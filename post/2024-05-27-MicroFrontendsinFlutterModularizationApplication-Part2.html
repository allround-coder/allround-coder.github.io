<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2" data-gatsby-head="true"/><meta name="twitter:title" content="플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 19:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이전 부분에서는 장단점을 논의하고 구현해야 할 아이디어를 기록했습니다. 이 기사를 처음으로 본 독자들도 있을 것이므로, 우선 part 1을 읽어보세요. 물론, 다시 언급해야 할 부분이 있어요. 시작하기 전에 모두 완료해야 할 체크리스트가 있는지 확인하세요.</p>
<p><img src="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png" alt="image"></p>
<h1>구현</h1>
<p>이번 파트에서 (마지막인지는 확실하지 않아요 😀), 전통적인 템플릿에 따라 프로젝트를 모듈화해 보겠습니다. 여기에 간단한 프로젝트를 만들었습니다. 로그인 및 홈 화면이 있고 목록보기가 딸려 있는 Clean Architecture를 따릅니다.
말만 하는 것보다는 코드를 보여줘! 라는 '하드코더'들을 위해, 이번 모듈화 후 프로젝트의 전체 소스 코드입니다. 이 기사를 읽은 후에 먼저 확인해보세요.</p>
<ol>
<li>패키지 관리
프로젝트 내의 모든 패키지를 관리하기 위해 패키지 관리가 필요합니다. 예를 들어, 각 모듈에서 한 번에 pub get, build_runner 또는 gen-l10n을 실행할 수 있습니다. 다행히도, invertase에서 개발한 melos를 알아내다.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-attr">name</span>: flutter-micro-frontend
<span class="hljs-attr">packages</span>:
  - modules<span class="hljs-comment">/*
command:
  bootstrap:
    runPubGetInParallel: false
scripts:
  gen-l10n:
    exec: flutter gen-l10n
    ignoreErrors: true
</span></code></pre>
<p>위와 같은 구성이 필요하므로, melos bootstrap을 실행하여 모든 패키지 내의 종속성을 가져올 수 있고, melos gen-l10n을 실행하여 언어 파일을 생성할 수 있습니다. 아주 쉽죠.</p>
<ol start="2">
<li>UI 모듈</li>
</ol>
<ul>
<li>참고: 패키지와 Dart 패키지의 생성에 대해 알아보고, 패키지와 Dart 패키지의 구조를 배우세요.</li>
</ul>
<p><img src="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_1.png" alt="이미지"></p>
<p>이것은 UI 모듈의 작은 버전입니다. 물론 큰 프로젝트나 다른 비즈니스 프로젝트의 경우 구조가 다를 수 있습니다. 이 모듈 내부에는 다음 사항을 확인하세요:</p>
<ul>
<li>너무 복잡한 로직이 아니라 UI 요소만 존재합니다.</li>
<li>각 카테고리(대화 상자, 목록보기 등)에 대해 모든 구체적 요소를 내보내는 내보내기 파일이 있어야 합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-string">'grid_view_load_more.dart'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-string">'list_view_load_more.dart'</span>;
</code></pre>
<ul>
<li>전체 앱에서 font를 사용하기 위해 여기에 추가하고 ui_theme에 추가해야 합니다. package/ui/assets/fonts/SFProText-Regular.ttf와 같이 경로 앞에 항상 package/ui가 있어야 합니다.</li>
<li>Main App의 localizationsDelegates 안에 추가하기 위해 LocalizationsDelegate를 export해야 합니다.</li>
</ul>
<p>이게 전부에요. 이 package에 대해 더 이상 논의할 주제는 없습니다.</p>
<ol start="3">
<li>Core Module</li>
</ol>
<p><img src="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_2.png" alt="이미지"></p>
<p>앱 전체와 다른 모듈의 뼈대입니다. 이 모듈 내의 코드를 추가하거나 수정할 때 신중히 고려해 주세요. 몇 가지 주의 사항이 있어요:</p>
<ul>
<li>기존 프로젝트에서는 상태 관리, 네비게이션 및 종속성 주입에 Get을 사용했지만, 모듈화할 때는 순수한 Flutter 네비게이션과 get_it을 사용합니다. 이는 모듈을 만들 때 다른 라이브러리에 너무 의존하지 않도록 하기 위함입니다. 모듈을 많은 곳에서 재사용하려면 심지어 파트너 앱 내에서도 모듈을 사용한다는 보장이 없으므로 Get을 사용하고 있다는 가정을 할 수 없습니다. 따라서 모듈이나 패키지를 만들 때 다른 라이브러리에 가능한 많이 의존하지 않도록 노력해 주세요.</li>
<li>여전히 상태 관리에 Get을 사용했기 때문에 여기에는 일부 베이스 뷰와 베이스 컨트롤러가 있습니다. BLoC를 선호하는 경우 BLoC용 베이스 코드도 있습니다. 그러나 이상적으로는 동기화를 위해 모든 모듈에 하나의 상태 관리만 사용해야 합니다.</li>
<li>이 모듈은 여전히 Clean Architecture를 따릅니다. API 호출을 위해 Dio와 Retrofit을 사용했습니다. 따라서 여기서 dio와 일부 설정을 만들겠습니다.</li>
<li>core 내에서 사용한 모든 기타 서드파티 패키지를 내보내는 libs.dart가 있습니다. 다른 패키지 내에서 이를 사용하거나 수정해야 할 경우, 핵심 모듈을 가져오기만 하면 됩니다.</li>
</ul>
<p><img src="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_3.png" alt="이미지"></p>
<ol start="4">
<li>주요 애플리케이션
주요 애플리케이션으로 돌아갑니다. UI 모듈에서 말했듯이, MaterialApp에 localizationsDelegates 및 테마를 추가해야 합니다. 이것이 앱 구성에 관한 전부입니다. 임시로 빈 Splash 화면과 홈 화면을 만듭니다. 기능 모듈을 몇 개 개발하고 그것에 추가할 것입니다.</li>
</ol>
<p>좋은 준비가 되었습니다. 이제 첫 번째 모듈을 구현하기 시작합니다. 대부분의 시스템이 필요로 하는 인증입니다.</p>
<ol start="5">
<li>인증 모듈
의존성은 Auth.start(context)를 호출하면 됩니다. 그런 다음 다음 비즈니스를 위한 결과를 얻습니다. 로그인, 등록, 비밀번호 재설정, OTP 등과 같은 모든 로직 또는 UI 페이지는 이 모듈에서 구현될 것입니다. 이것이 놀랍군요. 주요 앱은 인증에 대한 어떤 로직도 알지 못했습니다.</li>
</ol>
<ul>
<li>보시다시피, 리포지토리, 클라이언트 또는 유스케이스와 같은 각 클래스/파일에 auth 접두사를 추가할 필요가 없습니다.</li>
<li>세션 관리, 액세스 토큰 저장, 리프레시 토큰과 같은 것은 이 모듈 안에서만 구현했습니다.</li>
<li>전체 인증 모듈의 모든 로직을 관리하는 AuthController가 있습니다. 이는 모든 다른 클래스가 호출할 수 있는 전역 스트림과 같은 것입니다. 그 안에 있는 코드 일부를 살펴보겠습니다.</li>
</ul>
<pre><code class="hljs language-js">  late <span class="hljs-title class_">Completer</span> completer;

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">auth</span>(<span class="hljs-params">BuildContext context</span>) {
    completer = <span class="hljs-title class_">Completer</span>();
    final result = <span class="hljs-title class_">CheckIsLoggedInUseCase</span>(<span class="hljs-title class_">GetIt</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">get</span>&#x3C;<span class="hljs-title class_">Repository</span>>()).<span class="hljs-title function_">execute</span>();
    result.<span class="hljs-title function_">fold</span>((left) {
      <span class="hljs-keyword">if</span> (left) {
        completer.<span class="hljs-title function_">complete</span>();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title class_">Navigator</span>.<span class="hljs-title function_">pushAndRemoveUntil</span>(context, <span class="hljs-title class_">Routes</span>.<span class="hljs-title function_">checkPhone</span>(), <span class="hljs-function">(<span class="hljs-params">route</span>) =></span> <span class="hljs-literal">false</span>);
      }
    }, (right) {
      <span class="hljs-title function_">showError</span>(context, right);
    });
    <span class="hljs-keyword">return</span> completer.<span class="hljs-property">future</span>;
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">loginSuccessfully</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!completer.<span class="hljs-property">isCompleted</span>) {
      completer.<span class="hljs-title function_">complete</span>();
    }
  }
</code></pre>
<p>다른 화면이 loginSuccessfully()를 호출할 때마다, AuthController가 결과를 반환하고 인증 프로세스를 완료합니다.</p>
<p>메인 애플리케이션의 스플래시 화면으로 돌아와서, auth 함수를 호출하기만 하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SplashController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BaseController</span> {
  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReady</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onReady</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Auth</span>.<span class="hljs-title function_">start</span>(<span class="hljs-title class_">Get</span>.<span class="hljs-property">context</span>);
    <span class="hljs-title function_">_goToHome</span>();
  }

<span class="hljs-keyword">void</span> <span class="hljs-title function_">_goToHome</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">Get</span>.<span class="hljs-title function_">offNamedUntil</span>(<span class="hljs-title class_">MainRouteName</span>.<span class="hljs-property">home</span>, <span class="hljs-function">(<span class="hljs-params">route</span>) =></span> <span class="hljs-literal">false</span>);
  }
}
</code></pre>
<p>너무 좋네요! 인증 프로세스가 완료되면 홈 화면이 열릴 거예요. 완벽해요!!!</p>
<ol start="6">
<li>제품 모듈
이것은 데모하고 싶은 샘플 모듈뿐이에요. 거의 모든 일반 모듈이 동일한 개념을 가지고 있어요:</li>
</ol>
<p><img src="/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_5.png" alt="이미지"></p>
<p>이 데모에서는 홈 화면용 HomeProductWidget을 export해야 합니다. 이 모듈에 대해 이전 모듈을 알고 있다면 더 이상 언급할 것이 없습니다. 홈 화면 안에서 다음과 같이 호출하기만 하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:product/product.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeScreen</span>({<span class="hljs-title class_">Key</span> key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeProductWidget</span>();
  }
}
</code></pre>
<p>여기서 앱을 완전히 모듈화했습니다.</p>
<p>모듈화된 프로젝트의 전체 소스 코드입니다.</p>
<h1>결론</h1>
<p>모듈화는 앱 개발에서 모듈화, 코드 재사용성 및 확장성을 장려하는 아키텍처 패턴으로 인기를 얻고 있습니다. 물론, 비즈니스와 리소스에 따라 전통적인 아키텍처를 사용하거나 패키지로 분리할 수도 있습니다.</p>
<p>이 글에서 무언가를 배웠다면 좋아요를 눌러주시기 바랍니다. 만일 앱을 모듈화하는 과정에서 혼란이 있거나 문제가 발생한다면 댓글을 남겨주시고 함께 공부해보도록 하겠습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터에서의 마이크로 프론트엔드 모듈화 응용 프로그램","description":"","date":"2024-05-27 19:17","slug":"2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2","content":"\n이전 부분에서는 장단점을 논의하고 구현해야 할 아이디어를 기록했습니다. 이 기사를 처음으로 본 독자들도 있을 것이므로, 우선 part 1을 읽어보세요. 물론, 다시 언급해야 할 부분이 있어요. 시작하기 전에 모두 완료해야 할 체크리스트가 있는지 확인하세요.\n\n![image](/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png)\n\n# 구현\n\n이번 파트에서 (마지막인지는 확실하지 않아요 😀), 전통적인 템플릿에 따라 프로젝트를 모듈화해 보겠습니다. 여기에 간단한 프로젝트를 만들었습니다. 로그인 및 홈 화면이 있고 목록보기가 딸려 있는 Clean Architecture를 따릅니다.\n말만 하는 것보다는 코드를 보여줘! 라는 '하드코더'들을 위해, 이번 모듈화 후 프로젝트의 전체 소스 코드입니다. 이 기사를 읽은 후에 먼저 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*xv3Fj652XewSzSdgdXmniw.gif\" /\u003e\n\n1. 패키지 관리\n   프로젝트 내의 모든 패키지를 관리하기 위해 패키지 관리가 필요합니다. 예를 들어, 각 모듈에서 한 번에 pub get, build_runner 또는 gen-l10n을 실행할 수 있습니다. 다행히도, invertase에서 개발한 melos를 알아내다.\n\n```js\nname: flutter-micro-frontend\npackages:\n  - modules/*\ncommand:\n  bootstrap:\n    runPubGetInParallel: false\nscripts:\n  gen-l10n:\n    exec: flutter gen-l10n\n    ignoreErrors: true\n```\n\n위와 같은 구성이 필요하므로, melos bootstrap을 실행하여 모든 패키지 내의 종속성을 가져올 수 있고, melos gen-l10n을 실행하여 언어 파일을 생성할 수 있습니다. 아주 쉽죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. UI 모듈\n\n- 참고: 패키지와 Dart 패키지의 생성에 대해 알아보고, 패키지와 Dart 패키지의 구조를 배우세요.\n\n![이미지](/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_1.png)\n\n이것은 UI 모듈의 작은 버전입니다. 물론 큰 프로젝트나 다른 비즈니스 프로젝트의 경우 구조가 다를 수 있습니다. 이 모듈 내부에는 다음 사항을 확인하세요:\n\n- 너무 복잡한 로직이 아니라 UI 요소만 존재합니다.\n- 각 카테고리(대화 상자, 목록보기 등)에 대해 모든 구체적 요소를 내보내는 내보내기 파일이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport 'grid_view_load_more.dart';\nexport 'list_view_load_more.dart';\n```\n\n- 전체 앱에서 font를 사용하기 위해 여기에 추가하고 ui_theme에 추가해야 합니다. package/ui/assets/fonts/SFProText-Regular.ttf와 같이 경로 앞에 항상 package/ui가 있어야 합니다.\n- Main App의 localizationsDelegates 안에 추가하기 위해 LocalizationsDelegate를 export해야 합니다.\n\n이게 전부에요. 이 package에 대해 더 이상 논의할 주제는 없습니다.\n\n3. Core Module\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_2.png)\n\n앱 전체와 다른 모듈의 뼈대입니다. 이 모듈 내의 코드를 추가하거나 수정할 때 신중히 고려해 주세요. 몇 가지 주의 사항이 있어요:\n\n- 기존 프로젝트에서는 상태 관리, 네비게이션 및 종속성 주입에 Get을 사용했지만, 모듈화할 때는 순수한 Flutter 네비게이션과 get_it을 사용합니다. 이는 모듈을 만들 때 다른 라이브러리에 너무 의존하지 않도록 하기 위함입니다. 모듈을 많은 곳에서 재사용하려면 심지어 파트너 앱 내에서도 모듈을 사용한다는 보장이 없으므로 Get을 사용하고 있다는 가정을 할 수 없습니다. 따라서 모듈이나 패키지를 만들 때 다른 라이브러리에 가능한 많이 의존하지 않도록 노력해 주세요.\n- 여전히 상태 관리에 Get을 사용했기 때문에 여기에는 일부 베이스 뷰와 베이스 컨트롤러가 있습니다. BLoC를 선호하는 경우 BLoC용 베이스 코드도 있습니다. 그러나 이상적으로는 동기화를 위해 모든 모듈에 하나의 상태 관리만 사용해야 합니다.\n- 이 모듈은 여전히 Clean Architecture를 따릅니다. API 호출을 위해 Dio와 Retrofit을 사용했습니다. 따라서 여기서 dio와 일부 설정을 만들겠습니다.\n- core 내에서 사용한 모든 기타 서드파티 패키지를 내보내는 libs.dart가 있습니다. 다른 패키지 내에서 이를 사용하거나 수정해야 할 경우, 핵심 모듈을 가져오기만 하면 됩니다.\n\n![이미지](/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 주요 애플리케이션\n   주요 애플리케이션으로 돌아갑니다. UI 모듈에서 말했듯이, MaterialApp에 localizationsDelegates 및 테마를 추가해야 합니다. 이것이 앱 구성에 관한 전부입니다. 임시로 빈 Splash 화면과 홈 화면을 만듭니다. 기능 모듈을 몇 개 개발하고 그것에 추가할 것입니다.\n\n좋은 준비가 되었습니다. 이제 첫 번째 모듈을 구현하기 시작합니다. 대부분의 시스템이 필요로 하는 인증입니다.\n\n5. 인증 모듈\n   의존성은 Auth.start(context)를 호출하면 됩니다. 그런 다음 다음 비즈니스를 위한 결과를 얻습니다. 로그인, 등록, 비밀번호 재설정, OTP 등과 같은 모든 로직 또는 UI 페이지는 이 모듈에서 구현될 것입니다. 이것이 놀랍군요. 주요 앱은 인증에 대한 어떤 로직도 알지 못했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 보시다시피, 리포지토리, 클라이언트 또는 유스케이스와 같은 각 클래스/파일에 auth 접두사를 추가할 필요가 없습니다.\n- 세션 관리, 액세스 토큰 저장, 리프레시 토큰과 같은 것은 이 모듈 안에서만 구현했습니다.\n- 전체 인증 모듈의 모든 로직을 관리하는 AuthController가 있습니다. 이는 모든 다른 클래스가 호출할 수 있는 전역 스트림과 같은 것입니다. 그 안에 있는 코드 일부를 살펴보겠습니다.\n\n```js\n  late Completer completer;\n\n  Future\u003cvoid\u003e auth(BuildContext context) {\n    completer = Completer();\n    final result = CheckIsLoggedInUseCase(GetIt.instance.get\u003cRepository\u003e()).execute();\n    result.fold((left) {\n      if (left) {\n        completer.complete();\n      } else {\n        Navigator.pushAndRemoveUntil(context, Routes.checkPhone(), (route) =\u003e false);\n      }\n    }, (right) {\n      showError(context, right);\n    });\n    return completer.future;\n  }\n\n  void loginSuccessfully() {\n    if (!completer.isCompleted) {\n      completer.complete();\n    }\n  }\n```\n\n다른 화면이 loginSuccessfully()를 호출할 때마다, AuthController가 결과를 반환하고 인증 프로세스를 완료합니다.\n\n메인 애플리케이션의 스플래시 화면으로 돌아와서, auth 함수를 호출하기만 하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass SplashController extends BaseController {\n  @override\n  void onReady() async {\n    super.onReady();\n    await Auth.start(Get.context);\n    _goToHome();\n  }\n\nvoid _goToHome() {\n    Get.offNamedUntil(MainRouteName.home, (route) =\u003e false);\n  }\n}\n```\n\n너무 좋네요! 인증 프로세스가 완료되면 홈 화면이 열릴 거예요. 완벽해요!!!\n\n6. 제품 모듈\n   이것은 데모하고 싶은 샘플 모듈뿐이에요. 거의 모든 일반 모듈이 동일한 개념을 가지고 있어요:\n\n![이미지](/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 데모에서는 홈 화면용 HomeProductWidget을 export해야 합니다. 이 모듈에 대해 이전 모듈을 알고 있다면 더 이상 언급할 것이 없습니다. 홈 화면 안에서 다음과 같이 호출하기만 하면 됩니다:\n\n```js\nimport 'package:product/product.dart';\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeProductWidget();\n  }\n}\n```\n\n여기서 앱을 완전히 모듈화했습니다.\n\n모듈화된 프로젝트의 전체 소스 코드입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n모듈화는 앱 개발에서 모듈화, 코드 재사용성 및 확장성을 장려하는 아키텍처 패턴으로 인기를 얻고 있습니다. 물론, 비즈니스와 리소스에 따라 전통적인 아키텍처를 사용하거나 패키지로 분리할 수도 있습니다.\n\n이 글에서 무언가를 배웠다면 좋아요를 눌러주시기 바랍니다. 만일 앱을 모듈화하는 과정에서 혼란이 있거나 문제가 발생한다면 댓글을 남겨주시고 함께 공부해보도록 하겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png"},"coverImage":"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이전 부분에서는 장단점을 논의하고 구현해야 할 아이디어를 기록했습니다. 이 기사를 처음으로 본 독자들도 있을 것이므로, 우선 part 1을 읽어보세요. 물론, 다시 언급해야 할 부분이 있어요. 시작하기 전에 모두 완료해야 할 체크리스트가 있는지 확인하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003cp\u003e이번 파트에서 (마지막인지는 확실하지 않아요 😀), 전통적인 템플릿에 따라 프로젝트를 모듈화해 보겠습니다. 여기에 간단한 프로젝트를 만들었습니다. 로그인 및 홈 화면이 있고 목록보기가 딸려 있는 Clean Architecture를 따릅니다.\n말만 하는 것보다는 코드를 보여줘! 라는 '하드코더'들을 위해, 이번 모듈화 후 프로젝트의 전체 소스 코드입니다. 이 기사를 읽은 후에 먼저 확인해보세요.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e패키지 관리\n프로젝트 내의 모든 패키지를 관리하기 위해 패키지 관리가 필요합니다. 예를 들어, 각 모듈에서 한 번에 pub get, build_runner 또는 gen-l10n을 실행할 수 있습니다. 다행히도, invertase에서 개발한 melos를 알아내다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: flutter-micro-frontend\n\u003cspan class=\"hljs-attr\"\u003epackages\u003c/span\u003e:\n  - modules\u003cspan class=\"hljs-comment\"\u003e/*\ncommand:\n  bootstrap:\n    runPubGetInParallel: false\nscripts:\n  gen-l10n:\n    exec: flutter gen-l10n\n    ignoreErrors: true\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 구성이 필요하므로, melos bootstrap을 실행하여 모든 패키지 내의 종속성을 가져올 수 있고, melos gen-l10n을 실행하여 언어 파일을 생성할 수 있습니다. 아주 쉽죠.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eUI 모듈\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e참고: 패키지와 Dart 패키지의 생성에 대해 알아보고, 패키지와 Dart 패키지의 구조를 배우세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이것은 UI 모듈의 작은 버전입니다. 물론 큰 프로젝트나 다른 비즈니스 프로젝트의 경우 구조가 다를 수 있습니다. 이 모듈 내부에는 다음 사항을 확인하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e너무 복잡한 로직이 아니라 UI 요소만 존재합니다.\u003c/li\u003e\n\u003cli\u003e각 카테고리(대화 상자, 목록보기 등)에 대해 모든 구체적 요소를 내보내는 내보내기 파일이 있어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'grid_view_load_more.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'list_view_load_more.dart'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e전체 앱에서 font를 사용하기 위해 여기에 추가하고 ui_theme에 추가해야 합니다. package/ui/assets/fonts/SFProText-Regular.ttf와 같이 경로 앞에 항상 package/ui가 있어야 합니다.\u003c/li\u003e\n\u003cli\u003eMain App의 localizationsDelegates 안에 추가하기 위해 LocalizationsDelegate를 export해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이게 전부에요. 이 package에 대해 더 이상 논의할 주제는 없습니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eCore Module\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e앱 전체와 다른 모듈의 뼈대입니다. 이 모듈 내의 코드를 추가하거나 수정할 때 신중히 고려해 주세요. 몇 가지 주의 사항이 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존 프로젝트에서는 상태 관리, 네비게이션 및 종속성 주입에 Get을 사용했지만, 모듈화할 때는 순수한 Flutter 네비게이션과 get_it을 사용합니다. 이는 모듈을 만들 때 다른 라이브러리에 너무 의존하지 않도록 하기 위함입니다. 모듈을 많은 곳에서 재사용하려면 심지어 파트너 앱 내에서도 모듈을 사용한다는 보장이 없으므로 Get을 사용하고 있다는 가정을 할 수 없습니다. 따라서 모듈이나 패키지를 만들 때 다른 라이브러리에 가능한 많이 의존하지 않도록 노력해 주세요.\u003c/li\u003e\n\u003cli\u003e여전히 상태 관리에 Get을 사용했기 때문에 여기에는 일부 베이스 뷰와 베이스 컨트롤러가 있습니다. BLoC를 선호하는 경우 BLoC용 베이스 코드도 있습니다. 그러나 이상적으로는 동기화를 위해 모든 모듈에 하나의 상태 관리만 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 모듈은 여전히 Clean Architecture를 따릅니다. API 호출을 위해 Dio와 Retrofit을 사용했습니다. 따라서 여기서 dio와 일부 설정을 만들겠습니다.\u003c/li\u003e\n\u003cli\u003ecore 내에서 사용한 모든 기타 서드파티 패키지를 내보내는 libs.dart가 있습니다. 다른 패키지 내에서 이를 사용하거나 수정해야 할 경우, 핵심 모듈을 가져오기만 하면 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e주요 애플리케이션\n주요 애플리케이션으로 돌아갑니다. UI 모듈에서 말했듯이, MaterialApp에 localizationsDelegates 및 테마를 추가해야 합니다. 이것이 앱 구성에 관한 전부입니다. 임시로 빈 Splash 화면과 홈 화면을 만듭니다. 기능 모듈을 몇 개 개발하고 그것에 추가할 것입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e좋은 준비가 되었습니다. 이제 첫 번째 모듈을 구현하기 시작합니다. 대부분의 시스템이 필요로 하는 인증입니다.\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e인증 모듈\n의존성은 Auth.start(context)를 호출하면 됩니다. 그런 다음 다음 비즈니스를 위한 결과를 얻습니다. 로그인, 등록, 비밀번호 재설정, OTP 등과 같은 모든 로직 또는 UI 페이지는 이 모듈에서 구현될 것입니다. 이것이 놀랍군요. 주요 앱은 인증에 대한 어떤 로직도 알지 못했습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e보시다시피, 리포지토리, 클라이언트 또는 유스케이스와 같은 각 클래스/파일에 auth 접두사를 추가할 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e세션 관리, 액세스 토큰 저장, 리프레시 토큰과 같은 것은 이 모듈 안에서만 구현했습니다.\u003c/li\u003e\n\u003cli\u003e전체 인증 모듈의 모든 로직을 관리하는 AuthController가 있습니다. 이는 모든 다른 클래스가 호출할 수 있는 전역 스트림과 같은 것입니다. 그 안에 있는 코드 일부를 살펴보겠습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  late \u003cspan class=\"hljs-title class_\"\u003eCompleter\u003c/span\u003e completer;\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eauth\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    completer = \u003cspan class=\"hljs-title class_\"\u003eCompleter\u003c/span\u003e();\n    final result = \u003cspan class=\"hljs-title class_\"\u003eCheckIsLoggedInUseCase\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGetIt\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eRepository\u003c/span\u003e\u003e()).\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e();\n    result.\u003cspan class=\"hljs-title function_\"\u003efold\u003c/span\u003e((left) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (left) {\n        completer.\u003cspan class=\"hljs-title function_\"\u003ecomplete\u003c/span\u003e();\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eNavigator\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epushAndRemoveUntil\u003c/span\u003e(context, \u003cspan class=\"hljs-title class_\"\u003eRoutes\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeckPhone\u003c/span\u003e(), \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      }\n    }, (right) {\n      \u003cspan class=\"hljs-title function_\"\u003eshowError\u003c/span\u003e(context, right);\n    });\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e completer.\u003cspan class=\"hljs-property\"\u003efuture\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloginSuccessfully\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!completer.\u003cspan class=\"hljs-property\"\u003eisCompleted\u003c/span\u003e) {\n      completer.\u003cspan class=\"hljs-title function_\"\u003ecomplete\u003c/span\u003e();\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 화면이 loginSuccessfully()를 호출할 때마다, AuthController가 결과를 반환하고 인증 프로세스를 완료합니다.\u003c/p\u003e\n\u003cp\u003e메인 애플리케이션의 스플래시 화면으로 돌아와서, auth 함수를 호출하기만 하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSplashController\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eBaseController\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonReady\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonReady\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAuth\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtext\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003e_goToHome\u003c/span\u003e();\n  }\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_goToHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eoffNamedUntil\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMainRouteName\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehome\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eroute\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e너무 좋네요! 인증 프로세스가 완료되면 홈 화면이 열릴 거예요. 완벽해요!!!\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e제품 모듈\n이것은 데모하고 싶은 샘플 모듈뿐이에요. 거의 모든 일반 모듈이 동일한 개념을 가지고 있어요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 데모에서는 홈 화면용 HomeProductWidget을 export해야 합니다. 이 모듈에 대해 이전 모듈을 알고 있다면 더 이상 언급할 것이 없습니다. 홈 화면 안에서 다음과 같이 호출하기만 하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:product/product.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeProductWidget\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 앱을 완전히 모듈화했습니다.\u003c/p\u003e\n\u003cp\u003e모듈화된 프로젝트의 전체 소스 코드입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e모듈화는 앱 개발에서 모듈화, 코드 재사용성 및 확장성을 장려하는 아키텍처 패턴으로 인기를 얻고 있습니다. 물론, 비즈니스와 리소스에 따라 전통적인 아키텍처를 사용하거나 패키지로 분리할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서 무언가를 배웠다면 좋아요를 눌러주시기 바랍니다. 만일 앱을 모듈화하는 과정에서 혼란이 있거나 문제가 발생한다면 댓글을 남겨주시고 함께 공부해보도록 하겠습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-MicroFrontendsinFlutterModularizationApplication-Part2"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>