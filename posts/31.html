<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" href="/post/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다" href="/post/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 " href="/post/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 </strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Execa 9 저희의 가장 큰 릴리스" href="/post/2024-05-14-Execa9ourbiggestrelease"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Execa 9 저희의 가장 큰 릴리스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Execa 9 저희의 가장 큰 릴리스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Execa 9 저희의 가장 큰 릴리스</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="위대한 JavaScript 분할 CommonJS vs ES Modules" href="/post/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="위대한 JavaScript 분할 CommonJS vs ES Modules" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="위대한 JavaScript 분할 CommonJS vs ES Modules" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">위대한 JavaScript 분할 CommonJS vs ES Modules</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스" href="/post/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 Role-Based Access Control RBAC 구현하기" href="/post/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 Role-Based Access Control RBAC 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 Role-Based Access Control RBAC 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 Role-Based Access Control RBAC 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="서버 측 JavaScript의 진화" href="/post/2024-05-14-EvolutionofServer-SideJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="서버 측 JavaScript의 진화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="서버 측 JavaScript의 진화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">서버 측 JavaScript의 진화</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 - Strict Mode는 어떻게 작동하나요" href="/post/2024-05-14-JavaScriptStrictModeHowDoesItWork"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 - Strict Mode는 어떻게 작동하나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 - Strict Mode는 어떻게 작동하나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 - Strict Mode는 어떻게 작동하나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드" href="/post/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법","description":"","date":"2024-05-14 15:00","slug":"2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png\" /\u003e\n\nGET 및 POST 엔드포인트는 REST API에서 가장 일반적인 엔드포인트 중 두 가지입니다. GET 엔드포인트를 사용하면 클라이언트가 서버에서 데이터를 검색할 수 있고, POST 엔드포인트를 사용하면 클라이언트가 서버로 데이터를 보낼 수 있습니다. 여기에서는 NodeJS와 ExpressJS를 사용하여 필수 GET 및 POST 엔드포인트를 만드는 방법을 보여드릴 거에요.\n\n# GET 엔드포인트 생성\n\nGET 엔드포인트를 만들려면 app.get() 메서드를 사용할 수 있어요. 이 메서드는 두 개의 매개변수를 가지는데, 첫 번째는 엔드포인트의 경로이고, 두 번째는 클라이언트가 엔드포인트에 GET 요청을 할 때마다 실행될 콜백 함수입니다.\n\n\n\n다음은 /users-list 경로에 GET 엔드포인트를 만드는 방법의 예시입니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.get('/users-list', (req, res) =\u003e {\n  // 사용자 목록 전체를 가져옵니다\n  const usersList = [];\n\n  // 사용자 목록을 클라이언트에 응답으로 전송합니다\n  res.send(usersList);\n});\n```\n\n다음은 위에서 만든 엔드포인트를 사용하여 GET 요청을 보내는 방법의 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nfetch('http://localhost:3000/users-list')\n  .then(response =\u003e response.json())\n  .then(usersList =\u003e {\n    console.log(usersList.data);\n    // 응답으로 수행하려는 동작을 작성합니다\n  })\n  .catch(error =\u003e {\n    console.log(error);\n    // 요청이 성공적이지 않을 때의 오류를 처리합니다\n  });\n```\n\n\n\n만일 이 엔드포인트를 테스트하고 싶다면, Postman에서 다음 단계를 따르세요:\n\n- Postman을 열고 새 요청을 생성하세요.\n- HTTP 메소드를 GET으로 설정하세요.\n- URL을 http://localhost:3000/users-list로 설정하세요.\n- 보내기 버튼을 클릭하여 요청을 보내세요.\n\n가끔은 GET 요청과 함께 쿼리 매개변수를 보내야 할 때가 있습니다. 여기에 간단한 코드 조각이 있습니다:\n\n```js\nconst express = require('express');\nconst app = express();\napp.get('/users-list/:id', (req, res) =\u003e {\n  const id = req.params.id;\n  // 데이터베이스에서 사용자 데이터 가져오기\n  const user = {\n    id: 1,\n    name: 'John Doe',\n  };\n  // 클라이언트에 응답 보내기\n  res.send({\n    user: user,\n  });\n});\n```\n\n\n\n# POST 엔드포인트 생성하기\n\nPOST 엔드포인트를 만들려면 app.post() 메소드를 사용할 수 있어요. 이 함수는 app.get() 메소드와 유사하게 두 개의 매개변수를 사용해요. 하지만 여기서는 콜백 함수에서 요청 바디인 즉, 클라이언트가 요청할 때 보내는 데이터에 접근할 수 있어요. 이 엔드포인트를 사용하여 새로운 사용자를 만들 수 있어요.\n\n다음은 /users-list 경로에 POST 엔드포인트를 만드는 예시에요:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.post('/users-list', (req, res) =\u003e {\n  const usersList = req.body;\n\n  // 클라이언트가 보낸 사용자 데이터를 저장해요\n\n  // 요청이 성공적이었음을 보여주는 응답을 클라이언트에게 보내요\n  res.send({\n    message: '새 사용자가 목록에 추가되었어요',\n  });\n});\n```\n\n\n\n위에서 만든 엔드포인트를 사용하여 POST 요청을 보내는 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nconst user = {\n  name: \"John Doe\",\n  email: \"john.doe@example.com\"\n};\n\nfetch('http://localhost:3000/users-list', {\n  method: 'POST',\n  body: JSON.stringify(user)\n})\n  .then(response =\u003e {\n    console.log(response.data);\n  })\n  .catch(error =\u003e {\n    console.log(error);\n});\n```\n\n아래는 이 엔드포인트를 Postman에서 테스트하는 방법에 대한 단계입니다:\n\n- Postman을 열고 새 요청을 작성합니다.\n- HTTP 메서드를 POST로 설정합니다.\n- URL을 http://localhost:3000/users-list로 설정합니다.\n- Body 탭에서 content-type 헤더를 application/json로 설정합니다.\n- 그런 다음 보내고 싶은 JSON 데이터를 본문 탭에 붙여넣습니다.\n- Send 버튼을 클릭하여 요청을 보냅니다.\n\n\n\n위에 제시된 예시들은 매우 기본적이고 데모 목적으로 제공되었어요. 그러나 당신의 요구에 따라 더 복잡한 엔드포인트를 생성하기 위해 같은 단계를 따를 수 있어요.\n\n아래는 엔드포인트를 생성하는 동안 고려할 수 있는 몇 가지 추가 팁이에요:\n\n- 개발자가 실제로 엔드포인트가 무엇을 하는지 이해하는 데 도움이 되는 설명적인 엔드포인트 경로를 사용하세요.\n- POST 엔드포인트의 요청 본문을 유효성 검사할 수도 있어요. 이것은 받는 데이터가 올바른 형식에 있는지 확인하는 추가적인 검사층 역할을 해요.\n- 가능하다면 팀 내 다른 개발자에게 쉽게 엔드포인트를 설명할 수 있는 철저한 문서를 유지하는 것이 좋아요.\n\n위의 정보가 도움이 되었기를 바래요. 읽어주셔서 감사해요. 질문, 의견 또는 관심사가 있으면 아래에 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다","description":"","date":"2024-05-14 14:59","slug":"2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame","content":"\n\n![Node.js is Dying, Bun 1.0 is Changing the JavaScript Game](/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png)\n\n그 이전에, 자바스크립트 런타임이 무엇이며 왜 속도에 대해 신경 써야 하는지 설명해야 합니다.\n\n자바스크립트로 이야기를 쓰고 누군가에게 읽어달라고 부탁했다고 상상해보세요. 자바스크립트 런타임은 당신의 이야기를 살아있게 만드는 친근한 서술자 같은 존재입니다! 이것은 당신의 자바스크립트 이야기가 읽히고 연기되는 특별한 환경입니다. 하지만 좀 더 깊게 들어가보죠. 기술적으로, 이 '서술자'는 자바스크립트 엔진과 같은 구성 요소로 구성되어 있습니다. 이 엔진은 런타임의 핵심으로서 코드를 이해하고 실행하는 일을 담당합니다. 이것은 업무를 실행하고 코드가 스스로 걸림돌에 걸리지 않도록 하는 이벤트 루프와 같은 도구와 함께 사용됩니다. 또한 모든 캐릭터(또는 변수)가 각자 공간을 가지는 메모리 힙이 포함되어 있습니다. 씬별로 이야기의 액션이 일어나는 곳을 추적하는 호출 스택도 있습니다.\n\n# Bun 1.0 소개\n\n\n\nBun은 인기 있는 Node JS와 Deno보다 여러 가지 주요 장점을 가지고 있는 새로운 JavaScript 런타임입니다. Bun은 앱을 더 빠르게 만들기 위해 코드에 추가 복잡성을 추가할 필요 없이 설계되었습니다.\n\nNode.js의 대체물로 만들어졌기 때문에 Bun을 사용할 때는 node나 nodemon이 필요하지 않습니다. Bun은 내장된 감시 모드, dotenv, cross-env를 갖추고 있으며 .env 파일을 기본적으로 읽습니다.\n\n또한 Bun은 .js, .ts, .mjs, .jsx, .cjs, .tsx와 같은 다양한 파일을 실행할 수 있기 때문에 이제 프로젝트에 babel, tsc, ts-node 및 tsx를 설치할 필요가 없습니다.\n\nBun은 놀라운 성능을 자랑하는 JavaScript 번들러이며 esbuild 호환 플러그인 API를 제공하므로 esbuild, webpack 및 parcel도 필요하지 않습니다.\n\n\n\nBun은 npm과 yarn보다 빠른 속도가 가장 큰 이점 중 하나입니다. Bun은 npm과 yarn에 있는 익숙한 모든 명령어를 사용할 수 있는 npm 호환 패키지 매니저입니다. 또한 package.json 파일을 읽고 node_modules에 쓰지만 30배 빠르기 때문에 게임 체인저입니다.\n\n기본으로 Jest와 호환되는 테스트 러너를 내장하고 있어 추가 종속성을 설치하지 않고도 단위 테스트를 작성할 수 있습니다.\n\nNode.js의 대체할 수 있는 디자인으로 개발되었기 때문에 path, fs, net과 같은 일반적인 Node.js 모듈과 __dirname, process와 같은 전역 변수를 내장 지원합니다.\n\n# 성능 비교\n\n\n\n우리가 말했듯이 Bun은 Node.js보다 4배 빠르기 때문에 코드가 가벼워지고 실행 시간이 짧아지는데, 사용하기도 간단해요.\n\n```js\n$ bun install \n```\n\n\u003cimg src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_1.png\" /\u003e\n\n테스트를 실행하는 차이는 더 미친 것 같아요.\n\n\n\n```js\n$ bun test\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_2.png\" /\u003e\n\n사용하기 쉽습니다. 다음은 Bun을 사용하여 HTTP 서버를 만드는 예제입니다.\n\n```js\nconst server = Bun.serve({\n  port: 3000,\n  fetch(request) {\n    return new Response(“Bun에 오신 것을 환영합니다!\");\n  },\n});\n\nconsole.log(`localhost:${server.port}에서 서버를 대기 중입니다`);\n```\n\n\n\n# Bun이 Node.JS를 대체해야 할까요?\n\n요약하면, Bun은 자바스크립트 세계에서 새롭고 멋진 장난감 같은 존재입니다. 다음 프로젝트에 무엇을 사용할지 고민 중이라면 Bun을 한 번 시도해보는 것을 권해드립니다. 신뢰성이 있고, Node.js에 없는 멋진 기능들을 갖추고 있으며 빠르기도 합니다.\n\nBun 팀이 다음에 어떤 일을 할지 기대되네요. 그리고 더 자세히 알고 싶다면, [공식 안내서](링크)를 확인해보세요. 필요한 모든 세부 정보가 담겨 있답니다!\n\nBun에 대한 생각은 어떠신가요? Node.js를 대체할 것인가요? 아래 댓글에서 함께 토론해보세요!\n\n\n\n# 친근한 한국어 번역\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾을 수 있어요. 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터(X), 링크드인, 유튜브, 디스코드에서 우리를 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png"},"coverImage":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png","tag":["Tech"],"readingTime":3},{"title":"Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 ","description":"","date":"2024-05-14 14:58","slug":"2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices","content":"\n\nNode.js 개발의 광활한 우주에서 SOLID 원칙을 숙달하면 튼튼하고 유지보수가 쉽며 확장 가능한 애플리케이션을 만들 수 있는 우주선이 될 것입니다. 🛸 SOLID 우주를 탐험하며 각 원칙을 실제 예제와 코드 스니펫과 함께 살펴봅시다.\n\n## 단일 책임 원칙 (SRP) 🎯\n\n하나의 임무를 가진 우주선을 상상해보세요: 먼 행성으로 화물을 전달하는 것. 마찬가지로 Node.js에서 각 모듈은 하나의 명확한 목적을 가져야 합니다.\n\n예시: 사용자 서비스 모듈 🤖\n\n\n\nDo:\n\n```js\n// userService.js\nconst getUserById = (userId) =\u003e {\n  // 데이터베이스에서 사용자를 가져오는 로직\n};\n\nconst updateUser = (userId, newData) =\u003e {\n  // 데이터베이스에서 사용자를 업데이트하는 로직\n};\n\nmodule.exports = { getUserById, updateUser };\n```\n\nDon't:\n\n```js\n// IncorrectUserService.js\nconst userController = require('./userController');\n\nconst getUserByIdAndUpdate = (userId, newData) =\u003e {\n  // 같은 함수에서 사용자를 가져오고 업데이트하는 로직\n};\n```\n\n\n\n## 개방/폐쇄 원칙 (OCP) 🚪\n\n우주선의 문이 우주의 진공으로부터 닫혀있는 것처럼, 모듈은 확장을 위해 열려있지만 수정을 위해서는 닫혀있어야 합니다.\n\n예시: Logger 모듈 📝\n\n올바른 방법:\n\n\n\n```js\n// logger.js\nclass Logger {\n  log(message) {\n    // 메시지를 기록하는 로직\n  }\n}\nmodule.exports = Logger;\n```\n\n하지 말아야 할 것:\n\n```js\n// IncorrectLogger.js\nconst logger = require('./logger');\n\nlogger.customLog = (message, level) =\u003e {\n  // 사용자 정의 로깅 로직\n};\n```\n\n## 리스코프 치환 원칙 (LSP) 🧩\n\n\n\n\n소프트웨어 개발의 광대한 은하 속에서, 하위 클래스는 혼돈을 초래하지 않으면서 상위 클래스의 역할을 원활하게 수행해야 합니다.\n\n예: 데이터베이스 어댑터 📡\n\n올바르게 적용하라:\n\n```js\n// dbAdapter.js\nclass DatabaseAdapter {\n  connect() {\n    // 데이터베이스에 연결하는 로직\n  }\n}\n\nmodule.exports = DatabaseAdapter;\n```\n\n\n\n좋은 동료! 😊\n\n다음과 같이 변경해주실 수 있을까요?:\n\n\n```js\n// IncorrectDBAdapter.js\nclass MongoDBAdapter extends DatabaseAdapter {\n  connectToMongoDB() {\n    // Logic to connect specifically to MongoDB\n}\n```\n\n## Interface Segregation Principle (ISP) 🛠️\n\n만능 도구가 다양한 작업에 적응할 수 있는 것처럼, 인터페이스는 불필요한 메서드를 난잡하게 늘리지 않고 특정 필요에 맞게 설계되어야 합니다.\n\n\n\n예시: 인증 모듈 🔐\n\n다음과 같이 하세요:\n\n```js\n// auth.js\nclass Auth {\n  login(username, password) {\n    // 사용자 인증 로직\n  }\n  logout() {\n      // 사용자 로그아웃 로직\n    }\n  }\nmodule.exports = Auth;\n```\n\n하지 말아주세요:\n\n\n\n```js\n// IncorrectAuth.js\nclass Auth {\n  login(username, password) {\n    // 사용자를 인증하기 위한 로직\n  }\n  deleteUser(userId) {\n    // 사용자 삭제를 위한 관련 없는 메서드\n  }\n}\n```\n\n## 의존 역전 원칙 (DIP) 🔄\n\n의존성의 끊임없이 변화하는 우주에서, 고수준 모듈은 구체적인 구현이 아닌 추상화를 바라봐야 합니다.\n\n예시: 이메일 서비스 📧\n\n\n\n\n아래와 같이 변경해 주세요:\n\n```md\n// emailService.js\nclass EmailService {\n  sendEmail(to, subject, body) {\n    // 이메일을 보내는 로직\n  }\n}\n\nmodule.exports = EmailService;\n```\n\n```md\n// IncorrectEmailService.js\nconst nodemailer = require('nodemailer');\n\nconst sendEmail = (to, subject, body) =\u003e {\n  // nodemailer를 직접 사용하여 이메일을 보내는 로직\n};\n```\n\n\n\n이러한 SOLID 원칙에 따라 Node.js 프로젝트를 조정함으로써, 우리는 자신감과 미련으로 소프트웨어 개발의 광대한 우주를 탐험할 수 있습니다. 🌌 행복한 코딩, 동료 우주 탐험가 여러분! 🚀","ogImage":{"url":"/assets/img/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices_0.png","tag":["Tech"],"readingTime":3},{"title":"Execa 9 저희의 가장 큰 릴리스","description":"","date":"2024-05-14 14:56","slug":"2024-05-14-Execa9ourbiggestrelease","content":"\n\n```md\n![Execa](/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png)\n\nExeca는 스크립트, 애플리케이션 또는 라이브러리에서 명령을 실행합니다. zx와 Bun 쉘과는 달리, Execa는 쉘과 Bash 스크립트의 옛날과 거리를 둡니다. 대신, 현대적이고 완전히 JavaScript 방식을 채택하여 프로그래밍적 사용에 최적화되었습니다. 이러한 접근 방식은 명령 실행을 간단하고 안전하며 크로스 플랫폼이며 디버깅하기 쉽게 만듭니다.\n\n```js\nimport {$} from 'execa';\n\nconst tokensUrl = 'https://example.com/api/tokens';\nconst token = await $`curl ${tokensUrl}`\n  .pipe`grep api_token`\n  .pipe`head -n 1`;\n\nconst branch = await $`git branch --show-current`;\n\nconst logFile = 'logs.txt';\nawait $({stderr: logFile})`dep deploy\n  --parallel\n  --token=${token}\n  --branch=${branch}`;\n```\n\n프로젝트가 8년 된 이후에도 매우 활발하게 유지되고 있습니다. 사실, 오늘의 릴리스는 지금까지의 가장 큰 릴리스로, 6명의 기여자, 개발 9개월, 317개 PR 및 3915개 자동화된 테스트가 포함되었습니다. 여기에 몇 가지 새로운 기능 중 일부를 강조해보겠습니다.\n\n\n\n\n# 출력을 한 줄씩 읽기\n\n만약 명령어가 오랜 시간 동안 실행된다면, 여전히 실행 중일 때 출력을 읽을 수도 있습니다. 대부분의 명령어는 텍스트 기반이므로, 일반적으로 각 출력 라인을 반복하여 처리해야 합니다. 처음에는 간단해 보일 수 있지만, 실제로는 제대로 처리하는 것이 꽤 어려운 일이죠.\n\nExeca를 사용하면 명령어를 한 번에 한 줄씩 반복할 수 있습니다. lines 옵션을 사용하면 전체 출력을 여러 줄로 나눌 수도 있습니다.\n\n```js\nimport { execa } from 'execa';\n\n// 한 번에 한 줄씩\nfor await (const line of execa`npm run build`) {\n  if (line.includes('ERROR')) {\n    await reportError(line);\n  }\n}\n\n// 한 번에 모든 줄\nconst { stdout: lines } = await execa({\n  lines: true,\n})`npm run build`;\nconst errorLines = lines\n  .filter(line =\u003e line.includes('ERROR'))\n  .join('\\n');\nconsole.error(errorLines);\n```\n\n\n\n# 입력과 출력을 매핑/필터링하다\n\nNode.js Duplexes와 Transforms는 데이터를 매핑하거나 필터링하는 스트림입니다. 파싱 CSV부터 데이터 압축 또는 로깅까지 다양한 사용 가능한 모듈이 있습니다.\n\nExeca를 사용하면 명령어의 stdin, stdout 또는 stderr 옵션으로 바로 전달하여 입력 또는 출력을 변환할 수 있습니다. 웹 기반 TransformStreams도 지원됩니다.\n\n스트리밍은 메모리를 점진적으로 소비하고 CPU를 작은 버스트로 유지합니다. 명령어가 느리거나 출력이 큰 경우 일괄적으로 최종 결과를 수정하는 것보다 효율적입니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\nconst {stdout} = await execa({\n  stdout: new CompressionStream('gzip'),\n  encoding: 'buffer',\n})`npm run build`;\n\n// `stdout`이 gzip으로 압축되었습니다\nconsole.log(stdout); \n```\n\n# Generator-based transforms\n\n그렇지만 직접 스트림을 작성하는 일은 어려울 수 있습니다. 그들의 혜택을 누리고자 하지만 구체적인 내용에 대해 자세히 파고들기 싫다면 간단한 제너레이터 함수 대신 사용할 수 있습니다.\n\n```js\nimport {execa} from 'execa';\n\nlet count = 0;\nconst {stdout} = await execa({\n  * stdout(line) {\n    yield `[${count++}] ${line}`;\n  },\n})`npm run build`;\n\n// 줄 번호를 접두사로 붙입니다:\n// [0] ...\n// [1] ...\n// [2] ...\nconsole.log(stdout);\n```\n\n\n\n# 입력 및 출력 리디렉션\n\n명령어의 입력 또는 출력은 종종 유닉스 쉘 내에서 사용되는 \\`와 \\` 내장 연산자에 의해 표시된 대로 파일로 리디렉팅됩니다. Execa를 사용하면 stdin, stdout 또는 stderr 옵션에 'file: \\`./path\\`' 객체를 전달하여 이 작업을 수행할 수 있습니다.\n\n또 다른 일반적인 작업은 명령어의 출력을 점진적으로 표시하는 것입니다. stdout 또는 stderr 옵션에 'inherit'를 전달하면 이를 달성할 수 있지만, 출력을 변수에 저장하는 것을 방지합니다. 대신에 [`inherit`, `pipe`]를 전달하면 이 문제를 해결할 수 있습니다.\n\n```js\nimport {execa} from 'execa';\n\nconst {stderr} = await execa({\n  // stdout를 파일에 작성\n  stdout: {file: './stdout.txt'},\n  // stderr를 반환하되 출력도 함께 표시\n  stderr: ['inherit', 'pipe'],\n})`npm run build`;\n```\n\n\n\n# 여러 명령어를 연결하기\n\n파이프 연산자(|)는 대화식 터미널에서 아주 유용합니다. 그러나 스크립트 파일에서는 쉽게 다음을 할 수 없을 때가 있습니다:\n\n- 각 명령의 출력을 가져오기 어려울 수 있어 디버깅을 어렵게 만듭니다.\n- 오류 처리가 어렵습니다: 파이프라인 내의 몇 가지 명령이 실패해도 파이프라인이 성공할 수 있습니다(pipefail 옵션이 설정되지 않은 경우).\n- 하나의 명령을 여러 개에, 또는 여러 명령을 하나의 명령에 파이프하는 것이 어렵습니다.\n- 명령의 파이프 목적지를 변경하기 어렵습니다.\n- 파이프라인 문자열을 TypeScript에서 구문 분석하는 것이 불가능하기 때문에 강한 유형을 활용할 수 없습니다.\n\nExeca의 subprocess.pipe() 메소드는 위의 모든 것을 수행할 수 있어 프로그래밍적인 환경에서 더 나은 경험을 제공합니다.\n\n\n\n```js\nimport {execa, execaNode} from 'execa';\n\n// `npm run build | sort | head -n 2`를 실행합니다\n// 위의 세 개의 명령 중 하나라도 실패하면 오류가 발생합니다\nconst finalResult = await execa`npm run build`\n  .pipe`sort`\n  .pipe`head -n 2`;\n// `npm run build | sort`를 실행합니다\nconst sortResult = finalResult.pipedFrom[0];\n// `npm run build`를 실행합니다\nconst buildResult = sortResult.pipedFrom[0];\n\n// 동일한 로깅 프로세스로 여러 명령을 파이프합니다\nconst logger = execaNode`log-remotely.js`;\nawait Promise.all([\n  execa`npm run build`.pipe(logger),\n  execa`npm run test`.pipe(logger),\n]);\n```\n\n# 자세한 모드\n\n명령어는 때때로 블랙박스처럼 느껴집니다. 이들은 서로 격리된 프로세스에서 실행되어, 작은 오타가 몇 시간동안의 디버깅 지옥으로 변할 수 있습니다.\n\n이 문제를 완화하기 위해, 자세한 모드가 개선되어 자동으로 명령어의 인수, 출력, 오류, 완료 및 소요 시간을 출력합니다.```\n\n\n\n```js\n// build.js\nimport {execa} from 'execa';\n\nawait execa`npm run build`;\nawait execa`npm run test`;\n```\n\n```js\n$ NODE_DEBUG=execa node build.js\n[00:57:44.581] [0] $ npm run build\n[00:57:44.653] [0]   애플리케이션 빌드 중...\n[00:57:44.653] [0]   빌드 완료.\n[00:57:44.658] [0] ✔ (수행 시간: 78ms)\n[00:57:44.658] [1] $ npm run test\n[00:57:44.740] [1]   테스트 실행 중...\n[00:57:44.740] [1]   오류: 진입점이 잘못되었습니다.\n[00:57:44.747] [1] ✘ 명령이 종료 코드 1로 실패했습니다: npm run test\n[00:57:44.747] [1] ✘ (수행 시간: 89ms)\n```\n\n# 상세한 오류\n\n오류 메시지에는 이제 출력 내용, 수행 시간 및 실패 원인에 대한 추가 정보와 통찰이 포함되어 있습니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\ntry {\n  await execa({timeout: 5000})`npm run build`;\n} catch (error) {\n  console.error(error);\n  // ExecaError: Command timed out after 5000 milliseconds: npm run build\n  //     at file:///home/me/Desktop/example.js:2:20\n  //     at ... {\n  //   command: 'npm run build',\n  //   escapedCommand: 'npm run build',\n  //   cwd: '/path/to/cwd',\n  //   durationMs: 19.95693,\n  //   failed: true,\n  //   timedOut: true,\n  //   isCanceled: false,\n  //   isTerminated: true,\n  //   isMaxBuffer: false,\n  //   signal: 'SIGTERM',\n  //   signalDescription: 'Termination',\n  //   stdout: 'Building the application...',\n  //   stderr: 'Warning: deprecated API.',\n  //   stdio: [\n  //     undefined, \n  //     'Building the application...', \n  //     'Warning: deprecated API.',\n  //   ],\n  //   pipedFrom: []\n  // }\n}\n```\n\n# 디버그 종료 신호\n\n특정 명령이 갑자기 종료된 이유가 궁금했던 적이 있나요? SIGTERM과 같은 종료 신호에는 정보가 전달되지 않습니다. 메시지나 스택 추적도 없죠.\n\n이런 문제를 해결하기 위해 subprocess.kill()에 오류 인스턴스를 전달하여 복잡한 버그를 디버그하는 데 시간을 절약할 수 있습니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\nconst subprocess = execa`npm run build`;\nonCancel(reason =\u003e {\n  const error = new Error(`Canceled by ${reason}`);\n  subprocess.kill(error);\n});\nawait subprocess;\n```\n\n# 템플릿 문자열\n\nExeca 7부터 명령어를 zx와 같은 템플릿 문자열을 사용하여 지정할 수 있습니다. 그러나 이전에는 $ 메소드에 한정되어 있었습니다.\n\n템플릿 문자열 구문 및 전통적인 배열 구문은 이제 모든 Execa 메소드와 함께 사용할 수 있습니다. 두 가지 방법은 동등하며 주로 선호에 따라 다릅니다.\n\n\n\n\n또한, 템플릿 문자열은 여러 줄에 걸쳐 사용할 수 있어 여러 CLI 플래그를 전달할 때 유용합니다.\n\n스크립트에서 일련의 명령을 실행할 때는 $를 권장합니다. 응용 프로그램이나 라이브러리에서 개별 명령을 호출할 때는 execa와 execaNode를 대신 사용하는 것이 좋습니다. 유일한 차이점은 $가 스크립트 친화적인 기본 옵션을 사용한다는 것입니다. 예를 들어, 터미널로부터 stdin을 자동으로 읽습니다.\n\n```js\nimport {execa} from 'execa';\n\nawait execa`npm run build\n  --concurrency 2\n  --fail-fast`;\n```\n\n# 옵션 공유\n\n\n\n모든 Execa 메소드는 옵션을 바인딩할 수 있습니다. 이를 통해 전역 옵션을 설정하거나 여러 명령 사이에서 재사용할 수 있습니다.\n\n```js\nimport { execa as execa_ } from 'execa';\n\n// 전역 옵션 설정\nconst execa = execa_({ timeout: 5000 });\n\nawait execa`npm run build`;\nawait execa`npm run test`;\n```\n\n# 웹 API에 더 확실해져요\n\n서버 측 자바스크립트는 Node.js 코어 모듈 대신 웹 API를 점차 채택하고 있습니다. Execa도 마찬가지로 Node.js 스트림, 파일 경로 문자열 및 Buffer 대신 웹 스트림, 파일 URL 및 Uint8Array를 사용할 수 있습니다.\n\n\n\n```js\nimport {execaNode} from 'execa';\n\nconst response = await fetch('https://example.com/api/orders');\nawait execaNode({\n  stdin: response.body,\n})`send_orders.js`;\n```\n\n# 스트림으로 변환하기\n\n일부 모듈은 인수로 스트림을 사용하거나 반환합니다. 이러한 모듈에 직접 명령을 사용할 수 있도록 하려면 Execa의 자식 프로세스를 subprocess.readable(), subprocess.writable() 또는 subprocess.duplex()를 사용하여 스트림으로 변환할 수 있습니다.\n\n```js\nimport {execaNode} from 'execa';\nimport {pipeline} from 'node:stream/promises';\nimport {\n  createReadStream, \n  createWriteStream,\n} from 'node:fs';\n\nawait pipeline(\n  createReadStream('./input.txt'),\n  execaNode`transform.js`.duplex(),\n  createWriteStream('./output.txt'),\n);\n```\n\n\n\n모든 중요한 변경 내용, 새로운 기능 및 버그 수정 사항에 대한 전체 목록은 릴리스 노트를 확인해 주세요.\n\n그리고 문서 전체를 완전히 개선했습니다: 참조 섹션 외에도 이제 많은 사용자 가이드와 예제가 포함되어 있습니다. 처음에는 좀 어려울 수 있는 프로세스를 더 잘 이해할 수 있도록 새로운 사용자들을 격려하고 싶습니다. 기존 사용자가 이전에 놓쳤던 특정 기능을 발견할 수 있도록 새 문서가 도움이 되기를 희망합니다.","ogImage":{"url":"/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png"},"coverImage":"/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png","tag":["Tech"],"readingTime":8},{"title":"위대한 JavaScript 분할 CommonJS vs ES Modules","description":"","date":"2024-05-14 14:55","slug":"2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png\" /\u003e\n\n자바스크립트 커뮤니티가 논쟁을 즐기는 것은 비밀이 아닙니다. 4년 동안, 우리는 코드를 어떻게 구성해야 하는지에 대한 파티션이 계속되어 왔습니다. 이것은 기본적이지만 놀랄 만한 논란이 많은 질문이며, 개발자들을 나누는 계속된 문제입니다.\n\n이 분계는 CommonJS와 ES 모듈 두 가지 주요 시스템을 중심으로 이루어져 있습니다.\n\n## 분계를 이해하기\n\n\n\n자바스크립트가 처음에 발명된 때는 웹 브라우저의 스크립팅 언어로 사용되었습니다. 그러나 Node.js가 등장하면서 다양한 가능성이 열렸습니다.\n\n이제 브라우저용 언어가 아니라 서버 및 기타 응용 프로그램을 구동할 수 있었습니다.\n\n그 당시에는 브라우저의 모든 것이 전역 범위에 있었기 때문에 모듈에 대해 심각하게 생각할 필요가 없었습니다. 그러나 복잡한 서버 응용 프로그램을 구축하는 것은 간단하지 않았습니다. 모든 코드를 한 파일에 번들로 모아두는 것은 악몽이었기 때문입니다.\n\n이에 등장한 해결책은 CommonJS라는 모듈 시스템입니다.\n\n\n\n```js\nconst moduleA = require('./moduleA');\n```\n\nCommonJS는 다른 파일에서 JavaScript를 가져와서 그 파일이 내보낸 함수에 접근할 수 있게 해주는 require라는 함수를 사용합니다.\n\n그러나 JavaScript는 곧 ES6(이제는 유명한 버전)으로 이러한 아이디어를 채택했습니다. 이것은 웹 애플리케이션을 위한 것이며 import와 export를 소개했습니다.\n\n```js\nimport moduleA from './moduleA';\n```\n\n\n\n지금, 궁금해 할 수도 있습니다. 왜 JavaScript는 이미 사용 중인 require 호출에 고수하지 않았을까요?\n\nrequire의 문제는 동기적이라는 것이며, 모든 파일이 준비되어 있는 것을 전제로 원활하게 작동합니다. 그러나 브라우저 컨텍스트 내에서는 외부 리소스를 기다려야 하는 경우가 있기 때문에 require의 동기적인 성격은 시스템을 무너뜨릴 수 있습니다.\n\n그리고 이렇게 분리가 시작되었습니다.\n\n## 호환성의 진퇴양난\n\n\n\n대부분의 개발자들이 ES 모듈로 이동했는데, 이는 새롭고 사용하기 즐거웠기 때문이다. 그러나 상당수의 사용자는 CommonJS를 선택했습니다. 이 분리로 호환성 문제가 발생했습니다.\n\nES 모듈을 사용하는 경우 CommonJS를 문제없이 가져올 수 있습니다. 그러나 CommonJS로 ES 모듈을 가져오려고 하면 작동하지 않습니다. 대신, 가져오기를 모방하는 async 함수 해킹을 사용해야 합니다.\n\n```js\nconst moduleA = await import('./moduleA');\n```\n\n패키지를 배포할 때 이러한 호환성 문제 — 쌍둥이 패키지 하자로도 알려진 — 덕분에 매우 어려워집니다. 왜냐하면 ES 모듈과 CommonJS 사용자를 둘 다 고려해야 하기 때문입니다. ES 모듈만 제공하는 경우 CommonJS 사용자는 소외되고 반대의 경우도 마찬가지입니다.\n\n\n\n## 번들러의 역할\n\n번들러 또는 트랜스파일러인 Babel이나 TypeScript와 같은 도구들은 이 미묘한 문제에 추가적인 레이어를 더합니다. 여기서, 당신이 작성하는 코드가 무엇인지는 당신이 출력하는 코드에 따라 달라집니다. ES 모듈로 작성할 수도 있지만 CommonJS로 출력될 수도 있습니다.\n\n```js\n// Babel 또는 TypeScript 컴파일러가 ES Modules을 CommonJS로 변환\nconst moduleA = require('./moduleA');\n```\n\n당신이 생성한 코드에 require 호출이 보인다면, 당신은 CommonJS를 출력하고 있는 것이며, 반면에 import와 export가 있는 것은 당신이 ES 모듈의 일부라는 것을 나타냅니다. 앞으로 ES 모듈의 부분이 됩니다.\n\n\n\n## 미래는 ES 모듈로 향합니다\n\n개발자들의 관심을 끈 새로운 도구 중 하나는 번입니다. 번의 주요 강점은 CommonJS와 ES Modules 간의 상호 운용성 문제를 해결했다는 점입니다. 그러나 이 문제는 정확히 명세에 부합하지는 않습니다—CommonJS와 ES Modules 간의 문제를 해결하기 위해 대충 뭉개 놓은 것 뿐입니다.\n\nJavaScript 도구 체인은 이러한 별개의 모듈 시스템을 지원하느라 엄청난 복잡성을 가지고 있습니다.\n\n가능한 곳에서 ES 모듈을 사용하세요. 우리는 이 분열을 종식하고 미래를 수용할 때가 되었습니다. 현대적인 JavaScript. 통일된 JavaScript.\n\n\n\n만약 CommonJS를 사용하고 있거나 사용을 고려하고 있다면, 이제 코드를 좀 더 자세히 살펴볼 시간이 됐을지도 모릅니다. 미래는 ES 모듈을 사용하는 곳이며, JavaScript 환경을 더욱 간단하고 코딩이 더 재미있는 곳으로 만들기 위해 각자 역할을 다해야 합니다.\n\nBun의 최신 업데이트에 대한 자세한 내용은 확인해보세요:\n\n# 쉽게 이해하기\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우해 주세요! 👏\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인할 수 있어요 🚀\n- 무료 주간 뉴스레터에 가입해 보세요. 🗞️\n- 트위터(X) 말고도 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png"},"coverImage":"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png","tag":["Tech"],"readingTime":3},{"title":"RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스","description":"","date":"2024-05-14 14:54","slug":"2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad","content":"\n\n![FIT Proved Best PHP, MySQL, and Laravel Course in Rawalpindi Islamabad](/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png)\n\n- 웹사이트: [Future IT Technology](https://futureittechnology.com/)\n- 코스 링크: [PHP, MySQL, Laravel 코스](https://futureittechnology.com/php-mySQL-Laravel.html)\n\n안녕하세요! 이 포괄적인 코스는 PHP, MySQL 및 Laravel 프레임워크를 사용하여 웹 개발을 초급자에서 고급 수준까지 안내합니다. 프로그래밍이 처음이신 분들이거나 다른 언어에 어느 정도 경험이 있는 분들도 이 코스를 통해 견고한 웹 애플리케이션을 구축하는 데 필요한 기술과 지식을 습득할 수 있습니다.\n\n\n\n수업 개요:\n\n1. PHP를 활용한 웹 개발 소개\n\n- 웹 개발의 기본 개념 이해\n- PHP 프로그래밍 언어 소개\n- 개발 환경 설정하기\n\n2. MySQL 시작하기\n\n\n\n- MySQL 데이터베이스 관리 시스템 소개\n- 데이터베이스 및 테이블 생성\n- CRUD 작업 수행 (생성, 조회, 업데이트, 삭제)\n\n3. PHP 기초\n\n- 변수, 데이터 유형 및 연산자\n- 제어 구조 (if 문, 반복문)\n- 함수 및 배열\n- 양식 처리와 유효성 검사\n\n5. Laravel 소개\n\n\n\n- Laravel 프레임워크 이해하기\n- Laravel 환경 설정하기\n- Laravel 디렉토리 구조 및 설정\n\n6. Laravel로 애플리케이션 개발하기\n\n- 라우트 생성 및 관리\n- 컨트롤러 및 뷰 사용하기\n- 데이터베이스 마이그레이션과 시딩\n- 인증과 권한 부여\n- 데이터베이스 작업을 위한 엘로퀀트 ORM 사용\n\n7. 고급 Laravel 기술\n\n\n\n- 미들웨어 및 라우트 보호\n- RESTful API 개발\n- Laravel 패키지 사용\n- Laravel 애플리케이션 테스트 및 디버깅\n- 성능 최적화 기술\n\n필요 사항:\n\n- HTML 및 CSS의 기본적인 이해\n- 프로그래밍 컨셉(변수, 반복문, 함수)에 대한 이해\n- PHP, MySQL 또는 Laravel 경험이 없어도 됨\n\n이 수업을 마치면 웹 개발 원리, PHP 프로그래밍 언어, MySQL 데이터베이스 관리 및 Laravel 프레임워크에 대한 견고한 이해를 얻을 것입니다. 제작된 데이터 기반의 동적 웹 애플리케이션을 처음부터 만들고 제작 환경에 배포할 수 있게 될 것입니다.\n\n\n\n# PHP 기본 과정\n# PHP 고급 과정\n# 이슬라마바드 프리랜싱 과정\n# 라왈핀디 프리랜싱 과정\n# 라왈핀디 PHP 강좌\n# 이슬라마바드 PHP 강좌\n# 이슬라마바드 웹 디자인 강좌\n# 이슬라마바드 웹 개발 강좌\n# 라왈핀디 웹 디자인 강좌\n# 라왈핀디 웹 개발 강좌\n# 라왈핀디 이슬라마바드 고급 웹 개발\n# 라왈핀디 이슬라마바드 웹 개발 학원\n# 라왈핀디 이슬라마바드 IT 강좌\n# 라왈핀디 이슬라마바드 최고의 컴퓨터 학원\n\n[futureittechnology.com](https://futureittechnology.com/)\n\n[PHP, MySQL, Laravel](https://futureittechnology.com/php-mySQL-Laravel.html)\n\n주소: 퓨처 IT 기술, 피트 컴퓨터 학원 2층, 알-Mustafa 플라자, 찬드니 초크 근처, C 블록 피트 타운, 라왈핀디, 펀잡 46000\n\n\n\n휴대폰: 0344 5701828","ogImage":{"url":"/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png"},"coverImage":"/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs에서 Role-Based Access Control RBAC 구현하기","description":"","date":"2024-05-14 14:52","slug":"2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs","content":"\n\n역할 기반 액세스 제어 (RBAC)는 응용 프로그램 보안의 중요한 측면입니다. 조직 또는 응용 프로그램 내에서 사용자의 역할에 따라 리소스에 대한 액세스를 관리하고 제한하는 구조화된 접근 방식을 제공합니다. 이 포괄적인 안내서에서는 RBAC 개념을 탐색하고 혜택을 논의하며 Node.js 응용 프로그램에 RBAC를 구현하는 과정을 안내합니다. 이 글을 마치면 직접 프로젝트에 대해 RBAC를 설계하고 구현하는 방법을 명확히 이해할 수 있을 것입니다.\n\n![2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png)\n\n# 목차\n\n- 역할 기반 액세스 제어 (RBAC) 소개\n\n\n\n- RBAC이란 무엇인가요?\n- RBAC의 장점들\n\n- Node.js 환경 설정하기\n\n- 준비물\n- 프로젝트 구조\n\n- 예시 프로젝트: RBAC 실습하기\n\n\n\n- 간단한 업무 관리 시스템 구축\n- 역할 및 권한 정의\n- 인증 및 권한 부여 구현\n- RBAC 시스템 테스트\n\n- 최상의 실천 방법 및 보안 고려 사항\n\n- 데이터 유효성 검사\n- 감사 추적\n- 세분화된 권한\n- 정기적인 업데이트 및 모니터링\n\n- 결론\n\n\n\n# 1. 역할 기반 액세스 제어 (RBAC) 소개\n\n# RBAC란 무엇인가요?\n\n역할 기반 액세스 제어 (RBAC)은 시스템 액세스를 인가된 사용자로 제한하는 보안 개념입니다. RBAC에서는 액세스 권한이 역할과 연관되며 사용자에게 하나 이상의 역할이 할당됩니다. 이러한 역할은 사용자가 시스템 내에서 어떤 작업이나 작업을 수행할 수 있는지를 정의합니다.\n\nRBAC는 권한을 중앙 집중화하여 액세스 제어를 간소화하며, 관리자가 고수준에서 사용자 액세스를 관리할 수 있게 합니다. 사용자가 자신의 역할을 수행하는 데 필요한 권한만 갖도록 보장하여 보안을 강화하며, 무단 조치의 위험을 줄입니다.\n\n\n\n# 롤 기반 인증 이해하기\n\n롤 기반 인증은 사용자에게 역할을 할당하고 해당 역할에 따라 리소스에 대한 액세스를 결정하는 액세스 제어 방법입니다. 보통 각 역할에는 관련된 권한 집합이 있고, 사용자들은 할당된 역할에 기반하여 리소스에 액세스 권한이 부여됩니다.\n\n응용 프로그램에 따라 역할은 다양할 수 있지만 일반적으로 사용되는 역할은 다음과 같습니다:\n\n- Admin: 일반적으로 모든 기능에 액세스하고 관리 작업을 수행할 수 있는 관리 권한이 있는 사용자입니다.\n- User: 기본 기능 및 기능에 액세스 권한이 있는 표준 사용자입니다.\n- Moderator: 콘텐츠를 조절하거나 사용자를 관리하는 역할을 맡은 권한이 있는 사용자입니다.\n- Guest: 인증되지 않은 사용자로서 애플리케이션에 제한된 액세스 권한을 갖는 사용자입니다.\n\n\n\n# RBAC의 장점\n\nRBAC를 구현하면 다음과 같은 여러 가지 이점이 있습니다:\n\n- 보안: RBAC는 응용 프로그램 내에서 미인가된 액세스나 작업의 위험을 최소화하여 보안 취약점을 줄입니다.\n- 간편함: RBAC는 권한을 역할로 그룹화하여 사용자 액세스 관리를 간편하게 만들어 관리를 더 간편하게 합니다.\n- 확장성: RBAC는 매우 확장 가능하여 소규모 및 대규모 응용 프로그램에 모두 적합합니다.\n- 준수: GDPR 및 HIPAA와 같은 많은 규제 프레임워크는 RBAC와 같은 견고한 액세스 제어 메커니즘을 요구합니다.\n- 감사 기능: RBAC를 사용하면 사용자 작업을 추적하고 감사할 수 있어 보안 침해를 식별하는 데 중요합니다.\n\n이제 RBAC의 개념과 장점을 이해했으니, Node.js 애플리케이션에서 구현해 봅시다.\n\n\n\n# 2. Node.js 환경 설정하기\n\n# 요구 사항\n\nRBAC 구현에 들어가기 전에, 다음의 요구 사항이 갖춰져 있는지 확인해주세요:\n\n- 시스템에 Node.js가 설치되어 있어야 합니다.\n- 코드 편집기(예: Visual Studio Code)가 필요합니다.\n- JavaScript와 Node.js의 기본 지식이 요구됩니다.\n- Node.js 애플리케이션을 실행하기 위한 터미널 또는 명령 프롬프트가 있어야 합니다.\n- 의존성을 설치하기 위한 npm(Node Package Manager)이 필요합니다.\n\n\n\n# 프로젝트 구조\n\n이번 튜토리얼에서 사용할 기본 프로젝트 구조입니다:\n\n```js\nrbca/\n│\n├── helpers/\n│   ├── db.js\n│   ├── errorHandler.js\n│   ├── jwt.js\n│   └── role.js\n│\n├── models/\n│   └── user.js\n│\n├── public/\n│   └── stylesheets/\n│       └── style.css\n│\n├── routes/\n│   ├── index.js\n│   └── user.controllers.js\n│\n├── services/\n│   └── user.services.js\n│\n├── views/\n│   ├── error.jade\n│   ├── index.jade\n│   └── layout.jade\n│\n├── .gitignore\n├── README.md\n├── app.js\n├── config.json\n├── package-lock.json\n└── package.json\n```\n\n이 프로젝트 구조는 튜토리얼을 진행하면서 점진적으로 구성해 나갈 것입니다.\n\n\n\n# 의존성 설치\n\n```js\nnpm install bcryptjs@^2.4.3 cookie-parser@~1.4.4 cors@^2.8.5 debug@~2.6.9 express@~4.16.1 express-jwt@^6.0.0 http-errors@~1.6.3 jade@~1.11.0 jsonwebtoken@^8.5.1 mongoose@^5.9.25 morgan@~1.9.1 rootpath@^0.1.2 --save\n```\n\n# helpers/db.js:\n\n```js\nconst config = require(\"../config.json\");\nconst mongoose = require(\"mongoose\");\nconst conenctionOptions = {\n  useCreateIndex: true,\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false,\n};\ntry {\n  mongoose\n    .connect(\n      process.env.MONGODB_URI || config.connectionString,\n      conenctionOptions\n    )\n    .then((res) =\u003e console.log(`MOngoDB connected Successfully..!`));\n} catch (error) {\n  console.log(`MongoDB Error: `, error.message);\n  process.exit(1);\n}\n\nmongoose.Promise = global.Promise;\n\nmodule.exports = {\n  User: require(\"../models/user\"),\n};\n```\n\n\n\n- mongoose 모듈을 가져옵니다\n- 설정에서 데이터베이스 URL을 읽어옵니다\n- 연결 옵션을 설정합니다\n- 연결 및 오류 이벤트를 처리합니다\n- Promise 라이브러리를 구성합니다\n- 다른 곳에서 사용할 모델을 내보냅니다\n\nhelpers/errorHandler.js:\n\n```js\nfunction errorHandler(err, req, res, next) {\n  if (typeof err === \"string\") {\n    // 사용자 정의 애플리케이션 오류\n    return res.status(400).json({ message: err });\n  }\n  if (err.name === \"ValidationError\") {\n    // mongoose 유효성 검사 오류\n    return res.status(400).json({ message: err.message });\n  }\n\n  if (err.name === \"UnauthorizedError\") {\n    // jwt 인증 오류\n    return res.status(401).json({ message: \"잘못된 토큰\" });\n  }\n\n  // 기본적으로 500 서버 오류\n  return res.status(500).json({ message: err.message });\n}\n\nmodule.exports = errorHandler;\n```\n\nhelpers/jwt.js:\n\n\n\n```js\nconst expressJwt = require(\"express-jwt\");\nconst config = require(\"../config.json\");\nconst db = require(\"../helpers/db\");\n\nfunction jwt(roles = []) {\n  // roles 매개변수는 단일 역할 문자열 (예: Role.User 또는 'User')이거나 역할 배열 ([Role.Admin, Role.User] 또는 ['Admin', 'User'])일 수 있습니다.\n  if (typeof roles === \"string\") {\n    roles = [roles];\n    console.log(roles);\n  }\n\n  const secret = config.secret;\n\n  return [\n    // JWT 토큰을 인증하고 사용자를 요청 객체(req.user)에 추가합니다.\n    expressJwt({ secret, algorithms: [\"HS256\"] }),\n\n    // 사용자 역할에 따라 권한 부여\n    async (req, res, next) =\u003e {\n      const user = await db.User.findById(req.user.sub);\n\n      if (!user || (roles.length \u0026\u0026 !roles.includes(user.role))) {\n        // 사용자 역할이 허가되지 않았습니다.\n        return res.status(401).json({ message: \"Only Admin is Authorized!\" });\n      }\n      // 인증 및 권한 부여 성공\n      req.user.role = user.role;\n      next();\n    },\n  ];\n}\n\nmodule.exports = jwt;\n```\n\nhelpers/role.js:\n\n```js\nmodule.exports = {\n  Admin: \"Admin\",\n  User: \"User\",\n};\n```\n\nmodels/user.js:\n\n\n\n\n```js\nconst mongoose = require(\"mongoose\");\nconst Schema = mongoose.Schema;\n\nconst schema = new Schema({\n  email: { type: String, unique: true, required: true },\n  firstName: { type: String, required: true },\n  lastName: { type: String, required: true },\n  password: { type: String, required: true },\n  role: { type: String, required: true },\n  createdDate: { type: Date, default: Date.now },\n});\n\nschema.set(\"toJSON\", {\n  virtuals: true,\n  versionKey: false,\n  transform: function (doc, ret) {\n    delete ret._id, delete ret.password;\n  },\n});\n\nmodule.exports = mongoose.model(\"User\", schema);\n```\n\nroutes/index.js:\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\nroutes/user.controllers.js:\n```\n\n\n\n```js\nconst express = require(\"express\");\nconst router = express.Router();\nconst userServices = require(\"../services/user.services\");\nconst Role = require(\"../helpers/role\");\nconst jwt = require(\"../helpers/jwt\");\n\n// 라우트\nrouter.post(\"/authenticate\", authenticate);\nrouter.post(\"/register\", register);\nrouter.get(\"/\", jwt(Role.Admin), getAll);\nrouter.get(\"/current\", jwt(), getCurrent);\nrouter.get(\"/:id\", getById);\nrouter.put(\"/:id\", update);\nrouter.delete(\"/:id\", _delete);\n\nmodule.exports = router;\n\n// 라우트 함수\nfunction authenticate(req, res, next) {\n  userServices\n    .authenticate(req.body)\n    .then((user) =\u003e {\n      console.log(user);\n      user\n        ? res.json({ user: user, message: \"사용자가 로그인되었습니다.\" })\n        : res\n            .status(400)\n            .json({ message: \"사용자 이름 또는 비밀번호가 잘못되었습니다.\" });\n    })\n    .catch((error) =\u003e next(error));\n}\n\nfunction register(req, res, next) {\n  userServices\n    .create(req.body)\n    .then((user) =\u003e\n      res.json({\n        user: user,\n        message: `이메일 ${req.body.email}으로 성공적으로 등록되었습니다.`,\n      })\n    )\n    .catch((error) =\u003e next(error));\n}\n\nfunction getAll(req, res, next) {\n  const currentUser = req.user;\n\n  if (currentUser.role !== Role.Admin) {\n    return res.status(401).json({ message: \"권한이 없습니다!\" });\n  }\n  userServices\n    .getAll()\n    .then((users) =\u003e res.json(users))\n    .catch((err) =\u003e next(err));\n}\n\nfunction getCurrent(req, res, next) {\n  console.log(req);\n  userServices\n    .getById(req.user.sub)\n    .then((user) =\u003e (user ? res.json(user) : res.status(404)))\n    .catch((error) =\u003e next(error));\n}\n\nfunction getById(req, res, next) {\n  userServices\n    .getById(req.params.id)\n    .then((user) =\u003e {\n      if (!user) {\n        res.status(404).json({ message: \"사용자를 찾을 수 없습니다!\" });\n        next();\n      }\n      return res.json(user);\n    })\n    .catch((error) =\u003e next(error));\n}\n\nfunction update(req, res, next) {\n  userServices\n    .update(req.params.id, req.body)\n    .then(() =\u003e\n      res.json({\n        message: `ID가 ${req.params.id}인 사용자가 성공적으로 업데이트되었습니다.`,\n      })\n    )\n    .catch((error) =\u003e next(error));\n}\n\nfunction _delete(req, res, next) {\n  userServices\n    .delete(req.params.id)\n    .then(() =\u003e\n      res.json({\n        message: `ID가 ${req.params.id}인 사용자가 성공적으로 삭제되었습니다.`,\n      })\n    )\n    .catch((error) =\u003e next(error));\n}\n```\n\nservices/user.services.js:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nconst bcrypt = require(\"bcryptjs\");\nconst config = require(\"../config.json\");\nconst db = require(\"../helpers/db\");\nconst User = db.User;\n\n// 사용자 자격 증명을 인증하는 함수\nasync function authenticate({ email, password }) {\n  // 이메일로 사용자 찾기\n  const user = await User.findOne({ email });\n  console.log(\"사용자 모델\", user);\n  // 사용자가 있고 암호가 일치하면 토큰 생성\n  if (user \u0026\u0026 bcrypt.compareSync(password, user.password)) {\n    const token = jwt.sign({ sub: user.id, role: user.role }, config.secret, {\n      expiresIn: \"7d\",\n    });\n    \n    return { ...user.toJSON(), token };\n  }\n}\n\n// 모든 사용자 가져오기\nasync function getAll() {\n  return await User.find();\n}\n\n// ID를 사용하여 사용자 가져오기\nasync function getById(id) {\n  console.log(\"ID를 찾는 중: \", id);\n  return await User.findById(id);\n}\n\n// 사용자 추가\nasync function create(userParam) {\n  // 사용자가 있는지 확인\n  const user = await User.findOne({ email: userParam.email });\n  // 유효성 검사\n  if (user) throw `동일한 이메일이 이미 존재합니다: ${userParam.email}`;\n\n  // 사용자 객체 생성\n  const newUser = new User(userParam);\n  if (userParam.password) {\n    newUser.password = bcrypt.hashSync(userParam.password, 10);\n  }\n\n  await newUser.save();\n}\n\n// 사용자 업데이트\nasync function update(id, userParam) {\n  const user = await User.findById(id);\n  if (!user) throw \"사용자를 찾을 수 없습니다.\";\n  if (\n    user.email !== userParam.email \u0026\u0026\n    (await User.findOne({ email: userParam.email }))\n  ) {\n    throw `동일한 이메일을 가진 사용자가 이미 존재합니다: ${userParam.email}`;\n  }\n\n  if (userParam.password) {\n    userParam.password = bcrypt.hashSync(userParam.password, 10);\n  }\n\n  // 사용자 객체 복사\n  Object.assign(user, userParam);\n  await user.save();\n}\n\nasync function _delete(id) {\n  await User.findByIdAndRemove(id);\n}\n\nmodule.exports = {\n  authenticate,\n  getAll,\n  getById,\n  create,\n  update,\n  delete: _delete,\n};\n```\n\n\n\n```js\n레이아웃 확장\n\n콘텐츠 블록\n  h1= 메시지\n  h2= 오류 상태\n  pre #{error.stack}\n```\n\nviews/index.jade:\n\n```js\n레이아웃 확장\n\n콘텐츠 블록\n  h1= 제목\n  p 환영합니다 #{title}\n```\n\nviews/layout.jade:```\n\n\n\n```json\n{\n  \"database\": {\n    \"host\": \"localhost\",\n    \"username\": \"admin\",\n    \"password\": \"password123\",\n    \"port\": 3306\n  },\n  \"server\": {\n    \"port\": 5000,\n    \"corsOptions\": {\n      \"origin\": \"*\"\n    }\n  }\n}\n```\n\n\n\n```json\n{\n  \"connectionString\": \"//당신의 MONGODB URI\",\n  \"secret\": \"//JWT 토큰을 위한 원하는 시크릿 키\"\n}\n```\n\n사용자 등록\n\n![사진](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_1.png)\n\n사용자 인증\n\n\n\n\n![Current User](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_2.png)\n\n![Unauthorize](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_3.png)\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_4.png\" /\u003e\n\n# 7. 모범 사례 및 보안 주의 사항\n\nNode.js 애플리케이션에서 RBAC를 구현할 때 다음 모범 사례와 보안 주의 사항을 고려해보세요:\n\n# 데이터 유효성 검사\n\n\n\n사용자 입력을 항상 유효성 검사하여 SQL 인젝션, XSS 공격 등과 같은 보안 취약점을 방지하세요. 데이터 무결성을 보장하기 위해 유효성 검사 라이브러리나 프레임워크를 사용하세요.\n\n## 감사 로그\n\n사용자 활동과 액세스 시도를 추적하기 위해 감사 로그를 구현하세요. 이는 보안 위반이나 무단 활동을 식별하는 데 중요할 수 있습니다.\n\n## 세분화된 권한\n\n\n\n사용자가 자신의 업무를 수행하는 데 필요한 최소한의 권한을 보장하기 위해 세밀한 권한을 정의하십시오. 역할에 권한을 너무 많이 할당하지 않도록 주의하십시오.\n\n## 정기적인 업데이트와 모니터링\n\nRBAC 시스템을 최신 상태로 유지하십시오. 응용 프로그램이 발전함에 따라 역할과 권한을 조정해야 할 수 있습니다. 보안을 유지하기 위해 정기적으로 RBAC 정책을 모니터링하고 검토하십시오.\n\n## 저와 소통하기:\n\n\n\nLinkedin: [https://www.linkedin.com/in/suneel-kumar-52164625a/](https://www.linkedin.com/in/suneel-kumar-52164625a/)\n\n# 8. 결론\n\n이 포괄적인 안내서에서는 Role-Based Access Control (RBAC)의 개념을 탐구하고 Node.js 애플리케이션에 구현하는 방법을 시연했습니다. 역할 및 권한 정의, 사용자 인증, 역할 할당, 역할 기반 미들웨어, 그리고 RBAC가 작동하는 방식을 보여 주기 위해 샘플 작업 관리 시스템을 만들었습니다.\n\nRBAC를 구현함으로써 Node.js 애플리케이션의 보안을 크게 향상시키고 사용자 액세스를 효과적으로 제어하며 보안 위협을 줄일 수 있습니다. 또한, 최적의 방법을 따르고 보안 고려 사항을 고려함으로써 RBAC 시스템의 견고성을 보장할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png","tag":["Tech"],"readingTime":13},{"title":"서버 측 JavaScript의 진화","description":"","date":"2024-05-14 14:48","slug":"2024-05-14-EvolutionofServer-SideJavaScript","content":"\n\n자바 기반 런타임부터 Node.js의 급부상, NPM의 탄생, 성장하는 생태계, 혁신적인 Deno, 그리고 초고속 Bun의 등장까지, 몇 년 동안 서버 측 자바스크립트가 어떻게 발전해 왔는지 알아보세요.\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png)\n\n# 초기 시기\n\n서버 측 자바스크립트에 대해 이야기할 때, 먼저 떠오르는 것은 Node.js입니다. 그러나 노드 이전에도 백엔드 자바스크립트는 존재했음을 알아야 합니다. 이들은 생태계를 혁신시키지 않았던 것입니다. 커뮤니티에 영감을 주지 않은 것들. 역사의 잊혀진 페이지들 속에 사라진 것들입니다:\n\n\n\n- Jaxer\n- Silk\n- RingoJS\n- Rihno\n- AppEngineJS 등\n\n자바스크립트는 백엔드 프로젝트에서 피해 왔던 이유가 있습니다. 서버는 요청 당 스레드 모델에서 작동했는데, 이는 싱글 스레드인 자바스크립트와 잘 맞지 않았습니다.\n\n한 스레드가 점유되면 서버가 한 번에 하나의 요청만 처리할 수 있어 느리게 동작할 수밖에 없었습니다.\n\n멀티스레딩을 달성하기 위해 Ringo와 같은 라이브러리는 자바 가상 머신 위에 구축되었습니다. 그러나 심지어 JVM을 사용하여도 이러한 문제들을 해결하지 못했습니다. (서버에서 10,000개의 동시 연결을 처리하는 C10K 문제)\n\n\n\nJavaScript로는 이 문제에 대한 해결책이 없어 보였는데, 2009년 Ryan Dahl이 Node.js를 소개하기 전까지였습니다.\nNode.js는 JVM을 기반으로하지는 않았지만, C10K 문제를 해결했습니다.\n\n그래서 Node.js를 돋보이게 한 것은 무엇일까요? - 바로 비차단입니다!\n\n![Node.js 이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_1.png)\n\n# Node.js\n\n\n\nNode.js는 개방 소스, 크로스 플랫폼, 비동기적이고 이벤트 주도형 자바스크립트 런타임 환경으로, 개발자들이 서버에서 자바스크립트 코드를 실행할 수 있게 해줍니다. 이는 Google Chrome 브라우저를 구동하는 V8 자바스크립트 엔진 위에 구축되어 있습니다.\n\nNode.js는 개발자들이 JavaScript를 통해 OS와 상호작용할 수 있게 해 줍니다. 이는 파일 시스템, 운영 체제 검사, 프로세스 처리 외에도 HTTP 및 TCP 서버를 생성하고, DNS, CLI와 그 이상의 기능들을 사용할 수 있게 해 줍니다.\n\n\n\nNode.js는 최소주의, 속도 및 모듈성(공통JS 모듈을 사용하여)이라는 점에서 마이크로서비스를 개발할 때 완벽한 선택지가 되었습니다.\n결국, Node.js는 많은 노드로 분산 응용 프로그램을 구축하기 위해 설계되었습니다. 따라서 이름이 Node.js인 것입니다.\n\n하지만 Node.js는 그냥 수준을 높인 것이 아니라, 그것을 완전히 파괴했고 이 모든 것은 뒤에서 실행되는 천재적인 아키텍처로 시작되었습니다.\n\n## Non-Blocking I/O\n\nChrome의 V8 엔진(C++)과 Libuv(C 라이브러리)에서 구축되어진 Node.js는 JavaScript 외부에서 I/O 및 비동기 작업을 처리할 수 있도록 허용했습니다. 이때 작업의 스케줄링은 Event Loop에서 처리되었습니다.\n\n\n\n![Node.js](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_2.png)\n\n이것은 Node.js가 메인 JavaScript 스레드를 차단하지 않고 속도를 저하시키지 않고 여러 API 요청을 실행하거나 파일/데이터베이스에 읽기/쓰기를 할 수 있다는 것을 의미합니다.\n\n이 공식은 Node.js에서 이벤트, 소켓, 스트림 및 해싱 알고리즘을 포함하여 CPU 바운드 작업이 아닌 모든 것에서 재사용됩니다.\n\nNode.js 팀은 더 나아가서 Node.js 애플리케이션을 CPU 한계에 도전하게 허용함으로써 당신의 컴퓨터의 모든 파워를 활용할 수 있도록 했습니다. 기본적으로 Node.js는 CPU의 단일 프로세스에서 실행되며, 실패할 경우 그만입니다. 그러나 개발자들이 자식 프로세스를 활용할 수 있게 함으로써, Node.js는 각 CPU에 대해 복제본을 생성하고 내장된 로드 밸런서를 사용하여 트래픽을 균형있게 분산시켜 컴퓨터의 전체 성능을 활용할 수 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_3.png)\n\n그리고 하나가 실패하면, Node.js는 다른 것을 분기하고, 사이클을 다시 시작합니다. \n\"단일 스레드\"를 넘어서는 이야기를 해보는 거야.\n\nNode.js는 이 모든 것을 원래부터 제공해. 필요하다면 Nginx나 PM2, Docker, 또는 Kubernetes 같은 프로세스 매니저를 사용해서 기능을 향상시킬 수도 있어.\nNode.js를 따라온 JavaScript 런타임들은 이벤트 기반(논블로킹) 아키텍처를 디자인할 때 Node.js를 따랐지.\n\n하지만 네이티브 메커니즘 외에도, Node.js는 유틸리티, 라이브러리, 프레임워크를 위한 써드파티 패키지로 업그레이드할 수 있게 해 줬어.\n\n\n\n\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_4.png)\n\n# NPM\n\nNode Package Manager (NPM)은 Isaac Z. Schlueter에 의해 개발된 JavaScript 언어용 패키지 관리자입니다. NPM의 목적은 Node.js 또는 웹 앱을 다양한 서드파티 도구로 업그레이드할 수 있도록 하는 것입니다.\n\n패키지를 추가하는 것은 다음과 같이 간단합니다:\n\n\n\n\n```js\n\u003e npm i package-name\n```\n\n그게 전부에요. \n이제 패키지가 프로젝트에 추가되었고(패키지.json 파일에 표시됨) 사용할 준비가 되었습니다. 직접 CDN을 찾을 필요가 없을 뿐만 아니라 .dll 파일을 설정할 필요도 없어요.\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_5.png\" /\u003e\n\n일부 패키지는 서버 측 또는 웹 앱에만 특정되어 있고, 다른 것은 양쪽에서 작동합니다. 그리고 다양한 패키지 관리자가 있습니다:\n\n\n\n\n- Npm\n- Yarn\n\n누구나 자신의 패키지를 게시할 수 있기 때문에 NPM은 오픈 소스 도구들의 가장 큰 레지스트리 중 하나로 성장했습니다.\n\n## Express.js\n\nNode.js에 내장된 표준 HTTP 서버 모듈은 개발자들의 기대를 충족시키지 못했습니다. 곧 Express가 나와 문제를 해결했습니다. Express는 Node.js를 인기있게 만든 간소한 API 프레임워크입니다. Express의 아름다움은 몇 줄만으로도 처음부터 HTTP 서버를 시작할 수 있다는 점입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_6.png\" /\u003e\n\nExpress의 또 다른 특징은 매우 확장 가능하다는 것입니다. Express 핵심 팀에 의해 개발되지 않은 것은 전 세계의 오픈 소스 개발자들의 커뮤니티에 의해 개발되었습니다.\n\n## 풀 스택 JavaScript\n\nNode.js는 JavaScript 서버 기술이기 때문에, 이미 JavaScript에 익숙한 프런트엔드 개발자들은 새로운 프로그래밍 언어나 스택을 배우지 않아도 백엔드 개발자로 전환할 수 있습니다.\n\n\n\n동네에 또 다른 신입생이 나타났어요. Express와 동일한 해에 MongoDB도 선보였죠, JSON 구조를 사용하여 데이터를 저장하는 문서 기반 데이터베이스입니다. MongoDB 팀은 자신들의 데이터베이스를 홍보할 만한 파트너가 필요했고, 그 파트너를 Node.js \u0026 Express에서 찾았어요.\n\n- Angular.js와 같은 JavaScript 웹 프레임워크\n- Express.js와 같은 백엔드 서버사이드 JavaScript 프레임워크\n- JavaScript를 닮은 데이터베이스 MongoDB\n- JavaScript로 만들어진 런타임 환경 Node.js\n\nJavaScript 스택이 탄생했습니다.\n\n![에볼루션](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_7.png)\n\n\n\n# ECMAScript 6\n\nES6(가끔 ES2015로도 불림)은 언어에 전환점을 일으킨 주요 JavaScript 버전이었습니다.\n\n- Let \u0026 Const\n- Classes\n- Promises\n- ES 모듈\n- Map 및 Set 데이터 구조\n- 화살표 함수\n- 전개 연산자\n- 해체 할당\n\nClasses는 다른 언어에서 온 개발자들이 JavaScript로 쉽게 적응할 수 있도록 도와주었는데, 대부분의 경우 Classes는 JavaScript Prototype 상속을 위한 문법적 설탕일 뿐입니다.\n\n\n\n프로미스는 비동기 데이터를 조작하는 새로운 방법으로, 콜백보다 간단하게 사용하고 더 빠릅니다. ES6에서는 생성기 함수도 함께 도입되었습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_8.png)\n\n화살표 함수를 사용하면 콜백 구문이 더 깔끔하고 간단해지며, 전개 연산자와 구조 분해를 사용하면 복잡한 구조에서 데이터를 쉽게 추출할 수 있습니다.\n\n모듈의 강력함이 브라우저에도 도입되었습니다. Node.js에서 사용되는 CommonJS 모듈과 달리 ES 모듈은 패키지를 비동기적으로 가져왔습니다. 이를 통해 JavaScript 스크립트 파일을 더 작은 파일로 분할하고 연결할 수 있었습니다.\n\n\n\n언어 변경으로 서버 측 JavaScript(Node.js)도 적응해야 했습니다. ES6 기능을 사용하고 프라미스를 통해 비동기 작업을 처리할 수 있도록 만든 것부터 ES 모듈 지원을 제공하는 것까지 바뀌었습니다(Node.js v13에서 나온 것). \n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_9.png)\n\n## 번들러\n\n이러한 새로운 언어 기능과 최신 라이브러리 중 주요 단점 중 하나는 브라우저 지원에 있습니다. Google Chrome에서 작동하는 것이 다른 웹 브라우저에서는 동일하게 작동하지 않을 수도 있습니다. 결국 모든 브라우저는 서로 다른 JavaScript 엔진 위에 구축되어 있기 때문입니다.\n\n\n\n이를 해결하기 위해, 프레임워크는 ES6, React 또는 TypeScript로 작성된 코드를 일반 JavaScript로 번들하는 데 사용되는 Babel 및 Webpack과 같은 Transpiler에 의존했습니다.\n이러한 도구는 또한 ES 모듈 가져오기(예: 라이브러리 가져오기)를 제거하고, ES6(그리고 향후 ES 버전) 코드를 ES5 등가물로 변환하고, 빈 공간을 제거하며, 이미지를 압축하고, 프로세스를 자동화하는 등 다양한 최적화를 제공했습니다.\n\n한 번 변환 및 번들링되면, 코드는 브라우저 및 Node.js에서 완전히 실행 가능했습니다. 몇 년 동안 기술이 발전했고 모든 최신 브라우저가 ES6를 지원하지만, 새로운 ECMAScript 버전이 출시될 때마다 이러한 기술들은 여전히 사용되고 있습니다.\n\n내 컨텐츠를 좋아하시고 더 많이 보고 싶다면 저에게 따뜻한 한잔의 커피를 사주세요 ☕\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_10.png)\n\n\n\n![2024-05-14-EvolutionofServer-SideJavaScript_11](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_11.png)\n\n# TypeScript\n\nES6와 함께 최근 몇 년 동안 JavaScript 언어에 가져온 가장 큰 혁신 중 하나는 TypeScript입니다.\n\nTypeScript는 JavaScript를 기반으로 확장하여 언어에 엄격한 유형을 추가함으로써 개발되는 오픈 소스 언어입니다. TypeScript는 string, number, boolean 및 array와 같은 유형 변수를 사용하도록 개발자를 제한하며 Dictionary, Generics, Enums, Interfaces, Classes 및 Tuples와 같은 추가 기능을 도입하며 엄격한 널 체크를 통해 각 기능에 더 많은 컨텍스트를 제공합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_12.png\" /\u003e\n\n하지만 TypeScript는 JavaScript에 엄격한 타입을 도입하려는 첫 번째 시도가 아니었습니다.\n\n2000년대 초반에는 JavaScript를 타입과 함께 개선하려는 아이디어가 있었습니다. 이것은 JavaScript ECMAScript 4라는 코드명을 가졌습니다. 그러나 변경 사항이 너무 커서 당시 브라우저와 호환되지 않았습니다.\n\n그 실험이 실패했다고 말할 수 있습니다. 그래서 ES 3.1 이후에 우리는 즉시 ES5로 넘어가고, ES4는 TypeScript로 재구성되었습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_13.png\" /\u003e\n\n# 성장하는 생태계\n\nNode.js가 인기를 얻을수록 생태계도 함께 커져갔어요. 갑자기 자바스크립트가 모든 곳에 나타났죠. 핸드폰에서, 데스크톱 앱에서, 블로그에서, 개발자 모임에서도 말이에요.\n\n- Cross-platform tools (Electron, React Native, Ionic)\n- Visualization tools (D3, Chart, Three.js)\n- Video games (Phaser)\n- 다양한 웹 프레임워크 (React, Angular, Vue)\n- 상태 관리 도구 (Redux, Ngrx, Mobx)\n- 시간 및 날짜 조작 (Moment, DateFns, Day.js)\n- 유틸리티 라이브러리 (Lodash, Rx.js, Async.js)\n- 기계 학습 (TensorFlow.js)\n- 운영 체제 (NodeOS)\n\n\n\nNPM에는 100K개 이상의 모듈이 있습니다.\n\n그게 충분하지 않다면, Serverless 컴퓨팅의 팬들은 개발자들을 위한 프레임워크를 개발하여 코드로 인프라를 설정하고 AWS, Azure 및 GCP와 같은 클라우드 플랫폼에 분산시켰습니다. 그 결과 Serverless Framework가 탄생되었습니다.\n\n프로그레시브 웹 앱도 등장했고, Node.js도 발전했습니다. HTTP 2 지원, Async Hooks, Worker Threads 및 Watch 모드 등 다양한 기능이 추가되었습니다.\n한편, Angular의 팬들은 Nest.js를 개발했습니다. 이는 Express.js가 사용하는 함수형 접근 방식보다 C# 및 Java와 같은 언어에 사용되는 객체지향 패러다임을 선호하는 신선한 백엔드 프레임워크입니다.\n\n\n\n자바스크립트는 모든 면에서 선전하고 있는 것으로 보여서 얼마든지 사라지지 않을 것 같아요. 하지만 Node.js는 따라가는 데 어려움을 겪고 있었어요.\n\n## Node.js Chakra\n\nNode.js의 다른 버전이 있었죠. Node.js Chakra는 Microsoft가 자사의 JavaScript Chakra 엔진을 사용하여 Node.js를 재창조하려는 시도였어요. 이는 Windows 플랫폼을 특히 대상으로 한 고성능을 자랑했죠.\n\n하지만 운명은 그렇지 않았어요. Node.js Chakra의 인기는 매우 낮았기 때문에 Microsoft는 이 프로젝트를 포기하고 V8을 사용하기 시작했어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_15.png\" /\u003e\n\n# Node.js의 문제점\n\n시간이 지남에 따라 Node.js의 결함이 더욱 뚜렷해졌습니다.\n\n## ES 모듈\n\n\n\n프론트엔드 JavaScript가 ECMAScript 모듈을 채택하기 시작하면서 Node.js도 이 트렌드를 따라야 한다는 것이 분명해졌어요. 그러나 기존 NPM 모듈은 여전히 CommonJS 모듈에 의존하고 있었죠. 이는 라이브러리 개발자들도 ES 모듈만 지원하거나 둘 다 지원하도록 라이브러리를 변경해야 한다는 것을 의미했어요. Node.js는 둘 다 기본으로 지원하죠.\n\n## TypeScript\n\nTypeScript는 Node.js를 여러 가지 면에서 개선했어요. 단점은 TypeScript를 사용하려면 ts-node 패키지를 설치해야 하며, 사용한 NPM 패키지의 TypeScript 변형도 함께 설치해야 한다는 것이에요. Express를 설치할 때 @types/express도 함께 설치해야 한다는 거죠. 일부 패키지는 TypeScript 변형이 없어 TS와 전혀 호환되지 않을 수도 있어요. 반면에 새로운 패키지들은 TS 지원이 내장되어 있어 똑같은 패키지를 두 번 설치할 필요가 없는 것이 장점이에요.\n\n## 다양한 NPM 보안 문제\n\n\n\nNPM은 보안 문제로 유명합니다. 누구나 패키지를 만들고 NPM에 발행할 수 있기 때문에 악성 코드를 만들어 온라인으로 공유하는 것을 막을 방법이 없습니다. 또한 해로울 수 있는 패키지나 사용이 중단된 패키지를 설치할 때 경고도 없습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_16.png)\n\n이러한 문제들은 Node.js 개발자들을 처음부터 괴롭혔습니다. NPM 팀은 이를 해결하기 위해 끊임없이 노력하고 있습니다.\n\n## 표준화 부족\n\n\n\nNode.js 프로젝트를 설정하는 방법이나 사용할 라이브러리 도구, 따를 특별한 코드 규칙이 없습니다. 다른 패키지들마다 다른 구현을 가지고 있죠 (함수형, 이벤트 기반, 또는 객체 지향).\n\n필요한 것은 모두 NPM에 있어서 여러분의 프로젝트에 맞게 적합한지 확인해볼 수 있어서 끝도 없이 탐구하고 테스트할 수 있습니다. 다행히도 온라인에서 좋은 콘텐츠 제작자, 튜토리얼, 블로그 기사들이 있어서 적절한 도구를 찾는 데 도움을 줄 수 있습니다.\n\n이런 문제들을 살펴보면 다른 언어의 백엔드 개발자들이 Node.js를 피하는 이유가 분명해집니다. 대부분의 문제들이 해결되었지만, 한 표준에서 다른 표준으로의 전환은 많은 Node.js 개발자들에게 영향을 주었습니다. 심지어 Ryan Dahl이라는 창조자조차도 몇 년 전에 새로운 JavaScript 런타임을 만들기로 결정했죠. 이것이 Deno입니다.\n\n![에볼루션 오브 서버 측 자바스크립트](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_17.png)\n\n\n\n# 데노\n\n데노는 서버 측 자바스크립트에 대한 새로운 접근 방식입니다. 시선을 모은 신입생입니다. Libuv 대신 V8 및 Tokio (Rust 라이브러리)로 작성되어 더 빠르고 가벼운 런타임으로 홍보되었습니다.\n\nNode.js의 창시자에 의해 개발된 점이 엄청난 마케팅 포인트였습니다. 라이언은 노드.js의 문제점을 정확히 알고 있었으며 데노로 어떻게 개선할지 알고 있었습니다. 두 번째로, 노드.js의 창조자가 더 이상 사용하지 않고 일부 개발자를 데노의 세계로 끌어들였습니다.\n\n데노는 많은 새로운 기능을 가져왔습니다:\n\n\n\n- 그림 파일을 Markdown 형식으로 변환하면 됩니다.\n\n\n\n거기에 더불어, Node.js 팬들은 Deno의 일부 기능이 Node.js로 가져와지길 원하며, 특히 TypeScript가 기본으로 제공되길 열망합니다. 그러나 아직 그러한 변화는 일어나지 않았습니다.\n\n그러나 이 모든 기능들 중에서도 한 가지 주요 문제가 있었습니다 — Third-party 모듈들! Deno에서 NPM을 제거하는 것은, 이미 Node.js에서 NPM으로 갖고 있던 대부분의 기능들을 다시 개발해야 한다는 것을 의미했습니다.\n\n확실히 Deno 팀은 일부 NPM 패키지를 활성화하는 방법을 개발했지만, 내용의 부족으로 인해 Deno가 Node.js를 대체하지 못했습니다. 대신, Node.js는 Deno에서 가져온 몇 가지 새로운 기능을 채택했습니다. 오늘날에도 Node.js는 JS 생태계에서 가장 널리 사용되는 서버 측 플랫폼으로 자리잡고 있습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_19.png)\n\n\n\n# 메타 프레임워크\n\n최근 몇 년 동안 우리는 JavaScript 메타 프레임워크의 부상을 지켜보았습니다 - 이 도구들은 완전한 스택 앱을 구축할 수 있는 도구입니다. 백엔드 부분은 데이터베이스와 통신하고 엔드포인트를 노출시키며 다양한 방법으로 콘텐츠를 렌더링하는 역할을 하고 있습니다:\n\n- 정적 사이트 생성\n- 서버 측 렌더링\n- 증분적 정적 재생성\n\n한편, 프론트엔드 부분은 싱글 페이지 애플리케이션입니다. 이를 수행할 수 있는 몇 가지 도구가 있으며, Vercel의 Next.js가 그 중 선두를 달리고 있습니다.\n\n\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_20.png)\n\n샤벨트(Svelte) 및 퀵(Qwik)와 같은 새로운 프레임워크들이 자체적인 기능들을 가져왔습니다. 기존의 수분화(hydration)를 포기하고 Resumability라는 새 개념을 선호했습니다.\n\n이어서 Vite가 등장했습니다. 이는 속도와 성능에 중점을 둔 새로운 프론트엔드 빌더 도구로, Webpack의 직접적인 경쟁 상대입니다.\nVite는 백엔드에서도 발전하고 있습니다. Nest.js 팀은 SWC를 발견했습니다. 이는 Rust 기반의 플랫폼으로, 빠른 컴파일 및 번들링에 사용할 수 있으며 Vite와 호환됩니다.\n\n노드.js를 구동하는 V8 엔진은 더 이상 서버 측 개발의 궁극적인 해결책으로 여겨지지 않습니다. Rust가 점유율을 높이면서, 갑자기 죽을 것 같은 새로운 도구가 등장했습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_21.png\" /\u003e\n\n# 번\n\n인터넷에 자바스크립트 런타임 간의 다양한 성능 비교 기사들이 올라온 것은 2022년 말쯤이었습니다. 그 중 하나가 새로운 초고속 기술인 번입니다.\n\nZig로 작성되었고 V8 엔진을 완전히 피하는 번은 Deno 및 Node.js를 합친 것보다 현저히 빠르다는 것이 증명되었지만, 이점은 여기서 끝나지 않습니다:\n\n\n\n- 즉시 사용 가능한 TypeScript 지원\n- Node.js 코어 모듈 지원\n- NPM 지원\n- 내장 번들러\n- ECMAScript 및 CommonJS 모듈 지원\n- 기존 프레임워크 지원 (예: Next, Express 또는 Nest)\n\nBun 발명자 Jarred Sumner가 괴물을 만들었습니다.\n\nBun은 JavaScript 커뮤니티에서 확실하게 폭발적인 반응을 얻었습니다.\n\n현재 모든 게 완벽하다는 뜻은 아닙니다. Bun은 NPM을 통해 문을 열었지만, 제대로 기능하지 않는 패키지 목록이 꽤 있습니다. 그리고 Bun은 막 나온 것이기 때문에 경험이 부족하고 이전에 나온 런타임과 비교했을 때 온라인 참조가 부족합니다.\n\n\n\n저에게 있어서 Bun의 매력은 빠르거나 새롭고 혹평받는 것이 아니라, 오히려 Bun이 표준을 만들고자 한다는 점입니다. 개발자들을 소외시키거나 모듈을 가져오는 방법이나 패키지의 출처를 지시하는 대신, Bun은 맞는 방법을 찾으라고 장려합니다. 이는 JavaScript 개발자들과 생태계를 통합하는 중요한 한걸음이라고 생각해요.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_22.png)\n\nBun은 계속 발전할 것입니다. 버그는 수정되고 새로운 기능이 정기적으로 추가됩니다. 앞으로 몇 년 안에 Bun이 어떻게 발전할지 기대됩니다.\n\n# 백엔드 JavaScript의 미래\n\n\n\n다년간 JavaScript는 여러 변형을 거쳤어요. 어떤 확장 기능은 실패했고, 어떤 것은 성공하여 오늘날의 생태계가 되기까지 고난을 겪었죠.\n\n서버 측 JavaScript는 몇 년 전보다 오늘날 더 나은 상태에 있는 걸까요? 음, 그것은 상황에 따라 다르죠.\n\nNode.js 이전의 상태와 비교하면 JavaScript는 많은 발전을 이루었어요. 1995년 JavaScript가 시작된 때와는 더욱 예측할 수 없는 방향으로 발전해 왔거든요. 오랜 기간 개발자였다면 변화를 환영하며 빨리 적응할 수 있을 겁니다. 하지만 JavaScript 초심자라면 모든 것이 다른 런타임, 언어, 번들러, 모듈 등이 얽혀있어 엉망스럽게 들릴 수도 있어요.\n\n내가 생각하기에 장래에 Node.js가 여전히 최고의 서버 측 JavaScript 런타임 역할을 하게 될 것 같아요. 경쟁 상대들의 긍정적인 점들에도 불구하고, 다른 도구들은 Node.js만큼의 안정성, 많은 API와 온라인 참고 자료, 인기가 없을 뿐만 아니라 오랫동안 실전을 경험했다는 점에서 뒤쳐지죠.\n\n\n\n나의 극심한 희망은 언젠가 세 가지 중 가장 좋은 것을 모두 하나의 지붕 아래에 갖게 될 것이라는 것입니다 —빠르고 안전한 런타임, JS, TS 및 번들링을 위한 기본 지원이 충분히 갖춰진 것, 그리고 내장 및 제3자 도구가 풍부한 것, 그리고 전 세계 개발자들이 사용하는 것과도 함께요.\n지금까지 Bun은 그것을 달성하기 위한 좋은 길일 것입니다.\n\n분명한 한 가지는, 확실한 것은, 흥미진진한 JavaScript 세계에서 다음에 무엇이 일어날지 확실히 말하기 쉽지 않다는 것입니다.\n\n# 더 많은 JavaScript 이야기 읽기\n\n이제 잠시 안녕👋","ogImage":{"url":"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 - Strict Mode는 어떻게 작동하나요","description":"","date":"2024-05-14 14:46","slug":"2024-05-14-JavaScriptStrictModeHowDoesItWork","content":"\n\n![이미지](/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png)\n\n과연 엄격한 선생님이나 멘토를 만나본 적이 있나요? 그러나 결국 더 나은 학생이나 전문가가 되도록 도와준 적이 있습니까?\n자바스크립트 세계에서 \"use strict\"는 비슷한 역할을 합니다. 이는 최고의 실천법을 강요하고 더 깔끔하고 견고한 코드를 작성하는 데 도움을 줍니다.\n\n## 엄격 모드의 기원\n\n1990년대 초에 처음으로 등장한 이후로 자바스크립트는 많은 발전을 이루었습니다. 언어가 발전함에 따라 그 동안 유용했던 특정 기능 및 동작이 혼동을 일으키고 잠재적 버그의 원인이 되기도 했습니다. 이러한 문제를 해결하기 위해 ECMAScript 5 (ES5) 명세에서는 엄격 모드(strict mode)를 소개했습니다. 이로써 자바스크립트의 제한된 변형에 참여할 수 있는 방법을 제공했습니다.\n\n\n\nStrict 모드는 언어의 완전히 별개의 버전이 아닙니다. 오히려 언어의 일부 규칙을 자발적으로 준수하여 더욱 문제가 되는 기능과 동작을 제거하는 방법입니다. Strict 모드를 선택함으로써 JavaScript에게 \"약간 더 엄격해지길 바래. 날 마구 코딩 실수로 그냥 넘어가게 하지 말아줘\"라고 말하는 것과 같습니다.\n\n## Strict 모드 활성화\n\nStrict 모드를 활성화하는 것은 단순합니다. JavaScript 파일이나 함수의 시작 부분에 다음 줄을 추가하는 것으로 가능합니다:\n\n```js\n\"use strict\";\n```\n\n\n\n파일 상단에 이 줄을 포함하면 전체 스크립트에 strict 모드가 적용됩니다. 또는 함수 몸체의 시작 부분에 \"use strict\" 문을 포함하여 특정 함수에 대해 strict 모드를 활성화할 수도 있습니다.\n\n```js\nfunction strictFunction() {\n  \"use strict\";\n  // Strict 모드 코드를 여기에 입력합니다.\n}\n```\n\nES6 모듈 및 클래스에서는 strict 모드가 자동으로 활성화되며 비활성화할 수 없다는 점을 유의해야 합니다.\n\n## Strict 모드의 장점\n\n\n\n이제 엄격 모드를 활성화하는 방법을 알았으니, 이 모드가 제공하는 일부 이점을 살펴보겠습니다:\n\n- 일반적인 코딩 실수 잡기\n엄격 모드는 문제가 될 수 있는 또는 에러를 일으킬 수 있는 특정 코딩 패턴에 대해 예외를 던집니다. 예를 들어, 비엄격 모드에서는 변수 이름을 잘못 입력하거나 선언을 잊어서 전역 변수를 실수로 만들 수 있습니다. 엄격 모드는 이를 방지하기 위해 에러를 던져서 변수를 정확하게 선언하도록 강요합니다.\n\n```js\n\"use strict\";\nx = 3.14; // 이것은 엄격 모드에서 에러를 발생시킵니다\n```\n\n안전하지 않은 동작 방지\n엄격 모드는 예상치 못한 동작이나 보안 취약점으로 이어질 수 있는 일부 동작을 금지합니다. 예를 들어, 변수나 객체 속성을 삭제함으로써 실수로 전역 변수를 만드는 것을 방지합니다.\n\n\n\n```js\n\"use strict\";\ndelete Object.prototype; // 이것은 엄격한 모드에서 오류를 발생시킵니다.\n```\n\n혼란스러운 기능 제거하기\nJavaScript의 일부 기능들은 언어의 최상의 가이드가 완전히 확립되기 전에 도입되었습니다. 엄격 모드(strict mode)는 이러한 혼란스러운 기능들을 없애거나 수정하여 더 나은 코딩 관행을 촉진합니다. 예를 들어, 비 엄격 모드에서는 with 문을 사용할 수 있지만, 이는 예상치 못한 동작 및 성능 문제로 이어질 수 있습니다. 엄격 모드는 with 문의 사용을 금지합니다.\n\n```js\n\"use strict\";\nwith (Math) { // 이것은 엄격한 모드에서 오류를 발생시킵니다.\n  console.log(PI);\n}\n```\n\n더 나은 매개변수 처리 강화하기\n비 엄격 모드에서는 함수 내에 중복된 매개변수 이름을 가질 수 있으나, 이는 혼란과 버그를 초래할 수 있습니다. 엄격 모드는 중복된 매개변수 이름을 갖는 함수를 선언하려고 시도하면 오류를 발생시킵니다.```\n\n\n\n```js\n\"use strict\";\nfunction duplicateParams(a, a) { // 이것은 엄격한 모드에서 오류를 발생시킵니다\n  // ...\n}\n```\n\n실수로 전역 변수를 만드는 것을 방지하기\nJavaScript에서 버그가 가장 일반적으로 발생하는 소스 중 하나는 실수로 전역 변수를 만드는 것입니다. 엄격한 모드는 미선언 변수에 값을 할당하려고 할 때 오류를 던져 이를 방지합니다.\n\n```js\n\"use strict\";\nmyGlobal = 42; // 이것은 엄격한 모드에서 오류를 발생시킵니다\n```\n\n변수 사용을 단순화하기\n엄격한 모드가 아닌 경우, arguments 객체는 약간 특이한 동작을 합니다. 함수의 명명된 매개변수로 별칭을 지정하고 그 값을 덮어쓸 수 있습니다. 엄격한 모드는 이러한 혼동스러운 동작을 제거하여 arguments 객체를 다루기 쉽게 만듭니다.\n\n\n\n```js\n// 비 엄격 모드\nfunction nonStrict() {\n  var obj = {\n    prop: 1\n  };\n  \n  // 존재하지 않는 속성에 값 할당하기\n  obj.prop2 = 2;\n  \n  // 선언되지 않은 변수에 접근하기 (오류가 발생하지 않음)\n  x = 10;\n  \n  return obj;\n}\n\n// 엄격 모드\nfunction strict() {\n  \"use strict\";\n  var obj = {\n    prop: 1\n  };\n  \n  // 존재하지 않는 속성에 값 할당 시도 (오류 발생)\n  obj.prop2 = 2; // 엄격 모드에서 오류 발생\n  \n  // 선언되지 않은 변수에 접근 (오류 발생)\n  // x = 10; // 이 줄을 주석 해제하면 엄격 모드에서 오류가 발생합니다.\n  \n  return obj;\n}\n\nconsole.log(nonStrict());\nconsole.log(strict());\n```\n\n## 결론\n\n엄격 모드는 처음에는 엄격한 선생님처럼 보일 수 있지만, 결국 더 나은 JavaScript 개발자가 되도록 돕는 역할을 합니다. 엄격 모드를 사용하면 일반적인 실수를 미리 잡을 수 있습니다.\n\n물론, 엄격 모드가 모든 문제를 해결해주는 마법의 해결책은 아닙니다.```\n\n\n\n# 친절한 어조로 번역한 내용 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠로 고생하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드","description":"","date":"2024-05-14 14:45","slug":"2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png\" /\u003e\n\n앵귤러 애플리케이션에서 컴포넌트 간 데이터 흐름을 관리하는 것은 복잡해질 수 있습니다. 이때 비동기 프로그래밍을 위한 강력한 라이브러리인 RxJS가 유용합니다. RxJS는 데이터 스트림을 처리하는 다양한 연산자와 Subject를 제공하며, 그 중에서 BehaviorSubject는 중요한 역할을 합니다. BehaviorSubject는 상태를 관리하고 Angular 애플리케이션 내에서 변경 사항을 전파하는 데 기본적인 구조로 나타납니다. 이 블로그 포스트에서는 BehaviorSubject를 사용하여 컴포넌트 간 데이터를 공유하는 방법에 대해 알아보겠습니다.\n\n# BehaviorSubject란 무엇인가요?\n\n기본적으로 BehaviorSubject는 RxJS 라이브러리에서 제공하는 Observable의 한 유형입니다. 특정 이벤트가 발생할 때만 값을 방출하는 전통적인 Observable과 달리, BehaviorSubject는 최신 값을 유지하고 새로운 구독자에게 즉시 전달합니다.\n\n\n\n# 주요 기능:\n\n## 초기값으로의 초기화:\n\nBehaviorSubject를 생성할 때, 개발자는 초기값을 지정합니다. 이 초기값은 이후 발생하는 값들의 시작점으로 작용하며, 새로운 구독자가 구독 시 즉시 업데이트를 받을 수 있도록 보장해줍니다.\n\n## 상태 유지:\n\n\n\nBehaviorSubject의 독특한 특징 중 하나는 최신 값을 유지 및 구독자에게 전달할 수 있는 능력입니다. 이 행동은 추가 이벤트를 트리거할 필요 없이 컴포넌트가 가장 최신 데이터와 동기화되도록 합니다.\n\n## next() 메서드:\n\nnext() 메서드를 통해 개발자는 BehaviorSubject가 보유한 값을 동적으로 업데이트할 수 있습니다. 이 메커니즘은 응용 프로그램 전체에 이어지는 데이터 전파를 원활하게 처리하여 반응성 및 반응적인 동작을 가능하게 합니다.\n\n# 실제 구현:\n\n\n\n## 1. 빈 Angular 프로젝트를 생성하세요\n\n```js\nng new behaviorsubject-demo\n```\n\n## 2. 서비스 및 컴포넌트 생성\n\n이 프로젝트에서는 아래와 같은 UI를 만들 예정입니다. 이를 위해 인용구 데이터를 가진 Quote 서비스를 생성하고, 인용구를 업데이트하는 컴포넌트와 인용구를 표시하는 컴포넌트를 만들 예정입니다.\n\n\n\n아래 명령어를 실행하여 서비스와 컴포넌트를 생성하세요.\n\n```js\nng generate service services/quote\nng generate component components/display-quote\nng generate component components/update-quote\n```\n\n폴더 구조는 아래와 같이 보일 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_2.png\" /\u003e\n\n## 3. 서비스에 아래 코드를 추가하세요\n\n```js\n// quote.service.ts\n\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class QuoteService {\n\n  constructor() {}\n\n  // 명언 속성을 선언하고 초기화합니다. BehaviorSubject이 될 예정\n  qoute = new BehaviorSubject(\"Hello world\");\n\n  // BehaviorSubject를 Observable로 노출합니다\n  currentQuote = this.qoute.asObservable();\n\n  // BehaviorSubject 값을 업데이트하는 함수\n  updateQuote(newQuote: string){\n    this.qoute.next(newQuote);\n  }\n}\n```\n\n## 4. 명언 서비스에서 명언 값을 표시하기\n\n\n\n```typescript\n// display-quote.component.ts\n\n...\n\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class DisplayQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n  \n  currentQuote: string = '';\n\n  ngOnInit(): void {\n    // 현재 시간 값을 가져오기 위해 quote 서비스의 currentQuote 속성을 구독합니다\n    this.quoteService.currentQuote.subscribe(\n      // 컴포넌트의 속성을 업데이트합니다\n      quote =\u003e this.currentQuote = quote\n    );\n  }\n}\n\n// display-quote.component.html\n\n\u003ch2\u003e{currentQuote}\u003c/h2\u003e\r\n```\n\n이제 display-quote 컴포넌트에서 quote 서비스의 초기 인용구를 볼 수 있게 될 것입니다\n\n## 5. 인용구 값 업데이트\n\n```typescript\n// update-quote.component.ts\n\nimport { Component } from '@angular/core';\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class UpdateQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n\n  quote = '';\n\n  // 서비스에서 인용구를 업데이트하는 함수\n  submitHandler(){    \n   this.quoteService.updateQuote(this.quote);\n    this.quote=\"\";\n  }\n}\n\n// update-quote.component.html\n\n\u003cdiv\u003e\n  \u003cinput type=\"text\" [(ngModel)]=\"quote\" placeholder=\"새로운 인용구를 작성하세요\" /\u003e\n  \u003cbutton (click)=\"submitHandler()\"\u003e제출\u003c/button\u003e\n\u003c/div\u003e\r\n```\n\n\n\n이제 update-quote 컴포넌트에서 인용구 값을 업데이트할 수 있게 되었고, 이는 display-quote 컴포넌트에 직접적으로 반영될 것입니다. 아래 다이어그램에서 프로젝트 내 데이터의 흐름을 확인할 수 있습니다.\n\n![Diagram](/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_3.png)\n\n# 결론:\n\n- 이 예제에서 인용구 서비스는 BehaviorSubject를 사용하여 인용구를 저장합니다. display-quote 컴포넌트는 currentQuote observable을 구독하여 최신 인용구를 가져와 로컬 변수를 업데이트합니다.\n- Angular 개발에서 BehaviorSubject는 상태를 관리하고 컴포넌트 및 서비스 간 반응형 동작을 용이하게 하는 강력한 도구로 사용됩니다. 개발자들은 이를 활용하여 동적 데이터 흐름을 쉽게 다룰 수 있는 견고하고 반응적인 Angular 애플리케이션을 구축할 수 있습니다.\n\n\n\n아래 GitHub 저장소에서 최종 코드를 얻어보세요.","ogImage":{"url":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png"},"coverImage":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png","tag":["Tech"],"readingTime":4}],"page":"31","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"31"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>