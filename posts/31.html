<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" href="/post/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트의 비밀 병기를 발휘하라 StrictMode" href="/post/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트의 비밀 병기를 발휘하라 StrictMode</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴포넌트 라이프사이클 메서드" href="/post/2024-05-14-ReactComponentLifecycleMethods"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴포넌트 라이프사이클 메서드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="갇혀 있는 극악무도한 보안의 심연으로부터" href="/post/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">갇혀 있는 극악무도한 보안의 심연으로부터</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Js 설치 방법 완전 초보자용" href="/post/2024-05-14-HowToInstallReactJsForcompletebeginners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Js 설치 방법 완전 초보자용</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 언제 useRef 대신에 useState를 사용해야 할까요" href="/post/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 언제 useRef 대신에 useState를 사용해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 언제 useRef 대신에 useState를 사용해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 언제 useRef 대신에 useState를 사용해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컨텍스트를 올바르게 활용하기" href="/post/2024-05-14-UsingReactcontextstherightway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컨텍스트를 올바르게 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컨텍스트를 올바르게 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컨텍스트를 올바르게 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" href="/post/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="한국어 Axios 인터셉터란 무엇인가요" href="/post/2024-05-14-ENWhatareAxiosInterceptors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="한국어 Axios 인터셉터란 무엇인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="한국어 Axios 인터셉터란 무엇인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">한국어 Axios 인터셉터란 무엇인가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="BEM에 익숙해지기" href="/post/2024-05-14-GettingComfortablewithBEM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="BEM에 익숙해지기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingComfortablewithBEM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="BEM에 익숙해지기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">BEM에 익숙해지기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제","description":"","date":"2024-05-14 12:18","slug":"2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png)\n\n자바스크립트는 현대 웹 개발의 기초가 된 다재다능하고 동적인 프로그래밍 언어입니다. React, Angular, Vue.js와 같은 인기있는 프레임워크들이 등장함에 따라 특정 프레임워크를 배우기에 싫증이 나게 되기 쉽습니다. 그러나 점프하기 전에 자바스크립트 기초를 확실히 이해하는 것이 중요합니다. 이 블로그 포스트에서는 React 또는 다른 자바스크립트 프레임워크로 넘어가기 전에 반드시 숙달해야 할 핵심 주제를 살펴보겠습니다.\n\n# 1. 변수, 데이터 유형 및 연산자\n\n자바스크립트의 변수, 데이터 유형 및 연산자의 기초를 이해하는 것은 어떤 프로그래밍 작업에도 꼭 필요합니다. 이에는 다음이 포함됩니다:\n\n\n\n- 변수 선언 (let, const, var)\n- 데이터 유형 (원시, 복합, null, undefined)\n- 유형 강제 변환 및 변환\n- 연산자 우선순위 및 결합성\n\n코드 예시:\n\n\n# 변수 선언:\n\nJavaScript\n\n\n\n\n```js\nlet name = 'John';\nconst PI = 3.14;\nvar age = 30;\n```\n\n# 데이터 유형:\n\n자바스크립트\n\n```js\nlet isAdmin = true; // 불리언\nlet num = 42; // 숫자\nlet greeting = 'Hello'; // 문자열\n```\n\n\n\n# 형 변환:\n\n자바스크립트\n\n```js\nlet num = '42'; // 문자열\nconsole.log(num * 2); // 84 출력 (숫자로 강제 변환)\n```\n\n# 연산자 우선순위:\n\n\n\n자바스크립트\n\n```js\nlet result = 2 + 3 * 4; // 결과는 14가 나옵니다 (곱셈이 덧셈보다 높은 우선순위를 갖습니다)\n```\n\n## 2. 제어 구조 및 함수\n\n제어 구조 및 함수는 자바스크립트 프로그래밍의 기본 요소입니다. 다음을 확실히 이해해두세요:\n\n\n\n- 조건문 (if/else, switch)\n- 반복문 (for, while, do-while)\n- 함수 (선언, 표현식, 화살표 함수)\n- 함수 매개변수 및 반환 유형\n\n코드 예시:\n\n```javascript\n// 조건문:\n\n```\n\n\n\n```javascript\nlet age = 25;\nif (age \u003e= 18) {\n  console.log('당신은 성인입니다.');\n} else {\n  console.log('당신은 미성년자입니다.');\n}\n```\n\n# 반복문:\n\nJavaScript\n\n```javascript\nfor (let i = 0; i \u003c 5; i++) {\n  console.log(i);\n}\n```\n\n\n\n# Functions:\n\n자바스크립트\n\n```js\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('John'); // \"Hello, John!\"을 출력합니다\n```\n\n# 화살표 함수:\n\n\n\n자바스크립트\n\n```js\nlet double = x =\u003e x * 2;\nconsole.log(double(5)); // 10을 출력합니다.\n```\n\n## 3. 객체지향 프로그래밍 (OOP) 개념\n\n자바스크립트는 객체지향 언어이며, OOP 원칙을 이해하는 것이 중요합니다.\n\n\n\n- 객체와 속성\n- 생성자와 프로토타입\n- 상속과 다형성\n- 캡슐화와 추상화\n\n코드 예시:\n\n# 객체와 속성:\n\nJavaScript\n\n\n\n```js\nlet person = {\n  name: '존',\n  age: 30,\n  greet: function() {\n    console.log(`안녕, 내 이름은 ${this.name}이야!`);\n  }\n};\nperson.greet(); // \"안녕, 내 이름은 존이야!\"\n\n# 생성자와 프로토타입:\n\nJavaScript\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.greet = function() {\n  console.log(`안녕, 내 이름은 ${this.name}이야!`);\n};\nlet john = new Person('존', 30);\njohn.greet(); // \"안녕, 내 이름은 존이야!\"\n```\n\n\n\n# 상속:\n\n자바스크립트\n\n```js\nfunction Employee(name, age, department) {\n  Person.call(this, name, age);\n  this.department = department;\n}\nEmployee.prototype = Object.create(Person.prototype);\nlet employee = new Employee('Jane', 25, '마케팅');\nemployee.greet(); // \"안녕하세요, 제 이름은 Jane입니다!\"\n```\n\n# 4. DOM 조작과 이벤트\n\n\n\n문서 객체 모델(DOM)은 웹 개발의 기바입니다. 다음을 배워보세요:\n\n- DOM 요소 선택 및 조작하기\n- 이벤트 처리하기 (클릭, 호버, 제출 등)\n- 이벤트 위임과 버블링 사용하기\n\n코드 예시:\n\n- DOM 요소 선택 및 조작하기:\n\n\n\nJavaScript\n\n```js\nlet heading = document.querySelector('h1');\nheading.textContent = '새 헤딩';\n```\n\n# 이벤트 처리:\n\nJavaScript\n\n\n\n```js\nlet button = document.querySelector('button');\nbutton.addEventListener('click', function() {\n  console.log('버튼이 클릭되었습니다!');\n});\n```\n\n# 이벤트 위임:\n\nJavaScript\n\n```js\nlet ul = document.querySelector('ul');\nul.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    console.log('리스트 아이템이 클릭되었습니다!');\n  }\n});\n```\n\n\n\n# 5. 비동기 프로그래밍과 콜백\n\n자바스크립트에서 비동기 프로그래밍은 매우 중요합니다. 특히 외부 데이터나 API를 다룰 때:\n\n- 콜백과 고차 함수를 이해하세요.\n- 프로미스 및 async/await 구문에 대해 배우세요.\n- 오류 및 예외 상황을 다루세요.\n\n코드 예시:\n\n\n\n## 콜백:\n\n자바스크립트\n\n```js\nfunction loadData(callback) {\n  setTimeout(function() {\n    callback(['John', 'Jane', 'Bob']);\n  }, 2000);\n}\nloadData(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n```\n\n## 프로미스:\n\n\n\nJavaScript\n\n```js\nfunction loadData() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(['John', 'Jane', 'Bob']);\n    }, 2000);\n  });\n}\nloadData().then(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n```\n\n# Async/await:\n\nJavaScript\n\n\n\n```js\nasync function loadData() {\n  try {\n    let data = await fetch('(링크 제공 불가)');\n    console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n  } catch (error) {\n    console.error(error);\n  }\n}\nloadData();\n```\n\n# 6. JavaScript 객체 메소드와 배열\n\n필수 객체 메소드와 배열 조작 기술을 익혀보세요:\n\n- 객체 메소드 (keys, values, entries 등)\n- 배열 메소드 (map, filter, reduce 등)\n- 배열 구조 분해 및 전개\n\n\n\n코드 예시:\n\n# 객체 메소드:\n\n자바스크립트\n\n```js\nlet person = { name: 'John', age: 30 };\nconsole.log(Object.keys(person)); // 출력: [\"name\", \"age\"]\nconsole.log(Object.values(person)); // 출력: [\"John\", 30]\n```\n\n\n\n# 배열 메소드:\n\n자바스크립트\n\n```js\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(numbers.map(x =\u003e x * 2)); // 결과: [2, 4, 6, 8, 10]\nconsole.log(numbers.filter(x =\u003e x % 2 === 0)); // 결과: [2, 4]\n```\n\n# 배열 해체 및 전개:\n\n\n\n자바스크립트\n\n```js\nlet arr = [1, 2, 3];\nlet [first, ...rest] = arr;\nconsole.log(first); // 결과는 1\nconsole.log(rest); // 결과는 [2, 3]\n```\n\n```js\nlet newArr = [...arr, 4, 5];\nconsole.log(newArr); // 결과는 [1, 2, 3, 4, 5]\n```\n\n# 7. 클로저와 'this' 키워드\n\n\n\n클로저와 ‘this’ 키워드는 조금 까다로울 수 있지만, 이해하는 것이 중요합니다:\n\n- 클로저와 렉시컬 스코핑\n- ‘this’ 키워드와 컨텍스트 바인딩\n- bind, call, apply 메소드의 사용법\n\n코드 예시:\n\n# 클로저:\n\n\n\nJavaScript\n\n```js\nfunction outer() {\n  let x = 10;\n  function inner() {\n    console.log(x); // 10을 출력합니다\n  }\n  return inner;\n}\nlet innerFunc = outer();\ninnerFunc(); // 10을 출력합니다\n```\n\n# 'this' 키워드:\n\nJavaScript\n\n\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}!`);\n};\nlet john = new Person('John');\njohn.greet(); // 출력: \"Hello, my name is John!\"\n```\n\n# Bind, call, and apply:\n\nJavaScript\n\n```js\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\nlet greetJohn = greet.bind(null, 'John');\ngreetJohn(); // 출력: \"Hello, John!\"\n```\n\n\n\n```js\nlet person = { name: 'Jane' };\ngreet.call(person, person.name); // 출력: \"안녕, Jane!\"\nlet numbers = [1, 2, 3];\nconsole.log(Math.max.apply(null, numbers)); // 출력: 3\n```\n\n# 8. 오류 처리 및 디버깅\n\n오류를 처리하고 코드를 효과적으로 디버깅하는 방법을 배워보세요:\n\n- 오류 객체와 스택 추적 이해하기\n- console.log, debugger, 그리고 브라우저의 개발자 도구 사용하기\n- try-catch 블록 및 오류 처리 전략 구현하기\n\n\n\n코드 예시:\n\n## 오류 처리:\n\nJavaScript\n\n```js\ntry {\n  let x = 10 / 0;\n} catch (error) {\n  console.error(error); // \"Error: Division by zero\"이 출력됩니다.\n}\n```\n\n\n\n# 디버깅:\n\nJavaScript\n\n```js\nconsole.log('Hello'); // \"Hello\"를 출력합니다\ndebugger; // 실행을 일시 중단하고 DevTools를 엽니다\n```\n\n# 9. JavaScript Best Practices and Code Organization\n\n\n\n깨끗하고 유지보수 가능한 코드를 작성하기 위해 최상의 관행을 따르고 코드베이스를 조직화하세요:\n\n- 모듈식 코드와 임포트 사용\n- 네이밍 규칙과 코딩 표준 준수\n- 코드 분할과 트리 쉐이킹 구현\n\n코드 예시:\n\n\n# 모듈식 코드:\n\n\n\nJavaScript\n\n```js\n// greet.js\nfunction greet(name) {\n  console.log(`안녕, ${name}!`);\n}\nexport { greet };\n```\n\nJavaScript\n\n```js\n// main.js\nimport { greet } from './greet.js';\ngreet('John'); // 출력 결과: \"안녕, John!\"\n```\n\n\n\n# 네이밍 규칙 및 코딩 표준:\n\nJavaScript\n\n```js\n// 일관된 네이밍 규칙을 따르세요\nlet firstName = 'John';\nlet lastName = 'Doe';\n```\n\n```js\n// 일관된 들여쓰기와 공백을 사용하세요\nif (true) {\n  console.log('Hello');\n}\n```\n\n\n\n# 코드 분할과 트리 쉐이킹:\n\n자바스크립트\n\n```js\n// Webpack 또는 Rollup을 사용하여 코드를 작은 조각으로 분할하고\n// 사용하지 않는 코드를 제거하세요 (트리 쉐이킹)\n```\n\n# 10. 브라우저 호환성 및 웹 표준\n\n\n\n여러 브라우저에서 코드가 작동하도록 보장하고 웹 표준을 따르세요:\n\n- 브라우저의 특이점과 불일치를 이해하세요\n- 기능 감지와 폴리필 사용하기\n- 웹 표준과 접근성 가이드라인 준수하기\n\n코드 예시:\n\n\n# 기능 감지:\n\n\n\n\n자바스크립트\n\n```javascript\nif (typeof window.addEventListener === 'function') {\n  // 이벤트 리스너 추가\n} else {\n  // 대체 방법 사용\n}\n```\n\n## 폴리필:\n\n자바스크립트\n\n\n\n```js\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement) {\n    // Polyfill 구현\n  };\n}\n```\n\n# 웹 표준과 접근성:\n\nJavaScript\n\n```js\n// 시맨틱 HTML 요소 사용\n\u003cheader\u003e헤더\u003c/header\u003e\n\u003cnav\u003e네비게이션\u003c/nav\u003e\n\u003cmain\u003e주요 콘텐츠\u003c/main\u003e\n```\n\n\n\n```js\n// 접근성을 위해 ARIA 속성을 사용하세요\n\u003cbutton aria-label=\"제출\"\u003e제출\u003c/button\u003e\n```\n\n추가 자료\n\n- MDN Web Docs: JavaScript 문서 및 튜토리얼에 대한 포괄적인 자료\n- W3Schools: 웹 개발 튜토리얼 및 참고 자료가 있는 인기 있는 웹사이트\n- JavaScript Subreddit: JavaScript와 웹 개발에 대한 토론을 하는 커뮤니티 주도 포럼\n- Udemy 및 Coursera 강좌: JavaScript와 웹 개발 학습을 위한 온라인 강좌 및 튜토리얼\n\n# 결론\n\n\n\n\n자바스크립트의 기본을 완벽히 이해하는 것은 견고하고 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 구축하는 데 중요합니다. 이 블로그 포스트에서 다루는 주요 주제를 이해하면 더 고급 개념과 React, Angular, Vue.js와 같은 프레임워크에 대처할 준비가됩니다. 유능한 자바스크립트 개발자로 발전하기 위해 연습하고 실험하며 계속 학습해야합니다. 즐겨 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트의 비밀 병기를 발휘하라 StrictMode","description":"","date":"2024-05-14 12:17","slug":"2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode","content":"\n\n![StrictMode image](/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png)\n\nStrictMode는 당신이 그녀/그를 듣고 싶지 않더라도 진실을 말해주는 진짜 친구입니다. React 개발자들이 더 나은 방식으로 앱을 작성할 수 있도록 도와주는 도구로, 앱을 개발하는 과정에서 가능한 버그를 알려줍니다. 이는 개인용 들여쓰기 보조견과 같아요!\n\n# StrictMode에 관심을 가져야 하는 이유\n\nReact 개발자에게 StrictMode가 중요한 이유는 여러 가지가 있습니다:\n\n\n\n- 위험한 코드 식별: StrictMode를 사용하면 Android 문자열 ref API 사용이나 원치 않는 부작용과 같은 실행중 오류로 나타날 수 있는 문제를 잡을 수 있습니다.\n- 미래를 준비: StrictMode는 컴포넌트가 최신 React 버전 (그리고 동시 렌더링 같은 특징을 포함하는)과 완벽하게 작동하는 것을 보장합니다.\n- 성능 향상: StrictMode가 비효율적인 코드에 주목할 때, 응용 프로그램의 성능을 향상시키는 방법을 도와줍니다.\n\n# StrictMode의 주요 기능\n\nStrictMode는 더 깨끗하고 효율적인 React 코드를 작성하는 데 도움이 되는 여러 가지 확인 사항을 제공합니다:\n\n- 안전하지 않은 라이프사이클 식별: StrictMode는 componentWillMount, componentWillReceiveProps, componentWillUpdate 같은 고전 라이프사이클 방법을 사용하는 경우 동시 렌더링에서 불규칙성을 가져올 수 있는 경고를 표시합니다.\n- 레거시 문자열 ref API 사용에 대한 경고: 문자열 ref는 사용이 불필요하며 컴포넌트가 내부로 누출될 수 있습니다. StrictMode는 여전히 사용 중인 경우에 경고를 표시하여 콜백 기반 ref API로 전환하도록 장려합니다.\n- 예상치 못한 부작용 감지: StrictMode는 부작용을 나타내는 함수를 공개하고, 이는 불안정성, 성능 문제 및 더 어려운 추론을 초래할 수 있습니다.\n- 컨텍스트 API 호환성 보장: StrictMode는 응용 프로그램이 동시 렌더링을 허용하는 방식으로 컨텍스트 API를 사용하는지를 검증합니다.\n\n\n\n# 애플리케이션에 StrictMode 사용하기\n\nReact 애플리케이션에 StrictMode를 추가하는 것은 매우 쉽습니다. 확인하려는 컴포넌트를 `StrictMode` 컴포넌트로 감싸기만 하면 됩니다:\n\n```js\nimport React from 'react';\n\nfunction MyComponent() {\n  // ... 여러분의 컴포넌트 코드 ...\n}\n\nfunction App() {\n  return (\n    \u003cStrictMode\u003e\n      \u003cMyComponent /\u003e\n    \u003c/StrictMode\u003e\n  );\n}\n```\n\nStrictMode는 개발 도구일 뿐입니다. 프로덕션 빌드에 영향을 미치지 않습니다. 프로세스 초기에 문제가 있는 부분을 미리 발견하고 사용자에게 영향을 주지 않고 변경할 수 있도록 도와줍니다.\n\n\n\n# StrictMode의 현실 세계에서 얻는 이점\n\n저는 거대한 React 애플리케이션을 작업하는 세 명의 팀 중 한 명이었을 때 이상한 렌더링 버그로 골머리를 앓고 있었습니다. 마음이 놓여지지 않아 제 남은 머리카락을 뽑았지만, 우리 모듈을 StrictMode 명령어로 감싸보기로 결정했습니다. 놀라운 일에, 많은 결함을 즉시 가리켰는데, 그 중에는 위험한 라이프사이클 메소드를 사용하는 문제와 부작용이 있었습니다.\n\n우리는 이러한 문제에 신속히 대응할 수 있었고, 이로써 우리의 애플리케이션을 더 안정적이고 효율적으로 만들었습니다. 의심의 여지 없이, Android StrictMode는 우리 코드에 건강 진단을 해준 것이었습니다!\n\n# 결론: StrictMode 이점을 온전히 받아들이세요\n\n\n\nStrictMode는 모든 리액트 개발자가 코드 품질을 향상시키면서 더 능숙해지도록 도와주는 도구입니다. 어쩌면 조금 엄격한 친구처럼 느껴질 수 있지만 제공되는 사실들은 최상이며 가장 소중합니다. 그러므로 StrictMode에 대해 더 깊이 배우고, 리액트 코딩 경험을 한 단계 높여줄 가능성을 지켜보는 것을 꺼리지 마세요!\n\n# 콜 투 액션: 오늘부터 StrictMode 사용하기!\n\nStrictMode 도구를 귀하의 리액트 애플리케이션에 추가해 주시기 바랍니다. 게다가, 이와 같은 도구는 해당 문제와 코드에 미칠 긍정적인 영향에 대해 귀하를 놀라게 할 수도 있습니다. 약간의 엄격함은 리액트 개발 현상에서 중요하다는 말을 기억하세요.","ogImage":{"url":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"},"coverImage":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컴포넌트 라이프사이클 메서드","description":"","date":"2024-05-14 12:16","slug":"2024-05-14-ReactComponentLifecycleMethods","content":"\n\n![React Component Lifecycle Methods](/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png)\n\n프론트엔드 개발에서 React는 사용자 인터페이스를 구축하기 위한 가장 인기 있는 JavaScript 라이브러리 중 하나입니다. React가 강력한 이유 중 하나는 구성 요소 기반 아키텍처입니다. React 구성 요소가 라이프사이클 동안 어떻게 작동하는지 이해하는 것은 효율적인 애플리케이션을 구축하는 데 중요합니다.\n\n# React 구성 요소 라이프사이클 메서드란?\n\nReact 구성 요소는 초기화부터 파괴까지 라이프사이클 동안 다양한 단계를 거칩니다. React는 마운팅, 업데이팅 및 언마운팅 세 가지 단계로 분류할 수 있는 빌트인 메서드 집합인 라이프사이클 메서드를 제공합니다. 이 메서드를 사용하면 개발자는 이러한 단계에 훅을 걸어 작업을 수행할 수 있습니다.\n\n\n\n# 마운팅 단계:\n\n— constructor(): 이 메서드는 컴포넌트가 초기화될 때 호출됩니다. 상태를 초기화하고 이벤트 핸들러를 바인딩하는 데 사용됩니다.\n— render(): 이는 컴포넌트 UI의 JSX 표현을 반환하는 필수적인 메서드입니다. 컴포넌트가 다시 렌더링되어야 할 때마다 호출됩니다.\n— componentDidMount(): 컴포넌트가 마운트된 직후에 즉시 호출됩니다. 데이터 가져오기, 구독, 또는 제3자 라이브러리 초기화와 같은 부작용을 수행하는 데 자주 사용됩니다.\n\n# 업데이트 단계:\n\n— static getDerivedStateFromProps(): 이 메서드는 새로운 속성이 수신될 때 렌더링하기 바로 전에 호출됩니다. 속성 변경에 따라 상태를 업데이트할 수 있도록 합니다.\n— shouldComponentUpdate(): 이 메서드는 컴포넌트가 다시 렌더링해야 할지 여부를 결정합니다. 불필요한 다시 렌더링을 방지하여 성능을 최적화하는 데 사용됩니다.\n— render(): 업데이트된 상태나 속성으로 컴포넌트를 다시 렌더링합니다.\n— getSnapshotBeforeUpdate(): 가상 DOM의 변경이 실제 DOM에 반영되기 전 바로 호출됩니다. 업데이트 전에 일부 정보(예: 스크롤 위치)를 캡처할 수 있습니다.\n— componentDidUpdate(): 컴포넌트의 업데이트가 DOM으로 플러시된 후에 호출됩니다. 업데이트 이후에 업데이트된 데이터 가져오기 또는 업데이트 후 DOM과 상호 작용하는 등 부작용 수행에 자주 사용됩니다.\n\n\n\n# Unmounting Phase:\n\n— `componentWillUnmount()`: 컴포넌트가 언마운트되고 파괴되기 직전에 즉시 호출됩니다. 이는 이벤트 리스너 제거 또는 네트워크 요청 취소와 같은 정리 작업에 사용됩니다.\n\n라이프사이클 메소드 이해하기: \n각 라이프사이클 메소드는 특정 목적을 위해 제공되며, 개발자가 컴포넌트의 라이프사이클의 다른 단계에 훅을 걸고 그에 따라 작업을 수행할 수 있게 합니다.\n\n# 최상의 실천 방법:\n\n\n\n- 라이프사이클 메서드를 적게 사용하세요: React Hooks가 소개되면서 라이프사이클 메서드 대부분은 레거시로 간주되어 `useEffect`와 같은 Hooks를 선호하는 방식으로 대체되고 있습니다.\n- `render()`에서 부작용을 피하세요: `render()` 메서드는 순수해야 하며 부작용을 발생시키지 말아야 합니다. 부작용은 `componentDidMount()`나 함수형 컴포넌트의 `useEffect()`에서 수행되어야 합니다.\n- 성능에 유의하세요: `shouldComponentUpdate()`나 `React.memo()`를 사용하여 불필요한 다시 렌더링을 방지하여 컴포넌트 성능을 최적화하세요.\n- 자원 정리: 항상 `componentWillUnmount()`나 `useEffect()` 정리 함수에서 이벤트 리스너 제거 또는 구독 취소와 같은 정리 작업을 수행하세요.\n\n# 결론:\n\nReact 컴포넌트 라이프사이클 메서드를 이해하는 것은 확장 가능하고 효율적인 애플리케이션을 구축하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png","tag":["Tech"],"readingTime":3},{"title":"갇혀 있는 극악무도한 보안의 심연으로부터","description":"","date":"2024-05-14 12:15","slug":"2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity","content":"\n\nChapter three\n\n![Locked away from the depths of maximum security](/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png)\n\n금속 잠금장치가 동기화되어 열리는 소리가 복도를 통과하던 중, 트로이는 셀의 구금에서 벗어난다. 낮 시간이라 불리는 이 방 안에는 각각 여덟 개의 의자가 놓인 네 개의 탁자와 그 위에 위험하게 걸린 작은 32인치 TV가 있었다. 이것은 그들의 수감 상황을 뚜렷하게 상기시키는 것이었다. 수감자들이 셀에서 나와 공동 샤워, 카드 게임, 체스 대결 및 혼자만의 독서를 위한 필수품을 가지고 나왔다.\n\n그에게 다가온 것은 트로이가 그 유닛의 권위자로 가정했던 수감자였다. 5피트 9인치의 자신과 비슷한 키에 밝은 피부와 풍만한 체격을 가진 그 남자는 자신의 총명한 눈이 트로이의 눈을 뚫어봤다. 그는 “절차 알지? 정원에 있거나 짐 싸\"라고 권위적으로 말했다. 트로이는 ‘정원’이라는 말이 가지고 있는 함의를 이해했고, 이는 동맹원들이 구성원들에 대한 기록을 유지하는 시스템으로, 충돌 발생 시 중요하다. “자가 통치 선택권이 있어,\" 트로이가 반박했다.\n\n\n\n사람은 트로이의 억양을 무시하며, 최대한의 단위에서는 그와 같은 선택지가 없다고 설명했습니다. 트로이는 잠시 고민한 뒤 결과를 따져 보았습니다. '물러나다'는 자신을 드러내어 보호자가 되었지만 보복에 취약하게 남게 될 것이었습니다. 보호 관찰은 선택지가 아니었습니다. 그래서 마침내, 그는 설립된 기관들과 조인하기로 선택했습니다. 사람은 자신을 프리모로 소개했습니다. 트로이는 자신의 혐의를 폄하했습니다. 폭력사건 중에서도 어울리지 않는 약물 범행의 나열이었습니다. 프리모는 안심시켜 주며, 다른 구금구역으로의 이송을 약속했고, 그것은 트로이의 불안을 일시적으로 완화시켰습니다.\n\n그러나 폭력적인 범죄자들과 함께 한 유닛을 공유해야 한다는 현실은 트로이에게 큰 부담이었습니다. 다른 수감자들에게 다가올 때, 그는 조심스럽게 경계를 지키며 잠재적인 위협에 대해 예민하게 인식했습니다. TV의 깜박이는 빛 앞에 서있을 때, 트로이는 가족 - 어머니, 일곱 형제자매, 당시의 여자친구에 대한 생각으로 빛난 것에 주목했습니다. 외부 세계와의 연결 통로인 전화는 절망적인 전화를 위한 자금이 부족하여 조용했습니다.\n\n빅 에이가 제공한 수건, 비누, 식사화로 트로이는 지친 신체를 풀며 수영장으로 향했습니다. 재순환된 공기와 머무른 땀의 쇠약한 향기에 감싸여. 하루의 노엽을 씻어내는 고독 속에서, 트로이의 마음은 대립하는 생각과 달려 있는 것으로 뒹굴었습니다. 그를 둘러쌓은 피부에 남아 있는 늙은 먼지의 익숙한 냄새는, 그의 처지 - 사생활의 부재, 결정의 무게, 그리고 반복되는 감금에 대한 가족의 감정의 불확실함을 생생히 상기시켰습니다.\n\n트로이가 지친 몸에 쏟아지는 뜨거운 물과 함께, 그의 생각은 더욱 조각난 것처럼 더 혼란스러워졌습니다. 각각의 물방울은 그의 의심과 두려움을 메아리하며, 옥상을 흐르는 목소리와 금속의 딩동 소리와 섞였습니다. 트로이는 침착을 유지하려고 애썼지만, 그를 꺾어버릴 듯한 불안감의 끈 같은 감정이 그를 잡아채는 것을 흔들릴 수 없었습니다.\n\n\n\n한 시간 반이 지났지만, 갇힌 삶의 답답한 반복 속에서는 영원히 느껴졌다. 시간은 흘러가고, 트로이는 방향감소와 외부 세계에 대한 그리움을 느끼게 되었다. 다른 죄수들이 다시 감방으로 후퇴하는 것을 지켜보면서, 그는 지역 감옥 벽 안에서 시간이 무자비하게 흘러가는 것에 절망적인 감정을 억누를 수 없었다.","ogImage":{"url":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"},"coverImage":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png","tag":["Tech"],"readingTime":2},{"title":"React Js 설치 방법 완전 초보자용","description":"","date":"2024-05-14 12:14","slug":"2024-05-14-HowToInstallReactJsForcompletebeginners","content":"\n\n\n![React installation](/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png)\n\n요즘 리액트를 배우는 데 흥미를 느끼고 있고 리액트를 시작했습니다. 이 강력한 JavaScript 프레임워크를 사용하는 첫 번째 단계는 무엇일까요? React를 설치하기 전에 먼저 Node를 설치해야 합니다. 프로세스는 node 웹 사이트를 방문하고 최신 지원 버전을 다운로드하는 것만큼 간단합니다. Node가 필요한 이유가 궁금하다면, Node.js는 서버 측에서 JavaScript를 실행할 수 있는 JavaScript 런타임 환경입니다 (나중에 이에 대한 자세한 기사를 쓸 것입니다). 그 후 명령줄로 이동하여 명령줄이 익숙하지 않은 경우를 대비해 검색할 수 있습니다. React를 설치하는 방법에는 여러 가지가 있습니다:\n\na) CDN 사용 (가장 쉬운 방법)\n\n이 코드 조각을 html 코드의 head 부분에 포함하세요.\n\n\n\n\n```js\n\u003cscript crossorigin src=\"https://unpkg.com/react@18/umd/react.development.js\"\u003e\u003c/script\u003e\n\u003cscript crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"\u003e\u003c/script\u003e\n```\n\n이것은 쉽지만 제품 환경보다는 개발 환경에 권장됩니다. 학습을 시작할 때만 사용하는 것이 좋습니다.\n\na) Vite를 사용하는 방법\n\n명령줄에 다음과 같이 입력하세요: npm create vite@latest app_name — — template react. 그리고 npm install을 실행하고 코드를 행복하게 작성하세요. 이 방법의 장점은 vite가 다양한 기능을 갖추고 빠르며 서버를 빠르게 실행한다는 것입니다.```\n\n\n\nb) 이전 React 방식을 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-react-app 앱-이름. 그리고 나서 코딩을 즐기세요. 이 방법은 vite와 같은 다른 방법보다 서버를 빨리 구동하는 것에 비해 느릴 수 있습니다.\n\nc) Next.js 프레임워크를 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-next-app@latest 질문에 답하고 설치하세요. 다만, TypeScript/JavaScript, React, 그리고 tailwind CSS에 대한 선행 지식이 필요합니다.\n\n\n\n기존 프로젝트에서는 npm install react react-dom을 사용하여 프로젝트에 React를 추가할 수 있어요. Gatsby, remix와 같은 다양한 프레임워크도 설치할 수 있어요. 더 많은 정보를 원하시면 직접 찾아보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"},"coverImage":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 언제 useRef 대신에 useState를 사용해야 할까요","description":"","date":"2024-05-14 12:13","slug":"2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState","content":"\n\nReact에서 useRef는 함수형 컴포넌트 내에서 DOM 요소나 다른 React 요소를 참조하는 데 사용되는 훅입니다. (이 훅을 사용하면 함수형 컴포넌트가 클래스 컴포넌트의 this.refs와 유사한 기능을 활용할 수 있습니다.)\n\nuseRef를 사용하면 컴포넌트의 렌더링 여부에 관계없이 동일한 참조를 유지할 수 있습니다. 컴포넌트가 다시 렌더링되더라도 참조가 변경되지 않도록 보장할 수 있어 유용합니다.\n\n예를 들어 useRef를 사용하여 특정 DOM 요소에 대한 참조를 얻어 해당 요소를 프로그래박적으로 조작할 수 있습니다.\n\n\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst MyComponent = () =\u003e {\n  const myRef = useRef(null);\n\n  useEffect(() =\u003e {\n    // 컴포넌트가 마운트될 때 DOM 요소에 포커스를 설정합니다.\n    myRef.current.focus();\n  }, []);\n\n  return \u003cinput ref={myRef} /\u003e;\n};\n\nexport default MyComponent;\n```\n\n이 예제에서 useRef를 사용하여 myRef 변수를 만들고 그것을 입력 요소에 할당합니다. useEffect 훅을 사용하여 컴포넌트가 마운트될 때 해당 요소에 포커스를 설정합니다. myRef.current 프로퍼티를 사용하여 기본 DOM 요소에 액세스합니다.\n\n그럼 언제 useState 대신 useRef를 사용해야 할까요?\n\nuseState와 useRef는 React Hooks에서 서로 다른 목적을 제공합니다.```\n\n\n\nuseState: 컴포넌트의 상태를 관리하는 데 사용됩니다. 주로 컴포넌트의 상태가 변경될 때 다시 렌더링되기를 원할 때 사용됩니다. 상태가 변경되면 컴포넌트가 다시 렌더링됩니다. useRef: 렌더링과 직접적으로 관련이 없는 값을 유지해야 할 때 사용됩니다. 주로 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 직접적으로 관련이 없는 값들을 저장하는 데 사용됩니다. 따라서 useState와 useRef는 각각의 사용 사례에 따라 선택되어져야 합니다.\n\nuseRef를 사용하는 일반적인 시나리오는 다음과 같습니다:\n\n렌더링과 관련이 없는 값들 저장하기 DOM 요소에 대한 참조 저장하기 값이 변경되더라도 다시 렌더링이 필요하지 않은 경우 더 잘 이해하기 위해 예시와 설명을 살펴보겠습니다.\n\nuseState의 예제\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst Counter = () =\u003e {\n  const [count, setCount] = useState(0);\n\n  const increment = () =\u003e {\n    setCount(count + 1);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e카운트: {count}\u003c/p\u003e\n      \u003cbutton onClick={increment}\u003e증가\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Counter;\n```\n\n이 예제에서는 useState 훅을 사용하여 count 상태를 정의하고 업데이트하는 함수인 setCount를 정의합니다. count 상태가 컴포넌트의 렌더링에 직접적으로 영향을 주기 때문에 상태가 변경될 때마다 컴포넌트가 다시 렌더링됩니다.\n\nuseRef 예시\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst Timer = () =\u003e {\n  const intervalRef = useRef(null);\n  const secondsRef = useRef(0);\n\n  useEffect(() =\u003e {\n    intervalRef.current = setInterval(() =\u003e {\n      secondsRef.current += 1;\n      console.log('초:', secondsRef.current);\n    }, 1000);\n\n    return () =\u003e {\n      clearInterval(intervalRef.current);\n    };\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e타이머: {secondsRef.current} 초\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e clearInterval(intervalRef.current)}\u003e정지\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Timer;\n```\n\n\n\n이 예에서 useRef 훅을 사용하여 두 개의 레퍼런스를 생성합니다: intervalRef와 secondsRef입니다. intervalRef는 setInterval의 반환 값을 저장하며, secondsRef는 시간을 추적하는 데 사용됩니다. useEffect 훅은 컴포넌트가 마운트될 때 setInterval을 시작하고 언마운트될 때 정리합니다. secondsRef는 컴포넌트의 렌더링과는 관계없이 값을 유지하며, secondsRef.current는 현재 시간을 추적하고 표시하는 데 사용됩니다.\n\n이 두 예제는 useState가 컴포넌트의 상태를 관리하고 렌더링을 트리거하는 데 사용되는 반면, useRef는 렌더링과 직접적으로 관련되지 않는 값을 저장하거나 DOM 요소에 액세스하는 데 사용됨을 보여줍니다.\n\n데이터가 많을수록 useRef를 사용해야 하는 경우가 더 많아지며, 이번에는 동일한 프로그램의 예제를 통해 이를 확인해볼 것입니다.\n\nuseState를 이용한 예제:\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst BigDataComponent = () =\u003e {\n  const [data, setData] = useState('');\n\n  const fetchData = () =\u003e {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // 데이터가 증가함에 따라 렌더링이 지연될 수 있습니다\n    const newData = '아주 많은 데이터...';\n    setData(newData);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e\n      \u003cp\u003e데이터 길이: {data.length}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default BigDataComponent;\n```\n\n이 예제에서는 useState를 사용하여 데이터를 관리하고, 버튼을 클릭할 때마다 fetchData 함수를 호출하여 많은 양의 데이터를 가져옵니다. 그러나 데이터 양이 증가함에 따라 렌더링이 느려질 수 있습니다.\n\nuseRef를 사용한 예제\n\n```js\nimport React, { useRef } from 'react';\n\nconst BigDataComponent = () =\u003e {\n  const dataRef = useRef('');\n\n  const fetchData = () =\u003e {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // useRef를 사용하여 컴포넌트의 렌더링에 영향을 미치지 않고 데이터를 설정합니다\n    const newData = '아주 많은 데이터...';\n    dataRef.current = newData;\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e\n      \u003cp\u003e데이터 길이: {dataRef.current.length}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default BigDataComponent;\n```\n\n\n\n이 예에서는 useRef를 사용하여 데이터를 관리합니다. 데이터 양이 증가해도 useRef를 사용하면 데이터를 설정할 때 컴포넌트의 렌더링 속도에 영향을 미치지 않습니다.\n\n이 두 예시를 통해 데이터 양이 증가할수록 useState는 느려질 수 있지만 useRef를 사용하면 데이터가 늘어나도 렌더링에 영향을 미치지 않고 데이터를 관리할 수 있다는 것을 알 수 있습니다.\n\n다시 말해, useRef의 중요한 특징 중 하나는 렌더링과 관련이 없는 값의 보존입니다.\n\n- 렌더링과 관련이 없는 값의 보존: useRef로 생성된 ref 객체의 current 프로퍼티에 할당된 값은 컴포넌트를 다시 렌더링해도 변경되지 않습니다. 이를 통해 useRef는 컴포넌트의 렌더링과는 독립적인 값을 유지할 수 있으며, 컴포넌트 상태와 관련이 없는 값을 보존하는 데 유용합니다.\n- 렌더링 주기 중 값이 변경되어도 다시 렌더링을 트리거하지 않음: useRef로 생성된 객체의 current 프로퍼티에 값이 렌더링 주기 중에 할당되더라도 컴포넌트는 다시 렌더링되지 않습니다. 따라서 useState와 달리 상태 업데이트가 렌더링을 트리거하지 않으므로 다시 렌더링 없이 값의 변화를 허용합니다. useRef를 사용하여 렌더링과 관련이 없는 값을 관리하거나 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 관련이 없는 값들을 다루는데 유용합니다. 이러한 특징들은 useRef를 사용하여 컴포넌트 렌더링과는 독립적인 데이터를 관리하거나 DOM 요소에 접근할 때 매우 유용합니다.\n\n\n\n이를 효과적으로 활용하려면 React 렌더링에 대한 포괄적인 이해가 필수적입니다. 아래에는 React에서 렌더링이 작동하는 방식에 대한 기본 개념부터 최적화까지 간략한 개요가 있습니다.\n\n- 가상 DOM: 가상 DOM은 React에 의해 추상화된 실제 DOM의 가상 표현입니다. 상태 변경과 같은 이벤트가 발생하면 React는 가상 DOM을 업데이트하고 이를 실제 DOM과 비교하여 최소한의 작업을 적용하여 실제 DOM을 업데이트합니다. 이 과정은 성능을 향상시키고 불필요한 렌더링을 방지합니다.\n\n- 컴포넌트 렌더링 프로세스:\n\n  - 초기 렌더링: React 애플리케이션이 시작되면 컴포넌트 트리가 렌더링되어 초기 UI가 생성됩니다.\n  - 상태 또는 속성 변경: 사용자 상호작용과 같은 이벤트로 상태 또는 속성이 변경될 수 있습니다.\n  - 가상 DOM 업데이트: 상태 또는 속성이 변경되면 React는 해당 컴포넌트의 가상 DOM을 업데이트합니다. 필요없는 렌더링이나 DOM 조작을 최소화하기 위해 가상 DOM의 변경사항을 효율적으로 계산합니다.\n  - 실제 DOM 업데이트: 가상 DOM의 변경사항을 계산한 후 React는 실제 DOM과 비교하여 차이점을 식별하고 실제 DOM의 필요한 부분만 업데이트합니다. 이 최적화는 브라우저에서 불필요한 렌더링을 최소화합니다.\n\n- 렌더링 최적화: React는 성능을 최적화하기 위한 다양한 기술을 제공합니다:\n\n\n\n- PureComponent와 React.memo: 이들은 컴포넌트의 불필요한 다시 그리기를 방지하는 데 사용됩니다. PureComponent는 클래스 컴포넌트에 사용되며, React.memo는 함수형 컴포넌트에 사용됩니다.\n- shouldComponentUpdate 또는 React.memo를 사용한 컴포넌트 최적화: 이러한 방법을 사용하면 컴포넌트가 업데이트해야 하는 조건을 정의하여 다시 그리기를 제어하고 최적화할 수 있습니다.\n- 불변성 유지: 불변성을 유지함으로써 React는 상태가 변경될 때 새로운 객체를 생성하여 불필요한 다시 그리기를 방지합니다.\n\n이러한 렌더링 프로세스와 최적화 기술을 이해하면 효율적인 React 애플리케이션을 개발할 수 있습니다.\n\n다음 섹션에서는 더 나은 최적화를 위해 메모이제이션을 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png"},"coverImage":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 컨텍스트를 올바르게 활용하기","description":"","date":"2024-05-14 12:12","slug":"2024-05-14-UsingReactcontextstherightway","content":"\n\n리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.\n\n적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.\n\n![이미지](/assets/img/2024-05-14-UsingReactcontextstherightway_0.png)\n\n# 컨텍스트를 작성하는 방식의 관용적인 방법\n\n\n\n제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.\n\n이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.\n\n상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.\n\n그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.\n\n\n\n저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.\n\n저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.\n\n이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:\n\n그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:\n\n\n\n훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.\n\n한 가지씩 몇 가지 예시를 살펴보겠습니다.\n\n## URL에 상태 저장하기\n\n두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.\n\n\n\n## 로컬 스토리지에 상태 저장하기\n\n마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.\n\n마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:\n\n이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.\n\n\n\n## 파생 상태 노출 및 사용자 정의 작업 노출하기\n\nProvider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.\n\n다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.\n\n이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.\n\n\n\n# 컨텍스트 생성을 덜 번거롭게 만들기\n\n일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.\n\n그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.\n\n앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.\n\n\n\n다음과 같이 전역 범위에서 사용할 수 있습니다:\n\n이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 \"의사 전역\" 상태를 매우 쉽게 생성할 수 있습니다.\n\n여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.\n\n## 기타 장점\n\n\n\n요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:\n\n- 다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)\n- 중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.\n- 내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.\n- 데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.\n\n# 결론\n\n캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.\n\n\n\n내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"},"coverImage":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png","tag":["Tech"],"readingTime":4},{"title":"스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기","description":"","date":"2024-05-14 12:09","slug":"2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs","content":"\n\n다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png)\n\n언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.\n\nNext.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.\n\n\n\n# 데모\n\n기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻\n\n# 준비물\n\n구현을 시작하기 위해 다음이 필요합니다:\n\n\n\n- Node.js 18 또는 그 이후 버전\n- Stream 계정\n- Vercel 계정\n\n# 새 Stream 애플리케이션 설정하기\n\n이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.\n\nStream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_1.png\" /\u003e\n\n어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_2.png\" /\u003e\n\n설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.\n\n\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png)\n\n권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 \"인증 확인 비활성화\" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png)\n\n방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.\n\n\n\n사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png)\n\n방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 \"메시지 생성\" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png)\n\n\n\n방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png)\n\n마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png)\n\n\n\n이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.\n\n# 새 Next.js 애플리케이션 설정\n\n이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.\n\n새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:\n\n\n\n```js\r\nnpx create-next-app@latest my-chat-app\r\n```\r\n\r\n진행할 때, 다음을 선택하세요:\r\n\r\n- TypeScript를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- ESLint를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- Tailwind CSS를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- src/ 디렉토리를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- App Router를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- 기본 import alias를 맞춤 설정할 것인지 물으면 \"No\"를 선택하세요.\r\n\r\n위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:```\n\n\n\n```js\ncd my-chat-app\nnpm run dev\n```\n\n앱은 localhost:3000에서 실행 중이어야 합니다.\n\n이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.\n\n다음과 같이 보여야 합니다:```\n\n\n\n```js\n# .env\n\n# 스트림 환경 변수\nNEXT_PUBLIC_STREAM_API_KEY=\"...\"\n\n```\n\n## shadcn/ui 컴포넌트 통합\n\n채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n\n\n구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:\n\n- TypeScript를 사용하것이라고 하면 \"예\"를 선택하세요.\n- 사용할 스타일을 선택하라는 프롬프트가 나오면 \"기본\"을 선택하세요.\n- 기본 색상으로 선택하라는 프롬프트가 나오면 \"Slate\"를 선택하세요.\n- 색상에 CSS 변수를 사용하냐고 묻힐 경우 \"예\"를 선택하세요.\n\n위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.\n\n```js\nnpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add textarea\n```\n\n\n\n그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.\n\n## Chatscope 및 Stream UI Kit를 React에 설치하기\n\n구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.\n\n먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.\n\n\n\n위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n```js\nnpm install @chatscope/chat-ui-kit-react\nnpm install stream-chat stream-chat-react\nnpm install unique-username-generator\n```\n\n다음 라이브러리가 설치됩니다:\n\n- unique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.\n- stream-chat: Stream의 JavaScript API 클라이언트입니다.\n- stream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.\n- @chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.\n\n\n\n자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.\n\n# ChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기\n\n이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.\n\n먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.\n\n\n\n앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:\n\n```js\nimport { cn } from \"@/lib/utils\";\nimport { useChannelStateContext } from \"stream-chat-react\";\nimport { Message, MessageList } from \"@chatscope/chat-ui-kit-react\";\n\nexport default function () {\n  const { messages } = useChannelStateContext();\n  return (\n    \u003cMessageList\u003e\n      {messages?.map((i, index: number) =\u003e (\n        \u003cMessage\n          key={i.id}\n          model={{\n            position: \"normal\",\n            sender: i.user?.id,\n            direction: \"incoming\",\n            message: `${i.user?.id}: ${i.text}`,\n            sentTime: i.created_at?.toString(),\n          }}\n          className={cn(\n            \"bg-white rounded text-black py-2 text-xs\",\n            index !== messages.length - 1 \u0026\u0026 \"border-b\"\n          )}\n        /\u003e\n      ))}\n    \u003c/MessageList\u003e\n  );\n}\n```\n\n`useChannelStateContext` 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. `MessageList` 및 `Message` Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.\n\n이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:\n\n\n\n```js\n\"use client\";\n\nimport { useState } from \"react\";\nimport Messages from \"./Messages\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\nimport { Textarea } from \"@/components/ui/textarea\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        \u003cspan className=\"border-b border-gray-100 font-semibold\"\u003e채팅\u003c/span\u003e\n        {channel \u0026\u0026 (\n          \u003cChat client={chatClient}\u003e\n            \u003cChannel channel={channel}\u003e\n              \u003cMessages /\u003e\n            \u003c/Channel\u003e\n          \u003c/Chat\u003e\n        )}\n        \u003cTextarea\n          id=\"message_text\"\n          name=\"message_text\"\n          placeholder=\"메시지...\"\n          className=\"min-h-[100px] w-full\"\n        /\u003e\n        \u003cButton className=\"max-w-max\"\u003e\n          메시지 보내기 \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:\n\n```js\n\"use client\";\n\nimport Messages from \"./Messages\";\n+ import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\n+ import { DevToken, StreamChat } from \"stream-chat\";\nimport { Textarea } from \"@/components/ui/textarea\";\n+ import { generateUsername } from \"unique-username-generator\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+ const loadChatClient = async () =\u003e {\n+   const newChatClient = new StreamChat(\n+     process.env.NEXT_PUBLIC_STREAM_API_KEY,\n+     {\n+       enableWSFallback: true,\n+     }\n+   );\n+    if (newChatClient.user) await newChatClient.disconnectUser();\n+   const localUser = localStorage.getItem(\"local_user\");\n+   if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n+   const id = localStorage.getItem(\"local_user\");\n+   const userToConnect = { id };\n+   await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n+   setChatClient(newChatClient);\n+ };\n+ useEffect(() =\u003e {\n+   loadChatClient();\n+ }, []);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 그대로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.```\n\n\n\n특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:\n\n```js\n\"use client\";\n\n// Imports as is\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+  const watchChannel = () =\u003e {\n+    const channel = chatClient.channel(\"messaging\", \"livestreaming_chat\", {\n+      name: \"실시간 스트리밍 채팅\",\n+    });\n+    channel.watch().then(() =\u003e setChannel(channel));\n+  };\n  const loadChatClient = async () =\u003e {\n    const newChatClient = new StreamChat(\n      process.env.NEXT_PUBLIC_STREAM_API_KEY,\n      {\n        enableWSFallback: true,\n      }\n    );\n    if (newChatClient.user) await newChatClient.disconnectUser();\n    const localUser = localStorage.getItem(\"local_user\");\n    if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n    const id = localStorage.getItem(\"local_user\");\n    const userToConnect = { id };\n    await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n    setChatClient(newChatClient);\n  };\n  useEffect(() =\u003e {\n    loadChatClient();\n  }, []);\n+  useEffect(() =\u003e {\n+    if (chatClient) watchChannel();\n+  }, [chatClient]);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.\n\n채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\n\"use client\";\n\n// 그대로 가져오기\n\nexport default function () {\n  // 변수, 훅 그대로\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        {/* 컴포넌트 나머지 */}\n        \u003cButton\n          className=\"max-w-max\"\n          onClick={() =\u003e {\n            if (channel) {\n              channel.sendMessage({\n                text: document.getElementById(\"message_text\").value,\n              });\n              document.getElementById(\"message_text\").value = \"\";\n            }\n          }\n        \u003e\n          Send Message \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nonClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!\n\n이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.\n\n# Vercel에 배포하기\n\n\n\n이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:\n\n- 먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.\n- 그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.\n- 새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.\n- 설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.\n- 배포를 클릭합니다.\n\n# 마치며\n\n요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.\n\n\n\n# 더 많은 정보\n\n더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.\n\n- GitHub 저장소\n- 챗스코프 UI 킷\n- 인증되지 않은 사용자 - 스트림\n- 채널 시청 - 스트림","ogImage":{"url":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"},"coverImage":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png","tag":["Tech"],"readingTime":12},{"title":"한국어 Axios 인터셉터란 무엇인가요","description":"","date":"2024-05-14 12:08","slug":"2024-05-14-ENWhatareAxiosInterceptors","content":"\n\n![Axios Interceptors](/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png)\n\n인터셉터란 무엇인가요?\n인터셉터는 프로그램의 기능을 확장하거나 수정하는 데 사용되는 디자인 패턴입니다. Axios에서 인터셉터는 HTTP 요청과 응답을 처리하는 데 사용되는 특별한 함수입니다. 요청 인터셉터를 사용하면 요청을 보내기 전에 작업을 수행할 수 있고, 응답 인터셉터는 서버에서 반환된 응답에 작업을 수행할 수 있습니다.\n\nAxios 인터셉터를 사용해야 하는 이유는 무엇인가요?\n\n- 재사용성과 모듈성.\n- 오류 처리 용이성.\n- 보안 제어 및 인가 유효성 검사 프로세스 용이성.\n- 네트워크 문제 처리.\n- 사용 편의성과 유연성.\n- 성능 및 최적화.\n\n\n\nAxios Interceptors의 사용법\n간단한 사용법을 가지고 있고 Axios 내에서 추가 설정이 필요하지 않아 장점을 제공합니다.\n\n```js\nconst axiosInstance = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': null\n  }\n});\n\naxiosInstance.interceptors.request.use(\n  function (config) {\n    // 요청을 보내기 전 수행할 작업\n    console.log('요청을 보냅니다:', config);\n    \n    // 예를 들어, 각 요청에 세션 식별자를 추가할 수 있습니다.\n    const accessToken = localStorage.getItem('accessToken');\n    if (accessToken) {\n      config.headers.Authorization = `Bearer ${accessToken}`;\n    }\n\n    return config;\n  }, \n  function (error) {\n    // 요청 오류 발생 시 수행할 작업\n    console.error('요청 오류:', error);\n    return Promise.reject(error);\n  }\n);\n\naxiosInstance.interceptors.response.use(\n  function (response) {\n    // 응답이 성공했을 때 수행할 작업\n    console.log('응답:', response.data);\n    return response;\n  },\n  function (error) {\n    // 응답 오류 발생 시 수행할 작업\n    console.error('응답 오류:', error);\n    \n    // 예를 들어, 401 (Unauthorized) 오류 발생 시 세션이 만료된 것으로 가정할 수 있습니다.\n    if (error.response.status === 401) {\n      // 세션 새로 고침이나 로그인 페이지로 리다이렉트하는 등의 작업 수행 가능\n      console.log('세션이 만료되었습니다. 리다이렉트 중...');\n      // 예를 들어, 사용자를 로그인 페이지로 리다이렉트:\n    }\n    return Promise.reject(error);\n  }\n);\n\n// 예시 요청\n\naxiosInstance.get('/data')\n  .then(response =\u003e {\n    console.log('응답:', response.data);\n  })\n  .catch(error =\u003e {\n    console.error('오류:', error);\n  });\n\naxiosInstance.post('/post-data', {\n  // 전송할 데이터\n  firstName: 'John',\n  lastName: 'Doe'\n})\n.then(response =\u003e {\n  console.log('응답:', response.data);\n})\n.catch(error =\u003e {\n  console.error('오류:', error);\n});\n```\n\n🚀🚀 이 예시처럼 들어오는 오류를 잡아 사용자에게 반환하거나 페이지 간에 리다이렉트할 수 있습니다.\n콘솔에서 각 요청의 오류와 본문을 쉽게 보고 조치할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_1.png\" /\u003e\n\n\n\n### 이전 게시물","ogImage":{"url":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png"},"coverImage":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png","tag":["Tech"],"readingTime":3},{"title":"BEM에 익숙해지기","description":"","date":"2024-05-14 12:07","slug":"2024-05-14-GettingComfortablewithBEM","content":"\n\n이번 서킷에서 첫 번째 토픽은…. BEM! BEM이 뭐냐고 물을 수도 있겠죠? BEM은 HTML을 위한 클래스를 만드는 데 사용되는 방법론으로, 보다 깔끔하고 명확한 CSS 구조로 이어집니다. 이것은 제가 직전 프로젝트를 제 강사들에게 제출했을 때 생긴 굉장한 문제 때문에 저의 집착의 대상이 되었어요... 그것은 엉망이었고, 그런 일은 더 이상 허용되지 않아야 했죠.\n\n제 클래스 이름과 CSS가 의미가 있었죠… 버튼을 만들어야 했을 때, 기본 버튼을 만들고 약간 바꾼 버튼을 위한 다른 클래스를 만들었어요. 주로 내 메인 `a`는 특정한 방식으로 보이도록 설정을 하지만, 다른 hover 효과를 주고 싶은 앵커를 위해 a.purple-hover를 만들었어요. 결국, 제가 개별 요소를 위한 많은 클래스를 만들어 CSS 파일을 수백 줄짜리 HTML 파일에 수천 줄의 코드를 작성하고 있었어요.\n\n클래스 스타일을 조직하는 더 나은 방법을 찾아야 했고, 다른 개발자가 살펴보더라도 보다 빨리 이해할 수 있도록 페이지를 더 이해하기 쉽게 만들어야 했어요. 몇 분 동안 기사를 찾아보고 유튜브를 뒤지던 중, BEM을 발견했어요. Block-Element-Modifier는 기본 값, 해당 값의 변경 및 위치를 명확하게 정의하는 방법입니다. BEM을 해석하고 사용 사례 및 구현 방법을 설명하는 가장 좋은 설명은 https://en.bem.info/methodology/css/에서 찾았어요. 꼭 한 번 읽어보시고 이미 사용하고 있지 않다면 직접 구현해보는 것을 강력히 추천드립니다.\n\n기사를 그대로 소화할 생각은 없으니, 다시 한 번 읽는 것을 강력히 추천합니다. 제가 다룰 내용은 어떻게 BEM을 처음부터 적용할 것인지입니다. 작업하고 싶은 개인 프로젝트가 있어요, 개인 블로그 페이지(얼마나 진부한지 알죠)를 만들어서 게시하고, 게시한 내용을 모든 주요 블로그 사이트에 자동으로 업데이트할 수 있는 시스템을 구축할 거에요. 참고할 예시를 북마크하고 위의 링크를 저장해서 방법론을 준수하며 진행할 것이에요. 진행 상황은 여기에 업데이트할 거예요.\n\n\n\n제가 예시를 제대로 제공하지 않고 코드 조각을 포함하지 않은 것을 알고 있어요. 그러나 이번 주에 다른 주에서 12시간씩 일하고 호텔로 출퇴근해야 하는 일을 시작해서 조정 중입니다. 제가 계속 학습하고 블로깅을 진행할 수 있게 하는 것에 감사하게 생각해요. 개인 프로젝트에 착수할 때 BEM을 어떻게 사용하는지 보여줄 거예요. 그러나 반복해서 말씀드렸듯이, 위에 언급한 기사를 읽어보세요. 정말 흥미로워요.\n\n다음에 만나요, 여러분의 하드해트를 쓴 블루 칼라 코더 세르지오 파렐 / 페럴 코드예요. 좋은 밤 되세요, 그리고 계속 코딩하세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png"},"coverImage":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png","tag":["Tech"],"readingTime":2}],"page":"31","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"31"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>