<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/31" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 현재 시간을 가져오는 방법" href="/post/2024-06-20-HowtoGetCurrentTimeinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 현재 시간을 가져오는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 현재 시간을 가져오는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 현재 시간을 가져오는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" href="/post/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" href="/post/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 DSA 모험 - 3장 - 배열-01" href="/post/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 DSA 모험 - 3장 - 배열-01" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 DSA 모험 - 3장 - 배열-01" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 DSA 모험 - 3장 - 배열-01</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" href="/post/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" href="/post/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactjs 심층 분석 1  createElement와 jsx-runtime" href="/post/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactjs 심층 분석 1  createElement와 jsx-runtime" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactjs 심층 분석 1  createElement와 jsx-runtime" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reactjs 심층 분석 1  createElement와 jsx-runtime</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트" href="/post/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기" href="/post/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법" href="/post/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link posts_-active__YVJEi" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JavaScript에서 현재 시간을 가져오는 방법","description":"","date":"2024-06-20 07:24","slug":"2024-06-20-HowtoGetCurrentTimeinJavaScript","content":"\n\n`img` 태그를 Markdown 형식으로 변경해주세요.\n\n![How to Get Current Time in JavaScript](/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png)\n\n이미지 출처: How to Get Current Time in JavaScript\n\n이 글은 JavaScript를 사용하여 현재 시간을 얻는 다양한 방법을 안내합니다.\n\n## 1. `Date` 객체 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 현재 시간을 가장 직접적으로 얻는 방법은 `Date` 객체를 사용하는 것입니다. `Date` 객체는 플랫폼에 독립적인 형식으로 시간을 나타냅니다.\n\n```js\n// 새 Date 객체 생성\nlet currentDate = new Date();\n// 현재 시간 가져오기\nlet currentTime = currentDate.toLocaleTimeString();\nconsole.log(\"현재 시간은:\", currentTime);\n```\n\n이 예제에서:\n- 우리는 새로운 `Date` 객체 'currentDate'를 생성합니다. 이 객체는 현재 날짜와 시간으로 초기화됩니다.\n- `toLocaleTimeString()` 메서드를 사용하여 시간 부분을 로캘에 맞게 포맷합니다.\n\n## 2. `Date` 객체 사용 (UTC)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 시각을 UTC 형식으로 가져오려면:\n\n```js\n// 새 Date 객체 생성\nlet currentDateUTC = new Date();\n// 현재 UTC 시간 가져오기\nlet currentUTCTime = currentDateUTC.toUTCString();\nconsole.log(\"현재 UTC 시간은:\", currentUTCTime);\n```\n\n여기서 `toUTCString()`은 날짜를 UTC 형식의 문자열로 변환합니다.\n\n## 3. 시간, 분, 초 표시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 시간, 분, 초를 따로 표시해야 하는 경우:\n\n```js\n// 새 Date 객체 생성\nlet currentTimeDetails = new Date();\n// 시간, 분, 초 가져오기\nlet hours = currentTimeDetails.getHours();\nlet minutes = currentTimeDetails.getMinutes();\nlet seconds = currentTimeDetails.getSeconds();\nconsole.log(`현재 시간: ${hours}:${minutes}:${seconds}`);\n```\n\n## 4. 외부 라이브러리 사용\n\n또는 Moment.js와 같은 외부 라이브러리를 사용하여 더 고급의 날짜 및 시간 조작이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Moment.js 라이브러리 사용\nlet now = moment();\nconsole.log(\"Moment.js를 사용한 현재 시간:\", now.format('YYYY-MM-DD HH:mm:ss'));\n```\n\n프로젝트에 Moment.js를 포함시키면서 사용하세요.\n\n## 결론\n\n본문에서는 JavaScript에서 현재 시간을 얻는 다양한 방법을 탐색했습니다. 네이티브 `Date` 객체를 선택하거나 Moment.js와 같은 라이브러리를 선호하든, JavaScript는 다양한 요구 사항에 맞는 유연한 솔루션을 제공합니다. 이러한 방법을 이해하면 현재 시간 기능을 웹 애플리케이션에 효과적으로 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 요구 사항에 가장 잘 맞는 방법을 선택하는 것을 기억하세요. 단순성, 지역화 및 추가 기능을 고려해 선택하세요. 이러한 예제들을 실험하여 날짜와 시간을 효과적으로 다루는 JavaScript의 능력을 향상시키고 활용해보세요.","ogImage":{"url":"/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍","description":"","date":"2024-06-20 07:21","slug":"2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection","content":"\n\n개요, 응용 프로그램, 모범 사례 및 제한 사항\n\n![이미지](/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png)\n\n# 소개\n\n제목을 읽은 후에, 메타프로그래밍이 무엇인지 궁금할 수 있습니다. 일반 프로그래밍과 어떻게 다른가요? 주요 개념 및 기술은 무엇일까요? 실제 예시는 어떻게 될까요? 다양한 언어에서는 어떻게 구현되는가요? 장단점은 무엇일까요? 그리고 JavaScript에서는 어떻게 활용될 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 질문이 참 많죠! 그런데 걱정하지 마세요. 제가 이 기사에서 여러분의 궁금증을 해소하고 각 질문에 대답할 거에요. 여기 제가 제안하는 개요입니다:\n\n- 지구 상의 첫 발자국\n  - 메타 프로그래밍이란 무엇인가요?\n  - JavaScript에서의 메타 프로그래밍\n- 프록시와 리플렉트 API 실습\n  - 프록시와 리플렉트를 사용해 프로퍼티 접근 (get) 가로채기\n  - 프록시와 리플렉트를 사용해 프로퍼티 할당 (set) 가로채기\n  - get과 set 대신 임의의 키를 사용할 수 있을까요?\n  - 프록시와 리플렉트의 실용적인 예제\n- 사례 연구와 실제 예시\n  - 반응형 스토어 생성\n  - 유효성 검사 및 정제를 위한 라이브러리 생성\n  - 안전한 API 게이트웨이 구축\n  - 프록시와 리플렉트를 사용하는 실세계 프레임워크 및 라이브러리\n- 모범 사례, 일반적인 오류 및 권고 사항\n  - 모범 사례\n  - 일반적인 오류 및 권고 사항\n- 결론\n\n만약 이 개념을 탐험하는 데 열성적이고 궁금하시다면, 이 여정에 함께 참여하실 것을 초대합니다. 준비가 되셨죠! 함께 이륙합니다! 🚀\n\n## 지구 상의 첫 발자국\n\n### 메타 프로그래밍이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메타 프로그래밍의 간단한 정의를 찾아보려면, 다양한 프로그래밍 언어 예제를 살펴보는 것부터 시작해보겠습니다:\n\n```js\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n```\n\n위의 코드는 C 및 C++과 같은 언어에서 흔히 볼 수 있습니다. 이것은 상수를 정의하고 함수를 생성하며 조건부 컴파일을 수행하는 매크로 전처리기입니다.\n\n#define 지시어는 매크로를 생성하며, 이는 소스 코드 전체에서 재사용할 수 있는 코드의 자리 표시자입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nint main() {\n    int radius = 5;\n    double area = PI * SQUARE(radius); // placeholders\n    printf(\"Area: %f\\n\", area);  // Output: Area: 78.539750\n    return 0;\n}\r\n```\n\n프리프로세서(preprocessor)가 소스 코드에서 매크로를 만나면 매크로를 정의된 내용으로 대체합니다:\n\n```js\r\n// 전처리 전:\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n\nint main() {\n    int radius = 5;\n    double area = PI * SQUARE(radius);\n    printf(\"Area: %f\\n\", area);\n    return 0;\n}\n\n// 전처리 후:\nint main() {\n    int radius = 5;\n    double area = 3.14159 * ((5) * (5));\n    printf(\"Area: %f\\n\", area);\n    return 0;\n}\r\n```\n\n프리프로세서(preprocessor)는 #if, #ifdef, #ifndef, #else, #endif와 같은 지시문을 사용하여 특정 조건에 따라 코드의 일부를 포함하거나 제외할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n#define DEBUG\n\n#ifdef DEBUG\nprintf(\"Debug mode\\n\");\n#endif\r\n```\n\n전처리 후 확장된 코드는 컴파일러에 의해 기계 코드로 컴파일됩니다.\n\n매크로의 힘은 코드 재사용성, 조건부 컴파일, 코드 생성 및 변환에 대한 강력한 도구를 제공하는 능력에 있습니다.\n\n매크로가 메타 프로그래밍의 한 형태라는 것을 알고 계셨나요? 여기 메타 프로그래밍의 초기 정의가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🚩 컴파일러와 메타프로그래밍은 서로 다른 개념임을 명심하는 것이 중요합니다. 두 가지 모두 코드 조작을 포함하지만 목표와 방법이 다릅니다:\n\n- 메타프로그래밍은 코드를 생성하거나 수정하여 작업을 자동화하고 더 높은 수준의 추상화를 생성하는 데 중점을 둡니다.\n- 반면에 컴파일러 이론은 코드를 한 형식에서 다른 형식으로 번역하는 것에 관심이 있으며 일반적으로 고수준 소스 코드를 실행을 위한 기계 코드나 바이트 코드로 변환합니다.\n\nRust는 Macro도 가지고 있습니다:\n\n```rust\nmacro_rules! say_hello {\n    () =\u003e {\n        println!(\"Hello, world!\");\n    };\n}\n\nfn main() {\n    say_hello!(); // 확장 결과: println!(\"Hello, world!\");\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 알다시피, 매크로는 컴파일 중에 다른 코드를 생성하거나 변환하는 코드를 작성할 수 있게 해줍니다.\n\n메타프로그래밍에서 매크로는 사용되는 다양한 도구 및 기술 중 하나에 불과합니다. 메타프로그래밍은 프로그램이 다른 프로그램을 생성, 조작 또는 변환할 수 있는 다양한 방법을 포괄합니다. 매크로 이외의 몇 가지 주요 기술은 다음과 같습니다:\n\n1️⃣ 주석 및 속성 (Java): Java의 주석은 코드에 메타데이터를 추가하는 강력한 방법을 제공하며, 컴파일 시간 또는 런타임에서 처리하여 특정 동작, 구성 또는 제약을 강제적으로 적용할 수 있습니다.\n\n```js\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n// 컴파일 시간 retention을 가진 사용자 정의 주석\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\n@interface MyAnnotation {\n    String value();\n}\n\n// 런타임 retention을 가진 사용자 정의 주석\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface MyRuntimeAnnotation {\n    String value();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2️⃣ 템플릿 메타프로그래밍 (C++): 템플릿 메타프로그래밍은 컴파일러를 활용하여 효율적이고 타입 안전한 코드를 생성하는 강력한 기법으로, 성능 및 유지보수 측면에서 상당한 이점을 제공합니다.\n\n```cpp\n#include \u003ciostream\u003e\n\n// 주 템플릿\ntemplate\u003cint N\u003e\nstruct Factorial {\n    static const int value = N * Factorial\u003cN - 1\u003e::value;\n};\n\n// 기본 케이스를 위한 템플릿 특수화\ntemplate\u003c\u003e\nstruct Factorial\u003c0\u003e {\n    static const int value = 1;\n};\n\nint main() {\n    // 컴파일 시간에 5의 팩토리얼을 계산\n    std::cout \u003c\u003c \"5의 팩토리얼은 \" \u003c\u003c Factorial\u003c5\u003e::value \u003c\u003c \"입니다.\" \u003c\u003c std::endl;\n    return 0;\n}\n```\n\n3️⃣ 리플렉션 (Java): 리플렉션은 코드와 동적으로 상호작용하는 강력한 메커니즘을 제공하여 클래스, 메서드, 필드 등을 검사하거나 메서드를 호출하거나 필드에 접근할 수 있게 합니다.\n\n```java\nimport java.lang.reflect.Method;\n\n// 리플렉션을 사용하여 호출할 간단한 메서드가 있는 클래스 정의\npublic class ReflectExample {\n    public void sayHello(String name) {\n        System.out.println(\"안녕, \" + name + \"!\");\n    }\n\n    public static void main(String[] args) {\n        try {\n            // 클래스의 인스턴스 생성\n            ReflectExample example = new ReflectExample();\n\n            // ReflectExample과 관련된 Class 객체 가져오기\n            Class\u003c?\u003e clazz = example.getClass();\n\n            // sayHello 메서드를 나타내는 Method 객체 가져오기\n            Method method = clazz.getMethod(\"sayHello\", String.class);\n\n            // 예제 인스턴스에서 \"World\" 인수를 사용하여 sayHello 메서드 호출\n            method.invoke(example, \"World\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4️⃣ 동적 평가 (JavaScript):\n\n```js\nconst code = 'console.log(\"안녕, 세상!\");';\neval(code);  // 출력: 안녕, 세상!\n```\n\n⚠️ 조심해주세요, JavaScript에서 eval을 사용하는 것은 권장되지 않습니다.\n\n요약하면, 메타프로그래밍은 프로그램이 다른 프로그램을 데이터로 취급할 수 있는 프로그래밍 패러다임입니다. 이는 일반적으로 다음을 포함합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드 조작: 코드를 동적으로 생성, 변환 또는 검사할 수 있는 능력입니다.\n- 자동화: 코드 조작을 통해 반복적이거나 복잡한 작업을 자동화합니다.\n- 추상화: 코드 내의 중복을 간소화하고 줄이기 위해 높은 수준의 추상화를 만듭니다.\n- 동적 동작: 프로그램의 동작을 다양한 조건이나 입력에 기반하여 런타임 시에 적응시킵니다.\n\n지금까지 익힌 것으로 보아, 자바스크립트에서 eval을 사용하는 것을 넘어서 메타프로그래밍을 어떻게 적용할 수 있는지 궁금해하고 있군요. 함께 알아보도록 해요!\n\n## 자바스크립트에서의 메타프로그래밍\n\n자바스크립트에는 프락시(Proxies), 리플렉트 API, 그리고 데코레이터(Decorators)와 같이 메타프로그래밍에 활용할 수 있는 강력한 도구들이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오, 걱정 마세요! 제가 말한 건 자바스크립트이고, 자바가 아니에요. 😊\n\n각각의 기술은 서로 다른 목적을 가지고 다른 기능을 제공해요:\n\n- Proxy: 동적 동작, 유효성 검사, 로깅 등에 유용한 객체에 대한 다양한 작업을 가로채는 높은 유연성을 제공해요.\n- Reflect: 일반적인 객체 작업을 수행하기 위한 일관된 간편한 API를 제공하며, 대부분 프락시와 함께 사용되어 트랩의 구현을 간소화하기 위해 종종 사용돼요.\n- 데코레이터 (제안됨): 클래스와 메소드를 선언적으로 수정하여 어노테이션을 통해 향상하거나 동작을 변경할 수 있도록 해줘요.\n\n아마 궁금하실 거예요: 자바스크립트 프락시는 메타프로그래밍 개념과 어떻게 관련이 되는 걸까요? 자바스크립트 프락시는 동적 코드 조작, 작업 자동화, 추상화 생성, 그리고 실행 중에 동작을 조정하여 메타프로그래밍 원칙과 일치해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체에 대한 기본 작업을 가로채고 사용자 정의하여, 프록시는 메타프로그래밍의 핵심 목표를 달성하며 코드의 유연성을 향상시키고 중복을 줄이며 복잡성을 관리하는 강력한 방법을 제공합니다.\n\n이런 다소 이론적인 메타프로그래밍의 주요 개념을 소개한 후에, 이제 JavaScript 프록시를 사용한 실용적인 예제로 넘어 가볼까요? 시작해봅시다! 💻\n\n# 실습으로 알아보는 프록시와 Reflect API\n\n## Proxy 및 Reflect를 사용하여 속성 접근(GET) 가로채기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 이전에 보았듯이, JavaScript에서의 프록시는 객체에 대한 기본 작업들을 가로채고 재정의할 수 있도록 해줍니다. 속성에 접근하거나 할당, 열거, 함수 호출 등이 해당됩니다.\n\n프로퍼티 접근을 가로채기 위한 기본적인 방법은 다음과 같습니다:\n\n\nYou can play with the code [here](\u003clink\u003e)\n\n\n✳️ target은 단일 속성 message를 가진 간단한 객체로, \"Hello, World!\"라는 문자열이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✳️ 핸들러(handler)는 get 트랩을 정의하는 객체입니다. get 트랩은 대상 객체의 속성 접근을 가로채는 메서드입니다.\n\n✳️ 프록시(proxy)의 속성에 액세스할 때 get 트랩이 트리거되어 해당 속성이 어떤 것인지 나타내는 메시지가 기록됩니다.\n\n✳️ Reflect.get 메서드는 대상 객체에서 속성 값을 검색하는 기본 동작을 수행하는 데 사용됩니다. Reflect.get은 Reflect API의 일부로, 일관되고 표준화된 방법으로 일반적인 객체 작업을 수행할 수 있는 메서드 세트를 제공합니다.\n\n## 프록시(Proxy)와 Reflect를 사용하여 속성 할당(set)을 가로채는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티 설정을 가로채기 위해 프록시를 생성하는 기본적인 방법을 소개해 드립니다:\n\n여기서 코드를 테스트해볼 수 있어요.\n\n✳️ 핸들러 객체는 set 트랩을 정의합니다. set 트랩은 대상 객체에서 프로퍼티 할당을 가로채는 함수입니다.\n\n✳️ 프록시의 프로퍼티에 값이 할당되면, set 트랩이 작동됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✳️ 설정된 함정 안에서:\n\n- 어떤 속성이 설정되고 어떤 값으로 설정되는지를 나타내는 메시지를 기록합니다.\n- target[prop] = value;은 실제로 값을 대상 객체의 속성에 할당합니다.\n- return true;은 할당이 성공적으로 수행되었음을 나타냅니다. true를 반환하는 것은 작업이 올바르게 처리되었음을 프록시에 신호하는 데 중요합니다.\n\n## get과 set 대신 임의의 키를 사용할 수 있을까요?\n\nJavaScript 프록시의 맥락에서 get과 set 키는 속성 접근 및 설정 작업을 가로채기 위해 Proxy API에서 제공하는 특정 함정입니다. 이러한 키는 사전에 정의되어 있어 임의의 키로 대체할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 우리는 다른 종류의 작업을 가로챌 수 있는 미리 정의된 다른 함정들을 사용할 수도 있습니다. Proxy API에서 사용 가능한 모든 함정 목록은 다음과 같습니다:\n\n![Proxy API](/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_1.png)\n\nhas 함정은 in 연산자를 가로챕니다:\n\ndeleteProperty 함정은 delete 연산자를 가로챕니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`apply` 트랩은 함수 호출을 가로챕니다:\n\n`ownKeys` 트랩은 Object.getOwnPropertyNames와 Object.keys와 같은 작업을 가로챕니다:\n\n여기 하나의 프록시에 여러 트랩이 결합된 예제가 있습니다:\n\n여기서 코드를 실험해 볼 수 있어요. 멋지네요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프록시 API와 리플렉트 API는 서로 보완적입니다. 프록시 API는 다양한 작업을 가로채는 트랩을 제공하여 사용자 정의 동작을 정의할 수 있게 해주고, 리플렉트 API는 이러한 트랩을 반영하는 일련의 메서드를 제공하여 트랩 내에서 기본 동작을 수행하기 쉽게 만듭니다:\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`속성 ${prop} 가져오기`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.get(target, prop, receiver);\n    },\n    set: function(target, prop, value, receiver) {\n        console.log(`속성 ${prop}을(를) ${value}로 설정`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.set(target, prop, value, receiver);\n    },\n    has: function(target, prop) {\n        console.log(`속성 ${prop}이 대상에 있는지 확인`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.has(target, prop);\n    },\n    deleteProperty: function(target, prop) {\n        console.log(`속성 ${prop} 삭제`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.deleteProperty(target, prop);\n    },\n....\n\n```\n\n다시 말해, 리플렉트 API는 프록시를 사용할 때 기본 객체 동작을 복원하는 데 도움이 됩니다. 프록시 트랩 내에서 리플렉트 메서드를 사용하여 사용자 정의 논리를 자바스크립트의 표준 동작과 함께 사용할 수 있으므로 더 예측 가능하고 신뢰할 수 있는 코드를 작성할 수 있습니다.\n\n프록시 트랩 내에서 리플렉트 API를 사용하지 않으면, 가로챈 작업의 기본 동작을 수동으로 처리해야 합니다. 이는 오류를 유발할 수 있으며 항상 리플렉트를 사용하는 것만큼 일관성과 신뢰성을 보장하지는 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 get 케이스에서 발생할 수 있는 것들입니다.\n\n```js\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`속성 ${prop}을(를) 가져오는 중`);\n        return target[prop];  // 속성에 직접 접근\n    }\n};\n\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.name);  // 로깅: 속성 name을(를) 가져오는 중. 결과: Alice\n```\n\n잠재적인 문제: target[prop]에 직접 접근하는 것은 상속된 속성이나 게터(getter)와 같은 모든 경우를 올바르게 처리하지 못할 수 있습니다.\n\n```js\nconst parent = {\n  inheritedProp: \"상속되었어요\"\n};\n\nconst target = {\n  ...parent,\n  ownProp: \"내 소유 속성이에요\",\n};\n\n\nconst handler = {\n  get: function(target, prop, receiver) {\n    console.log(`속성 ${prop}을(를) 가져오는 중`);\n    return target[prop]; // 속성에 직접 접근\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 로깅: 속성 ownProp을(를) 가져오는 중. 결과: 내 소유 속성이에요\nconsole.log(proxy.ownProp); \n\n// 로깅: 속성 inheritedProp을(를) 가져오는 중. 결과: 아무것도 출력되지 않습니다\nconsole.log(proxy.inheritedProp); \n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토타입 체인에서 상속된 속성은 target[prop]에 의해 고려되지 않습니다.\n\n그러나 get 트랩에서 Reflect.get을 사용하면 상속된 속성과 getter가 있는 속성이 올바르게 처리됩니다:\n\n```js\nconst parent = {\n  inheritedProp: \"상속받은 속성입니다.\"\n};\n\nconst target = {\n  ...parent,\n  ownProp: \"자체 속성입니다.\",\n};\n\nconst handler = {\n  get: function(target, prop, receiver) {\n    console.log(`속성 ${prop}을(를) 가져옵니다.`);\n    return Reflect.get(target, prop, receiver);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 콘솔에 출력: 속성 ownProp를 가져옵니다. 결과: 자체 속성입니다.\nconsole.log(proxy.ownProp); \n\n// 콘솔에 출력: 속성 inheritedProp를 가져옵니다. 결과: 상속받은 속성입니다.\nconsole.log(proxy.inheritedProp); \n```\n\n💡Reflect를 사용하면 JavaScript에서 일반적으로 작동하는지 확인하여 내장 동작을 유지하고 이러한 작업을 수동으로 구현할 때 놓치기 쉬운 특수 상황을 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Proxy와 Reflect의 작동 방식을 이해했으니, Proxy를 사용하는 것이 권장되는 실제 예시를 살펴보겠습니다.\n\n## Proxy와 Reflect의 실용적인 예시\n\n✴️ 예시 1: 속성 접근 및 수정 로깅\n\n디버깅 및 객체 상호작용 모니터링을 위해 Proxy와 Reflect를 사용하여 속성 접근 및 수정을 로깅하는 것이 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`Getting property ${prop}`);\n        return Reflect.get(target, prop, receiver);\n    },\n    set: function(target, prop, value, receiver) {\n        console.log(`Setting property ${prop} to ${value}`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.name);  // 콘솔: Getting property name. 결과: Alice\nproxy.age = 31;           // 콘솔: Setting property age to 31\nconsole.log(proxy.age);   // 콘솔: Getting property age. 결과: 31\n```\n\n✴️ 예시 2: 유효성 검사\n\n속성 값 설정 전에 유효성 규칙을 강제하기 위해 프록시를 사용:\n\n```js\nconst target = {\n    age: 25\n};\n\nconst handler = {\n    set: function(target, prop, value, receiver) {\n        if (prop === 'age' \u0026\u0026 (typeof value !== 'number' || value \u003c= 0)) {\n            throw new TypeError('나이는 양의 숫자여야 합니다');\n        }\n        console.log(`Setting property ${prop} to ${value}`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.age = 30;  // 콘솔: Setting property age to 30\nconsole.log(proxy.age);  // 결과: 30\n// proxy.age = -5;  // 에러: TypeError: 나이는 양의 숫자여야 합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✴️ 예제 3: 동적 속성 생성\n\nProxy를 사용하여 속성을 동적으로 생성하고 존재하지 않는 속성을 고상하게 처리하는 방법:\n\n```js\nconst target = {};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        if (!(prop in target)) {\n            target[prop] = `속성 ${prop}이(가) 존재하지 않아 동적으로 생성되었습니다`;\n        }\n        console.log(`${prop} 속성을 가져오는 중`);\n        return Reflect.get(target, prop, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 로그: name 속성을 가져오는 중. 결과: name 속성이 존재하지 않아 동적으로 생성됨\nconsole.log(proxy.name);  \n\n// 로그: age 속성을 가져오는 중. 결과: age 속성이 존재하지 않아 동적으로 생성됨\nconsole.log(proxy.age);   \n```\n\n✴️ 예제 4: 함수 추적\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프록시를 사용하여 함수 호출을 추적하고 인수를 기록합니다:\n\n```js\nconst targetFunction = function(a, b) {\n    return a + b;\n};\n\nconst handler = {\n    apply: function(target, thisArg, argumentsList) {\n        console.log(`Called with arguments: ${argumentsList}`);\n        return Reflect.apply(target, thisArg, argumentsList);\n    }\n};\n\nconst proxy = new Proxy(targetFunction, handler);\n\nconsole.log(proxy(1, 2));  // Logs: Called with arguments: 1,2. Output: 3\nconsole.log(proxy(5, 10)); // Logs: Called with arguments: 5,10. Output: 15\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    deleteProperty: function(target, prop) {\n        console.log(`Deleting property ${prop}`);\n        return Reflect.deleteProperty(target, prop);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\ndelete proxy.age;  // Logs: Deleting property age\nconsole.log(target.age);  // Output: undefined\n```\n\n💡 Production 모드에서는 console 문을 백엔드 호출로 대체하여 로그를 추적하고 저장합니다.\n\n이 예제의 아름다움은 기존 코드와의 원활한 통합에 있으며, 라이브러리 및 프레임워크 개발에 매우 유용합니다. 함께 살펴보겠습니다!\n\n# 사례 연구 및 실제 예제\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 리액티브 스토어 생성\n\n이 저장소를 사용하는 예제입니다:\n\n```js\n// 사용 예시\nconst store = createStore({ count: 0 });\n\n// 상태 변경 구독\nstore.subscribe(state =\u003e {\n  console.log(\"상태 변경됨:\", state);\n});\n\n// 게터를 통해 속성에 액세스\nconsole.log(store.getState().count); // 출력: 0\n\n// 세터를 통해 상태 업데이트\nstore.getState().count = 10; // 출력: \"상태 변경됨: { count: 10 }\"\n\n// 게터를 통해 속성에 액세스\nconsole.log(store.getState().count); // 출력: 10\n```\n\n여기에서 코드를 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 스토어는 React 기능 컴포넌트에서도 사용할 수 있습니다:\n\n```js\nconst store = createStore({ count: 0 });\n\n// 상태에 기반한 UI를 렌더링하는 함수 컴포넌트\nfunction Counter() {\n  // 스토어의 현재 상태를 보유하는 상태\n  const [state, setState] = useState(store.getState());\n\n  // 컴포넌트가 마운트될 때 상태 변경 사항을 구독하는 효과\n  useEffect(() =\u003e {\n    // 상태 변경 사항을 구독합니다.\n    const unsubscribe = store.subscribe((newState) =\u003e {\n      // 스토어에서 새 상태로 로컬 상태를 업데이트합니다.\n      setState({ ...newState });\n    });\n\n    // 구독을 정리하는 해제 함수를 반환합니다.\n    return () =\u003e {\n      unsubscribe();\n    };\n  }, []);\n\n  // 5초마다 카운트를 증가시키는 효과\n  useEffect(() =\u003e {\n    // 5초마다 카운트를 증가시키는 타이머를 설정합니다.\n    const interval = setInterval(() =\u003e {\n      // 스토어의 상태에서 카운트를 업데이트합니다.\n      store.getState().count += 1;\n    }, 1000);\n\n    // 컴포넌트가 언마운트될 때 인터벌 타이머를 지웁니다.\n    return () =\u003e {\n      clearInterval(interval);\n    };\n  }, []);\n\n  // 로컬 상태에서 카운트를 렌더링합니다.\n  return \u003cdiv\u003eCount: {state.count}\u003c/div\u003e;\n}\n\nexport default Counter;\n```\n\n여기에서 코드를 사용해 볼 수 있습니다.\n\n## 검증 및 살균을 위한 라이브러리 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n입력이 속성에 할당되기 전에 유효성을 검사하기 위해 set 트랩을 사용하여 시스템에 유효하지 않은 데이터가 들어가는 것을 방지합니다:\n\n💡데이터가 예상 형식 및 제약 조건에 부합하는지 확인하여 보안과 일관성을 향상시킵니다.\n\n## 안전한 API 게이트웨이 구축\n\nJavaScript의 Proxy와 Reflect API를 사용하여 안전하고 유연하며 유지보수가 용이한 API 게이트웨이를 만들 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 코드를 사용해 놀 수 있어요. 이 예제는 익스프레스와 라우팅을 떠올리게 합니다.\n\n이제 산업 응용 프로그램으로 넘어가봅시다. 즉, 실제 세계의 프레임워크와 라이브러리에 초점을 맞춘다구요. 💫\n\n## Proxy와 Reflect를 사용한 실제 세계의 프레임워크 및 라이브러리\n\n✳️ Vue 3: Vue 3에서 반응성 시스템은 프록시 주변에 구축되어 있어 상태 변경을 가로채고 관리하는 방식으로 처리되어 반응성을 다루는 능률적이고 성능 좋은 방법을 제공해줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [Vue.js 공식 문서 - 반응성](https://v3.ru.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes)\n- [Vue.js 공식 문서 - 반응성 기본 개념](https://github.com/vuejs/docs/blob/main/src/guide/essentials/reactivity-fundamentals.md?plain=1#L46)\n- [Vue.js Core GitHub - 컴포넌트 렌더링 유틸리티 코드](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/componentRenderUtils.ts#L81)\n- [Vue.js Core GitHub - 인스턴스 호환성 관련 코드](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/compat/instance.ts#L101)\n- [Vue.js 공식 문서 - 반응성 핵심 API](https://github.com/vuejs/docs/blob/main/src/api/reactivity-core.md?plain=1#L135)\n\n✳️ MobX: 기본적으로 MobX는 배열과 일반 객체를 observable하게 만들기 위해 프록시를 사용합니다:\n\n- [MobX 설정 관련 문서](https://mobx.js.org/configuration.html#proxy-support)\n- [MobX 설치 관련 문서](https://github.com/mobxjs/mobx/blob/main/docs/installation.md?plain=1#L55)\n- [MobX observable 상태 관련 문서](https://github.com/mobxjs/mobx/blob/main/docs/observable-state.md?plain=1#L281)\n\n✳️ Svelte에서는 반응성 시스템이 의존성을 추적하고 상태 변경 시 효율적으로 DOM을 업데이트합니다. 상태 변이를 가로채고 반응하기 위해 프록시 객체를 사용하여 이를 구현합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/proxy.js\n- https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/reactivity/props.js#L83\n\n이들 실제 예제는 프록시와 Reflect API가 현대 자바스크립트 개발에 가져다 주는 중요한 능력과 다양성을 강조합니다.\n\n실제 예제와 실제 적용을 통해 프록시를 살펴봤으니, 이제는 그것들을 구현하는 데 있어서 좋은 방법과 피할 수 있는 일반적인 함정들을 고려하고 완벽한 이해를 위해 권장하는 것이 중요합니다. 🌟\n\n# 최선의 방법, 흔한 오류, 그리고 권장사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 최상의 방법\n\n🔵 프록시 트랩 내에서 반복되는 기본 동작을 유지하려면 Reflect API를 사용하세요:\n\n```js\nconst handler = {\n    get(target, prop, receiver) {\n        console.log(`속성 ${prop}을 가져옵니다`);\n        return Reflect.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n        console.log(`속성 ${prop}을 ${value}로 설정합니다`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\n```\n\n🔵 프록시를 상태 관리, 로깅, 유효성 검사 또는 반응형 프로그래밍과 같은 시나리오에 적용하세요. 프록시는 오버헤드를 도입할 수 있으므로 혜택이 명확한 곳에서만 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🔵 데이터가 할당되기 전에 데이터를 유효성 검사하기 위해 set 트랩을 사용하세요:\n\n```js\nconst handler = {\n    set(target, prop, value, receiver) {\n        if (prop === 'age' \u0026\u0026 (typeof value !== 'number' || value \u003c 0)) {\n            throw new TypeError('나이는 양수여야 합니다.');\n        }\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\nproxy.age = 30;  // 잘 작동합니다\n// proxy.age = -1;  // 오류 발생\n```\n\n🔵 디버깅 목적으로 작업을 기록하기 위해 프록시를 사용하되, 프로덕션 환경에서는 이러한 로깅을 비활성화하거나 제거하거나 백엔드 API를 사용하세요.\n\n🔵 무한 재귀를 발생시킬 수 있는 자기 참조 루프를 피하기 위해 프록시 핸들러를 설계하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst handler = {\n    get(target, prop, receiver) {\n        if (prop === 'self') return receiver;\n        return Reflect.get(target, prop, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\n```\n\n이제 피해야 할 실수에 대해 이야기해 봅시다. 🚫\n\n## 흔한 오류와 권장 사항\n\n🔴 오류: 프록시는 성능이 중요한 부분에서 성능 오버헤드를 일으킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 권장: 성능 영향을 측정하고 프록시를 신중하게 사용하세요. 성능이 중요할 때는 대안을 고려해보세요.\n\n🔴 오류: 프록시는 행동이 추상화되고 가로채기 때문에 디버깅을 복잡하게 만들 수 있습니다.\n\n✅ 권장: 프록시 트랩 내에서 명확하고 간결한 로깅을 사용하고 프록시 동작을 이해하기 위해 철저한 테스트를 수행하세요.\n\n🔴 오류: 프록시는 민감한 데이터를 노출하거나 미인가 수정을 허용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 권장 사항: 프록시 트랩 내에서 철저한 유효성 검사와 액세스 제어 구현하기\n\n🔴 오류: 모든 JavaScript 환경이 프록시를 완전히 지원하지는 않습니다, 특히 오래된 브라우저들에서.\n\n✅ 권장 사항: 대상 환경이 프록시를 지원하거나 대체 메커니즘을 제공하는지 확인하기\n\nJavaScript에서 프록시와 Reflect API를 사용함으로써 코드는 상당히 유연하고 강력해지며, 동적 동작과 고급 메타프로그래밍 기능을 제공할 수 있습니다. 최대 혜택을 누리기 위해 여러분은 최상의 관행을 준수하고 일반적인 오류들을 인지하는 것이 중요합니다. 🎯\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 기사에서는 프록시와 Reflect API에 중점을 두어 JavaScript 메타 프로그래밍의 강력한 기능을 탐구했습니다. 개념, 최선의 실천 방법, 흔한 함정 및 실제 응용 프로그램을 살펴보았습니다.\n\n프록시와 Reflect API는 객체 작업을 가로채는 방법을 통해 로깅, 유효성 검사 및 세밀한 반응성과 같은 동적 행위를 가능케 합니다.\n\n최선의 실천 방법은 기본 동작을 유지하기 위해 Reflect를 사용하고 견고한 보안 검사를 구현하는 것이며, 흔한 함정은 성능 부담과 디버깅 복잡성을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVue.js와 MobX와 같은 프레임워크는 상태 관리와 반응성을 위해 프록시를 활용합니다. 반응형 프로그래밍으로의 전환은 반응성 및 효율적인 애플리케이션 구축의 중요성을 강조합니다.\n\n실시간 대화형 애플리케이션에 대한 수요가 증가하고 WebAssembly와 같은 기술이 웹 개발 능력을 더욱 향상시키는 한, 이러한 추세는 계속될 것으로 예상됩니다.\n\n새로운 글과 신선한 모험에서 다시 만나요! ❤️\n\n제 글을 읽어주셔서 감사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nWant to Connect? \nYou can find me at GitHub: https://github.com/helabenkhalfallah\n","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png","tag":["Tech"],"readingTime":21},{"title":"네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다","description":"","date":"2024-06-20 07:18","slug":"2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa","content":"\n\n## Nest.js 대 ASP.NET: 프레임워크 비교\n\n![이미지](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png)\n\n웹 개발 여정을 시작하는 여러 가지 방법이 있습니다. 현대 웹에는 다양한 프레임워크가 있으며, 어떤 것이 최선인지 선택하는 것이 새로운 사용자들에게는 더 어려워지고 있습니다. 웹 프레임워크는 웹을 위해 만들어졌지만 사용해야 하는 다양한 이유가 있습니다.\n\n구축할 웹 사이트 유형, 사이트의 성능 요구 사항, 사용 가능한 개발자 풀, 그리고 사용하는 클라우드 제공 업체에 따라 만들어야 할 결정에 영향을 줄 것입니다. 결과적으로, 프레임워크를 선택할 때 고려할 사항이 많이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Nest.js와 ASP.NET이 무엇인가요?\n\n먼저 Nest.js부터 알아보겠습니다.\n\n## Nest.js\n\nNest.js는 TypeScript 프로그래밍 언어를 사용하여 완전히 구현된 Node.js 웹 프레임워크입니다. 다른 Node.js 웹 프레임워크와 비교할 때, Nest.js는 코드의 잘 정리된 프로젝트 구조에 중점을 둡니다. 경험 많은 개발자들은 Nest.js가 코드를 Angular 같은 다른 프레임워크로 어떻게 정리하는지를 알아볼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js는 Express의 함수형 접근 방식과 비교하여 TypeScript의 객체 지향 프로그래밍을 완전히 활용합니다. 그러나 내부적으로 Nest.js는 HTTP 서버를 실행하기 위해 Express 또는 Fastify(구성에 따라 다름)를 사용합니다. 따라서 다른 프레임워크 위에 있는 추상화 계층으로 생각할 수 있습니다.\n\n## ASP.NET\n\nASP.NET은 Microsoft가 만든 웹 프레임워크입니다. Microsoft의 C# 프로그래밍 언어를 사용합니다. ASP.NET은 2002년 초반부터 오랫동안 사용되어 왔습니다. 하지만 이전부터 지속적으로 새로운 버전을 출시하며 지속적으로 향상되어 왔습니다. 이러한 결과로 ASP.NET은 이제 C#으로 거의 모든 것을 구축할 수 있는 프로그래밍 도구 모음인 .NET으로 더 널리 알려지게 되었습니다.\n\n웹 프레임워크는 이제 보편적으로 .NET Core로 불리며, .NET 6가 최신 버전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TypeScript과 C#이 무엇인가요?\n\nTypeScript과 C#은 모두 Microsoft가 만들었습니다. Microsoft는 닷컴 붐 속에서 수요가 증가함에 따라 C#을 만들었습니다. Sun Microsystems의 Java와 같은 언어가 웹 개발자들에 의해 가장 인기 있는 프로그래밍 언어 중 하나로 발전하는 가운데, Microsoft는 자사의 언어를 만들어 시장에 진입하기로 결정했습니다.\n\nJavaScript도 닷컴 붐 이후 지금까지 인기를 얻고 있었습니다. 2010년대 초, Microsoft 엔지니어들은 강력한 타입 시스템을 갖춘 JavaScript의 상위 집합인 TypeScript을 만들었습니다. 그러나 TypeScript은 2016년부터 맹활약하기 전에 성숙 과정을 거쳤습니다.\n\n동일한 회사가 두 프로그래밍 언어를 만들었기 때문에 두 언어는 공통점이 많으며, 익숙함으로 인해 개발 경험이 증진되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 언어 모두 컴파일되기 때문에 컴파일러가 컴파일 시간에 오류를 확인합니다.\n\n## TypeScript에서의 객체 지향 프로그래밍\n\nTypeScript에서의 객체 지향 프로그래밍은 JavaScript보다 조금 더 나은 편입니다. 그러나 JavaScript와 TypeScript 모두 클래스를 지원하며, 두 언어 모두 코드 캡슐화를 구현하는 것은 꽤 간단해 보입니다.\n\n```typescript\nclass Car {\n  color: string;\n  getColor() {\n    return this.color;\n  }\n  setColor(_color: string) {\n    this.color = _color;\n  }\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript에는 JavaScript에 없는 인터페이스가 있습니다.\n\n```js\n인터페이스 Car {\n  type: string;\n  getType(): string;\n  setType(_type);\n}\n```\n\n인터페이스의 구현은 다음과 같이 보일 것입니다:\n\n```js\nclass Audi implements Car{\n  type: string;\n  color: string;\n  getName() {\n    return this.color;\n  }\n  setName(_color: string) {\n    this.color = _color;\n  }\n  getType(): string {\n    return this.type;\n  }\n  setType(_type: any) {\n    this.type = _type;\n  }\n}\n인터페이스 Car {\n    type: string;\n    getType(): string;\n    setType(_type);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js는 TypeScript에서 OOP를 가장 효율적으로 활용하는 프레임워크 중 하나입니다. 모든 것이 인터페이스, 클래스 및 의존성 주입과 같은 OOP 개념에 기반을 두고 있습니다.\n\n## C#에서의 객체 지향 프로그래밍\n\nC#은 당시 가장 인기 있는 OOP 프로그래밍 언어인 Java를 모델로 삼았습니다. 최근까지 C#에서 코딩하는 것은 항상 Java에서 코딩하는 것과 동일한 단점을 가지고 있었습니다. main 함수를 만들어야 하고 복잡한 프로젝트 구조를 유지해야 하는 등의 단점이 있었습니다. 또한, 프로바이더, 서비스 또는 컨트롤러와 같은 클래스 이름이 유사하거나 충돌할 수 있습니다.\n\nC#에서 유사한 베이스 클래스를 만드는 방법은 다음과 같을 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Car\n{\n  private string color;\n  \n  public void getColor() \n  {\n    return this.color;\n  }\n  \n  public void setColor(string color) \n  {\n    this.color = color;\n  }\n}\n```\n\n인터페이스는 다음과 같이 보일 것입니다:\n\n```js\ninterface ICar\n{\n    string getType();\n    void setType(type);\n}\n```\n\n전체 구현은 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Audi : ICar\n{\n  private string type;\n  private string color;\n  public void getColor() \n  {\n    return this.color;\n  }\n  public void setColor(string color) \n  {\n    this.color = _color;\n  }\n  public void getType() \n  {\n    return this.type;\n  }\n  public void setType(string type) \n  {\n    this.type = _type;\n  }\n}\n```\n\n개발자분께서 경험상 TypeScript와 비교하여 C#은 더 풍부한 객체지향 프로그래밍(OOP) 기능을 제공한다는 것을 알게 될 것입니다. 인터페이스는 C#이 할 수 있는 것들 중 일부에 불과합니다. 더 발전된 개념은 리플렉션(reflection)을 사용하는 것인데, 지금은 제가 먼저 가려고 하는 것 같네요.\n\n## Nest.js vs. ASP.NET\n\n이제 논란이 될 부분으로 향하고 있습니다. 프로젝트에는 무엇을 선택해야 할까요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n둘 다 놀라운 프레임워크인데 고려해야 할 일부 결정은 개인적인 기호에 따라 다르게 결정될 수 있습니다. 이 둘 사이에서 선택을 하는 것은 얼마나 유사한지 때문에 까다로운 일입니다.\n\n## 주요 기능 비교\n\nNest.js와 ASP.NET은 인증, 캐싱 및 데이터베이스 액세스와 관련된 기능을 쉽게 제공합니다. 두 프레임워크 모두 사용할 수 있는 기능입니다. Nest.js는 @nestjs/passport, @nestjs/cache-manager 및 @nestjs/typeorm 패키지를 사용하여 이러한 기능을 제공합니다. 한편 ASP.NET은 Microsoft.AspNetCore.Authentication, Microsoft.AspNetCore.Caching.Memory 및 유명한 Microsoft.AspNetCore.Identity.EntityFrameworkCore와 같은 패키지를 통해 인증, 캐싱 및 데이터베이스 액세스(및 더!) 기능을 제공합니다.\n\nTevpro의 기사에서는 Nest.js가 제공하는 기본 기능의 집합을 설명하고 있습니다. Nest.js와 ASP.NET 간의 사용 가능한 패키지를 비교한 테이블을 참조하여 더 자세한 내용을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 프레임워크의 주요 기능 간 결과는 비슷하지만, Nest.js와 ASP.NET은 둘 다 거대한 커뮤니티를 뒷받침하고 있습니다. 예를 들어, Nest.js는 Node.js 커뮤니티를 의지할 수 있고, ASP.NET은 거의 모든 대규모 기업 시스템에서 사용되기 때문에 대규모 기업 후원을 받고 있습니다.\n\n당연히 ASP.NET 웹 프레임워크 쪽에는 Nest.js보다 더 많은 패키지가 있습니다. 이는 ASP.NET이 더 오래되었기 때문입니다. 그러나 언젠가는 Nest.js도 JavaScript 및 TypeScript 개발자들의 수가 더 많아지면서 혜택을 받을 것입니다.\n\n## 유사점\n\nNest.js와 ASP.NET 사이에는 많은 유사점이 있다는 것이 놀라울 수도 있습니다. 그러나 둘 다 일상적으로 OOP에 크게 의존하고 있으며 TypeScript와 C#이 프로그래밍 언어로서 얼마나 유사한지를 고려할 때, 어떤 프레임워크를 사용하는지에 따라 앱을 비교할 때 큰 차이가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 Nest.js 프로젝트를 위한 서비스 컨트롤러는 아래와 같이 보일 것입니다:\n\n```js\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n  \n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n```\n\nAppController는 의존성 주입을 통해 AppService를 받아오며, getHello 함수는 문자열을 응답으로 반환합니다. 예를 들어, ASP.NET의 유사한 컨트롤러는 다음과 같이 보일 것입니다:\n\n```js\nnamespace Backend.AppController\n{\n    [ApiController]\n    public class AppController\n    {\n        private readonly AppService appService;\n        \n        public AppController(AppService _appService)\n        {\n            this.appService = _appService;\n        }\n        \n        [HttpGet]\n        public async Task\u003cIActionResult\u003e GetHello()\n        {\n            return Ok(this.appService.GetHello());\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js와 비교하면 ASP.NET에서 작성하는 것이 더 장황해 보입니다. 그리고 두 가지 모두 컴파일된 언어를 사용하기 때문에 컴파일러가 런타임 전에 유형 오류와 같은 사소한 오류를 잡아줄 수 있습니다.\n\n## Nest.js 대 ASP.NET 성능평가\n\n두 프레임워크 간 속도를 비교하는 것은 논란이 될 수 있고, 최소한 몇몇 비평을 유발할 것입니다. 하지만 프레임워크를 선택할 때 약간 고려해 볼 가치가 있습니다.\n\n2022년 Tech Empower Web Benchmarks에 따르면 ASP.NET Core는 14위로 세계에서 14번째로 빠른 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image 1](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_1.png)\n\nWhile Nest.js, using a Fastify backend, is ranked at #239.\n\n![image 2](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_2.png)\n\nPlease note that these benchmarks are arbitrary speed calculations of how fast a framework would respond. You don’t necessarily need a fast framework most of the time. And the most important metric is (arguably) your development speed, but that’s VERY subjective, bringing us to the next point.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n---\n\n# Nest.js 대신 ASP.NET을 고려해야 하는 시기 (또는 그 반대)\n\n대중들의 의견을 살펴보면 결정을 내리기 어려울 것입니다. 두 프레임워크를 비교하는 의견은 주로 물어보는 커뮤니티에 따라 (또는 이 경우에는 Sub Reddit에 따라) 다를 수 있습니다.\n\nReddit을 살펴보면, 몇 개의 게시물이 두 프레임워크를 비교하는데 (일부 게시물은 Node.js를 직접적으로 ASP.NET과 비교합니다) 있습니다. 토론에서 주로 나오는 의견은 \"Node.js에서 ASP.NET으로 전환하려면 먼저 TypeScript를 고려해보라\"로 요약됩니다.\n\nNest.js는 이미 TypeScript를 사용하고 있으니, 이것이 문제를 해결해 줄 것이라 생각할 수 있겠죠? 그렇지 않습니다. 그렇게 간단하지는 않습니다. TypeScript를 사용하는 것이 더 나은 이유는 frontend 언어와 backend 언어를 결합해 소규모 팀이 제품을 성장시키기 더 쉬워지기 때문이라고 주장하기는 하지만, ASP.NET을 사용하는 경우 더 합리적인 상황이 있을 수 있습니다.\n\n---\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어 클라우드 공급업체가 Azure이고 벤더 락인이 신경 쓰이지 않는다면 ASP.NET이 더 나은 선택입니다.\n\n그러나 보다 넓은 시각에서 볼 때 Nest.js와 ASP.NET 사이에 큰 차이가 많이 없습니다. 두 프레임워크가 추구하는 철학에는 많은 중첩이 있어서 OOP의 활발한 사용이 그 중 하나입니다. 때로는 특히 언어별 차이 덕분에 두 프레임워크 사이에 인상적인 유사성을 찾을 수 있습니다.\n\n실용적으로 중요한 것은 기본 속도, 프로젝트 구조, 라이브러리 이용 가능성 및 커뮤니티 지원을 고려할 필요가 없습니다. 다음 사항만 고려하면 됩니다:\n\n- 팀의 특정 기술 세트.\n- 제품 개발 일정.\n- 사용 중인 클라우드 공급업체.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 프레임워크 모두 서버 측 렌더링 프레임워크로, 전통적인 MVC 애플리케이션을 간편하게 연결하여 밀접하게 통합된 모노리스를 만들 수 있습니다.\n\n프레임워크를 선택할 때 흔히 발생하는 함정에 대해 알아야 합니다. 이전 선택사항에 과도하게 고집하지 말고, 시대가 변화하고 어떤 프레임워크가 인기 경쟁에서 우승한 것뿐만 아니라 그 기능적인 우수성 때문에 더 많이 채택될 수도 있다는 점을 인식해야 합니다. 사소한 문제 때문에 발목을 잡지 마세요, 더 나은 선택을 해보세요!\n\n# 결론\n\nNest.js와 ASP.NET은 놀라운 프레임워크이지만, 일반적으로 사용 사례는 구축하고 있는 팀(또는 가지게 되는 팀) 유형에 제한됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프레임워크들을 명백하게 선택해야 하는 이유는 없어요. 다른 언어보다 여기서 사용하라고 강제하거나 산업에 특화된 작업을 진행하는 경우, 게임 개발에 Unity를 사용하면서 C#을 사용해야 하는 경우처럼 특정 언어 집합을 사용해야 하는 경우를 제외하고는 백엔드로 ASP.NET을 고려해 보세요.\n\nNest.js와 ASP.NET 중에서 선택하는 것은 Nest.js와 고성능 Go/Rust 웹 프레임워크 중에서 선택하는 것만큼 중대하지 않아요. 각각의 독특함은 있지만 전반적으로 차이보다는 중첩된 부분이 더 많아요. 그러니 기술에 대해 너무 꼼꼼하게 고려할 필요 없어요. 시대에 맞춰 움직이세요. 즐겁게 코딩하세요! \n\n원문: https://blog.logrocket.com, 2022년 11월 22일에 발행됨.","ogImage":{"url":"/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png"},"coverImage":"/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 DSA 모험 - 3장 - 배열-01","description":"","date":"2024-06-20 07:17","slug":"2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01","content":"\n\n이 블로그에서는 프로그래밍에서 핵심적이고 널리 사용되는 배열 데이터 구조를 알아볼 것입니다.\n\n배열은 메모리가 서로 옆에 위치한 선형 데이터 구조입니다. 우리는 배열 요소에 인덱스 번호로 액세스할 수 있습니다. 배열은 대량의 데이터를 저장하는 데 자주 사용됩니다. 메모리 할당과 차원을 기반으로 범주화된 다양한 유형의 배열이 있습니다.\n\n# 메모리 할당에 따른 배열\n\n정적 배열: 배열 크기가 고정된 배열로, 메모리 할당이 배열 생성 시에 이루어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet arr=[1,2,3,4,5];\n```\n\n동적 배열: 크기가 동적으로 커질 수 있는 배열이며, 메모리 할당이 동적으로 이루어집니다.\n\n```js\nlet arr= new Array(5);\n```\n\n# 차원에 따른 배열\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\na. 일차원\n\nb. 다차원\n\n# 미리 정의된 배열 메소드의 복잡성 분석\n\n- push(): 배열의 끝에 요소를 추가하며 다른 인덱스를 업데이트하지 않습니다.\n시간 복잡도: O(1)\n공간 복잡도: O(1)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*opzqu5bRV6657AZwySuS5g.gif)\n\n2. pop(): 배열의 끝에서 요소를 제거하고 다른 인덱스를 업데이트하지 않습니다.\n시간 복잡도: O(1)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*cP7tauXB0AkDx9P0ECRooA.gif)\n\n3. shift(): 배열의 시작에서 요소를 제거하고 남은 인덱스를 업데이트합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*wDYt2Kg8rb0miocg8amjYw.gif)\n\n4. unshift(): 배열의 시작 부분에 요소를 추가하고 남은 인덱스를 업데이트합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*HagypKnHwgJPgAA53o2IAQ.gif)\n\n5. splice(): 기존 요소를 이동하여 요소를 추가하거나 제거합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (요소가 추가되면 새로운 요소에 대한 추가 공간이 필요합니다)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. concat(): 두 배열을 병합합니다.  \n시간 복잡도: O(n + m) (여기서 'n'과 'm'은 병합되는 배열의 길이입니다)  \n공간 복잡도: O(n + m) (결과를 저장하기 위해 새로운 배열이 생성됨)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*u4_C14uNAEPERs71mjPssQ.gif)\n\n7. 요소에 접근 (arr[index]): 인덱스를 사용하여 요소에 직접 액세스합니다.  \n시간 복잡도: O(1)  \n공간 복잡도: O(1)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6OuIlKR5RJiLwCS3SAM3lg.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n8. map(): 호출한 배열의 각 요소에 대해 함수를 호출하여 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (동일한 크기의 새 배열이 생성됨)\n\n9. forEach(): 배열 요소마다 한 번씩 제공된 함수를 실행합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n10. reduce(): 누산기에 대해 함수를 적용하고 배열의 각 요소마다 하나의 값을 줄입니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n11. filter(): 제공된 함수에 의해 구현된 테스트를 통과하는 모든 요소로 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (필터링된 요소를 보유하는 새 배열이 생성됨)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n12. slice(): 기존 배열의 일부를 추출하여 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (추출된 요소로 새 배열이 생성됩니다)\n\n13. includes(): 배열에 특정 값이 포함되어 있는지 여부를 확인합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qAvY1uZYVoruLu2hiDG7Ow.gif)\n\n14. indexOf(): 주어진 요소가 처음으로 발견되는 인덱스를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vjlt1A3ss8ncvINiuD4QJg.gif)\n\n15. find(): 주어진 테스트 함수를 만족하는 배열 내 첫 번째 요소를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*dK0xCiis9Aia7wgpR86Stg.gif)\n\n16. findIndex(): 주어진 테스트 함수를 만족하는 배열 내 첫 번째 요소의 인덱스를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vjlt1A3ss8ncvINiuD4QJg.gif)\n\n17. sort(): 배열 요소를 정렬하며 일반적으로 Timsort의 변형을 사용합니다.\n시간 복잡도: O(n log n)\n공간 복잡도: O(n) (정렬 중 임시 배열에 대한 추가적인 공간이 필요합니다)\n\n# 왜 배열을 사용해야 할까요?\n\n배열은 요소에 쉽게 액세스하고 더 나은 캐시 지역성을 갖고 싶을 때 유용합니다. 캐시 지역성은 상대적으로 가까운 저장 위치 내에서 데이터 요소를 사용하는 것을 의미합니다. 프로세서가 메모리 위치에 액세스할 때 그것이 필요한 특정 데이터뿐만 아니라 인접한 데이터 블록도 캐시로 로드합니다. 배열은 연속적으로 저장되어 있기 때문에 한 요소에 액세스하면 캐시로 로드된 인접 요소가 있을 수 있습니다. 이는 인접한 요소에 대한 후속 액세스가 빠르다는 것을 의미합니다. 왜냐하면 이미 캐시에 들어있기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음에 코딩할 때는 이 통찰을 잘 기억하고 자신감을 가지고 DSA(Data Structures and Algorithms) 모험을 떠나보세요!\n\n다음 블로그에서 만나요, 코드 마법사들!","ogImage":{"url":"/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png","tag":["Tech"],"readingTime":4},{"title":"새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화","description":"","date":"2024-06-20 07:16","slug":"2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers","content":"\n\nReact Native 개발자들이 기대할만한 새로운 것이 있습니다 — 현재 베타 단계에 있는 새로운 React Native IDE입니다. 이 흥미로운 새로운 도구는 Visual Studio Code (VS Code) 확장 프로그램으로 제공되며, macOS에서 안드로이드와 iOS 플랫폼 모두에 대한 개발을 지원합니다. 이 블로그에서는 이 IDE의 기능, 이점 및 잠재적인 도전 과제에 대해 탐구하고, React Native 개발 커뮤니티에 중요한 발전을 뜻하는 이유를 살펴보겠습니다.\n\n# React Native IDE 시작하기\n\n# 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 네이티브 IDE 설치는 간단합니다. VS Code에 확장 프로그램을 추가하여 리액트 네이티브 프로젝트를 위해 특별히 설계된 강력한 개발 도구 모음을 활성화할 수 있습니다. 아래는 시작하는 방법입니다:\n\n- VS Code 열기: 최신 버전이 설치되어 있는지 확인해주세요.\n- 확장 프로그램으로 이동: 활동 표시줄의 확장 프로그램 아이콘을 클릭하거나 Ctrl+Shift+X를 눌러 확장 프로그램 뷰로 이동합니다.\n- 리액트 네이티브 IDE 검색: 검색 상자에 \"리액트 네이티브 IDE\"를 입력합니다.\n- 확장 프로그램 설치: 설치 버튼을 클릭하여 확장 프로그램을 VS Code 환경에 추가합니다.\n\n설치 후, 이 확장 프로그램은 원활하게 통합되어 리액트 네이티브 개발에 특화된 고급 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 자동 시뮬레이터 관리\n\n시뮬레이터 및 에뮬레이터 관리는 귀찮은 일일 수 있지만, React Native IDE는 자동 시뮬레이터 관리 기능으로 이를 간단하게 처리합니다. 이 기능은 프로젝트에 적합한 시뮬레이터를 감지하고 시작하여 구성보다는 코딩에 집중할 수 있도록 합니다.\n\n# 2. 고급 디버깅 도구\n\nReact Native에서 디버깅하는 것은 이제 더 쉽지 않을 수 있습니다. IDE는 중단점 설정, 코드 스텝 진행 및 변수 검사를 포함한 견고한 디버깅 도구를 제공합니다. 이러한 도구는 문제를 신속하게 식별하고 해결하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 요소 검사\n\n클릭하여 검사하는 기능이 특히 주목할 만합니다. 웹 개발 도구와 유사하게, 이 기능을 사용하면 시뮬레이터에서 어떤 요소를 클릭해도 VS Code 내에서 해당 요소의 속성을 직접 검사할 수 있습니다. 이 익숙한 작업 흐름은 사용하기 쉽고 효과적으로 인정 받고 있습니다.\n\n# 4. 라우팅 및 내비게이션\n\nExpo 라우터와 통합된 IDE를 사용하면 프로젝트 내에서 탐색을 간편화 할 수 있습니다. URL 바를 통해 경로를 지정하여 서로 다른 화면과 구성 요소를 테스트하고 디버그하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 로그 통합\n\nIDE 내에서 로그를 통합하면 개발 환경을 떠나지 않고 콘솔 출력과 오류 로그를 모니터링할 수 있습니다. 이 통합은 디버깅 프로세스를 간편하게 만들어주고 생산성을 향상시켜줍니다.\n\n# 6. 독립적인 컴포넌트 개발\n\nReact Native IDE의 특징 중 하나는 독립적인 환경에서 컴포넌트를 개발할 수 있는 기능입니다. 이 기능을 통해 개발자는 개별 컴포넌트에 집중하여 해당 컴포넌트가 완벽하게 작동하는지 확인한 뒤 더 큰 응용 프로그램에 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 도전 과제 및 베타 단계에서 발생하는 문제\n\n모든 베타 소프트웨어와 마찬가지로, React Native IDE에는 고려해야 할 도전 과제가 있습니다. 초기 설정은 일부 사용자에게 번거로울 수 있으며, 기능적인 결함이 예상되기도 합니다. 그러나 이러한 것들은 도구가 점차 성숙해지면 개선될 가능성이 높습니다.\n\n## 결론\n\n베타 단계에 있음에도 불구하고 React Native IDE는 React Native 개발자들에게 상당한 진전을 제공합니다. 개발 프로세스를 간소화하고 디버깅 기능을 강화하며 강력한 기능을 제공함으로써, 이 IDE는 생산성을 향상시키고 개발을 보다 쉽게 만들어주는 것을 약속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 React Native 개발자이신 경우, 이 IDE의 베타 버전에 액세스를 요청하는 것은 워크플로우를 크게 향상시킬 수 있습니다. 이 인상적인 새로운 도구로 React Native 개발의 미래를 받아들이고 시대를 앞서가세요.\n\nIDE가 발전함에 따라 더 많은 안정성과 기능이 기대됩니다. 이는 React Native 개발자 툴킷의 필수적인 부분이 될 것입니다. React Native IDE가 완전히 출시될 때까지 업데이트와 개선 사항을 기대해주세요.\n\n🌟 읽어 주셔서 감사합니다!\n\n- 🚀 이 링크를 클릭하여 내 작업을 지원하세요: Support Me 🌟\n- 👏 이 기사에 박수를 보내어 감사의 표시를 전하세요.\n- 📌 더 많은 통찰력 있는 콘텐츠를 얻기 위해 Avishek Kumar를 팔로우하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n📣 계속 참여해 주세요\n\n- 🔔 트위터에서 팔로우하기(X)\n- 🔗 링크드인에서 연결하기\n\n# 스택아데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 응원하고 팔로우하기를 고려해 주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png"},"coverImage":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법","description":"","date":"2024-06-20 07:15","slug":"2024-06-20-HowtoSecureYourSiteAgainstWebScrapers","content":"\n\n## 가장 좋은 브라우저 지문 기술입니다. 당신만의 지문 코드를 몇 분 안에 구현하는 법을 배워보세요!\n\n![이미지](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png)\n\n브라우저 지문 기술은 사용자를 고유하게 식별하고 싶은 다양한 상황에서 사용되는 보안 기술입니다. 물론, 그러한 상황 중 하나는 당신의 웹 사이트를 스크랩하는 경우입니다. 사용자 에이전트나 IP를 확인하는 것과 같은 제한적인 탐지 기술을 사용하면 그 정보를 쉽게 변경할 수 있으며 당신은 알지 못할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 브라우저 핑거프린트와 같은 것을 구현한다면, 그들의 작업을 훨씬 더 어렵게 만들 수 있습니다. 왜냐하면 가짜로 만들기 어려운 정보를 사용하기 때문이죠.\n\n이 기사에서는 이렇게 불리는 \"브라우저 핑거프린트\"를 만드는 가장 일반적인 기술 중 일부를 다루고, 그 중 하나를 구현하는 방법을 안내해 드릴 거예요.\n\n# 일반적인 브라우저 핑거프린팅 기술\n\n이 제목이 어려운 것처럼 들릴 수 있지만, 핑거프린트란 특정 입력 데이터 집합으로부터 생성된 해시에 불과합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 핵심은 어떻게 그것에 도달하는지에 있어요.\n\n### 캔버스 요소 사용하기\n\n지문을 얻는 한 가지 방법은 사용자가 보지 못하도록 뭔가를 그려내고 그 결과를 확인하는 것입니다.\n\n각 브라우저는 캔버스 요소에 콘텐츠를 렌더링하는 방식에 약간의 차이가 있습니다. 이들은 미묘한 차이이므로 찾고 있지 않다면 정말로 발견하기 어렵습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정한 사용 사례는 여러 사실을 활용합니다:\n\n- 모든 시스템에 폰트가 제공되지 않아서 그런 경우에는 대체 옵션을 사용해야 합니다.\n- 적용된 안티 앨리어싱이 항상 동일하지는 않습니다.\n- 브라우저의 구현에 따라 다른 세부 사항이 있습니다.\n\n한 번 렌더링된 후 이미지를 해시로 변환해야 하며, 그렇게 하면 지문이 생성됩니다.\n\n최고의 부분은 캔버스 요소를 숨길 수 있어서 사용자가 실제로 무엇을 하는지 알 수 없다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 미디어 장치 목록\n\n브라우저의 지문을 식별하는 또 다른 방법은 시스템에 연결된 미디어 장치 목록을 수집하고 그 정보를 기반으로 해시를 생성하는 것입니다.\n\n이를 어떻게 할 수 있을까요? 실은 매우 간단합니다. 모든 최신 브라우저에는 연결된 모든 장치를 나열할 수 있는 미디어 장치 API가 있습니다.\n\n다음 코드는 시스템에서 모든 미디어 장치를 나열합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMDN 공식 문서에서 가져온 코드입니다. 제 Firefox에서 실행하면 다음 출력이 나옵니다:\n\n```html\n\u003cimg src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_1.png\" /\u003e\n```\n\n미래 요청에서 식별자 역할을 할 수 있는 단일 해시 값을 생성하는 방법을 쉽게 파악할 수 있을 것 같습니다. 브라우저 구성을 변경하더라도 식별 가능합니다.\n\n## 오디오 파형 지문분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스 요소 기술과 마찬가지로 Web Audio API를 사용하여 오디오 클립을 생성할 수도 있습니다. 고정된 소스(모든 시스템에 동일한 입력을 제공하는 발진기)를 기반으로 하고 출력의 해시를 계산할 수도 있습니다.\n\nWeb Audio API의 복잡성을 고려하면, 많은 수학과 부동 소수점 수학이 관련되어 있습니다. 이는 각 브라우저가 조금씩 다른 구현을 갖게 되며, 이는 누가 작성했는지와 해당 운영 체제에 따라 달라집니다. 이러한 차이점은 실행 중인 시스템이 매 실행에서 일관된 고유값을 생성할 수 있을 정도로 충분히 누적됩니다.\n\n이러한 값은 브라우저와 운영 체제를 식별하는 데 사용할 수 있는 신뢰할 수 있는 지문으로 사용할 수 있습니다. 특히, 브라우저의 시크릿 모드를 사용하더라도 동일한 지문이 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직접 지문코드를 구현해 봅시다\n\n가장 흔한 지문 기술 중 일부를 이해했으니, 여기서는 그 중 하나를 구현하는 방법에 대해 빠르게 살펴보겠습니다.\n\n미디어 장치 목록에 대한 코드 일부를 이미 보았지만, 캔버스 요소에 중점을 둘 것입니다. 많은 데이터 포인트를 수집하는 것보다 더 흥미로운 것이라고 생각하기 때문입니다.\n\n이 기술을 사용하려면 텍스트가 포함된 그림을 캔버스 요소 내부에 그리고, 그 그림을 단일 해시로 변환해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 해야 할 일은 캔버스를 정의하고 그 안에 몇 가지 모양을 그리고 텍스트를 추가한 다음, 그 위에서 toDataURL 메서드를 호출하는 것 뿐이에요. 기본적으로 캔버스는 우리의 이미지를 PNG로 변환하고, 그것을 단일 해시 값으로 변환할 겁니다.\n\n특히, 우리의 \"해시\"는 단일 정수가 될 겁니다. 본인이 원하는 해싱 방법을 사용해도 돼요. 저는 코딩하기 쉽고 빠른 성능을 가진 하나를 선택했어요.\n\n이 코드는 다음과 같은 출력물을 생성합니다:\n\n![How to Secure Your Site Against Web Scrapers](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 실제 이미지는 상당히 추악합니다. 우리는 지금 아름다운 것을 만들려는 것이 아니라 해시에 대해 걱정하고 있습니다. 크롬과 시크릿 모드의 크롬의 값이 동일하고 파이어폭스에서는 다르다는 것을 주목하세요.\n\n이것은 중요한 포인트입니다. 이는 크롤러/스크레이퍼가 그들의 브라우저에서 음해모드를 사용함으로써 \"속이려\" 하려고 할 때 언제인지 알 수 있다는 것을 의미합니다.\n\n그들은 브라우저를 변경할 수 있고, 그러면 당신은 몰라도 될 것입니다. 그러나 스크레이퍼/크롤러는 보통 자신을 다른 것처럼 식별하려고 하는 동일한 브라우저를 항상 사용합니다 (User Agent 문자열과 같이).\n\n이 상황에서 당신은 웹사이트를 크롤링/스크래핑하려는 헤드리스 브라우저에 대해 보호할 수 있습니다. 위 코드를 숨겨진 Canvas 요소에 실행하는 스크립트를 갖고, 해시를 가져와서 자체 \"블랙리스트\" 값 목록과 비교하세요. 그들이 거기에 있다면, 그럼 무슨 일을 해야하는지 알 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저 지문 추적은 사용자가 시스템과 상호 작용하는 방식을 원치 않을 때 보호하는 데 훌륭한 도구일 수 있습니다. 사이트를 스크랩하려는 사람부터 사용자가 유료 콘텐츠를 속일 수 없도록 하는 데 사용되며, 또는 콘텐츠에 제한된 횟수로만 액세스하도록 하는 데도 사용될 수 있습니다. 정말로 여러분의 상상력이 한계입니다.\n\n그리고 이론이 복잡해 보이지만 실제 구현은 그렇지 않다는 것을 알 수 있습니다. 여러분은 손쉽게 자체 지문 코드를 작성할 수 있습니다.\n\n이런 기술 중 하나를 사용해 보셨나요? 혹은 더 나아가, 과거에 한 번 속여 본 경험이 있으신가요? 그렇다면 어떻게 하셨는지 이야기를 공유해 주세요!\n\n# 재사용 가능한 컴포넌트로 마이크로프론트엔드 구축하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_3.png\" /\u003e\n\nBit의 오픈소스 도구를 통해 25만 명 이상의 개발자가 컴포넌트로 앱을 만들 수 있습니다.\n\n어떤 UI, 기능 또는 페이지도 재사용 가능한 컴포넌트로 변환하여 여러 애플리케이션에서 공유할 수 있습니다. 협업이 더 쉬워지고 빠르게 개발할 수 있습니다.\n\n→ 자세히 알아보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 구성 요소로 나누어 앱 개발을 쉽게 만들고 원하는 워크플로우에 최적의 경험을 즐기세요:\n\n- **Micro-Frontends**   \n- **Design System**   \n- **Code-Sharing and reuse**  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 모노리포\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs 심층 분석 1  createElement와 jsx-runtime","description":"","date":"2024-06-20 07:13","slug":"2024-06-20-ReactjsDeepDive1createElementandjsx-runtime","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png\" /\u003e\n\nReact는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리로, 상호작용적이고 동적인 웹 애플리케이션을 만들기 위한 다양한 도구와 기능이 풍부합니다. React의 최신 버전(React 17부터)에서는 JSX 변환 방법이 크게 변경되었습니다. React 17에서 소개된 새로운 JSX 변환은 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime 및 react/jsx-dev-runtime 패키지에서 jsx, jsxs, jsxDEV 등의 새로운 함수를 도입하였습니다. 이 글은 \"React.js Deep Dive\" 시리즈 중 첫 번째로, React.createElement, jsx-runtime을 사용한 새 버전 및 React 생태계에서의 역할을 탐구합니다.\n\n이 새로운 변환 방법이 작동하는 방식에 대한 개요는 다음과 같습니다:\n\n# React 17 이전\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에는 JSX가 React.createElement 호출로 컴파일되었습니다. 예를 들어, 다음 JSX:\n\n```js\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      My App\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n백그라운드에서 JSX는 React.createElement 호출로 변환됩니다:\n\n```js\nfunction App() {\n  return React.createElement(\"div\", {\n    children: \"My App\"\n  });\n}\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React 17버전 이후\n\n새 JSX 변환 기능을 사용하면 같은 JSX 코드:\n\n```js\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      My App\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n다음으로 변환됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction App() {\n  return /*#__PURE__*/_jsx(\"div\", {\n    children: \"내 앱\"\n  });\n}\nexport default App;\n```\n\n개발 모드에서는 더 나은 디버깅 정보를 제공하기 위해 react/jsx-dev-runtime의 jsxDEV을 사용할 수 있습니다:\n\n```js\nfunction App() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n    children: \"내 앱\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 3,\n    columnNumber: 5\n  }, this);\n}\n```\n\n# 왜 이 변화가 있었을까요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 JSX 트랜스폼에는 여러 가지 이점이 있습니다:\n\n- 범위 내에서 React 사용량이 필요 없음: 새로운 트랜스폼을 사용하면 JSX를 사용하는 모든 파일 맨 위에 React를 가져오지 않아도 됩니다. 이는 코드를 간소화하고 보일러플레이트를 줄일 수 있습니다.\n- 더 작은 번들 크기: 새로운 트랜스폼은 좀 더 최적화된 코드를 생성하기 때문에 조금 더 작은 번들 크기로 이어질 수 있습니다.\n- 미래 지향적: 이 변경 사항은 React 생태계를 미래 개선과 최적화를 위해 준비시킵니다.\n\n이 함수를 더 자세히 살펴보면 반환 값이 이와 같아야 합니다:\n\n```js\n{\n  $$typeof: Symbol(react.element),\n  type: \"div\",\n  props: {children: 'My App'},\n  key:null,\n  ref:null,\n  _owner: null,\n  _store: {validated: false}\n  _self: undefined\n  _source: {\n    fileName: '/my-app/src/App.tsx', \n    lineNumber: 3, \n    columnNumber: 5\n  }\n  [[Prototype]]: Object\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 반환된 각 속성을 자세히 살펴보겠습니다:\n\n타입\n\n전달한 요소의 유형입니다. HTML 태그나 React 컴포넌트를 나타내는 문자열일 수 있습니다. 위의 코드에서는 타입이 HTML 태그 div입니다.\n\n프롭스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전달 된 props 중에서 ref 및 key를 제외한 항목들. 컴포넌트의 타입이 defaultProps 속성을 가지고 있다면, 누락되거나 정의되지 않은 props는 기본 값으로 설정됩니다.\n\nref\n\n전달된 ref입니다. ref가 전달되지 않았다면, 이 속성은 null이 될 것입니다. Ref를 사용하면 DOM 노드에 직접 액세스할 수 있어 입력란에 초점을 맞추거나 스크롤 위치를 읽거나 DOM에 직접 액세스가 필요한 타사 DOM 라이브러리와 통합하는 등의 작업을 수행할 수 있습니다.\n\nkey\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n# 내부 메커니즘\n\n전달된 키가 문자열로 강제 변환됩니다. 키가 전달되지 않았다면, 이 속성은 null이 될 것입니다.\n\n중요한 점은 $$typeof, _store, _owner 및 _self가 React에서 개발 시 사용되는 내부 메커니즘임을 알아두어야 합니다. 이들은 React 작동에 중요한 역할을 하지만, 애플리케이션 코드에서 사용되도록 의도된 것은 아닙니다.\n\n$$typeoff\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 React 요소를 고유하게 식별하기 위해 $$typeof 속성을 사용합니다. 심볼을 초기에 사용한 선택은 다른 환경에서 전역 고유성을 보장하고 다른 라이브러리나 전역 범위의 코드와의 이름 충돌을 피하기 위한 욕구에서 비롯되었습니다.\n\n_store\n\nReact 요소 객체의 _store 속성은 주로 개발 모드(__DEV__)에서 유효성 검사를 위해 사용됩니다. 이 속성에는 validated라는 단일 부울 속성이 포함되어 있습니다. 이 속성은 React 요소가 특정 규칙에 대해 유효성을 검사했는지 여부를 나타내는 플래그 역할을 합니다. 예를 들어, 요소가 목록의 일부이고 고유한 키 속성이 없는 경우, React의 유효성 검사 논리는 _store.validated를 false로 표시할 것입니다. 요소를 유효성을 검사한 후, React는 _store.validated를 true로 설정하여 요소가 검사되었고 해당 요소에 대해 추가 유효성 검사가 필요하지 않음을 나타냅니다.\n\n_owner\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact에서 _owner 속성은 구성 요소 인스턴스의 소유자를 추적하는 데 내부적으로 사용됩니다. 이것은 React의 조정 프로세스에 중요한데요, 여기서 구성 요소가 다시 렌더링해야 하는지 여부를 결정합니다. 부모 구성 요소가 렌더링되면, 해당 자식 구성 요소의 인스턴스가 생성됩니다. 이러한 각 자식 인스턴스는 _owner 속성을 통해 부모에 대한 참조를 가지게 됩니다. 이를 통해 React는 구성 요소의 계층 구조를 추적하고 상태 변경을 효율적으로 관리할 수 있습니다.\n\n_self\n\nReact 요소의 _self 속성은 개발 모드 확인 및 최적화를 위해 React에서 사용되는 또 다른 내부 속성입니다. 이는 이벤트 위임 중에 원래 이벤트 대상을 저장하는 데 사용됩니다.\n\n이벤트가 트리거될 때 React는 _self를 사용하여 이벤트의 원래 대상을 기억합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n_소스\n\n리액트 요소에서 _소스 속성은 공식 리액트 문서나 표준 리액트 자원에서 직접적으로 문서화되지 않았습니다. 그러나 맥락을 고려하면, _소스는 리액트의 합성 이벤트 시스템 내에서 이벤트 원천 또는 소스를 내부적으로 추적하는 데 관련이 있을 수 있습니다.\n\n# 결론\n\n요약하면, 리액트는 React 17부터 도입된 새 JSX 변환에서 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime(jsx, jsxs) 및 react/jsx-dev-runtime(jsxDEV)에서 함수를 사용합니다. 이 변경으로 JSX를 사용할 때 React를 가져와야 하는 필요성을 제거하고, 잠재적으로 더 작은 번들 크기를 갖게 하며, 미래의 향상을 대비합니다. 해당 기능을 이해함으로써 리액트의 작동 방식에 대해 보다 깊은 통찰을 얻을 수 있어서 효율적이고 효과적인 리액트 애플리케이션을 작성하는 능력을 향상시킬 수 있습니다. 다음 글에서는 가상 DOM을 탐험하고, 리액트가 렌더링 성능을 최적화하기 위해 어떻게 사용하는지 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 더 많은 통찰과 즐거운 코딩을 기대해 주세요!\n\n참고 자료:\n\n- React 문서: React 17: 새로운 JSX 변환\n- Babel 문서: Babel: JSX 런타임\n- Webpack 문서: Webpack: 모드 구성","ogImage":{"url":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png"},"coverImage":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png","tag":["Tech"],"readingTime":5},{"title":"대시트랩 - 부트스트랩 5 관리자 대시보드, UI 키트","description":"","date":"2024-06-20 06:09","slug":"2024-06-20-DashtrapBootstrap5AdminDashboardUIKits","content":"\n\n🔍 다시 한 번 Dashtrap을 확인해보세요 - Bootstrap 5 Admin Dashboard \u0026 UI Kits! 🎉 저희의 📁 관리자 템플릿 웹 템플릿 라이브러리를 살펴보시고 🆓 무료 다운로드 혜택을 누리세요. 함께 즐겁게 작업해봅시다! 🚀\n\nXeloro는 Bootstrap 5, HTML5, CSS3, 그리고 JQuery를 기반으로 한 개발자 친화적이며 매우 커스터마이즈 가능한 HTML 관리 대시보드 템플릿 중 가장 우수한 제품입니다. 완전히 반응형이며 컴포넌트, 위젯 및 UI 요소의 거대한 컬렉션을 포함한 청결한 사용자 인터페이스를 제공합니다. Xeloro는 다음 Bootstrap을 더 빠르게 만들 수 있도록 도와줍니다. SAAS 기반 인터페이스, 관리자 대시보드, 또는 웹에서 구축하고 싶은 모든 것을 만드는 데 사용할 수 있습니다. Xeloro는 팀이 더 빠르게 움직이고 개발 비용을 절약할 수 있도록 도와줍니다.\n\n특징:\n\n- 응답형 레이아웃 (데스크톱, 태블릿, 모바일 기기)\n- Bootstrap v5.3.2로 구성\n- 쉽게 사용자 정의 가능\n- 48개 이상의 빌드된 페이지\n- 깨끗하고 평평한 디자인\n- HTML5 및 CSS3\n- SASS 지원\n- 로그인, 등록 및 오류 페이지\n- 캘린더 보기\n- 수직 및 수평 레이아웃\n- 양식 유효성 검사\n- Google 및 Vector Maps\n- Dropify 파일 업로드\n- Quill Js 편집기\n- 부스트랩 및 데이터테이블 테이블\n- Feather, Material Design, Dripicons 및 Font Awesome 5 아이콘\n- 양식 마스크\n- 팀원, 송장, 유지보수, FAQ 및 가격 페이지\n- Apex Chats 라이브러리\n- Bootstrap, React, MaxLength, Switchery, Select2, Bootstrap Touchspin, Colorpicker, Bootstrap Datepicker, Date Range Picker 및 Auto-Numberic 플러그인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png)\n\nMyraStudio님의 Envato Elements에서 사진을 찍음\n\n고지: 본 문서에는 제휴 링크가 포함되어 있습니다. 이 링크를 통해 구매를 하신 경우 추가 비용없이 수수료를 받을 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png"},"coverImage":"/assets/img/2024-06-20-DashtrapBootstrap5AdminDashboardUIKits_0.png","tag":["Tech"],"readingTime":2},{"title":"자바를 사용하여 Flying Saucer로 HTML을 PDF로 변환하기","description":"","date":"2024-06-20 06:08","slug":"2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png\" /\u003e\n\n요즘의 디지털 세계에서 HTML 파일을 PDF 문서로 프로그래밍적으로 변환하는 것은 보고서 생성, 문서 보관 등 엔터프라이즈 애플리케이션에서 흔한 요구 사항입니다. 이 블로그 포스트에서는 Maven 종속성을 활용하여 Java를 이용해 이 작업을 어떻게 수행하는지 알아보겠습니다.\n\n# Flying Saucer 소개\n\nFlying Saucer는 XHTML/XML 문서를 PDF로 쉽게 변환할 수 있는 오픈 소스 Java 라이브러리입니다. PDF 생성을 위해 강력한 iText 라이브러리를 내부적으로 활용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Maven 종속성 설정\n\n```java\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.xhtmlrenderer\u003c/groupId\u003e\n    \u003cartifactId\u003eflying-saucer-core\u003c/artifactId\u003e\n    \u003cversion\u003e9.1.22\u003c/version\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.xhtmlrenderer\u003c/groupId\u003e\n    \u003cartifactId\u003eflying-saucer-pdf\u003c/artifactId\u003e\n    \u003cversion\u003e9.1.22\u003c/version\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.xhtmlrenderer\u003c/groupId\u003e\n    \u003cartifactId\u003eflying-saucer-pdf-openpdf\u003c/artifactId\u003e\n    \u003cversion\u003e9.1.20\u003c/version\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.jsoup\u003c/groupId\u003e\n    \u003cartifactId\u003ejsoup\u003c/artifactId\u003e\n    \u003cversion\u003e1.13.1\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n이러한 종속성에는 핵심 Flying Saucer 라이브러리, PDF 렌더링 기능, OpenPDF를 사용한 Flying Saucer PDF 구현, 그리고 HTML 파싱을 위한 Jsoup 라이브러리가 포함되어 있습니다.\n\n# HTML을 PDF로 변환하기 - Java 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 자바 코드를 살펴봅시다:\n\n```js\nimport java.io.FileOutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.xhtmlrenderer.pdf.ITextRenderer;\n\npublic class PdfGenerator {\n\n    private static String htmlToXhtml(String html) {\n        // Convert HTML to XHTML\n        Document document = Jsoup.parse(html);\n        document.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n        return document.html();\n    }\n\n    public static void main(String[] args) {\n        String inputFile = \"appointment_letter.html\"; // XHTML/XML 파일 경로\n        String outputFile = \"output.pdf\"; // 출력 PDF 파일 경로\n\n        try {\n            // ITextRenderer 인스턴스 생성\n            ITextRenderer renderer = new ITextRenderer();\n\n            // 파일에서 HTML 콘텐츠 읽기\n            String content = FileUtils.readFileToString(Paths.get(inputFile).toFile(), StandardCharsets.UTF_8);\n\n            // 치환 작업 수행\n            Map\u003cString, String\u003e valueMap = new HashMap\u003c\u003e();\n            valueMap.put(\"employeeId\", \"20240200001\");\n            valueMap.put(\"employeeName\", \"Harish Jay Raj\");\n            valueMap.put(\"startDate\", \"25-03-2024\");\n\n            Set\u003cEntry\u003cString, String\u003e\u003e entrySet = valueMap.entrySet();\n            for (Entry\u003cString, String\u003e es : entrySet) {\n                content = content.replace(\"@{\" + es.getKey() + \"}\", es.getValue());\n            }\n\n            // HTML을 XHTML로 변환\n            String htmlToXhtml = PdfGenerator.htmlToXhtml(content);\n            renderer.setDocumentFromString(htmlToXhtml);\n\n            // 문서를 PDF로 렌더링\n            renderer.layout();\n            FileOutputStream fos = new FileOutputStream(outputFile);\n            renderer.createPDF(fos);\n            fos.close();\n\n            System.out.println(\"PDF 생성 성공!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 코드 이해\n\n- Flying Saucer의 ITextRenderer 클래스를 사용하여 HTML 콘텐츠를 PDF로 렌더링합니다.\n- HTML 콘텐츠는 파일(appointment_letter.html)에서 읽혀서 문자열로 저장됩니다.\n- Map을 사용하여 동적 콘텐츠 치환을 수행합니다. 예를 들어 '@employeeId'나 '@employeeName'과 같은 플레이스홀더를 실제 값으로 대체합니다.\n- HTML 콘텐츠를 Flying Saucer와 호환성을 위해 Jsoup 라이브러리를 사용하여 XHTML로 변환합니다. 마지막으로, XHTML 콘텐츠를 PDF로 렌더링하여 지정된 출력 파일(output.pdf)에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003e임명서\u003c/title\u003e\n    \u003cstyle\u003e\n        body {\n            font-family: Arial, sans-serif;\n        }\n\n        .letter {\n            max-width: 600px;\n            margin: 0 auto;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .header {\n            text-align: center;\n            margin-bottom: 20px;\n        }\n\n        .employee-info {\n            margin-bottom: 20px;\n        }\n\n        .closing {\n            margin-top: 20px;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv class=\"letter\"\u003e\n        \u003cdiv class=\"header\"\u003e\n            \u003ch2\u003e임명서\u003c/h2\u003e\n        \u003c/div\u003e\n\n        \u003cp\u003e\n            친애하는 \u003cspan id=\"employeeName\"\u003e@{employeeName}\u003c/span\u003e님,\n        \u003c/p\u003e\n\n        \u003cp\u003e\n            당신이 XYZ 회사의 직원으로 임명되었음을 기쁘게 알려드립니다. 당신의 헌신과 기술이 아래 세부 사항을 통해 당신에게 이 직책을 얻게 했습니다.\n        \u003c/p\u003e\n\n        \u003cdiv class=\"employee-info\"\u003e\n            \u003cp\u003e\u003cstrong\u003e직원 ID:\u003c/strong\u003e \u003cspan id=\"employeeId\"\u003e@{employeeId}\u003c/span\u003e\u003c/p\u003e\n        \u003c/div\u003e\n\n        \u003cp\u003e\n            XYZ 회사와의 근무는 \u003cspan id=\"startDate\"\u003e@{startDate}\u003c/span\u003e에 시작될 것입니다. 입사일에 인사부서에 보고하여 추가 방향과 절차에 대해 안내받으시기 바랍니다.\n        \u003c/p\u003e\n\n        \u003cp\u003e\n            여러분의 전문 지식이 팀에 크게 기여할 것이라 믿으며, 소중한 공헌을 기대하고 있습니다.\n        \u003c/p\u003e\n\n        \u003cdiv class=\"closing\"\u003e\n            \u003cp\u003e감사합니다,\u003c/p\u003e\n            \u003cp\u003eXYZ 회사 팀\u003c/p\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 튜토리얼에서는 Flying Saucer 라이브러리를 사용하여 Java로 HTML 파일을 PDF 문서로 변환하는 방법을 알아보았습니다. 이 접근 방식을 통해 HTML 내용을 프로그래밍 방식으로 PDF 문서로 생성할 수 있는 유연성과 사용자 정의 옵션이 제공됩니다. 제공된 단계와 코드 스니펫을 따라하면 Java 애플리케이션에 쉽게 HTML을 PDF로 변환하는 기능을 통합할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png"},"coverImage":"/assets/img/2024-06-20-ConvertingHTMLtoPDFinJavaUsingFlyingSaucer_0.png","tag":["Tech"],"readingTime":6},{"title":"HTML5 캔버스를 사용하여 픽셀 완벽한 그래픽 만들기 방법","description":"","date":"2024-06-20 06:07","slug":"2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas","content":"\n\n진짜 8비트 시각을 위한 캔버스 그래픽 마스터링 단계별 안내서입니다.\n\n이 포스트에서는 픽셀 완벽한 웹 게임을 만들기 위한 기반을 구축할 것입니다. \"픽셀 완벽\"이란 모든 픽셀이 선명하고 흐릿하지 않다는 것을 의미합니다. 이 자습서를 완료하면 픽셀화된 별 배경 위에 두 개의 이동하는 직사각형을 애니메이션하는 단일 HTML 파일이 생깁니다.\n\n다음 세 단계로 진행하겠습니다:\n\n1. 캔버스가 올바르게 크기 조정되는 기본 HTML 구조 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직사각형과 별을 그려보세요\n\n# 이미지 흐림 방지, 모든 픽셀을 선명하게 설정\n\n# 크기 조절 가능한 캔버스\n\n한 가지 HTML5 캔버스를 가진 간단한 HTML 페이지를 만들 것입니다. 이 캔버스는 브라우저 창 크기가 변경될 때 동적으로 크기가 조정됩니다. 정수 스케일링 상수를 사용하여 스케일링이 균일한 픽셀 크기를 유지하는지 제어할 수 있습니다. 정수 스케일링을 true로 설정하면 모든 픽셀이 동일한 크기를 유지합니다. 단점은 정수 스케일링으로 인해 일부 브라우저 창 크기에 따라 캔버스 주변에 더 큰 테두리가 생길 수 있다는 점입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n    \u003ctitle\u003e빈 크기 조절 캔버스\u003c/title\u003e\n    \u003cstyle\u003e\n      html,\n      body {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100%;\n        margin: 0;\n        background-color: #887ecb;\n      }\n    \n      .canvas-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 100%;\n        height: 100%;\n      }\n\n      #gameCanvas {\n        background-color: #50459b;\n        max-width: 100%;\n        max-height: 100%;\n      }\n    \u003c/style\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cdiv class=\"canvas-container\"\u003e\n      \u003ccanvas id=\"gameCanvas\" width=\"64\" height=\"36\"\u003e\u003c/canvas\u003e\n    \u003c/div\u003e\n    \u003cscript\u003e\n      const INTEGER_SCALING = true;\n\n      const canvas = document.getElementById(\"gameCanvas\");\n\n      function resizeCanvas() {\n        let scale = Math.min(\n          window.innerWidth / canvas.width,\n          window.innerHeight / canvas.height\n        );\n        if (INTEGER_SCALING) {\n          scale = Math.floor(scale);\n        }\n        canvas.style.width = `${Math.round(scale * canvas.width)}px`;\n        canvas.style.height = `${Math.round(scale * canvas.height)}px`;\n      }\n\n      resizeCanvas();\n      window.addEventListener(\"resize\", resizeCanvas);\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n위 코드의 주요 포인트는 크기 조절 이벤트에 등록하고 이벤트가 발생할 때마다 페이지의 캔버스 크기를 변경하는 것입니다. 스케일은 내부 캔버스 크기가 화면에 가장 적은 수의 배에 맞도록 계산됩니다. 이는 다른 방향으로 테두리를 유발할 수 있지만 내부 캔버스 크기의 종횡비를 유지합니다.\n\n창의 크기를 조정하면 캔버스 크기가 변경되는 것을 확인할 수 있습니다. 또한 INTEGER_SCALING 값을 false로 변경하여 캔버스가 항상 창을 가로 또는 세로로 채우는 방법을 확인해보세요.\n\n# 캔버스에 그리기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스에 그리기 위해서는 먼저 캔버스의 컨텍스트를 가져와야 합니다. 투명한 픽셀을 남기지 않을 것이기 때문에 알파값을 false로 설정합니다.\n\n```js\nconst canvas = document.getElementById(\"gameCanvas\");\nconst ctx = canvas.getContext(\"2d\", { alpha: false });\n```\n\n간단하게 유지하기 위해 이 게시물에서는 사각형만 그릴 것입니다.\n\n```js\nfunction drawRectangle(x, y, width, height, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, width, height);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 우리는 배경을 위해 200개의 별을 만듭니다. 별은 색에 따라 정렬되어 있으므로 덜 밝은 별이 더 밝은 별 위에 그려지지 않습니다.\n\n```js\nfunction createStar() {\n  const color = Math.floor(Math.random() * 256);\n  return {\n    x: Math.random() * canvas.width,\n    y: Math.random() * canvas.height,\n    color: color,\n    fillStyle: `rgb(${color}, ${color}, ${color})`,\n  }; \n}\n\nconst stars = Array.from({ length: 200 }, createStar).sort(\n  (a, b) =\u003e a.color - b.color\n);\n```\n\n우리는 requestAnimationFrame을 사용하여 게임 루프가 필요한 매 프레임마다 발생하도록 만듭니다. gameLoop이 호출될 속도는 \"일반적으로 디스플레이 새로고침 속도와 일치\"합니다. 많은 경우에 초당 60프레임인 경우가 많지만 다를 수도 있습니다. `now` 매개변수는 이전 프레임 렌더링의 밀리초를 나타냅니다. 애니메이션 중에 이 시간을 사용하는 것이 중요하며 일정한 프레임 속도를 가정하는 대신 해당 시간을 사용해야 합니다.\n\n```js\nfunction gameLoop(now) {\n  draw(now);\n  requestAnimationFrame(gameLoop);\n}\ngameLoop();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 재미있는 부분이 시작됩니다 — 캔버스에 그림을 그리는 것! 이전 프레임의 그래픽을 지우기 위해 캔버스를 지우는 것으로 시작합니다. 그런 다음, 모든 별과 두 개의 사각형을 그리는데, 이는 일정한 사인 및 코사인 패턴에 따라 움직입니다.\n\n```js\nfunction draw(t) {\n  drawRectangle(0, 0, canvas.width, canvas.height, \"#000\");\n\n  stars.forEach((star) =\u003e {\n    drawRectangle(star.x, star.y, 1, 1, star.fillStyle);\n    star.x = (star.x - star.color / 5000 + canvas.width) % canvas.width;\n  });\n  drawRectangle(\n    canvas.width / 4,\n    canvas.height / 4 + (canvas.width / 10) * Math.sin(t / 500),\n    canvas.width / 2,\n    canvas.height / 2,\n    \"#008\"\n  );\n  drawRectangle(\n    canvas.width / 2 + (canvas.width / 4) * Math.cos(t / 1000) - 4,\n    canvas.height / 2 + (canvas.height / 4) * Math.sin(t / 1000) - 4,\n    8,\n    8,\n    \"#00c\"\n  );\n}\n```\n\n그리고 이렇게 보입니다.\n\n이 코드펜에서 실행 중인 애니메이션을 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 많이 8-bit스럽지 않네요, 맞죠? 우리가 마주한 두 가지 문제는 스케일링할 때 픽셀 보간과 그릴 때 안티앨리어싱입니다.\n\n# Unblur\n\n## 픽셀 보간 끄기\n\n브라우저는 캔버스를 확대할 때 픽셀을 보간하고 있습니다. 이는 합리적인 표준 동작이지만 픽셀 그래픽에 적합하지 않습니다. 대신 css에서 픽셀화된 스케일링을 사용하도록 브라우저에 지시합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```css\ncanvas {\n  background-color: #50459b;\n  max-width: 100%;\n  max-height: 100%;\n  image-rendering: pixelated;\n}\n```\n\n## 안티앨리어싱 피하기\n\n또 다른 흐림 현상을 일으키는 문제는 정수가 아닌 값을 그릴 때 발생합니다. 별이 픽셀 사이에 위치할 때 브라우저는 일관성있게 만들려고 노력합니다. 해결책은 간단합니다. 우리는 좌표를 모두 정수로 반올림하면 됩니다. 이 해결책을 drawRectangle 함수에 넣어서 어디서든 무언가를 그릴 때마다 생각할 필요가 없게 만듭니다:\n\n```js\nfunction drawRectangle(x, y, width, height, color) {\n  ctx.fillStyle = color;\n  ctx.fillRect(\n    Math.round(x),\n    Math.round(y),\n    Math.round(width),\n    Math.round(height)\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 정리된 버전에 대한 코드펜입니다:\n\n여기 정리된 버전에 대한 전체 소스입니다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n    \u003ctitle\u003ePixel perfect canvas\u003c/title\u003e\n    \u003cstyle\u003e\n      html,\n      body {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: 100%;\n        margin: 0;\n        background-color: #887ecb;\n      }\n\n      .canvas-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 100%;\n        height: 100%;\n      }\n\n      canvas {\n        background-color: #50459b;\n        max-width: 100%;\n        max-height: 100%;\n        image-rendering: pixelated;\n      }\n    \u003c/style\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cdiv class=\"canvas-container\"\u003e\n      \u003ccanvas id=\"gameCanvas\" width=\"64\" height=\"36\"\u003e\u003c/canvas\u003e\n    \u003c/div\u003e\n    \u003cscript\u003e\n      const INTEGER_SCALING = true;\n\n      const canvas = document.getElementById(\"gameCanvas\");\n      const ctx = canvas.getContext(\"2d\");\n\n      function createStar() {\n        const color = Math.floor(Math.random() * 256);\n        return {\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          color: color,\n          fillStyle: `rgb(${color}, ${color}, ${color})`,\n        };\n      }\n\n      const stars = Array.from({ length: 200 }, createStar).sort(\n        (a, b) =\u003e a.color - b.color\n      );\n\n      function resizeCanvas() {\n        let scale = Math.min(\n          window.innerWidth / canvas.width,\n          window.innerHeight / canvas.height\n        );\n        if (INTEGER_SCALING) {\n          scale = Math.floor(scale);\n        }\n        canvas.style.width = `${Math.round(scale * canvas.width)}px`;\n        canvas.style.height = `${Math.round(scale * canvas.height)}px`;\n      }\n\n      function drawRectangle(x, y, width, height, color) {\n        ctx.fillStyle = color;\n        ctx.fillRect(\n          Math.round(x),\n          Math.round(y),\n          Math.round(width),\n          Math.round(height)\n        );\n      }\n\n      function gameLoop(now) {\n        draw(now);\n        requestAnimationFrame(gameLoop);\n      }\n\n      function draw(t) {\n        drawRectangle(0, 0, canvas.width, canvas.height, \"#000\");\n\n        stars.forEach((star) =\u003e {\n          drawRectangle(star.x, star.y, 1, 1, star.fillStyle);\n          star.x = (star.x - star.color / 5000 + canvas.width) % canvas.width;\n        });\n        drawRectangle(\n          canvas.width / 4,\n          canvas.height / 4 + (canvas.width / 10) * Math.sin(t / 500),\n          canvas.width / 2,\n          canvas.height / 2,\n          \"#008\"\n        );\n        drawRectangle(\n          canvas.width / 2 + (canvas.width / 4) * Math.cos(t / 1000) - 4,\n          canvas.height / 2 + (canvas.height / 4) * Math.sin(t / 1000) - 4,\n          8,\n          8,\n          \"#00c\"\n        );\n      }\n\n      resizeCanvas();\n      window.addEventListener(\"resize\", resizeCanvas);\n      gameLoop();\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 기초가 마련되었습니다 - 브라우저에서 픽셀 완벽한 그래픽을 애니메이트할 수 있는 코드 조각이 있습니다! 다음에는 몇 가지 스프라이트를 애니메이션화할 것입니다!","ogImage":{"url":"/assets/img/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoCreatePixelPerfectGraphicsUsingHTML5Canvas_0.png","tag":["Tech"],"readingTime":9}],"page":"31","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"31"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>