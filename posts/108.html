<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/108" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/108" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기" href="/post/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서의 디자인 패턴" href="/post/2024-05-14-DesignPatternsinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서의 디자인 패턴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DesignPatternsinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서의 디자인 패턴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서의 디자인 패턴</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 17의 새로운 기능들" href="/post/2024-05-14-WhatsNewinAngular17"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 17의 새로운 기능들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WhatsNewinAngular17_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 17의 새로운 기능들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 17의 새로운 기능들</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법" href="/post/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법" href="/post/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다" href="/post/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요" href="/post/2024-05-14-IsNextjsaFrontendorBackendFramework"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입 생성 비밀 탐구 in TypeScript" href="/post/2024-05-14-SecretsofTypeGenerationinTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입 생성 비밀 탐구 in TypeScript" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입 생성 비밀 탐구 in TypeScript" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입 생성 비밀 탐구 in TypeScript</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript" href="/post/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC에서 Apex 메소드 사용하기" href="/post/2024-05-14-WorkWithApexMethodInLWC"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC에서 Apex 메소드 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC에서 Apex 메소드 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC에서 Apex 메소드 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link posts_-active__YVJEi" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JavaScript에서 내장 함수를 사용하지 않고 비동기 작업을 병렬로 실행하기","description":"","date":"2024-05-14 13:59","slug":"2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript","content":"\n\n![Excute Asynchronous Tasks in Parallel without Using Built-in Functions in JavaScript](/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png)\n\n비동기 작업은 데이터베이스에서 데이터를 가져오거나 네트워크 요청을 만들거나 파일에서 읽는 등 외부 이벤트를 기다리는 작업이 포함된 상황에서 특히 흔히 발생합니다.\n\n이러한 작업이 완료될 때까지 전체 프로그램을 멈추지 않고 비동기 작업은 서로 독립적으로 실행되며 서로 다른 시간에 완료될 수 있으므로 효율성과 반응성이 향상됩니다.\n\n비동기 병렬 실행을 통해 작업을 동시에 실행할 수 있으므로 하드웨어의 기능(예: 다중 CPU 코어)을 활용할 수 있습니다. 이는 시스템 자원을 더 효율적으로 사용하고 작업을 빠르게 완료할 수 있게 합니다. 예: 일괄 처리, 웹 서버 요청의 동시 실행.\n\n\n\n자바스크립트는 Promise.all()이나 Promise.race()와 같은 내장 함수를 제공하여 비동기 병렬 실행을 달성할 수 있습니다. 이러한 내장 함수들은 간단한 경우에 편리하지만, 더 복잡한 시나리오를 위해 자체 병렬 비동기 함수를 사용하면 더 많은 제어, 유연성 및 최적화 가능성을 제공할 수 있습니다.\n\n동일한 작업을 Promises를 사용하여 수행하기 위해 사용자 지정 함수를 작성하는 샘플 예제를 찾아보세요.\n\n```js\nconst executeParallel = (tasks) =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const results = []; // 작업의 결과를 저장합니다\n    let completedCount = 0; // 완료된 작업을 추적합니다\n\n    const handleResolve = (result, index) =\u003e {\n      results[index] = result;\n      completedCount++;\n      if (completedCount === tasks.length) {\n        resolve(results);\n      }\n    };\n\n    const handleReject = (error) =\u003e {\n      reject(error);\n    };\n\n    tasks.forEach((task, index) =\u003e {\n      task()\n        .then((result) =\u003e {\n          // 모든 작업이 완료되면 주 Promise를 해결합니다\n          handleResolve(result, index);\n        })\n        .catch((error) =\u003e {\n          handleReject(error); // 작업 중 하나라도 실패할 경우 Promise를 거부합니다\n        });\n    });\n  });\n};\n\n// 예제 작업\nconst task1 = () =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e {\n      resolve('작업 1 완료');\n    }, 200);\n  });\n};\n\nconst task2 = () =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e {\n      resolve('작업 2');\n    }, 10);\n  });\n};\n\nconst task3 = () =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e {\n      resolve('105');\n    }, 50);\n  });\n};\n\nexecuteParallel([task1, task2, task3])\n  .then((results) =\u003e {\n    console.log('모든 작업 완료:', results);\n  })\n  .catch((error) =\u003e {\n    console.error('에러:', error);\n  });\n```\n\n위 구현에서:\n\n\n\n- executeParallel() 함수는 각각이 Promise를 반환하는 함수인 작업 배열을 가져옵니다.\n- executeParallel() 내에서 모든 작업의 완료를 추적하는 주요 Promise가 생성됩니다.\n- 각 작업은 Promise.resolve(task())를 사용하여 비동기적으로 실행됩니다.\n- 작업이 완료되면 그 결과가 배열에 저장되고 completedCount가 증가합니다.\n- 작업 중에 오류가 발생하면 주요 Promise는 해당 오류로 거부됩니다.\n- 모든 작업이 완료되면 주요 Promise는 결과 배열로 해결됩니다.\n\n이 블로그가 도움이 되고 통찰력을 줬기를 바랍니다. 읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-Executeasynchronoustasksinparallelwithoutusingbuilt-infunctionsinJavaScript_0.png","tag":["Tech"],"readingTime":3},{"title":"Nodejs에서의 디자인 패턴","description":"","date":"2024-05-14 13:57","slug":"2024-05-14-DesignPatternsinNodejs","content":"\n\nNode.js는 이벤트 주도, 비차단 I/O 모델을 사용하여 확장 가능한 네트워크 애플리케이션을 개발할 수 있는 인기 있는 JavaScript 런타임입니다. 다양한 디자인 패턴을 사용하면 코드 재사용, 유지 관리성 및 견고성을 증진시킬 수 있습니다. 이 기사에서는 Node.js 개발에 가장 유용한 디자인 패턴 중 일부를 개요하겠습니다.\n\n![](/assets/img/2024-05-14-DesignPatternsinNodejs_0.png)\n\n## 디자인 패턴 소개\n\n디자인 패턴은 소프트웨어 개발자가 코딩하는 동안 반복적으로 마주치는 문제에 대한 검증된 해결책입니다. 이는 도전적인 과제를 해결하는 구조화된 방법을 제공하며 소프트웨어 아키텍처에서 최상의 실천법을 촉진합니다. 디자인 패턴을 통합함으로써, 개발자는 더 견고하고 유지보수 가능하며 확장 가능한 코드베이스를 작성할 수 있습니다.\n\n\n\n## 왜 Node.js에서 디자인 패턴이 중요한 이유\n\nNode.js는 비차단 이벤트 주도 구조로 알려져 있어 소프트웨어 디자인에서 독특한 도전과 기회를 제공합니다. Node.js에 맞는 디자인 패턴을 적용하면 더 효율적이고 최적화된 애플리케이션을 개발할 수 있습니다. Node.js 생태계에서 특히 가치 있는 몇 가지 주요 디자인 패턴을 살펴보겠습니다:\n\n## 싱글톤 패턴\n\n싱글톤 패턴은 클래스가 하나의 인스턴스만 가지며 그에 대한 전역 액세스 지점을 제공하는 것을 보장합니다. Node.js에서 모듈이 캐시되고 애플리케이션 전체에서 공유될 수 있는 환경에서, 싱글톤 패턴을 사용하여 리소스를 효율적으로 관리할 수 있습니다. 예를 들어, 데이터베이스 연결 풀을 싱글톤으로 구현하여 자원 낭비를 방지할 수 있습니다.\n\n\n\n```js\nclass Database {\n  constructor() {\n    this.connection = null;\n  }\n  \n  static getInstance() {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance; \n  }\n\n  connect() {\n    // connect to database\n    this.connection = 'Connected'; \n  }\n}\n\nconst db1 = Database.getInstance();\nconst db2 = Database.getInstance();\n\nconsole.log(db1 === db2); // true\n\ndb1.connect(); \n\nconsole.log(db1.connection); // 'Connected'\nconsole.log(db2.connection); // 'Connected'\n```\n\n중요한 점은:\n\n- 생성자는 직접 인스턴스화를 방지하기 위해 비공개로 만들었습니다.\n- 정적 메소드 getInstance()는 인스턴스가 아직 존재하지 않는 경우 인스턴스를 만들고 반환합니다. 이렇게 하면 하나의 인스턴스만 생성됩니다.\n- db1과 db2 인스턴스는 동일한 객체를 가리킵니다.\n- db1이 연결하면 동일한 객체이기 때문에 db2도 연결을 받습니다.\n\n이를 통해 하나의 데이터베이스 인스턴스만 있고 중복 연결을 방지할 수 있습니다. 싱글톤 패턴은 클래스의 하나의 인스턴스만 존재해야 하는 상황에 유용합니다.\n\n\n\n\n## 팩토리 패턴\n\n팩토리 패턴은 생성될 객체의 정확한 클래스를 지정하지 않고 객체를 생성하는 방법을 제공합니다. Node.js에서는 파일을 읽거나 API 호출과 같은 비동기 작업을 다룰 때 객체 생성을 간소화할 수 있습니다. 팩토리 패턴은 객체 생성을 추상화함으로써 코드의 가독성과 재사용성을 향상시킵니다.\n\n```js\nclass Car {\n  constructor(model, price) {\n    this.model = model;\n    this.price = price;\n  }\n}\n\nclass CarFactory {\n  createCar(model) {\n    switch(model) {\n      case 'civic':\n        return new Car('Honda Civic', 20000);\n      case 'accord':  \n        return new Car('Honda Accord', 25000);\n      case 'odyssey':\n        return new Car('Honda Odyssey', 30000);\n      default:\n        throw new Error('Unknown model');\n    }\n  }\n}\n\nconst factory = new CarFactory();\n\nconst civic = factory.createCar('civic');\nconst accord = factory.createCar('accord');\n\nconsole.log(civic.model); // Honda Civic \nconsole.log(accord.model); // Honda Accord\n```\n\n주요 포인트는:\n\n\n\n- CarFactory 클래스는 객체 생성 로직을 처리합니다.\n- createCar() 메서드는 모델을 기반으로 Car 인스턴스를 반환합니다.\n- 클라이언트 코드는 직접 생성자 호출 대신 팩토리를 사용합니다.\n\n이는 객체 생성 로직을 추상화하여 지원되는 모델을 쉽게 확장할 수 있게 합니다. 팩토리 패턴은 복잡한 객체 생성 로직이 클라이언트 코드에 결합되지 말아야 하는 경우 유용합니다.\n\n## 옵저버 패턴\n\nNode.js의 이벤트 주도 특성은 옵저버 패턴과 잘 맞습니다. 이 패턴은 의존하는 객체 목록인 옵저버라는 종속 항목 목록을 유지하는 주제를 포함하며 상태 변경 시 이들에게 알립니다. Node.js의 맥락에서는 이를 활용하여 실시간 애플리케이션 및 채팅 애플리케이션과 같은 이벤트 주도 시스템을 구축할 수 있습니다.\n\n\n\n```js\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n    this.observers = this.observers.filter(o =\u003e o !== observer);\n  }\n\n  notify(data) {\n    this.observers.forEach(o =\u003e o.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n\n  update(data) {\n    console.log(`${this.name} received ${data}`);\n  }\n}\n\nconst subject = new Subject();\n\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello World');\n// Observer 1 received Hello World\n// Observer 2 received Hello World\n\nsubject.unsubscribe(observer2);\n\nsubject.notify('Hello Again');\n// Observer 1 received Hello Again\n```\n\n주요 포인트는:\n\n- Subject는 관찰자 목록을 유지합니다.\n- 관찰자들은 주제에 구독하고 구독을 취소합니다.\n- notify()가 호출되면 주제는 구독된 관찰자들을 모두 업데이트합니다.\n\n이를 통해 발행자를 구독자에 결합하지 않고 여러 개체에 업데이트를 발행할 수 있습니다. Observer 패턴은 이벤트 처리와 비동기적인 워크플로에 유용합니다.\n\n\n\n\n## 미들웨어 패턴\n\nNode.js의 미들웨어 아키텍처는 웹 애플리케이션에서 요청과 응답을 처리하는 데 널리 사용됩니다. 미들웨어 패턴은 요청을 순차적으로 처리하는 함수 체인을 포함합니다. 각 함수는 요청이나 응답을 수정한 다음 체인 내의 다음 함수로 전달할 수 있습니다. 이 패턴은 모듈성을 향상시키며, 각기 다른 기능을 완벽하게 결합하지 않고도 개발자가 다양한 기능을 확장할 수 있도록 합니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\nconst logger = (req, res, next) =\u003e {\n  console.log('Logged');\n  next();\n}\n\nconst authenticate = (req, res, next) =\u003e {\n  // 사용자 인증\n  next();\n}\n\napp.use(logger); \napp.use(authenticate);\n\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World');\n});\n\napp.listen(3000);\n```\n\n주요 포인트는:\n\n\n\n- 미들웨어 함수 logger와 authenticate는 라우트 핸들러를 감싸고 있어요.\n- 라우트 전후에 로직을 실행할 수 있어요.\n- next() 함수는 다음 미들웨어로 제어를 전달해요.\n- app.use()는 미들웨어를 전역으로 적용해요.\n\n이를 통해 요청 처리를 작은 재사용 가능한 단위로 분해할 수 있어요. 미들웨어 패턴은 Express 및 다른 Node.js 프레임워크에서 로깅, 인증 등과 같은 작업에서 매우 일반적으로 사용돼요.\n\n다른 미들웨어의 예시로는 body parsers, 압축, 속도 제한 등이 있어요. 이 패턴을 통해 모듈화된 방식으로 요청 파이프라인을 구축할 수 있어요.\n\n## 모듈 패턴\n\n\n\n모듈 패턴은 Node.js에서 가장 기본적이면서도 근본적인 패턴 중 하나입니다. 이 패턴을 사용하면 코드를 특정 기능을 캡슐화하는 별도의 파일 또는 모듈로 구성할 수 있습니다.\n\n```js\n// counter.js\n\nlet count = 0;\n\nconst increment = () =\u003e {\n  count++;\n}\n\nconst decrement = () =\u003e {\n  count--;\n}\n\nconst get = () =\u003e {\n  return count; \n}\n\nmodule.exports = {\n  increment,\n  decrement,\n  get  \n};\n\n// app.js\n\nconst counter = require('./counter');\n\ncounter.increment();\ncounter.increment();\n\nconsole.log(counter.get()); // 2\n\ncounter.decrement();\n\nconsole.log(counter.get()); // 1\n```\n\n중요한 포인트는:\n\n- counter.js 모듈은 private 변수인 count에 작용하는 함수들을 내보냅니다.\n- 함수들은 모듈 내부에서 로직과 데이터를 캡슐화합니다.\n- app.js는 모듈을 가져와 공개 API를 사용합니다.\n\n\n\n이 패턴은 데이터 캡슐화를 제공하며 오직 공개 API만 노출합니다. 모듈 패턴은 코드를 재사용 가능하고 이식 가능한 모듈로 구성하는 데 Node.js에서 매우 일반적으로 사용됩니다.\n\n다른 예시로는 미들웨어 모듈, 유틸리티 라이브러리, 데이터 접근 계층 등이 있습니다. 이 패턴은 의존성 관리와 구현 세부 정보 숨기기에 도움이 됩니다.\n\n## 데코레이터 패턴\n\n데코레이터는 다른 인스턴스에 영향을 주지 않으면서 객체에 새로운 기능을 동적으로 추가합니다. 이는 Node의 핵심 모듈을 확장하는 데 이상적입니다.\n\n\n\n```js\nclass Car {\n  constructor() {\n    this.price = 10000;\n  }\n\n  getPrice() {\n    return this.price;\n  }\n}\n\nclass CarOptions {\n  constructor(car) {\n    this.car = car;\n  }\n\n  addGPS() {\n    this.car.price += 500;\n  }\n  \n  addRims() {\n    this.car.price += 300; \n  }\n}\n\nconst basicCar = new Car();\n\nconsole.log(basicCar.getPrice()); // 10000\n\nconst carWithOptions = new CarOptions(basicCar);\n\ncarWithOptions.addGPS();\ncarWithOptions.addRims();\n\nconsole.log(carWithOptions.car.getPrice()); // 10800\n```\n\n주요 포인트:\n\n- CarOptions는 Car 클래스를 래핑하고 그 동작을 확장합니다.\n- addGPS()와 같은 메서드는 래핑된 Car의 상태를 수정합니다. \n- 클라이언트는 추가 기능이 있는 Car의 장식된 인스턴스를 갖게 됩니다.\n\n이는 실행 중에 동적으로 동작을 확장할 수 있도록 해줍니다. 데코레이터 패턴은 추상화에 유용하며 작은 기능을 추가하기 위해 서브클래스를 만들 필요가 없습니다.\n\n\n\n\n일부 다른 예시로는 인증된 경로, 로깅 래퍼, 캐싱 데코레이터 등이 있습니다. 이 패턴은 Node.js 애플리케이션에서 개방/폐쇄 원칙을 준수하는 유연한 방법을 제공합니다.\n\n## 의존성 주입 패턴\n\n의존성 주입은 모듈이나 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받는 패턴입니다. 이는 간결함, 테스트 용이성, 재사용성을 촉진하는 데 도움이 됩니다.\n\n```js\n// service.js\nclass Service {\n  constructor(db, logger) {\n    this.db = db;\n    this.logger = logger;\n  }\n\n  async getUser(userId) {\n    const user = await this.db.findUserById(userId);\n    this.logger.log(`사용자 ${user.name}을(를) 가져왔습니다.`);\n    return user;\n  }\n}\n\n// app.js\nconst Database = require('./database'); \nconst Logger = require('./logger');\n\nconst db = new Database();\nconst logger = new Logger();\n\nconst service = new Service(db, logger);\n\nservice.getUser(1);\n```\n\n\n\n주요 포인트는 다음과 같아요:\n\n- Service 클래스는 생성자를 통해 의존성을 선언합니다.\n- 호출 코드는 실제 의존성인 db와 logger를 주입합니다.\n- 이를 통해 Service와 구체적인 의존성이 결합이 해제됩니다.\n\n장점:\n\n- 모듈 간의 느슨한 결합\n- 의존성을 모의(mock)화하여 쉬운 테스트\n- 구현체 교체 가능합니다.\n\n\n\n의존성 주입 패턴은 NestJS와 같은 Node.js 프레임워크에서 일반적으로 사용됩니다. 이 패턴을 사용하면 코드 조직화와 재사용성을 더 효율적으로 할 수 있습니다.\n\n## Promise 패턴\n\nPromise는 Node.js에서 비동기 프로그래밍을 위한 패턴입니다. 이들은 비동기 작업의 최종 결과를 나타냅니다. 다음은 간단한 예제입니다:\n\n```js\nconst fetchData = new Promise((resolve, reject) =\u003e {\n  // 비동기 작업\n  const data = getDataFromDatabase();\n  \n  if (data) {\n    resolve(data); \n  } else {  \n    reject('데이터 가져오기 오류');\n  }\n});\n\nfetchData\n  .then(data =\u003e {\n    // 성공적인 데이터 처리\n  })\n  .catch(err =\u003e {\n    // 에러 처리  \n  });\n```\n\n\n\n주요 측면은 다음과 같습니다:\n\n- Promise는 resolve 및 reject 함수가 포함된 콜백을 사용합니다.\n- 비동기 작업은 콜백 내에서 시작됩니다.\n- resolve(data)는 성공 시 데이터를 반환합니다.\n- reject(error)는 실패 시 오류를 반환합니다.\n- 소비자들은 .then() 및 .catch()를 사용하여 결과를 얻습니다.\n\n장점:\n\n- 비동기 코드에서 콜백 지옥을 피할 수 있습니다.\n- 비동기 결과를 처리하는 표준화된 방법\n- Promise를 연결하고 조합할 수 있는 능력\n\n\n\n약속은 현대 Node.js 개발에 불가결하며, 깔끔한 비동기 코드 작성을 가능하게 합니다. axios와 같은 라이브러리, fs.promises와 같은 코어 API를 구동합니다.\n\n## 디자인 패턴 구현\n\nNode.js의 강점과 일치하는 주요 디자인 패턴을 탐색했으니, 효과적으로 구현하는 방법에 대해 자세히 알아봅시다:\n\n## 1. 컨텍스트 이해\n\n\n\n디자인 패턴을 적용하기 전에는 애플리케이션의 맥락을 이해하는 것이 중요합니다. 애플리케이션의 요구 사항, 확장 가능성 요구 사항 및 해결하려는 특정 문제 등을 고려해야 합니다. 디자인 패턴은 일반적인 해결책이 아니며, 프로젝트의 독특한 특성에 맞추어야 합니다.\n\n## 2. 모듈화\n\nNode.js는 모듈 시스템을 통해 모듈화를 촉진합니다. 디자인 패턴을 구현할 때에는 모듈을 작고 집중적이며 단일 책임을 부여하는 노력을 해야 합니다. 이렇게 하면 코드 재사용성과 유지보수성이 증가하며, 전체 애플리케이션에 영향을 미치지 않고 특정 기능을 교체하거나 향상시키기가 더 쉬워집니다.\n\n## 3. 비동기 패턴\n\n\n\nNode.js의 비동기적인 성격을 고려할 때, 비동기 프로그래밍 패러다임에 부합하는 디자인 패턴을 선택하는 것이 중요합니다. 옵저버 패턴과 미들웨어 패턴과 같은 패턴들은 자연스럽게 비동기 환경에 잘 맞아 이벤트 및 비동기 작업을 손쉽게 처리할 수 있게 해줍니다.\n\n## 결론\n\n디자인 패턴을 활용하면 Node.js 개발자들은 조직화되고 유연하며 견고한 코드를 작성할 수 있습니다. Factory, decorator, singleton과 같은 검증된 패턴을 활용하면 유지보수 및 확장이 쉬운 대규모 애플리케이션을 구축할 수 있습니다. 디자인 원칙을 적용하는 방법을 이해하는 것은 고급 Node 개발을 숙달하기 위한 핵심 요소입니다.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsinNodejs_0.png","tag":["Tech"],"readingTime":10},{"title":"Angular 17의 새로운 기능들","description":"","date":"2024-05-14 13:55","slug":"2024-05-14-WhatsNewinAngular17","content":"\n\n## 웹 개발\n\n![Angular 17](/assets/img/2024-05-14-WhatsNewinAngular17_0.png)\n\n앵귤러 팀이 더 이상 비밀로 간직할 수 없었습니다. 그들은 2023년 11월 8일에 프레임워크의 17번 버전을 공개하기 전 유튜브에서 지난 월요일에 흥미로운 소식을 드렸습니다.\n\n이전 릴리스의 개발자 미리보기에 있던 신호와 독립 컴포넌트와 같은 기능에 추가로, 프레임워크는 시대에 발맞추기 위해 새롭게 변모했습니다. 앵귤러는 이제 새로운 사이트, 최신 문서 및 멋진 새로운 로고를 갖추었습니다! 마치 프레임워크가 새 옷장을 얻은 것 같군요.\n\n\n\n만약 Angular의 최신 릴리스에 열정적이라면, 이 게시물을 놓치고 싶지 않을 거에요. 저와 함께 Angular 게임을 업그레이드할 수 있는 방법에 대해 살펴보세요.\n\n![Angular Latest Release](/assets/img/2024-05-14-WhatsNewinAngular17_1.png)\n\n이번 새 릴리스의 흥미로운 기능 중에는 새로운 템플릿 제어 블록 구문이 있어요. 이것은 더 부드럽고 표현력이 풍부한 코딩을 의미해요!\n\n이제 이야기의 주인공인 'Deferred loading blocks'에 대해 알려드릴게요.\n\n\n\n# 지연 로딩 블록\n\nAngular 17에서는 @defer 컨트롤 블록을 사용하여 콘텐츠를 지연 로딩할 수 있습니다. 컴포넌트, 디렉티브, 파이프를 포함한 의존성에 대해서도 적용됩니다.\n\n그리고 가장 좋은 점은?\n\n지연 가능한 뷰를 통해 현재 사용자 상호작용에 필요한 뷰만 로드할 수 있습니다. 번역하자면, 더 빠른 초기로드 시간과 최적화된 경험을 얻을 수 있습니다. 누가 속도와 효율성을 좋아하지 않겠어요?\n\n\n\n```js\n@defer {\n \u003cdetails-component /\u003e\n} @loading (after 100ms; minimum 1s) {\n \u003cp\u003e Loading… \u003c/p\u003e\n} @error {\n  \u003cp\u003e Failed to load the content ☹️ \u003c/p\u003e\n}\n```\n\n이고르 세도프는 코딩 심장을 뛰게 만들어 줄 비디오에서 예제와 사용 사례 시나리오를 제공했습니다:\n\n# 조건부 렌더링\n\n*ngIf, *ngFor 및 *ngSwitch 지시문에 작별 인사를 전하세요. 이제 더 나은 대안들이 있어서 더 쉬워졌습니다.\n\n\n\n## @switch, @case, @default\n\n@switch, @case, 그리고 @default은 제어 흐름 블록에서 멋진 친구들이에요. 다음 예시를 통해 어떻게 작동하는지 살펴보면서 동적 양식 템플릿에서 추출한 아래 예시를 리팩토링해 보겠습니다:\n\n```js\n\u003cng-container [ngSwitch]=\"formControl.controlType\"\u003e\n  \u003cmat-form-field *ngSwitchCase=\"'dropdown'\"\u003e\n   ...\n  \u003c/mat-form-field\u003e\n  \u003cng-container *ngSwitchCase=\"'slideToggle'\"\u003e\n    \u003cmat-slide-toggle [formControl]=\"formGroup.get(formControl.key)\"\u003e\n     ...\n    \u003c/mat-slide-toggle\u003e\n  \u003c/ng-container\u003e\n  \u003cng-container *ngSwitchCase=\"'checkbox'\"\u003e\n    \u003cmat-checkbox [formControl]=\"formGroup.get(formControl.key)\"\u003e\n     ...\n    \u003c/mat-checkbox\u003e\n  \u003c/ng-container\u003e\n\u003c/ng-container\u003e\n```\n\n위의 코드 대신, @switch 블록에 세 개의 중첩된 블록을 사용할 거에요:\n\n\n\n- @case(`dropdown`) 블록의 내용은 formControl.controlType이 `dropdown`과 같을 때 렌더링됩니다.\n- @case(`slideToggle`) 블록의 내용은 formControl.controlType이 `slideToggle`과 같을 때 렌더링됩니다.\n- @case(`checkbox`) 블록의 내용은 formControl.controlType이 `checkbox`와 같을 때 렌더링됩니다.\n\n```js\n@switch (formControl.controlType) {\n  @case ('dropdown') {\n    \u003cmat-form-field *ngSwitchCase=\"'dropdown'\"\u003e\n     ...\n    \u003c/mat-form-field\u003e\n  }\n  @case ('slideToggle') {\n    \u003cmat-slide-toggle [formControl]=\"formGroup.get(formControl.key)\"\u003e\n      ...\n    \u003c/mat-slide-toggle\u003e\n  }\n  @case ('checkbox') {\n    \u003cmat-checkbox [formControl]=\"formGroup.get(formControl.key)\"\u003e\n     ...\n    \u003c/mat-checkbox\u003e\n  }\n  @default {\n    ...\n  }\n}\n```\n\n새로운 구문으로 코드를 작성하면 매우 가독성이 좋아지고 개발자 경험이 향상됩니다(DX).\n\n## @if, @else, @for, @empty\n\n\n\n@if, @else 및 @for 블록을 사용하면 항목을 조건부로 렌더링하고 컬렉션을 쉽게 처리할 수 있습니다. 이전 구문 대신:\n\n```js\n\u003cng-container *ngIf=\"showAllFields; else customFieldsTemplate\"\u003e\n   \u003cng-container *ngFor=\"let ecsField of ecsFields; trackBy: trackByFn\"\u003e\n      \u003cdiv class=\"mt-2\"\u003e\n        { ecsField.name }\n      \u003c/div\u003e\n  \u003c/ng-container\u003e\n\u003c/ng-container\u003e\n\u003cng-template #customFieldsTemplate\u003e\n  Custom fields template.\n\u003c/ng-template\u003e\n```\n\n다음과 같이 템플릿에 로직을 구현할 수 있습니다:\n\n```js\n@if (showAllFields) {\n  @for (ecsField of ecsFields; track: ecsField.id) {\n    \u003cdiv class=\"mt-2\"\u003e\n      { ecsField.name }\n    \u003c/div\u003e\n  }\n} @else {\n  Custom fields template.\n}\n```\n\n\n\n내장 @for 루프에는 0개의 항목을 포함하는 컬렉션을 위한 선택적인 @empty 블록을 통해 편리한 단축키가 함께 제공됩니다:\n\n```js\n@for (ecsField of ecsFields; track: ecsField.id) {\n  \u003cdiv class=\"mt-2\"\u003e\n    { ecsField.name }\n  \u003c/div\u003e\n} @empty {\n  필드 목록이 비어 있습니다.\n}\n```\n\n# 반복문을 통한 빠른 렌더 속도\n\n자, 이제 속도에 대해 이야기해봅시다.\n\n\n\n*for에서 누락된 trackBy 함수는 성능 문제를 야기하기 쉽습니다. 하지만 @for를 사용하면 이런 문제가 사라집니다.\n\n@for가 뛰어나게 만드는 점은 빠른 차이 비교 성능을 보장하기 위해 track이 필수적이라는 것입니다. 그리고 가장 좋은 점은 사용하기가 정말 쉽다는 것이죠! 이제 더 이상 컴포넌트 클래스에 메서드를 추가할 필요가 없습니다. trackBy와 달리 track은 표현식으로만 사용할 수 있습니다.\n\n이 결과는 커뮤니티 프레임워크 벤치마킹에서 최대 90%까지 빠른 런타임을 제공할 수 있다는 것입니다!\n\n# 새로운 제어 플로우 구문으로 마이그레이션하기\n\n\n\n당신의 머리 속에서 삐죽삐죽한 무언가가 돌고 있을 거라고 느껴져요. 새 문법을 사용하려면 코드를 전면적으로 리팩토링해야 한다는 생각에 말이죠.\n\n하지만 걱정 마세요! 기쁜 소식을 전해드릴게요.\n\n리팩토링에 머리 아픔을 느끼지 않아도 됩니다. @angular/core:control-flow-migration 스키마가 모두 대신 처리해 드릴 거예요. 터미널을 열어서 다음 명령어를 실행해보세요:\n\n```js\nng g @angular/core:control-flow-migration\n```\n\n\n\n# 렌더링을 위한 새로운 라이프사이클 후크\n\n앵귤러의 서버 측 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 성능을 더욱 원활하게 하기 위해, 앵귤러 팀은 DOM 흉내와 직접적인 DOM 조작에서 이별을 준비 중입니다.\n\n이를 위해 프레임워크는 이제 afterRender 및 afterNextRender 라이프사이클 후크를 제공합니다:\n\n- afterRender 후크는 렌더링이 완료된 후에 콜백을 트리거하기 위해 동작합니다.\n- afterNextRender 후크는 다음 렌더링이 끝난 후에 트리거될 콜백을 등록합니다.\n\n\n\n# SSR 기능 기본 제공\n\nAngular의 옛날을 떠올려보면 SSR을 활성화하는 것은 모험을 떠나는 것과 같은 느낌이었습니다. 별도의 패키지(Angular Universal)와 중복된 빌드 프로세스를 다루고 angular.json에서 구성을 해석해야 했죠. 정말 머리 아파지죠.\n\n하지만 새로운 시대가 열렸어요!\n\n최신 애플리케이션 빌더는 간단함과 통일성에 초점을 맞추고 있습니다. Angular 앱을 위한 올인원 빌더를 제공해줘요. 앱 쉘, 브라우저, 서버 등을 모두 원활하게 통합시켜줍니다.\n\n\n\n새 프로젝트를 시작할 때, 다음 명령어를 실행하여 SSR 마법을 뿌려보세요:\n\n```js\nng new --ssr\n```\n\nCLI는 심지어 SSR을 활성화할지 묻기 위해 명령 프롬프트에서 확인을 요청할 거에요.\n\n그리고 SSR을 나중에 선택하려면 걱정하지 마세요! 그냥 아래와 같이 입력해주세요:\n\n\n\n\nnpm install @angular/ssr --save\n\n\n그럼요! 이제 Angular 앱이 SSR에 준비됐어요.\n\n# 수분공급\n\n수분공급은 서버에서 렌더된 애플리케이션을 클라이언트 측에서 다시 살려내는 마법 같은 행위에요.\n\n\n\n\n서버 렌더링된 DOM 구조를 재사용하고 애플리케이션 상태를 유지하며 서버에서 이미 가져온 애플리케이션 데이터를 전송하며 기타 영웅적인 역할을 수행합니다.\n\n그리고 놀랍게도!\n\nSSR을 선택하면 기본적으로 하이드레이션을 사용합니다. 이 기술에 대해 더 깊이 이해하려면 하이드레이션 가이드를 확인하세요.\n\n# ESBuild 및 Vite 기본 지원\n\n\n\n자, 이제 엔진 덮개 아래를 살펴보겠습니다: Angular CLI의 빌드 파이프라인.\n\nAngular는 CLI에서 ng build, ng serve 및 ng test와 같은 명령에 사용되는 빌더를 제공합니다. 이러한 내장 CLI 빌더 및 기타 빌더의 기본 대상 구성은 워크스페이스 구성 파일 angular.json의 architect 섹션에 사용 가능합니다:\n\n![이미지](/assets/img/2024-05-14-WhatsNewinAngular17_2.png)\n\n빌드 파이프라인에서 중요한 변경 사항은 모든 새 애플리케이션에 대해 esbuild 플러스 Vite가 기본적으로 활성화되었다는 사실입니다.\n\n\n\nAngular 16에 개발자 미리보기로 도입된 Esbuild 및 Vite 기반 빌드 경험이 소개되었어요. 피드백 결과 몇 가지 경우 빌드 시간이 67% 향상되었다고 해요.\n\n![2024-05-14-WhatsNewinAngular17_3.png](/assets/img/2024-05-14-WhatsNewinAngular17_3.png)\n\nSSR 및 SSG를 사용하는 경우, ng build의 속도가 최대 87% 향상되고 ng serve의 편집-새로고침 루프도 80% 빨라져요.\n\n# 마지막으로\n\n\n\nAngular 버전 17은 우리가 기대하던 멋진 새로운 기능을 가져오는 것뿐만 아니라 버그 수정과 성능 향상도 포함되어 있어요.\n\n더 자세한 내용이 궁금하다면, 백스테이지 패스는 GitHub에 있어요. 그리고 Angular의 미래를 예상해보고 싶다면, 로드맵을 확인해보세요.\n\n즐거움을 놓치지 마세요! 터미널로 이동해서 `ng upgrade` 명령어로 마법을 일으켜보세요.\n\n# 더 알고 싶다면?\n\n\n\n제가 똑똑하고 호기심 많은 사람들을 위해 엔지니어링, 기술 및 리더십에 관한 글을 쓰고 있어요 🧠💡. 독점 액세스를 원하시면 무료 이메일 뉴스레터에 가입해주세요.\n\n27,000여 명의 학생들과 함께 온라인 비디오 코스인 Web Performance 101: 웹 앱 성능 향상 방법을 받아보세요.","ogImage":{"url":"/assets/img/2024-05-14-WhatsNewinAngular17_0.png"},"coverImage":"/assets/img/2024-05-14-WhatsNewinAngular17_0.png","tag":["Tech"],"readingTime":7},{"title":"좋은 커밋 대 나의 커밋 완벽한 Git 커밋 메시지 작성법","description":"","date":"2024-05-14 13:53","slug":"2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage","content":"\n\n수 년 전, 궁금증 때문에 커밋 메시지 작성에 대한 구체적인 규칙이 있다는 것을 알지 못했어요. 예전엔 \"기능 2 추가\", \"메인 네비게이션 바 버그 수정\", 혹은 \"foo\"와 같이 간단한 메시지가 충분하다고 생각했어요. 하지만 커밋 메시지가 대부분 무시당한다고 생각했던 것은 잘못된 생각이었어요. 실제로, 신중하고 세심하게 작성된 커밋 메시지는 우리 미래의 자신이 우리의 성실함과 세심함에서 이익을 얻게끔 해주는 필수적인 역할을 합니다.\n\n목차: 왜 깨끗한 커밋 메시지 작성에 신경을 써야 할까? | 흔한 실수들 | 7가지 규칙 | 사례 연구 | 팁.\n\n# 왜 깨끗한 커밋 메시지 작성이 중요할까요?\n\n\n\n커밋은 프로그래머의 기술의 구체적인 구성 요소로 작용합니다. 코드의 완성을 나타내며, 올바르게 작성되면 상당한 가치를 제공합니다. 잘 쓰여진 커밋 메시지는 필수불가결합니다. 왜냐하면 컨텍스트를 제공하기 때문입니다. 그렇지 않으면 커밋 메시지는 처음부터 필요하지 않을 것입니다.\n\n개발자들 사이의 일반적인 실수 중 하나는 Git 저장소를 백업 시스템으로 취급하는 것입니다. 현재 코드 상태를 캡처하기 위해 무작위로 커밋하는 것은 미래에 코드베이스를 확인할 때 과거 변경 사항을 이해하는 능력을 방해할 수 있습니다. \"WIP\", \"Off for lunch\", \"End of code for today\", \"I am tired AF\", \"Happy Weekend Team\", \"First to commit\"과 같은 커밋 메시지는 추가적인 가치가 전혀 없기 때문에 Git 로그를 혼란스럽게 만들며, 본질적인 커밋 내용을 파악하기 어렵게 만들 수 있습니다.\n\n# 원격 저장소에 커밋할 때 피해야 할 몇 가지 주요 실수가 여기 있습니다.\n\n## 서로 다른 파일에 대한 변경 사항을 분리하여 커밋하지 마세요.\n\n\n\n다른 팀원들과 협업하거나 커밋 기록을 검토할 때 각 파일을 따로 커밋하는 것은 문제를 야기할 수 있습니다. 변경 사항의 전체 맥락을 이해하고 서로 간의 관계를 파악하는 데 어려움을 겪을 수 있어요.\n\n예를 들어, 온라인 상점을 만들고 있다고 가정해봅시다. 아래와 같이 하면 안 되죠:\n\n```js\n# header.js에 대한 변경 사항을 따로 커밋\ngit add header.js\ngit commit -m \"헤더 레이아웃 개선\"\n\n# footer.js에 대한 변경 사항을 따로 커밋\ngit add footer.js\ngit commit -m \"푸터 디자인 최적화\"\n```\n\n커밋 구조가 이러한 형태인 경우, 커밋 기록이 증가함에 따라 일관되지 못할 수 있어요.\n\n\n\n커밋은 명확하고 간결하며 논리적인 단위로 구성되어야 합니다. 예를 들어, 코드 레이아웃 섹션을 완료한 후 헤더와 푸터 섹션을 작업한 경우, 이러한 변경 사항을 커밋하기 전에 변경 사항들을 결합하는 것이 깔끔합니다:\n\n```js\n# header.js 및 footer.js의 Staging 변경 사항\ngit add header.js footer.js\n\n# 관련 변경 사항 함께 커밋\ngit commit -m \"UI 개선: 헤더 및 푸터 개선\"\n```\n\n이론적으로는 쉽게 들릴 수 있지만 실천하기는 쉽지 않을 수 있습니다. 그래서 변경 사항들을 메인 브랜치로 통합하기 전에 개인 브랜치를 유지하여 합병하기 전에 변경 사항을 커밋하는 것이 좋은 실천법입니다.\n\n## 개인 커밋용 전용 브랜치 만들기\n\n\n\n코드를 커밋한다고 해서 꼭 당신의 git 로그의 끝없는 영역에 영원히 남아 있어야 하는 것은 아닙니다. 개인 브랜치를 당신의 개인 프로그래머 스케치패드로 생각해보세요. 여기서는 다른 사람이 당신의 작업을 세심하게 조사할 필요 없이 자유롭게 실험할 수 있습니다.\n\n상황을 상상해보세요: 코딩 중이지만 잠시 쉬어야 하는 때가 오거나 저녁식사를 앞두고 있을 때. 현재 진행 중인 작업을 잃을까봐 두려워서 변경 사항을 커밋하기로 했습니다. 이런 경우에는 개인 브랜치가 완벽하게 활용될 수 있는 상황입니다. 당신의 코딩 세션을 마무리하거나 갑작스럽게 커밋을 하고 싶은 날에도 이러한 변경 사항은 개인 브랜치에 보관됩니다.\n\n```js\ncommit [커밋 해시]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate:   [타임스탬프]\n    작업 중\n\ncommit [커밋 해시]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate:   [타임스탬프]\n\n    파일을 최종적으로 잃기 전에 커밋합니다.\n\ncommit [커밋 해시]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate:   [타임스탬프]\n\n    저녁식사 준비 중\n\ncommit [커밋 해시]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate:   [타임스탬프]\n\n    화장실 가는 시간!\n```\n\n협업 환경에서는 개인 브랜치의 명칭을 명확하게 지어야 합니다. 이러한 종류의 커밋 메시지는 퍼블릭 브랜치에 나타나서는 안 되기 때문입니다.\n\n\n\n명시적인 브랜치 네이밍이나 동료들과 직접 의사 소통을 통해, 현재 브랜치의 내용이 지속적인 작업의 기반으로 사용되지 않음을 분명히 해주세요. 개인 브랜치에 적합한 좋은 네이밍은 `private/do-not-use-this` 같은 것입니다.\n\n당신의 퍼블릭 브랜치에 포함되는 모든 커밋은 잘 다듬어진, 독립적인, 되돌릴 수 있고 명확히 설명된 작업 단위여야 합니다.\n\n# 사례 연구: 온라인 스토어의 장바구니 기능 개발\n\n지금까지 진행해온 온라인 스토어 프로젝트를 살펴보겠습니다. 이 문맥에서, 여러분은 스토어에 장바구니 기능을 추가하는 것을 책임지는 프론트엔드 개발자로 활동하게 됩니다. 여러분의 여정은 다음과 같이 펼쳐집니다:\n\n\n\n이제 Git 로그를 살펴보겠습니다:\n\n```js\ncommit [commit-hash-1]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate: [Timestamp]\n\n    장바구니 섹션의 CSS 디자인 향상\n\ncommit [commit-hash-2]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate: [Timestamp]\n\n    장바구니에 Javascript 기능 추가\n\ncommit [commit-hash-3]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate: [Timestamp]\n\n    텍스트 정렬 문제 해결을 위한 CSS 수정\n\ncommit [commit-hash-4]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate: [Timestamp]\n\n    장바구니 동작과 관련된 카운터 버그 수정\n\ncommit [commit-hash-5]\nAuthor: Your Name \u003cyour.email@example.com\u003e\nDate: [Timestamp]\n\n    결제 버튼에 로딩 애니메이션 통합\n```\n\n이러한 변경 사항이 온라인 상점과 관련된 다른 커밋들과 함께 주요 기능 브랜치에 통합되어야 한다면, 리뷰 프로세스가 어려워질 수 있습니다.\n\n## 이런 커밋 로그들을 수정하는 방법은 다음과 같습니다\n\n\n\n우선 기능 브랜치로 전환해주세요:\n\n```js\n# feature/cart-section이라는 기능 브랜치로 전환\ngit checkout feature/cart-section\n```\n\n그런 다음 private/do-not-use-this 브랜치에서 모든 커밋을 하나의 커밋 메시지로 feature/cart-section에 통합해주세요:\n\n```js\n# private 브랜치의 모든 커밋을 하나의 커밋으로 feature 브랜치에 병합 및 통합\ngit merge --squash private/do-not-use-this\n```\n\n\n\n병합 및 squash 작업을 완료한 후에는 명확하고 설명적인 커밋 메시지를 작성해야 합니다:\n\n```js\n# 자세한 커밋 메시지를 작성하세요\ngit commit -v -m \"Feat: 멋진 애니메이션으로 장바구니 기능 만들기\n\n장바구니 섹션의 CSS 레이아웃을 개선하여 텍스트 정렬 문제를 해결하고 레이아웃을 재미있게 향상하여 가독성을 높였습니다.\"\n\"\n```\n\n# 완벽한 커밋 메시지 작성을 위한 7가지 표준 규칙\n\n이 규칙은 커밋 메시지가 올바르게 서식이 지정되고 명확한 정보를 전달하도록 보장하기 위한 지침과 모범 사례를 제공합니다. 특정 규칙은 다른 소스에 따라 다를 수 있지만, 일반적인 목표는 Git 버전 관리 시스템 내에서 커밋 메시지의 가독성과 이해를 높이는 것입니다.\n\n\n\n## 규칙 1: 제목은 50자로 제한하세요.\n\n커밋 메시지의 제목을 작성할 때는 간결하고 목적을 집중시키는 것이 좋습니다. 제목은 커밋의 목적을 간단히 요약한 것으로, 이상적으로 50자를 넘지 않도록 하는 것이 좋습니다.\n\n50자로 제한하는 것이 힘들다면, 커밋의 의도에 대한 명확성이 부족할 수 있습니다. 커밋 메시지는 명확하고 간결하며 독립적으로 설명할 수 있어야 합니다. 이 글자 수 제한을 준수함으로써, 가장 중요한 정보에 우선순위를 두어 팀원들과 미래의 본인이 변경 내용의 본질을 한눈에 파악하기 쉽게 할 수 있습니다.\n\n## 규칙 2: 제목의 첫 글자만 대문자로 쓰세요.\n\n\n\n커밋 메시지를 작성할 때 제목 라인의 첫 글자를 대문자로 쓰면 됩니다. 이는 간결한 문장을 쓰는 것과 마찬가지로 타이틀 케이스를 사용하는 것입니다. 추가로 메시지의 나머지 부분은 소문자로 작성해주세요.\n\n## Rule 3: 제목 라인 끝에 온점을 찍지 말아주세요\n\n제목 라인을 온점으로 끝내지 않는 이유는 부분적으로는 역사적이며 일부는 일관된 스타일을 유지하기 위함입니다. 제목 라인을 명령문이나 명령처럼 취급하여 작성하는 관례에 따라 마침표를 생략합니다. 이를 통해 이 관례를 강화하고 제목 라인을 간결하게 유지할 수 있습니다.\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\"\n```\n\n\n\n## 규칙 4: 제목과 본문 사이에 빈 줄을 넣으세요\n\n이 가이드라인은 조금 이상하게 보일지 모르지만, 실용성에 근간을 두고 있습니다. 많은 개발자들이 Git을 위한 명령줄 인터페이스를 사용하는데, 이들은 자동 줄 바꿈을 지원하지 않는 경우가 많습니다. 그래서 의도적인 형식 규칙이 도입되었으며 일관적이고 가독성 있는 커밋 메시지를 보장합니다.\n\n```js\ngit commit -v -m \"친절한 애니메이션을 가진 카트 기능 만들기\n\n본문...\n\"\n```\n\n## 규칙 5: 커밋 본문의 줄을 72자로 래핑하세요\n\n\n\n줄 바꿈 규칙은 전통적인 단어 줄 바꿈을 의미하는 것이 아니라, 명령줄 사용자가 72자를 초과하는 커밋 본문을 겪을 수 있다는 고려에서 비롯된 것임을 명확히 하는 것이 중요합니다.\n\n대부분의 경우, 메시지는 72자를 초과할 것입니다. 이러한 경우에는 아래의 커밋 메시지에서 보여주는 바와 같이 텍스트를 줄 바꿈하고 다음 줄에서 문장을 계속하는 것이 좋습니다:\n\n```js\ngit commit -v -m \"Create the Cart Feature with a Nice Animation\n\nEnhanced the CSS layout of the cart section, addressing text\nalignment issues and refining the layout for improved aesthetics\nand readability.\"\n```\n\n요약하자면, 점 목록을 표시하는 표준 방법은 하이픈이나 별표 뒤에 공백 하나를 두고 사용하는 것입니다. 더불어 조직적 가독성을 높이기 위해 들여쓰기를 유지하는 것이 중요합니다.\n\n\n\n## 규칙 6: 명령형 문법 사용하기\n\n가치 있는 실천 방법 중 하나는 커밋 메시지를 작성할 때 해당 커밋이 구현되면 정확한 작업을 수행할 것이라는 기본적인 이해를 갖는 것입니다. 커밋 메시지를 작성할 때 ‘만일 적용된다면, 이 커밋은…’이라는 문장을 논리적으로 완성하는 방식으로 만드세요. 예를 들어, `git commit -m \"Fixed the bug on the layout page\"` ❌ 대신에 `git commit -m \"Fix the bug on the layout page\"` ✔ 를 사용하세요.\n\n다시 말해, 만일 이 커밋이 적용된다면, 실제로 레이아웃 페이지에서 버그가 해결될 것입니다.\n\n## 규칙 7: “무엇\"과 “왜\"를 설명하되, “어떻게\"에 대해서는 제외하세요.\n\n\n\n커밋 메시지를 “무엇\"과 “왜\"로 제한하면 각 변경 사항에 대해 간결하면서도 정보를 제공하는 설명이 생성됩니다. 코드가 어떻게 구현되었는지 알고 싶은 개발자는 직접 코드베이스를 참조할 수 있습니다. 대신, 변경된 내용과 변경의 이유, 영향을 받은 구성 요소나 영역을 강조해주세요.\n\n## 사례 연구: Angular의 커밋 메시지 관행\n\nAngular는 효과적인 커밋 메시지 관행의 저변적인 예로 자리 잡고 있습니다. Angular 팀은 커밋 메시지를 작성할 때 특정 접두사의 사용을 지지합니다. 이러한 접두사에는 “chore: ,\" “docs: ,\" “style: ,\" “feat: ,\" “fix: ,\" “refactor: ,\" 그리고 “test: .\"가 포함됩니다. 이러한 접두사를 통합함으로써 커밋 이력은 각 커밋의 성격을 이해하는 데 유용한 자원이 됩니다.\n\n# 팁\n\n\n\n커밋 메시지를 통해 명확하고 의미 있는 커뮤니케이션을 우선시하는 것을 기억해 주세요. 정성스럽게 작성된 커밋 메시지는 ‘무엇을,’ ‘왜’에 대한 설명을 담고 있어야 합니다. 하지만 ‘어떻게’까지는 너무 자세히 설명하지 않아도 됩니다. 커밋 기록은 미래의 여러분과 팀원들이 의지할 중요한 자원이 되므로, 정보를 제공하고 간결하며 일관된 내용으로 커밋 메시지를 작성하는 습관을 들어보세요.\n\nGit을 깊게 이해하고 숙련된 \"버전 컨트롤러\"로 성장하고 싶다면, 이 훌륭한 자료들을 살펴보세요:","ogImage":{"url":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png"},"coverImage":"/assets/img/2024-05-14-GoodCommitvsYourCommitHowtoWriteaPerfectGitCommitMessage_0.png","tag":["Tech"],"readingTime":7},{"title":"클라이언트 측 JavaScript를 사용하여 문자열을 버퍼 및 데이터 URL 형식으로 변환하는 방법","description":"","date":"2024-05-14 13:52","slug":"2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript","content":"\n\n웹 애플리케이션에서는 Base64가 종종 사용됩니다. 바이너리 데이터를 ASCII 텍스트 형식으로 저장하거나 전송하기 위해 인코딩하는 데 쓰입니다. 예를 들어, 파일 전송 API는 효율적인 저장 및 처리 속도로 인해 이진 데이터로 반환된 응답을 받는 경우가 많습니다.\n\n![image](/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png)\n\n# NodeJS의 버퍼 클래스\n\nNodeJS에 독점적인 전역 API 중 하나인 버퍼 클래스는 보내거나 받는 이진 데이터를 처리하는 편리한 수단으로 사용됩니다. 예를 들어, 다음 코드 스니펫은 NodeJS의 버퍼 모듈을 사용하여 문자열을 ArrayBuffer로 변환하거나 그 반대로 변환하는 방법을 보여줍니다:\n\n\n\n```js\nconst str = 'Hey. this is a string!';\n\nconst buffer = Buffer.from(str, 'utf-8'); // 형식: ArrayBuffer\nconst b64Str = Buffer.from(str, 'utf-8').toString('base64');\nconsole.log(b64Str);\n/* 예상 결과: */\n// SGV5LiB0aGlzIGlzIGEgc3RyaW5nIQ==\n\nconst originalStr = Buffer.from(b64Str, 'base64').toString('utf-8');\nconsole.log(originalStr);\n/* 예상 결과: */\n// Hey. this is a string!\n```\n\n## 클라이언트 측 브라우저 환경\n\n- btoa()는 Base64로 인코딩된 문자열을 읽고 출력합니다.\n- atob()은 Base64 문자열의 디코딩에 사용됩니다.\n\nNodeJS의 Buffer 모듈은 기본적으로 UTF-8 인코딩 체계를 사용하는 반면, btoa()와 atob()은 유니코드 텍스트와 같은 비 ASCII 문자를 해석할 수 없어 에러를 발생시킵니다.\n\n\n\n```js\ntry {\n  btoa('ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ'); // 유니코드 문자만\n} catch(err) {\n  console.error(err);\n}\n// 콘솔 출력:\n/* InvalidCharacterError: Failed to execute 'btoa' on 'Window': The */\n/* string to be encoded contains characters outside of the Latin1 range. */\n```\n\n그러므로 데이터를 이진 데이터 형식으로 변환하는 경우 — 즉, Data URL 및 ArrayBuffer로 변환하기 위해 사전에 UTF-8로 문자열을 바이트 시퀀스로 변환한 후 이 바이트 시퀀스를 Base64 문자열로 인코딩해야 합니다.\n\n# 구현 세부 사항\n\n여기 클라이언트 측 JavaScript를 사용하여 \"유니코드 문제\"를 해결하기 위한 2가지 가능한 방법이 있습니다. 양 구현 모두 아래의 헬퍼 함수 convertBitArrtoB64 및 convertB64ToBitArr가 포함되어야 한다는 점을 유의하십시오:\n\n\n\n```js\n// Uint8Array를 Base64 문자열로 변환하는 함수\nconst convertBitArrtoB64 = (bitArr) =\u003e ( btoa( bitArr.reduce((data, byte) =\u003e data + String.fromCharCode(byte), '') ) );\n\n// Base64 문자열을 Uint8Array로 변환하는 함수\nconst convertB64ToBitArr = (b64Str) =\u003e ( Uint8Array.from(atob( (b64Str.includes(';base64,') ? (b64Str.split(','))[1] : b64Str) ), (v) =\u003e v.charCodeAt(0)) );\n```\n\n## (1) TextEncoder \u0026 TextDecoder\n\nUTF-8 문자열 인코딩은 네이티브 브라우저에서 TextEncoder 인터페이스(반대 방향으로는 TextDecoder)로 처리할 수 있습니다:\n\n- 문자열을 ArrayBuffer 및 Base64로 인코딩된 데이터 URL로 변환하기\n\n\n\n\n```js\nconst inputStr = '히카리 미나미';\n\n// 문자열을 Uint8Array로 출력하는 인자를 사용하는 함수\nconst bitArr = (utf8Str) =\u003e (new TextEncoder().encode(utf8Str));\n\nconst uInt8Arr = bitArr(inputStr);\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 236,150,136,237,132,132,235,170,164,237,157,144,32,236,130,183,235,143,138\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 바이트 길이가 21인 ArrayBuffer 출력\n\nconst b64Str = convertBitArrtoB64( bitArr(inputStr) );\nconsole.log(b64Str);\n// 예상 결과:\n// 7ZWw7ISw7Iqk7YOJIDA=\n```\n\n- 원래 입력된 텍스트로의 역 변환\n\n```js\n// Uint8Array를 사용하는 인자를 문자열로 출력하는 함수\nconst utf8Str = (bitArr) =\u003e (new TextDecoder().decode(bitArr.buffer));\n\nconst originalStr = utf8Str(convertB64ToBitArr(b64Str));\nconsole.log(originalStr);\n// 예상 결과:\n// 히카리 미나미\n```\n\n## (2) unescape + encodeURIComponent 및 decodeURIComponent + escape\n\n\n\n\n그러나 대안으로 UTF-8 인코더를 구현하는 JavaScript를 사용할 수도 있습니다. 이를 위해 브라우저 글로벌 객체인 unescape + encodeURIComponent (그리고 반대 방향으로는 decodeURIComponent + escape)를 사용할 수 있습니다:\n\n- 문자열을 ArrayBuffer와 Base64로 인코딩된 데이터 URL로 변환\n\n```js\nconst inputStr = 'ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ';\n\n// 문자열을 받아 Base64 문자열을 출력하는 함수\nconst utf8_to_b64 = (str) =\u003e (btoa(unescape(encodeURIComponent(str))));\n\nconst b64Str = utf8_to_b64(inputStr);\nconsole.log(b64Str);\n// 예상 결과:\n// 44O+zr7iuKjwn46Ay7binZvjg67inZviuKnvvokg4bWA4bS04bSxIOG0v+G0teG0ruG0ruG0vOG0uiDhtLPhtLXhtL/htLg=\n\nconst uInt8Arr = convertB64ToBitArr(utf8_to_b64(inputStr));\nconsole.log(uInt8Arr);\n// 예상 결과:\n// 227,131,190,206,190,226,184,168,240,159,142,128,203,182,226,157,155,227,131,174,226,157,155,226,184,169,239,190,137,32,225,181,128,225,180,180,225,180,177,32,225,180,191,225,180,181,225,180,174,225,180,174,225,180,188,225,180,186,32,225,180,179,225,180,181,225,180,191,225,180,184\n\nconst buffer = uInt8Arr.buffer; \nconsole.log(buffer); \n// 예상 결과:\n// 71바이트 길이의 ArrayBuffer를 출력함\n```\n\n- 원래 입력 텍스트로의 역변환\n\n\n\n```js\n// Base64로 인코딩된 데이터 URL을 받아 String을 출력하는 함수입니다.\nconst b64_to_utf8 = (str) =\u003e (decodeURIComponent(escape(atob(str)));\n\nconst originalStr = b64_to_utf8(b64Str);\n// 예상 결과:\n// ヾξ⸨🎀˶❛ヮ❛⸩ﾉ ᵀᴴᴱ ᴿᴵᴮᴮᴼᴺ ᴳᴵᴿᴸ\n```\n\n# 실시간 데모\n\n## ASCII 문자만 사용\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*FHtRkS1iUjaSCPGv6Pz0-A.gif\" /\u003e\n\n\n\n\n## 유니코드 문자만\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*kwj-q8KMkj_nQcqWhliUBw.gif)\n\nconvert-to-buffer에서 직접 시도해보세요!\n\n여기까지 읽어주셔서 정말 감사합니다! ❤ 이 구현이 유용했기를 바라며, 더 많은 GIS, 데이터 분석 및 웹 응용 프로그램 관련 콘텐츠를 원하시면 Medium에서 제 팔로우를 해주세요. 정말로 감사하겠습니다 — 😀\n\n\n\n— 🌮 타코 한 개 사주세요 ξ(🎀˶❛◡❛)\n\n## 다른 웹 관련 콘텐츨 후보:\n\n# PlainEnglish.io 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 저자에 대한 박수 및 팔로우 부탁드려요️\n- In Plain English에 글을 쓸 수 있는 방법을 배워보세요️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-HowToConvertStringToBufferAndDataURLFormatsUsingClient-SideJavaScript_0.png","tag":["Tech"],"readingTime":5},{"title":"믿거나 말거나, 우리에게 또 다른 할 일 앱이 필요합니다","description":"","date":"2024-05-14 13:50","slug":"2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp","content":"\n\n## 네, 이미 수백만 개 이상 구현된 것이 있음에도 불구하고...\n\n그 중에 하나가 있어요:\n\n- 찾을 수가 없어요.\n- 정말 필요해요.\n\n그래서, 제가 직접 만들기로 결정했어요. 생산성 앱으로 넘쳐나는 세상에서 새 할일 목록을 소개하는 아이디어는 중복되었거나 아주 불필요한 것처럼 보일 수 있어요. 이미 잘 밟힌 길을 왜 가야 할까요?\n\n\n\n그럼에도 불구하고, 내 목표는 초보 개발자의 작은 프로젝트에 흔히 볼 수 있는 애플리케이션 개념의 성공을 단순히 희망하는 데 그치지 않습니다. 저는 실제로 더 집중할 만한 몇 가지 사안이 있는데, 이에 대해 뒤에 자세히 논의할 것입니다. 이 애플리케이션의 아이디어에서부터 시작해보죠. 인기 있는 책에서 영감을 받았습니다.\n\n# 할 일 목록이란?\n\n팀 페리스(Tim Ferriss)의 책 '4시간 근무주'에 대해 들어봤을지도 모릅니다. 개인적으로 매우 유용하다고 생각하며 유용한 팁과 기교가 많이 있습니다. 그 중 하나를 사용해 보고 굉장히 강력한 도구라고 판단했습니다. 간단히 설명하자면, 그것은 플래너입니다. 하지만 처음에 상상할 것과 다른 플래너입니다. 오히려 그것을 도구라고 하거나, 단지 삶을 현재의 상태에서 기대되는 상태로 바꾸기 위한 프레임워크라고 할 것입니다. 일반적으로 그것이 플래너의 목표겠죠? 그렇다고 볼 수도 있겠지만, 저는 이것이 제가 알고 있는 다른 것보다 훨씬 잘 작동한다고 생각합니다. 한 번 해봤고 결과에 만족했습니다. 그래서 다시 해보고 싶습니다. 이번에는 종이가 아닌 앱을 사용하려고 합니다. 계획의 디지털 버전을 사용하면 다양한 일을 할 수 있습니다... 적어도 언제든지 출력하여 종이 버전을 얻을 수 있습니다! 농담은 놓고 — 정확히 어떻게 보일지와 어떤 기능이 최종적으로 포함될지 아직 모르겠지만, 디지턼 버전으로부터 혜택을 얻을 수 있는 여러 방법이 있는데요:\n\n- 접근성과 휴대성: 디지털 정보도 분실될 수 있습니다. 다만, 전반적으로 디지털 자산을 보관하는 것이 훨씬 쉽습니다.\n- 동기화와 백업: 처음 버전에는 포함되지 않을 것인데 필요할 때 실행할 수 있는 기회가 있습니다.\n- 업데이트와 편집: 거의 깜빡했네요! 종이에서는 어떻게 편집하시나요?\n- 데이터 분석과 통찰: 이것은 명백히 애플리케이션의 일부여야 합니다. 최소한 진행 상황의 시각화가 필수적인 것으로 보입니다.\n- 멀티미디어 통합: 진부해 보일지 모르지만 중요하지 않다는 뜻은 아닙니다. 종이 버전에 외부 자원에 대한 링크를 추가할 수는 없겠지요.\n\n\n\n## 그리고 훨씬 많은 것이 있어요! 사실 세계에 직접적으로 속하지 않아요 — 우리의 상상력으로 제한돼요.\n\n## 계획자.\n\n알았어요, 그러니까 우리가 어플리케이션이 가치를 가져다준다고 합의했으니, 이 책에서 계획자가 어떻게 정의되었는지 살펴보고 그 요소들을 세분화해보겠습니다.\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png)\n\n\n\n제가 두 가지 주요 부분으로 나누어서 설명해 드릴게요. 먼저 목표를 정의하는 단계와 관련된 7단계를 포함한 부분이고 두 번째로는 그 목표를 이루기 위해 필요한 작업 목록을 설정하는 부분입니다.\n\n기본적으로 먼저, 원하는 것, 되고 싶은 사람, 하고 싶은 일을 정의한 뒤, 그것을 이루기 위한 시간이나 돈을 투자하는 비용을 확인해야 해요:\n\n![이미지](/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_1.png)\n\n두 번째로, 이루어져야 하는 구체적인 작업 목록이에요:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_2.png\" /\u003e\n\n실생활 예시로 가볍게 한 번 생각해보자. 나만의 자동차로 전국을 여행하는 꿈이 있다고 상상해봐. 그런데 당장은 운전 면허나 자동차 둘 다 없군. 정말 큰 프로젝트 같지만 그래도 6개월 안에 완성할 수 있는 것이야.\n이번에 우리가 할 일을 표로 나눠서 좀 더 구체화해보자.\n\n## 단계 1: 소유\n\n당연하게도, 자동차와 운전 면허가 필요하겠지? 이 두 가지를 목록에 추가해보자:\n- 자동차\n- 운전 면허\n\n\n\n## 단계 5: 비용\n\n앗, 단계 번호가 혼란스러울 수 있어요. 방금 전에는 1단계에 있었는데, 이제는 5단계에요. 아마도 우리 애플리케이션에서는 이제 이런 단계들의 번호를 숫자 색인으로 사용하지 않을 거예요.\n\n그래서, 제가 전문가는 아니지만 이 차가 당신에게 처음으로 소개되는 차일 거예요. 그렇기 때문에 너무 걱정할 필요는 없지만 너무 오래된 차도 아니어야 해요. 10~15년 된 일본 제조 차량이 좋은 후보라고 생각해요. 상태가 괜찮은 차를 구입하기 위해 약 10,000 달러를 준비해야 할 거예요.\n또한 운전 면허를 취득하는 데 일부 비용이 들어요. 당신이 사는 나라에 따라 비용이 다르겠지만, 여기서는 평균적으로 약 500달러를 사용해볼게요.\n\n그럼 이 두 가지를 추가해볼게요:\n- 오래되지 않은 차: 10,000 달러\n- 운전 면허: 500 달러\n\n\n\n월 1,750달러를 모아야 한다는 것은 꽤 많은 금액입니다. 그러나 특정한 경우에는 이미 약간의 저축이 있을 수도 있고, 더 싼 차를 사기 위해 노력하고 있을 수도 있습니다.\n\n## 지금 취해야 할 단계\n\n글을 쓰고 나서 곧바로 할 수 있는 일들입니다. 다음 주 월요일이나 아침까지 기다릴 필요는 없습니다. 지금 바로 시작하세요.\n예를 들어:\n— 운전 규칙 배우기\n— 자산 계산하기\n— 저축 계획 수립하기\n— 줄일 수 있는 지출 결정하기\n\n## 내일\n\n\n\n\"내일\"을 정확히 의미하지는 않습니다. 대신 이것은 막힘이 있는 작업이며 다른 일을 완료하거나 일어난 후에만 할 수 있습니다. 이전 목록의 작업이 완료되기를 기다릴 수도 있습니다:\n\n- 운전 이론 시험 통과\n- 운전 교육사 찾기\n- 저축 계획을 평가하고 필요하다면 조정하기\n\n## 이후\n\n다시 말해, \"내일\"을 문자 그대로 받아들여서는 안 된다고 생각합니다. 이것은 직접적으로 당신의 주요 목표로 이어지는 마지막 작업이며 이전 목록을 해결함으로써 막힘이 해제됩니다:\n\n- 운전 시험을 통과하고 면허증을 받기\n- 지역 중고차 시장 분석\n- 저축 계좌에서 돈 인출\n- 중고차 판매자와 몇 가지 약속하기\n- 자동차 구매\n- 여행을 떠나세요!\n\n\n\n그거거든요, 거의 다 됐어요. 지금까지 받은 것으로 이미 유용한 계획을 가지고 있지만, 우리가 아직 STEP 2: BEING과 STEP 3: DOING에 손을 대지 않았어요. 작가나 음악가가 되고 싶을 수도 있고, 직업을 바꾸고 싶을 수도 있어요. 체육관에 가거나 마라톤을 뛰기 시작해도 좋아요. 무엇이든 좋아요—써 내려보고, 그것을 이룰 방법을 생각하고 계획을 세워보세요.\n\n이것은 일반적인 꿈과 아이디어를 구체적인 것들로 분해하고 그것들을 이루기 위한 계획을 세우는 강력한 도구에요. 그리고 한번 이걸 마치면 두 가지 중요한 지점으로 이끌어줘요:\n1. 목표를 이루기 위해 정확히 무엇이 필요한지 생각해보기.\n2. 실제로 그것에 얼마나 많은 자원이 필요한지 이해하기.\n\n첫 번째 지점이 매우 명백하고, 우리는 이미 이에 대해 지나왔기 때문에—두 번째 지점의 중요성은 몇 가지 설명이 필요할 수도 있어요. 저자는 일주일에 너무 많은 시간을 일하게 되어 결국 필요한 것보다 더 많이 벌게 되지만, 이른 퇴직을 위한 충분한 금액은 아니라는 사례를 제시해요. 이렇게 하다 보면 돈을 벌기 위해 시간을 소비하는데 있어서 차이를 만들지 못하게 되죠. 자신의 기회를 가로채지 말고 레버리지를 만들고 더 많이 벌게 되는 걸 시작해보세요. 적어도 기쁨을 주는 일을 하세요.\n\n제가 다른 경우를 상상해볼 수도 있는데, 소득이 좋아서 부채들—차 대출, 주택 대출, 할부 등 때문에 여유 자금이 없는 경우가 있을 수 있어요. 정확히 무엇이 필요한지 판단하고 그 외의 것들을 모두 끊어내면—청구서를 지불하기 위해 쓰는 시간을 줄이고 미래를 위해 투자할 수 있는 시간을 늘릴 수도 있어요.\n\n\n\n# 앱이 무엇인가요?\n\n내 계획은 브라우저 전용 앱으로 만들어서 모든 \"단계\"와 \"동작\"을 채울 수 있는 것이다. 완료된 항목을 확인하고 새 항목을 추가하는 등 할 일 앱의 일반적인 기능 세트가 포함되어 있습니다. 총 비용 및 월 단위 비용의 기본적인 계산, 남은 시간 및 완료 여부를 나타내는 진행률 표시 막대도 포함됩니다.\n\n목표는 가능한 한 적은 기능을 가지고 있으면서도 완전한 제품이라고 부를 수 있을 정도로 충분히 많은 것을 갖추는 것입니다.\n\n하지만 알고 있는 바로는 — 인기/성공이 된다는 가능성은 무의미하다고 생각합니다. 복권에 당첨될 확률 정도나 비슷한 수준이라고 말씀 드릴 것입니다. 그러나 복권은 비교적 아무것도 들지 않는 대가로 구매할 수 있지만, 애플리케이션을 만들기에는 시간을 많이 투자해야 하는 도전적인 작업입니다. 그것이 무슨 일이 좀 괴물스러운 것 같다고 생각합니다. 그래서 내가 좀 더 일반적인 애플리케이션의 성공 여부와 관계없이 유익한 다른 목표가 필요합니다. 그리고 적어도 두 가지 목표가 이미 떠오르고 있습니다.\n\n\n\n## 1. 가능한 한 간단한 방법을 찾아보세요.\n\n낚시 끈과 고무줄을 사용하여 슬링샷을 만들어보세요. 그것은 가능한 한 적은 양의 기능/기술을 적절하게 조합하여, 최종 제품으로 잠재적 사용자에게 독특하고 (적어도 어느 정도는) 유용한 경험을 제공할 수 있도록 하는 것이 목표임을 강조하고 싶습니다. 서버 없이, 데이터베이스 없이, 인증 없이 등을 염두에 두세요. 브라우저에서 시작부터 끝까지 실행되는 순수한 JavaScript 앱이 될 것입니다. 데이터는 탭 간에 영속적이며 사용자가 브라우저를 닫고 다시 열어도 유지될 것이지만, 다른 기기에서는 사용할 수 없을 것입니다. 이것은 흠이 될 수 있지만, 사용자가 제공하는 민감한 데이터의 보안을 보장하기 때문에 동시에 이점이 될 수 있습니다. 사용자 브라우저의 벽 밖으로는 결코 나가지 않습니다. 그래서 이것은 제 생각에 꽤 유익한 대가제이며, 이 경우에는 개발 노력이 필요하지 않습니다.\n그게 다에요. 한 번의 네트워크 요청도 없죠... 호스팅에서 앱을 다운로드하기 위해 한 번 제외하고 말이에요. 첫 번째 버전에서는 반드시 적절한 데이터베이스와 인증이 삽입될 수도 있지만, 결코 중요하지는 않아요.\n\n## 2. 과정을 기록하세요.\n\n이것도 중요한 사항입니다. 저는 이미 10년 이상 업계에서 다양한 프로젝트를 맡아왔습니다. 내가 말해도 믿지 못할 정도로 나쁜 과정과 매우 좋고 수월한 과정들을 목격했어요. 그것들이 완벽하지는 않지만 더 나은 방법을 상상할 수 없을 만큼 좋았죠. 그러나 무언가를 한 곳에서 가져와 다른 곳에 적용하면 대부분 실패할 가능성이 높을 것입니다. 각 사례는 가능한 모든 방법에서 독특할 수 있으며, 그것들을 구축하기 위해서는 기술을 배워야 합니다. 좋은 장인은 장차 나올 제품에 어울리는 것이 아니라, 잘하는 도구가 아닌 제품에 맞는 도구를 사용한다는 것을 유념해야 합니다.\n그래서 개발 과정에서 마주하는 도전들을 기록하고, 어떤 관행이 잘 작동했고 어떤 것이 그렇지 않았는지 이유를 적어나갈 것입니다. 최종적으로 이는 시리즈로 이어지는 기사 집필이 되어야 할 것입니다.\n\n\n\n# 팀\n\n물론, 모든 것을 혼자서 하지는 않을 거에요. 프로젝트를 함께 진행할 친구가 있습니다. 그는 초보 개발자이지만 JavaScript와 ReactJS에 대한 지식이 있어서, 약간의 도움과 멘토링으로 일을 처리할 만하다고 믿어요.  \n나는 코딩을 최대한 멀리하려고 노력할 거에요. 그러다가 그가 곤경에 처했을 때나 전략적 결정을 내려야 할 때만 개입할 거에요.\n\n# 결론\n\n이 여정은 시작에 불과하고, 목적지는 불확실하지만, 우리가 그리고 있는 길은 학습과 혁신의 가능성으로 가득합니다. 여러분을 이 모험에 초대합니다. 피드백을 제공하거나 기능을 제안하거나, 그냥 우리의 진행상황을 따라오는 것까지. 함께 무엇을 만들 수 있는지 탐험해봐요.","ogImage":{"url":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png"},"coverImage":"/assets/img/2024-05-14-BelieveItorNotWeNeedAnotherTo-DoApp_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs는 프론트엔드 또는 백엔드 프레임워크일까요","description":"","date":"2024-05-14 13:48","slug":"2024-05-14-IsNextjsaFrontendorBackendFramework","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png\" /\u003e\n\n# 소개\n\nNext.js는 웹 개발 세계에서 강력하고 다재다능한 도구로 떠오르고 있습니다. 개발자들이 그 능력을 탐구할 때 일반적인 질문이 제기됩니다: Next.js는 프론트엔드인가 백엔드 프레임워크인가? 이 글에서는 Next.js의 특성을 살펴보고 프론트엔드와 백엔드 개발과 일치하는 부분을 살펴보며, 그 이중적인 성격과 실제 적용 사례를 탐구할 것입니다.\n\n# 🚀 ShipFast: SaaS, AI 또는 웹 앱용 Next.js 보일러플레이트. $100 할인, 남은 자리는 13개뿐! ⏰\n\n\n\n# 프론트엔드 프레임워크 특징\n\n프론트엔드 프레임워크는 사용자 인터페이스를 구축하고 클라이언트 측 로직을 관리하는 데 중요합니다. React를 기반으로 구축된 Next.js는 프론트엔드 개발에 적합한 기능을 갖추고 있습니다:\n\n- React 기반 아키텍처: Next.js는 React를 기반으로 구성되어 있어, 개발자들이 쉽게 상호작용적이고 동적인 사용자 인터페이스를 만들 수 있습니다.\n- 클라이언트 측 렌더링 (CSR): CSR을 활용하여 Next.js는 브라우저가 렌더링을 처리하도록 하여 초기 페이지 로드 속도를 높이고 더 빠른 사용자 경험을 제공합니다.\n- 라우팅 기능: Next.js는 내장된 라우팅 시스템을 통해 애플리케이션 내에서의 탐색을 단순화시켜 프론트엔드 개발에 적합합니다.\n\n# 백엔드 프레임워크 특징\n\n\n\n백엔드 프레임워크는 서버 측 로직, 데이터 처리 및 서버 관리를 다루는 반면, Next.js는 프론트엔드와 백엔드 간의 경계를 희미하게 만드는 특징을 나타냅니다:\n\n- 서버 측 렌더링 (SSR): SSR을 통해 Next.js는 서버 측에서 HTML을 생성하여 성능과 검색 엔진 최적화를 향상시킵니다.\n- API 라우트 및 서버리스 함수: Next.js는 API 라우트와 서버리스 함수를 생성할 수 있어 개발자가 프론트엔드 코드베이스 내에서 강력한 백엔드 기능을 구축할 수 있도록 합니다.\n- 데이터 가져오기와 미들웨어 사용: 이 프레임워크는 효율적인 데이터 가져오기를 용이하게 만들어 서버 측 로직과 미들웨어를 관리하는 데 적합합니다.\n\n# Next.js의 이중적 성격\n\nNext.js는 프론트엔드와 백엔드 기능을 부드럽게 결합하는 것으로 두드러집니다. 전통적인 프론트엔드와 백엔드 간의 구분이 덜 명확해지는 상황에서 이중적 성격이 드러납니다. 예를 들어, Next.js 애플리케이션은 외부 API에서 데이터를 가져오는 독립적인 프론트엔드 역할을 하거나 서버 측 렌더링과 백엔드 로직을 갖춘 풀 스택 애플리케이션으로 작동할 수 있습니다.\n\n\n\n# 사용 사례\n\nNext.js는 다양한 사용 사례에서 응용 프로그램을 찾을 수 있습니다:\n\n- 프런트엔드 강조: 동적이고 클라이언트 측 상호 작용 및 신속한 사용자 인터페이스 개발을 우선시하는 프로젝트입니다.\n- 백엔드 강조: 서버 측 렌더링, API 개발 및 서버리스 함수를 필요로 하는 프로젝트입니다.\n- 하이브리드 프로젝트: 단일 코드베이스 내에서 프런트엔드 및 백엔드 기능이 원할하게 통합된 응용 프로그램에 이점이 있는 프로젝트입니다.\n\n# 🚀 ShipFast: SaaS, AI 또는 모든 웹 앱을 위한 NextJS 보일러플레이트. 13개 자리 만 움직이세요! ⏰\n\n\n\n# 장단점\n\n## 프런트엔드 관점\n\n장점:\n- 빠른 UI 개발: Next.js는 React를 기반으로하며 React 컴포넌트의 선언적 특성 덕분에 동적 사용자 인터페이스를 신속하고 효율적으로 개발할 수 있습니다.\n- 클라이언트 측 렌더링 (CSR): CSR을 활용하여 Next.js는 초기 페이지 로드 속도를 높이고 렌더링을 클라이언트 측으로 이동하여 더 원활한 사용자 경험을 제공합니다.\n- 컴포넌트 재사용성: Next.js의 모듈식 React 컴포넌트 구조는 쉬운 재사용을 가능케 하며 유지보수가 용이하고 확장 가능한 코드베이스를 촉진합니다.\n- 커뮤니티와 에코시스템: React를 기반으로 한 Next.js는 거대하고 활발한 커뮤니티로부터 다양한 라이브러리, 도구 및 지원을 제공받습니다.\n- SEO 친화적: Next.js는 서버 측 렌더링 (SSR)을 지원하여 사전 렌더링된 HTML 콘텐츠를 검색 엔진 크롤러에 전달함으로써 SEO를 개선합니다.\n\n\n\n단점:\n\n- 서버 측 로직에 대한 초점이 제한적임: Next.js는 서버 측 렌더링이 가능하지만, 주로 프론트엔드 영역에서 빛을 발하며, 백엔드 기능이 특화된 백엔드 프레임워크보다 강력하지 않을 수 있습니다.\n- 부가적인 복잡성 및 오버헤드의 가능성: 서버 측 렌더링이 포함될 경우, 특히 클라이언트 측 렌더링만으로 충분한 프로젝트에서는 추가 복잡성 및 오버헤드가 발생할 수 있습니다.\n- 학습 곡선: React 또는 Next.js에 익숙하지 않은 개발자들은 React의 컴포넌트 기반 아키텍처의 복잡성을 마스터하는 데 학습 곡선이 존재할 수 있습니다.\n- 성능 트레이드오프: 프로젝트 요구 사항에 따라 클라이언트 측 렌더링의 장점이 대규모 데이터 렌더링 시 성능 트레이드오프와 함께 제공될 수 있습니다.\n- 레거시 시스템 호환성: 레거시 시스템과 통합하는 것은 Next.js의 현대적이고 React 중심적인 성격으로 인해 어려울 수 있으며, 매끄러운 호환성을 위해 추가적인 노력이 필요할 수 있습니다.\n\n## 백엔드 관점\n\n장단점:\n\n\n\n- 서버 측 렌더링 (SSR): Next.js는 SSR을 지원하여 서버에서 페이지를 사전 렌더링하여 성능을 향상시키고 더 빠른 로딩 시간과 향상된 SEO를 제공합니다.\n- API 라우트 및 서버리스 함수: Next.js에서 API 라우트와 서버리스 함수를 생성할 수 있는 기능으로 효율적인 백엔드 개발을 가능하게 하여 RESTful API 및 서버 측 로직을 구축하는 데 적합합니다.\n- 미들웨어 사용: Next.js는 개발자가 미들웨어를 구현하여 서버 측 로직 및 사용자 정의 처리에 유연하고 확장 가능한 메커니즘을 제공합니다.\n- 통합 개발: 프론트엔드 및 백엔드 로직을 단일 코드베이스 내에서 원활하게 통합할 수 있는 능력으로 개발을 단순화시켜 별도의 프로젝트를 관리할 필요성을 줄입니다.\n- 데이터 가져오기 기능: Next.js의 효율적인 데이터 가져오기는 최적의 서버 측 성능을 제공하여 개발자가 서버에서 데이터 처리를 관리할 수 있게 합니다.\n\n단점:\n\n- 이중 구조로 인한 복잡성: Next.js의 이중 구조는 풀스택 개발에 유리하지만, 특화된 백엔드 프레임워크에 익숙한 개발자들에게는 추가 복잡성을 도입할 수 있습니다.\n- 코드 중복 가능성: 프론트엔드 및 백엔드 능력을 강조하는 프로젝트에서는 코드 중복이나 모듈화되지 않은 구조의 위험이 있어 유지보수에 영향을 줄 수 있습니다.\n- 자원 소모: 프론트엔드 및 백엔드 기능의 결합은 자원 사용량 증가로 이어지며 서버 성능에 영향을 미칠 수 있어 추가 인프라가 필요할 수 있습니다.\n- 확장성 도전: 프로젝트의 확장 요구에 따라 Next.js의 통합 구조는 프론트엔드 및 백엔드 구성 요소의 최적의 확장성을 달성하는 데 어려움을 겪을 수 있습니다.\n- 의존성 관리: 프론트엔드 및 백엔드 측면의 의존성을 조화시키기 위해 잠재적인 충돌 및 버전 관리 문제를 신중하게 관리해야 할 수도 있습니다.\n\n\n\nNext.js는 전통적인 프론트엔드 및 백엔드 프레임워크 사이의 구분을 초월합니다. React 기반으로 강력한 백엔드 기능을 결합하여 현대 웹 개발에 다재다능한 도구로써 떠오르고 있습니다. 동적 사용자 인터페이스를 개발하거나 견고한 서버 측 로직을 구축하는 데 중점을 둔다 해도, Next.js는 통합된 솔루션을 제공합니다. 프론트엔드와 백엔드 간의 경계가 더 많이 흐려지는 가운데, Next.js의 이중적 성격을 탐구하는 것은 자신의 프로젝트에서 유연성과 효율성을 추구하는 개발자에게 필수적입니다.","ogImage":{"url":"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png"},"coverImage":"/assets/img/2024-05-14-IsNextjsaFrontendorBackendFramework_0.png","tag":["Tech"],"readingTime":4},{"title":"타입 생성 비밀 탐구 in TypeScript","description":"","date":"2024-05-14 13:47","slug":"2024-05-14-SecretsofTypeGenerationinTypeScript","content":"\n\n한 번 TypeScript 모임에서 발표하기 위해 나라의 절반을 여행했던 적이 있어요. 제 발표를 진행한 후에는 청중들이 흥미로워 한 것 같았는데, 다른 연사가 나타났어요. 그는 매우 사소하지만 중요한 주제에 대해 이야기했어요. TypeScript에서 데이터 유효성 검사에 대해 논의했죠.\n\n![이미지](/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png)\n\n저는 자바 개발자로 경력을 시작했는데, 당연히 일상 업무에서 다양한 유효성 검사 라이브러리를 활용했어요.\n\nTypeScript 코딩을 시작하자, 유사한 도구 세트가 쉽게 사용 가능하지 않다는 것을 깨달았어요! JavaScript 커뮤니티에서 유효성 검사가 점점 중요해지고 있는 개념인 것 같았어요.\n\n\n\n발표자는 io-ts에 대해 이야기하며 유효성 검사 스키마에서 타입을 쉽게 추론할 수 있다고 설명했습니다. 추론이라는 아이디어가 나를 순간적으로 사로잡았어요. 만약 테이블 스키마와 같은 임의의 객체에서 타입을 생성할 수 있다면 어떨까요?\n\nSequelize, Prisma 또는 Zod와 같은 도구의 구현을 분석하여 타입 추론을 이해하기 위해 노력했습니다. 이 이야기는 제 학습 내용을 요약하며 사용자 정의 스키마를 활용하여 타입을 생성하는 방법을 설명할 것입니다.\n\n# 소개\n\n본 이야기에서, TypeScript에서의 두 가지 유형 생성 범주를 고안했습니다: 정적과 동적. 정적 생성은 코드 생성기를 활용하며 동적 생성은 TypeScript 추론을 활용하여 실시간으로 타입을 제공합니다.\n\n\n\n# 정적 타입 생성\n\n스키마 파일을 기반으로 타입 정의를 생성하는 라이브러리 또는 프레임워크를 찾을 수 있습니다. Prisma가 좋은 예입니다만, Prisma는 타입 뿐만 아니라 클라이언트 코드도 생성합니다.\n\n정적 타입 생성은 세 단계의 프로세스로 생각할 수 있습니다:\n\n- 스키마 파일을 생성(또는 업데이트)합니다.\n- CLI를 사용하여 코드 생성기를 실행합니다.\n- 프로젝트에서 생성된 코드를 사용합니다.\n\n\n\n일반적으로 도구 제작자가 허용하는 어떤 언어로든 스키마 파일을 작성합니다. 그들은 프로그래밍 언어를 사용하는 대신 도메인 특화 언어(DSL)를 선택할 수도 있습니다. 이런 선택은 TypeScript에 익숙하지 않은 사람들도 스키마 파일에 기여할 수 있도록 할 수 있습니다.\n\n예를 들어, Prisma의 제작자들은 데이터 모델링 언어를 개발했습니다. 아래에 전형적인 스니펫을 보실 수 있습니다.\n\n```js\ngenerator client {\n  provider = \"prisma-client-js\"\n  output   = \"./client\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id String @unique\n}\n```\n\n이 스니펫은 코드 생성 및 모델 자체에 대한 지시사항을 모두 포함하고 있다는 점을 언급할 가치가 있다고 생각합니다!\n\n\n\n다음 명령어를 실행하여 TypeScript 코드를 생성할 수 있어요.\n\n```js\npnpm exec prisma generate\n```\n\nPrisma는 스키마 파일이 가리키는 디렉토리에 코드를 생성합니다. 아래에 생성된 코드의 사용 예시를 확인해보세요.\n\n```js\nimport { randomBytes } from \"node:crypto\";\nimport { PrismaClient } from \"./prisma/client\";\n\nconst createUser = async () =\u003e {\n  const prisma = new PrismaClient();\n  try {\n    const id = randomBytes(16).toString(\"base64url\");\n\n    return await prisma.user.create({\n      data: {\n        id,\n      },\n    });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n```\n\n\n\n데이터베이스 스키마 설계에 대해 궁금하다면, 아래 이야기를 읽어보세요:\n\n## 정적 타입 생성의 장점\n\n정적 타입 생성을 통해 비즈니스 로직 구조와 TypeScript를 분리할 수 있습니다.\n\n이를 통해 비개발자들이 독립적으로 스키마 파일에 기여할 수 있습니다. 비기술자에게 코딩 원리를 가르치는 대신, 도메인 특화 언어 개념을 빠르게 설명할 수 있습니다!\n\n\n\n또한, 사람들은 스키마 파일을 특정 디렉토리에 특정 확장자로 저장합니다. 코드베이스 전체를 찾는 대신에 효율적으로 찾을 수 있도록 도와줄 수 있습니다.\n\n마지막으로, 저는 TypeScript 추론이 강력하지만 일부 응용 프로그램에서는 제약이 있음을 발견했습니다. TypeScript가 개발하기 어려워지지 않도록 추론을 제한해야 한다고 생각합니다.\n\n제가 TypeScript 추론의 불가피한 한계에 대해 사례 연구를 진행했고, 아래에서 읽을 수 있습니다:\n\n## 정적 타입 생성의 단점\n\n\n\n지금까지 도메인 특화 언어를 사용하여 코드와 유형을 생성하는 방법에 대해 설명했습니다. 흥미롭게도 TypeScript 파일을 기반으로 코드를 생성할 수도 있습니다.\n\n프로젝트 내 각 파일에 대해 특정 디렉토리 구조 및 특정 이름으로 내보내기를 강제하기를 원할 수 있습니다. 예를 들어, 데이터베이스 모델을 모델 디렉토리에 각 파일로 구성하고, 파일 이름에 모델 이름을 포함할 수 있습니다. 각 파일은 스키마 이름 아래 모델 스키마를 내보내야 합니다.\n\n생성기를 구현하여 적절한 유형 규율을 달성할 수 있습니다. 이 생성기는 폴더 구조를 읽고 유형 정의를 작성합니다. 모델을 생성한 후에는 생성기를 실행해야 합니다.\n\n이러한 접근 방식은 지속적인 유형 차이로 이어질 수 있습니다. 모델을 변경하면 기존 유형 정의에 반영되지 않는 변경 사항을 도입할 수 있습니다. 파일을 유효성 검사하려면 TypeScript 오류가 없을 때까지 생성기를 계속 실행해야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_1.png)\n\n두번째, 스키마에 대한 모든 변경 사항은 이후에 명령을 실행해야 하며, 이 단계는 경험이 부족한 엔지니어들에게 쉽게 간과될 수 있습니다.\n\n세번째, TypeScript에는 인상적인 타입 추론이 포함되어 있기 때문에, 처음부터 정적으로 타입을 생성해야 하는 이유가 있을까요? 제 생각에는 그에 대한 좋은 이유가 필요합니다.\n\n네번째, 생성된 타입을 소스 제어에 커밋해야 할까요? 아마도 생성되는 것이 정확히 무엇인지에 따라 다를 것입니다.\n\n\n\n# 동적 유형 생성\n\n여기 예제를 통해 동적 유형 생성을 보여 드리겠습니다.\n\n누군가가 TypeScript에서 새로운 ORM 생성을 맡겨줬다고 상상해 봅시다. 우리는 먼저 SQL 데이터 유형을 위한 추상화를 생성하는 것으로 시작할 것입니다. 먼저, 행에서 nullable 값을 허용하거나 허용하지 않을 수 있는 열을 인식합니다.\n\nNullable 및 non-nullable 열 사이의 구분을 만들기 위해 고유한 심볼을 사용할 수 있습니다.\n\n\n\n```js\nexport const NULL: unique symbol = Symbol();\nexport const NOT_NULL: unique symbol = Symbol();\n```\n\n저는 심볼을 실수로 선택한 것이 아닙니다. 이제 첫 번째 유형을 설명하겠습니다.\n\n특정 데이터 유형 내에 정의된 널 가능성 일반 유형을 앵커하는 TNULLABLE 유형을 정의하겠습니다.\n\n```js\ntype TNULLABLE = typeof NULL | typeof NOT_NULL;\n```\n\n\n\n다시 말해, 단순히 true 또는 false로 nullability를 제어해서는 안 됩니다. NULL 및 NOT_NULL 기호에 바인딩된 일반 타입 내에 nullability를 포함시킬 것입니다.\n\nTCHAR 타입 정의를 살펴봅시다.\n\n```js\ntype TCHAR\u003cN extends TNULLABLE, L extends number\u003e = Readonly\u003c{\n  type: \"char\";\n  length: L;\n  nullable: N;\n}\u003e;\n```\n\n이 정의에서 N은 nullability를 관리하고, L은 SQL CHAR 열의 길이를 설정합니다.\n\n\n\n다음으로 CHAR 컬럼을 위한 빌더를 생성합니다. 클래스 생성자가 아니기 때문에 '빌더'라는 용어를 사용했습니다.\n\n```js\nconst CHAR = \u003cN extends TNULLABLE, L extends number\u003e(\n  nullable: N,\n  length: L\n): TCHAR\u003cN, L\u003e =\u003e ({\n  type: \"char\",\n  length,\n  nullable,\n});\n```\n\nCHAR(false, 255) 대신 CHAR(NULL, 255)로 작성할 수 있습니다. 전후 문맥을 알지 못해도 이전 표현식을 쉽게 이해할 수 있습니다.\n\n이제 SQL INTEGER 컬럼에 대해 비슷한 내용을 작성합니다.\n\n\n\n```js\ntype TINTEGER\u003cN extends TNULLABLE\u003e = Readonly\u003c{\n  type: \"integer\";\n  nullable: N;\n}\u003e;\n\nconst INTEGER = \u003cN extends TNULLABLE\u003e(nullable: N): TINTEGER\u003cN\u003e =\u003e ({\n  type: \"integer\",\n  nullable,\n});\n```\n\n이제 스키마 유형을 정의하는 시간이 왔습니다. 키-값 쌍으로 구성된 객체로 생각할 수 있습니다. 키는 열 이름을 나타내고 값은 해당 열 정의를 제공합니다. 아래 예제를 살펴보세요.\n\n```js\nexport type Schema = Readonly\u003c{\n  [K in string]?: TCHAR\u003cTNULLABLE, number\u003e | TINTEGER\u003cTNULLABLE\u003e;\n}\u003e;\n```\n\n스키마 유형을 정의한 후에는 예제를 진행할 수 있습니다. 다음 스니펫을 만들었습니다.\n\n\n\n```js\n상수 스키마 = {\n  a: CHAR(NULL, 255),\n  b: CHAR(NOT_NULL, 1),\n  c: INTEGER(NULL),\n  d: INTEGER(NOT_NULL),\n}을(를) 스키마로써 만족합니다;\n```\n\n저는 \"만족합니다\" 키워드를 의도적으로 사용했습니다. 스키마를 Schema 유형에 할당하고 싶지 않았기 때문에 추론에 부정적인 영향을 미치지 않을 수 있습니다! 대신, 스키마 정의가 Schema 유형을 만족하는지 확인할 수 있습니다.\n\n이제 가장 흥미로운 부분인 추론이 시작됩니다!\n\n아래에 두 가지 도우미 유형을 정의해보겠습니다.\n\n\n\n```js\n유형 NullableString\u003cN\u003e = N이 typeof NOT_NULL인 경우\n  ? string\n  : string | null;\n\n유형 NullableNumber\u003cN\u003e = N이 typeof NOT_NULL인 경우\n  ? number\n  : number | null;\n```\n\n이 범용 유형은 널 가능성을 켜고 끄는 데 사용됩니다. 이런 도우미들은 TypeScript에서 유형 생성 시 흔한 속임수로 생각합니다.\n\n이제 추론에 사용되는 유형을 최종적으로 정의할 수 있습니다.\n\n```js\n유형 Attributes\u003cT\u003e = {\n  [K in keyof T]: T[K]이 TCHAR\u003cinfer N, number\u003e의 확장인 경우\n    ? NullableString\u003cN\u003e\n    : T[K]이 TINTEGER\u003cinfer N\u003e의 확장인 경우\n    ? NullableNumber\u003cN\u003e\n    : never;\n};\n```\n\n\n\n천천히 설명해 드릴게요.\n\n먼저, 일반 타입은 스키마 타입입니다.\n\n둘째, 값만 변환합니다. 키는 그대로 유지됩니다.\n\n셋째, 값이 TCHAR 타입이면 널 가능성 일반 타입 N을 추론하고 NullableString 도우미 타입으로 전달합니다.\n\n\n\n우리는 N에 따라 문자열 또는 null을 반환할 것입니다.\n\nTINTEGER 유형에 대해서도 비슷한 작업을 수행합니다. 값이 명시적 유형과 일치하지 않는 경우 never 유형을 전달합니다.\n\nAttributes 타입을 다음과 같이 사용할 수 있습니다:\n\n```js\ntype A = Attributes\u003ctypeof schema\u003e;\n```\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다:\n\n\n타입 A의 정의는 다음과 같습니다:\n\n```js\ntype A = {\n    a: string | null;\n    b: string;\n    c: number | null;\n    d: number;\n}\n```\n\n## 동적 타입 생성의 장점\n\n나는 TypeScript에서 schema를 유지하는 것이 동적 타입 생성의 자연스러운 장점이라고 생각합니다.\n\n\n\n\n먼저, 스키마를 구현하기 위해 다른 언어를 생각해 낼 필요가 없습니다. 둘째, 스키마에 대한 모든 변경 사항은 프로젝트 전체에 즉시 타입 영향을 줍니다. 셋째, 스키마를 변경한 후에 생성기를 실행할 필요가 없습니다.\n\n## 동적 타입 생성의 단점\n\n이전에 언급했듯이, TypeScript 추론에는 한계가 있습니다. 특정 상황에서 정적 타입 생성으로 전환하면 복잡한 타입 추론 도우미를 만들 필요가 줄어듭니다.\n\n게다가 TypeScript에서 스키마를 유지함으로써 업데이트를 개발자에게 의존해야 합니다. 진행 중인 프로그래밍 언어의 고급 메커니즘을 비 전공자들이 처리할 것을 거의 기대할 수 없습니다.\n\n\n\n# 결론\n\n정적 또는 동적 유형 생성을 선택하기 전에 문제와 모든 가능한 옵션을 고려해야 합니다. 유형 생성이 내 문제를 해결하는 가장 좋은 방법인가요? 더 수고로운 만큼 기술적이지 않은 해결책이 있을까요?\n\n실제로 올바른 선택을 하는 것은 우리 산업에서의 중대한 영향을 미칩니다!\n\n또한 TypeScript의 아키텍트들이 시간이 지남에 따라 유형 추론의 기능을 확대할 것으로 예상됩니다. 저는 지난 6년간 이 언어를 사용해왔는데, 새로운 기능과 개선 사항의 수는 놀라울 정도로 많았습니다!\n\n\n\n이야기가 유형 생성의 모든 주의사항을 이해하는 데 도움이 되었고 유도 추론에 조금 흥미를 느끼게 했다면 좋겠어요.\n\n이 이야기가 흥미로웠다면 아래에서 QR 코드의 실용적 구현에 대한 다른 이야기를 읽어보세요:","ogImage":{"url":"/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-SecretsofTypeGenerationinTypeScript_0.png","tag":["Tech"],"readingTime":8},{"title":"앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript","description":"","date":"2024-05-14 13:45","slug":"2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png\" /\u003e\n\n# 아주 간단히 요약하면;\n\n약 1년 전, SvelteKit이 TypeScript에서 JSDoc으로의 전환 결정을 내렸을 때 개발자 커뮤니티에 주목할 만한 변화가 있었습니다. TypeScript는 라이브러리 개발에 이상적인 선택이 아니라고 명시하며 이 전환이 일어났는데, 이로 인해 개발자들 사이에서 논란이 일었습니다. 처음에는 이것이 발전이 아닌 퇴보로 보여 의심스러웠습니다. TypeScript는 심지어 이전 블로그 포스트 중 하나에서 추천하는 도구로 소개되기도 했습니다. 그러나 이 결정은 시간이 흐름에 따라 점차 나에게 와닿게 되었고, 구글 앱스 스크립트에서 유사한 접근 방식을 채택하게 되었습니다. 이 전환의 이유는 여러 가지가 있으며, 일부는 보편적으로 적용되는 이유이며, 다른 일부는 앱스 스크립트의 특이성과 관련된 이유입니다.\n\n여기에 다시 레포 및 NPM 페이지 링크가 있습니다.\n\n\n\n자 TypeScript를 처음 선택했던 이유와 그것보다 JSDoc를 선호하는 이유에 대해 알아봅시다.\n\n# TypeScript를 처음 선택한 이유\n\nTypeScript는 스크립팅 및 앱 개발 분야에서 게임 체인저였습니다. 이는 주로 견고한 타입 안전 기능 때문입니다. TypeScript를 사용하면 명시적으로 선언하거나 지능적으로 추론할 수 있는 정적 타입을 사용할 수 있어 안전하고 견고한 코드를 작성하는 능력을 향상시킵니다. Google Apps Script 개발자에게 TypeScript는 추가적인 이점을 제공합니다; npm i -D @types/google-apps-script 명령어를 사용하여 GAS 타입을 쉽게 설치할 수 있습니다. 이를 통해 이러한 유형을 정의하는 데 필요한 초기 투자 시간에도 불구하고 개발 프로세스 초기에 버그를 조기에 발견하는 데 큰 도움이 됩니다.\n\n또한 TypeScript는 타입에 대한 자동 완성을 제공하여 코드 품질과 유지 보수성을 향상시키고 코딩 프로세스를 가속화하며 오류를 줄입니다. 또한, 네임스페이스와 모듈을 사용할 수 있어 보다 조직적이고 모듈식 코드 구조를 구현할 수 있습니다. 이러한 기능들이 모두 Google Apps Script로 복잡하고 확장 가능한 애플리케이션을 개발하려는 개발자들에게 TypeScript를 매력적인 선택으로 만듭니다.\n\n\n\n# TypeScript의 단점\n\nTypeScript은 많은 이점을 제공하지만 몇 가지 개발자들에게는 특히 번거로울 수 있는 단점도 있습니다. 먼저, 컴파일 단계가 필요하다는 점은 주요한 문제일 수 있습니다. 이 과정은 빌드 시스템의 설정 및 유지에 추가적인 복잡성을 추가하므로 일부 팀이 추구하는 간소화된 프로세스와 일치하지 않을 수 있습니다.\n\n또한, TypeScript은 종종 추가적인 종속성을 필요로 합니다. 예를 들어 프로젝트에 단위 테스트를 통합할 때 추가 패키지를 다루어야 한다는 점과 Cucumber와 같은 프레임워크와 특히 호환성 문제가 발생할 수 있어 통합이 거의 불가능해질 수 있습니다. 이는 특정 테스트 프레임워크에 의존하는 팀들에게 문제가 될 수 있습니다.\n\n다른 중요한 단점은 많은 양을 요구한다는 점입니다. TypeScript는 타입을 명시적으로 선언해야하므로 코드가 비대해질 수 있습니다. 이로 인해 코드가 덜 우아해지며 타입 정의를 작성하고 관리하는 데 더 많은 시간이 소비되어 개발 속도가 느려질 수 있습니다.\n\n\n\n마지막으로, 이러한 유형을 최신 상태로 유지하는 것은 상당한 부담이 될 수 있습니다. 프로젝트가 규모가 확장되고 발전함에 따라 정확한 유형 정의를 유지하는 것은 지속적인 관심이 필요하며 유용한 자원을 다른 개발 활동으로 전환할 수 있습니다. 이 과부하는 TypeScript를 사용하는 이점을 초월할 정도로 중요할 수 있으며, 이로 인해 일부 팀은 선택을 재검토하기도 합니다.\n\n# Apps Script 특정 단점\n\nTypeScript를 사용하는 데 관한 주목할만한 Apps Script 특정 단점 중 하나는 clasp 사용에 관련이 있습니다. clasp는 TypeScript를 JavaScript로 컴파일하는 도구 중 하나로, Apps Script 런타임과 호환되는 방식으로 작동합니다. 그러나 아쉽게도 clasp는 더 이상 업데이트되지 않는 상태이며, 이는 상당한 위험을 야기할 수 있습니다. clasp가 의존하는 TypeScript 버전이 점점 구식화되고 있으며, 호환성 문제나 완전한 실패가 발생하기 전에 오랜 시간이 걸리지 않을 것입니다. 이 구식화로 인해 더 최신의 TypeScript 기능이나 업데이트에 의존하는 스크립트들이 실행 안 될 가능성이 있습니다.\n\nclasp의 기본 컴파일을 우회하려는 사람들을 위해서 자체 컴파일 구성을 설정하는 것은 대안이 될 수 있습니다. 그러나 이 방법은 자체적인 어려움을 포함하고 있습니다. 개발자들은 최종적인 JavaScript 출력이 Apps Script와 호환되도록 보장해야 합니다. 최소한, module.exports를 폴리필하는 노력이 필요하며, TypeScript 없이 이러한 조정을 관리하는 것이 간단하고 더 직관적일 수 있습니다.\n\n\n\n또한 Google Apps Script와 호환되는 JavaScript 번들링 과정은 이 시리즈에서 나중에 다룰 예정입니다. 이 과정은 Apps Script 환경에서 스크립트가 원활하게 실행되도록 보장하므로 ECMAScript 표준 및 기타 호환성 장벽과 관련된 문제를 피할 수 있습니다. 이러한 요소들은 Apps Script 컨텍스트에서 TypeScript 대안을 고려하는 강력한 이유가 됩니다. 이에 대해 더 자세히 알아볼 것입니다.\n\n# JSDoc의 구원\n\nJSDoc로 전환하면 Apps Script 환경에서 TypeScript의 복잡성과 오버헤드에 좌절한 사람들에게 매력적인 대안이 제공됩니다. JSDoc의 가장 중요한 장점 중 하나는 컴파일 단계가 필요하지 않다는 것입니다. 이는 개발 프로세스를 간소화하고 설정 시간을 줄이며 빌드 중에 발생하는 오류 가능성을 줄입니다. 또한 clasp의 기능을 망가뜨릴 염려없이 컴파일이 실패할 걱정을 할 필요가 없습니다.\n\n게다가 JSDoc는 추가적인 종속성 없이 작동합니다. 이 간소화된 접근 방식은 많은 종속성을 유지하는 환경에서 부담이 될 수 있는 곳에서 특히 유용하며, 충돌 및 관리 문제로 이어질 수 있는 가능성을 줄일 수 있습니다.\n\n\n\n복잡한 유형이 필요한 경우에도 JSDoc은 여전히 유연성을 제공합니다. 개발자들은 .d.ts 파일을 활용하여 복잡한 유형을 정의할 수 있으며, TypeScript의 엄격한 요구 사항을 완전히 따르지 않고 고급 유형 안전성이 필요한 중간 지점을 제공합니다.\n\n중요한 점은 JSDoc이 다수의 개발자가 필요로 하는 기본적인 기능을 지원하면서도 타입 체크와 자동 완성을 제공한다는 것입니다. 이러한 기능을 통해 개발자들은 추가적인 도구의 부담 없이 정확하고 효율적인 코드를 작성할 수 있습니다.\n\n마지막으로, JSDoc을 사용하는 주목할만한 장점 중 하나는 코드베이스에서 기술 문서를 직접 생성하는 능력입니다. 간단한 명령행 명령을 통해 JSDoc은 소스 코드의 주석을 서식이 있는 HTML 문서로 변환하여 문서 작성 및 업데이트를 일관되게 수행하기 쉽게 만듭니다. 이 기능은 사용자 채택 및 개발자 온보딩에 중요한 문서를 최신 상태로 유지해야 하는 프로젝트에서 특히 가치가 있습니다.\n\n# 결론\n\n\n\n종류들은 멋지지만 JSDoc이 TypeScript보다 우세합니다.\n\n# 시리즈의 다른 글들\n\n- 파트 1: 나는 Google Apps Script에서 console.table()이 필요했고, 여기에 대해 한 일입니다.\n- 파트 2: 소스 코드와 프로젝트 구조\n- 파트 3: JSDoc 대 TypeScript (바로 이 글)\n- 파트 4: 곧 배포 예정\n- 파트 5: 곧 배포 예정\n- 파트 6: 곧 배포 예정\n- 파트 7: 곧 배포 예정\n\n# 나에 대해\n\n\n\n저는 전업 Google Workspace 및 Google Cloud Platform 개발자이자 Workspace Google Developer Expert (GDE)입니다. 또한 Wurkspaces.dev의 창립자이기도 합니다. 프로젝트에 신뢰할 수 있는 개발자를 찾고 계시다면 저를 고용해보세요.\n\n# 쉽게 이해할 수 있는 영어로 🚀\n\n이 쉽게 이해할 수 있는 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우하는 것을 잊지 마세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지친 적이 있나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"LWC에서 Apex 메소드 사용하기","description":"","date":"2024-05-14 13:43","slug":"2024-05-14-WorkWithApexMethodInLWC","content":"\n\n![이미지](/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png)\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce가 제공하는 강력한 프레임워크로, 현대적이고 효율적인 사용자 인터페이스를 구축하는 데 사용됩니다. LWC의 기능을 향상시키는 주요 기능 중 하나는 Apex 메서드와 함께 작업할 수 있는 능력입니다. Apex 메서드를 사용하면 서버 측 작업을 수행하고 Salesforce 데이터베이스에서 데이터를 검색할 수 있어, 프런트엔드 LWC 컴포넌트와 백엔드 Salesforce 로직 사이에 원활한 통합이 제공됩니다. 이 블로그 포스트에서는 LWC에서 Apex 메서드를 사용하는 프로세스를 살펴보고 실제 예제를 통해 안내할 것입니다.\n\n이 주제에서는 LWC 컴포넌트에서 어떻게 Apex 메서드를 호출하는지에 대해 알아볼 것입니다.\n\n\n\n- 와이어 어댑터를 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n- 명령형 접근을 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n- 비동기 및 대기 접근 방법을 사용하여 Apex 메서드를 호출하는 방법을 소개합니다.\n\n라이트닝 웹 컴포넌트(LWC)에서 Salesforce 개발 시 고려해야 할 두 가지 주요 측면이 있습니다: Apex 메서드를 라이트닝 웹 컴포넌트로 가져오는 방법과 다른 컴포넌트에서 사용할 수 있도록 Apex 메서드를 노출하는 방법입니다.\n\n# 라이트닝 웹 컴포넌트로 Apex 메서드 가져오기\n\n## 1. Import문:\n\n\n\n라이트닝 웹 구성 요소에서 Apex 메서드를 사용하려면 해당 메서드를 구성 요소로 가져와야 합니다. 이 작업은 구성 요소의 JavaScript 파일에서 import 문을 사용하여 수행됩니다. import 문에는 Apex 메서드의 네임스페이스와 이름이 포함됩니다.\n\n```js\nimport apexMethodName from '@salesforce/apex/namespace.classname.apexMethodReference';\n```\n\n- apexMethodName - Apex 메서드를 식별하는 심볼입니다.\n- apexMethodReference - 가져올 Apex 메서드의 이름입니다.\n- classname - Apex 클래스의 이름입니다.\n- namespace - 구성 요소와 동일한 네임스페이스에 있는 클래스인 경우 네임스페이스를 지정하지 않습니다. 관리되는 패키지에 있는 클래스인 경우 관리되는 패키지의 네임스페이스를 지정합니다.\n\n예시:\n\n\n\n```js\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n```\n\n## 2. Apex 메서드 호출하기:\n\n한 번 가져온 후에 Apex 메서드를 컴포넌트의 JavaScript 파일에서 호출할 수 있어요. 이를 위해 반응형 데이터 가져오기에 `@wire` 데코레이터를 사용하거나 더 많은 제어를 위해 명령형 Apex를 사용할 수 있어요.\n\n```js\n// @wire 데코레이터 사용\n@wire(getAccountDetails, { accountId: '$recordId' })\nwiredAccount;\n \n// 명령형 Apex 사용\nconnectedCallback() {\n    getAccountDetails({ accountId: this.recordId })\n        .then(result =\u003e {\n            // 결과 처리\n        })\n        .catch(error =\u003e {\n            // 에러 처리\n        });\n}\n```\n\n\n\n위의 예시에서 'getAccountDetails'는 가져온 Apex 메서드입니다. 첫 번째 예시는 데이터를 반응적으로 가져오기 위해 `@wire` 데코레이터를 사용하고, 두 번째 예시는 `connectedCallback` 라이프사이클 훅에서 명령형 호출을 보여줍니다.\n\n# 컴포넌트에 Apex 메서드 노출하기\n\n## 1. Apex 클래스에 주석 추가:\n\nApex 메서드를 라이트닝 웹 컴포넌트에서 접근 가능하게 하려면 `@AuraEnabled` 또는 `@AuraEnabled(cacheable=true)`와 같은 주석을 추가해야 합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-WorkWithApexMethodInLWC_1.png\" /\u003e\n\n알아두세요!\n\nApex 메서드를 노출하려면 메서드가 `static`으로 표시되어 있어야 하며 반드시 `@AuraEnabled`로 주석 처리된 `global` 또는 `public`이어야 합니다.\n\n`@AuraEnabled(cacheable=true)`로 표시된 Apex 메서드는 클라이언트 측 Lightning Data Service 캐시를 확인한 후 서버에서 Apex 메서드를 호출하려면 네트워크 호출을 발생시키기 전에 확인됩니다.\n\n\n\n```js\npublic with sharing class MyApexController {\n    @AuraEnabled(cacheable=true)\n    public static String getAccountDetails(String accountId) {\n        // Apex logic to fetch account details\n        return 'Account details for ' + accountId;\n    }\n}\n```\n\n이 예제에서 `getAccountDetails`는 `@AuraEnabled(cacheable=true)`로 주석이 달려 있습니다.\n\n## 2. Lightning 웹 컴포넌트에서 가져오고 사용하기:\n\nApex 메서드가 주석 처리된 후, 이전 섹션에서 설명한대로 Lightning 웹 컴포넌트에서 가져와 사용할 수 있습니다.\n\n\n\n```js\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n\n// ...\n\n@wire(getAccountDetails, { accountId: '$recordId' })\nwiredAccount;\n```\n\n이제 Lightning Web Component에서 `getAccountDetails`를 사용하여 서버에서 데이터를 가져올 수 있습니다.\n\n이러한 단계를 따라 하면 Lightning Web Component로 Apex 메서드를 원활하게 가져와 데이터를 검색하고, Apex 클래스에서 Apex 메서드를 Lightning Web Component에서 사용할 수 있게 공개할 수 있습니다. 이를 통해 Salesforce 개발에서 프론트엔드와 백엔드 간의 효율적인 통신이 가능해집니다.\n\n각 시나리오를 예제 코드와 함께 단계별로 살펴보겠습니다:\n\n\n\n# 1. LWC에 Apex 메서드 연결하기\n\nSalesforce 데이터를 가져오려면 JS 파일에서 `@wire` 어댑터를 사용해야 합니다. 데이터를 받으려면 프로퍼티나 함수에 `@wire`를 사용할 수 있습니다. 반환된 데이터를 조작하려면 함수에 `@wire`를 사용하면 됩니다.\n\n구문:\n\n```js\nimport apexMethodName from '@salesforce/apex/namespace.classname.apexMethodReference';\n@wire(apexMethodName, { apexMethodParams })\npropertyOrFunction;\n```\n\n\n\n와이어 어댑터 예시\n\n```js\n// Apex 클래스(MyApexController)의 Apex 메서드\npublic with sharing class MyApexController {\n \n    @AuraEnabled(cacheable=true)\n    public static list\u003cAccount\u003e getAccountDetails(){\n        return [SELECT Id, Name, Rating, Type FROM Account LIMIT 10];\n    }\n}\n```\n\n```js\n\u003c!-- ldsWithApex.html --\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"LDS with Apex controller\"\u003e\n    \u003cdiv class=\"slds-p-horizontal_small\"\u003e\n      \u003ctemplate for:each={accData} for:item=\"data\"\u003e\n        \u003cdiv key={data.Id}\u003e\n          \u003cp\u003e\u003cstrong\u003eName: - \u003c/strong\u003e{data.Name}\u003c/p\u003e\n        \u003c/div\u003e\n      \u003c/template\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n// ldsWithApex.js\nimport { LightningElement, wire } from 'lwc';\nimport getAccountDetails from '@salesforce/apex/MyApexController.getAccountDetails';\n \nexport default class LdsWithApex extends LightningElement {\n \n  accData = [];\n \n  @wire(getAccountDetails)\n  accDetails({ data, error }) {\n    if (data) {\n      console.log(JSON.stringify(data));\n      this.accData = data\n      if (error)\n        console.log(error);\n    }\n  }\n}\n```\n\n\n\n이 예제에서는 `@wire` 데코레이터를 사용하여 `getAccountDetails` 메서드를 호출합니다. 결과는 accData 속성에 저장되며, 포맷된 이름은 템플릿에 표시됩니다.\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-05-14-WorkWithApexMethodInLWC_2.png\" /\u003e\n\n매개변수를 사용한 와이어 어댑터의 예시\n\n\n\n```js\n// ApexClassController에 있는 Apex 클래스의 Apex 메소드\n\npublic with sharing class ApexClassController {\n \n    @AuraEnabled(cacheable=true)\n    public static list\u003cAccount\u003e getAccountDetailsByRating(String accRating){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WHERE Rating =: accRating\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n```js\n\u003c!-- ldsWithApex.html --\u003e\n\n\u003ctemplate\u003e\n  \u003clightning-card title=\"Apex 컨트롤러에서 매개변수를 이용한 LDS\"\u003e\n    \u003cdiv class=\"slds-p-horizontal_small\"\u003e\n      \u003clightning-combobox name=\"rating\" label=\"등급\" value=\"{accRating}\" placeholder=\"등급 선택\" options=\"{options}\" onchange=\"{handleChange}\"\u003e\n      \u003c/lightning-combobox\u003e\n      \u003ctemplate for:each=\"{accDataByRating}\" for:item=\"accData\"\u003e\n        \u003cdiv key=\"{accData.Id}\"\u003e\n          \u003cp\u003e\u003cstrong\u003e이름: - \u003c/strong\u003e{accData.Name} \u003c/p\u003e\n        \u003c/div\u003e\n      \u003c/template\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n// ldsWithApex.js\n\nimport { LightningElement, wire } from 'lwc';\nimport filterAccountDetails from '@salesforce/apex/ApexClassController.getAccountDetailsByRating';\n \nexport default class LdsWithApex extends LightningElement {\n  accDataByRating = [];\n  accRating = '';\n \n  @wire(filterAccountDetails, { accRating: '$accRating' })\n  accDetailsByType({ data, error }) {\n    if (data) {\n      console.log(JSON.stringify(data));\n      this.accDataByRating = data;\n      if (error)\n        console.log(error);\n    }\n  }\n \n  get options() {\n    return [\n      { label: '핫', value: 'Hot' },\n      { label: '따뜻', value: 'Warm' },\n      { label: '차가운', value: 'Cold' }\n    ]\n  }\n \n  handleChange(event) {\n    this.accRating = event.target.value;\n    console.log('검색 등급:- ' + this.accRating);\n  }\n}\n```\n\n결과:\n \n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*Ij_zMfi-q9nY4eIt.gif)\n\n## 2. Apex 메서드를 명령적으로 호출하기\n\n라이트닝 웹 컴포넌트(LWC)에서 Apex 메서드를 명령적으로 호출하는 것은 JavaScript 코드에서 Apex 메서드에 직접 호출을 하여 호출이 언제, 어떻게 실행되는지에 대해 더 많은 제어를 제공합니다. `@wire` 데코레이터를 사용하는 것과 달리, 명령적인 Apex 호출은 일반적으로 사용자 상호작용, 라이프사이클 이벤트 또는 다른 동적 조건에 대응하여 프로그래밍적으로 시작됩니다.\n\n![이미지](/assets/img/2024-05-14-WorkWithApexMethodInLWC_3.png)\n\n\n\nMIND IT!\n\n메소드가 언제 호출되어야 하는지 제어하려면 명령형 접근 방식을 사용하세요.\n예를 들어, 버튼을 클릭하여 데이터를 가져오고 싶다면 명령형 접근 방식을 사용할 수 있습니다.\n\n사용하는 시점\n\n- cacheable=true로 주석이 달려 있지 않은 메소드를 호출할 때, 이는 데이터를 삽입, 업데이트 또는 삭제하는 메소드를 포함합니다.\n- 호출 시점을 제어할 때 (예: 버튼을 클릭하는 경우).\n- Task 및 Event와 같이 지원되지 않는 객체로 작업할 때.\n- `LightningElement`를 확장하지 않는 ES6 모듈에서 메소드를 호출할 때.\n\n\n\n```js\n// 에이펙스 클래스(ApexClassController)에 있는 에이펙스 메소드\n\npublic with sharing class ApexClassController {\n     \n    @AuraEnabled\n    public static list\u003cAccount\u003e getAccountDetailsImperatively(){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n```js\n\u003c!-- ldsWithApex.html --\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"Imperatively Apex 메소드 호출\"\u003e\n    \u003cdiv class=\"sIds-p-horizontal_small\"\u003e\n      \u003clightning-button variant=\"Brand\" label=\"계정 세부정보 가져오기\" title=\"acc details\" onclick=\"{handleClick}\"\u003e\n      \u003c/lightning-button\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"slds-p-horizontal_small\"\u003e\n      \u003ctemplate lwc:if=\"{accDetailsImperatively}\"\u003e\n        \u003ctemplate for:each=\"{accDetailsImperatively}\" for:item=\"item\"\u003e\n          \u003cdiv key=\"{item.Id}\"\u003e\n            \u003cp\u003e\u003cstrong\u003e이름: - \u003c/strong\u003e{item.Name}\u003c/p\u003e\n          \u003c/div\u003e\n        \u003c/template\u003e\n      \u003c/template\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n// ldsWithApex.js\nimport { LightningElement, wire } from 'lwc';\nimport getAccountDetailsImperatively from '@salesforce/apex/ApexClassController.getAccountDetailsImperatively';\n \nexport default class LdsWithApex extends LightningElement {\n  accDetailsImperatively = [];\n  error = '';\n \n  // Apex 메소드를 명령형적으로 호출하는 함수\n  handleClick() {\n    getAccountDetailsImperatively()\n      .then((result) =\u003e {\n        console.log(result);\n        this.accDetailsImperatively = result\n        this.error = undefined\n      })\n      .catch((error) =\u003e {\n        console.log(error);\n        this.accDetailsImperatively = undefined\n        this.error = error\n      })\n  }\n}\n```\n\n설명:\n\n\n\n\n1. Imports:\n\n- `import { LightningElement, wire } from ‘lwc’;`: 여기서는 LightningElement 및 wire와 같은 필요한 Lightning 웹 컴포넌트 모듈을 가져옵니다.\n- `import getAccountDetailsImperatively from ‘@salesforce/apex/ApexClassController.getAccountDetailsImperatively’;`: ApexClassController Apex 클래스에서 getAccountDetailsImperatively Apex 메서드를 가져옵니다.\n\n2. Class Definition:\n\n- `export default class LdsWithApex extends LightningElement`: 여기서는 LdsWithApex 클래스를 정의하고 LightningElement를 확장합니다. 이 클래스는 Lightning 웹 컴포넌트의 동작을 캡슐화합니다.\n\n\n\n3. 속성:\n\n- `accDetailsImperatively = []; `: 이 속성은 Apex 메서드에서 반환된 결과를 저장할 배열(accDetailsImperatively)입니다.\n- `error = ‘’; `: 이 속성은 Apex 메서드 호출 중 발생한 오류를 저장합니다.\n\n4. 명령형 Apex 메서드 호출:\n\n- `handleClick() '`: 이 메서드(handleClick)는 구성 요소에서 버튼 클릭과 같은 작업이 발생했을 때 호출됩니다.\n- `getAccountDetailsImperatively()`: 이것은 명령형 Apex 메서드 호출입니다. 가져오기된 Apex 메서드를 사용하여 계정 세부 정보를 가져옵니다.\n- `.then((result) =` ' … ') `: 이 부분은 성공 시나리오를 처리합니다. Apex 메서드 호출이 성공하면 결과가 콘솔에 로깅되고 `accDetailsImperatively` 속성이 결과로 업데이트됩니다.\n- `.catch((error) =` ' … ') `: 이 부분은 오류를 처리합니다. Apex 메서드 호출 중 오류가 발생하면 오류가 콘솔에 로깅되고 오류 메시지로 `error` 속성이 업데이트됩니다.\n\n\n\n사용 방법:\n\n이 컴포넌트는 버튼이나 다른 사용자 인터페이스 요소와 연결할 수 있는 메소드 (`handleClick`)를 노출합니다. 사용자가 해당 요소와 상호 작용할 때, 명령형 Apex 메소드인 (`getAccountDetailsImperatively`)가 호출되고, 결과나 오류가 적절히 처리됩니다.\n\n이 코드는 라이트닝 웹 컴포넌트에서 명령형 Apex를 사용하는 방법을 보여줍니다. 데이터를 가져오고 성공 및 오류 시나리오를 모두 처리합니다. 가져온 데이터는 컴포넌트에서 표시하거나 추가 처리를 위해 속성에 저장됩니다.\n\n출력:\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*ty-u1bBD3a58qUzR.gif)\n\nApex 메소드에 매개변수 값을 전달할 때, Apex 메소드의 매개변수와 일치하는 속성을 가진 객체에 값을 전달합니다.\n\n예를 들어, Apex 메소드가 문자열 매개변수를 사용한다면 직접 문자열을 전달하지 마세요. 대신 값이 문자열인 속성을 포함한 객체를 전달하세요.\n\n```js\n// Apex 클래스의 Apex 메소드 (ApexClassController)\npublic with sharing class ApexClassController {\n     \n    @AuraEnabled\n    public static list\u003cAccount\u003e getAccountDetailsImperatively(String rating){\n        return [SELECT Id, Name, Rating, Type \n                FROM Account\n                WHERE Rating =: rating\n                WITH SECURITY_ENFORCED LIMIT 10];\n    }\n}\n```\n\n\n\n```js\n\u003c!-- ldsWithApex.html --\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"매개변수와 함께 Apex 메서드를 취급하는 법\"\u003e\n    \u003cdiv class=\"slds-p-horizontal_small\"\u003e\n      \u003clightning-combobox name=\"rating\" label=\"등급\" value=\"{rating}\" placeholder=\"등급 선택\" options=\"{options}\" onchange=\"{handleRatingChange}\"\u003e\n      \u003c/lightning-combobox\u003e\n      \u003clightning-button variant=\"Brand\" label=\"계정 세부 정보 가져오기\" title=\"계정 세부 정보\" onclick=\"{buttonHandler}\"\u003e\n      \u003c/lightning-button\u003e\n    \u003c/div\u003e\n \n    \u003cdiv class=\"slds-p-horizontal_small\"\u003e\n      \u003ctemplate lwc:if=\"{accDetailsByRatingImperatively}\"\u003e\n        \u003ctemplate for:each=\"{accDetailsByRatingImperatively}\" for:item=\"item\"\u003e\n          \u003cdiv key=\"{item.Id}\"\u003e\n            \u003cp\u003e\u003cstrong\u003e이름: - \u003c/strong\u003e{item.Name}\u003c/p\u003e\n          \u003c/div\u003e\n        \u003c/template\u003e\n      \u003c/template\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n// ldsWithApex.js\n \nimport { LightningElement } from 'lwc';\nimport getAccountDetailsByRatingImperatively from '@salesforce/apex/ApexClassController.getAccountDetailsByRatingImperatively';\n \nexport default class LdsWithApex extends LightningElement {\n  rating = '';\n  error = '';\n  accDetailsByRatingImperatively = [];\n \n  get options() {\n    return [\n      { label: '뜨거운', value: 'Hot' },\n      { label: '따뜻한', value: 'Warm' },\n      { label: '차가운', value: 'Cold' }\n    ]\n  }\n \n  handleRatingChange(event) {\n    this.rating = event.target.value;\n  }\n \n  buttonHandler() {\n    getAccountDetailsByRatingImperatively({ rating: this.rating })\n      .then((result) =\u003e {\n        this.accDetailsByRatingImperatively = result\n        this.error = undefined\n      })\n      .catch((error) =\u003e {\n        this.error = error\n        this.accDetailsByRatingImperatively = undefined\n      })\n  }\n}\n```\n\n출력:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*TytD0CuSTNo7y-1i.gif\" /\u003e\n\n\n\n\n아래 링크를 방문하시면 더 많은 정보를 얻을 수 있어요:\n\n\"더 흥미로운 LWC 주제를 기다려주세요. Salesforce 개발 전문가가 되기 위해 Lightning Web Components 세계를 계속 탐험해보세요.\"\n\nLWC로 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png"},"coverImage":"/assets/img/2024-05-14-WorkWithApexMethodInLWC_0.png","tag":["Tech"],"readingTime":13}],"page":"108","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"108"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>