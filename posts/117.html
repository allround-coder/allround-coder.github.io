<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/117" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/117" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" href="/post/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS에서 상태 관리 다루기 흔한 문제와 해결책</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" href="/post/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 컴포넌트 슬롯과 리액트" href="/post/2024-05-14-WebComponentsslotsandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 컴포넌트 슬롯과 리액트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextAuth v5를 사용한 보호된 라우팅 구현하기" href="/post/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextAuth v5를 사용한 보호된 라우팅 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" href="/post/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" href="/post/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 19 베타 버전이 출시되었어요" href="/post/2024-05-14-React19betaisout"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 19 베타 버전이 출시되었어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-React19betaisout_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 19 베타 버전이 출시되었어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 19 베타 버전이 출시되었어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" href="/post/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" href="/post/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" href="/post/2024-05-14-ReactHowtostopre-renderinginReactComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link posts_-active__YVJEi" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"ReactJS에서 상태 관리 다루기 흔한 문제와 해결책","description":"","date":"2024-05-14 11:25","slug":"2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution","content":"\n\n![이미지](/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png)\n\nReactJS는 구성 요소 기반 아키텍처와 가상 DOM으로 유명한 JavaScript 라이브러리입니다. 그러나 ReactJS에서 상태를 관리하는 것은 응용 프로그램이 복잡해질수록 어려울 수 있습니다. 이 기사에서는 ReactJS 상태 관리에서 발생하는 일반적인 문제를 탐구하고 해결책을 제시할 것입니다.\n\n## 문제: 상태와 인스턴스 속성을 혼동하는 문제\n\n클래스 구성 요소에서 개발자들은 자주 로컬 상태 객체를 정의하고 `this`로 접근합니다. 그러나 상태 이외에도 로컬 인스턴스 속성을 정의할 수도 있습니다. 이로 인해 혼란이 생길 수 있습니다. 다음 코드에서 확인할 수 있습니다:\n\n\n\n```JavaScript\r\n1class 인사 extends React.Component { \n2  user = { \n3    name: \"World\", \n4  };\n5\n6  state = { \n7    name: \"World\", \n8  };\n9\n10  render() { \n11    return `안녕하세요 ${this.user.name}`; // \"안녕하세요 World\"을 반환합니다.\n12  }\n13}\r\n```\r\n\r\n이 예에서 사용자 속성과 상태 객체는 둘 다 값이 \"World\"인 name 속성을 포함하고 있습니다. 그러나 render 메서드는 상태 객체 대신 사용자 속성에 접근합니다. 이는 예상치 못한 동작을 유발할 수 있으며 상태를 일관된 방법으로 관리하기 어렵게 만들 수 있습니다. \r\n\r\n## 해결책: 애플리케이션 상태 관리에 상태(State)를 전적으로 사용하기\n\n\n\n혼란을 피하기 위해 응용 프로그램 상태를 관리할 때는 상태를 전적으로 사용하는 것이 좋습니다. 이것은 개발자들이 상태와 유사한 데이터가 포함된 로컬 인스턴스 속성을 정의하는 것을 피해야 함을 의미합니다. 대신에 모든 상태는 상태 객체에 정의되어야하며 this.state를 사용하여 액세스되어야 합니다.\n\n다음은 권장되는 방법을 사용하여 클래스 컴포넌트에서 상태를 관리하는 예시입니다:\n\n```js\nclass Greeting extends React.Component { \n  state = { \n    name: \"World\", \n  };\n\n  render() { \n    return `Hello ${this.state.name}`; // \"Hello World\"를 반환합니다.\n  }\n}\n```\n\n\n\n\n이 예제에서는 name 속성이 state 객체에 정의되어 있고 this.state.name을 사용하여 액세스됩니다. 이렇게 함으로써 name 속성이 애플리케이션 상태의 일부임을 명확히하고 적절히 관리되어야 함을 나타냅니다.\n\n## 결론\n\nReactJS에서 상태를 관리하는 것은 도전일 수 있지만, 최선의 방법을 따르면 도움이 될 수 있습니다. 이 글에서는 ReactJS 상태 관리에서 흔한 문제인 상태와 인스턴스 속성을 혼동하는 문제를 탐구하고 해결책을 제시했습니다. 애플리케이션 상태를 관리하기 위해 state를 전적으로 사용함으로써, 개발자들은 혼란을 피하고 애플리케이션을 유지보수 가능하고 확장 가능하도록할 수 있습니다.\n\n또한, React는 훅의 도입으로 상태를 관리하는 새로운 방법을 제공하는데, 이를 통해 클래스를 작성하지 않고도 디벨로퍼들이 상태와 다른 React 기능을 사용할 수 있습니다. 이는 상태 관리를 간소화하고 최선의 방법을 따르기 쉽도록 도와줄 수 있습니다.\n\n\n\n요약하면, ReactJS에서 상태를 관리하는 것은 세심한 주의와 일관된 방법을 요구합니다. 상태를 응용 프로그램 상태를 관리하기 위해 전적으로 사용하고 모베스트 프랙티스를 따르면, 개발자들은 애플리케이션이 유지보수 가능하고 확장 가능하며 이해하기 쉬운 것을 보장할 수 있습니다.\n\n# 쉽게 설명한 것 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 꼭 박수를 보내고 작가를 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"},"coverImage":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png","tag":["Tech"],"readingTime":3},{"title":"첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내","description":"","date":"2024-05-14 11:24","slug":"2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide","content":"\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png)\n\n이전에 작성한 기사에서(https://medium.com/@regondaakhil1509/getting-started-with-react-a-beginners-guide-to-setting-up-your-first-application-a6d8a1ae414), React 애플리케이션을 설정하는 과정을 안내했습니다. 이제 로컬 코드를 GitHub에 올리는 방법을 배우는 것이 시간입니다. 이 단계별 가이드는 새로운 리포지토리를 GitHub에 생성하고 로컬 리포지토리에 연결하고 코드를 원격 리포지토리에 푸시하는 방법을 보여줍니다.\n\nReact가 처음이거나 GitHub를 시작한지 얼마 안 된 경우에도 이 튜토리얼은 프로젝트를 온라인으로 만들어 공동 작업자나 잠재적인 고용주에게 접근 가능하도록 도와줄 것입니다. React 스킬을 다음 수준으로 끌어 올리기 위해 준비하세요!\n\n# 소개 - Git 및 GitHub에 대해\n\n\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png)\n\n깃\n\n- 깃은 코드 변경을 관리하는 버전 관리 시스템입니다.\n- 깃을 사용하면 개발자들은 코드 버전을 추적하고, 다른 사람들과 협업하며, 필요할 때 이전 버전으로 되돌릴 수 있습니다.\n- 깃은 여러 개발자가 동시에 동일한 프로젝트에 작업할 수 있는 분산 버전 관리 시스템입니다. 각 개발자는 자신의 로컬 머신에 코드 저장소의 완전한 복사본을 가지고 있습니다.\n- 깃에 대해 더 알아보려면 https://git-scm.com/about를 방문해보세요.\n\n깃허브\n\n\n\n- GitHub은 Git 저장소를 호스팅하는 웹 기반 플랫폼입니다.\n- 협업을 더 쉽게 만드는 풀 리퀘스트, 이슈 추적 및 코드 리뷰와 같은 기능을 제공합니다.\n- GitHub에는 개발자들이 서로를 팔로우하고 자신의 작업을 보다 넓은 커뮤니티와 공유할 수 있는 소셜 측면도 있습니다.\n- GitHub에 대해 더 알아보려면 https://github.blog/category/company/에서 확인할 수 있습니다.\n\n- GitHub는 Git 호스팅을 제공하는 유일한 플랫폼이 아닙니다.\n- 다른 Git 호스팅 플랫폼으로는 GitLab, Bitbucket 및 SourceForge 등이 있습니다.\n- GitHub는 사용하기 쉽고 다양한 기능을 갖춘 편리한 플랫폼이어서 인기가 많습니다.\n\n## 설정\n\n시작하기 전에 기술적 선행 조건이 모두 갖추어져 있는지 확인하는 것이 중요합니다. 가장 중요한 요구 사항은 로컬 머신에 Git이 설치되어 있어야 한다는 것입니다. 아직 Git을 설치하지 않은 경우 https://git-scm.com/downloads 에서 Git을 다운로드하고 설치할 수 있습니다.\n\n\n\n설치 과정을 확인하려면 터미널에서 다음 명령을 실행하세요:\n\n```js\ngit -v\n```\n\n예시(숫자는 시스템에 따라 다를 수 있습니다):\n\n![예시 이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_2.png)\n\n\n\n다음 단계는 아직 GitHub 계정을 만들지 않으셨다면 GitHub 계정을 생성해야 합니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_3.png)\n\nGitHub 대시보드에서 새 저장소를 만들려면 페이지의 오른쪽 상단을 나타내는 플러스 기호로 표시된 드롭다운 메뉴를 클릭하십시오. 거기서 \"New repository\"로 표시된 옵션을 선택하거나 New Repository를 클릭할 수 있습니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_4.png)\n\n\n\n그 다음으로, 양식을 완성해야 합니다.\n\n- \"저장소 이름\" 필드에 저장소 이름을 입력하세요.\n- 선택사항으로 \"설명\" 필드에 저장소에 대한 설명을 추가할 수 있습니다.\n- 저장소의 가시성 설정을 선택하세요. 저장소를 비공개로 유지하려면 \"비공개\"를 선택하세요. 그렇지 않으면 \"공개\"를 선택하세요.\n- 저장소에 README 파일을 만들고 싶다면 \"이 저장소에 README 파일 추가\" 확인란을 선택하세요.\n- 원하는 경우 저장소에 라이선스를 선택하세요. 인기 있는 오픈소스 라이선스 목록 중에서 선택하거나 라이선스를 추가하고 싶지 않다면 \"없음\"을 선택하세요.\n- \"저장소 만들기\" 버튼을 클릭하세요.\n\n![Image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_5.png)\n\n만세! 새로운 저장소를 만들었어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_6.png\" /\u003e\n\n다음 단계는 코드를 로컬에서 GitHub로 이동하는 것입니다.\n\n만약 처음으로 git을 설정하고 있다면, git을 이름 및 이메일로 구성해야 합니다. 터미널에서 다음 명령어를 실행하세요.\n\n```js\ngit config --global user.email \"Your_Email\"\ngit config --global user.name \"Your_Name\"\n```\n\n\n\n로컬 React 프로젝트에서 Git을 초기화하려면:\n\nVS Code에서 \"your_local_repo\" 폴더(저의 경우, my_portfolio)를 열고 터미널을 열어 해당 디렉토리에서 Git을 초기화하는 명령을 실행하세요.\n\n```js\ngit init\n```\n\n\n\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_7.png)\n\nGitHub의 원격 저장소 링크는 저장소 페이지에서 \"Code\" 버튼을 클릭하여 찾을 수 있습니다. 적절한 프로토콜을 선택(우리의 경우 HTTPS), URL을 클립보드에 복사하고, VS 코드 터미널에서 다음 명령을 실행합니다.\n\n```js\ngit remote add origin https://github.com/your-username/your-repo.git\n```\n\n변경 내용을 스테이징하고 커밋하세요:\n\n\n\n\nReact 프로젝트의 모든 파일을 준비하는 \"git add\" 명령어를 사용하고, 그 변경 사항을 커밋하기 위해 \"git commit\" 명령어를 사용하세요.\n\n```js\ngit add .\ngit commit -m \"커밋 메시지 작성\"\n```\n\nGitHub로 변경 사항을 푸시하세요:\n\n마지막으로, 커밋된 변경 사항을 GitHub 리포지토리에 푸시하기 위해 \"git push\" 명령어를 사용하세요.\n\n\n\n```js\ngit push -u origin main\n```\n\n와우! 이렇게 하면 로컬 React 파일이 GitHub에 업로드되어 원격 저장소에서 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_8.png)\n","ogImage":{"url":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 컴포넌트 슬롯과 리액트","description":"","date":"2024-05-14 11:22","slug":"2024-05-14-WebComponentsslotsandReact","content":"\n\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_0.png)\n\nReact에서 컨텐츠는 children 속성을 통해 컴포넌트로 전달됩니다. 이 속성은 요소의 JSX 태그 내에 캡슐화된 컨텐츠를 위해 특별히 설계되었습니다. 그러나 이 방법은 더 복잡한 템플릿이나 JSX를 컴포넌트의 다른 섹션에 배치해야 하는 경우 부족할 수 있습니다. 다행히 JSX는 함수와 JSX를 모두 props를 통해 전달할 수 있기 때문에 문제없이 이를 구현할 수 있습니다.\n\nWeb Components에서 컨텐츠 처리는 React와 약간 다릅니다. 컴포넌트가 HTML로 렌더링되기 때문에 함수나 HTML(또는 JSX)을 props를 통해 전달할 수 없습니다. 대신, SLOTS를 사용합니다. 이것들은 컴포넌트 내에서 다양한 유형의 HTML 블록을 배치할 수 있는 지정된 영역입니다. 복잡한 컴포넌트에서 적절한 구성을 위해 사용됩니다. 브라우저의 인스펙터에서 슬롯이 약간 다르게 나타날 수 있다는 점을 주목하는 것이 중요합니다.\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_1.png)\n\n\n\n\n웹 페이지의 코드 인스펙터에서는 리다이렉트 기호와 함께 'reveal' 옵션을 볼 수 있습니다. 이 옵션을 클릭하면 DOM 내에서 다른 블록으로 이동하며, 해당 지점에서 렌더링됩니다. 이 기능을 통해 개발자는 Web Components의 복잡한 구성 요소 구조에서 컨텐츠가 정확히 어디에 렌더링되는지 추적할 수 있습니다.\n\nStencil에서는 속성을 통해 HTML 내용을 전달하는 것이 가능합니다 (코드 인스펙터에서 'right'로 된 div에서 확인할 수 있습니다). 그러나 이는 Vanilla JS와 유사하게 처리됩니다. 이를 위해 HTML 내용은 문자열 형태로 속성을 통해 전달되어야 합니다. 그런 다음 componentDidLoad() 라이프사이클 메서드 내에서 @Watch로 데코레이팅된 함수가 트리거되어야 합니다. 이 함수는 querySelector를 사용하여 HTML 블록이 삽입될 특정 div를 찾습니다. 마지막으로, 찾은 요소의 innerHTML이 HTML 내용을 삽입하도록 변형됩니다.\n\n고려해야 할 주요 요소: HTML은 문자열로 시작하지만 중요한 점은 HTML이다. 따라서 style 태그가 사용되면 kebab-case 규칙을 준수해야 합니다. useRef()와 같이 특정 리액트 기능은 이 문맥에서 사용할 수 없으므로 자식 요소를 효율적으로 전달하는 가장 최적의 방법이 아닙니다. 결과적으로, 이러한 환경에서 자식 요소를 효과적으로 전달하는 유일한 방법은 슬롯(slots)을 통해 이루어지게 됩니다.\n\n```js\nimport { Prop, h, Component, Element, Watch } from '@stencil/core';\n\n@Component({\n  tag: 'mtf-slots',\n  styleUrl: 'mtf-slots.scss',\n  shadow: true,\n})\nexport class MotifSlots {\n  @Element() el: HTMLMtfSlotsElement;\n\n  @Prop() rightContent: string;\n\n  @Watch('rightContent')\n  rightContentChanged(newValue: string) {\n    const rightSlot = this.el.shadowRoot.querySelector('.right-slot');\n    if (rightSlot) {\n      rightSlot.innerHTML = newValue;\n    }\n  }\n\n  componentDidLoad() {\n    this.rightContentChanged(this.rightContent);\n  }\n\n  render() {\n    return (\n      \u003cdiv class=\"container\"\u003e\n        \u003cdiv class=\"flexrow\"\u003e\n          \u003cdiv class=\"border-left\"\u003e\n            \u003cslot name=\"left\"\u003eLeft for Defect\u003c/slot\u003e\n          \u003c/div\u003e\n          \u003cslot name=\"middle\"\u003e\u003c/slot\u003e\n          \u003cdiv class=\"right-slot\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n\n\n이 그림에서 왼쪽과 가운데의 슬롯에 대한 두 가지 다른 접근 방식과 오른쪽 슬롯에 대한 프롭스가 표시되어 있습니다. 슬롯은 복잡성이 없지만 프롭스의 경우 코드를 많이 추가해야 합니다. 클래스, componentDidLoad 함수, 쿼리 선택기와 함께 @watch 함수 및 innerHTML을 사용하여 이러한 프롭스를 추가해야 하기 때문에 하나의 작업에 대해 많은 코드가 필요합니다.\n\nReact에서 웹 구성 요소와 상호 작용할 때 슬롯을 활용하는 데 완전한 호환성을 보장합니다. 간단히 해당 위치에 웹 구성 요소의 슬롯 이름을 가진 'slot' 속성을 할당하면 됩니다. 이는 React의 'children' 프롭과 유사하게 작동하여 useRef의 사용 및 그 안에서 상태를 표현하는 것을 허용합니다. 이렇게 함으로써 '슬롯'과 동일한 기능을 구현할 수 있습니다. 프롭스를 사용할 경우 HTML이 해당 위치에 '베이크'됩니다. 그러나 슬롯의 경우 — React 구성 요소에서 소비되는 경우이든 아니든 — DOM의 다른 부분을 참조하는 링크가 해당 섹션에 포함됩니다.\n\n# 결론\n\n\n\n대부분의 경우 HTML을 프롭스를 통해 웹 컴포넌트로 전송하여 작동하지만, 이것은 가장 최적의 방법은 아니며 필요한 모든 기능을 갖추지 못할 수 있습니다. 따라서 React와 100% 호환되는 슬롯을 사용하는 것이 항상 권장됩니다.","ogImage":{"url":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"},"coverImage":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png","tag":["Tech"],"readingTime":3},{"title":"NextAuth v5를 사용한 보호된 라우팅 구현하기","description":"","date":"2024-05-14 11:21","slug":"2024-05-14-ImplementingProtectedRoutingwithNextAuthv5","content":"\n\n![이미지](/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png)\n\n이 글에서는 Next.js 애플리케이션에서 NextAuth v5를 사용하여 클라이언트 측 및 서버 측 경로를 보호하는 방법을 알려드릴 거에요.\n\nNextAuth.js는 Next.js 애플리케이션에서 널리 사용되는 인증 라이브러리로, 버전 5가 출시되면서 여러 가지 주목할만한 개선 사항과 변경 사항이 소개되었어요. 이 최신 버전에서 중요한 업데이트 중 하나는 미들웨어 시스템에서 관찰되어요. 미들웨어 API가 향상되어 인증 흐름과 접근 제어에 대해 더 많은 유연성과 제어를 제공하고 있어요.\n\n그럼 시작해봅시다!\n\n\n\n## 단계 1 — 새로운 Next.js 프로젝트를 생성하고 필요한 패키지 설치하기\n\n이 글에서는 Next.js 애플리케이션을 만드는 방법에 대해 자세히 다루지는 않겠지만, nextAuth를 사용하기 위해서는 최신 버전이 필요합니다.\n\n```js\nnpm install --save next-auth\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_1.png\" /\u003e\n\n\n\n## 단계 2— 애플리케이션 내에 nextAuth 제공자 설정하기\n\n이 예제에서는 Google을 인증 제공자로 사용할 것입니다. 이제 Next 앱 내에 \"services\"라는 새 폴더를 만들고 그 안에 auth.ts라는 새 파일을 생성하세요. 파일을 만든 후 아래 코드를 추가하세요.\n\n```js\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\n\nexport const {\n  handlers: { GET, POST },\n  auth\n} = NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID as string,\n      clientSecret: process.env.GOOGLE_SECRET as string\n    })\n  ],\n  pages: {\n    signIn: '/login'\n  }\n});\n```\n\n반드시 .env 파일을 만들어서 google 클라이언트 ID와 clientSecret를 추가해주세요.\n\n\n\n다음으로, Next 앱 내에서 api 디렉토리(페이지 디렉토리 내부) 안에 새 폴더를 만들어주세요. 폴더의 이름은 `auth`로 지어주세요. 그 폴더 안에 `...nextAuth`(대소문자 구분 필수)라는 폴더를 만들고, 그 안에 `route.ts` 파일을 생성해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_2.png\" /\u003e\n\n해당 파일을 생성한 후, 아래 코드를 추가해주세요.\n\n```js\nexport { GET, POST } from '../../../../services/auth';\nexport const runtime = 'edge';\n```\n\n\n\n이제 제공자 설정이 모두 끝났으니, useContext API와 유사하게 전체 앱에 인증 상태를 제공하는 다른 컴포넌트를 사용하여 모든 구성 요소와 라우트를 감싸는 작업을 진행해 보겠습니다.\nrootlayout.ts 파일 내에서 세션 제공자(SessionProvider)를 사용하여 컴포넌트를 감싸세요.\n\n```js\nimport './globals.css';\n\nimport Navbar from '../components/nav-bar/navbar';\nimport { SessionProvider } from 'next-auth/react';\n\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\" className=\"h-full\"\u003e\n      \u003cbody className=\"h-full flex flex-col\"\u003e\n          \u003cSessionProvider\u003e\n            \u003cNavbar /\u003e\n            \u003cmain className=\"flex-1\"\u003e{children}\u003c/main\u003e\n          \u003c/SessionProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n## 단계 3 — 모든 signIn 및 signOut 함수 구현\n\n그런 다음 nextAuth를 사용하여 모든 signIn 및 signOut 함수를 구현해야 합니다. 그러나 이 문서에서는 해당 함수를 구현하지 않겠습니다. 필요한 라우트를 보호하는 방법만 안내해 드리겠습니다.\n\n\n\n## 단계 4 — 클라이언트 측과 서버 측 라우트를 보호하는 미들웨어 생성\n\n이 접근 방식에서는 클라이언트 측과 서버 측 라우트를 보호하기 위해 미들웨어를 사용할 것입니다. 먼저 src 폴더 안에 middleware.ts라는 새 파일을 만들고 다음 코드를 추가해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_3.png\" /\u003e\n\n```js\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nconst protectedRoutes = [\n  '/dashboard',\n  '/profile',\n];\nconst unprotectedRoutes = ['/', '/login'];\n\nimport { auth } from './services/auth';\n\nexport default async function middleware(request: NextRequest) {\n  const session = await auth();\n\n  const isProtectedRoute = protectedRoutes.some((prefix) =\u003e\n    request.nextUrl.pathname.startsWith(prefix)\n  );\n\n  if (!session \u0026\u0026 isProtectedRoute) {\n    const absoluteURL = new URL('/', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n  if (session \u0026\u0026 unprotectedRoutes.includes(request.nextUrl.pathname)) {\n    const absoluteURL = new URL('/dashboard', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n}\n```\n\n\n\n해당 코드에는 \"protectedRoutes\"와 \"unprotectedRoutes\"라우트가 몇 개 있습니다. 다음 js 애플리케이션에서 라우트를 보호하려면 이 배열에서 원하는 라우트를 추가하거나 제거할 수 있습니다.\n\n전체 문서를 보려면 방문해주세요.\n세미콜론 — 기술 블로그 (semicolon-blog.vercel.app)\n\n우리는 클라이언트 측과 서버 측 라우트를 성공적으로 보호했다고 생각합니다. 감사합니다! 👏👏👏","ogImage":{"url":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드","description":"","date":"2024-05-14 11:19","slug":"2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents","content":"\n\n![이미지](/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png)\n\n안녕하세요! 제 페이지로 돌아오신 여러분을 환영합니다. 당신이 경험 많은 팔로워이든 처음 방문자이든, 여기 오신 것을 매우 기쁘게 생각합니다.\n\n오늘의 주제는 귀여울 정도로 흥미로울 것입니다. 그 녀석이야; CSS-in-JS를 사용한 스타일링의 궁극적인 안내서인 Styled Components입니다. 우리는 JavaScript 내에서 CSS를 직접 작성하는 세계로 들어가보겠습니다. 이 방법이 React 애플리케이션의 스타일링에 제공하는 힘, 효율성 및 유연성을 탐구할 것입니다.\n\n# 소개:\n\n\n\n오케이, 웹 애플리케이션을 스타일링하는 것은 음식을 준비하는 것과 같다고 상상해 봅시다. 당신은 재료가 가득한 식료품실(스타일)과 따를 레시피(HTML 구조)가 있습니다. 그러나 전통적인 냄비나 프라이팬 대신에 당신은 마법의 지팡이 🪄 를 휘두르면서 쉽게 쿨리너리 창작물을 창조할 수 있는 마법을 갖고 있습니다. 이것이 CSS-in-JS의 마법입니다, 특히 Styled Components의 힘을 빌릴 때에는요.\n\n이 포괄적인 기사에서, 저는 Styled Components 설정과 활용, 시각적 및 실용적 예제 탐구, 이 강력한 스타일링 방법론의 모든 잠재력을 발휘하는 방법을 안내하겠습니다.\n\n# CSS-in-JS가 필요한 이유? 캐스케이딩 스타일시트 괴물을 물리치다\n\nCSS-in-JS는 스타일을 구성하는 더 \"원자적\"인 방법을 제공하여 그 스타일을 사용하는 컴포넌트로만 제한하는 방법을 제공합니다. 반면에, 전통적인 CSS는 스타일에 대한 세심한 통제를 제공하지만, 스타일링에 대한 도전과 같은 문제점도 도입합니다.\n\n\n\n- 특이성 전쟁: 이름 충돌과 스타일 재정의로 CSS 코드가 꼬인 문제가 발생할 수 있어 유지 보수가 악몢화될 수 있습니다.\n- 전역 범위 오염: 전역 스타일은 의도하지 않은 부분에 영향을 미칠 수 있습니다.\n- 컴포넌트 재사용성 문제: 스타일링 컴포넌트가 코드베이스 전체에 흩어져 있어 번거로울 수 있습니다.\n\nCSS-in-JS는 스타일을 JavaScript 컴포넌트 내에 직접 통합함으로써 이러한 문제에 대응합니다. 동적 스타일링과 향상된 유지 보수성 및 재사용성과 같은 여러 가지 이점을 제공합니다.\n\n참고: Styled-Components는 React/JavaScript 라이브러리를 위해 설계된 라이브러리이기 때문에 HTML 및 CSS에서 직접 사용할 수 없습니다. React 컴포넌트 구조와 JSX 구문과 같은 기능을 활용하여 CSS 스타일을 React 컴포넌트 내에 통합하도록 특별히 설계되었습니다.\n\n여기에서 CSS-in-JS의 이점을 확인해보세요.\n\n\n\n# 스타일드 컴포넌트 시작하기\n\n## 설치 및 설정\n\n스타일드 컴포넌트를 시작하기 위해 준비해야 할 사항은 다음과 같습니다:\n\n- React 설정: 기본적인 React 프로젝트가 설정되어 있어야 합니다. Create React App과 같은 도구를 사용하여 이 프로세스를 간편화할 수 있습니다 (https://create-react-app.dev/).\n- Styled Components 설치: npm 또는 yarn을 사용하여 Styled Components 라이브러리를 설치하세요.\n\n\n\n```js\nnpm install styled-components\n```\n\n설치가 완료되면 Styled Components를 프로젝트에 import하여 즉시 사용할 수 있습니다.\n\n# 심층 분석, 기본 구문 및 사용\n\n## - 기본 사용법 및 구문\n\n\n\nStyled Components는 스타일을 정의하기 위해 태그된 템플릿 리터럴을 활용합니다. 아래는 styled button 컴포넌트를 만드는 기본적인 예제입니다:\n\n```js\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: #007bff;\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return \u003cButton\u003eClick me\u003c/Button\u003e;\n};\n```\n\n## 스타일링된 컴포넌트 만들기\n\nStyled Components를 사용하면 HTML 요소나 재사용 가능한 컴포넌트 기본 요소의 사용자 정의된 스타일 버전을 생성할 수 있습니다. 예를 들어;\n\n\n\n```js\nconst StyledDiv = styled.div`\n  background-color: #f0f0f0;\n  padding: 1rem;\n`;\n\n// 사용 방법\nconst MyComponent = () =\u003e {\n  return \u003cStyledDiv\u003eHello, world!\u003c/StyledDiv\u003e;\n};\n```\n\nStyled Components를 사용하면 가능성이 무한합니다. 전통적인 CSS로 스타일을 지정하는 것과 동일하게 모든 컴포넌트나 HTML 요소에 스타일을 적용할 수 있지만, 스코피잉 및 재사용성의 추가 혜택이 있습니다.\n\n## - Styled Components in Action: Building Common UI Elements (with Illustrations)\n\n핵심 개념을 이해했으니, Styled Components를 사용하여 다양한 UI 요소를 스타일링하는 방법을 살펴보겠습니다.\n\n\n\n\n- 버튼: 이전 예제에서 볼 수 있듯이, 스타일된 컴포넌트는 사용자 정의 스타일을 가진 재사용 가능한 버튼을 만드는 데 뛰어납니다.\n- 카드: 스타일된 컴포넌트를 사용하여 시각적으로 매력적이고 정보를 제공하는 카드를 만들어보세요.\n- 아바타 이미지: 카드용 스타일링된 아바타 이미지를 만들어보세요.\n\n```js\nimport styled from \"styled-components\";\n\nconst Card = styled.div`\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 4px rgba(0.1, 0.1, 0.1, 0.2);\n  padding: 20px;\n  margin: 10px;\n`;\nconst CardTitle = styled.h2`\n  font-size: 1.2em;\n  margin-bottom: 10px;\n  align-item: center;\n  text-align: center;\n`;\nconst CardContent = styled.p`\n  margin-bottom: 10px;\n`;\nconst Button = styled.button`\n  padding: 10px 20px;\n  background-color: #007bff;\n  color: #fff;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\nconst AvatarImage = styled.img`\n  margin: 0px 20px 0px 0px;\n  height: 40px;\n  border-radius: 50%;\n  display: block;\n  margin: auto;\n`;\n\nfunction ProductCard() {\n  return (\n     \u003cCard\u003e\n    \u003cCardTitle\u003eJames Washington\u003c/CardTitle\u003e\n    \u003cAvatarImage\n      src=\"https://miro.medium.com/v2/resize:fit:740/1*ooOH6jo8I0ns0J-BE0SAow.jpeg\"\n      alt={name}\n    /\u003e\n    \u003cCardContent\u003e\n      Imagine styling your web applications like preparing a dish. You have a\n      pantry full of ingredients (styles) and a recipe (HTML structure) to\n      follow. But instead of traditional pots and pans, you wield a magic wand\n      🪄 that lets you conjure up your culinary creations effortlessly. This\n      is the magic of CSS-in-JS, particularly when wielded with the power of\n      Styled Components.\n    \u003c/CardContent\u003e\n    \u003cButton\u003eTry Now\u003c/Button\u003e\n  \u003c/Card\u003e\n  );\n}\n```\n\n실시간 미리보기🛠️:\n\n이 샌드박스 환경에서 실시간 미리보기를 살펴보세요. 자유롭게 실험하고 플레이그라운드 내에서 여러 가지 스타일링 기술을 적용해보세요.\n\n\n\n엔지니어로서 프로젝트를 진행하며 복잡성이 증가함에 따라 개발을 간소화하기 위해 재사용 가능한 구성 요소의 가치를 깨달았어요. 그래서 Styled Components를 주요 스타일링 방법으로 사용하여 만든 컴포넌트 라이브러리인 Vinyl Component Blocks를 만들었죠. Vinyl Component Blocks는 UI 컴포넌트 생성과 관련된 반복 작업을 줄이고 효율성을 촉진하며 일관된 개발 경험을 제공하는 것을 목표로 합니다. GitHub에서 라이브러리를 살펴보고, Styled Components를 사용하여 복잡한 UI 아키텍처를 어떻게 활용하는지 확인해보세요.\n\n더 많은 정보는 아래 링크를 확인해보세요:\n\n- Styled Components 공식 문서: 라이브러리의 기능과 API 참조를 더 깊이 파고들어보세요: https://styled-components.com/docs\n- Styled Components를 활용한 고급 기술: 테마 지정, 중첩, 전역 스타일 등과 같은 고급 기술을 탐구해보세요: https://styled-components.com/docs/api\n- Vinyl Component Blocks: 컴포넌트 라이브러리 및 기능을 탐색하고, Styled Components를 활용하여 복잡한 UI 아키텍처를 어떻게 구현하는지 확인하세요: https://github.com/Vinyl-Davyl/vinyl-component-blocks\n\n## - Styled Components를 활용한 스타일링 전략\n\n\n\n스타일드 컴포넌트의 힘을 발휘해보세요: 동적이고 재사용 가능한 UI를 위한 전략들. 스타일드 컴포넌트는 스타일링 능력을 향상시키는 다양한 기능을 제공합니다:\n\n- 전역 스타일 대 컴포넌트별 스타일\n\n스타일드 컴포넌트는 전역 스타일과 컴포넌트별 스타일을 정의하는 데 유연성을 제공합니다. 전역 스타일은 createGlobalStyle API를 사용하여 정의할 수 있습니다.\n\n```js\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyles = createGlobalStyle`\n  body {\n    font-family: 'Roboto', sans-serif;\n    background-color: #f8f8f8;\n  }\n`;\n\nconst MyApp = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cGlobalStyles /\u003e\n      \u003cMyComponent /\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n\n\n컴포넌트별로 스타일이 캡슐화되어 있습니다. 이전 예제와 같이요.\n\n이 방식을 통해 응용 프로그램 전체에서 일관된 디자인 시스템을 유지할 수 있으면서도 컴포넌트별 스타일의 모듈성을 누릴 수 있어요.\n\n2. Props로 테마 적용 및 사용자 정의\n\nStyled Components의 주요 기능 중 하나는 컴포넌트 props에 따라 스타일을 사용자 정의할 수 있는 기능이에요. 이는 동적 스타일 및 테마를 가진 재사용 가능한 컴포넌트를 생성하는 데 특히 유용합니다.\n\n\n\n```js\nconst Button = styled.button`\n  background-color: ${(props) =\u003e (props.primary ? '#007bff' : '#6c757d')};\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cButton primary\u003e주 버튼\u003c/Button\u003e\n      \u003cButton\u003e보조 버튼\u003c/Button\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n프롭스(props)를 활용하여 중복 코드를 방지하면서도 다양한 사용 사례에 맞게 유연한 컴포넌트를 생성할 수 있습니다.\n\n- 중첩(Nesting): 보다 복잡한 레이아웃 및 조직을 위해 서로 중첩된 스타일을 활용할 수 있습니다.\n- Styled System 통합: 통합 스타일링 접근을 위해 Styled Components와 같은 인기 있는 스타일링 시스템(Bootstrap 또는 Material-UI)을 활용할 수 있습니다.\n\n# Styled Components 이상: 대안 탐색하기\n\n\n\n\nStyled Components는 React 애플리케이션을 스타일링하는 인기 있는 선택지입니다. 그러나 탐색할 가치가 있는 여러 가지 대안이 있습니다. Emotion, JSS, CSS Modules는 각각 고유한 특징과 사용 사례를 가진 실용적인 옵션입니다.\n\n## Emotion\n\nEmotion은 다른 CSS-in-JS 라이브러리로, Styled Components와 유사한 기능을 제공하지만 자체 CSS 프롭 지원 및 자동 벤더 프리픽싱과 같은 추가 기능을 제공합니다.\n\n## JSS\n\n\n\nJSS (JSS는 인라인 스타일 및 테마에 매우 좋습니다)은 인라인 스타일과 테마에 중점을 둔 CSS-in-JS 라이브러리입니다. 이는 컴포넌트 속성에 따라 스타일을 동적으로 생성하기 위한 강력한 API를 제공하여 매우 사용자 정의 가능한 UI 컴포넌트를 구축하기에 이상적입니다.\n\n## CSS 모듈\n\nCSS 모듈은 React 애플리케이션에서 스타일링하는 다른 접근 방식으로, 웹팩과 같은 번들러에서 내장된 CSS 모듈 지원을 활용합니다. CSS 모듘을 사용하면 전통적인 CSS 파일을 작성하고 컴포넌트로 가져와 로컬 범위 및 자동 클래스명 생성과 같은 이점을 누릴 수 있습니다.\n\n저는 모든 JavaScript 스타일링 라이브러리에 대해 전문가는 아니에요. 제 경험이 주로 스타일드 컴포넌트와 관련이 있습니다. 이것은 내가 한 대부분의 작업에서 인기가 많은 훌륭한 도구입니다.\n\n\n\n# 결론 및 다음 단계\n\n축하해요!🎊 이제 Styled Components를 사용한 CSS-in-JS 스타일링의 기술을 정복했어요. 이 지식을 바탕으로 멋진 UI 구성 요소를 만들어 웹 애플리케이션을 더 생동감 있게 만들 수 있을 거예요.\n\n하지만 스타일링을 정복하는 것은 계속되는 여정이에요. 새로운 기술을 탐험하고 다양한 라이브러리를 실험하며 프론트엔드 개발의 최신 트렌드를 계속해서 따라가 주세요. 헌신과 실력 향상으로 함께 하겠습니다. 더 많은 업데이트와 이런 콘텐츠를 기대해 주세요!\n\n# 그림 및 참고자료\n\n\n\n- 스타일된 컴포넌트 공식 문서\n- Emotion 공식 문서\n- JSS 공식 문서\n- CSS Modules 공식 문서\n- 멋진 리액트 컴포넌트를 위한 GitHub 저장소\n- Vinyl-Component-Blocks, 스타일된 컴포넌트 기반 UI 라이브러리\n\nStyled Components 💅🏻를 사용하여 CSS-in-JS의 스타일링 세계를 정복하기 준비가 되었습니다. 다음에 또 만나요, Merci!","ogImage":{"url":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"},"coverImage":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png","tag":["Tech"],"readingTime":8},{"title":"코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램","description":"","date":"2024-05-14 11:18","slug":"2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative","content":"\n\nReact 또는 React Native 개발자이신가요? 코딩 경험을 더욱 향상시켜보고 싶다면요? Visual Studio Code(VS Code)는 이미 웹 및 모바일 앱 개발에 대한 환상적인 선택지입니다. 하지만 이 멋진 10가지 확장 기능을 추가하여 더욱 효율적으로 개발할 수 있습니다. 이 확장 기능들은 시간을 절약할 뿐만 아니라 코딩을 더욱 쉽게 만들어줍니다.\n\n1. ESLint\n\nESLint에 대해 들어본 적이 있을 것입니다. 그것이 그렇듯 유용하답니다. ESLint는 여러분의 코드를 훌륭한 동반자로 만들어 줍니다. 자바스크립트 및 리액트 코드에서 오류를 찾아주고 최고의 관행을 준수하도록 도와줍니다. 이 확장 기능을 사용하면 코드를 작성하는 도중 문제점을 발견하여 깨끗하고 일관된 코드를 유지할 수 있습니다.\n\n2. Prettier — Code Formatter\n\n\n\n끝없는 코드 형식에 대한 논쟁을 되새김없이 안녕하세요! Prettier가 미리 정의된 규칙에 따라 코드를 자동으로 서식 지정하여 코드베이스를 균일하고 아름답게 만들어 줍니다. 개인 코드 스타일리스트가 있는 것 같아요.\n\n3. React 스니펫\n\n일일이 입력하는 대신 몇 글자만 입력하면 코드가 마법처럼 나타납니다! React 스니펫은 다양한 React 코드 스니펫을 제공하여 시간을 절약하고 오타를 방지합니다.\n\n4. Bracket Pair Colorizer\n\n\n\n중첩된 코드 블록을 추적하는 것은 머리 아플 수 있어요. Bracket Pair Colorizer가 여기 있어 요. 괄호에 구별되는 색상을 할당하여 일치하는 쌍을 빠르게 확인할 수 있게 해 줍니다.\n\n5. Auto Close Tag\n\n이제 HTML 또는 XML 태그를 닫는 것을 잊을 일이 없어요. Auto Close Tag은 열린 태그를 입력하는 즉시 자동으로 닫히는 태그를 추가하여 구조화된 마크업을 보장해 줍니다.\n\n6. Auto Rename Tag\n\n\n\n매칭 태그는 훌륭하지만 하나를 변경하려면 어떻게 할까요? Auto Rename Tag 기능이 모두 처리해줍니다. 하나의 태그 이름을 변경하면 다른 태그도 자동으로 업데이트됩니다. \n\n7. 경로 인텔리센스\n\n더 이상 파일 경로를 추측하거나 가져오기로 번뜩임 없이 고민할 필요가 없습니다. 경로 인텔리센스는 파일 경로에 대한 자동 제안을 제공하여 내비게이션을 쉽게 만듭니다.\n\n8. GitLens — Git Supercharged\n\n\n\nGitLens가 여러분의 버전 관리에 슈퍼파워를 더해줍니다. 한 줄을 마지막으로 수정한 사람을 보여주고, 히스토리를 쉽게 탐색할 수 있게 해주며, 코드의 Git 기록에 대한 통찰력을 제공해줍니다.\n\n9. 코드 맞춤법 검사기\n\n오타는 발생할 수 있습니다, 심지어 코드 주석과 문자열에서도요. 코드 맞춤법 검사기는 슬기롭게 잡아내어라는 몸소 보여줌으로써 여러분의 문서가 전문적으로 보일 수 있도록 도와줍니다.\n\n10. React Native 도구\n\n\n\n만약 React Native로 작업 중이라면, 이 확장 프로그램은 정말 대단해요. React Native에 특화된 디버깅 및 인텔리센스를 제공하여 모바일 개발이 쉬워집니다.\n\n이 툴킷에 있는 이 10가지 VS Code 확장 프로그램을 사용하면 React 및 React Native 코딩 닌자로 성장할 수 있어요. 한번 시도해보세요. 생산성이 그리고 코딩 즐거움이 두 배로 늘어나는 걸 보게 될 거예요. 코딩 즐겁게! 🚀","ogImage":{"url":"/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png"},"coverImage":"/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 19 베타 버전이 출시되었어요","description":"","date":"2024-05-14 11:17","slug":"2024-05-14-React19betaisout","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-React19betaisout_0.png\" /\u003e\n\nReact 19 베타가 출시되었습니다. React 생태계에 독특한 업데이트와 기능을 가져왔어요. 이번 글에서는 React 19가 가져온 새로운 Hooks 및 API를 살펴보며, 이러한 변경 사항이 앞으로 React 애플리케이션 개발하는 방식을 개선할 수 있는 방법을 알아볼 거에요.\n\n이 글은 \"대용량 앱 구축\" 뉴스레터 커뮤니티에 보내는 첫 정보 제공 자료입니다. 뉴스레터에서는 대규모 웹 애플리케이션을 구축하고 유지하는 데 중점을 둔 프론트엔드 엔지니어링과 JavaScript 기술에 관한 콘텐츠를 공유합니다.\n\n저희가 공유하는 일부 콘텐츠는 코드 변경 및 API 향상에 더 초점을 맞출 거에요 (이와 같은 글 같죠!), 다른 콘텐츠는 대규모 웹 애플리케이션을 다루는 산업에서 종사하는 경험이 풍부한 엔지니어들의 경험, 사례 연구 또는 통찰력 있는 일화를 공유할 거에요.\n\n\n\n이런 문제들을 이메일로 받아보려면 구독해주세요!\n\n## React 19\n\nReact 19가 2024년 4월 25일에 공식 베타 릴리스로 무대에 등장했습니다. 이 새로운 버전에는 새로운 Hooks 및 API, React 서버 컴포넌트, 일부 만료된 React API의 제거 등 다양한 변경 사항이 포함되어 있습니다. 오늘의 이슈에서는 주로 React 19가 소개한 흥미로운 새로운 Hooks 및 API를 살펴볼 것입니다.\n\nReact 19는 아직 베타 버전이며 주로 라이브러리 개발자를 대상으로 만들어졌습니다. 이들은 새로운 변경 사항에 대해 실험하고 라이브러리를 적응시키기 위해 업그레이드해야 합니다. 일반 앱 개발자들은 React 18.3로 업그레이드하고 React 19의 안정 버전을 기다리는 것이 좋습니다. React 19로 업그레이드하는 더 자세한 정보는 React 팀이 제공한 React 19 베타 업그레이드 가이드를 확인할 수 있습니다.\n\n\n\n# 양식 제출 및 낙관적 업데이트\n\n지금날 웹 애플리케이션을 사용하는 방법 중 상당 부분은 사용자 인증부터 데이터 제출, 전자 상거래 거래, 피드백 수집, 검색 쿼리 등 다양한 목적의 양식과 상호 작용하는 것에 관련되어 있습니다. 그 결과로 React 컴포넌트 개발에서 매우 흔한 행동 중 하나는 양식 제출을 처리하고 제출될 때 양식이 무엇을 해야 하는지의 비동기 업데이트를 다루는 것입니다.\n\n이러한 비동기 업데이트를 처리하는 양식 컴포넌트의 간단한 예시는 다음과 같이 보일 수 있습니다:\n\n![예시 이미지](/assets/img/2024-05-14-React19betaisout_1.png)\n\n\n\n위 예제에서 Component는 양식의 상태를 관리하고 양식 제출을 비동기적으로 처리합니다. 제출 후 submitForm() 함수는 서버로 양식 정보를 제출하고 응답을 반환합니다. 컴포넌트는 상태를 업데이트하여 제출 프로세스에 대한 사용자 피드백을 표시합니다.\n\nReact 18에서 UI를 비긴요하지 않은 방식으로 한 뷰에서 다른 뷰로 전환하는 개념을 전환으로 명명했습니다. React 19는 이제 비동기 전환에서 async 함수를 사용할 수 있으며 useTransition Hook을 사용하여 비동기 데이터 검색 중에 로딩 지시자나 플레이스홀더를 관리할 수도 있습니다.\n\n# 작업\n\nReact 19에서 비동기 전환을 사용하는 기능은 작업으로 더 이상 발전되었으며, 비동기 전환을 사용하는 함수를 작업이라고 합니다. 위에서 본 것처럼 사용하기 위해 useActionState Hook과 같은 몇 가지 전문화된 Hook이 있으며, 첫 번째로 살펴볼 것은 useActionState Hook입니다.\n\n\n\n## useActionState\n\nuseActionState() 훅은 세 가지 매개변수를 받습니다:\n\n- \"action\" 함수는 폼 액션이 트리거될 때 실행됩니다.\n- 초기 상태 객체는 사용자 상호작용 전에 폼의 시작 상태를 설정합니다.\n- [옵션] 이 폼을 수정하는 고유 페이지 URL을 가리키는 퍼머링크입니다.\n\n그리고 튜플로 세 가지 값을 반환합니다:\n\n\n\n- 현재 양식의 상태.\n- 양식 동작을 트리거하는 함수.\n- 동작이 진행 중인지를 나타내는 부울 값.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_2.png)\n\nuseActionState Hook에 첫 번째 인자로 전달된 작업 함수는 양식을 제출할 때 트리거되고, 양식 제출이 성공하거나 오류가 발생할 때 전환할 양식 상태를 반환합니다. 이 함수는 두 개의 매개변수를 받습니다 - 현재 양식의 상태와 작업이 트리거된 시점의 양식 데이터입니다.\n\n다음은 작업() 함수를 만드는 예시입니다. 이 함수는 가상의 submitForm() 함수를 호출하고 이후에 서버로 양식 데이터를 제출하는 API 호출을 트리거합니다. 작업이 성공하면, 다음 양식 상태를 나타내는 양식 상태 객체를 반환합니다. 작업이 실패하면, 사용자가 문제를 해결하는 데 도움이 될 수 있는 오류 메시지 또는 표시기를 포함한 오류 상태를 반영하는 양식 상태 객체를 반환합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-React19betaisout_3.png\" /\u003e\n\n저희가 설정한 useActionState() 훅으로, 폼 상태, 디스패치 및 보류 중인 값들을 폼 템플릿에서 사용할 수 있습니다.\n\n## `form` 액션\n\nReact 19에서는 `form` 요소에 이제 action 속성이 있어서, 폼을 제출할 때 트리거될 수 있는 액션 함수를 받을 수 있습니다. 여기에서는 useActionState() 훅에서 디스패치 함수를 전달할 것입니다.\n\n\n\n\n![React 19 beta is out](/assets/img/2024-05-14-React19betaisout_4.png)\n\n폼 템플릿에서 상태를 표시하고 isPending 값 사용하여 비동기 액션이 처리 중임을 사용자에게 전달할 수 있습니다.\n\n![React 19 beta is out](/assets/img/2024-05-14-React19betaisout_5.png)\n\n이렇게 하면, React의 이러한 새로운 변경 사항으로 인해 폼에서 비동기 전환을 다룰 때 처리 중인 상태, 오류 및 순차 요청을 수동으로 처리할 필요가 없어집니다. 대신, 이러한 값들은 useActionState() Hook에서 직접 액세스할 수 있습니다.\n\n\n\n\n## useFormStatus\n\n리액트 19는 useFormStatus라는 새로운 훅을 소개합니다. 이 훅은 중첩된 자식 컴포넌트가 그들이 위치한 폼에 대한 정보에 액세스할 수 있게 해줍니다 (마치 폼이 컨텍스트 제공자인 것처럼).\n\n![이미지](/assets/img/2024-05-14-React19betaisout_6.png)\n\n부모 폼 정보에 액세스하는 행동은 컨텍스트를 통해 수행할 수 있지만, 리액트 19에서는 useFormStatus 훅을 소개하여 중첩된 컴포넌트 내에서 폼 데이터를 처리하는 일반적인 경우를 훨씬 쉽게 만들었습니다.\n\n\n\n## useOptimistic\n\nuseOptimistic() 훅은 React 19에서 추가된 또 다른 새로운 훅입니다. 네트워크 요청과 같은 백그라운드 작업이 완료될 때 낙관적 업데이트를 수행할 수 있습니다. 이를 통해 사용자 상호작용에 빠른 응답을 제공하여 사용자 경험을 향상시킬 수 있습니다.\n\n아래는 부모에서 전달된 메시지 상태 속성을 관리하기 위해 useOptimistic() 훅을 사용하는 예시입니다.\n\n![img](/assets/img/2024-05-14-React19betaisout_7.png)\n\n\n\n위의 컴포넌트 예시에서는 useOptimistic Hook을 사용하여 메시지 상태를 낙관적으로 업데이트하는 것을 관리합니다. 이 상태는 prop으로 전달됩니다.\n\n사용자가 \"Add Message\" 버튼을 클릭하여 폼을 제출하면 submitForm() 함수가 트리거됩니다. 메시지를 업데이트하기 위한 API 요청을 시작하기 전에, 새 메시지 값을 폼 데이터에서 얻어 setOptimisticMessage() 함수가 호출됩니다. 이렇게 하면 즉시 UI가 낙관적인 변경을 반영하여 사용자에게 즉각적인 피드백을 제공합니다.\n\n업데이트가 완료되거나 오류가 발생하면 React가 자동으로 메시지 prop 값으로 전환됩니다.\n\n# 새로운 API 사용\n\n\n\nReact 19에서는 Promise 또는 context와 같은 리소스에서 값을 읽는 다재다능한 방식으로 새 use API가 소개되었습니다.\n\n예를 들어, context 값을 읽으려면 단순히 context를 use()에 전달하면 함수가 컴포넌트 트리를 탐색하여 가장 가까운 context 제공자를 찾습니다.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_8.png)\n\nuseContext() Hook과 달리, use() 함수는 조건문과 루프 내에서 컴포넌트에서 사용할 수 있습니다!\n\n\n\n\n![React19betaisout_9](/assets/img/2024-05-14-React19betaisout_9.png)\n\nuse()도 Suspense와 에러 경계와 매끄럽게 통합됩니다. 프라미스를 읽기 위해서(React 문서의 서버에서 클라이언트로 데이터 스트리밍에서 더 자세히 참조).\n\n# React 서버 컴포넌트\n\nReact 서버 컴포넌트는 React 19에서 소개되는 새로운 기능으로, 서버에서 실행되는 상태 없는 React 컴포넌트를 만들 수 있게 해줍니다. 이러한 컴포넌트는 클라이언트 응용 프로그램이나 서버 측 렌더링 서버와 다른 환경에서 번들링되기 전에 미리 실행됩니다.\n\n\n\n\n리액트 서버 컴포넌트는 웹 서버에서 실행할 수 있기 때문에 API와 상호 작용하지 않고도 데이터 레이어에 액세스할 수 있어요!\n\n![이미지](/assets/img/2024-05-14-React19betaisout_10.png)\n\n정말 멋지죠! 이를 통해 API 엔드포인트를 노출할 필요가 없고, 데이터를 컴포넌트로 직접로딩하기 위해 추가적인 클라이언트 측 fetching 로직을 사용할 필요가 없어요. 모든 데이터 처리는 서버에서 이루어져요.\n\n서버 컴포넌트는 서버에서 실행되며 브라우저에서 실행되지 않습니다. 결과적으로 이러한 컴포넌트들은 useState와 같은 전통적인 리액트 컴포넌트 API를 사용할 수 없어요. 리액트 서버 컴포넌트 환경에 상호 작용성을 도입하기 위해서는 서버 컴포넌트와 상호 작용을 처리하기 위한 클라이언트 컴포넌트들을 결합해야 해요.\n\n\n\n위의 블로그 포스트 예시를 계속하면, 이런 식으로 Comment 컴포넌트가 상태(state)와 상호작용을 포함하는 클라이언트 컴포넌트로 렌더링된다는 것을 보여줄 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_11.png)\n\n위 예시에서 컴포넌트 파일의 맨 위에 \"use client\"를 선언하는 것에 유의하세요. React 서버 컴포넌트와 작업할 때, \"use client\"는 해당 컴포넌트가 클라이언트 컴포넌트임을 나타냅니다. 이는 상태를 관리하고 사용자 상호작용을 처리하며 브라우저별 API를 사용할 수 있는 것을 의미합니다. 이 지시어는 명시적으로 React 프레임워크와 번들러에게 이 컴포넌트를 서버에서 실행되는 상태 없는 서버 컴포넌트와 구분하여 다르게 취급하도록 알려줍니다.\n\n그 반대로 React 서버 컴포넌트는 기본값이기 때문에 서버 컴포넌트 파일의 맨 위에 \"use server\"를 명시하지 않습니다. 대신에 \"use server\"는 클라이언트 컴포넌트에서 호출할 수 있는 서버 측 함수를 표시하는 데에 사용되어야 합니다. 이것을 서버 액션(Server Actions)이라고 합니다.\n\n\n\nReact Server Components는 React 애플리케이션 구조를 변경하여 클라이언트와 서버 간의 관심사를 분리합니다. React 팀은 그들이 결국 광범위하게 채택되고 React 애플리케이션을 구축하는 방법을 변화시킬 것이라고 믿고 있습니다. 이 순간, 저희는 \"Building Large Scale Web Apps\" 책에 추가할 새로운 장 \"React in 2024\"의 일환으로 React Server Components를 깊이 파헤치고 있습니다. 이에 대해 더 많은 정보를 곧 공유할 예정입니다!\n\n이 기사를 즐겼다면? 이 뉴스레터를 직접 받아보기 위해 https://largeapps.substack.com에서 구독하세요.\n\nReact 19의 새로운 기능에 대한 자세한 내용과 베타 버전을 시도하는 방법에 대해서는 공식 React 문서의 React 19 베타 설명서를 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-14-React19betaisout_0.png"},"coverImage":"/assets/img/2024-05-14-React19betaisout_0.png","tag":["Tech"],"readingTime":7},{"title":"React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내","description":"","date":"2024-05-14 11:15","slug":"2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png\" /\u003e\n\nuseReducer과 useContext는 React에서 함께 사용하여 전체 애플리케이션의 상태를 관리하는 강력한 두 가지 훅입니다. useReducer는 복잡한 상태 전환을 더 예측 가능하고 관리하기 쉽게 처리할 수 있는 방법을 제공하며, useContext는 각 레벨을 통해 수동으로 props를 전달하지 않아도 컴포넌트 트리로 데이터를 전달할 수 있도록 해주어 데이터를 전역적으로 사용할 수 있게 합니다.\n\n이 블로그에서는 현재 알고 있는 코드 최적화 방법을 적용할 것입니다.\n\n앱에서 \"context\"라는 폴더를 생성하고 그 폴더 안에 \"IncrementContext\"라는 파일을 생성하세요.\n\n\n\n```js\r\nimport { createContext, useContext, useReducer } from 'react';\n\n// 상태를 보유하는 컨텍스트 생성\nconst IncrementContext = createContext();\n\n// 초기 상태 정의\nconst initialState = {\n  count: 0\n};\n```\n\n\n\n위의 코드 스니펫에서는 세 가지 리액트 훅, createContext, useContext 및 useReducer를 import했습니다.\n\n- CreateContext는 상태를 보유하는 컨텍스트를 생성하는 데 사용됩니다.\n- useContext는 컨텍스트를 호출하는 데 사용됩니다.\n- useReducer는 상태 변수와 기능을 관리하는 데 사용됩니다.\n\n또한 key-value 쌍인 count를 기본 값 0으로 가진 initialState 객체를 선언했습니다.\n\n이 코드를 useReducer 훅에 전달하여 기능을 구축할 것입니다.\n\n\n\n2. 리듀서 함수 작성하기\n\n```js\nconst reducer = (state, action) =\u003e {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// 리듀서와 초기 상태(initialState)와 함께 사용할 컴포넌트를 useReducer 훅 안에 선언할 것입니다.\n\n// IncrementProvider 내부에 선언될 것입니다.\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n리듀서 함수는 현재 상태와 액션 객체를 받아들여 액션의 유형 및 페이로드를 기반으로 새 상태를 반환하는 순수 함수입니다. 이는 React 애플리케이션에서 복잡한 상태 로직을 관리하기 위해 useReducer 훅과 함께 사용됩니다. 리듀서 함수는 현재 상태를 직접 수정하는 대신 항상 새 상태 객체를 반환해야 합니다.\n\n제공된 코드 스니펫에서 리듀서 함수는 현재 상태 객체와 형식(type) 속성이 있는 액션 객체를 받아들입니다. 액션 타입에 따라 리듀서는 count 속성이 증가하거나 감소한 새로운 상태 객체를 반환합니다. 액션 유형이 인식되지 않으면, 리듀서는 잘못된 액션이 전송되었음을 나타내기 위해 오류를 throw합니다.\n\n\n\n3. 콘텍스트 프로바이더 작성 및 데이터를 전역적으로 접근 가능하게 만들기\n\n```js\n// 리듀서와 초기 상태에 모두 액세스하려면 useReducer를 사용합니다.\nconst IncrementProvider = (props) =\u003e {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    \u003cIncrementContext.Provider value={{ ...state, dispatch }}\u003e\n      {props.children}\n    \u003c/IncrementContext.Provider\u003e\n  );\n}\n\n// IncrementProvider를 사용하여 index.js에서 전체 애플리케이션을 래핑합니다.\n// 이렇게 하면 콘텍스트 객체를 전역적으로 액세스할 수 있게 됩니다.\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cIncrementProvider\u003e\n      \u003cApp /\u003e\n    \u003c/IncrementProvider\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\nIncrementProvider는 useReducer를 사용하여 상태를 관리하고 createContext를 사용하여 콘텍스트를 생성하는 사용자 정의 프로바이더 컴포넌트입니다. 프로바이더 컴포넌트는 props를 인수로 받아 자식 컴포넌트를 래핑하는 프로바이더 컴포넌트를 반환합니다.\n\n프로바이더 컴포넌트는 IncrementContext.Provider를 사용하여 상태와 디스패치 함수를 컨텍스트를 통해 자식 컴포넌트에 제공합니다. 이를 위해 IncrementContext.Provider에 값을 전달하여 상태와 디스패치 함수가 포함된 객체를 전달합니다.\n\n\n\n예제 코드에서 IncrementProvider는 index.js 파일에서 App 컴포넌트를 감싸고 있습니다. 이렇게 함으로써 상태와 디스패치 함수를 App 컴포넌트의 모든 하위 컴포넌트에서 사용할 수 있게 됩니다.\n\nIncrementProvider로 전체 애플리케이션을 감싸면 모든 컴포넌트가 상태에 액세스하고 수정을 위한 액션을 디스패치할 수 있도록 보장합니다. 이는 React 애플리케이션에서 컨텍스트와 useReducer 훅을 사용하여 전역 상태를 관리하는 일반적인 패턴입니다.\n\n4. 컴포넌트에서 데이터에 액세스\n\n```js\nimport { useIncrementContext } from 'IncrementContext'\n\nconst MyComponent = () =\u003e {\n  // useContext를 사용하여 컨텍스트를 호출할 필요가 없습니다\n  // useIncrementContext 함수를 작성하여 컨텍스트를 호출하였기 때문입니다\n  const { state, dispatch } = useIncrementContext()\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {state.count}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n`useIncrementContext`은 `IncrementContext.Provider`에서 생성된 컨텍스트를 소비하는 데 사용되는 사용자 정의 후크입니다. 이 후크는 `useContext` 후크를 사용하는 보일러플레이트 코드를 추상화하여 컨텍스트 값을 쉽게 액세스할 수 있도록 돕습니다.\n\n예시 코드에서 `useIncrementContext`는 `IncrementContext` 파일에서 가져옵니다. `MyComponent` 컴포넌트는 `useIncrementContext` 후크를 사용하여 컨텍스트에서 상태 및 디스패치 함수에 액세스합니다.\n\n`useIncrementContext` 후크를 사용함으로써 컴포넌트에서 `useContext` 후크를 직접 사용할 필요가 없습니다. 대신 `useIncrementContext` 함수를 호출하여 컨텍스트에서 상태 및 디스패치 함수에 액세스할 수 있습니다.\n\n`MyComponent` 컴포넌트는 상태 객체에서 현재 카운트 값을 보여주는 단락을 렌더링합니다. 또한 클릭할 때 증가 또는 감소 액션을 디스패치하는 두 개의 버튼을 렌더링합니다.\n\n\n\n이 코드 스니펫은 React 컴포넌트에서 컨텍스트 값을 사용하기 위한 사용자 정의 훅을 어떻게 사용하는지 보여줍니다. 컨텍스트를 사용하는 과정을 간단하게 만들어주며 응용 프로그램의 여러 컴포넌트에서 상태와 디스패치 기능에 쉽게 액세스할 수 있습니다.\n\n이 블로그가 도움이 되기를 바라요!\n\nGithub : https://github.com/DevgenX","ogImage":{"url":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png"},"coverImage":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기","description":"","date":"2024-05-14 11:13","slug":"2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png\" /\u003e\n\nReact + Tailwind에서 토스 (알림 시스템)를 만들어 봅시다!\n\n새로운 튜토리얼 준비되셨나요!? 저는 로봇이나 인공지능이 아니라 다재다능한 사람입니다.\n\n음, 생각해 보니까 \"왜 안 해볼까\"라는 생각이 들더라고요. React JS를 한 번 시도해보는 거야.\n\n\n\n나의 취향에 따르면, React는 몇 가지 멋진 기능을 가지고 있어요!\n\n그래서 2016년에 뒤떨어진 채로 두고 둔 React JS에 다시 기회를 주게 되어 너무 흥분되고 있어요.\n\n# 내 컴퓨터에 React JS를 설치하는 방법은?\n\nReact JS 프로젝트의 모두에게 선호되는 선택지로 시작해 봅시다.\n\n\n\n최소 프로젝트를 시작하려면 먼저 다음 명령을 실행해야 합니다.\n\n이 프로젝트를 \"Tailwind-toast\"라고 이름 짓겠습니다. 샘플이기 때문입니다. 프로젝트 이름은 자유롭게 변경하셔도 됩니다.\n\n```js\nnpx create-react-app tailwind-toast\n```\n\nReactJS에 관한 이전 기사들을 통해 자바스크립트에 대해 더 많은 도움을 얻을 수도 있습니다.\n\n\n\n여기에서 새로운 REACT 프로젝트가 설정되고 생성되었음을 확인할 수 있습니다.\n\n계속하기 전에 Tailwind CSS를 설정해야 합니다.\n\n우리는 CDN을 사용하여 리액트 앱 내부에 tailwind를 설정할 계획입니다.\n\n다음으로, 새로운 리액트 프로젝트의 루트를 찾아야 합니다!\n\n\n\n```js\n./public/index.html\n```\n\n그리고 index의 head에 CDN Tailwind 스크립트 태그를 추가하십시오.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"utf-8\" /\u003e\n    \u003clink rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e\n    \u003cmeta name=\"theme-color\" content=\"#000000\" /\u003e\n    \u003cmeta\n      name=\"description\"\n      content=\"create-react-app을 사용하여 생성된 웹 사이트\"\n    /\u003e\n    \u003clink rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /\u003e\n    \u003c!--\n      manifest.json은 사용자의 모바일 기기나 데스크톱에서 웹 앱이 설치될 때 사용되는 메타데이터를 제공합니다. https://developers.google.com/web/fundamentals/web-app-manifest/\n    --\u003e\n    \u003clink rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /\u003e\n    \u003c!--\n      위 태그들에서 %PUBLIC_URL%을 주목하세요.\n      이것은 빌드 중에 'public' 폴더의 URL로 대체될 것입니다.\n      HTML에서는 'public' 폴더 내의 파일만 참조할 수 있습니다.\n\n      \"/favicon.ico\"나 \"favicon.ico\"와 달리, \"%PUBLIC_URL%/favicon.ico\"는\n      클라이언트 측 라우팅과 최상위 공용 URL 양측에서 제대로 작동합니다.\n      비공용 URL을 구성하는 방법은 `npm run build`를 실행하여 알아보세요.\n    --\u003e\n    \u003ctitle\u003eReact App\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cnoscript\u003e이 앱을 실행하려면 JavaScript를 활성화해야 합니다.\u003c/noscript\u003e\n    \u003cdiv id=\"root\"\u003e\u003c/div\u003e\n    \u003c!--\n      이 HTML 파일은 템플릿입니다.\n      브라우저에서 직접 열면 빈 페이지가 표시됩니다.\n\n      이 파일에 웹 폰트, 메타 태그 또는 분석을 추가할 수 있습니다.\n      빌드 단계에서 번들된 스크립트가 \u003cbody\u003e 태그에 배치됩니다.\n\n      개발을 시작하려면 `npm start` 또는 `yarn start`를 실행하십시오.\n      프로덕션 번들을 만들려면 `npm run build` 또는 `yarn build`를 사용하십시오.\n    --\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n# 내 프로젝트에 React Toastify를 설치하는 방법은 무엇인가요?\n\n\n\n\"React-Toastify\"라는 라이브러리를 먼저 가져와야 해요.\n\n이 라이브러리에는 토스트 메시지를 사용자 정의하고 더 많은 기능을 제공하는 멋진 기능이 있어요.\n\n아래 명령을 실행해 보세요.\n\n```js\nnpm install --save react-toastify\n```\n\n\n\n이제 Toast를 실행할 필요한 모든 패키지가 준비되었습니다!\n\n## React Toastify CSS를 가져오는 방법\n\n지금 튜토리얼의 이 지점에서 모든 패키지를 가지고 있지만 React-Toastify가 올바르게 작동하려면 약간의 CSS가 필요합니다.\n\n텍스트 편집기를 열고 App.js 파일을 몇 가지 수정하십시오. 이 파일은 자동으로 생성되며 src라는 디렉토리 안에 있습니다.\n\n\n\n다음으로, 이 두 줄의 코드를 포함해야 합니다.\n\n```js\nimport { ToastContainer, toast } from 'react-toastify';\n\nimport 'react-toastify/dist/ReactToastify.css';\n```\n\n좋아요! 이제 우리는 ToastContainer 및 toast를 사용하여 버튼 클릭 시 알림을 트리거할 수 있습니다.\n\n새로운 reactjs 프로젝트 안에 버튼을 정의해 봅시다. 이전과 같은 파일인 App.js에서 시작해서, 어떠한 onClick 이벤트에 대비할 준비가 된 상수 변수를 사용하여 새로운 버튼을 설정할 수 있습니다.\n\n\n\n```js\nconst notify = () =\u003e {};  \nreturn (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cp\u003e\n          Edit \u003ccode\u003esrc/App.js\u003c/code\u003e and save to reload.\n        \u003c/p\u003e\n        \u003ca\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        \u003e\n          Learn React\n        \u003c/a\u003e\n        \u003cbutton onClick={notify}\u003eNotify !\u003c/button\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n```\n\n멋져요! 다음은 버튼에 Tailwind를 추가하는 것입니다. ReactJS에서는 버튼에 class 대신 className을 사용해야 합니다. Tailwind CSS 스타일은 매우 직관적입니다. 여기서는 font-bold와 배경색이 필요합니다.\n\n```js\n\u003cbutton className=\"bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-700 hover:border-blue-500 rounded m-5 text-base\" onClick={notify}\u003eNotify !\u003c/button\u003e\n```\n\n잘 진행 중입니다! 이제 Toast를 작동시켜 봅시다! App.js 파일에 다음 줄을 추가하세요.\n\n\n\n\n```js\n const notify = () =\u003e toast(\"와우 정말 쉬워요!\");\n```\n\n이전에 우리는 App.js 파일 안에서 Toast 및 ToastContainer를 가져왔습니다.\n\n다음으로, 토스트가 테일윈드 CSS만으로 멋지게 설정되어 있는지 확인해야 합니다!\n\n어떠세요, contextClass를 상수로 추가하고 테일윈드가 특별한 매력을 불어 넣도록 할까요? 🪄\n\n\n\n\n```js\nconst contextClass = {\n  success: \"bg-blue-500\",\n  error: \"bg-red-600\",\n  info: \"bg-gray-600\",\n  warning: \"bg-orange-400\",\n  default: \"bg-indigo-600\",\n  dark: \"bg-white-600 font-gray-300\",\n};\n```\n\n이제 마지막 파트… ToastContainer를 설정해야 합니다.\n\n이곳이 모든 마법이 시작되고 끝나는 곳이니 준비하세요!\n\n```js\n\u003cToastContainer\n  toastClassName={(context) =\u003e\n    contextClass[context?.type || \"default\"] +\n    \" relative flex p-1 min-h-10 rounded-md justify-between overflow-hidden cursor-pointer\"\n  }\n  bodyClassName={() =\u003e \"text-sm font-white font-med block p-3\"}\n  position=\"top-left\"\n  autoClose={3000}\n  icon={({ type }) =\u003e {\n    if (type === \"success\") return \"👻\";\n    if (type === \"error\") return \"🚨\";\n    else return \"ℹ️\";\n  }}\n/\u003e\n```\n\n\n\n우리는 이전에 만든 컨텍스트를 전달하여 ToastClassName 컨테이너를 정의합니다. 그런 다음 몇 가지 Tailwind 스타일을 적용하여 ToastContainer가 멋지게 보이도록 합니다.\n\n다음으로 알림의 위치를 상단 및 왼쪽으로 설정합니다.\n\n훌륭해요! 이제 모두 설정되었어요. 하지만 React-Toastify에서 아이콘을 업데이트하고 싶습니다.\n\n일반적으로 React 라이브러리 내의 아이콘에 스타일을 변경하는 것은 어려울 수 있지만, react-toastify 자바스크립트에는 아이콘을 위한 특정 속성이 있습니다.\n\n\n\n앗 안돼! ...보이니 저희 토스트 알림 시스템이 예상대로 작동하지 않는 것 같아요.\n\n# 나만의 커스텀 Tailwind 스타일로 React-Toastify를 어떻게 발동시킬까요?\n\n이 튜토리얼을 끝까지 따라오면서 여러분은 아마도 우리가 만드는 팝업 알림이 올바른 스타일을 사용하지 않는다는 것을 느꼈을 겁니다.\n\n그 이유는 우리가 리액트의 알림 시스템에게 트리거될 때 올바른 컨텍스트를 사용하도록 활성적으로 알려줘야하기 때문이죠.\n\n\n\n앞서 우리의 React-toastify 알림 시스템이 사용자 지정 Tailwind 스타일을 트리거하지 않는 정확한 이유를 이해하려면 최종 App.js의 시작 지점으로 돌아가 봅시다.\n\n```js\nimport { ToastContainer, toast } from 'react-toastify';\n\nimport 'react-toastify/dist/ReactToastify.css';\n\nconst contextClass = {\n  success: \"bg-blue-500\",\n  error: \"bg-red-600\",\n  info: \"bg-gray-600\",\n  warning: \"bg-orange-400\",\n  default: \"bg-indigo-600\",\n  dark: \"bg-white-600 font-gray-300\",\n};\n\nfunction App() {\n const notify = () =\u003e toast(\"와우, 정말 쉬워요!\");\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cp\u003e\n          \u003ccode\u003esrc/App.js\u003c/code\u003e를 편집하고 저장하세요.\n        \u003c/p\u003e\n        \u003ca\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        \u003e\n          React 배우기\n        \u003c/a\u003e\n        \u003cbutton className=\"bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-700 hover:border-blue-500 rounded m-5 text-base\" onClick={notify}\u003e알림 보내기!\u003c/button\u003e\n          \u003cToastContainer\n            toastClassName={(context) =\u003e\n              contextClass[context?.type || \"default\"] +\n              \" relative flex p-1 min-h-10 rounded-md justify-between overflow-hidden cursor-pointer\"\n            }\n            bodyClassName={() =\u003e \"text-sm font-white font-med block p-3\"}\n            position=\"top-left\"\n            autoClose={3000}\n            icon={({ type }) =\u003e {\n                if (type === \"success\") return \"👻\";\n                if (type === \"error\") return \"🚨\";\n                else return \"ℹ️\";\n            }\n          /\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n문제점을 알아챘나요? 실제로... 우리는 Tailwind CSS 스타일이 기본 React-toastify 스타일을 재정의하기 위한 특정 컨텍스트를 확인하거나 유효화하지 않았군요.\n\n# React-Toastify 스타일 덮어쓰기 및 Tailwind 스타일이 나타나지 않는 문제를 해결하는 방법?\n\n\n\nReact-Toastify 설정을 수동으로 재정의하여 알림에 사용 가능한 타입을 다시 정의해야 합니다. 예를 들어, 성공 알림을 호출하려면 해당 알림을 선택해야 합니다.\n\nReact-Toastify 스타일에서 성공 알림을 선택하고 이전에 생성한 tailwind 스타일이 적용되어야 합니다.\n\n또한 progress-bar의 스타일을 변경하는 등 알림을 좀 더 사용자 정의할 수 있습니다.\n\n각 알림마다 react-toastify 옵션에서 progressStyle를 업데이트할 수 있습니다.\n\n\n\n표 태그를 Markdown 형식으로 변경해보세요.\n\n```js\nconst notify = () =\u003e toast(\"와우 정말 쉽군요 !\", { type: \"success\", progressStyle: { background: '#E8DFD0' } });\n```\n\n이제 올바른 스타일이 보일 것입니다. Tailwind와 React JS는 강력합니다. CSS와 JS를 마음대로 섞어 사용할 수 있어요.\n\n튜토리얼을 이렇게 멀리 따라오셔서 축하드려요!\n\n\n\n위 코드는 테스트해보고 싶은 사람을 위한 최종 코드입니다.\n\n# ReactJS + Libs에 대한 우리의 마지막 생각\n\n튜토리얼을 완료하며 많은 것을 이루었습니다.\n\nAngular와는 달리 작은 구성으로 많은 작업을 수행할 수 있다는 것이 놀라운 점입니다.\n\n\n\n저는 ReactJS가 훌륭한 도구라고 생각하지만, 모든 도구처럼 문제가 여전히 발생합니다.\n\nReact에서 경험했던 일반적인 문제는 역위 호환성 지원입니다.\n\n제가 틀렸다고 느낀다면 자유롭게 반론해주세요만…\n\nReact의 방법론은 항상 최신 기술에 초점을 맞추고 있어서 과거를 고려하지 않는다는 것을 의미합니다.\n\n\n\n한 번 완료된 프로젝트가 일 년 후에 무엇이 깨지면 여러 번 다시 시작하고 싶지는 않아요.\n\n즐거운 프로그래밍 하세요!! - 우리는 인공지능이 일자리를 없애는 걸 찬성하지 않아요 😵, 그러니 친절하게 대해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png","tag":["Tech"],"readingTime":9},{"title":"리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법","description":"","date":"2024-05-14 11:12","slug":"2024-05-14-ReactHowtostopre-renderinginReactComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png\" /\u003e\n\n리액트는 초기에 비해 많은 발전을 이루었습니다. 그럼에도 여전히 많은 사람들이 불필요한 다시 렌더링을 고치기 어려운 것으로 생각합니다.\n\n불필요한 다시 렌더링을 피하는 다양한 방법이 있습니다. 여기에서는 리액트에서 불필요한 다시 렌더링을 피하는 몇 가지 방법과 접근법을 논의하고 있습니다.\n\n- useState()를 useRef()훅으로 대체하기.\n- 메모이제이션된 셀렉터를 만들기 위해 Reselect 라이브러리 사용.\n- 데이터 가져오기를 위한 리액트 훅 라이브러리인 SWR 사용.\n- useMemo() 및 useCallback() 훅을 사용한 메모이제이션.\n\n\n\n# 1. useState()을 useRef() 훅으로 변경하기\n\nuseState() 훅은 React 함수형 컴포넌트에서 상태가 변경될 때 컴포넌트를 다시 렌더링하는 데 자주 사용되는 훅입니다. 그러나 경우에 따라 컴포넌트를 다시 렌더링하지 않고 업데이트를 추적해야 할 때가 있습니다. 이럴 때 useRef() 훅을 사용할 수 있습니다. useRef()를 사용하면 useState()처럼 다시 렌더링을 호출하지 않고 업데이트를 추적할 수 있습니다.\n\nuseState()를 사용한 예시:\n\n```js\nfunction inputWithState() {\n  const [value, setValue] = useState(\"\");\n  return (\n    \u003cinput \n      value={value} \n      onChange={e =\u003e setValue(e.target.value)} \n      type={type} \n    /\u003e\n  );\n}\n```\n\n\n\n이 예시에서는 input에서 각 키 입력마다 onChange 이벤트로 상태 변경이 발생하여 재렌더링됩니다.\n\nuseRef()를 활용한 예시:\n\n```js\nfunction inputWithRef() {\n  const inputEl = useRef(null);\n  console.log(inputEl?.current?.value);\n  return (\n    \u003cinput ref={inputEl} type=\"text\" /\u003e\n  );\n}\n```\n\n이 예시에서는 input에 입력하는 모든 내용을 input 참조를 통해 읽을 수 있습니다. 이 접근법은 각 키 입력마다 불필요한 재렌더링을 피할 수 있습니다.\n\n\n\n# 2. Reselect 라이브러리를 사용하여 메모이제이션 셀렉터 만들기\n\n리액트 컴포넌트는 빠른 수명주기를 갖고 있지만, 너무 많은 다시 렌더링으로 늘 피해를 입는 경우가 많습니다. 이를 해결하기 위해 개발자들은 성능을 개선하기 위해 Redux와 함께 사용되는 인기 라이브러리 Reselect의 래퍼인 서드파티 성능 라이브러리 re-select를 만들었습니다. 이 라이브러리는 메모이제이션 셀렉터를 코딩하여 성능을 향상시킵니다.\n\n- 셀렉터는 파생 데이터를 계산할 수 있어 Redux가 가능한 한 적은 상태를 저장할 수 있게 합니다.\n- 셀렉터는 효율적입니다. 셀렉터는 인수 중 하나가 변경될 때까지 재계산되지 않습니다.\n- 셀렉터는 조합 가능합니다. 다른 셀렉터의 입력으로 사용될 수 있습니다.\n\n예시:\n\n\n\n```js\nimport { createSelector } from 'reselect'\nconst selectShopItems = state =\u003e state.shop.items\nconst selectTaxPercent = state =\u003e state.shop.taxPercent\nconst selectSubtotal = createSelector(selectShopItems, items =\u003e\n  items.reduce((subtotal, item) =\u003e subtotal + item.value, 0)\n)\nconst selectTax = createSelector(\n  selectSubtotal,\n  selectTaxPercent,\n  (subtotal, taxPercent) =\u003e subtotal * (taxPercent / 100)\n)\nconst selectTotal = createSelector(\n  selectSubtotal,\n  selectTax,\n  (subtotal, tax) =\u003e ({ total: subtotal + tax })\n)\nconst exampleState = {\n  shop: {\n    taxPercent: 8,\n    items: [\n      { name: 'apple', value: 1.2 },\n      { name: 'orange', value: 0.95 }\n    ]\n  }\n}\nconsole.log(selectSubtotal(exampleState)) // 2.15\nconsole.log(selectTax(exampleState)) // 0.172\nconsole.log(selectTotal(exampleState)) // { total: 2.322 }\n```\n\n여기서 createSelector는 2개의 선택기를 입력으로 받아 메모이즈된 버전을 반환합니다. 값이 다를 때까지 이 메모이즈된 버전을 사용하여 선택기는 다시 계산되지 않을 것입니다.\n\nReselect는 Redux에만 한정되지 않으나, 공식 Redux Toolkit 패키지에 이미 기본으로 포함되어 있습니다. 추가 설치가 필요하지 않습니다.\n\n# 3. SWR 사용하기 - 데이터 패치용 리액트 훅스 라이브러리\n\n\n\nSWR은 데이터 가져오기를 위한 React Hooks 라이브러리입니다.\n\n\"SWR\"이라는 이름은 stale-while-revalidate의 약자입니다. SWR은 먼저 캐시에서 데이터를 반환한 후(request), 데이터를 업데이트하고(get), 최신 데이터를 다시 가져옵니다. 이를 통해 컴포넌트가 여러 번 다시 렌더링 되는 것을 방지할 수 있습니다.\n\n한 가지 훅으로 프로젝트에서 데이터 가져오기 로직을 크게 간소화할 수 있습니다. 뿐만 아니라 속도, 정확성, 안정성 면에서 모두 다루어져 더 나은 애플리케이션을 구축하는 데 도움이 됩니다.\n\n예시:\n\n\n\n```js\nfunction Profile() {\n  const { data, error } = useSWR('/api/user', fetcher)\n\n  if (error) return \u003cdiv\u003e로드에 실패했습니다\u003c/div\u003e\n  if (!data) return \u003cdiv\u003e로딩 중...\u003c/div\u003e\n  return \u003cdiv\u003e안녕하세요 {data.name}님!\u003c/div\u003e\n}\n```\n\n더 많은 정보와 예제는 여기를 참조하세요: [https://swr.vercel.app/](https://swr.vercel.app/)\n\n## 4. useMemo() 및 useCallback()Hooks를 사용한 Memoization\n\nMemoization은 우리의 리액트 코드를 프롭스에 업데이트가 있을 때에만 컴포넌트를 다시 렌더링하도록 하는 것을 가능하게 합니다. 이 접근 방식을 통해 개발자는 불필요한 다시 렌더링을 피하고 응용 프로그램에서의 계산 부하를 줄일 수 있습니다.\n\n\n\n\n리액트는 메모이제이션을 만들기 위해 두 가지 훅을 제공합니다:\n\n- useMemo()\n- useCallback()\n\n이 훅들은 계산 없이 입력이 동일한 경우 캐싱되어 동일한 결과를 반환하여 다시 렌더링을 줄입니다. 입력이 업데이트되면 캐시가 무효화되고 새로운 컴포넌트 상태가 렌더링됩니다.\n\n- useMemo()\n\n\n\n이 훅은 함수 호출과 렌더 사이에서 계산 결과를 메모이징하는 데 사용됩니다.\n\n예시:\n\n```js\nconst expensiveFunction = (inputValue) =\u003e {\n  let expensiveValue = inputValue * 42;\n  //... 입력값을 포함한 계산 작업이 많은 경우...\n  expensiveValue = 'World';\n  return expensiveValue;\n};\nconst MyComponent = ({ something }) =\u003e {\n  const [inputValue, setInputValue] = useState('');  \n  const expensiveValue = useMemo(\n    () =\u003e expensiveFunction(inputValue), \n    [ inputValue ]\n  );  \n  return \u003ch1\u003eHello {expensiveValue}\u003c/h1\u003e;\n};\n```\n\n2. useCallback()\n\n\n\n이것은 메모이제이션을 구현하는 또 다른 React Hook입니다. 그러나 useMemo()와 달리 결과를 캐시하지 않고 대신 제공된 콜백 함수를 메모이즈합니다.\n\n예시:\n\n```js\nfunction item() {\n  const onClick = useCallback(event =\u003e {\n    console.log('Clicked Item : ', event.currentTarget);\n  }, [item]);\n  \n  return (\n    \u003cli={item} onClick={onClick} /\u003e\n  );\n}\n```\n\n예시에서 useCallback()은 onClick 콜백을 메모이즈합니다. 따라서 사용자가 동일한 항목을 계속 클릭해도 컴포넌트를 다시 렌더링하지 않습니다.\n\n\n\n이 기사가 리액트 컴포넌트에서 재랜더링 문제를 해결하는 데 도움이 되기를 바랍니다. 만약 리액트에서 재랜더링을 피하는 다른 방법이나 기술이 있다면 댓글에 추가해 주세요.\n\n당신의 지원을 보여주기 위해 아래의 👏 버튼을 최대한 많이 눌러주세요!\n\n독자 여러분, 감사합니다. 화이팅!!!\n\n당신은 멋져요!","ogImage":{"url":"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png"},"coverImage":"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png","tag":["Tech"],"readingTime":5}],"page":"117","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"117"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>