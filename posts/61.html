<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/61" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/61" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 인과 관계 탐색하기 차이인차이법" href="/post/2024-05-20-ExploringcausalitywithPythonDifference-in-differences"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 인과 관계 탐색하기 차이인차이법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 인과 관계 탐색하기 차이인차이법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬으로 인과 관계 탐색하기 차이인차이법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 데이터 정제하기" href="/post/2024-05-20-DATACleaninginPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 데이터 정제하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-DATACleaninginPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 데이터 정제하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬에서 데이터 정제하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript, Rust, 그리고 GPT-3로 60초 안에 400개 이상의 탭 정렬하기" href="/post/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript, Rust, 그리고 GPT-3로 60초 안에 400개 이상의 탭 정렬하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript, Rust, 그리고 GPT-3로 60초 안에 400개 이상의 탭 정렬하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript, Rust, 그리고 GPT-3로 60초 안에 400개 이상의 탭 정렬하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Conf 2024에서 새롭게 소개된 내용들" href="/post/2024-05-20-WhatsNewatReactConf2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Conf 2024에서 새롭게 소개된 내용들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WhatsNewatReactConf2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Conf 2024에서 새롭게 소개된 내용들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Conf 2024에서 새롭게 소개된 내용들</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대용량 JSON 파일을 효율적으로 전송하는 방법" href="/post/2024-05-20-HowToTransferLargeJSONFilesEfficiently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대용량 JSON 파일을 효율적으로 전송하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대용량 JSON 파일을 효율적으로 전송하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대용량 JSON 파일을 효율적으로 전송하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" href="/post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">러스트 트레이트 TypeScript 인터페이스의 강력한 대안</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" href="/post/2024-05-20-FrontendWeeklyDigest3631319May2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 소식: 2024년 5월 13일  5월 19일</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="장고로 대규모 프로젝트를 만드는 방법" href="/post/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="장고로 대규모 프로젝트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="장고로 대규모 프로젝트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">장고로 대규모 프로젝트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="템플릿 간소화하기 Angular 17에서의 제어 흐름" href="/post/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="템플릿 간소화하기 Angular 17에서의 제어 흐름" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="템플릿 간소화하기 Angular 17에서의 제어 흐름" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">템플릿 간소화하기 Angular 17에서의 제어 흐름</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" href="/post/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PHP 8.3에 추가된 20가지 흥미로운 기능들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link posts_-active__YVJEi" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"파이썬으로 인과 관계 탐색하기 차이인차이법","description":"","date":"2024-05-20 21:55","slug":"2024-05-20-ExploringcausalitywithPythonDifference-in-differences","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_0.png\" /\u003e\n\n인과 관계를 확립하는 것은 현대 분석에서 가장 중요하면서 종종 간과되는 영역 중 하나입니다. 저는 다가오는 시리즈의 기사에서 우리의 인과 추론 워크샵에서 가장 많이 사용되는 도구를 설명하고 강조하고 싶습니다.\n\n# 인과 추론 101\n\n인과 추론을 정의하는 것부터 시작해봅시다. 저는 Scott Cunningham의 \"믹스테잎\" 책에서 가져온 정의를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그는 그것을 특정 결과에 대한 사건과 선택의 영향을 추정하는 연구로 정의합니다. 우리는 변수 간의 인과 관계를 수립하려고 노력합니다 (우리는 이들을 처리와 효과라고 부를 수 있습니다). 이는 비즈니스부터 공공 정책 설정까지 다양한 영역에서 널리 발생하는 문제입니다.\n\n일반적으로 인과성 파악 프레임워크의 설정은 상대적으로 간단하며 다음으로 구성됩니다:\n\n- 처리군 — 처리를 받는 그룹\n- 대조군 — 처리 효과를 평가하기 위한 기준으로 삼으려는 그룹\n- 처리 — 분석하고자 하는 처리에 직접적으로 관련된 모든 활동\n- 관심 결과\n\n이 설정은 이론적인 개념뿐만 아니라 광범위한 실제 시나리오에 적용할 수 있는 실용적인 도구입니다. 웹사이트 최적화부터 A/B 테스트, 약물 임상 실험부터 개발 프로그램의 효과 추정에 이르기까지, 인과 추론의 응용 분야는 광범위하고 다양합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 인과 효과를 확인하기 위해 충족시켜야 하는 조건을 고려해 봅시다. 먼저, 우리는 처리 그룹과 대조 그룹이 비교 가능하다고 가정해야 합니다. 두 그룹은 처리를 받았을 때와 받지 않았을 때 동일하게 행동해야 합니다. 예를 들어, 처리 그룹의 객체는 처리를 받지 않았을 경우 대조 그룹의 객체와 동일하게 행동해야 합니다.\n\n그 반대도 마찬가지입니다. 대조 그룹의 객체는 처리를 받았을 경우 처리 그룹의 객체와 동일하게 행동해야 합니다. 그러므로 두 그룹 간의 유일한 차이점은 처리에서만 나와야 합니다. 처리 그룹의 결과를 대조 그룹의 결과와 비교하여 우리는 처리 효과를 확인할 수 있습니다.\n\n대조 그룹은 비교뿐만 아니라 처리 그룹의 대체불능을 제시합니다. 이것은 주어진 처리에 노출되지 않았을 때 전자가 어떻게 행동했을지를 보여줍니다. 이것은 인과 효과를 확인하는 데 대조 그룹의 중요한 역할을 강조합니다.\n\n두 그룹이 비슷하다는 가정은 강력하며 가용 데이터와 연구 설계에 따라 달라집니다. 이러한 비교 가능성을 달성하는 것이 인과 추론의 중요한 과제입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 가짜 — 실험\n\n어떻게 그러한 조건들을 얻을 수 있을까요? 인과 관계 주제를 다루는 대부분의 논문은 무작위 실험이 인과 관계를 확립하는 데 있어 황금 표준이라는 개념으로 시작합니다. 그러나 이러한 실험은 종종 실현 가능하거나 실용적으로 수행하기 어려울 수 있습니다.\n\n그래서 우리는 계속해서 우리가 인과 관계를 찾는 데 도움이 되는 도구를 찾고 있습니다. 이 문제에 대처하는 연구 방법을 가짜 실험이라고 부릅니다.\n\n본 문서의 나머지 부분에서는 가장 중요하고 자주 사용되는 가짜 실험적 방법 중 하나인 차이 차이 방법에 초점을 맞출 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최저 임금 연구\n\n이 방법을 고전적인 응용 분야에서 설명하겠습니다. 이 접근 방식을 이해하기 위해 Card와 Kruger의 유명한 최저 임금 연구를 살펴보겠습니다.\n\n최저 임금이 고용에 미치는 영향은 경제학과 공공 정책 분야에서 가장 뜨거운 논쟁 중 하나입니다. 이 연구의 저자들은 이 질문에 대한 답을 찾으려고 했습니다. 이러한 유형의 문제는 무작위 실험을 사용하여 설명할 수 없는 사례의 완벽한 예입니다. 특정 그룹이나 지역을 서로 다른 최저 임금 수준에 무작위로 할당하는 것은 사실상 불가능합니다.\n\n1992년, 뉴저지는 최저 임금을 시간당 4.25달러에서 5.05달러로 인상했습니다. Card와 Kruger는 뉴저지를 비교할 기준을 찾고 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n연구자들은 뉴저지와 펜실베이니아의 고용 수준을 비교하기로 결정했습니다. 전자 주가 대조군 역할을 하는 것으로 선택되었습니다. 뉴저지와 지리적, 경제적 조건 면에서 유사한 펜실베이니아가 선택되었습니다.\n\n연구자들은 1992년 이전과 이후에 두 주의 패스트푸드 레스토랑을 조사하여 종업원 수를 확인했습니다. 고용량 연구 자료를 사용한 이유는 패스트푸드 업계가 최저임금 변화에 빠르게 대응할 수 있기 때문입니다.\n\n## 데이터 세트\n\n이제 데이터를 자세히 살펴보는 적절한 시기입니다. 필요한 데이터 변환을 거친 후 (교육 목적을 위해 간소화된 내용), 다음 데이터 구조가 사용 가능합니다. David Card 웹사이트(https://davidcard.berkeley.edu/data_sets.html)에서 데이터 세트를 사용했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_1.png\" /\u003e\n\n각 행을 식당 설문조사 결과로 취급할 수 있습니다. 중요한 정보는 주 이름, 총 고용 인원, 그리고 주어진 레코드가 최저임금 변경 전이나 후 기간인지를 나타내는 플래그입니다. 최저임금의 변경을 분석 대상의 처리 변수로 취급할 것입니다.\n\n기술적으로, 차트 작성을 쉽게 하기 위해 시간별 및 주별 평균을 데이터 프레임에 저장할 것입니다:\n\n## 직관적인 접근\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최저임금 인상의 영향을 직관적으로 알아보려면 어떻게 해야 할까요?\n\n가장 직관적인 방법은 처리 후 두 주(State)의 평균 고용량을 비교하는 것입니다.\n\n![그림](/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_2.png)\n\n차트를 통해 뉴저지의 평균 고용량이 펜실베이니아보다 약간 낮았음을 알 수 있습니다. 최저임금에 반대하는 사람들은 모두 크게 기뻐할 것이고 이 경제 정책 도구가 제대로 작동하지 않는다고 결론을 내릴 수 있습니다. 또는 아직 결론을 내기에는 너무 이르지 않을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타깝게도, 이 방법은 올바르지 않습니다. 이는 두 주 간의 사전 처리 차이에 대한 중요한 정보를 빼먹고 있습니다. 우리가 가지고 있는 정보는 무작위 실험 이외의 것에서 나온 것이기 때문에 두 주 간의 격차를 설명할 수 있는 다양한 요인을 식별할 수 없게 됩니다.\n\n이 두 주는 거기서 일하는 사람들의 수와 그들의 경제 상태 면에서 매우 다를 수 있습니다. 이들을 처리 후 비교하는 것은 최저임금의 영향에 대한 것을 밝혀 내지 않을 뿐만 아니라 부정확한 결론에 이를 수도 있습니다. 저는 거의 모든 경우에 이러한 유형의 비교를 피하는 것이 좋다고 생각합니다.\n\n## 처리 전/후 비교\n\n우리는 처리 후 두 주를 비교하여 결론을 내릴 수 없습니다. 어떤가요, 최저임금 변경에 영향을 받은 주만 살펴볼까요? 이 프로그램의 영향을 평가하는 다른 방법은 뉴저지의 최저임금 변경 전후 고용을 비교하는 것입니다. 아래 코드 블록은 정확히 이를 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_3.png\" /\u003e\n\n이전/이후 비교는 다른 결과를 보여줍니다. 최저 임금을 인상한 후, 뉴져지 주의 패스트푸드 레스토랑의 평균 고용량이 증가했습니다.\n\n유감스럽게도, 이러한 결론은 결정적이지 않습니다. 이 간단한 비교에는 많은 결함이 있습니다. 처리 전후를 비교할 때 강력한 가정 하나를 보여줍니다: 최저 임금이 인상되지 않았다면 뉴저지의 고용 수준은 변경 전과 동일하게 유지되었을 것이라는 것입니다.\n\n직관적으로, 이는 그럴듯한 시나리오로 보이지는 않습니다. 이 기간 동안 일반 경제 활동이 증가할 가능성이 있었고, 정부 프로그램이 고용을 보조할 수도 있었으며, 레스토랑 업계가 수요 증가로 큰 폭으로 경험할 수도 있었습니다. 이러한 시나리오 중 일부는 고용 수준에 영향을 미칠 수 있습니다. 간단히 선천과 후천을 비교하여 처리의 인과 관계적 영향을 확립하는 데는 보통 충분하지 않습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이와 같은 비교는 다양한 상황에서 매우 일반적입니다. 이전에 논의한 방법보다 더 신뢰할 수 있다고 생각하더라도 결과를 비교할 때는 항상 신중해야 합니다.\n\n# 차이 차이법\n\n마침내 이제 우리는 공연의 주인공인 차이 차이법을 소개할 준비가 다 되어 있습니다. 우리가 처리 이후 두 그룹을 비교해서 인과 효과가 있는지 확인하는 것만으로는 부족하다는 것을 발견했습니다. 처리 전후에 처리된 그룹을 비교하는 것만으로도 충분하지 않습니다. 이 두 방법을 결합해 볼까요?\n\n차이 차이 분석을 통해 선택한 그룹 간의 결과 변수 변화를 시간에 따라 비교할 수 있습니다. 시간은 매우 중요한 요소로, 우리는 처리가 시작된 이후에 무엇이 어떻게 변했는지 비교할 수 있습니다. 이 방법의 단순함은 놀랍지만, 모든 인과적 접근 방법과 마찬가지로 가정에 의존합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에 다양한 유의점에 대해 다룰 예정이에요. 우선, 이 평가 연구를 수행하는 데 필요한 구성 요소에 대해 시작해보죠. DiD 연구는 적어도 두 개의 서로 다른 시기에 두 개의 그룹이 필요해요. 한 그룹은 치료를 받고, 다른 하나는 비교 그룹으로 사용돼요. 언제 그룹을 비교할지 알아야 해요. 이 작업을 위해 필요한 항목은 무엇이 있을까요?\n\n- 통제 그룹의 전 치료 시점 결과 변수 값\n- '치료받는' 그룹의 전 치료 시점 결과 변수 값\n- 통제 그룹의 후 치료 시점 결과 변수 값\n- '치료받는' 그룹의 후 치료 시점 결과 변수 값\n\n다음 단계로 진행하여 다음 메트릭을 계산해야 합니다:\n\n- 치료받는 그룹과 통제 그룹 사이의 결과 변수 차이(치료 전 기간)\n- 치료받는 그룹과 통제 그룹 사이의 결과 변수 차이(치료 후)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 할 일은 무엇인가요? 우리는 마침내 차이-차이(differece-in-differences)를 계산합니다. 이는 전 처리와 후 처리 사이의 차이를 의미합니다. 이 측정은 평균 처리 효과의 추정을 제공합니다.\n\n이 전략의 이유를 쉽게 이해할 수 있어요. 무작위화 실험에서의 데이터 부족으로 인해 그룹 간의 차이를 비교할 수 없습니다. 그러나 그룹 간의 차이를 측정하는 것은 가능합니다. 치료 이전과 이후 기간을 비교하여 치료 효과를 나타내는 결과 변수의 차이를 측정할 수 있습니다.\n\n왜 그럴까요? 치료가 시작되기 전에 두 그룹 모두 결과 변수에 대한 기준 값을 갖고 있었습니다. 아무 일도 일어나지 않았다면 두 그룹에서 무엇이든 동일하게 유지될 것으로 가정합니다. 그러나 치료가 진행되었습니다.\n\n치료는 한 그룹에만 영향을 미쳤습니다. 따라서, 결과 변수에서의 어떠한 변화는 '치료된' 그룹에서만 발생해야 합니다. 치료 그룹에서의 어떠한 변화는 결과 변수를 통제 그룹과 비교했을 때 결과 변수를 바꿀 것입니다. 이 변화는 치료의 효과입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제어 그룹의 성과와 추이가 치료 전과 동일할 것으로 가정합니다. 또한, 치료가 발생하지 않았다면 치료 그룹의 개인들이 이전 활동을 유지했을 것으로 가정해야 합니다. 한 그룹에서의 치료 발생은 상황을 변화시키고 치료 효과를 제공합니다.\n\n## 응용\n\n새로운 도구를 사용하여 최저임금의 영향을 조사할 수 있습니다. 최저임금 예시로 돌아가서, 우리가 가지고 있는 정보를 토대로 다음 숫자를 알아낼 수 있습니다:\n\n- 뉴저지의 최저임금 인상 전 고용 상황\n- 펜실베이니아의 최저임금 인상 전 고용 상황\n- 뉴저지의 최저임금 인상 후 고용 상황\n- 펜실베이니아의 최저임금 인상 후 고용 상황\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최저임금이 인상되기 전에는 펜실베이니아의 패스트푸드 레스토랑 평균 고용량이 더 많았습니다. 그러나 인상 이후에는 상황이 변했고, 두 주 간의 평균 고용 차이가 훨씬 줄었습니다.\n\n아래 코드는 최저임금 인상 이전과 이후의 고용 차이를 계산합니다 (nj_difference 및 penn_difference). 또한 두 차이를 빼는 것으로 차이 차이 추정치를 계산합니다.\n\n아래 코드는 차이를 플롯하여 시각적인 비교를 제공합니다. 추가로 대조사실선을 추가하고 있습니다. 기술적으로, 패스트푸드 레스토랑 업종이 펜실베이니아의 추세를 따른다면 뉴저지의 사후처리 고용량을 추정하는 것입니다. 차이-차이 이해에 중요한 역할을 하는 다음 단락에서 이 대조사실선에 대해 논의할 것입니다.\n\n차트에서 보듯이 뉴저지의 평균 고용량이 0.59 증가했고, 펜실베이니아에서는 감소했습니다. 이를 계산하여 차이를 측정하면 처리 효과를 2.75로 얻을 수 있습니다. 최저임금 인상은 평균 고용량 증가로 이어졌는데, 이는 놀라운 결과입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot](/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_4.png)\n\n한번 이 결과를 초래한 것에 대해 고려해 보겠습니다. 뉴저지의 고용은 크게 증가하지 않았습니다. 그러나 펜실베이니아의 평균 고용률은 감소했습니다.\n\n최저 시급이 오르지 않았다면, 뉴저지의 평균 고용은 펜실베이니아에서 관측된 추세를 따라가는 것으로 예상됩니다. 최저 시급이 오르지 않았다면, 평균 고용은 더 낮았을 것입니다.\n\n차트에서 보면, 뉴저지의 추세가 펜실베이니아에서 관측된 추세를 따르는 대역상실한 선으로 표시되어 있습니다. 대역상실한 선과 뉴저지에서 관측된 실제 값과의 차이는 2.75의 치료 효과를 나타냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n치료의 도입으로 이러한 추세가 변하고 뉴저지의 고용이 해당 값을 유지하고 약간 증가할 수 있습니다. 이러한 유형의 분석에서 중요한 것은 처리 그룹의 변화가 대조 그룹에서 관찰된 변화와 비교하여 어떻게 되는지입니다.\n\n아래 표는 대개 DiD 분석에서 만나는 형식으로 계산 내용을 요약합니다. 치료 및 대조 그룹은 열에 나타내고, 기간은 행에 나타내며, 결과 변수의 측정값은 셀에 나타냅니다.\n\n오른쪽 하단 모서리에는 차이를 계산한 후 최종 추정치가 표시됩니다.\n\n![표](/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선형 회귀를 사용한 차이 차이 방법\n\n몇 가지 평균을 간단히 계산해 보았습니다. 차이 차이 모델의 계산의 간단함은 그 장점 중 하나입니다.\n\n그 결과를 얻는 다른 방법도 있습니다. 좋고 오래된 선형 회귀를 사용하여 동일한 결론에 도달할 수 있습니다. 이 모델을 여러 기간 및 그룹으로 확장하는 것이 유익할 것입니다.\n\n차이 차이 모델의 주요 장점 중 하나는 그 간단함입니다. 이 모델을 실행하기 위해 소수의 변수만 필요로 하며, 이를 간단하고 쉽게 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 결과 변수: 총 고용 (Y)\n- 기간: 처리 이전에는 0이고 처리 기간에는 1인 더미 변수 (T)\n- 그룹: 대조군에는 0이고 치료군에는 1인 더미 변수 (G)\n\n모델은 다음과 같은 형태를 가지고 있습니다:\n\n![식](/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_6.png)\n\n이 모델을 어떻게 해석할까요? B1은 처리 기간이 시작될 때 결과 변수 값의 증가를 나타냅니다. 우리의 예제는 처리 전후의 대조군 평균 고용 차이를 보여줍니다. 우리는 최저 임금이 증가하지 않는 상황에서 이 변화가 발생할 것으로 기대합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nB2는 통제 그룹에서 처리 그룹으로 결과 변수가 변경된 것을 나타냅니다. 이는 치료 전 세계의 두 그룹 간의 기준 차이입니다.\n\n치료 기간과 그룹 간의 상호 작용 용어(T*G)는 처리 기간과 처리 그룹이 모두 활성화 되었을 때 결과 변수의 변화를 보여줍니다. 처리된 그룹의 경우 처리된 기간에 대해 0이 아닌 값이 있습니다.\n\nDiD 분석에서 우리는 처리된 그룹에서 처리 기간 동안의 결과 변수 변경을 통제 그룹과 비교하는 것을 원합니다.\n\n이 모델의 결과를 Python에서 계산하는 많은 방법이 있습니다. 이 예제에서는 statsmodels 라이브러리를 사용할 것입니다. 우리 예제에서의 선형 모델의 명세는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회귀 출력 결과를 보면, (노란색으로 표시된) 치료 효과가 바로 위에서 계산한 값과 동일함을 확인할 수 있습니다. 모든 계수가 이전에 계산한 값과 일치하는지 확인할 수 있어요.\n\n![같이 보기](/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_7.png)\n\n간단한 평균 계산에 회귀 분석을 사용하는 것이 지나치다고 느껴질 수 있지만, 여러 이점이 있답니다.\n\n먼저, 모든 그룹에 대한 평균을 계산하는 것보다 계산이 더 간단해요. 또한 모델을 확장하여 여러 비교 그룹과 기간을 포함할 때 회귀의 이점을 볼 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핵심적인 가정들입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회귀 분석은 차이 차이 모델의 적용을 결론 지었습니다. 이 시연은 이 방법이 얼마나 강력한지를 보여줍니다. 마무리하기 전에 이 모델의 잠재적인 한계에 대해 생각해 봅시다.\n\n원인 추론의 대부분에 대해, 모델은 우리가 그에 대해 하는 가정만큼 좋습니다. 이 방법에서 올바른 비교 그룹을 찾는 것은 필수적이며 도메인 전문 지식이 필요합니다.\n\n차이 차이에 대해 읽을 때 항상 평행한 추세 가정을 만나게 됩니다. 이는 치료 전에 두 그룹이 결과 변수의 일관된 추세를 가졌다는 것을 의미합니다. 또한 이 모델은 해당 추세가 시간이 지남에 따라 지속되고 그 차이가 치료가 없을 때 결과 변수에서 두 그룹 간에 동일하게 유지되도록 요구합니다.\n\n우리의 예에서는 두 주에서 패스트푸드 음식점의 평균 고용 변화가 시간에 따라 동일하게 변경된다고 가정합니다. 이 가정이 충족되지 않는 경우 차이 차이 분석은 편향됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n역사는 하나의 것이지만, 우리는 또한 이 추세가 시간이 지나도 계속될 것으로 가정하며, 이것은 우리가 결코 알지 못하고 테스트할 수 없는 것입니다.\n\n이 가정은 부분적으로만 테스트할 수 있습니다. 우리는 역사적인 추세를 살펴보아 비슷한지 평가할 수 있습니다. 이를 위해 더 많은 역사적 데이터가 필요합니다—시간을 경과하며 추세를 그래프로 나타내면 이 가정의 좋은 지표가 됩니다.\n\n이것은 부분적으로 테스트할 수 있으며, 우리는 치료를 받은 그룹의 행동만 평가할 수 있습니다. 병든 그룹이 우리의 통제 그룹과 동일한 행동을 보였다고 가정하지만, 우리는 100% 확신할 수 없습니다. 우리가 평가할 수 있는 세상은 단 하나뿐입니다. 이것이 인과 추론의 근본적인 문제입니다.\n\n차이-차이(Difference-in-Differences)는 두 그룹의 구조가 시간이 지나도 동일하게 유지되어야 합니다. 치료 전에 두 그룹이 동일한 구성을 가져야 합니다. 그들은 치료에 노출되는 것을 제외하고는 동일한 특성을 가져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n첫눈에는 모든 가정들이 이 방법을 덜 매력적으로 만들 수 있습니다. 그렇지만 가정 없이 통계적이고 분석적인 접근이 있을까요? 가능한 한 품질 좋은 데이터를 확보하고, 민감도 분석을 수행하며, 도메인 지식을 활용해야 합니다. 그러면 차이-차이 방법을 사용하여 흥미로운 통찰을 발견할 수 있습니다.\n\n위 게시물은 한 가지 단점이 있습니다 (그 외에도 많을 수 있습니다 — 알려주시면 감사하겠습니다). 상대적으로 간단한 시나리오인 두 그룹과 두 기간을 다루고 있습니다. 다가오는 게시물에서는 동일한 기술을 좀 더 복잡한 환경에서 사용하여 이 그림을 더 복잡하게 만들 것입니다.\n\n차이-차이 방법에 관한 설명이 도움이 되었으면 좋겠습니다. 이 글은 인과 추론에 대한 내 학습을 공유하기 위한 첫걸음입니다. 더 많은 내용이 이어질 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\nCard, David \u0026 Krueger, Alan B, 1994. “Minimum Wages and Employment: A Case Study of the Fast-Food Industry in New Jersey and Pennsylvania,” American Economic Review, American Economic Association, vol. 84(4), pages 772–793, September\n\nhttps://davidcard.berkeley.edu/data_sets.html\n\nImpact Evaluation in Practice — Second Edition https://www.worldbank.org/en/programs/sief-trust-fund/publication/impact-evaluation-in-practice\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://mixtape.scunning.com/09-difference_in_differences","ogImage":{"url":"/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_0.png"},"coverImage":"/assets/img/2024-05-20-ExploringcausalitywithPythonDifference-in-differences_0.png","tag":["Tech"],"readingTime":11},{"title":"파이썬에서 데이터 정제하기","description":"","date":"2024-05-20 21:54","slug":"2024-05-20-DATACleaninginPython","content":"\n\n요구 사항: - Python3, 판다 라이브러리\n\n파이썬에서 데이터 클린업을 위한 몇 가지 미리 정의된 메서드가 있어요\n\n예: — dropna(), fillna(), duplicated(), loc()\n\n1. Dropna : 빈 행을 제거하는 데 사용돼요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-20-DATACleaninginPython_0.png)\n\n제가 데이터 세트를 가지고 있는데 빈 셀을 제거하고 싶어요 (제 경우 (5. 2015)) 빈 셀이 포함된 행을 제거할 수 있어요.\n\n![image](/assets/img/2024-05-20-DATACleaninginPython_1.png)\n\n2. Fillna() : 빈 값을 fillna 메서드로 대체할 수 있어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-DATACleaninginPython_2.png\" /\u003e\n\n이제 빈 값을 숫자 90으로 바꿀 수 있어요!\n\n\u003cimg src=\"/assets/img/2024-05-20-DATACleaninginPython_3.png\" /\u003e\n\n그리고 빈 값을 평균, 최빈값, 중앙값으로 대체할 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-05-20-DATACleaninginPython_4.png)\n\n![Image 2](/assets/img/2024-05-20-DATACleaninginPython_5.png)\n\n3. Duplicate(): it can remove duplicate rows from our dataset\n\n![Image 3](/assets/img/2024-05-20-DATACleaninginPython_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. `loc()`: `loc`은 location을 의미하며 이 함수를 사용하여 값을 바꿀 수 있습니다. 예를 들어, 데이터 세트에 잘못된 값이 들어가 있을 때 이 값을 변경하고 싶다면 `loc()`를 사용할 수 있습니다 :\n\n![파일](/assets/img/2024-05-20-DATACleaninginPython_7.png)\n\n이제 5번째 행의 값을 98로 바꾸고 싶다면 :\n\n![파일](/assets/img/2024-05-20-DATACleaninginPython_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-20-DATACleaninginPython_9.png)\n","ogImage":{"url":"/assets/img/2024-05-20-DATACleaninginPython_0.png"},"coverImage":"/assets/img/2024-05-20-DATACleaninginPython_0.png","tag":["Tech"],"readingTime":2},{"title":"JavaScript, Rust, 그리고 GPT-3로 60초 안에 400개 이상의 탭 정렬하기","description":"","date":"2024-05-20 21:47","slug":"2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3","content":"\n\n## 모든 재미를 위해 GPT-3 사용 중.\n\n![테이블 이미지](/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_0.png)\n\n저는 탭 중독자입니다. 솔직하게 말하자면요.\n\n현재 5개의 브레이브 창에서 약 460개의 탭을 열어 두고 있습니다. 북마크는 신경쓰지 말아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n응, 난 정보 햄스터 같아. 모든 탭을 호아딩해놓고 충분한 시간을 내어 모든 걸 읽으려고 노력할 때까지 새로운 탭을 더 열어. 알 수 있듯이, 너무 많은 탭을 가지고 있다는 건 상당히 압도적일 수 있어. 탭 바의 경계 너머로 사라져 버렸을 때 뭔가를 찾아야 하는 경우거나, 화면을 바라보며 \"할 일이 너무 많다\"는 불안한 느낌이 드는 경우 등이 있지. 그냥 어떤 작업도 해야 할 일이 없는 데도 말이야.\n\n그래서 게을러버리고 있는 해커 본성으로, 그들을 실제로 정리하거나 청소하거나 *이런* 단순히 모두 닫지 않고 기계가 할 수 있는 방법이 없을까 궁금해졌어. 내 괴로움의 1클릭 솔루션을 갖출 수 있을까?\n\n내 내면의 과다 집착자를 코드를 사용해 마리 콘도의 노예로 바꿀 수 있을까?\n\n다행히도, 우리에게는 수십억 달러의 가치가 있을 모델 언어가 있어 열심히 일을 할 준비만 하고 기다리고 있지.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아이디어는 간단해요: GPT-3에 항목 목록을 제공하고 해당 항목이 속하는 카테고리 목록을 요청하세요. 그것을 Chrome 확장 프로그램으로 묶어서 마법이 일어나게 해 보세요.\n\n그래서, 손가락을 털어놓고 코딩해 봅시다.. 아니면.. 음... 기다려 봐요..\n\n# 복잡성의 달콤한 맛\n\n조금 되돌아가 봅시다. 우리의 계획은 충분히 간단해 보이죠. 그러나 소프트웨어에서 보통 그렇듯, 우리는 제대로 생각하지 않으면 범위와 예산을 폭발시킬 중요한 세부사항을 놓쳤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드에 처음 뛰어들기 전에 후회의 세계에 빠지지 않도록 고려해야 할 중요한 문제 몇 가지가 있습니다:\n\n- 프롬프트 토큰 한도 - OpenAI의 언어 모델은 토큰 한도를 가지고 있습니다 - 2048 또는 4096 토큰. 각 토큰이 약 4개의 문자이기 때문에 우리의 프롬프트와 응답 크기는 각각 8192/16384 문자로 제한됩니다. 이 문제를 해결하는 몇 가지 방법이 있습니다(모두 다루겠습니다): 프롬프트를 소모 가능한 청크로 나누기, 토큰 수를 줄이기 위해 보내는 데이터 최적화, 우리의 작업에 대한 모델을 세밀하게 조정하기\n- API 키 보안 - OpenAI API는 사용된 토큰으로 API 호출을 청구하므로 API 키를 안전한 곳에 숨겨야 합니다. 확장 프로그램에 하드코딩하는 것은 권장되지 않습니다 - 우리의 키를 스크랩하려는 지루한 스크립트 키디로 인해 OpenAI에 백만 달러의 청구서를 지불하길 원한다면 제외합니다.\n- 사용자 프라이버시 - 탭 제목과 URL은 민감한 정보를 드러낼 수 있습니다 - 개인 문서, 링크, 세션 ID 및 개인에 대한 많은 데이터. 사용자가 확장 프로그램을 신뢰할 수 있도록 하려면 오픈 소스로 공개하고, 해당 소스에서 빌드 및 배포하고 다른 사람들에게 쉽게 배포할 수 있도록 해야 합니다.\n- 업데이트 용이성 - LLMs는 응답에 소질이 있고 OpenAI API는 단순한 실수로 인해 엄청난 사용 비용이 발생할 수 있으므로 사용자가 자유롭게 업데이트하게 두는 대신 업데이트를 통제하고 싶습니다. 이는 가장 중요한 코드를 확장 프로그램에 두지 않고 제어하고자 함을 의미합니다.\n\n이러한 문제를 어떻게 해결할까요?\n\n간단한 방법을 채택할 것입니다 - 확장 프로그램 자체에 모든 로직을 작성하는 대신 API 뒤에 숨깁니다 - 탭 데이터를 전달할 간단한 백엔드 서비스를 구축하여 프롬프트를 나누고 OpenAI API와 통신하여 데이터를 단일 응답으로 줄입니다. 이를 통해 키를 안전하게 보호하고 업데이트를 제어하며 시크릿 토큰을 노출하지 않고도 확장 프로그램을 오픈 소스로 공개할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 위해 Rust를 사용할 것입니다. 백엔드 프레임워크로 Axum을, 배포 플랫폼으로 Shuttle을, 그리고 CI로 GitHub Actions를 사용할 것입니다.\n\n그래서 코드 작성에 앞서, 무엇을 구축하고 있는지 개략적으로 파악하기 위해 냅킨 스케치를 몇 장 그려봅시다:\n\n\u003cimg src=\"/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_1.png\" /\u003e\n\n## 단계 1: 확장 프로그램 구축하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크로미움 확장 프로그램을 만드는 것은 매우 간단해요. 그냥 브라우저 안에 살아있는 작은 웹페이지들이에요. (적절한 권한으로) 브라우저의 API에 접근할 수 있어요.\n\n우리는 Chrome API를 사용할 거예요. 이 API는 구글 크롬이 사용하는 API인데, 많은 크로미움 기반 브라우저들이 노출시켜요 (예를 들어, 저는 Brave를 사용하고 있어요. 물론 Edge도 사용해요, 다만 다른 이름공간을 사용해요).\n\n다른 브라우저들은 크로미움 프로젝트 기반으로 만들어지지 않았지만, 비슷한 확장 프로그램 API를 제공해요. 만약 두 API 간 차이에 대해 더 알고 싶다면, MDN 기사를 추천해요.\n\n구체적으로, 이 두 API에 초점을 맞출 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- chrome.tabs - 현재 사용자가 열어둔 탭을 조회할 수 있도록 합니다.\n- chrome.tabGroups - 기존 그룹을 조회하고 새 그룹을 만들며 그 안에 탭을 이동할 수 있도록 합니다.\n\n그럼 이제 빌딩 과정으로 넘어가 봅시다.\n\n확장 프로그램을 시작하기 위해 Chrome 확장 프로그램 CLI를 사용할 것인데요 — 이를 통해 필요한 초기 프로젝트 구조를 생성합니다.\n\n그러니 터미널을 열고 다음을 입력해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nnpm install -g chrome-extension-cli\nchrome-extension-cli bookie-js\ncd bookie-js\n\n\n마지막에 나오는 안내에 따라 빌드 폴더를 확장 프로그램으로 로드하세요. 이를 통해 확장 프로그램을 핫 리로드를 통해로드 및 테스트할 수 있어서 변경 사항이 즉시 보입니다.\n\n지금 생성된 구조 안을 엿보세요. 대부분이 자명합니다.\n\n\n├── README.md\n├── config\n│   ├── paths.js\n│   ├── webpack.common.js\n│   └── webpack.config.js\n├── node_modules\n├── package-lock.json\n├── package.json\n├── pbcopy\n├── public\n│   ├── icons\n│   ├── manifest.json\n│   └── popup.html\n└── src\n    ├── background.js\n    ├── contentScript.js\n    ├── popup.css\n    └── popup.js\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 현재 주로 세 개의 파일에 관심이 있어요:\n\npublic/manifest.json — manifest는 당신의 확장 프로그램에 대한 정보를 브라우저에 제공하는 JSON 파일입니다. 이 파일에는 이름, 기능, 시작 방법, 어떤 파일을 표시할지, 페이지에서 실행할 스크립트 등이 포함되어 있어요. 우리가 주목해야 할 몇 가지 필드는 다음과 같아요:\n\n- default_popup - 확장 프로그램 아이콘이 클릭될 때 나타낼 HTML 파일\n- permissions - 특정 Chrome API의 일부에 액세스하기 위해 필요한 권한\n- host_permissions - 당신의 확장 프로그램이 액세스할 수 있는 URL 패턴들의 집합\n\n지금은 이 모든 것을 그대로 두고, 나중에 다시 돌아와서 확인할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsrc/popup.html은 UI의 시작점입니다. 웹 브라우저의 확장 기능 버튼을 클릭하면 이 HTML이 팝업됩니다. 여기에 간단한 인터페이스를 구축하는 데 사용할 것입니다.\n\nAPI의 /sort 엔드포인트를 호출하고 결과를 반환하는 '정렬' 버튼, 로딩 표시줄 및 문제가 발생할 경우 간단한 오류 상자가 있을 것입니다.\n디버깅을 위해 '탭 표시' 버튼을 추가하여 모든 탭의 목록을 표시할 수도 있습니다. 이제 몇 줄의 간단한 HTML을 작성해 봅시다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003ctitle\u003eBookie JS\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"popup.css\" /\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cdiv class=\"app\"\u003e\n      \u003cdiv class=\"button-container\"\u003e\n        \u003c!-- 이 버튼을 클릭하면 API가 호출됩니다 --\u003e\n        \u003cbutton id=\"sortBtn\" class=\"button\"\u003e정렬하기\u003c/button\u003e\n        \u003cdiv id=\"loading\" class=\"loading\"\u003e\u003c/div\u003e\n        \u003cdiv id=\"error\" class=\"error\"\u003e\u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cscript src=\"popup.js\"\u003e\u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\nsrc/popup.js 파일은 JS가 위치하는 곳입니다. 우린 적당한 Vanilla JS 만 사용할 것이니 예쁘고 견고한 사이버네틱 SSSR JavaScript 프레임워크는 사용하지 않을 거에요. UI를 업데이트하기 위해 DOM 요소를 조작하는 간단한 render(state) 함수에 의존하며, 요소.style.display를 block/none으로 변경하여 간단한 표시 및 숨김 함수를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 함수로 우리의 사고 과정을 작성해 봅시다.\n\n```javascript\n'use strict';\nimport './popup.css';\n\n(function () {\nconst SORT_BTN = 'sortBtn';\nconst LOADING = 'loading';\nconst ERROR = 'error';\n    \n// API에서 탭 및 그룹을 가져옵니다\nasync function getTabsAndGroups(){};\n// 데이터로 백엔드 호출\nasync function callBackendToSort(tabsAndGroups){};\n// 브라우저에 결과를 적용합니다\nasync function applySort(sortedCategories){};\n// 앱 실행\nasync function run(){\n// 탭을 가져옵니다\nlet tabsAndGroups = await getTabsAndGroups();\nrender({loading: false, error: null}\nlet btn = document.getElementById('sortBtn')\n// 클릭하면 API를 호출하고 로딩을 표시하고 결과를 적용합니다\n btn.addEventListener('click',async ()=\u003e {\n     render({loading: true, error: null}\n      try {\n        let result = await callBackendToSort(tabsAndGroups)\n        await applySort(result)\n        render({loading: false, error: undefined})\n      }catch (e){\n        render({loading: false, error: e})\n      }\n })\n}\n// 콘텐츠가로드 될 때 run 함수를로드합니다\ndocument.addEventListener('DOMContentLoaded', run);\n    \n})();\n```\n\n첫 번째 단계는 Chrome API에서 탭과 그룹을 조회하는 것입니다. 문서에 따르면 chrome.tabs.query를 사용하여 이 작업을 수행할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래, 한번 해보죠:\n\n```js\nasync function getTabsAndGroups() {\n    let chromeTabs = await chrome.tabs.query({})\n    console.log(chromeTabs)\n}\n```\n\n작동하지 않나요? 이제, 그 public/manifest.json 파일을 기억하시나요? 그리고 permissions 객체를요?\n\n그래서, 탭들, 제목들, 그리고 그룹들에 접근하려면, 그에 맞는 권한들을 추가해야 합니다. 그래서 manifest.json을 열어서 permissions 아래에 \"tabs\", \"tabGroups\"를 추가합니다. 그러면 설치시, Chrome이 확장 기능의 권한을 확인하고 사용자에게 어떤 정보에 접근하는지 알려줄 수 있습니다.\n하지만, 탭 API에 접근하려면, host-permissions라는 다른 특별한 권한이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확장 프로그램이 실행되는 웹 사이트를 사용자에게 알려줍니다. 따라서 모든 탭에서 이를 사용하려면 적절한 URL 패턴을 추가해야 합니다. 그래서 manifest.json에 \"host_permissions\"라는 새 속성을 추가하여 모든 URL과 일치하도록 패턴을 설정하세요. 예를 들어 \"host_permissions\": [\"*://*/*\"]입니다. 마지막으로 이제 사용자의 모든 탭과 그룹에 액세스할 수 있습니다.\n\n이제 작동 중이므로 chrome.tabs.query 메서드가 반환하는 데이터에는 필요한 몇 가지 항목이 포함됩니다: id, title 및 groupId. 우리는 id와 title을 정렬에 사용하고, groupId를 쿼리하는 데 사용할 것이므로 먼저 반환된 객체를 필요한 속성만 사용하여 간소화된 버전으로 매핑할 것입니다.\n\n그룹에 대한 더 많은 데이터를 얻으려면 tabsForGroups 함수를 만들어야 합니다. 이 함수는 모든 고유 그룹을 찾고 각 그룹의 제목을 가져오기 위해 chrome.tabGroups.get(id)를 사용하여 Chrome API를 쿼리할 것입니다.\n\n```js\nasync function tabsToGroups(tabs){\n  //탭에서 모든 기존 그룹Id 가져오기\n  let groupIds = tabs\n      .map( (it)=\u003eit.groupId)\n      .filter((it)=\u003eit!==null \u0026\u0026 it!==undefined \u0026\u0026 it!==-1);\n  \n  //고유한 것만 가져올 수 있도록 세트에 넣기\n  let groups = new Set(groupIds)\n  \n  //각 탭 그룹에 대한 데이터를 가져오기 위해 chrome API에 쿼리\n  return await Promise.all([...groups]\n      .map(async (it) =\u003e {\n      let item = await chrome.tabGroups.get(it)\n        return {\n          id: item.id,\n          title: item.title\n        }\n    }));\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이제 함수가 모든 탭과 그룹을 반환할 수 있습니다.\nasync function getTabsAndGroups() {\n    let chromeTabs = await chrome.tabs.query({});\n    let tabs = await mapTabs(chromeTabs);\n    let tabsWithGroups = await tabsToGroups(tabs);\n    let groups =  tabsWithGroups.filter((it)=\u003eit.title.length !== 0);\n    return {\n      items: tabs,\n      categories: groups\n    };\n}\n```\n\n와아, 몇 가지 간단한 단계로 기존 그룹과 탭 목록을 가져왔어요.\n\n또한 API 호출 함수도 매우 간단합니다. 아직 API가 없기 때문에 로컬호스트로 일반 POST 요청을 작성할 거에요:\n\n```js\nasync function callBackendToSort(data) {    \n return await fetch('http://127.0.0.1:8000/sort',{\n      method: 'POST',\n      headers: {'Content-Type': 'application/json'},\n      body: JSON.stringify({\n        items: data.items,\n        categories: data.categories\n      })\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 render 함수도 상당히 간단해요. 상태를 확인하고 UI를 그에 맞게 변경하는 것뿐이죠.\n\n```js\nfunction render(state){\n    if(state.loading){\n      show(LOADING)\n      hide(SORT_BTN)\n      hide(ERROR)\n    }else{\n      hide(LOADING)\n      show(SORT_BTN,true)\n    }\n    if(state.loading!==true \u0026\u0026\n      (state.error!==undefined \u0026\u0026 state.error!=null)){\n      show(ERROR)\n      showError(state.error)\n    }else\n      hide(ERROR)\n}\n```\n\n이제 할 일은 브라우저에 새로운 카테고리를 적용하는 applySort 함수를 구현하는 것 뿐입니다.\n\n아이디어는:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 그룹이 존재하는지 확인하세요.\n- 그룹이 없다면, 새로 만드세요.\n- 탭 목록과 제목을 업데이트하세요.\n\n이를 위해 API 조사를 좀 해야 합니다. 이 부분을 다루는 문서가 조금 혼란스러울 수 있어요. \nchrome.tabGroups.create 또는 chrome.tabGroups.update와 같은 것이 있을 것으로 예상할 수 있지만... 그런 건 순진한 생각이죠.\n\n그룹을 만들기 위해 사용하는 API 호출은 chrome.tabs.group으로, chrome.tabs.group에 groupId를 전달하지 않습니다. 그럼 그룹이 생성되고 새로운 groupId가 반환됩니다. 이것은 chrome 팀에 의해 조금 이상한 호출입니다 - 탭이 그룹에 대해 알고 있고 제어해야하는 이유는 무엇인가요?\n\n그룹은 그룹 API를 통해 생성하고 관리되어야 할 텐데요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아, 또한 그룹에 탭을 추가하려면 동일한 호출을 사용하여 tabIds를 통해 탭 배열을 전달합니다. \"이 API 호출을 통해 이미 객체를 생성하고 업데이트하고 있기 때문에 제목도 전달할 수 있을까요?\" 아니요, 그렇게 하려면 chrome.tabGroups.update API 호출을 사용해야 합니다.\n\n나는 이 이상한 구문이 그룹이 chrome에 추가 기능이었기 때문에 지원이 탭 API 자체로 후방 적용되었다고 가정했습니다. 그래서 이 가정을 테스트해 봅시다. Tabs API에 그룹을 추가한 커밋을 살펴보면 같은 논의가 댓글에서 나타나며, Tab Group API 제안으로 이어집니다. 팀은 탭 관리와 그룹 관리 사이의 역할을 분할하기로 결정한 것으로 보입니다. 탭을 이동시키는 것은 탭 관리이므로 해당 역할은 Tabs API에 속합니다.\n\n대체 제안도 논의되었었으며(TabGroups API에 해당 역할을 넣는 것), 그것의 장단점도 함께 논의되었습니다:\n\n![이미지](/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 관점에서(API 사용자로서) 단점 목록은 그렇게 나쁘지 않아 보입니다. 탭은 그룹에 대해 알 필요가 없을 것이며, 사용자 보안이 강화될 것입니다(확장 프로그램은 tabGroups 권한만 필요로 하며, 악성 확장 프로그램에 의한 잠재적인 남용 가능성이 줄어들 것입니다) 그리고 이는 추상화가 가지는 의미인 직관적 API로 구현 세부 정보를 숨겨주며 대체할 것입니다. 그래도 이상한 결정일 수 있어요.\n\n하지만 이따가 이런 걸 더 많이 이야기하고 있지 않고, 코드를 쓰도록 해봅시다.\n\n```js\nfunction applySort(sortedCategories){\n/* 우리가 원하는 응답 객체는 다음과 같습니다: \n{ categories: [\n { category_id: int, category_title: string, items: [int] }\n    ] }\n*/\nfor (i = 0; i \u003c sortedCategories.categories.length; i++) {\n     let category = sortedCategories.categories[i]\n     let categoryId = category.category_id\n     // ID가 있는 그룹을 확인합니다\n     let groupExists = await chrome.tabGroups.get(categoryId)\n          .catch((e)=\u003eundefined);\n      let groupId;\n      if(groupExists === undefined)\n         // ID가 없다면, chrome.tabs.group가 우리에게 ID를 반환합니다\n         groupId = await chrome.tabs.group({ tabIds: category.items });\n      else {\n          \n        // ID가 있다면, 기존 것을 사용합니다\n        groupId = groupExists.id\n        await chrome.tabs.group({groupId: groupId,\n                                tabIds: category.items});\n      }\n// 모든 그룹의 제목을 설정하고 그룹을 축소합니다\n      await chrome.tabGroups.update(groupId, {\n        collapsed: true,\n        title: category.title\n      });\n})\n}\n```\n\n이로써, JS 익스텐션 MVP가 완료되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 탭과 그룹을 수집합니다.\n- 그것들을 API로 보냅니다.\n- 반환된 정렬을 적용합니다.\n\n지금은 아직 API가 없으니 어떻게 테스트할까요?\n\n일부 단위 테스트를 작성해야하지만, 그건 다른 날로 미루겠습니다 (정말로요 — 약간 밑으로 내려가면 Jest를 사용하여 Chrome 확장 프로그램을 테스트하는 것을 살펴볼 거에요).\n\n지금은 callBackendToSort 함수의 반환을 조작하여 몇 가지 카테고리와 몇 가지 탭 ID를 포함시킬 수 있습니다 - 당신의 탭 ID와 함께 이런 식으로 (하지만 당신의 탭 ID로):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n \"categories\": [{\n  \"category_id\": 837293848,\n  \"category_name\": \"Hacker News\",\n  \"items\": [1322973609, 1322973620]\n }, {\n  \"category_id\": 837293850,\n  \"category_name\": \"Science\",\n  \"items\": [1322973618, 1322973617, 1322973608]\n }, {\n  \"category_id\": 837293851,\n  \"category_name\": \"GitHub\",\n  \"items\": [1322973619]\n }, {\n  \"category_id\": 837293852,\n  \"category_name\": \"Web Development\",\n  \"items\": [1322973612, 1322973613, 1322973615, 1322973616]\n }, {\n  \"category_id\": 837293853,\n  \"category_name\": \"Web APIs\",\n  \"items\": [1322973646]\n }]\n}\n```\n\n자, 이제 재미있는 부분으로 넘어갑시다 — API를 구축하기, 프롬프트 최적화, GPT 타임아웃 및 우리가 미래와 과거에서 범할 실수 수정하기.\n\n아, 그리고 우리는 기능의 복잡성과 크립트를 추가할 것이지만, 그것에 대해서는 나중에 더 설명하겠습니다.\n\n이제, 현재 가장 핫한 언어인 Rust로 다가가 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Sorting 400 Tabs in 60 Seconds With JavaScript, Rust, and GPT-3](/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_4.png)\n\n루스트에 대해 설명할 필요가 없을 것 같아요. 돌 아래에 살았더라도 루스트에 대해 들어봤을 거에요. 개발 커뮤니티는 루스트를 하늘 높이 칭찬하고 있어요. C 언어의 속도를 가지고 있으면서 자바의 안전성과 AH-64 아파치 공격 헬리콥터처럼 완벽한 헬리콥터 부모 역할을 하는 빌림 시스템을 가지고 있어요.\n\n하지만 문법이 깔끔하고, 성능이 놀라우며, 매크로도 멋있고, 대부분 메모리에 엄격하지만 여전히 원시 포인터에 액세스할 수 있고 !unsafe해도 돼요.\n\n그래서 이 언어를 익히는 느낌을 받아볼까요? 좀 재미있게 해보죠.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 서비스를 만들 예정이에요. 우리는 탭 컬렉션을 가져와서 조금 단순화하고 OpenAI API와 대화할 거예요. 희망컨대 환각 없이 응답을 우리 익스텐션에서 사용할 수 있는 형태로 파싱할 거예요.\n\n이 과정에서 몇 가지 장애물이 있을 거에요. 탭이 너무 많아 돈을 낭비하는 문제부터 실리콘밸리가 일어나 OpenAI API를 무너뜨리기 전까지 말이에요.\n\n우리 서비스는 꽤 간단할 거예요. 우리는 탭과 기존 카테고리를 POST할 /sort 메소드를 노출할 거에요. 이를 구축하기 위해 Axum 프레임워크를 활용할 거에요. 이를 통해 /sort 엔드포인트가 있는 서버를 쉽게 시작할 수 있어요. 그리고 배포를 위해 셔틀을 사용할 거에요. AWS 구성 파일 물어다님으로 싸움하지 않고 Rust 서버를 쉽게 가동할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트를 구성하는 데 사용할 것이기 때문에 설치부터 시작해봅시다.\n먼저, 러스트 패키지 관리자인 cargo가 필요합니다. 만약 설치되어 있지 않다면 여기에 있는 단계를 따라주세요. 둘째, 셔틀 계정이 필요합니다. 걱정하지 마세요. GitHub으로 1클릭 가입하면 됩니다. 양식을 작성할 필요 없어요.\n\n이제 올드 터미널을 열고 `cargo install cargo-shuttle \u0026\u0026 cargo shuttle login`을 입력한 다음 인증을 완료한 후 `cargo shuttle init`를 실행하세요.\n\n프로젝트 이름 및 위치를 설정하고 메뉴에서 axum을 프레임워크로 선택하세요. 이렇게 하면 라이브러리로 새로운 axum 프로젝트가 구성되며 셔틀이 종속성으로 설정됩니다.\n\n우리 폴더는 이제 이와 같이 보일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n├── Cargo.lock\n├── Cargo.toml\n└── src\n    └── lib.rs\n\n\n간단한 구조에요 — `Cargo.toml` 파일이 있습니다. 이는 `manifest.json`이나 `package.json`의 러스트 버전입니다. 이 파일에는 패키지, 의존성, 컴파일 특징 등에 대한 메타데이터가 포함되어 있어요. `Cargo.lock`은 환경 간 일관된 빌드를 보장하기 위해 지정된 의존성 목록을 담은 파일입니다.\n\n메인 서버 코드는 `src/lib.rs` 파일 안에 있어요. 아직 신선하고 아름다운 상태에서 코드를 살펴보려고 합니다:\n\n\nuse axum::{routing::get, Router};\nuse sync_wrapper::SyncWrapper;\nasync fn hello_world() -\u003e \u0026'static str {\n    \"Hello, world!\"\n}\n#[shuttle_service::main]\nasync fn axum() -\u003e shuttle_service::ShuttleAxum {\n    let router = Router::new().route(\"/hello\", get(hello_world));\n    let sync_wrapper = SyncWrapper::new(router);\n    Ok(sync_wrapper)\n}\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 주목할 점이 몇 가지 있어요:\n\n- 메인 메서드가 없어요 — 이 프로젝트들이 [lib]rary로 표시되어 있기 때문에 미리 정의된 진입점이 필요하지 않아요.\n- 라우터 — 당신의 Axum 서비스에 대한 \"진입점\". 요청은 여기를 통해 라우팅되며 코드는 매우 자명합니다 - 경로와 처리 함수를 매치시켜 요청을 처리해요. 즉, 우리의 supercoolservice.com/hello는 간단한 \"Hello, world!\" 텍스트를 반환할 거에요.\n- SyncWrapper — 우리의 라우터 객체를 감싸서 서로 다른 스레드에서 안전하게 액세스할 수 있도록 해요.\n- #[shuttle_service::main] - 이것은 러스트 매크로에요 - 알고 있다면 주석의 강력한 버전으로 생각해봐요. 코드를 작성하는 코드를 작성할 수 있도록 해주는데, 이게 게을러진 설명이에요. 음.. 여기서 빠른 탈선이 필요한 것 같아요.\n\n## 매크로의 마법 같은 영역으로 빠른 탈선\n\n\u003cimg src=\"/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 매크로에 들어가기 전에 경고로 처음부터 말씀드리겠습니다. 이 글은 [여기에 즐겨 사용하는 언어를 삽입]에서의 매크로에 대한 100% 설명이 아닙니다. 이에 대해 수백 권의 책, 안내서 및 기사들이 존재합니다.\n\n하지만 여기에 우연히 들어온 독자들 중에서 \"모네드는 엔도펑터 범주 내에서 모노이드이다\" 스타일의 매크로 설명 기사를 읽기 싫어하는 분들을 위해, 매크로의 아름다운 토끼굴로 빠르게 들어가보도록 하겠습니다.\n\n그래서 상상해 보죠. 우리가 상상의 언어 '버스트'에서 작업 중이라고요.\n\n'버스트'는 이제 트위터 전체에서 소문이 나고 있는 멋진 새로운 언어이며, 메타버스 AI 웹4 앱의 언어가 될 것으로 말하고 있습니다. 그러나 새로운 언어이므로 아직 초기 단계이며 많은 라이브러리가 없습니다. 예를 들어, 아직 JSON 직렬화 라이브러리가 없기 때문에 직렬화 코드를 아직 수동으로 작성해야 합니다. 따라서 구조체를 만들 때마다 직렬화 코드를 작성해주어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimpl ToJson for ReallyBigModel {\n   fn toJson() -\u003e String {\n       return mapOf { \"id\" to id, \n             \"name\" to name,\n             \"isReal\" to isReal,\n             ..., \n             \"stuff\" to stuff.toJson())\n         }.toJson() \n   }\n}\n```\n\n조금 귀찮죠? 매일 이렇게 많은 보일러플레이트를 작성하고 싶지 않으시죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 어느 날, 최신 변경 로그를 읽는 중에 새롭게 추가된 매크로(macros)라는 새로운 기능을 발견했다. 매크로는 여러 종류가 있지만, Bust에서의 매크로는 두 가지로 구성된 특별한 메서드로 정의할 수 있는 것이야:\n\n- 매크로 속성(attribute)\n- 매크로 함수\n\n속성은 다른 코드에 적용할 수 있는 표식 같은 거야.\n\n클래스나 메서드 위에 큼지막한 빨간 X 표시가 있는 걸 상상해봐. 그래서 컴파일러가 컴파일 중에 함수를 만나면, 그 함수 머리 위에 큼지막한 빨간 X 표시가 있다면, 너의 매크로 함수를 호출해야 한다는 걸 알 수 있어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매크로 함수는 속성으로 표시된 코드를 받아 처리한 후, 새로운 코드를 컴파일러에 반환하여 해당 기능이 있는 곳에 통합합니다.\n\n예를 들어, 우리가 toJson 매크로를 만들었다면, 어떤 구조체 위에 toJson 속성을 추가할 수 있으며, 이를 대신 코드로 작성해줄 것입니다. 따라서 위의 코드는 다음과 같이 변환될 것입니다:\n\n```js\n#[toJson]\nstruct ReallyBigModel {\n   id: String,\n   name: String,\n   isReal: Bool,\n   ...\n   stuff: AnotherBigModel\n}\n```\n\n그리고 매크로는 어떻게 생겼을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 나와 있는 코드(토큰으로 표시됨)를 가져와서 이를 대체할 새로운 코드를 반환하는 함수입니다.\n\n```js\n#[toJson]\n#[toJson] fn addToJsonTrait(input: TokenStream) -\u003e TokenStream { \n  let tree = parseIntoAST(input) \n  let nodes = ast.data.asStruct();\n  let name = tree.identity\n   // Get all the children that are properties\n   // Map them into format: $name to name \n  let properties = nodes\n    .filter((child)=\u003echild.isProperty)\n    .map((property) =\u003e \"\\\"${property.name}\\\" to ${property.name}\")\n    .joinToString(\",\\n\") \n  // Write the toJson trait body\n  let body = quote! { //this is also a kind of macro!\n     impl ToJson for #name { \n      fn toJson() -\u003e String { mapOf { properties }.toJson()}; \n    }\n   }\n   return body.intoTree().intoStream() \n}\n```\n\n참고: 이것은 가상 언어인 Bust입니다. 모든 언어에는 자체 매크로 구현이 있으며, 이것은 단순화된 표현일 뿐이므로 글이 지나치게 길어지지 않도록 한 것입니다.\n\n이제 우리 컴파일러가 #[toJson]로 표시된 클래스에 도착하면 addToJsonTrait 메서드를 호출하여 클래스 코드를 전달하고, 새 코드를 반환할 때까지 컴파일을 계속하기 전에 기다릴 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게 해서, 우리는 매크로 함수를 사용하여 시간을 많이 절약했고 항상 되고 싶어했던 생산적인 Bust 개발자가 될 수 있게 되었어요!\n\n하지만 너무 흥분하지는 마세요 - 이것은 단지 상상 속의 구현입니다. 매크로에 대해 알아야 할 것이 많이 있고, 매크로에 대해 깊이 파고들어 보길 권하고 싶어요. 러스트 자체에는 몇 가지 다른 유형의 매크로가 있습니다. 이것이 사람들이 Lisp를 너무 좋아하는 이유 중 하나로, 적절한(syntactic hygiene) 및 비적절한 비적절한 비적절한(expansion) 매크로, 다양한 확장 유형 및 더 많은 마법이 숨겨져 있어요.\n\n그래서 이제 그 문제를 해결했으니, 다시 API를 구축해 봅시다.\n\n## The POST office\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 서비스의 간단한 매력을 /sort POST 방식 뒤에 숨기겠습니다. 따라서 그 \"hello world\"를 삭제하고 /sort 요청을 처리하는 라우터로 교체할 거에요 - Router::new().route(\"/sort\", post(sort_items)) 그리고 요청을 처리할 sort_items 메서드:\n\n```js\nasync fn sort_items(Json(payload): Json\u003cSortRequestPayload\u003e)\n                                       -\u003e impl IntoResponse {\n (StatusCode::OK, Json(\"ok\")).into_response()\n}\n```\n\n이 메서드는 요청 구조의 Json 래퍼를 받아 우리 서버가 처리할 수 있는 IntoResponse 트레이트의 구현을 반환할 거에요.\n\n구체적으로, 우리는 이를 StatusCode, T 튜플 형식으로 반환할 거에요. 이것은 서버가 적절한 응답으로 변환하는 방법을 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 더 구현해야 할 것이 있습니다. 바로 요청 데이터 구조입니다. 이제 같은 파일에 만들어 둘 대신에 src 폴더에 models.rs라는 새 파일을 열어 기본 정의를 만들어 봅시다.\n\n우리는 받게 될 래퍼인 SortRequestPayload가 필요합니다. 이는 카테고리와 항목의 목록을 포함해야 합니다. 따라서 이를 위한 구조도 필요합니다 - Category와 Item이라는 구조를 추가해 봅시다.\n\n또한 카테고리와 항목을 가진 목록이 필요합니다. 이를 반환할 수 있는 카테고리에 속한 항목을 가지고 있는 구조와 이를 위한 래퍼도 만들어야 합니다. 또한 문제가 발생한 곳을 알 수 있도록 ErrorResponse를 추가합니다.\n\n```rust\n//in models.rs\npub(crate) struct SortRequestPayload {\n    pub(crate) categories: Vec\u003cCategory\u003e,\n    pub(crate) items: Vec\u003cItem\u003e,\n}\n\npub(crate) struct Category {\n    pub(crate) id: usize,\n    pub(crate) title: String,\n}\n\npub(crate) struct Item {\n    pub(crate) id: usize,\n    pub(crate) title: String,\n}\n\npub(crate) struct CategoryWithItems {\n    pub category_id: usize,\n    pub category_name: String,\n    pub items: Vec\u003cusize\u003e\n}\n\npub(crate) struct Categories {\n    pub categories: Vec\u003cCategoryWithItems\u003e\n}\n\npub(crate) struct ErrorResponse {\n    pub message: String,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 한 가지 문제가 발생했습니다 — 우리는 Serde 라이브러리를 사용하여 JSON과 (디)시리얼화가 쉽게 가능하도록 하려고 합니다. 이를 위해 앞서 구성한 매크로와 비슷한 매크로를 사용할 것입니다. 그래서 cargo.toml 파일을 열어서 serde와 serde_json을 종속성으로 추가해주세요:\n\n```js\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n```\n\n이제, serde의 #[derive(Deserialize)] 매크로를 사용하여 우리의 구조체를 표시할 수 있으므로 프레임워크가 수신된 JSON을 구조체로 역직렬화하는 방법을 알 수 있습니다.\n\n```js\n// models.rs 파일 안에\n#[derive(Deserialize)]\npub(crate) struct SortRequestPayload {\n    pub(crate) categories: Vec\u003cCategory\u003e,\n    pub(crate) items: Vec\u003cItem\u003e,\n}\n\n#[derive(Deserialize)]\npub(crate) struct Category {\n    pub(crate) id: usize,\n    pub(crate) title: String,\n}\n\n#[derive(Deserialize)]\npub(crate) struct Item {\n    pub(crate) id: usize,\n    pub(crate) title: String,\n}\n\n#[derive(Deserialize)]\n#[derive(Serialize)]\npub(crate) struct CategoryWithItems {\n    pub category_id: usize,\n    pub category_name: String,\n    pub items: Vec\u003cusize\u003e\n}\n\n#[derive(Deserialize)]\n#[derive(Serialize)]\npub(crate) struct Categories {\n    pub categories: Vec\u003cCategoryWithItems\u003e\n}\n\n#[derive(Serialize)]\npub(crate) struct ErrorResponse {\n    pub message: String,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 작업을 완료했으니, 이제 코드 작업에 다시 몰두해 볼까요?\n\n우리의 계획을 살펴보겠습니다:\n\n```js\n1. 아이템 가져오기\n2. 아이템을 카테고리에 할당하기\n3. 프롬프트를 청크로 나누기\n4. 재귀적 정렬:\n    4.1. 기존 카테고리와 청크를 입력으로 받아 프롬프트로 변환\n    4.2. OpenAI에 정렬 요청하기\n    4.3. 응답 역직렬화하기\n    4.4. 기존 카테고리에 추가하기\n    4.5. 청크가 남아있는 동안, 다시 4.1로 돌아감\n5. 결과 반환하기\n```\n\n그리고 메소드로 구조화해 보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\n//in lib.rs\n...\nfn create_chunks_for_prompting(items: Vec\u003cItem\u003e) -\u003e Vec\u003cVec\u003cItem\u003e\u003e\n```\n\n```rust\nfn sort_recursively(sorted_categories: Vec\u003cCategoryWithItems\u003e,\n                    remaining: Vec\u003cVec\u003cItem\u003e\u003e) -\u003e Result\u003cCategories, Error\u003e\nfn build_prompt(items: Vec\u003cItem\u003e, categories: Vec\u003cCategoryWithItems\u003e) -\u003e String\nfn prompt_open_ai(prompt: String) -\u003e Result\u003cString, String\u003e\n```\n\n우리는 프롬프트가 필요할 것이라고 생각해요. 아래와 같이 시도해봅시다. - 우리는 GPT3에게 항목 목록을 받을 것이라고 알려주고 형식을 제시한 후 목록을 포함해야 합니다.\n\n그런 다음, 반환할 유효한 JSON 형식을 설명하고 기존 카테고리를 전달하세요. 마지막으로, 유효한 JSON 형식으로 반환하도록 요청하세요. JSON 형식을 준수하고 이를 해석하지 않기를 희망하지만 후속 게시물에서 그 부분을 미세 조정할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 프롬프트의 끝 부분에 유효한 JSON 형식을 명시하고 \"유효한 JSON 형식\"을 언급하는 것이 꽤 적절해 보입니다.\n\n```js\n항목 목록을 [제목, id] 형식으로 받게 됩니다.\n제목과 URL을 기반으로 범주로 분류하며,\n기존 범주를 사용하거나 새 범주를 만들어 사용합니다.\n탭은:\n[$tabName, $tabId].\n반환할 유효한 JSON 형식은 다음과 같습니다:\n{ \"categories\": [ { \n    \"category_id\":\"여기에 id 입력\",\n    \"category_name\": \"여기에 이름 입력\", \n    \"items\":[여기에 tab_id 입력] } \n]}.\n기존 범주는: \n$categories\n보다 자세한 새 범주 목록(기존 및 새 범주 포함)과 항목을 유효한 JSON 형식으로 제시합니다.\n```\n\n그게 좋아요!\n\n이를 우리 코드 내에서 사용할 상수로 분리해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nconst PROMPT_TEXT_START: \u0026str = \"아이템 목록을 제목과 id의 형태로 받게 됩니다. 제목과 URL을 기반으로 기존 카테고리를 사용하거나 새로 만들어 아이템을 분류해주세요.\";\nconst PROMPT_TEXT_MIDDLE: \u0026str = \"\\n반환할 유효한 JSON 형식은:\n{ \\\"categories\\\": [ { \\\"category_id\\\":\\\"여기에 id 입력\\\", \\\"category_name\\\": \\\"이름 입력\\\", \\\"items\\\":[tab_id 여기에] } ]}.\n기존 카테고리는:\";\nconst PROMPT_TEXT_ENDING: \u0026str = \"탭을 사용하여 더 상세한 카테고리 목록(기존 및 새로 만든 항목)을 유효한 JSON 형식으로 제공합니다:\";\n```\n\n마지막으로 `sort_items` 메서드로 들어가서 모든 내용을 작성할 수 있습니다. 먼저 데이터를 소유권을 얻고 청크(조각)로 분할합니다:\n\n```rust\nlet items = payload.items;\nlet categories = payload.categories.iter().map(|it| {\n    CategoryWithItems {\n        category_id: it.id,\n        category_name: it.title.to_owned(),\n        items: Vec::new(),\n    }\n}).collect();\n```\n\n```rust\nlet prompt_slices = create_chunks_for_prompting(items_with_indexes);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 청크를 사용하는 걸까요?\n\n모든 항목을 한 번에 추가하면 우리의 프롬프트 크기가 4096 토큰 이상이 될 수 있습니다. 사용할 모델에서 프롬프트와 완성을 위한 최대 길이로 지원하는 값이기 때문이죠.\n\n따라서 우리는 적절한 크기로 분할하고 완성을 위한 여분 공간도 확보해야 합니다. 여분 공간으로 50%를 남기고 2048 크기의 프롬프트를 유지할 것입니다.\n\n이를 달성하기 위해 create_chunks_for_prompting 함수는 두 가지 작업을 수행해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 우리 기본 프롬프트의 토큰 수를 세어 보세요.\n- API로 전송하는 데이터의 토큰 수를 세어 보세요.\n- 총 토큰 수의 크기를 2048로 나누고 하드코딩된 프롬프트 크기를 뺀 값을 기준으로 필요한 청크 수를 계산하세요.\n\nOpenAI 문서에 따르면, 토큰 하나는 대략 4개의 문자 크기로 보실 수 있습니다.\n\n이제, 토큰을 세는 다양한 방법이 있지만, 올바르게 하려면 길이를 4로 나누는 것 이상의 작업을 해야 할 것입니다 - Rust 토크나이저 크레이트와 그들의 GPT2 토크나이저를 사용하는 게 최선일 것입니다.\n\n하지만, 그런 접근은 다른 문제로 이어지기 때문에, 이번에는 건너뛰고 간단한 방법을 사용하겠습니다 - split_whitespace 메서드를 사용해 토큰 길이의 근사치를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nfn create_chunks_for_prompting(items: Vec\u003cItem\u003e) -\u003e Vec\u003cVec\u003cItem\u003e\u003e {\n   \n  // 데이터 내의 토큰\n  let json_size = serde_json::to_string(\u0026items).unwrap()\n      .split_whitespace()\n      .collect_vec()\n      .len();\n  \n  // 하드코딩된 프롬프트의 크기 구하기\n  let hardcoded_prompt = format!(\"{a}{b}{c}\",\n                                 a =String::from(PROMPT_TEXT),\n                                 b = String::from(PROMPT_TEXT_APPEND),\n                                 c= String::from(PROMPT_TEXT_ENDING));\n  \n  let hardcoded_prompt_size = hardcoded_prompt\n      .split_whitespace()\n      .len();\n  \n  // 아이템을 나눌 청크의 수 계산\n  let chunks_to_make = json_size / (2048 - hardcoded_prompt_size);\n  \n  // 벡터를 N개의 청크로 나누기\n  let chunk_size = items.chunks(items.len() /\n                                    (if chunks_to_make \u003e 0 {\n                                    chunks_to_make\n                                    } else { 1 }));\n                                    \n  // 청크 목록 반환\n  return chunk_size.map(|s| s.into()).collect();\n}\n```\n\n이제 build_prompt 함수에 대해 이야기해 보겠습니다.\n\n프롬프트를 구성하기 위해 정렬해야 할 항목 목록과 기존의 카테고리가 필요합니다.\n\n항목 목록을 [제목, ID] 형식의 문자열로 변환한 다음, 카테고리를 JSON으로 변환하여 이를 모두 결합하는 형식으로 하나의 프롬프트를 생성할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nfn build_prompt(items: Vec\u003cItem\u003e,\n                categories: Vec\u003cCategoryWithItems\u003e) -\u003e String {\n  // items을 [title,id] 형태로 매핑한 후 모두 문자열로 결합합니다\n    let items_joined = items.iter().map(|item| format!(\n                                        \"[{title},{id}]\",\n                                        title = item.title,\n                                        id = item.id))\n                                .collect()\n                                .join(\",\");\n    let categories_json = serde_json::to_string(\u0026categories).unwrap();\n    \n    format!(\"{prompt}\\n{tabs}{middle}{categories}\\n{ending}\",\n            prompt = String::from(PROMPT_TEXT_START),\n            tabs = items_joined,\n            middle = String::from(PROMPT_TEXT_MIDDLE),\n            categories = categories_json,\n            ending = String::from(PROMPT_TEXT_ENDING))\n}\n```\n\n다음으로, 이 프롬프트를 실제로 OpenAI에 전송하려면 HTTP 클라이언트가 필요합니다.\n\n이를 위해 reqwest 크레이트를 사용할 것입니다. 이 크레이트는 간단한 비동기 함수를 사용하여 OpenAI API와 통신할 수 있도록 해주는 고수준 HTTP 클라이언트를 제공하며, 쉬운 직렬화/역직렬화를 위한 JSON 기능도 제공합니다.\n\n그러니 우리의 Cargo.toml 파일에 이를 추가해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n[의존성]\n...\nreqwest = { version = \"0.11\", features = [\"json\"] }\n\n\n여기서 우리는 오래된 좋은 빌더 패턴을 통해 HTTP 클라이언트를 구축할 수 있습니다.\n\n```rust\nlet client = Client::builder()\n    .http2_keep_alive_timeout(Duration::from_secs(120))\n    .timeout(Duration::from_secs(120))\n    .build()\n    .unwrap();\n```\n\n그러나 만약 우리가 prompt_open_ai 함수 내에서 클라이언트를 구축한다면, 우리는 각 요청마다 Client 인스턴스를 생성하게 될 것이므로, 대신 종속성을 만들어 sort_items 함수에 클라이언트 코드를 추가한 다음, 이를 sort_recursively 함수와 prompt_open_ai 함수에 전달하도록 하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTTP 클라이언트를 한 번만 사용하여 /sort 호출당 한 번의 인스턴스만 사용할 수 있습니다. 그리고 prompt_open_ai 함수는 실제 API를 호출하고 결과를 받는 데 중점을 둘 수 있습니다.\n\n그래서 간단한 POST 호출을 구축하고 그 결과를 받는 방법을 살펴보겠습니다.\n\n코드를 깔끔하게 유지하기 위해 우리의 구조 안에 별도의 모듈을 만들 것입니다. 모듈은 코드를 저장하는 컨테이너이며 (패키지와 유사한) 코드의 서로 다른 영역 간에 분리를 만들 수 있도록 해줍니다.\n\nopenai라는 새 폴더를 만들고 그 안에 두 개의 새 파일을 만들어 주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 우리 코드를 위한 mod.rs 파일\n- 우리 모델을 위한 models.rs 파일을 열어보세요.\n\nmodels.rs를 열어서 OpenAI Completion API와 통신하기 위해 필요한 구조체를 추가해보세요:\n\n```js\nuse serde::{Deserialize, Serialize};\n```\n\n```js\n#[derive(Serialize)]\npub(crate) struct AskGPT {\n    pub prompt: String,\n    pub model: String,\n    pub max_tokens: usize,\n    pub stream: bool,\n    pub temperature: usize,\n    pub top_p: usize,\n    pub n: usize,\n}\n#[derive(Deserialize)]\npub(crate) struct Completion {\n    pub model: String,\n    pub choices: Vec\u003cChoices\u003e,\n}\n#[derive(Deserialize)]\npub(crate) struct Choices {\n    pub text: String,\n    pub index: usize,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmod.rs 파일에서 prompt_open_ai 메서드를 구축할 수 있습니다. 이 메서드는 새로 생성된 AskGPT 모델을 OpenAI의 /completions 엔드포인트에 보낼 POST 요청을 함께 합니다.\n\n이 곳에는 몇 가지 중요한 필드가 있습니다. 자명한 prompt 필드, 완성을 담당할 모델을 선택할 수 있는 model 필드 (작성 시점에 가장 성능이 좋은 것은 text-davinci-003 이며), 우리가 4096으로 설정할 max_tokens 필드 (최대치, 당연한 얘기), 응답 개수를 제어하는 n 필드 및 어떤 확률을 고려할지 알려주는 temperature 필드가 있습니다. 이 값이 높을수록 완성이 더 무작위로 보일 수 있지만, 여기서는 0을 사용하여 출력이 덜 무작위로 나오도록 합니다.\n\n참고: 이 부분에서는 OpenAI API 키가 필요합니다. 여기서 찾을 수 있습니다.\n\n```rust\nasync fn prompt_open_ai(prompt_txt: String,\n                        client: \u0026Client) -\u003e Result\u003cString, String\u003e {\n    let token = String::from(\"여기에_귀하의_API_키_입력\")\n    let auth_header = format!(\"Bearer {}\", token);\n    let req = client.post(\"https://api.openai.com/v1/completions\")\n        .header(\"Authorization\", auth_header)\n        .json(\u0026AskGPT {\n            prompt: prompt_txt,\n            model: String::from(\"text-davinci-003\"),\n            max_tokens: 4096,\n            n: 1,\n            stream: false,\n            temperature: 0,\n        }).send().await;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과가 나왔네요!\n\n하지만 그 결과로 뭘 할까요?\n\n우리는 그냥 await 뒤에 ?를 추가해도 되지만, 재미가 없죠. 그래서 제가 가장 좋아하는 러스트의 기능 중 하나인 유명한 match를 사용할 거에요.\n\nmatch 문은 러스트 개발 경험의 핵심이며, 강력한 패턴 매칭 기능을 제공하여 코드가 따라가는 모든 경로를 확실하게 다룰 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIan씨, 이건 무슨 특별한 점이 있는 걸까요? 이게 그냥 더 강력한 if/else일 뿐인 거 아닌가요?\n\n아니에요, 이건 그 이상입니다.\n\nif/else나 switch 문들의 집합과 달리, match는 코드가 갈 수 있는 모든 가능성을 확인하도록 강요합니다. 이는 당신이 코드가 행복한 길과 슬픈 길 둘 다 다루도록 확실하게 해줍니다.\n\n이게 왜 이렇게 초능력이라고 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버그가 처리되지 않은 케이스로 인한 가능성을 줄이고 모든 가능한 케이스를 다루도록 강제하기 때문에 코드를 즉시 개선할 수 있습니다. 이는 코드의 가독성을 향상시키고 버그를 해결하며 유지보수성을 높이는 희귀한 도구 중 하나입니다.\n\n그러니 이를 시도해 봅시다. 구문은 간단합니다. 왼쪽에는 일치시키려는 패턴이 있고, 오른쪽에는 실행할 코드 블록이 있습니다.\n\n먼저, 우리는 실제 요청이 발생했는지 여부를 확인해볼 것입니다. 이를 통해 우리가 받은 결과(Result)를 확인합니다.\n\n```js\nmatch req {\n    Ok(response) =\u003e {\n        // 요청이 실제로 발생했습니다. 안전하게 응답에 접근할 수 있습니다.\n    }\n    Err(error) =\u003e {\n        // 오류 처리 작업\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리 Ok 브랜치에서는 안심하고 응답 객체에 접근할 수 있습니다. 에러 케이스에 대비했기 때문에 런타임 중에 충돌을 일으키지 않을 것입니다.\n\n이제 우리는 요청이 실제로 성공적이었는지를 확인할 단계로 넘어갈 수 있습니다. 단순히 상태 코드가 200 OK인지 확인하여 성공한 요청인지 확인할 수 있습니다.\n\n```js\nmatch response.status() {\n    StatusCode::OK =\u003e {\n      // 흥미진진한 성공 \n    }\n    other =\u003e {\n      // TODO 에러 처리\n    }\n}\n```\n\n마지막으로, 본격적인 단계로 진행합니다 — 요청이 성공했다면, 응답을 담은 Completion 구조체로 본문을 역직렬화해야 합니다. 그러나 이 역시 실패할 수 있으므로 이 부분에서도 빠르게 매칭을 수행하고 완료 객체에서 응답을 추출해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nmatch response.json::\u003cCompletion\u003e().await {\n    Ok(parsed) =\u003e {\n        // 우리의 요청 매개변수 n==1 때문에 choices에 항상 적어도 1개의 항목이 있다는 것을 알고 있습니다.\n        // 그러므로 우리는 단순하게 언랩을 해서 사용할 겁니다.\n        let choices = parsed.choices.first().unwrap();\n        let json: \u0026str = choices.text.borrow();\n        Ok(String::from(json))\n    }\n    Err(err) =\u003e {\n            return Err(Parsing);\n        }\n}\n```\n\n이제 에러를 처리하는 방법을 알아봅시다 — 여러분, 저는 이 세 유형의 에러로 모든 가능한 에러를 압축할 것입니다. 어떤 문제가 생길까요.. — 연결 에러(connection error), 서버 응답 에러(server response error) 및 파싱 에러(parsing error)를 표시하는 열거형(enum)을 추가합시다. models.rs로 올라가서 다음과 같이 추가해보세요:\n\n```rust\n#[derive(Debug)]\npub(crate) enum OpenAiError {\n    Connection,\n    Parsing,\n    Server,\n}\n\nmatch req {\n    Ok(response) =\u003e {\n        match response.status() {\n            StatusCode::OK =\u003e {\n                match response.json::\u003cCompletion\u003e().await {\n                    Ok(parsed) =\u003e {\n                        // 우리의 요청 때문에 최소한 1개의 항목이 항상 있습니다.\n                        let choices = parsed.choices.first().unwrap();\n                        let json: \u0026str = choices.text.borrow();\n                        Ok(String::from(json))\n                    }\n                    Err(err) =\u003e Err(Parsing);\n                }\n            }\n            other =\u003e Err(Server)          \n        }\n    }\n    Err(err) =\u003e Err(Connection)\n}\n```\n\n축하합니다! 우리는 안전하게 요청을 보내고 이 과정에서 모든 안좋은 상황과 기쁜 상황을 모두 다루었습니다. \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 요청이 증가하면서, 이제 드디어 재귀적으로 정렬하는 함수인 sort_recursively 함수에 대해 작업을 시작할 수 있게 되었어요. 여기서 왜 재귀일까요? 왜냐하면 우리는 GPT3가 우리의 축소 함수로 작용하면서 리스트를 자기 자신에게 축소하고 있거든.\n\n우리가 여기서 루프를 사용하고 이 방법을 n번 호출할 수는 있지만, 이렇게 하면 루프 외부의 변수(우리의 카테고리를 포함하는 변수)도 변경해야 하기 때문에 조금 어수선해집니다. 그러니까, 더럽게 하기보다는 재귀를 통해 깔끔하고 기능적인 방식으로 해결할 거에요.\n\n그러니까 이제 main.rs 파일을 열어서 sort_recursively 함수에 들어가 보도록 해요.\n\n먼저 우리의 프롬프트를 구축한 다음, prompt_open_ai로 보내고 응답을 역직렬화하려고 해요. 성공하면 기존의 카테고리들과 연결하고 남은 청크를 가지고 다시 sort_recursively에 전달합니다. 이를 계속해서 반복하여 남은 청크가 없을 때까지 반복합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nasync fn sort_recursively(\n    sorted_categories: Vec\u003cCategoryWithItems\u003e,\n    remaining: Vec\u003cVec\u003cItem\u003e\u003e,\n    client: Client) -\u003e Result\u003cCategories, Error\u003e {\n    let prompt = build_prompt(remaining.first().unwrap().to_vec(), sorted_categories);\n    let ai_response = prompt_open_ai(prompt, \u0026client).await.unwrap();\n    let json = ai_response.as_str();\n    \n    let generated = serde_json::from_str::\u003cCategories\u003e(json);\n    \n    let result = generated.map_err(|err| err.to_string()).and_then(|res| {\n        res.map_err(|err| err.to_string()).and_then(|wrapper| {\n            let mut new_categories = wrapper.categories.to_owned();\n            let mut next_slice = remaining.to_owned();\n            next_slice.remove(0);\n            next_categories.append(\u0026mut new_categories);\n            \n            if next_slice.len() != 0 {\n                sort_recursively(next_categories, next_slice, client).await\n            } else {\n                Ok(Categories { categories: next_categories })\n            }\n        })\n    });\n\n    result\n}\n```\n\nWith all these matches, our code is starting to look quite messy. One way to avoid nested match hell is to use map, map_err, and and_then extensions — they operate on either the left (map) or the right (map_err) side of the Result, enabling us to avoid nesting hell by simply chaining them into a more readable, concise version of it.\n\nThe data will pass only through the corresponding operands so we can safely map our data and errors to the proper format.\n\nWe’ll use it to reduce the first set of nested matches and we’ll leave the last one as a match. Why? Because async closures still aren’t stable in Rust it seems. We’ll map all the errors into an `Err(String)` format so we can return it properly.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nasync fn sort_recursively(sorted_categories: Vec\u003cCategoryWithItems\u003e,\n                          remaining: Vec\u003cVec\u003cItem\u003e\u003e,\n                          client: Client) -\u003e Result\u003cCategories, String\u003e {\n    let mut next_categories = Vec::from(sorted_categories.deref());\n    let prompt = build_prompt(remaining.first().unwrap().to_vec(),\n                              sorted_categories);\n    let ai_response_result = prompt_open_ai(prompt, \u0026client).await;\n    let res = ai_response_result\n        .map_err(|e|\n                format!(\"OpenAI와 통신 중 오류 발생 - {:?}\", e))\n        .and_then(|ai_response|\n            serde_json::from_str::\u003cCategories\u003e(ai_response.as_str())\n                .map_err(|_| \"응답 파싱 오류\".to_string()));\n    match res {\n        Ok(wrapper) =\u003e {\n            let mut new_categories = wrapper.categories.to_owned();\n            // 처리된 청크 제거\n            let mut next_slice = remaining.to_owned();\n            next_slice.remove(0);\n            // 카테고리 합치기\n            next_categories.append(\u0026mut new_categories);\n            // 아직 끝나지 않았다면 재귀 호출\n            if next_slice.len() != 0 {\n                sort_recursively(next_categories, \n                                next_slice,\n                                client).await\n                    .map_err(|e| \n                        format!(\"정렬 실패, 이유: {}\", e))\n            } else {\n                Ok(Categories { categories: next_categories })\n            }\n        }\n        Err(msg) =\u003e Err(msg)\n    }\n}\n```\n\n여기 있습니다 — 우리는 API를 안전하고 오류없이 호출했는데요...\n\n컴파일되지 않네요.\n\n음, 한 가지 생각하지 못한 것은 비동기 재귀입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이게 왜 문제가 됐는지 궁금하시죠?\n\nRust (그리고 다른 많은 언어들)에서 async/await가 어떻게 구현되는지 때문에, 내부적으로는 해당 메서드 안에 있는 모든 futures를 포함하는 상태 머신 타입을 생성합니다.\n\n그런데 이제 여기에 재귀를 추가하면, 생성된 타입이 자기 자신을 참조하기 시작합니다 — 그래서 내부적으로 잠재적으로 무한히 재귀적인 타입으로 폭발하고 컴파일러는 타입의 크기를 결정할 수 없게 됩니다.\n\n은 폭발하는 것을 막기 위해, 재귀를 수정하여 Box에 포장된 Future를 반환해야 하는데, 그러면 힙에 대한 포인터만 얻게 되어 전체 객체가 아닌 포인터를 제공하여 내부적으로 무한 자기 참조를 방지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제에 대해 좀 더 읽어보고 더 깊이 파고들어보시는 것을 추천드립니다. 많은 언어에서 나타나는 언어 디자인 질문과 개념들을 다루고 있습니다. 하지만 지금은 async_recursion 크레이트를 사용할 것이니, Cargo.toml로 이동해서 다음과 같이 추가해주세요:\n\n```js\n[dependencies]\n..\nasync-recursion = \"1.0.2\"\n```\n\n그리고 함수에 #[async_recursion] 매크로를 붙여서 Box 처리할 수 있도록 해주세요.\n\n이제 이 문제를 해결했으므로, 원래의 sort_items 메서드로 돌아가서 마침내 API 요청에 응답할 차례입니다. 마지막으로 그곳에 Client 인스턴스를 추가한 채로, 그 아래로 내려가서 sort_recursively 메서드를 호출하고, map_err를 사용하여 오류를 ErrorResponse 구조체로 매핑하고, JSON으로 래핑하여 응답으로 반환하고, map을 사용하여 Ok 결과를 적절한 응답으로 바꿉니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsort_recursively(categories, prompt_slices, client).await\n    .map_err(|e| \n        (StatusCode::INTERNAL_SERVER_ERROR, \n        Json(ErrorResponse { message: e })).into_response())\n    .map(|wrapper| {\n        let new_categories = wrapper.categories.iter().map(|item| {\n            CategoryWithItems {\n                category_id: item.category_id.to_owned(),\n                category_name: item.category_name.to_owned(),\n                items: item.items.to_owned(),\n            }\n        }).collect::\u003cVec\u003cCategoryWithItems\u003e\u003e();\n        (StatusCode::OK, Json(Categories {\n            categories: new_categories\n        })).into_response()\n    })\n```\n\n그리고 이렇게 하면, 이제 우리의 서비스가 완료되었습니다!\n\n우리는 응답을 가져와서 형식을 지정하고 사용자에게 돌려줍니다. 우리의 계획은 안전하고 제대로 되어 있습니다. 배포해야 할 일만 남았는데, 인스턴스 프로비저닝, 보안 그룹 설정 또는 도커파일 작성에 대해 걱정할 필요가 없습니다. 셔틀을 통해 서비스를 만들었기 때문에 단순히 터미널을 사용하여 쉽게 배포할 수 있습니다.\n\n쉘에서 프로젝트 폴더를 열고 다음을 입력하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n카고 셔틀을 배포했습니다.\n\n이제 일어서서 몇 번 숨 쉬고, 커피 한 모금을 한 후, 새로운 서버가 이미 https://projectname.shuttleapp.rs/ 에서 구동되고 있다는 것을 알게 될 거에요.\n\n자, 그런데... 이 작업을 왜 했더라?\n\n아, 맞다, JS 확장 프로그램을 작성 중이었죠. 서버가 올라와서 거의 다 완성됐어요. 확장 프로그램으로 이동해서 localhost 엔드포인트를 방금 셔틀로부터 받은 실제 엔드포인트로 교체하기만 하면 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 확장 프로그램을 테스트하기 위해 작은 창에 로드하세요. 정렬 버튼을 누르고 잠시 기다리면 — 바로 그렇습니다! 탭이 마법처럼 올바른 그룹으로 정리될 것입니다! 마침내!\n\n이제 본격적으로 하나의 창에서 해보죠 — 탭이 이미 600개가 가까워진 창이죠. 그러니까 정렬 버튼을 누르고 — 기다려보세요...\n\n...기다려보세요...\n\n.....조금 더 기다려보세요...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠시만 기다려주세요...\n\n60초보다 훨씬 오래 걸리고 있는 것 같네요...\n\n아, 기다려봐요...\n\n에러가 발생한 것 같네요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앗— 토큰 한도에 도달했네요!\n\n왜 그럴까요? 우린 전체 덩어리를 맞게 만들기 위해 청킹 작업을 했는데 말이죠?\n\n음, 많이 보니까 프롬프트 크기 계산이 좀 더 정확히 필요해 보여요.\n\n그리고 재귀가 문제를 일으키고 있는 것 같아요— 각 프롬프트에 이전 카테고리를 모두 추가하는 방식으로 크기가 폭발적으로 증가하고 전체 체인을 완료하는 데 정말 매우 오랜 시간이 걸리고요— 60초보다 훨씬 더 말이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 마지막으로, 카테고리가 조금... 별로네요.\n\n다음 반복에 할 일이 더 많아져서 좋네요. 이 재귀를 제거하는 방법, GPT 토크나이저 사용법, 딕셔너리 파일을 이진 파일에 넣는 방법, 그리고 시간을 낭비하지 않고 셔틀의 정적 폴더 서비스를 사용하는 방법 등을 알아볼 거에요.\n\n또한 모델을 미세 조정해서 토큰을 줄이면서 더 나은 결과를 얻을 예정이에요. 그리고 우리가 게으르다는 것을 감안해, 훈련 데이터 생성은 GPT 자체를 사용할 거예요.\n\n지금까지 읽어 주셔서 감사합니다. 다음 시리즈에서 계속해서 발전하고 잠재적 문제를 해결할 예정이니 걱정 마시고 '인간 대 기계'의 다음 에피소드에서 만나요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`\u003cimg src=\"/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_7.png\" /\u003e`","ogImage":{"url":"/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_0.png"},"coverImage":"/assets/img/2024-05-20-Sorting400Tabsin60SecondsWithJavaScriptRustandGPT-3_0.png","tag":["Tech"],"readingTime":39},{"title":"React Conf 2024에서 새롭게 소개된 내용들","description":"","date":"2024-05-20 21:45","slug":"2024-05-20-WhatsNewatReactConf2024","content":"\n\n## 빠르게 따라잡는 빠른 안내서\n\n![React Conf 2024](/assets/img/2024-05-20-WhatsNewatReactConf2024_0.png)\n\n내 무료 뉴스레터에서 원본으로 작성되었습니다.\n\nReact 개발자들은 모두 2024년 5월 15일에 공식적으로 시작된 React Conf 2024에 집중하고 있습니다. 여기 8시간의 비디오 다시보기: [React Conf 2024 Video](링크).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 제가 강조해야 한다고 생각하는 몇 가지 주요 사항을 빠르게 요약한 글입니다. 이를 통해 빠르게 최신 정보를 파악할 수 있습니다.\n\n# React Router와 Remix의 통합\n\nRemix가 React Router와 통합을 발표했습니다. 다가오는 React Router v7에서는 모든 Remix 기능이 포함될 것입니다. Remix 사용자는 import 문을 변경하면 됩니다:\n\n```js\n- import { Link } from `@remix-run/react`\n+ import { Link } from `react-router`\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 라우터 사용자들을 위해, 이제 SSR, prefetching 또는 Vite 플러그인을 포함한 Remix 기능을 React 프로젝트에서 직접 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-WhatsNewatReactConf2024_1.png)\n\nRemix는 항상 React Router 위에 있는 레이어에 불과했으며 시간이 지남에 따라 이 레이어가 줄어들고 있습니다. 이제 그 크기가 매우 작아져서 예정된 Remix v3 릴리스가 이제 React Router v7로 출시될 예정입니다.\n\n사실 이렇게 말해도 될 것 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-WhatsNewatReactConf2024_2.png\" /\u003e\n\n# React 19에서 새로운 기능 소개\n\n여기에 빠르게 코드 중심의 요약이 있고, 좀 더 간략한 내용은 여기에 있습니다:\n\n## Actions 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개선된 비동기 작업 및 상태 업데이트 처리를 위한 useTransition 및 useOptimistic과 같은 훅을 사용하여 suspense, 오류 처리 및 낙관적 업데이트의 관리를 간편화했습니다.\n\n## 서버 구성 요소:\n\n- 서버 구성 요소: React 19에서 공식적으로 서버 구성 요소 통합을 지원하며, 빌드 시간 이전에 구성 요소를 사전 렌더링하도록 허용하며, 빌드 시간 실행 및 실시간 요청 처리 두 가지 모드가 있습니다.\n- 서버 액션: 클라이언트 측 구성 요소가 “use server” 지시어를 사용하여 서버에서 비동기 함수를 호출하고 실행할 수 있으며, 프레임워크가 서버 함수에 대한 참조를 생성합니다.\n\n## 기능 최적화:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Ref 로 속성 전달: ref를 함수 컴포넌트 인수로 직접 전달할 수 있어서 forwardRef가 필요하지 않게 되었습니다.\n- 향상된 수분 공급 오류 보고: 클라이언트 측 렌더링이 서버 측 렌더링된 콘텐츠와 일치하지 않을 때 개선된 오류 보고로 더 명확한 오류 메시지를 제공합니다.\n- 공급자 최적화: 기존의 'Context.Provider'가 필요하지 않도록 'Context'를 직접 공급자로 사용합니다.\n- Ref 정리 함수: 컴포넌트가 언마운트될 때 정리를 처리하기 위해 ref 콜백 함수에서 정리 함수를 반환하는 지원이 추가되었습니다.\n- useDeferredValue의 초기 값: 컴포넌트의 초기 렌더링에 값을 지정할 수 있습니다.\n- 문서 메타데이터 지원: React를 사용하여 컴포넌트 내에서 'title', 'link', 'meta' 태그를 직접 정의하고 자동으로 이를 문서 'head'로 승격시켜 줍니다.\n- 스타일시트 지원: 컴포넌트 트리 내에서 스타일시트를 관리하는 기능이 내장되어 있으며, 로딩 순서를 자동으로 처리합니다.\n- 비동기 스크립트 지원: 컴포넌트 트리 어디에서든 비동기 스크립트를 렌더링하여 스크립트 관리를 간소화합니다.\n- 리소스 프리로딩 지원: prefetchDNS, preconnect, preload, preinit과 같은 사전로드 API를 도입하여 리소스 로딩을 최적화합니다.\n- 타사 스크립트 및 브라우저 익스텐션 호환성: 타사 스크립트 및 브라우저 익스텐션과의 호환성이 개선되었습니다.\n- 더 나은 오류 보고: 오류 처리를 향상시키기 위한 다양한 옵션이 추가되었습니다.\n- 사용자 정의 요소 지원 (웹 컴포넌트): 사용자 정의 요소에 대한 지원이 개선되었습니다.\n\n# React 컴파일러\n\nReact 컴파일러인 Forget으로도 알려진 React 컴파일러가 이제 오픈 소스입니다. 여기에서 찾아볼 수 있습니다. Rust로 작성되었으며 React 19 베타 또는 온라인 Playground에서 사용해 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-WhatsNewatReactConf2024_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발자들에 미치는 영향은 useMemo, useCallback, React.memo API를 사용하여 수동으로 최적화를 할 필요가 없어졌다는 점입니다. 이는 현재 이에 한정되어 있으며 useEffect와 같은 의존성 규칙에는 영향을 미치지 않습니다. 현재도 여전히 React 훅 규칙 (예: 훅을 최상위 레벨에서만 호출하는 것과 같은)을 따라야 합니다.\n\n컴파일러에 의해 최적화된 컴포넌트는 React Devtools (v5.0+)에서 \"Memo ✨\" 배지가 표시됩니다:\n\n![Memo Badge](/assets/img/2024-05-20-WhatsNewatReactConf2024_4.png)\n\n# 두 대의 컴퓨터를 위한 리액트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDan Abramov가 React 클라이언트 컴포넌트와 서버 컴포넌트의 각각의 장점을 소개했고, 어떻게 선택해야 하는지에 대해 설명했습니다. 여기에 간략하게 정리해보겠습니다:\n\n## 서버 사이드 컴포넌트의 장점\n\n- 데이터 접근: 서버 사이드 컴포넌트는 서버의 데이터와 파일에 접근할 수 있어 데이터 집약적인 애플리케이션에 유용합니다.\n- 데이터 전처리: 서버 사이드 컴포넌트는 데이터를 읽고 전처리한 후 클라이언트로 보내는데 유용합니다.\n- 빌드 시 렌더링: 서버 사이드 컴포넌트는 빌드 시 실행하여 정적 UI를 생성할 수 있어 SEO 및 초기 로드 성능에 도움이 됩니다.\n- 클라이언트 단순화: 서버에서 복잡한 데이터 로직을 처리함으로써 (UI = f(데이터)), 클라이언트 부담을 줄일 수 있으며, 클라이언트는 필요한 UI 데이터만 받아 보여줍니다.\n\n## 클라이언트 사이드 컴포넌트의 장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 즉시 피드백: 사용자가 UI와 상호 작용할 때(예: 버튼 클릭), 서버 응답을 기다리지 않고 즉시 피드백을 받을 수 있습니다.\n- 서버 폴링 없음: 사용자 작업 중 일부(슬라이더 드래깅 또는 버튼 클릭 등)에 대해 서버로부터 추가 요청이나 데이터 다운로드가 필요하지 않습니다.\n- 더 나은 사용자 경험: 직접적인 상호 작용 반응은 사용자 경험을 향상시켜 응용 프로그램이 더 반응적이고 부드러워지도록 합니다.\n- 클라이언트 측 상태 사용: 컴포넌트는 클라이언트 측 상태(UI = f(상태))를 사용하여 매우 상호 작용적이고 반응성이 좋은 사용자 인터페이스를 구축할 수 있습니다.\n\n# React Server Components in Expo Router\n\nExpo Router는 React Native 및 웹 애플리케이션용 파일 기반 라우터입니다. 이를 통해 응용 프로그램의 화면 간 탐색을 관리하고 Android, iOS 및 웹과 같은 여러 플랫폼에서 사용자가 응용 프로그램 UI의 다른 부분을 매끄럽게 이동할 수 있도록 합니다.\n\n서버 구성 요소의 장점은 클라이언트에 완전히 상호 작용적인 동적 UI를 전송할 수 있다는 것입니다. 이는 응용 프로그램이 다른 사용자 작업에 기반한 복잡한 UI 요소를 제공할 수 있음을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React 규칙 어기기\n\nReact에는 몇 가지 규칙이 있어요:\n\n![React Rules](/assets/img/2024-05-20-WhatsNewatReactConf2024_5.png)\n\nCharlotte은 이러한 규칙에 대한 이유를 논의하여 React의 내부 메커니즘을 더 깊이 이해하려고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최근에 React 아래의 내부를 더 깊이 이해하기 위해 기사를 썼어요. 간소화된 Fiber 아키텍처와 동시 모드를 사용하여 렌더링 중에 메인 스레드를 차단하지 않도록 했죠. 여기서 이 지침을 어기면 안 되는 이유도 이해할 수 있어요.\n\n# React 서버 구성 요소로 RedwoodJS\n\nRedwoodJS는 포함된 배터리를 갖춘 또 다른 풀스택 JavaScript 애플리케이션 프레임워크에요. 주로 스타트업을 대상으로 하고 있습니다.\n\n높은 수준에서, 이는 사용자 정의 GraphQL API와 통신하는 React 프런트엔드입니다. API는 데이터베이스와 상호 작용하기 위해 Prisma를 사용합니다. 기본 설정으로는 테스트에 Jest, 로깅에 Pino, UI 구성 요소 목록에 Storybook을 사용할 수 있어요. 인증(Auth0 같은) 또는 CSS 프레임워크(Tailwind CSS 같은) 설정은 명령줄 호출만으로도 간단하게 할 수 있어요. 게다가 Redwood의 아키텍처를 통해 서버리스 공급자(Netlify, Vercel 등) 또는 전통적인 서버 및 컨테이너 공급자(AWS, Render 등)로 배포할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이것은 주로 웹 개발에 중점을 둔 Day 1에서의 최신 정보이다. Day 2는 React Native에 관한 것입니다.\n\n가장 기대되는 것은 React 컴파일러입니다. 아직 실험 중이지만, 현재 제품에서 시도해보고 싶다면 피드백을 제공하는 것을 도와주기 위해 작업 그룹에 참여할 수 있습니다.\n\n만약 이 글이 도움이 된다면, 더 많은 웹 개발 통찰력을 위해 구독을 고려해 주세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-WhatsNewatReactConf2024_0.png"},"coverImage":"/assets/img/2024-05-20-WhatsNewatReactConf2024_0.png","tag":["Tech"],"readingTime":6},{"title":"대용량 JSON 파일을 효율적으로 전송하는 방법","description":"","date":"2024-05-20 21:43","slug":"2024-05-20-HowToTransferLargeJSONFilesEfficiently","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png\" /\u003e\n\n대규모 JSON 데이터를 전송할 때, 기존 방식을 사용하면 데이터 처리를 시작하기 전에 완전한 JSON 데이터를 수신해야 하므로 사용자 경험에 영향을 줄 수 있습니다. 이 문제를 해결하기 위해 기존의 JSON 스트림 구문 분석 라이브러리를 사용할 수 있습니다. 예를 들어 내부적으로 TextDecoder API를 사용하는 @streamparser/json이 있습니다.\n\nTextDecoder API는 이진 데이터 (일반적으로 ArrayBuffer 또는 TypedArray)를 문자열로 디코딩하기 위한 JavaScript API입니다. 이는 Web 플랫폼의 일부이며 텍스트 인코딩의 디코딩을 처리하는 데 주로 사용됩니다. 예를 들어, 서버로부터 수신한 스트리밍 데이터, 파일 데이터 등을 처리하는 데 사용됩니다.\n\n# TextDecoder API 사용 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 애플리케이션에서 이진 데이터를 다룰 때, 이 데이터를 읽을 수 있는 문자열 형식으로 변환해야 하는 경우가 종종 있습니다. TextDecoder를 사용하면 이를 효율적이고 편리하게 할 수 있습니다.\n\nTextDecoder API에는 다음과 같은 기능이 있습니다:\n\n- 효율적: 수동으로 바이트 단위로 처리하는 것보다 효율적이며, 문자열로 직접 디코딩이 가능합니다.\n- 여러 인코딩 지원: 다양한 텍스트 인코딩(예: UTF-8, UTF-16, ISO-8859-1 등)을 지원합니다.\n- 스트리밍 처리 지원: 데이터를 조각조각으로 처리할 수 있어 대용량 데이터 스트림 또는 실시간 처리가 필요한 데이터에 적합합니다.\n\n# TextDecoder API 사용 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, TextDecoder API를 사용하는 네 가지 시나리오를 소개하겠습니다:\n\n- 서로 다른 인코딩된 바이너리 데이터 해독\n- 스트리밍 JSON 데이터 디코딩\n- 대용량 JSON 파일의 데이터 청크 디코딩\n\n## 1. 서로 다른 인코딩된 바이너리 데이터 해독\n\n```js\n// 다른 인코딩으로 TextDecoder 인스턴스 생성\nconst utf16Decoder = new TextDecoder('utf-16');\nconst iso88591Decoder = new TextDecoder('iso-8859-1');\n\nconst utf16Array = new Uint16Array([0x0048, 0x0065, 0x006C, 0x006C, 0x006F]);\nconst iso88591Array = new Uint8Array([72, 101, 108, 108, 111]);\n\n// 문자열로 디코딩\nconst utf16String = utf16Decoder.decode(utf16Array);\nconst iso88591String = iso88591Decoder.decode(iso88591Array);\n\nconsole.log(utf16String); // 출력：\"Hello\"\nconsole.log(iso88591String); // 출력：\"Hello\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 스트리밍 JSON 데이터 디코딩\n\n먼저, 결과를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_1.png)\n\n위의 예제에서는 Node.js의 http 모듈을 사용하여 로컬 SSE (서버 전송 이벤트) 서버를 빠르게 구축합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nserver.js\n\n```js\nconst http = require(\"http\");\n\nconst PORT = 3000;\n\nconst server = http.createServer((req, res) =\u003e {\n  if (req.url === \"/sse\") {\n    res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\":\n        \"Origin, X-Requested-With, Content-Type, Accept\",\n    });\n\n    let id = 1;\n    const interval = setInterval(() =\u003e {\n      const data = {\n        id: id,\n        message: `This is message ${id}`,\n        timestamp: +new Date(),\n      };\n      res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\n      if (id == 5) {\n        res.write(\"event: end\\n\");\n        res.write(\"data: End of stream\\n\\n\");\n        clearInterval(interval);\n        res.end();\n      }\n\n      id++;\n    }, 1000);\n\n    req.on(\"close\", () =\u003e {\n      clearInterval(interval);\n    });\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n    res.end(\"404 Not Found\");\n  }\n});\n\nserver.listen(PORT, () =\u003e {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n```\n\nsse 핸들러에서는 Content-Type 응답 헤더의 유형을 \"text/event-stream\"으로 설정하여 클라이언트에게 스트리밍 데이터를 반환한다는 것을 알려줍니다.\n\nindex.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSSE \u0026 TextDecoder\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ch1\u003e서버-전송 이벤트 JSON 스트림 데이터 디코딩\u003c/h1\u003e\n    \u003cdiv id=\"messages\"\u003e\u003c/div\u003e\n    \u003cscript src=\"client.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\nclient.js\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", () =\u003e {\n  const messagesDiv = document.querySelector(\"#messages\");\n  const textDecoder = new TextDecoder(\"utf-8\");\n\n  fetch(\"http://localhost:3000/sse\").then((response) =\u003e {\n    const reader = response.body.getReader();\n    return new ReadableStream({\n      start(controller) {\n        function push() {\n          reader.read().then(({ done, value }) =\u003e {\n            if (done) {\n              controller.close();\n              return;\n            }\n\n            const chunk = textDecoder.decode(value, { stream: true });\n            const lines = chunk.split(\"\\n\");\n\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const json = line.slice(6);\n                const data = JSON.parse(json);\n                const p = document.createElement(\"p\");\n                p.textContent = `ID: ${data.id}, Message: ${data.message}, Timestamp: ${data.timestamp}`;\n                messagesDiv.appendChild(p);\n              } else if (line.startsWith(\"event: end\")) {\n                const p = document.createElement(\"p\");\n                p.textContent = \"스트림의 끝\";\n                messagesDiv.appendChild(p);\n                return;\n              }\n            }\n            push();\n          });\n        }\n        push();\n      },\n    });\n  });\n});\n```\n\nSSE 이벤트 스트림은 간단한 텍스트 데이터 스트림이며 해당 텍스트는 UTF-8 형식을 사용하여 인코딩됩니다. 따라서 textDecoder 객체를 생성할 때 인코딩을 utf-8로 설정해야 합니다. 텍스트Decoder 객체가 준비되면 해당 객체가 제공하는 decode 메소드를 호출하여 디코딩할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 대용량 JSON 파일에서 데이터 청크 디코딩하기\n\n다시 한번, 먼저 결과를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_2.png)\n\n위 그림에서 JSON 데이터 출력은 다음 large.json 파일에서 나온 것입니다. 우리는 파일을 0.5KB씩 잘라서 500ms마다 다음 청크를 보내는 방식으로 처리합니다. @streamparser/json 라이브러리를 사용하여 JSON 청크를 파싱할 수 있는 기능을 구현했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nlarge.json\n\n```js\n[\n  {},\n  {\n    \"image\": [\n      {\n        \"shape\": \"rect\",\n        \"fill\": \"#333\",\n        \"stroke\": \"#999\",\n        \"x\": 0.5e1,\n        \"y\": 0.5,\n        \"z\": 0.8,\n        \"w\": 0.5e5,\n        \"u\": 2e10,\n        \"foo\": 2e1,\n        \"bar\": 2,\n        \"width\": 47,\n        \"height\": 47\n      }\n    ],\n    \"corners\": { \"1\": true, \"3\": true, \"7\": true, \"9\": true }\n  },\n ...\n]\n```\n\njson-server.js\n\n```js\nconst http = require(\"http\");\nconst { join } = require(\"path\");\nconst { readFileSync } = require(\"fs\");\n\nconst PORT = 3000;\n\nconst largeJson = readFileSync(join(__dirname, \"large.json\")).toString();\n\nconst server = http.createServer((req, res) =\u003e {\n  if (req.url === \"/stream-json\") {\n    res.writeHead(200, {\n      \"Content-Type\": \"application/json\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\":\n        \"Origin, X-Requested-With, Content-Type, Accept\",\n    });\n\n    const CHUNK_SIZE = 512;\n    let position = 0;\n\n    const interval = setInterval(() =\u003e {\n      const chunk = largeJson.slice(position, position + CHUNK_SIZE);\n      res.write(chunk);\n      position += CHUNK_SIZE;\n\n      if (position \u003e= largeJson.length) {\n        clearInterval(interval);\n        res.end();\n      }\n    }, 500);\n\n    req.on(\"close\", () =\u003e {\n      clearInterval(interval);\n    });\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n    res.end(\"404 Not Found\");\n  }\n});\n\nserver.listen(PORT, () =\u003e {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstream.html\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n    \u003ctitle\u003eStream JSON\u003c/title\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003ch1\u003eStream JSON\u003c/h1\u003e\n    \u003cdiv id=\"messages\"\u003e\u003c/div\u003e\n    \u003cscript type=\"module\"\u003e\n      import { JSONParser } from \"https://cdn.jsdelivr.net/npm/@streamparser/json-whatwg@0.0.21/+esm\";\n      const messagesDiv = document.querySelector(\"#messages\");\n\n      document.addEventListener(\"DOMContentLoaded\", async () =\u003e {\n        const parser = new JSONParser();\n\n        const response = await fetch(\"http://localhost:3000/stream-json\");\n\n        const reader = response.body.pipeThrough(parser).getReader();\n        while (true) {\n          const { done, value: parsedElementInfo } = await reader.read();\n          if (done) break;\n\n          const { value, key, parent, stack, partial } = parsedElementInfo;\n          if (partial) {\n            console.log(`Parsing value: ${value}... (still parsing)`);\n          } else {\n            const p = document.createElement(\"p\");\n            p.textContent = `${JSON.stringify(value)}`;\n            messagesDiv.appendChild(p);\n            console.log(`Value parsed: ${JSON.stringify(value)}`);\n          }\n        }\n      });\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n@streamparser/json 라이브러리는 다른 용도도 있어요. 관심이 있다면 사용 설명서를 살펴보세요. TextDecoder API에 대한 다른 유용한 사용 사례가 있으면 댓글을 남겨주세요.\n\nTypeScript는 정말 멋지고 배울 가치가 있어요. TypeScript를 배우고 싶다면 Medium이나 Twitter에서 저를 팔로우해서 TS와 JS에 관한 더 많은 내용을 읽을 수 있어요!","ogImage":{"url":"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png"},"coverImage":"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png","tag":["Tech"],"readingTime":9},{"title":"러스트 트레이트 TypeScript 인터페이스의 강력한 대안","description":"","date":"2024-05-20 21:42","slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface","content":"\n\n\n![RustTraitAPowerfulAlternativeToTypeScriptInterface](/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png)\n\nRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\n\n이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\n\n# 선언\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\n\n인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\n\nTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\n\n```js\ninterface Entity {\n    id: string;\n    timestamp: number;\n}\n\ninterface Document extends Entity {\n    revised: boolean;\n}\n\ninterface Image extends Entity {\n    type: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\n\n```js\nstruct Document {\n    id: String,\n    timestamp: u64,\n    revised: bool,\n}\n\nstruct Image {\n    id: String,\n    timestamp: u64,\n    mime_type: String,\n}\n```\n\n# 상속 및 제네릭\n\n이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e\n documents.find(({ id: docId }) =\u003e docId === id);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e\n images.find(({ id: imageId }) =\u003e imageId === id);\n```\n\n하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\n\n```js\nconst get = \u003cT extends Entity\u003e(\n id: string,\n elements: T[]\n): T | undefined =\u003e\n elements.find(({ id: elementId }) =\u003e elementId === id);\n\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e get\u003cDocument\u003e(id, documents);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e get\u003cImage\u003e(id, images);\n```\n\nRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rs\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    documents.into_iter().find(|document| document.id == id)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    images.into_iter().find(|image| image.id == id)\n}\n```\n\n위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\n\n이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\n\n```rs\ntrait Compare {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool;\n}\n\nimpl Compare for Document {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n\nimpl Compare for Image {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\n\n```js\nfn get\u003cT: Compare\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements.into_iter().find(|element| element.compare(\u0026id))\n}\n\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    get(id, documents)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    get(id, images)\n}\n```\n\n또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\n\n```js\nfn get\u003cT: Compare + OtherTrait\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements\n        .into_iter()\n        .find(|element| element.compare(\u0026id) \u0026\u0026 element.other_trait(\u0026id))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\n\n```rust\ntrait Compare {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering;\n}\n\nimpl Compare for Document {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.timestamp.cmp(\u0026other.timestamp)\n    }\n}\n```\n\n# 결론\n\n우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무한한 여정이 시작됩니다\n데이비드\n\n더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"},"coverImage":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png","tag":["Tech"],"readingTime":4},{"title":"프론트엔드 주간 소식: 2024년 5월 13일  5월 19일","description":"","date":"2024-05-20 21:41","slug":"2024-05-20-FrontendWeeklyDigest3631319May2024","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png\" /\u003e\n\n# 웹 개발\n\n- 온라인 콘텐츠가 사라질 때: 2013년에 존재했던 웹페이지 중 38%가 10년 후에는 더 이상 접근할 수 없음\n- 로컬 파일을 배포하여 라이브 웹사이트 만들기\n- WebRTC를 활용한 P2P 비디오 스트리밍 구현하기\n- NoJS 2 - 확률적인 부갈루. 순수 HTML과 CSS를 사용해 '랜덤성'을 추가하여 틱택토 게임 만들기. 자바스크립트 없이!\n- 정적 사이트도 확장이 가능하다: 11ty 이벤트에서 Eleventy 대 Next.js 비교\n- 서버 로딩 시 Prefetching이 작동하지 않을 때\n- 다중 페이지 애플리케이션 뷰 전환이 도착했습니다(Google I/O 2024)\n\n- 도구\n- GTmetrix의 새로운 디자인\n- 대부분의 개발자가 알지 못하는 5가지 멋진 Chrome 개발자 도구 기능\n- Safari 17.4의 최신 Webkit 기능 이해\n\n- 접근성\n- 웹에서 텍스트 크기 조정을 다시 생각하기\n- 웹을 보다 접근 가능하게 만들기: 메뉴와 로더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CSS\n\n- CSS 변수 대신 사용자 정의 @property가 필요한 경우\n- JS-Free 사이트 메뉴를위한 앵커 위치 지정 및 팝오버 API\n- CSS 미디어 쿼리 너머\n- 준수 대 가독성: CSS로 텍스트 색상 생성\n- 시간 기반 CSS 애니메이션\n- 전통적인 테두리 반경 권고 사항과 더 이상의 비범한 요령\n- CSS 메이슨리의 구문과 이름보다 tabbing 동작에 대해 걱정합니다.\n\n# JavaScript\n\n- JavaScript 패키지 문서화하는 방법\n- 프로젝트에 적합한 라이브러리 선택: htmx vs. React\n- Vuejs Amsterdam 2024, 29개 동영상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript\n  - TypeScript Adventures: Prop Drilling Down the Rabbit Hole\n  - ReScript vs. TypeScript: Overview and comparison\n  - Dynamic Github profile with Bun and Typescript\n- React\n  - Snappy UI Optimization with useDeferredValue\n  - Bulletproof React — A simple, scalable, and powerful architecture for building production ready React applications.\n  - Meta Releases Open Source React Compiler\n  - 5 Tips and Tricks To Make Your Life With Next.js 14 Easier\n  - What’s New at React Conf 2024\n  - It’s not just you, Next.js is getting harder to use\n- Angular\n  - Angular 18 will arrive next week\n  - Angular 18: Revolutionizing Web Development with Cutting-Edge Features\n  - Simplifying Client-Side Logic: The Strategic Use of View Models\n  - Template local variables with @let in Angular","ogImage":{"url":"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png"},"coverImage":"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"장고로 대규모 프로젝트를 만드는 방법","description":"","date":"2024-05-18 22:36","slug":"2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png\" /\u003e\n\n요즘 장고는 이미 잘 아시겠지만, 큰 아이디어를 현실로 만들 때 절대적인 선택지입니다. 몇 가지를 만들어본 코더로서, 때로는 뭔가 엄청난 일들을 하려다 보면 조금씩 자신감이 떨어지기도 합니다. 그렇죠? '음, 장고가 이걸 오랫동안 버틸 수 있을까?' 하고 걱정이 드는 건 당연한 일입니다. 장고의 속도와 구조는 정말 생명을 살려주죠. (첫 번째 어드민 패널을 사용했을 때의 마법 같은 경험을 기억하시나요?) 하지만 여러분과 같은 코더로서, 나중에 복잡한 병목 현상을 걱정하기 시작할 때의 기분을 잘 아실 거예요.\n\n그러니까, 팬보이들의 이야기는 좀 떠나서 진짜 개발자들끼리 진지한 대화를 나눠보자고요. 장고는 정말 비범한 프로젝트에 대응할 수 있는 걸까요? 어디가 한계일까요? 이것이 정말 올바른 선택이며, 나중에 후회하지 않을 결정인지 어떻게 확신할 수 있을까요? 구글부터 현재 파이썬을 가르치고 있는 저의 경험에 따르면, 파헤쳐야 할 것들이 많다고 생각합니다.\n\n# 장고가 빛을 발하는 곳: 아이디어를 가속화합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빠른 시작, 빠른 반복: Django의 '전부 구비'는 빈말이 아닙니다. 사용자 인증이 필요한가요? 퍼워, 이미 구현되어 있어요. 객체-관계 매핑은? 해결했어요. 초기 단계는 아이디어를 발전시키는 데 집중할 수 있는 시간이에요. 새 프로젝트를 시작할 때 항상 Django를 선택하는 이유죠.\n- 구조가 정신 건강을 지킨다: 사실 몇몇 프로젝트는 빨리 코드 공룡이 될 수 있어요. Django의 모델은 데이터 관계를 깔끔하게 유지시켜주고 관리 패널은 전체 구조를 한 눈에 볼 수 있게 해줘요. 몇 달 후 코드를 다시 보게 되었을 때, 이것은 과거의 자신으로부터의 선물 같이 느껴질 거에요.\n- Django 커뮤니티의 지혜: 이상한 버그에 걸렸나요? 대형 Django 커뮤니티 속에 이미 누군가가 그것을 보았을 가능성이 높아요. Stack Overflow, 포럼, 블로그 사이에서 진짜로 꼼꼼히 막히는 일은 드물죠. 데드라인에 쫓겨 있을 때는 그만한 가치가 있다고 생각해요.\n\n## 예시: 내 컨텐츠 집계기가 작동 중\n\n당신의 컨텐츠 집계기를 떠올려보세요. Django를 사용한다면 아마 이와 같은 모델을 갖게 될 거에요:\n\n```js\nclass Source(models.Model):\n    name = models.CharField(max_length=100)\n    url = models.URLField()\n    # ... 기타 업데이트 주기 추적을 위한 필드들 \n\nclass Article(models.Model):\n    title = models.CharField(max_length=255)\n    content = models.TextField()\n    source = models.ForeignKey(Source, on_delete=models.CASCADE)\n    # ... 발행일, 작가 등을 위한 필드들\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보니까 많이 깨끗하다, 맞지? Django는 데이터베이스 관련 작업을 맡아 처리해주기 때문에 당신은 콘텐츠를 가져오고 표현하는 로직에 주력할 수 있어요. \n\n# 야망이 Django를 넘어설 때\n\n- 트래픽 몬스터: 그만봐도 알겠지만, 만약 다음 바이럴 히트를 만들고 있다면, 로우 Django는 이에 대응하기 어려울 수도 있어요. 하지만 이것은 Django의 실패가 아니에요! 여기에는 스마트한 아키텍처가 필요해요. 캐싱(미리 생성된 콘텐츠), 로드 밸런서(작업 분산), 그리고 쿼리 최적화를 고려하면 Django를 놀랄 정도로 멀리 뻗을 수 있어요.\n- 픽셀 퍼펙션 애정: 맞춤 및 혁신적인 상호작용이 필요한 디자인이 있는가요? Django의 템플릿 및 내장 구성 요소는 강력하지만, 매우 맞춤화된 UI는 씨름이 될 수도 있어요. Django와 함께 JavaScript 프레임워크를 고려하는 것이 더 현명한 장기적인 계획일 수 있어요.\n- 최신 기술에 대응: Django는 안정성과 신뢰할 수 있는 패키지의 거대한 생태계를 기반으로 발전해요. 만약 핵심 아이디어가 최신 AI 라이브러리나 실험적인 기술에 의존한다면 어려움에 부딪힐 수 있어요. 불가능한 것은 아니지만 소매를 걷고 통합 작업을 하기 위해 소매를 걷어올려야 할 준비를 해야 해요.\n\n## 예시: 게임이 시작될 때\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 멋진 실시간 멀티플레이어 게임 아이디어를 상상해 보세요. 물리 시뮬레이션, 게임 상태에 대한 지속적인 업데이트... Django는 플레이어 계정, 로비 등을 처리할 수 있지만 실시간, 저지연의 액션은 아마도 그 부분을 위해 특화된 도구가 필요할 것입니다. Django는 '큰 그림'을 관리하게 됩니다.\n\n중요한 참고사항: Django가 나쁜 것은 아닙니다! 모든 시나리오에 완벽한 도구는 없다는 점을 솔직하게 인식하는 것입니다. 숙련된 개발자의 초능력은 전략적으로 도구를 조합할 때를 알 수 있는 데에 있습니다.\n\n# \"달라질 수 있다\" 요소: Django만의 문제가 아닙니다\n\n- 당신의 팀의 Django-기술: 알고 있는 Django 팀은 요령을 알고 있습니다. 쿼리 최적화하는 방법, 장기적인 데이터 구조, 그리고 언제 추가 도구를 전략적으로 도입할지 알고 있습니다. Django에 익숙한 팀이 아닌 경우? 그들도 그 수준에 도달할 것이지만, 학습 곡선이 프로젝트 기한과 겹칠 수 있습니다.\n- 데이터 중심 vs. 야생의 서쪽: Django는 구조화된 데이터에서 빛을 발합니다. 전자상거래 사이트, 콘텐츠 플랫폼, 심지어 내부 도구들... 거기서 잘 동작합니다. 그러나 만약 당신의 아이디어가 예측할 수 없는 데이터 유형이나 상호작용을 가진 매우 실험적인 경우, Django를 자신의 의지에 맞게 굽히느라 건설하는 것보다 더 많은 시간을 보낼지도 모릅니다.\n- 야심찬...어떻게, 정확히? 백만 명의 사용자는 말하는 건가요, 그러나 비교적 직관적인 기능들일까요? Django는 스마트한 최적화로 이를 처리하는 경우가 많습니다. 그러나 적은 사용자지만 괴로운 완전히 복잡한 기능과 톤의 맞춤 논리가 있는 경우는? 그건 다른 종류의 도전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코딩의 아름다움(그리고 때로는 좌절!)은 보편적으로 '최고'인 도구가 없다는 점입니다. 올바른 선택은 이러한 요소들과 어떻게 조화를 이루느냐에 따라 달라집니다. 판단은 여러분의 최대 자산인 경험에 달려있어요.\n\n간단한 시나리오를 보여드리죠: 여러분의 컨텐츠 집계기가 성공적입니다. 하지만 홈페이지가 다수의 소스에서 최신 기사를 가져오기 때문에 느려지고 있어요.\n\n초보적인 접근 방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.all().order_by('-published_date')[:20] \n    return render(request, 'homepage.html', {'articles': latest_articles})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 이 방법은 모든 기사를 매번 가져와서 표시를 위해 슬라이스합니다. 데이터베이스가 커질수록 문제가 심각해집니다.\n\n최적화된 접근방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.select_related('source').order_by('-published_date')[:20]\n```\n\n변경된 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- select_related: 이것은 Django에게 각 기사에 대해 관련 'Source' 객체를 미리 가져오도록 지시하여 나중에 데이터베이스 작업을 줄입니다.\n- Queryset Slicing: 우리는 필요한 최상위 20개만 가져옵니다, 모든 것을 가져오지 않습니다.\n\n왜 중요한가: 이 문제는 작아 보일 수 있지만, 규모에 맞게 그 최적화 작업은 빠른 사이트와 부하 하에 격렬하게 돌아가는 사이트 사이의 차이를 만들어냅니다. 이것은 경험 많은 Django 개발자가 제공하는 사고 방식입니다.\n\n# 정직한 판단\n\n- Django: 스위스 아미 나이프, 레이저 빔이 아님 Django는 상상할 수 있는 모든 것을 구축하는 데 관한 것이 아닙니다. 대신, 수많은 웹 프로젝트를 빠르고 훌륭하게 구축하는 데 중점을 두고 있습니다. 때로는 전문화된 도구가 필요할 때도 있습니다. 그것은 괜찮습니다!\n- 구축을 시작하고, 답이 나타날 것입니다: 솔직히 말해서, Django가 장기적으로 적합한지 알아보는 가장 좋은 방법은 직접 해 보는 것입니다. 초기 속도를 통해 잠재적인 병목 현상이 실제 문제가 되기 훨씬 전에 발견할 수 있습니다. '만약' 때문에 시작하는 것을 막지 마세요.\n- Django보다 크게 생각하십시오: 데이터베이스가 중요합니다! 확장성을 고려하지 않고 나쁜 데이터베이스를 선택하면, Django 코드가 얼마나 좋든 손해를 입을 것입니다. 같은 이유로 엉성한 배포도 마찬가지입니다 - 느린 서버는 모든 것을 느리게 만듭니다. 전문가적인 마인드는 전체 시스템에 대한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Django의 모든 문제가 아닙니다\n\n성능적인 한계에 부딪혔다고 가정해 봅시다. Django를 포기하기 전에 다음을 고려해 보세요:\n\n- 쿼리 시간: 데이터베이스 조회가 엉망인가요? 최적화는 매우 중요합니다 (이전 예시를 참고하세요!)\n- 외부 요소: 서버 성능이 좋지 않은가요? 의존하는 외부 API가 병목 현상을 일으키나요?\n\n핵심 포인트: Django는 여러분의 도구상자에서 강력한 도구일 뿐, 유일한 존재는 아닙니다. 성공은 이러한 조각들을 잘 맞물리게 하는 데에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 추가 맛\n\n- 장고 거인들: 인스타그램이 Django를 떠나기로 유명하다고 하지만, Disqus, Eventbrite, 심지어 NASA와 같은 사이트들은 여전히 시스템의 핵심 부분에 의지하고 있습니다. 규모는 상대적이며, Django의 매력 포인트는 생각보다 넓습니다.\n- 나의 Django '아하!' 순간: 프로젝트가 Django를 벗어나야 한다고 생각했어요. 복잡한 데이터, 수많은 맞춤 기능... 몇 가지 잘못된 쿼리가 문제의 원인이라는 것을 발견했습니다! 그것들을 다시 작업하니 Django가 새로운 존재처럼 느껴졌어요. 배운 교훈: 탈주하기 전에 최적화 작업을 하세요.\n- 전쟁 이야기를 나눠보세요: Django가 승리한 이야기나 실망했던 순간에 대한 이야기를 가지고 계신가요? 댓글에서 공유해주세요! 이런 경험들이 우리를 더 나아지게 하는 방법입니다. Django 커뮤니티가 강한 이유가 있습니다 — 우리는 이런 것에 대해 열정적으로 이야기하는 것을 좋아합니다.\n\n## 더 알아보기\n\n만약 이러한 해설이 도움이 되었다면, 중요한 Python과 Django 통찰을 좀 더 파헤치겠습니다. 제 Medium 페이지를 팔로우해주시고, 대화를 이어가고, 만약 가치 있다고 느끼시면 박수를 치세요. 또한, 곧 YouTube 채널을 시작할 준비 중이니, 더 많은 코딩 모험을 기대해주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 번역  🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 이렇게 가기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인해보세요","ogImage":{"url":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png"},"coverImage":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png","tag":["Tech"],"readingTime":6},{"title":"템플릿 간소화하기 Angular 17에서의 제어 흐름","description":"","date":"2024-05-18 22:35","slug":"2024-05-18-StreamlineYourTemplatesControlFlowinAngular17","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png\" /\u003e\n\n안녕하세요, Angular 열정가 여러분! 오늘은 Angular 17의 새로운 혁신인 내장 제어 흐름 구문을 발표하려고 왔어요! 이 새로운 기능을 사용하면 추가 지시문 (ngIf, ngFor, ngSwitch)을 버리고 집에 온 듯한 키워드를 사용하여 템플릿에서 제어 흐름 로직을 직접 작성할 수 있어요 (자바스크립트 같아요!). 이것이 어떻게 당신의 Angular 경험을 향상시키는 지 한번 알아봐요!\n\n우리는 여러 해 동안 조건부로 콘텐츠를 렌더링하고 데이터를 반복하는 데 지시문을 의존해 왔어요. 그들은 작동하지만 템플릿에 혼란과 복잡성의 추가 레이어를 덧붙일 수 있어요. Angular 17은 @if, @else if, @switch 및 @for 같은 익숙한 키워드를 사용하여 템플릿 내에서 직접 제어 흐름 로직을 작성할 수 있게 해줘요. 이러면 코드가 더 깔끔하고 읽기 쉽고 일반적인 자바스크립트를 작성하는 느낌이 들어요!\n\n## 왜 지시문 대신 제어 흐름을 선택해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 변경하는 것이 좋은 몇 가지 설득력 있는 이유입니다:\n\n- 뚜렷한 가독성: 제어 흐름 구문은 JavaScript의 제어 흐름 구조를 반영하여, JavaScript에 익숙한 사람들에게 이해하기 쉬운 템플릿을 만드는 데 도움이 됩니다.\n- 중복성 감소: ✂️ 제어 흐름을 통해 여분의 지시문이 필요 없어져 더 깔끔하고 간결한 템플릿을 생성할 수 있습니다.\n- 현대적인 개발 경험: 제어 흐름은 현대적인 JavaScript 관행과 일치하며, 일관되고 익숙한 개발 경험을 촉진합니다. 이는 더 적은 정신 부담과 놀라운 기능을 구축하는 데 더 많은 시간을 집중할 수 있다는 것을 의미합니다!\n\n# @if와 @else로 익숙함을 받아들이다\n\n참/거짓 변수에 따라 메시지를 표시하려는 시나리오를 상상해보십시오. 기존에는 다음과 같이 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (isLoggedIn) {\n  \u003cp\u003e다시 오신 것을 환영합니다!\u003c/p\u003e\n} @else {\n  \u003cp\u003e로그인해주세요.\u003c/p\u003e\n}\n```\n\n이렇게 제어 흐름 구문을 사용하면 JavaScript에서 제어 흐름을 작성하는 방식과 더 자연스러워집니다. 더 복잡한 조건을 위해 @else if 문을 연결할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Level Up Loops with @for\n\n데이터 컬렉션을 반복하는 것은 Angular 애플리케이션의 기본적인 부분입니다. 이전에 우리는 *ngFor을 사용했습니다. 제어 흐름은 유사한 접근 방식을 제공합니다:\n\n```js\n\u003cul\u003e\n  \u003cli *ngFor=\"let fruit of fruits\"\u003e{ fruit.name }\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n제어 흐름에 대한 비교:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cul\u003e\n  @for (과일 in 과일들; trackBy: 과일.name) {\n    \u003cli\u003e{ 과일.name }\u003c/li\u003e\n  } @empty {\n    \u003cli\u003e과일이 없습니다.\u003c/li\u003e\n  }\n\u003c/ul\u003e\n```\n\n하지만 기능이 향상되었습니다! 제어 흐름 구문을 사용하려면 trackBy를 사용하여 추적 함수를 지정해야 합니다. 이렇게 하면 Angular가 컬렉션 내의 변경 사항을보다 효율적으로 식별하여 앱이 특히 대규모 데이터 세트로도 원활하게 실행되도록 지원합니다! ❤️\n\n# @switch로 결정 내리기 ⚖️\n\n여러 조건에 따라 콘텐츠를 렌더링해야 하는 경우 @switch 문이 구원의 손을 내밀어줍니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@switch(selectedFruit) {\n  @case(apple){\n    \u003cp\u003e사과를 선택하셨네요!\u003c/p\u003e\n  }\n  @case(banana){\n    \u003cp\u003e바나나는 포타슘의 좋은 원천입니다!\u003c/p\u003e\n  }\n  @default {\n    \u003cp\u003e그것은 제가 알아듣는 과일이 아니에요.\u003c/p\u003e\n  }\n}\n```\n\n이렇게 하면 템플릿 안에서 switch-case 로직을 보다 간결하고 가독성 있게 처리할 수 있어요. 멋지죠? ✨\n\n# 링크\n\n아래에서 제어 흐름 구문의 상세 정보를 찾을 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular — @for\n- Angular — @switch\n- Angular — @if","ogImage":{"url":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png"},"coverImage":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png","tag":["Tech"],"readingTime":3},{"title":"PHP 8.3에 추가된 20가지 흥미로운 기능들 정리","description":"","date":"2024-05-18 22:31","slug":"2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss","content":"\n\n## 웹 개발과 프로그래밍을 혁신하는 PHP 8.3의 최신 기능 및 개선 사항을 알아보세요.\n\n![이미지](/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png)\n\n인기 있는 서버 측 스크립팅 언어인 PHP의 최신 버전인 PHP 8.3은 새로운 기능과 개선 사항이 많이 포함되어 있어 웹 개발을 최적화하고 성능을 향상시킬 것을 약속합니다. readonly 클래스, 새 json_validate() 함수, Randomizer 클래스에 대한 추가, 더 적합한 날짜/시간 예외 등의 개선 사항을 통해 PHP 8.3은 PHP 개발 경험을 혁신할 것입니다. 이러한 업데이트는 PHP를 더 효율적, 안전하고 다양하게 만들어 웹 개발자와 기업의 변화하는 요구를 충족시키기 위해 목적을 두고 있습니다.\n\n# PHP 8.3의 20가지 흥미로운 기능 및 개선 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 읽기 전용 클래스 개선 사항\n- 새로운 json_validate() 함수\n- Randomizer 클래스에 대한 추가 기능\n- 타입이 지정된 클래스 상수\n- 익명 읽기 전용 클래스\n- 동적 클래스 상수 검색\n- 보다 적절한 날짜/시간 예외 처리\n- 개선된 unserialize() 오류 처리\n- 트레이트 및 정적 속성\n- 스택 오버플로 감지\n- 일정 상수 가시성\n- Assert String Eval 정리\n- 향상된 FFI\\CData:void\n- posix_getrlimit() 매개변수 개선\n- gc_status() 개선\n- 내부 클래스에 대한 class_alias() 지원\n- mysqli_poll() 오류 처리\n- array_pad() 개선 사항\n- opcache.consistency_checks ini 지시문 제거\n- number_format()을 사용하여 소수점 처리를 올바르게 처리\n\n# 1. 읽기 전용 클래스 개선 사항\n\nPHP 8.3에서 읽기 전용 클래스에 중요한 개선 사항이 있어 개발자들이 코드를 더 유연하고 효율적으로 제어할 수 있게 되었습니다. 특정하지만 중요한 엣지 케이스를 해결하기 위해 생성 및 복제 시 읽기 전용 속성을 다시 초기화할 수 있는 기능이 추가되었습니다. 이번 업그레이드로 읽기 전용 속성의 딥 클론이 가능하게 되어 PHP에서 읽기 전용 클래스의 유틸리티가 확장되었습니다. 다음은 DateTime 속성을 가진 읽기 전용 클래스의 예시입니다:\n\n```js\nreadonly class Post {\n    public function __construct(public DateTime $createdAt) {\n        // 생성자 로직\n    }\n\n    public function __clone() {\n        $this-\u003ecreatedAt = new DateTime();\n        // 읽기 전용 속성을 다시 초기화하는 것이 이제 허용됩니다\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서 Post 클래스에는 읽기 전용 속성 $createdAt이 있습니다. 이 속성은 게시물의 생성 날짜를 나타냅니다. PHP 8.3에서 개선된 사항으로, __clone() 메서드를 사용하여 읽기 전용 속성을 다시 초기화할 수 있어 객체의 깊은 복제를 가능하게 하고 읽기 전용 속성의 무결성을 해치지 않습니다.\n\n# 2. 새로운 json_validate() 함수\n\njson_validate() 함수의 도입으로 개발자들은 JSON 문자열을 유효성 검사하는 더 효율적이고 직접적인 방법을 제공받게 되었습니다. 이 함수는 JSON 문자열의 유효성을 확인해야 할 때 복호화 과정 없이 바로 확인할 수 있어 매우 유용합니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\nif (json_validate($jsonString)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서는 json_validate() 함수를 사용하여 JSON 문자열 $jsonString을 직접 유효성 검사합니다. JSON 문자열이 유효하면 해당 메시지가 표시됩니다. 이 함수는 디코딩 및 오류 처리 없이 JSON 데이터를 유효성 검사하는 간단한 방법을 제공합니다.\n\n사용자 정의 깊이와 플래그를 지정할 수도 있습니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\n// 사용자 정의 깊이와 플래그로 JSON 문자열 유효성 검사\nif (json_validate($jsonString, 512, JSON_THROW_ON_ERROR)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n이 예제에서는 사용자 정의 깊이와 플래그로 json_validate() 함수를 사용했습니다. 두 번째 매개변수는 JSON 문자열의 최대 깊이를 지정하고, 세 번째 매개변수는 유효성 검사를 위한 플래그를 설정합니다. 이를 통해 개발자는 특정 요구 사항에 맞게 유효성 검사 과정을 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPHP 8.3에서 json_validate() 함수는 JSON 유효성 검사 프로세스를 간소화하여 JSON 문자열을 해독하는 대안으로 더 효율적인 메모리를 제공합니다. 이 향상된 기능은 JSON 데이터의 유효성만을 확인해야 하는 시나리오에서 특히 유용하며 PHP 애플리케이션에서 성능과 자원 활용을 향상시킵니다.\n\n# Randomizer 클래스에 추가된 내용\n\nRandomizer 클래스는 새로운 메서드로 확장되어 개발자가 더 많은 제어와 유연성을 가지고 무작위 데이터를 생성할 수 있게 되었습니다. 이러한 추가 기능은 Randomizer 클래스의 기능을 확장하여 지정된 범위와 제약 조건 내에서 무작위 값을 생성하는데 탁월한 지원을 제공합니다.\n\n```js\nuse Randomizer;\n\n$string = \"Hello, World!\";\n$length = 10;\n\n$randomBytes = Randomizer::getBytesFromString($string, $length);\nvar_dump($randomBytes);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 Randomizer 클래스의 getBytesFromString() 메서드는 지정된 길이($length)의 랜덤 바이트 문자열을 주어진 입력 문자열($string)에서 생성하는 데 사용됩니다. 이 메서드는 랜덤 데이터 생성이 필요한 시나리오에 기반하여 소스 문자열을 기반으로 랜덤 바이트 시퀀스를 생성하는 편리한 방법을 제공합니다.\n\n또한 지정된 범위 내에서 랜덤 정수를 생성할 수도 있습니다.\n\n```js\nuse Randomizer;\nuse IntervalBoundary;\n\n$min = 10;\n$max = 20;\n\n$randomInteger = Randomizer::getRandomInteger($min, $max, IntervalBoundary::Closed);\necho $randomInteger;\n```\n\n이 예시에서 Randomizer 클래스의 getRandomInteger() 메서드는 $min과 $max로 정의된 범위 내에서 랜덤 정수를 생성하는 데 활용됩니다. IntervalBoundary::Closed 열거형은 최소값과 최대값을 범위에 포함해야 함을 나타내는 데 사용됩니다. 이 메서드는 개발자들이 특정 범위 내에서 랜덤 정수를 생성할 수 있도록 돕고 생성된 값에 대한 정확한 제어를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPHP 8.3의 Randomizer 클래스에 추가 사항은 더 향상된 랜덤 데이터 생성 기능을 제공하여, 다양한 제어된 무작위성을 필요로 하는 사용 사례에 맞춤 기능을 제공합니다. 이러한 방법들은 PHP 개발자들에게 사용 가능한 랜덤 데이터 생성 옵션의 범위를 풍부하게 하여 Randomizer 클래스의 전반적인 다양성과 유틸리티에 기여합니다.\n\n# 4. Typed class constants\n\n타입화된 클래스 상수의 도입은 특정 데이터 유형과 함께 클래스 상수를 정의할 수 있도록 하여, 클래스 정의 내에서 향상된 유형 안전성과 명확성을 제공합니다. 이 향상된 기능을 통해 개발자들은 클래스 상수에 대한 유형 제약을 강제할 수 있어 코드의 가독성을 향상시키고 의도하지 않은 데이터 유형 불일치 가능성을 줄일 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass MathOperations {\n    public const PI: float = 3.14159;\n    public const MAX_ITERATIONS: int = 1000;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 MathOperations 클래스는 두 개의 클래스 상수, PI와 MAX_ITERATIONS을 특정 데이터 유형으로 정의합니다. PI 상수는 float로, MAX_ITERATIONS 상수는 INT로 유형이 지정됩니다. 이렇게 함으로써 이러한 상수가 지정된 데이터 유형의 값을 보유하도록 보장하여 유형 안전성을 증진시키고 코드 가독성을 높입니다.\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT: int = 30;\n    public const ENABLE_LOGGING: bool = true;\n    \n    public function setRequestTimeout(int $timeout): void {\n        // Set the request timeout using the DEFAULT_TIMEOUT constant\n        // defined as an integer\n        // ...\n    }\n    \n    public function enableLogging(bool $enable): void {\n        // Enable or disable logging based on the ENABLE_LOGGING constant\n        // defined as a boolean\n        // ...\n    }\n}\n```\n\n이 예에서 Configuration 클래스는 유형화된 클래스 상수를 사용하여 기본 시간 초과 및 로깅 설정 옵션을 정의합니다. DEFAULT_TIMEOUT 상수는 INT로 유형이 지정되어 정수 값을 보유하도록 보장하고, ENABLE_LOGGING 상수는 boolean으로 유형이 지정되어 boolean 값을 보유함을 나타냅니다. 이를 통해 클래스 메서드 내에서 이러한 상수를 사용할 때 일관성과 유형 안전성이 증진됩니다.\n\nPHP 8.3에서 유형화된 클래스 상수의 도입은 클래스 정의의 표현성과 신뢰성을 향상시킵니다. 개발자가 클래스 상수에 대한 데이터 유형을 지정할 수 있어 코드 품질 향상, 더 나은 문서 작성, 클래스 상수 내 데이터 유형 오류 가능성 감소에 기여하며, 결국 PHP 애플리케이션의 견고성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 익명 읽기 전용 클래스\n\n익명 읽기 전용 클래스의 소개는 객체 지향 프로그래밍에 새로운 유연성을 가져 왔습니다. 이러한 클래스를 사용하면 명명된 클래스를 명시적으로 정의할 필요 없이 가벼운 불변 객체를 생성할 수 있습니다. 이 기능은 일시적이거나 일회성 객체가 필요한 시나리오에서 특히 유용합니다. 포멀한 클래스 선언의 오버헤드 없이 필요한 임시 객체를 만들 수 있습니다. 이 기능을 몇 가지 예제를 통해 알아봅시다:\n\n```js\n$person = new class {\n    public function __construct(public string $name, public int $age) {}\n};\n\n$john = new $person('John Doe', 30);\necho $john-\u003ename; // 출력: John Doe\necho $john-\u003eage; // 출력: 30\n```\n\n이 예제에서는 '...' 구문을 사용하여 익명 읽기 전용 클래스를 생성합니다. 이 클래스에는 name 및 age에 대한 공용 속성이 있으며, 이 익명 클래스에서 $john 객체가 인스턴스화됩니다. 이를 통해 포멀한 클래스 선언이 필요 없이 간단하고 가벼운 객체를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n익명 읽기 전용 클래스를 데이터 구조로 사용할 수도 있습니다.\n\n```php\n$data = new class {\n    public array $values = [];\n\n    public function addValue($value): void {\n        $this-\u003evalues[] = $value;\n    }\n};\n\n$data-\u003eaddValue('A');\n$data-\u003eaddValue('B');\n$data-\u003eaddValue('C');\n\nprint_r($data-\u003evalues); // 출력: Array ( [0] =\u003e A [1] =\u003e B [2] =\u003e C )\n```\n\n이 예제에서는 익명 읽기 전용 클래스를 사용하여 값을 저장하는 간단한 데이터 구조를 만듭니다. 클래스에는 배열을 보유하는 공개 속성 values와 배열에 값을 추가하는 addValue 메서드가 있습니다. 이 예는 공식 클래스 정의 없이 즉석에서 작성된 데이터 구조를 만들기 위해 익명 읽기 전용 클래스를 사용하는 방법을 보여줍니다.\n\nPHP 8.3에서 익명 읽기 전용 클래스가 소개되면서 개발자들은 불변의 객체와 데이터 구조를 가볍고 유연하게 즉석에서 만들 수 있게 되었습니다. 이 기능은 PHP의 객체 지향 기능을 보다 표현력 있고 다용도로 사용할 수 있게 하며, 특정 상황에 대해 전통적인 클래스 선언에 대한 편리한 대안을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 동적 클래스 상수 가져오기\n\n이 기능은 개발자들이 클래스 상수를 더 동적인 구문을 사용하여 가져올 수 있게 해주어 클래스 상수를 다룰 때 더 큰 유연성과 표현력을 제공합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT = 30;\n    public const ENABLE_LOGGING = true;\n}\n\n$constantName = 'DEFAULT_TIMEOUT';\necho Configuration::{$constantName}; // 출력: 30\n```\n\n이 예제에서 DEFAULT_TIMEOUT 클래스 상수의 값을 변수 $constantName을 사용하여 동적으로 가져왔습니다. 이 동적 구문을 사용하면 실행 중 값에 따라 클래스 상수를 검색할 수 있어 클래스 상수를 다루는 더 유연한 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해도 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 더 적절한 날짜/시간 예외 처리\n\n이 기능은 다양한 날짜 및 시간 관련 특이 케이스에 대한 전용 예외를 도입하여, 날짜 및 시간 연산에서 보다 세분화되고 구체적인 오류 처리를 제공합니다. 이 향상된 기능은 다양한 오류 시나리오에 대해 더 정확한 예외 유형을 제공하여, 날짜 및 시간 관련 코드의 견고성과 신뢰성을 향상시키고자 합니다. 몇 가지 예제와 함께 이 기능을 살펴봅시다:\n\n```js\ntry {\n    // 범위 오류가 발생하는 날짜 연산\n    // ...\n} catch (DateRangeError $e) {\n    // 특정 DateRangeError 예외 처리\n    // 에러 로깅, 사용자에게 통보 또는 적절한 조치 취하기\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예제에서는 범위 오류가 발생한 날짜 연산을 처리하기 위해 특정 DateRangeError 예외가 잡힙니다. 이를 통해 날짜 범위 오류에 특화된 오류 처리가 가능해지며, 특정 예외 유형을 기반으로 적절한 조치를 취할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n날짜 형식이 잘못된 간격 문자열 예외에 대해서도 처리할 수 있어요.\n\n```js\ntry {\n    // 날짜 간격 파싱 작업\n    // ...\n} catch (DateMalformedIntervalStringException $e) {\n    // 특정 DateMalformedIntervalStringException 처리\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예에서는 DateMalformedIntervalStringException을 사용하여 날짜 간격 문자열이 잘못된 경우 처리합니다. 이 특정 예외 유형을 사용하면 개발자가 날짜 간격 문자열이 잘못된 시나리오에 맞게 맞춤형 오류 처리를 구현할 수 있어요.\n\nPHP 8.3의 \"더 적절한 날짜/시간 예외\" 기능은 날짜 및 시간 관련 오류 처리에 대해 더 정확하고 체계적인 접근 방식을 제공해요. 특정 날짜 및 시간 예외를위한 전용 예외를 도입함으로써 이 개선 사항은 더 나은 오류 관리를 촉진하고 날짜 및 시간 관련 예외의 보다 효율적인 처리를 돕습니다. 이는 PHP 애플리케이션에서 날짜 및 시간 작업의 전체 신뢰성과 견고성에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8. unserialize() 오류 처리 기능 개선\n\n이 기능은 unserialize() 함수의 오류 처리 메커니즘을 향상시켜, 데이터의 역직렬화 중 문제가 발생했을 때 더 일관되고 예측 가능한 동작을 제공합니다. 이 개선은 오류 보고를 간소화하고 unserialize() 오류를 보다 효과적으로 처리하여 더 나은 오류 관리와 디버깅 기능을 제공하고 있습니다. 이 기능을 몇 가지 예제와 함께 살펴보겠습니다:\n\n```js\n$data = '...'; // 직렬화된 데이터\n$result = unserialize($data);\nif ($result === false) {\n    $error = error_get_last();\n    if ($error \u0026\u0026 $error['type'] === E_WARNING) {\n        // unserialize() 오류를 E_WARNING으로 처리\n        // 오류 기록, 사용자에게 알림 또는 적절한 조치를 취합니다\n        // ...\n    } else {\n        // 일반적인 오류 처리로 이동\n        // ...\n    }\n}\n```\n\n이 예제에서는 데이터의 역직렬화를 시도한 후 결과가 false인지 확인하여 오류를 나타내는지 여부를 확인합니다. 그런 다음 error_get_last()를 사용하여 마지막 오류를 가져와 오류 유형을 확인합니다. 오류 유형이 E_WARNING인 경우, unserialize() 오류를 경고로 처리하여 unserialize() 문제에 대한 특정 오류 처리를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n심지어 unserialize 메서드에서 예외 처리를 사용할 수도 있습니다.\n\n```js\n$data = '...'; // 직렬화된 데이터\ntry {\n    $result = unserialize($data);\n    // 직렬화 해제된 데이터 처리\n    // ...\n} catch (UnserializeException $e) {\n    // 특정 UnserializeException 처리\n    // 오류 기록, 사용자에게 알림 또는 적절한 조치 취함\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 대체\n    // ...\n}\n```\n\n이 예제에서 코드는 직렬화 해제 프로세스를 처리하기 위해 try-catch 블록을 활용합니다. UnserializeException이 발생하면 unserialize() 예외에 대한 특정 오류 처리가 가능하며, 개발자들이 unserialize() 문제에 대한 대상적인 오류 관리를 구현할 수 있도록 합니다.\n\nPHP 8.3의 \"Improved unserialize() error handling\" 기능은 unserialize() 함수에 대한 더 일관적이고 구조화된 오류 처리를 도입하여, unserialize 데이터의 처리 중 오류 보고 및 관리에 대한 향상된 제어를 제공합니다. 더 예측 가능한 오류 처리 메커니즘을 제공함으로써, 이 개선 사항은 PHP 애플리케이션에서 직렬화된 데이터를 다룰 때 디버깅 능력과 전반적인 오류 내구성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. 특성과 정적 속성\n\n이 기능은 정적 속성을 사용하는 관련된 특성의 동작 변경을 소개합니다. 이 향상은 특성을 사용할 때 부모 클래스에서 상속받은 정적 속성의 재선언을 다루며, 각 클래스가 특성을 포함할 때 정적 속성에 대한 별도의 저장소를 유지하도록 보장합니다. 이 동작은 이제 특성 내에서 정적 속성을 직접 클래스에 추가하는 것과 유사해졌으며, 특성 내에서 정적 속성을 보다 예측 가능하고 일관된 방식으로 다루도록 장려합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\ntrait Loggable {\n    protected static $log = [];\n\n    public static function addToLog($message) {\n        self::$log[] = $message;\n    }\n\n    public static function getLog() {\n        return self::$log;\n    }\n}\n\nclass User {\n    use Loggable;\n}\n\nclass Product {\n    use Loggable;\n}\n\nUser::addToLog('사용자가 로그인했습니다');\nProduct::addToLog('새 제품이 추가되었습니다');\n\nvar_dump(User::getLog());\nvar_dump(Product::getLog());\n```\n\n이 예제에서 Loggable 특성은 $log라는 정적 속성과 로그에 메시지를 추가하고 로그를 검색하는 메서드를 포함합니다. User 및 Product 클래스는 Loggable 특성을 사용하여 로깅 기능을 통합합니다. 각 클래스는 정적 속성 $log을 위한 별도의 저장소를 유지함으로써 User 및 Product 클래스 간에 로그 데이터가 격리되고 구분되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 바꿀 수도 있어요.\n\n```js\ntrait Counter {\n    protected static int $count = 0;\n\n    public static function increment() {\n        self::$count++;\n    }\n\n    public static function getCount() {\n        return self::$count;\n    }\n}\n\nclass Order {\n    use Counter;\n}\n\nclass Invoice {\n    use Counter;\n}\n\nOrder::increment();\nInvoice::increment();\nOrder::increment();\n\nvar_dump(Order::getCount()); // Output: int(2)\nvar_dump(Invoice::getCount()); // Output: int(1)\n```\n\n이 예시에서, Counter 트레이트는 정적 속성 $count를 초기화하고 카운트를 증가시키고 카운트 값을 검색하는 메서드를 제공합니다. Order와 Invoice 클래스는 카운트를 별도로 추적하기 위해 Counter 트레이트를 사용합니다. 각 클래스는 자체 카운트를 유지하며, 트레이트 내 정적 속성의 별도 저장을 보여 주어 다른 클래스의 정적 속성과는 별개로 작동하는 것을 보여줍니다.\n\nPHP 8.3의 \"Traits and static properties\" 기능은 여러 클래스에서 사용될 때 정적 속성을 일관되고 예측 가능하게 구현함으로써 trait를 사용한 코드 구조에서 정적 속성을 처리하는 강력하고 직관적인 메커니즘을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 10. 스택 오버플로 감지\n\n이 기능은 스택 오버플로 상황을 감지하고 방지하기 위해 zend.max_allowed_stack_size와 zend.reserved_stack_size라는 두 가지 새로운 ini 지시문을 소개합니다. 이 향상된 기능은 스택 오버플로 상황을 감지하고 처리함으로써 PHP 애플리케이션의 신뢰성과 안정성을 향상시키고 세그멘테이션 오류의 가능성을 줄이며 디버깅을 쉽게 만드는 것을 목표로 합니다. 몇 가지 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// php.ini\nzend.max_allowed_stack_size = 128K\n```\n\n이 예시에서는 php.ini 구성 파일에서 zend.max_allowed_stack_size 지시문이 128 킬로바이트로 설정되어 있습니다. 이 지시문은 PHP 프로그램의 최대 허용 스택 크기를 지정하는데, 개발자가 호출 스택 크기의 상한선을 정의할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// php.ini\nzend.reserved_stack_size = 16K\n\n// PHP 코드\nfunction recursiveFunction($n) {\n    if ($n \u003c= 0) {\n        return;\n    }\n    recursiveFunction($n - 1);\n}\n\nrecursiveFunction(100000); // 큰 수로 재귀 호출\n\n```\n\n이 예제에서는 php.ini 구성 파일에서 zend.reserved_stack_size 지시문이 16 킬로바이트로 설정되어 있습니다. PHP 코드는 재귀 호출을 많이 수행하는 재귀 함수를 포함하고 있으며, 재귀 호출이 많아져 스택 오버플로 상황이 발생할 수 있습니다. zend.reserved_stack_size 지시문을 사용하면 PHP가 호출 스택이 오버플로우 직전에 있는지 감지하여 상황을 처리하고 오류를 throw하여 세그멘테이션 오류를 방지하며 디버깅을 용이하게 합니다.\n\nPHP 8.3의 \"스택 오버플로우 감지\" 기능은 개발자가 호출 스택 크기에 제한을 설정하고 잠재적인 스택 오버플로우 상황을 감지하는 수단을 제공하여 PHP 응용 프로그램의 안정성과 견고성을 향상시킵니다. 이 ini 지시문을 통해 PHP는 스택 오버플로우 상황에 대한 개선된 오류 처리를 제공하며 세그멘테이션 오류의 발생 가능성을 줄이고 더욱 효과적인 디버깅 과정을 용이하게 합니다.\n\n# 11. 불변 상수 가시성\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 invariant 키워드를 사용하여 클래스 상수를 선언하는 기능을 소개합니다. 이를 통해 클래스의 상수의 가시성이 하위 클래스에서 확장되더라도 불변으로 유지될 수 있습니다. 이 향상된 기능은 클래스 상수를 정의하는 더 명시적이고 제어된 방법을 제공하며, 상속 계층 구조에서 상수의 가시성을 유지할 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass ParentClass {\n    public invariant int MAX_VALUE = 100;\n}\n\nclass ChildClass extends ParentClass {\n    // MAX_VALUE의 가시성을 변경하려고 시도하면 컴파일 오류가 발생합니다\n    protected invariant int MAX_VALUE = 200;\n}\n```\n\n이 예에서 ParentClass는 public invariant 상수인 MAX_VALUE를 값 100으로 선언합니다. ChildClass는 MAX_VALUE의 가시성을 protected로 변경하려고 시도하면 컴파일 오류가 발생하여 상속 계층 구조 전체에서 상수의 불변 가시성이 강제됩니다.\n\n인터페이스에서도 invariant 상수를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 Constants {\n    공개 불변의 문자열 VERSION = '1.0';\n}\n\n클래스 ImplementationClass는 Constants를 구현합니다 {\n    // VERSION의 가시성은 구현 클래스에서도 공개로 유지되어야 합니다\n    개인 불변의 문자열 VERSION = '2.0';\n}\n```\n\n이 예에서 Constants 인터페이스는 값이 ‘1.0’인 공개 불변 상수 VERSION을 선언합니다. ImplementationClass가 VERSION의 가시성을 개인으로 변경하려고 하면 컴파일 오류가 발생하여 상수의 가시성이 인터페이스에서 지정한 대로 불변으로 유지되도록 합니다.\n\nPHP 8.3의 “불변 상수 가시성” 기능은 클래스 상수를 정의하는 더 견고하고 명시적인 방법을 제공하여 상수의 가시성이 상속 계층 구조나 인터페이스 구현에서 일관되게 유지되도록 보장합니다. 이 개선은 코드의 유지 보수성을 높이고 상수의 가시성에 의도하지 않은 변경이 발생할 가능성을 줄여 PHP 코드베이스의 전체 신뢰성과 예측 가능성을 향상시킵니다.\n\n# 12. Assert String Eval Cleanup\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 문자열 평가 코드 어설션의 폐기를 포함하며, 더 안전하고 유지보수가 용이한 코딩 관행을 장려합니다. 이 개선은 문자열 평가 코드를 통한 어설션 사용을 억제하여 보안 취약점 및 코드 유지 관리 도전에 대응합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nassert('is_numeric($value)');\n```\n\n이 예에서는 assert 함수가 $value가 숫자인지 확인하기 위해 문자열 평가 코드 어설션과 함께 사용됩니다. 그러나 이 방식은 보안 위험에 노출되어 있으며 PHP 8.3에서는 폐기됩니다.\n\n여기서는 직접 표현식을 사용한 어설션의 업데이트된 버전을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nassert(is_numeric($value));\n```\n\nPHP 8.3에서는 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하는 것이 권장됩니다. 단언문 내에서 is_numeric 함수를 직접 호출함으로써 코드를 더 안전하고 유지보수하기 쉽게 만들 수 있습니다.\n\nPHP 8.3의 \"Assert String Eval Cleanup\" 기능은 개발자들이 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하도록 전환하도록 권장하며, 더 안전하고 신뢰할 수 있는 코딩 관행을 촉진합니다. 이 접근 방식을 deprecated 처리함으로써 PHP는 코드 보안과 유지보수성을 향상시키고, PHP 애플리케이션의 전체적인 견고성에 기여하고 있습니다.\n\n# 13. 향상된 FFI\\CData:void\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 FFI (외부 함수 인터페이스) 확장 기능을 향상시켜 C 함수가 void 반환 유형을 가질 때 PHP에서 FFI\\CData`void` 인스턴스를 반환하는 대신 null로 표시할 수 있도록 합니다. 이 개선을 통해 값을 반환하지 않는 C 함수를 처리하기가 더 간편해지며, PHP에서 예상하는 null 반환 유형과 일치시킵니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// C 코드\nvoid myFunction() {\n    // 함수 구현\n}\n\n// PHP FFI\n$ffi = FFI::cdef(\"\n    void myFunction();\n\", \"mylib.so\");\n\n$ffi-\u003emyFunction(); // C 함수 호출\n```\n\n이 예제에서 C 함수 myFunction은 void 반환 유형을 가지고 있습니다. PHP 8.3에서 FFI를 사용하여이 함수를 호출할 때 반환 값은 FFI\\CData`void` 인스턴스가 아닌 null이 됩니다. void를 반환하는 C 함수를 처리하기가 간단해집니다.\n\n다음과 같이 반환 유형을 확인할 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$result = $ffi-\u003emyFunction();\n\nif ($result === null) {\n    echo \"함수가 성공적으로 실행되고 null을 반환했습니다.\";\n} else {\n    echo \"예기치 않은 반환 값입니다.\";\n}\n```\n\n이 예제에서는 C 함수 myFunction의 반환 값을 확인합니다. 반환 값이 null이면 함수가 성공적으로 실행되고 값을 반환하지 않았음을 나타내며, void를 반환하는 함수에 대한 예상 동작과 일치합니다.\n\nPHP 8.3의 \"Improved FFI\\CData:void\" 기능은 PHP에서 void를 반환하는 C 함수를 간소화하여 FFI를 통한 이러한 함수와의 상호 작용을 단순화합니다. PHP에서 이러한 함수를 null로 표현할 수 있도록 함으로써, 이 향상은 값을 반환하지 않는 C 함수를 다룰 때 더 직관적이고 일관된 FFI 경험에 기여합니다.\n\n# 14. posix_getrlimit() 매개변수 향상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 posix_getrlimit() 함수에 개선 사항을 소개합니다. 선택적 매개변수를 전달하여 단일 리소스 제한을 가져올 수 있도록 허용합니다. 이 향상된 기능은 특정 리소스에 대한 자원 제한을 검색할 때 더 큰 유연성과 정밀도를 제공함으로써 PHP 애플리케이션 내에서 자원 한도에 대한 자세한 정보를 획득하는 프로세스를 간소화합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// 최대 열린 파일 수에 대한 소프트 제한 가져오기\n$softLimit = posix_getrlimit(posix_RLIMIT_NOFILE, POSIX_RLIMIT_SOFT);\necho \"최대 열린 파일 수에 대한 소프트 제한: \" . $softLimit . \"\\n\";\n```\n\n이 예제에서 posix_getrlimit() 함수는 최대 열린 파일 수에 대한 소프트 제한을 가져오는 데 사용됩니다. 선택적 매개변수 POSIX_RLIMIT_SOFT를 사용하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용에 대한 자세한 정보를 제공합니다.\n\n심지어 CPU 시간에 대한 하드 제한도 가져올 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// CPU 시간의 하드 제한을 가져오는 중\n$hardLimit = posix_getrlimit(posix_RLIMIT_CPU, POSIX_RLIMIT_HARD);\necho \"CPU 시간의 하드 제한: \" . $hardLimit . \"\\n\";\n```\n\n이 예제에서는 posix_getrlimit() 함수를 사용하여 CPU 시간의 하드 제한을 얻는 방법을 보여줍니다. 선택적 매개변수로 POSIX_RLIMIT_HARD를 지정하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용 세부 정보에 정확하게 액세스할 수 있도록 합니다.\n\nPHP 8.3의 \"posix_getrlimit() 매개변수 개선\"은 개발자가 개별 리소스 제한을 쉽게 가져올 수 있는 능력을 부여합니다. 개별 리소스 제한을 가져오는 접근 방식을 제공하여 리소스 사용 정보를 더 세부적으로 확인할 수 있도록 합니다. 이 개선은 리소스 제한과 관련된 더 세밀하고 유연한 작업을 향상시키며, PHP 애플리케이션 내에서 유효한 리소스 관리에 필수적인 세부 리소스 제한 정보를 제공합니다.\n\n# 15. gc_status() 개선내용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngc_status() 함수가 개선되어 PHP 애플리케이션 내에서 메모리 관리 및 가비지 수집에 대한 상세 정보를 제공하는 총 여덟 가지 새로운 필드가 도입되었습니다. 이러한 필드는 실제 가비지 수집이 실행 중인지, 메모리 블록이 가비지 수집으로부터 보호되는지, 가득찬 가비지 수집 주기가 진행 중인지 등 다양한 측면에 대한 세부 정보를 제공합니다.\n새로운 필드 목록은 다음과 같습니다:\n\n- \"running\" =` bool: 현재 가비지 수집이 실행 중인지를 나타냅니다.\n- \"protected\" =` bool: 메모리 블록이 가비지 수집으로부터 보호되는지를 나타냅니다.\n- \"full\" =` bool: 완전한 가비지 수집 주기가 진행 중인지를 나타냅니다.\n- \"buffer_size\" =` int: 가비지 수집을 위한 버퍼 크기를 바이트 단위로 지정합니다.\n- \"application_time\" =` float: 가비지 수집 주기를 포함한 총 응용 프로그램 실행 시간을 나타냅니다.\n- \"collector_time\" =` float: 소멸자의 실행 및 값의 해제를 포함하여 수집 주기에 소요된 시간을 반영합니다.\n- \"destructor_time\" =` float: 수집 주기 동안 소멸자를 실행하는 데 사용된 시간을 나타냅니다.\n- \"free_time\" =` float: 수집 주기 동안 값들을 해제하는 데 사용된 시간을 나타냅니다.\n\n이러한 필드에 접근하여 개발자들은 가비지 수집 상태, 메모리 보호, 수집 주기 시간, 리소스 활용 등에 대한 가치 있는 통찰을 얻을 수 있습니다. 이러한 상세 정보는 개발자들이 메모리에 관련된 결정을 내릴 때 인포메이션을 바탕으로 신중한 판단을 할 수 있도록 돕습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 16. 내부 클래스에 대한 class_alias() 지원\n\n이 기능은 class_alias() 함수의 기능을 확장하여 내부 PHP 클래스에 대한 별칭을 생성할 수 있도록 지원합니다. 이 향상된 기능은 내부 클래스를 다룰 때 더 많은 유연성과 편의성을 제공하여, 기존 내부 클래스에 대한 대체 이름을 생성할 수 있게 해줍니다. 이를 통해 클래스 참조를 간단히 하고 코드 가독성을 높일 수 있습니다. 아래 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass_alias('DateTime', 'MyDateTime');\n```\n\n이 예시에서는 class_alias() 함수를 사용하여 내부 PHP 클래스 DateTime에 대한 별칭 MyDateTime을 생성합니다. 이를 통해 개발자는 코드베이스 전반에서 MyDateTime이라는 별칭을 사용하여 DateTime 클래스에 참조할 수 있게 되며, 해당 클래스에 대해 더 명확하고 맥락적인 이름을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내부 클래스 초기화를 위해 클래스 별칭을 사용할 수도 있어요.\n\n```js\n$date = new MyDateTime('2023-11-24');\necho $date-\u003eformat('Y-m-d');\n```\n\n이 예제에서 MyDateTime 별칭은 내부 클래스 DateTime의 객체를 생성하는 데 사용되었어요. 이 별칭은 클래스 인스턴스 생성에 더 직관적이고 의미 있는 이름을 제공하여 코드의 가독성과 유지 보수성을 높여줍니다.\n\nPHP 8.3의 \"내부 클래스에 대한 class_alias() 지원\" 기능은 내부 클래스에 별칭을 만드는 프로세스를 간소화하여 개발자들에게 내부 클래스에 대한 대체 이름을 정의할 수 있는 편리한 메커니즘을 제공합니다. 이 개선으로 PHP 애플리케이션 내에서 보다 명확하고 읽기 쉬운 클래스 참조를 제공하여 더 표현적이고 일관성 있는 코드베이스로의 기여가 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 17. mysqli_poll() 오류 처리\n\n이 기능은 오류 처리와 관련된 동작 변경을 소개합니다. 특히, mysqli_poll() 함수를 호출할 때 읽기 및 오류 인수를 제공하지 않으면 이제 ValueError가 발생합니다. 이 향상은 mysqli_poll() 함수가 적절한 인수를 사용하여 사용되며, 비동기적 MySQL 쿼리 실행과 관련된 시나리오에서 더 견고하고 예측 가능한 오류 처리를 촉진합니다. 이 동작을 설명하기 위해 예제를 살펴봅시다:\n\n```js\n$links = [...]; // MySQL 링크 배열\n$read = $error = $reject = [];\nif (mysqli_poll($links, $read, $error, $reject, $timeout)) {\n    // 결과 처리\n    foreach ($read as $link) {\n        // 성공한 쿼리 실행 처리\n    }\n    foreach ($error as $link) {\n        // 쿼리 실행 오류 처리\n    }\n    foreach ($reject as $link) {\n        // 거부된 연결 처리\n    }\n} else {\n    // 폴링 오류 처리\n}\n```\n\n이 예제에서 mysqli_poll() 함수는 $read, $error, $reject 배열을 포함한 올바른 인수와 함께 호출됩니다. 이 사용법은 PHP 8.3의 업데이트된 동작을 준수하며, 폴링 작업 결과를 처리하기 위해 필요한 인수로 함수가 호출되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nread나 error 인자가 전달되지 않을 때 ValueError를 발생시키는 PHP 8.3은 더 명시적이고 신뢰할 수 있는 오류 처리 방법을 장려하며, mysqli_poll() 호출에 필요한 모든 인자를 제공하도록 개발자들을 격려합니다. 이 개선으로 PHP 애플리케이션에서 비동기 MySQL 쿼리 실행의 전체적인 견고성과 예측 가능성이 향상됩니다.\n\n## array_pad() 기능 향상\n\n이 기능은 array_pad() 함수를 사용하여 한 번에 추가할 수 있는 요소 수에 대한 이전 제한을 제거합니다. 이 개선 이전에 배열을 패딩할 때 한 번에 최대 1048576개의 요소만 추가할 수 있었습니다.\n\n그러나 PHP 8.3에서 소개된 개선으로, array_pad() 함수는 이제 배열이 가질 수 있는 최대 요소 수만 제한으로 나타냅니다. 이를 통해 개발자들은 더 큰 유연성을 가지고 이전의 배열 패딩 작업을 통해 추가할 수 있는 요소 수에 대한 제약을 제거할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 향상은 배열을 훨씬 많은 요소로 채우는 것을 가능하게 하며, 기존 제한으로 인해 배열 크기가 제한되지 않고 다양한 크기의 배열을 다룰 수 있도록 합니다. 결과적으로, 개발자는 array_pad() 함수를 보다 효과적으로 활용하여 배열 조작과 동적 크기 조정이 필요한 시나리오에서 유연성과 확장성을 향상시키는데 기여하며, PHP 애플리케이션 내에서 배열 패딩 작업의 유연성과 확장성을 향상시킵니다.\n\n# 19. opcache.consistency_checks ini 지시문 제거\n\n이 기능은 이전에 OPCache에서 일관성 검사를 활성화 또는 비활성화하는 데 사용되었던 opcache.consistency_checks ini 지시문의 제거를 나타냅니다. 이러한 제거로 인해 opcache.consistency_checks 지시문을 관리할 필요가 없어지며, OPCache 설정 및 유지 관리 프로세스를 간소화하여 OPCache 구성을 단순화합니다. 이 변경이 OPCache 구성에 미치는 영향에 대한 예시는 다음과 같습니다:\n\n이전 OPCache 설정과 opcache.consistency_checks.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopcache.consistency_checks=1\n```\n\n이 예제에서는 opcache.consistency_checks 지시문을 1로 설정하여 OPCache의 일관성 검사를 활성화합니다.\n\nPHP 8.3에서 opcache.consistency_checks 지시문이 삭제되면 OPCache의 일관성 검사 구성이 더 이상 필요하지 않아져 OPCache 구성 프로세스가 간소화됩니다.\n\n이 변경은 OPCache 구성에 대한 단순화된 접근 방식을 반영하며, OPCache의 일관성 검사를 관리하는 복잡성을 줄이고 PHP 8.3에서 OPCache의 전체 효율성과 사용 편의성을 향상시키는 목표와 일치합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 20. number_format()을 사용하여 소수점 처리하는 방법\n\n이 함수는 $decimal 매개변수를 올바르게 처리하도록 개선되었습니다. 이제 $decimal에 음수 정수가 올바르게 처리됩니다. $decimal에 음수 값을 사용하여 반올림하면 $num이 소수점 이전의 지정된 유효 숫자 자릿수로 반올림됩니다. 이전에는 음수 $decimal이 무시되고 숫자가 소수점 이하 자릿수가 0으로 반올림되었습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n$num = 1234.56789;\n$formatted1 = number_format($num, 2); // 1,234.57\n$formatted2 = number_format($num, -2); // 1,200\n```\n\n이 예제에서 number_format() 함수는 음수 $decimal 값을 올바르게 처리하여 숫자를 지정된 유효 숫자 자릿수로 소수점 이전에 반올림합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 업그레이드는 number_format() 함수를 사용하여 숫자를 반올림할 때 더 일관성 있고 예측 가능한 동작을 보장하여 개발자들이 숫자 값의 형식을 더 잘 제어할 수 있도록 합니다.\n\n축하합니다! PHP 8.3에서 소개된 상위 20가지 기능과 개선 사항에 대해 학습을 완료했습니다. 이 최신 릴리스는 계속 변화하는 개발자들과 기업들의 요구에 부합하는 다양한 개선 사항을 제공하여 더 효율적이고 신뢰할 수 있으며 유지보수가 쉬운 코드를 작성할 수 있도록 지원합니다.","ogImage":{"url":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png"},"coverImage":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png","tag":["Tech"],"readingTime":23}],"page":"61","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"61"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>