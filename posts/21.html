<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/21" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/21" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="AWS에서 이력서를 Terraform으로 만들어보세요 I" href="/post/2024-05-15-GetyourResumeTerraformedinAWSI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에서 이력서를 Terraform으로 만들어보세요 I" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에서 이력서를 Terraform으로 만들어보세요 I" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">AWS에서 이력서를 Terraform으로 만들어보세요 I</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Harbor 시작하기 단계별 안내" href="/post/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Harbor 시작하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Harbor 시작하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Harbor 시작하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" href="/post/2024-05-15-NavigatingExposeandPublishinDockerContainers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">도커 컨테이너에서 노출Expose과 공개Publish 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" href="/post/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Terraform을 사용하여 VPC 피어링 자동화하기" href="/post/2024-05-15-AutomateVPCPeeringwithTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Terraform을 사용하여 VPC 피어링 자동화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Terraform을 사용하여 VPC 피어링 자동화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Terraform을 사용하여 VPC 피어링 자동화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="글로벌 게이머 챌린지의 수상자 발표" href="/post/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="글로벌 게이머 챌린지의 수상자 발표" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="글로벌 게이머 챌린지의 수상자 발표" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">글로벌 게이머 챌린지의 수상자 발표</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 브라우저가 웹사이트를 찾는 방법" href="/post/2024-05-15-HowYourBrowserFindsWebsites"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 브라우저가 웹사이트를 찾는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 브라우저가 웹사이트를 찾는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 브라우저가 웹사이트를 찾는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 기술 개척 KBTG GO 집중 워크샵 후기" href="/post/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 기술 개척 KBTG GO 집중 워크샵 후기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 기술 개척 KBTG GO 집중 워크샵 후기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 기술 개척 KBTG GO 집중 워크샵 후기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="물리적 디바이스를 Firebase Emulator에 연결하기" href="/post/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="물리적 디바이스를 Firebase Emulator에 연결하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="물리적 디바이스를 Firebase Emulator에 연결하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">물리적 디바이스를 Firebase Emulator에 연결하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 iOS 앱의 비밀을 보호하는 중요한 단계" href="/post/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 iOS 앱의 비밀을 보호하는 중요한 단계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 iOS 앱의 비밀을 보호하는 중요한 단계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">당신의 iOS 앱의 비밀을 보호하는 중요한 단계</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"AWS에서 이력서를 Terraform으로 만들어보세요 I","description":"","date":"2024-05-15 11:08","slug":"2024-05-15-GetyourResumeTerraformedinAWSI","content":"\n\n안녕하세요! 👋 여러분! 오랜만이죠. 여기에 유용한(아니면 흥미로운?) 기사 몇 개를 올리고 싶다고 생각한 지 오래되었습니다. 그런데 좋거나 유용한 아이디어가 생각나지 않았어요. 몇 주 전 나를 위해 한 작업을 문서화하는 아이디어를 만났는데요: 이력서의 HTML 버전을 AWS에 Terraform과 GitHub Actions을 통해 배포(자동화)하는 것입니다. 요즘에는 이런 기술을 이력서에 넣는 것이 흥미로울 것 같아요. 근데 이력서 안에 그런 기술을 보여주면 어때요? 😜\n\n이런 작업을 어떻게 하는지 보여주는 많은 비디오/튜토리얼은 AWS 콘솔에서 \"클릭 단계별\"로 진행하는 것을 보여줍니다. 그러나 저는 Terraform + GithubActions 방법을 소개할 거에요, 더 흥미로울 것 같다고 봅니다.\n\n이 글은 두 편 중 첫 번째 입니다. 여러분이 지역 (HTML 형식)으로 배포된 이력서를 AWS(S3)에 보관하고 https://antonirs.com 같은 URL을 통해 접근 가능하게 하는 방법을 단계별로 안내할 거에요. 그리고 또한 매 푸시마다 새 버전을 자동으로 배포하는 ⚙️GitHub Actions 파이프라인⚙️ 도 설정할 거에요. 이 자동화 부분은 이 첫 번째 글에서 다루지 않고 두 번째 글에서 다뤄요.\n\n이 글을 따라가는 동안 제 개인 이력서 저장소에서 모든 소스 코드를 확인할 수 있어요. 즐겨보세요!\n\n\n\n# 인프라 구조 이해하기\n\n![이미지](/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png)\n\n우리가 구축할 내용을 크게 보여드립니다. 첫 번째 기사에서 Terraform을 사용하여 컴포넌트를 구축하고 연결하며 함께 작동시키는 방법을 안내해 드리겠습니다. 아키텍처는 전혀 복잡하지 않으므로, 모두 구축하기 위해 AWS의 \"단지\" 4가지 서비스를 사용할 예정입니다.\n\n# 이전 요구 사항\n\n\n\n일할 때 필요한 몇 가지가 있습니다:\n1. AWS 계정. 꽤 명백한 🤷🏼‍♂️ 당연하지만 필수입니다. AWS는 이 문서에서 한 단계씩 안내하여 계정을 설정하는 방법을 제공합니다.\n2. Terraform CLI 설치. 터미널에 terraform CLI가 설치되어 있어야 합니다. Hashicorp에서 설치 방법을 안내합니다.\n3. 등록된 도메인. 이 문서에서는 구매 및 AWS에서 처리된 도메인을 가지고 있다고 가정하지만, 반드시 그렇게 할 필요는 없습니다.\n4. 이력서의 HTML 버전. S3 버킷에 저장되고 CloudFront를 통해 제공될 것입니다.\n\n# 일하러 가볼까요 💪🏻\n\n저의 저장소에서 완전한 작동 솔루션을 제공받을 수 있기 때문에 👀, 단계별로 자세히 설명하지는 않겠지만 각 부분의 가장 중요한 요소에 대해 주석을 달겠습니다.\n\n## 단계 0: 도메인 구매 및 호스팅 존 생성\n\n\n\n도메인 (나의 경우에는 antonirs.com)의 구매와 호스팅 영역 생성은 Terraform으로 만들지 못하는 유일한 부분이며, 대신 AWS 콘솔에서 수동으로 처리해야 합니다.\n\n다른 제공업체에 도메인을 호스팅할 수도 있습니다. 이 경우 추가 구성이 필요할 수 있지만 (그 외에는 문제가 없습니다), 이 경우에는 AWS에서 호스팅되는 경우를 다루겠습니다.\n\n## 단계 1: Terraform으로 시작하기. AWS 제공자 설정\n\nTerraform 프로젝트의 시작점은 일반적으로 AWS 제공자 및 사용할 백엔드 구성을 설정하는 것입니다. 이를 통해 Terraform에게 AWS와의 인증 방법, 리소스를 배포할 지역 및 인프라의 tfstate를 저장할 위치를 알려줍니다. 이 구성을 provider.tf 파일에 넣어주세요.\n\n\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n  access_key = \"내 액세스 키\"\n  secret_key = \"내 시크릿 액세스 키\"\n}\n```\n\n액세스 키와 시크릿 키는 절대로 리포지토리에 푸시해서는 안 되는 것을 염두에 두세요. 여기서 보여주고 있지만, 다음 글에서 깃허브 리포지토리의 시크릿 구성으로 이동하는 방법을 보여줄 것입니다.\n\n백엔드.tf에 대해 다음과 같이 보이도록 해야 합니다. 우리는 인프라의 상태를 저장하기 위해 S3를 사용할 것입니다:\n\n```js\nterraform {\n  backend \"s3\" {\n    bucket         = \"antoni-tf-state\"\n    key            = \"personal-portfolio/terraform.tfstate\"\n    region         = \"us-east-1\"\n    encrypt        = true\n  }\n}\n```\n\n\n\n## Step 2: S3 및 액세스 정책 생성\n\n여기서는 antoni-html-cv라는 S3 버킷을 생성하고, 여기서 중요한 부분은 우리가 정의하는 정책인 s3_policy입니다. Cloudfront에서 오는 요청을 제외하고 모든 수신 트래픽을 차단할 것입니다 ⛔.\n\n```js\nresource \"aws_s3_bucket\" \"personal_portfolio_bucket\" {\n  bucket = \"antoni-html-cv\"\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_iam_policy_document\" \"s3_policy\" {\n  statement {\n    sid       = \"AllowCloudFrontServicePrincipal\"\n    effect    = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"cloudfront.amazonaws.com\"]\n    }\n    actions   = [\"s3:GetObject\"]\n    resources = [\"${aws_s3_bucket.personal_portfolio_bucket.arn}/*\"]\n    condition {\n      test     = \"StringEquals\"\n      variable = \"AWS:SourceArn\"\n      values   = [\"arn:aws:cloudfront::${data.aws_caller_identity.current.account_id}:distribution/${aws_cloudfront_distribution.portfolio_distribution.id}\"]\n    }\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"s3_policy\" {\n  bucket = aws_s3_bucket.personal_portfolio_bucket.id\n  policy = data.aws_iam_policy_document.s3_policy.json\n}\n```\n\n여기서 중요한 점은 정책을 통해 S3에 직접 액세스하는 것을 방지하고 Cloudfront가 내용을 가져오는 것을 허용한다는 것입니다 (고객에게 서비스하기 위해). 이를 수행하는 다른 방법도 있지만, 저는 현재 AWS가 가장 권장하는 Origin Access Control 접근 방식을 사용하기로 결정했습니다. OAC에 대한 자세한 정보는 [여기](링크)에서 확인할 수 있습니다.\n\n\n\n## 단계 3: SSL 인증서로 CloudFront 배포 설정하기\n\nCloudFront는 S3에서 정적 콘텐츠를 제공하는 데 사용할 AWS 서비스입니다. CloudFront는 CDN으로 작동하여 전 세계의 여러 위치(엣지 위치)에 콘텐츠를 캐시하여 더 빠르게 액세스할 수 있게 합니다. 또한, CloudFront를 사용하면 배포에 SSL/TLS 인증서를 첨부하여 웹 사이트 연결을 HTTPS로 강제할 수 있습니다.\n\n```js\nresource \"aws_cloudfront_origin_access_control\" \"portfolio_oac\" {\n  name        = \"OAC for Portfolio Website\"\n  description = \"OAC for antonirs portfolio website\"\n  origin_access_control_origin_type = \"s3\"\n\n  signing_behavior = \"always\"\n  signing_protocol = \"sigv4\"\n}\n\nresource \"aws_cloudfront_distribution\" \"portfolio_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.personal_portfolio_bucket.bucket_regional_domain_name\n    origin_id   = \"S3-antonirs-portfolio\"\n    origin_access_control_id = aws_cloudfront_origin_access_control.portfolio_oac.id\n  }\n\n  enabled = true\n  comment = \"Distribution for the antonirs.com static website\"\n  aliases = [\"antonirs.com\"]\n  default_root_object = \"index.html\"\n\n  default_cache_behavior {\n    allowed_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n\n    target_origin_id = \"S3-antonirs-portfolio\"\n\n    forwarded_values {\n      query_string = false\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"redirect-to-https\"\n    min_ttl                = 0\n    default_ttl            = 86400\n    max_ttl                = 31536000\n  }\n\n  viewer_certificate {\n    acm_certificate_arn = aws_acm_certificate.personal_web_portfolio_cert.arn\n    ssl_support_method  = \"sni-only\"\n    minimum_protocol_version = \"TLSv1.2_2021\"\n  }\n\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n  }\n\n  tags = {\n    Environment = \"production\"\n  }\n}\n```\n\n여기에는 많은 구성이 포함되어 있지만 주요 부분은 다음과 같습니다:\n-` 우리는 origin을 정의하여 CloudFront에게 데이터를 어디서 가져와야 하는지 알려줍니다(S3에서 가져옵니다).\n-` viewer_certificate 섹션을 사용하여 사용자 브라우저와 CloudFront 간의 안전한 연결(HTTPS)을 설정하는 SSL 인증서를 설정합니다.\n인증서를 생성하는 관련 명령에 대한 자세한 내용은 acm.tf에서 구성을 확인할 수 있습니다.```\n\n\n\n```js\nresource \"aws_acm_certificate\" \"personal_web_portfolio_cert\" {\n  domain_name       = \"antonirs.com\"\n  validation_method = \"DNS\"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_route53_record\" \"cert_validation\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.zone_id\n  name    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_name\n  type    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_type\n  records = [tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_value]\n  ttl     = 60\n}\n\nresource \"aws_acm_certificate_validation\" \"cert_validation\" {\n  certificate_arn         = aws_acm_certificate.personal_web_portfolio_cert.arn\n  validation_record_fqdns = [aws_route53_record.cert_validation.fqdn]\n}\n```\n\n인증서 구성 중 중요한 부분은 aws_acm_certificate_validation 섹션입니다. 이 인증서를 antonirs.com에 접속할 수 있게 하기 위해 Route53에 대해 이 인증서를 검증해야 합니다.\n\n## 단계 4: Route 53 설정\n\n인프라스트럭처에서말했던 것처럼 DNS 관리를 위해 Route 53을 사용할 것입니다. 글의 시작에서 말했듯이 이미 도메인(나의 경우엔 antonirs.com)과 AWS에 생성된 호스팅존이 있습니다. 다음 구성(route53.tf)을 따라 호스팅존 내에 A 레코드를 작성하고, CloudFront 배포로 가리키는 별칭으로 설정합니다.\n \n\n\n\n```js\ndata \"aws_route53_zone\" \"my_personal_zone\" {\n  name = \"antonirs.com.\"\n}\n\nresource \"aws_route53_record\" \"www\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.id\n  name    = \"antonirs.com\"\n  type    = \"A\"\n\n  alias {\n    name                   = aws_cloudfront_distribution.portfolio_distribution.domain_name\n    zone_id                = aws_cloudfront_distribution.portfolio_distribution.hosted_zone_id\n    evaluate_target_health = false\n  }\n}\n```\n\n## 단계 5: 모든 것이 작동하는 것을 확인\n\n지금까지 본 것으로 충분히 준비되었습니다. 이제 \"한 번의 클릭\"으로 모든 인프라를 구축하여 https://antonirs.com (제 경우)을 방문하여 이력서를 확인할 수 있습니다.\n\n좋아요, 이중 따옴표를 조금 풀어볼게요. 모든 테라폼 파일이 준비된 상태에서 이제 해야 할 일은 터미널을 열고 다음을 실행하는 것입니다:\n1. terraform init 이 명령어를 실행하면 의존성을 다운로드하고 간단히 말해서 AWS와 상호 작용할 수 있는 디렉토리를 초기화합니다.\n2. terraform plan 이 명령어를 실행하면 실제 인프라에 반영되지 않은 tf 파일에 있는 모든 변경 사항을 출력합니다.\n3. terraform apply 이 명령어를 실행하면 인프라에서 실제 변경 사항을 만듭니다. Terraform 파일에 구성된 모든 리소스를 생성합니다.\n4. 이력서의 HTML 버전을 생성한 버킷에 업로드합니다.\n5. 방문(제 경우) https://antonirs.com 그리고... 즐기세요 😜 🚀\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_1.png\" /\u003e\n\n# 마무리 및 다음 단계\n\n와우! 여기까지 모두 읽은 것을 보니 매우 기뻐요🎊! 하하. 하지만 기쁨은 여기까지가 아닙니다. 다음 기사에서 더 흥미로워집니다. 조금 스포하겠습니다:\n\n이전의 \"단계 5\"를 보면 인프라를 배포하기 위해 \"상당히 많은\" 명령을 실행해야 한다는 것 같죠? 그런데 만약 웹사이트에 이력서의 새 버전을 업로드하려면 어떨까요? 새 버전을 업로드하려면 AWS 콘솔에 로그인해야 합니다 (또는 aws-cli를 사용해야 합니다)... 어찌 보면 그렇게 편리하지 않을 거예요.\n\n\n\n다음 기사에서는 GitHub Actions에서 모든 이러한 단계를 자동화하는 방법을 보여 드릴 것이기 때문에 기대해 주세요. 다음 기사에서는 또한 파이프라인에 우리의 비용을 제어하기 위한 💰infracost💰 통합에 관한 '보너스' 섹션을 공유할 예정이에요. 자세한 내용을 더 다루겠지만, 이는 우리 인프라 비용을 관리하는 데 매우 유용한 도구입니다. 계속 지켜보세요! 😉","ogImage":{"url":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png"},"coverImage":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png","tag":["Tech"],"readingTime":9},{"title":"Harbor 시작하기 단계별 안내","description":"","date":"2024-05-15 11:06","slug":"2024-05-15-GettingStartedwithHarborAStep-by-StepGuide","content":"\n\nHarbor는 DockerHub, ECR 또는 ACR에 의존하지 않고 컨테이너 이미지를 안전하게 저장하고 관리하는 데 도움이 되는 오픈 소스 레지스트리입니다. Docker의 오픈 소스 레지스트리 위에 보안, 식별 및 관리 기능을 추가합니다. Harbor를 사용하면 이미지에 대한 정책을 설정하고 취약점을 검사하여 역할 기반 제어를 통해 액세스를 관리할 수 있습니다. 이는 컨테이너 이미지를 안전하고 잘 관리된 상태로 유지하려는 개발자들에게 필수적인 도구입니다.\n\n![Harbor 시작하기: 진행하기 전에](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png)\n\n## 전제 조건\n\n- Chocolatey 설치하기:\n\n\n\n- 관리자 권한으로 PowerShell 터미널을 열고 다음을 실행해주세요:\n\n```js\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n2. Chocolatey를 통해 Rancher Desktop을 설치하려면 다음 명령을 실행하세요:\n\n\n\n```js\nchoco install rancher-desktop\n```\n\n# 설정\n\n- 프로젝트 디렉토리를 생성하고 이동하세요:\n\n```js\nmkdir LearningHarbor cd LearningHarbor\n```\n\n\n\n2. Harbor Helm 저장소를 추가하고 Harbor 차트를 가져옵니다:\n\n```js\nhelm repo add harbor https://helm.goharbor.io\nhelm fetch harbor/harbor --untar cd harbor\n```\n\n3. values.yaml 파일을 편집합니다:\n\n- externalUrl 설정\n\n\n\n```js\nexternalURL: https://core.harbor.localhost\n```\n\n![Getting Started with Harbor: A Step-by-Step Guide](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_1.png)\n\n3. 윈도우 호스트 파일 수정:\n\n- 관리자 권한으로 텍스트 편집기에서 c:\\Windows\\System32\\Drivers\\etc\\hosts 파일을 엽니다.\n- 다음 줄을 추가하세요:```\n\n\n\n```js\n127.0.0.1 core.harbor.localhost\n```\n\n![Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_2.png)\n\n# Harbor 배포\n\n- Harbor Helm 차트 설치:\n\n\n\n```js\nhelm upgrade harbor-release . --namespace harbor-helm --create-namespace --wait --install\n```\n\n2. 배포가 완료될 때까지 기다린 후 다음으로 이동하세요:\n\n- https://core.harbor.localhost\n\n![Getting Started with Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_3.png)\n\n\n\n3. 기본 자격 증명을 사용하여 로그인하세요:\n\n- 사용자명: admin\n- 비밀번호: Harbor12345\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_4.png)\n\n# 추가 구성\n\n\n\n- Docker를 사용하여 Harbor 레지스트리에 로그인하세요:\n\n```js\ndocker login https://core.harbor.localhost\n```\n\n동일한 자격 증명을 사용하세요:\n\n- 사용자 이름: admin\n- 비밀번호: Harbor12345\n\n\n\n# Harbor로 이미지 푸시하기\n\n참고: 사용할 로케이션 이미지인 aspiresample/api 및 aspiresample/web이 있습니다. 제 이미지 이름을 교체해도 괜찮습니다.\n\n- 이미지에 태그 붙이기\n\n```js\ndocker tag aspiresample/apiservice core.harbor.localhost/library/apiservice:latest\n```\n\n\n\n2. 이미지를 푸시하세요\n\n```js\ndocker push core.harbor.localhost/library/apiservice:latest\n```\n\n이제 Harbor UI에서 다음을 볼 수 있습니다\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_5.png)\n\n\n\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_6.png)\n\n# 고급 기능\n\nHarbor에는 기능을 향상시키는 몇 가지 고급 기능이 있습니다. 저는 이에 대해 자세히 다루지 않을 것입니다:\n\n- 외부 저장소 연결:\n\n\n\n\n- Harbor에 외부 저장소를 링크하고 정기적으로 해당 저장소에서 이미지를 복제하여 Harbor 레지스트리를 항상 최신 상태로 유지할 수 있습니다.\n\n![Step 7](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_7.png)\n\n![Step 8](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_8.png)\n\n2. 외부 인증:\n\n\n\n- Harbor은 Keycloak와 같은 외부 OIDC 서버와의 통합을 지원하여 사용자 관리와 싱글 사인온 기능을 제공합니다.\n\n![사진](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_9.png)\n\n3. 할당량 설정:\n\n- 관리자는 프로젝트 및 저장소에 할당량을 설정하여 저장 공간 소비를 관리하고 조직 전체에서 적절하게 자원을 할당할 수 있습니다.\n\n\n\n# 마무리\n\n해법은 컨테이너 이미지를 관리하고 보호하는 강력한 솔루션을 제공합니다. 본 안내서에 나와 있는 단계에 따라 진행하면 신속하게 Harbor를 배포하여 이미지를 안전한 관리 환경에 저장할 수 있습니다. Harbor의 고급 기능인 외부 저장소 연결, 인증을 위해 Keycloak과 같은 OIDC 서버와 통합, 스토리지 할당량 설정 등은 그 유틸리티를 더욱 향상시킵니다. 이러한 기능들은 Harbor를 보안이며 효율적인 컨테이너 이미지 레지스트리를 유지하려는 개발자와 조직에 꼭 필요한 도구로 만듭니다.","ogImage":{"url":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"도커 컨테이너에서 노출Expose과 공개Publish 이해하기","description":"","date":"2024-05-15 11:05","slug":"2024-05-15-NavigatingExposeandPublishinDockerContainers","content":"\n\n\n![2024-05-15-NavigatingExposeandPublishinDockerContainers_0](/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png)\n\n도커는 응용 프로그램을 배포하는 방법을 혁신적으로 바꿨습니다. 소프트웨어를 컨테이너화하는 데 가벼우면서도 효율적이며 휴대 가능한 솔루션을 제공합니다. Docker 컨테이너에서 노출(expose)하고 게시(publish)하는 내용을 이해하는 것은 컨테이너와 호스트 시스템 간의 네트워크 통신을 효과적으로 관리하는 데 중요합니다.\n\nDocker Expose이란 무엇인가요?\n\nDockerfile에서 EXPOSE 지시문은 컨테이너가 실행 중에 어떤 네트워크 포트에서 수신 대기하는지 Docker에 알려줍니다.\n\n\n\n\n하지만 Docker 호스트 외부에서 컨테이너에 직접 액세스하거나 해당 포트를 호스트 시스템에 공개하지는 않습니다. 대신, 들어오는 연결을 수신하기 위해 컨테이너가 설정된 포트를 나열하는 메모 역할을 합니다.\n\n예를 들어, Dockefile에 EXPOSE 80를 포함하면, 컨테이너화된 응용프로그램이 80포트에서 들어오는 연결을 기다리는 것을 나타냅니다.\n\n이 정보는 컨테이너화된 응용프로그램의 네트워킹 요구사항을 이해하려는 개발자나 관리자에게 유용합니다.\n\n도커 Publish가 무엇인가요?\n\n\n\n한편, docker run 명령에 -p 또는 — publish 플래그를 사용하면 컨테이너에서 호스트 시스템으로 포트를 공개하여 외부 세계에서 액세스할 수 있습니다.\n\n-p 플래그를 사용하여 포트를 공개하면, Docker는 호스트 시스템의 포트와 컨테이너의 포트 사이에 매핑을 작성합니다.\n\n예를 들어, docker run -p 8080:80 `이미지 이름`을 실행하면 컨테이너에서 호스트 시스템의 포트 80을 포트 8080에 공개합니다. 따라서 호스트의 포트 8080으로 전달된 모든 트래픽은 컨테이너의 포트 80으로 라우팅됩니다.\n\n예시 및 사용 사례:\n\n\n\n웹 응용 프로그램이 도커 컨테이너에서 실행되고 포트 80에서 수신하는 시나리오를 생각해보세요. Dockerfile에 EXPOSE 지시문을 사용하여이 포트를 노출하려면 다음 줄을 추가하면 됩니다:\n\n```js\nEXPOSE 80\n```\n\n이를 통해 Docker에게 컨테이너화된 웹 응용 프로그램이 포트 80에서 수신한다는 것을 알립니다.\n\n이제 docker run 명령을 사용하여 컨테이너를 실행할 때 호스트 시스템의 포트 80에 해당하는 포트에 80포트를 게시할 수 있습니다. -p 플래그를 사용하면 됩니다:\n\n\n\n```js\n# 도커 실행 -p 8080:80 \u003c이미지 이름\u003e\n```\n\n이 명령은 컨테이너 내의 80포트를 호스트 시스템의 8080포트로 매핑하여 웹 애플리케이션에 외부 액세스할 수 있게 합니다.\n\n아래 명령은 지정된 이미지를 기반으로 컨테이너를 백그라운드 모드에서 시작하고 -- publish-all 옵션을 사용하여 모든 노출된 포트를 호스트 시스템의 랜덤 포트로 게시합니다.\n\n예를 들어, Dockerfile에 80포트와 443포트에 대한 EXPOSE 지시가 포함되어 있다면, 아래 명령을 실행하면 자동으로 컨테이너의 80포트와 443포트가 호스트 시스템의 랜덤 포트에 매핑됩니다.\n\n\n\n```js\n# 도커 실행 -d — 모두 공개 \u003c이미지 이름\u003e\n```\n\n주요 차이점 :\n\n노출 :\n\n공개 :\n  \n\n\n\nBest Practices:\n\n- Dockerfile에서 EXPOSE를 사용하여 컨테이너가 수신 대기 중인 포트를 문서화하세요.\n- 필요할 때 컨테이너 포트를 호스트 시스템에 공개하기 위해 docker run -p를 사용하세요.\n- 보안 상의 영향을 염두에 두고 외부 액세스에 필요한 포트만 노출하세요.\n- 컨테이너 간 통신을 위해 네트워크 및 서비스 검색과 같은 Docker 네트워킹 기능을 탐색하세요.\n\n결론:\n요약하자면, \"노출\"과 \"공개\"는 Docker 컨테이너 네트워킹에서 중요한 개념입니다.\nEXPOSE를 통해 컨테이너 포트를 문서화하고, docker run -p를 통해 컨테이너 포트를 호스트 시스템에 노출하여 외부 액세스를 가능하게 합니다.\n\n이러한 개념을 효과적으로 이해하고 적용함으로써, 개발자와 시스템 관리자는 Docker 컨테이너에서 네트워크 통신을 능숙하게 관리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png"},"coverImage":"/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사","description":"","date":"2024-05-15 11:02","slug":"2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing","content":"\n\n아래와 같이 Markdown 형식으로 표 태그를 변경해주세요.\n\n\n| Tag | Description |\n| --- | ----------- |\n| `\u003chtml\u003e` | Defines an HTML document |\n| `\u003cbody\u003e` | Defines the body of the HTML document |\n| `\u003ch1\u003e` | Defines a large heading |\n\n\n\n\n워크스페이스 관리자로서, 사용자들에게 원활하고 성능이 우수한 데이터브릭 경험을 제공하는 것이 중요합니다. 동시에 데이터 접근 권한에서 최소 권한 원칙을 따르지 않는 위험한 행동을 방지해야 합니다. 데이터브릭 API, 시스템 테이블 및 데이터브릭 SQL (DBSQL)의 강력함으로 워크스페이스 관리자와 데이터 관리자는 데이터브릭 플랫폼에서의 사용 사항 거의 모든 측면을 추적할 수 있습니다. 이 블로그에서는 워크스페이스 관리자가 데이터 창고 성능을 모니터링하고 데이터 접근 권한이 높고 과도하게 허용되는 것을 모니터링하기 위한 알람을 설정하는 방법을 살펴보겠습니다.\n\n# 사례 1 — 컴퓨팅 성능 모니터링\n\n데이터브릭 SQL 웨어하우스에서는 시스템을 가로 및 세로로 확장할 수 있습니다. 우리는 티셔츠 사이즈(x-small, small, medium 등)를 통해 세로로 확장하여 주어진 쿼리에 대해 CPU 및 메모리를 추가할 수 있습니다. 또한 웨어하우스는 웨어하우스에 더 많은 클러스터를 추가함으로써 가로로 확장됩니다. 이는 웨어하우스 생성자가 오토스케일링을 활성화한 경우 자동으로 발생합니다. 그러나 웨어하우스 구성의 티셔츠 사이즈와 오토스케일링 범위(웨어하우스의 최소 및 최대 클러스터 수)를 이해하는 것은 종종 시범 및 오류 연습일 수 있습니다. 특히 웨어하우스의 사용이 쿼리 복잡성, 쿼리된 테이블 크기 또는 동시 사용자 수의 변화로 인해 시간이 지남에 따라 변하는 경우, 성능 메트릭에 대한 경고는 웨어하우스 생성자가 구성을 조정해 사용자에게 더 나은 쿼리 성능을 제공할 시기를 이해하도록 도와줄 수 있습니다.\n\n이 첫 번째 연습에서는 쿼리 기록 API(공식 시스템 테이블 —  비공개 미리보기 예정)을 활용하여 큰 수의 쿼리가 대기 중인 경우나 쿼리가 디스크로 데이터를 쓰는 경우에 웨어하우스 관리자에게 알림을 보낼 수 있는 테이블을 만들 것입니다.\n\n\n\n쿼리 기록 데이터를 수집하는 파이프라인 설정하기\n\n저희의 웨어하우스 사용량 및 크기에 기반한 알림을 설정하기 위해 먼저 쿼리 기록 API를 수집할 파이프라인을 생성해야 합니다 (참고: 이 플랫폼에 곧 도입될 쿼리 기록 시스템 테이블이 있습니다. 이 테이블을 통해 API를 사용하지 않고도 이 정보를 얻을 수 있을 것입니다. 현재 개인 미리보기 상태입니다). 이 API에는 워크스페이스 내에서 실행된 모든 쿼리에 대한 데이터가 포함되어 있습니다. 웨어하우스 ID나 사용자 ID와 같은 기본 정보부터 쿼리 프로파일러 UI에서 찾을 수 있는 성능 지표까지 포함됩니다(API를 호출할 때 \"include_metrics\" 플래그를 True로 설정하여 이러한 메트릭이 반환되도록 해야 합니다). Databricks Python SDK를 사용하여 작성된 노트북을 통해 지난 1시간 동안 실행된 모든 쿼리를 추출할 수 있습니다.\n\n```js\n#import and setup the SDK\nfrom databricks.sdk import WorkspaceClient\nfrom databricks.sdk.service import sql\n\nw = WorkspaceClient()\n\n\n#현재 시간과 관심 시간 창의 시작점을 반환하는 함수\n#(이 경우 지난 1시간 동안 실행된 모든 쿼리를 가져올 것입니다)\nimport datetime\nimport time\n\ndef get_current_time_and_minus_one_hour():\n  current_time = datetime.datetime.now()\n  current_time_sub_hour = current_time - datetime.timedelta(hours=1)\n\n  current_time_ms = int(time.mktime(current_time.timetuple()))*1000\n  current_time_sub_hour_ms = int(time.mktime(current_time_sub_hour.timetuple()))*1000\n\n  return current_time_ms, current_time_sub_hour_ms\n\n\n#API를 호출하여 지난 1시간 동안 실행된 모든 쿼리 기록을 가져옴\nimport json\nimport pandas as pd\nfrom pyspark.sql.functions import lit\n\ncurrent_time_ms, current_time_sub_hour_ms = get_current_time_and_minus_one_hour()\n\n#SDK를 사용하여 API를 호출\nqueries = w.query_history.list(\n    filter_by=sql.QueryFilter(\n        query_start_time_range=sql.TimeRange(\n            start_time_ms=current_time_sub_hour_ms, end_time_ms=current_time_ms\n        ) #지난 1시간의 시간 범위로 필터링\n    ),\n    include_metrics=True  #쿼리의 메트릭을 포함\n)\n\n#반환된 쿼리 기록을 사전으로 변환\nqueries_as_dicts = [query.as_dict() for query in queries]\n\n#pandas 데이터프레임을 생성한 다음 pySpark 데이터프레임으로 변환\nqueries_pandas = pd.DataFrame(queries_as_dicts)\nqueries_df = spark.createDataFrame(queries_pandas)\n\n#향후 분석을 위해 쿼리가 속한 시간 창을 추가\nqueries_df_with_window = queries_df.withColumn(\"start_window\", lit(current_time_sub_hour_ms)).withColumn(\"end_window\", lit(current_time_ms))\n\n#알림 및 분석에 사용할 테이블에 데이터프레임 추가\nqueries_df_with_window.write.mode(\"append\").saveAsTable(\"shared.tomasz_alerts.query_history\")\n```\n\n이 노트북을 통해 워크스페이스에서 지난 1시간 동안 실행된 모든 쿼리 기록을 수집하고 Delta 테이블에 추가하는 수집 프로세스를 설정했습니다. 이제 이 테이블은 모니터링을 위해 쿼리할 수 있으며 더 중요한 것은 사용자가 쿼리 실행 시 성능이 저하될 때 경고를 설정할 수 있습니다. 이제 이 테이블을 사용하여 웨어하우스를 변경하는 시기를 결정하는 방법을 살펴보겠습니다.\n\n\n\n## 대기열에서 막힌 쿼리를 찾는 방법\n\n웨어하우스가 많은 사용자 사이에서 공유되기 때문에 너무 많은 동시 쿼리가 발생하면 웨어하우스가 처리할 수 있는 리소스가 이용 가능할 때까지 대기열이 발생할 수 있습니다. 이러한 병목 현상은 대부분 자동으로 오토스케일링을 통해 해결될 수 있지만, 관리자는 주어진 SLA에 맞는 허용 가능한 최대 클러스터 개수의 건장한 상한선을 찾아야 합니다. 따라서, 관리자는 웨어하우스의 적절한 크기를 결정하기 위해 최소 클러스터 설정을 늘리고 자주 발생하는 스케일 업을 줄이며 최대 클러스터 설정을 늘려 대기열 병목 현상을 제거해야 합니다.\n\n아래 쿼리는 이전 단계에서 생성한 테이블을 호출할 것입니다. 가장 최근의 시간대 창을 사용하며, 1초 이상 대기열 단계에 갇힌 쿼리를 필터링합니다.\n\n```js\nselect\n  sum(\n    metrics.query_compilation_start_timestamp - metrics.overloading_queue_start_timestamp\n  ) as waiting_for_compute_duration_ms,\n  count(*) as count_queries_waiting_for_compute,\n  warehouse_id\nfrom\n  query_history\nwhere\n  end_window = (\n    select\n      max(end_window)\n    from\n      query_history\n  )\n  and metrics.query_compilation_start_timestamp - metrics.overloading_queue_start_timestamp \u003e 1000\ngroup by\n  warehouse_id\norder by\n  waiting_for_compute_duration_ms desc\n```\n\n\n\n위 쿼리 결과를 기반으로 하여 창고 관리자는 SQL 창고 모니터링 페이지를 검토하여 대기 시간이 매우 긴 경우를 확인할 수 있습니다. 창고가 최대 클러스터 수로 확장되었을 때 많은 쿼리 대기가 발생했다면, 관리자는 이 최대 제한을 늘려야 합니다. 반면에, 창고가 설정된 최대 클러스터 수에 도달하지 않았을 경우, 대기열의 원인은 아마도 빈번한 오토스케일링 때문일 것입니다. 이 경우, 관리자는 창고의 최소 클러스터 설정값을 더 높은 값으로 조정해야 합니다.\n\n디스크 스피룰링이 발생하는 창고 식별\n\n좋지 않은 쿼리 성능의 일반적인 원인 중 하나는 사용 중인 창고가 수평 스케일링(티셔츠 사이징) 면에서 적절하게 크기가 조정되지 않은 경우입니다. 이는 쿼리 실행 시간을 원하는 SLA와 비교하여 측정할 수 있습니다. 그러나 먼저, 이 문제가 있는지 여부를 결정하는 일반적인 전략은 쿼리가 자주 디스크로 스피릴하는 경우 트리거되는 경고를 설정하는 것입니다. 이는 클러스터가 단순히 메모리에 데이터를 처리하기에 너무 작거나 데이터에 중요한 스키가 있는 경우일 수 있음을 의미합니다.\n\n다음 쿼리는 우리의 쿼리 히스토리 테이블을 사용하여 디스크로 스피릴하는 쿼리의 수와 평균 및 최대 값에 대한 카운트를 반환합니다.\n\n\n\n```sql\nselect\n  avg(metrics.spill_to_disk_bytes) as avg_spill_to_disk_bytes,\n  max(metrics.spill_to_disk_bytes) as max_spill_to_disk_bytes,\n  count(*) as count_queries_spilled,\n  warehouse_id\nfrom\n  query_history\nwhere\n  end_window = (\n    select\n      max(end_window)\n    from\n      query_history\n  )\ngroup by\n  warehouse_id\nhaving\n  avg_spill_to_disk_bytes \u003e 0\norder by\n  avg_spill_to_disk_bytes desc\n```\n\n해당 쿼리 결과를 통해 데이터 웨어하우스 관리자는 많은 양의 디스크 스파일이 발생하는 웨어하우스를 확인할 수 있습니다. 이를 기반으로 해당 웨어하우스 클러스터를 더 큰 크기로 구성하여 더 많은 메모리 용량을 추가하고, 디스크 스파일을 줄이거나 제거할 수 있습니다.\n\n## 데이터 적재 및 경보 파이프라인 설정\n\n데이터를 적재하고 웨어하우스 관리자에게 사이즈를 재구성해야 할 때를 알려주는 경보를 활성화하는 Databricks 워크플로우를 설정할 수 있습니다. 이를 위해 먼저 위의 쿼리들 각각에 대한 두 개의 경보를 설정할 수 있습니다. 여기 예시에서는 임계값을 0보다 큰 고유한 웨어하우스로 설정하여, 디스크 스파일이나 대기 시간 초과가 발생할 때마다 경보가 트리거됩니다.\n\n\n\n\n\n![Databricks SQL Governance Alerting Patterns Warehousing Scaling Data Access Auditing 1](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_1.png)\n\n![Databricks SQL Governance Alerting Patterns Warehousing Scaling Data Access Auditing 2](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_2.png)\n\n쿼리 임계값(디스크로 스파일되는 크기 및 대기 시간)과 경고 임계값은 성능이 느린 쿼리에 대한 허용 수준에 따라 조정할 수 있습니다. 또한 쿼리 스파일 비율이나 쿼리 스파일 빈도에 따라 경고도 트리거할 수 있으며, 이는 데이터 웨어하우스를 확장하거나 쿼리 자체의 문제를 식별할 필요가 있음을 더 잘 나타낼 수 있습니다. 이러한 경고가 설정되면 먼저 쿼리 이력 API 데이터 처리 노트북을 실행하고 이러한 경고를 새로 고침하는 워크플로우를 생성할 수 있습니다. 워크플로에 경고를 추가하려면 \"작업 추가\" 버튼을 클릭한 후 SQL - 경고 옵션을 선택합니다. 이전 단계에서 생성한 경고를 선택하여 최종 워크플로 작업 다이어그램을 얻을 수 있습니다.\n\n이 워크플로는 데이터 웨어하우스의 성능 허용 수준에 따라 매 시간 또는 매일 실행되도록 예약할 수 있습니다. 쿼리 이력 시스템 테이블이 공개 미리보기로 제공되면 데이터 처리를 제거하고 이러한 경고를 DBSQL에서 직접 실행하도록 트리거할 수 있습니다!\n\n\n\n\n디스크 스피릴과 대기열 간의 관계\n\n수직으로 확장된 창고는 수평으로 확장할 필요성을 제거할 수 있다는 점을 강조해야 합니다. 예를 들어, 창고에서 쿼리가 완료되기까지 매우 오랜 시간이 걸릴 수 있으며, 위의 디스크로 스피릴이라는 경보로 나타날 수 있습니다. 이러한 상황에서 초기 실행 중인 쿼리가 완료될 때까지 신규 쿼리가 대기열에 들어가 있을 수 있습니다. 따라서 예를 들어 중간 규모에서 대형 클러스터로 수직으로 확장되면, 초기 실행 중인 쿼리가 더 빨리 완료되는 것 뿐만 아니라 대기 중인 쿼리 수도 줄어들 확률이 높습니다.\n\n동일한 맥락에서 창고를 가로로 확장하여 클러스터를 더 추가함으로써 복잡한 쿼리에 더 많은 전용 자원을 할당할 수 있으며, 작은 쿼리는 다른 클러스터로 리디렉션할 수 있습니다. 따라서 창고에 더 많은 클러스터를 추가하여 수평으로 확장함으로써 동적 쿼리 실행 중 발생하는 디스크 스피릴 양도 줄일 수 있습니다.\n\n# Use Case 2 — 모니터링 액세스 제어\n\n\n\nDatabricks 웨어하우스를 사용할 때 설정할 수 있는 또 다른 유용한 경고는 액세스 제어와 관련된 것입니다. 데이터 관리자 및 지배 관리자의 주요 관심사 중 하나는 사용자가 너무 허용적인 액세스를 허용받은 경우에 대해 이해하는 것입니다. 모베스트 프랙티스에서 벗어나는 권한 부여에 대한 경고를 설정하기 위한 기본 작업을 수행하려면 조직은 사용자가 일반적인 액세스 영역을 벗어나 데이터에 액세스해야 하는 방법을 정의하는 프로토콜 집합을 미리 정의해야 합니다. 이러한 관행이 정의된 상태에서 경고를 사용하여 표준 운영 절차에서 벗어나는 경우를 이해할 수 있습니다. 아래 예에서는 시스템 테이블에 대한 경고를 사용하여 관리자가 사용자가 민감한 PII 데이터에 액세스를 허용했을 때와 사용자에게 읽기 권한 대신 쓰기 액세스를 부여받았을 때 모니터링할 수 있습니다.\n\n## 개별 사용자에 대한 편집 권한\n\nUnity Catalog를 활용할 때 일반적인 모베스트 프랙티스는 개별 사용자에 직접 권한을 부여하는 대신 사용자 그룹을 통해 데이터 액세스를 관리하는 것입니다. 카탈로그는 팀 또는 프로젝트를 위해 생성되어야 하고 해당 카탈로그에 대한 소유자, 편집자 및 판독자 사용자 그룹이 데이터 액세스에 사용되어야 합니다. 그러나 다른 팀의 동료가 해당 카탈로그에 ad-hoc 액세스가 필요한 경우, 지배 관리자는 임시적인 권한 부여를 위해 그들을 기존 그룹 중 하나로 추가하길 원하지 않을 수 있습니다. 이 경우에는 이러한 사용자를 위해 사전에 생성된 게스트 사용자 그룹을 만들어 임시 액세스를 부여할 수 있습니다. 이를 통해 액세스를 사용자 계정을 통해 직접 제공하는 것과 비교할 때 지배를 더 쉽게 할 수 있습니다.\n\n지배 모베스트 프랙티스가 정립된 후에는 표준을 벗어나는 권한 부여 행동을 감시하기 위해 경고를 설정할 수 있습니다. 따라서 ad hoc 사용자 권한을 위해 게스트 그룹을 사용하는 모베스트 프랙티스에 따라 사용자 계정(사용자 그룹이 아닌 사용자 계정)이 카탈로그, 스키마 또는 테이블에 직접 액세스를 제공받았을 때 식별하기 위한 쿼리를 설정할 수 있습니다. 이 예에서는 권한을 MODIFY 또는 ALL_PRIVILEGES만 필터링하지만 구성 규칙이 조직 내에서 얼마나 엄격한지에 따라 READ 권한을 포함할 수 있습니다.\n\n\n\n```js\n-- 테이블, 스키마 또는 카탈로그 수준에서 직접 사용자 계정에 부여된 모든 쓰기 권한 (MODIFY 또는 ALL_PRIVILEGES)를 가져오십시오.\nSELECT\n  event_time,\n  user_identity.email as granter,\n  request_params.changes as perm_changes,\n  audit.request_params.securable_type as securable_type,\n  request_params.securable_full_name as securable_full_name\nFROM\n  system.access.audit\nWHERE\n  audit.service_name = \"unityCatalog\"\n  AND audit.action_name = \"updatePermissions\"\n  AND audit.request_params.securable_type in (\"catalog\", \"schema\", \"table\")\n  AND audit.event_time \u003e (current_timestamp() - INTERVAL 70 MINUTES)\n  AND audit.response.status_code = 200\n  AND request_params.changes:[*].principal like \"%@databricks.com%\" -- 조직 이메일 도메인\n  AND (\n    array_contains(\n      flatten(\n        from_json(\n          request_params.changes:[*].add,\n          'array\u003carray\u003cstring\u003e\u003e'\n        )\n      ),\n      \"MODIFY\"\n    )\n    OR array_contains(\n      flatten(\n        from_json(\n          request_params.changes:[*].add,\n          'array\u003carray\u003cstring\u003e\u003e'\n        )\n      ),\n      \"ALL_PRIVILEGES\"\n    )\n  )\n```\n\n이 문서에서는 조직의 도메인(\"databricks.com\")을 사용하여 사용자 계정이 데이터 자산에 직접 쓰기 액세스 권한이 부여된 것을 식별합니다. 이 예시에서는 매 시간마다 스케줄을 설정했으므로, 70분 전까지의 감사 테이블을 확인하는 필터가 있습니다(감사 테이블 업데이트에 지연이 있기 때문입니다).\n\n이 쿼리를 매 시간 실행하고 결과 레코드가 반환되면 데이터의 행 수를 선택하여 반환된 값이 0보다 크면 경고를 설정할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_3.png\" /\u003e\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_4.png\" /\u003e\n\n## 민감한 개인 식별 정보(PII) 테이블에 대한 권한\n\n다른 일반적인 Unity 카탈로그 패턴은 데이터에 민감한 PII(개인 식별 정보)가 포함되어 있음을 나타내는 테이블이나 열에 태그를 붙이는 것입니다. 따라서 이러한 데이터는 특정 사용자 집합에만 제한되어야 합니다. \"pii\" 태그가 있는 모든 테이블과 열을 찾아서 해당 테이블 및 스키마, 카탈로그 목록을 가져올 수 있는 정보 스키마 시스템 테이블을 사용할 수 있습니다. 그런 다음 이 목록을 권한 부여를 통해 교차 참조할 수 있습니다. 이 쿼리에 대한 알림을 설정하면 관리자는 이러한 민감한 자산에 추가된 모든 권한을 알 수 있어 잘못된 권한이 설정되지 않았는지 확인할 수 있습니다.\n\n```js\n-- \"pii\"를 포함하는 열 태그 또는 테이블 태그가 있는 모든 테이블(및 해당 카탈로그와 스키마) 찾기\nWITH table_tags_union AS (\n  SELECT\n    explode(\n      array(\n        catalog_name,\n        CONCAT(catalog_name, \".\", schema_name),\n        CONCAT(catalog_name, \".\", schema_name, \".\", table_name)\n      )\n    ) as securable_full_name\n  FROM\n    system.information_schema.column_tags\n  WHERE\n    tag_name LIKE \"%pii%\"\n    OR tag_value LIKE \"%pii%\"\n  GROUP BY\n    all\n  UNION\n    DISTINCT\n  SELECT\n    explode(\n      array(\n        catalog_name,\n        CONCAT(catalog_name, \".\", schema_name),\n        CONCAT(catalog_name, \".\", schema_name, \".\", table_name)\n      )\n    ) as securable_full_name\n  FROM\n    system.information_schema.table_tags\n  WHERE\n    tag_name LIKE \"%pii%\"\n    OR tag_value LIKE \"%pii%\"\n  GROUP BY\n    all\n) \n-- \"pii\" 태그가 있는 시큐러블과 권한 추가가 있었던 감사 로그를 조인\nSELECT\n  event_time,\n  user_identity.email,\n  request_params.changes,\n  request_params.securable_type,\n  request_params.securable_full_name\nFROM\n  system.access.audit\n  INNER JOIN table_tags_union ON audit.request_params.securable_full_name = table_tags_union.securable_full_name\nWHERE\n  audit.service_name = 'unityCatalog'\n  AND audit.action_name = 'updatePermissions'\n  AND audit.event_time \u003e (current_timestamp() - INTERVAL 70 MINUTES)\n  AND audit.response.status_code = 200\n  AND audit.request_params.changes:[*].add is not null\n```\n\n\n\n\n이전 설정에서와 마찬가지로, PII 데이터에 액세스가 허용된 경우 트리거되는이 쿼리에 대한 경고를 생성할 수 있습니다.\n\n![Alert Image 5](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_5.png)\n\n![Alert Image 6](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_6.png)\n\n# 결론\n\n\n\n쿼리 히스토리 API, 시스템 테이블, DBSQL 및 Databricks Workflows 등을 통해 관리자가 워크스페이스를 모니터링하여 플랫폼의 최종 사용자들에게 원활하고 안전한 경험을 제공하는 데 활용할 수 있는 다양한 방법의 몇 가지 예시에요. 이러한 쿼리와 알림은 조직의 요구 사항에 따라 성능 및 거버넌스에 관한 부분을 수정할 수 있어요. 원하는 거버넌스 및 모니터링 주제가 있으시면 직접 연락해 주세요!","ogImage":{"url":"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png"},"coverImage":"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png","tag":["Tech"],"readingTime":13},{"title":"Terraform을 사용하여 VPC 피어링 자동화하기","description":"","date":"2024-05-15 11:00","slug":"2024-05-15-AutomateVPCPeeringwithTerraform","content":"\n\n\n![image](/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png)\n\nAWS의 VPC 피어링은 두 개의 VPC 간에 사설 IPv4 또는 IPv6 주소를 사용하여 트래픽을 경로 설정할 수 있는 네트워킹 연결입니다.\n\nVPC 피어링은 AWS의 네트워킹 서비스 스위트의 일부로, 클라우드에서 확장 가능하고 안전하며 고가용성 네트워크 아키텍처를 생성할 수 있는 강력한 옵션을 제공합니다.\n\n이 기사에서는 Terraform을 사용하여 VPC 피어링 연결을 생성하는 방법을 살펴보겠습니다.\n\n\n\n\n## 준비 사항:\n\n- Terraform이 설치된 서버\n\n## 단계 1: VPC용 코드 생성\n\n- main.tf 파일을 생성하고 아래 코드를 추가하세요.\n\n\n\n```json\n# Demo VPC A\nresource \"aws_vpc\" \"demo-vpc-a\" {\n  cidr_block = var.demo-vpc-a-cidr\n\n  tags = {\n    Name = \"demo-vpc-a\"\n  }\n}\n\n# Demo VPC B\nresource \"aws_vpc\" \"demo-vpc-b\" {\n  cidr_block = var.demo-vpc-b-cidr\n\n  tags = {\n    Name = \"demo-vpc-b\"\n  }\n}\n```\n\n- 위의 코드는 2개의 VPC를 생성합니다.\n\n## 단계 2: 서브넷용 코드 작성\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n```js\n# 데모 VPC A의 서브넷\nresource \"aws_subnet\" \"demo-subnet-a\" {\n  vpc_id            = aws_vpc.demo-vpc-a.id\n  cidr_block        = var.demo-subnet-a-cidr\n  availability_zone = data.aws_availability_zones.available_zones.names[0]\n\n  tags = {\n    Name = \"Public Subnet A\"\n  }\n}\n\n# 데모 VPC B의 서브넷\nresource \"aws_subnet\" \"demo-subnet-b\" {\n  vpc_id            = aws_vpc.demo-vpc-b.id\n  cidr_block        = var.demo-subnet-b-cidr\n  availability_zone = data.aws_availability_zones.available_zones.names[1]\n\n  tags = {\n    Name = \"Public Subnet B\"\n  }\n}\n```\n\n- 위 코드는 각 VPC에 서브넷을 생성합니다.\n\n## 단계 3: 피어링 연결을 위한 코드 생성\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n  \n\n\n\n```js\n# Peering connection\nresource \"aws_vpc_peering_connection\" \"vpc_peering\" {\n  vpc_id      = aws_vpc.demo-vpc-a.id\n  peer_vpc_id = aws_vpc.demo-vpc-b.id\n}\n\n# Peering connection acceptor\nresource \"aws_vpc_peering_connection_accepter\" \"vpc_peering_accepter\" {\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n  auto_accept               = true\n}\n```\n\n- 위의 코드는 VPC 피어링 연결을 생성하고 자동으로 수락합니다.\n\n## 단계 4: 라우트 테이블 및 R을 위한 코드 만들기\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n\n```js\n# 라우트 테이블\n리소스 \"aws_route_table\" \"demo-route-table-a\" {\n  vpc_id = aws_vpc.demo-vpc-a.id\n}\n\n리소스 \"aws_route_table\" \"demo-route-table-b\" {\n  vpc_id = aws_vpc.demo-vpc-b.id\n}\n```\n\n- 위의 코드는 각 VPC에 두 개의 라우트 테이블을 생성합니다.\n\n## 단계 5: 라우트 코드 생성\n\n- 아래 코드를 main.tf 파일에 추가합니다.\n  \n\n\n\n```js\n# VPC 피어링을 위한 라우트 테이블에 라우트 생성하기\nresource \"aws_route\" \"demo-route-a\" {\n  route_table_id            = aws_route_table.demo-route-table-a.id\n  destination_cidr_block    = aws_vpc.demo-vpc-b.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n}\n\nresource \"aws_route\" \"route2\" {\n  route_table_id            = aws_route_table.demo-route-table-b.id\n  destination_cidr_block    = aws_vpc.demo-vpc-a.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n}\n```\n\n- 위 코드는 라우트 테이블을 수정하여 VPC A에서 VPC B로의 라우트 및 VPC B에서 VPC A로의 라우트를 허용합니다.\n\n## 단계 6: 인터넷 게이트웨이용 코드 작성하기\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n\n```js\n# 인터넷 게이트웨이 생성\nresource \"aws_internet_gateway\" \"demo-igw\" {\n  vpc_id = aws_vpc.demo-vpc-a.id\n}\n\n# VPC 라우트 테이블과 인터넷 게이트웨이 연결\nresource \"aws_route\" \"route_to_internet\" {\n  route_table_id         = aws_route_table.demo-route-table-a.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.demo-igw.id\n}\n```\n\n## 단계 7: 변수 파일 생성하기\n\n- variables.tf 파일을 생성하고 아래 코드를 추가합니다.\n\n```js\n# VPC A CIDR\nvariable \"demo-vpc-a-cidr\" {\n  type        = string\n  description = \"VPC A의 CIDR\"\n}\n\n# VPC B CIDR\nvariable \"demo-vpc-b-cidr\" {\n  type        = string\n  description = \"VPC B의 CIDR\"\n}\n\n# 서브넷 A CIDR\nvariable \"demo-subnet-a-cidr\" {\n  type        = string\n  description = \"데모 서브넷 A의 CIDR\"\n}\n\n# 서브넷 B CIDR\nvariable \"demo-subnet-b-cidr\" {\n  type        = string\n  description = \"데모 서브넷 B의 CIDR\"\n}\n\n# 지역\nvariable \"region\" {\n  type        = string\n  description = \"지역\"\n}\n```\n\n\n\n## 단계 8: 제공자 파일 만들기\n\n- provider.tf 파일을 만들고 아래 코드를 추가하세요.\n\n```js\n# AWS 제공자 구성\nprovider \"aws\" {\n  region = var.region\n}\n\n# 백엔드 구성\nterraform {\n  backend \"s3\" {\n    bucket         = \"dhsoni-terraform\"\n    key            = \"peering.terraform.tfstate\"\n    region         = \"us-east-2\"\n    dynamodb_table = \"terraform-state-lock-dynamodb\"\n  }\n}\n```\n\n## 단계 9: terraform.tfvars 파일 만들기\n\n\n\n- terraform.tfvars 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\nregion             = \"us-east-2\"\ndemo-vpc-a-cidr    = \"10.0.0.0/16\"\ndemo-vpc-b-cidr    = \"10.1.0.0/16\"\ndemo-subnet-a-cidr = \"10.0.1.0/24\"\ndemo-subnet-b-cidr = \"10.1.1.0/24\"\n```\n\n## 단계 10: 작업 디렉토리 초기화\n\n- 작업 디렉토리에서 terraform init 명령어를 실행해주세요. 이 명령어는 필요한 모든 공급자 및 모듈을 다운로드하고, 백엔드를 초기화합니다.\n\n\n\n## 단계 11: 테라폼 실행 계획 작성\n\n- 작업 디렉토리에서 `terraform plan` 명령을 실행하세요. 실행 계획을 확인할 수 있습니다.\n\n## 단계 12: 테라폼 적용 실행\n\n- 작업 디렉토리에서 `terraform apply` 명령을 실행하면 AWS에 필요한 모든 리소스가 생성됩니다.\n\n\n\n## 단계 13: 연결 확인하기\n\n- AWS 콘솔로 이동하여 VPC 피어링 연결을 확인하세요.\n\n![이미지](/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_1.png)\n\n이제 AWS VPC 피어링 연결을 Terraform을 사용하여 만드는 방법을 배웠습니다. 이제 원하는 대로 재생하고 필요에 맞게 수정할 수 있습니다.\n\n\n\n여기서 전체 코드를 찾을 수 있어요.\n\n다른 저장소들도 살펴보세요.\n\n이 안내서가 도움이 되었다면 👏 버튼을 클릭해 주시고, 자유롭게 댓글을 남겨 주세요.\n\n더 이런 이야기를 보고 싶다면 팔로우해 주세요 😊\n\n\n\n# 스택더믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n- 저희 작가를 clapping하고 팔로우해주시기 바랍니다! 👏\n- 저희를 팔로우하고 Youtube, Discord에서 만나보세요\n- 다른 플랫폼에서도 만나보세요: In Plain English, CoFeed, Venture, Cubed\n- 알고리즘 콘텐츠를 강제로 다루게 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 스택더믹 닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png","tag":["Tech"],"readingTime":6},{"title":"글로벌 게이머 챌린지의 수상자 발표","description":"","date":"2024-05-15 10:59","slug":"2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge","content":"\n\n# 우리의 상위 10개 프로젝트 및 지속 가능한 게임에 참여하는 방법\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png)\n\n플러터(Flutter) 및 글로벌 시민 커뮤니티에 게임개인도의 행성을 돕기 위해 초점을 맞춘 에픽 플러터 게임을 개발하도록 요청했습니다. 수십 개국에 걸친 수천 명의 열정적인 개발자에 의해 제출된 수백 개의 혁신적인 게임 프로젝트가 있었습니다.\n\n각 프로젝트는 플레이어들에게 지식과 조치를 전달하여 우리 행성을 보호할 수 있도록 하는 것을 목표로 했습니다. 자원 보존부터 오염 대응까지, 이러한 게임들은 절박한 환경 문제에 대한 우리의 집단 인식을 높이는 동시에 정말 재미있게 플레이할 수 있는 것입니다! 우리는 참여한 사람들의 놀라운 아이디어와 열정에 깊은 영감을 받았습니다.\n\n\n\n# 최종 10위를 위한 마지막 드럼 소리\n\n이 프로젝트 팀들은 103일 동안 프로젝트를 기획하고 만들고, 피드백을 받고, 프로젝트를 개선해왔습니다. 결과물은 우리 모두에게 더 지속 가능하게 생활할 수 있는 방법에 대해 깊이 생각하도록 도와주는 흥미로운 게임들입니다. 이들은 모두 알파벳순으로 나열되어 있습니다!\n\n## Better World\n\n환경 주제의 다양한 색감 있는 시각적 효과와 음악, 그리고 긍정적인 행동을 촉진하기 위해 기관들과 파트너십을 맺기 위한 아이디어가 담겨 있습니다.\n\n\n\n![Craftown](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_1.png)\n\n**Craftown**\n\n전통적인 실시간 전략 및 자원 관리 게임플레이의 독특한 혼합물로, 지속가능성 주제에 초점을 맞추고 있어요.\n\n![Craftown](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_2.png)\n\n\n\n## 에코시프트 연대기\n\n매력적인 시각적 효과와 사운드 디자인으로 긍정적인 행동을 장려하며, 플레이어들에게 관련성 있는 선택지와 환경적 결과를 제시합니다.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_3.png)\n\n## 고밀랜드\n\n\n\n매력적이고 교육적인 쓰레기 처리 게임으로, 일본 문화에서 영감을 받았어요.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_4.png)\n\n## Last Bottle\n\n매력적인 디자인과 수집 가능한 요소들이, 재활용의 한계와 환경 문제를 비판적으로 생각하는 핵심 메시지를 효과적으로 전달해 줘요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_5.png\" /\u003e\n\n## MGame — 쓰레기 처리 게임\n\n복잡한 쓰레기 처리 시스템에 대한 흥미로운 시뮬레이션 게임으로, 클래식 도시 건설 게임을 연상시킵니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_6.png\" /\u003e\n\n\n\n## Ocean Rangers\n\n유쾌한 이야기, 매력적인 캐릭터, 전략적인 게임 요소는 익숙한 장르에 환경적 요소를 더해 독특한 경험을 제공합니다.\n\n![Image](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_7.png)\n\n## PlasticPunk\n\n\n\n도시를 건설하는 스타일의 게임으로 매력적인 시각 효과와 매혹적인 게임 플레이를 통해 복잡한 환경적 도전 과제를 제시합니다.\n\n![이미지](/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_8.png)\n\n## Waste Wise\n\n직관적인 게임 플레이를 특징으로 하는 쓰레기 분리 수집 게임으로 적절한 쓰레기 처리 방법을 플레이어에게 효과적으로 교육합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_9.png\" /\u003e\n\n## Whaley’s Bins Waste Sorting\n\n재활용 교육을 위한 창의적 접근을 갖춘 쓰레기 분리 게임으로, 독특한 픽셀 아트 시각 효과를 특징으로 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_10.png\" /\u003e\n\n\n\n우리는 구글 사무실에서 워크샵과 더 많은 활동을 통해 뉴욕 시에서 이 팀들과 함께 시간을 보내는 것을 기대하며, 글로벌 시티즌 페스티벌 2024에서 60,000명의 다른 글로벌 시민들과 함께 축하할 것을 기대합니다!\n\n하지만 이들은 글로벌 게이머 챌린지에서 상을 받은 30개 이상의 팀 중에 딱 10개일 뿐입니다. 상위 20명의 다른 팀원들을 포함해서입니다. 'flutter.dev/global-gamers/#winners'로 이동하여 모든 수상팀을 확인해보세요!\n\n모든 수상자들에게 축하드립니다!\n\n# 여기서 끝나지 않아요\n\n\n\nPlaying 4 the Planet Alliance의 운영 책임자인 Lisa Pak이(가) 씀\n\n세계 게이머 챌린지가 점점 마무리를 지어가지만, 지속 가능한 게임 운동은 여기서 끝나지 않습니다. 이번 챌린지를 통해 만들어진 게임들과 Global Game Jam과 같은 유사한 챌린지들은 수백만 명의 플레이어에게 도달할 수 있는 잠재력을 가지고 있어 전 세계적인 긍정적인 환경 변화의 파동을 만들어낼 수 있습니다.\n\n이 성장하는 운동과 연결을 유지하는 방법은 다음과 같습니다:\n\n- 커뮤니티 가입: 생태 친화적인 게임 디자인에 전념한 온라인 커뮤니티와 포럼에 가입하는 것을 고려해보세요. 이러한 공간은 여러분의 작품을 공유하고 다른 개발자들과 아이디어를 교환할 수 있는 소중한 기회를 제공합니다.\n- 지속가능한 게임 플레이: 중요한 주제에 대한 플레이어들의 참여를 촉진하기 위해 한정된 시간의 이벤트, 도전 과제, 새로운 레벨 등을 포함한 인기 게임들을 주목해보세요. 우리의 목표는 가능한 많은 사람들에게 도달하는 것이며, 이러한 게임들은 큰 영감의 원천이 될 수 있습니다.\n- 여러분만의 목소리를 내다: 지속가능한 게임 개발에 관한 여러분의 경험을 쓰거나, 향후 개발자를 조언하거나, 여러분만의 프로젝트를 기획해보세요. 여러분의 기술적 또는 환경적 지식을 공유함으로써, 커뮤니티의 성장을 지원하는 뿐만 아니라 다른 사람들에게 지구에 긍정적인 영향을 미치는 게임을 만들도록 영감을 줄 수 있습니다.\n\n\n\n# 계속해서 발전해주세요\n\n클레이튼 위틀(Clayton Whittle), 기후 SIG 공동 의장\n\n게임에서의 지속가능성은 움직임 자체를 홍보하고, 팀의 게임 디자인 실천에서 기후와 지속가능성에 우선순위를 둠으로써, 게임 산업의 지속가능성 대사로서 지속될 수 있습니다.\n\n녹색 게임 디자인은 발전하는 분야로, 현실적이고 측정 가능한 영향을 가져오는 게임을 만들기 위한 점점 더 정제된 실천 방법을 포함하고 있습니다. 녹색 게임을 만들기 위한 범용 규칙은 없지만, 표준 지침을 준수하면 어떤 게임 디자인 팀이든 상당한 혜택을 받을 수 있습니다.\n\n\n\n- 대상을 알아야 합니다: 효과적인 지속 가능성 게임은 대상의 요구 사항과 능력을 이해하는 것부터 시작합니다. 지속 가능성 게임은 플레이어를 어떤 방식으로 변화시킬지를 목표로 하기 때문에 대상을 이해하는 것이 이 변화를 이끌어내는 데 중요합니다. 대상이 처음에 어디에 서 있는지를 알지 못하면 원하는 목표 지점으로 이끄는 것이 어려울 수 있습니다.\n- 구체적이 되세요: 효과적인 메시지를 전달하기 위해 메시지에 집중해야 합니다. 한 게임으로 플레이어의 전체 세계관을 바꾸려고 하는 것은 현실적이지 않습니다. 대신 변화가 의미 있는 특정 영역을 확인하세요.\n- 효과적인 조치를 장려하세요: 행동 가능한 지식을 제공하세요. 플레이어들이 차이를 만들 수 있는 영향력 있는 조치를 가르치세요. 플레이어들은 자신의 행동이 생태계나 사회에 어떻게 영향을 줄 수 있는지를 보여주면 높은 확률로 참여할 것입니다.\n- 그린워싱에 주의하세요: 얕은 지속 가능성 노력을 피하세요. 그린워싱은 지속 가능성 요소를 가짜로 표현하는 것을 의미합니다. 그린 아트워크를 추가하거나 캐릭터를 \"캡틴 리사이클\"로 지칭하는 것은 매력적으로 보일 수 있지만, 게임 플레이나 스토리텔링에서 의미 있는 지속 가능성 조치가 없다면 플레이어들은 이러한 얕은 연결을 통찰하게 됩니다.\n\n기억하세요, 영향력 있는 그린 게임을 개발하는 무수히 많은 방법이 있습니다. 당신의 아이디어와 디자인은 이 가이드를 벗어나서 미개척 영역으로 확장될 수 있습니다. 당신의 팀에 적합한 것은 미션과 대상에 따라 다릅니다. 하지만 이 원칙을 디자인 토론에 반영함으로써 당신의 팀이 영향력 있는 미션에 초점을 유지하도록 도와줄 수 있습니다.\n\n# Flutter가 어떻게 도움이 될 수 있는지\n\n여기 Flutter가 당신이 게임을 실행할 곳에 대해 걱정하는 시간을 덜고, 대신 미션과 대상을 위한 영향력 있는 경험을 디자인하는 데 더 많은 시간을 할애할 수 있는 몇 가지 방법이 있습니다.\n\n\n\n- Flutter은 생산적입니다: Flutter를 사용하여 단일 코드베이스를 개발하면 게임을 한 번만 작성하고 여러 플랫폼에 배포할 수 있습니다. Stateful hot reload와 같은 기능을 통해 빠르게 반복하고 개발 흐름을 가속화할 수 있습니다.\n- Flutter는 배우기 쉽습니다: 전문 게임 개발자가 아니더라도 Flutter로 시작하는 것이 전통적인 게임 개발 도구보다 쉬울 수 있습니다. 또한 Flutter Casual Games Toolkit의 일환인 게임 템플릿과 같은 여러 리소스를 제공하여 게임 개발 기술을 향상시킬 수 있는 발판을 제공합니다.\n\n다음 여정에 함께해 줘서 감사합니다! 다음에 여러분이 무엇을 만들어내는지 기대됩니다!","ogImage":{"url":"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png"},"coverImage":"/assets/img/2024-05-15-AnnouncingthewinnersoftheGlobalGamersChallenge_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 브라우저가 웹사이트를 찾는 방법","description":"","date":"2024-05-15 10:57","slug":"2024-05-15-HowYourBrowserFindsWebsites","content":"\n\n![이미지](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png)\n\n## 웹의 작동 방식: 뒷면을 엿보는 중\n\n웹 사이트 주소를 입력하고 Enter 키를 누르면 무슨 일이 벌어지는지 알아봅시다. 화면에 웹 사이트 구성 요소가 표시되지만, 어떻게 그려지는 걸까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*pQhQk0K7WbJRLeA5ixEA9Q.gif)\n\n\n\n## 1. 웹사이트 찾기\n\n웹사이트에 접속하려면 일반적으로 브라우저에 그 이름을 입력합니다. 하지만 컴퓨터는 그 이름을 우리가 이해하는 방식으로 인식하지 않습니다.\n\n대신, 인터넷 상의 모든 장치에 대한 고유한 식별자 역할을 하는 숫자 문자열인 IP 주소를 사용합니다. 따라서 우리가 웹사이트를 검색할 때 컴퓨터는 해당 웹사이트의 IP 주소를 찾아야 합니다.\n\n## 2. 귀하의 ISP: 인터넷 게이트웨이\n\n\n\n웹 브라우저에 \"google.com\"을 입력하면 당신의 기기가 웹사이트에 직접 연결되지는 않습니다. 대신, 인터넷 서비스 제공업체(ISP)에게 웹사이트의 IP 주소를 요청하는 요청을 보냅니다.\n\n![image](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_1.png)\n\nISP는 당신에게 인터넷 접속을 제공하는 회사로, 국가마다 다양합니다.\n\n## 3. DNS: 인터넷의 전화번호부\n\n\n\nISP도 \"google.com\"의 위치를 모르고 있어요. 이를 알아보기 위해 인터넷을 위한 거대한 전화번호부 역할을 하는 도메인 이름 시스템(DNS)에 연락합니다.\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_2.png)\n\nDNS는 모든 웹사이트의 IP 주소를 해당 도메인 이름과 함께 저장합니다. 따라서 ISP가 google.com에 대한 요청을 받으면 DNS에 연락하여 해당 도메인에 연결된 IP 주소를 찾아냅니다.\n\n그럼 DNS가 IP 주소로 응답하고, ISP는 해당 IP 주소를 당신의 브라우저로 전송해줍니다.\n\n\n\nMarkdown 형식으로 바꿔보세요.\n\n![Connecting to the Website](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_3.png)\n\n## 4. Connecting to the Website\n\n웹사이트의 IP 주소를 가져오면 브라우저가 HTTP 요청을 준비합니다. 이 요청은 케이블과 라우터로 구성된 네트워크를 통해 목적지에 도달합니다.\n\n![Traveling through the Network](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_4.png)\n\n\n\n요청을 받은 서버는 ‘google.com’을 구성하는 모든 파일을 저장하는 창고와 같이 작동합니다. 이 서버는 ‘google.com’을 구성하는 HTML, CSS 및 JavaScript 파일을 찾아서 브라우저로 다시 전송합니다.\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_5.png)\n\n## 5. Rendering the Magic\n\n이제 브라우저가 이러한 파일을 보유하고 있으면, 해석을 시작합니다. HTML을 읽고 구조를 이해하며, CSS 스타일을 적용하고 JavaScript를 실행한 다음... 그 결과로 웹페이지가 화면에 표시됩니다.\n\n\n\n\n![How Your Browser Finds Websites](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_6.png)\n\nAfter this point, there might be many other requests back and forth between your browser and Google servers for other HTML, CSS, and JS files. However, you don’t need to make another request to your ISP for these, as they go directly to Google’s servers. Additionally, your browser has likely cached the IP address of google.com, so it won’t need to make an unnecessary request to your ISP next time.\n\n## Experiment: See It in Action\n\nWant proof? Try this:\n\n\n\n\n- 브라우저의 개발자 도구를 열어주세요 (F12를 누르거나 마우스 오른쪽 버튼을 클릭하여 \"Inspect\"를 선택합니다).\n- \"Network\" 탭으로 이동합니다.\n- \"google.com\"을 입력하고 Enter를 누릅니다.\n- 첫 번째 요청을 찾아 \"Remote Address\"를 확인합니다 - 그곳에 구글의 IP 주소가 있어요!\n- IP 주소를 복사하여 새 탭에 붙여넣고 Enter를 누릅니다.\n\n![화면이미지](/assets/img/2024-05-15-HowYourBrowserFindsWebsites_7.png)\n\n이렇게 하면 ISP와 DNS를 거치지 않고도 구글에 접속할 수 있어요.\n\n## 요약: 전체 그림\n\n\n\n그래서, 웹 사이트를 방문할 때:\n\n- 도메인 이름 해석: 귀하의 ISP는 웹 사이트의 IP 주소를 찾기 위해 DNS를 사용합니다.\n- HTTP 요청: 귀하의 브라우저가 서버에 웹 사이트를 요청합니다.\n- 서버 응답: 서버가 HTML, CSS 및 JavaScript 파일을 보냅니다.\n- 렌더링: 귀하의 브라우저가 웹 사이트를 조립하고 표시합니다.\n\n웹 개발 기본에 대해 더 알아보고 싶다면, 무료 웹 개발자 커뮤니티에 가입하고 모든 강좌에 액세스하세요.","ogImage":{"url":"/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png"},"coverImage":"/assets/img/2024-05-15-HowYourBrowserFindsWebsites_0.png","tag":["Tech"],"readingTime":3},{"title":"새로운 기술 개척 KBTG GO 집중 워크샵 후기","description":"","date":"2024-05-15 10:55","slug":"2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop","content":"\n\n![image](/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png)\n\n👋 안녕하세요, 제 이름은 치바스입니다.\n\n오늘은 2024년 5월 11일부터 12일까지 K+ 건물에서 참가한 KBTG GO 집중 워크샵 경험을 공유하고 싶습니다.\n\n🎉🎉 시작해봅시다! 🎉🎉\n\n\n\n# 워크샵 개요\n\n이 워크샵에 참여하려면 Go 소프트웨어 엔지니어링 부트캠프를 완료해야 합니다.\n\n이 워크샵은 Git 및 협업, 소프트웨어 설계, 소프트웨어 품질, 데브옵스 등 부트캠프에서 습득한 기술을 기반으로 구축됩니다!\n\n다음 부트캠프를 놓치지 않으려면 KBTG의 공식 페이스북 페이지를 팔로우하여 최신 정보를 확인하세요!\n\n\n\n워크샵은 오전 8시 30분부터 오후 6시까지 진행될 예정이며, 아이스브레이킹, 요구 사항 설명 및 구현과 같은 활동이 포함될 것입니다. 워크샵 중에는 강사가 다양한 기술과 지식을 공유할 예정입니다.\n\n# 배운 점\n\n이 워크샵에서 배운 내용\n\n워크샵 중에는 모든 참가자가 다섯 개의 그룹으로 나눠지고, 그룹으로 협업할 것입니다. 다만, 처음 보는 사람들이며 동료의 이름만 알고 있는 점을 기억해 주세요.\n\n\n\n팀원들과 의견을 공유하고 피드백을 요청하는 것은 중요합니다. 가끔은 좋은 아이디어가 있더라도 상황에 더 나은 접근 방식이 있을 수 있습니다. 그러므로 팀원들로부터 가능한 모든 피드백을 듣는 것이 중요합니다.\n\n협업뿐만 아니라 소프트웨어 엔지니어링 기술, 프로덕션급 소프트웨어 인프라 구축, 페어 프로그래밍, 테스트 주도 개발(TDD)과 같은 다양한 분야에서 지식이 풍부합니다.\n\n# 실습 활동\n\n## 비즈니스 요구 사항 이해 및 계획하기\n\n\n\n첫째 날, 아이스 브레이킹 활동 후, 강사는 제품 소유자의 역할을 맡게 됩니다. 그는 비즈니스 요구 사항을 제시하고, 여러분과 여러분의 팀은 해당 요구 사항을 기반으로 제품을 어떻게 구축할지 계획하기 위해 토론에 참여할 것입니다.\n\n## 페어 프로그래밍\n\n각 그룹은 다음 규칙을 따라야 합니다: 모든 그룹은 페어 프로그래밍을 해야 합니다. 처음으로 페어 프로그래밍을 하게 되었고, 저와 제 페어가 선택한 프로그래밍 유형은 드라이버와 네비게이터입니다.\n\n## 매일 동기화하기\n\n\n\n두 번째 날에는 어제 달성한 내용에 대해 동료와 싱크를 맞춰야 하고, 마주한 어려움을 파악하고 오늘 해야 할 일을 계획해야 할 거예요.\n\n## 코드 리뷰\n\n구현 기간이 끝난 후, 여러분의 팀은 프로젝트 진행 상황을 발표하고 다른 그룹이 같은 비즈니스 요구 사항을 어떻게 완수하는지 배울 수 있는 기회가 주어질 거에요.\n\n# 네트워킹과 연결\n\n\n\nKBTG Go Workshop에 참여하여 기술 전문가, 비 기술 관련자, 심지어 학생들과 다양한 사람들과 연결할 수 있는 기회를 가졌어요 (나는 늙은 것 같아요 😭)\n\n워크샵은 제 네트워크를 확장하고 관계를 구축하는 플랫폼을 제공했어요. 최고에요!\n\n# 다음 단계\n\n부트캠프와 워크샵에서 얻은 기술을 활용하여 개인 성장을 증진할 계획이에요.\n\n\n\nKBTG가 훌륭한 부트 캠프와 워크샵 경험을 제공해줘서 정말 감사합니다! 🙏","ogImage":{"url":"/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png"},"coverImage":"/assets/img/2024-05-15-UnlockingNewSkillsARecpoftheKBTGGOintensiveworkshop_0.png","tag":["Tech"],"readingTime":2},{"title":"물리적 디바이스를 Firebase Emulator에 연결하기","description":"","date":"2024-05-15 10:54","slug":"2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator","content":"\n\n## 플러터 개발 및 테스트를 위한 Firebase 에뮬레이터 스위트에 실제 기기 연결하기\n\n모든 플러터 개발자들은 공통 목표를 공유합니다: 성능이 우수하고 버그가 없는 앱을 출시하는 것입니다. 이를 달성하기 위해서는 실제 환경과 가까운 환경에서 엄격한 테스트가 필요합니다. 이를 통해 개발자들은 사용자에게 영향을 미치기 전에 문제를 식별하고 해결할 수 있습니다. 테스트 조건이 실제 사용 시나리오와 유사할수록, 개발자들은 앱을 미세 조정하여 안정성, 사용성 및 원활한 성능을 보장할 수 있습니다.\n\n그러나 가끔씩 실제 제품 환경에서 바로 테스트하는 것이 유혹적일 수 있지만, 이는 매우 위험합니다. 실제 사용자들의 경험과 정확히 일치하는 테스트를 수행하는 것은 기존 사용자들에게 라이브 서비스를 방해할 위험을 가지며, 의도하지 않은 상당한 비용을 초래할 수도 있습니다. 구름 기능에 오류가 있는 경우, 수천 개의 작업을 실수로 수행할 수 있습니다. 각 작업은 수수료가 부과될 수 있습니다. 불행한 헤드라인의 대상이 되고 싶지 않다면 안전하고 격리된 테스트 환경이 중요합니다.\n\n![이미지](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png)\n\n\n\n파이어베이스 에뮬레이터 스위트가 등장하는 곳입니다. 이는 파이어베이스 서비스를 로컬로 시뮬레이션하여 앱의 기능을 철저히 테스트할 수 있게 해줍니다. 인증, 데이터베이스 작업, 서버 측 로직과 같은 기능을 배포 코드가 실제 백엔드로 이동하는 위험 없이 테스트할 수 있습니다. 이 로컬 에뮬레이터와 함께 물리적 장치에서 테스트를 활성화하여, 개발자는 실제 사용자들이 사용하는 실제 장치에서 어플리케이션이 어떻게 동작하는지 볼 수 있습니다. 이는 랩 조건과 실제 사용 사이의 간극을 메우고, 프로덕션 환경에서의 테스트의 위험을 회피할 수 있도록 해줍니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_1.png\" /\u003e\n\n파이어베이스 에뮬레이터 스위트를 설정하는 방법에 대한 훌륭한 많은 기사들이 있습니다. 이 기사들은 에뮬레이터가 테스트 중인 소프트웨어가 실행 중인 기기와 동일한 장치에서 실행되고 있다고 가정합니다. 실제로 구글의 공식 문서는 우수합니다. 하지만 모바일 개발자에게는 물리적 장치에서 테스트하는 것이 가장 중요한 경우가 많습니다, 시뮬레이션된 아이폰이나 안드로이드 장치만으로는 부족합니다. 시뮬레이터는 모바일 장치의 하드웨어 동작(배터리 사용, 카메라 기능, GPS 정확도 등)을 완벽하게 재현할 수 없기 때문입니다. 또한 시뮬레이터에서 앱의 느낌을 완전히 이해하는 것이 어렵습니다. 실제 장치에서 테스트하여 앱이 실제 사용 조건에서 잘 작동하도록 보장하고, 시뮬레이터가 놓치는 세세한 점과 상호 작용을 포착할 수 있습니다.\n\n파이어베이스 에뮬레이터 스위트에 실제 모바일 장치를 연결하는 방법에 대한 문서화된 정보가 부족합니다. 그래서 이 기사에서는 이 과정을 다룰 것입니다.\n\n\n\n# 로컬에서 플러터 앱을 Firebase Emulator Suite에 연결하는 방법\n\n그러나 실제 기기와 작업하기 전에 첫 번째 단계는 개발 컴퓨터에서 모두 실행 중인 경우 플러터 앱을 Firebase Emulator Suite에 연결하는 것입니다. 이를 수행하려면 앞에서 언급한 대로 다른 곳에서도 잘 문서화되어있는 몇 가지 단계를 따라야합니다.\n\n## 단계 1: Firebase Emulator Suite 설치 및 구성\n\n플러터 앱을 Firebase Emulator에 연결하려면 먼저 Firebase CLI를 설치하고 로컬 컴퓨터에 Firebase Emulator Suite를 설정해야합니다. Firebase CLI는 npm을 사용하여 설치할 수 있습니다:\n\n\n\n```bash\nnpm install -g firebase-tools\n```\n\n만약 아직 프로젝트 디렉토리에서 Firebase를 초기화하지 않았다면:\n\n```bash\nfirebase init\n```\n\n초기화 과정 중에 설정하려는 역할을 선택하세요 (예: Firestore, Authentication, Functions). 이렇게 하면 프로젝트 디렉토리에 firebase.json 파일이 생성되고 해당 파일에 에뮬레이터 설정이 저장됩니다. 곧 다시 이 파일을 사용할 것이므로 기억해 두세요.\n\n\n\n## 단계 2: 플러터 앱에서 Firebase 구성\n\n플러터 앱에서 Firebase 패키지가 라이브 Firebase 서비스가 아닌 로컬 엠블러에 연결되도록 구성해야 합니다. 플러터 앱에서 Firebase를 초기화하여 로컬 엠블러 인스턴스에 연결하십시오. 일반적으로 이는 main.dart 파일이나 Firebase를 초기화하는 곳에서 수행됩니다:\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Firebase를 초기화합니다.\n  await Firebase.initializeApp();\n\n  // 디버그 모드에서 Firebase 로컬 엠블러를 사용합니다.\n  if (kDebugMode) {\n    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);\n    await FirebaseAuth.instance.useAuthEmulator('localhost', 9099);\n    FirebaseFunctions.instance.useFunctionsEmulator('localhost', 5001);\n\n    debugPrint('Firebase 엠블러 스위트 사용중');\n  }\n\n  runApp(MyApp());\n}\n```\n\n\n\n```js\nif (kDebugMode) {…}\n```\n\n은 선택 사항이지만, 디버깅 중에 Flutter 앱이 항상 Firebase Emulator Suite를 사용하는지 확인하는 데 유용하다고 생각합니다.\n\n## 단계 3: 에뮬레이터 실행 및 Flutter 앱 실행\n\nFirebase 에뮬레이터를 구성하고 Flutter 앱이 이러한 에뮬레이터에 연결되도록 설정한 후, 이제 에뮬레이터를 시작할 수 있습니다:\n\n\n\n```js\nfirebase emulators:start\n```\n\n이 명령어는 설정한 모든 에뮬레이터를 시작합니다. 플러터 앱을 시작하기 전에 실행 중인지 확인해주세요. 이제 디버그 모드로 플러터 앱을 실행하면 Firebase Emulator Suite를 사용할 수 있습니다. CLI도 이에 대해 알려줄 것이지만, (일반적으로) http://localhost:4000/로 이동하여 에뮬레이터 스위트용 UI에 액세스할 수 있습니다.\n\n![Connecting Physical Devices to Your Firebase Emulator](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_2.png)\n\n## 단계 4: 연결 확인하기\n\n\n\n앱이 실행되면 FirebaseAuth를 사용하여 로그인하거나 Firestore에서 문서를 읽고 쓰는 작업을 수행해보세요. 에뮬레이터 UI에 반영된 액션을 확인할 수 있을 것입니다. 이는 Flutter 앱이 Firebase Emulator에 올바르게 연결되어 있는지를 확인하는 것이죠.\n\n# Flutter 앱과 Firebase 에뮬레이터를 외부 장치에 연결하기\n\n좋아요, 이제 Flutter 앱이 동일한 기기에서 실행 중일 때 Firebase 에뮬레이터 스위트에 연결할 수 있는 것처럼 외부 모바일 장치(예: 안드로이드 폰, 아이폰 또는 iPad)에서 실행 중인 Flutter 앱을 Firebase 에뮬레이터 스위트에 연결하기 위한 몇 가지 조정이 필요합니다.\n\n## 단계 1: 개발 환경의 IP 주소 얻기\n\n\n\n먼저 개발 컴퓨터의 IP 주소를 확인해야 합니다. 이 IP 주소는 플러터 앱의 Firebase 초기화 코드에서 localhost 참조를 대체할 것입니다. 이렇게 하면 주요 운영 체제에서 IP 주소를 찾을 수 있습니다:\n\n- Windows: 명령 프롬프트를 열고 ipconfig를 입력합니다. 네트워크 연결에서 \"IPv4 주소\"를 찾아보세요.\n- macOS: 시스템 환경설정을 열고 네트워크로 이동한 다음 활성 네트워크 연결을 선택합니다. 거기서 IP 주소를 확인할 수 있습니다.\n- Linux: 터미널을 열고 hostname -I를 입력하면 컴퓨터의 IP 주소가 표시됩니다.\n\n## 단계 2: 플러터 앱의 Firebase 초기화 업데이트\n\n획득한 IP 주소로 플러터 앱의 Firebase 초기화 코드에서 localhost 참조를 대체하세요. 이렇게 하면 외부 기기가 올바른 서버를 대상으로 할 수 있습니다. main.dart에서 설정을 수정하는 방법은 다음과 같습니다:\n\n\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Firebase 초기화\n  await Firebase.initializeApp();\n\n  // 디버그 모드에서는 Firebase 로컬 에뮬레이터를 사용합니다.\n  if (kDebugMode) {\n    // Firebase 에뮬레이터 스위트를 실행하는 컴퓨터의 IP 주소입니다. 앱과 같은 기기에서 에뮬레이터 스위트를 실행 중이면 \"localhost\"를 사용합니다. 그렇지 않으면 에뮬레이터 스위트를 실행 중인 기기의 IP 주소를 사용합니다.\n    const String devMachineIP = '192.168.x.x';  // 실제 IP 주소로 대체하세요\n\n    FirebaseFirestore.instance.useFirestoreEmulator(devMachineIP, 8080);\n    await FirebaseAuth.instance.useAuthEmulator(devMachineIP, 9099);\n    FirebaseFunctions.instance.useFunctionsEmulator(devMachineIP, 5001);\n  }\n\n  runApp(MyApp());\n}\n```\n\n## 단계 3 : firebase.json 구성 수정\n\n이 프로젝트에 Firebase를 초기화할 때 생성된 firebase.json 파일을 기억하시나요? 외부 기기에서 연결을 허용하려면 Firebase Emulator Suite를 localhost뿐만 아니라 모든 IP 주소에서 요청을 수락하도록 구성해야 합니다. 이를 위해 firebase.json 파일에서 모든 에뮬레이터의 호스트를 0.0.0.0으로 설정합니다:\n\n```js\n{\n  \"emulators\": {\n    \"auth\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"9099\"\n    },\n    \"firestore\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"8080\"\n    },\n    \"functions\": {\n      \"host\": \"0.0.0.0\",\n      \"port\": \"5001\"\n    },\n    // 필요한 다른 서비스를 포함하세요\n  }\n}\n```\n\n\n\n## ❗ 보안 경고 ❗\n\nFirebase 에뮬레이터를 어떤 IP 주소에서든 연결할 수 있도록 구성하면 외부 기기에서의 테스트를 가능케 할 뿐만 아니라 에뮬레이터를 네트워크에 노출시킬 수도 있습니다. 이 설정은 무단 접근을 방지하기 위해 안전하고 제어된 네트워크 환경에서만 사용해야 합니다. Firebase Emulator Suite를 인터넷이나 안전하지 않은 네트워크에 노출시키지 마십시오.\n\n# 마무리\n\n외부 모바일 기기를 Firebase Emulator Suite에 연결하는 과정은 문서화가 잘 되어 있지 않지만, 주요 변경 사항은 두 가지뿐입니다:\n\n\n\n- firebase.json 파일에서 에뮬레이터의 호스트를 0.0.0.0으로 설정하여 앱이 로컬 컴퓨터 외의 기기에서도 연결할 수 있도록 합니다.\n- Flutter 앱을 로컬호스트 대신 개발 컴퓨터의 IP 주소를 사용하도록 업데이트합니다.\n\nFlutter 앱을 외부 모바일 기기와 Firebase Emulator Suite에 연결할 수 있도록 설정하면 개발 컴퓨터의 범위를 벗어나 심층적인 테스트를 수행할 수 있습니다. 이 기능을 통해 제품 환경에 손상을 주지 않고 실제 기기에서 앱의 기능을 검증하므로 더 큰 확신을 갖고 앱을 출시할 수 있을 것입니다.\n\n![이미지](/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_3.png)","ogImage":{"url":"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png"},"coverImage":"/assets/img/2024-05-15-ConnectingPhysicalDevicestoYourFirebaseEmulator_0.png","tag":["Tech"],"readingTime":7},{"title":"당신의 iOS 앱의 비밀을 보호하는 중요한 단계","description":"","date":"2024-05-15 10:52","slug":"2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets","content":"\n\n암호화와 적절한 솔루션 선택\n\n앱에 하드코딩된 문자열로 저장된 비밀 또는 암호화 키가 있나요? 또는 Info.plist와 같은 파일에 저장되어 있나요?\n\n그렇다면, 그것들은 매우 쉽게 발견될 수 있습니다.\n\n먼저, 우리가 방지하려는 것을 이해하기 위해 공격자가 어떻게 하드코딩된 문자열을 볼 수 있는지 살펴봅시다.\n\n\n\n# 해커가 하드코딩된 문자열을 어떻게 볼 수 있을까요?\n\n당신의 애플리케이션(예: iOS의 경우 IPA 파일)을 정적 분석 도구에 전달하면 그 문자열들이 이렇게 나타날 것입니다:\n\n![이미지](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png)\n\nInfo.plist 파일에 저장한다면 어떨까요?\n\n\n\n이 방법도 안전하지 않습니다. 파일은 정적 분석기를 통해 쉽게 볼 수 있습니다.\n\n![image](/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_1.png)\n\n## 그래서, 하드코딩된 문자열을 어떻게 보호할까요?\n\n이상적으로는 보안 정보(API 키, 엔드포인트, API 토큰 등 민감한 데이터)는 클라이언트 측에 저장되어서는 안 됩니다. 이는 피해야 할 패턴입니다.\n\n\n\n하지만 거의 모든 앱에는 일부 정보가 저장되어 있고, 당신이 이러한 상황에 처할 수도 있습니다. 이 경우에는 정보가 올바르게 보호되었는지 확인해야 합니다.\n\nAPI 키와 기타 비밀 정보를 간단히 암호화할 수 있을까요?\n\n좋은 시작입니다. 하지만 클라이언트에 암호화 키를 저장해야 하는 경우 어떻게 그것을 안전하게 보호할 수 있을까요?\n\n어떤 정보든 클라이언트에 두는 보안 계층은 100% 안전하지 않다는 것을 강조하고 싶습니다. 그러나 공격자가 이러한 정보를 획득하는 것을 매우 어렵게 만들 수는 있습니다.\n\n\n\n주기적으로 비밀을 업데이트하는 것은 역공학 공격을 무력화시킬 수 있습니다. 정기적인 업데이트로, 역공학자가 시간을 쏟아서 비밀을 얻으려고 노력한 모든 시간이 무익해질 수 있기 때문이죠.\n\n# 코드 난독화\n\n위에서 설명한 것처럼 일반적으로 정보를 업데이트하여 구조를 변경함으로써 역공학 공격을 무력화할 수 있습니다.\n\n난독화는 정보나 코드를 이해하기 어렵게 만드는 행위입니다. 이는 인간뿐만 아니라 컴퓨터도 이해하기 힘들게 만드는 것을 의미합니다.\n\n\n\n추가적인 보안층으로, hardcoded된 비밀을 암호화한 다음 암호화 키를 난독화 하는 것을 권장합니다. 이렇게 하면 모든 비밀을 난독화 해야 하는 대신 암호화 키만 난독화하면 되므로 알고리즘에 따라 발생할 수 있는 성능 오버헤드를 피할 수 있습니다.\n\niOS를 사용 중이라면 Apple의 CryptoKit을 사용하는 것을 추천하며, AES와 같은 강력한 산업 표준 알고리즘을 선택하는 것이 좋습니다.\n\n# 결과\n\n비밀 hardcoded된 문자열을 난독화한 후 정적 분석기가 그들을 직접적으로 사용할 수 없는 변형 형태로 캐치할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_2.png\" /\u003e\n\n# 당신의 난독화 솔루션을 선택하기\n\n어떤 난독화 라이브러리를 선택해야 할까요?\n\n비록 당신이 선택한 어떤 난독화 알고리즘이라도 단순히 앱 내에 하드코딩된 보안 정보를 그대로 둘 것보다 낫다는 것은 사실이지만, 해독자에게 더 어렵게 만드는 솔루션도 있습니다.\n\n\n\n# 찾아야 할 난독화 기술\n\n비밀 정보를 안전하게 유지하기 위해 난독화 라이브러리를 찾고 있다면 다음의 기본 아이디어를 살펴보세요.\n\n1. 데이터 변환\n\n비밀 정보 숨김에 관련된 코드 난독화의 중요한 요소는 데이터(문자열)를 다른 형태로 변환하는 것입니다. 이는 코드의 성능에 미치는 영향을 최소화하면서도 해커들이 이해하기 어렵게 만들어야 합니다.\n\n\n\n이것은 하드코딩된 문자열을 특히 난독화하는 솔루션이 필요하다는 것을 의미합니다 (또는 문자열을 매개변수로 사용할 수 있는 것), 애플리케이션의 클래스 이름 및 소스 코드를 난독화하려는 것이 아니라는 것을 명심해주세요. 왜냐하면 그것은 다른 목적을 위한 것이기 때문입니다.\n\n데이터 변환은 문자열 암호화, 키 분할, 사용자 지정 인코딩 등 다양한 형태를 가질 수 있습니다.\n\n다중 레이어\n\n난독화 알고리즘이 여러 변환을 수행하면 스크립트에 덜 취약할 가능성이 높으며, 따라서 데이터를 이해하려는 시도가 더 시간이 걸릴 수 있으며 코드를 다시 난독화하려면 수동 개입 (동적 분석)이 필요할 수도 있습니다.\n\n\n\n# 결론\n\n요약하자면, 자동화된 스크립트에 취약하지 않은 알고리즘을 찾는 것이 이상적입니다. 공격자가 키를 복호화하는 것을 어렵게 만들어야 하며, 시간이 많이 걸리는 기술을 사용해 애플리케이션을 공격자에겐 덜 유혹적으로 만들어야 합니다.\n\n또한 비밀 정보의 중요성을 고려하고, API 키를 숨기는 경우에는 API 키 사용을 제한하는 등의 회전하는 보안 방법을 고려해야 합니다.\n\n원하는 보안 수준에 따라 소유권 기반의 난독화 솔루션을 선택할 수도 있습니다. 이러한 솔루션의 장점 중 하나는 비공개로 유지되어 자동화 스크립트에 취약할 가능성이 낮다는 것입니다.\n\n\n\n# iOS 개인 추천 사항\n\n이 추천 사항은 작성 시점에 작성되었음을 유의해 주세요.\n\n다음은 이러한 아이디어를 일부 이용한 라이브러리 목록입니다:\n\n- Swift confidentials — https://github.com/securevale/swift-confidential\n- ObfuscateMacro — https://github.com/p-x9/ObfuscateMacro\n\n\n\n이 기사는 iOS에 초점을 맞추었지만 일반적인 원칙은 모든 클라이언트 측 코드에 적용할 수 있습니다.\n\n사용하는 난독화 알고리즘은 앞으로 다룰 다른 보호층과 함께 사용해야 합니다.\n\n애플리케이션을 더 안전하게 만드는 방법에 대해 더 많은 통찰력을 얻고 싶으신가요?\n\n향후 게시물을 최신 상태로 유지하려면 아래 무료 뉴스레터를 구독해주세요:\n\n\n\nhttps://substack.com/@alexlotsu?utm_source=profile-page","ogImage":{"url":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png"},"coverImage":"/assets/img/2024-05-15-ThecrucialstepinprotectingyouriOSappssecrets_0.png","tag":["Tech"],"readingTime":4}],"page":"21","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"21"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>