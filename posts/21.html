<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/21" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/21" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" href="/post/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대학에서도 배울 수 없는 프로그래밍 스킬 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Go 언어로 WebSockets 완벽하게 마스터하는 방법" href="/post/2024-06-22-MasteringWebSocketsWithGo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Go 언어로 WebSockets 완벽하게 마스터하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Go 언어로 WebSockets 완벽하게 마스터하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Go 언어로 WebSockets 완벽하게 마스터하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" href="/post/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl"> 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드" href="/post/2024-06-22-AdvancedDataStructuresandAlgorithmsTries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 인기를 끌고 있는 오픈 소스 도구 4가지" href="/post/2024-06-22-4TrendingOpenSourcetools"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 인기를 끌고 있는 오픈 소스 도구 4가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 인기를 끌고 있는 오픈 소스 도구 4가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 인기를 끌고 있는 오픈 소스 도구 4가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="경이로운 WebGL 점 구체 만드는 방법" href="/post/2024-06-22-StunningWebGLDotSpheres"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="경이로운 WebGL 점 구체 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="경이로운 WebGL 점 구체 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">경이로운 WebGL 점 구체 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 배열 흉내내기 Objectassign, arr 방법" href="/post/2024-06-22-JavaScriptFakesArraysObjectassignarr"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 배열 흉내내기 Objectassign, arr 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 배열 흉내내기 Objectassign, arr 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 배열 흉내내기 Objectassign, arr 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="정규 표현식에서 여러 조건을 일치시키는 방법" href="/post/2024-06-22-HowToMatchMultipleConditionsinRegex"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="정규 표현식에서 여러 조건을 일치시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="정규 표현식에서 여러 조건을 일치시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">정규 표현식에서 여러 조건을 일치시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법" href="/post/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법" href="/post/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link posts_-active__YVJEi" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"대학에서도 배울 수 없는 프로그래밍 스킬 5가지","description":"","date":"2024-06-22 13:56","slug":"2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou","content":"\n\n## 일\n\n![이미지](/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png)\n\n- 작은 코너나 집에서 코딩하는 것은 매우 교육적이지만, 회사에서 코딩하는 것과는 많이 다릅니다. 둘 중 하나로 다른 것을 대체할 수 없어요.\n- 테스트되지 않은 것은 미리 정해지지 않았다고 볼 수 있어요. 시간을 낭비하지 않기 위해 코드를 자동으로 테스트해야합니다(단위 테스트, 통합 테스트, 성능 테스트, 트래픽 재현, 안정성 테스트 등).\n- PR/코드 리뷰, 빌드 자동화 및 실행 테스트는 품질을 향상시키는 데 많은 도움이 됩니다. 재구성을 할 때 자신감을 주죠.\n- 운영 환경에서 모니터링 및 경보는 꼭 필요합니다. 코드가 오류와 비정상 케이스를 감지하고 오류를 보고하여 이러한 오류가 알람을 생성하여 문제가 감지되고 수정되도록 해야 합니다(가능하면 고객의 불만이 제기되기 전에).\n- 학교, 책, 자습서에서 배우는 코딩 방식은 실제 프로젝트에서 사용하는 방식과 다릅니다. 배우는 과정은 주로 hello world나 조금 더 복잡한 내용에 중점을 두는데, 실제 문제는 큰 규모의 코드에서 프레임워크, 방법론 등이 팀으로서 작성/수정/유지되는 방식입니다.\n- 새로운 프레임워크나 기술은 주로 좋은 hello world와 자습서 이외의 본질적인 것은 제공하지 않을 수 있습니다. 주요 기술적인 변화가 정기적으로 있을지라도, 제공되는 것 중 95%는 시간을 낭비하는 것일수도 있습니다. 적합한 것, 게임 체인저, 부가적인 것을 구분하는 방법을 배워야 합니다.\n- Google, StackOverflow 등이 여러분의 친구입니다. 멈춰있지 마세요. 해결책이 있더라도, 더 나은, 더 짧고, 더 표준적이며, 더 읽기 쉬운 것을 찾아보세요. 여러분이 작성한 이 작은 함수는 이미 어떤 라이브러리에 있을 것입니다. 바퀴를 다시 발명하지 마세요. 연습이나 단지 연습을 위해 사용하기보다는 이미 작성되고 디버깅되어 테스트된 표준 코드를 사용하는 것이 더 좋을 겁니다. 사용자 정의 코드 작성은 마지막 수단이어야 하며, 작성된 코드는 실로 명료하고 간결해야 합니다.\n- 인터넷 곳곳에서 코딩에 관한 질문 한 번도 한 적이 없어요. 그러나 많은 질문에 답변했답니다. 99.99%의 경우 여러분이 묻는 질문은 이미 1000번 이상 물린 질문이고 이미 훌륭한 답변이 있습니다. 물어본 질문에 대한 답을 기다리기보다는 누군가 이미 해결책을 갖고 있는지 알아보거나 직접 찾아보세요. 99.99%의 경우 일이 잘 풀리죠.\n- 코드는 종종 수정되고 더 자주 읽힙니다. 매우 읽기 쉽고 의외가 없어야 합니다. 작친 꼼수, 지나치게 똑똑하거나 너무 많은 가정을 하는 코드는 리뷰어가 버그를 수정해야 하는데 리뷰어가 혼란스러워하게 만들 것입니다.\n- 좋은 IDE는 코드를 쉽게 이동하게 해주며, 리팩토링을 수행하고, 잠재적인 버그를 강조하며, 단위 테스트를 실행하고 디버깅을 쉽게 할 수 있도록 도와줍니다. print/cout 라인을 추가하여 디버깅하지 마세요, 수정한 메서드 호출 50회를 하나씩 수정하지 마세요. 그보다 나은 방법이 있답니다. 진정한 IDE를 사용하는 방법을 배워보세요.\n- 여러분이 작성하는 코드는 여러분의 코드가 아닙니다. 수정/리펙토링/개발을 하는 모든 사람에게 속합니다. 마찬가지로, 코드를 여러분의 취향에 맞게 수정해선 안됩니다.\n- 두 종류의 코드가 있습니다: 잘 지정된, 새로운, 비싼 코드는 작동하지 않을 수 있지만 오래되거나, 해독하기 어렵거나, 심지어 테스트되지 않은 코드들은 작동합니다. 여기서 나는 고객의 문제를 해결하는 것이 기본적인 알고리즘/디자인을 구현하는 것이 아닌 일을 한다는 의미입니다. 보통 디자인을 혼란스럽게 만들고 코드를 읽기 어렵게하는 모든 세부, 특별한 경우 및 예외사항을 다루는 작업입니다. 그렇지만 그것이 필요하고 그것이 비용이 많이 들죠. 텍스트 편집기를 인턴이 만들게 한다면 그게 됩니다. 모든 사용자의 모든 기능을 지원하고 모든 형식과 작업하는 워드를 만든다면 그것은 수십억 유로가 드는 일입니다.\n- 작성된 모든 코드, 심지어 테스트 및 완벽히 디자인된 코드도 부채입니다. 소프트웨어의 복잡성은 코드의 크기에 지수적으로 증가합니다. 각 기능을 개발하고 유지하는 데 비용이 들죠, 사용되지 않아도. 불필요한 코드는 작성하지 말고, 더 이상 필요하지 않은 기능을 제거하고 가능한 한 최소한의 코드를 작성하세요. 그 페어는 구현하는 기능이 드는 비용보다 훨씬 많이 가져오는 것을 확실하게 하세요.\n- 디자인, 선택 사항, 문서 등은 대부분 디자이너의 머리 속에 있습니다. 이 정보는 흔히 완벽하게 전달되지 않습니다. 팀이 완전히 새롭게 구성되면, 신입사원들은 기존 소프트웨어의 디자인과 논리를 제대로 이해하지 못할 수 있고 다르게 작업할 수 있습니다. 이것을 너무 빨리, 너무 자주(프로젝트에서 누가 코딩하는지 변경하는 것) 한 경우에는 너무 많은 다른 시각을 축적하여 여러분의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스택데믹 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 추천하고 팔로우해 주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png"},"coverImage":"/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png","tag":["Tech"],"readingTime":3},{"title":"Go 언어로 WebSockets 완벽하게 마스터하는 방법","description":"","date":"2024-06-22 13:52","slug":"2024-06-22-MasteringWebSocketsWithGo","content":"\n![웹 소켓 사용 방법](/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png)\n\n생각해보면, 일반적인 HTTP API는 정말 어리석습니다. 데이터를 가져오려면 해당 데이터에 대한 요청을 보내야 합니다. 웹 사이트의 데이터를 신선하게 유지해야 한다면 데이터를 계속 요청해야 하는 폴링이라는 방법을 사용해야 합니다.\n\n이는 목적지에 도착했는지를 물어보는 자리에서 운전자가 \"우리가 이미 도착했어\"라고 말해주는 대신 뒷자리에 앉은 아이가 계속 \"도착했니?\"라고 물어보는 것과 같습니다. 이것이 웹사이트를 디자인할 때 사용하기 시작한 방식입니다. 참 어리석죠?\n\n다행히도, 개발자들은 웹 소켓, WebRTC, gRPC, HTTP2 스트림, Server-Sent 이벤트 및 기타 양방향 통신과 같은 기술로 이를 해결했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹소켓은 상호 양방향 통신의 가장 오래된 방법 중 하나이며 현재 널리 사용되고 있습니다. 대부분의 브라우저에서 지원되며 비교적 쉽게 사용할 수 있습니다.\n\n이 튜토리얼에서는 웹소켓이 무엇이며 어떻게 작동하는지, 서버와 클라이언트 간에 통신하는 데 Go에서 사용하는 방법에 대해 다룰 것입니다. 또한 웹소켓 API에서 본 적이 있는 몇 가지 일반적인 함정을 탐구하고 이를 해결하는 방법도 살펴볼 것입니다.\n\n이 튜토리얼에서는 다양한 채팅방에 참여할 수 있는 채팅 애플리케이션을 구축할 것입니다. 웹소켓 서버는 Go를 사용하여 구축되며 클라이언트는 순수 JavaScript를 사용하여 연결할 것입니다. 배운 패턴은 Go, Java, React 또는 다른 언어로 작성된 웹소켓 클라이언트를 사용할 때 쉽게 적용할 수 있습니다.\n\n이 기사는 또한 녹화되어 내 YouTube 채널에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹소켓이 뭔지, 그리고 왜 중요한지 알아보세요\n\n![웹소켓](/assets/img/2024-06-22-MasteringWebSocketsWithGo_1.png)\n\n웹소켓 표준은 RFC 645에서 정의되어 있습니다.\n\n웹소켓은 서버로 초기 요청을 보내기 위해 HTTP를 사용합니다. 이것은 일반적인 HTTP 요청이지만, Connection: Upgrade라는 특별한 HTTP 헤더가 포함되어 있습니다. 이를 통해 클라이언트가 HTTP 요청의 TCP 연결을 장기적인 웹 소켓으로 업그레이드하려고 한다는 것을 서버에 알립니다. 서버가 HTTP 101 Switching Protocols로 응답하면 연결이 유지되어 클라이언트와 서버가 메시지를 상호간에 전이 가능하고 풀듀플렉스로 보낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 이 연결이 합의되면, 우리는 양쪽에서 데이터를 송수신할 수 있습니다. 웹소켓에 대해 이해해야 할 것은 더 이상 없습니다.\n\n설치 중에 무슨 일이 벌어지는지 더 자세히 알고 싶다면, RFC를 추천드릴게요.\n\n실시간 솔루션이 필요한지 궁금할 수도 있습니다. 그래서 다음은 웹소켓이 자주 사용되는 몇 가지 분야입니다.\n\n- 채팅 애플리케이션 — 다른 클라이언트에게 메시지를 받아 전달해야 하는 애플리케이션들은 웹소켓에 완벽히 어울립니다.\n- 게임 — 멀티플레이어를 갖고 있고 웹 기반의 게임을 개발한다면, 웹소켓은 정말 완벽한 매치입니다. 클라이언트로부터 데이터를 푸시하고 다른 플레이어들에게 브로드캐스트할 수 있습니다.\n- 피드 — 데이터 피드가 필요한 애플리케이션의 경우, 업데이트된 데이터를 손쉽게 모든 클라이언트로 푸시할 수 있습니다.\n- 실시간 데이터 — 실시간 데이터가 필요한 경우, 웹소켓은 탁월한 솔루션입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 애플리케이션의 기초를 설치하기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_2.png)\n\n간단한 HTTP 서버를 설정하여 파일 서버를 통해 웹 애플리케이션을 호스팅하는 방법으로 시작하겠습니다. React와 같은 웹 프레임워크를 사용하지 않도록 하려고 합니다. 대신 네이티브 JavaScript를 사용해 보겠습니다. 보통 WebSocket에 연결하는 단계는 매우 유사하기 때문에 사용 중인 프레임워크와의 연결에 문제가 없어야 합니다.\n\n새 모듈을 초기화하는 것부터 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngo mod init programmingpercy.tech/websockets-go\n```\n\n그런 다음 application의 시작점이 될 새로운 파일 main.go를 만듭니다.\n\n먼저 application을 API를 서비스하고 HTML/JS 코드를 호스팅하도록 설정합니다. 그 이후에는 WebSocket 구현을 시작하여 따라가기 쉽도록 합니다.\n\n이제 우리가 곧 구축할 웹사이트를 호스팅하기 위한 간단한 코드를 main.go에 작성해 봅시다. 우리는 곧 만들고 내용을 저장할 frontend 디렉토리만 서비스할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 프론트 엔드를 추가해 보겠습니다. 저희의 멋진 채팅 애플리케이션을 보여주기 위해 간단한 원시 HTML/JS/CSS 파일을 만들겠습니다. 사용자들이 특정 채팅방에 입력할 수 있는 채팅방 선택 양식과 메시지를 WebSocket을 통해 보낼 수 있는 두 번째 채팅방 메시지 양식으로 구성되어 있습니다.\n\n이것은 단지 간단한 HTML과 JavaScript이지만, 아직 WebSocket 구현은 되어 있지 않습니다. 말하기 괜찮은 유일한 것은 클라이언트 브라우저가 WebSocket을 지원하는지 확인할 수 있는 글로벌인 window[\"WebSocket\"]입니다. 이 값이 정의되지 않은 경우 사용자에게 그들의 브라우저가 지원되지 않는다는 경고 메시지를 보여줄 것입니다.\n\nfrontend이라는 폴더와 index.html이라는 파일을 만들어 주세요. 그런 다음 다음의 Gist로 index.html을 채워주세요. HTML과 JS 부분은 다루지 않겠습니다. 당신이 익숙하다고 가정할게요.\n\n터미널에서 go run main.go를 실행하고 localhost:8080을 방문하면 WebSocket을 구현하기 시작할 모든 것이 갖춰진 멋진 웹사이트로 환영받을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_3.png\" /\u003e\n\n지금은 메시지를 보내거나 채팅방을 변경해도 콘솔에만 출력되지만, 이제 구현할 것입니다.\n\n## 클라이언트 및 서버 사이의 WebSocket 연결\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 위해 프론트엔드에 추가하여 웹소켓 API에 연결하도록 설정하겠습니다. JavaScript로는 간단하게 한 줄의 코드로 처리할 수 있어요.\n\nJavaScript에는 가져올 필요 없이 사용할 수 있는 내장 웹소켓 라이브러리가 있어요. 우리는 new WebSocket(URL)을 사용하여 클라이언트를 생성할 수 있는데 먼저 URL을 만들어야 해요. URL은 프로토콜과 함께 일반적인 HTTP URL처럼 구성되어 있고, 그 뒤에 경로가 따라옵니다. 일반적으로 웹소켓은 /ws 엔드포인트에 배치하는 것이 표준입니다.\n\n웹소켓을 사용할 때 두 가지 프로토콜이 있는데, ws와 wss가 있어요. 이것은 HTTP와 HTTPS처럼 작동하는데요, 여기에서의 S는 보안을 나타내며 트래픽에 SSL 암호화를 적용합니다.\n\n이를 사용하는 것이 매우 추천되지만 인증서가 필요합니다. 이 부분은 나중에 적용할 예정이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwindows.onload 함수에 ws://localhost/ws에 연결하는 라인을 추가해보세요.\n\n지금까지 코드를 다시 실행해보고, 웹 사이트를 방문하면 아직 연결할 수 없다는 오류가 콘솔에 출력되는 것을 볼 수 있을 겁니다. 이는 단순히 백엔드가 아직 연결을 허용하지 않기 때문입니다.\n\n이제 백엔드 코드를 업데이트하여 WebSocket 연결을 허용해봅시다.\n\n먼저, 연결을 처리하고 일반 HTTP 요청을 WebSocket 연결로 업그레이드하는 Manager를 구축하겠습니다. 또한, Manager는 모든 클라이언트를 추적하는 역할도 담당할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹소켓 연결을 처리하기 위해 Gorilla WebSocket 라이브러리를 사용할 것입니다. 이는 HTTP 요청을 취해 TCP 연결을 업그레이드하는 Upgrader를 생성하여 수행됩니다. Upgrader에 버퍼 크기를 할당할 것이며, 이는 모든 새로운 클라이언트에 적용될 것입니다.\n\n매니저는 /ws 엔드포인트에 호스팅할 serveWS라는 일반 HTTP HandlerFunc를 노출할 것입니다. 이 시점에서 연결을 업그레이드하고 간단히 다시 닫을 것이지만, 이렇게 연결할 수 있는지 확인할 수 있습니다.\n\nmanager.go라는 파일을 생성하고 코드를 gist에서 가져와서 채워 넣을 것입니다.\n\n또한, /ws 엔드포인트에 serveWS를 추가하여 프론트엔드가 연결할 수 있게 할 것입니다. main.go의 setupAPI 함수 내에서 새로운 매니저를 생성하고 HTTP 핸들러를 추가할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 다음 명령어를 사용하여 소프트웨어를 실행할 수 있어요.\n\n```js\ngo run *.go\n```\n\n웹사이트를 방문하여 계속 진행하시면 콘솔에 더 이상 오류가 출력되지 않고 연결이 수락된 것을 확인할 수 있을 거예요.\n\n## 클라이언트 및 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_5.png\" /\u003e\n\n모든 클라이언트 로직을 serveWS 함수에 추가할 수도 있지만, 그렇게 되면 매우 커질 수 있습니다. 클라이언트를 처리하는 데 사용되는 Client 구조체를 만드는 것을 추천합니다. 이 구조체는 클라이언트 관련 모든 로직을 담당하며 Manager에 의해 관리됩니다.\n\n또한 클라이언트는 메시지를 동시에 안전하게 읽고 쓸 수 있어야 합니다. Go의 WebSocket 연결은 동시에 하나의 작성기만 허용하므로 버퍼가없는 채널을 사용하여 처리할 수 있습니다. 이 기술은 Gorilla 라이브러리 개발자들이 권장하는 기술입니다.\n\n메시지를 구현하기 전에 Client 구조체를 생성하고 Manager에 클라이언트를 추가하거나 삭제할 수 있는 기능을 부여해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 지금 client.go라는 새 파일을 만들었어요. 일단은 작고 고객과 관련된 로직을 담을 거에요.\n\nClientList라는 새로운 타입을 만들 건데, 이건 간단히 클라이언트를 조회하는 데 사용할 수 있는 맵이에요. 그리고 각 클라이언트가 매니저를 참조하도록 하고 싶어요. 이렇게 하면 클라이언트에서도 상태를 쉽게 관리할 수 있거든.\n\n이제 매니저를 업데이트해서 새로 만든 ClientList를 보관하게 할 차례에요. 여러 사람이 동시에 연결할 수 있기 때문에 매니저도 sync.RWMutex를 구현해야 해요. 그래야 클라이언트 추가 전에 잠글 수 있어요.\n\n또, NewManager 함수를 업데이트해서 ClientList를 초기화할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 serveWS를 업데이트하여 새로운 클라이언트를 연결과 함께 생성하고 매니저에 추가할 것입니다.\n\n또한 클라이언트를 삽입하는 addClient 함수와 삭제하는 removeClient 함수로 매니저를 업데이트할 것입니다. 삭제 작업은 연결을 정상적으로 종료하도록 보장합니다.\n\n새 클라이언트를 수락하고 추가할 준비가 되어있습니다. 아직 클라이언트를 제대로 제거할 수는 없지만 곧 할 수 있을 것입니다.\n\n클라이언트가 메시지를 읽고 쓸 수 있는 기능을 구현해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메시지 읽기 및 쓰기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_6.png)\n\n메시지 읽기 및 쓰기는 쉬운 작업처럼 보일 수 있지만, 실제로는 그렇습니다. 그러나 많은 사람들이 놓치는 작은 함정이 있습니다. WebSocket 연결은 하나의 동시 라이터만 허용됩니다. 이 문제를 해결하기 위해 버퍼가 없는 채널을 잠금 장치로 활용할 수 있습니다.\n\n우리는 manager.go 내의 serveWS 함수를 업데이트하여 클라이언트 당 두 개의 고루틴을 생성하도록 변경할 것입니다. 현재는 작성 부분을 완전히 구현되기 전까지 주석 처리할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소켓에서 메시지를 읽는 작업은 ReadMessage를 사용하여 수행됩니다. 이 함수는 메시지 유형, 페이로드 및 오류를 반환합니다.\n\n메시지 유형은 전송되는 메시지의 유형이 무엇인지 설명하는 데 사용됩니다. Ping, pong, 데이터 또는 바이너리 메시지 등이 있습니다. 모든 유형은 RFC에서 확인할 수 있습니다.\n\n오류는 무언가 잘못되었을 경우 반환될 것이며, 연결이 닫힌 후에도 오류가 반환됩니다. 따라서 특정 닫기 메시지를 확인하여 출력하고, 일반적인 닫기에 대해서는 기록하지 않도록 하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 코드를 업데이트하고 몇 가지 메시지를 보내서 제대로 작동하는지 확인해볼 수 있어요.\n\nindex.html 파일 내에는 지금 sendMessage라는 함수가 있는데, 현재는 콘솔에 메시지를 출력하는 역할을 합니다. 간단히 이를 업데이트하여 대신 웹소켓으로 메시지를 전송하도록 수정할 수 있어요. JavaScript로 메시지를 보내는 것은 conn.send 함수를 사용하는 것만큼 쉽습니다.\n\n프로그램을 다시 시작하고 UI에 메시지를 입력한 후 Send Message 버튼을 누르면 메시지 유형과 페이로드가 stdout에 전송된 것을 확인할 수 있어요.\n\n지금은 메시지를 보낼 수만 있지만 메시지를 처리하는 것은 없습니다. 이제 메시지를 작성할 수 있는 기능을 추가할 시간이 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 WebSocket에 대해 한 번에 하나의 동시 프로세스로만 작성할 수 있다고 말한 것을 기억하시나요? 이러한 문제는 여러 가지 방법으로 해결할 수 있습니다. Gorilla가 권장하는 방법 중 하나는 동시 작성을 차단하기 위해 버퍼가 없는 채널을 사용하는 것입니다. 어떤 프로세스든 클라이언트 연결에 쓰기를 하려고 하면, 대신 이 메시지를 버퍼가 없는 채널로 작성합니다. 다른 프로세스가 현재 쓰기를 하는 경우에는 차단됩니다. 이렇게 함으로써 우리는 어떠한 동시성 문제도 피할 수 있게 됩니다.\n\n우리는 클라이언트 구조체를 업데이트하여 이 채널을 보유하도록 하고, 생성자 함수를 사용하여 이를 초기화할 것입니다.\n\nwriteMessages 함수는 readMessages와 매우 유사합니다. 하지만 이 경우에는 연결이 닫혔음을 알리는 Err을 받지 않습니다. 우리가 대신 egress 채널이 닫힐 때 프론트엔드 클라이언트에 CloseMessage를 보내줍니다.\n\nGo에서는 채널이 닫혔는지 여부를 알 수 있습니다. 두 번째 출력 매개변수를 수락하여 채널이 닫혔음을 나타내는 boolean을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 messagetype을 첫 번째 입력 매개변수로, payload를 두 번째 입력 매개변수로 받는 connections WriteMessage 함수를 사용할 거에요.\n\n만약 Go에 익숙하시다면, 현재 중복된 for select 문을 사용했다는 것을 알아채셨을 것입니다. 나중에 이 튜토리얼에서 선택 사항을 더 추가할 거에요.\n\n지금은 egress로 푸시된 모든 메시지가 클라이언트에게 전송됩니다. 현재 어떤 프로세스도 메시지를 egress에 작성하지 않지만, 작동 여부를 테스트하기 위해 빠른 해킹을 할 수 있습니다.\n\n우리는 readMessages에서 수신된 모든 메시지를 모든 다른 클라이언트에 브로드캐스트할 거에요. 간단히 말해, 모든 입력 메시지를 각 클라이언트의 egress로 출력함으로써 이 작업을 수행할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n29번 라인에 for 루프만 추가했습니다. 나중에 제거할 거에요. 이건 단지 전체 Reading과 Writing이 의도대로 작동하는지 테스트한 거예요.\n\n이제 프론트엔드를 업데이트해서 들어오는 메시지를 처리할 시간이에요. 자바스크립트는 웹소켓 이벤트를 다룰 때 일부 이벤트를 발생시킵니다. 그 이벤트들에 리스너를 적용할 수 있어요.\n\n모든 이벤트는 문서에 자세히 설명되어 있어요. 빠르게 다룰 수 있을 거예요.\n\n- Close — 웹소켓이 닫힐 때 발생합니다.\n- Error — 웹소켓이 오류로 인해 닫힐 때 발생합니다.\n- Message — 웹소켓이 새 메시지를 받았을 때 발생합니다.\n- Open — 웹소켓 연결이 열렸을 때 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트 엔드에서 할 일에 따라 이벤트 핸들러를 할당할 수 있어요. 저희는 메시지 이벤트에 관심이 있으므로, 일단 콘솔에 메시지를 출력하는 리스너를 추가할 거에요.\n\n연결이 열리면 보낸 이벤트를 출력하는 간단한 함수를 추가할 거예요. 이 이벤트 객체에는 보낸 타임스탬프와 메시지 유형과 같은 많은 데이터가 들어 있어요. 우리는 데이터 필드에 포함된 페이로드를 원할 거에요.\n\n이제 소프트웨어를 다시 시작하고 웹 사이트를 방문하여 몇 가지 메시지를 보내볼 수 있어요. 콘솔에서 이벤트가 보내고 받아지는 것을 볼 수 있어야 해요.\n\n지금은 읽기와 쓰기가 잘 되는 것을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이벤트 접근을 사용한 확장\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_7.png)\n\n지금은 연결하고 메시지를 보내고 받을 수 있습니다. 이 모든 것은 훌륭하며 기본 설정이 준비되었습니다.\n\n이제, 하나의 종류의 메시지만 보내려면 작동할 수도 있습니다. 보통 이벤트/유형 기반 접근 방식을 채택하면 웹소켓을 확장하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 말은 각 메시지를 보낼 때 기본 형식을 만든다는 것을 의미합니다. 이 형식에는 메시지 유형을 설명하는 특정 필드와 페이로드가 있습니다.\n\n이게 익숙해보이나요?\n\n왜냐하면 현재 WebSockets가 하는 것과 기본적으로 같습니다. 다만, 우리는 메시지를 JSON 개체로 보내고 응용 프로그램이 올바른 작업/함수를 수행하기 위해 라우팅할 수 있도록 합니다.\n\n이 방식은 사용하기 쉽고 확장 가능하며 웹소켓을 다양한 사용 사례에 활용할 수 있는 방법입니다. 이것은 RPC 솔루션이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 파일에 Event 클래스를 추가하여 수신 메시지를 구문 분석할 수 있도록 시작합니다. 그런 다음 이벤트를 routeEvent 함수에 전달하여 필드 유형의 값을 확인하고 해당 이벤트를 실제 핸들러로 전달합니다.\n\nonmessage 리스너에서는 Event 클래스로 맞는 JSON 형식의 데이터를 기대할 것입니다.\n\n또한 이벤트 이름과 페이로드를 입력으로 받는 sendEvent라는 함수를 생성할 것입니다. 이 함수는 입력을 기반으로 이벤트를 생성하고 JSON 형식으로 전송합니다.\n\n사용자가 sendMessage를 사용하여 메시지를 보낼 때마다 sendEvent를 호출할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 JavaScript 부분을 다루는 코드를 보여주는 gist입니다.\n\n이제 웹 사이트가 이벤트를 수락하고 보낼 수 있는 로직이 갖춰졌으니, 백엔드에서도 그 이벤트를 처리할 수 있도록 해야 합니다.\n\nevent.go라는 파일을 만들어 시작하세요. 이 파일에는 이벤트에 대한 모든 로직이 포함되어야 합니다.\n\n우리는 백엔드에 Event 구조체를 갖고 싶을 것이고, 이는 JavaScript의 Event 클래스와 동일한 모양이어야 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n페이로드의 데이터 타입이 json.RawMessage인 이유는 사용자가 원하는 페이로드를 보낼 수 있도록 하기 위해서입니다. 페이로드 데이터의 구조를 알고 있는 것은 이벤트 핸들러의 몫입니다.\n\n백엔드에서 메시지를 받을 때, 우리는 type 필드를 사용하여 적절한 EventHandler로 라우팅할 것이며, eventhandler는 함수 시그니처입니다. 따라서, 새로운 기능을 추가하려면 시그니처 패턴을 충족하는 새로운 함수를 만들면 됩니다.\n\nEventHandler 시그니처는 이벤트와 해당 메시지의 수신한 클라이언트를 받습니다. 또한 오류를 반환합니다. 클라이언트를 받는 이유는 일부 핸들러가 완료되면 응답을 반환하거나 클라이언트에게 다른 이벤트를 보낼 수 있기 때문입니다.\n\n또한 페이로드 내에서 예상되는 형식인 SendMessageEvent를 추가할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저가 EventHandlers의 맵을 저장하는 방식을 좋아합니다. 이렇게 하면 실제 응용 프로그램에서 매니저는 데이터베이스 저장소 등을 포함할 수 있어 쉽게 추가할 수 있습니다. 이를 추가하고 필요한 것들을 추가하는 데 사용되는 setupEventHandlers라는 새 함수를 추가할 것입니다.\n\n일련의 핸들러를 쉽게 확장할 수 있는 멋진 방법은 이 EventHandlers를 Map에 저장하고 Type을 키로 사용하는 것입니다. 따라서 이벤트를 경로로 지정하는 대신 모든 핸들러를 보유한 Map을 유지할 것입니다.\n\n들어오는 이벤트를 받아 맵에서 올바른 핸들러를 선택하는 routeEvent 함수를 추가할 것입니다.\n\n이벤트 인프라 전체를 마련하기 전에 Client를 변경해야 할 마지막 조각입니다. 클라이언트의 readMessages는 들어오는 JSON을 이벤트로 변환한 다음 매니저를 사용하여 이벤트를 경로로 지정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이언트의 출구 채널도 raw bytes를 보내는 대신 이벤트를 보내도록 수정할 것입니다. 이는 writeMessages를 변경하여 데이터를 보내기 전에 마샬해야 한다는 것을 의미합니다.\n\n백엔드를 다시 시작해보세요. `go run *.go`를 사용해서 메시지를 보내보세요. 'send_message [34 49 50 51 34]'와 같은 메시지가 출력되는 것을 확인할 수 있을 것입니다. 현재 Handler는 raw bytes를 파싱하지 않기 때문에 페이로드가 바이트로 출력될 것입니다.\n\n이를 구현하기 전에 WebSocket과 관련된 몇 가지 더 다뤄야 할 주제가 있습니다.\n\n## 하트비트 - 핑 \u0026 퐁\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![WebSocket Ping and Pong](/assets/img/2024-06-22-MasteringWebSocketsWithGo_8.png)\n\n웹소켓은 서버와 클라이언트 모두 Ping 프레임을 보낼 수 있습니다. Ping은 연결의 다른 부분이 여전히 살아 있는지 확인하는 데 사용됩니다.\n\n우리는 다른 연결이 살아 있는지 확인하는 것 뿐만 아니라 그것을 계속 유지하기도 합니다. 아무 것도 하지 않는 웹소켓은 오랫동안 유휴 상태로 있으면 닫힐 수 있습니다. Ping 및 Pong은 채널을 쉽게 유지하고, 저 트래픽의 장기간 연결이 예상치 못하게 닫히는 것을 피할 수 있게 해줍니다.\n\nPing을 보내면 상대방은 Pong으로 응답해야 합니다. 응답이 없으면 상대방이 더 이상 살아 있지 않다고 가정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 응답하지 않는 사람에게 계속 말하는 것은 논리적이죠.\n\n이를 구현하려면 서버 코드에서 진행해야 합니다. API 서버는 각 클라이언트에게 자주 Pings를 보내고 Pong을 기다립니다. 그리고 만약 Pong이 없다면 해당 클라이언트를 제거할 것입니다.\n\n먼저 사용할 타이머를 정의해 봅시다. client.go 내부에 pongWait와 pingInterval 변수를 생성할 것입니다. PongWait은 허용되는 Pong 사이의 초로, 클라이언트로부터의 각 Pong마다 리셋될 것입니다. 이 시간을 초과하면 연결을 끊을 것이며, 10초를 기다리는 것이 합리적이라고 할 수 있습니다.\n\npingInterval은 클라이언트에게 얼마나 자주 pings를 보내는지를 나타냅니다. 이것이 pongWait보다 낮아야 한다는 것에 주목하세요. PongWait보다 더 느리게 pings를 보내는 PingInterval을 가지고 있다면, PongWait가 취소될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 15초마다 핑을 보내지만 서버는 퐁을 받는 시간을 10초로만 허용한다면, 연결이 10초 후에 끊어질 것입니다.\n\n이제 서버가 각 클라이언트에게 핑 메시지를 보낼 필요가 있습니다. 이는 클라이언트의 writeMessages 함수 내에서 이뤄질 것입니다. 핑 간격(pingInterval)을 기반으로 트리거하는 타이머를 생성할 것이며, 트리거되면 비어있는 페이로드를 가진 PingMessage 유형의 메시지를 보낼 것입니다.\n\n이를 같은 함수 내에서 처리하는 이유는 연결이 동시 쓰기를 허용하지 않기 때문입니다. 이를 대신하여 egress에서 핑을 보내고 Event 구조체에 messageType 필드를 추가하는 다른 프로세스를 가질 수 있지만, 그 해결책이 조금 더 복잡하다고 생각합니다.\n\n같은 함수 내에서 이를 실행함으로써 동시적인 쓰기를 방지하는데, 외부출력(egress)에서 읽거나 타이먼의 여부를 따질 것이기 때문에 두 경우를 동시에 수행하는 것을 막을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPing을 보내고 있습니다. 프론트엔드 코드를 업데이트할 필요는 없어요. 왜냐하면 RFC 명세에 따르면 PingMessage가 올 때마다 PongMessage를 보내야하는 것으로 정의되어 있거든요. WebSocket을 지원하는 브라우저들은 클라이언트가 Ping 메시지에 응답하도록 자동으로 구성되어 있어요.\n\n그래서 서버가 클라이언트에 Ping을 보내고 있어요. 클라이언트는 Pong 메시지로 응답하지만 이제 어떻게 할까요?\n\n서버에 PongHandler를 구성해야 해요. PongHandler는 PongMessage를 수신하면 트리거되는 함수에요. readMessages를 업데이트해서 초기 PongWait 타이머를 설정하고 연결을 유지할 시간을 역으로 카운트 다운할 거에요.\n\ngorilla 패키지를 사용하면 SetReadDeadLine 함수를 통해 쉽게 설정할 수 있어요. 현재 시간을 가져와서 PongWait을 더한 다음, 해당 값을 연결에 설정할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 PongMessage를 수신할 때마다 타이머를 재설정하는 pongHandler 함수를 만들 것입니다. SetReadDeadLine을 사용하여 client가 PongMessage를 받을 때마다 타이머를 재설정합니다.\n\n좋아요, 이제 연결을 유지하여 웹사이트가 연결이 끊기지 않고 오랫동안 실행될 수 있습니다.\n\n소프트웨어를 다시 시작해보고 서버에서 Pong 및 Pong이 인쇄되는지 확인해보세요.\n\n대부분의 구현이 완료되었으니 이제 보안에 대해 고민해볼 시간입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메시지 크기 제한\n\n![image](/assets/img/2024-06-22-MasteringWebSocketsWithGo_9.png)\n\n보안 규칙 중 하나는 항상 악의적 사용을 기대해야 한다는 것입니다. 사람들이 할 수 있다면 그들은 할 것입니다. 따라서 항상 하는 좋은 것 중 하나는 서버에서 처리할 수 있는 메시지의 최대 크기를 제한하는 것입니다.\n\n이것은 악성 사용자가 DDOS에 대해 메가프레임을 보내거나 서버에서 다른 나쁜 일을 하는 것을 피하기 위함입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGorilla는 백엔드에서 구성할 때 SetReadLimit을 사용하여 허용된 바이트 수를 받는 것이 매우 쉽습니다. 메시지가 제한을 초과하면 연결이 닫힐 것입니다.\n\n사용자가 애플리케이션을 올바르게 사용하는 데 제한을 두지 않으려면 메시지의 크기를 알아야 합니다.\n\n우리가 만들고 있는 채팅에서는 프론트엔드에서 문자 제한을 부과한 뒤 가장 큰 메시지와 일치하는 최대 크기를 지정할 수 있습니다.\n\n각 메시지의 최대 크기를 512바이트로 설정하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n재시작하고 긴 메시지를 보내면 연결이 끊어질 수 있습니다.\n\n## 출처 확인\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_10.png)\n\n현재 상태에서는 어디서든 API에 연결할 수 있도록 허용하고 있습니다. 그렇게 하고 싶은 게 아니라면 이는 좋지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로, 프론트엔드는 어떤 서버에 호스팅되는데, 그 도메인이 유일하게 허용된 출처로 연결하는 것입니다. 이것은 Cross-Site Request Forgery를 방지하기 위해 수행됩니다.\n\nOrigin 확인을 다루기 위해 HTTP 요청을 수락하고 허용된 출처인지 간단한 문자열 체크를 통해 확인하는 함수를 작성할 수 있습니다.\n\n이 함수는 func(r \\*http.Request) bool 시그니처를 따라야 합니다. 왜냐하면 일반 HTTP 요청을 HTTP 연결로 업그레이드하는 업그레이더에는 해당 함수를 수락할 필드가 있기 때문입니다. 연결을 업그레이드하도록 허용하기 전에, 해당 요청에 대해 운영체제를 수행하여 출처를 확인합니다.\n\n테스트하고 싶다면, 스위치 문에서 8080 이외의 다른 포트로 변경하고 UI를 방문해보십시오. 그러면 출처가 허용되지 않음 메시지와 함께 출구할 것을 볼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인증\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_11.png)\n\nAPI의 중요한 부분 중 하나는 인증할 수 있는 사용자만 허용해야 한다는 것입니다.\n\nWebSocket에는 내장된 인증 유틸리티가 없습니다. 그러나 이는 문제가 되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWebSocket 연결이 설정되기 전에 사용자를 인증하겠습니다. serveWS 함수에서.\n\n이를 수행하는 두 가지 일반적인 방법이 있습니다. 두 가지 방법 모두 어느 정도 복잡하지만 심각한 문제는 아닙니다. 예전에는 Websocket 연결 URL에 사용자:비밀번호를 추가하여 일반적인 기본 인증을 전달할 수 있었지만 이 방법은 오랫동안 사용되지 않았습니다.\n\n추천되는 두 가지 솔루션이 있습니다.\n\n- 인증을 위한 일반적인 HTTP 요청이 OneTimePassword (OTP)을 반환하며 이를 WebSocket 연결에 사용할 수 있습니다.\n- WebSocket에 연결하되, 특정 인증 메시지가 전달된 후에만 메시지를 수락합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRetentionMap은 OTP를 보관하는 간단한 맵을 만들 것입니다. 5초가 지난 OTP는 삭제됩니다.\n\n또한 사용자를 인증하는 일반 HTTP 요청을 수락하는 새로운 로그인 엔드포인트를 만들어야 합니다. 이 예에서는 인증이 간단한 문자열 확인인데, 실제 프로덕션 응용프로그램에서는 인증을 실제 솔루션으로 대체해야 합니다. 인증 처리는 별도의 글을 작성할 주제입니다.\n\n사용자가 호출할 때 OTP를 검증하도록 serveWS를 업데이트해야 하며, 프론트 엔드가 연결 요청과 함께 OTP를 보내도록 해야 합니다.\n\n먼저 프론트 엔드를 변경하며 시작해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 로그인 양식을 만들고 연결 여부를 표시하는 텍스트와 함께 렌더링하려고 합니다. 따라서 index.html의 body를 업데이트하기로 합니다.\n\n다음으로, 문서 로드 이벤트에서 WebSocket 연결을 제거할 것입니다. 사용자가 로그인하기 전에 연결을 시도하지 않기 때문입니다.\n\nOTP 입력을 GET 매개변수로 추가하는 connectWebsocket 함수를 만들 것입니다. HTTP 헤더나 POST 매개변수로 추가하지 않는 이유는 브라우저에서 사용 가능한 WebSocket 클라이언트에서 지원되지 않기 때문입니다.\n\n또한 onload 이벤트를 업데이트해서 loginform에 핸들러를 할당할 것입니다. 이 핸들러는 /login으로 요청을 보내고 OTP가 반환될 때까지 기다린 후 WebSocket 연결을 트리거할 것입니다. 인증 실패 시 경고를 표시할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nonopen과 onclose을 사용하여 올바른 연결 상태를 사용자에게 출력할 수 있습니다. index.html의 스크립트 섹션을 다음 함수가 있는 형태로 업데이트하세요.\n\n이제 프론트 엔드를 시도해 볼 수 있으며, 로그인을 시도할 때 경고가 표시됩니다.\n\n프론트 엔드에 이러한 변경 사항을 적용한 후에는 백엔드에서 OTP를 확인할 수 있도록 해야 합니다. OTP를 생성하는 여러 가지 방법이 있으며, 도움이 되는 라이브러리도 있습니다. 이 튜토리얼을 간단하게 유지하기 위해 저희는 OTP를 생성하고 만료되면 이를 제거하며 확인하는 매우 기본적인 도우미 클래스를 작성했습니다. OTP를 처리하는 더 나은 방법들이 많이 있습니다.\n\notp.go라는 새 파일을 생성했으며 아래의 핵심 내용이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저를 업데이트하여 RetentionMap을 유지할 필요가 있습니다. 이를 사용하여 serveWS에서 OTP를 확인하고 사용자가 /login을 사용하여 로그인할 때 새 OTP를 생성할 수 있습니다. 보관 기간을 5초로 설정하고 기본 고루틴을 취소할 수 있는 컨텍스트를 수락해야 합니다.\n\n다음으로 /login에서 작동하는 핸들러를 구현해야 합니다. 간단한 핸들러입니다. 인증 부분을 실제 로그인 확인 시스템으로 교체해야 합니다. 핸들러는 사용자 이름과 비밀번호가 포함된 JSON 형식의 데이터를 수락할 것입니다.\n\n사용자 이름이 percy이고 비밀번호가 123 일 때 새 OTP를 생성하여 반환하고, 일치하지 않으면 권한이 없음 HTTP 상태를 반환할 것입니다.\n\n또한 serveWS를 업데이트하여 otp GET 매개변수를 수락하도록 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, main.go를 업데이트하여 로그인 엔드포인트를 호스팅하고 Manager에 Context를 전달해야 합니다.\n\n이 모든 것이 준비된 후에는 이제 프론트 엔드를 사용할 수 있어야 합니다. 그러나 로그인 양식을 성공적으로 사용한 후에만 가능합니다.\n\n해보세요. 메시지 보내기 버튼을 눌러도 아무 일도 일어나지 않을 것입니다. 그러나 로그인한 후에 WebSocket에서 메시지를 받아볼 수 있습니다.\n\n이벤트는 콘솔에만 출력할 것입니다. 하지만 우리가 그쪽으로 갈 것입니다. 마지막으로 다룰 보안 측면이 하나 더 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTTPS 및 WSS를 사용하여 트래픽 암호화하기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_12.png)\n\n우리는 지금 평문 트래픽을 사용하고 있습니다. 운영 환경으로 런칭하려면 HTTPS를 사용하는 것이 매우 중요합니다.\n\n웹소켓을 HTTPS를 사용하도록 전환하려면 프로토콜을 ws에서 wss로 업그레이드하면 됩니다. WSS는 웹소켓 보안(WebSockets Secure)의 약어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html 파일을 열어 connectWebsocket의 연결 부분을 WSS를 사용하도록 변경해주세요.\n\n지금 UI를 시도해도 연결되지 않을 것입니다. 왜냐하면 백엔드가 HTTPS를 지원하지 않기 때문입니다. 백엔드에 인증서와 키를 추가하여 이 문제를 해결할 수 있습니다.\n\n만약 소유하지 않았다고 걱정하지 마세요. 이 튜토리얼 중에 사용할 자체 서명 인증서를 만들 수 있습니다.\n\nOpenSSL을 사용하여 자체 서명 인증서를 생성하는 작은 스크립트를 만들었습니다. 그들의 Github에서 설치 노트를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngencert.bash라는 파일을 만들어주세요. Windows를 사용하시는 경우에는 명령을 수동으로 실행할 수 있습니다.\n\n명령을 실행하거나 bash 스크립트를 실행하세요.\n\nbash gencert.bash\n\n두 개의 새 파일인 server.key와 server.crt가 생성됩니다. 이 파일들을 절대로 공유하면 안 됩니다. 이 파일들을 GitHub에 실수로 푸시하지 않도록 더 안전한 위치에 저장해주세요. (진짜, 이런 일이 벌어집니다. 이런 실수를 찾는 봇들이 있습니다)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 작업을 완료하고 나면, main.go 파일을 업데이트하여 인증서를 사용하여 트래픽을 암호화하는 HTTP 서버를 호스팅해야 합니다. ListenAndServe 대신 ListenAndServeTLS를 사용하여 이 작업을 수행합니다. 동일한 방식으로 작동하지만 인증서 파일과 키 파일의 경로를 입력해야 합니다.\n\nHTTPS 도메인을 허용하도록 originChecker를 업데이트하는 것을 잊지 마세요.\n\ngo run \\*.go를 사용하여 서버를 다시 시작하고, 이번에는 https 사이트를 방문해보세요.\n\n다음과 같이 에러 메시지가 표시될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n2022/09/25 16:52:57 http: TLS handshake error from [::1]:51544: remote error: tls: unknown certificate\n```\n\n이것은 원격 오류입니다, 즉 클라이언트에서 서버로 전송된 것을 의미합니다. 이는 브라우저가 인증서 제공업체(즉, 여러분)를 인식하지 못하기 때문에 나타납니다. 이는 개발용으로 자체 서명된 인증서이므로 걱정하지 마세요.\n\n실제 인증서를 사용하고 있다면 해당 오류를 보지 못할 것입니다.\n\n축하합니다. 이제 HTTPS를 사용하고 있으며 WebSocket은 WSS를 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 몇 가지 이벤트 핸들러 구현\n\n이 튜토리얼을 마무리하기 전에, 실제 이벤트 핸들러를 구현하여 채팅이 제대로 작동하도록 해보고 싶어요.\n\n우리는 웹소켓 관련 모든 것에 대한 프레임워크만 구현했어요. 핸들러 관련한 비즈니스 로직을 구현할 때입니다.\n\n더 이상 아키텍처 원칙이나 웹소켓에 관한 정보를 다루지 않을 거예요. 우리는 최종적으로 실습을 통해 몇 가지 핸들러와 로직을 추가하는 간단한 과정을 진행할 거에요. 이 이벤트 접근 방식을 사용하여 웹소켓 API에 추가적인 핸들러와 로직을 어떻게 쉽게 추가할 수 있는지 확인하실 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저.go를 업데이트하여 setupEventHandlers에서 실제 함수를 받도록 변경하겠습니다.\n\n우리는 SendMessageHandler를 구현하고 싶습니다. 이 핸들러는 수신된 이벤트의 페이로드를 허용하고, 마샬링한 다음 다른 모든 클라이언트에게 출력해야 합니다.\n\nevent.go 파일에 다음을 추가할 수 있습니다.\n\n백엔드에서 해야 할 일은 여기까지입니다. 이제 프론트엔드를 정리해서 자바스크립트가 원하는 형식으로 Payload을 보내도록 해야 합니다. 그러니 JavaScript에서 동일한 클래스를 추가하여 이를 이벤트에 보내겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html의 Script 섹션 상단에 Event 유형에 대한 Class 인스턴스를 추가하십시오. 이러한 인스턴스는 event.go의 구조체와 일치해야 하므로 JSON 형식이 동일해야 합니다.\n\n그런 다음, 새 메시지를 보낼 때 트리거되는 sendMessage 함수를 업데이트해야 합니다. 올바른 페이로드 유형을 보내도록 만들어야 합니다.\n\n이것은 서버의 핸들러가 예상하는 SendMessageEvent 페이로드여야 합니다.\n\n마지막으로, 클라이언트에서 메시지를 수신하면 콘솔 대신 텍스트 영역에 출력해야 합니다. NewMessageEvent를 예상하고 해당 메시지를 텍스트 영역에 추가하는 함수로 전달하는 routeEvent를 업데이트해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 클라이언트 간에 메시지를 보낼 수 있어야 합니다. 이를 쉽게 시도할 수 있습니다. 두 개의 브라우저 탭에서 UI를 열고 로그인한 후 자신과 채팅을 시작하세요. 그러나 밤을 새우지는 마세요!\n\n모든 메시지를 모두에게 전달하지 않도록 새로운 채팅방을 관리할 수 있도록 쉽게 수정할 수 있습니다.\n\n우선 index.html에 새로운 ChangeRoomEvent를 추가하고, 사용자가 채팅방을 전환했음을 알리는 채팅을 업데이트하도록 시작합시다.\n\nmanager.go에 새로운 ChangeEvent를 추가하여 새로운 이벤트를 처리하도록 setupEventHandlers에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nClient 구조체에 채팅방 필드를 추가하여 사용자가 선택한 채팅방을 파악할 수 있습니다.\n\nevent.go 파일 내에 ChatRoomHandler를 추가하면 클라이언트의 새 채팅방 필드를 덮어쓸 수 있습니다.\n\n또한 SendMessageHandler에서는 이벤트를 전송하기 전에 다른 클라이언트가 동일한 방에 있는지 확인합니다.\n\n대단해요! 사용자가 채팅방을 전환할 수 있는 훌륭한 채팅 앱을 알게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI를 방문하고 한 번 시도해보세요!\n\n## 결론\n\n이 튜토리얼에서는 Websocket 서버를 위한 전체 프레임워크를 만들었습니다.\n\n우리는 웹소켓을 안전하고 확장 가능하며 관리되는 방식으로 수용하는 서버를 갖게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 다음 측면을 다루었습니다.\n\n- 웹소켓 연결 방법\n- 웹소켓으로 메시지를 효과적으로 읽고 쓰는 방법\n- 웹소켓을 이용한 Go 백앤드 API 구조화 방법\n- 관리가 용이한 웹소켓 API를 위한 이벤트 기반 디자인 사용 방법\n- PingPong이라는 하트 비팅 기법을 사용하여 연결을 유지하는 방법\n- 점보 프레임을 피하기 위해 메시지 크기 제한으로 사용자가 웹소켓을 악용하는 것을 방지하는 방법\n- 웹소켓이 허용하는 허용된 출처 제한 방법\n- OTP 티켓팅 시스템을 구현하여 웹소켓을 사용할 때 인증하는 방법\n- 웹소켓에 HTTPS 및 WSS 추가하는 방법\n\n이 튜토리얼이 WebSocket API를 시작하기 전에 학습해야 할 모든 것을 다루었다고 강하게 믿습니다.\n\n질문, 아이디어 또는 피드백이 있으면 언제든지 연락하길 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 즐겨 보셨길 바라요! 저는 정말 즐거웠어요.\n","ogImage":{"url":"/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png","tag":["Tech"],"readingTime":22},{"title":" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫","description":"","date":"2024-06-22 13:48","slug":"2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png\" /\u003e\n\n우리의 일상적인 개발 루틴에서는 종종 콘텐츠를 복사하거나 URL로부터 특정 매개변수를 가져오는 등 여러 일반적인 JavaScript 코드 스니펫을 사용합니다.\n\n이 코드 스니펫들은 개발의 편의를 위해 고정된 구현을 가지고 있습니다. 오늘은 자주 사용되는 7가지 코드 스니펫을 살펴보겠습니다.\n\n# 1️⃣ 클립보드로 콘텐츠 복사하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지정된 DOM 요소에서 내용을 사용자 클립보드로 복사하는 버튼을 사용하는 방법:\n\n```js\nconst copyToClipboard = (content) =\u003e {\n  const textarea = document.createElement(\"textarea\");\n  textarea.value = content;\n  document.body.appendChild(textarea);\n  textarea.select();\n  document.execCommand(\"Copy\");\n  textarea.remove();\n}\n```\n\n# 2️⃣ URLSearchParams를 사용하여 URL 검색 매개변수 가져 오기\n\n이것은 매우 흔한 작업입니다. 이 작업에 대해 regex에 의존했지만 이제는 더 간단한 접근 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getQueryByName = (name) =\u003e {\n  const query = new URLSearchParams(location.search);\n  return decodeURIComponent(query.get(name));\n}\n\n// 사용 예시:\n// URL: https://sunday.com/?name=fatfish\u0026age=100\nconst name = getQueryByName('name'); // fatfish\nconst age = getQueryByName('age'); // 100\nconst gender = getQueryByName('gender'); // null\n```\n\n# 3️⃣ 페이지 상단으로 스무스하게 스크롤\n\n페이지 상단으로 스무스하게 스크롤하는 방법:\n\n```js\nconst scrollToTop = () =\u003e {\n  const c = document.documentElement.scrollTop || document.body.scrollTop;\n  if (c \u003e 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, c - c / 8);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4️⃣ 현재 스크롤 위치 가져오기\n\n페이지의 현재 스크롤 위치를 검색합니다:\n\n```js\nconst getScrollPosition = (el = window) =\u003e ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,\n});\n\ngetScrollPosition(); // { x: 0, y: 215 }\n```\n\n# 5️⃣ 기기가 안드로이드인지 iOS인지 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 기기의 운영 체제를 식별하십시오:\n\n```js\nfunction getOSType() {\n  let u = navigator.userAgent;\n  let isAndroid = u.indexOf(\"Android\") \u003e -1 || u.indexOf(\"Linux\") \u003e -1;\n  let isIOS = !!u.match(/\\(i[^]+( U)? CPU.+Mac OS X/);\n  \n  if (isIOS) {\n    return 0; // iOS\n  } else if (isAndroid) {\n    return 1; // Android\n  } else {\n    return 2; // Other\n  }\n}\n\ngetOSType(); // 0은 iOS\n```\n\n# 6️⃣ 통화 포맷\n\n숫자를 통화 형식으로 변환하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst formatMoney = (money) =\u003e {\n  return money.toLocaleString();\n}\n\nconsole.log(formatMoney(123456789)); // '123,456,789'\nconsole.log(formatMoney(123456789.123)); // '123,456,789.123'\nconsole.log(formatMoney(123)); // '123'\n```\n\n# 7️⃣ 전체 화면 모드로 들어가고 나오기\n\n전체 화면으로 들어가고 나오기 함수:\n\n```js\n// 전체 화면으로 들어가기\nfunction fullScreen() {\n  let el = document.documentElement;\n  let rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen;\n  if (rfs) {\n    rfs.call(el);\n  } else if (typeof window.ActiveXObject !== \"undefined\") {\n    let wscript = new ActiveXObject(\"WScript.Shell\");\n    if (wscript != null) {\n      wscript.SendKeys(\"{F11}\");\n    }\n  }\n}\n\n// 전체 화면에서 나오기\nfunction exitScreen() {\n  let el = document;\n  let cfs = el.cancelFullScreen || el.webkitCancelFullScreen || el.mozCancelFullScreen || el.exitFullScreen;\n  if (cfs) {\n    cfs.call(el);\n  } else if (typeof window.ActiveXObject !== \"undefined\") {\n    let wscript = new ActiveXObject(\"WScript.Shell\");\n    if (wscript != null) {\n      wscript.SendKeys(\"{F11}\");\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쉽게 말해 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 추천하고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png","tag":["Tech"],"readingTime":4},{"title":"고급 자료 구조와 알고리즘 트라이tries 사용법 완벽 가이드","description":"","date":"2024-06-22 13:46","slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsTries","content":"\n\n## 트라이(Tries)로 직접 Google을 만들어보기: 잠재적 검색 엔진 구현의 내부를 살펴보겠습니다\n\n![image](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png)\n\n우리는 모두 웹 애플리케이션에 어떤 종류의 검색을 구축하는 데 익숙합니다. 특히 \"구축\"을 단순히 프로젝트에 Algolia 플러그인을 추가하고 SDK를 사용하여 그들의 API를 호출하는 것으로 생각한다면요.\n\n사실, 웹 애플리케이션에 기본 검색을 구현하는 것은 이제 그렇게 어렵지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 API라는 \"커튼\" 뒤에 사용되는 알고리즘이 어떤 종류인지 생각해 본 적이 있나요?\n\n오늘은 \"고급\" 데이터 구조라고 부르는 것을 살펴볼 것입니다. 이 구조는 텍스트 코퍼스 안에서 텍스트 검색을 수행하는 데 사용할 수 있는데, 그것이 바로 \"Tries\"입니다.\n\n저는 최근까지 이들에 대해 들어본 적이 없어서 여러분도 비슷하다면 놀라지 마세요. 하지만 걱정하지 마세요. 실제로는 생각보다 덜 위험하게 들립니다.\n\n자, 시작해 보죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 트라이(Tries)는 무엇인가요?\n\n우선 이해해야 할 것은 트라이가 트리(Tree)의 특별한 종류임을 알아야 합니다. 우리 모두가 트리를 알고 있죠. 각 노드가 다양한 수의 자식 노드 요소를 가질 수 있는 방법으로 노드 객체를 구성하는 방법입니다. 노드가 자식이 없으면 “잎 노드”라고 부릅니다(“트리” 비유를 유지하면서).\n\n이제 트라이는 특별한데, 각 노드는 알파벳순으로 최대 26개의 자식을 가질 수 있다는 점입니다 (다른 알파벳을 사용하려면 해당 숫자가 달라지겠지만, 모든 노드가 동일한 최대 자식 수를 가집니다).\n\n그 위에, 단어는 트리 전체에 \"수직으로\" (또는 레벨별로) 삽입됩니다. 이것이 트라이가 어떻게 보이는지 보여드리죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_1.png)\n\nTrie의 루트는 항상 \"null\"일 것입니다. 이 것이 이 데이터 구조의 한 가지 특징입니다. 제가 4개의 단어를 추가했음을 볼 수 있습니다:\n\n- All\n- Alt\n- Cat\n- Cow\n\n이것들을 수직으로 읽을 수 있습니다. 이것이 제가 이전에 \"레벨\"이라고 했던 의미입니다. 각 레벨은 우리 단어에서의 위치가 될 것입니다. 각 단어의 마지막 노드는 또한 플래그 \"isFinal\"과 함께 표시될 것입니다. 이 플래그가 얼마나 중요한 지 곧 알게 될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 자식을 가진 노드가 있을 때는 알파벳 순으로 정렬됩니다. 이는 데이터를 삽입하고 나중에 검색하는 알고리즘을 간단하게 만들기 위해 정렬된 것입니다. 기억하세요, 우리는 소문자 \"a\"부터 \"z\"까지 26개의 문자만 다룬다는 가정 아래 작업을 하고 있습니다. 보다 유연성을 가지려면 이 숫자를 높일 수 있으며 노드를 적절하게 색인화하는 방법을 찾을 수 있습니다.\n\n그래서 Trie로 가장 기본적인 두 가지 작업을 어떻게 구현할 수 있는지 살펴봅시다: 데이터를 삽입하고, 나중에 그 데이터를 검색하는 것입니다.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 2십 년 간의 지혜를 무료로 공유하는 제 뉴스레터에 구독해 보시는 건 어떨까요? \"The Rambling of an old developer\"에 가입해보세요!\n\n# Trie에 데이터 삽입하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 데이터 구조 안에 데이터를 삽입하는 데 필요한 기본 알고리즘은 간단합니다:\n\n- 삽입하려는 단어를 소문자로 변환합니다.\n- 루트의 자식 노드들 중에서 단어의 첫 글자를 찾습니다.\n- 글자가 예상한 위치에 있나요? 그렇다면 단어의 다음 글자로 넘어가고 방금 찾은 현재 글자의 자식 노드들 중에서 해당 글자를 찾습니다.\n- 글자를 찾을 수 없다면 새로운 노드를 추가하고 단어의 다음 글자로 넘어갑니다.\n\n글자가 떨어질 때까지 이러한 과정을 계속 반복하다가 마지막 글자를 “isFinal”로 표시하면 완료됩니다.\n\n예를 들어, \"ALL\"이라는 단어를 빈 Trie에 추가한다고 가정하면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 소문자를 \"모두\"로 변경합니다.\n- 루트에 첫 번째 자식 노드에 \"a\"가 있나요? 아니요, 비어 있기 때문에 첫 번째 자식 슬롯에 새 노드를 추가합니다.\n- 이제 첫 번째 \"l\"로 이동합니다. 이 \"l\"은 \"a\"의 12번째 자식에 없습니다. 왜냐하면 후자가 방금 추가되었기 때문입니다. 따라서 12번째 자식 슬롯에 \"l\"을 위한 새 노드를 추가합니다.\n- 마지막 \"l\"로 이동하면 똑같은 작업을 반복합니다. 이전 글자(첫 번째 \"l\") 내에서 12번째 자식 슬롯을 찾아서 비어 있기 때문에 마지막 \"l\"을 위한 새 노드를 만듭니다. 유일한 차이점은 \"isFinal\"로도 표시한다는 것입니다.\n\n이제 \"alt\" 단어를 추가하려면 첫 두 글자가 이미 있음을 알 수 있습니다. 따라서 해당 노드를 추가하는 부분을 건너 뜁니다.\n\nJavaScript로 어떻게 변환되는지 이해하기 위해 코드를 살펴봅시다:\n\n노드는 구조가 매우 간단합니다. 솔직히 말해서 레이블 속성조차 선택 사항입니다. 노드의 실제 위치가 나타내는 글자를 결정하기 때문입니다. 그렇다고 해서 이해하기 쉽다고 생각하기 때문에 이 방법을 사용하는 것이 더 좋다고 생각합니다. 마음대로 수정하셔도 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 Trie는 이렇게 생겼어요:\n\n보시다시피, 생성 시에 \"루트\" 노드는 null로 초기화되고 새로운 단어를 삽입할 때마다 루트의 자식부터 시작해서 이동합니다.\n\n단어의 마지막 노드는 isFinalLetter로 표시되어 해당 단어의 끝을 알 수 있습니다. 이를 통해 검색이 어떻게 수행되는지 알아보기 전에 중요한 부분이 됩니다.\n\n# Trie 내에서 데이터 검색하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n검색은 실제로 삽입과 매우 유사합니다. 우리는 동일한 알고리즘을 따라 Trie를 통과해야 하기 때문에 찾으려는 글자가 없는 경우, 추가하는 대신 false를 반환해야 합니다.\n\n이제 검색에 대한 다른 작은 세부 사항은 단어의 끝에서 모든 글자를 찾았을 때, 마지막 노드가 isFinalLetter로 표시되어 있는지 확인해야 한다는 것입니다. 그럴 경우, Trie에 단어가 존재하는 것을 의미하고, 그렇지 않으면 삽입된 단어의 부분 문자열을 찾고 있으므로 \"부분\" 일치를 얻었다는 것을 의미합니다.\n\n기본적으로 Trie에 \"Words\"라는 단어가 있는 것을 상상해보세요.\n\n- \"want\"를 찾는 경우에는 \"w\"의 자식들에서 \"a\"를 찾을 수 없기 때문에 \"there\"가 아닙니다.\n- \"word\"를 찾는 경우에는 \"d\"에 도달하지만 \"d\"가 isFinalLetter로 표시되지 않으므로 \"word\"가 Trie에 없음을 알 수 있지만 그 단어를 포함하는 다른 단어를 찾은 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 코드로 어떻게 보이는지 확인해 봅시다:\n\n이전과 동일한 클래스이지만 검색 방법이 바뀌어서 더 읽기 쉽습니다.\n\n이 메서드는 다음 세 가지 값을 반환합니다:\n\n- 일치하는 값이 없으면 false를 반환합니다.\n- 최종 글자까지 도달하여 마지막 글자가 실제로 isFinalLetter로 표시된 경우 full-match를 반환합니다\n- 끝까지 도달하였지만 마지막 글자가 표시되지 않은 경우 partial-match를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법에서는 forEach를 일반 for로 바꿨어요. 후자를 사용하면 간단한 return 문으로 빨리 반환할 수 있지만, 전자는 전체 단어를 모두 확인할 때까지 빠져나올 수 없어요.\n\n다음 예제는 지금까지 본 모든 것을 사용합니다:\n\n결과는 당신이 기대하는 대로 이렇습니다:\n\n```js\n'fer'를 찾고 있습니다: 완전일치\n'angel'을 찾고 있습니다: 없음\n'fernando2'을 찾고 있습니다: 없음\n'federico'를 찾고 있습니다: 완전일치\n'fern'을 찾고 있습니다: 부분일치\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 한 걸음 더 나아가보죠. 실험은 재미있지만, 실제 애플리케이션에서 어떻게 사용할까요? 그렇다면 Next 앱에 이를 추가하는 방법을 보겠습니다!\n\n# Next 내 Trie-검색 사용하기\n\n사용하고 싶은 프레임워크를 선택할 수 있습니다. 저는 Next를 선택했는데, 그 이유는 좋은 API 프레임워크를 제공하기 때문입니다.\n\n간단하게 npx create-next-app@latest 명령을 사용해서 새로운 앱을 만들겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 앱의 폴더 구조 안에 다음과 같은 새 폴더를 만들 것입니다:\n\n- /components: 여기에 새로운 검색 컴포넌트를 추가할 것입니다.\n- /utils: 여기에는 방금 보여드린 클래스가 있는 tries 폴더를 저장하고 새로운 search.js 파일을 추가할 것입니다. 이 파일은 우리의 Trie에 대한 게이트웨이 역할을 할 것입니다.\n\n검색 서비스는 백엔드에 유지할 것이므로, 우리는 페이지/api/search 폴더 안에 추가할 API 엔드포인트를 통해 상호 작용할 것입니다.\n\n마지막으로, 당신의 폴더 구조는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_2.png\" /\u003e\n\n## 검색 엔드포인트 추가\n\n이 예제에서는 검색 엔드포인트를 만들어 보겠습니다. 매우 간단하게 처리할 것이며 모든 요청을 처리하고 검색 문자열이 저장될 q 쿼리 매개변수를 찾을 것입니다.\n\n따라서 전체 코드는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조금 후에 getSearch 함수에 대해 걱정할 거예요. 이제 알아둬야 할 것은 당신에게 Trie 인스턴스에 액세스할 수 있다는 것뿐이에요.\n\n## 검색 UI 구성요소 추가\n\n사용자가 무언가를 검색하고 어떤 피드백을 보여줄 수 있도록 UI 구성 요소가 필요할 거예요.\n\n우리 경우에는 피드백이 \"찾을 수 없음\", \"부분 일치\" 또는 \"전체 일치\"일 거예요. 하지만 당신이 원하는 만큼 창의적이 해도 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 컴포넌트의 코드는 다음과 같이 보입니다:\n\n다시 말하지만, 이것은 그리 미친 짓은 아닙니다. 입력 필드가 변경될 때마다 새 API로 Fetch 요청을 수행하는 컴포넌트뿐입니다. 이것을 개선하고 요청의 수를 제어하는 방법을 찾을 수 있을 겁니다.\n\n다음은 렌더링된 결과입니다 (여기에는 스타일이 없으므로 예쁘지 않을 수 있습니다!):\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n방금 말했잖아요!\n\n이제 getSearch 함수를 살펴봅시다. 이 함수는 흥미로운 일을 하고 있어요.\n\n## 검색 게이트웨이\n\n무언가를 검색할 수 있도록 하려면, 우리 Trie에 그 \"무언가\"를 먼저 삽입해야 합니다. 그래서 그 \"무언가\"를 언제 삽입하는 거죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 검색 엔진의 \"코퍼스\"를 첫 번째 검색 요청으로 로드하기로 결정했습니다. 그리고 메모리에 Trie를 유지하고 기본 싱글톤 패턴을 구현하여 덮어쓰지 않도록하겠습니다. 다음과 같이요:\n\n여러분은 아마도 제가 실제 Trie를 처음으로 생성할 때 몇 가지 단어를 Trie에 추가하는 loadIndex 함수를 호출하는 것을 확인할 수 있습니다. 그런 다음에는 처음 생성한 인스턴스를 반환하는 것 뿐입니다.\n\n이 방법은 전체 앱 실행 중에 단일 인스턴스를 유지하는 깔끔한 방법입니다.\n\n이 예제를 더 자세히 살펴보고 싶다면, 여기에서 코드를 확인해보세요. 즐겁게 이용하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 Trie에 대해 들어보셨나요? 혹은 더 좋은 경우, 어디에 사용해 본 적이 있나요? 댓글에서 여러분의 경험을 공유해 주세요. 무엇을 해봤는지 알고 싶어요!\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 만들기\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_4.png)\n\nBit은 25만 명 이상의 개발자가 컴포넌트로 앱을 구축하는 데 도움을 주는 오픈 소스 도구입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떠한 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업이 쉬워지고 더 빠르게 개발할 수 있습니다.\n\n→ 더 알아보기\n\n애플리케이션을 구성 요소로 나누어 앱 개발을 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 누려보세요:\n\n## → Micro-Frontends\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 단일 저장소\n\n# 자세히 알아보기","ogImage":{"url":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsTries_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 인기를 끌고 있는 오픈 소스 도구 4가지","description":"","date":"2024-06-22 13:44","slug":"2024-06-22-4TrendingOpenSourcetools","content":"\n\n효율적인 응용 프로그램을 개발하기 위한 효과적인 도구와 플랫폼의 필요성은 절대적입니다. 이 분야에서 큰 발전을 이루고 있는 네 가지 주목할만한 오픈 소스 솔루션은 Bisheng, CesiumJS, Dokploy 및 AgentScope입니다.\n\n각 플랫폼은 다양한 응용 프로그램 개발 측면을 고려한 독특한 기능과 기능을 제공합니다. 큰 언어 모델부터 대화형 3D 매핑, 셀프 호스트된 PaaS 솔루션 및 다중 에이전트 시스템까지 다양한 기능을 갖추고 있습니다. 본 문서에서는 이러한 혁신적인 도구들에 대한 개요를 제공하며, 주요 기능 및 잠재적인 응용 분야를 강조합니다.\n\n## 더 읽기:\n\nUX를 위한 카드 정렬 이해\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4가지 개방형 소스 도구로 설명 가능한 AI\n\n값에 의한 전달과 참조에 의한 전달 이해하기\n\n자원봉사 기회를 찾을 수 있는 새로운 앱\n\n그리고 구독 무료인 AI 뉴스레터 BrainScriblr도 쓰고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비생\n\n비생은 대규모 언어 모델 (LLM) 애플리케이션의 개발을 가속화하고 간소화하기 위해 디자인되었습니다. Apache 2.0 라이선스 하에 출시되었으며, 비즈니스 사용자와 기술 전문가 모두에게 액세스 가능하도록 LLM 개발을 민주화하는 것을 목표로 합니다.\n\n비생은 사전 구성된 애플리케이션 템플릿 및 직관적인 폼 작성 프로세스를 통해 비즈니스 사용자에게 사용 용이성이 제공됩니다. 이를 통해 깊은 기술적 전문 지식이 없는 사람들도 빠르게 LLM을 중심으로 한 지능적인 애플리케이션을 구축할 수 있습니다.\n\nLLM 기술에 익숙한 개발자들을 위해, 비생은 수백 가지 개발 구성 요소와 시각적 프로세스 조종 기능을 제공하여 다양하고 정교한 LLM 애플리케이션을 만들 수 있도록 광범위한 유연성을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBisheng은 계약 검토, 신용 조사, 문서 요약과 같은 작업에 대한 분석 보고서 생성을 포함한 다양한 응용 프로그램을 개발할 수 있도록 지원합니다. 또한 사용 설명서 Q\u0026A 및 연구 보고서 지식 베이스를 포함한 지식 베이스 Q\u0026A 시스템의 작성을 지원합니다.\n\n마지막으로 Bisheng은 면접관이나 외국어 교사로서의 역할 연기, 이력서 최적화, 그리고 계약서, 공학 보고서 등에서 요소를 추출하는 작업을 쉽게 할 수 있도록 지원합니다.\n\n## Cesiumjs\n\nCesiumJS는 플러그인 없이 웹 브라우저에서 대화형 3D 지구 및 지도를 생성하기 위한 오픈 소스 JavaScript 라이브러리입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCesiumJS는 하드웨어 가속화된 그래픽을 위해 WebGL을 사용하며 크로스 플랫폼, 크로스 브라우저이며 대규모 데이터 시각화에 최적화되어 있습니다. 강력한 상호 운용성을 위해 오픈 포맷으로 구축되어 있으며 대규모 데이터 세트에 대한 확장성을 제공합니다. 주요 기능으로는 3D Tiles 스트리밍 및 기타 표준 포맷, 고정밀도 WGS84 지구를 사용한 데이터 시각화 및 분석, 데스크톱이나 모바일 사용자와 데이터 공유가 있습니다.\n\nCesiumJS는 Apache 2.0 라이선스로 출시되었으며 2012년부터 오픈 소스로 제공되어 상업적 및 비상업적 사용 모두 무료입니다. 시작하려면 CDN에서 가져오거나 npm을 통해 설치할 수 있습니다. CesiumJS 퀵 스타트 가이드는 실제 데이터를 사용하여 앱을 설정하는 단계별 지침을 제공합니다.\n\n또한 CesiumJS는 ArcGIS 위치 서비스와 통합되어 개발자가 지오코딩, 루팅, 데이터 풍부화 및 공간 쿼리와 같은 기능에 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 독플로이\n\n독플로이는 배포와 애플리케이션 및 데이터베이스 관리를 간단하게 해주는 무료 오픈 소스 자체 호스팅 가능한 플랫폼서비스(PaaS) 입니다.\n\n독플로이는 Node.js, PHP, Python, Go, Ruby 등 도커화할 수 있는 모든 종류의 애플리케이션을 배포하는 것을 지원합니다. 또한 MySQL, PostgreSQL, MongoDB, MariaDB, Redis와 같은 데이터베이스의 생성과 관리도 지원합니다.\n\n독플로이의 중요한 기능은 데이터베이스에 대한 자동 백업, Docker Compose의 네이티브 지원, Docker Swarm을 사용한 멀티 노드 스케일링, 오픈 소스 템플릿의 원클릭 배포, 자원의 실시간 모니터링 및 사용자 친화적인 웹 인터페이스가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDokploy는 Vercel, Netlify 및 Heroku와 같은 플랫폼 대안으로 개방형 소스로 위치하고 있습니다. 사용자들은 자체 VPS에 플랫폼을 호스팅하고 벤더 잠금 현상이나 관리 서비스 비용을 피할 수 있습니다.\n\nDokploy는 각 애플리케이션에 대한 웹훅 URL을 제공하여 GitHub 또는 DockerHub와 같은 서비스와 통합하여 자동 배포에 사용할 수 있습니다. 다른 태그가 있는 여러 이미지가 푸시될 때 Dokploy는 현재 각 태그별로 별도의 배포 작업을 트리거합니다.\n\nDokploy는 비교적 새로운 프로젝트이지만 활발한 커뮤니티를 갖고 있으며 새로운 기능으로 지속적으로 개선 중입니다. 다른 오픈 소스 PaaS 대안으로는 CapRover, KintoHub 및 Render가 있습니다.\n\n![이미지](/assets/img/2024-06-22-4TrendingOpenSourcetools_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 에이전트 범위\n\n에이전트 스코프는 개발자가 대형 언어 모델(LLMs)을 사용하여 더 쉽게 애플리케이션을 개발할 수 있는 오픈 소스 멀티에이전트 플랫폼입니다.\n\n에이전트 스코프는 LLM을 에이전트에 통합하여 고급 추론, 지식, 대화 능력을 가능하게 하는 LLM-강화형 에이전트, 유연한 에이전트 상호작용을 지원하는 에이전트 상호작용, 중앙화된 프로그래밍 방식으로 분산 멀티에이전트 애플리케이션을 구축하기 위한 Actor-Based Distribution과 같은 세 가지 고수준 기능을 제공합니다.\n\n에이전트 스코프는 OpenAI (gpt-4, gpt-3.5-turbo 등), Hugging Face, BLOOM, Llama, Vicuna, Alpaca, ChatGLM, MOSS 등 다양한 모델 라이브러리 및 API를 지원합니다. 이를 쉽게 통합할 수 있도록 `ModelWrapper` 클래스를 제공합니다. 최신 릴리스(v0.0.4)에서는 에이전트 스코프 워크스테이션, AgentScope에 대한 질문에 대답하는 코파일럿, Llama3 및 DashScope와 같은 더 많은 모델 지원, 새로운 예제 등 여러 새로운 기능을 소개했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAgentScope은 Python 3.9 이상을 필요로 하며 소스로부터 설치할 수 있습니다. 자세한 설치 지침은 README에 제공됩니다. 해당 저장소에는 AgentScope의 기능을 보여주는 다양한 예제가 포함되어 있습니다. 예를 들어 멀티 에이전트 대화, AI 지원 프로그래밍, AI 지원 쉘, 멀티 에이전트 논쟁, 고모쿠 게임 등이 있습니다.\n\n이 프로젝트는 다양한 기여자들로 이루어진 활발한 커뮤니티를 가지고 있습니다. 해당 저장소에는 최근 풀 리퀘스트와 새로운 기능, 향상 사항, 버그 수정에 대한 이슈가 토론되고 있습니다.\n\n결론적으로, AgentScope은 대형 언어 모델을 활용한 멀티 에이전트 애플리케이션 개발을 간단하게 만드는 유연하고 견고한 오픈 소스 플랫폼입니다.\n\n이 네 플랫폼은 오픈 소스 개발 도구의 최첨단을 대표하며, 각각 기술 생태계 내에서 특정 요구 사항을 해결합니다. LLM 애플리케이션 생성, 3D 데이터 시각화, 쉬운 애플리케이션 배포, 멀티 에이전트 시스템 구축 등을 위한 강력한 솔루션을 제공하는 Bisheng, CesiumJS, Dokploy, 그리고 AgentScope은 현대 개발자들을 위한 강력한 도구입니다.","ogImage":{"url":"/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png"},"coverImage":"/assets/img/2024-06-22-4TrendingOpenSourcetools_0.png","tag":["Tech"],"readingTime":5},{"title":"경이로운 WebGL 점 구체 만드는 방법","description":"","date":"2024-06-22 13:43","slug":"2024-06-22-StunningWebGLDotSpheres","content":"\n\n\n![Image](/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png)\n\n최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).\n\n두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.\n\n# 씬 설정하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.\n\n씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.\n\n```js\n// 씬을 설정합니다.\nconst scene = new THREE.Scene();\n\n// 모든 점의 geometries를 보관할 배열을 정의합니다.\nconst dotGeometries = [];\n\n// 점에서 사용할 빈 벡터를 생성합니다.\nconst vector = new THREE.Vector3();\n\n// 이곳에서 점을 생성하고 위치를 지정합니다!\n```\n\n점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.\nconst mergedDotGeometries = BufferGeometryUtils.mergeBufferGeometries(\n  dotGeometries\n);\n\n// 점을 위한 재질을 정의합니다.\nconst dotMaterial = new THREE.MeshBasicMaterial({\n  color: DOT_COLOR,\n  side: THREE.DoubleSide\n});\n\n// 점 지오메트리와 재질에서 점 메시를 생성합니다.\nconst dotMesh = new THREE.Mesh(mergedDotGeometries, dotMaterial);\n\n// 점 메시를 씬에 추가합니다.\nscene.add(dotMesh);\n```\n\n이제 어떻게 점을 생성하고 배치할지 살펴봅시다.\n\n# 기본적인 접근 방법\n\n구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).\n\n두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.\n\n```js\n// 위도를 반복합니다.\nfor (let lat = 0; lat \u003c LATITUDE_COUNT; lat += 1) {\n  // 경도를 반복합니다.\n  for (let lng = 0; lng \u003c LONGITUDE_COUNT; lng += 1) {\n    // 점에 대한 geometry를 생성합니다.\n    const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n    // 점을 위한 phi와 theta 각도를 정의합니다.\n    const phi = (Math.PI / LATITUDE_COUNT) * lat;\n    const theta = ((2 * Math.PI) / LONGITUDE_COUNT) * lng;\n\n    // 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.\n    vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n    // 점이 올바른 방향을 향하도록 합니다.\n    dotGeometry.lookAt(vector);\n\n    // 점 geometry를 올바른 위치로 이동합니다.\n    dotGeometry.translate(vector.x, vector.y, vector.z);\n\n    // 위치 지정 geometry를 배열에 추가합니다.\n    dotGeometries.push(dotGeometry);\n  }\n}\n```\n\n이렇게 해서 다음 결과를 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.\n\n# 실로택시스 방법론\n\n해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.\n\n이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 점의 개수만큼 반복합니다.\nfor (let dot = 0; dot \u003c DOT_COUNT; dot += 1) {\n  // 점을 위한 geometry를 생성합니다.\n  const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n\n  // 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.\n  const phi = Math.acos(-1 + (2 * dot) / DOT_COUNT);\n  const theta = Math.sqrt(DOT_COUNT * Math.PI) * phi;\n\n  // 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.\n  vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n  ...\n\n}\n```\n\n위와 같은 결과가 나타납니다.\n\n이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?\n\n# 선형 접근법\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.\n\n여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.\n\n```js\n// 위도 선을 가로지르는 루프\n  for (let lat = 0; lat \u003c LATITUDE_COUNT; lat += 1) {\n    // 위도선의 반지름 계산\n    const radius =\n      Math.cos((-90 + (180 / LATITUDE_COUNT) * lat) * (Math.PI / 180)) *\n      SPHERE_RADIUS;\n    // 위도선의 둘레 계산\n    const latitudeCircumference = radius * Math.PI * 2 * 2;\n    // 해당 위도선에 필요한 점의 수 계산\n    const latitudeDotCount = Math.ceil(latitudeCircumference * DOT_DENSITY);\n\n    // 해당 위도선의 점 수에 대해 루프 수행\n    for (let dot = 0; dot \u003c latitudeDotCount; dot += 1) {\n      const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n      // 점을 위한 파이와 세타 각도 계산\n      const phi = (Math.PI / LATITUDE_COUNT) * lat;\n      const theta = ((2 * Math.PI) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n```\n\n이로써 매우 만족스러운 점 배치가 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?\n\n# 모양 마스킹\n\n더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.\n\n이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이미지 로더를 초기화합니다.\nconst imageLoader = new THREE.ImageLoader();\n\n// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.\nimageLoader.load(MASK_IMAGE, (image) =\u003e {\n    // HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.\n    const tempCanvas = document.createElement(\"canvas\");\n\n    tempCanvas.width = image.width;\n    tempCanvas.height = image.height;\n\n    const ctx = tempCanvas.getContext(\"2d\");\n\n    ctx.drawImage(image, 0, 0);\n\n    // 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.\n    const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n    renderScene(imageData);\n});\n```\n\n이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.\n\n```js\n// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.\nconst spherePointToUV = (dotCenter, sphereCenter) =\u003e {\n    // 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.\n    const newVector = new THREE.Vector3();\n    newVector.subVectors(sphereCenter, dotCenter).normalize();\n\n    // 점의 UV 좌표를 계산해서 벡터로 반환합니다.\n    const uvX = 1 - (0.5 + Math.atan2(newVector.z, newVector.x) / (2 * Math.PI));\n    const uvY = 0.5 + Math.asin(newVector.y) / Math.PI;\n\n    return new THREE.Vector2(uvX, uvY);\n};\n```\n\n두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.\nconst sampleImage = (imageData, uv) =\u003e {\n  // UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.\n  const point =\n    4 * Math.floor(uv.x * imageData.width) +\n    Math.floor(uv.y * imageData.height) * (4 * imageData.width);\n\n  return imageData.data.slice(point, point + 4);\n};\n```\n\n이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.\n\n```js\n// 도트 geometry를 위치로 이동합니다.\ndotGeometry.translate(vector.x, vector.y, vector.z);\n\n// 도트의 경계 구를 찾습니다.\ndotGeometry.computeBoundingSphere();\n\n// 랜드 이미지에서 도트의 UV 위치를 찾습니다.\nconst uv = spherePointToUV(\n  dotGeometry.boundingSphere.center,\n  new THREE.Vector3()\n);\n\n// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.\nconst sampledPixel = sampleImage(imageData, uv);\n\n// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),\n// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.\nif (sampledPixel[3]) {\n  // 위치 지정 geometry를 배열에 추가합니다.\n  dotGeometries.push(dotGeometry);\n}\n```\n\n실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:\n\n또한 텍스트를 렌더링할 수도 있어요:\n\n# 여기까지!\n\n이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.","ogImage":{"url":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png"},"coverImage":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png","tag":["Tech"],"readingTime":9},{"title":"JavaScript로 배열 흉내내기 Objectassign, arr 방법","description":"","date":"2024-06-22 12:53","slug":"2024-06-22-JavaScriptFakesArraysObjectassignarr","content":"\n\n## 자바스크립트에서 배열은 사실 객체임을 비밀로 만들 필요가 없습니다. 그런데 이를 무시하는 대신, 배열에 객체 메소드를 적용해보면 어떨까요?..\n\n![이미지](/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png)\n\n## 1. Object.assign()\n\n자바스크립트는 배열을 객체로 변환하는 데 전혀 문제가 없다고 인식합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign({}, arr);\nconsole.log(newObj); // 출력: {0: 1, 1: 2, 2: 3}\n```\n\n하지만 재미있는 점은 인수를 바꾸고 일부 비어 있지 않은 객체를 사용하는 경우 발생합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // 출력: (3) [1, 2, 3, a: 4, b: 5]\n```\n\n이제 \"무언가\"를 찾을 수 없는 전형적인 이름을 가진: 반 배열 — 반 객체입니다. 이것이 어떻게 동작하는지는 심지어 더더욱 우스꽝스럽습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // Output: [1, 2, 3, a: 4, b: 5]\nconsole.log(arr.a); // Output: 4\nconsole.log(arr.length); // Output: 3\nconsole.log(JSON.stringify(arr)); // Output: [1,2,3]\n```\n\n자바스크립트는 괴상한 짓을 할 때 양심에 찔리는 듯한 척합니다. 한쪽에서는 배열에 문제가 없는 것처럼 꾸미지만, “이상한” 것들에 명시적으로 접근하면 추악한 진실을 드러내야 할 뿐입니다.\n\n## 2. Object.freeze()\n\nObject.freeze()는 객체에 새로운 속성이 추가되거나 기존 속성이 제거 또는 수정되지 못하도록 합니다. 배열과 함께 완벽하게 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nObject.freeze(arr);\narr[0] = 10; // 영향이 없음\nconsole.log(arr); // 출력: [1, 2, 3]\narr.push(4); // TypeError: Cannot add property 3, object is not extensible\n```\n\n여기서는 \"object is not extensible\"라고 속이지 않고 그냥 객체라고 합니다.\n\n## 3. Object.seal() 사용하기\n\nObject.seal()은 객체에 새로운 속성을 추가하지 못하게 하지만 기존 속성의 수정은 허용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nObject.seal(arr);\narr[0] = 10; // 작동합니다\nconsole.log(arr); // 출력: [10, 2, 3]\narr.push(4); // TypeError: 프로퍼티를 추가할 수 없습니다\n```\n\n이 도구는 정의된 크기로 배열을 생성할 수 있게 해줄 수 있었지만, 제대로 작동했더라면 유용한 도구가 될 수도 있었습니다. 왜냐하면:\n\n```js\nconst arr = []\narr.length = 10\nconsole.log(arr) // 출력: [empty × 10]\nObject.seal(arr)\narr[0] = 1 // 여기에 오류가 없습니다\nconsole.log(arr) // 안타깝게도, 다시 출력은: [empty × 10]\n```\n\n## 4. Object.getOwnPropertyDescriptors() 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`Object.getOwnPropertyDescriptors()`은 객체의 모든 소유 속성 설명자를 반환합니다. 배열에서 사용할 때는 배열 색인에 대한 설명자도 포함됩니다.\n\n```js\nconst arr = [1, 2, 3];\nconst descriptors = Object.getOwnPropertyDescriptors(arr);\nconsole.log(descriptors);\n/* 결과:\n{\n  \"0\": { value: 1, writable: true, enumerable: true, configurable: true },\n  \"1\": { value: 2, writable: true, enumerable: true, configurable: true },\n  \"2\": { value: 3, writable: true, enumerable: true, configurable: true },\n  \"length\": { value: 3, writable: true, enumerable: false, configurable: false }\n}\n*/\n```\n\nJS 배열의 진정한 성격을 보여주는 쇼케이스입니다.\n\n## 5. `Object.getPrototypeOf()` 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObject.getPrototypeOf()은 지정된 객체의 프로토타입을 반환합니다. 배열에 사용하면 Array.prototype을 반환합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst proto = Object.getPrototypeOf(arr);\nconsole.log(proto === Array.prototype); // 출력: true\n```\n\n그것은 배열을 식별하는 방법으로 정말 유용합니다. 왜냐하면:\n\n```js\nconst arr = []\ntypeof arr // 출력 'object'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. Object.defineProperty() 사용하기\n\nObject.defineProperty()은 객체에 새로운 속성을 정의하거나 기존 속성을 수정하고 해당 객체를 반환합니다. 배열에 사용될 때, 새로운 속성을 정의하거나 기존 속성을 수정할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.defineProperty(arr, '0', {\n  value: 10,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nconsole.log(arr[0]); // 결과: 10\narr[0] = 20; // 쓰기가 불가능하기 때문에 영향을 주지 않음\nconsole.log(arr[0]); // 결과: 10\n```\n\n어째서 이렇게 할까요? 저는 상당히 작은 이유로 동료들을 놀리기 위해서 한다는 것 밖에 상상이 안됩니다. 또 다른 아이디어가 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. Object.setPrototypeOf() 사용\n\nObject.setPrototypeOf()은 지정된 객체의 프로토타입을 설정합니다. 배열에 사용하면 프로토타입을 다른 객체로 변경할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.setPrototypeOf(arr, Object.prototype);\nconsole.log(arr); // 출력: [1, 2, 3]\nconsole.log(arr.push); // 출력: undefined\nconsole.log(arr.shift); // 출력: undefined\nconsole.log(arr.pop); // 출력: undefined\n// .map(), .filter(), .forEach() 등도 동일\nconsole.log(arr.toString()); // 출력: '[object Array]'\narr[3] = 4\nconsole.log(arr); // 출력: [1, 2, 3, 4]\nconst newArr = [5,6]\nconsole.log([...arr, ...newArr]) // TypeError: arr은 반복 가능하지 않음\n```\n\n반 배열에서 반 죽은 노파를 만드는 재미있는 방법이에요. \"arr[3] = 4\"와 같이 새 요소를 추가하거나 \"delete arr[2]\"를 호출하여 요소를 삭제할 수 있지만, 거의 모든 다른 것들이 동작하지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 8. delete 연산자 사용하기\n\n이전 포인트의 아이디어를 백 퍼센트 따르지는 않지만, 자바스크립트에서 값의 \"존재하지 않음\"을 나타내는 null, undefined와의 연결을 드러내어 매우 흥미로운 부분입니다.\n다음 예제를 살펴보세요:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 출력: [1, empty, 3]\n```\n\n특정 크기의 객체를 봉인하려고 시도할 때 \"empty\"가 표시되었습니다. 하지만 이것이 무엇인가요? \"empty\"라는 값 또는 유형은 없기 때문에 표시된 것은 실제 데이터가 아니며, 그저 \"희소 배열\"을 나타내는 방법일 뿐입니다. 누락된 인덱스가 있는 배열에 대한 일반적인 용어입니다. 하지만 이 값을 액세스하려고 해보죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr[1]); // Output: undefined\n```\n\n이것이 우리에게 알려주는 바는 Javascript가 존재하지 않는 것에 접근하려고 할 때 \"undefined\"로 대체한다는 것입니다. 이것은 실제로 공백으로 변환되기보다 \"undefined\"를 배열에 명시적으로 넣어두면 \"empty\"로 다시 변환되지 않는다는 트릭입니다:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // Output: [1, empty, 3]\nconsole.log(arr[1]); // Output: undefined\narr[1] = undefined\nconsole.log(arr); // Output: [1, undefined, 3]\n```\n\n이게 다가 아닙니다. JS 데이터를 표현하는 또 다른 내장 방법인 JSON이 있습니다. JSON이 우리에게 어떤 것을 제공할 수 있는지 살펴봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(JSON.stringify(arr)); // 결과: [1, null, 3]\nconsole.log(JSON.parse(JSON.stringify(arr))); // 결과: [1, null, 3]\n```\n\nJSON.stringify()은 그냥 \"undefined\"를 \"null\"로 변환하기 때문에 JSON에는 undefined가 없다. 자바스크립트에도 \"null\"이 있기 때문에 다시 파싱할 때 \"null\"로 유지되는 것이 예상된다... 정말 이상한 일이다:\n한 가지 방향은 empty -` undefined -` null이다.\n돌아오는 방향은 null -` null -` null이다.\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(arr[1]); // 결과: undefined\nconst jsonArr = JSON.stringify(arr);\nconsole.log(jsonArr); // 결과: [1, null, 3]\nconst parsedArr = JSON.parse(jsonArr);\nconsole.log(parsedArr) // 결과: [1, null, 3]\nconsole.log(parsedArr[1]) // 결과: null\n```\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서 배열의 동작은 밑바닥 복잡성을 보여줍니다. 이는 종종 짜증을 유발할 수 있습니다. JavaScript 배열은 기술적으로 객체이지만, 고유한 특성과 표준 객체 메서드와의 상호작용으로 인해 예상치 못한 결과를 초래할 수 있습니다. 이러한 특이점을 이해하는 것은 개발자에게 잠재적인 문제를 피하는 데 중요할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png"},"coverImage":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png","tag":["Tech"],"readingTime":7},{"title":"정규 표현식에서 여러 조건을 일치시키는 방법","description":"","date":"2024-06-22 12:52","slug":"2024-06-22-HowToMatchMultipleConditionsinRegex","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png\" /\u003e\n\n이전 포스트에서는 미디엄 게시물에서 YouTube 링크를 썸네일로 표시하는 방법에 대해 설명했습니다. 이를 위해서는 제공된 URL에서 특정 패턴을 일치시키고 바꾸기 위해 일부 정규 표현식을 활용해야 합니다.\n\n포스트에는 두 가지 다른 조건을 고려해야 하는 보너스 섹션이 포함되어 있습니다. 두 가지 경우를 처리하기 위해 각각 별도의 문을 사용할 수 있습니다. 또는 여러 조건을 하나의 정규 표현식 문으로 통합하여 깔끔하고 효율적으로 할 수도 있습니다.\n\n이 포스트에서는 이에 대해 조금 더 깊이 이해해 보겠습니다! 아래는 문자열에서 정규 표현식 조건에 일치하는 부분을 찾을 수 있도록 match와 함께 사용할 수 있는 간단한 정규 표현식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 NY 메츠를 좋아합니다.';\nconst regex = /[A-Za-z]/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n\u003e (33) ['M', 'y', 'n', 'a', 'm', 'e', 'i', 's', 'M', 'a', 't', 't', 'h', 'e', 'w', 'C', 'r', 'o', 'a', 'k', 'I', 'l', 'o', 'v', 'e', 't', 'h', 'e', 'N', 'Y', 'M', 'e', 't', 's']\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요! 만약 우리가 전체 단어와 일치시키고 싶다면 어떨까요? 예를 들어, 'love'란 단어를 찾고 싶으면 이렇게 할 수 있어요!\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 뉴욕 메츠를 사랑해요.';\nconst regex = /love/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n\u003e ['love']\n```\n\n쉽죠? 만약 우리가 대괄호 안에 love를 넣어서 /[love]/g와 같이 하면 아래와 같은 결과가 나올 거에요.\n\n```js\n\u003e (9) ['e', 'e', 'o', 'l', 'o', 'v', 'e', 'e', 'e']\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 대괄호가 \"문자 클래스\"로 사용되기 때문입니다. 즉, \"a, b 또는 c 중의 어떤 문자\"를 의미합니다. 문자 클래스는 범위를 사용할 수도 있습니다. 예를 들어 [a-d] = [abcd]입니다. [여기](https://stackoverflow.com/questions/3512471/what-does-it-mean-to-escape-the-regex-square-brackets)에서 원본 스택 오버플로 설명을 볼 수 있습니다.\n\n## 다중 조건\n\n이 게시물의 원래 목적으로 돌아가 보겠습니다: 정규식에서 여러 조건을 사용하는 방법은 무엇인가요?\n\n예를 들어 우리가 love와 Mets 단어를 찾고 싶다고 할 때, 파이프 (|)를 사용하여 아래와 같은 정규식을 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst line = '내 이름은 매튜 크로크입니다. 나는 NY 메츠를 좋아합니다.';\nconst regex = /좋아합니다|메츠/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n\u003e ['좋아합니다', '메츠']\n```\n\n파이프는 논리 OR 표현을 나타냅니다. 하나의 패턴이나 다른 패턴 중 하나를 찾고 싶을 때 사용할 수 있습니다. 만약 love와 Mets 간에 공백을 넣었다면 또는 아예 아무것도 넣지 않았다면, 정규식에서 아무런 결과도 얻을 수 없을 것입니다.\n\n이는 이제 match 패턴이 loveMets 또는 love Mets라는 둘 중 하나가 되었기 때문입니다. 이들은 문자열에 나타나지 않는 패턴들입니다. OR 로직을 실행하려면 파이프가 필요합니다.\n\n이 OR 연산자는 두 개뿐만 아니라 다양한 조건과 함께 사용할 수 있습니다! 한 번 살펴보세요. 매튜, 좋아합니다, 메츠를 찾아 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst line = '내 이름은 Matthew Croak이다. 나는 NY Mets를 사랑해.';\nconst regex = /love|Mets|Matthew/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n\n\u003e ['Matthew', 'love', 'Mets']\n```\n\n패턴을 포함하는 순서가 중요하지 않은 것을 주목하셨나요? 여전히 일치 항목을 찾아 문자열에 나타난 순서대로 기록할 거에요.\n\n조금 더 복잡한 것을 시도해보죠.\n\n## 다중 조건 (특수 문자 사용)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 Markdown 형식으로 변경하면 아래와 같아요.\n\n```js\nconst line = \"내 이름은 Matthew Croak :). 나는 NY 메츠를 좋아해요 (양키스는 그렇게 좋아하지는 않지만, 괜찮아요.)\";\n\n// 이모티콘을 모두 찾고 싶다면 아래 내용을 콘솔에서 실행해보세요.\n\nconst line = \"내 이름은 Matthew Croak :). 나는 NY 메츠를 좋아해요 (양키스는 그렇게 좋아하지는 않지만, 괜찮아요).\";\nconst regex = /\u003c3|:)/g;\nconst found = line.match(regex);\n\nconsole.log(found)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무슨 일이 있었나요? 로그를 찍을 때 이렇게 나왔나요...\n\nUncaught SyntaxError: Invalid regular expression: /`3|:)/: Unmatched ‘)’\n\n왜 이런 일이 발생했을까요? 그것은 단순히 )가 정규식에서 특수 문자로 사용되기 때문이에요! 그것은 그룹화에 사용돼요. 문자열에서 )를 찾으려면 백슬래시로 이스케이핑 해야 해요.\n\n아래 사항을 확인해 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst regex = /\u003c3|:\\)/g;\n```\n\n코드를 업데이트하면 아래와 같은 응답이 나와야 합니다.\n\n```js\n\u003e (2) [':)', '\u003c3']\n```\n\n여기 있습니다! 여러 개의 정규 표현식을 논리 OR 연산자를 사용하여 하나로 결합하는 방법과 문자열에서 특수하거나 예약된 문자를 찾을 수 있도록 이스케이프하는 방법까지 배웠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 방법으로 정규식에서 여러 조건을 사용하는 방법이 있나요? 댓글로 알려주세요! \n\n나의 정리된 정규식 목록을 확인하려면 더 많은 자료를 보십시오!\n\n무제한 광고 없는 이야기를 수천 명의 작가로부터 받으며 무료 Medium 멤버십을 업그레이드하세요. 이것은 제가 작성한 콘텐츠에 대한 보상을 받게 해주는 제 계정과 연계된 링크입니다.\n\n또한 이메일로 구독하여 새로운 글이 올라올 때마다 알림을 받을 수도 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고문헌","ogImage":{"url":"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png"},"coverImage":"/assets/img/2024-06-22-HowToMatchMultipleConditionsinRegex_0.png","tag":["Tech"],"readingTime":4},{"title":"사용자 맞춤 AI Meta의 Llama 3와 Nodejs로 프라이버시 중심 LLM 배포 방법","description":"","date":"2024-06-22 06:09","slug":"2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs","content":"\n\n\"우리는 이 새로운 기술들의 힘을 활용해야 해,\" CEO가 단호하게 선언했다. \"하지만 우리는 고객 데이터 보안을 저해할 여유가 없어.\"","ogImage":{"url":"/assets/img/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs_0.png"},"coverImage":"/assets/img/2024-06-22-AIonYourTermsPrivacy-FocusedLLMDeploymentwithMetasLlama3andNodejs_0.png","tag":["Tech"],"readingTime":1},{"title":"실생활 비유로 이해하는 JavaScript call, apply, bind 메서드 사용 방법","description":"","date":"2024-06-22 06:09","slug":"2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies","content":"\n\n\n![image](/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png)\n\n자바스크립트는 함수가 작동하는 문맥(this)을 제어하기 위해 call, apply, bind 세 가지 강력한 메서드를 제공합니다. 이러한 메서드를 이해하면 유연하고 재사용 가능한 코드를 작성할 수 있는 능력이 크게 향상됩니다. 각 메서드를 간단한 설명과 현실적인 비유와 함께 살펴보겠습니다.\n\n# call\n\ncall은 한 객체로부터 메서드를 빌려와 다른 객체에 즉시 사용할 수 있도록 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요!\n\n아래 예시를 보시면 함수 호출 시 사용되는 `table` 태그를 Markdown 형식으로 변경하였습니다.\n\n예시:\n\nAlice가 인사하는 메소드를 가지고 있다고 상상해봅시다:\n\n```js\nconst alice = {\n    name: 'Alice',\n    sayHello: function(greeting) {\n        console.log(greeting + ', ' + this.name);\n    }\n};\n\nalice.sayHello('Hi');  // 결과: \"Hi, Alice\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n밥이 인사를 하고 싶지만 sayHello 메서드가 없어요. call을 사용하면 앨리스의 메서드를 빌려와서 즉시 사용할 수 있어요:\n\n```js\nconst bob = { name: 'Bob' };\n\nalice.sayHello.call(bob, 'Hello');  // 출력: \"Hello, Bob\"\n```\n\n유사성: call은 앨리스의 메서드 책을 빌려와서 바로 사용하여 밥이 누군가에게 인사할 수 있게 도와주는 것처럼 생각해 보세요.\n\n# apply\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napply는 call과 비슷하지만, 인수를 배열로 전달할 수 있습니다.\n\n```js\nfunction.apply(thisArg, [argsArray])\n```\n\n예시:\n\n같은 인사 방법을 사용하면, 만약 인사말이 배열에 저장되어 있다면 apply를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst args = ['안녕'];\n\nalice.sayHello.apply(bob, args);  // 출력: \"안녕, Bob\"\n```\n\n비유: apply는 앨리스의 메서드 책을 빌리는 것처럼 즉시 사용하는 것이지만 개별 지시사항을 주는 대신에 지시사항 목록을 전달합니다.\n\n# bind\n\nbind는 제공된 값으로 this 값을 설정하고 주어진 인수 시퀀스로 호출될 때 새 함수를 생성합니다. call 및 apply와 달리 bind는 함수를 즉시 실행하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction.bind(thisArg, arg1, arg2, ...)\n```\n\n예시:\n\n만약 나중에 Bob에게 인사를 준비하고 싶다면, bind를 사용하여 그렇게 할 수 있어요.\n\n```js\nconst greetBobLater = alice.sayHello.bind(bob, '좋은 아침');\n\ngreetBobLater();  // 출력: \"좋은 아침, Bob\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비유: bind는 밥을 위해 알람 시계를 설정하는 것과 같습니다. 인사말을 미리 설정하고, 시간이 되면 밥이 사용할 수 있습니다.\n\n# 주요 차이점\n\n— 호출 시기:\n\n- call과 apply는 함수를 즉시 호출합니다.\n- bind는 나중에 호출할 수 있는 새로운 함수를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n— 인수 처리:\n\n- call은 개별적인 인수를 사용합니다.\n- apply는 배열로 인수를 사용합니다.\n- bind는 새 함수를 호출할 때 제공할 수 있는 새 함수를 위한 미리 설정된 인수를 사용할 수 있습니다.\n\n## 사용 사례\n\n- call: 함수를 즉시 호출하고 this 컨텍스트를 제어하고 개별적으로 인수를 전달하고 싶을 때 사용합니다. 예: 하나의 객체에서 메서드를 빌려와서 다른 객체에서 즉시 사용할 때.\n- apply: 함수를 즉시 호출하고 배열에 있는 인수를 사용해야 할 때 사용합니다. 예: 배열에 저장된 매개변수 목록을 사용하는 방법.\n- bind: 특정한 this 컨텍스트와 선택적으로 미리 설정된 인수를 사용하여 나중에 호출할 수 있는 함수를 만들어야 할 때 사용합니다. 예: 이벤트 핸들러나 콜백을 위해 메서드를 미리 설정하는 경우.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 간단한 비유를 통한 요약:\n\n- call: \"앨리스야, 밥이 지금 `sayHello` 메서드를 빌려와서 사용해도 될까?\" (즉시 사용)\n- apply: call과 동일하지만 목록 형태의 지시사항 제공: \"여기, 밥, 여기 있는 목록 [`안녕`]을 사용해서 인사해봐.\"\n- bind: \"앨리스, 밥이 `좋은 아침`이라는 것으로 나준비를 해놓을 수 있을까?\" (나중 사용을 위한 준비)\n\n# 결론\n\nJavaScript에서 call, apply 및 bind를 이해하면 함수 실행과 this 바인딩에 대한 더 큰 제어력을 가질 수 있습니다. 이러한 방법은 객체 지향 및 함수형 프로그래밍 패턴에서 특히 유용하며 코드의 유연성과 재사용성을 향상시킵니다. 간단한 비유를 사용하여, call과 apply는 즉시 메서드를 빌려와서 사용하는 것과 유사하며, bind는 미래 사용을 위해 메서드를 준비하는 것과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초보자든 숙련된 개발자든, 이러한 방법을 숙달하는 것은 더 견고하고 유지보수가 쉬운 JavaScript 코드를 작성하는 데 도움이 될 것입니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingJavaScriptscallapplyandbindMethodswithReal-LifeAnalogies_0.png","tag":["Tech"],"readingTime":3}],"page":"21","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"21"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>