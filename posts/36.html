<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/36" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/36" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="앵귤러 컴포넌트 상호작용 Seamless 통신을 위한 Input과 Output 바인딩 간단히 알아보기" href="/post/2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 컴포넌트 상호작용 Seamless 통신을 위한 Input과 Output 바인딩 간단히 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 컴포넌트 상호작용 Seamless 통신을 위한 Input과 Output 바인딩 간단히 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 컴포넌트 상호작용 Seamless 통신을 위한 Input과 Output 바인딩 간단히 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서 사용하는 다양한 배열 유형  언제 사용해야 할까요" href="/post/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서 사용하는 다양한 배열 유형  언제 사용해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서 사용하는 다양한 배열 유형  언제 사용해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서 사용하는 다양한 배열 유형  언제 사용해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트 코드를 더 우아하게 만드는 방법" href="/post/2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트 코드를 더 우아하게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트 코드를 더 우아하게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트 코드를 더 우아하게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이전 화면으로 돌아갈 때 데이터 전송하기 React Native" href="/post/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이전 화면으로 돌아갈 때 데이터 전송하기 React Native" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이전 화면으로 돌아갈 때 데이터 전송하기 React Native" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이전 화면으로 돌아갈 때 데이터 전송하기 React Native</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 훅스 소개" href="/post/2024-06-20-IntroductiontoReactHooks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 훅스 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IntroductiontoReactHooks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 훅스 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 훅스 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구글 파이어베이스를 React에서 활용하기" href="/post/2024-06-20-MakinguseofGooglefirebaseinReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구글 파이어베이스를 React에서 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구글 파이어베이스를 React에서 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">구글 파이어베이스를 React에서 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기" href="/post/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지" href="/post/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드" href="/post/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들" href="/post/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link posts_-active__YVJEi" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"앵귤러 컴포넌트 상호작용 Seamless 통신을 위한 Input과 Output 바인딩 간단히 알아보기","description":"","date":"2024-06-20 05:20","slug":"2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication_0.png\" /\u003e\n\nAngular은 인기 있는 JavaScript 프레임워크로, Input() 및 Output() 바인딩을 통해 컴포넌트 간에 강력한 통신 방법을 제공합니다. 이 안내서에서는 이러한 개념을 단계별로 살펴보며 쉽게 이해할 수 있는 코드 예제를 제시할 것입니다.\n\n1. 컴포넌트 상호 작용 이해하기: 복잡한 애플리케이션을 개발할 때, 이를 작은 재사용 가능한 컴포넌트로 분리하는 것이 중요합니다. 그러나 이러한 컴포넌트들은 종종 서로 통신해아 합니다. 이때 Angular의 Input() 및 Output()이 필요합니다.\n\n2. 데이터 흐름에 Input() 사용하기: Input() 데코레이터를 사용하면 부모 컴포넌트가 자식 컴포넌트로 데이터를 전달할 수 있습니다. 이 데이터는 자식 컴포넌트 내부에서 속성으로 받아옵니다. 아래 예시에서 부모 컴포넌트는 메시지를 자식 컴포넌트로 전달하고, 자식 컴포넌트에서는 이를 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\n// 부모 컴포넌트\n@Component({\n  selector: 'app-parent',\n  template: '\u003capp-child [message]=\"parentMessage\"\u003e\u003c/app-child\u003e'\n})\nexport class ParentComponent {\n  parentMessage = \"부모로부터 안녕하세요!\";\n}\n```\n\n```typescript\n// 자식 컴포넌트\n@Component({\n  selector: 'app-child',\n  template: '\u003cp\u003e{ message }\u003c/p\u003e'\n})\nexport class ChildComponent {\n  @Input() message: string;\n}\n```\n\n3. Output()를 사용하여 데이터를 전송: Input()가 부모에서 자식으로 데이터를 흘려보내는 것을 허용한다면, Output()은 자식 컴포넌트가 부모 컴포넌트로 데이터를 다시 보낼 수 있게 합니다. 이는 Angular의 EventEmitter를 사용하여 구현됩니다. 다음 예제에서는 자식 컴포넌트가 버튼을 클릭할 때 메시지를 전송하고, 부모 컴포넌트가 해당 메시지를 받아서 표시하는 방법을 보여줍니다.\n\n```typescript\n// 자식 컴포넌트\n@Component({\n  selector: 'app-child',\n  template: '\u003cbutton (click)=\"sendMessage()\"\u003e메시지 전송\u003c/button\u003e'\n})\nexport class ChildComponent {\n  @Output() messageEvent = new EventEmitter\u003cstring\u003e();\n  sendMessage() {\n      this.messageEvent.emit(\"자식으로부터 안녕하세요!\");\n    }\n  }\n\n// 부모 컴포넌트\n@Component({\n  selector: 'app-parent',\n  template: '\u003capp-child (messageEvent)=\"receiveMessage($event)\"\u003e\u003c/app-child\u003e\u003cp\u003e{ message }\u003c/p\u003e'\n})\nexport class ParentComponent {\n  message = \"\";\n  receiveMessage($event: string) {\n    this.message = $event;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. ngModel을 사용한 양방향 바인딩: Angular은 ngModel을 사용하여 양방향 바인딩을 달성할 수 있는 방법을 제공합니다. 이를 통해 데이터 바인딩과 이벤트 처리가 모두 필요한 구성 요소 간의 통신을 간단하게 할 수 있습니다. 아래 예시에서는 부모 구성 요소의 입력 필드 변경이 자동으로 자식 구성 요소의 표시를 업데이트합니다.\n\n```js\n\u003c!-- 부모 구성 요소 --\u003e\n\u003cinput [(ngModel)]=\"name\"\u003e\n\u003capp-child [childName]=\"name\"\u003e\u003c/app-child\u003e\n\n\u003c!-- 자식 구성 요소 --\u003e\n\u003cp\u003e{ childName }\u003c/p\u003e\n```\n\n5. 모범 사례와 고려 사항\n\n- 단순하게 유지하기: 지나치게 복잡한 구성 요소 계층 구조를 피하십시오. Input()과 Output()을 분별하여 사용하여 데이터 흐름을 명확하게 유지하세요.\n- 순환 의존성 피하기: 상호 통신에 조심해야 하며, 이는 순환 의존성으로 이어질 수 있고 코드를 유지하기 어렵게 만들 수 있습니다.\n- Observable 서비스 사용: 더 복잡한 시나리오의 경우 Angular 서비스와 옵저버블을 사용하여 구성 요소 간의 복잡한 상호 작용을 관리하는 것을 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, Angular 컴포넌트 간에 효과적인 통신을 위해 Input() 및 Output() 바인딩을 이해하는 것이 중요합니다. 이 개념을 숙지하고 모범 사례를 따르면 모듈화되고 인터랙티브한 애플리케이션을 구축하는 데 잘 준비될 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication_0.png"},"coverImage":"/assets/img/2024-06-20-AngularComponentInteractionACloserLookatInputandOutputBindingsforSeamlessCommunication_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트에서 사용하는 다양한 배열 유형  언제 사용해야 할까요","description":"","date":"2024-06-20 05:18","slug":"2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem","content":"\n\n![2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_0](/assets/img/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_0.png)\n\n자바스크립트에서 제공하는 배열 종류와 사용 시기에 대해 알아보겠습니다. 이는 특정 사용보다는 일반적인 용도에 대해 더 다룹니다.\n\n# 배열이란\n\n\"진정한 배열\"이 무엇인지에 대한 번복적인 토론을 피하려 합니다. 알아야 할 것은 \"배열\"의 의미가 고수준 및 저수준 해석 둘 다를 포함한다는 점입니다. 고수준 배열은 기본적으로 순차적인 컬렉션입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 순차적 컬렉션\n\n다양한 프로그래밍 언어에서, 이는 데이터를 동적으로 조절하면서 순차적으로 저장하는 데이터셋입니다. 순차적 컬렉션은 기본 배열, 뷰, 리스트 또는 링크드 리스트를 나타낼 수 있습니다. Golang에서는 Slice, Python에서는 List, JavaScript에서는 Array가 될 것입니다.\n\nJS에서 배열에 대한 여러 면에는 다양한 미묘한 점이 있습니다: 공간 유무, Object 여부 등이 있습니다. 여기 제 소견입니다:\n\n그럼에도 불구하고, JS의 배열에 대한 가장 중요한 측면만 다루고 싶습니다. 이미 알고 계신 분들을 위해, Array.isArray()를 사용하여 배열을 유형 검사할 수 있습니다. 저는 Array를 구조화하는데 Array.isArray()를 사용하는 const 'isArray'를 사용합니다. Array에 대한 보다 기본적인 정보는 MDN에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배열 생성자\n\n```js\nconst array = new Array(12_345)\n```\n\n- 항상 folding을 수행하도록 V8에 알림을 보내기 때문에 많은 항목이 있는 배열에 대해 높은 성능을 제공합니다.\n- 항목 수가 많을 때 사용하세요.\n\n# 배열 리터럴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst array = []\n```\n\n- 일반적으로 시간이 지남에 따라 더 작은 길이의 데이터를 가져오도록 최적화되어 있습니다\n- 동적으로 변할 것으로 예상됩니다\n- 일반적인 용도에 가장 적합합니다\n\n# 고정 길이 배열 리터럴\n\n```js\nconst array = []\narray.length = 12_234\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고정 길이 배열 리터럴은 배열 생성자 예제와 성능이 유사합니다. 일반적으로 성능 차이는 미미합니다. 배열 생성자와 고정 길이 배열 리터럴은 주로 같은 사용 사례를 공유합니다.\n\n# ArrayBuffer\n\nArrayBuffer는 \"바이트 배열\"로, 연속적인(서로 이어진) 바이트 그룹을 포함하는 메모리 영역입니다.\n\n```js\n[ Byte 0  | Byte 1  | Byte 2, ... ] // 연속적인 바이트들\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nV8(Chrome/Node.js)에서 배열 버퍼가 메모리 힙에 저장됩니다.\n\n배열 버퍼는 일반적인 원시 이진 데이터 버퍼입니다.\n\n- 일반적: 특정한 데이터 유형에 구속되지 않습니다. 정수, 부호 없는 정수, 부동 소수점, 부호 없는 부동 소수점 및 문자열 등을 나타내는 이진 데이터를 저장하는데 사용될 수 있습니다.\n- 원시: JavaScript에서 ArrayBuffer의 표현은 물리적 메모리와 일치하며 메타데이터나 변환은 없습니다.\n\n배열 버퍼는 생성 시 크기가 고정되며 직접 조작되지 않고 이진 데이터의 컨테이너 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- 일반적 (위에서 언급한 대로)\n- 빠름: 메모리 미리 할당 (고정되고 변경할 수 없는 메모리 양)을 수행하여 런타임에서 효율적입니다.\n- 다중 뷰: 배열 버퍼에는 데이터 바이트 (8비트)가 포함되어 있습니다. 데이터를 [8비트] [8비트] [8비트] [8비트]로 볼 수도 있고, 16비트 뷰 [8비트, 8비트] [8비트, 8비트] 또는 32비트 뷰 [8비트, 8비트, 8비트, 8비트] 등으로 볼 수도 있습니다. 이것이 일반적으로 의미하는 바이며, 데이터가 이진 사용 사례에 적합한 모든 방식으로 보고 형성할 수 있습니다.\n\n# 뷰\n\n뷰는 배열 버퍼를 해석하는 방식입니다. 배열 버퍼는 바이트(옆으로 나란히 있는 8비트) 데이터입니다. 이는 절대 변경되지 않으며, 16비트, 32비트 또는 BigInt 64비트로 해석하더라도 항상 바이트 데이터일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뷰(Views)는 데이터 해석뿐만 아니라 배열 버퍼를 조작할 수 있는 메커니즘입니다.\n\nJS에서 숫자 표현에 대해 썼어요. 여기서 확인할 수 있어요: JavaScript: Poorly Designed? — Part 3: IEEE 754 이것은 JS에서 이진(binary)을 이해하는 데 도움이 될 거예요.\n\n## 뷰(Views)의 유형\n\n두 가지 유형의 뷰(Views)가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Typed-arrays (TypedArray 객체)\n- DataViews (이 부분은 범위를 벗어납니다, 이것은 pt2가 필요합니다)\n\nTyped-arrays는 배열 버퍼의 숫자 유형 관점을 제공합니다:\n\n- Int8Array: 8-bit 부호 있는 정수\n- Uint8Array: 8-bit 부호 없는 정수\n- Uint8ClampedArray: 0~255로 클램프된 8-bit 부호 없는 정수\n- Int16Array: 16-bit 부호 있는 정수\n- Uint16Array: 16-bit 부호 없는 정수\n- Int32Array: 32-bit 부호 있는 정수\n- Uint32Array: 32-bit 부호 없는 정수\n- Float32Array: 32-bit 부동 소수점 숫자\n- Float64Array: 64-bit 부동 소수점 숫자\n- BigInt64Array: 64-bit 부호 있는 정수 BigInt 숫자\n- BigUint64Array: 64-bit 부호 없는 정수 BigInt 숫자\n\n## 함께 춤을 춥시다 🕺\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 우리는 4 바이트(32비트)의 버퍼를 할당합니다.\nconst buffer = new ArrayBuffer(4)\n\n// 8비트 부호 없는 정수 TypedArray 뷰를 만듭니다.\nconst uint8 = new Uint8Array(buffer)\n\n// 123을 할당합니다.\nuint8[0] = 123\n\n// 456을 할당합니다.\nuint8[1] = 456\n\n// 항목을 출력합니다.\nfor (const item of uint8) console.log(item)\n// 123\n// 200\n// 0 \n// 0\n\n// 무슨 일이 일어나고 있는 거죠? 왭!\n```\n\n그래서 먼저 8비트를 10진수로 확인해 볼까요(인간의 수 체계)? 2⁸ = 256로 계산됩니다. 즉, 8비트 부호 없는 정수 배열의 항목은 256을 초과할 수 없습니다.\n\nuint8[1] = 456은 256을 200으로 초과하려 합니다. 따라서 나머지 값인 200으로 줄어듭니다. 나머지가 전체 값의 중요한 부분입니다.\n\n언급한대로, 버퍼에는 여러 개의 뷰가 있을 수 있으므로 같은 버퍼를 16비트 부호 없는 정수로 보겠습니다. 이어서 계속해봅시다...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst uint16 = new Uint16Array(buffer) // 같은 buffer 변수\n\nfor (const item of uint16) console.log(item)\n// 51323\n// 0\n```\n\n우리는 16비트에서 8비트 데이터를 보고 있기 때문에 두 개의 항목을 기대합니다. 하지만 왜 51323이 나오는 걸까요?\n\n먼저 우리는 8비트 - 10진법 표현을 16비트로 변환해야 합니다. 저는 자랑을 하려고 하는 게 아니에요, 바이너리 계산기를 사용할 뿐이에요.\n\n- 123 = 01111011\n- 200 = 11001000\n- 0 = 00000000\n- 0 = 0000000000000000\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트는 리틀엔디안 방식으로 바이트를 오른쪽에서 왼쪽으로 읽습니다. 이는 10진수에서는 중요하지 않지만,\n\n하지만 2진수에서는 오른쪽에서 왼쪽으로 연결해야 하므로 16비트 형식에서는 다음과 같습니다:\n\n[1100100001111011, 0000000000000000]\n\n이제 10진수로 변환하면 아래와 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 배열 버퍼를 조작하고 나타내는 여러 가지 방법을 이해할 수 있을 것입니다.\n\n## 알겠는데, 이걸 언제 활용하죠?\n\n이미 알고 계실지 모를지도 모르겠지만, ArrayBuffer는 그래픽 (WebGL, WebGPU), 사용자 정의 비디오 코덱 및 다양한 형태의 이진 처리에 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 프로그래밍 작업에는 일반적으로 순차 컬렉션 Array이 충분합니다. 그러나 ArrayBuffer를 사용하는 것이 좋은 경우가 있습니다.\n\n## 좌표\n\n대량의 x와 y 좌표 또는 다른 세트의 좌표를 처리해야 하는 경우(예: 애니메이션 또는 데이터 처리 등), 객체로 채워진 배열 대신 ArrayBuffer를 사용하는 것이 더 적합할 수 있습니다. 이는 사용 사례에 따라 다릅니다. 데이터 크기에 최적인 방법을 결정하기 위해 벤치마킹하는 것이 가치가 있습니다.\n\n## 금융\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 선사 시대에서 오셨다면 JavaScript에 원시 64비트 BigInt 숫자가 있고, 브라우저와 node.js에서 완벽히 지원된다는 사실이 새로울 수 있습니다.\n\nBigUint64Array를 사용하면 빠른 데이터 조작이 가능하지만, 이진 조작에 대한 혜택은 실제로 별로 없습니다. 다시 한 번, 어떤 방법이 가장 잘 작동하는지 확인하기 위해 벤치마킹이 필요합니다.\n\n## 대용량 데이터\n\nAccenture에서 근무하면서, 수만 개의 항목을 포함하는 대량 데이터셋을 사용한 IAM 프로젝트를 담당했습니다. 이 데이터의 구문 분석과 처리는 브라우저에 약간의 부담이 되었습니다. 한 시점에서의 프로세스는 아래와 유사했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 가져오기 - JSON 구문 분석 - IndexedDB에 데이터 저장 - 데이터 반복\n\n- 그래프 업데이트\n- 가상 목록 업데이트\n\n값은 숫자와 일부 문자열 값을 가진 항목(행)이었습니다. 배열 버퍼로 필드를 구분하거나 JavaScript의 Array 버퍼에 더 익숙했다면 성능이 향상되었을 것입니다.\n\nIndexedDB의 장점은 Binary Large Objects로 알려진 Blob로 배열 버퍼를 저장할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nArrayBuffer를 사용하는 것이 일반적인 목적의 데이터와 직접적으로 연관되는 경우는 드물지만, 성능 이점을 활용하기 위해 데이터를 여러 배열로 분할해야 할 때가 많습니다.\n\n# 결론\n\nJavaScript에는 다음이 모두 있습니다:\n\n- 고수준 배열\n- 저수준 배열\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"어레이(array)\" 라는 단어가 혼란스러울 수 있으니 신경 쓰지 마세요. 그러니로마에 가면 피자에 파인애플을 넣지 마세요. 배열은 [] 이거나 new Array(...)이고 ArrayBuffer는 \"버퍼\"라고 합니다. \"뷰(view)\" 는 \"뷰\" 이거나 \"어레이 뷰\"일 수 있습니다. 솔직히 제가 진짜 관심이 없어요.\n\n이 글에서 다루지 않은 부분이 많습니다. 배열 리터럴을 반복하는 것이 객체 리터럴을 반복하는 것보다 유의미한 성능 이점이 없다는 점을 강조하고 싶습니다. 그러니 이 글을 읽고 기존 코드를 망가뜨려놓지 마세요. 그것은 이 글의 의도가 아닙니다.\n\n우리의 선택지를 인식하여 개발 방법에 대한 더 나은 결정을 내릴 수 있도록 하는 것이 목적입니다.\n\n말하고 싶지 않지만...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_1.png\" /\u003e\n\n현실에서 대부분의 사람들은 재미있는 것을 하지 않을 것이며 새로운 문법을 시도하고 싶어서 지루한 것을 강요할 이유가 없습니다.\n\n또한 성능이 항상 핵심 측정 기준은 아니지만, 이 글은 상수 폴딩 배열과 배열 버퍼의 성능에 기본 초점을 두었으니 그것이 실제로 그들의 주요 장점입니다.\n\n2부에서는 DataViews에 대해 다루고, 아마도 3부에서 SharedArrayBuffer와 Atomics를 다룰 것입니다. 그에 대한 업데이트는 여기에 추가하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 테이블 태그를 마크다운 형식으로 변경해주세요. 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_0.png"},"coverImage":"/assets/img/2024-06-20-DifferentTypesofArraysinJavaScriptWhentoUseThem_0.png","tag":["Tech"],"readingTime":7},{"title":"타입스크립트 코드를 더 우아하게 만드는 방법","description":"","date":"2024-06-20 05:16","slug":"2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant_0.png\" /\u003e\n\nTypeScript는 수퍼셋 언어로, JavaScript의 모든 기능을 포함하며 더 강력한 기능과 도구 지원을 제공하여 그 위에 조성되었습니다. TypeScript는 개발자가 더 견고하고 유지보수가 쉬운 코드를 작성하는 데 도움을 주고, 이를 통해 개발 효율성과 코드 품질을 향상시키려 합니다.\n\n이 기사에서는 TypeScript의 고급 기능을 탐구하고, 이러한 기능이 어떻게 더 높은 품질의 코드 작성에 도움을 줄 수 있는지를 보여줍니다. TypeScript를 처음 시작하는 사람이거나 그 고급 기능을 깊게 탐색하려는 경우, 이 기사는 가치 있는 통찰과 실용적인 조언을 제공할 것입니다.\n\n# 1. 템플릿 리터럴 타입\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n템플릿 리터럴 유형은 TypeScript에서의 고급 유형 기능으로, 문자열 템플릿 구문을 사용하여 복잡한 문자열 조합 유형을 만들 수 있게 해줍니다. 예를 통해 살펴보겠습니다:\n\n어플리케이션에서 서로 다른 사용자 역할과 권한 수준이 있다고 가정해봅시다. 이를 표현하는 유형을 만들고 싶은 경우, 템플릿 리터럴을 사용해 역할과 권한 수준의 조합을 나타내는 유형을 생성할 수 있습니다.\n\n```js\ntype Role = \"admin\" | \"user\" | \"guest\";\ntype PermissionLevel = \"read\" | \"write\" | \"execute\";\ntype RolePermission = `${Role}-${PermissionLevel}`;\n\nlet rolePermission: RolePermission = \"admin-read\"; // 유효한 값\n// let invalidRolePermission: RolePermission = \"manager-read\"; \n// 에러: 'manager-read' 유형이 'RolePermission'에 할당될 수 없습니다.\n```\n\n템플릿 리터럴 유형을 사용하여 RolePermission 유형을 생성했습니다. 이는 Role과 PermissionLevel의 각 값들을 결합해 총 아홉 가지 문자열 유형을 생성합니다: \"admin-read\", \"admin-write\", \"admin-execute\", \"user-read\", \"user-write\", \"user-execute\", \"guest-read\", \"guest-write\", 그리고 \"guest-execute\".\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"manager-read\"은 RolePermission의 정의 범위에 없습니다. \"manager\"가 Role 유형에 포함되어 있지 않기 때문에 TypeScript에서 오류를 발생시킵니다. \"manager-read\" 타입은 `RolePermission` 타입으로 할당할 수 없다는 메시지가 표시됩니다.\n\n템플릿 리터럴 타입을 사용하여 복잡한 문자열 조합 타입을 쉽게 생성하고 관리할 수 있습니다. 이를 통해 코드의 가독성과 타입 안정성을 높일 수 있습니다. 특히 복잡한 문자열 패턴을 정의하고 검증해야 하는 상황에서 유용합니다.\n\n# 2. TypeScript 유형 예측(Type Predicates)을 사용하여 정확한 유형 검사\n\n유형 예측은 특정 유형에 변수가 속하는지 확인하고 실행 시점에 유형을 보장하는 강력한 도구입니다. 유형 예측을 사용하면 유형 안전한 코드를 작성할 때 더 정확한 유형 검사를 수행하여 유형 오류를 피하고 코드의 견고성과 유지 보수성을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 고양이(Cat)와 개(Dog)를 포함한 동물을 나타내는 유니언 타입이 있는 경우를 상정해 봅시다:\n\n```js\ninterface Cat {\n  kind: \"cat\";\n  meow: () =\u003e void;\n}\n\ninterface Dog {\n  kind: \"dog\";\n  bark: () =\u003e void;\n}\n\ntype Animal = Cat | Dog;\n```\n\n이제 Animal이 Cat 타입인지 확인하는 함수를 작성하려고 합니다. 이 때, 우리는 타입 가드를 사용할 수 있습니다:\n\n```js\nfunction isCat(animal: Animal): animal is Cat {\n  return animal.kind === \"cat\";\n}\n\nfunction makeSound(animal: Animal) {\n  if (isCat(animal)) {\n    animal.meow(); // 여기서 TypeScript는 animal이 Cat 타입임을 알고 있습니다.\n  } else {\n    animal.bark(); // 여기서 TypeScript는 animal이 Dog 타입임을 알고 있습니다.\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예시에서 우리는 isCat이라는 함수를 정의하고 결과 타입으로 타입 검사 animal is Cat를 사용하였습니다. 이 함수는 전달된 animal 객체의 kind 속성이 \"cat\"인지 확인합니다. 만약 \"cat\"이라면, 함수는 true를 반환하고 TypeScript 컴파일러에게 이 조건 분기 내에서 animal 변수가 Cat 타입임을 알려줍니다.\n\n이렇게 함으로써, makeSound 함수는 Animal의 특정 타입을 정확히 식별하고 해당하는 조건 분기에서 Cat 또는 Dog에 특화된 메서드를 호출할 수 있습니다. 이는 코드의 타입 안정성을 향상시키는 동시에 코드를 더 명확하고 유지보수하기 쉽게 만듭니다.\n\n# 3. 색인 액세스 타입\n\n색인 액세스 타입은 T[K] 구문을 사용하여 T 유형에서 키 K와 연결된 유형에 액세스할 수 있도록 합니다. 이는 JavaScript에서 객체 속성에 액세스하기 위해 대괄호를 사용하는 것과 유사하지만, TypeScript에서 색인 액세스 타입은 컴파일 시간 타입 체크를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 응답 유형에서 데이터와 오류 정보가 포함된 경우를 가정해보겠습니다:\n\n```js\ninterface ApiResponse\u003cT\u003e {\n  data: T;\n  error: string | null;\n}\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ProductResponse = ApiResponse\u003cProduct\u003e;\n```\n\n우리는 Indexed Access Types를 사용하여 ProductResponse 유형의 data 속성의 유형을 추출할 수 있습니다.\n\n```js\ntype ProductDataType = ProductResponse['data']; // Product\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 응용 프로그램에서는 속성 이름을 기반으로 객체 속성에 동적으로 액세스해야 하고 형식 보호를 수행해야 하는 경우가 많습니다. 인덱스 액세스 유형과 `keyof` 연산자를 사용하여 이를 달성할 수 있습니다:\n\n```js\nfunction getProperty\u003cT, K extends keyof T\u003e(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user: User = {\n  id: 1,\n  name: \"Alice\",\n  email: \"alice@example.com\"\n};\n\nconst userId = getProperty(user, 'id'); // number\nconst userName = getProperty(user, 'name'); // string\nconst userEmail = getProperty(user, 'email'); // string\n```\n\n이 예제에서는 다음과 같은 내용이 있습니다:\n\n- getProperty 함수는 객체 obj와 속성 이름 key를 사용하고 해당 속성의 값을 반환합니다.\n- T는 객체의 유형이며, K는 속성 이름의 유형입니다(이는 T의 키여야 합니다).\n- 반환 유형 T[K]는 객체 T의 키 K에 해당하는 속성의 유형을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. TypeScript의 유틸리티 타입\n\nTypeScript에는 다양한 시나리오에서 복잡한 타입을 빠르게 생성하고 조작하는 데 도움이 되는 많은 내장 유틸리티 타입이 제공됩니다. 이 유틸리티 타입을 활용함으로써 개발 효율을 크게 향상시키고, 수동으로 타입 정의를 작성하는 작업 부담을 줄이며, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 여기에 유틸리티 타입의 몇 가지 예시가 있습니다:\n\n- Partial 타입은 타입 T의 모든 속성을 선택적으로 만들어줍니다. 초기에 필요하지 않은 모든 속성을 가진 객체를 구성해야 할 때 매우 유용합니다.\n\n```js\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction updateUser(id: number, update: Partial\u003cUser\u003e) {\n  // ...\n}\n\nupdateUser(1, { name: \"Alice\" }); // 유효\nupdateUser(2, { email: \"bob@example.com\" }); // 유효\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Required 유형은 T 유형의 모든 속성을 필수 속성으로 만듭니다. 객체의 모든 속성에 값이 할당된 것을 보장해야 할 때 매우 유용합니다.\n\n```js\ninterface User {\n  id?: number;\n  name?: string;\n  email?: string;\n}\n\nconst completeUser: Required\u003cUser\u003e = {\n  id: 1,\n  name: \"Alice\",\n  email: \"alice@example.com\"\n};\n```\n\n- Readonly 유형은 T 유형의 모든 속성을 읽기 전용으로 만들어 수정할 수 없게 합니다.\n\n```js\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst user: Readonly\u003cUser\u003e = {\n  id: 1,\n  name: \"Alice\",\n  email: \"alice@example.com\"\n};\n\nuser.id = 2; // 오류: 'id'는 읽기 전용 속성이므로 할당할 수 없습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Pick 유형은 형식 T에서 특정 속성들을 선택하여 새로운 유형을 만드는 데 사용됩니다.\n\n```js\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype UserSummary = Pick\u003cUser, \"id\" | \"name\"\u003e;\n\nconst userSummary: UserSummary = {\n  id: 1,\n  name: \"Alice\"\n};\n```\n\n- Omit 유형은 형식 T에서 지정된 속성을 제외하여 새로운 유형을 만드는 데 사용됩니다.\n\n```js\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype UserWithoutEmail = Omit\u003cUser, \"email\"\u003e;\n\nconst userWithoutEmail: UserWithoutEmail = {\n  id: 1,\n  name: \"Alice\",\n  age: 30\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 개발에서는 종종 여러 유틸리티 유형을 결합하여 복잡한 유형 정의를 만들어 특정 요구 사항을 충족시키는 경우가 많습니다.\n\n```js\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\ntype ReadonlyPartialUser = Readonly\u003cPartial\u003cUser\u003e\u003e;\n\nconst user: ReadonlyPartialUser = {\n  id: 1,\n  name: \"Alice\"\n};\n\nuser.id = 2; // 오류: 'id'는 읽기 전용 속성이기 때문에 할당할 수 없습니다.\n```\n\n# 5. TypeScript의 고급 유형 추론 활용하기\n\nTypeScript의 고급 유형 추론 메커니즘은 해당 유형 시스템의 핵심 기능입니다. 유형 추론을 통해 TypeScript는 변수, 함수 반환 값 및 표현식의 유형을 자동으로 추론하여 명시적인 유형 주석을 줄이고 코드를 더 간결하고 우아하게 만들 수 있습니다. 아래에서는 몇 가지 고급 유형 추론 기술과 예제를 소개하여 이러한 기능을 활용하여 코드 품질과 가독성을 개선하는 방법을 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5.1 타입 추론의 기본\n\nTypeScript는 많은 상황에서 자동으로 타입을 추론할 수 있습니다.\n\n예를 들어 변수를 선언하고 값을 할당할 때 TypeScript는 할당된 값에 기반하여 변수의 타입을 추론합니다:\n\n```js\nlet x = 42; // TypeScript는 x의 타입을 숫자로 추론합니다\nlet y = \"Hello, TypeScript!\"; // TypeScript는 y의 타입을 문자열로 추론합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수를 정의하고 값으로 반환할 때 TypeScript는 함수의 반환 유형을 자동으로 추론합니다:\n\n```js\nfunction add(a: number, b: number) {\n  return a + b; // TypeScript는 함수의 반환 유형을 number로 추론합니다\n}\n```\n\n이 추론 메커니즘은 코드를 더 간결하게 만들어주며, 함수의 반환 유형을 명시적으로 지정할 필요가 없어집니다.\n\n## 5.2 고급 유형 추론 예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 객체 속성 유형 추론: TypeScript는 객체 리터럴을 기반으로 속성의 유형을 자동으로 추론할 수 있어요. \n\n```js\nconst user = {\n  id: 1,\n  name: \"Alice\",\n  email: \"alice@example.com\"\n};\n\n// TypeScript는 user의 유형을 { id: number; name: string; email: string; }으로 추론해요.\n```\n\n- 배열 요소 유형 추론: TypeScript는 요소를 기반으로 배열의 유형을 추론할 수 있어요.\n\n```js\nconst numbers = [1, 2, 3, 4]; // TypeScript는 numbers의 유형을 number[]로 추론해요.\nconst names = [\"Alice\", \"Bob\", \"Charlie\"]; // TypeScript는 names의 유형을 string[]로 추론해요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 일반 유형 추정: TypeScript를 사용할 때 제네릭을 사용하면 전달된 매개변수를 기반으로 제네릭의 특정 유형을 추정할 수 있습니다.\n\n```js\nfunction identity\u003cT\u003e(value: T): T {\n  return value;\n}\n\nconst numberIdentity = identity(42); // TypeScript는 T를 숫자로 추정합니다.\nconst stringIdentity = identity(\"Hello\"); // TypeScript는 T를 문자열로 추정합니다.\n```\n\n- 조건부 유형 추정: TypeScript는 조건부 유형을 지원하여 다양한 조건에 기반해 다른 유형을 추정할 수 있습니다.\n\n```js\ntype IsString\u003cT\u003e = T extends string ? \"yes\" : \"no\";\n\ntype A = IsString\u003cstring\u003e; // \"yes\"\ntype B = IsString\u003cnumber\u003e; // \"no\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 함수 매개변수 유추하기: 고계 함수를 사용할 때 TypeScript는 콜백 함수의 매개변수 유형을 추론할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n =\u003e n * 2); // TypeScript는 n의 타입을 숫자로 추론합니다\n```\n\n## 5.3 실전에서의 고급 유추 활용\n\n실제 프로젝트에서 TypeScript의 고급 유추 기능을 활용하면 코드가 더 간결하고 표현력이 높아집니다. 아래는 이러한 유추 기술을 실제 개발에서 적용하는 방법을 종합적으로 보여주는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction getUser(id: number): User {\n  return {\n    id,\n    name: \"User\" + id,\n    email: `@example.com\"\u003euser${id}@example.com`\n  };\n}\n\nconst users = [getUser(1), getUser(2), getUser(3)];\n\nfunction sendEmail(user: User, message: string) {\n  console.log(`Sending email to ${user.email}: ${message}`);\n}\n\nusers.forEach(user =\u003e sendEmail(user, \"Welcome!\")); // TypeScript는 user의 타입을 User로 추론합니다.\n```\n\nTypeScript는 우아하고 효율적인 코드를 작성할 수 있도록 다양한 강력한 기능을 제공합니다. 타입 예측자를 사용하면 다른 유형 간 안전한 타입 전환을 보장하는 정확한 타입 검사를 수행할 수 있으며, 인덱스 액세스 유형을 사용하면 복잡한 유형을 동적으로 조작하고 액세스할 수 있습니다. 유틸리티 타입을 사용하면 유형을 정의하는 프로세스가 단순화되어 코드 가독성과 유지보수성이 향상되며, 고급 타입 추론을 통해 TypeScript가 변수와 표현식의 유형을 자동으로 추론하여 명시적인 유형 주석이 필요한 경우를 줄입니다.\n\n이러한 기능은 개발 효율성을 향상시킬 뿐만 아니라 코드의 유형 안전성과 유지보수성을 향상시킵니다. 실제 개발에서 이러한 TypeScript 기능을 최대한 활용하면 더 깨끗하고 명확하며 견고한 코드를 작성하는 데 도움이 됩니다. TypeScript의 강력한 기능을 지속적으로 탐구하고 적용함으로써 프로젝트에서 더 높은 품질의 코드와 더 효율적인 개발 프로세스를 달성할 수 있습니다.\n\n# 간단하게 설명하기 🚀\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해 주세요 👏️️\n- 팔로잉해 주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoMakeYourTypeScriptCodeMoreElegant_0.png","tag":["Tech"],"readingTime":10},{"title":"이전 화면으로 돌아갈 때 데이터 전송하기 React Native","description":"","date":"2024-06-20 05:15","slug":"2024-06-20-PassDataWhenbacktoPreviousScreenReactNative","content":"\n\n리액트 네비게이션에서 navigation.goBack 함수를 사용하면 스택 내비게이터에서 이전 화면으로 돌아갈 수 있어요. 이전 화면으로 돌아갈 때 데이터를 전달하고 싶다면 params 속성과 함께 navigation.goBack 함수를 사용할 수 있어요.\n\n예를 들어:\n\nScreenA와 ScreenB 두 개의 화면이 있다고 가정해봅시다. ScreenA에서 ScreenB로 이동한 다음 ScreenA로 돌아가면서 데이터를 전달하고 싶다면요.\n\nScreenA에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState } from 'react';\nimport { View, Text, Button } from 'react-native';\n\nconst ScreenA = ({ navigation }) =\u003e {\n  const [dataFromScreenB, setDataFromScreenB] = useState(null);\n\n  const navigateToScreenB = () =\u003e {\n    navigation.navigate('ScreenB', {\n      onGoBack: (data) =\u003e {\n        // ScreenB로부터 데이터를 처리하는 콜백 함수\n        setDataFromScreenB(data);\n      },\n    });\n  };\n\n  return (\n    \u003cView\u003e\n      \u003cText\u003eScreenB로부터의 데이터: {dataFromScreenB}\u003c/Text\u003e\n      \u003cButton title=\"ScreenB로 이동\" onPress={navigateToScreenB} /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default ScreenA;\n```\n\n```js\nimport React, { useState } from 'react';\nimport { View, TextInput, Button } from 'react-native';\n\nconst ScreenB = ({ route, navigation }) =\u003e {\n  const [dataToSendBack, setDataToSendBack] = useState('');\n\n  const handleGoBack = () =\u003e {\n    // onGoBack 콜백을 사용해 ScreenA로 데이터 전달\n    route.params.onGoBack(dataToSendBack);\n    navigation.goBack();\n  };\n\n  return (\n    \u003cView\u003e\n      \u003cTextInput\n        placeholder=\"데이터 입력\"\n        value={dataToSendBack}\n        onChangeText={(text) =\u003e setDataToSendBack(text)}\n      /\u003e\n      \u003cButton title=\"데이터와 함께 돌아가기\" onPress={handleGoBack} /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default ScreenB;\n```\n\n이 예시에서:\n- ScreenA는 navigation.navigate를 사용하여 ScreenB로 이동하고 매개변수로 콜백 함수(onGoBack)를 전달합니다.\n- ScreenB는 navigation route에서 콜백 함수를 추출하고 이를 사용하여 되돌아갈 때 ScreenA로 데이터를 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 패턴은 navigation.goBack를 사용할 때 자식 화면(ScreenB)에서 부모 화면(ScreenA)로 데이터를 전달할 수 있는 방법입니다. 코드를 귀하의 특정 사용 사례와 데이터 요구 사항에 맞게 조정해주세요.\n\n감사합니다!!!","ogImage":{"url":"/assets/img/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative_0.png"},"coverImage":"/assets/img/2024-06-20-PassDataWhenbacktoPreviousScreenReactNative_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 훅스 소개","description":"","date":"2024-06-20 05:14","slug":"2024-06-20-IntroductiontoReactHooks","content":"\n\n\n\n![React Hooks](/assets/img/2024-06-20-IntroductiontoReactHooks_0.png)\n\n리액트 훅(React Hooks)은 2018년 10월 React Conf에서 소개되었습니다. 이는 함수 컴포넌트에서 상태(state) 및 사이드 이펙트(side-effects)를 사용하는 방법으로, 훅(React Hooks) 이전에 함수 컴포넌트는 상태를 가지지 않고 라이프사이클 메서드를 관리할 수 없어 상태 관련 로직을 처리하기 위해 함수 컴포넌트를 클래스 컴포넌트로 변환해야 했습니다. 하지만 훅(React Hooks)을 사용하면 함수 컴포넌트에서도 상태와 사이드 이펙트를 처리할 수 있어 클래스 컴포넌트를 사용할 필요가 없어졌습니다.\n\n# React Hooks의 필요성\n\n리액트 훅(React Hooks)은 함수 컴포넌트에서 상태 관리와 사이드 이펙트를 도입하기 위해 설계되었습니다. 이를 통해 컴포넌트의 리팩터링을 방지할 수 있게 되었습니다. 훅(React Hooks) 이전에는 상태와 라이프사이클 메서드를 클래스 컴포넌트에서만 사용할 수 있었습니다. 리액트 훅(React Hooks)을 사용하면 이와 같은 불필요한 리팩터링을 방지하며 리액트 애플리케이션을 보다 우아하고 가벼운 방식으로 작성할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cp\u003eYou clicked {this.state.count} times\u003c/p\u003e\n        \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e\n          Click me\n        \u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nexport default Counter;\n```\n\n```js\nimport React from 'react';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eYou clicked {count} times\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\n        Click me\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default Counter;\n```\n\n# 부수효과 로직\n\n클래스 컴포넌트에서는 부수효과를 componentDidMount, componentDidUpdate 및 componentWillUnmount와 같은 라이프사이클 메소드에서 관리했습니다. React Hooks는 useEffect Hook을 사용하여 함수 컴포넌트에서 부수효과를 처리할 수 있도록 해줍니다. useEffect Hook은 설정(setup) 및 정리(cleanup) 단계 모두를 캡슐화합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // 기능 1을 위한 리스너 추가\n    // 기능 2를 위한 리스너 추가\n  }\n\n  componentWillUnmount() {\n    // 기능 1을 위한 리스너 제거\n    // 기능 2를 위한 리스너 제거\n  }\n\n  ...\n}\n```\n\n```js\nimport React from 'react';\n\nfunction MyComponent() {\n  React.useEffect(() =\u003e {\n    // 기능 1을 위한 리스너 추가 (셋업)\n    return () =\u003e {\n      // 기능 1을 위한 리스너 제거 (정리)\n    };\n  });\n\n  React.useEffect(() =\u003e {\n    // 기능 2를 위한 리스너 추가 (셋업)\n    return () =\u003e {\n      // 기능 2를 위한 리스너 제거 (정리)\n    };\n  });\n\n  ...\n}\n```\n\n# React의 추상화 지옥\n\nReact에서의 고급 패턴인 고차 컴포넌트(HOCs) 및 렌더 프롭 컴포넌트는 종종 복잡한 컴포넌트 트리를 유발했습니다. React Hooks는 이를 단순화시켜 함수에 로직을 캡슐화하여 추가 컴포넌트 대신 더 평평한 컴포넌트 트리를 만들어냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\nimport { compose, withReducer } from 'recompose';\nimport { withRouter } from 'react-router-dom';\n\nfunction App({ history, state, dispatch }) {\n  return (\n    \u003cThemeContext.Consumer\u003e\n      {theme =\u003e (\n        \u003cContent theme={theme}\u003e\n          ...\n        \u003c/Content\u003e\n      )}\n    \u003c/ThemeContext.Consumer\u003e\n  );\n}\n\nexport default compose(\n  withRouter,\n  withReducer(reducer, initialState)\n)(App);\n```\n\n```js\nimport React from 'react';\nimport { useTheme } from 'styled-components';\nimport { useRouter } from 'react-router-dom';\n\nfunction App() {\n  const theme = useTheme();\n  const history = useRouter();\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n\n  return (\n    \u003cContent theme={theme}\u003e\n      ...\n    \u003c/Content\u003e\n  );\n}\n\nexport default App;\n```\n\n# JavaScript Class Confusion\n\n자바스크립트 클래스는 'this', 클래스 바인딩 및 상속과 같은 개념 때문에 가파른 학습 곡선을 가지고 있습니다. React Hooks는 이러한 복잡성 없이 컴포넌트를 작성할 수 있도록 해주어 React 초심자에게 더 부드러운 학습 곡선을 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  state = { value: 0 };\n\n  onIncrement = () =\u003e {\n    this.setState(state =\u003e ({\n      value: state.value + 1\n    }));\n  };\n\n  onDecrement = () =\u003e {\n    this.setState(state =\u003e ({\n      value: state.value - 1\n    }));\n  };\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        {this.state.value}\n        \u003cbutton onClick={this.onIncrement}\u003e+\u003c/button\u003e\n        \u003cbutton onClick={this.onDecrement}\u003e-\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nexport default Counter;\n```\n\n## React Hooks와 어떻게 다른가요?\n\nReact Hooks는 React의 기본 사항을 변경하지는 않고, 단지 컴포넌트를 작성하는 새로운 방법을 제공합니다. 로컬 상태와 라이프사이클 메소드를 가진 클래스 컴포넌트는 여전히 작동하며, HOCs나 Render Props와 같은 고급 패턴도 유효합니다. React Hooks는 보다 간소화된 함수 컴포넌트를 가능케 함으로써 React의 미래 개발을 단순화하는 API를 추가합니다.\n\n## 다루어진 주제들\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모든 것이 변화합니다: 훅스는 React 애플리케이션을 작성하는 방식을 변화시킬 것이지만 기존의 클래스 컴포넌트는 여전히 작동합니다.\n- React는 덩치가 커지고 있는 중: React는 날씬한 API를 유지하려 노력합니다. 훅스는 미래의 React API를 단순화하는 방향으로 나아가는 한 걸음입니다.\n- 클래스는 잘 작동했습니다: 훅스는 특히 React 초심자들에게 컴포넌트를 작성하는 더 간단한 방법을 제공합니다.\n- 마법 같아요: 훅스는 마법처럼 보일 수 있지만 클래스 컴포넌트와 마찬가지로 React의 내부 업데이트 큐를 활용합니다.\n\n# 일반적인 React 훅 사용하기\n\nuseState 훅은 함수 컴포넌트에서 로컬 상태를 관리하는 데 사용됩니다.\n\n- 예시: 항목 배열 관리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\n\nconst INITIAL_LIST = [\n  { id: '0', title: 'React with RxJS', url: 'https://example.com/rxjs' },\n  { id: '1', title: 'React with Apollo', url: 'https://example.com/apollo' },\n];\n\nfunction App() {\n  const [list, setList] = React.useState(INITIAL_LIST);\n\n  const onRemoveItem = id =\u003e {\n    const newList = list.filter(item =\u003e item.id !== id);\n    setList(newList);\n  };\n\n  return (\n    \u003cul\u003e\n      {list.map(item =\u003e (\n        \u003cli key={item.id}\u003e\n          \u003ca href={item.url}\u003e{item.title}\u003c/a\u003e\n          \u003cbutton type=\"button\" onClick={() =\u003e onRemoveItem(item.id)}\u003e\n            Remove\n          \u003c/button\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n\nexport default App;\n```\n\nuseEffect Hook은 함수 컴포넌트에서 사이드 이펙트를 처리하기 위해 사용됩니다.\n\n- 예시: 간단한 스톱워치 구현\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [isOn, setIsOn] = React.useState(false);\n  const [timer, setTimer] = React.useState(0);\n\n  React.useEffect(() =\u003e {\n    let interval;\n\n    if (isOn) {\n      interval = setInterval(() =\u003e setTimer(prevTimer =\u003e prevTimer + 1), 1000);\n    }\n\n    return () =\u003e clearInterval(interval);\n  }, [isOn]);\n\n  return (\n    \u003cdiv\u003e\n      {timer}\n\n      {!isOn \u0026\u0026 (\n        \u003cbutton type=\"button\" onClick={() =\u003e setIsOn(true)}\u003e\n          Start\n        \u003c/button\u003e\n      )}\n\n      {isOn \u0026\u0026 (\n        \u003cbutton type=\"button\" onClick={() =\u003e setIsOn(false)}\u003e\n          Stop\n        \u003c/button\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 useEffect 훅은 스톱워치가 시작될 때(즉, isOn이 true일 때) 인터벌을 설정하고 스톱워치가 중지될 때(즉, isOn이 false일 때) 인터벌을 정리합니다. 이는 React Hooks를 사용하여 함수 컴포넌트에서 사이드 이펙트를 관리하는 방법을 보여줍니다.\n\n# 결론\n\nReact Hooks는 함수 컴포넌트에서 상태와 사이드 이펙트를 관리하는 강력한 방법을 제공하여 클래스 컴포넌트와 복잡한 추상화가 필요하지 않게 합니다. 특히 초보자에게 React 개발을 간단하고 기능적으로 작성할 수 있도록 돕습니다.\n\n즐거운 학습되세요! 😎","ogImage":{"url":"/assets/img/2024-06-20-IntroductiontoReactHooks_0.png"},"coverImage":"/assets/img/2024-06-20-IntroductiontoReactHooks_0.png","tag":["Tech"],"readingTime":7},{"title":"구글 파이어베이스를 React에서 활용하기","description":"","date":"2024-06-20 05:13","slug":"2024-06-20-MakinguseofGooglefirebaseinReact","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png\" /\u003e\n\n# React에서 Firebase 탐험하기\n\n환영합니다!\n\n저는 Firebase와 React의 흥미로운 세계로 다가가려 합니다. 그래서 Firebase는 무엇일까요? 구글이 제공하는 클라우드 기반 도구함으로 생각해보세요. 개발자로서 우리의 삶을 더 쉽게 만들어주는 도구들로 가득차 있습니다. 이는 우리가 웹 앱/React 앱에 멋진 기능을 추가하기 위해 빠르게 개발할 수 있는 초능력과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase는 강력한 백엔드 서비스(BaaS) 솔루션이며, 개발자들에게 클라우드 서비스를 쉽게 React 애플리케이션에 통합할 수 있는 기회를 제공합니다.\n\n# 주요 Firebase 기능\n\n## 1. 실시간 데이터베이스 (Firestore)\n\nFirestore는 클라우드 저장소 장치로 생각해보세요. 이것은 실시간으로 데이터를 저장하고 공유할 수 있는 NoSQL 클라우드 데이터베이스입니다. 무언가를 업데이트하면 React 앱을 사용하는 모든 사용자가 수동 새로 고침 없이 즉시 보여주므로 부드럽고 반응이 빠른 사용자 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 인증\n\nFirebase Authentication은 웹/앱을 위한 VIP 목록을 갖는 것과 같습니다. 회원가입, 로그인 및 비밀번호 관리를 처리하여 누가 들어오고 나가는지를 관리하는 데 도움을 줍니다. 보안이 쉬워졌어요!\n\n## 3. 호스팅\n\nFirebase Hosting은 React 애플리케이션을 배포하고 호스팅하기 위한 번거로움 없는 솔루션을 제공합니다. 전 세계 사용자를 위한 빠른 로딩 시간을 위한 글로벌 콘텐츠 전송 네트워크(CDN)를 제공하여 전 세계 사용자에게 원활한 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4. 클라우드 함수\n\n이것들은 작은 도우미들 같아요. Firebase 클라우드 함수를 사용하면 Firebase 기능에서 트리거된 이벤트에 응답하여 서버 측 코드를 실행할 수 있어요. 이 서버리스 아키텍처는 서버를 관리할 필요 없이 React 애플리케이션에서 백엔드 로직을 실행하는 데 특히 유용할 수 있어요.\n\n## 5. 저장소\n\nFirebase 저장소는 디지털 저장 공간이에요. 이미지와 비디오를 안전하게 보관하여 React 앱에서 미디어를 손쉽게 표시할 수 있도록 도와줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React와 Firebase의 우정\n\nReact와 Firebase를 결합하면 마치 호두 버터와 쨈을 섞는 것과 같아요. React는 앱의 외관과 느낌을 다루고(프론트엔드), Firebase는 뒷단 작업을 처리해줘요(백엔드).\n\n액션 준비 완료!\n\n다가오는 레슨에서는 손을 놓지 않을 거예요. 프로젝트 설정부터 React 컴포넌트에서 Firebase 기능을 사용하기까지, 멋진 실시간 및 안전한 애플리케이션을 만들기 위해 준비하세요. 함께 Firebase의 특별 능력을 React 우주에서 발휘해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Firebase와 React를 통합하는 단계별 안내서\n\n## 단계 1: Firebase 계정 설정\n\n시작하기 전에 구글 계정이 있어야 합니다. 계정이 없다면 하나 생성하십시오. Firebase 콘솔로 이동하여 로그인합니다.\n\n## 단계 2: 새 Firebase 프로젝트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`\u003cimg src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_1.png\" /\u003e`\n\n\"Create a Project\"을 탭하세요\n\n`\u003cimg src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_2.png\" /\u003e`\n\n프로젝트에 제목을 입력하고 두 개의 상자를 체크하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_3.png\" /\u003e\n\n이 프로젝트에서는 GOOGLE ANALYSIS를 사용하지 않을 것이므로 내 것을 비활성화했습니다. 여러분은 본인 것을 비활성화할지 여부를 결정할 수 있습니다.\n그런 다음 \"CREATE PROJECT\"를 클릭하세요.\n\n## 단계 3: 실시간 데이터베이스 설정\n\nReal-time database. Firebase 콘솔에서 \"Build\" 쪽으로 이동한 후 \"Realtime Database\"를 선택하세요. \"Create Database\"를 클릭하고 위치를 선택하세요. 간편함을 위해 테스트 모드에서 시작하세요.\n원하는 대로 나중에 바꿀 수 있는 형식으로 콘솔을 편집하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_4.png)\n\n## 단계 4: Firebase 구성\n\n프로젝트 대시보드에서 톱니바퀴 아이콘을 클릭한 후 \"프로젝트 설정\"을 선택합니다. \"일반\" 탭에서 아래로 내려가서 \"앱\"을 클릭한 후 웹 아이콘(`/`)을 클릭하세요. 프로젝트 이름을 작성하고 npm을 사용하여 제공된 구성 스니펫을 복사하세요.\n\n## 단계 5: React 앱 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널을 열고 다음을 실행해보세요:\n\n```js\nnpx create-react-app my-firebase-app\ncd my-firebase-app\n```\n\n## 단계 6: React 앱에 Firebase 설치하기\n\n프로젝트 디렉토리에서 Firebase 종속성을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install firebase\n```\n\n## 단계 7: React 애플리케이션 실행하기\n\n터미널에서 다음 명령을 실행하세요:\n\n```js\nnpm start\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 기본 브라우저에서 자동으로 열리지 않는 경우 http://localhost:3000을 방문하여 React 앱이 어떻게 작동하는지 확인할 수 있습니다.\n\n## 단계 8: React 앱에서 Firebase 구성하기\n\n“configuration.jsx” 파일을 생성하고 Step 4에서 Firebase 구성을 복사하여 src/index.js 파일에 붙여넣으세요.\n\n```js\n// 필요한 Firebase 모듈 가져오기\nimport { initializeApp } from \"firebase/app\";\n\n// 여기에 Firebase 구성 추가\nconst firebaseConfig = {\n  apiKey: \"YOUR_API_KEY\",\n  authDomain: \"YOUR_AUTH_DOMAIN\",\n  projectId: \"YOUR_PROJECT_ID\",\n  storageBucket: \"YOUR_STORAGE_BUCKET\",\n  messagingSenderId: \"YOUR_MESSAGING_SENDER_ID\",\n  appId: \"YOUR_APP_ID\",\n};\n\n// Firebase 초기화\nconst cong = initializeApp(firebaseConfig);\n\nexport default cong;\n// 이제 React 앱에서 Firebase 서비스를 사용할 수 있습니다!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 9: React 구성 요소에서 데이터베이스 사용하기\n\n예를 들어, App.js 파일에서 데이터를 가져와서 표시하는 방법입니다.\n파일에서 기본 코드를 제거하고 아래 코드로 대체하세요.\n\n```js\nimport React, { useEffect, useState } from \"react\";\nimport cong from \"./configuration\"; // 구성 파일의 올바른 경로를 가정\nimport { getDatabase, ref, onValue } from \"firebase/database\";\n\n// App.js\n\nfunction App() {\n  const [data, setData] = useState([]);\n\n  useEffect(() =\u003e {\n    // 제공된 구성으로 Firebase 데이터베이스를 초기화합니다\n    const database = getDatabase(cong);\n    \n    // 데이터베이스의 특정 컬렉션에 대한 참조\n    const collectionRef = ref(database, \"your_collection\");\n\n    // 데이터베이스에서 데이터를 가져오는 함수\n    const fetchData = () =\u003e {\n      // 컬렉션의 변경 사항을 수신대기\n      onValue(collectionRef, (snapshot) =\u003e {\n        const dataItem = snapshot.val();\n\n        // 데이터가 있는지 확인\n        if (dataItem) {\n          // 객체 값을 배열로 변환\n          const displayItem = Object.values(dataItem);\n          setData(displayItem);\n        }\n      });\n    };\n\n    // 컴포넌트가 마운트될 때 데이터를 가져옵니다\n    fetchData();\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e데이터베이스에서 가져온 데이터:\u003c/h1\u003e\n      \u003cul\u003e\n        {data.map((item, index) =\u003e (\n          \u003cli key={index}\u003e{item}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저를 확인하면 데이터베이스 콘솔에 나열된 항목과 일치하는 내용이 표시됩니다.\n\n![Google Firebase in React](/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_5.png)\n\n데이터베이스에 새 항목을 추가하고 실시간 업데이트를 확인하며 경험을 향상시켜보세요. 항목을 더 복잡하게 만들어 보거나 코드를 조정하여 콘솔에 이러한 변화를 반영하고, 원하는대로 프레젠테이션을 스타일링하여 창의력을 발휘해보세요. 가능성은 여러분이 탐험할 수 있도록 열려 있습니다!","ogImage":{"url":"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png"},"coverImage":"/assets/img/2024-06-20-MakinguseofGooglefirebaseinReact_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 API 가져오기 다섯 가지 방법으로 프로세스 간소화하기","description":"","date":"2024-06-20 05:12","slug":"2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods","content":"\n\n\n![image](/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png)\n\n# 소개\n\nAPI에서 데이터를 가져오는 것은 현대 웹 애플리케이션에 필수적입니다. React에서는 페이지 전체를 새로 고침하지 않고 콘텐츠를 로드하고 표시할 수 있습니다. 이 블로그에서는 API 가져오기 및 React에서 이를 수행하는 다섯 가지 쉬운 방법을 설명하겠습니다.\n\nAPI 가져오기 설명\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI(Application Programming Interface)는 요청을 보내고 응답을 받습니다. 앱이 데이터를 요청하면, API가 데이터베이스에서 가져와 다시 전송합니다. 이 과정은 실시간으로 이루어지며, 페이지를 새로 고침할 필요가 없습니다.\n\n데이터 가져오기는 API에서 정보를 가져와 앱의 프론트엔드로 보내는 것을 의미합니다. React에서는 다음을 사용하여 데이터를 가져올 수 있습니다:\n\n- Fetch\n- Async/Await\n- Promises\n- Callbacks\n- Axios\n\n# 1. Fetch\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트의 fetch 함수를 사용하면 네트워크 요청을 할 수 있어요. 이 함수는 응답(response)을 반환하는 프로미스를 리턴하는데, 그 후에 이를 JSON으로 변환할 수 있어요.\n\n예시:\n\n```js\n// Fetch API 사용하기\nfetch('https://api.example.com/data')\n  .then(response =\u003e response.json())\n  .then(data =\u003e console.log(data))\n  .catch(error =\u003e console.error('데이터 가져오는 중 오류 발생:', error));\n```\n\n# 2. Async/Await\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기/대기는 프로미스를 처리하는 더 간단한 방법입니다. 이를 사용하면 동기 코드처럼 보이는 비동기 코드를 작성할 수 있습니다.\n\n예시:\n\n```js\n// async/await 사용\nconst fetchData = async () =\u003e {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n};\n\nfetchData();\n```\n\n# 3. 프로미스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약속은 비동기 작업을 처리할 수 있게 해줍니다. .then()과 .catch()를 연결하여 응답과 에러를 관리할 수 있어요.\n\n예시:\n\n```js\n// Promises 사용\nconst fetchData = () =\u003e {\n  fetch('https://api.example.com/data')\n    .then(response =\u003e response.json())\n    .then(data =\u003e console.log(data))\n    .catch(error =\u003e console.error('데이터를 가져오는 중 오류 발생:', error));\n};\n\nfetchData();\n```\n\n# 4. 콜백(callbacks)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백은 나중에 실행되도록 다른 함수에 전달된 함수입니다. 데이터를 가져오는 데는 복잡하기 때문에 자주 사용되지 않습니다.\n\n예시:\n\n```js\n// 콜백 사용\nconst fetchData = (callback) =\u003e {\n  fetch('https://api.example.com/data')\n    .then(response =\u003e response.json())\n    .then(data =\u003e callback(null, data))\n    .catch(error =\u003e callback(error, null));\n};\n\n\nfetchData((error, data) =\u003e {\n  if (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  } else {\n    console.log(data);\n  }\n});\n```\n\n# 5. Axios\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAxios는 HTTP 요청을 보다 간편하게 만들어주는 라이브러리로, async/await와 유사하게 작동하지만 더 많은 기능을 제공합니다.\n\n예시:\n\n```js\n// Axios 사용\nimport axios from 'axios';\n\nconst fetchData = async () =\u003e {\n  try {\n    const response = await axios.get('https://api.example.com/data');\n    console.log(response.data);\n  } catch (error) {\n    console.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n  }\n};\n\nfetchData();\n```\n\n맺음말\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact에서 데이터를 가져오는 간단한 방법들을 소개해 드렸어요. 각 방법마다 장단점이 있으니, 자신에게 가장 잘 맞는 방법을 선택할 수 있어요. 이러한 방법들을 알고 있으면 API를 효과적으로 다루고 동적인 React 애플리케이션을 만들 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png"},"coverImage":"/assets/img/2024-06-20-ReactAPIFetchingSimplifyingtheProcesswithFiveMethods_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트에서 권한 기반 인증 및 권한 부여 - 인증 핸들러로 특정 권한 및 익명 인증 페이지","description":"","date":"2024-06-20 05:11","slug":"2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages","content":"\n\nRole-based 인가 및 인증은 React 애플리케이션을 안전하게 유지하기 위해 사용자 역할에 따라 애플리케이션의 다른 부분에 대한 액세스를 제어하는 데 필수적입니다. 인증 핸들러를 사용하여 인증 및 권한 부여 논리를 관리할 것입니다.\n\n.Net Core와 유사한 구현은 다음에서 확인할 수 있습니다: https://medium.com/@siva.veeravarapu/role-based-authorization-in-net-core-a-beginners-guide-with-code-snippets-b952e5b952f7\n\nDotNet-FullStack-Dev와 함께 지속적인 학습과 탐험의 여정을 떠나보세요. 더 많은 정보를 알아보려면 저희 블로그 https://dotnet-fullstack-dev.blogspot.com 를 방문해 주세요.\n\n## 단계 1: 인증 컨텍스트 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 인증 상태를 관리하고 구성 요소에 인증 방법을 제공하는 Authentication Context를 만들어보세요.\n\nAuthContext.js:\n\n```js\nimport React, { createContext, useContext, useState } from 'react';\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =\u003e {\n  const [user, setUser] = useState(null);\n\n  const login = (userData) =\u003e {\n    // 여기에 로그인 로직을 구현합니다 (예: API 호출)\n    setUser(userData);\n  };\n\n  const logout = () =\u003e {\n    // 여기에 로그아웃 로직을 구현합니다\n    setUser(null);\n  };\n\n  return (\n    \u003cAuthContext.Provider value={{ user, login, logout }}\u003e\n      {children}\n    \u003c/AuthContext.Provider\u003e\n  );\n};\n\nexport const useAuth = () =\u003e useContext(AuthContext);\n```\n\n## 단계 2: 인증 구성 요소 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인, 로그아웃 및 보호된 경로용 구성 요소를 작성하십시오.\n\nLogin.js:\n\n```js\nimport React, { useState } from 'react';\nimport { useAuth } from './AuthContext';\n\nconst Login = () =\u003e {\n  const { login } = useAuth();\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleLogin = () =\u003e {\n    // 로그인 로직 구현 (예: AuthContext에서 로그인 메서드 호출)\n    login({ username, password });\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput type=\"text\" value={username} onChange={(e) =\u003e setUsername(e.target.value)} /\u003e\n      \u003cinput type=\"password\" value={password} onChange={(e) =\u003e setPassword(e.target.value)} /\u003e\n      \u003cbutton onClick={handleLogin}\u003e로그인\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Login;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\nimport { useAuth } from './AuthContext';\n\nconst Logout = () =\u003e {\n  const { logout } = useAuth();\n\n  const handleLogout = () =\u003e {\n    // 로그아웃 로직 구현 (예: AuthContext에서 logout 메서드 호출)\n    logout();\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={handleLogout}\u003e로그아웃\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Logout;\n```\n\nProtectedRoute.js:\n\n```js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\nconst ProtectedRoute = ({ component: Component, roles, ...rest }) =\u003e {\n  const { user } = useAuth();\n\n  return (\n    \u003cRoute {...rest} render={(props) =\u003e {\n      if (!user) {\n        return \u003cRedirect to='/login' /\u003e;\n      }\n\n      if (roles \u0026\u0026 !roles.includes(user.role)) {\n        return \u003cRedirect to='/' /\u003e;\n      }\n\n      return \u003cComponent {...props} /\u003e;\n    } /\u003e\n  );\n};\n\nexport default ProtectedRoute;\n```\n\n## 단계 3: 인증 컴포넌트 사용하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션 루트에서 인증 구성요소를 사용하세요.\n\nApp.js:\n\n```js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './AuthContext';\nimport Login from './Login';\nimport Logout from './Logout';\nimport ProtectedRoute from './ProtectedRoute';\nimport Home from './Home';\nimport AdminDashboard from './AdminDashboard';\n\nconst App = () =\u003e {\n  return (\n    \u003cAuthProvider\u003e\n      \u003cRouter\u003e\n        \u003cSwitch\u003e\n          \u003cRoute path='/login' component={Login} /\u003e\n          \u003cRoute path='/logout' component={Logout} /\u003e\n          \u003cProtectedRoute path='/admin' component={AdminDashboard} roles={['admin']} /\u003e\n          \u003cProtectedRoute path='/' component={Home} /\u003e\n        \u003c/Switch\u003e\n      \u003c/Router\u003e\n    \u003c/AuthProvider\u003e\n  );\n};\n\nexport default App;\n```\n\n리액트 애플리케이션에서 역할 기반의 접근 제어를 갖는 About 및 Contact 페이지를 추가하는 방법에 대해, 추가 구성요소와 라우트로 확장할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## About 및 Contact 컴포넌트 구현\n\nAbout.js:\n\n```js\nimport React from 'react';\n\nconst About = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eAbout Us\u003c/h1\u003e\n      \u003cp\u003eWelcome to our website!\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default About;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\n\nconst Contact = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eContact Us\u003c/h1\u003e\n      \u003cp\u003eYou can reach us via email or phone.\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Contact;\n```\n\n## Update ProtectedRoute Component\n\nProtectedRoute.js:\n\n```js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\nconst ProtectedRoute = ({ component: Component, roles, ...rest }) =\u003e {\n  const { user } = useAuth();\n\n  return (\n    \u003cRoute {...rest} render={(props) =\u003e {\n      if (!user) {\n        return \u003cRedirect to='/login' /\u003e;\n      }\n\n      if (roles \u0026\u0026 !roles.includes(user.role)) {\n        return \u003cRedirect to='/' /\u003e;\n      }\n\n      return \u003cComponent {...props} /\u003e;\n    }} /\u003e\n  );\n};\n\nexport default ProtectedRoute;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## App 컴포넌트 및 라우팅 업데이트\n\nApp.js:\n\n```js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './AuthContext';\nimport Login from './Login';\nimport Logout from './Logout';\nimport ProtectedRoute from './ProtectedRoute';\nimport Home from './Home';\nimport AdminDashboard from './AdminDashboard';\nimport About from './About';\nimport Contact from './Contact';\n\nconst App = () =\u003e {\n  return (\n    \u003cAuthProvider\u003e\n      \u003cRouter\u003e\n        \u003cSwitch\u003e\n          \u003cRoute path='/login' component={Login} /\u003e\n          \u003cRoute path='/logout' component={Logout} /\u003e\n          \u003cProtectedRoute path='/admin' component={AdminDashboard} roles={['admin']} /\u003e\n          \u003cProtectedRoute path='/about' component={About} roles={['user', 'admin']} /\u003e\n          \u003cRoute path='/contact' component={Contact} /\u003e\n          \u003cProtectedRoute path='/' component={Home} /\u003e\n        \u003c/Switch\u003e\n      \u003c/Router\u003e\n    \u003c/AuthProvider\u003e\n  );\n};\n\nexport default App;\n```\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 가이드에 따라 React 함수형 컴포넌트에서 인증 핸들러를 사용하여 역할 기반 인가 및 인증을 구현할 수 있습니다. 이 방법은 React 애플리케이션을 안전하게 보호하기 위한 유연하고 확장 가능한 솔루션을 제공합니다. 다양한 인증 및 권한 부여 전략을 실험하여 애플리케이션의 특정 요구 사항을 충족시킬 수 있습니다.\n\n이 방법을 통해 'About' 페이지에 대한 역할 기반의 액세스 제어와 'Contact' 페이지에 대한 무제한 액세스를 보장할 수 있습니다. 애플리케이션의 요구 사항에 따라 역할과 권한을 조정해주세요.","ogImage":{"url":"/assets/img/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages_0.png"},"coverImage":"/assets/img/2024-06-20-Role-BasedAuthorizationandAuthenticationinReactwithAuthHandlersSpecificrole-basedandanonymousauthpages_0.png","tag":["Tech"],"readingTime":7},{"title":"데스크톱에서 모바일 UI 검사 마스터하기 단계별 가이드","description":"","date":"2024-06-20 05:10","slug":"2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png)\n\n소개:\n데스크톱에서 모바일 UI 검사 여정을 시작하는 것은 웹 개발자에게 판을 뒤집는 일일 수 있습니다. 오늘은 Chrome Inspect를 활용하여 모바일 브라우저 테스트 프로세스를 간소화하는 단계별 안내서를 공유해 드리겠습니다. 바로 시작해 보죠!\n\n단계 1: 모바일 장치에서 USB 디버깅 활성화 먼저, 모바일 장치에서 USB 디버깅이 활성화되어 있는지 확인하세요. 이 설정을 통해 장치가 USB 연결을 통해 데스크톱과 통신할 수 있게 됩니다.\n[이미지](https://tenor.com/blXOu.gif)\n\n단계 2: 모바일 장치를 데스크톱에 연결 USB 케이블을 사용하여 모바일 장치와 데스크톱을 연결하세요. 연결되면 장치에서 USB 디버깅을 허용할 지 여부를 확인하는 메시지가 표시될 것입니다. 허용하고 계속 진행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 단계 3: 데스크탑에서 크롬 실행\n데스크탑에서 Google Chrome을 열고 휴대폰에서 검사하려는 웹 페이지로 이동합니다.\n\n### 단계 4: 크롬 검사 열기\n크롬 브라우저의 주소 표시줄에 chrome://inspect를 입력하고 Enter 키를 누르세요. 이렇게 하면 크롬 검사 페이지가 열립니다.\n\n![이미지](/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_1.png)\n\n### 단계 5: 모바일 장치 확인\n크롬 검사 페이지의 \"장치\" 섹션에서 연결된 모바일 장치가 표시됩니다. 장치 이름 옆의 \"검사\" 버튼을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 6:** 모바일 UI 요소 살펴보기! 이제 데스크톱 화면에서 기기의 모바일 브라우저 인터페이스를 확인할 수 있어요. 모바일 기기에서 표시된 웹 페이지 요소들을 탐험해보세요.\n\n**단계 7:** 실시간으로 CSS 검사 및 수정하기 크롬 검사를 통해 실시간으로 CSS 속성을 검사하고 수정할 수 있어요. 웹 페이지의 요소 중 하나를 마우스 오른쪽 버튼으로 클릭하고 컨텍스트 메뉴에서 \"검사\"를 선택하세요. 이렇게 하면 개발자 도구 패널이 열리며 CSS 스타일을 확인하고 조작할 수 있어요.\n\n**단계 8:** 디버깅이 쉽습니다 모바일 웹 페이지에서 레이아웃 불일치나 스타일링 문제를 식별하고 개발자 도구 패널을 사용하여 실시간으로 조정할 수 있어요. 여백을 조정하거나 글꼴 크기를 조절하거나 색상을 미세하게 조정하는 등 필요한 조정이 필요할 때 크롬 검사를 통해 정밀하게 디버깅할 수 있어요.\n\n**단계 9:** 변경 사항 저장 및 적용 필요한 수정 사항을 완료했다면 변경 사항을 개발자 도구 패널에서 직접 저장할 수 있어요. 변경 사항을 실시간으로 웹 페이지에 적용하려면 \"저장\" 버튼을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 10 단계: 반응성 및 기능 테스트 마무리하기 전에 검사를 마무리하기 전에 다양한 화면 크기에서 웹 페이지의 반응성과 기능을 테스트하는 것을 잊지 마세요. Chrome Inspect를 사용하면 다른 기기 해상도를 시뮬레이트하여 사용자 경험을 원활하게 만들 수 있습니다.\n\n결론:\n\nChrome Inspect를 사용하여 데스크톱에서 모바일 UI 검사의 기술을 마스터한 것을 축하합니다! 이 단계별 가이드를 따라가면 웹 개발 워크플로를 혁신할 강력한 도구를 활용할 수 있습니다. 가능성을 받아들이고 다양한 기술을 실험하며 Chrome Inspect로 디버깅 능력을 향상시키세요.\n\nBaby Wolf Codes에게 심층적인 비디오 튜토리얼을 제공해준 특별한 감사를 표합니다. 여기에서 튜토리얼을 시청할 수 있습니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringMobileUIInspectiononDesktopAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트를 배우기 전에 반드시 알아야 할 JavaScript ES6 기능들","description":"","date":"2024-06-20 05:09","slug":"2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact","content":"\n\n## React를 배우기 전에 이 개념들을 꼭 익히세요\n\n![JavaScript ES6 Features](/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png)\n\nReact를 배우려는 경우, 당연히 JavaScript 기본 개념을 이해해야 합니다.\n\nReact는 또한 많은 ES6 개념을 사용하는데, 이미 알고 있어야 합니다. 이 튜토리얼에서는 React를 배우기 전에 꼭 알아야 할 가장 흔히 사용되는 ES6 기능을 다룰 것입니다. 이러한 개념을 학습하고 이해하는 것은 React 여행을 즐겁고 원할하게 만들어줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 템플릿 리터럴\n\nES6는 문자열 작업을 쉽게 만들어주었습니다. 문자열을 더하기(+) 기호로 연결하는 대신, 템플릿 문자열은 더 간단한 방법을 제공합니다.\n\n```js\n// 문자열 연결하는 예전 방법\nfunction sumNumbers(a, b) {\n  return \"The sum of \" + a + \" and \" + b + \" is \" + (a + b);\n}\n// 템플릿 리터럴 사용\nfunction sumNumbers(a, b) {\n  return `The sum of ${a}  and ${b} is ${a + b}`;\n}\n```\n\n템플릿 리터럴은 여러 줄 문자열을 다루는 것을 더 쉽게 만들어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst multiLineString = `\n  Lorem ipsum dolor sit amet,\n  consectetur adipiscing elit.\n  Sed do eiusmod tempor incididunt\n  ut labore et dolore magna aliqua.\n`;\n\n``` \n\n# 화살표 함수\n\n화살표 함수를 사용하면 코드를 더 간결하게 만들 수 있어요. 일반 함수와 화살표 함수의 차이를 살펴봅시다.\n\n```js\n// 일반 함수\nfunction myFunction() {\n  // 표현식 또는 문장\n}\n// 화살표 함수\nconst myArrowFunction = () =\u003e {\n  // 표현식 또는 문장\n};\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화살표 함수를 사용하면 function 키워드 대신 뚱뚱한 화살표(=\u003e)를 사용하여 코드를 더 간결하게 만들 수 있어요.\n\n화살표 함수가 단일 표현식을 반환한다면 중괄호와 return 키워드를 생략할 수 있어요.\n\n화살표 함수가 단일 매개변수를 가진다면 매개변수 주위의 괄호를 생략할 수 있어요.\n```js\n// 명시적 반환 단일 표현식\nconst add = (a,b) =\u003e a + b;\n\n// 하나의 인수를 가져오는 경우 괄호를 생략해도 돼요\nconst squared = a =\u003e a * a;\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화살표 함수는 map(), filter(), forEach()와 같은 배열 메소드에서 일반적으로 사용됩니다.\n\n```js\nconst names = [\"Carol\", \"jane\", \"alice\"];\nconst capitalizedNames = names.map((name) =\u003e name.toUpperCase());\nconsole.log(capitalizedNames);\n\n//출력  // [ 'CAROL', 'JANE', 'ALICE' ]\n```\n\n위의 예시에서 보듯이, 우리는 하나의 인자만 전달하므로 괄호를 생략했습니다.\n\n# 객체 해체화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서의 구조 분해는 배열에서 값이나 객체의 속성을 개별 변수로 푸는 과정을 말합니다. 이는 데이터베이스나 API와 같이 복잡한 데이터 구조를 다룰 때 유용합니다.\n\n예를 들어, 간단한 고양이를 설명하는 객체가 있다고 가정해봅시다.\n\n```js\nconst cat = {\n  catName: 'Whiskers',\n  age: 3,\n  color: 'gray',\n  breed: 'Persian'\n};\n```\n\n고양이의 이름을 얻기 위해서는 보통 점 표기법이나 대괄호 표기법을 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nconst cat = {\n  catName: \"Whiskers\",\n  age: 3,\n  color: \"gray\",\n  breed: \"Persian\",\n};\n\n// console.log(cat.catNname)\n```\n\nHowever, with object destructuring, you can unpack the properties into variable names and assign them to the cat object like this:\n\n```js\nconst { catNname, age, color, breed } = cat;\nconsole.log(`My cat ${catNname} is ${age} moths old`)\n```\n\nThe output will be:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n내 고양이 'Whiskers'는 3개월입니다.\n```\n\n# 배열 해체\n\n배열 해체는 객체 해체와 유사합니다. 직원 배열이 있다고 가정해봅시다:\n\n```js\nconst employees = [\n    'Carol kristen deck ',\n    'john weber Smith',\n    'Alice k Johnson'\n];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직원 목록에서 1번 인덱스의 직원을 가져오려면 다음과 같이 할 수 있어요:\n\n```js\nemployees[1]\n```\n\n하지만 구조 분해를 사용하면 값을 이렇게 변수에 풀어낼 수 있어요:\n\n```js\nconst employees = [\n  \"Carol kristen deck \",\n  \"john weber Smith\",\n  \"Alice k Johnson\",\n];\n\nconst [E1, E2, E3] = employees;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nE1은 배열의 첫 번째 직원의 값이 되고, E2는 두 번째 직원의 값이 되는 식으로 진행됩니다. 만약 배열에서 첫 번째 직원만 필요하다면, 아래와 같이 나머지 부분을 비워두면 됩니다:\n\n```js\nconst [E1, ,] = employees;\nconsole.log(E1); \n// Carol kristen deck\n```\n\n# 객체 리터럴\n\n객체 리터럴을 사용하면 객체를 작성할 때 중복을 피할 수 있습니다. 예를 들어, 아래와 같은 Task 함수 생성자를 가진 경우를 생각해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n기본 형식보다 더 짧게 ES6 객체 리터럴로 작성할 수 있어요. 아래와 같이 써보세요;\n\nfunction Task(title, description, priority) {\n  return {\n    title,\n    description,\n    priority,\n  };\n}\n\n# 전개 연산자\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전개 연산자는 iterable 객체의 요소를 전개하는 데 사용됩니다. Iterable 객체에는 배열, 객체 및 문자열이 포함됩니다.\n\n전개 연산자는 요소를 복사, 결합 또는 다른 함수에 인수로 전달하는 데 사용될 수 있습니다. 예를 들어, 배열을 다룰 때 원본 배열을 변경하지 않고 작업해야 할 때, 다음과 같이 전개 연산자를 사용하여 배열의 사본을 만들 수 있습니다:\n\n```js\nconst names = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Ethan\"];\nconst namesCopy = [...names]\nconsole.log(namesCopy)\n```\n\n# 나머지 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n램덤(…) 연산자는 세 개의 점을 사용하며 확산 연산자와 유사합니다. 하지만 램덤 연산자는 함수 매개변수 내에서 여러 인수를 하나의 배열로 수집하는 데 사용됩니다.\n\n예를 들어, 숫자의 합계를 얻는 함수를 작성해야 한다고 가정해보겠습니다. 우리 배열이 무한수의 인수를 가질 수 있는 경우, 램덤 연산자를 사용하여 인수를 배열로 수집할 수 있습니다.\n\n```js\nfunction sumNumbers(...arr) {\n  let sum = 0;\n  for (let i = 0; i \u003c arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n}\n```\n\n그런 다음, 해당 함수를 사용하여 어떤 수의 인수든 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnumbers = [1, 2, 4];\ngrades = [30, 40, 50, 60, 70];\nconsole.log(sumNumbers(...numbers)); // 출력 // 7\nconsole.log(sumNumbers(...grades));   // 출력 // 250\n```\n\n나머지 연산자는 구조 분해 할당에도 사용할 수 있습니다. 예를 들어, 성적 배열의 첫 번째 요소를 추출해야 한다고 가정해보세요. 변수로 추출하고 나머지 요소를 아래와 같이 배열로 수집할 수 있습니다.\n\n```js\ngrades = [30, 40, 50, 60, 70];\nconst [index0, ...arr] = grades;\nconsole.log(math);\n```\n\n# for of 루프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`for of` 루프는 배열, 문자열, 타입 배열, 맵, 세트 및 NodeList와 같은 반복 가능한 객체의 요소를 반복하는 데 사용됩니다. `for of` 루프의 구문은 다음과 같습니다:\n\n```js\nfor (variable of iterable) {\n  // 각 변수에 대해 실행할 코드\n}\n```\n\n# 배열 순회\n\n```js\nconst currencyCodes = [\"USD\", \"EUR\", \"GBP\", \"JPY\"];\nfor (const code of currencyCodes) {\n  console.log(code);\n}\n// USD\n// EUR\n// GBP\n// JPY\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 객체 배열을 반복하는 방법\n\n예를 들어, 아래와 같이 여러 객체가 포함 된 배열이 있다고 가정 해 봅시다.\n\n```js\nconst currencies = [\n    { currency: \"US Dollar\", code: \"USD\" },\n    { currency: \"Euro\", code: \"EUR\" },\n    { currency: \"British Pound\", code: \"GBP\" },\n    { currency: \"Japanese Yen\", code: \"JPY\" }\n  ];\n```\n\ncurrencies 배열을 반복하면 각각의 개별 객체를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfor (const currency of currencies) {\n  console.log(currency);\n}\n```\n\n다음은 출력 결과입니다:\n\n```js\n{ currency: 'US Dollar', code: 'USD' }\n{ currency: 'Euro', code: 'EUR' }\n{ currency: 'British Pound', code: 'GBP' }\n{ currency: 'Japanese Yen', code: 'JPY' }\n```\n\n# NodeList을 반복하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드 목록(NodeList)은 웹 페이지의 문서에서 추출된 노드들의 컬렉션입니다. 예를 들어, 페이지에 `li` 요소로 이루어진 `ul`이 있다고 가정해 보세요:\n\n```js\n\u003cul class=\"languages\"\u003e\n  \u003cli\u003ePython\u003c/li\u003e\n  \u003cli\u003eJavaScript\u003c/li\u003e\n  \u003cli\u003eRuby\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n위와 같은 요소들을 포함하는 NodeList를 얻기 위해 querySelectorAll 속성을 사용할 수 있습니다.\n\n```js\nconst listItems = document.querySelectorAll('.languages li')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 각 요소의 textContent를 얻기 위해 for of 루프 개념을 사용해보세요.\n\n```js\nconst listItems = document.querySelectorAll(\".languages li\");\nfor (const item of listItems) {\n  console.log(item.textContent);\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_1.png\" /\u003e\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 매일 사용하는 ES6 기능은 무엇인가요? 아래 댓글로 알려주세요.\n\n읽어주셔서 감사합니다.\n\nJavaScript를 마스터하는 가장 좋은 방법은 프로젝트를 만드는 것입니다. 실용적인 JavaScript 뉴스레터를 구독하여 JavaScript 기술을 향상시키세요.\n\n# 간단명료하게 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 👏️️로 칭찬하고 팔로우하기\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptES6FeaturesYouneedtoKnowbeforeLearningReact_0.png","tag":["Tech"],"readingTime":7}],"page":"36","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"36"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>