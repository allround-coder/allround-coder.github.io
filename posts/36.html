<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/36" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/36" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" href="/post/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" href="/post/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" href="/post/2024-05-14-ExpressgatewayYournextAPIGatewaySolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" href="/post/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" href="/post/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" href="/post/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC에서 LMS를 통한 커뮤니케이션" href="/post/2024-05-14-CommunicationThroughLMSinLWC"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC에서 LMS를 통한 커뮤니케이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" href="/post/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" href="/post/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" href="/post/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Fetch API CORS 및 no-cors에 대한 궁극의 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기","description":"","date":"2024-05-14 13:33","slug":"2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB","content":"\n\n요즘의 디지털 세계에서는 보안이 매우 중요합니다. 특히 사용자 인증 프로세스에서 보안을 강화하는 일반적인 방법 중 하나는 일회용 비밀번호(OTP) 확인입니다. OTP는 사용자가 자격 증명과 함께 입력해야 하는 고유한 코드를 생성하여 보안의 추가적인 계층을 더합니다. 이 튜토리얼에서는 Node.js와 MongoDB를 사용하여 OTP 확인 시스템을 구축하는 과정을 단계별로 안내하겠습니다.\n\n![이미지](/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png)\n\n# 저와 소통하기:\n\nLinkedin: [링크](https://www.linkedin.com/in/suneel-kumar-52164625a/)\n\n\n\n사전 준비 사항: 구현에 들어가기 전에 다음을 설치했는지 확인하세요:\n\n- Node.js: 시스템에 Node.js가 설치되어 있는지 확인하세요. 공식 Node.js 웹사이트에서 다운로드할 수 있습니다.\n- MongoDB: 사용자 데이터 및 OTP 정보를 저장할 MongoDB를 설치하세요. 공식 MongoDB 웹사이트에서 다운로드할 수 있습니다.\n- 텍스트 편집기: 원하는 텍스트 편집기나 IDE를 선택하세요. VS Code, Sublime Text 또는 Atom이 인기 있는 선택지입니다.\n\n프로젝트 설정: 프로젝트 디렉토리를 설정하고 필요한 종속성을 설치하는 것으로 시작해봅시다. 터미널을 열고 다음 단계를 따르세요:\n\n- 프로젝트용 새 디렉토리를 만드세요:\n\n\n\n```js\nmkdir otp-verification-system\ncd otp-verification-system\n```\n\n새로운 Node.js 프로젝트를 초기화하세요:\n\n```js\nnpm init -y\n```\n\n필요한 종속성을 설치하세요:\n\n\n\n```js\nnpm install express mongoose twilio dotenv body-parser\n```\n\n- express: 웹 서버를 만들기 위해 사용됩니다.\n- mongoose: MongoDB와 상호 작용하기 위해 사용됩니다.\n- twilio: SMS를 통해 OTP를 전송하는 데 사용됩니다.\n- dotenv: 환경 변수를 관리하기 위해 사용됩니다.\n- body-parser: 들어오는 요청 본문을 구문 분석하기 위한 미들웨어입니다.\n\n이제 프로젝트가 설정되었으므로 OTP 인증 시스템을 구축할 차례입니다.\n\nMongoDB 설정: 먼저 MongoDB 데이터베이스를 설정해보겠습니다. 프로젝트 디렉토리에 db.js라는 파일을 생성하고 다음 코드를 추가하세요:\n```\n\n\n\n```js\nconst mongoose = require('mongoose');\n\nfunction connect() {\n  return new Promise((resolve, reject) =\u003e {\n    mongoose.connect('mongodb://localhost/otp_verification', {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n\n    const db = mongoose.connection;\n\n    db.on('error', error =\u003e {\n      console.error('MongoDB 연결 오류:', error);\n      reject(error);\n    });\n\n    db.once('open', () =\u003e {\n      console.log('MongoDB에 연결되었습니다');\n      resolve();\n    });\n  });\n}\n\nmodule.exports = { connect };\n```\n\n이 코드는 로컬 MongoDB 인스턴스에 연결하고 otp_verification이라는 이름의 데이터베이스를 생성합니다.\n\n사용자 모델 생성: 이제 사용자 정보를 저장할 사용자 모델을 만들어 봅시다. models/User.js 파일을 생성하고 다음 코드를 추가하세요:\n\n```js\nconst mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  username: String,\n  phone: String,\n  otp: String,\n  otpExpiration: Date,\n});\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n\n\n이 스키마는 MongoDB의 사용자 문서 구조를 정의합니다. 여기에는 사용자 이름, 전화번호, OTP 및 OTP 만료 시간 필드가 포함됩니다.\n\nOTP 생성 및 전송: 이제 SMS를 통해 OTP를 생성하고 전송하는 로직을 만들어 봅시다. 이를 위해 Twilio API를 사용하겠습니다. utils/otp.js라는 파일을 만들고 다음 코드를 추가하세요:\n\n```js\nconst twilio = require('twilio');\nconst dotenv = require('dotenv');\n\ndotenv.config();\n\nconst accountSid = process.env.TWILIO_ACCOUNT_SID;\nconst authToken = process.env.TWILIO_AUTH_TOKEN;\nconst client = new twilio(accountSid, authToken);\n\nasync function sendOTP(phone, otp) {\n  try {\n    const message = await client.messages.create({\n      body: `Your OTP is: ${otp}`,\n      from: process.env.TWILIO_PHONE_NUMBER,\n      to: phone,\n    });\n    console.log(`OTP sent to ${phone}: ${message.sid}`);\n  } catch (error) {\n    console.error('Error sending OTP:', error);\n  }\n}\n\nmodule.exports = { sendOTP };\n```\n\nTwilio 계정을 설정하고 필요한 자격 증명(Account SID, Auth Token 및 전화번호)을 얻었는지 확인하십시오. 이 정보는 .env 파일에 저장되어야 합니다.\n\n\n\nOTP 인증 엔드포인트 구현하기: 이제 OTP 인증을 처리하는 엔드포인트를 만들어 봅시다. routes/auth.js라는 파일을 만들고 아래 코드를 추가해주세요:\n\n```js\nconst express = require('express');\nconst router = express.Router();\nconst User = require('../models/User');\nconst { sendOTP } = require('../utils/otp');\nconst {randomInt} = require('crypto')\n\nrouter.post('/sendotp', async (req, res) =\u003e {\n  const { phone } = req.body;\n\n  // 6자리 OTP 생성\n  //const otp = Math.floor(100000 + Math.random() * 900000).toString();\n  const otp =  randomInt(100000, 999999);\n\n  try {\n    // OTP 및 만료 시간을 데이터베이스에 저장\n    const user = await User.findOneAndUpdate(\n      { phone },\n      { otp, otpExpiration: Date.now() + 600000 }, // OTP는 10분 후에 만료됨\n      { upsert: true, new: true }\n    );\n\n    // SMS로 OTP 전송\n    await sendOTP(phone, otp);\n\n    res.status(200).json({ success: true, message: 'OTP 전송 성공' });\n  } catch (error) {\n    console.error('OTP 전송 중 오류 발생:', error);\n    res.status(500).json({ success: false, message: 'OTP 전송 실패' });\n  }\n});\n\nrouter.post('/verifyotp', async (req, res) =\u003e {\n  const { phone, otp } = req.body;\n\n  try {\n    // 전화번호와 OTP로 사용자 찾기\n    const user = await User.findOne({ phone, otp });\n\n    if (!user || user.otpExpiration \u003c Date.now()) {\n      return res.status(400).json({ success: false, message: '유효하지 않은 OTP' });\n    }\n\n    // 성공적으로 확인된 후 OTP 및 만료 시간 비우기\n    user.otp = undefined;\n    user.otpExpiration = undefined;\n    await user.save();\n\n    res.status(200).json({ success: true, message: 'OTP 확인 성공' });\n  } catch (error) {\n    console.error('OTP 확인 중 오류 발생:', error);\n    res.status(500).json({ success: false, message: 'OTP 확인 실패' });\n  }\n});\n\nmodule.exports = router;\n```\n\n이 코드는 /sendotp 엔드포인트로 OTP를 생성하고 전송하고, /verifyotp 엔드포인트로 사용자가 입력한 OTP를 확인합니다.\n\n서버 시작하기: 마지막으로 애플리케이션을 시작하기 위한 주 서버 파일을 생성해봅시다. server.js라는 파일을 만들고 아래 코드를 추가해주세요:\n\n\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst { connect } = require('./db'); // db.js에서 connect 함수를 가져옴\nconst authRoutes = require('./routes/auth');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// 미들웨어\napp.use(bodyParser.json());\n\n// 라우트\napp.use('/auth', authRoutes);\n\n// 서버를 시작하기 전에 데이터베이스에 연결\nconnect()\n  .then(() =\u003e {\n    // 서버 시작\n    app.listen(PORT, () =\u003e {\n      console.log(`서버가 ${PORT} 포트에서 실행 중입니다.`);\n    });\n  })\n  .catch(error =\u003e {\n    console.error('데이터베이스 연결 중 오류 발생:', error);\n  });\n```\n\n이 코드는 Express 서버를 설정하고, 수신된 JSON 요청을 파싱하며, 인증을 위한 라우트를 정의합니다.\n\n결론: 축하합니다! Node.js와 MongoDB를 사용하여 OTP(일회용 비밀번호) 확인 시스템을 성공적으로 구축했습니다. SMS로 전송된 일회용 비밀번호를 통해 사용자의 신원을 확인함으로써 응용 프로그램에 추가적인 보안층을 추가했습니다. OTP 확인을 기반으로 한 이메일, 요청 속도 제한, 오류 처리 기능을 추가함으로써 이 시스템을 확장하실 수 있습니다.\n\n이 튜토리얼에서 다룬 내용:\n  \n\n\n\n- 사용자 데이터 저장을 위해 MongoDB 설정하기\n- Twilio를 사용하여 SMS를 통해 OTP 생성 및 전송\n- OTP 인증 엔드포인트 구현하기","ogImage":{"url":"/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png"},"coverImage":"/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법","description":"","date":"2024-05-14 13:30","slug":"2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel","content":"\n\n![웹 스피치 API가 작동하는 방식이 무엇이고, 어떻게 개선할 수 있는지에 대한 리스트와 GPT 언어 모델과 연결하는 방법](/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png)\n\n현대 기술들은 현재 소프트웨어가 제안하는 것보다 훨씬 간단하고 자연스러운 인간-컴퓨터 상호작용을 가능케 한다는 생각을 가지고 있어요. 사실, 저는 기술들이 충분히 성숙해져서 전통적인 인터페이스 없이도 사용자 경험에 혁명을 가져갈 수 있다고 생각해요.\n\n대형 언어 모델은 특히 정보 요청하는 방식에서 이러한 혁명의 한 단계를 촉발했습니다. 하지만, 제 생각에는 기술들이 더 많은 것을 제공할 수 있다고 봐요. 예를 들어, VR 헤드셋 비용이 점차 낮아지더라도 아직도 평평한 화면에 크게 의존하고 있고; 눈금, 음성 인식, 신체 부위 추적과 같은 기술들이 발전함에도 마우스, 키보드 및 터치 동작을 사용하고 있고; 음성 합성이 크게 발전했음에도 여전히 많은 것을 읽는 것에 그친 채 있어요.\n\n본 기사를 통해 저는 이미 잘 작동하는 현대 기술들로 인해 인간-컴퓨터 상호작용이 영원히 변할 수 있다는 것에 헌신하는 짧은 시리즈를 시작하려고 해요. 제가 공유할 코드 조각과 예시 앱을 통해 직접 테스트해보실 수 있을 거예요.\n\n\n\n저는 내 스타일을 유지하며, 이 모든 현대 기술의 웹 기반 구현에 대해 구체적으로 이야기하겠습니다. 그리고 여기서 웹 브라우저에 통합된 웹 음성 API로 시작하여 그 강점을 논의하고 일부 사용 사례를 보여주며 한계를 강조하고 일부 한계를 커버하는 방법에 대해 구체적으로 설명해 보겠습니다.\n\n# (현대) 음성 인식과 음성 합성\n\n특히 두 가지 기술, 음성 인식과 음성 합성은 거의 20년 동안 존재해 오며 더 자연스러운 인간과 컴퓨터 간 상호 작용을 도와줄 많은 것을 제공합니다.\n\n음성 인식 또는 ASR(Automatic Speech Recognition) 또는 STT(Speech-To-Text)는 구어를 쓰여진 텍스트로 변환합니다. 주요 넓은 적용 분야가 두 개 있습니다:\n\n\n\n- 명령어를 자연스럽게 발화하여 스마트폰이나 컴퓨터와 같은 하드웨어를 제어합니다. 스마트폰이나 Alexa 또는 Siri를 음성 명령을 통해 사용하는 방식을 생각해보세요.\n- 대화 내용을 필사하고(그리고 아마도 그 후에 표시하거나 저장하거나 분석함)하는 작업입니다. 회의 필사, 비디오 자막 등을 생각해보세요.\n\n두 응용 프로그램은 이 블로그 글의 주제와 직접적으로 관련이 있으며, 웹 프로그래머를 위해 Web Speech API를 통해 구현되었습니다.\n\n음성 합성 또는 TTS(텍스트를 음성으로 변환)는 쓰여진 텍스트를 말로 변환합니다. 이를 통해 컴퓨터 및 다른 장치가 인간과 유사한 말을 생성하여 정보를 청각적으로 액세스할 수 있게 되었습니다. 여기 Medium 기사에서 보는 것처럼 음성으로도 정보를 듣을 수 있게 해줍니다.\n\n음성 합성은 시각 장애인을 위한 접근성 기능, 대화형 음성 응답 시스템 및 멀티미디어 콘텐츠 보강을 포함한 다양한 시나리오에 적용됩니다.\n\n\n\nSTT와 TTS를 함께 사용하면 디지털 콘텐츠와의 상호작용이 더 포괄적이고 다양해지며, 무손실 및 화면 없이 작동하는 기회와 맞춤형 사용자 경험을 열어줍니다.\n\n## 음성 인식 및 합성 기술의 역사 개관\n\n음성 인식과 합성 기술은 특히 최신 AI 모델의 통합과 기계 학습 기술의 발전으로 지속적인 발전을 이루었습니다. 초기 시도가 컴퓨터를 언어 처리에 사용하려는 20세기 중반으로 거슬러 올라갑니다. 초기 모델은 발음, 방언, 동음이의어 및 언어적 미묘함에 대한 도전을 겪었으며, 음성 생성 및 이해 모두에서 직면했습니다. 통계 모델과 상징적 자연 언어 처리의 발전으로 ASR 시스템이 점차 향상되었지만, 2010년대 후반에 트랜스포머의 등장으로 ASR에서 특히 기반을 둔 획기적인 발전이 이루어졌습니다. \n\nSTT는 TTS보다 변수가 많아 다소 복잡하지만, 가장 현대적인 방법은 매우 잘 작동합니다. 이에 대해 자세히 다루지는 않겠습니다. 현대 STT는 여러 단계와 AI 모델이 협력하는 복잡한 프로세스를 포함합니다. 주요 단계는 오디오 입력의 전처리, 특징 추출, 음소 추출, 언어 모델 의사 결정 및 단어 시퀀스로의 디코딩이 포함됩니다. 현대 ASR 모델은 종종 모든 단계에서 트랜스포머를 사용하여 정보의 장거리 결합을 보존하여 정확도와 일관성을 향상시킵니다. 가장 선진적인 ASR 시스템에는 핵심 모듈에 직접 내장된 언어 모델 요소가 포함되어 있습니다. 이러한 내장 통합은 높은 전사 및 인식 정확도에 중요한 역할을 하였습니다.\n\n\n\n현대 ASR 및 TTS 기술은 실제로 단순한 음성인식 또는 합성 이상으로 한 걸음 더 나아가 \"말하는 언어의 이해\"에 근접할 수 있습니다. 가장 고급 스피치 투 텍스트(STT) 및 텍스트 투 스피치(TTS) 모델은 여러 언어로 오디오를 텍스트로 전사하거나 텍스트에서 오디오를 합성할 수 있으며, 일부는 언어를 자동으로 식별하고 맥락에 적응하며, 다양한 화자를 감지하거나 시뮬레이션할 수 있으며, 전사된 단어에 타임스탬프를 달거나 구두점 및 비언어적 발화를 처리하며, 사용자 정의 사전을 허용하는 등의 기능도 제공합니다.\n\n웹 Speech API를 통해 웹 앱에서 이러한 기능을 활용할 수 있는 가능성에 흥분한다면, 알아야 할 몇 가지 제약 사항이 있습니다. 브라우저가 지원하는 것이 최첨단 기술이 아니기 때문에 조금 실망할 수도 있습니다. 다행히도 Web Speech API를 대규모 언어 모델과 결합하면 이러한 문제 일부를 완화할 수 있으며, 많은 현대 ASR 및 TTS 기술이 수행하는 것처럼 GPT-3.5-turbo 또는 GPT-4를 프로그래밍적으로 사용하여 여기에서 보여드리겠습니다. 그것만으로 충분하지 않다면, 최첨단에서 ASR 및 TTS를 수행하기 위해 자사의 (유료) API를 제공하는 회사들도 있음을 알게 될 것입니다.\n\n# Web Speech API, 그 구성 요소 및 이용 가능성\n\nWeb Speech API는 웹 애플리케이션이 음성 데이터를 기능에 통합할 수 있도록 하는 웹 표준입니다. SpeechRecognition(음성 입력 및 인식을 허용하는 구성요소)와 SpeechSynthesis(음성 출력 및 합성을 허용하는 구성요소)로 구성되어 있습니다.\n\n\n\nWeb Speech API은 구글에서 2010년에 처음 제안되었고, 2013년 Chrome 25에서 구현되었습니다. 그 이후로 다른 브라우저에서도 지원되고 있지만 호환성과 기능에는 차이가 있습니다. 2023년 12월 기준으로 caniuse.com에서 보고한대로 매우 다양한 지원이 있습니다, 특히 음성 인식에 대해 말이죠:\n\n![음성인식](/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_1.png)\n\n제 경험상 API의 음성 인식 모듈은 사파리와 크롬에서만 잘 작동했습니다. 각각의 iOS 및 Android 버전도 지원하고 있죠. Brave나 Oculus Browser와 같은 크로미움 기반 브라우저(메타의 퀘스트 브라우저용 가상현실 웹 브라우저)는 음성 인식을 지원하지 않습니다. 이는 구글의 음성 인식 서비스가 독점적이며 라이선스가 필요하기 때문에 발생하는 문제입니다. 구글은 다른 브라우저에게 라이선스를 부여하지 않습니다. 소리내어 나타내자면, 크롬의 음성 인식은 클라우드 컴퓨팅을 기반으로하기 때문에 Brave와 같은 사용자 프라이버시에 중점을 둔 브라우저가 구글이 자원을 이용하여 음성 인식을 실행할 수 있게 하도록 허용한다면 어려운 결정을 내려야 할 것입니다. 그리고 프라이버시에 대해 언급하자면, Web Speech API를 통해 이루어지는 모든 음성 인식은 호출하는 웹페이지가 https를 통해 제공되어야 합니다!\n\n음성 합성은 음성 인식과는 달리 컴퓨터의 모든 주요 브라우저에서 잘 처리되며, 스마트폰을 포함한 대부분의 브라우저에서도 지원됩니다. TTS의 경우, 현재 https는 필수가 아닙니다.\n\n\n\n다음에는 구체적으로 Web Speech API에 초점을 맞추어 Chrome에서 해당 API를 사용하는 방법에 대해 알아볼 것입니다. 원칙적으로는 API를 지원하는 모든 다른 브라우저에서도 핵심 요소가 동일하게 작동해야 합니다.\n\n# Chrome의 Web Speech API 사용하기\n\n프로그래밍적으로 Web Speech API를 사용하려면 SpeechRecognition 또는 SpeechSynthesis 인터페이스의 인스턴스를 생성해야 합니다. 음성 입력 또는 출력을 사용하려는 경우에 따라 두 가지를 모두 생성하고 동일한 앱에서 사용할 수도 있습니다!\n\n## 음성 인식\n\n\n\n예를 들어, 음성 인식 객체를 생성하려면 이렇게 간단히 할 수 있어요:\n\n```js\nvar recognition = new SpeechRecognition();\n```\n\n하지만, 브라우저에서 실제로 ASR(음성 인식)이 활성화되어 있는지 확인해야 해요. 그러면 최소한의 코드 블록은 다음과 같아요:\n\n```js\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nwindow.onload = function () {\n  if (typeof SpeechRecognition === “undefined\") {  // 브라우저가 음성 인식을 할 수 있는지 확인\n    console.log(“Speech api failed\");\n  } else {\n    console.log(“Speech api ok\");\n    const recognition = new SpeechRecognition();  // 음성 인식 객체 생성\n    recognition.continuous = true;                // 동작 및 속성 정의, 예를 들어 지속적인 ASR을 요청하는 경우,\n    recognition.interimResults = true;            // ASR의 일부 결과 표시 (즉, 결과가 아직 최종이 아닌 경우에 발화가 계속되는 경우)\n    recognition.lang = \"en-US\";                   // 언어는 미리 정의되어야 해요\n    recognition.onresult = (event) =\u003e {           // 단어나 문장이 인식되었을 때 트리거\n      const res = event.results[last];            // 여러 인식된 단어/문장 목록이 있는 경우, 마지막 것을 가져와요\n      var text = res[0].transcript.trim();        // 텍스트 추출 및 정리\n      … // 텍스트 처리\n    }\n    recognition.start();            // 모든 설정이 준비된 상태로 인식 시작\n  }\n}\n```\n\n\n\n위에 표시된 대로 객체의 메서드와 속성을 사용하여 음성 인식 서비스를 제어하고 최상의 방법으로 활용할 수 있어요. 가장 많이 사용되는 명령어와 속성은 start, stop, abort, lang, interimResults 등이에요. 객체가 발생시키는 이벤트를 처리하기 위해 onstart, onend, onresult, onerror 등과 같은 이벤트 리스너를 추가할 수도 있어요.\n\n특히 주목할만한 프로퍼티 중 하나는, 약간의 부정적인 이유로 매우 주목할 가치가 있는 것은 \"grammars\"입니다. 음성 인식 \"grammars\"는 ASR을 수행하는 코드가 일반적으로 이해하지 못하거나 순위가 낮게 채점할 수 있는 단어를 이해할 수 있게 해줘야 한다고 합니다. 이 기능은 발음을 교정하고 이름, 전문용어, 지역 표현 등의 사용에 특히 중요하다고 해요. 기능에 대한 일부 정보는 여기서 찾아볼 수 있지만... 자세한 내용은 다루지 않겠습니다. 왜냐하면... 그냥 제대로 작동하지 않아서 많은 사람들이 이에 대해 불평하고 있거든요. 더구나, 현재 어떤 브라우저도 잘 지원하지 않기 때문에 API에서 gramamrs를 삭제할 계획이 있는데요 (여기를 참조하세요).\n\nSpeechRecognition 객체의 속성 및 이벤트에 대해 더 알고 싶다면, 여기를 확인해보세요.\n\n그리고 웹 Speech API를 음성 인식에 사용하는 전역적이고 완벽한 예제로, 웹 페이지의 배경색을 음성 명령어를 통해 변경하는 방법을 보여주는 이 공식 예제를 확인해보세요.\n\n\n\n## 음성 합성\n\n또한, 음성 합성 객체를 만들기 위해 다음과 같이 작성할 수 있습니다:\n\n```js\nvar synthesis = window.speechSynthesis;\n```\n\n그런 다음, SpeechSynthesisUtterance 인터페이스의 인스턴스를 생성할 수 있습니다. 이 인스턴스는 합성하고자 하는 구체적인 음성 요청을 나타냅니다. 텍스트, 음성, 속도, 음높이, 볼륨 등과 같은 utterance의 속성을 설정할 수 있습니다. 객체의 메서드와 속성을 사용하여 음성 합성 서비스를 제어할 수 있습니다. speak, pause, resume, cancel, getVoices 등과 같은 작업을 수행할 수도 있습니다. 또한, utterance가 발생시키는 이벤트를 처리하기 위해 이벤트 리스너를 추가할 수도 있습니다. onstart, onend, onerror 등과 같이 발생하는 이벤트를 처리하기 위한 예시로, 텍스트를 합성하고 시작과 종료시에 로그를 남기는 방법은 다음과 같습니다:\n\n\n\n웹 앱에서 정말 좋아하는 것 중 하나는 문자열을 받아서 음성으로 출력하는 함수를 가지고 있는 것입니다. 이 함수를 speakUp()이라고 부르고 다음과 같이 보입니다:\n\n```js\nfunction speakup(TextToSpeak) {\n  if (“speechSynthesis\" in window) {                            //TTS가 지원되는지 확인\n    const toSpeak = new SpeechSynthesisUtterance(TextToSpeak);  //음성 생성\n    toSpeak.lang = “en-US\";                                     //언어 설정\n    window.speechSynthesis.speak(toSpeak);                      //음성 출력!\n  } else {\n    console.log(“브라우저에서 음성 합성을 지원하지 않습니다.\");\n  }\n}\n```\n\n# 웹 Speech API를 통한 음성 인식 및 합성의 문제와 대형 언어 모델을 사용하여 그 일부를 수정하는 방법\n\n\n\n웹 Speech API는 매우 쉽게 사용할 수 있어요. 무료이며 API 키도 필요하지 않고 얼마나 자주 호출해도 제한이 없어요.\n\n하지만 계속 시도해보니 시스템이 자주 다운되는 경향이 보이는데, 특히 ASR(자동 음성 인식)에 대해서요. 게다가 API는 때때로 자체적으로 꺼지는 것처럼 보이며, 많은 사람들이 명확한 해결책 없이 질문을 합니다. 더 나쁜 점은 무료 API가 어떤 응용 프로그램에는 괜찮을 수 있지만, 음성 인식 및 합성 측면에서는 최신 기술 수준과는 거리가 멀어요. 일반적으로 설명한 현대 ASR(자동 음성 인식) 시스템에 비해, Chrome의 ASR 서비스는 매우 제한적이에요!\n\n음성 인식은 매우 정확하거나 신뢰성이 높지 않으며, 사투리나 방언에도 민감하지 않아요. 심지어 약간의 소음이 있어도 거의 쓸모가 없어요. 언어를 자동으로 감지하지 않고, 같은 대화에서 여러 사람이 말할 때도 인식하지 못하며, 구두점은 괜찮지만 발성과 혼동되기도 해요.\n\n음성 인식 서비스는 개인 정보 보호 및 보안 문제가 있어요. 음성 데이터가 사용자 동의나 지식 없이 외부 서버나 제3자에 전송됩니다.\n\n\n\n음성 합성 서비스는 특히 영어 이외의 언어에 대해서는 매우 자연스럽거나 표현력이 부족합니다.\n\n또한 위에서 본 것처럼 음성 인식 및 합성 서비스는 브라우저와 장치에 매우 의존적이며, 다른 플랫폼 및 지역에서 사용 가능하지 않거나 일관성이 없을 수 있습니다.\n\n그리고 그 한계로 인해 편견, 차별, 속임수, 조작 또는 가장 등 윤리적 및 사회적 영향이 발생할 수 있습니다.\n\n개발자로서 그리고 사용자로서, 이러한 제한사항과 도전에 대해 인식하고 Web Speech API를 책임 있게 사용해야 합니다.\n\n\n\n## 대형 언어 모델을 사용하여 음성 인식 문제 완화하기\n\n위 문제 중에서도 음성 인식(ASR)과 관련된 문제가 가장 중요합니다. 이러한 문제 중 많은 것들을 해결하기 위해서는 인식이 진행되는 가장 기본적인 수준에서 조치가 필요합니다. 그러나 전사 정확성과 전문 용어 완성과 관련된 가장 중요한 문제들은 대형 언어 모델을 사용해서 해결할 수 있습니다. 제가 GPT-3.5-turbo 또는 GPT-4를 통해 직접 JavaScript 내부의 웹 앱에서 프로그래밍을 통해 해결하고 있습니다.\n\n작동 방식\n기본적으로 언어 모델을 호출하여 입력이 어떻게 보일지와 해당 입력에 대한 출력이 어떻게 되어야 하는지 설명하는 프롬프트를 제공한 다음, API에서 인식한 음성으로부터 나오는 실제 (원시) 전사를 따릅니다.\n\n이 모든 작업을 일으킨 웹 앱에서는 음성 인식을 사용하여 명령을 트리거합니다. 예를 들어 사용자가 \"확대\", \"줌 인\" 또는 비슷한 명령을 하면 시각화(분자 그래픽을 위한 앱)가 확대되어야 합니다. 이 앱의 프롬프트는 다음과 같습니다:\n\n\n\n```js\nlet theprompt = [];         //프롬프트가 저장될 배열을 초기화합니다\n\ntheprompt.push({\n  role: \"system\",           //모드에게 수행할 작업을 알립니다\n  content: \"음성인식으로 텍스트를 받고 주어진 예제처럼 명령을 트리거하여 적절히 대응합니다. 요청을 이해하지 못하거나 목록에 없는 경우 didntUnderstand() 명령을 실행합니다.\",\n  });\n\ntheprompt.push(                                      //여기서부터 예제 제공\n { role: “user\", content: “분자 크게 만들기\" },\n { role: “assistant\", content: “scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"확대\" },\n { role: \"assistant\", content: \"scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"크게 만들기\" },\n { role: \"assistant\", content: \"scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"축소\" },\n { role: \"assistant\", content: \"scale(-)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"작게 만들기\" },\n { role: \"assistant\", content: \"scale(-)\" }\n);\n```\n\n이를 자세히 살펴보겠습니다. 여기에 프롬프트의 시스템 요소가 있습니다:\n\n그런 다음 사용자/어시스턴트 쌍이 동일한 또는 관련된 출력을 생성하는 가능한 입력의 예제를 제공하는 방법을 살펴보십시오. 예를 들어 \"확대\"라고 말하면 \"크게 만들기\" 모두 scale(+) 호출을 결과로 지니며, \"축소\"는 scale(-) 호출을 합니다.\n\n코드의 다른 부분에서는 프로그램이 크래시하지 않는 방식으로 입력을 수정하도록 언어 모델을 가르치는 항목을 찾을 수 있습니다. 동시에 올바른 출력을 생성할 가능성을 높입니다. 예를 들어, 제가 말하는 \"최소화\"는 종종 \"미니 마우스\"로 인식되고 \"ANI\"는 표준 영어 단어가 아닌 \"애니\"로 인식됩니다. 그런 다음 이러한 예제로 언어 모델을 지시할 수 있습니다:\n```\n\n\n\n```js\ntheprompt.push(\n { role: \"사용자\", content: \"ANI로 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\ntheprompt.push(\n { role: \"사용자\", content: \"애니로 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\ntheprompt.push(\n { role: \"사용자\", content: \"애니로 미니 쥐들을 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\n...등등.\n```\n\n이 요령이 굉장히 잘 작동하는 것을 알 수 있습니다. 이는 최신 언어 모델인 Whisper와 같은 모던한 언어 모델의 핵심입니다. 이 모델은 언어 모델을 직접 음성 인식 절차에 포함시켜서 가능한 것입니다!\n\n이 섹션을 마치면서, 물론 전체 프롬프트는 저의 경우에는 주로 GPT-3.5-turbo나 OpenAI의 GPT-4로부터의 응답을 포함하는 프로미스 내부에 있어야 합니다.\n\n```js\nfetch(`https://api.openai.com/v1/chat/completions`, {    // 음성 API를 호출하는 주요 부분\n  body: JSON.stringify({\n  model: \"gpt-3.5-turbo\",                     // 또는 2023년 12월 기준 GPT-4\n  messages: theprompt,                    // 방금 생성된 프롬프트\n  temperature: 0,                         // 환각을 피하기 위해 이를 낮추세요\n  max_tokens: 20,                         // 출력물은 작은 명령어여야 하므로 이 값도 낮추세요\n}),\n  method: \"POST\",\n  headers: {\n    \"content-type\": \"application/json\",\n    Authorization: \"Bearer \" + 빈칸에 당신의 API 키와 문자열을 넣으세요,    // OpenAI의 GPT 모델용 API 키!\n  },\n}).then((response) =\u003e {\n  if (response.ok) {\n    response.json().then((json) =\u003e {\n    var command = json.choices[0].message.content.trim();    // 명령어가 담긴 텍스트를 추출합니다\n    console.log(command);\n    if (command == ....                 // 작업 목록을 나열하고 실행합니다                  \n```\n\n\n\n# Chrome Web Speech API를 사용하는 몇 가지 사례\n\n이 블로그 글을 트리거한 앱 이외에도 음성 인식 및/또는 합성 API를 사용하는 이 다른 프로젝트들을 공유할 수 있어요:\n\n이 예시에서, 나는 Chrome의 음성 인식 기능을 GPT-3과 함께 사용하여 음성으로 입력된 노트와 가이드라인에서 이메일을 작성하는 웹 앱을 만들었어요.\n\n여기에서, 나는 당신에게 Chrome의 음성 인식 및 합성 API를 사용하여 GPT-3으로 구동된 언어 모델이 채팅봇의 '뇌'로 작용하는 채팅GPT와 유사한 봇을 만드는 방법을 보여줄 거예요.\n\n\n\n이 다른 예제에서는 Chrome의 음성 인식 기능을 사용하여 웹 앱을 제어합니다. 이 경우, GPT-3를 사용하여 발언된 요청을 명령으로 변환합니다.\n\n# 웹 음성 API를 넘어서\n\n위에서 설명했듯이 일부 웹 브라우저는 음성 합성을 지원하지 않을 뿐 아니라 음성 인식도 지원하지 않습니다. 또한 Chrome의 내장 음성 API가 좋지 않다고 설명했고, 특히 음성 인식에 있어서는 그 제한사항이 극복되는 경우도 있지만, 이 전략으로 해결할 수 없는 문제도 있으며, 따라서 현대 음성 인식 시스템이 가지고 있는 많은 기능이 완전히 부족한 경우가 많습니다.\n\n이러한 맥락에서, 브라우저가 대안 서비스나 솔루션을 사용하여 음성 인식 및 합성을 지원할 수 있다는 것을 알아두는 것이 중요합니다 - Chrome의 무료 API와 대조적으로 유료이지만 일반적으로 더 강력한 원칙입니다.\n\n\n\n일부 이 API 서비스를 제공하는 회사들을 언급해보자면 Gladia, Speechly, AssemblyAI, Deepgram, Spechmatics(이 회사는 여기에서 멋진 예제를 자랑해요) 등이 있습니다. Google도 Chrome에서 무료로 제공하는 것과 별도로 ASR 시스템을 보유하고 있으며, 이는 분명히 더 잘 작동합니다. 또한 Microsoft와 AWS와 같은 기술 거인들도 API를 통해 제공하는 제품을 갖고 있습니다. OpenAI의 오픈 소스 Whisper를 다운로드해서 특정 서비스로 실행할 수도 있습니다. 이 경우에는 본인의 요구에 따라 커스터마이징하여 사용할 수도 있는데, 그런 경우에는 Gladia.io와 같이 API를 제공하는 회사와 함께 하는 편이 더욱 편리할 수 있습니다.\n\n물론, Whisper를 로컬 서버에서 사용하듯이, 닫힌 환경에서 구현하지 않는 한, 이러한 서비스 대부분은 오디오를 서버로 전송해야 하므로 개인 정보를 잠재적으로 노출할 수 있습니다. 그러나 민감하지 않은 작업에 대해서는 매우 저렴한 비용으로도 완벽한 해결책이 될 수 있습니다.\n\n# 더 많은 읽을거리\n\nwww.lucianoabriata.com 나는 내 관심 분야인 자연, 과학, 기술, 프로그래밍 등에 관한 모든 것에 대해 쓰고 있습니다. 새로운 이야기를 이메일로 받으시려면 구독하세요. 소규모 작업에 대해 상담하려면 여기에서 내 서비스 페이지를 확인하세요. 저에게 연락하려면 여기에서 연락하세요. 팁을 보내고 싶으시다면 여기에서 가능합니다.","ogImage":{"url":"/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png"},"coverImage":"/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png","tag":["Tech"],"readingTime":13},{"title":"익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션","description":"","date":"2024-05-14 13:28","slug":"2024-05-14-ExpressgatewayYournextAPIGatewaySolution","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png\" /\u003e\n\n안녕하세요 개발자 여러분! 이 블로그 포스트에 오신 것을 환영합니다. 이 포스트에서는 Express 게이트웨이에 대해 자세히 살펴보겠습니다. 왜 사용해야 하며 언제 사용해야 하는지, 그리고 어떤 문제를 해결할 수 있는지 알아봅시다. 시작해봅시다! 🚀\n\nAPI 게이트웨이는 현대 소프트웨어 아키텍처에서 중요한 구성 요소로, 백엔드 서비스와 API에 대한 모든 클라이언트 요청의 단일 진입점 역할을 합니다. 인증, 권한 부여, 속도 제한 및 라우팅과 같은 작업을 처리하며 클라이언트와 다양한 마이크로서비스 간의 통신을 간소화합니다. 이러한 기능을 중앙 집중화함으로써 API 게이트웨이는 분산 시스템의 보안, 확장성 및 관리 용이성을 향상시킵니다. 인기 있는 API 게이트웨이 솔루션에는 Kong, AWS API 게이트웨이 및 Traefik 등이 있으며, 이러한 서비스를 관리하는 UI와 함께 훌륭한 API 관리 시스템을 제공하지만 Express 게이트웨이는 이 문제에 대한 오픈 소스 솔루션이며 우리가 곧 살펴볼 모든 편리한 구성을 제공합니다.\n\nAPI 게이트웨이는 특히 분산 아키텍처에서 여러 마이크로서비스나 API를 관리할 때 사용해야 합니다. 통합된 진입점을 제공함으로써 클라이언트 액세스를 간소화하고 인증, 권한 부여 및 트래픽 관리와 같은 필수 기능을 제공합니다. 게다가 API 게이트웨이는 복잡한 서비스 지향 환경에서 보안 정책을 강화하고 잠재적인 위험을 완화하는 데 유용합니다.\n\n\n\n\n![Express Gateway 이미지 1](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_1.png)\n\n![Express Gateway 이미지 2](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_2.png)\n\nExpress Gateway는 미리 정의된 라우팅 규칙에 따라 들어오는 HTTP 요청을 가로채어 적절한 마이크로 서비스 또는 API로 보내는 방식으로 작동합니다. 인증, 권한 부여, 속도 제한 및 로깅과 같은 작업을 처리하여 클라이언트와 서비스 간의 안전하고 효율적인 통신을 보장합니다. Express Gateway의 정책 시스템은 사용자 정의 및 확장성을 허용하여 개발자가 특정 요구 사항에 맞게 조정할 수 있도록 합니다. Express Gateway에서 사용 가능한 정책 목록을 확인하고 그에 맞게 구성하는 방법을 알아봅시다.\n\n이제 Express Gateway의 설치부터 시작하여 우리의 요구 사항에 맞게 구성하는 방법을 살펴봅시다.\n\n\n\n\n```js\n$ bun add -g express-gateway\n```\n\n- 익스프레스 게이트웨이를 추가합니다.\n\n```js\n$ eg gateway create\n```\n\n몇 가지 질문에 답하면 기본 구성으로 준비된 게이트웨이 프로젝트가 생성됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_3.png\" /\u003e\n\n- server.js: 게이트웨이의 진입점이며 구성이 로드되고 응용 프로그램이 API 엔드포인트를위한 포트 8080 및 관리 API 엔드 포인트를위한 포트 9876에서 수신 대기를 시작하는 위치입니다.\n- system.config.yml: 게이트웨이의 시스템 수준 구성 및 글로벌 매개 변수가 정의되어 있으며 system.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이를 실행하는 데 사용되는 인프라 구성 설정을 설명합니다.\n- gateway.config.yml: 게이트웨이의 모든 기능이 정의되어 있으며 gateway.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이의 마이크로 서비스 및 API 연산 전체를 한눈에 보여줍니다.\n- models: models 디렉토리에는 Express Gateway 엔티티의 JSON 스키마를 설명하는 모델 구성 파일이 포함되어 있습니다. 이는 사용자 정의 및 확장 가능한 항목입니다.\n\nExpress Gateway 구성을 시도해보기 위해 각각 다른 포트 3000, 3001 및 3002에서 실행 중인 local-server에 세 개의 Express 서버를 만들었습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_4.png\" /\u003e\n\n\n\n이제 gateway.config.yml을 구성하여 익스프레스 게이트웨이의 라우트에 마이크로 서비스를 포함시켜서 요청을 지정된 마이크로 서비스로 리디렉션할 수 있도록 설정하십시오.\n\n```js\nhttp:\n  port: 8080\nadmin:\n  port: 9876\n  host: localhost\napiEndpoints:\n  ms1:\n    host: localhost\n    paths: /api/ms1/*\n  ms2:\n    host: localhost\n    paths: /api/ms2/*\nserviceEndpoints:\n  ms1:\n    url: 'http://localhost:3000'\n  ms2:\n    url: 'http://localhost:3001'\npolicies:\n  - basic-auth\n  - cors\n  - expression\n  - key-auth\n  - log\n  - oauth2\n  - proxy\n  - rate-limit\npipelines:\n  ms1:\n    apiEndpoints:\n      - ms1\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms1\n              changeOrigin: true\n  ms2:\n    apiEndpoints:\n      - ms2\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms2\n              changeOrigin: true\n```\n\n- http: 익스프레스 게이트웨이가 수신하는 HTTP 요청의 포트를 지정합니다 (포트 8080).\n- admin: 관리 인터페이스에 액세스하기 위한 포트 (9876) 및 호스트 (localhost)를 정의합니다.\n- apiEndpoints: 지정된 경로를 기반으로 서로 다른 마이크로 서비스 (ms1 및 ms2)를 위한 엔드포인트를 구성합니다.\n- serviceEndpoints: 서비스 엔드포인트 (ms1 및 ms2)를 해당 URL과 연결합니다.\n- policies: API 라우트에 적용할 수 있는 사용 가능한 정책을 나열합니다. 기본 인증, CORS, 속도 제한 등이 포함됩니다.\n- pipelines: 각 마이크로 서비스에 대해 처리 파이프라인을 정의하고 적용할 API 엔드포인트 및 정책을 지정합니다. 예를 들어, ms1에 대한 파이프라인은 요청을 ms1 서비스 엔드포인트로 프록시하고 출처 변경을 가능하게 합니다. 마찬가지로, ms2에 대한 파이프라인은 출처 변경이 가능한 상태로 요청을 ms2 서비스 엔드포인트로 프록시합니다.\n\n게이트웨이 구성에 대해 더 알아보려면 이 링크를 따르세요 [링크](내부 링크 주소를 입력하세요).\n\n\n\n이제 구성 변경으로 인해 localhost:8080/api/ms1/에 요청을 보낼 수 있으며 해당 요청을 serviceEndpoint에 리디렉션할 것입니다.\n\n또한 다음은 이 구성을 편집할 수 있는 관리자 API 엔드포인트를 사용할 수 있습니다. 아래는 예시입니다.\n\n- API 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_5.png)\n\n\n\n- 서비스 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_6.png)\n\n- 서비스 엔드포인트용 파이프라인 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_7.png)\n\n\n\n이 요청에서 다른 가능한 정책도 구성하세요.\n\napiEndpoints, serviceEndpoint 및 piplines을 나열할 수도 있습니다. 이러한 엔드포인트에 대해 GET 요청을 만들어 읽을 수 있습니다. 익스프레스 게이트웨이는 관리자 API를 자체 도메인이나 서브도메인으로 유지하고 이를 퍼블릭으로 사용할 수 없도록 권장하며, 이러한 엔드포인트에 인증을 추가할 수도 있습니다.\n\n관리자 API 엔드포인트에 대한 자세한 정보는 다음 문서를 읽는 것을 권장합니다.\n\nAPI 관리 여정에 착수하면서 익스프레스 게이트웨이의 공식 문서를 탐험하는 것을 잊지 마세요. 이 강력한 도구에 대한 이해와 능력을 향상시키는 데 소중한 자원으로 작용합니다. 즐거운 코딩👨‍💻️!","ogImage":{"url":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png"},"coverImage":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png","tag":["Tech"],"readingTime":5},{"title":"디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까","description":"","date":"2024-05-14 13:27","slug":"2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem","content":"\n\n![이미지](/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png)\n\n웹 개발자이시라면, 짧은 시간 간격으로 반복적으로 실행되는 코드의 성능을 최적화해야 하는 상황에 직면할 수 있습니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이나 페이지 레이아웃을 조정하는 크기 조정 이벤트 핸들러 등이 있을 수 있습니다. 이러한 경우에 코드가 너무 자주 실행되지 않도록 하고, 불필요한 네트워크 요청, 느린 사용자 인터페이스 또는 고 CPU 사용량을 유발하지 않도록 하려면 좋지 않습니다.\n\n이 문제를 해결하기 위해 디바운싱(debouncing)과 쓰로틀링(throttling)이라는 두 가지 기술을 사용할 수 있습니다. 이러한 기술을 사용하면 코드가 실행되는 속도를 제어하고 호출되는 횟수를 줄일 수 있습니다. 이 기사에서는 디바운싱과 쓰로틀링이 무엇인지, 어떻게 다른지, 그리고 JavaScript에서 이를 구현하는 방법에 대해 설명하겠습니다.\n\n## 디바운싱이란 무엇인가요?\n\n\n\n디바운싱은 사용자가 특정 작업을 수행하지 않을 때까지 함수의 실행을 지연시키는 기술입니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이 있다면, API 호출을 수행하는 함수를 디바운싱할 수 있습니다. 이렇게 하면 사용자가 몇 초 동안 타이핑을 멈춘 후에만 해당 함수가 실행되도록 할 수 있습니다. 이렇게 함으로써 서버를 과부하로 만들거나 관련이 없는 결과를 반환하는 API 호출을 피할 수 있습니다.\n\n자바스크립트에서 디바운싱을 구현하려면 지연 기간을 추적하는 타이머 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 지연 기간 후에 함수를 실행할 타이머를 설정할 수 있습니다. 사용자가 동작을 다시 수행하기 전에 지연 기간이 끝나면 clearTimeout 함수를 사용하여 타이머를 취소할 수도 있습니다. 이렇게 함으로써 사용자가 동작을 멈춘 후에 함수가 한 번만 실행되도록 할 수 있습니다.\n\n다음은 자바스크립트에서 디바운싱을 구현하는 예시입니다:\n\n```js\n// 검색 쿼리로 API 호출을 수행하는 함수\nfunction searchHandler(query) {\n    // 검색 쿼리로 API 호출 수행\n    getSearchResults(query);\n}\n\n// 함수와 지연 시간을 매개변수로 받는 debounce 함수\nfunction debounce(func, delay) {\n    // 지연 기간을 추적하는 타이머 변수\n    let timer;\n    // 인수를 받는 함수를 반환\n    return function(...args) {\n        // 이전 타이머를 지우기\n        clearTimeout(timer);\n        // 지연 기간 후 함수를 실행할 새로운 타이머 설정\n        timer = setTimeout(() =\u003e {\n            // 인수와 함께 함수 적용\n            func.apply(this, args);\n        }, delay);\n    };\n}\n\n// 500ms 지연을 가진 검색 핸들러의 디바운스 버전\nconst debouncedSearchHandler = debounce(searchHandler, 500);\n\n// 검색 바 입력에 이벤트 리스너 추가\nsearchBar.addEventListener(\"input\", (event) =\u003e {\n    // 입력란의 값 가져오기\n    const query = event.target.value;\n    // 쿼리로 디바운스된 검색 핸들러 호출\n    debouncedSearchHandler(query);\n});\n```\n\n\n\n이 예제에서는 검색 쿼리로 API 호출을 하는 searchHandler 함수가 있습니다. 또한 함수와 지연을 매개변수로 사용하여 해당 함수의 디바운스 버전을 반환하는 debounce 함수도 있습니다. 우리는 이 debounce 함수를 사용하여 500ms 지연을 가진 debouncedSearchHandler 함수를 만듭니다. 그런 다음 검색 창 입력란에 이벤트 리스너를 추가하고 입력 값으로 debouncedSearchHandler 함수를 호출합니다. 이렇게 함으로써 사용자가 500ms 동안 타이핑을 멈추면 단 하나의 API 호출만 한다는 것을 보장할 수 있습니다.\n\n## 쓰로틀링이란?\n\n쓰로틀링은 함수의 실행을 지정된 시간 간격마다 한 번씩 제한하는 기술입니다. 예를 들어 페이지 레이아웃을 조정하는 리사이즈 이벤트 핸들러가 있는 경우, 레이아웃을 업데이트하는 함수를 쓰로틀링하여 100ms마다 한 번씩만 실행되도록 할 수 있습니다. 이렇게 함으로써 코드를 너무 자주 실행하는 것을 피하고, 사용자 인터페이스가 끊기거나 높은 CPU 사용률을 유발하는 것을 방지할 수 있습니다.\n\nJavaScript에서 쓰로틀링을 구현하려면 함수가 이미 실행 중인지 여부를 추적하는 플래그 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 시간 간격 이후에 플래그를 재설정할 타이머를 설정할 수 있습니다. 또한 함수를 실행하기 전에 플래그가 true인지 확인하는 if문을 사용할 수도 있습니다. 이렇게 함으로써 함수가 지정된 시간 간격마다 한 번만 실행되도록 보장할 수 있습니다.\n\n\n\n자바스크립트에서 쓸데없는 반복을 줄이는 방법 중 하나인 쓸데없는 실행을 빈번하게 하는 데바운싱(Debouncing)과 쓸데없는 실행을 일정 간격으로 제한하는 스로틀링(Throttling)을 구현하는 방법을 보여드렸어요.\n\n아래 코드는 페이지 레이아웃을 업데이트하는 updateLayout 함수와 함수 및 간격을 매개변수로 받아 해당 함수의 스로틀링된 버전을 반환하는 throttle 함수를 보여줍니다. 이 throttle 함수를 사용하여 100ms 간격의 throttledUpdateLayout 함수를 생성합니다. 그런 다음 창 크기 조정 이벤트에 대한 이벤트 리스너를 추가하고 throttledUpdateLayout 함수를 호출합니다. 이렇게 하면 100ms마다 레이아웃을 업데이트하는 것을 보장할 수 있어요.\n\n## 데바운싱(Debouncing)과 스로틀링(Throttling)의 차이점은 무엇인가요?\n\n\n\nDebouncing(디바운싱)과 Throttling(슈로틀링)의 주요 차이점은 디바운싱은 일정 시간 동안 기다린 후 함수를 실행하는 반면, 스로틀링은 일정 간격으로 함수를 실행한다는 것입니다. 두 기법 모두 코드의 성능을 향상시키는 데 유용하지만 각각 다른 사용 사례와 효과가 있습니다.\n\n디바운싱은 특정 작업을 수행하는 사용자가 멈출 때까지 코드의 실행을 지연시키고 싶을 때 유용합니다. 예를 들어 사용자가 백엔드에서 제안을 불러오기 전에 사용자가 입력을 멈출 때까지 기다리고 싶은 경우 자동 완성에 디바운싱을 사용할 수 있습니다. 디바운싱을 사용하면 코드 실행 횟수를 줄일 수 있지만 사용자 인터페이스에 지연이 발생할 수도 있습니다.\n\n스로틀링은 코드 실행을 일정 주기로 제한하고 싶을 때 유용합니다. 예를 들어 페이지 레이아웃을 일정한 속도로 업데이트하고 싶을 때 리사이즈에 대해 스로틀링을 사용할 수 있습니다. 스로틀링을 사용하면 사용자 인터페이스의 응답성을 향상시킬 수 있지만 코드의 일부 정보 누락이나 정확도 손실을 가져올 수도 있습니다.\n\n## 결론\n\n\n\n디바운싱과 쓰로틀링은 짧은 시간 동안 반복적으로 실행되는 코드의 성능을 최적화하는 데 도움이 되는 두 가지 기술입니다. 디바운싱은 사용자가 특정 작업을 일정 시간 동안 수행하지 않을 때까지 코드 실행을 지연시킵니다. 쓰로틀링은 코드 실행을 지정된 시간 간격마다 한 번으로 제한합니다. 두 기술은 서로 다른 사용 사례와 효과를 가지고 있으며, 여러분의 요구에 가장 잘 맞는 방법을 선택해야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png"},"coverImage":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png","tag":["Tech"],"readingTime":4},{"title":"카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기","description":"","date":"2024-05-14 13:24","slug":"2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png\" /\u003e\n\n만약 누군가가 나에게 비가 오는 오후를 보내며 'q-테이블'을 통한 강화 학습 데모를 만들어 오래된 친구들의 집에서 얼 그레이 차를 찾는 캡틴 피카드를 쫓는다고 말해 준다면, 나는 그들을 미친 사람이라고 부를 것이다.\n\n그런데, 여기에 우리가 있네요.\n\n(여기 내가 연례 휴가를 즐기며 지루해질 때 일어나는 일이지...)\n\n\n\n여러분이 8월 '23을 되돌아보자면, 저는 강화학습 기초에 관한 가이드를 작성하는 데 시간을 할애했었죠.\n\n이 가이드에서는 '다중암 기계' 문제를 살펴보고, 무작위 선택을 통해 보상을 최대화하는 다양한 방법을 탐색해보았습니다. 욕심 부리는 선택, 그리고 욕심부리는 엡실론 사용까지 비교해보았죠. 적어도 나에게는 정말 즐거운 경험이었어요! 하지만 그것은 강화학습 세계의 극표면을 다루는 것에 불과합니다. 'RL'이라 불리는 광범위한 세계에 대해 읽어보기 시작하면, 컴퓨터에게 보상을 극대화하는 법을 가르치기 위한 다양한 알고리즘, 방법론, 프레임워크로 가득한 깊고 복잡한 세계임을 알게 됩니다.\n\n본 후속 글에서는 강화학습 세계를 더 심도 있게 파헤치고, 문제를 해결하기 위해 강화학습을 사용하는 더 복잡하지만 흥미로운 방법 중 하나를 탐구할 것입니다. 최종적으로는 우리만의 강화학습 실험을 직접 구축하는 과정까지 이어질 것입니다! 만약 이 기사의 나머지 부분을 따라주신다면, 여러분은 여러분만의 브라우저에서 체험할 수 있는 강화학습의 작은 기술 데모를 즐길 수 있을 겁니다.\n\n# Q 누구?\n\n\n\n![image](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_1.png)\n\n특정 강화 학습 메커니즘인 'Q-러닝'에 대해 배우게 될 거에요. 그게 무엇인지 이해하려면 1989년으로 모습을 돌려봐야해요. 그 해, Christoper Watkins 교수라는 창의적인 학자가 나타났어요.\n\nWatkins는 AI/ML 엔터프라이즈에 중요한 공헌을 한 인물로, 기계 학습에 관한 다수의 논문(텍스트 해석 방식에서 큰 언어 모델과 사람 간의 유사성을 제시한 2022년 연구 포함)의 저자 또는 공동 저자로 활동했어요. 그 중 1989년에 'Q-러닝' 개념을 소개한 논문에 우리는 오늘 초점을 맞출 거에요.\n\n논문에는 \"Q-러닝(Watkins, 1989)은 에이전트가 제어된 Markov 도메인에서 최적으로 행동하는 법을 배우는 간단한 방법이다\"라고 나와 있어요. (Markov 도메인에 대한 자세한 내용은 나중에 설명할게요)\n\n\n\n첫째로, Q-학습은 다른 강화 학습 방법 및 알고리즘과 마찬가지로 에이전트가 환경을 이해하여 주어진 시나리오에서 보상을 극대화하기 위한 방법입니다. 강화 학습에 대한 첫 번째 글을 생각해보면 'RL 루프'를 다음과 같이 상상했습니다:\n\n![RL 루프 이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_2.png)\n\nQ-학습에도 동일한 다이어그램이 적용됩니다. 추상적으로 말하면 에이전트가 환경에서 행동을 취하여 보상을 얻고, 실제 세계의 사용 사례에서는 온라인 마케팅에 사용하여 고객에게 구매 습관에 가장 적합한 광고를 제공하는 최적화 작업에 사용할 수 있습니다 (고객이 광고를 클릭할 때 보상이 제공됩니다).\n\nQ 학습에서 에이전트는 특정 상태에서 작업을 시도하고, 즉시 받은 보상이나 패널티 및 해당 상태의 가치에 대한 추정을 평가합니다. 모든 상태에서 모든 작업을 반복적으로 시도함으로써 장기적으로 할인된 보상에 의해 평가된 전체적으로 가장 좋은 작업을 학습합니다.\n\n\n\n환경 내에서 행동의 가치에 대한 정보를 저장하기 위해 Q-러닝은 'Q-테이블'을 사용합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_3.png)\n\nQ 테이블을 그냥 그런 테이블로 생각해보세요. 이 테이블은 환경에서 가능한 상태와 행동을 나타내는 열과 행의 조회 테이블입니다.\n\nQ 테이블의 각 '셀'은 초기에 0으로 설정됩니다(이를 '미발견됨'으로 생각할 수 있습니다) 하지만 에이전트가 발견하면 상태와 행동의 각 조합에 대해 얻은 보상으로 Q-테이블을 업데이트합니다. 시간이 지남에 따라, 아이디어는 에이전트가 Q 테이블에서 지속적으로 업데이트되는 정보를 활용하여 보상을 극대화하기 위한 최상의 조치에 수렴할 것입니다.\n\n\n\n우리 이전의 기사에서 3개의 팔잡이 문제에 대한 관점을 고려해보면, 초기 q-테이블은 다음과 같이 보일 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |   0   |   0   |   0   |\n```\n\n슬롯 머신에는 실제로 손잡이를 당기는 하나의 상태만 있고, 3개의 기계를 가진 3개의 팔잡이 문제에서, 위와 같은 결과를 얻게 됩니다. 몇 번의 슬롯을 당겨본 후에는 몇 가지 보상 값이 나올 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |  0.5  |   1   |   4   |\n```\n\n\n\n에이전트가 상태에 있을 때, 그 상태에 대한 Q-테이블의 행을 확인하고 대부분의 경우, 그 행에서 가장 높은 Q-값을 갖는 행동을 선택합니다 (지금까지 알고 있는 가장 좋은 행동). '탐험률' (에이전트가 새로운 행동을 탐험할지 알려진 좋은 행동을 활용할지를 선택하는 빈도)과 '탐험 감소' (에이전트가 최대 보상 경로로 수렴하고 고수하는 속도)와 같은 요소들은 에이전트가 Q-테이블에서 찾은 값에 얼마나 의존할지에 영향을 미칩니다.\n\nQ-테이블과 상호 작용하는 공식인 '벨만' 방정식은 다음과 같습니다:\n\n새로운 Q-값 = 이전 Q-값 + 학습률 × (보상 + 할인율 × 최상의 미래 Q-값 - 이전 Q-값)\n\n벨만 방정식의 아이디어는 상태-행동 쌍의 가치가 즉시 보상뿐만 아니라 최선의 예상 미래 보상에도 기반하여 업데이트되며, 학습률에 의해 조정된다는 것입니다. 하지만 지난 보상들은 어떨까요? 이전에 있었던 일들의 역사는 어떻게 될까요?\n\n\n\n# 마르코프 성질의 역할\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_4.png)\n\n'마르코프(Markov)' 성질을 따르는 환경에 대해 얘기할 때 q-테이블 및 q-러닝 방법을 사용하는 것이 가장 적합하다는 점을 주목하는 것이 중요합니다.\n\n그게 뭔지 궁금하신가요?\n\n\n\n본질적으로 환경은 '마르코프'로 간주됩니다(러시아의 수학자 안드레이 마르코프에서 유래된 용어). 여기서 '마르코프'란 환경 안의 에이전트의 미래 상태가 현재 상태와 그 상태에서 취하는 행동에만 의존하며, 그 전에 발생한 사건이나 상태 순서에는 영향을 받지 않는 것을 의미합니다. 즉, 과거는 중요하지 않고, 현재와 즉각적인 미래만 고려하여 최상의 보상을 얻는 데 집중됩니다.\n\n마르코프 환경의 한 예로는 연결 네 개 보드가 있습니다. 연결 네에서 움직일 때마다, 실제로 중요한 것은 해당 시점의 보드 상태뿐이며, 5번 전에 누가 무슨 일을 했는지는 중요하지 않습니다(물론 그 때 중요했던 사항이지만, 움직일 때는 현재 보드 상태와 플레이 중인 모든 조각들만 알면 됩니다).\n\n마르코프 환경이 아닌 좋은 예시로는 포커 게임을 들 수 있습니다. 현재 카드와 베팅 풀뿐만 아니라, 상대의 베팅 이력과 블러핑 등의 맥락도 고려해야 합니다. 이러한 사항들은 현재와 미래 패를 플레이하기 위해 전략을 수정할 수 있습니다.\n\n강화학습에는 마르코프와 비마르코프 환경으로 처리하는 메커니즘이 있지만, Q-러닝은 전자를 위해 설계되었습니다.\n\n\n\n# 얼 그레이, 뜨겁게!\n\n이제 기다리고 계셨던 순간이 왔어요. 속 내용이 어떻게 스타 트렉: 다음 세대의 캡틴, 쟌 루크 피카드와 연결되는 건지 궁금하셨죠? 음, 여기서는 상기된 스타 플릿 선장과 그의 유명한 얼 그레이 차에 대한 애정을 사용해서 Q-러닝의 우리만의 구현을 보여드릴 거예요!\n\n그를 위해, '얼 그레이, 뜨겁게!' 라는 이름의 스타 트렉 우주를 기반으로 한 간단한 아케이드 게임을 디자인하기로 결정했어요.\n\n![Earl Grey, HOT!](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_5.png)\n\n\n\n우리의 강화학습 기반 게임을 만들기 위해 몇 가지가 필요할 거에요. 끝에 GitHub 레포지토리 링크를 제공할 테니, 여정 동안 함께 하실 거예요. 실험에서는 다음을 선택했어요:\n\n- Phaser (웹 기반 게임 개발 툴킷). 브라우저에서 호스팅할 빠르게 프로토타입을 만들고 싶어서 선택했어요. Phaser에 대해 더 알고 싶다면 여기를 참고하세요 https://phaser.io/\n- JavaScript (브라우저/클라이언트 기반으로 무언가를 만들기 때문에 순수 바닐라 JavaScript를 사용할 거에요).\n- AWS AppRunner (마지막 솔루션을 호스팅하기 위해 사용할 거예요. AppRunner에 대한 지식은 필요하지 않지만, GitHub와 AWS AppRunner 사이의 효과적인 연동이 간단하고 효과적이어서 선택했어요. 더 알아보려면 여기를 참고하세요 https://docs.aws.amazon.com/apprunner/latest/dg/service-source-code.html\n\n제 이야기는 이렇습니다. 불쌍한 Picard가 우주 병원에 감염되었어요. 이 바이러스로 뇌의 논리와 결정 센터가 덮어씌워져 동물처럼 허기진 듯이 얼그레이 차를 찾는 무모한 욕망이 일어났는데요. 그 결과, 그는 더 많은 얼그레이를 찾기 위해 지역 양로원을 뒤지고 다닌다고 해요. 이것이 우리 게임의 핵심이 될 거예요:\n\n- 에이전트 (Picard 선장)\n- 환경 (어린이집, 우리 경우 8 * 8 그리드)\n- 목표 (얼그레이 찻잔)\n- 일부 장애물 (Picard의 진행을 막는 양로원 간호원들!)\n\n\n\n저희 어플리케이션은 매우 간단하게 유지하고 있습니다. 우리 게임을 표시하는 index.html이 있고, RL 로직을 포함한 game.js, 게임을 호스팅하는 node.js 스크립트인 server.js, 그리고 몇 개의 .png 에셋이 있습니다. 완성된 에셋은 다음 저장소에 있어서 즐거운 시간을 보내실 수 있습니다:\n\n우리의 Web UI에는 우리의 에이전트의 성능에 영향을 미칠 수 있는 강화 학습 매개변수가 몇 가지 있습니다! 이들은 다음과 같습니다:\n\n- 학습률 — 에이전트가 경험으로부터 학습하는 속도를 나타냅니다. 높은 학습률은 에이전트가 더 빨리 학습하지만, 오버피팅에 민감할 수도 있습니다.\n- 할인 계수 — 할인 계수는 에이전트가 미래 보상을 얼마나 중요하게 생각하는지 결정합니다. 높은 할인 계수는 에이전트가 미래 보상을 더 중요하게 생각하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 비율 — 탐험 비율은 에이전트가 새로운 행동을 얼마나 자주 탐구할지 결정합니다. 높은 탐험 비율은 에이전트가 더 자주 탐구하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 감소 — 탐험 감소는 탐험 비율이 시간이 지남에 따라 얼마나 빨리 감소할지 결정합니다. 높은 탐험 감소는 탐험이 더 빨리 감소하게 만들고, 그 반대도 마찬가지입니다.\n\n자바스크립트 코드를 비롯한 모든 내용을 하나하나 검토하는 것보다, 강화 학습 구현과 관련된 부분에 중점을 둘 것입니다. Phaser 게임의 기본 설정(스프라이트, 환경 등)에 대한 정보는 Phaser 웹사이트를 참조해주세요.\n\n\n\nQ-learning을 사용하기 때문에 q-테이블을 생성해야 하는데, 이전에 간단히 언급한 것보다 더 복잡한 q-테이블이 필요합니다. 강화학습 환경을 생각해 보면, 8x8 그리드가 있으므로 64개의 다른 상태가 있습니다. 게다가, Picard는 각 그리드 타일에서 위, 아래, 왼쪽 또는 오른쪽으로 이동할 수 있으므로 8x8x4로 이어지게 됩니다. 따라서 이를 위해 3차원 배열이 필요합니다!\n\n게임.js에서 이를 수행하기 위해 q-테이블을 다음과 같이 생성합니다:\n\n```js\nfunction create() {\n    // gridSize x gridSize x 4 (4는 행동의 수)\n    qTable = Array(gridSize).fill().map(() =\u003e Array(gridSize).fill().map(() =\u003e Array(4).fill(0)));\n```\n\n\n\n기본적으로 우리는 격자의 길이를 가진 배열을 생성하고, 각 요소가 격자의 길이인 배열 내에 배열을 생성한 다음, 그 배열 내에 배열을 만들어 각 요소가 4가지 작업 상태에 대한 배열을 포함하도록합니다.\n\n우리 게임에서 무슨 일이 일어날까요? 의사 결정 프로세스의 핵심은 update(time) 메서드에서 처리됩니다.\n\n여기에서 우리의 에이전트는 행동을 결정하고, 그 행동을 취하며 보상이 업데이트되고, q-테이블이 업데이트되고 목표가 달성될 때까지 진행됩니다. update(time) 내에는 위치를 업데이트하고 스프라이트 또는 텍스트를 렌더링하는 데 관련된 많은 코드가 있지만, 검토해야 할 두 가지 핵심 요소는 chooseAction(position) 함수와 takeAction(position, action) 함수입니다.\n\n다음은 우리의 chooseAction 메서드입니다:\n\n\n\n```js\nfunction chooseAction(position) {\n    var action;\n\n    // 마지막 이동을 되돌리는 행동을 피합니다.\n    var avoidActions = lastActions(); // 최근 몇 가지 작업을 피하기 위한 함수 호출\n\n    if (Math.random() \u003c explorationRate) {\n        do {\n            action = Math.floor(Math.random() * 4); // 탐험\n        } while (avoidActions.includes(action));\n    } else {\n        // 최선으로 알려진 행동을 활용하며, 가능한 경우 최근 작업의 반대를 피합니다.\n        var currentQValues = [...qTable[position.y][position.x]]; // 현재 Q-값을 복제합니다.\n        avoidActions.forEach(a =\u003e currentQValues[a] = Math.min(...currentQValues)); // 반대 행동을 방지합니다.\n        var maxQValue = Math.max(...currentQValues);\n        action = currentQValues.indexOf(maxQValue);\n    }\n\n    updateLastActions(action); // 최근 작업을 업데이트합니다.\n    return action;\n}\n```\n\n우리는 탐험(새로운 영역 찾기) 또는 활용(알려진 좋은 보상 선택)을 선택할 때 약간의 무작위성을 사용하지만, explorationRate의 값에 따라 어느 정도 제어되는 것을 알 수 있습니다.\n\n탐험하기로 결정하면, 무작위로 위/아래/왼쪽/오른쪽 움직임을 선택합니다 (하지만 최근 작업 중에서 선택하지 않도록 확인을 추가해야 했습니다. 이렇게 함으로써 에이전트가 말하자면, 예를 들어 2개의 타일 사이를 오가며 무한 루프에 갇히는 것을 막았습니다).\n\n활용하기로 결정하면, 우리의 Q-테이블이 가장 좋은 알려진 행동이 무엇인지 알려줍니다 (시간이 지날수록 더 나아지고 더 \"알려진\" 상태가 됩니다). 그런 다음 행동을 선택하고 움직이며, 간호사, 격자 상의 일반 공간 또는 목표 자체 - 맛있는 얼그레이 티를 만났는지 확인하는 등의 작업을 수행합니다.\n\n\n\n\n우리의 takeAction() 메서드에서는 구체적으로 '보상' 기능을 구현했습니다. 가능하다면 Picard를 이동하고 목표를 발견한 경우 긍정적인 보상을 제공하거나 장애물에 부딪힌 경우 약간 부정적인 보상(누적)을 제공합니다:\n\n```js\nfunction takeAction(position, action) {\n    var reward = -0.01;\n    var newPosition = { x: position.x, y: position.y };\n\n    // 새 위치가 유효한지 확인합니다(장애물이 아니며 그리드 범위 내에 있는지)\n    function isValidMove(newX, newY) {\n        if (newX \u003c 0 || newY \u003c 0 || newX \u003e= gridSize || newY \u003e= gridSize) {\n            return false; // 그리드 범위 초과\n        }\n        return !obstacles.some(obstacle =\u003e obstacle.x / tileSize === newX \u0026\u0026 obstacle.y / tileSize === newY);\n    }\n\n    // 동작에 따라 새 위치 결정\n    switch (action) {\n        case 0: // 위\n            if (isValidMove(position.x, position.y - 1)) newPosition.y -= 1;\n            break;\n        case 1: // 오른쪽\n            if (isValidMove(position.x + 1, position.y)) newPosition.x += 1;\n            break;\n        case 2: // 아래\n            if (isValidMove(position.x, position.y + 1)) newPosition.y += 1;\n            break;\n        case 3: // 왼쪽\n            if (isValidMove(position.x - 1, position.y)) newPosition.x -= 1;\n            break;\n    }\n\n    if (newPosition.x !== position.x || newPosition.y !== position.y) {\n        // 유효한 이동인 경우 에이전트 위치 업데이트\n        agentPosition = newPosition;\n\n        if (agentPosition.x === goalPosition.x \u0026\u0026 agentPosition.y === goalPosition.y) {\n            reward = 1; // 목표에 도달한 경우 보상\n        }\n    } else {\n        // 잘못된 이동(경계를 벗어나거나 장애물로 이동함)\n        reward -= 0.1;\n    }\n\n    return reward;\n}\n```\n\nPicard를 결정하고 이동한 후에는 q-테이블을 다음과 같이 업데이트해야 합니다:\n\n```js\nfunction updateQTable(position, action, reward) {\n    var nextState = agentPosition;\n    var maxQValueNextState = Math.max(...qTable[nextState.y][nextState.x]);\n    qTable[position.y][position.x][action] += learningRate * (reward + discountFactor * maxQValueNextState - qTable[position.y][position.x][action]);\n}\n```\n\n\n\n다음은 Q-테이블을 업데이트하는 데 사용되는 JavaScript 구현입니다:\n\nQ(state, action)←Q(state, action) + α×(reward+γ×maxaQ(nextState, a)−Q(state, action))\n\n간단히 말하면: 새 점수 = 이전 점수 + 학습 계수 × (최근 점수 + 미래 잠재력 - 이전 점수).\n\n행동을 선택하고 수행하며 Q-테이블을 업데이트하는 것 외에도, 업데이트 방법에서 수행하는 몇 가지 다른 작업이 있으며, 이는 에이전트가 탐험할지 또는 이용할지에 대한 가중치와 관련이 있습니다.\n\n\n\n먼저, 각 단계마다 탐사하는 양을 감소시켜 최대 보상 경로로 수렴할 수 있도록 천천히 줄입니다 (저희 감쇠율에 따라):\n\n```js\nexplorationRate = Math.max(explorationRate - explorationDecay, 0.01);\n```\n\n이에 추가하여, 에이전트가 '멈춰 있는' 것처럼 보일 때 임시로 결정을 탐사하는 가능성을 증가시키는 작은 조정을 업데이트 메서드에 추가해야 했습니다.\n\n```js\nif (samePositionCount \u003e 3) {\n    explorationRate = Math.min(explorationRate + 0.1, 1.0);\n    samePositionCount = 0; // 카운터를 재설정합니다\n}\n```\n\n\n\n이전에는 에이전트가 어딘가에서 루프에 자주 걸렸었지만, 추가하면서 멈춰있다가 얼마 동안 같은 위치에 있으면 약간의 '후드'를 줍니다. 이 변경 사항은 일시적이며 에이전트가 다시 움직일 때까지만 유효합니다.\n\n게임은 피카드가 소중한 얼 그레이에 도착할 때마다 보상을 평가하며, 5번의 연속 시도에서 최대 보상에 수렴할 때 실험이 완료/이루어집니다. 이 시점에서 우리는 에이전트가 가능한 한 작업에 '적합하게' 되었다고 생각합니다.\n\n완성품? 정말 멋진 ('알아요, 알아요 - 이것은 매우 유치하지만, 여전히 재미 있겠죠!') '얼 그레이, HOT1' 게임을 만들었는데요, 아래 링크에서 확인해보세요:\n\nhttps://earlgreyhot.org/\n\n\n\n![Building a Q-table Reinforcement Learning Agent with Captain Picard](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_6.png)\n\n재밌게 즐기고, 매개변수를 조정해보세요. 에이전트가 완료할 때까지 시도 횟수를 최소화해보세요! 그리고 덤으로, 누군가에게 다양한 보상(긍정적이고 부정적인 것, 또는 새로 만들기?)을 조정할 수 있는 기능을 추가하여 그것이 에이전트의 성능에 미치는 영향을 사용자들이 볼 수 있도록 소스 코드를 업데이트하도록 초대합니다.\n\n이 글이 재밌게 보이셨기를 바라며 — 항상 트레키한 방식으로 Q-러닝을 통한 강화 학습 개념을 다룬 것에 흥미를 느끼셨으면 이 기사를 즐기셨다면 박수를 보내거나 댓글을 남겨주세요 — 다음에 또 만나요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png","tag":["Tech"],"readingTime":12},{"title":"ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작","description":"","date":"2024-05-14 13:22","slug":"2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem","content":"\n\n# 아이디어의 시작\n\n모든 것은 간단한 필요성에서 시작되었습니다: 내 스크립트에서 함수로 관리되는 레이어의 시각적 표현이 포함된 코멘트를 작성하고 싶었습니다. 몇 가지 특수 문자(ASCII 문자)가 존재하여 상자의 변에는 직선, 모퉁이에는 각도, 교차점에는 십자가 있는 다이어그램을 만드는 데 복사하여 붙여넣을 수 있다는 것을 알고 있었습니다.\n\n![다이어그램](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png)\n\n모든 이러한 문자들은 함께 작동하고 정렬하기 위해 설계되었습니다. 이러한 문자들은 상자 그리기 문자로 알려져 있습니다. 그러나 문자를 복사하여 붙여넣어 복잡한 다이어그램을 수동으로 만드는 것은 지루하고 실수할 여지가 많습니다.\n\n\n\n```js\n┌─┬┐  ╔═╦╗  ╓─╥╖  ╒═╤╕\n│ ││  ║ ║║  ║ ║║  │ ││\n├─┼┤  ╠═╬╣  ╟─╫╢  ╞═╪╡\n└─┴┘  ╚═╩╝  ╙─╨╜  ╘═╧╛\n┌───────────────────┐\n│  ╔═══╗ 일부 텍스트  │▒\n│  ╚═╦═╝ 상자 안에    │▒\n╞═╤══╩══╤═══════════╡▒\n│ ├──┬──┤           │▒\n│ └──┴──┘           │▒\n└───────────────────┘▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n```\n\n이 작업을 간단하게 처리할 수있는 도구의 잠재력을 깨달았을 때, 기존 솔루션을 검색했지만 제 요구 사항을 충족하는 것은 없었습니다. 우리가 \"프로그래머의 저주\"라고 부를 수있는 것에 격려되어, 제 즉각적인 문제를 수동으로 해결하지 않고 누구나 사용할 수있는 프로세스를 자동화하는 솔루션을 생성하기로 결정했습니다.\n\n## 비전 정의\n\n내 비전은 분명했습니다: 누구나 ASCII 상자를 그리고 클릭하고 드래그하여 코멘트를 추가 할 수있는 직관적이고 쉽게 접근할 수있는 웹 앱을 개발하는 것 — Adobe Illustrator와 같은 도구의 간단함과 강력함을 반영하는 것입니다.\n\n\n\n# 핵심 구축: ASCII 아트의 로제타 스톤\n\n이 도구(ASCII Box Editor)의 기초를 다지기 위해, 나는 디지털 캔버스 상에서 서로 다른 ASCII 문자들이 어떻게 결합되는지에 대한 도전에 직면했습니다. 예를 들어, 수직 선 위에 수평 선을 그리는 것은 단순히 겹치는 것이 아니라 교차점을 형성해야 합니다.\n이러한 과정에서 나는 \"로제타\"라는 시스템을 설계하기로 결심했습니다. 이 시스템은 서로 다른 타격과 문자가 어떻게 병합되는지를 정의하는 복잡한 배열 기반 객체입니다.\n이 아이디어는 각 문자를 함수에 의해 해석될 수 있는 표현으로 변환하는 것입니다. 각 문자마다 그 카디널 포인트에 경로의 존재에 대응하는 등가 배열을 얻게 됩니다.\n\n```js\n[ ╳, ╳, ╳, ╳ ]                         \n  │  │  │  │                           \n  └──┼──┼──┼──▶ 상단에 경로가 있나요?  \n     └──┼──┼──▶ 우측에 경로가 있나요?  \n        └──┼──▶ 하단에 경로가 있나요?  \n           └──▶ 좌측에 경로가 있나요?  \n\n왼쪽 상단 모서리 문자 '┌'의 예\n       ┌┄┄┄┄┄┄┄┄┄┄┄┄┐           \n       ┆            ▽           \n    ╔══╧══╗ '┌' = [ 0, 1, 1, 0 ]   \u003e 0 = 없음\n    ║     ║            ▲  ▲  △     \u003e 1 = 경로가 이 위치에 있음\n  ┌┄╢  ┏━╸╟────────────┘  │  ┆  \n  ┆ ║  ┃  ║               │  ┆  \n  ┆ ╚══╤══╝               │  ┆  \n  ┆    └──────────────────┘  ┆  \n  └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘  \n```\n\n이러한 논리를 기반으로, 각 문자에 대한 모든 등가 배열을 보관할 asciiBox_Rosetta 객체를 생성했으며, 문자('char') 표현에서 배열('code')로 변환하고 그 반대로 변환하는 두 가지 함수를 첨부했습니다.\n\n\n\n```js\n// ROSETTA: ASCII 문자를 배열 표현으로 매핑하기\nclass asciiBox_Rosetta {\n  constructor() {\n    this.rosetta = {\n      '─': [0, 1, 0, 1], // 수평선\n      '│': [1, 0, 1, 0], // 수직선\n      '┼': [1, 1, 1, 1], // 교차점\n      // 기타 등등...\n    };\n  }\n  // 문자와 코드 사이의 변환을 위한 메소드\n  getCharFromCode(code) {…}\n  getCodeFromChar(char) {…}\n}\n```\n\n로제타를 사용하면, 나는 이제 문자들 간 상호작용에 기반한 동적 문자 변환을 수행할 수 있는 간단한 중첩 문자 논리를 구성할 수 있었습니다. 이는 디지털 회로의 논리 연산을 모방하지만 텍스트 캔버스 상에서 이루어집니다.\n\n```js\n'─'와 '│' 사이의 조합 예제\n\n '─' + '│' = [0, 1, 0, 1] + [1, 0, 1, 0] = [1, 1, 1, 1] = '┼'   \n└┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┘  \n수평선      배열 표현          최종 배열       교차점\n\u0026 수직선                                          \n```\n\n이 간단한 논리 알고리즘은 문자 간의 중첩을 효과적으로 처리하는 데 매우 효과적이었습니다. 이 알고리즘을 통해, 나는 그림을 그리기 위해 마우스 이벤트를 캡처하고, 굵은 글꼴, 점선, 이중 선 등의 스타일 변경 및 화살표와 같은 방향 표시용 끝 캡슐을 통합하는 것만으로도 가능했습니다.```\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*tPD4T6_yVr6wBlKDj6RKGw.gif\" /\u003e\n\n# 기능 구현: 선 그리기를 넘어서\n\n정적 디자인으로부터 완전히 상호작용형 웹 애플리케이션으로의 여정은 다양한 사용자 도구를 관리하는 것을 포함하여 수많은 도전을 안겨주었습니다. 각 도구마다 고유한 특성과 동작이 있기 때문에 그것을 관리하는 것이 쉽지 않았습니다.\n\nASCII Box Editor의 핵심은 asciiBox_ToolManager인데, 이 동적 시스템은 사용자의 작업에 따라 도구를 전환할 수 있도록 설계되었습니다. 이 시스템은 부드러운 사용자 경험을 제공할 뿐만 아니라 코드베이스를 획기적으로 간소화하는 데 중요합니다.\n\n\n\n```js\n// 도구 관리자: 도구의 활성화와 사용을 관리합니다\nclass asciiBox_ToolManager {\n    constructor(db, styleContainer) {\n        this.currentTool = null;  // 현재 활성화된 도구\n        this.previousTool = null;  // 빠른 전환을 위해 이전에 사용한 도구\n        // 일련의 도구로 초기화\n        this.tools = {\n            \"직선 그리기\": new asciiBox_DrawLine(this),\n            \"상자 그리기\": new asciiBox_DrawBox(this),\n            \"지우개\": new asciiBox_Erase(this),\n            // 여기서 더 많은 도구를 초기화합니다...\n        };\n    }\n    // 사용자 선택에 따라 도구를 설정하는 함수\n    setTool(toolName) {\n        this.previousTool?.deactivate();  // 이전 도구 비활성화\n        this.currentTool = this.tools[toolName];\n        this.currentTool.activate();  // 새 도구 활성화\n    }\n}\n```\n\n전통적인 절차적 코드는 각 도구를 별도의 함수로 처리하거나 if-else 문의 일련의 문장으로 처리할 수 있었으며, 이는 코드가 비대하고 반복적이며 유지보수하기 어렵게 만들었습니다. 반면, 객체지향 접근 방식은 각 도구의 기능을 클래스 내부에 캡슐화합니다. 이로 인해 코드가 더 깨끗하고 디버깅하기 쉬워지면서 확장성도 향상됩니다. 새로운 도구를 추가하는 것은 새 클래스를 정의하고 도구 관리자에 추가하는 것만으로 간단해집니다.\n\n각 도구는 일반 asciiBox_Tool 클래스에서 상속을 받으며 활성화 및 비활성화와 같은 공통 동작을 정의하고 특정 동작은 각 도구의 필요에 맞게 하위 클래스에 재정의됩니다. 이 다형성은 asciiBox_ToolManager가 도구 세부 사항에 대해 무관하게 유지되면서 다양한 기능을 활성화할 수 있도록 합니다.\n\n```js\n// 일반 도구 클래스\nclass asciiBox_Tool {\n    constructor(name, manager) {\n        this.name = name;\n        this.manager = manager;\n        this.isActive = false;\n    }\n    activate() { this.isActive = true; }\n    deactivate() { this.isActive = false; }\n    onMouseDown(args) { /* 기본 마우스 다운 동작 */ }\n}\n\n// 특정 도구 생성\nclass asciiBox_Select extends asciiBox_Tool {\n    constructor(manager) {\n        super('선택', manager);\n        // 더 많은 초기화 변수\n    }\n    // 사용자 입력 이벤트 처리를 위한 함수 로직\n}\n```\n\n\n\n사용자 상호작용의 세부 사항을 주의 깊게 고려하여 필요한 모든 도구를 설정했습니다. 간단한 클릭부터 복잡한 드래그 앤 드롭 제스처까지 ASCII Box Editor가 모든 단계에서 직관적으로 유지될 수 있도록했습니다.\n이 유연한 아키텍처는 많은 시간을 절약했습니다. 앱이 발전함에 따라 asciiBox_ToolManager의 유연성으로 인해 새로운 도구와 스타일을 소개할 수 있었지만 이전 기능의 핵심 기능을 방해하지 않았습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jJFHQSLocMxTWVT5nMofiA.gif)\n\n# 여정이 계속됩니다\n\n처음부터 비전은 간단한 필요성을 보편적인 해결책으로 변형하는 것이었습니다. ASCII Box Editor는 그 비전의 실행입니다. ASCII 코멘트를 생성하는 것을 간소화하면서도 정교한 디자인 도구의 간편함과 강력함을 유지합니다.\n\n\n\n위 설명에서 볼 수 있듯이, 때로는 \"프로그래머의 저주\"가 초기 도전을 벗어나 혁신적인 해결책을 이끌어낼 수 있습니다.\n\n어떻게 작동하는지 궁금하신가요? ASCII Box Editor를 한 번 시도해 보세요!\ntheokva.github.io/ascii-box-editor 👋\n\n![출력](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_1.png)\n\n—Theo\n\n\n\n만약 이 기사가 마음에 드셨다면 👏 클랩(clap)을 부탁드려요. \n더 많은 이야기를 보시려면 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png"},"coverImage":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png","tag":["Tech"],"readingTime":6},{"title":"LWC에서 LMS를 통한 커뮤니케이션","description":"","date":"2024-05-14 13:20","slug":"2024-05-14-CommunicationThroughLMSinLWC","content":"\n\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png)\n\nSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\n\n# Lightning Message Service란?\n\nLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\n\n\n\n\n그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\n\nLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\n\n아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\n\n\n\n# 라이트닝 메시지 서비스(LMS) 이해하기:\n\nLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\n\n라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\n\n## 1. 발행자(Publisher):\n\n\n\n- Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\n- 이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\n- Publisher 구성 요소를 생성할 때는 `@salesforce/messageChannel` 모듈에서 `publish()` 함수를 import해야 합니다.\n- 이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\n\n## 2. Subscriber:\n\n- Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\n- 이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\n- 중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png)\n\n\n\n## 주의 !\n\n# LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\n\n## 메시지 채널 메타데이터 정의:\n\n컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\n\n\n\n- Salesforce 프로젝트 구조의 `force-app/main/default` 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\n\n2. 이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\n\n3. 아래 코드를 참고하여 .xml 파일에 `lightning message field`를 정의해주세요:\n\n\nsampleMessageChannel.messageChannel-meta.xml\n\n\n\n\nmd\n```js\n\u003c!--?xml version=\"1.0\" encoding=\"UTF-8\"?--\u003e\n\u003clightningmessagechannel xmlns=\"http://soap.sforce.com/2006/04/metadata\"\u003e\n    \u003cmasterlabel\u003eSampleMessageChannel\u003c/masterlabel\u003e\n    \u003cisexposed\u003etrue\u003c/isexposed\u003e\n    \u003cdescription\u003eThis is a sample Lightning Message Channel.\u003c/description\u003e\n     \n    \u003c!-- Define message payload fields --\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordId\u003c/fieldname\u003e\n        \u003cdescription\u003eThis is the record Id that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordData\u003c/fieldname\u003e\n        \u003cdescription\u003eThe current data representing the record that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n\u003c/lightningmessagechannel\u003e\n```\n\n## 설명:\n\n- `isExposed` 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\n- `lightningMessageFields` 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 `recordId`를 정의할 수 있습니다.\n- `description` 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\n- `.messageChannel-meta.xml` 파일이 작성되면 Salesforce org에 배포하세요.\n\n## 메시지 서비스 기능 가져오기:\n\n\n\n\n번역 : \n\n당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\n\n```js\nimport { publish, subscribe, unsubscribe, APPLICATION_SCOPE, MessageContext } from 'lightning/messageService';\nimport msgService from '@salesforce/messageChannel/messageChannelName__c';\n```\n\n## 메시지 서비스 범위 정의:\n\n`@wire 어댑터`를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 `@wire 어댑터`로만 스코핑이 가능합니다.\n\n\n\n예시:\n\n```js\n@wire(MessageContext)\nmessageContext;\n```\n\n# 메시지 채널 발행:\n\n메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 `publish()` 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\n\n\n\n```js\nconst messagePayload = {\n    recordId: '0012y00000L5R6jAAF',\n    recordData: { /* 레코드를 나타내는 데이터 */ }\n};\npublish(this.messageContext, msgService, messagePayload);\n```\n\n`publish()` 메소드는 3개의 파라미터를 받습니다 :\n\n- 메시지 컨텍스트 (객체 타입)\n- 메시지 채널 (객체 타입)\n- 메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\n\nmessageContext : `MessageContext` 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\nmessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 `@salesforce/messageChannel`과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\n\nmessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\n\n# 메시지 채널 구독:\n\n\n\n특정 메시지 채널의 메시지를 구독하려면 `subscribe()` 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\n\n```js\nthis.subscription = subscribe(\n    this.messageContext,\n    msgService,\n    (message) =\u003e this.handleMessage(message)\n);\n```\n\n`subscribe()` 메서드는 4개의 매개변수를 받습니다:\n\n- 메시지 컨텍스트 (객체 형식)\n- 메시지 채널 (객체 형식)\n- 리스너 (함수 형식)\n- 구독자 옵션 (객체 형식)\n\n\n\n메시지 컨텍스트: `MessageContext` 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터를 통해 가져오거나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\n메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 `@salesforce/messageChannel`을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\n\n리스너: 발행된 메시지를 처리하는 함수입니다.\n\n\n\nsubscriberOptions: (선택 사항) 이 객체는 `'scope: APPLICATION_SCOPE'`로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. `lightning/messageService`에서 `APPLICATION_SCOPE`를 가져와야 합니다.\n\n# 메시지 채널 구독 취소:\n\n메시지 채널 구독을 취소하려면 `unsubscribe()` 메서드를 사용하고, `subscribe()` 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\n\n```js\nunsubscribe(this.subscription);\n```\n\n\n\n# Salesforce Lightning Message Service를 언제 사용해야 할까요?\n\n라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\n\n- 부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\n- 동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\n- 크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\n- 동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\n\n다음은 Lightning Message Service의 사용 예시 시나리오입니다:\n\n\n\n당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\n\n# Salesforce Lightning Message Service의 제한 사항\n\n- LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\n- LMS는 iframe에서 작동하지 않습니다.\n- LMS는 Salesforce 클래식에서 작동하지 않습니다.\n- Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\n\n# 결론:\n\n\n\n라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\n\n\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\n\n즐거운 LWC 코딩하세요!\n\n더 자세한 내용은 아래 링크를 방문해주세요:","ogImage":{"url":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png","tag":["Tech"],"readingTime":7},{"title":"네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여","description":"","date":"2024-05-14 13:18","slug":"2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG","content":"\n\n![지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png)\n\nGeoJSON 데이터셋과 JavaScript d3.js를 사용한 SVG 시각화의 결합은 지리적 데이터(지역, 국가, 주, 성, 도시 등)에 대한 풍부하고 상호 작용적인 시각화를 만드는 데 매우 가치가 있습니다. 이 기사에서는 저의 거주 지역인 네덜란드에 이 강력한 결합을 적용할 것입니다. 네덜란드의 12개 성에 대한 데이터가 포함된 GeoJSON 파일을 찾아서 d3.js를 사용하여 간단한 웹 애플리케이션에서 국가와 그 성을 시각화할 것입니다. 그런 다음, 저가 CTO로서 역할을 맡고 있는 Conclusion 회사들의 사무실 위치를 나타내는 마커를 추가할 것입니다.\n\n최근 몇 개의 기사에서는 세계 데이터셋에서 특정 속성에 따라 국가에 색상을 할당한 테마별 세계지도를 사용한 데이터 시각화에 대해 d3.js 라이브러리의 사용법을 소개했습니다. 이를 위해 SVG와 함께 사용하는 방법을 소개했는데, GeoJSON 데이터 형식은 국가 및 주에서 도시, 호수 및 산림까지 다양한 지리적 정의가 가능합니다. 어떻게 지도를 다른 속성 간에 쉽게 전환하고 상호 작용성을 추가할 수 있는지(국가를 클릭하여 선택하고 지도의 회전 또는 동서 방향 이동 변경)를 보여 주었습니다. 네 번째 기사에서는 프로그래밍 방식과 사용자 시작으로 확대(그리고 다시 축소)하는 두 가지 다른 방법에 대해 논의했습니다.\n\n이 기사에서는 이전 기사에서 만든 것을 적용하여 네덜란드 관련 데이터를 다룰 것입니다.\n\n\n\n# 네덜란드 시각화\n\nd3.js를 사용하여 세계의 일부를 시각화하는 첫 단계는 분명히 지리 정보를 제공하는 GeoJSON 파일을 찾는 것입니다. 조금 찾아보니 Cartomap GitHub 저장소를 발견했는데, 다양한 지역 시스템에 대한 지리 정보를 제공하는 유용한 GeoJSON 파일이 많이 있습니다. 재판소, 소방서, 노동시장, 관광, 보건, 자치구, 도시지역, 청소년, 상공회의소, 농업, 공공시설, 경찰, 지방, 소속기관, 동네, 안전 지역 등을 위한 파일들이 많이 있습니다. 대부분의 파일은 여러 해에 대해 사용 가능합니다.\n\n저는 wgs84/provincie_2023.geojson 파일을 활용하기로 결정했습니다. 이 파일은 12개의 지방에 대한 경계 점의 지리 좌표를 포함하고 있습니다. 각 지방의 이름도 포함되어 있습니다. 이것만 있으면 지도를 그릴 수 있습니다.\n\n![네덜란드 지역의 공식 위치 시각화 지도](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_1.png)\n\n\n\n저는 세계를 시각화하는 기사에서 대부분 했던 작업을 가져왔어요. \"country/countries(국가/국가들)\"에 대한 모든 참조를 \"area/areas(지역/지역들)\"로 변경했어요. 여기서 적절한 초기 축척 요소(네덜란드는 작은 국가이기 때문에 대규모 축척로 했을 때 거의 보이지 않는다)와 적절한 투영 회전을 찾았어요. d3.geoEquirectangular 투영 대신에 이제 d3.geoMercator를 사용하고 있어요(지구의 모양이 투영에 방해가 되지 않는 더 작은 국가에 더 적합해요). 국가의 형태에 따라 mapHeight(너비에 비해 상대적으로 높이를 증가했어요).\n\nGeoJSON 기능에서 제공되는 제목(마우스 호버 텍스트) 및 식별에 관한 내용을 제공하는 상수를 정의했어요:\n\n이러한 변경 사항은 redrawMap() 함수에서 나타납니다:\n\n\n\n![그림1](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_3.png)\n\n아래는 영역을 선택하거나 해제하는 논리에 대한 코드 예시입니다:\n\n![그림2](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_4.png)\n\n현재 index.html 파일의 상태입니다. GitHub Pages에서 데모를 확인해보세요.\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*GUemI5VHeyQPqQiATAoNZQ.gif\" /\u003e\n\n# 지도상의 위치 표시\n\n이것은 좋은 첫걸음입니다: 네덜란드와 그 주요 지역 구획의 시각화입니다.\n\n한 발 더 나아가서 지도에 위치를 추가해봐요. 도시를 대표하는 지리적 지점들이나, Conlusion 사무실 위치 등을 예로 들 수 있습니다.\n\n\n\n이 GeoJSON 파일에는 대도시 지역이 포함되어 있습니다. 이 지역은 다각형을 통해 다시 정의됩니다. 이들은 지방에 그려질 수 있으며, 해당 국가의 주요 도시를 나타낼 수 있습니다.\n\n도시 지역을 포함하려면 필요한 변경 사항은 다음과 같습니다:\n\n- 도시 지역을 위한 스타일 클래스를 정의합니다.\n- City GeoJSON을 로드하고 이를 지방 세부 정보와 병합합니다.\n- 각각 지방과 도시에 대한 생성된 모양에 적절한 스타일 클래스를 할당합니다.\n\n클래스 도시:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_5.png\" /\u003e\n\n도시 GeoJSON을 로딩하고 병합:\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_6.png\" /\u003e\n\nSVG 모양을 렌더링할 때 적절한 스타일 클래스 할당하기:\n\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_7.png)\n\n생성된 지도는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_8.png)\n\n모든 도시 지역이 강조되어 있습니다. 각각에는 호버 텍스트에 해당하는 이름이 있습니다. 그리고 도시 지역도 마찬가지로 선택할 수 있습니다:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_9.png\" /\u003e\n\n이 시점의 index.html 파일입니다. 그리고 라이브 데모입니다.\n\n이제 도시를 다각형 영역으로 그리는 대신, 각 도시를 원으로 나타내는 것이 더 나을 것 같습니다. 이것은 Polygon 대신 GeoJSON Point에서 파생됩니다.\n\n이를 달성하기 위해 해야 할 일은 도시 GeoJSON의 모든 요소를 처리하고 각각을 만들어 집합니다. 그런 다음 치에서 파생된 geojsonData에 추가하는 것입니다.\n\n\n\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_10.png)\n\n생성된 지도:\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_11.png)\n\n네덜란드 지리에 익숙하신 분들은 이 도시 원들이 실제 도시가 위치한 곳에 모두 있는 것이 아니라는 점을 알 수 있을 것입니다. 분명히, 도시 영역을 경계 지정하는 직사각형의 중심이 항상 실제 도시 중심과 같은 곳에 있는 것이 아닙니다.\n\n\n\n\n점(도시)의 시각화 크기와 색상을 조절할 수 있어요. 가장 간단한 방법은 원의 반지름을 사용자 정의하여 경로 생성기를 정의하는 것입니다: d3.geoPath().pointRadius(custom-circle-radius);\n\nGeoJSON 기능을 위한 SVG 객체를 만들 때 사용되는 경로 생성기 함수를 수정하여 Points에 대한 사용자 지정 함수를 호출할 수 있어요.\n\n사용자 정의 함수를 구현한 예시 중 하나는 간단한 집 모양(사실 직사각형과 삼각형입니다)을 그리는 경로를 만드는 함수입니다:\n\n\n\n![Map Visualization](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_13.png)\n\n지도 상에 각 도시의 위치에 간단한 집 모양이 표시되었습니다:\n\n![Map Update](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_14.png)\n\n이 시점에서의 index.html 파일 상태 및 실시간 데모 페이지입니다.\n\n\n\n# 컨클루전 사무실 위치 추가\n\n2023년 5월 1일 현재, 저는 IT 기업 그룹인 컨클루전의 CTO입니다. 컨클루전은 각기 다른 전문성, 문화, 역사(및 미래), 제안 및 고객을 갖춘 30개 이상의 자율적인 회사들로 구성되어 있습니다. 이러한 회사들은 내부적으로 협력하여 더 스마트하고 효율적으로 일을 처리하고, 노하우와 경험을 공유하는 좋은 실천 방법을 기반으로 한 활동, 스포츠 이벤트, 문화 활동 및 자선 행사에서 더 즐거운 시간을 보내며, 동료들이 자매 회사의 다른 역할에서 경력을 쌓을 수 있도록 가능하게 하며, 외부적으로는 고객에게 상호 일치하는 다양한 서비스를 제공하기 위해 협력합니다.\n\n네덜란드 내에서 컨클루전은 12개 이상의 장소에 사무실을 두고 있습니다. 대부분은 개별 회사용이며 일부는 여러 회사를 수용하고 있습니다. 대부분의 동료들은 사무실에 출근하고 싶은 경우 모든 사무실을 이용할 수 있습니다.\n\n모든 컨클루전 사무실 위치를 시각화하기 위해 네덜란드의 지도를 사용할 예정입니다.\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_15.png)\n\n결론 사무실의 위치를 나타내는 새로운 GeoJSON 파일을 추가할 거에요. 이 파일은 저 혼자 만들어야 해요. 이 위치들은 Point 유형의 특징이며 방금 도시들에 사용한 집 아이콘으로 시각화되어야 해요.\n\n사무실을 위한 새로운 CSS 스타일을 정의했어요.\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_16.png)\n\n\n\n새로운 파일이 로드되고 사무실 위치에 대한 데이터가 geojsonData 세트에 포함되었습니다\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_17.png)\n\n기능이 사무실 위치를 설명하는 경우 작은 집 아이콘을 그릴 사용자 정의 기능이 호출됩니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_18.png)\n\n\n\n다음과 같은 지도가 생성됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-네덜란드의사무소위치시각화-GeoJSON, D3, SVG_19.png\" /\u003e\n\n실시간 데모에서 직접 이 결과를 확인할 수 있습니다. index.html의 현재 상태도 확인할 수 있습니다.\n\n다음 단계로는 오피스를 클릭하면 해당 위치와 그 안에 위치한 회사에 대한 정보를 보여주는 팝업 창을 구현할 수 있습니다 (필요한 정보는 이미 GeoJSON 파일에 포함되어 있습니다).\n\n\n\n# 결론\n\n이 글에서는 GeoJSON 데이터를 네덜란드의 맥락에서 시각화할 수 있다는 것을 보여드렸어요. 전 세계 지도에 대한 모든 코드를 재사용하여 네덜란드의 지방 및 도시 데이터가 포함된 GeoJSON 파일을 손쉽게 추가하고 시각화할 수 있습니다 (매우 조정된 스케일 요인을 사용). 그리고 커스텀 포인트 표현을 소개했어요 - 결론 생태계의 사무실 위치를 보여주기 위해 (네덜란드에 있습니다.; 독일, 벨기에, 포르투갈, 스페인, 남아프리카에도 위치가 있어요. 혹시 다음 글에서 이를 추가할지도 몰라요).\n\n# 자료\n\n이 글에 대한 코드가 포함된 GitHub 저장소, 새로운 GeoJSON 파일을 포함하고 있어요 - 결론 사무실 위치를 나타내기 위해 제가 직접 만들어야 했던 파일이에요.\n\n\n\n내 이전 기사들을 통해 세계지도 데이터 시각화에 대해 소개하겠습니다:\n\n1. 나라 데이터 시각화를 위한 대화형 세계지도 생성하기 - https://medium.com/@lucasjellema/create-interactive-world-map-to-visualize-country-data-baa5b242bfbb - d3, SVG 및 JavaScript를 사용한 세계지도 데이터 시각화 소개.\n\n2. 세계지도 시각화를 활용한 데이터로 세계를 소개하기 - https://medium.com/@lucasjellema/presenting-the-world-in-data-using-world-map-visualization-d3-kaggle-world-data-set-7c16ca207fb0 - 첫 번째 기사에서 데이터 시각화에 대한 간단한 접근 방식과 Kaggle의 풍부한 데이터 세트를 결합하여 세계의 모든 국가에 대한 교육, 건강, 경제, 인구 통계, 기후 등 많은 흥미로운 세부 정보를 제공합니다.\n\n3. 세계지도 내 대화형 데이터 시각화 - 확대, 이동, 범례 - https://medium.com/@lucasjellema/interactive-data-visualization-in-world-map-translate-select-legend-popup-4d28261110df - 세계지도에 상호 작용을 추가하는 것에 대해 자세히 살펴보겠습니다. 특히: 지도의 회전을 변경, 나라 선택(클릭으로), 나라 세부 정보 팝업 창 표시 및 범례 - 색상 스케일 (히트맵 색상을 숫자 값에 매핑) 표시하기.\n\n\n\n4. World Map Data Visualization with d3.js, GeoJSON and SVG - Zooming, Panning and Dragging\n- 더 자세한 내용은 [여기](https://medium.com/@lucasjellema/world-map-data-visualization-with-d3-js-geojson-and-svg-zooming-and-panning-and-dragging-194fb16dec9a)를 확인해보세요!  \n- 월드맵에 확대/축소, 이동 및 드래그 기능을 사용자 및 프로그램으로 구현했습니다.\n- 원본 게시물은 2024년 1월 2일에 [여기](https://technology.amis.nl)에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png"},"coverImage":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png","tag":["Tech"],"readingTime":8},{"title":"대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays","content":"\n\n## 프로그래밍\n\n![이미지](/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png)\n\n대학이나 대학교에 다니는 것이 프로그래밍에 도움이 되는 이유를 정리해 보았어요.\n\n1. 대학에 다니면 전문가로 성장할 수 있어요. 직업에 상관없이 공부를 하면 뚜렷한 차이가 있어요. 대학은 교육을 제공하고 그 기반이 되는 것으로 각자 자아를 세워나가게 해줘요. 니든, 버핏, 또는 빌 게이츠처럼 천재가 아닌 이상, 대학은 무궁무진한 장점을 줄 거예요.\n\n\n\n2. 요즘에는 온라인으로 모든 것을 배울 수 있어요. Coursera나 Udemy와 같은 무료 또는 믿을 수 없을 만큼 저렴한 강좌를 제공하는 플랫폼이 많이 있어요. 어떤 대학들은 수업을 녹화해서 유튜브에 무료로 올리기도 해요.\n\n문제는 여전히 자격 증명과 학위를 높이 평가하는 사회에서 살고 있다는 거예요. 그래서 대학을 가지 않은 사람이 일자리를 구하는 데 훨씬 더 어려움을 겪을 확률이 매우 높아요. 좋은 프로그래머가 되려면 반드시 대학에 다녀야 하는 것은 아니지만, 다녀도 안 하지 않는 게 무의미한 건 아니에요.\n\n3. 대학의 주요 기능은 많은 주제에 대한 비교적 기본적인 개요를 제공하는 것이에요. 유용하긴 하지만 스스로 계속 공부해야 해요. 스스로 공부하거나 대학에서 배우는 차이는 대학이 당신이 도움이 되지 않을 것 같아서 무시하거나 지루하다고 생각하던 주제를 봐야 한다는 점이에요. 또한 고려해야 할 내용이라고 전혀 모르던 주제까지 볼 수도 있어요. 대학은 또한 당신에게 (컨퍼런스, 강좌, 인턴쉽과 같은) 문을 여는데, 이를 통해 당신의 시야를 넓힐 수 있게 해줄 거에요.\n\n4. 대학은 좋은 프로그래머를 보장해 줄 수준이 아니에요. 프로그래밍에 전념하지 않는 가득 찬 강의가 많이 있어서 소중한 시간을 낭비하게 될 수도 있어요. 게다가, 이 수업은 스스로 알고 있거나 모르는지 알려줘야 하는 학생들을 대상으로 같은 내용을 가르치기 때문에, 많은 대학들이 특정 언어의 여러 레벨을 제공하지 않아요. 하지만 당신이 지식의 표면을 긁어 보는 데는 도움이 될 거에요.\n\n\n\n5. 보통 프로그래머들이 더 나아지고 있다고 생각해요. 왜냐하면 그들은 더 좋은 기반으로 시작하기 때문이에요. 이 직업에서는 매일 무언가가 발명되고, 많은 해를 경험을 통해 배우는 것은 처음부터 그 가치가 무엇이며 막다른 길에 뉴런을 낭비하지 않는 것과는 다릅니다.\n\n6. 대학교는 말하자면, 어떻게 배우는지를 가르쳐줍니다. 자원을 찾아내고 어디에서 찾을 수 있는지를 아는 것이죠. 대학교가 당신을 좋은 프로그래머로 만든다고 생각하지 않아요. IDE(코드를 작성하는 환경)과 처음으로 대면했을 때, 색깔에 놀랐어요. 첫 디버깅을 했을 때, 브레이크포인트를 설정할 수 있다는 것을 보고 놀랐어요.\n\n아직도 세상에는 직업 세계를 접하지 않은 공룡 교수님들이 있는 대학교가 있어요. 그들은 실제로 어떻게 하는지 알지 못해요. 오늘날은 어떤 IDE나 버전 관리 도구, 모든 친구들에게도 참을 수 없어요.\n\n7. 대학교에서는 배우는 법을 배웁니다. 미래의 프로그래머로, 당신은 스스로 학습하는 습관을 길러야 합니다. 때로는 강제적인 속도로 학습해야 할 때도 있죠.\n\n\n\n프로그래밍 스킬의 90%를 스스로 얻는다는 것을 이해한다면, 대학 외부에서 공부하거나 동료 학생들과 협력하면서 얻게 될 것이다.\n\n그래서, 네, 대학은 당신을 더 나은 프로그래머로 만들어줄 것입니다. 교과목들이 당신에게 가르치는 것만으로 충분히 숙련된 프로그래머로 성장할 수 있다고 기대한다면, 그렇지 않습니다. 대학은 당신을 더 나은 프로그래머로 만들어주지 않을 것입니다.\n\n훈련을 통해 많은 계획이 오랜 시간 동안 세심하게 고안되고 개선되어온 것을 알 수 있습니다. 이는 과거의 프로그래머들에 의해 잘 계획된 구조와 체계의 유형과 문제 분류를 교육합니다. 좋은 코드를 만드는 것은 창의력의 문제이지만, 그 창의력이 더 복잡한 구조와 체계에서 작동하며, 과거에 다른 사람들이 잘 계획한 것들을 이용한다면, 엄청난 힘이 됩니다.\n\n나는 코드를 작성하는 데에 특별히 전념하지는 않지만, 주로 계산 소프트웨어를 사용하여 무척 뛰어난 방식으로 \"프로그래밍\"하는 라인들을 사용합니다. 물론, 대학에서 가르쳐준 것이 매우 유용했기 때문에 처음부터 쓰는 것이 아니라 모든 것을 더 효율적으로 만드는 순차적인 구조를 사용합니다.\n\n\n\n좋은 프로그래머가 되는 데에는 개인적인 기술이 필요하지만, 수십 년 동안 다른 사람들이 개발한 구조를 활용하여 자신의 재능을 향상시키는 것은 명백한 이점이 있어요!\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 이 포스트를 나가기 전에:\n\n- 반드시 체리와 작가를 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 컨텐츠를 처리해야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io 에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png"},"coverImage":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png","tag":["Tech"],"readingTime":3},{"title":"Fetch API CORS 및 no-cors에 대한 궁극의 가이드","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png\" /\u003e\n\n웹 애플리케이션에서 제3자 API 또는 서버에서 데이터를 가져와야 하는 경우가 있나요? 그렇다면, 요청한 데이터에 액세스하는 데 방해가 되는 Cross-Origin Resource Sharing (CORS) 오류를 만날 수도 있습니다.\n\n이 블로그 포스트에서는 Fetch API에서 CORS 및 No-CORS 모드를 사용하여 이러한 제약을 극복하고 외부 소스에서 데이터를 성공적으로 가져오는 방법을 살펴볼 것입니다.\n\n먼저, CORS가 무엇이며 왜 중요한지 이해해 봅시다.\n\n\n\n\n그러나 웹 애플리케이션에서 제3자 API 또는 서버로 요청을 보내야 할 때는 장애가 될 수도 있습니다.\n\n![image](/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_1.png)\n\nFetch API는 웹 애플리케이션에서 HTTP 요청을 보내는 방법을 제공합니다. Fetch를 사용하면 fetch() 함수의 mode 옵션을 사용하여 요청의 모드를 지정할 수 있습니다.\n\nmode 옵션은 `cors`, `no-cors`, `same-origin`, 또는 `navigate` 중 하나로 설정할 수 있습니다.\n\n\n\n`cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하며, 서버가 허용 여부를 나타내는 Access-Control-Allow-Origin 헤더로 응답할 것을 기대합니다.\n\n서버가 적절한 헤더로 응답하면, 브라우저는 요청을 계속 진행하도록 허용하고 응답을 웹 페이지에 제공합니다. 이 모드는 제3자 API나 서버에 요청을 보낼 때 유용합니다.\n\n```js\nfetch('https://example.com/api/data', {\n  mode: 'cors',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    key1: 'value1',\n    key2: 'value2'\n  })\n})\n.then(response =\u003e response.json())\n.then(data =\u003e console.log(data))\n.catch(error =\u003e console.error(error));\n```\n\n`no-cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하지 않으며, 서버의 응답이 불투명하게 처리되어 JavaScript 코드로 액세스할 수 없습니다. 이 모드는 서버로부터의 응답이 필요하지 않은 경우, 예를 들어 제3자 애널리틱스 서비스에 요청을 보낼 때 사용됩니다.\n\n\n\n이제 Fetch API에서 CORS 및 No-CORS 모드를 사용하는 방법을 이해했으므로, 언제 사용해야 하는지에 대해 이야기해보겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"},"coverImage":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png","tag":["Tech"],"readingTime":2}],"page":"36","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"36"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>