<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/81" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/81" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="m3u 및 m3u8 재생목록 재생을 위한 온라인 비디오 플레이어 만들기" href="/post/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="m3u 및 m3u8 재생목록 재생을 위한 온라인 비디오 플레이어 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="m3u 및 m3u8 재생목록 재생을 위한 온라인 비디오 플레이어 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">m3u 및 m3u8 재생목록 재생을 위한 온라인 비디오 플레이어 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Google I O 2024에서 Jetpack Compose의 새로운 소식" href="/post/2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Google I O 2024에서 Jetpack Compose의 새로운 소식" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Google I O 2024에서 Jetpack Compose의 새로운 소식" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Google I O 2024에서 Jetpack Compose의 새로운 소식</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Pulumi 대 비교 IaC 도구 선택을 위한 확실한 안내" href="/post/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Pulumi 대 비교 IaC 도구 선택을 위한 확실한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Pulumi 대 비교 IaC 도구 선택을 위한 확실한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Pulumi 대 비교 IaC 도구 선택을 위한 확실한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="올라마와 오픈 웹 UI를 쿠버네티스에 배포하기" href="/post/2024-05-16-DeployingOllamaandOpenWebUIonKubernetes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="올라마와 오픈 웹 UI를 쿠버네티스에 배포하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-DeployingOllamaandOpenWebUIonKubernetes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="올라마와 오픈 웹 UI를 쿠버네티스에 배포하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">올라마와 오픈 웹 UI를 쿠버네티스에 배포하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기" href="/post/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SSL 문제와 Databricks Connect" href="/post/2024-05-16-SSLIssueswithDatabricksConnect"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SSL 문제와 Databricks Connect" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-SSLIssueswithDatabricksConnect_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SSL 문제와 Databricks Connect" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SSL 문제와 Databricks Connect</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS 클라우드에서 Terraform IaC를 사용하여 OPA 예방 통제를 구현하는 방법GitHub Actions 워크플로우 포함" href="/post/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS 클라우드에서 Terraform IaC를 사용하여 OPA 예방 통제를 구현하는 방법GitHub Actions 워크플로우 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS 클라우드에서 Terraform IaC를 사용하여 OPA 예방 통제를 구현하는 방법GitHub Actions 워크플로우 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">AWS 클라우드에서 Terraform IaC를 사용하여 OPA 예방 통제를 구현하는 방법GitHub Actions 워크플로우 포함</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TIC-80 튜토리얼 머신 러닝걱정하지 마세요 이것은 AI의 일부일 뿐입니다  퍼셉트론 학습" href="/post/2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TIC-80 튜토리얼 머신 러닝걱정하지 마세요 이것은 AI의 일부일 뿐입니다  퍼셉트론 학습" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TIC-80 튜토리얼 머신 러닝걱정하지 마세요 이것은 AI의 일부일 뿐입니다  퍼셉트론 학습" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TIC-80 튜토리얼 머신 러닝걱정하지 마세요 이것은 AI의 일부일 뿐입니다  퍼셉트론 학습</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당장 시작할 수 있는 SaaS 아이디어를 소개합니다" href="/post/2024-05-16-SaaSideasthatyoucangetstartedrightaway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당장 시작할 수 있는 SaaS 아이디어를 소개합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-SaaSideasthatyoucangetstartedrightaway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당장 시작할 수 있는 SaaS 아이디어를 소개합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">당장 시작할 수 있는 SaaS 아이디어를 소개합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 숙련된 개발자를 위한 최고의 소프트웨어 아키텍처 코스 5선" href="/post/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 숙련된 개발자를 위한 최고의 소프트웨어 아키텍처 코스 5선" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 숙련된 개발자를 위한 최고의 소프트웨어 아키텍처 코스 5선" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년에 숙련된 개발자를 위한 최고의 소프트웨어 아키텍처 코스 5선</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link posts_-active__YVJEi" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"m3u 및 m3u8 재생목록 재생을 위한 온라인 비디오 플레이어 만들기","description":"","date":"2024-05-16 17:04","slug":"2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback","content":"\n\n저는 m3u 및 m3u8 형식의 재생 목록을 재생할 수 있는 플레이어를 만든 경험을 공유하고 싶어요.\n\n아이디어의 기원\n\n몇 년 전, 축구 중계 시청이 비싼 구독료나 많은 광고로 제한되어 있을 때, 작은 비용으로 다양한 채널을 제공하는 서비스를 사용하기 시작했어요. 해당 서비스는 m3u8 형식의 파일을 제공했죠. iOS에서는 이 형식의 재생 목록을 재생하는 옵션이 제한되어 있었어요: 사용 가능한 앱은 유료이거나 세션 당 여러 차례 보이는 광고로 가득 찼었어요. 또한, 서비스에서 제공한 파일을 파싱할 수 없는 VLC 플레이어 문제도 있었고 OttPlayer는 일시적으로 앱 스토어에서 사라져 있었는데 (지금은 다시 이용 가능해요), 이러한 상황으로 인해 나만의 플레이어를 만들게 되었어요.\n\n첫 번째 버전의 개발\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 개월 동안 플레이어의 첫 번째 버전을 개발했어요. 디자인과 네비게이션은 인기 앱에서 영감을 받았어요. 애플리케이션의 아이콘은 스톡 자원에서 구매하고, 앱 아이콘은 온라인 편집기를 사용하여 만들었어요. iOS의 내장 AVPlayerViewController를 비디오 재생의 기초로 선택했어요. 처음 몇 달 동안 앱은 다운로드 숫자가 적었지만, 아시아 블로거가 자신의 텔레그램 채널에서 언급한 후 상황이 바뀌었어요.\n\n![이미지](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_0.png)\n\n개선사항과 새로운 기능\n\n이후에 플레이리스트 작업을 위한 많은 기능이 추가되었어요. 검색, 편집, 링크 기반로딩을 포함해서 말이에요. 하지만 이는 다운로드의 큰 증가로 이어지지 않았어요. 그래서 사용자 정의와 비디오 로딩/버퍼링 추적에 관한 문제점을 해결하여 플레이어를 개선하기로 결정했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기존 AVPlayer를 기반으로 한 향상된 플레이어가 만들어졌으며 전체 화면 모드, AirPlay 기능 및 화면 내 화면 모드를 지원합니다. 새 버전은 앱의 안정성을 향상시키고 비디오 로딩 상태를 추적하거나 플레이어에 새 기능을 추가하는 문제를 해결했습니다. 이 라이브러리는 MIT 라이선스 하에 링크를 통해 사용할 수 있습니다.\n\n사용자 정의 플레이어 버전으로 전환한 후, 안정성 비율(크래시 없음)이 95%로 감소했습니다. 스택 추적을 분석해도 명확한 해결책을 제시하지 않았고, 에러를 내 기기에서 재현할 수 없었습니다. 로딩 프로세스를 추적하기 위해 KVO를 사용한 부분에 의심이 생겼습니다. KVO 구독의 존재를 기록하는 변수를 추가함으로써 문제를 해결했습니다. 이는 구독해지 프로세스를 적절히 관리할 수 있도록 했습니다. 이 핫픽스를 구현하면 크래시가 완전히 없어졌습니다.\n\n형식 지원 확장\n\nAVPlayer는 다양한 비디오 형식을 지원하지 않습니다. 이로 인해 일부 채널에서는 재생되지 않거나 다른 채널은 오디오는 있지만 비디오가 없는 경우가 있습니다. 이 문제에 대한 해결책을 찾는 과정에서 LGPLv2.1 라이선스 하에 배포되는 오픈 소스 VLC 플레이어를 찾았습니다. 이 라이선스로 인해 소프트웨어 상에서 라이브러리를 사용할 수 있지만 해당 변경 사항이 있을 경우 라이브러리를 오픈해야 하는 제약이 있음을 이해하는 데 시간이 걸렸습니다. 이에 반해 GPLv2는 모든 코드를 동일한 라이선스 하에 공개해야 하지만 해당 변경 사항을 공개해야 하는 요구는 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVLCKit 통합에 관한 이슈입니다. VLCKit은 Cocoapods와 Carthage를 통해 설치가 가능하지만, 제 프로젝트는 Swift Package Manager (SPM)를 사용하고 있습니다. GitHub에서 VLCKit을 SPM용으로 패키징한 저장소를 발견했지만, 최신 버전의 라이브러리를 포함하고 있지 않았습니다. 그래서 포크를 생성하고 VLCKit을 최신 버전으로 업데이트했습니다.\n\n이제는 라이브러리를 프로젝트에 통합하는 일만 남았습니다. 구독을 통해 별도의 향상된 플레이어를 개발 및 판매하려는 아이디어가 있었지만, VLCKit은 PIP(화면 내 화면) 기능을 지원하지 않았고, AirPlay 기능도 오디오만 전송했습니다. 결과적으로 AVPlayer를 기반으로 한 플레이어를 사용하여 링크를 열기로 결정했습니다. 재생이 실패하거나 비디오 스트림이 누락된 경우에는 VLCKit이 도움을 줍니다. 만약 VLCKit도 실패한다면 사용자에게 채널을 이용할 수 없다는 안내가 제공됩니다. VLC 지원을 한 라이브러리는 여기에서 이용 가능합니다.\n\n일부 수치\n\n앱의 대부분 사용자는 중국과 러시아에 있지만, 지난 달 미국의 다운로드가 크게 증가했습니다. 트래픽 유입에 투자하지 않았습니다. 지역화 전략과 사용자가 리뷰를 남길 수 있는 새로운 기능 도입이 특히 효과적이었습니다. 피드백 수집을 위해 앱 내평가 시스템을 사용하고 있지만, 대부분의 사용자가 텍스트 리뷰 대신 앱에 평가를 내리고 있습니다. 앞으로 사용자들이 적극적으로 리뷰를 작성하도록 유도하는 매커니즘을 개발해야 하며, 이는 앱 스토어에서 앱의 가시성 향상에 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image1](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_1.png)\n\n![image2](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_2.png)\n\n![image3](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_3.png)\n\n![image4](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMonetization\n\n저는 AdMob에서 세 가지 유형의 광고를 실험해 보았습니다: 피드에 통합된 네이티브 광고, 인터스티셜 광고 및 앱 오픈 광고입니다. 처음에는 네이티브 광고를 사용했지만 수익은 미미했습니다. 그런 다음 앱 오픈 광고로 전환했는데, 지표가 약간 향상되었지만 여전히 기대에 못 미쳤습니다. 마지막으로 사용한 것은 인터스티셜 광고였습니다. 앱 오픈 광고가 앱 시작 시 표시되는 용도라는 것을 고려하면 이상적이지는 않지만, 그들의 eCPM은 상당히 높았습니다. 현재 앱을 열 때 3시간마다 한 번 광고가 표시됩니다.\n\n![이미지](/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_5.png)\n\n프로젝트 개발을 위한 계획은 무엇입니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 플랜은 온보딩을 추가하는 것입니다. 이를 통해 인터넷에서 재생 목록을 검색하는 방법을 설명하고, 가능하다면 비디오를 통해 시연할 것입니다. 애플의 가이드라인에 따라 비디오가 거절될 수 있지만 시도해 볼 가치가 있습니다. 추가로 비디오 재생을 멈추는 타이머가 도입되고, 화면 방향 잠금 기능도 추가될 예정입니다.\n\n여기까지 입니다. 주목해 주셔서 감사합니다!\n\nPS: 앱 링크입니다.","ogImage":{"url":"/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_0.png"},"coverImage":"/assets/img/2024-05-16-CreatinganOnlineVideoPlayerform3uandm3u8PlaylistPlayback_0.png","tag":["Tech"],"readingTime":4},{"title":"Google I O 2024에서 Jetpack Compose의 새로운 소식","description":"","date":"2024-05-16 17:03","slug":"2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024","content":"\n\nGoogle I/O 2024에서는 특히 Jetpack Compose를 활용한 UI 개발 영역에서 개발자들을 위한 중요한 진전 사항이 소개되었습니다. 최신 업데이트를 자세히 살펴보고, 개발 경험을 향상시키는 방법을 탐색해 보겠습니다.\n\n![](/assets/img/2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024_0.png)\n\n## Compose Multiplatform: 하나의 코드베이스, 다중 플랫폼\n\nJetpack Compose는 macOS 및 웹 플랫폼을 지원하는 능력을 확장했습니다. 이 발전을 통해 개발자들은 공유 코드베이스를 유지하고, 개발 프로세스를 간소화하며, 다양한 장치에서 일관된 경험을 보장할 수 있습니다. 한 번 작성하고 여러 플랫폼에 배포하는 능력은 개발 시간과 노력을 줄이면서 높은 품질의 사용자 경험을 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 안드로이드, macOS 및 웹에서 작동하는 Jetpack Compose UI의 간단한 예제입니다:\n\n```js\nimport androidx.compose.desktop.ui.tooling.preview.Preview\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.window.singleWindowApplication\n\n@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}\n\n@Preview\n@Composable\nfun GreetingPreview() {\n    Greeting(\"Compose\")\n}\n\nfun main() = singleWindowApplication {\n    Greeting(\"World\")\n}\n```\n\n## Compose Material 3: 디자인 현대화\n\n최신 Material Design 가이드라인과 일치하는 Compose Material 3는 UI 구성 요소에 현대화된 접근 방식을 소개합니다. 이 업데이트는 시각적 매력을 강화하고 새로운 디자인 요소를 통합하여 앱이 디자인 트렌드와 함께 유지되도록 보장합니다. Material 3는 보다 유연성이 향상되고 새로운 테마 옵션을 제공하여 더 다이나믹하고 표현력 있는 UI를 구현할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport androidx.compose.material3.*\n\n@Composable\nfun Material3ThemeExample() {\n    MaterialTheme {\n        Surface(color = MaterialTheme.colorScheme.background) {\n            Text(text = \"Hello Material 3!\", style = MaterialTheme.typography.h4)\n        }\n    }\n}\n```\n\n## Compose 컴파일러를 통한 향상된 성능\n\nJetpack Compose 컴파일러는 상당한 성능 향상을 이룩했습니다. 더 효율적인 코드 작성을 가능하게 하는 새로운 API가 도입되었고, 오버헤드를 줄이고 개발 과정을 최적화합니다. 이는 더 부드러운 애니메이션과 빠른 UI 렌더링으로 이어지며, 궁극적으로 더 나은 사용자 경험을 제공합니다.\n\n효율적인 목록 렌더링을 위해 LazyColumn 사용하기: \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\n\n@Composable\nfun NamesList(names: List\u003cString\u003e) {\n    LazyColumn {\n        items(names) { name -\u003e\n            Text(text = name)\n        }\n    }\n}\n```\n\n## 접근성 향상: 포용적 디자인\n\n접근성은 앱 개발의 중요한 측면이었고, Jetpack Compose는 이를 더욱 발전시키고 있습니다. 새로 도입된 도구와 기능은 개발자들이 더 접근성이 뛰어난 앱을 만들 수 있도록 설계되었습니다. 이에는 더 나은 스크린 리더 지원, 향상된 포커스 관리 및 모든 사용자에게 앱을 사용할 수 있게 하는 기타 기능이 포함되어 있습니다.\n\n접근성을 위해 Modifier.semantics 사용하기:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.semantics.Role\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun AccessibleButton(onClick: () -\u003e Unit) {\n    Text(\n        text = \"Click Me\",\n        modifier = Modifier\n            .padding(16.dp)\n            .clickable(onClick = onClick, role = Role.Button)\n            .semantics { contentDescription = \"Click Me Button\" }\n    )\n}\n```\n\n# 결론\n\n젯팩 콤포즈는 플랫폼 지원을 확대하고 최신 디자인 원칙과 일치시키며 성능을 향상시키고 접근성을 우선시하여 UI 개발을 혁신하고 있습니다. 이러한 업데이트는 개발 프로세스를 간소화할 뿐만 아니라 응용 프로그램이 모든 기기에서 아름답고 기능적인 모습을 유지하도록 보장합니다.\n\n이러한 새로운 기능을 활용함으로써, 개발자들은 사용자를 기쁘게 하는 혁신적인 응용 프로그램을 만들어 경쟁적인 시장에서 두드러지게 할 수 있습니다. 더 많은 업데이트를 기대하고 이러한 새로운 능력을 실험하여 앱 개발 게임을 한 단계 높여보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 자세한 정보는 공식 Google Developers 블로그를 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024_0.png"},"coverImage":"/assets/img/2024-05-16-WhatsNewinJetpackComposeatGoogleIO2024_0.png","tag":["Tech"],"readingTime":4},{"title":"Pulumi 대 비교 IaC 도구 선택을 위한 확실한 안내","description":"","date":"2024-05-16 16:58","slug":"2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool","content":"\n\n\u003cimg src=\"/assets/img/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png\" /\u003e\n\n클라우드 네이티브 시대에는 인프라스트럭처를 코드로 관리하는 것이 클라우드 인프라 관리의 표준으로 자리 잡았습니다.\n\n테라폼은 거의 10년째 사용되어오던 클라우드에 중립적인 옵션으로 서비스되어 왔으며 경쟁사들이 등장하기 전까지 독보적인 위치에 있었습니다. 지금은 AWS CDK, Terraform용 CDK 그리고 상대적으로 새로운 Pulumi와 같은 다양한 옵션이 존재합니다.\n\n다만 다양한 선택지가 있다는 것은 결정하는 과정이 어렵다는 것을 의미하지는 않습니다. 오히려 이로 인해 결정 과정이 복잡해 질 수도 있습니다. 모든 옵션을 탐색하고 정보를 수집하여 결정을 내리기 위해서는 몇 일, 아니면 몇 주가 걸릴 수도 있습니다. 그러나 빠른 클라우드 네이티브/데브옵스 시대에는 모두가 그러한 여유가 없다는 점을 잊지 말아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n걱정하지 마세요: 이 블로그에서는 Pulumi 대 Terraform에 대해 심층적으로 살펴보겠습니다 (그리고 AWS CDK/CDK for Terraform 메커니즘에 대해 약간 언급할 거예요). 비교 차트, 의사 결정 트리, 몇 가지 팁과 FAQ도 포함할 거에요 (TL;DR: 마지막 두 섹션으로 건너뛰세요) - 일에 적합한 올바른 도구를 선택하는 데 도움이 될거에요.\n\n더 이상의 변들겋 없이, 시작합시다.\n\n# 1. 테라폼\n\nIaC 도구에 대해 이야기하고 있기 때문에 테라폼을 우회할 수 없어요. 왜냐하면 이 도구가 가장 오랜 역사를 가지고 있기 때문이에요. 네, (예: AWS CloudFormation)과 같이 더 오랜 역사를 가진 클라우드 특화 솔루션이 있을 수 있지만, 클라우드에 중립적이 아닌 것들이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, Pulumi에 대해 언급하기 전에 먼저 Terraform을 살펴보겠습니다.\n\n## 1.1. Terraform의 간단한 역사\n\nHashiCorp에서 2014년에 처음 출시된 Terraform은 2016년과 2017년에 매우 많은 흥미를 끌기 시작했습니다. 이 기간 동안 기본적으로 모든 데브옵스 엔지니어들이 테스트해 보려고 했거나 적어도 이에 대해 이야기했습니다.\n\n2021년에 처음으로 출시된 generally available 버전인 v1.0 이후에 이르기까지, 특히 2017년부터 2019년 사이의 v0.11 및 v0.12와 같은 이전 버전들은 이미 다른 비즈니스 분야의 여러 기업들에 의해 크게 수용되었으며 개발 환경뿐만 아니라 프로덕션 환경에서도 널리 사용되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모든 역사가 의미하는 바는, 우리가 테라폼에 대해 어느 정도의 확신을 갖을 수 있다는 것입니다: 테라폼은 실제 프로덕션 환경에서 오랜 기간 테스트되었으며 그와 같이 입증된 성과가 있으므로, 다른 대안들을 시도해본 적이 없거나 시간이 부족하더라도 테라폼으로 잘못 갈 수 없습니다.\n\n## 1.2. 테라폼의 내부 동작\n\n테라폼 (물론 다른 모든 IaC 도구들도 마찬가지지만)을 더 잘 이해하기 위해, 다음으로 테라폼이 어떻게 작동하는지 확인해보겠습니다: 핵심 플러그인 아키텍처입니다.\n\n간단히 말하면, 핵심은 상태 기계입니다. 이는 인프라 수명주기를 관리하며 현재 인프라 상태와 선언적 코드로 정의된 원하는 상태를 비교한 다음, 해당 인프라를 선언적으로 정의된 상태로 가져오기 위해 변경/작업을 수행할 계획을 세우는 방식으로 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 변경 또는 조작 작업은 플러그인(또는 프로바이더라고도 부르는 것이 동일한 개념)에 의해 수행됩니다. 코어는 플러그인과 소통하여 주어진 상태에서 무엇을 해야 하는지 알려줍니다.\n\n요약하면, 코어는 상태를 관리하고, 플러그인은 작업을 수행합니다. 기본적으로 이것이 모든 IaC 도구가 작동하는 방식입니다: 상태를 관리해야하며, 클라우드 인프라를 조작하는 데 필요한 무거운 작업을 수행할 수 있는 것이 필요합니다.\n\nTerraform에 관련된 몇 가지 추가 정보를 언급하면, 대부분의 플러그인은 Golang으로 구현됩니다 (Terraform의 코어-플러그인 프레임워크를 통해 다른 프로그래밍 언어로 작성된 플러그인을 사용할 수 있지만), 따라서 플러그인은 클라우드 Go SDK가 필요합니다. 이를 통해 실제로 CRUD 작업을 수행할 수 있습니다.\n\n이러한 세부 정보가 약간 복잡해 보인다면 걱정하지 마세요: Terraform 사용자로서(개발자/기여자가 아닌) 우리는 플러그인 구현에 대해 걱정할 필요가 없습니다. Go 코드를 작성하지 않고 HCL만 작성합니다. HCL을 통해 인프라를 정의하면, 내부적으로 Terraform은 일부 변환 작업을 수행하여 해당 Go 플러그인을 호출하고, 이 플러그인은 다시 클라우드 Go SDK를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1.3. 테라폼 HCL\n\n테라폼에서 인프라를 정의하는 것은 간단합니다: HCL (HashiCorp Configuration Language)이라는 구성 언어로 인프라를 정의합니다.\n\nAWS에 S3 버킷을 만드는 HCL 예제를 살펴보겠습니다:\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-tf-test-bucket\"\n\n  tags = {\n    Name        = \"나의 버킷\"\n    Environment = \"Dev\"\n  }\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 마크업 언어나 마크다운, JSON, YAML 같은 어떤 형식이라도 익숙하다면, 위 구문을 사용하는 것이 너무 낯설지 않을 것이고 HCL이 두 가지 개념을 중심으로 구축되어 있다는 것을 분명히 이해하게 될 것입니다: 블록과 속성. 위의 예시에서:\n\n- 전체 리소스 ... '' 는 리소스를 정의하는 블록이며, 첫 번째 키워드로 나타납니다.\n- aws_s3_bucket은 리소스의 종류이다. AWS 제공업체 문서를 참조하여 지원되는 모든 AWS 리소스 목록을 얻을 수 있다.\n- 예시 부분은 리소스의 이름이다.\n- 블록 안에는 속성이나 이 리소스에 대한 인수인 키-값 쌍이 있습니다. 다시 말하지만, 지원되는 인수, 필수또는 아닌 것들을 알아내기 위해서는 제공업체 문서를 참조해야 합니다.\n\nHCL에 대한 학습곡선은 있지만, 다른 프로그래밍 언어를 배우는 것만큼 가파르지는 않습니다. 왜냐하면 HCL은 그저 설정 목적으로만 사용되는 완전한 프로그래밍 언어가 아니기 때문입니다. 이것은 당신의 철학적 성향에 따라 장단점이 될 수 있습니다:\n\n- 한편, 완전한 프로그래밍 언어가 아니라 간단한 설정 언어일 뿐이기 때문에, 큰 혜택을 가져옵니다: 이는 사실상 키-값 쌍으로 구성되어 있어서 아주 직관적이고 사람이 읽기에 편리합니다.\n- 반면에, 그 간단함으로 인해 루프나 분기 같은 복잡한 작업을 반복적으로 수행하기 어려울 수 있습니다 (특별 구문으로 이러한 것들을 달성할 수 있지만, 파이썬 같은 실제 프로그래밍 언어에서 사용하는 ... 또는 if/else와 같이 글로 쓰는 것만큼 간단하지는 않다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 IaC 도구 Terraform은 어느 정도 중간 난이도의 학습 곡선과 제약 사항을 가지고 있습니다 (HCL 때문에 양: 배워야 하며, 인프라를 정의해야 합니다). 이러한 상황을 개선하기 위해 많은 다른 IaC 도구가 등장했습니다. 계속해서 읽어보세요.\n\n## 2. Pulumi\n\n이전 섹션에서 언급했듯이, Terraform은 완벽하지 않습니다. 이러한 문제를 해결하기 위해 많은 도구가 등장했으며, Pulumi는 최근 시도 중 하나입니다.\n\nPulumi란 무엇일까요? 간단히 말해, 이것은 Terraform과 마찬가지로 IaC 도구입니다. 하지만 Terraform이 특정 구문인 HCL을 사용하는 반면, Pulumi는 거의 모든 프로그래밍 언어를 사용하여 인프라를 정의할 수 있도록 허용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이를 말하기에 극도로 정확하지는 않고 큰 저평가일 것이라는 것을 알고 있지만, 한 문장으로 Pulumi가 무엇인지 배우고 싶은 초보자들을 위해 간단히 설명하자면: Pulumi는 한 마디로 말하면 Python/Go/Java/Node.js 등에서의 Terraform이라고 볼 수 있어요.\n\n## 2.1. Pulumi의 간단한 역사\n\nPulumi는 2018년 처음 오픈 소스로 공개되었는데, 그리 새로운 것은 아니지만 현재의 버전인 v3는 이전 버전과 비교해 몇 가지 중요한 변경 사항이 있는데요, 이는 2021년에 출시되었고, 그 이후로 사람들이 이를 이전보다 훨씬 더 많이 주목하기 시작했습니다 (믿지 못하겠다면 구글 트렌드를 확인해보세요.)\n\n오늘날에는 Terraform과 비교할 때, Pulumi는 구글 검색 결과에서 훨씬 더 적은 관심을 끌고 있습니다. Pulumi의 블로그에 따르면, 2023년에 고객 수가 2000명 미만으로, 이는 Terraform의 주문량보다 훨씬 적다고 합니다 (인터넷의 여러 데이터 소스에 따르면.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, 이 프로그램은 새로운 기술로 널리 받아들여지진 않아요. 그럼에도 불구하고 Pulumi를 선택한 이유는 무엇일까요? 그 이유는 바로 Pulumi가 가진 강력한 기능 때문입니다: 다중 언어 지원입니다.\n\n## 2.2. Pulumi: 다중 언어 지원\n\n만약 Terraform을 선택한다면, HCL을 작성해야 합니다. 많은 사람들에게는 부담스러울 수 있습니다.\n\n예를 들어, 주로 Go로 프로그램을 작성하고 가끔 클라우드 인프라를 관리하는 백엔드 엔지니어들은, 인프라를 Go로 정의할 수 있는 상황에서 왜 HCL을 배워야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 및 풀스택 엔지니어들도 JavaScript/TypeScript로 주로 코딩하는 경우가 많은데, 이미 사용 중인 기술에 HCL을 배우는 것은 부담이 될 수도 있을 뿐만 아니라 기술 스택을 복잡하게 만드는 요인이 됩니다. 보통 기술 스택을 고려할 때는 더 많이 사용하는 것보다는 오히려 덜 사용하는 것이 더 나을 때가 많습니다.\n\nPulumi에서는 이야기가 달라집니다. 다음 중 하나의 언어로 인프라를 정의할 수 있습니다:\n\n- TypeScript (Node.js)\n- Python\n- C#, VB, F# (.NET)\n- Go\n- Java\n- YAML\n\n예를 들어, 이전 섹션에서 언급된 AWS S3 버킷을 Pulumi를 사용해 Python으로 작성하려면 간단히 다음과 같이 작성하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport pulumi\nimport pulumi_aws as aws\n\nbucket = aws.s3.Bucket(\"bucket\",\n    acl=\"private\",\n    tags={\n        \"Environment\": \"Dev\",\n        \"Name\": \"My bucket\",\n    })\n```\n\n혹은 파이썬이 익숙치 않고 TypeScript로 작성하고 싶다면:\n\n```js\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst bucket = new aws.s3.Bucket(\"bucket\", {\n    acl: \"private\",\n    tags: {\n        Environment: \"Dev\",\n        Name: \"My bucket\",\n    },\n});\n```\n\n여기 완성!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.3. Pulumi의 내부 동작\n\n요약하자면, Pulumi는 Terraform과 동일한 방식으로 작동합니다: 두 도구 모두 언급한 코어 플러그인 아키텍처를 갖고 있습니다.\n\nTerraform과 마찬가지로, Pulumi도 내부적으로 클라우드 SDK 및 라이브러리를 사용합니다. Pulumi는 플러그인 자체가 여러 언어로 구현되어 있기 때문에 여러 언어를 지원합니다. 예를 들어, 여기서 Pulumi의 AWS 프로바이더를 보면, 서로 다른 언어로 여러 구현이 있음을 볼 수 있습니다. 이런 이유로 Python으로 인프라를 정의할 때는 `import pulumi_aws as aws`와 같이 사용하고, TypeScript로 사용할 때는 Node.js용으로 전혀 다른 패키지를 사용합니다: `import * as aws from \"@pulumi/aws\";`.\n\n언급할 가치가 있는 것은 AWS Cloud Development Kit (AWS CDK) 및 CDK for Terraform (CDKTF)와 같이 여러 언어로 인프라 코드를 정의할 수 있는 다른 옵션이 있지만, 본질적으로, 이러한 다중 언어 지원은 완전히 다른 방법으로 구현됩니다: AWS CDK와 CDKTF는 어떤 언어의 코드도 JavaScript 클래스와 자연스럽게 상호 작용할 수 있도록 하는 라이브러리 jsii에 의존합니다. 따라서 AWS CDK (그리고 CDKTF)는 TypeScript 코드를 다양한 언어로 변환하여 다국어 (여러 언어를 지원하는 것을 가리키는 어려운 용어입니다)를 지원하도록 하는 jsii를 사용하지만, Pulumi는 내부적으로 다양한 언어로 작성된 이러한 프로바이더만 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. Pulumi 대 Terraform: 주요 유사점과 차이점\n\n## 3.1. Pulumi와 Terraform의 주요 유사점\n\n가장 큰 유사점은 작동 방식인 코어 플러그인 아키텍처입니다.\n\n우선, 핵심은, 혹은 다른 말로 하면, 실제로 상태입니다. 두 도구 모두 상태를 유지하기 위해 핵심을 사용하여 현재 인프라 및 코드로 정의된 내용에 따라 상태를 계산할 수 있도록 하고, 인프라를 정의된 상태로 가져오기 위한 연산 계획을 생성하는 데 사용합니다. 그리고 두 도구 모두 상태를 로컬, S3 버킷, 또는 클라우드/SaaS 솔루션 등 다양한 위치에 저장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째로, 플러그인을 사용합니다. 앞에서 언급했듯이, 둘 다 상태를 관리하고 변경을 수행하기 위해 핵심 플러그인 아키텍처를 사용합니다.\n\n## 3.2. Pulumi와 Terraform의 주요 차이점\n\n가장 큰 차이는 물론 다중 언어 지원입니다.\n\nTerraform은 HCL을 사용하는데, 이는 완전한 프로그래밍 언어가 아니라 구성 언어에 불과합니다. 그러므로 본질적으로 다른 프로그래밍 언어들이 할 수 있는 것들을 모두 할 수는 없지만, 앞에서 언급한 바와 같이, 이는 당신에게 좋은 점일 수 있습니다. 왜냐하면 읽기 쉽고 간단한 것이 더 나은 경우가 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPulumi는 다양한 언어를 지원하며 이것은 단연 가장 중요한 차이점입니다. 어떤 이유로든 Python/Go/Java 또는 다른 주요 프로그래밍 언어로 인프라를 정의해야하는 경우, Terraform와 Pulumi 사이에는 경쟁이 없습니다.\n\n언급할 가치가 있는 또 다른 차이점은 Pulumi를 사용하여 인프라 코드를 테스트할 수 있는 점입니다. Pulumi를 사용하면 프로그래밍 언어와 함께 제공되는 단위 테스트 및 기능 테스트와 도구를 활용할 수 있습니다. 반면 Terraform에서는 테스트를 실행하는 방법이 주로 통합 테스트로 제한됩니다.\n\n물론 Terraform과 Pulumi 사이에는 다양한 미세한 기능 차이가 있습니다 (Pulumi의 공식 문서가 수십 개 이상을 찾는 데 놀라지 마세요), 하지만 이들은 실제로 결정적인 요인이 되지는 않습니다. 예를 들어, 오픈 소스 라이선스나 상태의 기본 구성이 가장 우선시해야 할 목록 상단에 있지는 않을 것입니다.\n\n# 4. Pulumi에 대한 오해들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 블로그를 읽고 계신다면, 아마도 Pulumi 대 Terraform에 관한 첫 번째 글은 아니실 것입니다. 아마도 조사를 많이 해보셨고 이에 대한 장단점을 많이 읽으신 것 같습니다.\n\n그러나 다른 많은 기사들에서 언급된 Pulumi에 관한 몇 가지 흔히 언급되는 단점들이 실제로 오해되었거나 더 이상 사실이 아닌 것들이 있다고 생각합니다. 저는 그것들을 다루어서 Pulumi에 대해 공정하고 정확한 시각을 얻을 수 있도록 하고 싶습니다. 이것은 중요해서 별도의 챕터를 할당해야할 만큼 중요합니다.\n\n## 4.1. 오해 1: Pulumi 문서 부족\n\n이제는 사실이 아닙니다 (아마도 처음 시작했을 때 그랬을 수도 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPulumi는 설치 방법과 시작하는 방법에 대한 매우 상세하고 단계별 설명서가 있어요. 더 깊이 알고 싶다면, Pulumi의 핵심 개념에 대한 훌륭한 섹션이 있어요. 게다가 Pulumi는 여러 클라우드 제공 업체에 대한 상세한 문서와 예제를 제공해요.\n\n플러그인/제공업체에 대해서 특정 제공업체를 검색하면, AWS와 같은 인기 있는 업체 또는 PagerDuty Pulumi 제공업체와 같은 인기 없는 업체와 비교하여 Terraform의 문서와 비교하면 \"Pulumi 문서가 부족하다\"는 결론에 도달하지 않을 거예요.  \n\n## 4.2. 오해 2: Pulumi 커뮤니티가 작다\n\n더 이상 사실이 아니에요, 다시 말해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPulumi의 공식 블로그에 따르면, 2000명의 고객과 15만 명의 최종 사용자가 있습니다. GitHub에 따르면, 주요 리포 pulumi/pulumi만 1.8만 개 이상의 스타를 받았으며, 1.9천개의 이슈와 184개의 오픈된 풀 리퀘스트가 있습니다.\n\n어떤 지표를 사용하더라도, 커뮤니티의 크기를 측정하는 기준이 무엇이든, Pulumi의 커뮤니티는 분명히 큽니다. 테라폼보다는 작지만, 절대적인 의미에서는 절대적으로 작은 커뮤니티가 아닙니다.\n\n## 4.3. 오해 3: Pulumi는 모든 상황에 적용할 수 없다\n\n다시 말하지만, 그렇지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 사람들은 Pulumi가 더 최근에 나왔기 때문에 보편적으로 적용되지 않는다고 결론 지을 수 있지만, 실제로는 그렇지 않습니다.\n\n프로그래밍 언어에 대해 이야기할 때, Pulumi는 사실 주요 언어 대부분을 지원합니다.\n\n플러그인 및 프로바이더에 대해 이야기할 때, 새로운 도구일수록 사용 기간이 짧았기 때문에 플러그인이 적을 것으로 생각할 수 있지만, 현실은 이와 일치하지 않습니다. Pulumi는 주요 공개 클라우드 프로바이더를 모두 지원하며, 테라폼과 마찬가지로 팀 및 사용자 관리와 같은 비 클라우드 인프라 관리에서도 넓게 대상으로 합니다.\n\n예를 들어, 대기업에서는 GitHub, PagerDuty, DataDog, Sentry 등과 같은 여러 DevOps 도구를 관리해야 할 수 있습니다. 아마도 이러한 도구들의 사용자/팀/권한을 IaC를 사용하여 관리하고 싶을 수도 있습니다. 이 경우, 이러한 도구들의 플러그인을 검색하면, Pulumi가 테라폼처럼 모두 갖추고 있다는 것에 놀랄 것입니다. 이 도구들은 널리 사용되는 것이 아니라는 점에서도 클라우드와 관련된 기존 플러그인과는 조금 다를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급했듯이, Pulumi/Terraform을 객관적으로 평가하고 \"문서가 부족하다\"거나 \"커뮤니티가 작다\"는 곳에서 읽었기 때문에 Pulumi를 부정적으로 생각하지 않았으면 좋겠어요. \"최신 버전은 보편성이 떨어진다\"고 생각할 필요도 없습니다.\n\n# 5. Pulumi 대 Terraform: 현실에 가까운 비교\n\n이전 섹션에서 Terraform과 Pulumi의 구문과 사용법을 보여주기 위해 몇 가지 코드 조각을 제공했지만, 이 코드들은 현실 세계에서 의미가 있는 것이 아니라 너무 단순하고 \"Hello, World\" 수준이라는 것을 의미합니다. 현실에서는 대부분의 상황이 지수적으로 커지기 때문에 코드를 간단하고 가독성 있게 유지하는 것과 동시에 확장 가능하게 유지하는 것이 어렵다는 것을 의미합니다.\n\n그러므로 다음으로 Pulumi 대 Terraform을 살펴보고 이러한 현실 세계의 도전에 대해 어떻게 다루는지 비교해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5.1. Pulumi 대 Terraform: 코드 구조, 가독성 및 확장성\n\nTerraform의 경우, 모듈을 정의하고 재사용하여 최대한의 코드 재사용성을 달성할 수 있습니다. 전형적인 단일 모놀리식 Terraform 저장소는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── dev\n│   ├── config.tf\n│   ├── main.tf\n│   ├── output.tf\n│   └── variables.tf\n├── modules\n│   ├── module_a\n│   └── module_b\n└── prod\n    ├── config.tf\n    ├── main.tf\n    ├── output.tf\n    └── variables.tf\n```\n\n단일 저장소의 강점은 아주 사람이 읽기 쉽고 설명 없이도 쉽게 이해할 수 있다는 것입니다. 그리고 Terraform의 특성으로 인해 폴더 구조의 두 수준을 가지고 있으며, 최대 세 수준까지, 이 모든 것은 한눈에 전체적인 내용을 파악하기 쉽고 쉽게 관리할 수 있다는 것을 의미합니다. 또한 다른 환경을 생성하는 것은 단순히 동일한 저장소에 \"test\"라는 이름의 추가 폴더를 생성하는 것만큼 복잡하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 깨끗한 코드 기반을 바탕으로 프로젝트가 커질 때 여러 가지 개선 방법이 있습니다: 인프라의 다른 부분을 별도의 리포지토리로 분리; 모듈을 다른 하나 또는 몇 개의 리포지토리로 이동; 다른 환경을 다른 리포지토리로 넣습니다. 모든 선택지는 유연하며 모두 새로운 리포지토리를 생성하여 좀 더 깨끗하고 이해하기 쉬운 디렉터리 구조를 만들어냅니다.\n\nPulumi를 사용하면 상황이 조금 복잡해질 수 있습니다. 전형적인 단일 모놀리식 Pulumi 프로젝트는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── Pulumi.dev.yml\n├── Pulumi.prod.yml\n├── Pulumi.yml\n├── api-gateway\n│   ├── index.ts\n│   └── micro-service-01\n│       └── index.ts\n├── database\n│   └── table-01.ts\n├── index.ts\n├── package-lock.json\n├── package.json\n├── sns\n│   └── topics.ts\n└── queues.ts\n├── pkg\n│   └──application\n│     └── app.go\n└── .etc\n```\n\nTerraform과 유사하게, 프론트엔드 또는 백엔드 프로젝트에서 작업한 것과 마찬가지로 공통적인 내용을 패키지로 묶을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트가 커지면 프로젝트를 별도로 관리되는 작은 프로젝트로 분할하는 '마이크로 스택' 접근 방식을 사용할 수 있습니다. 각 프로젝트는 위에서와 같을 수 있습니다.\n\n그러나 사물이 커지면 디렉토리 구조가 훨씬 더 복잡해지고 디렉토리가 더 많아지며 수준이 더 많아져 혼란스러울 수 있습니다. Java나 여러분이 참여한 실제 프로젝트를 상상해 보세요. 그 프로젝트 전체를 빠르게 이해하기 쉬운가요? 아니죠, 너무 많은 폴더와 수준의 디렉토리가 있어 어느 것이 무엇이며 어디서 시작해야 하는지조차 모를 수 있습니다.\n\nPulumi의 가장 강력한 장점은 다국어 지원이지만, 큰 힘에는 큰 책임이 따릅니다. 코드를 이해하고 유지하는 데 도움이 되는 방식으로 조직화하는 것이 중요합니다. 이는 사용하는 도구에 상관없이 사실입니다.\n\n## 5.2. Pulumi 대 Terraform: 통합\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우 IaC가 끝나면 모든 작업이 끝나는 것은 아닙니다. 인프라 구성 부분은 CI/CD 파이프라인과 같은 다른 요소와 통합되어야 합니다. 다행히도 Terraform과 Pulumi는 변경 사항을 배포하기 위해 한 번의 명령만 필요하므로 통합하기에 이상적입니다. 그러나 차이점이 있습니다.\n\n일부 경우에는 IaC 파이프라인이 시작하기 전에 뭔가를 수행하고 싶을 수 있습니다.\n\n예를 들어 사용자, 팀, 멤버십 및 권한을 관리하기 위해 IaC를 사용하고자 한다고 가정해 봅시다. 새로운 사용자를 추가할 때 코드 베이스를 열어서 복사하여 수정하고 커밋하는 것은 너무 번거롭습니다. 어딘가에 사용자 목록이 저장되어 있고, 해당 파일을 검색하여 일부 템플릿 도구를 사용하여 IaC 코드를 자동으로 생성할 수 있다고 가정해 보겠습니다.\n\n이 경우 Terraform의 경우 추가 도구인 Python 스크립트를 사용하여 파일을 다운로드하고 구문 분석하고 템플릿을 적용한 다음 생성된 IaC 파일을 커밋하고 IaC 파이프라인을 실행하기 전에 수행해야 할 수 있습니다. Pulumi의 경우에는 하나의 패스로 모든 작업을 수행할 수 있기 때문에 상황이 훨씬 간단해질 수 있습니다. 원하는 프로그래밍 언어를 사용하여 파일을 다운로드/구문 분석하고, 동일한 언어를 사용하여 간단한 for 루프를 사용하여 작업을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n적으로 IaC가 완료된 후에 무언가를 수행하고 싶을 수도 있습니다. 예를 들어 IaC 부분의 출력에는 Helm 차트에서 사용하고 싶은 로드 밸런서 URL이 포함될 수 있습니다. 다시 말하지만, Terraform을 사용하면 아마도 스크립트를 실행해야 하는 또 다른 단계가 필요할 것입니다. 그러나 Pulumi를 사용하면 IaC 코드 이후에도 해당 작업을 수행하기 위해 계속 코드 작성을 할 수 있습니다 (여기에 일부 예시가 있습니다).\n\n간단히 말하면, Terraform과 스크립트를 통합하는 데 어려움을 겪고 있다면, Pulumi를 시도해볼 가치가 있을 것입니다.\n\n## 5.3. Pulumi 대 Terraform: 보안\n\n보안은 코드에 항상 중요한 주제이며, 인프라 코드도 마찬가지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 보안을 위해 가장 기본적인 원칙은 아마도 코드 내에서 비밀을 평문으로 저장하지 않는 것입니다. 이 부분에서 Terraform 및 Pulumi가 잘 수행됩니다. Terraform은 다양한 시크릿 매니저와 통합할 수 있고, Pulumi에서도 시크릿 매니저로부터 읽어오는 것이 한 줄의 코드로 쉽습니다. 예를 들어, 여기에 Terraform에서 시크릿을 관리하는 블로그가 있습니다.\n\n코드 보안에 대해 더 말씀드릴 수 있습니다: Terraform을 사용하면 HCL로 작성하며, 구성 코드는 API 호출로 변환되어 리소스를 생성, 읽기, 업데이트 및 삭제합니다. 물론, Terraform 코어 및 플러그인 자체에 보안 문제와 CVE가 있을 수 있지만, 다른 IaC 옵션에 대해 동일한 말을 할 수 있습니다. Pulumi의 경우, IaC 코드를 여러 언어로 작성할 수 있고 더 많은 작업을 수행할 수 있기 때문에 공격 대상이 더욱 확대될 수 있습니다. 이는 Pulumi에 대한 단점으로 보일 수 있지만 다행히도 보안을 강화하기 위한 SAST 및 DAST와 같은 최고의 실천 방법과 도구가 있습니다.\n\nTerraform 및 IaC 보안에 관심이 있다면 여기에 Terraform을 사용한 IaC 보안에 관한 블로그가 있고, 여기에는 Terraform의 일부 모베스트 프랙티스에 대한 블로그가 있습니다 (걱정하지 마세요, 이전에 읽어본 것과는 다를 것입니다).\n\n코드 보안을 제외하고, IaC 도구는 인프라를 관리하며 중요한 정보는 실제로 상태에 저장되기 때문에 상태의 보안도 중요합니다. Terraform 및 Pulumi는 민감한 정보를 상태에 평문으로 인쇄되지 않도록 암호화할 수 있으며, 두 도구 모두 상태를 암호화하여 저장하기 위한 다양한 백엔드를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션 마무리를 위한 몇 가지 권장 사항:\n\n- IaC 도구로 민감한 데이터를 관리하는 경우(데이터베이스 암호, 사용자 암호 또는 개인 키 등), 상태 자체를 민감한 데이터로 취급해야 합니다. 즉,\n- 원격으로 상태를 저장하면 더 나은 보안을 제공할 수 있으므로 상태에 로컬 디스크를 사용하지 않도록 하십시오.\n- 휴식 중인 상태 데이터를 암호화할 수 있는 백엔드를 사용하세요.\n\n# 6. Summary: Choosing Your IaC Tool\n\n## 6.1. Comparison Table\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 표를 통해 각 도구의 주요 기능을 빠르게 비교해 보겠습니다:\n\n![Comparison Table](/assets/img/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_1.png)\n\n## 6.2. IaC 도구 선택하기\n\n더 즐겁게 선택을 할 수 있도록, 다음의 플로우 차트를 만들어 봤어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- IaC를 시작해보려고 합니까? 예: 2번으로 이동. 아니요: 7번으로 이동.\n- 더 적은 것이 더 나은 것이라고 생각합니까? 예: 11번으로 이동. 아니요: 3번으로 이동.\n- DevOps 엔지니어이십니까? 예: 5번으로 이동. 아니요: 4번으로 이동.\n- 가끔 인프라를 관리하는 개발자이십니까? 예: 5번으로 이동. 아니요: 11번으로 이동.\n- 이미 JavaScript/Python/Go/Java로 코딩을 하고 계십니까? 예: 12번으로 이동. 아니요: 6번으로 이동.\n- 새로운 구성 언어를 배우고 싶으십니까? (새 프로그래밍 언어를 배우는 것보다 훨씬 어렵지 않습니다) 예: 11번으로 이동. 아니요: 12번으로 이동.\n- 이미 Terraform을 사용해보신 적이 있습니까? 예: 8번으로 이동. 아니요: 9번으로 이동.\n- Terraform을 사용하며 고민거리가 있습니까? 예를 들어, HCL에 만족스럽지 않거나 더 복잡한 작업을 수행하고 싶은 경우 등? 예: 10번으로 이동. 아니요: 11번으로 이동.\n- Terraform을 시도해보세요.\n- Pulumi를 시도해보세요.\n- Terraform을 계속 사용하세요.\n- 죄송합니다, 둘 다 적합하지 않습니다.\n\n## 6.3. 작업에 적합한 올바른 도구를 선택하는 방법\n\n장난은 좋지만, 올바른 도구를 선택하는 몇 가지 팁을 안내해드릴게요:\n\n- 여전히 앱 코드 작성이 주 업무인데 인프라 코드를 부분적으로 관리해야 한다면 Pulumi가 더 나은 선택이 될 수 있습니다.\n- Terraform에 경험이 있고 불만족스러운 점이 있다면, Pulumi를 사용해보세요. 안심하세요, Terraform이 할 수 있는 중요한 것은 Pulumi로 할 수 없는 게 없습니다.\n- 한 가지 전세되는 도구를 선택할 필요는 없습니다. Pulumi 대 Terraform은 경쟁이 아니에요. 어떤 것이 더 나은지, 어떤 것이 잘못된지 결정해야 한다는 것은 아니에요. 사실 둘 다 사용할 수 있습니다. 프로젝트가 성장하면 단일 인프라 저장소를 관리하기 어려워지고, 마이크로서비스와 같은 프로젝트에서는 각 부분에 적합한 도구를 사용함으로써 최선을 다할 수 있습니다. 올바른 도구를 선택하면 일부 작업을 더 쉽게 수행할 수 있습니다.\n- 직접 체험해보세요. 블로그와 기사를 모두 읽어도 괜찮지만, 마지막으로 두 도구를 간단히 시도해보면 진정한 필요를 알게 될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# FAQ\n\n## Q: Terraform은 오래된 기술인가요?\n\n네/아니요.\n\n네, Terraform은 많은 해동안 사용되어 왔고, 그만큼 자체적인 한계도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, HCL을 사용해야 하는 점을 제외하면, Terraform은 거의 모든 것을 처리하고 잘 다루어냅니다.\n\nTerraform은 이제 CDKTF를 사용할 수 있어 다른 프로그래밍 언어로 인프라를 정의할 수 있다는 점을 언급할 가치가 있습니다.\n\n## 질문: Pulumi가 Terraform보다 나은가요?\n\n그렇고 아니요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 실제로 인프라를 정의하기 위해 다른 프로그래밍 언어를 선택할 수 있습니다.\n\n하지만 전체 프로그래밍 언어로 된 큰 프로젝트는 간단한 구성 언어보다 더 명확하지 않고 읽기 어려울 수 있습니다.\n\n각 도구마다 장점이 있으며 둘 중 어떤 것이 뛰어나다고 말할 수는 없습니다.\n\n## 질문: Pulumi가 Terraform이 할 수 있는 모든 것을 할 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예.\n\n음, 그래 별로. 각각에는 각각의 특징과 장점이 있지만, IaC에 관한 이야기를 할 때 기본적으로 찾는 기능은 두 도구 모두 갖추고 있습니다. Pulumi를 선택한 후 테라폼이 훌륭하게 수행하는 어떤 마법 같은 기능을 할 수 없을 때 곤경에 처하지 않을 것입니다.\n\n## Q: Pulumi의 단점은 무엇인가요?\n\n솔직히 말해서, 아무것도 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당하는 작업을 아주 잘 수행하며, 선택한 프로그래밍 언어로 할 수 있어요. 게다가 문서와 커뮤니티도 친절해요.\n\nPulumi에 대해 조금 꼭 언급하자면, Python, Go 또는 JavaScript로 큰 코드베이스를 관리하는 것은 HCL 형식의 구성 파일 저장소보다 훨씬 까다롭다는 점이죠. 하지만 이 도전을 가져온 건 Pulumi가 아니라 프로그래밍 부분입니다. 또한, HCL을 사용한다고 해서 코드베이스가 자동으로 읽기 쉽고 관리하기 쉬워지는 것은 아니에요. 분명히 혼란스럽게 만들 수 있어요. 결국 깨끗한 코드를 작성하고 유지하는 것은 프로그래머들의 몫이에요.","ogImage":{"url":"/assets/img/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"},"coverImage":"/assets/img/2024-05-16-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png","tag":["Tech"],"readingTime":17},{"title":"올라마와 오픈 웹 UI를 쿠버네티스에 배포하기","description":"","date":"2024-05-16 16:56","slug":"2024-05-16-DeployingOllamaandOpenWebUIonKubernetes","content":"\n\n여러 이유들로 인해 별도의 긴 텍스트 블로그 게시물에서 설명할 것을 계획한 대로, 저는 팀이 AI 모델을 자체 호스팅하고 개발 팀을 더 효율적으로 만들 수 있는지 조사하는 실험을 진행하기로 결정했습니다. 본문에서는 우리 팀을 위해 쿠버네티스에서 Ollama와 Open Web UI를 호스팅하기 위해 구축한 아키텍처에 대해 설명하고, 왜 그것을 선택했는지 설명하겠습니다.\n\n# IDE 플러그인 선택\n\n무언가를 구축하기 전에, Ollama와 양방향 대화 및 코드 자동 완성(FIM)을 모두 지원하는 IDE 플러그인을 찾기를 원했습니다. Cody AI와 Llama Coder를 포함한 여러 옵션을 평가한 후, VS Code에서 저희 개발자들을 위해 Twinny를 선택했습니다. (우리 둘의 IntelliJ 개발자들은 자신들의 선택을 했습니다.)\n\nCody AI는 멋지며, 제 개인 장비에서 사용 중입니다. 팀을 위해, 우리는 라이선스 문제나 구매 부분과의 충돌을 피하기 위해 모든 부분에서 오픈 소스 소프트웨어를 준수하고자 했습니다. Llama Coder는 오픈 소스이며 좋으나, 우리가 시도했을 때는 채팅 기능만 있었습니다. Twinny는 저희가 로컬 테스트 중에도 채팅 및 자동 완성 기능을 둘 다 잘 수행하는 유일한 오픈 소스 IDE 플러그인이었습니다. 플러그인 유지자는 항상 열정적으로 작업하고 문제에 신속히 대응하는 것으로 보여서 우리가 좋아하는 점입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 아키텍처\n\n첫 번째 POC에서는 Open Web UI 도커 컴포즈 파일을 EC2 인스턴스에서 실행하여 테스트했습니다. 초기 POC에서는 작업을 훌륭하게 수행했습니다. UI를 올리고 Twinny를 연결했으며, GPU 드라이버를 올바르게 설치한 후에는 성능이 양호했습니다. 이것이 잘 확장되지 않을 것을 알고 빠르게 모든 것을 쿠버네티스에 구축하는 다음 단계로 넘어갔습니다.\n\n저희는 AWS 회사이므로 이러한 워크로드를 EKS에서 호스팅하기로 결정했습니다. GPU 지원을 위해 EKS 가속화 AMI를 사용하여 Ollama 인스턴스에서 드라이버를 추가하는 작업을 저희를 도와주었습니다. NVIDIA K8s Device Plugin을 실행하는 Daemon Set으로 작동되도록 배포하는 방법은 AWS 문서에 연결된 지침을 따르세요. 클러스터를 설정한 후 아래 명령어를 사용할 수 있습니다.\n\n```js\nkubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.14.5/nvidia-device-plugin.yml\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 ALB 인그레스 컨트롤러를 사용하여 Open Web UI Ingress 주석에서 ALB를 생성했고, Persistent Volumes를 처리하기 위해 EBS CSI 플러그인을 사용했습니다.\n\n노드 그룹에 대해 초기 빌드를 위해 세 개의 노드 그룹을 사용했습니다: Open WebUI 서비스는 GPU가 필요하지 않기 때문에 m5a.large 인스턴스를 사용하는 노드 그룹에서 실행되며, FIM 모델 및 채팅 모델 각각에 대해 g5.2xlarge 인스턴스에서 실행되는 두 개의 별도의 Ollama 노드 그룹을 구축했습니다. GPU 메트릭스를 수집하기 위해 사용자 데이터를 통해 CloudWatch 에이전트를 설치하고 사용 패턴 및 동작을 볼 수 있도록 했습니다.\n\n처음에 이것을 구축할 때 Ollama는 메모리에 로드되지 않은 모델에 대해 사용자가 요청을 보낼 때마다 모델을 언로드 및 재로드하여 사용자가 응답을 받기까지 5-15초의 지연이 발생했습니다. 그러나 Ollama는 그 이후에 한 번에 여러 모델을로드 유지하는 기능을 출시했으나, 우리는 현재는 별도의 모델에 대해 별도의 백엔드를 계속 사용하고 있습니다.\n\n마지막으로, Ollama와 Open WebUI 서비스를 구축하기 위해 각각의 Helm 차트를 사용했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://artifacthub.io/packages/helm/ollama-helm/ollama\n- https://artifacthub.io/packages/helm/open-webui/open-webui\n\n튜닝 섹션에는 서비스가 시작되자마자 최대 성능을 얻기 위해 Helm 값에 포함해야 하는 팁이 포함되어 있습니다.\n\n현재 설정에 대한 아키텍처 다이어그램은 아래에서 확인할 수 있습니다.\n\n![아키텍처 다이어그램](/assets/img/2024-05-16-DeployingOllamaandOpenWebUIonKubernetes_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 섬세한 조정\n\n제품이 좀 더 생산 준비 상태로 설정되어 있으므로 작은 시범 그룹에게 오픈하여 매일 테스트 중입니다. 사용자들이 들어오자, 사용자들에게 응답이나 코드 자동 완성을 받기 전에 지연이 발생한다는 보고를 받기 시작했습니다.\n\nOllama가 한 번에 한 요청에만 응답할 수 있다는 것을 발견했는데, 이는 여러 사람들에게 노출하는 목적을 상쇄시켰습니다. 다행스럽게도 Ollama의 1.34 릴리스에서 OLLAMA_NUM_PARALLEL 옵션이 추가되어 Ollama가 한 번에 여러 요청에 응답할 수 있도록 설정할 수 있게 되었습니다. 이 값을 10으로 설정하고, g5.2xlarge 인스턴스에서 10개의 응답을 동시에 받는 것이 꽤 잘 작동하는 것을 알았습니다. 약간의 속도 저하만 있어요. Ollama 배포가 고사용량 상태에 있을 때 확장하도록 메트릭을 수집하는 작업을 시작했지만, 아직 그 정도로는 못 갔습니다.\n\nOllama Helm 차트에 추가할 수 있는 다른 값은 ollama.models 값입니다. 이를 통해 Ollama 서비스가 호스팅할 모든 모델을 미리 로드할 수 있어서 첫 사용자들에게 시간을 절약할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n이 블로그 글에 대해 더 많은 정보를 추가하고 업데이트할 가능성이 매우 큽니다. 미래에는 시작점으로 사용할 수 있는 몇 가지 샘플 코드를 제공할 예정이지만 거기서 약속을 드릴 수는 없습니다.\n\n의견이나 질문이 있으면 언제든지 0xthresh@proton.me로 연락해주세요. 최대한 빨리 회신 드리겠습니다.\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-16-DeployingOllamaandOpenWebUIonKubernetes_0.png"},"coverImage":"/assets/img/2024-05-16-DeployingOllamaandOpenWebUIonKubernetes_0.png","tag":["Tech"],"readingTime":4},{"title":"도커에서 extra_hosts를 사용하여 DNS 해결 단순화하기","description":"","date":"2024-05-16 16:56","slug":"2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts","content":"\n\n소개: Docker 세계에서는 가장 간단한 작업조차 복잡해질 수 있습니다. 최근 Docker 컨테이너에서 Apache Airflow를 실행하는 중에 귀찮은 문제에 직면했습니다. 우리의 설정은 Airflow를 Azure PostgreSQL 데이터베이스에 연결하는 것을 포함했지만, 때때로 DNS 오류로 인해 작업 흐름이 방해받았습니다. 조사를 통해 Docker의 DNS 캐싱 부족이 문제의 주범임을 알게 되었습니다. 이 게시물에서는 Docker Compose의 extra_hosts 기능을 활용하여 문제를 해결한 방법을 공유하겠습니다. 이를 통해 팀이 불필요한 두통으로부터 구해졌습니다.\n\n문제: Docker 컨테이너는 내장된 DNS 캐싱이 없어 모든 연결 시도에 대해 DNS 해상도에 의존해야 합니다. 이는 가끔 실패로 이어질 수 있으며 특히 네트워크 트래픽이 많은 환경에서 문제가 발생할 수 있습니다. 우리의 경우, 매일 수천 개의 작업을 실행하는 Apache Airflow가 DNS 해상도 문제로 PostgreSQL 데이터베이스에 연결하는 데 어려움을 겪고 있었습니다.\n\n해결책: DNS 해상도 문제에 대처하기 위해 Docker Compose의 extra_hosts 기능을 활용했습니다. 이 편리한 기능을 사용하면 추가 호스트 이름과 IP 주소를 지정하여 DNS 해상도가 전혀 필요하지 않게 됩니다. 호스트 이름을 직접 IP 주소로 매핑함으로써 개인 DNS 서버의 부하를 줄이고 컨테이너 간 안정적인 통신을 보장할 수 있습니다.\n\n구현: 해결책을 구현하는 것은 간단했습니다. PostgreSQL 데이터베이스 호스트 이름과 해당 IP 주소에 대한 extra_hosts 항목을 Docker Compose 구성에 업데이트했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n버전: '3'\n서비스:\n  airflow:\n    이미지: airflow:latest\n    환경:\n     - AIRFLOW__CORE__EXECUTOR=LocalExecutor\n     - AIRFLOW__DATABASE__SQL_ALCHEMY_CONN=postgresql+psycopg2://@myprivatpgsqlserver.postgres.database.azure.com:6432/mydbinstance\n     - AIRFLOW__CORE__LOAD_EXAMPLES=False\n     - AIRFLOW__CORE__LOGGING_LEVEL=INFO\n    extra_hosts:\n     - \"myprivatpgsqlserver.postgres.database.azure.com:192.168.159.84\"\n    # 기타 Airflow 구성...\n\n이 구성에서는:\n\n- airflow 서비스 하위에 extra_hosts 섹션을 추가했습니다.\n\n우리는 myprivatpgsqlserver.postgres.database.azure.com 호스트명 및 해당 IP 주소 192.168.1.100을 지정하여 PostgreSQL 데이터베이스에 대한 연결에 대한 DNS 해결을 우회했습니다.\n","ogImage":{"url":"/assets/img/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts_0.png"},"coverImage":"/assets/img/2024-05-16-SimplifyingDNSResolutioninDockerwithextra_hosts_0.png","tag":["Tech"],"readingTime":2},{"title":"SSL 문제와 Databricks Connect","description":"","date":"2024-05-16 16:55","slug":"2024-05-16-SSLIssueswithDatabricksConnect","content":"\n\n# 문제\n\nWindows 머신의 (회사) 네트워크에서 로컬로 Databricks-Connect를 실행 중이고 사용자 정의 인증서(루트 및 중간)를 사용하고 있다면, 코드를 실행할 때 다음과 유사한 오류가 발생할 수 있습니다:\n\n데이터브릭스-커넥트가 gRPC를 사용하기 때문에(현재 구현체에는) 사용자 정의/회사 인증서에 대해 알지 못합니다. 비록 해당 인증서가 올바르게 로컬 Windows 인증서 저장소에 설치되어 있어도 그렇습니다.\n\n이 문제는 pip/requests나 certifi를 사용할 때 발생하는 SSL 문제와 매우 유사합니다. requests/certifi/pip 주제에 대해 다양한 온라인 포스트를 찾을 수 있습니다. 예를 들어 이것이 있습니다. 해결 방법은 보통 pip-system-certs 또는 (이미 사용되지 않는) python-certifi-win32를 설치하는 것입니다. 그러나 이러한 수정 사항은 Databricks-Connect에서의 gRPC 문제를 해결하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 솔루션\n\n## (1) 회사별 인증서가 포함된 .pem 파일 생성하기\n\n로컬 Windows 인증서 저장소에 모든 관련 회사별 인증서가 설치되어 있다고 가정하고, 다음 파이썬 스크립트를 사용하여 해당 인증서를 추출할 수 있습니다:\n\n```js\nimport ssl\n\ncontext = ssl.create_default_context()\nder_certs = context.get_ca_certs(binary_form=True)\npem_certs = [ssl.DER_cert_to_PEM_cert(der) for der in der_certs]\n\nwith open('wincacerts.pem', 'w') as outfile:\n    for pem in pem_certs:\n        outfile.write(pem + '\\n')\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 Windows 인증서 저장소에 있는 모든 인증서를 포함하는 파일(wincacerts.pem)이 생성됩니다.\n\n이 인증서를 certifi와 함께 제공되는 표준 인증서에 추가하는 것을 제안합니다. 해당 인증서를 찾으려면 다음 명령을 사용하세요:\n\n```python\nimport certifi\n\nprint(certifi.where())\n\n\u003e\u003e\u003e 'd:\\repos\\XXX\\.venv\\lib\\site-packages\\certifi\\cacert.pem'\n```\n\n반환된 위치에서 찾은 파일을 열고 이전에 생성한 파일을 텍스트 편집기에서 열어 cacert.pem의 내용을 wincacerts.pem에 단순 복사하여 붙여넣기합니다. 이 파일 내의 인증서 순서는 중요하지 않습니다. 그 후 저장하고 wincacerts.pem을 Windows 사용자 홈 디렉터리의 임의의 위치로 이동해주세요. 예를 들어:\nC:\\Users\\`사용자명`\\certs\\wincacerts.pem\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 환경 변수를 이용하여 사용자 정의 인증서 참조하기\n\n이제 gRPC에게 사용자 정의 인증서 파일의 위치를 알려주기만 하면 됩니다. 가장 간단한 방법은 환경 변수 GRPC_DEFAULT_SSL_ROOTS_FILE_PATH를 사용하는 것입니다. 이 환경 변수는 VS-Code(특정 프로젝트/터미널용)에서 설정할 수도 있고, - 저는 선호하는 방법인 - 사용자의 Windows 환경 변수에 설정할 수도 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-16-SSLIssueswithDatabricksConnect_0.png\" /\u003e\n\n팁: 새 환경 변수를 설정한 후 모든 열려있는 터미널/셸을 재시작하여 변경 사항을 적용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그게 전부에요!\n\n다음에 Databricks-Connect 코드를 실행할 때 SSL 핸드셰이크 오류가 사라져 있을 거예요.","ogImage":{"url":"/assets/img/2024-05-16-SSLIssueswithDatabricksConnect_0.png"},"coverImage":"/assets/img/2024-05-16-SSLIssueswithDatabricksConnect_0.png","tag":["Tech"],"readingTime":2},{"title":"AWS 클라우드에서 Terraform IaC를 사용하여 OPA 예방 통제를 구현하는 방법GitHub Actions 워크플로우 포함","description":"","date":"2024-05-16 16:53","slug":"2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow","content":"\n\n이 절차에서는 테라폼을 인프라스트럭처-애즈-코드(IaC)로 사용하는 동안 GitHub Actions와 함께 OPA(Open Policy Agent)를 활용한 Policy-as-Code 시프트-레프트 전략을 구현하는 방법을 보여드리고 있습니다.\n\nGitHub Actions는 지속적 통합 및 지속적 전달(CI/CD) 플랫폼으로, 빌드, 테스트, 배포 파이프라인을 자동화할 수 있습니다. 레포지토리로 풀 리퀘스트(PR)를 생성하여 머지된 풀 리퀘스트를 프로덕션으로 배포하는 등의 워크플로우를 생성할 수 있습니다.\n\nOPA는 공개 소스이고 일반용도의 정책 엔진으로, 어떠한 도메인에 대해 정책-애즈-코드를 적용하기 위한 공통 프레임워크를 제공하기 위해 개발되었습니다. OPA는 의사결정과 정책 강제를 분리하는 방식으로 작동합니다. 정책 결정이 필요한 경우 구조화된 데이터(예: JSON)를 입력으로 OPA에 쿼리하면 OPA가 결정을 반환합니다.\n\nOPA 정책은 해당 내용을 나타내는 Terraform 실행을 방지하거나 강제하는 가드레일입니다. 이러한 정책은 버전 컨트롤 시스템(VCS)에 그룹화되어, 해당 사례에서는 GitHub을 통해 GitHub Actions 워크플로우를 사용하여 시행될 수 있습니다. 이러한 정책은 또한 OPA 정책 대상을 특정 자원에 대한 확인을 위해 예외 요건을 정의할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 선행 조건\n\n- 인프라스트럭처를 코드로 배포하는 데 사용되는 Terraform 오픈 소스 소프트웨어.\n- 버전 관리 시스템으로 사용하기 위한 GitHub 계정.\n- 활성화된 AWS 계정.\n\n# 대상 아키텍처\n\n![이미지](/assets/img/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub Actions를 사용하여 코드가 한 환경에서 다른 환경으로 푸시될 때 수행해야 할 작업을 정의하는 Workflow에 사용되었습니다. 예를 들어 사용자가 낮은 환경에서 높은 환경으로 코드를 커밋하기 위해 Pull Request를 올린 경우, \"dev\"에서 \"main\" 브랜치로 예를 들면 코드를 커밋하는 경우, GitHub Actions에서 정의된 CI/CD Workflow가 트리거됩니다. 다이어그램에 표시된 대로, 첫 번째 단계에서 \"Terraform Plan\"이 생성됩니다. \"Terraform Plan\" 출력물은 JSON 형식으로 변환되어 OPA 정책에 대해 확인됩니다. 정책 중 하나라도 실패하면 실행이 실패합니다. 정책 평가가 성공하면 사용자는 \"Terraform Apply\"로 대상 AWS 계정에 필요한 리소스를 생성할 수 있습니다. 리소스가 어떤 OPA 정책에 대해 확인을 건너뛰도록 태그가 지정된 경우, 그러한 리소스에 대해 정책을 평가하지 않습니다.\n\n아래는 Workflow를 트리거하면 GitHub Actions에서 수행되는 단계입니다. CICD 파이프라인에서 발생하는 단계별 과정을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow_1.png)\n\n# 자동화 및 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOPA 정책 검사는 각 리포지토리에서 Github Actions 워크플로우를 활용하여 확장할 수 있습니다. 이를 통해 CICD 파이프라인에서 구성 규정 준수를 자동화할 수 있습니다. GitHub reusable workflows는 GitHub Actions의 기능 중 하나로, CI/CD(지속적 통합 및 지속적 배포)에 강력한 도구입니다. 이를 통해 여러 리포지토리에서 사용할 수 있는 워크플로우를 생성할 수 있어 코드를 복사하여 붙이는 필요성을 줄이고 최상의 관행을 촉진할 수 있습니다.\n\n# GitHub Actions 워크플로우 설정 단계\n\n## Terraform 구성을 호스팅하기 위한 GitHub 리포지토리 설정\n\n- GitHub에서 리포지토리를 생성합니다.\n- AWS 샘플에서 Terraform 인프라 코드를 위한 policy-as-code/OPA에서 \"policy\" 디렉터리를 복사합니다. 새로 생성한 리포지토리에 \"policy\" 폴더를 놓습니다.\n- 새로 생성한 리포지토리에 Terraform 배포 코드가 포함된 \"main.tf\"를 추가합니다.\n- 변경 내용을 스테이징하고 커밋한 후 리포지토리에 푸시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## AWS 계정과 GitHub을 연결하도록 OIDC를 구성하세요.\n\n- AWS 계정 내 자원에 액세스하고 배포할 수 있도록 GitHub Action 워크플로우에 OIDC를 사용하는 방법을 따르세요.\n\n## GitHub Actions 구성\n\n- GitHub 레포지토리에서 .github/workflows 디렉토리를 생성하세요.\n- .github/workflows 디렉토리 내에 github-actions-demo.yml이라는 파일을 생성하세요.\n- GitHub Actions 워크플로우 YAML 파일 아래 코드 부분의 YAML 내용을 github-actions-demo.yml 파일로 복사하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nname: Terraform 유효성 검증\n\non:\n  pull_request:\n    branches:\n      - main\n      \npermissions:\n      id-token: write   # JWT를 요청하는 데 필요합니다\n      contents: read    # actions/checkout에 필요합니다\n\njobs:\n  terraform:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: 리포지토리 체크아웃\n      uses: actions/checkout@v3\n      with:\n        fetch-depth: 0\n    - name: Conftest 설정\n      uses: princespaghetti/setup-conftest@v1\n      \n    - name: Terraform 설정\n      uses: hashicorp/setup-terraform@v2\n\n    - name: AWS 자격 증명 구성\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        role-to-assume: arn:aws:iam::XXXXXXXXXXXX:role/github_oidc_role\n        role-session-name: GitHub_to_AWS_via_Federated_OIDC\n        aws-region: us-east-1\n   \n    - name: Sts GetCallerIdentity\n      run: |\n        aws sts get-caller-identity\n\n    - name: Terraform 초기화\n      run: terraform init\n\n    - name: Terraform 유효성 검사\n      run: terraform validate\n\n    - name: Terraform Plan JSON 출력 생성\n      run: |\n        terraform plan -out=\"plan.tfplan\"\n        terraform show -json plan.tfplan | grep -v \"::debug::\" | tail -n +2 \u003e plan.json\n        pwd\n\n    - name: OPA 설치\n      run: |\n        curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64\n        chmod 755 ./opa\n        sudo mv opa /usr/local/bin/\n\n    - name: Rego 정책 평가\n      id: evaluate_policies\n      run: |\n       EXIT_CODE=0\n       conftest test /home/runner/work/terraform-opa-testing/terraform-opa-testing/plan.json -o table --all-namespaces -p policy/ || EXIT_CODE=$?\n       echo \"::set-output name=exit_code::$EXIT_CODE\"\n\n    - name: OPA 규칙 평가 실패\n      if: ${{ steps.evaluate_policies.outputs.exit_code != 0 }}\n      run: |\n       echo \"AWS 계정에 배포하는 Terraform 리소스가 정의된 표준을 준수하지 않습니다. \"Evaluate Rego Policies\"를 확인하여 준수되지 않는 구성을 찾고 코드를 수정하십시오.\"\n       exit 1\n\n    - name: Terraform 적용\n      if: steps.evaluate_policies.outputs.exit_code == 0\n      run: terraform apply -auto-approve\n\n\n4. 변경 사항을 \"dev\" 브랜치에서 \"Main\" 브랜치로 병합하기 위해 Pull Request가 올라왔을 때 워크플로우가 트리거됩니다.\n\n5. AWS 계정에 배포하는 Terraform 코드에서 위반 사항이 발견되지 않으면 워크플로우가 성공적으로 실행됩니다. 그렇지 않으면 \"AWS 계정에 배포하는 Terraform 리소스가 정의된 표준을 준수하지 않습니다. \"Evaluate Rego Policies\"를 확인하여 준수되지 않는 구성을 찾고 코드를 수정하십시오.\"라는 오류 메시지와 함께 워크플로우가 실패합니다.\n\n## 관련 자료\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 OPA 소개\n\nOPA와 Terraform\n\nTerraform용 OPA Rules 공개 저장소\n\nOPA 정책 참조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOPA 동작 방식\n\n링크드인에서 연결하면 좋겠어요.","ogImage":{"url":"/assets/img/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow_0.png"},"coverImage":"/assets/img/2024-05-16-ImplementOPApreventivecontrolsinAWScloudusingTerraformIaCwithGitHubActionsworkflow_0.png","tag":["Tech"],"readingTime":6},{"title":"TIC-80 튜토리얼 머신 러닝걱정하지 마세요 이것은 AI의 일부일 뿐입니다  퍼셉트론 학습","description":"","date":"2024-05-16 16:52","slug":"2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning","content":"\n\n\n![공포를 느끼지 마세요. 그냥 AI의 일부입니다.](/assets/img/2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning_0.png)\n\n[페이지에 시각적인 풍미를 위해 만든 예쁜 3D 모델]\n\n신경망의 경우, 퍼셉트론 학습은 소개 알고리즘 중 가장 간단한 것 중 하나입니다.\n\n이것은 간단한 이진 분류에 사용됩니다. 이는 물건을 그룹화하는 데 사용될 수 있다는 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임을 개발하면서 여러 아이디어가 떠오를 수 있습니다. 이것은 무작위로 생성된 레벨을 더 멋지게 디자인하거나 플레이어의 입력에 따라 난이도를 조절하거나 더 나은 적을 제공하는 방법일 수 있어요.\n\n--- --- --- --- --- --- --- --- --- --- --- --- ---\n\n![나만의 랜덤 애니메이션](https://miro.medium.com/v2/resize:fit:200/1*J6hWD17Q6PPkhnd0E5rkgw.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서, 퍼셉트론은 입력을 받아 처리한 후 출력을 내놓습니다.\n\n- 퍼셉트론 학습은 입력을 받는 간단한 신경망입니다.\n\n2. 일정한 가중치가 있습니다 (랜덤으로 생성됩니다. 가중치가 동일하지 않도록 하기 위한 것이며, 학습이 이루어질 수 있도록 항상 모두 마스터할 필요는 없습니다).\n\n3. 그런 다음 가중합을 얻습니다 (이는 단순히 가중치*입력과 가중치*입력의 합을 의미합니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 마지막으로 출력을 결정하는 활성화 함수를 포함합니다.\n\n다음은 코드입니다:\n\n```js\nrnd = math.random\n-- 가중치 초기화\nlocal weight1 = rnd(1) - 0.5\nlocal weight2 = rnd(1) - 0.5\n\n-- 활성화 함수 (계단 함수)\nfunction activate(sum)\n    if sum \u003e 0 then\n        return 1\n    else\n        return 0\n    end\nend\n\n-- 메인 루프\nfunction TIC()\n\ncls()\n    -- 입력 값 샘플 (이 값을 변경할 수 있음)\n    local input1 = 1\n    local input2 = 0\n    \n    -- 가중합 계산\n    local weightedSum = input1 * weight1 + input2 * weight2\n    \n    -- 퍼셉트론 활성화\n    local output = activate(weightedSum)\n    \n    -- 출력 표시\n    print(\"Output: \" .. output, 20, 20, 15)\nend\n```\n\n이 활성화 함수는 신경망 세계에서 꽤 한정적인 단계 활성화 활성화 함수이지만, 창의적으로 사용하면 멋진 것들을 만들 수 있다고 생각합니다.","ogImage":{"url":"/assets/img/2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning_0.png"},"coverImage":"/assets/img/2024-05-16-TIC-80TutorialMachineLearningdonotgetscaredawaybythisItissimplyapartofAIPerceptronlearning_0.png","tag":["Tech"],"readingTime":2},{"title":"당장 시작할 수 있는 SaaS 아이디어를 소개합니다","description":"","date":"2024-05-16 16:51","slug":"2024-05-16-SaaSideasthatyoucangetstartedrightaway","content":"\n\n\u003cimg src=\"/assets/img/2024-05-16-SaaSideasthatyoucangetstartedrightaway_0.png\" /\u003e\n\nSaaS를 개발하는 것은 모든 사람이 원하는 것입니다. 그게 왜냐하면 노력을 덜 들여도 매달 수입이 지속적으로 들어오기 때문이죠. 따라서 오늘의 기사에서는 시작할 수 있는 3가지 SaaS 아이디어를 공유하려고 합니다.\n\n시작하기 전에, 성공적인 AI 기반 SaaS 비즈니스를 운영하는 데 심층적으로 파고들고 모든 중요한 전략과 요점을 알고 싶다면, \"AI 주도 SaaS 구축을 위한 치트 코드\"라는 책을 썼습니다. 이 책은 광범위한 지침을 제공하며 AI 기반 SaaS를 구축하는 데 필요한 길을 찾을 수 있을 겁니다.\n\n# CRM용 플러그인 🤔\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCRM은 어떤 기업에서도 매우 중요한 역할을 합니다. Salesforce, Hubspot, 또는 Drip과 같은 도구들은 현재 시장에서 가장 인기 있는 CRM 중 일부입니다. \n\n하지만 이러한 CRM에는 하나의 중요한 문제가 있습니다. 바로 학습 곡선인데요. Salesforce에 익숙하지 않은 경우 실수를 하게 되면 소중한 회사 데이터를 잃을 수도 있습니다. \n\n그래서 이러한 CRM에 쉽게 통합되는 AI 어시스턴스 같은 것을 구축할 수 있습니다. 이는 플러그인이나 확장 프로그램으로 제공되어 사용자들이 플랫폼을 움직이는 데 도움을 줍니다. AI 어시스턴스의 심각성을 높게, 중간으로 또는 낮게 설정할 수 있습니다. CRM에 대한 이해를 기반으로 AI 어시스턴스가 언제든지 사용할 것을 확신하지 않는 버튼을 누르려고 할 때 경고를 제공하고 결과에 대해 알려줄 것입니다.\n\n더불어, AI는 사용자들이 플랫폼을 더 잘 이해하도록 도와주며, 어떤 기능에서 막혀있을 때 질문에 답변해줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 산업에서 큰 문제를 해결하게 될 거에요. 제품의 USP는 중요한 조치를 취하기 전에 사용자에게 결과를 미리 보여줄 수 있다는 것이에요.\n\n# AI 기능 요청 🧑‍💻\n\n성공적인 SaaS를 운영 중이시라면 사용자가 기능을 요구하는 상황에 마주치셨을 것입니다.\n\n가끔 이러한 기능들은 좋은데 미래에 SaaS에 큰 영향을 미칠 수 있지만, 그 때에는 우리가 그것들을 무시하다가 나중에 만약 그 변화를 먼저 할 수 있었다면 더 쉬웠을텐데 라고 깨달게 되곤 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자로부터 피처 요청만 수집하는 도구를 상상해보세요. 버그나 피드백을 추가하지 말고, 피처 요청 데이터에는 버그나 서포트 티켓을 포함시키지 마세요.\n\n이제 AI는 SaaS에서 훈련되어 작동 방법을 알기 때문에 사용자로부터 제안된 모든 피처를 분류하고 구현할지 말지에 대한 제안을 할 수 있습니다. 또한 AI가 이 피처가 구현되었을 때 매출에 영향을 미칠 것인지 미래 예측을 할 수도 있습니다. AI는 과거 요구사항과 경쟁사와 비교하여 이를 계산할 수 있습니다.\n\n# 소셜 미디어에서의 표정🤔\n\n이제 SaaS 세계에서 큰 문제가 있습니다. 많은 사람들이 아주 좋은 아이디어를 가지고 있지만, 그들은 위대한 SaaS 제품을 만든다거나 적절히 마케팅 하는 방법도 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런데 문제는 사람들이 소셜 미디어 계정에 자신의 얼굴을 올리고 싶어하지 않는다는 것인데, 이는 회사에서 일하거나 콘텐츠 제작에 능하지 않다는 이유일 수 있습니다.\n\n이제 인공지능이 소셜 미디어용 릴과 콘텐츠를 만들 수 있지만, 유튜브나 인스타그램에 AI 아바타나 비디오를 올리면 사람들이 진지하게 받아들이지 않을 수 있습니다. 그래서 나는 소셜 미디어에서 콘텐츠를 만들 줄 아는 인턴들이 있고 AI를 사용해 그들의 얼굴을 비디오에 합성할 수 있는 기능을 갖춘 대행사를 만들어 제안합니다. 당신은 고객에게 콘텐츠 기준으로 요금을 부과하거나 다양한 패키지를 제공할 수 있습니다.\n\n이 아이디어는 자동화보다는 인간의 개입이 더 많이 필요하지만 높은 수요가 있는 아이디어입니다.\n\n이런 아이디어를 여러분과 공유하고 싶었고, 귀하의 특정 시장 및 요구 사항에 맞도록 이러한 아이디어를 유효성을 검사해 보시기 바랍니다. 어떻게 생각하시는지 댓글로 알려주세요. 귀하의 의견을 듣고 의문을 해결해 드리고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함께 공유하고 싶은 책이 있는데, 최근에 마케팅에 관한 책을 썼어요. SaaS를 위해 장기적으로 유지되는 고객을 확보하는 방법을 깊게 파헤치고 싶다면, \"당신의 SaaS를 성장시키는 마케팅 전략\"을 참고해보세요. 이 책은 SaaS를 처음부터 시작하여 실제 유저를 확보하는 데 도움이 되는 필요한 단계와 전략을 상세히 다루고 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-SaaSideasthatyoucangetstartedrightaway_0.png"},"coverImage":"/assets/img/2024-05-16-SaaSideasthatyoucangetstartedrightaway_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년에 숙련된 개발자를 위한 최고의 소프트웨어 아키텍처 코스 5선","description":"","date":"2024-05-16 16:48","slug":"2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024","content":"\n\n## 10 가지 필수 소프트웨어 아키텍처 + 경험 있는 개발자를 위한 Udemy에서 좋아하는 소프트웨어 아키텍처 강좌.\n\n![image](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_0.png)\n\n안녕하세요 여러분, 소프트웨어 아키텍처는 주니어 개발자를 시니어 개발자로 만드는 주제 중 하나이기 때문에 시니어 개발자들에게 중요한 주제입니다. 따라서 우리의 경험이 높아짐에 따라 시스템 디자인과 소프트웨어 아키텍처에 대해 배우는 것이 중요해져 더 높은 수준에서 기여할 수 있게 됩니다.\n\n그러나 이 주제를 마스터하는 것은 쉽지 않습니다. 굉장히 방대하고 자료를 찾기 어렵기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 사람들이 소프트웨어 아키텍처에 대해 알지 못하지만, 마이크로서비스 덕분에 이제는 적어도 Monolithic와 Microservice 아키텍처에 대해 알고 있다는 사실을 알게 되었습니다. 하지만 이 외에도 더 많은 것들이 있으며, 이 글에서는 이를 배워볼 것입니다.\n\n과거에는 최고의 시스템 디자인 강의와 최고의 소프트웨어 아키텍처 강의를 공유했었는데, 많은 분들이 유데미 강의를 요청해주셨기 때문에 이번 글에서는 소프트웨어 아키텍처를 배울 수 있는 최고의 유데미 강의도 소개하겠습니다.\n\n당장 서둘러야 한다면 Michael Pogrebinsky의 유데미 소프트웨어 아키텍처 강의부터 시작해보세요.\n\n그는 Software Architecture \u0026 Design of Modern Large Scale Systems 및 The Complete Microservices \u0026 Event-Driven Architecture와 같이 많은 수준 높은 품질의 소프트웨어 아키텍처 및 대규모 시스템 디자인 강의를 개설했습니다. 이 강의들은 시작하기에 최적이며 가격 또한 매우 저렴합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Software Architecture Courses](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_1.png)\n\n# 10 Software Architecture Every Experienced Developer Should Know\n\n여기에는 가장 인기있는 소프트웨어 아키텍처 및 간단한 설명과 장단점이 포함된 목록이 있습니다. 시니어 개발자로서는 항상이만큼의 정보를 갖고 있어야 합니다.\n\n- Monolithic Architecture: 전체 응용 프로그램이 단일 단위로 구축되는 전통적인 아키텍처입니다. 개발 및 배포는 간단하지만 확장은 도전적일 수 있습니다.\n- Microservices Architecture: 응용 프로그램을 느슨하게 결합된 서비스의 모음으로 구조화하는 아키텍처 스타일로, 각각이 특정 비즈니스 기능을 담당합니다. 확장성, 유연성 및 유지 관리가 쉽습니다. Microservices 아키텍처를 배우려면 이 강좌도 참고하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서비스 지향 아키텍처 (SOA)\n이 아키텍처는 마이크로서비스와 비슷하지만 네트워크를 통해 서비스를 제공하는 데 초점을 맞춥니다. SOA는 서비스를 잘 정의된 인터페이스로 정의하여 응용 프로그램을 더 모듈식이고 상호 운용 가능하게 만들고자 합니다. 그리고 원한다면 SOA 아키텍처를 배우는 데 도움이 되는 이런 코스들도 확인하실 수 있습니다.\n\n- 이벤트 주도 아키텍처 (EDA)\n이 소프트웨어 아키텍처 스타일은 이벤트 흐름이 특정 작업 실행을 유발하는 방식입니다. 실시간으로 많은 이벤트에 반응하고 처리하는 시스템을 구축하는 데 유용합니다.\n- 계층화된 아키텍처\n이 소프트웨어 아키텍처는 소프트웨어를 구별된 계층으로 구성합니다(예: 표현 계층, 비즈니스 로직 계층, 데이터 액세스 계층), 각 계층은 인접한 계층과만 통신합니다. 모듈성과 관심사의 분리를 촉진합니다.\n- 육각형 아키텍처 (포트와 어댑터)\n이 소프트웨어 아키텍처는 핵심 로직을 데이터베이스 및 사용자 인터페이스와 같은 외부 관심사로부터 분리하여 테스트, 유지 보수 및 이해하기 쉬운 소프트웨어를 만들도록 초점을 맞춥니다.\n- 클린 아키텍처\n관심사의 분리와 의존성 규칙을 강조하는 아키텍처 패턴입니다. 코드를 원형 또는 계층으로 구성하여 유연하고 확장 가능하며 유지보수 가능한 시스템을 만들도록 지향합니다.\n- 이벤트 주도 마이크로서비스\n이 소프트웨어 아키텍처는 마이크로서비스 아키텍처를 이벤트 주도 아키텍처와 결합하여 서비스가 이벤트를 통해 비동기적으로 통신하는 구조입니다. 느슨한 결합, 확장성 및 회복력과 같은 이점을 제공합니다.\n- CQRS (Command Query Responsibility Segregation)\n이는 데이터 저장소의 읽기 및 쓰기 작업을 별도의 모델로 분리하는 아키텍처 패턴입니다. 읽기 및 쓰기 요구 사항이 크게 다른 복잡한 애플리케이션에 유용합니다.\n- 서버리스 아키텍처\n이 아키텍처는 인프라를 관리하지 않고 응용 프로그램 및 서비스를 구축하고 실행할 수 있는 구조를 제공합니다. 코드는 이벤트에 응답하여 실행되고 클라우드 제공업체가 자동으로 리소스를 할당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 크레딧 - LinkedIn의 Rocky Bhatia씨. 그를 팔로우하면 유용한 컨텐츠를 공유합니다.\n\n# 2024년 Udemy에서 가장 좋은 소프트웨어 아키텍처 강좌 5선\n\n이제 소프트웨어 아키텍처를 배울 수 있는 Udemy 강좌를 살펴보는 시간입니다. 더 이상 미루지 말고, 여기 2024년 Udemy에서 가입할 수 있는 최고의 소프트웨어 아키텍처 강좌 목록이 있습니다. 이 강좌들은 최신 정보가 담겨있고 심도 있는 내용을 다루며 가격도 매우 저렴합니다. 대부분의 강좌는 현재 Udemy 세일에서 $10에 구매할 수 있습니다.\n\n## 1. Michael Pogrebnisky에 의한 Modern Large Scale Systems의 소프트웨어 아키텍처 및 디자인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작년에는 소프트웨어 디자인 및 아키텍처 과정이 우리 순위에서 5위였지만, 이제는 우리 독자들과 수강생들의 놀랍도록 좋은 반응으로 인해 2위로 도약했습니다.\n\nMichael Pogrebinsky가 만든 이 소프트웨어 아키텍처 과정은 2024년에 대규모 및 분산 시스템을 설계하는 방법을 가르쳐줍니다. 자바 동시성 과정에 참여한 후 이 과정에 참여하기는 당연한 선택이었고, 실망하지 않았습니다.\n\n시스템 디자인 면접을 합격하고 소프트웨어 아키텍처를 배우기 원하는 경험 많은 개발자라면 소프트웨어 아키텍트나 솔루션 아키텍트가 되기 위한 Udemy 과정이 완벽할 것입니다.\n\n이 과정에서 배울 수 있는 내용들은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 하루에 수백만 개의 요청을 처리할 수 있는 대규모 시스템을 설계하는 방법\n\n2. 확장성 및 고가용성을 위한 설계 방법\n\n3. 소프트웨어 아키텍처 패턴, 구축 블록 및 모범 사례\n\n4. 시스템의 기술적 요구 사항, 고수준 구성 요소 및 API 정의 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. 대규모 시스템의 소프트웨어 아키텍처 및 기술\n\n이 수업을 수강한 후에는 대규모 시스템에서 사용되는 소프트웨어 아키텍처에 대해 solide knowledge를 얻을 것입니다. 경험 많은 Java 개발자에게 이 소프트웨어 아키텍처 과정을 강력히 추천합니다.\n\n다음은 이 수업에 참여할 수 있는 링크입니다 — 현대 대규모 시스템의 소프트웨어 아키텍처 및 디자인\n\n![Course](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코스의 큰 성공 이후, Michael은 시스템 디자인 및 소프트웨어 아키텍처에 대한 두 가지 새로운 코스를 더 출시했습니다. 첫 번째 코스는 '소프트웨어 아키텍처 및 시스템 디자인 실용 사례 연구'이고, 두 번째 코스는 '완전한 클라우드 컴퓨팅 소프트웨어 아키텍처 패턴'입니다. 이 두 코스는 이 코스를 효과적으로 보완합니다.\n\n가능하다면, 2024년에 시스템 디자인과 소프트웨어 아키텍처를 완벽히 마스터하기 위해 세 코스에 참여할 수 있습니다.\n\n## 2. Anurag Yadav의 대규모 시스템의 소프트웨어 아키텍처 및 기술\n\n이 Udemy의 또 다른 소프트웨어 아키텍처 코스는 경험 있는 개발자들이 확인할 가치가 있습니다. 이 코스는 다른 코스가 5에서 8시간의 콘텐츠를 제공하는 것에 비해 25.5시간 이상의 콘텐츠를 제공하며 가장 포괄적인 시스템 디자인 코스 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 소프트웨어 아키텍처 과정은 현대 기술을 활용하여 고성능, 확장성, 가용성 및 보안을 갖춘 소프트웨어 시스템을 만드는 방법을 가르쳐 줄 거에요.\n\n이 과정은 기본적인 삼단 애플리케이션 아키텍처부터 시작해, 마이크로서비스와 분산 시스템과 같은 고급 및 현대 소프트웨어 아키텍처로 전환됩니다.\n\n또한 성능, 확장성, 신뢰성 및 보안을 고려한 아키텍처 설계 방법과 같은 비기능 요구사항을 어떻게 다룰지 배우게 될 거에요.\n\n또한 Nodejs, Redis, Cassandra, Kafka, Hadoop, Elasticsearch와 같이 높은 확장성을 갖춘 기술 및 기술 스택에 노출될 거에요. 무엇보다도 대규모 프로덕션 배포를 위해 Docker 및 Kubernetes를 사용하는 방법을 배우게 되어, 클라우드 컴퓨팅 시대에서 중요한 기술을 습득할 수 있을 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코스에 가입하려면 다음 링크를 참조하세요 — 소프트웨어 아키텍처 및 대규모 시스템 기술\n\n![이미지](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_3.png)\n\n## 3. Microservices 아키텍처 — Memi Lavi의 완벽한 안내서\n\nMemi Lavi는 Udemy의 다른 강사로, 소프트웨어 아키텍처, 특히 Azure, 그리고 시스템 설계에 대한 광범위한 지식으로 매우 존경받는 강사입니다. 이 코스는 복잡한 소프트웨어 개념을 단순하고 친근한 언어로 설명하는 그의 탁월한 기술을 또 다른 예로 제시한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 5 시간 짜리 강좌는 마이크로서비스 아키텍처에 대해 다룹니다. 이 강좌에서는 기초부터 전담자 및 관련 문제, 마이크로서비스 아키텍처의 9가지 속성을 탐구하는 내용을 다룹니다.\n\n또한 아키텍처 프로세스, 견고하고 신뢰성 있는 마이크로서비스 설계, 효과적인 배포 및 테스트, 서비스 매시 컨셉에 대한 깊이 있는 이해, 마이크로서비스를 사용하지 말아야 하는 경우 및 단일체를 마이크로서비스로 분할하는 전략을 탐구할 것입니다.\n\n소셜 증명에 관해 이 강좌는 12,669개의 평가로부터 5점 만점에 4.5점이라는 인상적인 평가를 받았으며, 총 63,991 명의 학생들로 구성된 방대한 학생 집단을 유치했습니다.\n\n이 강좌에 가입하려면 다음 링크를 참조하십시오 — . 마이크로서비스 아키텍처 — 완전 가이드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_4.png](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_4.png)\n\nWhether you are a beginner or experienced developer, this course stands as a valuable resource in mastering Microservices Architecture, and if you like this course, you can also checkout Mavi’s other courses on Software architecture, many of them are worth watching, particularly, The Complete Guide to Becoming a Software Architect\n\n## 4. The Complete Cloud Computing Software Architecture Patterns\n\nThis is another Software architecture course from Michael Pogrebinsky on Udemy which is designed to teach you skills needed to architect large-scale systems using cloud computing, software architecture patterns, and modern system design principles.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 과정에서는 현대 대규모 소프트웨어 시스템의 설계와 아키텍처에서 클라우드의 역할을 배우고, 도전적인 시스템 설계 문제를 해결하며, 소프트웨어 아키텍처 패턴을 효과적으로 활용하고, 전 세계 수백만 사용자에게 서비스를 제공하기 위해 클라우드 컴퓨팅을 활용할 수 있습니다.\n\n그리고, Michael의 강의 스타일을 좋아한다면 그의 다른 소프트웨어 아키텍처 및 분산 시스템 디자인 강좌인 Software Architecture \u0026 Design of Modern Large Scale Systems과 The Complete Microservices \u0026 Event-Driven Architecture도 마찬가지로 마음에 들 것입니다. 이 강좌들은 병행성과 자바 성능에 관한 강좌처럼 멋진 강좌들입니다.\n\n이 강좌에 참여하려면 다음 링크로 이동해주세요 — The Complete Cloud Computing Software Architecture Patterns\n\n![Image](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 소프트웨어 엔지니어링 101: Kurt Anderson에 의해 더 나은 소프트웨어 계획 및 실행\n\n이것은 소프트웨어 엔지니어링과 아키텍처를 배우기에 가치 있는 Udemy 강의 중 하나입니다. Kurt Anderson이 만든 이 강의는 YouTube의 전문가이자 주인공입니다.\n\n이 강의는 마스터-슬레이브, 계층 패턴, 클라이언트-서버, 파이프-필터 등 이 글에서 다룬 주요 아키텍처 중 대부분을 가르칠 것입니다.\n\n강사는 또한 아주 좋은 이야기꾼이며, 수업은 강을 향해 흐르듯 흘러갑니다. 당신은 분명히 이 강의를 좋아할 것입니다. 이 강의를 보게 된 이유 중 하나이기도 합니다. 또한, 많은 세부 정보로 지루하지 않도록 구성되어 있어요. 따라서 주요 소프트웨어 아키텍처에 대해 빠르게 소개받고 싶다면, 이 강의가 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수업에 참여하려면 다음 링크를 참조하세요: 소프트웨어 공학 101: 더 나은 소프트웨어 계획 및 실행\n\n![Software Engineering Course](/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_6.png)\n\n2024년 Udemy에서 가장 좋은 소프트웨어 아키텍처 과정에 관한 내용이었습니다. 소프트웨어 아키텍처는 숙련된 개발자들에게 꼭 필요한 주제이며, 그들은 시간과 노력을 투자하여 배워야 합니다.\n\n가격이 합리적인 자료를 찾을 때는 Udemy보다 나은 곳이 없습니다. 그래서 저는 이 소프트웨어 아키텍처 및 마이크로서비스를 배우기 위한 최고의 Udemy 코스들을 공유했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 진행 중인 Udemy 세일에서 이 강좌들을 각 10달러에 구입할 수도 있어요. 나는 이미 많은 기술을 배우고 이번 여름에 그것들을 복습하기 위해 많은 강좌를 구입했어요.\n\n다른 시스템 디자인 면접 자료들도 마음에 들 수 있을 거예요\n\n- 2024년 시스템 디자인 면접 준비 방법\n- 2024년 시스템 디자인 학습을 위한 8가지 최고 웹사이트\n- 시스템 디자인을 위한 ByteByteGo의 가치는 있을까요?\n- 2024년 시스템 디자인 학습을 위한 최고의 유튜브 채널 8가지\n- 2024년 학습할 5가지 최고의 자바 프레임워크\n- 온라인에서 무료로 코딩을 배울 수 있는 21가지 웹사이트\n- 2024년 시스템 디자인 학습을 위한 10가지 이유\n- 프로그래머를 위한 10가지 최고의 시스템 디자인 강좌\n- 시스템 디자인을 배울 수 있는 7가지 최고의 장소\n- 시스템 디자인 면접 코스인 Grokking the System Design Interview 가치가 있을까요?\n- 완전한 데브옵스 엔지니어 로드맵\n- 시스템 디자인 면접을 해결할 수 있는 최고의 11가지 자료\n- 프로그래머를 위한 50개 이상의 데이터 구조 면접 질문\n- 답변과 함께 30가지 시스템 디자인 면접 질문\n\n지금까지 이 글을 읽어주셔서 감사합니다. 만약에 Udemy의 최고 시스템 디자인 인터뷰 강좌가 마음에 든다면 친구나 동료와 공유해주세요. 궁금한 점이나 피드백이 있으시다면 연락 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nP.S. — 소프트웨어 디자인과 시스템 디자인을 배울 수 있는 무료 온라인 강좌를 찾고 있다면 Udemy에서 제공하는 최고의 무료 소프트웨어 디자인 강좌 목록을 확인해보세요. 이 유용한 기술을 배울 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_0.png"},"coverImage":"/assets/img/2024-05-16-Top5SoftwareArchitectureCoursesforExperiencedDevelopersin2024_0.png","tag":["Tech"],"readingTime":9}],"page":"81","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"81"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>