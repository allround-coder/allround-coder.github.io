<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/50" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/50" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" href="/post/2024-06-20-ReactCompilerisalmosthereanditisExciting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴파일러가 거의 다 왔어요 정말 기대돼요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" href="/post/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마이크로 프론트엔드의 미래" href="/post/2024-06-20-TheFutureofMicroFrontends"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마이크로 프론트엔드의 미래" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마이크로 프론트엔드의 미래" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">마이크로 프론트엔드의 미래</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" href="/post/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 클로저 마스터하기 심층 탐험 " href="/post/2024-06-20-MasteringJavaScriptClosuresADeepDive"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 클로저 마스터하기 심층 탐험 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 클로저 마스터하기 심층 탐험 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 클로저 마스터하기 심층 탐험 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" href="/post/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 다중 모달 지원하기 새로운 방식</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nx 암시적 라이브러리 숨겨진 보물 " href="/post/2024-06-20-NxImplicitLibrariesTheHiddenGem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nx 암시적 라이브러리 숨겨진 보물 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nx 암시적 라이브러리 숨겨진 보물 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nx 암시적 라이브러리 숨겨진 보물 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GitHub Copilot의 탑 10 기능" href="/post/2024-06-20-Top10GitHubCopilotFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GitHub Copilot의 탑 10 기능</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고급 데이터 구조 및 알고리즘 더미용 신경망" href="/post/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고급 데이터 구조 및 알고리즘 더미용 신경망</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 데이터 유형" href="/post/2024-06-20-JavaScriptDataTypes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 데이터 유형" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptDataTypes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 데이터 유형" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 데이터 유형</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link posts_-active__YVJEi" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 컴파일러가 거의 다 왔어요 정말 기대돼요","description":"","date":"2024-06-20 01:32","slug":"2024-06-20-ReactCompilerisalmosthereanditisExciting","content":"\n\nMeet Jay, he is a budding Frontend Engineer and has been working with React for a few months. Recently, he raised a Pull Request where he is fetching a list of todos and displaying it on the UI —\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png)\n\nBut Wait… His PR does not get approved!\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_2.png\" /\u003e\n\n만나요! Ray는 프론트엔드 리드입니다. 그는 그의 경험을 바탕으로 Jay가 할 일 목록을 조작하고 있고 이 목록이 매우 커질 수 있다는 것을 알아챘어요 (10,000개 이상). 그래서 그는 Jay에게 React에서 제공하는 훅을 사용하여 함수를 메모이즈하는 것을 권유했어요. 그렇게 하면 의존성(dependencies)이 변경될 때에만 함수가 호출되도록 할 수 있어요. 우리가 이야기하고 있는 훅은 useMemo()입니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_3.png\" /\u003e\n\nJay는 Ray의 조언을 따라 했지만, 여기서 몇 가지 더 코멘트가 있어요. 어떤 경우에는 여러 개의 콜백이 자식 컴포넌트로 전달되고 있어요. Ray는 Jay에게 useCallback()을 사용하여 이러한 함수들의 참조(reference)를 보존하여 각 리렌더링마다 자식 컴포넌트를 메모이즈하고 그들의 리렌더링을 멈출 수 있도록 하는 것을 요청했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업의 반은 끝났어요! 이제 비싼 자식 구성 요소들을 memo() 훅으로 감싸서 다시 렌더링을 막아야 해요.\n\n마음을 바꿔보면, 팀은 이 문제가 손에 잡히질 않아서 지금까지 위 훅들을 사용하여 오버엔지니어링을 한 부분이 많은 것 같아요. 실제로 성능 문제가 크게 발생한 것은 아니었는데, 누군가가 이런 베스트 프랙티스를 읽고, 성능을 분석하지 않고 사용해버린 결과이죠.\n\n어쨌든, 이런 대화와 React 앱을 더 최적화하기 위해 이러한 매개변수들을 추가하는 머릿 속 부담감은 피곤하고 React의 본래 이념과는 거리가 있는데요 -\n\nUI는 상태의 함수입니다... 확실히 이게 더 세밀하고 복잡한 문제이고, 우리는 방금 목격한 것처럼 말이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기에는 🚀 즉, REACT 컴파일러가 등장합니다\n\n# 2막 — REACT 컴파일러 소개\n\nReact 컴파일러는 React가 개발자 경험을 향상시키기 위해 가져오는 미래 기술입니다. 이름보다는 다소 온화해 보일 수 있지만, 이것은 게임 체인저입니다.\n\n컴파일러 뒤에 숨은 아이디어는 대부분의 메모이제이션 논리를 React에게 위임하고 과도하게 복잡한 useMemo 및 useCallback 훅을 줄여서 코드베이스를 가독성 있게 만드는 것입니다. 이러한 훅들의 종속성은 많은 사람들에게 고통의 요점이기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트에서 이와 같은 지원을 받기 위한 작업은 상당한 시간동안 진행되어 왔습니다. 2021년 Xuan의 이번 토크를 확인해보세요 —\n\n다음은 간단한 카운터 예제인 다음 코드 조각을 고려해 봅시다 —\n\n```js\nexport default function Counter({initialCount}) {\n  const [count, setCount] = useState(initialCount);\n\n  return (\n    \u003c\u003e\n      \u003cdiv className=\"flex gap-1 justify-center items-center\"\u003e\n        \u003cbutton\n          onClick={() =\u003e {\n            setCount(count + 1);\n          }\n        \u003e\n          +\n        \u003c/button\u003e\n      \u003c/div\u003e\n\n      \u003cspan\u003e\n        {count}\n      \u003c/span\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n리액트 컴파일러에 의해 컴파일된 이 코드를 사용하여 상황을 확인할 수도 있습니다 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction Counter(t0) {\n  const $ = _c(2);\n\n  const { initialCount } = t0;\n  const [count, setCount] = useState(initialCount);\n  let t1;\n\n  if ($[0] !== count) {\n    t1 = (\n      \u003c\u003e\n        \u003cdiv className=\"flex gap-1 justify-center items-center\"\u003e\n          \u003cbutton\n            onClick={() =\u003e {\n              setCount(count + 1);\n            }\n          \u003e\n            +\n          \u003c/button\u003e\n        \u003c/div\u003e\n        \u003cspan\u003e{count}\u003c/span\u003e\n      \u003c/\u003e\n    );\n    $[0] = count;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n\n  return t1;\n}\n```\n\n여기서 $는 props, state 및 다른 반응적인 정보의 데이터를 보관하는 변수이며, 잠재적인 다시 렌더링에서 비교하고 부모 구성 요소 또는 상태 변경이 있을 때, 그 정보가 변경된 것이 없다면... 바로! 컴포넌트 다시 렌더링이 저장됩니다!\n\n_c는 여기에서 실제 리액트 컴파일러 훅이며 useMemoCache()라고도 불리며 우리가 보았던 바와 같이 useMemo() 네이티브 훅과는 다르게 작동합니다.\n\n그래서 간단히 말해서, Dan Abramov의 말로 하면, 리액트 컴파일러는 본질적으로 이것입니다 —\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet jsx;\n\nif(prevCount != count){\n  jsx = ...\n} else {\n  jsx = prevJsx;\n}\n```\n\n아래는 이것이 큰 개선될 상황 몇 가지 예시입니다 —\n\n- 우리는 DOM 노드의 tree, 즉 React Fiber 또는 Virtual DOM을 알고 있습니다. 부모 컴포넌트가 렌더링될 때 전체 서브트리/자식 컴포넌트가 다시 렌더링 됩니다. React 컴파일러는 변경 사항이 없는 경우 그것을 회피해주고, 의존할 props가 없더라도 도움을 줄 것입니다.\n- useMemo() 훅의 경우 대부분의 경우에는 필요하지 않을 것이며, React 컴파일러가 적절하게 캐싱을 할 수 없는 경우에만 필요할 것입니다. 이 경우 오리지널 컴파일러 구현체로 되돌아갈 것입니다. 이를 잘못 사용했을 때 useMemo() 훅의 예시가 될 수 있습니다.\n\n# 제 ACT III: 지나치게 복잡한 최적화가 끝나는 시작\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n드디어 React에도 다른 대부분의 라이브러리에서 사용하던 컴파일러가 도입되고 있습니다. 이로 인해 날이 갈수록 React 코드를 작성할 때 \"만약 이 부분이 변경된다면?\", \"이 함수가 성능에 해를 끼칠까?\"라는 걱정을 덜어내고 코드를 작성할 수 있게 되었습니다.\n\nReact 팀에게 👏 이를 위해 수년간 반복적이고 꾸준한 노력을 기욯 합니다. 재미있는 사실: 컴파일러를 도입하고자 한 목표가 후크(hook)와 서버 컴포넌트(Server components)를 탄생시켰습니다.\n\n컴포넌트를 이주할 준비가 되어 있는지 확인하려면 추천사항은 아니지만 React 팀의 React 컴파일러 소개 페이지(https://react.dev/learn/react-compiler#existing-projects)를 참조할 수 있습니다. 더 깊이 살펴볼 수 있는 유용한 리소스 몇 가지를 소개해 드리겠습니다 -\n- https://www.youtube.com/watch?v=PYHBHK37xlE\n- https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a\n- https://www.youtube.com/watch?v=wnXGSwrOw80\n- https://www.youtube.com/watch?v=0ckOUBiuxVY\u0026t=9311s [React 컴파일러 부분을 확인할 수 있습니다]","ogImage":{"url":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png"},"coverImage":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png","tag":["Tech"],"readingTime":5},{"title":"CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다","description":"","date":"2024-06-20 01:30","slug":"2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther","content":"\n\n\n![이미지](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png)\n\nECMAScript 모듈은 현대 JavaScript 개발에서 인정받는 산업 표준이 되어가고 있습니다. ESM이 Node.js에 소개된 이후 비동기 로딩 기능과 모듈 해결 논리가 잘 받아들여졌습니다.\n\n그러나 역사적인 이유로 많은 기존 코드베이스와 타사 라이브러리는 여전히 CommonJS 모듈 시스템에 의존하고 있습니다. ESM의 비동기 로딩 설계로 인해 이 두 모듈화 체계가 아직 공존할 수 없었는데, 이는 많은 개발자들에게 주요 고통 요인이 되었습니다.\n\n최근 joyeecheung 님이 이 문제를 해결하기 위한 중요한 Pull Request를 제출했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_1.png\"/\u003e\n\n## CJS와 ESM의 과거와 현재\n\n자바스크립트의 세계에서 모듈화는 대규모 애플리케이션을 구축하는 데 필수적입니다. 모듈화는 글로벌 네임스페이스에 영향을 미치지 않고 코드를 관리하는 데 도움이 되며, 기능을 분리하고 코드를 재사용하며 의존성을 관리하기 쉽게 합니다. Node.js와 브라우저 환경 모두에서는 CommonJS (CJS)와 ECMAScript Module (ESM)이라는 두 가지 주류 모듈 시스템이 있습니다.\n\nCommonJS는 Node.js에서 네이티브로 지원되는 모듈 시스템으로, 초기에 서버 측 모듈화 요구를 충족하기 위해 도입되었습니다. CJS는 require 함수를 사용하여 모듈을 로드하고 module.exports 또는 exports 객체를 사용하여 코드를 모듈로 노출합니다. CommonJS 모듈의 특징은 동기적으로 로딩되는 것으로, 모듈이 로드된 후 즉시 코드가 실행된다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// math.js\nfunction add(x, y) {\n  return x + y;\n}\nmodule.exports = { add };\n\n// app.js\nconst math = require('./math.js');\nconsole.log(math.add(0, 17)); // 17을 출력합니다\n```\n\n서버 환경에서는 대부분 파일이 로컬이기 때문에 동기적으로 로딩되어도 문제가 되지 않습니다. 그러나 브라우저 환경에서는 동기적 로딩이 브라우저의 이벤트 루프가 스크립트를 완전히 다운로드하고 구문 분석할 때까지 블로킹되어 성능 문제를 일으킬 수 있습니다.\n\nESM은 최신 JavaScript의 공식 표준 모듈 시스템이며, 최신 브라우저의 버전에서 네이티브로 지원됩니다. CommonJS와 달리 ESM은 동적으로 모듈을 로드하거나 생성할 수 없도록 디자인되어 정적입니다. ESM은 import 및 export 문을 사용하여 모듈을 가져오고 내보내는데, 비동기적 로딩을 지원합니다:\n\n```js\n// math.js\nexport function add(x, y) {\n  return x + y;\n}\n\n// app.js\nimport { add } from './math.js';\nconsole.log(add(0, 17)); // 17을 출력합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nESM을 Node.js에서 활성화하려면 보다 복잡한 방법을 요구합니다. 이는 .js 파일 확장자가 기본적으로 CommonJS 모듈과 연관되기 때문입니다. 이 문제를 해결하기 위해 Node.js는 .mjs 파일 확장자를 사용하거나 package.json에서 명시적으로 \"type\": \"module\" 속성을 지정하여 ESM 모듘임을 나타낼 수 있습니다.\n\nNode.js에서 ESM이 지원되기 때문에 cjs를 가져올 수 있지만 require(esm)는 불가능합니다. ERR_REQUIRE_ESM으로 인한 당혹감은 많은 사용자들을 괴롭히며 Node.js 생태계 내에서 시간 낭비의 주요 원인이 될 수 있습니다.\n\n![Commonjs and ESM Module Compatibility](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 패키지 제작자들이 CJS와 ESM 사용자 모두가 그들의 패키지를 사용할 수 있도록 보장하고 싶다면, 그들은 모듈을 계속 CJS로 출판하거나 CJS와 ESM 둘 다를 릴리스하는 이중 모듈로 출시하여야 합니다 (일부 문제를 발생시킬 수 있지만, 이는 지금 매우 흔한 실천법입니다).\n\n동시에, 많은 트랜스파일러 (예: TypeScript 컴파일러)는 아직도 최종 출력물로 CJS 코드를 생성하도록 구성되어 있습니다. 이러한 트랜스파일러의 사용자들은 ESM 구문을 사용하여 코드를 작성하지만, 그들의 코드가 최종적으로 Node.js에서 CJS로 실행된다는 것을 필요로 알지 않을 수 있습니다. 그들의 코드가 실제로 require할 수 없는 진짜 ESM 써드파티 모듈을 사용하면, ERR_REQUIRE_ESM을 볼 수 있습니다. 이는 그들이 그들의 코드가 진정한 ESM으로 실행되고 있다고 가정하기 때문에 매우 혼란스러울 수 있습니다.\n\n## 왜 호환되지 않을까요?\n\n당연히 사람들은 다음과 같이 물을 수 있습니다: 왜 require()가 ESM 로딩을 지원하지 않을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오랜 시간 동안 Node.js 프로젝트의 응답은 항상 이와 같았습니다:\n\n하지만 여기서는 문서와 다른 형태의 커뮤니케이션이 오해를 일으킬 수 있는 상황입니다 — 아마도 그들은 Node.js ESM에서 발생하는 일에 대해 이야기하고 있을 뿐이며, ESM 자체가 어떻게 설계되었는지에 대해서는 언급하지 않은 것일 수도 있습니다. 지난 해, joyeecheung이 메모리 누수 문제를 해결하기 위해 V8 코드를 읽다가 ESM 자체가 절대적으로 비동기적으로 설계된 것이 아니라 조건적으로 비동기적으로 설계된 것을 우연히 발견했습니다. 즉, 코드에 최상위 await가 있는 경우에만 비동기적으로 동작하도록 설계되었습니다.\n\n따라서, 최상위 await를 포함하지 않는 ESM에 대한 require()를 지원하는 데는 아무 문제가 없습니다. 최상위 await를 사용해야 하는 유효한 이유가 있는 라이브러리도 있겠지만, 그렇게 흔한 일은 아닐 수도 있습니다.\n\n실제로, joyeecheung이 후에 npm 레지스트리에서 ESM을 지원하기 위해 (esm)을 요구하는 약 30개의 패키지를 테스트한 결과, 아무도 최상위 await를 포함하지 않았습니다 — 그리고 require()에서 동기 모듈을 지원하는 것이 이미 생태계에서 많은 머리아픔을 해결할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 초기 탐험 및 시도\n\nESM 지원은 긴 토론, 디자인 및 실험을 거쳤습니다. 2019년부터 Node.js 커뮤니티는 ESM과 CommonJS 간의 상호 운용성을 지원하는 방법을 탐색하기 시작했습니다. 이 기간 동안 많은 개발자들이 서로 다른 구현 솔루션과 개선 조치를 제안하는 Pull Request를 제출했습니다.\n\n당시, 중대한 PR 토론은 Node.js에서 .mjs 확장자를 가진 파일을 지원하는 방법과 동시에 CommonJS와 ESM을 지원할 수 있는 이중 모듈 시스템을 구현하는 데 초점을 맞추었습니다.\n\n![image](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 풀 리퀘스트는 상위 수준 대기를 처리하기 위해 로더에서 이벤트를 루핑하는 시도를 했지만, 그 방법이 안전하지 않아서 닫혔습니다.\n\n명세에 따르면, 구문 기반 ESM 동기 평가의 이론적 기초가 2019년에 확립되었습니다. 시간이 흐를수록 Node.js 내에서 \"ESM이 비동기적이고 CJS가 동기적이기 때문에 CJS는 ESM을 로드할 수 없다\"는 신화가 형성된 것으로 보입니다. 그러나 표준 기관에서는 ES 명세가 ESM이 조건부로 비동기적임을 명확히 보장하고 있습니다. W3C 명세는 Service Worker가 동기식 모듈 평가만 허용하도록 보장하기 위해 이를 사용합니다. 만약 2019년 이후 명세에 기반한 동기화가 보다 광범위하게 인식되면, 더 많은 시도가 있을 수 있으며 문서는 ESM을 무조건적으로 비동기로 설명하지 않을 것입니다.\n\n## 동기 require(esm) 지원\n\n작년 말에 joyeecheung은 문법에 따르면 ESM이 동기적일 수 있음을 발견하였으며, 오징어는 로딩 프로세스에 비동기성을 도입한 것은 오직 Node.js 뿐이라고 언급했습니다. 따라서, joyeecheung과 GeoffreyBooth는 동기 require(esm)를 다시 시작하기로 논의를 시작했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2024년 2월 말, joyeecheung은 CJS와 ESM 로더에 대해 캐싱과 유사한 작업을 수행하면서 더 깊이 파고들었을 때, \"Node.js에서 ESM 로더를 유일한 로더로 만드는 것을 포기하고 CJS 로더를 지원하는 별도의 프로그램을 구현하자\"는 더 간단한 방법이 있다는 것을 알게 되었습니다. 기존 ESM 로더 코드를 최소화할수록 구현이 더 쉬워지는 것 같았죠.\n\n그렇게해서 이 PR이 생성되었습니다.\n\nhttps://github.com/nodejs/node/pull/51977\n\n2019년 PR과의 주요 차이점은 이 PR이 require(esm)의 범위를 작게 유지하고 동기적으로 ESM을 로드하는 것만 지원하려고 한다는 것입니다. 기술 지도위원회(TSC)에서는 이것이 전혀 논란이되지 않았고, 크게 반박도 받지 않았다고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_4.png)\n\n현재, 이 기능은 여전히 실험 단계로 진행 중이며 실험적으로-require-module 플래그 아래에서 작업을 완료해야 합니다.\n\n현재, require(esm)은 명시적으로 .mjs 확장자를 통해 또는 .js 확장자에 “type”: “module” 패키지 필드를 사용하여 ESM으로 표시된 ESM 모듈만 지원합니다. 이는 npm에서 ESM-only 패키지를로드하는 데 충분합니다. .js 파일에 ESM 구문이 포함되어 있지만 가장 가까운 package.json에 “type”: “module” 필드가 없는 경우 .js 파일이 ESM로드로 “fallback”할 수 있지만, 이를 일반적으로 사용자가 피해야 할 사항입니다. ESM 구문 감지는 오버헤드를 유발하며 프로젝트에 충분한 ESM 모듈이 있을 때 노드.js가 모듈 유형을 추측하는 데 시간을 낭비하고 싶지 않을 수 있습니다. 특히, package.json에 명시적인 “type”: “module” 필드를 사용하여 이러한 오버헤드를 저장할 수 있습니다.\n\n## 마침내\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정직히 말해서, 이 문제는 오랜 시간 동안 나를 괴롭혔어요. 많은 NPM 패키지 개발자들도 이런 문제로 고통을 겪고 있어요. 이번 joyeecheung의 시도가 가능한 한 빨리 제품으로 출시되기를 바랍니다!","ogImage":{"url":"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png"},"coverImage":"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png","tag":["Tech"],"readingTime":6},{"title":"마이크로 프론트엔드의 미래","description":"","date":"2024-06-20 01:27","slug":"2024-06-20-TheFutureofMicroFrontends","content":"\n\n## 나는 이 퍼즐의 빠진 조각이 무엇인지 이해하고, 이 아키텍처 접근 방식을 더 개선할 수 있는 방법을 상상해 봐야겠어요\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png)\n\n2021년 말부터 2022년 초까지, 나는 미니 프론트엔드 여정이 현재까지 어디까지 왔는지 살펴보았어요.\n팀이 고민하는 다양한 도전 과제, 장기적으로 결합을 일으키는 안티 패턴, 그리고 이를 해결하기 위해 사용되는 반복 패턴들을 분석했어요.\n\n우리는 미니 프론트엔드가 팀이 독립적으로 작업하고 중대형 규모 애플리케이션에 기여하도록 가능하게 했으며, 우리의 애플리케이션을 진화시키며 잠재적인 문제의 영향 범위를 줄이는 방식을 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 현재까지 이룩한 것으로 분석이 끝나지 않았어요.\n\n나는 앞으로 나아가야 했어요, 미래로 한 발짝 내딛어.\n\n이 흥미로운 퍼즐의 빠진 조각들이 무엇인지 이해해야 하고, 이 아키텍처 접근 방법을 더욱 개선할 수 있는 방안을 상상해 봐야 했어요.\n\n이 글에서는 마이크로 프론트엔드 커뮤니티에서 흥미로운 대화를 일으킬 수도 있는 아이디어와 트렌드를 공유하고 싶어요. 다루는 주제는 이 아키텍처의 클라이언트 측, 서버 측, 그리고 엣지 측 구현을 고려하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 2022년에 저의 초점이 될 마이크로 프론트엔드 생태계에 대해 공유하려고 합니다.\n\n# 보다 철저한 디자인\n\n마이크로 프론트엔드 아키텍처의 주요 과제 중 하나는 \"마이크로\"가 얼마나 되어야 하는지에 대한 질문에 대답하는 것입니다.\n\n이 질문에 직면하는 많은 조직이 있습니다. 실제로, 하나의 답변만 있는 것이 아니라, 맥락, 조직 구조와 규모, 그리고 팀 간의 커뮤니케이션 흐름을 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 팀이 분산 아키텍처에 대해 여러 차례 소통한 후에 저는 '분산 컴포넌트'가 '마이크로 프론트엔드' 구현보다 더 많이 나타났다는 것을 많이 보았어요.\n\n분산 컴포넌트를 사용하면 도메인 지식이 컨테이너와 '마이크로 프론트엔드' 또는 컨테이너와 여러 '마이크로 프론트엔드' 사이에 공유되었어요.\n\n우리는 여전히 올바른 경계를 찾기 어려워하고 때로는 구현할 때 마이크로 프론트엔드를 어떻게 해석해야 하는지에 대한 이해가 부족한 경우가 있어요.\n\n저는 이해가 성숙해지는 방향으로 나아가는 필수적인 단계라고 생각해요. 응용 프로그램 비즈니스 하위 도메인을 정복하는 것은 쉬운 작업이 아니며 빌드하는 응용 프로그램에 대한 심층적인 지식이 필요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 이 문제를 완화할 잠재적인 해결책이 있다고 생각합니다.\n\n사용자 경험을 저해하지 않으면서 비즈니스 도메인을 어떻게 분리할지 여러 부서와 함께 화이트보드를 통해 더 많은 시간을 투자하는 것이 중요합니다.\n\n이러한 회의를 마칠 때 우리는 프로젝트를 자신 있게 시작하고 처음에 설정한 전제가 목표를 달성하는 데 여전히 유효한지 확인하기 위해 우리의 결정을 지속적으로 검토할 수 있어야 합니다.\n\n모든 것을 처음부터 포착할 수는 없다는 것을 기억해야 합니다. 비즈니스와 조직은 6개월 또는 12개월 후에 변할 수 있으므로 정기적으로 우리의 마이크로 프론트엔드 경계를 다시 검토해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 조직 구조와 소프트웨어 아키텍처 간의 연결 링크를 잊지 마세요. 이를 인식하고 설계 결정에 고려하는 것이 중요합니다.\n\n# 마이크로 프론트엔드 통신\n\n같은 뷰에서 여러 마이크로 프론트엔드를 가지고 있을 때, 어느 순간에는 서로 통신해야 합니다.\n\n저가 마이크로 프론트엔드를 설계하기 위해 만든 정신 모델에서는, 마이크로 프론트엔드 간의 통신을 촉진하기 위해 게시-구독 패턴을 사용하는 것이 권장됩니다. 이는 마이크로 프론트엔드 간의 경계를 강화하고, 디자인 시점 결합을 피하거나 최소화하여 더 자율적인 팀을 이끄는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기술적으로 이 패턴을 구현하는 데는 사용자 정의 이벤트, 이벤트 에미터 라이브러리 또는 반응형 스트림과 같은 여러 옵션이 있습니다.\n\n지난 몇 달 동안 중요한 요구 사항이 나왔는데, 처음에는 그다지 강조하지 않은 것 같습니다. 아마 당연시 여겼기 때문일 것 같아요, 그러나 분명히 주의해야 할 부분입니다.\n\n백엔드에서 이벤트 주도 아키텍처와 마찬가지로, 이벤트에 대한 명확한 스키마를 갖는 것은 통합 단계에서 실수를 피하는 데 도움이 됩니다. 더불어 스키마는 코드베이스에 직접 작업하지 않는 기술 직군들에게도 특정 애플리케이션 내에서 무슨 일이 일어나고 있는지 명확히 이해할 수 있도록 돕습니다.\n\n내가 팔로우하는 많은 Slack 채널 중 하나에서 발견한, 느슨하게 결합된 요소 간(마이크로 프론트엔드뿐만 아니라) 보다 구조화된 커뮤니케이션을 달성하는 데 도움이 되는 이 이벤트 버스 라이브러리가 있습니다: [링크](https://www.npmjs.com/package/@trutoo/event-bus).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_1.png)\n\n마이크로 프론트엔드는 분산 아키텍처이기 때문에 더 형식적인 API나 이벤트 관리가 필요합니다.\n\nAPI나 이벤트는 팀이 상호 작용하는 방법입니다. 마이크로 프론트엔드뿐만 아니라 중요합니다. \n이러한 사례들은 이벤트가 전송될 때 개발자가 실수를 피할 뿐만 아니라 팀 간 토론을 용이하게 하고 의도를 명확히 하는 데 도움이 됩니다.\n\n미래에는 잘 연결된 통신 전략을 대규모로 사용하는 대규모 애플리케이션에서 개발자 경험을 더 간단하게 만드는 데 더 많은 노력이 기울여졌으면 좋겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 새로운 마이크로 프런트엔드 간 상호 작용을 개발할 때마다 참고할 수 있는 이벤트 레지스트리가 있다면 얼마나 좋을까요?\n\n마이크로 프런트엔드 간 통신에 대해 PayPal이 무엇을 하고 있는지 아직 확인해보지 못했다면, 이 멋진 비디오를 꼭 시청하도록 권장드립니다!\n\n# 서버 측 렌더링 (SSR)\n\n서버 측 렌더링 아키텍처는 지난 몇 달 동안 혁신을 이루고 있는데, Next.js나 React 18 팀이 서버 구성 요소에 투자한 것을 생각해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 Next.js, Piral, TailorX, ILC 등의 마이크로 프론트엔드에 대한 흥미로운 솔루션도 갖고 있어요.\n\nSSR 마이크로 프론트엔드 애플리케이션에 대해 더 자세히 살펴봐야 할 몇 가지 주제가 있어요.\n\n지금까지 발견한 공백은 다음과 같아요:\n\n- 마이크로 프론트엔드 검색: 마이크로서비스를 위한 서비스 검색 패턴과 유사하지만 프론트엔드에 적용된 것입니다. 이 패턴을 사용하면 시스템의 엔드포인트에 대한 정적 참조없이 동적으로 마이크로 프론트엔드를 구성할 수 있어요. 마이크로 프론트엔드 인프라가 검색 서비스에 자체 등록되고 UI 컴포저가 마이크로 프론트엔드 자체보다는 검색 서비스에서 마이크로 프론트엔드를 검색할 수 있다면 어떨까요? 🤯\n- 클라우드에서의 참조 아키텍처: 인기 있는 클라우드 제공업체를 사용하여 SSR 마이크로 프론트엔드 아키텍처를 구축하는 방법에 대한 지침이 부족합니다. 이는 비교적 빨리 해결할 수 있는 마찰점이며 최대한 도와드리고 싶어요.\n- 마이크로 프론트엔드에서 서버리스 패러다임 활용하기: 서버리스가 인프라 관리를 클라우드 제공업체에 위임하여 개발 속도를 높일 수 있다고 믿어요. 동시에 우리는 어떤 서비스를 특정 워크로드에 활용해야 하는지 이해하는 마인드셋을 가져야 해요. 예를 들어, AWS Step Functions와 같은 서비스를 사용하여 마이크로 프론트엔드의 생성을 단순화하는 가치를 보고 있습니다. AWS 생태계 전체와의 통합이 훌륭하기 때문에 저희는 오랜 기간에 걸쳐 유지보수를 단순화할 수 있는 로우코드 모델을 채택할 수 있어요.\n이것은 클라우드에서 사용할 수 있는 많은 패턴 중 하나이며, 마이크로 프론트엔드와 함께 이러한 패턴을 탐색하는 것은 매우 매혹적일 수 있어요 (적어도 제겐).\n\n- 프레임워크에 중립적인 React 서버 컴포넌트 접근 방식: 백엔드 데이터가 변경될 때 뷰의 일부를 서버사이드 렌더링을 통해 원자적으로 다시로드하고 클라이언트 마이크로 프론트엔드와 시티 파트를 연결하는 메커니즘이 있는 것이 좋아요. 이를 통해 CSR과 SSR을 혼합하는 하이브리드 아키텍처를 사용하여 모든 마이크로 프론트엔드에 대해 올바른 접근 방식을 사용할 수 있을 거예요. 아마도 우리는 오늘 이러한 메커니즘을 만들어낼 수 있겠지만, React 18처럼 매끄러운 구현을 갖게 되는 것이 최종 목표일 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 보시는 것처럼, 저희 앞에 많은 기회가 있습니다. 몇 가지는 더 구체적인 기회인 레퍼런스 아키텍처 같은 것이 있고, 어떤 것은 보다 장기적인 시각에 있는 React 서버 컴포넌트 접근 방식 같은 것도 있습니다.\n이 목록 중에서 저의 초점은 레퍼런스 아키텍처 및 서버리스 패러다임을 이용한 마이크로 프론트엔드에 대한 조사에 있을 것입니다. 이미 레퍼런스 아키텍처에 대한 프로토타입 작업을 시작했고, 서버리스 측면에서도 몇 가지 흥미로운 프로토타입이 있습니다. 계속해서 업데이트를 기대해 주세요.\n\n# 부분 수화\n\n성능은 모든 프론트엔드 응용프로그램에 중요한 요소입니다. 마이크로 프론트엔드를 포함한 모든 것에 대한 것입니다. \"아일랜드 아키텍처\" 개념에 대해 들은 지 어느 정도 시간이 지났습니다. 그러나 이 아키텍처는 원칙과 특성 때문에 마이크로 프론트엔드 범주에 속할 수 있다고 믿습니다.\n\n아일랜드 아키텍처가 소개한 흥미로운 기술은 부분 수화를 통해 서버 측 렌더링 응용프로그램의 성능을 향상시킬 수 있는 가능성을 제시한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부분 수분화는 새로운 기술이 아니며, 2019년 이후로 사용 가능합니다(기억이 맞다면). 그러나 나는 마이크로 프론트엔드 응용 프로그램에서 이 기술에 대한 어떠한 언급도 보지 못했습니다.\n\n마이크로 프론트엔드의 성격과 부분 수분화의 작동 방식을 고려할 때, 이 기술이 SSR 마이크로 프론트엔드 응용 프로그램을 더욱 최적화하는 데 더 많은 인기를 얻어야 한다고 생각합니다.\n\n이 게시물에서 Addy Osmani는 이 개념을 더 잘 이해할 수 있는 유용한 리소스를 제공합니다:\n\n마지막으로, 만약 이 주제에 관심이 있다면, 부분 수분화를 사용할 수 있는 UI 프레임워크 목록이 포함된 이 게시물을 읽어보는 것을 적극 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 현재 Preact를 사용하여 마이크로프론트엔드 Proof of Concept를 실험 중입니다. 곧 더 많은 통찰을 공유할 수 있기를 희망합니다.\n\n# 마이크로프론트엔드와 엣지 컴퓨팅\n\n마이크로프론트엔드와 엣지에 대해 이야기할 때 자주 Edge-Side Includes (ESI) 마크업 언어를 생각합니다.\n\n이번에는 AWS Lambda at the edge나 Cloudflare workers와 같은 많은 CDN에서 제공하는 컴퓨팅 기능을 가리키고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최신 기술들이 빠르게 발전하고 있기 때문에 응용 프로그램의 일부분을 엣지로 옮길 수 있어 지연 시간과 솔루션의 확장성을 향상시킬 수 있습니다.\n\n그러나 많은 웹 애플리케이션에서는 여러 개의 마이크로 프론트엔드를 사용하여 HTML 페이지를 생성하는 계산 노력만을 고려할 수는 없으며 전체 애플리케이션의 복잡성도 고려해야 합니다.\n\n현재 계산 문제는 해결하기 \"쉬운\" 문제가 되었지만, 데이터 중력(데이터베이스, 다중 지역 데이터 복제, 글로벌 인프라에서의 쓰기 대 읽기, 데이터 복제 지연 등) 또는 일반적으로 중앙 집중화되고 안전한 인증(클라우드 인프라의 특정 지역이나 온프레미스 데이터 센터)과 같은 문제는 그렇지 않습니다.\n\nSSR 마이크로 프론트엔드 애플리케이션은 엣지 컴퓨팅에서 이점을 얻을 수 있지만, 아직 완전히 엣지에서 사용할 수 없는 기타 리소스(데이터, 인증, 캐시 등)에 액세스해야 합니다.\n외부 종속성이 전혀 필요하지 않은 매우 잘 캡슐화된 워크로드가 있는 경우가 아니라면 엣지의 전체 성능을 이용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래에는 엣지 기술의 채택이 더 많아질 것 같아요. 그런데 동시에 '멋지다'는 이유만으로가 아닌, 엣지 기술이 어떻게 실제 업무에 영향을 미칠 수 있는지 더 잘 이해해야 한다고 생각해요. 엣지 노드와 함께 작업하는데, \"하이프 주도 개발 anyone?\" 같은 용어는 크게 듣고 싶지 않을 거예요.\n\n내 의견으로는 엣지 컴퓨팅이 미래에는 마이크로 프론트엔드에 많은 영향을 미치고, 특히 응용 프로그램의 성능을 향상시키는 데 중요하다고 생각해요. 그러나 현재보다 그렇게 쉽지 않을 거에요.\n\n# 배포\n\n마이크로서비스에서는 특성 플래그, 블루-그린 배포, 카나리아 출시와 같은 새로운 마이크로서비스 버전의 배포를 위한 안전한 실천 방법이 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 12개월 동안, 저는 마이크로 프론트엔드에 유사한 기법을 구현하기 위한 노력을 볼 수 없었어요. 기능 플래그 이외의 것들은 많은 팀에서 잘 알려진 패턴으로 보입니다.\n\n개발 팀에 신뢰감을 주는 배포 전략이 반드시 필요하다고 생각해요.\n\n분산 시스템에서는 종종 지속적인 배포가 현실이기 때문에, 개발자들이 코드를 빠르게 반복하며 랩톱에서 프로덕션 환경으로 이동시키는 동안 모든 사용자에 의해 경험되는 버그를 도입할 위험이 없도록 안전망을 만들어야 해요.\n\nSSR(서버 측 렌더링) 마이크로 프론트엔드의 경우, 기존 도구와 관행을 쉽게 재활용할 수 있으며, 이러한 메커니즘 중 하나를 활용하여 인프라를 출시하는 데 사용할 수 있어요. 그러나 클라이언트 측 렌더링 마이크로 프론트엔드 애플리케이션에는 종종 이러한 전략이 수용되지 않는 경우가 많습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 그것들을 구현할 수 있는 여러 가지 방법이 있습니다, 클라이언트 측, 서버 측 또는 심지어 엣지에서도요.\n\n제 추천은 가능한 한 빨리 이러한 전략 중 하나를 구현하는 것입니다. 그것들은 당신의 팀에 대한 안전한 환경을 만들어주고 결과가 놀라울 수도 있습니다... 긍정적으로요.\n\n# 라우팅\n\n배포 전략과 엄격하게 연관된 것으로, 클라이언트 측 렌더링 마이크로 프론트엔드 응용 프로그램은 견고한 라우팅 전략이 부족합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 구현은 단일체 아키텍처를 구현하는 데 사용하는 라우팅 라이브러리를 사용하고 있습니다.\n\n대신, 우리는 이것보다 더 잘할 수 있다고 믿습니다!\n\n이전에 설명한 배포 전략과 함께 라우팅 라이브러리를 혼합하면 더 똑똑한 라우팅을 구현할 수 있습니다. 이를 통해 더 신규한 마이크로프론트엔드 버전, 다양한 환경 또는 사용자 역할을 고려할 수 있습니다.\n\n또한 트래픽을 점진적으로 증가시키고 버전에 대한 롤백을 수행하는 도구도 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, AWS에서 컨테이너 또는 서버리스 워크로드를 개발할 때 선호하는 배포 전략을 몇 줄의 구성으로 쉽게 설정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_2.png)\n\n애플리케이션 쉘의 라우팅은 외부 JSON을 통해 쉽게 조정할 수 있으며, 응용프로그램 로직에 이 정보를 통합할 필요가 없이 가능한 다양한 옵션을 제공합니다.\n\n마지막으로, 이 정적 JSON이 배포 로직과 결합될 때, 새 버전의 위험을 줄이고 비즈니스가 구현하고자 하는 로직에 따라 동적 설정이 가능해져서 많은 가치를 제공할 수 있다고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우팅과 배포는 제가 흥미를 느끼는 분야입니다. 다음 몇 달 동안 시간을 투자하여 일반적인 번거로움을 없애고 팀이 배포 및 라우팅을 더 잘 제어할 수 있게 하려고 합니다. 이 두 주제에 대해 매우 흥분하고 있는 작업 그룹 때문에 가능한 한 빨리 제가 진행 중인 작업을 공유할 수 있기를 희망합니다 🚀\n\n# 마이크로 프론트엔드 관리\n\n아직 이 영역을 탐험하지는 않았지만, 마이크로 프론트엔드의 PROs와 CONs를 이해하기 위해 시도할 도구 목록을 가지고 있습니다.\n\n제 주요 관심사는 모노 레포에 중점을 두는 것입니다. 제 생각에는 다른 프로젝트가 같은 저장소에 독립적으로 존재할 때와 같이 코드를 관리하는 추가 도구가 필요하지 않습니다. 현재 제 관심을 끄는 도구 목록은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Turborepo\n- PNPM\n- Projen\n\n내 생각에는 이들 모두 몇 가지 기능을 가지고 있어 개발자 경험을 향상시키는 모노 레포 전략을 구축하는 데 도움이 될 것입니다.\n\n올해의 목표는 조금 벗어나 있는 것 같아요. 모든 도구를 검토하는 데 충분한 시간을 투자할 수 있는지 확신이 안 서지만, 개발자 경험을 더욱 개선할 미개척된 기회가 있다고 믿기 때문에 이 분야를 주의 깊게 지켜보겠어요.\n\n시도해 볼 도구에 대한 제안은 언제든 환영이에요. 특히 도구를 테스트하고 경험을 공유할 때 간단한 리뷰를 제공해주신다면 더욱 환영합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n보시다시피, 마이크로 프론트엔드 생태계에서 아직 해결해야 할 문제가 많지만, 지난 몇 년 동안 큰 발전을 이루었습니다.\n\n저에게는 기업 조직 전반에서 성공을 거두고 있는 \"젊은\" 아키텍처의 여러 개선 영역을 만들어나가는 것이 매우 흥미로운 기회입니다.\n\n더 많은 발견이 있을 것이며, 이 빠른 채택이 분산 UI 아키텍처에서 무엇이 동작하고 동작하지 않는지에 대한 새로운 통찰을 가져다 줄 것이라고 기대합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹어셈블리(WASM), 클라이언트 측 보안 강화, 개발자 경험을 더욱 효율적으로 만드는 작업 등 다른 주제도 제가 주시하고 있어요. 하지만 이 글에서 나열된 주제들은 애플리케이션과 조직을 다음 몇 달 동안 확장하는 차세대 방법을 개선하는 데 고민거리를 제공해줄 거예요. 함께 토론해보면 좋을 것 같아요.","ogImage":{"url":"/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png"},"coverImage":"/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png","tag":["Tech"],"readingTime":10},{"title":"자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기","description":"","date":"2024-06-20 01:25","slug":"2024-06-20-JavaScriptParsingXMLDataFromOnlineSources","content":"\n\n\n![이미지](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png)\n\n웹에서 XML 데이터를 가져오고 추출하는 능력은 웹 개발자에게 중요한 기술입니다. XML은 구조화된 데이터를 교환하는 데 널리 사용되는 형식이며, 많은 온라인 서비스와 API가 이 형식으로 데이터를 제공합니다.\n\nJavaScript로 XML 데이터를 가져오는 현대적인 방법 중 하나는 fetch() API를 사용하는 것입니다. fetch() 함수를 사용하면 이전의 XMLHttpRequest 객체보다 더 간결하고 promise 기반으로 HTTP 요청을 보내고 XML 내용을 검색할 수 있습니다.\n\nfetch()를 사용하여 XML 데이터를 가져오면 JavaScript에서 DOMParser 객체와 같은 도구를 제공하여 XML을 DOM 구조로 구문 분석할 수 있으며, 이를 통해 필요한 정보를 추출할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# [1] JavaScript 프로젝트 생성하기\n\nReplit 플랫폼에서 만들어보세요\n\n![](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_1.png)\n\n# [2] HTML과 JavaScript 코드 편집하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 index.html:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e\n  \u003ctitle\u003ereplit\u003c/title\u003e\n  \u003clink href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv id=\"divOutput\"\u003e\u003c/div\u003e\n  \u003cscript src=\"script.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n위 HTML 코드는 웹 페이지의 기본 구조를 설정합니다. 이는 문자 인코딩, 뷰포트, 제목을 지정하는 `head` 섹션과 \"style.css\"라는 외부 CSS 파일에 대한 링크를 포함하고 있습니다. 또한, 동적 콘텐츠를 담을 컨테이너로 사용될 ID가 \"divOutput\"인 `div` 요소와 페이지 로드 시 실행될 \"script.js\"라는 외부 JavaScript 파일을 포함하는 `script` 요소를 포함한 `body` 섹션을 포함합니다. `!DOCTYPE html` 선언은 웹 브라우저에게 이 문서가 HTML5 문서임을 알려주며, 전체 코드는 클라이언트 측 스크립팅 및 JavaScript 파일을 사용한 동적 콘텐츠 조작을 포함한 웹 페이지의 기초를 설정합니다.\n\n파일 script.js:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar myUrl = 'https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml';\n// CORS 문제를 처리하기 위해 cors-anywhere 서비스를 사용함\nvar proxy = 'https://cors-anywhere.herokuapp.com/';\n\n// 요청 실행\nfetch(proxy + myUrl)\n  .then(response =\u003e response.text())\n  .then(xmlString =\u003e parseXML(xmlString))\n  .catch(error =\u003e console.error(error));\n\n// XML 데이터 파싱\nfunction parseXML(xmlString) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(xmlString, 'application/xml');\n\n  // 요소에 액세스\n  const posts = doc.getElementsByTagName('Post');\n  for (let i = 0; i \u003c posts.length; i++) {\n    const post = posts[i];\n    const postClass = post.getAttribute('class');\n    const postUser = post.getAttribute('user');\n    const postText = post.textContent.trim();\n\n    console.log('게시물 클래스:', postClass);\n    console.log('게시물 사용자:', postUser);\n    console.log('게시물 텍스트:', postText);\n\n    const terminals = post.getElementsByTagName('t');\n    for (let j = 0; j \u003c terminals.length; j++) {\n      const terminal = terminals[j];\n      const pos = terminal.getAttribute('pos');\n      const word = terminal.getAttribute('word');\n      console.log(`POS: ${pos}, 단어: ${word}`);\n      const divOutput = document.getElementById('divOutput');\n      if (divOutput) {\n        divOutput.innerHTML += `POS: ${pos}, 단어: ${word}\u003cbr\u003e`;\n      }\n    }\n    console.log();\n  }\n}\n```\n\n제공된 코드는 \"https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml\"에 위치한 XML 문서를 가져와 내용을 파싱하는 JavaScript 솔루션을 보여줍니다. 이 데이터는 NPS Internet Chatroom Corpus의 일부입니다.\n\n위의 JavaScript 코드는 fetch() API를 사용하여 HTTP 요청을 수행하고, 잠재적인 Cross-Origin Resource Sharing (CORS) 문제를 처리하기 위해 \"https://cors-anywhere.herokuapp.com/\"의 프록시 URL을 활용합니다. fetch 요청에서의 응답은 텍스트 형식으로 변환되며, XML 문자열이 가정적인 parseXML() 함수에 전달되어 추가 처리됩니다. 코드에는 또한 fetch나 파싱 작업 중 발생할 수 있는 문제를 기록하기 위한 오류 처리도 포함되어 있습니다.\n\nparseXML() 함수는 이전 코드 스니펫에서 가져온 XML 데이터를 파싱하는 역할을 합니다. 먼저 DOMParser 객체의 새 인스턴스를 생성하고, parseFromString() 메서드를 사용하여 XML 문자열을 Document 객체로 파싱합니다. 함수는 이후 파싱된 문서에서 모든 'Post' 요소를 검색하고, 각각의 'class', 'user' 및 텍스트 내용을 추출하여 콘솔에 기록합니다. 다음으로, 함수는 각 'Post' 요소 내부의 모든 't' (터미널) 요소를 가져와, 'pos' (품사) 및 'word' 속성을 추출하고, 이 정보를 콘솔에 기록하고 동시에 'divOutput' ID를 가진 HTML 요소에 추가합니다. 이 과정을 통해 함수는 XML 데이터를 파싱하고 관련 정보를 추출하여 이를 콘솔과 웹 페이지에 표시할 수 있게 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_2.png\" /\u003e\n\n# [3] Replit Code:\n\n코드를 사용하지 않는 방법을 선호하는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://jsonformatter.org/xml-parser\n- https://codebeautify.org/xml-parser-online\n\n# 🤓","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트 클로저 마스터하기 심층 탐험 ","description":"","date":"2024-06-20 01:23","slug":"2024-06-20-MasteringJavaScriptClosuresADeepDive","content":"\n\n자바스크립트 클로저는 이해하기 어려운 개념 중 하나입니다. 코드에서 클로저를 많이 사용할 수 있지만 그것을 사용하고 있다는 것을 깨닫지 못할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png)\n\n클로저에 대한 큰 영광은 Will Sentance와 Frontend master가 제공하는 JavaScript: The Hard Parts 강좌에 갑니다.\n\n클로저를 이해하기 위해 먼저 실행 컨텍스트를 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실행 컨텍스트란 무엇인가요?\n\n- 실행 컨텍스트: JavaScript에서 \"실행 컨텍스트\"란 코드가 실행되는 환경을 말합니다. 실행 컨텍스트에는 코드가 실행되는 동안 접근할 수 있는 변수, 함수, 객체 및 기타 데이터가 포함되어 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*9mMAag-MhCw8FKNtIP5WDA.gif)\n\n# 실행 컨텍스트의 종류:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전역 실행 컨텍스트: 이것은 기본 또는 가장 바깥에 있는 실행 컨텍스트입니다. 스크립트가 실행될 때 생성되며, 함수 내부에 없는 코드가 실행되는 곳입니다. 웹 브라우저에서는 전역 실행 컨텍스트가 윈도우 객체와 관련됩니다.\n- 함수 실행 컨텍스트: 함수가 호출될 때마다 해당 함수를 위한 새로운 실행 컨텍스트가 생성됩니다. 이 컨텍스트에는 함수 내에서 정의된 모든 변수, 객체 및 함수가 포함됩니다. 함수 실행이 완료되면 해당 실행 컨텍스트가 실행 스택(호출 스택)에서 제거됩니다.\n\n# 함수 실행 개요\n\n함수가 호출될 때, JavaScript는 함수가 올바르게 실행되도록 일련의 명확하게 정의된 단계를 수행합니다. 다음은 프로세스의 자세한 설명입니다:\n\n- 시작: 실행 컨텍스트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 실행 컨텍스트: 함수가 호출될 때 JavaScript는 해당 함수를 위해 새로운 실행 컨텍스트를 생성합니다. 이 컨텍스트에는 필요한 모든 매개변수, 변수 및 함수의 코드가 포함됩니다.\n- 호출 스택: 이 새로운 실행 컨텍스트는 호출 스택에 푸시됩니다. 이는 JavaScript가 함수 호출 순서를 관리하는 메커니즘입니다.\n\n- 실행: 라인별 처리\n\n- 라인별 실행: 함수의 실행 컨텍스트 내에서 JavaScript는 함수의 코드를 한 줄씩 처리합니다. 이는 변수 처리, 계산 수행 및 함수 내에서 정의된 다른 작업 실행을 포함합니다.\n- 스코프 체인과 클로저: 실행 중에 함수는 클로저 덕분에 자체 지역 변수, 전달된 매개변수 및 외부 범위의 변수에 액세스할 수 있습니다.\n\n- 종료: 정리 및 컨텍스트 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 함수 호출 스택에서 팝업: 함수가 실행을 완료하면 해당 실행 컨텍스트가 호출 스택에서 팝업됩니다. 이는 컨텍스트가 제거되어 JavaScript가 함수가 호출된 위치에서 코드를 계속 실행하게 됨을 의미합니다.\n- 지역 변수 정리: 함수의 실행 컨텍스트 내에서 정의된 지역 변수와 매개변수는 제거되어 메모리와 리소스를 해제합니다.\n\n# 명확성을 위한 예시:\n\n다음 함수의 실행을 자세히 살펴봅시다:\n\n```js\n1: const num = 3;\n2: function multiplyBy2(inputNumber) {\n3:   const result = inputNumber * 2;\n4:   return result;\n5: }\n6: const output = multiplyBy2(num);\n7: const newOutput = multiplyBy2(10);\n8: console.log(output);\n9: console.log(newOutput);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 1행: 전역 실행 컨텍스트에서 새로운 상수 변수 num을 선언하고 숫자 3을 할당합니다.\n- 2~5행: 여기서는 multiplyBy2라는 새로운 함수를 선언합니다. 전역 실행 컨텍스트에 multiplyBy2라는 새 변수를 생성하고 이에 함수 정의를 할당합니다. 이 함수는 inputNumber 매개변수를 받아들이고 그 값을 2배로 곱한 후 결과를 변수 result에 저장하고 반환합니다. 이 함수 내의 코드는 아직 평가되지 않았으며 나중 사용을 위해 저장됩니다.\n- 6행: 이 행은 간단해 보이지만 많은 일이 벌어집니다. 먼저, 전역 실행 컨텍스트에 새 변수를 선언하고 output이라고 이름 붙입니다. 이 변수는 처음에는 정의되지 않은 상태입니다.\n- 6행 (계속): 함수 multiplyBy2를 호출하여 output에 새 값을 할당할 것입니다. JavaScript 엔진은 전역 실행 컨텍스트에서 multiplyBy2를 찾아 함수 정의를 찾은 후 이를 실행할 준비를 합니다. 변수 num을 인자로 전달합니다. 엔진은 전역 실행 컨텍스트에서 값이 3인 num을 찾고 이 값을 함수에 전달합니다.\n- multiplyBy2를 위한 새 실행 컨텍스트: 새로운 로컬 실행 컨텍스트가 생성되어 여기에 multiplyBy2 실행 컨텍스트라고 부르겠습니다. 이 컨텍스트가 호출 스택에 푸시됩니다. 여기서 첫 번째 할 일은 함수 매개변수를 처리하는 것입니다. 이 로컬 실행 컨텍스트에서 새 변수 inputNumber가 선언되고 전달된 값인 3이 할당됩니다.\n- 3행: 로컬 실행 컨텍스트 내에서 새로운 상수 변수 result를 선언합니다. 처음에 result는 정의되지 않은 상태입니다. 그런 다음, 식 inputNumber * 2가 평가됩니다. 엔진은 inputNumber를 찾아 이 값을 3으로 가진 로컬 실행 컨텍스트에서 찾은 후 이를 2배로 곱하여 6을 얻습니다. 이 값은 result에 할당됩니다.\n- 4행: 결과 값인 6을 반환합니다. 로컬 실행 컨텍스트가 여기서 종료됩니다. 변수 inputNumber와 result는 파괴됩니다. 컨텍스트가 호출 스택에서 팝되고 반환 값 6이 호출 컨텍스트인 전역 실행 컨텍스트에 반환됩니다.\n- 6행 (계속): 반환된 값인 6이 output에 할당됩니다.\n- 7행: 비슷하게, 전역 실행 컨텍스트에서 다른 변수인 newOutput을 선언하고 인수 10을 사용하여 multiplyBy2를 호출한 결과를 할당합니다. 엔진은 다시 multiplyBy2를 찾고 호출하며 인수로 10을 전달합니다.\n- multiplyBy2를 위한 새 실행 컨텍스트 (두 번째 호출): 새로운 로컬 실행 컨텍스트가 생성되어 호출 스택에 푸시됩니다. 매개변수 inputNumber에 값 10이 할당됩니다.\n- 3행: 이 로컬 실행 컨텍스트에서 새로운 상수 변수 result를 선언하고 undefined로 초기화합니다. 식 inputNumber * 2가 평가됩니다. 엔진은 값이 10인 inputNumber를 찾아 2배로 곱한 후 20을 얻고 이 값을 result에 할당합니다.\n- 4행: 함수는 결과값인 20을 반환합니다. 로컬 실행 컨텍스트가 종료되고 변수 inputNumber와 result가 파괴됩니다. 컨텍스트가 호출 스택에서 팝되어 반환값 20이 호출 컨텍스트로 반환됩니다.\n- 7행 (계속): 반환된 값인 20이 newOutput에 할당됩니다.\n- 8행: output 값을 콘솔에 출력합니다. 콘솔에는 6이 표시됩니다.\n- 9행: newOutput 값을 콘솔에 출력합니다. 콘솔에는 20이 표시됩니다.\n\n이 자세한 설명은 JavaScript가 변수 선언, 함수 정의, 실행 컨텍스트의 생성 및 소멸을 처리하는 방식을 보여줍니다. 아직 클로저에 대해서 다루지는 않았지만, 함수와 스코프가 동작하는 기본적인 내용을 보여줌으로써 이해를 돕습니다.\n\n코드 실행을 확인하려면 JavaScript Visualizer (ui.dev)와 같은 도구를 사용할 수 있습니다.\n\n# 코드를 실행해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제에서 함수가 어떻게 실행되는지 배웠습니다. 이번 함수를 살펴보고 무슨 일이 일어날지 알아보겠습니다.\n\n```js\n1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n```\n\ncreateCounter 함수의 실행을 단계별로 자세히 살펴보겠습니다:\n\n- 1–8행: createCounter라는 함수를 정의합니다. 전역 실행 컨텍스트에서, createCounter라는 새 변수를 선언하고, 1부터 8까지의 함수 정의를 그에 할당합니다. 함수 내의 코드는 아직 실행되지 않고, 나중 사용을 위해 저장됩니다.\n- 9행: 전역 실행 컨텍스트에서 새 변수 increment를 선언합니다. 초기에는 이 변수가 정의되지 않습니다.\n- 9행(계속): createCounter 함수를 호출하고, 반환된 값을 increment에 할당합니다. JavaScript 엔진은 전역 실행 컨텍스트에서 createCounter를 찾아 함수 정의를 찾아 실행 준비를 합니다.\n- createCounter에 대한 새 실행 컨텍스트: createCounter 실행 컨텍스트라는 새로운 로컬 실행 컨텍스트가 생성됩니다. 이 컨텍스트는 호출 스택에 푸시됩니다.\n- 2행: 이 로컬 컨텍스트 안에서, 변수 counter를 선언하고 0으로 초기화합니다.\n- 3–6행: 새 constant 변수인 myFunction을 선언하고 함수 정의를 할당합니다. 이 함수는 counter 변수를 증가시키고 해당 값을 반환합니다.\n- 7행: myFunction 함수가 createCounter에 의해 반환됩니다. createCounter의 로컬 실행 컨텍스트가 종료되고, 컨텍스트는 호출 스택에서 팝됩니다. 변수 counter와 myFunction은 더 이상 이 컨텍스트에 존재하지 않습니다.\n- 9행(계속): 반환된 함수(myFunction과 해당 클로저)가 increment 변수에 할당됩니다. 이제 increment에는 myFunction에 저장된 함수 정의가 포함됩니다.\n- 10행: 전역 실행 컨텍스트에 새 변수 c1을 선언합니다.\n- 10행(계속): increment 함수를 호출하고, 반환 값을 c1에 할당합니다. JavaScript 엔진은 increment를 찾아 함수 정의를 찾아 실행 준비를 합니다.\n- increment에 대한 새 실행 컨텍스트: 이 함수 호출을 위한 새 로컬 실행 컨텍스트가 생성됩니다. 이 컨텍스트는 호출 스택에 푸시됩니다.\n- 4행: 이 로컬 컨텍스트 안에서, counter를 1만큼 증가시켜 업데이트합니다. 로컬 실행 컨텍스트에서 counter를 찾지만 찾을 수 없습니다. 따라서 전역 컨텍스트에서 찾지만 여전히 counter가 없습니다. JavaScript는 이를 undefined + 1로 해석하여 값이 1인 새로운 로컬 변수 counter를 만듭니다 (undefined가 여기서 0처럼 작동).\n- 5행: 함수는 counter의 값인 1을 반환합니다. 이로써 로컬 실행 컨텍스트가 종료되고 counter가 제거됩니다.\n- 10행(계속): 반환된 값인 1이 c1에 할당됩니다.\n- 11행: c2에 대해 9-14단계를 반복합니다. increment 함수가 다시 호출되고, 이번에도 1이 반환되어 c2에 할당됩니다.\n- 12행: c3에 대해 9-14단계를 반복합니다. increment 함수가 다시 호출되고, 이번에도 1이 반환되어 c3에 할당됩니다.\n- 13행: 마지막으로, c1, c2 및 c3의 값이 콘솔에 로깅됩니다. 콘솔에는 \"example increment 1 1 1\"이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 설명에 따르면 1, 1, 1을 기대할 수 있지만, 실제로는 1, 2, 3이 출력됩니다. 여기서 무슨 일이 벌어지고 있는 걸까요?\n\nincrement 함수가 어떻게 counter의 값을 기억한다는 거죠?\n\ncounter가 전역 실행 컨텍스트의 일부인가요? console.log(counter)를 해보면 undefined를 보게 될 것입니다. 그러니 그것도 아닙니다.\n\nincrement를 호출할 때, 어떻게 그것이 생성된 함수인 createCounter로 돌아가는 걸까요? 그런데 변수 increment는 함수 정의를 포함하고 있는데, 어떤 컨텍스트에서 왔는지는 포함하고 있지 않습니다. 그러니 그것도 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 다른 메카니즘이 작용하고 있을 수 있어요.\n그리고 있죠: \"클로저\"가 있습니다. 이것이 부재한 부분입니다.\n\n작동 방식은 다음과 같습니다. 새 함수를 선언하고 변수에 할당할 때, 함수 정의뿐만 아니라 클로저도 함께 저장됩니다. 클로저는 함수가 생성될 때 범위 내에 있는 모든 변수를 포함합니다. 가방처럼 생각해 보세요. 함수 정의는 모든 변수를 함께 저장하는 작은 가방을 가지고 있습니다. 함수를 호출할 때 increment를 호출하면 함수 정의뿐만 아니라 함수가 정의될 때 범위 내에 있던 변수도 사용됩니다. 따라서 counter는 increment를 호출할 때마다 값을 계속 유지합니다. 이는 전역 실행 컨텍스트의 일부가 아니지만 클로저 덕분에 기억되는 것입니다.\n\n따라서 우리가 위에서 설명한 것은 전혀 틀렸어요. 다시 시도해 보죠, 이번에는 올바르게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n```\n\n위 코드는 createCounter 함수의 실행을 자세히 살펴보겠습니다.\n\n- 1–8번 줄: createCounter라는 함수를 정의합니다. 전역 실행 컨텍스트에서 createCounter 변수를 선언하고 1부터 8까지의 함수 정의를 할당합니다. 함수 내부의 코드는 아직 실행되지 않고 나중에 사용할 준비만 되어 있습니다.\n- 9번 줄: 전역 실행 컨텍스트에서 increment 변수를 초기화합니다.\n- 9번 줄 (계속): createCounter 함수를 호출하고 반환된 값을 increment에 할당합니다. JavaScript 엔진은 전역 실행 컨텍스트에서 createCounter를 검색하여 함수 정의를 찾고 실행 준비를 합니다.\n- createCounter를 위한 새로운 실행 컨텍스트: createCounter 실행 컨텍스트라는 새로운 로컬 실행 컨텍스트가 생성되고 호출 스택에 푸시됩니다.\n- 2번 줄: 이 로컬 컨텍스트 내에서 counter 변수를 선언하고 0으로 초기화합니다.\n- 3–6번 줄: 새 상수 변수 myFunction을 선언하고 함수 정의를 할당합니다. 이 함수는 counter 변수를 증가시키고 해당 값을 반환합니다. 여기서 클로저가 생성됩니다. 클로저에는 함수 정의 내부의 counter 변수의 현재 값(0)이 포함됩니다.\n- 7번 줄: myFunction 함수(및 클로저)가 createCounter에 의해 반환됩니다. createCounter의 로컬 실행 컨텍스트가 종료되고 컨텍스트가 호출 스택에서 팝됩니다. 이 컨텍스트에는 더 이상 counter 및 myFunction 변수가 존재하지 않습니다. 그러나 myFunction은 클로저를 통해 counter에 대한 액세스 권한을 유지합니다.\n- 9번 줄 (계속): 반환된 함수(myFunction 및 클로저)가 increment 변수에 할당됩니다. 이제 increment에는 myFunction에 저장된 함수 정의가 포함되어 있습니다.\n- 10번 줄: 전역 실행 컨텍스트에서 새 변수 c1를 선언합니다.\n- 10번 줄 (계속): increment 함수를 호출하고 반환 값을 c1에 할당합니다. JavaScript 엔진은 increment를 검색하여 함수 정의를 찾고 실행 준비를 합니다.\n- increment를 위한 새로운 실행 컨텍스트: 이 함수 호출을 위한 새로운 로컬 실행 컨텍스트가 생성되어 increment 실행 컨텍스트로 명명됩니다. 이 컨텍스트가 호출 스택에 푸시됩니다. 이 로컬 컨텍스트에서 처음으로 할 일은 클로저를 사용하는 것입니다.\n- 4번 줄: 이 로컬 컨텍스트 내에서 counter를 1씩 증가시켜 업데이트합니다. 클로저 내에 counter가 있으므로 해당 값(0)이 검색되어 1로 증가되고 클로저에 업데이트됩니다.\n- 5번 줄: 함수는 업데이트된 counter의 값을 반환합니다(1). increment의 로컬 실행 컨텍스트가 종료되어 컨텍스트가 호출 스택에서 팝됩니다.\n- 10번 줄 (계속): 반환된 값(1)이 c1에 할당됩니다.\n- 11번 줄: c2에 대해 단계 9–14를 반복합니다. increment 함수가 다시 호출되고 클로저의 counter 값(1)이 2로 증가되어 2가 반환되고 c2에 할당됩니다.\n- 12번 줄: c3에 대해 단계 9–14를 반복합니다. increment 함수가 다시 호출되고 클로저의 counter 값(2)이 3으로 증가되어 3이 반환되고 c3에 할당됩니다.\n- 13번 줄: 마지막으로 c1, c2 및 c3의 값을 콘솔에 로깅합니다. 콘솔은 example increment 1 2 3를 표시합니다.\n\n이런 상황이 벌어지는 이유는 무엇일까요? 함수가 선언될 때 함수 정의뿐만 아니라 클로저도 함께 포함되기 때문입니다. 클로저는 함수가 생성된 시점의 모든 스코프에 있는 변수들의 집합입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n글로벌 범위에서 생성된 함수도 클로저를 가지고 있는지 궁금할 수 있습니다. 그 답은 네입니다. 글로벌 범위에서 생성된 함수도 클로저를 가지고 있지만, 글로벌 범위에서 정의되어 있기 때문에 모든 전역 변수에 접근할 수 있어 클로저 개념이 덜 중요해집니다.\n\n클로저는 함수가 다른 함수를 반환할 때 매우 중요해집니다. 반환된 함수는 글로벌 범위에 없지만 해당 클로저에 존재하는 변수에 접근할 수 있습니다.\n\n요약하면 인크리먼트 함수는 클로저를 통해 카운터의 값을 기억합니다. 인크리먼트를 호출할 때마다 카운터 값을 업데이트하고 반환하여 클로저를 통해 자신의 렉시컬 범위에 대한 액세스를 유지하는 방법을 보여줍니다. 이것이 JavaScript에서의 클로저의 본질입니다: 이들은 함수가 생성된 환경을 \"기억\"하도록 하여 함수가 그것들을 생성한 함수가 실행을 완료한 후에도 자신의 렉시컬 범위에 대한 액세스를 유지할 수 있도록합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 수업에서 윌 센튼스가 훌륭한 유사성을 제시했어요:\n\n이제 클로저에 대해 이해하셨으면 좋겠어요. 감사합니다🙌","ogImage":{"url":"/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png","tag":["Tech"],"readingTime":10},{"title":"리액트 네이티브에서 다중 모달 지원하기 새로운 방식","description":"","date":"2024-06-20 01:20","slug":"2024-06-20-SupportingMultipleModalsinReactNativeANewApproach","content":"\n\n## 여러 모달을 관리하는 것은 React Native의 표준 모달 구현 및 인기있는 서드 파티 라이브러리에서 볼 수 있는 제한 사항입니다. 이 문제에 대한 우리만의 접근 방식 및 우리의 rn-modal-presenter 라이브러리 사용 방법을 알아보세요.\n\n바이 화이트 스펙트어 React Native 팀\n\n![이미지](/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png)\n\n이 기사는 화이트 스펙트어 React Native 팀 구성원인 Lucas Diez de Medina와 Rui Lu가 공동 저술했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어플 빌드를 위한 조사 중에, 현재 React Native 표준 모달 구현이 동시에 여러 모달을 관리하지 못한다는 사실을 발견했습니다. 인기 있는 서드 파티 라이브러리들도 비슷한 제한을 가지고 있어서 우리에겐 작동하지 않았습니다. 더욱 복잡한 React Native 앱일수록 더 많은 제약이 생길 것입니다. 더 나쁜 점은, 에러가 발생할 수 있지만 눈에 띄지 않을 수도 있습니다.\n\n그래서 우리는 우리만의 간단한 방법을 만들기로 결정했고, rn-modal-presenter 라이브러리를 출시했습니다. 우리가 발견한 사항과 여러분의 React Native 프로젝트에 우리 라이브러리를 사용하는 방법을 알아보려면 계속 읽어주세요.\n\n이 글에서 다루는 내용은 다음과 같습니다:\n\n- 서드 파티 모달 라이브러리의 제한 사항\n- 테스트한 대안\n- 우리의 해결책: rn-modal-presenter 라이브러리\n- rn-modal-presenter 라이브러리 구현 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nrn-modal-presenter 라이브러리의 전체 문서를 npm 및 GitHub에서 읽어보세요.\n\n# 서드파티 Modal 라이브러리의 제한 사항\n\n이제 위에서 언급한 대로, React Native에서 모달이 얼마나 중요한지는 알 수 있지만, 표준 구현은 몇 가지 중요한 제한 사항을 갖고 있습니다. 이는 사용자에게 다른 상황에서 여러 모달을 표시하려고 시도했을 때 우리가 발견한 것입니다.\n\n모달은 일반적으로 프롭을 기반으로 표시되거나 숨겨지는 컴포넌트이며, 이 프롭은 일반적으로 표시하는 컴포넌트의 상태에 의해 제어됩니다. 해당 컴포넌트는 컴포넌트 트리의 일부여야 하며 표시하고 싶은 모든 컴포넌트의 자식으로 나타나야 합니다. 이러한 이유로 하나의 컴포넌트로 표시되는 여러 모달을 표시하려는 경우나 모달이 표시되는 별도의 화면으로 이동해야 하는 경우에 기본적인 제한 사항과 복잡성이 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 번역하면 다음과 같습니다:\n\n- 모달을 제어하는 상태를 관리해야 합니다.\n- 상태를 업데이트함으로써 모달의 표시 및 숨김을 동시에 처리해야 합니다 (표시하는 컴포넌트 내에서).\n- 특정 컴포넌트에서 모달을 표시한 후에 뒤로 이동하려면, 표시하는 컴포넌트가 언마운트되므로 모달도 사라집니다.\n- iOS에서는 동시에 두 개 이상의 모달을 표시하거나 서로 겹치는 여러 모달을 스택으로 관리할 수 없습니다: https://github.com/react-native-modal/react-native-modal/issues/30\n\n마지막으로, 이 제한 사항은 iOS 네이티브 측면에 있습니다. UIViewController가 다른 뷰 컨트롤러를 표시한 후, 표시 중인 뷰 컨트롤러 (이제 숨겨진 상태)가 해당 뷰 컨트롤러 위에 다른 두 번째 뷰 컨트롤러를 표시할 수 없습니다. 따라서 이전에 표시된 뷰 컨트롤러에서 두 번째 뷰를 표시해야 합니다.\n\n# 간단한 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 예제로이 한계를 확인해 보겠습니다. 여기서는 전통적인 모달을 사용하여 앱 평가를 받으려고 시도하지만, 특정 상황에서만 만족한 사용자에게만 보여줍니다.\n\n사용자가 앱에서 관련 작업을 수행한 후에는 다음을 보여줍니다:\n\n- 작업이 완료되었음을 알리는 모달\n- 앱에 대해 얼마나 만족하는지 묻는 모달\n\n- 긍정적인 답변일 경우 AppStore에서 앱 평가를 요청하는 모달을 보여줍니다.\n- 부정적인 답변인 경우 피드백을 남겨 주시라는 모달을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 모든 이 modal들이 같은 메인 화면에서 제시되며 이 코드 스니펫에서 볼 수 있듯이 네 가지 다른 modal에 대한 모든 상태를 가지고 있으며 그 상태에 따라 각 modal을 표시합니다.\n\n```js\nconst App = () =\u003e {\n const [showRateAppModal, setShowRateAppModal] = useState(false);\n const [showAppRatedPositiveModal, setShowAppRatedPositiveModal] = useState(false);\n const [showAppRatedNegativeModal, setShowAppRatedNegativeModal] = useState(false);\n const [showActivateGadgetModal, setShowActivateGadgetModal] = useState(false);\n \n return (\n   \u003cSafeAreaView\u003e\n     {showActivateGadgetModal \u0026\u0026 (\n       \u003cActivateGadgetModal\n         onDismiss={() =\u003e {\n           setShowActivateGadgetModal(false);\n         }\n       /\u003e\n     )}\n     {showRateAppModal \u0026\u0026 (\n       \u003cRateAppModal\n         positiveFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedPositiveModal(true);\n         }\n         negativeFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedNegativeModal(true);\n         }\n       /\u003e\n     )}\n     {showAppRatedPositiveModal \u0026\u0026 (\n       \u003cPositiveFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedPositiveModal(false)}\n       /\u003e\n     )}\n     {showAppRatedNegativeModal \u0026\u0026 (\n       \u003cNegativeFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedNegativeModal(false)}\n       /\u003e\n     )}\n     \u003cButton\n       title=\"Activate Gadget\"\n       onPress={() =\u003e {\n         setShowActivateGadgetModal(true);\n         setShowRateAppModal(true);\n       }\n     /\u003e\n   \u003c/SafeAreaView\u003e\n );\n};\n```\n\n이 상호작용은 상태를 같은 컴포넌트에서 제어하기 때문에 매우 간단합니다. 또한 우리는 저장소(store)를 가지고 있지 않습니다. 이미 4개의 상태 변수를 가지고 있는 저장소를 관리하고 있는데, 이것은 계속해 추가할수록 더 복잡해집니다.\n\n이제 실수로 두 개의 modal을 동시에 표시하려고하면 어떻게 작동하는지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 첫 번째 모달이 iOS에서만 표시될 것이며, 이 문제의 가장 나쁜 부분은 React Native 콘솔에서는 오류가 발생하지 않았다는 것입니다.\n\n그러나 Xcode 콘솔을 확인하면 현재 다른 View Controller 위에 View Controller를 표시하려고 시도하고 있는 것이 iOS 시스템에서 올바르지 않은 동작임을 알 수 있습니다.\n\n보게 될 오류는 다음과 같습니다:\n\n```js\nWarning: Attempt to present \u003cUIViewController: 0x147d2c6b0\u003e on \u003cUIViewController: 0x147d614c0\u003e which is already presenting (null)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS에서 올바른 흐름은 첫 번째 모달을 표시한 후에, 첫 번째 모달이 해제되면(해당 상태 변수를 false로 설정함으로써) 다음 모달의 상태 변수를 true로 설정하여 표시하는 것입니다.\n\n상상할 수 있듯이, 이것은 매우 복잡해질 수 있습니다. 대부분의 경우 개발자들은 여러 모달의 해제와 표시를 관리하기 위해 지연 또는 시간 초과를 사용합니다. 이로 인해 예기치 못한 오류가 발생하며 실제로 모달 애니메이션 지속 시간은 앱이 실행되는 기기에 따라 다를 수 있습니다.\n\n요약하면, 여기서 직면한 문제는 표시 컴포넌트가 모든 로직 및 상태 관리를 처리해야 하고 표시하려는 각 모달마다 하나의 상태 변수가 필요하다는 것입니다.\n\n우리에게 가장 큰 문제는 한 가지 실수를 하게 되면, 두 개의 모달을 동시에 표시하려고 한다면 두 번째 모달이 나타나지 않고 오류/경고 메시지도 표시되지 않는다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시도한 대체품\n\n리액트 네이티브 프로젝트에서 여러 모달을 관리하는 데 직면할 수 있는 두 가지 일반적인 문제는 다음과 같습니다:\n\n- 동시에 하나 이상의 모달을 표시할 수 없음\n- 모달이 더 많이 추가될수록 코드 복잡성이 기하급수적으로 증가함\n\n이러한 두 가지 문제로 인해 표준 네이티브 모달 컴포넌트를 사용하면서 이를 해결하기 위해 다양한 옵션을 시도해 보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에는 여기서 가장 일반적으로 사용되는 2개의 라이브러리가 있으며, 이들을 사용한 이유와 우리가 고유한 방식으로 진행하기로 결정한 이유를 설명했습니다.\n\n# react-native-modal\n\n이는 표준 React Native Modal 컴포넌트의 확장입니다. 기존 기능에 추가적인 기능을 제공하여 들어오는/나가는 애니메이션 타이밍을 지정할 수 있거나 다른 콜백을 제공하여 API를 사용자 정의할 수 있습니다. 또한 기기 방향에 따라 스와이프할 수 있고 스크롤 가능하며 적응적인 콘텐츠를 제공합니다.\n\n하지만 이러한 기능이 얼마나 좋든, 이 라이브러리는 결국 React Native에서 모달이 작동하는 방식을 변경하지 않기 때문에 여전히 동시에 여러 모달을 표시하거나 코드 복잡성을 줄이는 등 위에서 언급한 같은 제한 사항을 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# react-native-modalfy\n\n이 라이브러리는 이전 것보다 훨씬 인기가 적지만, 우리가 달성하고자 하는 방향과 일치합니다.\n\n첫 번째 이점은 JavaScript로 구현되어 여러 모달을 지원한다는 것입니다. 코드의 어느 곳에서든 JavaScript 함수를 호출할 수 있으며, 컴포넌트 트리를 혼동시키지 않고 추가적인 상태를 관리할 필요가 없습니다.\n\n다른 중요한 점은 명령형 API를 기반으로 하고 있으며, 각 모달의 외형에 대한 애니메이션과 전환을 완전히 사용자 정의할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 장점들에도 불구하고, 이 라이브러리는 설정하기 위해 일부 뼈대 코드가 필요했습니다. 이런 면에서 React Navigation과 매우 유사합니다. 여러분은 프로젝트 내에서 사용할 각 모달을 미리 정의하고 각각에 대한 구성을 제공해야 합니다.\n\n또 다른 단점은 동일한 모달 유형의 여러 인스턴스를 표시하거나 숨기지 못한다는 것입니다. 같은 스타일을 공유하는 다양한 버튼과 복사본을 가진 다수의 모달이 있는 애플리케이션에서는, 다양한 모달 엔티티를 만드는 대신 서로 다른 복사본을 위한 특정 매개변수를 가진 하나의 모달만 가지는 것이 더 효율적입니다.\n\n# 우리의 해결책: rn-modal-presenter\n\n다양한 옵션을 분석한 후, 우리는 다음 기반으로 우리만의 라이브러리를 만들기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유연한 구성요소와 명령형 API\n\n유연하다는 의미는 어떤 구성요소든 모달로 표현할 수 있고, 상태를 수정하지 않고 코드의 어디서든(표시된 모달 내에서도) 표시/감춤을 관리할 수 있다는 것입니다.\n\n명령형 API를 사용하면 앱 전체 위에 모달이 표시되므로 어디서든 모달 표시를 트리거할 수 있습니다.\n\n# 콘텐츠는 부모 구성요소(보통 귀하의 구성요소) 위에 표시됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 부보 컴포넌트는 우리 라이브러리에서 노출되었고, 여러분은 해당 컴포넌트 트리 어딘가에 배치해야 합니다. 이것은 모달 창이 다른 일반 뷰와 화면에 비해 가장 높은 우선순위를 가지고 있기 때문에 멋집니다.\n\n# 다중 모달 지원\n\n100% 자바스크립트 라이브러리이기 때문에 여러 개의 모달을 쉽게 표시할 수 있습니다. 또한 동일한 모달 유형의 여러 인스턴스를 표시하는 것을 지원합니다.\n\n그러나 이에는 조금 제한이 있습니다. 자바스크립트 솔루션이기 때문에 프로젝트에 다른 네이티브 모달이 있는 경우, 해당 나중 모달은 여전히 우리 모달 위에 있을 수 있습니다. 왜냐하면 네이티브 컴포넌트가 가장 높은 우선순위를 가지기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리 통합 방법\n\n단계 1: 프로젝트에 라이브러리 추가하기:\n\n- yarn add @whitespectre/rn-modal-presenter\n- npm install @whitespectre/rn-modal-presenter\n\n단계 2: 모달을 표시하고 싶은 컴포넌트 위에 래핑하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { ModalPresenterParent, showModal } from '@whitespectre/rn-modal-presenter';\n…\n\u003cModalPresenterParent\u003e\n  \u003cApp /\u003e\n\u003c/ModalPresenterParent\u003e\n```\n\n제 3단계: showModal 메소드를 호출하세요. 이 메소드는 다음을 받습니다:\n\n- 보여질 컴포넌트\n- 해당 컴포넌트로 전달될 속성\n- 나중에 모달을 해제하는 데 사용할 ModalHandler를 반환합니다.\n\n```js\nexport declare const showModal: \u003cContentProps\u003e(\n  Content: (props: ContentProps \u0026 ModalContentProps) =\u003e JSX.Element,\n  contentProps: ContentProps,\n) =\u003e ModalHandler;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다야. 충분히 준비됐어요.\n\n## 더 복잡한 구현\n\n### 컴포넌트에 속성 전달하기\n\n모달 위에 표시하려는 컴포넌트에 속성을 추가하려면 컴포넌트에 도우미 함수를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 showModal 함수를 호출하는 helper 함수를 만들 수 있습니다. 이 함수는 사용자에게 보여줄 텍스트와 사용자가 닫기 버튼을 눌렀을 때 실행할 완료 핸들러를 받는데, 이것은 custom text modal이 받는 속성을 받게 됩니다.\n\n```js\nexport const showCustomAlert = (\n  title: string,\n  body: string,\n  buttons: CustomAlertButton[] = [defaultButton],\n) =\u003e {\n  return showModal(CustomAlert, { title, body, buttons });\n};\n```\n\n## 컴포넌트 속성에 ModalContentProps 추가하기\n\n이 기능은 컴포넌트를 설치할 때 라이브러리에 의해 제공되며, dismiss 함수를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst CustomAlert = ({\n  dismiss,\n  title,\n  body,\n  buttons\n}: CustomAlertProps \u0026 ModalContentProps) =\u003e {\n  return (\n    …\n```\n\n여기에는 모달 컴포넌트 속성으로 반환된 dismiss 함수를 전달하고 해당 dismiss를 모달 내에서 모달을 지우는 데 사용합니다.\n\n## 새 라이브러리를 사용한 원본 예제\n\nrn-modal-presenter 라이브러리를 사용하면 상태를 관리할 필요가 없고 어디에서든 모달 표시를 강제로 트리거할 수 있기 때문에 원본 예제는 다음과 같이 다시 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인 앱 컴포넌트는 Gadget Activation 모달을 표시할 것입니다:\n\n```js\nconst App = () =\u003e {\n  return (\n    \u003cModalPresenterParent\u003e\n      \u003cSafeAreaView\u003e\n        \u003cButton\n          title=\"Gadget 활성화\"\n          onPress={() =\u003e {\n            showModal(ActivateGadgetModal, {});\n          }\n        /\u003e\n      \u003c/SafeAreaView\u003e\n    \u003c/ModalPresenterParent\u003e\n  );\n};\n```\n\n그리고 각 모달은 자체적으로 dismiss하고, 흐름에서 다음 모달을 표시하는 책임이 있을 것입니다. 예를 들어, ActivateGadgetModal은 아래와 같이 보일 것입니다:\n\n```js\nconst ActivateGadgetModal = ({dismiss}: ModalContentProps) =\u003e {\n  return (\n    \u003cView style={styles.modalOverlay}\u003e\n      \u003cView style={styles.modal}\u003e\n        \u003cView style={styles.contentContainer}\u003e\n          \u003cText\u003e당신의 Gadget이 활성화되었습니다\u003c/Text\u003e\n          \u003cView style={styles.buttonsContainer}\u003e\n            \u003cButton\n              title=\"닫기\"\n              onPress={() =\u003e {\n                dismiss();\n                showModal(RateAppModal, {});\n              }\n            /\u003e\n          \u003c/View\u003e\n        \u003c/View\u003e\n      \u003c/View\u003e\n    \u003c/View\u003e\n  );\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미래 개선 사항\n\nrn-modal-presenter 라이브러리는 현재 진행 중인 프로젝트에 우리의 요구 사항에 맞게 만들어 졌지만, 사용하면서 다른 기능과 개선 사항들을 확인했습니다. 다른 사용 사례에 유용할 수 있는 것들입니다.\n\n여기 우리 라이브러리에 도입하고 싶은 주요 기능 및 개선 사항입니다:\n\n- 하나씩 보이도록 모달의 대기열 만들기\n- 현재 여러 개의 모달이 동시에 표시되려고 하면 서로 위에 겹쳐서 나타납니다.\n- 대기열은 우선순위 매커니즘을 포함하여 강제로 다음 모달을 표시할 수 있어야 합니다.\n- 뷰가 네이티브 뷰들 위에 나타날 수 있도록 만들기\n- 더불어 네이티브 모듈을 구축하여 내용을 네이티브 뷰 위에 표시할 수 있도록 하기\n- 각 효과에 대해 사용자 정의 가능한 애니메이션 및 지속 시간 허용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이러한 기능 중 어떤 것을 구현하고 싶거나 우리 라이브러리에 기여하고 싶다면, 언제든지 다음 링크에서 PR을 열어주세요: [https://github.com/whitespectre/rn-modal-presenter](https://github.com/whitespectre/rn-modal-presenter).","ogImage":{"url":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png"},"coverImage":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png","tag":["Tech"],"readingTime":11},{"title":"Nx 암시적 라이브러리 숨겨진 보물 ","description":"","date":"2024-06-20 01:19","slug":"2024-06-20-NxImplicitLibrariesTheHiddenGem","content":"\n\nNx가 제공하는 엄청난 기능을 활용하기 위해, 여러 라이브러리로 애플리케이션을 분할하는 것이 일반적입니다. 사실, 애플리케이션을 라이브러리로 분리하는 것은 관심사와 경계를 명확히 분리하고, Nx의 캐싱, 그래프 및 병렬화 덕분에 빠른 작업 실행을 제공한다는 장점 중 하나입니다.\n\n그러나 여러 라이브러리를 만들면 각 라이브러리 사이에 일부 중복된 구성이 있음을 알 수 있을 것입니다.\n\n이러한 파일들은 작업 공간을 혼란스럽게 만들고 더 많은 라이브러리를 생성하는 것을 꺼리게 할 수 있습니다.\n\n다음은 최근 생성된 웹 라이브러리의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlibs\n└── web\n    └── catalog\n        └── ui\n            ├── README.md\n            ├── src\n            │   ├── index.ts\n            │   └── lib\n            │       ├── catalog.spec.ts\n            │       └── catalog.ts\n            ├── eslint.config.js\n            ├── project.json\n            ├── tsconfig.json\n            ├── tsconfig.lib.json\n            ├── tsconfig.spec.json\n            ├── vite.config.ts\n            └── vitest.config.ts\n```\n\n# 💎 프로젝트 크리스탈\n\n버전 18부터 (사실 그 전부터 조금씩), Nx는 프로젝트 구조를 기반으로 작업을 추론할 수 있게 되었습니다. 이는 Nx 플러그인이 새로운 대상을 자동으로 추가할 수 있게 해줍니다(예: Vitest 구성 파일을 감지하면 적절한 구성으로 테스트 대상을 암시적으로 추가). 이것을 프로젝트 크리스탈이라고 합니다.\n\n이를 통해 project.json 파일에서의 중복이 줄어들고 더 중앙 집중화된 구성이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로젝트 크리스털 이전\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png)\n\n## 프로젝트 크리스털 이후\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🪄 암시적 라이브러리\n\n프로젝트 Crystal은 프로젝트.json 파일에서 중복 구성을 줄입니다. 그런데 만약 프로젝트.json 파일을 완전히 제거할 수 있다면 어떨까요?\n\nNx 추론을 사용하면 Nx 그래프에 노드를 추가하거나 기존 노드를 보강하는 플러그인을 만들 수 있습니다 (예: 라이브러리 선언 노드 추가) 또는 기존 노드를 보강할 수도 있습니다. 프로젝트.json 파일에 남아 있는 정보는 프로젝트 구조에서 쉽게 유도할 수 있기 때문에 (관례가 있다고 가정할 때), 프로젝트.json 파일에서 남은 정보를 추론하고 이 파일을 간단히 제거할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📂 공유 설정\n\n프로젝트의 json 파일을 라이브러리에서 제거하는 데 성공했지만, eslint.config.js, tsconfig.json, vite.config.ts, vitest.config.ts 등 다른 구성 파일은 어떨까요?\n\n이러한 파일들을 완전히 제거하는 것이 유혹적일 수 있지만, 다른 도구와 IDE(예: IDE lint 플러그인, WallabyJS와 같은 테스트 러너 등)에 여전히 유용하므로 그대로 두는 것이 좋습니다.\n\n그러나 특정 그룹 내의 대부분의 라이브러리가 유사한 구성을 공유하기 때문에 이러한 구성 파일을 상위 그룹 디렉토리로 이동시킬 수 있습니다. 이전 예에서는 libs/web 디렉토리가 해당됩니다. 이렇게 하면 IDE 및 다른 도구가 여전히 구성을 인식할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🎯 암시적 라이브러리의 대상\n\n프로젝트.json을 제거하고 구성 파일을 공유 구성으로 교체한 후, 대부분의 Nx 내장 플러그인은 대상 구성을 자동으로 추정할 수 없게 됩니다.\n\nImplicit Libraries 플러그인을 수정하여 라이브러리를 생성하는 것뿐만 아니라 필요한 대상을 추가해야합니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공유된 구성 및 대상을 제대로 설정하여 작업이 라이브러리 파일에서만 실행되도록 해야 합니다.\n\n언급할 가치가 있는 점은 일부 도구(Eslint 및 Vitest 등)가 라이브러리의 루트를 현재 작업 디렉토리로 실행해야 합니다:\n\n```js\n{\n  ...,\n  targets: {\n    lint: {\n      command: 'eslint',\n      options: {cwd: projectRoot},\n      ...\n    },\n    ...\n  }\n}\n```\n\n# 🏷️ 추론된 태그\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 Implicit Libraries 플러그인은 당신의 프로젝트 구조와 규칙을 인식합니다. 이는 경계를 강제하거나 작업을 실행할 때 필터링하기 쉽도록 태그를 추가할 수 있습니다.\n\n이는 라이브러리가 잘못 태그되는 것을 방지하고 프로젝트 구조가 라이브러리 카테고리를 반영하도록 보장합니다.\n\n![Implicit Libraries](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_4.png)\n\n# 🏗️ Implicit Libraries Generators\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성기가 Implicit Libraries에 대해 쓸모없어 보일 수 있지만, tsconfig.base.json의 경로를 업데이트하는 데 사용될 수 있어 유용합니다. 개발자에게 올바른 카테고리(예: 플랫폼, 범위, 유형)를 제공하여 유효한 라이브러리 경로를 생성할 수 있습니다.\n\n# 🧩 도전과 주의할 점\n\nImplicit Libraries는 워크스페이스의 구성 파일 수를 줄이고 개발자가 더 많은 라이브러리를 생성하도록 장려하는 좋은 방법이지만, 다음과 같은 관련 도전에 대해 인식해야 합니다:\n\n- 대부분의 Nx 내장 플러그인은 project.json 파일을 사용하여 대상 구성을 추론합니다. 이는 Implicit Libraries 플러그인을 수정하여 필요한 대상을 추가해야 한다는 것을 의미합니다.\n- 대상 옵션을 사용하여 도구의 모든 옵션을 항상 쉽게 제어할 수 있는 것은 아닙니다. 예를 들어, 현재 Vitest 옵션에는 캐시 디렉토리를 재정의할 수 있는 방법이 없습니다. 해결책은 현재 작업 디렉토리를 사용하여 계산하는 것이지만, 이는 Nx 일괄 처리 모드와 간섭할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📖 Marmicode Cookbook\n\n만약 Nx 및 다른 내용에 대해 더 알고 싶다면, Marmicode Cookbook을 확인해보세요!\n\n![image](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_5.png)\n\n# 📚 추가 자료\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 💻 암시적 라이브러리 예제\n- 📝 Nx 암시적 라이브러리 | Marmicode Cookbook\n- 📝 Nx 프로젝트 크리스탈의 매력 발견하기 | 조나단 젤린\n- 📺 프로젝트 크리스탈 | Nx\n- 📺 Nx로 프로젝트 재정의: 새로운 추론 API 탐구 | 크레이거리 코폴라","ogImage":{"url":"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png"},"coverImage":"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png","tag":["Tech"],"readingTime":4},{"title":"GitHub Copilot의 탑 10 기능","description":"","date":"2024-06-20 01:18","slug":"2024-06-20-Top10GitHubCopilotFeatures","content":"\n\n## 더 행복하고 생산적인 개발자가 되어보세요\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png)\n\nGitHub Copilot은 인공 지능 기술을 활용한 페어 프로그래밍 도구로, 빠르게 코딩하고 생산성을 향상시킬 수 있습니다.\n\n이 글에서는 GitHub Copilot의 최고 10가지 기능에 대해 이야기해볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 워크스페이스 에이전트\n\nCopilot @workspace agent은 우리의 코드를 강화하여 워크스페이스의 전체 맥락을 분석하고 이해함으로써 프로젝트의 아키텍처와 의존성과 일치하는 권장 사항을 제공할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_1.png)\n\n# 2. 코딩 질문하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 확실하지 않거나 기억하지 못하는 경우, 문서를 찾아보거나 구글 검색하지 않고도 Copilot에게 문법이나 일반 프로그래밍 개념에 대해 물어보세요. Copilot은 자연어나 코드 스니펫 형식으로 답변을 제공합니다. 예를 들어, 배열의 합을 계산하는 방법에 대해 물어보는 등의 질문을 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_2.png)\n\n또한, 코드의 동작이나 작동 방식을 이해하고 싶은 경우, 설명을 요청할 수 있습니다.\n\n![다른 이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 코드 완성\n\n코딩을 시작하면 Copilot은 파일의 컨텍스트를 분석하고 편집기에서 제안을 제공합니다. 예를 들어, arraySum이라는 메서드 이름을 입력하면 Copilot이 코딩 스타일과 일치하는 구현을 제안합니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_4.png)\n\n# 4. 코드 리팩터링 및 개선\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCopilot에 선택한 코드를 리팩토링하거나 개선할 것을 요청할 수 있습니다. 이는 우리 코드베이스의 맥락을 활용하여 리팩터링이나 개선 사항을 분석하고 제안할 것입니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_5.png)\n\n## 5. 수정해주세요\n\n코드에 오류나 경고가 있는 경우, Copilot은 오류 메시지, 코드 구문 및 주변 코드를 기반으로 가능한 수정 사항을 제안할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_6.png)\n\n# 6. 유닛 테스트 케이스 생성\n\nCopilot은 우리의 테스트 프레임워크와 코딩 스타일을 식별하고 오류, 널 값 또는 예기치 않은 입력 데이터 유형을 다루기 위한 테스트 케이스를 제안합니다.\n\n이전 arraySum 함수에 대한 테스트 케이스를 생성해 보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_7.png\" /\u003e\n\n생성된 테스트 케이스:\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_8.png\" /\u003e\n\n# 7. 커밋 메시지 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 커밋 메시지를 작성하기 귀찮다면, Copilot이 우리를 위해 작성해줄 거예요. VS Code에서 커밋 메시지 텍스트 상자 옆의 화문 아이콘을 클릭해보세요.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_9.png)\n\n# 8. 언어 번역\n\n이제 다른 프로그래밍 언어를 배울 필요가 없어졌어요. Copilot은 선택한 코드를 다른 언어로 번역할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 arraySum JavaScript 함수를 Python으로 번역해 보겠습니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_10.png)\n\n## 9. 이름 바꾸기 제안\n\n코드에서 심볼의 이름을 변경할 때 Copilot은 해당 심볼의 문맥을 기반으로 새 이름을 제안합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전의 arraySum 함수의 이름을 바꾸어 봅시다:\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_11.png)\n\n# 10. VSCode Agent\n\n만약 VS Code 기능을 수행하거나 상호 작용할 방법을 찾고 계시다면, Copilot @vscode 에이전트가 원하시는 기능에 대해 자세히 설명하거나 명확히 해주는 데 도움이 될 수 있습니다. 예를 들어, 우리가 기능을 설명하면, Copilot이 VS Code에서 해당하는 기능을 결정하는 데 도움을 줄 것입니다. 파일을 저장할 때 끝에 새로운 라인을 추가하도록 요청해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_12.png\" /\u003e\n\n# 결론\n\n이제 GitHub Copilot의 최고 10가지 기능을 알았으니, 더 행복하고 생산적인 개발자가 되실 수 있습니다.\n\n읽어주셔서 감사합니다. 유용한 정보였기를 바라며, 즐겁게 코딩하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원","ogImage":{"url":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"},"coverImage":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"고급 데이터 구조 및 알고리즘 더미용 신경망","description":"","date":"2024-06-20 01:15","slug":"2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies","content":"\n\n## 자바스크립트에서 첫 번째 신경망 구현하기\n\n![image](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png)\n\n신경망은 매력적이고 흥미로운 것처럼 들립니다. 하지만 정확히 무엇이고, 어떻게 그런 마법을 달성하는 걸까요? 그리고 무엇보다 중요한 건, 전문적인 데이터 과학자가 아니어도 하나를 만들 수 있을까요?\n\n이 기사에서는 신경망의 기본 원리와 기존 도구를 사용하여 직접 구현하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 매우 실용적 일 것입니다. 마지막에 여러분께 자신만의 신경망을 만들어 터미널에서 기본 ASCII 그림을 그리는 방법을 안내해 드리겠습니다.\n\n시작해 봅시다!\n\n## 신경망 이해하기\n\n신경망은 \"뉴런(neurons)\"으로 알려진 개별 요소로 구성된 특수한 유형의 데이터 구조입니다. 뉴런은 레이어로 그룹화되어 있으며 다른 레이어의 다른 뉴런과 연결됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 기본적인 신경망 구조 중 하나는 피드포워드 신경망입니다. 이들은 입력 레이어, 하나 이상의 은닉 레이어 및 출력 레이어로 구성되어 있으며, 정보는 한 방향으로만 흐릅니다 (입력 레이어에서 출력 레이어로).\n\n이것이 무엇을 의미하는지 보여주는 기본 다이어그램이 있습니다:\n\n![다이어그램](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_1.png)\n\n기본적으로 입력 정보는 입력 레이어에 입력되고, 거기서 \"가중치\"라고 불리는 값과 특정 활성화 함수(값을 취하여 0과 1 사이의 값을 출력하는 함수)를 사용하여 데이터가 변환됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 뉴런 그룹을 결합하고 가중치를 적절하게 조정하면 (즉, 네트워크를 \"학습\"할 때 하는 것), 결합된 출력은 제공한 입력에 기초해 기대한 출력(또는 거의 동일한 값)이 됩니다.\n\n예를 들어, XOR 방정식을 해결하는 기본적인 예는 다음과 같습니다:\n\n\n[0,0] =\u003e 0\n[0,1] =\u003e 1\n[1,0] =\u003e 1\n[1,1] =\u003e 0\n\n\n하지만 2개의 입력과 1개의 출력 뉴런을 가진 피드포워드 네트워크를 만들면, 한 번 학습되면 0 또는 1의 모든 조합을 입력하고 실제로 XOR 동작을 프로그래밍하지 않고도 예상한 XOR 출력을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이 왜 신경망을 사용하고 싶어하는지의 주된 이유입니다. 실제로 모든 규칙을 코딩하지 않고도 일반화된 행동을 달성하기 위해서입니다.\n\n## 신경망의 종류\n\n다양한 종류의 신경망이 있으며, 각각의 특징과 용도가 있습니다. 여기에서 모든 종류를 나열하고 그들을 사용하고 구현하는 방법에 대해 깊게 설명하는 것은 이 글의 실용적인 접근을 방해할 수 있습니다.\n\n따라서 가장 흔한 신경망 유형의 목록을 여기에 제시합니다. (다른 유형도 있다는 것을 염두에 두세요):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 피드포워드 신경망: 앞에서 이미 다루었습니다. 이들은 가장 흔하고 간단한 신경망이지만 여전히 유효한 사용 사례가 있습니다.\n- 합성곱 신경망(CNNs): 이미지 인식 및 처리 작업용으로 설계된 신경망입니다. 이미지 데이터에서 특징을 학습하는 데 효과적이며 컴퓨터 비전 응용 프로그램에서 일반적으로 사용됩니다.\n- 순환 신경망(RNNs): 언어 번역이나 음성 인식과 같은 순차 데이터 처리 작업용으로 설계된 신경망입니다. 순차 데이터의 패턴을 학습하는 데 효과적이며 자연어 처리(NLP) 응용 프로그램에서 일반적으로 사용됩니다.\n- 오토인코더: 차원 축소 및 특성 학습 작업용으로 설계된 신경망입니다. 입력 레이어, 은닉 레이어 및 출력 레이어로 구성되어 입력 데이터를 출력 레이어에서 재구성하도록 훈련됩니다.\n- 생성적 적대 신경망(GANs): 가상 데이터 생성용으로 설계된 신경망입니다. 생성자 네트워크가 가상 데이터를 생성하고, 식별자 네트워크가 가상 데이터를 실제 데이터와 구분하려고 합니다.\n- 트랜스포머: NLP 및 텍스트 생성에 매우 효과적입니다. 많은 자연어 처리 작업에 대해 최첨단 결과를 크게 개선했으며 이 분야에서 널리 사용되고 있습니다. 예를 들어, ChatGPT는 훈련 과정에서 이러한 유형의 NN(신경망)을 사용했습니다.\n\n원하는 행동 유형에 따라 하나를 선택합니다. 이 기사에서는 간단하게 유지하고 첫 번째 신경망에 초점을 맞출 것입니다.\n\n읽어주셔서 감사합니다! 제 무료 뉴스레터를 구독해보시겠어요? IT 산업에서 20년 동안의 지혜를 모두가 공유하는 \"The Rambling of an old developer\"에 가입해보세요!\n\n# 첫 번째 신경망 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 우리의 첫 번째 시도이므로 실용적인 방법을 찾고 있기 때문에, 바퀴를 다시 발명할 필요가 없다고 생각해요. 우리가 원하는 것을 달성하는 데 도움이 되는 도구들이 많이 있으니, 우리가 지금 바로 선택하면 돼요.\n\n제 경우에는 저는 Synaptic을 선택했어요. 낮은 수준의 인터페이스를 제공하지만 기본적인 구성 요소는 이미 갖춰져 있어요. 그래서 심층 수학에 신경 쓸 필요없이 NN을 구축하는 데 필요한 요소를 잘 이해할 수 있어요.\n\n우리의 NN을 사용하여 XOR 방정식을 해결하는 대신, 그것을 사용하여 터미널에 ASCII 이미지를 \"그리고\" 싶었어요. 이미지는 상대적으로 작아서 교육 시간을 짧게 유지하려고 해요.\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 그려고 하는 행렬 또는 더 정확히 말하자면, NN에게 그리는 방법을 배우도록 요청하는 것입니다. 그래서 우리가 할 일은 이전과 동일한 3개의 레이어를 가진 NN을 생성할 것입니다:\n\n- X와 Y 좌표를 위한 2개의 뉴런이 있는 입력 레이어.\n- 15개의 뉴런이 있는 은닉 레이어.\n- 그리고 각 좌표 세트마다 1 또는 0을 출력해야 하는지 이해하기 위해 1개의 뉴런만 있는 출력 레이어.\n\n우리는 Synaptic을 사용하여 NN을 다음과 같이 설정할 것입니다.\n\n이제 훈련에 대해, 가중치 간의 학습률을 0.3으로 설정할 것입니다. 이는 뉴런 간의 가중치가 각 반복에서 0.3씩 값을 조정할 것을 의미합니다. 그런 다음 그 결과를 출력해야 하는 것과 비교하고, 다음 반복에서 이에 따라 조정할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상수 이미지에는 내가 원하는 출력이 포함되어 있어요. 이를 사용하여 네트워크를 훈련할 거에요. 0과 1로 이루어진 8x6 매트릭스에요.\n\n그런 다음 훈련을 위해 30,000회의 반복을 실행할 거에요. 매 \"픽셀\"마다 activate 메소드를 호출할 거에요. 이 메소드는 입력을 입력 레이어에 넣고 NN을 실행해요. 그런 다음 propagate 메소드를 사용하여 learningRate와 마지막 활성화값에 대한 예상 값을 사용해 네트워크가 자신을 조정하게 할 거에요.\n\n참고로, \"y * 8 + x\"라는 작은 공식은 직교 좌표를 사용하여 1차원 배열을 탐색하는 작은 속임수에요. 더 자세히 말하면 \"`y 좌표` * `폭` + `x 좌표`\"이고, 2차원 배열이 더 이상 필요하지 않아요.\n\n훈련이 끝나면 좌표를 다시 통과시키고 activate할 차례에요. 이번에는 결과를 출력할 거에요. 그를 위해 다음과 같은 함수를 만들었어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 Y 좌표에 대해 활성화 결과를 리스트에 저장하고, 한 행이 완료되면 (해당 Y에 대한 모든 X 좌표를 거쳤을 때) 출력합니다.\n\n여기서 Math.round를 사용하고 있는 이유는 NN의 출력이 0 또는 1이 아니라 둘 사이의 숫자일 것이기 때문입니다.\n\n결과를 보세요:\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 결과가 완벽하지 않음을 알 수 있어요. 그 이미지에는 2개의 오류가 있다는 걸 주목해주세요. 조금 더 훈련을 시키면 더 나은 결과를 얻을 수 있을지도 모르지만, 이것은 저가 얻은 최상의 결과 중 하나에요.\n\n정확한 알고리즘을 코딩하지 않고도 일반적인 행동을 달성하려고 노력하는 만큼, 항상 올바른 답을 얻을 수 있는 것은 아니며 그 유사한 정도에 그치게 될 거예요.\n\n그래서 Dall-e나 Midjourney로 이미지를 생성할 때 이상한 손이 나타나거나, ChatGPT가 가끔 사실이 아닌 문장을 작성하거나 버그가 있는 코드를 생성하는 이유에 대해 이해할 수 있어요. 그들의 훈련 결과에 기반하여 유사한 정도의 답변을 제시할 뿐이기 때문이에요.\n\n신경망은 입력값의 다양한 수를 적응시켜야 하는 행동을 달성하려는 경우나 특정하게 코딩하는 데 많은 노력이 필요할 때 매우 유용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 대신, 적절한 유형의 입력을 사용하여 훈련을 통해 충분히 가까운 결과를 얻을 수 있어요.\n\n이전에 NN을 사용해 보셨나요? 그것들을 어떤 목적으로 사용했나요?\n\n# 레고처럼 재사용 가능한 구성 요소로 앱을 만들어 보세요\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트의 오픈 소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고 여러 응용 프로그램 간에 공유하세요. 협업하고 빠르게 개발하기가 더욱 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 간단하게 만들고 원하는 작업 흐름에 대해 최상의 경험을 누리세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"},"coverImage":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png","tag":["Tech"],"readingTime":6},{"title":"자바스크립트 데이터 유형","description":"","date":"2024-06-20 01:14","slug":"2024-06-20-JavaScriptDataTypes","content":"\n\n이해하기 쉬워요\n\n## JavaScript는 총 여덟 가지의 다른 데이터 유형을 지원합니다. 일곱 가지의 기본 유형과 하나의 비 기본 유형이 있어요.\n\n이러한 데이터 유형을 이해하는 것은 효율적이고 버그 없는 코드를 작성하는 데 중요해요. 이 블로그에서는 각 데이터 유형에 대해 자세히 살펴볼 거에요.\n\n데이터 유형에 대해 계속 진행하기 전에 JavaScript의 console.log() 메서드에 대해 이야기하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`console.log()`은 웹 콘솔에 메시지를 출력하는 JavaScript의 메서드입니다. 일반적으로는 변수의 값이나 표현식의 결과와 같은 정보를 인쇄하기 위해 디버깅 목적으로 사용되며, 이를 통해 개발자들은 코드의 동작을 검사할 수 있습니다.\n\n```js\nconsole.log(\"Hello, world!\"); // 출력: Hello, world!\nconsole.log(42);              // 출력: 42\n\n// 변수 출력\nlet greeting = \"Hello, world!\";\nconsole.log(greeting); // 출력: Hello, world!\n```\n\n- Number\n\nNumber 타입은 정수와 부동 소수점 숫자를 모두 나타냅니다. JavaScript는 두 유형을 구분하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 정수 값\nconst age = 21;\n\n// 부동 소수점 값\nconst temperature = 32.5;\n```\n\n2. 문자열\n\n문자열 유형은 텍스트를 형성하는 문자 시퀀스를 나타냅니다.\n\n```js\n// 문자열 예시\nconst name = \"제 이름은 요기이고 웹 개발자입니다\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 불리언\n\n불리언 유형에는 true 또는 false의 두 가지 값만 있습니다. 일반적으로 조건문에서 사용됩니다.\n\n```js\n// 불리언 예시\n\n// True 저장\nconst isAdmin = true;\n\n// False 저장\nconst isLoggedIn = false;\n```\n\n4. 널\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnull 타입은 의도적으로 어떤 객체 값도 없음을 나타냅니다. 기본적으로 변수를 정의하고 그 때 어떤 값을 추가하고 싶지 않을 때, 그리고 나중에도 해당 변수에 값을 추가하고 싶지 않을 때 사용합니다.\n\n```js\n// Null의 예시\nconst dummy = null;\n```\n\n5. Undefined\n\n값이 할당되지 않은 변수는 undefined 타입입니다. 기본적으로 변수를 선언했지만 아직 값이 할당되지 않은 상태를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Undefined 예제\nlet name;\n```\n\n6. BigInt\n\nBigInt을 사용하면 Number 타입이 처리할 수 있는 정수보다 큰 정수를 표현할 수 있습니다.\n\nNumber에서 BigInt로 변환하려면 값 뒤에 `n`을 추가하기만 하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// BigInt의 예시\nlet Money = 54215484215484212n;\n```\n\n7. Symbol\n\nSymbol은 고유하고 변경할 수 없는 데이터 유형으로서, 객체 속성의 식별자로 사용할 수 있습니다.\n\n여기서 '변경할 수 없는'이란 한 번 선언된 심볼의 값은 변경할 수 없다는 의미이고, '고유한'이란 동일한 값으로 여러 심볼 변수를 만들더라도 각각 메모리에서 고유하다는 의미입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Symbol 예제\nconst Variable_one = Symbol(\"abc\");\nconst Variable_two = Symbol(\"abc\");\n```\n\n위 예제를 보면 변수 one과 two가 심볼 데이터 유형의 동일한 값을 가지고 있는 것처럼 보이지만, 두 변수 간에는 어떤 유사성도 없습니다. 두 변수는 서로 다릅니다.\n\n8. 객체\n\n객체는 속성들의 모음이며, JavaScript에서 유일한 원시 데이터 윕입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서는 객체 키가 객체 내의 특정 속성에 대한 고유 식별자로 작용합니다. 이러한 키는 문자열 또는 숫자가 될 수 있습니다.\n\n일반적으로 문자열은 키로 직접 사용되지만, 숫자는 사용될 때 자동으로 문자열로 변환됩니다.\n\n이 유연성을 통해 객체는 자바스크립트 응용 프로그램 내에서 구조화된 데이터의 저장 및 검색을 용이하게 합니다.\n\n```js\n// 객체 예제\nlet obj = {\n  name: \"yogi parmar\",\n  age: 21,\n  isGood: true,\n  storingNull: null,\n  undefinedPropertu: undefined,\n  1: \"one\",\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 다음 블로그에서는 자바스크립트에서 변수의 기초를 탐구할 것이며, 데이터를 저장하는 용기로서의 역할에 중점을 둘 것입니다.\n게다가, 변수의 이름 짓는 데 대한 최상의 실천법과 관습에 대해 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png","tag":["Tech"],"readingTime":3}],"page":"50","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"50"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>