<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/50" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/50" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요" href="/post/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기" href="/post/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="러스트를 사용한 것이 괜찮았나요" href="/post/2024-05-12-WasRustWorthIt"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="러스트를 사용한 것이 괜찮았나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WasRustWorthIt_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="러스트를 사용한 것이 괜찮았나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">러스트를 사용한 것이 괜찮았나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것" href="/post/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 Command-Line Tool 만드는 방법" href="/post/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 Command-Line Tool 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 Command-Line Tool 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 Command-Line Tool 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" href="/post/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="브라우저 아키텍처의 과거와 현재" href="/post/2024-05-12-ThePastandPresentofBrowserArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="브라우저 아키텍처의 과거와 현재" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="브라우저 아키텍처의 과거와 현재" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">브라우저 아키텍처의 과거와 현재</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디자인 패턴 더 나은 코드 작성하기" href="/post/2024-05-12-DesignPatternsBuildingBetterCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 패턴 더 나은 코드 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 패턴 더 나은 코드 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디자인 패턴 더 나은 코드 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 HTTP Interceptors" href="/post/2024-05-12-HTTPInterceptorsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 HTTP Interceptors</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Gulp v5를 발표 내용 정리" href="/post/2024-05-12-AnnouncingGulpv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AnnouncingGulpv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Gulp v5를 발표 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"프론트엔드 성능에 대해 이야기할 때, 우리는 무엇을 얘기하고 있는 걸까요","description":"","date":"2024-05-12 23:59","slug":"2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png\" /\u003e\n\n이 기사에서는 Google의 공식 도구 라이트하우스를 활용하여 최신 프런트엔드 페이지 성능 평가 표준을 분석하여 다양한 성능 지표를 이해하고 관련 프런트엔드 프로젝트를 개선하고 최적화하는 데 도움을 줍니다.\n\n프런트엔드 페이지 성능은 사용자 유지율이 페이지 로드 성능과 밀접한 연관이 있기 때문에 모두에게 항상 연속적인 관심사였습니다. 구글의 데이터 통계에 따르면, 페이지 방문 시간이 1초에서 3초로 증가할 때 사용자의 이탈률이 32% 증가합니다.\n\n프런트엔드 페이지 성능을 평가하는 두 가지 방법이 일반적으로 있습니다: 하나는 성능 분석 도구를 사용하여 온라인에서 다양한 지표를 점수화하고 평가하는 것이며, 다른 하나는 성능 모니터링을 사용하여 Performance API나 사용자의 실제 네트워크 액세스 상황을 보고한 후 통계 분석을 수행하는 것입니다.\n\n\n\n사용자 데이터를 통계적으로 수집하는 것이 더 현실적이지만 페이지 성능 평가에 대한 통일된 양적 기준을 갖기 위해 종종 페이지 성능을 평가하는 데 표준 평가 도구를 사용하기로 선택합니다.\n\n성능 분석 초기 단계에서는 Chrome 개발자 도구를 사용하여 웹 페이지를 분석하며, 로드 및 DOMContentLoaded와 같은 이벤트가 발생하는 시간을 확인합니다. 나중에 Webpage Analyzer, WebPageTest, YSlow 등과 같은 일련의 성능 분석 도구가 등장했습니다.\n\n이제 Google은 자체 개발한 Lighthouse를 공식적으로 개발자 도구 탭에 내장시켰으므로, Lighthouse를 표준 평가 도구로 고려합니다.\n\nLighthouse는 페이지의 최상의 사례에 관한 관련 권고 사항을 제공하는 오픈 소스 웹 페이지 성능 분석 도구입니다. Chrome DevTools에서 직접 사용할 수도 있을 뿐만 아니라 브라우저 확장 프로그램(Chrome 및 Firefox)이나 npm 패키지(Node API 또는 CLI)도 지원합니다.\n\n\n\nGoogle의 Web Measure 및 PageSpeed Insight와 같은 도구는 페이지를 분석하는 라이트하우스를 사용합니다.\n\n## 1. 라이트하우스의 반복 및 성능 지표 변경\n\n라이트하우스의 최초 오픈 소스 버전은 2016년으로 거슬러 올라가며, 2020년 10월 기준 최신 버전은 6.4.1이며, 총 89번의 반복을 거쳤습니다. 이들 몇 년 사이에, 라이트하우스는 성능 메트릭스(지표)를 업데이트해 왔습니다.\n\n최신 버전 6.X에서 Google은 5.X 버전과 비교해 세 가지 새로운 성능 메트릭스를 소개했습니다: FMP(첫 의미 있는 그림 렌더링), FCI(첫 CPU 비활성 및 mpFID(최대 잠재 첫 입력 지연)가 제거되었습니다.\n\n\n\nTBT (Total Blocking Time), LCP (Largest Contentful Paint), and CLS (Cumulative Layout Shift)가 추가되었습니다. 다음 섹션에서는 이러한 지표들에 대한 자세한 설명을 제공할 것입니다.\n\n![image](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_1.png)\n\n## 2. 페이지 성능 점수 계산 방법\n\n아래 그림에서 보듯이, 페이지 성능 섹션에서 Lighthouse는 6가지 주요 지표의 성능을 평가하고 페이지의 성능 점수를 계산할 것입니다.\n\n\n\n![표](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_2.png)\n\n최신 6.X 계산 방법에 따르면 각 성능 메트릭은 점수에 대응됩니다. 예를 들어, 위 그림에서 FCP, SI, LCP, TTI, TBT 및 CLS의 값은 각각 78, 62, 37, 5, 99, 92에 해당하는 개별 점수입니다. 일반적으로 메트릭 값이 작을수록 해당하는 점수가 높습니다.\n\n이 여섯 메트릭에 할당된 가중치는 각각 15%, 15%, 25%, 15%, 25%, 5%입니다. 전체 성능 점수는 가중 평균을 통해 60점으로 계산됩니다.\n\n각 메트릭 값이 해당하는 점수 계산 방법은 이 기사 끝에 있는 참고 자료 번호 다섯와 여섯에서 자세히 확인할 수 있습니다.\n\n\n\n라이트하우스 v6.0.에서는 FMP (First Meaningful Paint), FCI (First CPU Idle) 및 mpFID (Maximum Potential First Input Delay)와 같은 세 가지 핵심 성능 지표가 제거되었습니다.\n\n현재 버전이 그들의 메트릭을 선택하는 방식을 더 잘 이해하기 위해 이 세 가지 폐기된 지표의 정의를 살펴보겠습니다.\n\n## 1. FMP란 무엇이며 FCP와 어떤 차이가 있는가?\n\nFMP에 대해 이야기할 때에는 먼저 First Contentful Paint (FCP)를 소개해야 합니다: 첫 번째 콘텐츠 렌더링 시간입니다.\n\n\n\n위에서 언급한 대로, 브라우저가 처음으로 'First Page Paint' 이벤트를 트리거하면, 이 순간이 FCP가 됩니다. 하지만, 이때 렌더링되는 내용이 반드시 중요한 페이지 정보일 필요는 없습니다. 예를 들어, 헤더 액션바를 그리거나 심지어 가시적인 요소만 렌더링되는 경우도 있을 수 있습니다. Lighthouse 6.0에는 여전히 포함되어 있지만, 성능 점수에서의 비중은 23%에서 15%로 감소했습니다.\n\n그러므로, FCP는 사용자 관점에서 페이지 성능을 정확히 판단할 수 있는 지표로 사용할 수 없습니다.\n\n이 맥락에서 'FMP (First Meaningful Paint)'이 등장했습니다. 공식적인 정의에 따르면, FMP는 페이지 로딩이 시작된 후 초기 화면에 가장 많거나 주요 콘텐츠가 렌더링된 시점을 말합니다.\n\n그렇다면, FMP 타이밍은 어떻게 확인할까요? 먼저 가장 기본적인 계산 방법을 살펴보겠습니다:\n\n\n\n먼저 레이아웃 오브젝트의 수를 계산합니다 (테스트 계산을 위해 LayoutAnalyzer를 사용하십시오; 참조 17번을 참조하십시오).\n\n아래 그림에서 볼 수 있듯이 페이지 로딩 프로세스는 레이아웃 오브젝트가 레이아웃 트리로 점진적으로 들어가고 렌더링되는 과정입니다.\n\n![이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_3.png)\n\nlayoutAnalyzer는 레이아웃 오브젝트의 수를 모으고, LayoutObjectsThatHadNeverHadLayout라는 카운터로 새로 추가된 레이아웃 오브젝트의 수를 나타냅니다.\n\n\n\n테스트를 통해 다른 카운터와 비교했을 때, 가장 변화가 많이 일어나는 순간은 종종 페이지에서 가장 중요한 요소들이 렌더링될 때입니다.\n\n따라서 FMP 지표의 계산 방법은 LayoutObjectsThatHadNeverHadLayout(새롭게 추가된 레이아웃 오브젝트)가 가장 큰 변화를 경험한 다음 순간입니다(가장 큰 레이아웃 변경을 따라오는 페인트).\n\n물론, 위의 상황이 적용되지 않는 몇 가지 시나리오도 있습니다:\n\na) 페이지가 긴 경우, 첫 화면 내에는 가시적인 레이아웃 오브젝트보다 보이지 않는 레이아웃 오브젝트가 더 많이 추가될 수 있습니다. 이 경우에는 FMP가 부정확해집니다.\n\n\n\nb) 웹 폰트를 로드하고 텍스트가 레이아웃을 위해 대체 글꼴을 사용하지만 로드 시작으로부터 3초 내에 그려지지 않는 경우; 이는 또한 FMP 계산에 영향을 줄 수 있습니다.\n\n시나리오 1의 경우, FMP는 이 문제를 해결하기 위해 \"레이아웃 중요성\" 개념을 도입했습니다; 시나리오 2의 경우, FMP는 통계를 지연시켜 지표가 페이지 상태를 더 정확하게 반영하도록 합니다. 자세한 해결책은 참조문헌 18을 참조해 주세요.\n\n그러나 FMP는 주요하게 다음 두 가지 이유로 버전 6.0에서 폐기되었습니다.\n\n- 실제 환경에서 FMP는 페이지의 작은 변경에 너무 민감하여 일관되지 않은 결과로 쉽게 이어질 수 있습니다.\n- 이 지표의 정의는 브라우저의 구체적인 구현 세부 사항에 심하게 의존하며 참조를 위한 표준화가 부족합니다.\n\n\n\n# 2. LCP가 FMP를 대체하고 나타났어요\n\n이전 섹션에서 FCP와 FMP의 단점을 언급했었는데요, 그래서 W3C의 성능 그룹은 페이지의 주요 콘텐츠를 사용자가 볼 수 있는 시간을 더 정확하게 반영하는 적절한 지표를 찾고 있었어요.\n\n가끔은 더 간단할수록 더 좋아요. 다양한 소스에서의 토론을 토대로 페이지 성능에 관한 보다 정확한 측정 방법, 즉 LCP (가장 큰 콘텐츠 렌더링)가 마침내 찾아졌어요.\n\nLCP는 뷰포트 내에서 가장 큰 콘텐츠 요소가 렌더링되는 시간을 의미해요. 이 지표는 Lighthouse 6.0에서 공식적으로 소개되었으며 최종 성능 점수에서 25%의 가중치를 갖고 있어요.\n\n\n\nLCP는 FCP와 함께 정의하기 가장 쉬운 메트릭 중 하나여야 합니다. 그 정의에는 비교할 요소 선택과 그 크기를 결정하는 두 가지 중요한 요소가 있습니다.\n\n공식 문서에 따르면, 다음 요소들이 가장 큰 콘텐츠 요소(Largest Contentful Element)의 일부로 고려될 것입니다:\n\n- `img`\n- `svg` 내부의 `image`\n- `video`\n- url() 함수를 통해 배경 이미지를 로드하는 요소\n- 텍스트 노드를 포함하거나 인라인 텍스트 자식 요소를 포함하는 블록 수준의 요소들\n\n요소의 크기를 어떻게 결정할까요? 주로 다음 네 가지 규칙에 기반하여 결정됩니다:\n\n\n\n- 화면 뷰포트 내에서 보이는 요소의 크기; 뷰포트를 벗어나거나 가려지거나 가려지거나 감춰진 경우 크기로 계산되지 않습니다.\n- 이미지 요소의 경우 크기는 실제 크기와 원래 크기 중 작은 것을 취함으로 결정됩니다.\n- 텍스트 요소의 경우 모든 텍스트를 덮는 최소 직사각형 영역만을 고려합니다.\n- 모든 요소의 경우 여백, 안쪽 여백, 테두리 등은 계산에 포함되지 않습니다.\n\n구글은 이 메트릭을 다음과 같이 평가합니다: LCP는 매우 중요한 사용자 중심 지표이며 사용자 수준에서 지각된 로딩 속도를 반영합니다. 주요 콘텐츠에서 가장 큰 콘텐츠 요소의 로딩이 완료된 것을 나타내며, 더 짧은 LCP 시간으로 사용자는 페이지를 더 빠르게 사용 가능하다고 인식하게 됩니다.\n\n# 3. 버려진 FCI와 TTI와 왜 밀접한 관련이 있는가?\n\nFCI(First CPU Idle: 첫 번째 CPU 대기)는 페이지가 최소 상호 작용 표준에 도달하는 데 얼마나 오래 걸리는지를 측정하는 메트릭입니다.\n\n\n\n최소 상호 작용성의 확인을 위해서는 다음 두 가지 조건을 동시에 충족해야 합니다:\n\na) 화면에 있는 대부분의 UI 요소가 상호 작용 가능해야 합니다\n\nb) 페이지가 일반적으로 합리적인 범위 내에서 사용자 입력에 응답해야 합니다\n\nTTI (Time To Interactive: 페이지 상호 작용까지의 시간)는 페이지가 완전히 상호 작용 가능한 상태에 도달하는 데 필요한 시간을 의미합니다.\n\n\n\n\"완전 대화형\"이란 다음 세 가지 조건을 모두 충족하는 것을 의미합니다:\n\na) FCP 이후 페이지에 유용한 콘텐츠가 렌더링되었습니다\n\nb) 가장 눈에 띄는 페이지 요소에 이벤트 콜백이 등록되었습니다\n\nc) 사용자 상호작용에 대한 페이지 응답 시간이 50ms 이내입니다\n\n\n\n2017년에 첫 번째 상호 작용 메트릭이 두 가지 메트릭, 즉 첫 상호 작용 및 일관적 상호 작용으로 나뉘었으며, 이어지는 해의 7월에 첫 상호 작용은 FCI로 변경되었고, 일관적 상호 작용은 TTI로 변경되었습니다. FCI와 TTI는 사용자 상호 작용 응답을 반영하는 두 가지 메트릭임을 볼 수 있습니다.\n\n그렇다면 최소 상호 작용 및 전체 상호 작용은 어떻게 계산되는 걸까요? 구체적인 계산 방법을 소개하기 전에 이 두 가지 메트릭이 모호하며 서로 다른 상황에서 계속 최적화되고 개선될 수 있다는 것을 알아야 합니다.\n\n- FCI의 최소 상호 작용 시간\n\n주 스레드의 타임라인에서 FMP부터 특정 작업이 끝난 후까지 길이가 f(t)인 시간 창 W를 찾습니다. W가 해당 기간 동안 어떤 지점에서도 250ms 이상의 연속적인 작업 집합이 없고, 그 끝과 직전 1초 내에 JS 실행 시간이 50ms를 초과하는 긴 작업이 없으면 해당 작업이 끝난 시점이 우리가 정의하는 FCI입니다. 여기서 f(t)=4e^(-0.045t)+1.\n\n\n\n아래 그림에서 빨간 상자로 표시된 지점이 FCI를 나타냅니다.\n\n![FCI](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_4.png)\n\n- TTI: 완전 상호 작용 시간\n\n네트워크 및 주 스레드의 타임라인에서 처음 5초 창기간 W을 찾으세요. W 기간 내에서 다음 조건을 충족해야 합니다: 어떤 순간에도 동시 네트워크 요청이 최대 두 개이고 50ms를 초과하는 긴 작업이 없습니다. W 이전의 마지막 긴 작업의 종료 시간을 TTI로 지칭합니다.\n\n\n\n아래 그림에서 빨간 상자로 표시된 시점은 TTI입니다:\n\n![Figure](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_5.png)\n\n일부 사람들은 FCI가 특정 시기에 TTI보다 의미가 더 있다고 지적했지만, 이들 사이의 차이는 여전히 라이트하우스가 두 가지 유사한 메트릭을 유지하는 것을 정당화하는데 충분하지 않습니다.\n\n그래서 라이트하우스 버전 6.0에서 최종 결정이 내려져 FCI 대신 TTI를 사용하기로 결정되었습니다.\n\n\n\n# 4. mpFID 및 새로 추가된 TBT 지표\n\nmpFID (최대 잠재적 첫 입력 지연)은 사용자 입력부터 페이지에서 이벤트 콜백을 처리하기 시작하는 실제 시간까지의 잠재적 최대 지연 시간을 나타냅니다.\n\nmpFID의 구체적인 계산 방법은 FCP부터 TTI까지의 JavaScript 실행 시간을 기준으로 가장 긴 작업을 선택한 다음 해당 작업이 소비한 시간에서 50ms를 뺀 것입니다.\n\n그러나 mpFID는 최대 지연 시간만을 나타내며, 사용자가 경험하는 실제 지연 시간과 다를 수 있습니다. 사용자가 다른 시간에 얻는 FID도 다를 수 있습니다. 따라서 mpFID는 페이지의 응답 시간을 사용자 입력에 대한 실제 반응 시간을 정확하게 반영하지 않습니다.\n\n\n\n5. X 버전에서 성능 점수를 계산할 때 mpFID는 가중치가 0으로 설정되어 점수에 기여하지 않습니다. 이 메트릭은 이제 더 이상 보고서에 나타나지 않지만, JSON 데이터에는 유지되며 공식적으로 인정받는 핵심 사용자 경험 지표로 남아 있습니다.\n\n그렇다면 TBT (Total Blocking Time)은 정확히 무엇이며 왜 성능 보고서에서 FID 대신 선택해야 하는 것인가요?\n\n먼저 정의를 살펴보겠습니다: TBT는 페이지에서 사용자 입력에 응답할 때 차단된 총 누적 시간을 의미합니다.\n\n구체적인 계산 방법은 매우 명확합니다 — FCP와 TTI 사이의 모든 긴 작업을 합산하고 그 차단 부분의 시간을 추가하여 TBT를 얻습니다. 차단 부분의 시간이란 긴 작업 실행 시간이 50ms를 초과하는 부분을 말합니다; 예를 들어, 긴 작업이 전체 70ms 걸리면 차단된 시간은 20ms가 됩니다.\n\n\n\nmpFID과 비교해 볼 때 TBT는 사용자 입력에 대한 페이지의 평균 지연 응답을 더 정확하게 반영할 수 있는 더 안정적인 지표입니다.\n\n## 5. 최근 추가된 CLS\n\nCLS (Cumulative Layout Shift)는 시각적 인터페이스의 안정성을 측정하는 지표입니다.\n\n데이터는 레이아웃 불안정성 API(참조 14 참조)에서 얻으며, 계산 방법은 다음과 같습니다:\n\n\n\n\n레이아웃 이동 점수 = 영향 분수 * 거리 분수\n\n영향 분수는 전체 뷰포트에 미치는 영향 정도를 나타냅니다. 예를 들어 아래 이미지에서 텍스트가 전체 뷰포트의 50%를 차지하고 다음 프레임에서 이전 프레임 대비 25% 아래로 이동한다면 전체 페이지의 75%에 영향을 줍니다. 따라서 영향 분수는 0.75입니다.\n\n![이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_6.png)\n\n거리 분수는 비교적 이해하기 쉽습니다. 전체 뷰포트의 변경된 거리 비율을 의미합니다. 예를 들어 위 경우에서 25% 이동은 거리 분수가 0.25를 의미합니다.\n\n\n\n그래서, 그림으로 설명된 데모의 CLS 값은 0.75 * 0.25 = 0.1875로 계산됩니다. 더 자세한 계산 방법은 참고문헌 13과 14에서 확인할 수 있습니다.\n\nCLS가 사용자 경험에 미치는 영향을 설명하는 예시: 아래 다이어그램과 같이 사용자가 취소 버튼을 클릭하려고 할 때, 갑자기 페이지에서 레이아웃이 변경되어 취소 버튼이 있던 자리에 확인 버튼이 나타납니다...\n\n![다이어그램 이미지](/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_7.png)\n\nCLS는 사용자 중심의 새로운 성능 평가 지표임을 알 수 있습니다.\n\n\n\n현재 CLS는 새로 추가된 지표로, 가중치가 5%뿐입니다. 하지만 Lighthouse는 다음 주요 버전에서 해당 가중치를 늘릴 계획이라고 합니다.\n\n## 6. 항상 사용되던 속도 지수\n\n속도 지수(Speed Index, SI)는 페이지에서 보이는 내용이 채워지는 속도를 측정하는 데 사용됩니다. 계산 과정은 오픈 소스 도구인 Speedline(참고 문헌 16)을 사용합니다.\n\nSpeedline은 페이지의 비디오를 기록하고 첫 프레임과 마지막 프레임 사이의 시간 차이를 측정하여 속도 지수의 값을 계산합니다.\n\n\n\nSI의 최종 점수는 데이터베이스에 있는 실제 웹 사이트의 SI 값과 비교하여 계산됩니다. 현재 SI 점수와 평가 기준은 아래 표에 표시되어 있습니다:\n\n| 항목 | 점수 |\n|:--:|:--:|\n| FMP to LCP | X |\n| FCI to TTI | Y |\n| FID to TBT | Z |\n\n위 지표들의 교체 과정을 검토하면, 성능 지표의 선택은 모두 더욱 안정적인 방향으로 나아가고 있음을 알 수 있습니다: 지표의 정의가 더욱 간결하고 명확해지고, 계산 방법 또한 표준화되는 방향으로 발전하고 있습니다.\n\n하지만 우리는 여기에 완벽한 해결책이 없다는 것을 알아야 합니다; 각 지표에는 한계가 있습니다. 많은 상황에서 낮은 점수가 반드시 페이지 경험의 품질이 나쁘다는 것을 의미하지는 않습니다. 성능 점수에 기반하여 페이지를 더 과학적으로 평가하기 위해서는 이러한 지표들 뒤의 원칙을 이해해야 합니다.\n\n\n\n성능 관련 기술의 신속한 변화로 이 문서에 빠뜨린 부분이 있을 경우 언제든지 의사 소통하여 수정해 주시기 바랍니다.\n\n- 새로운 산업 기준에 맞는 모바일 페이지 속도를 찾아보세요.\n- Performance.timing API\n- Lighthouse 6.0의 새로운 기능\n- Web Vitals\n- Lighthouse 점수 산출기\n- Lighthouse 성능 점수\n- WebPageTest 데모\n- 첫 의미 있는 페인트까지의 시간\n- 첫 상호작용 및 일관된 상호작용\n- 가장 큰 콘텐츠 페인트 (LCP)\n- 첫 상호작용 및 일관된 상호작용\n- Mercado Libre가 Web Vitals (TBT/FID)을 최적화한 방법\n- 누적 레이아웃 이동 (CLS)\n- 레이아웃 불안정성\n- 속도 지수\n- 속도 라인\n- 레이아웃 분석기\n- 첫 의미 있는 페인트까지의 시간","ogImage":{"url":"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png"},"coverImage":"/assets/img/2024-05-12-WhenWeTalkaboutFront-endPerformanceWhatAreWeTalkingAbout_0.png","tag":["Tech"],"readingTime":10},{"title":"자바스크립트 실력 업그레이드 배열 조작 기술 마스터하기","description":"","date":"2024-05-12 23:57","slug":"2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques","content":"\n\nJavaScript에서 배열은 값들의 컬렉션을 저장하고 조작할 수 있게 해주는 기본 데이터 구조입니다.\n\n배열이 유용한 이유 중 하나는 내장된 다양한 메서드를 제공하여 배열 내 요소를 쉽게 추가, 제거, 조작할 수 있다는 점입니다.\n\n![이미지](/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png)\n\n## Push\n\n\n\n배열에 요소를 추가해야 할 때는 push 메서드를 사용하는 것이 좋습니다. 이 메서드는 배열의 끝에 요소를 추가하며 기존 요소에 영향을 주지 않습니다. 새 배열의 총 개수를 반환합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst totalCount = animals.push(\"bird\");\n\nconsole.log(totalCount) // 5\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\"]\n```\n\n## Pop\n\n배열에서 요소를 제거하는 것은 추가하는 것만큼 간단합니다. 이 작업을 수행하는 한 가지 방법은 pop 메서드를 사용하는 것입니다. pop 메서드는 배열에서 마지막 요소를 제거하고 해당 요소를 반환합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst element = animals.pop();\n\nconsole.log(element); // shark\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\"]\n```\n\n## 연결하기\n\n만약 여러 값을 추가하고 싶다면 어떻게 해야 할까요? push로는 예상한 대로 작동하지 않을 것입니다. 이럴 때는 concat 메서드를 사용하여 두 개 이상의 배열을 결합할 수 있습니다.\n\n```js\nlet animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.push([\"bird\", \"eagle\"]);\nconsole.log(animals); // Nope [\"dog\", \"cat\", \"chicken\", \"shark\", [\"bird\", \"eagle\"]]\n\nanimals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst extendedAnimals = animals.concat([\"bird\", \"eagle\"]);\n\nconsole.log(extendedAnimals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\", \"eagle\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"bird\"]\n```\n\n\n\n## 슬라이스\n\n슬라이스 메소드는 전체 배열의 새로운 사본을 만들거나 배열의 일부를 추출하여 새 배열에 저장하는 데 사용할 수 있습니다.\n\n음수 인덱스를 사용하면 배열 끝에서 요소에 접근해야 할 때 정확한 길이를 모르더라도 편리합니다.\n\n그러나 슬라이스에 의해 생성된 사본은 얕은 복사입니다. 이는 원래 배열이 중첩된 배열이나 객체를 포함하는 경우 사본 내의 해당 중첩된 요소에 대한 수정이 원래 배열에도 반영된다는 것을 의미합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst last = animals.slice(-1);\nconst lastTwo = animals.slice(-2);\nconst first = animals.slice(0, 1);\nconst catChicken = animals.slice(1, 3);\n\nconsole.log(last); // [\"shark\"]\nconsole.log(lastTwo) // [\"chicken\", \"shark\"]\nconsole.log(first); // [\"dog\"]\nconsole.log(catChicken); // [\"cat\", \"chicken\"]\n\nconst copy = animals.slice();\n\nconsole.log(copy);\n\ncopy.push(\"spider\");\n\nconsole.log(copy); // [\"dog\", \"cat\", \"chicken\", \"shark\", \"spider\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\"]\n```\n\n## Join\n\n가끔 배열을 문자열로 변환해야 할 때가 있습니다. 배열 항목을 출력해야 할 때 유용합니다. 항목 사이에 끼워넣을 구분자를 지정해야 합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\nconsole.log(animals.join(\", \")); // dog, cat, chicken, shark\n```\n\n\n\n## 스플라이스\n\n특정 위치에서 배열에 요소를 추가하거나 제거해야 할 때는 splice 메소드가 유용합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\nconst removed = animals.splice(1, 2);\n\nconsole.log(removed); // [\"cat\", \"chicken\"]\nconsole.log(animals); // [\"dog\", \"shark\"]\n```\n\n## Shift\n\n\n\n배열에서 요소를 제거해야 할 때는 shift 메소드가 편리한 선택지입니다. 또한 제거된 요소를 반환합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst removed = animals.shift();\nconsole.log(removed); // \"dog\"\nconsole.log(animals); // [\"cat\", \"chicken\", \"shark\"]\n```\n\n## Unshift\n\nunshift 메소드를 사용하면 배열의 시작 부분에 하나 이상의 요소를 추가할 수 있습니다. push와 유사합니다. 배열의 새로운 길이를 반환합니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst totalCount = animals.unshift(\"deer\", \"tiger\");\nconsole.log(totalCount); // 6\nconsole.log(animals); // [\"deer\", \"tiger\", \"dog\", \"cat\", \"chicken\", \"shark\"]\n```\n\n## IndexOf\n\nindexOf 메서드를 사용하여 배열에서 항목의 위치를 쉽게 찾을 수 있습니다. 이 메서드는 배열에서 지정된 요소의 첫 번째 발생을 검색하고 해당 인덱스를 반환합니다. 요소를 찾지 못하면 indexOf는 -1을 반환합니다.\n\n추가로, indexOf에 두 번째 인수를 제공하여 배열에서 검색을 시작할 인덱스를 지정할 수 있습니다. 요소의 인덱스를 알게 되면 splice와 같은 메서드를 사용하여 쉽게 해당 요소를 교체하거나 제거할 수 있습니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nlet index = animals.indexOf(\"cat\");\nconsole.log(index); // 1\n\nindex = animals.indexOf(\"cat\", 2);\nconsole.log(index); // -1\n```\n\n## 찾기\n\n특정 조건에 맞는 요소를 찾아야 하는 경우가 있었나요? `find` 메소드는 배열에서 원하는 조건에 맞는 첫 번째 요소를 찾아줍니다.\n\n```js\nconst animals = [\n    {\n        id: 1, type: \"dog\", name: \"Luna\",\n    },\n    {\n        id: 2, type: \"cat\", name: \"Smokey\",\n    },\n];\n\nconst found = animals.find(animal =\u003e animal.id === 2);\nconst notFound = animals.find(animal =\u003e animal.id === 10);\n\nconsole.log(found); // { id: 2, type: 'cat', name: 'Smokey' }\nconsole.log(notFound); // undefined\n```\n\n\n\n## 포함 여부 확인\n\n배열에서 항목의 존재 여부를 확인해야 하는 경우 includes 메서드가 유용합니다! 이 메서드는 부울 값으로 반환됩니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst hasChicken = animals.includes(\"chicken\");\nconst hasTiger = animals.includes(\"tiger\");\n\nconsole.log(hasChicken); // true\nconsole.log(hasTiger); // false\n```\n\n## ForEach\n\n\n\nforEach는 배열을 반복하는 동안 현재 요소와 함께 인덱스 매개변수를 제공합니다. 이는 콜백 함수를 사용하는 장점으로 전통적인 for 루프와 유사하게 작동합니다.\n\nfor 루프와는 달리 forEach에서 탈출하는 내장 메커니즘이 없습니다. 그러나 콜백 내에서 예외를 throw하거나 조건문을 사용하여 조기 종료를 달성할 수 있습니다. 이러한 경우, 다른 옵션을 찾아보는 것이 좋습니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.forEach((animal, index) =\u003e {\n    console.log(animal, index);\n});\n\n// dog 0\n// cat 1\n// chicken 2\n// shark 3\n```\n\n## Map\n\n\n\n만약 배열의 데이터를 수정하고 수정된 데이터로 새로운 배열을 만들어야 한다면, map 메서드를 사용할 수 있어요. 콜백 함수를 통해 각 요소에 대해 원하는 작업을 수행하고 수정된 값을 반환할 수 있어요.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"salmon\"];\n\nconst indexed = animals.map((animal, index) =\u003e {\n    return `${index}.${animal}`;\n});\n\nconsole.log(indexed);\n// [\"1.dog\", \"2.cat\", \"3.chicken\", \"4.salmon\"]\n```\n\n## Filter\n\n커스텀 조건에 따라 배열에서 일부 요소를 제거하고 원하는 요소만 포함하는 새로운 배열을 얻어야 한다면, filter 메서드를 사용할 수 있어요. 이는 원본 배열을 수정하지 않고 새로운 배열을 생성한다는 점에서 map과 다릅니다.\n\n\n\n필터에 제공하는 콜백 함수는 새 배열에 포함될 요소에 대해 true를 반환하고 제외될 요소에 대해 false를 반환해야 합니다.\n\n```js\nconst animals = [\n    {\n        id: 1, type: \"dog\", name: \"Luna\", age: 1\n    },\n    {\n        id: 2, type: \"cat\", name: \"Smokey\", age: 3,\n    },\n    {\n        id: 3, type: \"dog\", name: \"Charlie\", age: 5,\n    },\n    {\n        id: 4, type: \"cat\", name: \"Boo\", age: 1,\n    },\n];\n\nconst adultAnimals = animals.filter(animal =\u003e animal.age \u003e 1);\nconsole.log(adultAnimals);\n// [\n//     { id: 2, type: 'cat', name: 'Smokey', age: 3 },\n//     { id: 3, type: 'dog', name: 'Charlie', age: 5 }\n// ]\n```\n\n## Reduce\n\n리듀스 메서드는 맵(map)과 필터(filter)보다 직관적이지 않습니다. 이 메서드는 배열 내 각 요소에서 작동하는 콜백 함수와 누적값(accumulated value)을 고려합니다. 누적값은 이전 반복에서 콜백 함수의 결과이며 현재 반복에서 콜백 함수에 첫 번째 인수로 전달됩니다.\n\n\n\nreduce는 다양한 작업에 사용할 수 있는 다재다능한 함수입니다. 배열의 합을 계산하거나, 다차원 배열을 평평하게 만들거나, 조건에 따라 배열을 변형하는 등의 작업에 사용할 수 있습니다.\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst totalCount = ages.reduce((이전값, 현재값) =\u003e {\n    return 이전값 + 현재값;\n}, 0);\n\nconsole.log(totalCount); // 201\nconsole.log(Math.round(totalCount / ages.length)); // 29\n```\n\n## ReduceRight\n\n이 함수는 reduce와 거의 비슷하지만, 오른쪽에서 왼쪽으로 요소를 읽어옵니다. 순서가 중요할 때 유용하게 활용할 수 있습니다.\n\n\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst totalCount = ages.reduceRight((previous, current) =\u003e {\n    console.log(current); // 43, 44, 6 ...\n    return previous + current;\n}, 0);\n\nconsole.log(totalCount); // 201\nconsole.log(Math.round(totalCount / ages.length)); // 29\n```\n\n## Every\n\nevery 메서드는 제공된 콜백 함수에 의해 구현된 테스트를 통과하는 배열의 모든 요소를 검증하는 데 사용됩니다.\n\nevery는 모든 요소가 콜백 함수에서 지정된 조건을 충족하는 경우에만 true를 반환합니다. 콜백 함수에서 요소 중 하나라도 테스트를 통과하지 못하면 (콜백이 false를 반환하면) every는 즉시 반복을 중지하고 false를 반환합니다.```\n\n\n\n```js\nconst ages = [31, 10, 45, 8, 6, 44, 43];\nconst allOver18 = ages.every(age =\u003e {\n   console.log(age); // 31, 10\n   return age \u003e 18\n});\nconsole.log(allOver18); // false\n```\n\n## 일부\n\nevery와 반대로 사용하며 하나 이상의 요소가 사용자 정의 조건을 충족하는지 확인하려면 some 메서드를 사용할 수 있습니다.\n\n```js\nconst ages = [10, 45, 45, 8, 6, 44, 43];\nconst isSomeoneChild = ages.some(age =\u003e age \u003c 18);\nconsole.log(isSomeoneChild); // true\n```\n\n\n\n## Flat\n\nflat 메서드는 모든 하위 배열 요소가 연결된 새 배열을 생성합니다. 이 프로세스는 재귀적일 수 있으며 지정된 깊이까지 중첩된 하위 배열을 평탄화합니다.\n\n이전에는 reduce 메서드를 사용하여 평탄화를 수행할 수 있었지만, flat은 이 작업에 대해 더 간결하고 내장된 솔루션을 제공합니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"salmon\", [\"spider\", \"horse\"]];\nconsole.log(animals.flat()); // [ \"dog\", \"cat\", \"chicken\", \"salmon\", \"spider\", \"horse\" ]\n```\n\n\n\n## FlatMap\n\n이전에 평탄화할 수 있었던 것은 map과 flat을 결합함으로써 이루어졌었습니다. 그러나 flatMap은 더 간결한 방식을 제공합니다.\n\n이 메소드는 사실상 이 두 가지 방법을 하나의 단계로 결합합니다. flatMap은 배열의 각 요소에 콜백 함수를 적용한 다음 결과를 한 단계로 평탄화하여 새 배열을 생성합니다.\n\nfilter + map을 사용한 첫 번째 예제를 살펴보겠습니다.\n\n\n\n```js\nconst owners = [\n  { name: \"Alice\", pets: [{ type: \"cat\", name: \"Luna\" }] },\n  { name: \"Bob\", pets: [{ type: \"dog\", name: \"Charlie\" }, { type: \"cat\", name: \"Whiskers\" }] },\n  { name: \"Charlie\", pets: [] },\n];\n\nconst catNames = owners.flatMap(owner =\u003e owner.pets)\n  .filter(pet =\u003e pet.type === \"cat\")\n  .map(cat =\u003e cat.name);\n\nconsole.log(catNames);\n```\n\n이제 flatMap을 사용하여 다시 작성해 봅시다.\n\n```js\nconst owners = [\n  { name: \"Alice\", pets: [{ type: \"cat\", name: \"Luna\" }] },\n  { name: \"Bob\", pets: [{ type: \"dog\", name: \"Charlie\" }, { type: \"cat\", name: \"Whiskers\" }] },\n  { name: \"Charlie\", pets: [] },\n];\n\nconst catNames = owners\n  .flatMap(owner =\u003e owner.pets.flatMap(pet =\u003e (pet.type === \"cat\" ? pet.name : [])));\n\nconsole.log(catNames); //  [\"Luna\", \"Whiskers\"]\n```\n\n## ToSpliced\n```\n\n\n\n이 기능은 splice와 유사하게 작동합니다.\n\n그러나 중요한 차이점이 있습니다: splice는 원래 배열을 직접 수정하지만 toSpliced는 제거된 요소를 제외한 새로운 배열을 생성합니다. 게다가 splice는 제거된 요소를 별도의 배열로 반환하는 반면 toSpliced는 변경된 배열 자체에 중점을 둡니다.\n\n```js\nconst animals = [\"개\", \"고양이\", \"닭\", \"상어\"];\n\nconst cleanedArray = animals.toSpliced(1, 2);\n\nconsole.log(removed); // [\"개\", \"상어\"]\nconsole.log(animals); // [\"개\", \"고양이\", \"닭\", \"상어\"]\n```\n\n## 정렬\n\n\n\n배열의 요소를 기본적으로 오름차순으로 정렬합니다. 이 메서드는 정렬된 동일한 배열에 대한 참조를 반환하며, 이제 정렬되었습니다.\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals.sort();\n\nconsole.log(animals); // [\"cat\", \"chicken\", \"dog\", \"shark\"]\n```\n\n## ToSorted\n\n원 배열을 직접 수정하는 sort 메서드와 달리, toSorted는 배열의 새로운 복사본을 만듭니다. 따라서 원래 배열은 그대로 유지됩니다.\n\n\n\n```js\nconst animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst sortedAnimals = animals.toSorted();\n\nconsole.log(sortedAnimals); // [ \"cat\", \"chicken\", \"dog\", \"shark\" ]\nconsole.log(animals); // [\"cat\", \"chicken\", \"dog\", \"shark\"]\n```\n\n## With\n\n해당 인덱스의 값을 변경합니다. 주어진 값으로 주어진 인덱스를 대체한 새로운 배열을 반환합니다. 일반적으로 대괄호와 인덱스로 이 작업을 수행하지만 기존 배열을 수정합니다.\n\n```js\nlet animals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nanimals[0] = \"spider\";\nconsole.log(animals); // [\"spider\", \"cat\", \"chicken\", \"shark\"]\n\nanimals = [\"dog\", \"cat\", \"chicken\", \"shark\"];\n\nconst newAnimals = animals.with(0, \"spider\");\n\nconsole.log(newAnimals); // [\"spider\", \"cat\", \"chicken\", \"shark\"]\nconsole.log(animals); // [\"dog\", \"cat\", \"chicken\", \"shark\"]\n```","ogImage":{"url":"/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png"},"coverImage":"/assets/img/2024-05-12-LevelUpYourJavaScriptMasteringArrayManipulationTechniques_0.png","tag":["Tech"],"readingTime":11},{"title":"러스트를 사용한 것이 괜찮았나요","description":"","date":"2024-05-12 23:55","slug":"2024-05-12-WasRustWorthIt","content":"\n\n![2024-05-12-WasRustWorthIt_0](/assets/img/2024-05-12-WasRustWorthIt_0.png)\n\n몇 년 전에 나는 모든 것을 내려놓고 WebAssembly에 100% 집중하기로 결심했습니다. 그 당시에 Rust는 WebAssembly로 컴파일하는 데 가장 좋은 지원을 제공했으며, 가장 기능이 풍부한 WebAssembly 런타임은 Rust 기반입니다. Rust가 메뉴에서 최상의 선택이었습니다. 나는 그 호기심이 어디에서 나왔는지 알기 위해 들어갔습니다.\n\n그 이후로 나는(다른 멋진 사람들과 함께) WebAssembly를 핵심 모듈 시스템으로 사용하는 응용 프레임워크 및 런타임인 Wick를 만들었습니다.\n\n![2024-05-12-WasRustWorthIt_1](/assets/img/2024-05-12-WasRustWorthIt_1.png)\n\n\n\n수년의 경력, 다양한 제품 배포, ebook, 그리고 crates.io에 배포된 ~100개의 패키지가 있으니 Rust에 대한 생각을 공유할 시간이 된 것 같아요.\n\n# 좋은 점\n\n## 더 많은 것을 적은 노력으로 유지할 수 있어요\n\n저는 테스트 주도 개발을 강력히 지지해요. 자바, 자바스크립트 같은 언어에서 테스트에 익숙해졌어요. Rust에서도 다른 언어와 마찬가지로 테스트를 작성했지만, 실패할 수 없는 테스트를 작성하게 된 걸 발견했어요. Rust 코드가 컴파일될 수 있는 지점에 도달하면 많은 오류를 고려하여 많은 일반적인 테스트 사례가 관련이 없어집니다. ''unsafe'' 블록이나 .unwrap()과 같은 패닉이 발생할 수 있는 메서드를 피한다면, 기본으로 많은 문제를 우회하는 기반이 생기게 됩니다.\n\n\n\n러스트의 빌림 검사자의 강인함, 러스트의 타입 시스템의 풍부함, 함수형 패턴 및 라이브러리, 그리고 \"null\" 값이 없는 것은 테스트하는 데 들이는 노력이 적은 상태로 더 많은 것을 유지하도록 이끕니다. Wick 프로젝트의 70,000줄 이상의 코드를 다른 언어에서 필요한 것보다 훨씬 적은 테스트로 유지했습니다.\n\n테스트를 작성해야 할 때, 그냥 추가해도 괜찮은 거예요. 러스트의 통합 테스트 하네스를 사용하면 코드 옆에 거의 생각 없이 테스트를 추가할 수 있습니다.\n\n## 이제 다른 언어에서 더 잘 코딩합니다\n\n러스트에서 코딩하는 것은 감정적으로 학대를 당하는 것과 같습니다. 러스트는 하루 종일 당신에게 소리치고, 종종 다른 생활에서는 완전히 정상적으로 여겼을 일에 대해 소리를 질러요. 결국, 그 소리를 듣는 데 익숙해져요. 그것들이 일상이 되어요. 당신은 컴파일러의 화를 부르지 않도록 갈고리를 걷는 법을 배워요. 그리고 실제 생활에서처럼, 그 행동 변화는 영원히 당신과 함께 남아 있습니다.\n\n\n\n정서적 학대는 일반적으로 변화를 격려하는 건 건강한 방법으로 여기지 않지만, 그럼에도 불구하고 변화를 일으킵니다.\n\n다른 언어로 코드를 작성할 때 순서가 맞지 않을 때나 반환 값이 확인되지 않을 때 불편함을 느낍니다. 런타임 오류가 발생하면 이성적으로 화가 나게 됩니다.\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_2.png)\n\n## Clippy 정말 좋아요!\n\n\n\n크리피는 러스트의 린터입니다, 하지만 그것을 그냥 린터라고 부르는 것은 조금 과분한 것 같아요. 컴파일러가 당신을 울게 할 수 있는 언어에서, 크리피는 린터보다는 오히려 친절한 친구 같아요.\n\n러스트 표준 라이브러리는 거대해요. 많은 기능이 다양한 작은 유형, 트레이트, 매크로, 함수에 걸쳐 퍼져 있기 때문에 이미 존재할 것으로 알고 있는 함수를 찾기가 어려워요. 많은 크리피 규칙들(예: `manual_is_ascii_check`)은 표준 라이브러리의 메서드나 유형이 더 나은 대체물이 될 수 있는 일반적인 패턴을 찾아냅니다.\n\n크리피는 성능, 가독성 및 불필요한 간접 참조를 다루는 수백 개의 규칙을 가지고 있습니다. 가능한 경우 대체 코드를 자주 제시해 줄 거예요.\n\n또한 (곧) 프로젝트용 전역 린트를 구성할 수 있게 될 것 같아요. 지금까지는 프로젝트의 일관성을 유지하기 위해 해킹 해야만 했어요. Wick에서는 몇 십 개의 크레이트에 대한 인라인 린트 구성을 자동으로 업데이트하는 스크립트를 사용해요. 러스트 커뮤니티가 이를 위한 해결책을 찾아내기까지 몇 년이 걸렸는데, 그 결과가 이런 것이 되었군요...\n\n\n\n# 나쁜 점\n\n## 살아가야 할 공백이 있습니다\n\n제가 위의 Clippy 문제로 다시 돌아올 때마다 제 정신을 의심했어요. 분명히 제가 잘못했을 거예요. 빠뜨린 설정이 있을 테니까요. 그것을 믿을 수 없었어요. 지금도 그런 생각이 들어요. 린트를 전역으로 구성할 수 있는 방법이 있을 텐데요. 이 글을 쓸 때 현실감 있는지 확인하려고 네 번이나 확인했어요. 이제는 그 문제들이 해결되었지만 그동안 몇 년 동안 계속되었었어요.\n\nClippy는 멋지지만 이러한 사용 사례가 러스트 세계 여러 곳에서 자주 발생합니다. 내 사용 사례가 다루지 않는 라이브러리나 도구를 자주 만나게 돼요. 새로운 언어나 프로젝트에서 이것이 일반적이죠. 소프트웨어는 시간(사용)이 걸려 성숙해져야 해요. 하지만 러스트는 그렇게 새로운 게 아니에요. 러스트에는 다른 느낌이 있는 거거든요.\n\n\n\n오픈 소스에서 에지 케이스는 초기 채택자와 새로운 사용자들에 의해 자주 다뤄집니다. 그들이 바로 에지 케이스를 가지고 있는 사람들이죠. 그들의 PR은 프로젝트를 개선하여 다음 사용자들에게 더 좋은 환경을 제공합니다. Rust는 거의 10년 동안 \"가장 사랑받는 언어\"로 선정되었습니다. 새로운 사용자를 유치하는 데는 어려움이 없지만, 이로 인해 혁신적으로 개선된 라이브러리나 도구가 나오지는 않습니다. 대신 특정 사용 사례를 다루는 일회성 포크가 나오는 것이 일반적입니다. 저 또한 그 중 하나인데요, 그것은 PR을 제출하려는 노력 부족 때문은 아닙니다.\n\n왜 그럴까요. 안정적인 API를 유지하는 압력과 Rust의 세밀한 유형 시스템으로 인해 라이브러리 소유자들이 반복적인 작업을 하는 것이 어려울 수 있습니다. 만약 작은 변경 사항이 큰 버전 상향을 야기하는 경우 소수의 변경 사항을 수용하기가 어려울 수 있습니다.\n\n아니면 모든 사람을 위해 모든 일을 처리하는 Rust 코드를 작성하는 것이 극도로 어렵기 때문에 사람들이 그것을 다루고 싶어하지 않을 수도 있습니다.\n\n## Cargo, crates.io 및 프로젝트 구조화 방법\n\n\n\n다른 인기있는 프로젝트를 보고 Wick 저장소 구조를 모델로 만들었어요. 합리적으로 보였고 제대로 작동했어요, 근데 언젠가부터는 문제가 발생했어요.\n\nCargo를 이용하면 모듈 크기의 상자를 쉽게 만들고 테스트할 수 있어요. 하지만 crates.io로 배포하는 건 전혀 다른 이야기네요.\n\ncrates.io로 패키지를 게시하려면 각각의 참조된 크레이트가 개별로 게시되어 있어야 해요. 그게 납득이 가는 부분이죠. 저차원의 파일시스템에만 존재하는 패키지에 의존하고 싶지 않잖아요.\n\n하지만 많은 개발자들이 큰 프로젝트를 자연스럽게 작은 모듈로 분할하는데, 자기 자신 안에만 존재하는 하위 크레이트를 가진 상위 크레이트를 게시할 수 없어요. 심지어 로컬 개발 의존성을 가진 크레이트도 게시할 수 없답니다. 이 문제를 피하려면 무작위 유틸리티 크레이트를 게시할지, 프로젝트를 다시 구조화할지 선택해야 해요. 이 제약은 임의적이고 불필요하다는 느낌이 들어요. 이렇게 구조화된 프로젝트를 만들 수는 있지만, 게시할 수는 없다는 게 함정이죠.\n\n\n\n카고는 역시 우수한 작업 공간 지원이 있어요! 카고의 작업 공간은 대부분의 언어보다 큰 프로젝트를 더 잘 관리할 수 있는 경험을 제공해줘요. 하지만 배포 문제를 해결해 주지는 않아요. 사실, 작업 공간을 설정하는 방법은 수십 가지중 어느 것도 배포를 쉽게 해결해 주지 않아요.\n\n이 문제는 실용적인 유틸리티 크레이트 수가 많아서 발생합니다. 각각은 일부 구성과 함께 작동하며, 아직까지 작업 공간을 설정하는 \"진정한 방법\"은 제가 아직 찾지 못했어요. Wick를 게시할 때, 수동적이고 반복적인 작업을 부분적으로만 작동하는 도구와 결합하는 노력이 자주 1시간 이상 걸려요.\n\n## Async\n\nRust는 시작 이후에 비동기성을 언어에 추가했어요. 이것은 나중에 생각한 것처럼 느껴지고, 그렇게 작동하며, 종종 이해하고 해결하기 어려운 오류로 인해 방해를 받을 수 있어요. 해결책을 찾을 때는 다양한 런타임 및 이들의 비동기 스타일을 기반으로 필터링해야 해요. 비동기 라이브러리를 사용하고 싶으세요? 특정 비동기 런타임 외에서 사용할 수 없는 가능성이 있어요.\n\n\n\n두 10년 이상의 JavaScript 경험에 Go 언어로 우수한 경험이 있는 만큼, Rust에서 가장 큰 단점이자 괴로움의 원천은 비동기 처리와 관련된 부분일 것입니다. 극복할 수 있는 문제이지만, 비동기 처리 기능이 필요할 때 항상 준비돼 있어야 합니다. 다른 언어들에서는 비동기 처리가 거의 눈에 띄지 않는데, Rust에서는 그렇지 않습니다.\n\n# 까다로운 부분\n\n## 리팩터링은 지루할 수 있습니다\n\nRust의 풍부한 유형 시스템은 축복이자 저주입니다. Rust 유형으로 생각하는 것은 꿈같은 경험이 될 수 있습니다. 그러나 Rust의 유형 관리는 악몽이 될 수 있습니다. 데이터와 함수 시그니처에는 일반 유형, 일반 수명 및 특성 제약사항이 포함될 수 있습니다. 이러한 제약 조건에는 고유의 일반 유형 및 수명이 포함될 수 있습니다. 때로는 실제 코드보다 유형 제약이 더 많을 수도 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_3.png)\n\n첫 번째로 작성할 때 일일히 제네릭을 모두 정의해야 합니다. 처음에 쓸 때는 지루하지만 리팩토링할 때는 작은 변경도 연쇄적인 문제로 이어질 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-WasRustWorthIt_4.png)\n\n하나의 작업을 진행하기 전에 14개의 다른 정의를 조정해야 한다면 빠른 진전을 이루기 어려울 것입니다.\n\n\n\n이해해 줘서 고마워요! 의견에 대해 수정한 내용을 적용했습니다.\n\n# 결론\n\n러스트를 좋아해요. 무엇이든 할 수 있고 다재다능한 모습을 사랑합니다. CLI 앱, 웹 서버 및 웹 클라이언트를 동일한 언어로 작성할 수 있습니다. 웹어셈블리를 사용하면 브라우저에서도 LLM을 실행할 때와 동일한 이진 파일을 사용할 수 있습니다. 이것이 여전히 제 머릿속을 뒤흔들어요.\n\n러스트 프로그램이 얼마나 견고한지 사랑합니다. 러스트가 보호해주는 것들을 깨달은 후에는 다른 언어로 돌아가기 힘들어요. 잠시 동안 Go로 돌아갔다가 빠른 개발 속도에 다시 빠지게 되었어요. 그리고 런타임 패닉이 발생하고 유리가 깨지더라구요.\n\n\n\n하지만 러스트에는 문제점이 있어요. 채용이 어렵고 배우는 데 시간이 오래 걸리며 빠르게 반복할 수 없을 정도로 엄격해요. 특히 async 코드를 다룰 때 메모리 및 성능 문제를 해결하는 게 어렵죠. 모든 라이브러리가 안전한 코드에 대해 동일하게 좋지는 않고, 개발 도구도 많이 부족해요. 시작할 때 어려움이 많고 다른 것들도 많이 방해하겠지만, 그 장애물을 극복하면 모두를 앞지를 수 있을 거예요. 하지만 이건 커다란 가정이에요.\n\n우리에게 러스트는 가치가 있었을까요? 아직 일러본도 못했어요. 작은 팀으로 놀라운 일을 해냈지만 방해요소도 많았죠. 러스트를 더 적합하게 만든 기술적 이유도 있었어요.\n\n당신에게는 가치가 있을까요? 빠르게 반복해야 한다면 아마 그렇지 않을 거예요. 알려진 범위가 있거나 초기 비용을 조금 더 감당할 수 있다면? 분명히 고려해보세요. 견고한 소프트웨어를 만들 수 있을 거예요. 매월 더 강해지는 WebAssembly 각도로 봤을 때, 한 번 완벽한 소프트웨어를 작성하고 어디서든 재사용하는 전망이 더 빨리 현실이 될 것 같아요.","ogImage":{"url":"/assets/img/2024-05-12-WasRustWorthIt_0.png"},"coverImage":"/assets/img/2024-05-12-WasRustWorthIt_0.png","tag":["Tech"],"readingTime":6},{"title":"힙 메모리 프로파일링이 나에게 메모리 누수에 대해 가르쳐준 것","description":"","date":"2024-05-12 23:53","slug":"2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks","content":"\n\n![메모리 누수에 대한 Heap 메모리 프로파일링이 가르쳐 준 것](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png)\n\n웹 개발자로서, 보통은 JavaScript(사실 TypeScript)로 코딩을 즐겨하며, 애플리케이션이 브라우저에서 실행될 때 관리되는 메모리 관리와 가비지 수집의 복잡성에 무감각하게 살아갑니다. 메모리 관리? 응, 그건 브라우저가 걱정해야 하는 문제야!\n\n가끔은 사소한 코드 변경으로 우리의 한 때는 원활하게 작동하던 애플리케이션이 녹슬은 보트처럼 갑자기 물고기처럼 움직이기 시작합니다. 느린 반응, 응달한 인터페이스, 그리고 두려운 충돌이 제 친절치 않은 동반자가 되곤 했습니다. 그래서 가끔씩, 나는 브라우저 JavaScript 메모리 개발 도구 패널의 신비한 동굴 속에서 자신을 발견하곤 합니다.\n\n개발 도구 메모리 탭의 깊은 곳으로 다시 돌아가려면 언제나 어려운 작업이 필요합니다. 거의 갈 일이 없는 이곳을 방문하려면 상기시키기가 언제나 필요하죠. 리프레셔를 통과한 후, 내 시간을 거기서 즐기기 시작했습니다. 거기에는 애플리케이션의 효율성 또는 종종 비효율성, 그리고 숨겨진 메모리 누수에 대한 통찰과 비밀이 가득한 지식의 보물창고가 있습니다.\n\n\n\n잠시만요, 브라우저 메모리 패널을 빠르게 살펴보며 만들어지는 골드를 발굴해 보겠습니다. Chrome DevTools에서 자바스크립트 힙과 메모리 할당의 신비를 풀기 위해 함께 여행을 떠날 준비가 되셨나요?\n\n# 힙이란?\n\n자바스크립트 힙은 웹 브라우저 내부의 특정 메모리 공간을 가리키며, 자바스크립트 코드에서 사용하는 데이터를 저장하는 데 전용되어 있습니다. 이는 웹 애플리케이션 실행에 특별히 예약된 대규모 메모리 풀로 이해하시면 됩니다.\n\n- 런타임 중에 자바스크립트 코드에 의해 할당된 동적 데이터를 저장합니다. 이에는 객체, 배열, 함수 및 스크립트에서 생성된 다른 데이터 구조가 포함됩니다.\n- 스택에 있는 변수(숫자나 문자열과 같은 고정 크기 데이터에 사용)와는 달리, 힙은 코드의 필요에 따라 유연하게 메모리를 할당할 수 있습니다.\n- 자바스크립트 엔진은 힙을 자동으로 관리하여 새로운 객체에 대해 메모리를 할당하고 사용되지 않는 것들에 대해서는 가비지 수집(garbage collection)이라는 과정을 통해 메모리를 회수합니다.\n\n\n\n우리는 다행히도 코드에서 직접 메모리 할당 또는 해제를 관리하지 않습니다. 하지만 힙이 작동하는 방식을 이해하면 더 효율적이고 성능이 우수한 JavaScript 코드를 작성하는 데 도움이 될 수 있어요.\n\n## 우리는 공간을 세 가지 부분으로 나눌 수 있어요\n\n- 살아 있는 객체: 현재 코드에서 사용 중인 객체로 힙 공간을 차지하고 있어요.\n- 죽은 객체: 코드에서 더는 필요하지 않지만 쓰레기 수집에 의해 회수되지 않은 객체들이에요.\n- 빈 공간: 새로운 객체를 할당하기 위해 사용 가능한 사용되지 않은 메모리공간이에요.\n\n## 이 정보를 활용해서 무엇을 할 수 있을까요?\n\n\n\n- 힙(heap)이 어떻게 작동하는지 이해하면 효율적인 메모리 관리가 가능해지며, 이는 성능과 안정성에 직접적으로 영향을 미칩니다.\n- 더 이상 필요하지 않은 객체가 의도하지 않게 보관되는 메모리 누수는 메모리 고갈, 느려짐 및 최종적으로 충돌로 이어질 수 있습니다. (오늘 이 글을 쓰게 된 동기입니다)\n\n자바스크립트 힙은 웹 애플리케이션의 메모리를 관리하는 데 중요한 역할을 합니다. 용도, 관리 전략 및 구성 요소를 이해함으로써, 보다 숙련되고 책임감 있는 개발자가 되어 효율적이고 성능이 우수한 코드를 작성하여 부드러운 사용자 경험을 제공할 수 있습니다.\n\n# 메모리 사용 분석을 위한 메모리 탭 활용 방법\n\n힙 스냅샷\n\n\n\n- 특정 시점에 전체 JavaScript 힙에 대한 스냅샷을 촬영할 수 있게 해줘요. 메모리 사용량을 캡처하는 것과 같아요. 살아있는 모든 객체와 그들의 관계를 포함하고 있어요.\n- 다른 애플리케이션 상태 간의 스냅샷을 비교하여 메모리 누수를 식별할 수 있어요.\n- 다른 객체 유형이 사용하는 메모리의 전반적인 분포를 분석할 수 있어요.\n- 불필요한 데이터를 유지하고 있는 이유를 이해하기 위해 개별 객체와 속성을 검사할 수 있어요.\n\n![이미지 파일](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_1.png )\n\n![이미지 파일](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_2.png)\n\n상호작용해보세요! 애플리케이션의 작업 흐름의 다른 단계에서 스냅샷을 찍어 메모리 사용량을 비교하고 잠재적인 누출을 식별하세요. \"스냅샷 찍기\" 버튼을 내일이 없는 것처럼 클릭해보세요!\n\n\n\n## 타임라인에 할당 계측\n\n이 옵션은 웹 애플리케이션에서 메모리 사용량을 분석하는 강력한 방법을 제공합니다. 힙 스냅숏(Heap Snapshots)과 할당 샘플링(Allocation Sampling)의 측면을 결합하여 애플리케이션 실행에 따른 메모리 할당 및 해제 이벤트를 자세히 보여줍니다.\n\n- 일정 간격으로 JavaScript 힙의 스냅숏과 해당 스냏텟들 사이에 할당 및 해제된 모든 객체에 대한 정보를 기록합니다.\n- 객체 생성(메모리 할당 이벤트) 및 객체 해제(메모리 해제 이벤트)를 나타내는 표식이 있는 시각적 타임라인을 생성합니다.\n\n![이미지](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_3.png)\n\n\n\n- 특정 사용자 상호 작용이나 코드 실행 중에 메모리 사용량이 어떻게 변화하는지 확인해 보세요.\n- 할당된 메모리를 정리하는 쓰레기 수집 주기의 효과를 분석하세요.\n\n![image](/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_4.png)\n\n- 시간이 지남에 따라 메모리가 어떻게 변하는지 명확하게 시각적으로 표현하여 잠재적인 문제를 식별하기가 더 쉬워집니다.\n\n전반적으로 할당 기기 프로필 형식은 응용 프로그램의 메모리 사용량에 대한 깊은 통찰력을 얻을 수 있는 소중한 도구이며, 잠재적인 메모리 누수를 식별하는 데 도움이 됩니다. 메모리 변화를 이해하는 데 중요한 복잡한 응용 프로그램이나 상황에 특히 유용합니다.\n\n\n\n## 할당 샘플링\n\n프로필은 애플리케이션 실행 중 특정 기간 동안 새로 할당된 JavaScript 객체에 대한 정보를 기록합니다. 다른 프로필 유형과 달리 전체 힙의 스냅샷을 캡처하지는 않지만 대신 시간 경과에 따른 메모리 할당 패턴을 추적하는 데 초점을 맞춥니다.\n\n- 메모리 핫스팟 식별: 가장 많은 메모리 할당을 담당하는 애플리케이션 내 함수 또는 코드 블록을 파악하는 데 도움이 됩니다. 이를 통해 코드의 어느 부분이 전체 메모리 사용량에 가장 크게 기여하는지 이해할 수 있습니다.\n- 시간별 메모리 변화 분석: 기간 동안 데이터를 수집하여 특정 사용자 상호작용이나 코드 실행 중 메모리 사용량이 어떻게 변하는지 볼 수 있습니다. 이를 통해 할당 증가와 관련된 메모리 누수나 병목 현상을 식별할 수 있습니다.\n- 빈번한 가비지 컬렉션 진단: 애플리케이션이 빈번한 가비지 컬렉션 주기를 겪는 경우, 할당 샘플링을 통해 가장 수명이 짧은 객체를 생성하는 코드 섹션이 어디인지 이해할 수 있습니다. 이를 통해 불필요한 할당을 줄이고 가비지 컬렉션 효율성을 향상시킬 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_5.png\" /\u003e\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_6.png\" /\u003e\n\n## 할당 샘플링 프로필에 대한 추가 참고 사항\n\n- 전체 힙을 표시하지 않습니다: \"힙 스냅샷\"과 달리 특정 시점에 전체 JavaScript 힙을 캡처하지 않습니다. 이는 누수 가능성이 있는 객체를 직접 식별할 수 없지만 어느 영역이 많이 할당되는지만 볼 수 있음을 의미합니다.\n- 자원을 많이 소비할 수 있습니다: 많은 양의 할당된 객체를 샘플링하는 것은 응용 프로그램 실행에 약간의 부하를 추가합니다. 성능에 영향을 미치지 않도록 짧은 기간 동안 신중하게 사용하십시오.\n\n할당 샘플링 프로필은 JavaScript 애플리케이션에서 메모리 할당 패턴을 프로파일링하는 데 유용한 도구입니다. 높은 메모리 사용을 가진 코드 영역을 식별하고, 시간 경과에 따른 메모리 변화를 이해하며, 빈번한 가비지 수집과 관련된 잠재적인 성능 문제를 진단하는 데 도움이 됩니다.\n\n\n\n우리 Memory Tab 프로필 중 \"Heap Snapshots\" 또는 \"Allocation instrumentation on timeline\"과 같은 다른 프로필을 대체하려는 것이 아닙니다. 서로 다른 통찰력을 제공하는 다른 도구를 선택하세요. 특정한 요구사항과 메모리 분석 목표에 따라 올바른 도구를 선택해야 합니다.\n\n힙과 메모리 프로파일링을 탐구한 결과, JavaScript 응용 프로그램 내의 메모리 관리 세계를 탐구하기 흥미롭고 비교적 편안한 곳이라는 것을 발견했습니다.\n\n메모리 누수는 때때로 발생하는 것조차 모르기 어려울 뿐 아니라 어플리케이션이 수십만 줄 또는 수백만 줄의 코드로 이루어진 상황에서 어디서 발생했는지 정확히 파악하는 것이 어렵습니다. 실수로 유지된 객체에 대한 의도하지 않은 참조로 인한 메모리 누수는 메모리 고갈, 성능 저하 및 최종적으로 어플리케이션 충돌과 같은 여러 문제를 야기할 수 있습니다. 이는 JavaScript 힙 안에서 메모리가 어떻게 할당되고 사용되며 회수되는지를 이해하는 것이 상당히 중요하다는 것을 강조합니다.\n\n이러한 지식을 바탕으로 메모리 누수를 효과적으로 식별하고 해결하는 방법 뿐만 아니라 더 효율적이고 성능이 우수한 코드를 설계하는 방법도 익혔습니다. 브라우저의 JavaScript 힙을 탐험하는 여정은 계몽적이고 능력을 부여하는 경험이 되었습니다.\n\n\n\n```\n만약 이 콘텐츠를 즐겼고 이러한 노력을 지원하고 싶다면 여기를 방문해주세요: https://ko-fi.com/jacobmacinnis.\n\n# 쉽고 날 것의 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io 에서 더 많은 콘텐츠 확인하기\n```","ogImage":{"url":"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png"},"coverImage":"/assets/img/2024-05-12-HeresWhatHeapMemoryProfilingTaughtMeAboutMemoryLeaks_0.png","tag":["Tech"],"readingTime":6},{"title":"JavaScript로 Command-Line Tool 만드는 방법","description":"","date":"2024-05-12 23:52","slug":"2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge","content":"\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png\" /\u003e\n\n# 소개:\n\n이 가이드에 오신 것을 환영합니다! JavaScript를 사용하여 명령줄 도구를 구축하는 코딩 챌린지에 도전하게 됩니다. 우리의 목표는 텍스트 파일을 분석하고 줄 수, 단어 수, 문자 수 등 다양한 메트릭을 제공할 수 있는 다재다능한 도구를 만드는 것입니다.\n\n여기에서 다룰 도전 과제를 찾을 수 있습니다. 이 작업에는 JavaScript (JS)을 사용하겠습니다. 이제 구현 세부 정보로 바로 들어가 봅시다.\n\n# 환경 설정하기\n\n명령줄 도구를 만들 때 가장 먼저 해야 할 일 중 하나는 코드를 작성할 위치를 결정하는 것입니다. 통합 개발 환경(IDE)에서의 전통적인 개발과는 달리, 스크립팅은 약간 다른 절차를 따릅니다.\n\n먼저, 컴퓨터에 Node.js가 설치되어 있는지 확인하세요. 그런 다음 다음 단계를 따르세요:\n\n- 프로젝트의 루트 디렉토리로 이동합니다.\n- mkdir bin 명령을 사용하여 'bin'이라는 새 폴더를 만듭니다.\n- 'bin' 폴더 내부에 새 파일을 만듭니다. touch `파일이름`을 사용할 수 있습니다.\n- 텍스트 편집기로 파일을 열기 위해 nano `파일이름`을 사용합니다.\n- 파일의 맨 위에 다음 해시뱅( shebang) 라인을 추가합니다: #!/usr/local/bin/node. 이 라인은 컴파일러에게 코드를 Node.js를 사용해 해석하도록 지시합니다.\n- Ctrl + O를 눌러 변경 사항을 저장한 후 Enter를 누르고 Ctrl + X를 눌러 편집기를 종료합니다.\n- chmod +x `파일이름`을 사용하여 스크립트에 실행 권한을 부여합니다.\n- bin 폴더 내부에 export PATH=\"$HOME/bin:$PATH\"를 입력합니다.\n- 이제이 스크립트를 실행할 때마다 Node.js 스크립트로 해석됩니다.\n\n# 챌린지 해결하기\n\n## 단계 1: 파일의 바이트 수 세기\n\n우리의 첫 번째 작업은 파일의 바이트 수를 계산하고 터미널에서 제공된 인수가 ‘-c’인지 감지하는 함수를 만드는 것입니다. 다음은 이를 어떻게 달성할 수 있는지입니다:\n\n```js\nconst fs = require(\"fs\");\nfunction readFileContent(fileName) {\n  if (!fs.existsSync(fileName)) {\n    console.log(`파일을 찾을 수 없습니다: ${fileName}`);\n    process.exit(1);\n  }\n\n  fs.readFile(fileName, \"utf8\", (err, data) =\u003e {\n    if (err) throw err;\n    const fileSizeInBytes = Buffer.byteLength(data, \"utf8\");\n    displayResult(fileSizeInBytes);\n  });\n}\nfunction displayResult(fileSizeInBytes) {\n  if (commandLineOption === \"-c\") {\n    console.log(`${fileSizeInBytes} ${fileName}`);\n  }\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 코드 스니펫에서는 fs.readFile 메서드를 사용하여 파일 내용을 읽고 Buffer.byteLength를 사용하여 파일 크기를 바이트 단위로 계산합니다. 그런 다음 명령줄 옵션이 ‘-c’와 일치하는 경우 결과를 표시합니다.\n\n## 단계 2: 줄, 단어 및 문자수 계산하기\n\n다음으로, 파일의 줄 수, 단어 수 및 문자 수를 계산하는 도구를 확장합니다. readFileContent 함수를 재사용하여 ‘-l’, ‘-w’ 및 ‘-m’과 같은 추가 옵션을 지원하도록 향상시킬 수 있습니다.\n\n```js\nfunction readFileContent(fileName) {\n  // 이전과 동일\n  fs.readFile(fileName, \"utf8\", (err, data) =\u003e {\n    if (err) throw err;\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n}\nfunction parseFile(data) {\n  const charactersCount = data.length;\n  const wordsCount = data.split(\" \").length;\n  const numberOfLines = data.split(\"\\n\").length;\n  return { charactersCount, wordsCount, numberOfLines };\n}\nfunction displayResult(charactersCount, wordsCount, numberOfLines) {\n  // 이전과 동일하며 '-l', '-w', '-m'에 대한 추가 조건이 있습니다.\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 수정된 코드에서는 파일 내용을 구문 분석하여 줄 수, 단어 수 및 문자 수를 계산합니다. 그런 다음 제공된 명령줄 옵션에 따라 해당 카운트를 표시합니다.\n\n## 단계 3: 표준 입력 처리\n\n파일 이름이 지정되지 않은 경우 표준 입력에서 읽기를 지원하기 위해 코드를 수정하여 다른 명령에서 입력이 파이프될 때 (예: cat test.txt | ccwc -l) 입력이 감지되는지 확인해야 합니다. 다음과 같이 이를 달성할 수 있습니다:\n\n```js\nif (!process.stdin.isTTY) {\n  let data = \"\";\n  process.stdin.setEncoding(\"utf8\");\n  process.stdin.on(\"data\", (chunk) =\u003e {\n    data += chunk;\n  });\n  process.stdin.on(\"end\", () =\u003e {\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n} else {\n  // 이전과 동일하지만 약간 수정된 부분이 있음\n}\n```\n\n표준 입력이 제공되는지 확인함으로써 (!process.stdin.isTTY), 우리는 적절하게 파이프로 연결된 입력을 처리할 수 있습니다.\n\n## 결론\n\n이 안내서에서는 코딩 도전 과제를 해결하기 위해 JavaScript로 명령줄 도구를 만드는 과정을 안내했습니다. 환경 설정, 파일에서 바이트, 라인, 단어 및 문자 수를 세는 기능 구현, 그리고 표준 입력 처리까지 다루었습니다.\n\n이 튜토리얼을 따라와 주셔서 CLI 도구 구축, Node.js 파일 처리, 그리고 동적으로 명령줄 인수를 처리하는 방법에 대한 통찰력을 얻었습니다.\n\nGitHub에서 완전한 코드 솔루션과 테스트 파일을 살펴보세요.\n\n이 안내서가 도움이 되었기를 바랍니다. 궁금한 사항이나 제안 사항이 있으면 아래에 댓글을 남겨주세요. 더 많은 튜토리얼을 기대해주세요!\n\n다음 포스트에서 뵙겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시","description":"","date":"2024-05-12 23:51","slug":"2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases","content":"\n\n\n![Image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png)\n\nIt's one of those cool things you can do in JavaScript that's immensely powerful in the real world.\n\n# Powerful practical use cases\n\n## Action (A) waiting for another (B)\n\n\n\nA는 진행 중입니다만 사용자는 B를 하고 싶지만 A가 먼저 발생해야 합니다.\n\n예시: 사용자가 게시물을 생성, 저장 및 게시할 수 있는 소셜 앱. 마치 Medium처럼.\n\n![이미지1](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_1.png)\n\n![이미지2](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_2.png)\n\n\n\n만약 사용자가 저장 중에 게시물을 발행하길 원한다면 어떻게 할까요?\n\n해결책: 발행되기 전에 게시물이 저장되도록 확인하세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:588/0*u7Littlul1VVDuUU.gif)\n\n\n\n이 논리를 Deffered 클래스로 추상화하면 더욱 좋아집니다:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_4.png)\n\n리팩토링✅:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_5.png)\n\n\n\n그리고 이전과 정확히 같이 작동합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:588/0*dv5w4HYCmh1giS5w.gif)\n\nDeferred는 훨씬 깔끔합니다. 그래서 우리는 ts-deferred, deferred, promise-deferred와 같은 수많은 NPM 라이브러리를 가지고 있습니다.\n\n![image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_6.png)\n\n\n\n## 이벤트 스트림 Promisifying하기\n\n이건 내가 여러 번 사용해 본 멋진 설정이야.\n\n실제로 이벤트 스트림이 발생할 때 대기하는 비동기 작업을 수행하는 것입니다. 내부적으로:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_7.png)\n\n\n\n# 마무리\n\n외부에서 약속을 이행하는 것은 강력한 패턴을 발휘합니다.\n\n사용자 조치부터 이벤트 스트림까지 깔끔하고 유연한 코드를 유지합니다. 그리고 ts-deferred와 같은 라이브러리를 사용하면 더 나은 처리가 가능합니다.\n\n# 자바스크립트가 하는 모든 미친 일\n\n\n\n알고 있던 것이 모두라 생각했을 때 새로운 것을 알려드릴게요.\n자바스크립트의 세심한 주의사항과 잘 알려지지 않은 부분들을 담은 Every Crazy Thing JavaScript Does 가이드로 고통스러운 버그를 피하고 소중한 시간을 절약하세요.\n\n오늘 여기서 무료로 받아보세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_8.png)","ogImage":{"url":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png"},"coverImage":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png","tag":["Tech"],"readingTime":2},{"title":"브라우저 아키텍처의 과거와 현재","description":"","date":"2024-05-12 23:47","slug":"2024-05-12-ThePastandPresentofBrowserArchitecture","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png\" /\u003e\n\n브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.\n\n# 1. 브라우저 아키텍처의 진화\n\n2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:\n\n\n\n![브라우저 아키텍처의 과거와 현재](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png)\n\n단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:\n\n- 불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.\n- 부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.\n- 보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.\n\n단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.\n\n\n\n2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:\n\n![다이어그램](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png)\n\n이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.\n\n프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.\n\n\n\n멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.  \n\n샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다. \n\n최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:\n\n![Chrome Browser Components](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png)\n\n\n\n브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 \"스케줄러\"로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.\n\nGPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.\n\n현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:\n\n![Diagram](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png)\n\n\n\n# 2. 브라우저 페이지 열리는 과정\n\n- 탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.\n- 사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.\n- 브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.\n- 네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.\n- 캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.\n- 네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.\n- 200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.\n- 브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.\n- 브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 \"문서 제출\" 메시지를 보냅니다.\n- 데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.\n\n# 3. 렌더링 프로세스\n\n현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:\n\n\n\n- 사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.\n- URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.\n- DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.\n- 소켓 연결 — 사용자와 서버 IP 간의 연결 설정.\n- HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.\n- 서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.\n- 플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.\n- 브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.\n- 응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.\n- DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.\n- 스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.\n- JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.\n- 페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.\n\n## 3.1 HTML 구문 분석\n\n브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.\n\n## 3.2 CSS Object Model\n\n\n\nCSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.\n\n## 3.3 레이아웃 관리자\n\n레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.\n\n# 4 플러그인 메커니즘\n\n\n\n## 4.1 플러그인 개발 역사\n\n플러그인 메커니즘의 개발 과정은 다음과 같습니다:\n\n- 2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.\n- 2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.\n- 2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.\n- 2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.\n- 2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.\n- 2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.\n- 2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.\n- 2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.\n- 2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.\n- 2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.\n- 2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.\n- 2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.\n- 2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.\n- 2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.\n- 2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.\n- 2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.\n- 2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.\n- 2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.\n- 2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.\n\n총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.\n\n\n\nManifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.\n\n## 4.2 Manifest의 기능 및 버전 이전\n\nManifest V2의 기능:\n\n- Content-Security-Policy (CSP)를 설정하여 script-src 'self'; object-src 'self';를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.\n- 플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.\n- 브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.\n\n\n\nManifest V3의 기능:\n\n- Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.\n- 네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.\n- 원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.\n- Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.\n- Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.\n- 웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.\n- 콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.\n\nManifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.\n\nV2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.\n\n\n\n또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.\n\n## 4.3 Chrome 확장 프로그램의 주요 구성 요소\n\n4.3.1 매니페스트 파일\n\n매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.\n\n\n\nManifest V2의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 2,\n  // 플러그인 이름\n  \"name\": \"...\",\n  // 플러그인 버전\n  \"version\": \"1.0.0\",\n  // 플러그인 설명\n  \"description\": \"...\",\n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  // 브라우저의 백그라운드 JS 또는 백그라운드 페이지\n  \"background\": {\n    \"scripts\": [\"js/background.js\"]\n  },\n  // 브라우저 아이콘 설정: browser_action, page_action, app\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 특정 페이지가 열릴 때에만 표시되는 아이콘\n  \"page_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 페이지에 직접 주입되는 JS\n  \"content_scripts\": [{\n    \"matches\": [\"\u003call_urls\u003e\"],\n    \"js\": [\"js/content-script.js\"],\n    \"css\": [\"css/custom.css\"],\n    // 코드 주입 시기, 기본값은 document_idle\n    \"run_at\": \"document_start\"\n  }],\n  // 요청되는 권한\n  \"permissions\": [\n    \"contextMenus\", // 우클릭 메뉴\n    \"tabs\", // 탭\n    \"notifications\", // 알림\n    \"webRequest\", // 웹 요청\n    \"webRequestBlocking\",\n    \"storage\", // 플러그인 로컬 저장소\n    \"https://*/*\" // executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트\n  ],\n  // 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", // 플러그인 홈페이지\n  \"chrome_url_overrides\": { // 브라우저 기본 페이지 재정의\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": { // 플러그인 옵션 페이지\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": { \"keyword\" : \"...\" }, // 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능\n  \"default_locale\": \"en\", // 기본 언어\n  \"devtools_page\": \"devtools.html\", // Devtools 페이지 진입점, HTML 파일만 지정 가능    \"content_security_policy\": \"...\", // 보안 정책\n  \"web_accessible_resources\": [ // 로드 가능한 리소스\n    \"RESOURCE_PATHS\"\n  ]\n}\n```\n\nManifest V3의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 3,\n  \"name\": \"...\", \n  \"version\": \"1.0.0\",\n  \"description\": \"...\", \n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  \"background\": {\n    \"service_worker\": \"js/background.js\"\n  },\n  \"action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\", \n    \"default_popup\": \"popup.html\"\n  },\n  \"content_security_policy\": {\n    \"extension_pages\": \"...\",\n    \"sandbox\": \"...\"\n  },\n  \"web_accessible_resources\": [\n    {\n      \"resources\": [\"RESOURCE_PATHS\"]\n    }\n  ],\n  \"permissions\": [\n    \"contextMenus\",\n    \"tabs\",\n    \"notifications\",\n    \"webRequest\",\n    \"webRequestBlocking\",\n    \"storage\",\n    \"https://*/*\"\n  ],\n  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", \n  \"chrome_url_overrides\": {\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": {\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": {\n    \"keyword\": \"...\"\n  },\n  \"default_locale\": \"zh_CN\", \n  \"devtools_page\": \"devtools.html\",\n  \"content_security_policy\": \"...\",\n  \"web_accessible_resources\": [\"RESOURCE_PATHS\"]\n}\n```\n\n\n\n4.3.2 콘텐츠 스크립트\n\n크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.\n\n- chrome. extension\n- chrome.i18n\n- chrome. runtime\n- chrome.storage\n\n다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.\n\n\n\n### 4.3.3 배경 스크립트\n\n크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.\n\n### 4.3.4 팝업 창\n\n팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.\n\n\n\n### 4.3.5 스크립트 삽입\n\n크롬 확장 프로그램 개발 중 개발자들이 \"스크립트 삽입\"이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.\n\n## 4.4 크롬 확장 프로그램의 통신 메커니즘\n\n크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:\n\n\n\n- 인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.\n- 컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.\n- 팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.\n- 백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, \"chrome.tabs.sendMessage\", chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.\n- 개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.\n\n각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.\n\n과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"},"coverImage":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png","tag":["Tech"],"readingTime":15},{"title":"디자인 패턴 더 나은 코드 작성하기","description":"","date":"2024-05-12 23:46","slug":"2024-05-12-DesignPatternsBuildingBetterCode","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png\" /\u003e\n\n## 소개\n\n소프트웨어 개발 세계에서 효율적이고 유지보수 가능하며 확장 가능한 코드를 작성하는 것이 매우 중요합니다. 하지만 프로젝트가 복잡해지면 이를 관리하는 것이 점점 어려워집니다. 여기서 디자인 패턴이 필요해집니다.\n\n## 디자인 패턴이란 무엇인가요?\n\n\n\n디자인 패턴은 코딩에서 흔히 발생하는 문제에 대한 준비된 솔루션과 같아요. 그들은 개발자들이 항상 직면하는 까다로운 코딩 퍼즐을 해결하기 위한 레시피 같습니다. 요리를 할 때 레시피를 사용하는 것처럼, 개발자들은 디자인 패턴을 사용하여 똑똑한 방식으로 코드를 작성해요.\n\n## 디자인 패턴을 사용하는 이유는?\n\n디자인 패턴은 유용합니다:\n\n코드 재사용성: 재사용 가능한 솔루션을 제공하기 때문에, 개발자들은 문제를 만날 때마다 바퀴를 다시 발명할 필요가 없어요.\n\n\n\n# 확장성: 새로운 기능을 추가하거나 프로젝트의 규모를 확장하는 데 도움을 줍니다. 이렇게 함으로서 코드를 엉망으로 만들지 않고 처리할 수 있습니다.\n\n# 유지보수성: 프로젝트가 시간이 지나도 코드를 조직화하고 이해하기 쉽게 도와줍니다.\n\n# 오류 감소: 정해진 패턴을 따름으로써 개발자는 흔한 실수와 버그를 피할 수 있습니다.\n\n# 성능 향상: 디자인 패턴은 효율적인 코딩 방법을 장려하여 더 나은 성능의 소프트웨어로 이끕니다.\n\n\n\n협업: 여러 개발자가 동일한 코드베이스에서 작업하기가 더 쉽습니다. 팀워크와 생산성을 촉진합니다.\n\n## 디자인 패턴의 종류\n\n주요 세 가지 유형이 있습니다:\n\n생성 패턴: 이러한 패턴은 객체가 어떻게 생성되는지 다룹니다. 객체를 언제, 어떻게 생성할지 결정하는 데 도움이 됩니다. 코드의 유연성과 성능을 향상시킬 수 있습니다.\n\n\n\n구조 패턴: 이러한 패턴은 클래스와 객체가 대형 구조를 형성하는 방식에 중점을 둡니다. 코드를 이해하고 유지 관리하기 쉬운 방식으로 구조화하는 데 도움을 줍니다.\n\n행동 패턴: 이러한 패턴은 객체 간의 통신 방식을 정의합니다. 코드를 유연하고 결합도가 낮은 방식으로 설계할 수 있게 도와줍니다. 이는 코드의 다른 부분이 서로에게 지나치게 의존하지 않도록 합니다.\n\n## 일반적으로 사용되는 디자인 패턴\n\n생성 패턴:\n\n\n\n- 팩토리 메서드: 이 패턴은 구체적으로 인스턴스화할 클래스를 지정하지 않고 객체를 생성하는 데 도움을 줍니다. 이는 느슨한 결합을 촉진하고 코드를 더 유연하게 만듭니다.\n\n```js\n{\nclass Fruit {\nconstructor(name) {\nthis.name = name;\n}\neat() {\nconsole.log(`${this.name}을(를) 먹는 중`);\n}\n}\nclass FruitStand {\nstatic create(name) {\nreturn new Fruit(name);\n}\n}\nconst fruit1 = FruitStand.create(\"사과\");\nconst fruit2 = FruitStand.create(\"오렌지\");\nfruit1.eat(); // 사과를 먹는 중\nfruit2.eat(); // 오렌지를 먹는 중\n}\n```\n\n- 싱글톤: 이 패턴은 클래스가 하나의 인스턴스만 가지도록 보장하고 해당 인스턴스에 대한 전역 액세스 지점을 제공합니다. 설정 또는 로깅에 유용하지만 남용하면 결합이 강화될 수 있으므로 삼가 사용하세요.\n\n```js\nclass Singleton {\nconstructor() {\nif (Singleton.instance) {\nreturn Singleton.instance;\n}\nSingleton.instance = this;\n}\n// 여기에 코드 작성\n}\nmodule.exports = Singleton;\n```\n\n\n\n프론트엔드 개발자님 안녕하세요!\n\n- Builder: 복합 객체의 생성을 표현으로부터 분리하여 동일한 생성 프로세스가 다양한 표현을 만들 수 있게 합니다. 많은 선택적 매개변수나 구성을 갖는 객체를 다룰 때 매우 유용합니다.\n\n구조 패턴:\n\n- Adapter: 이 패턴을 사용하면 호환되지 않는 인터페이스끼리 함께 작동할 수 있습니다. 서로 다른 인터페이스를 가진 두 클래스 사이에 다리 역할을 합니다.\n\n```js\n// 기존 Animal 클래스\nclass Animal {\nconstructor(name) {\nthis.name = name;\n}\nspeak() {\nconsole.log(`${this.name} makes a sound.`);\n}\n}\n// Adapter 클래스\nclass LionAdapter {\nconstructor(animal) {\nthis.animal = animal;\n}\nroar() {\nconsole.log(`${this.animal.name} roars loudly!`);\n}\n}\n// 사용법\nconst genericAnimal = new Animal(\"일반 동물\");\nconst lion = new LionAdapter(genericAnimal);\nlion.roar(); // 일반 동물이 크게 웁니다!\n```\n\n\n\n- 데코레이터: 이 패턴은 기존 객체에 동적으로 새로운 기능을 추가합니다. 핵심 기능을 수정하지 않고 여러 데코레이터를 추가할 수 있습니다.\n\n행동 패턴:\n\n- 옵저버: 이 패턴은 객체 간의 일대다 종속성을 정의합니다. 한 객체의 상태 변경 시 모든 종속 객체에게 알립니다. 이는 이벤트 처리나 실시간 업데이트와 같은 기능을 구현하는 데 유용합니다.\n\n```js\nclass FruitObserver {\nconstructor() {\nthis.observers = [];\n}\nsubscribe(fn) {\nthis.observers.push(fn);\n}\nunsubscribe(fn) {\nthis.observers = this.observers.filter(fruitListener =\u003e fruitListener !== fn);\n}\nnotify(data) {\nthis.observers.forEach(observer =\u003e observer(data));\n}\n}\nconst fruitObserver = new FruitObserver();\nfruitObserver.subscribe(data =\u003e console.log(`Subscribed to ${data}`));\nfruitObserver.notify(\"Apple\"); // Subscribed to Apple\n```\n\n\n\n- 전략: 이 패턴은 알고리즘의 동작을 실행 중에 동적으로 변경할 수 있게 합니다. 클라이언트 코드를 수정하지 않고 다양한 전략 사이를 전환할 수 있습니다.\n\n## 결론\n\n디자인 패턴을 코드의 구성 요소로 생각해보세요. 프로그래머들이 자주 마주치는 문제에 대한 검증된 솔루션이죠. 이러한 패턴을 배움으로써, 초보자든 전문가든 상관없이 빠르게 더 좋은 코드를 작성할 수 있습니다.\n\n읽어주셔서 감사합니다! 🎉","ogImage":{"url":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png"},"coverImage":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" /\u003e\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" /\u003e\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent\u003cany\u003e) =\u003e {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cunknown\u003e\u003e {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) =\u003e {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" /\u003e\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},{"title":"Gulp v5를 발표 내용 정리","description":"","date":"2024-05-12 23:43","slug":"2024-05-12-AnnouncingGulpv5","content":"\n![Announcing Gulp v5.0](/assets/img/2024-05-12-AnnouncingGulpv5_0.png)\n\ngulp 5로 가는 길은 길었지만, 우리가 여기까지 왔어요! 이 릴리스에는 60개 이상의 프로젝트에 대한 4년치 작업이 포함되어 있습니다. 함께하여 팀은 200개 이상의 이슈와 풀 리퀘스트를 마무리했어요. 🤯\n\n# Streamx\n\n처음부터 gulp는 스트림을 중심으로 만들어졌어요. gulp 5에서는 mafintosh의 우수한 streamx 라이브러리로 전환했어요. Streamx에는 Node.js 코어 스트림 대비 여러 이점이 있습니다. `pipe()` 함수에서 객체 및 버퍼 모드를 투명하게 처리하며 에러 처리가 가능해요.\n\n저희는 이 훌륭한 스트림 구현에 대해 더 많은 글을 쓸 시간을 갖고 싶어합니다. 그러나 대부분의 사용자들은 Node.js 코어 스트림과의 호환성을 유지하려는 노력 덕분에 차이를 느끼지 못할 것입니다. gulp 5 개발 과정에서 Mathias님의 도움과 버그 수정에 감사드립니다! 그의 작업을 후원해주시기를 고려해 주세요.\n\n# 종속성\n\n이번 릴리스의 주요 초점은 의존성 트리를 줄이고 대부분 유지하는 것으로 통합하는 데 있습니다. gulp 4가 발표된 이후 사용하던 많은 종속성이 유지되지 않았고, 따라서 이를 제거하거나 유지 책임을 갖기로 결정했습니다.\n\ngulpjs GitHub 조직은 70개 이상의 저장소로 성장했습니다. 이 세분화된 분리는 우리가 빠르게 작은 수정을 할 수 있게 하며, 다른 프로젝트들이 우리 패키지의 일부에 의존할 수 있게 합니다. 그러나 이에 대한 희생은 프로젝트 전체에 대한 대규모 변화를 만들기까지 시간이 걸린다는 것입니다.\n\n# 주요 변경 사항\n\n\"breaking changes\"가 없는 SemVer 주요 릴리스는 없겠죠. 유저들이 업그레이드할 때 문제가 없거나 거의 없기를 바라지만, 변경된 사항을 꼭 숙지하셔야 합니다.\n\n이번 대규모 릴리스에서 여기서 다루는 변경 사항은 일부분에 불과하기 때문에, 무언가가 다르게 느껴지는 것이 있다면 저희의 종합 변경 로그와 개별 프로젝트 변경 로그를 확인해주세요.\n\n## 스트림 인코딩\n\n저희 스트림은 이제 UTF-8 인코딩이 기본 설정으로 적용됩니다. 이전에는 스트림이 발생한 데이터를 인코딩을 고려하지 않고 그대로 가져왔었는데, 이번 릴리스에서는 10년 된 문제를 해결하여 사용자 정의 인코딩을 지원하고 이를 기본값으로 UTF-8로 설정했습니다. 대부분의 사용 방법은 gulp을 변경할 필요가 없을 것이지만, 일부 플러그인은 UTF-8이 아닌 출력물을 생성할 수 있으며 gulp 스트림에서 `' encoding: false '`로 설정해야 할 수 있습니다.\n\n## 글롭(Globs)\n\n또한 모든 API에서 글로빙 라이브러리를 통일했습니다. 이전에는 `src()`가 node-glob 라이브러리를 사용하고 `watch()`가 anymatch 라이브러리를 chokidar를 통해 사용했었습니다. 몇 년 동안 특정 글로브들이 이러한 함수 간에 동일하게 작동하지 않는 문제가 여러 개 개설되었었습니다. gulp 5부터는 글로브 지원으로 일관되게 anymatch를 사용합니다.\n\n게다가 “순서가 있는 글로브(ordered globs)\"를 더 이상 지원하지 않습니다. “순서가 있는 글로브\"는 음수 글로브가 배열에서 뒤에 나오는 양수 글로브에 의해 무시될 수 있는 기능이었습니다. 다른 글로빙 라이브러리에서는 이것이 흔하지 않기 때문에 모든 음수 글로브는 생태계에 일관성을 주기 위해 모든 양수 글로브에서 경로를 필터링합니다. 순서가 있는 스트림이 필요하면, ordered-read-streams 라이브러리를 제공합니다.\n\n## CLI\n\n우리는 `swc`, `esbuild`, 그리고 `sucrase`의 로더를 추가했어요. 많은 사용자들이 `.mjs`와 `.cjs` 확장자를 지원해줄 것을 요청했기 때문에, 이제 이 둘을 사용할 수 있어요. 의존성 트리를 간소화하는 과정에서 많은 구식이며 폐기된 로더들을 제거했어요. 만약 우리가 지원했던 더 색다른 로더들을 사용 중이셨다면, 더 현대적인 것으로 변경해야 할지도 모르겠어요.\n\n우리는 `—verify` 플래그를 마침내 제거했어요. 왜냐하면 오랫동안 플러그인 금지 목록을 유지하지 않고 있어서 그랬거든요. 그리고 `—require`를 `—preload`로 이름을 변경해야 했어요. 그렇게 함으로써 Node.js 플래그와 충돌을 피할 수 있어요.\n\n## Logging\n\n`gulplog`을 사용하는 모든 플러그인은 v1에서 v2로 업그레이드해야 하며, 만약 v1을 사용 중이면 사용자에게 사용 중단 경고가 표시됩니다.\n\n# 노드 지원\n\n우리는 오랫동안 gulp가 안정적인 소프트웨어임을 말해 왔으며, 가능한 많은 사용자를 지원하는 것에 관심이 있습니다. Gulp 4는 릴리스 시점에 널리 사용되었던 Node.js v0.10 사용자를 목표로 지원하는 것을 명시적으로 설정하였습니다. 10년이 지난 지금, 플랫폼이 성장하고 JavaScript가 발전함에 따라 Node.js는 이제 6개월마다 새로운 안정 버전을 출시하며, LTS 지원 기간은 30개월입니다. 이러한 새로운 버전에는 gulp를 더 나아지고 더 안정적으로 만들기 위해 활용하길 원하는 기능이 포함되어 있어서, 우리는 Node.js v10.13.0 미만의 모든 버전을 지원 중단했습니다.\n\n지원하는 Node.js 버전을 제한함으로써 의존성 트리에서 많은 플랫폼 및 JavaScript 쉼들을 제거할 수 있었습니다. 이 중 많은 부분은 유지보수되지 않았거나 스캐너에 의해 문제가 발견된 것입니다. 2018년에 발표된 Node.js 버전(그리고 LTS 지원 기간 외부)을 계속 지원함으로써 희망을 갖고 있습니다. 모든 사용자가 gulp 5로 원활하게 업그레이드할 수 있기를 바랍니다.\n\n마침내, 우리는 Windows, Mac 및 Linux을 우선 플랫폼으로 고려해 왔기 때문에 v3, v4 및 v5 사이의 인프라에 상당한 변동이 있었습니다. 이 세 가지 운영 체제를 일관되게 지원하고 사용하기 쉬운 지속적 통합 서비스를 찾는 데 많은 시간이 소요되었습니다. 우리는 우리 주요 대상을 지원하고 release-please와 같은 도구를 활용할 수 있는 GitHub Actions을 중심으로 인프라를 안정화하는 데 상당한 시간을 투자했습니다.\n\n# 앞으로\n\n할 일은 언제나 더 많이 남아 있습니다. 다가오는 몇 주 동안, 나는 우리 v5 이후 프로젝트 보드를 검토하고 중단되지 않는 후속 작업을 위한 토의를 만들 계획입니다. 우리는 gulp 5를 일정 기간 안정화한 후 다음 주요 버전을 계획하기 전에 문제가 발생하면 수정할 수 있도록 할 것입니다.\n\n우리는 더 넓은 커뮤니티로부터 피드백을 받기 위해 설문 조사를 작성 중입니다. 5월 경에 발표될 예정이니 주목해주시기 바랍니다.\n\n지금은 새 릴리스를 즐기시길 바라며, 프로젝트에 기여하거나 저희의 작업을 후원해주시면 감사하겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png"},"coverImage":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png","tag":["Tech"],"readingTime":4}],"page":"50","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"50"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>