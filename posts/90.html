<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/90" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/90" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법" href="/post/2024-05-15-InjectingComposableswithDaggerwithoutlosingit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터폼 용어 및 인증 흐름 이해하기" href="/post/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터폼 용어 및 인증 흐름 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터폼 용어 및 인증 흐름 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터폼 용어 및 인증 흐름 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제" href="/post/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지" href="/post/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RAG 모델 구축하기  Databrick으로 쉽게 만들기" href="/post/2024-05-15-RAGyourmodelSimplifiedwithDatabrick"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RAG 모델 구축하기  Databrick으로 쉽게 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RAG 모델 구축하기  Databrick으로 쉽게 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">RAG 모델 구축하기  Databrick으로 쉽게 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간" href="/post/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기" href="/post/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라라벨에 다크 모드토글 버튼 포함 추가하는 방법" href="/post/2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라라벨에 다크 모드토글 버튼 포함 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라라벨에 다크 모드토글 버튼 포함 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">라라벨에 다크 모드토글 버튼 포함 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="카오스 엔지니어링 파트 I 소개 및 개념" href="/post/2024-05-15-ChaosEngineeringPartIIntroductionConcepts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="카오스 엔지니어링 파트 I 소개 및 개념" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ChaosEngineeringPartIIntroductionConcepts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="카오스 엔지니어링 파트 I 소개 및 개념" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">카오스 엔지니어링 파트 I 소개 및 개념</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개발 속도를 높이고 비용을 절감하는 방법 SAPI" href="/post/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발 속도를 높이고 비용을 절감하는 방법 SAPI" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발 속도를 높이고 비용을 절감하는 방법 SAPI" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">개발 속도를 높이고 비용을 절감하는 방법 SAPI</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link posts_-active__YVJEi" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Dagger를 사용하여 컴포저블을 주입시키되, 그것을 잃지 않는 방법","description":"","date":"2024-05-15 15:54","slug":"2024-05-15-InjectingComposableswithDaggerwithoutlosingit","content":"\n\n\n![Injecting Composables with Dagger without losing it](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png)\n\nEveryone is using Hilt/Koin or some other fancy DI framework that just works™.\n\nIn this house, we still use plain Dagger2. It’s… not going great.\n\nConsider the predicament of a composable that can only work with certain parameters:\n\n\n\n\n가끔 composable들이 호출자에게 너무 많은 것을 요구하는 경우가 있어요.\n\n이 때는 아마도 이미 너무 깊이 들어간 상황일 것이고, 이를 바꾸려면 다른 10가지 것들을 깨뜨려야 할 수도 있어요.\n\n## 정리\n\n이 게시물의 목표는 독립적인 composable을 만드는 방법을 찾는 것입니다:\n\n\n\n- 자체 Dagger 컴포넌트를 생성합니다.\n- 자신을 주입합니다.\n- 사용자 정의 팩토리로 ViewModel을 빌드합니다.\n- ViewModels 및 Compose에 대한 자세한 정보는 이 미미/블로그를 확인해주세요.\n\n## 요약\n\n## 시작점\n\nDagger2로 활동/프래그먼트를 일반적으로 사용합니다.\n\n\n\n- 자체 Dagger 컴포넌트를 빌드합니다\n- 또는 애플리케이션 컴포넌트에서 일부 의존성을 가져옵니다\n\n그런 다음 의존성을 파라미터로 컴포저블에 아래로 전달할 것입니다 (현재 그대로 또는 함수를 통해):\n\n정보는 CompositionLocals로도 전달할 수 있습니다.\n\n이 방법은 논란의 여지가 있는데, 최소한 이 글에서는 다루지 않겠습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_1.png\" /\u003e\n\n## 이주\n\nFirstScreen을 독립적으로 만들기 위해서는 주입된 종속성을 별도의 클래스로 분리해야 합니다.\n\n@Stable 주석을 사용하면 생성된 후에 실제로 변경되지 않을 것을 compose 컴파일러에 알릴 수 있습니다.\n\n\n\n## Dagger 구성 요소\n\n## Compose 레이어\n\n이 방법은 처음에는 작동하지만 매번 재구성할 때마다 Dagger 구성 요소가 다시 생성됩니다.\n\n이와 같이 무해한 예제에 대해서는 성능에 거의 영향을 미치지 않을 것입니다. 그러나 보다 복잡한 화면에 대해서는 그렇지 않을 수 있습니다.\n\n\n\n\nLet’s use the classic remember keyword, then:\n\n![image](/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_2.png)\n\n## Should someone actually do this?\n\nThis approach goes against most compose guidelines. Composables should really be pure functions, fast, idempotent, and free of side effects.\n\n\n\n\n하지만 주요 리팩터링이 실현 가능하지 않을 때, 너무 많은 노력을 들이지 않고 작동시킬 수 있어요.\n\n## 잊지말고요 (미안해요😑)\n\n효율성이 중요하다면, 간단히 처리할 수 없을 거에요. Ian Lake가 여기에서 왜 설명하는지 알려줄게요:\n\n위와 같은 경우에는 DI 구성 요소가 다시 생성되어 composable로 주입될 거예요.\n\n\n\n세계의 끝은 아니지만, 특히 무거운 Dagger 구성 요소의 경우에는 약간의 단점이 있습니다.\n\n만약 기억하는 값을 너무 쉽게 잃어버리지 않을까 걱정된다면, 더 고급 스코핑 옵션 2가지가 있습니다:\n\n- **resaca**\n    - sebaslogen에 의해 만들어졌습니다. 정말 좋아요! 👍\n- **Circuit**\n    - Slack에 의해 만들어졌습니다. 더 강력한 기억 형태 이외에도 더 많은 기능들을 제공합니다. 개인적인 경험은 없습니다.\n\n## 그래도요\n\n\n\n조금이나마 도움이 되었기를 바랍니다.\n\n@markasduplicate\n\n나중에 봐요.","ogImage":{"url":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png"},"coverImage":"/assets/img/2024-05-15-InjectingComposableswithDaggerwithoutlosingit_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터폼 용어 및 인증 흐름 이해하기","description":"","date":"2024-05-15 15:52","slug":"2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow","content":"\n\n## MLOPS: 데이터 파이프라인 오케스트레이션\n\n![이미지](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png)\n\nDataform은 팀이 복잡한 SQL 기반 데이터 파이프라인을 개발하고 운영할 수 있게 해주는 GCP 서비스의 일환으로 추가된 새로운 서비스입니다. Dataform은 소프트웨어 엔지니어링의 최고 관행인 테스팅, 환경, 버전 제어, 종속성 관리, 오케스트레이션 및 자동 문서화를 데이터 파이프라인에 적용할 수 있습니다. 이는 GCP 내에서 서버리스, SQL 워크플로 오케스트레이션의 주요 요소입니다. 위의 이미지에서 볼 수 있듯이 Dataform은 원시 데이터를 가져와 소프트웨어 엔지니어링의 최고 관행을 적용하여 구조화가 잘 된 데이터를 생산합니다.\n\n이 게시물의 영감은 저희 프로젝트 중 하나인 기존 Dataform의 웹 UI에서 GCP BigQuery로의 마이그레이션 중 발생했습니다. 마이그레이션 중, 릴리스 구성, 워크플로 구성 및 개발 워크스페이스와 같은 용어들이 정말 혼란스럽고 납득하기 어려웠습니다. 이것이 GCP Dataform에서 사용되는 일부 새로운 용어를 설명하는 게시물을 작성하게 된 동기가 되었습니다. 또한 GCP에서 단일 저장소 다중 환경 Dataform 작업의 기본 흐름을 강조할 것입니다. Dataform을 설정하는 다양한 방법이 있으므로 구글의 모베스트 관행을 확인해보세요.\n\n\n\n이것은 데이터폼의 기초와 설정을 다룬 2부작 시리즈 중 첫 번째 부분입니다. 제2부에서는 데이터폼을 프로비저닝할 때 최소 액세스 제어를 구현하는 방법을 보여드리겠습니다. 이에 대한 미리보기를 원하신다면 저장소를 확인해보세요.\n\n# 용어\n\n데이터폼에서의 구현은 GitHub 워크플로우와 유사합니다. 두 가지 간 유사성을 대조하고 이해하기 쉽도록 비유를 만들어보겠습니다. 데이터폼을 로컬 GitHub 저장소로 상상하는 것은 쉽습니다. 데이터폼을 설정할 때 로컬 GitHub이 원격 소스와 함께 연결되는 것과 유사한 방식으로 원격 저장소가 구성되도록 요청될 것입니다. 이 시나리오 설정을 염두에 두고 빠르게 데이터폼 용어를 살펴보겠습니다.\n\n## 개발 워크스페이스\n\n\n\n로컬 GitHub 브랜치와 유사한 개념입니다. GitHub의 main에서 브랜치를 만드는 것과 유사하게, 새로운 Dataform 개발 워크스페이스는 main Dataform 저장소 코드의 편집 가능한 사본을 체크아웃합니다. 개발 워크스페이스는 GitHub 브랜치처럼 서로 독립적입니다. 코드 개발과 실험은 개발 워크스페이스 내에서 진행되며, 코드가 커밋되고 푸시되면 개발 워크스페이스와 유사한 이름의 원격 브랜치가 생성됩니다. 개발 워크스페이스로 코드를 체크아웃하는 GitHub 저장소는 구성 가능하며, main 브랜치나 원격 저장소의 다른 브랜치 중 어디서든 가능합니다.\n\n## 릴리스 구성\n\nDataform은 데이터 변환과 로직을 위해 .sqlx 스크립트와 Javascript .js를 혼합하여 사용합니다. 결과적으로 코드베이스의 표준적이고 재현 가능한 파이프라인 표현을 얻기 위해 먼저 코드베이스의 컴파일을 생성하고 스크립트가 데이터로 구체화될 수 있는지 확인합니다. 릴리스 구성은 이 컴파일이 수행되는 자동화된 프로세스입니다. 구성된 시간에, Dataform은 원격 main 저장소의 코드를 체크아웃하고 JSON 구성 파일로 컴파일합니다. 코드를 체크아웃하고 컴파일을 생성하는 과정이 릴리스 구성이 다루는 내용입니다.\n\n## Workflow 구성\n\n\n\n릴리즈 구성의 출력물은 .json 구성 파일입니다. 워크플로 구성은 구성 파일을 언제 실행할지, 누가 실행해야 하는지 및 어느 환경에 구성 파일 출력물이 표시되거나 작성될지를 결정합니다.\n\n워크플로 구성은 릴리즈 구성의 출력물이 필요하기 때문에, 릴리즈 구성보다 이후에 실행되도록하는 것이 합리적입니다. 그 이유는 릴리즈 구성이 먼저 원격 저장소에 인증해야 하고(때로 실패할 수 있음), 코드를 체크아웃하고 컴파일해야 하기 때문입니다. 이러한 단계는 몇 초 안에 발생하지만 네트워크 연결 장애의 경우 더 많은 시간이 소요될 수 있습니다. 워크플로 구성은 릴리즈 구성에 의해 생성된 .json 컴파일 파일이 필요하기 때문에, 릴리즈 구성보다 나중에 예약하는 것이 의미가 있습니다. 동시에 예약하면 워크플로 구성이 이전 컴파일을 사용할 수 있으므로, 최신 변경 사항이 바로 BQ 테이블에 반영되지 않을 수 있습니다. 다음 워크플로 구성이 실행될 때까지 또는 BQ 테이블에 반영되지 않습니다.\n\n## 환경\n\n\u003cimg src=\"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_1.png\" /\u003e\n\n\n\nDataform의 기능 중 하나는 코드를 개발, 스테이징 및 프로덕션과 같은 다른 환경으로 변환할 수 있는 기능입니다. 여러 환경에서 작업하는 것은 Dataform의 설정 방법에 어려움을 가져올 수 있습니다. 여러 환경에서 데이터 형성이 더 좋을까요? 단일 환경에서만 형성해야 할까요? Google은 Dataform 최상의 실천법 섹션에서 이러한 Trade-offs에 대해 논의했습니다. 이 게시물은 단일 리포지토리로 스테이징 및 프로덕션 환경에 Dataform을 설정하는 방법을 보여줍니다.\n\n환경들은 각각 사용자 지정 서비스 계정이 있는 GCP 프로젝트로 설정됩니다. Dataform은 스테이징 환경/프로젝트에만 생성되며 많은 변경 사항을 가지고 있기 때문에 스테이징(또는 비 프로덕션) 환경에서 실험하는 것이 좋습니다. 또한, 개발 코드가 나타나는 환경으로 스테이징 환경이 선택됩니다. 이는 개발 워크스페이스에서 생성된 데이터셋과 테이블이 스테이징 환경 안에서 나타나게 됨을 의미합니다.\n\n개발이 완료되면 코드가 커밋되고 원격 리포지토리에 푸시됩니다. 그 후, 리뷰를 거친 후 PR을 올릴 수 있으며 메인 리포지토리에 병합됩니다. 예약된 워크플로에서 릴리스 및 워크플로 구성이 실행됩니다. Dataform은 메인 브랜치에서 코드를 컴파일하고 프로덕션 환경 내에서 실행되도록 구성되어 있습니다. 따라서, 리뷰를 거친 코드만이 프로덕션으로 이동하고 개발 코드는 스테이징 환경에 남아 있습니다.\n\n요약하면, 위 Dataform 아키텍처 플로우에서 개발 워크스페이스에서 개발된 코드는 스테이징 환경에 나타내거나 원격 GitHub으로 푸시되어 피어 리뷰를 거치고 메인 브랜치에 병합됩니다. 릴리스 구성은 주요 브랜치에서 코드를 컴파일하고 워크플로 구성은 컴파일된 코드를 가져와 프로덕션 환경에 데이터를 나타냅니다. 따라서, GitHub 메인 브랜치에 있는 리뷰된 코드만이 프로덕션 환경에 나타납니다.\n\n\n\n# 인증\n\n데이터폼의 인증은 특히 여러 환경을 설정할 때 복잡하고 까다로울 수 있습니다. 스테이징 및 프로덕션 환경의 예제를 사용하여 이를 어떻게 수행하는지 설명하겠습니다. 어디에 인증이 필요하고 그 방법에 대해 알아봅시다.\n\n![그림](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_2.png)\n\n위의 도표는 인증이 필요한 위치와 리소스에 대해 추적할 수 있는 간단한 데이터폼 워크플로우를 보여줍니다. 이 흐름은 개발 워크스페이스에서 데이터폼이 실행되고 일정에 따라 실행될 때(릴리스 및 워크플로 구성) 무엇이 발생하는지를 기록합니다.\n\n\n\n기계 사용자\n\n기계 사용자에 대해 이야기해봅시다. Dataform은 원격 저장소에 저장된 코드를 확인할 때 GitHub에 액세스하기 위한 자격 증명이 필요합니다. 개별 자격 증명을 사용할 수 있지만, 최선의 방법은 조직 내에서 기계 사용자를 사용하는 것입니다. 이러한 방법을 통해 Dataform 파이프라인 조종은 개별 신원과 독립적이며 그들의 이탈에 영향받지 않습니다. 기계 사용자를 설정하는 것은 여기에 자세히 설명된대로 개인에 속하지 않은 신원을 사용하여 GitHub 계정을 설정하는 것을 의미합니다. Dataform의 경우, 기계 사용자 계정을 위해 개인 액세스 토큰(PAT)이 생성되고 GCP 시크릿 매니저에 비밀로 저장됩니다. 또한 기계 사용자는 Dataform 원격 저장소에 읽기 및 쓰기 액세스 권한을 가진 외부 공동 작업자로 추가되어야 합니다. 나중에 테라폼 코드에서 Dataform이 비밀에 액세스할 수 있도록 구성되는 방법을 살펴볼 것입니다. 사용자가 기계 사용자 대신 자신의 신원을 사용하기로 결정할 경우, 여기에 자세히 설명된대로 토큰을 생성해야 합니다.\n\nGitHub 인증 흐름\n\n![GitHub 인증 흐름](/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_3.png)\n\n\n\n데이터폼은 구현을 위해 기본 서비스 계정을 사용합니다. 따라서 데이터폼 작업을 수행할 때 기본 서비스 계정부터 시작됩니다. 기계 사용자를 설정했다고 가정하고, 해당 사용자를 원격 저장소의 공동 작업자로 추가하고 해당 사용자 PAT를 GCP 시크릿 매니저에 비밀로 추가해야 합니다. GitHub에 인증하기 위해 기본 서비스 계정은 시크릿 매니저로부터 비밀을 추출해야 합니다. 기본 서비스 계정은 비밀을 액세스하기 위해 secretAccessor 역할이 필요합니다. 비밀에 액세스한 후, 기본 서비스 계정은 이제 기계 사용자를 표현할 수 있으며, 기계 사용자가 원격 Git 리포지토리의 공동 작업자로 추가되었기 때문에 기본 서비스 계정은 이제 해당 원격 GitHub 리포지토리에 공동 작업자로서 액세스할 수 있습니다. 이 흐름은 GitHub 인증 워크플로우 그림에 표시되어 있습니다.\n\n개발 워크스페이스 인증\n\n개발 워크스페이스에서 실행이 트리거되면, 기본 서비스 계정은 스테이징 환경 사용자 지정 서비스 계정으로 교체하여 스테이징 환경 내부에서 결과를 표시합니다. 스테이징 환경 사용자 지정 서비스 계정을 나타내기 위해 기본 서비스 계정이 필요한 것은 스테이징 서비스 계정에 대한 iam.serviceAccountTokenCreator 역할입니다. 이를 통해 기본 서비스 계정이 스테이징 사용자 지정 서비스 계정을 나타내기 위해 사용되는 기계 사용자를 표현하는 데 사용되는 PAT과 유사한 짧은 수명의 토큰을 생성할 수 있게 되며, 이를 통해 나타낼 수 있습니다. 따라서 스테이징 사용자 지정 서비스 계정은 BigQuery 테이블에 쓰기 권한이 모두 부여되고, 기본 서비스 계정은 스테이징 사용자 지정 서비스 계정을 나타낼 때 이러한 권한을 상속받을 수 있습니다.\n\n워크플로 구성 인증\n\n\n\n리포지토리를 확인한 후 릴리스 구성은 컴파일된 config .json 파일을 생성합니다. 이 파일에서 workflow 구성은 데이터를 생성합니다. 프로덕션 BQ 테이블에 데이터를 쓰기 위해 기본 서비스 계정은 프로덕션 사용자 정의 서비스 계정에 대해 iam.serviceAccountTokenCreator 역할이 필요합니다. 스테이징 사용자 정의 서비스 계정을 위해 수행한 것과 유사하게, 프로덕션 서비스 계정은 프로덕션 환경 BQ 테이블에 쓰기 위해 필요한 모든 권한을 부여받고, 기본 서비스 계정은 이 서비스 계정을 표시할 때 모든 권한을 상속합니다.\n\n요약\n\n요약하자면, 기본 서비스 계정이 주요 인물입니다. 기계 사용자를 표시할 때 기계 사용자 PAT를 사용하여 GitHub에 공동 작업자로 인증합니다. 또한 serviceAccountTokenCreator 역할로 생성된 단기 토큰을 사용하여 각각의 사용자 정의 서비스 계정을 표시하여 스테이징 및 프로덕션 환경에 인증합니다. 이해한 내용을 바탕으로 GCP 내에서 Terraform을 사용하여 Dataform을 프로비저닝할 시간입니다. 이에 대한 자세한 내용은 블로그의 Part 2를 기대하거나 코드를 확인하세요.\n\n이미지 출처: 본 게시물의 모든 이미지는 저자가 제작했습니다.\n\n\n\n## 참고 자료\n\n- [Dataform 소개 페이지](https://cloud.google.com/dataform?hl=ko)\n- [Dataform 이전 가이드 문서](https://cloud.google.com/dataform/docs/migration)\n- [Dataform 모범 사례 문서](https://cloud.google.com/dataform/docs/best-practices)","ogImage":{"url":"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png"},"coverImage":"/assets/img/2024-05-15-UnderstandingDataformTerminologiesAndAuthenticationFlow_0.png","tag":["Tech"],"readingTime":7},{"title":"쿠버네티스 배포와 ArgoCD NGINX를 사용한 실전 예제","description":"","date":"2024-05-15 15:51","slug":"2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png\" /\u003e\n\n쿠버네티스 배포는 복잡할 수 있지만, ArgoCD와 같은 도구를 사용하면 프로세스가 훨씬 순조롭게 진행됩니다. 이 안내서에서는 ArgoCD를 사용하여 쿠버네티스에 NGINX 웹 서버를 배포하는 방법을 실용적인 코딩 예제와 함께 안내해 드리겠습니다.\n\n- ArgoCD 설정하기:\n제공된 YAML 매니페스트를 사용하여 쿠버네티스 클러스터에 ArgoCD를 설치합니다. 이는 ArgoCD가 애플리케이션을 원활하게 관리할 수 있도록 설정해 줍니다.\n\n```js\n# ArgoCD 설치 YAML\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: nginx-app\n  namespace: argocd\nspec:\n  destination:\n    namespace: default\n    server: 'https://kubernetes.default.svc'\n  project: default\n  source:\n    path: nginx\n    repoURL: 'https://github.com/yourusername/your-repo.git'\n    targetRevision: HEAD\n  syncPolicy:\n    automated: {}\n```\n\n\n\n2. 애플리케이션 구성 정의하기:\nNGINX 배포 구성을 정의하는 nginx.yaml 파일을 생성하세요.\n\n```yaml\n# NGINX 배포 구성 (nginx.yaml)\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n```\n\n3. GitOps 워크플로우 따르기:\nnginx.yaml 파일을 Git 저장소에 커밋하여 ArgoCD의 동기화 프로세스를 실행하세요.\n\n```bash\n# Git에 변경 사항 커밋하고 푸시하기\ngit add nginx.yaml\ngit commit -m \"NGINX 배포 구성 추가\"\ngit push origin main\n```\n\n\n\n4. 모두를 동기화 유지하기:\nArgoCD는 Git 저장소의 변경 사항을 자동으로 감지하고 원하는 상태를 Kubernetes 클러스터와 동기화합니다.\n\n```js\n# 응용 프로그램 동기화 상태 확인\n argocd app get nginx-app\n```\n\n5. 배포 문제 처리:\n문제가 발생하면 ArgoCD를 사용하여 서비스 연속성을 유지하기 위해 원할한 롤백 또는 롤포워드 작업을 수행할 수 있습니다.\n\n```js\n# 이전 상태로 롤백\n argocd app rollback nginx-app\n```\n\n\n\n\n# 새로운 버전으로 롤포워드\n argocd app rollforward nginx-app\n\n\n6. 워크플로우 사용자화하기:\nArgoCD를 사용하여 CI/CD 파이프라인, 모니터링 시스템 또는 알림 서비스와 통합하여 필요에 맞게 맞춤 설정하세요.\n\nArgoCD는 Kubernetes 배포를 간소화하는 데 사용되며, 기본 통합, 간단한 구성, GitOps 워크플로우, 자동 동기화, 롤백/롤포워드 기능 및 확장성을 제공합니다. ArgoCD를 채택함으로써 팀은 배포 프로세스를 최적화하고 생산성을 높이며, Kubernetes 클러스터에서 실행되는 응용 프로그램의 신뢰성과 확장 가능성을 보장할 수 있습니다. ArgoCD로 뛰어나게 Kubernetes 여정을 시작해보세요!\n\n관련 기사: Kubernetes 환경에서 ArgoCD가 필수적인 이유\n\n\n\n\n행복한 코딩하세요 🙂","ogImage":{"url":"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png"},"coverImage":"/assets/img/2024-05-15-KubernetesDeploymentswithArgoCDAHands-OnExampleUsingNGINX_0.png","tag":["Tech"],"readingTime":3},{"title":"개발 컨테이너 - 왜 필요하고 어떻게 개발 환경을 변화시키는지","description":"","date":"2024-05-15 15:49","slug":"2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment","content":"\n\n소프트웨어 개발 세계에서 일관성 있는 신뢰할 수 있는 개발 환경은 생산성과 효율성에 중요합니다. 전통적인 로컬 개발 환경은 모든 것을 수동으로 설치하는 것으로, 호환성 문제, 의존성 및 버전 충돌 문제, 그리고 광범위한 설정과 구성이 필요한 문제에 직면할 수 있습니다. 여기서 도커 개발 컨테이너가 나오면 개발 경험을 혁신할 수 있습니다.\n\n🇧🇷 Portuguese version here!\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png)\n\n## 도커 개발 컨테이너란 무엇인가요?\n\n\n\n특정 프로젝트를 만들기 위한 모든 도구가 들어 있는 상자를 상상해 보세요. 목공에 필요한 공구 상자처럼 망치, 톱 등이 들어 있습니다. Docker 개발 컨테이너는 이와 같은 상자와 비슷하지만 소프트웨어 개발을 위한 것입니다. 가상 환경에 사전 설치된 필수 소프트웨어가 모두 포함되어 사용할 준비가 된 상태입니다.\n\nDocker 개발 컨테이너는 Docker 기술을 활용하여 완전한 개발 환경을 포장한 가벼운, 격리된 환경입니다 (당신의 공구 상자!). 이러한 컨테이너는 특정 프로젝트를 개발하는 데 필요한 모든 도구, 라이브러리 및 런타임 구성을 캡슐화합니다. 개발자가 개발 컨테이너를 실행하면 로컬에서 작업한 코드 변경 사항이 클라우드로 배포될 때나 여러 사람이 함께 작업할 때와 동일하게 잘 작동함을 보장합니다.\n\n# 일관되고 재사용 가능한 환경\n\n개발 컨테이너를 사용하면 팀 내 모든 사람이 자신이 사용하는 컴퓨터에 상관없이 동일한 설정을 사용할 수 있습니다. 모두가 약간 다른 오븐과 재료로 케이크를 구워야 하는 대신, 개발 컨테이너는 모두가 정확히 같은 오븐과 같은 레시피를 사용하도록 보장합니다. 이는 한 명이 작업한 프로젝트가 다른 사람에게도 동일하게 작동하며, 새 팀원이 합류할 때 자신의 환경을 처음부터 설정하지 않고도 즉시 코딩을 시작할 수 있음을 의미합니다.\n\n\n\n# Visual Studio Code에서 개발 컨테이너 확장 기능 사용하기\n\nVisual Studio Code의 Dev Containers 확장 기능을 사용하면 개발 컨테이너를 쉽게 다룰 수 있어요. 이렇게 사용하는 방법에 대해 간단히 설명해 드릴게요:\n\n- 복잡한 설정을 건드릴 필요 없이 VS Code 내에서 새로운 개발 컨테이너를 설정할 수 있어요. 미리 만들어진 템플릿 중 하나를 사용하거나 직접 정의해서 시작할 수 있어요.\n- 이 확장 기능을 사용하면 다른 개발 환경간에 매끄럽게 전환할 수 있어요. 여러 대의 컴퓨터 환경을 여러 개 설정하지 않아도 되고, 일반적으로 발생하는 복잡함이 없어요.\n- 코드 작업은 로컬 데스크탑에서 작업하는 것과 같아요. 실제 코드가 컨테이너 안에서 실행되더라도, VS Code 내에서 프로젝트를 수정, 실행, 디버그할 수 있어요. 이미 익숙한 인터페이스를 통해 작업할 수 있어요.\n\n\n\n`devcontainer.json` 파일은 실제로 개발 컨테이너의 청사진입니다. 개발 환경에 필요한 모든 것을 지정합니다. \n\n- 사용할 기본 이미지: 이는 개발 환경의 \"OS\"를 선택하는 것과 같습니다. 간단한 Ubuntu 환경이나 좀 더 사용자 정의된 것이 될 수 있습니다.\n- 필요한 소프트웨어: 컨테이너에 미리 설치되어야 하는 모든 도구와 프로그램을 나열합니다. 이는 이러한 설정을 수동으로 설정하는 시간을 낭비하지 않아도 된다는 것을 의미합니다.\n- 설정과 확장: 파일은 또한 VS Code의 구성 설정을 포함하거나 자동으로 설치되어야 하는 확장을 나열할 수도 있습니다.\n\n이 구성 파일을 사용하면 누구나 이 개발 컨테이너를 사용할 때 개인 컴퓨터에 관계없이 정확히 동일한 설정을 가질 수 있으며, \"내 컴퓨터에서는 잘 되는데\" 문제를 피하는 데 도움이 됩니다.\n\n제 CDK에 관한 글에서 devcontainer.json을 살펴보겠습니다:\n\n\n\n```json\n{\n    \"name\": \"aws-dev-container\",\n    \"image\": \"mcr.microsoft.com/devcontainers/typescript-node:1-18-bookworm\",\n    \"features\": {\n        \"ghcr.io/devcontainers/features/aws-cli:1\": {},\n        \"ghcr.io/devcontainers-contrib/features/aws-cdk:2\": {}\n    },\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"dbaeumer.vscode-eslint\",\n                \"eamodio.gitlens\",\n                \"firsttris.vscode-jest-runner\",\n                \"ryanluker.vscode-coverage-gutters\",\n                \"humao.rest-client\"\n            ]\n        }\n    },\n    \"remoteUser\": \"root\"\n}\n```\n\n- name: 이 키는 여러 개의 컨테이너 중에서 쉽게 식별할 수 있게 도와주는 개발 컨테이너의 친근한 이름을 할당합니다.\n- image: 개발 컨테이너의 기본으로 사용할 Docker 이미지를 지정합니다. 이것은 운영 체제와 미리 설치된 언어나 프레임워크를 결정합니다. 위 예에서는 이미 NodeJS와 Typescript가 설치된 이미지를 사용했습니다.\n- features: 이것이 개발 컨테이너의 가장 좋은 ... 기능 중 하나입니다. \"기능\"은 컨테이너에 자동으로 설치되는 추가적인 도구나 유틸리티입니다. 이것들은 일반적으로 특정 기능을 가진 컨테이너의 기본 기능을 확장하기 위해 사용됩니다. 이 예에서는 AWS CLI와 CDK를 추가했습니다. 컨테이너에 추가할 수 있는 전체 기능 목록을 여기에서 찾을 수 있습니다.\n- customizations: VS Code를 위해 개발 환경을 사용자 정의할 수 있게 합니다.\n- extensions: 컨테이너에 자동으로 설치할 VS Code 확장 목록을 나열합니다. 수동으로 설정하지 않고 개발 경험을 향상시키는 데 사용됩니다.\n- remoteUser: 컨테이너 내에서 VS Code 서버가 실행될 기본 사용자를 지정합니다. 이는 컨테이너 내 파일과 프로세스에 대한 권한 및 액세스에 영향을 미칩니다. 예를 들어 root는 일반적으로 컨테이너 내의 모든 것을 수정할 수 있는 루트 사용자로 작동한다는 것을 의미합니다.\n\n# 개발 컨테이너 사용\n\n개발 컨테이너를 사용하려면 먼저 Dev Containers 확장을 설치해야 합니다.\n\n\n\n\n디브 컨테이너 구성 파일(devcontainer.json)은 프로젝트의 루트인 .devcontainer 폴더에 위치합니다.\n\n이 구성으로 처음으로 프로젝트를 열 때 VS Code가 제안을 안내해줍니다.\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_1.png)\n\nVS Code는 컨테이너 구성을 감지하고 프로젝트를 컨테이너 내에서 열지 원하는 지 물어봅니다. \"컨테이너에서 다시 열기\"를 선택하면 Docker 이미지와 컨테이너가 생성됩니다. 화면이 다시 로드되고 VS Code가 컨테이너에 연결됩니다.\n\n\n\n\"Command Palette\"를 통해 컨테이너를 빌드/재빌드할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_2.png)\n\n컨테이너가 생성되면, devcontainer.json 구성에 설명된 대로 환경을 갖게 됩니다.\n\n# devcontainer.json을 사용한 기본 구성\n\n\n\ndevcontainer.json 파일은 dev container 구성의 핵심입니다. 위에서 보신 것처럼 다양한 설정 및 기능을 직접 지정할 수 있어 개발 환경을 쉽게 설정하고 \"features\"로 매우 사용자 정의할 수 있습니다.\n\n# Dockerfile로 고급 설정하기\n\n더 많은 사용자 정의 및 모듈식 설정이 필요한 경우 Dockerfile을 가리키는 방식으로 devcontainer.json 구성을 확장할 수 있습니다. 이 방법을 통해 환경에 대한 보다 큰 유연성과 제어가 가능해집니다.\n\n```json\n{\n    \"name\": \"aws-dev-container\",\n    \"build\": {\n        \"dockerfile\": \"Dockerfile\"\n    },\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"dbaeumer.vscode-eslint\",\n                \"eamodio.gitlens\",\n                \"firsttris.vscode-jest-runner\",\n                \"ryanluker.vscode-coverage-gutters\",\n                \"humao.rest-client\"\n            ]\n        }\n    },\n    \"remoteUser\": \"root\"\n}\n```\n\n\n\n질문이나 제안이 있으면 댓글을 남겨주세요. 함께 배우는 모두에게 도움이 될 거에요! 🤠","ogImage":{"url":"/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png"},"coverImage":"/assets/img/2024-05-15-DevContainersWhyandHowTheyTransformYourDevelopmentEnvironment_0.png","tag":["Tech"],"readingTime":5},{"title":"RAG 모델 구축하기  Databrick으로 쉽게 만들기","description":"","date":"2024-05-15 15:48","slug":"2024-05-15-RAGyourmodelSimplifiedwithDatabrick","content":"\n\n# RAG 이론 (간단 버전)\n\n언어 모델이 지식을 배우는 몇 가지 방법이 있습니다. 전통적으로는 모델을 처음부터 훈련하거나 기존 모델을 세밀 조정하는 방법이 있습니다. 이는 모델 가중치를 업데이트하여 모델을 더 훈련시키는 것을 의미합니다. 다른 방법은 상대적으로 새롭고 직접적으로 프롬프트 공학과 연관이 있습니다. 여기서는 지식을 모델 입력값으로 전달합니다. 모델은 이를 문맥으로 편입하여 지식을 통합합니다. 왜 모델에 처음부터 문맥을 전달하는 걸까요? 모델에게 문맥을 전달하는 것은 모델에게 오픈 노트로 시험을 보는 것과 같습니다. 모델은 참고할 사실을 손에 넣게 됩니다. 다만 전달할 수 있는 문맥의 크기에는 제한이 있습니다. 보통 5 페이지이며, 이는 대부분의 산업용 사례에 부족할 정도입니다. 그래서 모델 문맥 문제용 새로운 모델 구조 - 'RAG'가 등장했습니다!\n\n# RAG 아키텍처—\n\nContext 데이터/지식을 임베드된 벡터로 변환하고 이를 저장하는 모델(임베딩 모델)을 추가(Vector 스토어). 쿼리(프롬프트)가 전달되면 프롬프트를 캡처하여 임베드된 벡터로 변환하고, 저장소에서 유사한 벡터를 찾아 메인 모델에게 컨텍스트 강화된 프롬프트(쿼리 벡터 + 저장소로부터의 유사 벡터)를 전달합니다. 이것이 여러분이 제공한 문맥을 통합하여 정확한 응답을 생성하는 RAG입니다.\n\n\n\n아래는 Markdown 형식으로 변경된 표입니다.\n\n\n![이미지](/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png)\n\n# RAG의 세부 내용:\n\nRAG는 다음과 같은 네 가지 주요 구성 요소로 구성됩니다:-\n\n1. 벡터 검색 - 주의할 점은 우리가 아무런 검색을 하기 전에 문맥/지식을 임베딩 벡터로 변환한다는 것입니다. 모든 데이터 객체인 오디오, 비디오 또는 텍스트는 임베드 벡터로 변환되어 벡터 저장소에 저장될 수 있습니다.\n  \n\n\n\n두 가지 종류의 검색이 있습니다. 정확한 검색과 근사 검색. 이름에서 알 수 있듯이 정확한 검색은 가장 가까운 방법을 찾는 무차별 대입 방법입니다. 전통적인 KNN과 유사합니다. 반면에 근사 검색은 가장 가까운 이웃을 찾는 데 정확도가 낮지만 속도가 빠릅니다. 가장 인기 있는 벡터 검색 알고리즘은 ANN을 사용합니다.\n\n공통의 인덱싱 알고리즘은 몇 가지 있습니다 — Spotify의 ANNOY(트리 기반), Facebook의 FAISS(클러스터링), LSH(해싱), 그리고 Google의 SCaNN(벡터 압축). 이러한 알고리즘들은 모두 효율적인 검색을 수행하기 위한 모든 필요한 정보를 보유한 vector Index라는 데이터 구조를 반환합니다.\n\n2. Vector Store: 벡터를 저장하는 데 사용하는 두 가지 전략이 있습니다. 하나는 가벼운 벡터 라이브러리를 사용하는 것이고, 다른 하나는 고급 기능을 제공하는 벡터 데이터베이스를 사용하는 것입니다.\n\n- 벡터 라이브러리: 벡터 인덱스를 생성하고 이 인덱스는 메모리에 저장됩니다. 라이브러리는 일반적으로 작고 정적인 데이터에 대해 충분합니다. 저장된 벡터에 대한 CRUD 작업을 지원하지 않습니다. 즉, 데이터가 변경될 때마다 인덱스를 다시 만들어야 합니다. 데이터 복제가 없습니다.\n\n\n\nb. 벡터 데이터베이스 — 다른 한편으로는 구조화되지 않은 데이터를 저장하는 데 특화된 데이터베이스입니다. 데이터베이스의 CRUD 속성을 상속하며 오프라인에서 색인을 사전 처리하고 나서 벡터를 데이터베이스에 저장하여 모델에 온라인으로 제공할 수 있도록 합니다.\n\n3. 필터링 — 필터링은 생성 프로세스에 통합하기 전에 검색된 지식 베이스에서 관련 정보를 선택하고 우선순위를 정하는 메커니즘을 참조합니다. 이를 통해 검색된 컨텍스트가 정보를 제공할 뿐만 아니라 일관성 있고 맥락에 부합하는 응답을 생성하는 데 도움이 됩니다.\n\n세 가지 전략 — Pre-Query, In-Query, Post-Query 필터링.\n\n4. 프롬프트 엔지니어링 — LLM에 응답 생성이나 작업 완료를 요청하는 텍스트입니다. 원하는 출력을 생성하도록 모델을 안내하는 명확하고 구체적이며 잘 구조화된 입력을 작성하는 것을 포함합니다. 모델이 사실을 찾지 못했을 때 억지로 내용을 만들지 않도록 안내하는 지침을 제공하는 것, 예시와 데모 사용, 그리고 더 중요한 것은 작업을 더 잘 이해할 수 있도록 맥락을 제공하는 것을 모두 포함합니다. 위에서 설명한 RAG 워크플로우에 주목하세요. 마지막으로, 우리는 맥락 문서를 프롬프트를 통해 모델에 전달하고 있기 때문에 RAG가 프롬프트 엔지니어링과 밀접하게 연관되어 있다고 할 수 있습니다.\n\n\n\n# RAG Nvidia/Llama3 model with Databricks\n\n## Assets -\n\nModel - nvidia/Llama3-ChatQA-1.5-8B ([링크](https://huggingface.co/nvidia/Llama3-ChatQA-1.5-8B))\n\nVector Database - ChromaDb\n\n\n\nDatabricks ML 런타임 -13.3.x-cpu-ml-scala2.12 / 13.3.x-gpu-ml-scala2.12\n\n이 두 Databricks 런타임은 호환됩니다. 그러나이 모델은 8B 매개변수를 가지고 있어 노트북에서 추론을 위해 로드하기에 너무 큽니다. 충분한 메모리와 코어가 있는 CPU 머신에서 응답을 생성하는 데 오랜 시간이 걸렸습니다. 당신의 요구에 적합하고 예산에 맞는 런타임을 선택하세요.\n\n## 데모 -\n\n감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png"},"coverImage":"/assets/img/2024-05-15-RAGyourmodelSimplifiedwithDatabrick_0.png","tag":["Tech"],"readingTime":3},{"title":"폭풍 속을 네비게이팅하며 소프트웨어 엔지니어로서 가장 어려웠던 순간","description":"","date":"2024-05-15 15:46","slug":"2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer","content":"\n\n## 소프트웨어 엔지니어링, 성장\n\n![Image](/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png)\n\n작년, 소프트웨어 아키텍처에 관한 에버하르트 볼프의 팟캐스트에서 특별한 기회를 가졌습니다.\n\n최근에 에버하르트가 다시 초대해 \"일로서의 소프트웨어 아키텍처\"에 대해 깊이 탐구하는 시간을 가졌는데, 12가지 생각할 거리 질문에 대답을 해야했습니다. 그중 한 질문이 돋보여 제가 잠시 망설이게 했습니다:\n\n\n\n이제, 내가 경력 동안 많은 힘든 시간과 좋지 않은 순간들을 겪었다는 것을 알려줄게. 그것은 우리 모두가 경험하는 일이야. 하지만 젊은 전문가들이 다음과 같은 친절한 말로 나에게 다가오면:\n\n- \"당신으로부터 배우고 싶어요,\"\n- \"멘토가 되어주세요?\"\n- 또는 \"당신은 소프트웨어 산업에서 귀중한 자산이에요,\"\n\n내가 종종 마음속으로 생각한다. \"그들이 내가 겪은 모든 좌절과 실패에 대해 알고 있다면 참 좋겠다.\" 그들은 내가 몇 번이나 직장을 해고당했는지 알아주겠는가? 아마 그렇지 않을 거야.\n\n내 불행했던 전문가 경험 중에서, 에버하르트의 질문에 대답하기 위해 가장 나쁜 순간을 선택해야 했어. 처음에는 간단한 대답이 될 거라고 생각했던 것이 기사로 공유할 만한 내러티브가 되었거든.\n\n\n\n그래서, 자리를 잡고 함께해요.\n\n# 초기 어려움\n\n많은 사람과 마찬가지로, 제 직업 시작은 가파른 학습 곡선과 사기 신드롬의 변화로 가득했습니다. 평범할 수 있지만, 이러한 어려움은 각 개인마다 고유하며 자신의 자신감, 단호함, 취약성 및 커뮤니케이션 기술 수준에 의해 형성됩니다.\n\n독일로 이사를 가서 새로운 언어로 일하다보니 고유한 어려움이 있었습니다. 내 능숙도 부족으로 소통 문제가 생기고, 그 당시에는 소프트 스킬이 미숙해서 더 어려웠죠.\n\n\n\n하지만, 가장 힘든 전문적 순간은 아직 오지 않았어요.\n\n# 가장 어려웠던 순간\n\n수천 명의 사용자와 약 5,000 QPS(초당 쿼리 수)를 처리하는 시스템에서 AWS DevOps 개발자로 첫 직장을 시작했을 때가 제 경력 중 가장 어려운 시기로 기억됩니다. 그 당시에는 AWS에 대한 경험이 실제보다 이론적인 면이 더 많았고, 파이썬에 대한 배경 지식이 없었습니다.\n\n갑자기 나는 Java와 Python으로 구현된 약 60개의 마이크로서비스가 있는 복잡한 시스템에 던져졌고, Axon Server를 사용한 CQRS와 이벤트 주도 아키텍처를 사용하고 있었습니다.\n\n\n\nIaC, Terraform, Fargate, EKS, CloudWatch 및 실시간 지표를 표시하는 대규모 Grafana 대시보드와 같은 용어들에 둘러싸인 새내기 같은 느낌을 받았습니다. 정말 압도되었죠.\n\n그중에서도 가장 어려웠던 점은 무엇일까요?\n\n저는 주니어 개발자가 아니었습니다. 소프트웨어 엔지니어로 10년 이상 경험을 쌓은 저는 기술적 역량에 확신을 갖게 되었고, 종종 동료들에게 조언하고 지도해왔습니다.\n\n제 기술을 자신하며 적극적이고 쉽게 이 복잡한 시스템을 탐험할 수 있기를 기대했지만, 새로운 기술을 습득하는 시간은 주니어 개발자에 비해 제한적이었습니다.\n\n\n\n우리 팀은 이미 시스템에 익숙했지만, 나의 직면한 복잡성을 보지 못했습니다. 그 결과로 저의 노고와 성과에 대한 압박이 더욱 심해졌죠.\n\n# 새로운 도구에 압도되다\n\n일반적으로 소스 코드를 검토하고 분석하는 초기 날들을 보내야 할 터였지만, 나는 자주 구글에 다음과 같은 질문을 하게 되었습니다:\n\n- Tasklib은 무엇인가요?\n- Terraform은 무엇인가요?\n- 인프라스트럭처와 코드란 무엇인가요?\n- Axon Server는 무엇이며, 왜 관계형 데이터베이스를 대체할 수 있을까요?\n- LocalStack은 무엇인가요?\n- Grafana와 CloudWatch가 어떻게 함께 작동할까요?\n- 일부 람다 함수가 Python으로 작성된 이유와 다른 함수들이 Java로 작성된 이유는 무엇일까요?\n- 람다와 파게이트(Fargate)의 차이점은 무엇이며, 언제 파게이트를 선택하는 것이 더 좋나요?\n- Flask는 무엇인가요? 파이썬 앱을 람다에서 Flask로 변경하는 방법은 무엇인가요?\n- AWS에서 Flask를 위한 서비스가 있나요?\n\n\n\n이 프로젝트 특정 구현에 대한 질문이어야 했던 이 질문들은 도구와 개념 자체에 대한 기본 문의였어요.\n\n# 산업 전문가들의 인사이트\n\nKlotho의 공동 창업자이자 이전 Microsoft 및 Riot 엔지니어인 Ala Shiban과의 대화를 기억했습니다. 그는 현대 클라우드 및 인프라 기술이 FAANG 수준의 기술 전문가를 필요로 한다고 언급했는데, 이는 항상 기능 개발 속도를 높이지는 않는다고 했습니다.\n\n제가 생산적으로 얼마나 오랜 시간이 걸릴지 궁금해서 AWS 인증을 받은 친구에게 연락했어요.\n\n\n\n\"AWS 자격증 시험을 준비하는 데 얼마나 시간이 걸릴까요? 1주일이면 충분한가요?\" 제가 물었습니다.\n\n\"1주일?!\" 그는 놀라며 대답했습니다.\n\n\"아니면 2~3일만에 가능할까요,\" 제가 농담을 했습니다.\n\n그는 웃으며 \"적어도 한 달은 걸릴 것 같아요\" 라고 말했습니다.\n\n\n\n# 도전에 맞서보기\n\n나의 여정을 되돌아보며, 내 처음의 자신감이 내 역량과 시장 상황에 대한 잘못된 가정에 바탕을 두고 있음을 깨달았다. 기술적 변화의 빠른 속도에 맞추기 위해 필요한 복잡성과 고통을 과소평가했다.\n\n하지만 가치 있는 교훈도 얻었다. 내가 깨우친 것은 심층적인 도메인 지식의 중요성과 지속적인 학습의 필요성이었다. 나는 애플리케이션에 대한 고민을 인프라에 대한 것으로부터 분리하여 개발 프로세스를 간소화하는 Klotho와 같은 도구를 탐색하기 시작했다.\n\n# 앞으로 나아가기\n\n\n\n요약하자면, 제가 경험한 최악의 전문적인 순간은 도전으로 가득 찼지만, 결국 그것이 저의 개인적이고 전문적인 성장의 길을 열어 주었습니다.\n\n경력에서 어려운 시기를 겪고 있다면, 이러한 경험들이 더 큰 성공으로 나아가는 발판이 될 수 있다는 것을 기억해 주세요. 도전을 받아들이고 그것으로부터 배우며, 계속 전진해 나가세요.\n\n괴물에 대항하는 법을 배우기 위해 기다리지 말고 이미 앞서서 준비를 하세요. 적극적으로 행동하고 호기심을 가지며 계속해서 발전해 나가세요.\n\n이 이야기가 여러분에게 자신의 도전에 참을성 있게 이겨 나가도록 영감을 주고, 그 동안 배운 교훈의 가치를 인지할 수 있기를 바랍니다.\n\n\n\n# 더 알고 싶으세요?\n\n🧠💡 저는 공학, 기술, 리더십에 대해 똑똑하고 호기심 많은 사람들을 위한 커뮤니티에 글을 씁니다. 제 이메일 뉴스레터에 가입하시면 제 비디오 강의에 무료로 액세스할 수 있는 기회를 드립니다 📚.","ogImage":{"url":"/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png"},"coverImage":"/assets/img/2024-05-15-NavigatingtheStormMyToughestMomentasaSoftwareEngineer_0.png","tag":["Tech"],"readingTime":4},{"title":"Dev Log  Unity GAS를 사용하여 더 많은 능력 구성하기","description":"","date":"2024-05-15 15:44","slug":"2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS","content":"\n\n# 개요\n\n이전의 개발일지에서 Unreal Gameplay Ability System의 매우 기본적인 개념적 개요, 사용 중이며 확장 중인 Unity GAS 구현의 구체적인 내용, 그리고 프레임워크 내에서 구성된 몇 가지 기본 능력 예제를 제공했습니다. 이 기사에서는 몇 가지 더 간단한 능력들을 논의하고 GAS 내에서 어떻게 구현했는지에 대해 알아보겠습니다.\n\n# 요약\n\n이전에 논의된 대로, 내가 작업 중인 첫 번째 플레이어 클래스는 스택 메커니즘을 기반으로 하고 있습니다. 플레이어가 적에게 특정 방식으로 영향을 미치면(기본 공격 데미지 또는 특정 능력 효과), 적에게 5초 동안 스택이 추가됩니다. 동일한 적에 4개의 스택이 누적되면 추가 데미지가 입히고 스택이 지워지며 몇 초 동안 Mark 상태 효과로 대체됩니다. 이 논리를 보여주는 GIF는 다음과 같습니다:\n\n\n\n이 스태킹 메커니즘은 이 배 클래스의 기초가 되도록 의도되어 있어, 이 클래스의 대부분의 능력 효과는 적들에게 스택이 쌓인 상태에 의존하게 될 거에요. 예를 들어, 저번 데브로그에서 다룬 첫 번째 능동 능력은 스택이 적용된 적들 주변을 데미지를 입히고 기절시킵니다. 데미지와 기절 지속 시간은 주어진 적의 스택 수에 따라 증가합니다. 아래는 이 능력의 모습을 시각적으로 보여드린 그림입니다:\n\n# 플레이어 능력 세트 완성하기\n\n이 배의 처음 몇 가지 능력은 좋은 시작이지만, 분명 플레이어는 더 많은 옵션이 필요할 거에요. 저는 현재 GAS 구현에서의 작업 흐름을 개발하기 위해 몇 가지 추가 능력을 프로토타입으로 만들었어요. 일단, 플레이어는 잠정적으로 세 개의 능력 슬롯에 액세스할 수 있고, 이를 잠긴 능동 능력 집합에서 선택해 채울 수 있게 될 거에요. 앞서 언급한 능력을 포함하여 이러한 능력들이 있어요:\n\n## 스택 기반 힐링\n\n\n\n- 플레이어가 받는 데미지를 잠시 동안 줄이고 범위 내의 적의 패시브 스택을 소비하여 해당 스택이 소모된 만큼 플레이어를 치유함\n- 지속력을 위해 사용하거나 갑작스러운 대미지 발생을 완화하는 데 사용될 수 있음\n\n## 폭발성 발사체\n\n- 접촉 시 추가로 데미지를 입히는 대형 직진 발사체로, 접촉 시 폭발하며 범위 내에서 추가로 데미지를 입힘\n- 주로 대규모 피해를 입히려고 사용되며, 접촉과 폭발 데미지는 별개의 데미지 타입이므로 초기 발사체에 맞은 적은 사실상 추가 데미지와 함께 2개의 패시브 스택을 받음\n\n## 충격 탑\n\n\n\n- 매 초 틱을 하는 작은 물체를 소환하여 주변 적들을 간단히 중심으로 끌어안는다\n- AoE 콤보나 철회를 위한 집합/CC 능력으로 사용할 수 있다\n\n이전 로그를 읽어 보셨다면, 어떻게 이러한 능력들이 구현될 수 있는지 대략적인 개념을 이미 가지고 있을 것입니다. 현재의 GAS 워크플로우와 가까운 미래에 개선할 수 있는 통증점과 가능한 개선점을 이해하기 위해 조금 더 깊게 파고들어 보겠습니다.\n\n# 스택 기반 치유 구현\n\n가장 복잡한 것부터 시작해 보죠. 이 능력은 이전 기사에 구현된 스택 기반 스턴 능력과 유사하게 작동합니다. 그러나 능력이 활성화될 때 일부 추가 작업이 필요하다는 점에서 추가 복잡성이 조금 더 있습니다. 위의 설명을 다시 요약해보면, 이 능력은 \"일부 초 동안 플레이어가 받는 피해를 줄이고 범위 내의 적들로부터 패시브 스택을 소비하여, 소비된 스택에 기반하여 플레이어를 회복하는\" 기능을 합니다. 즉, 능력이 활성화될 때 다음을 해야 합니다:\n\n\n\n- 플레이어 주변 범위 내의 모든 적 캐릭터를 대상으로 총 스택 인스턴스 수를 결정합니다.\n- 잠정적으로 플레이어가 받는 피해를 줄입니다.\n- 주변 적 캐릭터의 총 스택 수에 기반하여 플레이어를 회복합니다.\n- 범위 내의 각 적 캐릭터에서 기존 스택(마크를 제외한)을 제거합니다. 능력은 영향을 받는 적 캐릭터로부터 스택을 소모하며, 스택을 소모하면 플레이어가 가할 수 있는 피해가 더 이상 줄어들어, 더 많은 스택이 적용될 때까지 플레이어가 언제 어떻게 사용할지 신중히 고려해야 합니다.\n\n다행히도 이러한 기능 대부분을 꽤 기본적인 GameplayEffect로 수행할 수 있습니다. 능력의 각 측면을 따라 최상위에서부터 작업을 시작해봅시다.\n\n다음은 검사 원격에 나타나는 능력 정의입니다:\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png)\n\n\n\n## 일정 기간 동안 플레이어의 받는 피해를 줄이기\n\n이전에 피해 증감을 조정하기 위해 애트리뷰트를 추가했기 때문에 아주 간단합니다. 플레이어의 IncomingDamageScalar 애트리뷰트를 반으로 줄이는 GameplayEffect가 필요합니다. 이후 몇 초 동안 지속됩니다:\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_1.png)\n\n## 주변 스택 수에 따라 플레이어 치료하기\n\n\n\n이것은 가장 복잡한 측면입니다. 우리는 플레이어에 적용되는 GameplayEffect를 생성하여 각 영향을 받는 적마다 플레이어를 회복시킬 수 있습니다. 이 GameplayEffect는 현재 적의 스택 수에 기반하여 플레이어를 회복시키며, 각 적에 맞게 실행하므로 우리에게 원하는 효과를 제공합니다. 이 일을 처리하는 코드 조각은 다음과 같습니다:\n\n```js\n// apply per-enemy player gameplayEffects, e.g. healing (do this before applying enemy GEs, \n// since that will remove all stack instances which we need for healing calculations)\nforeach (var ge in typedAbilityDefinition.perEnemyPlayerGameplayEffects) {\n    // note: target is still the enemy because we want to get tags from them, not the player\n    var geSpec = Owner.MakeOutgoingSpec(ge, source: Owner, target: hitAsc);\n    Owner.ApplyGameplayEffectSpecToSelf(geSpec);\n}\n```\n\n이 GameplayEffect는 지정된 적의 스택 수를 제공하기 위해 사용자 정의 TagCountBackedModifierMagnitude를 사용하며, 다음과 같이 구성됩니다 :\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_2.png)\n\n\n\n게임플레이 효과 자체:\n\n![게임플레이 효과 이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_3.png)\n\n## 영향받는 적에서 기존 스택 제거하기\n\n이것은 적용 시 모든 패시브 스택 태그 인스턴스를 제거하도록 구성된 간단한 게임플레이 효과를 통해 수행할 수 있습니다. 게임플레이 효과 구성은 다음과 같습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_4.png)\n\n그리고 GE를 적용하는 능력 정의의 작은 부분은 이렇게 생겼어요:\n\n```js\n// apply enemy gameplayEffects\nforeach (var gameplayEffect in typedAbilityDefinition.enemyGameplayEffects) {\n    var geSpec = Owner.MakeOutgoingSpec(gameplayEffect, Owner, hitAsc);\n    hitAsc.ApplyGameplayEffectSpecToSelf(geSpec);\n}\n```\n\n여기서 설명할 내용은 대략 이 정도네요! 다음 능력으로 넘어가겠습니다.\n  \n\n\n\n\n# 폭발성 발사체 구현\n\n이 능력은 BaseProjectileAbilityScriptableObject의 인스턴스로, ASC 호스트의 WeaponSystem 구성 요소를 참조하여 WeaponConfiguration을 로드하고 무기를 발사합니다. WeaponConfiguration은 다음과 같습니다:\n\n```js\npublic class BaseWeaponConfiguration : ScriptableObject {\n    \n    // 이 무기의 발사체가 어떻게 발사될 것인가? (숫자, 분산, 각도 등)\n    public ShootConfiguration shootConfiguration;\n    \n    // 이 무기가 발사하는 발사체는 무엇인가? (프리팹, 이동 및 충돌 동작 등)\n    public ProjectileConfiguration projectileConfiguration;\n    \n    [SerializeField]\n    private List\u003cGameplayEffectScriptableObject\u003e onHitGameplayEffects;\n    \n    [SerializeField]\n    private List\u003cGameplayTagScriptableObject\u003e fireWeaponGameplayCues;\n}\n```\n\n실제 능력 구현의 관련 부분은 여기에 있습니다:\n\n\n\n```js\nprotected override IEnumerator ActivateAbility() {\n    ... // 쿨다운 적용 같은 보일러플레이트 작업\n    \n    // 능력 구성에서 GameplayEffects를 프로젝타일 구성으로 복사\n    weaponConfiguration.OnHitGameplayEffects = projectileGameplayEffects;\n    \n    // 계산된 조준 각도로 WeaponSystem 호출\n    weaponSystem.TryFireWeapon(aimAngle, weaponConfiguration);\n    \n    EndAbility();\n    yield return null;\n}\n```\n\n그거면 GAS 관련 내용이 거의 다에요! WeaponSystem 구성요소는 프로젝타일을 생성하고 설정하며, 실제 프로젝타일 프리팹은 모든 이동 및 충돌 로직을 처리하여 관심사를 명확히 구분하고 코드를 정리합니다. 만약, 프로젝타일이 어떤 것과 충돌할 때 어떤 로직을 수행해야 하는 더 복잡한 능력을 구현하고 싶다면, 충돌 게임 플레이 이벤트를 기다리고 그 후 작업을 수행하려면 AbilityTask를 시작할 수 있습니다. 아직 도달하지 못했지만, 미래 로그에서 AbilityTasks의 구현을 다루겠습니다.\n\n# 탄도 탑 구현\n\n이 능력은 주위의 RigidBody에 힘을 적용하는 개체를 생성하며, 사실상 위에서 설명한 폭발성 프로젝타일 능력과 동일한 방식으로 구현됩니다: 프리팹을 소환하기 위해 WeaponSystem을 호출합니다. 앞에서 언급한 폭발성 프로젝타일 능력과 마찬가지로, 탄도 탑 능력 정의는 매우 가볍습니다. 능력 기능의 대부분은 생성된 탑 GameObject에 있습니다. 특히, ImpulseSourceComponent가 틱할 때 힘의 강도, 작용 범위 반경을 결정합니다. 다음이 에디터에서 이 구성 요소가 어떻게 보이는지에 대한 예시입니다:\n\n\n\n\n![2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_5](/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_5.png)\n\nThe actual logic is also very straightforward:\n\n- when the Ability spawns the pylon prefab, it sets its parameters such as radius, impulse strength, tick rate, and time to live\n- the ImpulseSourceComponent `Update()` determines when to tick the pylon\n- when it’s time to tick, we simply identify `RigidBody2D` instances within the pylon’s radius and apply an impulse force to them in the direction of the center of the pylon\n\nAs can be seen from the screenshot above, I’ve also added fields to allow the component to pull period and force values from the owner’s attribute system. This easily facilitates upgrades that modify the parameters of this ability — for example, one upgrade may reduce the period (thereby increasing the impulse’s trigger frequency) while also reducing the force, altering the overall function of the ability.\n\n\n\n\n# 결론\n\n지금 이 시점에서, 개념적 프레임워크로서의 GAS의 힘은 더욱 분명해지고, 이미 한 번에 처리한 보일러플레이트 작업의 가치를 볼 수 있게 됩니다. 우리는 여러 가지 다양한 능력의 구현을 더욱 탐구했으며, 시스템을 추가로 세부적으로 확장하고 개선할 수 있는 더 많은 방법들이 존재합니다. 다음 로그에서는 이러한 개선사항 중 일부에 대해 깊이 파헤치겠습니다. 예를 들어:\n\n- AbilityTasks는 여러 프레임에 걸쳐 동작하는 능력을 가능하게 하며, 능력이 이벤트에 반응할 수 있는 콜백 스타일 메커니즘을 제공합니다. 예를 들어, 우리가 플레이어를 치유하는 업그레이드를 원할 때, 주변의 가시적 마법진이 사라질 때 플레이어를 치유하는 능력이있다면, 해당 마법진 GameObject가 비활성화되고 풀로 반환될 때 일부 로직을 트리거하는 AbilityTask를 생성할 수 있습니다.\n- GameplayCues는 GameplayEffects 및 Abilities가 단순히 구성에 특정 GameplayTags를 포함시킴으로써 애니메이션, 사운드 또는 입자 효과를 재생할 수 있는 기능을 제공합니다.\n\n읽어 주셔서 감사합니다. 다음에 만나요!","ogImage":{"url":"/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png"},"coverImage":"/assets/img/2024-05-15-DevLogComposingMoreAbilitiesUsingUnityGAS_0.png","tag":["Tech"],"readingTime":8},{"title":"라라벨에 다크 모드토글 버튼 포함 추가하는 방법","description":"","date":"2024-05-15 15:43","slug":"2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton","content":"\n\n첫 번째 미디엄 게시물에 오신 것을 환영합니다! 제가 사랑하는 다크 모드 덕후로서 여러분에게 라라벨 프로젝트에서 라이트 모드와 다크 모드 간 전환을 가능하게 하는 버튼을 소개해 드리겠습니다. 함께 알아보도록 하죠!\n\n![이미지](/assets/img/2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton_0.png)\n\n# 라라벨 Breeze 설치\n\n먼저 새 프로젝트를 생성해 보세요:\n\n\n\n```js\ncomposer create-project laravel/laravel:^10.0 DarkmodeExample\n```\n\n이제 디렉토리로 이동하여 Breeze를 설치합니다:\n\n```js\ncd DarkmodeExample\ncomposer require laravel/breeze --dev\nphp artisan breeze:install\n```\n\n그런 다음 다음 질문에 답해야합니다:\n\n\n\n- 어떤 Breeze 스택을 설치하시겠습니까? Blade with Alpine.\n- 다크 모드 지원 여부를 원하시나요? 네 (당연히).\n- 선호하는 테스트 프레임워크는 무엇인가요? PHPUnit (현재는 관련 없음).\n\n마이그레이션을 실행하기 전에, .env 파일을 편집하여 데이터베이스를 애플리케이션과 연결하는 것을 잊지 마세요. 이 예제에서는 PostgreSQL을 사용하겠습니다:\n\n```js\nDB_CONNECTION=pgsql\nDB_HOST=127.0.0.1\nDB_PORT=5432\nDB_DATABASE=test_db\nDB_USERNAME=marcosklender\nDB_PASSWORD=followme\n```\n\n작업이 완료되면 아래와 같이 애플리케이션을 실행해 봅시다:\n\n\n\n```js\nphp artisan migrate\nnpm install\n```\n\n```js\nphp artisan serve\nnpm run dev\n```\n\n모든 것이 제대로 진행되면 프로젝트가 실행될 것입니다. 대시보드 뷰에 접근하려면 우리 자신을 등록해야 합니다.\n\n이제 신뢰할 수 있는 IDE를 사용하여 다음 파일을 편집해 봅시다:\n\n\n\n\n- /tailwind.config.js\n\n```js\n...\n    plugins: [forms],\n\n    darkMode: 'class' // Just add this line at the bottom.\n};\n...\n```\n\n- /resources/js/app.js\n\n```js\nimport \"./bootstrap\";\n\nimport Alpine from \"alpinejs\";\n\nwindow.Alpine = Alpine;\n\nAlpine.start();\n\n// 다크 모드 토글 버튼\nvar themeToggleDarkIcon = document.getElementById(\"theme-toggle-dark-icon\");\nvar themeToggleLightIcon = document.getElementById(\"theme-toggle-light-icon\");\n\nif (\n    localStorage.getItem(\"color-theme\") === \"dark\" ||\n    (!(\"color-theme\" in localStorage) \u0026\u0026\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches)\n) {\n    themeToggleLightIcon.classList.remove(\"hidden\");\n} else {\n    themeToggleDarkIcon.classList.remove(\"hidden\");\n}\n\nvar themeToggleBtn = document.getElementById(\"theme-toggle\");\n\nthemeToggleBtn.addEventListener(\"click\", function () {\n    themeToggleDarkIcon.classList.toggle(\"hidden\");\n    themeToggleLightIcon.classList.toggle(\"hidden\");\n\n    if (localStorage.getItem(\"color-theme\")) {\n        if (localStorage.getItem(\"color-theme\") === \"light\") {\n            document.documentElement.classList.add(\"dark\");\n            localStorage.setItem(\"color-theme\", \"dark\");\n        } else {\n            document.documentElement.classList.remove(\"dark\");\n            localStorage.setItem(\"color-theme\", \"light\");\n        }\n    } else {\n        if (document.documentElement.classList.contains(\"dark\")) {\n            document.documentElement.classList.remove(\"dark\");\n            localStorage.setItem(\"color-theme\", \"light\");\n        } else {\n            document.documentElement.classList.add(\"dark\");\n            localStorage.setItem(\"color-theme\", \"dark\");\n        }\n    }\n});\n```\n\n\n\n- /resources/views/layouts/navigation.blade.php\n\n```js\n...\n\u003c!-- 설정 드롭다운 --\u003e\n\u003cdiv class=\"hidden sm:flex sm:items-center sm:ms-6\"\u003e\n\n    \u003c!-- 이 버튼을 여기에 추가하세요 --\u003e\n    \u003cbutton id=\"theme-toggle\" type=\"button\"\n        class=\"text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2.5\"\u003e\n        \u003csvg id=\"theme-toggle-dark-icon\" class=\"hidden w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.org/2000/svg\"\u003e\n            \u003cpath d=\"M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z\"\u003e\u003c/path\u003e\n        \u003c/svg\u003e\n        \u003csvg id=\"theme-toggle-light-icon\" class=\"hidden w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.org/2000/svg\"\u003e\n            \u003cpath\n                d=\"M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z\"\n                fill-rule=\"evenodd\" clip-rule=\"evenodd\"\u003e\u003c/path\u003e\n        \u003c/svg\u003e\n    \u003c/button\u003e\n\n    \u003cx-dropdown align=\"right\" width=\"48\"\u003e\n        \u003cx-slot name=\"trigger\"\u003e\n...\n```\n\n웹 브라우저로 돌아가시면, 전체 앱에 대한 선택을 기억하며 밝은/어두운 모드 사이를 전환할 수 있는 아이콘을 찾을 수 있습니다.\n\n끝까지 오신 것에 감사합니다. 당신과 같은 분들이 저에게 격려를 주어 계속해서 제 경험을 공유하고 싶게 만듭니다. 다음에 또 만나요! 👋🏻\n\n\n\n제 LinkedIn을 통해 언제든지 연락 주세요. ✍🏻","ogImage":{"url":"/assets/img/2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton_0.png"},"coverImage":"/assets/img/2024-05-15-HowtoadddarkmodeinLaravelwithtogglebutton_0.png","tag":["Tech"],"readingTime":5},{"title":"카오스 엔지니어링 파트 I 소개 및 개념","description":"","date":"2024-05-15 15:41","slug":"2024-05-15-ChaosEngineeringPartIIntroductionConcepts","content":"\n\n## 대규모 이벤트를 위한 준비\n\n# 일화\n\n2018년 러시아에서 개최된 FIFA 월드컵 기간 동안, 온라인 스트리밍 플랫폼인 훌루(Hulu)가 중대한 장애를 경험했습니다. 이 장애로 시청자들은 훌루 플랫폼에서 경기를 실시간으로 스트리밍할 수 없었습니다. 포르투갈과 모로코 사이의 매우 기대되는 경기 중에 장애가 발생하여 많은 팬들이 경기를 시청할 수 없었습니다. 같은 예시로 아마존 프라임 데이 장애(2018)와 구글 클라우드 장애(2023)가 있습니다.\n\n2019년 크리켓 월드컵 인도와 뉴질랜드의 준결승전에서 MS 도니가 경기장에 나설 때, 인도의 주요 스트리밍 플랫폼인 호트스타(Hotstar)은 이전에 없던 동시 접속자 수를 기록했습니다. 플랫폼은 25.3백만 명의 동시 접속자 수를 기록했습니다(2019 IPL 결승전 기록과 비교했을 때 동시 접속자 수가 36% 증가한 거대한 수치).\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1152/1*FGVPaKYqzqow7Q5Zv0Ivsw.gif)\n\n# 소개\n\n건물을 건설 중이라고 상상해보세요. 자연 재해나 극한 기상 현상과 같은 다양한 도전에 견딜 수 있는 건물을 만들고 싶습니다. 그 건물의 탄력성을 테스트하는 한 가지 방법은 이러한 사건들을 기다렸다가 건물이 어떻게 견디는지 확인하는 것입니다. 그러나 이 방법은 위험할 수 있으며 중대한 피해나 완전한 파괴로 이어질 수 있습니다.\n\n카오스 엔지니어링은 건설이 완료되기 전에 통제된 환경에서 카오스/스트레스 테스트를 실행하여 의도적으로 이러한 시나리오를 모의하는 것과 같습니다. 이는 건설 과정 중의 잠재적인 약점과 취약점을 선행적으로 식별하여 문제가 발생하기 전에 대응할 수 있는 방법입니다.\n\n\n\n\n![Image](/assets/img/2024-05-15-ChaosEngineeringPartIIntroductionConcepts_0.png)\n\n# 소프트웨어 생태계에 적용하는 방법\n\n소프트웨어는 기계에서 실행되며 리소스 제약( CPU, 메모리, 디스크)을 가지고 있으며 일정한 부하만 지탈을 수 있습니다. 노트북에서 추가로 크롬 창을 열면 팬이 큰 소음을 내며 컴퓨터 리소스가 한계에 다다랐음을 나타내는 장면을 경험할 수 있습니다.\n\n이 익숙한 시나리오는 대규모 응용 프로그램이 돌발적인 트래픽 증가 또는 리소스 활용이 발생했을 때 직면하는 도전의 미시적인 사례입니다. 개인 컴퓨터가 동시에 너무 많은 응용프로그램을 실행하여 혼란스러워질 수 있는 것처럼, 복잡한 분산 시스템도 예상치 못한 부하로 인해 붕괴되어 성능 하락, 장애 또는 완전한 중단으로 이어질 수 있습니다.\n\n\n\n\n\n![Chaos Engineering](/assets/img/2024-05-15-ChaosEngineeringPartIIntroductionConcepts_1.png)\n\n# 실제 사례\n\n실제 사례를 살펴보면 카오스 테스트가 취약점을 시뮬레이션하고 식별하는 데 사용되는 몇 가지 사례를 볼 수 있습니다.\n\n- 원자력 발전소: 원자력 발전소는 비상 대응 계획과 절차를 테스트하기 위해 정기적인 훈련 및 시뮬레이션을 실시합니다. 이 연습들은 반응기 고장, 방사능 누출 또는 발전소 운영에 영향을 줄 수있는 자연재해 등의 시나리오를 시뮬레이션할 수 있습니다. 극한 조건 하에서 시스템을 테스트함으로써 원자력 발전소는 취약성을 식별하고 운영의 안전성을 보장할 수 있습니다.\n- 아마존: 아마존은 \"GameDay\"라는 긴 전통을 가지고 있으며, 팀은 본딩 시스템에 의도적으로 오류를 도입하여 그 견고함을 테스트합니다. 이벤트 중에 팀은 네트워크 장애, 서버 장애 등과 같은 다양한 시나리오를 시뮬레이션합니다. 이러한 실천은 아마존이 취약성을 확인하고 해결하여 서비스가 실제 장애를 견디고 높은 가용성을 유지할 수 있도록 도왔습니다.\n\n\n\n\n# 카오스 테스트를 어떻게 수행할 수 있을까\n\n카오스 테스트를 구현하는 등의 조치를 취해도 대규모 응용 프로그램을 관리하는 것은 복잡하고 지속적인 도전입니다. 시스템이 커지고 복잡성이 증가하며 사용자가 성능과 가용성에 대한 요구를 증가시킬 때, 이러한 응용 프로그램이 가장 강렬한 부하를 견딜 수 있고 신뢰할 수 있고 탄력적일 수 있도록 보장하기 위해 계속해서 새로운 기술과 접근 방식이 개발되고 있습니다.\n\n네트워크 오류 (예: 네트워크 지연, 패킷 손실, DNS 오류), 리소스 고갈 (예: CPU, 메모리 또는 디스크 공간)과 같은 다양한 구성 요소의 실패 또는 장애를 시뮬레이션하여 인프라 수준에서 카오스 실험을 자동화하고 조율하는 데 도움이 되는 다양한 오픈 소스 (Chaos Toolkit, Litmus) 및 상용 도구 (AWS Fault Injection Simulator)이 있습니다.\n\n블로그의 다음 부분에서는 AWS Fault Injection Simulator와 Litmus에 대해 이야기할 것입니다. 어떻게 사용하여 카오스 실험을 조율할 수 있는지 알아보겠습니다.\n\n\n\n안녕하세요,\n소라브\n\n읽어주셔서 감사합니다! 매주 2번씩 꾸준히 업로드할 수 있도록 노력하겠습니다. 제가 Medium에 글을 올릴 때마다 이메일 알림을 받으실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-ChaosEngineeringPartIIntroductionConcepts_0.png"},"coverImage":"/assets/img/2024-05-15-ChaosEngineeringPartIIntroductionConcepts_0.png","tag":["Tech"],"readingTime":3},{"title":"개발 속도를 높이고 비용을 절감하는 방법 SAPI","description":"","date":"2024-05-15 15:40","slug":"2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI","content":"\n\n모바일이나 웹 제품을 개발하거나 이미 보유하고 계신다면, 간단한 API인 SAPI를 사용하여 필요한 자원(인력)의 수를 줄이고 예상보다 빠르게 마감일에 도달할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_0.png)\n\nSAPI를 사용하면 REST API(공개 웹 주소)를 생성하여 클라이언트(애플리케이션)가 원하는 내용/응답 및 포맷으로 소비할 수 있습니다. 대부분의 웹 및 모바일 애플리케이션은 JSON을 사용하여 데이터를 전달합니다. JSON은 기본적으로 매우 특정한 형식의 텍스트(이름/값 쌍)입니다. 예를 들어:\n\n```js\n[\n    {\n        \"title\": \"내 미디엄 게시물\",\n        \"slug\": \"/my-medium-post\",\n        \"author\": \"곤잘로\",\n        \"categories\": \"REST-APIs\",\n        \"tags\": \"API, Cloud, Platform\",\n        \"excerpt\": \"개발 가속화를 위한 SAPI 사용\",\n        \"content\": \"글 내용이 여기에 ...\",\n        \"link\": \"https://simple-api.app\",\n        \"unique\": \"5a365275f3e0dd9396dfe4682fe2876b\",\n        \"created\": \"1691010876\",\n        \"modified\": \"1691010876\",\n        \"public\": \"예\",\n        \"date\": \"2024년 12월 12일\",\n        \"image\": \"https://simple-api.app/assets/logo.png\"\n    },\n    { ... },\n    { ... }\n]\n```\n\n\n\n위의 예시는 JSON 구조를 보여줍니다. 이는 기사와 유사한 콘텐츠로, 뉴스 피드 앱에 공급하는 데 사용할 수 있는 내용입니다.\n\n온라인에서 (또는 공개적으로 이용 가능한) 이와 유사한 엔드포인트를 생성하거나 보유하는 것은 매우 쉽고 직관적입니다. 앱에서 소비할 준비가 된 형태로 제공됩니다.\n\n좋은 점은 다른 옵션이 여러 가지 있다는 것입니다:\n\n- 정적 콘텐츠를 사용하여 (위의 예시처럼 특정 JSON 구조를 직접 복사/붙여넣기), 엔드포인트를 Google 스프레드시트에 연결하고 제품 재고 목록을 JSON 형식으로 변환하여 위의 예시와 같이 나열하는 것과 같은 가능성이 있습니다.\n- 클라우드 SQL 관리자를 사용하여 데이터베이스와 테이블을 업로드, 생성하고 쿼리하는 능력 — 기존 데이터를 플랫폼에 가져와 필요한 쿼리를 실행하거나 저장하여 엔드포인트를 생성할 때 로드할 수 있음으로써 가장 좋은 조합 중 하나라고 말할 수 있습니다.\n- Proxy SOAP 또는 공개 API를 사용하여 (이 시나리오에서 API의 응답은 위의 출력/연결에서 제공된 응답임) 엔드포인트를 암호로 보호하거나 웹훅을 설정하고 원격 구성을 사용하는 등의 설정 가능.\n\n\n\n\n여기 제시된 다른 방법들 외에도, 편집기로 .csv 파일을 직접 업로드할 수도 있어요.\n\n![image1](/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_1.png)\n\n![image2](/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_2.png)\n\n![image3](/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_3.png)\n\n\n\n위의 그림에서 API 편집기가 어떻게 보이는지 확인할 수 있습니다.\n\n고객 도메인은 사용자의 도메인 이름 아래에서 API가 실행되도록 도와주는 기능으로 개발 중입니다. 모바일 개발에서는 iOS를 예로 들면 다른 도메인에서 데이터를로드 할 때 보안 문제를 극복할 수 있습니다(자세한 내용은 문서 섹션에서 확인할 수 있습니다). 웹 개발에서는 CORS 문제가 발생할 수 있으므로 위의 기능에 주목하세요.\n\n따라서 CEO, 기업가(혼자서 하는 일), 제품이 어떻게 보이고 어떤 콘텐츠가 있어야 하는지 전체 그림을 가진 사람이며(색상 테마, 메뉴 위치 및 번역을 포함한 내용 유형), 이러한 자료를 준비하고 응용 프로그램을 만들어야 하는 담당 개발자에게 전달하는 데 몇 시간을 소비하는 사람이라면 정말 흥미로울 것입니다!\n\n위의 시나리오에서는 개발자가 아닌 경우 두 명의 사람이 있으면 작업을 완료할 수 있으며 충분합니다.\n\n\n\n저희 API 및 API와 컨텐츠 생성, 배포, 수익화에 관련된 모든 도구를 이용해보시기를 초대합니다. (다음 게시물에서 다룰 도구도 있습니다.)","ogImage":{"url":"/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_0.png"},"coverImage":"/assets/img/2024-05-15-SpeedingupdevelopmentandcuttingcostswithSAPI_0.png","tag":["Tech"],"readingTime":3}],"page":"90","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"90"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>