<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/67" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/67" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="3D로 감싼 벡터 필드와 연료 소비" href="/post/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="3D로 감싼 벡터 필드와 연료 소비" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="3D로 감싼 벡터 필드와 연료 소비" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">3D로 감싼 벡터 필드와 연료 소비</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유" href="/post/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서 NgRx를 활용한 상태 관리하는 방법" href="/post/2024-05-18-StatemanagementwithNgRxinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서 NgRx를 활용한 상태 관리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서 NgRx를 활용한 상태 관리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서 NgRx를 활용한 상태 관리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 53에 새로 추가된 내용 정리" href="/post/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 53에 새로 추가된 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 53에 새로 추가된 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 53에 새로 추가된 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Cars24 SDE-2 Frontend 면접 경험" href="/post/2024-05-18-Cars24SDE-2FrontendInterviewExperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Cars24 SDE-2 Frontend 면접 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Cars24 SDE-2 Frontend 면접 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Cars24 SDE-2 Frontend 면접 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " href="/post/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 </strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" href="/post/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 웹사이트 성능 향상 시키는 방법" href="/post/2024-05-18-performanceinreact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-performanceinreact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 웹사이트 성능 향상 시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Axios, Fetch, Express 깊이 알아보기" href="/post/2024-05-18-ADeepDiveintoAxiosFetchandExpress"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Axios, Fetch, Express 깊이 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NinjaCart SDE 2 프론트엔드 인터뷰 경험" href="/post/2024-05-18-NinjaCartSDE2frontendInterviewExp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NinjaCart SDE 2 프론트엔드 인터뷰 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link posts_-active__YVJEi" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"3D로 감싼 벡터 필드와 연료 소비","description":"","date":"2024-05-18 21:52","slug":"2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D","content":"\n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png)\n\n푸아송 방정식, 벡터 필드 및 특수 신경망 사이의 연결을 탐구하면서, 사용자 정의 벡터 필드 시각화를 만들기로 결정했습니다. 미적분의 몇 가지 경험적인 응용을 소개하고 싶습니다. 보트, 비행기 또는 차량을 보유하고 계신다면, 이 글을 마치면 돈을 아끼기 위해 어느 경로를 선택하고 언제 출발해야 하는지를 결정할 수 있을 겁니다. 대개의 여정에서 강한 해풍보다 강한 꼬리풍이 더 좋습니다.\n\n본 글의 목표는 공간을 통과하는 가장 일치하는 경로를 찾는 것입니다. 이를 달성하기 위해 일반적인 작업과 비용 함수 같은 기본적인 개념을 사용할 것입니다. 최적 제어의 의미에서 최적 경로를 찾는 것이 목표가 아니므로 글의 끝에 우리는 정확한 비행 또는 항해 당 소비량을 알지 못할 것입니다. 그러나 “주어진 벡터 필드에 대해, 이 경로는 최소한의 저항을 줄 것”이라고 말할 수 있을 것입니다. 하지만 나중에 특히 신경망과 결합하여 최적 제어 개념을 다시 살펴볼 수도 있을 것입니다. 이러한 분야는 매우 관련이 깊습니다.\n\n본 글에서 제시된 솔루션은 WebGL2와 TypeScript의 조합입니다. WebGL 개념은 제가 직접 구현했지만, 일부 계산 부분은 직접 구현하기 번거로울 수 있습니다. 즉, 방정식의 상징적 조작이나 노이즈 생성과 같은 부분은 제작자의 이해로 하여금 코드를 이해하는 데 아무런 영향을 끼치지 않아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소리를 내보세요\n\n보통 날씨 예보나 현재 바람 상황은 바람 깃발을 통해 설명됩니다. 이 바람 깃발은 특정 위치(경도, 위도, 고도)에서의 바람의 방향과 속도를 기본적으로 제공합니다. 이러한 데이터 포인트들은 벡터 필드를 형성합니다(공간의 각 점에서의 관련 스칼라 값과 방향). 하지만 스칼라 필드 같은 다른 종류의 필드들도 있습니다. 즉, 공간의 각 점에서의 온도와 같은 것입니다. 제 집 프로젝트에서는 벡터 필드 데이터가 저가 해결하고 있는 문제들에 해당하지만 연료 소비에 대한 경우와 이 게시물에서는 소음을 생성기로 사용할 것입니다.\n\n벡터 필드를 생성하기 위해 Simplex 소음을 사용할 것입니다. Simplex 소음의 중요한 성능 특성 중 하나는 생성된 소음의 차원과 매우 잘 조화를 이룬다는 것입니다. 다른 것들과 대조적으로, 예를 들어 퍼린 소음과 같은 것들과는 다르게요. 우리의 벡터 필드는 시간에 따라 변할 것이므로, 4차원 소음을 생성해야 하며 매 프레임은 사실상 그 4차원 공간에서의 3차원 슬라이스가 될 것입니다. Simplex 소음이 더 나은 성능을보일 수 있는 이유에 대해 상세히 다루는 공간이 없기 때문에 그것에 대한 자세한 내용을 다루지 않겠습니다. 그건 또 다른 전체 블로그 글이 될 것이지만 웹에서 많은 정보를 찾을 수 있습니다.\n\n우리의 사용 사례에 대해, 저는 이 소스에서 Simplex 구현을 사용했습니다. 이 결정의 뒤에 있는 이유는 쉐이더에서 직접 계산을 사용할 수 있는 가능성과 코드가 상당히 읽기 쉽기 때문입니다. 우리의 소음 기능인 N(x, y, z, t)는 `0, 1.0` 사이의 값입니다. 내부적으로 벡터 당 세 개의 랜덤 값이 필요합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- XY 평면 각도\n- XZ 평면 내 각도\n- 벡터 크기\n\n각 쌍은 z 매개변수에 대한 다른 상수 오프셋 샘플링을 통해 얻어집니다. 오프셋은 값이 교차하지 않도록 선택되므로 XY 각도는 N(x, y, z, t), XZ 각도는 N(x, y, z + 오프셋, t)이고 벡터 크기는 N(x, y, z + 2*오프셋, t)입니다. 중요 참고 사항은 서로 다른 노이즈 구현은 서로 다른 함수 범위를 가질 수 있으므로 항상 `0`, `1.0` 사이의 값을 얻을 수 없을 수도 있습니다.\n\n아래 벡터 필드의 시각화를 확인할 수 있습니다. 벡터 외에도 텍스처로 렌더링된 노이즈를 볼 수 있습니다 - 회색으로 분리되거나 RGB로 세 개의 채널로 결합됩니다.\n\n공간은 Z 축을 따라 n 개의 평면으로 분할되며, 각 평면은 그럼으로써 렌더링됩니다. 일반적으로 전체 노이즈 필드를 렌더링할 필요는 없지만, 시각화 목적으로 그렇게 합니다. 아래에서 보듯이, 하단 레이어는 노이즈 필드가 실제로 어떻게 보이는지 보여줍니다; 시간에 따라 변하는 회색 이미지입니다. 그런 다음 오프스크린 텍스처를 가져와서 우리의 벡터를 그릴 수 있습니다 (현재 각 평면당 400개의 벡터). 벡터의 각도와 크기는 쉐이더에서 텍셀을 추출하여 텍스처로부터 얻어집니다. 사용자 인터페이스에서 동적으로 더 많은 레이어를 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플로우, 느껴보세요!\n\n벡터는 현재 벡터 필드 상태를 시각화하는 데 좋지만 때로는 전체 시스템의 시간 간격 기반 동작을 얻기 위해 플로우 필드 시각화를 하는 것이 더 나을 수도 있어요. 그리고 그것이 바로 우리의 세 번째 시각화 도구이기도 해요. WebGL은 약간 제한적인 프레임워크이기 때문에 (컴퓨팅 또는 지오메트리 쉐이더의 사용은 야생 서부와 같다), 우리는 플로우 필드를 텍스처에 렌더링할 거에요. 간단화된 파이프라인은 다음과 같아요:\n\n- 시간 T에서 공간 내에서 N개의 랜덤한 점을 생성하고 위치를 버퍼 B1과 B2에 저장하기\n- B1의 점들을 텍스처에 그리기\n- 텍스처 렌더링 후 텍스처의 알파 값을 낮추어 시간에 따라 입자의 꼬리를 얻기\n- 현재 벡터 필드(우리의 Noise 함수)를 기반으로 시간 T+Epsilon에서 점들의 위치 계산하고 결과를 B2에 저장하기, 기본적으로 B2 = Noise('B1')\n- 버퍼 B1과 B2 교체하기\n- 두 번째 단계로 이동하기\n\n그러나 이 단계에서는 우리가 노이즈를 렌더링할 때와 같이 오프스크린 텍스처를 사용하지는 않을 거에요. 우리는 데이터셋(점으로 표현된 입자) 위에서 계산하는 것에만 관심이 있기 때문에 WebGL의 Transform Feedback 기능을 사용할 거예요. 이 접근 방식은 GPGPU에 대한 텍스처 핑퐁보다 약간 더 나아요. 우리는 데이터와 직접 작업할 수 있어 샘플링 모호성을 방지할 수 있어요. 텍스처나 텍셀 페치의 샘플링이 어떻게 깨졌다는 것은 전혀 말하고 싶지 않아, 하지만 얻은 데이터의 정확성과 특정 방식으로 보간되지 않을 것임을 내 인생을 건다고 말할 수는 없겠어요. 하지만 아마도 저는 너무 의심이 많을지도 모르겠어요. :] 빨간색은 더 빠른 입자를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말씀드린 대로, 저희 Noise 함수는 셰이더에서 구현되어 있어서 Transform feedback과 함께 Noise를 사용하는 것은 간단합니다. 저는 성능을 깊게 테스트하지는 않았지만, 우리는 입자들을 두 번만 접촉하고 새로운 위치를 계산하고 드로우 콜을 하기 때문에 규모 확장 관점에서 꽤 좋을 것입니다. 이 특정 경우에는 플로우 시각화가 그다지 흥미로운 것은 아니지만, 이것을 2D 평면상의 투사 표면 기울기 필드의 시각화로 사용하고 있으며 3D 공간을 탐색하는 것보다 더 유용합니다.\n\n## 비행기는 어디죠, 류보스키?\n\n그래서 저희는 벡터 필드를 갖고 있고, 몇 가지 시각화 기술 집합도 있습니다. 필요한 것은 실제 비행기와 비행 경로뿐입니다. 일반적으로, 어떤 경로를 선택하든 여행 비용을 계산할 수 있어야 하지만, 실제 생활과 적어도 어느 정도 유사한 케이스를 만들기 위해 실제 비행과 비슷한 경로를 선택해야 합니다.\n\n저는 Bump 함수부터 시작하기로 결정했습니다. 이 함수는 대칭적이며, 도메인 크기에 비해 오랜 플랫폼을 갖고 있을 수 있으며, 공격적인 이륙 또는 착륙을 나타낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹지엘에서 경로 시각화는, 잘, 이상적이지 않아요. 우리는 공간에서 경로 표현에 많은 시간을 쏟을 수 있지만, 저는 더 중요한 일이 있어서 악마와 협상을 통해 LINE_STRIP를 통한 표현으로 만족해야 합니다. 어떤 함수든 주어졌을 때, 프로그램은 N개의 점에서 함수를 샘플링하고 벡터 필드를 통해 스트립을 만듭니다. 보면서 알 수 있듯이, 어떤 샘플 점에서든 해당 시간에 벡터 값도 시각화됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_1.png\" /\u003e\n\n## 비행 비용\n\n나중에 더 복잡한 내용을 다룰 예정이지만, 먼저 입자가 일정 경로를 따라 벡터 필드를 통해 이동할 때 수행되는 작업의 기본적인 정의를 사용할 것입니다. 그래서 우리 경우에 비행기가 단순히 입자로 가정합시다. 직관적으로, 이 적분은 현재 시간에 따른 벡터 필드와 얼마나 잘 맞는지를 말합니다. 즉, 양수가 나오면 풍향이 더 세다는 것을 의미하고, 음수가 나오면 역풍이 더 강했다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Vector Fields and Fuel Consumption Wrapped in 3D](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_2.png)\n\nr는 우리 경로를 통해 매개변수화된 함수이며, F는 노이즈 함수에 의해 정의된 우리의 벡터 필드이며, 경로에서 계산된 것이며 시간 t에 대해 적분하고 싶습니다. 또한 적분하기 전에는 매개변수화된 함수의 도함수와 점곱을 해야 합니다. 이 모든 것은 전부 좋고 훌륭한데, 식을 적분하기 시작하기 전까지만요. 이를 해결하는 데 여러 문제가 있습니다. 하지만 그 문제에 들어가기 전에, 우리의 노이즈 함수를 살펴봅시다.\n\n## Akima? 네!\n\n심플렉스 노이즈의 정의는 기본적으로 우리의 섀이더에 작성되어 있으므로, 이를 적분의 입력으로 사용해도 괜찮다고 생각할 수 있습니다. 결국, 노이즈 계산을 단순화할 때 논리적으로 증명하기 위해서, 이는 적분하기 쉽게 다루기 쉬운 다항식들에 대한 멋진 작업들뿐인 것이기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제는 벡터 계수를 얻으려면 사인 및 코사인 함수를 적용해야 한다는 것입니다. 그리고 이러한 함수를 적분하면, 일반화된 프레넬 적분 영역에 들어가게 됩니다. 이러한 적분을 해결하고 나열할 수는 있지만, 많은 작업이 필요합니다. 그리고 궁금증은 Matlab이나 Scipy와 같은 백엔드를 사용하지 않고도 비슷한 프로젝트에서 복소해석을 다루고 싶은지에 대한 문제입니다.\n\n그러나 다른 방법으로 이 문제를 해결하는 또 다른 주장이 있습니다. 종종 수천 개의 센서에서 얻은 데이터때문에 벡터 필드의 정의를 알 수 없는 경우가 많습니다. 그리고 예, 동적 시스템을 어떻게든 모델링하거나, 뉴럴 네트워크를 학습시키거나 오버피팅하여 꽤 좋은 상미분 방정식 또는 편미분 방정식을 얻을 수는 있지만, 그것은 쉬운 작업이 아닙니다.\n\n대신, 우리는 다음과 같이 할 것입니다. 경로 r을 따라 노이즈 함수를 N개의 점에서 샘플링하여 무작위 삼중 세트 (XY 각도, XZ 각도, 벡터 크기)를 얻습니다. 그런 다음, 우리는 벡터의 성분을 얻기 위해 사인/코사인 변환을 적용할 것입니다. 마지막으로, 우리는 그 데이터 점에 Akima 스플라인 보간을 적용하여 세 개의 연속적인 조각 이차 다항 함수를 얻을 것입니다 (총 N-1 다항 함수가 각 성분당).\n\nAkima 스플라인은 계산이 매우 빠르고 특히 연속 도함수의 n차 순도 같은 강력한 요구사항이 없는 경우 특히 유용한 유형의 스플라인이기 때문에 흥미로운 유형의 스플라인입니다. 우리의 경우, 우리는 처음 도함수만 필요합니다. 이것은 잘 동작하며 평균 오차가 작으며 종종 그러한 다항 함수들이 선형이거나 일정할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 단일 적분이 N-1개의 적분으로 분할되어 함께 요약해야 한다는 것을 의미합니다. 이론적으로 각 근사치에 스텝 함수 또는 헤비사이드 함수의 해석적 근사치를 곱해서, 스플라인이 해당 도메인에서만 \"활성화\"되도록 할 수 있습니다. 그러나 이는 최종 적분을 더욱 복잡하게 만들 수 있습니다.\n\n# 버프 함수가 손을 놓고 있지 않습니다\n\n지금까지는 벡터 필드가 다항식으로 근사되어 왔고 이제는 매개변수화된 경로 함수 r의 미분을 어떻게 처리할지 신경 써야 합니다. 우리의 내적 부분을 살펴봅시다: \n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAkima의 보간 (다항식)이 있는 벡터 필드에 따른 경로의 pol, 그리고 g(t)는 t에 관한 매개변수화된 경로의 z 성분입니다. 아래에서 g(t) 함수의 두 예시를 볼 수 있습니다. 하나는 상수 0이고, 다른 하나는 sin(t)입니다. 이제 우리는 벡터 필드를 통해 의미 있는 경로를 구성할 수 있습니다.\n\n범프 함수의 유도는 나쁘지 않지만, 우리는 이것이 다항식들과의 내적에서 곱해질 것이며, 그것이 우리의 다음 문제라는 것을 깨닫게 되어야 합니다. 그러한 적분은 수치적으로만 해결할 수 있고, 그것은 우리가 꼭 하고 싶어하는 것은 아닙니다.\n\n그래서, 우리는 매개변수화된 경로 함수의 유도를 Akima 스플라인을 통해 보간할 것입니다. 이제 내적은 최대 6차수의 다항식을 생성하고, 다항식의 적분은 괜찮고 잘 되며, 결국 언어로도 따지지 않고 잘 될 것입니다.\n\n라이브 데모나 소스 코드를 함께 살펴보거나 플레이하려고 계획하시는 경우, FlightHelper 클래스에 임의의 경로를 추가할 수 있습니다. 사용하고 싶은 기호적 표현을 사용할 수 있지만, Nerdamer와 호환되어야 합니다. 이전 그림에서 본 함수들에 대한 정의는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstatic init() {\n  this.flightPaths = new Array\u003cFlightPath\u003e()\n  this.flightPaths.push(\n    new FlightPath(\"sin(3x)\", \"e^(-1/(1-x^2))\")\n  )\n\n  for (let i = 0; i \u003c 5; i++) {\n    let offset = \"\" + (1 + 0.1 * i) + \"*\"\n    this.flightPaths.push(\n      new FlightPath(\"0\", offset + \"e^(-1/(1-x^2))\")\n    )\n  }\n}\n```\n\n# 결과가 나타납니다!\n\n정수 안정성과 계산된 작업이 정확하게 될지에 대해 약간 불안했던 점을 인정해야 했습니다. 특히 여러 Akima 보간법을 사용하는 경우입니다. 그 결과는 생각보다 나아졌습니다. 아래 비디오에서 확인할 수 있습니다.\n\n벡터 필드가 우리의 경로와 일치하는 경우, 작업 결과는 2가 되며 정확히 도메인 크기가 2이기 때문에 합리적입니다. 벡터 필드가 우리에게 반대로 작용할 때 작업 결과는 -2이고 수직일 때는 작업이 0입니다. 다음 비디오에서는 벡터 필드가 잡음에 의해 무작위로 개선되었을 때의 계산을 볼 수 있습니다. 완료되면 최적의 경로는 검은색으로 표시되며 각 경로의 비용은 왼쪽 상단에 표시됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 하지만 비행기는 단순히 한 점이 아닙니다\n\n지금까지 우리는 벡터 필드가 우리의 경로와 얼마나 일치하는지 계산할 수 있었습니다. 우리의 계산은 정확한 모델은 아니지만, 이제 어느 경로가 에너지적인 관점에서 어떻게 더 나은지 또는 나쁜지를 말할 수 있습니다. 우리가 프라하에서 도쿄로 사선비행기로 날아갈 때 언제 출발할지 선택한다면, 날씨 예측을 기반으로 작업 계수를 계산하여 가장 일치하는 예측을 선택했기 때문에 연료를 절약할 수 있습니다. 그러나 다른 교통 수단으로도 그렇게 할 수 있습니다. 예를 들어 보트를 소유하고 있다면, 바람 날씨 예측 데이터 대신에 파도 속도를 바람 예측과 결합하여 사용할 수 있으며, 작업은 동일하지만 차원이 적어집니다.\n\n연료 소비의 정확한 모델보다는 계산을 개선할 수 있는 한 가지 방법이 있습니다. 작업 적분 뿐만 아니라, 우리의 적분에 다른 함수를 추가해 보겠습니다. 이를 '비용'이라고 부르겠습니다: \n\n\u003cimg src=\"/assets/img/2024-05-18-벡터필드와연료소비의3D포장.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 함수는 다음과 같은 전체 동적 특성을 나타낼 수 있어요:\n\n- 45도에서의 역풍은 45도에서의 유동풍과는 다른 영향을 줄 수 있어요.\n- 이륙 단계에서는, 벡터 필드에서의 어떤 역풍이 최종 작업 적분에 더 큰 영향을 줄 거에요.\n- 비행 시간이 길수록, 연료를 소모하기 때문에 바람이 더 큰 영향을 줄 거에요.\n- 비행기의 공기역학 프로필을 전파할 수도 있어요. 즉, 각도별로 다른 계수를 사용할 수 있어요.\n- 지금까지 비행기의 추진력을 고려하지 않았는데, 이 또한 벡터 필드의 영향에 대해 동적 시스템일 수 있어요.\n\n비용 함수는 매우 복잡할 수 있으며, 물리적인 비행기나 상세한 모델이 없으면 예측하기 어려울 수 있어요. 그러나 서로 다른 아이디어로 실험해 볼 수 있으며, 포아송 방정식과 관련해 이 개념을 해결하는 동안 다양한 경우에 대해 실험해 볼 수 있어요. 또한 비용 함수의 적용은 다른 경우에 따라 다르며, 곱셈뿐만 아니라 비용이 작업자 역할을 할 수도 있어요.\n\n# 길을 보여주세요, 나의 주여\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 목적지로 비행할 때 언제 출발할지 선택할 수 있는 위치에 있습니다. 경로도 선택할 수 있습니다 — 보통 이는 사실이 아니며, 항공 공간은 무질서가 아닙니다. 수학적 관점에서 우리는 작업 적분의 전역 최솟값을 찾고, 해당 최솟값 후보를 얻기 위해 도함수가 영과 같은 도함수를 찾을 수 있습니다:\n\n![image](/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_5.png)\n\n이 문제를 해결하는 것은 쉽지 않을 수 있습니다. 특히 비용 함수가 복잡해질 때입니다 — 이것은 개념/아이디어로만 간주하십시오. 실제로 이러한 문제는 다르게 해결됩니다. 그러나 실제 세계에서 효과적으로 작동할 수 있는 다른 옵션들이 있습니다. 지금까지 이러한 옵션은 프로젝트에 아직 구현되지 않았습니다. 왜냐하면 저는 그것들이 필요하지 않았기 때문이지만, 나중에 추가할 수도 있습니다.\n\n하나의 해결책은 세상을 3D 그리드로 분할하고 그래프상에서 최적의 경로를 찾는 것입니다. 그리드가 정칙적이므로 경로에 스플라인 보간을 적용할 수도 있습니다. 게다가 규칙 세트도 갖고 있을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 경로 시작점으로부터 현재 위치까지의 유클리드 거리는 항상 증가해야 하며, 동시에 현재 위치로부터 경로 끝까지의 유클리드 거리는 항상 감소해야 합니다.\n- 격자 위의 어떤 점도 반드시 어떤 봉투 안에 있어야 합니다.\n\n또 다른 해결책은 \"몬테 칼로\"와 비슷한 접근 방식일 수 있습니다. n개의 경로를 생성하고, 각각의 작업을 계산한 다음 어떤 최상의 하위 집합을 선택하고, 각 하위 집합에 대해 비슷한 경로 집합을 생성합니다. 반복 횟수는 사용자에 달려 있으며, 얼마나 정확한 결과가 필요한지에 따라 다릅니다. 벡터 필드가 연속적일 것이고 해당 필드의 어떤 측정도 마찬가지로 연속적일 것이므로, 우리 비행용으로는 꽤 좋은 후보를 선정할 수 있어야 합니다. 마지막 문장은 매우 가정적이지만, 바람이나 어떤 자연 현상에 관한 이야기라면, 같은 지역 내에서 비용이 많이 드는 경로들이 많은 지역이 아니라 특별한 계곡이 있는 것이 상식적으로 보이지 않습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_6.png\" /\u003e\n\n# 미래 계획\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초반에는 포아송 방정식에 관한 글을 작성하려 했지만 결국 시각화 작업이 예상보다 더 오랜 시간이 걸렸고 중간에 더 많은 기능을 추가하기도 했어요. 그래도 어쨌든 결과적으로 이런 식으로 끝나서 기뻐요. 이런 작은 작업조차 흥미로운 부분이 많거든요. GitHub에서 실시간 데모와 소스 코드를 확인할 수 있어요. 해당 프로젝트 관련 모든 것은 webgl2 폴더에 있어요. 아직 몇 가지 부분을 더 최적화하고 싶어해요 (노이즈 계산/경로 비용 속도 향상, 더 나은 궤도 카메라, 드로우 호출 감소 (인스턴스 어레이, 중복된 유니폼 제거) 등). 현재로서는 데스크탑/노트북에서의 사용이 선호돼요.\n\n다음 블로그 글에서는 신경망과 포아송 방정식에 관한 몇 가지 아이디어를 소개하고 WebGL에서 WebGPU로 전환하고 싶어해요. 이번에는 데스크탑 애플리케이션으로 개발할 거라 C++ 또는 Rust를 사용할 거에요. 그 중에서 Rust가 더 재미있어 보이네요. 시간 내 주셔서 감사합니다. 자유롭게 의겢거나 댓글을 남겨주세요. 그리고 제 LaTeX 기술이 녹슨 것 같아서 LaTeX OG들에게 일으킨 피해에 대해 정말 죄송해요.","ogImage":{"url":"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png"},"coverImage":"/assets/img/2024-05-18-VectorFieldsandFuelConsumptionWrappedin3D_0.png","tag":["Tech"],"readingTime":11},{"title":"nightwatch-api v301에서 playwright로 이주를 고려해야 하는 이유","description":"","date":"2024-05-18 21:51","slug":"2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright","content":"\n\nNightwatch.js v1.7은 JavaScript를 위해 고안된 것이기 때문에 TypeScript을 지원했습니다. Igor Bari가 nightwatch-api를 만들어 TypeScript을 지원했습니다. Igor Bari에게 nightwatch-api를 만들어주어서 정말 감사해야 합니다. Nightwatch.js v1.7 npm 패키지는 TypeScript 개발자들이 Nightwatch.js v1.7을 편리하게 제어할 수 있도록 제공했습니다.\n\n## nightwatch-api와 Nightwatch.js v1.7의 관계는 무엇인가요?\n\nnightwatch-api는 TypeScript를 지원하기 위해 만들어진 래퍼이며 Nightwatch.js v1.7과 관련이 있습니다.\n\n## Nightwatch.js v1.7의 인기는 어떤가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 개발자들이 Nightwatch.js 프로젝트에서 nightwatch-api npm 패키지를 사용해 왔습니다. 여전히 매주 다운로드되고 있어요.\n\n![이미지](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png)\n\n# Nightwatch.js v2.0 릴리스 이후 어떤 일이 있었나요?\n\nNightwatch.js v2.0 릴리스부터는 Cucumber.js를 지원합니다. Nightwatch 엔지니어링 블로그에서 Nightwatch로 Cucumber 테스트를 실행하는 데 관한 상세한 블로그 포스트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2022년 3월 16일에 Igor Bari가 경고 메시지를 포함하여 README.md를 업데이트했습니다.\n\n![이미지](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_1.png)\n\n# Nightwatch v1.x에서 Nightwatch v2.x로의 이주는 무엇이 발생했나요?\n\nNightwatch.js는 v1.x에서 v2.x로의 마이그레이션을 돕기위한 마이그레이션 가이드를 만들었습니다. 그러나 이 가이드는 nightwatch-api npm 패키지 사용자에게 도움이 되지 않습니다. Nightwatch.js는 JavaScript를 사용할 때만 cucumber.js를 지원하기 때문에 TypeScript 사용자는 마이그레이션에서 제외됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 다음 단계는 무엇이 있을까요?\n\n- 누군가가 nightwatch-api 프로젝트를 포크하고 Nightwatch.js v2.0을 지원하도록 만들어야합니다.\n답변: 아직 누구도 프로젝트를 포크하지 않았습니다. 포크를 확인했는데 https://github.com/mucsi96/nightwatch-api/forks?include=active\u0026page=1\u0026period=\u0026sort_by=stargazer_counts Nightwatch.js v2.0이상을 지원하기 위해 작업한 프로젝트를 찾지 못했습니다.\n- cucumber.js를 사용하고 TypeScript로 테스트를 작성할 수 있는 다른 테스팅 프레임워크로 이동하십시오. 또한 새로운 테스팅 프레임워크로의 이전을 지원하기 위해 Nightwatch.js v1.7의 다양한 기능을 지원해야합니다.\n답변: Nightwatch.js와 주요 두 가지 테스팅 프레임워크를 비교할 수 있는 방법을 확인해보실 수 있습니다. Nightwatch.js에서 제공한 것으로 두 테스팅 프레임워크 중 어떤 것이 좋은 대안이 될지 보여주었습니다.\n\n# nightwatch-api v3.0.1에서 playwright로 이주를 고려해야 하는 이유\n\n내 관점으로 볼 때, Nightwatch.js 및 주요 두 가지 테스팅 프레임워크를 읽은 후, playwright가 좋은 대안이 될 것으로 판단했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_2.png)\n\n고려 사항\n\n- 테스트 시작 전에 AUT를 실행할 수 있는 지원. 사용자가 특정 포트에서 테스트 시작 전에 AUT를 시작할 수 있습니다.\n- Visual Studio Code와 확장 프로그램 형태로 통합되어 있습니다.\n- 다양한 언어 지원 - Javascript, Typescript, Java, Python, .NET.\n\n나는 이러한 세 가지 고려 사항으로 Nightwatch.js v1.7에서 Playwright로 테스트를 이전하려고 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 글을 좋아하신다면, 제 Medium 팔로우하기를 눌러주세요. 또한 YouTube에서 제 영상을 시청하실 수도 있고, 커피 한 잔 사주는 걸로도 저를 응원할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png"},"coverImage":"/assets/img/2024-05-18-AutomationTestingWhyyouneedtoconsidermigratingfromnightwatch-apiv301toplaywright_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러에서 NgRx를 활용한 상태 관리하는 방법","description":"","date":"2024-05-18 21:49","slug":"2024-05-18-StatemanagementwithNgRxinAngular","content":"\n\n\n![스크린샷](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png)\n\n현대의 프론트엔드 애플리케이션은 주로 컴포넌트 개념을 사용합니다. 이는 사용자 인터페이스의 독립적이고 재사용 가능하며 자체적인 부분을 나타냅니다. Angular, React, Vue.js와 같은 인기 있는 프론트엔드 라이브러리들에서 이 개념은 중요합니다. 다수의 컴포넌트가 동일한 데이터를 필요로 할 때 간편함과 여러 이점을 제공하지만 문제도 발생할 수 있습니다. 이 문제를 해결하기 위해 Redux 패턴이라는 개념이 있습니다. Redux 라이브러리는 처음에 React 생태계에서 인기를 얻었지만 Angular나 Vue.js와 같은 다른 프레임워크에서도 사용할 수 있습니다. 이 글에서는 NgRx 라이브러리를 사용한 상태 관리에 집중하겠습니다. Angular에서는 Redux를 사용할 수 있지만, Angular에 특별히 제작된 인기 있는 상태 관리 라이브러리인 NgRx를 사용하는 애플리케이션을 자주 볼 수 있습니다.\n\n## NgRx란?\n\n소개에서 언급한 대로, NgRx는 Redux에 영감을 받은 상태 관리를 위한 라이브러리입니다. Angular용 Redux 원칙을 구현하여 애플리케이션 상태를 예측 가능하고 구조적인 방식으로 관리합니다. NgRx는 액션, 리듀서, 이펙트, 셀렉터와 같은 개념을 사용하여 상태를 조작하는데 있어 가시적인 방식을 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_1.png\" /\u003e\n\n## 저장소\n\n\"저장소\"는 불변 데이터 구조로 구현된 상태 관리자의 일부입니다. 다시 말하면, 그 안에 포함된 데이터는 직접 변경할 수 없습니다. 따라서 모든 상태 변경은 작업을 통해 이루어져야 합니다. 이러한 작업은 '리듀서'라고 불리는 메커니즘을 통해 상태에서 변경될 내용을 정의합니다. 이 함수는 상태와의 통신을 처리합니다.\n\n## 리듀서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리듀서의 책임은 스토어의 상태를 변경할 필요가 있는 모든 작업을 처리하는 것입니다. 현재 상태와 액션을 입력으로 받아 변경 후의 새로운 상태를 반환합니다.\n\n## 액션\n\n\"액션\"은 단순히 상태 변경을 나타내는 객체들입니다. 상태를 변경할 정보를 포함한 액션은 스토어로 전송됩니다.\n\n## 셀렉터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"selectors\"는 저장된 상태의 특정 정보에 액세스하고 가져 오는 데 사용되는 기능입니다. 따라서 구성 요소가 상점의 완전한 상태를 직접 가져 오는 대신 필요한 데이터만 요청 할 수 있습니다. 이렇게하면 코드가 더 모듈식이고 재사용 가능하며 유지 보수가 쉬워집니다. 또한, 요청 한 구성 요소에 제공되기 전에 상태에서 calc 및 변환을 수행 할 수도 있습니다.\n\n## 효과\n\n\"효과\"는 비동기 작업이나 부작용, 즉 네트워크 요청, 데이터베이스 액세스, 외부 API 호출 또는 순수 동기가 아닌 작업과 같은 기능을 나타냅니다. 그러나이 기능을이 기사에서는 사용하지 않습니다. 곧이 주제에 특별히 전념 한 기사를 쓰는 것을 선호합니다.\n\n# 실제로 사용하는 NgRx\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 저장소에 있는 애플리케이션은 GitHub의 igormarti/angular-ngrx-shopping(https://github.com/) 링크에서 확인할 수 있어요. 클론하려면 확인해보세요. 하지만 이 개념을 처음부터 적용할 수도 있어요. 내 애플리케이션에서는 제품을 즐겨찾기에 추가하는 상태 관리자를 사용할 거에요. 우리 애플리케이션에는 스토어에서 즐겨찾기한 제품들을 요청할 몇 가지 구성 요소가 있을 거예요. 이후 단계에서 자세한 내용을 볼 수 있을 거에요. 코드 구현에 대해 한 가지 팁: 이 프로젝트의 코드 구현은 Angular 버전 16과 NgRx 버전 7.8.0을 사용해 만들어졌어요.\n\n# Angular에서 NgRx 설치\n\n프로젝트에서 NgRx를 설치하려면 루트 폴더에서 다음 명령을 실행하세요:\n\n```js\nnpm install @ngrx/store --save\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트에서 NgRx 구조화하기\n\nNgRx를 프로젝트에 설치한 후에는, 이제 구조를 만들어야 하는 때입니다. 다음 단계에서는 액션, 리듀서, 셀렉터 및 초기 상태를 만들 것입니다.\n\n먼저, 애플리케이션의 앱 폴더 내에서 \"states\"라는 폴더를 만들 것입니다. 이 폴더 안에 \"favorite-product\"라는 폴더를 만든 후, 그 안에 \"action\", \"reducer\", \"selector\"라는 세 개의 폴더를 만들 것입니다. 구조는 다음과 같습니다:\n\n```js\napp -\u003e\n  states -\u003e\n      favorite-product -\u003e\n                    action\n                    reducer\n                    selector\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 \"favorite-product\" 폴더 안에 \"app.state.ts\" 파일을 생성할 것입니다. 이 파일은 초기 상태의 모델이 될 것입니다:\n\n```js\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\nexport interface AppState {\n    products: FavoriteProduct[];\n}\n```\n\n우리의 \"AppState\" 인터페이스 안에 \"products\"라는 속성이 있음을 주목해주세요. 이는 초기 상태의 유형을 나타내는 배열 \"FavoriteProduct\"입니다. 따라서 우리는 이 인터페이스를 프로젝트에 만들어야 합니다. 저는 내 애플리케이션에서 \"src/app/models/favorite-product.model\" 경로에 만들었습니다. 그러나 원하는 곳에 넣으셔도 됩니다. 중요한 점은 \"app.state.ts\" 파일에서 올바르게 가져오는 것입니다.\n\n```js\nexport interface FavoriteProduct {\n    id: number;\n    name: string;\n    price: number;\n    image: string;\n    isFavorite?: boolean;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업 생성하기\n\n이 단계에서는 \"src\\app\\states\\favorite-product\\action\" 폴더 안에 작업을 만들 것입니다. 우리의 파일은 \"app.action.ts\"로 명명될 것입니다. 이 파일에는 데이터 상태를 변경하는 모든 작업을 나타내는 함수들이 포함될 것입니다. 다음의 코드를 참조해주세요:\n\n```js\nimport { createAction, props } from '@ngrx/store';\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\nexport const add = createAction('[FavoriteProduct] Add',  props\u003c{ product: FavoriteProduct }\u003e());\nexport const remove = createAction('[FavoriteProduct] Remove', props\u003c{ product: FavoriteProduct }\u003e());\nexport const updateAllState = createAction('[FavoriteProduct] Update all state of favorites products', \n props\u003c{ products: FavoriteProduct[] }\u003e());\nexport const clear = createAction('[FavoriteProduct] Clear');\n```\n\n위 코드에서는 \"@ngrx/store\" 모듈의 \"createAction\" 함수가 작업 설명을 첫 번째 매개변수로서, 처리할 데이터를 두 번째 매개변수로 가지는 것을 알 수 있습니다. 우리의 \"favorite-product\" 상태에는 다음과 같은 작업들이 있을 것입니다: add, remove, updateAllState, clear.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 리듀서 생성하기\n\n우리는 \"src\\app\\states\\favorite-product\\reducer\" 폴더에 \"app.reducer.ts\" 파일을 만들어야 합니다. 이 파일에서는 즐겨찾는 제품 목록의 초기 상태를 초기화하고 각 작업에 대한 비즈니스 로직을 구현한 다음 상태를 업데이트하기 전에 상태를 변경합니다. 자세한 내용은 다음 코드를 참조해주세요:\n\n```js\nimport { createReducer, on } from '@ngrx/store';\nimport { add, remove, clear, updateAllState } from '../action/app.action';\nimport { AppState } from '../app.state';\n\nexport const initialState: AppState = {\n  products:[],\n};\n\nexport const favoriteReducer = createReducer(\n  initialState,\n  on(add, (state, {product}) =\u003e (\n    {\n      ...state,\n      products: [...state.products, product]\n    }\n  )\n  ),\n  on(remove, (state, {product}) =\u003e ({\n    ...state,\n    products: state.products.filter((p)=\u003e product.id != p.id)\n  })),\n  on(updateAllState, (state, {products}) =\u003e (\n    {\n      ...state,\n      products\n    }\n  )\n  ),\n  on(clear, state =\u003e initialState)\n);\n```\n\n먼저 초기 상태가 빈 즐겨찾는 제품 배열로 초기화되는 것을 알아봅니다. 그다음, \"@ngrx/store\" 모듈에서 \"createReducer\" 함수가 초기 상태와 여러 \"on\" 함수를 받아 작업을 상태 변경과 연결하고 있음을 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- \"add\" 액션은 현재 상태에 새 제품을 추가합니다.\n- 마찬가지로, \"remove\" 액션은 현재 상태에서 특정 제품을 제거합니다.\n- \"updateAllState\" 액션은 매개변수로 받은 제품 목록으로 상태를 업데이트합니다.\n- 마지막으로 중요하지만 더욱 중요한 것은, \"clear\" 액션은 초기 상태로 설정하여 상태를 재설정하며, 저장소에서 모든 즐겨찾는 제품을 모두 지우게 됩니다.\n\n## 셀렉터 생성하기\n\n이제 저장소에서 데이터를 검색하려면 셀렉터를 생성해야 합니다. 이를 위해 'src\\app\\states\\favorite-product\\selector' 폴더에 'app.selector.ts' 파일을 만들어야 합니다. 자세한 내용은 다음 코드를 참조해주십시오:\n\n```js\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\nimport { AppState } from '../app.state';\nimport { FavoriteProduct } from \"src/app/models/favorite-product.model\";\n\n// 애플리케이션 내에서 즐겨찾는 제품의 전체 상태를 가져옵니다.\nexport const selectAppState = createFeatureSelector\u003cAppState\u003e('favorite');\n\n// 모든 즐겨찾는 제품 가져오기\nexport const selectProducts = createSelector(\n  selectAppState,\n  (state: AppState) =\u003e state.products\n);\n\n// ID로 하나의 즐겨찾는 제품 가져오기\nexport const selectProductById = createSelector(\n  selectProducts,\n  (products: FavoriteProduct[], props: { productId: number }) =\u003e\n    products.find(product =\u003e product.id === props.productId)\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 함수에서는 'favorite' 스토리지에서 전체 상태를 얻고 있습니다. 두 번째 함수에서는 이 완전한 상태를 사용하여 즐겨찾는 상품만 검색합니다. 마지막 함수는 즐겨찾는 상품의 상태를 활용하여 해당 ID의 특정 상품을 가져옵니다. 우리는 이러한 모든 함수를 애플리케이션에서 필요한 데이터를 검색하는 데 사용할 수 있습니다.\n\n우리의 폴더 구조는 다음과 같이 구성되어 있습니다:\n\n![폴더 구조](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_2.png)\n\n상태 관리를 사용하기 전에 StoreModule을 모듈에 가져와 reducer를 포함해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { NgModule } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { StoreModule } from '@ngrx/store';\nimport { favoriteReducer } from './states/favorite-product/reducer/app.reducer';\n\n@NgModule({\n  declarations: [\n\n  ],\n  imports: [\n    StoreModule.forRoot({favorite:favoriteReducer})...\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n## 액션 사용하기\n\n상태에서 액션을 사용하려면 먼저 \"@ngrx/store\" 모듈에서 \"Store\"를 가져와서 생성자에 포함해야 합니다. 다음은 예시입니다:\n\n```js\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-home-product',\n  templateUrl: './home-product.component.html',\n  styleUrls: ['./home-product.component.scss']\n})\nexport class HomeProductComponent{\n\nconstructor(private readonly storageService:StorageService\u003cFavoriteProduct[]\u003e){}\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'store'을 import한 후에는 이제 액션을 사용할 수 있습니다. 우리 애플리케이션에서는 특정 제품의 하트 아이콘을 클릭할 때마다 해당 제품을 즐겨찾기에 추가합니다. 아래 이미지에서 'Notebook' 제품이 즐겨찾기 목록에 추가되었음을 보실 수 있습니다. 또한, 오른쪽 상단에 있는 하트 아이콘에 주목해주세요. 이 아이콘은 즐겨찾기에 추가된 항목 수를 나타내는데, 이 경우에는 '1'이 표시됩니다.\n\n![image](/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_3.png)\n\n따라서 즐겨찾기 아이콘을 클릭할 때마다 'dispatch' 함수가 트리거되며, 원하는 액션을 매개변수로 전달합니다. 이 경우에는 액션이 'add'가 됩니다. 아래 코드를 확인해주세요:\n\n```js\n\u003cmat-icon [style.color]=\"product.isFavorite?'red':'black'\" class=\"mat-icon-lg icon\" \n(click)=\"addProductToFavorites(product)\" \u003efavorite\u003c/mat-icon\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-home-product',\n  templateUrl: './home-product.component.html',\n  styleUrls: ['./home-product.component.scss']\n})\nexport class HomeProductComponent {\n\n  constructor(private readonly storageService:StorageService\u003cFavoriteProduct[]\u003e) {}\n\n  addProductToFavorites(product: FavoriteProduct) {\n    const favoriteProduct: FavoriteProduct = {\n      ...product,\n      isFavorite: true\n    }\n    this.store.dispatch(add({ product }));\n  }\n\n}\n```\n\n그래서, 'dispatch' 함수를 트리거할 때마다 클릭한 제품이 '리듀서'로 전송되는데, 이는 데이터를 처리하고 상태에 저장하기 전에 책임이 있습니다.\n\n## 셀렉터 사용하기\n\n셀렉터를 사용하기 위해서는 '@ngrx/store' 모듈에서 'Store'를 가져와야 합니다. 그러나 셀렉터를 사용하여 데이터를 검색하는 데 사용되는 함수는 'pipe'입니다. 다음 코드에서 자세한 내용을 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { FavoriteProduct } from 'src/app/models/favorite-product.model';\nimport { Store, select } from '@ngrx/store';\nimport { AppState } from 'src/app/states/favorite-product/app.state';\nimport { selectProducts } from 'src/app/states/favorite-product/selector/app.selector';\n\n@Component({\n  selector: 'app-header',\n  templateUrl: './header.component.html',\n  styleUrls: ['./header.component.scss']\n})\nexport class HeaderComponent {\n\n  favoritesProducts: Observable\u003cArray\u003cFavoriteProduct\u003e\u003e = this.store.pipe(select(selectProducts))\n\n  constructor(private router: Router, private store: Store\u003cAppState\u003e) { }\n\n}\n```\n\n'pipe' 안에 있는 코드를 볼 때 'select' 함수를 사용하고 있습니다. 이 함수는 '@ngrx/store' 모듈에서 가져온 것으로, 셀렉터를 파라미터로 받습니다. 현재 셀렉터는 'selectProducts'이며 'FavoriteProduct' 배열의 'Observable'을 반환합니다. 이 목록은 속성에 저장되어 템플릿에서 사용되어 즐겨찾기 제품의 수량을 표시합니다. 아래 템플릿 코드에서 더 자세한 내용을 확인할 수 있습니다:\n\n```js\n\u003cmat-icon [style.color]=\"'red'\" \nmatBadge=\"{(favoritesProducts | async)?.length}\" \nmatBadgePosition=\"above after\"\u003efavorite\u003c/mat-icon\u003e\n```\n\n템플릿에서 'async' 파이프를 사용해 TypeScript에서 옵저버블로 받은 데이터를 처리합니다. 그리고 'length' 속성을 이용하여 목록에 있는 항목 수를 얻습니다. 더 자세한 코드는 제 GitHub 리포지토리에서 확인할 수 있습니다. 아래 링크에 접속해주세요: igormarti/angular-ngrx-shopping (github.com)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAngular 애플리케이션에서 상태 관리는 매우 중요한 요소입니다. 특히 특정 상태가 복잡해지는 경우가 많습니다. Angular의 인기 있는 상태 관리 라이브러리인 NgRx는 애플리케이션 상태를 중앙에서 예측 가능하게 효율적으로 관리할 수 있는 견고하고 확장 가능한 솔루션을 제공합니다. 액션, 리듀서, 셀렉터 등의 개념을 활용해 NgRx를 사용하면 개발자들이 상태 변경을 효율적으로 처리하고 관심사를 명확히 분리할 수 있습니다. NgRx를 사용하면 유지보수성이 높고 테스트 가능하며 확장 가능한 Angular 애플리케이션을 만들 수 있어서 복잡한 상태 관련 도전 과제를 관리하는 강력한 도구로 작용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png"},"coverImage":"/assets/img/2024-05-18-StatemanagementwithNgRxinAngular_0.png","tag":["Tech"],"readingTime":11},{"title":"TypeScript 53에 새로 추가된 내용 정리","description":"","date":"2024-05-18 21:47","slug":"2024-05-18-WhatsFreshinTypeScript53LetsDiveIn","content":"\n\n\n![2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0](/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png)\n\n자바스크립트로 작업 중인 상황을 상상해보세요. 이 언어는 유연하지만 때로는 까다로운 면이 있습니다.\n\n타입스크립트는 코드를 실행하기 전에 실수를 잡아주는 일종의 보조 역할을 하는데요.\n\n변수와 함수와 같은 요소들의 타입을 명시하는 방법을 추가함으로써 이를 수행합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니까, 흔한 오류를 미리 방지하는 데 넘어서 TypeScript는 테이블에 몇 가지 멋진 기능을 가져다 줍니다. 이것을 한 마디로 말하면, 오타를 만들 것 같을 때나 특정 사항을 확인을 잊었을 때 지적해주는 스마트한 친구가 있다고 생각해보세요. 하나 더, 코드를 작성하는 동안 당신을 도와주기도 합니다.\n\nVisual Studio 또는 VS Code를 사용해 본 적이 있다면, 자동 완성, 코드 탐색, 코드를 더 깔끔하게 만드는 매력적인 부분이 TypeScript가 뒷담화로 작동하고 있다는 거죠.\n\n호기심이 생겼고 TypeScript를 한 번 시도해 보고 싶다면, TypeScript를 사용하는 방법은 다음과 같습니다:\n\nTypeScript를 시작해 보려면 NuGet을 사용하여 가져올 수 있고, npm 세계에 더 익숙하다면 다음 명령어를 입력해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install -D typescript\n```\n\n# Import 속성\n\nTypeScript 5.3에서 새로 추가된 멋진 기능 중 하나는 import 속성입니다. 이것들은 런타임에 가져온 항목들을 다루는 방법에 대한 특정 세부사항을 알려주는 작은 태그 같은 역할을 합니다.\n\n예를 들어, JSON 파일을 가져올 때 이것이 JSON으로 처리되고 실행 가능한 JavaScript로 처리되지 않도록 하려면 다음과 같이 할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport obj from \"./something.json\" with { type: \"json\" };\n```\n\n이러한 속성은 TypeScript 자체에서 확인되지 않습니다. 대신 브라우저나 런타임이 따를 주석과 같습니다. 따라서 자유롭게 사용할 수 있지만, 무의미한 유형을 사용하여 브라우저를 혼란스럽게 하지 않도록 주의하십시오:\n\n```js\nimport * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };\n```\n\n동적 임포트인 import()로 만든 임포트도 이러한 임포트 속성을 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nconst obj = await import(\"./something.json\", {\n    with: { type: \"json\" }\n});\n```\n\n재밌는 점은 TypeScript가 예전 기능인 \"import assertions\"에서 이 새로운 import 속성으로 이동하고 있다는 것입니다.\n\n이제 더 이상 assert 키워드를 사용하는 대신 with를 사용합니다. 이전 코드에 assert가 있는 경우, 새로운 문법인 with를 사용하도록 업데이트하는 것이 권장됩니다.\n\n# Import 타입에서 버그 수정된 해상도 모드 안정성 지원\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재는 Markdown 형식을 사용하고 있는 것 같네요. 예를 들어, 코드에서 타입 가져오기를 기존 require처럼 처리하거나 현대적인 import처럼 처리할지 결정할 때 사용하는 설정과 비슷한 거죠.\n\n코드에서 타입 가져오기를 예전 방식인 require()처럼 처리하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\nimport type { TypeFromRequire } from \"pkg\" with {\n    \"resolution-mode\": \"require\"\n};\n```\n\n그리고 새로운 import 방식을 선호한다면, 이렇게 할 수도 있죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport type { TypeFromImport } from \"pkg\" with {\n    \"resolution-mode\": \"import\"\n};\n```\n\n하지만 여기에 멋진 부분이 있어요. 이 기능은 처음에 import 어써션에 사용할 수 없었는데요, 이는 모듈이 어떻게 처리되어야 하는지에 대한 힌트 같은 것입니다.\n\n지금은 TypeScript 5.3에서 이 \"resolution-mode\" 속성을 import 타입에도 확장했습니다. 따라서, 이제 일반적인 import뿐만 아니라 import()를 사용하여 동적으로 타입을 끌어올 때에도 사용할 수 있어요.\n\n여기에 더 실용적인 예시가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport type TypeFromRequire =\n    import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;\n\nexport type TypeFromImport =\n    import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;\n\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n```\n\n# resolution-mode All Module Modes에서 지원됩니다.\n\n과거에는 node16 및 nodenext와 같은 특정 moduleResolution 옵션에서만 resolution-mode 마법을 사용할 수 있었습니다.\n\n하지만 생각해보세요! TypeScript 5.3가 삶을 더 간단하게 만들어줍니다. 이제 bundler, node10 및 심지어 classic와 같은 모든 다른 moduleResolution 옵션과 함께 resolution-mode를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더는 당신이 타입을 다루는 방식을 조정하고 싶어서 발생하는 오류가 더 이상 나타나지 않는다.\n\n TypeScript는 여러분이 원하는 모듈 모드에서 자유롭게 작업할 수 있도록 더 널널해졌어요. 멋지죠?\n\n# switch (true) 좁히기\n\n이제 true로 설정된 switch 문을 다룰 때, TypeScript가 각 case의 조건에 따라 타입을 똑똑하게 좁힐 수 있어요. 자세히 설명해 드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이런 함수가 있다고 하자:\n\n```js\nfunction f(x: unknown) {\n    switch (true) {\n        case typeof x === \"string\":\n            // 'x'은 여기서 'string'입니다.\n            console.log(x.toUpperCase());\n            // 계속 진행...\n\n        case Array.isArray(x):\n            // 'x'는 여기서 'string | any[]' 입니다.\n            console.log(x.length);\n            // 계속 진행...\n\n        default:\n            // 'x'는 여기서 'unknown'입니다.\n            // ...\n    }\n}\n```\n\n여기서 하는 일은, 각 case의 조건에 따라 TypeScript가 'x'의 유형을 더 수월하게 파악하는 것입니다.\n\n예를 들어, 'x'가 문자열이면, 그것을 알고 있으며, toUpperCase()와 같은 문자열 관련 작업을 수행할 수 있습니다. 배열인 경우에도 이해합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 불리언에 대한 비교 좁히기\n\n당신이 직접적으로 true 또는 false와 비교를 할 때를 말해요. 스타일적 이유이거나 JavaScript의 특징을 처리하기 위해서 명시적으로 무언가가 true인지 false인지 확인할 때 그렇습니다.\n\n이전에 TypeScript는 이러한 비교를 인지하지 못했지만, 이제는 도와줄 준비가 되어 있어요. 한 예제로 보여드릴게요:\n\n```js\ninterface A {\n    a: string;\n}\n\ninterface B {\n    b: string;\n}\n\ntype MyType = A | B;\n\nfunction isA(x: MyType): x is A {\n    return \"a\" in x;\n}\n\nfunction someFn(x: MyType) {\n    if (isA(x) === true) {\n        console.log(x.a); // TypeScript가 이해했어요!\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래, isA(x) === true를 보셨나요? TypeScript가 그것을 이해하고 if 블록 내에서 타입을 더 좁게 인식할 수 있게 되었습니다.\n\n그래서 TypeScript가 불평하지 않고도 console.log(x.a)와 같은 작업을 자신 있게 수행할 수 있습니다.\n\n# Symbol.hasInstance를 통한 좁히기\n\ninstanceof를 사용할 때, [Symbol.hasInstance]로 정의된 메서드를 고려하여 더 똑똑해졌습니다. 이는 사용자 정의 타입 가드를 사용하여 타입을 더 정확하게 좁힐 수 있게 되었다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 통해 설명해 드리겠습니다:\n\nPoint라는 클래스가 있다고 상상해 보세요. 이제 TypeScript를 사용하여 [Symbol.hasInstance]를 사용하여 해당 클래스에 특별한 메서드를 정의할 수 있습니다. 이 메서드에서는 Point와 유사한지를 확인하기 위한 사용자 지정 로직을 구현할 수 있습니다.\n\n```js\nclass Point {\n    static [Symbol.hasInstance](val: unknown): val is PointLike {\n        // 여기에 사용자 정의 타입 가드 로직을 넣으세요\n    }\n}\n```\n\n그런 다음 코드에서 instanceof를 사용할 때 TypeScript는 사용자 정의 타입 가드를 인식하고 활용할 수 있습니다. 예를 들면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\nfunction f(value: unknown) {\n    if (value instanceof Point) {\n        // Now, you can access properties defined in PointLike,\n        // but you won't have access to specific Point methods or properties.\n    }\n}\n```\n\n그래서 이 기능은 기본적으로 TypeScript가 사용자 정의 유형 확인을 정말 이해하고 유형을 더 정확하게 좁힐 수 있도록 합니다.\n\n# 인스턴스 필드에서 수퍼 속성 액세스를 위한 검사\n\n클래스를 다룰 때 기반 클래스에서 메서드에 접근하기 위해 super 키워드를 사용할 수 있습니다. 이것은 \"이 클래스에서 상속 받은 클래스로부터 메서드를 가져오게 해줘\"라는 방식입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어:\n\n```js\nclass Base {\n    someMethod() {\n        console.log(\"베이스 메서드 호출됨!\");\n    }\n}\n\nclass Derived extends Base {\n    someMethod() {\n        console.log(\"파생 메서드 호출됨!\");\n        super.someMethod();\n    }\n}\n\nnew Derived().someMethod();\n// 출력:\n//   파생 메서드 호출됨!\n//   베이스 메서드 호출됨!\n```\n\n따라서 super.someMethod()은 베이스 클래스에서 메서드를 특별히 얻는 방법임을 알 수 있습니다.\n\n이제 여기가 tricky한 부분입니다. 클래스 필드(전체의 속성)를 다룬다면, 동일한 방식으로 super를 사용하는 것이 예상대로 작동하지 않을 수 있습니다. TypeScript 5.3는 이를 잘 파악하여 경고를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 예시가 있어요:\n\n```js\nclass Base {\n    someMethod = () =\u003e {\n        console.log(\"someMethod called!\");\n    }\n}\n\nclass Derived extends Base {\n    someOtherMethod() {\n        super.someMethod(); // 이제 오류가 발생할 거예요!\n    }\n}\n\nnew Derived().someOtherMethod();\n// 💥\n// 'super.someMethod'이 'undefined'이기 때문에 작동하지 않아요.\n```\n\n그래서 TypeScript 5.3은 super를 사용하여 무언가에 접근할 때 그것이 클래스 필드인지 확인해요. 그게 맞다면, super를 통해 접근하려고 하면 TypeScript가 런타임 오류에 부딪히기 전에 멈춰줄 거예요. 코드에 잠입하는 교묘한 버그를 막기 위해 친구가 코드를 한 번 더 확인해주는 것 같죠!\n\n# 자동 Imports 유형을 선호하는 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자동으로 타입에 대한 import를 추가할 때, 이전에는 사용자 설정을 기반으로 했습니다. 예를 들어, Person이라는 타입이 있는 경우:\n\n```js\nexport let p: Person;\n```\n\nTypeScript는 보통 다음과 같이 import를 추가했을 것입니다:\n\n```js\nimport { Person } from \"./types\";\n\nexport let p: Person;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 설정에 따라 다를 수 있습니다. 예를 들어, verbatimModuleSyntax와 같은 특정 설정이 있는 경우에는 type 수정자를 추가할 수도 있습니다:\n\n```js\nimport { type Person } from \"./types\";\n\nexport let p: Person;\n```\n\n이제 TypeScript는 더 많은 제어권을 제공합니다. 특정한 선호도가 있거나 코드베이스에서 특정 옵션을 사용할 수 없는 경우, 가능한 경우에는 항상 명시적인 타입 가져오기를 설정할 수 있습니다. 이는 \"안녕 TypeScript, 이렇게 해 달라고 말했어, 깜짝 놀라지 말고\"라고 말하는 것과 같습니다. 그래서 TypeScript를 자신이 원하는 방식으로 작동하도록 만드는 것입니다.\n\n# TypeScript 5.3에서 몇 가지 최적화가 소개되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, JSDoc 파싱을 스킵하고 있습니다. 이는 TypeScript가 JSDoc에 불필요한 시간과 메모리를 소비하지 않아 컴파일 속도를 높일 수 있음을 의미합니다.\n\n특히 변경 사항이 빈번한 감시 모드에서 이 점이 특히 두드러집니다. 게다가, 이 개선은 TypeScript 자체뿐만 아니라 typescript-eslint와 Prettier와 같은 도구들도 이 속도 및 메모리 향상으로 이점을 얻을 수 있습니다.\n\n또한, TypeScript가 교차(intersections)를 처리하는 방식에 최적화가 있습니다. 이는 TypeScript가 유니언과 교차에서 특히 타입을 비교하는 데 능숙해지고 있는 것과 같습니다.\n\n원본 교차형식을 살펴보면, 이제 더 빠르게 확인할 수 있어 타입 평가가 더 효율적으로 이루어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 TypeScript는 tsserverlibrary.js 및 typescript.js 라이브러리 파일을 합치면서 봄철처럼 청소를 하고 있어요.\n\n중복을 줄이고 일관성을 높이기 위해 이들을 결합하고 있습니다.\n\n이렇게 하면 API 사용이 보다 간소화되며 자원 사용량이 감소하는데 도움이 됩니다. 모든 것이 제 자리에 있고 원활하게 작동되도록 집을 정리하는 것과 같아요.\n\n자세한 변경 사항에 대한 내용은 여기에서 확인할 수 있는 완전한 릴리스 로그를 참조해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 Medium 페이지와 연결해 보세요! ✍ : https://medium.com/@Evelyn.Taylor","ogImage":{"url":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png"},"coverImage":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png","tag":["Tech"],"readingTime":9},{"title":"Cars24 SDE-2 Frontend 면접 경험","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-Cars24SDE-2FrontendInterviewExperience","content":"\n\n나는 링크드인에서 리쿠루터에게 연락했다.\n\n# 1차 면접 — JS\n\n질문 1 — 클로저란 무엇이며 예시와 함께 설명해보세요.\n\n```js\nfunction closure() {\n    let count = 0;\n    return function test() {\n        count++;\n        return count;\n    }\n}\n\nconst closuredTest = closure();\n\nconsole.log(closuredTest());\nconsole.log(closuredTest());\nconsole.log(closuredTest());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2번 문제 - 커리(curry)란 무엇이며 주어진 함수의 커리 고차 함수를 만드세요.\n\n```js\nfunction sum(a, b, c){\n  return a + b + c; \n}\n```\n\n```js\nfunction curry(fn){\n  return function curriedFn(...params){\n    if(params.length \u003e= fn.length){\n      return fn(...params);\n    }\n    else{\n      return function(...next){\n        return curriedFn(...params,...next);\n      }\n    }\n  }\n}\n\nlet curriedSum = curry(sum);\n\nconsole.log(curriedSum(1, 2, 3));   // 6, 일반적으로 호출 가능\nconsole.log(curriedSum(1)(2,3));    // 6, 첫 번째 인수 커리\nconsole.log(curriedSum(1)(2)(3));   // 6, 완전한 커리\n```\n\n3번 문제 - Task Queue(작업 큐) 및 이벤트 루프에 대해 설명해보세요.\n먼저 구두로 설명한 후 코드 스니펫을 작성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## question4 — output based question\n\n```js\nasync function async1() {\n    console.log(\"async1 start\");\n    const data = await async2();\n    console.log(data);\n    console.log(\"async1 end\");\n}\n\nasync function async2() {\n    console.log(\"async2\");\n    return \"async2 completed\";\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function () {\n    console.log(\"setTimeout\");\n}, 0);\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log(\"promise1\");\n    resolve();\n}).then(function () {\n    console.log(\"promise2\");\n});\n\nconsole.log(\"script end\");\n```\n\nquestion 5 — explain this keyword and how can we change it forcefully\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nlet obj = {\n    name: 'prikshit',\n    myName(city, birthPlace) {\n        console.log(this.name + ' i live in ' + city + ' my birthplace is ' + birthPlace);\n    }\n}\n\nlet obj2 = {\n    name: 'sohail',\n}\n\n// obj.myName.call(obj2,'blr');\n// obj.myName.apply(obj2,['blr']);\n\nconst bindedFn = obj.myName.bind(obj2);\n\nbindedFn('blr', 'delhi');\n\nobj.myName(); // this keyword here is obj\n```\n\n## 2nd Round — Machine Coding\n\n1. **1st question** - 온라인/오프라인 상태를 보여주는 사용자 정의 훅을 만들어 보세요. (해결 사항)\n\n2. **2nd question** - 그리드 라이트를 만들어 보세요. (Uber 인터뷰어들의 즐겨하는 문제)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3차 라운드 — 기술 관리 라운드\n\n이번 라운드에서 면접관은 전자 상거래 필터 구성 요소를 만들어 달라고 했어요.","ogImage":{"url":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 ","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration","content":"\n\n\n\n![RAII Reimagined: Embracing Lifecycle Hooks](/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png)\n\n# RAII Reimagined: Embracing Lifecycle Hooks\n\nRAII은 객체 초기화 중에 리소스를 획득하고 파괴 시에 해제하는 것을 강조합니다. React Native에서는 컴포넌트 라이프사이클 훅이 RAII를 가능하게 합니다:\n\n```js\nimport React, { useEffect } from 'react';\nimport Geolocation from '@react-native-community/geolocation'; // 예시 리소스\n\nfunction LocationTracker() {\n  useEffect(() =\u003e {\n    const watchId = Geolocation.watchPosition(location =\u003e {\n      // ... 위치 데이터 처리\n    });\n\n    return () =\u003e {\n      Geolocation.clearWatch(watchId); // 언마운팅시 워치 해제\n    };\n  }, []); \n\n  // ... 컴포넌트 로직\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 조각에서:\n\n- useEffect는 컴포넌트가 마운트될 때 지리적 위치 감시를 설정합니다.\n- useEffect에서 반환된 정리 함수는 소멸자와 유사하게 동작하여 컴포넌트가 마운트 해제될 때 감시를 지워 리소스 누출을 방지합니다.\n\n# 스마트 포인터: TypeScript에서의 색다른 접근\n\nTypeScript에는 진정한 스마트 포인터가 없지만 클래스를 사용하여 그 본질을 모방할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass AudioPlayer {\n  private sound: Sound | null; \n\n  constructor(filePath: string) {\n    this.sound = new Sound(filePath, error =\u003e {\n      // ... handle potential errors\n    });\n  }\n\n  play() {\n    if (this.sound) this.sound.play();\n  }\n\n  release() { \n    if (this.sound) {\n      this.sound.release(); \n      this.sound = null;\n    }\n  }\n}\n```\n\n구성요소에서:\n\n```js\nuseEffect(() =\u003e {\n  const player = new AudioPlayer('path/to/sound.mp3');\n  // ...\n\n  return () =\u003e {\n    player.release(); // 청소스럽게 오디오 자원을 해제합니다\n  };\n}, []);\n```\n\nAudioPlayer 클래스는 Sound 객체를 캡슐화하고 제어된 접근을 제공합니다. release 메서드는 스마트 포인터의 소멸자를 흉내내어 적절한 정리를 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 신중한 참조: 원시 포인터 함정 피하기\n\n객체 참조를 부드러운 포인터처럼 취급하세요:\n\n- 구독 취소: 컴포넌트가 언마운트될 때 항상 이벤트 이밋터나 옵저버블 구독을 해제하세요.\n- 인터벌 비우기: clearInterval 및 clearTimeout를 꼼꼼히 사용하세요.\n- 순환 참조 해제: 가비지 컬렉션을 방해할 수 있는 순환 참조에 주의하세요.\n\n기본 이상으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라이브러리: RxJS (Observables)나 React Native AppState API와 같은 라이브러리를 고려하여 자원 관리를 효율적으로 처리합니다.\n- 커스텀 훅: 복잡한 자원 상호작용을 캡슐화하기 위해 커스텀 훅을 작성합니다.\n- 에러 처리: 자원 관리 전략에 정교한 에러 처리를 통합합니다.\n\nRAII 원칙을 적용하고 스마트 포인터에서 영감을 받아 React Native TypeScript 개발을 높여나갈 수 있습니다. 자원을 자신있게 관리하고 메모리 누수를 방지하며 시간이 지날수록 늘 튼튼한 애플리케이션을 구축하세요.","ogImage":{"url":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png","tag":["Tech"],"readingTime":3},{"title":"우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법","description":"","date":"2024-05-18 21:44","slug":"2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu","content":"\n\n웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.\n\n# 필수 사항\n\n시작하기 전에 다음 사항을 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Apache가 설치된 Ubuntu 서버\n- openssl 도구가 설치되어 있습니다.\n\n우선, 프론트엔드 폴더로 이동해주세요.\n\n### 단계 1: 디렉토리 생성\n\n인증서를 위한 디렉토리를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir certificates\ncd certificates\n```\n\n# 단계 2: 개인 키 생성\n\n```js\nopenssl genpkey -algorithm RSA -out private.key\n```\n\n- genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.\n- -algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.\n- -out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -\n\n```js\nopenssl genpkey -algorithm RSA -aes256 -out private.key\n```\n\n-aes256:\n\n- 이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.\n\n\nYou’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(당신의 IP를 Ip 자리에 넣으세요)\n\n- [req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.\n- distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.\n- req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.\n- prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.\n- [req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.\n- CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.\n- C = BD: 국가 속성으로 방글라데시를 나타냅니다.\n- ST = Dhaka: 주 속성으로 다카를 지정합니다.\n- L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.\n- O = Robist: 조직 속성으로 로비스트를 나타냅니다.\n- OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.\n- emailAddress = smazoomder@gmail.com: 인증서와 관련된 이메일 주소입니다.\n- [req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.\n- subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.\n\n## Subject Alternative Name (SAN)의 내용 :\n\n- Subject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.\n- Alternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SAN 사용 이유:\n\n- 다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.\n- 다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.\n- IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.\n- 와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.\n- 인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.\n\n요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.\n\n# 단계 4: 인증서 서명 요청(CSR) 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl req -new -key private.key -out certificate.csr -config san.conf\n```\n\nopenssl req:\n\n- 이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.\n\n-new:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.\n\n- -key private.key:\n\n- CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.\n\n- -out certificate.csr:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.\n\n- `config san.conf`:\n\n- 인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.\n\n# 단계 5: 자체 서명 인증서 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\nopenssl x509 -req -in certificate.csr -signkey private.key -out server.cert -days 365\n```\n\nopenssl x509:\n\n- X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.\n\n-req:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.\n\n- certificate.csr 파일 안에:\n\n- 서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.\n\n- signkey private.key:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.\n\n- server.cert에 저장됩니다:\n\n- 서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.\n\n- 365일 동안 유효합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.\n\n## X.509 인증서 소개\n\nX.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)\n- 일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.\n- 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.\n- 발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.\n- 유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.\n- 주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.\n- 주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.\n- 확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.\n- 인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.\n- 인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.\n\n# X.509 인증서의 목적:\n\n- 인증: 인증서 소지자의 신원을 확인합니다.\n- 암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.\n- 디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.\n- 키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.\n\n# SSL/TLS에서의 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.\n- X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.\n\n웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.\n\n# 단계 6: Apache 구성 업데이트\n\nApache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 가상 호스트 설정:\n\n- **`VirtualHost *:443`**: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.\n\n- **`ServerName localhost`**: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.\n\nDocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.\n\nSSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.\n\nSSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.\n\nSSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.\n\nServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.\n\n`Directory \"/var/www/html/your-project/backend/public\"`: 지정된 디렉토리에 대한 구성 블록을 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOptions All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.\n\nAllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.\n\nRequire all granted: 모든 사용자에게 액세스를 부여합니다.\n\n`/Directory`: 지정된 디렉토리에 대한 구성 블록을 종료합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`/VirtualHost` : VirtualHost 블록을 종료합니다.\n\n# 설정 목적:\n\n- 이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.\n- \"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.\n\n그런 다음 활성화하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo a2ensite your-site.conf\n```\n\n# 단계 7: 아파치 재시작\n\n```js\nsudo systemctl restart apache2\n```\n\nSSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: Apache 오류 로그 확인\n\n```bash\nsudo tail -f /var/log/apache2/error.log\n```\n\nSSL과 관련된 오류 메시지를 확인해 보세요.\n\n# 단계 9: 라라벨 저장소 권한 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n이제 https://192.168.0.88 (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.\n\n# 단계 10: React/Laravel 애플리케이션을 실행 중이라면\n\n프론트엔드 환경에서:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nREACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false\n\nREACT_APP_API_BASE_URL='https://192.168.0.88/api'\nREACT_APP_ASSET_BASE_URL='https://192.168.0.88/storage'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='https://192.168.0.88'\nREACT_APP_BACK_DOMAIN = 'https://192.168.0.88'\n\nREACT_APP_SITE_KEY = 'your-key'\n\n\nin backend env :\n\n\nAPP_URL=https://192.168.0.88\nAPP_SITE_URL=\"https://192.168.0.88:3000\"\n\n\n축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제가 있으면 다음을 실행해 보세요\n\n```js\nsudo systemctl restart apache2\n```\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n# (선택 사항) /etc/hosts 파일 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.\n\n# (선택 사항) Chrome에서 인증서를 가져오는 방법:\n\n- 권한 생성 및 인증서를 CRT 형식으로 변환:\n\n```js\nopenssl x509 -in server.cert -out server.crt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- PKCS#12 형식으로 인증서 및 키 변환하기:\n\n```js\nopenssl pkcs12 -export -out certificate.pfx -inkey private.key -in server.cert\n```\n\n개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n3. Chrome에 인증서 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크롬을 열고 설정으로 이동합니다.\n- 아래로 스크롤하여 고급을 클릭합니다.\n- 개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.\n- 인증서 창에서 개인 탭으로 이동합니다.\n- 가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.\n- 가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.\n\n4. 신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:\n\n```js\nsudo cp server.crt /usr/local/share/ca-certificates/server.crt\nsudo update-ca-certificates\n```\n\n다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nawk -v cmd='openssl x509 -noout -subject' ' /BEGIN/{close(cmd)};{print | cmd}' \u003c /etc/ssl/certs/ca-certificates.crt | grep -i localhost\n```\n\n인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.\n\n```js\nopenssl x509 -in server.cert -text -noout\n```\n\n만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl x509 -enddate -noout -in server.cert\n```\n\n인증서 내용 확인:\n\nOpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:\n\n```js\nopenssl x509 -in server.cert -text -noout\nopenssl rsa -in private.key -text -noout\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.\n\n```js\nopenssl rsa -in private.key -out private.key\n```\n\n인증서를 확인하려면\n\n```js\nopenssl verify server.crt\n```","ogImage":{"url":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트 웹사이트 성능 향상 시키는 방법","description":"","date":"2024-05-18 21:42","slug":"2024-05-18-performanceinreact","content":"\n\n현대 웹 애플리케이션을 개발할 때 최적의 성능을 달성하는 것이 중요합니다. ReactJS는 개발자가 빠르고 반응이 뛰어나며 효율적인 애플리케이션을 만들 수 있도록 도와주는 강력한 도구와 기술을 제공하지만, 이들을 어떻게 사용해야 하는지 알아야 합니다! 이 글에서는 ReactJS에서 성능을 극대화하기 위한 주요 원칙을 탐구하며, 재렌더링을 최소화하고 DOM과 가상 DOM 간의 차이를 이해하며 불변성을 활용하고 메모이제이션을 구현하는 것에 초점을 맞출 것입니다.\n\n![Image](/assets/img/2024-05-18-performanceinreact_0.png)\n\nReact의 성능 최적화의 핵심은 재렌더링을 최소화하는 원칙에 있습니다. 컴포넌트가 재렌더링될 때마다 React는 변경 사항을 조화하고 DOM을 적절히 업데이트해야 합니다. 불필요한 재렌더링을 줄이면 애플리케이션 속도가 향상되는 것뿐만 아니라, 사용자 경험도 부드럽고 반응성 있게 유지할 수 있습니다. 그러나 이를 실현하기 위해서는 상태 관리, 컴포넌트 디자인 및 라이프사이클 메서드에서 모베스트 프랙티스를 이해하고 적용해야 합니다.\n\n# DOM vs. 가상 DOM 🌐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDOM 및 가상 DOM과 같은 개념이 성능과 연관이 있는 이유는 React와 같은 프레임워크가 사용자 인터페이스 업데이트를 다루는 방식 때문입니다. 문서 객체 모델(DOM)은 웹 문서를 프로그래밍적으로 다루는 인터페이스로, 웹페이지의 구조를 객체 트리로 표현합니다. 이 트리의 각 노드는 요소, 속성, 텍스트 컨텐츠와 같은 문서의 부분을 나타냅니다. 이것은 기본적으로 브라우저가 HTML 코드를 이해하는 방식입니다:\n\n![Performance in React](/assets/img/2024-05-18-performanceinreact_1.png)\n\n각 재렌더링은 React가 변경 사항을 조율하고 DOM을 업데이트해야 하므로 연산 부하가 발생할 수 있습니다. DOM의 변경마다 브라우저가 스타일을 다시 계산하고 레이아웃을 재구성하며 페이지를 다시 그리게 됩니다. 이는 퍼포먼스에 상당한 영향을 미칠 수 있으며 특히 업데이트가 빈번하고 DOM 트리의 큰 부분을 포함할 때 그 영향이 커집니다.\n\n하지만 React는 어떻게 이를 효율적으로 처리할까요?\nReact는 실제 DOM의 추상화인 가상 DOM을 생성합니다. 이는 React가 메모리에 유지하는 DOM의 가벼운 사본입니다. React 컴포넌트의 상태가 변경되면 React는 먼저 가상 DOM을 업데이트합니다. 그런 다음에 실제 DOM을 새로운 가상 DOM 상태와 일치하도록 업데이트해야 하는 최소한의 변경 세트를 효율적으로 결정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 말은 React가 모든 상태 변경에 대해 즉시 DOM을 업데이트하는 대신 변경 사항을 수집하고 한 번에 DOM을 업데이트한다는 것을 의미합니다. 이로써 DOM에 액세스하고 수정하는 횟수가 감소하여 성능이 향상됩니다. 이 프로세스를 reconciliation이라고 합니다.\n\n# 성능 최적화 📈\n\n성능에 대해 논의할수록, 프레임워크의 핵심 원칙에 대해 깊게 이야기하며 데이터와 계산을 효율적으로 처리하는 방식에 영향을 미치는 것에 대해 말하게 됩니다. React에서 두 가지 원칙인 불변성과 메모이제이션은 모두 성능을 향상시키는 데 중요한 역할을 합니다.\n\n## 불변성🔒\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불변성은 데이터 구조를 생성한 후에 수정하지 않는 실천 방식을 의미합니다. 대신, 모든 수정은 새로운 데이터 구조를 생성합니다. 이 개념은 React에서 아래와 같은 이유로 중요합니다:\n\n- 예측 가능한 상태 변경: 상태가 불변성을 갖추면 변경 사항이 예측 가능하고 추적 가능해져서 코드의 디버깅과 이해가 간소화됩니다.\n- 효율적인 다시 렌더링: React는 이전 상태나 프롭을 현재 상태나 프롭과 비교하여 컴포넌트를 다시 렌더링해야 하는지 빠르게 판단할 수 있습니다. 참조가 다를 경우 React는 변경이 발생했음을 알 수 있습니다. 이 비교는 불변성 데이터 구조를 사용하여 빠르고 효율적입니다.\n- 부작용 회피: 불변성은 공유된 가변 상태로 인한 의도하지 않은 부작용을 방지하여 더 신뢰성이 있고 유지보수가 용이한 코드를 만들어냅니다.\n\n하지만 React와 JavaScript는 어떻게 불변성을 활용하여 더 빠르게 렌더링할 수 있을까요?\n\n앞에서 언급했듯이 불변 데이터를 사용하면 React의 diffing 알고리즘이 애플리케이션의 상태 변화를 더 효율적으로 추적할 수 있습니다. 왜냐하면 객체 참조를 간단히 비교함으로써 각 객체의 속성을 깊게 비교할 필요가 없기 때문입니다. JavaScript는 객체 포인터가 다른 메모리 위치에 있는지 확인함으로써 모든 키를 확인하지 않고도 차이점을 확인할 수 있습니다. 이렇게 하면 훨씬 빨라집니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션 🧠\n\n한편, 메모이제이션은 결과를 캐싱하고 같은 입력이 다시 발생할 때 재사용하여 비싼 계산을 최적화하는 데 도움이 됩니다. React에서 memoization은 useMemo 및 useCallback과 같은 훅을 통해 구현될 수 있습니다. 이러한 훅은 값과 함수를 메모이즈하여 불필요한 다시 랜더링과 계산을 막아주는데 도움을 줍니다. 만약 ReactJS 코드를 작성한 적이 있다면 아마 이에 대해 알고 있어야 할 것입니다.\n\n하지만 중요한 것은 메모이제이션과 불변성을 따로 생각하지 않는 것입니다. 이 둘은 밀접한 관련이 있으며 종종 함께 사용하여 성능을 최적화합니다. 이들의 관계를 이해하면 개발자가 더 효율적이고 유지보수가 쉬운 코드를 작성하는 데 도움이 됩니다.\n\n![React 성능 개선 이미지](/assets/img/2024-05-18-performanceinreact_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션과 불변성의 관계 🔗\n\n리액트에서 성능 최적화의 맥락에서 메모이제이션과 불변성은 밀접한 관련이 있습니다. 불변성은 안정적인 기반을 제공하여 메모이제이션을 더 효율적이고 신뢰할 수 있도록 만드는데 기여합니다. 다음과 같은 이유로 상태 변화가 예측 가능하고 의존성 추적을 단순화시킵니다:\n\n- 캐시 로직 단순화: 불변 데이터로 인해 메모이제이션 함수의 캐싱 로직이 더 간단해집니다. 데이터가 변할 수 없기 때문에 캐시는 데이터 변화로 인한 무효화를 처리할 필요가 없어져 더 직접적이고 신뢰할 수 있는 메모이제이션이 가능해집니다.\n- 부작용 회피: 불변 데이터 구조는 공유된 가변 상태에 의한 부작용을 피하는 데 도움이 됩니다. 이는 메모이제이션 함수가 더 안전하고 예측 가능하게 만들어줍니다. 예상치 못한 변경이 없는 입력값에 의존하기 때문입니다.\n- 참조 동등성: 불변성은 데이터 구조들을 참조 동등성을 통해 간단하고 효율적으로 비교할 수 있게 해줍니다 (즉, 두 참조가 동일한 객체를 가리키는지 확인). 이는 메모이제이션에 핵심적인데, 빠르고 효율적인 캐시 조회를 가능하게 합니다. 메모이제이션 함수의 입력이 불변성을 가진다면 함수는 입력값이 변경되었는지 쉽게 참조를 비교함으로써 판단할 수 있습니다.\n\n데이터가 불변하면 메모이제이션 함수나 컴포넌트의 의존성이 안정적으로 유지됩니다. 이 안정성은 메모이제이션 값을 또는 콜백을 필요한 경우에만 다시 계산함으로써 불필요한 계산과 새로고침을 피할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-performanceinreact_3.png) \n\n# 결론 📢\n\n이전에 이야기한 대로, 성능에 대해 더 깊이 이야기할수록, 프레임워크의 핵심 원칙에 대해 더 많이 이야기하게 됩니다. React 애플리케이션은 Virtual DOM의 효율적인 차이점 및 업데이팅 기능을 활용하고, 불변 데이터 구조 및 메모이제이션된 계산을 보완하여 번개처럼 빠른 렌더링 및 부드러운 사용자 경험을 달성할 수 있습니다.\n\nReact 핵심 개념을 조화롭게 통합함으로써, 개발자들은 응답성이 뛰어나고 성능이 우수한 사용자 경험을 제공하여 응용 프로그램의 최대 잠재력을 발휘할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음… 그것이 다야!\n내 LinkedIn에 연락해 보고 메시지를 보내주세요. 멋진 경험이 될 거에요!\n\n고마워요!! 👋👋","ogImage":{"url":"/assets/img/2024-05-18-performanceinreact_0.png"},"coverImage":"/assets/img/2024-05-18-performanceinreact_0.png","tag":["Tech"],"readingTime":5},{"title":"Axios, Fetch, Express 깊이 알아보기","description":"","date":"2024-05-18 21:41","slug":"2024-05-18-ADeepDiveintoAxiosFetchandExpress","content":"\n\n웹 개발 분야에서, 작업에 적합한 도구를 선택하는 것이 생산성과 애플리케이션의 효율에 상당한 영향을 미칠 수 있습니다. 오늘은 Axios, Fetch 및 Express라는 세 가지 중요한 기술에 대해 자세히 살펴볼 것입니다. 프론트 엔드, 백 엔드 또는 둘 다를 개발 중이더라도 이러한 도구를 이해하는 것은 개발 기술을 향상시킬 수 있습니다. 함께 알아보겠습니다!\n\n# Axios vs. Fetch vs. Express: 어떤 것을 사용해야 할까요?\n\n# 소개\n\n웹 개발자로서, HTTP 요청을 보내고 강력한 서버 측 애플리케이션을 구축하는 작업에 자주 직면하게 됩니다. Axios, Fetch 및 Express는 이러한 목표를 달성하는 데 도움이 되는 세 가지 주요 기술입니다. 그러나 이들은 각각 다른 목적을 가지고 있습니다. 이 포괄적인 안내서에서 각 도구의 특징, 작동 방식 및 사용 시기에 대해 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Axios란 무엇인가요?\n\nAxios는 브라우저와 Node.js 환경에서 HTTP 요청을 보내는 데 사용되는 인기 있는 JavaScript 라이브러리입니다. Promise를 기반으로 하고 있어 비동기 작업을 간편하게 처리할 수 있습니다. Axios는 간단함과 강력한 기능으로 개발자 커뮤니티에서 사랑받고 있습니다.\n\n# Axios의 주요 기능:\n\n- Promise 기반 API: 비동기 요청 처리를 간편하게 합니다.\n- Interceptors: 요청이나 응답을 처리하기 전에 수정할 수 있습니다.\n- 자동 JSON 파싱: JSON 데이터를 자동으로 처리합니다.\n- 넓은 호환성: 오래된 브라우저와 Node.js에서 작동합니다.\n- 편리한 메소드: HTTP 요청을 위한 간소화된 메소드를 제공합니다 (예: axios.get, axios.post).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법:\n\nAxios를 사용하여 API에서 데이터를 가져오는 간단한 예제가 여기 있어요.\n\n```js\naxios.get('https://api.example.com/data')\n  .then(response =\u003e {\n    console.log(response.data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  });\n```\n\n# 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Fetch가 무엇인가요?\n\nFetch는 XMLHttpRequest에 대한 더 현대적이고 유연한 대안을 제공하는 내장 JavaScript API입니다. 대부분의 최신 브라우저에서 사용할 수 있으며 promise를 반환하여 네이티브 솔루션을 선호하는 많은 개발자들에게 인기가 있습니다.\n\n# Fetch의 주요 기능:\n\n- 네이티브 API: 추가 라이브러리가 필요하지 않습니다.\n- Promise 기반: 현대적인 JavaScript와 매끄럽게 통합됩니다.\n- 간소화된 구문: XMLHttpRequest보다 더 간결하고 가독성이 좋습니다.\n- 수동 JSON 처리: JSON 응답을 수동으로 구문 분석해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법\n\nFetch를 사용하여 API 요청을 하는 방법을 보여드리겠습니다:\n\n```js\nfetch('https://api.example.com/data')\n  .then(response =\u003e response.json())\n  .then(data =\u003e {\n    console.log(data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류가 발생했습니다:', error);\n  });\n```\n\n# 익스프레스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Express란 무엇인가요?\n\nExpress는 웹 및 모바일 애플리케이션을 개발하기 위한 강력한 기능 세트를 제공하는 최소한의 유연성을 갖춘 Node.js 웹 애플리케이션 프레임워크입니다. 그 간결함과 확장성으로 인해 API 및 서버 측 응용 프로그램을 만드는 데 널리 사용됩니다.\n\n# Express의 주요 기능:\n\n- 미들웨어 지원: 요청을 처리하는 함수를 쉽게 추가할 수 있습니다.\n- 라우팅: 다양한 HTTP 메소드와 URL 패턴을 처리하기 위한 강력한 라우팅 기능.\n- 확장성: 다양한 플러그인 및 모듈의 큰 생태계.\n- 확장성: 확장 가능한 어플리케이션을 구축하는 데 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제 사용법:\n\n다음은 Express 서버를 설정하는 기본적인 예제입니다:\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/data', (req, res) =\u003e {\n  res.json({ message: '안녕, 세상아!' });\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n# 이 비교가 중요한 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAxios, Fetch 및 Express 간의 차이를 이해하는 것은 여러 가지 이유로 중요합니다:\n\n- 정보 있는 결정: 특정 시나리오에서 어떤 도구를 사용해야 하는지를 알면 효율성과 효과성이 향상됩니다.\n- 코드 품질 향상: 작업에 적합한 적절한 도구를 사용하면 보다 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 더 나은 디버깅: 이러한 도구에 익숙해지면 문제 해결과 디버깅을 더 효과적으로 수행할 수 있습니다.\n- 생산성 향상: 적절한 도구로 개발 프로세스를 최적화하면 시간을 절약하고 복잡성을 줄일 수 있습니다.\n\n# Axios vs. Fetch: 언제 사용해야 할까요?\n\nAxios를 사용하세요 만약:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 요청/응답 인터셉터와 같은 기능이 필요합니다.\n- 자동 JSON 파싱을 선호합니다.\n- Node.js 및 오래된 브라우저와 같은 다른 환경에서 보다 넓은 호환성이 필요합니다.\n\nFetch를 사용하실 때:\n\n- 추가 라이브러리 없이 네이티브 솔루션을 선호합니다.\n- 모던 브라우저에서 작업 중이십니다.\n- 요청 및 응답 처리에 대한 더 많은 제어를 원합니다.\n\n# Express를 사용해야 하는 경우?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Express를 사용하면:\n  - 서버 측 애플리케이션이나 API를 구축 중일 때.\n  - 견고한 라우팅 및 미들웨어 지원이 필요할 때.\n  - Node.js 생태계 내에서 작업하며 유연하고 확장 가능한 프레임워크가 필요할 때.\n\n# 결론\n\n웹 개발 작업에 적합한 도구를 선택하는 것은 효율적이고 확장 가능하며 유지보수가 쉬운 애플리케이션을 만드는 데 중요합니다. Axios와 Fetch는 각자의 장점을 가지고 있어 클라이언트 측에서 HTTP 요청을 처리하는 데 탁월한 선택지입니다. 반면 Express는 서버 측 애플리케이션과 API를 구축하는 데 강력한 프레임워크입니다.\n\n이 상세한 비교가 여러분이 이 도구들을 언제, 어떻게 효과적으로 사용해야 하는지 이해하게 도와드리기를 바랍니다. Axios, Fetch, 그리고 Express를 숙달함으로써 여러분은 다양한 웹 개발 과제에 대처할 수 있는 역량을 갖추게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 댓글에 생각을 공유하거나 궁금한 점을 질문해 주세요.\n\n만약 이 글이 도움이 되었다면 박수를 보내고 동료 개발자들과 공유해주세요. 앞으로 더 많은 웹 개발 통찰과 튜토리얼이 기대되니 기대해 주세요!\n\nAditya Singh.","ogImage":{"url":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"},"coverImage":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png","tag":["Tech"],"readingTime":4},{"title":"NinjaCart SDE 2 프론트엔드 인터뷰 경험","description":"","date":"2024-05-18 21:40","slug":"2024-05-18-NinjaCartSDE2frontendInterviewExp","content":"\n\n친구로부터 닌자카트 인재영입 담당자의 전화번호를 받았어요\n\n# 면접 1 — 기본 JS 이해\n\n1번 질문 — 디바운싱과 쓰로틀링에 관련된 질문입니다. 이 두 기술의 차이 및 실제 적용법을 말해주세요.\n\n2번 질문 — 프로미스와 setTimeout을 활용한 출력 관련 질문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(1);\n\nsetTimeout(function () {\n    console.log(2);\n}, 0);\n\nPromise.resolve()\n    .then(function () {\n        console.log(3);\n    })\n    .then(function () {\n        console.log(4);\n    });\n```\n\n3번 문제 — 클로저 및 setTimeout을 기반으로 한 출력 문제\n\n```js\nfor (var index = 1; index \u003c= 3; index++) {\n    setTimeout(function () {\n        console.log('after ' + index + ' second(s):' + index);\n    }, index * 1000);\n}\n```\n\n4번 문제 — 중첩된 배열을 평평하게 만드는 함수를 작성하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5번 질문 — useEffect와 useMemo를 기반으로 함\n\n# 2차 인터뷰 — 머신 코딩 및 문제 해결\n\n1번 질문 — 사용자 정의 React 탭 컴포넌트 만들기\n해결책\n\n2번 질문 — 실패하면 프라미스를 다시 시도하는 함수 만들기 (질문 링크)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3차 면접 — 매니저 면접\n\n매니저는 하르야나 출신이셔서 저희는 그냥 평범한 대화를 나눴어요 (아버지의 친구와 얘기하는 느낌이었어요 😂)","ogImage":{"url":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"},"coverImage":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png","tag":["Tech"],"readingTime":1}],"page":"67","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"67"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>