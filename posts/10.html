<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/10" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/10" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" href="/post/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 Firebase 인증 사용하는 방법" href="/post/2024-06-23-Firebaseauthenticationinangular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 Firebase 인증 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 Firebase 인증 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 Firebase 인증 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular HttpClient와 Signals를 연결하는 방법" href="/post/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular HttpClient와 Signals를 연결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular HttpClient와 Signals를 연결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular HttpClient와 Signals를 연결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v15에 Google Analytics 추가하는 방법" href="/post/2024-06-23-AddingGoogleAnalyticstoAngularv15"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v15에 Google Analytics 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 커스텀 파이프 사용 방법" href="/post/2024-06-23-AngularCustomPipes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularCustomPipes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 커스텀 파이프 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" href="/post/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" href="/post/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" href="/post/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" href="/post/2024-06-23-UsingESLintHuskyLint-staged"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" href="/post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">OpenAI 기능 호출로 훈련 데이터 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link posts_-active__YVJEi" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법","description":"","date":"2024-06-23 14:07","slug":"2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png\" /\u003e\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터/변수를 전달하는 여러 가지 방법이 있습니다. 가장 흔한 두 가지 방법은 다음과 같습니다:\n\n- @Input 데코레이터 사용\n- 공유 서비스 사용\n\n## 1. @Input 데코레이터 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 방법은 자식 컴포넌트에서 데이터를 수신할 변수를 선언하는 데 @Input() 데코레이터를 사용하는 것입니다.\n\n부모 컴포넌트의 템플릿에서, 속성 바인딩 구문(대괄호)을 사용하여 변수의 값을 자식 컴포넌트의 입력에 바인딩합니다.\n\n예를 들어, 부모 컴포넌트의 템플릿에서:\n\n```js\n\u003c!--parent.component.html--\u003e\n\n\u003capp-child [inputFromParent]=\"data\"\u003e\u003c/app-child\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아이 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cp\u003e{ inputFromParent }\u003c/p\u003e\n  `\n})\nexport class ChildComponent {\n  @Input() inputFromParent: any;\n}\n```\n\n## 2. 공유 서비스 사용\n\n다른 방법은 공유 서비스를 사용하는 것입니다. 공유 서비스는 서로 직접적으로 관련이 없는 컴포넌트 간에 데이터를 공유하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부모 컴포넌트의 클래스에서:\n\n```js\n// parent.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    \u003capp-child\u003e\u003c/app-child\u003e\n  `\n})\nexport class ParentComponent {\n  constructor(private dataService: DataService) {\n    this.dataService.data = '부모 컴포넌트에서 안녕하세요!';\n  }\n}\n```\n\n자식 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cp\u003e{ data }\u003c/p\u003e\n  `\n})\nexport class ChildComponent {\n  data: any;\n  constructor(private dataService: DataService) {\n    this.data = this.dataService.data;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 변수를 전달하는 다른 방법이 있을 수 있습니다. 이것들은 기본 접근 방법 중 두 가지에 불과합니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular에서 Firebase 인증 사용하는 방법","description":"","date":"2024-06-23 14:06","slug":"2024-06-23-Firebaseauthenticationinangular","content":"\n\n이 기사에서는 Angular 프로젝트에 Firebase 인증을 Google Single Sign-On (SSO)과 빠르게 설정하는 방법을 제안합니다. 또한 선택한 백엔드에 인증된 요청을 하는 방법도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png)\n\n전체 코드는 여기에서 확인할 수 있습니다: https://github.com/Gabriel2409/demofirebase\n\n# Firebase 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase에 가서 새 프로젝트를 만들어주세요.\n\n## 앱 설치\n\n프로젝트 개요 페이지에서 Web 아이콘을 클릭하거나 +앱 추가 아이콘을 클릭하여 웹 애플리케이션을 추가하세요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열리는 창에서 앱에 이름을 지정하고, 예를 들어 myangularapp처럼 등록해주세요. Firebase 구성을 어딘가에 저장하세요. 다음과 같이 보여야 합니다:\n\n```js\nconst firebaseConfig = {\n  apiKey: \"\u003cfirebase-api-key\u003e\",\n  authDomain: \"\u003cmy-project-id\u003e.firebaseapp.com\",\n  projectId: \"\u003cmy-project-id\u003e\",\n  storageBucket: \"\u003cmy-project-id\u003e.appspot.com\",\n  messagingSenderId: \"\u003cmy-messaging-sender-id\",\n  appId: \"\u003cmy-app-id\u003e\",\n};\n```\n\n프로젝트 설정의 일반 탭(톱니바퀴 아이콘)로 이동하여 아무 때나 앱의 Firebase 구성에 액세스할 수 있음을 유념하세요.\n\n## 인증 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 제품으로 이동한 다음 **인증**을 선택하세요. **로그인 방법**에서 **새로운 제공자 추가**를 클릭하고 Google을 선택하세요. Firebase는 Google과 긴밀하게 통합되어 있기 때문에 별도의 설정이 필요하지 않습니다.\n\n그게 다에요! 이제 Google SSO를 사용하여 Firebase 사용자를 인증할 준비가 되었습니다.\n\n참고: 다른 제공자도 추가할 수 있습니다(예: 이메일/비밀번호, 아래 이미지 참조), 하지만 이 기사에서는 Google SSO에 중점을 두고 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Angular 설정\n\n## 프로젝트 생성\n\n먼저, npm install -g @angular/cli를 사용하여 Angular을 전역으로 설치하세요. 저는 버전 17.0.1을 사용하고 있어요.\n\n그런 다음, demofirebase라는 새 폴더를 만들고 해당 폴더에서 ng new frontend --no-standalone --routing ssr=false을 실행하세요. 이렇게 하면 필요한 파일이 포함된 frontend 폴더가 생성됩니다. 이 단계를 마치면 저장소 구조는 다음과 같아야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndemofirebase\n└── frontend\n```\n\n하나의 추가 패키지가 필요합니다. frontend 폴더에서 npm i @angular/fire 명령어를 실행해주세요.\n\n다음으로, 개발 및 프로덕션을 위한 환경을 생성할 때 ng g environments를 사용합니다.\n이는 src/environments 폴더에 2개의 파일을 생성합니다: environment.development.ts와 environment.ts.\n로컬에서 개발할 때는 environment.ts가 environment.development.ts로 대체되어 environment.ts에서 import를 하면 자동으로 environment.development.ts의 변수들을 사용할 수 있습니다. 이는 angular.json 파일에서 확인할 수 있습니다:\n\n```js\n\"fileReplacements\": [\n    {\n        \"replace\": \"src/environments/environment.ts\",\n        \"with\": \"src/environments/environment.development.ts\"\n    }\n]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase 구성을 environment.development.ts에 붙여 넣으세요.\n\n```js\n// environment.development.ts\nexport const environment = {\n  production: false,\n  // 백엔드에 요청을 보낼 수 있는 가정\n  backendUrl: \"http://127.0.0.1:8000\",\n  // 콘솔에서 가져온 Firebase 구성입니다.\n  // 이것은 민감한 정보가 아님을 주의하세요\n  firebaseConfig: {\n    apiKey: \"\u003cfirebase-api-key\u003e\",\n    authDomain: \"\u003cmy-project-id\u003e.firebaseapp.com\",\n    projectId: \"\u003cmy-project-id\u003e\",\n    storageBucket: \"\u003cmy-project-id\u003e.appspot.com\",\n    messagingSenderId: \"\u003cmy-messaging-sender-id\",\n    appId: \"\u003cmy-app-id\u003e\",\n  },\n};\n```\n\n참고: production용 (environment.ts 파일)으로 가시려면, backendUrl을 배포된 백엔드로, firebaseConfig을 production 구성으로 대체하시면 됩니다. Firebase 프로젝트는 여러 환경을 가질 수 없으므로 환경마다 프로젝트를 생성하는 것이 좋습니다. 지금은 빠른 진행을 위해 더미 값만 사용하셔서 IDE에서 필드 부족으로 에러가 발생하지 않도록 하세요.\n\n```js\n// environment.ts\nexport const environment = {\n  production: true,\n  backendUrl: \"backendUrl\",\n  firebaseConfig: {},\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 모듈(app.module.ts)에 필요한 import 문을 추가하고 애플리케이션을 초기화하세요:\n\n```js\n//app.module.ts\nimport { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { AppRoutingModule } from \"./app-routing.module\";\nimport { AppComponent } from \"./app.component\";\nimport { AngularFireModule } from \"@angular/fire/compat\";\nimport { AngularFireAuthModule } from \"@angular/fire/compat/auth\";\nimport { environment } from \"../environments/environment\";\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    AngularFireAuthModule,\n    AngularFireModule.initializeApp(environment.firebaseConfig),\n    BrowserModule,\n    AppRoutingModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 필요한 컴포넌트와 라우트 생성\n\n첫째로, Google SSO를 위한 컴포넌트를 생성하려면 'ng g c signin'을 사용하고, 랜딩 페이지를 위한 컴포넌트를 생성하려면 'ng g c landing'을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown으로 테이블 태그를 변경하세요.\n\n그럼, app-routing.module.ts을 수정하세요:\n\n```typescript\nimport { NgModule } from \"@angular/core\";\nimport { RouterModule, Routes } from \"@angular/router\";\nimport { SigninComponent } from \"./signin/signin.component\";\nimport { LandingComponent } from \"./landing/landing.component\";\n\nconst routes: Routes = [\n  { path: \"\", component: LandingComponent },\n  { path: \"signin\", component: SigninComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n마지막으로, app.component를 수정하세요:\n\n```typescript\n// app.component.ts\n\u003cnav\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/\"\u003e랜딩 페이지\u003c/a\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/signin\"\u003e로그인 페이지\u003c/a\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 ng serve를 실행하고 http://localhost:4200으로 이동하면 아주 아름다운 페이지를 볼 수 있고, 랜딩 페이지와 로그인 페이지 사이를 이동할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_3.png)\n\n## 구글 SSO 추가하기\n\n구글 SSO를 추가하려면 단순히 버튼에 click 이벤트 리스너를 추가하면 됩니다. 저는 재사용 가능하도록 지시어를 사용하는 것을 선호하는데, 아래에 제가 보여주는 구현 방법을 사용하시면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 SSO를 실행하여 지시문을 만들고 app.module.ts에 자동으로 추가합니다.\n\n```js\n//google-sso.directive.ts\nimport { Directive, HostListener } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { GoogleAuthProvider } from \"@firebase/auth\";\n\n@Directive({\n  selector: \"[googleSso]\",\n})\nexport class GoogleSsoDirective {\n  constructor(private angularFireAuth: AngularFireAuth) {}\n  @HostListener(\"click\")\n  async onClick() {\n    const creds = await this.angularFireAuth.signInWithPopup(\n      new GoogleAuthProvider(),\n    );\n    // 자격 증명으로 할 일을 실행합니다, 예를 들어 Firestore에 추가하기...\n  }\n}\n```\n\napp.module.ts에 지시문을 추가하십시오.\n\n이제 로그인 페이지에서 해당 지시문을 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- signin.component.html --\u003e\n\u003cbutton googleSso\u003eGoogle 계정으로 로그인\u003c/button\u003e\n```\n\n그게 다에요. 작동하는지 확인하려면 프론트엔드로 이동하여 만든 버튼을 클릭하세요. 로그인한 후에 Firebase 콘솔로 돌아가세요. 인증에서 사용자 탭으로 이동하면 로그인에 사용한 이메일이 나타날 것입니다.\n\n계속 진행하기 전에 로그아웃이 가능하도록 로그인 구성요소를 수정해봅시다.\n\n```js\n// signin.component.ts\nimport { Component } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n@Component({\n  selector: \"app-signin\",\n  templateUrl: \"./signin.component.html\",\n  styleUrl: \"./signin.component.scss\",\n})\nexport class SigninComponent {\n  constructor(public angularFireAuth: AngularFireAuth) {}\n  logOut() {\n    this.angularFireAuth.signOut();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003c!-- signin.component.html --\u003e\n@if (angularFireAuth.authState | async) {\n\u003cbutton (click)=\"logOut()\"\u003eLog out\u003c/button\u003e\n} @else {\n\u003cbutton googleSso\u003eSign in with google\u003c/button\u003e\n}\n\n\n## Adding a route available only for logged in users\n\nLet’s create another component: ng g c require-auth\n\nThen let’s create a guard: ng g g auth then select CanActivate\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// auth.guard.ts\nimport { CanActivateFn } from \"@angular/router\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n\nexport const authGuard: CanActivateFn = async (route, state) =\u003e {\n  const angularFireAuth = inject(AngularFireAuth);\n  const user = await angularFireAuth.currentUser;\n  // coerce to boolean\n  const isLoggedIn = !!user;\n  return isLoggedIn;\n};\n```\n\n그런 다음 app-routing.module.ts의 라우트를 수정합니다.\n\n```js\n// app-routing.module.ts - new lines\n...\nimport { RequireAuthComponent } from './require-auth/require-auth.component';\nimport { authGuard } from './auth.guard';\nconst routes: Routes = [\n  ...\n  {\n    path: 'require-auth',\n    component: RequireAuthComponent,\n    canActivate: [authGuard],\n  },\n];\n...\n```\n\napp.component.html에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cli\u003e\n  \u003ca routerLink=\"/require-auth\"\u003eAuth protected\u003c/a\u003e\n\u003c/li\u003e\n```\n\n이제 로그인한 상태에서만 액세스할 수 있는 경로가 생겼어요.\n\n## 백엔드 경로로 bearer 토큰을 보내는 인터셉터\n\n백엔드에서 요청을 인증하려면 Firebase에서 제공한 토큰을 Authorization 헤더에 추가해야 합니다. 백엔드에서는 토큰을 확인하는 작업을 담당할 것입니다(본 문서의 범위를 벗어남).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng g interceptor bearer-token 명령을 사용하여 interceptor를 생성하세요.\n\n```js\n// bearer-token.interceptor.ts\nimport { HttpEvent, HttpHandlerFn, HttpInterceptorFn, HttpRequest } from \"@angular/common/http\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { from, lastValueFrom } from \"rxjs\";\nimport { environment } from \"../environments/environment\";\n\n// 토큰을 얻는 작업이 비동기적이므로 이 함수를 추가해야 합니다.\nconst addBearerToken = async (\n  req: HttpRequest\u003cany\u003e,\n  next: HttpHandlerFn,\n): Promise\u003cHttpEvent\u003cany\u003e\u003e =\u003e {\n  const angularFireAuth = inject(AngularFireAuth);\n  const firebaseUser = await angularFireAuth.currentUser;\n  const token = await firebaseUser?.getIdToken();\n  if (token) {\n    req = req.clone({\n      setHeaders: { Authorization: `Bearer ${token}` },\n    });\n  }\n  return lastValueFrom(next(req));\n};\nexport const bearerTokenInterceptor: HttpInterceptorFn = (req, next) =\u003e {\n  // 이 bearer token을 백엔드로 보내는 요청에만 추가합니다.\n  // 특정 요청에만 bearer token을 추가하도록 사용자 정의할 수 있습니다.\n  if (req.url.startsWith(environment.backendUrl)) {\n    return from(addBearerToken(req, next));\n  } else {\n    return next(req);\n  }\n};\n```\n\n그런 다음 app.module.ts에 provider를 추가해야 합니다.\n\n```js\n// app.module.ts\n\n...\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\nimport { bearerTokenInterceptor } from './bearer-token.interceptor';\n...\n  providers: [provideHttpClient(withInterceptors([bearerTokenInterceptor]))],\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 확인해보기 위해 백엔드를 호출하는 서비스를 생성해봅시다: ng g s api\n\n```js\n// api.service.ts\nimport { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { environment } from \"../environments/environment\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ApiService {\n  // 현재 사용자의 firebase 사용자 ID를 반환하는 백엔드 URL\n  userIdUrl = `${environment.backendUrl}/userid`;\n  constructor(private http: HttpClient) {}\n  getUserId(): Observable\u003cany\u003e {\n    return this.http.get(this.userIdUrl);\n  }\n}\n```\n\n그리고 랜딩 컴포넌트에서:\n\n```js\n\u003cbutton (click)=\"getUserId()\"\u003e사용자 ID 가져오기\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from \"@angular/core\";\nimport { ApiService } from \"../api.service\";\n@Component({\n  selector: \"app-landing\",\n  templateUrl: \"./landing.component.html\",\n  styleUrl: \"./landing.component.scss\",\n})\nexport class LandingComponent {\n  constructor(private apiService: ApiService) {}\n  getUserId() {\n    this.apiService.getUserId().subscribe({\n      next: (res) =\u003e console.log(res),\n      error: (err) =\u003e console.log(err),\n    });\n  }\n}\n```\n\n이제 백엔드에 요청을 보내는 버튼이 생겼어요. 개발자 도구의 네트워크 탭에서 인증되어 있다면 토큰이 Authorization 헤더에 추가되는 것을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_4.png)\n\n## 추가 정보: Firebase는 로그인 정보를 어디에 저장하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 인터셉터를 사용할 때 다음 코드를 사용했습니다:\n\n```js\nconst angularFireAuth = inject(AngularFireAuth);\nconst firebaseUser = await angularFireAuth.currentUser;\nconst token = await firebaseUser?.getIdToken();\n```\n\n하지만 이 코드는 실제로 어떻게 작동할까요? 정보는 어디에 저장되나요?\n\n사실, Google SSO로 인증할 때, 인증 정보가 브라우저에 저장됩니다. 브라우저 개발자 도구를 열고 저장소 탭 (Chrome의 경우 Application)으로 이동하신 다음 Indexed DB로 이동해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png"},"coverImage":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular HttpClient와 Signals를 연결하는 방법","description":"","date":"2024-06-23 14:04","slug":"2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals","content":"\n\nEver since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.\n\nBut first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.\n\nAmidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## RxJS 직접 구독\n\n가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.\n\n```js\npublic data = signal\u003cnumber[]\u003e([])\n....\nconstructor(private testService: TestService) {}\n....\npublic ngOnInit() {\n  this.testService.getItems().subscribe((items) =\u003e {\n    // 시그널 덮어쓰기/생성\n    this.data = signal(items);\n    // 또는 값 직접 설정\n    this.data.set(items);\n  });\n}\n```\n\n## Promises 활용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:\n\n- async/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.\n- 또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.\n\n```js\npublic async ngOnInit() {\n  // observable 소스를 즉시 구독합니다\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n  // 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음\n```\n\n코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npublic async initData() {\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n}\n\npublic ngOnInit() {   \n  this.initData();\n  ....\n}\n```\n\n```js\npublic ngOnInit() {    \n  (async () =\u003e {\n    this.data = signal(await firstValueFrom(this.testService.getItems()));\n    console.log('data inited');\n  })();\n  ....\n}\n```\n\n다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.\n\n```js\npublic ngOnInit() {   \n  firstValueFrom(this.testService.getItems()).then((items) =\u003e {\n    this.data = signal(items);\n  });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## rxjs-interop을 사용하여 toSignal을 활용해보세요\n\nrxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:\n\n- 주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.\n- default 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.\n- API 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.\n- 읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.\n\n```js\nprivate _injector = inject(Injector);\n\npublic ngOnInit() {  \n  this.data = toSignal(this.testService.getItems(), {\n    // injector에 대한 참조 제공\n    injector: this._injector,\n    // default 값을 제공\n    initialValue: [],\n  });\n\n  // 또는 runInInjectionContext를 사용\n  runInInjectionContext(this._injector, () =\u003e {\n    toSignal(this.testService.getItems(), {\n      initialValue: [],\n    });\n  });\n  ....\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론:\n\n현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.\n\n유용한 링크:\nhttps://angular.dev/guide/signals\nhttps://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context","ogImage":{"url":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"},"coverImage":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular v15에 Google Analytics 추가하는 방법","description":"","date":"2024-06-23 14:03","slug":"2024-06-23-AddingGoogleAnalyticstoAngularv15","content":"\n\n아마 당신도 저와 같이 포트폴리오를 만들고 방문자 추적을 원하시는 분들 중 하나일 것 같아요. 다음 직업에 얼마나 가까운지 확인하려고 사이트 트래픽을 추적하고 싶어하시는 분들일 것이라고 생각해요. 혹은 스타트업에서 일하고 있는데 사용자 참여를 추적하길 원하는 경우도 있을 거예요. 어떤 케이스이든 데이터는 웹 개발에서 매우 중요하며 사람들의 일상 생활과 상호 작용하는 방식으로 상당히 중요합니다.\n\n그러니까 더 이상 말이 필요 없겠죠! Angular v15를 사용하여 Google Analytics를 통해 당신의 분석을 어떻게 추적할 수 있는지 단계별로 알려드릴게요.\n\n## 단계 1: Google Analytics 가입하기\n\n우선 처음으로 Google Analytics에 가입해야 해요. 이미 가입한 경우에는 걱정하지 마세요. 아직 가입하지 않은 경우에는 걱정하지 마시고 시작하려면 이 링크의 지시에 따라 https://analytics.withgoogle.com/ 진행한 다음 이 페이지로 돌아오세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가입 절차를 완료하셨다면 또는 이미 이 과정을 완료했다면, 아래 화면을 확인해야 합니다.\n\n![Google Analytics](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png)\n\n파란색 버튼 위에 측정 ID가 표시되어 있는 것을 알 수 있을 겁니다. 제 사진에서는 측정 ID가 흐릿하게 처리되어 있습니다. 예시로, 저의 경우 일시적으로 1234로 설정되어 있습니다.\n\n## Step 2: Angular 애플리케이션에 Google Analytics 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 index.html 파일을 열어야 합니다. 파일이 열리면 아래 코드를 head 태그 밑에 추가해야 합니다. 그러나 body 위에 추가해야 합니다. 아래와 같이 보이는대로 추가해주세요:\n\n```js\n \u003c!-- Google tag (gtag.js) --\u003e\n    \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-M7DLQTY7NJ\"\u003e\u003c/script\u003e\n    \u003cscript\u003e\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n\n      gtag('config', \u003cyour_sites_measurement_ID\u003e);\n    \u003c/script\u003e\n```\n\n측정 ID는 이 튜토리얼의 1단계에서 찾은 ID로 교체해주세요. 완료하면 이와 같이 보여야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: 분석 서비스 작성하기\n\n이번에 처음으로 Angular 서비스를 생성하고 계신다면, Angular 구조를 따르기 위해 app 폴더 내에 services라는 새 폴더를 생성하는 것을 제안드립니다. 다음과 같이 보여야 합니다:\n\n![폴더 구조](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_2.png)\n\n그런 다음, 새로운 서비스를 생성하고 분석.service.ts라는 이름의 새 서비스를 만들어 새 services 폴더 안에 넣으세요. 분석.service.ts 파일 내에는 다음 코드를 적용하게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\nimport { Injectable } from '@angular/core';\n\ndeclare var gtag: any;\n\n@Injectable({providedIn: 'root'})\nexport class AnalyticsService {\n\n  trackEvent(eventName: string, eventDetails: string, eventCategory: string) {\n    gtag('event', eventName, {\n    // event Type - example: 'SCROLL_TO_TOP_CLICKED'\n    'event_category': eventCategory,\n    // the label that will show up in the dashboard as the events name\n    'event_label': eventName,\n    // a short description of what happened\n    'value': eventDetails\n    })\n  }\n}\n```\n\nvar gtag를 선언함으로써 Angular에게 애플리케이션 어딘가에 참조하려는 gtag라는 메서드가 있는 것을 알려줍니다. 이제 gtag를 index.html 파일에 가져와서 새로운 메서드를 만들 수 있게 되었습니다. 우리가 만든 새로운 메서드는 trackEvent()입니다. 각 속성이 대시보드에 어떻게 표시될지 이해하는 데 도움이 되도록 주석을 남겨 두었습니다.\n\n다음 단계는 선택 사항입니다. 그러나 대부분의 주요 응용 프로그램은 이 구조를 따르므로 이 프레임워크가 익숙하지 않다면 해당 폴더의 index.ts 파일을 업데이트하는 습관을 가져가는 것을 제안합니다. 그런 경우가 아니라면 services 폴더 내에 index.ts 파일을 생성하여 * 장식자를 사용하여 모든 서비스 콘텐츠를 내보낼 수 있도록 합니다. 아래 정보를 참고로 사용하십시오.\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 새로운 분석 서비스 사용하기\n\n이제 사용 중인 컴포넌트에 새 서비스를 가져와야 합니다. 이 튜토리얼은 v15용이므로 독립형 컴포넌트 방법을 사용할 것입니다. 이전 버전을 사용 중이라면 서비스를 컴포넌트가 포함된 모듈 또는 앱 모듈로 가져와야 합니다.\n\n당신의 파일은 Angular의 최신 버전을 사용 중이라면 다음과 유사한 모습이어야 합니다:\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 서비스를 가져와서 제공자 목록에 추가하세요. 그런 다음 @angular/core에서 ngOnInit()를 구현할 것입니다. 이렇게 하면 Angular 라이프사이클에서 생성자가 완료된 후 footer가 로드되었다는 이벤트를 보낼 수 있게 됩니다. 그런 다음 분석 서비스를 타겟팅하고 trackEvent() 메서드에 액세스하여 일부 데이터를 전달할 것입니다. 저는 footer 컴포넌트를 예시로 사용하겠습니다. 아래 이미지에서 보여지는 것처럼:\n\n![Adding Google Analytics to Angular v15_5](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_5.png)\n\n## 단계 5: 배포 및 테스트\n\n마지막 단계는 애플리케이션을 배포하고 최종 결과를 테스트하는 것입니다. 대시보드로 돌아가서 리포트에 있는 실시간 탭으로 이동할 수 있습니다. 사이트에 방문하면 지도상에서 자신을 확인할 수 있고 새 이벤트가 애플리케이션에 추가되었음을 확인할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Google Analytics Event Network Tab](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_6.png)\n\n이벤트를 트리거할 때 컬렉션 이벤트 트리거를 보게 될 것입니다. 또한 쿠키에서 태그를 볼 수 있습니다. 두 가지 이미지 모두 아래에서 확인할 수 있습니다.\n\n![Collection Event Trigger in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_7.png)\n\n![Viewing the Tag in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞으로의 개발 팁과 요령을 팔로우해주세요. 읽어 주셔서 감사합니다. 여러분의 지원에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"},"coverImage":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 커스텀 파이프 사용 방법","description":"","date":"2024-06-23 14:02","slug":"2024-06-23-AngularCustomPipes","content":"\n\nMarkdown 형식으로 테이블 태그를 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 간단한 사용자 정의 파이프 만들기\n\n우리가 하는 일을 시작하기 위해 문자열에서 각 단어의 첫 글자를 대문자로 변경하는 파이프를 만들어보는 간달한 예제부터 사용해 봅시다.\n\n1. 파이프 생성하기\n\n```js\nng generate pipe capitalize\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 로직 구현\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'capitalize'\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return value;\n    return value.replace(/\\b\\w/g, char =\u003e char.toUpperCase());\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용\n\n```html\n\u003cp\u003e{ 'hello world' | capitalize }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 매개변수를 사용한 Pipe 생성하기\n\n사용자 정의 파이프는 매개변수도 받을 수 있습니다. 이 예제에서는 어떻게 매개변수를 가진 파이프를 생성하는지 자세히 살펴보겠습니다. 이 파이프 예제는 숫자를 지정된 소수 자리로 서식 지정합니다. \n\n1. 파이프 생성하기\n\n```js\nng generate pipe decimalFormatter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Pipe Logic을 구현하세요\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'decimalFormatter'\n})\nexport class DecimalFormatterPipe implements PipeTransform {\ntransform(value: number, decimalPlaces: number): string {\n if (isNaN(value)) return value.toString();\n return value.toFixed(decimalPlaces);\n }\n}\n```\n\n3. 파라미터와 함께 Pipe 사용하기\n\n```js\n\u003cp\u003e{ 1234.56789 | decimalFormatter:2 }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 복잡한 변환에는 Pipes를 사용해요\n\n가끔, Pipes는 더 복잡한 변환을 다루어야 할 때가 있어요. 특정 속성과 값에 따라 객체 배열을 필터링하는 Pipe를 만들어 보도록 해요.\n\n1. Pipe 생성하기\n\n```js\nng generate pipe filter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 논리 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'filter'\n})\nexport class FilterPipe implements PipeTransform {\n  transform(items: any[], property: string, value: any): any[] {\n    if (!items || !property || value === undefined) return items;\n    return items.filter(item =\u003e item[property] === value);\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용하기\n\n```js\nexport class AppComponent {\n  users = [\n    { name: 'AJ', role: 'admin' },\n    { name: 'Segun', role: 'user' },\n    { name: 'Homelander', role: 'admin' },\n    { name: 'Alice', role: 'user' }\n  ];\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cul\u003e\n@for(user of users; track user | filter:'role':'admin') {\n \u003cli\u003e\n { user.name } ({ user.role })\n \u003c/li\u003e\n}\n\u003c/ul\u003e\n```\n\n## 비동기 파이프 생성하기\n\nAngular는 Observables 또는 Promises를 사용하여 비동기 파이프를 지원합니다. API에서 데이터를 가져와 표시하는 파이프를 만들어보겠습니다.\n\n1. 파이프 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate pipe fetchData\n```\n\n2. Pipe 로직 구현하기\n\n```js\n@Pipe({\n name: 'fetchData',\n pure: false\n})\nexport class FetchDataPipe implements PipeTransform {\n private http = inject(HttpClient)\n transform(url: string): Observable\u003cany\u003e {\n return this.http.get(url);\n }\n}\n```\n\n3. 템플릿에서 Pipe 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cdiv\u003e\n@if(apiUrl | fetchData | async as data) {\n \u003cpre\u003e{ data | json }\u003c/pre\u003e\n}\n\u003c/div\u003e\n//apiUrl: string = 'https://api.example.com/data'\n```\n\n## 파이프 성능 최적화\n\n기본적으로 Angular 파이프는 순수입니다. 이는 입력 참조가 변경될 때만 다시 실행됨을 의미합니다. 성능 상의 이유로 가능한 곳에서 이 동작을 활용하는 것이 중요합니다. 그러나 입력 데이터가 가변적인 경우, @Pipe 데코레이터의 pure 속성을 false로 설정하여 순수하지 않은 파이프를 생성할 수 있습니다.\n\n순수하지 않은 파이프의 예시\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 파이프 생성하기\n\n```js\nng generate pipe impure\n```\n\n2. 파이프 로직 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'impure',\n pure: false\n})\nexport class ImpurePipe implements PipeTransform {\ntransform(value: any, …args: any[]): any {\n // 사용자 정의 변환 로직\n return value;\n }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 커스텀 파이프에 대한 최상의 방법\n\n가능한 경우 Pipes Pure를 유지하여 Angular의 변경 감지 최적화를 활용하세요.\n단일 책임: 각 파이프는 단일 책임을 가져야 합니다. 변환 작업이 복잡한 경우 여러 파이프로 분리하는 것을 고려해보세요.\n성능 고려사항: 특히 복잡한 변환 작업이나 대량 데이터세트의 경우 성능에 신경을 써야 합니다. 필요한 경우 캐싱 전략을 사용하세요.\n오류 처리: 특히 외부 서비스와 상호작용이나 복잡한 작업을 수행하는 파이프의 경우 오류 처리를 구현하세요.\n재사용성: 다른 컴포넌트 및 모듈에서 재사용할 수 있는 파이프를 만들어 중복을 피하세요.\n\nAngular의 사용자 정의 파이프는 템플릿에서 데이터를 직접 변환하고 형식화하는 강력한 방법을 제공합니다. 이는 간단한 텍스트 변환부터 복잡한 데이터 조작 및 비동기 작업까지 다양할 수 있습니다. 사용자 정의 파이프를 효과적으로 이해하고 구현함으로써 Angular 애플리케이션의 가독성과 유지 관리성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularCustomPipes_0.png"},"coverImage":"/assets/img/2024-06-23-AngularCustomPipes_0.png","tag":["Tech"],"readingTime":4},{"title":"NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법","description":"","date":"2024-06-23 14:00","slug":"2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations","content":"\n\n상태 데이터와 데이터베이스를 다루는 것은 어렵습니다. 특히 프로젝트가 시간이 지남에 따라 커지면 더욱 어려워집니다. 개발 프로젝트의 성공을 위해서는 처음부터 좋은 개발 및 프로젝트 설정을 갖추는 것이 중요합니다. 이 글에서는 대부분의 프로젝트를 설정하는 방법을 보여드리고, 설정 뒤에 있는 몇 가지 생각을 강조하려고 합니다.\n\n이 예시에서는 데이터 저장을 위해 PostgreSQL 데이터베이스를 사용하는 간단한 NodeJS API 작업을 진행하고 개발자의 편의를 위해 일부 도구를 설정합니다.\n\n다음은 설정입니다:\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS에서 API를 빌드하기 위해 NestJS를 사용할 예정입니다. NestJS는 상당히 유연한 프레임워크로 ExpressJS 원칙에 기반을 두고 있어 NodeJS 서비스를 쉽고 빠르게 개발할 수 있게 해줍니다. 이 프레임워크에는 여러 가지 편의 기능 (전체 TypeScript 지원, 의존성 주입, 모듈 관리 등)이 내장되어 있습니다.\n\n더 많은 정보를 보려면 여기 웹사이트를 방문해보세요: http://nestjs.com\n\n프로젝트와 도구\n\nNestJS는 보일러플레이트를 처리해주는 멋진 CLI 도구를 함께 제공하여 작업을 빠르게 시작할 수 있습니다. 개인적으로 CLI에서 생성된 NestJS 프로젝트가 완벽한 시작점이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 블랙 매직 코드는 실제로 무엇을 하는지 알지 못한 채 조정하거나 확장하려고 할 때 문제가 될 수 있습니다. 그래서 저는 항상 아주 작게 시작하고 필요한 기능을 시간이 지남에 따라 추가하고 배우는 것을 선호합니다. 필요하지 않거나 이해하지 못하는 많은 기능이 있는 오버블로운 스타터 프로젝트를 사용하지 않는 것이죠.\n\n프로젝트 준비하기 — 보일러플레이트\n\n좋아요, 이 몇 줄로 프로젝트를 생성하여 시작해보죠:\n\n```js\nnpm i -g @nestjs/cli\nnest new project-name\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 내용은 NestJS 및 CLI에 대해 여기에서 찾아볼 수 있어요.\n\n귀하의 프로젝트는 다음과 같이 보일 것입니다:\n\n![project image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_1.png)\n\n지금까지 모든 작업이 잘 되는지 테스트해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run start:dev\n```\n\n이제 프로젝트 기본 설정이 완료되었으니, 데이터 영속성 레이어를 추가해 봅시다.\n\n데이터베이스 스키마를 관리하기 위해 TypeORM을 사용할 것입니다. TypeORM의 장점은 TypeScript로 데이터 엔티티를 모델링할 수 있으며, 이후 이러한 모델을 데이터베이스의 테이블 구조로 적용하거나 동기화할 수 있다는 것입니다. (물론 PostgreSQL 데이터베이스뿐만 아니라 다른 데이터베이스와도 작동합니다. TypeORM 문서에서 지원하는 데이터베이스에 대한 자세한 정보 찾아보세요.)\n\n로컬 PostgreSQL 데이터베이스 인스턴스 설정 - 도커 자동화와 함께!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 데이터 지속성 작업을 위해 데이터베이스 서버와 연결해야 합니다. PostgreSQL 데이터베이스 서버를 로컬 머신에 설정해야 하는 방법 중 하나가 있지만, 저는 이 방법을 크게 선호하지 않아요. 왜냐하면 프로젝트가 내 머신에 많이 종속될 수 있기 때문이죠. 즉, 팀으로 프로젝트를 진행하거나 머신을 바꾸면 매번 다시 설정해야 하거나 어떻게든 설정 가이드를 작성해야 합니다 (서로 다른 운영 체제를 사용하는 머신에서는 더욱 까다로워집니다).\n\n그렇다면 우리는 어떻게 이 문제를 해결할 수 있을까요? 자동화를 통해!\n\n미리 구축된 PostgreSQL 도커 이미지를 사용하고 데이터베이스 서버를 도커 프로세스로 실행합니다. 이렇게 하면 몇 줄의 셸 코드로 전체 설정을 스크립팅하여 서버 인스턴스를 실행하고 연결할 준비가 끝난 빈 데이터베이스를 준비할 수 있습니다. 이것은 재현 가능하고 설정 코드를 프로젝트 코드의 나머지와 함께 소스 제어로 관리할 수 있어, 다른 개발자들이 프로젝트에 빠르게 참여할 수 있도록 만들어줍니다.\n\n이 스크립트는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 package.json 실행 스크립트에 그 명령어를 추가해서 쉽게 실행할 수 있도록 합시다.\n\n```js\n\"start:dev:db\": \"./src/scripts/start-db.sh\"\n```\n\n좋아, 이제 실행할 수 있는 명령어가 생겼고 데이터베이스 서버와 기본 데이터베이스가 설정됩니다.\n\n프로세스를 더 견고하게 만들기 위해 항상 도커 컨테이너에 동일한 이름($SERVER 변수 스크립트에서)을 사용할 거에요. — 이렇게 하면 추가적인 확인을 추가할 수 있어요 — 만약 컨테이너가 이미 실행 중이면 종료하고 제거해서 깔끔한 상태를 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS를 데이터베이스에 연결하는 방법\n\n모든 것을 위해 이미 NestJS 프로젝트를 데이터베이스에 연결하는 데 도움이 되는 NPM 모듈이 있습니다. 우리 프로젝트에 사전 빌드된 NestJS-to-TypeORM 모듈을 사용하여 TypeORM 지원을 추가해 봅시다.\n\n다음과 같이 필요한 모듈을 추가할 수 있습니다:\n\n```js\nnpm install --save @nestjs/typeorm typeorm pg\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보는 NestJS 문서에서 찾을 수 있어요.\n\n구성 관리\n\n이제 모든 것을 하나로 묶는 시간입니다.\n\nNestJS에서 TypeORM에게 어떤 데이터베이스 서버에 연결해야 하는지 알려주는 방법은 TypeOrmModule을 사용하는 것이에요.\nforRoot 메소드를 사용하여 구성을 전달할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것을 잘 작동시키려면 다음과 같이 설정 서비스를 작성할 수 있습니다.\n\n이 config 클래스의 아이디어는 API 서버 main.ts가 시작되기 전에 실행되도록 하는 것입니다. 이 클래스는 환경 변수에서 구성을 읽어오며, 실행 중에 읽기 전용으로 값을 제공할 수 있습니다.\n\n개발 및 운영 모드에 유연하게 대응하기 위해 dotenv 모듈을 사용할 것입니다.\n\n```js\nnpm install --save dotenv\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모듈을 사용하면 로컬 개발 환경의 프로젝트 루트에 \" .env\" 파일을 만들어 구성 값을 준비할 수 있고, 프로덕션 환경에서는 프로덕션 서버의 환경 변수에서 값만 읽어올 수 있습니다. 이는 매우 유연한 방식이며 이 파일을 팀 내 다른 개발자들과 쉽게 공유할 수도 있습니다.\n\n참고: 그러나 이 파일을 git으로 무시하는 것을 강력히 권장합니다. 이 파일에 실제 비밀 정보를 넣을 수 있기 때문에 프로젝트 외부로 누설되거나 실수로 커밋하는 것을 원하지 않을 것입니다.\n\n아래는 .env 파일이 어떻게 보일 수 있는지에 대한 예시입니다:\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=5432\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=mysecretpassword\nPOSTGRES_DATABASE=my_database\nPORT=3000\nMODE=DEV\nRUN_MIGRATIONS=true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 ConfigService는 싱글톤 서비스로 실행되며 시작할 때 구성 값을 로드하여 다른 모듈에 제공합니다. 서비스에는 오류 조기 패턴이 포함됩니다. 즉, 해당 서비스가 제공할 수없는 값에 대해 요청을하면 의미 있는 오류를 throw합니다. 이렇게 함으로써 구성 오류를 런타임 라이프사이클이 아닌 빌드/부트 시간에 감지하여 설정이 더 견고해집니다. 이렇게하면 서버를 배포/시작 할 때가 아닌 소비자가 API를 사용할 때 이것을 일찍 감지할 수 있습니다.\n\n이것이 ConfigService의 모습이며, NestJS 앱 모듈에 추가하는 방법입니다:\n\n이제 첫 번째 테스트를 시작할 준비가 거의 완료되었지만, 실제로 개발 시 TypeScript에서 작업하려면 nodemon과 함께 ts-node를 사용할 것이므로 특별한 nodemon.json을 사용하여 typescript 컴파일러를 활성화하는 ts-node 모듈을 사용하여 개발 서버를 실행할 수 있습니다. 그러니까 nodemon과 ts-node를 설치합시다.\n\n```sh\nnpm i --save-dev nodemon ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉토리에 debug 및 ts-node 지원이 포함된 nodemon.json 파일을 추가해주세요.\n\n```js\n{\n \"watch\": [\"src\"],\n \"ext\": \"ts\",\n \"ignore\": [\"src/**/*.spec.ts\"],\n \"exec\": \"node --inspect=127.0.0.1:9223 -r ts-node/register -- src/main.ts\",\n \"env\": {}\n}\n```\n\n마지막으로 package.json 파일의 start:dev 스크립트를 다음과 같이 수정해주세요:\n\n```js\n\"start:dev\": \"nodemon --config nodemon.json\",\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 API 서버를 시작하기 위해 npm run start:dev를 실행할 수 있어요. 시작 시 ConfigService에서 .env 값들을 가져와 데이터베이스에 TypeORM이 연결될 겁니다. 또한, 이 작업은 제 컴퓨터에 바운드되어 있지 않아요. 멋지죠!\n\n데이터 모델 엔티티를 정의하고 로드해봅시다.\n\nTypeORM은 데이터 모델 엔티티의 자동 로딩을 지원해요. 단순히 모든 엔티티를 한 폴더에 넣고 구성에서 패턴을 사용하여 로드할 수 있어요. 저희는 model/`name`.entity.ts에 엔티티를 넣었어요. (ConfigService의 TypeOrmModuleOptions의 entities 속성을 참고해주세요)\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeORM의 또 다른 멋진 기능은 Entity 모델들이 상속을 지원한다는 것입니다.\n\n예를 들어 특정 데이터 필드가 모든 엔티티에 있도록 원한다면 정말 멋진 기능입니다.\n\n예를 들어, 자동으로 생성된 UUID id 필드와/또는 createDateTime, lastChangedDateTime 필드 등이 있습니다.\n참고: 이러한 베이스 클래스들은 추상적이어야 합니다.\n\n따라서 TypeORM에서 데이터 모델 엔티티를 정의하면 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 지원되는 데이터 어노테이션을 TypeORM 문서에서 찾아보세요.\n\n파티 시간이에요 — API를 시작하고 작동하는지 확인해 봅시다.\n\n```js\nnpm run start:dev:db\nnpm run start:dev\n```\n\n… 멋지네요 — 작동하는 것 같지만, 사실 데이터베이스는 아직 데이터 모델을 반영하지 않았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 스키마를 적용하고 데이터베이스 마이그레이션을 생성하고 실행하세요.\n\n이전에 언급했듯이, TypeORM은 데이터 모델을 데이터베이스의 테이블로 동기화하는 기능을 제공합니다.\n\n이 모델의 동기화는 좋지만 위험할 수도 있습니다.\n\n왜냐하면 초창기 개발 단계에서는 좋습니다. 모든 데이터 엔티티가 아직 확정되지 않았기 때문입니다. 그래서 코드에서 클래스를 변경하면 모든 것이 데이터베이스에서 잘 동작합니다. 기본적으로 데이터베이스의 상태에 대해 생각할 필요가 그리 많지 않습니다. TypeORM이 모든 일을 대신 처리해 주니까요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기서 tricky한 부분이 나타납니다. 데이터베이스에 실제 데이터가 있을 때는 모든 엔티티 변경에서 손실을 입고 싶지 않습니다. 이것은 조금 더 복잡해집니다. 이 동기화 기능은 데이터베이스 테이블에 필요한 변경 사항을 적용하기 위해 테이블을 삭제하고 다시 생성하는 방식으로 작동합니다. 이는 테이블 내의 데이터가 손실된다는 것을 의미합니다. 당연히 프로덕션 환경에서 피해야 하지만 개발 환경에서도 예상치 못한 부작용을 야기할 수 있습니다.\n\n그래서 저는 개발 초기부터 코드에서 데이터베이스 마이그레이션을 사용하는 것을 선호합니다.\n\n이렇게 함으로써 데이터 세트의 변경 사항을 더 잘 추적하고 이에 대해 더 적극적으로 생각하게 하여 프로덕션 시나리오에서의 변경 및 데이터 손실을 방지하는 데 도움이 됩니다.\n\n그러니 이 문제를 해결해 봅시다 - 다행히 TypeORM에는 이에 대한 솔루션이 포함되어 있고, SQL 명령을 생성하는 작업을 처리하는 'CLI' 명령도 있습니다. 이를 통해 내부에 어떤 마법도 없이 생성된 SQL 명령을 쉽게 확인하고 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 typeORM CLI를 쉽게 설정할 수 있어요.\n\n1. typeORM CLI 설정\n\n이미 ConfigService로 필요한 모든 설정을 추가했어요.\n\n하지만 typeORM CLI는 ormconfig.json 파일과 함께 작동하며 올바른 설정이 있어야 해요. 또한 CLI를 실제 API 서버와 별도로 실행하고 싶어요. CLI를 사용하기 전에 설정 파일을 생성하므로 .gitignore-list에 추가해주세요. 설정 파일을 작성하는 퀵 도우미 스크립트를 추가해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { configService } from '../config/config.service';\nconst fs = require('fs');\nfs.writeFileSync('ormconfig.json',\n JSON.stringify(configService.getTypeOrmConfig(), null, 2)\n);\n```\n\n그리고 npm 스크립트 작업을 추가하여 해당 스크립트를 실행하고 typeorm:migration:generate 및 typeorm:migration:run 명령어를 실행할 수 있습니다.\n\n이렇게 하면 typeORM CLI 명령을 실행하기 전에 ormconfig가 생성됩니다.\n\n```js\n\"pretypeorm\": \"(rm ormconfig.json || :) \u0026\u0026 ts-node -r tsconfig-paths/register src/scripts/write-type-orm-config.ts\",\n\"typeorm\": \"ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js\",\n\"typeorm:migration:generate\": \"npm run typeorm -- migration:generate -n\",\n\"typeorm:migration:run\": \"npm run typeorm -- migration:run\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 마이그레이션 작성\n\n이제 이 명령을 실행하여 초기 마이그레이션을 생성할 수 있습니다:\n\n\nnpm run typeorm:migration:generate -- my_init\n\n\n이 명령은 typeORM을 데이터베이스에 연결하고 데이터베이스 마이그레이션 스크립트 my_init`timestamp`.ts(타입스크립트)를 생성하고 프로젝트의 마이그레이션 폴더에 넣습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 마이그레이션 스크립트를 소스 컨트롤에 커밋하고 파일을 읽기 전용으로 다루어야 합니다. 이 스크립트는 서로 위에 순서대로 작동합니다.\n\n만약 어떤 것을 변경하고 싶다면, cli 명령어를 사용하여 맨 위에 다른 마이그레이션을 추가하는 것이 아이디어입니다.\n\n![migration](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_3.png)\n\n3. 마이그레이션 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run typeorm:migration:run\n```\n\n이 명령어는 아직 적용되지 않은 데이터베이스에 있는 모든 마이그레이션을 적용합니다. (이미 모든 것이 최신 상태인 경우 아무 작업도 수행하지 않음)\n\n이제 API 서버 프로젝트를 실행하지 않고도 마이그레이션을 생성하고 실행하는 데 필요한 모든 도구를 갖추었습니다. 이렇게 하면 원할 때마다 다시 실행하거나 다시 만들거나 추가할 수 있어 개발 시 유연성이 높습니다.\n\n그러나 프로덕션 또는 스테이지 환경에서는 배포 후 API 서버를 시작하기 전에 마이그레이션 스크립트를 자동으로 실행하는 것이 안전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게 하면 start.sh 스크립트를 추가할 수 있어요.\n\n마이그레이션을 자동으로 실행할지 여부를 제어하기 위해 환경 변수 RUN_MIGRATIONS=`0|1`을 추가할 수도 있어요.\n\n```js\n#!/bin/bash\nset -e\nset -x\nif [ \"$RUN_MIGRATIONS\" ]; then\n  echo \"마이그레이션 실행 중\";\n  npm run typeorm:migration:run\nfi\necho \"서버 시작\";\nnpm run start:prod\n```\n\n디버깅 및 데이터베이스 도구\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와우, 우리 API 및 DB 설정이 작동하는 것 같네요! 하지만 우리 데이터베이스가 실제 데이터 모델을 잘 반영하고 있는지 확인해야 해요.\n\n이를 확인하기 위해 CLI 스크립트 쿼리를 실행하거나 빠른 디버깅을 위해 UI 데이터베이스 관리 도구를 사용할 수 있어요.\n\nPostgreSQL 데이터베이스를 사용할 때, 저는 pgAdmin을 사용해요.\n\n이 도구는 현재 상황을 보기 위한 멋진 UI를 제공하는 강력한 도구에요. 그러나 다음과 같은 워크플로우를 추천해 드릴게요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Table Image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_4.png)\n\n이제 데이터베이스에 테이블이 생성된 것을 볼 수 있습니다.\n\n1. 프로젝트에서 정의한 항목 테이블\n2. 이 테이블에서 typeORM이 이미 실행한 마이그레이션을 추적하는 마이그레이션 테이블 (참고: 이 테이블을 읽기 전용으로 처리해야만 합니다. 그렇지 않으면 typeORM CLI가 혼란스러워질 수 있습니다.)\n\n일부 비즈니스 로직 추가중\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 비즈니스 로직을 추가해 봅시다.\n데모를 위해 테이블에 있는 데이터를 반환하는 간단한 엔드포인트를 추가하겠습니다.\n\n이를 위해 항목 컨트롤러와 항목 서비스를 추가할 것이고, NestJS CLI를 사용할 겁니다.\n\n```js\nnest -- generate controller item\nnest -- generate service item\n```\n\n이렇게 하면 우리를 위한 기본 템플릿이 생성되고,\n그런 다음 우리가 추가해야 할 내용은요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'그리고 ItemModule안에서 물건들을 함께 연결하고, 그것을 AppModule에서 가져와요.\n\nAPI를 시작한 후 curl 명령어를 통해 다음을 얻을 수 있어요:\n\n```js\ncurl localhost:3000/item | jq\n[] # \u003c\u003c 데이터베이스에 아이템이 없음을 나타냅니다 - 멋지죠 :)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔티티를 노출하지 마세요 - DTO 및 응답 추가하기\n\n하나의 1대1 데이터 모델을 영속성을 통해 API를 통해 소비자에게 직접 노출시키지 않는 것이 아이디어입니다.\n\n처음 프로젝트를 설정할 때 이것을 바로 하지 않는 것은 처음에는 이점이 직접적으로 보이지 않기 때문에 유혹을 받을 수 있습니다. 물론, 각 데이터 엔티티를 데이터 전송 객체로 래핑해야 하고 직렬화 및 역직렬화를 수행해야 해서 종종 보일러플레이트처럼 느껴질 수 있습니다.\n\n항상 이런 설정을 권장합니다. 따라서 내부 데이터 모델(API to Database)과 외부 모델(API-consumer to API) 사이에 명확한 구분을 두게 됩니다. 이렇게 하면 사물을 분리시키고 장기적으로 유지보수를 더 쉽게할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 이점:\n- 도메인 주도 설계 원칙 적용을 위한 분리\n- 성능, 쿼리 최적화가 훨씬 쉽게 가능\n- 진화, 버전 관리 — 동일한 지속성으로 다른 응답을 반환\n- 테스트 용이성 — 모의(mocking)를 할 수 있음\n… 그리고 훨씬 더 많은 기능\n\n그래서 우리는 데이터베이스의 항목 엔티티에서 채워진 ItemDTO 응답 클래스를 추가할 것입니다.\n간단한 서비스와 응답 DTO는 다음과 같이 보일 수 있습니다.\n\n참고: 이를 위해 `@nestjs/swagger`, `class-validator` 및 `class-transformer`를 설치해야 합니다.\n\n이제 우리는 이 DTO를 간단하게 다음과 같이 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAPI (Swagger) 설정하기\n\nDTO 접근 방식을 통해 API 문서 (openAPI 또는 스웨거 문서)를 생성할 수도 있습니다. 간단히 다음을 설치하면 됩니다:\n\n```js\nnpm install --save @nestjs/swagger swagger-ui-express\n```\n\n그리고 main.ts 파일에 다음 몇 줄을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 다 됐어요:\n\n![이미지 이름](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_5.png)\n\n해당 주제에 대한 자세한 정보는 여기서 확인하세요.\n\n씨드 데이터 정의.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 이제 화려한 비즈니스 로직을 통해 프로젝트를 확장하는 데 필요한 거의 모든 것을 갖췄어요. 프로젝트 작업 시 당신과 팀의 생산성을 실제로 향상시킬 수 있는 것은 데이터 씨드 스크립트입니다.\n\n이 스크립트는 데이터베이스를 테스트용이나 더미 데이터로 설정합니다. 우리는 이미 데이터베이스 서버를 자동으로 생성하고 사용할 수 있는 빈 데이터베이스를 추가했다는 것을 기억하세요. 이제 우리는 해당 데이터베이스에 \"의미 있는 더미 데이터\"를 생성할 수 있는 스크립트를 추가할 거예요. 이것은 개발에 도움이 되며(모두가 동일한 데이터 집합으로 로컬에서 작업하지만, 또한 영속성 상태를 알 수 있기 때문에 테스트 시스템에 대해 통합 테스트 실행도 가능합니다).\n\n우리는 스크립트를 작성하는 방법을, 이미 정의된 모델을 사용하도록 하며(필요하다면 서비스 레이어 등도 사용할 수 있습니다). 제어의 역전, 클래스 생성자에서의 의존성 주입을 통해 프로젝트의 리포지토리와 서비스의 인스턴스를 생성할 수 있습니다. 이렇게 하면 NestJS API 서버를 시작하지 않고도 TypeScript 파일에서 데이터베이스 연결을 제공하여 수동으로 생성할 수 있습니다.\n\n이것은 정말 좋아요 — 이러한 유형의 시험 코드를 실행하여 코드를 시험하면서 실제 서버를 시작하기 전에 독립적으로 시드 프로세스를 실행하며, 시드 스크립트 논리가 실제 비즈니스 로직 코드로 빠져나가지 않으며 오히려 그것을 활용할 수 있습니다. 보통 제가 스크립트를 매우 일반적인 방식으로 작성해서 한 번에 한 번 실행되어도 다른 것에 의존하지 않고 랜덤 값을 무작위로 생성하여 \"시드-id\"를 넣어 작업하는 편입니다. 이렇게 하면 스크립트를 여러 차례 실행하여 계속해서 더 많은 데이터를 생성하지만 매번 실행할 때마다 뭔가 잘못 되지 않음이 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 스크립트에서 데이터베이스 연결을 설정하기 위해서는 작성한 configService를 재사용하고 ts-node 모듈을 사용하여 실행하면 됩니다.\n\n씨드 스크립트는 다음과 같이 생겼을 수 있습니다:\n\n우리는 다음처럼 실행합니다\n\n```js\nnpm run start:dev:db:seed\n# 결과\n# 완료 -\u003e seed2302-1\n# 완료 -\u003e seed2302-2\n# ...스크립트 실행 종료까지 기다립니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI를 시작한 후에는 데이터베이스에서 이 데이터를 가져옵니다.\n\n```js\ncurl localhost:3000/item | jq\n[\n {\n  \"id\": \"393a370b-762b-44fb-9830-9526a1d6a685\",\n  \"name\": \"seed8239-1\",\n  \"description\": \"created from seed\"\n },\n // ...\n]\n```\n\n마지막으로\n\n로컬에서 데이터베이스 상태를 관리하는 모든 도구를 설정하는 방법을 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 설정부터 모델, 후킹, 그리고 데이터베이스 작업까지.\n\n모든 도구는 어떤 식으로든 코드에 의존하며 UI로 가서 버튼을 클릭하여 설정하는 대신에. 이 \"코드\" 접근 방식을 통해 일을 쉽게 복제할 수 있습니다. 새 팀원을 온보딩하거나, 혹은 2년 후 프로젝트를 다시 방문하여 설정 방법을 잊어버렸다면 — 매우 쉽게 처리할 수 있을 것입니다. 시작하려면 단순히 3~4개의 명령을 실행하면 되며 명령이 어떻게 작동하는지 알기 위해서는 프로젝트 파일을 살펴보기만 하면 됩니다. 왜냐하면 모든 것이 코드로 제공되기 때문입니다.\n\n저는 이를 통해 NestJS, typeORM, 그리고 PostgreSQL 데이터베이스와 함께 작업할 때 여러분을 빠르게 출발시킬 수 있었기를 바랍니다. 여러분은 어떠신가요? 비슷하거나 더 나은 도구/접근 방식이 있으신가요? 아래 댓글에 알려주시면 감사하겠습니다!\n\n건배!","ogImage":{"url":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"},"coverImage":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png","tag":["Tech"],"readingTime":14},{"title":"2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드","description":"","date":"2024-06-23 13:57","slug":"2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024","content":"\n\n![Express.js in Action: How to Build an API with Node.js and TypeScript in 2024](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png)\n\n안녕하세요! 이 프로젝트는 여러 포스트로 이어지게 될 거에요. 새로운 파트를 올릴 때 알림을 받으려면 저를 팔로우해 주세요. Node.js와 TypeScript를 사용해 백엔드 개발을 배우고 싶으시다면, 이 시리즈를 확인해보세요. 유용하고 즐거운 정보가 될 거에요.\n\n이 프로젝트에서는 Node.js와 TypeScript를 사용하여 빠르게 API를 구축하겠습니다. Node.js와 TypeScript를 사용하여 API를 처음부터 만드는 방법에 대해 단계별 가이드를 제공할 거에요. 프로젝트에서 다음 기능들을 구현할 예정입니다:\n\n- 프로젝트 구조 설정 및 TypeScript 구성\n- 미들웨어 사용하여 요청 분석 및 응답 전송과 같은 공통 작업 처리\n- 환경 변수를 사용하여 설정 및 비밀 정보 저장\n- 동적 환경\n- 유용한 정보 기록 및 표시하기 위해 로거 사용\n- CORS 활성화 및 기본 인증을 통해 API 보호\n- 유효성 검사 및 예외 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 구조\n\n우리의 프로젝트 구조는 간단하면서도 확장 가능한 구조로, 잘 조직된 코드를 쉽게 확장하고 유지보수할 수 있게 해줍니다. 불필요한 복잡성을 피하며 모든 것을 간단하게 유지합니다.\n\n```js\n-- src\n   -- controllers\n   -- models\n   -- utils\n      -- helpers\n      -- middlewares\n      -- validations\n      -- exceptions\n   -- app.ts\n```\n\n# 프로젝트 초기화 및 TypeScript 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하려면 node 및 npm이 이미 설치되어 있어야합니다. 이 튜토리얼에서는 node v20.11.0 (npm v10.2.4)를 사용할 것입니다. 또한 IDE로 Visual Studio Code를 사용할 것입니다.\n\n- 여기서 node를 설치하세요.\n- 여기서 vscode를 설치하세요.\n- (선택 사항 - bash 터미널을 얻기 위해) 여기서 windows용 git을 설치하세요.\n\n프로젝트를 위한 새 폴더를 만들어 시작하겠습니다. 이것을 node-api-ts로 이름 지을 것입니다. vscode에서 프로젝트 폴더를 열어보세요. 파일을 '열기...'를 통해 열거나 터미널을 사용해서 프로젝트 폴더로 이동하여 다음 명령어를 사용하세요:\n\n```js\ncode .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Ctrl + `를 사용하여 vscode 통합 터미널을 엽니다. 이렇게 하면 기본 터미널이 열릴 것입니다.\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_1.png)\n\n이 튜토리얼에서는 리눅스 및 맥 시스템에서 일반적인 베이시 터미널 명령어를 사용할 것입니다. Windows 사용자는 git bash를 설치하여 유사한 환경을 얻을 수 있습니다. git bash는 베이시 터미널을 에뮬레이트하는 무료 소프트웨어입니다.\n\n# 프로젝트 초기화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 프로젝트 폴더에서 다음 명령어를 사용하여 빈 Node.js 프로젝트를 초기화해보겠습니다. 진행하시기 전에 프로젝트 디렉토리에 있는지 확인해주세요:\n\n```js\nnpm init\n```\n\n앞서 언급한 명령어는 package.json 파일을 생성하기 위해 몇 가지 질문을 통해 새로운 Node.js 패키지/프로젝트를 초기화합니다. 기본적으로 index.js를 덮어씌우기 위해 entry point를 build/app.js로 변경해야 합니다. TypeScript를 사용하기 때문에 나중에 해당 내용을 알아보겠습니다.\n\n```js\npackage name: (api-ts) node-api-ts\nversion: (1.0.0) \ndescription: API with Node.js and TypeScript\nentry point: (index.js) build/app.js\ntest command: \ngit repository: \nkeywords: node.js,express,api,typescript\nauthor: Mahmoud Kassem\nlicense: (ISC) \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더를 확인해보세요. 아마 이와 유사한 내용을 찾을 수 있을 거에요:\n\n```js\n{\n  \"name\": \"node-api-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API with Node.js and TypeScript\",\n  \"main\": \"build/app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n  },\n  \"keywords\": [\n    \"node.js\",\n    \"express\",\n    \"api\",\n    \"typescript\"\n  ],\n  \"author\": \"Mahmoud Kassem\",\n  \"license\": \"ISC\"\n}\n```\n\n# 의존성 설치\n\n무언가를 시작하기 전에 먼저 사용할 종속성(dependancies) 및 개발 종속성(devDependancies)을 나열하고 각각의 사용 목적을 설명해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성(dependencies):\n\n- express: 우리의 API를 구축하는 노드.제이에스 API 프레임워크\n- cors: 프로젝트에서 교차 출처를 활성화함\n- dotenv: .env 파일에서 환경 변수를 읽어 동적 환경을 생성함\n- helmet: 응답 헤더에서 민감한 데이터를 제거하여 API를 보호함\n- morgan: 디버깅 및 모니터링 앱 활동을 위한 로깅 미들웨어\n\n개발 의존성(devDependencies):\n\n- typescript: 코드를 빌드하여 JavaScript로 변환하는 데 사용\n- types (@types/express, @types/helmet, @types/morgan, @types/dotenv): 자바스크립트 생태계의 일부 패키지는 자체 유형 정의를 제공하지 않아 TypeScript 개발자가 사용하기 어렵게 만들 수 있습니다. 다행히 이러한 패키지를 위한 유형 정의를 제공하는 @types 선언 패키지가 있습니다. 예를 들어, @types/express, @types/helmet, @types/morgan 및 @types/dotenv는 각각 express, helmet, morgan 및 dotenv에 대한 유형 정의를 제공하는 선언 패키지입니다. 이러한 선언 패키지를 devDependencies로 설치하고 TypeScript 코드에서 가져와서 해당 패키지에 대한 유형 검사와 코드 완성을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 종속성을 먼저 설치하세요 — 여러 개의 패키지를 설치할 때는 각 패키지 이름 사이에 공백을 사용하면 됩니다:\n\n```js\nnpm install express cors dotenv helmet morgan\n```\n\n그런 다음 다음 명령어를 사용하여 개발용 종속성을 설치하세요:\n\n```js\nnpm install --save-dev typescript @types/express @types/cors @types/dotenv @types/helmet @types/morgan\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json 파일을 확인했다면, 설치된 패키지와 그 버전이 업데이트되었음을 알 수 있습니다. 또한 프로젝트에 node_modules와 package-lock.json이 추가된 것을 발견하게 될 거에요.\n\nnode_modules 폴더 안에는 설치된 의존성이 포함되어 있습니다. 그리고 그 의존성의 종속 항목을 찾아볼 수 있습니다. 이 파일들은 우리가 만들고 있는 것과 유사한 노드 패키지입니다.\n\npackage-lock.json은 노드 패키지 매니저(npm)에 의해 자동으로 생성됩니다. 이 파일은 모든 의존성 및 이에 대한 트리의 정확한 버전을 저장합니다. 프로젝트에서 어떤 종속성을 설치하거나 업데이트할 경우 업데이트될 거에요.\n\n## TypeScript 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js는 JavaScript의 런타임으로, 개발자들이 확장 가능하고 효율적인 웹 애플리케이션을 만들 수 있게 합니다. TypeScript는 JavaScript의 슈퍼셋으로, 정적 유형 지정, 객체 지향 프로그래밍, 데코레이터 등의 기능을 추가합니다. 그러나 TypeScript 코드는 Node.js에서 직접 실행되지 않고 먼저 JavaScript로 컴파일해야 합니다.\n\n우리 프로젝트에서 TypeScript를 지원하려면, 먼저 그것을 구성해야 합니다. 아래 명령을 사용하여 구성 파일을 초기화하십시오. 나중에 이 파일을 수정하여 일부 기본값을 변경할 것입니다:\n\n```js\nnpx tsc --init\n```\n\n이전 명령은 다음 내용을 출력할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n다음은 TypeScript의 기본 구성이지만 변경할 수 있습니다. tsconfig.json이라는 새 파일이 생성된 것을 알 수 있을 거에요.\n\n이전에 설정한 프로젝트 폴더 구조에 맞추기 위해 일부 기본값을 수정할 거에요.\n\nrootDir 주석 처리를 해제하고 값을 ./src로 변경해주세요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n...\n\"rootDir\": \"./src\",\n...\n}\n```\n\n이 명령은 프로젝트의 루트 디렉토리를 설정합니다. 이는 TypeScript가 이 폴더 내에만 .ts 파일을 찾도록 하는 것을 의미합니다.\n\noutDir를 주석 처리해제하고 값으로 ./build를 변경하세요.\n\n```js\n{\n...\n\"outDir\": \"./build\",\n...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 transpiled TypeScript의 기본 출력 디렉터리를 변경합니다.\n\n— 이전 파트는 프로젝트 폴더 이름에 따라 변경할 수 있습니다. src를 app, source 또는 다른 이름으로 변경할 수 있지만, 그러면 rootDir을 선택한 폴더 이름과 일치하도록 변경해야 하며 outDir도 동일합니다.\n\n# Express 서버\n\n이제 코드를 작성해 보겠습니다. 전체 프로젝트의 첫 번째 파일 및 주 파일을 만들어 보겠습니다. npm을 사용하여 노드 프로젝트를 초기화하고 일치하는 엔트리 포인트를 build/app.js로 선택했던 것을 기억하십니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.ts 파일을 생성하여 이 파일로 컴파일될 것입니다. 그래서 먼저 해야 할 일은 소스 폴더를 생성하는 것입니다. src 폴더를 루트 디렉토리로 설정한 다음, ./src/app.ts 라는 새 파일을 만들어야 합니다. 그 안에 다음과 같은 코드를 작성해 봅시다.\n\n```js\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport morgan from 'morgan';\n\n// Express 서버 생성\nconst app = express(); // 새 express 인스턴스\nconst port = 3000; // 포트 번호\n\n// Express 설정\napp.use(cors()); // CORS 활성화\napp.use(helmet()); // Helmet 활성화\napp.use(morgan('dev')); // Morgan 활성화\n\n// Express 서버 시작\napp.listen(port, () =\u003e {\n  // 서버가 성공적으로 시작되면 콜백 함수 실행\n  console.log(`서버가 http://localhost:${port} 에서 시작되었습니다.`);\n});\n\n// Express 앱 내보내기\nexport default app;\n```\n\n이전 코드에서는 express 서버 인스턴스를 생성하고 몇 가지 (선택적) 미들웨어로 구성했습니다. 이를 통해 보안, 모니터링 및 디버깅을 개선할 수 있습니다.\n\n이제 다음 명령어를 실행하여 응용 프로그램을 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx tsc \u0026\u0026 node .\n```\n\n이제 터미널에서 다음 줄로 끝나는 출력을 확인해야합니다:\n\n```js\n서버가 http://localhost:3000에서 시작되었습니다\n```\n\n이것은 서버가 성공적으로 시작되었음을 보여주는 콜백 함수의 텍스트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 첫 번째 라우트 생성하기\n\n이제 우리는 애플리케이션을 구성하고 시작했지만 아직 기능이 없습니다. API를 구축해야 하므로 몇 가지 라우트를 생성해야 합니다.\n\n아래 코드는 express의 get() 메서드를 사용하여 경로 / 에 대한 리스너를 만들고 간단한 Hello World! 문자열을 반환합니다.\n\nStart Express Server 코드 블록 앞에 다음 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Express 라우트 정의\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World!');\n});\n```\n\n이제 터미널로 이동해서 현재 프로세스를 Ctrl + C로 중지한 후 npx tsc \u0026\u0026 node . 명령어를 입력하여 다시 빌드하고 서버를 시작합니다.\n\n이제 새로 만든 라우트를 테스트해보겠습니다. GET 요청을 테스트하기 때문에 http://localhost:3000을 열어보면 다음 출력이 표시됩니다:\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 하셨습니다! 첫 번째 라우트를 만드셨네요.\n\n이 튜토리얼에서 사용된 소스 코드가 포함된 레포지토리입니다. 새 커밋이 있는 경우마다 업데이트될 예정이에요. mahkassem/node-api-ts\n\n2부를 보려면 (여기를 클릭해주세요)","ogImage":{"url":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"},"coverImage":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png","tag":["Tech"],"readingTime":8},{"title":"TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법","description":"","date":"2024-06-23 13:56","slug":"2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow","content":"\n\n\n![Functional Programming in TypeScript](/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png)\n\n함수형 프로그래밍 (FP)은 코드 품질, 유지 보수성, 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 조작이 높은 복잡한 도메인에서는 더 그렇습니다. TypeScript의 경우, 강력한 유형 시스템을 통해 고급 FP 기술을 처리할 수 있어 데이터의 모델링과 처리를 정확하고 효율적으로 수행할 수 있습니다. 금융 응용 프로그램을 예로 들어 주요 FP 개념을 살펴보겠습니다.\n\n# 주요 함수형 프로그래밍 원칙\n\n- 순수 함수: 동일한 입력에 대해 동일한 출력을 생성하며 부작용이 없는 함수입니다. 순수 함수는 동일한 입력을 사용하면 일관성있게 동일한 출력을 반환하며 범위 외부의 상태를 변경하지 않고 가변 상태에 의존하지 않습니다. 이러한 예측 가능성으로 순수 함수는 테스트 가능하고 신뢰할 수 있으며 프로그램 동작에 대한 추론을 용이하게 하고 디버깅을 단순화합니다.\n- 불변성: 데이터 구조를 변경하지 않고 새로운 구조를 생성해야 합니다. 데이터 구조의 불변성은 한 번 생성된 데이터 구조를 변경할 수 없음을 보장합니다. 기존 구조를 수정하는 대신 새 구조를 만듭니다. 불변성은 상태 관련 문제를 피하면서 동시성을 향상시킵니다.\n- 일급 및 고차 함수: 함수를 인수로 전달하거나 다른 함수로부터 반환하고 변수에 할당할 수 있습니다. 이 기능은 모듈화와 코드 재사용을 도와주며 더 추상적이고 유연한 코드를 만들 수 있습니다. 고차 함수를 사용하여 개발자는 표현적인 방식으로 복잡한 작업을 수행하여 더 깨끗하고 유지보수가 쉬운 코드베이스를 만들 수 있습니다.\n- 함수 합성: 더 간단한 함수들을 결합하여 복잡한 함수를 구축합니다. 이 기술을 사용하면 기본 작업을 연결하여 복잡한 기능을 만들 수 있으며 고수준의 추상화를 유지할 수 있습니다. 함수 합성은 코드 재사용과 명확성을 촉진하며 각 함수를 단독으로 테스트하고 이해하고부터 큰 워크플로에 통합되기 전까지 더 자세히 이해할 수 있습니다.\n- 선언적 코드: 제어 흐름을 명시적으로 설명하지 않고 로직을 표현합니다. 선언적 코드는 계산 논리를 세세하게 설명하지 않고 제어 흐름을 자세히 설명하지 않습니다. 명령형 프로그래밍과 달리 목표를 달성하기 위한 명시적 단계를 지정하는 대신 선언적 프로그래밍은 프로그램이 달성해야 하는 것을 기술합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함수형 프로그래밍을 위한 TypeScript 기능들\n\n- 정적 타입 및 타입 추론: 컴파일 시에 정확성을 보장하고 오류를 감지합니다.\n- 제너릭: 유연하고 재사용 가능한 데이터 구조와 함수를 생성할 수 있습니다.\n- 합집합 및 교집합 타입: 정확한 타입 정의를 가능하게 하며 복잡한 데이터를 조합할 수 있습니다.\n- 맵핑 타입 및 조건부 타입: 데이터 변환 및 타입 조작에 강력한 도구를 제공합니다.\n\n# 모델링에서의 대수형 데이터 타입 (ADTs)\n\nADTs는 복잡한 데이터 구조를 효과적으로 표현하며 각각의 독특한 특성과 행위를 포착할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype Currency = 'EUR' | 'USD';\n\ninterface Cash {\n    type: 'cash';\n    amount: number;\n    currency: Currency;\n}\n\ninterface Stock {\n    type: 'stock';\n    ticker: string;\n    quantity: number;\n}\n\ninterface Credit {\n    type: 'credit';\n    isin: string;\n    maturity: Date;\n    faceValue: number;\n    interestRate: number;\n}\n\ntype Element = Cash | Stock | Bond;\n\nconst calculateValue = (instrument: Element, exchangeRates: Record\u003cCurrency, number\u003e): number =\u003e {\n    switch (instrument.type) {\n        case 'cash':\n            return instrument.amount * exchangeRates[instrument.currency];\n        case 'stock':\n            // Some complex value calcuation\n            return instrument.quantity * 100;\n        case 'credit':\n            // Some complex value calcuation\n            return instrument.faceValue * (1 + instrument.interestRate / 100);\n        default:\n            throw new Error('Unknown financial instrument');\n    }\n};\n```\n\n## 재미있는터와 모나드를 활용한 금융 계산\n\n재미있는터와 모나드(부작용 핸들러)는 금융 데이터를 처리하고 선택적 값, 오류 및 비동기 작업을 다루는 계산을 관리합니다.\n\n```js\ntype Option\u003cT\u003e = None | Some\u003cT\u003e;\n\nclass None {\n    readonly tag = 'None';\n}\n\nclass Some\u003cT\u003e {\n    readonly tag = 'Some';\n    constructor(public value: T) {}\n}\n\nconst none = new None();\nconst some = \u003cT\u003e(value: T): Option\u003cT\u003e =\u003e new Some(value);\n\nconst mapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e U): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? some(fn(opt.value)) : none;\n\nconst flatMapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e Option\u003cU\u003e): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? fn(opt.value) : none;\n\nconst calculateInterest = (amount: number, rate: number): Option\u003cnumber\u003e =\u003e\n    rate \u003e= 0 ? some(amount * rate) : none;\n\nconst result = flatMapOption(some(1000), amount =\u003e calculateInterest(amount, 0.05));\nconsole.log(result); \n// Should be....\n// Some { tag: 'Some', value: 50 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 금융 데이터 조작을 위한 렌즈\n\n렌즈는 데이터 구조의 일부에 초점을 맞추어 조작 가능한 데이터를 제공합니다.\n\n```js\ntype Lens\u003cS, A\u003e = {\n    get: (s: S) =\u003e A;\n    set: (a: A, s: S) =\u003e S;\n};\n\nconst lens = \u003cS, A\u003e(getter: (s: S) =\u003e A, setter: (a: A, s: S) =\u003e S): Lens\u003cS, A\u003e =\u003e ({\n    get: getter,\n    set: setter,\n});\n\ntype Portfolio = {\n    owner: string;\n    instruments: FinancialInstrument[];\n};\n\nconst instrumentsLens = lens(\n    (p: Portfolio) =\u003e p.instruments,\n    (instruments, p) =\u003e ({ ...p, instruments })\n);\n\nconst addInstrument = (portfolio: Portfolio, instrument: FinancialInstrument): Portfolio =\u003e {\n    const instruments = instrumentsLens.get(portfolio);\n    return instrumentsLens.set([...instruments, instrument], portfolio);\n};\n\nconst myPortfolio: Portfolio = { owner: 'Rass', instruments: [] };\nconst updatedPortfolio = addInstrument(myPortfolio, { kind: 'cash', amount: 1000, currency: 'USD' });\nconsole.log(updatedPortfolio); \n// 예상 출력 결과...\n// 현금 계기가 추가된 포트폴리오\n```\n\n# 실용적 예시: 금융 데이터 처리 파이프라인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 금융 데이터를 가져 와서 처리하고 리스크 분석을 수행해야 하는 작업을 고려해 보세요.\n\n## 금융 데이터 가져오기\n\n```js\nconst fetchStockPrices = async (): Promise\u003cOption\u003cRecord\u003cstring, number\u003e\u003e\u003e =\u003e {\n    return some({ 'AAAA': 150, 'BBBB': 2800 });\n};\n\nconst fetchExchangeRates = async (): Promise\u003cOption\u003cRecord\u003cCurrency, number\u003e\u003e\u003e =\u003e {\n    return some({ 'EUR': 1.2, 'USD': 1 });\n};\n```\n\n## 데이터 처리와 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 데이터를 결합합니다.\n\n```js\nconst processFinancialData = async (): Promise\u003cOption\u003c{ stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }\u003e\u003e =\u003e {\n    const stockPrices = await fetchStockPrices();\n    const exchangeRates = await fetchExchangeRates();\n\n    return flatMapOption(stockPrices, stocks =\u003e\n        mapOption(exchangeRates, rates =\u003e ({ stocks, rates }))\n    );\n};\n\nprocessFinancialData().then(data =\u003e console.log(data));\n```\n\n## 위험 분석\n\n결합된 데이터에 대한 위험 분석을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst analyzeRisk = (data: { stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }): string =\u003e {\n    const totalValue = Object.values(data.stocks).reduce((acc, price) =\u003e acc + price, 0);\n    return totalValue \u003e 5000 ? 'High Risk' : 'Low Risk';\n};\n\nconst performRiskAnalysis = async () =\u003e {\n    const data = await processFinancialData();\n    const riskLevel = mapOption(data, analyzeRisk);\n    // The riskLevel variable here is an option holding the result.\n    console.log(riskLevel);\n};\n\nperformRiskAnalysis();\n```\n\n함수형 프로그래밍 개념인 ADT, 펑터, 모나드, 렌즈와 같은 것들을 사용하여 가독성이 좋고 확장 가능한 금융 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"},"coverImage":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png","tag":["Tech"],"readingTime":7},{"title":"ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드","description":"","date":"2024-06-23 13:55","slug":"2024-06-23-UsingESLintHuskyLint-staged","content":"\n\n저는 새로운 회사에 프론트엔드 개발자로 합류했어요!\n\n하지만 여기서 또 다시 시작되는군요 — 완벽한 코드 스타일을 위한 영원한 탐험이라니...\n\n제 개인적인 생각으로는 이 방대한 코딩 우주에서 '나쁜 코드'란 존재하지 않는다고 확신하고 있어요. 각자가 고유한 스타일을 갖고 있으니까 말이에요.\n\n그렇지만 5명 이상이 참여하는 프로젝트에서 각자 다른 스타일로 코딩한 걸 보면, 특히 네이밍 규약과 함수 이름 (사실 패턴까지도)에 다양한 스타일이 있음을 알게 되었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 회사에 새로 합류한 입장에서는 코드를 이해하는 데 시간이 걸렸는데, 이러한 시간을 최소화하기 위해 이름 규칙을 적어도 일관되게 적용할 방법에 대해 생각하기 시작했습니다.\n\n![이미지](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png)\n\n물론, 우리는 일반적으로 알려진 ESLint와 Prettier를 사용하고 있었습니다. 그러나 체크를 실행하지 않고 푸시하는 등 실수가 발생한 경우가 있었습니다.\n\n사실, 이는 이 두 도구의 사용을 무효화시키는 결과를 초래합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에는 VSCode와 같은 IDE가 팝업 알림을 제공하지만, 커밋하기 전에 추가적인 확인을 하는 것도 나쁘지 않은 생각이에요. \n\n그래서, 커밋 전에 코드 스타일을 확인하는 라이브러리 husky를 사용해보자는 아이디어를 생각해냈어요. 이렇게 하면 더 편리할 거에요.\n\n추가적인 단계로, ESLint를 사용자 정의하여 내 규칙이나 회사별 규칙을 설정해볼 생각이에요!\n\n먼저, 대부분의 분들이 이미 알고 있을 것 같지만, ESLint와 Prettier가 무엇인지 간단히 설명드리겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ESLint: 코드의 수호천사 👼\n\nESLint를 만나보세요 — 당신의 신뢰할 수 있는 리터입니다. 그것은 하루를 구해주는 친구와 같아요!\n코드를 위한 문법 검사기를 가지고 있는 것 같아요.\nESLint는 교묘한 구문 오류를 잡는 것뿐만 아니라 일관된 코드 스타일을 위해 매치메이커 역할을 하며, 당신의 코드가 최상급인지 확인합니다. 🌟\n\n## Prettier: 코드 스타일리스트 ✨\n\n코드베이스를 위한 패션 관리자가 있는 것 같아요.\nPrettier는 코드를 새롭게 꾸며주는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 두 가지 도구는 때때로 구성 사항 간의 충돌로 이어져있는 코드 스타일과 관련된 측면을 다룹니다. 이러한 충돌을 처리하는 것이 중요합니다.\n\n자, 이 글의 주요 내용인 Husky에 대해 살펴봅시다.\n\n## Husky\n\n이전에 논의한 바와 같이 Husky는 git commit이나 git push와 같은 중요한 Git 이벤트가 발생하기 전에 지정된 스크립트를 실행하는 데 도움이 되는 다재다능한 라이브러리입니다. 이 고급 도구는 사실상 지휘자 역할을 하여 Git 내에서의 작업 흐름을 안내하고 개발자가 개발 과정을 보다 세밀하게 통제할 수 있도록 돕습니다. Husky는 Git 이벤트 사이에 전략적으로 배치된 후크를 구현하여 작동하며 작업 흐름을 섬세하게 조정할 수 있게 합니다. 이런 제어된 이벤트 저지 기법 패러다임은 보통 git 후크 관리로 불립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## lint-staged\n\n깃에서 스테이징의 개념은 lint-staged의 가치를 이해하는 데 기초를 제공합니다. 코드 린트 활동을 수행할 때 개발자들은 종종 검사할 파일을 수동으로 지정해야 하는 선택을 직면할 수 있습니다. - 이는 잠재적으로 고통스러운 노력일 수 있습니다 - 또는 전체 프로젝트 저장소를 검토에 노출시킬 수 있습니다.\n그러나 프로젝트가 규모가 커질수록 복잡성도 증가합니다.\n이러한 맥락에서, 감독은 점점 걱정거리가 되며, 린트 과정 중 실수로 빠뜨린 파일이 상당히 많이 발생할 수 있습니다.\nlint-staged는 코드 품질 보증 분야에서 세련되고 전략적인 협업자입니다. 깃 add를 사용하여 스테이징 상태로 전환된 파일만 엄밀히 검사함으로써, lint-staged는 감독을 방지하고 린팅 정밀도와 효율성을 향상시키는 아주 우아한 해결책을 제공합니다.\n\n실용적인 사용법을 알아보겠습니다!\n\n## husky \u0026 lint-staged 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHusky 및 lint-staged을 설치하세요\n\n```js\nnpx mrm lint-staged\n```\n\n위 명령어를 실행하면 .husky라는 이름의 폴더가 생성되고 package.json 파일에 코드가 추가됩니다.\n\n```js\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  ...\n  \"lint-staged\": {\n    \"*.js\": \"eslint --cache --fix\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## husky 설정하기\n\nmrm은 다운로드 시 기본 구성을 제공하기 때문에 별도로 구성할 것이 별로 없습니다. 그러나 재미를 위해 몇 가지 사용자 정의 문구를 셸 스크립트에 추가했습니다. (?)\n\n## lint-staged 설정하기\n\nlint-staged의 구성은 사용 중인 프로그래밍 언어에 따라 다를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나의 경우에는 TypeScript를 사용하고 있기 때문에 별도로 설정해주어야 했습니다.\n\n```js\n\"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --max-warnings 0 .\"\n    ]\n}\n```\n\n처음에는 경고를 완전히 무시하고 싶지 않았기 때문에 --max-warnings 0을 포함시켰습니다.\n\n당신의 상황에 따라 제거하는 것도 고려해볼 수 있어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 실행하면 아래와 같이 Husky가 원활하게 작동하는 것을 확인할 수 있습니다.\n\n```bash\ngit commit -m 'husky work'\n```\n\n# 💀\n\n\u003cimg src=\"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 😎\n\n![Image](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_2.png)","ogImage":{"url":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"},"coverImage":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png","tag":["Tech"],"readingTime":4},{"title":"OpenAI 기능 호출로 훈련 데이터 생성하는 방법","description":"","date":"2024-06-23 13:54","slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"/\u003e\n\n머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\n\n(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"/\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 이 기능을 사용해야 하나요?\n\nOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\n\n# 나의 동기\n\n최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OpenAI를 사용하여 데이터 라벨링하기\n\n먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\n\nOpenAI에 적절한 컨텍스트 제공하기:\n\n- 명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\n- 프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 `blog post content...` 라벨을 추가하세요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\n\n- 도구에 대한 자세한 설명을 제공해주세요.\n- 응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\n\n스키마에 의해 정의된 함수를 작성해주세요:\n\n- 이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\n\n# 간단한 코드 예제 살펴보기\n\n여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\n\n이 예제에서는 어떤 텍스트에 [`긍정적`, `부정적`, `중립적`] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {ITool, ToolSchema} from './interfaces/tool.interface';\nimport {ToolUtils} from \"../utils/tool-utils\";\nimport * as path from 'path';\nimport {createObjectCsvWriter as createCsvWriter} from 'csv-writer';\n\nexport class LabelTool implements ITool\u003cstring[], { inputText: string }\u003e {\n    private csvWriter;\n\n    constructor(private readonly labels: string[] = ['positive', 'negative', 'neutral'], private readonly csvFilePath: string = path.join('labeled_text.csv')) {\n        this.csvWriter = createCsvWriter({\n            path: this.csvFilePath,\n            header: [\n                {id: 'label', title: 'Label'},\n                {id: 'text', title: 'Text'},\n            ],\n            append: true\n        });\n    }\n\n    // 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n    async callback(\n        options: { label: string },\n        ctx: { inputText: string },\n    ): Promise\u003cany\u003e {\n\n        // 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\n        await this.csvWriter.writeRecords([{\n            label: options.label,\n            text: ctx.inputText\n        }]);\n\n        console.log(`CSV 행 추가됨: ${options.label} | ${ctx.inputText}`);\n\n        return `레이블이 성공적으로 추가되었습니다: ${options.label}`;\n    }\n\n    // JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\n    async getSchema(ctx: { inputText: string }): Promise\u003cToolSchema\u003e {\n\n        // 이는 LLM을 위한 제공된 스키마입니다.\n        return {\n            type: 'function',\n            function: {\n                name: 'set_label',\n                description: '텍스트에 레이블 설정',\n                function: ToolUtils.getToolFn(this, ctx),\n                parse: JSON.parse,\n                parameters: {\n                    type: 'object',\n                    properties: { // 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\n                        label: {\n                            type: 'string',\n                            description: '입력 텍스트의 레이블',\n                            enum: this.labels // 가능한 문자열을 제한합니다\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n```\n\n이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n```js\nimport OpenAI from \"openai\";\nimport {LabelTool} from \"./tools/label.tool\";\nrequire('dotenv').config()\n\nconst client = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\n(async () =\u003e {\n    const inputTexts = [ // OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\n        \"이 제품을 사랑해요!\",\n        \"이게 내가 산 것 중에 가장 최악이에요.\",\n        \"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\",\n        \"돈 안 아깝다고.\",\n        \"최고의 구매!\",\n    ];\n\n    for (const inputText of inputTexts) {\n        console.debug(`프롬프트: 이 텍스트에 레이블을 부여하세요: ${inputText}`);\n\n        const tool = new LabelTool(['positive', 'negative', 'neutral']);\n        const context = { inputText: inputText };\n        const prompt = `이 텍스트에 레이블을 부여하세요: ${inputText}`;\n        const system = '훈련 데이터 생성을 돕는 유용한 도우미입니다.';\n\n        const runner = client.beta.chat.completions.runTools({\n            model: 'gpt-3.5-turbo',\n            messages: [\n                {\n                    role: 'system',\n                    content: system,\n                },\n                {\n                    role: 'user',\n                    content: prompt,\n                },\n            ],\n            tools: [await tool.getSchema(context)],\n            tool_choice: 'auto', // 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\n        });\n\n        const finalContent = await runner.finalContent();\n        console.log(`AI 응답: ${finalContent}\n        `);\n    }\n})();\n```\n\n로그 결과:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\r\n\n\r\nCSV 파일:\r\n\r\n\n라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\r\n\n\r\n물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: https://github.com/MaurerKrisztian/training_data_genration_with_openai\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\n\n이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"},"coverImage":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png","tag":["Tech"],"readingTime":7}],"page":"10","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"10"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>