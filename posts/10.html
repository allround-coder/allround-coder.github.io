<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/10" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/10" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" href="/post/2024-06-23-TheLatestinDataEngineering"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheLatestinDataEngineering_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" href="/post/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이렇게 Python 함수 작성 안 하면 PR 거부" href="/post/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이렇게 Python 함수 작성 안 하면 PR 거부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이렇게 Python 함수 작성 안 하면 PR 거부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이렇게 Python 함수 작성 안 하면 PR 거부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 코드 속도를 높이는 8가지 팁" href="/post/2024-06-23-8TipstoSpeedUpYourPythonCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 코드 속도를 높이는 8가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 코드 속도를 높이는 8가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 코드 속도를 높이는 8가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" href="/post/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" href="/post/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법" href="/post/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs 애플리케이션에서 Winston으로 로깅하는 방법" href="/post/2024-06-23-UsingWinstonforLogginginNodejsApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs 애플리케이션에서 Winston으로 로깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs 애플리케이션에서 Winston으로 로깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs 애플리케이션에서 Winston으로 로깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 이용한 이중 인증 구현 단계별 가이드" href="/post/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 이용한 이중 인증 구현 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 이용한 이중 인증 구현 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 이용한 이중 인증 구현 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법" href="/post/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link posts_-active__YVJEi" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드","description":"","date":"2024-06-23 13:33","slug":"2024-06-23-TheLatestinDataEngineering","content":"\n\n## 주요 개발 사항 및 그 영향\n\n최근 몇 주 동안 DuckDB, Snowflake, DataBricks 및 Polars에서 중요한 발표를 통해 데이터 엔지니어링 분야가 상당히 발전하고 있습니다. 이러한 발전은 데이터 생태계 내 중요성과 혁신의 증가를 강조하고 있습니다. 제 평소의 글과는 다르지만, 최근 이러한 발표들을 살펴보고 데이터 엔지니어링의 미래에 대해 어떤 의미를 갖을지 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-23-TheLatestinDataEngineering_0.png)\n\n# 뉴스 속으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DuckDB v1.0.0 릴리스\n\nDuckDB는 SQL OLAP 데이터베이스 관리 시스템으로, 1.0.0 마일스톤에 도달했습니다. DuckDB에 대한 별도의 기사를 썼는데, 여기서 더 많은 정보를 찾을 수 있습니다. 이번 릴리스인 \"Nivis\"는 신화 속 눈오리 오리 이름을 지어 안정성과 하위 호환성을 강조했습니다. 대규모 테이블을 전체 트랜잭션 의미론과 최신 압축 기술을 사용하여 관리할 수 있도록 하는 DuckDB의 사용자 정의 저장 형식은 이제 버전 간 호환성을 보장합니다. 이 릴리스는 DuckDB의 성숙성과 신뢰성을 나타내며 데이터베이스 운영에 안정적인 선택지로 만듭니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n## Snowflake의 Polaris, 오픈 소스 아이스버그 카탈로그\n\nSnowflake은 Apache Iceberg를 위한 벤더 중립적 카탈로그 구현인 Polaris를 공개했습니다. 오픈 소스로 나아가는 이 전략적인 움직임은 데이터 관리 커뮤니티에서 보다 큰 협력과 표준화를 촉진하기 위한 것입니다. Polaris는 앞으로 3개월 동안 오픈 소스로 공개될 예정이며, Snowflake의 상호 운용성과 혁신에 대한 약속을 강화합니다. 오픈 소스를 채택함으로써 Snowflake는 생태계의 유연성을 향상시켜 사용자가 다양한 플랫폼에서 데이터를 보다 효율적으로 관리하고 쿼리할 수 있도록 합니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DataBricks 오픈소스 Unity 카탈로그\n\n스노우플레이크의 발표에 반응하여 DataBricks는 Unity 카탈로그를 오픈소스로 공개하기로 결정했습니다. 이 카탈로그는 Iceberg, Hudi 및 Delta 데이터 레이크하우스 파일 형식을 지원하여 현대적인 데이터 관리 필요에 대한 포괄적인 솔루션을 제공합니다. 이 오픈소스 코드는 오늘부터 GitHub에서 사용 가능할 것이며, 투명성 및 커뮤니티 기반의 향상을 촉진할 것입니다. 이러한 조치는 고급 데이터 관리 도구에 대한 접근을 민주화할 뿐만 아니라 DataBricks를 오픈소스 데이터 생태계의 선도 업체로 위치시킵니다. DataBricks 웹사이트에서 아직 정보를 찾을 수 없지만, PR Newswire에서 링크를 확인할 수 있습니다.\n\n## Polars v1.0.0 곧 출시 예정\n\nRust로 작성된 고성능 DataFrame 라이브러리인 Polars는 앞으로 몇 주 안에 1.0.0 버전을 출시할 예정입니다. 현재 1.0.0 버전은 여기에서 알파 버전으로 제공됩니다. 다중 코어 프로세서를 활용하여 빠른 데이터 처리를 지원하는 능력으로 알려진 Polars는 대규모 데이터 분석용 Pandas의 매력적인 대안을 제공합니다. 이 도구는 여러 기술 문서에 사용하는 내 선택 도구이며, 제 GitHub 계정에서 강력하게 활용될 것입니다. 이 출시는 다양한 새로운 기능과 성능 향상을 가져와서 Python을 사용하는 데이터 엔지니어들에게 필수적인 도구로서의 입지를 더욱 굳히게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DataBricks가 Tabular를 인수했습니다\n\n전략적으로 DataBricks가 Iceberg 테이블 형식의 창시자들에의해 설립된 Tabular를 인수했습니다. 이번 인수는 Tabular의 전문지식과 기술을 DataBricks 플랫폼에 통합하여 대용량 데이터 형식을 처리하는 능력을 강화하는 것을 목표로 합니다. 병합은 데이터 저장 및 관리에 혁신을 도모해 사용자들에게 더 견고하고 확장 가능한 솔루션을 제공할 것으로 예상됩니다.\n\n# 데이터 엔지니어링의 미래에 대한 영향\n\n이러한 발표들은 오픈 소스 솔루션, 상호운용성 및 향상된 데이터 관리 능력으로 나아가는 일반적인 추세를 반영합니다. 이러한 발전들이 데이터 엔지니어링의 미래에 미치는 의미는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 향상된 안정성과 신뢰성: DuckDB의 v1.0.0 릴리스에서 안정성에 대한 강조는 다른 데이터베이스 관리 시스템에 선례를 제공합니다. 신뢰성 있고 하위 호환성 있는 시스템은 데이터 무결성과 가용성이 중요한 기업 애플리케이션에서 필수적입니다.\n- 오픈 소스 우위: Snowflake와 DataBricks의 오픈 소스 노력은 커뮤니티 기반 개발과 협업의 중요성을 강조합니다. 오픈 소스 프로젝트는 다른 성공적인 오픈 소스 데이터베이스 및 도구들과 마찬가지로 빠른 혁신과 채택을 이끌어냅니다.\n- 향상된 데이터 상호 운용성: Polaris와 Unity Catalog의 오픈 소스화와 같이 벤더 중립 카탈로그의 도입으로 다양한 시스템 간 데이터 관리 및 쿼리가 더욱 원활해질 것입니다. 이러한 상호 운용성은 다양한 데이터 소스와 형식을 다루는 기관에 중요합니다.\n- 성능 최적화: Polars와 DuckDB와 같은 도구들은 고성능 데이터 처리 라이브러리의 필요성을 강조합니다. 데이터 양이 계속해서 증가함에 따라 효율적인 데이터 처리는 실시간 분석과 의사 결정에 중요할 것입니다.\n- 전략적 인수: DataBricks가 Tabular를 인수한 것은 플랫폼 기능을 향상시키기 위해 전문 지식과 기술을 통합하는 추세를 보여줍니다. 기업이 데이터 관리 솔루션을 강화하려는 노력으로 이러한 전략적 움직임은 계속될 것입니다.\n\n# 결론\n\n저는 오픈 소스의 팬이라서 이러한 발표들이 나를 흥분시킵니다. 안정성, 오픈 소스 협업 및 성능 향상에 초점을 맞추면, 데이터 엔지니어링의 미래는 밝아 보입니다. 이러한 혁신은 기업이 데이터를 더 효과적으로 처리하고 더 나은 통찰과 비즈니스 결과를 이끌어내도록 할 것입니다. 앞으로 나아가면서, 이러한 트렌드를 주시하는 것은 데이터 전문가가 끊임없이 변화하는 데이터 생태계에서 앞서 나가기 위한 중요한 요소가 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png"},"coverImage":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png","tag":["Tech"],"readingTime":4},{"title":"HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법","description":"","date":"2024-06-23 13:31","slug":"2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs","content":"\n\n현재 인터넷 트래픽의 약 30%는 봇, 스파이더 및 크롤러에 의해 생성됩니다. 이들은 다양한 목적으로 웹을 스캔하는 자동화 프로그램입니다.\n\n이 프로그램 중 일부는 다음과 같은 중요한 인터넷 작업을 수행합니다:\n\n- 검색 엔진 인덱싱\n- 성능 모니터링\n- 인터넷 매핑\n- 선의의 취약점 스캔\n\n해당 주제에서 제가 찾을 수 있는 가장 포괄적인 목록은 클라우드플레어의 목록입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 합법적인 또는 조작된 것인가요?\n\n좋은 크롤러 외에도, 다른 많은 봇들은 단순히 자원을 낭비하거나 비패치된 취약점을 악용하려 하거나 웹사이트의 콘텐츠를 훔치려고 시도하는 경우가 많습니다.\n\n좋은 봇과 나쁜 봇을 구분하는 것은 어려운 주제입니다. 몇몇 영리한 봇은 사용자 에이전트 필드를 조정하여 실제로 보이도록 속이려고 합니다. 사용자 에이전트 필드는 브라우저가 웹사이트로 보내는 것이며, 자기 자신을 식별하는 방법입니다.\n\n```js\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래도 프로그래밍으로 요청을 보낼 때, 어떤 개발자든 해당 요청에 원하는 사용자 에이전트를 설정할 수 있어요. 그래서 HTTP 요청이 필수적인 봇에서 시작되었는지를 확인하는 방법은 사용자 에이전트 값을 살펴보는 것 뿐이에요.\n\n## robots.txt는 어떤가요?\n\n웹사이트 루트에 위치한 robots.txt 파일은 자동화된 요청에 대한 해당 웹사이트의 정책을 나타냅니다. 크롤러(또는 프로그램)가 지시 사항을 존중하고 이행하는 것은 그들에 달려 있어요.\n\n# 원본 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도, 주요 인터넷 업체들은 명확한 확인 지침을 제공하고 최신 IP 목록을 유지하고 있습니다. 이를 통해 누구든지 특정 서비스에서 오는 임의의 요청인지 여부를 확인할 수 있습니다.\n\n지금 당장, 이 정보를 공유하는 기업들 사이에 공통 표준이 없습니다. 이 공통 표준의 부재는 괜찮습니다; 웹에는 더 많은 대화가 필요합니다 — 더 많은 규제가 아닌요.\n\n아래를 읽어보세요.\n## Google\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle은 사전 정의된 URL에서 제공되는 JSON 형식(기계가 읽을 수 있는 형식)으로 봇 IP 범위를 공개합니다. Google은 현재 세 가지 주요 크롤러를 운영 중입니다:\n\n- GoogleBot — Google 검색용 초기 크롤러\n- GoogleBot Special + AdsBot — 광고 및 기타 서비스\n- GoogleBot User Triggered — 사용자 요청에 따른 색인 작업\n\n## Bing\n\nMicrosoft는 검색 결과를 개선하기 위해 BingBot을 사용하며, Google과 동일한 JSON 형식으로 IP 범위를 나열합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## OpenAI\n\nGPTBot은 OpenAI의 봇으로, 웹사이트 콘텐츠를 다운로드하는 데 사용될 가능성이 높습니다. 이를 통해 ChatGPT와 같은 AI 모델을 훈련할 수 있습니다. IP 범위는 JSON 형식으로 제공됩니다. robots.txt를 사용하여 이들을 차단할 수 있습니다.\n\n## DuckDuckGo\n\nDuckDuckGo는 Google의 대체로서 개인정보 보호에 중점을 둔 검색 엔진입니다. 이 페이지에서 각 개별 봇의 IP를 공개합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메타\n\n메타는 웹사이트에 접근하기 위해 Facebook 크롤러를 사용합니다. IP 범위는 radb.net 레지스트리를 사용하여 공개됩니다.\n\n## Amazon, Apple, Baidu, Sogou, Yahoo, Yandex\n\n이 기업들은 인터넷을 스캔하는 데 사용되는 IP 주소의 고정된 목록이나 자동 업데이트되는 목록을 공개하지 않습니다. 그러나, bot 트래픽이 자신들의 시스템에서 유래되었는지 확인하는 문서화된 방법을 갖고 있습니다. host 명령을 사용하여 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ host 17.58.101.179\n179.101.58.17.in-addr.arpa domain name pointer 17-58-101-179.applebot.apple.com.\n\n\n## 인터넷 아카이브\n\n인터넷 아카이브 봇은 웨이백 머신/아카이브 닷오르그 프로젝트를 위한 크롤러입니다. 그들은 웹의 콘텐츠를 역사적인 이유로 저장합니다. 웹사이트는 변화하고 페이지는 매일 생성되고 사라집니다.\n\nIABot은 host 명령을 사용하여 확인할 수 있습니다. robots.txt의 내용을 무시하기 때문에 차단하기 어렵습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## CommonCrawl\n\n커먼크롤(CommonCrawl)은 인터넷 아카이브와 유사한 비영리 기관입니다. 전체 인터넷의 주기적인 스냅샷 또는 데이터셋을 생성하고 이를 공개적으로 제공합니다.\n\n커먼크롤은 해당 주제에 대한 정보를 과도하게 공유하지 않으며, 실제 CCBot를 식별하는 것은 대규모 온디맨드 AWS 인프라에서 실행되므로 더 복잡합니다.\n\n한 가지 방법은 사용자 에이전트와 호스트를 모두 확인하는 것입니다. 이는 완벽한 방법은 아니지만, 모든 EC2 클라우드 인스턴스가 같은 .amazonaws.com 호스트 이름을 공유하기 때문에 복잡합니다. 그러나 두 가지가 일치하면, 요청이 실제 CCBot에서 시작되었을 가능성이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이 스크립트로 변환하기\n\nGitHub에는 자체 업데이트되는 좋은 봇 IP 목록 및 프로젝트가 많이 있습니다. 주요 단점은 이러한 프로젝트 관리자에게 의존한다는 것입니다. 이러한 프로젝트의 계획 또는 EOL(수익화 종료) 날짜는 알려져 있지 않으며 라이선스도 명확하지 않습니다.\n\n그것을 고려하면 아래 스크립트는 생성자에서 IP 범위에 관한 모든 정보를 다운로드합니다. 그 정보는 직접 제공되는 서비스에서 가져옵니다. 따라서 HTTP 요청 로그 항목의 IP 및 사용자 에이전트를 확인할 수 있습니다.\n\n안타깝게도 이 스니펫은 완전한 Python 패키지로 발전시키기 위해 추가 작업이 필요하므로 현재는 Gist 상태입니다. 호스트 호출로 인해 실시간 사용에 대한 도움 클래스는 충분히 빠르지 않을 것입니다. 50,000개의 로그 항목을 확인하는 데 약 15분이 소요됩니다. 서브프로세스 호출에 대해 교차 플랫폼 작업이 필요할 수 있습니다. IPv6 지원은 없습니다. 가독성을 우선시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 응용 프로그램 방화벽(WAF)가 실시간으로 이러한 요청을 차단해야 한다면 CloudFlare, RunCloud 등의 검증된 서비스를 선택하세요.\n\n현재 클래스는 과거의 HTTP 서버 로그 항목을 테스트할 수 있습니다. 서버가 받는 건강한 봇/크롤러/스파이더 트래픽의 양을 확인하는 데 사용할 수 있습니다.\n\n# 사용 방법\n\n저는 NGINX 서버의 봇 트래픽을 확인하기 위해 아래 스크립트를 사용했습니다.\n아래의 사용 예는 하위 폴더 내에있는 모든 access.log[.*.gz] 파일을 구문 분석합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# NGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로 로드합니다  \nNGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로로드합니다.  \n\n# tqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다\ntqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다. 이 단계는 시간이 걸릴 수 있으므로 주의해주세요.  \n\n# 디스크에 보고서 저장 및 요약 출력  \n디스크에 보고서를 저장하고 요약을 출력합니다.  \n\n이 스크립트는 NGINX 로그 파일에 작동합니다. NGINX는 인그레스 컨트롤러로 가장 인기 있는 선택지이기 때문에 잘 작동합니다.  \n위 코드 조각들은 어떤 데이터 분석 사용 사례 및 다른 인그레스 컨트롤러에 대한 확장이 가능하도록 충분히 일반적입니다.  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n사실, 로봇 요청 중에서 4%만 진짜 서비스에서 시작된 것으로 나타났습니다. 즉, 25개 중 1개만이 진짜 요청입니다.\n\n나머지는 단지 대역폭과 자원을 낭비하는 것 뿐입니다.\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png","tag":["Tech"],"readingTime":5},{"title":"이렇게 Python 함수 작성 안 하면 PR 거부","description":"","date":"2024-06-23 13:30","slug":"2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png\" /\u003e\n\n이건 나의 직장에서 기술 리드로부터 받았던 에너지였죠. 사실 나도 이 시점에서 그와 동의합니다.\n\n# 우리에게 파이썬 함수를 어떻게 작성하는지 배웠는가\n\n다음은 간단한 매개변수를 사용하는 함수입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 숫자 목록 num_list가 있습니다.\n- 숫자 num이 있습니다.\n- num_list에 있는 모든 숫자에 num을 더한 새로운 목록을 반환합니다.\n\n```js\ndef add_all(num_list, num):\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n문제 - 첫눈에 알기 어려운 것들:\n\n- 이 함수가 어떤 데이터 유형을 사용하는지\n- 이 함수가 어떤 데이터 유형을 반환하는지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음, 코드를 읽으면 num_list가 숫자의 목록이고 num은 숫자이며, 함수가 숫자의 목록을 반환한다는 것을 유추할 수 있다는 걸 알 수 있어. 그러나 이건 즉시 알 수 있는 게 아니잖아.\n\n그리고 대규모 제품용 앱에서는 수천 개의 함수가 처리되어야 한다. 정말 그 추가 시간을 들여서 데이터 유형을 이해하고 추론해야 할까?\n\n# 타입 주석 (타입 힌트)이 구해줍니다 \n\n참고 - 우리는 이것을 타입 힌트 또는 타입 주석이라고 부를 수 있어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 위의 함수에 몇 가지 타입 힌트를 추가해 봅시다.\n\n```python\nfrom typing import List, Union\n\ndef add_all(\n    num_list: List[Union[int, float]],\n    num: Union[int, float]\n) -\u003e List[Union[int, float]]:\n    \"\"\"\n    num_list의 모든 숫자에 num을 추가합니다  \n\n    inputs:\n        num_list: 숫자 리스트\n        num: 숫자\n    \"\"\"\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx: List[Union[int, float]] = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n- Union[int, float]은 int 또는 float 중 하나를 의미합니다.\n- List[Union[int, float]]은 정수 또는 소수의 리스트를 의미합니다.\n\nnum_list: List[Union[int, float]]은 num_list가 숫자 (정수 또는 소수)의 리스트여야 함을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, `num: Union[int, float]`은 num이 정수 또는 부동 소수점 숫자여야 함을 의미합니다.\n\n마지막으로, `- List[Union[int, float]]`은 이 함수가 정수 또는 부동 소수점 숫자들의 리스트를 반환해야 함을 의미합니다.\n\n참고 - 함수의 첫 줄에 우리 함수가 무엇을 하는지 간단히 설명하고 문서화하기 위해 (세 개의 따옴표로 둘러싼 것) 독스트링을 추가합니다.\n\n# 네, 이렇게 함수를 작성해야 합니다. 그렇지 않으면 PR이 거부될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 기술 리드가 우리에게 함수를 이렇게 작성하라고 요청하는지 알려드릴게요:\n\n- 변수의 데이터 유형이 한눈에 알 수 있습니다.\n- 이를 유추할 필요가 없어져 시간을 절약할 수 있습니다.\n- 함수가 반환해야 하는 것을 한눈에 알 수 있습니다.\n- 독스트링을 통해 함수가 하는 일을 코드를 살펴보지 않고도 한눈에 알 수 있습니다. 더 많은 시간을 절약할 수 있죠.\n- 이렇게 함으로써 함수가 장기적으로 유지보수하기에 더 적합해집니다.\n\n# 더 널리 사용되는 타입 힌트들\n\n기본 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\na: int = 5\n\nb: float = 3.14\n\nc: bool = True\n\nd: str = 'apple orange pear'\n```\n\n리스트, 사전, 튜플, 셋:\n\n```js\nfrom typing import List, Dict, Tuple, Set\n\n# 정수 리스트\na: List[int] = [1, 2, 3]  \n\n# 문자열 리스트\nb: List[str] = ['apple', 'orange'] \n\n# 키가 문자열이고 값이 정수인 사전\nc: Dict[str, int] = {'apple':4, 'orange':5}\n\n# 키가 정수이고 값이 부울인 사전\nd: Dict[int, bool] = {1: True, 2: False, 3: True}\n```\n\n변수가 정수 또는 부동 소수점 숫자일 수 있는 경우 Unions을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom typing import Union, Dict\n\ndef add10(number: Union[int, float]):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, Union[int, float, bool]]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n대안적인 방법으로 `Union`을 사용하는 대신에 다음과 같이 작성할 수 있습니다:\n\n```js\nfrom typing import Dict\n\ndef add10(number: int | float):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, int | float | bool]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n^ `Union[int, float]` 대신에 `int | float`을 사용하는 대체 방법입니다. 저는 이 방법을 더 우아하게 보이고(그리고 덜 타이핑해야 하기 때문에) 주로 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 옵셔널 변수에 대한 예제입니다:\n\n```python\nfrom typing import Optional\nfrom random import random\n\ndef test() -\u003e Optional[int]:\n    \"\"\"\n    50%의 확률로 1000 반환\n    50%의 확률로 None 반환\n    \"\"\"\n    random_float: float = random()\n\n    if random_float \u003e 0.5:\n        return 1000\n\n    return None\n```\n\n여기서 Optional[int]는 변수가 int 또는 None 중 하나일 수 있음을 나타냅니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 정말이죠. 만약 우리 중 누군가가 타입 주석이나 독스트링을 추가하지 않고 코드를 작성한다면, 우리는 리더들로부터 그것을 추가하라는 의견을 받게 될 거에요.\n\n그것이 나쁜 일은 아니에요, 왜냐하면 코드는 읽기 쉽도록 만들어졌으니까요.\n\n# 만약 크리에이터로서 저를 지원하고 싶다면\n\n- 제 책을 사 주세요! — 101 Things I Never Knew About Python\n- 어디서 찾을 수 있나요: https://payhip.com/b/vywcf\n- 이 이야기에 50번 박수를 보내주세요\n- 여러분의 생각을 나에게 말씀해 주세요\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"},"coverImage":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png","tag":["Tech"],"readingTime":5},{"title":"파이썬 코드 속도를 높이는 8가지 팁","description":"","date":"2024-06-23 13:29","slug":"2024-06-23-8TipstoSpeedUpYourPythonCode","content":"\n\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png)\n\n파이썬은 C/C++와 같은 컴파일된 언어와 비교했을 때 효율성과 성능 면에서 몇 가지 단점을 가지고 있는 스크립팅 언어입니다. 그러나 파이썬의 효율성이 상상 이상으로 과장되지 않는 경우가 많습니다. 이 기사는 파이썬 코드의 실행 속도를 높이는 몇 가지 팁을 요약한 것입니다.\n\n# 0 코드 최적화 원칙\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 Python 코드 실행 속도를 높이는 여러 기술을 소개할 것입니다. 코드 최적화의 세부 사항에 들어가기 전에 코드 최적화의 기본 원칙 몇 가지를 이해해야 합니다.\n\n첫 번째 기본 규칙은 너절로 최적화하지 말아야 한다는 것입니다. 많은 사람들이 성능 최적화를 목표로 코드를 작성하기 시작합니다. \"올바른 프로그램을 더 빠르게 만드는 것은 빠른 프로그램을 올바르게 만드는 것보다 훨씬 쉽습니다.\" 따라서 최적화의 선행 조건은 코드가 제대로 작동해야 한다는 것입니다. 조기 최적화는 종합적 성능 지표를 파악하는 것을 무시할 수 있습니다. 전역 결과를 얻기 전에 우선순위를 바꾸지 마세요.\n\n두 번째 기본 원칙은 최적화 비용을 따져보는 것입니다. 최적화에는 비용이 발생하며 모든 성능 문제를 해결하는 것은 거의 불가능합니다. 선택해야 하는 것은 일반적으로 공간에 대한 시간 또는 시간에 대한 공간입니다. 또한, 개발 비용도 고려해야 합니다.\n\n세 번째 원칙은 중요하지 않은 부분을 최적화하지 말아야 한다는 것입니다. 코드의 모든 부분을 최적화하려고 한다면 이러한 변경으로 코드가 읽고 이해하기 어려워질 수 있습니다. 코드가 느리게 실행된다면, 코드가 느린 부분을 찾아보고 보통 내부 루프에 해당하는 부분에 중점을 두어 최적화를 집중하세요. 그 외의 부분은 약간의 시간 손실이 큰 차이를 만들지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1 전역 변수 피하기\n\n```js\n# 비권장. 소요 시간: 26.8 초\nimport math\n\nsize = 10000\nfor x in range(size):\n    for y in range(size):\n        z = math.sqrt(x) + math.sqrt(y)\n```\n\n많은 프로그래머들은 파이썬에서 간단한 스크립트를 작성할 때 시작합니다. 스크립트를 작성할 때 일반적으로 위 코드와 같이 전역 변수로 직접 작성하는 습관이 있습니다. 그러나 전역 변수와 지역 변수의 구현 방식이 다르기 때문에 전역 범위에 정의된 코드는 함수에 정의된 코드보다 훨씬 느리게 실행됩니다. 스크립트 문장을 함수로 넣음으로써 일반적으로 15% ~ 30%의 속도 향상을 얻을 수 있습니다.\n\n```js\n# 권장. 소요 시간: 20.6 초\ndef main():\n    size = 10000\n    for x in range(size):\n        for y in range(size):\n            z = math.sqrt(x) + math.sqrt(y)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 점 피하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_2.png)\n\n## 2.1 모듈 및 함수 속성 접근 피하기\n\n```python\n# 권장되지 않음. 실행 시간: 14.5 초\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    for i in range(size):\n        result.append(math.sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n각각 . (속성 액세스 연산자)을 사용할 때 특정 메서드인 __getattribute__() 및 __getattr__()이 트리거됩니다. 이러한 메서드는 사전 작업을 수행하므로 추가 시간 소요가 발생할 수 있습니다. 속성 액세스는 from import 문을 통해 제거할 수 있습니다.\n\n```js\nfrom math import sqrt\n\ndef computeSqrt(size: int):\n    result = []\n    for i in range(size):\n        result.append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n제1 섹션에서 전역 변수보다 로컬 변수의 검색이 빠를 것이라고 언급했습니다. 때문에 빈번하게 액세스되는 변수 sqrt에 대해 이를 로컬 변수로 변경함으로써 작업을 가속화할 수 있습니다.\n\n```js\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    sqrt = math.sqrt\n    for i in range(size):\n        result.append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수학.sqrt 외에도 computeSqrt 함수에는 리스트의 append 메소드를 호출하는 .이 있습니다. 이 메소드를 지역 변수에 할당하여 computeSqrt 함수의 for 루프 내부에서의 . 사용을 완전히 제거할 수 있습니다.\n\n```js\n# 권장됨. 시간 소요: 7.9초\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    append = result.append\n    sqrt = math.sqrt\n    for i in range(size):\n        append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n## 2.2 내부 속성 접근 피하기\n\n```js\n# 비권장. 시간 소요: 10.4초\nimport math\nfrom typing import List\n\nclass DemoClass:\n    def __init__(self, value: int):\n        self._value = value\n    \n    def computeSqrt(self, size: int) -\u003e List[float]:\n        result = []\n        append = result.append\n        sqrt = math.sqrt\n        for _ in range(size):\n            append(sqrt(self._value))\n        return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        demo_instance = DemoClass(size)\n        result = demo_instance.computeSqrt(size)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`.table` 태그를 Markdown 형식으로 변경하세요.\n\n```js\n| Recommended | Cost time: 8.3 seconds |\n|--------------|-----------------------|\n| import math | |\n| from typing import List | |\n| |\n| class DemoClass: | |\n|\u0026nbsp;\u0026nbsp;def __init__(self, value: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self._value = value | |\n| |\n|\u0026nbsp;\u0026nbsp;def computeSqrt(self, size: int) -\u003e List[float]: | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;result = [] | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;append = result.append | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sqrt = math.sqrt | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;value = self._value | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for _ in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;append(sqrt(value)) | |\n|\u0026nbsp;\u0026nbsp;return result | |\n| |\n| def main(): | |\n|\u0026nbsp;\u0026nbsp;size = 10000 | |\n|\u0026nbsp;\u0026nbsp;for _ in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance = DemoClass(size) | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance.computeSqrt(size) | |\n| main() | |\n```\n\n# 3 불필요한 추상화 피하기\n\n```js\n| Not recommended | Cost time: 0.55 seconds |\n|-----------------|------------------------|\n| class DemoClass: | |\n|\u0026nbsp;\u0026nbsp;def __init__(self, value: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self.value = value | |\n| |\n|\u0026nbsp;\u0026nbsp;@property | |\n|\u0026nbsp;\u0026nbsp;def value(self) -\u003e int: | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return self._value | |\n|\u0026nbsp;\u0026nbsp;@value.setter | |\n|\u0026nbsp;\u0026nbsp;def value(self, x: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self._value = x | |\n| |\n| def main(): | |\n|\u0026nbsp;\u0026nbsp;size = 1000000 | |\n|\u0026nbsp;\u0026nbsp;for i in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance = DemoClass(size) | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;value = demo_instance.value | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance.value = i | |\n| main() | |\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가 계층으로 코드를 래핑할 때 (데코레이터, 프로퍼티 액세스, 디스크립터와 같은), 코드 실행 속도가 느려질 수 있습니다. 대부분의 경우, 프로퍼티 액세스 사용 정의를 다시 검토하는 것이 필요합니다. 프로퍼티 액세서를 사용할 때 getter/setter 함수를 사용하는 것은 일반적으로 C/C++ 프로그래머가 남긴 코딩 스타일입니다. 꼭 필요하지 않은 경우, 간단한 속성을 사용해보세요.\n\n```js\n# 추천하는 방법. 실행 시간: 0.33 초\nclass DemoClass:\n    def __init__(self, value: int):\n        self.value = value\n\ndef main():\n    size = 1000000\n    for i in range(size):\n        demo_instance = DemoClass(size)\n        value = demo_instance.value\n        demo_instance.value = i\n\nmain()\n```\n\n# 4 데이터 복사 피하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4.1 무의미한 데이터 복사 피하기\n\n```js\n# 권장하지 않습니다. 시간 소요: 6.5 초\ndef main():\n    size = 10000\n    for _ in range(size):\n        value = range(size)\n        value_list = [x for x in value]\n        square_list = [x * x for x in value_list]\n\nmain()\n```\n\n위 코드에서 value_list는 완전히 불필요하며 불필요한 데이터 구조 또는 복사를 생성할 것입니다.\n\n```js\n# 권장합니다. 시간 소요: 4.8 초\ndef main():\n    size = 10000\n    for _ in range(size):\n        value = range(size)\n        square_list = [x * x for x in value]\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 다른 상황은 Python의 데이터 공유 메커니즘에 대해 지나치게 걱정하고 있거나 Python의 메모리 모델을 충분히 이해하거나 신뢰하지 않아 copy.deepcopy()와 같은 함수를 남용하는 경우입니다. 일반적으로 이러한 코드에서는 복사 작업을 제거할 수 있습니다.\n\n## 4.2 값을 교환할 때 중간 변수를 사용하지 마세요\n\n```js\n# 권장되지 않음. 소요 시간: 0.07초\ndef main():\n    size = 1000000\n    for _ in range(size):\n        a = 3\n        b = 5\n        temp = a\n        a = b\n        b = temp\n\nmain()\n```\n\n위 코드는 값을 교환할 때 임시 변수 temp를 생성합니다. 중간 변수의 도움 없이 코드는 더 간결하고 빨리 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 권장됨. 시간 소요: 0.06 초\ndef main():\n    size = 1000000\n    for _ in range(size):\n        a = 3\n        b = 5\n        a, b = b, a\n\nmain()\r\n```\n\n# 5 if 조건문의 단락회로 기능 사용하기\n\n```js\n# 권장되지 않음. 시간 소요: 0.05 초\nfrom typing import List\n\ndef concatString(string_list: List[str]) -\u003e str:\n    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}\n    abbr_count = 0\n    result = ''\n    for str_i in string_list:\n        if str_i in abbreviations:\n            result += str_i\n    return result\n\ndef main():\n    for _ in range(10000):\n        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']\n        result = concatString(string_list)\n\nmain()\r\n```\n\nif 조건문의 단락회로 특성은 if a and b와 같은 문장에서 a가 False인 경우 직접 반환되어 b가 계산되지 않고, if a or b와 같은 문장에서 a가 True인 경우 직접 반환되어 b가 더 이상 계산되지 않는 것을 의미합니다. 따라서 실행 시간을 절약하기 위해 or 문에서는 더 높은 확률로 True인 변수가 or 앞에 나와야 하며, and는 뒤로 미루어져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 권장사항. 시간 소요: 0.03 초\nfrom typing import List\n\ndef concatString(string_list: List[str]) -\u003e str:\n    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}\n    abbr_count = 0\n    result = ''\n    for str_i in string_list:\n        if str_i[-1] == '.' and str_i in abbreviations:\n            result += str_i\n    return result\n\ndef main():\n    for _ in range(10000):\n        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']\n        result = concatString(string_list)\n\nmain()\r\n```\n\n# 6 루프 최적화\n\n![이미지](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_4.png)\n\n## 6.1 `while` 루프 대신 `for` 루프 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 비추천합니다. 소요 시간: 6.7 초\ndef computeSum(size: int) -\u003e int:\n    sum_ = 0\n    i = 0\n    while i \u003c size:\n        sum_ += i\n        i += 1\n    return sum_\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum_ = computeSum(size)\n\nmain()\n```\n\n파이썬의 `for` 루프가 `while` 루프보다 빠릅니다.\n\n```js\n# 추천합니다. 소요 시간: 4.3 초\ndef computeSum(size: int) -\u003e int:\n    sum_ = 0\n    for i in range(size):\n        sum_ += i\n    return sum_\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum_ = computeSum(size)\n\nmain()\n```\n\n## 6.2 명시적 `for` 루프 대신 암시적 `for` 루프 사용하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제에서는 명시적인 for 루프 대신 함축적인 for 루프를 사용할 수 있습니다.\n\n```js\n# 권장됨. 소요 시간: 1.7 초\ndef computeSum(size: int) -\u003e int:\n    return sum(range(size))def main():\n    size = 10000\n    for _ in range(size):\n        sum = computeSum(size)\n\nmain()\r\n```\n\n## 6.3 내부 `for` 루프의 계산 감소\n\n```js\n# 권장되지 않음. 소요 시간: 12.8 초\nimport math\n\ndef main():\n    size = 10000\n    sqrt = math.sqrt\n    for x in range(size):\n        for y in range(size):\n            z = sqrt(x) + sqrt(y)\n\nmain()\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 `sqrt(x)`은 for 루프 내에 있으며 각 훈련 과정마다 다시 계산되어 시간을 많이 소비합니다.\n\n```js\n# 권장됨. 소요 시간: 7초\nimport math\n\ndef main():\n    size = 10000\n    sqrt = math.sqrt\n    for x in range(size):\n        sqrt_x = sqrt(x)\n        for y in range(size):\n            z = sqrt_x + sqrt(y)\n\nmain()\r\n```\n\n# 7 numba.jit 사용\n\n위에서 소개한 예시를 따라 numba.jit을 사용합니다. numba는 Python 함수를 JIT 컴파일하여 기계 코드로 변환하여 코드 실행 속도를 크게 향상시킵니다. numba에 대한 자세한 정보는 아래 홈페이지를 참조하세요: [http://numba.pydata.org/numba.pydata.org](http://numba.pydata.org/numba.pydata.org).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 추천. 소요 시간: 0.62 초\nimport numba\n\n@numba.jit\ndef computeSum(size: float) -\u003e int:\n    sum = 0\n    for i in range(size):\n        sum += i\n    return sum\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum = computeSum(size)\n\nmain()\r\n```\n\n# 8. 적절한 데이터 구조 선택하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_5.png)\n\n파이썬의 내장 데이터 구조인 str, tuple, list, set, dict은 모두 C 언어로 최하위 수준에서 구현되어 매우 빠릅니다. 성능 측면에서 내장 속도를 달성하기 위해 스스로 새로운 데이터 구조를 구현하는 것은 거의 불가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nList는 C++의 std::vector과 유사하며, 동적 배열이다. 일정량의 메모리 공간을 미리 할당한다. 미리 할당된 메모리 공간이 사용되고 요소가 추가될 때, 더 큰 메모리 공간이 적용된다. 그럼 기존 요소를 모두 복사하고 이전 메모리 공간을 파괴하며 새 요소를 삽입한다.\n\n요소를 삭제할 때도 유사하다. 사용된 메모리 공간이 미리 할당된 메모리 공간의 절반보다 작으면 추가적인 작은 메모리가 적용되고, 요소 복사가 이루어진 뒤 큰 원래 메모리 공간이 파괴된다.\n\n따라서, 자주 추가 및 삭제 작업이 이뤄지고 추가 및 삭제된 요소의 수가 많은 경우, 리스트의 효율성은 높지 않을 수 있다. 이때 collections.deque를 사용하는 것을 고려해야 한다. collections.deque는 스택과 큐의 특성을 모두 가지며, 양쪽 끝에서 O(1) 복잡도의 삽입 및 삭제 작업을 수행할 수 있다.\n\n리스트 검색 작업도 매우 시간이 소요된다. 리스트에서 특정 요소를 자주 검색하거나 순서대로 이러한 요소에 자주 액세스해야 하는 경우, bisect를 사용하여 리스트 객체의 순서를 유지하고 검색 효율성을 향상시킬 수 있는 이진 검색을 수행할 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자주 필요한 요구사항은 최솟값 또는 최댓값을 찾는 것입니다. 이 경우 heapq 모듈을 사용하여 리스트를 힙으로 변환하여 최솟값을 얻는 시간 복잡도를 O(1)로 만들 수 있습니다.\n\n다음 웹 페이지에는 일반적으로 사용되는 Python 데이터 구조의 다양한 작업의 시간 복잡도가 나와 있습니다: [Python Time Complexity](https://wiki.python.org/moin/TimeComplexity).\n\n참고:\n\n- David Beazley \u0026 Brian K. Jones. Python Cookbook, Third edition. O’Reilly Media, ISBN: 9781449340377, 2013.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼도 방문해 주세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 대해 걱정할 필요 없는 블로그 플랫폼이 필요하시다구요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png"},"coverImage":"/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png","tag":["Tech"],"readingTime":13},{"title":"JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법","description":"","date":"2024-06-23 13:27","slug":"2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM","content":"\n\n## 아파치 아이스버그, 람다 및 프로젝트 네시를 사용하여 WAP의 오픈 소스 구현, 모두 Python으로 완전히 실행\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png)\n\n# 소개\n\n이 블로그 포스트에서는 Apache Iceberg를 열린 테이블 포맷으로 사용하고 git과 유사한 시맨틱을 지원하는 데이터 카탈로그인 프로젝트 네시를 사용하여 데이터 레이크에서 Write-Audit-Publish(WAP) 패턴에 대한 간결한 참조 구현을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNessie를 선택한 이유는 그 분기 기능이 WAP 디자인을 구현하는 데 좋은 추상화를 제공하기 때문입니다. 무엇보다도 개발자 경험 측면에서 JVM이 필요하지 않도록 PyIceberg를 기반으로 구축하도록 선택했습니다. 실제로 통합 애플리케이션을 포함한 전체 프로젝트를 실행하려면 Python과 AWS만 필요합니다.\n\nNessie는 기술적으로 Java로 구축되었지만 이 프로젝트에서는 데이터 카탈로그가 AWS Lightsail에 의해 컨테이너로 실행되며 우리는 단지 엔드포인트를 통해서만 상호 작용할 것입니다. 결과적으로 우리는 Python에서 쿼리 다운스트림을 포함한 전체 WAP 로직을 표현할 수 있습니다!\n\nPyIceberg가 상대적으로 새로운데, 기본으로 지원되지 않는 것들이 많습니다. 특히, 쓰기는 여전히 초기 단계에 있으며, Iceberg 테이블의 분기는 아직 지원되지 않습니다. 따라서 여기에서 찾을 수 있는 것은 Python에서 직접 Nessie에서 Iceberg 테이블을 분기하는 것이 가능하도록 우리가 직접 수행한 일부 원래 작업의 결과입니다.\n\n그렇게 해서 모든 것이 어느 정도 이루어졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 와닝! 낯선 단어 \"WAP\"이 나타났어요!\n\n2017년에 Netflix의 Michelle Winters가 데이터에서 사용되는 디자인 패턴인 Write-Audit-Publish (WAP)에 대해 이야기를 했어요. 기본적으로 WAP는 데이터 품질 검사를 하기 쉽게 만들기 위한 기능적 디자인을 지향해요. 이를 통해 데이터가 하류 사용자에게 제공되기 전에 데이터 품질 검사를 구현하는 것이 목표에요.\n\n예를 들어, 대표적인 사용 사례는 데이터 수집 시 데이터 품질을 확인하는 것이에요. 이 과정은 새로 수집된 데이터에 대해 스테이징 환경을 생성하고 품질 테스트를 진행한 후, 해당 데이터를 하류 애플리케이션에 제공하는 것처럼 보여요.\n\n이름에서 알 수 있듯이, WAP에는 기본적으로 세 단계가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작성. 소비자가 접근할 수 없는 위치에 데이터를 배치하십시오(예: 스테이징 환경 또는 브랜치).\n- 감사. 데이터를 변환하고 테스트하여 사양을 준수하는지 확인하십시오(예: 스키마가 갑자기 변경되었거나 NULL과 같이 예기치 않은 값이 있는지 확인).\n- 배포. 데이터를 소비자가 읽을 수 있는 위치에 배치하십시오(예: 프로덕션 데이터 레이크).\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_1.png)\n\n이것은 WAP 패턴의 가능한 응용 사례 중 하나에 불과합니다. ETL 및 데이터 수집부터 분석 및 ML 응용프로그램을 지원하는 복잡한 데이터 파이프라인까지 데이터 수명주기의 다양한 단계에서 적용할 수 있다는 것을 쉽게 알 수 있습니다.\n\n매우 유용한 WAP이지만 아직 널리 보급되지 않았으며 최근에 기업들이 더 체계적으로 생각하기 시작했습니다. 오픈 테이블 형식 및 Nessie, LakeFS와 같은 프로젝트의 등장으로 이 과정이 가속화되고 있지만 아직은 조금 전방적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어쨌든, 데이터에 대해 생각하는 아주 좋은 방법이며, 엔지니어들을 깨어나게 하는 일반적인 문제를 해결하는 데 굉장히 유용합니다. 그래서 우리가 어떻게 구현할 수 있는지 살펴봅시다.\n\n# Python에서 데이터 레이크에 대한 WAP\n\n우리는 WAP에 대한 이론적 논의를 하지 않을 것이며, 다른 방법을 구현하는 방법의 철저한 조사를 제공하지 않을 것입니다 (Dremio의 Alex Merced 및 LakeFs의 Einat Orr가 이미 이에 대해 훌륭한 작업을 하고 있습니다). 대신, 데이터 레이크에 대한 WAP의 참조 구현을 제공할 것입니다.\n\n# 아키텍처 및 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 아이디어는 섭밽 워크플로우를 시뮬레이션하고 데이터 레이크를 분기하고 데이터 품질 테스트를 실행하여 WAP 패턴을 구현하는 것입니다. 그 후 해당 데이터를 데이터 레이크의 최종 테이블에 넣을지 결정합니다.\n\n저희는 Nessie 분기 기능을 사용하여 다운스트림 소비자가 데이터를 읽을 수 없는 샌드박스 환경을 확보하고 AWS Lambda를 사용하여 WAP 로직을 실행합니다.\n\n기본적으로 새로운 파케이 파일이 업로드될 때마다 람다가 실행되어 데이터 카탈로그에서 브랜치를 생성하고 데이터를 아이스버그 테이블에 추가합니다. 그런 다음, PyIceberg를 사용하여 간단한 데이터 품질 테스트를 수행하여 테이블의 특정 열에 NULL 값이 포함되어 있는지 확인합니다.\n\n만약 그렇다면, 데이터 품질 테스트가 실패합니다. 새로운 브랜치는 데이터 카탈로그의 주요 브랜치에 병합되지 않으며, 데이터 레이크의 주요 브랜치에서 데이터를 읽을 수 없게 됩니다. 대신, 슬랙으로 경고 메시지가 전송될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 답이 '아니오'이고 데이터에 NULL 값이 포함되어 있지 않다면, 데이터 품질 테스트가 통과됩니다. 새 브랜치는 데이터 카탈로그의 주 브랜치로 병합되며 다른 프로세스가 읽을 수 있도록 데이터 레이크의 Iceberg 테이블에 데이터가 추가됩니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_2.png)\n\n모든 데이터는 완전히 합성되어 있으며 프로젝트를 실행함으로써 자동으로 생성됩니다. 물론, 데이터 품질 사양을 준수하는 데이터를 생성할지 또는 일부 NULL 값을 포함하는 데이터를 생성할지 선택할 수 있습니다.\n\n전체 엔드투엔드 플로우를 구현하기 위해 다음 구성 요소를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저장소: AWS S3\n- 오픈 테이블 형식: Apache Iceberg\n- 데이터 카탈로그: Project Nessie\n- 코드 구현: PyIceberg, PyNessie\n- 서버리스 런타임: Lambda\n- 가상 전용 서버: Lightsail\n- 경보 시스템: Slack\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_3.png)\n\n이 프로젝트는 상당히 자립적이며 전체 인프라를 설정하는 스크립트가 함께 제공되므로 AWS 및 Python에 대한 입문 수준만 있으면 됩니다.\n\n또한, 이 프로젝트는 프로덕션에 즉시 사용할 수 있는 솔루션이 아닌 참고 구현으로, 더 복잡한 시나리오를 위한 출발점입니다. 코드는 매우 상세하고 주석이 많아서 기본 개념을 수정하고 확장하여 누구의 사용 사례에 더 적합하게 만드는 것이 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시각화\n\n데이터 품질 테스트 결과를 시각화하기 위해 매우 간단한 Streamlit 앱을 제공합니다. 새 데이터가 S3의 첫 번째 위치에 업로드될 때 발생하는 일을 확인할 수 있습니다 — 이 위치는 하류 소비자들에게 제공되지 않습니다.\n\n앱을 사용하여 서로 다른 브랜치 간의 테이블에 있는 행의 개수를 확인할 수 있습니다. 또한, main 이외의 브랜치에서는 데이터 품질 테스트가 실패한 열과 행 수를 쉽게 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 호수에서 호수집까지\n\n아이스버그를 기반으로 한 WAP 플로우가 구성되면 이를 활용하여 하류 소비자를 위해 구성 가능한 디자인을 구현할 수 있습니다. 우리의 저장소에는 이러한 아키텍처 가능성을 탐색하는 방법으로 Snowflake 통합을 설명하는 지침을 제공합니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_5.png)\n\n이것은 호수집 아키텍처의 주요 원칙 중 하나로, 현대 데이터 웨어하우스보다 유연하고 전통적인 데이터 호수보다 사용하기 쉬운 설계로 고안되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한편, Lakehouse는 객체 저장소를 활용하여 데이터 중복을 제거하고 동시에 저장 비용을 낮추는 데 의존하며, 다른 목적을 위해 다양한 컴퓨트 엔진을 선택하는 데 더 많은 유연성을 제공해야 합니다.\n\n모든 것이 이론상 매우 흥미로워 보이지만, 대규모로 엔지니어링하는 것은 매우 복잡하게 느껴질 수 있습니다. 심지어 Snowflake와 S3 버킷 간의 단순한 통합조차 꽤 지루할 정도입니다.\n\n그렇다고 해도, 천 마일의 여정도 한 걸음부터 시작된다는 것을 염두에 두면, 간단하지만 구체적이고 실용적인 결과를 얻을 수 있는 가장 낮은 과일을 따라가는 게 어떨까요?\n\n저장소에서의 예시는 WAP 및 데이터 품질 테스트 중 하나를 보여줍니다. 여기서 WAP 패턴은 데이터 품질 테스트(그리고 어떤 경우에는 일부 적재 ETL에 대해서도)에 필요한 계산을 데이터 웨어하우스 외부로 이동시키는 기회를 제공하면서도 인증된 자산에 대한 높은 가치 분석 워크로드에 대한 Snowflake의 장점을 활용할 수 있도록 합니다. 이 게시물이 개발자들이 자신의 개념 증명을 구축하고 이용하는 데 도움이 되기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n여기 제안된 참조 구현에는 여러 가지 장점이 있습니다:\n\n## 테이블이 파일보다 좋습니다\n\n데이터 레이크는 과거에 개발하기 어려웠던 영역이었습니다. 왜냐하면 데이터 추상화는 일반적으로 좋은 구식 데이터베이스에서 채택된 것과 매우 다르기 때문입니다. Spark와 같은 Big Data 프레임워크는 먼저 파일로 저장된 대량의 원시 데이터를 처리할 수 있는 기능을 제공했지만, 사람들은 종종 파일의 관점으로 생각하지 않고 테이블의 관점으로 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이유가 있어 오픈 테이블 형식을 사용합니다. Iceberg는 주 파일 대신 테이블로 주 데이터 레이크 추상화를 변환하여 상당히 직관적으로 만듭니다. 데이터를 탐색하기 위해 이제는 SQL 쿼리 엔진을 네이티브로 사용할 수 있으며 정확한 스키마 진화를 제공할 수 있도록 Iceberg를 신뢰할 수 있습니다.\n\n## 상호 운용성이 좋아요\n\nIceberg는 아키텍처적으로 더 큰 상호 운용성도 허용합니다. 오픈 테이블 형식을 사용하는 주요 이점 중 하나는 데이터를 객체 저장소에 보관하면서 고성능 SQL 엔진(Spark, Trino, Dremio) 및 데이터 창고(Snowflake, Redshift)를 사용하여 쿼리할 수 있다는 것입니다. Iceberg가 대부분의 계산 엔진에서 지원된다는 사실은 우리가 데이터 플랫폼을 설계하는 방식에 깊은 영향을 미칩니다.\n\n위에서 설명한 대로, Snowflake와의 제안된 통합은 조정으로 ETL 처리 및 데이터 품질 테스트를 데이터 창고 밖으로 이동시키고 대규모 분석 작업 및 고성능 필요한 마지막 마일 쿼리에 대한 데이터 창고를 유지하는 것이 대규모 분석 작업으로 전환되어 상당히 낮은 비용으로 이어질 수 있다는 것을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 브랜치는 유용한 추상화입니다\n\nWAP 패턴은 데이터를 소비자가 실수로 읽을 수 없는 위치에 작성하는 방법을 필요로 합니다. 브랜치 세맨틱스는 이를 구현하는 방법을 제공하므로, 데이터 카달로그 수준에서 브랜치 세맨틱스를 활용하기 위해 Nessie를 사용합니다. Nessie는 Iceberg 및 해당 타임 트래버스 및 테이블 브랜치 기능을 기반으로 구축됩니다. 우리의 레포지토리에서 수행하는 많은 작업은 Nessie를 직접 Python에서 작동하도록 만드는 것입니다. 결과적으로 Nessie 카달로그에 상호 작용하고 데이터 카달로그의 여러 브랜치에 Iceberg 테이블을 작성할 수 있으며 JVM 기반 프로세스를 사용하지 않아도 됩니다.\n\n## 개발자 경험을 간소화합니다\n\n마지막으로, 끝에서 끝까지 완전히 Python 기반 경험을 만드는 것은 시스템 설정 및 상호 작용을 현저하게 간소화합니다. 우리가 알고있는 다른 시스템은 JVM이나 추가 호스팅 서비스가 필요하거나 서로 다른 브랜치에 다시 Iceberg 테이블을 작성하기 위해 외부에서 호스팅되어야 하는 반면, 이 구현에서는 전체 WAP 논리가 단일 람다 함수 내에서 실행될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJVM에는 본질적으로 문제가 없습니다. 많은 빅데이터 프레임워크의 근본적인 구성 요소로서, 특정 플랫폼 리소스와 작업하기 위한 공통 API를 제공함과 동시에 보안과 정확성을 보장합니다. 그러나 JVM은 개발자 경험 측면에서 부담이 될 수 있습니다. Spark와 작업한 사람들은 JVM 기반 시스템이 까다로우며 신비한 오류로 실패하는 경향이 있다는 사실을 알고 있습니다. 데이터 작업을 하는 많은 사람들은 Python을 주 프로그래밍 언어로 삼고 있기 때문에 JVM의 이점이 사용성 측면에서 비용이 드는 것으로 여겨집니다.\n\n우리는 이러한 것들처럼 더 많은 사람들이 조립 가능한 디자인에 대해 흥미를 가지길 바라며, Iceberg와 Arrow와 같은 오픈 표준이 표준이 될 것을 희망합니다. 그리고 무엇보다도 우리는 이것이 유용할 것이라고 기대합니다.\n\n그렇게 됩니다.","ogImage":{"url":"/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png"},"coverImage":"/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png","tag":["Tech"],"readingTime":8},{"title":"Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법","description":"","date":"2024-06-23 13:26","slug":"2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit","content":"\n\nNASA의 실제 글로벌 표면 온도 데이터 분석입니다.\n\n지난 몇 년 동안 여름에 온도 상승을 느낄 수 있었어요. 우리는 지난 몇 십 년간 NASA에 기록된 글로벌 표면 온도 지수에 대한 연구를 진행하고 파이썬 선형 회귀 모델을 기반으로 미래 추세를 파악할 거에요.\n\n![Global Warming Plot](/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png)\n\n지난 140년간의 지구 온난화 그래프:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터 프레임 gw에 전체 지구 온난화 데이터를 로드하고, 지난 140년간의 완전한 그래프 플롯을 생성했습니다 (음수 섭씨는 녹색, 양수 섭씨는 빨강색). 1970년부터 온도가 천천히 빨간 색으로 변하기 시작했고, 되돌아보지 않은 것 같습니다. 표면 온도가 0도 섭씨를 넘어선 후로 남극과 북극의 얼음이 천천히 녹고 있습니다.\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ngw = pd.read_csv(\"Global_Warming.csv\") # 지구 온난화 데이터를 gw에 로드합니다.\n\nx = gw['Year'] # 연도 값을 x에 할당합니다.\ny = gw['Index'] # 지수 값을 y에 할당합니다.\n\ngw2000 = gw[(gw['Year'] \u003e 1999)]  # 2000년 이후의 데이터를 gw2000에 할당합니다.\ngw2010 = gw[(gw['Year'] \u003e 2009)]  # 2010년 이후의 데이터를 gw2010에 할당합니다.\n\nx1 = gw2000['Year']\ny1 = gw2000['Index']\n\nx2 = gw2010['Year']\ny2 = gw2010['Index']\n\n# 음수 지수는 녹색, 양수는 빨간색으로 표시됩니다.\ncolors = np.where(gw['Index'] \u003e= 0, 'r', 'g') \n\nplt.figure(figsize =(20,8))\nplt.subplot(2, 1, 1)  # 전체 그래프를 표시할 첫 번째 행입니다.\nplt.xlabel('Year') \nplt.ylabel('Index') \nplt.bar(x, y, color=colors)\n\nplt.subplot(2, 2, 3) # 2000년 이후 그래프를 표시할 두 번째 행 첫 번째 열입니다.\nplt.xlabel('2000년부터의 연도') \nplt.ylabel('Index') \nplt.scatter(x1, y1, s=100, c='y', marker=\"o\", alpha=1, edgecolor='r')\n\nplt.subplot(2, 2, 4) # 2010년 이후 그래프를 표시할 두 번째 행 두 번째 열입니다.\nplt.xlabel('2010년부터의 연도') \nplt.ylabel('Index') \n\nplt.scatter(x2, y2, s=400, c='r', marker=\"^\", alpha=1, edgecolor='b')\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_1.png\" /\u003e\n\n직선 방정식의 값을 식별하는 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nY = mx + c의 직선 방정식입니다.\n여기서 m은 추세의 기욱이고 c는 Y-절편의 높이입니다.\nscikit 라이브러리를 사용하여 기울기(m)와 Y-절편(c)의 값을 생성할 예정입니다.\n\n```js\n# 완전한 데이터 세트 중 1974 이후의 데이터로 데이터프레임 생성.\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\nX = np.array(gw1974['Year'])\ny = np.array(gw1974['Index'])\nregression_model = LinearRegression() # scikit의 선형 회귀 모델 사용\nregression_model.fit(X.reshape(-1,1), y)\nslope = regression_model.coef_  # 기울기 값 식별\nintercept = regression_model.intercept_ # Y-절편 값 식별\nprint(\"기울기(m) 값은 \", slope, \"|| Y-절편(c) 값은 \", intercept)\n```\n\n```js\n1975년 이후의 NASA 표면 온도 지수(Celsius) 데이터셋입니다.\nYear Index\n1975 0.02\n1976 0.04\n1977 0.07\n1978 0.12\n1979 0.16\n...\n2022 1.00\n2023 1.02\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래 추세를 생성하기 위해 기울기와 Y-절편을 기반으로 하는 테이블 값을 변환했습니다:\n\n```js\ndef line(x):\n  # 함수 y = mx + c에 기울기(m)와 절편(c) 값을 할당합니다.\n  return 0.0196163 * x + (-38.71344489795919) \nx_pred = range(1974,2051)  # 1974년부터 2051년까지의 범위입니다.\n\n# 연도가 증가함에 따라 직선 방정식을 기반으로 기울기가 추가됩니다.\ny_pred = [line(i) for i in x_pred] \n\nimport matplotlib.pyplot as plt\nfig,ax = plt.subplots()\nax.bar(gw1974['Year'],gw1974['Index'],color = ['g'])\nax.stackplot(x_pred,y_pred, color=\"y\",linewidth = 2.5,linestyle = '--',alpha = 0.40)\nax.set_xlabel('Year')\nax.set_ylabel('표면 온도 지수')\nplt.title('지구 온난화 추세')\nplt.show()\n```\n\n직선 방정식을 기반으로 미래 추세를 생성하고, 지구 표면 지수가 매우 빠른 시간 내에 1.4도 섭씨를 넘는 것을 확인했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 몇 년 동안 표면 온도 분석을 기반으로 한 추론:\n\n- 탄소 배출이 중요하게 제어/감소되지 않으면 다음 24년 안에 표면 온도가 1.40도 섭씨를 넘을 것입니다.\n- 탄소 배출량이 증가하면 2050년 이전에 표면 온도가 1.50도 섭씨를 넘을 가능성이 있습니다.\n- 지속 가능한 에너지(태양광, 풍력, 수력, 생물 에너지)가 앞으로 지구 온난화를 통제하는 유일한 해결책이 될 것입니다.\n\n분석을 통해, 온난화가 개념으로만 여겨졌던 것보다 실제로 더 위험한 것으로 보입니다. 탄소 배출이 감소되지 않으면 전 세계적으로 재앙적인 기후 변화가 발생할 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png"},"coverImage":"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법","description":"","date":"2024-06-23 13:24","slug":"2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs","content":"\n\n안녕하세요!\n\n오늘은 Node.js 및 Express.js API에 대한 간단한 역할 기반 액세스 제어 (RBAC)를 구축하는 방법을 알아볼 것입니다. 이를 위해 인증을 위해 Keycloak을 사용할 것입니다.\n\nKeycloak 인증을 통해 Node + Express API를 안전하게 보호하는 해결책을 찾던 중 Keycloak Node.js 어댑터인 keycloak-connect를 만났습니다. 이 어댑터는 모든 요청과 함께 제공된 Bearer 토큰을 확인하는 프로세스를 간소화해주지만, 특정 역할이 있는 사용자가 특정 경로에 액세스할 수 있는지 확인하는 것은 조금 더 복잡해졌습니다.\n\n조사한 결과, Keycloak에서 큰 설정이 필요하지 않는 해결책을 찾을 수 있었습니다. 함께 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 준비 사항\n\n안내서를 따라 가기 전에 이미 독립적인 Keycloak 설정이 완료되어 있어야 합니다. 그렇지 않은 경우 Docker를 사용하여 빠르게 로컬에서 설정할 수 있습니다. 또한 사용자 액세스 토큰을 생성하는 방법이 이미 설정되어 있는 것을 기대합니다. (이전 글에서 구성한 프론트엔드 설정을 재사용할 수 있습니다)\n\n# 새로운 Node.js 프로젝트 만들기\n\n먼저, 로컬에서 새로운 Node.js 프로젝트를 시작해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm init\n```\n\n구성을 원하는 대로 변경할 수 있어요. 주로 기본 설정을 사용해요.\n\n## npm 패키지 설치\n\n이 프로젝트에 필요한 패키지를 설치해봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i cors dotenv express jsonwebtoken keycloak-connect nodemon\n```\n\n각 패키지에 대해 자세히 알아보려면 해당 공식 문서를 확인할 수 있어요.\n\njwt를 사용하여 API 요청을 통해 전달된 Bearer 토큰을 읽고, keycloak-connect를 사용하여 토큰을 확인할 거에요.\n\n로컬에서 API 서버를 실행하려면 package.json 파일에 스크립트를 추가해야 해요. \"scripts\" 아래에 이 줄을 객체에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 파일: package.json\n\n...\n\n\"start\": \"nodemon index.js\",\n\n...\n```\n\n사용 편의를 위해 package.json 파일에 루트 및 미들웨어 디렉토리의 경로 별칭도 추가했습니다.\n\n```js\n// 파일: package.json\n\n...\n\n\"imports\": {\n  \"#routes/*\": \"./routes/*.js\",\n  \"#middlewares/*\": \"./middlewares/*.js\"\n}\n\n...\n```\n\n## 기본 프로젝트 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI가 작동하는지 테스트하려면 간단한 기본 프로젝트를 만들어 보겠습니다. 루트 폴더에 index.js 파일을 추가해주세요.\n\n```js\n// 파일: index.js\n\nrequire('dotenv').config();\nconst cors = require('cors');\nconst express = require('express');\n\nconst port = process.env.PORT;\n\n// 라우터\nconst testRoutes = require('#routes/test');\n\nconst errorHandler = (error, req, res, next) =\u003e {\n  const status = error.status || 422;\n  res.status(status).send(error.message);\n}\n\nconst app = express();\n\napp.use(express.json());\napp.use(cors());\n\n// 라우트 등록\napp.use('/api', testRoutes);\napp.use(errorHandler);\n\napp.listen(port, () =\u003e {\n  console.log(`서버가 ${port} 포트에서 시작되었습니다.`);\n});\n```\n\n여기서 환경 변수를 사용하는 것을 주목했나요?\n\n프로젝트용 .env 파일을 만들고, 이미 만들지 않았다면 API에 사용할 포트 번호를 할당해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 테스트를 위해 라우트 파일을 사용하고 있습니다. 다음으로 그것을 생성해 봅시다.\n\n```js\n// 파일: routes/test.js\n\nconst express = require('express');\nconst router = express.Router();\n\n// 테스트 라우트\nrouter.get('/test', (req, res) =\u003e {\n  res.json({\n    message: \"API 연결이 설정되었습니다.\",\n    status: \"성공\"\n  })\n  .status(200);\n});\n\nmodule.exports = router;\n```\n\n## 기본 프로젝트를 가동해 봅시다\n\n로컬에서 API를 실행하려면 터미널에서 다음을 실행하세요 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm start\n```\n\n터미널에서 'Server Started at `port`'와 같은 메시지가 표시될 것입니다.\n\n모든 것이 동작하는지 확인하려면 브라우저에서 http://localhost:`port`/api/test을 열어보세요. 여기에서는 test.js 라우트 파일에서 만든 응답 객체를 확인할 수 있어야 합니다. 이는 우리의 기본 프로젝트가 기대한 대로 동작 중임을 의미합니다.\n\n# 사용을 위한 Keycloak 구성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정한 Keycloak으로 새로운 프로젝트를 위한 Realm을 생성해보세요. 저는 간단하게 \"rbacDemo\"라고 지었습니다.\n\n만들어진 Realm으로 이동한 후, 좌측의 \"Clients\"를 선택하고 \"Client 목록\" 탭에서 \"Client 만들기\" 버튼을 클릭해보세요. \"Client 만들기\" 양식에서 \"일반 설정\" 아래에 새로운 클라이언트 ID를 지정해주세요.\n\n\"Realm 역할\"로 이동하여 좌측에 있는 \"역할 만들기\" 버튼을 클릭해주세요. 우리는 이 Realm을 위한 관리자 역할을 만들 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지1](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_1.png)\n\n이제 \"Realm roles\"로 돌아가면 방금 만든 관리자 역할을 볼 수 있어야 합니다.\n\n이제 우리의 realm 및 클라이언트가 준비되었으므로 사용자가 필요합니다. 2명만 있으면 됩니다. 하나는 관리자 사용자이고 다른 하나는 일반 사용자입니다. \"사용자\"로 이동하고 \"사용자 추가\" 버튼을 클릭하세요.\n\n![이미지2](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n관리자 사용자가 생성되면 사용자의 \"사용자 세부정보\" 페이지로 이동하여 \"자격 증명\" 탭에서 사용자의 비밀번호를 설정해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_3.png)\n\n\n한 번 더 \"사용자\" 페이지로 돌아가서 다른 사용자를 추가해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n카렌을 위해도 비밀번호를 만들지 않도록하세요.\n\"사용자\"로 돌아가서 이제 목록에 Admin과 Karen 두 명의 사용자가 있는 것을 확인할 수 있을 거에요.\n\n이제 어드민 사용자로 이동하여 \"Role mapping\" 탭 아래에서 사용자에게 역할을 할당해볼까요?\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_5.png)\n\n이제 우리 어드민 사용자에게 \"admin\" 역할이 할당된 것을 확인할 수 있을 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_6.png\" /\u003e\n\n그것만으로도 Keycloak에서 RBAC 작업을 시작할 준비가 끝났습니다.\n\n# API에 RBAC 구현하기\n\n먼저 Keycloak Realm 및 Client ID를 .env 파일에 추가해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n키클로크가 있는 위치에 따라 KEYCLOAK_URL을 변경해주세요.\n\n## 키클로크 미들웨어 설정\n\nkeycloak-connect를 라우트의 미들웨어로 사용하려면, 새로운 미들웨어를 만들어야 합니다.\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// file: middlewares/keycloak.js\n\nconst Keycloak = require(\"keycloak-connect\");\nconst dotenv = require('dotenv').config();\n\nconst config = {\n  \"realm\": process.env.KEYCLOAK_REALM,\n  \"auth-server-url\": `${process.env.KEYCLOAK_URL}`,\n  \"ssl-required\": \"external\",\n  \"resource\": process.env.KEYCLOAK_CLIENT,\n  \"bearer-only\": true\n}\n\nmodule.exports = new Keycloak({}, config);\n```\n\n그런 다음 우리는 index.js에 방금 만든 미들웨어를 사용하도록 알려주어야 합니다.\n\n```js\n// file: index.js\n\n...\n\nconst express = require('express');\nconst keycloak = require('#middlewares/keycloak'); // Keycloak\n\n...\n\napp.use(keycloak.middleware());\napp.use(express.json());\n\n...\n```\n\n## 라우트에 Keycloak 미들웨어 추가하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 라우트 파일을 만들어 미들웨어를 사용할 것이에요.\n\n```js\n// 파일: routes/menuItems.js\n\nconst express = require(\"express\");\nconst router = express.Router();\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\n\n// 가짜 데이터\nconst menuItems = [\n  {\n    name: \"크루아상\",\n    price: \"$1\",\n    onMenu: true\n  },\n  {\n    name:\"라떼\",\n    price: \"$5\",\n    onMenu: true\n  },\n  {\n    name: \"로티 차나이\",\n    price: \"$0.50\",\n    onMenu: true\n  },\n  {\n    name: \"핫 초콜릿\",\n    price: \"$5\",\n    onMenu: false\n  },\n  {\n    name: \"사테\",\n    price: \"$8\",\n    onMenu: false\n  },\n  {\n    name: \"팟 타이\",\n    price: \"$7\",\n    onMenu: false\n  }\n];\n\n// 어떤 역할이든 열려 있는 라우트\nrouter.get(\"/menu-items\",\n[keycloak.protect()],\nasync (req, res, next) =\u003e {\n  try {\n    let filtered = menuItems.filter(item =\u003e {\n      if (item.onMenu === true) {\n        return item;\n      }\n    });\n\n    // 필터된 데이터 반환\n    res.json(filtered);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n라우트가 데이터 세트를 반환하도록 지시할 거에요. 일반적으로는 데이터베이스에서 하겠지만 여기서는 가짜 데이터를 사용할 거에요.\n\n## Keycloak 미들웨어 테스트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림: 여기서 사용자의 엑세스 토큰을 생성해야 합니다.\n\nBearer 토큰을 요청의 인증 헤더로 파싱하고 있다고 가정하면, 메뉴에 있는 항목만 응답을 받아야 합니다. /menu-items 경로는 모든 사용자에게 열려 있기 때문에 관리자와 카렌이 동일한 응답을 받아야 합니다.\n\nPostman을 사용하여 이를 테스트할 수 있습니다.\n\n## Bearer 토큰에서 데이터 디코딩 및 추출하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 \"admin\" 역할을 가진 사용자에게만 제한된 또 다른 경로를 추가해 봅시다.\n\n먼저 두 개의 미들웨어를 추가해야 합니다.\n하나는 jsonwebtoken을 사용하여 Bearer 토큰에서 사용자 데이터를 해독 및 추출하는 것이고, 다른 하나는 해당 사용자가 필요한 역할을 가졌는지 확인하는 것입니다.\n\n```js\n// file: middlewares/extractToken.js\n\nconst jwt = require(\"jsonwebtoken\");\n\nmodule.exports = async (req, res, next) =\u003e {\n  try {\n    // 액세스 토큰 디코딩\n    const bearerToken = req.headers.authorization;\n    // bearerToken은 \"Bearer \u003caccess_token\u003e\"을 반환합니다.\n\n    const token = bearerToken.split(\" \");\n    // token은 [\"Bearer\", \"\u003caccess_token\u003e\"]을 반환합니다.\n\n    const tokenData = jwt.decode(token[1]);\n    // tokenData는 사용자 데이터를 반환합니다.\n\n    // 해독된 토큰 데이터를 요청에 저장\n    req.tokenData = tokenData;\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n```js\n// file: middlewares/checkIfAdmin.js\n\nmodule.exports = async (req, res, next) =\u003e {\n  try {\n    const tokenData = req.tokenData;\n    const roles = tokenData.realm_access.roles;\n    // roles는 문자열 배열을 반환합니다.\n\n    const isAdmin = roles.includes(\"admin\");\n\n    if (isAdmin) {\n      // 사용자가 Admin 역할을 가지고 있는 경우, 진행합니다.\n      next();\n    } else {\n      // 사용자가 관리자가 아닌 경우 오류 발생\n      const error = new Error(\"액세스 거부: 이에 액세스할 수 있는 권한이 없습니다.\");\n      error.statusCode = 401;\n      throw error;\n    }\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작성된 미들웨어와 새로운 라우트를 메뉴 아이템 라우트 파일에 추가해보세요.\n\n```js\n// 파일: routes/menuItems.js\n\n...\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\nconst extractToken = require(\"#middlewares/extractToken\");\nconst checkIfAdmin = require(\"#middlewares/checkIfAdmin\");\n\n...\n\n// 어드민 역할만 접근 가능한 라우트\nrouter.get(\"/menu-items/all\", \n[keycloak.protect(), extractToken, checkIfAdmin],\nasync ( req, res, next) =\u003e {\n  try {\n    // 모든 데이터 반환\n    res.json(menuItems);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n이제 이 새로운 API 라우트를 Postman을 사용하여 두 사용자로 테스트해보세요.\n\nKaren의 토큰을 사용하면 액세스 거부 오류가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Admin의 토큰을 사용했다면, 메뉴에 있는 모든 항목을 얻을 수 있습니다.\n\n# 마무리\n\n여기서는 Node + Express API에 간단한 Role-Based Access Control (RBAC)를 구현하는 방법을 안내했습니다. Keycloak를 사용했습니다.\n\n이 안내서는 여러분의 API에 사용할 수 있는 방법을 쉽게 보여주기 위해 간소화되었습니다. 이 안내서에서는 GET 요청만 사용했지만 사실상 다른 요청 방법과 함께 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 가이드의 소스 코드는 여기에서 확인할 수 있어요. 이 기사에 대해 토론할 내용이 있다면 언제든지 연락해 주세요.\n\n읽어 주셔서 감사합니다. 다음에 또 만나요! 👋","ogImage":{"url":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png","tag":["Tech"],"readingTime":9},{"title":"Nodejs 애플리케이션에서 Winston으로 로깅하는 방법","description":"","date":"2024-06-23 13:23","slug":"2024-06-23-UsingWinstonforLogginginNodejsApplications","content":"\n\n로그 기록은 모든 애플리케이션에서 중요한 부분입니다. 디버깅, 모니터링 및 코드 유지 관리에 도움이 됩니다. 유연성과 기능이 풍부한 기능으로 Node.js에서 가장 인기 있는 로깅 라이브러리 중 하나인 Winston에 대해 알아보겠습니다. 이 기사에서는 Node.js 애플리케이션에 Winston을 통합하는 방법과 그 기능을 최대한 활용하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png)\n\n# 개요:\n\n이 튜토리얼에서 다룰 내용은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Node.js 프로젝트에서 Winston 설정하기.\n- 다른 로깅 레벨 구성하기.\n- 사용자 정의 로그 형식 만들기.\n- 여러 전송 방법 (콘솔, 파일 등)으로 로깅하기.\n- 사용자 정의 로그 레벨 만들기.\n- 매일 로그 파일에 로깅하기.\n- Express 애플리케이션에서 Winston 사용하기.\n\n# 준비물:\n\n- JavaScript 및 Node.js의 기본 지식.\n- npm 및 Express에 익숙해야 합니다 (마지막 단계에서 선택 사항이지만 권장됨).\n\n# 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js 프로젝트를 초기화해봅시다:\n\n```js\nmkdir winston-logger-example\ncd winston-logger-example\nnpm init -y\n```\n\nWinston을 설치해보세요:\n\n```js\nnpm install express winston winston-daily-rotate-file\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 설정:\n\nWinston을 설정하기 위한 logger.js 파일을 만듭니다:\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.colorize(),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) =\u003e `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- createLogger: 새 로거 인스턴스를 초기화합니다.\n- format.combine: 여러 형식을 결합하는데, 여기에서는 colorize, timestamp, printf를 사용합니다.\n- transports: 로그를 전송할 위치를 지정합니다. 이 예에서는 콘솔과 파일 (app.log)에 로그를 남깁니다.\n\n# 로깅 레벨 구성:\n\nWinston은 error, warn, info, http, verbose, debug, silly와 같은 여러 가지 로깅 레벨을 지원합니다. 캡쳐할 로그의 최소 레벨을 구성할 수 있습니다.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  levels: {\n    error: 0,\n    warn: 1,\n    info: 2,\n    http: 3,\n    verbose: 4,\n    debug: 5,\n    silly: 6\n  },\n  level: 'info', // 기본 로그 레벨 설정\n  format: format.combine(\n    format.colorize(),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) =\u003e `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설명:\n\n- levels: 사용자 정의 로깅 레벨을 정의합니다.\n- level: 캡처할 로그의 최소 레벨을 설정합니다 (여기서는 info로 설정되어 있음).\n\n# 로그 레벨 이해:\n\n로그 레벨은 기록되는 메시지의 심각성을 결정합니다. Winston은 npm 스타일 로깅 레벨을 사용하며, 가장 심각한 것부터 가장 적게 심각한 것까지 우선 순위가 정해져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- error: (0) 즉각적인 주의가 필요한 오류를 기록하는 데 사용합니다.\n- warn: (1) 잠재적인 문제를 나타내는 경고 메시지를 기록하는 데 사용합니다.\n- info: (2) 애플리케이션 진행 상황을 강조하는 정보 메시지를 기록하는 데 사용합니다.\n- http: (3) HTTP 요청을 기록하는 데 사용합니다.\n- verbose: (4) 디버깅 중 유용한 자세한 정보를 기록하는 데 사용합니다.\n- debug: (5) 디버깅 정보를 기록하는 데 사용합니다.\n- silly: (6) 필요 이상으로 자세한 정보를 기록하는 데 사용합니다.\n\n덜 심각한 메시지를 필터링하기 위해 최소 로그 레벨을 설정할 수 있습니다. 예를 들어, 로그 레벨을 info로 설정하면 info, warn, error 메시지만 기록됩니다.\n\n# 사용자 정의 로그 포맷 생성:\n\n필요에 맞게 사용자 정의 로그 포맷을 만들 수 있습니다. 예를 들어, 메타데이터를 추가하거나 로그 메시지 구조를 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst customFormat = format.combine(\n  format.colorize(),\n  format.timestamp(),\n  format.printf(({ timestamp, level, message, ...meta }) =\u003e {\n    return `${timestamp} ${level}: ${message} ${Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''}`;\n  })\n);\n\nconst logger = createLogger({\n  level: 'info',\n  format: customFormat,\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n해설:\n\n- customFormat: 타임스탬프, 로그 레벨, 메시지 및 선택적인 메타데이터를 구조화된 로그 형식으로 결합합니다.\n\n# 다중 전송으로 로깅하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n윈스턴은 서로 다른 파일, 외부 로깅 서비스 또는 콘솔과 같은 여러 대상에 로그를 기록할 수 있어요.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) =\u003e `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' }),\n    new transports.File({ filename: 'error.log', level: 'error' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n설명:\n\n- transports.File('filename: ‘error.log’, level: ‘error’'): 에러 메시지를 별도의 파일에 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 커스텀 로그 레벨 만들기:\n\n윈스턴(Winston)에서 자체적인 로그 레벨을 정의할 수 있습니다. 기본 레벨로는 충분하지 않은 특정 요구 사항이 있을 때 유용합니다.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports, config } = require('winston');\n\nconst customLevels = {\n  levels: {\n    critical: 0,\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4\n  },\n  colors: {\n    critical: 'red',\n    error: 'red',\n    warn: 'yellow',\n    info: 'green',\n    debug: 'blue'\n  }\n};\n\nconst logger = createLogger({\n  levels: customLevels.levels,\n  level: 'info', // 기본 로그 레벨 설정\n  format: format.combine(\n    format.colorize({ all: true }),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) =\u003e `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nwinston.addColors(customLevels.colors);\n\nmodule.exports = logger;\n```\n\n설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- customLevels: 사용자 정의 로깅 수준 및 해당하는 색상을 정의합니다.\n- winston.addColors: 로깅 수준에 사용자 정의 색상을 적용합니다.\n\n# 매일 로그 파일에 로깅하기:\n\nwinston-daily-rotate-file 전송을 사용하여 매일 새로운 로그 파일을 생성할 수 있습니다.\n\nwinston-daily-rotate-file를 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\nnpm install winston-daily-rotate-file\n\n매일 로테이트 파일 전송을 구성하세요:\n\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\nconst DailyRotateFile = require('winston-daily-rotate-file');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) =\u003e `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new DailyRotateFile({\n      filename: 'application-%DATE%.log',\n      datePattern: 'YYYY-MM-DD',\n      zippedArchive: true,\n      maxSize: '20m',\n      maxFiles: '14d'\n    })\n  ]\n});\n\nmodule.exports = logger;\n\n설명:\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DailyRotateFile: 지정된 날짜 패턴으로 매일 새 로그 파일을 생성합니다.\n- zippedArchive: 이전 로그 파일을 압축합니다.\n- maxSize: 로테이션하기 전 로그 파일의 최대 크기입니다.\n- maxFiles: 로그 파일을 유지하는 최대 일수입니다.\n\n# Express 애플리케이션에서 Winston 사용하기:\n\nWinston을 Express 애플리케이션에 통합하여 HTTP 요청과 오류에 대한 로깅을 처리하세요.\n\nExpress 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install express\n```\n\nWinston을 이용한 Express 서버 설정:\n\n```js\n// server.js\n\nconst express = require('express');\nconst logger = require('./logger');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// HTTP 요청을 로깅하는 미들웨어\napp.use((req, res, next) =\u003e {\n  logger.http(`${req.method} ${req.url}`);\n  next();\n});\n\napp.get('/', (req, res) =\u003e {\n  res.send('Hello, World!');\n});\n\n// 에러 처리 미들웨어\napp.use((err, req, res, next) =\u003e {\n  logger.error(err.message);\n  res.status(500).send('Internal Server Error');\n});\n\napp.listen(PORT, () =\u003e {\n  logger.info(`서버가 http://localhost:${PORT} 에서 실행 중입니다.`);\n});\n```\n\n설명:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- HTTP 요청 로깅: 미들웨어는 logger.http를 사용하여 수신된 모든 HTTP 요청을 로깅합니다.\n- 오류 처리 미들웨어: logger.error를 사용하여 오류를 로깅합니다.\n\n# 결론:\n\nWinston을 Node.js 애플리케이션에 통합함으로써 더욱 강력하고 유연한 로깅 시스템을 구축할 수 있습니다. 이를 통해 코드를 보다 효율적으로 디버깅, 모니터링 및 유지보수할 수 있습니다. 콘솔, 파일 또는 외부 서비스로 로그를 기록해야 하는 경우, Winston의 다양한 기능이 Node.js 로깅에 우수한 선택이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png"},"coverImage":"/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs를 이용한 이중 인증 구현 단계별 가이드","description":"","date":"2024-06-23 13:21","slug":"2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide","content":"\n\n오늘날의 디지턈 시대에서는 보안이 매우 중요합니다, 특히 웹 애플리케이션의 경우에는 더욱 그렇습니다. 두 단계 인증(2FA)을 구현하는 것은 애플리케이션의 보안을 향상시키는 효율적인 기술입니다.\n\n이 게시물은 node.js 개발자에게 가치 있는 정보일 것이지만, 개발자가 아니더라도 모든 프로그래밍 언어에 적용되는 주제이므로 여러분에게 많은 도움이 될 것입니다. Twilio Authy, Microsoft Authenticator, Google Authenticator 등 인기있는 인증 앱이 많이 있습니다. 이 튜토리얼에서는 Google Authenticator를 사용하여 2FA가 무엇인지, 애플리케이션 보안에 어떻게 도움이 되는지, 그리고 구현하는 방법에 대한 단계별 지침을 제공할 것입니다.\n\n## 두 단계 인증(2FA)이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이중 인증 또는 2FA는 사용자가 자신의 신원을 확인하기 위해 두 가지 다른 요소를 제공해야하는 보안 메커니즘입니다. 이러한 요소는 일반적으로 세 가지 범주로 나뉩니다:\n\n- 알고 있는 것 (예: 비밀번호)\n- 소지품 (예: 모바일 기기)\n- 본인인 것 (예: 생체 인식)\n\n일반적인 사용자 이름 및 비밀번호 조합 이외에도 2FA는 더 높은 수준의 보안을 추가합니다. 해커가 비밀번호를 얻거나 추측해도 두 번째 요소 없이 계정에 액세스할 수 없습니다.\n\n## Google Authenticator를 사용한 Node.js에서의 2FA 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2FA를 Node.js 애플리케이션에 Google Authenticator 앱을 사용하여 통합하는 방법을 알아봐요. 코딩 부분에 들어가기 전에 먼저 이 과정에 포함된 단계를 이해해 봅시다.\n\n- 비밀 키 생성: 사용자 등록 시마다 각 사용자를 위한 고유한 비밀 키를 생성해요.\n- QR 코드 생성: 비밀 키를 사용하여 사용자가 Google Authenticator 앱으로 스캔할 수 있는 QR 코드를 생성해요.\n- 사용자 설정: 애플리케이션에서 사용자에게 QR 코드 또는 비밀 키를 제공해요. 사용자는 Google Authenticator 앱으로 QR 코드를 스캔해야 해요.\n- OTP 코드 생성: 서버에서 비밀 키를 사용하여 시간 기반 일회용 암호(TOTP)를 생성해요. 이 코드는 매 30초마다 바뀌어요.\n- 사용자 인증: 로그인 시 사용자는 Google Authenticator 앱에서 생성된 현재 OTP를 입력해야 해요.\n- 검증: 사용자가 입력한 OTP를 서버에서 생성된 OTP와 비교해요. 일치하면 사용자가 인증됩니다.\n\n이제 재미있는 부분이 다가와요 :) 우리는 위 단계들을 모두 코드로 변환할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n양방향 인증을 구현하기 전에 다음 사전 요구 사항을 갖추었는지 확인해주세요:\n\n- JavaScript 또는 TypeScript의 기본 지식.\n- API 디자인과 CRUD 패턴에 대한 기본 이해.\n- 시스템에 Node.js의 최신 버전이 설치되어 있어야 합니다.\n- Node.js와 Express에 대한 기본 지식이 있어야 합니다.\n\n## 단계 1: Node.js 프로젝트 설정\n\n시작하기 위해 프로젝트용 새 디렉토리를 만들고 터미널에서 해당 디렉토리로 이동한 후 새 Node.js 프로젝트를 초기화하고 필요한 패키지를 설치하세요. 아래 명령어를 터미널에서 실행해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir node_2fa\ncd node_2fa\nnpm init -y\nnpm install express otpauth hi-base32\n```\n\n- express – Node.js 웹 프레임워크\n- otpauth – TOTP를 생성하고 유효성을 검사하는 라이브러리\n- hi-base32 – 데이터를 Base32 형식으로 인코딩 및 디코딩하는 기능을 제공하는 라이브러리입니다. Authenticator 앱에서 TOTP를 생성하는 데 사용할 것입니다.\n\n## 단계 2: Express 서버 설정\n\n프로젝트에 index.js 파일을 만들고 기본 express 서버를 설정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) =\u003e {\n  res.send('이중 인증 예제');\n});\n\napp.listen(port, () =\u003e {\n  console.log(`서버가 포트 ${port}에서 실행 중입니다`);\n});\n```\n\n## 단계 3: 사용자 등록\n\n이 단계에서는 사용자 등록을 구현하고 사용자 정보를 안전하게 저장합니다. 보통 이를 위해 데이터베이스를 사용하지만, 이 예시에서는 간단함을 위해 내부 배열을 사용합니다. MongoDB를 이용한 포괄적인 예시는 제 GitHub 레포지토리에서 확인할 수 있습니다. https://github.com/Nik720/2fa-nodejs\n\n```js\nconst users = [];\n\n// 새로운 사용자 등록을 위한 엔드포인트\napp.post('/register', (req, res) =\u003e {\n  const { username, password } = req.body;\n  const id = users.length + 1;\n\n  // 사용자 정보를 안전하게 저장 (사용자의 비밀번호 포함)\n  users.push({ id, username, password });\n  res.status(201).send({\n    status: \"성공\",\n    message: \"사용자가 성공적으로 생성되었습니다\"\n  });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Step 4: Enable Two-Way Authentication](/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_1.png)\n\n## 단계 4: 두 가지 요소 인증 활성화\n\n이제 otpauth 라이브러리를 사용하여 두 가지 요인 인증을 구축해 봅시다. 사용자가 인증 앱으로 스캔할 수있는 QR 코드를 표시하고 일회용 코드를 확인하는 비밀 키를 생성하는 것이 이 프로세스의 단계입니다.\n\n```js\nconst OTPAuth = require(\"otpauth\");\nconst encode = require(\"hi-base32\");\nconst QRCode = require('qrcode');\n\n// 두 가지 요소 인증 활성화를 위한 엔드포인트\napp.post('/enable-2fa', (req, res) =\u003e {\n  const { username } = req.body;\n\n  // 사용자를 사용자 이름으로 찾기 (여기서는 데이터베이스를 사용해야 함)\n  const user = users.find((u) =\u003e u.username === username);\n\n  if (!user) {\n    return res.status(404).send('사용자를 찾을 수 없습니다.');\n  }\n\n  // 사용자를 위한 비밀 키 생성\n  const base32_secret = generateBase32Secret();\n  user.secret = base32_secret;\n\n  // 사용자가 스캔할 QR 코드 URL 생성\n  let totp = new OTPAuth.TOTP({\n      issuer: \"YourSite.com\",\n      label: \"YourSite\",\n      algorithm: \"SHA1\",\n      digits: 6,\n      secret: base32_secret,\n  });\n\n  let otpauth_url = totp.toString();\n\n  // 생성된 QR 코드를 응답으로 보내기\n  QRCode.toDataURL(otpauth_url, (err) =\u003e {\n        if(err) {\n            return res.status(500).json({\n                status: 'fail',\n                message: \"QR 코드 생성 중 오류 발생\"\n            })\n        }\n        res.json({\n            status: \"success\",\n            data: {\n                qrCodeUrl: qrUrl,\n                secret: base32_secret\n            }\n        })\n    })\n});\n\nconst generateBase32Secret = () =\u003e {\n  const buffer = crypto.randomBytes(15);\n  const base32 = encode(buffer).replace(/=/g, \"\").substring(0, 24);\n  return base32;\n};\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드 스니펫에서 개발한 GenerateBase32Secret() 메서드는 base32로 인코딩된 비밀 키를 생성하는 데 사용됩니다. 이 키는 TOTP 생성 메커니즘의 중요한 구성 요소입니다. 또한 필요한 인수로 인스턴스화 한 후에 totpvariable에 OTPAuth.TOTP 클래스를 할당했습니다.\n\n다음으로, totp.toString() 함수를 사용하여 TOTP Auth URL을 가져왔습니다. QR 코드를 생성하고 응용 프로그램에서 TOTP 인증을 구성하기 위해 필요한 인코딩된 비밀과 필요한 설정은 이 URL에서 사용할 수 있습니다. 또한, 미래에 이러한 값을 사용할 수 있도록 base32 비밀 문자열을 사용자 객체에 저장했습니다.\n\n마지막 단계에서는 QR 코드 라이브러리를 사용하여 otpauth_url로 QR 코드를 만들고 JSON 응답에 QR 코드 URL과 base32 비밀 문자열을 반환했습니다. 클라이언트에게 이러한 값을 반환함으로써 클라이언트 측 구현을 유연하고 쉽게 할 수 있습니다. 이를 통해 클라이언트는 base32 비밀 문자열을 사용하거나 인증 애플리케이션을 스캔하여 QR 코드를 사용하여 관련 TOTP 토큰을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증 확인의 마지막 단계로 진행하기 전에, 먼저 인증 앱을 구성하여 다음 단계에서 토큰으로 제공될 6자리 코드를 생성해야 합니다.\n\nGoogle Authenticator 앱을 활성화하기 위해 중요한 몇 가지 단계가 필요합니다. 이를 편리하게 하기 위해 여기서는 Chrome 확장 프로그램을 사용하고 있습니다. API에서 제공된 base64 비밀을 수동으로 입력하거나 계정을 추가하기 위해 QR 코드를 스캔해야 합니다.\n\n![2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_3.png](/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_3.png)\n\n## 단계 5: 양방향 인증 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 사용자가 제공한 일회용 코드를 확인하는 엔드포인트를 구현하세요. 이 단계에서는 인증 앱에서 생성된 6자리 코드를 전달하여 사용자의 신원을 확인해야 합니다.\n\n```js\n// 두 단계 인증 코드를 검증하는 엔드포인트\napp.post('/verify-2fa', (req, res) =\u003e {\n  const { username, token } = req.body;\n\n  // 사용자명으로 사용자 찾기\n  const user = users.find((u) =\u003e u.username === username);\n\n  if (!user) {\n    return res.status(404).send('사용자를 찾을 수 없습니다');\n  }\n\n  // 토큰을 검증합니다.\n  let totp = new OTPAuth.TOTP({\n      issuer: \"YourSite.com\",\n      label: \"YourSite\",\n      algorithm: \"SHA1\",\n      digits: 6,\n      secret: user.secret!,\n   });\n\n  let delta = totp.validate({ token });\n\n  if(delta) {\n        res.json({\n            status: \"success\",\n            message: \"인증 성공\"\n        })\n    } else {\n        res.status(401).json({\n            status: \"fail\",\n            message: \"인증 실패\"\n        }) \n    }\n});\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_4.png\" /\u003e\n\n이 게시물은 2단계 인증의 기본 설정 및 사용법을 다룹니다. 사용자의 존재 여부를 확인하는 기능을 구현했지만, 실제 구현에서는 2FA를 활성화하거나 비활성화하거나 인증하기 전에 사용자 로그인 상태를 추가로 확인해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMongoDB 데이터베이스를 활용한 포괄적인 예제를 구축했어요. 모든 필수 API 엔드포인트와 미들웨어를 통합했습니다. 자세한 내용은 GitHub 레포지토리를 방문해주세요. https://github.com/Nik720/2fa-nodejs\n\n최초 블로그 게시: https://codeshakti.com/how-to-implement-two-factor-authentication-using-node-js-step-by-step-guide/\n\n## 결론\n\n이 게시물에서 설명된 기술들인 QR 코드 기반 토큰 생성 및 안전한 OTP 확인을 적용함으로써, 무단 접근에 대한 강력한 방어막을 만들고 Node.js 사용자에게 비교할 수 없는 보호를 제공할 수 있습니다. 오늘부터 2FA 시스템을 구축하여 더 안전한 디지털 공간으로 나아가는 첫걸음을 내딛어보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이 글을 즐겼나요?\n\n다음 글에서는 노드 JS 클러스터 모듈을 활용하여 로드 밸런서를 만드는 방법에 대해 더 자세히 다룰 것입니다.\n\n제 글이 마음에 드셨다면 아래 작은 👏을 눌러주세요 (50번 타포도 가능합니다). 더 많은 기술 기사를 위해 팔로우해주세요. 친구들 👦, 동료들 👭 🧑‍🤝‍🧑 와 공유해주세요.\n\n여러분의 지지를 감사히 받겠습니다. 💚 읽어 주셔서 감사합니다! 🙏\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 블로깅 사이트 codeshakti.com에서 기술 블로그에 대해 더 많은 정보를 찾아보세요.\n\n코딩 즐거움을 느끼세요... 😁","ogImage":{"url":"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법","description":"","date":"2024-06-23 13:20","slug":"2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs","content":"\n\n몽고디비에서 문서 내 배열 업데이트하기.\n\n![이미지](/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png)\n\nNode.js와 몽고디비를 이용하여 애플리케이션 배열 내 특정 applicationId의 활성 상태를 업데이트하려면 $set 연산자를 사용해야 합니다. $ 연산자는 쿼리 조건과 일치하는 첫 번째 배열 요소를 업데이트할 수 있도록 합니다.\n\n```js\n// applications 배열에서 지정된 applicationId를 포함하는 문서를 찾는 쿼리.\nconst filter = { _id: userId, 'applications.applicationId': applicationId };\n\n// 활성 상태를 설정하는 업데이트.\nconst updateDoc = {\n  // $set 및 $ 연산자 활용: 일치하는 applicationId의 active 필드를 업데이트.\n  $set: { 'applications.$.active': newStatus }\n};\n\nconst result = await collection.updateOne(filter, updateDoc);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 설명:\n\n- 필터: 필터 객체는 특정 userId(또는 문서의 다른 고유 식별자)와 applications 배열 내의 applicationId를 가진 문서를 찾고 있는지를 나타냅니다.\n- 업데이트: $set 연산자는 일치하는 배열 요소의 active 필드를 업데이트하기 위해 위치 $ 연산자와 함께 사용됩니다.\n\n## 이제 중첩된 배열에서 여러 applicationId의 활성 상태를 업데이트하는 방법:\n\n한 번의 작업에서 applications 배열 내의 여러 applicationId 항목의 활성 상태를 업데이트하려면 $set 연산자를 $[`identifier`] 배열 필터와 함께 사용할 수 있습니다. 이를 통해 배열 내의 요소를 일치시키고 이에 따라 업데이트할 수 있는 여러 조건을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 여러 applicationId 항목을 업데이트하는 단계:\n\n- MongoDB에 연결: MongoDB 클라이언트를 사용하여 데이터베이스에 연결합니다.\n- 쿼리 정의: 업데이트할 문서를 지정합니다.\n- Array Filters와 $set 사용: 배열 필터를 사용하여 여러 applicationId 항목을 일치시키고 업데이트합니다.\n- 업데이트 처리: 업데이트 명령을 실행하고 응답을 처리합니다.\n\n# 예시 코드\n\n다음은 Node.js와 MongoDB를 사용하여 이 작업을 수행하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nconst { MongoClient } = require('mongodb');\r\n\r\n// 귀하의 MongoDB 연결 문자열과 데이터베이스 이름으로 대체합니다.\r\nconst uri = 'mongodb://localhost:27017';\r\nconst dbName = '귀하의데이터베이스이름';\r\nconst collectionName = '귀하의컬렉션이름';\r\n\r\nasync function updateApplicationStatu(userId, updates) {\r\n  const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });\r\n\r\n  try {\r\n    await client.connect();\r\n    console.log('MongoDB에 연결됨');\r\n\r\n    const database = client.db(dbName);\r\n    const collection = database.collection(collectionName);\r\n\r\n    // 사용자 문서 가져오기\r\n    const userDoc = await collection.findOne({ _id: userId });\r\n\r\n    if (!userDoc) {\r\n      console.log('사용자 문서를 찾을 수 없음');\r\n      return;\r\n    }\r\n\r\n    // applications 배열을 초기화\r\n    if (!userDoc.applications) {\r\n      userDoc.applications = [];\r\n    }\r\n\r\n    const updateOperations = [];\r\n    const applicationIds = userDoc.applications.map(app =\u003e app.applicationId);\r\n\r\n    // 중첩 배열 내 여러 applicationId의 활성 상태를 업데이트\r\n    updates.forEach(update =\u003e {\r\n      if (applicationIds.includes(update.applicationId)) {\r\n        // 기존 애플리케이션 상태를 업데이트\r\n        updateOperations.push({\r\n          updateOne: {\r\n            filter: { _id: userId, 'applications.applicationId': update.applicationId },\r\n            update: { \r\n              $set: { 'applications.$.active': update.active },\r\n              $addToSet: { updatedBy: req.session.userId }\r\n            }\r\n          }\r\n        });\r\n      } else {\r\n        // 존재하지 않는 경우 새로운 애플리케이션 추가\r\n        updateOperations.push({\r\n          updateOne: {\r\n            filter: { _id: userId },\r\n            update: {\r\n              $push: {\r\n                applications: { applicationId: update.applicationId, active: update.active }\r\n              }\r\n            },\r\n            $addToSet: { updatedBy: req.session.userId }\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    // 대량 쓰기 작업 수행\r\n    const result = await collection.bulkWrite(updateOperations);\r\n\r\n    if (result.modifiedCount \u003e 0 || result.insertedCount \u003e 0) {\r\n      console.log('애플리케이션 상태가 성공적으로 업데이트됨.');\r\n    } else {\r\n      console.log('일치하는 애플리케이션이 없거나 변경된 내용이 없습니다.');\r\n    }\r\n  } catch (error) {\r\n    console.error('애플리케이션 상태 업데이트 오류:', error);\r\n  } finally {\r\n    await client.close();\r\n  }\r\n}\r\n\r\n// 사용 예시: 여러 애플리케이션 업데이트\r\nupdateApplicationStatuses('userId123', [\r\n  { applicationId: 'Apple', active: true },\r\n  { applicationId: 'Mango', active: false },\r\n  { applicationId: 'Orange', active: true }\r\n]);\r\n```\r\n\r\n# 설명\r\n\r\n- MongoDB 연결: MongoDB 인스턴스에 연결을 설정합니다.\r\n- 데이터베이스 및 컬렉션: 작업할 데이터베이스 및 컬렉션을 지정합니다.\r\n- 필터: 필터 객체는 userId 또는 문서의 다른 고유 식별자를 기반으로 문서를 식별합니다.\r\n- 업데이트 오브젝트: updateDoc은 $set 연산자를 사용하여 지정된 applicationId 엔트리의 활성 상태를 업데이트합니다. 필드 경로는 배열 필터를 동적으로 사용하기 위해 구성됩니다.\r\n- 배열 필터: arrayFilters 옵션을 사용하여 어떤 요소를 업데이트해야 하는지를 정의하는 조건을 정의합니다. 각 필터는 업데이트해야 할 applicationId에 해당합니다.\r\n- updatedBy 필드: updatedBy는 applications 배열의 일부가 아닌 문서의 별도 필드입니다. 요구 사항에 따라서 applications 배열에서 수정이나 추가가 있을 때마다 updatedBy 필드를 업데이트해야 합니다.\r\n- 결과 처리: 업데이트 작업이 문서를 수정했는지 확인하고 결과를 로그에 남깁니다.\r\n\r\n만약 applicationId가 존재하지 않는 경우 해당 활성 상태와 함께 추가되어야 합니다. 이를 위해 쿼리와 업데이트 작업을 혼합해 사용합니다.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계:\n\n- 문서 가져오기 및 확인: _id별로 문서를 가져와서 applications 배열의 각 applicationId를 확인합니다.\n- 업데이트 수행: applicationId가 있는지 여부에 따라 기존 객체를 업데이트하거나 새로운 객체를 추가합니다.\n\n# 예시 코드\n\n다음은 Node.js와 MongoDB를 사용하여 이 작업을 수행하는 전체 예시 코드입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst { MongoClient } = require('mongodb');\n\n// 귀하의 MongoDB 연결 문자열 및 데이터베이스 이름으로 대체합니다.\nconst uri = 'mongodb://localhost:27017';\nconst dbName = '당신의데이터베이스이름';\nconst collectionName = '당신의컬렉션이름';\n\nasync function updateApplicationStatuses(userId, updates) {\n  const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });\n\n  try {\n    await client.connect();\n    console.log('MongoDB에 연결되었습니다.');\n\n    const database = client.db(dbName);\n    const collection = database.collection(collectionName);\n\n    // 사용자 문서 검색\n    const userDoc = await collection.findOne({ _id: userId });\n\n    if (!userDoc) {\n      console.log('사용자 문서를 찾을 수 없습니다.');\n      return;\n    }\n\n    // applications 배열을 초기화합니다.\n    if (!userDoc.applications) {\n      userDoc.applications = [];\n    }\n\n    const updateOperations = [];\n    const applicationIds = userDoc.applications.map(app =\u003e app.applicationId);\n\n    updates.forEach(update =\u003e {\n      if (applicationIds.includes(update.applicationId)) {\n        // 기존 애플리케이션 상태 업데이트\n        updateOperations.push({\n          updateOne: {\n            filter: { _id: userId, 'applications.applicationId': update.applicationId },\n            update: { $set: { 'applications.$.active': update.active } }\n          }\n        });\n      } else {\n        // 새로운 애플리케이션 추가\n        updateOperations.push({\n          updateOne: {\n            filter: { _id: userId },\n            update: {\n              $push: {\n                applications: { applicationId: update.applicationId, active: update.active }\n              }\n            }\n          }\n        });\n      }\n    });\n\n    // 일괄 작성 작업 수행\n    const result = await collection.bulkWrite(updateOperations);\n\n    if (result.modifiedCount \u003e 0 || result.insertedCount \u003e 0) {\n      console.log('애플리케이션 상태를 성공적으로 업데이트했습니다.');\n    } else {\n      console.log('일치하는 애플리케이션이 없거나 변경 사항이 없습니다.');\n    }\n  } catch (error) {\n    console.error('애플리케이션 상태를 업데이트하는 중 오류 발생:', error);\n  } finally {\n    await client.close();\n  }\n}\n\n// 예제 사용법: 여러 애플리케이션을 업데이트\nupdateApplicationStatuses('userId123', [\n  { applicationId: 'Apple', active: true },\n  { applicationId: 'Mango', active: false },\n  { applicationId: 'Orange', active: true }\n]);\n```\n\n만약 도움이 되었다면 👏 👏 를 좀 받아도 괜찮으세요? 다른 사람들에게도 도움이 될 수 있도록 글을 공유해주시면 정말 감사하겠습니다 :)\n\n언제나 환호해 주세요...\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:156/0*9zGASKmAOha2Ov3S.gif\" /\u003e\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png","tag":["Tech"],"readingTime":8}],"page":"10","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"10"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>