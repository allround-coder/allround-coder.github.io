<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/154" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/154" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리덕스 사가 사용하는 방법(기초)" href="/post/2024-05-01-GettingStartedwithReduxSagaTutorial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리덕스 사가 사용하는 방법(기초)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리덕스 사가 사용하는 방법(기초)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리덕스 사가 사용하는 방법(기초)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">43<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" href="/post/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" href="/post/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link" href="/posts/143">143</a><a class="link" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a><a class="link" href="/posts/152">152</a><a class="link" href="/posts/153">153</a><a class="link posts_-active__YVJEi" href="/posts/154">154</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리덕스 사가 사용하는 방법(기초)","description":"","date":"2024-05-01 17:33","slug":"2024-05-01-GettingStartedwithReduxSagaTutorial","content":"\n## 리덕스 기초를 제공하는 새가 튜토리얼입니다. 기초부터 고급 수준까지의 예제를 통해 리덕스 사가를 배워보세요. 리덕스 사가 개념을 활용하여 블로그 앱을 만들어보세요.\n\n![](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png)\n\n## 배경:\n\n약 2개월 전에 리덕스 사가를 배우기 시작했고, 리덕스에 대한 이해도가 조금밖에 없었습니다. 처음에는 혼란스러울 수 있지만, 한번 감을 잡게 되면 코드가 더 깔끔해지고 앱도 더 나아질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 일반적으로 하는 것과는 다른 방식으로 정보를 공유해보려고 노력했습니다. 여러 작은 앱을 만들어 한 가지 또는 여러 개념을 이해하는 데 중점을 두었습니다. 이 기사가 여러분이 실용적인 방식으로 개념을 이해하는 데 도움이 되기를 바랍니다.\n\n## 어떻게 진행할 것인가요?\n\n리덕스에 대해 간단히 다시 설명한 후 리덕스 사가의 다양한 개념을 예제와 함께 이해하는 데 도움이 될 것입니다.\n\n## 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n필요한 라이브러리는 다음과 같습니다:\n\n```js\nyarn add @reduxjs/toolkit@1.8.3\nyarn add react-redux@8.0.2\nyarn add redux-saga@1.1.3\n//선택 사항\nyarn add axios@0.27.2\n```\n\n연습용으로 새 리액트 또는 리액트 네이티브(원하는 대로 선택) 프로젝트를 만들고 위의 패키지를 설치하세요. 저는 'redux-saga-tutorial'이라는 프로젝트를 만들었습니다:\n\n```js\nnpx create-react-app redux-saga-tutorial\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_1.png)\n\n# Redux 간단 안내:\n\n리덕스의 몇 가지 개념을 빠르게 되새겨 보겠습니다. 이 섹션 끝에는 기본적인 리덕스 예제가 풀코드로 제공됩니다.\n\n초기 상태 / 전역 상태:\n초기 상태는 앱의 모든 초기 값이 있는 일반 JS 객체입니다. 모든 최신 값이 포함된 전역 상태라고도 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 앱 전체가 숫자를 증가 및 감소하는 데 관한 것이라면 초기 상태는 `value: 0, name: ''`와 같은 객체여야 합니다. API에서 아직 로드되지 않은 데이터와 같은 추가적인 사항이 있다면 초기 상태는 `allUserChats: [], allUsers: [], isLoggedIn: false...`와 같이 정의할 수 있습니다. 앱에서 필요한 모든 것들의 기본값을 가진 초기 상태를 사용할 수 있습니다.\n\n최신 업데이트된 초기 상태의 값은 저장소에 유지될 것입니다. 저장소를 진실의 단일 출처로 생각하고 redux가 제공하는 저장소에서 값을 읽고 업데이트할 것입니다.\n\n액션:\n액션은 일반적인 JS 문자열입니다. 일반적으로 `domain/eventName`와 같은 형태로 선언합니다. 이러한 상수는 `profile/updateName`과 같은 고유한 액션의 이름입니다. 모든 것에는 액션 변수가 있어야 합니다.\n\n액션은 앱에서 일어날 수 있는 모든 것으로 생각할 수 있습니다. 예를 들어, 앱에서 특정 API를 호출한다면 해당 API를 호출하는 액션이 있어야하며, 성공한 경우의 다른 액션 및 데이터를 검색하는 데 실패한 경우의 다른 액션이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n액션 크리에이터:\n우리는 const SOME_ACTION_NAME = `domain/eventName`과 같이 액션 문자열을 만들고, 데이터를 전달할 수 있는 함수인 액션 크리에이터를 생성합니다. 보통, 액션 크리에이터에는 두 가지가 있습니다. 첫 번째는 우리가 만든 변수를 전달할 수 있는 액션의 이름인 type이고, 두 번째는 데이터를 보내는 payload입니다. payload라는 이름은 아무것이나 될 수 있습니다.\n\n```js\nfunction someActionCreator(text) {\n  return { type: SOME_ACTION_NAME, payload: text };\n}\n```\n\n만약 const NAME_UPDATED = `profile/updateName`와 같은 이름의 액션이 있다면, 해당 액션 크리에이터는 다음과 같을 것입니다:\n\n```js\nfunction updateProfile(text) {\n  return { type: NAME_UPDATED, payload: text };\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npayload과 type은 원하는 대로 이름을 지을 수 있어요. 대부분의 개발자들이 사용하는 규칙이죠.\n\nReducer:\nReducer는 두 가지를 받는 함수에요:\n\n- 초기 상태의 현재 상태\n- 액션 객체 (기본적으로 액션 생성자)\n\n```js\nconst initialState = { name: \"\" };\nfunction myReducer(state = initialState, action) {\n  switch (action.type) {\n    case NAME_UPDATED:\n      return { ...state, name: action.payload };\n    default:\n      return state;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nswitch 문이 있다. 이 switch 문은 NAME_UPDATED 액션을 찾는데, 보통 상수로 선언된 별도의 파일에 있을 것입니다. 예를 들어, const NAME_UPDATED = `profile/updateName` 같은 식으로 선언될 것입니다.\n\n어떤 액션이 취해지면 해당 리듀서를 호출하고, 리듀서는 취해진 액션을 확인하고 초기 상태를 업데이트할 겁니다. 이러한 요소를 아직 연결하지는 않았지만요.\n\n이제 받게 될 액션은 state와 action 두 가지를 가질 겁니다. action은 우리가 위에서 액션 생성기 섹션에서 본 것처럼 객체일 겁니다. 그리고 우리는 보내는 type과 payload를 사용할 겁니다.\n\nProvider / Redux를 주요 애플리케이션에 연결하기:\nRedux 레이어 안에 우리 앱을 래핑하는 방법을 빠르게 살펴볼게요. 이를 통해 store 객체를 앱 전반에 걸쳐 접근 가능하게 만들 수 있습니다. index.js 같은 주 파일에서, 우리는 Provider를 가져와서 앱을 감싸는데, 이것은 접근이 필요한 모든 중첩된 컴포넌트에 store를 사용할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Provider } from \"react-redux\";\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { myReducer } from \"../reducers\";\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\n// const rootReducer = combineReducers({myFirstReducer}); //in case you have more than one reducer. Don't forget to import it from @reduxjs/toolkit\nconst store = configureStore({ reducer: myReducer });\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cProvider store={store}\u003e\n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\n위의 코드에서는 하나의 reducer와 하나의 액션을 갖는 스토어 내에 전체 `App /`을 감쌌습니다. 이제 앱에서 디스패치가 발생하면 Provider가 해당 디스패치를 캐치하고 스토어에 전달합니다. 그런 다음 스토어는 리듀서로 이동하여 함수를 실행합니다.\n\n디스패치:\n어떻게 액션을 트리거할까요? 현재 액션은 한 파일에 있고 리듀서는 다른 파일에 있습니다. Redux가 리듀서로 이동하고 올바른 작업을 수행하도록 액션이 트리거되어야 합니다. 이때 디스패치(dispatch)가 필요합니다. `react-redux`에서 import useDispatch를 사용하여 가져올 수 있고, 다음과 같이 변수를 만들어서 액션의 디스패처로 사용할 수 있습니다: const dispatch = useDispatch();. 버튼이 있고 그 버튼의 onPress에서 dispatch(type: NAME_UPDATED, payload: input.text); 같은 작업을 할 수 있지만, 앞서 updateProfile와 같은 액션 생성자를 만든 경우 다음과 같이 호출할 수 있습니다:\n\n```js\nimport { useDispatch } from 'react-redux';\nfunction example() {\n    const myDispatch = useDispatch();\n    return (\n        \u003cButton title='Update Name' onPress={() =\u003e {\n            myDispatch(updateProfile('input.text'))\n        } /\u003e\n    )\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 버튼을 눌렀거나 앱을 통해서도 동작을 수행할 수 있습니다. API 응답을 통해 작업을 트리거할 수 있습니다.\n\n선택기:\n선택기를 사용하면 리덕스 스토어에서 데이터를 추출할 수 있습니다. useDispatch와 마찬가지로 선택기에도 useSelector라는 훅이 있습니다.\n\n```js\nimport { useSelector } from \"react-redux\";\nfunction example() {\n  const mySelector = useSelector((store) =\u003e store);\n  return \u003cText\u003e{mySelector.name}\u003c/Text\u003e;\n}\n```\n\nuseSelector()는 뷰를 다시 렌더링하도록 강제하지만, 선택기 결과가 마지막 결과와 다른 것처럼 보일 때에만 다시 렌더링을 수행합니다. 전체 스토어를 반환하며, 초기 상태에 있는 것들에 접근할 수 있지만 업데이트된 값을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것을 함께 해보자!\n위의 예제를 다음 보일러플레이트 코드에 결합한 것을 살펴봅시다:\n\n위의 코드 예제에서는 App.js에서 액션을 디스패치했으며(useDispatch), App.js에서 이를 소비하고 있습니다(useSelector). 앱은 단순히 값을 업데이트하여 보이는 것을 빠르게 확인할 수 있습니다.\n\n이것은 리덕스가 어떻게 작동하는지에 대한 매우 간단한 예시입니다. 동일한 개념을 사용하여 다른 작업들을 구축할 수 있습니다. 예를 들어, API 데이터를 상태로 로드하는 경우에는 name 대신에 다른 이름을 사용할 수 있습니다. 예를 들어 allProductsData 또는 allUser 등이 될 것입니다. 그리고 이것은 문자열(string) 유형이 아니라 객체 또는 배열 [] 또는 객체들의 배열 또는 그 외의 것들이 될 것입니다. 따라서 다음과 같은 경우에는 액션을 생성하고 리듀서에서 처리할 수 있습니다. API 호출의 경우, 이 튜토리얼에서 이전에 작성한 파이어베이스 예시를 참조할 수 있습니다.\n\n이 내용이 유익하게 느끼는 분들을 위해, 새 페이지를 추가해보고 해당 페이지로 이동하여 선택기(selector)만 호출해보세요. 그러면 값이 업데이트된 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Redux Saga](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_2.png)\n\n# Redux Saga:\n\n가장 쉽게 설명하는 방법은 redux-saga는 비즈니스 로직을 프론트엔드로부터 분리한다는 것입니다. Saga는 이벤트 기반 솔루션이라고 언급할 수 있으며, 이벤트를 발생시키고 해당 이벤트에 대해 실행되어야 하는 로직을 처리합니다.\n\nRedux-saga가 어떻게 작동하는지 이해하려면 redux-saga의 개념을 이해한 후에 명확해질 수 있는 다양한 플로우 다이어그램을 찾을 수 있습니다. 여기에 하나의 다이어그램이 있습니다. 전반적인 아이디어를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Getting Started with Redux Saga Tutorial](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_3.png)\n\n위 다이어그램에서 사용자가 'Get Users' 버튼을 누르면 액션이 발생합니다. 이 액션은 사가로 전송되고, 사가 파일에서는 특정 액션이 취해졌을 때 어떻게 할지를 정의합니다. 특정 액션이 발생했을 때 우리 앱이 수행하길 원하는 API 또는 다른 유형의 기능을 의미합니다. 따라서 API 호출 / 결과 대기 단계는 사용자 액션이 발생했을 때 수행할 기능의 일부입니다. 이 단계가 점선으로 표시되는 이유는, 이것이 필수 단계가 아니며 사가가 직접적으로 리듀서로 이동할 수 있지만, 리듀서 확인은 과정에서 필수적인 단계이고, 리듀서는 필요에 따라 상태를 업데이트하거나 동일한 상태를 반환할 것입니다. 아래 GIF 이미지는 인터넷에서 발견한 것입니다. developpaper 웹사이트에서 찾았던 것 같은데, 리덕스 사가 환경에서 $10을 입금하는 액션이 어떻게 발생하는지 보여줍니다. GIF 아래의 미들웨어를 사가로 생각해보세요.\n\n![Redux Saga Tutorial GIF](https://miro.medium.com/v2/resize:fit:1400/1*AyYYoeDMTTK_7J7aCeaIUA.gif)\n\n위의 플로우를 기억하며, 사가 학습을 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스-사가의 개념을 이해하려면 API를 호출하는 간단한 예제를 살펴보는 것이 도움이 됩니다. 따라서 사가를 사용하여 이를 수행하는 프로그램을 작성해 보겠습니다. 그러나 그 전에 리덕스-사가를 이해하는 데 도움이 될 두 가지 JavaScript 관련 사항이 있습니다:\n\n- 제너레이터 함수\n- 제너레이터 함수에서의 yield 키워드\n\n제너레이터 함수에 대한 간단한 개관을 작성했는데 여기에는 yield 부분도 포함되어 있습니다.\n\n그래서 이 튜토리얼에서는 제너레이터 함수 및 yield에 대해 자세히 다루지는 않겠지만 사가를 배우려면 위의 JavaScript 개념을 알고 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 첫 번째로 우리 이야기를 시작하는 데 필요한 고수준의 설정을 해 봅시다. 우리가 store를 설정할 때 index.js 파일에서 한 것과 같이요.\n\n```js\n// ... 다른 imports\nimport { Provider } from \"react-redux\";\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport createSagaMiddleware from \"@redux-saga/core\";\nimport { myReducer } from \"./reducers\";\nimport App from \"./App\";\nconst rootElement = document.getElementById(\"root\");\nconst root = createRoot(rootElement);\nconst sagaMiddleware = createSagaMiddleware();\nconst store = configureStore({ reducer: myReducer, middleware: [sagaMiddleware] });\n// TODO: 곧 여기서 saga를 실행해야 합니다\nroot.render(\n  \u003cStrictMode\u003e\n    \u003cProvider store={store}\u003e\n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  \u003c/StrictMode\u003e\n);\n```\n\n위 코드에서 세 가지를 했어요:\n\n- 이름에 명시된대로 우리 앱에서 saga를 생성하는 데 도움이 될 createSagaMiddleware를 가져왔어요.\n- 우리가 모든 saga의 기능에 액세스할 수 있게 해주는 변수 sagaMiddleware를 생성했어요.\n- 변수 sagaMiddleware을 store에 포함시켜 reducer를 다룬 것과 같이 앱 전체에서 액세스할 수 있도록 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니까 세 가지 작업을 수행해서 saga가 앱 전반에 걸쳐 사용할 수 있도록 준비할 거에요. 저는 saga를 메시지를 지속적으로 수신 대기하면서 실행되는 서비스로 생각해요. 메시지가 시작되면 그 다음에 뭘 해야 하는지 알고 있어요.\n\n이 세 가지 작업을 actions.js에 추가해볼까요?\n\n```js\nexport const GET_USERS_FETCH = \"GET_USERS_FETCH\";\nexport const GET_USERS_SUCCESS = \"GET_USERS_SUCCESS\"; // API 호출을 성공적으로 완료할 때 호출될 거에요\nexport const GET_USERS_FAILURE = \"GET_USERS_FAILURE\"; // API 호출을 실패로 완료할 때 호출될 거에요\n```\n\n액션을 생성할 때 대부분의 경우 액션 크리에이터도 함께 만듭니다. 여기서는 GET_USERS_FETCH에 대한 액션 크리에이터만 필요할 거에요. dispatch와 함께 호출될 것이기 때문에 useDispatch가 인자로 객체를 가져야 하며, saga 이펙트를 사용할 때 문자열을 전달할 수 있어서 그에 대한 액션 크리에이터가 필요하지 않을 거에요. 그러니까 actionCreators.js에 해당 액션 크리에이터를 만들어봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { GET_USERS_FETCH } from \"./actions\";\nexport function takeGetUserFetchAction() {\n  return { type: GET_USERS_FETCH };\n}\n```\n\n매개변수가 필요하지 않기 때문에 단순히 타입만 반환하는 간단한 자바스크립트 객체입니다. 그러나 필요한 경우 매개변수를 전달해야 할 때는 redux 리프레셔 섹션에서 updateProfile(text)를 참조하십시오.\n\n이제 sagas.js라는 새 파일을 만들고 세 부분으로 이 파일을 만들어 보겠습니다:\n\nPART 1 — sagas를 사용하여 API를 호출하는 것이 목표이므로 먼저 API를 호출하고 응답을 반환하는 일반 함수를 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport axios from \"axios\";\nfunction userFetch() {\n  // 만약에 axios를 사용하고 싶지 않은 경우\n  //return.fetch('https://jsonplaceholder.typicode.com/users').then(response =\u003e response.json());\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n위의 부분에서는 간단히 res.data;를 반환하는 함수를 만들었으며, 성공적으로 검색하고 오류가 발생할 경우 err을 throw합니다.\n\n파트 2 — 이제 사용자가 호출되고 응답에 따라 작업을 트리거하는 제너레이터 함수를 작성할 것입니다.\n\n```js\nimport { call, put } from \"redux-saga/effects\";\nimport { GET_USERS_SUCCESS, GET_USERS_FAILURE } from \"./actions\";\n// ... axios와 같은 다른 import\n// ... userFetch 함수와 같은 다른 코드\nfunction* getUsersFetch() {\n  try {\n    const users = yield call(userFetch);\n    //yield는 다음 줄로 넘어가기 전에 이 호출이 완료되기를 기다릴 것입니다.\n    yield put({ type: GET_USERS_SUCCESS, users });\n  } catch (error) {\n    yield put({ type: GET_USERS_FAILURE, error });\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 호출(fetch)을 하는 매우 직관적인 제너레이터 함수가 있습니다. 사용자 호출(fetch)로부터 응답이나 오류가 반환될 때까지 기다리도록 yield를 사용하였습니다. redux-saga/effects에서 call은 함수를 호출하는 데 사용되며 결과를 users 변수에 저장합니다. 다음으로, put은 미들웨어에 action을 스토어에 디스패치(dispatch)할 것을 예약하는 효과 설명을 생성합니다. 이 디스패치는 즉시 이루어지지 않을 수 있으며, Saga 작업 큐에서 다른 작업이나 진행 중인 작업이 있을 수 있습니다. 그래서 디스패치가 완료되면 결과를 성공 또는 실패로 전달할 것입니다.\n\n제 3부 — Redux 프레임워크에서는 액션이 중요한 역할을 합니다. 각각이 다른 목적을 가진 앱에서 실행되는 고유한 프로세스입니다. 따라서 채워야 할 액션이 하나 남았는데, 바로 GET_USERS_FETCH입니다. 이 액션을 디스패치할 때마다 getUsersFetch를 호출할 것입니다.\n\n```js\nimport { call, put, take } from \"redux-saga/effects\";\nimport { GET_USERS_FETCH } from \"./actions\";\n// ... axios, actions 등의 다른 import들\n// ... userFetch, getUsersFetch 함수 등의 다른 코드\nfunction* mySaga() {\n  while (true) {\n    yield take(GET_USERS_FETCH);\n    yield call(getUsersFetch);\n  }\n}\nexport default mySaga;\n```\n\n위의 코드에서 GET_USERS_FETCH 액션이 발생할 때마다, saga는 getUsersFetch 제너레이터 함수를 호출하여 API에 대한 호출을 수행하고 성공 또는 실패 시 액션을 트리거하는 동작을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`take`는 미들웨어에게 Store에서 특정 액션을 기다리라는 Effect 설명을 만듭니다. 즉, 버튼을 누를 때 이를 듣고 있을 것이며, 우리가 액션을 디스패치할 때 take(GET_USERS_FETCH)가 이 액션을 알거나 이를 듣고 있는 상태이며, 이 액션이 발생하면 getUsersFetch 제너레이터 함수를 호출합니다. 따라서 yield는 매우 중요한 개념으로, 이것은 일시중지/재개를 담당하는 문 앞의 가드와 같습니다. 즉, yield take(GET_USERS_FETCH)는 GET_USERS_FETCH 액션이 발생할 때까지 대기 상태에 있을 것입니다. 해당 액션이 발생하면 그 yield는 완료되고, 그런 다음 yield call이 작동하며 getUsersFetch로부터 응답이 올 때까지 더 이상 실행되지 않게 됩니다.\n\n이 제너레이터 함수의 이름은 mySaga이며 이것은 루트 또는 메인 리듀서에서 본 것과 같이 우리의 주요 사가가 될 것입니다. 우리는 모두를 사용하여 사가를 결합할 수 있지만, 이 특정 예제에서는 하나만 있을 것입니다.\n\n이게 sagas.js 파일에 있는 모든 내용입니다.\n\n다음으로 우리는 액션을 수행할 reducer.js 파일을 준비할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { GET_USERS_FAILURE, GET_USERS_SUCCESS } from \"./actions\";\nconst initialState = {};\nconst myReducer = (state = initialState, action) =\u003e {\nswitch (action.type) {\ncase GET_USERS_SUCCESS: return { ...state, payload: action.users };\ncase GET_USERS_FAILURE: return { ...state, payload: action.error };\ndefault: return state;\n};\nexport default myReducer;\n```\n\n이 리듀서는 성공 또는 실패 이벤트가 발생했을 때 호출됩니다. 이제 할 일이 두 가지만 남았어요. 하나는 API가 반환할 데이터를 표시할 수 있도록 App.js를 변경하는 것이고, 두 번째는 우리가 index.js에 // TODO:를 추가한 sage를 실행하는 것입니다. 먼저 sage를 실행한다는 것이 무엇을 의미하는지 살펴보겠습니다.\n\nsage를 백그라운드에서 계속 실행되는 서비스로 생각해보세요. 사용자가 취한 동작의 수를 넣으면 적절히 처리하여 성공 또는 실패를 반환합니다. 기다렸다가 현재 것을 해결한 다음 다음 동작을 수행합니다. 그러므로 루트 파일에서 실행할 필요가 있습니다. index.js를 열고 다음 한 줄의 코드(사실상 2줄)를 추가하세요:\n\n```js\nimport mySaga from \"./sagas\";\n// ... 모든 다른 import 및 코드 위에\nsagaMiddleware.run(mySaga);\n// ... 루트에 render(...와 같은 다른 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n런은 앱이 실행 중이라면 작업이 발행될 때마다 우리의 사가를 시작합니다. 그 다음으로, 정확히 그것을 할 거에요. App.js를 열고 버튼을 누르면 fetch 작업이 트리거되는 UI를 만들어볼 거에요.\n\n```js\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { takeGetUserFetchAction } from \"./actionCreators\";\n\nfunction App() {\n  const myDispatch = useDispatch();\n  const retrivedData = useSelector((state) =\u003e {\n    return state.myReducer;\n  });\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003ch1\u003eUsers\u003c/h1\u003e\n      \u003cbutton onClick={() =\u003e myDispatch(takeGetUserFetchAction())}\u003eCall API\u003c/button\u003e\n      \u003chr /\u003e\n      \u003cdiv\u003e\n        {retrivedData?.users \u0026\u0026 retrivedData.users.map((user) =\u003e \u003cdiv key={user.id}\u003e{user.name}\u003c/div\u003e)}\n        {retrivedData?.error \u0026\u0026 \u003cp\u003e{retrivedData.error.message}\u003c/p\u003e}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\nuseSelector에서 전체 상태를 반환할 수도 있었지만, 관심 있는 reducer만 선택했어요. 사용자 또는 오류가 발생할 것이므로 데이터를 그에 맞게 렌더링하고 있습니다. 지금 실행하고 버튼을 클릭하면 데이터가 표시될 거에요. 그러나 사가 파일의 URL을 https://jsonplaceholder.typicode.com/user로 변경하면 오류가 출력될 거에요.\n\n따라서 사가를 사용하여 간단한 API 요청을 만들었습니다. 여기 모든 주제에 대한 실행 예시를 보여주는 코드가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 위 예제를 더 간단하게 만드는 방법\n\n위 예제에서 우리는 목표를 달성했습니다. 그러나 여러분이 redux 훅들을 사용하여 매우 쉽게 작업할 수 있음을 알 수 있기 때문에 더 간단하게 만들 수 있습니다. createAction, createReducer 등의 많은 훅들이 있으며 우리가 살펴볼 것입니다.\n\n가능한 한 더 많은 부분을 순수 JS로 유지하여 뒷단을 이해할 수 있도록 기본적인 접근 방식을 취했습니다. 그래서 이제 우리가 할 일은 몇 가지 더 많은 훅과 효과를 사용하여 위 예제를 간소화하고 그것이 어떻게 간단해지는지 확인하는 것입니다.\n\n지금쯤에 혹시 saga가 어떻게 작동하는지 주목하지 못했다면, saga를 백그라운드에서 실행되는 서비스로 생각할 수 있습니다. 지속적으로 액션을 수신하며 해당 액션이 트리거되면 즉시 작동하여 액션을 수행하고 다른 쓰레드에서 다른 함수를 실행하고 다양한 작업을 완전 비동기적으로 수행 할 수 있는 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 해야 할 첫 번째 일은 actions.js 파일과 actionCreators.js 파일 두 개 대신에 actions.js 파일 하나만 필요할 것이라는 것이에요. 그리고 아래 코드를 추가할 거에요:\n\n```js\nimport { createAction } from \"@reduxjs/toolkit\";\nexport const GET_USERS_FETCH = createAction(\"GET_USERS_FETCH\");\nexport const GET_USERS_SUCCESS = createAction(\"GET_USERS_SUCCESS\");\nexport const GET_USERS_FAILURE = createAction(\"GET_USERS_FAILURE\");\n```\n\n이것은 각각에 대한 action과 action 생성자를 만들었기 때문에, 많은 시간을 절약할 수 있고 actions를 생성하고 사용하는 복잡성을 줄일 수 있어요. 또한, 디스패치(dispatch), 선택자(selector), 또는 리듀서(reducer)에 전달할 때 문자열(action) 또는 객체(action 생성자)가 어디로 갈지 걱정할 필요가 없어요. 이를 전달하면 createAction이 대신 책임지고 필요한 대로 사용되고 자동으로 반환할 거라는 거죠.\n\ncreateAction을 사용해 매개변수를 전달하고 다양한 작업을 할 수도 있고, 간단하게 action을 생성하는 법도 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 createReducer에 대해 살펴보겠습니다. 이름에서 알 수 있듯, 여러 귀찮은 일을 덜어주는 reducer를 만들어줄 겁니다. createReducer(INITIAL_STATE, 빌더 콜백 함수)라는 두 가지 매개변수를 사용합니다. (빌더 함수는 .을 사용하여 조인 가능한 체인 구조를 계속하여 만들 수 있는 함수입니다.)\n\n그래서 우리는 reducer.js 파일을 다시 작성할 거에요:\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_USERS_FAILURE, GET_USERS_SUCCESS } from \"./actions\";\nconst initialState = {};\nconst myReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_USERS_SUCCESS, (state, action) =\u003e {\n      state.users = action.users;\n    })\n    .addCase(GET_USERS_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myReducer;\n```\n\n위의 코드에서, switch 문에서 했던 것과 유사한 작업을 했지만 여기서는 빌더 함수 접근 방식을 사용했습니다. 우리는 .addCase를 원하는 만큼 사용할 수 있고, 그 후 .addDefaultCase(선택사항)를 사용하여 기본 문을 처리할 수 있어서 builder.addCase(...).addCase(...).addCase(...)….addDefaultCase(...)과 같은 체인 빌더를 생성할 수 있습니다. 모든 case는 상태와 액션을 가지며, 상태/초기 상태를 업데이트할 수 있도록 지정할 수 있습니다. 이것을 스위치 문 형식으로 생각한다면 매우 간단합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 \"createAction\"과 \"createReducer\"을 사용하면 코드의 복잡성을 줄일 수 있다는 것을 보았어요. 위의 변경 사항을 적용하려면 'App.js'에서 액션을 디스패치하는 부분에 작은 변경 한 가지를 해야 해요. 다음과 같이 바꿔 주세요:\n\n```js\n// ... 다른 import들\nimport { GET_USERS_FETCH } from \"./actions\";\n// ... 다른 코드\n\u003cbutton onClick={() =\u003e dispatch(GET_USERS_FETCH())}\u003eAPI 호출\u003c/button\u003e;\n```\n\nGET_USERS_FETCH는 createAction을 사용하여 생성되었기 때문에 액션 생성자가 자동으로 생성되어 있으므로 GET_USERS_FETCH()와 같이 호출할 수 있고, 이렇게 하면 액션이 트리거되어요. 사가에 변경 사항이 없었기 때문에 액션이 캐치될 것이며, 나머지 플로우도 그에 따라 작동할 거에요. 우리의 리듀서도 예상대로 작동할 거에요.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 예전 예제를 확장해서 일을 더 쉽게 만들기로 했으니, 사가를 사용하는 앱에서 널리 사용되는 또 다른 것을 다루는 것이 좋겠죠. 아래에는 이 세 가지에 대한 간단한 설명이 있고, 그 후에 우리가 만드는 앱에서 이들을 사용하는 방법을 살펴볼 거에요.\n\n- take\n  yield take(pattern)의 결과는 디스패치된 액션 객체입니다. 이는 미들웨어 (saga)에게 특정 액션이 저장소에서 취해질 때까지 기다리라고 알려줍니다. take는 한 번만 액션을 취하기 때문에 버튼을 클릭할 때마다 작업을 하려면 while(true) ... 안에 넣어야 합니다. 또는 use case에 따라 takeEvery나 takeLatest를 사용할 수도 있어요.\n- takeEvery\n  GET_USERS_FETCH 액션을 동시에 호출하도록 가능하게 합니다. 주어진 순간에 우리는 아직 종료되지 않은 하나 이상의 이전 GET_USERS_FETCH 작업이 있을 때, 새로운 GET_USERS_FETCH 작업을 시작할 수 있습니다. GET_USERS_FETCH 액션을 실행하면 이를 버튼에서 디스패치합니다. takeEvery는 동시 작업을 처리할 수 있게 해줍니다. 위의 예에서 GET_USERS_FETCH 액션이 디스패치되면, 이전 GET_USERS_FETCH가 아직 종료되지 않은 상태여도(예를 들어, 사용자가 빠르게 두 번 연속 'API 호출' 버튼을 클릭한다면, 두 번째 클릭에서는 fetchUser가 아직 종료되지 않았더라도 GET_USERS_FETCH 액션이 디스패치됩니다)\n- takeLatest\n  한 번에 하나의 GET_USERS_FETCH 작업만 활성화될 수 있습니다. 또한, 가장 최근에 시작된 작업이 될 것입니다. 이전 작업이 계속 진행 중일 때 새로운 GET_USERS_FETCH 작업이 시작된다면, 이전 작업은 즉시 중단됩니다. takeEvery와는 반대로, takeLatest는 동일하게 실행 중인 작업을 중지하고 새 작업을 시작합니다. 각 액션이 저장소에 디스패치될 때마다. 액션이 패턴과 일치하면 takeLatest가 백그라운드에서 새로운 saga 작업을 시작합니다. 이전에 시작된 saga 작업이 있었다면(실제 액션이 디스패치되기 전의 마지막 액션에서 시작된 경우), 그 작업이 계속 실행 중이었다면, 해당 작업은 취소될 것입니다.\n\ntake, takeEvery, takeLatest의 실제 예제를 보려면 이를 시도해 보세요:\n\n그러니 sagas.js 파일을 열어서 take와 call 라인을 다음과 같이 바꿔주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { call, put, takeEvery } from \"redux-saga/effects\";\nfunction* mySaga() {\n  yield takeEvery(GET_USERS_FETCH, getUsers);\n}\n```\n\n매우 간단한 방법으로, GET_USERS_FETCH가 실행될 때마다 getUsers 함수를 실행하라는 것을 나타내는 것이다. 이전과 똑같이 작동하는 것을 확인할 수 있을 것이다. 이제 takeEvery를 사용하는 이유와 takeLatest 또는 take를 사용하지 않는 이유는 사용 사례에 따라 달라진다.\n\n따라서 기본적으로 이전에 작성한 앱을 변환한 것입니다. 이번에는 간단하게 만드는 데 집중했습니다. createAction, createReducer, takeEvery 등의 사용법을 배웠습니다.\n\n지금까지 한 모든 변경 내용이 반영된 코드는 다음과 같습니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 고급 개념을 간단하게\n\n여기서는 고급으로 간주되는 몇 가지 개념을 다룰 것입니다. 그러나 그 본질을 이해한다면 실은 간단한 경우도 있습니다. 이전 섹션에서 본 것처럼, 여기서도 상황은 비슷할 것입니다. 모든 것을 다 다룰 수는 없겠지만, 가능한 많은 개념을 사용하는 예시를 살펴볼 것입니다. fork, cancel, createSelector 등 몇 가지 주제를 다룰 예정입니다.\n\n플로우를 차단할 것인지 말 것인지, 그리고 기대만들 것인지 여부를 이해하는 것이 중요한 포인트가 될 것입니다. 이는 yield가 다음 코드 줄을 실행하기 전에 기다릴 것인지 여부가 우리가 사용하는 효과에 따라 다르다는 것을 의미합니다. 그래서, 간단하고 명확한 설명은 다음과 같습니다:\n\n## 차단/비차단 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 테이크(take), 콜(call), 푸트(put) 등 사가의 다양한 효과를 보았어요. 이를 두 가지 범주로 분류할 수 있어요:\n\n- 블로킹(Blocking)\n- 논블로킹(Non-Blocking)\n\n블로킹 호출은 사가가 효과를 생성하고, 해당 실행 결과를 기다린 다음에야 생성기 안에서 다음 명령을 재개할 것을 의미해요.\n\n논블로킹 호출은 사가가 효과를 생성한 후 즉시 재개될 것을 의미해요. 즉, 호출자는 작업을 시작하고 완료를 기다리지 않고 실행을 계속할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTLDR; Blocking은 흐름을 차단하고 non-blocking은 길을 막지 않습니다. 우리가 배운 대로, yield는 응답/에러가 제공되거나 현재 작업에서 해결/거부될 때까지 실행을 일시 중단하지만 어떤 사가 효과는 과정을 일시 중단시키지 않는 non-blocking이며 실행 중인 작업 기능을 백그라운드에서 실행하면서 코드가 다음 줄을 실행할 수 있게 합니다. 예시가 있습니다:\n\n다른 많은 것들이 있고 앱에서 모두 사용하지 않을 수 있지만 어떤 것이 차단 또는 비차단 호출인지 알아두는 것이 좋습니다. 다음은 효과 목록이며 차단/비차단 여부입니다:\n\n차단/비차단 설명에서 알 수 있듯이, 사가를 사용함으로써 우리는 시스템을 통해 논리가 어떻게 흐를지를 많이 제어하고 데이터 흐름과 각 효과가 다양한 사용 사례에서 유용한 기능을 갖습니다.\n\n# Fork \u0026 Cancel\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nfork()은 (일종의 takeEvery와 비슷하게) 병렬로 작업을 실행하는 데 사용되지만 흐름을 차단하지 않습니다. 비차단 작업을 시작해야 할 때 사가가 유용합니다.\n\nfork()을 프로세스를 가져와서 별도의 스레드에서 별도로 실행하는 것으로 생각할 수 있습니다. 작업을 완료하거나 거부할 때 해당 작업을 실행하던 함수가 알림을 받아서 컴파일러는 해당 함수를 종료합니다. 이 개념은 많은 개념과 비슷할 수 있지만, 핵심적인 차이점은 fork가 다음 코드 줄을 실행하는 것을 막지 않지만, 현재 있던 함수를 종료하지 않는다는 점입니다. 즉, 컴파일러는 fork가 모두 완료되거나 응답하면 해당 함수를 종료합니다. 이 개념을 실제로 이해하려면 아래 예제를 살펴보세요.\n\n## 예제\n\n앱에서 사용자가 다음 작업을 수행할 수 있는 화면에 있다고 가정해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자 목록을 가져오는 API를 호출합니다.\n- 게시물을 가져오는 API를 호출합니다.\n- 댓글을 가져오는 API를 호출합니다.\n- 앱을 종료하는 것은 이전 화면으로 돌아가는 것을 의미합니다.\n\n먼저 사가의 fork를 사용하여 게시물을 가져오는 API를 호출할 것입니다.\n\n모든 작업은 서로 의존하지 않습니다. 이들은 사용자가 언제든지 화면에서 수행할 수있는 네 개의 독립적인 예상 작업입니다.\n\nactions.js에 다음과 같은 작업이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const GET_POSTS_FETCH = createAction(\"GET_POSTS_FETCH\");\nexport const GET_POSTS_SUCCESS = createAction(\"GET_POSTS_SUCCESS\");\nexport const GENERAL_FAILURE = createAction(\"GENERAL_FAILURE\");\nexport const EXIT_APP = createAction(\"EXIT_APP\");\n```\n\n대부분의 생성된 액션은 어떤 작용을 하는지 명확하지만, EXIT_APP은 사용할 효과를 보여주기 위해 추가한 액션입니다. 사용자가 화면을 떠날 때 또는 뒤로 돌아갈 때를 생각해보면, 사가를 깨끗하게 정리하기 위해 exit 함수를 호출합니다. API를 호출하고 결과를 가져오고자 할 때는 Post fetch를 사용합니다. API 호출 시 오류가 발생한 경우 General failure을 사용하고, 데이터를 성공적으로 가져온 경우에는 success가 트리거됩니다.\n\n이제 sagas.js를 세 부분으로 나누어 만들어봅시다:\n\n```js\n// PART 1\nfunction getPosts() {\n  console.log(\"Now calling getPosts API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/posts\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드는 간단한 JS 함수를 호출하여 결과를 반환하는 것뿐입니다. 다음으로, 우리는 아래에 있는 사가를 추가할 것입니다.\n\n- getPosts API 호출하기\n- 응답이나 오류 가져 오기\n\n```js\nimport { call, put, take } from 'redux-saga/effects';\n// PART 2\nfunction* getPostsSaga() {\nwhile (true) {\ntry {\nconsole.log(\"getPosts action ready...\");\nyield take(GET_POSTS_FETCH);\nconsole.log(\"getPosts action started...\");\nconst posts = yield call(getPosts);\nconsole.log(\"getPosts action fetched...\");\nyield put({type: GET_POSTS_SUCCESS, posts: posts});\nconsole.log(\"getPosts action finished...\");\n} catch (error) {\nconsole.log(\"getPosts action failed...\");\nyield put({type: GENERAL_FAILURE, error: error});\nconsole.log(\"getPosts action error finished...\");\n}}\n```\n\n위 코드에 콘솔 로그를 추가하여 코드가 멈추는 지점과 대기하는 지점을 효율적으로 확인할 수 있도록 했습니다. 위 코드는 GET_POSTS_FETCH 액션을 받고 API를 호출하고 응답이나 오류를 받은 후에 작업을 수행하도록 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 우리는 방금 생성한 getPostsSaga를 호출할 메인 Saga가 필요합니다. 그러니 이렇게 만들어 봅시다:\n\n```js\nimport { call, put, take, fork, cancel } from \"redux-saga/effects\";\n// PART 3\nexport default function* mySaga() {\n  const posts = yield fork(getPostsSaga);\n  console.log(\"이제 사용자의 작업을 기다리고 있습니다...\");\n  yield take(EXIT_APP);\n  console.log(\"앱을 종료 중입니다...\");\n  yield cancel(posts);\n  console.log(\"종료가 완료되었습니다...\");\n}\n```\n\nfork가 블로킹되지 않는 호출이기 때문에 call(...)과 같은 기대값이나 take와 같은 기다림이 필요하지 않습니다. 위의 코드에서는 실제로 이야기를 전달하고 있는데, 즉시 Saga가 시작되면 getPostsSaga를 fork했음을 의미합니다. 즉, getPostsSaga 함수를 완료할 때까지 기다리지 않고 별도의 스레드에서 실행합니다.\n\ngetPostsSaga의 첫 줄이 take 이펙트인데, 이는 GET_POSTS_FETCH 액션을 '청취'하거나 '감시'하기 시작하게 됩니다. 이 액션이 실행될 때가지 즉시 take를 수행합니다. getPostsSaga에서 take와 같은 블로킹 호출이 없으면 전체 함수를 실행하게 되므로, 사용자가 이 작업을 취할 때마다 Saga는 별도의 스레드에서 이를 실행하기 위해 기다리게 됩니다(즉, 앱의 현재 흐름을 방해하지 않는 상태).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 mySaga로 돌아가서 사용자의 동작을 기다리는 중일 것이에요... 지금 파일에서는 여기까지에요. 이제 yield take(EXIT_APP) 부분에 대해 곧 설명할게요. (console.log로 실행하면 훨씬 더 명확해질 거예요.)\n\n따라서 우리는 sagas.js에서 API에서 게시물을 가져오는 기능을 달성하기 위해 세 가지를 했어요.\n\n- 최신 게시물을 API에서 가져오기 위한 getPosts 함수를 생성함\n- 응답, 오류 및 API 호출을 처리하는 getPosts를 위한 generator 함수를 작성함\n- sagas에 대한 주 generator 함수를 생성해서 getPostsSaga를 분기함\n\n지금은 이게 sagas 파일에서 우리가 할 일 전부에요. 다음으로 reducers.js를 설정할 건데요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_POSTS_SUCCESS, GENERAL_FAILURE } from \"./actions\";\nconst initialState = {};\nconst myFirstReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_POSTS_SUCCESS, (state, action) =\u003e {\n      state.posts = action.posts;\n    })\n    .addCase(GENERAL_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myFirstReducer;\n```\n\n우리는 앱이 특정 동작을 취하기 위해 사용되지 않을 작업만 처리하려고 합니다. 사용자가 실제로 보고 싶어하는 데이터를 검색하지 않을 것이므로 그래서 이 두 작업만 추가되었습니다.\n\n마지막으로, 이 작업을 시험할 화면인 App.js에서 열어서 다음을 추가하세요:\n\n```js\n{\n  /* ...다른 코드... */\n}\n\u003cbutton onClick={() =\u003e myDispatch(GET_POSTS_FETCH())}\u003e 포스트 API \u003c/button\u003e;\n{\n  /* ...다른 코드... */\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버튼을 누르면 우리는 지켜보고 있는 SAGA에서 작업을 수행하도록 GET_POST_FETCH 액션을 취하고 싶습니다. 따라서 이 작업을 수행하자마자 getPosts 함수가 정상적으로 실행될 것입니다. 먼저 실행한 후 결과를 확인하고 무슨 일이 일어나는지 살펴보겠습니다:\n\n![image](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_5.png)\n\n앱이 로드되자마자 fork 때문에 getPostsSaga로 이동되었음을 볼 수 있습니다. 이는 이미 준비되어 있다는 것을 알기 때문에 GET_POST_FETCH 액션이 발생할 때마다 getPostsSaga의 나머지 부분을 실행하도록 준비되어 있을 것입니다. 다시 돌아와서 앱이 메서드를 fork했고 사용자가 필요한 작업을 언제든지 수행할 수 있도록 기다리고 있다고 출력합니다. 지금까지 사용자가 수행할 수 있는 작업은 두 가지 뿐입니다:\n\n- API에서 게시물 가져오기\n- 앱 종료하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 '게시물 API' 버튼을 클릭해 봅시다:\n\n![게시물 API](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_6.png)\n\n행동을 취하자마자 API를 호출하기 시작할 것이며, 데이터를 가져오면 완료됩니다. 계속해서 while(true)를 사용하므로 다시 준비됩니다. '게시물 API' 버튼을 다시 누르면 API가 다시 호출됩니다:\n\n![게시물 API](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 \"exit\" 버튼을 누르면 어떻게 될까요? 우리가 \"이제 사용자의 조치를 기다리고 있습니다…\"를 출력했던 것을 기억하십니까? 바로 이후에는 yield take(EXIT_APP)를 수신하고 있음을 의미합니다. 총으로 보면, 포스트 API를 호출하는 블로킹 콜과 exit를 수신하고 있습니다. Saga는 두 가지를 동시에 수신하고 있는데, 이 둘 중 하나의 작업이 수행될 때마다 saga는 해당 지점에서 흐름을 계속합니다.\n\n그래서 지금 \"exit\" 버튼을 클릭하면 콘솔에 우리가 가진 console.log가 인쇄됩니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_8.png)\n\n\"exit\"가 호출되면 cancel(posts)가 실행되는데, 이는 saga에게 GET_POST_FETCH 액션을 듣는 것을 중단하라는 것입니다. 그래서 지금 \"포스트 API\" 버튼을 누르면 아무 일도 일어나지 않을 것입니다. 이것이 앱에서 흐름을 제어하는 방법이며, 필요한 것에만 집중할 수 있습니다. 해당 작업을 다시 열려면 사용자가 화면에 다시 입력하거나 재시작해야 합니다. 따라서 fork 사용을 신중하게 계획해야 하며, 이를 올바르게 활용하면 매우 유용하고 삶을 더 쉽게 만들어줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 현재 예제 확장하기 (블로그 앱)\n\ncreateSelector, fork 및 기타 개념들을 학습하기 위해 위 예제를 확장해보겠습니다. 두 개의 새 버튼, 즉 Comments API 및 UsersAPI를 추가하여 동일하게 API를 호출하고 결과를 검색할 것입니다. 포스트와 동일한 방법으로 수행됩니다.\n\n그러므로, 해당 액션들을 추가해 시작해봅시다:\n\n```js\nimport { createAction } from \"@reduxjs/toolkit\";\nexport const GET_POSTS_FETCH = createAction(\"GET_POSTS_FETCH\");\nexport const GET_COMMENTS_FETCH = createAction(\"GET_COMMENTS_FETCH\");\nexport const GET_USERS_FETCH = createAction(\"GET_USERS_FETCH\");\nexport const GET_POSTS_SUCCESS = createAction(\"GET_POSTS_SUCCESS\");\nexport const GET_COMMENTS_SUCCESS = createAction(\"GET_COMMENTS_SUCCESS\");\nexport const GET_USERS_SUCCESS = createAction(\"GET_USERS_SUCCESS\");\nexport const EXIT_APP = createAction(\"EXIT_APP\");\nexport const GENERAL_FAILURE = createAction(\"GENERAL_FAILURE\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 예제에 필요한 모든 작업이 준비되었습니다. 이제 우리의 리듀서를 업데이트하여 GET_USERS_SUCCESS, GET_POSTS_SUCCESS 두 가지 새로운 성공 경우를 처리해봅시다.\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_USERS_SUCCESS, GET_POSTS_SUCCESS, GET_COMMENTS_SUCCESS, GENERAL_FAILURE } from \"./actions\";\nconst initialState = {};\nconst myReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_POSTS_SUCCESS, (state, action) =\u003e {\n      state.posts = action.posts;\n    })\n    .addCase(GET_COMMENTS_SUCCESS, (state, action) =\u003e {\n      state.comments = action.comments;\n    })\n    .addCase(GET_USERS_SUCCESS, (state, action) =\u003e {\n      state.users = action.users;\n    })\n    .addCase(GENERAL_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myReducer;\n```\n\n그다음, 사용자가 코멘트나 사용자 데이터를 가져오고 싶을 때 어떻게 처리할지 정의해야 합니다. 따라서 우리는 sagas.js 파일에 API 호출 함수를 작성할 것입니다. 비즈니스 로직을 처리하는 곳입니다.\n\n```js\nfunction getComments() {\n  console.log(\"Now calling getComments API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/comments\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\nfunction getUsers() {\n  console.log(\"Now calling getUsers API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngetPosts 함수처럼 우리는 두 개의 새로운 API 호출 함수를 추가했습니다. 이제 두 함수에 대한 사가를 추가해야 하는데, 이는 특정 액션이 발생할 때 대기하고 실행하고 결과를 반환하는 것을 의미합니다. getPostsSaga와 유사하게 getCommentsSaga와 getUsersSaga를 추가할 것입니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_9.png)\n\nconsole.log 함수를 제거하면 매우 간단합니다. take 때문에 이 액션을 청취하기 시작합니다. 해당 액션이 발생하자마자 사가가 API 함수를 호출하고 성공하면 성공 액션을 호출하여 데이터를 리듀서에 넣습니다. 리듀서는 이를 초기 상태나 초기화된 상태에 추가할 것입니다.\n\n새롭게 추가된 두 사가를 루트 수준에서 실행 중인 주 사가인 mySaga에 바인딩해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { call, cancel, fork, put, take, all } from \"redux-saga/effects\";\n//... other code\nexport default function* mySaga() {\n  const posts = yield fork(getPostsSaga);\n  const comments = yield fork(getCommentsSaga);\n  const users = yield fork(getUsersSaga);\n  console.log(\"이제 사용자의 조치를 기다리고 있습니다...\");\n  yield take(EXIT_APP); // 조치가 취해질 때까지 대기\n  console.log(\"앱을 종료합니다...\");\n  yield all([cancel(posts), cancel(comments), cancel(users)]);\n  console.log(\"종료가 완료되었습니다...\");\n}\n```\n\n우리는 fork를 사용하여 세 가지 모두에 대해 saga에게 듣도록 지시했습니다. fork는 비차단적이므로 세 가지 모두와 EXIT_APP까지 등록한 다음에 네 가지 조치 중 어느 것이든 취해질 때까지 기다립니다. fork는 기본적으로 getCommentsSaga 및 getUsersSaga 생성기 함수 내부로 들어가며 그 안에 차단 take가 있으므로 해당 saga가 GET_POSTS_FETCH, GET_COMMENTS_FETCH, GET_USERS_FETCH 및 EXIT_APP(종료 앱)를 대기하도록 등록한 방법입니다. 성공한 조치(GET_COMMENTS_SUCCESS 등)는 아직 등록되지 않았으며, 그런 경우 해당 동작이 취해지면 아무 일도 일어나지 않습니다. EXIT_APP이 취해질 때 댓글 및 사용자 리스너도 취소합니다.\n\n이제 버튼 클릭으로 fetch 동작을 호출해야 하므로 App.js 또는 index.js를 업데이트하세요:\n\n```js\n//... other imports\nimport {\nGET_POSTS_FETCH,\nGET_COMMENTS_FETCH,\nGET_USERS_FETCH,\nEXIT_APP\n} from \"./actions\";\n//... other UI\n\u003cbutton onClick={() =\u003e myDispatch(GET_POSTS_FETCH())}\u003e\n게시물 API\n\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(GET_COMMENTS_FETCH())}\u003e\n댓글 API\n\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(GET_USERS_FETCH())}\u003e사용자 API\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(EXIT_APP())}\u003e앱 종료\u003c/button\u003e\n\u003chr /\u003e\n//... other UI after rendering posts\n        {retrivedData?.comments \u0026\u0026\n{retrivedData?.comments \u0026\u0026\nretrivedData.comments.map((comment) =\u003e (\n\u003cdiv key={comment.id}\u003e\n   \u003cp style={ fontWeight: \"bold\" }\u003e{comment.name}\u003c/p\u003e\n   \u003cp style={ fontSize: 12, marginTop: -16, marginBottom: -10 }\u003e\n      {comment.email}\n   \u003c/p\u003e\n   \u003cp\u003e{comment.body}\u003c/p\u003e\n\u003c/div\u003e\n))}\n{retrivedData?.users \u0026\u0026\nretrivedData.users.map((user) =\u003e (\n\u003cdiv key={user.id}\u003e\n\u003cp style={ fontWeight: \"bold\" }\u003e\n   {user.name} ({user.company.name})\n\u003c/p\u003e\n\u003cp style={ fontSize: 12, marginTop: -16, marginBottom: -10 }\u003e\n   {user.email} | {user.phone}\n\u003c/p\u003e\n\u003cp\u003e\n   {user.address.suite} {user.address.street}, {user.address.city}, {user.address.zipcode}\n\u003c/p\u003e\n\u003c/div\u003e\n))}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드는 검색한 데이터를 출력할 것입니다. 이를 확인하는 가장 좋은 방법은 앱을 실행하는 것입니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_10.png)\n\n한 번 실행하면, 우리 프로그램이 모든 세 가지 액션을 계속 지켜보고 있음을 볼 수 있고 사용자가 세 가지 액션 중 아무 것이라도 취할 수 있습니다. 먼저 Users API 액션을 취해 봅시다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 API에서 데이터를 가져와서 멋진 형식으로 렌더링되는 것을 볼 수 있습니다. 이제 다른 작업을 수행해 봅시다. 한 번의 포스트, 게시물 가져오기 또는 사용자들을 다시 가져올 수 있습니다. 계속해서 while(true) 문을 사용했기 때문에 다시 준비된 것을 볼 수 있습니다. 다음으로 댓글 API를 살펴보겠습니다:\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_12.png)\n\n댓글이 가져와지고 맨 아래로 스크롤하면 사용자 데이터도 확인할 수 있습니다. UI에서는 댓글 후에 사용자 데이터가 렌더링됩니다.\n\n지금까지 우리는 이전 섹션에서 한 것과 똑같은 방식으로 두 개의 사가 함수를 더 만들었습니다. 그 코드는 아래에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 좀 더 많은 훅을 살펴보도록 합시다. 기본적으로 블로그 앱의 형태 예시를 시작할 준비가 되었습니다.\n\n## createSelector\n\n이제, createSelector라는 편리한 훅을 어떻게 사용할 수 있는지 살펴보겠습니다. 아래 패키지를 설치하여 사용해 보세요:\n\n```js\nyarn add reselect *OR* npm i reselect\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스 복습 섹션에서 살펴본 대로 셀렉터(selector)는 객체에서 값을 선택하는 데 사용됩니다. 셀렉터는 단순히 더 큰 데이터 컬렉션에서 데이터 하위 집합을 선택하는 데 사용되는 함수입니다.\n\n이 예시에서는 댓글, 사용자 및 포스트와 같은 데이터가 있고, 셀렉터를 사용하여 데이터를 슬라이스해서 사용자 id가 1인 사용자의 댓글을 선택하거나 id가 5인 사용자의 포스트를 선택할 수 있습니다. 기본적으로 데이터를 모두 페치한 블로그를 가정하고 이를 표시합니다. 이상적인 시나리오에서는 사용자를 위한 특정 포스트를 얻을 수 있는 API가 있을 것이며, 거기서부터 사용자의 상위 5개 포스트를 표시하는 셀렉터를 생성할 수 있습니다. 시나리오에 따라 셀렉터를 사용하고, 이 예시를 위해 모든 댓글, 사용자 및 포스트를 가져왔으므로 블로그 응용 프로그램에서 데이터를 필요에 맞게 구성할 수 있도록 필요한 만큼 많은 셀렉터를 만들어갈 것입니다.\n\n우리의 블로그 앱에서는 다음과 같이 진행합니다:\n\n- 앱을 시작할 때 모든 데이터를 가져오도록 3개의 fetch API 액션을 모두 트리거합니다. (실제 세계에서는 좋은 방법이 아니지만 이 튜토리얼을 위해서만 수행합니다.)\n- 그런 다음 사용자에게 포스트 목록만 표시합니다. 이 목록은 클릭할 수 있습니다.\n- 사용자는 어떤 포스트도 선택할 수 있습니다. 포스트를 선택하면 해당 사용자에 대한 댓글 및 사용자 정보를 가져오는 다른 액션을 트리거합니다. (여기서 createSelector를 사용할 것입니다)\n- 다시 모든 포스트로 돌아갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 블로그 게시물 목록 표시:\n\n첫 번째로 할 일은 필요한 모든 데이터를 가져오는 것입니다. \"Posts API\", \"Comments API\" 등의 버튼을 제거하겠습니다. 앱을 시작하면 이러한 작업이 트리거될 것이기 때문입니다. 그래서 App.js에 다음을 추가하세요:\n\n```js\nimport { useEffect } from \"react\";\n//... 기타 imports\nfunction App() {\n  const myDispatch = useDispatch();\n  useEffect(() =\u003e {\n    // 시작 시 모든 데이터 가져오기. 데이터를 슬라이스하고 표시하기 위해 selector를 사용할 것입니다.\n    myDispatch(GET_POSTS_FETCH());\n    myDispatch(GET_COMMENTS_FETCH());\n    myDispatch(GET_USERS_FETCH());\n  }, [myDispatch]);\n  //... 기타 코드\n}\n```\n\n위 코드에서 세 가지 액션을 디스패치하여 모든 데이터를 가져왔습니다. 리듀서와 사가는 그대로이며, 이전 예제에서 만든 selector로 확인한 데이터가 있다는 것을 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약간 정리를 해보려고 합니다. sagas.js 파일에서 getPosts, getComments, 그리고 getUsers 함수를 apis.js라는 새 파일로 이동하고 거기에 붙혀보세요. 기본적으로, 제너레이터 함수만을 사가 파일에 유지하는 것으로 합니다.\n\n```js\n// apis.js\nimport axios from \"axios\";\n\nexport async function getPosts() {\n  console.log(\"getPosts API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/posts\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      return err;\n    });\n}\n\nexport async function getComments() {\n  console.log(\"getComments API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/comments\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      return err;\n    });\n}\n\nexport async function getUsers() {\n  console.log(\"getUsers API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n위의 apis.js 파일에는 세 가지 API 함수를 추가하고, sagas.js 파일에서 이들을 제거했습니다.\n\n이제 UI (App.js)를 수정해봅시다. 메인 return(...) 안의 모든 내용을 제거하고 다음 코드를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nreturn (\n\u003cdiv className=\"App\"\u003e\n   \u003ch3\u003e블로그 앱\u003c/h3\u003e\n   \u003cdiv\u003e\n     \u003cp\u003e\n      \u003cb\u003e더 많은 내용을 보려면 아래에서 블로그 글을 선택하세요:\u003c/b\u003e\n     \u003c/p\u003e\n     \u003chr /\u003e\n     {retrivedData?.posts \u0026\u0026 retrivedData.posts.map((post) =\u003e (\n           \u003ca href={`/#${post.id}`} onClick={() =\u003e {\n                 console.log(post);\n              } key={post.id}\u003e\n              {post.id}: {post.title}\n           \u003c/a\u003e\n           \u003cbr /\u003e\n     ))}\n   \u003c/div\u003e\n\u003c/div\u003e\n)\n```\n\n이 UI에는 링크 `a`만 있습니다. href는 링크처럼 느껴지게하는데 추가되었습니다. 앱을 실행하고 포스트를 선택하십시오. 콘솔에 출력되는 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_13.png\" /\u003e\n\n그래서, 우리의 로직이 작동합니다. 이러한 변경만으로 우리가 위에서 논의한 총 4가지 중 처음 두 가지를 완료했습니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번호 3은 사용자가 이 게시물 중 하나를 선택할 때 해당 게시물, 댓글 및 작성자를 표시해야 하는 곳입니다. 이미 모든 데이터를 가지고 있기 때문에 우리가 해야 하는 것은 적절한 것을 필터링하고 표시하는 것 뿐입니다. 예를 들어, 사용자가 게시물 번호 31을 선택하면 31번 id를 가진 게시물에 대한 댓글과 해당 게시물을 작성한 사용자 이름을 가져와야 합니다. 그것이 바로 우리가 선택자를 생성할 곳입니다. 'Selectors'는 그 이름 그대로 데이터를 선택합니다. 그러니 새 파일을 만들어 selectors.js로 이름을 붙이고 첫 번째 선택자를 추가해 봅시다.\n\n```js\nexport const allPosts = (state) =\u003e state.myReducer.posts;\nconst allComments = (state) =\u003e state.myReducer.comments;\nconst allUsers = (state) =\u003e state.myReducer.users;\n```\n\n위 코드에서는 가져온 전역 상태에서 allPosts를 간단히 내보냈습니다. 그것이 목록에 모든 게시물을 표시하는 데 필요한 유일한 것이기 때문에 내보내야 하는 것입니다. 다른 두 allComments 및 allUsers는 단순히 모든 데이터를 가져오기 위해 존재하며 다음으로 필요한 선택자를 만들 것입니다.\n\ncreateSelector의 문서를 보면 3개의 매개변수를 받는다는 것을 알 수 있지만 아래에서보면 필요한 것은 첫 두 가지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_14.png\" /\u003e\n\n우리가 한 코드에는 입력 셀렉터로 사용할 수 있는 세 개의 데이터 객체가 있습니다. 입력 셀렉터란 선택하려는 데이터를 의미합니다. resultFunc는 원하는 방식으로 데이터를 잘라내고 반환할 수 있는 함수입니다. 여러 입력 셀렉터가 있을 수 있다는 점에 유의하세요 (곧 보게 될 것입니다). 이는 해당 데이터의 선택기를 만들어 데이터를 혼합하고 일치시킬 수 있다는 것을 의미합니다.\n\n우리의 목표는 사용자가 게시물을 선택할 때 선택한 게시물, 해당 댓글 및 저자 정보를 가져와야 한다는 것입니다. 이를 위해 사용자가 선택해야 하는데, 이는 사용자가 ACTION을 취해야 한다는 의미입니다.\n\n그래서 actions.js에 다음 액션을 추가해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n//... 다른 작업들\n// post를 매개변수로 받는 액션\nexport const SELECTED_POST = createAction(\"SELECTED_POST\", (post) =\u003e {\n  return {\n    payload: {\n      selectedPost: post,\n    },\n  };\n});\n```\n\n우리는 이번에 createAction을 사용하여 매개변수를 받는 액션을 처음 만들었습니다. 이것은 이 액션을 전달할 때 우리가 post 객체를 전달할 것을 의미합니다. 그리고 저는 payload: selectedPost: post; (원하는 대로 구조화할 수 있습니다).\n\n이 post 객체를 전역 상태에 저장해서 selector 및 다른 곳에서 액세스할 수 있도록 하려고 합니다. 따라서 reducers.js 파일로 이동하여 createReducer에 이 케이스를 추가해 보겠습니다.\n\n```js\n//... 다른 임포트들\nimport {\nGET_USERS_SUCCESS,\nGET_POSTS_SUCCESS,\nGET_COMMENTS_SUCCESS,\nGENERAL_FAILURE,\nSELECTED_POST\n} from \"./actions\";\n//... 다른 코드\n.addCase(SELECTED_POST, (state, action) =\u003e {\nstate.selectedPost = action.payload.selectedPost;\n})\n//... 다른 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 전역 상태에서 selectedPost로 저장하고 있어요. 이제 selectors로 돌아가볼게요. 선택된 게시물의 댓글을 선택하는 selector를 만들 준비가 되었어요. selectors.js 파일을 열어서 다음 코드를 추가해주세요:\n\n```js\nimport { createSelector } from \"reselect\";\n//...other code\nexport const selectedPost = (state) =\u003e state.myReducer.selectedPost;\nexport const getCommentsForPost = createSelector(allComments, selectedPost, (c, p) =\u003e {\n  if (c \u0026\u0026 p) {\n    const filteredComments = c.filter((comment) =\u003e {\n      return comment.postId === p.id;\n    });\n    return filteredComments;\n  }\n});\n```\n\n위 코드에서는 createSelector을 import하고, allPosts 등과 마찬가지로 전역 상태에서 selectedPost를 가져왔어요. 그리고 getCommentsForPost에서는 allComments와 selectedPost를 입력 selector로 제공했어요. (여러 입력 selector를 제공하는 방법이에요.) 그런 다음에 c와 p를 사용하여 모든 댓글(allComments)에서의 객체와 선택된 게시물 데이터 객체를 나타내는 필터링된 댓글을 반환하는 resultFunc 함수를 추가했어요.\n\n또 다른 selector가 필요한데, 그것은 선택된 게시물의 작성자로 표시할 사용자 이름을 가져오는 것이에요. 선택된 블로그 게시물의 작성자를 선택할 selector를 만들어봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const getAuthorForPost = createSelector(\nallUsers, selectedPost,\n(u, p) =\u003e {\nif (u \u0026\u0026 p) {\nconst author = u.find((user) =\u003e {\n   return p.userId === user.id;\n});\n   return author;\n});\n```\n\n이전과 마찬가지로 두 개의 입력 선택기를 추가했고 결과 함수를 사용하여 allUsers에서 p.userId와 일치하는 객체를 찾고 있습니다.\n\n이제 선택기를 설정했으니, 이를 어떻게 사용하는지 확인해보는 시간입니다. 이제 남은 일은 UI를 그려서 모든 이벤트 변경을 표시하는 것뿐입니다. 그러니 App.js를 열어서 다음 수정 사항을 적용하세요:\n\n```js\nimport { useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { GET_POSTS_FETCH, GET_COMMENTS_FETCH, GET_USERS_FETCH, SELECTED_POST, EXIT_APP } from \"./actions\";\nimport { allPosts, selectedPost, getCommentsForPost, getAuthorForPost } from \"./selectors\";\n//... other code function App() {...\nconst retrivedPosts = useSelector(allPosts);\nconst selPost = useSelector(selectedPost);\nconst selPostComments = useSelector(getCommentsForPost);\nconst selPostAuthor = useSelector(getAuthorForPost);\n// 이 useState는 게시물 선택에 따라 UI를 숨기거나 보여주기 위한 것입니다.\nconst [selectedPostModeOn, setSelectedPostModeOn] = useState(false);\nfunction postSelected(selectedPost) {\n  myDispatch(SELECTED_POST(selectedPost));\n}\n//... More code\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 UI에 대한 첫 번째 변경 사항에서, 필요한 모든 작업과 필요한 모든 셀렉터를 먼저 import 했습니다. 저희는 하나의 view만 있기 때문에 선택된 모드에 따라 UI 요소를 숨기거나 표시할 것입니다. 즉, 게시물이 선택되었을 때와 그렇지 않을 때를 나타내는 상태를 컨트롤하기 위해 useState를 추가했습니다. 선택된 게시물이 있을 때 호출되는 postSelected 함수가 있으며, 게시물이 선택되었을 때 선택된 게시물 객체와 함께 SELECTED_POST 액션을 dispatch하고 나머지는 이미 처리되었습니다.\n\n그 다음, App.js의 return(...)에서 두 개의 div가 있을 것입니다:\n\n- 첫 번째 div에는 이미 표시된 모든 게시물이 표시됩니다.\n- 두 번째 div에는 선택한 게시물, 해당 댓글 및 작성자의 이름이 표시됩니다.\n\n언제든지 위의 div 중 하나만 표시되며, 선택된 게시물 모드를 사용하여 컨트롤할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인 div 안에 있는 `div className=\"App\"` 안에 다음 코드를 추가해주세요:\n\n```js\n{selectedPostModeOn \u0026\u0026 (\n\u003cdiv\u003e\n{/* 뒤로 가기 버튼 */}\n\u003cbutton\nonClick={() =\u003e {\n   myDispatch(EXIT_APP());\n   setSelectedPostModeOn(false);\n}\u003e 뒤로 \u003c/button\u003e\n\u003cbr /\u003e \u003chr /\u003e\n{/* 글 */}\n\u003cdiv\u003e\n  \u003ccode\u003e글 ID: {selPost ? selPost.id : \"선택된 글 없음\"}\u003c/code\u003e\n  \u003ch1\u003e{selPost.title}\u003c/h1\u003e\n  \u003cp\u003e{selPost.body}\u003c/p\u003e\n  \u003cp\u003e\n    \u003ci\u003e작성자: {selPostAuthor.name}\u003c/i\u003e\n  \u003c/p\u003e\n\u003c/div\u003e \u003chr /\u003e\n{/* 댓글 */}\n\u003cp style={{ fontSize: 12, fontWeight: \"bold\" }}\u003e 댓글 ({selPostComments.length}):\u003c/p\u003e\n{selPostComments \u0026\u0026 selPostComments.map((comment) =\u003e (\n\u003cdiv key={comment.id} style={{\n     backgroundColor: \"#e8e8e8\",\n     padding: 8,\n     marginBottom: 8,\n     borderRadius: 8\n}}\u003e\n\u003cp style={{ fontSize: 12, color: \"#7d7d7d\" }}\u003e\n   {comment.name} \u003cbr /\u003e {comment.email}\n\u003c/p\u003e\n\u003cp style={{ fontSize: 12, fontWeight: \"bold\" }}\u003e\n   {comment.body}\n\u003c/p\u003e\n\u003c/div\u003e))}\n\u003c/div\u003e\n)}\n```\n\n위 컴포넌트는 글 내용과 저자의 이름 그리고 마지막으로 모든 댓글을 표시하는 div입니다.\n\n나머지 return 부분은 동일하지만 모든 글을 표시하는 div를 `selectedPostModeOn`으로 묶어주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{!selectedPostModeOn \u0026\u0026 (\n\u003cdiv\u003e\n\u003cp\u003e\n  \u003cb\u003e블로그 게시물을 선택하여 더 많은 내용을 읽어보세요:\u003c/b\u003e\n\u003c/p\u003e\n\u003chr /\u003e\n{retrivedPosts \u0026\u0026 retrivedPosts.map((post) =\u003e (\n\u003ca href={`/#${post.id}`} onClick={() =\u003e {\n   postSelected(post);\n   setSelectedPostModeOn(true);\n  }\n  key={post.id}\u003e\n{post.id}: {post.title}\n\u003cbr /\u003e\n\u003c/a\u003e))}\n\u003c/div\u003e\n)}\n```\n\n동일한 내용이지만 두 가지 미세한 변경 사항이 있습니다. 첫째, 더 이상 필요하지 않아 retrivedData를 제거하고 retrivedPosts를 사용하여 렌더링합니다.\n\n앱을 실행하면 이렇게 작동해야 합니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Ve1TEwbgQTZwb_e6JFcVTg.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블로그 앱의 완전한 작동 코드가 준비되어 있습니다:\n\n# 결론:\n\n이 튜토리얼에서 진행한 샘플 프로젝트와 마찬가지로, 프로젝트에 따라 redux-saga를 활용하여 더 이벤트 중심의 아키텍처로 프로젝트를 구성할 수 있습니다. 필요한 모든 작업과 사가가 처리할 모든 기능을 계획할 수 있습니다. 전역 상태에 데이터를 저장해야 할 경우에는 리듀서에서 처리해야 하며, createReducer, createSelector와 같은 내장 훅, 그리고 saga의 call, put, take, fork 등의 효과를 사용함으로써 redux-saga를 간소화하는 방법을 살펴보았습니다. useSelector 대신 sagas에서 사용하는 select(SELECTOR_NAME)와 같은 방법도 있습니다. 이 예시에서는 사용하지 않았지만, race, spawn 등 많은 다른 효과들도 있습니다. 이제 이러한 훅 중 어떤 것을 사용하여 사가를 더 효율적으로 만들 수 있는지 알아보고 탐험해보세요.\n\n언제나 새롭게 배운 지식을 테스트해볼 만한 것들에 대해 안내해 드리겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 블로그 앱을 확장해 보세요 (해당 코드 샌드박스에 가서 포크하세요) 그리고 작성자: ...를 클릭하면 사용자 프로필 (모든 사용자 데이터)과 해당 사용자가 작성한 게시물이 표시되도록 확장하세요. UI를 사용자의 소셜 미디어 프로필처럼 보이도록 만들어보세요.\n- 이 글은 읽어보세요. https://redux-saga.js.org/docs/advanced/RacingEffects/ 그리고 기사에 제시된 일부 효과를 사용하여 블로그를 확장할 수 있는지 확인해보세요.\n\n이게 도움이 되었다면 공유하고 👏🏻 버튼을 눌러서 다른 사람들도 찾을 수 있게 도와주세요. 오타를 발견하거나 잘못된 점이 있다면 강조하여 알려주시고, 크레딧과 함께 업데이트하겠습니다. 난감하거나 도움이 필요하다면 댓글 남겨주세요. 최선을 다해 도와드리겠습니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_15.png\" /\u003e\n\n내 모든 자습서는 무료입니다. 지원하고 싶다면 buymeacoffee.com/chaudhrytalha에서 커피를 사줄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩 👨🏻‍💻\n\n![Image](https://miro.medium.com/v2/resize:fit:292/1*V30UUCfEIck3Fjt3EJdfLg.gif)\n","ogImage":{"url":"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png"},"coverImage":"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png","tag":["Tech"],"readingTime":43},{"title":"리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)","description":"","date":"2024-05-01 17:30","slug":"2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png\" /\u003e\n\n리액트를 시작한 초보자이든 전문가이든 새로운 기능을 추가하려는 경우, 이 문서는 \"Axios를 사용하여 ReactJS에서 API에서 PDF를 다운로드 하는 방법\"을 배우는 데 도움이 될 것입니다. 5 단계로 진행하여 진행하도록 하겠습니다!\n\n추신 : 전체 코드를 보려면 끝 부분으로 건너뛸 수 있습니다. 도움이 되었다면 박수를 눌러주세요 💙\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대 웹 애플리케이션에서는 API에서 PDF를 다운로드해야 하는 경우가 많습니다. 사실, 이것은 많은 일상 애플리케이션의 핵심 기능입니다.\n\nUber를 통해 최근 여행의 청구서를 다운로드하거나 온라인 이력서 템플릿, 이메일에서 노트를 받는 것과 같이 가능합니다.\n\nPayPal은 청구서를 다운로드할 수 있게 해주고, Dropbox은 클라우드 저장소에서 파일을 다운로드할 수 있게 해줍니다. 대학 노트에 대해 이미 알고 계시죠!\n\n![PDF 다운로드하기](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReactJS는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리로써 이 프로세스를 용이하게 할 수 있는 다양한 도구와 라이브러리를 제공합니다. HTTP 요청을 보다 간단히 만들어주는 \"axios\" 라이브러리를 사용하는 것이 일반적입니다.\n\n파일 다운로드에 관한 ReactJS의 강력한 기능 중 하나는 blobs(Binary Large Objects)입니다. Blobs를 사용하면 파일과 같은 이진 데이터를 더 효율적으로 처리할 수 있습니다. Blobs를 활용함으로써 API에서 파일을 쉽게 다운로드하고 원활한 사용자 경험을 제공할 수 있습니다.\n\n이 글에서는 axios와 blobs를 사용하여 ReactJS에서 API로부터 파일을 다운로드하는 단계별 방법을 살펴보겠습니다. 다룰 내용은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 설정,\n- API 요청 만들기,\n- 응답 처리,\n- 파일 다운로드 트리거 및\n- 다운로드 후 정리\n\n이 자습서를 마치면 ReactJS 애플리케이션에서 파일 다운로드 기능을 구현하는 방법에 대해 확실하게 이해하게 될 것입니다. 사용자에게 원활하고 효율적인 파일 다운로드 경험을 제공할 수 있도록 도와줄 것입니다.\n\n# 필요한 설정\n\n프로젝트를 설정하는 것은 axios와 blobs를 사용하여 ReactJS에서 API에서 파일을 다운로드하는 첫 번째 단계입니다. 시작하려면 아래를 따라해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새로운 ReactJS 프로젝트를 만들거나 기존 프로젝트 디렉토리로 이동하세요.\n- 터미널을 열고 다음 명령을 실행하여 axios를 설치하세요:\n\n```js\nnpm install axios\n```\n\n3. axios가 설치되면 React 컴포넌트 파일에서 다음과 같이 import할 수 있습니다:\n\n```js\nimport axios from 'axios';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 다음으로 프로젝트를 위한 기본 파일 구조를 만들어 보겠습니다. 여러분의 요구에 맞게 파일을 조직화할 수 있지만, 간단한 예제를 확인해보세요:\n\n```js\n   src/\n   ├── components/\n   │   └── PDFDownloader.js\n   └── App.js\n```\n\n이 예에서는 PDF 다운로드 기능을 처리할 FileDownloader 컴포넌트가 있습니다.\n\n5. FileDownloader.js 파일을 열고 컴포넌트를 만들어봅시다. 함수형 컴포넌트를 사용한 예제가 여기 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_4.png\" /\u003e\n\n원하는 대로 컴포넌트를 사용자 정의해보세요.\n\n이러한 단계를 통해 ReactJS 프로젝트의 기본 구조를 설정하고 axios 라이브러리를 가져왔습니다. 이제 axios와 블롭을 사용하여 API 요청을 보내고 파일을 다운로드할 준비가 되었습니다.\n\n# API 요청 보내기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 요청을 하려면 axios.get() 메서드를 사용할 수 있어요. 파일을 blob 객체로 받기 위해 responseType 옵션을 ‘blob’으로 설정해주세요. 예시를 보여드릴게요:\n\n![Download PDF](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_5.png)\n\n위의 코드 스니펫에서는 downloadPDF라는 비동기 함수를 만들어 GET 요청을 ‘https://ExampleAPI.com/getFile`로 보내고 responseType을 ‘blob’로 지정해요. 응답은 then 블록에서 접근할 수 있고, 파일 데이터를 적절히 처리할 수 있어요. 오류가 발생하면 catch 블록에서 잡을 수 있어요.\n\n이제 파일 데이터가 준비되었으니 API 응답을 처리하고 파일을 다운로드할 준비를 마치면 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# API 응답 처리\n\nReactJS에서 파일 다운로드를 위한 API 응답을 처리할 때, 파일 데이터에 액세스하고 해당 데이터로 blob URL을 생성해야 합니다. 다음은 이를 수행하는 방법입니다:\n\n- 먼저 axios를 사용하여 API 요청을 만들 때 responseType을 'blob'으로 설정한 후, \"response.data\"를 사용하여 응답의 파일 데이터에 액세스할 수 있습니다. 이를 통해 파일을 나타내는 blob 객체를 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다음으로, URL.createObjectURL() 메서드를 사용하여 파일 데이터에서 blob URL을 생성할 수 있습니다. 이 URL은 React 구성 요소에서 다운로드 링크나 버튼을 생성하는 데 사용할 수 있습니다.\n\n![image](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_7.png)\n\n- 이러한 단계를 따르면 API 응답을 효과적으로 처리하고 ReactJS에서 파일 데이터에 액세스할 수 있습니다. 따라서 우리의 함수는 이제 다음과 같습니다:\n\n![image](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파일 다운로드 트리거\n\n- 파일을 다운로드하기 위해 버튼을 만들겠습니다. 사용자가 클릭하면 pdf가 사용자의 시스템으로 다운로드됩니다. 다음과 같이 할 수 있습니다:\n\n```js\n\u003cbutton onClick={downloadPDF}\u003eDownload PDF\u003c/button\u003e\n```\n\n- 이제 임시 URL을 만들고 다운로드를 트리거할 `a` 태그를 만들어봅시다. 여기서 파일에 동적 이름이나 제네릭 파일 이름을 줄 수도 있습니다. 그런 다음 `a` 태그를 버튼에 추가하고 클릭을 활성화해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![그림 1](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_9.png)\n\n- 메모리가 해제되도록 링크와 URL을 제거하세요. 그렇지 않으면 더 많은 파일을 추가할수록 웹사이트가 느려질 수 있습니다.\n\n![그림 2](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_10.png)\n\n# 보너스: 전체 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기사를 건너뛰지 않고 여기로 바로 넘어오지는 않았겠죠? 그렇다면 왜 이렇게 했는지 이해할 수 없으실 거에요 😂\n\n만약 건너뛰셨다면 괜찮아요, 중요한 건 이해하시는 거니까요. 그럼, 여기 있어요:\n\n![이미지](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_11.png)\n\n```js\nimport react from 'react';\nimport axios from 'axios';\n\nconst FileDownloader = () =\u003e {\n\n  const downloadPdf = async () =\u003e {\n      try {\n        const response = await axios.get(\n          \"https://ExampleAPI.com/getFile\",\n          {\n            responseType: \"blob\", \n          }\n        );\n\n        const pdfBlob = new Blob([response.data], { type: \"application/pdf\" });\n\n        const url = window.URL.createObjectURL(pdfBlob);\n\n        const tempLink = document.createElement(\"a\");\n        tempLink.href = url;\n        tempLink.setAttribute(\n          \"download\",\n          `bill_${User_Id}_${date}.pdf`\n        );\n\n        document.body.appendChild(tempLink);\n        tempLink.click();\n\n        document.body.removeChild(tempLink);\n        window.URL.revokeObjectURL(url);\n      } catch (error) {\n        console.error(\"Error downloading PDF:\", error);\n      }\n    };\n\n  return (\n      \u003cbutton onClick={downloadPDF}\u003ePDF 다운로드\u003c/button\u003e\n  );\n}\n\nexport default FileDownloader;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 컴포넌트를 원하는 곳에 렌더링할 수 있습니다. 앞서 언급한 파일 구조에 따라 App.js에서 렌더링하면 잘 작동할 것입니다!\n\n# 결론\n\n본 문서에서는 ReactJS에서 axios와 블롭을 사용하여 API에서 PDF를 다운로드하는 방법에 대한 포괄적인 안내를 제공했습니다.\n\n프로젝트 설정, API 요청 만들기, 응답 처리, 파일 다운로드 트리거, 그리고 다운로드 후 정리하는 단계별 프로세스를 다루었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 제공된 코드 조각과 설명을 따라하면 ReactJS 애플리케이션에서 파일 다운로드 기능을 구현하는 방법에 대해 확실한 이해를 얻을 수 있을 것입니다. axios와 blobs의 조합을 사용하면 사용자에게 원활하고 효율적인 파일 다운로드 경험을 제공할 수 있습니다.\n\n더 탐구하고 파일 다운로드 프로세스를 향상시키기 위한 다양한 방법을 실험해 보기를 권장합니다. 오류 처리 구현, 최선의 방법 적용, 스트리밍 또는 청크 다운로드를 탐색하여 응용 프로그램의 성능을 최적화하는 등을 고려해 보세요.\n\n질문이 있거나 다른 기능에 대한 안내를 요청하고 싶으시면 아래에 댓글을 남겨주세요. 여러분의 피드백은 귀중하며, 여러분의 요구를 충족하는 콘텐츠를 제공하기 위해 항상 열려 있습니다.\n\n읽어 주셔서 감사합니다. 즐거운 코딩되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환호 🥂\n\n# 쉽게 이해하는 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 저자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png"},"coverImage":"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png","tag":["Tech"],"readingTime":7},{"title":"Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기","description":"","date":"2024-05-01 17:28","slug":"2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png\" /\u003e\n\n## 소개\n\n웹 개발의 끊임없이 발전하는 환경에서, 견고한 인증 메커니즘은 안전하고 확장 가능한 애플리케이션을 구축하는 데 중요합니다. Laravel Breeze는 웹 및 API용 강력한 인증 프레임워크 솔루션으로, 이 영역에서 등대 같은 역할을 합니다. 강력한 Laravel Sanctum 인증 시스템을 활용하여, Breeze는 기본적으로 매끄럽고 안전한 경험을 제공합니다.\n\n본 문서에서는 Laravel Breeze API 프레임워크를 React 애플리케이션과 통합하는 복잡성에 대해 살펴보고, 두 강력한 프레임워크의 장점을 결합하는 방법을 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 라라벨 백엔드 설정\n\n저희의 여정은 라라벨 백엔드를 설정하는 것으로 시작됩니다. 새로운 라라벨 애플리케이션을 생성하고 다음 명령어를 사용하여 Breeze API 스캐폴딩을 설치합니다:\n\n```js\n# 라라벨 애플리케이션 생성\ncomposer create-project laravel/laravel react-backend\ncd react-backend\n\n# Breeze 설치\ncomposer require laravel/breeze\nphp artisan breeze:install api\n```\n\n이 명령어를 통해 백엔드를 위한 기반을 설정하고 필수적인 인증 스캐폴딩을 통합합니다. 설치 후에는 환경 파일의 FRONTEND_URL을 localhost:3000으로 업데이트하는 것이 필요합니다. 라라벨 세일이나 php artisan serve 명령어를 사용하여 애플리케이션을 실행할 수 있습니다. 브라우저에서 localhost:8000을 방문하여 간단한 테스트를 수행하면 응답의 일부로 앱 버전이 표시될 것이며, 이는 라라벨 백엔드가 리액트 앱의 요청을 처리할 준비가 되었음을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## React 앱 설정\n\n프론트 엔드로 전환하며, React 애플리케이션을 설정하기 위해 Create React App을 선택합니다. 아래 명령을 실행하여 React 앱을 초기화하세요.\n\n```js\nnpx create-react-app breeze-react\ncd breeze-react\nyarn start\n```\n\n이를 통해 React 애플리케이션을 위한 기초를 설정하고, 더 많은 개발을 위한 견고한 기반을 마련합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Axios 구성하기\n\nReact 애플리케이션에서 API 요청을 처리하기 위해 Axios를 활용합니다. 전역 Axios 클라이언트를 아래와 같이 추가해보세요:\n\n```js\nimport Axios from 'axios'\n\nconst axios = Axios.create({\n  baseURL: process.env.REACT_APP_BACKEND_URL,\n  headers: {\n    'X-Requested-With': 'XMLHttpRequest'\n  },\n  withCredentials: true\n})\n\nexport default axios\n```\n\n`withCredentials`를 `true`로 설정하여 교차 사이트 쿠키 액세스를 활성화할 수 있습니다. `.env` 파일에 `REACT_APP_BACKEND_URL=localhost:8000`을 추가하고, 이는 이전에 생성한 Laravel 백엔드 애플리케이션에 해당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nREACT_APP_BACKEND_URL=http://localhost:8000\n```\n\n우리의 React 앱과 라라벨 백엔드 사이의 통신 링크를 설정합니다.\n\n## CSRF 요청\n\n라라벨 Breeze가 인증에 Sanctum을 활용하기 때문에 React 앱은 먼저 /sanctum/csrf-cookie 엔드포인트로 초기 요청을 보내야 합니다. 이는 인증에 중요하며, 로그인, 등록 및 비밀번호 잊어버리기와 같은 모든 비인증된 경로에서 수행되어야 합니다. 이 프로세스를 간소화하기 위해 hooks/auth.js 파일에 사용자 정의 후크를 만들어 CSRF 요청을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// auth.js\nimport axios from ‘axios’;\n\nexport const useAuth = () =\u003e {\n const getCsrfToken = async () =\u003e {\n await axios.get(`${process.env.REACT_APP_BACKEND_URL}/sanctum/csrf-cookie`);\n }\n\n// 기타 인증 관련 함수들\n\nreturn {\n getCsrfToken,\n // 기타 인증 관련 함수들\n };\n};\n```\n\n## 로그인 API 통합\n\nCSRF 처리를 위한 기본 작업이 완료되었으므로 이제 로그인 API를 통합해보겠습니다. 이에는 useAuth 훅에 함수를 추가하는 작업이 필요합니다:\n\n```js\n// auth.js\nimport axios from ‘axios’;\n\nexport const useAuth = () =\u003e {\n\n // 이전 코드\nconst login = async (credentials) =\u003e {\n await getCsrfToken();\n await axios.post(`${process.env.REACT_APP_BACKEND_URL}/login`, credentials);\n // 로그인 성공 또는 실패 처리\n };\n\n// 기타 인증 관련 함수들\n\nreturn {\n getCsrfToken,\n login,\n // 기타 인증 관련 함수들\n };\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 로그인 API 호출을 시작하기 전 CSRF 토큰을 요청하는 프로세스를 캡슐화하여 안전하고 인증된 로그인 경험을 보장합니다.\n\n## Laravel Breeze React\n\nLaravel Breeze를 위해 맞춤화된 사전 구성된 React 애플리케이션 템플릿을 찾는 개발자들에게 Laravel Breeze React가 이상적인 솔루션으로 떠오릅니다. GitHub에서 제공되는 이 템플릿은 Laravel Breeze의 장점을 Vite의 효율성과 결합한 것입니다. 이 기능들과 스스로 쉽게 시작할 수 있는 빠른 시작 가이드를 살펴보겠습니다.\n\n## 기능들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 미리 구축된 UI 구성 요소: 라라벨 Breeze React는 Tailwind CSS를 사용하여 스타일이 적용된 로그인, 등록, 비밀번호 재설정, 대시보드 등의 미리 구축된 UI 구성 요소를 갖추고 있습니다. 이를 통해 공통 인증 관련 페이지에 대한 기반을 제공하여 개발을 가속화합니다.\n\n2. Vite 4로 구축: Vite 4의 최신 기능과 성능 향상을 활용하여, 라라벨 Breeze React는 더 빠르고 효율적인 개발 경험을 보장합니다.\n\n3. React Router 6: 이 템플릿은 효율적이고 동적인 클라이언트 사이드 라우팅을 위해 React Router 6을 채택하여 부드럽고 원활한 탐색 경험을 제공합니다.\n\n4. 데이터 재확인을 위한 SWR: 사용자 데이터의 재확인을 용이하게 하기 위해 SWR (Stale-While-Revalidate)이 통합되어 있어, 애플리케이션이 서버 상태와 동기화되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. ESLint: 코드 품질을 유지하고 최고의 실천 방법을 준수하기 위해, Laravel Breeze React는 정적 코드 분석을 위해 ESLint를 통합하고 있습니다.\n\n## 빠른 시작 가이드\n\n1. 저장소 복제: GitHub에서 Laravel Breeze React 저장소를 복제하여 시작해보세요.\n\n```js\ngit clone https://github.com/nilanth/laravel-breeze-react\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 의존성 설치: 복제된 디렉토리로 이동하여 Yarn을 사용하여 프로젝트 의존성을 설치하세요.\n\n```js\ncd laravel-breeze-react\nyarn install\n```\n\n3. 환경 설정: .env.example 파일을 .env로 복사하고 Laravel 백엔드의 URL을 지정하세요.\n\n```js\nVITE_APP_BACKEND_URL=http://localhost:8000\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 애플리케이션 실행: 개발 서버를 시작하려면 `yarn start` 명령을 실행하세요.\n\n```js\nyarn start\n```\n\n위 단계를 따라하면, 깨끗하고 기능적인 사용자 인터페이스를 갖춘 Laravel Breeze React 템플릿이 작동하는 것을 확인할 수 있을 거에요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, Laravel Breeze API 뼈대와 React 애플리케이션의 원활한 통합은 개발자들이 견고하고 안전하며 확장 가능한 웹 애플리케이션을 만들 수 있도록 돕습니다. 제시된 단계를 따라가면, 개발자들은 Laravel Breeze와 React의 강점을 결합한 안전한 인증 레이어를 구축할 수 있습니다. 수동 통합을 선택하든지, Laravel Breeze React와 같은 템플릿을 활용하든지, 결과물은 백엔드 인증 메커니즘과 프론트엔드 사용자 경험이 조화롭게 어우러진 것입니다. 이 통합은 개발을 효율적으로 만들 뿐만 아니라 현대적인 웹 애플리케이션을 구축하기 위한 견고한 기반을 보장합니다.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 박수를 치고 작성자를 팔로우해 주세요 👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png"},"coverImage":"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png","tag":["Tech"],"readingTime":6}],"page":"154","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"154"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>