<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/97" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/97" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" href="/post/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native 앱 디버깅하는 방법" href="/post/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native 앱 디버깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native 앱 디버깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native 앱 디버깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" href="/post/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" href="/post/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js에서 로컬 스토리지 사용하는 방법" href="/post/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js에서 로컬 스토리지 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" href="/post/2024-05-01-HooksinReacts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HooksinReacts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서의 훅(Hooks)을 제대로 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js를 위한 실제 API 미들웨어 작성 방법" href="/post/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js를 위한 실제 API 미들웨어 작성 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue3 + Vite 컴포넌트화 하는 방법" href="/post/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3 + Vite 컴포넌트화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React-Native로 투두 앱 만드는 방법" href="/post/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React-Native로 투두 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React-Native로 투두 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React-Native로 투두 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" href="/post/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link posts_-active__YVJEi" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법","description":"","date":"2024-05-01 18:15","slug":"2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18","content":"\n\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png)\n\n# 소개\n\nReact는 사용자 인터페이스를 만들기 위한 인기있는 JavaScript 라이브러리이며, 최근 버전에서 상당한 개선을 거쳤습니다. React 18을 통해 개발자들은 이제 비즈니스 로직을 UI 구성 요소에서 효과적으로 분리하는 더 강력한 도구를 갖게 되었습니다. 이 글에서는 비즈니스 로직과 UI 구성 요소를 분리하는 장점을 탐구하고, React 18의 새로운 기능을 사용하여 이를 어떻게 달성할 수 있는지 보여줄 것입니다.\n\n# 목차\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n- 비즈니스 로직 분리를 위한 React 18의 새로운 기능들\n- 비즈니스 로직 분리하기: 단계별 안내서\n- React 18에서 비즈니스 로직 분리를 위한 고급 기술\n- 결론\n- 참고 자료\n\n# 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n\n- 코드 재사용성: 비즈니스 로직이 분리되면 응용 프로그램의 다른 부분이나 다른 프로젝트에서도 쉽게 구성 요소를 재사용할 수 있습니다.\n- 테스트: 비즈니스 로직과 UI 구성 요소를 독립적으로 단위 테스트할 수 있으므로 테스트가 더 간단해집니다. 이는 테스트 범위와 전체 코드 품질을 향상시킵니다.\n- 가독성 및 유지보수성: 비즈니스 로직을 UI 구성 요소에서 분리하면 더 깨끗하고 유지보수가 쉬운 코드가 됩니다. 각 부분의 책임을 이해하기 쉬워집니다.\n- 확장성: 응용 프로그램이 성장함에 따라 관심을 분리하면 충돌 없이 개발자가 코드베이스의 다른 부분에 동시에 작업할 수 있습니다.\n\n# React 18의 비즈니스 로직 분리를 위한 새로운 기능들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 리액트 훅\n\n리액트 16.8에서 소개된 리액트 훅은 클래스 컴포넌트를 작성하지 않고도 상태 및 다른 리액트 기능을 사용할 수 있는 방법을 제공합니다. useState 및 useEffect와 같은 훅을 사용하면, 개발자는 비즈니스 로직을 캡슐화하고 컴포넌트 간에 재사용할 수 있습니다.\n\n## 동시 모드의 서스펜스\n\n리액트 18에서는 동시 모드와 서스펜스에서 개선 사항을 가져왔습니다. 동시 모드를 통해 리액트가 동시에 여러 작업을 처리하여 더 나은 성능을 제공합니다. 서스펜스는 선언적 데이터 가져오기와 코드 분할을 가능하게 하여 비동기 작업을 쉽게 다룰 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비즈니스 로직 분리하기: 단계별 안내\n\n## 단계 1: 비즈니스 로직 식별\n\n컴포넌트에서 데이터, 상태를 관리하거나 API 호출을 수행하는 작업과 관련된 부분을 식별합니다.\n\n## 단계 2: 커스텀 훅 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지정된 비즈니스 로직을 캡슐화하기 위해 사용자 정의 훅을 생성하세요. 사용자 정의 훅은 use로 시작하는 함수입니다. 내부적으로 다른 훅을 사용할 수 있습니다.\n\n코드 예시 (사용자 정의 훅):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() =\u003e {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다.\n    fetch('https://api.example.com/users')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e setUserData(data))\n      .catch((error) =\u003e console.error('데이터를 가져오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n```\n\n## 단계 3: 컴포넌트에서 사용자 정의 훅 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI 컴포넌트 내에서 비즈니스 로직과 데이터에 접근하기 위해 사용자 정의 후크를 활용하세요. 이렇게 하면 컴포넌트가 렌더링에 집중하고, 후크가 내부 로직을 처리합니다.\n\n코드 예시 (컴포넌트에서 사용자 정의 후크 사용):\n\n```js\n// UserList.js\nimport React from 'react';\nimport { useUserData } from './useUserData';\n\nfunction UserList() {\n  const userData = useUserData();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e사용자 목록\u003c/h1\u003e\n      \u003cul\u003e\n        {userData.map((user) =\u003e (\n          \u003cli key={user.id}\u003e{user.name}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n## 단계 4: Suspense를 사용한 코드 분할\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSuspense를 사용하면 비동기 데이터 가져오기나 계산이 많이 필요한 컴포넌트를 코드로 나누고 지연로드할 수 있어요. 이렇게 하면 관심사를 분리하고 애플리케이션의 성능을 향상시킬 수 있어요.\n\n코드 예시 (Suspense를 사용한 코드 분할):\n\n```js\n// App.js\nimport React, { Suspense } from 'react';\nconst UserList = React.lazy(() =\u003e import('./UserList'));\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e나의 앱\u003c/h1\u003e\n      \u003cSuspense fallback={\u003cdiv\u003e로딩 중...\u003c/div\u003e}\u003e\n        \u003cUserList /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n# 리액트 18에서 비즈니스 로직 분리를 위한 고급 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 커스텀 훅 조합\n\n커스텀 훅의 강력한 측면 중 하나는 더 복잡한 로직을 만들기 위해 조합할 수 있다는 것입니다. 여러 커스텀 훅을 결합함으로써, 복잡한 비즈니스 로직을 구축하면서 UI 컴포넌트를 깔끔하고 집중적으로 유지할 수 있습니다.\n\n코드 예시 (커스텀 훅 조합):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() =\u003e {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다\n    fetch('https://api.example.com/users')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e setUserData(data))\n      .catch((error) =\u003e console.error('데이터를 불러오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n\n// useFilteredUserData.js\nimport { useUserData } from './useUserData';\n\nexport function useFilteredUserData(searchTerm) {\n  const userData = useUserData();\n\n  // 검색어를 기반으로 사용자 데이터 필터링\n  const filteredData = userData.filter((user) =\u003e\n    user.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  return filteredData;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useFilteredUserData` 훅을 사용하면 검색어에 기반을 둔 필터링된 사용자 데이터를 가져올 수 있으며, `useUserData`에서 가져오는 로직을 재사용할 수 있습니다. 이 합성 접근 방식은 로직을 모듈식으로 유지하고 컴포넌트 간에 재사용할 수 있도록 합니다.\n\n## 2. 부수효과를 위한 커스텀 훅\n\n가끔 비즈니스 로직에는 데이터 가져오기 이상의 부수효과가 필요할 수 있습니다. 예를 들어 타이머 관리나 외부 API와의 상호작용과 같은 것들이 있습니다. 커스텀 훅은 이러한 부수효과를 캡슐화하여 컴포넌트 간에 일관되게 처리되도록 보장합니다.\n\n코드 예시 (타이머용 커스텀 훅):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// useTimer.js\nimport { useState, useEffect } from 'react';\n\nexport function useTimer(initialTime = 0) {\n  const [time, setTime] = useState(initialTime);\n\n  useEffect(() =\u003e {\n    const interval = setInterval(() =\u003e {\n      setTime((prevTime) =\u003e prevTime + 1);\n    }, 1000);\n\n    return () =\u003e clearInterval(interval);\n  }, []);\n\n  return time;\n}\n```\n\n이제 인터벌을 관리할 걱정 없이 타이머 기능을 모든 컴포넌트에 쉽게 통합할 수 있습니다.\n\n## 3. 전역 상태 관리를 위한 컨텍스트\n\n여러 컴포넌트 간에 공유해야 하는 상태 관리를 위해 React 18의 Context API를 활용할 수 있습니다. 비즈니스 로직에 대한 컨텍스트를 생성함으로써 어떤 컴포넌트에서든 해당 상태와 액션에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예제 (상태 관리를 위해 컨텍스트 사용):\n\n```js\n// UserDataContext.js\nimport React, { createContext, useContext } from 'react';\nimport { useUserData } from './useUserData';\n\nconst UserDataContext = createContext();\n\nexport function UserDataProvider({ children }) {\n  const userData = useUserData();\n\n  return (\n    \u003cUserDataContext.Provider value={userData}\u003e\n      {children}\n    \u003c/UserDataContext.Provider\u003e\n  );\n}\n\nexport function useUserDataContext() {\n  return useContext(UserDataContext);\n}\n```\n\nUserDataContext와 useUserDataContext 훅을 사용하여 UserDataProvider 내의 모든 컴포넌트에서 프롭 전달 없이 사용자 데이터에 액세스할 수 있습니다.\n\n## 4. Cross-Cutting Concerns을 위한 Higher-Order Components (HOCs)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 컴포넌트에 특정 로직을 적용해야 하는 경우, 고차 컴포넌트(Higher-Order Components, HOCs)를 사용할 수 있어요. HOCs는 컴포넌트를 가져와서 추가 프롭이나 로직이 포함된 새로운 컴포넌트를 반환하는 함수들이에요.\n\n코드 예시 (스타일링을 위한 HOC):\n\n```js\n// withStyles.js\nimport React from 'react';\n\nfunction withStyles(WrappedComponent) {\n  return function WithStyles(props) {\n    return (\n      \u003cdiv style={{ color: 'blue' }}\u003e\n        \u003cWrappedComponent {...props} /\u003e\n      \u003c/div\u003e\n    );\n  };\n}\n\n// 사용 예시\nconst MyComponent = ({ name }) =\u003e \u003cdiv\u003eHello, {name}!\u003c/div\u003e;\nconst StyledComponent = withStyles(MyComponent);\n```\n\n이제 StyledComponent는 MyComponent에 정의된 스타일들을 자동으로 적용해요. 여러 곳에서 스타일 선언을 반복할 필요가 없어졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nReact 18의 새로운 기능을 활용하여 사용자 정의 훅, Suspense 및 Context API를 포함한 고급 기술을 효과적으로 구현할 수 있습니다. 이를 통해 비즈니스 로직과 UI 구성 요소를 보다 효과적으로 분리할 수 있습니다. 사용자 정의 훅 조합, 부작용 처리, 전역 상태 관리를 위한 Context API, 그리고 고차 컴포넌트를 활용하여 개발자는 모듈화되고 유지보수가 용이한 React 애플리케이션을 만들 수 있습니다.\n\n이러한 기술을 적용함으로써 개발자는 코드 구성을 개선하고 성능을 향상시키면서 더욱 확장 가능하고 유지보수가 쉬운 애플리케이션을 구축할 수 있습니다.\n\n# 참고 문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- React 문서\n- React에서 Hooks 소개\n- React 18 알파 - 동시 모드\n- 상태 Hook 사용하기\n- 데이터 가져오기용 서스펜스\n- React 커스텀 훅 - 구성\n- React 컨텍스트\n- React 고차 컴포넌트\n\n이러한 참고 자료는 React 18의 새로운 기능과 비즈니스 로직을 UI 컴포넌트에서 분리하기 위한 모베스트 프랙티스에 대한 심도 있는 정보를 제공합니다.\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_1.png)\n\n이 글이 도움이 되셨나요? 좋아요나 코멘트를 남겨주세요. 고맙습니다 🙏.","ogImage":{"url":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png"},"coverImage":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png","tag":["Tech"],"readingTime":8},{"title":"React Native 앱 디버깅하는 방법","description":"","date":"2024-05-01 18:14","slug":"2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-ReactNativeAppsDebuggingTopToolsandStrategies_0.png\" /\u003e\n\n리액트 네이티브 앱을 디버깅하는 것은 도전일 수 있어요! 제게 (그리고 많은 개발자들에게) 도움이 된 몇 가지 필수 도구와 전략이 있답니다:\n\n## 도구:\n\n- React Native Debugger: 필수품! 디버거, 콘솔, 요소 검사기를 비롯한 종합적인 디버깅 환경을 제공해줘요.\n- Chrome DevTools: Chrome DevTools 디버거를 사용하여 코드를 디버깅하고 중지점을 설정하고 변수를 검사할 수 있어요.\n- Console.log(): 간단하지만 효과적이에요. console.log()를 사용하여 변수, 함수, 오류를 콘솔에 출력해주세요.\n- React Native CLI: React Native CLI를 사용하여 앱을 실행할 때 — debug 플래그를 사용하여 디버깅 기능을 활성화할 수 있어요.\n- Flipper: React Native를 위한 인기 있는 디버깅 도구로, 디버거, 콘솔 등을 제공해줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전략:\n\n- 분할 정복: 문제를 격리하기 위해 코드를 주석 처리하고 작은 구성 요소를 테스트하며 문제를 추적하기 위해 console.log()을 사용합니다.\n- 콘솔 확인: 정기적으로 콘솔을 확인하여 오류, 경고 및 로그를 확인하여 문제를 식별합니다.\n- 디버거 사용: 중단점을 설정하여 코드를 따라가고 변수를 검사하여 흐름을 이해하고 문제를 식별합니다.\n- 구성 요소 검사: 요소 검사기를 사용하여 구성 요소 계층 구조, 속성 및 상태를 검사합니다.\n- 다른 기기에서 테스트: 여러 기기 및 시뮬레이터에서 테스트하여 문제가 특정 기기에 종속되지 않도록합니다.\n- 제3자 라이브러리 확인: 제3자 라이브러리가 최신 상태이며 올바르게 구성되어 있는지 확인합니다.\n- 온라인 검색: 유사한 문제, GitHub 문제 및 Stack Overflow 질문을 검색하여 솔루션을 찾습니다.\n\n# 성공 (그리고 실패!):\n\n- 성공: React Native Debugger를 사용하여 제3자 라이브러리와 관련된 까다로운 문제를 식별했습니다.\n- 실패: 몇 시간 동안 디버깅을 한 후에야 단순한 오타였음을 깨달았습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 여러분들의 차례입니다! 좋아하는 디버깅 도구와 전략을 공유해 주세요. 함께 서로의 경험을 나누며 배워봐요!","ogImage":{"url":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png","tag":["Tech"],"readingTime":2},{"title":"대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)","description":"","date":"2024-05-01 18:13","slug":"2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png\" /\u003e\n\n리액트 애플리케이션에서 상태를 관리하는 것은 복잡하고 시간이 많이 소모되는 작업일 수 있습니다. 애플리케이션이 커지고 복잡해지면 상태를 확장 가능하고 유지 보수 가능한 방식으로 관리하기가 점점 어려워집니다. 다행히 React용으로 제공되는 가벼운 강력한 상태 관리 라이브러리가 여러 개 있습니다. 이 글에서는 이 중 두 개의 라이브러리인 Zustand와 React Query를 살펴보고, React 애플리케이션에서 상태를 관리하는 견고하고 유연한 솔루션을 제공하는 방법을 보여줄 것입니다.\n\n# Zustand란 무엇인가요?\n\nZustand는 함수형 프로그래밍 개념을 사용하여 상태를 정의하고 관리하는 React용 가벼운 상태 관리 라이브러리입니다. Redux와 달리 Zustand는 전역 저장소나 복잡한 액션 및 리듀서 집합에 의존하지 않습니다. 대신, Zustand를 사용하면 간단한 자바스크립트 객체와 함수를 사용하여 상태를 정의할 수 있습니다. 이를 통해 더 복잡한 상태 관리 솔루션의 부하 없이 상태를 확장 가능하고 유지 보수 가능한 방식으로 정의하고 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand은 상태에 액세스하고 업데이트 기능을 제공하는 사용자 정의 React 훅을 생성하여 작동합니다. 이 훅은 응용 프로그램 어디에서나 상태에 액세스하고 업데이트할 수 있습니다. Zustand는 상태를 정의하고 다양한 방법으로 조작하기 쉽게 하는 도우미 함수 및 유틸리티 세트를 제공합니다.\n\n# React Query란?\n\nReact Query는 React용 강력하고 유연한 데이터 검색 및 캐싱 라이브러리입니다. REST API, GraphQL API 등 다양한 소스에서 데이터를 가져오는 간단하고 선언적인 API를 제공합니다. React Query는 또한 응용 프로그램에서 서버 상태를 관리하는 데 사용할 수 있는 강력한 캐싱 레이어를 제공합니다.\n\nReact Query의 주요 이점 중 하나는 그 유연성입니다. 자동 재시도, 백그라운드 다시 가져오기 등을 지원하는 데이터 검색 및 캐싱을 구성하는 다양한 옵션을 제공합니다. 이를 통해 사용자 지정 로직이나 보일러플레이트 없이도 응용 프로그램에서 다양한 데이터 검색 및 캐싱 시나리오를 쉽게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Zustand과 React Query 함께 사용하기\n\nZustand과 React Query는 각각 강력한 상태 관리 라이브러리입니다. 하지만 두 라이브러리를 함께 사용하면 더욱 강력한 기능을 발휘할 수 있습니다. 두 라이브러리를 결합하여 React 애플리케이션에서 상태를 효과적으로 관리하는 견고하고 유연한 솔루션을 만들 수 있습니다.\n\n전반적으로 접근 방식은 간단합니다. Zustand를 사용하여 애플리케이션의 로컬 상태를 관리하고, React Query를 사용하여 서버 상태를 관리합니다. Zustand는 함수형 프로그래밍 개념을 활용하여 간단하고 유연하게 로컬 상태를 정의하고 관리할 수 있는 방법을 제공하는 반면, React Query는 선언적 API를 활용하여 강력하고 유연하게 서버 상태를 관리할 수 있습니다.\n\n실제로 이를 구현하는 방법을 좀 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Zustand을 사용하여 상태 정의하기\n\nZustand와 React Query를 함께 사용하는 첫 번째 단계는 Zustand를 사용하여 애플리케이션의 상태를 정의하는 것입니다. 이 과정은 상태를 정의하고 업데이트 함수 집합을 제공하는 사용자 정의 훅을 생성하는 것을 포함합니다.\n\n다음은 이 과정이 어떻게 보일 수 있는지 예시입니다:\n\n![예시](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 Zustand를 사용하여 상태를 관리하는 간단한 카운터를 정의하고 있습니다. useStore 훅은 count 속성과 상태를 업데이트하는 데 사용할 수 있는 increment 및 decrement 함수를 포함하는 객체를 반환합니다.\n\n# Zustand과 React Query를 함께 사용하는 방법\n\n이제 Zustand와 React Query를 함께 사용하는 장점을 이해했으니, Zustand를 활용한 애플리케이션에서 React Query를 구현하는 방법을 살펴보겠습니다.\n\n- React Query 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 React Query와 그 종속성들을 설치해야 합니다. 터미널을 열고 프로젝트 디렉토리로 이동하세요.\n\n다음 명령어를 실행하세요:\nnpm install react-query\n\n2. React Query 공급자 설정\n\nReact Query를 사용하려면 QueryClientProvider 컴포넌트로 애플리케이션을 감싸야 합니다. 이 컴포넌트는 React Query가 제대로 작동할 수 있도록 필요한 컨텍스트를 제공합니다. 루트 컴포넌트 파일에서 필요한 종속성을 import하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_2.png)\n\n여기서는 QueryClient의 새 인스턴스를 생성하고 queryClient를 속성으로 전달하여 전체 애플리케이션을 QueryClientProvider 내에 래핑합니다.\n\n3. React Query를 사용하여 데이터 가져오기\n\nReact Query는 데이터를 가져오기 위한 간단하고 선언적인 API를 제공합니다. React Query를 사용하여 API 엔드포인트에서 데이터를 가져오는 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_3.png)\n\n이 예시에서는 React Query의 useQuery 훅을 사용하여 /api/users 엔드포인트에서 데이터를 가져오고 있습니다. useQuery의 첫 번째 인자는이 쿼리를 식별하는 고유한 키입니다. 두 번째 인자는 데이터를 가져오는 비동기 함수입니다. React Query는 캐싱, 백그라운드 재검색 및 오류 처리를 처리해줍니다.\n\nuseQuery 훅은 데이터, 로딩 상태 및 오류 여부 속성이 있는 객체를 반환합니다. 이러한 속성을 사용하여 데이터 가져오기 프로세스의 다른 상태를 처리할 수 있습니다.\n\n4. Zustand과 React Query를 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 결합하기 위해 React Query의 데이터를 Zustand 상태에 통합할 수 있습니다. Zustand를 사용하여 전역 상태를 관리하고 React Query를 사용하여 데이터를 가져오고 업데이트할 수 있습니다.\n\nReact Query 데이터를 Zustand에 통합하는 예시를 살펴봅시다:\n\n![image](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_4.png)\n\n이 예시에서 useStore 훅을 사용하여 Zustand에서 users 상태를 정의합니다. 또한 상태를 업데이트하는 setUsers 함수를 정의합니다. UsersList 컴포넌트 내에서는 API 엔드포인트에서 데이터를 가져오기 위해 useQuery 훅을 사용합니다. 데이터를 가져올 때 setUsers 함수를 호출하여 가져온 데이터로 Zustand 상태를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 결합하여 전역 상태를 쉽게 관리할 수 있습니다. Zustand를 사용하면서 React Query의 강력한 데이터 가져오기 및 캐싱 기능을 활용할 수 있습니다.\n\n## Zustand과 React Query를 함께 사용하는 장점\n\n이전에 언급한대로, Zustand와 React Query는 React 애플리케이션용 강력한 상태 관리 라이브러리입니다. 함께 사용할 때는 Redux나 각각 사용하는 것보다 여러 장점을 제공합니다. 이러한 장점을 자세히 살펴보겠습니다.\n\n- 코드 간소화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 함께 사용하는 가장 중요한 장점 중 하나는 코드를 간소화한다는 것입니다. Zustand는 응용 프로그램 상태를 관리하기 위한 간단한 API를 제공하며, React Query는 데이터 가져오기와 캐싱을 간단하게 만들어줍니다. 이 둘을 함께 사용하면 그렇지 않았다면 작성해야 했을 많은 뼈대 코드를 제거할 수 있습니다.\n예를 들어, Zustand를 사용하여 응용 프로그램의 전역 상태를 관리하고, 그런 다음 React Query를 사용하여 API에서 데이터를 가져올 수 있습니다. 이를 통해 데이터와 UI를 분리하여 코드를 더 모듈식으로 유지하고 이해하기 쉽게 만들 수 있습니다.\n\n2. 성능 향상\n\nReact Query의 캐싱 메커니즘은 응용 프로그램에 훌륭한 성능 향상을 제공합니다. 클라이언트 측에서 데이터를 캐시함으로써 응용 프로그램이 수행하는 네트워크 요청의 수를 줄일 수 있어 더 빠르고 반응성이 향상됩니다.\n\nZustand의 작은 크기와 간결함도 성능 향상에 기여합니다. Redux보다 훨씬 작기 때문에 로드하는 데 더 빠르고 응용 프로그램의 메모리 풋프린트를 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 쉬운 통합\n\nZustand와 React Query는 기존의 React 애플리케이션에 쉽게 통합할 수 있습니다. Zustand는 React의 훅과 잘 작동하는 간단한 API를 제공하여 구성 요소에 쉽게 통합할 수 있습니다. React Query도 통합하기 쉽고 데이터 가져오기 라이브러리와 함께 사용할 수 있어 유연하고 사용자 정의가 가능합니다.\n\n4. 확장성\n\nZustand의 간결함은 소규모에서 중규모 애플리케이션에 좋은 선택입니다. 그러나 React Query와 결합하면 대규모 복잡한 애플리케이션을 구축하는 강력한 도구가 됩니다. React Query의 캐싱 메커니즘과 다른 라이브러리와의 쉬운 통합은 애플리케이션의 확장에 좋은 선택입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nZustand과 React Query는 함께 사용할 때 React 애플리케이션에서 상태를 관리하고 데이터를 가져오는 간단하고 확장 가능한 솔루션을 제공하는 강력한 상태 관리 라이브러리입니다. Zustand는 로컬 상태의 관리를 간소화하고, React Query는 서버 상태를 처리하고 성능있는 캐싱 레이어를 제공합니다.\n\nReact Query를 Zustand와 통합함으로써 React 애플리케이션에서 코드를 단순화하고 성능을 향상시키며 쉽게 통합하고 확장 가능성을 높일 수 있습니다. 작은 프로젝트나 대규모 애플리케이션을 구축하더라도 Zustand와 React Query는 상태 관리와 데이터 가져오기에 강력하고 유연한 솔루션을 제공합니다.\n\n다음 React 프로젝트에 Zustand와 React Query를 통합하여 상태 관리 작업에서 가져다 주는 효율성과 생산성을 경험해보세요.","ogImage":{"url":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png"},"coverImage":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png","tag":["Tech"],"readingTime":6},{"title":"JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법","description":"","date":"2024-05-01 18:11","slug":"2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications","content":"\n\n웹 개발에 한정되어 있던 JavaScript가 이제는 브라우저 외의 다양한 응용 프로그램을 구동하는 데 확장되었습니다. 데스크톱 애플리케이션부터 모바일 앱까지, JavaScript는 유연성과 다양한 프레임워크 및 라이브러리 생태계 덕분에 만연한 언어가 되었습니다. 이 글에서는 JavaScript의 응용 분야, 데스크톱 및 모바일 개발을 위한 프레임워크, 그리고 그들을 마스터하기 위한 학습 프로그램에 대해 살펴보겠습니다.\n\n## JavaScript를 사용할 수 있는 곳\n\n- 웹 개발: JavaScript의 주요 용도는 여전히 웹 개발입니다. 이는 웹 페이지의 상호 작용성과 기능을 향상시켜 동적 콘텐츠, 양식 유효성 검사, 애니메이션 등을 가능하게 합니다.\n- 데스크톱 애플리케이션: Electron의 등장으로 JavaScript는 데스크톱 애플리케이션 개발에 진출했습니다. Electron을 통해 개발자는 HTML, CSS, JavaScript와 같은 웹 기술을 활용하여 크로스 플랫폼 데스크톱 앱을 구축할 수 있으며, 웹 개발 기술을 활용할 수 있습니다.\n- 모바일 애플리케이션: JavaScript는 점점 더 모바일 앱 개발에 활용되고 있으며, 주로 React Native 및 Progressive Web Apps (PWA)와 같은 프레임워크를 통해 구현됩니다. 이러한 프레임워크를 사용하면 JavaScript를 사용하여 모바일 앱을 개발할 수 있으며, 네이티브와 유사한 경험을 제공할 수 있습니다.\n- 서버 측 개발: Chrome의 V8 JavaScript 엔진 위에 구축된 Node.js는 JavaScript를 사용하여 서버 측 코드를 작성할 수 있도록 하는 JavaScript 런타임입니다. 비차단, 이벤트 주도 아키텍처로 인기를 얻은 Node.js는 확장 가능하고 실시간 애플리케이션을 구축하기에 적합합니다.\n\n![이미지](/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데스크톱 및 모바일 애플리케이션을 위한 프레임워크\n\nElectron: Electron은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 구축하기 위한 프레임워크입니다. 웹 콘텐츠를 독립적인 애플리케이션으로 패키징하여 네이티브와 유사한 경험을 제공하며, 다양한 플랫폼에 배포할 수 있습니다. 핵심 기능으로는 네이티브 운영 체제 API, 자동 업데이트 및 광범위한 커뮤니티 지원이 있습니다.\n\nReact Native: 페이스북에서 개발된 React Native은 JavaScript와 React를 사용하여 모바일 애플리케이션을 구축하는 인기 있는 프레임워크입니다. 개발자들은 코드를 한 번 작성하고 iOS 및 Android 플랫폼 모두에 배포할 수 있어 개발 시간과 노력을 줄일 수 있습니다. React Native은 네이티브 컴포넌트를 활용하여 고성능 및 네이티브와 유사한 앱을 제작할 수 있습니다.\n\nFlutter: JavaScript를 기반으로 하지는 않지만, Flutter는 모바일 앱 개발에서 두드러진 성과를 보여주기 때문에 언급할 가치가 있습니다. Google에서 개발된 Flutter는 Dart 프로그래밍 언어를 사용하며 React Native와 유사한 반응형 프레임워크를 제공합니다. 단일 코드베이스로 고품질 크로스 플랫폼 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자바스크립트 프레임워크를 마스터하기 위한 학습 프로그램\n\n자바스크립트의 기초: 자바스크립트 기본 지식을 토대로 시작해보세요. 문법, 데이터 유형, 함수, 비동기 프로그래밍 등을 포함한 기본 개념을 이해합니다.\n\n리액트로 웹 개발: 리액트는 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리로, 재사용 가능한 UI 구성 요소를 만드는 데 주로 초점을 맞춥니다. 핵심적으로, 리액트는 가상 DOM(문서 객체 모델)의 원리에 따라 작동하며 컴포넌트 기반 아키텍처를 따릅니다. 리액트는 UI를 재사용 가능한 구성 요소로 구성하며, 이는 사용자 인터페이스의 일부를 나타내는 작고 독립적인 코드 단위입니다. 컴포넌트는 서로 중첩시켜 복잡한 UI 구조를 만들 수 있습니다.\n\n리액트는 가상 DOM이라고 하는 가벼운 인메모리 DOM 표현을 유지합니다. 응용 프로그램의 상태나 데이터에 변경이 있을 때, 리액트는 실제 DOM을 직접 조작하는 대신 가상 DOM을 재 렌더링합니다. 리액트는 JSX를 도입했는데, 이는 자바스크립트를 위한 구문 확장으로, 개발자가 자바스크립트 내에서 HTML과 유사한 코드를 작성할 수 있게 합니다. JSX를 사용하면 UI 구성 요소의 구조와 동작을 선언적으로 정의하는 것이 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데스크톱 애플리케이션용 Electron: Electron.js 또는 간단히 Electron으로 불리는 Electron은 GitHub에서 개발된 오픈소스 프레임워크로, HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 만들 수 있습니다. 이를 통해 개발자들은 웹사이트를 구축하는 데 사용하는 동일한 기술을 사용하여 데스크톱 애플리케이션을 만들 수 있습니다. Electron은 HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 데스크톱 애플리케이션을 구축하는 프레임워크를 제공합니다. Windows, macOS, Linux 등 다양한 운영체제에서 실행할 수 있는 데스크톱 애플리케이션을 단일 코드베이스로 개발할 수 있도록 합니다. 개발 과정을 간소화하는 라이브러리, 도구, 리소스로 이루어진 풍부한 생태계가 있습니다. npm 패키지, 프레임워크, 플러그인 등을 활용하여 Electron 애플리케이션 기능을 확장할 수 있습니다.\n\nElectron은 크로스 플랫폼 데스크톱 애플리케이션을 구축하는 데 주로 사용됩니다. 생산성 도구, 통신 앱, 미디어 플레이어, 개발 도구 등 다양한 목적의 애플리케이션을 개발할 수 있습니다. Electron을 사용하면 웹 기반 사용자 인터페이스로 데스크톱 애플리케이션을 만들 수 있어 웹 개발자에게 익숙하고 빠른 개발이 가능합니다. Electron 애플리케이션은 다양한 웹 기술과 서드파티 라이브러리를 활용하여 사용자 정의 및 확장이 가능합니다. 개발자는 자신의 애플리케이션에 고유한 사용자 경험을 만들고 추가 기능을 통합할 수 있는 유연성을 갖습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 고급 주제\n- 상태 관리 라이브러리(Redux, MobX)와 같은 고급 주제에 대해 탐구해보세요. \n- 테스트, 성능 최적화, 그리고 데스크톱 및 모바일 애플리케이션의 배포 전략에 대한 학습도 이어지겠지요.\n\n### 크로스 플랫폼 개발을 위한 Flutter\n- 플러터(Flutter)는 풍부하고 반응형 사용자 인터페이스를 구축하기 위한 미리 디자인된 위젯 세트를 제공하는 포괄적인 UI 툴킷입니다.\n- Flutter는 텍스트, 버튼, 이미지, 레이아웃, 애니메이션 등 다양한 사용자 정의 가능한 위젯을 제공합니다.\n- Flutter를 사용하면 개발자들은 코드를 한 번 작성하고 iOS, Android, 웹, 데스크톱을 포함한 여러 플랫폼에 배포할 수 있습니다.\n- 이 접근 방식은 효율적인 크로스 플랫폼 개발을 가능케 하며, 개발 시간과 노력을 줄일 수 있습니다.\n\n### 실제 프로젝트\n- 개인적으로 또는 GitHub와 같은 온라인 플랫폼을 통해 실제 프로젝트에 참여하여 실무 경험을 쌓고 본인의 기술을 과시해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구조화된 공부 프로그램을 따라가면 JavaScript 기반 데스크톱 및 모바일 애플리케이션 개발을 위한 프레임워크와 도구를 점차 숙달할 수 있습니다. 소프트웨어 개발 분야에서 보람찬 경력을 쌓을 수 있도록 길을 열어줄 거에요.\n\n친구, 시간 내 주셔서 고마워요... 다음 기사에서 만나요 :)","ogImage":{"url":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"},"coverImage":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png","tag":["Tech"],"readingTime":4},{"title":"Next.js에서 로컬 스토리지 사용하는 방법","description":"","date":"2024-05-01 18:10","slug":"2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png\" /\u003e\n\n로컬 스토리지는 웹 응용 프로그램이 사용자의 브라우저 내에서 데이터를 로컬로 저장할 수 있는 웹 스토리지 유형입니다. 이 웹 API를 사용하면 개발자가 브라우저의 메모리에 키-값 쌍을 저장할 수 있습니다. 이는 브라우저 세션 및 페이지 새로 고침 간에 데이터를 지속적으로 유지하거나 저장하는 데 사용할 수 있는 간단하면서도 강력한 도구입니다. 이는 사용자 환경 설정을 저장하거나 오프라인 환경을 만들거나 나중에 사용할 데이터를 저장하는 데 유용할 수 있습니다.\n\n이 글에서는 로컬 스토리지의 사용 사례와 Next.js 웹 응용 프로그램에서 로컬 스토리지를 사용하는 방법을 살펴보겠습니다.\n\n## 어디에서 로컬 스토리지를 사용할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 애플리케이션에서 사용할 수 있는 여러 시나리오가 있어요. \n\n- 사용자 설정 저장: 전자 상거래 애플리케이션에서는 사용자가 선호하는 통화를 로컬 스토리지에 저장하여 매번 웹 사이트를 방문할 때 해당 통화로 가격을 자동으로 표시할 수 있어요.\n- 임시 데이터 저장: 업무 관리 애플리케이션에서는 사용자가 '할 일' 목록에 추가한 작업을 아직 완료하지 않은 상태로 로컬 스토리지에 저장할 수 있어요. 그래서 브라우저를 닫거나 페이지를 이탈해도 진행 상황이 소멸되지 않아요.\n- 폼 데이터 저장: 구직 신청서에서는 사용자가 입력한 데이터를 나중에도 폼으로 돌아와서 진행 상황을 유지할 수 있도록 로컬 스토리지에 저장할 수 있어요.\n- 데이터 캐싱: 날씨 애플리케이션에서는 현재 날씨 상황을 로컬 스토리지에 저장하여 사용자가 오프라인일 때에도 접근할 수 있게 할 수 있어요.\n- 인증 정보 저장: 소셜 미디어 애플리케이션에서는 사용자의 인증 토큰을 로컬 스토리지에 저장하여 매번 애플리케이션을 열 때마다 로그인할 필요가 없게 할 수 있어요. (로컬 스토리지에 민감한 데이터를 암호화하지 않고 저장하는 것은 추천되지 않아요. 민감한 데이터 암호화를 다루는 방법을 알고 싶다면 이 기사를 참고해보세요.)\n\n## Local Storage 객체\n\n로컬 스토리지를 사용하기 위해서는 브라우저에서 제공하는 localStorage 객체를 사용할 수 있어요. 이 객체에는 로컬 스토리지와 상호작용하기 위한 여러 메소드가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메서드\n\n다음은 localStorage에서 사용할 수 있는 메서드입니다:\n\n- setItem(key, value): 이 메서드는 키-값 쌍을 로컬 스토리지에 추가하는 데 사용됩니다. 키는 문자열이며 값은 문자열 또는 JavaScript 객체가 될 수 있습니다. 이 값은 저장되기 전에 자동으로 문자열로 변환됩니다.\n\n```js\nlocalStorage.setItem('username', 'Anisha');\nlocalStorage.setItem('userId', '12345');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- getItem(key): 해당 메서드는 로컬 스토리지에서 키의 값을 검색하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 값을 문자열로 반환합니다.\n\n```js\nlocalStorage.getItem('username');\nlocalStorage.getItem('userId');\n```\n\n- removeItem(key): 해당 메서드는 로컬 스토리지에서 키-값 쌍을 제거하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 키-값 쌍을 로컬 스토리지에서 제거합니다.\n\n```js\nlocalStorage.removeItem('username');\nlocalStorage.removeItem('userId');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- clear(): 이 메서드는 로컬 스토리지에서 모든 키-값 쌍을 제거하는 데 사용됩니다.\n\n```js\nlocalStorage.clear();\n```\n\n- key(index): 이 메서드는 로컬 스토리지에서 특정 인덱스에 있는 키-값 쌍의 키를 검색하는 데 사용됩니다. 인덱스를 매개변수로 받아 해당하는 키를 문자열 형식으로 반환합니다.\n\n```js\nconst key = localStorage.key(0); // 0번 인덱스의 키를 가져오기\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- length: 숫자 쌍의 개수를 반환하는 읽기 전용 속성입니다.\n\n```js\nconst numOfItemsInLocalStorage = localStorage.length()\n```\n\n## 로컬 저장소 구현 예시\n\n다음은 Next.js 애플리케이션에서 모든 localStorage 메서드를 사용하는 방법에 대한 완전한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 우리는 localStorage에 저장할 각 항목에 대한 상태를 만들고 키와 로컬 저장소의 항목 수에 대한 상태를 생성합니다.\n\n```js\nconst [username, setUsername] = useState\u003cstring | null\u003e(null);\nconst [userId, setUserId] = useState\u003cstring | null\u003e(null);\nconst [userData, setUserData] = useState\u003c{email: string, age: number} | null\u003e(null);\nconst [keys, setKeys] = useState\u003cstring[]\u003e([]);\nconst [length, setLength] = useState\u003cnumber\u003e(0);\n```\n\n이제 useEffect 훅을 사용하여 브라우저의 localStorage API의 사용 가능 여부를 확인하고, 컴포넌트가 처음으로 렌더링될 때 localStorage에 저장된 키-값 쌍의 값을 검색합니다.\n\n```js\nuseEffect(() =\u003e {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    let username = localStorage.getItem('username');\n    let userId = localStorage.getItem('userId');\n    let userData = JSON.parse(localStorage.getItem('userData'));\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}, []);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 handleSave, handleRemove, handleClear 세 가지 이벤트 핸들러를 사용해서 데이터를 저장, 삭제, 지우는 함수를 구현했어요.\n\nhandleSave 함수 안에서는 setItem 메서드를 사용하여 로컬 스토리지에 키-값 쌍을 저장해요. 그런 다음 getItem 메서드를 사용하여 그 값을 불러와 setUsername, setUserId, setUserData, setKeys, setLength를 사용해서 상태를 갱신합니다.\n\n```js\nfunction handleSave() {\n  if (typeof window !== \"undefined\" \u0026\u0026 window.localStorage) {\n    localStorage.setItem(\"username\", \"Anisha\");\n    localStorage.setItem(\"userId\", \"12345\");\n    localStorage.setItem(\"userData\", JSON.stringify({ email: \"anisha@example.com\", age: 25 }));\n\n    let username = localStorage.getItem(\"username\");\n    let userId = localStorage.getItem(\"userId\");\n    let userData = JSON.parse(localStorage.getItem(\"userData\")!);\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhandleRemove 함수에서는 removeItem 메서드를 사용하여 로컬 저장소에서 `username` 키-값 쌍을 제거하고 setUsername을 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleRemove() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.removeItem('username');\n    setUsername(null);\n  }\n}\n```\n\nhandleClear 함수에서는 clear 메서드를 사용하여 로컬 저장소에서 모든 키-값 쌍을 제거하고 setUsername, setUserId, setUserData, setKeys, setLength를 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleClear() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.clear();\n    setUsername(null);\n    setUserId(null);\n    setUserData(null);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 렌더 메서드에서는 localStorage에 저장된 키-값 쌍의 값을 표시하고 로컬 저장소와 상호 작용할 수 있는 버튼을 제공합니다.\n\n```js\n\u003cdiv\u003e\n  \u003cbutton onClick={handleSave}\u003elocalStorage에 저장\u003c/button\u003e\n  \u003cbutton onClick={handleRemove}\u003elocalStorage에서 제거\u003c/button\u003e\n  \u003cbutton onClick={handleClear}\u003elocalStorage 지우기\u003c/button\u003e\n  \u003cp\u003e사용자 이름: {username}\u003c/p\u003e\n  \u003cp\u003e사용자 ID: {userId}\u003c/p\u003e\n  \u003cp\u003e사용자 데이터: {JSON.stringify(userData)}\u003c/p\u003e\n  \u003cp\u003e키 목록: {keys.join(\", \")}\u003c/p\u003e\n  \u003cp\u003e로컬 저장소의 총 아이템 수: {length}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n코드의 더 자세한 내용을 확인하고 싶다면, 내 GitHub 저장소를 자유롭게 확인해주세요.\n\n## 로컬 저장소 사용 시 보안 고려 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 사용하는 한 가지 단점은 그 안에 저장된 데이터가 일반 텍스트 형식이라는 것입니다. 이는 악성 스크립트에 의해 쉽게 액세스될 수 있다는 것을 의미합니다. 이는 공격자가 사용자의 장치에 액세스를 얻으면 로컬 스토리지에 저장된 데이터에 잠재적으로 액세스할 수 있다는 것을 의미합니다.\n\n다음은 Next.js 애플리케이션에서 민감한 데이터를 암호화하는 방법을 찾는 데 도움이 되는 이 기사의 제2부입니다. Next.js 앱의 로컬 스토리지에 민감한 데이터를 안전하게 보호하기","ogImage":{"url":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서의 훅(Hooks)을 제대로 사용하는 방법","description":"","date":"2024-05-01 18:08","slug":"2024-05-01-HooksinReacts","content":"\n\n현대 웹 개발 분야에서는 React의 Hooks 도입이 개발자들이 사용자 인터페이스를 구축하는 방식에 상당한 변화를 가져왔어요. Hooks는 클래스를 작성하지 않고도 상태 및 기타 React 기능을 활용할 수 있게 해주는 함수들이에요. 이를 통해 개발 프로세스가 간소화되고 코드베이스를 더 잘 관리하고 가독성있게 만들 수 있어요. Hooks를 사용하면 useState를 활용하여 컴포넌트 상태를 쉽게 관리하고, useEffect로 부수 효과를 처리하며, useContext를 사용하여 컴포넌트 내에서 컨텍스트에 접근할 수 있어요.\n\n# useReducer\n\nuseReducer는 컴포넌트 내에서 복잡한 상태 로직을 관리하기 위해 사용되는 React 훅이에요. 특히 이전 상태에 따라 상태 전이가 발생하는 경우에 유용해요. 여기서 useReducer가 적용될 수 있는 몇 가지 다른 사용 사례들을 제공할게요.\n\n```js\nimport React, { useReducer } from \"react\";\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"LOGIN\":\nreturn { …state, user: action.payload.user, isLoggedIn: true };\ncase \"LOGOUT\":\nreturn { …state, user: null, isLoggedIn: false };\ndefault:\nreturn state;\n}\n}\nfunction Auth() {\nconst [state, dispatch] = useReducer(reducer, {\nuser: null,\nisLoggedIn: false,\n});\nconst handleLogin = () =\u003e {\n// 로그인 처리 로직\nconst fakeUser = { username: \"user\", email: \"user@example.com\" };\ndispatch({ type: \"LOGIN\", payload: { user: fakeUser } });\n};\nconst handleLogout = () =\u003e {\n// 로그아웃 처리 로직\ndispatch({ type: \"LOGOUT\" });\n};\nreturn (\n\u003cdiv\u003e\n{state.isLoggedIn ? (\n\u003cdiv\u003e\n\u003cp\u003e환영합니다, {state.user.username}님!\u003c/p\u003e\n\u003cbutton onClick={handleLogout}\u003e로그아웃\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cbutton onClick={handleLogin}\u003e로그인\u003c/button\u003e\n)}\n\u003c/div\u003e\n);\n}\nexport default Auth;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useContext\n\nuseContext은 함수형 컴포넌트 내에서 컨텍스트를 소비하는 데 사용되는 React 훅입니다. 이를 통해 React.createContext() 함수에 의해 생성된 컨텍스트 객체의 값을 액세스할 수 있습니다. useContext의 몇 가지 다른 사용 사례와 여러 값을 처리하는 방법에 대해 살펴보겠습니다:\n\n```js\nimport React, { createContext, useContext, useState } from 'react';\nconst UserContext = createContext();\nconst UserProvider = ({ children }) =\u003e {\nconst [user, setUser] = useState(null);\nconst login = (userData) =\u003e {\nsetUser(userData);\n};\nconst logout = () =\u003e {\nsetUser(null);\n};\nreturn (\n\u003cUserContext.Provider value={ user, login, logout }\u003e\n{children}\n\u003c/UserContext.Provider\u003e\n);\n};\nconst Profile = () =\u003e {\nconst { user, logout } = useContext(UserContext);\nreturn (\n\u003cdiv\u003e\n{user ? (\n\u003cdiv\u003e\n\u003cp\u003eWelcome, {user.name}!\u003c/p\u003e\n\u003cbutton onClick={logout}\u003eLogout\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cp\u003ePlease log in\u003c/p\u003e\n)}\n\u003c/div\u003e\n);\n};\nconst LoginForm = () =\u003e {\nconst { login } = useContext(UserContext);\nconst [username, setUsername] = useState('');\nconst [password, setPassword] = useState('');\nconst handleLogin = () =\u003e {\n// perform login logic\nconst userData = { name: username }; // Example data\nlogin(userData);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={username} onChange={(e) =\u003e setUsername(e.target.value)} /\u003e\n\u003cinput type=\"password\" value={password} onChange={(e) =\u003e setPassword(e.target.value)} /\u003e\n\u003cbutton onClick={handleLogin}\u003eLogin\u003c/button\u003e\n\u003c/div\u003e\n);\n};\nconst App = () =\u003e {\nreturn (\n\u003cUserProvider\u003e\n\u003cProfile /\u003e\n\u003cLoginForm /\u003e\n\u003c/UserProvider\u003e\n);\n};\nexport default App;\n```\n\n# useRef\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseRef은 주로 React 훅으로 사용되며, 다시 렌더링을 유발하지 않고 렌더링 간 지속되는 가변 값에 액세스하고 저장하는 데 주로 사용됩니다. 이는 DOM 요소에 액세스하거나 렌더링 간 값 추적 또는 가변 변수 저장에 흔히 사용됩니다. useRef의 다양한 사용 사례와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useRef } from \"react\";\nfunction MutableValues() {\nconst counterRef = useRef(0);\nconst incrementCounter = () =\u003e {\ncounterRef.current += 1;\nconsole.log('Current value of counter:', counterRef.current);\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={incrementCounter}\u003eIncrement Counter\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default MutableValues;\n```\n\n# useCallback\n\nuseCallback은 함수를 메모이제이션하는 데 사용되는 React 훅입니다. 자식 컴포넌트에 콜백을 전달할 때 불필요한 다시 렌더링을 방지하는 데 특히 유용합니다. useCallback의 다양한 사용 사례와 여러 값을 처리하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useCallback } from 'react';\nimport ChildComponent from './ChildComponent';\nfunction ParentComponent() {\nconst [count, setCount] = useState(0);\n// count를 의존성으로 갖는 메모이제이션된 콜백 함수\nconst handleClick = useCallback(() =\u003e {\nconsole.log('버튼이 클릭되었습니다! Count:', count);\n}, [count]);\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent onClick={handleClick} /\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e증가\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useMemo\n\nuseMemo는 비용이 많이 드는 계산을 메모이제이션하기 위해 사용되는 React 훅입니다. 값들의 불필요한 다시 계산을 피하고 성능을 최적화해야 하는 경우에 특히 유용합니다. useMemo의 다양한 사용 사례와 여러 값들을 다루는 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useMemo } from \"react\";\nfunction ProductList() {\nconst [products] = useState([\n{ id: 1, name: \"제품 1\", price: 10 },\n{ id: 2, name: \"제품 2\", price: 20 },\n{ id: 3, name: \"제품 3\", price: 30 },\n{ id: 4, name: \"제품 4\", price: 30 },\n{ id: 5, name: \"제품 5\", price: 30 },\n]);\nconst [selectedProducts, setSelectedProducts] = useState([]);\nconst handleToggleProduct = (productId) =\u003e {\nsetSelectedProducts((prevSelectedProducts) =\u003e {\nconst isSelected = prevSelectedProducts.includes(productId);\nif (isSelected) {\nreturn prevSelectedProducts.filter((id) =\u003e id !== productId);\n} else {\nreturn [...prevSelectedProducts, productId];\n}\n});\n};\n// 총 가격 메모이제이션된 계산\nconst totalPrice = useMemo(() =\u003e {\nconsole.log(\"총 가격 계산 중...\");\nreturn selectedProducts.reduce((total, productId) =\u003e {\nconst selectedProduct = products.find(\n(product) =\u003e product.id === productId\n);\nreturn total + (selectedProduct ? selectedProduct.price : 0);\n}, 0);\n}, [selectedProducts, products]);\nreturn (\n\u003cdiv\u003e\n\u003ch2\u003e제품 목록\u003c/h2\u003e\n\u003cul\u003e\n{products.map((product) =\u003e (\n\u003cli key={product.id}\u003e\n\u003clabel\u003e\n\u003cinput\ntype=\"checkbox\"\nchecked={selectedProducts.includes(product.id)}\nonChange={() =\u003e handleToggleProduct(product.id)}\n/\u003e\n{product.name} - ${product.price}\n\u003c/label\u003e\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003ch3\u003e총 가격: ${totalPrice}\u003c/h3\u003e\n\u003c/div\u003e\n);\n}\nexport default ProductList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useImperativeHandle\n\nuseImperativeHandle은 React 훅으로, React.forwardRef를 사용할 때 부모 컴포넌트가 자식 컴포넌트에 노출하는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 부모 컴포넌트의 부모에게 액세스 가능한 함수 또는 값들을 정의하고, 직접 자식 컴포넌트에 노출되지 않도록 합니다. useImperativeHandle의 몇 가지 사용 사례 및 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useImperativeHandle, forwardRef } from 'react';\nconst ChildComponent = forwardRef((props, ref) =\u003e {\nconst [count, setCount] = useState(0);\nuseImperativeHandle(ref, () =\u003e ({\ngetCount: () =\u003e count\n}));\nreturn (\n\u003cdiv\u003e\n\u003cp\u003eCount: {count}\u003c/p\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n\u003c/div\u003e\n);\n});\nfunction ParentComponent() {\nconst childRef = useRef(null);\nconst handleGetCount = () =\u003e {\nalert(`Count from child component: ${childRef.current.getCount()}`);\n};\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent ref={childRef} /\u003e\n\u003cbutton onClick={handleGetCount}\u003eGet Count from Child\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useLayoutEffect\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseLayoutEffect은 useEffect와 유사한 React 훅이지만, 모든 DOM 변이 후 동기적으로 실행됩니다. 브라우저가 화면을 그리기 전에 반드시 DOM 명령을 실행하거나 DOM에서 레이아웃 정보를 읽어야 하는 경우에 유용합니다. useLayoutEffect의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useLayoutEffect, useRef } from 'react';\nfunction ComponentWithLayoutEffect() {\nconst [dimensions, setDimensions] = useState({ width: 0, height: 0 });\nconst elementRef = useRef(null);\nuseLayoutEffect(() =\u003e {\nconst { current: element } = elementRef;\nif (!element) return;\nconst { width, height } = element.getBoundingClientRect();\nsetDimensions({ width, height });\n}, [elementRef]);\nreturn (\n\u003cdiv ref={elementRef}\u003e\n\u003cp\u003eWidth: {dimensions.width}px\u003c/p\u003e\n\u003cp\u003eHeight: {dimensions.height}px\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default ComponentWithLayoutEffect;\n```\n\n# useDeferredValue\n\nuseDeferredValue는 React 18에서 도입된 React 훅으로, 일정 시간이 지난 후 컴포넌트 내의 값을 업데이트를 지연시킵니다. 부드러운 사용자 상호작용을 우선시하거나 빠른 상태 변경으로 인한 불필요한 다시 렌더링을 줄이는 경우에 유용합니다. useDeferredValue의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useDeferredValue } from 'react';\nfunction TextInput() {\nconst [text, setText] = useState('');\nconst deferredText = useDeferredValue(text, { timeoutMs: 1000 });\nconst handleChange = (e) =\u003e {\nsetText(e.target.value);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={text} onChange={handleChange} /\u003e\n\u003cp\u003eDeferred Value: {deferredText}\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default TextInput;\n```\n\n# useTransition\n\nuseTransition은 React 18에서 도입된 React 훅입니다. 애플리케이션에서 애니메이션과 업데이트를 조정할 수 있게 해줍니다. 특히 원활한 전환을 통해 특정 작업을 수행하고 싶을 때 유용합니다. useTransition의 몇 가지 유즈 케이스와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useTransition } from \"react\";\nfunction AnimatedList() {\nconst [items, setItems] = useState([]);\nconst [isPending, startTransition] = useTransition({ timeoutMs: 300 });\nconst addItem = () =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e […prevItems, Date.now()]);\n});\n};\nconst removeItem = (timestamp) =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e prevItems.filter((item) =\u003e item !== timestamp));\n});\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={addItem}\u003eAdd Item\u003c/button\u003e\n{isPending \u0026\u0026 \u003cp\u003eLoading…\u003c/p\u003e}\n\u003cul\u003e\n{items.map((item) =\u003e (\n\u003cli key={item}\u003e\n\u003cbutton onClick={() =\u003e removeItem(item)}\u003eRemove\u003c/button\u003e\nItem {item}\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003c/div\u003e\n);\n}\nexport default AnimatedList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useId\n\nuseId은 내장된 React 훅이 아닙니다. 하지만 React 컴포넌트 내에서 고유한 식별자를 생성하는 데 사용되는 사용자 정의 훅 또는 유틸리티 함수로 종종 구현됩니다. 이러한 식별자는 목록 항목에 고유한 키 속성을 설정하거나 고유한 HTML id 속성을 생성하거나 양식 입력란과 라벨을 연결하는 등 다양한 목적으로 유용합니다. useId의 몇 가지 사용 사례와 여러 값을 처리하는 방법에 대해 설명합니다:\n\n```js\nimport React from 'react';\nfunction List({ items }) {\n  return (\n    \u003cul\u003e\n      {items.map(item =\u003e (\n        \u003cli key={useId()}\u003e{item}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\nexport default List;\n```","ogImage":{"url":"/assets/img/2024-05-01-HooksinReacts_0.png"},"coverImage":"/assets/img/2024-05-01-HooksinReacts_0.png","tag":["Tech"],"readingTime":10},{"title":"Next.js를 위한 실제 API 미들웨어 작성 방법","description":"","date":"2024-05-01 18:07","slug":"2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png\" /\u003e\n\n어플리케이션을 위한 웹 클라이언트나 특정한 종류의 컨셉 프로젝트를 구현해야 할 때 저는 본능적으로 Next.js를 선택합니다. 몇 년 전, 제가 구현해야 했던 어플리케이션은 Next.js 버전 12가 나온 시기에 맞춰 만들어졌었는데, 이 때 공개된 많은 새로운 기능들에 대해 듣게 되어 흥분했습니다. 그 중에서도 API Middleware의 출시는 저에게 가장 흥미로운 기능 중 하나였습니다.\n\n하지만 이 흥분은 잠시 지속되었습니다. 그들의 구현은 이름은 같고 개념적으로 유사하지만, 이전에 있던 것을 재탄생시킨 느낌이었고, 결과적으로 베이스림에 담긴 벽돌 같은 느낌을 주었습니다.\n\n# Middleware가 어떤 문제를 해결하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNext.js API routes는 정말 편리한 방법 중 하나로, 클라이언트에 API를 추가할 수 있습니다. 해야 할 일은 api 디렉토리 내에 새 파일을 만들고 함수를 작성하는 것 뿐입니다.\n\n```js\nexport default function handler(req, res) {\n  res.status(200).json({ name: 'John Doe' })\n}\n```\n\n시작하기에는 이 간단함이 좋지만, 복잡성을 구현 수준으로 미루는 결과가 될 수 있습니다.\n\n예를 들어, 구현에서 요청 유형 분기 처리를 처리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport default function handler(req, res) {\n  if (req.method === 'POST') {\n    // POST 요청 처리\n  } else {\n    // 다른 모든 HTTP 메소드 처리\n  }\n}\n```\n\n이제 사용자가 인증되었는지 확인하고 싶다면 어떻게 해야 할까요? 해당 내용은 라우트 핸들러 내에서 처리해야 합니다.\n\n```js\nexport default function handler(req, res) {\n  if (!isAuthenticated(req)) {\n    res.status(401).send(\"권한이 없습니다\")\n  }\n  // 구현\n}\n```\n\n이러한 방식으로 계속 하다 보면, 핸들러 구현 앞에 조건들이 계속 쌓이는 것을 알게 되고, 더 나쁜 일로, 핸들러 간에 많은 복사 및 붙여넣기 작업이 필요합니다. 이는 완전히 혼란스러워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보통 이 문제는 어떻게 해결하나요?\n\n이 문제는 Express와 같은 프레임워크를 사용하여 매우 우아하게 해결됩니다. \n\n우리의 코드는 아래와 같이 보일 수 있어요:\n\n```js\napp.post(\n  '/hello',\n  requireAuth,\n  validatePayload,\n  doUsefulStuff,\n  respond,\n);\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 구현된 다음 인터페이스를 준수하는 한 재사용 가능한 여러 함수를 서로 쌓을 수 있게 해줍니다:\n\n- 함수는 next라는 매개변수를 가져야 하며, 이 매개변수는 함수여야 합니다.\n- 사용자 정의 로직이 실행된 후, 체인 내의 다음 함수로 이동하려면 next()를 호출하거나 즉시 요청에 응답해야 합니다.\n\n```js\nfunction myMiddleware(req, res, next) {\n  // 일부 검사 수행\n  next()\n}\n```\n\n이제 이러한 미들웨어를 목록에 추가하여 활성화하거나 제거하거나 주석 처리하여 비활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문법은 매우 명확하며 코드를 재사용할 수 있어요.\n\n# Next.js에서 미들웨어 문제를 어떻게 해결하나요?\n\nNext.js 문서를 보면 middleware.js 파일을 생성하고 미들웨어를 구현하라고 합니다. 이 부분이 조금 마음에 들지 않지만 계속해 봅시다.\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  return response\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어를 구현한 후에는 Next.js에 해당 미들웨어가 실행되어야 하는 위치를 알려주는 구성 객체를 내보내야 합니다.\n\n```js\n// 미들웨어.js\n\nexport const config = {\n  matcher: '/api/:여러분의-엔드포인트-여기에*'\n}\n```\n\n이 구성 객체에서는 정규 표현식을 지원하는 매처를 지정할 수 있습니다.\n\n만족스럽지 않다면, 미들웨어 선언 내에서 조건문을 활용하여 사용자 정의 로직을 적용해볼 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    return NextResponse.rewrite(new URL('/about-2', request.url))\n  }\n \n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\n  }\n}\n```\n\n여기서 약간의 점들이 왜 저는 이 방식을 좋아하지 않는지에 대해 이야기해 드리겠습니다:\n\n- 미들웨어 구현이 담긴 전용 middleware.js 파일이 있으면 조잡하게 느껴집니다. 라우트가 정의된 곳에 내 미들웨어를 두고 싶어요.\n- 설정과 매처 접근 방식은 정말로 필요 없어보입니다. 왜 내 미들웨어를 실행하려면 매처와 정규식을 작성해야 하는 건가요? 이미 디렉토리 구조로 라우트를 설정했는데 (제가 처음에 Next.js를 선택한 가장 큰 이유가 이것인데) 이제 다른 연관성 없는 곳으로 가서 매처나 조건문을 작성해야 한다니요.\n\n몇 가지 상황에서는 이러한 방식이 실용적일 수 있는데, 예를 들어 애플리케이션 수준에서 모든 요청에 대해 실행되는 미들웨어를 사용하는 경우 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말씀하신 대로, 이 기능의 디자인은 별로 마음에 들지 않아요. 미들웨어를 정의하고 라우트를 정의하는 곳과 같이 깔끔하게 쌓아 나열하고 유지 관리하기 쉽게 만들고 싶어요.\n\n# API 라우트를 위한 사용자 정의 미들웨어\n\n최근 Next.js에서 라우트 핸들러를 출시했지만, 대부분의 사람들(포함해서 저도)은 여전히 대부분의 프로젝트에서 API 라우트를 사용하고 있기 때문에, 먼저 API 라우트의 구현 방법에 대해 다루겠습니다.\n\n소스 코드는 GitHub에서 사용 가능하며, 아래 예시에서는 간단한 JavaScript를 사용하겠습니다. 이는 의사코드와 유사하지만 여전히 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 루트가 작동하는 방식을 설명한 것입니다.\n\n```js\n// src/pages/api/hello.js\n\nconst middleware_1 = async (req, res, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\nconst middleware_2 = async (req, res, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\nconst middleware_3 = async (req, res, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\nconst middleware_4 = async (req, res, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\nconst hello = async (req, res) =\u003e {\n  res.status(200).json({ message: 'Hello World.' })\n};\nexport default handler(\n  middleware_1,\n  middleware_2,\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n언제든지 미들웨어 체인 중간에서 next() 함수 대신 res 객체를 사용하여 응답할 수 있어야하며, 그때 체인이 실행이 중단됩니다. 또한 미들웨어는 다른 곳에서 선언되어 재사용 가능하도록 작성되고 루트로 가져와야 합니다.\n\n이러한 기능을 구현하기 위해 할 일은 여기서 호출하고 있는 handler 함수를 구현하는 것뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 예시 구현을 확인할 수 있고, 소스 코드는 여기서 찾을 수 있습니다.\n\n```js\n// src/pages/middleware/handler.js\n\nconst execMiddleware = async (\n  req,\n  res,\n  middleware,\n  index = 0,\n) =\u003e {\n  if (res.headersSent || !middleware[index]) return\n  if (typeof middleware[index] !== 'function') {\n    res.status(500).end('Middleware must be a function!')\n    throw new Error('Middleware must be a function!')\n  }\n  await middleware[index](req, res, async () =\u003e {\n    await execMiddleware(req, res, middleware, index + 1)\n  })\n}\n\nexport const handler =\n  (...middleware) =\u003e\n  async (req, res) =\u003e {\n    await execMiddleware(req, res, middleware)\n  }\n```\n\n추가적으로, 여기에서 사용할 수 있는 allowMethods 미들웨어가 포함되어 있어요. 라우트에서 다음과 같이 사용할 수 있습니다:\n\n```js\n// src/pages/api/hello.js\n\nexport default handler(\n  allowMethods(['GET', 'PUT']),\n  hello,\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라우트 핸들러를 위한 사용자 지정 미들웨어\n\n라우트 핸들러는 Next.js에서 최신 API 구현 접근 방식이며, 앞으로 채택할 것을 권장합니다.\n\n한편으로는 HTTP 메소드(GET, POST, PUT 등)별로 명명된 내보내기가 필요하게 되어 좋아하지만, 핸들러 내에서 명시적으로 응답 값을 반환해야 하는 변경 사항에는 큰 부담을 느낍니다.\n\n위와 마찬가지로 소스 코드는 GitHub에서 확인할 수 있으며, 우리가 구현하고 있는 기능을 설명하기 위해 간단한 JavaScript를 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 원하는 라우트 작업 방식을 보여줍니다.\n\n```js\n// src/app/api/hello/route.js\n\nconst middleware_1 = async (req, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\n\nconst middleware_2 = async (req, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\n\nconst middleware_3 = async (req, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\n\nconst middleware_4 = async (req, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\n\nconst hello = async (req) =\u003e {\n  return NextResponse.json({ data: 'Hello World' })\n};\n\nexport const GET = handler(\n  middleware_1,\n  middleware_2,\n  hello,\n);\n\nexport const POST = handler(\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n한 번 더 강조하지만, 미들웨어 체인에서 언제든지 응답을 반환하여 next() 함수를 호출하는 대신 응답을 반환할 수 있으며, 체인이 실행을 중지합니다.\n\n아래는 handler 함수의 예시 구현입니다. 소스 코드는 여기에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/app/middleware/handler.js\n\nexport const handler =\n  (...middleware) =\u003e\n  async (request) =\u003e {\n    let result\n    for (let i = 0; i \u003c middleware.length; i++) {\n      let nextInvoked = false\n      const next = async () =\u003e {\n        nextInvoked = true\n      };\n      result = await middleware[i](request, next);\n      if (!nextInvoked) {\n        break\n      }\n    }\n    if (result) return result\n    throw new Error('핸들러 또는 미들웨어가 NextResponse를 반환해야 합니다!')\n  }\n```\n\n# 결론\n\n당연히 취향의 문제일 수 있지만, 우리는 50줄 이하의 코드로 Next.js에 우리의 미들웨어 구현을 성공적으로 적용했고, 이것은 내 기준에서 이긴 것입니다.\n\nNext.js가 가는 방향에 대해서는, 우리가 그냥 우회로에 들어간 것이고 곧 간단하고 깨끗하며 쉬운 개발자 경험으로 돌아갈 것을 손가락을 꼬집었어요. 몇 년 전에 그들의 개발 경험이 얼마나 부드러운지 보았을 때 반해버렸으며, 아직 희망을 버리지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어 패턴에 대해서는 어떤 프로젝트에든 자유롭게 코드를 활용하셔도 괜찮아요. 이는 로직을 세분화하여 작은 조각으로 쌓는 훌륭한 방법입니다.\n\n호기심을 잃지 말고, 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png","tag":["Tech"],"readingTime":8},{"title":"Vue3 + Vite 컴포넌트화 하는 방법","description":"","date":"2024-05-01 18:06","slug":"2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas","content":"\n\n# Vue3 + rspack 003: 컴포넌트화의 기술 (Composition API) 및 일반적인 문제 해결 아이디어\n\nVue 3에서 Composition API는 컴포넌트와 로직을 재사용하는 새로운 방법을 제공합니다. 이는 우리의 코드에 더 나은 구성 구조를 제공할 뿐만 아니라 복잡한 컴포넌트 로직을 더 유연하게 처리할 수 있는 기회를 줍니다. 아래에서 탐색해봅시다.\n\n# 컴포넌트 생성 및 사용\n\n컴포넌트는 Vue 애플리케이션의 기본 구성 요소입니다. Composition API에서는 reactive 상태와 컴포넌트의 동작을 정의하기 위해 setup 함수를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시: 간단한 카운터 컴포넌트\n\n```js\n\u003ctemplate\u003e\n  \u003cbutton @click=\"increment\"\u003e{ count }\u003c/button\u003e\n\u003c/template\u003e\u003cscript\u003e\nimport { ref } from 'vue';export default {\n  setup() {\n    const count = ref(0);\n    function increment() {\n      count.value++;\n    }    return { count, increment };\n  };\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: Composition API를 사용할 때, 개발자들은 조각난 상태 로직을 경험하여 컴포넌트를 유지하기 어렵게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 관련 로직을 함수로 캡슐화한 후에 이 함수를 설정(setup)에서 호출하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.\n\n# 부모 및 자식 컴포넌트 간 통신\n\nVue 3에서 부모 및 자식 컴포넌트 간의 통신은 주로 props와 emit을 통해 이루어집니다. Composition API는 defineProps와 defineEmit 함수를 제공하여이 프로세스를 간단화합니다.\n\n# 예: 부모-자식 컴포넌트 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- ChildComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cdiv @click=\"emitToParent\"\u003e나를 클릭해주세요!\u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { defineProps, defineEmit } from 'vue';\nexport default {\n  setup() {\n    const props = defineProps(['messageFromParent']);\n    const emit = defineEmit(['messageToParent']);\n    \n    function emitToParent() {\n      emit('messageToParent', '안녕하세요, 부모님!');\n    }\n    \n    return { emitToParent };\n  }\n};\n\u003c/script\u003e\n\n\u003c!-- ParentComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cChildComponent\n    :messageFromParent=\"parentMessage\"\n    @messageToParent=\"handleMessageFromChild\"\n  /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ChildComponent from './components/ChildComponent.vue';\nexport default {\n  components: {\n    ChildComponent\n  },\n  setup() {\n    const parentMessage = ref('안녕하세요, 자식님!');\n    \n    function handleMessageFromChild(message) {\n      console.log(message);\n    }\n    \n    return { parentMessage, handleMessageFromChild };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움 : 대규모 어플리케이션에서는 종종 다층 중첩된 컴포넌트 간의 통신 요구사항이 발생합니다. 직접 props와 emit을 사용하면 \"props를 계층적으로 전달하는\" 및 \"이벤트를 계층적으로 발생시키는\" 문제가 발생할 수 있습니다.\n\n해결책 : 이러한 번거로운 계층별 전달을 피하기 위해 Vue 3의 provide 및 inject API를 사용하여 컴포넌트 간 수준의 통신을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 슬롯 사용\n\n슬롯을 사용하면 자식 컴포넌트의 내용으로 어떤 템플릿 코드든 부모 컴포넌트에 전달할 수 있습니다. Composition API에서는 슬롯 내용에 접근할 수 있습니다.\n\n# 예시: 슬롯 사용하기\n\n```js\n\u003c!-- BaseLayout.vue --\u003e\n\u003ctemplate\u003e\n  \u003cheader\u003e\n    \u003cslot name=\"header\"\u003e\u003c/slot\u003e\n  \u003c/header\u003e\n  \u003cmain\u003e\n    \u003cslot\u003e\u003c/slot\u003e\n  \u003c/main\u003e\n  \u003cfooter\u003e\n    \u003cslot name=\"footer\"\u003e\u003c/slot\u003e\n  \u003c/footer\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { useSlots } from 'vue';\nexport default {\n  setup() {\n    const slots = useSlots();\n    return { slots };\n  }\n};\n\u003c/script\u003e\n\u003c!-- App.vue --\u003e\n\u003ctemplate\u003e\n  \u003cBaseLayout\u003e\n    \u003ctemplate #header\u003e\n      \u003ch1\u003e여기에 페이지 제목이 올 수 있어요\u003c/h1\u003e\n    \u003c/template\u003e\n    \u003cp\u003e페이지의 주요 내용\u003c/p\u003e\n    \u003ctemplate #footer\u003e\n      \u003cp\u003e여기에 연락처 정보가 있습니다\u003c/p\u003e\n    \u003c/template\u003e\n  \u003c/BaseLayout\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport BaseLayout from './components/BaseLayout.vue';\nexport default {\n  components: {\n    BaseLayout\n  }\n};\n\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실용적인 어려움과 해결책\n\n어려움: 이름이 지정된 슬롯을 사용할 때, 슬롯 콘텐츠를 자식 컴포넌트의 상태 또는 동작에 따라 동기화하는 것이 복잡할 수 있습니다.\n\n해결책: scoped 슬롯을 사용할 수 있습니다. scoped 슬롯을 사용하면 자식 컴포넌트가 부모 컴포넌트에 데이터를 노출시킬 수 있고 그 데이터를 부모 컴포넌트의 슬롯 콘텐츠에서 사용할 수 있습니다.\n\n# 동적 컴포넌트와 비동기 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVue 3는 defineAsyncComponent를 통해 비동기 컴포넌트를 지원합니다. 동적 컴포넌트는 내장 `component` 태그와 `:` 속성을 사용하여 구현할 수 있습니다.\n\n# 예시: 비동기 컴포넌트\n\n```js\n// defineAsyncComponent를 사용하여 비동기 컴포넌트 로드\nimport { defineAsyncComponent } from 'vue';export default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =\u003e\n      import('./components/AsyncComponent.vue')\n    )\n  }\n};\n```\n\n# 예시: 동적 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003ccomponent :is=\"currentComponent\" /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ComponentA from './components/ComponentA.vue';\nimport ComponentB from './components/ComponentB.vue';\nexport default {\n  setup() {\n    const currentComponent = ref('ComponentA');    // 실제 상황에 맞게 currentComponent의 값을 변경하여 컴포넌트를 전환할 수 있습니다.\n    \n    // currentComponent.value = 'ComponentB';\n    \n    return { currentComponent, ComponentA, ComponentB };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: 비동기 컴포넌트를 사용할 때 컴포넌트 로딩 지연이나 실패와 같은 문제가 발생할 수 있어 사용자 경험에 영향을 줄 수 있습니다.\n\n해결책: 로딩 상태 힌트 및 오류 처리 매커니즘을 제공할 수 있습니다. 예를 들어, Suspense 컴포넌트를 사용하여 비동기 컴포넌트를 감쌀 수 있고 대체 콘텐츠(대체 콘텐츠)를 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003cSuspense\u003e\n    \u003ctemplate #default\u003e\n      \u003cAsyncComponent /\u003e\n    \u003c/template\u003e\n    \u003ctemplate #fallback\u003e\n      \u003cdiv\u003eLoading...\u003c/div\u003e\n    \u003c/template\u003e\n  \u003c/Suspense\u003e\n\u003c/template\u003e\n```\n\n위의 예제와 해결책을 통해 Vue 3의 모듈화 및 Composition API가 강력한 기능과 유연성을 제공하여 우리가 실용적인 개발 문제를 더 잘 해결하고 우아한 방식으로 복잡한 애플리케이션을 구축할 수 있음을 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"},"coverImage":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png","tag":["Tech"],"readingTime":5},{"title":"React-Native로 투두 앱 만드는 방법","description":"","date":"2024-05-01 18:04","slug":"2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png\" /\u003e\n\nReact-Native를 이용한 Todo List 애플리케이션 만들기에 대한 포괄적인 안내서에 오신 것을 환영합니다!\n\nReact-Native는 페이스북에서 개발한 강력한 프레임워크로, React의 익숙한 구문을 사용하여 크로스 플랫폼 모바일 애플리케이션을 개발할 수 있습니다. 이 튜토리얼에서는 컴포넌트, 상태 관리, 기본적인 스타일링을 포함한 React-Native의 필수 개념을 다룰 것입니다. 이 가이드의 끝에는 모바일 기기용 완전히 기능하는 Todo List 앱을 만들 준비가 될 것입니다.\n\n# 준비물\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n할 일 목록 앱을 만들기 전에 다음 사전 준비 사항이 갖춰져 있는지 확인해주세요:\n\n- JavaScript와 React 개념에 대한 기본 지식\n- 컴퓨터에 Node.js 및 npm이 설치되어 있어야 합니다.\n- Expo CLI가 npm install -g expo-cli 명령을 사용하여 전역으로 설치되어 있어야 합니다.\n- Visual Studio Code와 같은 코드 편집기\n- 테스트를 위해 Expo Go 앱이 설치된 모바일 기기\n\n# 단계 1: 프로젝트 설정하기\n\n첫 번째 작업은 Expo를 사용하여 React-Native 프로젝트를 설정하는 것입니다. 터미널을 열고 다음 명령을 실행해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1) React-Native 앱 만들기\n\n```js\nexpo init todo-app\n```\n\n## 2) 프로젝트 디렉토리로 이동\n\n```js\ncd todo-app\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3) 개발 서버 시작하기\n\n```js\nexpo start\n```\n\n이 명령어를 입력하면 새로운 React-Native 프로젝트인 \"todo-app\"이 생성되고 개발 서버가 시작됩니다.\n\n# 단계 2: 앱 컴포넌트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리의 할 일 목록 애플리케이션의 진입점인 App 컴포넌트를 만들어 봅시다.\n\n```js\n// App.js\nimport React from 'react';\nimport TodoList from './components/TodoList';\n\nexport default function App() {\n  return (\n    \u003cTodoList /\u003e\n  );\n}\n```\n\n# 단계 3: TodoList 컴포넌트 만들기\n\n이 단계에서는 작업 목록을 관리하고 작업 관련 기능을 처리할 TodoList 컴포넌트를 만들 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// components/TodoList.js\nimport React, { useState } from 'react';\nimport { View, TextInput, Button } from 'react-native';\nimport TodoItem from './TodoItem';\n\nexport default function TodoList() {\n  // State Hooks\n  const [tasks, setTasks] = useState([\n    { id: 1, text: '의사 예약', completed: true },\n    { id: 2, text: '학교 회의', completed: false },\n  ]);\n  const [text, setText] = useState('');\n  // Function to Add Task\n  function addTask() {\n    const newTask = { id: Date.now(), text, completed: false };\n    setTasks([...tasks, newTask]);\n    setText('');\n  }\n  // Function to Delete Task\n  function deleteTask(id) {\n    setTasks(tasks.filter(task =\u003e task.id !== id));\n  }\n  // Function to Toggle Task Completion\n  function toggleCompleted(id) {\n    setTasks(tasks.map(task =\u003e (task.id === id ? { ...task, completed: !task.completed } : task));\n  }\n  // Render TodoList Component\n  return (\n    \u003cView\u003e\n      {tasks.map(task =\u003e (\n        \u003cTodoItem\n          key={task.id}\n          task={task}\n          deleteTask={deleteTask}\n          toggleCompleted={toggleCompleted}\n        /\u003e\n      ))}\n      \u003cTextInput\n        value={text}\n        onChangeText={setText}\n        placeholder=\"새 작업\"\n      /\u003e\n      \u003cButton title=\"추가\" onPress={addTask} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- 필요한 모듈 가져오기: TodoList 컴포넌트에 필요한 모듈을 가져오는 것부터 시작합니다.\n- TodoList 컴포넌트 정의: 우리는 할 일 목록을 관리하는 중심 컴포넌트인 TodoList 함수형 컴포넌트를 선언합니다.\n- State Hooks: useState 훅을 사용하여 두 가지 상태 변수를 초기화합니다. tasks는 작업 목록을 관리하고, text는 새 작업을 추가하는 데 사용되는 입력 텍스트를 처리합니다. tasks 상태는 초기에 두 가지 예제 작업으로 설정됩니다.\n- 작업 추가 함수: addTask 함수는 고유 ID와 입력 텍스트, 완료 상태가 false로 설정된 새 작업 객체를 생성합니다. 그런 다음 새 작업을 추가하고 입력 텍스트를 재설정하여 tasks 상태를 업데이트합니다.\n- 작업 삭제 함수: deleteTask 함수는 주어진 ID를 가진 작업을 tasks 상태에서 제거합니다.\n- 작업 완료 토글 함수: toggleCompleted 함수는 주어진 ID를 가진 작업의 완료 상태를 토글합니다. map 메서드를 사용하여 대상 작업의 완료 상태가 뒤바뀐 새로운 작업 배열을 생성합니다.\n- TodoList 컴포넌트 렌더링: TodoList 컴포넌트는 map 메서드를 사용하여 작업 목록을 렌더링하며, 각 작업을 TodoItem 컴포넌트에 전달합니다. 또한 새 작업을 입력하는 TextInput과 addTask 함수를 트리거하는 Button을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 TodoList에서 개별 작업을 나타내는 TodoItem 컴포넌트를 생성할 차례입니다.\n\n```js\n// components/TodoItem.js\nimport React from 'react';\nimport { View, Text, CheckBox, Button } from 'react-native';\n\nexport default function TodoItem({ task, deleteTask, toggleCompleted }) {\n  return (\n    \u003cView\u003e\n      \u003cCheckBox\n        value={task.completed}\n        onValueChange={() =\u003e toggleCompleted(task.id)}\n      /\u003e\n      \u003cText style={{ textDecorationLine: task.completed ? 'line-through' : 'none' }}\u003e\n        {task.text}\n      \u003c/Text\u003e\n      \u003cButton title=\"X\" onPress={() =\u003e deleteTask(task.id)} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- CheckBox: CheckBox 컴포넌트는 작업의 완료 상태를 나타냅니다. 그 값은 작업의 완료 상태에 따라 결정되며, onValueChange는 체크박스와 상호작용할 때 toggleCompleted 함수를 호출합니다.\n- 스타일이 적용된 Text: Text 컴포넌트는 작업 텍스트를 표시합니다. 작업이 완료되었을 경우 라인 스타일을 줄 긋게 만드는 스타일이 적용됩니다.\n- 삭제 버튼: Button 컴포넌트는 \"X\" 레이블이 있는 삭제 버튼을 제공합니다. 버튼을 누르면 deleteTask 함수가 호출됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 5: 스타일링\n\n할 일 목록을 시각적으로 더 매력적으로 만들기 위해, 기본적인 스타일을 적용해 보겠습니다. 프로젝트에서 styles.css라는 파일을 생성하고 아래 스타일을 추가해주세요:\n\n```js\n/* styles.css */\n.todo-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center; /* 아이템을 수직으로 중앙 정렬합니다 */\n  margin-bottom: 8px;\n  padding: 8px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n}\n.todo-item-text {\n  flex: 1; /* 텍스트가 남은 공간을 차지할 수 있도록 설정합니다 */\n  margin-right: 8px;\n  color: #333;\n}\n.completed {\n  text-decoration: line-through;\n  color: #888;\n}\n.delete-button {\n  background-color: #ff6347; /* 토마토 색 */\n  color: #fff;\n  padding: 4px 8px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n```\n\n이제, TodoItem.js 파일에서 styles.css를 import하여 로컬에서 스타일을 적용해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// components/TodoItem.js\nimport React from 'react';\nimport { View, Text, CheckBox, TouchableOpacity } from 'react-native';\nimport styles from './styles'; // 스타일 가져오기\n\nexport default function TodoItem({ task, deleteTask, toggleCompleted }) {\n  return (\n    \u003cView style={styles.todo-item}\u003e\n      \u003cCheckBox\n        value={task.completed}\n        onValueChange={() =\u003e toggleCompleted(task.id)}\n      /\u003e\n      \u003cText style={[styles.todo-item-text, task.completed \u0026\u0026 styles.completed]}\u003e\n        {task.text}\n      \u003c/Text\u003e\n      \u003cTouchableOpacity\n        style={styles.delete-button}\n        onPress={() =\u003e deleteTask(task.id)}\n      \u003e\n        \u003cText style={{ color: '#fff' }}\u003e삭제\u003c/Text\u003e\n      \u003c/TouchableOpacity\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- .todo-item : 각 할 일 항목에 플렉스 레이아웃을 적용하고 항목을 가로로 정렬하여 간격을 두고 깔끔한 외관을 위해 패딩, 테두리 및 테두리 반경을 추가합니다.\n- .todo-item-text : 텍스트가 나머지 공간을 차지하도록 하며 오른쪽 여백을 추가하고 텍스트 색상을 변경합니다.\n- .completed : 완료된 작업에 대해 가로 줄 꾸미기 및 텍스트 색상 변경을 추가합니다.\n- .delete-button : 빨간색 배경, 흰색 텍스트, 패딩 및 테두리 반경으로 삭제 버튼을 스타일링합니다. 또한 상호 작용을 위해 커서 포인터를 제공합니다.\n\n여기까지 완료되었습니다! React-Native를 사용하여 직접 Todo List 앱을 만들었다니 축하드립니다. 이 안내서를 통해 React-Native 컴포넌트, 상태 관리, 훅, 프롭스, 이벤트 처리를 이해하고 스타일링을 향상시켰습니다. 이제 당신이 이룬 것을 되돌아보고 다음 단계를 생각해봅시다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마지막으로\n\n할 일 목록 앱을 만드는 것은 단지 React-Native 여행의 일부에 불과해요. 닦은 토대 위에, 어디로 나아갈지 고민할 때입니다. 할 일 편집, 드래그 앤 드롭으로 재정렬, 또는 백엔드 통합에 대해 고려해보세요. 이러한 기능을 추가하여 앱을 더욱 발전시켜보세요.\n\n그리고 여기서 멈추는 것은 왜 그런가요? 도전을 받아들이고, 실시간 채팅과 소셜 기능을 탐험하여 앱을 더욱 상호작용적으로 만들어 보세요. Amity의 채팅 및 소셜 SDK가 제공하는 것을 한 번 살펴보세요. 다음 큰 프로젝트에 빠진 퍼즐 조각이 될 지도 모릅니다. 또한, 채팅, 소셜 및 라이브 스트리밍에 대한 완성된 솔루션이 비즈니스 목표와 일치한다면, 주저하지 말고 Amity에 연락하여 일을 가속화하세요.\n\n코딩과 학습을 계속하면서, 코드 한 줄이 한 걸음을 의미한다는 것을 기억하세요. 따라서 계속 전진하고 새로운 지평을 탐험하며, React-Native 개발의 흥미로운 세계를 받아들이세요. 당신의 코딩 여행에 건배합니다!","ogImage":{"url":"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기","description":"","date":"2024-05-01 18:03","slug":"2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX","content":"\n\nReact JSX는 JavaScript XML의 약자로, 개발자들이 JavaScript 내에서 직접 HTML과 유사한 코드를 작성할 수 있는 강력한 구문 확장 기능입니다. React 개발 세계에서 JSX는 사용자 인터페이스와 컴포넌트를 정의하는 데 중요한 역할을 합니다. JSX를 이해하는 것은 React를 다루는 데 필수적이며, 코드의 가독성과 유지보수성을 크게 향상시킵니다.\n\n이 포괄적인 가이드에서 React JSX에 대한 중요한 내용부터 문법과 사용법, 그리고 JavaScript로 변환하는 방법까지 알아보겠습니다.\n\nJSX는 JavaScript를 위한 구문 확장 기능으로, 개발자들이 JavaScript 파일 내에서 HTML과 유사한 코드를 작성할 수 있도록 합니다. React 애플리케이션에서 UI 컴포넌트를 정의하는 익숙하고 표현적인 방법을 제공합니다. JSX는 별도의 템플릿 언어가 아닌, React 요소를 생성하는 것을 단순화하는 구문적 설탕입니다.\n\nReact에서 JSX를 사용하는 주요 이유 중 하나는 HTML과 유사한 구문을 JavaScript 표현식과 혼합할 수 있는 능력 때문이며, 이를 통해 UI 코드를 이해하고 유지하기 쉽게 만듭니다. JSX를 활용함으로써, 개발자들은 HTML과 유사한 코드를 작성할 수 있으면서 JavaScript와 같은 동작을 수행하도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX 구문은 HTML과 매우 닮아 있어 개발자들이 UI 요소와 컴포넌트를 선언적으로 정의할 수 있습니다. JSX 태그는 HTML 태그와 유사하지만 실제로는 React.createElement()를 호출하는 문법 설탕입니다.\n\n```js\nconst element = \u003ch1\u003eHello, JSX!\u003c/h1\u003e;\n```\n\nJSX는 중괄호 {} 안에 JavaScript 표현식을 포함할 수도 있습니다. 이를 통해 동적 콘텐츠, 변수, 그리고 함수 호출을 JSX 요소 내부에 직접 포함할 수 있습니다.\n\n```js\nconst name = 'John';\nconst element = \u003ch1\u003eHello, {name}!\u003c/h1\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX 표현식을 사용하면 JavaScript 로직을 JSX 요소 안에 직접 삽입할 수 있습니다. 이를 통해 애플리케이션 상태에 따라 동적 콘텐츠 렌더링 및 조건부 렌더링이 가능해집니다.\n\n```js\nconst isLoggedIn = true;\nconst greeting = isLoggedIn ? \u003ch1\u003e다시 오신 것을 환영합니다!\u003c/h1\u003e : \u003ch1\u003e로그인하세요\u003c/h1\u003e;\n```\n\nJSX 표현식에는 변수, 함수, 심지어 복잡한 로직도 포함할 수 있어 React 애플리케이션에서 동적 UI를 구축하는 다재다능한 도구로 활용됩니다.\n\nReact에서 JSX 요소는 UI 컴포넌트의 구성 요소를 나타냅니다. JSX를 사용하면 개발자가 사용자 정의 요소를 생성하고 이를 결합하여 복잡한 인터페이스를 구축할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cHeader /\u003e\n      \u003cMainContent /\u003e\n      \u003cFooter /\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\nJSX 요소는 props 및 children도 받아들일 수 있어서 유연한 컴포넌트 조합과 재사용이 가능합니다.\n\nJSX는 실제로는 Babel과 같은 도구에 의해 일반 JavaScript 코드로 변환됩니다. JSX 요소는 React.createElement() 호출로 컴파일되어 JSX 구문에서 React 엘리먼트를 생성합니다.\n\n```js\nconst element = \u003ch1\u003eHello, JSX!\u003c/h1\u003e;\n// 컴파일 후:\nconst element = React.createElement('h1', null, 'Hello, JSX!');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX가 JavaScript로 변환되는 과정을 이해하는 것은 React 애플리케이션의 디버깅과 최적화에 필수적입니다.\n\nJSX 작업 시에는 최상의 관례를 따르는 것이 중요합니다. 이는 일관된 들여쓰기, JSX 프래그먼트의 올바른 사용, 이벤트 처리의 올바른 방법, 그리고 컴포넌트 내부에서 책임을 분리하는 것을 포함합니다.\n\n```js\nconst Button = ({ onClick, children }) =\u003e {\n  return \u003cbutton onClick={onClick}\u003e{children}\u003c/button\u003e;\n};\n```\n\n최상의 관행을 준수함으로써 개발자는 효율적이고 가독성 있는 JSX 코드를 작성할 수 있으며 유지보수 및 확장이 쉬운 코드를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 JSX는 리액트 애플리케이션에서 UI 개발을 간소화하는 강력한 도구입니다. 문법, 표현식, 요소, 그리고 최상의 방법을 이해함으로써, 개발자들은 손쉽게 견고하고 유지보수가 쉬운 사용자 인터페이스를 구축할 수 있습니다.\n\n이 안내서에서는 리액트 JSX의 기초부터 문법과 사용법, 최상의 방법, 그리고 자바스크립트로 변환하는 것까지 다루었습니다. 이 지식을 바탕으로, 여러분은 리액트 개발을 깊이있게 알아가고 여러분의 프로젝트에서 JSX의 전체 잠재력을 활용할 준비가 되었습니다.\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png"},"coverImage":"/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png","tag":["Tech"],"readingTime":3}],"page":"97","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":19,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"97"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>