<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/14" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/14" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" href="/post/2024-06-22-SetUpandRunaSimpleNodeServerProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">간단한 Nodejs 서버 프로젝트 설정 및 실행 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" href="/post/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Expressjs 프로젝트를 AWS EC2에 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" href="/post/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" href="/post/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Firebase와 Nodejs를 사용한 푸시 알림 설정 방법" href="/post/2024-06-22-PushNotificationusingfirebaseandnode-js"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Firebase와 Nodejs를 사용한 푸시 알림 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Firebase와 Nodejs를 사용한 푸시 알림 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Firebase와 Nodejs를 사용한 푸시 알림 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오늘 배운 것 Nodejs 타이머의 Promise API 사용 방법" href="/post/2024-06-22-TILNodejstimershavepromiseAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오늘 배운 것 Nodejs 타이머의 Promise API 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TILNodejstimershavepromiseAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오늘 배운 것 Nodejs 타이머의 Promise API 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오늘 배운 것 Nodejs 타이머의 Promise API 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PostgreSQL 쿼리를 최적화하는 방법 " href="/post/2024-06-22-HowtoOptimizePostgreSQLQueries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PostgreSQL 쿼리를 최적화하는 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PostgreSQL 쿼리를 최적화하는 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PostgreSQL 쿼리를 최적화하는 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" href="/post/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대학에서도 배울 수 없는 프로그래밍 스킬 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대학에서도 배울 수 없는 프로그래밍 스킬 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Go 언어로 WebSockets 완벽하게 마스터하는 방법" href="/post/2024-06-22-MasteringWebSocketsWithGo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Go 언어로 WebSockets 완벽하게 마스터하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Go 언어로 WebSockets 완벽하게 마스터하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Go 언어로 WebSockets 완벽하게 마스터하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" href="/post/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl"> 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link posts_-active__YVJEi" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"간단한 Nodejs 서버 프로젝트 설정 및 실행 방법","description":"","date":"2024-06-22 14:05","slug":"2024-06-22-SetUpandRunaSimpleNodeServerProject","content":"\n\n컴퓨터 프로그래밍을 거의 3년째 배우고 있는데, 다른 개발자들을 도울 기술적 지식이 생겨났어요. 그래서 내가 잘 알고 있는 내용을 적어놓아 기억에 도움이 되고 다른 사람들에게도 참고할 수 있게 하려고 했어요. 그래서 뭔가를 시작하기로 했고, 간단하게 시작해보려고 하는데요, Node 애플리케이션을 사용하여 요청에 정적 파일로 응답하는 것부터 시작하려고 해요. 실제로는 경험이 많은 개발자들에게는 간단해 보일 수 있지만, 저는 이 부분을 조금 더 자세히 설명해볼 거에요. 왜냐하면 최소한의 웹 개발 지식이 있는 사람도 이 Node 앱을 시작하고 다음으로 진행할 재미있는 것들에 굳은 기초를 쌓을 수 있도록 하고 싶거든요. 물론 모든 것을 설명할 수는 없어서, 알고 싶다면 때로는 더 배울 수 있는 곳으로 보내줄게요.\n\n## Level Up 인재 집단에 합류하세요\n\n이 튜토리얼에서는 Node 서버를 설정하는 단계를 따라가겠어요. 클라이언트의 관점에서 (클라이언트란 서버와 통신하는 사람/컴퓨터입니다), 이 서버는 단 하나의 작업을 수행할 거에요: 단일 정적 HTML 페이지를 표시할 거에요. CSS도 없고, 프론트엔드 JavaScript도 없고, 데이터베이스 연결도 없고, 그리고 필요한 최소한의 NPM 패키지만 사용할 거에요 (NPM이 무엇인지는 곧 설명할게요). 사실, 이를 실제 인터넷에서 실행하지 않고 로컬에서만 실행할 거에요. 그리고 서버 in general이 어떻게 작동하는지, 클라이언트-서버 통신의 메커니즘에 대해 설명을 찾고 있다면, 좀 더 진지한 Node 작업을 하려면 그것에 대해 다루지 않을 거에요.\n\n먼저, 전체 과정을 개략적으로 살펴봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NodeJS 웹사이트로 이동해서 NodeJS를 다운로드하세요.\n- Node와 NPM이 설치되었는지 확인하고 PATH가 정의되어 있는지 확인하세요.\n- 새로운 프로젝트 폴더를 생성하세요.\n- 프로젝트 폴더에서 NPM을 실행하세요 (백그라운드에서 실행됩니다).\n- 필요한 NPM 패키지를 설치하세요.\n- 프로젝트 폴더에 HTML 파일을 생성하세요 (이것이 클라이언트가 볼 내용입니다).\n- 프로젝트 폴더에 Node/JavaScript 파일을 생성하세요 (이것이 서버 파일입니다).\n- 서버를 실행하세요.\n- (로컬) 웹사이트를 방문하세요!\n\n단계 1: NodeJS 웹사이트로 이동해서 NodeJS를 다운로드하세요.\n\n여기에 NodeJS 웹사이트가 있습니다. 이 튜토리얼을 따른다면 LTS(장기 지원) 버전을 다운로드하는 것을 추천드립니다. 이는 대부분의 사람들이 사용하고 안정적인 버전으로 다운로드하는 경우 무언가가 고장났을 때 더 나은 도움을 얻을 수 있습니다. 이 섹션 제목은 기술적으로 그리스도를 이끌었다가와 착각을 일으키는 거라고 합니다. 사실, 여러분은 NodeJS 설치 프로그램을 다운로드한 것이며, 다운로드가 완료되면 해당 프로그램을 열고 지침에 따라 Node를 설치해야 합니다.\n\n단계 2: Node와 NPM이 설치되었는지 확인하고 PATH가 정의되어 있는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS를 다운로드하고 설치했다면, 터미널에서 다음 명령어를 실행하여 Node가 제대로 설치되었는지 확인하고 싶을 것입니다:\n\n```js\nnode -v\n```\n\n이 명령어를 실행하면 다음과 같이 버전 번호가 출력됩니다:\n\n```js\nv14.15.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode를 설치하면 Node Package Manager로도 알려진 NPM이 함께 설치됩니다. 명령 줄에서는 Node보다는 NPM과 더 많이 상호 작용할 가능성이 높습니다. 이 기능에 대해 설명하겠지만, 일단은 NPM이 설치되어 있고 PATH가 올바른지 확인하세요. 이를 확인하려면 노드를 확인한 것과 동일한 작업을 수행하세요:\n\n```js\nnpm -v\n```\n\n위 명령은 다음과 비슷한 숫자를 반환할 것입니다:\n\n```js\n6.14.8\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실, 명령 줄에서 대부분의 프로그램을 확인하는 일반적인 기술입니다. 명령 줄 구문에 너무 깊이 들어가지 않고, 대부분의 프로그램은 -v 플래그를 처리할 수 있으므로 명령 줄에서 상호 작용할 때 거의 항상 다음 형식을 따라 작동하는지 확인할 수 있습니다.\n\n```js\n프로그램명 -v\n```\n\n모든 것이 잘 작동하면 다음 단계에 준비된 것입니다. 만약 다음과 같은 메시지를 받는다면:\n\n```js\n'node'는(은) 내부 또는 외부 명령, 실행할 수 있는 프로그램 또는 배치 파일이 아닙니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 해야 할 일은 9/10 번 이 문제가 발생하는 이유입니다. 가능한한 이 게시물을 짧게 유지하기 위해 문제 해결 방법에 대해 자세히 설명하지는 않겠습니다. 그러나 많은 사람들이 온라인에서 물어본 일반적인 문제입니다. Node와 NPM이 작동하는지 확인한 후 다음 단계로 넘어갈 수 있습니다.\n\n단계 3: 새 프로젝트 폴더 만들기\n\n프로젝트 폴더를 컴퓨터의 원하는 위치에 만들고 원하는 이름을 지을 수 있습니다. 이 단계는 간단합니다. 누구나 새 디렉토리나 폴더를 만드는 방법을 알고 있죠?\n\n단계 4: 프로젝트 폴더에서 NPM 실행 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알겠어요, 그럼 NPM은 무엇인가요? 직접 웹사이트를 방문해서 확인해보세요. 하지만 Node를 배우고 있는 초심자를 위해 간단하게 설명하면, 패키지는 단지 Node 앱과 함께 작동하도록 설계된 프로그램입니다. 웹 앱이 무언가를 수행하거나 몇 가지 로직을 수행하거나 데이터를 조작하거나 다른 서비스와 통신해야 할 때, Node 파일에 직접 모든 코드를 작성하는 대신 패키지를 찾아서 다운로드하고 프로젝트에 추가할 수 있습니다. NPM 패키지를 사용하는 것이 항상 쉽다는 것은 아니라는 것을 의미합니다. 보통 여전히 패키지와 Node 프로젝트 간의 인터페이스를 생성하기 위해 일부 코드를 작성해야 하고 때로 그 코드가 다소 까다로울 수도 있습니다.\n\n프로젝트 폴더에서 NPM을 시작하는 방법은 다음과 같습니다:\n\n- 터미널을 열기\n- 프로젝트 폴더까지 디렉토리를 변경\n- 터미널에서 npm init 명령어를 실행\n\n이 시점에서 다음 정보를 입력하라는 프롬프트가 표시될 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n이 유틸리티는 package.json 파일을 생성하는 과정을 안내해줍니다.\n가장 일반적인 사항만 다루며 합리적인 기본값을 추측합니다.\n이 필드에 대한 확정적인 설명과 각각의 기능에 대한 정확한 문서는 `npm help init`을 확인하세요.\n나중에 `npm install \u003c패키지\u003e`를 사용하여 패키지를 설치하고\n이를 package.json 파일의 종속성으로 저장해주세요.\n```\n\n이후 다음과 같이 표시되어야 합니다:\n\n```js\nPress ^C at any time to quit.\npackage name: (simple-node-server)\n```\n\n패키지 이름: (simple-node-server)\"와 이 설정 과정 중에 나오는 모든 후속 라인은 무엇을 요청하는지를 먼저 말하고 (이 경우 패키지 이름), 오른쪽에는 괄호 안에 값이 있을 수도 있고 비어 있을 수도 있습니다. 괄호 안의 값은 기본값이며, 이러한 각 라인에 대해 기본값을 그대로 사용하거나(비어있는 기본값도 허용됨), 또는 자신의 값을 입력한 후 enter를 누를 수 있습니다. 초보자 대부분은 기본값을 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 설정에 대해 더 알아야 할 사항 하나 더 있어요. 진입점 변수는 대형 프로젝트에서는 보통 여러 서버 파일이 있기 때문에 Node가 앱을 시작할 때 진입점 파일을 사용하지만, 이처럼 간단한 경우에는 하나만 필요해요. Node와 작업을 시작할 때 헷갈렸던 점 중 하나는 주 서버 파일의 다른 이름들이었어요. 가장 흔히 본 것은:\n\n- index.js\n- app.js\n- server.js\n\n주 서버 파일의 이름은 임의로 정할 수 있고, 일부 Node를 사용하는 서비스는 서버 파일이 특정한 이름이어야 하거나 특정 위치에 있어야 하는 경우가 있는데, 이는 이 간단한 서버에 대해 굉장히 중요하지는 않지만 예제를 살펴볼 때 염두에 두어야 할 부분이에요.\n\n작업을 마치면 터미널이 이와 같이 보일 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png)\n\n프로젝트 폴더에 다음과 같이 보이는 package.json이라는 파일이 있어야 합니다:\n\n단계 5: NPM 패키지 설치하기:\n\n이제 NPM이 프로젝트와 연결되었으므로 명령줄을 사용하여 하나의 NPM 패키지를 설치할 것입니다. 이 특정 패키지는 대부분의 Node 서버 프로젝트에서 사용됩니다. Express.js라고 불리며 Node 자체와 밀접한 관계가 있습니다. 실제로 Express에서 제공하는 객체와 메소드를 사용하여 라우팅, 데이터베이스 통합, 오류 처리, 그리고 프론트엔드 템플릿 사용과 같은 일반적인 웹 개발 프로세스를 쉽게 처리할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 루트 프로젝트 폴더에 있는 package.json 파일은 앱에 대한 몇 가지 기본 정보를 담고 있지만, package.json 파일의 가장 일반적인 용도는 다운로드하고 프로젝트에 저장하는 모든 패키지의 레코드를 저장하는 것입니다. 이것은 우리의 프로젝트 코드가 다른 환경에서 실행되기 위해서 (예를 들어 팀과 함께 작업하거나, 오픈 소스 프로젝트를 다른 사람이 자신의 컴퓨터에서 작업할 수 있게 하거나, Amazon Web Services (AWS), Google App Engine (GAE), Heroku 또는 이와 유사한 서비스에 배포하고 싶은 경우) 필요합니다. 다른 환경은 프로젝트에서 사용하는 NPM 패키지를 알아야 하기 때문에 다운로드하고 저장할 수 있어야 합니다. 실제로 package.json이 수행하는 작업은 많지만, 당분간 꼭 알아야 할 것은 프로젝트의 기본 정보와 패키지를 포함한다는 것입니다.\n\n간단히 말해, 패키지를 앱에 연결하는 두 가지 단계가 있습니다:\n\n- NPM에서 패키지 다운로드/설치\n- package.json의 \"Dependencies\"에 패키지 이름과 버전 번호 저장\n\nNPM 패키지를 다운로드하고 프로젝트에 설치하려면, 이 경우 express를 사용할 때, 터미널에서 다음 명령을 실행해야 합니다 (이 명령을 실행할 때 프로젝트의 루트 폴더에 있는지 확인하십시오):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i -s express\n```\n\n- npm은 실행 중인 프로그램 이름입니다.\n- -i는 --install에 대한 약칭이며 둘 중 아무것이나 사용할 수 있습니다. 이 명령을 사용하면 express를 프로젝트 루트 폴더의 node_modules라는 폴더에 추가합니다. NPM으로 처음 패키지를 설치할 때까지 이 폴더가 프로젝트 폴더에 추가되지 않는다는 점을 유의해야 합니다. (그래서 아직 프로젝트 폴더에 보이지 않습니다).\n- -s는 --save에 대한 약칭이며 둘 중 아무것이나 사용할 수 있습니다. npm install 명령에 추가할 수 있는 태그로, 자동으로 package.json에 저장합니다. -s 또는 --save를 잊어버리면 package.json에 패키지 이름과 버전 번호를 수동으로 추가할 수 있습니다. 어떻게든 추가하되, 패키지 이름과 버전 번호가 package.json에 있는지 확인하세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*L-A4jgG4P2bgdYca0guC3w.gif)\n\nStep 6: HTML 파일 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더를 생성한 후에 완료해야 할 두 번째로 간단한 단계가 아닐까 싶어요. 폴더에 확장자 '.html'을 가진 파일을 추가하세요. 일반적으로 기본 html 파일의 이름은 'index.html'로 지정하지만, 이건 절대적인 규칙이 아니기 때문에 자유롭게 이름을 정하셔도 됩니다.\n\n이게 모두요! 이것만 있으면 HTML 파일에 완성된 거죠, 여기서부터 본인이 원하는 형식의 HTML 페이지로 만들어가시면 됩니다:\n\n7단계: 프로젝트 폴더에 Node/JavaScript 파일 만들기\n\n프로젝트의 루트 폴더에 'index.js'라는 파일을 만들어주세요. 그렇습니다, 이제 루트 폴더 안에 'index.html' 파일과 'index.js' 파일이 모두 있게 될 거에요. 헷갈린다면, 조금 익숙해지기까지 조금 걸릴 수 있지만, 실제로는 노드가 서버를 시작하거나 페이지를 렌더링하는 과정에서 문제가 발생했을 때 디버깅에 유용할 수 있어요. 이 규칙은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 프론트엔드 프레임워크들, Handlebars와 같은 템플릿 엔진부터 React와 같은 JavaScript 프레임워크까지, 이를 활용하여 특정 폴더를 살펴 index.js 파일을 해당 디렉토리의 진입점으로 사용합니다.\n\n어쨌든, 서버가 실제로 어떻게 작동하는지 전혀 모른다면, 서버가 하는 가장 기본적인 작업을 간단히 설명해 드리겠습니다:\n\n- 클라이언트로부터 수신되는 요청을 처리하기 위해 포트를 개방합니다.\n- 들어오는 각 요청에 대해 무엇을 해야 하는지 정의합니다 (서버의 응답).\n\n이것이 적절히 요청-응답 주기라고 불리는 것의 가장 간단한 설명이며, 대부분 인터넷이 작동하는 방식입니다. 따라서 우리는 서버를 이렇게 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드/익스프레스 앱에서는 다음과 같이 작업을 수행합니다:\n\n- 방금 설치한 Express 종속성을 가져옵니다.\n- Express 앱 객체의 인스턴스를 생성합니다. 이 앱 객체에는 서버에 사용할 수있는 다양한 내장 메서드와 변수가 있습니다. 그 중 일부를 곧 보게 될 것입니다.\n- 포트 번호를 변수에 저장합니다. 이 앱에서는 선택 사항이지만, 다른 사람들과 함께 앱을 개발하고 앱을 클라우드 기반 서비스에 배포할 때, 앱이 작동하는 환경을 결정하고 적절한 포트를 사용할 수 있도록 몇 가지 로직을 추가하고 싶어할 것입니다.\n- 루트를 설정합니다. 이 경우 하나의 루트를 설정하고 해당 루트의 역할은 앱의 루트(‘/’)에서 요청을 받아들여 클라이언트 브라우저로 HTML 파일을 보내는 것입니다. 다시 말하지만, 규모가 큰 Node 앱을 작업하면 여러 루트가 있고 종종 완전히 분리된 라우터 파일이 있으며, 각각에는 여러 루트가 연결되어 있습니다.\n- 마지막으로 서버를 위한 수신 포트를 설정해야 합니다. 이는 들어오는 연결을 대기하는 역할을 하며, Express 앱에서는 항상 파일의 끝에 있습니다.\n\n그럼, 작업 방법은 다음과 같습니다:\n\n- Node 파일에 종속성을 가져오려면 다음 형식을 따라야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst \u003cvariable-name\u003e = require('\u003cname-of-package\u003e');\n```\n\n여기 몇 가지 빠른 팁이에요:\n\n- `variable-name`은 임의의 이름이에요. 원하는 대로 사용할 수 있어요. 하지만, 이 변수들을 그들의 의존성에 따라 명명하는 것이 최선의 실천 방법이에요.\n- require()는 다른 Node 파일의 코드에 액세스할 수 있게 해주는 내장 Node 함수에요. 이 함수는 Node 서버에 가져오는 모든 의존성에 사용되며, 동일한 방식으로 자신의 Node 파일을 작성하고 주 서버 파일로 가져올 수 있어요.\n- `name-of-package`은 가져오려는 폴더나 파일의 정확한 이름이에요 (JavaScript 파일만 가져올 경우 파일 확장자를 뺄 수 있어요). 가져오는 것이 NPM 패키지인 경우, package.json을 참조할 수 있어요. 왜냐하면 package.json에 나열된 것이 Node 서버 파일에서 필요한 문자열과 동일해야 하거든요. 저희의 package.json에는 의존성이 이렇게 나와 있어요:\n\n```js\n\"dependencies\": {\n   \"express\": \"^4.17.1\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요렇게 table 태그를 Markdown 형식으로 변경해보세요.\n\n1. So, the package.json 파일에는 ‘express’가 있고 require() 함수는 'express' 문자열을 인수로 사용합니다.\n\n2. 다음으로 Express에서 앱 객체 인스턴스를 생성해야 합니다. 앱 객체는 Node.js로 애플리케이션을 만들고 싶다면 꼭 이해해야 할 내용입니다. 우리는 다음과 같이 인스턴스화합니다:\n\n```js\nconst app = express();\n```\n\n- 이 코드의 역할은 바로 위 줄에서 가져온 의존성을 실행하는 것뿐입니다. 그 의존성은 앱 객체를 내보내며 그 앱 객체가 app이라는 상수 변수에 저장됩니다. 이 앱 객체가 Express 코드를 보유하며, 여기서 가장 많은 상호작용을 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이건 쉬워요. 일단 변수 port에 포트 번호를 저장해 보세요. 3000에서 8000 사이의 숫자라면 어떤 숫자든 괜찮아요. 대부분의 사람들은 3000이나 8000을 주로 사용해요.\n\n```js\nconst port = 5000;\n```\n\n4. app 오브젝트에는 HTTP 메소드를 기반으로 요청을 라우팅하는 여러 함수가 포함되어 있어요. 이 함수들 중 가장 일반적인 것들은:\n\n- app.get()\n- app.post()\n- app.put()\n- app.delete()\n- app.use()\n- app.all()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 흔한 함수 중 하나는 app.get()입니다. 이 함수는 GET 요청에 사용되며, 웹사이트에 방문할 때마다 실행됩니다. GET 요청은 인터넷에서 가장 흔한 종류이므로 app.get()를 살펴보겠습니다. Express 문서에서는 다음과 같이 정의하고 있습니다:\n\n그리고 이에 대한 예시를 보여줍니다:\n\n```js\napp.get('/', function (req, res) {\n  res.send('GET request to homepage')\n})\n```\n\n이 정의를 보면 app.get() 함수가 path와 콜백 함수 두 가지 인수를 받을 것으로 예상됩니다. 예시에서는 두 개의 인수가 있는 것을 볼 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `/` = 경로\n- function (req, res) ' res.send(`홈페이지로의 GET 요청`)' = 콜백 함수\n\n이 예제에서는 하나의 콜백 함수만 있지만, 여러 개의 콜백 함수가 있을 수도 있어요. Express에서는 이러한 것들을 미들웨어라고 부르는데, 그 이유는 서버가 클라이언트 요청을 받는 시점과 응답을 다시 보내는 사이에 삽입되기 때문이에요. 게다가, 대규모 Node 프로젝트에서는 미들웨어 함수의 수가 상당히 많아지고, 종종 라우트가 여러 개의 미들웨어 함수를 가지게 되기도 해요. 또한, Node 프로젝트에서 사용할 수 있는 많은 NPM 패키지들이 미들웨어처럼 사용되도록 작성되어 있어요. 사실, Express도 이와 같은 것들뿐이에요:\n\nExpress에서는 많은 미들웨어가 다른 곳에 정의되어 이름과 함께 라우팅 함수로 전달될 수 있지만, 일반적으로 라우팅 함수의 마지막 콜백 함수는 이 예제와 비슷하게 보일 것이며, 이에 대해 아셔야 해요:\n\n- req와 res 두 가지 인수를 가지고 있어요. 이것들은 새로운 요청-응답 주기 동안 다양한 작업을 수행하는 데 도움이 되는 내장 객체들이에요. Express는 이를 미들웨어 함수에서 기대하고 있어요. 현재는 req 객체를 사용하지는 않지만, 앱에 입력이나 URL 인코딩된 데이터 (URL에 서버로 전달되는 데이터)가 있는 경우 req 객체를 통해 해당 정보에 액세스할 수 있어요. res 객체는 서버가 응답을 보낼 때 사용할 객체에요. 중요한 점은 꼭 req와 res로 명명할 필요가 없다는 점이에요. Express는 req와 res 대신 사용하는 이름을 사용할 것이지만, 문서는 모두 req와 res를 참조하고 있고, 대부분의 Node 서버가 이 관례를 따르고 있기 때문에 그대로 따르는 것이 좋을 거예요.\n- 이 함수는 대부분 미들웨어로 간주되는 것들과 약간 다르다는 점에 유의해야 해요. 왜냐하면 대부분의 미들웨어는 Express에게 다음 미들웨어로 계속 진행하라고 말하는 next 인수를 가지고 있는데, 이 함수는 res.sendFile()를 호출하기 때문에 요청-응답 주기의 끝을 의미하고, 서버는 해당 요청을 완료한 상태에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nres.sendFile()에 대해 더 알고 싶다면 문서를 참조해보세요. 하지만 지금 당장 알아두어야 할 점은 다음과 같습니다.\n\n```js\nres.sendFile('\u003cfile-name\u003e', {root: __dirname});\n```\n\n이것이 서버 파일(index.js)이 있는 같은 폴더(루트)에서 파일을 전송하는 방법입니다.\n\n5. 마지막으로, 서버가 들어오는 요청을 수신하기로 약속하려면 코드를 설정해야 합니다. Express의 app 객체에는 이를 수행하는 app.listen()이라는 함수가 있습니다. 모든 매개변수는 옵션으로, 포트 번호를 포함한 것들입니다. 하지만 일반적으로 포트 번호가 적어도 하나 보이며 종종 콜백 함수도 함께 전달됩니다. 제가 앱에서 사용하는 app.listen()의 전체 버전은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\napp.listen(port, () =\u003e {\n    console.log(`Now listening on port ${port}`);\n}); \r\n```\n\n알았어요, 이것을 자세히 살펴보고 마무리하도록 하죠.\n\n- port는 우리 index.js 파일 맨 위에서 정의한 것과 동일한 포트입니다.\n- () =\u003e {}은 화살표 함수로, JavaScript에서 일반 함수와 정확히 동일한 작업을 수행하지만 조금 더 깔끔하게 보입니다.\n- console.log()은 아마 이전에 본 적이 있을 것이라고 기대합니다. 그렇지 않은 경우, 이 줄은 단순히 주어진 문자열을 콘솔에 출력할 것입니다.\n\n총으로, 당신의 index.js 파일은 이렇게 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 8: Node 서버 시작하기\n\n코딩 부분은 여기까지입니다. 다음 단계는 실제로 서버를 시작하는 것입니다! 터미널을 열고 다음 명령을 실행하여 이를 수행할 수 있습니다:\n\n```js\nnode index.js\n```\n\n콘솔에 원하는 포트 번호가 표시된 console.log 메시지가 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Oqa--bT2xy4bNeErxLWxpA.gif)\n\nStep 9: 방문하고자하는 (로컬) 사이트 방문하기!\n\n이제 할 일은 자신의 사이트로 이동하는 것뿐입니다. 귀하의 사이트는 로컬호스트에 호스팅되어 있으며 지정한 포트에서 실행 중입니다. 브라우저를 열고 아래 URL을 사용하세요:\n\n```js\nlocalhost:\u003c포트번호\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지에서 포함한 내용을 얻을 수 있어요! 첫 번째 노드 사이트를 호스팅했군요! \n\n이 튜토리얼은 어떠셨나요? 모든 단계를 따라가고 로컬에서 간단한 HTML 페이지를 실행할 수 있었나요? 혼란스러운 용어가 있었다면 무엇이었나요? 댓글로 알려주세요.\n\n# 코딩 레벨업\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\n- 💰 무료 코딩 면접 코스 ⇒ 코스 보기\n- 🔔 팔로우하기: 트위터 | 링크드인 | 뉴스레터\n\n🚀👉 Level Up 인재 집단에 가입하여 놀라운 직업을 찾아보세요","ogImage":{"url":"/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png"},"coverImage":"/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png","tag":["Tech"],"readingTime":13},{"title":"Expressjs 프로젝트를 AWS EC2에 배포하는 방법","description":"","date":"2024-06-22 14:03","slug":"2024-06-22-HowtodeployExpressjsprojecttoAWSEC2","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png\" /\u003e\n\n# 목차\n\n- AWS EC2 인스턴스 생성 (Linux)\n- SSH 액세스용 키페어 생성\n- 서버 환경 설정\n- 서버 어플리케이션 실행\n\n# 1. AWS EC2 인스턴스 생성 (Linux)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS 콘솔에 로그인하면 상단 바에 검색 상자가 나타납니다. \"ec2\"를 입력하고 EC2 대시보드를 엽니다.\n\n\n![이미지 설명](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_1.png)\n\n\nEC2 대시보드에서 '인스턴스 시작' 패널을 찾아 새 인스턴스를 생성하려면 '인스턴스 시작'을 클릭하세요. 이렇게 하면 아래와 같은 새 페이지가 열릴 것입니다.\n\n\n![이미지 설명](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인스턴스 이름을 입력하고 인스턴스 OS로 \"Amazon Linux\"을 선택하세요.\n\n\"Key pair(login)\" 패널에서 인스턴스용 키페어를 만드세요. 이미 키페어가 있는 경우, 기존 것을 선택하시면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_3.png\" /\u003e\n\n그리고 .pem 파일을 저장하여 EC2 인스턴스에 액세스하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. SSH 액세스를 위한 키페어 생성\n\n이미 Node 프로젝트용 EC2 인스턴스가 있으면이 단계를 건너 뛰세요.\n\nEC2 인스턴스가 있지만 SSH 액세스를 위한 키페어가 없는 경우 \"EC2 Key pair\" 페이지를 만들 수 있습니다.\n\n![EC2 Key pair](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_5.png)\n\n\"Create key pair\"를 클릭하여 .pem 파일을 다운로드할 수 있으며, 이것은 \"Key pairs\" 페이지 표에 나열됩니다.\n\n예를 들어, pem 파일 이름이 ec2-key.pem이고 인스턴스 이름이 ec2-012-345-678.computer-1.amazonaws.com이라고 가정해 봅시다.\n\n이제 터미널에서 EC2 인스턴스에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널을 열고 ec2-key.pem 파일이 있는 디렉토리로 이동해주세요.\n\n```js\n$ ssh -i ec2-key.pem ec2-user@ec2-012-345-678.computer-1.amazonaws.com\n\n\"Amazon Linux\"의 새로운 릴리스가 있습니다.\n  Version 2023.3.20240219:\n  Version 2023.3.20240304:\n  Version 2023.3.20240312:\n  Version 2023.4.20240319:\n  Version 2023.4.20240401:\n  Version 2023.4.20240416:\n  Version 2023.4.20240429:\n  Version 2023.4.20240513:\n  Version 2023.4.20240528:\n  Version 2023.4.20240611:\n전체 릴리스 및 버전 업데이트 정보 확인을 위해 \"/usr/bin/dnf check-release-update\"를 실행하세요.\n   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-\u003e\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\n마지막 로그인: 2024년 6월 20일 목요일 20:21:34, 91.74.112.249부터 로그인했습니다.\n-bash: export: `.bashrc': not a valid identifier\n[ec2-user@EC2_HOSTNAME ~]$\n```\n\n콘솔에 위와 같은 메시지가 나타날 것입니다.\n\n# 3. 서버 환경 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js 서버를 실행하려면 EC2에 Node를 설치해야 합니다.\n\nnvm을 사용하여 Node.js를 설치하세요.\n\nnvm 설치 방법:\n\n```js\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode(20)을 설치하세요:\n\n```js\nnvm install 20\n```\n\n올바르게 설치되었는지 확인하세요:\n\n```js\nnode --version\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 GitHub에 Express 프로젝트가 있다면, git clone 명령어를 사용하여 프로젝트를 EC2로 가져올 수 있습니다.\n\n파일과 디렉토리를 살펴보려면 ls를 사용하세요. 숨겨진 파일과 디렉토리를 모두 볼 때는 ls -a를 사용하세요. 그리고 마침표(.)로 시작하는 모든 파일과 디렉토리를 볼 수 있습니다.\n\n만약 GitHub 프로젝트가 없다면 지금은 괜찮습니다.\n\nnode-app이라는 폴더를 만들기 위해 mkdir node-app를 사용하세요. Node.js 프로젝트를 만들기 위해 npm init -y를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\ncd mkdir\nnpm init -y\n```\n\n그런 다음 이 간단한 Express.js 애플리케이션 코드를 붙혀넣어주세요.\n\n```js\nnpm install express\n\nnano app.js\n```\n\n이 코드를 app.js에 복사해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express');\n\n// express의 인스턴스 생성\nconst app = express();\n\n// 루트 URL (\"/\")에 대한 라우트 정의\napp.get('/', (req, res) =\u003e {\n    res.send('Hello World!');\n});\n\n// 포트 3000에서 서버 시작\nconst port = 3000;\napp.listen(port, () =\u003e {\n    console.log(`서버가 http://localhost:${port}에서 실행 중입니다.`);\n});\n```\n\n이제 간단한 hello-world Node 서버 애플리케이션이 준비되었습니다.\n\n`node app` 명령을 실행하면 콘솔에 '서버가 http://localhost:3000에서 실행 중입니다.' 메시지가 표시됩니다.\n\n브라우저를 열고 다음 URL을 입력하여 확인해보세요: `http://ec2-012-345-678.computer-1.amazonaws.com:3000`. 브라우저에 'Hello World!'가 표시될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 거의 완료하셨네요!\n\n보이지 않으신가요? 제게 알려주세요.\n\n# 4. 서버 애플리케이션 실행\n\n터미널을 닫으면 서버 애플리케이션이 종료됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 애플리케이션을 실행하려면 pm2 모듈을 사용할 수 있어요.\n\npm2 모듈을 전역으로 설치하고 프로젝트 폴더에서 pm2 start app을 실행하세요.\n\npm2에 대한 자세한 정보는 pm2 공식 웹사이트에서 확인할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png"},"coverImage":"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png","tag":["Tech"],"readingTime":5},{"title":"NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은","description":"","date":"2024-06-22 14:01","slug":"2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads","content":"\n\n\n![Image](/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png)\n\n만약 Frontend 또는 Full Stack 개발자라면, 아마도 NPM, YARN, PNPM 중 하나 이상을 사용해 보았을 것입니다. 이들은 프로젝트의 의존성을 관리하는데 도움이 되는 도구인데요, 라이브러리, 프레임워크, 유틸리티와 같은 것들을 관리할 수 있습니다.\n\n각 패키지 매니저에 대해 간단히 소개해 보겠습니다.\n\n# NPM\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNPM은 Node Package Manager의 약자입니다. JavaScript를 위한 기본이자 가장 인기 있는 패키지 매니저입니다. 2009년 Isaac Schlueter에 의해 만들어졌으며 Node.js 프로젝트에서 코드를 공유하고 재사용하는 방법으로 시작되었습니다. 그 이후로, 약 200만 개가 넘는 패키지로 구성된 거대한 저장소로 성장했습니다. 이 패키지는 프론트엔드와 백엔드 개발에 사용할 수 있습니다.\n\nNPM은 간단하고 직관적인 명령줄 인터페이스를 제공하여 패키지를 설치, 업데이트, 제거 및 게시할 수 있습니다. 또한 npmjs.com이라는 웹사이트도 있어 패키지를 탐색, 검색 및 다운로드할 수 있습니다. NPM은 프로젝트의 메타데이터(이름, 버전, 의존성, 스크립트 등)을 저장하는 package.json이라는 파일을 사용합니다. 또한 설치된 패키지를 저장하는 node_modules라는 폴더를 생성합니다.\n\n## 장점\n\n- JavaScript 커뮤니티에서 널리 사용되며 지원되고 있습니다.\n- 거의 모든 사용 사례에 대한 다양하고 방대한 패키지 컬렉션이 있습니다.\n- 프로젝트를 사용자 정의하는 데 유용한 다양한 기능과 옵션이 있습니다.\n- 종속성에서 취약점을 확인하는 내장된 보안 감사 도구가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단점\n\n- 패키지를 설치하거나 업데이트할 때 느리고 비효율적일 수 있습니다.\n- 중복된 또는 중첩된 종속성을 만들어 디스크 공간을 차지하고 충돌을 일으킬 수 있습니다.\n- 다른 환경 간에 패키지 버전이 일관되지 않거나 오래된 경우가 있을 수 있습니다.\n\n# YARN\n\nYARN은 Yet Another Resource Negotiator의 약자입니다. 이는 2016년 페이스북, 구글, 익스포넌트, Tilde에 의해 만들어진 JavaScript의 대체 패키지 매니저입니다. 이는 NPM의 속도, 신뢰성 및 보안과 같은 몇 가지 문제와 한계를 해결하기 위해 설계되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYARN은 NPM과 유사한 명령줄 인터페이스를 가지고 있지만 일부 차이점과 개선 사항이 있습니다. 그리고 NPM과 동일한 package.json 파일을 사용하지만 종속성의 정확한 버전을 잠그는 yarn.lock이라는 추가 파일이 있습니다. 또한 설치된 패키지를 저장하는 node_modules 폴더를 생성합니다.\n\n## 장점\n\n- 패키지를 설치하거나 업데이트할 때 NPM보다 빠르고 효율적입니다\n- 중복이나 패키지의 중첩을 피하는 평면적인 종속성 구조를 사용합니다\n- 로컬 캐시에서 패키지를 오프라인으로 설치할 수 있습니다\n- 일관된 및 결정적인 버전의 패키지를 다른 환경에서 보장하는 더 나은 해결 알고리즘을 제공합니다\n\n## 단점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JavaScript 커뮤니티에서 NPM만큼 널리 사용되거나 지원되는 것은 아닙니다.\n- 일부 NPM 패키지나 기능과 호환되지 않을 수 있습니다.\n- 아직 수정되지 않거나 해결되지 않은 버그나 문제가 있을 수 있습니다.\n\n# PNPM\n\nPNPM은 Performant Node Package Manager의 약자입니다. 2016년 Zoltan Kochan에 의해 만들어진 JavaScript용 대체 패키지 관리자입니다. NPM과 YARN보다 빠르고 가벼우며 더 안전하도록 설계되었습니다.\n\nPNPM은 NPM과 YARN과 유사한 명령줄 인터페이스를 가지고 있지만 일부 차이점과 개선점이 있습니다. 또한 NPM과 YARN과 동일한 package.json 파일을 사용하지만 의존성의 정확한 버전을 잠그는 pnpm-lock.yaml이라는 파일을 추가합니다. 또한 설치된 패키지를 저장하는 node_modules 폴더를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- 패키지 설치 또는 업데이트 시 NPM 및 YARN보다 빠르고 가벼움\n- 글로벌 저장소에서 하드 링크 또는 심볼릭 링크를 사용하여 패키지를 node_modules 폴더에 복사하는 대신 연결함\n- 패키지가 package.json 파일에 선언되지 않은 모듈에 액세스하는 것을 방지하는 엄격한 의존성 격리를 지원\n- 종속성 내의 취약점을 확인하는 내장된 보안 감사 도구를 제공\n\n## 단점\n\n- 자바스크립트 커뮤니티에서 NPM 또는 YARN만큼 널리 사용되거나 지원되지 않음\n- 일부 NPM 또는 YARN 패키지 또는 기능과 호환되지 않을 수 있음\n- 아직 수정되지 않거나 해결되지 않은 버그나 문제가 있을 수 있음\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비교\n\n## 요약\n\n## 성능\n\n패키지 관리자의 가장 중요한 측면 중 하나는 프로젝트의 종속성을 빠르게 설치하고 업데이트하는 데 얼마나 빠른지입니다. 이는 개발 워크플로우 및 배포 프로세스에 영향을 줄 수 있습니다. NPM, YARN 및 PNPM의 성능을 측정하기 위해 약 1000개의 종속성이 포함된 샘플 프로젝트를 사용하여 벤치마크를 실행했습니다. 여기에 결과가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPNPM이 가장 빠른 패키지 매니저인 것을 보실 수 있습니다. 그 다음으로 YARN, 그리고 NPM이 따릅니다. PNPM은 \"symlinked node_modules\"라는 혁신적인 접근 방식을 사용하여 각 프로젝트로 패키지를 복사하는 대신 전역 저장소에 대한 하드 링크를 생성합니다. 이렇게 하면 디스크 공간을 절약하고 중복을 줄일 수 있습니다. YARN도 전역 캐시를 사용하지만 여전히 각 프로젝트로 패키지를 복사합니다. NPM은 캐싱 메커니즘을 사용하지 않기 때문에 매 번 패키지를 다운로드하고 설치합니다.\n\n## 특징\n\n패키지 매니저의 또 다른 측면은 개발자로서 더 쉽게 일할 수 있도록 어떤 기능을 제공하느냐입니다. 제가 중요하게 생각하는 기능 중 일부는 다음과 같습니다:\n\n- Workspaces: 이 기능을 통해 단일 저장소 내에서 여러 하위 프로젝트를 관리하고 서로 의존성을 공유할 수 있습니다. 서로 의존하는 여러 패키지가 있는 monorepo 아키텍처에 유용합니다.\n- Lockfiles: 이 기능은 레지스트리나 package.json 파일의 변경과 무관하게 매번 정확한 버전의 종속성이 설치되도록 보장합니다. 빌드의 재현성과 신뢰성을 향상시킵니다.\n- Scripts: 이 기능을 사용하면 종속성을 설치하거나 업데이트하기 전이나 후에 컴파일, 테스트 또는 코드 린팅과 같은 사용자 지정 명령을 실행할 수 있습니다.\n- Hooks: 이 기능을 통해 패키지 매니저의 라이프사이클의 특정 이벤트 중에 사용자 지정 로직을 실행할 수 있습니다. 종속성을 해결하거나 가져오거나 링크 또는 감사하는 경우가 여기에 해당합니다.\n- Audit: 이 기능을 사용하면 종속성을 알려진 취약점이나 문제점을 확인하고 해결 방법에 대한 권장 사항을 받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자 모두 워크스페이스, 락파일, 스크립트 및 감사 기능을 지원합니다. 그러나 YARN과 PNPM만 후크를 지원하는데, 이를 통해 의존성 관리 프로세스를 유연하고 효율적으로 제어할 수 있습니다. 반면에 NPM과 YARN만 감사 기능을 지원하는데, 이를 통해 코드의 보안성과 품질을 향상시킬 수 있습니다.\n\n## 호환성\n\n패키지 관리자의 또 다른 측면은 프로젝트에서 사용할 수 있는 다른 도구 및 플랫폼과 얼마나 호환성이 있는지입니다. 호환성에 영향을 미치는 몇 가지 요소는 다음과 같습니다:\n\n- 레지스트리: 이는 패키지 관리자가 의존성을 설치하고 업데이트하는 데 사용하는 패키지의 원본입니다. 가장 일반적인 레지스트리는 npmjs.com인데, 이는 JavaScript 및 Node.js용으로 2백만 개 이상의 패키지를 호스팅합니다. 그러나 다른 목적으로 사용할 수 있는 개인 또는 범위가 지정된 패키지와 같은 다른 레지스트리도 있을 수 있습니다.\n- CLI: 이는 패키지 관리자가 상호 작용할 수 있도록 제공하는 명령줄 인터페이스입니다. 가장 일반적인 CLI는 Node.js와 함께 제공되는 npm-cli인데, 그러나 별도로 설치할 수 있도록 제공되는 standalone 도구인 yarn-cli나 일부 추가 기능을 추가하는 npm-cli 래퍼인 pnpm-cli와 같은 다른 CLI도 있을 수 있습니다.\n- 생태계: 이는 패키지 관리자가 통합하거나 지원하는 도구 및 플랫폼 세트입니다. 웹팩, 바벨, eslint, 모카, 익스프레스 또는 AWS와 같은 도구들을 포함하는 Node.js 생태계가 가장 보편적인데, 그러나 browserify, rollup, typescript, prettier, jest, react, 또는 firebase와 같은 도구를 포함하는 브라우저 생태계와 같이 다른 목적으로 사용할 수 있는 다른 생태계도 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자는 동일한 레지스트리와 생태계와 호환됩니다. 그러나 각각이 제공하는 다른 CLI를 통해 서로 다른 명령어와 옵션을 제공합니다. 예를 들어, YARN에는 작업 공간을 더 쉽게 관리할 수 있도록 해주는 \"yarn workspaces\"라는 명령어가 있습니다. PNPM에는 여러 하위 프로젝트에서 명령어를 한 번에 실행할 수 있도록 하는 \"pnpm recursive\"라는 명령어가 있습니다.\n\n## 보안\n\n비교할 패키지 관리자의 한 가지 더 중요한 측면은 얼마나 안전한지입니다. 보안은 종속성이 악의적인 코드나 취약점을 포함할 수 있어 프로젝트나 사용자를 위협할 수 있기 때문에 중요합니다. 패키지 관리자가 보안을 향상시키기 위해 취할 수 있는 조치 중 일부는 다음과 같습니다:\n\n- 확인: 이는 설치하거나 업데이트할 패키지의 무결성과 신뢰성을 확인하는 과정입니다. 이를 통해 변조나 위조 공격을 예방할 수 있으며, 패키지를 악의적인 것으로 대체하거나 변경하는 것을 방지할 수 있습니다.\n- 격리: 이는 설치하거나 업데이트하는 패키지의 액세스 및 권한을 제한하는 과정입니다. 이를 통해 특권 상승이나 코드 삽입 공격을 방지하여 시스템이나 사용자의 시스템에서 악의적인 코드가 실행되는 것을 방지할 수 있습니다.\n- 해결: 이는 설치하거나 업데이트하는 패키지의 최상의 버전을 선택하는 과정입니다. 이를 통해 종속성 지옥이나 충돌 문제를 방지하여 프로젝트가 손상되거나 예기치 않게 동작하는 것을 방지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자는 모두 패키지의 무결성과 신뢰성을 보장하기 위한 형태의 확인을 사용합니다. 그러나 PNPM은 YARN(SHA-1)보다 더 강력한 알고리즘(SHA-512)을 사용하여 충돌 및 무차별 공격에 더 저항력을 가집니다. NPM과 YARN은 PNPM과 동일한 알고리즘(SHA-512)을 사용합니다.\n\n그러나 PNPM만이 패키지의 액세스 및 권한을 제한하기 위해 격리를 사용합니다. 이를 위해 각 패키지마다 별도의 node_modules 폴더를 생성하고 심볼릭 링크를 사용하여 이들을 함께 연결합니다. 이렇게 함으로써 패키지가 명시적인 허가 없이 다른 패키지의 파일 또는 모듈에 액세스하거나 수정하는 것을 방지합니다. NPM과 YARN은 격리 메커니즘을 사용하지 않기 때문에 패키지가 node_modules 폴더 내의 모든 파일 또는 모듈에 액세스하거나 수정할 수 있습니다.\n\n더불어, PNPM만이 엄격한 해상도를 사용하여 최상의 버전을 선택합니다. 이를 위해 package.json 파일에서 지정된 정확한 버전을 따르고 평평한 종속성 트리를 생성합니다. 이렇게 함으로써 중복되거나 호환되지 않는 버전의 패키지가 설치되거나 업데이트되는 것을 방지합니다. NPM과 YARN은 범위 또는 수정자에 따라 버전을 선택하는 semver 해상도를 사용하며 이로 인해 중복되거나 호환되지 않는 버전의 패키지가 설치되거나 업데이트 될 수 있습니다.\n\n# 최적의 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트 요구 사항, 기호 및 제약 사항에 가장 적합한 패키지 관리자를 선택해보세요. 일반 해결책은 없으며, 각 패키지 관리자는 각자의 장단점을 가지고 있습니다. 필요하다면 다른 패키지 관리자로 전환할 수도 있습니다. 그러나 다른 패키지 관리자로 설치하기 전에 기존 node_modules 폴더와 lockfile을 삭제해야 합니다.\n- 서로 다른 기기 및 환경에서 재현 가능한 설치를 보장하기 위해 로크 파일을 사용하세요. 로크 파일은 프로젝트가 의존하는 패키지의 정확한 버전과 출처를 기록한 파일로, 매번 일관되게 설치할 수 있도록 도와줍니다. NPM은 package-lock.json 파일을 사용하고, Yarn은 yarn.lock 파일을 사용하며, PNPM은 pnpm-lock.yaml 파일을 사용합니다. 이 파일들을 버전 관리 시스템에 커밋하고 패키지를 추가, 제거 또는 업데이트할 때마다 업데이트해야 합니다.\n- 패키지 관리자의 동작과 설정을 구성하기 위해 .npmrc 파일을 사용하세요. .npmrc 파일은 패키지 관리자의 구성 옵션인 레지스트리 URL, 프록시 설정, 캐시 위치 등의 키-값 쌍을 포함하는 파일입니다. 이 파일을 프로젝트의 루트 디렉토리나 홈 디렉토리에 생성하여 구성을 전역적으로 또는 로컬적으로 적용할 수 있습니다. 또한 환경 변수나 명령줄 플래그를 사용하여 구성 옵션을 재정의할 수도 있습니다.\n- 패키지 관리자와 자주 사용하는 작업 및 워크플로우를 자동화하기 위해 스크립트를 사용하세요. 스크립트는 \"scripts\" 속성 아래에 정의된 커맨드로, \"start\", \"test\", \"build\" 등과 같은 명령이 포함됩니다. 그런 다음 패키지 관리자의 CLI를 통해 이러한 스크립트를 실행할 수 있습니다. 예를 들어 npm run start, yarn start 또는 pnpm start와 같이 실행할 수 있습니다. 또한 pre- 및 post- 훅을 사용하여 다른 스크립트 전 또는 후에 스크립트를 실행할 수도 있습니다. 예를 들어 pretest 또는 postbuild와 같이 실행할 수 있습니다.\n- 하나의 저장소 내에서 여러 프로젝트 또는 패키지를 관리하기 위해 워크스페이스를 사용하세요. 워크스페이스는 자체의 package.json 파일과 종속성을 포함하는 폴더로, 공통 node_modules 폴더와 root 수준의 lockfile을 공유합니다. 이렇게 하면 중복을 피하고 프로젝트 또는 패키지 간의 종속성 관리를 간소화할 수 있습니다. NPM은 버전 7부터 워크스페이스를 지원하고, Yarn은 버전 1부터 워크스페이스를 지원하며, PNPM은 버전 2부터 워크스페이스를 지원합니다.\n\n# 결론\n\n각 패키지 관리자에는 각자의 장단점이 있습니다.\n\nNPM은 널리 사용되며 쉽지만 Yarn과 PNPM보다 느립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n야드는 NPM보다 더 빠르고 멋진 새로운 기능을 갖추고 있지만, NPM과 동일한 평평해진 node_modules 디렉토리를 사용합니다.\n\nPNPM은 가장 빠르고 가장 디스크 공간을 효율적으로 사용하는 패키지 매니저지만, 일부 패키지와의 호환성 문제가 있을 수 있습니다.\n\n프로젝트 요구사항에 가장 잘 맞는 패키지 매니저를 선택해보세요.","ogImage":{"url":"/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png"},"coverImage":"/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png","tag":["Tech"],"readingTime":8},{"title":"확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법","description":"","date":"2024-06-22 14:00","slug":"2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects","content":"\n\n요즘에는 마이크로서비스 아키텍처가 확장 가능하고 유지보수가 용이하며 유연한 애플리케이션을 개발할 수 있는 능력 때문에 상당한 인기를 얻고 있습니다. Nest.js는 점진적인 Node.js 프레임워크로, 마이크로서비스를 구축하기에 적합합니다. 본 문서에서는 Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계하고 구현하는 방법을 살펴볼 것입니다. 마이크로서비스를 구축하는 데 필요한 주요 개념, 장점 및 최선의 방법, 그리고 구현을 설명하는 실용적인 코드 예제를 포함하고 있습니다.\n\n![마이크로서비스 아키텍처 구축](/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png)\n\n## 목차\n\n- 마이크로서비스 소개\n- 마이크로서비스 아키텍처의 장점\n- Nest.js 프레임워크 이해\n- 마이크로서비스 아키텍처 설계\n  - 서비스 검색 및 레지스트리\n  - 부하 분산과 게이트웨이\n  - 데이터 저장 및 지속성\n  - 마이크로서비스 간 통신\n  - 오류 처리와 회복\n- Nest.js로 마이크로서비스 구현\n- Docker를 사용한 마이크로서비스 구축\n- 클라우드에 마이크로서비스 배포\n- 마이크로서비스 모니터링 및 확장\n- 마이크로서비스 테스트 및 디버깅\n- 마이크로서비스 개발을 위한 최선의 방법\n- 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 마이크로서비스 소개\n\n마이크로서비스는 응용 프로그램을 작은, 독립적이며 느슨하게 결합된 서비스 집합으로 나누는 아키텍처 스타일입니다. 각 마이크로서비스는 특정 업무 기능을 수행하며 다른 서비스와 API를 통해 통신합니다. 이 모듈식 접근법을 통해 팀은 각 서비스를 개발, 배포 및 확장할 수 있어 더 큰 유연성과 더 빠른 개발 주기를 제공합니다.\n\n# 2. 마이크로서비스 아키텍처의 장점\n\n마이크로서비스 아키텍처는 다음과 같은 여러 가지 장점을 제공합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 확장성: 각 마이크로서비스는 독립적으로 확장 가능하여 고효율로 대량 처리를 처리할 수 있습니다.\n- 유지보수성: 서비스들은 전체 애플리케이션에 영향을 주지 않고 독립적으로 유지보수 및 업데이트할 수 있습니다.\n- 유연성: 팀은 각 서비스의 요구 사항에 따라 다른 기술을 선택할 수 있습니다.\n- 오류 격리: 한 서비스가 실패해도 전체 시스템에 영향을 미치지 않아 높은 가용성을 보장합니다.\n- 빠른 개발: 작고 집중된 팀은 특정 서비스에 독립적으로 작업하여 개발 속도를 높일 수 있습니다.\n- 지속적인 배포: 서비스는 다른 구성 요소에 영향을 미치지 않고 개별적으로 배포할 수 있습니다.\n\n# 3. Nest.js 프레임워크 이해\n\nNest.js는 효율적이고 확장 가능하며 유지보수가 용이한 서버 측 애플리케이션을 구축하기 위해 설계된 강력한 Node.js 프레임워크입니다. API 생성, 의존성 주입 및 모듈화 아키텍처를 작성하는 데 내장 지원을 제공합니다. Nest.js는 Express.js 위에 구축되었으며 TypeScript를 활용하여 강한 타입 지정 및 향상된 생산성을 가능하게 합니다.\n\n# 4. 마이크로서비스 아키텍처 설계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 구현에 들어가기 전에, Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계해 봅시다.\n\n## 서비스 검색 및 레지스트리\n\n마이크로서비스 아키텍처에서는 서비스들이 서로를 발견하고 통신해야 합니다. Consul이나 Eureka와 같은 서비스 레지스트리를 사용하여 마이크로서비스를 등록하고 찾을 수 있습니다.\n\n## 부하 분산 및 게이트웨이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 인스턴스의 서비스 간에 오는 요청을 균등하게 분산시키기 위해 로드 밸런서가 필요합니다. 게이트웨이는 클라이언트의 입구 역할을 하고 요청을 적절한 마이크로서비스로 라우팅합니다.\n\n## 데이터 저장 및 지속성\n\n각 마이크로서비스는 독립적인 데이터 관리를 유지하기 위해 자체 데이터베이스나 데이터 저장소를 가져야 합니다.\n\n## 마이크로서비스 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마이크로서비스는 RabbitMQ나 Kafka와 같은 RESTful API 또는 메시지 큐를 통해 통신합니다.\n\n## 오류 처리와 내구성\n\n시스템이 실패에서 우아하게 복구할 수 있도록 견고한 오류 처리 및 내구성 패턴을 구현하세요.\n\n# 5. Nest.js로 마이크로서비스 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 우리의 디자인을 실행하여 Nest.js를 사용하여 마이크로서비스를 구현해 봅시다.\n\n단계 1: 새로운 Nest.js 프로젝트 생성\n시작하려면 Nest.js CLI를 설치하고 새 프로젝트를 만듭니다:\n\n```js\nnpm install -g @nestjs/cli\nnest new microservices-project\ncd microservices-project\n```\n\n단계 2: 종속성 설치\n다음으로, 마이크로서비스를 위해 필요한 종속성을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nnpm install @nestjs/microservices @nestjs/typeorm typeorm mysql\r\n\n\r\nStep 3: Create Microservice Modules\r\n각각의 마이크로서비스를 위한 별도의 모듈을 만듭니다:\r\n\r\n```typescript\r\n// app.module.ts (Gateway)\r\nimport { Module } from '@nestjs/common';\r\nimport { AppController } from './app.controller';\r\nimport { AppService } from './app.service';\r\nimport { ClientsModule, Transport } from '@nestjs/microservices';\r\n\r\n@Module({\r\n  imports: [\r\n    ClientsModule.register([\r\n      {\r\n        name: 'SERVICE_A',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3001,\r\n        },\r\n      },\r\n      {\r\n        name: 'SERVICE_B',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3002,\r\n        },\r\n      },\r\n    ]),\r\n  ],\r\n  controllers: [AppController],\r\n  providers: [AppService],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n```typescript\r\n// service-a.module.ts\r\nimport { Module } from '@nestjs/common';\r\nimport { ServiceAController } from './service-a.controller';\r\nimport { ServiceAService } from './service-a.service';\r\n\r\n@Module({\r\n  controllers: [ServiceAController],\r\n  providers: [ServiceAService],\r\n})\r\nexport class ServiceAModule {}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\n// service-b.module.ts\nimport { Module } from '@nestjs/common';\nimport { ServiceBController } from './service-b.controller';\nimport { ServiceBService } from './service-b.service';\n\n@Module({\n  controllers: [ServiceBController],\n  providers: [ServiceBService],\n})\nexport class ServiceBModule {}\n```\n\nStep 4: 각 Microservice를 위한 Controllers 및 Services 구현\n각 Microservice에 대한 controllers 및 services를 생성하십시오:\n\n```typescript\n// app.controller.ts (Gateway)\nimport { Controller, Get, Inject } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { ClientProxy } from '@nestjs/microservices';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService, @Inject('SERVICE_A') private readonly clientA: ClientProxy, @Inject('SERVICE_B') private readonly clientB: ClientProxy) {}\n\n  @Get()\n  async getHello(): Promise\u003cstring\u003e {\n    const resultA = await this.clientA.send('getHello', '').toPromise();\n    const resultB = await this.clientB.send('getHello', '').toPromise();\n    return this.appService.getHello(resultA, resultB);\n  }\n}\n```\n\n```typescript\n// service-a.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceAService } from './service-a.service';\n\n@Controller()\nexport class ServiceAController {\n  constructor(private readonly serviceAService: ServiceAService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceAService.getHello();\n  }\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// service-b.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceBService } from './service-b.service';\n\n@Controller()\nexport class ServiceBController {\n  constructor(private readonly serviceBService: ServiceBService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceBService.getHello();\n  }\n}\n```\n\nStep 5: 서비스 로직 구현\n각 마이크로서비스에 대한 비즈니스 로직을 추가하십시오:\n\n```js\n// app.service.ts (게이트웨이)\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(serviceA: string, serviceB: string): string {\n    return `서비스 A가 말합니다: ${serviceA}, 서비스 B가 말합니다: ${serviceB}`;\n  }\n}\n```\n\n```js\n// service-a.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceAService {\n  getHello(): string {\n    return '서비스 A에서 안녕하세요';\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// service-b.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceBService {\n  getHello(): string {\n    return 'Hello from Service B';\n  }\n}\n```\n\n# 결론\n\n축하합니다! Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 성공적으로 구축했습니다. 마이크로서비스는 확장성, 유지보수성 및 장애 분리와 같은 여러 가지 이점을 제공합니다. 응용 프로그램을 더 작고 독립적인 서비스로 나누면 매우 유연하고 견고한 시스템을 구축할 수 있습니다. 마이크로서비스 개발을 위한 최상의 방법론을 따르는 것이 중요합니다. 서비스 검색, 부하 분산 및 적절한 오류 처리를 구현하는 것과 같은 것들을 잊지마세요.\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png","tag":["Tech"],"readingTime":7},{"title":"Firebase와 Nodejs를 사용한 푸시 알림 설정 방법","description":"","date":"2024-06-22 13:59","slug":"2024-06-22-PushNotificationusingfirebaseandnode-js","content":"\n\n## 이 설명서는 Firebase Admin SDK를 사용하여 Node.js 애플리케이션에 Firebase Cloud Messaging (FCM) 푸시 알림을 구현하는 단계별 가이드를 제공합니다.\n\nFirebase 푸시 알림을 찾느라 지쳤다면, 여기에서 간단하게 구현하는 방법을 설명했습니다! (딥 링킹 포함!)\n\n# 준비 사항:-\n\n시작하기 전에 다음 사항을 준비해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Firebase 콘솔 (https://console.firebase.google.com)에서 생성된 Firebase 프로젝트.\n- 개발 컴퓨터에 Node.js가 설치되어 있어야 합니다 (https://nodejs.org).\n\n# 단계 1: 종속 항목 설치\n\nNode.js 애플리케이션에서 푸시 알림을 보내려면 Firebase Admin SDK가 필요합니다.\n\n다음 명령어를 사용하여 설치하세요: \"npm install firebase-admin\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: Firebase Admin SDK 설정하기\n\n- Firebase 콘솔로 이동하여 프로젝트를 선택하고 프로젝트 설정으로 이동합니다.\n- \"서비스 계정\" 탭에서 \"새 개인 키 생성\"을 클릭합니다. 이렇게 하면 서비스 계정 자격 증명이 포함된 JSON 파일이 다운로드됩니다. 이 파일을 안전하게 보관하세요.\n- Node.js 애플리케이션에서 다운로드한 서비스 계정 키를 사용하여 Firebase Admin SDK를 초기화합니다:\n\n![이미지1](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_0.png)\n\n![이미지2](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림 유형:-\n\n![push notification using firebase and node-js](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_2.png)\n\n알림 카테고리:-\n\n![push notification using firebase and node-js](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이어베이스 클라우드 메시징(FCM)에서는 Firebase Cloud Messaging 토큰(일반적으로 \"등록 토큰\"으로 불리는)이 중요한 역할을 합니다. 이 토큰은 특정 기기 또는 사용자와 관련된 고유 식별자로, 애플리케이션에서 푸시 알림을 올바른 수신자에게 라우팅하는 데 사용됩니다. 아래에서 이 역할과 어디서 토큰을 얻을 수 있는지 살펴보겠습니다:\n\nFirebase Cloud Messaging 토큰의 역할:\n\n- 기기 식별: FCM에 의해 모바일 애플리케이션을 실행하는 각 기기에 고유한 등록 토큰이 할당됩니다. 이 토큰은 FCM 인프라 내에서 기기를 식별합니다.\n- 수신자 주소: 특정 기기나 사용자에게 푸시 알림을 보내고 싶을 때, 해당 등록 토큰을 사용하여 주소로 설정합니다. 이를 통해 알림이 의도한 수신자에게 도달할 수 있습니다.\n- 구독 관리: 등록 토큰을 사용하여 특정 주제나 그룹에 대한 기기를 구독하거나 구독 취소할 수 있습니다. 이를 통해 특정 관심사나 특성을 가진 기기 그룹에 알림을 보낼 수 있습니다.\n\nFirebase Cloud Messaging 토큰을 얻는 곳:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase Cloud Messaging 토큰은 일반적으로 클라이언트 측(즉, 모바일 앱 내)에서 얻어지고, 이후 서버로 전송되어 저장 및 메시지 라우팅에 사용됩니다. 아래는 토큰을 얻는 방법입니다:\n\n프론트엔드 Android 팀에서 디바이스 Firebase 토큰을 제공하므로 해당 토큰을 데이터베이스의 사용자 컬렉션에 저장해야 합니다.\n\n이제 사용자의 Firebase 토큰을 가져와야 합니다:\n\n![이미지](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 meta-Data Replacer 라는 폴더를 만들었어요. 거기에 사용자 정의 메시지를 설정하고 해당 기능을 호출하고 사용자 정의 동적 메시지를 설정할 수 있어요.\n\n비즈니스 로직:-\n\n![image 1](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_5.png)\n\n![image 2](/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n축하합니다! Node.js 애플리케이션에 Firebase 푸시 알림을 성공적으로 구현하셨습니다. 이제 이 지식을 활용하여 애플리케이션 내에서 다양한 트리거와 이벤트에 기반한 사용자에게 알림을 보낼 수 있습니다. 더 많은 고급 기능 및 사용자 정의를 원하신다면 Firebase 문서 (https://firebase.google.com/docs/cloud-messaging)를 참고해보세요.","ogImage":{"url":"/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_0.png"},"coverImage":"/assets/img/2024-06-22-PushNotificationusingfirebaseandnode-js_0.png","tag":["Tech"],"readingTime":3},{"title":"오늘 배운 것 Nodejs 타이머의 Promise API 사용 방법","description":"","date":"2024-06-22 13:58","slug":"2024-06-22-TILNodejstimershavepromiseAPI","content":"\n\n안녕하세요! 코드 개발자 여러분!\n\n혹시 자바스크립트/타입스크립트를 사용하여 기능을 코딩하면서 \"오 이 코드에 2초의 인위적인 지연을 추가해야겠네\"라고 깨달은 적이 있나요? 그럴 땐 아래와 같이 코드를 작성해야겠지요:\n\n```js\n// 처음에 프로미스가 아닌 것을 프로미스화하기\nawait new Promise\u003cvoid\u003e((resolve, reject) =\u003e {\n  setTimeout(() =\u003e {\n    resolve()\n  }, 2_000)\n})\n```\n\n저는 저런 경우를 참 많이 겪었어요. 특히 직장에서 코드를 작성할 때죠. 때로는 그런 게 간단하지 않다는 건 거니까요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드.js는 setTimeout, setInterval 및 setImmediate 같은 모든 타이머에 대한 프로미스 API를 이미 제공했으므로 기뻐해야 합니다.\n\n그냥 timers/promises에서 해당 set 함수를 가져와서 사용할 수 있습니다.\n\n```js\n// 프로미스를 사용한 정확히 2초의 지연\nimport { setTimeout } from 'timers/promises'\n\nawait setTimeout(2_000, 'success')\n```\n\n그리고 두 번째 인자로 전달한 값으로 2초 후에 프로미스가 해결됩니다. 멋지죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘 새로운 것을 배우셨으면 좋겣습니다.\n\n즐거운 학습 되세요.\n\n안녕히 가세요~","ogImage":{"url":"/assets/img/2024-06-22-TILNodejstimershavepromiseAPI_0.png"},"coverImage":"/assets/img/2024-06-22-TILNodejstimershavepromiseAPI_0.png","tag":["Tech"],"readingTime":1},{"title":"PostgreSQL 쿼리를 최적화하는 방법 ","description":"","date":"2024-06-22 13:57","slug":"2024-06-22-HowtoOptimizePostgreSQLQueries","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png\" /\u003e\n\nPostgreSQL은 강력하고 높은 사용자 정의 가능성을 가진 오픈 소스 관계형 데이터베이스 관리 시스템입니다. PostgreSQL은 높은 효율성을 갖도록 설계되었지만, 쿼리 성능을 최적화하여 개선할 수 있습니다. PostgreSQL 쿼리를 최적화하는 몇 가지 팁은 다음과 같습니다:\n\n## 1. 인덱스 사용\n\n이메일로 사용자를 자주 검색하는 경우, “users”라는 테이블이 있고 “id”, “name”, “email” 열이 있다고 가정해보겠습니다. 이 경우 “email” 열에 인덱스를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nCREATE INDEX users_email_idx ON users (email);\n```\n\n## 2. Use EXPLAIN\n\nSuppose you have a query that joins two tables and returns the total number of rows:\n\n```js\nEXPLAIN SELECT COUNT(*) FROM table1 JOIN table2 ON table1.id = table2.table1_id;\n```  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEXPLAIN 명령은 쿼리의 실행 계획을 출력하여 성능 문제를 식별하는 데 도움이 됩니다.\n\n## 3. 와일드카드 문자 사용을 피하세요\n\n예를 들어 email 주소가 \"@example.com\"으로 끝나는 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\n\n```js\nSELECT * FROM users WHERE email LIKE '%@example.com';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 \"users\" 테이블 전체를 순차적으로 스캔하여 실행되며, 테이블이 크다면 느릴 수 있습니다. 이 쿼리를 최적화하려면 다음과 같이 다시 작성할 수 있습니다:\n\n```js\nSELECT * FROM users WHERE email LIKE '@example.com%';\n```\n\n이 쿼리는 1단계에서 생성된 인덱스를 사용하고 훨씬 더 빠른 인덱스 스캔을 수행할 것입니다.\n\n## 4. 반환된 행의 수 제한:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"users\" 테이블에서 모든 사용자를 반환하는 쿼리가 있다고 가정해보세요:\n\n```js\nSELECT * FROM users;\n```\n\n이 쿼리는 테이블이 큰 경우 느리고 자원을 많이 사용할 수 있습니다. 이 쿼리를 최적화하려면 LIMIT 절을 사용하여 반환되는 행 수를 제한할 수 있습니다:\n\n```js\nSELECT * FROM users LIMIT 100;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 성능을 향상시킬 수 있도록 처음 100개의 행만 반환합니다.\n\n## 5. 적절한 데이터 유형 사용:\n\n만일 \"users\" 테이블에 사용자의 나이를 정수로 저장하는 \"age\"라는 열이 있다고 가정해보겠습니다. 사용자의 평균 연령을 자주 계산한다면 \"integer\" 대신 \"smallint\"와 같은 더 작은 데이터 유형을 사용하여 성능을 최적화할 수 있습니다:\n\n```js\nALTER TABLE users ALTER COLUMN age TYPE smallint;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경하면 메모리 사용량을 줄일 수 있어 성능을 향상시킬 수 있어요.\n\n## 6. 서브쿼리 최적화\n\n특정 도시에 거주하는 고객에 대한 모든 주문을 검색하는 쿼리가 있다고 가정해보세요:\n\n```js\nSELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE city = '뉴욕');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 뉴욕에 거주하는 고객들의 고객 ID를 검색하기 위해 서브쿼리를 사용합니다. 이 쿼리를 최적화하기 위해 JOIN으로 다시 작성할 수 있습니다:\n\n```js\nSELECT orders.* FROM orders JOIN customers ON orders.customer_id = customers.id WHERE customers.city = 'New York';\n```\n\n이 쿼리는 서브쿼리 대신 JOIN을 수행하며, \"orders\" 테이블에 많은 행이 있는 경우 더 빠를 수 있습니다.\n\n## 7. 준비된 문을 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 이름을 가진 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\n\n```js\nSELECT * FROM users WHERE name = 'John';\n```\n\n여러 번 다른 이름으로 이 쿼리를 실행한다면, 준비된 문을 사용하여 성능을 개선할 수 있습니다:\n\n```js\nPREPARE get_users_by_name (text) AS SELECT * FROM users WHERE name = $1;\nEXECUTE get_users_by_name('John');\nEXECUTE get_users_by_name('Jane');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 각 후속 실행에 대해 쿼리를 준비하고 실행 계획을 재사용할 수 있어 성능을 향상시킬 수 있습니다.\n\n제가 언급한 옵션을 사용하여 PostgreSQL 쿼리를 최적화하는 방법을 명확하게 설명하는 데 도움이 되기를 바랍니다!\n\n## 8. 연결 풀 사용\n\n연결 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커넥션 풀링은 각 데이터베이스 요청마다 새로운 연결을 생성하고 해제하는 대신 데이터베이스 연결 풀을 관리하는 기술입니다. 기존 연결을 재사용함으로써 커넥션 풀링은 새로운 연결을 맺는 데 필요한 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\n\n다음은 PostgreSQL에서 커넥션 풀링을 사용하는 예시입니다:\n\n- 커넥션 풀링 라이브러리 설치: PostgreSQL용 여러 커넥션 풀링 라이브러리가 있습니다. pgBouncer, pgpool-II, 그리고 Pgpool 등이 있습니다. 요구 사항에 가장 적합한 라이브러리를 선택하고 서버에 설치합니다.\n- 커넥션 풀 구성: 데이터베이스에 대한 최대 연결 수와 최대 휴대 중인 연결 수를 지정하도록 커넥션 풀을 구성합니다. 또한 일정 시간 후 휴대 중인 연결을 자동으로 닫도록 풀을 구성할 수도 있습니다.\n- 응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 각 데이터베이스 요청마다 새로운 연결을 생성하는 대신에 커넥션 풀을 사용하도록 수정합니다. 선택한 커넥션 풀 라이브러리에 따라 연결 문자열이나 데이터베이스 URL을 수정해야 할 수도 있습니다.\n\n다음은 pgBouncer를 사용한 커넥션 풀링 사용 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- pgBouncer 설치: 패키지 관리자를 사용하거나 소스에서 컴파일하여 서버에 pgBouncer를 설치합니다.\n- 연결 풀 구성: pgBouncer 구성 파일을 편집하여 데이터베이스에 대한 연결 최대 수와 최대 휴식 연결 수를 지정합니다. 또한 일정 시간이 지난 후 자동으로 휴식 연결을 닫도록 pgBouncer를 구성할 수 있습니다.\n- 응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 기본 PostgreSQL 연결 문자열 대신 pgBouncer 연결 문자열을 사용하도록 합니다. 다음은 PostgreSQL 연결 문자열의 예시입니다:\n\n```js\npostgres://username:password@hostname:port/database\n```\n\n다음은 pgBouncer 연결 문자열의 예시입니다:\n\n```js\npostgres://username:password@hostname:6432/database\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포트 번호가 다르고 호스트 이름이 PostgreSQL 서버가 아닌 pgBouncer 서버를 가리키는 것을 유의해 주세요.\n\npgBouncer와 같은 커넥션 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\n\n## 9. 테이블 분석 및 VACUUM\n\n분석과 VACUUM은 데이터베이스 통계를 업데이트하고 디스크 공간을 회수하여 PostgreSQL 쿼리의 성능을 향상시킬 수 있는 두 가지 중요한 유지 관리 작업입니다. 각 작업에 대한 간단한 설명은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 분석: 테이블에 인덱스를 생성하거나 데이터를 필터링하거나 정렬하는 쿼리를 실행할 때, PostgreSQL은 통계를 사용하여 조건과 일치하는 행 수를 추정합니다. 데이터베이스 통계에는 데이터의 분포에 대한 정보가 포함되어 있습니다. 즉, 고유한 값의 수 및 각 값의 빈도가 포함됩니다. 이러한 통계는 pg_statistic이라는 시스템 카탈로그에 저장됩니다. 통계가 오래되거나 부정확할 경우, 쿼리 플래너가 잘못된 결정을 내리고 효율적이지 않은 쿼리 계획을 생성할 수 있습니다.\n\n통계를 업데이트하려면 테이블이나 전체 데이터베이스에 ANALYZE 명령을 실행할 수 있습니다. ANALYZE는 테이블을 스캔하고 pg_statistic에서 통계를 업데이트합니다. 대규모 테이블의 경우, 이 작업은 상당한 시간이 소요될 수 있지만, 이는 일회성 비용이며 혜택이 상당할 수 있습니다.\n\n- 박강작업: 테이블에 행을 삽입, 업데이트 또는 삭제할 때, PostgreSQL은 이전 행이 사용한 디스크 공간을 즉시 해제하지 않습니다. 대신, 해당 공간을 재사용 가능하다고 표시하고 새 행이 그 공간을 채울 때까지 기다립니다. 이를 \"불필요한\" 공간이라고 하며 시간이 지남에 따라 축적되어 단편화와 성능 저하로 이어질 수 있습니다. 박강작업은 불필요한 공간을 회수하여 운영 체제가 다시 사용할 수 있도록 하는 과정입니다.\n\nPostgreSQL에서 테이블을 박강하는 여러 옵션이 있습니다. 가장 간단한 옵션은 VACUUM 명령을 실행하는 것으로, 전체 테이블을 스캔하고 불필요한 공간을 제거합니다. 다른 옵션은 VACUUM ANALYZE 명령을 실행하는 것으로, 분석과 박강 작업의 혜택을 결합한 명령입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 PostgreSQL에서 테이블을 분석하고 VACUUM하는 방법을 알아볼게요:\n\n```js\n-- 테이블 분석하기\nANALYZE mytable;\n\n-- 테이블 VACUUM하기\nVACUUM mytable;\n```\n\n정기적으로 테이블을 분석하고 VACUUM하면 데이터베이스 통계가 최신 상태를 유지하고 디스크 공간을 효율적으로 사용할 수 있어요. 이는 PostgreSQL 쿼리의 성능을 향상시키고 더 나은 쿼리 계획을 생성하며 데이터를 읽고 쓰기 위해 필요한 디스크 I/O 양을 줄이는 데 도움이 될 수 있어요.\n\n이 글에 대한 궁금한 점이나 피드백이 있으면 언제든지 댓글을 남겨주세요.\n읽어주셔서 감사합니다. 함께 NodeTeam에 참여해보세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png","tag":["Tech"],"readingTime":6},{"title":"대학에서도 배울 수 없는 프로그래밍 스킬 5가지","description":"","date":"2024-06-22 13:56","slug":"2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou","content":"\n\n## 일\n\n![이미지](/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png)\n\n- 작은 코너나 집에서 코딩하는 것은 매우 교육적이지만, 회사에서 코딩하는 것과는 많이 다릅니다. 둘 중 하나로 다른 것을 대체할 수 없어요.\n- 테스트되지 않은 것은 미리 정해지지 않았다고 볼 수 있어요. 시간을 낭비하지 않기 위해 코드를 자동으로 테스트해야합니다(단위 테스트, 통합 테스트, 성능 테스트, 트래픽 재현, 안정성 테스트 등).\n- PR/코드 리뷰, 빌드 자동화 및 실행 테스트는 품질을 향상시키는 데 많은 도움이 됩니다. 재구성을 할 때 자신감을 주죠.\n- 운영 환경에서 모니터링 및 경보는 꼭 필요합니다. 코드가 오류와 비정상 케이스를 감지하고 오류를 보고하여 이러한 오류가 알람을 생성하여 문제가 감지되고 수정되도록 해야 합니다(가능하면 고객의 불만이 제기되기 전에).\n- 학교, 책, 자습서에서 배우는 코딩 방식은 실제 프로젝트에서 사용하는 방식과 다릅니다. 배우는 과정은 주로 hello world나 조금 더 복잡한 내용에 중점을 두는데, 실제 문제는 큰 규모의 코드에서 프레임워크, 방법론 등이 팀으로서 작성/수정/유지되는 방식입니다.\n- 새로운 프레임워크나 기술은 주로 좋은 hello world와 자습서 이외의 본질적인 것은 제공하지 않을 수 있습니다. 주요 기술적인 변화가 정기적으로 있을지라도, 제공되는 것 중 95%는 시간을 낭비하는 것일수도 있습니다. 적합한 것, 게임 체인저, 부가적인 것을 구분하는 방법을 배워야 합니다.\n- Google, StackOverflow 등이 여러분의 친구입니다. 멈춰있지 마세요. 해결책이 있더라도, 더 나은, 더 짧고, 더 표준적이며, 더 읽기 쉬운 것을 찾아보세요. 여러분이 작성한 이 작은 함수는 이미 어떤 라이브러리에 있을 것입니다. 바퀴를 다시 발명하지 마세요. 연습이나 단지 연습을 위해 사용하기보다는 이미 작성되고 디버깅되어 테스트된 표준 코드를 사용하는 것이 더 좋을 겁니다. 사용자 정의 코드 작성은 마지막 수단이어야 하며, 작성된 코드는 실로 명료하고 간결해야 합니다.\n- 인터넷 곳곳에서 코딩에 관한 질문 한 번도 한 적이 없어요. 그러나 많은 질문에 답변했답니다. 99.99%의 경우 여러분이 묻는 질문은 이미 1000번 이상 물린 질문이고 이미 훌륭한 답변이 있습니다. 물어본 질문에 대한 답을 기다리기보다는 누군가 이미 해결책을 갖고 있는지 알아보거나 직접 찾아보세요. 99.99%의 경우 일이 잘 풀리죠.\n- 코드는 종종 수정되고 더 자주 읽힙니다. 매우 읽기 쉽고 의외가 없어야 합니다. 작친 꼼수, 지나치게 똑똑하거나 너무 많은 가정을 하는 코드는 리뷰어가 버그를 수정해야 하는데 리뷰어가 혼란스러워하게 만들 것입니다.\n- 좋은 IDE는 코드를 쉽게 이동하게 해주며, 리팩토링을 수행하고, 잠재적인 버그를 강조하며, 단위 테스트를 실행하고 디버깅을 쉽게 할 수 있도록 도와줍니다. print/cout 라인을 추가하여 디버깅하지 마세요, 수정한 메서드 호출 50회를 하나씩 수정하지 마세요. 그보다 나은 방법이 있답니다. 진정한 IDE를 사용하는 방법을 배워보세요.\n- 여러분이 작성하는 코드는 여러분의 코드가 아닙니다. 수정/리펙토링/개발을 하는 모든 사람에게 속합니다. 마찬가지로, 코드를 여러분의 취향에 맞게 수정해선 안됩니다.\n- 두 종류의 코드가 있습니다: 잘 지정된, 새로운, 비싼 코드는 작동하지 않을 수 있지만 오래되거나, 해독하기 어렵거나, 심지어 테스트되지 않은 코드들은 작동합니다. 여기서 나는 고객의 문제를 해결하는 것이 기본적인 알고리즘/디자인을 구현하는 것이 아닌 일을 한다는 의미입니다. 보통 디자인을 혼란스럽게 만들고 코드를 읽기 어렵게하는 모든 세부, 특별한 경우 및 예외사항을 다루는 작업입니다. 그렇지만 그것이 필요하고 그것이 비용이 많이 들죠. 텍스트 편집기를 인턴이 만들게 한다면 그게 됩니다. 모든 사용자의 모든 기능을 지원하고 모든 형식과 작업하는 워드를 만든다면 그것은 수십억 유로가 드는 일입니다.\n- 작성된 모든 코드, 심지어 테스트 및 완벽히 디자인된 코드도 부채입니다. 소프트웨어의 복잡성은 코드의 크기에 지수적으로 증가합니다. 각 기능을 개발하고 유지하는 데 비용이 들죠, 사용되지 않아도. 불필요한 코드는 작성하지 말고, 더 이상 필요하지 않은 기능을 제거하고 가능한 한 최소한의 코드를 작성하세요. 그 페어는 구현하는 기능이 드는 비용보다 훨씬 많이 가져오는 것을 확실하게 하세요.\n- 디자인, 선택 사항, 문서 등은 대부분 디자이너의 머리 속에 있습니다. 이 정보는 흔히 완벽하게 전달되지 않습니다. 팀이 완전히 새롭게 구성되면, 신입사원들은 기존 소프트웨어의 디자인과 논리를 제대로 이해하지 못할 수 있고 다르게 작업할 수 있습니다. 이것을 너무 빨리, 너무 자주(프로젝트에서 누가 코딩하는지 변경하는 것) 한 경우에는 너무 많은 다른 시각을 축적하여 여러분의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스택데믹 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 추천하고 팔로우해 주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Differ\n- 스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png"},"coverImage":"/assets/img/2024-06-22-ProgrammingSkillsThatAnyUniversityCantTeachYou_0.png","tag":["Tech"],"readingTime":3},{"title":"Go 언어로 WebSockets 완벽하게 마스터하는 방법","description":"","date":"2024-06-22 13:52","slug":"2024-06-22-MasteringWebSocketsWithGo","content":"\n![웹 소켓 사용 방법](/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png)\n\n생각해보면, 일반적인 HTTP API는 정말 어리석습니다. 데이터를 가져오려면 해당 데이터에 대한 요청을 보내야 합니다. 웹 사이트의 데이터를 신선하게 유지해야 한다면 데이터를 계속 요청해야 하는 폴링이라는 방법을 사용해야 합니다.\n\n이는 목적지에 도착했는지를 물어보는 자리에서 운전자가 \"우리가 이미 도착했어\"라고 말해주는 대신 뒷자리에 앉은 아이가 계속 \"도착했니?\"라고 물어보는 것과 같습니다. 이것이 웹사이트를 디자인할 때 사용하기 시작한 방식입니다. 참 어리석죠?\n\n다행히도, 개발자들은 웹 소켓, WebRTC, gRPC, HTTP2 스트림, Server-Sent 이벤트 및 기타 양방향 통신과 같은 기술로 이를 해결했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹소켓은 상호 양방향 통신의 가장 오래된 방법 중 하나이며 현재 널리 사용되고 있습니다. 대부분의 브라우저에서 지원되며 비교적 쉽게 사용할 수 있습니다.\n\n이 튜토리얼에서는 웹소켓이 무엇이며 어떻게 작동하는지, 서버와 클라이언트 간에 통신하는 데 Go에서 사용하는 방법에 대해 다룰 것입니다. 또한 웹소켓 API에서 본 적이 있는 몇 가지 일반적인 함정을 탐구하고 이를 해결하는 방법도 살펴볼 것입니다.\n\n이 튜토리얼에서는 다양한 채팅방에 참여할 수 있는 채팅 애플리케이션을 구축할 것입니다. 웹소켓 서버는 Go를 사용하여 구축되며 클라이언트는 순수 JavaScript를 사용하여 연결할 것입니다. 배운 패턴은 Go, Java, React 또는 다른 언어로 작성된 웹소켓 클라이언트를 사용할 때 쉽게 적용할 수 있습니다.\n\n이 기사는 또한 녹화되어 내 YouTube 채널에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹소켓이 뭔지, 그리고 왜 중요한지 알아보세요\n\n![웹소켓](/assets/img/2024-06-22-MasteringWebSocketsWithGo_1.png)\n\n웹소켓 표준은 RFC 645에서 정의되어 있습니다.\n\n웹소켓은 서버로 초기 요청을 보내기 위해 HTTP를 사용합니다. 이것은 일반적인 HTTP 요청이지만, Connection: Upgrade라는 특별한 HTTP 헤더가 포함되어 있습니다. 이를 통해 클라이언트가 HTTP 요청의 TCP 연결을 장기적인 웹 소켓으로 업그레이드하려고 한다는 것을 서버에 알립니다. 서버가 HTTP 101 Switching Protocols로 응답하면 연결이 유지되어 클라이언트와 서버가 메시지를 상호간에 전이 가능하고 풀듀플렉스로 보낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 이 연결이 합의되면, 우리는 양쪽에서 데이터를 송수신할 수 있습니다. 웹소켓에 대해 이해해야 할 것은 더 이상 없습니다.\n\n설치 중에 무슨 일이 벌어지는지 더 자세히 알고 싶다면, RFC를 추천드릴게요.\n\n실시간 솔루션이 필요한지 궁금할 수도 있습니다. 그래서 다음은 웹소켓이 자주 사용되는 몇 가지 분야입니다.\n\n- 채팅 애플리케이션 — 다른 클라이언트에게 메시지를 받아 전달해야 하는 애플리케이션들은 웹소켓에 완벽히 어울립니다.\n- 게임 — 멀티플레이어를 갖고 있고 웹 기반의 게임을 개발한다면, 웹소켓은 정말 완벽한 매치입니다. 클라이언트로부터 데이터를 푸시하고 다른 플레이어들에게 브로드캐스트할 수 있습니다.\n- 피드 — 데이터 피드가 필요한 애플리케이션의 경우, 업데이트된 데이터를 손쉽게 모든 클라이언트로 푸시할 수 있습니다.\n- 실시간 데이터 — 실시간 데이터가 필요한 경우, 웹소켓은 탁월한 솔루션입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 애플리케이션의 기초를 설치하기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_2.png)\n\n간단한 HTTP 서버를 설정하여 파일 서버를 통해 웹 애플리케이션을 호스팅하는 방법으로 시작하겠습니다. React와 같은 웹 프레임워크를 사용하지 않도록 하려고 합니다. 대신 네이티브 JavaScript를 사용해 보겠습니다. 보통 WebSocket에 연결하는 단계는 매우 유사하기 때문에 사용 중인 프레임워크와의 연결에 문제가 없어야 합니다.\n\n새 모듈을 초기화하는 것부터 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngo mod init programmingpercy.tech/websockets-go\n```\n\n그런 다음 application의 시작점이 될 새로운 파일 main.go를 만듭니다.\n\n먼저 application을 API를 서비스하고 HTML/JS 코드를 호스팅하도록 설정합니다. 그 이후에는 WebSocket 구현을 시작하여 따라가기 쉽도록 합니다.\n\n이제 우리가 곧 구축할 웹사이트를 호스팅하기 위한 간단한 코드를 main.go에 작성해 봅시다. 우리는 곧 만들고 내용을 저장할 frontend 디렉토리만 서비스할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 프론트 엔드를 추가해 보겠습니다. 저희의 멋진 채팅 애플리케이션을 보여주기 위해 간단한 원시 HTML/JS/CSS 파일을 만들겠습니다. 사용자들이 특정 채팅방에 입력할 수 있는 채팅방 선택 양식과 메시지를 WebSocket을 통해 보낼 수 있는 두 번째 채팅방 메시지 양식으로 구성되어 있습니다.\n\n이것은 단지 간단한 HTML과 JavaScript이지만, 아직 WebSocket 구현은 되어 있지 않습니다. 말하기 괜찮은 유일한 것은 클라이언트 브라우저가 WebSocket을 지원하는지 확인할 수 있는 글로벌인 window[\"WebSocket\"]입니다. 이 값이 정의되지 않은 경우 사용자에게 그들의 브라우저가 지원되지 않는다는 경고 메시지를 보여줄 것입니다.\n\nfrontend이라는 폴더와 index.html이라는 파일을 만들어 주세요. 그런 다음 다음의 Gist로 index.html을 채워주세요. HTML과 JS 부분은 다루지 않겠습니다. 당신이 익숙하다고 가정할게요.\n\n터미널에서 go run main.go를 실행하고 localhost:8080을 방문하면 WebSocket을 구현하기 시작할 모든 것이 갖춰진 멋진 웹사이트로 환영받을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_3.png\" /\u003e\n\n지금은 메시지를 보내거나 채팅방을 변경해도 콘솔에만 출력되지만, 이제 구현할 것입니다.\n\n## 클라이언트 및 서버 사이의 WebSocket 연결\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 위해 프론트엔드에 추가하여 웹소켓 API에 연결하도록 설정하겠습니다. JavaScript로는 간단하게 한 줄의 코드로 처리할 수 있어요.\n\nJavaScript에는 가져올 필요 없이 사용할 수 있는 내장 웹소켓 라이브러리가 있어요. 우리는 new WebSocket(URL)을 사용하여 클라이언트를 생성할 수 있는데 먼저 URL을 만들어야 해요. URL은 프로토콜과 함께 일반적인 HTTP URL처럼 구성되어 있고, 그 뒤에 경로가 따라옵니다. 일반적으로 웹소켓은 /ws 엔드포인트에 배치하는 것이 표준입니다.\n\n웹소켓을 사용할 때 두 가지 프로토콜이 있는데, ws와 wss가 있어요. 이것은 HTTP와 HTTPS처럼 작동하는데요, 여기에서의 S는 보안을 나타내며 트래픽에 SSL 암호화를 적용합니다.\n\n이를 사용하는 것이 매우 추천되지만 인증서가 필요합니다. 이 부분은 나중에 적용할 예정이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwindows.onload 함수에 ws://localhost/ws에 연결하는 라인을 추가해보세요.\n\n지금까지 코드를 다시 실행해보고, 웹 사이트를 방문하면 아직 연결할 수 없다는 오류가 콘솔에 출력되는 것을 볼 수 있을 겁니다. 이는 단순히 백엔드가 아직 연결을 허용하지 않기 때문입니다.\n\n이제 백엔드 코드를 업데이트하여 WebSocket 연결을 허용해봅시다.\n\n먼저, 연결을 처리하고 일반 HTTP 요청을 WebSocket 연결로 업그레이드하는 Manager를 구축하겠습니다. 또한, Manager는 모든 클라이언트를 추적하는 역할도 담당할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹소켓 연결을 처리하기 위해 Gorilla WebSocket 라이브러리를 사용할 것입니다. 이는 HTTP 요청을 취해 TCP 연결을 업그레이드하는 Upgrader를 생성하여 수행됩니다. Upgrader에 버퍼 크기를 할당할 것이며, 이는 모든 새로운 클라이언트에 적용될 것입니다.\n\n매니저는 /ws 엔드포인트에 호스팅할 serveWS라는 일반 HTTP HandlerFunc를 노출할 것입니다. 이 시점에서 연결을 업그레이드하고 간단히 다시 닫을 것이지만, 이렇게 연결할 수 있는지 확인할 수 있습니다.\n\nmanager.go라는 파일을 생성하고 코드를 gist에서 가져와서 채워 넣을 것입니다.\n\n또한, /ws 엔드포인트에 serveWS를 추가하여 프론트엔드가 연결할 수 있게 할 것입니다. main.go의 setupAPI 함수 내에서 새로운 매니저를 생성하고 HTTP 핸들러를 추가할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 다음 명령어를 사용하여 소프트웨어를 실행할 수 있어요.\n\n```js\ngo run *.go\n```\n\n웹사이트를 방문하여 계속 진행하시면 콘솔에 더 이상 오류가 출력되지 않고 연결이 수락된 것을 확인할 수 있을 거예요.\n\n## 클라이언트 및 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringWebSocketsWithGo_5.png\" /\u003e\n\n모든 클라이언트 로직을 serveWS 함수에 추가할 수도 있지만, 그렇게 되면 매우 커질 수 있습니다. 클라이언트를 처리하는 데 사용되는 Client 구조체를 만드는 것을 추천합니다. 이 구조체는 클라이언트 관련 모든 로직을 담당하며 Manager에 의해 관리됩니다.\n\n또한 클라이언트는 메시지를 동시에 안전하게 읽고 쓸 수 있어야 합니다. Go의 WebSocket 연결은 동시에 하나의 작성기만 허용하므로 버퍼가없는 채널을 사용하여 처리할 수 있습니다. 이 기술은 Gorilla 라이브러리 개발자들이 권장하는 기술입니다.\n\n메시지를 구현하기 전에 Client 구조체를 생성하고 Manager에 클라이언트를 추가하거나 삭제할 수 있는 기능을 부여해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 지금 client.go라는 새 파일을 만들었어요. 일단은 작고 고객과 관련된 로직을 담을 거에요.\n\nClientList라는 새로운 타입을 만들 건데, 이건 간단히 클라이언트를 조회하는 데 사용할 수 있는 맵이에요. 그리고 각 클라이언트가 매니저를 참조하도록 하고 싶어요. 이렇게 하면 클라이언트에서도 상태를 쉽게 관리할 수 있거든.\n\n이제 매니저를 업데이트해서 새로 만든 ClientList를 보관하게 할 차례에요. 여러 사람이 동시에 연결할 수 있기 때문에 매니저도 sync.RWMutex를 구현해야 해요. 그래야 클라이언트 추가 전에 잠글 수 있어요.\n\n또, NewManager 함수를 업데이트해서 ClientList를 초기화할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 serveWS를 업데이트하여 새로운 클라이언트를 연결과 함께 생성하고 매니저에 추가할 것입니다.\n\n또한 클라이언트를 삽입하는 addClient 함수와 삭제하는 removeClient 함수로 매니저를 업데이트할 것입니다. 삭제 작업은 연결을 정상적으로 종료하도록 보장합니다.\n\n새 클라이언트를 수락하고 추가할 준비가 되어있습니다. 아직 클라이언트를 제대로 제거할 수는 없지만 곧 할 수 있을 것입니다.\n\n클라이언트가 메시지를 읽고 쓸 수 있는 기능을 구현해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메시지 읽기 및 쓰기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_6.png)\n\n메시지 읽기 및 쓰기는 쉬운 작업처럼 보일 수 있지만, 실제로는 그렇습니다. 그러나 많은 사람들이 놓치는 작은 함정이 있습니다. WebSocket 연결은 하나의 동시 라이터만 허용됩니다. 이 문제를 해결하기 위해 버퍼가 없는 채널을 잠금 장치로 활용할 수 있습니다.\n\n우리는 manager.go 내의 serveWS 함수를 업데이트하여 클라이언트 당 두 개의 고루틴을 생성하도록 변경할 것입니다. 현재는 작성 부분을 완전히 구현되기 전까지 주석 처리할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소켓에서 메시지를 읽는 작업은 ReadMessage를 사용하여 수행됩니다. 이 함수는 메시지 유형, 페이로드 및 오류를 반환합니다.\n\n메시지 유형은 전송되는 메시지의 유형이 무엇인지 설명하는 데 사용됩니다. Ping, pong, 데이터 또는 바이너리 메시지 등이 있습니다. 모든 유형은 RFC에서 확인할 수 있습니다.\n\n오류는 무언가 잘못되었을 경우 반환될 것이며, 연결이 닫힌 후에도 오류가 반환됩니다. 따라서 특정 닫기 메시지를 확인하여 출력하고, 일반적인 닫기에 대해서는 기록하지 않도록 하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 코드를 업데이트하고 몇 가지 메시지를 보내서 제대로 작동하는지 확인해볼 수 있어요.\n\nindex.html 파일 내에는 지금 sendMessage라는 함수가 있는데, 현재는 콘솔에 메시지를 출력하는 역할을 합니다. 간단히 이를 업데이트하여 대신 웹소켓으로 메시지를 전송하도록 수정할 수 있어요. JavaScript로 메시지를 보내는 것은 conn.send 함수를 사용하는 것만큼 쉽습니다.\n\n프로그램을 다시 시작하고 UI에 메시지를 입력한 후 Send Message 버튼을 누르면 메시지 유형과 페이로드가 stdout에 전송된 것을 확인할 수 있어요.\n\n지금은 메시지를 보낼 수만 있지만 메시지를 처리하는 것은 없습니다. 이제 메시지를 작성할 수 있는 기능을 추가할 시간이 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 WebSocket에 대해 한 번에 하나의 동시 프로세스로만 작성할 수 있다고 말한 것을 기억하시나요? 이러한 문제는 여러 가지 방법으로 해결할 수 있습니다. Gorilla가 권장하는 방법 중 하나는 동시 작성을 차단하기 위해 버퍼가 없는 채널을 사용하는 것입니다. 어떤 프로세스든 클라이언트 연결에 쓰기를 하려고 하면, 대신 이 메시지를 버퍼가 없는 채널로 작성합니다. 다른 프로세스가 현재 쓰기를 하는 경우에는 차단됩니다. 이렇게 함으로써 우리는 어떠한 동시성 문제도 피할 수 있게 됩니다.\n\n우리는 클라이언트 구조체를 업데이트하여 이 채널을 보유하도록 하고, 생성자 함수를 사용하여 이를 초기화할 것입니다.\n\nwriteMessages 함수는 readMessages와 매우 유사합니다. 하지만 이 경우에는 연결이 닫혔음을 알리는 Err을 받지 않습니다. 우리가 대신 egress 채널이 닫힐 때 프론트엔드 클라이언트에 CloseMessage를 보내줍니다.\n\nGo에서는 채널이 닫혔는지 여부를 알 수 있습니다. 두 번째 출력 매개변수를 수락하여 채널이 닫혔음을 나타내는 boolean을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 messagetype을 첫 번째 입력 매개변수로, payload를 두 번째 입력 매개변수로 받는 connections WriteMessage 함수를 사용할 거에요.\n\n만약 Go에 익숙하시다면, 현재 중복된 for select 문을 사용했다는 것을 알아채셨을 것입니다. 나중에 이 튜토리얼에서 선택 사항을 더 추가할 거에요.\n\n지금은 egress로 푸시된 모든 메시지가 클라이언트에게 전송됩니다. 현재 어떤 프로세스도 메시지를 egress에 작성하지 않지만, 작동 여부를 테스트하기 위해 빠른 해킹을 할 수 있습니다.\n\n우리는 readMessages에서 수신된 모든 메시지를 모든 다른 클라이언트에 브로드캐스트할 거에요. 간단히 말해, 모든 입력 메시지를 각 클라이언트의 egress로 출력함으로써 이 작업을 수행할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n29번 라인에 for 루프만 추가했습니다. 나중에 제거할 거에요. 이건 단지 전체 Reading과 Writing이 의도대로 작동하는지 테스트한 거예요.\n\n이제 프론트엔드를 업데이트해서 들어오는 메시지를 처리할 시간이에요. 자바스크립트는 웹소켓 이벤트를 다룰 때 일부 이벤트를 발생시킵니다. 그 이벤트들에 리스너를 적용할 수 있어요.\n\n모든 이벤트는 문서에 자세히 설명되어 있어요. 빠르게 다룰 수 있을 거예요.\n\n- Close — 웹소켓이 닫힐 때 발생합니다.\n- Error — 웹소켓이 오류로 인해 닫힐 때 발생합니다.\n- Message — 웹소켓이 새 메시지를 받았을 때 발생합니다.\n- Open — 웹소켓 연결이 열렸을 때 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트 엔드에서 할 일에 따라 이벤트 핸들러를 할당할 수 있어요. 저희는 메시지 이벤트에 관심이 있으므로, 일단 콘솔에 메시지를 출력하는 리스너를 추가할 거에요.\n\n연결이 열리면 보낸 이벤트를 출력하는 간단한 함수를 추가할 거예요. 이 이벤트 객체에는 보낸 타임스탬프와 메시지 유형과 같은 많은 데이터가 들어 있어요. 우리는 데이터 필드에 포함된 페이로드를 원할 거에요.\n\n이제 소프트웨어를 다시 시작하고 웹 사이트를 방문하여 몇 가지 메시지를 보내볼 수 있어요. 콘솔에서 이벤트가 보내고 받아지는 것을 볼 수 있어야 해요.\n\n지금은 읽기와 쓰기가 잘 되는 것을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이벤트 접근을 사용한 확장\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_7.png)\n\n지금은 연결하고 메시지를 보내고 받을 수 있습니다. 이 모든 것은 훌륭하며 기본 설정이 준비되었습니다.\n\n이제, 하나의 종류의 메시지만 보내려면 작동할 수도 있습니다. 보통 이벤트/유형 기반 접근 방식을 채택하면 웹소켓을 확장하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 말은 각 메시지를 보낼 때 기본 형식을 만든다는 것을 의미합니다. 이 형식에는 메시지 유형을 설명하는 특정 필드와 페이로드가 있습니다.\n\n이게 익숙해보이나요?\n\n왜냐하면 현재 WebSockets가 하는 것과 기본적으로 같습니다. 다만, 우리는 메시지를 JSON 개체로 보내고 응용 프로그램이 올바른 작업/함수를 수행하기 위해 라우팅할 수 있도록 합니다.\n\n이 방식은 사용하기 쉽고 확장 가능하며 웹소켓을 다양한 사용 사례에 활용할 수 있는 방법입니다. 이것은 RPC 솔루션이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 파일에 Event 클래스를 추가하여 수신 메시지를 구문 분석할 수 있도록 시작합니다. 그런 다음 이벤트를 routeEvent 함수에 전달하여 필드 유형의 값을 확인하고 해당 이벤트를 실제 핸들러로 전달합니다.\n\nonmessage 리스너에서는 Event 클래스로 맞는 JSON 형식의 데이터를 기대할 것입니다.\n\n또한 이벤트 이름과 페이로드를 입력으로 받는 sendEvent라는 함수를 생성할 것입니다. 이 함수는 입력을 기반으로 이벤트를 생성하고 JSON 형식으로 전송합니다.\n\n사용자가 sendMessage를 사용하여 메시지를 보낼 때마다 sendEvent를 호출할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 JavaScript 부분을 다루는 코드를 보여주는 gist입니다.\n\n이제 웹 사이트가 이벤트를 수락하고 보낼 수 있는 로직이 갖춰졌으니, 백엔드에서도 그 이벤트를 처리할 수 있도록 해야 합니다.\n\nevent.go라는 파일을 만들어 시작하세요. 이 파일에는 이벤트에 대한 모든 로직이 포함되어야 합니다.\n\n우리는 백엔드에 Event 구조체를 갖고 싶을 것이고, 이는 JavaScript의 Event 클래스와 동일한 모양이어야 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n페이로드의 데이터 타입이 json.RawMessage인 이유는 사용자가 원하는 페이로드를 보낼 수 있도록 하기 위해서입니다. 페이로드 데이터의 구조를 알고 있는 것은 이벤트 핸들러의 몫입니다.\n\n백엔드에서 메시지를 받을 때, 우리는 type 필드를 사용하여 적절한 EventHandler로 라우팅할 것이며, eventhandler는 함수 시그니처입니다. 따라서, 새로운 기능을 추가하려면 시그니처 패턴을 충족하는 새로운 함수를 만들면 됩니다.\n\nEventHandler 시그니처는 이벤트와 해당 메시지의 수신한 클라이언트를 받습니다. 또한 오류를 반환합니다. 클라이언트를 받는 이유는 일부 핸들러가 완료되면 응답을 반환하거나 클라이언트에게 다른 이벤트를 보낼 수 있기 때문입니다.\n\n또한 페이로드 내에서 예상되는 형식인 SendMessageEvent를 추가할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저가 EventHandlers의 맵을 저장하는 방식을 좋아합니다. 이렇게 하면 실제 응용 프로그램에서 매니저는 데이터베이스 저장소 등을 포함할 수 있어 쉽게 추가할 수 있습니다. 이를 추가하고 필요한 것들을 추가하는 데 사용되는 setupEventHandlers라는 새 함수를 추가할 것입니다.\n\n일련의 핸들러를 쉽게 확장할 수 있는 멋진 방법은 이 EventHandlers를 Map에 저장하고 Type을 키로 사용하는 것입니다. 따라서 이벤트를 경로로 지정하는 대신 모든 핸들러를 보유한 Map을 유지할 것입니다.\n\n들어오는 이벤트를 받아 맵에서 올바른 핸들러를 선택하는 routeEvent 함수를 추가할 것입니다.\n\n이벤트 인프라 전체를 마련하기 전에 Client를 변경해야 할 마지막 조각입니다. 클라이언트의 readMessages는 들어오는 JSON을 이벤트로 변환한 다음 매니저를 사용하여 이벤트를 경로로 지정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이언트의 출구 채널도 raw bytes를 보내는 대신 이벤트를 보내도록 수정할 것입니다. 이는 writeMessages를 변경하여 데이터를 보내기 전에 마샬해야 한다는 것을 의미합니다.\n\n백엔드를 다시 시작해보세요. `go run *.go`를 사용해서 메시지를 보내보세요. 'send_message [34 49 50 51 34]'와 같은 메시지가 출력되는 것을 확인할 수 있을 것입니다. 현재 Handler는 raw bytes를 파싱하지 않기 때문에 페이로드가 바이트로 출력될 것입니다.\n\n이를 구현하기 전에 WebSocket과 관련된 몇 가지 더 다뤄야 할 주제가 있습니다.\n\n## 하트비트 - 핑 \u0026 퐁\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![WebSocket Ping and Pong](/assets/img/2024-06-22-MasteringWebSocketsWithGo_8.png)\n\n웹소켓은 서버와 클라이언트 모두 Ping 프레임을 보낼 수 있습니다. Ping은 연결의 다른 부분이 여전히 살아 있는지 확인하는 데 사용됩니다.\n\n우리는 다른 연결이 살아 있는지 확인하는 것 뿐만 아니라 그것을 계속 유지하기도 합니다. 아무 것도 하지 않는 웹소켓은 오랫동안 유휴 상태로 있으면 닫힐 수 있습니다. Ping 및 Pong은 채널을 쉽게 유지하고, 저 트래픽의 장기간 연결이 예상치 못하게 닫히는 것을 피할 수 있게 해줍니다.\n\nPing을 보내면 상대방은 Pong으로 응답해야 합니다. 응답이 없으면 상대방이 더 이상 살아 있지 않다고 가정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 응답하지 않는 사람에게 계속 말하는 것은 논리적이죠.\n\n이를 구현하려면 서버 코드에서 진행해야 합니다. API 서버는 각 클라이언트에게 자주 Pings를 보내고 Pong을 기다립니다. 그리고 만약 Pong이 없다면 해당 클라이언트를 제거할 것입니다.\n\n먼저 사용할 타이머를 정의해 봅시다. client.go 내부에 pongWait와 pingInterval 변수를 생성할 것입니다. PongWait은 허용되는 Pong 사이의 초로, 클라이언트로부터의 각 Pong마다 리셋될 것입니다. 이 시간을 초과하면 연결을 끊을 것이며, 10초를 기다리는 것이 합리적이라고 할 수 있습니다.\n\npingInterval은 클라이언트에게 얼마나 자주 pings를 보내는지를 나타냅니다. 이것이 pongWait보다 낮아야 한다는 것에 주목하세요. PongWait보다 더 느리게 pings를 보내는 PingInterval을 가지고 있다면, PongWait가 취소될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 15초마다 핑을 보내지만 서버는 퐁을 받는 시간을 10초로만 허용한다면, 연결이 10초 후에 끊어질 것입니다.\n\n이제 서버가 각 클라이언트에게 핑 메시지를 보낼 필요가 있습니다. 이는 클라이언트의 writeMessages 함수 내에서 이뤄질 것입니다. 핑 간격(pingInterval)을 기반으로 트리거하는 타이머를 생성할 것이며, 트리거되면 비어있는 페이로드를 가진 PingMessage 유형의 메시지를 보낼 것입니다.\n\n이를 같은 함수 내에서 처리하는 이유는 연결이 동시 쓰기를 허용하지 않기 때문입니다. 이를 대신하여 egress에서 핑을 보내고 Event 구조체에 messageType 필드를 추가하는 다른 프로세스를 가질 수 있지만, 그 해결책이 조금 더 복잡하다고 생각합니다.\n\n같은 함수 내에서 이를 실행함으로써 동시적인 쓰기를 방지하는데, 외부출력(egress)에서 읽거나 타이먼의 여부를 따질 것이기 때문에 두 경우를 동시에 수행하는 것을 막을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPing을 보내고 있습니다. 프론트엔드 코드를 업데이트할 필요는 없어요. 왜냐하면 RFC 명세에 따르면 PingMessage가 올 때마다 PongMessage를 보내야하는 것으로 정의되어 있거든요. WebSocket을 지원하는 브라우저들은 클라이언트가 Ping 메시지에 응답하도록 자동으로 구성되어 있어요.\n\n그래서 서버가 클라이언트에 Ping을 보내고 있어요. 클라이언트는 Pong 메시지로 응답하지만 이제 어떻게 할까요?\n\n서버에 PongHandler를 구성해야 해요. PongHandler는 PongMessage를 수신하면 트리거되는 함수에요. readMessages를 업데이트해서 초기 PongWait 타이머를 설정하고 연결을 유지할 시간을 역으로 카운트 다운할 거에요.\n\ngorilla 패키지를 사용하면 SetReadDeadLine 함수를 통해 쉽게 설정할 수 있어요. 현재 시간을 가져와서 PongWait을 더한 다음, 해당 값을 연결에 설정할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 PongMessage를 수신할 때마다 타이머를 재설정하는 pongHandler 함수를 만들 것입니다. SetReadDeadLine을 사용하여 client가 PongMessage를 받을 때마다 타이머를 재설정합니다.\n\n좋아요, 이제 연결을 유지하여 웹사이트가 연결이 끊기지 않고 오랫동안 실행될 수 있습니다.\n\n소프트웨어를 다시 시작해보고 서버에서 Pong 및 Pong이 인쇄되는지 확인해보세요.\n\n대부분의 구현이 완료되었으니 이제 보안에 대해 고민해볼 시간입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메시지 크기 제한\n\n![image](/assets/img/2024-06-22-MasteringWebSocketsWithGo_9.png)\n\n보안 규칙 중 하나는 항상 악의적 사용을 기대해야 한다는 것입니다. 사람들이 할 수 있다면 그들은 할 것입니다. 따라서 항상 하는 좋은 것 중 하나는 서버에서 처리할 수 있는 메시지의 최대 크기를 제한하는 것입니다.\n\n이것은 악성 사용자가 DDOS에 대해 메가프레임을 보내거나 서버에서 다른 나쁜 일을 하는 것을 피하기 위함입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGorilla는 백엔드에서 구성할 때 SetReadLimit을 사용하여 허용된 바이트 수를 받는 것이 매우 쉽습니다. 메시지가 제한을 초과하면 연결이 닫힐 것입니다.\n\n사용자가 애플리케이션을 올바르게 사용하는 데 제한을 두지 않으려면 메시지의 크기를 알아야 합니다.\n\n우리가 만들고 있는 채팅에서는 프론트엔드에서 문자 제한을 부과한 뒤 가장 큰 메시지와 일치하는 최대 크기를 지정할 수 있습니다.\n\n각 메시지의 최대 크기를 512바이트로 설정하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n재시작하고 긴 메시지를 보내면 연결이 끊어질 수 있습니다.\n\n## 출처 확인\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_10.png)\n\n현재 상태에서는 어디서든 API에 연결할 수 있도록 허용하고 있습니다. 그렇게 하고 싶은 게 아니라면 이는 좋지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로, 프론트엔드는 어떤 서버에 호스팅되는데, 그 도메인이 유일하게 허용된 출처로 연결하는 것입니다. 이것은 Cross-Site Request Forgery를 방지하기 위해 수행됩니다.\n\nOrigin 확인을 다루기 위해 HTTP 요청을 수락하고 허용된 출처인지 간단한 문자열 체크를 통해 확인하는 함수를 작성할 수 있습니다.\n\n이 함수는 func(r \\*http.Request) bool 시그니처를 따라야 합니다. 왜냐하면 일반 HTTP 요청을 HTTP 연결로 업그레이드하는 업그레이더에는 해당 함수를 수락할 필드가 있기 때문입니다. 연결을 업그레이드하도록 허용하기 전에, 해당 요청에 대해 운영체제를 수행하여 출처를 확인합니다.\n\n테스트하고 싶다면, 스위치 문에서 8080 이외의 다른 포트로 변경하고 UI를 방문해보십시오. 그러면 출처가 허용되지 않음 메시지와 함께 출구할 것을 볼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인증\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_11.png)\n\nAPI의 중요한 부분 중 하나는 인증할 수 있는 사용자만 허용해야 한다는 것입니다.\n\nWebSocket에는 내장된 인증 유틸리티가 없습니다. 그러나 이는 문제가 되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWebSocket 연결이 설정되기 전에 사용자를 인증하겠습니다. serveWS 함수에서.\n\n이를 수행하는 두 가지 일반적인 방법이 있습니다. 두 가지 방법 모두 어느 정도 복잡하지만 심각한 문제는 아닙니다. 예전에는 Websocket 연결 URL에 사용자:비밀번호를 추가하여 일반적인 기본 인증을 전달할 수 있었지만 이 방법은 오랫동안 사용되지 않았습니다.\n\n추천되는 두 가지 솔루션이 있습니다.\n\n- 인증을 위한 일반적인 HTTP 요청이 OneTimePassword (OTP)을 반환하며 이를 WebSocket 연결에 사용할 수 있습니다.\n- WebSocket에 연결하되, 특정 인증 메시지가 전달된 후에만 메시지를 수락합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRetentionMap은 OTP를 보관하는 간단한 맵을 만들 것입니다. 5초가 지난 OTP는 삭제됩니다.\n\n또한 사용자를 인증하는 일반 HTTP 요청을 수락하는 새로운 로그인 엔드포인트를 만들어야 합니다. 이 예에서는 인증이 간단한 문자열 확인인데, 실제 프로덕션 응용프로그램에서는 인증을 실제 솔루션으로 대체해야 합니다. 인증 처리는 별도의 글을 작성할 주제입니다.\n\n사용자가 호출할 때 OTP를 검증하도록 serveWS를 업데이트해야 하며, 프론트 엔드가 연결 요청과 함께 OTP를 보내도록 해야 합니다.\n\n먼저 프론트 엔드를 변경하며 시작해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 로그인 양식을 만들고 연결 여부를 표시하는 텍스트와 함께 렌더링하려고 합니다. 따라서 index.html의 body를 업데이트하기로 합니다.\n\n다음으로, 문서 로드 이벤트에서 WebSocket 연결을 제거할 것입니다. 사용자가 로그인하기 전에 연결을 시도하지 않기 때문입니다.\n\nOTP 입력을 GET 매개변수로 추가하는 connectWebsocket 함수를 만들 것입니다. HTTP 헤더나 POST 매개변수로 추가하지 않는 이유는 브라우저에서 사용 가능한 WebSocket 클라이언트에서 지원되지 않기 때문입니다.\n\n또한 onload 이벤트를 업데이트해서 loginform에 핸들러를 할당할 것입니다. 이 핸들러는 /login으로 요청을 보내고 OTP가 반환될 때까지 기다린 후 WebSocket 연결을 트리거할 것입니다. 인증 실패 시 경고를 표시할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nonopen과 onclose을 사용하여 올바른 연결 상태를 사용자에게 출력할 수 있습니다. index.html의 스크립트 섹션을 다음 함수가 있는 형태로 업데이트하세요.\n\n이제 프론트 엔드를 시도해 볼 수 있으며, 로그인을 시도할 때 경고가 표시됩니다.\n\n프론트 엔드에 이러한 변경 사항을 적용한 후에는 백엔드에서 OTP를 확인할 수 있도록 해야 합니다. OTP를 생성하는 여러 가지 방법이 있으며, 도움이 되는 라이브러리도 있습니다. 이 튜토리얼을 간단하게 유지하기 위해 저희는 OTP를 생성하고 만료되면 이를 제거하며 확인하는 매우 기본적인 도우미 클래스를 작성했습니다. OTP를 처리하는 더 나은 방법들이 많이 있습니다.\n\notp.go라는 새 파일을 생성했으며 아래의 핵심 내용이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저를 업데이트하여 RetentionMap을 유지할 필요가 있습니다. 이를 사용하여 serveWS에서 OTP를 확인하고 사용자가 /login을 사용하여 로그인할 때 새 OTP를 생성할 수 있습니다. 보관 기간을 5초로 설정하고 기본 고루틴을 취소할 수 있는 컨텍스트를 수락해야 합니다.\n\n다음으로 /login에서 작동하는 핸들러를 구현해야 합니다. 간단한 핸들러입니다. 인증 부분을 실제 로그인 확인 시스템으로 교체해야 합니다. 핸들러는 사용자 이름과 비밀번호가 포함된 JSON 형식의 데이터를 수락할 것입니다.\n\n사용자 이름이 percy이고 비밀번호가 123 일 때 새 OTP를 생성하여 반환하고, 일치하지 않으면 권한이 없음 HTTP 상태를 반환할 것입니다.\n\n또한 serveWS를 업데이트하여 otp GET 매개변수를 수락하도록 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, main.go를 업데이트하여 로그인 엔드포인트를 호스팅하고 Manager에 Context를 전달해야 합니다.\n\n이 모든 것이 준비된 후에는 이제 프론트 엔드를 사용할 수 있어야 합니다. 그러나 로그인 양식을 성공적으로 사용한 후에만 가능합니다.\n\n해보세요. 메시지 보내기 버튼을 눌러도 아무 일도 일어나지 않을 것입니다. 그러나 로그인한 후에 WebSocket에서 메시지를 받아볼 수 있습니다.\n\n이벤트는 콘솔에만 출력할 것입니다. 하지만 우리가 그쪽으로 갈 것입니다. 마지막으로 다룰 보안 측면이 하나 더 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTTPS 및 WSS를 사용하여 트래픽 암호화하기\n\n![이미지](/assets/img/2024-06-22-MasteringWebSocketsWithGo_12.png)\n\n우리는 지금 평문 트래픽을 사용하고 있습니다. 운영 환경으로 런칭하려면 HTTPS를 사용하는 것이 매우 중요합니다.\n\n웹소켓을 HTTPS를 사용하도록 전환하려면 프로토콜을 ws에서 wss로 업그레이드하면 됩니다. WSS는 웹소켓 보안(WebSockets Secure)의 약어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html 파일을 열어 connectWebsocket의 연결 부분을 WSS를 사용하도록 변경해주세요.\n\n지금 UI를 시도해도 연결되지 않을 것입니다. 왜냐하면 백엔드가 HTTPS를 지원하지 않기 때문입니다. 백엔드에 인증서와 키를 추가하여 이 문제를 해결할 수 있습니다.\n\n만약 소유하지 않았다고 걱정하지 마세요. 이 튜토리얼 중에 사용할 자체 서명 인증서를 만들 수 있습니다.\n\nOpenSSL을 사용하여 자체 서명 인증서를 생성하는 작은 스크립트를 만들었습니다. 그들의 Github에서 설치 노트를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngencert.bash라는 파일을 만들어주세요. Windows를 사용하시는 경우에는 명령을 수동으로 실행할 수 있습니다.\n\n명령을 실행하거나 bash 스크립트를 실행하세요.\n\nbash gencert.bash\n\n두 개의 새 파일인 server.key와 server.crt가 생성됩니다. 이 파일들을 절대로 공유하면 안 됩니다. 이 파일들을 GitHub에 실수로 푸시하지 않도록 더 안전한 위치에 저장해주세요. (진짜, 이런 일이 벌어집니다. 이런 실수를 찾는 봇들이 있습니다)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 작업을 완료하고 나면, main.go 파일을 업데이트하여 인증서를 사용하여 트래픽을 암호화하는 HTTP 서버를 호스팅해야 합니다. ListenAndServe 대신 ListenAndServeTLS를 사용하여 이 작업을 수행합니다. 동일한 방식으로 작동하지만 인증서 파일과 키 파일의 경로를 입력해야 합니다.\n\nHTTPS 도메인을 허용하도록 originChecker를 업데이트하는 것을 잊지 마세요.\n\ngo run \\*.go를 사용하여 서버를 다시 시작하고, 이번에는 https 사이트를 방문해보세요.\n\n다음과 같이 에러 메시지가 표시될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n2022/09/25 16:52:57 http: TLS handshake error from [::1]:51544: remote error: tls: unknown certificate\n```\n\n이것은 원격 오류입니다, 즉 클라이언트에서 서버로 전송된 것을 의미합니다. 이는 브라우저가 인증서 제공업체(즉, 여러분)를 인식하지 못하기 때문에 나타납니다. 이는 개발용으로 자체 서명된 인증서이므로 걱정하지 마세요.\n\n실제 인증서를 사용하고 있다면 해당 오류를 보지 못할 것입니다.\n\n축하합니다. 이제 HTTPS를 사용하고 있으며 WebSocket은 WSS를 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 몇 가지 이벤트 핸들러 구현\n\n이 튜토리얼을 마무리하기 전에, 실제 이벤트 핸들러를 구현하여 채팅이 제대로 작동하도록 해보고 싶어요.\n\n우리는 웹소켓 관련 모든 것에 대한 프레임워크만 구현했어요. 핸들러 관련한 비즈니스 로직을 구현할 때입니다.\n\n더 이상 아키텍처 원칙이나 웹소켓에 관한 정보를 다루지 않을 거예요. 우리는 최종적으로 실습을 통해 몇 가지 핸들러와 로직을 추가하는 간단한 과정을 진행할 거에요. 이 이벤트 접근 방식을 사용하여 웹소켓 API에 추가적인 핸들러와 로직을 어떻게 쉽게 추가할 수 있는지 확인하실 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니저.go를 업데이트하여 setupEventHandlers에서 실제 함수를 받도록 변경하겠습니다.\n\n우리는 SendMessageHandler를 구현하고 싶습니다. 이 핸들러는 수신된 이벤트의 페이로드를 허용하고, 마샬링한 다음 다른 모든 클라이언트에게 출력해야 합니다.\n\nevent.go 파일에 다음을 추가할 수 있습니다.\n\n백엔드에서 해야 할 일은 여기까지입니다. 이제 프론트엔드를 정리해서 자바스크립트가 원하는 형식으로 Payload을 보내도록 해야 합니다. 그러니 JavaScript에서 동일한 클래스를 추가하여 이를 이벤트에 보내겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html의 Script 섹션 상단에 Event 유형에 대한 Class 인스턴스를 추가하십시오. 이러한 인스턴스는 event.go의 구조체와 일치해야 하므로 JSON 형식이 동일해야 합니다.\n\n그런 다음, 새 메시지를 보낼 때 트리거되는 sendMessage 함수를 업데이트해야 합니다. 올바른 페이로드 유형을 보내도록 만들어야 합니다.\n\n이것은 서버의 핸들러가 예상하는 SendMessageEvent 페이로드여야 합니다.\n\n마지막으로, 클라이언트에서 메시지를 수신하면 콘솔 대신 텍스트 영역에 출력해야 합니다. NewMessageEvent를 예상하고 해당 메시지를 텍스트 영역에 추가하는 함수로 전달하는 routeEvent를 업데이트해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 클라이언트 간에 메시지를 보낼 수 있어야 합니다. 이를 쉽게 시도할 수 있습니다. 두 개의 브라우저 탭에서 UI를 열고 로그인한 후 자신과 채팅을 시작하세요. 그러나 밤을 새우지는 마세요!\n\n모든 메시지를 모두에게 전달하지 않도록 새로운 채팅방을 관리할 수 있도록 쉽게 수정할 수 있습니다.\n\n우선 index.html에 새로운 ChangeRoomEvent를 추가하고, 사용자가 채팅방을 전환했음을 알리는 채팅을 업데이트하도록 시작합시다.\n\nmanager.go에 새로운 ChangeEvent를 추가하여 새로운 이벤트를 처리하도록 setupEventHandlers에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nClient 구조체에 채팅방 필드를 추가하여 사용자가 선택한 채팅방을 파악할 수 있습니다.\n\nevent.go 파일 내에 ChatRoomHandler를 추가하면 클라이언트의 새 채팅방 필드를 덮어쓸 수 있습니다.\n\n또한 SendMessageHandler에서는 이벤트를 전송하기 전에 다른 클라이언트가 동일한 방에 있는지 확인합니다.\n\n대단해요! 사용자가 채팅방을 전환할 수 있는 훌륭한 채팅 앱을 알게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI를 방문하고 한 번 시도해보세요!\n\n## 결론\n\n이 튜토리얼에서는 Websocket 서버를 위한 전체 프레임워크를 만들었습니다.\n\n우리는 웹소켓을 안전하고 확장 가능하며 관리되는 방식으로 수용하는 서버를 갖게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 다음 측면을 다루었습니다.\n\n- 웹소켓 연결 방법\n- 웹소켓으로 메시지를 효과적으로 읽고 쓰는 방법\n- 웹소켓을 이용한 Go 백앤드 API 구조화 방법\n- 관리가 용이한 웹소켓 API를 위한 이벤트 기반 디자인 사용 방법\n- PingPong이라는 하트 비팅 기법을 사용하여 연결을 유지하는 방법\n- 점보 프레임을 피하기 위해 메시지 크기 제한으로 사용자가 웹소켓을 악용하는 것을 방지하는 방법\n- 웹소켓이 허용하는 허용된 출처 제한 방법\n- OTP 티켓팅 시스템을 구현하여 웹소켓을 사용할 때 인증하는 방법\n- 웹소켓에 HTTPS 및 WSS 추가하는 방법\n\n이 튜토리얼이 WebSocket API를 시작하기 전에 학습해야 할 모든 것을 다루었다고 강하게 믿습니다.\n\n질문, 아이디어 또는 피드백이 있으면 언제든지 연락하길 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 즐겨 보셨길 바라요! 저는 정말 즐거웠어요.\n","ogImage":{"url":"/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringWebSocketsWithGo_0.png","tag":["Tech"],"readingTime":22},{"title":" 일상 개발에 꼭 필요한 7가지 자바스크립트 코드 스니펫","description":"","date":"2024-06-22 13:48","slug":"2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png\" /\u003e\n\n우리의 일상적인 개발 루틴에서는 종종 콘텐츠를 복사하거나 URL로부터 특정 매개변수를 가져오는 등 여러 일반적인 JavaScript 코드 스니펫을 사용합니다.\n\n이 코드 스니펫들은 개발의 편의를 위해 고정된 구현을 가지고 있습니다. 오늘은 자주 사용되는 7가지 코드 스니펫을 살펴보겠습니다.\n\n# 1️⃣ 클립보드로 콘텐츠 복사하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지정된 DOM 요소에서 내용을 사용자 클립보드로 복사하는 버튼을 사용하는 방법:\n\n```js\nconst copyToClipboard = (content) =\u003e {\n  const textarea = document.createElement(\"textarea\");\n  textarea.value = content;\n  document.body.appendChild(textarea);\n  textarea.select();\n  document.execCommand(\"Copy\");\n  textarea.remove();\n}\n```\n\n# 2️⃣ URLSearchParams를 사용하여 URL 검색 매개변수 가져 오기\n\n이것은 매우 흔한 작업입니다. 이 작업에 대해 regex에 의존했지만 이제는 더 간단한 접근 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getQueryByName = (name) =\u003e {\n  const query = new URLSearchParams(location.search);\n  return decodeURIComponent(query.get(name));\n}\n\n// 사용 예시:\n// URL: https://sunday.com/?name=fatfish\u0026age=100\nconst name = getQueryByName('name'); // fatfish\nconst age = getQueryByName('age'); // 100\nconst gender = getQueryByName('gender'); // null\n```\n\n# 3️⃣ 페이지 상단으로 스무스하게 스크롤\n\n페이지 상단으로 스무스하게 스크롤하는 방법:\n\n```js\nconst scrollToTop = () =\u003e {\n  const c = document.documentElement.scrollTop || document.body.scrollTop;\n  if (c \u003e 0) {\n    window.requestAnimationFrame(scrollToTop);\n    window.scrollTo(0, c - c / 8);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4️⃣ 현재 스크롤 위치 가져오기\n\n페이지의 현재 스크롤 위치를 검색합니다:\n\n```js\nconst getScrollPosition = (el = window) =\u003e ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,\n});\n\ngetScrollPosition(); // { x: 0, y: 215 }\n```\n\n# 5️⃣ 기기가 안드로이드인지 iOS인지 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 기기의 운영 체제를 식별하십시오:\n\n```js\nfunction getOSType() {\n  let u = navigator.userAgent;\n  let isAndroid = u.indexOf(\"Android\") \u003e -1 || u.indexOf(\"Linux\") \u003e -1;\n  let isIOS = !!u.match(/\\(i[^]+( U)? CPU.+Mac OS X/);\n  \n  if (isIOS) {\n    return 0; // iOS\n  } else if (isAndroid) {\n    return 1; // Android\n  } else {\n    return 2; // Other\n  }\n}\n\ngetOSType(); // 0은 iOS\n```\n\n# 6️⃣ 통화 포맷\n\n숫자를 통화 형식으로 변환하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst formatMoney = (money) =\u003e {\n  return money.toLocaleString();\n}\n\nconsole.log(formatMoney(123456789)); // '123,456,789'\nconsole.log(formatMoney(123456789.123)); // '123,456,789.123'\nconsole.log(formatMoney(123)); // '123'\n```\n\n# 7️⃣ 전체 화면 모드로 들어가고 나오기\n\n전체 화면으로 들어가고 나오기 함수:\n\n```js\n// 전체 화면으로 들어가기\nfunction fullScreen() {\n  let el = document.documentElement;\n  let rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen;\n  if (rfs) {\n    rfs.call(el);\n  } else if (typeof window.ActiveXObject !== \"undefined\") {\n    let wscript = new ActiveXObject(\"WScript.Shell\");\n    if (wscript != null) {\n      wscript.SendKeys(\"{F11}\");\n    }\n  }\n}\n\n// 전체 화면에서 나오기\nfunction exitScreen() {\n  let el = document;\n  let cfs = el.cancelFullScreen || el.webkitCancelFullScreen || el.mozCancelFullScreen || el.exitFullScreen;\n  if (cfs) {\n    cfs.call(el);\n  } else if (typeof window.ActiveXObject !== \"undefined\") {\n    let wscript = new ActiveXObject(\"WScript.Shell\");\n    if (wscript != null) {\n      wscript.SendKeys(\"{F11}\");\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쉽게 말해 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 추천하고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-7EssentialJavaScriptSnippetsforDailyDevelopment_0.png","tag":["Tech"],"readingTime":4}],"page":"14","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"14"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>