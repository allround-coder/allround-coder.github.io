<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/153" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/153" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" href="/post/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱을 만들 때 유용한 공짜 API들" href="/post/2024-05-01-APIstoUseforCreatingReactApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱을 만들 때 유용한 공짜 API들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱을 만들 때 유용한 공짜 API들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱을 만들 때 유용한 공짜 API들</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" href="/post/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" href="/post/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Webpack에 대한 Fallback 구축 방법 -  Module not found Error" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Webpack에 대한 Fallback 구축 방법 -  Module not found Error</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" href="/post/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 라우터 기초 내용 정리" href="/post/2024-05-01-ReactRouterNavigateYourAppswithEase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 라우터 기초 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 라우터 기초 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 라우터 기초 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" href="/post/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19 Beta 릴리스, 새로운 기능 소개 및 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node.js 애플리케이션을 디버깅하는 방법" href="/post/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node.js 애플리케이션을 디버깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node.js 애플리케이션을 디버깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Node.js 애플리케이션을 디버깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" href="/post/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" href="/post/2024-05-01-HowtoSkipReactuseEffectonInitialRender"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link" href="/posts/143">143</a><a class="link" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a><a class="link" href="/posts/152">152</a><a class="link posts_-active__YVJEi" href="/posts/153">153</a><a class="link" href="/posts/154">154</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"NextJS 앱에 JWT 인증 추가하는 방법(2024년 최신)","description":"","date":"2024-05-01 17:56","slug":"2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps","content":"\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png)\n\n# 소개\n\n본 문서는 NextJS를 사용하여 인증을 구현하는 방법에 대한 간단한 자습서입니다. 가이드에 들어가기 전에 사용될 기술을 시연하겠습니다:\n\n- JWT 또는 JSON Web Token은 두 당사자 간에 안전하게 클레임을 나타내는 데 사용되는 산업 표준 RFC 7519 방법입니다.\n- NextJS 미들웨어: 미들웨어를 사용하면 요청이 완료되기 전에 코드를 실행할 수 있으며, 수신된 요청을 기반으로 응답을 수정하여 리다이렉팅하거나 요청 또는 응답 헤더를 수정하거나 직접 응답하는 등의 작업을 수행할 수 있습니다. 이를 사용하여 우리는 인증을 처리하는 라우팅을 돕겠습니다.\n- JWT 인증 서비스: JWT를 사용하여 인증을 지원하는 백엔드 서비스가 필요합니다. NestJS를 사용하여 어떻게 만드는 지에 대한 내 튜토리얼을 확인하거나 다른 기술을 사용하여 직접 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레이아웃\n\n먼저 사용자 인터페이스가 필요해요. 이 간단한 레이아웃을 살펴봐요:\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_1.png)\n\n레이아웃을 보고 루트를 말해줄 수 있어요. 총 3가지 종류의 루트가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 공개 경로: 누구나 접근할 수 있는 경로\n- 인증 경로: 인증되지 않은 사용자만 접근할 수 있는 경로\n- 보호된 경로: 인증된 사용자만 접근할 수 있는 경로\n\n# 인증 서비스\n\nAPI 로그인을 호출해야 합니다. 따라서 인증 API 호출을 처리하는 서비스가 필요합니다. 이 예제에서는 axios를 사용하여 API 호출을 처리할 것입니다.\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 요청이 성공하면 사용자 이름, accessToken 또는 JWT, 만료 시간을 얻을 수 있습니다.\n\n# 인증 훅\n\n3 가지 간단한 훅이 필요합니다:\n\n- useCurrentUser : 현재 로그인한 사용자 정보를 가져오는 훅\n- useLogin : 로그인 방법을 제공하는 훅\n- useLogout : 로그아웃 방법을 제공하는 훅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 먼저 첫 번째 useLogin으로 들어갈 거에요:\n\n![HowtoaddJWTAuthenticationtoNextJSApps_3](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_3.png)\n\n사용자 정보를 쿠키로 저장했죠. 왜 쿠키를 사용했을까요? 나중에 설명할게요.\n\nuseLogout:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_4.png)\n\n로그아웃하려면 쿠키를 지우기만 하면 됩니다.\n\n사용자 현재 사용자\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미들웨어\n\nReact만 사용하면 모든 라우트에서 인증을 확인하는 것이 꽤 어렵습니다. 그러나 NextJS 미들웨어를 사용하면 매우 쉽게 처리할 수 있습니다.\n\n먼저, 라우트를 확인해 봅시다:\n\n![라우트 이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 가이드는 간단한 것이므로, 이렇게 가보겠습니다.\n\n중요한 부분은 미들웨어입니다. NextJS에서 미들웨어는 요청이 완료되기 전에 코드를 실행할 수 있게 해주며, 들어오는 요청을 기반으로 요청이나 응답 헤더를 수정하거나, 리다이렉팅하거나, 요청이나 응답에 직접 응답할 수 있게 해줍니다.\n\n즉, 미들웨어는 프로젝트의 모든 경로에 대해 호출될 것입니다.\n\n미들웨어.ts 파일을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_7.png)\n\n해석:\n\n- 먼저 쿠키에서 현재 사용자를 가져옵니다.\n- 다음 경로가 보호된 경로인지 확인한 후, 사용자가 인증되지 않았거나 토큰이 만료되었는지 확인합니다. 사용자를 쿠키에서 삭제하고 /login으로 리디렉트합니다.\n- 다음 경로가 인증 경로이지만 사용자가 로그인되어 있는 경우, 사용자를 /profile로 리디렉트합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서, NextJS에서 인증을 처리하는 간단한 구현이다. 이 글이 유용하게 느껴지길 바라며, 예제 코드가 너무 난해하다면 소스 코드를 여기서 확인해보세요.\n\n# 마지막으로\n\n내 컨텐츠는 누구에게나 무료이지만, 이 글이 도움이 되었다면 여기에서 커피 한 잔 사주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoaddJWTAuthenticationtoNextJSApps_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 앱을 만들 때 유용한 공짜 API들","description":"","date":"2024-05-01 17:53","slug":"2024-05-01-APIstoUseforCreatingReactApp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png\" /\u003e\n\n리액트는 현대적인 웹 및 모바일 애플리케이션을 구축하는 데 가장 인기 있는 프레임워크 중 하나가 되었습니다. 그 인기의 주요 이유 중 하나는 캡슐화된 UI 요소를 구축할 수 있는 구성 기반 아키텍처입니다.\n\n그러나 실제 세계 애플리케이션은 프론트엔드 UI 코드보다 훨씬 더 많은 기능이 필요합니다. 사용자 인증, 데이터베이스 액세스, 결제 처리, 분석 추적 등과 같은 능력이 종종 필요합니다.\n\n이러한 복잡한 기능을 처음부터 구축하는 대신, 외부 API를 활용하는 것이 일반적인 실천 방법이 되었습니다. Reactjs 개발자를 고용하여 바퀴를 다시 발명하지 않고 강력한 기능을 추가할 수 있으며, 개발자들은 빠르게 잘 구조화된 구성 요소를 구축하고 API를 통합하여 기능을 빠르게 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제는 다양한 범주에서 개방 API가 수천 개 제공됩니다. 이 범주에는 개발, UI, 인증 등이 포함됩니다. Remix 앱을 만들기 위해 API를 결합하면 제품을 위한 독특한 가치를 구축하는 데 집중할 수 있습니다.\n\n이 게시물에서는 React 앱에 쉽게 통합할 수 있는 일반적인 사용 사례의 가장 유용한 API 목록을 살펴볼 것입니다. React 컴포넌트에서 이러한 API를 직접 호출하여 결제, UI, 인증, 데이터, 저장소 등과 같은 기능을 추가하는 방법을 살펴볼 것입니다.\n\nAPI를 활용하고 React 개발자를 고용하면 풀 속도로 기능이 풍부한 앱을 빠르게 구축할 수 있습니다. 이러한 도구를 사용하여 React 앱을 강화하는 방법을 알아봅시다!\n\nReact 앱을 구축할 때 유용한 API 통합 목록을 더 잘 이해하기 위해.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인증\n\n인증 API는 현대의 웹 및 모바일 애플리케이션의 중심 역할을 합니다. 사용자의 안전한 리소스 접근을 효과적으로 조절하여, 사용자 등록, 로그인, 비밀번호 유지 및 세션 감독과 같은 기능을 수행합니다. 이러한 API 기능은 민감한 데이터와 상호 작용할 수 있는 사용자가 인증된 사용자만인지를 확인하여, 사용자 신뢰가 최우선이 되는 오늘날의 디지털적으로 결합된 생태계에서, 인증 API는 꼭 필요한 존재입니다. 이는 보안 및 사용자 중심 애플리케이션을 구축하기 위한 기초가 되며, 보안과 사용자 경험의 원활함을 최우선으로 하는 애플리케이션의 핵심 요소입니다.\n\n![인증 이미지](https://miro.medium.com/v2/resize:fit:960/1*sqHSJsqvTfKPEJ7XKhadHw.gif)\n\n## Firebase Auth\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle의 Firebase 플랫폼은 Firebase Authentication이라는 신뢰할 수 있는 인증 메커니즘을 제공합니다. 모바일 및 웹 애플리케이션의 사용자 권한 부여 및 인증 프로세스를 개선하는 다양한 기능을 제공합니다.\n\n다음은 Firebase Authentication API의 주요 특징 중 일부입니다:\n\n- 다중 서인 메소드\n- 사용자 관리\n- 신원 확인\n- 사용자 정의 인증 시스템\n- 단일 로그인\n- 보안 규칙\n\n## Auth0\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAuth0은 웹 및 모바일 개발자들이 강력한 인증 및 권한 부여 솔루션을 손쉽게 통합할 수 있도록 하는 현존하는 최첨단 Identity-as-a-Service (IDaaS) 플랫폼으로, 사용자의 신원 관리 복잡성을 간소화하며 소셜 로그인, 기업 연결 및 비밀번호 없는 대체 옵션을 포함한 다양한 로그인 옵션을 지원합니다. 개인 블로그나 글로벌 전자 상거래 제국을 개발하고 있다 하더라도, Auth0을 통해 보안과 사용자 참여를 강화하고 끊임없이 변화하는 온라인 규정과 조화를 이룰 수 있습니다.\n\n다음은 Auth0 API의 주요 기능 몇 가지입니다:\n\n- 인증 방법\n- 사용자 정의 인증\n- 비밀번호 없는 인증\n- 다중 요소 인증 (MFA)\n- 사용자 관리\n- 단일 로그인 (SSO)\n\n# 결제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결제 API는 전자 상거래의 디지턄 동맥 역할을 하며, 기업들이 온라인 환경에서 재정 거래를 원활하게 처리할 수 있도록 합니다. 이러한 API는 자금을 안전하고 효율적으로 이체하는 주요 동력이며, 고객들이 제품과 서비스를 쉽게 구매할 수 있도록 가능하게 합니다. 디지털 시장이 기하급수적으로 성장하는 시대에, 결제 API는 금융 데이터 보호, 결제 프로세스 간소화, 그리고 기업이 온라인 상거래 세계에서 번창할 수 있도록 하는 중추적 역할을 합니다.\n\n![](https://miro.medium.com/v2/resize:fit:1000/1*89T2MjogSTQDwIZUldjfHg.gif)\n\n## Stripe\n\nStripe는 신용 카드, 모바일 지갑 및 로컬 결제 수단을 지원하는 인기 있는 결제 처리 서비스 중 하나입니다. 이들의 API를 통해 React 애플리케이션 내에서 일회성 및 반복 결제를 손쉽게 수락할 수 있습니다. Stripe는 React, React Native, Node.js 등에 대한 클라이언트 라이브러리를 제공하여 통합을 간편하게 할 수 있습니다. 몇 줄의 코드로 안전하게 결제를 수락하고 거래를 관리할 수 있습니다. 많은 기업에게 결제가 중요한 만큼, Stripe는 React 앱을 수익화하는 데 필수적인 API입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Stripe의 일부 기능들입니다:\n\n- 결제 처리\n- 정기 구독 청구\n- 지급\n- 사기 방지\n- 송장\n- 재무 보고서\n\n## PayPal\n\nPayPal을 React 앱에 통합하면 고객에게 신용카드와 함께 선호하는 결제 방법을 제공할 수 있습니다. PayPal의 글로벌 플랫폼은 PayPal 계정, 신용/직불 카드 또는 은행 이체를 통해 안전한 결제를 제공합니다. React용 전용 JavaScript SDK를 사용하여 PayPal 버튼 및 PayPal 체크아웃과 같은 구성 요소를 통해 쉽게 PayPal 결제를 구현할 수 있습니다. 백엔드에서는 PayPal의 node.js API가 주문 처리와 거래를 관리합니다. 이 통합을 통해 변환율과 수익을 향상시킬 수 있으며, 더 넓은 사용자 베이스를 대상으로 한 원활한 결제 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 PayPal의 일부 기능들입니다:\n\n- 결제 처리\n- 글로벌 범위\n- 보안\n- 구매자 및 판매자 보호\n- 비즈니스용 PayPal\n- 국제 거래\n\n# 데이터 및 저장\n\n현대적인 React 애플리케이션은 사용자 프로필 및 콘텐츠와 같은 지속적인 데이터 저장이 필요합니다. 자체 데이터베이스 서버를 관리하는 대신 Firebase Firestore, Supabase, Airtable과 같은 써드파티 API를 사용하면 애플리케이션 데이터를 클라우드에 저장하고 쿼리하는 것이 쉬워집니다. 이들의 React SDK 및 훅을 사용하면 컴포넌트에서 데이터에 선언적으로 액세스할 수 있으므로 데이터베이스 구성보다는 프론트엔드 구축에 집중할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Firebase Firestore](https://miro.medium.com/v2/resize:fit:520/1*9fLgRS8xnprs6gidpYMYFg.gif)\n\n## Firebase Firestore\n\n파이어베이스 Firestore는 유연하고 NoSQL 구조의 클라우드 데이터베이스로, 사용자 간에 앱 데이터를 실시간으로 저장하고 동기화할 수 있습니다. 데이터 검색, 추가, 업데이트, 삭제 및 쿼리와 같은 데이터 작업에 대한 간단한 API를 제공합니다. Firestore는 인증 및 호스팅과 같은 다른 파이어베이스 서비스와 매끄럽게 통합됩니다. React-Firebase 훅스 라이브러리는 컴포넌트 내에서 파이어베이스 API를 직접 호출하기 위한 쉽게 사용할 수 있는 React 훅스를 제공합니다. 실시간 리스너를 통해 협업 및 소셜 기능을 더 쉽게 구축할 수 있습니다. 전반적으로, Firestore는 클라우드에서 확장 가능한 실시간 데이터베이스가 필요한 React 앱에 필수적인 데이터 API입니다.\n\n다음은 Firebase Firestore의 주요 기능 몇 가지입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NoSQL 데이터베이스\n- 실시간 데이터 동기화\n- 확장 가능하고 유연한\n- 오프라인 데이터 액세스\n- 보안 규칙\n- 쿼리 기능\n\n## Airtable\n\nAirtable은 API의 유연성과 쉽게 사용할 수 있는 스프레드시트 인터페이스를 독특하게 결합한 관계형 데이터베이스 옵션입니다. Airtable은 내부적으로 데이터를 레코드로 저장하는 스프레드시트와 유사한 테이블 형태로 관리합니다. Airtable의 React SDK를 사용하면 Records 및 RecordForm과 같은 선언적 구성 요소를 사용하여 데이터의 가져오기, 필터링 및 변경 작업을 수행하여 앱에 Airtable을 원활하게 통합할 수 있습니다. 직관적인 스프레드시트 뷰는 비기술 팀원이 데이터를 관리할 수 있도록 Airtable을 우수한 선택지로 만듭니다. 자체 서버를 관리하지 않으면서 관계형 데이터 중심의 React 앱을 구축하고 싶다면, Airtable의 React 통합을 통해 제공되는 단순성과 강력함의 조합은 탐험할 가치가 있는 훌륭한 선택지입니다.\n\n다음은 Airtable의 주요 기능입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자 친화적 인터페이스\n- 관계형 데이터베이스\n- 협업 및 공유\n- 사용자 정의 가능한 템플릿\n- 데이터 가져오기 및 내보내기\n- API 통합\n\n# 머신러닝\n\n머신러닝 기능을 추가하면 앱이 더욱 발전하게 됩니다. 그러나 ML 모델을 구축하려면 심층적인 전문 지식이 필요합니다. ML API를 사용하면 시각, 언어, 예측 등을 위한 사전 훈련된 모델을 손쉽게 통합할 수 있습니다. Google, AWS, Microsoft 같은 클라우드 제공업체는 이미지 분류, 음성 인식, 자연어 처리 등과 같은 일반적인 사용 사례를 다루는 ML API를 제공합니다. Clarifai와 같은 전문 API는 컴퓨터 비전에 집중합니다. 이러한 ML API를 활용하면 React 개발자들은 자신의 앱에 지능적인 기능을 추가할 수 있으며 AI 전문가가 아니어도 자체 모델을 훈련시키기 위한 리소스가 없어도 됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*i3OGEnu6h_0WRNiJzjBSqg.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TensorFlow\n\nTensorFlow.js는 웹 브라우저나 Node.js와 같은 JavaScript 환경에서 모델을 구축하고 배포하기 위한 ML 프레임워크입니다. 컴퓨터 비전, NLP 및 기타 분야에 대한 사전 훈련된 모델을 제공합니다. React TensorFlow 모듈을 사용하면 React 구성 요소 내에서 쉽게 모델을 사용하고 다시 훈련할 수 있으며, use TensorFlow와 같은 후크를 사용할 수 있습니다. 머신 러닝을 통합하려는 React 개발자들에게 TensorFlow.js는 필수적인 시작점입니다.\n\nTensorFlow의 주요 기능 중 일부는 다음과 같습니다.\n\n- 오픈 소스 프레임워크\n- 딥 러닝 기능\n- 모델 빌딩을 위한 유연성\n- 확장성\n- 생태계 및 커뮤니티 지원\n- 크로스 플랫폼 호환성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클라우드 비전 API\n\n구글의 클라우드 비전 API는 이미지를 이해하기 위한 강력한 사전 훈련된 머신러닝 모델을 제공합니다. 라벨, 얼굴 감지, OCR 등을 통해 이미지를 이해하는 기능을 제공합니다. 몇 줄의 코드로 React 앱에 지능적인 이미지 분류 및 분석 기능을 추가할 수 있습니다. 사용자 정의 모델을 훈련시킬 필요 없이 컴퓨터 비전을 통합하는 간단한 방법입니다.\n\n다음은 클라우드 비전 API의 주요 기능입니다.\n\n- 이미지 인식\n- 물체 탐지\n- 얼굴 인식\n- 광학 문자 인식 (OCR)\n- 라벨링 및 분류\n- 안전 검색 및 음란물 감지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 애널리틱스\n\n애널리틱스를 통해 사용자 행동을 이해하는 것은 성공적인 앱을 만드는 데 중요합니다. Google 애널리틱스와 Mixpanel과 같은 플랫폼을 사용하면 이벤트, 퍼널 및 지표를 측정하여 이용자 참여를 측정할 수 있습니다. React 라이브러리를 통해 이벤트를 직접 컴포넌트에서 분석 파이프라인으로 보낼 수 있습니다. 자체 추적 인프라를 구축하는 대신에 이러한 애널리틱스 플랫폼을 활용하면 상당한 개발 시간을 절약하고 강력한 애널리틱스 대시보드를 기본으로 제공받을 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*x8wKS9HGaskNnFSTg9Ws0g.gif)\n\n## Google 애널리틱스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 인기 있는 분석 솔루션인 Google Analytics은 웹 사이트 트래픽 및 사용자 참여를 추적하는 데 중요합니다. react-ga 라이브러리는 Google Analytics를 React와 통합하여 컴포넌트에서 페이지 뷰, 이벤트, 시간 및 기타를 직접 보낼 수 있도록 합니다.\n\n다음은 Google Analytics의 주요 기능입니다.\n- 실시간 데이터 모니터링\n- 전자 상거래 목표 추적\n- 웹 사이트 트래픽 분석\n- 사용자 행동 추적\n- 전환 추적\n- 사용자 정의 가능한 보고서\n\n## Mixpanel\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 인기 있는 분석 솔루션으로, Google Analytics는 웹 사이트 트래픽 및 사용자 참여를 추적하는 데 중요합니다. react-ga 라이브러리는 Google Analytics를 React와 통합하여 페이지 뷰, 이벤트, 타이밍 등을 컴포넌트에서 직접 전송할 수 있습니다.\n\n다음은 Mixpanel의 주요 기능들입니다.\n\n- 이벤트 추적\n- 사용자 행동 분석\n- 퍼널 분석\n- 충성도 분석\n- A/B 테스트\n- 사용자 정의 대시보드\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 React 앱을 개발할 때 타사 API의 사용을 논의하면서 외부 서비스 및 데이터를 통합하는 중요성을 강조합니다. 개발자들은 Firebase, Stripe 및 Mixpanel과 같은 기술을 활용하여 개발을 가속화하고 매력적인 사용자 경험을 제작하는 데 집중할 수 있습니다. 야심찬 앱을 구축하고 효과적으로 확장하기 위해, 이 기사는 확장되는 React 생태계와 모든 프로젝트에 API를 통합할 수 있는 가능성을 강조합니다. 또한 최신 솔루션에 대해 계속해서 알아둘 중요성을 강조합니다.","ogImage":{"url":"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png"},"coverImage":"/assets/img/2024-05-01-APIstoUseforCreatingReactApp_0.png","tag":["Tech"],"readingTime":8},{"title":"ReactJS와 Firebase를 사용하여 사용자 로그인 및 가입 구현하기(2024년)","description":"","date":"2024-05-01 17:51","slug":"2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide","content":"\n\u003cimg src=\"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png\" /\u003e\n\n# 소개:\n\n현재의 디지털 환경에서 사용자 인증 및 등록은 모든 웹 애플리케이션의 기본적인 측면입니다. 개인 블로그, 전자 상거래 플랫폼 또는 협업 도구를 구축하고 있더라도 안전하고 간편한 로그인 및 사용자 가입 프로세스를 구현하는 것이 중요합니다. ReactJS는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리이며, 강력한 백엔드 플랫폼인 Firebase와 결합하면 응용 프로그램에서 사용자 인증을 관리하는 강력한 솔루션을 제공합니다.\n\n본문에서는 ReactJS와 Firebase를 사용하여 로그인 및 사용자 가입 기능을 구현하는 단계별 안내를 제공하며, Bootstrap의 유연성과 디자인 기능을 활용합니다. 이 튜토리얼을 완료하면 ReactJS 응용 프로그램의 사용자 경험을 향상시킬 수 있는 원활하고 안전한 사용자 인증 시스템을 만들기 위한 지식과 기술을 갖추게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 튜토리얼을 통해 다음 주제를 다룰 예정입니다:\n\n- ReactJS 프로젝트 설정 및 필요한 종속 항목 설치하기.\n- Firebase 프로젝트 생성 및 Firebase 인증 구성하기.\n- 로그인 기능 구현하기, 폼 유효성 검사 및 오류 처리 포함.\n- 사용자 등록 기능 구현하기, 새로운 사용자 등록 허용하기.\n- 시각적으로 매력적이고 반응형 디자인을 위해 Bootstrap 통합하기.\n\n이 포괄적인 안내를 따라가면 ReactJS에서 튼튼한 로그인 및 사용자 등록 시스템을 구현하는 방법을 이해하고 Firebase의 인증 기능과 Bootstrap의 디자인 구성 요소를 활용할 수 있습니다. 그러니 시작해보고 애플리케이션을 무결한 사용자 인증 경험으로 강화해보세요!\n\n# 1. ReactJS 프로젝트 설정 및 필요한 종속 항목 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구현 세부 사항에 들어가기 전에 ReactJS에 대해 기본적인 이해가 있고 ReactJS 프로젝트를 이미 설정한 것으로 가정한 이 기사를 읽으셔야 합니다. ReactJS에 익숙하지 않거나 프로젝트 설정에 대한 지침이 필요한 경우 이전 기사를 참고하는 것을 권장합니다.\n\nReactJS에서 로그인 및 사용자 가입 기능을 구현하려면 이 과정을 돕는 여러 패키지를 설치해야 합니다. 이 패키지에는 Bootstrap, Firebase, react-bootstrap, react-google-button, react-router-dom, react-scripts, 그리고 web-vitals이 포함됩니다. 각 패키지와 이들이 구현에서 하는 역할에 대해 자세히 살펴보겠습니다:\n\n- Bootstrap: Bootstrap은 반응형이고 시각적으로 매력적인 사용자 인터페이스를 구축하기 위한 다양한 CSS와 JavaScript 컴포넌트를 제공하는 인기 있는 프론트엔드 프레임워크입니다. 응용 프로그램을 디자인하고 스타일을 쉽게할 수 있도록 도와주며 복잡한 CSS 스타일링에 시간을 할애하는 대신 기능에 집중할 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 터미널이나 명령 프롬프트를 열고 ReactJS 프로젝트의 루트 디렉토리로 이동하세요. 다음 명령을 사용하여 npm(Node Package Manager)을 통해 Bootstrap을 설치해보세요:\n\n```js\nnpm install bootstrap\n```\n\nFirebase: Firebase는 Firebase 인증을 포함한 다양한 서비스를 제공하는 강력한 백엔드 플랫폼입니다. Firebase Authentication은 이메일/비밀번호 인증, Google 및 Facebook과 같은 제공업체를 이용한 소셜 인증 등과 같이 사용할 수 있는 인증 기능을 제공합니다. Firebase Authentication은 응용 프로그램에 대한 안전한 사용자 관리, 인증 흐름, 및 신원 확인을 보장합니다.\n\n```js\nnpm install firebase\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. react-bootstrap: react-bootstrap은 Bootstrap의 강력함과 ReactJS의 쉬운 사용성 및 유연성을 결합한 라이브러리입니다. 재사용 가능한 React 컴포넌트로 구성된 미리 만들어진 Bootstrap 컴포넌트를 제공하여 Bootstrap의 스타일링 기능을 ReactJS 애플리케이션에 원활하게 통합할 수 있습니다.\n\n```js\nnpm install react-bootstrap\n```\n\n4. react-google-button: 이 패키지는 Google Sign-In 기능을 쉽게 추가할 수 있는 편리한 방법을 제공합니다. Google Sign-In 버튼 컴포넌트를 제공하여 Google의 인증 프로세스를 처리하고 Google 인증을 로그인 및 사용자 가입 흐름에 간소화되게 통합할 수 있습니다.\n\n```js\nnpm install react-google-button\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. react-router-dom: react-router-dom은 ReactJS 애플리케이션에서 라우팅 기능을 활성화하는 패키지입니다. 이를 사용하면 애플리케이션의 각 페이지에 대한 다른 경로를 정의하여 로그인 페이지, 가입 페이지 및 사용자 대시 보드와 같은 서로 다른 뷰 간에 원할하게 이동할 수 있습니다.\n\n```js\nnpm install react-router-dom\n```\n\n6. web-vitals: web-vitals는 페이지 로드 시간, 상호 작용 및 콘텐츠 렌더링과 같은 중요한 웹 성능 지표를 측정하고 추적하는 데 도움이 되는 패키지입니다. 웹 성능 지표를 모니터링하면 애플리케이션의 성능을 최적화하고 원활한 사용자 경험을 보장할 수 있습니다.\n\n```js\nnpm install web-vitals\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 패키지를 설치하고 활용하면 강력한 로그인 및 사용자 가입 시스템을 구현하는 데 필요한 도구를 갖게 됩니다.\n\n## 2. Firebase 프로젝트 생성 및 Firebase 인증 구성\n\nReactJS 애플리케이션을 위한 Firebase 프로젝트를 만들고 Firebase 인증을 구성하는 방법은 다음과 같습니다:\n\n- Firebase 프로젝트 생성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Firebase 콘솔(https://console.firebase.google.com/)로 이동해서 Google 계정으로 로그인해주세요.\n- \"프로젝트 추가\" 버튼을 클릭하여 새 Firebase 프로젝트를 만드세요.\n- 프로젝트 이름을 입력하고 원하는 지역을 선택해주세요.\n- Firebase 프로젝트를 생성하려면 \"프로젝트 만들기\" 버튼을 클릭하세요.\n\n2. Firebase 인증 활성화:\n\n- Firebase 프로젝트가 생성되면 프로젝트 대시보드로 리디렉션됩니다.\n- 왼쪽 사이드바에서 \"Develop\" 섹션 아래에 있는 \"Authentication\" 옵션을 클릭하세요.\n- Authentication 페이지에서 \"Sign-in method\" 탭 아래의 \"시작하기\" 버튼을 선택하세요.\n- 이메일/비밀번호 및 Google과 같은 인증 제공자를 선택하고 활성화하세요.\n\n3. Firebase 구성 세부정보 획득:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Firebase 프로젝트 대시보드에서 왼쪽 상단에있는 \"프로젝트 개요\" 옆에 있는 \"프로젝트 설정\" 기어 아이콘을 클릭합니다.\n- \"일반\" 탭에서 \"앱\" 섹션으로 스크롤하고 프로젝트에 새 웹 앱을 추가하려면 \"/\" 아이콘을 클릭합니다.\n- 앱에 대한 별명을 제공하고 \"이 앱에 대해 Firebase 호스팅도 설정\" 확인란을 선택 취소 해주세요.\n- \"앱 등록\" 버튼을 클릭하여 계속합니다.\n- Firebase에서 앱의 구성 세부 정보를 생성합니다. Firebase SDK 스니펫이 포함됩니다.\n\n4. ReactJS 애플리케이션과 Firebase 연결:\n\n- firebase.js 파일을 만들고 SDK 스니펫을 붙여넣어 주세요:\n\n```js\nimport { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\nconst firebaseConfig = {\n  apiKey: \"여러분의-API키\",\n  authDomain: \"여러분의-인증도메인\",\n  projectId: \"여러분의-프로젝트ID\",\n  storageBucket: \"여러분의-저장소버킷\",\n  messagingSenderId: \"여러분의-메시징발신자ID\",\n  appId: \"여러분의-앱ID\",\n};\n\n// Firebase 초기화\nconst app = initializeApp(firebaseConfig);\nexport const auth = getAuth(app);\nexport default app;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 컨텍스트 API 구축:\n\nReactJS에서는 컨텍스트 API를 사용하여 컴포넌트 트리를 통해 데이터를 전달할 수 있습니다. 각 레벨에서 명시적으로 props를 전달할 필요 없이 데이터를 전달하는 방법을 제공합니다. 컨텍스트 API에는 두 가지 주요 구성 요소가 있습니다: 컨텍스트 제공자와 컨텍스트 소비자가 있습니다.\n\n컨텍스트 제공자는 데이터를 트리 내의 다른 컴포넌트와 공유해야 하는 React 컴포넌트입니다. 이는 데이터의 진실의 원천 역할을 하며 해당 데이터를 사용할 수 있도록 만듭니다. 제공자는 컨텍스트를 생성하고 그것이 공유하려는 데이터를 지정하는 것이 책임입니다.\n\n- 컨텍스트 생성: (UserAuthContext.js)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userAuthContext = createContext();\n\nexport function useUserAuth() {\n  return useContext(userAuthContext);\n}\n```\n\n2. Provider 만들기: (UserAuthContext.js)\n\n```js\nexport function UserAuthContextProvider({ children }) {\n  const [user, setUser] = useState({});\n\n  return (\n    \u003cuserAuthContext.Provider value={{ user, logIn, signUp, logOut, googleSignIn }}\u003e\n      {children}\n    \u003c/userAuthContext.Provider\u003e\n  );\n}\n```\n\n3. App을 Provider로 감싸기: (App.js)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cUserAuthContextProvider\u003e\n           내 앱\n\u003c/UserAuthContextProvider\u003e\n```\n\n컨텍스트 프로바이더는 여러 컴포넌트에서 필요로 하는 데이터가 있고 props를 수동으로 전달하는 것을 원치 않을 때 유용합니다. 데이터 공유를 간소화하고 코드베이스를 유지보수 가능하고 확장 가능하게 만듭니다. 그러나 컨텍스트를 과도하게 사용하면 복잡하고 관리하기 어려운 코드로 이어질 수 있습니다.\n\n# 4. Firebase 함수 만들기:\n\n이제 LogIn, SignUp, LogOut 및 googleSignIn 함수를 만들겠습니다. 여기서는 firebase.js 파일에서 만든 Auth 인스턴스를 사용할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n function logIn(email, password) {\n    return signInWithEmailAndPassword(auth, email, password);\n  }\n  function signUp(email, password) {\n    return createUserWithEmailAndPassword(auth, email, password);\n  }\n  function logOut() {\n    return signOut(auth);\n  }\n  function googleSignIn() {\n    const googleAuthProvider = new GoogleAuthProvider();\n    return signInWithPopup(auth, googleAuthProvider);\n  }\n```\n\nonAuthStateChanged:\n\n파이어베이스에서 onAuthStateChanged는 Firebase 인증 모듈에서 제공하는 메소드입니다. 이는 사용자의 인증 상태를 실시간으로 모니터링할 수 있는 리스너 함수입니다. 이 함수는 사용자 세션을 관리하고 응용 프로그램에서 관련 인증 로직을 처리하는 데 특히 유용합니다.\n\nonAuthStateChanged 함수는 Firebase 인증 시스템에 옵저버를 등록하고 사용자의 인증 상태 변경을 듣습니다. 사용자가 로그인하거나 로그아웃하거나 인증 토큰이 만료될 때와 같이 사용자의 인증 상태가 변경될 때마다 콜백 함수를 트리거합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  useEffect(() =\u003e {\n    const unsubscribe = onAuthStateChanged(auth, (currentuser) =\u003e {\n      console.log(\"인증 상태\", currentuser);\n      setUser(currentuser);\n    });\n\n    return () =\u003e {\n      unsubscribe();\n    };\n  }, []);\n```\n\n# 5. 사용자 가입 작업중:\n\n\u003cimg src=\"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_1.png\" /\u003e\n\n여기서 먼저 부트스트랩을 사용하여 간단한 폼 UI를 만들겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이메일과 비밀번호에 대한 값은 각각 이메일(email)과 비밀번호(password)로 설정할 것입니다.\n\n```js\n\u003cForm.Group className=\"mb-3\" controlId=\"formBasicEmail\"\u003e\n    \u003cForm.Control\n        type=\"email\"\n        placeholder=\"이메일 주소\"\n        onChange={(e) =\u003e setEmail(e.target.value)}\n    /\u003e\n\u003c/Form.Group\u003e\n\n\u003cForm.Group className=\"mb-3\" controlId=\"formBasicPassword\"\u003e\n    \u003cForm.Control\n        type=\"password\"\n        placeholder=\"비밀번호\"\n        onChange={(e) =\u003e setPassword(e.target.value)}\n    /\u003e\n\u003c/Form.Group\u003e\n```\n\n회원가입 기능을 구현하기 위해 UserAuthContext.js 파일의 context API를 사용할 것입니다.\n\n```js\nconst Signup = () =\u003e {\n    const [email, setEmail] = useState(\"\");\n    const [error, setError] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n    const { signUp } = useUserAuth();\n    let navigate = useNavigate();\n\n    const handleSubmit = async (e) =\u003e {\n        e.preventDefault();\n        setError(\"\");\n        try {\n            await signUp(email, password);\n            navigate(\"/\");\n        } catch (err) {\n            setError(err.message);\n        }\n    };\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 유저 로그인 작업 중:\n\n![User Login](/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_2.png)\n\n회원가입과 완전히 같은 방식으로, 부트스트랩을 사용하여 이메일과 비밀번호 값을 설정하는 로그인 페이지를 디자인할 것입니다. 다만 회원가입 기능 대신 로그인 기능을 사용할 것입니다.\n\n또한 Google 로그인을 위해 react-google-button을 사용하여 디자인할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cGoogleButton className=\"g-btn\" type=\"dark\" onClick={handleGoogleSignIn} /\u003e\n```\n\n```js\nconst handleGoogleSignIn = async (e) =\u003e {\n  e.preventDefault();\n  try {\n    await googleSignIn();\n    navigate(\"/home\");\n  } catch (error) {\n    console.log(error.message);\n  }\n};\n```\n\n# 7. 보호된 라우트:\n\nReactJS에서 보호된 라우트란 응용 프로그램의 경로 중 인증된 사용자만 액세스할 수있는 경로를 나타냅니다. 일부 응용 프로그램의 특정 부분에 대한 액세스를 제한하여 로그인에 성공한 사용자 만이 특정 페이지 또는 구성 요소를 볼 수 있도록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReactJS 애플리케이션에서 보호된 경로를 구현하는 방법에 대한 단계별 안내서가 있어요:\n\n![이미지](/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_3.png)\n\nApp.js에서 `Home /`을 보호된 경로로 설정할 거에요,\n\n```js\n\u003cRoute\n  path=\"/home\"\n  element={\n    \u003cProtectedRoute\u003e\n      \u003cHome /\u003e\n    \u003c/ProtectedRoute\u003e\n  }\n/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 PretectedRoute.js 파일에서는 사용자가 로그인했는지 여부를 확인하고, 로그인되지 않은 경우 로그인 페이지로 리디렉션합니다.\n\n```js\nconst ProtectedRoute = ({ children }) =\u003e {\n  const { user } = useUserAuth();\n\n  console.log(\"Check user in Private: \", user);\n  if (!user) {\n    return \u003cNavigate to=\"/\" /\u003e;\n  }\n  return children;\n};\n```\n\n이 포괄적인 기사에서는 ReactJS 애플리케이션에서 Firebase를 사용하여 인증하고 디자인하기 위해 Bootstrap을 사용하여 로그인 및 사용자 가입 기능을 구현하는 방법에 대해 탐구했습니다. ReactJS의 기본적인 이해가 있다고 가정하여 ReactJS 프로젝트 설정부터 Firebase 프로젝트 생성 및 Firebase 인증 구성에 이르기까지 모든 중요한 단계를 다루었습니다.\n\n이 기사가 ReactJS 애플리케이션에서 견고한 로그인 및 사용자 가입 기능을 구현할 수 있는 지식과 자신감을 제공했기를 바랍니다. 여기서 제시된 단계를 따라가면 사용자의 전체 경험을 향상시키는 안전하고 사용자 친화적인 인증 시스템을 만들기 위한 준비가 충분히 갖춰집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩과 ReactJS 앱을 Firebase와 Bootstrap으로 멋지게 만드는 여정에 행운을 빕니다!\n\nGitHub에서 소스 코드를 확인하세요.\n","ogImage":{"url":"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-01-ImplementingUserLoginandSignUpwithReactJSandFirebaseAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"React Webpack에 대한 Fallback 구축 방법 -  Module not found Error","description":"","date":"2024-05-01 17:50","slug":"2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError","content":"\n\u003cimg src=\"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png\" /\u003e\n\n리액트 프로젝트에 google-sheets npm 패키지를 통합하려고 했는데 \"모듈을 찾을 수 없음: 오류 ...\"라는 오류 메시지가 나타났어요. 스택 추적을 통해 여러 종속성을 설치하면이 문제를 해결할 수 있다는 정보를 얻었지만, 그렇게 해도 여전히 이 오류가 발생했어요. 이 오류를 해결하려면 모듈을 찾을 수 없는 오류를 방지하기 위해 종속성과 대체값을 포함해야 합니다.\n\n## 우리의 오류 주요 부분\n\n이 문제를 해결하기 전에 스택 추적에서 몇 가지 항목을 이해해야 합니다. 오류 메시지의 첫 번째이자 가장 중요한 부분은 다음 줄입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n중요 변경 사항: webpack \u003c 5는 기본적으로 node.js 핵심 모듈을 위한 폴리필을 포함했었습니다. 이제는 그렇지 않습니다. 이 모듈이 필요한지 확인하고 그에 대한 폴리필을 구성하세요.\n```\n\n이 줄은 이 문제를 해결하는 데 필요한 모든 맥락을 제공하지만, webpack은 무엇이며 폴리필은 무엇인지, 그리고 중요 변경이란 무엇인지 등 궁금증을 불러일으킵니다. 먼저 webpack이 무엇인지 알아보겠습니다.\n\n## Webpack이란?\n\nUI / UX에 대한 중요한 디자인 고려 사항 중 하나는 속도입니다. 사용자들은 페이지의 구조나 자산이로드되기를 기다리고 싶어하지 않습니다. 첫 콘텐츠 렌더링 시간을 줄이고, 네트워크 트래픽을 감소시키고 사용자 경험을 향상시킬 수 있는 모든 방법을 고려해야 합니다. 이를 돕기 위해 우리는 webpack을 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩은 자바스크립트 모듈, CSS 스타일, HTML 코드 및 기타 자산을 가져와 서버에서 요청하는 클라이언트로 최적화되어 전송되는 방식을 최적화하는 모듈 번들러입니다. 의존성 그래프를 생성하여 이러한 자산 및 코드가 클라이언트로 전송될 때 결합되는 방식을 최적화하는 데 도움이 됩니다.\n\n![Webpack Image](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_1.png)\n\n이미지에는 여러 .js, .css 및 .png 파일이 몇 가지 항목으로 컴파일되어 클라이언트와 공유됩니다. 이것은 SPA(싱글 페이지 애플리케이션)를 빠르게 만드는 방식으로 코드를 구성하는 데 도움이 되어 React와 같은 프론트엔드 프레임워크에서 인기 있는 도구입니다.\n\n## 무엇이 중요한 변경 사항인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 변경 사항을 이해하기 위해서는 소프트웨어 버전 관리를 이해해야 합니다. 소프트웨어는 비트와 바이트, 1과 0으로 이루어져 있죠. 이 원자적인 단위를 넘어, 소프트웨어는 살아 숨 쉬는 존재입니다. 개발자들은 소프트웨어 코드를 수정합니다. 새로운 기능을 추가하고 기존 기능을 업데이트합니다. 변경되고 업데이트되는 의존성에 대응하여 엔드 사용자들에게 스무스한 경험을 제공하기 위해 노력합니다.\n\n하지만 모든 변경이 안전한 것은 아닙니다. 그래서 소프트웨어는 버전 관리 방법을 갖고 있습니다. 아니, 우리는 물건을 '내 패키지 1', '내 패키지 2'와 같이 이름 붙이는 것이 아니에요. 대신 다음과 같은 3자리 숫자 형식을 사용합니다:\n\n![이미지](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_2.png)\n\n왼쪽에서 오른쪽으로 읽을 때, 첫 번째 숫자는 주요 버전입니다. 이 숫자는 주요 소프트웨어 변경 사항이 발생할 때마다 올라갑니다. 이 변경 사항은 의존하는 프로그램에 영향을 미칠 것으로 확신되는 변경 사항이기 때문에 '중요한 변경 사항'이라 불립니다. 변경 사항에는 리소스나 메서드에 대한 다른 이름이나 기존 프로그램이 데이터를 찾지 못하게 만들 수 있는 API 구조의 변화 등이 포함될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가운데 숫자는 마이너 버전 변경을 나타냅니다. 이는 새로운 기능을 도입할 수 있지만, 소프트웨어 내의 기존 기능에는 영향을 미치지 않아야 합니다. 마지막 숫자는 패치 버전 변경이며, 기능을 확장하지는 않고 오직 고장난 코드를 수정하는 버그 수정을 의미합니다.\n\n오류 메시지에서 볼 수 있듯이, Webpack 5보다 큰 모든 주요 버전에서 중단 변경이 발생했습니다.\n\n## 폴리필이란 무엇인가요?\n\n소프트웨어는 정적이 아니며, 프로그램의 각 버전이나 그것에 액세스하는 도구는 예기치 못한 효과를 초래할 수 있습니다. 웹 개발자들은 HTML5 및 CSS3 코드를 사용할 때 발생하는 브라우저 문제에 대해 이 문제를 알고 있습니다. 이것이 caniuse.com과 같은 웹 사이트가 인기 있는 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nECMAScript 버전은 HTML5와 CSS3처럼 작동하여, 새로운 버전에서는 오래된 JavaScript 버전과 호환되지 않는 기능이 추가됩니다. ECMAScript의 새로운 버전은 개발자들에게 개발을 더 쉽게 만들어주는 내장 메소드와 구조를 제공하지만, 클라이언트가 해당 코드를 지원하지 않을 경우에는 오작동한 코드를 유발할 수 있습니다. 이때 폴리필이 도움이 됩니다.\n\n폴리필은 웹 브라우저에서 해당 기능을 지원하지 않는 경우에 해당 기능의 기능성을 구현하는 코드 조각입니다. 이를 통해 개발자들은 최신 웹 기능을 사용할 수 있으면서도 프로그램이 오래된 브라우저에서도 작동하는 것을 보장할 수 있습니다.\n\n우리가 보고 있는 오류를 해결하려면 의존성 후폭풍을 추가할 수 있습니다. 우리의 코드가 webpack 5에서 제외된 내장 노드.js 모듈을 찾을 때, 실패하는 대신에, 우리가 제공하고 대신 사용할 대체 패키지를 찾을 것입니다.\n\n## NPM과 폴리필을 사용하여 모듈을 찾을 수 없는 오류를 어떻게 해결할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩이 무엇인지, 소프트웨어 버전 관리 방법 및 폴리필이 무엇인지에 대해 이야기했습니다. 이제 모듈을 찾을 수 없는 오류를 해결할 준비가 되었습니다. 브라우저 JavaScript와 서버 JavaScript는 사용할 수 있는 패키지가 다르기 때문에, 누락된 모듈 오류를 해결하기 위해 필요한 패키지를 다운로드해야할 수 있습니다.\n\n이 오류를 해결하기 위해 해결해야 할 문제가 두 가지 있습니다:\n\n- 프로젝트에 필요한 npm 패키지가 포함되어 있지 않음\n- 클라이언트 친화적인 패키지를 사용하고, 노드 패키지를 웹 패키지로 매핑해야 함\n\n오류 메시지에서 필요한 모든 정보를 얻을 수 있습니다. 첫 번째 단계는 누락된 패키지를 포함해야 합니다. 예를 들어 path 패키지를 살펴보겠습니다. 이것은 표준 노드 패키지이지만 클라이언트 친화적이지 않습니다. 우리의 React 앱에 필요한 것은 path-browserify 패키지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 path-browserify를 npm install할 수 있지만, 이것은 첫 번째 단계만 해결합니다. 앱을 작동시키기 위해서는 webpack에게 path 대신 path-browserify를 찾도록 해야 합니다. webpack.config.js 파일로 이동할 수 있습니다:\n\n```bash\n/node_modules/react_scripts/config/webpack.config.js\n```\n\n이 파일은 로컬 서버를 react 스크립트 명령(npm start dev)으로 시작할 때 webpack 설정을 다룹니다. 우리는 이전 의존성인 path를 새 의존성인 path-browserify로 매핑하고자 합니다. 이 매핑에 대한 예외 처리 또는 catch 문을 사용하고 있으므로 이를 명확히 해주어야 합니다.\n\n만약 파일에서 \"fallback: \"을 검색하면, 모듈에 대한 여러 예외 매핑을 넣을 수 있는 해시를 찾을 수 있습니다. 에러 문구에서 코드를 복사하여 다음과 같이 해시에 넣어주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_3.png)\n\n서버를 재시작해야 할 수도 있지만, 종속성을 설치하고 폴백 경로를 추가하면 오류가 해결될 것입니다!\n","ogImage":{"url":"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoBuildFallbackforReactWebpackModulenotfoundError_0.png","tag":["Tech"],"readingTime":5},{"title":"Socket.io, React.js, Node.js 및 Express.js를 사용한 실시간 애플리케이션 만들기","description":"","date":"2024-05-01 17:48","slug":"2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide","content":"\n\n**실시간 웹 개발: Socket.io, React.js, Node.js 및 Express.js를 활용한 대화형 애플리케이션 구축에 대한 포괄적인 가이드**\n\n![BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png](/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png)\n\n오늘날의 디지털 환경에서 실시간 통신은 웹 애플리케이션의 중요한 측면이 되었습니다. 채팅 애플리케이션, 협업 도구 또는 실시간 업데이트와 같이 사용자는 페이지를 새로 고치지 않고 즉시 업데이트를 기대합니다. 이것이 Socket.io, React.js, Node.js 및 Express.js가 등장하는 곳입니다.\n\nSocket.io는 웹 서버와 클라이언트 간의 양방향 및 이벤트 기반 통신을 가능하게 하는 강력한 라이브러리입니다. React.js, 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리, 그리고 Express.js를 통한 Node.js와 결합하면 다양한 웹 애플리케이션을 만들 수 있는 다재다능한 웹 애플리케이션 프레임워크를 통해 개발자는 원활하고 대화형 실시간 애플리케이션을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그에서는 Socket.io의 기본을 탐구하고 React.js, Node.js, Express.js와 통합하는 방법을 알아볼 것입니다. 우리는 기본 개념, 단계별 구현 방법, 실시간 애플리케이션을 구축하는 데 가장 좋은 방법에 대해 이야기할 것입니다. 이 안내서를 마치면 이러한 기술을 활용하여 사용자가 실시간으로 참여하는 동적이고 반응적인 어플리케이션을 만드는 방법에 대해 확고한 이해를 갖게 될 것입니다. 그러니 Socket.io, React.js, Node.js, Express.js와 함께하는 실시간 웹 개발의 흥미로운 여정을 시작해봅시다!\n\n먼저 클라이언트 및 서버 폴더가 필요합니다. 서버 폴더에서 Node.js 프로젝트를 초기화하세요.\n\n```js\nnpm init\n```\n\n그런 다음 필요한 종속성(Express, Cors, Nodemon, Socket.io)을 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install express cors nodemon socket.io\n```\n\n- Express: Express는 Node.js를 위한 인기 있는 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션과 API를 구축하는 간편하고 유연한 방법을 제공합니다.\n- Cors: Cross-Origin Resource Sharing (CORS)는 웹 브라우저에 의해 구현된 보안 메커니즘으로, 다른 출처의 리소스에 대한 액세스를 제한합니다. 웹 애플리케이션을 개발할 때, 하나의 도메인에서 다른 도메인으로 요청을 보낼 때 CORS 문제가 발생할 수 있습니다. cors 라이브러리를 사용하여 Express 애플리케이션에서 CORS 관련 문제를 처리합니다.\n- Nodemon: Nodemon은 소스 코드에 변경 사항이 감지될 때마다 Node.js 애플리케이션을 자동으로 다시 시작하는 개발 유틸리티입니다.\n- Socket.io: Socket.io는 웹 브라우저와 서버 간에 실시간 양방향 통신을 가능하게 하는 JavaScript 라이브러리입니다. 주로 즉각적인 데이터 업데이트나 대화형 기능이 필요한 애플리케이션을 구축하는 데 사용됩니다.\n\n그 후, 서버 폴더에 index.js 파일을 만들고 다음 코드를 추가하세요.\n\n```js\nconst express = require('express');\nconst app = express();\nconst http = require('http');\nconst { Server } = require(\"socket.io\");\nconst cors = require('cors');\napp.use(cors());\n\nconst server = http.createServer(app);\nconst io = new Server(server, {\n    cors: {origin:\"http://localhost:3000\", methods: [\"GET\", \"POST\"]},\n});\n\nserver.listen(4000, () =\u003e { console.log(\"listening on *:4000\"); });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 클라이언트 폴더로 이동하여 리액트 앱을 만들어봅시다.\n\n```js\nnpx create-react-app .\n```\n\n여기서 소켓 IO 클라이언트 종속성을 설치해야 합니다.\n\n```js\nnpm install socket.io-client\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱.js에 다음 코드를 추가하세요.\n\n```js\nimport \"./App.css\";\nimport { useEffect } from \"react\";\nimport io from \"socket.io-client\";\nconst socket = io.connect(\"http://localhost:4000\");\n\nfunction App() {\n  function sendMessage() {\n    console.log(\"버튼 클릭됨\");\n    socket.emit(\"send_message\", { message: \"클라이언트에서 안녕하세요\" });\n  }\n  useEffect(() =\u003e {\n    socket.on(\"receive_message\", (data) =\u003e {\n      alert(data.message);\n    });\n  }, [socket]);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cinput placeholder=\"메시지\" /\u003e\n      \u003cbutton onClick={sendMessage}\u003e메시지 보내기\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n게다가, 서버 폴더에 있는 index.js 파일에 다음 코드를 추가하세요.\n\n```js\nio.on(\"connection\", (socket) =\u003e {\n  console.log(`유저가 연결되었습니다 ${socket.id}`);\n  \n  socket.on(\"send_message\", (data) =\u003e {\n    socket.broadcast.emit(\"receive_message\", data);\n  });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 줄들로 기본 메시지 '클라이언트에서 안녕하세요'를 보낼 수 있고, 다른 모든 사용자에게 방송할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*owCRflCEFkCAw6365cvt0g.gif)\n\n지금까지 socket.io가 올바르게 작동하고 있습니다. 이제 할 일은 메시지 데이터를 전송하는 것뿐입니다.\n\n여기 클라이언트 앱의 최종 버전인 app.js 파일이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport \"./App.css\";\nimport { useEffect, useState } from \"react\";\nimport io from \"socket.io-client\";\nconst socket = io.connect(\"http://localhost:4000\");\n\nfunction App() {\n  const [message, setMessage] = useState(\"\");\n  const [messageReceived, setMessageReceived] = useState(\"\");\n  function sendMessage() {\n    console.log(\"Button clicked\");\n    socket.emit(\"send_message\", { message: message });\n  }\n  useEffect(() =\u003e {\n    socket.on(\"receive_message\", (data) =\u003e {\n      setMessageReceived(data.message);\n    });\n  }, [socket]);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cinput\n        placeholder=\"메시지를 입력하세요\"\n        onChange={(e) =\u003e {\n          setMessage(e.target.value);\n        }}\n      /\u003e\n      \u003cbutton onClick={sendMessage}\u003e메시지 보내기\u003c/button\u003e\n      \u003ch1\u003e\n        받은 메시지: {messageReceived}\n      \u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n서버의 index.js 파일 최종 버전은 다음과 같습니다.\n\n```js\nconst express = require(\"express\");\nconst app = express();\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst cors = require(\"cors\");\napp.use(cors());\n\nconst server = http.createServer(app);\nconst io = new Server(server, {\n  cors: { origin: \"http://localhost:3000\", methods: [\"GET\", \"POST\"] },\n});\n\nio.on(\"connection\", (socket) =\u003e {\n  console.log(`사용자가 연결되었습니다: ${socket.id}`);\n\n  socket.on(\"send_message\", (data) =\u003e {\n    socket.broadcast.emit(\"receive_message\", data);\n  });\n});\nserver.listen(4000, () =\u003e {\n  console.log(\"4000번 포트에서 수신 대기 중\");\n});\n```\n\n최종 결과는 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Real-time applications](https://miro.medium.com/v2/resize:fit:1400/1*f0e54kuZSGu0pvAivmOJug.gif)\n\n이 포괄적인 가이드는 Socket.io, React.js, Node.js 및 Express.js를 사용하여 실시간 애플리케이션을 구축하는 방법을 탐구합니다. 이러한 기술을 활용하여 개발자는 사용자에게 즉각적인 업데이트를 제공하는 동적 대화형 애플리케이션을 만들 수 있습니다. 이 안내서는 기본 개념, 단계별 구현 및 모베스트 프랙티스를 다룹니다. 전체 소스 코드는 GitHub 저장소 https://github.com/matheshyogeswaran/React_socket_io.git 를 방문해주세요. 즐겁게 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingReal-TimeApplicationswithSocketioReactjsNodejsandExpressjsAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 라우터 기초 내용 정리","description":"","date":"2024-05-01 17:47","slug":"2024-05-01-ReactRouterNavigateYourAppswithEase","content":"\nReact Router는 React 애플리케이션을 위한 강력한 라우팅 라이브러리입니다. URL을 기반으로 다른 컴포넌트를 렌더링하고 탐색을 처리하는 것을 통해 전체 페이지 새로 고침이 필요하지 않도록 해줍니다. 간단히 말해, React Router는 사용자 인터페이스가 URL 변경에 동적으로 업데이트되어 사용자에게 더 부드럽고 원활한 브라우징 경험을 제공하는 단일 페이지 애플리케이션(SPA)을 만드는 데 도움을 줍니다.\n\nReact Router를 사용하는 장점:\n\n- 클라이언트 측 라우팅: 페이지 전체를 새로 고치지 않고 뷰 간의 부드럽고 빠른 전환이 가능하여 좀 더 원활한 사용자 경험을 제공합니다.\n- 선언적 라우팅: React 컴포넌트 내에서 라우트를 쉽게 정의하고 관리할 수 있습니다.\n- 동적 라우팅: React Router는 동적 라우팅을 지원하여 개발자가 URL 매개변수를 사용하여 라우트를 생성하고 URL에 따라 동적 콘텐츠를 렌더링할 수 있습니다. 이를 통해 React를 사용하여 동적이고 데이터로 구동되는 사용자 인터페이스를 구축할 수 있습니다.\n- 중첩된 라우팅: React Router는 중첩된 라우트를 지원하여 중첩된 컴포넌트와 라우트로 복잡한 UI 계층 구조를 만들 수 있습니다. 이는 다수의 탐색 수준을 갖는 대규모 애플리케이션을 구성하고 관리하는 데 유용합니다.\n- 리다이렉트 및 오류 처리: 예상치 못한 상황에서도 사용자 경험을 향상시킵니다.\n\nReact Router를 사용하는 방법은 어떻게 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설치: 먼저 npm 또는 yarn을 사용하여 React Router를 설치하세요:\n\n```js\nnpm install react-router-dom\n또는\nyarn add react-router-dom\n```\n\n2. 라우트 설정: 주로 App.js와 같은 주요 컴포넌트 파일을 연 후 react-router-dom에서 필요한 컴포넌트를 가져옵니다.\n\n라우트를 설정하는 과정에서 `BrowserRouter`의 역할을 이해하는 것이 중요합니다. 이 컴포넌트는 애플리케이션의 최상위 래퍼로 작동하여 클라이언트 측 라우팅을 가능하게 합니다. 우리의 전체 애플리케이션을 `BrowserRouter`로 감싸면 내비게이션과 라우트 변경을 원활하게 처리할 수 있습니다. `BrowserRouter`를 우리 애플리케이션의 내비게이션의 주요 컨트롤러로 생각해보세요. 이를 통해 애플리케이션 내의 모든 컴포넌트가 라우팅 기능에 액세스할 수 있게 되며, 효과적으로 라우트를 정의하고 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\n```\n\n리액트 앱에서 주요 구성 요소인 보통 App이 모든 것을 제어합니다. 그러나 React Router를 추가하면 Router 구성 요소가 새로운 주인이 됩니다. 이는 네비게이션에 대한 마스터 컨트롤러와 같습니다. Router를 가장 높은 부모로 만들면 모든 구성 요소가 라우팅 슈퍼파워에 액세스할 수 있습니다. 이렇게 하면 다른 페이지 간에 쉽게 이동하고 라우트 정보에 액세스할 수 있습니다. 요약하면 최상위 부모로 Router를 사용하면 앱의 모든 구성 요소가 React Router의 혜택을 누릴 수 있습니다.\n\n가장 간단한 방법으로 React Router를 설정하려면 index.js 파일에 다음을 포함하십시오:\n\n```js\nReactDOM.render(\n  \u003cRouter\u003e\n    \u003cApp /\u003e\n  \u003c/Router\u003e\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 네비게이션에 링크 사용하기: React 애플리케이션에서 React Router를 사용하여 네비게이션을 위해 `Link` 컴포넌트를 사용하려면, React Router에서 Link를 import하십시오.\n\n```js\nimport { Link } from \"react-router-dom\";\n```\n\nReact Router의 `Link` 컴포넌트는 애플리케이션의 서로 다른 경로 간에 링크를 생성하는 데 사용됩니다. 이는 전통적인 HTML `a` 태그와 유사하지만, React Router를 사용하는 React 애플리케이션 내에서 사용하도록 특별히 디자인되었습니다.\n\n일반적으로 `Link`를 사용하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cLink to=\"/about\"\u003eAbout\u003c/Link\u003e\n```\n\n클릭 가능한 링크를 만들기 위해 `Link`를 사용합니다. `to` 속성은 클릭했을 때 링크가 이동해야 하는 대상 URL을 지정합니다.\n\n`Link`를 클릭하면 React Router가 네비게이션 이벤트를 가로채고 전체 페이지 새로고침 없이 브라우저의 URL을 업데이트합니다. 이를 통해 React 애플리케이션 내에서 부드러운 클라이언트 측 네비게이션이 가능해집니다.\n\n라우트 매개변수와 동적 라우트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우트 매개변수는 URL 패턴 내 동적 값을 캡처하고 동적 경로를 생성할 수 있는 자리 표시자입니다. 이 매개변수들은 콜론(:)으로 시작하고 매개변수 이름이 따라온 루트 경로에 정의됩니다. 예를 들어, 루트 경로 /users/:id에서 :id는 라우트 매개변수입니다.\n\n예를 들어, 블로그 애플리케이션에서 각 블로그 게시물이 고유한 식별자(ID)를 가지는 경우를 생각해보세요. 개별 블로그 게시물마다 별도의 경로를 만드는 대신, 포스트 ID를 라우트 매개변수로 캡처하는 단일 동적 경로를 만들 수 있습니다:\n\n```js\n\u003cRoute path=\"/posts/:postId\" component={PostDetail} /\u003e\n```\n\n이 라우트에서 :postId는 블로그 게시물의 고유 식별자를 나타내는 라우트 매개변수입니다. 사용자가 /posts/123과 같은 URL로 이동할 때, React Router는 postId 매개변수로 값 123을 캡처합니다. 이 매개변수는 그런 다음 PostDetail 컴포넌트 내에서 액세스하여 해당 블로그 게시물 콘텐츠를 가져와 표시할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 매개변수를 사용하여 응용 프로그램에서 보다 유연하고 유지 관리 가능한 라우팅 로직을 만들 수 있습니다. 각 가능한 값에 대해 개별 라우트를 하드코딩할 필요 없이 동적 데이터를 처리할 수 있기 때문에 응용 프로그램이 성장함에 따라 더 확장 가능하고 유지 관리하기 쉬워집니다.\n\n루트 매개변수에 액세스하기\n\n루트 매개변수는 URL 경로에 정의된 루트 매개변수의 값을 액세스할 수 있습니다. 이러한 후크는 useParams 또는 match.params와 같은 React Router 후크를 사용하여 구성 요소 내에서 액세스할 수 있습니다.\n\n함수형 구성 요소에서 useParams 후크를 사용하세요 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { useParams } from \"react-router-dom\";\n\nconst ComponentName = () =\u003e {\n  const { parameterName } = useParams();\n  // parameterName에 접근\n};\n```\n\n에러 처리 및 모범 사례:\n\n모든 애플리케이션에서 라우팅 오류와 같은 404 오류 또는 잘못된 경로와 관련된 오류 처리를 고려하는 것이 중요합니다.\n\n에러 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 404 페이지 구현: 알 수 없는 경로가 발생했을 때 특정 컴포넌트를 디자인해주세요.\n- 기본 경로로 리다이렉트: 알려진 경로로 사용자를 리다이렉션하여 예비 메커니즘을 고려해주세요.\n- 명확한 오류 메시지 제공: 네비게이션 오류에서 복구하는 방법을 안내하기 위해 유용한 메시지를 사용해주세요.\n\n![이미지](/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png)\n\n효과적인 라우트 구성\n\n- 관련 라우트 그룹화: 논리적으로 연결된 라우트를 그룹화해주세요 (예: /products, /products/new, /products/:productId).\n- 라우트 파일 모듈화: 큰 애플리케이션의 경우 기능 또는 앱의 섹션에 따라 라우트 구성을 별도 파일로 분리해주세요.\n- 지연 로딩으로 코드 분할: 대규모 애플리케이션의 초기 로딩 시간을 개선하기 위해 요청에 따라 라우트를 로드해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공식 문서\n\n더 많은 기능과 가능성에 대해 자세히 알아보려면 공식 리액트 라우터 문서를 확인해보세요: [링크](https://reactrouter.com/)\n","ogImage":{"url":"/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png"},"coverImage":"/assets/img/2024-05-01-ReactRouterNavigateYourAppswithEase_0.png","tag":["Tech"],"readingTime":5},{"title":"React 19 Beta 릴리스, 새로운 기능 소개 및 정리","description":"","date":"2024-05-01 17:45","slug":"2024-05-01-React19BetaReleasedWhatYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png)\n\n지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\n\n## 액션\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\n\n예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\n\n```js\n// 액션 이전\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, setIsPending] = useState(false);\n\n  const handleSubmit = async () =\u003e {\n    setIsPending(true);\n    const error = await updateName(name);\n    setIsPending(false);\n    if (error) {\n      setError(error);\n      return;\n    } \n    redirect(\"/경로\");\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        업데이트\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\n\n```js\n// Actions에서 대기 상태 사용하기\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSubmit = async () =\u003e {\n    startTransition(async () =\u003e {\n      const error = await updateName(name);\n      if (error) {\n        setError(error);\n        return;\n      } \n      redirect(\"/path\");\n    })\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        Update\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\n\n관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동작은 데이터 제출을 자동으로 처리해줍니다:\n\n- 보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\n- 낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\n- 오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\n- 폼: 이제 `form` 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\n\nReact 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 `form` 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\n\nReact 19에서 위 예제는 간단하게 변경될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// \u003cform\u003e 작업 및 useActionState 사용하기\nfunction ChangeName({ name, setName }) {\n  const [error, submitAction, isPending] = useActionState(\n    async (previousState, formData) =\u003e {\n      const error = await updateName(formData.get(\"name\"));\n      if (error) {\n        return error;\n      }\n      redirect(\"/path\");\n    }\n  );\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cinput type=\"text\" name=\"name\" /\u003e\n      \u003cbutton type=\"submit\" disabled={isPending}\u003e업데이트\u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n# 새로운 훅: useActionState\n\nReact 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\n\n```js\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) =\u003e {\n  const error = await updateName(newName);\n  if (error) {\n    // 작업의 결과로 어떤 것이든 반환할 수 있습니다.\n    // 여기서는 오직 에러만 반환합니다.\n    return error;\n  }\n  \n  // 성공 처리\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useActionState` 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\n\n# React DOM: form 액션\n\nReact 19의 새로운 `form` 기능에 액션도 통합되어 있습니다. `form`, `input`, 그리고 `button` 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\n\n```js\n\u003cform action={actionFunction}\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`form`이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 `form`을 재설정합니다. `form`을 수동으로 재설정해야 하는 경우, 새 요청 `form` 재설정 React DOM API를 호출할 수 있습니다.\n\n# React DOM: 새로운 훅: useFormStatus\n\n디자인 시스템에서 `form`에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\n\n```js\nimport {useFormStatus} from 'react-dom';\n\nfunction DesignButton() {\n  const {pending} = useFormStatus();\n  return \u003cbutton type=\"submit\" disabled={pending} /\u003e\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useFormStatus`는 부모 `form`의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\n\n# 새로운 훅: useOptimistic\n\n데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 `useOptimistic`라는 새로운 훅이 추가되었습니다:\n\n```js\nfunction ChangeName({currentName, onUpdateName}) {\n  const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n\n  const submitAction = async formData =\u003e {\n    const newName = formData.get(\"name\");\n    setOptimisticName(newName);\n    const updatedName = await updateName(newName);\n    onUpdateName(updatedName);\n  };\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cp\u003eYour name is: {optimisticName}\u003c/p\u003e\n      \u003cp\u003e\n        \u003clabel\u003eChange Name:\u003c/label\u003e\n        \u003cinput\n          type=\"text\"\n          name=\"name\"\n          disabled={currentName !== optimisticName}\n        /\u003e\n      \u003c/p\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useOptimistic` 훅은 `updateName` 요청이 진행 중일 때 즉시 `optimisticName`을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 `currentName` 값으로 전환됩니다.\n\n# 새 API: use\n\nReact 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: `use`.\n\n예를 들어, `use`로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {use} from 'react';\n\nfunction Comments({commentsPromise}) {\n  // `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\n  const comments = use(commentsPromise);\n  return comments.map(comment =\u003e \u003cp key={comment.id}\u003e{comment}\u003c/p\u003e);\n}\n\nfunction Page({commentsPromise}) {\n  // Comments에서 `use`가 일시 중단되면\n  // 이 Suspense 경계가 표시됩니다.\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cComments commentsPromise={commentsPromise} /\u003e\n    \u003c/Suspense\u003e\n  )\n}\n```\n\n렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\n\n렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\n\n수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\n\n```js\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\n\nfunction Heading({children}) {\n  if (children == null) {\n    return null;\n  }\n  \n  // 일찍 반환으로 인해 useContext로 동작하지 않습니다.\n  const theme = use(ThemeContext);\n  return (\n    \u003ch1 style={{color: theme.color}}\u003e\n      {children}\n    \u003c/h1\u003e\n  );\n}\n```\n\nuse API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\n\n자세한 정보는 use에 대한 문서를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref을 속성으로 사용하기\n\nReact 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\n\n```js\nfunction MyInput({placeholder, ref}) {\n  return \u003cinput placeholder={placeholder} ref={ref} /\u003e\n}\n\n//...\n\u003cMyInput ref={ref} /\u003e\n```\n\n새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 'Context'를 제공자로 렌더링하기\n\nReact 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\n\n```js\nconst ThemeContext = createContext('');\n\nfunction App({children}) {\n  return (\n    \u003cThemeContext value=\"dark\"\u003e\n      {children}\n    \u003c/ThemeContext\u003e\n  );  \n}\n```\n\n나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref에 대한 정리 함수\n\n이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\n\n```js\n\u003cinput\n  ref={(ref) =\u003e {\n    // ref 생성\n\n    // 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\n    return () =\u003e {\n      // ref 정리\n    };\n  }\n/\u003e\n```\n\n컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\n\n```js\n- \u003cdiv ref={current =\u003e (instance = current)} /\u003e\n+ \u003cdiv ref={current =\u003e {instance = current} /\u003e\n```\n\n원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\n\n# useDeferredValue 초기 값\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 useDeferredValue에 initialValue 옵션을 추가했습니다:\n\n```js\nfunction Search({deferredValue}) {\n  // 초기 렌더링 시 값은 ''입니다.\n  // 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\n  const value = useDeferredValue(deferredValue, '');\n  \n  return (\n    \u003cResults query={value} /\u003e\n  );\n}\n```\n\ninitialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\n\n# 문서 메타데이터 지원\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML에서는 `title`, `link`, `meta`와 같은 문서 메타데이터 태그를 문서의 `head` 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 `head`를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 `head`를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\n\nReact 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\n\n```js\nfunction BlogPost({post}) {\n  return (\n    \u003carticle\u003e\n      \u003ch1\u003e{post.title}\u003c/h1\u003e\n      \u003ctitle\u003e{post.title}\u003c/title\u003e\n      \u003cmeta name=\"author\" content=\"Josh\" /\u003e\n      \u003clink rel=\"author\" href=\"https://twitter.com/joshcstory/\" /\u003e\n      \u003cmeta name=\"keywords\" content={post.keywords} /\u003e\n      \u003cp\u003e\n        Eee equals em-see-squared...\n      \u003c/p\u003e\n    \u003c/article\u003e\n  );\n}\n```\n\nReact가 이 컴포넌트를 렌더링할 때 `title`, `link`, `meta` 태그를 찾아서 자동으로 문서의 `head` 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":11},{"title":"Node.js 애플리케이션을 디버깅하는 방법","description":"","date":"2024-05-01 17:44","slug":"2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png\" /\u003e\n\n이 튜토리얼에서는 Node.js 애플리케이션 코드를 디버깅하는 가장 쉽고 효율적인 방법을 배웁니다.\n\n그럼 시작해봅시다.\n\n이 튜토리얼의 비디오 버전을 보고 싶나요? 아래 비디오를 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적으로 우리가 Node.js 애플리케이션을 디버깅하는 방법\n\n만약 우리가 어떤 Node.js 애플리케이션을 디버깅하고 싶다면, 보통 디버깅하려는 코드에 console.log 문을 추가하여 어떤 변수의 값을 찾아내려고 합니다.\n\n이 방법은 작동하지만 출력한 값을 보려면 계속 콘솔 로그를 확인해야 합니다.\n\n하지만 콘솔에 출력된 데이터가 중첩 객체를 포함하거나 많은 데이터인 경우 console.log를 사용하는 것은 실용적이지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 좋은 방법이 있어요.\n\n# 코드 디버깅을 위해 Debugger 추가하기\n\n대신에 우리는 디버그하고 싶은 코드에 debugger; 문을 추가할 수 있어요.\n\n아래 코드에서 보듯이 Express.js API 라우트를 가지고 사용자를 등록하는 경우를 가정해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// controllers/auth.js\n\nconst register = async (req, res) =\u003e {\n  try {\n    const { email, password } = req.body;\n    const existingUser = await User.findOne({\n      email,\n    });\n    if (existingUser) {\n      return res.status(400).send('이미 등록된 사용자가 해당 이메일로 존재합니다');\n    }\n    // 추가 코드\n    return res.status(201).send();\n  } catch (error) {\n    console.log(error);\n    return res\n      .status(500)\n      .send('새 사용자 등록 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n  }\n};\n\nmodule.exports = { register };\n\n// routes/auth.js\nconst { register } = require('../controllers/auth');\n\nconst Router = express.Router();\n\nRouter.post('/api/register', register);\n```\n\n그리고 사용자 등록시 문제가 발생하여 register 함수 코드를 디버그하려고 합니다.\n\n이 경우, 다음과 같이 register 함수 코드 내에 debugger; 문을 추가하면됩니다:\n\n```js\nconst register = async (req, res) =\u003e {\n  try {\n    const { email, password } = req.body;\n    debugger;\n    const existingUser = await User.findOne({\n      email,\n    });\n    if (existingUser) {\n      return res.status(400).send('이미 등록된 사용자가 해당 이메일로 존재합니다');\n    }\n    // 추가 코드\n    return res.status(201).send();\n  } catch (error) {\n    console.log(error);\n    return res\n      .status(500)\n      .send('새 사용자 등록 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 디버깅을 위한 애플리케이션 실행 방법\n\n일반적으로, Node.js 애플리케이션을 실행하려면 다음 명령을 실행합니다:\n\n```js\nnode index.js\n```\n\n하지만 대신에, 다음 명령을 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n노드를 검사하려면 index.js를 입력하세요.\n```\n\n여기에서는 단순히 inspect 키워드를 추가했습니다.\n\n위 명령을 실행하면 다음과 같이 출력이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 출력에서 디버거가 연결된 것을 확인할 수 있어요, 이제 코드 디버깅을 시작할 수 있어요.\n\n크롬 브라우저를 열고 브라우저 URL에 chrome://inspect를 입력하세요.\n\n아래와 같은 출력이 나타날 거에요:\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 `node inspect index.js` 명령을 실행하여 inspecting을 시작했으니, 원격 대상 섹션 아래에 새로운 대상 항목이 표시된 것을 볼 수 있어요.\n\n그럼, 표시된 파란색 inspect 링크를 클릭하면 아래 이미지처럼 새로운 브라우저 개발 도구가 열릴 거에요:\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_3.png)\n\n위 이미지의 오른쪽 패널에서 볼 수 있듯이, 디버거 일시 중지 메시지가 표시되고 디버깅 제어가 코드의 첫 줄에 있는 것을 확인할 수 있어요 (하이라이트된 노란색 줄로 확인 가능합니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 코드의 첫 번째 줄부터 디버깅을 시작하려는 것은 원하지 않습니다. 대신, 등록 코드만 디버깅하려고 합니다. 아래 디버거 일시 중지 메시지 위에 표시된 파란 삼각형 아이콘을 클릭해주세요:\n\n![Debug icon](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_4.png)\n\n지금이 창을 닫지 마세요. 대신에 Postman을 사용하여 응용 프로그램에서 사용자를 등록하거나 API 호출을 해보세요. 그렇게 하면 이전에 추가한 /register route 핸들러 코드가 실행될 것입니다.\n\n![API call](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 새 계정 만들기 버튼을 클릭하면 자동으로 debugger; 문이 추가된 코드로 리디렉션됩니다.\n\n이제 코드를 줄 단위로 디버깅하고 각 변수의 값을 볼 수 있으며 디버깅 중에 문제를 찾아 수정할 수 있습니다.\n\n# 디버깅 중 변수 액세스하기\n\n때로는 디버깅 중에 마우스를 가리키면 실제 값이 표시되는 변수가 너무 길어서 많은 속성을 가진 객체일 수 있습니다. 그래서 간단하게 마우스 오버로는 쉽게 볼 수 없을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 디버거가 계속 활성화된 채로 콘솔 탭을 열고 우리가 보고 싶은 변수의 이름을 입력할 수 있어요. 이 과정은 아래 GIF에서 확인할 수 있어요:\n\n![예시 이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_6.png)\n\n이렇게 우리는 Node.js 어플리케이션 코드를 쉽게 디버깅할 수 있어요.\n\n# 디버깅을 위한 스크립트 작성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널에서 매번 node inspect index.js 명령어를 수동으로 입력하기 싫다면, package.json 파일 안에 아래와 같이 새로운 디버그 스크립트를 생성할 수 있어요:\n\n```js\n\"scripts\": {\n    \"start\": \"node index.js\",\n    \"debug\": \"node inspect index.js\",\n    \"dev\": \"nodemon index.js\"\n},\n```\n\n그래서 이제 npm run debug 명령어를 실행하여 애플리케이션을 디버그 모드로 시작할 수 있어요.\n\n# 간단한 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js 애플리케이션을 디버깅하려면 다음 단계를 따라야합니다:\n\n- 디버깅하려는 코드 내에 디버거 문을 추가합니다.\n- node inspect index.js 또는 node inspect server.js 명령을 실행하여 디버그 모드로 애플리케이션을 시작합니다.\n- Chrome 브라우저에서 URL chrome://inspect에 액세스합니다.\n- 원격 대상 섹션 아래의 inspect 링크를 클릭합니다.\n- index.js 또는 server.js 파일의 첫 줄부터 디버깅을 시작하고 싶지 않다면 파란 삼각형 아이콘을 클릭합니다.\n- debugger; 문이 추가된 곳에서 코드를 트리거하는 API 호출 또는 작업을 수행합니다.\n- 이렇게하면 코드를 줄 단위로 디버깅하여 문제를 찾을 수 있습니다.\n\n# 읽어 주셔서 감사합니다\n\n이 튜토리얼은 여기까지입니다. 새로운 것을 배우셨기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 튜토리얼의 비디오 버전을 시청하고 싶으신가요? 이 비디오를 확인해보세요.\n\n만일 자바스크립트, ES6+, 리액트, 그리고 노드.js를 쉽게 이해할 수 있는 내용으로 습득하고 싶다면, 제 유튜브 채널을 확인해보세요. 구독하기를 잊지 마세요.\n\n정기적인 자바스크립트, 리액트, 그리고 노드.js 콘텐츠로 계속해서 최신 소식을 받고 싶다면, 링크드인에서 저를 팔로우하세요.\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_7.png)","ogImage":{"url":"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png","tag":["Tech"],"readingTime":6},{"title":"거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스","description":"","date":"2024-05-01 17:41","slug":"2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions","content":"\n\n## 거대한 Nx 모노 레포 유지 및 확장에 대한 주관적인 접근\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png)\n\n- 거대한 Nx의 규칙\n  - 프로젝트 유형\n  - 재현 가능한 생성\n  - 일관된 모노 레포\n- 당신의 워크스페이스 생성해봐요\n  - 1. 규칙 정의하기\n  - 2. create-huge-nx CLI 사용하기\n- 더 많은 프리셋\n- 마지막으로 생각할 것들\n\n여러 조직을 Nx 모노 레포로 이전하고 유지 관리한 후, 각 주요 Nx 버전마다 새로운 리포지토리를 만들어 기존 리포를 모방하여 구성 파일을 비교하고 최신 Nx 버전과 일치하는지 확인했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 원본을 반영하는 완전한 리포를 다시 만드는 것은 많은 노동이 필요했습니다. 처음에는 Bash 스크립트를 사용했고, 그 다음으로는 Node.js 스크립트를 사용했습니다. 최종적으로는 HugeNx를 개발했습니다. 이는 구성 파일에서 워크스페이스를 생성하는 사용자 지정 Nx 프리셋입니다.\n\n더 깊게 생각해 본 결과, 저는 단순히 워크스페이스를 생성하기 위한 파일을 만드는 것이 아니라, 워크스페이스 규칙을 설명하고 다른 목적에도 활용할 수 있는 파일을 만들고 있음을 깨달았습니다.\n\n# HugeNx의 규칙\n\n이 라이브러리의 주요 개념은 HugeNx의 규칙 파일입니다. 이 파일은 Nx 워크스페이스에 대해 내린 모든 관례적인 결정을 그룹화한 구성 파일입니다. 이 파일은 작업 공간이 어떻게 보이는지 설명할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_1.png](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_1.png)\n\nHugeNx의 Conventions 파일에 대상 워크스페이스에 관한 모든 정보가 들어 있다면, 새로운 워크스페이스를 처음부터 생성하거나 기존 워크스페이스를 유지할 수 있습니다.\n\n## 프로젝트 유형\n\n저는 통합하고자 하는 첫 번째 주요 규칙은 Nx 프로젝트 유형 개념입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx 워크스페이스를 구성하는 여러 가지 자료들을 탐색하면, 라이브러리를 범위 또는 유형별로 분류하고 경계를 정의하는 태그를 만드는 방법에 대한 상세한 설명을 만나게 될 거에요:\n\n- 코드 구조화 및 명명 규칙\n- 라이브러리 유형\n- 도메인 주도 설계\n\n하지만 저는 항상 이 ProjectTypes 목록을 구체적으로 지정하는 중심화된 방법이 부족했어요. 프로젝트를 생성할 때 소스 생성기 및 관련 기술과의 링크를 잃게 돼버리거든.\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 그 정보를 유지하고 싶었던 이유입니다. HugeNx의 컨벤션을 활용하면 프로젝트를 인식할 수 있습니다. 왜냐하면 그 프로젝트들은 당신이 지정한 규칙을 따를 것이기 때문이죠.\n\n## 재현 가능한 생성\n\nNx로 프로젝트를 시작하면 모든 것이 깨끗하고 일관되게 정렬됩니다. 그러나 시간이 지나면서 우리는 마이그레이션을 적용하고 사용자 정의 생성기를 만들며, 설정을 수동으로 수정하게 됩니다. 모든 이것이 개발자의 교체와 함께 누적되면 최종적으로는 좋지 않은 상황이 발생할 수 있습니다.\n\n이것은 특히 인프라 수준에서 인프라 구성 요소로 코드를 사용하는 개념과 함께 IT에서 해결하려는 일반적인 도전 과제입니다. Ansible과 같은 도구를 사용하면 스크립트와 구성 파일에서 전체 인프라를 초기화하고 다시 구성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx를 사용하면 프리셋 목록을 사용할 수 있지만 하드코딩되어 있습니다. 각각에는 몇 가지 옵션이 있지만 더 고급 워크스페이스를 생성하는 데 충분하지 않습니다.\n\n더 고급 워크스페이스를 만들고 싶다면 사용자 정의 프리셋을 만들어야 합니다. 이것은 씨앗을 생성하는 데 유용하지만 비교, 데모, 또는 워크샵을 위해 빠르게 워크스페이스를 생성하는 데는 번거로울 수 있습니다.\n\n그래서 저는 HugeNx의 컨벤션을 사용하여 Nx 워크스페이스를 생성할 수 있는 사용자 정의 Nx 프리셋을 만들기로 결정했습니다. 여러분은 자체 프리셋을 만들거나 유지할 필요가 없습니다!\n\n![Reproducible Nx Workspace](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx 버전에 맞게 전체 리포지토리를 다시 생성할 수 있습니다. 변경된 내용을 비교하거나 현재 Nx 프리셋을 생성하는 방식을 단순화하는 데 도움이 됩니다.\n\nHugeNx는 모든 Nx 플러그인을 지원하므로 모든 Nx 프리셋을 쉽게 재현하고 사용자 정의 프리셋을 만들 수 있습니다.\n\n## 일관성 있는 Monorepo\n\n처음부터 리포지토리를 생성하는 것은 좋지만 오랜 기간 유지하는 것이 더 좋지 않나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHugeNx의 규칙을 통한 주요 목표는 귀하의 작업 공간이 어떻게 보이고 작동해야 하는지 설명하는 가디언, 관리인이 되는 것입니다.\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_4.png)\n\nEslint 규칙:\nEslint와 같은 도구를 활용하여 해당 파일을 읽고 규칙을 생성하여 다음을 시행할 수 있습니다:\n\n- 각 프로젝트가 명명 규칙을 따르는지 확인\n- 작업 공간 구조를 확인\n- 각 프로젝트가 올바르게 하나의 ProjectType과 관련되어 있는지 확인\n- nx.json 생성기의 옵션을 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 발견하기:\nNx Project Crystal에서 제공하는 프로젝트 추론 기능을 통해 네이밍 규칙에 따라 손쉽게 Nx 프로젝트를 발견할 수 있습니다.\n\n또한 프로젝트 유형 네이밍 규칙과 일치하는 하나의 Nx 플러그인을 생성하고 프로젝트 구성을 자동으로 연결할 수도 있습니다!\n\n마이그레이션:\n특정 Nx 버전을 위해 새로운 작업 공간을 처음부터 다시 생성할 수 있다는 사실과 관련하여, 이제 최신 Nx로 작업 공간을 손쉽게 생성하고 기존 작업 공간과 비교할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 타입 무한히 변경하고 싶다면 Betterer와 같은 도구를 사용할 수도 있어요. 이를 통해 당신의 저장소를 HugeNx의 규칙에 맞게 단계적으로 이동할 수 있어요.\n\n프로젝트 타입 생성기:\n복잡하고 특수한 생성기를 만들 필요가 없어요. 프로젝트 타입을 읽고 해당 내용으로 프로젝트를 생성해주는 생성기를 만들 수 있어요.\n\n# 워크스페이스 생성해볼까요?\n\n새 TypeScript 파일을 생성해보면서 구체적인 예시로 시작해봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 규칙 정의하기\n\n호텔을 관리하는 풀스택 애플리케이션을 만들기 위한 작업 공간을 포함하는 huge-angular-full-stack.conventions.ts 파일을 만들 수 있습니다:\n\n```js\nexport default {\n  version: '1.0',\n  generators: {\n    '@nx/angular:application': { //\u003c-- 생성기 식별자\n      linter: 'eslint', //\u003c-- 옵션 목록\n      style: 'css',\n      unitTestRunner: 'jest',\n      bundler: 'esbuild',\n      e2eTestRunner: 'playwright',\n      inlineStyle: true,\n      inlineTemplate: true,\n    },\n    '@nx/angular:library': {\n      linter: 'eslint',\n      unitTestRunner: 'jest',\n    },\n    '@nx/angular:component': {\n      style: 'css',\n    },\n    '@nx/js:lib': {\n      bundler: 'swc',\n    },\n  },\n  projectTypes: {\n    'global:angular:app': { //\u003c-- 프로젝트 유형 식별자\n      projectPattern: '*-app', //\u003c-- 규칙과 일치하는 프로젝트 명칭\n      generators: [{ generator: '@nx/angular:application' }], //\u003c-- 해당 유형의 프로젝트를 생성하는 데 사용되는 생성기 목록\n    },\n    'backend:api': {\n      projectPattern: '*-api',\n      generators: [{ generator: '@nx/nest:application' }],\n    },\n    'global:angular:lib:data-access': {\n      projectPattern: '*-data-access',\n      generators: [{ generator: '@nx/angular:library' }],\n    },\n    'global:angular:lib:feature': {\n      projectPattern: '*-feature',\n      generators: [{ generator: '@nx/angular:library' }],\n    },\n    'global:angular:lib:ui:storybook': { //\u003c-- 이 프로젝트 유형은 라이브러리를 생성한 다음 storybook 구성을 생성함\n      projectPattern: '*-ui',\n      generators: [{ generator: '@nx/angular:library' }, { generator: '@nx/storybook:configuration', options: { uiFramework: '@storybook/angular' } }],\n    },\n    'global:ts:lib:utils': {\n      projectPattern: '*-utils',\n      generators: [{ generator: '@nx/js:lib', options: { bundler: 'swc' } }],\n    },\n  },\n  workspace: { //\u003c-- 작업 공간은 폴더와 프로젝트로 구성됨\n    apps: {\n      //\u003c-- apps 폴더 생성\n      'hotel-app': 'global:angular:app', //\u003c-- global:angular:app 프로젝트 유형을 이용하여 hotel-app 프로젝트 생성\n      'hotel-api': { //\u003c-- backend:api 프로젝트 유형을 이용하여 hotel-api 프로젝트를 생성하고 추가 옵션을 사용\n        projectType: 'backend:api',\n        options: {\n          '@nx/angular:remote': { frontendProject: 'hotel-app' },\n        },\n      },\n    },\n    libs: { //\u003c-- libs 폴더 생성\n      guest: { //\u003c-- guest 폴더 생성\n        'data-access': 'global:angular:lib:data-access', //\u003c-- global:angular:lib:data-access 프로젝트 유형을 이용하여 guest-data-access 프로젝트 생성\n        'booking-feature': 'global:angular:lib:feature', //\u003c-- global:angular:lib:feature 프로젝트 유형을 이용하여 guest-booking-feature 프로젝트 생성\n        'feedback-feature': 'global:angular:lib:feature', //\u003c-- global:angular:lib:feature 프로젝트 유형을 이용하여 guest-feedback-feature 프로젝트 생성\n      },\n      room: { //\u003c-- room 폴더 생성\n        'data-access': 'global:angular:lib:data-access',\n        'list-feature': 'global:angular:lib:feature',\n        'request-feature': 'global:angular:lib:feature',\n      },\n      shared: { //\u003c-- shared 폴더 생성\n        ui: { //\u003c-- global:angular:lib:ui:storybook 프로젝트 유형을 이용하여 shared-ui 프로젝트를 생성하고 추가 옵션을 사용\n          projectType: 'global:angular:lib:ui:storybook',\n          options: {\n            '@nx/storybook:configuration': { project: 'shared-ui' },\n          },\n        },\n        utils: 'global:ts:lib:utils',\n      },\n    },\n  }\n};\n```\n\n기본 생성기 옵션\nNx에서 이미 사용 가능한 것이며, 워크스페이스에서 사용 중인 각 생성기의 기본 옵션을 정의할 수 있는 nx.json 파일을 구성함으로써 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx API 문서에서 모든 Nx 옵션을 찾을 수 있어요.\n\n프로젝트 유형 목록\n여기서는 기술, 도메인, 라이브러리 유형, 팀 등을 기반으로 하는 ProjectType 목록을 정의할 거에요.\n\n각 ProjectType에 대해 사용해야 하는 생성기와 주변 규칙을 모두 지정할 거예요. 기본 생성기 옵션을 사용하며 필요하면 추가 옵션을 추가할 수 있어요.\n\n작업 영역 구조\n마지막으로 작업 영역 레이아웃 내에서 프로젝트 목록을 정의할 거에요. 각 프로젝트는 특정 ProjectType에 의해 연결되고 설명될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 섹션은 생성에는 필요하지만 유지에는 필요하지 않습니다.\n\n## 2. create-huge-nx CLI 사용하기\n\n작업 영역을 생성하려면 이제 다음과 같이 HugeNx CLI를 사용할 수 있습니다:\n\n```js\nnpx create-huge-nx@latest my-workspace --hugeNxConventions=./huge-angular-full-stack.conventions.ts --nxCloud skip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 작업 공간을 생성할 것입니다:\n\n```js\nmy-workspace/\n├─ apps/\n│   ├─ hotel-api/\n│   ├─ hotel-api-e2e/\n│   ├─ hotel-app/\n│   └─ hotal-app-e2e/\n├── libs/\n│   ├─ guest/\n│   │   ├─ data-access\n│   │   ├─ booking-feature\n│   │   └─ feedback-feature\n│   ├─ room/\n│   │   ├─ data-access\n│   │   ├─ list-feature\n│   │   └─ request-feature\n│   └─ shared/\n│       ├─ ui\n│       └─ utils\n├─ nx.json\n├─ package.json\n├─ jest.config.json\n└─ huge-nx.conventions.ts\n```\n\n기본적으로는 최신 버전의 Nx가 사용될 것이지만, --nxVersion으로 특정 Nx 버전으로 작업 공간을 생성할 수 있습니다:\n\n```js\nnpx create-huge-nx@latest my-workspace --nxVersion 17 --hugeNxConventions=./huge-angular-full-stack.conventions.ts --nxCloud skip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 많은 프리셋\n\n이제는 새로운 huge-nx.conventions.ts 파일을 소개함으로써 다양한 유형의 저장소를 간단히 만들 수 있습니다. 이 방식은 Nx의 모든 프리셋을 포괄하는 뿐만 아니라 Nx 문서의 라이브러리 유형 섹션에 설명된 대로 각 프로젝트 유형을 자세하게 설명할 수 있도록 합니다.\n\n예를 들어, @angular-architects/ddd 패키지의 유형을 정의하고 이 정의를 사용하여 워크스페이스를 생성할 수 있습니다. 이 유연성을 통해 Nx의 강력하고 확장 가능한 도구 생태계를 활용하여 프로젝트의 특정 요구 사항에 맞는 매우 사용자 정의된 설정을 제공할 수 있습니다.\n\n저는 ChatGPT를 사용하여 컨벤션 파일을 생성했습니다. 파일의 예시를 제공하고 특정한 목적을 설명했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Nx 워크스페이스를 나타냅니다.\n- Angular 생성기를 사용해야 합니다.\n- 호텔 비즈니스를 나타냅니다.\n- 풀 스택 앱이어야 합니다.\n\n# 마지막으로\n\nHugeNx의 규칙은 특히 대규모 및 계속 발전 중인 단일 레포지토리를 관리하는 사람들을 위해 Nx 환경에서 유용한 도구를 제공하기 위해 만들어졌습니다.\n\n워크스페이스 설정을 자동화하고 표준화함으로써 프로젝트 생성 및 유지보수와 관련된 복잡성을 줄이는 데 도움이 됩니다. 이 접근 방식은 이주 과정에서 시간과 노력을 절약하는 데 도움이 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 여러분의 피드백을 기다리며 HugeNx를 개선하고자 합니다. 개발 툴킷에 귀한 추가가 될 수 있기를 희망합니다. 여러분의 아이디어와 경험이 이 도구를 완성하는 데 중요합니다. 그러니 의견을 공유해주세요.\n\n곧 다시 만나요! 🚀\n\n# 관련 정보\n\n# 간단하게 이해하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제발 공개 커뮤니티인 In Plain English의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 글쓴이를 박수로 응원하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png"},"coverImage":"/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png","tag":["Tech"],"readingTime":10},{"title":"React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법","description":"","date":"2024-05-01 17:40","slug":"2024-05-01-HowtoSkipReactuseEffectonInitialRender","content":"\n\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png)\n\n많은 React 개발자들이 클래스 컴포넌트보다 함수 컴포넌트를 선호합니다. 함수 컴포넌트는 더 작고, 자체 상태를 관리하는 자식 UI 요소를 구성하는 기능을 제공합니다. 그러나 몇 가지 단점이 있습니다. 최근 버그 찾기 세션에서 한 가지 문제점은 함수 컴포넌트의 초기 렌더 기능을 제어할 수 없다는 것이었습니다. 폼 페이지의 첫 번째 렌더에서 useEffect 호출을 우회하지 않아 발생한 오류를 발견했을 때 이것이 분명해졌습니다.\n\n## useEffect와 어떤 문제가 있었나요?\n\nuseEffect 훅은 React 개발자들이 컴포넌트 상태에 기반한 작업을 대기열에 넣을 수 있게 합니다. React는 JQuery와 같은 선행자들과 다르게 상태 유지(stateful) 또는 상태 없음(stateless) 컴포넌트를 구축할 수 있도록 허용합니다. 이러한 컴포넌트는 내부 상태 변수를 통해 사용자 상호작용과 데이터를 추적할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseEffect 훅은 상태를 가지고 있는 컴포넌트의 기능을 더 발전시킵니다. useEffect의 주요 부분은 작업을 수행하는 콜백 함수와 변경 사항을 감시할 상태 변수의 배열입니다. 상태 변수 중 하나라도 변경되면 콜백이 실행됩니다:\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_1.png)\n\n이 훅을 사용하면 상태 변경으로부터 작업을 트리거할 수 있지만 일부 제한 사항이 있습니다. 우리가 주로 다루는 주요 제한 사항은 useEffect 콜백이 초기 렌더링 중에 호출되어 앱에 의도치 않은 부작용을 일으킬 수 있다는 것입니다.\n\n## 멀티 셀렉트에서 제품 데이터 로드하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제와 해결책을 살펴보려면 사용자가 목록에서 항목을 선택하고 모든 항목의 정보를 볼 수 있는 페이지를 만드는 티켓을 받았다고 상상해보세요. 사용자는 초기 페이지 로드에 검색 창을 사용하여 임의의 쿼리 용어를 입력할 수 있습니다. 이 쿼리는 API 호출을 트리거하여 서버에서 연속되는 검색 용어 항목 컬렉션을 반환합니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_2.png\" /\u003e\n\n이 페이지의 상태를 설정하는 일반적인 방법은 검색 창을 제어 컴포넌트로 만드는 것입니다 (즉, 부모 페이지 컴포넌트가 이 입력 상태를 유지하고 쿼리 값을 다시 입력으로 보내 표시합니다) 그리고 입력에 대한 onChange 이벤트 핸들러를 갖는 것입니다. 불필요한 API 호출을 피하기 위해 입력에 debounce를 추가하여 키가 눌릴 때마다 API 호출을 방지할 수 있습니다. 쿼리는 제품에 대한 API 호출을 트리거할 useEffect 훅에 추가됩니다.\n\n이 프로세스의 요약은 다음과 같습니다: 사용자가 텍스트 입력란에 용어를 입력하면 입력이 쿼리 상태를 업데이트하고 쿼리 상태가 useEffect를 트리거하여 데이터를 얻기 위해 API에 요청을 보냅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_3.png)\n\n이론적으로는 텍스트 입력란에 사용자가 입력할 때마다 API 호출을 하는 좋은 설정이 있습니다. 실제로 콘솔을 열면 페이지가 처음로드될 때 useState의 쿼리에 대한 기본값이 무엇이냐에 따라 쿼리 용어로 '정의되지 않음' 또는 빈 문자열과 함께 API 호출이 트리거됨을 볼 수 있습니다. useEffect가 일찍 호출되어 불필요하게 호출됩니다.\n\n## useRef를 사용하여 초기 렌더링 useEffect 호출 우회 방법\n\n문서에서 명확하지 않지만, 컴포넌트가 로드될 때 상태 변수들이 초기로 설정되면 useEffect 훅이 값이 변경되거나 정의될 때 트리거되어 부작용을 일으킬 수 있습니다. 초기 렌더링에 대한 useEffect 동작을 우회해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떻게 해야 할까요? 제가 찾은 가장 좋은 방법은 useRef 훅을 사용하는 것입니다. 이 훅을 사용하면 상태와는 관련이 없는 값을 설정하고 참조할 수 있습니다. 그 문장의 마지막 부분이 중요한데요, 상태 변경은 다른 훅 및 컴포넌트가 어떻게 그리고 언제 다시 렌더링되는지에 영향을 미치게 됩니다.\n\n페이지가 초기 렌더링되었는지 여부를 확인하여 useEffect가 사용자 상호작용에서 호출되었는지 알아내고 싶습니다. 이를 위해 hasPageBeenRendered용 useRef 변수를 만들 수 있습니다. 그 후에 useRef 변수를 참조하는 조건부 래퍼로 useEffect 콜백을 감쌀 수 있습니다. 간단한 예는 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_4.png)\n\nReact 변수를 가져와서 useRef 변수를 초기화하고, useState로 쿼리 값을 초기화하고, API 호출 로직을 설정합니다. useRef의 초기 상태는 false이므로 useRef를 true로 설정하기 전에 API 호출을 우회합니다. 이후 API 호출 로직으로 들어가서 데이터베이스를 쿼리하여 다음 호출에 대한 정보를 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이 방식의 문제점\n\n이제 브라우저와 서버 콘솔에서 불필요한 호출과 오류가 사라져 좋은 결과를 거뒀네요. 그러나, 이것은 간단한 예제일 뿐입니다. 만약 우리가 초반 트리거를 방지하고 싶은 여러 useEffect 메소드가 있다면 어떻게 될까요?\n\n각각의 useEffect에 대해 별도의 useRef 변수를 생성할 수 있습니다. 각각의 useEffect가 초기 렌더링 시 호출되는 것을 막고 싶다면 우리는 각 useEffect에 대해 하나의 useRef를 생성할 수 있습니다. 이 방법도 가능하지만, 더 복잡한 로직이 들어갈수록 컴포넌트 헤더가 엉망이 될 것입니다.\n\n각 useEffect에 새로운 useRef를 추가하는 대신에, useRef 값을 다차원으로 만들어서는 어떨까요? 현재 useRef는 부울 값을 설정 및 업데이트하고 있습니다. 코드를 정리하기 위해 useRef 값을 해시로 설정하여 각 키가 다른 useEffect를 가리키도록 할 수 있습니다. 이렇게 보일 것입니다: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표현한 내용입니다.\n\n\n![How to Skip React useEffect on Initial Render](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_5.png)\n\n이러한 방법으로 중앙 useRef 변수로 모든 로직을 관리할 수 있어요. 이 작은 수정으로 함수 컴포넌트를 지저분하게 만들지 않으면서도 많은 useEffect를 관리할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png","tag":["Tech"],"readingTime":4}],"page":"153","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"153"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>