<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/71" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/71" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서 Rest 매개변수 사용하는 방법" href="/post/2024-05-17-WhatIstheRestParameterinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서 Rest 매개변수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서 Rest 매개변수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서 Rest 매개변수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트의 기본 타입과 참조 타입 이해하기" href="/post/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트의 기본 타입과 참조 타입 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트의 기본 타입과 참조 타입 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트의 기본 타입과 참조 타입 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 55 버전에 추가된 3가지 내용 정리" href="/post/2024-05-17-3ExcitingNewFeaturesinTypeScript55"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 55 버전에 추가된 3가지 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 55 버전에 추가된 3가지 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 55 버전에 추가된 3가지 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 라우트를 제대로 사용하는 방법 3가지" href="/post/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 라우트를 제대로 사용하는 방법 3가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 라우트를 제대로 사용하는 방법 3가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 라우트를 제대로 사용하는 방법 3가지</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="독일, 모든 비용을 통해 FFmpeg 보호하기" href="/post/2024-05-17-GermanyToProtectFfmpegAtAllCost"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="독일, 모든 비용을 통해 FFmpeg 보호하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="독일, 모든 비용을 통해 FFmpeg 보호하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">독일, 모든 비용을 통해 FFmpeg 보호하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아니요, 제가 줌에서 당신을 보고 싶지 않아요" href="/post/2024-05-17-NoIDontWanttoLookAtYouonZoom"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아니요, 제가 줌에서 당신을 보고 싶지 않아요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아니요, 제가 줌에서 당신을 보고 싶지 않아요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아니요, 제가 줌에서 당신을 보고 싶지 않아요</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈CTI 61의 텔레메트리" href="/post/2024-05-17-TelemetryinOpenCTI61"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈CTI 61의 텔레메트리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈CTI 61의 텔레메트리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오픈CTI 61의 텔레메트리</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SREF 랜덤 ID 코드 해석하는 방법" href="/post/2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SREF 랜덤 ID 코드 해석하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SREF 랜덤 ID 코드 해석하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SREF 랜덤 ID 코드 해석하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="암 치료에 대한 대응" href="/post/2024-05-17-ResponsetoCancerTreatment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="암 치료에 대한 대응" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-ResponsetoCancerTreatment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="암 치료에 대한 대응" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">암 치료에 대한 대응</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈 소스 모델, 온도 조정, 재순위 매기기 등 최신 LLM 반드시 읽어야 할 글들을 놓치지 마세요" href="/post/2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈 소스 모델, 온도 조정, 재순위 매기기 등 최신 LLM 반드시 읽어야 할 글들을 놓치지 마세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈 소스 모델, 온도 조정, 재순위 매기기 등 최신 LLM 반드시 읽어야 할 글들을 놓치지 마세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오픈 소스 모델, 온도 조정, 재순위 매기기 등 최신 LLM 반드시 읽어야 할 글들을 놓치지 마세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link posts_-active__YVJEi" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"자바스크립트에서 Rest 매개변수 사용하는 방법","description":"","date":"2024-05-17 20:26","slug":"2024-05-17-WhatIstheRestParameterinJavaScript","content":"\n\n## ES6 REST 문법\n\n![이미지](/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png)\n\n# 소개: REST 파라미터의 힘\n\n자바스크립트 세계는 끊임없이 발전하는 풍경 속에서, 코딩을 더 효율적이고 유연하며 재미있게 만들어주는 멋진 기능들로 가득 차있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nECMAScript 6 (ES6)에서 소개된 하나의 기능은 ...나머지 매개변수이며 ...rest 매개변수로도 쓰입니다. \n\n이 마법같은 구문을 사용하면 함수 인수를 하나의 배열로 쉽게 수집할 수 있습니다.\n\n시작하기 전에 REST와 ...나머지가 완전히 다른 개념임을 언급해야 합니다. REST(API와 관련된 REST)에 대해서는 이 기사들을 확인해주세요:\n\n이제 재미있는 이모지 예제를 활용하여 나머지 파라미터의 기능을 탐험해 봅시다. 어떻게 하는지 알고 있겠죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 자바스크립트의 ES6 Rest 파라미터로 미사일 발사\n\n...rest 파라미터는 자바스크립트 함수로 전달된 다양한 수의 인수를 처리하는 간단하면서도 강력한 방법입니다.\n\n여러 개의 이모지 인수를 받아들이는 함수가 있다고 상상해보세요. 이들을 모두 출력해야 할 때의 과제가 생겼다고 가정해 봅시다.\n\n...rest 파라미터를 사용하지 않으면 arguments 객체를 처리해야 할 것입니다. 그러나 ...rest 파라미터를 사용하면 보다 우아하게 처리할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction printEmojis(...emojis) {\n  emojis.forEach(emoji =\u003e console.log(emoji))\n}\n\nprintEmojis(\"🚀\", \"🌕\", \"👩‍🚀\")\n// 출력:\n// 🚀\n// 🌕\n// 👩‍🚀\n```\n\n이 예제에서 ...rest 파라미터는 모든 이모지들을 하나의 배열로 모아줍니다. 그리고 우리는 배열을 반복하여 각각을 개별적인 줄에 출력합니다.\n\n# 🧙‍♂️ Rest 파라미터와 구조 분해(Destructuring) 결합하기\n\nRest 파라미터를 destructuring과 결합하여 더욱 강력하게 사용할 수 있습니다. 이런 조합은 마치 마술처럼 보일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기술은 이모지 배열에서 특정 요소를 추출하고 별도로 처리할 수 있게 해줍니다. 이것이 어떻게 동작하는지 실습을 통해 살펴보겠습니다:\n\n```js\nfunction emojiParty(firstEmoji, ...otherEmojis) {\n  console.log(`첫 번째 이모지: ${firstEmoji}`)\n  console.log(`다른 이모지들: ${otherEmojis}`)\n}\n\nemojiParty(\"🎉\", \"🎈\", \"🎊\", \"🎁\")\n// 출력:\n// 첫 번째 이모지: 🎉\n// 다른 이모지들: 🎈,🎊,🎁\n```\n\n이 예제에서는 함수 인수를 구조 분해하여 첫 번째 이모지를 firstEmoji 변수에 할당합니다.\n\n그런 다음, ... rest 파라미터 구문을 사용하여 나머지 이모지를 otherEmojis 배열에 수집합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 마술 묘기로, 첫 번째 이모지와 나머지 이모지를 쉽게 나눠서 표시할 수 있어요.\n\n여러 개의 첫 번째 매개변수를 포함하고, 끝에 ...rest 구문만 사용하면 돼요.\n\n# 🔧 인수 객체의 단점을 수정하기\n\n나머지 매개변수는 특히 옛날 ES5 기능인 arguments 객체와 비교할 때 상쾌한 기운을 불어넣어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인수 개체와는 달리, 나머지 매개변수는 실제 배열이며 모든 유용한 배열 메서드를 사용할 수 있습니다.\n\n```js\nfunction printArguments() {\n  // 인수 객체를 배열로 변환\n  const argsArray = Array.from(arguments)\n  // 배열을 순환하며 각 인수를 출력\n  argsArray.forEach(arg =\u003e console.log(arg)); \n}\n\nprintArguments(\"🍔\", \"🍟\", \"🥤\")\n// 출력:\n// 🍔\n// 🍟\n// 🥤\n```\n\n인수 개체와는 달리 인수 개체의 forEach 메서드를 사용할 수 없습니다. 이는 열거 가능한 속성을 가진 객체가 아닌 배열류 객체이기 때문입니다.\n\n나머지 매개변수가 배열이므로 \"나머지\"의 사용은 훨씬 더 간단하고 즐거워집니다. 한번 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction sumEmojisLength(...emojis) {\n  return emojis.reduce((total, emoji) =\u003e total + emoji.length, 0);\n}\n\nconst totalLength = sumEmojisLength(\"🎂\", \"🥳\", \"🎈\", \"🎉\")\n\nconsole.log(`Total emoji length: ${totalLength}`)\n// Output: Total emoji length: 8\n// Each emoji has a string length of 2 characters, and 2×4 === 8\n```\n\n이 예시에서는 이모티콘 배열에 reduce 메서드를 사용하여 모든 이모티콘의 총 길이를 계산할 수 있습니다.\n\n나머지 매개변수를 사용함으로써, Array.from()을 사용하여 먼저 인자 객체를 배열로 변환할 필요 없이 번거로움을 줄일 수 있습니다.\n\nJavaScript의 화살표 함수 구문을 사용하면 이 코드가 더 짧아지면서도 여전히 매우 가독성이 높아집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst calculateEmojiLength = (...emojis) =\u003e emojis.reduce((total, emoji) =\u003e total + emoji.length, 0)\n\nconst totalLength = calculateEmojiLength(\"🎂\", \"🥳\", \"🎈\", \"🎉\")\n\nconsole.log(`Total emoji length: ${totalLength}`)\n// 출력: Total emoji length: 8\n// 각 이모지는 2개의 문자로 이루어져 있으며, 2×4 === 8\n```\n\n# 🤹 조작하기: 스프레드 연산자 + 나머지 매개변수\n\n나머지 매개변수의 동생인 스프레드 연산자도 세 개의 점 구문을 사용하지만 다른 목적을 가지고 있습니다.\n\n나머지 매개변수는 함수 인수를 배열로 수집하는 반면, 스프레드 연산자는 반대로 작용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n펼침 연산자(Spread)는 배열이나 객체를 개별 요소로 확장하거나 얕은 복사를 하는 데 사용됩니다.\n\n나머지 매개변수와 함께 사용되는 펼침 연산자는 데이터를 쉽게 조작하고 전달할 수 있는 강력한 동료를 만듭니다.\n\n다음 코드 예제에서 이들의 힘을 결합해 보겠습니다:\n\n```js\nconst mixEmojis = (...emojis) =\u003e emojis.join(\" \")\n\nconst partyEmojis = [\"🎉\", \"🎈\", \"🎁\"]\nconst celebration = mixEmojis(\"🥳\", ...partyEmojis, \"🎂\")\n\nconsole.log(`Celebration: ${celebration}`)\n// 출력: Celebration: 🥳 🎉 🎈 🎁 🎂\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 partyEmojis 배열 요소를 개별 인수로 mixEmojis 함수에 전달하기 위해 전개 연산자를 사용합니다.\n\n그런 다음 나머지 매개변수가 이를 단일 배열로 수집하고 문자열로 결합합니다. 축하할 일이네요!\n\n# 결론: ... 나머지 매개변수 활용하기\n\n우리가 보았듯이, 나머지 매개변수는 다양한 수의 함수 인수를 우아하게 처리할 수 있는 다재다능한 도구입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nES6 해체 및 전개 연산자와 ...rest 매개변수를 결합하여 더 나은, 더 간단한 코드를 작성할 수 있어요.\n\n물론, React 규칙을 따르고 매개변수로 객체를 전달하는 것이 좋아요. ...rest는 필요없어요!\n\n다른 쪽으로, Tailwind CSS와 함께 작업할 때 항상 간단한 classNames 함수가 필요해서 ... rest 구문을 매일 사용하고 있지만:\n\n```js\nconst classNames = (...args: string[]) =\u003e args.filter(Boolean).join(' ')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 아이디어는 문자열 목록을 전달하고, Prettier로 정렬된 Tailwind CSS 클래스 이름을 합치는 것입니다.\n\n만약 그 필터 트릭이 이해되지 않는다면, 왜 이것이 멋지다고 생각하는지 설명한 이전 게시물로 돌아가보세요.\n\n...나머지 매개변수의 마법을 받아들이고, 코드에 이 \"스놀랙스 구문\"을 뿌려넣어 코드를 휴식 시키는 것을 바랍니다!\n\n코딩을 즐기세요! 😴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 읽을 거리\n\n- Yug Shah이 GeeksforGeeks.org에서 나머지 매개변수에 대해 쓴 글을 참고해보세요.\n\n- 웹 관련 내용을 학습할 때 항상 MDN 문서를 먼저 참고합니다.\n\n- Dhanajay kumar이 Telerik에서 나머지(rest)에 대해 이야기합니다.","ogImage":{"url":"/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-WhatIstheRestParameterinJavaScript_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트의 기본 타입과 참조 타입 이해하기","description":"","date":"2024-05-17 20:25","slug":"2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript","content":"\n\nJavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\n\n원시 타입\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\n\n```js\n- Number: 1, 2.5, 100과 같은 숫자\n- String: \"hello\", \"123\"과 같은 문자열\n- Boolean: true 또는 false\n- Null: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\n- Undefined: 할당된 값이 없는 변수를 나타냄\n```\n\n변수에 원시 값을 할당할 때, 값을 복사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\nlet x = 10;\nlet y = x;\ny = 20;\nconsole.log(x); // 10\nconsole.log(y); // 20\n```\n\n참조형 타입\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\n\n```js\nlet obj1 = { name: \"Ali\" };\nlet obj2 = obj1;\nobj2.name = \"Reza\";\nconsole.log(obj1.name); // \"Reza\"\nconsole.log(obj2.name); // \"Reza\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가변이란 무엇을 의미합니까?\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\n\n```js\nlet person = { name: \"Ali\", age: 25 };\nperson.name = \"Reza\";\nconsole.log(person); // { name: \"Reza\", age: 25 }\n// 배열을 사용한 예시:\n\nlet numbers = [1, 2, 3];\nnumbers.push(4);\nconsole.log(numbers); // [1, 2, 3, 4]\n```\n\n불변이란 무엇을 의미합니까?\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\n\n문자열을 사용한 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet greeting = \"Hello\";\nlet newGreeting = greeting.replace(\"H\", \"J\");\nconsole.log(greeting); // \"Hello\"\nconsole.log(newGreeting); // \"Jello\"\n```\n\n왜 중요한가요?\n- 메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\n\n실용적인 팁:\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\n\n```js\n#### 객체의 깊은 복사:\nlet original = { name: \"Ali\", age: 25 };\nlet copy = JSON.parse(JSON.stringify(original));\ncopy.name = \"Reza\";\nconsole.log(original); // { name: \"Ali\", age: 25 }\nconsole.log(copy); // { name: \"Reza\", age: 25 }\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\n\n---\n\n이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"TypeScript 55 버전에 추가된 3가지 내용 정리","description":"","date":"2024-05-17 20:24","slug":"2024-05-17-3ExcitingNewFeaturesinTypeScript55","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png\" /\u003e\n\nTypeScript 세계에서는 항상 개발자 경험을 업그레이드하기 위해 새로운 기능들이 지속적으로 추가됩니다.\n\n오늘도 예외는 아닙니다. TypeScript 버전 5.5가 공식적으로 발표되었습니다!\n\n이 기사에서는 TypeScript의 이 새로운 장을 준비하는 3가지 혁신적인 기능을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거두 절미하고... 지금 시작해 봐요!\n\n## 1. 추론된 유형 예측\n\n이게 무슨 의미인지 살펴보기 전에, 유형 예측이 무엇인지 정의해 봅시다.\n\n다음은 어떤 입력의 유형을 문자열로 좁히는 유형 예측의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet x = \"test\"\n\n// `is` 키워드로 표시된 타입 예측자.\nfunction isString(variable: any): variable is string {\n  return typeof variable === \"string\"\n}\n\nif (isString(x)) {\n  console.log(x.trim())\n}\n```\n\n이제 타입 예측자에 대해 이해했으니, 유추된 부분은 어디에 있는 걸까요?\n\n인덱스 3에 하나의 null 값만 있는 숫자 배열을 상상해보세요.\n\n```js\nconst nums = [1, 2, 3, null, 5].filter((x) =\u003e x !== null)\n\n// nums = [1, 2, 3, 5]\n// 하지만 타입은 여전히 (number | null)[] 유지됩니다!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Null 값을 제외하기 위해 필터 함수를 적용했어요.\n- 필터링된 배열에 더 이상 null 값이 없으므로 nums의 타입이 number[]가 되기를 기대합니다.\n\n하지만 아쉽게도 현재 이것은 불가능하여 nums의 타입은 그대로 유지됩니다.\n\n하지만 TypeScript 5.5에서 이 문제가 해결됩니다!\n\nTS 5.5에서는 filter 함수가 결과 배열의 타입을 정확하게 추론하기 위해 암시적으로 타입 예측자를 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 유형 예측 함수가 실제로 어떻게 보일 수 있는지 예시입니다:\n\n```js\n// `filter` 함수 내 각 요소에 대해 호출됨\nfunction isNotNull(x: number | null) {\n  return x !== null;\n}\n```\n\n# 2. 정규식 검사\n\n또 다른 멋진 기능은 TypeScript 유형 검사기를 통해 정규식을 유효성 검사할 수 있는 능력입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTS 5.5 발표에서 문법 오류가 정규 표현식에서 캐치되는 훌륭한 예시가 있어요:\n\n```js\nlet myRegex = /@robot(\\s+(please|immediately)))? do some task/\n//                                            ~\n// error!\n// Unexpected ')'. Did you mean to escape it with backslash?\n```\n\n또한, 이 기능은 구문 분석만이 아닙니다!\n\n네 맞아요, 타입 체커는 이 예시에서 보여준 것처럼 정규 표현식에서 존재하지 않는 역참조와 같은 의미론적 문제도 잡아낼 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u;\n//                                                        ~\n// 오류!\n// 이 역참조는 존재하지 않는 그룹을 가리킵니다.\n// 이 정규식에는 캡처 그룹이 2개만 있습니다.\n```\n\n# 3. 상수 인덱스 액세스 범위 좁히기\n\n이제 TypeScript는 obj[key] 형식의 표현식을 좁힐 수 있습니다. 이는 obj와 key가 상수여야만 가능합니다.\n\n다음은 TypeScript 5.5 공식 발표의 예제를 적용한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction changeUnkownValue(obj: Record\u003cstring, unknown\u003e, key: string) {\n  if (typeof obj[key] === \"string\") {\n    // Now okay, previously was error\n    obj[key].toUpperCase()\n  }\n}\n```\n\n이전에는 색인 액세스를 사용하여 알 수 없는 Record 값의 유형을 추론할 수 없었습니다.\n\n이 경우 typeof 키워드를 사용하여 알 수없는 타입을 추론하지 못했기 때문에 obj[key].toUpperCase()가 에러를 발생시켰습니다.\n\nTypeScript 5.5에서는 이 문제가 해결되었으며 코드에서 더 이상 문제가 발생하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nTypeScript 5.5에서는 커뮤니티에서 오랫동안 기다려온 많은 흥미로운 기능들이 소개되었습니다.\n\n이러한 기능 중에서 이 3가지를 강조하여 이번에 꼭 필요한 업그레이드의 중요성을 부각했습니다.\n\n# 더 많은 읽기 📖 \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 제휴사\n\n- All-in-One SaaS 프로젝트 템플릿\n- Figma Home: 내 모든 프로젝트에서 사용하는 UI 디자인 도구.\n- Figma Professional: 당신이 필요로 하는 유일한 UI 디자인 도구.\n- FigJam: 직관적인 다이어그램 및 아이디어 회의로 마음을 자유롭게 발산시킬 수 있습니다.\n\n- Notion: 내 전체 인생을 조직하는 데 사용되는 도구.\n- Notion AI: ChatGPT를 능가하는 AI 도구로 Notion 워크플로우를 급속히 향상시킬 것입니다.\n\n# 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 맷 포콕 쓰레드\n- TS 5.5 마이크로소프트 블로그\n- 타입 프레디케이트","ogImage":{"url":"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png"},"coverImage":"/assets/img/2024-05-17-3ExcitingNewFeaturesinTypeScript55_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러 라우트를 제대로 사용하는 방법 3가지","description":"","date":"2024-05-17 20:22","slug":"2024-05-17-3KeyRecipestoNavigateYourAngularRoutes","content":"\n\n![Angular](/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png)\n\n정직하게 말하자면, 나는 Angular과 사랑과 미움이 공존하는 관계를 가지고 있어. 모든 것이 제대로 작동할 때는 정말 멋져. 그렇지만 그렇지 않고 나에게 힌트나 '더 어려운' 자료가 없는 경우, 그때는 너무나 짜증이 나.\n\n하지만 결국, 어떤 라이브러리, 프레임워크 또는 구글에 직면한 직관적인 답변이 없는 이상한 오류도 마찬가지로 그렇다.\n\n많은 사람들에게 Angular 라우팅은 포기하고 싶게 만드는 문제다. 일부로, 온라인 튜토리얼 중 많은 것들이 기본 라우트를 구현하는 예제들뿐이기 때문이다. 복잡한 시나리오에 적합한 것을 찾는 것은 갑자기 시간 소모적인 시행착오 과정이 될 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러는 프레임워크이기 때문에 내재적으로 이해하는 데 시간이 걸릴 수 있어도 라우팅 방식이 구현되는 방식은 때로는 지루하게 느껴질 수 있습니다. 그러나 이해하고 난 뒤에는 실제로 과소평가된 보석이라고 생각해요.\n\n리액트와 같은 것과 비교해보면, 리액트는 다양한 방법론의 아드혹 패치워크일 수 있지만, 앵귤러의 '이게 우리가 하는 방식이다' 접근 방식은 여러 팀 간 협업 시 덜 괴로울 수 있어요.\n\n앵귤러에서는 라우트를 별도 모듈(일반적으로 AppRoutingModule)에서 정의하고 RouterModule.forRoot() 메서드를 사용하여 라우트를 등록해요. 라우트는 객체 배열로 정의되며, 각 객체는 경로와 연결된 컴포넌트를 포함해요. 반면 리액트에서는 라우트가 Route, Switch, BrowserRouter와 같은 React Router 라이브러리에서 제공되는 컴포넌트를 사용하여 정의돼요. 이러한 컴포넌트들은 JSX 코드 내에서 직접 사용되며, 라우트 구성이 더 선언적이에요.\n\n앵귤러 라우팅의 장점(AppRoutingModule 및 RouterModule.forRoot()을 통해)은 구성이 중앙 집중화되어 있고 강력한 타입 지정으로 일관된 접근 방식을 제공한다는 점이에요. 반면, 리액트 라우팅(Route, Switch, BrowserRouter 컴포넌트를 통해)은 중앙 집중화가 부족하고 내장된 유형 확인이 없으며, 일관성 부족으로 인한 높은 불일치가 발생할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 이야기는 여기까지 하고, 본문의 요점으로 넘어가 봅시다. 이 글에서 다루는 Angular 라우팅 시나리오/레시피 중 가장 중요한 것은 바로 세 가지입니다. 이 세 가지는 모든 앱 개발 작업과 프로젝트를 다루며, 이해하기 어려웠던 부분을 간단하게 설명해줬으면 했던 것들입니다.\n\n# 레시피 1: 여러 수준과 동적 경로를 가진 중첩 라우팅\n\nAngular 라우트에서 동적 경로를 가진 다중 수준의 탐색 구조는 정보가 층층이 쌓인 정체를 푸는 것 같은 신비한 상자와 같은 느낌을 줄 수 있습니다.\n\n라우팅을 처음 배울 때, 우리는 종종 한 수준에서 시작하여 종료하는, 다음 페이지로 이동하고 다시 돌아오는 정도의 시나리오로 끝나곤 합니다. 하지만 90년대가 아니라는 것을 기억해야 합니다. 실제로 레알 앱/사이트는 카테고리, 서브카테고리, 사용자가 작성한 콘텐츠를 통해 동적 경로로 이어지는 필수 요소들이 많습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시를 위해 상상해 봅시다. 우리는 그것만 있는 전자상거래 애플리케이션을 개발하고 있다고 상상해 봅시다.\n\n## 단계 1: 카테고리, 하위 카테고리 및 제품 컴포넌트를 생성합시다\n\n```js\nng generate component category\nng generate component subcategory\nng generate component product\n```\n\n## 단계 2: AppRoutingModule에서 라우트를 정의합시다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { CategoryComponent } from './category/category.component';\nimport { SubcategoryComponent } from './subcategory/subcategory.component';\nimport { ProductComponent } from './product/product.component';\n\nconst routes: Routes = [\n  {\n    path: 'category/:categoryId',\n    component: CategoryComponent,\n    children: [\n      {\n        path: 'subcategory/:subcategoryId',\n        component: SubcategoryComponent,\n        children: [\n          {\n            path: 'product/:productId',\n            component: ProductComponent,\n          },\n        ],\n      },\n    ],\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n위 예제에서는 전자 상거래 앱의 각 수준에 대한 경로를 정의했습니다. 경로에서 :categoryId, :subcategoryId 및 :productId 자리 표시 자를 사용한 점에 주목하세요. 이러한 세그먼트는 앱을 통해 탐색할 때 실제 값으로 대체됩니다.\n\n## 단계 3: 컴포넌트 템플릿에 라우터 아웃렛을 추가하여 Angular이 자식 컴포넌트를 렌더링할 위치를 알 수 있도록 합니다:\n\n```js\n\u003c!-- category.component.html --\u003e\n\u003ch1\u003eCategory\u003c/h1\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\n\u003c!-- subcategory.component.html --\u003e\n\u003ch2\u003eSubcategory\u003c/h2\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\n\u003c!-- product.component.html --\u003e\n\u003ch3\u003eProduct\u003c/h3\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 앱을 통해 이동할 수 있는 몇 가지 라우터 링크를 생성합니다\n\n```js\n\u003c!-- app.component.html --\u003e\n \u003cnav\u003e\n   \u003cul\u003e\n     \u003cli *ngFor=\"let category of categories\"\u003e\n       \u003ca [routerLink]=\"['/category', category.id]\"\u003e{ category.name }\u003c/a\u003e\n     \u003c/li\u003e\n   \u003c/ul\u003e\n \u003c/nav\u003e\n \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n \n```\n\n이 예에서는 카테고리 배열이 id와 name 속성이 있는 카테고리 데이터를 포함하고 있다고 가정합니다. [routerLink] 지시문은 카테고리, 하위 카테고리 및 제품을 통해 이동할 때 적절한 URL을 생성합니다.\n\n그게 다입니다! 이제 다중 수준 및 동적 경로를 포함하는 중첩 라우팅 구조의 기본 뼈대가 완성되었습니다. 사용자는 이제 카테고리, 하위 카테고리, 제품을 손쉽게 탐색할 수 있으며 앱의 구조는 깔끔하고 조직적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레시피 2: 라우트 가드 및 역할 기반 액세스와 canActivate\n\n오케이, 멋져요. 중첩된 내용들이 있고, 특정 사람들에게만 보기 권한을 부여하고 특정 작업을 할 수 있게끔 하는 건 어떻게 하는지 궁금하신가요? 예를 들어, 사용자들?\n\n이것이 바로 canActivate 및 RoleGuard의 역할입니다.\n\nAngular에서 역할 기반 액세스 제어를 구현하는 데 Route guards와 canActivate 가드를 사용할 수 있습니다. 이를 통해 응용 프로그램의 특정 부분에 대한 액세스 권한이 있는 사용자만 해당 부분에 액세스할 수 있도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 사용자와 관리자 사용자가 있는 응용 프로그램을 개발 중이라고 상상해 봅시다. 이제 사용자의 역할에 따라 특정 경로로의 액세스를 제한하려고 합니다. 이를 위해 RoleGuard라는 사용자 지정 라우트 가드를 만들 수 있습니다.\n\n## 단계 1: RoleGuard 생성\n\n```js\nng generate guard role\n```\n\n## 단계 2: RoleGuard를 생성하고 CanActivate 인터페이스를 구현하여 사용자의 역할을 확인하도록 수정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서는 사용자 역할을 확인하고 해당 사용자가 관리자인 경우 true를 반환합니다. 사용자가 관리자가 아닌 경우 홈 페이지로 리디렉션하고 false를 반환합니다.\n\nRoleGuard를 CanActivate 인터페이스를 구현하도록 수정하면, Angular에게이 가드가 사용자의 역할에 기반하여 경로를 활성화 할 수 있는지를 결정해야한다고 말하는 것과 같습니다. 이 경우 사용자의 역할을 확인하는 사용자 정의 로직을 검사합니다.\n\nCanActivate 인터페이스를 구현하려면, 경로를 활성화 할 수 있는지(true) 아니면 할 수 없는지(false)를 나타내는 boolean 또는 boolean을 해결하는 observable 또는 promise를 반환하는 canActivate 메서드를 제공해야합니다. canActivate 메서드가 false를 반환하면, 탐색이 취소되고 사용자가 경로에 액세스하는 것이 방지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자의 역할을 확인하여 canActivate 메서드 내에서 특정 라우트에 대한 액세스를 제어할 수 있습니다. 예를 들어 응용 프로그램에 관리자 영역이 있다면, 사용자가 관리자인지 확인하는 canActivate 메서드가 포함된 RoleGuard를 사용하여 액세스를 허용하기 전에 확인할 수 있습니다. 사용자가 관리자가 아닌 경우 가드가 false를 반환하고 탐색이 취소되어 권한이없는 액세스를 방지합니다.\n\n특정 라우트에 대한 액세스를 제어하는 유연하고 안전한 방식을 제공하기 위해 RoleGuard를 수정하여 CanActivate 인터페이스를 구현하고 사용자의 역할을 확인해야합니다. 이는 Angular 응용 프로그램 내에서 사용자 역할이나 권한에 따라 액세스 제어하는 방식입니다.\n\n## 단계 3: 관리자만 액세스할 수 있는 관리자 구성 요소 생성\n\n```js\nng generate component admin\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: AppRoutingModule에 관리자 컴포넌트를 위한 새 경로를 추가하고 RoleGuard를 canActivate 가드로 사용하세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { RoleGuard } from './role.guard';\n\nconst routes: Routes = [\n  // ... 다른 경로들 ...\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [RoleGuard]\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n## 단계 5: 관리자 페이지로 이동하는 라우터 링크 생성하기\n\n```js\n\u003c!-- app.component.html --\u003e\n\u003cnav\u003e\n  \u003cul\u003e\n    \u003c!-- ... 다른 링크들 ... --\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/admin\"\u003eAdmin\u003c/a\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그걸로 끝이에요! ‘admin’ 역할을 가진 사용자만 관리자 경로에 액세스할 수 있고, 다른 사용자는 홈페이지로 리디렉트됩니다.\n\n# 레시피 3: 404 오류 및 리디렉션 처리\n\n언젠가는 사용자가 리디렉트나 404 에러를 만나게 될 것이고, 이를 다룰 필요가 있을 겁니다. 다음은 그 방법입니다.\n\n## 단계 1: 존재하지 않는 경로에 방문한 사용자에게 표시될 NotFoundComponent를 생성하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate component not-found\n```\n\n## Step 2: NotFoundComponent 템플릿을 수정하여 친근한 에러 메시지를 표시하도록 사용자 정의하기\n\n```js\n\u003c!-- not-found.component.html --\u003e\n\u003ch1\u003e이런!\u003c/h1\u003e\n\u003cp\u003e찾고 있는 페이지가 없는 것 같아요.\u003c/p\u003e\n\u003ca routerLink=\"/\"\u003e홈페이지로 돌아가기\u003c/a\u003e\n```\n\n## Step 3: AppRoutingModule에 NotFoundComponent를 위한 라우트 추가하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 일치하지 않는 경로를 캐치할 수 있는 ** 경로와 와일드카드 라우트를 사용할 것입니다.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nconst routes: Routes = [\n  // ... 다른 라우트 ...\n  {\n    path: '**',\n    component: NotFoundComponent\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n이 설정을 사용하면 사용자가 존재하지 않는 경로로 이동할 때마다 NotFoundComponent가 표시됩니다.\n\n# 그렇다면 리다이렉트는 어떻게 하죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예전 경로에서 새 경로로 사용자를 리디렉션하고 싶을 때 AppRoutingModule에 리디렉트 경로를 추가하여 이 작업을 수행할 수 있습니다:\n\n```js\nconst routes: Routes = [\n   // ... 다른 경로들 ...\n   {\n     path: 'old-route',\n     redirectTo: '/new-route',\n     pathMatch: 'full'\n   },\n   {\n     path: '**',\n     component: NotFoundComponent\n   },\n ];\n```\n\n이 예제에서 /old-route를 방문하는 사용자는 /new-route로 리디렉션이 됩니다. pathMatch: `full` 옵션은 전체 URL 경로가 일치해야 리디렉션이 발생합니다.\n\n다양한 리디렉트 유형에 대한 설명은 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 리다이렉트\n\n기본적으로는 방금 한 것과 똑같지만 목록을 대충 훑는 사람들을 위해 여기에 가져 두는 게 좋다고요.\n\n```js\n{\n   path: 'old-page',\n   redirectTo: '/new-page',\n   pathMatch: 'full'\n}\n```\n\n## 매개변수를 사용한 리다이렉트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n   path: 'user/:userId/profile',\n   redirectTo: '/profile/:userId',\n   pathMatch: 'full'\n }\n```\n\n이 경우, /user/123/profile을 방문하는 사용자는 /profile/123로 리디렉션이 됩니다. 경로의 :userId 매개변수가 자동으로 새 경로로 전달됩니다.\n\n## 와일드카드를 사용한 리디렉션\n\n```js\n{\n   path: 'legacy/**',\n   redirectTo: '/new-section'\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/legacy/로 시작하는 모든 경로를 방문하는 사용자(e.g., /legacy/some-page, /legacy/another-page)들은 /new-section으로 리디렉션됩니다. ** 와일드카드는 legacy/ 뒤의 모든 하위 경로와 일치시키기 위해 사용됩니다.\n\n## 쿼리 매개변수와 함께 리디렉션하기\n\n쿼리 매개변수를 유지하면서 리디렉션하기 위해서 컴포넌트의 로직을 수정해야 합니다. 다음은 예시입니다:\n\n```js\nimport { ActivatedRoute, Router } from '@angular/router';\n\n constructor(private route: ActivatedRoute, private router: Router) {}\n \n ngOnInit() {\n   const queryParams = this.route.snapshot.queryParams;\n   this.router.navigate(['/new-route'], { queryParams });\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 이전 경로와 관련된 컴포넌트가 초기화될 때 현재 쿼리 매개변수를 읽고, 쿼리 매개변수를 보존한 채 새 경로로 이동합니다.\n\n## 조건부 리디렉션\n\n조건부 리디렉션을 수행하려면 Route Guards를 사용할 수 있습니다. 이전 예시에서 RoleGuard로 보여졌듯이 사용자 지정 Route Guard를 생성하여 특정 조건을 확인하고 그에 따라 리디렉션할 수 있습니다.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ConditionalRedirectGuard implements CanActivate {\n  constructor(private router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    const condition = // 여러분의 사용자 정의 조건;\n\n    if (condition) {\n      this.router.navigate(['/new-route']);\n      return false;\n    }\n\n    return true;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 다음 가드를 라우트 구성에 사용해 보세요:\n\n```js\n{\n   path: 'some-page',\n   component: SomePageComponent,\n   canActivate: [ConditionalRedirectGuard]\n }\n```\n\n# 마무리\n\n거의 다 다룬 것 같아요. 이 내용이 유용하게 사용되기를 바라요. Angular 라우팅에는 여기서 다룬 것 이외에도 보안 취약점을 다루고 앱을 망가뜨리는 것을 방지하는 방법 등이 있어요. 하지만 아마도 그건 다음에 해보죠. 지금은 Angular 라우트를 구현하는 방법, 조각으로 만들어둔 레시피에 대해 이야기해 봤어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 와 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png"},"coverImage":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png","tag":["Tech"],"readingTime":11},{"title":"독일, 모든 비용을 통해 FFmpeg 보호하기","description":"","date":"2024-05-17 20:21","slug":"2024-05-17-GermanyToProtectFfmpegAtAllCost","content":"\n\n![Image](/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png)\n\n# 독일 공개 소스 기금이 인터넷 비디오의 기반인 ffmpeg에 대한 엄청난 기부를 발표했습니다.\n\n그거 아시는 분들은 많지 않지만, 온라인 비디오 보기의 붐은 실제로 ffmpeg 덕분에 시작되었습니다.\n\nFfmpeg는 비디오 파일을 변환, 최적화 및 편집하는 명령줄 유틸리티입니다. 초기에는 서버에서 비디오를 처리하는 것이 매우 어려웠기 때문에 온라인 비디오가 인기가 없었던 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 더 빠른 인터넷 연결과 ffmpeg 온라인 플랫폼 덕분에 비디오를 웹 및 브라우저가 이해하는 형식으로 최적화할 수 있었습니다.\n\n오늘날까지 ffmpeg는 많은 애플리케이션에서 널리 사용되며 필요한 모든 비디오 작업을 처리합니다.\n\n그러나 누구도 그것에 대해 알지 못합니다. 왜냐하면 그것은 그 뒤에서 작동하기 때문입니다. 흥미롭게도, 이것은 주요 기술 회사에서 만들어진 것이 아닙니다.\n\n이것은 초기에 프랑스의 천재 컴퓨터 프로그래머인 Fabrice Bellard에 의해 만들어졌습니다. 이후에는 오늘날까지 작업하는 다른 개발자들이 참여했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 글 중 하나에 썼던 것처럼, 오픈 소스 프로젝트의 유지보수자들은 지원받아야 합니다. 그렇게 하면 프로젝트를 보호하고 유지할 수 있습니다.\n\n독일의 주권 기술 기금을 통해 그와 관련된 흥미로운 이니셔티브가 이루어졌습니다.\n\n이 특별 기금은 중요한 프로젝트에 기부합니다. 그리고 오늘 딱 오늘은 ffmpeg가 그 목록에 추가되었습니다.\n\n2024년과 2025년을 위해 15만 7천 유로 이상의 기부를 받았습니다. 그 너그러운 기부금은 이 프로젝트를 유지하는 데 도움이 될 것입니다. 이는 그 도구가 얼마나 중요한지 때문에 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃허브에서 11,000개 이상의 포크가 있습니다. 그리고 깃허브 저장소는 프로젝트의 미러일 뿐입니다!\n\n지금까지 기부를 받은 다른 프로젝트로는 OpenJS 재단, Fortran, curl, systemd, Gnome 또는 Mamba 등이 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png"},"coverImage":"/assets/img/2024-05-17-GermanyToProtectFfmpegAtAllCost_0.png","tag":["Tech"],"readingTime":2},{"title":"아니요, 제가 줌에서 당신을 보고 싶지 않아요","description":"","date":"2024-05-17 04:29","slug":"2024-05-17-NoIDontWanttoLookAtYouonZoom","content":"\n\n![NoIDontWanttoLookAtYouonZoom](/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png)\n\nZoom를 항상 싫어했던 유일한 사람인가요?\n\n잘못 이해하지 마세요. 필요한 때에 나타났고, COVID가 거리를 패달아 다녔을 때 나타났죠. 모든 건물이 닫혀 있었고, 마스크를 쓰지 않은 사람은 보지도 못했어요.\n\n저는 대학 시절 COVID를 겪은 사람으로서 이 모든 것을 잘 알고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수업에 가지 않아도 되는 아이디어를 좋아했는데, Zoom 덕분에 교수님들과 매니저들이 완전히 긴장된 상태가 되었어요.\n\n지금은 Zoom 콜을 위해 사람들이 만든 모든 규칙들을 싫어해요:\n\n- 카메라를 꼭 켜야 합니다\n- 좋은 소리를 꼭 설정해야 합니다\n- 채팅에 댓글/질문을 하나 꼭 써야 합니다\n- 프로필 사진이 있어야 합니다\n- 멋진 배경을 가져야 합니다\n\n정말 말도 안 되게 되고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 내가 어떻게 생겼는지 이미 아는데 내 얼굴을 왜 보려고 하나요?\n\n뻔한 농담을 할 때마다 가짜 미소를 보려고 하는 거예요? 내가 뭘 입었는지 보려고?\n\n진지해져요.\n\n대부분의 경우, 줌 콜이 예정되어 있을 때, 저는 잠옷을 입고 있어요. 화장도 안 하고 머리는 엉망이 되어 있을 거예요. 마치 방금 일어난 것처럼 보일 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그건 내가 너나 누구에게도 보고 싶어하는 것이 아닌 걸.\n\n집에서는 칙칙한 모습을 보여주고 싶지 않아. 그건 직장에서 해야 할 일이지.\n\nZoom은 거의 개인 정보 침해로 변모했어.\n\n왜 내 배경이 어떤지 볼 필요가 있어? 내가 어디에 있는지 알고 싶어?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 위치는 당신의 사업이 아닙니다.\n\n그리고 온라인에서 사용할 수 있는 멋진 배경에 대해 전혀 신경 쓰지 않습니다. 내 카메라는 꺼져 있어야 하기 때문에 배경을 찾아야 할 이유가 없습니다!\n\n이것은 오디오 통화여야만 합니다.\n\n## 그 큰 불평을 한 이유는 다시 일반 전화 통화를 정상화해야 한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 서로 얼굴을 본 적이 없고 자신을 소개하거나 화면 공유를 통해 중요한 내용을 논의하고 싶다면 Zoom 콜의 필요성을 이해합니다. 완전히 이해할 수 있어요.\n\n하지만 월간 또는 주간 상호작용에는 Zoom 콜이 필요하지 않아요.\n\n그 순간에, 당신은 누군가를 감시하거나 신뢰하지 않는 사람을 조사하기 위해 Zoom 콜을 진행하고 있어요. 이제 이런 일에 시간을 할애할 여유가 없어요.\n\n오디오 콜이 돌아오기를 바래요 (이전에는 그것이 불편했던 사람으로서).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 빛을 보았어요.\n\n당신의 얼굴을 보고 싶지 않고, 제 얼굴도 보고 싶지 않아요, 알겠죠?\n\n화가 풀렸어요.\n\n90일 안에 글쓰기 습관을 시작하고 싶나요? 여기서 무료 글쓰기 습관 안내서를 받아보세요.","ogImage":{"url":"/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png"},"coverImage":"/assets/img/2024-05-17-NoIDontWanttoLookAtYouonZoom_0.png","tag":["Tech"],"readingTime":2},{"title":"오픈CTI 61의 텔레메트리","description":"","date":"2024-05-17 04:28","slug":"2024-05-17-TelemetryinOpenCTI61","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png\" /\u003e\n\n6.1부터 OpenCTI는 플랫폼과 관련된 일부 측정 값을 수집합니다. 현재 사용량은 이전보다 매우 많은 데이터 양을 의미하기 때문에 플랫폼 성능을 개선하기 위해 이러한 메트릭 수집은 이제 필수적입니다. 또한 우리에게는 워크플로우를 향상시키고 커뮤니티 사용 패턴에 맞게 적응시키는 것이 중요합니다. 데이터는 익명화되어 통계적으로 처리됩니다. 사용자 개인 정보와 기밀 데이터는 수집되지 않습니다.\n\n함께 이 과정을 알아보도록 합시다! 🙂\n\n# 기밀성과 익명화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수집된 모든 데이터는 익명화되어 있으며 IP 주소, 이메일 주소 또는 사용자 이름과 같은 개별 사용자를 식별할 수 있는 데이터는 수집하지 않습니다. 따라서 사용자의 개인 정보는 개인정보 규정을 준수하여 보호받고 있습니다.\n\n또한 위협 인식 지식과 관련된 정보를 수집하지 않습니다: 플랫폼에서 소비된 데이터 및 분석 데이터는 엄격히 기밀을 유지합니다.\n\n# 텔레메트리의 목적\n\n수집된 데이터는 다음을 위해 사용됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플랫폼 사용을 더 잘 이해하여 응용 프로그램의 기능과 성능을 향상시킵니다.\n- 사용자 행동을 분석하여 사용자 경험을 향상시킵니다.\n- 내부 측정항목 및 KPI를 위해 집계 및 익명화된 통계를 생성합니다.\n\n미래에는 외부 보고를 위해 이 통계 데이터도 사용할 계획이며, OpenCTI 사용에 대한 직접적인 통찰을 사용자 및 고객 커뮤니티에 제공할 것입니다.\n\n# 텔레메트리 데이터 계산\n\n텔레메트리 데이터를 수집, 관리 및 내보내기하기 위해 OpenTelemetry 라이브러리를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메트릭은 텔레메트리 관리자에 의해 매 시간 수집됩니다. 플랫폼 수명 중 변하지 않는 버전과 같은 일부 메트릭은 텔레메트리 관리자 시작 시에 한 번만 수집됩니다.\n\n## 텔레메트리 데이터 내보내기\n\n데이터는 두 가지 방법으로 매 6시간마다 내보냅니다:\n\n- 파일 내보내기 — 메트릭은 파일 내보내기자를 통해 특정 로그 파일에 기록됩니다. 이 파일은 로컬 OpenCTI 폴더(경로: opencti/opencti-platform/opencti-graphql/telemetry/)에서 찾을 수 있으므로 내보낸 데이터에 액세스할 수 있습니다. 이 파일들은 지원 패키지에 포함되어 있습니다. 이 파일들은 항상 생성되며 비활성화할 수 없습니다.\n- OTPL 내보내기 — 연결된 플랫폼의 경우 메트릭은 OTLP 프로토콜을 통해 HTTPS를 통해 telemetry.filigran.io 호스트에 전송됩니다. 이 내보내기는 OpenCTI가 텔레메트리 관리자 시작 시에 호스트명에 연결할 수없는 경우 비활성화됩니다(연결 끊긴 플랫폼).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내보낸 데이터는 OpenTelemetry JSON 형식으로 작성됩니다.\n\n![그림](/assets/img/2024-05-17-TelemetryinOpenCTI61_1.png)\n\n## 수집된 데이터\n\n다음은 OpenCTI 6.1에서 수집된 플랫폼 사용에 관련된 메트릭 목록입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 현재 플랫폼 버전,\n- 플랫폼 고유 식별자,\n- 플랫폼 생성 날짜,\n- 노드(인스턴스) 수,\n- 총 사용자 수,\n- 활성 사용자 수 (즉, 텔레미트리 매니저에 의해 마지막 데이터 수집 이후 세션을 활성화한 사용자 수),\n- 엔터프라이즈 에디션 상태 (EE가 활성화되었는지 여부),\n- 활성 커넥터 수.\n\n# 다음 단계\n\n향후 플랫폼 사용 상황을 더 잘 이해하기 위해 다른 데이터가 수집될 수 있습니다:\n\n- 엔터프라이즈 에디션 활성화 원점 (EE 팝업이 열린 페이지) 등, 어떤 기능이 사용자가 EE를 가장 많이 채택하게 하는지 알아내기.\n- 시간 경과에 따른 평균 세션 기간, 시간이 지남에 따른 사용자 플랫폼 사용 변화 평가.\n- 기능 채택률을 평가하기 위한 몇 가지 메트릭, 시간이 지남에 따른 특정 기능 사용량 파악하는 데 도움이 됩니다. 예를 들어 세션당 특정 기능의 API 호출 수를 통해 계산될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nFiligran을 위한 텔레메트리 데이터 수집은 사용자의 개인 정보와 데이터 기밀성을 고려하며, 플랫폼 이용 방식을 더 잘 이해할 수 있게 해줍니다. 이를 통해 사용자들의 행동에 적합한 솔루션과 기능을 제안하고, 우리 커뮤니티를 위해 OpenCTI 경험과 기능을 가장 잘 개선할 수 있습니다.\n\nSlack 커뮤니티 채널에서 언제든지 관련 질문을 자유롭게 해 주세요! 📢","ogImage":{"url":"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png"},"coverImage":"/assets/img/2024-05-17-TelemetryinOpenCTI61_0.png","tag":["Tech"],"readingTime":3},{"title":"SREF 랜덤 ID 코드 해석하는 방법","description":"","date":"2024-05-17 04:27","slug":"2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs","content":"\n\n## MIDJOURNEY \u0026 SREF 코드 숙달하기\n\nMidjourney의 새로운 스타일 참조 ID를 통해 프로젝트를 혁신하고, 여러 프롬프트에서 일관된 예술 스타일을 보장하세요.\n\n2월에 Midjourney는 새로운 스타일 참조 이미지 기능을 도입했습니다. 여기서 혁신적인 점은 사용자가 적절한 이미지 URL을 사용하여 --sref [URL] 또는 --sref [URL] [URL] [URL]을 프롬프트에 사용할 수 있으며, 이를 통해 프롬프트에 스타일을 적용할 수 있다는 것입니다. 이것은 여러 이미지 프롬프트 전반에 걸쳐 일관된 모습을 유지할 수 있는 방법을 마침내 제공했기 때문에 게임 체인저였습니다. 그래픽 소설이나 어린이 도서를 제작하는 창작자들은 프로젝트 전체에서 동일한 예술 스타일을 원할 수 있습니다. 텍스트 프롬프트로 특정 스타일을 유지하는 것은 때로는 어려울 수 있었지만, 새로운 SREF를 사용하면 쉽게 가능합니다.\n\n하지만 Midjourney는 여기서 멈추지 않았습니다! --sref random이라는 것을 소개했는데, 이를 사용하면 1부터 4294967295 사이의 숫자를 얻을 수 있습니다. 네, 맞았습니다. 40억 가량의 숫자가 가능합니다. 각 ID 번호에는 다른 스타일이 적용되어 있으며 일부는 유사한 영향을 받을 수도 있습니다. --sref random을 사용하거나 범위 내에서 숫자를 선택하고 프롬프트 끝에 --sref ID#를 사용하여 해당 번호를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로 생성된 --sref random으로 만든 새 SREF ID에 대한 기본 이미지를 보는 것은 불가능합니다. 그러나 다른 프롬프트 없이도 해당 ID의 직접적인 영향을 볼 수 있는 방법이 있습니다. 이를 통해 주어진 ID의 내부 영향을 훨씬 명확하게 파악할 수 있습니다.\n\n이를 실행하는 방법은 빈 프롬프트와 스타일 가중치 1000 --sw 1000으로 나타내는 상자 아래에 표시된 대로 하면 됩니다. 스타일 가중치는 1부터 1000 사이의 값을 가질 수 있습니다.\n\n```js\n\"\" --ar 2:3 --sw 1000 --sref random\n```\n\n아무것도 넣지 않고 빈 이중 인용부호만 사용함으로써 Midjourney에 프롬프트를 만들도록 강제하는 것입니다. 스타일 가중치를 1000으로 설정하면 이 비-프롬프트에 스타일의 전체 가중치를 강제로 부여합니다. 반환되는 이미지는 해당 ID가 무엇을 하는지 명확히 보여줍니다. 몇 가지 예를 들어 설명해 드리겠습니다. 동일한 SREF ID로부터 만들어진 네 개의 이미지 쿼드를 실행했습니다. 다양한 변형이 있지만 전부 영향을 받은 것이 매우 유사함을 보여줍니다. 강한 여성적이고 핑크색 및 네온 요소를 가진 이 ID를 선택한 이유는 이를 빠르게 식별하고 영향을 파악할 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"\" --ar 2:3 --sref 1583246159 --sw 1000\n```\n\n여자와 소녀의 이미지를 만들었어요. 이 스타일에 너무 잘 어울린다고 생각했어요. 소년은 조금 흔해빠진 이미지일지도 모르겠어요 (죄송해요). 하지만 SREF가 없는 보통 이미지에는 이미지에 분필이 많이 들어 있지 않았을 거에요.\n\n```js\na beautiful young woman posing for a portrait --ar 2:3 --sref 1583246159\nA little girl having a tea party with her favourite dolls. --ar 2:3 --sref 1583246159\nA little boy playing war games with his action figures. --ar 2:3 --sref 1583246159\n```\n\n다음 이미지들로 넓은 지역에 갔어요. 사진에 나오는 오두막은 자연 실외 색상이 핑크 톤을 압도했어요. 일반적으로 더 많은 초록색이 아닐까 생각했지만, #1의 연한 핑크징을 힌트로 남겨뒀어요, #2와 #3의 핑크징으로 이루어진 집, 그리고 #4에서 미세하게 핑크 빛을 받아빛나는 민들레까지도요. 물에 비치는 핑크색의 반사와 모래색이 따뜻하고 황금빛을 내는 걸 특히 좋아했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈 프롬프트 이미지를 확인하는 것이 도움이 되는 이유 중 하나는 동일한 ID를 사용하여 만든 이미지에서 불일치가 발견되면, 프롬프트에 충돌하는 요소가 ID의 기저 영향과 일치하지 않을 가능성이 있다는 것을 나타낼 수 있습니다.\n\n```js\n일몰이 진 해변, 따뜻한 황금 모래가 촉촉하게 반짝입니다. 푸른 파도가 천천히 해변으로 밀려옵니다. 갈매기들이 하늘을 가볍게 날아다닙니다. --ar 2:3 --sref 1583246159\n자정에 도심 거리를 희주로 달리는 스포츠 카 --ar 2:3 --sref 1583246159\n숲 속 작은 오두막, 왼쪽에는 상록수로 둘러싸여 있고 오른쪽의 개방된 초원은 민들레로 가득합니다. --ar 2:3 --sref 1583246159\n```\n\n위의 세 개의 쿼드는 기본 스타일 가중치인 100으로 실행됩니다. --sw #이 지정되지 않으면 자동으로 100을 사용합니다. ID가 프롬프트에 미치는 영향을 가볍게 만들기 위해 숫자를 줄일 수 있습니다. 아래에는 스타일 가중치가 200, 500 및 1000인 동일한 프롬프트를 실행한 예시가 있습니다. 이 ID의 분홍색 스타일은 강력하기 때문에 차이를 보기 어렵지만, 200에서 이미 사람들을 포함하지 않는 프롬프트에 여성이 나타나기 시작합니다.\n\n아래 상자에 서로 다른 스타일 가중치를 순열로 설정했습니다. 순열은 하나의 프롬프트로 여러 프롬프트를 실행할 수 있게 하는 꼼수입니다. 중괄호 안에 쉼표로 구분된 목록을 추가함으로써, 미드저니에게 200으로 먼저 프롬프트를 실행하고, 그 다음에는 500으로, 그리고 1000으로 실행하라고 알려주는 것입니다. 이는 무엇이 무엇을 하는지 탐색하는 경우에 유용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n해변, 일몰, 따뜻한 황금빛 모래가 촉촉하게 빛난다. 파란 파도가 천천히 밀려나 올라온다. 갈매기가 하늘을 가르며 날아다닌다. --ar 2:3 --sref 1583246159 --sw {200,500,1000}\n자정에 도시 길을 광장히 달리는 스포츠카 --ar 2:3 --sref 1583246159 --sw {200,500,1000}\n나무로 된 작은 오두막, 왼쪽으로 이어진 상록수와 오른편의 물푸레나무로 가득한 넓은 목초지. --ar 2:3 --sref 1583246159 --sw {200,500,1000}\n```\n\n## 더 알아보기\n\n## 30개의 SREF ID가 당신의 프롬프트를 기다립니다!\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중간 여행의 혁신적인 스타일 참조 이미지 기능과 무작위 ID 생성 기능은 창작자들이 작품에서 일관성을 유지할 수 있는 방식을 변화시켰습니다. 그래픽 소설, 어린이 책 또는 일관된 스타일을 필요로 하는 어떤 창의적 프로젝트를 작업 중이든, 이러한 도구들은 탁월한 제어와 창의성을 제공합니다. 서로 다른 스타일 가중치와 순열을 실험함으로써 여러 예술적 가능성을 개방하고 이미지에서의 영향을 세밀하게 조절할 수 있습니다. 이러한 기능들을 포용하여 매번 일관된, 시각적으로 놀라운 결과물을 달성하고 예술을 높이세요.\n\n여러분의 참여와 피드백은 저에게 귀중합니다. 제가 작성하는 콘텐츠를 안내해주어 그것이 공감되고 풍요로워지도록 합니다. 만약 이 중간 여행 탐험에서 영감을 받았다면 언제든지 생각을 공유하고 그 박수를 클릭해주기를 망설이지 마세요—총 50개까지 가능합니다! 다음 예술적 모험까지, 계속해서 창작하고 영감을 주세요!\n\n![Cracking the Code of Midjourney's SREF Random IDs](/assets/img/2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs_0.png)\n\n```js\n\"\" --ar 4:3 --sref 509968410 --sw 1000\n```","ogImage":{"url":"/assets/img/2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs_0.png"},"coverImage":"/assets/img/2024-05-17-CrackingtheCodeofMidjourneysSREFRandomIDs_0.png","tag":["Tech"],"readingTime":5},{"title":"암 치료에 대한 대응","description":"","date":"2024-05-17 04:24","slug":"2024-05-17-ResponsetoCancerTreatment","content":"\n\n## 암 치료 반응 지표의 정확한 추출\n\n![이미지](/assets/img/2024-05-17-ResponsetoCancerTreatment_0.png)\n\n저자: Gursev Pirge, Samed Kocer\n\n암 치료에 대한 환자 반응을 정확하게 평가하는 것은 임상 의사 결정에 유용하며 치료 결과를 최적화하는 데 중요합니다. 대형 언어 모델(Large Language Models, LLMs)은 다양한 자연어 처리(Natural Language Processing, NLP) 작업에서 인상적인 성능을 발휘해 왔지만, 의료 언어의 복잡성과 임상 내러티브 해석의 세심한 뉘앙스로 인해 이 도메인에서의 성능이 제한되어 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n임상 보고서에 기록된 복잡한 세부 내용을 정확하게 이해하는 능력은 후속 치료 결정을 인도하고 치료 전략을 조정하며 궁극적으로 환자 결과를 향상시키는 데 중요합니다. John Snow Labs은 비정형 텍스트에서 환자 응답을 추출하고 분류하는 데 뛰어난 정확성으로 알려진 모델을 제공하여 NLP를 암 치료에 적용하는 중요한 발전을 이루었습니다.\n\n본 게시물에서는 John Snow Labs의 Healthcare NLP 라이브러리의 사전 훈련된 모델을 사용하여 환자의 암 치료에 대한 응답을 평가하는 내용을 다룹니다. 환자의 암 치료 경과/변화를 이해하는 데 중요한 텍스트 데이터의 키워드나 구절 NER을 식별하고, 더불어 텍스트 분류 모델을 사용하여 적용된 치료에 대한 응답을 평가할 것입니다.\n\n우선 짧은 Spark NLP 소개부터 시작한 다음, 암 치료에 대한 응답의 세부 내용과 실질적인 결과에 대해 논의해보겠습니다.\n\n## Spark NLP 및 LLM\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헬스케어 라이브러리는 존 스노 랩의 Spark NLP 플랫폼의 강력한 구성 요소로, 의료 분야 내에서 NLP 작업을 용이하게 하는 데 설계되었습니다. 이 라이브러리는 의료 데이터에 맞춘 2,200개 이상의 사전 훈련된 모델과 파이프라인을 제공하여 정확한 정보 추출, 임상 및 의료 개념을 위한 NER, 텍스트 분석 기능을 제공합니다. 정기적으로 업데이트되며 최첨단 알고리즘으로 구축된 헬스케어 라이브러리는 정보 처리를 최적화하고 전자 의료 기록, 임상 노트, 생물 의학 문헌과 같은 비정형 의료 데이터 소스로부터 의료 전문가들에게 더 깊은 통찰력을 제공하기 위해 노력하고 있습니다.\n\n존 스노 랩의 GitHub 저장소는 사용자가 오픈 소스 리소스에 액세스할 수 있는 협업 플랫폼으로, 코드 샘플, 튜토리얼 및 프로젝트 등을 포함합니다. 이를 통해 사용자들은 Spark NLP 및 관련 도구의 이해와 활용을 더욱 향상시킬 수 있습니다.\n\n존 스노 랩은 또한 헬스케어 라이브러리 및 NLP 플랫폼의 다른 구성 요소를 이용하는 데 전문 지식을 습득하는 데 도움이 되는 주기적인 인증 교육을 제공합니다.\n\n존 스노 랩의 데모 페이지는 라이브러리의 기능을 탐색하기 위한 사용자 친화적 인터페이스를 제공하여 사용자가 상호 작용적으로 테스트하고 다양한 기능과 모델을 시각화할 수 있도록 하며, 이러한 도구가 의료 및 다른 분야에서 실제 시나리오에 적용될 수 있는 방법에 대한 더 깊은 이해를 돕습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJohn Snow Labs의 Healthcare Library가 핵심 역할을 할 수 있는 중요한 응용 분야 중 하나는 환자가 암 치료에 대한 반응을 평가하는 것입니다. 개인이 치료에 어떻게 반응하는지 정확하게 평가하는 것은 임상 의사 결정을 안내하고 치료 결과를 최적화하는 데 중요합니다. 그러나 의료 언어의 복잡성과 그러한 텍스트를 해석하는 데 관련된 세세한 점들 때문에 비구조적 임상 문서에서 이 정보를 추출하는 것은 어려울 수 있습니다.\n\nNLP를 사용하여 환자의 암 치료에 대한 반응을 평가하는 데 여러 접근 방법이 있습니다. 첫 번째 접근 방식은 NER 모델을 사용하여 비구조적 임상 텍스트에서 관련 있는 종양학적 개념 및 엔티티를 추출하는 것입니다. 이를 통해 시스템은 환자의 상태, 치료 방법 및 결과에 관련된 주요 정보를 정확하게 파악할 수 있습니다.\n\n두 번째 접근 방식은 텍스트 분류 모델을 사용하여 임상 내러티브의 전반적인 내용과 문맥을 분석하는 것입니다. 이러한 모델을 레이블이 지정된 데이터셋으로 훈련시킴으로써, 이 모델은 환자의 진행 상황, 증상 및 기타 관련 요소를 묘사하는 데 사용된 언어를 기반으로 처방된 암 치료의 효과성과 효율성을 평가할 수 있습니다.\n\n이 블로그 포스트에서 우리는 John Snow Labs의 NER 및 텍스트 분류 모델이 이 중요한 문제를 해결하기 위해 정확한 솔루션으로서의 잠재력을 탐구할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 임상 노트에서 종양학 관련 엔티티 추출\n\n이 파트에서는 John Snow Labs Healthcare NLP 라이브러리가 임상 노트에서 종양학 관련 엔티티(NERs)를 추출하는 방법에 대해 살펴볼 것입니다.\n\n200개 이상의 종양학 모델의 힘을 활용하여 의료 전문가들은 복잡한 임상 내러티브에서 암 진단, 치료 및 환자 결과에 관련된 중요한 정보를 효율적으로 식별하고 추출할 수 있습니다.\n\nSpark NLP는 파이프라인을 사용하여 가치 있는 정보를 추출하며, 이를 위해 6단계만 필요합니다. 나는 ner_oncology 모델을 활용하여 종양과 관련된 엔티티를 추출했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 단계 1: 원시 텍스트를 `document`로 변환합니다.\ndocument = DocumentAssembler()\\\n    .setInputCol(\"text\")\\\n    .setOutputCol(\"document\")\n\n# 단계 2: 문장 감지/분할\nsentencer = SentenceDetectorDLModel.pretrained(\"sentence_detector_dl_healthcare\",\"en\",\"clinical/models\")\\\n    .setInputCols([\"document\"])\\\n    .setOutputCol(\"sentence\")\n\n# 단계 3: 토큰화\ntokenizer = Tokenizer()\\\n    .setInputCols([\"sentence\"])\\\n    .setOutputCol(\"token\")\\\n    .setSplitChars([\"-\", \"\\/\"])\n\n# 단계 4: 임상 임베딩\nembeddings = WordEmbeddingsModel.pretrained(\"embeddings_clinical\",\"en\",\"clinical/models\")\\\n    .setInputCols([\"sentence\",\"token\"])\\\n    .setOutputCol(\"embeddings\")\n\n# 종양학 모델\nmodel = MedicalNerModel.pretrained(\"ner_oncology\",\"en\",\"clinical/models\")\\\n    .setInputCols([\"sentence\",\"token\",\"embeddings\"])\\\n    .setOutputCol(\"ner_oncology\")\\\n\nconverter = NerConverterInternal()\\\n    .setInputCols([\"sentence\",\"token\",\"ner_oncology\"])\\\n    .setOutputCol(\"ner_oncology_chunk\")\n\n# 파이프라인 정의\npipeline = Pipeline(stages=[document, tokenizer, embeddings, model, converter])\n\n# 빈 데이터프레임 생성\nempty_df = spark.createDataFrame([['']]).toDF(\"text\")\n\n# 데이터프레임을 파이프라인에 맞추어 모델을 가져옵니다.\npipelineModel = pipeline.fit(empty_df)\n```\n\n모델의 효과적인 분석을 위해 이 임상 텍스트 샘플을 활용해 보겠습니다.\n\n```js\nsample_text = \"\"\"65세 여성이 복부 및 골반의 컴퓨터 단층 촬영(CT)을 받았고, 복난소에 복잡한 난소 종양이 보였습니다. 한 달 후에 실시된 Pap 스며는 비정상적인 선세포를 보여 주며 점액선암을 의심케 합니다. 병리 검사에 따르면 종양은 난관, 충수, 위막 및 5개의 비정상적으로 커진 림프절 전방에 걸쳐 있었습니다. 종양의 최종 병리학적 진단은 ⅡIC 형태의 유두낭 형성 난소 선암이었습니다. 그리고 2개월 후 환자는 폐 전이 병변이 발견되었습니다.\n\"\"\"\n```\n\n여기서 LightPipeline을 사용하여 엔티티를 추출해 보겠습니다. LightPipeline은 Spark NLP 특정 파이프라인 클래스로, Spark ML 파이프라인과 동등한 기능을 제공합니다. 다만, Spark 원칙을 준수하지 않고 모든 계산을 로컬(그러나 병렬)로 수행하여 데이터 양이 적을 때 빠른 결과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlight_model = LightPipeline(pipelineModel)\n\nlight_result_onc = light_model.fullAnnotate(sample_text)\n\n\nchunks = []\nentities = []\nsentence= []\nbegin = []\nend = []\nconfidence = []\n\nfor n in light_result_onc[0]['ner_oncology_chunk']:\n\n    begin.append(n.begin)\n    end.append(n.end)\n    chunks.append(n.result)\n    entities.append(n.metadata['entity'])\n    sentence.append(n.metadata['sentence'])\n    confidence.append(n.metadata[\"confidence\"])\n\ndf_oncology = pd.DataFrame({'chunks':chunks, 'begin': begin, 'end':end,\n                   'sentence_id':sentence, 'entities':entities, 'confidence':confidence})\n\ndf_oncology.head()\n```\n\nner_oncology 모델을 적용한 후, 샘플 임상 노트에서 다음과 같은 관련 의학적 개념이 자동으로 식별되고 추출되었습니다:\n\n![의학 개념](/assets/img/2024-05-17-ResponsetoCancerTreatment_1.png)\n\nSpark NLP를 사용하여 생성된 엔티티를 빠르게 시각화할 수 있는 기능은 개발 프로세스를 가속화하고 얻은 결과를 이해하는 데 매우 유용합니다. Spark NLP Display는 Spark NLP에서 생성된 추출된 및 레이블이 지정된 엔티티를 시각화하기 위한 오픈 소스 파이썬 라이브러리입니다. NerVisualizer 어노테이터는 추출된 명명된 엔티티를 강조하고 분석된 텍스트 위에 레이블을 표시하여 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom sparknlp_display import NerVisualizer\n\nvisualiser = NerVisualizer()\n\nvisualiser.display(light_result_onc[0], label_col='ner_oncology_chunk', document_col='document')\n```\n\n이러한 엔티티를 강조함으로써 환자의 상태, 치료 계획 및 전반적인 예후에 대한 깊은 통찰력을 얻게 되어 의료 전문가들이 맞춤형 치료를 안내하고 종양학 실무에서 치료 결과를 최적화할 수 있는 가치 있는 정보를 얻을 수 있습니다.\n\n## 임상 보고서로부터 암 치료에 대한 환자 반응 평가하기\n\nNER 모델은 임상 노트에서 종양학적 개념을 추출할 수 있지만, 치료 반응을 이해하려면 주로 내러티브의 전체 맥락을 분석해야 합니다. 텍스트 분류 모델은 환자 파일의 전반적인 내용이 긍정적인 반응을 나타내는지, 또는 질병 진행을 시사하는지를 판단할 수 있습니다. 임상 전문가가 치료 결과에 따라 파일을 레이블링한 주석이 달린 데이터셋으로 모델을 훈련하면, 이러한 모델은 상태, 증상, 영상 소견 및 기타 중요한 요소를 기술하는 언어에서 예측적인 패턴을 학습합니다. 새로운 미레이블 파일에 적용하면, 모델은 높은 정확도로 분류할 수 있습니다. 이 자동 분류는 추가 검토를 위해 사례를 필터링하고 연구를 위한 코호트 식별을 간소화하는 데 도움이 될 수 있습니다. 그러나 높은 정확도를 달성하려면 고품질의 훈련 데이터와 이 도메인에서의 실제 언어 뉘앙스를 주의 깊게 다루어야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 중요한 임무에 대한 텍스트 분류 모델의 성능을 평가하기 위해 John Snow Labs의 데이터 과학자들은 5,000개 이상의 환자 파일로 구성된 정제된 데이터셋에서 여러 모델을 훈련하고 테스트했습니다. 각 파일은 의료 전문의들에 의해 수동으로 레이블이 지정되었으며 치료 반응에 따라 '환자가 치료에 응답함' 또는 '환자가 치료에 반응하지 않음' 중 하나로 분류되었습니다. 가장 우수한 성능을 보인 모델은 이 특수 데이터셋으로 미세 조정된 BERT 기반 아키텍처였습니다.\n\n아래에 표시된 임상 텍스트 조각들에 대한 정확한 레이블 할당을 얻기 위해 종양 치료 반응 분류기를 사용해봅시다:\n\n```python\nsample_texts = [\n    [\"뇌의 콘트라스트 증강 MRI는 테모졸로마이드 요법 이후 안정된 질병을 시사하여 글리오블라스토마 크기의 변화가 없음을 보여줌.\"],\n    [\"신생 대상화 요법 이후의 유방 초음파는 3cm에서 1cm로 원발 병변 크기 감소를 보여줌으로써 치료에 대한 유리한 반응을 시사합니다. 피부 감염 역시 다중 항생제 치료로 잘 통제됨.\"],\n    [\"골반의 MRI는 복강경 총 제거 및 6개월 호르몬 억제 요법 후, 자궁내막증의 추가 진전이 없음을 나타냄.\"],\n    [\"재방문 내시경 검사는 치료되고 있는 위궤양 및  H. pylori 감염의 신증상을 보여줍니다. PPI 계속 논의할 예정입니다.\"],\n    [\"간의 다이내믹 콘트라스트 증강 MRI는 소라페닙을 이용한 6개월간의 전향요법 이후 간 전이의 크기와 개수에 상당한 감소가 없음을 나타냈습니다.\"],\n    [\"뇌혈관의 디지털 적출 혈관 조영술은 뇌동맥류 코일 재관류 후, 뇌동맥류의 진전 확장과 새로운 혈관 이상을 나타내어 시도가 실패한 것으로 나타냅니다.\"],\n    [\"환자의 반복 폐기능 검사는 FEV1과 FVC 모두에 심각한 향상이 없음을 나타냄으로써 최대한 최적화된 흡입요법으로도 천식 증상을 효과적으로 통제하는 데 실패했음을 시사합니다. 계속해서 논의할 것입니다.\"]\n]\n```\n\n이 모델의 치료에 대한 반응을 예측하는 정확성은 제공된 벤치마킹 결과에서 명확하게 확인됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-17-ResponsetoCancerTreatment_2.png\" /\u003e\n\nSpark NLP 어노테이터 MedicalBertForSequenceClassification을 사용한 텍스트 분류를 위한 파이프라인이 더욱 짧아졌어요:\n\n```js\n# 단계 1: 원시 텍스트를 `document`로 변환\ndocument_assembler = DocumentAssembler()\\\n    .setInputCol(\"text\")\\\n    .setOutputCol(\"document\")\n\n# 단계 2: 토큰화\ntokenizer = Tokenizer()\\\n    .setInputCols([\"document\"])\\\n    .setOutputCol(\"token\")\n\n# 단계 3: 텍스트 분류\nsequenceClassifier = MedicalBertForSequenceClassification.pretrained(\"bert_sequence_classifier_response_to_treatment\", \"en\", \"clinical/models\")\\\n    .setInputCols([\"document\",\"token\"])\\\n    .setOutputCol(\"prediction\")\n\npipeline = Pipeline(\n        stages=[\n            document_assembler,\n            tokenizer,\n            sequenceClassifier\n])\n\n# 샘플 텍스트에서 Spark 데이터프레임 생성\nsample_data = spark.createDataFrame(sample_texts).toDF(\"text\")\n\n# 데이터프레임을 파이프라인에 맞추고 예측값 가져오기\nresult = pipeline.fit(sample_data).transform(sample_data)\n\nresult.select(\"text\", \"prediction.result\", 'prediction.metadata').show(truncate = 100)\n```\n\n텍스트 분류 모델을 적용한 후, 샘플 임상 텍스트는 치료에 대한 응답 또는 응답이 없음을 나타내는 신뢰도 값과 함께 분류되었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모델은 임상 노트를 기반으로 반응 및 비반응 사례를 구별하는 뛰어난 능력을 보였습니다. 이러한 결과는 더 포괄적인 인간 리뷰 전 단계로서 맞춤형 텍스트 분류 모델을 사용할 수 있는 가능성을 보여줍니다. 정확도가 93% 이상이어서, 모델은 교종류팀이 우선적으로 평가할 고위험 비반응 사례를 자동으로 도출할 수 있었습니다. 더 많은 레이블이 적용 가능한 경우 계속해서 반복적인 훈련을 거침으로써 성능을 더욱 향상시킬 수 있을 것입니다.\n\n## 결론\n\n암 치료와 같이 중요한 분야에서, 치료에 대한 응답을 정확하게 평가할 수 있는 것이 치료 전략과 결과에 영향을 줄 수 있는데, John Snow Labs NER 및 텍스트 분류 모델은 복잡한 임상 보고서에서 정보 추출 및 환자 응답을 분류하는 데 높은 정확도를 달성했습니다.\n\nLLMs를 사용하여 환자의 암 치료에 대한 응답을 평가하는 것은 정확도를 향상시키고 맥락을 이해하는 데 도움이 될 수 있습니다. 일반적으로, 더 많은 매개변수를 가진 큰 모델은 많은 NLP 과제에서 더 나은 성능을 이룰 수 있지만 계산 비용이 더 많이 드는 경향이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론적으로, 이 두 가지 접근 방식은 암 치료에 대한 환자의 반응을 평가하는 데 유용한 통찰력을 제공합니다. NER 및 텍스트 분류 모델을 활용하면 임상 텍스트를 분석하는 효율적이고 정확한 방법을 제공하며 치료 결과에 대한 통찰력을 제공합니다. 한편, 수십억 개의 매개변수로 이루어진 LLM을 활용하면 맥락과 의미에 대한 보다 깊은 이해력으로 인해 향상된 정확도가 약속됩니다. 그러나 이에는 계산 자원 및 인프라 요구 사항을 포함한 비용 증가가 따릅니다. 궁극적으로, 이러한 접근 방식들 사이의 선택은 헬스케어 환경의 구체적인 요구 사항에 의존하며 정확도와 비용 효율성 사이의 절충을 균형있게 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-05-17-ResponsetoCancerTreatment_0.png"},"coverImage":"/assets/img/2024-05-17-ResponsetoCancerTreatment_0.png","tag":["Tech"],"readingTime":10},{"title":"오픈 소스 모델, 온도 조정, 재순위 매기기 등 최신 LLM 반드시 읽어야 할 글들을 놓치지 마세요","description":"","date":"2024-05-17 04:22","slug":"2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads","content":"\n\n새로운 LLM들이 거의 매일 등장하고, 그들이 가능케 하는 도구와 워크플로우도 더 빨리 확산됩니다. 우리는 이 영원히 변화하는 지형에서 최근 대화들을 되짚는 좋은 순간이라고 생각했고, 그것을 하는 더 나은 방법을 생각해내지 못했습니다. 과거 몇 주간의 강력한 기사 중 몇 가지를 강조함으로써 그것을 할 수 있다고 판단했습니다.\n\n우리가 모아둔 글의 라인업은 고수준의 질문과 미시적인 문제들을 다루고 있습니다. 그래서 AI 윤리에 관심이 있다든지, 오픈 소스 기술의 발전에 흥미가 있다든지, 혁신적인 RAG 접근법이 궁금하다든지 하더라도, 여기에서 여러분의 관심을 끄는 것이 있을 거라고 확신합니다. 함께 살펴보죠.\n\n- 변화하는 흐름: 오픈 소스 LLM이 닫힌 소스 LLM에 비해 경쟁 우위에 있는 이유\n생산적인 AI 도구의 초기 물결은 OpenAI가 출시한 프로프레타리 모델들에 의해 주도되었습니다. \n레오니 몬티아티(LTM’s)의 새로운 기사는 떠오르는 트렌드에 초점을 맞추고 있습니다: 데이터 보안, 맞춤화, 비용 등의 요소로 주목받는 작은 오픈 소스 재단 모델들이 등장하면서 점차 더 많은 시장을 지배하고 있다는 점.\n- 챗봇의 윤리?\nLLM들이 사실 정보를 요청했을 때 환각을 유발할 수 있다는 것은 알고 있습니다. 사용자들이 윤리에 초점을 맞춘 조언을 요청하기 시작했을 때 어떻게 될까요?\n에얼 아하로니와 에디 나미아스는 이 tricky한 질문과 \"특정한, 통제된 상황에서 인간의 윤리적 대화를 모방하거나 합성할 수 있는\" 챗봇들의 도덕성 지각에 내재된 위험에 대한 최신 연구를 제시합니다.\n- LLM의 추천이 제품 가시성 향상을 위해 조작될 수 있을까요?\n전자상거래는 이미 조작과 의문 스러운 비즈니스 관행에 민감한 분야입니다.\n파룰 판데이는 최근 논문 분석에서 보듯이, 텍스트와 다른 미디어를 빠르게 대량으로 생산할 수 있는 LLM은 이미이 생태계에서 여러 갭과 맹점을 악용할 수 있도록 준비되어 있습니다.\n\n![Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads_0](/assets/img/2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- LLM에서 온도 스케일링 및 빔 서치 텍스트 생성, ML-인접\n포괄적이고 예시 가득한 가이드에서,\n마이크 체트가\n생성적 AI 워크플로우 문맥에서 온도 개념을 해체합니다: 이는 모델의 출력 순서의 예측 가능성을 수정하는 매개변수이며, 그 세세한 점을 숙달함으로써 실무자들이 AI 도구를 보다 효과적으로 활용할 수 있습니다.\n- 더 나은 LLM RAG 검색을 위한 Re-Ranking 사용 방법\n검색 확장 생성에 대한 초기 흥분 이후, 많은 실무자들에게 RAG 시스템이 더 고급 정제 방법에서 효과를 볼 수 있는 것으로 명확해졌습니다.\nLeon Eversberg 박사\n의 최근 자습서에서, 우리를 더 나은 결과를 위해 (오픈 소스 바이-인코더와 크로스-인코더를 사용하는) 두 단계 검색을 활용하는 워크플로우를 안내합니다.\n\n우리의 저자들은 항상 그랬던 것처럼, 최근 몇 주간 다양한 주제로 뻗어나가며 우수한 기사들을 제공했고, 여기 대표적인 샘플이 있습니다:\n\n- 고객 평생 가치 시리즈를 여기저기에 끝낸 후,\n캐서린 군이\n가용한 예측 방법의 상세 개요와 각각에 대한 마케터와 데이터 과학자들이 기대할 수 있는 것을 제공합니다.\n- 모든\n사친 데이트가\n몰입 분석은 축하할 가치가 있으며, 최신 버전도 이외의 것이 아닙니다. 19세기 난파 사건을 통해 설득력 있는 통계 수렴의 철저한 탐구입니다.\n- 최신 초보자 친화적 가이드에서,\nSrijanie Dey 박사\n는 Llama 3로 이동하고, 그 변환기 구조의 세세한 점을 해체합니다.\n- 분자 생물학, 생물 정보학 및 AI의 교차로에서 글쓰는,\n무르토 힐라리가\n단백질 상호 작용의 변이에 대한 효과를 예측하는 다중 분류 모델을 구축하는 방법을 보여줍니다.\n- 물리학 (및 관련 분야)에서 데이터 과학으로의 직업 전환을 고려 중이라면,\n사라 노브레가\n스스로의 여정과 그동안 모은 경험을 바탕으로 한 실용적인 가이드를 놓치지 마십시오.\n- 딥 러닝을 시작하는 사람들에게는,\n쉬레야 라오가\n컨볼루션 신경망에 대한 새로운 초보자 친화적이고 전문적으로 그림으로 설명된 입문서를 가져왔습니다.\n- 콜모고로프-아놀드 네트워크 (KANs)를 공개한 논문은 겨우 2주 된 것이지만 이미 분야에서 큰 파장을 일으키고 있습니다.\n테오 울프가\nKANs가 어떻게 작동하며 그에 대한 소문이 무엇인지 이해하는 데 도움이 되는 TDS 초간단 기사를 첫 번째로 소개했습니다.\n\n우리의 저자들을 지원해 주셔서 감사합니다! 우리는 새로운 저자들로부터의 기사를 출판하는 것을 사랑하므로, 최근에 재미있는 프로젝트 설명서, 자습서 또는 핵심 주제 중 하나에 대한 이론적 반성을 작성한 경우 우리와 공유하시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 변수까지,\n\nTDS 팀","ogImage":{"url":"/assets/img/2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads_0.png"},"coverImage":"/assets/img/2024-05-17-Open-SourceModelsTemperatureScalingRe-RankingandMoreDontMissOurRecentLLMMust-Reads_0.png","tag":["Tech"],"readingTime":3}],"page":"71","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"71"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>