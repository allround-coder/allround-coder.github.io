<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/46" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/46" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" href="/post/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">클라이언트 측 로직 간소화 뷰 모델의 전략적 활용</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" href="/post/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 앱에 Stripe 결제 추가하는 방법" href="/post/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 앱에 Stripe 결제 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 앱에 Stripe 결제 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 앱에 Stripe 결제 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="12가지 유용한 JavaScript 면접 팁" href="/post/2024-05-14-12UsefulJavaScriptInterviewTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="12가지 유용한 JavaScript 면접 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="12가지 유용한 JavaScript 면접 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">12가지 유용한 JavaScript 면접 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="노드js 클러스터 구현으로 성능 개선하기" href="/post/2024-05-14-ImplementingNodejsClusterforImprovedPerformance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="노드js 클러스터 구현으로 성능 개선하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="노드js 클러스터 구현으로 성능 개선하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">노드js 클러스터 구현으로 성능 개선하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" href="/post/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jupyter 노트북에 현대적 JavaScript 가져오기" href="/post/2024-05-14-BringingModernJavaScripttotheJupyterNotebook"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jupyter 노트북에 현대적 JavaScript 가져오기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jupyter 노트북에 현대적 JavaScript 가져오기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Jupyter 노트북에 현대적 JavaScript 가져오기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" href="/post/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아스트로 JS 프로젝트용 Neovim 설정" href="/post/2024-05-14-NeovimSetupforAstroJsProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아스트로 JS 프로젝트용 Neovim 설정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아스트로 JS 프로젝트용 Neovim 설정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아스트로 JS 프로젝트용 Neovim 설정</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" href="/post/2024-05-14-IHateJavaScriptThankYouBlazor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link posts_-active__YVJEi" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"클라이언트 측 로직 간소화 뷰 모델의 전략적 활용","description":"","date":"2024-05-15 02:45","slug":"2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels","content":"\n\n\n![User View Model](/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png)\n\n애플리케이션은 종종 서버에서 직접 사용 가능한 데이터 표현과는 다른 데이터 표현이 필요합니다. 예를 들어 사용자 객체에는 열거형 역할, 열거형 상태, 이름 등의 속성이 포함될 수 있습니다. 클라이언트 측 뷰에서 이러한 서버 측 모델을 직접 사용하면 종종 UI 로직 전체에 분산된 복잡한 변환을 유발합니다.\n\n이 문제를 해결하기 위해 각 엔티티에 대한 뷰 모델 클래스를 생성하는 것을 주장합니다. 이 캡슐화는 데이터 처리를 간단하게 만들어주며 UI가 필요한 것만 받도록 보장합니다. 다음은 UserVm의 간단한 실제 예시입니다:\n\n```js\nconst rolesMap = fromBeEnum(UserRoleEnum, {\n  VIEWER: '뷰어',\n  ADMIN: '관리자',\n  SIGNER: '서명자',\n  OWNER: '소유자'\n});\n\nexport class UserVm {\n  constructor(dto: User) {\n    this.displayName = dto.name || dto.email;\n    this.isActive = dto.status === UserStatusEnum.ACTIVE;\n    this.isServiceAccount = dto.type === UserTypeEnum.SERVICE_ACCOUNT;\n    this.isViewer = dto.role === UserRoleEnum.VIEWER;\n    this.isOwner = dto.role === UserRoleEnum.OWNER;\n    this.isActiveAdmin = dto.isAdmin \u0026\u0026 this.isActive;\n    this.typeLabel = dto.isServiceAccount ? '서비스 계정' : '사용자';\n    this.roleLabel = this.userRoleToLabel();\n    this.hasAddQuorum = hasQuorum(dto, 'add');\n    this.hasRemoveQuorum = hasQuorum(dto, 'remove');\n    this.isPendingApproval = this.hasAddQuorum || this.hasRemoveQuorum;\n  }\n  \n  private userRoleToLabel() {\n    return rolesMap[this.dto.role] || '알 수 없음';\n  }\n}\n```\n\n\n\ngetUser 엔드포인트에서 데이터를 받으면 UserVm 클래스를 사용하여 응답에 맞는 새 사용자 뷰 모델을 생성합니다. 이 추상화를 통해 깔끔하고 유지 관리 가능한 코드 구조를 유지할 수 있습니다.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getUser({ vaultId }) {\n    return this.query({\n      queryKey: ['user'],\n      queryFn: () =\u003e {\n        return this.client.getAuthenticatedUser({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(user =\u003e new UserVm())\n    )\n  }\n}\n```\n\n이 원칙은 엔티티 배열을 다룰 때에도 동일하게 적용됩니다. 예를 들어, 응용 프로그램 내에서 거래가 어떻게 처리되는지 살펴보면 — UI 변환을 거치는 중요한 엔티티인 거래에 대해 어떻게 다루는지에 대해 생각해 보세요.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class TransactionsService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getTransactions({ vaultId }) {\n    return this.query({\n      queryKey: ['transactions'],\n      queryFn: () =\u003e {\n        return this.client.getTransactions({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(res =\u003e res.transactions.map(t =\u003e new TransactionVm(t)))\n    )\n  }\n}\n```\n\n\n\n# 뷰 모델 사용의 이점\n\n## 명확성과 사용자 정의\n\n백엔드 네이밍 규칙 때문에 머리를 긁는 순간들을 우리 모두 겪어봤죠 😛. 뷰 모델은 속성 이름을 바꿔 더 직관적으로 만들 수 있습니다. DTO 이름이 애매할 때, VM은 DTO를 직접 변경하지 않고 더 구체적인 이름을 사용하는 방법을 제공합니다.\n\n## 스키마 유연성\n\n\n\nVMs(Visual Models)은 백엔드 구조에 영향을 미치지 않고 DTO 스키마를 애플리케이션의 요구에 더 잘 맞게 수정할 수 있는 기회를 제공합니다. 이 유연성은 다양한 사용 케이스에 적응하는 데 중요합니다.\n\n## 중앙화된 수정\n\nDTO에 중요한 변경이 있거나 예기치 못한 수정이 필요한 경우, 조정은 뷰 모델에서만 하면 되며 애플리케이션 전체에 수정을 반영할 필요가 없습니다. 이 중앙화는 버그와 유지보수 부담을 크게 줄여줍니다.\n\n## 캡슐화\n\n\n\n변환 로직을 VM 내부로 캡슐화하면 컴포넌트 전체에서의 파이프, 유틸리티 함수 및 열거형에 대한 의존성이 줄어들어 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n## 재사용성\n\n한 번 정의된 View Model은 응용 프로그램의 다른 부분 또는 다른 프로젝트에서도 재사용할 수 있습니다. 이러한 재사용성은 개발 시간을 크게 단축하고 오류를 줄일 수 있습니다. 예를 들어, ownerVm을 사용하는 DeviceVm의 시나리오를 살펴보겠습니다:\n\n```js\nexport class DeviceVm {\n  ownerVm: UserVm;\n\n  constructor(device: Device) {\n    // ...device props\n    this.ownerVm = new UserVm(device.owner);\n  }\n}\n```\n\n\n\n이 설정을 사용하면 장치를 처리하는 애플리케이션의 어떤 부분이든 UserVm에서 사용 가능한 풍부한, 사전 처리된 데이터를 자동으로 활용할 수 있습니다.\n\nEntity 간 관련이 있는 복잡한 데이터 구조는 조합된 VM에서 크게 이점을 얻을 수 있습니다. 예를 들어, 여러 장치를 가진 사용자 시나리오는 다음과 같이 보일 수 있습니다:\n\n```js\nexport class UserWithDevicesVm extends UserVm {\n  devices: DeviceVm[];\n\n  constructor(user: User, devices: Device[]) {\n    super(user); // 기본 UserVm 초기화\n    this.devices = devices.map(device =\u003e new DeviceVm(device));\n  }\n}\n\n// 서비스에서\nimport { intersectResults$ } from '@ngneat/query';\n\ncombineLatest([\n  this.usersService.getUsers({ vaultId }),\n  this.devicesService.getDevices({ vaultId })\n]).pipe(\n  intersectResults$(([users, devices]) =\u003e {\n    const userDevices = devices.filter(...); \n    return users.map(user =\u003e new UserWithDevicesVm(user, userDevices));\n  })\n)\n```\n\n# 업데이트용 뷰 모델 복제\n\n\n\n가끔가다 VM을 업데이트해야 할 때가 있습니다. 이런 경우를 위해 원본 DTO를 보존하고 복제 방법을 구현할 수 있습니다:\n\n```js\nexport class DeviceVm {\n  \n  constructor(private dto: Device) {\n    // 장치 속성\n  }\n  \n  clone() {\n    return new DeviceVm(this.dto)\n  }\n}\n```\n\n제 애플리케이션에서는 보통 VM을 직접 업데이트하지 않습니다. 대신 성능 문제가 없는 한, @ngneat/query(내부적으로 tanstack/query를 사용)의 invalidateQueries 함수를 활용합니다. 이 방식은 서버에서 데이터를 다시 가져오고 자동으로 새 VM을 생성하여 사용자 인터페이스를 업데이트합니다.\n\n# 결론\n\n\n\n뷰 모델은 애플리케이션 데이터를 관리하기 위한 강력한 패턴으로 작용합니다. 이들은 클라이언트 측 개발을 단순화할 뿐만 아니라 애플리케이션의 유지 보수성과 확장성을 향상시킵니다. 데이터 처리 및 변환을 전용 클래스로 추상화함으로써, 개발자들은 견고하고 사용자 친화적인 인터페이스를 구축하는 데 집중할 수 있습니다.\n\nAngular 및 JS에 대해 더 알아보려면 Medium 또는 Twitter에서 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png"},"coverImage":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png","tag":["Tech"],"readingTime":5},{"title":"API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터","description":"","date":"2024-05-15 02:43","slug":"2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters","content":"\n\n이 글에서는 개발자가 API의 성능을 향상시키기 위해 사용할 수 있는 최적화 시리즈를 탐색해 보겠습니다. API를 디자인할 때 최적의 성능을 확보하는 것이 중요합니다. 그러나 때로는 사용 가능한 도구를 효과적으로 활용하지 못하거나, 충분한 정보가 없어 판단을 내리기 어려울 수 있습니다.\n\n일반적인 시나리오를 살펴보겠습니다: 데이터베이스에서 카테고리 및 해당 카테고리에 속한 제품을 가져오는 과정입니다. 우리는 구현할 수 있는 다양한 최적화 또는 수정 단계를 따라갈 것입니다.\n\n```js\nList\u003cCategory\u003e categories = getAllCategory();\n        \ncategories.forEach(category -\u003e {\n    Product product = getProductByCategory(category.getId());\n    productList.add(product);\n});\n```\n\n이 코드 조각은 잘 작동하며 우리가 하려고 하는 작업을 수행합니다. 그런데 더 나은 방법이 있을까요?\n\n\n\n병렬 스트림이 도와드릴게요!!!\n\nJava는 API 성능을 향상시키기 위해 병렬 스트림을 제공하지만 효율적으로 사용하지 않으면 시스템 가속화에 도움이 되지 않을 수 있습니다. 병렬 스트림은 백그라운드 OS 스레드를 활용하여 실행하므로 스레드 컨텍스트 전환의 오버헤드를 고려하면서 효과적으로 사용하는 방법을 이해하는 것이 중요합니다.\n\n배치 처리 소개\n\n한 걸음 더 나아가서 일부 배치 처리를 사용하고 병렬 스트림을 활용하여 더욱 최적화할 수 있습니다.\n\n\n\n```java\nList\u003cCategory\u003e categories = getAllCategory();\nList\u003cList\u003cCategory\u003e\u003e partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch -\u003e {\n    categoryBatch.parallelStream().forEach(category -\u003e {\n        Product product = getProductByCategory(category.getId());\n        productList.add(product);\n    });\n});\n```\n\n파티션 함수는 원본 목록을 지정된 배치 크기를 기준으로 일괄로 나눕니다. 예를 들어, 원본 목록에 220개의 요소가 있다면 결과 목록은 크기가 `50, 50, 50, 50, 20`인 5개의 요소로 나눠질 것입니다.\n\n그리고 이제 중첩된 병렬 스트림을 사용하여 요소를 반복할 수 있습니다.\n\n다중 처리를 잘 활용한 것 같은데, 더 개선할 부분이 있을까요?\n\n\n\n데이터베이스 최적화\n\n이제 최적화된 접근법처럼 보이지만, 여전히 DB(데이터베이스)에 N번 접근하고 있습니다. 다만, 여러 스레드를 사용하여 동일한 작업을 수행하고 있을 뿐입니다.\n\n더 좋은 접근 방식은 분할된 목록을 사용하여 WHERE 절을 구성하고 여러 카테고리 ID를 전달하여 단일 데이터베이스 호출을 실행하는 것입니다.\n\n```js\ndb.getCollection('Product').find({'category_id':{$in:['categoryId1','categoryId2']}\n```\n\n\n\n```js\nBson filter = Filters.in(\"categoryId\", \"categoryId1\", \"categoryId2\");\n// 마찬가지로 필터를 사용하여 카테고리 ID를 전달할 수 있습니다.\nList\u003cCategory\u003e categories = getAllCategory();\nList\u003cList\u003cCategory\u003e\u003e partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch-\u003e{\n    Bson filter = Filters.in(\"categoryId\", categoryBatch);\n    List\u003cProduct\u003e productsBatch = getProducts(filter);\n    productList.addAll(productsBatch);\n});\n```\n\nBson 필터를 사용하여 데이터 검색을 구현하면 API에 유연성을 추가할 수 있어서 클라이언트가 쿼리를 자신의 요구에 맞게 조정할 수 있습니다. 이 방식은 API의 사용성을 향상시키고 다양한 시나리오에서 유용하게 사용할 수 있도록 합니다.\n\n지금까지 한 작업을 요약해볼까요!\n\n정말 멋진 개선이군요. 일괄 검색 및 여러 스레드를 활용하면 데이터베이스 호출 수를 줄이고 병렬 처리를 효율적으로 활용하여 성능을 크게 향상시킬 수 있습니다. API의 성능에 상당한 최적화가 되었으므로 성능 상에서 뚜렷한 차이를 느낄 수 있을 겁니다.\n\n\n\n\n이 풀 리퀘스트는 정말 리뷰할 준비가 되어 있어요! 😄🚀","ogImage":{"url":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"},"coverImage":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs 앱에 Stripe 결제 추가하는 방법","description":"","date":"2024-05-14 16:09","slug":"2024-05-14-HowtoaddStripepaymentstoyourNextjsapp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png\" /\u003e\n\n와! 내 매체 암호를 찾았어요!\n\n이제, 내 첫 번째 기사에서 Stripe를 Next.js 앱에 통합하는 방법에 대해 이야기하려고 해요.\n\n이 프로젝트에서는 너무 복잡한 것을 만드는 데 주의를 기울이지 않을 거에요. 대신에 우리는 간편한 Next.js 13.4 앱을 개발하여 일회성 Stripe 결제를 가능하게 할 거에요.\n\n\n\n## 설정하기\n\n터미널을 열고 나의 경우에는 Workspace 안에서 다음 명령을 실행해 주세요.\n\n```js\nnpx create-next-app@latest\n```\n\n위 명령을 실행하면 \"create-next-app@13.4.1\"을 설치하라는 메시지가 표시되며 몇 가지 질문이 있을 겁니다.\n\n\n\n- 프로젝트 이름은 무엇인가요? stripe-nextjs\n- TypeScript를 사용하고 싶나요? 네\n- ESLint를 사용하고 싶나요? 네\n- 이 프로젝트에 Tailwind CSS를 사용하고 싶나요? 아니요, 스타일 작업을 하지 않을 예정이기 때문에\n- `src/` 디렉토리를 사용하고 싶나요? 네\n- App Router를 사용하시겠습니까? 네\n- 기본 import 별칭을 사용자 정의하시겠습니까? 아니요\n\n질문에 모두 답했다면, 설치가 시작됩니다!\n\n이제 설치가 완료되었습니다! 이제 실제로 Next.js 앱을 보려면 터미널에서 다음 명령을 실행하세요. Next.js 앱 내부에 있는지 확인하세요.\n\n```js\nyarn run dev\n```\n\n\n\n더 나아가기 전에, Stripe 계정을 생성하고 API 키를 받아봐요.\n\nStripe 계정을 만든 후에, dashboard.stripe.com/test/apikeys로 이동해서 API 키를 받아요.\n\n## 환경 파일 설정하기\n\n루트 디렉토리 안에, .env.local이라는 파일을 만들어주세요.\n\n\n\n.env.local 파일 안에 다음을 추가해주세요:\n\n```js\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\"\"\nSTRIPE_SECRET_KEY=\"\"\n```\n\n여기서 기억해야 할 중요한 점이 몇 가지 있어요. 먼저, \"\"\"를 Stripe 키로 대체해야 합니다. 둘째로, 두 변수 간의 차이를 이해하는 것이 중요합니다. 하나는 \"NEXT_PUBLIC\"을 포함하고 다른 하나는 포함하지 않습니다. 간단히 말해서, \"NEXT_PUBLIC\"을 사용하여 STRIPE_PUBLISHABLE_KEY를 노출시키는 것은 괜찮지만 시크릿 키는 절대로 클라이언트 측에 노출되어서는 안 됩니다.\n\n알았어요, 이해했어요? 그럼 다음 단계로 넘어갑시다!\n\n\n\n## 필요한 패키지 설치하기\n\n당신의 Next.js 앱 내부에 다음 패키지를 설치해보세요:\n\n```js\n@stripe/react-stripe-js @stripe/stripe-js stripe axios\n```\n\n## 백엔드 작업을 시작해봅시다\n\n\n\n우리 앱 폴더 안에 api라는 새 폴더를 만들어주세요. 이곳에 모든 백엔드 코드가 위치하게 됩니다.\n\napi 폴더 안에 create-payment-intent라는 새 폴더를 만들고, 그 안에 route.ts 라는 파일을 생성해주세요.\n\n![이미지](/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_1.png)\n\n\"create-payment-intent\" 폴더 안에 \"route\"라는 파일을 만드는 이유는 Next.js에 API 요청을 다루고 있다는 것을 알리는 것입니다. 공식 문서에 따르면, route는 라우팅의 가장 기본적인 수준으로, 페이지가 하는 것처럼 레이아웃이나 클라이언트 측 탐색에 영향을주지 않습니다. \"route.ts\" 파일이 \"page.ts\" 파일이 있는 곳에 존재할 수 없다는 점을 명심해야 합니다. 자세한 내용은 문서를 참고하는 것을 강력히 권장합니다.\n\n\n\n여기는 route.ts 파일의 코드입니다:\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n\nexport async function POST(req: NextRequest) {\n  const { data } = await req.json();\n  const { amount } = data;\n  try {\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(amount) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n  } catch (error: any) {\n    return new NextResponse(error, {\n      status: 400,\n    });\n  }\n}\n```\n\n이것을 자세히 살펴보고 무슨 일이 일어나고 있는지 이해해 봅시다.\n\n첫째로, 우리는 타입과 stripe를 import 합니다:\n\n\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n```\n\n다음으로 stripe 인스턴스를 만듭니다:\n\n```js\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n```\n\n우리의 Stripe 인스턴스는 env.local 파일에서 Stripe 비밀키가 필요합니다. 더 나아가, 우리는 Stripe 인스턴스에 TypeScript를 활성화하고 인스턴스용 Stripe API 버전을 지정했습니다.\n\n\n\n계속 진행하기 전에 Next.js 13.4에서 API 경로를 다루는 방법에 대해 이야기해 봅시다.\n\n아마 이미 주목했을 것이지만, 함수의 제목이 \"POST\"와 같이 모두 대문자로 되어 있습니다. 이 네이밍 규칙은 Next.js가 실행할 해당 HTTP 메소드를 결정하기 위해 필요합니다. 예를 들어, GET 요청을 수행하려면 함수의 제목을 \"GET\"으로 지정해야 하며, 수행하려는 다른 작업에 대해서도 유사하게 지정해야 합니다.\n\n알겠습니다, 이해했습니다, 좋아요! 계속 진행합시다!\n\n우리 함수 내에서는 요청에서 데이터를 비구조화하는 방식으로 진행합니다. 그 후에는 데이터 객체에서 금액을 더욱 세분화합니다.\n\n\n\n```js\nconst { data } = await req.json();\nconst { amount } = data;\n```\n\n이제 모든 흥미로운 로직이 발생하는 trycatch 블록을 살펴보겠습니다!\n\n파고들어 봅시다.\n\n```js\nconst paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(price) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n```\n\n\n\n우리의 try 블록 안에서, 결제 인텐트를 생성할 것입니다. 결제 인텐트에 대해 잘 모르신다면 걱정하지 마세요. 거래에 관한 중요한 정보를 담고 있죠. 지원되는 결제 방법, 징수할 금액, 그리고 희망하는 통화를 포함하고 있습니다.\n\n마지막으로, Stripe로부터 얻은 클라이언트 시크릿을 포함한 응답을 반환할 것입니다. 이 단계는 매우 중요합니다. 왜냐하면 우리는 클라이언트 측에서 Stripe가 결제를 확인하는 데 도움을 주기 위해 클라이언트 시크릿을 활용할 것이기 때문이죠.\n\n```js\n    return new NextResponse(error, {\n      status: 400,\n    });\n```\n\n우리의 catch 블록 안에서는 간단히 오류를 포함한 응답을 반환합니다.\n\n\n\n이 시점에서 백엔드 개발은 완료되었습니다. 이제 새로 만든 엔드포인트와 상호 작용할 클라이언트 측으로 이동해 봅시다.\n\n## 프론트엔드\n\n마법을 시작하기 전에 정리해 봅시다!\n\nlayout.tsx 파일에서 global.css를 불러오는 줄을 삭제하세요. 스타일에 대해서는 다루지 않을 거에요.\n\n\n\n앱.tsx 파일에서 `main` 태그 내부의 모든 내용을 삭제하고, Image 컴포넌트 import 구문을 삭제해주세요.\n\n좋아요, 이 시점에서 layout.tsx 파일은 다음과 같아야 합니다:\n\n```js\nimport { Inter } from \"next/font/google\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody className={inter.className}\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n그리고 app.tsx 파일은 다음과 같아야 합니다:\n\n\n\n```js\nexport default function Home() {\n  return (\n    \u003c\u003e\u003c/\u003e\n  );\n}\n```\n\n여기 멋진 곳에요, 결제 양식을 설정해 봅시다!\n\n\"src\" 폴더에서 \"components\"라는 새 폴더를 만들어 주세요. \"components\" 폴더 안에 \"PaymentForm\"이라는 또 다른 폴더를 만들어 주세요. \"PaymentForm\" 폴더 안에 \"PaymentForm.tsx\"라는 파일을 만들어 주세요. 거기에 우리의 결제 양식이 위치하고 대부분의 로직이 여기서 실행될 거에요.\n\n시작해 봅시다!\n\n\n\n우리가 컴포넌트 작성을 시작하기 전에, Next.js에게 서버 컴포넌트가 아닌 클라이언트 컴포넌트를 다루고 있다는 것을 알려주어야 해요.\n\nPaymentForm.tsx 파일의 맨 위에 다음을 추가해주세요:\n\n```js\n\"use client\";\n```\n\n그 다음에 다음과 같은 import 문을 추가해주세요:\n\n\n\n```js\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n```\n\n이제 빈 컴포넌트를 생성해봅시다:\n\n```js\nexport default function PaymentForm() {\n  return \u003c\u003e\u003c/\u003e;\n}\n```\n\n지금까지의 파일은 이렇게 보여야 합니다:\n\n\n\n```js\n\"사용자용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  return \u003c\u003e\u003c/\u003e;\n}\n```\n\n우리 컴포넌트 안에서 처음으로 해야 할 일은 Stripe 훅을 사용하는 것인데, 우리가 사용할 훅은 useStripe와 useElements 입니다.\n\n```js\n  const stripe = useStripe();\n  const elements = useElements();\n```\n\nfrom을 제출할 수 있는 onSubmit이라는 함수를 만들어봅시다.```\n\n\n\n```js\n  const onSubmit = async (e: React.FormEvent\u003cHTMLFormElement\u003e) =\u003e {}\n```\n\nonSubmit 함수 안에서 e.preventDefault(); 를 사용하여 기본 동작을 막아줍시다.\n\n다음으로, stripe 카드 엘리먼트에 다음 스니펫을 사용하여 접근해야 합니다:\n\n```js\n    const cardElement = elements?.getElement(\"card\");\n```\n\n\n\n지금부터 실제 마법을 시도해 봅시다!\n\ntry-catch 블록을 만들어 봅시다. try 블록 안에는 stripe와 cardElement의 존재 여부를 확인하는 조건문을 만들 것입니다. 둘 중 하나라도 누락된 경우, onSubmit 함수를 효과적으로 중단시키고 더 이상의 작업을 방지하기 위해 null을 반환할 것입니다.\n\ncatch 블록에서는 단순히 error를 console.log 하면 됩니다.\n\n다음은 코드 조각입니다:\n\n\n\n```js\n    try {\n      if (!stripe || !cardElement) return null;\n    } catch (error) {\n      console.log(error);\n    }\n```\n\n안녕하세요 여러분, 지금 좋은 위치에 있어요. 계속 진행하죠.\n\nStripe와 cardElement가 모두 존재하는지 확인한 후에, 이전에 백엔드에서 설정한 API를 사용하여 결제 의도를 생성할 수 있습니다. API에 전달할 데이터는 금액이 포함되며, 저의 경우에는 89로 설정되어 있어요.\n\n```js\n    const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n```\n\n\n\n응답을 clientSecret라는 변수에 할당해보세요.\n\n```js\nconst clientSecret = data;\n```\n\n마지막으로 우리가 해야 할 일은 stripe에서 제공하는 confirmCardPayment 메서드를 사용하여 결제를 확인하는 것입니다. 아래는 예시 코드 조각입니다:\n\n```js\nawait stripe?.confirmCardPayment(clientSecret, {\n  payment_method: { card: cardElement },\n});\n```\n\n\n\n지금까지 onSubmit 함수를 완료했습니다.\n\n우리의 컴포넌트가 stripe에서 제공하는 CardElement 컴포넌트를 사용하는 폼을 반환하도록 만들어보겠습니다.\n\n```js\n    \u003cform onSubmit={onSubmit}\u003e\n      \u003cCardElement /\u003e\n      \u003cbutton type=\"submit\"\u003e제출하기\u003c/button\u003e\n    \u003c/form\u003e\n```\n\n최종 결과:\n\n\n\n```js\n\"사용자 사용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  const stripe = useStripe();\n  const elements = useElements();\n\n  const onSubmit = async (e: React.FormEvent\u003cHTMLFormElement\u003e) =\u003e {\n    e.preventDefault();\n    const cardElement = elements?.getElement(\"card\");\n\n    try {\n      if (!stripe || !cardElement) return null;\n      const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n      const clientSecret = data;\n\n      await stripe?.confirmCardPayment(clientSecret, {\n        payment_method: { card: cardElement },\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  return (\n    \u003cform onSubmit={onSubmit}\u003e\n      \u003cCardElement /\u003e\n      \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n좋은 소식입니다! 우리의 PaymentForm 컴포넌트가 이제 완성되었습니다. 만세! 이제 마지막 단계로 넘어가서, 새롭게 생성된 PaymentForm 컴포넌트를 사용하도록 앱의 app.tsx 파일을 업데이트하는 것을 진행해보겠습니다.\n\nPaymentForm 컴포넌트가 app.tsx 안에서 사용되기 전에, 몇 가지를 import하고 stripe를 로드해야 합니다.\n\n```js\n\"사용자 사용\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n```\n\n\n\nstripe를 불러와보겠습니다:\n\n```js\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n```\n\nstripe를 컴포넌트 외부에서 로드하는 것을 확인해주세요. 그렇지 않으면 stripe가 매번 렌더링되어 원하지 않는 결과가 발생할 수 있습니다.\n\n마지막으로, return 문 안에서 우리에게 제공된 Element 공급자를 활용해봅시다. PaymentForm 컴포넌트를 해당 공급자로 감싸겠습니다. 다음과 같이 보여야 합니다:\n\n\n\n여기 완성된 결과입니다:\n\n```js\n\"use client\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n// 컴포넌트 렌더링 시에 `Stripe` 객체를 다시 생성하는 것을 피하기 위해\n// `loadStripe`를 컴포넌트 밖에서 호출하는 것을 확인해주세요.\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n\nexport default function Home() {\n  return (\n    \u003cElements stripe={stripePromise}\u003e\n      \u003cPaymentForm /\u003e\n    \u003c/Elements\u003e\n  );\n}\n```\n\n와! Stripe를 사용하여 결제 폼을 만들었네요. 잘 했어요!\n\n\n\n이 글이 도움이 되었으면 좋겠어요! 앞으로 여기서 더 활발하게 활동할 거에요. 기대돼요 🤔\n\n여기 git 레포지토리 링크에요. 즐겨보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png","tag":["Tech"],"readingTime":10},{"title":"12가지 유용한 JavaScript 면접 팁","description":"","date":"2024-05-14 16:06","slug":"2024-05-14-12UsefulJavaScriptInterviewTips","content":"\n\n제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록\n\n![자바스크립트에 대해 알아야 할 것들](/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png)\n\n이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.\n\n이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.\n\n\n\n# 1. 'Set' 객체는 무엇이며 어떻게 작동하나요?\n\nSet 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.\n\nSet 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.\n\n```js\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n```\n\n\n\nSet 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.\n\n```js\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n```\n\n특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.\n\n```js\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n```\n\n\n\nSet 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.\n\n```js\nset2.size // 10을 반환합니다\n```\n\n모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.\n\n```js\nset2.clear();\n```\n\n\n\n배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n```\n\n## 2. 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.\n\n\n\n자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.\n\n```js\nconst btnAdd = document.getElementById('btnAdd');\n\nbtnAdd.addEventListener('click', function clickCallback(e) {\n    // 아무 일도 하지 않음\n});\n```\n\n이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.\n\n배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.\n\n\n\n# 3. ES6 모듈이란 무엇인가요?\n\n모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.\n\n- CommonJS-Node.js\n- AMD (비동기 모듈 정의) - 브라우저\n\n기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.\n\n\n\n## 내보내기\n\nES5(CommonJS) 사용\n\n```js\n// ES5(CommonJS)를 사용하여 - helpers.js\nexports.isNull = function(val) {\n  return val === null;\n}\n\nexports.isUndefined = function(val) {\n  return val === undefined;\n}\n\nexports.isNullOrUndefined = function(val) {\n  return exports.isNull(val) || exports.isUndefined(val);\n}\n```\n\nES6 모듈 사용\n\n\n\n```js\n// Using ES6 Modules - helpers.js\nexport function isNull(val){\n  return val === null;\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\nexport function isNullOrUndefined(val) {\n  return isNull(val) || isUndefined(val);\n}\n```\n\n다른 파일에서 함수 가져오기\n\n```js\n//ES5 (CommonJS) - index.js\nconst helpers = require('./helpers.js'); // helpers는 객체임\nconst isNull = helpers.isNull;\nconst isUndefined = helpers.isUndefined;\nconst isNullOrUndefined = helpers.isNullOrUndefined;\n// 또는 환경이 구조 분해를 지원하는 경우\nconst { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js');\n-------------------------------------------------------\n// ES6 Modules - index.js\nimport * as helpers from './helpers.js'; // helpers는 객체임\n// 또는 \nimport { isNull, isUndefined, isNullOrUndefined as isValid } from './helpers.js';\n// \"as\"를 사용하여 명명된 내보내기 이름 변경\n```\n\n파일에서 단일 함수 또는 기본 내보내기 내보내기\n\n\n\nES5 (CommonJS)\n\n```js\n// ES5 (CommonJS) - index.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nmodule.exports = Helpers;\n```\n\nES6 Modules을 사용하는 예시\n\n```js\n// using ES6 Modules - helpers.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nexport default Helpers;\n```\n\n\n\n다른 파일에서 함수를 한 개 가져오기\n\nES5(CommonJS)를 사용하는 방법\n\n```js\n// ES5(CommonJS) - index.js\nconst Helpers = require('./helpers.js');\nconsole.log(Helpers.isNull(null));\n```\n\nES6 모듈 사용법\n\n\n\n```js\nimport Helpers from '.helpers.js'\nconsole.log(Helpers.isNull(null));\n```\n\n## 4. Promise이 무엇인가요?\n\nPromise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.\n\n```js\nfs.readFile('somefile.txt', function (e, data) {\n  if (e) {\n    console.log(e);\n  }\n  console.log(data);\n});\n```\n\n\n\n만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.\n\n```js\n// 콜백 지옥\nfs.readFile('somefile.txt', function (e, data) {\n  //여기에 코드 작성\n  fs.readdir('directory', function (e, files) {\n    //여기에 코드 작성\n    fs.mkdir('directory', function (e) {\n      //여기에 코드 작성\n    })\n  })\n})\n```\n\n이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.\n\n```js\npromReadFile('file/path')\n  .then(data =\u003e {\n    return promReaddir('directory');\n  })\n  .then(data =\u003e {\n    return promMkdir('directory');\n  })\n  .catch(e =\u003e {\n    console.log(e);\n  })\n```  \n\n\n\n약속은 세 가지 다른 상태를 가집니다:\n\n- 대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.\n- 충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.\n- 거부됨(rejected): 작업이 실패한 상태입니다.\n\n대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:\n\n```js\nconst myFirstPromise = new Promise((resolve, reject) =\u003e {\n    setTimeout(function(){\n        resolve(\"Success!\"); \n    }, 250);\n});\n\nmyFirstPromise.then((data) =\u003e {\n    console.log(\"Yay! \" + data);\n}).catch((e) =\u003e {...});\n```\n\n\n\n# 5. async/await이란 무엇이며 어떻게 동작합니까?\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.\n\n\n\n```js\n기능 callApi() {\n  return fetch(\"url/to/api/endpoint\")\n    .then(resp =\u003e resp.json())\n    .then(data =\u003e {\n      // \"data\"와 무언가를 처리합니다\n    }).catch(err =\u003e {\n      // \"err\"과 무언가를 처리합니다\n    });\n}\n```\n\nasync/await\n\nasync/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.\n\n```js\nasync function callApi() {\n  try {\n    const resp = await fetch(\"url/to/api/endpoint\");\n    const data = await resp.json();\n    // \"data\"와 무언가를 처리합니다\n  } catch (e) {\n    // \"err\"과 무언가를 처리합니다\n  }\n}\n```\n\n\n\n참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\ngiveMeOne()\n  .then((num) =\u003e {\n    console.log(num); // 1을 출력합니다\n  });\n```\n\n참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\nfunction getOne() {\n  try {\n    const num = await giveMeOne();\n    console.log(num);\n  } catch (e) {\n    console.log(e);\n  }\n}\n// Uncaught SyntaxError: await is only valid in async function\nasync function getTwo() {\n  try {\n    const num1 = await giveMeOne(); \n    const num2 = await giveMeOne(); \n    return num1 + num2;\n  } catch (e) {\n    console.log(e);\n  }\n}\nawait getTwo(); // 2\n```\n\n\n\n# 6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?\n\n스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.\n\n나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.\n\n```js\nfunction add(a, b) {\n  return a + b;\n};\n\nconst nums = [5, 6];\nconst sum = add(...nums);\nconsole.log(sum);\n```\n\n\n\n이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.\n\n```js\nfunction add(...rest) {\n  return rest.reduce((total, current) =\u003e total + current);\n};\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add(1, 2, 3, 4, 5)); // 15\n```\n\n이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.\n\n```js\nconst [first, ...others] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(others); // [2, 3, 4, 5]\n```\n\n\n\n여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.\n\n# 7. 기본 매개변수란?\n\n기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.\n\n```js\n//ES5 버전\nfunction add(a, b) {\n  a = a || 0;\n  b = b || 0;\n  return a + b;\n}\n\n//ES6 버전\nfunction add(a = 0, b = 0) {\n  return a + b;\n}\nadd(1); // 1을 반환\n```\n\n\n\n기본 매개변수에서 해체 할당을 사용할 수도 있어요.\n\n```js\nfunction getFirst([first, ...rest] = [0, 1]) {\n  return first;\n}\n\ngetFirst();  // 0\ngetFirst([10,20,30]);  // 10\nfunction getArr({ nums } = { nums: [1, 2, 3, 4] }){\n    return nums;\n}\ngetArr(); // [1, 2, 3, 4]\ngetArr({nums:[5,4,3,2,1]}); // [5,4,3,2,1]\n```\n\n이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.\n\n```js\nfunction doSomethingWithValue(value = \"Hello World\", callback = () =\u003e { console.log(value) }) {\n  callback();\n}\ndoSomethingWithValue(); //\"Hello World\"\n```\n\n\n\n# 8. 래퍼 객체란 무엇인가요?\n\n이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.\n\n기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt\n\n참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.\n\n\n\n참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:\n\n```js\nlet name = \"maxwell\";\n\nconsole.log(typeof name); // \"string\"\nconsole.log(name.toUpperCase()); // \"MAXWELL\"\n```\n\n이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.\n\n그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:\n\n\n\n```js\nconsole.log(new String(name).toUpperCase()); // \"MAXWELL\"\n```\n\n속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.\n\n## 9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?\n\n암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.\n\n\n\n아래의 예시를 가정해 봅시다.\n\n```js\nconsole.log(1 + '6'); // 16\nconsole.log(false + true); // 1\nconsole.log(6 * '2'); // 12\n```\n\n첫 번째 `console.log` 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.\n\n두 번째 `console.log` 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.\n\n\n\n세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.\n\n반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.\n\n```js\nconsole.log(1 + parseInt('6'));\n```\n\n이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.\n\n\n\n# 10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?\n\nNaN은 \"숫자가 아님(Not a Number)\"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.\n\n```js\nlet a;\n\nconsole.log(parseInt('abc')); // NaN\nconsole.log(parseInt(null)); // NaN\nconsole.log(parseInt(undefined)); // NaN\nconsole.log(parseInt(++a)); // NaN\nconsole.log(parseInt({} * 10)); // NaN\nconsole.log(parseInt('abc' - 2)); // NaN\nconsole.log(parseInt(0 / 0)); // NaN\nconsole.log(parseInt('10a' * 10)); // NaN\n```\n\nJavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.\n\n\n\n```js\nconsole.log(isNaN()); // true\nconsole.log(isNaN(undefined)); // true\nconsole.log(isNaN({})); // true\nconsole.log(isNaN(String('a'))); // true\nconsole.log(isNaN(() =\u003e { })); // true\n```\n\n모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.\n\nES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.\n\n```js\nfunction checkIfNaN(value) {\n  return value !== value;\n}\n```\n\n\n\n# 11. 값이 배열인지 어떻게 판단할 수 있을까요?\n\nArray.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n```js\nconsole.log(Array.isArray(5));  // false\nconsole.log(Array.isArray(\"\")); // false\nconsole.log(Array.isArray()); // false\nconsole.log(Array.isArray(null)); // false\nconsole.log(Array.isArray({ length: 5 })); // false\n\nconsole.log(Array.isArray([])); // true\n```\n\n이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.\n\n\n\n```js\nfunction isArray(value){\n return Object.prototype.toString.call(value) === \"[object Array]\"\n}\n```\n\n물론 전통적인 방법도 사용할 수 있어요:\n\n```js\nlet a = []\nif (a instanceof Array) {\n  console.log('is an array')\n} else {\n  console.log('Non-Arrays')\n}\n```\n\n# 12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?\n\n\n\n객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.\n\n첫 번째 방법은 in 연산자를 사용하는 것이에요:\n\n```js\nconst o = { \n  \"prop\" : \"rabbit\",\n  \"prop2\" : \"tiger\"\n};\n\nconsole.log(\"prop\" in o); // true\nconsole.log(\"prop1\" in o); // false\n```\n\n두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.\n\n\n\n```js\r\nconsole.log(o.hasOwnProperty(\"prop2\")); // true\nconsole.log(o.hasOwnProperty(\"prop1\")); // false\r\n```\n\n세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.\n\n```js\r\nconsole.log(o[\"prop\"]); // \"rabbit\"\nconsole.log(o[\"prop1\"]); // undefined\r\n```\n\n더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.\n\n\n\n우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.","ogImage":{"url":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"},"coverImage":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png","tag":["Tech"],"readingTime":14},{"title":"노드js 클러스터 구현으로 성능 개선하기","description":"","date":"2024-05-14 16:05","slug":"2024-05-14-ImplementingNodejsClusterforImprovedPerformance","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png\" /\u003e\n\nNode.js는 확장 가능하고 효율적인 서버 측 애플리케이션을 만들기 위한 인기있는 런타임 환경입니다. 멀티 코어 시스템의 잠재력을 최대한 활용하고 Node.js 애플리케이션의 성능을 향상시키기 위해 내장된 클러스터 모듈을 사용하여 클러스터링을 구현할 수 있습니다. 클러스터링은 여러 워커 프로세스를 생성하여 들어오는 요청을 처리하므로 성능이 향상되고 시스템 자원을 더 효율적으로 활용할 수 있습니다.\n\n이 글에서는 Node.js에서 클러스터링의 개념을 탐구하고, 이점을 이해하며, 클러스터링 있는 경우와 없는 경우의 워크스루를 설명하고, 성능 평가를 위해 loadtest 패키지를 사용한 로드 테스트를 소개합니다.\n\n## 클러스터링 이해하기\n\n\n\nNode.js에서의 클러스터링은 여러 워커 프로세스를 만들어들어오는 작업 부하를 공유하는 것을 포함합니다. 각 워커 프로세스는 자체 이벤트 루프에서 실행되며 사용 가능한 CPU 코어를 활용합니다. 마스터 프로세스는 워커 프로세스를 관리하고 들어오는 요청을 분배하며 프로세스 실패를 처리합니다.\n\n## 클러스터링의 장점:\n\n- 성능 향상: 클러스터링을 통해 여러 코어에 걸쳐 요청을 병렬로 처리함으로써 응용 프로그램의 성능과 응답성이 향상됩니다. 이는 특히 여러 CPU 코어를 가진 기기에서 사용 가능한 시스템 자원을 더 잘 활용할 수 있게 합니다.\n- 확장성: 클러스터링은 동시에 발생하는 요청들을 병렬로 처리하여 Node.js 애플리케이션의 확장성을 향상시킵니다. 작업 부하가 증가하면 추가 워커 프로세스가 동적으로 생성되어 부하를 효과적으로 분산시킬 수 있습니다.\n- 내결함성: 워커 프로세스가 충돌하거나 응답이 없어지면 마스터 프로세스가 해당 실패를 감지하고 자동으로 워커 프로세스를 다시 시작할 수 있습니다. 이 내결함성은 프로세스 실패가 발생해도 응용 프로그램이 계속 사용 가능하도록 보장합니다.\n\n## 예시 구현- 클러스터링과 함께:\n\n\n\nNode.js Express 애플리케이션에서 클러스터링을 구현하는 예제를 살펴보겠습니다:\n\n```js\nconst cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);\n\n  for (let i = 0; i \u003c numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) =\u003e {\n    console.log(`워커 프로세스 ${worker.process.pid}가 종료되었습니다. 다시 시작 중...`);\n    cluster.fork();\n  });\n} else {\n  const app = express();\n\n  // Express 앱을 구성합니다\n  // ...\n\n  const server = app.listen(3000, () =\u003e {\n    console.log(`워커 프로세스 ${process.pid}가 3000 포트에서 수신 대기 중입니다`);\n  });\n}\n```\n\n이 예제에서는 마스터 프로세스가 사용 가능한 CPU 코어 수에 기반하여 워커 프로세스를 생성합니다. 각 워커 프로세스는 Express 앱의 인스턴스를 실행하여 병렬 요청 처리를 활성화합니다.\n\n## 클러스터링 없이 구현한 예시:\n\n\n\n비교를 위해 클러스터링 없이 구현한 예제를 보여드립니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\n// Express 앱 구성\n// ...\n\nconst server = app.listen(3000, () =\u003e {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n이 단순화된 예제에서는 클러스터링이 없고, 응용 프로그램은 단일 프로세스에서 실행됩니다.\n\n## 클러스터링과 부하 테스트 비교:\n\n\n\n클러스터링은 병렬 처리를 통해 성능을 향상시키지만, 로드 테스팅은 다양한 작업 부하 아래 응용 프로그램의 성능을 평가합니다. 우리는 로드테스트 패키지를 사용하여 부하를 시뮬레이션하고 성능을 평가하여 이러한 방법을 비교할 수 있습니다.\n\n## 로드 테스팅 구현:\n\n응용 프로그램을 로드 테스트하려면 다음 단계를 따르세요:\n\n단계 1: 프로젝트 디렉토리에서 다음 명령을 실행하여 loadtest 패키지를 설치합니다.\n\n\n\n```js\nnpm install -g loadtest\n```\n\n단계 2: 터미널에서 node app.js를 실행하여 Express 애플리케이션을 시작합니다.\n\n단계 3: 새로운 터미널 창을 열고 다음 명령을 실행하여 애플리케이션을 로드 테스트합니다:\n\n```js\nloadtest -c 10 --rps 100 -n 100 http://localhost:3000\n```\n\n\n\n이 예시에서는 특정 URL에 초당 100개의 요청률을 가진 10개의 동시 사용자를 모의하는 것입니다.\n\n## 관찰 사항\n\n클러스터링 없음: 100개의 요청 중 100개의 오류 발생\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_1.png)\n\n\n\n캐슁터링을 이용한: 0개의 오류/100개의 요청\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_2.png)\n\n응답 시간, 처리량, 그리고 오류와 같은 메트릭을 포함한 부하 테스트 결과를 살펴보세요. 이러한 메트릭은 지정된 부하 하에서 애플리케이션의 성능에 대한 통찰을 제공합니다.\n\n## 결론:\n\n\n\n이 글에서는 Node.js 애플리케이션에서 클러스터링의 이점을 탐색했습니다. 병렬 요청 처리를 통한 성능 향상, 확장성 및 오류 허용성을 통해 성능을 향상시킬 수 있다고 설명했습니다. 별도의 클러스터링을 사용한 예제와 그렇지 않은 예제를 제공하며, 여러 워커 프로세스를 활용하는 장점을 강조했습니다.\n\n게다가, loadtest 패키지를 사용하여 시뮬레이션된 워크로드에서 응용 프로그램의 성능을 평가하는 수단으로서 부하 테스트에 대해 논의했습니다. 부하 테스트는 응답 시간, 처리량 및 오류율을 평가하여 성능 최적화에 도움을 줍니다.\n\nNode.js 애플리케이션에서 클러스터링 및 부하 테스트를 활용함으로써 높은 성능, 확장성 및 고품질 트래픽 상황을 효과적으로 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png","tag":["Tech"],"readingTime":4},{"title":"JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기","description":"","date":"2024-05-14 16:04","slug":"2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps","content":"\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png)\n\n## 프론트엔드 개발\n\n# 텍스트를 음성으로 변환하기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_1.png)\n\n\n\n## 자바스크립트로 텍스트 음성 변환 앱 만드는 간단한 안내서\n\n안녕하세요! 코딩과 기술을 좋아하는 미디엄 친구 여러분!\n\n미디엄에서 텍스트 음성 변환 기능을 시도해 보신 적이 있나요? 정말 멋진 기능이죠, 그렇죠? 버튼을 누르기만 하면 글을 읽는 대신에 들을 수 있어요. 그렇게 하면 내용을 즐기면서 다른 일을 할 수도 있어요.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_2.png)\n\n\n\n이 기능 덕분에 새로운 기사 아이디어가 떠올랐어요. 그래서 이 기능이 어떻게 작동하는지 보여주고 여러분께 자신만의 기능을 만드는 방법을 가르쳐주기로 결심했어요.\n\n이 기사에서는 JavaScript와 Web Speech API만을 사용하여 어떻게 재미있는 텍스트 음성 변환 앱을 만들 수 있는지 단계별로 보여드릴 거에요. 끝나면 브라우저에서 어떤 텍스트든 음성으로 변환할 수 있게 되며 음성과 속도를 선택할 수도 있을 거예요.\n\n준비됐나요? 시작해볼까요?\n\n# JavaScript로 텍스트 음성 변환 애플리케이션 만들기\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_3.png\" /\u003e\n\n텍스트 음성 변환 (TTS) 시스템은 일반 언어 텍스트를 음성으로 변환합니다.\n\n이제 JavaScript를 사용하여 간단한 텍스트 음성 변환 애플리케이션을 만들어 보겠습니다. 구체적으로는 Web Speech API의 Speech Synthesis 인터페이스를 사용할 것입니다. 이 인터페이스는 거의 모든 최신 브라우저에서 지원되며 우리의 애플리케이션에 완벽합니다.\n\n시작하기 전에 JavaScript와 HTML의 기본적인 이해와 ES6 기능에 대한 친숙함이 있으면 더 좋을 것입니다.\n\n\n\n## 단계 1: HTML 구조 설정\n\n새 HTML 파일을 만들고 index.html로 저장하세요.\n\n먼저 텍스트를 입력하고 음성 기능을 실행할 수 있는 간단한 사용자 인터페이스를 설정해보겠습니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eJavaScript 텍스트 음성 변환\u003c/title\u003e\n    \u003cstyle\u003e\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            font-family: Arial, sans-serif;\n        }\n\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ctextarea id=\"text\" rows=\"5\" cols=\"30\"\u003e\u003c/textarea\u003e\n        \u003cbutton id=\"speak\"\u003e음성 변환\u003c/button\u003e\n    \u003c/div\u003e\n\n    \u003cscript src=\"app.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\n\nHTML 코드에서 사용자 입력을 받을 수 있는 텍스트 영역과 텍스트를 음성으로 변환하는 버튼을 추가했고, 다음 단계에서 생성할 'app.js'라는 JavaScript 파일을 링크했습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_4.png)\n\n## 단계 2: JavaScript 구현하기\n\n이제 기능을 추가해봅시다. HTML 파일과 동일한 디렉토리에 새 JavaScript 파일을 만들어 'app.js'로 이름짓어주세요.\n\n\n\n스피치 합성 API는 window.speechSynthesis 객체를 통해 노출됩니다. 다음은 기본 구현입니다:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\n\nspeakButton.addEventListener('click', () =\u003e {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n이 스크립트는 다음을 수행합니다:\n\n- DOM에서 textarea와 버튼 엘리먼트를 선택합니다.\n- 버튼에 클릭 이벤트 리스너를 추가합니다. 버튼을 클릭하면 이벤트 리스너가:\n- 텍스트 영역의 현재 값 가져옵니다.\n- 텍스트 영역의 값으로 새로운 SpeechSynthesisUtterance 객체를 생성합니다.\n- 이 SpeechSynthesisUtterance를 speechSynthesis.speak 메서드에 전달하여 음성 합성을 시작합니다.\n\n\n\n## 단계 3: 음성 및 발화 속도 사용자화\n\nSpeechSynthesisUtterance 객체를 통해 음성, 음조, 발화 속도 등의 속성을 변경할 수 있습니다. 그러나 이를 구현하는 방법을 살펴보겠습니다.\n\n먼저, 음성 선택 및 발화 속도 제어를 위한 새로운 요소를 추가하기 위해 HTML을 수정해주세요:\n\n```js\n\u003c!-- ...기존 HTML... --\u003e\n\u003cdiv class=\"container\"\u003e\n    \u003ctextarea id=\"text\" rows=\"5\" cols=\"30\"\u003e\u003c/textarea\u003e\n    \u003cselect id=\"voices\"\u003e\u003c/select\u003e\n    \u003cinput id=\"rate\" type=\"range\" min=\"0.5\" max=\"2\" value=\"1\" step=\"0.1\" /\u003e\n    \u003cbutton id=\"speak\"\u003e말하기\u003c/button\u003e\n\u003c/div\u003e\n\u003c!-- ...기존 HTML... --\u003e\n```\n\n\n\n그럼 app.js를 다음과 같이 업데이트하세요:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\nconst voicesSelect = document.getElementById('voices');\nconst rateInput = document.getElementById('rate');\n\nlet voices = [];\n\nfunction populateVoices() {\n    voices = speechSynthesis.getVoices();\n    voices.forEach((voice, i) =\u003e {\n        let option = document.createElement('option');\n        option.value = i;\n        option.textContent = `${voice.name} (${voice.lang})`;\n        voicesSelect.appendChild(option);\n    });\n}\n\nspeechSynthesis.addEventListener('voiceschanged', populateVoices);\n\nspeakButton.addEventListener('click', () =\u003e {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    // 선택한 음성 가져오기\n    let selectedVoiceIndex = voicesSelect.value;\n    utterance.voice = voices[selectedVoiceIndex];\n\n    // 속도 가져오기\n    utterance.rate = rateInput.value;\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n여기서는 모든 사용 가능한 음성으로 select 요소를 채우는 populateVoices 함수를 추가했으며, 'voiceschanged' 이벤트가 트리거될 때 이 함수를 호출합니다. 'voiceschanged' 이벤트는 speechSynthesis.getVoices() 메소드가 반환할 SpeechSynthesisVoice 객체 목록이 변경되었을 때 발생합니다.\n\n음성 합성을 트리거할 때 우리는 선택한 음성과 속도를 DOM에서 가져와서 SpeechSynthesisUtterance 객체에 설정합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_5.png)\n\n이제 위의 사진에 나와 있는 대로 작동하는 텍스트 음성 변환 애플리케이션이 준비되었어요: 텍스트 영역에 원하는 텍스트를 입력하고, 음성을 선택하고 말 속도를 조절한 다음 \"음성 출력\"을 클릭하면 말이 들릴 거예요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:732/1*EImZrlDQ1zrxaKe9FBPPmA.gif)\n\n## 더 알아보기:\n\n\n\n# 마무리\n\n![text-to-speech-app](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_6.png)\n\n그러면 JavaScript와 Web Speech API를 사용하여 몇 분 안에 만든 간단하고 재미있는 텍스트 음성 변환 앱이 준비됐어요!\n\n이것은 사용자들이 콘텐츠를 독특하고 접근성 있게 소비하는 것과 같이 Medium이 하는 대로 당신의 웹 애플리케이션의 사용자 경험을 향상시키는 멋진 방법이 될 수 있어요.\n\n\n\n만약 JavaScript와 웹 개발의 다른 측면을 더 탐구하고 싶다면, 내 다른 기사들을 꼭 확인해보시길 권해드립니다.\n\n텍스트 음성 변환에 대해 이야기할 때, 이제 텍스트 강조 기능을 구현해보는 것이 좋겠네요. \"AWS Polly를 활용한 클라우드 기반 텍스트 음성 변환 및 텍스트 강조 생성 애플리케이션 구축\"에 해당하는 제 기사를 참고해보세요. 이 기사는 클라우드 기술을 통해 진보된, 확장 가능하고 이용하기 쉬운 텍스트 음성 변환 솔루션을 만드는 방법을 안내합니다. 그리고 AWS Polly는 친근하고 쉬운 도구입니다.\n\n반면에 UI 게임을 업그레이드하고 싶다면, “UI 디자인 마스터하기: 최고의 실천 지침 완전 가이드\"를 놓치지 마세요. 이 포괄적인 안내서는 UI 디자인의 힘을 발휘하며, 웹 및 모바일 플랫폼을 위한 직관적이고 사용자 친화적, 매력적인 인터페이스를 만드는 통찰을 제공합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_7.png\" /\u003e\n\n\n\n# 리고처럼 재사용 가능한 구성 요소로 애플리케이션 만들기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_8.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소로 애플리케이션을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 구성 요소로 변환하고 애플리케이션 간에 공유하세요. 협업이 더 쉬워지고 더 빠르게 개발할 수 있습니다.\n\n\n\n→ 더 많은 정보 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 워크플로에 대해 최상의 경험을 누려보세요:\n\n# → 미크로 프론트엔드\n\n# → 디자인 시스템\n\n\n\n# → 코드 공유 및 재사용\n\n# → 단일 저장소\n\n# Learn more:","ogImage":{"url":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png","tag":["Tech"],"readingTime":7},{"title":"Jupyter 노트북에 현대적 JavaScript 가져오기","description":"","date":"2024-05-14 16:02","slug":"2024-05-14-BringingModernJavaScripttotheJupyterNotebook","content":"\n\n## Deno 커널은 주피터를 위한 가장 최신 런타임이에요\n\n정말 예상치 못한 소식이죠.\n\nDeno는 TypeScript, JavaScript, npm 및 ES 모듈을 갖추고 있어 주피터에 쉽게 설치할 수 있는 커널을 제공해요.\n\n지금 Deno를 시작하는 더 좋은 때는 없어요. Deno를 설치한 후, deno 주피터 커널 설치를 실행하세요:  \n\n\n\n```js\ndeno jupyter --unstable --install\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*_KUkFmq1lO3H-tx4XJPNew.gif)\n\nDeno는 fetch와 같은 웹 표준을 기본적으로 지원하므로 데이터 로딩이 간단하고 쉽습니다.\n\n![image](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png)\n\n\n\n\n이것은 빠르고 안전한 런타임일뿐만 아니라 즐거운 시간을 보낼 수 있습니다. 타이밍도 훌륭합니다 — 데이터프레임은 줄리아, 파이썬, R 및 러스트만의 전유물이 아닙니다. Polars는 JavaScript용 데이터프레임을 제공합니다.\n\n![이미지1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_1.png)\n\n놀라운 점은 얼마나 쉽게 D3를 데이터프레임과 함께 사용할 수 있는지입니다.\n\n![이미지2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_2.png)\n\n\n\n우리는 캔버스에 직접 플롯을 그릴 수 있어요.\n\n![plot1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_3.png)\n\n또한 SVG를 출력하는 어떤 라이브러리도 사용할 수 있지요.\n\n![plot2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_4.png)\n\n\n\n이것은 다양한 JavaScript 개발자와 데이터 전문가들이 노트북에서 문서 작성을 할 수 있도록 함을 의미합니다.\n\nJavaScript/TypeScript로 데이터를 탐색하고 시각화하려면 Deno를 확인하고 Jupyter 시작 가이드 문서를 살펴보세요.\n\nRust를 알고 있다면 Deno에서 해킹해보세요. Rust를 몰라도, 나와 같은 경우라도 Deno에서 해킹해보세요. 배울 수 있습니다. Deno 팀은 TypeScript, Jupyter 및 표준의 힘을 깊이 믿는 친절한 사람들로 구성되어 있습니다.\n\n또한 버그를 보고하고, 노트북을 작성하고, Deno 커널을 다른 사람들과 공유함으로써 기여할 수도 있습니다.\n\n\n\n\n![Bringing Modern JavaScript to the Jupyter Notebook](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_5.png)\n\n해피 노트북!\n","ogImage":{"url":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png"},"coverImage":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png","tag":["Tech"],"readingTime":2},{"title":"디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내","description":"","date":"2024-05-14 15:59","slug":"2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode","content":"\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png)\n\n## 소프트웨어 개발 원칙\n\n# 소개 — JavaScript 디자인 패턴\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png)\n\n\n\n## 디자인 패턴의 본질\n\n안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.\n\n## 디자인 패턴 — 무엇인가요?\n\n디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.\n\n\n\n## 자바스크립트 디자인 패턴의 힘\n\n자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.\n\n다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.\n\n# 자바스크립트 디자인 패턴 유형 탐색\n\n\n\n![image](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png)\n\n## 생성 디자인 패턴: 객체 생성\n\nJavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.\n\n생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.\n\n\n\n공장 패턴\n\n공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.\n\n```js\nfunction CarFactory() {\n  this.createCar = function(model) {\n    let car;\n    if (model === '세단') {\n      car = new Sedan();\n    } else if (model === 'SUV') {\n      car = new SUV();\n    }\n    return car;\n  };\n}\n```\n\n싱글톤 패턴\n\n\n\n싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.\n\n```js\nlet Singleton = (function () {\n  let instance;\n \n  function createInstance() {\n    return new Object(\"I am the instance\");\n  }\n \n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n```\n\n빌더 패턴\n\n빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.\n\n\n\n```js\nfunction CarBuilder() {\n  this.car = null;\n\n  this.step1 = function () {\n    this.car = new Car();\n  };\n\n  this.step2 = function () {\n    this.car.addParts();\n  };\n\n  this.get = function () {\n    return this.car;\n  };\n}\n```\n\n## 구조적 디자인 패턴: 코드 모양을 만드는 방법\n\n구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.\n\n어댑터 패턴```\n\n\n\n어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.\n\n```js\nclass OldCalculator {\n  constructor() {\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return term1 + term2;\n        case 'sub':\n          return term1 - term2;\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\nclass NewCalculator {\n  constructor() {\n    this.add = function(term1, term2) {\n      return term1 + term2;\n    };\n    this.sub = function(term1, term2) {\n      return term1 - term2;\n    };\n  }\n}\n\nclass CalculatorAdapter {\n  constructor() {\n    const newCalc = new NewCalculator();\n    \n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return newCalc.add(term1, term2);\n        case 'sub':\n          return newCalc.sub(term1, term2);\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n```\n\n데코레이터 패턴\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.\n\n\n\n```js\nfunction Car(name) {\n  this.name = name;\n}\n\nCar.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedCar(car, color, price) {\n  this.car = car;\n  this.color = color;\n  this.price = price;\n}\n\nDecoratedCar.prototype.getName = function () {\n  return this.car.getName() + ' has color ' + this.color + ' and price ' + this.price;\n};\n```\n\n프록시 패턴\n\n프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.\n\n```js\nfunction NetworkAccess() {\n  this.connect = function () {\n    console.log('네트워크에 연결되었습니다.');\n  };\n}\n\nfunction NetworkProxy() {\n  this.network = new NetworkAccess();\n  this.connect = function () {\n    console.log('네트워크 프록시를 사용합니다.');\n    this.network.connect();\n  };\n}\n```\n\n\n\n## 행동 디자인 패턴: 객체 협업 관리\n\n행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.\n\n옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.\n\n\n\n```js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index \u003e -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notifyAll(data) {\n        for (let i = 0; i \u003c this.observers.length; i++) {\n            this.observers[i].notify(data);\n        }\n    }\n}\n\nclass Observer {\n    notify(data) {\n        console.log(`Observer received: ${data}`);\n    }\n}\n```\n\n전략 패턴\n\n전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.\n\n```js\nclass Shipping {\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    calculate(parcel) {\n        return this.strategy.calculate(parcel);\n    }\n}\n\nclass UPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.75}`;\n    }\n}\n\nclass FedEx {\n    calculate(parcel) {\n        return `$${parcel.weight * 2.45}`;\n    }\n}\n\nclass USPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.25}`;\n    }\n}\n```\n\n\n\n## 커맨드 패턴\n\n커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.\n\n```js\nclass Switch {\n  execute(command) {\n    command.execute();\n  }\n}\n\nclass TurnOnCommand {\n  constructor(light) {\n    this.light = light;\n  }\n\n  execute() {\n    this.light.turnOn();\n  }\n}\n\nclass Light {\n  turnOn() {\n    console.log('불이 켜졌습니다');\n  }\n\n  turnOff() {\n    console.log('불이 꺼졌습니다');\n  }\n}\n```\n\n다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.\n\n\n\n# JavaScript 디자인 패턴의 실제 응용\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png)\n\n디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.\n\n## 사용자 프로필 생성\n\n\n\n사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.\n\n```js\nfunction UserFactory() {\n  this.createUser = function(type) {\n    let user;\n\n    if (type === '개인') {\n      user = new PersonalUser();\n    } else if (type === '비즈니스') {\n      user = new BusinessUser();\n    }\n\n    user.type = type;\n    user.say = function() {\n      console.log(this.type + \": 프로필이 생성되었습니다\");\n    }\n    return user;\n  }\n}\n```\n\n## 제3자 API와의 통합\n\n다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.\n\n\n\n```md\n```js\nclass ThirdPartyAPI {\n  constructor() {\n    this.specificRequest = function() {\n      return \"Third-party API response\";\n    };\n  }\n}\n\nclass Adapter {\n  constructor(thirdPartyAPI) {\n    this.request = function() {\n      return thirdPartyAPI.specificRequest();\n    };\n  }\n}\n\n// Using the Adapter\nconst thirdPartyAPI = new ThirdPartyAPI();\nconst adapter = new Adapter(thirdPartyAPI);\nadapter.request();\n```\n\n## 사용자 프로필에 기능 추가하기\n\nDecorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedUser(user, badge, theme) {\n  this.user = user;\n  this.badge = badge;\n  this.theme = theme;\n}\n\nDecoratedUser.prototype.getName = function () {\n  return `${this.user.getName()}, Badge: ${this.badge}, Theme: ${this.theme}`;\n};\n```\n\n\n\n## 게시물과 사용자 상호작용\n\n옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.\n\n```js\nclass Post {\n  constructor() {\n    this.observers = [];\n  }\n\n  like(user) {\n    this.notifyAll(`게시물이 ${user}님에 의해 좋아요!`);\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll(message) {\n    for (let observer of this.observers) {\n      observer.notify(message);\n    }\n  }\n}\n\nclass User {\n  notify(message) {\n    console.log(`사용자에게 알림: ${message}`);\n  }\n}\n```\n\n## 다양한 배송 방법\n\n\n\n이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.\n\n```js\nclass Shipping {\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(parcel) {\n    return this.strategy.calculate(parcel);\n  }\n}\n\nclass UPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.75}`;\n  }\n}\n\nclass FedEx {\n  calculate(parcel) {\n    return `$${parcel.weight * 2.45}`;\n  }\n}\n\nclass USPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.25}`;\n  }\n}\n```\n\n## 웹사이트 테마 사용자 정의\n\n사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.\n\n\n\n```js\n// 팩토리 패턴\nfunction ThemeFactory() {\n  this.createTheme = function(type) {\n    let theme;\n\n    if (type === 'Dark') {\n      theme = new DarkTheme();\n    } else if (type === 'Light') {\n      theme = new LightTheme();\n    }\n\n    theme.type = type;\n    return theme;\n  }\n}\n\n// 데코레이터 패턴\nfunction DecoratedTheme(theme, color) {\n  this.theme = theme;\n  this.color = color;\n}\n\nDecoratedTheme.prototype.getName = function () {\n  return this.theme.getName() + ' in ' + this.color + ' color';\n};\n```\n\n## 할인 이벤트가 적용된 전자 상거래 사이트\n\n전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.\n\n```js\n// 전략 패턴\nclass SpecialOffer {\n  apply(product) {\n    // abstract method\n  }\n}\n\nclass BlackFridayOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.8;  // 20% 할인\n  }\n}\n\nclass ChristmasOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.85;  // 15% 할인\n  }\n}\n\n// 옵서버 패턴\nclass Product {\n  constructor(price) {\n    this.price = price;\n    this.observers = [];\n  }\n\n  setPrice(price) {\n    this.price = price;\n    this.notifyAll();\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll() {\n    for (let observer of this.observers) {\n      observer.notify(this);\n    }\n  }\n}\n\nclass Customer {\n  notify(product) {\n    console.log(`제품 가격이 $${product.price}로 업데이트되었습니다.`);\n  }\n}\n```\n\n\n\n## 성능 모니터링 시스템\n\n알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.\n\n```js\n// Factory Pattern\nfunction ModuleFactory() {\n  this.createModule = function(type) {\n    let module;\n\n    if (type === 'Database') {\n      module = new DatabaseModule();\n    } else if (type === 'Network') {\n      module = new NetworkModule();\n    }\n\n    module.type = type;\n    return module;\n  }\n}\n\n// Proxy Pattern\nclass PerformanceProxy {\n  constructor(module) {\n    this.module = module;\n  }\n\n  monitor() {\n    console.log('성능 모니터링 중...');\n    // 호출을 원래 객체로 위임합니다.\n    this.module.monitor();\n  }\n}\n```\n\n## 채팅 애플리케이션\n\n\n\n매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.\n\n```js\n// 싱글톤 패턴\nlet ChatRoom = (function() {\n  let instance;\n\n  function createInstance() {\n    let object = new Object(\"ChatRoom\");\n    return object;\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// 옵서버 패턴\nclass User {\n  notify(message) {\n    console.log(`Received message: ${message}`);\n  }\n}\n```\n\n## 온라인 게임 시스템\n\n온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.\n\n\n\n```js\n// Factory Pattern\nfunction CharacterFactory() {\n  this.createCharacter = function(type) {\n    let character;\n\n    if (type === 'Warrior') {\n      character = new Warrior();\n    } else if (type === 'Mage') {\n      character = new Mage();\n    }\n\n    character.type = type;\n    return character;\n  }\n}\n\n// Observer Pattern\nclass Character {\n  hit() {\n    // Notify all observers\n  }\n}\n\n// Decorator Pattern\nfunction EnhancedCharacter(character, ability) {\n  this.character = character;\n  this.ability = ability;\n}\n\nEnhancedCharacter.prototype.useAbility = function() {\n  console.log(`Using ability: ${this.ability}`);\n}\n```\n\nThese examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.\n\n# Design Patterns를 사용할 때 피해야 할 함정\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png)\n\n\n\n\n디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.\n\n다음은 피해야 할 몇 가지 일반적인 함정입니다:\n\n## 디자인 패턴 과용\n\n디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.\n\n\n\n## 디자인 패턴 오용\n\n각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.\n\n## 패턴을 완전히 이해하지 못한 경우\n\n디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.\n\n\n\n## 간단함의 원칙을 무시하다\n\nKISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.\n\n# 요약 및 권장 사항\n\n![](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png)\n\n\n\n본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.\n\n## 추가 학습\n\n지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.\n\n자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: \"JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice\" 그리고 \"JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구\"\n\n\n\n두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.\n\n항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png)\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\n\n\n\n우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png","tag":["Tech"],"readingTime":15},{"title":"아스트로 JS 프로젝트용 Neovim 설정","description":"","date":"2024-05-14 15:58","slug":"2024-05-14-NeovimSetupforAstroJsProjects","content":"\n\n![AstroJS](/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png)\n\n최근 JavaScript 커뮤니티에서 AstroJS가 많은 사랑을 받고 있어요. Astro를 들어보지 못했다면, 콘텐츠 중심 웹 프레임워크입니다. '아일랜드'와 같은 개념을 사용하여 모든 비필수적인 자바스크립트를 제거하여 사이트 속도를 높일 수 있어요.\n\n저는 이것을 시도해보고 있으며, 편집기로 Neovim을 사용하고 있어요. 모든 것을 설정하는 방법이 100% 명확하지 않아서 이 기사에서 제가 한 설정 방법을 공유하려고 해요. AstroJS 프로젝트에서 Neovim을 잘 작동하도록 설정하는 방법은 다음과 같아요.\n\n## LSP 구성\n\n\n\n이 부분이 조금 헷갈렸네요.\n\n- 먼저 Mason을 통해 astro-language-server를 설치해야 합니다:\n\n![astro-language-server 설치](/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_1.png)\n\n2. mason_lspconfig.setup에서 astro가 ensure_installed 객체에 있는지 확인하세요:\n\n\n\n```js\n mason_lspconfig.setup({\n   -- mason 설치할 서버 목록\n   ensure_installed = {\n    \"astro\",\n    \"tsserver\",\n    \"html\",\n    \"cssls\",\n    \"tailwindcss\",\n   },\n   -- lspconfig로 자동 설치 (ensure_installed랑 다름)\n   automatic_installation = true,\n  })\n```\n\n3. lspconfig를 설정하는 곳에 다음 코드를 넣으세요:\n\n```js\n  -- astro --\n  lspconfig[\"astro\"].setup({\n   capabilities = capabilities,\n   on_attach = on_attach,\n   filetypes = { \"astro\" },\n  })\n```\n\n저는 이 부분이 헷갈렸어요. astro-language-server를 설치했는데 lspconfig에서는 astro만 사용한다고 하더라구요. 나중에 돌아봤을 때 Mason에서 LSP 이름 뒤에 astro를 제공하는 걸 볼 수 있었지만, 처음에는 이게 명확하지 않았어요.```\n\n\n\n이것이 .astro 파일에 대한 LSP를 활성화해야 합니다.\n\n## 구문 강조\n\n그를 위해 저는 내 treesitter 구성에서 ensure_installed object에 astro를 추가했어요.\n\n```js\n require(\"nvim-treesitter.configs\").setup({\n    ensure_installed = {\n     \"astro\",\n    },\n })\n```\n\n\n\n## 형식 지정\n\n이를 위해 나는 prettier와 prettier-plugin-astro라는 플러그인의 조합을 사용하고 있습니다. 우선 none-ls.lua 파일에 있는 파일 목록에 astro 파일 유형을 prettier로 서식을 지정할 파일 목록에 추가했습니다 (저는 Mason을 통해 포매터로 prettier를 설치했습니다).\n\n```js\n formatting.prettier.with({\n     extra_filetypes = { \"svelte\", \"typescriptreact\", \"astro\" },\n    }), \n```\n\n그런 다음 로컬 astro 프로젝트에서 이 prettier-plugin-astro를 로컬 개발 종속성으로 설치했습니다.\n\n\n\n```js\npnpm add -D prettier-plugin-astro\n```\n\n그리고 Neovim을 다시 시작한 후 .astro 파일을 저장하면 저장될 때 자동으로 서식이 지정됩니다.\n\n# 결론\n\n이 모든 것을 설정하는 방법이 100% 명확하지는 않았고, 꽤 오랜 시간이 걸렸습니다. 여러 가지를 찾아보고 시행착오를 격은 결과였죠. 이 기사가 Neovim에서 AstroJs 프로젝트를 작업하기를 희망하는 사람들이 자신의 설정을 Neovim에서 잘 작동하도록 도와줄 수 있기를 바랍니다.```\n\n\n\n# 구독하기\n\n만약 이 블로그 글을 좋아한다면, 매번 새로운 글이 올라올 때마다 알림을 받을 수 있습니다. 저는 매주 월요일 아침 8:30에 중앙 유럽 시간에 글을 올립니다.\n\n# 나에 대해\n\n저는 주로 React와 Typescript를 사용하는 프론트엔드 개발자입니다. 새로운 도구와 라이브러리를 탐구하는 것을 좋아하며, JavaScript 생태계를 사랑합니다.\n\n\n\n저는 발견한 새로운 흥미로운 도구, 사용 설명서 논문 및 가끔 의견 조각을 나누는 블로그 글을 쓰는 것을 좋아해요.\n\n저는 체코 공화국 프라하에 제 가족과 함께 살고 있어요.\n\n제 블로그에서 원본 블로그 글을 확인해보세요.\n\n관심이 있다면 제 LinkedIn과 Github도 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png"},"coverImage":"/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요","description":"","date":"2024-05-14 15:56","slug":"2024-05-14-IHateJavaScriptThankYouBlazor","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png\" /\u003e\n\n여러 해 동안 JavaScript는 웹 개발의 주인공으로 선전을 하면서 클라이언트 측 프로그래밍을 지배했습니다. 다양한 브라우저에서의 보급성과 웹 페이지 상호 작용에서 중요한 역할을 하는 기능으로 인해 사람들은 JavaScript를 떠날 수 없었습니다. 그러나 저와 JavaScript의 관계는 지금까지 괴로움으로 가득 찼습니다. 동적 타입의 특성부터 다양한 브라우저 간의 예측할 수 없는 동작까지, JavaScript와 함께한 여행은 디버깅과 해결책 찾기의 롤러코스터였습니다. 그런데 그 모든 것이 Blazor를 만나면서 달라졌습니다.\n\n# JavaScript의 문제점\n\n저와 같은 많은 개발자들이 겪은 것처럼 JavaScript에 대한 불평은 그 언어의 독특한 점과 일관성 부족에서 비롯됩니다. 여기에는 JavaScript의 특정 문제점을 자세히 살펴보며 이 언어의 풍경에 익숙한 많은 사람들에게 공감할 수 있는 예제가 포함되어 있습니다.\n\n\n\n\n## 동적 타이핑의 문제점\n\n자바스크립트의 동적 타이핑은 종종 그 유연성으로 인해 칭찬받지만, 변수가 언제든지 어떤 유형의 값을 보유할 수 있다는 것을 의미합니다. 그러나, 이 기능은 예상치 못한 동작과 디버깅하기 어려운 런타임 에러를 초래할 수 있습니다. 다음 예시를 살펴보세요:\n\n```js\nlet value = \"5\";\nconsole.log(value + 5); // 결과: \"55\"\n```\n\n이 스니펫에서, 자바스크립트는 두 숫자를 더하는 대신, 문자열과 숫자를 연결하여 \"55\"를 출력합니다. 이러한 타입 강제 변환이 컴파일 시점에 변수의 유형이 알려진 정적으로 타입화된 언어에서 왔던 사람들에게는 예상치 못할 수도 있습니다.\n\n\n\n## 변수 스코핑과 `this` 키워드\n\n자바스크립트의 변수 스코프 처리와 `this` 키워드는 혼란스러울 수 있습니다. var을 사용할 때 특히 변수의 스코프는 예측할 수 없는 동작으로 이어질 수 있습니다:\n\n```js\nfor (var i = 0; i \u003c 5; i++) {\n  setTimeout(function() { console.log(i); }, 1000);\n}\n// 출력: 5, 5, 5, 5, 5\n```\n\nvar의 함수 스코프 성질 때문에 루프가 어떤 것을 예상하는 대로 동작하지 않는데, setTimeout 함수가 실행될 때 i의 값이 이미 5에 도달했기 때문에 0부터 4가 아닌 5를 다섯 번 출력합니다.\n\n\n\n안녕하세요! \n\n위의 표는 마크다운 형식으로 변경할 수 있습니다. \n\n이 키워드는 상황에 따라 다르게 동작하기 때문에 혼란스러울 수 있습니다:\n\n```js\nconst object = {\n  property: \"Value\",\n  method: function() {\n    console.log(this.property);\n  }\n};\n\nobject.method(); // 출력: \"Value\"\nconst detachedMethod = object.method;\ndetachedMethod(); // 출력: undefined\n```\n\n두 번째 호출에서는 this가 더 이상 객체를 가리키지 않기 때문에 결과가 정의되지 않았습니다.\n\n## 콜백 지옥\n\n\n\n자바스크립트의 비동기 특성은 종종 \"콜백 지옥\"으로 이어질 수 있습니다. 이는 콜백이 중첩되어 코드를 읽고 유지하기 어렵게 만듭니다:\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getEvenMoreData(b, function(c){\n            console.log('Got data:', c);\n        });\n    });\n});\n```\n\n특히 복잡한 애플리케이션에서 이러한 중첩은 빠르게 관리하기 어려워질 수 있습니다.\n\n# 블레이저가 등장합니다\n\n\n\nBlazor의 강력한 프레임워크로서의 부상은 웹 개발 방법을 본질적으로 변화시켰습니다. 혁신적인 기능과 .NET 생태계와의 원활한 통합으로, JavaScript로 가지고 있던 불평을 해결할 뿐만 아니라 개발 워크플로우를 혁신적으로 바꿀 수 있었습니다. 여기에서는 Blazor가 웹 개발 환경을 변화시킨 내용에 대해 더 자세한 예제와 통찰을 공유하겠습니다. 특히 구성 요소 중심 아키텍처, 코드 공유의 원활함, 그리고 C#의 장점을 강조할 것입니다.\n\n## 예제로 살펴보는 구성 요소 중심 아키텍처\n\nBlazor의 가장 매력적인 특징 중 하나는 구성 요소 중심 아키텍처입니다. 이 접근 방식을 통해 개발자는 각 구성 요소가 자체 기능과 디자인을 관리하는 모듈식 방식으로 웹 UI를 구축할 수 있습니다. Blazor 구성 요소의 예제를 살펴보겠습니다:\n\n```js\n@page \"/counter\"\n\n\u003ch1\u003eCounter\u003c/h1\u003e\n\n\u003cp\u003eCurrent count: @count\u003c/p\u003e\n\n\u003cbutton class=\"btn btn-primary\" @onclick=\"IncrementCount\"\u003eClick me\u003c/button\u003e\n\n@code {\n    private int count = 0;\n\n    private void IncrementCount()\n    {\n        count++;\n    }\n}\n```\n\n\n\n이 간단한 Counter 구성 요소는 Blazor의 접근 방식을 보여줍니다. 렌더링을 위한 HTML과 동작을 위한 C# 코드가 한 파일에 캡슐화되어 있습니다. 버튼을 클릭하면 IncrementCount 메서드가 count 변수를 업데이트하고 UI가 이 변경을 자동으로 반영합니다. 이 캡슐화와 마크업과 로직의 통합이 Blazor 컴포넌트를 재사용 가능하고 쉽게 관리할 수 있게 만듭니다.\n\n## 서버와 클라이언트 간의 코드 공유의 원활함\n\nBlazor의 서버 및 클라이언트 간 코드를 원활하게 공유할 수 있는 능력은 특히 둘 다에 공유되어야 하는 많은 로직이 필요한 프로젝트에게 혁명을 일으켰습니다. 이 능력은 중복을 줄이고 비즈니스 로직의 유지 보수를 간단하게 만듭니다. 다음은 클라이언트 (Blazor WebAssembly 앱 내) 및 서버 양쪽에서 사용되는 모델을 정의하는 방법의 예시입니다:\n\n```js\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n}\n```\n\n\n\n이 Product 클래스는 공유 라이브러리에 정의될 수 있으며 API 응답을 위한 서버와 렌더링 및 조작을 위한 클라이언트 모두에서 사용할 수 있습니다. 이는 클라이언트 및 서버 코드가 동기화되어 있음을 보장할 뿐만 아니라 C#의 강력한 타이핑을 활용하여 버그를 줄이는 데 도움이 됩니다.\n\n## C# 및 컴파일 시간 오류 검사의 장점\n\nUI 로직을 정적으로 타입된 언어인 C#로 작성으로 전환함으로써 런타임 오류를 줄이고 컴파일 시간 오류 검사를 통해 코드 품질을 향상시켰습니다. 다음은 비교적인 예시를 통해 설명합니다:\n\nJavaScript에서 변수 이름에 오타가 있을 경우 런타임에서만 오류가 발견될 수 있다:\n\n\n\n```js\nlet userName = \"Mabrouk\"; // 오타가 있는 변수 이름\nconsole.log(userName); // ReferenceError: userName is not defined\n```\n\n한편, Blazor에서 비슷한 실수는 컴파일 시간에 잡힐 것입니다:\n\n```js\nstring userName = \"Mabrouk\"; // 오타가 있는 변수 이름\nConsole.WriteLine(userName); // Compile-time error: The name 'userName' does not exist in the current context\n```\n\n이 즉각적인 피드백 루프는 디버깅 시간을 크게 줄이고 전체적인 생산성을 향상시킵니다.\n\n\n\n# Blazor의 영향\n\nBlazor는 내 생산성뿐만 아니라 웹 개발에 대한 태도도 개선시켰어요. JavaScript의 특이한 점에 대한 답답함은 신뢰할 수 있는 언어와 생태계에서 개발하는 만족을 주도록 바뀌었어요. Blazor가 기존 .NET 라이브러리와 도구와 통합되어 있어 새로운 프레임워크나 라이브러리를 계속 배우는 필요 없이 넓은 생태계를 활용할 수 있습니다.\n\nBlazor Server의 서버 측 렌더링 기능과 Blazor WebAssembly의 클라이언트 측 기능은 응용 프로그램을 배포하고 실행하는 방법에 유연성을 제공하여 다양한 프로젝트 요구 사항에 맞춰줍니다. 이러한 다재다능함은 .NET 플랫폼에서 실행하는 성능 및 보안 이점과 결합되어 Blazor를 새로운 프로젝트나 기존 프로젝트에 모두 유용한 선택지로 만들어줍니다.\n\n# 요약\n\n\n\n자바스크립트는 여전히 웹 개발의 중심이 되어 있지만, 제 개인적인 여정은 웹 애플리케이션을 구축하기 위한 주요 프레임워크로 Blazor를 포용하게 되었습니다. 생산성 증가, C#로 코딩하는 즐거움, 그리고 Blazor로 개발된 애플리케이션의 견고함이 바로 제가 \"자바스크립트를 싫어하지만 Blazor에게 고마워\"라고 말하는 이유입니다.\n\n자바스크립트에 대해 같은 답답함을 느끼는 분들에게는 Blazor를 탐험해 보라고 권유합니다. 당신에게도 저와 같이 웹 개발에 대한 시각을 바꿔줄 수 있을지도 모릅니다. 기술 선택이 프로젝트의 성패를 좌우할 수 있는 세상에서, Blazor는 .NET의 견고함을 현대적 웹 애플리케이션의 역동성과 결합하여 매력적인 대안을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png"},"coverImage":"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png","tag":["Tech"],"readingTime":5}],"page":"46","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"46"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>