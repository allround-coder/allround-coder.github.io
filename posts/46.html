<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/46" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/46" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="웹 개발을 위한 상위 10개 Nodejs 프레임워크" href="/post/2024-06-20-Top10NodejsFrameworksForWebDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 개발을 위한 상위 10개 Nodejs 프레임워크" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Top10NodejsFrameworksForWebDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 개발을 위한 상위 10개 Nodejs 프레임워크" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 개발을 위한 상위 10개 Nodejs 프레임워크</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NodeJS 유닛 테스팅 튜토리얼 포괄적 가이드" href="/post/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NodeJS 유닛 테스팅 튜토리얼 포괄적 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NodeJS 유닛 테스팅 튜토리얼 포괄적 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NodeJS 유닛 테스팅 튜토리얼 포괄적 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs는 빠르다고 하면 어떻게 생각하시나요" href="/post/2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs는 빠르다고 하면 어떻게 생각하시나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs는 빠르다고 하면 어떻게 생각하시나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs는 빠르다고 하면 어떻게 생각하시나요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextJS에서 Node Cron을 사용해 예약 작업 실행하기" href="/post/2024-06-20-RunningaScheduledjobinNextJSwithNodeCron"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextJS에서 Node Cron을 사용해 예약 작업 실행하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-RunningaScheduledjobinNextJSwithNodeCron_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextJS에서 Node Cron을 사용해 예약 작업 실행하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextJS에서 Node Cron을 사용해 예약 작업 실행하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ES 모듈 범위에서 __dirname이 정의되지 않았습니다 오류를 해결하는 방법" href="/post/2024-06-20-Howtofix__dirnameisnotdefinedinESmodulescope"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ES 모듈 범위에서 __dirname이 정의되지 않았습니다 오류를 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Howtofix__dirnameisnotdefinedinESmodulescope_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ES 모듈 범위에서 __dirname이 정의되지 않았습니다 오류를 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ES 모듈 범위에서 __dirname이 정의되지 않았습니다 오류를 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS Lambda에서 런타임 변경 처리하기 단순한 작업 이상" href="/post/2024-06-20-NavigatingRuntimeChangesinAWSLambdaMoreThanJustaSimpleTask"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS Lambda에서 런타임 변경 처리하기 단순한 작업 이상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-NavigatingRuntimeChangesinAWSLambdaMoreThanJustaSimpleTask_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS Lambda에서 런타임 변경 처리하기 단순한 작업 이상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">AWS Lambda에서 런타임 변경 처리하기 단순한 작업 이상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 Type과 Interface 중 어떤 것을 선택해야 할까요 상세 안내" href="/post/2024-06-20-ChoosingBetweenTypeandInterfaceinTypeScriptADetailedGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 Type과 Interface 중 어떤 것을 선택해야 할까요 상세 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ChoosingBetweenTypeandInterfaceinTypeScriptADetailedGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 Type과 Interface 중 어떤 것을 선택해야 할까요 상세 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 Type과 Interface 중 어떤 것을 선택해야 할까요 상세 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" href="/post/2024-06-20-ReactCompilerisalmosthereanditisExciting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴파일러가 거의 다 왔어요 정말 기대돼요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴파일러가 거의 다 왔어요 정말 기대돼요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" href="/post/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마이크로 프론트엔드의 미래" href="/post/2024-06-20-TheFutureofMicroFrontends"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마이크로 프론트엔드의 미래" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마이크로 프론트엔드의 미래" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">마이크로 프론트엔드의 미래</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link posts_-active__YVJEi" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"웹 개발을 위한 상위 10개 Nodejs 프레임워크","description":"","date":"2024-06-20 01:40","slug":"2024-06-20-Top10NodejsFrameworksForWebDevelopment","content":"\n\n## 웹 개발을 위한 최고의 Node.js 프레임워크에 대한 포괄적인 가이드\n\n![이미지](/assets/img/2024-06-20-Top10NodejsFrameworksForWebDevelopment_0.png)\n\n노드.js는 논블로킹 및 이벤트 기반 아키텍처로 인해 웹 개발에서 인기 있는 선택지가 되었습니다.\n\n이를 통해 빠르고 확장 가능하며 실시간 응용 프로그램을 구축할 수 있습니다. 개발을 쉽게하고 기능을 향상시키기 위해 Node.js 기반으로 여러 프레임워크가 구축되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프레임워크들은 웹 및 API 개발을 더 쉽고 효율적으로 만드는 데 필수적입니다.\n\nNode.js가 2009년에 등장하기 전에는 웹 개발자들이 주로 클라이언트 측 스크립팅에 JavaScript를 사용하는 제약을 겪었습니다. 그 전에도 몇 가지 서버 측 JavaScript 프레임워크가 있었지만 널리 사용되지는 않았습니다. Node.js는 JavaScript를 클라이언트 쪽 및 서버 쪽 개발 모두에 사용할 수 있게 함으로써 같은 언어를 전체 애플리케이션에서 사용할 수 있도록 하여 게임을 바꿨습니다.\n\n이 가이드는 웹 개발을 위한 최고의 Node.js 프레임워크를 탐색하며, 주요 기능과 이상적인 사용 사례를 강조하여 프로젝트에 완벽하게 맞는 것을 선택하는 데 도움을 줍니다.\n\n# Node.js Frameworks: A Quick Look\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Node.js Frameworks](/assets/img/2024-06-20-Top10NodejsFrameworksForWebDevelopment_1.png)\n\nNode.js는 기술적으로 JavaScript 런타임 환경이지만 종종 프레임워크로 불립니다.\n\nNode.js는 이를 기반으로 하는 JavaScript 프레임워크와 함께 개발자들에게 사전 작성된 코드, 도구 및 라이브러리를 제공하여 웹 개발을 더 쉽고 빠르게 만듭니다.\n\n어떤 Node.js 프레임워크의 핵심 부분은 그 아키텍처와 기능입니다. 이에는 보안 지원, 다른 라이브러리와의 호환성, 유연성 및 사용자 정의 가능성이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발을 위해 Node.js를 사용하는 것에는 여러 가지 이점과 단점이 있습니다. 이러한 장단점을 이해하는 것은 이러한 기능이 개발 요구 사항을 얼마나 잘 충족시키는지에 따라 달라집니다.\n\n# 웹 개발을 위한 최고의 10가지 Node.js 프레임워크\n\n## 1. Express.js\n\nExpress.js는 Node.js 프레임워크 중에서도 최소주의 챔피언으로 높이 평가받고 있습니다. 유연성과 사용 편의성을 우선시하며, 모든 경험 수준의 개발자들 사이에서 인기가 있습니다. 이것이 Express.js를 웹 개발에 강력한 도구로 만드는 이유입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 특징:\n\n- 고유한 미니멀리즘 및 고인물 없는 코어로 높은 유연성을 제공합니다.\n- 서드 파티 미들웨어 및 플러그인의 방대한 생태계가 있습니다.\n- 다양한 URL 요청을 처리하는 강력한 라우팅 시스템이 있습니다.\n- 14가지 이상의 옵션과 함께 작동하는 견고한 템플릿 엔진 지원이 있습니다.\n- 사용자 경험을 고려한 내장된 오류 처리가 있습니다.\n- 자산 효율적 전달을 위한 정적 파일 제공이 있습니다.\n- 플러그인 및 미들웨어를 통한 확장 가능한 아키텍처가 있습니다.\n- 문제 해결을 간소화하는 디버깅 기능이 있습니다.\n- 다양한 HTTP 도우미 함수가 있습니다.\n- 최적의 콘텐츠 전달을 위한 향상된 콘텐츠 협상이 있습니다.\n\n이상적인 용도:\n\n- 일반 웹 애플리케이션, RESTful API, 싱글 페이지 애플리케이션(SPA), 실시간 애플리케이션, 미들웨어 풍부한 애플리케이션에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Express.js를 고려해야 하는가:\n\n- 쉽고 포괄적인 학습 자료 덕분에 초보자에게 이상적입니다.\n- 프로젝트의 특정 요구 사항에 맞게 매우 유연하게 사용할 수 있습니다.\n- 개발 시간을 절약할 수 있는 다양한 미리 제작된 도구 생태계가 있습니다.\n- 대부분의 웹 개발 시나리오에 대해 잘 동작하는 성능을 제공합니다.\n\n## 2. NestJS\n\nNestJS는 Express.js와 다르게 다가갑니다. Express 위에 구축된 완벽한 프레임워크로 TypeScript를 활용해 구조를 강제하고 깨끗한 코드 아키텍처를 촉진합니다. NestJS가 제공하는 것은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n키 특징:\n\n- 클래스와 데코레이터를 활용한 객체지향 개발\n- 더 깔끔한 코드를 위한 내장형 의존성 주입\n- 확장 가능한 모듈식 아키텍처\n- 견고한 어플리케이션을 위한 테스트 유틸리티\n\n이상적인 사용 용도:\n\n- 기업 어플리케이션, API, 마이크로서비스 아키텍처\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS를 고려해야 하는 이유:\n\n- 대형 프로젝트의 코드 유지 보수성 및 확장성을 촉진합니다.\n- 의존성 주입과 같은 기능으로 보일러플레이트 코드를 줄입니다.\n- 복잡한 응용프로그램을 구축하기 위한 구조화된 접근 방식을 제공합니다.\n\n## 3. Koa.js\n\nKoa.js는 다음 세대의 Node.js 프레임워크로 간주되며 종종 Express.js의 후속작으로 여겨집니다. Express.js에 비해 응용프로그램을 보다 더 세밀하게 제어할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요 기능:\n\n- 현대 웹 애플리케이션에 이상적인 비동기 기본 설정.\n- 유연성을 위한 미들웨어 기반 아키텍처.\n- 비동기 작업 처리를 위한 제너레이터 함수.\n- 맞춤화에 초점을 맞춘 작은 코어.\n\n적합한 용도:\n\n- API, 마이크로서비스, 실시간 애플리케이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 Markdown 형식으로 바꿔드릴게요.\n\n왜 Koa.js를 고려해야 하나요:\n\n- Express.js보다 사용자 정의 기능을 구축하기 위한 유연성이 더 큼\n- 비동기 작업에 초점을 맞춘 현대적인 웹 애플리케이션에 적합\n- 작은 코어 크기로 가벼운 프레임워크가 필요한 프로젝트에 이상적\n\n## 4. Fastify\n\nFastify는 초고속 성능을 우선시하여, 빠른 속도와 낮은 대기 시간을 요구하는 응용 프로그램에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n키 특징:\n\n- 효율적인 라우팅 및 플러그인 아키텍처로 인한 초고속 성능.\n- 자동 라우트 등록을 통한 쉬운 플러그 앤 플레이 아키텍처.\n- 견고한 데이터 처리를 위한 스키마 유효성 검사.\n- 깔끔한 API로 우수한 개발자 경험을 제공.\n\n이상적인 용도:\n\n- 실시간 애플리케이션, 성능 중요한 API, 대규모 웹 애플리케이션에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 Fastify의 이유를 고려해보세요:\n\n- 최상의 성능을 요구하는 애플리케이션에 이상적입니다.\n- 개발자 친화적인 API로 쉽게 배우고 사용할 수 있습니다.\n- 모듈식 아키텍처를 통해 플러그인을 사용하여 맞춤 설정이 가능합니다.\n\n## 5. Hapi.js\n\nHapi.js는 견고한 보안 기능과 프로덕션 준비 기능으로 잘 알려진 기업용 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- 다양한 기능을 위한 폭넓은 플러그인 생태계.\n- 데이터 무결성을 위한 내장 검증.\n- 인증 및 권한 부여와 같은 견고한 보안 기능.\n- 훌륭한 문서 및 다양하고 지원하는 커뮤니티.\n\n이상적인 사용처:\n\n- 대규모 기업 애플리케이션, 중요한 API에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Hapi.js를 고려해야 하는가:\n\n- 뛰어난 보안 기능으로 민감한 데이터를 보호하기에 이상적이다.\n- 방대한 문서와 다양한 커뮤니티가 지원을 보장한다.\n- 신뢰할 수 있는 어플리케이션을 구축하기 위한 성숙하고 안정적인 프레임워크를 제공한다.\n\n## 6. Sails.js\n\nSails.js는 실시간 기능과 데이터 주도 개발에 중점을 둔 MVC 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- 실시간 통신을 위한 내장된 웹 소켓 지원.\n- 풍부한 모델 기능으로 데이터 기반 개발.\n- 효율적인 API 개발을 위한 자동 REST API 생성.\n- 설정보다 규칙에 중점을 둔 개발자 생산성에 초점.\n\n이를 통해 실시간 웹 애플리케이션, 채팅 애플리케이션, 협업 편집 도구에 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Sails.js를 고려해야 하는가:\n\n- 내장된 웹 소켓을 통해 실시간 기능의 개발을 간소화합니다.\n- 데이터 중심 웹 애플리케이션을 쉽게 구축할 수 있습니다.\n- 더 빠른 개발을 위한 관례 기반 접근 방식을 제공합니다.\n\n## 7. Meteor.js\n\n대부분의 프레임워크와 달리, Meteor.js는 웹, 모바일 및 데스크톱 애플리케이션을 구축하기 위한 풀 스택 솔루션을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- 클라이언트와 서버 간 실시간 데이터 동기화.\n- 자동 데이터 업데이트를 위한 반응형 프로그래밍 모델.\n- 웹, 모바일 (iOS, Android), 데스크탑 (Windows, macOS, Linux)에서 작동.\n- 쉬운 배포를 위한 내장된 빌드 도구.\n\n이상적인 용도:\n\n- 실시간 협업 애플리케이션, 채팅 애플리케이션, 소셜 네트워킹 플랫폼에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Meteor.js를 고려해야 하는가:\n\n- 자동 데이터 동기화로 실시간 애플리케이션을 구축을 간단하게 만들어줍니다.\n- 크로스 플랫폼 애플리케이션 (웹, 모바일, 데스크톱)을 개발하는 데 사용할 수 있습니다.\n- 풀 스택 애플리케이션에 대한 통합 개발 경험을 제공합니다.\n\n## 8. LoopBack\n\nLoopBack은 빠른 API 개발과 내장된 접근 제어에 중점을 둔다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- RESTful API를 위한 자동 API 생성 기능.\n- 사용자 권한 관리를 위한 내장된 액세스 제어 (ACL).\n- 다양한 데이터베이스 통합을 위한 포괄적인 커넥터.\n- 클라우드 플랫폼과 쉽게 통합 가능.\n\n이상적인 용도:\n\n- RESTful API, 모바일 백엔드, 사물인터넷 (IoT) 애플리케이션 백앤드.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLoopBack을 고려해야 하는 이유:\n\n- 자동 API 생성으로 빠른 API 개발에 적합합니다.\n- 기본 액세스 제어가 사용자 권한 관리를 간단하게 만들어 줍니다.\n- 다양한 데이터 소스에 연결되는 API 구축에 적합합니다.\n\n## 9. Feathers.js\n\nFeathers.js는 마이크로서비스 아키텍처를 활용한 현대적인 웹 애플리케이션을 개발하는 데 적합한 경량 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- 확장성과 유지보수성을 위한 마이크로서비스 아키텍처.\n- 웹소켓 지원을 내장한 실시간 기능.\n- 효율적인 데이터 처리를 위한 클라이언트-서버 통신에 집중.\n- 커스터마이징을 위한 강력한 훅을 갖춘 RESTful API.\n\n이 제품은 다음에 최적화되어 있습니다:\n\n- 확장 가능한 API, 마이크로서비스 아키텍처, 실시간 웹 애플리케이션 구축\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표를 마크다운 형식으로 변경하세요.\n\n\n| 왜 Feathers.js를 고려해야 하는가:\n\n- 마이크로서비스 아키텍처로 구축된 현대 웹 애플리케이션에 적합합니다.\n- 실시간 통신 및 유연성에 중점을 둔 경량 프레임워크입니다.\n- 복잡한 애플리케이션을 구축하기 위한 모듈식 접근 방식을 제공합니다.\n\n## 10. Adonis.js\n\nAdonis.js는 내장된 ORM(Object-Relational Mapper)을 갖춘 객체지향 MVC 프레임워크이며, 데이터베이스 상호작용을 간소화합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능:\n\n- 관심사의 명확한 분리를 통한 객체지향 개발.\n- 간소화된 데이터베이스 상호작용을 위한 내장 Adonis ORM.\n- 효율적인 성능을 위한 비동기 프로그래밍.\n- 깔끔하고 간결한 구문으로 개발자 경험에 중점을 둠.\n\n이상적인 대상:\n\n- 일반적인 웹 애플리케이션, 데이터베이스 주도 애플리케이션, API\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Adonis.js를 고려해야 하는가:\n\n- 깔끔한 구문 및 객체 지향 접근 방식은 학습과 사용이 쉽습니다.\n- 내장 ORM은 데이터베이스 상호 작용을 단순화합니다.\n- 다양한 웹 개발 프로젝트에 대한 훌륭한 프레임워크를 제공합니다.\n\n# XongoLab과 함께 노드.js의 파워를 경험해보세요\n\nXongoLab은 경험이 풍부한 개발팀을 보유한 선도적인 노드.js 개발 회사입니다. 우리는 최신 기술과 도구를 사용하여 인기 있는 노드.js 프레임워크로 고품질이면서 확장 가능한 웹 애플리케이션을 구축합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 다양한 NodeJS 개발 서비스는 모든 사용자 정의 요구 사항을 충족합니다. 우리 팀은 최고의 Node.js 프레임워크를 사용하여 모든 규모의 비즈니스를 위한 웹 앱이나 API를 개발하는 데 능숙합니다. Node.js 개발자를 고용하고 오늘부터 웹 개발 프로젝트를 시작해보세요.\n\n# 마무리\n\nNode.js 프레임워크 랜드스케이프는 다양한 옵션으로 풍부합니다. 각 프레임워크의 강점과 약점을 이해하고 프로젝트 요구 사항을 신중하게 평가함으로써, 강력하고 확장 가능하며 효율적인 Node.js 애플리케이션을 구축하는 최적의 선택을 할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-Top10NodejsFrameworksForWebDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-Top10NodejsFrameworksForWebDevelopment_0.png","tag":["Tech"],"readingTime":7},{"title":"NodeJS 유닛 테스팅 튜토리얼 포괄적 가이드","description":"","date":"2024-06-20 01:38","slug":"2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide","content":"\n\n![Node.js Unit Testing Tutorial](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_0.png)\n\n안녕하세요! Node.js는 서버 측에서 JavaScript를 실행하는 인기 있는 JavaScript 엔진입니다. 세계적인 최고의 기술 회사들이 Node.js를 사용하여 효율적이고 효과적인 소프트웨어 개발을 해 왔기 때문에 JavaScript를 사용한 서버 측 개발에서는 사실상 표준으로 자리 잡았습니다.\n\n소프트웨어 공학에서 소프트웨어 테스팅은 중요한 단계로, 결함을 제거하고 테스트 중인 소프트웨어가 요구 사항을 준수하는지 확인하는 데 도움이 됩니다.\n\nMocha를 사용하여 소프트웨어 테스팅을 구현하는 것이 몇 년 동안 다른 도구보다 증가하는 이점을 보여 주었습니다. 이렇게 하면 TDD(Test-Driven Development) 및 BDD(Behavior-Driven Development)를 위한 단언 라이브러리 사이를 쉽게 전환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS 단위 테스트 튜토리얼에서는 Node.js를 사용하여 효과적인 소프트웨어 테스트를 수행하고, Mocha와 Chai를 사용하여 효율적인 테스트 케이스를 작성하는 방법을 탐색할 것입니다. 또한, Chai와 Mocha를 결합하여 Node에서 자동화된 테스트를 실행함으로써 더 나은 품질의 코드를 작성하는 방법을 배울 수 있을 것입니다.\n\n## NodeJS 단위 테스트란?\n\nNodeJS 단위 테스트는 전문 자동화 테스트 프레임워크와 라이브러리를 사용하여 Node.js 애플리케이션의 개별 단위나 구성 요소를 테스트하는 것을 의미합니다.\n\n이러한 테스트에는 개별 함수, 모듈 또는 클래스의 기능을 테스트하거나 애플리케이션의 서로 다른 부분 간의 상호 작용을 테스트하는 것이 포함될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인기있는 NodeJS 단위 테스트 프레임워크에는 Jest, Mocha, AVA 등이 있습니다. 그러나 이 NodeJS 단위 테스트 튜토리얼에서는 Mocha와 Chai를 사용한 NodeJS 단위 테스트에 대해 살펴볼 것입니다.\n\n## Mocha와 Chai를 사용한 NodeJS 단위 테스트\n\nMocha.js는 Node.js 및 브라우저에서 실행되는 인기있는 JavaScript 테스트 프레임워크입니다. 다양한 환경에서 테스트를 구조화하고 실행하는 간단하고 유연한 방법을 제공합니다.\n\nChai는 Mocha와 결합하여 더 자연스럽고 표현력 있는 방식으로 테스트 어설션을 작성할 수 있는 어설션 라이브러리입니다. Mocha와 Chai를 사용하면 Node.js 애플리케이션의 단위 테스트를 쉽게 작성하고 실행할 수 있습니다. 이 Mocha NodeJS 튜토리얼을 통해 Mocha를 사용하여 NodeJS 모듈을 테스트하는 방법에 대해 더 배울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재로서 Chai와 Mocha는 각각 Github와 npmtrends.com을 기준으로 사용량과 월간 다운로드 수를 토대로 상당한 인기를 얻고 있습니다.\n\n![image](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_1.png)\n\n이 NodeJS 단위 테스트 튜토리얼의 다음 섹션에서는 Mocha와 Chai를 사용하여 단위 테스트를 작성하는 방법에 대해 알아보겠습니다.\n\n## Mocha와 Chai로 단위 테스트 작성하는 방법은?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 단위 테스트를 구현하기 위해 Mocha 테스팅 라이브러리와 Chai 어설션 라이브러리를 사용하는 방법을 배우게 됩니다.\n\nNodeJS 단위 테스트를 작성하기 위해 Mocha와 Chai를 설치하고 구성하기 전에 Mocha와 Chai에서 자주 사용되는 메서드 중 일부를 살펴보겠습니다.\n\n### Describe:\n\n`describe()` 메서드는 그룹화된 테스트 스위트의 블록입니다. 이는 테스트를 위해 그룹화된 테스트 스크립트 모음입니다. 두 개의 매개변수를 사용하며, 첫 번째는 스위트의 이름으로 사용되는 문자열이고, 두 번째는 테스트 케이스를 그룹화하는 콜백 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndescribe('테스트 도우미', function () {\n /**\n  * 여기에 모든 관련 테스트 케이스를 추가하세요\n  *\n  */\n});\n```\n\nIt():\n\n`it()` 메서드는 실행할 가장 작은 테스트 케이스입니다. 두 개의 매개변수를 가져옵니다. 첫 번째는 suite의 이름인 문자열이고 두 번째는 테스트 케이스를 실행할 콜백 함수입니다.\n\n```js\ndescribe('테스트 도우미', function () {\n it('피보나치 수열을 계산해야 합니다', function () {\n   /*...*/\n });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기대:\n\n`expect()` 메서드는 행동 주도 개발 (BDD) 스타일 라이브러리에서 단언문을 체이닝하기 위해 사용됩니다. 대부분 불리언이나 숫자 등으로 해결되는 주제에 사용됩니다.\n\n```js\nit('피보나치 수열을 계산해야 합니다', function () {\n   const fib = fibonacci(4);\n   expect(fib).toEqual(5);\n });\n```\n\n해야 할 일:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`should()` 메서드는 BDD-style 라이브러리에서도 사용되어, 단언문을 연결하는 데 사용됩니다. 그러나 각 객체에 should 속성이 추가되어 체인을 시작합니다.\n\n```js\nit('일부 챌린지 업데이트 - 찾을 수 없음', async () =\u003e {\n const response = await chai.request(app)\n should.equal(response.status, 404)\n should.equal(response.body.message, 'Challenge with id: ${notFoundId} doesn't exist')\n})\n```\n\nAssert:\n\n`assert()` 메서드는 테스트 주도 개발 (TDD) 스타일 라이브러리에서 사용되어, 단언문을 연결하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nit('partially update challenge - not found', async () =\u003e {\n assert('foo' !== 'bar', 'foo is not bar');\n assert(Array.isArray([]), 'empty arrays are arrays');\n})\n```\n\nMocha 및 Chai를 설치하는 방법은 무엇인가요?\n\nMocha와 Chai를 시작하려면 먼저 프로젝트에 설치해야 합니다. 터미널에서 다음 명령을 실행하여 설치할 수 있습니다. LambdaTest로 JavaScript 자동화를 빠르게 시작해 보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트를 위해 새 프로젝트를 생성하거나 이 저장소를 복제할 수 있어요:\n\n```js\nnpm install --save-dev mocha \nnpm install --save-dev chai\n```\n\n여기서 저장소를 다운로드할 수 있어요.\n\nMocha와 Chai가 설치되었으면, 테스트 파일을 만들기 시작할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 마크다운 형식으로 변경한 내용입니다.\n\n![NodeJSUnitTestingTutorialAComprehensiveGuide_2](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_2.png)\n\n프로젝트 폴더 구조를 보면 다음 샘플과 같이 tests 폴더가 포함되어 있어야 합니다.\n\n![NodeJSUnitTestingTutorialAComprehensiveGuide_3](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_3.png)\n\nMocha는 기본적으로 test라는 디렉토리에서 테스트 파일을 찾지만 다른 디렉토리나 파일 패턴을 지정하여 테스트 파일을 찾을 수도 있습니다. 각 테스트 파일은 `.test.js` 또는 `.spec.js` 파일 확장자를 가져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 다음, 새 프로젝트를 만들었다면 package.json 파일을 열고 아래 코드에서 \"scripts\" 블록을 \"mocha\"로 변경하세요:\n\n```js\n\"scripts\": {\n   \"test\": \"mocha\",\n   \"start\": \"node app.js\"\n },\n```\n\n테스트를 실행하기 전에 .env 파일에서 다음 환경 변수를 설정해주세요. LambdaTest 프로필 페이지에서 사용자 이름과 액세스 키를 찾을 수 있습니다.\n\n여기서는 실제 브라우저, 기기 및 운영 체제 조합 3000개 이상에서 웹 및 모바일을 위한 수동 및 자동화 테스트를 수행할 수 있는 LambdaTest에서 Node.js 단위 테스트를 실행하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nLT_USERNAME= \nLT_ACCESS_KEY= \nGRID_HOST=hub.lambdatest.com/wd/hub\n```\n\n라이브러리를 설치하고 환경 변수를 설정한 후에, 아래는 웹 계산기의 구현입니다:\n\n## 간단한 NodeJS 앱을 만드는 방법\n\n먼저 NodeJS 애플리케이션을 만들어서 Node 어플리케이션에 전달된 입력을 계산하고 결과를 응답으로 반환하는 간단한 NodeJS 애플리케이션을 만들어보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 애플리케이션에서는 Node.js를 사용하여 간단한 계산기 애플리케이션을 만들고 프로덕션 서버에 배포했습니다. 다음은 두 개의 입력값을 받아 계산된 결과를 반환하는 애플리케이션입니다.\n\n![calculator](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_4.png)\n\n이미 라이브 서버에 애플리케이션이 배포되어 있으므로 계산하여 결과를 반환할 것입니다. 아래는 LambdaTest 클라우드 Selenium 그리드를 사용하여 계산을 수행하는 코드입니다.\n\n```js\nconst { Builder, By } = require('selenium-webdriver');\nlet driver;\nconst USERNAME = process.env.LT_USERNAME ?? '';\nconst KEY = process.env.LT_ACCESS_KEY ?? '';\nconst GRID_HOST = 'hub.lambdatest.com/wd/hub';\n\nconst searchCapabilities = {\n  browserName: 'Chrome',\n  browserVersion: '110.0',\n  'LT:Options': {\n    username: USERNAME,\n    accessKey: KEY,\n    geoLocation: 'US',\n    platformName: 'Windows 10',\n    build: 'calculate',\n    project: 'Calculate',\n    w3c: true,\n    plugin: 'node_js-node_js',\n  },\n};\n\nconst searchGridUrl = 'https://' + USERNAME + ':' + KEY + '@' + GRID_HOST;\n\nasync function calculateWithLambdaTest(num1 = 5, num2 = 5) {\n  try {\n    driver = await new Builder()\n      .usingServer(searchGridUrl)\n      .withCapabilities(searchCapabilities)\n      .build();\n\n    await driver.get(\n      'https://www.lambdatest.com/selenium-playground/simple-form-demo'\n    );\n\n    const inputSum1 = await driver.findElement(By.id('sum1'));\n    const inputSum2 = await driver.findElement(By.id('sum2'));\n    const button = await driver.findElement(\n      By.xpath(\n        '/html/body/div[1]/div/section[3]/div/div/div[2]/div[2]/div[2]/div/div[1]/form/button'\n      )\n    );\n\n    inputSum1.sendKeys(num1);\n    inputSum2.sendKeys(num2);\n\n    button.click();\n\n    const result = await driver.findElement(By.id('addmessage'));\n\n    return await result.getText();\n  } catch (error) {\n    throw new Error(error);\n  } finally {\n    await driver.quit();\n  }\n}\n\nmodule.exports = {\n  calculate: calculateWithLambdaTest,\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안내:\n\n코드를 함께 살펴보고 이해해 봅시다.\n\n단계 1: 필요한 패키지 추가 및 Selenium 기능 생성\n\n먼저 selenium-webdriver 패키지가 필요합니다. 작업을 실행하기 전에 필요한 것을 초기화했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, Markdown 형식으로 테이블 태그를 변경해주세요.\n\n다음으로, LambdaTest Capabilities Generator를 사용하여 Selenium 구성을 생성합니다. 구성을 설정하고 아래에 표시된 대로 JavaScript 객체를 코드에 복사하세요.\n\n![LambdaTest Capabilities Generator](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_5.png)\n\n단계 2: 작업 수행.\n\n다음으로, 구성 및 용량을 사용하여 드라이버를 생성한 후 `calculateWithLambdaTest()` 함수를 사용하여 LambdaTest 그리드를 사용하여 계산을 수행했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 내에서 위의 구성을 사용하여 드라이버의 인스턴스를 생성합니다.\n\n![image](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_6.png)\n\n다음으로 `driver.get()` 함수를 사용하여 계산기가 있는 웹페이지를 엽니다.\n\n![image](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 Selenium `findElement` 함수를 사용하여 페이지에서 요소를 찾습니다.\n\n![이미지](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_8.png)\n\n아래 이미지는 HTML 페이지의 모든 요소의 전체 XPath를 검색하는 방법을 보여줍니다. 요소의 HTML 태그를 마우스 오른쪽 단추로 클릭하고 copy full XPath 또는 Copy XPath를 클릭하여 복사할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 calculateWithLambdaTest 함수 내부에서는 findElement 함수를 사용하여 가져온 input 요소에 숫자 입력을 전달하는 데 sendKeys() 함수를 사용했습니다.\n\n아래 이미지를 참조하세요:\n\n![image](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_10.png)\n\n마지막으로 form을 제출하고 계산을 수행하기 위해 click() 함수를 사용했습니다. 계산 결과를 얻기 위해 findElement(By.id('addmessage'))를 사용하여 결과를 검색하고 getText() 함수를 사용하여 결과 요소의 텍스트 값을 가져옵니다. Selenium에서 요소의 텍스트를 가져오는 방법에 대해 더 알고 싶다면 이 블로그를 참조해보세요.\n\n## Express를 사용하여 Node 서버 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 Node.js 서버 Express를 만들어 Mocha 프레임워크를 사용하기 전에 수동으로 구현을 테스트해 봅니다.\n\n먼저 아래 명령어를 사용하여 ExpressJS를 설치해 주세요:\n\n```js\nnpm install express\n```\n\n위 명령어의 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_11.png\" /\u003e\n\n루트 디렉토리에 `app.js`라는 파일을 만들고 아래 스니펫을 `app.js` 파일에 붙여넣으세요:\n\n```js\nconst express = require('express');\n\nconst Calculator = require('./calculate');\nconst app = express();\nconst port = 3002;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\n\napp.get('/calculate', async (request, response) =\u003e {\ntry {\nconst num1 = request.query?.num1 ?? 4;\nconst num2 = request.query?.num2 ?? 6;\nconst data = await Calculator.calculate(num1, num2);\nconsole.log(num1, num2, data);\nresponse.status(200).json(data);\n} catch (error) {\nresponse.status(500).json({\nmessage: '서버 오류가 발생했습니다',\n});\n}\n});\n\napp.listen(port, () =\u003e {\nconsole.log('예시 앱이 http://localhost:${port}에서 수신 대기 중입니다');\n});\n```\n\n이 NodeJS 테스트 튜토리얼의 다음 섹션에서는 Mocha 및 Node.js를 사용하여 Node.js 애플리케이션을 테스트하는 방법을 살펴볼 것입니다. 그러나 프로젝트를 수동으로 테스트하면 입력값에 따라 결과가 나타날 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Mocha를 이용한 NodeJS 단위 테스트하는 방법\n\nNode 애플리케이션을 위해 테스트 디렉토리에 파일을 생성하고 `tests/chai-calculate.spec.js` 파일을 만들어서 다음 코드 스니펫을 추가하세요. 아래는 코드 스니펫입니다:\n\n```js\nconst chai = require('chai').expect;\nconst request = require('request');\nlet url;\n\nbeforeEach(async () =\u003e {\n    url = 'http://localhost:3002/calculate';\n});\n\ndescribe('Calculate', () =\u003e {\n\n    it('두 값의 합을 계산합니다', async () =\u003e {\n        request(url, function (error, response, body) {\n            expect(response.statusCode).to.equal(200);\n            expect(body[0]).to.equal(9);\n            done();\n        });\n    });\n\n    it('잘못된 두 값의 합을 계산합니다', async () =\u003e {\n        request(url + '?num1=5\u0026num2=6', function (error, response, body) {\n            expect(response.statusCode).to.equal(200);\n            expect(body[0]).to.not.equal(9);\n            done();\n        });\n\n    });\n\n});\n```\n\n마지막으로, 다른 모든 테스트 케이스를 Describe 블록 안에 포함시켰습니다. 각 테스트 케이스는 특정 동작이나 기능 구현을 테스트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트 실행하기\n\n테스트를 실행하려면 루트 터미널에 다음 명령을 입력하십시오.\n\n```js\nyarn start\n\nyarn test\n```\n\n테스트를 성공적으로 실행한 후에는 아래 스크린샷과 같이 테스트에 대한 녹색 통과 메시지를 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_12.png)\n\n지금까지는 테스트가 통과하는지 확인하기 위해 위 명령을 수동으로 실행했습니다. 이제 앞으로 전개해 나가기 전에 배포하기 전에 테스트가 통과하는지 확인해야 합니다.\n\nLambdaTest Grid를 사용하여 이 프로세스를 자동화할 수도 있습니다. 이를 통해 배포 프로세스 중에 테스트 전략을 실행할 수 있습니다.\n\n이 자격증은 자바스크립트 개발자로서 자동화 테스트 분야에서 성공을 위해 필요한 포괄적인 지식과 필수 기술을 제공하여, 어떤 자바스크립트 자동화 역할에서도 뛰어날 수 있도록 돕습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소프트웨어 테스트는 소프트웨어 개발 중이나 이후에 소프트웨어가 요구 사항과 일치하는지 확인하는 방법입니다. 버그를 줄이고 결함이 있는 소프트웨어 제품을 배포하는 데 매우 중요한 소프트웨어 엔지니어링 측면입니다.\n\nMocha는 Chai와 결합하여 BDD 또는 TDD 접근 방식을 사용하여 NodeJS 단위 테스트를 수행하는 강력한 도구입니다. 테스트를 간단하고 유연하게 만드는 유연한 자바스크립트 테스트 프레임워크입니다.\n\n이 NodeJS 단위 테스트에서는 Mocha와 Chai를 사용하여 NodeJS 단위 테스트를 수행하는 방법을 탐색했습니다.\n\n원문은 https://www.lambdatest.com에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-NodeJSUnitTestingTutorialAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},{"title":"Nodejs는 빠르다고 하면 어떻게 생각하시나요","description":"","date":"2024-06-20 01:36","slug":"2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-WhenYouHearNodejsIsFast_0.png\" /\u003e\n\n만약 Node.js 개발자에게 플랫폼에 대한 좋은 점에 대해 물어보면 \"Node.js가 빠르다\"고 들을 확률이 높습니다. 왜 빠른지 묻는다면 JavaScript가 빠르거나 비동기성, 싱글 스레드, 또는 V8 엔진 때문이라고 들을 수도 있습니다...\n\n이러한 모든 이유들은 어떤 면에서는 타당할 수 있습니다. 어떻게 작동하든 Node.js의 메커니즘은 궁극적으로 처리 능력을 높이기 위해 노력합니다. 하지만 이러한 기능을 구현하는 것은 Node.js뿐만이 아니며, 많은 다른 언어나 플랫폼에서도 구현되어 있고 때로는 더 나은 방식으로 구현되어 있을 수도 있습니다.\n\n따라서, Node.js는 정말로 얼마나 빠를까요? 이 글에서는 \"Node.js가 빠르다\"라는 문제에 대한 내 견해를 제시하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 먼저, 대부분의 사람들이 Node.js가 빠르다고 결론 내릴 때 자주 언급하는 메커니즘을 살펴보겠습니다.\n\n# Single Thread\n\nNode.js는 비동기 작업을 처리하기 위해 이벤트 루프를 통해 단일 스레드 모델을 사용합니다. 이를 통해 Node.js는 동시에 여러 요청을 쉽게 처리할 수 있습니다.\n\n이 개념을 이해하기 위해, PHP와 같이 단일 스레드 모델을 따르지 않는 언어를 생각해보십시오. 각 연결에 대해 PHP는 처리하기 위한 스레드를 생성합니다. 명백하게, 서버는 생성된 각 스레드에 대해 CPU 및 메모리와 같은 자원을 할당해야 합니다. 이제 여러 요청이 전송될 때 무슨 일이 발생하는지 상상해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모델은 Node.js에 일부 이점을 제공합니다. 리소스 소비를 최소화하기 위해 스레드 수를 줄이면서도 많은 수의 동시 요청을 처리할 수 있습니다.\n\n# 비동기 I/O\n\n웹 응용 프로그램이 데이터베이스와 상호 작용할 필요가 없는 경우는 거의 없습니다. 데이터베이스에 연결하고 쿼리하는 데는 일반 명령보다 더 많은 시간이 걸린다는 것을 우리는 다 알고 있습니다. 예를 들어 API 엔드포인트가 2초가 소요되는 쿼리를 수행해 결과를 반환해야 한다고 가정해 봅시다. Node의 단일 스레드 모델에서 두 번째 요청은 처리되기까지 적어도 2초를 기다려야 할까요? 세 번째, 네 번째... 요청은 어떨까요? 이로 인해 지연 시간이 기하급수적으로 증가하지 않을까요?\n\n걱정하지 마세요, 왜냐하면 Node.js의 강점 중 하나는 비동기 I/O를 처리할 수 있는 능력입니다. 특정 수의 요청을 거의 동시에 처리할 수 있습니다. 그러나 Node.js는 각 요청에 차례로 응답하며, 이 프로세스는 보통 매우 빠르게 진행됩니다. PHP에서는 스레드가 독립적이기 때문에 편안하게 결과를 동시에 반환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# V8 Engine\n\nNode.js를 언급할 때 V8 엔진을 무시할 수 없어요. 이 도구는 JS 코드를 기계 코드로 번역하고 실행하는 JIT 컴파일러입니다. V8의 속도는 모든 JavaScript 엔진 중에서도 극도로 인상적입니다.\n\n그렇다면, Node.js는 정확히 얼마나 빠를까요?\n\nNode.js가 특히 API 시스템, 채팅과 같은 실시간 애플리케이션, 또는 많은 I/O를 필요로 하는 작업과 같은 특정 시나리오에 적합하다고 누군가 추천했다는 소문을 들었을 수 있어요. 하지만 Node.js의 처리 속도를 칭찬하는 글은 매우 드물죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능은 많은 동시 요청을 처리할 때 모든 언어 또는 플랫폼에 대한 고민입니다. 각 언어는 특정 문제를 해결하기 위해 만들어졌습니다. 따라서 Node.js가 빠르다고 말하는 것은 정확하지 않습니다. 오히려 Node.js가 적절한 선택인 경우와 그 이유를 평가해야 합니다.\n\n그렇다고 해서 Node.js가 \"빠르지 않다\"는 것은 아닙니다. 다만, Node.js의 속도는 배포와 릴리스 속도에 있다고 생각합니다.\n\nNode는 JS 실행 환경을 제공하며, JS는 프로그래밍 언어 분야에서 매우 인기가 있습니다. 따라서 Node 커뮤니티는 크고, 프로젝트를 위한 개발 파트너를 빨리 찾을 수 있습니다. 또한, 이 개발을 통해 npm을 통해 Node를 위해 무수한 라이브러리가 구현되었습니다. 커뮤니티가 도와줄 것이기 때문에 바퀴를 다시 발명할 필요가 없습니다.\n\n결론적으로, 강력한 언어 또는 플랫폼을 결정하는 것은 개발자의 태도와 커뮤니티 내에서의 보급 범위입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다른 언어나 플랫폼과의 Node.js 성능 비교\n\n만약 아직 Node.js가 \"빠르다\"고 믿지 못하신다면, [Techempower](https://www.techempower.com/benchmarks/#section=data-r21\u0026test=plaintext)가 다양한 언어나 플랫폼의 성능을 서로 비교한 결과를 쉽게 확인할 수 있습니다. 공정성을 보장하기 위해 같은 환경에서 여러 언어나 플랫폼에 대해 여러 테스트를 실행하며 최신 버전의 언어나 플랫폼을 꾸준히 업데이트하고 재테스트합니다.\n\n2022년 7월 최근 측정 결과에 따르면, \"hello world\"과 같은 텍스트 응답 서버 테스트에 대해 Node.js와 [fastify](https://www.npmjs.com/package/fastify) 같은 인기 있는 프레임워크는 575,967 req/s의 처리량으로 156위에 랭크되었습니다. 이는 C#, Java 또는 Golang과 같은 언어로 구성된 다른 프레임워크들보다 훨씬 낮은 수치입니다. 특히, C#을 사용한 aspcore는 7백만 req/s 이상의 처리량을 달성할 수 있습니다.\n\n![2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast_1.png](/assets/img/2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 쿼리 속도 테스트를 위해 fastify-mysql은 9,383 req/s를 처리할 수 있으나, 여전히 C#이 달성한 20,000 이상의 응답 속도에는 훨씬 못 미칩니다.\n\n더 많은 성능 테스트가 있습니다. 독자 여러분은 [프로젝트 정보 프레임워크 테스트 개요](https://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview)에서 Techempower의 벤치마크 기준과 함께 자세히 알아볼 수 있습니다.\n\n# 결론\n\n본 글에서는 “Node.js가 빠르다”고 말할 때 무슨 의미인지 밝히고자 합니다. 동시에 각 언어나 플랫폼에는 존재 이유가 있으며, 그들의 속도를 비교하는 것이 모든 강점을 반영하지는 않는다는 점을 강조하고자 합니다. 대신, 우리는 각각의 강점과 약점을 이해하고 문제에 적절히 적용해야 한다는 것을 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떻게 생각하세요? Node.js가 정말 \"빠르다\"고 생각하시나요? 아래 댓글로 의겢을 나누어 주세요!","ogImage":{"url":"/assets/img/2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast_0.png"},"coverImage":"/assets/img/2024-06-20-WhatdoyouthinkwhenIsayNodejsisfast_0.png","tag":["Tech"],"readingTime":4},{"title":"NextJS에서 Node Cron을 사용해 예약 작업 실행하기","description":"","date":"2024-06-20 01:35","slug":"2024-06-20-RunningaScheduledjobinNextJSwithNodeCron","content":"\n\n![2024-06-20-RunningaScheduledjobinNextJSwithNodeCron](/assets/img/2024-06-20-RunningaScheduledjobinNextJSwithNodeCron_0.png)\n\nNext.js에서 Cron 작업을 소개합니다. Vercel Cron과 같은 외부 서비스를 의존하지 않고 Next.js 프레임워크 내에서 예약된 작업을 통합하는 주제입니다. Cron 작업은 데이터 가져오기, 이메일 알림, 또는 웹 애플리케이션에서 시스템 유지보수와 같은 반복적인 작업을 자동화하는 데 중요한 역할을 합니다. Vercel은 내장된 cron과 유사한 기능을 제공하지만 Next.js 내에서 cron 작업을 직접 구현하는 방법을 이해하면 애플리케이션의 예약된 작업에 더 많은 유연성과 제어를 제공할 수 있습니다. 이 블로그 포스트에서는 cron 작업의 기본 원리를 살펴보고 Node.js를 사용하여 Next.js 프로젝트에 이를 원활하게 통합하는 방법을 보여드리겠습니다. 함께 알아보겠습니다!\n\n**단계 1**\n\n필요한 패키지를 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i node-cron\n```\n\n단계 2\n\n서버.js 설정\n\n```js\nconst express = require('express');\nconst next = require('next');\nconst axios = require('axios');\n\nconst dev = process.env.NODE_ENV !== 'production';\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\n//\nconst http = require('http');\nconst socketIO = require('socket.io');\n//\n\napp.prepare().then(async () =\u003e {\n    const server = express();\n    const httpServer = http.createServer(server);\n\n    // 스케줄러\n    const runScheduler = async () =\u003e {\n        try {\n            const response = await axios.post(`${당신의_기본_URL}/api/services/scheduler`,\n                {\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    }\n                }\n            )\n        } catch (error) {\n            console.log(error)\n        }\n    }\n\n    server.all('*', (req, res) =\u003e {\n        return handle(req, res);\n    });\n\n    const PORT = process.env.PORT || 3000;\n    httpServer.listen(PORT, () =\u003e {\n        console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n\n        runScheduler();\n    });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스텝 3\n\n'api/services/scheduler' 경로에 라우트를 생성하세요.\n\n```js\nimport { NextResponse } from \"next/server\";\n\nvar cron = require('node-cron');\n\nexport async function POST(req, res) {\n\n    try {\n\n        cron.schedule('*/20 * * * *', async () =\u003e {\n\n            console.log('')\n            console.log('######################################')\n            console.log('#                                    #')\n            console.log('# 매 20분마다 스케줄러 실행됨              #')\n            console.log('#                                    #')\n            console.log('######################################')\n            console.log('')\n\n            // 여기에서 작업을 수행하세요\n        });\n\n        return NextResponse.json({ data: '성공', status: 200 });\n\n    } catch (error) {\n        console.log(error)\n        return NextResponse.json({ error: error }, { status: 500 })\n    }\n\n}\n```\n\n- 크론 타이밍은 Crontab.guru를 통해 설정할 수 있습니다. — 크론 스케줄 표현식 생성기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNext.js에서 cron 작업을 구현하는 것을 살펴봐 주셔서 감사합니다. 이 가이드가 Next.js 애플리케이션에서 예약 작업을 활용하는 데 유용한 통찰을 제공했기를 바랍니다. 궁금한 점이 있거나 도전에 직면하거나 단순히 생각을 공유하고 싶다면 망설이지 말고 연락해 주세요. 귀하의 피드백은 저희에게 매우 소중합니다. 귀하와 같은 개발자들을 위해 콘텐츠를 만들어 가는 데 큰 영감을 받습니다. 즐거운 코딩하세요!\n\n참고 자료\n\n- node-cron — npm (npmjs.com)","ogImage":{"url":"/assets/img/2024-06-20-RunningaScheduledjobinNextJSwithNodeCron_0.png"},"coverImage":"/assets/img/2024-06-20-RunningaScheduledjobinNextJSwithNodeCron_0.png","tag":["Tech"],"readingTime":3},{"title":"ES 모듈 범위에서 __dirname이 정의되지 않았습니다 오류를 해결하는 방법","description":"","date":"2024-06-20 01:34","slug":"2024-06-20-Howtofix__dirnameisnotdefinedinESmodulescope","content":"\n\n## 상황\n\n난 예전 프로젝트를 CommonJS에서 ES 모듈로 이주하려고 할 때 이 오류를 만났어. 그리고 진입 파일이 전역 변수인 __dirname을 사용해. 이런 에러 메시지를 봤어:\n\nNode 스크립트에서 __dirname을 사용하면 현재 JavaScript 파일을 포함하는 디렉토리 경로를 받을 수 있어. 많은 Node.js 애플리케이션들이 이 전역 변수를 사용해.\n\nCommonJS 모듈에서 사용할 때(당신의 애플리케이션의 package.json 파일에 \"type\": \"module\"이 정의되지 않았을 때), __dirname은 문제없이 작동하겠지만, ES 모듈에서 사용하면 \"ES 모듈 스코프에서 __dirname이 정의되지 않았습니다\"라는 에러가 나타나.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 해결책\n\n저는 ES 모듈에 관한 Node.js 문서를 살펴봤어요. 특히 import.meta 객체에 대해요. 또한, 필요한 것은 현재 스크립트/모듈이 포함된 디렉토리의 이름이니, Node.js의 path 모듈을 활용할 수 있어요. 또한 url 모듈에는 파일의 완전히 해결된 경로를 반환해주는 fileURLToPath 함수가 있어요.\n\n그래서, path 모듈과 url 모듈에서 fileURLToPath 함수를 함께 import 해야 해요:\n\n```js\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCommonJS의 __dirname 기능을 복제하려면 다음을 수행하기만 하면 됩니다:\n\n```js\nconst __filename = fileURLToPath(import.meta.url); // 파일까지의 경로를 가져옵니다\nconst __dirname = path.dirname(__filename); // 디렉토리 이름 가져옵니다\n```\n\n이제 __dirname 변수가 스크립트에서 원하는 대로 작동할 것입니다. 스크립트에서 이를 확인하려면 정의 바로 다음에 로그를 남기면 됩니다:\n\n```js\nconsole.log(__dirname);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 있어요! 도움이 되었으면 좋겣습니다.\n\n연결하고 싶다면, X 또는 LinkedIn에서 연락할 수 있어요.\n\n건배하며, 계속해서 해킹해보세요!!! 🥂","ogImage":{"url":"/assets/img/2024-06-20-Howtofix__dirnameisnotdefinedinESmodulescope_0.png"},"coverImage":"/assets/img/2024-06-20-Howtofix__dirnameisnotdefinedinESmodulescope_0.png","tag":["Tech"],"readingTime":2},{"title":"AWS Lambda에서 런타임 변경 처리하기 단순한 작업 이상","description":"","date":"2024-06-20 01:34","slug":"2024-06-20-NavigatingRuntimeChangesinAWSLambdaMoreThanJustaSimpleTask","content":"\n\n## 소개\n\nAWS Lambda의 빠르게 발전하는 세계에서 런타임을 변경하는 것은 드롭다운 메뉴에서 새로운 옵션을 선택하는 문제 이상이 아닙니다. 이 작업은 기본 운영 체제를 이해하고 기존 라이브러리와의 호환성, 그리고 성능 및 보안에 미치는 잠재적인 영향을 고려해야 합니다. 특히 Python 및 Node.js와 같은 인기있는 런타임을 사용할 때 이 seemingly straightforward(보통으로 여겨지는) 작업이 왜 복잡성으로 가득 차 있는지 알아봅시다.\n\n## 람다 런타임과 그 환경 이해하기\n\nAWS Lambda는 여러 런타임을 지원하며, 각각이 특정 버전의 Amazon Linux에 연결되어 있는 여러 버전의 Python 및 Node.js를 포함합니다. 이 연관성은 람다 함수가 실행되는 환경을 결정하는 중요한 요소이며, 종속성을 어떻게 관리할지에서부터 응용 프로그램의 보안 포지션에 이르기까지 모든 것에 영향을 미칩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 경우, AWS는 현재 다음을 제공합니다:\n\n- Amazon Linux 2023에서 Python 3.12\n- Amazon Linux 2에서 Python 3.11\n- Amazon Linux 2에서 Python 3.10\n- Amazon Linux 2에서 Python 3.9\n- Amazon Linux 2에서 Python 3.8\n\n마찬가지로, Node.js의 경우 다음을 제공합니다:\n\n- Amazon Linux 2023에서 Node.js 20.x\n- Amazon Linux 2에서 Node.js 18.x\n- Amazon Linux 2에서 Node.js 16.x\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAmazon Linux 2에서 Amazon Linux 2023으로 최신 버전으로 전환하는 것은 큰 변화를 야기합니다. 이 변경 사항은 운영 체제의 최신 버전뿐만 아니라 라이브러리의 호환성 확인, 기존 레이어의 이전 및 네이티브 이진 파일의 재 컴파일도 포함됩니다.\n\n## 올바른 환경에서 빌드 및 배포하기\n\n호환성과 성능을 보장하기 위해 배포 패키지 및 레이어를 Lambda의 런타임 환경과 일치하는 환경에서 빌드하는 것이 중요합니다. Amazon Linux 2023을 사용하는 Python 3.12 및 Node.js 20.x의 경우, 개발자는 이러한 리소스를 Amazon Linux 2023을 실행하는 EC2 인스턴스 또는 Cloud9 환경을 사용하여 만들어야 합니다.\n\n아직 Amazon Linux 2에 있던 이전 버전을 위해선 해당 EC2 또는 Cloud9 환경을 사용해야 합니다. 이 접근 방식은 배포 후 귀찮은 런타임 오류의 주요 원인인 바이너리 호환성과 라이브러리 종속성과 관련된 문제를 최소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 의존성 처리에 대한 실용적인 팁\n\nPython 라이브러리를 다룰 때, Lambda 실행 환경과 유사한 환경에서 pip install 명령을 실행해야 합니다. 이 전략은 Lambda 런타임의 기반이 되는 운영 체제와 호환되는 네이티브 이진 파일을 컴파일하는 데 중요합니다. 이와 관련된 의존성 문제를 처리하기 위한 실용적인 지침을 얻으려면 AWS는 Lambda에서 모듈을 가져올 때 발생하는 일반적인 오류와 해결책을 다루는 이러한 지식 센터 기사와 같은 리소스를 제공합니다.\n\n## 왜 중요한가요?\n\nAmazon Linux의 올바른 버전에서 함수가 실행되도록 보장하는 것은 런타임 오류를 피하는 데만 중요한 것이 아닙니다. 그것은 또한 다음과 같은 영향을 미칩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능: 대상 환경에 맞게 의존성을 빌드하고 최적화하는 경우 최상의 성능이 보장됩니다.\n- 보안: 각 버전의 Amazon Linux에는 해당 보안 기능과 패치가 함께 제공되므로 특히 프로덕션 환경에서는 최신 지원 버전과 함께 정렬하는 것이 중요합니다.\n\n## 결론\n\nAWS는 Lambda를 계속 발전시키는 동안 런타임 변경에 적응하기 위해서는 환경과 의존성에 대한 세심한 이해가 필요합니다. 이러한 측면을 꼼꼼히 관리함으로써 개발자는 클라우드에서 원활하고 안전하며 효율적인 함수 실행을 보장할 수 있습니다. 이러한 복잡한 프로세스는 빠르게 진보하는 기술적 환경에서 AWS Lambda의 모든 잠재력을 활용하는 데 중요합니다.\n\n## 참고 문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AWS Lambda Runtimes: AWS 문서\n- 람다에서의 Python 종속성 처리: AWS 지식 센터","ogImage":{"url":"/assets/img/2024-06-20-NavigatingRuntimeChangesinAWSLambdaMoreThanJustaSimpleTask_0.png"},"coverImage":"/assets/img/2024-06-20-NavigatingRuntimeChangesinAWSLambdaMoreThanJustaSimpleTask_0.png","tag":["Tech"],"readingTime":3},{"title":"TypeScript에서 Type과 Interface 중 어떤 것을 선택해야 할까요 상세 안내","description":"","date":"2024-06-20 01:33","slug":"2024-06-20-ChoosingBetweenTypeandInterfaceinTypeScriptADetailedGuide","content":"\n\nNode.js에서 TypeScript로 작업할 때, 종종 객체의 모양을 정의해야 합니다. 여기서 TypeScript의 타입과 인터페이스가 등장합니다. 두 가지 모두 객체의 구조를 설명하는 데 사용되지만, 어떤 것을 선택할지는 여러 요소에 따라 결정됩니다. 정보를 참고하여 신중한 결정을 내리는 데 도움이 되는 자세한 가이드가 여기 있습니다.\n\n## 1. 사용 의도\n\n- 인터페이스: 객체와 클래스의 구조를 정의하는 데 가장 적합합니다. 특정 형태에 대한 클래스나 객체의 준수를 보장하는 계약 역할을 합니다.\n- 타입: 기본 타입, 유니언 타입, 튜플 타입 및 더 복잡한 유형 표현에 대한 별칭을 만드는 데 이상적입니다.\n\n## 2. 확장성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인터페이스: extends 키워드를 사용하여 확장 가능합니다. 이 기능은 계층적이고 유연한 디자인을 지원하여 기존 인터페이스를 기반으로 새로운 인터페이스를 쉽게 만들 수 있습니다.\n- 타입: \u0026 연산자를 사용하여 교차 타입을 확장할 수 있습니다. 이는 여러 타입을 결합하여 하나의 타입으로 만듭니다.\n\n```js\ninterface User {\n    id: number;\n    username: string;\n    email: string;\n}\n\ninterface Admin extends User {\n    adminLevel: number;\n}\n```\n\n```js\ntype User = {\n    id: number;\n    username: string;\n    email: string;\n};\n\ntype Admin = User \u0026 {\n    adminLevel: number;\n};\n```\n\n## 3. 선언 병합\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인터페이스: 선언 병합을 지원합니다. 따라서 동일한 인터페이스를 여러 번 정의할 수 있으며 TypeScript에서 이를 단일 정의로 병합합니다.\n- 타입: 선언 병합을 지원하지 않습니다. 타입 별칭을 다시 정의하려고 하면 오류가 발생합니다.\n\n```js\ninterface User {\n    id: number;\n    username: string;\n}\n\ninterface User {\n    email: string;\n}\n\n// 병합된 User 인터페이스: { id: number; username: string; email: string; }\n```\n\n```js\ntype User = {\n    id: number;\n    username: string;\n};\n\ntype User = {\n    email: string;\n}; // 오류: 중복 식별자 'User'\n```\n\n## 4. 복잡한 유형\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 유형: 연합 유형, 교차 유형 또는 튜플과 같은 복잡한 유형을 정의하는 데 더 강력합니다.\n\n```js\ntype User = {\n    id: number;\n    username: string;\n    email: string;\n};\n\ntype ApiResponse = User | { error: string };\n```\n\n# 실제 예제\n\n- 인터페이스 예제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ninterface User {\n    id: number;\n    username: string;\n    email: string;\n}\n\nfunction getUserById(id: number): User {\n    return { id, username: \"john_doe\", email: \"john@example.com\" };\n}\n```\n\n유형 예시:\n\n```js\ntype User = {\n    id: number;\n    username: string;\n    email: string;\n};\n\nfunction getUserById(id: number): User {\n    return { id, username: \"john_doe\", email: \"john@example.com\" };\n}\n```\n\n# 각각을 사용하는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터페이스를 사용하는 경우:\n\n- 객체나 클래스의 모양을 정의할 때\n- 다른 유형에 의해 확장되거나 구현될 것으로 예상될 때\n- 선언 병합을 활용할 때\n\n타입을 사용하는 경우:\n\n- 복잡한 유형을 정의할 때 (예: 연합, 교차, 튜플)\n- 기본값, 연합 및 교차 유형을 위한 타입 별칭을 생성할 때\n- 타입 추론을 광범위하게 활용할 때\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nTypeScript에서 다양한 기능을 제공하는 type과 interface는 모두 중요한 도구입니다. 각각의 고유한 장점을 가지고 있습니다. interface는 객체 형태를 정의하고 확장성 및 선언 병합을 지원하는 데 뛰어나며, type은 복잡한 유형을 생성하고 TypeScript 강력한 유형 추론을 활용하는 데 우수합니다. 이러한 차이를 이해하면 더 견고하고 유지보수 가능하며 확장 가능한 TypeScript 코드를 작성하는 데 도움이 될 것입니다.\n\n구체적인 사용 사례를 기반으로 현명하게 선택하고 TypeScript의 유형 시스템의 모든 장점을 활용하려면 적절한 곳에 양쪽을 모두 사용하는 것이 좋습니다. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-20-ChoosingBetweenTypeandInterfaceinTypeScriptADetailedGuide_0.png"},"coverImage":"/assets/img/2024-06-20-ChoosingBetweenTypeandInterfaceinTypeScriptADetailedGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컴파일러가 거의 다 왔어요 정말 기대돼요","description":"","date":"2024-06-20 01:32","slug":"2024-06-20-ReactCompilerisalmosthereanditisExciting","content":"\n\nMeet Jay, he is a budding Frontend Engineer and has been working with React for a few months. Recently, he raised a Pull Request where he is fetching a list of todos and displaying it on the UI —\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png)\n\nBut Wait… His PR does not get approved!\n\n![image](/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_2.png\" /\u003e\n\n만나요! Ray는 프론트엔드 리드입니다. 그는 그의 경험을 바탕으로 Jay가 할 일 목록을 조작하고 있고 이 목록이 매우 커질 수 있다는 것을 알아챘어요 (10,000개 이상). 그래서 그는 Jay에게 React에서 제공하는 훅을 사용하여 함수를 메모이즈하는 것을 권유했어요. 그렇게 하면 의존성(dependencies)이 변경될 때에만 함수가 호출되도록 할 수 있어요. 우리가 이야기하고 있는 훅은 useMemo()입니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_3.png\" /\u003e\n\nJay는 Ray의 조언을 따라 했지만, 여기서 몇 가지 더 코멘트가 있어요. 어떤 경우에는 여러 개의 콜백이 자식 컴포넌트로 전달되고 있어요. Ray는 Jay에게 useCallback()을 사용하여 이러한 함수들의 참조(reference)를 보존하여 각 리렌더링마다 자식 컴포넌트를 메모이즈하고 그들의 리렌더링을 멈출 수 있도록 하는 것을 요청했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업의 반은 끝났어요! 이제 비싼 자식 구성 요소들을 memo() 훅으로 감싸서 다시 렌더링을 막아야 해요.\n\n마음을 바꿔보면, 팀은 이 문제가 손에 잡히질 않아서 지금까지 위 훅들을 사용하여 오버엔지니어링을 한 부분이 많은 것 같아요. 실제로 성능 문제가 크게 발생한 것은 아니었는데, 누군가가 이런 베스트 프랙티스를 읽고, 성능을 분석하지 않고 사용해버린 결과이죠.\n\n어쨌든, 이런 대화와 React 앱을 더 최적화하기 위해 이러한 매개변수들을 추가하는 머릿 속 부담감은 피곤하고 React의 본래 이념과는 거리가 있는데요 -\n\nUI는 상태의 함수입니다... 확실히 이게 더 세밀하고 복잡한 문제이고, 우리는 방금 목격한 것처럼 말이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기에는 🚀 즉, REACT 컴파일러가 등장합니다\n\n# 2막 — REACT 컴파일러 소개\n\nReact 컴파일러는 React가 개발자 경험을 향상시키기 위해 가져오는 미래 기술입니다. 이름보다는 다소 온화해 보일 수 있지만, 이것은 게임 체인저입니다.\n\n컴파일러 뒤에 숨은 아이디어는 대부분의 메모이제이션 논리를 React에게 위임하고 과도하게 복잡한 useMemo 및 useCallback 훅을 줄여서 코드베이스를 가독성 있게 만드는 것입니다. 이러한 훅들의 종속성은 많은 사람들에게 고통의 요점이기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트에서 이와 같은 지원을 받기 위한 작업은 상당한 시간동안 진행되어 왔습니다. 2021년 Xuan의 이번 토크를 확인해보세요 —\n\n다음은 간단한 카운터 예제인 다음 코드 조각을 고려해 봅시다 —\n\n```js\nexport default function Counter({initialCount}) {\n  const [count, setCount] = useState(initialCount);\n\n  return (\n    \u003c\u003e\n      \u003cdiv className=\"flex gap-1 justify-center items-center\"\u003e\n        \u003cbutton\n          onClick={() =\u003e {\n            setCount(count + 1);\n          }\n        \u003e\n          +\n        \u003c/button\u003e\n      \u003c/div\u003e\n\n      \u003cspan\u003e\n        {count}\n      \u003c/span\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n리액트 컴파일러에 의해 컴파일된 이 코드를 사용하여 상황을 확인할 수도 있습니다 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction Counter(t0) {\n  const $ = _c(2);\n\n  const { initialCount } = t0;\n  const [count, setCount] = useState(initialCount);\n  let t1;\n\n  if ($[0] !== count) {\n    t1 = (\n      \u003c\u003e\n        \u003cdiv className=\"flex gap-1 justify-center items-center\"\u003e\n          \u003cbutton\n            onClick={() =\u003e {\n              setCount(count + 1);\n            }\n          \u003e\n            +\n          \u003c/button\u003e\n        \u003c/div\u003e\n        \u003cspan\u003e{count}\u003c/span\u003e\n      \u003c/\u003e\n    );\n    $[0] = count;\n    $[1] = t1;\n  } else {\n    t1 = $[1];\n  }\n\n  return t1;\n}\n```\n\n여기서 $는 props, state 및 다른 반응적인 정보의 데이터를 보관하는 변수이며, 잠재적인 다시 렌더링에서 비교하고 부모 구성 요소 또는 상태 변경이 있을 때, 그 정보가 변경된 것이 없다면... 바로! 컴포넌트 다시 렌더링이 저장됩니다!\n\n_c는 여기에서 실제 리액트 컴파일러 훅이며 useMemoCache()라고도 불리며 우리가 보았던 바와 같이 useMemo() 네이티브 훅과는 다르게 작동합니다.\n\n그래서 간단히 말해서, Dan Abramov의 말로 하면, 리액트 컴파일러는 본질적으로 이것입니다 —\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet jsx;\n\nif(prevCount != count){\n  jsx = ...\n} else {\n  jsx = prevJsx;\n}\n```\n\n아래는 이것이 큰 개선될 상황 몇 가지 예시입니다 —\n\n- 우리는 DOM 노드의 tree, 즉 React Fiber 또는 Virtual DOM을 알고 있습니다. 부모 컴포넌트가 렌더링될 때 전체 서브트리/자식 컴포넌트가 다시 렌더링 됩니다. React 컴파일러는 변경 사항이 없는 경우 그것을 회피해주고, 의존할 props가 없더라도 도움을 줄 것입니다.\n- useMemo() 훅의 경우 대부분의 경우에는 필요하지 않을 것이며, React 컴파일러가 적절하게 캐싱을 할 수 없는 경우에만 필요할 것입니다. 이 경우 오리지널 컴파일러 구현체로 되돌아갈 것입니다. 이를 잘못 사용했을 때 useMemo() 훅의 예시가 될 수 있습니다.\n\n# 제 ACT III: 지나치게 복잡한 최적화가 끝나는 시작\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n드디어 React에도 다른 대부분의 라이브러리에서 사용하던 컴파일러가 도입되고 있습니다. 이로 인해 날이 갈수록 React 코드를 작성할 때 \"만약 이 부분이 변경된다면?\", \"이 함수가 성능에 해를 끼칠까?\"라는 걱정을 덜어내고 코드를 작성할 수 있게 되었습니다.\n\nReact 팀에게 👏 이를 위해 수년간 반복적이고 꾸준한 노력을 기욯 합니다. 재미있는 사실: 컴파일러를 도입하고자 한 목표가 후크(hook)와 서버 컴포넌트(Server components)를 탄생시켰습니다.\n\n컴포넌트를 이주할 준비가 되어 있는지 확인하려면 추천사항은 아니지만 React 팀의 React 컴파일러 소개 페이지(https://react.dev/learn/react-compiler#existing-projects)를 참조할 수 있습니다. 더 깊이 살펴볼 수 있는 유용한 리소스 몇 가지를 소개해 드리겠습니다 -\n- https://www.youtube.com/watch?v=PYHBHK37xlE\n- https://jherr2020.medium.com/react-compiler-with-react-18-1e39f60ae71a\n- https://www.youtube.com/watch?v=wnXGSwrOw80\n- https://www.youtube.com/watch?v=0ckOUBiuxVY\u0026t=9311s [React 컴파일러 부분을 확인할 수 있습니다]","ogImage":{"url":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png"},"coverImage":"/assets/img/2024-06-20-ReactCompilerisalmosthereanditisExciting_0.png","tag":["Tech"],"readingTime":5},{"title":"CommonJS와 ES 모듈이 드디어 서로 호환될 예정입니다","description":"","date":"2024-06-20 01:30","slug":"2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther","content":"\n\n\n![이미지](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png)\n\nECMAScript 모듈은 현대 JavaScript 개발에서 인정받는 산업 표준이 되어가고 있습니다. ESM이 Node.js에 소개된 이후 비동기 로딩 기능과 모듈 해결 논리가 잘 받아들여졌습니다.\n\n그러나 역사적인 이유로 많은 기존 코드베이스와 타사 라이브러리는 여전히 CommonJS 모듈 시스템에 의존하고 있습니다. ESM의 비동기 로딩 설계로 인해 이 두 모듈화 체계가 아직 공존할 수 없었는데, 이는 많은 개발자들에게 주요 고통 요인이 되었습니다.\n\n최근 joyeecheung 님이 이 문제를 해결하기 위한 중요한 Pull Request를 제출했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_1.png\"/\u003e\n\n## CJS와 ESM의 과거와 현재\n\n자바스크립트의 세계에서 모듈화는 대규모 애플리케이션을 구축하는 데 필수적입니다. 모듈화는 글로벌 네임스페이스에 영향을 미치지 않고 코드를 관리하는 데 도움이 되며, 기능을 분리하고 코드를 재사용하며 의존성을 관리하기 쉽게 합니다. Node.js와 브라우저 환경 모두에서는 CommonJS (CJS)와 ECMAScript Module (ESM)이라는 두 가지 주류 모듈 시스템이 있습니다.\n\nCommonJS는 Node.js에서 네이티브로 지원되는 모듈 시스템으로, 초기에 서버 측 모듈화 요구를 충족하기 위해 도입되었습니다. CJS는 require 함수를 사용하여 모듈을 로드하고 module.exports 또는 exports 객체를 사용하여 코드를 모듈로 노출합니다. CommonJS 모듈의 특징은 동기적으로 로딩되는 것으로, 모듈이 로드된 후 즉시 코드가 실행된다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// math.js\nfunction add(x, y) {\n  return x + y;\n}\nmodule.exports = { add };\n\n// app.js\nconst math = require('./math.js');\nconsole.log(math.add(0, 17)); // 17을 출력합니다\n```\n\n서버 환경에서는 대부분 파일이 로컬이기 때문에 동기적으로 로딩되어도 문제가 되지 않습니다. 그러나 브라우저 환경에서는 동기적 로딩이 브라우저의 이벤트 루프가 스크립트를 완전히 다운로드하고 구문 분석할 때까지 블로킹되어 성능 문제를 일으킬 수 있습니다.\n\nESM은 최신 JavaScript의 공식 표준 모듈 시스템이며, 최신 브라우저의 버전에서 네이티브로 지원됩니다. CommonJS와 달리 ESM은 동적으로 모듈을 로드하거나 생성할 수 없도록 디자인되어 정적입니다. ESM은 import 및 export 문을 사용하여 모듈을 가져오고 내보내는데, 비동기적 로딩을 지원합니다:\n\n```js\n// math.js\nexport function add(x, y) {\n  return x + y;\n}\n\n// app.js\nimport { add } from './math.js';\nconsole.log(add(0, 17)); // 17을 출력합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nESM을 Node.js에서 활성화하려면 보다 복잡한 방법을 요구합니다. 이는 .js 파일 확장자가 기본적으로 CommonJS 모듈과 연관되기 때문입니다. 이 문제를 해결하기 위해 Node.js는 .mjs 파일 확장자를 사용하거나 package.json에서 명시적으로 \"type\": \"module\" 속성을 지정하여 ESM 모듘임을 나타낼 수 있습니다.\n\nNode.js에서 ESM이 지원되기 때문에 cjs를 가져올 수 있지만 require(esm)는 불가능합니다. ERR_REQUIRE_ESM으로 인한 당혹감은 많은 사용자들을 괴롭히며 Node.js 생태계 내에서 시간 낭비의 주요 원인이 될 수 있습니다.\n\n![Commonjs and ESM Module Compatibility](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 패키지 제작자들이 CJS와 ESM 사용자 모두가 그들의 패키지를 사용할 수 있도록 보장하고 싶다면, 그들은 모듈을 계속 CJS로 출판하거나 CJS와 ESM 둘 다를 릴리스하는 이중 모듈로 출시하여야 합니다 (일부 문제를 발생시킬 수 있지만, 이는 지금 매우 흔한 실천법입니다).\n\n동시에, 많은 트랜스파일러 (예: TypeScript 컴파일러)는 아직도 최종 출력물로 CJS 코드를 생성하도록 구성되어 있습니다. 이러한 트랜스파일러의 사용자들은 ESM 구문을 사용하여 코드를 작성하지만, 그들의 코드가 최종적으로 Node.js에서 CJS로 실행된다는 것을 필요로 알지 않을 수 있습니다. 그들의 코드가 실제로 require할 수 없는 진짜 ESM 써드파티 모듈을 사용하면, ERR_REQUIRE_ESM을 볼 수 있습니다. 이는 그들이 그들의 코드가 진정한 ESM으로 실행되고 있다고 가정하기 때문에 매우 혼란스러울 수 있습니다.\n\n## 왜 호환되지 않을까요?\n\n당연히 사람들은 다음과 같이 물을 수 있습니다: 왜 require()가 ESM 로딩을 지원하지 않을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오랜 시간 동안 Node.js 프로젝트의 응답은 항상 이와 같았습니다:\n\n하지만 여기서는 문서와 다른 형태의 커뮤니케이션이 오해를 일으킬 수 있는 상황입니다 — 아마도 그들은 Node.js ESM에서 발생하는 일에 대해 이야기하고 있을 뿐이며, ESM 자체가 어떻게 설계되었는지에 대해서는 언급하지 않은 것일 수도 있습니다. 지난 해, joyeecheung이 메모리 누수 문제를 해결하기 위해 V8 코드를 읽다가 ESM 자체가 절대적으로 비동기적으로 설계된 것이 아니라 조건적으로 비동기적으로 설계된 것을 우연히 발견했습니다. 즉, 코드에 최상위 await가 있는 경우에만 비동기적으로 동작하도록 설계되었습니다.\n\n따라서, 최상위 await를 포함하지 않는 ESM에 대한 require()를 지원하는 데는 아무 문제가 없습니다. 최상위 await를 사용해야 하는 유효한 이유가 있는 라이브러리도 있겠지만, 그렇게 흔한 일은 아닐 수도 있습니다.\n\n실제로, joyeecheung이 후에 npm 레지스트리에서 ESM을 지원하기 위해 (esm)을 요구하는 약 30개의 패키지를 테스트한 결과, 아무도 최상위 await를 포함하지 않았습니다 — 그리고 require()에서 동기 모듈을 지원하는 것이 이미 생태계에서 많은 머리아픔을 해결할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 초기 탐험 및 시도\n\nESM 지원은 긴 토론, 디자인 및 실험을 거쳤습니다. 2019년부터 Node.js 커뮤니티는 ESM과 CommonJS 간의 상호 운용성을 지원하는 방법을 탐색하기 시작했습니다. 이 기간 동안 많은 개발자들이 서로 다른 구현 솔루션과 개선 조치를 제안하는 Pull Request를 제출했습니다.\n\n당시, 중대한 PR 토론은 Node.js에서 .mjs 확장자를 가진 파일을 지원하는 방법과 동시에 CommonJS와 ESM을 지원할 수 있는 이중 모듈 시스템을 구현하는 데 초점을 맞추었습니다.\n\n![image](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 풀 리퀘스트는 상위 수준 대기를 처리하기 위해 로더에서 이벤트를 루핑하는 시도를 했지만, 그 방법이 안전하지 않아서 닫혔습니다.\n\n명세에 따르면, 구문 기반 ESM 동기 평가의 이론적 기초가 2019년에 확립되었습니다. 시간이 흐를수록 Node.js 내에서 \"ESM이 비동기적이고 CJS가 동기적이기 때문에 CJS는 ESM을 로드할 수 없다\"는 신화가 형성된 것으로 보입니다. 그러나 표준 기관에서는 ES 명세가 ESM이 조건부로 비동기적임을 명확히 보장하고 있습니다. W3C 명세는 Service Worker가 동기식 모듈 평가만 허용하도록 보장하기 위해 이를 사용합니다. 만약 2019년 이후 명세에 기반한 동기화가 보다 광범위하게 인식되면, 더 많은 시도가 있을 수 있으며 문서는 ESM을 무조건적으로 비동기로 설명하지 않을 것입니다.\n\n## 동기 require(esm) 지원\n\n작년 말에 joyeecheung은 문법에 따르면 ESM이 동기적일 수 있음을 발견하였으며, 오징어는 로딩 프로세스에 비동기성을 도입한 것은 오직 Node.js 뿐이라고 언급했습니다. 따라서, joyeecheung과 GeoffreyBooth는 동기 require(esm)를 다시 시작하기로 논의를 시작했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2024년 2월 말, joyeecheung은 CJS와 ESM 로더에 대해 캐싱과 유사한 작업을 수행하면서 더 깊이 파고들었을 때, \"Node.js에서 ESM 로더를 유일한 로더로 만드는 것을 포기하고 CJS 로더를 지원하는 별도의 프로그램을 구현하자\"는 더 간단한 방법이 있다는 것을 알게 되었습니다. 기존 ESM 로더 코드를 최소화할수록 구현이 더 쉬워지는 것 같았죠.\n\n그렇게해서 이 PR이 생성되었습니다.\n\nhttps://github.com/nodejs/node/pull/51977\n\n2019년 PR과의 주요 차이점은 이 PR이 require(esm)의 범위를 작게 유지하고 동기적으로 ESM을 로드하는 것만 지원하려고 한다는 것입니다. 기술 지도위원회(TSC)에서는 이것이 전혀 논란이되지 않았고, 크게 반박도 받지 않았다고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![](/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_4.png)\n\n현재, 이 기능은 여전히 실험 단계로 진행 중이며 실험적으로-require-module 플래그 아래에서 작업을 완료해야 합니다.\n\n현재, require(esm)은 명시적으로 .mjs 확장자를 통해 또는 .js 확장자에 “type”: “module” 패키지 필드를 사용하여 ESM으로 표시된 ESM 모듈만 지원합니다. 이는 npm에서 ESM-only 패키지를로드하는 데 충분합니다. .js 파일에 ESM 구문이 포함되어 있지만 가장 가까운 package.json에 “type”: “module” 필드가 없는 경우 .js 파일이 ESM로드로 “fallback”할 수 있지만, 이를 일반적으로 사용자가 피해야 할 사항입니다. ESM 구문 감지는 오버헤드를 유발하며 프로젝트에 충분한 ESM 모듈이 있을 때 노드.js가 모듈 유형을 추측하는 데 시간을 낭비하고 싶지 않을 수 있습니다. 특히, package.json에 명시적인 “type”: “module” 필드를 사용하여 이러한 오버헤드를 저장할 수 있습니다.\n\n## 마침내\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정직히 말해서, 이 문제는 오랜 시간 동안 나를 괴롭혔어요. 많은 NPM 패키지 개발자들도 이런 문제로 고통을 겪고 있어요. 이번 joyeecheung의 시도가 가능한 한 빨리 제품으로 출시되기를 바랍니다!","ogImage":{"url":"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png"},"coverImage":"/assets/img/2024-06-20-CommonjsandESModuleAreFinallyGoingtoBeCompatiblewithEachOther_0.png","tag":["Tech"],"readingTime":6},{"title":"마이크로 프론트엔드의 미래","description":"","date":"2024-06-20 01:27","slug":"2024-06-20-TheFutureofMicroFrontends","content":"\n\n## 나는 이 퍼즐의 빠진 조각이 무엇인지 이해하고, 이 아키텍처 접근 방식을 더 개선할 수 있는 방법을 상상해 봐야겠어요\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png)\n\n2021년 말부터 2022년 초까지, 나는 미니 프론트엔드 여정이 현재까지 어디까지 왔는지 살펴보았어요.\n팀이 고민하는 다양한 도전 과제, 장기적으로 결합을 일으키는 안티 패턴, 그리고 이를 해결하기 위해 사용되는 반복 패턴들을 분석했어요.\n\n우리는 미니 프론트엔드가 팀이 독립적으로 작업하고 중대형 규모 애플리케이션에 기여하도록 가능하게 했으며, 우리의 애플리케이션을 진화시키며 잠재적인 문제의 영향 범위를 줄이는 방식을 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 현재까지 이룩한 것으로 분석이 끝나지 않았어요.\n\n나는 앞으로 나아가야 했어요, 미래로 한 발짝 내딛어.\n\n이 흥미로운 퍼즐의 빠진 조각들이 무엇인지 이해해야 하고, 이 아키텍처 접근 방법을 더욱 개선할 수 있는 방안을 상상해 봐야 했어요.\n\n이 글에서는 마이크로 프론트엔드 커뮤니티에서 흥미로운 대화를 일으킬 수도 있는 아이디어와 트렌드를 공유하고 싶어요. 다루는 주제는 이 아키텍처의 클라이언트 측, 서버 측, 그리고 엣지 측 구현을 고려하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 2022년에 저의 초점이 될 마이크로 프론트엔드 생태계에 대해 공유하려고 합니다.\n\n# 보다 철저한 디자인\n\n마이크로 프론트엔드 아키텍처의 주요 과제 중 하나는 \"마이크로\"가 얼마나 되어야 하는지에 대한 질문에 대답하는 것입니다.\n\n이 질문에 직면하는 많은 조직이 있습니다. 실제로, 하나의 답변만 있는 것이 아니라, 맥락, 조직 구조와 규모, 그리고 팀 간의 커뮤니케이션 흐름을 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 팀이 분산 아키텍처에 대해 여러 차례 소통한 후에 저는 '분산 컴포넌트'가 '마이크로 프론트엔드' 구현보다 더 많이 나타났다는 것을 많이 보았어요.\n\n분산 컴포넌트를 사용하면 도메인 지식이 컨테이너와 '마이크로 프론트엔드' 또는 컨테이너와 여러 '마이크로 프론트엔드' 사이에 공유되었어요.\n\n우리는 여전히 올바른 경계를 찾기 어려워하고 때로는 구현할 때 마이크로 프론트엔드를 어떻게 해석해야 하는지에 대한 이해가 부족한 경우가 있어요.\n\n저는 이해가 성숙해지는 방향으로 나아가는 필수적인 단계라고 생각해요. 응용 프로그램 비즈니스 하위 도메인을 정복하는 것은 쉬운 작업이 아니며 빌드하는 응용 프로그램에 대한 심층적인 지식이 필요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 이 문제를 완화할 잠재적인 해결책이 있다고 생각합니다.\n\n사용자 경험을 저해하지 않으면서 비즈니스 도메인을 어떻게 분리할지 여러 부서와 함께 화이트보드를 통해 더 많은 시간을 투자하는 것이 중요합니다.\n\n이러한 회의를 마칠 때 우리는 프로젝트를 자신 있게 시작하고 처음에 설정한 전제가 목표를 달성하는 데 여전히 유효한지 확인하기 위해 우리의 결정을 지속적으로 검토할 수 있어야 합니다.\n\n모든 것을 처음부터 포착할 수는 없다는 것을 기억해야 합니다. 비즈니스와 조직은 6개월 또는 12개월 후에 변할 수 있으므로 정기적으로 우리의 마이크로 프론트엔드 경계를 다시 검토해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 조직 구조와 소프트웨어 아키텍처 간의 연결 링크를 잊지 마세요. 이를 인식하고 설계 결정에 고려하는 것이 중요합니다.\n\n# 마이크로 프론트엔드 통신\n\n같은 뷰에서 여러 마이크로 프론트엔드를 가지고 있을 때, 어느 순간에는 서로 통신해야 합니다.\n\n저가 마이크로 프론트엔드를 설계하기 위해 만든 정신 모델에서는, 마이크로 프론트엔드 간의 통신을 촉진하기 위해 게시-구독 패턴을 사용하는 것이 권장됩니다. 이는 마이크로 프론트엔드 간의 경계를 강화하고, 디자인 시점 결합을 피하거나 최소화하여 더 자율적인 팀을 이끄는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기술적으로 이 패턴을 구현하는 데는 사용자 정의 이벤트, 이벤트 에미터 라이브러리 또는 반응형 스트림과 같은 여러 옵션이 있습니다.\n\n지난 몇 달 동안 중요한 요구 사항이 나왔는데, 처음에는 그다지 강조하지 않은 것 같습니다. 아마 당연시 여겼기 때문일 것 같아요, 그러나 분명히 주의해야 할 부분입니다.\n\n백엔드에서 이벤트 주도 아키텍처와 마찬가지로, 이벤트에 대한 명확한 스키마를 갖는 것은 통합 단계에서 실수를 피하는 데 도움이 됩니다. 더불어 스키마는 코드베이스에 직접 작업하지 않는 기술 직군들에게도 특정 애플리케이션 내에서 무슨 일이 일어나고 있는지 명확히 이해할 수 있도록 돕습니다.\n\n내가 팔로우하는 많은 Slack 채널 중 하나에서 발견한, 느슨하게 결합된 요소 간(마이크로 프론트엔드뿐만 아니라) 보다 구조화된 커뮤니케이션을 달성하는 데 도움이 되는 이 이벤트 버스 라이브러리가 있습니다: [링크](https://www.npmjs.com/package/@trutoo/event-bus).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_1.png)\n\n마이크로 프론트엔드는 분산 아키텍처이기 때문에 더 형식적인 API나 이벤트 관리가 필요합니다.\n\nAPI나 이벤트는 팀이 상호 작용하는 방법입니다. 마이크로 프론트엔드뿐만 아니라 중요합니다. \n이러한 사례들은 이벤트가 전송될 때 개발자가 실수를 피할 뿐만 아니라 팀 간 토론을 용이하게 하고 의도를 명확히 하는 데 도움이 됩니다.\n\n미래에는 잘 연결된 통신 전략을 대규모로 사용하는 대규모 애플리케이션에서 개발자 경험을 더 간단하게 만드는 데 더 많은 노력이 기울여졌으면 좋겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 새로운 마이크로 프런트엔드 간 상호 작용을 개발할 때마다 참고할 수 있는 이벤트 레지스트리가 있다면 얼마나 좋을까요?\n\n마이크로 프런트엔드 간 통신에 대해 PayPal이 무엇을 하고 있는지 아직 확인해보지 못했다면, 이 멋진 비디오를 꼭 시청하도록 권장드립니다!\n\n# 서버 측 렌더링 (SSR)\n\n서버 측 렌더링 아키텍처는 지난 몇 달 동안 혁신을 이루고 있는데, Next.js나 React 18 팀이 서버 구성 요소에 투자한 것을 생각해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 Next.js, Piral, TailorX, ILC 등의 마이크로 프론트엔드에 대한 흥미로운 솔루션도 갖고 있어요.\n\nSSR 마이크로 프론트엔드 애플리케이션에 대해 더 자세히 살펴봐야 할 몇 가지 주제가 있어요.\n\n지금까지 발견한 공백은 다음과 같아요:\n\n- 마이크로 프론트엔드 검색: 마이크로서비스를 위한 서비스 검색 패턴과 유사하지만 프론트엔드에 적용된 것입니다. 이 패턴을 사용하면 시스템의 엔드포인트에 대한 정적 참조없이 동적으로 마이크로 프론트엔드를 구성할 수 있어요. 마이크로 프론트엔드 인프라가 검색 서비스에 자체 등록되고 UI 컴포저가 마이크로 프론트엔드 자체보다는 검색 서비스에서 마이크로 프론트엔드를 검색할 수 있다면 어떨까요? 🤯\n- 클라우드에서의 참조 아키텍처: 인기 있는 클라우드 제공업체를 사용하여 SSR 마이크로 프론트엔드 아키텍처를 구축하는 방법에 대한 지침이 부족합니다. 이는 비교적 빨리 해결할 수 있는 마찰점이며 최대한 도와드리고 싶어요.\n- 마이크로 프론트엔드에서 서버리스 패러다임 활용하기: 서버리스가 인프라 관리를 클라우드 제공업체에 위임하여 개발 속도를 높일 수 있다고 믿어요. 동시에 우리는 어떤 서비스를 특정 워크로드에 활용해야 하는지 이해하는 마인드셋을 가져야 해요. 예를 들어, AWS Step Functions와 같은 서비스를 사용하여 마이크로 프론트엔드의 생성을 단순화하는 가치를 보고 있습니다. AWS 생태계 전체와의 통합이 훌륭하기 때문에 저희는 오랜 기간에 걸쳐 유지보수를 단순화할 수 있는 로우코드 모델을 채택할 수 있어요.\n이것은 클라우드에서 사용할 수 있는 많은 패턴 중 하나이며, 마이크로 프론트엔드와 함께 이러한 패턴을 탐색하는 것은 매우 매혹적일 수 있어요 (적어도 제겐).\n\n- 프레임워크에 중립적인 React 서버 컴포넌트 접근 방식: 백엔드 데이터가 변경될 때 뷰의 일부를 서버사이드 렌더링을 통해 원자적으로 다시로드하고 클라이언트 마이크로 프론트엔드와 시티 파트를 연결하는 메커니즘이 있는 것이 좋아요. 이를 통해 CSR과 SSR을 혼합하는 하이브리드 아키텍처를 사용하여 모든 마이크로 프론트엔드에 대해 올바른 접근 방식을 사용할 수 있을 거예요. 아마도 우리는 오늘 이러한 메커니즘을 만들어낼 수 있겠지만, React 18처럼 매끄러운 구현을 갖게 되는 것이 최종 목표일 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 보시는 것처럼, 저희 앞에 많은 기회가 있습니다. 몇 가지는 더 구체적인 기회인 레퍼런스 아키텍처 같은 것이 있고, 어떤 것은 보다 장기적인 시각에 있는 React 서버 컴포넌트 접근 방식 같은 것도 있습니다.\n이 목록 중에서 저의 초점은 레퍼런스 아키텍처 및 서버리스 패러다임을 이용한 마이크로 프론트엔드에 대한 조사에 있을 것입니다. 이미 레퍼런스 아키텍처에 대한 프로토타입 작업을 시작했고, 서버리스 측면에서도 몇 가지 흥미로운 프로토타입이 있습니다. 계속해서 업데이트를 기대해 주세요.\n\n# 부분 수화\n\n성능은 모든 프론트엔드 응용프로그램에 중요한 요소입니다. 마이크로 프론트엔드를 포함한 모든 것에 대한 것입니다. \"아일랜드 아키텍처\" 개념에 대해 들은 지 어느 정도 시간이 지났습니다. 그러나 이 아키텍처는 원칙과 특성 때문에 마이크로 프론트엔드 범주에 속할 수 있다고 믿습니다.\n\n아일랜드 아키텍처가 소개한 흥미로운 기술은 부분 수화를 통해 서버 측 렌더링 응용프로그램의 성능을 향상시킬 수 있는 가능성을 제시한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부분 수분화는 새로운 기술이 아니며, 2019년 이후로 사용 가능합니다(기억이 맞다면). 그러나 나는 마이크로 프론트엔드 응용 프로그램에서 이 기술에 대한 어떠한 언급도 보지 못했습니다.\n\n마이크로 프론트엔드의 성격과 부분 수분화의 작동 방식을 고려할 때, 이 기술이 SSR 마이크로 프론트엔드 응용 프로그램을 더욱 최적화하는 데 더 많은 인기를 얻어야 한다고 생각합니다.\n\n이 게시물에서 Addy Osmani는 이 개념을 더 잘 이해할 수 있는 유용한 리소스를 제공합니다:\n\n마지막으로, 만약 이 주제에 관심이 있다면, 부분 수분화를 사용할 수 있는 UI 프레임워크 목록이 포함된 이 게시물을 읽어보는 것을 적극 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 현재 Preact를 사용하여 마이크로프론트엔드 Proof of Concept를 실험 중입니다. 곧 더 많은 통찰을 공유할 수 있기를 희망합니다.\n\n# 마이크로프론트엔드와 엣지 컴퓨팅\n\n마이크로프론트엔드와 엣지에 대해 이야기할 때 자주 Edge-Side Includes (ESI) 마크업 언어를 생각합니다.\n\n이번에는 AWS Lambda at the edge나 Cloudflare workers와 같은 많은 CDN에서 제공하는 컴퓨팅 기능을 가리키고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최신 기술들이 빠르게 발전하고 있기 때문에 응용 프로그램의 일부분을 엣지로 옮길 수 있어 지연 시간과 솔루션의 확장성을 향상시킬 수 있습니다.\n\n그러나 많은 웹 애플리케이션에서는 여러 개의 마이크로 프론트엔드를 사용하여 HTML 페이지를 생성하는 계산 노력만을 고려할 수는 없으며 전체 애플리케이션의 복잡성도 고려해야 합니다.\n\n현재 계산 문제는 해결하기 \"쉬운\" 문제가 되었지만, 데이터 중력(데이터베이스, 다중 지역 데이터 복제, 글로벌 인프라에서의 쓰기 대 읽기, 데이터 복제 지연 등) 또는 일반적으로 중앙 집중화되고 안전한 인증(클라우드 인프라의 특정 지역이나 온프레미스 데이터 센터)과 같은 문제는 그렇지 않습니다.\n\nSSR 마이크로 프론트엔드 애플리케이션은 엣지 컴퓨팅에서 이점을 얻을 수 있지만, 아직 완전히 엣지에서 사용할 수 없는 기타 리소스(데이터, 인증, 캐시 등)에 액세스해야 합니다.\n외부 종속성이 전혀 필요하지 않은 매우 잘 캡슐화된 워크로드가 있는 경우가 아니라면 엣지의 전체 성능을 이용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래에는 엣지 기술의 채택이 더 많아질 것 같아요. 그런데 동시에 '멋지다'는 이유만으로가 아닌, 엣지 기술이 어떻게 실제 업무에 영향을 미칠 수 있는지 더 잘 이해해야 한다고 생각해요. 엣지 노드와 함께 작업하는데, \"하이프 주도 개발 anyone?\" 같은 용어는 크게 듣고 싶지 않을 거예요.\n\n내 의견으로는 엣지 컴퓨팅이 미래에는 마이크로 프론트엔드에 많은 영향을 미치고, 특히 응용 프로그램의 성능을 향상시키는 데 중요하다고 생각해요. 그러나 현재보다 그렇게 쉽지 않을 거에요.\n\n# 배포\n\n마이크로서비스에서는 특성 플래그, 블루-그린 배포, 카나리아 출시와 같은 새로운 마이크로서비스 버전의 배포를 위한 안전한 실천 방법이 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 12개월 동안, 저는 마이크로 프론트엔드에 유사한 기법을 구현하기 위한 노력을 볼 수 없었어요. 기능 플래그 이외의 것들은 많은 팀에서 잘 알려진 패턴으로 보입니다.\n\n개발 팀에 신뢰감을 주는 배포 전략이 반드시 필요하다고 생각해요.\n\n분산 시스템에서는 종종 지속적인 배포가 현실이기 때문에, 개발자들이 코드를 빠르게 반복하며 랩톱에서 프로덕션 환경으로 이동시키는 동안 모든 사용자에 의해 경험되는 버그를 도입할 위험이 없도록 안전망을 만들어야 해요.\n\nSSR(서버 측 렌더링) 마이크로 프론트엔드의 경우, 기존 도구와 관행을 쉽게 재활용할 수 있으며, 이러한 메커니즘 중 하나를 활용하여 인프라를 출시하는 데 사용할 수 있어요. 그러나 클라이언트 측 렌더링 마이크로 프론트엔드 애플리케이션에는 종종 이러한 전략이 수용되지 않는 경우가 많습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 그것들을 구현할 수 있는 여러 가지 방법이 있습니다, 클라이언트 측, 서버 측 또는 심지어 엣지에서도요.\n\n제 추천은 가능한 한 빨리 이러한 전략 중 하나를 구현하는 것입니다. 그것들은 당신의 팀에 대한 안전한 환경을 만들어주고 결과가 놀라울 수도 있습니다... 긍정적으로요.\n\n# 라우팅\n\n배포 전략과 엄격하게 연관된 것으로, 클라이언트 측 렌더링 마이크로 프론트엔드 응용 프로그램은 견고한 라우팅 전략이 부족합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 구현은 단일체 아키텍처를 구현하는 데 사용하는 라우팅 라이브러리를 사용하고 있습니다.\n\n대신, 우리는 이것보다 더 잘할 수 있다고 믿습니다!\n\n이전에 설명한 배포 전략과 함께 라우팅 라이브러리를 혼합하면 더 똑똑한 라우팅을 구현할 수 있습니다. 이를 통해 더 신규한 마이크로프론트엔드 버전, 다양한 환경 또는 사용자 역할을 고려할 수 있습니다.\n\n또한 트래픽을 점진적으로 증가시키고 버전에 대한 롤백을 수행하는 도구도 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, AWS에서 컨테이너 또는 서버리스 워크로드를 개발할 때 선호하는 배포 전략을 몇 줄의 구성으로 쉽게 설정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-TheFutureofMicroFrontends_2.png)\n\n애플리케이션 쉘의 라우팅은 외부 JSON을 통해 쉽게 조정할 수 있으며, 응용프로그램 로직에 이 정보를 통합할 필요가 없이 가능한 다양한 옵션을 제공합니다.\n\n마지막으로, 이 정적 JSON이 배포 로직과 결합될 때, 새 버전의 위험을 줄이고 비즈니스가 구현하고자 하는 로직에 따라 동적 설정이 가능해져서 많은 가치를 제공할 수 있다고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우팅과 배포는 제가 흥미를 느끼는 분야입니다. 다음 몇 달 동안 시간을 투자하여 일반적인 번거로움을 없애고 팀이 배포 및 라우팅을 더 잘 제어할 수 있게 하려고 합니다. 이 두 주제에 대해 매우 흥분하고 있는 작업 그룹 때문에 가능한 한 빨리 제가 진행 중인 작업을 공유할 수 있기를 희망합니다 🚀\n\n# 마이크로 프론트엔드 관리\n\n아직 이 영역을 탐험하지는 않았지만, 마이크로 프론트엔드의 PROs와 CONs를 이해하기 위해 시도할 도구 목록을 가지고 있습니다.\n\n제 주요 관심사는 모노 레포에 중점을 두는 것입니다. 제 생각에는 다른 프로젝트가 같은 저장소에 독립적으로 존재할 때와 같이 코드를 관리하는 추가 도구가 필요하지 않습니다. 현재 제 관심을 끄는 도구 목록은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Turborepo\n- PNPM\n- Projen\n\n내 생각에는 이들 모두 몇 가지 기능을 가지고 있어 개발자 경험을 향상시키는 모노 레포 전략을 구축하는 데 도움이 될 것입니다.\n\n올해의 목표는 조금 벗어나 있는 것 같아요. 모든 도구를 검토하는 데 충분한 시간을 투자할 수 있는지 확신이 안 서지만, 개발자 경험을 더욱 개선할 미개척된 기회가 있다고 믿기 때문에 이 분야를 주의 깊게 지켜보겠어요.\n\n시도해 볼 도구에 대한 제안은 언제든 환영이에요. 특히 도구를 테스트하고 경험을 공유할 때 간단한 리뷰를 제공해주신다면 더욱 환영합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n보시다시피, 마이크로 프론트엔드 생태계에서 아직 해결해야 할 문제가 많지만, 지난 몇 년 동안 큰 발전을 이루었습니다.\n\n저에게는 기업 조직 전반에서 성공을 거두고 있는 \"젊은\" 아키텍처의 여러 개선 영역을 만들어나가는 것이 매우 흥미로운 기회입니다.\n\n더 많은 발견이 있을 것이며, 이 빠른 채택이 분산 UI 아키텍처에서 무엇이 동작하고 동작하지 않는지에 대한 새로운 통찰을 가져다 줄 것이라고 기대합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹어셈블리(WASM), 클라이언트 측 보안 강화, 개발자 경험을 더욱 효율적으로 만드는 작업 등 다른 주제도 제가 주시하고 있어요. 하지만 이 글에서 나열된 주제들은 애플리케이션과 조직을 다음 몇 달 동안 확장하는 차세대 방법을 개선하는 데 고민거리를 제공해줄 거예요. 함께 토론해보면 좋을 것 같아요.","ogImage":{"url":"/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png"},"coverImage":"/assets/img/2024-06-20-TheFutureofMicroFrontends_0.png","tag":["Tech"],"readingTime":10}],"page":"46","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"46"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>