<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" href="/post/2024-06-27-AladoanewlightweightwebframeworkforNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " href="/post/2024-06-27-iBuildaCliToollikeShadcnforNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" href="/post/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 18로 뉴욕 타임스 웹 성능 향상 방법" href="/post/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 18로 뉴욕 타임스 웹 성능 향상 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 18로 뉴욕 타임스 웹 성능 향상 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 18로 뉴욕 타임스 웹 성능 향상 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" href="/post/2024-06-27-Itstimetokilltheweb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-Itstimetokilltheweb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" href="/post/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" href="/post/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 26, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Typescript 런타임 설정 완벽 마스터하는 방법" href="/post/2024-06-24-MasteringTypescriptRuntimeConfigurations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Typescript 런타임 설정 완벽 마스터하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Typescript 런타임 설정 완벽 마스터하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Typescript 런타임 설정 완벽 마스터하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 24, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 속성 가져오고 설정하는 방법" href="/post/2024-06-23-JavaScriptGettingSettingsAttributes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 속성 가져오고 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 속성 가져오고 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 속성 가져오고 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 링크의 종류와 사용 방법" href="/post/2024-06-23-LinksinHTMLTypesandUses"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 링크의 종류와 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 링크의 종류와 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 링크의 종류와 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link posts_-active__YVJEi" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개","description":"","date":"2024-06-27 17:42","slug":"2024-06-27-AladoanewlightweightwebframeworkforNodejs","content":"\n\nNode.js 서버 측 개발 분야에서는 자주 새로운 도구와 프레임워크가 등장하여 개발자들의 작업을 간편화하고 응용 프로그램 성능을 향상시키려고 노력합니다. 그 중 하나인 Alado는 가벼운 백엔드 프레임워크입니다. \n\nAlado란 무엇인가요?\n\nAlado는 현대적인 Node.js 백엔드 프레임워크로, 간소화와 고성능을 중점으로 삼고 있습니다. 이 프레임워크는 개발자들에게 최소한의 리소스로 서버 측 응용 프로그램을 생성할 수 있는 간단하고 직관적인 도구를 제공하며 빠른 요청 처리 속도를 제공하면서 다양한 기능을 내장하고 있습니다.\n\nAlado의 주요 장점\n\n- 가벼움\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. Alado의 미니멀한 디자인은 로드 시간과 메모리 사용량을 크게 줄입니다. Node.js 코어 모듈과 문서화를 위해 swagger-ui-dist에만 의존하여 매우 가볍고 빠르게 만들어졌습니다.\n\n2. 뛰어난 성능\n\n현대 서버 응용프로그램 성능을 고려하여 설계된 Alado는 효율적인 요청 처리 알고리즘과 최소한의 추상화를 사용하여 높은 속도와 응답성을 보장합니다.\n\n3. 직관적인 API\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAlado는 심플하고 논리적인 API를 제공하여 개발자들이 신속하게 스피드를 내는 데 도움을 줍니다. 이는 Node.js 개발에 익숙치 않거나 새로운 도구로 전환하는 사람들에게 특히 유용합니다.\n\n**내장된 기능:**\n\n- 빠른 라우팅, 쿼리 및 바디 파싱, CORS\n- 파일 업로드: 파일 업로드를 지원하여 파일 처리 구현을 간단화합니다.\n- 자동 API 문서화: 정의된 라우트와 컨트롤러를 기반으로 문서를 생성하여 최신 API 문서를 유지보수하기 쉽게 합니다.\n\nAlado는 가벼운 디자인, 높은 성능 및 사용 편의성을 결합한 유망한 Node.js 백엔드 프레임워크입니다. 서버 측 응용 프로그램에 효율적인 솔루션을 찾는 개발자들에게 이상적인 선택입니다. 오늘 바로 Alado를 시도하고 이점을 경험해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보와 문서를 보려면 npm의 Alado 페이지를 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png"},"coverImage":"/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png","tag":["Tech"],"readingTime":2},{"title":"Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 ","description":"","date":"2024-06-27 17:41","slug":"2024-06-27-iBuildaCliToollikeShadcnforNextjs","content":"\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*OqSruG8nIPecbw8awLPfcQ.gif)\n\n![image](/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png)\n\nSo let’s Start 👇 and don’t Forget to “💖”.\n\nHello👋 Developers! Welcome to My Another Blog Post.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 이 블로그 글은 제 새로운 프로젝트 Mixcn-ui에 대해 이야기하고 싶어요. 제 친구 Md Taqui Imam입니다.\n\nMixcn-ui는 Nextjs를 위한 컴포넌트 컬렉션이 담긴 앱이에요.\n\nMixcn-ui를 확인해보세요 🚀\n\n가장 멋진 점은 컴포넌트의 코드를 복사하여 붙여넣기 하는 대신 shadcnui와 같은 CLI를 사용할 수 있다는 거예요.\n\n![이미지](/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어: npx mixcn-ui add hackerbutton\n\nGithub에 별을 한 개 눌러주세요⭐\n\n현재는 몇 가지 컴포넌트만 있지만, 멋진 컴포넌트를 만들고 있어요.\n\n\u003cimg src=\"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 프로젝트에 대한 멋진 아이디어나 제안이 있으시면 댓글로 남겨주세요 👇.\n\n# 여기까지 😁\n\n이 블로그를 읽어주셔서 감사합니다🙏, 새로운 장소를 발견할 수 있는 좋은 정보가 되었으면 좋겠어요!\n\n아이디어가 있다면 댓글로 표시해주세요 📩.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 \"💖\"을 꼭 남겨주세요!\n\nGithub에서 팔로우도 부탁드려요 ✅\n\n즐거운 코딩하세요 👋","ogImage":{"url":"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png"},"coverImage":"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png","tag":["Tech"],"readingTime":2},{"title":"이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법","description":"","date":"2024-06-27 17:38","slug":"2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages","content":"\n\n\n![이미지](/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png)\n\n이 게시물에서는 이미지를 최적화하기 위해 sharp 패키지를 활용하는 express.js 미들웨어를 구현할 것입니다.\n\n중요 사항 요약; 이 스토리의 끝에 코드 전체가 gist로 제공됩니다.\n\n초기화\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nmkdir express-image-opt-middleware\ncd express-image-opt-middleware\nnpm init -y\ntouch index.js\ntouch utils.js\r\n```\n\n이제 의존성을 설치해 봅시다:\n\n```js\r\nnpm i express sharp\nnpm i -D nodemon\r\n```\n\nnpm 스크립트를 구성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n// package.json\n{\n  ...,\n  \"scripts\": {\n    \"dev\": \"nodemon index.js\",\n    \"start\": \"node index.js\"\n  },\n  ...\n}\n```\n\nExpress 서버를 초기화합니다:\n\n```js\n// index.js\n\nconst express = require('express');\nconst fs = require('fs/promises');\nconst path = require('path');\n\nconst app = express();\n\napp.listen(8080, () =\u003e {\n  console.log(\"서버가 http://localhost:8080에서 실행 중입니다.\");\n});\n```\n\n보통 express를 통해 정적 자산을 제공하려면 내장된 express.static 미들웨어를 사용합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\napp.use(express.static('public'));\n```\n\n이 미들웨어는 사용하지 않아도 됩니다. 왜냐하면 우리가 직접 구현할 것이기 때문입니다. 이미지를 표시하려고 할 때 이해해야 할 첫 번째 것은 이미지를 표시하려면 특정 URL로 GET 요청을 하는데, 서버에서 이미지를 가져와 표시하는 것입니다. 여기서 우리가 하는 일은 이 요청을 가로채서 URL에 제공된 쿼리 매개변수를 기반으로 필요할 때 최적화된 이미지를 제공하는 것입니다.\n\n```js\n// index.js\n\napp.get('*', async (req, res, next) =\u003e {\n  const storagePath = path.join(__dirname, 'public');\n  const fileName = req.params[0] ?? '';\n  const filePath = path.join(storagePath, fileName);\n\n  try {\n    const stats = await fs.stat(filePath);\n    if (!stats.isFile()) return next();\n\n    // * 여기에 코드를 추가합니다\n  } catch(err) {\n    console.error(err);\n    res.status(404).send('파일을 찾을 수 없습니다');\n  }\n});\n```\n\n요청된 이미지에 기반하여 적절한 Content-Type 헤더를 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// utils.js\nconst path = require('path');\n\nexports.getContentType = fileName =\u003e {\n  const ext = path.extname(fileName).slice(1);\n  let contentType;\n  \n  switch (ext) {\n    case 'jpg':\n    case 'jfif':\n    case 'jpeg':\n      contentType = 'image/jpeg';\n      break;\n    case 'png':\n      contentType = 'image/png';\n      break;\n    case 'webp':\n      contentType = 'image/webp';\n      break;\n    case 'svg':\n      contentType = 'image/svg+xml';\n      break;\n    default:\n      contentType = 'application/octet-stream';\n  }\n\n  return contentType;\n};\n```\n\n```js\n// index.js\n\n// * setting the Content-Type\n// * make sure to require getContentType\nconst contentType = getContentType(fileName);\nres.setHeader('Content-Type', contentType);\n  \n// * serve svg and unknown files as they are\nif (['image/svg+xml', 'application/octet-stream'].includes(contentType)) {\n  const readStream = createReadStream(filePath);\n  readStream.pipe(res);\n  readStream.on('error', next);\n  return;\n}\n```\n\nfs/promises API는 createReadStream 함수를 제공하지 않습니다. 두 방법을 모두 활용하려면 다음과 같이 사용하십시오:\n\n```js\nconst { createReadStream } = require('fs');\nconst fs = require('fs/promises');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 미들웨어는 다음 쿼리 매개변수를 이해합니다:\n\n- q — 품질\n- w — 너비\n- h — 높이\n\n모든 이 매개변수들이 선택 사항임을 유의하세요.\n\nw 또는 h 중 하나만 지정된 경우, 이미지의 원래 종횡비가 다른 차원을 계산하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// index.js\n\n// * sharp 패키지를 포함해야 합니다\nconst image = sharp(filePath);\nconst metadata = await image.metadata();\nconst aspectRatio = metadata.width / metadata.height;\nconst quality = Math.trunc(+(req.query.q ?? 100));\nlet width = Math.trunc(+(req.query.w ?? 0));\nlet height = Math.trunc(+(req.query.h ?? 0));\n\n// * 너비만 지정된 경우\nif (width \u0026\u0026 !height) {\n  height = Math.round(width * (1 / aspectRatio));\n\n  // * 높이만 지정된 경우\n} else if (height \u0026\u0026 !width) {\n  width = Math.round(height * aspectRatio);\n\n  // * 둘 다 지정되지 않은 경우\n} else {\n  width = metadata.width;\n  height = metadata.height;\n}\n\nconst stream = image\n  .resize({ width, height })\n  .jpeg({ quality, progressive: true, force: false })\n  .webp({ quality, progressive: true, force: false })\n  .png({ quality, progressive: true, force: false });\n\nstream.pipe(res);\nstream.on('error', next);\r\n```\n\nMiddleware의 전체 코드는 다음 gist에 있습니다: [link](gist 주소)\r\n","ogImage":{"url":"/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png"},"coverImage":"/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png","tag":["Tech"],"readingTime":4},{"title":"React 18로 뉴욕 타임스 웹 성능 향상 방법","description":"","date":"2024-06-27 17:35","slug":"2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18","content":"\n\n## React 18 업그레이드가 뉴욕 타임스 웹 사이트에 활력을 불어넣었고 우리가 직면한 일부 도전에 대해 어떻게 대처했는지 알아봅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*rT1gMg-9ensw1FDxaAaq_Q.gif)\n\n작성자: 이리야 구레비치\n\n뉴욕 타임스의 소프트웨어 엔지니어로서 우리는 페이지 성능, SEO 및 최신 기술과의 연계 유지에 큰 가치를 둡니다. 이러한 우선 순위를 염두에 두고, React 18의 발표는 웹 개발의 끊임없이 확장되는 세계에서 상당하고 현실적인 발전으로 우리에게 돋보였습니다. React 기반 사이트의 경우, 이 업그레이드는 성능 향상과 흥미로운 새로운 기능에 접근할 수 있는 것을 약속했습니다. 지난 겨울, 우리는 주요 핵심 뉴스 사이트에서 React 18의 장점을 받아들이기로 결정했습니다. 이 과정에서 리액트와 우리 사이트의 고유한 특징을 극복해야 했지만, 최종적으로 우리는 큰 성능 향상을 이루어내고 향후 개선 가능성을 열어두었으며 아직 탐험 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 업그레이드 과정에 들어가기 전에, React 18에서 주요 이점과 변경 사항 몇 가지를 살펴보겠습니다:\n\n- Concurrent Mode로 더 부드러운 렌더링: React 18는 동시에 업데이트와 사용자 상호작용을 렌더링하는 새로운 패러다임인 Concurrent Mode를 소개했습니다. 이는 더 부드러운 애니메이션, 적은 화면 지연 및 누적 레이아웃 변경으로 이어지며 더 반응적인 사용자 경험을 제공합니다.\n- 자동 일괄 처리 및 전환: 동시성을 최대한 활용하기 위해 React 18는 단일 렌더 사이클 내에서 상태 업데이트를 자동으로 일괄 처리하여 성능을 최적화합니다. 이는 메인 스레드에서 작업을 분할하여 거의 모든 작업이 동기적으로 실행되는 이전 메커니즘과 큰 차이가 있습니다. 또한 새로운 useTransition 훅을 도입하여 특정 상태가 UI를 차단하지 않고 업데이트되도록 엔지니어들이 보장할 수 있습니다.\n- 흥미로운 새로운 기능: React 18은 서버 측 렌더링 및 선택적 가수분화를 통해 리액트 서버 컴포넌트를 통해 스트리밍 업데이트와 같은 흥미로운 기능을 제공하며 혁신적인 UI 패턴과 초기 렌더링을 가속화합니다.\n\n성능 향상은 특히 INP(Interaction to Next Paint) 점수에서 상당히 중요했기 때문에 우리에게 매우 의미가 있었습니다. INP는 페이지 응답성의 측정 항목이며 구글이 웹 사이트를 검색 결과에서 순위를 매기는 데 사용하는 Core Web Vital 중 최신 메트릭스입니다. SEO 점수는 뉴스 조직에게 매우 중요하며 우리의 INP 점수를 개선하는 것은 어려운 도전이었기 때문에 React 업그레이드가 우리에게 높은 우선 순위(그리고 위험 부담)의 이니셔티브로 자리 잡았습니다.\n\n# 우리의 이주 프로세스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용되지 않는 종속성 제거\n\n마이그레이션을 시작하기 전에 React 18과 호환되지 않은 폐기된 Enzyme 테스팅 라이브러리를 제거해야 했습니다. 이를 위해 모든 테스트 파일을 보다 최신 라이브러리인 @testing-library/react으로 수동으로 이관해야 했습니다. 시간을 투자하는 측면에서, 이것이 전체 프로젝트에서 가장 큰 작업이었을 수도 있습니다. Enzyme은 저희 리포지토리 전체에 걸쳐 수백 개의 테스트 파일에서 사용되었으며, 이를 완전히 대체하려면 상당한 인적 노력과 몇 십 개의 풀 리퀘스트가 필요했습니다. 우리는 다른 제품 작업을 수용하고 개발자의 피로를 피하기 위해 단계적인 풀 리퀘스트로 이 작업을 몇 달 동안 해내었습니다. 노력의 끝에, 우리는 분명히 @testing-library/react API에 대한 전문가가 되었으며, React 18 업그레이드로 넘어갈 수 있어 기쁘게 생각했습니다.\n\n2. 기반 설정\n\n테스트 파일 마이그레이션이 완료되면 React 18 통합 작업을 시작할 수 있었습니다. 이를 안전하게 수행하기 위해, 먼저 주요 종속성, 유형 및 테스트를 React 18에 맞게 업그레이드하는 작업을 시작했습니다. 실제 기능을 구현하는 것이 아니라 React 18에 적합하도록 간단히 @types/react, react-test-renderer, react-dom 및 @testing-library 등 모든 것을 우리 리포지토리 전체의 package.json 파일에서 최신 버전으로 업그레이드했습니다. 모든 주요 의존성을 업그레이드하는 것은 동일 버전에 맞도록 일부 테스트 및 유형 정의를 리팩토링하는 것도 필요했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 엔진 켜기\n\n우리가 패키지 업그레이드에 자신감을 갖게 되자, 우리는 React 18의 새로운 기능을 안전하게 통합할 준비가 되었습니다. 이 기능을 현실로 바꾸기 위해, 우리는 최신 API인 createRoot와 hydrateRoot를 활용해야 했습니다. 우리는 여러 웹 서버에 걸쳐 React Hydration을 통합한 몇 가지 인스턴스를 가지고 있었는데, 모든 서버 간에 렌더링되는 일련의 공유 UI 구성 요소가 있었기 때문에 우리는 가능한 한 많은 곳에서 React 18 기능을 활성화시키는 것이 중요했습니다. 처음 보기에는 ReactDOM.hydrate를 hydrateRoot로 변경하는 것만으로 간단해 보였지만, 정말 그럴까요?\n\n예기치 않은 도전\n\n개발자로써 \"운영 환경으로 전개\" 버튼을 누를 때 자신감이 생기기 쉽습니다. 엔드 투 엔드 통합 및 단위 테스트가 통과되었고, 다양한 환경과 장치에서 QA를 수행했으며, 최신 기능을 곧 출시할 단계에 있다면, 그 생각이 들 수 있습니다. 우리는 뉴욕 타임즈 웹사이트에 최신 React 버전을 처음으로 배포했을 때 모두 그러했습니다. 새로운 업그레이드를 초기에 배포한 직후, \"내장형 인터랙티브\"라고 하는 일부 고트래픽 콘텐츠에 문제가 발생했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 리액트 18에 임베디드 인터랙티브 적용\n\n![이미지](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png)\n\n뉴욕타임스에서는 custom 임베디드 인터랙티브를 사용하여 위험성 있는 `dangerouslySetInnerHTML`을 통해 서버 측에서 렌더링됩니다. 이러한 인터랙티브는 자체의 HTML, 링크 및 스크립트를 갖추며, React 트리와 독립적으로 실행됩니다. 편집자와 기자들은 코어 인프라를 변경하거나 다시 배포할 필요 없이 페이지에 일회용 및 독립적인 시각적 및 상호작용 요소를 삽입할 수 있습니다. 임베디드 인터랙티브는 우리의 일부 가장 중요한 보도 활동의 핵심 요소이지만, 개발자들에게 실제로 어려움을 초래할 수도 있습니다.\n\n간단한 예시는 다음과 같습니다(script 태그는 페이지가 열리자마자 DOM을 수정할 것입니다):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst embeddedInteractiveString = `\n  \u003cdiv id=\"server-test\"\u003e서버\u003c/div\u003e\n  \u003cscript\u003e\n    document.addEventListener(\"DOMContentLoaded\", () =\u003e {\n      const serverTestElement = document.getElementById(\"server-test\");\n      serverTestElement.textContent = \"클라이언트\";\n    });\n  \u003c/script\u003e\n`;\nreturn \u003cdiv dangerouslySetInnerHTML={ {__html: embeddedInteractiveString } } /\u003e;\n```\n\n이 설정에서 스크립트는 페이지 로드 후에 \"server-test\" 요소의 내용을 \"server\"에서 \"client\"로 수정합니다. 브라우저에서 렌더링된 스크립트가 React가 DOM을 하이드레이트하기 전에 실행되기 때문에 작동합니다. 이는 우리가 주입된 HTML 및 해당 스크립트가 의도한 대로 동작할 것을 신뢰하는 \"블랙 박스\"로 볼 수 있습니다.\n\n하이드레이션 장벽\n\nReact 18이 도입되면서 더 엄격해진 하이드레이션 불일치 요구 사항이 있습니다. 새로운 규칙에 따르면 초기 브라우저 로드와 클라이언트 측 하이드레이션 사이의 모든 DOM 수정은 클라이언트 측 렌더링으로 되돌아가도록 트리거됩니다. 우리의 예시에서는 스크립트 태그가 하이드레이션 전에 \"server-test\" 요소를 수정하더라도, 하이드레이션 불일치에서 React는 서버 측 렌더링된 콘텐츠를 버리고 클라이언트 측 렌더링으로 되돌아가게 됩니다. 이전 버전의 React에서는 하이드레이션 불일치가 있더라도 React 팀이 클라이언트에서 완전히 다시 렌더링하는 대신 DOM 버전을 무효한 상태로 남기기로 선택했기 때문에 과거에는 문제가 발생하지 않았던 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제적으로는 이게 무슨 뜻일까요? 사용자가 `dangerouslySetInnerHTML` 속성을 사용하여 클라이언트에 컴포넌트를 렌더링할 때, 안전성 상의 이유로 `script` 태그가 포함된 HTML은 브라우저에서 실행되지 않습니다. 이는 `dangerouslySetInnerHTML` 속성을 사용하여 클라이언트에서 재렌더링된 중에 하이드레이션 불일치 때문에 임베드된 상호 작용이 사실상 자바스크립트가 실행되지 않은 것처럼 렌더링됨을 의미합니다. 위의 예시에서, 텍스트 콘텐츠는 \"서버\"에서 \"클라이언트\"로 변경되지만, 하이드레이션 불일치로 인해 다시 \"서버\"로 렌더링됩니다. 이로 인해 일부 임베드된 상호 작용이 예상한 렌더와 매우 다르게 보여지게 되었습니다.\n\n예상:\n\n\u003cimg src=\"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_1.png\" /\u003e\n\n실제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_2.png\" /\u003e\n\n그래서 우리는 무엇을 해야 할까요?\n\nReact 18가 React 16보다 수분화 불일치에 더 민감하다는 사실을 감안할 때, 우리 앞에는 두 가지 선택지가 있었습니다. 첫 번째는 웹 사이트에서 발생할 수 있는 모든 수분화 불일치를 수정하는 것이었고, 두 번째는 수분화 불일치가 발생할 경우 클라이언트에서 재설치되도록 내장 상호작용형을 수정하는 것이었습니다. 이로 인해 우리는 애로 상황에 처해 있었습니다. 뉴욕 타임스는 수백 가지 다양한 구성 요소와 수만 개의 사용자 정의 임베디드 상호작용형을 포함한 수백만 개의 기사를 게시했습니다. 물론 모든 수분화 불일치를 수정하고 싶었지만, 어떻게 안전하게 할 수 있을까요?\n\n결국, 우리는 두 가지 문제를 동시에 해결하기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 내장 인터랙티브 스크립트 수동 추출 및 실행\n\ninnerHTML 프로퍼티를 통해 추가된 스크립트 태그나 클라이언트 측 재렌더링 도중 추가된 스크립트 태그는 브라우저 보안상의 이유로 자동으로 실행되지 않는다는 것을 알고 있습니다. 그렇다면 어떻게 해결할까요? 스크립트 태그는 수동으로 다른 DOM 요소의 자식 노드로 추가 또는 대체할 때에만 실행됩니다. 이는 스크립트 태그를 올바르게 실행하려면 먼저 대화형 HTML에서 추출하고 제거한 다음 컴포넌트가 다시 렌더링될 때 내장된 대화형 HTML의 올바른 위치에 다시 추가해야 한다는 것을 의미합니다.\n\n```js\n// 이 함수는 일반 HTML에서 스크립트 태그를 빈 플레이스홀더로 대체합니다.\n// 이렇게 하면 나중에 클라이언트 마운트에서 실제 스크립트로 스크립트 태그 참조를 현위치에 대체할 수 있습니다.\nexport const addsPlaceholderScript = (scriptText, id, scriptCounter) =\u003e {\n  let replacementToken = '';\n  let hoistedText = scriptText;\n\n  replacementToken = `\u003cscript id=\"${id}-script-${scriptCounter}\"\u003e\u003c/script\u003e`;\n  hoistedText = hoistedText.replace('\u003cscript', `\u003cscript id=\"${id}-script-${scriptCounter}\"`);\n\n  return {\n    replacementToken,\n    hoistedText,\n  };\n};\n\n// 이 함수는 대화형 HTML 문자열에서 `\u003cscript\u003e` 태그를 추출하고 제거하며\n// 클라이언트 마운트에서 실행할 스크립트 텍스트 배열과 스크립트를 제거한 빈 스크립트 참조가 있는 수정된 HTML 문자열을 포함하는 객체를 반환합니다.\nexport const extractAndReplace = (html, id) =\u003e {\n  const SCRIPT_REGEX = /\u003cscript[\\s\\S]*?\u003e[\\s\\S]*?\u003c\\/script\u003e/gi;\n  let lastMatchAdjustment = 0;\n  let scriptlessHtml = html;\n  let match;\n  const scriptsToRunOnClient = [];\n  let scriptCounter = 0;\n  while ((match = SCRIPT_REGEX.exec(html))) {\n    const [matchText] = match;\n    if (matchText) {\n      let hoistedText = matchText;\n      let replacementToken = '';\n      ({ hoistedText, replacementToken } = addsPlaceholderScript(hoistedText, id, scriptCounter));\n      scriptCounter += 1;\n      const start = match.index - lastMatchAdjustment;\n      const end = match.index + matchText.length - lastMatchAdjustment;\n      scriptlessHtml = `${scriptlessHtml.substring(\n        0,\n        start\n      )}${replacementToken}${scriptlessHtml.substring(end, scriptlessHtml.length)}`;\n      scriptsToRunOnClient.push(hoistedText);\n      lastMatchAdjustment += matchText.length - replacementToken.length;\n    }\n  }\n\n  return {\n    scriptsToRunOnClient,\n    scriptlessHtml,\n  };\n};\n\n// 클라이언트에서 스크립트 실행\nconst runScript = (clonedScript) =\u003e {\n    const script = document.getElementById(document.getElementById(`${clonedScript.id}`))\n    script.parentNode.replaceChild(clonedScript, script);\n}\n```\n\n어째서 서버에 스크립트를 유지하고 클라이언트에서 재실행하지 않고도 해결할 수 없을까요? 이를 몇 가지 시나리오에서 불가능한 이유 중 하나는 스크립트 태그 중 일부가 함수 클로저 내가 아닌 전역 변수를 선언하기 때문입니다. 서버에서 스크립트 태그를 미리 렌더링한 다음 클라이언트에서 재실행하면 전역 변수의 다시 선언으로 인한 오류가 발생하여 불가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 초기 솔루션으로 많은 내장 상호작용을 수정했습니다. 그러나 임의로 순서 지정된 스크립트 실행과는 잘 맞지 않는 상호작용이 있습니다. 여기서 몇 가지 세심한 사항을 살펴보겠습니다:\n\n스크립트 로드 순서\n\n일부 상호작용 스크립트는 다시 내장된 상호작용 HTML에 추가될 때 올바른 순서로 로드되어야 합니다. 이전 스크립트 실행 전략은 모든 `script` 태그가 이미 서버에 선언되고 사전 렌더링되었다고 가정했습니다. 이제는 스크립트 태그를 제거하고 클라이언트에 재부팅해야 하기 때문에 이러한 원칙을 기반으로 한 몇 가지 내재 논리가 깨지게 될 것입니다. 예시를 통해 함께 살펴보겠습니다.\n\n```js\n\u003cscript\u003e\n  const results = document.getElementById(\"RESULTS_MANIFEST\").innerHTML.ELECTION_RESULTS;\n  // 결과를 사용하여 추가적인 로직 수행\n\u003c/script\u003e\n\u003cdiv\u003e\n  대화형 DOM 내용이 여기로 이동합니다\n\u003c/div\u003e\n\u003cscript id=\"RESULTS_MANIFEST\"\u003e{\"ELECTION_RESULTS\": ['result1', 'result2', ....]}\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 시나리오에서는 두 번째 스크립트 태그의 ID를 사용하여 다른 스크립트 태그를 검색한 다음 두 번째 스크립트 태그의 innerHTML을 기반으로 일부 기존 논리를 활용하는 초기 스크립트가 있습니다. 이전 반복의 경우, 스크립트 태그는 서버에서 미리 렌더링되었기 때문에 기본적으로 문제 없이 DOM에서 스크립트 태그를 ID로 참조할 수 있었습니다.\n\n최적의 상호 작용을 위해 스크립트 실행은 다시 DOM에 추가될 때 특정 순서를 따라야 합니다. 이에는 다음이 포함됩니다:\n\n- 정적 데이터가 포함된 기능이 없는 manifest 스크립트를 먼저 추가합니다.\n- 다음으로 src 속성을 가진 스크립트를 비동기적으로 실행합니다.\n- 마지막으로 innerHTML에 있는 순수 JavaScript로 스크립트를 추가하고 실행합니다.\n\n이 순서대로 진행하면 스크립트가 제대로 로드되기 전에 서로를 참조하지 못하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 제공된 스크립트 태그를 구문 분석하여 정렬을 위한 우선순위를 반환합니다.\n// 우선순위 1: JSON 또는 기타 메타데이터 콘텐츠\n// 우선순위 2: 다른 바닐라 JS 또는 src 콘텐츠\nexport const getPriority = template =\u003e {\n  let priority;\n  try {\n    JSON.parse(template.innerHTML);\n    priority = 1;\n  } catch (err) {\n    priority = 2;\n  }\n  return priority;\n};\n\n\nscripts.sort((a, b) =\u003e getPriority(a) - getPriority(b));\n```\n\n# 즉시 퍼포먼스 개선\n\n매우 세심하게 조정된 이 내장형 인터랙티브 코드의 통합 후, 우리는 React 18을 다시 안전하게 출시할 수 있었습니다. 우리는 거의 40,000개의 사용자 정의 내장형 인터랙티브를 철저히 테스트할 수 없지만, 그래픽 팀이 자주 활용하는 재사용 가능한 몇 가지 템플릿을 신뢰할 수 있었습니다. 이를 통해 Svelte나 Adobe Illustrator 기반의 내장형 인터랙티브 내에서 특정 동작을 검증할 수 있었습니다. 장기적으로는 남아있는 하이드레이션 불일치를 해결하고 안심할 수 있는 상태에 도달하기 위한 노력을 계속하지만, 단기적으로는 다시 \"배포\" 버튼을 누르는 준비를 했습니다.\n\n새로운 기능을 출시한 후 (그리고 어떠한 문제도 발생하지 않는지를 신경 쓰면서 한 시간 동안 내부 알림을 신중히 확인한 후), 거의 즉시 성능 향상을 볼 수 있었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![React Upgrade Chart](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_3.png)\n\n이 차트에서 볼 수 있듯이, INP 스코어가 p75 범위에서 대략 30% 감소했어요!\n\n업그레이드 이전에, 우리의 가장 큰 과제 중 하나는 페이지를 로드하는 동안 뉴스 사이트가 거치는 빈번한 재렌더링이었어요. 이는 사용자가 아직 로드 중인 페이지와 상호 작용을 시도할 때 부정적인 사용자 경험(그리고 하위 수준의 INP 스코어)을 초래했어요.\n\nReact 18을 업그레이드한 후, 재렌더링이 거의 절반으로 줄었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_4.png)\n\n이 두 가지 매우 눈에 띄고 중요한 개선 사항은 React 18의 자동 일괄 처리와 병행성 기능의 직접적인 결과입니다. 이는 우리가 올바른 방향으로 나아가고 있다는 매우 명확하고 긍정적인 신호를 주었습니다.\n\n# 다음 단계\n\nReact 18 통합은 이미 우리에게 상당한 개선을 가져다 주었으며, 이전에 이용할 수 없었던 다양한 가능성의 문을 열어 주었습니다. 이제는 startTransition 및 React Server Components와 같은 새로운 기능의 잠재적 이점을 탐색하는 데 집중하고 있습니다. 우리의 핵심 의도는 지속적으로 INP 점수를 낮추고 전반적인 기능을 개선하는 것입니다. 그러나 이러한 개선 사항에 대해 답할 필요가 있는 질문에 대해 주의를 기울이고 있습니다. 현재 사용 중인 React 버전의 안정적이고 신뢰할 수 있는 성능을 보장하는 것이 현재 우리의 주요 업무입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뉴스 사이트 결과를 바탕으로, 우리는 유사한 성능 향상을 보인 기타 몇몇 사이트의 업그레이드를 추구할 자신감을 느꼈습니다. 3월 구글 데드라인 전에 INP 점수를 \"나쁨\" 영역을 벗어낼 수 있었으며, 구글의 검색 알고리즘 일부가 되었을 때 부정적인 SEO 결과를 보지 못했습니다. 우리는 독자들이 약간 빨라진 경험을 즐기고 있다고 생각합니다. 뉴스룸은 매일 강력하고 흥미로운 대화형 콘텐츠를 제공해왔으며, 가속화 프레임워크에 대해 두 번째 생각할 필요 없이 작업을 이어가고 있습니다.\n\nIlya Gurevich는 스타트업과 기업 환경에서 10년 이상의 경력을 가진 시니어 소프트웨어 엔지니어입니다. 그는 2019년 뉴욕타임스에 합류한 이후 현재 핵심 웹 플랫폼 팀의 일원입니다. 그는 주요 사이트를 구동하는 중앙집중식 NodeJS 플랫폼을 관리하며, 개발자 경험, 도구 및 수백 명 이상의 활발한 기여자가 있는 멀티 워크스페이스 모노레포의 빌드 프로세스에도 참여하고 있습니다. 그 전에는 레포터와 편집자를 위해 특별히 제작된 최첨단 실시간 협업 텍스트 편집기에 참여한 경력이 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png"},"coverImage":"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png","tag":["Tech"],"readingTime":12},{"title":"웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석","description":"","date":"2024-06-27 14:25","slug":"2024-06-27-Itstimetokilltheweb","content":"\n\n무슨 일이 벌어지고 있어요. 사람들이 불만스러워하는 모양이에요. 시민 불안의 유령이 우리 프로그래밍 커뮤니티를 쫓고 있어요.\n\n처음으로, 많은 개발자들이 웹 플랫폼을 공개적으로 의심하고 있어요. 여기 한 편의 대표적인 기사와 토론이 있어요. 또 다른 것도 있어요. 더 있지만, 당신이 이것을 읽고 있는 만큼 프로그래밍에 흥미가 있는 분이라면, 올해에 대한 현대 웹 개발 상태에 대한 웃기는 항의 한 편은 이미 한 편 이상 읽었어요. 이 기사는 그러한 종류가 아니에요. 저는 상태 quo를 조롱하는 것보다, 매일 그것을 경험하는 불쌍한 사람들보다 더 나은 일을 할 수 없어요. 이 기사는 다른 종류에요.\n\n![이미지](/assets/img/2024-06-27-Itstimetokilltheweb_0.png)\n\n웹을 대체하고 흡수하여 최종적으로 그것을 대체할 만한 경쟁 프로그램을 만드는 방법에 대해 생각해보고 싶어요, 적어도 앱 작성 목적으로요. 웹은 문서를 배포하는 방법으로서도 문제점이 있지만, 걱정할 정도로 심각하지는 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 총 세 편으로 나뉩니다. 첫 번째 편에서는 웹 플랫폼에 대한 심각하고 수정할 수 없는 문제점을 검토할 것입니다. 나는 당신에게 이것을 완전히 폐기해야 한다고 설득하고 싶어요. 결국, 문제를 분석하지 않으면 해결할 수 없거든요. 또한 이 문제들에 대해 이제 정치적으로 이야기할 수 있는 이유를 간단히 살펴보겠어요. 비록 이러한 문제들이 사실 새로운 것은 아니지만 말이에요.\n\n제 2부와 3부에서는 작은 그룹이 합리적인 시간 내에 구축할 수 있는 새로운 앱 플랫폼을 제안하고, 오늘날의 것보다 훨씬 나은 것이어야 한다고 생각해요 (제 의견). 물론, 모두가 마지막 부분에 동의할 수는 없을 거에요. 문제에 동의하는 것은 해결책에 동의하는 것보다 항상 쉽거든요.\n\n제 1부. 시작합니다.\n\n# 왜 웹은 죽어야 할까요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 앱들. 그겟서요? 뭐든 문제가 많지만, 오늘은 두 가지만 얘기해볼게요.\n\n- 웹 개발은 천천히 1990년대를 되살리고 있죠.\n- 웹 앱들을 보안하는 건 불가능해요.\n\n요즘 핫한 Facebook의 최신 웹 프레임워크인 Flux에 관한 좋은 블로그 포스트가 있어요. 저자는 Flux가 1985년 발매된 Windows 1.0에서 사용된 프로그래밍 모델을 재현했다고 언급했어요. 마이크로소프트는 이 모델을 사용했는데, 그 당시 컴퓨터가 매우 느려서 적합했지만 개발하기가 어색했죠. 그래서 10년 미만이 지난 시간 동안, 이러한 WndProc 메시징 시스템을 추상화한 제품들(예: OWL)이 생겨났어요.\n\nReact/Flux가 사용하는 방식이 이러한 이유 중 하나는 웹 렌더링 엔진이 매우 느리기 때문이에요. 사용자가 실제로 보는 최종 결과물은 20년 전의 Windows 사용자가 본 것보다 약간 더 멋있을 뿐이라는 사실이 있답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_1.png\" /\u003e\n\n지금은 화면 해상도가 높아졌죠. 우리가 좋아하는 회색 음영도 바뀌었어요. 하지만 위에서 보는 UI는 아래에서 보는 UI와 복잡성 면에서 비슷합니다:\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_2.png\" /\u003e\n\n아이콘 스타일도 똑같아요! Windows 98는 예전에는 다채롭고 빽빽한 픽셀 아트 스타일이었던 플랫, 회색조 아이콘의 새로운 트렌드를 소개했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 오피스 2000은 75 Mhz CPU와 32mb RAM으로도 행복했지만, 위에 표시된 구글 독스는 2.5Ghz CPU와 거의 정확히 10배 더 많은 RAM을 사용하고 있어요.\n\n만약 생산성이나 기능이 10배 증가했다면 용서해도 될지도 모르지만, 사실은 그렇지 않아요. 1995년 개발자 플랫폼은 모두 이런 것들을 가져야 했어요. 이것이 '시작의 가치'였어요:\n\n- 레이아웃 제약 조건과 데이터 바인딩이 있는 시각적 UI 디자이너.\n- 다국어 소프트웨어 컴포넌트에 대한 정교한 지원. 정적으로 입력된 네이티브 코드와 스크립팅 언어를 혼합할 수 있었어요.\n- 몇 메가바이트의 RAM에서 실행될 수 있는 효율적인 출력 바이너리.\n- 데이터 그래픽, 테마, 3D 그래픽, 소켓 프로그래밍, 대화식 디버깅을 지원하는 것.\n\n이러한 기능 중 많은 것들이 지난 몇 년 동안에야 웹 플랫폼에 도입되었으며, 종종 불안정한 방식으로 도입되곤 했어요. 웹 앱은 실제 소켓을 사용할 수 없기 때문에 서버를 \"웹 소켓\"을 지원하도록 변경해야 합니다. UI 구성 요소와 같은 기본적인 것들조차도 끔찍한 상황입니다. 언급할 가치가 있는 웹 IDE는 없으며, 서로 다른 프로그래밍 언어를 혼합하는 것에 대해서는... 자바스크립트로 변환할 수 있어요. 때때로요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 앱을 개발자가 쓰는 이유 중 하나는 웹에서의 사용자 기대치가 극히 낮기 때문입니다. Windows 95용 앱은 아이콘, 드래그 앤 듭, 되돌리기, 파일 연관, 일관된 키보드 단축키, 백그라운드에서 유용한 작업을 수행하며 오프라인에서도 작동하는 것이 기본 기능으로 예상되었습니다. 하지만 이 모든 것들은 기본적인 앱 수준에 불과했습니다. 정말 인상적인 소프트웨어는 Office 문서 내에 임베드될 수 있거나 Explorer를 확장하거나 원래 개발자에게 알려지지 않은 임의의 플러그인으로 확장되어야 했습니다. 그러나 웹 앱은 보통 이러한 것들을 하지 않습니다.\n\n이 모든 것들이 쌓여 나에게는 데스크톱 앱을 작성할 때 훨씬 더 생산적인 느낌이 듭니다 (파일 유형용 아이콘을 만드는 것과 같은 \"세금\"을 지불해야 하는 것들을 포함하여도). 또한 사용하는 것을 선호합니다. 그리고 다른 이들과의 토론을 통해 나만 이런 것은 아니라는 것을 압니다.\n\n나는 웹이 이렇게 되어 있는 것은 HTML이 문서 플랫폼으로 시작했을 때 어떤 일관된 디자인 철학과 도구 세트를 갖고 있었기 때문이라고 생각합니다. 그러나 HTML이 앱 플랫폼으로 추상화된 것은 나중에 따로 추가되었고 결국 제대로 이루어지지 않았습니다. 따라서 파일 연관과 같은 기본 기능조차 존재하지 않지만 Google은 행아웃을 만들고 구글의 우선 순위가 무엇이 추가되는지를 결정하기 때문에 HTML5에는 P2P 비디오 스트리밍이 있습니다. 이러한 문제를 피하려면 처음부터 앱을 염두에 두고 설계된 플랫폼이 필요하며, 아마도 그 위에 문서를 추가하는 것이 더 좋을 것입니다.\n\n# 웹 앱은 보안이 불가능합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1990년대 말에 소프트웨어 산업에는 끔찍한 깨달음이 들었습니다: C/C++ 프로그램의 보안 버그는 적 spor한 실수가 아니었고, 임시 프로세스로 처리할 수 있는 것이 아니었습니다. 그것들은 어디에나 있었습니다. 사람들은 C/C++ 조각이 인터넷에 노출되면 악용이 따를 것이라는 것을 깨달았습니다.\n\n그 당시 세상이 얼마나 순진했는지 알 수 있습니다. 2001년 Code Red에 관한 SANS 보고서를 읽어보면 됩니다:\n\nWindows는 자동 업데이트 기능을 가지고 있었지만, 제대로 기본으로 활성화되지는 않았던 것으로 기억합니다. 사용자의 허락 없이 소프트웨어가 변경될 수 있다는 아이디어는 일종의 금기였습니다.\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n산업은 변화하기 시작했지만, 많은 비명과 부인과 함께였습니다. 당시에는 Linux와 Mac 사용자들 사이에서 이 문제가 Microsoft에만 특정한 문제로 여겨졌다는 것이 일반적인 지혜였죠... 그들의 시스템이 뛰어난 프로그래머들에 의해 만들어졌다는 것. Microsoft는 자신들이 존재적 위기에 직면하고 있다고 받아들였고 \"안전한 개발 수명주기\"를 도입했습니다(대규모의 교육 및 프로세스 프로그램). 그러나 경쟁사들은 거의 아무것도 하지 않았습니다. 레드먼드는 Windows XP에 방화벽을 추가하고 코드 서명 인증을 도입했습니다. 모바일 코드가 제한되었고, 보안 버그가 끝없는 것으로 드러나자 \"패치 화요일\"이 고안되었습니다. 영리한 해커들은 예전에 무해로 여겨졌던 버그 유형이 여전히 악용 가능하며, 강력하다고 여겨졌던 악용 방지가 우회될 수 있음을 지속적으로 발견했습니다. Mac 및 Linux 커뮤니티는 천천히 바이러스와 악용에 완전히 면역이 아니라는 사실을 깨달았습니다.\n\n2008년 구글이 Chrome을 출시하면서 최종적인 전환점이 왔습니다. 이 프로젝트는 거대한 노력을 들여 복잡하지만 완전히 투명한 렌더러 샌드박스를 도입한 점이 주목할 만합니다. 다시 말해, 산업 최고의 엔지니어들이 얼마나 노력해도 안전한 C++ 코드를 쓸 수 없다는 사실을 공개적으로 인정했다는 점입니다. 이 신념과 설계가 사실상의 표준이 되었습니다.\n\n## 이제 웹의 차례입니다\n\n유감스럽게도, 웹은 신뢰할만한 앱의 약속의 땅으로 우릴 이끌어가지 못했습니다. 웹 앱은 호스트 OS로부터 어느 정도 격리되어 있기는 하지만, 앱 자체는 2001년 경의 Windows 코드보다 훨씬 튼튼하지 못합니다. 우리의 레거시 문제를 영구적으로 해결하는 대신, 웹은 오히려 하나의 버퍼 오버플로우 종류를 다른 것으로 대체했습니다. 데스크톱 앱이 \"이중 해제\", \"스택 스매시\", \"이후 무료 사용\" 등과 같은 악용 카테고리를 가지고 있는 것과는 달리, 웹 앱은 이를 해결하고 나서도 자체적으로 유사한 실수를 반복하는 경향이 있었습니다: SQL 인젝션, XSS, XSRF, 헤더 인젝션, MIME 혼란 등입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 논문으로 이어집니다:\n\n나는 안전한 웹 앱을 작성하는 것이 불가능하다는 주장을 제기합니다.\n\n문제를 극복합시다. 이는 말그대로 모든 웹 앱에 해당하는 것이 아닙니다. 네, 안전한 HTML Hello World를 만들 수 있습니다. 멋지네요.\n\n저는 실제 규모의 웹 앱, 현실적인 조건에서 작성된 것에 대해 이야기하고 있습니다. 이는 가볍게 주장하는 것이 아닙니다. 이것은 제가 Google에서 8년간 지켜본 곳에서 얻은 신념입니다. 거기서 가장 뛰어난 웹 개발자들이 계속해서 취약한 소프트웨어를 배포하는 것을 지켜봤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 보안팀은 세계에서 가장 우수한 보안팀 중 하나일 수도 있고, 아마도 최고일 수도 있습니다. 그들은 내부 교육 프로그램의 일환으로 사람들이 하는 주요 실수들에 대한 유용한 가이드를 작성했습니다. 데이터를 안전하게 브라우저로 전송하여 표시하는 데 도움이 되는 이들의 조언을 여기에 소개합니다:\n\n이 믿기 힘든 마법과 전설 속의 뭉텅이를 읽으면 항상 웃음이 나옵니다. 농담이어야 할 것 같지만 실제로는 구글의 모든 웹 개발자가 알고 있어야 하는 기본적인 내용입니다. 화면에 데이터를 표시하기 위해 필요한 것뿐입니다.\n\n사실, 위의 모든 방어책을 구현하더라도 작동하지 않을 수 있습니다. HEIST 공격은 웹 플랫폼 자체의 수정할 수 없는 설계 결함을 이용하여 심지어 위의 모든 완화 조치를 채택한 웹 앱에서 데이터를 도난당할 수 있게 합니다. 게임 오버입니다.\n\n정말 그렇지 않습니다! 더 나빠집니다! REST/JSON 엔드포인트를 보호하는 것은 현대 웹 개발자가 이해해야 할 다양한 보안 문제 중 하나뿐입니다. 수십 가지 더 있습니다(여기 흥미로운 예제가 있고 다른 재미있는 것이 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 경험상 이 모든 덫 중 하나라도 들어본 웹 개발자를 고용하려고 시도하면 실패로 끝나기 마련이며, 이런 덫을 신뢰할 수 있는 방법으로 회피하는 개발자를 고용하는 것은 더욱 어렵습니다. 그래서 결론은 다음과 같습니다: 안전한 웹 앱을 작성하는 방법을 이해하지 못한 웹 개발자를 고용할 수 없다면 안전한 웹 앱을 작성할 수 없습니다.\n\n# 핵심 문제\n\n거의 모든 웹 보안 문제는 몇 가지 주요 설계 문제에서 발생합니다:\n\n- 길이를 명시하지 않은 버퍼\r\n- 문서가 아닌 앱을 위한 설계된 프로토콜\n- 동일 출처 정책\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버퍼 크기를 잃어버리는 것은 C 프로그램에서 취약점의 전형적인 원인이며 웹도 똑같은 문제를 가지고 있습니다: XSS와 SQL 인젝션 악용은 코드 버퍼가 시작되고 데이터 버퍼가 끝나는 곳이 어디인지 혼란을 야기하는 것에 기반합니다. 웹은 텍스트 프로토콜과 형식에 완전히 의존하기 때문에 버퍼는 반드시 구문 분석되어 길이를 알아내야 합니다. 이는 피할 수 있는 탈출, 대체 및 기타 문제들의 세계를 열어놓습니다.\n\n해결책: 모든 버퍼는 데이터베이스에서 프론트엔드 서버, 사용자 인터페이스로의 이동 과정에서 길이가 사전에 지정되어야 합니다. 끝을 결정하기 위해 어떤 마법적인 문자열을 스캔해야 하는 필요는 없어야 합니다. 이는 전체 스택에서 이진 프로토콜, 형식 및 UI 논리가 필요하다는 것에 유의해주세요.\n\nHTTP와 HTML은 문서를 위해 디자인되었습니다. Egor Homakov이 SMS 코드 입력 필드 안에 간단히 \"../sms\"를 입력하여 Authy의 2요소 인증 제품을 파괴할 수 있었던 이유는 Authy와 같은 모든 웹 서비스가 하이퍼텍스트를 위해 디자인된 스택에 기반에 두고 있기 때문입니다. 경로 이동이 유용한 것은 만약 접근하려는 것이 실제 HTML 파일이 들어 있는 디렉토리 세트라면 하는 것입니다, Sir Tim이 의도한 대로. 프로그래밍 API를 \"문서\"로 제공한다면 경로 이동이 치명적일 수 있습니다.\n\nREST가 XML을 반환했을 때만으로도 충분히 나빴지만 요즘에는 XML이 유행을 타지 않고 웹에서는 대신 JSON을 사용합니다. 이는 실제로 보안 문제에 대해 전체 섹션을 갖고 있는 wiki 페이지가 있는 식으로 설계되어 있어서 매우 나쁘게 디자인된 형식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정: REST를 좋은 아이디어인 것처럼 가정하는 것을 그만두죠. REST는 HTTP를 비틀어서 브라우저의 제약을 우회하기 위해 만들어진 좋은 아이디어가 아니에요. 브라우저까지 변형되어야 할 도구를 다른 용도로 바꾸는 것은 문제가 생길 수밖에 없어요. 이런 접근은 결국 좋은 결말을 가져다주지 않아요. 이전 내용을 고려할 때, 클라이언트/서버 간 통신은 RPC 사용 사례에 특별히 설계된 이진 프로토콜을 사용해야 해요.\n\n동일 출처 정책은 스티븐 킹의 소설에서 나온 것 같은 개발자 경험입니다. 위키에서 인용하자면:\n\nSOP는 넷스케이프가 문서 형식에 코드를 덧붙이면서 생긴 결과입니다. 이것은 실제로 어떤 의미도 갖지 않으며, 무엇보다도 10일 이상의 시간이 주어지지 않는다면 앱 플랫폼을 그렇게 설계하지 않겠죠. 그래도 우리는 자비심을 가지고 있어야 할지도 몰라요. 넷스케이프는 격려되는 시간 압력 속에서 일하는 스타트업이었고, 이미 언급한 대로, 그때는 보안에 대해 생각하는 사람이 별로 없었어요. 10일 코딩 마라톤이 더 심각한 상황을 만들었을 수도 있어요.\n\n우리의 동정을 떠나 SOP는 HEIST 공격의 근간이 되며, HEIST는 실제 웹 앱 거의 모두를 손상시키는 것으로 보이며, 아마 역호환성을 깨지 않고 고칠 수는 없을 겁니다. 이것이 안전한 웹 앱을 작성하는 것이 불가능하다는 하나의 더이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정 사항: 애플리케이션에는 명확한 식별이 필요하며 보안 토큰을 기본 설정으로 서로 공유해서는 안 됩니다. 서버에 액세스 권한이 없다면 해당 서버로 메시지를 보낼 수 없어야 합니다. 웹을 제외한 모든 플랫폼이 이를 올바르게 처리합니다.\n\n웹에는 보안을 어렵게 만드는 다른 디자인 문제들이 있지만, 위의 예시들만으로도 이를 납득시킬 수 있을 것입니다.\n\n# 결론\n\nHTML 5는 우리 산업에 해를 끼치는 요인입니다. 일부 기능은 잘 처리하지만 다른 앱 플랫폼과 쉽게 맞먹을 수 있는 이점도 있지만, 웹의 핵심적인 디자인 결함들은 대부분 수정할 수 없습니다. 따라서 웹은 모바일에서 패배했습니다: 유기적으로 성장하는 대신 실제로 설계된 경쟁 플랫폼이 나왔을 때, 개발자들은 대부분 네이티브 앱으로 전환하는 것을 선택했습니다. 그러나 모바일 외에는 좋은 대안이 없습니다. 데스크탑과 랩톱에 안전하게 분산할 수 있는, 보안된, 자동 업데이트된 앱을 편리하게 배포할 방법이 절실합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10년 전에는 이 기사를 쓴다고 사형당했을 겁니다. 지금에도 약간의 불만소리가 예상되지만, 최근에는 웹을 비판하는 것이 사회적으로 수용되는 것이 되었습니다. 그때는 웹이 Flash, Shockwave 및 Java와 같은 다른 독점적 플랫폼과 경쟁하고 있었습니다. 웹은 열려 있었지만 경쟁 플랫폼으로의 생존은 분명하지 않았습니다. 그러나 최종적으로 부활하고 승리하는 이야기는 우리 모두의 감정을 자극하는 계산된 이야기입니다: 열린 것이 폐쇄된 것보다 낫고, 집단 소유권이 독점보다 낫고, 다윗이 골리앗을 이길 수 있다는 것 등입니다. 많은 프로그래머들은 그것에 대해 족속적 충성심을 느끼게 되었습니다. \"웹\"이라는 단어 앞에 붙이면 급증이었습니다. 매크로미디어 플래시가 실제로 좋을지도 모른다고 제안하면 당신의 게크 카드가 취소될 겁니다.\n\n그러나 시대는 변하고 있습니다. 지금은 웹이 너무 비대해져서 열려있다고 부르는 것은 상당히 의미가 없어졌습니다: 몇 십억 달러를 태우고 싶다면 HTML5를 구현할 수있는 가능성이 없습니다. W3C는 사용자의 요구를 충족시키지 못했으며 지금은 관련이 없어졌습니다. 따라서 구글이나 마이크로소프트에서 일하지 않는 한 웹의 기술적 방향에 의미있는 영향을 미칠 수는 없습니다. 이전에는 닫혀 있던 몇 가지 경쟁 플랫폼도 오픈되었습니다. 그리고 자바스크립트 생태계는 자신의 의미없는 순환의 무게 아래서 붕괴하고 있습니다.\n\n드로잉 보드로 돌아가는 시간입니다. 이제 음료를 가져오고이 시리즈의 다음 기사를 읽어보세요: 웹의 후속편은 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-27-Itstimetokilltheweb_0.png"},"coverImage":"/assets/img/2024-06-27-Itstimetokilltheweb_0.png","tag":["Tech"],"readingTime":9},{"title":"Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법","description":"","date":"2024-06-27 14:23","slug":"2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport","content":"\n\n## 사용자들의 손목에 앱을 확장해보세요\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*I9arFpW6WbVftid8urPmfQ.gif)\n\nReact Native를 사용하여 모바일 앱을 개발하는 것을 모두가 좋아합니다. 왜냐하면 iOS 및 Android 애플리케이션에 널리 사용되는 크로스 플랫폼 통합을 제공하기 때문이죠. 하지만 더 흥미로운 사실을 아시나요?\n\n맞죠! React Native 애플리케이션에서 스마트 워치 기기도 지원한다는 것이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 Apple watchOS 애플리케이션을 React Native 애플리케이션과 통합하는 방법을 배우겠습니다. 더불어, 워치 페이스의 복잡성으로 설정할 수 있는 위젯도 생성할 것입니다.\n\n# 준비물\n\n- React Native, Xcode 및 SwiftUI의 기본 지식\n- watchOS를 지원하는 장치 시뮬레이터가 포함된 Xcode\n\n# 개발 환경 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwatchOS 앱을 React Native 앱에 추가하기 위해 Apple에서 제공하는 IDE인 Xcode를 사용할 거에요.\n\n더불어, Apple이 제공하는 프레임워크인 WatchKit을 사용할 거에요. WatchKit을 이용하면 watchOS 앱을 만들고, 다른 Apple 기기의 앱과 연결하여 작동시킬 수 있어요.\n\n## watchOS 및 위젯을 위한 필수 종속성 설치\n\niOS와 watchOS 앱 간 통신을 구현하기 위해 react-native-watch-connectivity라는 라이브러리를 사용할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 패키지를 설치하려면 프로젝트에 따라 yarn 또는 npm을 사용할 수 있습니다:\n\n```js\nnpm install react-native-watch-connectivity --save\n```\n\n```js\nyarn add react-native-watch-connectivity\n```\n\n코코아팟도 설치하는 것을 잊지 마세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd ios \u0026\u0026 pod install \u0026\u0026 cd ..\n```\n\n다음으로, 우리는 플러스 및 마이너스 버튼이 있는 카운트 변수를 갖는 매우 기본적인 React Native 화면을 생성할 것입니다.\n\n# watchOS 앱 지원 추가\n\n이제 iOS 앱을 설정했으므로, watchOS 앱을 개발하기 시작해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXcode를 열어 iOS 프로젝트를 엽니다. 툴바에서 File - New - Target를 선택합니다.\n\n다음 창이 표시됩니다: 상단 탭에서 watchOS를 선택한 다음 해당 탭에서 App을 선택합니다.\n\n![이미지](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png)\n\n다음으로, watchOS 앱에 대한 자세한 정보를 제공하는 또 다른 창이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 창에서 워치OS 앱의 앱 이름과 번들 식별자를 제공해주세요.\n\n위의 창에서는 이미 기존의 iOS 앱이 있는지 여부를 선택할 수 있습니다. 우리의 경우 iOS 앱 프로젝트가 설정되어 있습니다. 그래서 Watch App for Existing iOS App을 선택하고 아래 드롭다운에서 iOS 앱의 타겟을 선택하겠습니다.\n\nFinish 버튼을 클릭한 후에는 Xcode 프로젝트에 새 폴더가 추가된 것을 알 수 있습니다. 해당 폴더에는 우리의 watchOS 프로젝트 파일이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 워치OS 앱의 UI 디자인\n\n이제 워치OS 애플리케이션의 UI를 디자인하기 시작합니다. 시작하려면 SwiftUI 코드가 포함된 ContentView.swift 파일을 열어주세요.\n\n우리의 SwiftUI 코드에서는 카운터의 값이 표시되는 간단한 텍스트 요소를 표시할 것입니다.\n\n우리의 ContentView는 다음과 같이 보여야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기능 구현하기\n\n이제 iOS 앱과 watchOS 앱 사이의 양방향 통신 메커니즘을 설정해 봅시다.\n\n## iOS 앱에서 watchOS 앱으로 메시지 보내기\n\n- iOS 앱이 발신자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워치OS 앱에 메시지를 보내려면 React Native 앱에 설치된 패키지를 사용해야 합니다.\n\nreact-native-watch-connectivity에서 sendMessage 및 getReachability 함수를 가져와서 시청 가능한 워치여부를 결정하고 count 변수를 워치OS 앱으로 보내기 위해 사용할 수 있습니다.\n\n다음과 같이 버튼 액션을 수정할 것입니다:\n\n- 수신자로서 워치OS 앱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwatchOS 앱이 iOS 앱에서 전송된 메시지를 수신하도록 설정하려면 새 Swift 파일을 만들어 ConnectionHelper.swift로 이름을 지정합시다. 이 클래스를 사용하여 iOS 앱에서 보내는 메시지와 이벤트를 캡처할 것입니다.\n\n먼저 ConnectionHelper라는 클래스를 만들고 그 안에 워치 세션과 이벤트를 설정하겠습니다.\n\n이 코드는 필수 메서드를 구현하도록 강제하여 오류를 발생시킬 것입니다. 우리의 클래스에서 워치 세션 델리게이트를 위해 필요한 메서드를 구현해야 합니다.\n\n코드를 깨끗하게 유지하기 위해 ConnectionHelper 클래스의 확장(extension)을 만들고 거기에 WCSessionDelegate를 구현하세요. 확장(extension)은 아래 표시된 메서드를 반드시 구현해야 한다는 필수 조건이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 WCSession의 활성화 상태에 변경이 있는지 표시하는 데 유용합니다. 이것은 iOS 앱과 페어링된 Apple Watch 간의 통신이 현재 활성화되어 있는지 확인할 수 있다는 뜻입니다. 그렇지 않으면 오류가 발생합니다.\n\n다음 단계는 iOS 앱에서 watchOS 앱으로 전송되는 이벤트 및 메시지를 가져오는 것인데, 이를 위해 확장에서 didReceiveMessage 메서드를 구현할 것입니다. 이제 우리의 ConnectionHelper 확장은 다음과 같이 보여야 합니다:\n\n위에서 선언한 방법을 사용하여 카운터의 값이 업데이트될 것입니다. 먼저 ConnectionHelper 클래스 내에 선언해 봅시다. 이제 우리의 클래스는 다음과 같이 보여야 합니다:\n\n변수 count를 선언하고 Published로 주석을 달고 ObservableObject 프로토콜을 클래스에 구현했습니다. 왜냐하면 이 count 변수가 변경될 때마다 추적하고 싶기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 iOS 앱에서 이벤트를 받을 때마다 count 값을 업데이트하는 로직을 구현해야 합니다. 이를 위해 ConnectionHelper 확장에서 정의한 didReceiveMessage 메서드를 사용할 것입니다.\n\n이제 우리가 counter 변수를 생성했으니, watchOS 앱의 UI 내에서 그것을 사용할 시간입니다. ContentView에서 ConnectionHelper 클래스를 인스턴스화하고 count 속성을 사용하여 텍스트 요소 아래에 표시합니다.\n\n이제 iOS 앱에서 watchOS 앱으로의 일방향 통신이 완료되었습니다.\n\n## watchOS 앱에서 iOS 앱으로 메시지 보내기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- watchOS 앱을 보낸 사람\n\nwatchOS 앱에서 iOS 앱으로 메시지를 보내기 위해, 먼저 ConnectionHelper 클래스 내부에 도우미 함수를 만들겠습니다. 이 함수는 watchOS로부터 이전에 생성한 watch 세션을 통해 count 변수를 메시지로 iOS 앱으로 보낼 것입니다.\n\n다음으로, ContentView 파일을 수정하여 +와 - 텍스트가 있는 버튼을 추가하고 해당 버튼에 동작을 추가할 것입니다. 아래 코드 스니펫에서 보시다시피, count 변수를 수정하고 sendNewCount 함수를 사용하여 iOS 앱으로 전송할 것입니다.\n\n그러나 기다려주세요! 아직은 iOS 앱을 설정하여 watchOS 앱에서 보낸 메시지를 수신할 준비를 마치지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **수신기로 사용되는 iOS 앱**\n\n이러한 수신 메시지를 처리하기 위해서는 먼저 react-native-watch-connectivity 패키지에서 가져온 watchEvents를 사용하여 메시지를 수신 대기해야 합니다.\n\n만세! 여기까지입니다. 이제 두 앱을 실행시켜서 한번 시도해보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1076/1*PqaAgPuCgE1W_RGKEC9r7Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 워치OS 애플리케이션에 위젯 추가하기\n\n## 위젯 익스텐션 타겟 설정\n\n우리의 워치OS 앱에 위젯 지원을 도입하려면 동일한 Xcode 프로젝트에 새로운 타겟을 생성해야 합니다.\n\n프로젝트에 '위젯 익스텐션'이라는 새로운 타겟을 추가할 것이며, 이는 워치OS 타겟과 유사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ReactNativeAppwithAppleWatchWidgetSupport image 2](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_2.png)\n\n다음을 클릭한 후 위젯 대상의 제품 이름을 제공하십시오.\n\n![ReactNativeAppwithAppleWatchWidgetSupport image 3](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_3.png)\n\n위젯 확장 대상을 설정한 후 프로젝트에 새 폴더가 표시됩니다. 이 경우 CounterWidget이라는 이름의 폴더가 있습니다. 이 폴더에는 처음에 AppIntent 및 CounterWidget이라는 두 개의 Swift 파일이 포함되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_4.png\" /\u003e\n\n## 위젯 UI 및 기능 설계 및 구현\n\nUI를 수정하기 전에 먼저 위젯 확장에 count 변수를 설정해보겠습니다.\n\n이를 위해 AppIntent 파일을 열고 currentCount라는 변수를 선언하고 다음 코드 스니펫에 표시된대로 생성자를 설정해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯 UI를 디자인하기 위해 CounterWidget 파일을 열어보세요. 위젯 확장을 생성할 때 Xcode에서 자동으로 생성한 EntryView로 스크롤하세요. 아래에 보여지는 대로 현재 카운트 변수를 보여줄 매우 간단한 텍스트 구성요소를 만들 것입니다:\n\n## watchOS 앱과 위젯 확장 간의 데이터 교환 및 공유\n\n이제 watchOS 앱에서 선언된 현재 카운트 변수를 위젯 UI에 표시하려고 합니다. 그러나 Apple은 watchOS 앱과 위젯 간에 데이터를 교환할 수 있는 직접적인 방법을 제공하지 않습니다. 따라서 우리는 Apple이 제공하는 로컬 저장소인 UserDefaults에 카운트 변수를 저장할 것입니다.\n\nwatchOS 앱과 위젯 확장 사이에서 공유할 단일 속성을 추가하려면 watchOS와 위젯 확장 모두에 App Groups이라는 새 능력을 추가해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 방법을 수행하려면, 프로젝트 설정을 열고, 타겟을 선택한 다음, Signing \u0026 Capabilities 탭을 선택하세요. 그러면 + Capability 버튼을 클릭하여 그 창에서 타겟을 선택하세요.\n\n![image](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_5.png)\n\nApp Groups을 기능으로 추가한 후에는, 이 창 안에 이 섹션이 표시될 것입니다. 이제 + 버튼을 눌러 식별자를 추가하세요.\n\n![image](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 여러 대상에서 사용되고 프로젝트에서 데이터가 저장되고 사용될 컨테이너에 대한 유효한 식별자(또한 UserDefaults의 스위트 이름으로 사용될 것)를 제공해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_7.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_8.png\" /\u003e\n\nCounterWidget 파일에는 사용자 인터페이스(UI)를 관리하는 모든 로직과 해당 기능이 포함될 것입니다. 그러나, 주요 기능은 지정된 간격으로 위젯의 UI를 새로 고치는 timeline 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞으로 나아가면, 우리 앱 그룹이 준비되었으니, watchOS 앱과 위젯 익스텐션 간에 데이터를 공유하기 위한 메커니즘을 설정해 봅시다.\n\nwatchOS 타겟 폴더에 선언된 ConnectionHelper 클래스 내부에 appCount라는 새 변수를 선언할 것이며, 이 변수는 UserDefaults를 사용하여 AppStorage로 주석이 달릴 것입니다. 아래와 같이:\n\n또한, appCount 변수가 작동하도록 하기 위해, count가 변경될 때마다 새로운 값을 할당할 것입니다.\n\n다음 단계에서, 위젯의 UI 내에 이를 표시하고 싶다면, 위젯의 Timeline Provider를 수정해야 합니다. 이를 위해 CounterWidget 파일 내의 미리 생성된 Provider 구조로 이동하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 해당 구조체의 범위 내에서 appCount 변수를 선언하고 프로바이더 함수를 아래와 같이 수정해야 합니다:\n\n찬양하리로다! 우리는 성공적으로 watchOS 앱의 위젯 확장 프로그램을 설정하여 카운트 값을 표시했습니다. 이제 실행해서 시도해 보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:554/1*4W6YaN1I5FIM0FKJHUZ2BA.gif)\n\n이제 iOS 애플리케이션에서 카운트를 수정해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1196/1*u8y-X3CelS4YDm0JLFuIdg.gif)\n\n# 결론\n\nReact Native 앱을 watchOS와 연동하고 워치 페이스용 위젯을 지원하는 데 성공했습니다.\n\n이제 WatchKit과 WidgetKit을 사용하여 멋진 앱을 만들어보세요. 아이디어와 프로젝트를 아래 댓글에서 공유해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩! 😉","ogImage":{"url":"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png"},"coverImage":"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png","tag":["Tech"],"readingTime":8},{"title":"브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구","description":"","date":"2024-06-26 12:20","slug":"2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI","content":"\n브라우저에서 강력한 AI를 직접 사용할 수 있다면 어떻겠어요? WebGPU와 유사하지만 크롬이 모든 것을 처리해줍니다. 외부 서비스에 의존하거나 서버를 설정하거나 대용량 파일을 다운로드할 필요가 없어요. 이겔 시작하려고 600MB 모델을 다운로드하는 것이 아니에요. 이것은 브라우저에서 직접할 수 있는 것을 재정의하는 혁신적인 방법입니다.\n\n구글 크롬의 새로운 실험적 기능인 Gemini Nano용 Prompt API는 브라우저 내 AI 도구의 미래를 엿보게 해줍니다. 텍스트 요약, 문장 재구성, 정보 분류 등의 빠르고 간편한 작업에 뛰어나며 온라인에서 읽는 모든 것에 빠르게 통찰을 추가하는 데 완벽합니다. 그러나 이 도구는 코드를 다른 프로그래밍 언어로 변환하는 등 더 복잡한 작업을 위해 만들어진 것이 아닙니다. 더 간단한 응용에 대한 기능은 인상적이지만, 보다 요구되는 도전에는 한계가 있습니다.\n\n다음은 설정하는 방법입니다:\n\n- 최신 버전의 Google Canary를 다운로드합니다.\n- 주소 표시줄에 `chrome://flags`를 입력합니다.\n- \"Prompt API for Gemini Nano\"를 찾은 후 설정을 'Enabled'로 변경합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png\" /\u003e\n\n- \"Enables optimization guide on device\"을 검색하여 'Enabled'로 설정하세요.\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_1.png\" /\u003e\n\n- '다시 시작' 버튼을 클릭하여 브라우저를 다시 시작하세요.\n- 브라우저를 다시 열면 주소 표시줄에 `chrome://components/`을 입력한 후 \"Optimization Guide On Device Model\"을 찾고 '업데이트 확인'을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드를 Markdown 포맷으로 변경하였습니다.\n\n\n![이미지](/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_2.png)\n\n이미지가 다운로드를 시작하는 것을 확인할 수 있습니다. 다운로드가 완료될 때까지 기다려주세요.\n\n지금 모든 것이 작동되는 것을 보려면:\n\n- 개발자 도구를 여는 방법: 웹페이지에서 개발자 도구를 열고, 프롬프트를 사용할 세션을 설정하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst session = await window.ai.createTextSession();\n```\n\n- 질문을 해주세요\n\n```js\nsession.prompt(\"아재 개그 하나 알려줄래?\").then(console.log);\n```\n\n웃음이 절로 나올 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_3.png\" /\u003e\n\n우리는 이러한 함수로 우리의 JS 앱을 통합할 수 있어요\n\n```js\nasync function getAnswer(question) {\n  try {\n    const session = await window.ai.createTextSession();\n\n    const aiResponse = await session.prompt(question);\n\n    return aiResponse;\n  } catch (e) {\n    throw new Error(\"세션 생성 중 오류 발생, AI가 활성화되지 않았습니다.\");\n  }\n}\n```\n\n작은 Next.js 앱은 https://chrome-llm-local-nextjs-git-main-muthukumaran-ns-projects.vercel.app/ 에서 이용 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_4.png\" /\u003e\n\n깃허브에서 소스 코드를 확인하세요: https://github.com/muthuishere/chrome-llm-local-nextjs\n\n현재 Gemini Nano용 Prompt API는 Google Chrome Canary에서 실험적인 기능으로 제공됩니다. 더 넓은 Chrome 릴리스로 넘어가거나 그렇지 않을 수도 있지만, 이 이니셔티브는 더욱 개인 정보 보호가 강화된 효율적인 웹 상호작용을 위한 중요한 한 걸음입니다. Google은 브라우저 내에서 AI를 직접 실행함으로써, 데이터가 기기를 벗어나지 않고도 유용한 AI 기반 통찰력을 생성하는 미래로 향하는 길을 열어두고 있습니다. 이는 개인 정보 보호를 향상시키는 것뿐만 아니라 더 빠른 응답 시간을 보장하기도 합니다. 이 기능을 오늘 실험해 보면 브라우저 능력의 잠재력을 보다 명확하게 볼 수 있을 것입니다. 로컬 모델이 매일의 디지털 상호작용을 혁신시키면서도 데이터 보안을 희생하지 않을 수 있는 브라우저 능력의 잠재적 미래를 엿볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png"},"coverImage":"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png","tag":["Tech"],"readingTime":3},{"title":"Typescript 런타임 설정 완벽 마스터하는 방법","description":"","date":"2024-06-24 02:24","slug":"2024-06-24-MasteringTypescriptRuntimeConfigurations","content":"\n\n모든 사람이 경력 초반에 배우는 구성은 중요합니다. 대부분의 사람들은 처음에 배운 방법을 고수합니다. 저는 웹 개발을 10년 이상 해왔고, 무수히 많은 구성 방법을 보았습니다. 오늘은 여러분의 앱 구성을 좀 더 쉽게 만들어드리고, 물론 제 새로운 패키지 https://github.com/mrspartak/config 를 홍보하기 위해 여기에 왔습니다.\n\n![이미지](/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png)\n\n저는 풀 스택 개발자이지만, 백엔드와 프론트엔드 구성을 실제로 구분하지 않습니다. 둘 다 빌드 시간 및 실행 시간 구성을 사용할 수 있기 때문에 유사합니다. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 것입니다. 다음 섹션에 있는 통찰은 매우 주관적이므로, 다른 의견이 있으면 댓글로 의견을 공유해 주시면 감사하겠습니다.\n\n## 빌드 시간 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드에서는 빌드 시간 구성이 그리 흔하지는 않지만, 프론트엔드에서는 상당히 인기 있는 방식입니다. 여기에서는 구성 값을 패키지나 이미지에 포함하여 응용 프로그램을 실행하는 데 충분하게 활용합니다. 제게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서의 IO 작업 동작에 영향을 주는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif)\n\n그러나 어떤 사람들은 API 엔드포인트, 인증 키 등 외부 구성 요소를 빌드 시간에 포함하는 것이 너무 멀리간다고 생각합니다. 이 방식은 작동하지만, 각 환경별로 패키지 또는 이미지를 다시 빌드하고 테스트해야 하므로 빌드 사이에 불일치가 발생할 수 있습니다.\n\n## 런타임 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 곳이 백엔드의 진정한 빛이 나오는 곳입니다. 그러나 SSR (서버 측 렌더링) 및 SPA (단일 페이지 어플리케이션) 프론트 엔드에서 런타임 구성을 자주 사용합니다. 앱이 로드되는 가장 처음에 실행 구성 정보가 로드됩니다. 런타임 구성은 모든 외부 구성을 포함해야 하며, 환경에 따라 크게 다를 수 있습니다. 여기서 일회성 환경의 장점이 발휘되며, 더 큰 유연성과 적응성을 제공합니다.\n\n## 어떻게 구성하나요?\n\n그래서 구성이 정확히 무엇인가요? 네, 당신은 `.env` 파일을 알고 계시죠... 또는 `.toml`. 아마도 `.json` 또는 `.ini`도요? 음, 그냥 `.ts` 파일을 만들고 그 안에서 객체를 내보내겠습니다. 하지만 기다려주세요. 그 파일을 git에 커밋해야 할까요? 각 환경 당 파일을 만들어 비밀 데이터를 커밋해야 할까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 어떤 형식이 가장 좋은지를 두고 전쟁을 일으킬 수 있지만, 사실 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 형식이라면 충분하죠. 당신이 사용하기 편한 형식으로 선택하세요. 하지만 저장 및 사용 전략은 상당히 중요합니다.\n\n저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 순수한 Docker를 사용한다면 아마도 설정 및 비밀키에 익숙할 것입니다. 이를 통해 코드와 함께 실행 중인 컨테이너에 어떤 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경으로 새 구성을 배포할 때 발생한다고 보아요.\n\n## 유효성 검사, 유효성 검사, 유효성 검사\n\n구성은 선언부터 시작돼요. 정말 간단하죠. 백엔드에서 데이터베이스를 호출해야 한다면, 해당 데이터베이스에 인증하는 데 필요한 것을 파악하고 구성 선언에 넣으세요. 그 결과로 얻는 것은 - 어플리케이션이 다운될 때입니다. 하지만 이것이 우리가 원하는 것이에요. 이를 통해 누락되거나 잘못된 구성을 조기에 식별할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif\" /\u003e\n\n그 다음으로, 물론 구성 파일에 필요한 필드를 추가하시게 됩니다. 여러분은 어떤 유효성 검사 라이브러리든 사용하시거나, 더 좋은 방법으로는 (몰래 광고 주의!) 제 라이브러리를 사용하여 유효성을 처리할 수 있습니다.\n\n## 병합은 때로는 시간을 절약할 수 있습니다\n\n기본 PORT를 설정하는 것을 잊었을 때 항상 기본값이 있는데요, 어떻게 하면 좋을까요? 당연히 그 기본값을 정의하겠죠. 그렇다면 이후에 그들을 어떻게 병합할까요? 단순히 lodash를 사용하시거나, 더 좋은 방법으로는 (무언가를 여러 차례 언급하면 짜증나는 것에서 당신이 생각하는 방식으로 변화한다고 들었습니다) 제 라이브러리를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발자에게 무엇을 할 수 있을까요? 더 좋은 것을 받을 수 있을까요?\n\n물론 가능합니다. 물어주셔서 감사합니다. 저의 메인 언어(도움을 부탁드려요)가 TypeScript인 지금, 제게 제일 잘 맞는 것을 얻고 싶어해요. 상상해보세요! 전체 구성이 타이핑된 채로 보일 수 있어요. 와우. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 훌륭한 삶을 살고 있어요. 제 라이브러리는 어떤 유효성 검사 라이브러리든 가져다 사용할 수 있게 해주고, 그것들은 모두 Out of the box로 작동할 거예요.\n\ntrpc의 개발자에게 큰 칭찬을 보내요 - 그는 천재에요. 유효성 검사의 결과로 구성을 추론하기 위해 그의 코드를 그대로 복사하거나 도용할 수 있어요. 마법 같죠.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발 환경을 언급하셨군요. 커밋할까요?\n\n아니요. 절대 그러지 마세요. 제가 바로 OPENAPI_KEY를 훔쳐갈 거에요. 일주일 후면 길거리에서 구걸하게 될 거에요. 비밀 보관 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org 및 다른 멋진 프로젝트들이 안전하게 비밀을 보관하고 공유할 수 있게 해줍니다.\n\n패키지.json에 설치 스크립트를 포함하여 정확한 버전의 비밀을 다운로드할 수 있게 하세요. 또한 업로드 스크립트도 추가해서 버전을 업그레이드하고 git에서 충돌을 피할 수 있도록 해주세요. 나중에 감사의 인사를 드릴게요. 저는 이 방법을 여러 년간 사용해왔고 로컬 구성을 USB 드라이브나 Slack을 통해 공유하는 것으로는 돌아갈 수 없을 거에요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 알겠어요, 이제 다른 부풀린 npm 패키지에 대해 이야기해 주세요\n\n사실, 이 패키지는 의존성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용한다고 가정합니다. 일반적으로 이 패키지는 위에서 언급한 모든 문제를 해결합니다 (물론 개발 환경은 제외하고), 아래와 같은 기능을 제공합니다:\n\n- 3가지 데이터 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 처리합니다.\n- 런타임 유효성 검사: Zod, Superstruct, Yup 등과 같은 인기있는 라이브러리와 호환됩니다.\n- TypeScript IntelliSense: 유효성 검사 라이브러리에서의 변환기를 고려하고 해결된 유효성 검사에 대한 모든 힌트를 제공합니다.\n- 병합: 왜냐하면 가능한 이유가 있잖아요? 디폴트를 분리하여 가지고 있으면 상당히 멋집니다. 항상 유효성 검사자 스키마에 기본값을 넣을 수 있지만, 그러면 코드에 저장됩니다.\n- 완전히 테스트됨: 프로덕션에 사용할 준비가 되어 있으며 이미 여러 응용 프로그램에서 사용 중입니다.\n- 백엔드 및 프론트엔드 친화적: 두 환경 모두에서 원활하게 작동합니다.\n\n```js\n// 파일: state/config.ts\nimport { fromJSONFile } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst config = await fromJSONFile({\n  path: [\"../config/default.json\", \"../config/runtime.json\"],\n  schema: z.object({\n    db: z.object({\n      host: z.string(),\n      port: z.number(),\n      username: z.string(),\n      password: z.string()\n    }),\n    app: z.object({\n      port: z.number().optional().default(3000)\n    })\n  }),\n});\n\nexport default config\n\n\n\n// 파일: index.ts\n// 해결된 구성을 가져오세요\nimport config from './state/config.js';\n\n// 응용 프로그램에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그런데 JSON 지원만 보여요. system crap 환경 변수를 아름답게 하려면 어떻게 하죠?\n\n객체와 함께 작업을 지원하므로 env 객체를 함수에 전달하면 됩니다. 다른 .env 파서를 다시 작성하는 것이 이상할 것입니다. 이미 시험된 많은 파서가 시장에 있으니까요\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    NODE_ENV: z.enum([\"development\", \"production\"]),\n    DB_HOST: z.string(),\n    DB_PORT: z.number(),\n    DB_USER: z.string(),\n    DB_PASSWORD: z.string(),\n    APP_PORT: z.number().default(3000),\n  })\n  .transform((data) =\u003e ({\n    environment: data.NODE_ENV,\n    port: data.APP_PORT,\n    db: {\n      host: data.DB_HOST,\n      port: data.DB_PORT,\n      user: data.DB_USER,\n      password: data.DB_PASSWORD,\n    },\n  }));\n\nconst config = await fromObject({\n  data: process.env,\n  schema\n})\n\nexport default config\n\n// 파일 index.ts\nimport 'dotenv/config'\n// ! dotenv 이후에 설정이 로드되어야 하므로 process.env가 채워질 겁니다\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n## frontend를 언급했는데 node 파일 API를 확실히 사용했기 때문에 빌드가 중단될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 당신이 요청한 작업을 수행해드릴 수 있어요. (만약 더 나은 해결책을 아시는 분이 계시다면, 연락주세요)\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config/web\"; // 라이브러리의 별도 빌드\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    API_URL: z.string(),\n  })\n\nconst config = await fromObject({\n  data: import.meta.env, // vite를 사용한 예시 \n  schema\n})\n\nexport default config\n```\n\n![](https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif)\n","ogImage":{"url":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png"},"coverImage":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript에서 속성 가져오고 설정하는 방법","description":"","date":"2024-06-23 14:43","slug":"2024-06-23-JavaScriptGettingSettingsAttributes","content":"\n\n지난 기사에서는 요소나 요소들의 내부 텍스트와 내부 HTML을 변경하는 방법을 다뤘어요. 이 기사에서는 해당 요소들의 속성을 가져오고 설정하는 방법에 대해 다룰 거에요.\n\n![image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png)\n\n여기에는 href 속성이 있는 a 태그와 class 속성이 있는 p 태그가 있어요. JavaScript에서 가져오거나 설정할 수 있는 여러 가지 속성이 있어요. 이제 a 태그에서 href 속성을 가져와 보겠어요.\n\n![image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 a 태그에 대한 참조를 link라는 상수에 저장했어요. 그런 다음 link.getAttribute()를 기록하고 있어요. 이 방법에 href라는 문자열을 제공했어요. 브라우저 콘솔을 확인하면 그 값이 출력됩니다.\n\n이제 값을 설정해 보겠어요.\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_2.png\" /\u003e\n\nGoogle로 이동하는 대신 Yahoo로 이동하도록 말했어요. 브라우저에서 이 요소를 검사하면 값이 변경된 것을 볼 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_3.png\" /\u003e\n\n또 다른 예시:\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_4.png\" /\u003e\n\n여기서 p 태그를 잡아서 속성을 success로 변경하고 있어요. 이를 엘리먼트에서 검사해보면 속성이 변경된 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_5.png)\n\n이것은 무언가가 작동했는지 여부를 표시하는 데 유용할 수 있습니다. 그렇지 않으면 오류가 있으므로 메시지 색상을 빨간색으로 변경하거나 작동했으면 메시지 색상을 녹색으로 변경할 수 있습니다.\n\n이제 이미 존재하지 않는 html 요소에 속성을 설정합시다. JavaScript를 통해 p 태그에 스타일 속성을 추가하겠습니다.\n\n![Image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 style 속성을 추가하여 텍스트 색상을 녹색으로 설정합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_7.png\" /\u003e\n\n실용적인 예는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘 확인만 할 불(bool)이 있어요. 이 불 값을 true로 설정하면 텍스트가 초록색으로 바뀌고 \"You Win!\"이라고 나와요. 그리고 false로 바꾸면 텍스트가 빨간색으로 바뀌고 \"You Lose!\"라고 나와요!\n\n![이미지 1](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_9.png)\n\n![이미지 2](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_10.png)\n\n나중에 다룰 글에서 런타임시에 어떻게 동적으로 것들을 바꿀 수 있는지 다룰 거에요.","ogImage":{"url":"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png"},"coverImage":"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML 링크의 종류와 사용 방법","description":"","date":"2024-06-23 14:43","slug":"2024-06-23-LinksinHTMLTypesandUses","content":"\n\nHTML의 링크는 웹사이트 내에서의 탐색과 연결을 가능하게 하는 가장 중요한 요소 중 하나입니다. 이들은 웹페이지간이나 문서, 이미지, 비디오 등 외부 소스로의 하이퍼링크 생성에 사용됩니다. 이 블로그 포스트에서는 HTML의 링크가 무엇이며, 어떻게 작동하는지, 그리고 사용 가능한 다양한 종류의 HTML 링크에 대해 살펴볼 것입니다.\n\n![LinksinHTMLTypesandUses_0](/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png)\n\n## HTML에서의 링크란?\n\nHTML에서의 링크는 사용자가 하이퍼링크를 클릭하여 웹사이트를 탐색할 수 있는 요소입니다. 하이퍼링크는 사용자를 새 웹페이지, 문서 또는 자원으로 이동시키는 클릭 가능한 요소입니다. 이는 \"anchor(앵커)\"를 나타내는 HTML `a` 태그를 사용하여 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하이퍼링크는 목적지 웹페이지나 리소스의 URL을 `a` 태그에 추가하여 만듭니다. 사용자가 하이퍼링크를 클릭하면 브라우저가 새 탭이나 창에서 목적지 웹페이지나 리소스를 엽니다.\n\n## HTML에서 링크는 어떻게 작동하나요?\n\nHTML에서 링크는 HTML 코드와 사용자의 웹 브라우저를 함께 사용하여 작동합니다. HTML 코드는 목적지 웹페이지나 리소스의 URL과 링크로 표시될 텍스트를 지정하여 하이퍼링크를 정의합니다. 사용자의 웹 브라우저는 이 정보를 사용하여 사용자가 클릭하여 목적지 웹페이지나 리소스로 이동할 수 있는 클릭 가능한 링크를 만듭니다.\n\n## HTML에서 다양한 유형의 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML에는 각각의 특정 사용과 목적을 갖는 여러 유형의 링크가 있습니다. 이 섹션에서는 HTML에서 가장 일반적인 유형의 링크 몇 가지를 살펴보겠습니다.\n\n- 내부 링크: 내부 링크는 하나의 웹페이지를 같은 웹사이트 내의 다른 페이지에 연결하는 하이퍼링크입니다. 내부 링크는 주로 내비게이션 메뉴를 만들거나 관련 페이지에 대한 링크를 제공하거나 특정 주제에 대한 추가 정보를 사용자에게 제공하기 위해 사용됩니다.\n\n내부 링크는 HTML `a` 태그와 대상 페이지의 상대적인 URL을 사용하여 생성됩니다. 예를 들어, 웹사이트 내의 \"about.html\"이라는 페이지에 링크를 만들고 싶은 경우 다음 코드를 사용할 수 있습니다:\n\n```js\n\u003ca href=\"about.html\"\u003eAbout\u003c/a\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 \"About\" 링크를 클릭하면 동일한 웹 사이트 내의 \"about.html\" 페이지로 이동하게 됩니다.\n\n![링크 이미지](/assets/img/2024-06-23-LinksinHTMLTypesandUses_1.png)\n\n2. 외부 링크: 외부 링크는 한 웹페이지를 다른 웹사이트의 페이지와 연결하는 하이퍼링크입니다. 이들은 주제에 대한 추가 정보나 자원을 사용자에게 제공하는 데 자주 사용됩니다.\n\n외부 링크는 HTML `a` 태그와 대상 페이지의 전체 URL을 사용하여 생성됩니다. 예를 들어, \"HTML\" 위키백과 페이지에 대한 링크를 만들고 싶다면 다음 코드를 사용하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[HTML on Wikipedia](https://en.wikipedia.org/wiki/HTML)\n```\n\n사용자가 \"위키백과의 HTML\" 링크를 클릭하면 \"HTML\" 위키백과 페이지로 이동합니다.\n\n3. 이미지 링크: 이미지 링크는 클릭 가능한 요소로 이미지를 사용하는 하이퍼링크입니다. 시각적으로 매력적인 내비게이션 메뉴를 만들거나 관련 페이지로 연결하는 데 일반적으로 사용됩니다.\n\n이미지 링크는 HTML `a` 태그와 `img` 태그를 사용하여 만듭니다. 예를 들어, 웹 사이트 내 \"contact.html\"이라는 페이지로 이미지 링크를 만들고 싶다면 다음 코드를 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[Contact Us](contact.html)\n```\n\n사용자가 \"Contact Us\" 이미지를 클릭하면 동일한 웹사이트 내의 \"contact.html\" 페이지로 이동됩니다.\n\n4. 이메일 링크: 이메일 링크는 사용자가 웹페이지에서 직접 이메일을 보낼 수 있는 하이퍼링크입니다. 웹사이트 소유자에게 연락하는 방법을 제공하거나 피드백을 보내는 데 일반적으로 사용됩니다.\n\n이메일 링크는 HTML `a` 태그와 \"mailto\" 프로토콜을 사용하여 생성됩니다. 예를 들어 사용자가 \"info@example.com\"로 이메일을 보낼 수 있는 이메일 링크를 만들고 싶다면 다음 코드를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[info@example.com](mailto:info@example.com)\n```\n\n\"Contact Us\"를 클릭하면 사용자의 기본 이메일 클라이언트가 \"To\" 필드가 \"info@example.com\"으로 채워진 상태로 열립니다.\n\nHTML의 링크는 사용자 친화적이고 기능적인 웹 사이트를 만드는 데 중요한 부분입니다. 이를 통해 사용자는 웹 사이트를 탐색하고 문서, 이미지, 동영상과 같은 외부 리소스와 연결할 수 있습니다.\n\n![Links in HTML Types and Uses](/assets/img/2024-06-23-LinksinHTMLTypesandUses_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTML 링크의 활용\n\nHTML에서의 링크는 웹 개발의 기본 구성 요소로, 웹 사이트 내에서의 탐색과 연결성을 가능하게 합니다. 사용자에게 웹 페이지 간 이동, 외부 자원 접근, 웹 사이트 요소와의 상호 작용을 제공합니다. 이 섹션에서는 HTML에서 링크를 사용하는 몇 가지 일반적인 방법을 살펴볼 것입니다.\n\n- 내비게이션: HTML 링크의 주요 용도 중 하나는 웹 사이트 내에서의 내비게이션을 제공하는 것입니다. 내부 링크는 동일한 웹 사이트 내의 다른 페이지로 연결하는 데 사용되어 사용자가 쉽게 웹 페이지 간 이동할 수 있도록 합니다. 내비게이션 메뉴, 브레드크럼 트레일, 내부 링크 전략은 모두 내비게이션 용도로 링크를 사용하는 일반적인 예시입니다.\n- 외부 자원: HTML에서의 링크는 또한 문서, 이미지, 비디오, 다른 웹 사이트와 같은 외부 자원에 대한 사용자 접근을 제공하는 데 사용됩니다. 외부 링크는 다른 웹 사이트의 페이지에 현재 웹 페이지를 연결하여 사용자가 동일한 웹 사이트에 호스팅되지 않은 자원에 접근할 수 있도록 합니다. 이는 주제나 제품과 관련된 추가 정보나 자원을 제공하는 데 흔히 사용됩니다.\n- 호출-투-액션: HTML 링크는 호출-투-액션(CTA) 요소로도 사용할 수 있으며, 사용자가 구매를 하거나 뉴스레터 구독과 같은 특정 동작을 취할 수 있도록 장려합니다. CTA 링크는 일반적으로 웹 페이지의 다른 링크와 시각적으로 구분되도록 설계되며, 색상, 글꼴 크기, 배치와 같은 기법을 사용하여 링크에 주목을 끕니다.\n- 이미지 링크: HTML에서의 링크는 이미지와 결합하여 웹 페이지에서 시각적으로 매력적이고 인터랙티브한 요소를 만들어낼 수 있습니다. 이미지 링크는 일반적으로 내비게이션 목적으로 사용되며, 관련 페이지로 연결하거나 사용자가 외부 자원에 액세스하도록 합니다. HTML `a` 태그와 `img` 태그를 사용하여 이미지 링크를 만들 수 있습니다.\n- 이메일 링크: HTML에서의 링크를 사용하여 사용자가 웹 사이트 소유자에게 연락하는 방법을 제공하거나 피드백을 보내는 데 사용할 수도 있습니다. 이메일 링크는 \"mailto\" 프로토콜을 사용하여 특정 이메일 주소가 기재된 사용자의 기본 이메일 클라이언트를 엽니다.\n\nHTML에서의 링크는 사용자 친화적이고 기능적인 웹 사이트를 만드는 데 있어서 필수적인 부분입니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크는 HTML에서 사용되는 가장 일반적인 유형의 링크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-LinksinHTMLTypesandUses_3.png)\n\n## 결론\n\nHTML에서의 링크는 웹 개발의 중요한 구성 요소로, 웹 사이트 내에서의 네비게이션과 연결을 가능하게 합니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크는 HTML에서 가장 일반적으로 사용되는 링크 유형이며, 각각의 용도와 목적이 있습니다. 링크를 효과적으로 활용하는 방법을 이해함으로써, 웹 개발자는 사용자의 요구를 충족시키는 효과적이고 효율적인 웹 사이트를 만들 수 있습니다.\n\nCronJ는 HTML 개발 분야의 전문가로, 비즈니스에게 효과적이고 효율적인 웹 사이트를 만들기 위한 전문 지식과 자원을 제공합니다. 품질, 효율성, 고객 만족도에 중점을 둔 CronJ는 비즈니스에 최고의 HTML 개발 솔루션을 제공하기 위해 노력하고 있습니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크가 필요하다면, CronJ는 HTML 개발 요구 사항을 충족시키기 위한 전문 지식과 자원을 보유하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- [https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks)\n- HTML 링크\n- HTML 입력 유형\n- HTML 튜토리얼\n- HTML 입력 유형: 최선의 실천법 및 팁 | Olga Green | 2023년 3월 | Medium","ogImage":{"url":"/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png"},"coverImage":"/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png","tag":["Tech"],"readingTime":5}],"page":"4","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>