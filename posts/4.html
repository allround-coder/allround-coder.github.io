<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" href="/post/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 26, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Typescript 런타임 설정 완벽 마스터하는 방법" href="/post/2024-06-24-MasteringTypescriptRuntimeConfigurations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Typescript 런타임 설정 완벽 마스터하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Typescript 런타임 설정 완벽 마스터하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Typescript 런타임 설정 완벽 마스터하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 24, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 속성 가져오고 설정하는 방법" href="/post/2024-06-23-JavaScriptGettingSettingsAttributes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 속성 가져오고 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 속성 가져오고 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 속성 가져오고 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 링크의 종류와 사용 방법" href="/post/2024-06-23-LinksinHTMLTypesandUses"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 링크의 종류와 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 링크의 종류와 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 링크의 종류와 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기" href="/post/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS에서 테두리 속성 다루는 방법" href="/post/2024-06-23-EngineeringBorderPropertiesinCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS에서 테두리 속성 다루는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS에서 테두리 속성 다루는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS에서 테두리 속성 다루는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="반응형 이미지와 동적 미디어 제대로 구현하기  Part III" href="/post/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="반응형 이미지와 동적 미디어 제대로 구현하기  Part III" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="반응형 이미지와 동적 미디어 제대로 구현하기  Part III" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">반응형 이미지와 동적 미디어 제대로 구현하기  Part III</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법" href="/post/2024-06-23-JavaScriptChangingandAddingPageContent"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iframe과 부모 앱 간의 통신 방법" href="/post/2024-06-23-Communicationbetweeniframeanditsparentapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iframe과 부모 앱 간의 통신 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iframe과 부모 앱 간의 통신 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">iframe과 부모 앱 간의 통신 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PDF 분할 로드  풀스택 솔루션 안내" href="/post/2024-06-23-PDFSliceLoadingFullStackSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PDF 분할 로드  풀스택 솔루션 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PDF 분할 로드  풀스택 솔루션 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PDF 분할 로드  풀스택 솔루션 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link posts_-active__YVJEi" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"브라우저에서 AI 활용하기 2024년 Google Chrome의 새로운 Prompt API 탐구","description":"","date":"2024-06-26 12:20","slug":"2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI","content":"\n브라우저에서 강력한 AI를 직접 사용할 수 있다면 어떻겠어요? WebGPU와 유사하지만 크롬이 모든 것을 처리해줍니다. 외부 서비스에 의존하거나 서버를 설정하거나 대용량 파일을 다운로드할 필요가 없어요. 이겔 시작하려고 600MB 모델을 다운로드하는 것이 아니에요. 이것은 브라우저에서 직접할 수 있는 것을 재정의하는 혁신적인 방법입니다.\n\n구글 크롬의 새로운 실험적 기능인 Gemini Nano용 Prompt API는 브라우저 내 AI 도구의 미래를 엿보게 해줍니다. 텍스트 요약, 문장 재구성, 정보 분류 등의 빠르고 간편한 작업에 뛰어나며 온라인에서 읽는 모든 것에 빠르게 통찰을 추가하는 데 완벽합니다. 그러나 이 도구는 코드를 다른 프로그래밍 언어로 변환하는 등 더 복잡한 작업을 위해 만들어진 것이 아닙니다. 더 간단한 응용에 대한 기능은 인상적이지만, 보다 요구되는 도전에는 한계가 있습니다.\n\n다음은 설정하는 방법입니다:\n\n- 최신 버전의 Google Canary를 다운로드합니다.\n- 주소 표시줄에 `chrome://flags`를 입력합니다.\n- \"Prompt API for Gemini Nano\"를 찾은 후 설정을 'Enabled'로 변경합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png\" /\u003e\n\n- \"Enables optimization guide on device\"을 검색하여 'Enabled'로 설정하세요.\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_1.png\" /\u003e\n\n- '다시 시작' 버튼을 클릭하여 브라우저를 다시 시작하세요.\n- 브라우저를 다시 열면 주소 표시줄에 `chrome://components/`을 입력한 후 \"Optimization Guide On Device Model\"을 찾고 '업데이트 확인'을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드를 Markdown 포맷으로 변경하였습니다.\n\n\n![이미지](/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_2.png)\n\n이미지가 다운로드를 시작하는 것을 확인할 수 있습니다. 다운로드가 완료될 때까지 기다려주세요.\n\n지금 모든 것이 작동되는 것을 보려면:\n\n- 개발자 도구를 여는 방법: 웹페이지에서 개발자 도구를 열고, 프롬프트를 사용할 세션을 설정하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst session = await window.ai.createTextSession();\n```\n\n- 질문을 해주세요\n\n```js\nsession.prompt(\"아재 개그 하나 알려줄래?\").then(console.log);\n```\n\n웃음이 절로 나올 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_3.png\" /\u003e\n\n우리는 이러한 함수로 우리의 JS 앱을 통합할 수 있어요\n\n```js\nasync function getAnswer(question) {\n  try {\n    const session = await window.ai.createTextSession();\n\n    const aiResponse = await session.prompt(question);\n\n    return aiResponse;\n  } catch (e) {\n    throw new Error(\"세션 생성 중 오류 발생, AI가 활성화되지 않았습니다.\");\n  }\n}\n```\n\n작은 Next.js 앱은 https://chrome-llm-local-nextjs-git-main-muthukumaran-ns-projects.vercel.app/ 에서 이용 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_4.png\" /\u003e\n\n깃허브에서 소스 코드를 확인하세요: https://github.com/muthuishere/chrome-llm-local-nextjs\n\n현재 Gemini Nano용 Prompt API는 Google Chrome Canary에서 실험적인 기능으로 제공됩니다. 더 넓은 Chrome 릴리스로 넘어가거나 그렇지 않을 수도 있지만, 이 이니셔티브는 더욱 개인 정보 보호가 강화된 효율적인 웹 상호작용을 위한 중요한 한 걸음입니다. Google은 브라우저 내에서 AI를 직접 실행함으로써, 데이터가 기기를 벗어나지 않고도 유용한 AI 기반 통찰력을 생성하는 미래로 향하는 길을 열어두고 있습니다. 이는 개인 정보 보호를 향상시키는 것뿐만 아니라 더 빠른 응답 시간을 보장하기도 합니다. 이 기능을 오늘 실험해 보면 브라우저 능력의 잠재력을 보다 명확하게 볼 수 있을 것입니다. 로컬 모델이 매일의 디지털 상호작용을 혁신시키면서도 데이터 보안을 희생하지 않을 수 있는 브라우저 능력의 잠재적 미래를 엿볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png"},"coverImage":"/assets/img/2024-06-26-AIWithinYourBrowserExploringGoogleChromesNewPromptAPI_0.png","tag":["Tech"],"readingTime":3},{"title":"Typescript 런타임 설정 완벽 마스터하는 방법","description":"","date":"2024-06-24 02:24","slug":"2024-06-24-MasteringTypescriptRuntimeConfigurations","content":"\n\n모든 사람이 경력 초반에 배우는 구성은 중요합니다. 대부분의 사람들은 처음에 배운 방법을 고수합니다. 저는 웹 개발을 10년 이상 해왔고, 무수히 많은 구성 방법을 보았습니다. 오늘은 여러분의 앱 구성을 좀 더 쉽게 만들어드리고, 물론 제 새로운 패키지 https://github.com/mrspartak/config 를 홍보하기 위해 여기에 왔습니다.\n\n![이미지](/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png)\n\n저는 풀 스택 개발자이지만, 백엔드와 프론트엔드 구성을 실제로 구분하지 않습니다. 둘 다 빌드 시간 및 실행 시간 구성을 사용할 수 있기 때문에 유사합니다. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 것입니다. 다음 섹션에 있는 통찰은 매우 주관적이므로, 다른 의견이 있으면 댓글로 의견을 공유해 주시면 감사하겠습니다.\n\n## 빌드 시간 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드에서는 빌드 시간 구성이 그리 흔하지는 않지만, 프론트엔드에서는 상당히 인기 있는 방식입니다. 여기에서는 구성 값을 패키지나 이미지에 포함하여 응용 프로그램을 실행하는 데 충분하게 활용합니다. 제게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서의 IO 작업 동작에 영향을 주는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif)\n\n그러나 어떤 사람들은 API 엔드포인트, 인증 키 등 외부 구성 요소를 빌드 시간에 포함하는 것이 너무 멀리간다고 생각합니다. 이 방식은 작동하지만, 각 환경별로 패키지 또는 이미지를 다시 빌드하고 테스트해야 하므로 빌드 사이에 불일치가 발생할 수 있습니다.\n\n## 런타임 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 곳이 백엔드의 진정한 빛이 나오는 곳입니다. 그러나 SSR (서버 측 렌더링) 및 SPA (단일 페이지 어플리케이션) 프론트 엔드에서 런타임 구성을 자주 사용합니다. 앱이 로드되는 가장 처음에 실행 구성 정보가 로드됩니다. 런타임 구성은 모든 외부 구성을 포함해야 하며, 환경에 따라 크게 다를 수 있습니다. 여기서 일회성 환경의 장점이 발휘되며, 더 큰 유연성과 적응성을 제공합니다.\n\n## 어떻게 구성하나요?\n\n그래서 구성이 정확히 무엇인가요? 네, 당신은 `.env` 파일을 알고 계시죠... 또는 `.toml`. 아마도 `.json` 또는 `.ini`도요? 음, 그냥 `.ts` 파일을 만들고 그 안에서 객체를 내보내겠습니다. 하지만 기다려주세요. 그 파일을 git에 커밋해야 할까요? 각 환경 당 파일을 만들어 비밀 데이터를 커밋해야 할까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 어떤 형식이 가장 좋은지를 두고 전쟁을 일으킬 수 있지만, 사실 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 형식이라면 충분하죠. 당신이 사용하기 편한 형식으로 선택하세요. 하지만 저장 및 사용 전략은 상당히 중요합니다.\n\n저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 순수한 Docker를 사용한다면 아마도 설정 및 비밀키에 익숙할 것입니다. 이를 통해 코드와 함께 실행 중인 컨테이너에 어떤 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경으로 새 구성을 배포할 때 발생한다고 보아요.\n\n## 유효성 검사, 유효성 검사, 유효성 검사\n\n구성은 선언부터 시작돼요. 정말 간단하죠. 백엔드에서 데이터베이스를 호출해야 한다면, 해당 데이터베이스에 인증하는 데 필요한 것을 파악하고 구성 선언에 넣으세요. 그 결과로 얻는 것은 - 어플리케이션이 다운될 때입니다. 하지만 이것이 우리가 원하는 것이에요. 이를 통해 누락되거나 잘못된 구성을 조기에 식별할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif\" /\u003e\n\n그 다음으로, 물론 구성 파일에 필요한 필드를 추가하시게 됩니다. 여러분은 어떤 유효성 검사 라이브러리든 사용하시거나, 더 좋은 방법으로는 (몰래 광고 주의!) 제 라이브러리를 사용하여 유효성을 처리할 수 있습니다.\n\n## 병합은 때로는 시간을 절약할 수 있습니다\n\n기본 PORT를 설정하는 것을 잊었을 때 항상 기본값이 있는데요, 어떻게 하면 좋을까요? 당연히 그 기본값을 정의하겠죠. 그렇다면 이후에 그들을 어떻게 병합할까요? 단순히 lodash를 사용하시거나, 더 좋은 방법으로는 (무언가를 여러 차례 언급하면 짜증나는 것에서 당신이 생각하는 방식으로 변화한다고 들었습니다) 제 라이브러리를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발자에게 무엇을 할 수 있을까요? 더 좋은 것을 받을 수 있을까요?\n\n물론 가능합니다. 물어주셔서 감사합니다. 저의 메인 언어(도움을 부탁드려요)가 TypeScript인 지금, 제게 제일 잘 맞는 것을 얻고 싶어해요. 상상해보세요! 전체 구성이 타이핑된 채로 보일 수 있어요. 와우. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 훌륭한 삶을 살고 있어요. 제 라이브러리는 어떤 유효성 검사 라이브러리든 가져다 사용할 수 있게 해주고, 그것들은 모두 Out of the box로 작동할 거예요.\n\ntrpc의 개발자에게 큰 칭찬을 보내요 - 그는 천재에요. 유효성 검사의 결과로 구성을 추론하기 위해 그의 코드를 그대로 복사하거나 도용할 수 있어요. 마법 같죠.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발 환경을 언급하셨군요. 커밋할까요?\n\n아니요. 절대 그러지 마세요. 제가 바로 OPENAPI_KEY를 훔쳐갈 거에요. 일주일 후면 길거리에서 구걸하게 될 거에요. 비밀 보관 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org 및 다른 멋진 프로젝트들이 안전하게 비밀을 보관하고 공유할 수 있게 해줍니다.\n\n패키지.json에 설치 스크립트를 포함하여 정확한 버전의 비밀을 다운로드할 수 있게 하세요. 또한 업로드 스크립트도 추가해서 버전을 업그레이드하고 git에서 충돌을 피할 수 있도록 해주세요. 나중에 감사의 인사를 드릴게요. 저는 이 방법을 여러 년간 사용해왔고 로컬 구성을 USB 드라이브나 Slack을 통해 공유하는 것으로는 돌아갈 수 없을 거에요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 알겠어요, 이제 다른 부풀린 npm 패키지에 대해 이야기해 주세요\n\n사실, 이 패키지는 의존성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용한다고 가정합니다. 일반적으로 이 패키지는 위에서 언급한 모든 문제를 해결합니다 (물론 개발 환경은 제외하고), 아래와 같은 기능을 제공합니다:\n\n- 3가지 데이터 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 처리합니다.\n- 런타임 유효성 검사: Zod, Superstruct, Yup 등과 같은 인기있는 라이브러리와 호환됩니다.\n- TypeScript IntelliSense: 유효성 검사 라이브러리에서의 변환기를 고려하고 해결된 유효성 검사에 대한 모든 힌트를 제공합니다.\n- 병합: 왜냐하면 가능한 이유가 있잖아요? 디폴트를 분리하여 가지고 있으면 상당히 멋집니다. 항상 유효성 검사자 스키마에 기본값을 넣을 수 있지만, 그러면 코드에 저장됩니다.\n- 완전히 테스트됨: 프로덕션에 사용할 준비가 되어 있으며 이미 여러 응용 프로그램에서 사용 중입니다.\n- 백엔드 및 프론트엔드 친화적: 두 환경 모두에서 원활하게 작동합니다.\n\n```js\n// 파일: state/config.ts\nimport { fromJSONFile } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst config = await fromJSONFile({\n  path: [\"../config/default.json\", \"../config/runtime.json\"],\n  schema: z.object({\n    db: z.object({\n      host: z.string(),\n      port: z.number(),\n      username: z.string(),\n      password: z.string()\n    }),\n    app: z.object({\n      port: z.number().optional().default(3000)\n    })\n  }),\n});\n\nexport default config\n\n\n\n// 파일: index.ts\n// 해결된 구성을 가져오세요\nimport config from './state/config.js';\n\n// 응용 프로그램에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그런데 JSON 지원만 보여요. system crap 환경 변수를 아름답게 하려면 어떻게 하죠?\n\n객체와 함께 작업을 지원하므로 env 객체를 함수에 전달하면 됩니다. 다른 .env 파서를 다시 작성하는 것이 이상할 것입니다. 이미 시험된 많은 파서가 시장에 있으니까요\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    NODE_ENV: z.enum([\"development\", \"production\"]),\n    DB_HOST: z.string(),\n    DB_PORT: z.number(),\n    DB_USER: z.string(),\n    DB_PASSWORD: z.string(),\n    APP_PORT: z.number().default(3000),\n  })\n  .transform((data) =\u003e ({\n    environment: data.NODE_ENV,\n    port: data.APP_PORT,\n    db: {\n      host: data.DB_HOST,\n      port: data.DB_PORT,\n      user: data.DB_USER,\n      password: data.DB_PASSWORD,\n    },\n  }));\n\nconst config = await fromObject({\n  data: process.env,\n  schema\n})\n\nexport default config\n\n// 파일 index.ts\nimport 'dotenv/config'\n// ! dotenv 이후에 설정이 로드되어야 하므로 process.env가 채워질 겁니다\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n## frontend를 언급했는데 node 파일 API를 확실히 사용했기 때문에 빌드가 중단될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 당신이 요청한 작업을 수행해드릴 수 있어요. (만약 더 나은 해결책을 아시는 분이 계시다면, 연락주세요)\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config/web\"; // 라이브러리의 별도 빌드\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    API_URL: z.string(),\n  })\n\nconst config = await fromObject({\n  data: import.meta.env, // vite를 사용한 예시 \n  schema\n})\n\nexport default config\n```\n\n![](https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif)\n","ogImage":{"url":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png"},"coverImage":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript에서 속성 가져오고 설정하는 방법","description":"","date":"2024-06-23 14:43","slug":"2024-06-23-JavaScriptGettingSettingsAttributes","content":"\n\n지난 기사에서는 요소나 요소들의 내부 텍스트와 내부 HTML을 변경하는 방법을 다뤘어요. 이 기사에서는 해당 요소들의 속성을 가져오고 설정하는 방법에 대해 다룰 거에요.\n\n![image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png)\n\n여기에는 href 속성이 있는 a 태그와 class 속성이 있는 p 태그가 있어요. JavaScript에서 가져오거나 설정할 수 있는 여러 가지 속성이 있어요. 이제 a 태그에서 href 속성을 가져와 보겠어요.\n\n![image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 a 태그에 대한 참조를 link라는 상수에 저장했어요. 그런 다음 link.getAttribute()를 기록하고 있어요. 이 방법에 href라는 문자열을 제공했어요. 브라우저 콘솔을 확인하면 그 값이 출력됩니다.\n\n이제 값을 설정해 보겠어요.\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_2.png\" /\u003e\n\nGoogle로 이동하는 대신 Yahoo로 이동하도록 말했어요. 브라우저에서 이 요소를 검사하면 값이 변경된 것을 볼 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_3.png\" /\u003e\n\n또 다른 예시:\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_4.png\" /\u003e\n\n여기서 p 태그를 잡아서 속성을 success로 변경하고 있어요. 이를 엘리먼트에서 검사해보면 속성이 변경된 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_5.png)\n\n이것은 무언가가 작동했는지 여부를 표시하는 데 유용할 수 있습니다. 그렇지 않으면 오류가 있으므로 메시지 색상을 빨간색으로 변경하거나 작동했으면 메시지 색상을 녹색으로 변경할 수 있습니다.\n\n이제 이미 존재하지 않는 html 요소에 속성을 설정합시다. JavaScript를 통해 p 태그에 스타일 속성을 추가하겠습니다.\n\n![Image](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 style 속성을 추가하여 텍스트 색상을 녹색으로 설정합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_7.png\" /\u003e\n\n실용적인 예는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘 확인만 할 불(bool)이 있어요. 이 불 값을 true로 설정하면 텍스트가 초록색으로 바뀌고 \"You Win!\"이라고 나와요. 그리고 false로 바꾸면 텍스트가 빨간색으로 바뀌고 \"You Lose!\"라고 나와요!\n\n![이미지 1](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_9.png)\n\n![이미지 2](/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_10.png)\n\n나중에 다룰 글에서 런타임시에 어떻게 동적으로 것들을 바꿀 수 있는지 다룰 거에요.","ogImage":{"url":"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png"},"coverImage":"/assets/img/2024-06-23-JavaScriptGettingSettingsAttributes_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML 링크의 종류와 사용 방법","description":"","date":"2024-06-23 14:43","slug":"2024-06-23-LinksinHTMLTypesandUses","content":"\n\nHTML의 링크는 웹사이트 내에서의 탐색과 연결을 가능하게 하는 가장 중요한 요소 중 하나입니다. 이들은 웹페이지간이나 문서, 이미지, 비디오 등 외부 소스로의 하이퍼링크 생성에 사용됩니다. 이 블로그 포스트에서는 HTML의 링크가 무엇이며, 어떻게 작동하는지, 그리고 사용 가능한 다양한 종류의 HTML 링크에 대해 살펴볼 것입니다.\n\n![LinksinHTMLTypesandUses_0](/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png)\n\n## HTML에서의 링크란?\n\nHTML에서의 링크는 사용자가 하이퍼링크를 클릭하여 웹사이트를 탐색할 수 있는 요소입니다. 하이퍼링크는 사용자를 새 웹페이지, 문서 또는 자원으로 이동시키는 클릭 가능한 요소입니다. 이는 \"anchor(앵커)\"를 나타내는 HTML `a` 태그를 사용하여 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하이퍼링크는 목적지 웹페이지나 리소스의 URL을 `a` 태그에 추가하여 만듭니다. 사용자가 하이퍼링크를 클릭하면 브라우저가 새 탭이나 창에서 목적지 웹페이지나 리소스를 엽니다.\n\n## HTML에서 링크는 어떻게 작동하나요?\n\nHTML에서 링크는 HTML 코드와 사용자의 웹 브라우저를 함께 사용하여 작동합니다. HTML 코드는 목적지 웹페이지나 리소스의 URL과 링크로 표시될 텍스트를 지정하여 하이퍼링크를 정의합니다. 사용자의 웹 브라우저는 이 정보를 사용하여 사용자가 클릭하여 목적지 웹페이지나 리소스로 이동할 수 있는 클릭 가능한 링크를 만듭니다.\n\n## HTML에서 다양한 유형의 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML에는 각각의 특정 사용과 목적을 갖는 여러 유형의 링크가 있습니다. 이 섹션에서는 HTML에서 가장 일반적인 유형의 링크 몇 가지를 살펴보겠습니다.\n\n- 내부 링크: 내부 링크는 하나의 웹페이지를 같은 웹사이트 내의 다른 페이지에 연결하는 하이퍼링크입니다. 내부 링크는 주로 내비게이션 메뉴를 만들거나 관련 페이지에 대한 링크를 제공하거나 특정 주제에 대한 추가 정보를 사용자에게 제공하기 위해 사용됩니다.\n\n내부 링크는 HTML `a` 태그와 대상 페이지의 상대적인 URL을 사용하여 생성됩니다. 예를 들어, 웹사이트 내의 \"about.html\"이라는 페이지에 링크를 만들고 싶은 경우 다음 코드를 사용할 수 있습니다:\n\n```js\n\u003ca href=\"about.html\"\u003eAbout\u003c/a\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 \"About\" 링크를 클릭하면 동일한 웹 사이트 내의 \"about.html\" 페이지로 이동하게 됩니다.\n\n![링크 이미지](/assets/img/2024-06-23-LinksinHTMLTypesandUses_1.png)\n\n2. 외부 링크: 외부 링크는 한 웹페이지를 다른 웹사이트의 페이지와 연결하는 하이퍼링크입니다. 이들은 주제에 대한 추가 정보나 자원을 사용자에게 제공하는 데 자주 사용됩니다.\n\n외부 링크는 HTML `a` 태그와 대상 페이지의 전체 URL을 사용하여 생성됩니다. 예를 들어, \"HTML\" 위키백과 페이지에 대한 링크를 만들고 싶다면 다음 코드를 사용하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[HTML on Wikipedia](https://en.wikipedia.org/wiki/HTML)\n```\n\n사용자가 \"위키백과의 HTML\" 링크를 클릭하면 \"HTML\" 위키백과 페이지로 이동합니다.\n\n3. 이미지 링크: 이미지 링크는 클릭 가능한 요소로 이미지를 사용하는 하이퍼링크입니다. 시각적으로 매력적인 내비게이션 메뉴를 만들거나 관련 페이지로 연결하는 데 일반적으로 사용됩니다.\n\n이미지 링크는 HTML `a` 태그와 `img` 태그를 사용하여 만듭니다. 예를 들어, 웹 사이트 내 \"contact.html\"이라는 페이지로 이미지 링크를 만들고 싶다면 다음 코드를 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[Contact Us](contact.html)\n```\n\n사용자가 \"Contact Us\" 이미지를 클릭하면 동일한 웹사이트 내의 \"contact.html\" 페이지로 이동됩니다.\n\n4. 이메일 링크: 이메일 링크는 사용자가 웹페이지에서 직접 이메일을 보낼 수 있는 하이퍼링크입니다. 웹사이트 소유자에게 연락하는 방법을 제공하거나 피드백을 보내는 데 일반적으로 사용됩니다.\n\n이메일 링크는 HTML `a` 태그와 \"mailto\" 프로토콜을 사용하여 생성됩니다. 예를 들어 사용자가 \"info@example.com\"로 이메일을 보낼 수 있는 이메일 링크를 만들고 싶다면 다음 코드를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n[info@example.com](mailto:info@example.com)\n```\n\n\"Contact Us\"를 클릭하면 사용자의 기본 이메일 클라이언트가 \"To\" 필드가 \"info@example.com\"으로 채워진 상태로 열립니다.\n\nHTML의 링크는 사용자 친화적이고 기능적인 웹 사이트를 만드는 데 중요한 부분입니다. 이를 통해 사용자는 웹 사이트를 탐색하고 문서, 이미지, 동영상과 같은 외부 리소스와 연결할 수 있습니다.\n\n![Links in HTML Types and Uses](/assets/img/2024-06-23-LinksinHTMLTypesandUses_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTML 링크의 활용\n\nHTML에서의 링크는 웹 개발의 기본 구성 요소로, 웹 사이트 내에서의 탐색과 연결성을 가능하게 합니다. 사용자에게 웹 페이지 간 이동, 외부 자원 접근, 웹 사이트 요소와의 상호 작용을 제공합니다. 이 섹션에서는 HTML에서 링크를 사용하는 몇 가지 일반적인 방법을 살펴볼 것입니다.\n\n- 내비게이션: HTML 링크의 주요 용도 중 하나는 웹 사이트 내에서의 내비게이션을 제공하는 것입니다. 내부 링크는 동일한 웹 사이트 내의 다른 페이지로 연결하는 데 사용되어 사용자가 쉽게 웹 페이지 간 이동할 수 있도록 합니다. 내비게이션 메뉴, 브레드크럼 트레일, 내부 링크 전략은 모두 내비게이션 용도로 링크를 사용하는 일반적인 예시입니다.\n- 외부 자원: HTML에서의 링크는 또한 문서, 이미지, 비디오, 다른 웹 사이트와 같은 외부 자원에 대한 사용자 접근을 제공하는 데 사용됩니다. 외부 링크는 다른 웹 사이트의 페이지에 현재 웹 페이지를 연결하여 사용자가 동일한 웹 사이트에 호스팅되지 않은 자원에 접근할 수 있도록 합니다. 이는 주제나 제품과 관련된 추가 정보나 자원을 제공하는 데 흔히 사용됩니다.\n- 호출-투-액션: HTML 링크는 호출-투-액션(CTA) 요소로도 사용할 수 있으며, 사용자가 구매를 하거나 뉴스레터 구독과 같은 특정 동작을 취할 수 있도록 장려합니다. CTA 링크는 일반적으로 웹 페이지의 다른 링크와 시각적으로 구분되도록 설계되며, 색상, 글꼴 크기, 배치와 같은 기법을 사용하여 링크에 주목을 끕니다.\n- 이미지 링크: HTML에서의 링크는 이미지와 결합하여 웹 페이지에서 시각적으로 매력적이고 인터랙티브한 요소를 만들어낼 수 있습니다. 이미지 링크는 일반적으로 내비게이션 목적으로 사용되며, 관련 페이지로 연결하거나 사용자가 외부 자원에 액세스하도록 합니다. HTML `a` 태그와 `img` 태그를 사용하여 이미지 링크를 만들 수 있습니다.\n- 이메일 링크: HTML에서의 링크를 사용하여 사용자가 웹 사이트 소유자에게 연락하는 방법을 제공하거나 피드백을 보내는 데 사용할 수도 있습니다. 이메일 링크는 \"mailto\" 프로토콜을 사용하여 특정 이메일 주소가 기재된 사용자의 기본 이메일 클라이언트를 엽니다.\n\nHTML에서의 링크는 사용자 친화적이고 기능적인 웹 사이트를 만드는 데 있어서 필수적인 부분입니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크는 HTML에서 사용되는 가장 일반적인 유형의 링크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-LinksinHTMLTypesandUses_3.png)\n\n## 결론\n\nHTML에서의 링크는 웹 개발의 중요한 구성 요소로, 웹 사이트 내에서의 네비게이션과 연결을 가능하게 합니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크는 HTML에서 가장 일반적으로 사용되는 링크 유형이며, 각각의 용도와 목적이 있습니다. 링크를 효과적으로 활용하는 방법을 이해함으로써, 웹 개발자는 사용자의 요구를 충족시키는 효과적이고 효율적인 웹 사이트를 만들 수 있습니다.\n\nCronJ는 HTML 개발 분야의 전문가로, 비즈니스에게 효과적이고 효율적인 웹 사이트를 만들기 위한 전문 지식과 자원을 제공합니다. 품질, 효율성, 고객 만족도에 중점을 둔 CronJ는 비즈니스에 최고의 HTML 개발 솔루션을 제공하기 위해 노력하고 있습니다. 내부 링크, 외부 링크, 이미지 링크, 이메일 링크가 필요하다면, CronJ는 HTML 개발 요구 사항을 충족시키기 위한 전문 지식과 자원을 보유하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- [https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks)\n- HTML 링크\n- HTML 입력 유형\n- HTML 튜토리얼\n- HTML 입력 유형: 최선의 실천법 및 팁 | Olga Green | 2023년 3월 | Medium","ogImage":{"url":"/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png"},"coverImage":"/assets/img/2024-06-23-LinksinHTMLTypesandUses_0.png","tag":["Tech"],"readingTime":5},{"title":"파이썬, Jinja2, Weasyprint를 사용한 인보이스 생성기 만들기","description":"","date":"2024-06-23 14:41","slug":"2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint","content":"\n\n프리랜서 프로젝트로 작은 작업을 부탁받을 때는 어떻게 하시나요?\n\n고객에게 할 작업과 해당 작업에 대한 비용을 나열한 송장을 작성합니다. 이를 통해 작업 범위를 세부적으로 설명하고 해당 비용에 대해 투명하게 고객에게 알림을 줍니다. 이는 비즈니스 거래에서 명확성과 공정성에 대한 당신의 헌신을 보여줍니다.\n\n프리랜서 고객과 거래할 때 전문성에 기여하는 다른 요소들이 많지만, 실제로 신경 쓸 필요가 없는 기능으로 여러 기능이 넘치는 완벽한 송장 솔루션 대신 사용할 도구로 이것을 선택했습니다.\n\n이 작업을 위한 빠르고 간편한 솔루션이 필요했기 때문에 이 스크립트를 만들었고, 정확히 어떻게 만들었는지 보여드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png\" /\u003e\n\n# 랜드스케이프\n\n저는 단순함을 유지하고 싶었어요... 정말 한없이 단순하게. 보통 제가 하는 것과 같이 OOP 방식을 선택하는 대신 함수를 만들었어요. 그러나 다소 사용자 정의할 수 있도록 하기 위해 invoice를 설정하는 방법에 대한 구성이 담긴 settings.py를 추가했어요.\n\ninvoice 자체는 jinja2 구문으로 작성된 HTML 파일입니다. 이 템플릿에 렌더링되는 데이터는 data.json에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 나는 render_template()를 팩토리로 사용하는 원시적인 팩토리 디자인 패턴을 선택했고 이는 invoice_gen.py 내에 있습니다.\n\n각 파일이 의도된 용도는 다음과 같습니다:\n\n- data.json 👉 Jinja 템플릿으로 렌더링 될 데이터를 포함합니다.\n- invoice_gen.py 👉 팩토리로 작용하여 송장을 생성하는 스크립트 파일입니다.\n- settings.py 👉 HTML 템플릿의 구성을 포함합니다.\n\n조금 더 이해하기 쉽게 하기 위해 아래 다이어그램에서 어떻게 작동하는지 설명했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기술\n\n다음을 사용하고 있습니다:\n\n- Jinja\n- WeasyPrint\n\n# 데이터 파일\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 저희가 템플릿에 렌더링하려는 모든 정보를 포함한 JSON 파일입니다. 제 파일은 다음과 같은 형식을 가지고 있어요:\n\n```js\n{\n    \"title\": \"서비스 청구서\",\n    \"invoiceNumber\": 13,\n    \"issueDate\": \"2023년 11월 12일\",\n    \"dueDate\": \"2023년 12월 18일\",\n    \"status\": \"만기\",\n\n...\n\n    \"server\": {\n        \"logo\": \"로고/경로.png\",\n        \"companyName\": \"Hammad의 회사\",\n        \"firstName\": \"M. Hammad\",\n        \"lastName\": \"Hassan\",\n        \"address\": {\n            \"city\": \"신드주 카라치\",\n            \"country\": \"파키스탄\"\n        },\n        \"email\": \"hammad.hassan@localhost.com\",\n        \"profileURL\": {\n            \"url\": \"https://www.upwork.com/freelancers/~01f9b5bc6f481f0385\",\n            \"displayText\": \"Upwork의 Hammad\"\n        }\n    },\n    \"itemList\": [\n        {\n            \"title\": \"파이썬 코스\",\n            \"description\": \"시작하기에 좋은 파이썬 기초 코스\",\n            \"isFixedPrice\": false,\n            \"rate\": 10,\n            \"hours\": 15\n        },\n        {\n            \"title\": \"HTML/CSS/JS\",\n            \"description\": \"초보자용 프론트엔드 코스\",\n            \"isFixedPrice\": false,\n            \"rate\": 6,\n            \"hours\": 10\n        }\n    ],\n    \"moderatorCharges\": 0.1,\n    \"percentIncreaseAfterDueDate\": 0.05\n\n...\n\n}\n```\n\n위의 JSON 파일은 제가 사용하는 실제 파일의 간략한 버전입니다.\n\n# 주요 스크립트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ndata.json 파일에 정의된 데이터 세트에서 송장을 생성하는 프로세스는 송장을 만들기 위해 여러 리소스를 사용합니다. 클라이언트에게 보낼 수 있는 송장을 생성합니다.\n\n먼저 의존성을 가져와야 합니다.\n\n```js\nfrom jinja2 import Template\nimport json\n```\n\n그런 다음, Jinja HTML 템플릿에 일부 컨텍스트를 삽입하는 함수를 작성하고 나중에 이러한 템플릿을 pdf로 변환할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef render_template(\n    template_file: str, \n    context: dict, \n    styles: list, \n    output_filename: str\n) -\u003e str:\n    \n    # 템플릿 파일을 가져와 컨텍스트 변수를 사용하여 렌더링합니다.\n    template = Template(template_file)\n    rendered_html = template.render(context)\n\n    # 출력 파일의 이름을 설정합니다.\n    html_file = f\"{output_filename}.html\"\n    pdf_file = f\"{output_filename}.pdf\"\n\n    # HTML 콘텐츠를 파일에 기록합니다.\n    with open(html_file, 'w') as file:\n        file.write(rendered_html)\n\n    # WeasyPrint를 사용하여 HTML을 PDF로 변환합니다.\n    HTML(html_file).write_pdf(pdf_file, stylesheets=styles)\n\n    # 파일 이름을 반환합니다.\n    return pdf_file\n```\n\n이제 동일한 스크립트 파일 내에서 템플릿을 렌더링하는 데 필요한 에셋을 로드합니다.\n\n```python\n# 컨텍스트 데이터 로드\ncontext_data = {}\nwith open(\"./data.json\") as data:\n    context_data = get_context_data(json.load(data))\n    \n# Jinja 템플릿 로드\ntemplate_html = \"\"\nwith open(TEMPLATE_HTML_PATH) as template:\n    template_html = template.read()\n\n# 템플릿을 렌더링하고 PDF를 생성합니다.\npdf_filename = render_template(template_html, context_data, TEMPLATE_CSS, OUTPUT_FILENAME)\nprint(f\"PDF 생성됨: {pdf_filename}\")\n```\n\nget_context_data() 함수에서 컨텍스트 데이터를 불러오고, 이 함수는 settings.py에 위치합니다. 이 함수는 파이썬 딕셔너리 하나를 매개변수로 받습니다. 이 딕셔너리는 data.json에서 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 또한 Jinja 템플릿(HTML 파일)을 로드하고 'with' 키워드와 'open' 함수를 사용하여 내용을 읽습니다. TEMPLATE_HTML_PATH는 settings.py에서 왔는데, 이는 다음 섹션에서 설명됩니다.\n\n마지막으로, 우리는 render_template() 함수를 호출하여 그 마법을 일으킵니다.\n\n# 설정 파일\n\n이 파일에는 스크립트의 모든 사용자 정의 가능한 부분이 포함되어 있습니다. 따라서 위에서 언급한 스크립트의 결과를 변경하고 싶다면, 이 파일을 변경하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성을 가져오세요. 이제 weasyprint가 포함되어 있습니다.\n\n```js\nfrom weasyprint import HTML, CSS\nfrom datetime import datetime\n```\n\n이 파일에는 변수 3개와 함수 하나만 포함되어 있습니다.\n\n```js\nOUTPUT_FILENAME = f\"output-{datetime.now().strftime('%d-%b-%Y')}\"\nTEMPLATE_HTML_PATH = \"./invoice_template_002.html\"\n\nTEMPLATE_CSS = [\n    CSS(\"./invoice_template_002.css\"),\n    CSS(\"https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css\" ),\n    CSS(\"https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\" )\n]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 두 변수는 설명이 분명하기 때문에 그에 대해 많은 시간을 낭비하지 않을 겁니다.\n\n그러나 TEMPLATE_CSS는 weasyprint 라이브러리에서 가져온 CSS 개체의 목록입니다.\n\n이 목록에는 필요한 만큼 많은 CSS 모듈을 추가할 수 있으며 모두 HTML 템플릿에 적용됩니다.\n\n이 목록의 첫 번째 요소는 제 개인적인 사용자 정의 CSS이므로 상대 경로를 갖고 있습니다. 다른 두 개는 Bootstrap 및 Font Awesome CDNs에서 가져온 링크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef get_context_data(context_json:dict)-\u003edict:\n    \"\"\"이 함수는 data.json에서 가져온 컨텍스트를 조작합니다.\"\"\"\n    context_json['issueDate'] = datetime.strptime(context_json['issueDate'], '%d-%m-%Y').strftime('%d-%m-%Y')\n    context_json['dueDate'] = datetime.strptime(context_json['dueDate'], '%d-%m-%Y').strftime('%d-%m-%Y')\n    context_json['invoiceDate'] = datetime.strptime(context_json['issueDate'], '%d-%m-%Y').strftime('%B')\n    return context_json\n```\n\nget_context_data()는 정확히 그 이름이 의미하는 대로 동작합니다. 이 함수는 컨텍스트 데이터를 가져오고, 사용자가 해당 데이터를 조작할 수 있도록 해주며, 수식을 적용하고 계산을 수행한 다음 데이터를 Python 사전 형태로 반환합니다.\n\n나는 이 함수를 사용했는데, data.json에는 많은 정보가 있지만, 계산이 필요한 데이터를 넣지 않았기 때문이다. 예를 들어, 송장에 판매 중인 다양한 제품이 있을 수 있지만, 고객에게 청구하는 총 금액은 하드 코딩하는 대신 계산되어야 합니다.\n\n하지만 위의 함수에서 그중 어떤 것도 계산하지는 않았습니다. 그 이유는 저는 계산을 Jinja 템플릿 내에서 수행하기로 선택했기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어찌되었든, 여기저기 숫자를 하드 코딩하진 않아요.\n\n너무 많은 공간을 차지하기 때문에 템플릿 파일은 여기에 포함하지 않겠습니다. 그러나 완전한 코드를 확인하려면 내 GitHub 저장소를 확인해주세요.\n\n# GitHub 저장소\n\n# 샘플 미리보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_1.png\" /\u003e\n\n위는 제가 제공한 공장 코드로 할 수 있는 가능성 중 하나입니다. 예를 들어, 인증서를 만들거나 CSS로 스타일을 지정하고 data.json에 수령인의 이름을 넣을 수도 있습니다.\n\n즐겁게 사용하시기 바랍니다.\n\n만약 이 글이 도움이 되었고 새로운 것을 배웠다면 👏을 남겨주시거나 제게 알려주셔요 📣. 여러분의 피드백을 듣고 싶어합니다.","ogImage":{"url":"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png"},"coverImage":"/assets/img/2024-06-23-CreateAnInvoiceGeneratorUsingPythonJinja2Weasyprint_0.png","tag":["Tech"],"readingTime":7},{"title":"CSS에서 테두리 속성 다루는 방법","description":"","date":"2024-06-23 14:40","slug":"2024-06-23-EngineeringBorderPropertiesinCSS","content":"\n\n공학 (CSS)\n\n![EngineeringBorderPropertiesinCSS_0.png](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png)\n\n## 테두리 속성\n\n- 테두리 속성을 사용하면 HTML 요소 주변에 테두리를 정의할 수 있습니다.\n- border-width\n- border-style\n- border-color\n- border-radius\n- border\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테두리 너비:\n\n- '얇은', '보통', '두꺼운' 또는 구체적인 크기 (예: 2px, 0.1em 등)로 지정할 수 있습니다.\n\n# 테두리 색상:\n\n- 유효한 색상 값 중 하나 (예: 색 이름, 16진수, RGB, RGBA, HSL, HSLA 등)을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테두리 스타일:\n\n- none, hidden, dotted, dashed, solid, double, groove, ridge, inset, outset 중 하나 가능\n\n# 위 속성에 대한 예시\n\n![이미지](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# Individual border sides:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- border-top: 상단 테두리를 설정합니다.\n- border-right: 우측 테두리를 설정합니다.\n- border-bottom: 하단 테두리를 설정합니다.\n- border-left: 좌측 테두리를 설정합니다.\n\n![EngineeringBorderPropertiesinCSS_5](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_5.png)\n\n![EngineeringBorderPropertiesinCSS_6](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_6.png)\n\n# border-radius:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- border-radius 속성을 사용하면 테두리에 둥근 모퉁이를 추가할 수 있습니다.\n- 모든 모퉁이에 적용하는 대신 다음 중 하나를 사용할 수 있습니다:\n  - border-top-left-radius\n  - border-top-right-radius\n  - border-bottom-right-radius\n  - border-bottom-left-radius\n\n![EngineeringBorderPropertiesinCSS_7](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_7.png)\n\n![EngineeringBorderPropertiesinCSS_8](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_8.png)\n\n# All in one\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `border` 속기 속성을 사용하면 요소의 테두리 너비, 스타일 및 색상을 한 번에 설정할 수 있습니다.\n\n![EngineeringBorderPropertiesinCSS_9](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_9.png)\n\n![EngineeringBorderPropertiesinCSS_10](/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_10.png)","ogImage":{"url":"/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png"},"coverImage":"/assets/img/2024-06-23-EngineeringBorderPropertiesinCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"반응형 이미지와 동적 미디어 제대로 구현하기  Part III","description":"","date":"2024-06-23 14:37","slug":"2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII","content":"\n\n# 동적 미디어 및 HTML 5\n\n오늘날의 웹사이트는 다양한 기기에서 경험됩니다. 화면 크기는 물론 해상도, 방향 및 종횡비도 다양합니다.\n\n![ResponsiveImagingandDynamicMediadoneRightPartIII_0](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png)\n\n다양한 기기를 위해 이미지를 다른 해상도와 포맷으로 제공해야 합니다. HTML5는 이를 어떻게 수행할 수 있는지에 대한 일부 힌트를 제공합니다. 그러나 표준은 다소 복잡하며 오류를 발생시키기 쉽습니다. 또한 HTML5는 약간 정적이며 AEM Dynamic Media를 사용할 때 활용할 수 있는 고급 렌더링 기능을 완전히 활용하지 못합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 네 부분 시리즈의 세 번째 파트입니다. 시리즈는 아래와 같이 나뉘어 있습니다:\n\n- 첫 번째 파트: 반응형 이미징이란 무엇인가? 왜 필요한지 그리고 어떤 사용 사례가 있는지.\n- 두 번째 파트: AEM Dynamic Media를 사용하여 페이지 로딩 성능을 높이는 방법은?\n- 세 번째 파트: HTML 5로 Dynamic Media를 어떻게 구현할 수 있는가?\n- 네 번째 파트: HTML 5 이상: 사용자 정의 이미지 로더를 사용하여 페이지 로딩 시간을 단축하는 방법.\n\n# Responsive Images를 위한 HTML 마크업\n\n아직 여기 있나요? 멋지네요. 여태까지 오신 것을 기뻐해요. 이 장에서는 반응형 이미지의 HTML 부분에 중점을 둘 것입니다. HTML5 표준은 반응형 이미지를 지원하는 몇 가지 새로운 태그를 제공합니다. 경험 많은 웹 개발자라면 아마도 srcset 속성과 `picture` 태그를 이미 사용해 본 적이 있을 것입니다. 이것이 우리가 작업할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞서 이 태그들에 익숙하다 해도, 여기 머무르는 것을 초대해요. 이 마크업 유형에는 잘 알지 못하는 몇 가지 숨은 기능이 있을 수 있어요. 그리고 나중에는, 앱이나 정적 웹사이트에서 사용하는 기술이 콘텐츠 관리 시스템(CMS)에서 생성된 사이트에 적용 가능하지 않을 수도 있다고 주장할 거예요.\n\n# 유동 및 반응형 레이아웃의 이미지\n\n지금쯤이면 개별 이미지를 잘라내거나 크기 조절하는 방법을 알고 계실 거에요. 각 이미지는 개별 URL로 참조될 수 있어요. 그렇다면 브라우저는 어떤 URL을 특정 레이아웃에 사용해야 할지 어떻게 알 수 있을까요?\n\n이는 사용 사례에 따라 다릅니다. 설명하기 위해 몇 가지 전형적인 사용 사례를 다루는 간단한 레이아웃을 만들었어요. 이 레이아웃은 유동적이고 반응형입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Fluid\"은 모든 너비 정의가 %로 되어 있음을 의미합니다. 브라우저 창의 크기를 줄이면 페이지 상의 모든 요소의 너비가 비례하여 줄어듭니다.\n\n\"반응형\": 어느 순간 – 전형적인 모바일 기기용 브레이크포인트에 도달하면 약간 다른 레이아웃이 적용됩니다. 즉, 다중 열 요소가 쌓이게 됩니다:\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_1.png)\n\n# 사용 사례들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nA: 화면 너비의 100%를 차지하는 히어로 배너입니다. 크기는 실제 화면 너비에 맞게 조정됩니다. 모든 기기에서 종횡비 3:1이 동일합니다.\n\nB: 옆에 표시된 두 개의 작은 티저 구성 요소입니다. 이미지는 사용 가능한 너비의 50%를 차지하고 비례하여 확대됩니다. 좁은 화면을 가진 모바일 기기에서는 티저가 쌓이게 표시되며 화면 너비의 100%를 차지합니다. 종횡비 1:1이 동일합니다.\n\nC: 텍스트-이미지 구성 요소입니다. 데스크톱 해상도에서 이미지는 텍스트 오른쪽에 표시되며 뷰포트 너비의 33%를 차지합니다. 모바일 기기에서 이미지는 텍스트 위에 표시되며 종횡비가 1:1에서 3:1로 변경됩니다.\n\nD: 텍스트와 이미지가 있는 큰 티저입니다. 데스크톱에서 이미지는 화면 너비의 33%를 사용합니다. 모바일 화면에서 이미지는 쌓이고 화면 너비의 100%를 사용하며 3:1로 표시됩니다. 텍스트 이미지 구성 요소와 달리, 이미지의 높이는 가변적입니다. 이미지의 높이는 텍스트 블록의 높이에 따라 정의됩니다. 더 긴 복사 텍스트는 더 늘어진 형식을 유도합니다. 이미지는 모든 종횡비를 가질 수 있으며 미리 정의된 형식 중 하나에 부합되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트 환경\n\n5 페이지에 간단한 테스트 페이지 세트를 준비해두었어요. 이를 따라가며 제 결과물을 검증할 수 있어요.\n\n여러 브라우저를 병렬로 사용하는 것을 추천해요. 각각 약간 다르게 작동하기 때문이에요. 새로운 개념을 익히기에는 Firefox가 최적이라고 생각해요. Chrome은 몇 가지 성능 최적화를 적용하고 핵심 기능을 가리는 특징이 있어요. 이 점이 약간 혼란스러울 수 있어요.\n\n실험을 위해 dummyimage.com을 사용하여 테스트 이미지를 생성하고 있어요. 이 이미지들은 내재적인 크기를 표시해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ndummyimage.com에 차원 매개변수를 사용하여 요청을 보내면 이렇게 됩니다:\n\nhttps://dummyimage.com/300x100/000/fff\n\n이는 300x100 픽셀 이미지를 렌더링하고 이미지 콘텐츠로 차원을 표시합니다. 즉, 다음과 같이 됩니다:\n\n\n![image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 곧 유용할 것입니다.\n\n프로덕션에서는 물론 실제 이미지를 제공하는 Dynamic Media를 사용할 것입니다.\n\n## Hero 배너\n\n![Hero 배너](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 확장 - 순진한 방법\n\n히어로 배너는 화면 너비의 100%를 차지합니다. 종횡비는 3:1입니다. 먼저 간단한 방법으로 시작해보죠. 웜업을 해봅시다. 간단한 `img` 태그를 사용해 봅시다:\n\n```js\n\u003cstyle\u003e\n  .hero{\n    width: 100%;\n  }\n…\n\u003c/style\u003e\n\n\u003cdiv class=\"hero\"\u003e\n  \u003cimg src=\"https://dummyimage.com/300x100/D3C8D9/000\" id=\"hero\" class=\"hero\"/\u003e\n\u003c/div\u003e\n```\n\n결과는 이와 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Responsive Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_4.png)\n\nAlso, check out [this link](https://ackoch.github.io/image-zoo/001-hero-naive.html).\n\nIt looks like the image quality is not great. The image appears blurry because we are loading an image with an intrinsic size of 300x100, which is smaller than what your screen can handle in terms of pixel display.\n\nI've also included some additional metrics on the test page using JavaScript. You will see the total viewport width, the logical dimension of the image, and the physical dimension. The \"logical\" dimension is what the browser uses for layout calculations, while \"physical\" represents the actual pixel density of the screen. I am currently using a MacBook with a \"Retina\" display, which has a higher pixel density compared to the layout elements. This means that images and fonts are rendered sharper on my screen.\n\nThis pixel density is expressed as the device pixel ratio (DPR), which is also displayed on the test page. A higher DPR value is common on modern screens, with most starting above 1. Entry-level devices may have a DPR of 1.5, while an iPhone 14 has a DPR of 3.0.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론: 이미지를 선명하고 선명하게 보이게 하려면 더 높은 해상도의 이미지가 필요합니다.\n\n그냥 이미지의 크기를 1500x500으로 늘리면 될 것 같아요:\n\n```js\n\u003cdiv class=\"hero\"\u003e\n  \u003cimg src=\"https://dummyimage.com/1500x500/D3C8D9/000\" id=\"hero\" class=\"hero\"/\u003e\n\u003c/div\u003e\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 링크를 참조해 보세요. (https://ackoch.github.io/image-zoo/001-hero-naive-2.html)\n\n이제 이미지가 매우 선명해 보입니다. 위 스크린샷에서 창 너비를 450px로 줄인 것을 알아챘을 겁니다. 지금은 1500px 이미지를 불러오고 있습니다. 하지만 900px 이미지로도 충분히 좋았을 것입니다. 소개에서 기억하실 것처럼, 파일 크기의 증가는 차원에 비해 과도하게 높습니다: 여기서 많은 대역폭을 낭비하고 있는 것입니다. 특히, 좁은 화면이 모바일 기기에서 더 많이 발견될 가능성이 높다는 점을 고려하면 대역폭이 귀중한 환경에서 더욱 그렇습니다.\n\n\"srcset\" 접근법\n\n표준 해결책은 간단합니다: 하나 이상의 이미지를 제공해야 합니다 — 이미지 집합, 소스 세트를 제공해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cimg srcset=\"https://dummyimage.com/300x100/D3C8D9/000 300w,\n             https://dummyimage.com/600x200/D3C8D9/000 600w,\n             https://dummyimage.com/900x300/D3C8D9/000 900w,\n             https://dummyimage.com/1200x400/D3C8D9/000 1200w,\n             https://dummyimage.com/1500x500/D3C8D9/000 1500w\"\n  id=\"hero\"/\u003e\n```\n\n여기에는 브라우저가 선택할 수 있는 다양한 해상도의 후보 이미지가 제공됩니다. 브라우저는 각 이미지의 실제 너비를 알 수 없기 때문에 각 후보에 이 정보를 추가해야 합니다.\n\n예를 들어, 다음 표현식\n\n```js\nhttps://dummyimage.com/300x100/D3C8D9/000 300w\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 URL에서 제공하는 이미지가 300픽셀 너비(300w)로 되어있음을 알려줍니다.\n\n첫 번째 테스트를 진행해 보겠습니다:\n- Firefox에서 페이지를 엽니다 (정말로 Firefox에서).\n- 캐시를 비활성화합니다 (개발 도구 / 네트워크 / 캐시 비활성화).\n- 개발 도구 창을 열어둡니다 (!).\n- 창 크기를 변경하여 확인합니다.\n\n로딩된 이미지가 필요한 물리적 크기에 맞는지 확인할 수 있습니다. 또한 Firefox가 항상 다음으로 큰 후보를 로딩하고 있다는 것을 알 수 있습니다. 1040픽셀 뷰포트에서 1200픽셀 이미지를 로드하는 등 약간의 대역폭이 낭비되긴 하지만, 수용할만 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식의 테이블입니다.\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_6.png\" /\u003e\n\nFirefox에서 창 크기 변경하기\n\nFirefox와 Chrome이 다르게 작동하는 것을 말씀드렸나요? 아래 예시를 보세요.\n\n이제 Chrome에서 같은 작업을 해봅시다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크롬에서 페이지를 열어주세요.\n- 캐시를 비활성화하세요 (개발자 도구 / 네트워크 / 캐시 사용 안 함)\n- 개발자 도구 창을 열어둡시다!\n- 창 크기를 변경할 때 창 테두리를 드래그하세요.\n\n작은 창에서 시작하여 차츰 창 크기를 키울 때, 크롬은 더 큰 이미지를로드합니다.\n\n그러나 그 이후에 다시 크기를 줄이면 페이지가 가장 큰 크기로 \"붙어\" 있습니다. 페이지를 강제 새로 고침할 때만 크롬이 이미지의 작은 버전을 다시로드합니다. 개발자 도구를 닫은 상태에서는 크롬이 다시로드 할 때조차 다시평가하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://ackoch.github.io/image-zoo/001-hero.html을(를) 참고하세요.\n\n이것은 버그가 아닌 기능입니다. 크롬은 이미 더 큰 후보가 메모리에 있을 때 작은 버전의 이미지를 로드하지 않고 다운 샘플링할 수 있습니다. 이것은 성능에 좋지만 새로운 HTML 기능이 어떻게 작동하는지 이해하려고 할 때 혼란스러울 수 있습니다.\n\n그래서 반응형 이미지를 다룰 때는 Firefox를 선호합니다. 이것이 테스트를 조금 더 쉽게 만들어주기 때문입니다.\n\n참고: \"sizes\" 매개변수를 놓치셨다면. 그렇습니다. 다음 챕터에서 목적을 더 잘 설명하기 위해 고의로 실수한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 작은 티저 ½와 ½에서 \n\n![Small Teasers](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_8.png)\n\n우리가 배운 것을 두 작은 티저 구성 요소에 적용해 보겠습니다. 이 두 요소는 50%씩 나란히 표시되어야 합니다:\n\n```js\n\u003cdiv class=\"flex-container\"\u003e\n  \u003cdiv class=\"card\"\u003e\n\n    \u003cimg srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n                 https://dummyimage.com/800x800/D5E8D4/000 800w,\n                 https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n                 https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n         id=\"card1\"\u003e\n\n    \u003cp id=\"dimensions-card1\"\u003e\u003c/p\u003e\n\n  \u003c/div\u003e\n\n  \u003cdiv class=\"card\"\u003e\n    \u003cimg srcset=\"… 위와 동일하게 …\" src=\"…\" id=\"card2\"\u003e\n    \u003cp id=\"dimensions-card2\"\u003e\u003c/p\u003e\n  \u003c/div\u003e\n\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`800px` 스크린에서 `flex-container`를 감싸도록 스타일에 미디어 쿼리가 있습니다:\n\n```js\n@media(max-width: 800px){\n  .flex-container{\n    flex-wrap: wrap;\n  }\n}\n```\n\n브라우저에서 데모 페이지를 열고 창 크기를 변경해보세요.\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 링크를 참조해보세요:  [링크](https://ackoch.github.io/image-zoo/002-small-teaser-naive.html)\n\n첫눈에는 모든 것이 잘 보일 것입니다. 그러나 주의 깊게 살펴보면, 로드된 이미지가 이미지의 실제 너비에 맞추어 정렬되지 않는 것을 알 수 있을 겁니다. 이미지 해상도가 뷰포트의 실제 너비에 맞추어 정렬됩니다.\n\n옆으로 나열된 경우에도 브라우저가 1500px 이미지를 로드하고 있습니다. 그러나 800px 이미지로도 충분히 표시될 수 있습니다. 줄바꿈된 경우에도 1200px 이미지가 로드되는 것을 보실 수 있을 겁니다. 이 경우에도 800px 후보 이미지로도 충분합니다.\n\n이게 왜 발생하는 걸까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저는 가능한 빨리 이미지를 로드합니다: `img` 태그를 구문 분석할 때입니다. 그 시점에는 문서가 완전히 로드되지 않았기 때문에 브라우저는 페이지 레이아웃을 완전히 수행할 수 없고 어떤 후보 이미지를로드해야 하는지 결정할 수 없습니다. 따라서 이미지 품질을 잃지 않도록 발견한 가장 큰 후보를로드합니다.\n\n브라우저가 문서가 로드되고 페이지가 완전히 렌더링된 후에 결정하는 것이 더 나을 수 있다고 주장할 수 있습니다. 그러나 이렇게 하면:\n\na) 이미지로드가 약간 지연되었고 인지적 성능이 느려질 수 있습니다.\n\nb) 이미지가 주변 `div`에 의해 제약되지 않았을 경우(예: width: 100%로 수행한 것처럼) 일부 다시 렌더링이 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저가 조금 더 작은 정보로 이미지를 미리로드하는 것은 성능 및 교환의 상과 관련이 있습니다.\n\n실제로 이 동작은 HTML5 표준에 따라 이루어집니다.\n\n제가 일부러 여기에 오류를 만들었어요. 포인트를 증명하기 위해서 말이에요. MDN의 srcset 문서를 확인해보세요 [6]:\n\nsrcset에 \"w\" 설명자가 포함된 경우, 브라우저는 이 설명자를 sizes 속성과 함께 사용하여 리소스를 선택함니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번역해 드릴게요: \"브라우저는 요소 내 이미지의 너비를 모르기 때문에 크기 속성을 명시적으로 정의해야 합니다.\"\n\n자, 그것을 해봐요:\n\n```js\n\u003cdiv class=\"card\"\u003e\n  \u003cimg srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n               https://dummyimage.com/800x800/D5E8D4/000 800w,\n               https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n               https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n       sizes=\"40vw\"\n       id=\"card1\"\u003e\n       ...\n\u003c/div\u003e\n```\n\n이 속성 sizes=\"40vw\"는 이미지가 뷰포트 너비의 40%를 차지한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지가 화면 가장자리까지 표시되지 않고 양옆과 가운데에 약간의 여백이 남아 있기 때문에 50%가 아닌 40%를 선택했어요. 40%는 대략적인 추정입니다. 의심스러우시다면 더 큰 값을 선택하여 품질을 희생하지 마세요. 이미지가 정확하게 일치할 필요는 없습니다. 왜냐하면 이미지 후보자들은 우리 예제에서 대략 200px 간격으로 있거든요.\n\n이제 이미지들은 sizes 속성에서 정의된 대로 맞춰졌어요:\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_10.png\" /\u003e\n\n\nhttps://ackoch.github.io/image-zoo/002-small-teaser-sizes.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데스크톱 모드에서는 적어도 문제가 세세해도 어색함이 없지만, 모바일 모드에서는 여전히 괜찮아 보이지 않아요. 이 차이는 크기를 출력하지 않으면 놓칠 수 있는 부분일 거에요:\n\n![Responsive Image Example](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_11.png)\n\n렌더링된 이미지의 물리적 너비는 1000픽셀이에요. 하지만 브라우저는 600픽셀 후보를 불러옵니다. 40vw 미디어 쿼리를 평가하여 1298px * 40% = 519px 이 되기 때문이에요. 따라서 가장 적합한 후보는 600픽셀 이미지예요.\n\nsizes 속성을 개선해야 해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cdiv class=\"card\"\u003e\n  \u003cimg srcset=\"https://dummyimage.com/600x600/D5E8D4/000 600w,\n               https://dummyimage.com/800x800/D5E8D4/000 800w,\n               https://dummyimage.com/1200x1200/D5E8D4/000 1200w,\n               https://dummyimage.com/1500x1500/D5E8D4/000 1500w\"\n       sizes=\"(max-width: 800px) 90vw,\n              (min-width: 801px) 40vw\"\n       id=\"card2\"\u003e\n  ...\n\u003c/div\u003e\n```\n\n`sizes` 속성은 미디어 쿼리 / 너비 쌍의 목록을 가져옵니다. 여기서 우리는 다음을 지정합니다:\n\n- 뷰포트의 800px까지 이미지는 뷰포트 너비의 90%를 차지합니다 (간격 포함한 단일 열).\n- 801px 이상부터 40%만으로도 충분합니다 (간격을 고려한 두 열).\n\n이제 모든 경우가 적절한 이미지 차원으로 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_12.png)\n\nSee: [link](https://ackoch.github.io/image-zoo/002-small-teaser-sizes-responsive.html)\n\n# Interlude: The CMS Point of View\n\nLet’s take a short break here.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 섹션에서 브라우저가 이미지를 즉시 로드할 수 있도록 몇 가지 추가적인 마크업이 필요하다고 설명했습니다. 브라우저의 관점에서는 합리적인 접근 방식입니다. 그러나 아키텍처적인 측면에서는 이 해결책이 최적이라고 생각하지 않습니다. 특히 CMS 애플리케이션의 맥락에서는:\n\na) 구성 요소는 적합한 미디어 쿼리를 렌더링할 수 있도록 렌더링되는 컨텍스트를 인지해야 합니다. 뷰포트 너비의 1/1을 차지하는 페이지와 너비의 1/3만 차지하는 여백 열에서 동일한 탄성 \"이미지\" 구성 요소를 재사용하려면 해당 다른 컨텍스트에 대해 명시적으로 구성해야 합니다. (예를 들어 AEM에서 컴포넌트 정책을 사용할 수 있습니다). 이미지 구성 요소를 1/3 뷰포트 너비만 사용하는 티저로 재사용하는 경우 더 복잡해집니다.\n\nb) 일반적으로 CSS에서 분리되어 유지되는 미디어 쿼리 정의가 HTML 마크업으로 누설됩니다. 이제 CSS와 HTML에서 미디어 쿼리를 일치시켜야 하며, 이는 다중 테넌트 플랫폼에서 공유된 컴포넌트 라이브러리를 재사용하기 더 복잡하게 만듭니다. 다른 스타일링을 위해 CSS만 변경할 수 없습니다. 컴포넌트의 렌더링을 매개변수화해야 합니다.\n\nc) \"버그\"를 발견하기 어렵습니다. 우리의 예에서, 해상도가 너무 높거나 너무 낮은지 확인하는 것은 상대적으로 쉬웠습니다. 그래나 이미지의 고유한 크기를 알려주기 때문에 가능했습니다. 사진에서는 문제가 너무 낮은 해상도일 때만 발생합니다. 우리가 해상도를 \"과다 할당\"하고 있는지 파악하기가 훨씬 더 어렵습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 브라우저 캐시는 혼란을 가중시킵니다. 테스트는 정말로 어렵고 거의 모든 테스터들이 반응형 이미징 개념을 잘 이해하지 못합니다.\n\n# 텍스트 이미지\n\n![텍스트 이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_13.png)\n\n아직 끝나지 않았습니다. 다음 사용 사례, 텍스트 이미지 구성 요소에는 다른 측면이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데스크톱 화면에서는 이미지의 너비가 33%이고 1:1 비율을 갖도록 설정되어야 합니다. 모바일 장치에서는 이미지가 100%로 표시되며 3:1 형식으로 표시됩니다. 단순 축소만으로는 도움이 되지 않습니다.\n\n우리는 주위에 `div`를 사용하여 높이를 제한하고 `img`를 \"object-fit: cover\"로 설정할 수 있습니다. 하지만 그렇게 하면 여전히 전체 이미지를 전송하고 그 중 2/3을 버려야 합니다. 그리고 잘라내기는 간단히 중심을 자를 것입니다.\n\n다행히도 두 가지 고정된 종횡비만 있는 것을 미리 알고 있습니다. 그리고 언제 어떤 것을 적용해야 하는지 정확히 알고 있습니다. 그래서 `picture` 태그를 사용할 수 있습니다:\n\n```jsx\n\u003cpicture class=\"image\"\u003e\n  \u003csource srcset=\"\n      https://dummyimage.com/100x100/C0CCDE/000\u0026text=square+500 500w,\n      https://dummyimage.com/200x200/C0CCDE/000\u0026text=square+600 600w,\n      https://dummyimage.com/300x300/C0CCDE/000\u0026text=square+700 700w,\n      https://dummyimage.com/600x600/C0CCDE/000\u0026text=square+800 800w,\n      https://dummyimage.com/800x800/C0CCDE/000\u0026text=square+900 900w,\n      https://dummyimage.com/1000x1000/C0CCDE/000\u0026text=square+1000 1000w,\n      https://dummyimage.com/1200x1200/C0CCDE/000\u0026text=square+1200 1200w,\n      https://dummyimage.com/1500x1500/C0CCDE/000\u0026text=square+1500 1500w\"\n    sizes=\"30vw\"\n    media=\"(min-width: 801px)\"\u003e\n\n  \u003csource srcset=\"\n      https://dummyimage.com/500x166/C0CCDE/000\u0026text=panorama+700 700w,\n      https://dummyimage.com/600x200/C0CCDE/000\u0026text=panorama+800 800w,\n      https://dummyimage.com/900x300/C0CCDE/000\u0026text=panorama+900 900w,\n      https://dummyimage.com/900x300/C0CCDE/000\u0026text=panorama+1000 1000w,\n      https://dummyimage.com/900x300/C0CCDE/000\u0026text=panorama+1200 1200w,\n      https://dummyimage.com/1500x500/C0CCDE/000\u0026text=panorama+1500 1500w\"\n      sizes=\"85vw\"\n      media=\"(max-width: 800px)\"\u003e\n\n  \u003cimg src=\"https://dummyimage.com/900x300/C0CCDE/000\u0026text=panorama+900\" \n       id=\"card3\" \u003e\n\n\u003c/picture\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시의 표 태그를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Responsive Image and Dynamic Media](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_14.png)\n\n이런! 이미지를 30vw로 구성했던 것 같아요. viewport 너비의 30%로 설정했었지만, 실제로는 주요 콘텐츠 영역의 30%만 필요한 거 같네요. 낮은 해상도에서는 콘텐츠 영역과 viewport가 동일한 너비이기 때문에 문제가 없었어요. 1024px 이상에서는 콘텐츠 영역의 너비가 고정되어 확장되지 않아요. 우리는 잘못된 참조점을 사용하여 필요한 이미지 너비를 불필요하게 늘리고 있어요: 1024px * 30% ~ 300px 크기의 이미지가 필요한데, 1500px 너비의 viewport에서는 1500px * 30% ~ 500px 이미지를 요청하고 있어요 (또는 2배 레티나 디스플레이를 사용하는 경우 약 600px 대 약 1000px). \n\n문제는 주요 콘텐츠 영역의 max-width 제약이 소스 요소의 미디어 쿼리에 반영되지 않는다는 것이에요. 이를 수정하기 위해 1024px 이상의 다른 브레이크포인트를 추가하는 것으로 해결할 수 있어요:\n\n\n```js\n\u003csource srcset=\"https://dummyimage.com/500x500/C0CCDE/000\u0026text=square+600\"\n        media=\"(min-width: 1024px)\"\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기를 참고해 주세요: https://ackoch.github.io/image-zoo/003-text-image-art-direction.html\n\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_15.png)\n\n\n내 컴퓨터에서는 잘 작동하고 아마 당신의 것에서도 잘 작동할 것입니다. 그러나 브라우저의 논리적 해상도보다 이미지에서 두 배 더 많은 픽셀을 표시할 수 있는 화면이 있음을 기억하세요. 위 예제에서는 2배의 장치 픽셀 비율(1024 x 33% * 2 ≈ 675)을 가정합니다.\n\n고정 크기 이미지에 대해 서로 다른 장치 픽셀 비율을 구분하려면 srcset 정의에서 약간 다른 구문을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csource srcset=\"https://dummyimage.com/300x300/C0CCDE/000\u0026text=square+300 1x,\n                https://dummyimage.com/600x600/C0CCDE/000\u0026text=square+600 2x\"\n        media=\"(min-width: 1024px)\"\u003e\n```\n\n여기에서는 저해상도 화면에 300px 이미지를 사용하고 고해상도 화면에는 600px 변형을 사용합니다.\n\n결과는 여기에서 확인할 수 있습니다: https://ackoch.github.io/image-zoo/003-text-image-art-direction-capped-dpr.html\n\n# 사이드노트: 파라미터 가져오는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`picture` 및 `srcset`를 사용하려면 정의해야 할 많은 매개변수가 있습니다. 이러한 매개변수를 어떻게 얻을까요? 이는 상황에 따라 다릅니다. 아주(!) 잘 설계된 스타일 가이드가 있다면 해당 스타일 가이드에서 미디어 쿼리를 계산할 수도 있습니다. 그러나 저는 구현된 페이지를 자세히 살펴보고 상식을 적용하는 것이 더 실용적이라고 생각했습니다. 일반적으로 100px 또는 200px 간격으로 이미지 후보를 제공합니다. 그래서 그것은 정확한 과학은 아닙니다. 특정 브레이크포인트에서 이미지가 뷰포트의 약 1/3을 차지한다는 것을 알고 있고, 요소 사이의 공간을 고려하여 sizes=\"30vw\"로 안전하게 정의할 수 있습니다. 일부 실험을 통해 이를 28%로 낮출 수도 있습니다.\n\n테스트하는 모니터의 디바이스 픽셀 비율을 알아야 합니다. 즉, 특정 브레이크포인트에서 논리적인 차원을 300px부터 800px 사이로 측정한다면, 1x 모니터와 좁은 뷰포트를 위해 300px 이미지 후보를 제공하고 넓은 화면 2x 모니터를 위해 1600px 버전을 제공해야 합니다.\n\n# 큰 티저\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫눈에는 Large Teaser가 텍스트와 이미지 구성요소처럼 보입니다. 그러나 여기서는 이미지의 높이를 항상 텍스트 상자의 높이에 맞추고 싶습니다.\n\n데스크톱에서 이미지는 화면 너비의 33%를 사용합니다. 모바일 화면에서는 이미지가 쌓이고 화면 너비의 100%를 사용하며 3:1로 표시됩니다. 텍스트 이미지 구성요소와는 달리 이미지의 높이는 가변적입니다. 이미지의 높이는 텍스트 블록의 높이로 정의됩니다. 긴 복사 텍스트는 보다 늘어진 형식으로 이어집니다:\n\n![이미지 1](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_17.png)\n\n![이미지 2](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_19.png)\n\nThe image can have any aspect ratio and does not conform to any of the pre-defined formats. We can see that it’s getting dynamically narrower the longer the text gets. Remember, that Dynamic Media’s Smart Cropping requires an exact and pre-defined aspect ratio.\n\nThere are two ways to solve that:\n\n## Dynamic Cropping without Dynamic Media\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDynamic Media를 사용하지 않으면 이미지의 크기를 제한하기 위해 `img` 주위에 래핑 된 `div`를 만들 수 있습니다. 그런 다음 `img` 태그는 다음과 같이 스타일을 지정할 수 있습니다.\n\n```js\nheight: 100%;\nwidth: 100%;\nobject-fit: cover;\nposition: absolute;\n```\n\n기본적으로 이미지는 상대적인 측면에서 고르게 잘립니다. object-position 매개변수로 영향을 받을 수 있습니다.\n\n```js\nobject-position: 50% 50%;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가운데 맞춤 자르기를 나타냅니다.\n\n`object-position: 0% 100%;`은 이미지를 왼쪽에서 0%, 위쪽에서 100% (즉, 아래에서) 위치에 배치하며, 이는 기본적으로 오른쪽 상단에서 자르는 것을 의미합니다. 다시 말해, 이는 남서쪽 사분면에 초점이 있음을 가정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저에서는 여전히 전체 이미지를 전송하지만 가장자리가 잘립니다. 따라서 여기에서는 대역폭을 낭비하고 있습니다.\n\n각 이미지마다 객체 위치를 정의해야 합니다. 전역 스타일 시트에서 이를 정의하는 것은 의미가 없습니다. 각 이미지에는 다른 자르기 매개변수가 필요합니다.\n\n콘텐츠 관리 시스템에서는 일반적으로 작성자에게 이러한 매개변수를 제공하도록 요청합니다. 예를 들어 Part I에서 제안한 3x3 매트릭스로요. 또는 작성자에게 모든 가장자리에서 안전하게 자를 수 있는 이미지만 사용하도록 권장할 수도 있습니다.\n\n![Responsive Image](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왼쪽의 사진은 중앙에 아무것도 없습니다. 기본 모드에서 브라우저는 사진의 흥미로운 부분을 자르게 될 것입니다. 오른쪽의 이미지는 안전하게 제거할 수 있는 가장자리의 많은 배경이 있습니다.\n\n# Dynamic Media로 동적 자르기\n\nDynamic Media는 실시간으로 스마트 자르기를 적용할 수는 없지만, 저자 경험 및 성능을 향상시키는 몇 가지 기능을 제공합니다:\n\n- 안전하게 중앙에서 자를 수 있는 영역을 정의하기 위해 스마트 사전 자르기를 사용할 수 있습니다.\n- 서버 측에서 동적 자르기를 적용하여 수행할 수 있습니다. 이를 통해 브라우저에서의 (가중치가 지정된) 중앙 자르기와 동일한 시각적 결과를 얻을 수 있습니다. 다만 이 작업은 서버에서 수행됩니다. 따라서 전송되는 이진 데이터가 작아지며 페이지 렌더링이 더욱 빨라집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스마트 프리크롭은 제품 설명서에 나오는 기능이 아니에요. 일반 스마트 크롭핑을 적용할 수 있는 간단한 방법이에요.\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_21.png)\n\n원본 이미지로 스마트 크롭을 먼저 만들어 브라우저에 전달해서 나머지 부분을 자르는 것이 아이디어에요. 첫 번째로 스마트 크롭(그리고 수동 보정도 함께)을 사용하면 가장자리가 충분한 영역을 쉽게 찾을 수 있어요.\n\n# 다이나믹 크롭\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDynamic Media에는 또 다른 강점이 있습니다. 우리는 다음과 같은 URL을 사용하여 서버 측에서 자르기를 할 수 있습니다:\n\nhttps://techsupporteu.scene7.com/is/image/AEMEMEAPractice/AdobeStock_636568731?fit=crop\u0026wid=300\u0026hei=100\n\nfit=crop 매개변수는 Dynamic Media에게 이미지를 너비와 높이로 정의된 사각형에 맞추어 그려진 명시적들을 잘라 제거하세요.\n\n만약 우리가 HTML5만으로 후보 중 하나를 선택하고 있다면, 이것은 특별히 유용하지 않을 수 있습니다. 우리가 동적 자르기를 위해 필요한 정적 URL이나 URL의 범위를 정의할 수 없기 때문입니다. 우리가 사용자 지정 이미지 로더를 구현할 때 Dynamic Media의 동적 자르기 기능을 완전히 최대한 활용하는 방법과 다이나믹 자르기 기능을 완전히 활용하는 방법에 대해 다룬 이 시리즈의 제4부를 참고하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AEM 코어 컴포넌트 만들기\n\n우리는 이제 모든 중요한 사용 사례를 모두 조합했습니다.\n\n어차피 AEM 코어 컴포넌트를 사용하는 게 어떨까요? 그게 편하지 않을까요?\n\n안타깝지만 그렇지 않아요. AEM 코어 컴포넌트는 다이나믹 미디어를 위한 제한된 지원만 제공합니다. 또한 컴포넌트마다 지원하는 정도가 다릅니다. 지원하는 내용의 몇 가지 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_22.png)\n\n이미지 구성 요소는 스마트 크로핑을 지원합니다. 그러나 비율적인 스케일링은 허용되지 않습니다. 모든 뷰포트 크기에서 원본 해상도를 사용합니다. 아트 방향이나 브라우저 크로핑은 지원되지 않습니다. 하지만 이러한 구성 요소에는 대개 필요하지 않습니다.\n\n이미지 목록은 브라우저에서 크로핑되며 이는 스마트 크로핑에 이상적인 사용 사례일 것입니다. 적어도 이미지를 축소합니다.\n\n티저는 브라우저에서만 크로핑됩니다. 이는 스마트 사전 크로핑에 좋은 후보였을 것입니다. 이미지에 대한 아트 방향을 지원하지 않지만 데스크탑과 모바일의 형식은 매우 다릅니다. 다시 말해, 기본 크로핑만 적용되어 대역폭을 낭비하며 최적의 결과를 얻지 못합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 구성 요소의 스케일링 단계는 이미지 코어 구성 요소의 정책에서 정의됩니다. 이 구성은 모든 구성 요소에 적용되어야 하므로 srcset에 후보 URL이 매우 긴 목록으로 생성됩니다. 기본적으로 100px에서 1600px까지 13개의 후보 이미지가 있습니다. 저는 각 구성 요소에 개별적인 srcset을 구성하는 것이 더 나았을 것 같아요. 이것은 조금은 미학적인 문제입니다. 전체 HTML이 조금은 늘어납니다만 너무 많이 늘지는 않아요.\n\n지원이 더 좋을 수 있다는 것을 깨달은 첫 번째 사람은 아니에요. wcm.io [7] 프로젝트에는 동적 미디어에 대한 더 나은 지원을 약속하는 고급 미디어 핸들러가 있습니다. 하지만 아직 시도해보지는 않았어요.\n\n# 결론\n\n파트 IV에서는 동적 미디어의 대역폭을 최대한 끌어내는 사용자 정의 이미지 로더를 구현하는 방법에 대해 다룰 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 감사의 말\n\n친애하는 동료들인 Eryk Lagun과 Rob Freeman에게 영감, 교정 및 사실 확인에 대해 감사드립니다.\n\n# 참고 문헌\n\n[1] https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[2] [Adobe Dynamic Media Developer Resources - Image Serving API - HTTP Protocol Reference - Command Reference](https://experienceleague.adobe.com/docs/dynamic-media-developer-resources/image-serving-api/image-serving-api/http-protocol-reference/command-reference/c-command-reference.html)\n\n[3] [Adobe Experience Manager Learn - Smart Crop Feature Video Use](https://experienceleague.adobe.com/docs/experience-manager-learn/assets/dynamic-media/images/smart-crop-feature-video-use.html)\n\n[4] [Adobe Experience Manager Cloud Service - Dynamic Media Image Profiles](https://experienceleague.adobe.com/docs/experience-manager-cloud-service/content/assets/dynamicmedia/image-profiles.html)\n\n[5] [Image Zoo GitHub Repository](https://github.com/ackoch/image-zoo/blob/master/README.md)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[6] https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset\n\n[7] https://wcm.io/handler/media/usage.html","ogImage":{"url":"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png"},"coverImage":"/assets/img/2024-06-23-ResponsiveImagingandDynamicMediadoneRightPartIII_0.png","tag":["Tech"],"readingTime":23},{"title":"JavaScript로 페이지 콘텐츠 변경 및 추가하는 방법","description":"","date":"2024-06-23 14:35","slug":"2024-06-23-JavaScriptChangingandAddingPageContent","content":"\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png)\n\n이제 우리는 바꾸려는 요소를 DOM에서 쿼리하는 방법을 알게 되었습니다. 이제는 그 요소들로 무엇을 하는지 살펴봅시다.\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_1.png)\n\n이 첫 번째 p 태그를 가져와서 그 안의 텍스트를 추출해 봅시다. 그리고 그 내용을 변경해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_2.png)\n\n여기서는 첫 번째 p 태그를 찾는 document.querySelector 메서드에 대한 참조를 저장하고 있습니다. 그런 다음 para.innerText를 \"Yo!\"로 설정하고 있습니다. innerText는 메서드가 아닌 속성이기 때문에 괄호를 사용하지 않습니다.\n\n![이미지](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_3.png)\n\n한 번에 여러 가지를 변경해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_4.png)\n\nHere I'm using querySelectorAll to get all the p tags. Then I'm using the forEach method to simply log out each one.\n\n![Image 2](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_5.png)\n\nNow I'm just appending 'new text' to each p tag.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무언가의 HTML을 변경하고 싶다면 어떻게 해야 할까요?\n\n첫 번째 단계는 해당 요소에 대한 참조를 가져오는 것입니다.\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_6.png)\n\n여기서 content 클래스에 대한 참조를 가져와 innerHTML을 로깅하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_7.png)\n\n그런 다음 innerHTML 속성을 사용하여 해당 요소의 실제 HTML을 변경할 수 있습니다.\n\n여기 가정해 봅시다!\n\n우리가 사람들의 데이터베이스를 보고 있는 것으로 상상해 봅시다. 그리고 각 사람에 대해 HTML 템플릿을 만들어 브라우저에 출력하고 싶습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Esh6L4NcymzAF3vIW5MQfw.gif)\n\n여기서 people이라는 배열을 만들고 forEach 메소드를 사용하여 .content 요소의 innerHTML을 변경하고 있습니다. 내용을 추가하므로 브라우저에는 이름 목록과 함께 페이지 요소를 검사할 때 div 내부에 이름 목록이 표시됩니다.\n","ogImage":{"url":"/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png"},"coverImage":"/assets/img/2024-06-23-JavaScriptChangingandAddingPageContent_0.png","tag":["Tech"],"readingTime":2},{"title":"iframe과 부모 앱 간의 통신 방법","description":"","date":"2024-06-23 14:34","slug":"2024-06-23-Communicationbetweeniframeanditsparentapp","content":"\n\n여기에서는 iframe과 해당 부모 앱 간의 통신이 가능한 방법을 간단히 설명하고 있어요.\n\n이 경우에는 브라우저에로드되는 주 응용프로그램이자 iframe을 포함하고 있는 부모 응용프로그램이 있습니다. 여기에서는 iframe의 src 속성을 통해 다른 웹 페이지를 로드하고 있어요. 따라서 부모 앱과 iframe의 두 가지 원본이 있죠.\n\n![iframe and its parent app communication](/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png)\n\n## 시나리오 1 - 부모와 iframe이 동일한 출처를 가지고 있으며 부모 및 자식 모두를 제어할 수 있는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 부모는 www.abc.com을 가지고 있고 자식은 www.abc.com/child를 가지고 있습니다.\n\n이 경우 브라우저는 부모에서 자식으로, 그리고 자식에서 부모로 window 객체를 통해 통신을 허용합니다.\n\n부모 - 자식\n\n```js\n// 자식 앱에서\n// window 객체에 메소드 바인딩\nwindow.childCallback = function() {\n  console.log('부모가 자식 메소드 호출 중');\n}\n\n// 부모 앱에서\n// iframe 로드\n\u003ciframe id='iframe' src=\"http://www.abc.com/child\"/\u003e\n// iframe window을 통해 메소드 호출\nconst iframe = document.getElementById(\"iframe\");\niframe.contentWindow.childCallback();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChild - Parent\n\n```js\n// Parent 앱에서\n// window 객체에 메소드를 바인딩합니다.\nwindow.parentCallback = function() {\n  console.log('자식이 부모 메소드를 호출합니다');\n}\n\n// Child 앱에서\n// window 객체를 통해 메소드를 호출하세요\nwindow.parent.parentCallback();\n```\n\n데모 보기 - https://thinugigs-iframe-test-same-origin.web.app/\n\n소스코드(간단한 리액트 앱) - https://github.com/thinugigs/-Iframe-test-same-origin\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 시나리오 2 - 부모와 아이프레임이 서로 다른 출처를 가지고 있고 부모와 자식 요소를 모두 제어할 수 있는 경우\n\n부모 요소의 출처이 www.abc.com이고 자식 요소의 출처이 www.xyz.com인 경우를 예로 들어보겠습니다.\n\n이 시나리오에서 브라우저는 postMessage를 통해 부모에서 자식으로 통신하거나 자식에서 부모로 통신하는 것을 허용합니다.\n\n부모 - 자식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 자식 애플리케이션에서\n// 윈도우 객체에 메시지 이벤트 리스너를 연결합니다\nwindow.addEventListener(\"message\", function(event) {\n  console.log('부모가 자식 메소드 호출 중');\n});\n\n// 부모 애플리케이션에서\n// iframe만 로드합니다\n\u003ciframe id='iframe' src=\"http://www.xyz.com\"/\u003e\n// iframe 창을 통해 메시지를 전송합니다\nconst iframeWindow = document.getElementById(\"iframe\").contentWindow;\niframeWindow.postMessage(\"\", \"*\");\n```\n\n자식 - 부모\n\n```js\n// 부모 애플리케이션에서\n// 윈도우 객체에 메시지 이벤트 리스너를 연결합니다\nwindow.addEventListener(\"message\", function(event) {\n  console.log('자식이 부모 메소드 호출 중');\n});\n\n// 부모 애플리케이션에서\n// 부모 객체를 통해 메시지를 전송합니다\nparent.postMessage(\"\", \"*\");\n```\n\n샘플 데모 - https://thinugigs-iframe-test-different-origin-parent.web.app/\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원본(간단한 html 앱입니다) - https://github.com/thinugigs/-iframe-test-different-origins\n\n## 시나리오 3 - 부모와 아이프레임이 서로 다른 출처를 갖지만 부모나 자식 중 한 곳을 제어할 수 있는 경우\n\n이러한 시나리오에서 당신은 부모 앱 또는 자식 앱 중 하나에 속할 수 있습니다. 따라서 한쪽에서만 메시지 구현이 가능하여 상호 통신을 양방향으로 할 수 없게 됩니다, 즉 부모에서 자식으로, 그리고 자식에서 부모로의 통신이 불가능해집니다.\n\n따라서 다음은 우리가 경험한 내용의 요약입니다.","ogImage":{"url":"/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png"},"coverImage":"/assets/img/2024-06-23-Communicationbetweeniframeanditsparentapp_0.png","tag":["Tech"],"readingTime":3},{"title":"PDF 분할 로드  풀스택 솔루션 안내","description":"","date":"2024-06-23 14:32","slug":"2024-06-23-PDFSliceLoadingFullStackSolution","content":"\n\n# 서문\n\n본 문서는 PDF 파일을 로딩하는 최적화 솔루션에 대해 풀 스택 관점에서 설명합니다. 서버인 NestJS를 통해 PDF 파일을 업로드하고 노드를 통해 PDF를 이미지로 나누는 과정을 거칩니다. 그 후, 모바일 H5는 원본 PDF 파일 자원이 로드될 때까지 이미지를 우선적으로 로딩합니다. 그 이후에 PDF 소스 파일이 표시되며 사용자 제스처 확대/축소 및 복사 기능을 지원합니다.\n\n# 배경\n\n전반적으로 프런트엔드 페이지에서 PDF 파일을 로드해야 하는 필요성이 종종 발생합니다, 특히 정부 기관, 금융 업계 등에서 많이 발생합니다. PDF 파일은 여러 객체(텍스트, 이미지, 폰트 등)를 포함하는 컨테이너로, 파일 내부에는 어떤 순서로든 저장될 수 있습니다. 전체 PDF 파일은 네트워크로부터 다운로드된 후 파싱되어 렌더링되어야 페이지에 올바르게 표시됩니다. PDF 파일이 수십 메가바이트 또는 수백 메가바이트일 때, 사용자들은 PDF 파일 콘텐츠를 보기 위해 오랜 시간을 기다려야 합니다. 모바일 기기에서 PDF 파일을 여는 데 필요한 대기 시간은 더욱 길어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스키마 비교\n\n- HTTP Range Requests 헤더\n- PDF 조각 잘라내기\n\n솔루션 1: 프론트 엔드는 PDF 파일에 대한 네트워크 페이징 요청을 생성하며, 네트워크 병렬 요청은 리소스 다운로드 과정을 가속화합니다. 서버는 이 Content-Range을 지원하도록 수정되어야 하지만, 이 방법은 가시 범위 내의 우선 순위로 페이지 로드를 제어하기 어려운 문제가 있습니다.\n\n솔루션 2: 이것은 이 장에서 소개하는 주요 내용입니다. 이 방법의 장점은 가시 범위 내의 PDF 콘텐츠를 먼저 로드할 수 있어 첫 화면에서 PDF 콘텐츠를 렌더링하는 시간을 크게 단축할 수 있다는 것입니다. 그러나 이 방법의 단점은 조각으로 표시된 PDF 이미지가 확대 및 복사를 지원하지 않는다는 것입니다. 제스처 확대 및 복사는 원본 PDF 파일이 로드될 때까지 지원되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# PDF 분할 솔루션 비교\n\n운영 환경: Chrome 브라우저에서 모바일 기기로 PDF를 로드하는 시뮬레이션, 네트워크는 4G로 설정\n\n로드된 PDF 파일: NVIDIA 2024년 제1분기 재무 보고서 PDF 파일, 페이지 번호 183, 파일 크기: 34.8MB\n\n이 그림은 원본 PDF 로딩 효과를 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*6z6XdVED9HwQ4lBWiqjwMA.gif)\n  \n이 그림은 슬라이싱 솔루션로딩 효과를 보여줍니다\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*Cgp-GrVHbvSPYaunMduhZQ.gif)\n\n# 사용된 환경과 기술적인 포인트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버: 노드, 네스트져스, MulterModule, ServeStaticModule, FileInterceptor, postman 도구\n- 프론트엔드: http-server (글로벌로 설치), pdfjs, pdfh5\n\n# 노드 서버\n\n서버는 업로드된 PDF 리소스를 페이지 번호에 따라 여러 이미지로 분할하고, 로딩된 PDF API를 요청하는 것을 주로 담당합니다. 인터페이스는 PDF 리소스 주소와 분할로 생성된 이미지 리소스 주소를 반환하며, nestjs 프레임워크를 사용합니다.\n\n# 1. 네스트져스 프로젝트 생성 및 종속성 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, NestJS 프로젝트를 빠르게 만들고 `upload` 모듈을 업로드해 보세요. 자세한 내용이 필요하시면 NestJS 시작하기 (파트 2): 사진 업로드를 꼭 읽어보세요. `upload.module`을 수정하여 PDF 형식의 업로드를 허용하도록 변경하세요.\n\n```js\n  // src/upload/upload.module.ts\n  \n  fileFilter: (req, file, cb) =\u003e { \n     if ( \n       file.mimetype === 'image/jpeg' || \n       file.mimetype === 'image/png' || \n+       file.mimetype === 'application/pdf' ) { \n         cb(null, true); \n       } else { \n         cb(new Error('Only images (JPEG, PNG) and PDF files are allowed...'), false);\n         } \n       }\n```\n\nPDF 자르기에 필요한 도구를 설치해보세요:\n\n- pdfjs-dist: 새 버전의 사용 방법을 피하기 위해 pdf 파일 도구킷(문서 주소)을 사용하세요. 이 글은 아래와 같은 고정된 패키지를 설치합니다. @2.7.570\n- canvas: canvas를 통해 pdf 스트림을 읽어 이미지를 생성하세요.\n- @types/pdfjs-dist: pdfjs-dist 데클레어션 파일 패키지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install pdfjs-dist@2.7.570 canvas @types/pdfjs-dist --save\n```\n\n## 2. PDF 파일의 각 페이지를 이미지로 잘라내기\n\nPDF 파일을 페이지 번호에 따라 사진으로 자릅니다. 각 페이지는 한 장의 사진에 해당합니다. 잘린 사진은 루트 디렉토리 uploads/images/에 저장됩니다. 시작 파일에서 uploads/images/ 디렉토리가 있는지 확인해야 합니다. 디렉토리가 없으면 생성해야 합니다.\n\n```js\n// src/main.ts\n\nasync function bootstrap() {\n...\n+ const imagesDir = join(process.cwd(), 'uploads/images');\n+  if (!existsSync(imagesDir)) {\n+    mkdirSync(imagesDir);\n+  }\n...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스Create a class to convert PDF stream to image\n\n```js\n// src/upload/node-canvas-factory.ts\n\nimport { Canvas, createCanvas, CanvasRenderingContext2D } from 'canvas';\n\nexport class NodeCanvasFactory {\n    create(width: number, height: number) {\n        const canvas = createCanvas(width, height);\n        const context = canvas.getContext('2d');\n        return {\n            canvas,\n            context,\n        };\n    }\n\n    reset(canvasAndContext: { canvas: Canvas; context: CanvasRenderingContext2D }, width: number, height: number) {\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n\n    destroy(canvasAndContext: { canvas: Canvas; context: CanvasRenderingContext2D }) {\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n}\n```\n\nCreate a basic class for reading PDF and generating imagesupload.service\n\n```js\n// src/upload/upload.service.ts\n\nimport { Injectable } from '@nestjs/common';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { NodeCanvasFactory } from './node-canvas-factory';\n\n// 使用 require 语句导入 pdfjs-dist\nconst pdfjsLib = require(\"pdfjs-dist/es5/build/pdf.js\");\n\n@Injectable()\nexport class UploadService {\n    async convertPdfToImages(pdfPath: string, outputDir: string): Promise\u003cstring[]\u003e {\n        const pdfBuffer = await fs.readFile(pdfPath);\n        const pdfDocument = await pdfjsLib.getDocument({ data: pdfBuffer }).promise;\n        const numPages = pdfDocument.numPages;\n        const imageUrls = [];\n        for (let pageNum = 1; pageNum \u003c= numPages; pageNum++) {\n            const imageUrl = await this.processPage(pdfDocument, pageNum, outputDir);\n            imageUrls.push(imageUrl);\n        }\n        return imageUrls;\n    }\n\n    private async processPage(pdfDocument, pageNumber: number, outputDir: string): Promise\u003cstring\u003e {\n        const page = await pdfDocument.getPage(pageNumber);\n        const viewport = page.getViewport({ scale: 1.8 });\n        const canvasFactory = new NodeCanvasFactory();\n        const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n\n        const renderContext = {\n            canvasContext: canvasAndContext.context,\n            viewport: viewport,\n            canvasFactory: canvasFactory,\n        };\n\n        const renderTask = page.render(renderContext);\n        await renderTask.promise;\n\n        const imageBuffer = canvasAndContext.canvas.toBuffer();\n        const outputFileName = path.join(outputDir, `output_page_${pageNumber}.png`);\n        await fs.writeFile(outputFileName, imageBuffer);\n\n        return `http://localhost:3000/uploads/images/output_page_${pageNumber}.png`;\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThe `convertPdfToImages` 함수는 PDF 파일을 읽고 슬라이싱하여 생성된 이미지의 주소를 반환합니다. `processPage` 함수는 PDF의 각 페이지를 이미지로 변환합니다.\n\n이제 해당 업로드 PDF 리소스 인터페이스를 추가해야 합니다: `uploadPdf`\n\n```js\n// src/upload/upload.controller.ts\n\n...\nexport class UploadController {\n    ...\n    \n+    @Post('/uploadPdf')\n+    @UseInterceptors(FileInterceptor('file'))\n+    async uploadPdf(@UploadedFile() file) {\n+       const outputDir = join(process.cwd(), 'uploads/images');\n+        const filePath = join(process.cwd(), 'uploads', file.filename);\n+        const imageUrls = await this.uploadService.convertPdfToImages(filePath, outputDir);\n+        return { urls: imageUrls };\n+    }\n\n}\n```\n\n이제 Postman을 사용하여 2024년 첫 번째 분기 NVIDIA 재무 보고서를 업로드 PDF 파일로 제출해주세요. 페이지 수는 183페이지이고 파일 크기는 34.8MB입니다. 업로드 프로세스 중 PDF 슬라이싱 과정을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*I0SxO90cmJAwt4rxlvYcHA.gif)\n\n# 3. PDF 및 해당 슬라이스 이미지 주소를 얻기 위한 API 인터페이스 생성\n\npdf 및 해당 슬라이스 이미지 주소를 얻기 위한 메소드를 생성합니다. 간편함을 위해, 단계 2에서 생성된 정적 리소스 주소를 지정합니다. upload.controller.ts.Get\n\n```js\n// src/upload/upload.controller.ts\n\nimport {\n    Controller,\n    Post,\n    UploadedFile,\n    UseInterceptors,\n    Get\n} from '@nestjs/common';\n...\nexport class UploadController {\n    ...\n    \n    @Get()\n    async getPdf() {\n        const baseUrl = 'http://localhost:3000/uploads/';\n        const pdf = `${baseUrl}1718437748872.pdf`;\n        const images = [] // Slice image storage\n        // There are 187 images\n        for (let i = 0; i \u003c 187; i++) {\n            images.push(`${baseUrl}images/output_page_${i}.png`);\n        }\n        return { pdf, images };\n    }\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPostmanGet 요청: localhost:3000/upload\n\n리턴 형식:\n\n```js\n{\n   \"pdf\": \"http://localhost:3000/uploads/1718437748872.pdf\",\n   \"images\": [ \n        \"http://localhost:3000/uploads/images/output_page_0.png\",\n        \"http://localhost:3000/uploads/images/output_page_1.png\",\n        \"http://localhost:3000/uploads/images/output_page_2.png\",\n        .....\n   ] \n}\n```\n\n# 4. 서버는 CORS를 시작하여 인터페이스에 대한 크로스도메인 액세스를 허용합니다\n\n주로 나중을 위해, 프런트엔드 프로젝트 서비스는 포트 8080이며, 해당 서비스 포트 3000에 대해 크로스도메인 문제가 있습니다. 여기서 main.ts를 업로드 인터페이스에 대한 크로스도메인 액세스를 허용하도록 설정해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/main.ts\n\n+ app.use('/uploads', (req, res, next) =\u003e {\n+   res.header(\"Access-Control-Allow-Origin\", \"*\");\n+   res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n+   next();\n+ });\n\napp.use('/uploads', express.static(join(process.cwd(), 'uploads'));\n\n// Enable CORS\n+ app.enableCors({\n+    origin: '*', // Front-end address allowed\n+    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n+    credentials: true,\n+ });\n```\n\n마침내 서버가 이미지를 성공적으로 자르고 정적 리소스 디렉터리에 저장합니다. 다음으로는 PDF 슬라이스 이미지의 프론트엔드 분할 렌더링을 소개하겠습니다.\n\n# Front End\n\n본 문서에서는 H5 모바일 터미널에서 PDF 로드 속도를 최적화하는 해결책을 주로 다루므로, H5 터미널에서는 오픈 소스 프레임워크인 pdfh5를 사용하여 PDF 파일을 표시합니다. 이 문서에서는 HTML을 사용하여 pdfh5를 실행합니다. React, Vue에서 실행해야 하는 경우 저자의 해당 프레임워크 예제를 참조할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 프론트엔드 프로젝트 웹 만들기 및 로컬 서비스 시작하기\n\n프론트엔드 프로젝트 웹을 만들고 index.html을 생성해주세요.\n\n```js\n// index.html\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    /\u003e\n    \u003ctitle\u003eH5 성능을 고려한 PDF 뷰어 로딩\u003c/title\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003ch2\u003eH5 성능을 고려한 PDF 뷰어 로딩\u003c/h2\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n프론트엔드는 순수한 Html 페이지이므로 로컬로 서비스를 시작해야합니다. 여기서 http-server을 사용하여 먼저 전역으로 설치해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n npm i http-server -g\n```\n\n폴더를 열고 다음 명령어로 서비스를 시작해보세요\n\n```js\n cd web\n http-server ./ -p 8080\n```\n\n브라우저에서 localhost:8080으로 접속하면 화면이 보일 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png)\n\n## 2. 웹 프로젝트에 pdfh5 통합하기\n\npdfh5 프로젝트 다운로드\n\n```js\ngit clone https://github.com/gjTool/pdfh5.git\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 웹 프로젝트에 CSS와 JS 파일을 복사하고, index.html 코드를 수정하여 이전에 작성한 서버 인터페이스인 localhost:3000/upload 를 요청하도록 변경해보세요.\n\n아래는 수정된 index.html 코드입니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"apple-mobile-web-app-capable\" content=\"yes\" /\u003e\n    \u003cmeta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /\u003e\n    \u003cmeta name=\"format-detection\" content=\"telephone=no\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1,user-scalable=no\" /\u003e\n    \u003cmeta http-equiv=\"pragma\" content=\"no-cache\" /\u003e\n    \u003cmeta http-equiv=\"cache-control\" content=\"no-cache\" /\u003e\n    \u003cmeta http-equiv=\"expires\" content=\"0\" /\u003e\n    \u003ctitle\u003ePDFH5\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"css/pdfh5.css\" /\u003e\n    \u003cstyle\u003e\n      html, body {\n        width: 100%;\n        height: 100%;\n        padding: 0;\n        margin: 0;\n      }\n    \u003c/style\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cdiv id=\"demo\"\u003e\u003c/div\u003e\n    \u003cscript src=\"js/pdf.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"js/pdf.worker.js\"\u003e\u003c/script\u003e\n    \u003cscript src=\"js/jquery-3.6.0.min.js\" type=\"text/javascript\" charset=\"utf-8\"\u003e\u003c/script\u003e\n    \u003cscript src=\"js/pdfh5.js\" type=\"text/javascript\" charset=\"utf-8\"\u003e\u003c/script\u003e\n    \u003cscript type=\"text/javascript\"\u003e\n      var pdfh5;\n      $(function () {\n        // AJAX GET 요청을 수행하여 PDF URL을 가져옵니다.\n        $.get('http://localhost:3000/upload', function(response) {\n          if (response \u0026\u0026 response.pdf) {\n            var pdfUrl = response.pdf;\n            pdfh5 = new Pdfh5(\"#demo\", {\n              pdfurl: pdfUrl,\n              pageNum: false,\n              URIenable: false, \n              lazy: false,\n            });\n \n            // PDF 렌더링의 성공 이벤트 처리\n            pdfh5.on(\"success\", function (time) {\n              time = time / 1000;\n              console.log(\"pdf rendering completed, total time taken: \" + time + \" seconds\");\n            });\n\n          } else {\n            console.error('PDF URL을 검색하는 데 실패했습니다.');\n          }\n        }).fail(function() {\n          console.error('GET 요청 수행에 실패했습니다.');\n        });\n      });\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n브라우저가 H5 모드로 전환되었음을 확인하고, http://127.0.0.1:8080/ 로 이동하여 서버 인터페이스에 요청을 보내고, 반환된 PDF 주소가 성공적으로 로드되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_1.png)\n\n# 3. 우선 PDF 조각 렌더링하기\n\nPDF 표시에는 레이어를 다운로드한 후 렌더링이 필요하기 때문에 PDF 파일이 큰 경우 사용자는 대기해야 하는 경우가 많습니다. 이 기다리는 동안에 조각 이미지를 먼저 렌더링한 다음 네트워크를 이용하여 PDF 파일을 조각화합니다. 이렇게 하면 사용자에게 더 친화적입니다. 사용자는 원본 PDF 파일을 표시하며, 복사, 확대 등의 상호 작용을 지원합니다.\n\nslice 맵 컨테이너를 추가하고 .image-list를 만들어 서비스 인터페이스 이미지의 배열에서 가져온이미지 노드 src를 생성하십시오. 먼저 첫 번째 맵을로드한 다음 로드가 성공하면 순서대로 조각 맵을로드하십니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// index.html\n\n...\n\u003cstyle\u003e\n+ .이미지-리스트 {\n+       패딩: 12px 8px;\n+       z-인덱스: 999;\n+     }\n+     .이미지-리스트 img {\n+       상자-사이징: 테두리-박스;\n+       테두리: 없음;\n+       패딩: 0;\n+       마진: 0;\n+       너비: 100%;\n+       마진-바텀: 8px;\n+       박스-그림자: 어두운회색 0px 1px 3px 0px;\n+      }\n\u003c/style\u003e\n...\n+  \u003cdiv class=\"이미지-리스트\"\u003e\u003c/div\u003e\n   \u003cdiv id=\"demo\"\u003e\u003c/div\u003e\n\n...\n \u003cscript type=\"text/javascript\"\u003e\n+ const imageList = $(\".이미지-리스트\");\n\n    $.get(\"http://localhost:3000/upload\", function (response) {\n          if (response \u0026\u0026 response.pdf) {\n            var pdfUrl = response.pdf;\n+            var images = response.images;\n+            loadImageSequentially(images);\n...\n\n\n+function loadImageSequentially(images) {\n+        let index = 1;\n+        function loadNextImage() {\n+          if (index \u003c images.length + 1) {\n+            const img = new Image();\n+           img.src = images[index];\n+           img.onload = function () {\n+              index++;\n+             loadNextImage(); // 다음 이미지 로드\n+            };\n+            img.onerror = function (error) {\n+             console.error(\"이미지 로드 실패:\", img.src, error);\n+             index++;\n+              loadNextImage(); // 다음 이미지로 건너뜀\n+            };\n+           imageList.append(img);\n+         }\n+        }\n+        loadNextImage();\n+      }\r\n```\n\n참고: .image-list 노드는 #demo 노드앞에 있어야 첫 화면에서 먼저 PDF 자른 이미지 자원을 볼 수 있습니다. loadImageSequentially 함수는 자른 이미지 자원을 재귀적으로 로드하는 기능을 합니다.\n\n이미지를 로드할 때, 노드는 삭제해야 합니다. image-list\n\n```js\n// index.html\n\n  pdfh5.on(\"success\", function (time) {\n+       imageList.remove();\n              time = time / 1000;\n              console.log(\"렌더링 완료: \" + time + \"초\");\n  });\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n효과:\n\n![이미지](https://miro.medium.com/v2/resize:fit:400/1*vDNwCJmngtkbiZQO6Pu0ZA.gif)\n\n위의 효과를 보면, PDF가 성공적으로 로드되면 분할 이미지가 제거되면서 맨 위로 호출되는 것을 볼 수 있습니다. 이러한 상호 작용은 매우 사용자 친화적이지 않습니다. 이 전환 과정은 스크롤 바 위치를 변경하지 않고 유지해야 합니다:\n\n```js\n// index.html\n\npdfh5.on(\"success\", function (time) {\n    const scrollTop = $(window).scrollTop();\n    imageList.remove();\n    document.querySelector(\".viewerContainer\").scrollTo(0, scrollTop);\n    time = time / 1000;\n    console.log(\"pdf 렌더링 완료, 총 걸린 시간: \" + time + \"초\");\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 효과:\n\n![final effect](https://miro.medium.com/v2/resize:fit:480/1*pgy_ZFs9x3PQwi0V9s_d6g.gif)\n\n마침내 효과를 확인할 수 있습니다. PDF 원본 파일이 PDF 슬라이스 이미지로 대체되면, 프로세스가 매우 부드럽고 사용자는 전환을 거의 느낄 수 없습니다. 이것으로 고성능 PDF 로딩 풀스택 솔루션에 대한 예비 소개를 마칩니다.\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPDF 슬라이스 솔루션에 대한 많은 기사가 있지만, 그 중에서도 다양한 관점에서 자세히 설명하는 것은 많지 않아서 이 기사를 쓰게 되었습니다. 이 기사는 프론트엔드와 백엔드 솔루션 및 공동 디버깅 단계를 주로 설명합니다. 현재 솔루션의 많은 세부 사항이 더 최적화될 수 있습니다. 예를 들어: 슬라이스의 압축, PDF의 총 폭과 높이에 대한 사전 페이지 높이 획득, 이미지의 가상 목록, 애플리케이션의 네이티브 측에서의 로컬 로드, pdfh5 종속성 패키지... 등이 있습니다. 나중에 최적화 솔루션 기사가 공개될 예정이니 기대해 주세요!\n\n소스 코드 주소","ogImage":{"url":"/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png"},"coverImage":"/assets/img/2024-06-23-PDFSliceLoadingFullStackSolution_0.png","tag":["Tech"],"readingTime":16}],"page":"4","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>