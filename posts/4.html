<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular v15에 Google Analytics 추가하는 방법" href="/post/2024-06-23-AddingGoogleAnalyticstoAngularv15"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v15에 Google Analytics 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 커스텀 파이프 사용 방법" href="/post/2024-06-23-AngularCustomPipes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularCustomPipes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 커스텀 파이프 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" href="/post/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" href="/post/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" href="/post/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" href="/post/2024-06-23-UsingESLintHuskyLint-staged"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" href="/post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">OpenAI 기능 호출로 훈련 데이터 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" href="/post/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 첫 번째 라이브러리 만드는 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" href="/post/2024-06-23-MonorepoorNotMonorepo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" href="/post/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">dotenv으로 TypeScript에서 환경 변수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link posts_-active__YVJEi" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular v15에 Google Analytics 추가하는 방법","description":"","date":"2024-06-23 14:03","slug":"2024-06-23-AddingGoogleAnalyticstoAngularv15","content":"\n\n아마 당신도 저와 같이 포트폴리오를 만들고 방문자 추적을 원하시는 분들 중 하나일 것 같아요. 다음 직업에 얼마나 가까운지 확인하려고 사이트 트래픽을 추적하고 싶어하시는 분들일 것이라고 생각해요. 혹은 스타트업에서 일하고 있는데 사용자 참여를 추적하길 원하는 경우도 있을 거예요. 어떤 케이스이든 데이터는 웹 개발에서 매우 중요하며 사람들의 일상 생활과 상호 작용하는 방식으로 상당히 중요합니다.\n\n그러니까 더 이상 말이 필요 없겠죠! Angular v15를 사용하여 Google Analytics를 통해 당신의 분석을 어떻게 추적할 수 있는지 단계별로 알려드릴게요.\n\n## 단계 1: Google Analytics 가입하기\n\n우선 처음으로 Google Analytics에 가입해야 해요. 이미 가입한 경우에는 걱정하지 마세요. 아직 가입하지 않은 경우에는 걱정하지 마시고 시작하려면 이 링크의 지시에 따라 https://analytics.withgoogle.com/ 진행한 다음 이 페이지로 돌아오세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가입 절차를 완료하셨다면 또는 이미 이 과정을 완료했다면, 아래 화면을 확인해야 합니다.\n\n![Google Analytics](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png)\n\n파란색 버튼 위에 측정 ID가 표시되어 있는 것을 알 수 있을 겁니다. 제 사진에서는 측정 ID가 흐릿하게 처리되어 있습니다. 예시로, 저의 경우 일시적으로 1234로 설정되어 있습니다.\n\n## Step 2: Angular 애플리케이션에 Google Analytics 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 index.html 파일을 열어야 합니다. 파일이 열리면 아래 코드를 head 태그 밑에 추가해야 합니다. 그러나 body 위에 추가해야 합니다. 아래와 같이 보이는대로 추가해주세요:\n\n```js\n \u003c!-- Google tag (gtag.js) --\u003e\n    \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-M7DLQTY7NJ\"\u003e\u003c/script\u003e\n    \u003cscript\u003e\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n\n      gtag('config', \u003cyour_sites_measurement_ID\u003e);\n    \u003c/script\u003e\n```\n\n측정 ID는 이 튜토리얼의 1단계에서 찾은 ID로 교체해주세요. 완료하면 이와 같이 보여야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: 분석 서비스 작성하기\n\n이번에 처음으로 Angular 서비스를 생성하고 계신다면, Angular 구조를 따르기 위해 app 폴더 내에 services라는 새 폴더를 생성하는 것을 제안드립니다. 다음과 같이 보여야 합니다:\n\n![폴더 구조](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_2.png)\n\n그런 다음, 새로운 서비스를 생성하고 분석.service.ts라는 이름의 새 서비스를 만들어 새 services 폴더 안에 넣으세요. 분석.service.ts 파일 내에는 다음 코드를 적용하게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\nimport { Injectable } from '@angular/core';\n\ndeclare var gtag: any;\n\n@Injectable({providedIn: 'root'})\nexport class AnalyticsService {\n\n  trackEvent(eventName: string, eventDetails: string, eventCategory: string) {\n    gtag('event', eventName, {\n    // event Type - example: 'SCROLL_TO_TOP_CLICKED'\n    'event_category': eventCategory,\n    // the label that will show up in the dashboard as the events name\n    'event_label': eventName,\n    // a short description of what happened\n    'value': eventDetails\n    })\n  }\n}\n```\n\nvar gtag를 선언함으로써 Angular에게 애플리케이션 어딘가에 참조하려는 gtag라는 메서드가 있는 것을 알려줍니다. 이제 gtag를 index.html 파일에 가져와서 새로운 메서드를 만들 수 있게 되었습니다. 우리가 만든 새로운 메서드는 trackEvent()입니다. 각 속성이 대시보드에 어떻게 표시될지 이해하는 데 도움이 되도록 주석을 남겨 두었습니다.\n\n다음 단계는 선택 사항입니다. 그러나 대부분의 주요 응용 프로그램은 이 구조를 따르므로 이 프레임워크가 익숙하지 않다면 해당 폴더의 index.ts 파일을 업데이트하는 습관을 가져가는 것을 제안합니다. 그런 경우가 아니라면 services 폴더 내에 index.ts 파일을 생성하여 * 장식자를 사용하여 모든 서비스 콘텐츠를 내보낼 수 있도록 합니다. 아래 정보를 참고로 사용하십시오.\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 새로운 분석 서비스 사용하기\n\n이제 사용 중인 컴포넌트에 새 서비스를 가져와야 합니다. 이 튜토리얼은 v15용이므로 독립형 컴포넌트 방법을 사용할 것입니다. 이전 버전을 사용 중이라면 서비스를 컴포넌트가 포함된 모듈 또는 앱 모듈로 가져와야 합니다.\n\n당신의 파일은 Angular의 최신 버전을 사용 중이라면 다음과 유사한 모습이어야 합니다:\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 서비스를 가져와서 제공자 목록에 추가하세요. 그런 다음 @angular/core에서 ngOnInit()를 구현할 것입니다. 이렇게 하면 Angular 라이프사이클에서 생성자가 완료된 후 footer가 로드되었다는 이벤트를 보낼 수 있게 됩니다. 그런 다음 분석 서비스를 타겟팅하고 trackEvent() 메서드에 액세스하여 일부 데이터를 전달할 것입니다. 저는 footer 컴포넌트를 예시로 사용하겠습니다. 아래 이미지에서 보여지는 것처럼:\n\n![Adding Google Analytics to Angular v15_5](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_5.png)\n\n## 단계 5: 배포 및 테스트\n\n마지막 단계는 애플리케이션을 배포하고 최종 결과를 테스트하는 것입니다. 대시보드로 돌아가서 리포트에 있는 실시간 탭으로 이동할 수 있습니다. 사이트에 방문하면 지도상에서 자신을 확인할 수 있고 새 이벤트가 애플리케이션에 추가되었음을 확인할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Google Analytics Event Network Tab](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_6.png)\n\n이벤트를 트리거할 때 컬렉션 이벤트 트리거를 보게 될 것입니다. 또한 쿠키에서 태그를 볼 수 있습니다. 두 가지 이미지 모두 아래에서 확인할 수 있습니다.\n\n![Collection Event Trigger in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_7.png)\n\n![Viewing the Tag in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞으로의 개발 팁과 요령을 팔로우해주세요. 읽어 주셔서 감사합니다. 여러분의 지원에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"},"coverImage":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 커스텀 파이프 사용 방법","description":"","date":"2024-06-23 14:02","slug":"2024-06-23-AngularCustomPipes","content":"\n\nMarkdown 형식으로 테이블 태그를 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 간단한 사용자 정의 파이프 만들기\n\n우리가 하는 일을 시작하기 위해 문자열에서 각 단어의 첫 글자를 대문자로 변경하는 파이프를 만들어보는 간달한 예제부터 사용해 봅시다.\n\n1. 파이프 생성하기\n\n```js\nng generate pipe capitalize\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 로직 구현\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'capitalize'\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return value;\n    return value.replace(/\\b\\w/g, char =\u003e char.toUpperCase());\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용\n\n```html\n\u003cp\u003e{ 'hello world' | capitalize }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 매개변수를 사용한 Pipe 생성하기\n\n사용자 정의 파이프는 매개변수도 받을 수 있습니다. 이 예제에서는 어떻게 매개변수를 가진 파이프를 생성하는지 자세히 살펴보겠습니다. 이 파이프 예제는 숫자를 지정된 소수 자리로 서식 지정합니다. \n\n1. 파이프 생성하기\n\n```js\nng generate pipe decimalFormatter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Pipe Logic을 구현하세요\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'decimalFormatter'\n})\nexport class DecimalFormatterPipe implements PipeTransform {\ntransform(value: number, decimalPlaces: number): string {\n if (isNaN(value)) return value.toString();\n return value.toFixed(decimalPlaces);\n }\n}\n```\n\n3. 파라미터와 함께 Pipe 사용하기\n\n```js\n\u003cp\u003e{ 1234.56789 | decimalFormatter:2 }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 복잡한 변환에는 Pipes를 사용해요\n\n가끔, Pipes는 더 복잡한 변환을 다루어야 할 때가 있어요. 특정 속성과 값에 따라 객체 배열을 필터링하는 Pipe를 만들어 보도록 해요.\n\n1. Pipe 생성하기\n\n```js\nng generate pipe filter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 논리 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'filter'\n})\nexport class FilterPipe implements PipeTransform {\n  transform(items: any[], property: string, value: any): any[] {\n    if (!items || !property || value === undefined) return items;\n    return items.filter(item =\u003e item[property] === value);\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용하기\n\n```js\nexport class AppComponent {\n  users = [\n    { name: 'AJ', role: 'admin' },\n    { name: 'Segun', role: 'user' },\n    { name: 'Homelander', role: 'admin' },\n    { name: 'Alice', role: 'user' }\n  ];\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cul\u003e\n@for(user of users; track user | filter:'role':'admin') {\n \u003cli\u003e\n { user.name } ({ user.role })\n \u003c/li\u003e\n}\n\u003c/ul\u003e\n```\n\n## 비동기 파이프 생성하기\n\nAngular는 Observables 또는 Promises를 사용하여 비동기 파이프를 지원합니다. API에서 데이터를 가져와 표시하는 파이프를 만들어보겠습니다.\n\n1. 파이프 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate pipe fetchData\n```\n\n2. Pipe 로직 구현하기\n\n```js\n@Pipe({\n name: 'fetchData',\n pure: false\n})\nexport class FetchDataPipe implements PipeTransform {\n private http = inject(HttpClient)\n transform(url: string): Observable\u003cany\u003e {\n return this.http.get(url);\n }\n}\n```\n\n3. 템플릿에서 Pipe 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cdiv\u003e\n@if(apiUrl | fetchData | async as data) {\n \u003cpre\u003e{ data | json }\u003c/pre\u003e\n}\n\u003c/div\u003e\n//apiUrl: string = 'https://api.example.com/data'\n```\n\n## 파이프 성능 최적화\n\n기본적으로 Angular 파이프는 순수입니다. 이는 입력 참조가 변경될 때만 다시 실행됨을 의미합니다. 성능 상의 이유로 가능한 곳에서 이 동작을 활용하는 것이 중요합니다. 그러나 입력 데이터가 가변적인 경우, @Pipe 데코레이터의 pure 속성을 false로 설정하여 순수하지 않은 파이프를 생성할 수 있습니다.\n\n순수하지 않은 파이프의 예시\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 파이프 생성하기\n\n```js\nng generate pipe impure\n```\n\n2. 파이프 로직 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'impure',\n pure: false\n})\nexport class ImpurePipe implements PipeTransform {\ntransform(value: any, …args: any[]): any {\n // 사용자 정의 변환 로직\n return value;\n }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 커스텀 파이프에 대한 최상의 방법\n\n가능한 경우 Pipes Pure를 유지하여 Angular의 변경 감지 최적화를 활용하세요.\n단일 책임: 각 파이프는 단일 책임을 가져야 합니다. 변환 작업이 복잡한 경우 여러 파이프로 분리하는 것을 고려해보세요.\n성능 고려사항: 특히 복잡한 변환 작업이나 대량 데이터세트의 경우 성능에 신경을 써야 합니다. 필요한 경우 캐싱 전략을 사용하세요.\n오류 처리: 특히 외부 서비스와 상호작용이나 복잡한 작업을 수행하는 파이프의 경우 오류 처리를 구현하세요.\n재사용성: 다른 컴포넌트 및 모듈에서 재사용할 수 있는 파이프를 만들어 중복을 피하세요.\n\nAngular의 사용자 정의 파이프는 템플릿에서 데이터를 직접 변환하고 형식화하는 강력한 방법을 제공합니다. 이는 간단한 텍스트 변환부터 복잡한 데이터 조작 및 비동기 작업까지 다양할 수 있습니다. 사용자 정의 파이프를 효과적으로 이해하고 구현함으로써 Angular 애플리케이션의 가독성과 유지 관리성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularCustomPipes_0.png"},"coverImage":"/assets/img/2024-06-23-AngularCustomPipes_0.png","tag":["Tech"],"readingTime":4},{"title":"NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법","description":"","date":"2024-06-23 14:00","slug":"2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations","content":"\n\n상태 데이터와 데이터베이스를 다루는 것은 어렵습니다. 특히 프로젝트가 시간이 지남에 따라 커지면 더욱 어려워집니다. 개발 프로젝트의 성공을 위해서는 처음부터 좋은 개발 및 프로젝트 설정을 갖추는 것이 중요합니다. 이 글에서는 대부분의 프로젝트를 설정하는 방법을 보여드리고, 설정 뒤에 있는 몇 가지 생각을 강조하려고 합니다.\n\n이 예시에서는 데이터 저장을 위해 PostgreSQL 데이터베이스를 사용하는 간단한 NodeJS API 작업을 진행하고 개발자의 편의를 위해 일부 도구를 설정합니다.\n\n다음은 설정입니다:\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS에서 API를 빌드하기 위해 NestJS를 사용할 예정입니다. NestJS는 상당히 유연한 프레임워크로 ExpressJS 원칙에 기반을 두고 있어 NodeJS 서비스를 쉽고 빠르게 개발할 수 있게 해줍니다. 이 프레임워크에는 여러 가지 편의 기능 (전체 TypeScript 지원, 의존성 주입, 모듈 관리 등)이 내장되어 있습니다.\n\n더 많은 정보를 보려면 여기 웹사이트를 방문해보세요: http://nestjs.com\n\n프로젝트와 도구\n\nNestJS는 보일러플레이트를 처리해주는 멋진 CLI 도구를 함께 제공하여 작업을 빠르게 시작할 수 있습니다. 개인적으로 CLI에서 생성된 NestJS 프로젝트가 완벽한 시작점이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 블랙 매직 코드는 실제로 무엇을 하는지 알지 못한 채 조정하거나 확장하려고 할 때 문제가 될 수 있습니다. 그래서 저는 항상 아주 작게 시작하고 필요한 기능을 시간이 지남에 따라 추가하고 배우는 것을 선호합니다. 필요하지 않거나 이해하지 못하는 많은 기능이 있는 오버블로운 스타터 프로젝트를 사용하지 않는 것이죠.\n\n프로젝트 준비하기 — 보일러플레이트\n\n좋아요, 이 몇 줄로 프로젝트를 생성하여 시작해보죠:\n\n```js\nnpm i -g @nestjs/cli\nnest new project-name\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 내용은 NestJS 및 CLI에 대해 여기에서 찾아볼 수 있어요.\n\n귀하의 프로젝트는 다음과 같이 보일 것입니다:\n\n![project image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_1.png)\n\n지금까지 모든 작업이 잘 되는지 테스트해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run start:dev\n```\n\n이제 프로젝트 기본 설정이 완료되었으니, 데이터 영속성 레이어를 추가해 봅시다.\n\n데이터베이스 스키마를 관리하기 위해 TypeORM을 사용할 것입니다. TypeORM의 장점은 TypeScript로 데이터 엔티티를 모델링할 수 있으며, 이후 이러한 모델을 데이터베이스의 테이블 구조로 적용하거나 동기화할 수 있다는 것입니다. (물론 PostgreSQL 데이터베이스뿐만 아니라 다른 데이터베이스와도 작동합니다. TypeORM 문서에서 지원하는 데이터베이스에 대한 자세한 정보 찾아보세요.)\n\n로컬 PostgreSQL 데이터베이스 인스턴스 설정 - 도커 자동화와 함께!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 데이터 지속성 작업을 위해 데이터베이스 서버와 연결해야 합니다. PostgreSQL 데이터베이스 서버를 로컬 머신에 설정해야 하는 방법 중 하나가 있지만, 저는 이 방법을 크게 선호하지 않아요. 왜냐하면 프로젝트가 내 머신에 많이 종속될 수 있기 때문이죠. 즉, 팀으로 프로젝트를 진행하거나 머신을 바꾸면 매번 다시 설정해야 하거나 어떻게든 설정 가이드를 작성해야 합니다 (서로 다른 운영 체제를 사용하는 머신에서는 더욱 까다로워집니다).\n\n그렇다면 우리는 어떻게 이 문제를 해결할 수 있을까요? 자동화를 통해!\n\n미리 구축된 PostgreSQL 도커 이미지를 사용하고 데이터베이스 서버를 도커 프로세스로 실행합니다. 이렇게 하면 몇 줄의 셸 코드로 전체 설정을 스크립팅하여 서버 인스턴스를 실행하고 연결할 준비가 끝난 빈 데이터베이스를 준비할 수 있습니다. 이것은 재현 가능하고 설정 코드를 프로젝트 코드의 나머지와 함께 소스 제어로 관리할 수 있어, 다른 개발자들이 프로젝트에 빠르게 참여할 수 있도록 만들어줍니다.\n\n이 스크립트는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 package.json 실행 스크립트에 그 명령어를 추가해서 쉽게 실행할 수 있도록 합시다.\n\n```js\n\"start:dev:db\": \"./src/scripts/start-db.sh\"\n```\n\n좋아, 이제 실행할 수 있는 명령어가 생겼고 데이터베이스 서버와 기본 데이터베이스가 설정됩니다.\n\n프로세스를 더 견고하게 만들기 위해 항상 도커 컨테이너에 동일한 이름($SERVER 변수 스크립트에서)을 사용할 거에요. — 이렇게 하면 추가적인 확인을 추가할 수 있어요 — 만약 컨테이너가 이미 실행 중이면 종료하고 제거해서 깔끔한 상태를 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS를 데이터베이스에 연결하는 방법\n\n모든 것을 위해 이미 NestJS 프로젝트를 데이터베이스에 연결하는 데 도움이 되는 NPM 모듈이 있습니다. 우리 프로젝트에 사전 빌드된 NestJS-to-TypeORM 모듈을 사용하여 TypeORM 지원을 추가해 봅시다.\n\n다음과 같이 필요한 모듈을 추가할 수 있습니다:\n\n```js\nnpm install --save @nestjs/typeorm typeorm pg\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보는 NestJS 문서에서 찾을 수 있어요.\n\n구성 관리\n\n이제 모든 것을 하나로 묶는 시간입니다.\n\nNestJS에서 TypeORM에게 어떤 데이터베이스 서버에 연결해야 하는지 알려주는 방법은 TypeOrmModule을 사용하는 것이에요.\nforRoot 메소드를 사용하여 구성을 전달할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것을 잘 작동시키려면 다음과 같이 설정 서비스를 작성할 수 있습니다.\n\n이 config 클래스의 아이디어는 API 서버 main.ts가 시작되기 전에 실행되도록 하는 것입니다. 이 클래스는 환경 변수에서 구성을 읽어오며, 실행 중에 읽기 전용으로 값을 제공할 수 있습니다.\n\n개발 및 운영 모드에 유연하게 대응하기 위해 dotenv 모듈을 사용할 것입니다.\n\n```js\nnpm install --save dotenv\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모듈을 사용하면 로컬 개발 환경의 프로젝트 루트에 \" .env\" 파일을 만들어 구성 값을 준비할 수 있고, 프로덕션 환경에서는 프로덕션 서버의 환경 변수에서 값만 읽어올 수 있습니다. 이는 매우 유연한 방식이며 이 파일을 팀 내 다른 개발자들과 쉽게 공유할 수도 있습니다.\n\n참고: 그러나 이 파일을 git으로 무시하는 것을 강력히 권장합니다. 이 파일에 실제 비밀 정보를 넣을 수 있기 때문에 프로젝트 외부로 누설되거나 실수로 커밋하는 것을 원하지 않을 것입니다.\n\n아래는 .env 파일이 어떻게 보일 수 있는지에 대한 예시입니다:\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=5432\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=mysecretpassword\nPOSTGRES_DATABASE=my_database\nPORT=3000\nMODE=DEV\nRUN_MIGRATIONS=true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 ConfigService는 싱글톤 서비스로 실행되며 시작할 때 구성 값을 로드하여 다른 모듈에 제공합니다. 서비스에는 오류 조기 패턴이 포함됩니다. 즉, 해당 서비스가 제공할 수없는 값에 대해 요청을하면 의미 있는 오류를 throw합니다. 이렇게 함으로써 구성 오류를 런타임 라이프사이클이 아닌 빌드/부트 시간에 감지하여 설정이 더 견고해집니다. 이렇게하면 서버를 배포/시작 할 때가 아닌 소비자가 API를 사용할 때 이것을 일찍 감지할 수 있습니다.\n\n이것이 ConfigService의 모습이며, NestJS 앱 모듈에 추가하는 방법입니다:\n\n이제 첫 번째 테스트를 시작할 준비가 거의 완료되었지만, 실제로 개발 시 TypeScript에서 작업하려면 nodemon과 함께 ts-node를 사용할 것이므로 특별한 nodemon.json을 사용하여 typescript 컴파일러를 활성화하는 ts-node 모듈을 사용하여 개발 서버를 실행할 수 있습니다. 그러니까 nodemon과 ts-node를 설치합시다.\n\n```sh\nnpm i --save-dev nodemon ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉토리에 debug 및 ts-node 지원이 포함된 nodemon.json 파일을 추가해주세요.\n\n```js\n{\n \"watch\": [\"src\"],\n \"ext\": \"ts\",\n \"ignore\": [\"src/**/*.spec.ts\"],\n \"exec\": \"node --inspect=127.0.0.1:9223 -r ts-node/register -- src/main.ts\",\n \"env\": {}\n}\n```\n\n마지막으로 package.json 파일의 start:dev 스크립트를 다음과 같이 수정해주세요:\n\n```js\n\"start:dev\": \"nodemon --config nodemon.json\",\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 API 서버를 시작하기 위해 npm run start:dev를 실행할 수 있어요. 시작 시 ConfigService에서 .env 값들을 가져와 데이터베이스에 TypeORM이 연결될 겁니다. 또한, 이 작업은 제 컴퓨터에 바운드되어 있지 않아요. 멋지죠!\n\n데이터 모델 엔티티를 정의하고 로드해봅시다.\n\nTypeORM은 데이터 모델 엔티티의 자동 로딩을 지원해요. 단순히 모든 엔티티를 한 폴더에 넣고 구성에서 패턴을 사용하여 로드할 수 있어요. 저희는 model/`name`.entity.ts에 엔티티를 넣었어요. (ConfigService의 TypeOrmModuleOptions의 entities 속성을 참고해주세요)\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeORM의 또 다른 멋진 기능은 Entity 모델들이 상속을 지원한다는 것입니다.\n\n예를 들어 특정 데이터 필드가 모든 엔티티에 있도록 원한다면 정말 멋진 기능입니다.\n\n예를 들어, 자동으로 생성된 UUID id 필드와/또는 createDateTime, lastChangedDateTime 필드 등이 있습니다.\n참고: 이러한 베이스 클래스들은 추상적이어야 합니다.\n\n따라서 TypeORM에서 데이터 모델 엔티티를 정의하면 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 지원되는 데이터 어노테이션을 TypeORM 문서에서 찾아보세요.\n\n파티 시간이에요 — API를 시작하고 작동하는지 확인해 봅시다.\n\n```js\nnpm run start:dev:db\nnpm run start:dev\n```\n\n… 멋지네요 — 작동하는 것 같지만, 사실 데이터베이스는 아직 데이터 모델을 반영하지 않았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 스키마를 적용하고 데이터베이스 마이그레이션을 생성하고 실행하세요.\n\n이전에 언급했듯이, TypeORM은 데이터 모델을 데이터베이스의 테이블로 동기화하는 기능을 제공합니다.\n\n이 모델의 동기화는 좋지만 위험할 수도 있습니다.\n\n왜냐하면 초창기 개발 단계에서는 좋습니다. 모든 데이터 엔티티가 아직 확정되지 않았기 때문입니다. 그래서 코드에서 클래스를 변경하면 모든 것이 데이터베이스에서 잘 동작합니다. 기본적으로 데이터베이스의 상태에 대해 생각할 필요가 그리 많지 않습니다. TypeORM이 모든 일을 대신 처리해 주니까요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기서 tricky한 부분이 나타납니다. 데이터베이스에 실제 데이터가 있을 때는 모든 엔티티 변경에서 손실을 입고 싶지 않습니다. 이것은 조금 더 복잡해집니다. 이 동기화 기능은 데이터베이스 테이블에 필요한 변경 사항을 적용하기 위해 테이블을 삭제하고 다시 생성하는 방식으로 작동합니다. 이는 테이블 내의 데이터가 손실된다는 것을 의미합니다. 당연히 프로덕션 환경에서 피해야 하지만 개발 환경에서도 예상치 못한 부작용을 야기할 수 있습니다.\n\n그래서 저는 개발 초기부터 코드에서 데이터베이스 마이그레이션을 사용하는 것을 선호합니다.\n\n이렇게 함으로써 데이터 세트의 변경 사항을 더 잘 추적하고 이에 대해 더 적극적으로 생각하게 하여 프로덕션 시나리오에서의 변경 및 데이터 손실을 방지하는 데 도움이 됩니다.\n\n그러니 이 문제를 해결해 봅시다 - 다행히 TypeORM에는 이에 대한 솔루션이 포함되어 있고, SQL 명령을 생성하는 작업을 처리하는 'CLI' 명령도 있습니다. 이를 통해 내부에 어떤 마법도 없이 생성된 SQL 명령을 쉽게 확인하고 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 typeORM CLI를 쉽게 설정할 수 있어요.\n\n1. typeORM CLI 설정\n\n이미 ConfigService로 필요한 모든 설정을 추가했어요.\n\n하지만 typeORM CLI는 ormconfig.json 파일과 함께 작동하며 올바른 설정이 있어야 해요. 또한 CLI를 실제 API 서버와 별도로 실행하고 싶어요. CLI를 사용하기 전에 설정 파일을 생성하므로 .gitignore-list에 추가해주세요. 설정 파일을 작성하는 퀵 도우미 스크립트를 추가해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { configService } from '../config/config.service';\nconst fs = require('fs');\nfs.writeFileSync('ormconfig.json',\n JSON.stringify(configService.getTypeOrmConfig(), null, 2)\n);\n```\n\n그리고 npm 스크립트 작업을 추가하여 해당 스크립트를 실행하고 typeorm:migration:generate 및 typeorm:migration:run 명령어를 실행할 수 있습니다.\n\n이렇게 하면 typeORM CLI 명령을 실행하기 전에 ormconfig가 생성됩니다.\n\n```js\n\"pretypeorm\": \"(rm ormconfig.json || :) \u0026\u0026 ts-node -r tsconfig-paths/register src/scripts/write-type-orm-config.ts\",\n\"typeorm\": \"ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js\",\n\"typeorm:migration:generate\": \"npm run typeorm -- migration:generate -n\",\n\"typeorm:migration:run\": \"npm run typeorm -- migration:run\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 마이그레이션 작성\n\n이제 이 명령을 실행하여 초기 마이그레이션을 생성할 수 있습니다:\n\n\nnpm run typeorm:migration:generate -- my_init\n\n\n이 명령은 typeORM을 데이터베이스에 연결하고 데이터베이스 마이그레이션 스크립트 my_init`timestamp`.ts(타입스크립트)를 생성하고 프로젝트의 마이그레이션 폴더에 넣습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 마이그레이션 스크립트를 소스 컨트롤에 커밋하고 파일을 읽기 전용으로 다루어야 합니다. 이 스크립트는 서로 위에 순서대로 작동합니다.\n\n만약 어떤 것을 변경하고 싶다면, cli 명령어를 사용하여 맨 위에 다른 마이그레이션을 추가하는 것이 아이디어입니다.\n\n![migration](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_3.png)\n\n3. 마이그레이션 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run typeorm:migration:run\n```\n\n이 명령어는 아직 적용되지 않은 데이터베이스에 있는 모든 마이그레이션을 적용합니다. (이미 모든 것이 최신 상태인 경우 아무 작업도 수행하지 않음)\n\n이제 API 서버 프로젝트를 실행하지 않고도 마이그레이션을 생성하고 실행하는 데 필요한 모든 도구를 갖추었습니다. 이렇게 하면 원할 때마다 다시 실행하거나 다시 만들거나 추가할 수 있어 개발 시 유연성이 높습니다.\n\n그러나 프로덕션 또는 스테이지 환경에서는 배포 후 API 서버를 시작하기 전에 마이그레이션 스크립트를 자동으로 실행하는 것이 안전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게 하면 start.sh 스크립트를 추가할 수 있어요.\n\n마이그레이션을 자동으로 실행할지 여부를 제어하기 위해 환경 변수 RUN_MIGRATIONS=`0|1`을 추가할 수도 있어요.\n\n```js\n#!/bin/bash\nset -e\nset -x\nif [ \"$RUN_MIGRATIONS\" ]; then\n  echo \"마이그레이션 실행 중\";\n  npm run typeorm:migration:run\nfi\necho \"서버 시작\";\nnpm run start:prod\n```\n\n디버깅 및 데이터베이스 도구\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와우, 우리 API 및 DB 설정이 작동하는 것 같네요! 하지만 우리 데이터베이스가 실제 데이터 모델을 잘 반영하고 있는지 확인해야 해요.\n\n이를 확인하기 위해 CLI 스크립트 쿼리를 실행하거나 빠른 디버깅을 위해 UI 데이터베이스 관리 도구를 사용할 수 있어요.\n\nPostgreSQL 데이터베이스를 사용할 때, 저는 pgAdmin을 사용해요.\n\n이 도구는 현재 상황을 보기 위한 멋진 UI를 제공하는 강력한 도구에요. 그러나 다음과 같은 워크플로우를 추천해 드릴게요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Table Image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_4.png)\n\n이제 데이터베이스에 테이블이 생성된 것을 볼 수 있습니다.\n\n1. 프로젝트에서 정의한 항목 테이블\n2. 이 테이블에서 typeORM이 이미 실행한 마이그레이션을 추적하는 마이그레이션 테이블 (참고: 이 테이블을 읽기 전용으로 처리해야만 합니다. 그렇지 않으면 typeORM CLI가 혼란스러워질 수 있습니다.)\n\n일부 비즈니스 로직 추가중\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 비즈니스 로직을 추가해 봅시다.\n데모를 위해 테이블에 있는 데이터를 반환하는 간단한 엔드포인트를 추가하겠습니다.\n\n이를 위해 항목 컨트롤러와 항목 서비스를 추가할 것이고, NestJS CLI를 사용할 겁니다.\n\n```js\nnest -- generate controller item\nnest -- generate service item\n```\n\n이렇게 하면 우리를 위한 기본 템플릿이 생성되고,\n그런 다음 우리가 추가해야 할 내용은요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'그리고 ItemModule안에서 물건들을 함께 연결하고, 그것을 AppModule에서 가져와요.\n\nAPI를 시작한 후 curl 명령어를 통해 다음을 얻을 수 있어요:\n\n```js\ncurl localhost:3000/item | jq\n[] # \u003c\u003c 데이터베이스에 아이템이 없음을 나타냅니다 - 멋지죠 :)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔티티를 노출하지 마세요 - DTO 및 응답 추가하기\n\n하나의 1대1 데이터 모델을 영속성을 통해 API를 통해 소비자에게 직접 노출시키지 않는 것이 아이디어입니다.\n\n처음 프로젝트를 설정할 때 이것을 바로 하지 않는 것은 처음에는 이점이 직접적으로 보이지 않기 때문에 유혹을 받을 수 있습니다. 물론, 각 데이터 엔티티를 데이터 전송 객체로 래핑해야 하고 직렬화 및 역직렬화를 수행해야 해서 종종 보일러플레이트처럼 느껴질 수 있습니다.\n\n항상 이런 설정을 권장합니다. 따라서 내부 데이터 모델(API to Database)과 외부 모델(API-consumer to API) 사이에 명확한 구분을 두게 됩니다. 이렇게 하면 사물을 분리시키고 장기적으로 유지보수를 더 쉽게할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 이점:\n- 도메인 주도 설계 원칙 적용을 위한 분리\n- 성능, 쿼리 최적화가 훨씬 쉽게 가능\n- 진화, 버전 관리 — 동일한 지속성으로 다른 응답을 반환\n- 테스트 용이성 — 모의(mocking)를 할 수 있음\n… 그리고 훨씬 더 많은 기능\n\n그래서 우리는 데이터베이스의 항목 엔티티에서 채워진 ItemDTO 응답 클래스를 추가할 것입니다.\n간단한 서비스와 응답 DTO는 다음과 같이 보일 수 있습니다.\n\n참고: 이를 위해 `@nestjs/swagger`, `class-validator` 및 `class-transformer`를 설치해야 합니다.\n\n이제 우리는 이 DTO를 간단하게 다음과 같이 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAPI (Swagger) 설정하기\n\nDTO 접근 방식을 통해 API 문서 (openAPI 또는 스웨거 문서)를 생성할 수도 있습니다. 간단히 다음을 설치하면 됩니다:\n\n```js\nnpm install --save @nestjs/swagger swagger-ui-express\n```\n\n그리고 main.ts 파일에 다음 몇 줄을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 다 됐어요:\n\n![이미지 이름](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_5.png)\n\n해당 주제에 대한 자세한 정보는 여기서 확인하세요.\n\n씨드 데이터 정의.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 이제 화려한 비즈니스 로직을 통해 프로젝트를 확장하는 데 필요한 거의 모든 것을 갖췄어요. 프로젝트 작업 시 당신과 팀의 생산성을 실제로 향상시킬 수 있는 것은 데이터 씨드 스크립트입니다.\n\n이 스크립트는 데이터베이스를 테스트용이나 더미 데이터로 설정합니다. 우리는 이미 데이터베이스 서버를 자동으로 생성하고 사용할 수 있는 빈 데이터베이스를 추가했다는 것을 기억하세요. 이제 우리는 해당 데이터베이스에 \"의미 있는 더미 데이터\"를 생성할 수 있는 스크립트를 추가할 거예요. 이것은 개발에 도움이 되며(모두가 동일한 데이터 집합으로 로컬에서 작업하지만, 또한 영속성 상태를 알 수 있기 때문에 테스트 시스템에 대해 통합 테스트 실행도 가능합니다).\n\n우리는 스크립트를 작성하는 방법을, 이미 정의된 모델을 사용하도록 하며(필요하다면 서비스 레이어 등도 사용할 수 있습니다). 제어의 역전, 클래스 생성자에서의 의존성 주입을 통해 프로젝트의 리포지토리와 서비스의 인스턴스를 생성할 수 있습니다. 이렇게 하면 NestJS API 서버를 시작하지 않고도 TypeScript 파일에서 데이터베이스 연결을 제공하여 수동으로 생성할 수 있습니다.\n\n이것은 정말 좋아요 — 이러한 유형의 시험 코드를 실행하여 코드를 시험하면서 실제 서버를 시작하기 전에 독립적으로 시드 프로세스를 실행하며, 시드 스크립트 논리가 실제 비즈니스 로직 코드로 빠져나가지 않으며 오히려 그것을 활용할 수 있습니다. 보통 제가 스크립트를 매우 일반적인 방식으로 작성해서 한 번에 한 번 실행되어도 다른 것에 의존하지 않고 랜덤 값을 무작위로 생성하여 \"시드-id\"를 넣어 작업하는 편입니다. 이렇게 하면 스크립트를 여러 차례 실행하여 계속해서 더 많은 데이터를 생성하지만 매번 실행할 때마다 뭔가 잘못 되지 않음이 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 스크립트에서 데이터베이스 연결을 설정하기 위해서는 작성한 configService를 재사용하고 ts-node 모듈을 사용하여 실행하면 됩니다.\n\n씨드 스크립트는 다음과 같이 생겼을 수 있습니다:\n\n우리는 다음처럼 실행합니다\n\n```js\nnpm run start:dev:db:seed\n# 결과\n# 완료 -\u003e seed2302-1\n# 완료 -\u003e seed2302-2\n# ...스크립트 실행 종료까지 기다립니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI를 시작한 후에는 데이터베이스에서 이 데이터를 가져옵니다.\n\n```js\ncurl localhost:3000/item | jq\n[\n {\n  \"id\": \"393a370b-762b-44fb-9830-9526a1d6a685\",\n  \"name\": \"seed8239-1\",\n  \"description\": \"created from seed\"\n },\n // ...\n]\n```\n\n마지막으로\n\n로컬에서 데이터베이스 상태를 관리하는 모든 도구를 설정하는 방법을 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 설정부터 모델, 후킹, 그리고 데이터베이스 작업까지.\n\n모든 도구는 어떤 식으로든 코드에 의존하며 UI로 가서 버튼을 클릭하여 설정하는 대신에. 이 \"코드\" 접근 방식을 통해 일을 쉽게 복제할 수 있습니다. 새 팀원을 온보딩하거나, 혹은 2년 후 프로젝트를 다시 방문하여 설정 방법을 잊어버렸다면 — 매우 쉽게 처리할 수 있을 것입니다. 시작하려면 단순히 3~4개의 명령을 실행하면 되며 명령이 어떻게 작동하는지 알기 위해서는 프로젝트 파일을 살펴보기만 하면 됩니다. 왜냐하면 모든 것이 코드로 제공되기 때문입니다.\n\n저는 이를 통해 NestJS, typeORM, 그리고 PostgreSQL 데이터베이스와 함께 작업할 때 여러분을 빠르게 출발시킬 수 있었기를 바랍니다. 여러분은 어떠신가요? 비슷하거나 더 나은 도구/접근 방식이 있으신가요? 아래 댓글에 알려주시면 감사하겠습니다!\n\n건배!","ogImage":{"url":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"},"coverImage":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png","tag":["Tech"],"readingTime":14},{"title":"2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드","description":"","date":"2024-06-23 13:57","slug":"2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024","content":"\n\n![Express.js in Action: How to Build an API with Node.js and TypeScript in 2024](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png)\n\n안녕하세요! 이 프로젝트는 여러 포스트로 이어지게 될 거에요. 새로운 파트를 올릴 때 알림을 받으려면 저를 팔로우해 주세요. Node.js와 TypeScript를 사용해 백엔드 개발을 배우고 싶으시다면, 이 시리즈를 확인해보세요. 유용하고 즐거운 정보가 될 거에요.\n\n이 프로젝트에서는 Node.js와 TypeScript를 사용하여 빠르게 API를 구축하겠습니다. Node.js와 TypeScript를 사용하여 API를 처음부터 만드는 방법에 대해 단계별 가이드를 제공할 거에요. 프로젝트에서 다음 기능들을 구현할 예정입니다:\n\n- 프로젝트 구조 설정 및 TypeScript 구성\n- 미들웨어 사용하여 요청 분석 및 응답 전송과 같은 공통 작업 처리\n- 환경 변수를 사용하여 설정 및 비밀 정보 저장\n- 동적 환경\n- 유용한 정보 기록 및 표시하기 위해 로거 사용\n- CORS 활성화 및 기본 인증을 통해 API 보호\n- 유효성 검사 및 예외 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 구조\n\n우리의 프로젝트 구조는 간단하면서도 확장 가능한 구조로, 잘 조직된 코드를 쉽게 확장하고 유지보수할 수 있게 해줍니다. 불필요한 복잡성을 피하며 모든 것을 간단하게 유지합니다.\n\n```js\n-- src\n   -- controllers\n   -- models\n   -- utils\n      -- helpers\n      -- middlewares\n      -- validations\n      -- exceptions\n   -- app.ts\n```\n\n# 프로젝트 초기화 및 TypeScript 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하려면 node 및 npm이 이미 설치되어 있어야합니다. 이 튜토리얼에서는 node v20.11.0 (npm v10.2.4)를 사용할 것입니다. 또한 IDE로 Visual Studio Code를 사용할 것입니다.\n\n- 여기서 node를 설치하세요.\n- 여기서 vscode를 설치하세요.\n- (선택 사항 - bash 터미널을 얻기 위해) 여기서 windows용 git을 설치하세요.\n\n프로젝트를 위한 새 폴더를 만들어 시작하겠습니다. 이것을 node-api-ts로 이름 지을 것입니다. vscode에서 프로젝트 폴더를 열어보세요. 파일을 '열기...'를 통해 열거나 터미널을 사용해서 프로젝트 폴더로 이동하여 다음 명령어를 사용하세요:\n\n```js\ncode .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Ctrl + `를 사용하여 vscode 통합 터미널을 엽니다. 이렇게 하면 기본 터미널이 열릴 것입니다.\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_1.png)\n\n이 튜토리얼에서는 리눅스 및 맥 시스템에서 일반적인 베이시 터미널 명령어를 사용할 것입니다. Windows 사용자는 git bash를 설치하여 유사한 환경을 얻을 수 있습니다. git bash는 베이시 터미널을 에뮬레이트하는 무료 소프트웨어입니다.\n\n# 프로젝트 초기화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 프로젝트 폴더에서 다음 명령어를 사용하여 빈 Node.js 프로젝트를 초기화해보겠습니다. 진행하시기 전에 프로젝트 디렉토리에 있는지 확인해주세요:\n\n```js\nnpm init\n```\n\n앞서 언급한 명령어는 package.json 파일을 생성하기 위해 몇 가지 질문을 통해 새로운 Node.js 패키지/프로젝트를 초기화합니다. 기본적으로 index.js를 덮어씌우기 위해 entry point를 build/app.js로 변경해야 합니다. TypeScript를 사용하기 때문에 나중에 해당 내용을 알아보겠습니다.\n\n```js\npackage name: (api-ts) node-api-ts\nversion: (1.0.0) \ndescription: API with Node.js and TypeScript\nentry point: (index.js) build/app.js\ntest command: \ngit repository: \nkeywords: node.js,express,api,typescript\nauthor: Mahmoud Kassem\nlicense: (ISC) \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더를 확인해보세요. 아마 이와 유사한 내용을 찾을 수 있을 거에요:\n\n```js\n{\n  \"name\": \"node-api-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API with Node.js and TypeScript\",\n  \"main\": \"build/app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n  },\n  \"keywords\": [\n    \"node.js\",\n    \"express\",\n    \"api\",\n    \"typescript\"\n  ],\n  \"author\": \"Mahmoud Kassem\",\n  \"license\": \"ISC\"\n}\n```\n\n# 의존성 설치\n\n무언가를 시작하기 전에 먼저 사용할 종속성(dependancies) 및 개발 종속성(devDependancies)을 나열하고 각각의 사용 목적을 설명해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성(dependencies):\n\n- express: 우리의 API를 구축하는 노드.제이에스 API 프레임워크\n- cors: 프로젝트에서 교차 출처를 활성화함\n- dotenv: .env 파일에서 환경 변수를 읽어 동적 환경을 생성함\n- helmet: 응답 헤더에서 민감한 데이터를 제거하여 API를 보호함\n- morgan: 디버깅 및 모니터링 앱 활동을 위한 로깅 미들웨어\n\n개발 의존성(devDependencies):\n\n- typescript: 코드를 빌드하여 JavaScript로 변환하는 데 사용\n- types (@types/express, @types/helmet, @types/morgan, @types/dotenv): 자바스크립트 생태계의 일부 패키지는 자체 유형 정의를 제공하지 않아 TypeScript 개발자가 사용하기 어렵게 만들 수 있습니다. 다행히 이러한 패키지를 위한 유형 정의를 제공하는 @types 선언 패키지가 있습니다. 예를 들어, @types/express, @types/helmet, @types/morgan 및 @types/dotenv는 각각 express, helmet, morgan 및 dotenv에 대한 유형 정의를 제공하는 선언 패키지입니다. 이러한 선언 패키지를 devDependencies로 설치하고 TypeScript 코드에서 가져와서 해당 패키지에 대한 유형 검사와 코드 완성을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 종속성을 먼저 설치하세요 — 여러 개의 패키지를 설치할 때는 각 패키지 이름 사이에 공백을 사용하면 됩니다:\n\n```js\nnpm install express cors dotenv helmet morgan\n```\n\n그런 다음 다음 명령어를 사용하여 개발용 종속성을 설치하세요:\n\n```js\nnpm install --save-dev typescript @types/express @types/cors @types/dotenv @types/helmet @types/morgan\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json 파일을 확인했다면, 설치된 패키지와 그 버전이 업데이트되었음을 알 수 있습니다. 또한 프로젝트에 node_modules와 package-lock.json이 추가된 것을 발견하게 될 거에요.\n\nnode_modules 폴더 안에는 설치된 의존성이 포함되어 있습니다. 그리고 그 의존성의 종속 항목을 찾아볼 수 있습니다. 이 파일들은 우리가 만들고 있는 것과 유사한 노드 패키지입니다.\n\npackage-lock.json은 노드 패키지 매니저(npm)에 의해 자동으로 생성됩니다. 이 파일은 모든 의존성 및 이에 대한 트리의 정확한 버전을 저장합니다. 프로젝트에서 어떤 종속성을 설치하거나 업데이트할 경우 업데이트될 거에요.\n\n## TypeScript 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js는 JavaScript의 런타임으로, 개발자들이 확장 가능하고 효율적인 웹 애플리케이션을 만들 수 있게 합니다. TypeScript는 JavaScript의 슈퍼셋으로, 정적 유형 지정, 객체 지향 프로그래밍, 데코레이터 등의 기능을 추가합니다. 그러나 TypeScript 코드는 Node.js에서 직접 실행되지 않고 먼저 JavaScript로 컴파일해야 합니다.\n\n우리 프로젝트에서 TypeScript를 지원하려면, 먼저 그것을 구성해야 합니다. 아래 명령을 사용하여 구성 파일을 초기화하십시오. 나중에 이 파일을 수정하여 일부 기본값을 변경할 것입니다:\n\n```js\nnpx tsc --init\n```\n\n이전 명령은 다음 내용을 출력할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n다음은 TypeScript의 기본 구성이지만 변경할 수 있습니다. tsconfig.json이라는 새 파일이 생성된 것을 알 수 있을 거에요.\n\n이전에 설정한 프로젝트 폴더 구조에 맞추기 위해 일부 기본값을 수정할 거에요.\n\nrootDir 주석 처리를 해제하고 값을 ./src로 변경해주세요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n...\n\"rootDir\": \"./src\",\n...\n}\n```\n\n이 명령은 프로젝트의 루트 디렉토리를 설정합니다. 이는 TypeScript가 이 폴더 내에만 .ts 파일을 찾도록 하는 것을 의미합니다.\n\noutDir를 주석 처리해제하고 값으로 ./build를 변경하세요.\n\n```js\n{\n...\n\"outDir\": \"./build\",\n...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 transpiled TypeScript의 기본 출력 디렉터리를 변경합니다.\n\n— 이전 파트는 프로젝트 폴더 이름에 따라 변경할 수 있습니다. src를 app, source 또는 다른 이름으로 변경할 수 있지만, 그러면 rootDir을 선택한 폴더 이름과 일치하도록 변경해야 하며 outDir도 동일합니다.\n\n# Express 서버\n\n이제 코드를 작성해 보겠습니다. 전체 프로젝트의 첫 번째 파일 및 주 파일을 만들어 보겠습니다. npm을 사용하여 노드 프로젝트를 초기화하고 일치하는 엔트리 포인트를 build/app.js로 선택했던 것을 기억하십니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.ts 파일을 생성하여 이 파일로 컴파일될 것입니다. 그래서 먼저 해야 할 일은 소스 폴더를 생성하는 것입니다. src 폴더를 루트 디렉토리로 설정한 다음, ./src/app.ts 라는 새 파일을 만들어야 합니다. 그 안에 다음과 같은 코드를 작성해 봅시다.\n\n```js\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport morgan from 'morgan';\n\n// Express 서버 생성\nconst app = express(); // 새 express 인스턴스\nconst port = 3000; // 포트 번호\n\n// Express 설정\napp.use(cors()); // CORS 활성화\napp.use(helmet()); // Helmet 활성화\napp.use(morgan('dev')); // Morgan 활성화\n\n// Express 서버 시작\napp.listen(port, () =\u003e {\n  // 서버가 성공적으로 시작되면 콜백 함수 실행\n  console.log(`서버가 http://localhost:${port} 에서 시작되었습니다.`);\n});\n\n// Express 앱 내보내기\nexport default app;\n```\n\n이전 코드에서는 express 서버 인스턴스를 생성하고 몇 가지 (선택적) 미들웨어로 구성했습니다. 이를 통해 보안, 모니터링 및 디버깅을 개선할 수 있습니다.\n\n이제 다음 명령어를 실행하여 응용 프로그램을 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx tsc \u0026\u0026 node .\n```\n\n이제 터미널에서 다음 줄로 끝나는 출력을 확인해야합니다:\n\n```js\n서버가 http://localhost:3000에서 시작되었습니다\n```\n\n이것은 서버가 성공적으로 시작되었음을 보여주는 콜백 함수의 텍스트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 첫 번째 라우트 생성하기\n\n이제 우리는 애플리케이션을 구성하고 시작했지만 아직 기능이 없습니다. API를 구축해야 하므로 몇 가지 라우트를 생성해야 합니다.\n\n아래 코드는 express의 get() 메서드를 사용하여 경로 / 에 대한 리스너를 만들고 간단한 Hello World! 문자열을 반환합니다.\n\nStart Express Server 코드 블록 앞에 다음 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Express 라우트 정의\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World!');\n});\n```\n\n이제 터미널로 이동해서 현재 프로세스를 Ctrl + C로 중지한 후 npx tsc \u0026\u0026 node . 명령어를 입력하여 다시 빌드하고 서버를 시작합니다.\n\n이제 새로 만든 라우트를 테스트해보겠습니다. GET 요청을 테스트하기 때문에 http://localhost:3000을 열어보면 다음 출력이 표시됩니다:\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 하셨습니다! 첫 번째 라우트를 만드셨네요.\n\n이 튜토리얼에서 사용된 소스 코드가 포함된 레포지토리입니다. 새 커밋이 있는 경우마다 업데이트될 예정이에요. mahkassem/node-api-ts\n\n2부를 보려면 (여기를 클릭해주세요)","ogImage":{"url":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"},"coverImage":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png","tag":["Tech"],"readingTime":8},{"title":"TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법","description":"","date":"2024-06-23 13:56","slug":"2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow","content":"\n\n\n![Functional Programming in TypeScript](/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png)\n\n함수형 프로그래밍 (FP)은 코드 품질, 유지 보수성, 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 조작이 높은 복잡한 도메인에서는 더 그렇습니다. TypeScript의 경우, 강력한 유형 시스템을 통해 고급 FP 기술을 처리할 수 있어 데이터의 모델링과 처리를 정확하고 효율적으로 수행할 수 있습니다. 금융 응용 프로그램을 예로 들어 주요 FP 개념을 살펴보겠습니다.\n\n# 주요 함수형 프로그래밍 원칙\n\n- 순수 함수: 동일한 입력에 대해 동일한 출력을 생성하며 부작용이 없는 함수입니다. 순수 함수는 동일한 입력을 사용하면 일관성있게 동일한 출력을 반환하며 범위 외부의 상태를 변경하지 않고 가변 상태에 의존하지 않습니다. 이러한 예측 가능성으로 순수 함수는 테스트 가능하고 신뢰할 수 있으며 프로그램 동작에 대한 추론을 용이하게 하고 디버깅을 단순화합니다.\n- 불변성: 데이터 구조를 변경하지 않고 새로운 구조를 생성해야 합니다. 데이터 구조의 불변성은 한 번 생성된 데이터 구조를 변경할 수 없음을 보장합니다. 기존 구조를 수정하는 대신 새 구조를 만듭니다. 불변성은 상태 관련 문제를 피하면서 동시성을 향상시킵니다.\n- 일급 및 고차 함수: 함수를 인수로 전달하거나 다른 함수로부터 반환하고 변수에 할당할 수 있습니다. 이 기능은 모듈화와 코드 재사용을 도와주며 더 추상적이고 유연한 코드를 만들 수 있습니다. 고차 함수를 사용하여 개발자는 표현적인 방식으로 복잡한 작업을 수행하여 더 깨끗하고 유지보수가 쉬운 코드베이스를 만들 수 있습니다.\n- 함수 합성: 더 간단한 함수들을 결합하여 복잡한 함수를 구축합니다. 이 기술을 사용하면 기본 작업을 연결하여 복잡한 기능을 만들 수 있으며 고수준의 추상화를 유지할 수 있습니다. 함수 합성은 코드 재사용과 명확성을 촉진하며 각 함수를 단독으로 테스트하고 이해하고부터 큰 워크플로에 통합되기 전까지 더 자세히 이해할 수 있습니다.\n- 선언적 코드: 제어 흐름을 명시적으로 설명하지 않고 로직을 표현합니다. 선언적 코드는 계산 논리를 세세하게 설명하지 않고 제어 흐름을 자세히 설명하지 않습니다. 명령형 프로그래밍과 달리 목표를 달성하기 위한 명시적 단계를 지정하는 대신 선언적 프로그래밍은 프로그램이 달성해야 하는 것을 기술합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함수형 프로그래밍을 위한 TypeScript 기능들\n\n- 정적 타입 및 타입 추론: 컴파일 시에 정확성을 보장하고 오류를 감지합니다.\n- 제너릭: 유연하고 재사용 가능한 데이터 구조와 함수를 생성할 수 있습니다.\n- 합집합 및 교집합 타입: 정확한 타입 정의를 가능하게 하며 복잡한 데이터를 조합할 수 있습니다.\n- 맵핑 타입 및 조건부 타입: 데이터 변환 및 타입 조작에 강력한 도구를 제공합니다.\n\n# 모델링에서의 대수형 데이터 타입 (ADTs)\n\nADTs는 복잡한 데이터 구조를 효과적으로 표현하며 각각의 독특한 특성과 행위를 포착할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype Currency = 'EUR' | 'USD';\n\ninterface Cash {\n    type: 'cash';\n    amount: number;\n    currency: Currency;\n}\n\ninterface Stock {\n    type: 'stock';\n    ticker: string;\n    quantity: number;\n}\n\ninterface Credit {\n    type: 'credit';\n    isin: string;\n    maturity: Date;\n    faceValue: number;\n    interestRate: number;\n}\n\ntype Element = Cash | Stock | Bond;\n\nconst calculateValue = (instrument: Element, exchangeRates: Record\u003cCurrency, number\u003e): number =\u003e {\n    switch (instrument.type) {\n        case 'cash':\n            return instrument.amount * exchangeRates[instrument.currency];\n        case 'stock':\n            // Some complex value calcuation\n            return instrument.quantity * 100;\n        case 'credit':\n            // Some complex value calcuation\n            return instrument.faceValue * (1 + instrument.interestRate / 100);\n        default:\n            throw new Error('Unknown financial instrument');\n    }\n};\n```\n\n## 재미있는터와 모나드를 활용한 금융 계산\n\n재미있는터와 모나드(부작용 핸들러)는 금융 데이터를 처리하고 선택적 값, 오류 및 비동기 작업을 다루는 계산을 관리합니다.\n\n```js\ntype Option\u003cT\u003e = None | Some\u003cT\u003e;\n\nclass None {\n    readonly tag = 'None';\n}\n\nclass Some\u003cT\u003e {\n    readonly tag = 'Some';\n    constructor(public value: T) {}\n}\n\nconst none = new None();\nconst some = \u003cT\u003e(value: T): Option\u003cT\u003e =\u003e new Some(value);\n\nconst mapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e U): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? some(fn(opt.value)) : none;\n\nconst flatMapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e Option\u003cU\u003e): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? fn(opt.value) : none;\n\nconst calculateInterest = (amount: number, rate: number): Option\u003cnumber\u003e =\u003e\n    rate \u003e= 0 ? some(amount * rate) : none;\n\nconst result = flatMapOption(some(1000), amount =\u003e calculateInterest(amount, 0.05));\nconsole.log(result); \n// Should be....\n// Some { tag: 'Some', value: 50 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 금융 데이터 조작을 위한 렌즈\n\n렌즈는 데이터 구조의 일부에 초점을 맞추어 조작 가능한 데이터를 제공합니다.\n\n```js\ntype Lens\u003cS, A\u003e = {\n    get: (s: S) =\u003e A;\n    set: (a: A, s: S) =\u003e S;\n};\n\nconst lens = \u003cS, A\u003e(getter: (s: S) =\u003e A, setter: (a: A, s: S) =\u003e S): Lens\u003cS, A\u003e =\u003e ({\n    get: getter,\n    set: setter,\n});\n\ntype Portfolio = {\n    owner: string;\n    instruments: FinancialInstrument[];\n};\n\nconst instrumentsLens = lens(\n    (p: Portfolio) =\u003e p.instruments,\n    (instruments, p) =\u003e ({ ...p, instruments })\n);\n\nconst addInstrument = (portfolio: Portfolio, instrument: FinancialInstrument): Portfolio =\u003e {\n    const instruments = instrumentsLens.get(portfolio);\n    return instrumentsLens.set([...instruments, instrument], portfolio);\n};\n\nconst myPortfolio: Portfolio = { owner: 'Rass', instruments: [] };\nconst updatedPortfolio = addInstrument(myPortfolio, { kind: 'cash', amount: 1000, currency: 'USD' });\nconsole.log(updatedPortfolio); \n// 예상 출력 결과...\n// 현금 계기가 추가된 포트폴리오\n```\n\n# 실용적 예시: 금융 데이터 처리 파이프라인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 금융 데이터를 가져 와서 처리하고 리스크 분석을 수행해야 하는 작업을 고려해 보세요.\n\n## 금융 데이터 가져오기\n\n```js\nconst fetchStockPrices = async (): Promise\u003cOption\u003cRecord\u003cstring, number\u003e\u003e\u003e =\u003e {\n    return some({ 'AAAA': 150, 'BBBB': 2800 });\n};\n\nconst fetchExchangeRates = async (): Promise\u003cOption\u003cRecord\u003cCurrency, number\u003e\u003e\u003e =\u003e {\n    return some({ 'EUR': 1.2, 'USD': 1 });\n};\n```\n\n## 데이터 처리와 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 데이터를 결합합니다.\n\n```js\nconst processFinancialData = async (): Promise\u003cOption\u003c{ stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }\u003e\u003e =\u003e {\n    const stockPrices = await fetchStockPrices();\n    const exchangeRates = await fetchExchangeRates();\n\n    return flatMapOption(stockPrices, stocks =\u003e\n        mapOption(exchangeRates, rates =\u003e ({ stocks, rates }))\n    );\n};\n\nprocessFinancialData().then(data =\u003e console.log(data));\n```\n\n## 위험 분석\n\n결합된 데이터에 대한 위험 분석을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst analyzeRisk = (data: { stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }): string =\u003e {\n    const totalValue = Object.values(data.stocks).reduce((acc, price) =\u003e acc + price, 0);\n    return totalValue \u003e 5000 ? 'High Risk' : 'Low Risk';\n};\n\nconst performRiskAnalysis = async () =\u003e {\n    const data = await processFinancialData();\n    const riskLevel = mapOption(data, analyzeRisk);\n    // The riskLevel variable here is an option holding the result.\n    console.log(riskLevel);\n};\n\nperformRiskAnalysis();\n```\n\n함수형 프로그래밍 개념인 ADT, 펑터, 모나드, 렌즈와 같은 것들을 사용하여 가독성이 좋고 확장 가능한 금융 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"},"coverImage":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png","tag":["Tech"],"readingTime":7},{"title":"ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드","description":"","date":"2024-06-23 13:55","slug":"2024-06-23-UsingESLintHuskyLint-staged","content":"\n\n저는 새로운 회사에 프론트엔드 개발자로 합류했어요!\n\n하지만 여기서 또 다시 시작되는군요 — 완벽한 코드 스타일을 위한 영원한 탐험이라니...\n\n제 개인적인 생각으로는 이 방대한 코딩 우주에서 '나쁜 코드'란 존재하지 않는다고 확신하고 있어요. 각자가 고유한 스타일을 갖고 있으니까 말이에요.\n\n그렇지만 5명 이상이 참여하는 프로젝트에서 각자 다른 스타일로 코딩한 걸 보면, 특히 네이밍 규약과 함수 이름 (사실 패턴까지도)에 다양한 스타일이 있음을 알게 되었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 회사에 새로 합류한 입장에서는 코드를 이해하는 데 시간이 걸렸는데, 이러한 시간을 최소화하기 위해 이름 규칙을 적어도 일관되게 적용할 방법에 대해 생각하기 시작했습니다.\n\n![이미지](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png)\n\n물론, 우리는 일반적으로 알려진 ESLint와 Prettier를 사용하고 있었습니다. 그러나 체크를 실행하지 않고 푸시하는 등 실수가 발생한 경우가 있었습니다.\n\n사실, 이는 이 두 도구의 사용을 무효화시키는 결과를 초래합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에는 VSCode와 같은 IDE가 팝업 알림을 제공하지만, 커밋하기 전에 추가적인 확인을 하는 것도 나쁘지 않은 생각이에요. \n\n그래서, 커밋 전에 코드 스타일을 확인하는 라이브러리 husky를 사용해보자는 아이디어를 생각해냈어요. 이렇게 하면 더 편리할 거에요.\n\n추가적인 단계로, ESLint를 사용자 정의하여 내 규칙이나 회사별 규칙을 설정해볼 생각이에요!\n\n먼저, 대부분의 분들이 이미 알고 있을 것 같지만, ESLint와 Prettier가 무엇인지 간단히 설명드리겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ESLint: 코드의 수호천사 👼\n\nESLint를 만나보세요 — 당신의 신뢰할 수 있는 리터입니다. 그것은 하루를 구해주는 친구와 같아요!\n코드를 위한 문법 검사기를 가지고 있는 것 같아요.\nESLint는 교묘한 구문 오류를 잡는 것뿐만 아니라 일관된 코드 스타일을 위해 매치메이커 역할을 하며, 당신의 코드가 최상급인지 확인합니다. 🌟\n\n## Prettier: 코드 스타일리스트 ✨\n\n코드베이스를 위한 패션 관리자가 있는 것 같아요.\nPrettier는 코드를 새롭게 꾸며주는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 두 가지 도구는 때때로 구성 사항 간의 충돌로 이어져있는 코드 스타일과 관련된 측면을 다룹니다. 이러한 충돌을 처리하는 것이 중요합니다.\n\n자, 이 글의 주요 내용인 Husky에 대해 살펴봅시다.\n\n## Husky\n\n이전에 논의한 바와 같이 Husky는 git commit이나 git push와 같은 중요한 Git 이벤트가 발생하기 전에 지정된 스크립트를 실행하는 데 도움이 되는 다재다능한 라이브러리입니다. 이 고급 도구는 사실상 지휘자 역할을 하여 Git 내에서의 작업 흐름을 안내하고 개발자가 개발 과정을 보다 세밀하게 통제할 수 있도록 돕습니다. Husky는 Git 이벤트 사이에 전략적으로 배치된 후크를 구현하여 작동하며 작업 흐름을 섬세하게 조정할 수 있게 합니다. 이런 제어된 이벤트 저지 기법 패러다임은 보통 git 후크 관리로 불립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## lint-staged\n\n깃에서 스테이징의 개념은 lint-staged의 가치를 이해하는 데 기초를 제공합니다. 코드 린트 활동을 수행할 때 개발자들은 종종 검사할 파일을 수동으로 지정해야 하는 선택을 직면할 수 있습니다. - 이는 잠재적으로 고통스러운 노력일 수 있습니다 - 또는 전체 프로젝트 저장소를 검토에 노출시킬 수 있습니다.\n그러나 프로젝트가 규모가 커질수록 복잡성도 증가합니다.\n이러한 맥락에서, 감독은 점점 걱정거리가 되며, 린트 과정 중 실수로 빠뜨린 파일이 상당히 많이 발생할 수 있습니다.\nlint-staged는 코드 품질 보증 분야에서 세련되고 전략적인 협업자입니다. 깃 add를 사용하여 스테이징 상태로 전환된 파일만 엄밀히 검사함으로써, lint-staged는 감독을 방지하고 린팅 정밀도와 효율성을 향상시키는 아주 우아한 해결책을 제공합니다.\n\n실용적인 사용법을 알아보겠습니다!\n\n## husky \u0026 lint-staged 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHusky 및 lint-staged을 설치하세요\n\n```js\nnpx mrm lint-staged\n```\n\n위 명령어를 실행하면 .husky라는 이름의 폴더가 생성되고 package.json 파일에 코드가 추가됩니다.\n\n```js\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  ...\n  \"lint-staged\": {\n    \"*.js\": \"eslint --cache --fix\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## husky 설정하기\n\nmrm은 다운로드 시 기본 구성을 제공하기 때문에 별도로 구성할 것이 별로 없습니다. 그러나 재미를 위해 몇 가지 사용자 정의 문구를 셸 스크립트에 추가했습니다. (?)\n\n## lint-staged 설정하기\n\nlint-staged의 구성은 사용 중인 프로그래밍 언어에 따라 다를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나의 경우에는 TypeScript를 사용하고 있기 때문에 별도로 설정해주어야 했습니다.\n\n```js\n\"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --max-warnings 0 .\"\n    ]\n}\n```\n\n처음에는 경고를 완전히 무시하고 싶지 않았기 때문에 --max-warnings 0을 포함시켰습니다.\n\n당신의 상황에 따라 제거하는 것도 고려해볼 수 있어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 실행하면 아래와 같이 Husky가 원활하게 작동하는 것을 확인할 수 있습니다.\n\n```bash\ngit commit -m 'husky work'\n```\n\n# 💀\n\n\u003cimg src=\"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 😎\n\n![Image](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_2.png)","ogImage":{"url":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"},"coverImage":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png","tag":["Tech"],"readingTime":4},{"title":"OpenAI 기능 호출로 훈련 데이터 생성하는 방법","description":"","date":"2024-06-23 13:54","slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"/\u003e\n\n머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\n\n(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"/\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 이 기능을 사용해야 하나요?\n\nOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\n\n# 나의 동기\n\n최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OpenAI를 사용하여 데이터 라벨링하기\n\n먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\n\nOpenAI에 적절한 컨텍스트 제공하기:\n\n- 명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\n- 프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 `blog post content...` 라벨을 추가하세요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\n\n- 도구에 대한 자세한 설명을 제공해주세요.\n- 응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\n\n스키마에 의해 정의된 함수를 작성해주세요:\n\n- 이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\n\n# 간단한 코드 예제 살펴보기\n\n여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\n\n이 예제에서는 어떤 텍스트에 [`긍정적`, `부정적`, `중립적`] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {ITool, ToolSchema} from './interfaces/tool.interface';\nimport {ToolUtils} from \"../utils/tool-utils\";\nimport * as path from 'path';\nimport {createObjectCsvWriter as createCsvWriter} from 'csv-writer';\n\nexport class LabelTool implements ITool\u003cstring[], { inputText: string }\u003e {\n    private csvWriter;\n\n    constructor(private readonly labels: string[] = ['positive', 'negative', 'neutral'], private readonly csvFilePath: string = path.join('labeled_text.csv')) {\n        this.csvWriter = createCsvWriter({\n            path: this.csvFilePath,\n            header: [\n                {id: 'label', title: 'Label'},\n                {id: 'text', title: 'Text'},\n            ],\n            append: true\n        });\n    }\n\n    // 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n    async callback(\n        options: { label: string },\n        ctx: { inputText: string },\n    ): Promise\u003cany\u003e {\n\n        // 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\n        await this.csvWriter.writeRecords([{\n            label: options.label,\n            text: ctx.inputText\n        }]);\n\n        console.log(`CSV 행 추가됨: ${options.label} | ${ctx.inputText}`);\n\n        return `레이블이 성공적으로 추가되었습니다: ${options.label}`;\n    }\n\n    // JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\n    async getSchema(ctx: { inputText: string }): Promise\u003cToolSchema\u003e {\n\n        // 이는 LLM을 위한 제공된 스키마입니다.\n        return {\n            type: 'function',\n            function: {\n                name: 'set_label',\n                description: '텍스트에 레이블 설정',\n                function: ToolUtils.getToolFn(this, ctx),\n                parse: JSON.parse,\n                parameters: {\n                    type: 'object',\n                    properties: { // 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\n                        label: {\n                            type: 'string',\n                            description: '입력 텍스트의 레이블',\n                            enum: this.labels // 가능한 문자열을 제한합니다\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n```\n\n이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n```js\nimport OpenAI from \"openai\";\nimport {LabelTool} from \"./tools/label.tool\";\nrequire('dotenv').config()\n\nconst client = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\n(async () =\u003e {\n    const inputTexts = [ // OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\n        \"이 제품을 사랑해요!\",\n        \"이게 내가 산 것 중에 가장 최악이에요.\",\n        \"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\",\n        \"돈 안 아깝다고.\",\n        \"최고의 구매!\",\n    ];\n\n    for (const inputText of inputTexts) {\n        console.debug(`프롬프트: 이 텍스트에 레이블을 부여하세요: ${inputText}`);\n\n        const tool = new LabelTool(['positive', 'negative', 'neutral']);\n        const context = { inputText: inputText };\n        const prompt = `이 텍스트에 레이블을 부여하세요: ${inputText}`;\n        const system = '훈련 데이터 생성을 돕는 유용한 도우미입니다.';\n\n        const runner = client.beta.chat.completions.runTools({\n            model: 'gpt-3.5-turbo',\n            messages: [\n                {\n                    role: 'system',\n                    content: system,\n                },\n                {\n                    role: 'user',\n                    content: prompt,\n                },\n            ],\n            tools: [await tool.getSchema(context)],\n            tool_choice: 'auto', // 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\n        });\n\n        const finalContent = await runner.finalContent();\n        console.log(`AI 응답: ${finalContent}\n        `);\n    }\n})();\n```\n\n로그 결과:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\r\n\n\r\nCSV 파일:\r\n\r\n\n라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\r\n\n\r\n물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: https://github.com/MaurerKrisztian/training_data_genration_with_openai\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\n\n이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"},"coverImage":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png","tag":["Tech"],"readingTime":7},{"title":"Angular에서 첫 번째 라이브러리 만드는 단계별 가이드","description":"","date":"2024-06-23 13:52","slug":"2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png\" /\u003e\n\n안녕하세요! 라이브러리 프로젝트를 진행 중이었고, 각본을 만들 때는 앵귤러 라이브러리를 단계별로 만드는 방법을 어딘가에 기록하지 않았다는 것을 깨닫게 되었습니다. 이것은 나중에 참고할 수 있도록 그리고 여러분을 위해도 올린 것입니다. 그러니 시작해 보겠습니다!\n\n이 블로그 글을 시작하기 전에, 앵귤러 라이브러리 코딩랩에 대해 말씀드리고 싶습니다. 나는 Angular를 사용하여 라이브러리를 만드는 동안 마주치는 모든 가능한 오류들을 설명하고 있는 코딩랩을 준비 중입니다. 이 코딩랩은 CLI를 사용하여 라이브러리를 만드는 방법을 단계별로 안내하는 내용이 될 것입니다. 이 코딩랩은 자세한 레시피가 되어서, 여러분은 그대로 따라 하여 라이브러리를 만들 수 있습니다.\n\n이 블로그 글에서는 라이브러리의 개요, 라이브러리 생성, 앵귤러 애플리케이션에서 로컬로 사용하는 방법, npm에 발행하는 방법에 대해 이야기하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리 만들기: [여기](https://github.com/NishuGoel/ngSLDemo)\n\n라이브러리 사용하기: [여기](https://github.com/NishuGoel/consuming-angular-lib)\n\n# 개요\n\n우선, 프로그래밍에서 라이브러리란 일반적으로 무엇을 의미하는지 이해해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사전 컴파일된 루틴 - 이것은 반복적으로 수행할 작업의 컴파일된, 확립된, 즉시 사용 가능한 버전임을 시사합니다.\n프로그램이 사용할 수 있다 - 이는 이 재사용성이 라이브러리가 생성된 프로젝트가 아니더라도 여러 다른 프로젝트에서 활용될 수 있다는 것을 시사합니다.\n\n이 모든 것을 종합하면, 라이브러리는 주로 여러 프로젝트에서 사용할만한 기능 세트이며 해당 기능의 컴파일된 버전이 번들로 제공되어 필요한 프로젝트에 제공됩니다. 따라서 라이브러리의 기능은 다음과 같습니다.\n\n- 쉽게 공유할 수 있는 코드\n- 반복해서 사용할 수 있는 기능\n- 하나의 기능을 위해 별도로 지정된 코드\n\nAngular 라이브러리에는 기능을 정의하기 위한 컴포넌트, 모듈, 서비스가 포함되어 있습니다. 우리 앱에서 이미 많은 라이브러리를 사용하고 있습니다. 예를 들어 카운트 다운 타이머나 스크롤 바와 같은 기능을 위해서 사용됩니다. 자주 사용되는 기능이 있다면 왜 그것을 라이브러리로 내보내어 활용하지 않을까요? 많은 Angular/Javascript 라이브러리에 연결된 Angular 애플리케이션으로 생각해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 어떤 라이브러리가 Angular 라이브러리로서 자격을 갖추려면 무엇이 있어야 할까요?\n\n- 먼저 플랫폼 독립적이어야 합니다.\n- 번들화되고 배포돼야 합니다.\n- AOT 컴파일레이션 준비가 되어 있어야 합니다.\n- TypeScript로 작성돼야 합니다.\n\n이제 모든 사람이 소비하기 쉽도록 표준화되고 있는 라이브러리를 만들기 위해서는 패키지를 어떻게 배포해야 하는지에 대한 표준이나 권장 방법이 있어야 합니다.\n\nAngular 패키지 포맷은 우리의 Angular 패키지를 배포하는 추천 방법입니다. 이는 다음에 중점을 두고 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모듈 정의\n- 타이핑 파일\n- 진입점\n- AOT 준비 메타데이터 파일\n\nAPF를 여기에서 읽으세요.\n\n# 라이브러리 만들기\n\n주로 라이브러리를 만드는 데 필요한 중요한 단계는 모든 템플릿을 인라인하고 ngc로 컴파일하여 빌드 형식을 생성하는 것입니다. 그러나 이는 많은 수동 작업이 필요하고 ng-packagr이 이를 해결하기에 충분합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng-packagr을 사용하여 라이브러리를 생성하는 방법에 대해 작성했어요.\n\nDavid Herges가 만든 ng-packagr은 단일 명령어를 사용하여 라이브러리를 빌드하고 패키징할 수 있게 해줍니다. 그러나 Angular 6 이후에는 CLI 내에 통합되어 있어, ng-packagr을 사용하여 Angular 라이브러리를 생성하는 데 ng generate 명령어를 사용할 수 있습니다.\n\nng-packagr이 우리를 위해 처리해주는 것들은 무엇이 있을까요?\n\n- Angular 패키지 형식으로 라이브러리 생성\n- 모든 번들 생성 (es52015, esm5, umd)\n- 형식 정의 파일(.d.ts) 생성\n- aot 메타데이터 파일 생성\n- 모든 스타일과 템플릿을 인라인으로 처리합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 라이브러리를 위한 작업 공간을 만들어보겠습니다!\n\n다음 명령어를 사용하여 새로운 애플리케이션을 생성하되 애플리케이션을 만들지 않도록 설정하세요.\n\n```bash\nng new `application-name` --create-application=false\n```\n\n이렇게 하면 애플리케이션을 만들지 않고 작업 공간만 생성됩니다. 이후 해당 작업 공간 내에서 라이브러리를 생성할 수 있습니다. 아래 이미지를 참고하세요.\n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng generate library `library-name`\n\n이 명령은 lib 폴더가 포함된 projects 폴더를 생성합니다. 여기서 라이브러리에 추가할 기능을 작성할 수 있어요! \n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_2.png)\n\n라이브러리 작성을 마쳤나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리 구축 시간입니다!\n\n루트 package.json에 빌드 라이브러리 스크립트를 추가하세요:\n\n```json\n\"build-library\": \"ng build nishu-library”\n```\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 라이브러리를 위한 dist 폴더가 생성됩니다.\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_4.png)\n\n프로젝트가 조금 어려워지기 시작하는 지점입니다. 왜냐하면 이제 전체 프로젝트에는 3개의 package.json 파일이 모두 포함되어 있다는 것을 알아차릴 것입니다. 루트 package.json에는 라이브러리 빌드 스크립트가 작성되어 있고, 라이브러리 package.json에는 라이브러리의 이름, 버전과 같은 정보가 제공됩니다. 이것은 라이브러리를 npm에 배포할 때 사용됩니다. 라이브러리를 패키징할 때에 대해 이야기를 나눌 것입니다.\n세 번째 package.json은 방금 생성한 라이브러리의 배포 폴더에 있습니다. 이 폴더에는 내보낼 최종 코드가 포함되어 있습니다.\n\n# 라이브러리 패키징\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 라이브러리를 패키징하려면 라이브러리 배포 디렉토리로 이동하여 npm pack 명령을 실행하면 됩니다.\n\n여기서 라이브러리 디렉토리를 패킹하는 혼란을 피합니다. 라이브러리의 빌드된 배포 폴더를 패킹해야 합니다. 이를 수동으로 하는 대신에 스크립트도 추가할 수 있습니다.\n\n\"pack-lib\": \"cd dist/nishu-library \u0026\u0026 npm pack\"\n\n이렇게 하면 라이브러리용 .tgz 패키지가 생성되고, 이를 내보낼 것입니다. 다른 애플리케이션에서 사용될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_5.png\" /\u003e\n\n우리의 패키지가 준비되었으니, 다른 애플리케이션 내에서 사용하여 테스트할 수 있습니다.\n\n새로운 Angular 애플리케이션을 생성하고 다음을 사용하여 라이브러리를 설치하세요:\n\nnpm install `path-to-tgz-file`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json을 확인해 보세요. 종속성에 설치되었는지 확인하세요.\n\n다음과 같이 파일이 추가된 것을 확인할 수 있을 겁니다:\n\n![image](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_6.png)\n\n다음 단계로, 라이브러리의 모듈을 가져와 컴포넌트를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n' NishuLibraryModule'를 `nishu-library`에서 가져와주세요.\n\n이렇게 하면 프로젝트에서 이 모듈 내에서 선언된 컴포넌트에 액세스할 수 있게 됩니다. 이제 템플릿에서 이 컴포넌트를 직접 사용하여 작동 방식을 확인할 수 있습니다!\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_7.png\" /\u003e\n\n템플릿에서는,\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csection class=\"body-section\"\u003e\n    \u003clib-nishu-library\u003e\u003c/lib-nishu-library\u003e\n\u003c/section\u003e\n```\n\n여기 있어요!\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_8.png\" /\u003e\n\n# 마지막으로 우리 라이브러리를 게시해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리를 게시하려면 npm 패키지에 대한 네이밍 규칙을 따르고 고유하게 유지해야 합니다. npm에는 많은 라이브러리가 있으므로, 라이브러리를 @`your-username`/`library-name`과 같이 명명하는 것이 쉬운 방법입니다.\n\n다음 단계는 package.json 내부에 라이브러리의 이름과 버전을 지정하는 것입니다.\n\n```js\n{\n  \"name\": \"nishu-library\",\n  \"version\": \"1.0.0\",\n  \"peerDependencies\": {\n        \"@angular/common\": \"~9.0.0\",\n        \"@angular/core\": \"~9.0.0\",\n  }\n}\n```\n\npeerDependencies는 소비 프로젝트에 해당 패키지 버전과 잘 호환됨을 알리는 방법입니다. 라이브러리의 버전을 주요 버전, 부 버전, 패치 버전 구체적으로 따르기 위해 시맨틱 버전팅을 사용하세요. SemVer에 대해 자세히 알아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json에는 작성자, 라이선스 등 라이브러리에 대한 더 많은 정보를 추가할 수 있습니다.\n\n라이브러리를 빌드하고 dist 폴더에 업데이트된 패키지.json을 찾으세요. pack-lib 스크립트를 사용하여 새 번들을 패키징하세요.\n\n모두 준비되었나요? 이제 npm에 로그인합시다. 명령줄 또는 GUI에서 둘 다 가능합니다.\n\nnpm login을 사용하여 npm에 로그인하고 npm whoami로 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계별로 첫 번째 Angular 라이브러리를 만드는 방법에 대한 안내서.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n짠, 이제 누구나 아래와 같이 Angular 프로젝트에서 이 공개 라이브러리를 사용할 수 있어요:\n\n```bash\nnpm i nishu-library\n```\n\n읽어 주셔서 감사합니다! 피드백/질문은 트위터/링크드인을 통해 연락해 주세요. 🚀","ogImage":{"url":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png","tag":["Tech"],"readingTime":7},{"title":"모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까","description":"","date":"2024-06-23 13:51","slug":"2024-06-23-MonorepoorNotMonorepo","content":"\n\n소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.\n\n과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.\n\n# 모노 레포란 무엇인가요?\n\n모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Monorepos의 장점\n\n1. 통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.\n2. 단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.\n3. 일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.\n4. 더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.\n\n# Monorepos의 도전과제\n\n1. 확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.\n2. 복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.\n3. 접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예제: TurboRepo를 이용한 단일저장소 설정\n\nTurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:\n\n1. 설치:\n\n```js\nnpx create-turbo@latest\ncd my-turbo-repo\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 애플리케이션과 패키지 추가하기:\n\n```js\n npx turbo run create next-app apps/myapp\n npx turbo run create react-lib packages/mylib\n```\n\n3. 프로젝트 간 코드 공유하기:\n\n```js\n// packages/mylib/src/index.ts\nexport function greet(name: string) {\nreturn `Hello, ${name}!`;\n }\n\n// apps/myapp/pages/index.tsx\nimport { greet } from 'mylib';\n\nconst Home = () =\u003e {\n return \u003cdiv\u003e{greet(‘World’)}\u003c/div\u003e;\n }\n\nexport default Home;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. TurboRepo 구성:\n\n```js\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"]\n     },\n     \"lint\": {},\n     \"test\": {}\n   }\n }\n```\n\n5. TurboRepo 실행:\n\n```js\nnpx turbo run build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 증분 빌드 및 캐싱\n\nTurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.\n\n1. TurboRepo 캐싱:\n\nsa\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"],\n       \"cache\": true\n     },\n     \"lint\": {\n       \"cache\": true\n     },\n     \"test\": {\n       \"cache\": true\n     }\n   }\n }\n```\n\n## 단일 저장소(monorepo)를 사용해야 하는 경우\n\n- 꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.\n- 소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.\n- 일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.\n\n## 단일 저장소(monorepo)를 피해야 하는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.\n- 독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.\n- 확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.\n\n# 결론\n\n소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.\n\n글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!","ogImage":{"url":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"},"coverImage":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png","tag":["Tech"],"readingTime":4},{"title":"dotenv으로 TypeScript에서 환경 변수 사용하는 방법","description":"","date":"2024-06-23 13:50","slug":"2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv","content":"\n\n새 프로젝트를 시작하거나 환경 변수가 필요한 기존 프로젝트와 작업 중이라면, 이 안내서가 TypeScript 코드베이스에 원활하게 통합되도록 도와줄 것입니다.\n\n# 단계 1: 필수 패키지 설치\n\n터미널을 열고 프로젝트의 루트 디렉토리로 이동하세요. npm과 같은 선호하는 패키지 관리자를 사용하여 필요한 패키지를 설치하세요:\n\n```js\nnpm install dotenv ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 환경 변수 구성\n\n프로젝트 디렉토리의 루트에 .env 파일을 생성하세요. 이 파일 안에 환경 변수를 다음 형식을 사용하여 정의하세요:\n\n```js\nVARIABLE_NAME=value\n```\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nREACT_APP_MY_API_KEY=your-api-key-here\n```\n\n# 단계 3: TypeScript 파일 생성\n\n환경 변수에 액세스할 위치에 .ts 파일을 생성합니다. 이 예제에서는 파일 이름을 app.ts로 지정합시다.\n\n# 단계 4: 환경 변수 가져오고 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 TypeScript 파일(app.ts)에서 dotenv 라이브러리를 가져와서 환경 변수를 .env 파일에서 로드할 수 있도록 구성하세요:\n\n```js\n// app.ts\nimport dotenv from 'dotenv';\ndotenv.config();  // .env 파일로부터 환경 변수 로드\nconst apiKey = process.env.REACT_APP_MY_API_KEY;  // 환경 변수 검색\nconsole.log('API Key:', apiKey);  // 필요한 대로 환경 변수 사용하기\n```\n\n# 단계 5: ts-node를 사용하여 TypeScript 파일 실행하기\n\nts-node는 수동 컴파일 작업 없이 TypeScript 파일을 직접 실행하는 프로세스를 간소화하는 중요한 도구입니다. TypeScript는 정적으로 유형이 지정된 언어이며 Node.js 환경에서 실행되기 전에 JavaScript로 변환되어야 합니다. 이때 ts-node가 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널에서 프로젝트 디렉토리로 이동한 후 TypeScript 파일을 ts-node을 사용하여 실행하세요:\n\n```js\nnpx ts-node app.ts\n```\n\nts-node 패키지는 수동 컴파일 과정 없이 TypeScript 파일을 직접 실행할 수 있도록 도와줍니다. 특히 개발 중에 코드를 빠르게 테스트하고 싶을 때 유용합니다.\n\n이 간단한 단계를 따라가면 dotenv와 ts-node 패키지를 사용하여 환경 변수를 TypeScript 코드에 손쉽게 통합할 수 있습니다. 어려움을 겪는 경우 각 단계를 주의 깊게 따르고 파일 경로와 변수 이름이 프로젝트 구조와 일치하는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자주 묻는 질문 (FAQs)\n\n## 1. TypeScript 프로젝트에서 환경 변수가 필요한 이유는 무엇인가요?\n\n환경 변수는 코드베이스 외부에 API 키 또는 데이터베이스 자격 증명과 같은 중요한 정보를 안전하게 저장하는 데 필수적입니다. 이러한 관행은 보안을 강화하고 개발, 테스트 및 프로덕션 환경 간의 구성 전환 프로세스를 간소화합니다.\n\n## 2. 다른 프로그래밍 언어에서도 환경 변수를 사용할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 환경 변수는 많은 프로그래밍 언어와 프레임워크에서 표준 기능입니다. 이를 사용하면 설정을 코드와 독립적으로 저장할 수 있어 유연성과 보안을 높일 수 있습니다.\n\n## 3. 프로덕션 환경에서 환경 변수를 업데이트하는 방법은 무엇인가요?\n\n애플리케이션을 프로덕션 환경에 배포할 때, 일반적으로 호스팅 공급업체의 대시보드나 명령줄 인터페이스를 사용하여 환경 변수를 설정합니다. 이를 통해 민감한 정보가 코드와 분리되어 안전하게 보호됩니다.\n\n## 4. 환경 변수를 관리하는데 dotenv 대체품이 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, dotenv 외에도 config, env-cmd 및 호스팅 플랫폼에서 제공하는 내장 솔루션과 같은 대체 제품이 있습니다. 프로젝트의 요구 사항과 아키텍처에 가장 적합한 것을 선택하세요.\n\n# 5. 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있나요?\n\n네, 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있습니다. 그러나 이러한 변수는 클라이언트 측에서 접근 가능할 것입니다. 민감한 정보를 보호하기 위해 서버 측 코드 또는 프록시 엔드포인트를 사용하는 것이 권장됩니다.\n\n요약하면, dotenv와 ts-node를 사용하여 TypeScript 프로젝트에 환경 변수를 통합하는 것은 보안 및 구성 관리를 향상시키는 간단한 프로세스입니다. 이러한 단계와 지침을 따르면 민감한 정보를 코드와 분리하여 더 안전하고 효율적인 개발 워크플로우를 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 저는 전문 프론트엔드 개발자를 희망하고 있고, 본업은 시스템 관리자인 수샨트입니다. 저의 학습 여정을 완전 초보자의 눈을 통해 공유하겠습니다. 코딩 통찰력부터 IT 분야를 넘나드는 방법까지 모두 기록해 나갈 예정이에요. 앞으로의 서비스 개발을 향해 노력하는 동안 함께 LinkedIn에서 연결하고 배우는 시간을 가지길 기대하고 있습니다! 함께 소통하고 배우는 것을 기대하고 있어요!","ogImage":{"url":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png"},"coverImage":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png","tag":["Tech"],"readingTime":3}],"page":"4","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>