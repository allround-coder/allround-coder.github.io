<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/8" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/8" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" href="/post/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" href="/post/2024-06-23-UsingESLintHuskyLint-staged"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" href="/post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">OpenAI 기능 호출로 훈련 데이터 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" href="/post/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 첫 번째 라이브러리 만드는 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 첫 번째 라이브러리 만드는 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" href="/post/2024-06-23-MonorepoorNotMonorepo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" href="/post/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="dotenv으로 TypeScript에서 환경 변수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">dotenv으로 TypeScript에서 환경 변수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트 런타임 설정 완전 정복하는 방법" href="/post/2024-06-23-MasteringTypescriptRuntimeConfigurations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트 런타임 설정 완전 정복하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트 런타임 설정 완전 정복하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트 런타임 설정 완전 정복하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선" href="/post/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내" href="/post/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Router에 대해 알아보기 사용 방법과 주요 기능 " href="/post/2024-06-23-LearnaboutReactRouter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Router에 대해 알아보기 사용 방법과 주요 기능 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-LearnaboutReactRouter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Router에 대해 알아보기 사용 방법과 주요 기능 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Router에 대해 알아보기 사용 방법과 주요 기능 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link posts_-active__YVJEi" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"TypeScript에서 함수형 프로그래밍 금융 데이터 흐름 적용 방법","description":"","date":"2024-06-23 13:56","slug":"2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow","content":"\n\n\n![Functional Programming in TypeScript](/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png)\n\n함수형 프로그래밍 (FP)은 코드 품질, 유지 보수성, 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 조작이 높은 복잡한 도메인에서는 더 그렇습니다. TypeScript의 경우, 강력한 유형 시스템을 통해 고급 FP 기술을 처리할 수 있어 데이터의 모델링과 처리를 정확하고 효율적으로 수행할 수 있습니다. 금융 응용 프로그램을 예로 들어 주요 FP 개념을 살펴보겠습니다.\n\n# 주요 함수형 프로그래밍 원칙\n\n- 순수 함수: 동일한 입력에 대해 동일한 출력을 생성하며 부작용이 없는 함수입니다. 순수 함수는 동일한 입력을 사용하면 일관성있게 동일한 출력을 반환하며 범위 외부의 상태를 변경하지 않고 가변 상태에 의존하지 않습니다. 이러한 예측 가능성으로 순수 함수는 테스트 가능하고 신뢰할 수 있으며 프로그램 동작에 대한 추론을 용이하게 하고 디버깅을 단순화합니다.\n- 불변성: 데이터 구조를 변경하지 않고 새로운 구조를 생성해야 합니다. 데이터 구조의 불변성은 한 번 생성된 데이터 구조를 변경할 수 없음을 보장합니다. 기존 구조를 수정하는 대신 새 구조를 만듭니다. 불변성은 상태 관련 문제를 피하면서 동시성을 향상시킵니다.\n- 일급 및 고차 함수: 함수를 인수로 전달하거나 다른 함수로부터 반환하고 변수에 할당할 수 있습니다. 이 기능은 모듈화와 코드 재사용을 도와주며 더 추상적이고 유연한 코드를 만들 수 있습니다. 고차 함수를 사용하여 개발자는 표현적인 방식으로 복잡한 작업을 수행하여 더 깨끗하고 유지보수가 쉬운 코드베이스를 만들 수 있습니다.\n- 함수 합성: 더 간단한 함수들을 결합하여 복잡한 함수를 구축합니다. 이 기술을 사용하면 기본 작업을 연결하여 복잡한 기능을 만들 수 있으며 고수준의 추상화를 유지할 수 있습니다. 함수 합성은 코드 재사용과 명확성을 촉진하며 각 함수를 단독으로 테스트하고 이해하고부터 큰 워크플로에 통합되기 전까지 더 자세히 이해할 수 있습니다.\n- 선언적 코드: 제어 흐름을 명시적으로 설명하지 않고 로직을 표현합니다. 선언적 코드는 계산 논리를 세세하게 설명하지 않고 제어 흐름을 자세히 설명하지 않습니다. 명령형 프로그래밍과 달리 목표를 달성하기 위한 명시적 단계를 지정하는 대신 선언적 프로그래밍은 프로그램이 달성해야 하는 것을 기술합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함수형 프로그래밍을 위한 TypeScript 기능들\n\n- 정적 타입 및 타입 추론: 컴파일 시에 정확성을 보장하고 오류를 감지합니다.\n- 제너릭: 유연하고 재사용 가능한 데이터 구조와 함수를 생성할 수 있습니다.\n- 합집합 및 교집합 타입: 정확한 타입 정의를 가능하게 하며 복잡한 데이터를 조합할 수 있습니다.\n- 맵핑 타입 및 조건부 타입: 데이터 변환 및 타입 조작에 강력한 도구를 제공합니다.\n\n# 모델링에서의 대수형 데이터 타입 (ADTs)\n\nADTs는 복잡한 데이터 구조를 효과적으로 표현하며 각각의 독특한 특성과 행위를 포착할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype Currency = 'EUR' | 'USD';\n\ninterface Cash {\n    type: 'cash';\n    amount: number;\n    currency: Currency;\n}\n\ninterface Stock {\n    type: 'stock';\n    ticker: string;\n    quantity: number;\n}\n\ninterface Credit {\n    type: 'credit';\n    isin: string;\n    maturity: Date;\n    faceValue: number;\n    interestRate: number;\n}\n\ntype Element = Cash | Stock | Bond;\n\nconst calculateValue = (instrument: Element, exchangeRates: Record\u003cCurrency, number\u003e): number =\u003e {\n    switch (instrument.type) {\n        case 'cash':\n            return instrument.amount * exchangeRates[instrument.currency];\n        case 'stock':\n            // Some complex value calcuation\n            return instrument.quantity * 100;\n        case 'credit':\n            // Some complex value calcuation\n            return instrument.faceValue * (1 + instrument.interestRate / 100);\n        default:\n            throw new Error('Unknown financial instrument');\n    }\n};\n```\n\n## 재미있는터와 모나드를 활용한 금융 계산\n\n재미있는터와 모나드(부작용 핸들러)는 금융 데이터를 처리하고 선택적 값, 오류 및 비동기 작업을 다루는 계산을 관리합니다.\n\n```js\ntype Option\u003cT\u003e = None | Some\u003cT\u003e;\n\nclass None {\n    readonly tag = 'None';\n}\n\nclass Some\u003cT\u003e {\n    readonly tag = 'Some';\n    constructor(public value: T) {}\n}\n\nconst none = new None();\nconst some = \u003cT\u003e(value: T): Option\u003cT\u003e =\u003e new Some(value);\n\nconst mapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e U): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? some(fn(opt.value)) : none;\n\nconst flatMapOption = \u003cT, U\u003e(opt: Option\u003cT\u003e, fn: (value: T) =\u003e Option\u003cU\u003e): Option\u003cU\u003e =\u003e\n    opt instanceof Some ? fn(opt.value) : none;\n\nconst calculateInterest = (amount: number, rate: number): Option\u003cnumber\u003e =\u003e\n    rate \u003e= 0 ? some(amount * rate) : none;\n\nconst result = flatMapOption(some(1000), amount =\u003e calculateInterest(amount, 0.05));\nconsole.log(result); \n// Should be....\n// Some { tag: 'Some', value: 50 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 금융 데이터 조작을 위한 렌즈\n\n렌즈는 데이터 구조의 일부에 초점을 맞추어 조작 가능한 데이터를 제공합니다.\n\n```js\ntype Lens\u003cS, A\u003e = {\n    get: (s: S) =\u003e A;\n    set: (a: A, s: S) =\u003e S;\n};\n\nconst lens = \u003cS, A\u003e(getter: (s: S) =\u003e A, setter: (a: A, s: S) =\u003e S): Lens\u003cS, A\u003e =\u003e ({\n    get: getter,\n    set: setter,\n});\n\ntype Portfolio = {\n    owner: string;\n    instruments: FinancialInstrument[];\n};\n\nconst instrumentsLens = lens(\n    (p: Portfolio) =\u003e p.instruments,\n    (instruments, p) =\u003e ({ ...p, instruments })\n);\n\nconst addInstrument = (portfolio: Portfolio, instrument: FinancialInstrument): Portfolio =\u003e {\n    const instruments = instrumentsLens.get(portfolio);\n    return instrumentsLens.set([...instruments, instrument], portfolio);\n};\n\nconst myPortfolio: Portfolio = { owner: 'Rass', instruments: [] };\nconst updatedPortfolio = addInstrument(myPortfolio, { kind: 'cash', amount: 1000, currency: 'USD' });\nconsole.log(updatedPortfolio); \n// 예상 출력 결과...\n// 현금 계기가 추가된 포트폴리오\n```\n\n# 실용적 예시: 금융 데이터 처리 파이프라인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 금융 데이터를 가져 와서 처리하고 리스크 분석을 수행해야 하는 작업을 고려해 보세요.\n\n## 금융 데이터 가져오기\n\n```js\nconst fetchStockPrices = async (): Promise\u003cOption\u003cRecord\u003cstring, number\u003e\u003e\u003e =\u003e {\n    return some({ 'AAAA': 150, 'BBBB': 2800 });\n};\n\nconst fetchExchangeRates = async (): Promise\u003cOption\u003cRecord\u003cCurrency, number\u003e\u003e\u003e =\u003e {\n    return some({ 'EUR': 1.2, 'USD': 1 });\n};\n```\n\n## 데이터 처리와 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 소스에서 데이터를 결합합니다.\n\n```js\nconst processFinancialData = async (): Promise\u003cOption\u003c{ stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }\u003e\u003e =\u003e {\n    const stockPrices = await fetchStockPrices();\n    const exchangeRates = await fetchExchangeRates();\n\n    return flatMapOption(stockPrices, stocks =\u003e\n        mapOption(exchangeRates, rates =\u003e ({ stocks, rates }))\n    );\n};\n\nprocessFinancialData().then(data =\u003e console.log(data));\n```\n\n## 위험 분석\n\n결합된 데이터에 대한 위험 분석을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst analyzeRisk = (data: { stocks: Record\u003cstring, number\u003e; rates: Record\u003cCurrency, number\u003e }): string =\u003e {\n    const totalValue = Object.values(data.stocks).reduce((acc, price) =\u003e acc + price, 0);\n    return totalValue \u003e 5000 ? 'High Risk' : 'Low Risk';\n};\n\nconst performRiskAnalysis = async () =\u003e {\n    const data = await processFinancialData();\n    const riskLevel = mapOption(data, analyzeRisk);\n    // The riskLevel variable here is an option holding the result.\n    console.log(riskLevel);\n};\n\nperformRiskAnalysis();\n```\n\n함수형 프로그래밍 개념인 ADT, 펑터, 모나드, 렌즈와 같은 것들을 사용하여 가독성이 좋고 확장 가능한 금융 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png"},"coverImage":"/assets/img/2024-06-23-FunctionalProgramminginTypeScriptAFinancialDataFlow_0.png","tag":["Tech"],"readingTime":7},{"title":"ESLint  Husky  Lint-staged 사용 방법 및 설정 가이드","description":"","date":"2024-06-23 13:55","slug":"2024-06-23-UsingESLintHuskyLint-staged","content":"\n\n저는 새로운 회사에 프론트엔드 개발자로 합류했어요!\n\n하지만 여기서 또 다시 시작되는군요 — 완벽한 코드 스타일을 위한 영원한 탐험이라니...\n\n제 개인적인 생각으로는 이 방대한 코딩 우주에서 '나쁜 코드'란 존재하지 않는다고 확신하고 있어요. 각자가 고유한 스타일을 갖고 있으니까 말이에요.\n\n그렇지만 5명 이상이 참여하는 프로젝트에서 각자 다른 스타일로 코딩한 걸 보면, 특히 네이밍 규약과 함수 이름 (사실 패턴까지도)에 다양한 스타일이 있음을 알게 되었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 회사에 새로 합류한 입장에서는 코드를 이해하는 데 시간이 걸렸는데, 이러한 시간을 최소화하기 위해 이름 규칙을 적어도 일관되게 적용할 방법에 대해 생각하기 시작했습니다.\n\n![이미지](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png)\n\n물론, 우리는 일반적으로 알려진 ESLint와 Prettier를 사용하고 있었습니다. 그러나 체크를 실행하지 않고 푸시하는 등 실수가 발생한 경우가 있었습니다.\n\n사실, 이는 이 두 도구의 사용을 무효화시키는 결과를 초래합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에는 VSCode와 같은 IDE가 팝업 알림을 제공하지만, 커밋하기 전에 추가적인 확인을 하는 것도 나쁘지 않은 생각이에요. \n\n그래서, 커밋 전에 코드 스타일을 확인하는 라이브러리 husky를 사용해보자는 아이디어를 생각해냈어요. 이렇게 하면 더 편리할 거에요.\n\n추가적인 단계로, ESLint를 사용자 정의하여 내 규칙이나 회사별 규칙을 설정해볼 생각이에요!\n\n먼저, 대부분의 분들이 이미 알고 있을 것 같지만, ESLint와 Prettier가 무엇인지 간단히 설명드리겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ESLint: 코드의 수호천사 👼\n\nESLint를 만나보세요 — 당신의 신뢰할 수 있는 리터입니다. 그것은 하루를 구해주는 친구와 같아요!\n코드를 위한 문법 검사기를 가지고 있는 것 같아요.\nESLint는 교묘한 구문 오류를 잡는 것뿐만 아니라 일관된 코드 스타일을 위해 매치메이커 역할을 하며, 당신의 코드가 최상급인지 확인합니다. 🌟\n\n## Prettier: 코드 스타일리스트 ✨\n\n코드베이스를 위한 패션 관리자가 있는 것 같아요.\nPrettier는 코드를 새롭게 꾸며주는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 두 가지 도구는 때때로 구성 사항 간의 충돌로 이어져있는 코드 스타일과 관련된 측면을 다룹니다. 이러한 충돌을 처리하는 것이 중요합니다.\n\n자, 이 글의 주요 내용인 Husky에 대해 살펴봅시다.\n\n## Husky\n\n이전에 논의한 바와 같이 Husky는 git commit이나 git push와 같은 중요한 Git 이벤트가 발생하기 전에 지정된 스크립트를 실행하는 데 도움이 되는 다재다능한 라이브러리입니다. 이 고급 도구는 사실상 지휘자 역할을 하여 Git 내에서의 작업 흐름을 안내하고 개발자가 개발 과정을 보다 세밀하게 통제할 수 있도록 돕습니다. Husky는 Git 이벤트 사이에 전략적으로 배치된 후크를 구현하여 작동하며 작업 흐름을 섬세하게 조정할 수 있게 합니다. 이런 제어된 이벤트 저지 기법 패러다임은 보통 git 후크 관리로 불립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## lint-staged\n\n깃에서 스테이징의 개념은 lint-staged의 가치를 이해하는 데 기초를 제공합니다. 코드 린트 활동을 수행할 때 개발자들은 종종 검사할 파일을 수동으로 지정해야 하는 선택을 직면할 수 있습니다. - 이는 잠재적으로 고통스러운 노력일 수 있습니다 - 또는 전체 프로젝트 저장소를 검토에 노출시킬 수 있습니다.\n그러나 프로젝트가 규모가 커질수록 복잡성도 증가합니다.\n이러한 맥락에서, 감독은 점점 걱정거리가 되며, 린트 과정 중 실수로 빠뜨린 파일이 상당히 많이 발생할 수 있습니다.\nlint-staged는 코드 품질 보증 분야에서 세련되고 전략적인 협업자입니다. 깃 add를 사용하여 스테이징 상태로 전환된 파일만 엄밀히 검사함으로써, lint-staged는 감독을 방지하고 린팅 정밀도와 효율성을 향상시키는 아주 우아한 해결책을 제공합니다.\n\n실용적인 사용법을 알아보겠습니다!\n\n## husky \u0026 lint-staged 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHusky 및 lint-staged을 설치하세요\n\n```js\nnpx mrm lint-staged\n```\n\n위 명령어를 실행하면 .husky라는 이름의 폴더가 생성되고 package.json 파일에 코드가 추가됩니다.\n\n```js\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  ...\n  \"lint-staged\": {\n    \"*.js\": \"eslint --cache --fix\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## husky 설정하기\n\nmrm은 다운로드 시 기본 구성을 제공하기 때문에 별도로 구성할 것이 별로 없습니다. 그러나 재미를 위해 몇 가지 사용자 정의 문구를 셸 스크립트에 추가했습니다. (?)\n\n## lint-staged 설정하기\n\nlint-staged의 구성은 사용 중인 프로그래밍 언어에 따라 다를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나의 경우에는 TypeScript를 사용하고 있기 때문에 별도로 설정해주어야 했습니다.\n\n```js\n\"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --max-warnings 0 .\"\n    ]\n}\n```\n\n처음에는 경고를 완전히 무시하고 싶지 않았기 때문에 --max-warnings 0을 포함시켰습니다.\n\n당신의 상황에 따라 제거하는 것도 고려해볼 수 있어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 실행하면 아래와 같이 Husky가 원활하게 작동하는 것을 확인할 수 있습니다.\n\n```bash\ngit commit -m 'husky work'\n```\n\n# 💀\n\n\u003cimg src=\"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 😎\n\n![Image](/assets/img/2024-06-23-UsingESLintHuskyLint-staged_2.png)","ogImage":{"url":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png"},"coverImage":"/assets/img/2024-06-23-UsingESLintHuskyLint-staged_0.png","tag":["Tech"],"readingTime":4},{"title":"OpenAI 기능 호출로 훈련 데이터 생성하는 방법","description":"","date":"2024-06-23 13:54","slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"/\u003e\n\n머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\n\n(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"/\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 이 기능을 사용해야 하나요?\n\nOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\n\n# 나의 동기\n\n최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OpenAI를 사용하여 데이터 라벨링하기\n\n먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\n\nOpenAI에 적절한 컨텍스트 제공하기:\n\n- 명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\n- 프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 `blog post content...` 라벨을 추가하세요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\n\n- 도구에 대한 자세한 설명을 제공해주세요.\n- 응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\n\n스키마에 의해 정의된 함수를 작성해주세요:\n\n- 이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\n\n# 간단한 코드 예제 살펴보기\n\n여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\n\n이 예제에서는 어떤 텍스트에 [`긍정적`, `부정적`, `중립적`] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {ITool, ToolSchema} from './interfaces/tool.interface';\nimport {ToolUtils} from \"../utils/tool-utils\";\nimport * as path from 'path';\nimport {createObjectCsvWriter as createCsvWriter} from 'csv-writer';\n\nexport class LabelTool implements ITool\u003cstring[], { inputText: string }\u003e {\n    private csvWriter;\n\n    constructor(private readonly labels: string[] = ['positive', 'negative', 'neutral'], private readonly csvFilePath: string = path.join('labeled_text.csv')) {\n        this.csvWriter = createCsvWriter({\n            path: this.csvFilePath,\n            header: [\n                {id: 'label', title: 'Label'},\n                {id: 'text', title: 'Text'},\n            ],\n            append: true\n        });\n    }\n\n    // 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n    async callback(\n        options: { label: string },\n        ctx: { inputText: string },\n    ): Promise\u003cany\u003e {\n\n        // 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\n        await this.csvWriter.writeRecords([{\n            label: options.label,\n            text: ctx.inputText\n        }]);\n\n        console.log(`CSV 행 추가됨: ${options.label} | ${ctx.inputText}`);\n\n        return `레이블이 성공적으로 추가되었습니다: ${options.label}`;\n    }\n\n    // JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\n    async getSchema(ctx: { inputText: string }): Promise\u003cToolSchema\u003e {\n\n        // 이는 LLM을 위한 제공된 스키마입니다.\n        return {\n            type: 'function',\n            function: {\n                name: 'set_label',\n                description: '텍스트에 레이블 설정',\n                function: ToolUtils.getToolFn(this, ctx),\n                parse: JSON.parse,\n                parameters: {\n                    type: 'object',\n                    properties: { // 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\n                        label: {\n                            type: 'string',\n                            description: '입력 텍스트의 레이블',\n                            enum: this.labels // 가능한 문자열을 제한합니다\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n```\n\n이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n```js\nimport OpenAI from \"openai\";\nimport {LabelTool} from \"./tools/label.tool\";\nrequire('dotenv').config()\n\nconst client = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\n(async () =\u003e {\n    const inputTexts = [ // OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\n        \"이 제품을 사랑해요!\",\n        \"이게 내가 산 것 중에 가장 최악이에요.\",\n        \"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\",\n        \"돈 안 아깝다고.\",\n        \"최고의 구매!\",\n    ];\n\n    for (const inputText of inputTexts) {\n        console.debug(`프롬프트: 이 텍스트에 레이블을 부여하세요: ${inputText}`);\n\n        const tool = new LabelTool(['positive', 'negative', 'neutral']);\n        const context = { inputText: inputText };\n        const prompt = `이 텍스트에 레이블을 부여하세요: ${inputText}`;\n        const system = '훈련 데이터 생성을 돕는 유용한 도우미입니다.';\n\n        const runner = client.beta.chat.completions.runTools({\n            model: 'gpt-3.5-turbo',\n            messages: [\n                {\n                    role: 'system',\n                    content: system,\n                },\n                {\n                    role: 'user',\n                    content: prompt,\n                },\n            ],\n            tools: [await tool.getSchema(context)],\n            tool_choice: 'auto', // 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\n        });\n\n        const finalContent = await runner.finalContent();\n        console.log(`AI 응답: ${finalContent}\n        `);\n    }\n})();\n```\n\n로그 결과:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\r\n\n\r\nCSV 파일:\r\n\r\n\n라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\r\n\n\r\n물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: https://github.com/MaurerKrisztian/training_data_genration_with_openai\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\n\n이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"},"coverImage":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png","tag":["Tech"],"readingTime":7},{"title":"Angular에서 첫 번째 라이브러리 만드는 단계별 가이드","description":"","date":"2024-06-23 13:52","slug":"2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png\" /\u003e\n\n안녕하세요! 라이브러리 프로젝트를 진행 중이었고, 각본을 만들 때는 앵귤러 라이브러리를 단계별로 만드는 방법을 어딘가에 기록하지 않았다는 것을 깨닫게 되었습니다. 이것은 나중에 참고할 수 있도록 그리고 여러분을 위해도 올린 것입니다. 그러니 시작해 보겠습니다!\n\n이 블로그 글을 시작하기 전에, 앵귤러 라이브러리 코딩랩에 대해 말씀드리고 싶습니다. 나는 Angular를 사용하여 라이브러리를 만드는 동안 마주치는 모든 가능한 오류들을 설명하고 있는 코딩랩을 준비 중입니다. 이 코딩랩은 CLI를 사용하여 라이브러리를 만드는 방법을 단계별로 안내하는 내용이 될 것입니다. 이 코딩랩은 자세한 레시피가 되어서, 여러분은 그대로 따라 하여 라이브러리를 만들 수 있습니다.\n\n이 블로그 글에서는 라이브러리의 개요, 라이브러리 생성, 앵귤러 애플리케이션에서 로컬로 사용하는 방법, npm에 발행하는 방법에 대해 이야기하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리 만들기: [여기](https://github.com/NishuGoel/ngSLDemo)\n\n라이브러리 사용하기: [여기](https://github.com/NishuGoel/consuming-angular-lib)\n\n# 개요\n\n우선, 프로그래밍에서 라이브러리란 일반적으로 무엇을 의미하는지 이해해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사전 컴파일된 루틴 - 이것은 반복적으로 수행할 작업의 컴파일된, 확립된, 즉시 사용 가능한 버전임을 시사합니다.\n프로그램이 사용할 수 있다 - 이는 이 재사용성이 라이브러리가 생성된 프로젝트가 아니더라도 여러 다른 프로젝트에서 활용될 수 있다는 것을 시사합니다.\n\n이 모든 것을 종합하면, 라이브러리는 주로 여러 프로젝트에서 사용할만한 기능 세트이며 해당 기능의 컴파일된 버전이 번들로 제공되어 필요한 프로젝트에 제공됩니다. 따라서 라이브러리의 기능은 다음과 같습니다.\n\n- 쉽게 공유할 수 있는 코드\n- 반복해서 사용할 수 있는 기능\n- 하나의 기능을 위해 별도로 지정된 코드\n\nAngular 라이브러리에는 기능을 정의하기 위한 컴포넌트, 모듈, 서비스가 포함되어 있습니다. 우리 앱에서 이미 많은 라이브러리를 사용하고 있습니다. 예를 들어 카운트 다운 타이머나 스크롤 바와 같은 기능을 위해서 사용됩니다. 자주 사용되는 기능이 있다면 왜 그것을 라이브러리로 내보내어 활용하지 않을까요? 많은 Angular/Javascript 라이브러리에 연결된 Angular 애플리케이션으로 생각해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 어떤 라이브러리가 Angular 라이브러리로서 자격을 갖추려면 무엇이 있어야 할까요?\n\n- 먼저 플랫폼 독립적이어야 합니다.\n- 번들화되고 배포돼야 합니다.\n- AOT 컴파일레이션 준비가 되어 있어야 합니다.\n- TypeScript로 작성돼야 합니다.\n\n이제 모든 사람이 소비하기 쉽도록 표준화되고 있는 라이브러리를 만들기 위해서는 패키지를 어떻게 배포해야 하는지에 대한 표준이나 권장 방법이 있어야 합니다.\n\nAngular 패키지 포맷은 우리의 Angular 패키지를 배포하는 추천 방법입니다. 이는 다음에 중점을 두고 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모듈 정의\n- 타이핑 파일\n- 진입점\n- AOT 준비 메타데이터 파일\n\nAPF를 여기에서 읽으세요.\n\n# 라이브러리 만들기\n\n주로 라이브러리를 만드는 데 필요한 중요한 단계는 모든 템플릿을 인라인하고 ngc로 컴파일하여 빌드 형식을 생성하는 것입니다. 그러나 이는 많은 수동 작업이 필요하고 ng-packagr이 이를 해결하기에 충분합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng-packagr을 사용하여 라이브러리를 생성하는 방법에 대해 작성했어요.\n\nDavid Herges가 만든 ng-packagr은 단일 명령어를 사용하여 라이브러리를 빌드하고 패키징할 수 있게 해줍니다. 그러나 Angular 6 이후에는 CLI 내에 통합되어 있어, ng-packagr을 사용하여 Angular 라이브러리를 생성하는 데 ng generate 명령어를 사용할 수 있습니다.\n\nng-packagr이 우리를 위해 처리해주는 것들은 무엇이 있을까요?\n\n- Angular 패키지 형식으로 라이브러리 생성\n- 모든 번들 생성 (es52015, esm5, umd)\n- 형식 정의 파일(.d.ts) 생성\n- aot 메타데이터 파일 생성\n- 모든 스타일과 템플릿을 인라인으로 처리합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 라이브러리를 위한 작업 공간을 만들어보겠습니다!\n\n다음 명령어를 사용하여 새로운 애플리케이션을 생성하되 애플리케이션을 만들지 않도록 설정하세요.\n\n```bash\nng new `application-name` --create-application=false\n```\n\n이렇게 하면 애플리케이션을 만들지 않고 작업 공간만 생성됩니다. 이후 해당 작업 공간 내에서 라이브러리를 생성할 수 있습니다. 아래 이미지를 참고하세요.\n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng generate library `library-name`\n\n이 명령은 lib 폴더가 포함된 projects 폴더를 생성합니다. 여기서 라이브러리에 추가할 기능을 작성할 수 있어요! \n\n![Step-by-step guide to creating your first library in Angular](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_2.png)\n\n라이브러리 작성을 마쳤나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리 구축 시간입니다!\n\n루트 package.json에 빌드 라이브러리 스크립트를 추가하세요:\n\n```json\n\"build-library\": \"ng build nishu-library”\n```\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 라이브러리를 위한 dist 폴더가 생성됩니다.\n\n![이미지](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_4.png)\n\n프로젝트가 조금 어려워지기 시작하는 지점입니다. 왜냐하면 이제 전체 프로젝트에는 3개의 package.json 파일이 모두 포함되어 있다는 것을 알아차릴 것입니다. 루트 package.json에는 라이브러리 빌드 스크립트가 작성되어 있고, 라이브러리 package.json에는 라이브러리의 이름, 버전과 같은 정보가 제공됩니다. 이것은 라이브러리를 npm에 배포할 때 사용됩니다. 라이브러리를 패키징할 때에 대해 이야기를 나눌 것입니다.\n세 번째 package.json은 방금 생성한 라이브러리의 배포 폴더에 있습니다. 이 폴더에는 내보낼 최종 코드가 포함되어 있습니다.\n\n# 라이브러리 패키징\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 라이브러리를 패키징하려면 라이브러리 배포 디렉토리로 이동하여 npm pack 명령을 실행하면 됩니다.\n\n여기서 라이브러리 디렉토리를 패킹하는 혼란을 피합니다. 라이브러리의 빌드된 배포 폴더를 패킹해야 합니다. 이를 수동으로 하는 대신에 스크립트도 추가할 수 있습니다.\n\n\"pack-lib\": \"cd dist/nishu-library \u0026\u0026 npm pack\"\n\n이렇게 하면 라이브러리용 .tgz 패키지가 생성되고, 이를 내보낼 것입니다. 다른 애플리케이션에서 사용될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_5.png\" /\u003e\n\n우리의 패키지가 준비되었으니, 다른 애플리케이션 내에서 사용하여 테스트할 수 있습니다.\n\n새로운 Angular 애플리케이션을 생성하고 다음을 사용하여 라이브러리를 설치하세요:\n\nnpm install `path-to-tgz-file`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json을 확인해 보세요. 종속성에 설치되었는지 확인하세요.\n\n다음과 같이 파일이 추가된 것을 확인할 수 있을 겁니다:\n\n![image](/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_6.png)\n\n다음 단계로, 라이브러리의 모듈을 가져와 컴포넌트를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n' NishuLibraryModule'를 `nishu-library`에서 가져와주세요.\n\n이렇게 하면 프로젝트에서 이 모듈 내에서 선언된 컴포넌트에 액세스할 수 있게 됩니다. 이제 템플릿에서 이 컴포넌트를 직접 사용하여 작동 방식을 확인할 수 있습니다!\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_7.png\" /\u003e\n\n템플릿에서는,\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003csection class=\"body-section\"\u003e\n    \u003clib-nishu-library\u003e\u003c/lib-nishu-library\u003e\n\u003c/section\u003e\n```\n\n여기 있어요!\n\n\u003cimg src=\"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_8.png\" /\u003e\n\n# 마지막으로 우리 라이브러리를 게시해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리를 게시하려면 npm 패키지에 대한 네이밍 규칙을 따르고 고유하게 유지해야 합니다. npm에는 많은 라이브러리가 있으므로, 라이브러리를 @`your-username`/`library-name`과 같이 명명하는 것이 쉬운 방법입니다.\n\n다음 단계는 package.json 내부에 라이브러리의 이름과 버전을 지정하는 것입니다.\n\n```js\n{\n  \"name\": \"nishu-library\",\n  \"version\": \"1.0.0\",\n  \"peerDependencies\": {\n        \"@angular/common\": \"~9.0.0\",\n        \"@angular/core\": \"~9.0.0\",\n  }\n}\n```\n\npeerDependencies는 소비 프로젝트에 해당 패키지 버전과 잘 호환됨을 알리는 방법입니다. 라이브러리의 버전을 주요 버전, 부 버전, 패치 버전 구체적으로 따르기 위해 시맨틱 버전팅을 사용하세요. SemVer에 대해 자세히 알아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json에는 작성자, 라이선스 등 라이브러리에 대한 더 많은 정보를 추가할 수 있습니다.\n\n라이브러리를 빌드하고 dist 폴더에 업데이트된 패키지.json을 찾으세요. pack-lib 스크립트를 사용하여 새 번들을 패키징하세요.\n\n모두 준비되었나요? 이제 npm에 로그인합시다. 명령줄 또는 GUI에서 둘 다 가능합니다.\n\nnpm login을 사용하여 npm에 로그인하고 npm whoami로 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계별로 첫 번째 Angular 라이브러리를 만드는 방법에 대한 안내서.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n짠, 이제 누구나 아래와 같이 Angular 프로젝트에서 이 공개 라이브러리를 사용할 수 있어요:\n\n```bash\nnpm i nishu-library\n```\n\n읽어 주셔서 감사합니다! 피드백/질문은 트위터/링크드인을 통해 연락해 주세요. 🚀","ogImage":{"url":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-Step-by-stepguidetocreatingyourfirstlibraryinAngular_0.png","tag":["Tech"],"readingTime":7},{"title":"모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까","description":"","date":"2024-06-23 13:51","slug":"2024-06-23-MonorepoorNotMonorepo","content":"\n\n소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.\n\n과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.\n\n# 모노 레포란 무엇인가요?\n\n모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Monorepos의 장점\n\n1. 통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.\n2. 단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.\n3. 일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.\n4. 더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.\n\n# Monorepos의 도전과제\n\n1. 확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.\n2. 복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.\n3. 접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예제: TurboRepo를 이용한 단일저장소 설정\n\nTurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:\n\n1. 설치:\n\n```js\nnpx create-turbo@latest\ncd my-turbo-repo\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 애플리케이션과 패키지 추가하기:\n\n```js\n npx turbo run create next-app apps/myapp\n npx turbo run create react-lib packages/mylib\n```\n\n3. 프로젝트 간 코드 공유하기:\n\n```js\n// packages/mylib/src/index.ts\nexport function greet(name: string) {\nreturn `Hello, ${name}!`;\n }\n\n// apps/myapp/pages/index.tsx\nimport { greet } from 'mylib';\n\nconst Home = () =\u003e {\n return \u003cdiv\u003e{greet(‘World’)}\u003c/div\u003e;\n }\n\nexport default Home;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. TurboRepo 구성:\n\n```js\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"]\n     },\n     \"lint\": {},\n     \"test\": {}\n   }\n }\n```\n\n5. TurboRepo 실행:\n\n```js\nnpx turbo run build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 증분 빌드 및 캐싱\n\nTurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.\n\n1. TurboRepo 캐싱:\n\nsa\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"],\n       \"cache\": true\n     },\n     \"lint\": {\n       \"cache\": true\n     },\n     \"test\": {\n       \"cache\": true\n     }\n   }\n }\n```\n\n## 단일 저장소(monorepo)를 사용해야 하는 경우\n\n- 꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.\n- 소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.\n- 일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.\n\n## 단일 저장소(monorepo)를 피해야 하는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.\n- 독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.\n- 확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.\n\n# 결론\n\n소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.\n\n글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!","ogImage":{"url":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"},"coverImage":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png","tag":["Tech"],"readingTime":4},{"title":"dotenv으로 TypeScript에서 환경 변수 사용하는 방법","description":"","date":"2024-06-23 13:50","slug":"2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv","content":"\n\n새 프로젝트를 시작하거나 환경 변수가 필요한 기존 프로젝트와 작업 중이라면, 이 안내서가 TypeScript 코드베이스에 원활하게 통합되도록 도와줄 것입니다.\n\n# 단계 1: 필수 패키지 설치\n\n터미널을 열고 프로젝트의 루트 디렉토리로 이동하세요. npm과 같은 선호하는 패키지 관리자를 사용하여 필요한 패키지를 설치하세요:\n\n```js\nnpm install dotenv ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 환경 변수 구성\n\n프로젝트 디렉토리의 루트에 .env 파일을 생성하세요. 이 파일 안에 환경 변수를 다음 형식을 사용하여 정의하세요:\n\n```js\nVARIABLE_NAME=value\n```\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nREACT_APP_MY_API_KEY=your-api-key-here\n```\n\n# 단계 3: TypeScript 파일 생성\n\n환경 변수에 액세스할 위치에 .ts 파일을 생성합니다. 이 예제에서는 파일 이름을 app.ts로 지정합시다.\n\n# 단계 4: 환경 변수 가져오고 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 TypeScript 파일(app.ts)에서 dotenv 라이브러리를 가져와서 환경 변수를 .env 파일에서 로드할 수 있도록 구성하세요:\n\n```js\n// app.ts\nimport dotenv from 'dotenv';\ndotenv.config();  // .env 파일로부터 환경 변수 로드\nconst apiKey = process.env.REACT_APP_MY_API_KEY;  // 환경 변수 검색\nconsole.log('API Key:', apiKey);  // 필요한 대로 환경 변수 사용하기\n```\n\n# 단계 5: ts-node를 사용하여 TypeScript 파일 실행하기\n\nts-node는 수동 컴파일 작업 없이 TypeScript 파일을 직접 실행하는 프로세스를 간소화하는 중요한 도구입니다. TypeScript는 정적으로 유형이 지정된 언어이며 Node.js 환경에서 실행되기 전에 JavaScript로 변환되어야 합니다. 이때 ts-node가 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널에서 프로젝트 디렉토리로 이동한 후 TypeScript 파일을 ts-node을 사용하여 실행하세요:\n\n```js\nnpx ts-node app.ts\n```\n\nts-node 패키지는 수동 컴파일 과정 없이 TypeScript 파일을 직접 실행할 수 있도록 도와줍니다. 특히 개발 중에 코드를 빠르게 테스트하고 싶을 때 유용합니다.\n\n이 간단한 단계를 따라가면 dotenv와 ts-node 패키지를 사용하여 환경 변수를 TypeScript 코드에 손쉽게 통합할 수 있습니다. 어려움을 겪는 경우 각 단계를 주의 깊게 따르고 파일 경로와 변수 이름이 프로젝트 구조와 일치하는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자주 묻는 질문 (FAQs)\n\n## 1. TypeScript 프로젝트에서 환경 변수가 필요한 이유는 무엇인가요?\n\n환경 변수는 코드베이스 외부에 API 키 또는 데이터베이스 자격 증명과 같은 중요한 정보를 안전하게 저장하는 데 필수적입니다. 이러한 관행은 보안을 강화하고 개발, 테스트 및 프로덕션 환경 간의 구성 전환 프로세스를 간소화합니다.\n\n## 2. 다른 프로그래밍 언어에서도 환경 변수를 사용할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 환경 변수는 많은 프로그래밍 언어와 프레임워크에서 표준 기능입니다. 이를 사용하면 설정을 코드와 독립적으로 저장할 수 있어 유연성과 보안을 높일 수 있습니다.\n\n## 3. 프로덕션 환경에서 환경 변수를 업데이트하는 방법은 무엇인가요?\n\n애플리케이션을 프로덕션 환경에 배포할 때, 일반적으로 호스팅 공급업체의 대시보드나 명령줄 인터페이스를 사용하여 환경 변수를 설정합니다. 이를 통해 민감한 정보가 코드와 분리되어 안전하게 보호됩니다.\n\n## 4. 환경 변수를 관리하는데 dotenv 대체품이 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, dotenv 외에도 config, env-cmd 및 호스팅 플랫폼에서 제공하는 내장 솔루션과 같은 대체 제품이 있습니다. 프로젝트의 요구 사항과 아키텍처에 가장 적합한 것을 선택하세요.\n\n# 5. 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있나요?\n\n네, 브라우저 기반 TypeScript 애플리케이션에서 환경 변수를 사용할 수 있습니다. 그러나 이러한 변수는 클라이언트 측에서 접근 가능할 것입니다. 민감한 정보를 보호하기 위해 서버 측 코드 또는 프록시 엔드포인트를 사용하는 것이 권장됩니다.\n\n요약하면, dotenv와 ts-node를 사용하여 TypeScript 프로젝트에 환경 변수를 통합하는 것은 보안 및 구성 관리를 향상시키는 간단한 프로세스입니다. 이러한 단계와 지침을 따르면 민감한 정보를 코드와 분리하여 더 안전하고 효율적인 개발 워크플로우를 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 저는 전문 프론트엔드 개발자를 희망하고 있고, 본업은 시스템 관리자인 수샨트입니다. 저의 학습 여정을 완전 초보자의 눈을 통해 공유하겠습니다. 코딩 통찰력부터 IT 분야를 넘나드는 방법까지 모두 기록해 나갈 예정이에요. 앞으로의 서비스 개발을 향해 노력하는 동안 함께 LinkedIn에서 연결하고 배우는 시간을 가지길 기대하고 있습니다! 함께 소통하고 배우는 것을 기대하고 있어요!","ogImage":{"url":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png"},"coverImage":"/assets/img/2024-06-23-UsingEnvironmentVariablesinTypeScriptwithdotenv_0.png","tag":["Tech"],"readingTime":3},{"title":"타입스크립트 런타임 설정 완전 정복하는 방법","description":"","date":"2024-06-23 13:49","slug":"2024-06-23-MasteringTypescriptRuntimeConfigurations","content":"\n\n대부분의 사람들이 경력 초기에 배우는 것 중 하나가 구성(configuration)입니다. 그리고 대부분의 사람들이 처음에 배운 방법을 계속 사용합니다. 저는 10년 이상 웹 개발을 해 왔는데, 끊임없이 다양한 구성 접근 방식을 보았습니다. 오늘은 여러분이 앱을 구성하는 것을 조금 더 쉽게 만들어 드리려고 왔습니다. 물론, 새롭게 출시한 제 패키지 https://github.com/mrspartak/config 도 소개할 예정이에요.\n\n![image](/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png)\n\n저는 풀스택 개발자이지만, 백엔드와 프론트엔드 구성을 구분하지는 않습니다. 빌드 시간 및 실행 시간 구성을 모두 사용할 수 있기 때문에 유사하다고 생각하기 때문이죠. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 거예요. 아래 섹션에서 제공하는 통찰력은 꽤 주관적일 수 있으므로, 만약 여러분의 의견이 다르다면 댓글로 의견을 나누고 싶어요.\n\n## 빌드 시간 구성(Build-time configuration)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빌드 시간 구성은 백엔드에서는 덜 흔하지만 프론트엔드에서는 꽤 인기 있는 접근 방식입니다. 여기서 구성 값을 패키지나 이미지에 포함하여 애플리케이션을 실행하는 데 충분할 수 있습니다. 저에게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서 IO 작업이 어떻게 동작하는지에 영향을 미치는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif)\n\n그러나 일부 사람들은 빌드 시간에 API 엔드포인트, 인증 키 등 외부 구성을 포함하여 이를 지나치게 사용하기도 합니다. 이 방법은 작동하지만 각 환경별로 패키지나 이미지를 재빌드하고 테스트해야 하므로 빌드 간에 불일치를 일으킬 수 있습니다.\n\n## 런타임 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드에서 진짜 빛을 발할 때죠. 하지만 나는 SSR (서버 측 렌더링) 및 SPA (단일 페이지 응용 프로그램) 프런트엔드에서 실행시 구성을 자주 사용해요. 앱이 로드되는 처음에 사용되고 외부 구성을 모두 포함해야 하며 환경에 따라 크게 달라질 수 있어요. 여기서 순간적인 환경의 강점이 발휘되어 더 큰 유연성과 적응성을 제공해 줍니다.\n\n## 어떻게 구성하나요?\n\n그래서 정확히 구성(configuration)이 뭔가요? `.env` 파일을 알죠… 아니라면 `.toml`이나 `.json`, `.ini`이 있겠죠? 안돼, 그냥 `.ts` 파일을 만들고 그 안에서 객체를 내보내요. 하지만 기다려봐요. 파일을 git에 커밋해야 하나요? 환경마다 파일을 만들고 비밀 데이터를 숨길까요?\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최고의 형식에 대해 전쟁을 벌일 수 있지만, 사실은 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 것이면 충분히 좋아요. 당신이 원하는 대로 하세요. 하지만 저장 및 사용 전략은 상당히 중요해요.\n\n저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 일반 Docker를 사용하는 경우, 아마도 configs와 secrets에 익숙할 겁니다. 이를 통해 코드와 실행 중인 컨테이너에 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경에 새로운 구성을 배포할 때 발생한다고 생각해요.\n\n## 확인, 확인, 확인\n\n설정은 선언부터 시작돼요. 그것만이 필요한 거예요. 백엔드에서 데이터베이스를 호출해야 한다면, 이 데이터베이스에 인증하는 데 필요한 것을 알아내서 설정 선언에 넣어보세요. 그 결과는 무엇일까요? 앱이 충돌하게 되는 거죠 — 이게 바로 좋은 일이에요. 이를 통해 누락된 또는 잘못된 구성을 조기에 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif)\n\n다음으로 필요한 필드를 구성 파일에 추가해야 합니다. 검증 라이브러리를 사용하거나 더 좋은 방법으로 (비밀 광고 경고) 제 라이브러리를 사용하여 검증을 처리하세요.\n\n## 병합, 때때로 시간을 절약합니다\n\n기본 PORT가 항상 설정되어 있는데 설정하지 않을 때는 어떻게 할까요? 당연히 그 기본값을 정의하는 것이 도움이 됩니다. 그런데 그 후에 어떻게 병합하죠? lodash를 사용하거나 더 나은 방법으로 (계속 언급하다 보면 짜증나지 않고 내 생각처럼 되기 시작한다는 말이 있습니다).\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발자에 대한 생각은 뭐야? 그보다 더 있을까?\n\n물론이죠. 물어주셔서 감사합니다. 제 현재 주 언어는 TypeScript이기 때문에 그것에서 최선을 다해야겠죠. 상상해보세요! 전체 구성이 타입으로 정의된 것을 볼 수 있다면 얼마나 멋진가요. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 편한 삶을 살고 있어요. 제 라이브러리를 사용하면 어떤 유효성 검사 라이브러리라도 손쉽게 적용할 수 있답니다.\n\ntrpc 무신, 정말 천재적이에요. 그의 코드를 그냥 복사하여 사용하면 구성을 결과로 유도해낼 수 있어요. 마법 같죠.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발 환경을 언급했어요. 커밋할까 말까?\n\n안 돼요. 정말로요. OPENAPI_KEY를 즉시 훔치고, 일주일 후엔 길거리에서 구걸하게 될 거에요. 비밀 저장소 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org, 그리고 여러 다른 멋진 프로젝트들이 안전하게 시크릿을 저장하고 공유할 수 있게 해줘요.\n\npackage.json에 설정 스크립트를 포함해서 시크릿의 정확한 버전을 다운로드할 수 있게 해주세요. 또한, 충돌을 피하기 위해 버전을 업데이트하고 git에서 충돌을 피하도록 하는 업로드 스크립트도 포함해주세요. 나중에 감사를 말할 거예요. 저는 이 방법을 여러 해 동안 사용해왔고, 로컬 설정을 플래시 드라이브나 Slack을 통해 공유하는 데 돌아갈 수 없을 거예요.\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 좋아 좋아, 이제 다른 무거운 npm 패키지에 대해 말씀드릴게요\n\n실제로, 이 패키지는 종속성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용해야 합니다. 일반적으로 위에서 언급한 모든 문제를 해결해 줍니다 (물론 개발 환경은 제외하고요). 이 패키지를 사용하면 다음과 같은 장점을 얻을 수 있어요:\n\n- 3가지 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 커버합니다.\n- 런타임 유효성 검사: Zod, Superstruct, Yup 등 인기있는 라이브러리와 함께 작동합니다.\n- TypeScript IntelliSense: 유효성 검사 라이브러리의 변환기를 적용하고 해결된 유효성에 대한 힌트를 제공합니다.\n- 병합: 왜냐하면요? 기본값을 분리해서 가지고 있는 것이 상당히 멋지기 때문이죠. 기본값을 항상 유효성 검사 스키마에 넣을 수 있지만, 그러면 코드에 저장되어 있게 됩니다.\n- 완전히 테스트된 상태: 상용화 준비가 끝난 상태이며 이미 다수의 응용 프로그램에서 사용되었습니다.\n- 백엔드 및 프런트엔드 친화적: 양쪽 환경에서 매끄럽게 작동합니다.\n\n```js\n// file: state/config.ts\nimport { fromJSONFile } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst config = await fromJSONFile({\n  path: [\"../config/default.json\", \"../config/runtime.json\"],\n  schema: z.object({\n    db: z.object({\n      host: z.string(),\n      port: z.number(),\n      username: z.string(),\n      password: z.string()\n    }),\n    app: z.object({\n      port: z.number().optional().default(3000)\n    })\n  }),\n});\n\nexport default config\n\n\n\n// file: index.ts\n// 해결된 구성을 가져옵니다\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성을 사용합니다\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그런데 JSON 지원만 있는 것 같아요. 환경 변수를 사용하는데 무거운 시스템 쓰레기가 많이 들어가지 않은 사랑스러운 방법이 있을까요?\n\n객체와 작업하는 것을 지원하므로 env 객체를 함수에 전달할 수 있어요. 다른 .env 파서를 다시 작성하는 것이 이상할 수 있겠죠. 시장에 이미 테스트된 많은 것들이 있으니까요.\n\n```js\n// file: state/config.ts\nimport { fromObject } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    NODE_ENV: z.enum([\"development\", \"production\"]),\n    DB_HOST: z.string(),\n    DB_PORT: z.number(),\n    DB_USER: z.string(),\n    DB_PASSWORD: z.string(),\n    APP_PORT: z.number().default(3000),\n  })\n  .transform((data) =\u003e ({\n    environment: data.NODE_ENV,\n    port: data.APP_PORT,\n    db: {\n      host: data.DB_HOST,\n      port: data.DB_PORT,\n      user: data.DB_USER,\n      password: data.DB_PASSWORD,\n    },\n  }));\n\nconst config = await fromObject({\n  data: process.env,\n  schema\n})\n\nexport default config\n\n\n// file index.ts\nimport 'dotenv/config'\n// ! dotenv 이후에 설정이로드되어야 하므로 process.env가 채워집니다.\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성 사용하기\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n## 프론트엔드를 언급했는데, 노드 파일 API를 사용한 것 같아요. 빌드가 깨질 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네. 그렇습니다. 따로 내보내는 방법이 있습니다. (만약 다른 더 나은 해결책을 아시면 연락 주세요)\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config/web\"; // 라이브러리의 별도 빌드\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    API_URL: z.string(),\n  })\n\nconst config = await fromObject({\n  data: import.meta.env, // vite의 예제\n  schema\n})\n\nexport default config\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif)","ogImage":{"url":"/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringTypescriptRuntimeConfigurations_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 파이썬 및 웹 개발자를 위한 Rob Percival의 최고의 Udemy 강좌 10선","description":"","date":"2024-06-23 13:47","slug":"2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024","content":"\n\n## 2024년에 Python 및 JavaScript를 배우기 위한 Rob Percival 강사의 가장 좋아하는 Udemy 강의들\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png)\n\n안녕하세요 여러분, 웹 개발, Python, JavaScript 및 Node.js를 배우기 위한 Udemy의 최고 강사인 Rob Percival의 최고의 온라인 강좌를 찾고 계시다면, 당신이 올바른 장소에 오신 것을 환영합니다.\n\nRob Percival은 Udemy의 최고 강사 중 하나인데, Jose Portilla, Stephen Grider, Maximillian SchwarzMuller, Stephane Maarek 및 Brad Traversy와 함께 제가 가장 좋아하는 강사 중 한 명입니다. 이 기사에서는 Udemy 최고 강사이자 제가 최고로 좋아하는 Rob Percival의 최고의 온라인 강좌를 공유하려고 합니다. 하지만, 우선적으로 Rob이 누구인지 알려드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로브 퍼서벌은 유데미 플랫폼에서 가장 자격 있는 강사 중 한 명으로, 코딩에 미친 열정을 가지고 케임브리지 대학에서 수학 학위를 받은 사람입니다.\n\n그는 친구들과 가족을 위한 웹사이트를 만들면서 웹 개발의 기초를 익혔습니다. 웹 개발이 매우 유망한 직업 선택일 수 있다는 것을 깨달은 후에는, 선생님으로 일하던 일을 그만두고 전업 코더가 되기로 결심했습니다.\n\n로브 퍼서벌은 어린이들에게 코딩을 가르치는 데 열정적입니다. 매해 여름에는 케임브리지라는 아름다운 도시에서 코드 스쿨을 운영합니다. 또한 에코 웹 호스팅이라는 인기 있는 웹 호스팅 및 디자인 서비스도 운영합니다.\n\n유데미에서 그의 강좌 중 하나라도 체험해 보면 많은 사람들 - 포함해서 제 자신도 - 그의 강좌를 수강하고 추천하는 이유를 알 수 있을 것입니다. 그의 강좌는 시장에서 가장 우수하며, 만약 어쩌다가 강좌가 마음에 들지 않는다고 느끼면, 기쁜 마음으로 환불해 드릴 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 해드린 어려운 일을 대신해 로브의 우데미 플랫폼에서의 최고 강의 목록을 정리했습니다. 거의 모든 강의가 가치 있는 것을 깨달을 때, 이게 생각보다 얼마나 어려운 일이었는지 알게 될 거예요. 더 자세한 내용을 알아보려면 계속 읽어주세요.\n\n# 2024년 로브 퍼서벌의 파이썬 및 웹 개발자를 위한 최고의 우데미 강좌 10선\n\n다음은 우데미에서 로브 퍼서벌의 최고 온라인 강좌 목록입니다. 로브는 웹 개발, 디지털 마케팅, 노드제이에스, 카피라이팅, 파이썬, 자바스크립트, 루비 온 레일즈, 머신 러닝을 학습할 수 있는 멋진 강좌를 만들었습니다. 이러한 필수 기술을 배우고 테크 분야에서 경력을 시작하려면 우데미에서 로브의 강좌에 참여하세요.\n\n## 1. 완전한 웹 개발자 강좌 3.0 [우데미]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 멋진 코스를 통해 HTML, CSS, JavaScript, PHP, Python 및 MySQL을 사용하여 25개의 웹사이트 및 모바일 앱을 만들며 웹 개발을 배울 수 있습니다. 이 코스를 마칠 때쯤에는 주니어 웹 개발자로서 좋은 직장을 얻을 수 있을 것입니다.\n\n코스 기간: 40시간\n\n코스 평점: 5점 만점에 4.5점\n\n코스 강사: Rob Percival\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코스 가격: $56\n\n이 코스를 구매하면 온디맨드 비디오 강의 40시간 이상과 135개의 기사에 평생 액세스할 수 있습니다.\n\n다음은 이 코스에 가입할 수 있는 링크입니다 — The Complete Web Developer Course 3.0\n\n![Course Image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. The Complete Python Course — Learn Python By Doing [Udemy]\n\n이 강좌는 초보자와 숙련자 모두에게 완벽합니다. Python 3로 모든 중요한 Python 주제를 배우고 작업할 수 있습니다. 객체 지향 프로그래밍을 마스터하고 프로처럼 프로그램 구조를 만들 수 있습니다.\n\n강좌 기간: 35 시간\n\n강좌 평가: 5점 만점에 4.6점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강의 강사: Rob Percival 및 Telcado\n\n강의 가격: $56\n\n이 강의를 구매하면 요청 시 볼 수 있는 35시간 이상의 비디오 강의, 56개의 기사, 그리고 13개의 다운로드 가능한 교육 자료에 평생 액세스할 수 있습니다.\n\n다음은 이 강의인 \"The Complete Python Course - Learn Python By Doing\"에 가입할 수 있는 링크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_2.png\" /\u003e\n\n## 3. The Complete React Js \u0026 Redux Course — Build Modern Web Apps\n\n이 훌륭한 강의는 React.js를 사용하여 더 나은 웹 애플리케이션을 만들 수 있도록 도와줍니다. React.js는 강력하고 인기 있는 JavaScript 라이브러리 중 하나입니다. 당신은 기본적으로 현대적인 방식으로 웹 애플리케이션을 구축하는 방법을 배우게 될 것입니다.\n\n수강 시간: 8 시간\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코스 평점: 5점 만점에 4.6점\n\n강사: Rob Percival\n\n가격: $56\n\n이 코스에서 가장 좋은 점은 Instagram과 유사한 웹 앱을 처음부터 만들 수 있다는 것입니다! Redux를 사용하여 앱 데이터를 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코스에 참여하려면 여기 링크를 클릭하세요 — The Complete React Js \u0026 Redux Course — Build Modern Web Apps\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_3.png)\n\n### 4. The Complete Node.js Developer Course (3rd Edition) [Udemy]\n\n이 코스를 통해 Node.js, Express, MongoDB 및 Jest를 사용하여 실제 웹 애플리케이션을 구축하는 방법을 학습할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강의 기간: 35 시간\n\n강의 평점: 5점 만점 중 4.6점\n\n강사: Rob Percival과 Andrew Mead\n\n강의 가격: $56\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코스를 구매하시면 온디맨드 비디오 강의 35시간 이상과 다운로드 가능한 교육 자료 135개에 대한 평생 액세스가 제공됩니다.\n\n이 코스에 가입하려면 다음 링크를 참조하세요 — The Complete Node.js Developer Course\n\n[이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_4.png)\n\n## 5. The Complete Ruby On Rails Developer Course [Udemy]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이 강좌를 통해 아이디어를 신속하게 프로토타이핑하고 이를 발표 가능한 앱으로 구현하는 방법을 배울 수 있습니다. 귀하는 전문적인 Ruby on Rails 개발자가 될 것입니다.\n\n강좌 기간: 46 시간\n\n강좌 평점: 5점 만점 중 4.6점\n\n강좌 강사: Rob Percival\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수강료: $56\n\n이 과정을 구매하면 온 디맨드 비디오 강의 45시간 이상, 기사 157편, 그리고 다운로드 가능한 교육 자료 1개에 평생 접근할 수 있습니다.\n\n이 과정에 가입하려면 다음 링크를 클릭하세요 — The Complete Ruby On Rails 개발자 과정\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. 파이썬을 활용한 완벽한 머신러닝 코스 [Udemy]\n\n이 훌륭한 코스를 통해 Python, SVM, 회귀 및 비지도 학습을 활용하여 12개의 머신러닝 프로젝트 포트폴리오를 만들 수 있습니다.\n\n코스 기간: 18 시간\n\n코스 평점: 5점 만점 중 4.4점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강의 강사: Rob Percival\n\n수업 가격: $56\n\n이 강좌의 가장 좋은 점은 Python, SVM, 회귀, 비지도 학습 및 기타를 사용하여 12개의 기계 학습 프로젝트 포트폴리오를 만들 수 있다는 것입니다!\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 — Python을 이용한 완벽한 머신 러닝 강좌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_6.png)\n\n## 7. The Complete WordPress Website Business Course [Udemy]\n\n이 완벽한 워드프레스 과정을 통해 워드프레스를 쉽게 마스터할 수 있습니다. 여기서 중요한 점은 이 모든 것을 하기 위해 코딩이나 프로그래밍을 배울 필요가 없다는 것입니다.\n\n수강 기간: 22시간\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코스 평점: 5점 만점에 4.3점\n\n코스 강사: Rob Percival\n\n아래 링크를 통해 이 코스에 참여할 수 있습니다 — The Complete WordPress Website Business Course\n\n![Course Image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 8. The Complete Digital Marketing Course — 12 Courses in 1 [Udemy]\n\n이 강좌는 디지털 마케팅 전략, 소셜 미디어 마케팅, SEO, YouTube, 이메일, Facebook 마케팅 및 분석을 습득하는 데 도움이 되는 훌륭한 강좌입니다.\n\n수강 시간: 22 시간\n\n강좌 평점: 5점 만점 중 4.5점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수강 강사: Rob Percival\n\n수강료: $56\n\n이 강의를 구매하면 온디맨드 비디오 강의 22시간 이상, 기사 35편, 그리고 다운로드 가능한 교육 자료 11개에 평생 접근할 수 있습니다.\n\n이 강의인 The Complete Digital Marketing Course — 12 Courses in 1 에 가입하려면 여기를 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_8.png)\n\n## 9. The Complete Android N Developer Course [Udemy]\n\n이 훌륭한 강의는 안드로이드 앱 개발에 대해 모든 것을 알려줄 것입니다. 안드로이드 7 Nougat를 사용하여 Uber, WhatsApp 및 Instagram과 같은 실제 앱을 구축할 수 있도록 합니다.\n\n수강 시간: 32 시간\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강의 평점: 5점 만점에 4.1점\n\n강의 강사: Rob Percival\n\n강의 가격: $56\n\n이 강의의 최고 장점은 Uber, WhatsApp, Instagram 등의 실제 앱을 만들면서 안드로이드 7 누가 버전에서 안드로이드 앱 개발을 배울 수 있다는 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 과정에 참여하려면 다음 링크를 클릭해주세요 — The Complete Android N Developer Course\n\n![course image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_9.png)\n\n## 10. The Complete JavaScript Course — Beginner To Professional\n\n제목만 봐도 환상적인 내용처럼 보이죠? 여러분이 JavaScript 개발자가 되기 위해 필요한 유일한 과정입니다. 이 강의에는 45개의 JavaScript 프로젝트, JSON, 그리고 AJAX가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 강좌 정보\n\n- 수업 시간: 35시간\n- 강좌 평점: 5점 만점에 4.7점\n- 강사: Rob Percival\n- 강좌 비용: $56\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서, JavaScript를 배우기 위한 최고의 Udemy 강좌 중 하나입니다. 사실, JavaScript 개발자가 되기 위한 유일한 필수 강좌입니다 — 45개의 JavaScript 프로젝트, ES6, JSON, AJAX 등이 모두 포함되어 있습니다!\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 — The Complete JavaScript Course — Beginner To Professional\n\n![이미지](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_10.png)\n\n# Rob Percvial 자주 묻는 질문들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 학습자들이 Rob Percival과 그의 Udemy 코스에 관해 자주 묻는 질문을 살펴보겠습니다.\n\n## 1. Rob Percival은 누구인가요?\n\nRob Percival은 Udemy 플랫폼에서 가장 자격 있는 강사 중 한 명으로, 코딩을 좋아하는 사람이자 케임브리지 대학에서 수학 학위를 받은 사람입니다. 그는 친구와 가족을 위해 웹 사이트를 만들며 웹 개발의 기초를 배웠습니다. Rob Percival에 대해 더 알고 싶다면 여기를 클릭해보세요.\n\n![image](/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 로브 퍼서벌의 자격은 무엇인가요?\n\n로브 퍼서벌은 아이들에게 코딩을 가르치는 데 열정적입니다. 매년 여름에는 캠브리지라는 아름다운 도시에서 코드 스쿨을 운영합니다. 또한 Eco Web Hosting이라는 매우 인기 있는 웹 호스팅 및 디자인 서비스도 운영하고 있습니다.\n\n## 3. 로브 퍼서벌의 강의를 수강해야 하는 이유는 무엇인가요?\n\nUdemy에서 그의 강의 중 하나를 시도해보면, 저를 포함한 많은 사람들이 그의 강의를 수강하고 추천하는 이유가 왜인지 알게 될 것입니다. 그의 강의는 시장 최고이며, 만약 강의가 별로라고 느끼는 경우에도 편안하게 환불해 드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n이상이 2024년에 파이썬과 자바스크립트를 배우기 위한 로브 퍼서벌의 베스트 유데미 강좌에 관한 전부입니다. 이것은 지금까지 로브 퍼서벌이 만든 가장 좋은 강좌들입니다. 이러한 강좌들은 몇 주 만에 완전 초보자에서 자바나 파이썬 전문가로 변모시켜 줄 것입니다.\n\n이 로브 퍼서벌의 베스트 유데미 강좌 10개 목록을 좋아하셨다면, 친구나 가족과 자유롭게 공유해보세요.\n\n다음의 웹 개발 자료도 마음에 드실지도 모릅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 풀 스택 웹 개발자가 되기 위한 10가지 최고 강좌\n- 초보자를 위한 Angular 학습용 무료 강좌 10가지\n- 웹 개발자를 위한 최고의 JavaScript 강좌 10가지\n- 2024년 React 개발자 로드맵\n- 40대에 코딩과 웹 개발을 배울 수 있을까요?\n- 2024년 React 학습을 위한 무료 강좌 10가지\n- 2024년까지 풀스택 웹 개발자가 되기 위한 강좌 10가지\n- 모든 소프트웨어 엔지니어가 배워야 할 10가지\n- 2024년에 Node.js를 배우기 위한 내가 좋아하는 강좌\n- HTML과 CSS를 배우기 위한 내가 좋아하는 무료 강좌\n- 2024년에 TypeScript를 배우기 위한 최고의 7가지 강좌\n- 웹 디자인을 위한 Bootstrap 학습용 무료 강좌 7가지\n- 웹 개발을 깊게 공부하기 위한 내가 좋아하는 강좌\n\n이 기사를 읽어 주셔서 감사합니다. 만약 이 Udemy의 최고 강좌들로 HTML, CSS, JavaScript, Angular, ReactJS, Nodejs를 배우는 것을 좋아한다면 친구나 동료와 공유해주세요. 질문이나 피드백이 있으시면 메모를 남겨주시기 바랍니다.\n\n추신: Javascript를 배우고 싶지만 Rob의 강좌의 대안을 찾고 계시다면 Jonas Schmedtmann의 '2024년 완전한 JavaScript 코스: 실전 프로젝트 구축'도 좋은 강좌입니다.","ogImage":{"url":"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png"},"coverImage":"/assets/img/2024-06-23-10BestUdemyCoursesOfRobPercivalforPythonandWebDevelopersin2024_0.png","tag":["Tech"],"readingTime":9},{"title":"Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내","description":"","date":"2024-06-23 13:45","slug":"2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs","content":"\n\n![OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0](/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png)\n\n안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.\n\n# 왜 다시 유효성 검사가 중요한가요?\n\n다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 재확인의 두 가지 유형:\n\n- 시간 기반 재확인\n- 요청에 따른 재확인\n\n### 1. 시간 기반 재확인\n\n시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfetch('https://example.pl/api/products', { next: { revalidate: 3600 } })\n```\n\n이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.\n\n대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:\n\n```js\n// app/products/page.tsx\n\nexport const revalidate = 3600 // 최대 1시간마다 재검증\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.\n\n## 2. 요청에 의한 재유효화\n\n요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:\n\n```js\nexport default async function Page() {\n  const res = await fetch(\n    'https://example.pl/api/products', \n    { next: { tags: ['products'] } } // 이 부분이 마법이 일어나는 곳입니다\n  ) \n  const data = await res.json()\n\n  return (\n  ...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 한국어로 번역하면 다음과 같습니다.\n\nNext.js에서 라우트 핸들러를 만들어보겠습니다\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n이 라우트에 접근할 때 URL http://localhost:3000/api/revalidate/products를 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.\n\n내부 서버에서 다시 유효성을 검증하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n  // 검색 매개변수에서 비밀 키 가져오기\n  const secret = request.nextUrl.searchParams.get('secret');\n\n  // 비밀 키 확인\n  if (secret !== process.env.REVALIDATE_SECRET) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n환경 변수에 REVALIDATE_SECRET도 추가해주세요:\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.\n\n```js\n// src/subscribers/product.ts\nimport axios from \"axios\";\n\nclass ProductSubscriber {\n  constructor({ eventBusService }) {\n    eventBusService.subscribe(\n      \"product.created\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.updated\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.deleted\",\n      this.revalidateOnDemand\n    );\n  }\n\n  revalidateOnDemand = async () =\u003e {\n    await axios.post(process.env.FRONTEND_REVALIDATE_URL/products, {\n      params: {\n        secret: process.env.FRONTEND_REVALIDATE_SECRET\n      },\n    });\n  };\n}\n\nexport default ProductSubscriber;\n```\n\n`.env` 파일에 다음 변수들을 포함시키세요.\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\nFRONTEND_REVALIDATE_URL=http://localhost.3000/api/revalidate\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.\n\n본 문서가 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png"},"coverImage":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png","tag":["Tech"],"readingTime":4},{"title":"React Router에 대해 알아보기 사용 방법과 주요 기능 ","description":"","date":"2024-06-23 13:44","slug":"2024-06-23-LearnaboutReactRouter","content":"\n\n리액트는 단일 페이지 애플리케이션(SPA)에서 리액트 라우터를 기반으로 합니다.\n\n안녕하세요, 이 DIY 프로젝트에 오신 것을 환영합니다.\n\n시작하기 전에, 먼저 제 소개를 드리겠습니다. 저는 시니어 개발자이자 아키텍트입니다.\n\n이 작업을 시작하기 전에 사전 요구 사항을 나열해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 노드가 설치되었는지 확인해주세요 (설치되어 있지 않은 경우 여기를 클릭해주세요).\n\n위에 언급된 요구 사항이 있는지 확인해주세요.\n\nReact Router가 무엇인가요? 사용해야 하는 이유는 무엇인가요?\n\nReact Router는 React를 위한 라우터 관리자로, 즉 컴포넌트의 렌더링을 제어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션 내에 SignIn, SignUp, Home, Dashboard와 같은 컴포넌트가 있는 간단한 예를 가정해보겠어요. 사용자 상호작용에 따라 한 번에 한 컴포넌트만 나타나도록 설정되어 있어요.\n\n예를 들어, 사용자가 로그인하려면 SignIn 컴포넌트를 렌더링하고, 계정을 만들고 싶다면 SignUp 컴포넌트가 될 거예요. 그렇다면 렌더링을 어떻게 관리할까요?\n\n브라우저에서는 이를 경로를 사용하여 이루어낼 수 있어요. 예를 들어, https://medium.com/`path`\n\n여기서 예를 들어, https://medium.com/signin이라면 SignIn을 렌더링하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Router가 등장하여 이러한 조건을 제어할 수 있게 됩니다. 여기서 React 라우터를 사용하기 시작하려면 먼저 React 앱을 가져와야 합니다. 아래는 이 멋진 GitHub - jherr/create-mf-app: CLI app to create Module Federation applications를 사용해 기본 React 애플리케이션을 만드는 방법에 대한 내용입니다. 자세한 정보 및 이 명령을 사용하여 React를 생성하는 이유에 대해 알아보려면 여기를 클릭해주세요.\n\n```js\n# 웹팩으로 React 생성하기\nnpx create-mf-app\n```\n\nNVM을 사용하여 노드 버전을 최신 버전으로 설정했습니다. NVM에 대해 더 자세히 알아보려면 여기를 클릭해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![React Router](/assets/img/2024-06-23-LearnaboutReactRouter_0.png)\n\n앱 프로젝트 유형을 선택했고, 포트 번호는 기본값 8080으로 남겼습니다. 선택한 프레임워크는 리액트이며 이 부분에서 자유롭게 놀아보세요.\n\n![코드베이스](/assets/img/2024-06-23-LearnaboutReactRouter_1.png)\n\n이제 로컬호스트:8080에서 실행 중인 리액트 애플리케이션이 준비되었습니다. 폴더와 컴포넌트의 코드베이스를 살펴보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-LearnaboutReactRouter_2.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-LearnaboutReactRouter_3.png\" /\u003e\n\n## React Router Dom 설치\n\n이제 npm i react-router-dom을 설치해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-LearnaboutReactRouter_4.png\" /\u003e\n\n앱 컴포넌트에서는 전체 애플리케이션을 BrowserRouter로 래핑해 봅시다.\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { \n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eApp Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cApp /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n# React Router를 사용한 기본 라우팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 라우터는 `Routes /`와 `Route /` 컴포넌트를 제공하며 경로에 기반하여 컴포넌트를 렌더링합니다:\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  Route,\n  Routes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eApp Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst Login = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eLogin Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst AppRoute = () =\u003e {\n  return (\n    \u003cRoutes\u003e\n      \u003cRoute path=\"/\" element={\u003cApp /\u003e} /\u003e\n      \u003cRoute path=\"/login\" element={\u003cLogin /\u003e} /\u003e\n    \u003c/Routes\u003e\n  )\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cAppRoute /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n위의 코드 조각을 설명하자면, react-router-dom에서 세 가지를 import 했습니다: Route, Routes, BrowserRouter 이 세 가지가 모여 라우터 마법을 수행합니다.\n\nBrowserRouter — 앱 전체를 제어하는 기본 래퍼입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션의 경로 목록 및 경로와 요소를 함께 나열한 루트입니다.\n\n루트 - 경로와 요소를 매핑하는 개별 항목\n\n## 경로를 나타내는 일반 JavaScript 객체\n\nReact 컴포넌트에서 react-router-dom에 있는 후크와 함수형 컴포넌트로 이를 구현할 수 있습니다. \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  useRoutes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\n\nconst App = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eApp Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst Login = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eLogin Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst AppRoute = () =\u003e {\n  const routes = useRoutes([\n    {\n      path: \"/\",\n      element: \u003cApp /\u003e\n    },\n    {\n      path: \"/login\",\n      element: \u003cLogin /\u003e\n    }\n  ]);\n  return routes;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cAppRoute /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n와우!! 기본 설정 로직을 완료했습니다. 어려움이 있거나 소스 코드를 보려면 여기를 클릭하세요\n\n# 공개 및 보호된 라우트\n\n보호된 라우트는 Private Routes로도 알려져 있으며 일부 사용자의 액세스 수준에 따라 특정 경로에 대한 액세스를 제한하는 기본 개념입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이에 대해 알아보려면 먼저 Outlet에 대해 배워야 합니다. 이것들은 다시 말해 React Routers에서 옵니다.\n\nOutlet은 기본적으로 React가 라우터 구성에 따라 표시해야 하는 적절한 구성 요소로 대체하는 요소입니다.\n\n그게 무슨 말인지 이해하지 못했다면 걱정하지 마세요. 먼저 SimpleLayout과 DashboardLayout을 구현하는 예제 스니펫을 아래에서 살펴보겠습니다.\n\n## SimpleLayout\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# src/layouts/SimpleLayout\nimport { useOutlet } from \"react-router-dom\";\n\nconst SimpleLayout = () =\u003e {\n  const outlet = useOutlet();\n\n  return (\n    \u003cdiv className=\"container\"\u003e\n      {outlet}\n    \u003c/div\u003e\n  )\n\n}\n\nexport default SimpleLayout\n```\n\n저는 SimpleLayout 컴포넌트의 outlet을 얻기 위해 useOutlet 훅을 사용했습니다. 이를 일반적인 앱에서는 헤더, 푸터 및 내비게이션 바 컴포넌트로 감쌌습니다.\n\n## DashboardLayout\n\n```js\nimport { Link, Navigate, Outlet } from \"react-router-dom\";\n\nconst DashboardLayout = () =\u003e {\n  const isLoggedIn = () =\u003e {\n    // 인증 로직이 여기에 들어갑니다\n    return Math.floor(Math.random() * 10) \u003c 8\n  };\n\n  if (!isLoggedIn()) {\n    alert('isLoggedIn 함수가 로그인하지 않은 사용자를 반환하는 예시')\n    return \u003cNavigate to=\"/login\" /\u003e;\n  }\n\n  return (\n    \u003cdiv className=\"container\"\u003e\n      \u003cnav\u003e\n        \u003cLink to=\"/dashboard\"\u003e대시보드 홈\u003c/Link\u003e\n        \u003cbr /\u003e\n        \u003cLink to=\"/dashboard/settings\"\u003e대시보드 설정\u003c/Link\u003e\n      \u003c/nav\u003e\n      \u003cOutlet /\u003e\n    \u003c/div\u003e\n  )\n\n}\n\nexport default DashboardLayout\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 여부 확인하는 함수가 맞게 동작하지 않습니다. 이 예시에서는 랜덤 값을 사용하여 참 또는 거짓을 무작위로 반환하도록 했습니다.\n\n`Outlet`은 `useOutlet` 훅을 사용한 것과 같은 역할을 합니다.\n\n`!isLoggedIn()`은 이 부분에서 실패하면 사용자가 `/login`으로 이동하게 되며, 이는 SimpleLayout 컴포넌트로 이동합니다. 사용자를 브라우저에서 이동시키기 위해 Navigate 컴포넌트를 사용하여 사용자를 리디렉션시킵니다.\n\n우리는 개인 및 보호된 경로를 처리하기 위한 레이아웃을 준비했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRoutes 및 Route에 Simple 및 Dashboard 레이아웃을 사용하도록 지원을 추가해 보겠습니다.\n\n## 레이아웃 지원과 라우트, 라우트 패턴\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  Route,\n  Routes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\nimport DashboardLayout from \"./Layouts/Dashboard\";\nimport SimpleLayout from \"./Layouts/Simple\";\n\nconst App = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eApp Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst Login = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eLogin Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst Dashboard = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eDashboard Home Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst Settings = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eSettings Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst AppRoute = () =\u003e {\n  return (\n    \u003cRoutes\u003e\n      \u003cRoute path=\"\" element={\u003cSimpleLayout /\u003e}\u003e\n        \u003cRoute index path=\"\" element={\u003cApp /\u003e} /\u003e\n        \u003cRoute path=\"/login\" element={\u003cLogin /\u003e} /\u003e\n      \u003c/Route\u003e\n      \u003cRoute path=\"/dashboard\" element={\u003cDashboardLayout /\u003e}\u003e\n        \u003cRoute index path=\"\" element={\u003cDashboard /\u003e} /\u003e\n        \u003cRoute path=\"settings\" element={\u003cSettings /\u003e} /\u003e\n      \u003c/Route\u003e\n    \u003c/Routes\u003e\n  )\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cAppRoute /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n대시보드 및 설정 구성요소가 DashboardLayout 내에서 어떻게 렌더링되는지 이해하는 방법은 Route 구성 요소 자체에 route를 자식으로 보내는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 간단히 설명하면\n\n```js\n\u003cRoute path=\"/dashboard\" element={\u003cDashboardLayout /\u003e}\u003e\n  \u003cRoute index path=\"\" element={\u003cDashboard /\u003e} /\u003e\n\u003c/Route\u003e\n```\n\n위와 같은 구조로 전달됩니다. `Route index path=”” element='`Dashboard /`' /` prop으로 전달되며, DashboardLayout 내에서 isLoggedIn 상태를 확인하여 `Dashboard` 컴포넌트를 렌더링합니다.\n\n가독성을 높이기 위해 아래 섹션에서 직접 Dashboard를 객체 내의 children 키에 넣는 방식을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Layout Support with Plain JS Object Route patterns\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  useRoutes,\n  BrowserRouter,\n} from \"react-router-dom\";\nimport \"./index.css\";\nimport DashboardLayout from \"./Layouts/Dashboard\";\nimport SimpleLayout from \"./Layouts/Simple\";\n\nconst App = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch1\u003eApp Component\u003c/h1\u003e\n  \u003c/div\u003e\n);\n\nconst Login = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eLogin Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst Dashboard = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eDashboard Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst Setting = () =\u003e (\n  \u003cdiv className=\"container\"\u003e\n    \u003ch2\u003eSetting Component\u003c/h2\u003e\n  \u003c/div\u003e\n);\n\nconst AppRoute = () =\u003e {\n  const routes = useRoutes([\n    {\n      path: '/',\n      element: \u003cSimpleLayout /\u003e,\n      children: [\n        {\n          index: true,\n          element: \u003cApp /\u003e\n        },\n        {\n          path: '/login',\n          element: \u003cLogin /\u003e\n        }\n      ]\n    },\n    {\n      path: '/dashboard',\n      element: \u003cDashboardLayout /\u003e,\n      children: [\n        {\n          index: true,\n          element: \u003cDashboard /\u003e\n        },\n        {\n          path: 'settings',\n          element: \u003cSetting /\u003e\n        }\n      ]\n    }\n  ]);\n  return routes;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"app\"));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cAppRoute /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n이를 따라 했을 때 앱이 어떻게 보여야 하는지에 대한 스크린샷을 첨부합니다. [GitHub 레포지토리 링크](GitHub Repo Link)\n\n만약 마음에 드신다면, 이 블로그에 대해 몇 번의 클랩을 더 클릭해주시면 정말 좋겠습니다. 이를 통해 저의 작업에 더 많은 동기부여를 할 수 있습니다. 아래 내용도 좋아하실 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 테이블 태그를 바꿀게요.\n\n\n| 제목                                             | 작성자          | 날짜       | 플랫폼  |\n|--------------------------------------------------|-----------------|------------|---------|\n| Dockerize any Application in seconds              | Akhshy Ganesh   | Jun, 2024 | Medium  |\n| Must know GitHub Commands for Developers          | Akhshy Ganesh   | Jun, 2024 | Medium  |\n| MacOS Home Brew Guide. MacOS without home brew is nightmare | Akhshy Ganesh | Jun, 2024 | Medium  |\n","ogImage":{"url":"/assets/img/2024-06-23-LearnaboutReactRouter_0.png"},"coverImage":"/assets/img/2024-06-23-LearnaboutReactRouter_0.png","tag":["Tech"],"readingTime":10}],"page":"8","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"8"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>