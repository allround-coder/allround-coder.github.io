<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/131" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/131" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 19의 새로운 기능 - 자산 로딩" href="/post/2024-05-12-NewFeaturesinReact19AssetLoading"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 19의 새로운 기능 - 자산 로딩" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 19의 새로운 기능 - 자산 로딩" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 19의 새로운 기능 - 자산 로딩</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱에서 애니메이션 적용하는 5가지 방법" href="/post/2024-05-12-5WaystoanimateaReactapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱에서 애니메이션 적용하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱에서 애니메이션 적용하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱에서 애니메이션 적용하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DOM 트리의 일부 선택 인터뷰 문제" href="/post/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DOM 트리의 일부 선택 인터뷰 문제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DOM 트리의 일부 선택 인터뷰 문제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">DOM 트리의 일부 선택 인터뷰 문제</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs Monorepo 마스터하기 포괄적인 안내" href="/post/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs Monorepo 마스터하기 포괄적인 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs Monorepo 마스터하기 포괄적인 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs Monorepo 마스터하기 포괄적인 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실시간 알림 React에서 종류 및 구현" href="/post/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실시간 알림 React에서 종류 및 구현" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실시간 알림 React에서 종류 및 구현" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실시간 알림 React에서 종류 및 구현</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁" href="/post/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19 다가오는 변화에 대비하세요" href="/post/2024-05-12-React19GetReadyForWhatsComing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19 다가오는 변화에 대비하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19 다가오는 변화에 대비하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19 다가오는 변화에 대비하세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 19의 새로운 기능 - 새로운 리액트 훅" href="/post/2024-05-12-NewFeaturesinReact19NewReactHooks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 19의 새로운 기능 - 새로운 리액트 훅" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 19의 새로운 기능 - 새로운 리액트 훅" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 19의 새로운 기능 - 새로운 리액트 훅</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="12부 setTimeout  클로저 인터뷰 문제 " href="/post/2024-05-12-Part12setTimeoutClosuresInterviewQuestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="12부 setTimeout  클로저 인터뷰 문제 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="12부 setTimeout  클로저 인터뷰 문제 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">12부 setTimeout  클로저 인터뷰 문제 </strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기" href="/post/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link posts_-active__YVJEi" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 19의 새로운 기능 - 자산 로딩","description":"","date":"2024-05-12 21:17","slug":"2024-05-12-NewFeaturesinReact19AssetLoading","content":"\n\n🚀 리액트 19에서 자산 로딩을 통한 성능 최적화 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png)\n\n안녕하세요, 리액트 애호가 여러분! 리액트 19가 어떻게 자산 로딩을 관리하고 애플리케이션의 성능을 향상시키는지 살펴봅시다. 특히 이미지 및 기타 자산 파일에 관련해서 이야기해보겠습니다.\n\n리액트에서의 로딩 경험:\n\n\n\n리액트에서는 이미지와 같은 자산을 다룰 때 로딩 경험을 관리하는 것이 중요합니다. 일반적으로 뷰는 브라우저에서 먼저 렌더링되고, 그 다음으로 스타일 시트, 폰트, 이미지가 로드됩니다. 이는 비스티하지 않은 스타일에서 스타일이 적용된 뷰로 전환되면서 피드백이 발생할 수 있습니다(FOUC).\n\n리액트 19 이전:\n\nFOUC 문제를 완화하기 위해 개발자들은 종종 자산이 준비되었을 때 감지하는 사용자 정의 코드를 추가하여 모든 것이 로드된 후에만 뷰가 표시되도록 보장했습니다. 그러나 이 방식은 복잡하고 번거로울 수 있었습니다.\n\n리액트 19 이후:\n\n\n\n리액트 19에서는 이미지 및 다른 파일이 로드되는 방식에 중요한 개선이 있습니다. 이제 이러한 자산은 사용자가 현재 페이지를 탐험하는 동안 백그라운드에서 로드될 것입니다. 이 향상은 페이지 로드 시간을 개선하고 대기 시간을 크게 줄일 것으로 기대됩니다.\n\n라이프사이클 Suspense 소개:\n\n리액트 19는 자산 로딩을 위한 라이프사이클 Suspense 개념을 소개합니다. 이는 스크립트, 스타일시트 및 폰트를 포함합니다. 이 기능을 통해 React가 콘텐츠가 표시 준비가 된 시점을 결정하여 \"스타일이 적용되지 않은\" 깜박임을 제거합니다.\n\n새로운 자원 로드 API:\n\n\n\n또한, React 19에서는 preload 및 preinit과 같은 새로운 Resource Loading API를 소개하여 자원이 언제로 로드 및 초기화해야 하는지에 대한 더 큰 제어를 제공합니다. 이 수준의 제어는 자산이 필요한 때 정확히 로드되어 성능과 사용자 경험을 최적화합니다.\n\nReact 19에서는 자산을 백그라운드에서 비동기적으로로드함으로써 대기 시간을 최소화하고 사용자가 내용과 상호 작용하는 불편함 없이 이를 보장합니다. 이 최적화는 React 애플리케이션의 성능을 향상시킬뿐만 아니라 사용자에게 더 즐거운 브라우징 경험을 제공합니다.\n\n결론:\n\nReact 19의 자산 로드 및 성능 최적화 개선은 빠르고 반응적이며 즐거운 웹 애플리케이션을 만드는데 중대한 진전을 나타냅니다. 더 많은 업데이트를 기대해 주세요. React로 가능한 영역을 계속해서 확장해 나가요! 👩‍💻👨‍💻\n\n\n\n관련 링크:\n\n- React 19의 새로운 기능\n\n- React 19의 새로운 기능 — React 컴파일러\n\n- React 19의 새로운 기능 — 서버 컴포넌트\n\n\n\n새로운 기능: React 19 — 액션\n\n새로운 기능: React 19 — 웹 컴포넌트\n\n새로운 기능: React 19 — 문서 메타데이터\n\n새로운 기능: React 19 — 새로운 React 훅","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19AssetLoading_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 앱에서 애니메이션 적용하는 5가지 방법","description":"","date":"2024-05-12 21:15","slug":"2024-05-12-5WaystoanimateaReactapp","content":"\n\u003cimg src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png\" /\u003e\n\n리액트 앱에서 애니메이션은 인기 있는 주제입니다. 다양한 종류의 애니메이션을 만드는 많은 방법이 있습니다. 많은 개발자들이 CSS를 사용하여 애니메이션을 만들고 HTML 태그에 클래스를 추가하는 방법을 주로 사용합니다. 이것은 훌륭한 방법이며 사용해야 합니다. 더 복잡한 애니메이션을 만들고 싶다면 GreenSock을 사용해보세요. GreenSock은 가장 강력한 애니메이션 플랫폼 중 하나입니다. 또한, 리액트에서 애니메이션을 만드는 데 사용할 수 있는 많은 라이브러리와 컴포넌트들이 있습니다.\n함께 알아보겠습니다 😎\n\n- CSS 방법\n- React-transition-group — 기본 CSS 애니메이션과 전환을 간단히 구현할 수 있는 추가 컴포넌트입니다.\n- react-animations — React-animations은 animate.css의 모든 애니메이션을 구현합니다. 사용하기 쉽습니다!\n- React Reveal — 이것은 React용 애니메이션 프레임워크입니다.\n- TweenOne — ant.design에서 애니메이션에 사용하는 라이브러리\n\n물론 오픈 소스에는 더 많은 애니메이션 라이브러리와 컴포넌트가 있습니다. 탐험해보고 싶습니다. 그러나 이 글에는 라이브러리가 포함되지 않습니다. 또한, 글의 끝에서 주목할만한 라이브러리 형태로 보너스를 받게 될 것입니다.\n\n👨‍💻 시작해봐요.\n\n# 1.\n\nCSS 방법\n\n이 방법은 간단한 애니메이션에 가장 적합한 방법 중 하나에요. 자바스크립트 라이브러리를 가져오는 대신 이 방법을 사용하면 번들 크기가 작아집니다. 그리고 브라우저가 더 적은 자원을 사용하게 됩니다. 이 두 가지 요소는 앱 생산성에 상당한 영향을 미칩니다. 번들 크기와 앱 생산성에 신경을 쓰는 경우 간단한 애니메이션이 있다면 이 방법을 주목해보세요.\n\n이제 CSS를 사용하여 애니메이션을 어떻게 만드는지 보여드릴게요.\n햄버거 메뉴 예제를 살펴볼까요:👇\n\n![table](https://miro.medium.com/v2/resize:fit:1200/1*cosKxTRdOfM3YrNc_2Ah3g.gif)\n\n이 메뉴는 CSS 속성을 사용하여 쉽게 사용할 수 있으며 html 태그에 className=\"is-nav-open\"을 트리거로 사용합니다. 이 예제를 구현하는 여러 가지 방법이 있습니다. 그 중 하나는 네비게이션 위에 래퍼를 만들고 마진을 변경하는 것입니다. 네비게이션은 너비가 250px인 상수 너비를 가지고 있습니다. 그리고 너비가 같은 마진-왼쪽 또는 translateX 속성을 가진 래퍼가 있습니다. 네비게이션을 표시해야 할 때는 래퍼에 className=\"is-nav-open\"을 추가하고 래퍼를 margin-left/translateX: 0으로 이동해야 합니다.\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_1.png)\n\n그리고 CSS 스타일:\n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_2.png)\n\n진실을 말하자면, 대부분의 상황에서 이 방법을 사용하는 것이 좋습니다. 몇 줄의 CSS를 작성하고 className을 트리거하는 것이 큰 라이브러리를 가져와 프로젝트에 구현하는 것보다 나은 선택입니다. 사용자들은 브라우저가 앱을 빨리 재생산하면 당신에게 감사할 것입니다.\n\n하지만 가끔 다른 방법을 사용해야 할 때도 있습니다. 다른 방법이 무엇이 있는지 알아보겠습니다. 다음 방법을 살펴보세요.\n\n## 2. ReactTransitionGroup\n\n이 추가 구성 요소는 ReactJs 커뮤니티에서 개발되었습니다. ReactTransitionGroup는 기본 CSS 애니메이션 및 전환을 손쉽게 구현할 수 있습니다.\n\n개발자들이 이 라이브러리를 다음과 같이 설명했습니다:\n\n어쨌든, 이 추가 구성 요소에 대해 알아야 할 세 가지 사항은 다음과 같습니다:\n\n- React Transition Group은 구성 요소 라이프사이클이 변경될 때 클래스를 변경합니다. 결국, 애니메이션 스타일은 CSS 클래스에 설명해야 합니다.\n- ReactTransitionGroup은 크기가 작습니다. React 애플리케이션용 패키지에 설치해야 하며 번들 크기를 크게 증가시키지 않습니다. 하지만 CDN을 사용할 수 있습니다.\n- ReactTransitionGroup에는 3개의 구성 요소가 있습니다(Transition, CSSTransition 및 TransitionGroup). 애니메이션을 얻으려면 해당 구성 요소를 감싸야 합니다.\n\n비슷한 애니메이션을 만드는 방법을 알아보겠습니다 👀👇\n\n![animation](https://miro.medium.com/v2/resize:fit:1200/1*AwFrD7KVn0gibJX5iVT5BA.gif)\n\n먼저 react-transition-group에서 CSSTransitionGroup를 import해야 합니다. 그 후 목록을 해당 그룹으로 감싸고 transitionName 속성을 설정해야 합니다. CSSTransitionGroup의 자식 요소가 추가되거나 삭제될 때 애니메이션 스타일이 적용될 것입니다.\n\n![transition](/assets/img/2024-05-12-5WaystoanimateaReactapp_3.png)\n\n만약 transitionName=\"example\" 프로퍼티를 설정하면, 스타일 시트에 있는 클래스들은 example 이름으로 시작해야 합니다.\n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_4.png)\n\nReactTransitionGroup 버전의 기본 사용법을 확인할 수 있어요. 👀\n\n이게 당신이 필요한 모든 것입니다. 물론, 어떤 로직을 추가해야 할 것입니다. 저희는 예제 연락처 목록을 구현하기 위한 두 가지 방법을 설명해야 합니다.\n\n설명드리겠습니다.\n먼저, handleAdd - 새로운 연락처를 추가하는 함수입니다. 랜덤한 이름을 생성한 후 이를 배열 상태인 state.items에 추가합니다. (랜덤한 이름을 생성할 때 random-name 패키지를 사용합니다)\n\nhandleRemove - state.items 배열에서 인덱스에 해당하는 연락처를 제거하는 함수입니다.\n\n![React Animations](/assets/img/2024-05-12-5WaystoanimateaReactapp_5.png)\n\n# 3️. React-animations\n\nReact-animations — 이 라이브러리는 animate.css를 사용하여 모든 애니메이션을 구축했습니다. 사용하기 쉽고 다양한 애니메이션 컬렉션이 있습니다. React-animation은 Radium, Aphrodite 또는 styled-components와 같이 객체를 사용하여 keyframe 애니메이션을 정의하는 인라인 스타일 라이브러리와 함께 작동합니다. 제가 가장 선호하는 styled-components를 사용하는 것을 선호합니다.\n\n여기서 일부 애니메이션을 볼 수 있습니다: 👀👇\n\n![GIF](https://miro.medium.com/v2/resize:fit:1200/1*2SJH2tItiljweyRgivf9JQ.gif)\n\n당신이 무엇을 생각하고 있는지 알고 있어요 😄\n\n![이미지](\"https://miro.medium.com/v2/resize:fit:940/1*1VZUa3mn3569l3ePzq3piA.gif\")\n\n이 애니메이션을 보자마자 그것들을 어디에 사용할 수 있을지 깨달았을 것입니다.\n이것이 어떻게 작동하는지 살펴봅시다. 예를 들어, 바운스 애니메이션을 봅시다.\n\n![이미지](\"https://miro.medium.com/v2/resize:fit:1200/1*bkPR-nhoZ5aTw_et9Mt7Ow.gif\")\n\nReact-animations에서 선택한 애니메이션을 import해야 합니다.\n\n이전에 언급한 대로, 기본 keyframes와 애니메이션 스타일이 적용된 wrapped 컴포넌트를 만든 후 styled-component를 사용하고 있어요.\n\n컴포넌트를 만들면 애니메이션을 적용하기 위해 어떤 HTML이나 컴포넌트를 래핑해야 해요.\n\n예시:\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_8.png)\n\n애니메이션이 작동합니다. 이 애니메이션은 기본적이고 매우 간단합니다.\n\n스크롤 시 이 애니메이션을 사용하는 좋은 해결책이 있습니다 — react-animate-on-scroll.\n\n# 4️. React-reveal\n\nReact Reveal은 React용 애니메이션 프레임워크입니다. 페이드, 뒤집기, 줌, 회전 등의 기본 애니메이션이 있으며 더 많은 고급 애니메이션이 있습니다. 위치, 지연, 거리, 케스케이드 등과 같은 모든 애니메이션을 프롭스로 제어할 수 있습니다. 여기에서 확인할 수 있습니다. 사용자 정의 CSS 효과를 사용할 수도 있습니다. 또한 서버 측 렌더링 및 고차 컴포넌트가 있습니다. 스크롤 시 애니메이션을 사용하는 경우 이 프레임워크를 사용하면 좋습니다. 작동 방식을 살펴보세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_9.png\" /\u003e\n\n스크롤 효과에 대한 이 애니메이션을 살펴보겠습니다.👀👇\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*Xk4c0gzjEu8RCsCyVRPlYg.gif)\n\n우리에게는 전체 화면 페이지와 제목이 내부에 있는 5개의 블록이 있습니다.\n\n![image](/assets/img/2024-05-12-5WaystoanimateaReactapp_10.png)\n\nanimateList 상수를 생성합니다. 이 배열에는 5개의 요소가 포함되어 있습니다. 배열 메서드 map을 사용한 후에는 각 요소를 Fade 구성 요소에 렌더링하여 아이템을 제목에 삽입할 수 있습니다. Const 스타일은 블록과 제목에 대한 간단한 CSS 스타일을 가지고 있습니다. 우리는 Fade 애니메이션으로 위에서 아래로 빛나는 5개의 블록을 가지고 있습니다.\n\n# 5️. TweenOne 및 애니메이션 Ant Design\n\nAnt Design은 사용하기 쉬운 여러 컴포넌트로 구성된 React UI 라이브러리입니다. 우아한 사용자 인터페이스를 구축하는 데 유용한 컴포넌트입니다. Ant Design은 중국 기업 알리바바에 의해 만들어졌으며 알리바바(물론), 텐센트, 바이두 등 많은 잘 알려진 회사들이 사용하고 있습니다.\n\n아마도 Ant Design에 대해 들어보았을 것입니다. 그래서 우리는 그들의 랜딩 페이지의 애니메이션을 살펴보겠습니다.👇\n\n![Ant Design Animation](https://miro.medium.com/v2/resize:fit:1200/1*_6S4VTzzGwRtebx-ys4htA.gif)\n\n위에서 보시다시피 많은 애니메이션 요소들이 있어요. 비슷한 애니메이션을 가진 요소들이 많아, 간단한 버전을 보여드리고 싶습니다. 전체 출발하는 지구 모습과 녹색 공, 그리고 배경에는 빨간 정사각형 한 개가 있어요. 우리의 애니메이션은 이렇게 보일 거에요.\n\n![animation](https://miro.medium.com/v2/resize:fit:1200/1*awI1UedVjvAwINK3lwCsyA.gif)\n\n이 애니메이션에서는 TweenOne 컴포넌트를 사용했지만, 애니메이션에 경로를 사용하기 위해 PathPlugin이 필요해요. PathPlugin을 TweenOne.plugins에 추가하면 잘 작동할 거에요.\n\n![path-plugin](/assets/img/2024-05-12-5WaystoanimateaReactapp_11.png)\n\n다음 단계에서는 기본 애니메이션 매개변수를 설명해 보겠습니다:\n\n- duration - 애니메이션 시간(밀리초 단위),\n- ease - 애니메이션 이징,\n- yoyo - 각 반복마다 앞뒤로 번갈아 가며 재생합니다.\n- repeat - 애니메이션을 반복합니다. 지속적인 프로세스를 위해 -1을 사용해야 합니다.\n- p - 애니메이션을 위한 경로 좌표입니다.\n- easePath - 애니메이션을 위한 이징 경로 좌표입니다.\n\n마지막 두 매개변수에 대해 걱정할 필요는 없습니다. 이것들은 이 SVG에 더 구체적인 매개변수입니다.\n\n다음으로 애니메이션 객체를 만들겠습니다. 이 객체에는 3 종류의 애니메이션이 있습니다:\n\n- redSquare — 아래에 설명한 루프 파라미터 및 Y 좌표, 지속 시간, 지연이 있습니다.\n- greenBall — x, y를 값 p로 하는 객체 파라미터를 갖는 경로가 있습니다. 지속 시간, 반복 및 ease는 TweenOne.easing.path 함수와 함께 있습니다:\n  - path — easePath 좌표.\n  - lengthPixel — 400 구간으로 나뉜 곡선.\n  - track — 루프 스타일과 rotate 파라미터가 있는 축을 가진 타원.\n\n![이미지](/assets/img/2024-05-12-5WaystoanimateaReactapp_12.png)\n\n이 코드에 대해 걱정할 필요는 없습니다. TweenOne 컴포넌트에 주의를 기울이셔야 합니다. 간단히 기억해 주겠습니다, 이러한 컴포넌트들은 rc-tween-one에서 가져올 것입니다. 기본 속성과 애니메이션 속성이 있는 기본 컴포넌트로 사용됩니다. 이것이 바로 우리의 애니메이션입니다! 각 TweenOne에는 redSquare, track, greenBall과 같은 고유한 애니메이션 규칙이 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*lIUAJ_Cu6PgTrL6MLj1uvA.gif)\n\n😄 조금 무서워 보이죠. 하지만 실제로 이 줄들에 주의를 기울여야 합니다.\n\n![Animation](/assets/img/2024-05-12-5WaystoanimateaReactapp_13.png)\n\n알아차린 것처럼, 이 방법으로 애니메이션을 생성하는 것은 간단한 방법입니다. 필요한 것은 애니메이션 규칙을 설명하고, 그것을 TweenOne 컴포넌트로 전달하는 것뿐입니다.\n\n## 🏁 결론\n\n애니메이션을 사용하는 여러 방법이 있습니다. 각각 다른 방법이 필요합니다. 오늘은 여러분의 프로젝트에서 사용할 수있는 몇 가지 결정을 검토했습니다. 당신에게 어울리는 방법을 선택하세요 👨‍💻\n\n🙂 이 기사를 읽기 전 당신의 사이트:\n\n\u003cimg src=\"/assets/img/2024-05-12-5WaystoanimateaReactapp_14.png\" /\u003e\n\n🤪 이 기사를 읽은 후 당신의 사이트:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*emR9fk9Kt80Dugw5VSNkQA.gif\" /\u003e\n\n😄 애니메이션을 현명하게 활용해보세요!\n\n- Sentry를 활용한 React 앱의 오류 추적\n- React JS에서 CSS를 구현하는 9가지 방법\n\n# ❤️ 읽어주셔서 감사합니다\n\n재미를 내고 계속 배우며 코딩을 계속하세요.\n저를 Medium과 Linkedin에서 팔로우하세요.\n\n# 👏 좋아요, 공유 및 의겢을 남겨주세요.\n\n질문이나 피드백이 있으면 아래 댓글로 알려주세요 👇\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*itETjI1PFdtVKZvp5Qusxw.gif)\n\n- 리액트를 배우는 길\n- 리액트 배움: 함수형 웹 개발과 리액트 및 리덕스\n- Eloquent JavaScript, 3판: 프로그래밍에 대한 현대적인 소개\n- JavaScript: Definitive Guide: 웹 페이지 활성화(결정적 가이드)\n- 빠르게 배우는 React: 리액트, JSX, 리덕스 및 GraphQL을 이용한 무난한 웹 앱\n- JavaScript: 좋은 부분\n- JavaScript Patterns: 코딩 및 디자인 패턴으로 더 나은 애플리케이션 구축\n\n- react-motion — 애니메이션 문제를 해결하는 스프링\n- react-spring — 스프링 물리학 기반의 리액트 애니메이션 라이브러리\n- ant-motion — Ant Design의 애니메이션 명세 및 구성요소 애니메이션\n- react-move — 리액트를 위한 아름다운, 데이터 기반 애니메이션\n- react-flight — 리액트용 애니메이션 구성물을 구축하는 최고의 방법\n- react-flip-move — FLIP 기법을 사용하여 DOM 변경(예: 목록 재정렬) 사이의 무난한 애니메이션\n- react-burger-menu — CSS 전환 및 SVG 경로 애니메이션을 사용하여 효과 및 스타일 모음을 가진 오프캔버스 사이드바 구성 요소\n- animated — React 및 React Native를 위한 선언적 애니메이션 라이브러리\n- react-tween-state — React 애니메이션\n- react-animations — 인라인 스타일 라이브러리용 애니메이션 모음\n\n- GSAP — 현대 웹을 위한 고품질 애니메이션을 지원하는 초고성능 전문가급 애니메이션 라이브러리\n- Anime.js — Anime.js (/ˈæn.ə.meɪ/)는 간단하지만 강력한 API를 갖춘 경량 JavaScript 애니메이션 라이브러리입니다. CSS 속성, SVG, DOM 속성 및 JavaScript 객체와 함께 작동합니다.\n- Popmotion — 사용자 인터페이스를 위한 감각적인 애니메이션 라이브러리\n- vivus — SVG에 그리기 애니메이션을 만들기 위한 JavaScript 라이브러리\n- svg.js — SVG 조작 및 애니메이션을 위한 경량 라이브러리\n- velocity — jQuery의 $.animate()와 동일한 API를 갖춘 애니메이션 엔진인 Velocity\n- wow — 스크롤할 때 나타나는 애니메이션. 매우 애니메이트.css 친구.\n- dynamic.js — 물리 기반 애니메이션을 생성하기 위한 JavaScript 라이브러리\n- granim.js — 작은 JavaScript 라이브러리를 사용하여 유려하고 상호 작용적인 그래디언트 애니메이션 생성\n- kute.js — 코드 품질과 탁월한 성능을 갖춘 네이티브 JavaScript 애니메이션 엔진인 KUTE.js\n- TweenJs — JavaScript를 위한 간단하지만 강력한 트윈/애니메이션 라이브러리. CreateJS 라이브러리 스위트의 일부.\n- moveTo — 어떠한 종속성도 없는 가벼운 스크롤 애니메이션 JavaScript 라이브러리\n","ogImage":{"url":"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png"},"coverImage":"/assets/img/2024-05-12-5WaystoanimateaReactapp_0.png","tag":["Tech"],"readingTime":10},{"title":"DOM 트리의 일부 선택 인터뷰 문제","description":"","date":"2024-05-12 21:13","slug":"2024-05-12-PartialselectionofaDOMtreeAninterviewquestion","content":"\n\n\n![DOM 트리의 일부 선택에 관한 인터뷰 질문](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png)\n\n웹 페이지의 일부를 선택하는 문제는 상당히 실용적이며, 웹 레이아웃과 DOM 트리 간의 변환과 관련이 있어 시각적으로 흥미로운 문제입니다.\n\n이 문제는 웹 페이지의 일부를 선택하고 선택한 요소들을 모두 파악하여 화면에 표시된 순서대로 하나씩 나열하라는 내용입니다.\n\n이 유형의 문제를 해본 적이 없다면, 그 순간에는 압도적일 수 있습니다. 그러므로 이 글에서는 이에 대해 천천히 공부해보려 합니다.\n\n\n\n## 웹 페이지 부분 선택\n\n부분 선택하는 것이 좀 tricky 하죠. 정확히 어떤 것을 말하는 걸까요?\n\n모두가 아시다시피 페이지는 요소(element)로 이루어져 있습니다. 하나의 요소는 시각적인 요소일 수도 있고, 다른 요소들을 그룹화하는 요소일 수도 있습니다. 이것이 바로 DOM 트리라고 합니다.\n\n![DOM 트리의 부분 선택](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_1.png)\n\n\n\n간단히 하기 위해 위의 예시에서는 이진 트리를 사용했습니다. 하지만 실제로는 각 부모 아래 노드가 비어 있거나 하나, 두 개 이상의 요소를 포함할 수 있습니다. 이 질문의 첫 번째 과제는 위 트리를 웹 콘텐츠에 대응시키는 것입니다. 우리는 그렇게하는 일이 드물기 때문에 나무 노드에서 어떤 것이 무엇인지 명확하지 않아집니다. 그래서 웹 용어에 따라 노드에 레이블을 붙여 보겠습니다:\n\n![DOM tree image](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_2.png)\n\nbody 태그에서 시작합니다 (원한다면 html에서 시작할 수도 있어요 :). 그리고 페이지에는 헤더와 본문 두 섹션이 있습니다. 헤더를 예로 들면, 가로로 두 개의 div 태그가 있습니다. 그 중 하나에는 링크 태그로 래핑된 이미지 로고가 있습니다. 이것이 전형적인 헤더입니다. 비슷하게, 본문 섹션을 살펴보면, 하나의 article과 참고 자료 목록이 있습니다. article 안에는 컨텐츠 안에 있는 저자 이름이 들어 있는 중첩된 span이 있습니다. 그래서, 이제 이 웹 페이지의 올바른 정신적 이미지를 가졌으면 좋겠네요.\n\n트리의 위상 구조는 페이지의 레이아웃으로 잘 번역되지 않을 수 있습니다. 이것은 레이아웃이 위에서 아래로 이동하거나 왼쪽에서 오른쪽으로 이동할 수도 있고, CSS가 순서를 뒤집을 수도 있기 때문입니다. 반면에, DOM 트리 노드 표현은 한 가지 패턴으로만 이동할 수 있습니다: 부모로 들어가면 여러 자식을 볼 수 있고, 자식 안에는 자식의 자식을 볼 수 있습니다. 이 두 가지 시스템을 머리 속에서 동시에 운영하는 데 시간이 조금 필요할 수 있습니다.\n\n\n\n질문은 페이지의 일부를 선택하도록 우리에게 요청했습니다. 페이지의 로고에서 마우스를 드래그하여 기사의 작성자 이름에 놓는 것을 원한다고 가정해 봅시다. 먼저 요구 사항에서 생각해 봅시다. 우리가 실제로 무엇을 선택했나요?\n\n우리는 헤더 섹션에서 시작해서 본문 섹션에서 끝났습니다. 그래서 헤더 섹션에서 일부를 선택하고 본문 섹션에서 일부를 선택했습니다. 모두 부분적인 선택이라는 이유는 어떤 것도 완전한 선택을 받지 못했기 때문입니다. 이제 질문은 DOM 표현에서 부분적인 선택이 무엇인지 묻습니다.\n\n다음 강조부분에서 살펴보겠습니다:\n\n![Partial selection of a DOM tree: An interview question](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_3.png)\n\n\n\n아마도 일부 노드에는 시각적인 표현이 없을 것이라고 생각할 수 있습니다. 이 경우, 부모 노드(잎이 아닌)가 선택되지 않을 것이라고 가정한다면 main, article 및 마지막 div 노드를 숨길 수 있습니다. 기본적으로 오직 잎 노드만 표시될 수 있으므로 사용자가 볼 수 있는 것입니다.\n\n어차피, 어떤 변화던 주제가 크게 달라지지 않아야 합니다. 따라서 이 기사에서는 여전히 부모가 먼저 강조된 기본 버전에 대해 이야기합니다. 우리의 변명은 부모 노드(또는 startProcess)에서 시각적 표시가 전달될 수 있기 때문입니다.\n\n## DOM 노드의 트리 순회\n\n질문을 받기 전에 위의 그림을 보았다면, 아마도 어느 정도 여유를 가지고 질문에 대답할 수 있을 것입니다. 나머지는 주로 우리가 알고리즘 코더로서 훈련받은 방법입니다.\n\n\n\n트리 순회에 대해 이야기할 때, 주로 두 가지 패턴이 있습니다: 깊이 우선과 너비 우선입니다. 웹 페이지 표시는 깊이 우선 탐색으로 이루어집니다. 왜냐하면 우리는 body로 들어가고, 그리고 header로 들어가기 때문에 header가 표시되기 전에 main을 표시할 필요가 없습니다.\n\n이것은 한 조각의 내용을 가능한 한 자세히 공개하고 나서 다른 조각의 내용을 표시하려고 합니다. 레이아웃 관점에서 다음(또는 다른) 요소는 일반적으로 형제 노드입니다.\n\n먼저 자식을 다음으로 형제를, 이것이 깊이 우선 탐색입니다. 이것은 재귀 알고리즘을 사용하여 수행할 수 있다는 것을 의미합니다. 이것은 프로그래밍을 다소 쉽게 만들어주며, 스택을 사용할 필요가 없으므로 중첩 함수 호출이면 충분합니다.\n\n다음으로, 중위/전위/후위 순서는 혼동스러울 수 있습니다. 기본적으로 우리의 경우에는 각 요소에 도달한 후에 노드 이름을 표시하고, 그런 다음 자식 요소로 깊숙이 파고들 수 있도록 전위 순서인 경우가 될 수 있습니다: 먼저 이름을 수집하고 나서 자식 요소로 깊숙히 들어갑니다.\n\n\n\n```js\nbody -\u003e header -\u003e div -\u003e p -\u003e em\n-\u003e div -\u003e a -\u003e img(*) -\u003e a\n-\u003e main -\u003e article -\u003e p -\u003e div -\u003e span(*)\n-\u003e ul -\u003e li -\u003e li\n```\n\n위에 전위 순서로 인쇄된 트리 이동 목록이 있습니다. 이 목록에서 img와 span을 확인할 수 있고, 그것이 우리의 대답입니다. 이동할 때 기본적으로 img를 만나면 노드를 기록하기 시작하고 span을 감지할 때까지 마무리할 수 있습니다. 왜냐하면 img와 span 둘 다 질문의 입력이어야 하기 때문입니다. 여기서 마우스 동작(예: onDragStart)이 감지됩니다.\n\n잎 노드에만 초점을 맞추려면 잎이 아닌 노드를 수집하지 않는 것을 건너뛸 수 있으며, 이렇게 할 경우 다음 목록을 얻을 수 있습니다:\n\n```js\np -\u003e em -\u003e img(*) -\u003e a\n-\u003e p -\u003e span(*) -\u003e li -\u003e li\n```\n\n\n\n우리는 다양한 변형이 가능할 거라고 가정할 수 있어요. 예를 들어, 무엇인가의 이유로 형제로 이동하기 전에 부모를 다시 방문해야 하는 경우가 있다면, 기술적으로 부모에게 끝내기 작업을 의존해야 하는 경우일 수도 있어요 (예: endProcess). 심지어  postorder 순회도 할 수 있어요:\n\n```js\np -\u003e em -\u003e div -\u003e img(*) -\u003e a -\u003e a -\u003e div -\u003e header\n-\u003e p -\u003e span(*) -\u003e div -\u003e article\n-\u003e li -\u003e li -\u003e ul -\u003e main -\u003e body\n```\n\n위 목록에서 부모(잎이 아닌 것)를 숨겨서 이전에 얻은 답변을 얻을 수도 있어요. 완성을 위해, 여기에 inorder 순회에 대한 인쇄결과가 있어요:\n\n```js\np -\u003e div -\u003e em -\u003e header\n-\u003e img(*) -\u003e a -\u003e div -\u003e a -\u003e body\n-\u003e p -\u003e article -\u003e span(*) -\u003e div -\u003e main\n-\u003e li -\u003e ul -\u003e li\n```\n\n\n\n어떤 문제에 inorder가 어떻게 도움이 될지 정확히는 모르겠지만, 어쨌든 특별한 용도가 있을지도 몰라요.\n\n따라서 특정 시점에 노드를 처리해야 할 필요가 있다면, 트리를 다른 방식으로 순회할 수도 있어요. 하지만 결국 이는 깊이 우선 탐색이기 때문에 무엇이든지, 올바른 답변에 가까워질 것이에요.\n\n![이미지](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_4.png)\n\n# 결론\n\n\n\n웹 페이지의 일부를 선택하는 것은 이해하기 어려울 수 있지만, 중요한 것은 어떤 노드가 어떤 내용 조각에 매핑되는지 위상적인 방식으로 알아내는 것입니다. 그 후에는 트리 순회 작업의 문제입니다.\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png"},"coverImage":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png","tag":["Tech"],"readingTime":5},{"title":"Nextjs Monorepo 마스터하기 포괄적인 안내","description":"","date":"2024-05-12 21:12","slug":"2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide","content":"\n\n웹 개발의 세계에서 Next.js는 서버 측 렌더링 및 정적 생성 웹 애플리케이션을 구축하기 위한 강력하고 다재다능한 프레임워크로 등장했습니다. 프로젝트가 커지면 여러 패키지와 종속성을 관리하는 것이 어려운 작업이 될 수 있습니다. 이때 모노레포가 필요해집니다. 모노레포(“monolithic repository\"의 줄임말)는 여러 프로젝트, 라이브러리 및 패키지를 수용하는 단일 저장소입니다. 이 글에서는 Next.js와 함께 모노레포를 사용하는 이점을 살펴보고 설정하는 방법에 대한 단계별 가이드를 제공할 것입니다.\n\nNext.js와 함께 모노레포를 사용하는 이유는 다음과 같습니다:\n\n- 간소화된 종속성 관리: 모노레포를 사용하면 모든 프로젝트의 종속성을 한 곳에서 관리할 수 있어 추적하고 업데이트하기 쉬워집니다.\n- 코드 재사용성: 단일 저장소에 여러 프로젝트를 담음으로써 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있어 중복 코드의 양을 줄이고 유지보수성을 향상시킬 수 있습니다.\n- 개발 과정 단순화: 모노레포를 사용하면 여러 프로젝트를 동시에 개발하고 테스트할 수 있어 한 프로젝트의 변경이 다른 프로젝트를 깨뜨리지 않도록 보다 쉽게 확인할 수 있습니다.\n- 개선된 협업: 모노레포를 통해 개발자들은 여러 프로젝트에서 작업할 수 있어 여러 저장소 간에 전환할 필요가 없어 협업을 간소화하고 생산성을 향상시킬 수 있습니다.\n\n\n\nNext.js 모노레포 설정하기\nNext.js 모노레포를 설정하려면 Turborepo라는 인기있는 도구를 사용할 것입니다. Turborepo는 JavaScript 및 TypeScript 모노레포용 고성능 빌드 시스템입니다.\n\n단계 1: Turborepo 설치하기\n먼저 시스템에 Node.js와 npm이 설치되어 있는지 확인하세요. 그런 다음 다음 명령을 실행하여 Turborepo를 전역으로 설치하세요:\n\n```js\nnpm install -g turborepo\n```\n\n단계 2: 새 모노레포 만들기\n다음으로, 모노레포를 위한 새 디렉토리를 만들고 해당 디렉토리로 이동하세요:\n\n\n\n```js\nmkdir nextjs-monorepo\ncd nextjs-monorepo\n```\n\n이제 다음 명령어를 실행하여 새 Turborepo를 생성하세요:\n\n```js\nnpx create-turbo@latest\n```\n\n프롬프트에 따라 답변해주세요. Next.js 프리셋을 선택할 수 있습니다.\n\n\n\n**단계 3:** Next.js 앱 만들기\n모노레포를 설정한 후, 이제 모노레포 내에서 새 Next.js 앱을 만들 수 있습니다. 앱 디렉토리로 이동한 다음 다음 명령어를 실행하세요:\n\n```js\ncd apps\nnpx create-next-app@latest my-next-app\n```\n\n`my-next-app`을 앱에 원하는 이름으로 바꿔주세요.\n\n**단계 4:** 모노레포 구성\nTurboRepo는 모노레포의 빌드 및 작업 구성을 정의하기 위해 turbo.json 파일을 사용합니다. turbo.json 파일을 열고 pipeline 섹션을 업데이트하여 Next.js 앱을 포함하도록 설정하세요:\n\n\n\n```json\n{\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\".next/**\"]\n    },\n    \"dev\": {\n      \"cache\": false\n    },\n    \"start\": {},\n    \"lint\": {\n      \"outputs\": []\n    },\n    \"test\": {\n      \"outputs\": []\n    }\n  },\n  \"globalDependencies\": {\n    \"my-next-app\": []\n  }\n}\n```\n\nStep 5: 이제 Next.js 앱을 실행하세요. Next.js 앱이 모노레포에 설정되었으므로 다음 명령어를 사용하여 실행할 수 있습니다:\n\n```json\nnpm run dev --filter=my-next-app\n```\n\nmy-next-app를 여러분의 Next.js 앱의 이름으로 바꿔주세요.\n\n\n\n이 기사에서는 Next.js를 사용한 모노 레포의 장점을 탐색하고, Turborepo를 사용하여 설정하는 방법에 대한 단계별 가이드를 제공했습니다. 모노 레포를 활용하면 의존성 관리를 간소화하고, 코드 재사용성을 향상시키며, 개발을 간소화하고, 팀 간 협업을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringNextjsMonoreposAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"실시간 알림 React에서 종류 및 구현","description":"","date":"2024-05-12 21:11","slug":"2024-05-12-Real-TimeNotificationsinReactTypesandImplementations","content":"\n\n![Real-Time Notifications in React: Types and Implementations](/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png)\n\n## 소개:\n\n실시간 알림은 웹 애플리케이션에서 사용자 참여를 촉진하고 적시에 업데이트를 제공하는 데 중요한 역할을 합니다. 이 안내서에서는 React 애플리케이션에서 다양한 유형의 실시간 알림과 그 구현을 탐색할 것입니다. Firebase 알림, One Signal 및 SignalR을 비롯한 많은 알림 라이브러리들이 있지만, 지금은 WebSocket, Server-Sent Events (SSE) 및 Push Notifications을 사용할 것입니다.\n\n## 실시간 알림의 유형:\n\n\n\n- WebSocket 통지: WebSocket은 클라이언트와 서버 간의 실시간 데이터 전송을 가능하게 하는 단일 TCP 연결 상에서 전이중(duplex) 통신 채널을 제공하는 통신 프로토콜입니다. 웹소켓 통지는 양방향 통신과 즉각적인 업데이트가 필요한 애플리케이션에 이상적입니다.\n- 서버 보낸 이벤트(SSE): 서버 보낸 이벤트(SSE)는 단일 HTTP 연결 상에서 서버로부터 클라이언트로의 스트리밍 업데이트를 위한 표준입니다. SSE 알림은 단방향적이며, 데이터가 서버에서 클라이언트로 흐릅니다. 서버가 클라이언트로부터 시작되는 요청 없이 업데이트를 푸시해야 하는 애플리케이션에 적합합니다.\n- 푸시 통지: 푸시 통지를 사용하면 웹 애플리케이션이 브라우저에서 열려 있지 않을 때에도 실시간 통지를 사용자에게 전달할 수 있습니다. 푸시 통지는 서버에서 사용자 기기로 서비스 작업자를 통해 전송되어, 시기 적절한 업데이트로 사용자 경험을 원활하게 만들고 사용자에게 다시 관심을 유도합니다.\n\n## React에서 구현:\n\nReact 애플리케이션에서 각 유형의 실시간 통지를 구현하는 방법을 살펴봅시다.\n\n\n\nReact에서 WebSocket 알림을 사용하려면 socket.io-client와 같은 라이브러리를 사용하여 서버와 WebSocket 연결을 설정하고 실시간 업데이트를 수신할 수 있습니다.\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport io from 'socket.io-client';\n\nconst NotificationsComponent = () =\u003e {\n  const [notification, setNotification] = useState('');\n  useEffect(() =\u003e {\n    const socket = io('http://localhost:5000');\n    socket.on('notification', (data) =\u003e {\n      setNotification(data.message);\n    });\n    return () =\u003e {\n      socket.disconnect();\n    };\n  }, []);\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eWebSocket 알림:\u003c/h2\u003e\n      \u003cp\u003e{notification}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default NotificationsComponent;\n```\n\n## Server-Sent Events (SSE):\n\nReact는 EventSource API를 통해 Server-Sent Events를 지원합니다. EventSource 객체를 사용하여 서버와 연결을 설정하고 업데이트를 수신할 수 있습니다.\n\n\n\n```js\nimport React, { useEffect, useState } from 'react';\n\nconst NotificationsComponent = () =\u003e {\n  const [notification, setNotification] = useState('');\n  useEffect(() =\u003e {\n    const eventSource = new EventSource('http://localhost:5000/notifications');\n    eventSource.onmessage = (event) =\u003e {\n      setNotification(event.data);\n    };\n    return () =\u003e {\n      eventSource.close();\n    };\n  }, []);\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eServer-Sent Events (SSE) Notifications:\u003c/h2\u003e\n      \u003cp\u003e{notification}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default NotificationsComponent;\n```\n\n## 푸시 알림:\n\nReact에서 푸시 알림을 사용하려면 서비스 워커를 구현하여 들어오는 푸시 이벤트를 처리하고 사용자에게 알림을 표시해야 합니다.\n\n```js\n// 서비스 워커 파일 (sw.js)\nself.addEventListener('push', function(event) {\n  const data = event.data.json();\n  const title = '새 알림';\n  const options = {\n    body: data.message,\n    icon: '아이콘/이미지/경로.png',\n  };\n\nevent.waitUntil(\n    self.registration.showNotification(title, options)\n  );\n});\n```\n\n\n\nReact 컴포넌트에서 서비스 워커를 등록하고 푸시 알림을 위해 Notification API를 사용하는 방법을 설명했습니다.\n\n## 결론:\n\n실시간 알림은 웹 애플리케이션 사용자를 정보를 제공하고 참여시키는 데 중요합니다. 이 안내서에서 WebSocket, Server-Sent Events (SSE), 및 푸시 알림 세 가지 유형의 실시간 알림을 탐색하고 React 애플리케이션에서 구현하는 방법을 안내했습니다. 실시간 알림을 통합함으로써 사용자 경험을 향상시키고 적시에 업데이트를 제공하여 React 애플리케이션의 성공에 기여할 수 있습니다. 즐거운 학습과 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png"},"coverImage":"/assets/img/2024-05-12-Real-TimeNotificationsinReactTypesandImplementations_0.png","tag":["Tech"],"readingTime":4},{"title":"오픈 소스로부터 배운 JavaScript의 제너레이터 함수 팁","description":"","date":"2024-05-12 21:10","slug":"2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript","content":"\n\nNext.js 소스 코드를 읽다가 *로 접두사가 붙은 함수 이름을 본 적이 있어요. 제 첫 생각은 \"이거 Javascript에서 포인터인가?\" 였어요. 구글 검색을 해보니 *로 접두사가 붙은 이 함수들은 제너레이터 함수라고 불린다는 걸 알았어요. 지금까지는 Javascript에서 제너레이터 함수에 대해 알지 못했어요.\n\nNext.js 소스 코드에는 아래와 같이 클래스 내에서 정의된 제너레이터 함수가 있어요:\n\n![이미지](/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png)\n\n일반적으로 이런 제너레이터 함수를 클래스 바깥에서 정의할 때는 다음과 같은 구문을 사용해요:\n\n\n\n```js\n// 출처: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\nfunction* generator(i) {\n  yield i;\n  yield i + 10;\n  yield i + 20;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\n// 예상 출력: 10\nconsole.log(gen.next().value);\n// 예상 출력: 20\nconsole.log(gen.next().value);\r\n```\n\n# Keys() as a generator function\n\n```js\npublic *keys(): IterableIterator\u003cstring\u003e {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n```\n\n이 코드 스니펫은 Next.js 소스 코드의 header.ts에서 가져온 것입니다. \"keys() 함수가 제너레이터 함수인 이유는 무엇일까?\" 라는 질문을 내 자신에게 했습니다.\n\n\n\n저는 ChatGPT에 이 코드를 붙여 넣었더니 \"메모리 효율성\"이라는 용어를 소개해 주었어요. 잠깐만, 어떻게 그런 걸까요?\n\n아래 코드를 복사해서 브라우저에 붙여넣어 보세요.\n\n```js\nconst exampleObject = {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  age: 30\n};\n\n// 제너레이터 함수를 사용하여 keys() 메서드 구현하기\nexampleObject.keys = function* () {\n  for (const key in this) {\n    yield key;\n  }\n};\n\n// 이제 exampleObject의 키를 for...of 루프를 사용하여 반복할 수 있습니다.\nfor (const key of exampleObject.keys()) {\n  console.log(key);\n}\n\n// 결과:\nfirstName\nVM247:16 lastName\nVM247:16 age\nVM247:16 keys\n```\n\n하지만 keys()를 출력하려고 하면 다음과 같은 결과가 나타납니다:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_1.png\" /\u003e\n\n한 번에 모든 키를 생성하고 배열에 저장하는 대신, 제너레이터 함수는 필요할 때 키를 즉석에서 생성합니다.\n\n# 더 많은 읽을거리 링크:\n\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*\n- https://stackoverflow.com/questions/47027191/do-suspended-generator-functions-have-performance-costs\n\n\n\n# 결론:\n\n`function* keys()`은 포인터가 아닌 제너레이터 함수임을 알게 되었습니다. 원하는 시점에 키, 엔트리, 값 등을 생성할 때 사용합니다.\n\n제너레이터 함수는 실행 시간을 소비하지 않으며 사용될 때까지 메모리에 남아 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png"},"coverImage":"/assets/img/2024-05-12-Tipsfromopen-sourceGeneratorfunctioninJavascript_0.png","tag":["Tech"],"readingTime":3},{"title":"React 19 다가오는 변화에 대비하세요","description":"","date":"2024-05-12 21:09","slug":"2024-05-12-React19GetReadyForWhatsComing","content":"\n\n![React 19](/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png)\n\n리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.\n\n## 리액트 컴파일러: 리액트 핵심 최적화\n\n오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.\n\n\n\n그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.\n\nReact 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:\n\n```js\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =\u003e {\n    setCount(count + 1);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={handleClick}\u003eIncrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nReact 컴파일러 없이 count 상태를 업데이트하면 `button` 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 `p` 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.\n\n\n\n## 작업: 데이터 처리 간소화\n\n리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.\n\nActions를 사용하면 `form`과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport React from 'react';\n\nfunction SearchForm({ action }) {\n  return (\n    \u003cform action={action}\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003e검색\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n\nfunction App() {\n  const search = async (data) =\u003e {\n    const response = await fetch(`/api/search?q=${data.query}`);\n    const results = await response.json();\n    // 검색 결과로 UI 업데이트\n  };\n\n  return \u003cSearchForm action={search} /\u003e;\n}\n```\n\n\n\n이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.\n\n액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 `use server` 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.\n\n기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.\n\n액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.\n\n\n\n## React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.\n\nReact 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.\n\nRSC를 사용하면 개발자는 `use server` 지시어를 사용하여 특정 구성 요소를 \"서버\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.\n\n다음은 RSC를 사용하는 예시입니다:\n\n\n\n```jsx\n// PostContent.server.jsx\nimport React, { useState, useEffect } from 'react';\nimport fetchPost from './fetchPost';\n\nexport default async function PostContent({ id }) {\n  const [post, setPost] = useState(null);\n\n  useEffect(() =\u003e {\n    const fetchPostData = async () =\u003e {\n      const postData = await fetchPost(id);\n      setPost(postData);\n    };\n    fetchPostData();\n  }, [id]);\n\n  if (!post) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{post.title}\u003c/h1\u003e\n      \u003cp\u003e{post.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.\n\nRSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.\n\n## 리액트 개발의 미래를 받아들이기\n\n\n\nReact 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.\n\n출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React\n\n# 평문으로 간단히 🚀\n\nIn Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요! 👏\r\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\r\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\r\n- 알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\r\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png"},"coverImage":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 19의 새로운 기능 - 새로운 리액트 훅","description":"","date":"2024-05-12 21:07","slug":"2024-05-12-NewFeaturesinReact19NewReactHooks","content":"\n\n🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png)\n\n안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!\n\nReact Hooks의 진화:\n\n\n\n리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.\n\n리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.\n\nuseMemo()로 간단한 메모이제이션:\n\n주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:\n\n\n\nReact 19 이전:\n\n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  // 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다\n  const isInputEmpty = useMemo(() =\u003e {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  }, [inputValue]);\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) =\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cp\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ExampleComponent;\n```\n\nReact 19 이후:\n\n```js\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  const isInputEmpty = () =\u003e {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) =\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cp\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ExampleComponent;\n```\n\n\n\n아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.\n\nforwardRef()로 리팩터링:\n\nReact 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:\n\n```js\n// React 19 이전\nconst ExampleButton = forwardRef((props, ref) =\u003e (\n  \u003cbutton ref={ref}\u003e\n    {props.children}\n  \u003c/button\u003e\n));\n\n// React 19 이후\nconst ExampleButton = ({ ref, children }) =\u003e (\n  \u003cbutton ref={ref}\u003e\n    {children}\n  \u003c/button\u003e\n);\n```\n\n\n\n새로운 'use' Hook을 소개합니다:\n\nReact 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:\n\n```js\nconst users = use(fetchUsers());\n```\n\n'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.\n\n\n\n아래 코드는 fetch 요청이 ne \"use\" 훅과 함께 처리되는 방법을 보여줍니다.\n\n```js\nimport { use } from \"react\";\n\nconst fetchUsers = async () =\u003e {\n    const res = await fetch('https://jsonplaceholder.typicode.com/users');\n    return res.json();\n};\n\nconst UsersItems = () =\u003e {\n    const users = use(fetchUsers());\n\n    return (\n        \u003cul\u003e\n            {users.map((user) =\u003e (\n                \u003cdiv key={user.id} className='bg-blue-50 p-2 my-4 rounded-lg'\u003e\n                    \u003ch2 className='text-xl font-bold'\u003e{user.name}\u003c/h2\u003e\n                    \u003cp\u003e{user.email}\u003c/p\u003e\n                \u003c/div\u003e\n            ))}\n        \u003c/ul\u003e\n    );\n};\n\nexport default UsersItems;\n```\n\n이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.\nuse 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.\nuseState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.\nreturn 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.\n\n새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하세요.\n\n\n\n두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.\n\n\n\n```js\nconst { status } = useFormStatus()\n```\n\npending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.\ndata: parent `form`이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.\nmethod: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.\naction: 함수 참조\n\nuseFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.\n\n다음은 코드 예시입니다:\n\n\n\n```js\nimport { useFormStatus } from \"react-dom\";\n\nfunction Submit() {\n  const status = useFormStatus();\n  return \u003cbutton disabled={status.pending}\u003e{status.pending ? '제출 중...' : '제출'}\u003c/button\u003e;\n}\n\nconst formAction = async () =\u003e {\n  // 2초 지연 시뮬레이션\n  await new Promise((resolve) =\u003e setTimeout(resolve, 3000));\n}\n\nconst FormStatus = () =\u003e {\n  return (\n    \u003cform action={formAction}\u003e\n      \u003cSubmit /\u003e\n    \u003c/form\u003e\n  );\n};\n\nexport default FormStatus;\n```\n\n위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 \"제출 중...\"이라는 텍스트가 표시됩니다. 보류가 false가 되면 \"제출\"으로 텍스트가 변경됩니다.\n\nuseFormState() 훅\n\nuseFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:\n\n\n\n\n여기가 문법입니다:\n\n```js\nconst [state, formAction] = useFormState(fn, initialState, permalink?);\n```\n\nfn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.\ninitialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.\npermalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.\n\n이 훅은 반환할 것입니다:\n\n\n\n초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.\nformAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.\n\nuseFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.\n\nuseOptimistic() 훅:\n\nuseOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.\n\n\n\n여기 문법이에요:\n\n```js\nconst [ optimisticMessage, addOptimisticMessage] = useOptimistic(state, updatefn)\n```\n\n예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 \"상태\"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 \"낙관적\" 상태가 그것으로 대체될 거예요.\n\n`useOptimistic` 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 \"낙관적\"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.\n\n\n\nuseOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.\n\n다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀\n\n관련 링크\n\nReact 19의 새로운 기능\n\n\n\nReact 19의 새로운 기능 — React 컴파일러\n\nReact 19의 새로운 기능 — 서버 컴포넌트\n\nReact 19의 새로운 기능 — 액션\n\nReact 19의 새로운 기능 — 웹 컴포넌트\n\n\n\nReact 19의 새로운 기능 — 문서 메타데이터\n\nReact 19의 새로운 기능 — 자산 로딩","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png","tag":["Tech"],"readingTime":7},{"title":"12부 setTimeout  클로저 인터뷰 문제 ","description":"","date":"2024-05-12 21:06","slug":"2024-05-12-Part12setTimeoutClosuresInterviewQuestions","content":"\n\n# 사전 준비 사항:\n\n만약 클로저(Closures) 개념이 잘 이해되지 않는다면, 아래 내용을 꼭 읽어보세요:\n\n- Part 11: 자바스크립트(JS)에서의 클로저(Closures) 🤷🏻‍♀️\n\n![이미지](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png)\n\n\n\n## 이 프로그램을 실행하면 콘솔에서 무엇을 기대하시나요?\n\n출력:\n\n![Output](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_1.png)\n\n1초 후에 i의 값인 1이 출력됩니다.\n\n\n\n아래와 같이 시간 초가 지난 후 출력이 됩니다.\n\nsetTimeout()을 사용하면 3초 후에 i를 출력한 다음 \"Learn\"을 출력할 것으로 생각할 수 있습니다. 하지만, 그렇지 않습니다. \"Learn\"을 먼저 출력하고 3초를 기다린 후 i의 값을 출력할 것입니다.\n\n## setTimeout()이 실제로 하는 일은 무엇인가요?\n\n- 3줄에서, function ()이 클로저를 형성합니다. 이 함수는 i에 대한 참조를 기억합니다.\n- setTimeout()은 해당 콜백 함수를 실행하고 어딘가에 저장하고 타이머를 부착합니다. JS는 다음 줄로 진행합니다.\n- 타이머가 만료되면 해당 함수를 가져와서 호출 스택에 넣고 실행합니다.\n\n\n\n다음은 복잡한 문제의 예를 살펴보겠습니다.\n\n## 콘솔에 1부터 10까지의 숫자를 매 초마다 출력하려고 합니다. 즉, 1초 후에 1을, 2초 후에 2를, 그리고 3초 후에 3을 출력하는 방식입니다. 이를 어떻게 해결할 수 있을까요?\n\n첫 번째 떠오르는 해결책은 for 루프를 사용하고 그 안에 setTimeout()을 넣는 것입니다. 아래와 같이 말이죠?\n\n이제 결과를 확인해 보겠습니다:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_2.png\" /\u003e\n\n이건 우리가 기대했던 것과 다릅니다. 왜 그런 건가요? 무슨 일이 있었나요? 🧐\n\n두 가지 이유가 있어요:\n\n1. 우리는 클로저가 함수와 그 렉시컬 환경이 어떻게 동작하는지 배웠거든. 그래서 함수가 자신의 원래 범위에서 벗어나더라도 여전히 자신의 원래 범위를 기억할 거에요. 클로저는 렉시컬 범위의 변수에 접근할 수 있어요.\n\n\n\n그래서 setTimeout()이 이 함수를 취하고 어딘가에 저장하고 타임아웃을 부착하면, i에 대한 참조를 기억합니다.\n\n따라서 루프가 처음 실행될 때, 함수의 복사본을 만들어 타이머를 부착하고 i에 대한 참조를 기억합니다.\n\n마찬가지로, 모든 10개의 함수 복사본은 i에 대한 참조를 기억하고 있으며, 값이 아닙니다. 그리고 모두 같은 i에 대한 참조를 가리키고 있습니다.\n\n## 왜 젠장 같은 i에 대한 참조를 가리키고 있는 걸까요? 😳\n\n\n\n모든 이러한 기능들의 환경은 같기 때문이에요. setTimeout()의 콜백 함수 복사본들은 모두 같은 메모리 공간에서 i를 참조하고 있어요. 🤷🏻‍♀️\n\n2. JS는 아무것도 기다리지 않아요. 그래서 루프가 계속 실행될 거예요 🔄. 그래서 setTimeout()은 모든 10개의 함수를 저장하고 JS는 계속 진행할 거예요. JS는 타이머가 만료되기를 기다리지 않아요. \"Learn\"을 출력하고, 타이머가 만료되면 이미 너무 늦어요. 이제 i의 값이 변경되었어요. 왜냐하면 루프가 계속 실행되었으니까요. 이 콜백 함수가 실행될 때에는 이미 메모리 위치에 var i = 11의 값이 되어 있어요.\n\n그래서 매번 11이 출력되는 거죠 🤷🏻‍♀️. 왜냐하면 이러한 콜백 함수 복사본들이 모두 같은 메모리 위치를 참조하기 때문이에요 🤦🏻‍♀️. 해당 위치는 이제 10번 실행되었고 루프에서 값이 1씩 증가했기 때문에 11이 되었답니다 🙄.\n\n## 이제, 어떻게 이 문제를 해결할 수 있을까요? 💡💡\n\n\n\nlet 대신 var 대신 사용하세요. 왜냐하면 let은 블록 범위를 가지고 있기 때문에 각각의 반복에서 i는 매번 새로운 변수가 됩니다. 메모리에는 매번 i의 새 복사본이 있습니다. \n\nsetTimeout()이 실행될 때, 콜백 함수는 새로운 i의 복사본을 가질 것입니다. \n\n실행해보고 결과를 확인해봅시다:\n\n\u003cimg src=\"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_3.png\" /\u003e\n\n잘 작동했어요 🎉🎉\n\n\n\n## 다시 한 번 수정해 봅시다. let 키워드 때문에 실제로 일어난 일에 대해:\n\n1. i = 1로 시작한 루프에서, 함수가 자체적으로 새 변수와 클로저를 형성했습니다.\n2. i++ 이후에 함수가 다시 클로저를 형성했을 때, 값이 2인 새 변수를 가지고 있으며 이를 저장했습니다.\n3. 이런 식으로 계속 진행됩니다. 이렇게 하면 변수 i의 10개의 복사본을 만들어 각 함수마다 클로저를 형성합니다.\n\n## 그래서, 다음에 누군가 아래 두 경우의 출력 차이와 그 이유에 대해 물으면? 당신은 답을 알고 있습니다 😎\n\n## 경우 1:\n\n\n\n```js\nfunction x(){\n  for (var i = 1; i \u003c= 10; i++){  // 이 부분에서 var을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\n## Case 2:\n\n```js\nfunction x(){\n  for (let i = 1; i \u003c= 10; i++){  // 이 부분에서 let을 사용했어요 \n    setTimeout(function (){\n    console.log(i);\n    }, i * 1000);\n  }\n  console.log(\"배워요\")\n}\nx();\r\n```\n\nAnswer: let은 블록 스코프이며 루프가 실행될 때마다 매번 새로운 복사본을 생성합니다.\n\n\n\n## 다시 뒤로 돌아가기 🤭: 만약 var만 사용하고 매 초 1,2,3,..10을 출력해야 한다면 어떻게 해야 할까요? \n\n조금만 생각해 보세요. 어떤 해결책이 될 수 있을까요?\n요령은 매번 변수 i의 새 복사본을 만들어야 한다는 것입니다.\n\n그래서, 새로운 함수 close()를 만들고 그 안에 setTimeout()을 랩핑합니다. 그리고 호출할 때마다 i를 전달합니다.\n\n## 왜 이 방법이 동작할까요? 😬\n\n\n\n매번 i와 함께 close() 함수를 호출할 때마다 setTimeout()을 위한 새로운 i 복사본이 생성된다고 해요 😎.\n\n그게 전부에요. setTimeout()이 어떻게 작동하는지와 클로저랑 어떻게 연관되는지 다루었어요. 👏🏼\n\n## 다음 👩🏻‍🏫 ⏭️ : 제13부 : 클로저 JS 인터뷰 질문들 🤯\n\n이 기사를 읽어 주셔서 감사합니다 ❤️\n\n\n\n# ⭐️ 즐겁게 코딩해요. ⭐️\n\n오늘 무엇인가를 배웠으면 좋겠네요! 떠나시기 전에:\n\n- 👏 스와티 레드후를 따르고 스토리에 박수를 보내주세요 👩🏻‍💻\n- 📰 2023 자바스크립트 학습 로드맵에서 더 많은 콘텐츠를 확인해보세요 — 최고의 안내서 ❤️\n- 🔔 LinkedIn을 팔로우해주세요\n\n🚀👉 자바스크립트 기본을 확실히 다지고 멋진 직장을 찾아보세요","ogImage":{"url":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png","tag":["Tech"],"readingTime":4},{"title":"React에서 Axios를 사용하여 중앙 집중식 API 클라이언트 파일 만들기","description":"","date":"2024-05-12 21:05","slug":"2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios","content":"\n\n리액트 애플리케이션을 구축할 때 API와 상호 작용하는 경우, API 호출을 처리하는 깔끔하고 조직화된 방식을 유지하는 것이 중요합니다. 이를 달성하는 효과적인 방법 중 하나는 중앙 집중식 API 클라이언트 파일을 생성하는 것입니다. 이 튜토리얼에서는 Axios를 사용하여 이러한 파일을 구조화하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png)\n\n# API 호출을 중앙 집중화하는 이유\n\nAPI 호출을 중앙 집중화하는 것에는 여러 가지 이점이 있습니다:\n\n\n\n- 모듈성: API 로직을 하나의 파일로 분리함으로써 응용 프로그램 전반에 걸쳐 모듈성과 재사용성을 촉진합니다.\n- 조직화: 모든 API 관련 코드가 하나의 파일에 포함되어 있어 관리하고 유지하는 것이 더 쉬워집니다.\n- 일관성: 일반적인 설정 및 오류 처리 전략을 한 곳에 정의함으로써 응용 프로그램 전체에서 일관성을 보장할 수 있습니다.\n\n# Axios 설정하기\n\n먼저 프로젝트에 Axios가 설치되어 있는지 확인하세요. npm이나 yarn을 통해 설치할 수 있습니다:\n\n```js\nnpm install axios\n# 또는\nyarn add axios\n```\n\n\n\n# API 클라이언트 파일 만들기\n\nAPI 호출을 처리할 apiClient.js 파일을 생성해 봅시다:\n\n```js\n// apiClient.js\n\nimport axios from 'axios';\n\nconst BASE_URL = process.env.REACT_APP_BASE_URL || 'https://api.example.com';\n\nconst apiClient = axios.create({\n  baseURL: BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n    // 여기에 인증 토큰과 같은 다른 헤더를 추가할 수 있습니다\n  },\n});\n\n// 공통 API 메서드 정의\nconst _get = (url, config = {}) =\u003e {\n  return apiClient.get(url, config);\n};\n\nconst _delete = (url, config = {}) =\u003e {\n  return apiClient.delete(url, config);\n};\n\nconst _put = (url, data = {}, config = {}) =\u003e {\n  return apiClient.put(url, data, config);\n};\n\nconst _post = (url, data = {}, config = {}) =\u003e {\n  return apiClient.post(url, data, config);\n};\n\n// API 메서드 내보내기\nexport { _get, _delete, _put, _post };t api;\n```\n\n위 파일에서:\n\n\n\n- Axios 인스턴스를 생성하여 기본 URL과 기본 헤더를 설정합니다.\n- 각 엔드포인트에 해당하는 다양한 API 기능을 정의합니다.\n\n환경 변수 설정: 먼저, 각 환경에 맞게 환경 변수를 설정해야 합니다. 일반적으로 각 환경에 대한 .env 파일을 생성하여 이 작업을 수행할 수 있습니다. 예를 들어:\n\n- .env.development: 개발 환경을 위한 변수를 포함합니다.\n- .env.qa: QA 환경을 위한 변수를 포함합니다.\n- .env.staging: 스테이징 환경을 위한 변수를 포함합니다.\n- .env.production: 프로덕션 환경을 위한 변수를 포함합니다.\n\n각 .env 파일 내에서 기본 URL을 정의하세요.\n\n\n\nREACT_APP_BASE_URL=https://api.example.com\n\n- 다른 환경에 접속하기: 환경에 따라 (예: 개발, QA, 스테이징) React는 자동으로 해당 .env 파일을로드하고 BASE_URL이 그에 맞게 설정됩니다.\n\n예를 들어, 개발 중일 때 React는 .env.development를로드하고 BASE_URL이 해당 파일에 지정된 값으로 설정됩니다.\n\n마찬가지로 다른 환경 (예: QA, 스테이징)에서도 React는 해당 .env 파일을로드합니다.\n\n\n\n2. React 컴포넌트에서의 사용법: 이전 예시에서 보았던 것처럼 React 컴포넌트에서 api 객체를 계속 사용할 수 있습니다. 기본 URL은 환경에 따라 동적으로 결정됩니다.\n\n이 설정을 사용하면 다른 환경에 대해 쉽게 다른 기본 URL을 관리할 수 있어 React 애플리케이션이 실행 중인 환경에 따라 적절한 백엔드와 통신할 수 있도록 보장합니다.\n\n# 컴포넌트에서 API 클라이언트 사용하기\n\n이제 React 컴포넌트에서 이 API 클라이언트를 사용하는 방법을 살펴보겠습니다:\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { _get, _post, _put, _delete } from './apiClient'; // 필요에 따라 경로를 조정하세요\n\nfunction ExampleComponent() {\n  const [data, setData] = useState([]);\n\n  useEffect(() =\u003e {\n    // 컴포넌트가 마운트될 때 데이터 가져오기\n    fetchData();\n  }, []);\n\n  const fetchData = async () =\u003e {\n    try {\n      const response = await _get('/data', { headers: { Authorization: 'Bearer 여기에 토큰 입력' } });\n      setData(response.data);\n    } catch (error) {\n      console.error('데이터를 가져오는 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const addData = async () =\u003e {\n    try {\n      const newData = { name: '새 데이터' };\n      await _post('/data', newData);\n      fetchData(); // 추가 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 추가 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const updateData = async (id, updatedData) =\u003e {\n    try {\n      await _put(`/data/${id}`, updatedData);\n      fetchData(); // 업데이트 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 업데이트 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  const deleteData = async (id) =\u003e {\n    try {\n      await _delete(`/data/${id}`);\n      fetchData(); // 삭제 후 데이터 새로고침\n    } catch (error) {\n      console.error('데이터 삭제 중 오류 발생:', error);\n      // 에러 처리\n    }\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e예시 컴포넌트\u003c/h1\u003e\n      \u003cbutton onClick={addData}\u003e데이터 추가\u003c/button\u003e\n      \u003cul\u003e\n        {data.map(item =\u003e (\n          \u003cli key={item.id}\u003e\n            {item.name}\n            \u003cbutton onClick={() =\u003e updateData(item.id, { name: '업데이트된 아이템' })}\u003e업데이트\u003c/button\u003e\n            \u003cbutton onClick={() =\u003e deleteData(item.id)}\u003e삭제\u003c/button\u003e\n          \u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ExampleComponent;\n```\n\nAxios에서 config 매개변수를 사용하면 HTTP 요청에 대한 추가 구성을 전달할 수 있습니다. 일반적으로 사용되는 구성에는 헤더, 쿼리 매개변수, 요청 시간 초과, 인증 토큰 등이 있습니다.\n\n참고: axios.create()로 Axios 인스턴스를 만들 때 baseURL 옵션을 BASE_URL로 설정합니다. 이렇게 하면 이 Axios 인스턴스로 작성된 모든 요청에 기본 URL이 URL에 접두사로 붙습니다.\n\n예를 들어, ExampleComponent에서 _get(`/data`)를 호출하면 Axios는 `https://api.example.com/data`로 GET 요청을 보냅니다.\n\n\n\n# 결론\n\nAxios를 사용하여 React 애플리케이션에서 API 호출을 중앙화하는 것은 API 로직을 관리하기 위한 깔끔하고 조직된 방법을 제공합니다. 중앙 집중화된 API 클라이언트 파일을 만들면 코드베이스에서 모듈화, 조직화 및 일관성을 달성할 수 있습니다. 이 방법을 통해 유지 보수가 간단해지며 애플리케이션 전체에서 코드 재사용을 장려합니다.\n\n오늘부터 API 호출을 조직화하고 React 프로젝트에 가져다 주는 혜택을 경험해보세요!","ogImage":{"url":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaCentralizedAPIClientFileinReactwithAxios_0.png","tag":["Tech"],"readingTime":5}],"page":"131","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"131"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>