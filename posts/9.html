<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/9" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/9" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="디자인 시스템에서 공간 활용하는 방법" href="/post/2024-06-23-SpaceinDesignSystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 시스템에서 공간 활용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SpaceinDesignSystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 시스템에서 공간 활용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디자인 시스템에서 공간 활용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="완벽한 코드 블로그를 만드는 방법" href="/post/2024-06-23-Howtocreatetheperfectcodeblog"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="완벽한 코드 블로그를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Howtocreatetheperfectcodeblog_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="완벽한 코드 블로그를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">완벽한 코드 블로그를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Tailwind Signals로 UI 강화하기 설정 및 예제" href="/post/2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Tailwind Signals로 UI 강화하기 설정 및 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Tailwind Signals로 UI 강화하기 설정 및 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Tailwind Signals로 UI 강화하기 설정 및 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석" href="/post/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법" href="/post/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기" href="/post/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 Command 패턴 소개" href="/post/2024-06-23-IntroductiontoCommandPatterninAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 Command 패턴 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 Command 패턴 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 Command 패턴 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 꼭 알아야 할 RxJS 연산자들" href="/post/2024-06-23-RxJSOperatorsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 꼭 알아야 할 RxJS 연산자들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 꼭 알아야 할 RxJS 연산자들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 꼭 알아야 할 RxJS 연산자들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" href="/post/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular Reactive Forms setValue와 patchValue 함수 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" href="/post/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link posts_-active__YVJEi" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"디자인 시스템에서 공간 활용하는 방법","description":"","date":"2024-06-23 14:20","slug":"2024-06-23-SpaceinDesignSystems","content":"\n\n## 기본 개념부터 공간을 의도적으로 적용하는 확장 컨셉으로\n\n시스템의 시각적 언어에 대해 오래 전부터 Color, Type 및 Icons를 \"Big 3\"로 참조해왔습니다. 모든 UI 구성 요소 — 버튼부터 시작 — 는 이들과 함께 구축됩니다. 하지만 뭔가를 잊고 있었습니다. 공간, 우리의 최종 터전.\n\n## 공간이 색에 미치는 영향\n\n공간은 어디에나 존재합니다. CSS는 패딩, 마진, 절대 위치 지정의 좌측, 우측, 상단 및 하단과 같은 속성을 사용하여 객체를 분리합니다. 부트스트랩, Salesforce Lightning, Foundation, 이전 프로젝트 및 현재 프로젝트라는 다섯 개의 라이브러리에서, 이런 공간 속성이 색, 크기, 타입, 레이아웃 및 기타 속성 그룹에 비해 얼마나 자주 나타나는지 비교해보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS에서 이미 결정 시스템을 제공하고 있는 영향(예:0으로 지정된 값 또는 투명 또는 자동과 같은 예약 용어)을 제거한 후, 공간 규칙은 색상을 제외하고 다른 모든 것보다 더 많이 나타났습니다. 다른 것들은 전혀 아니었습니다. 글꼴, 크기, 레이아웃 등이 가까이에 있었던 적도 없었습니다. 우리 라이브러리에는 공간에 내재된 복잡성이 너무 많이 포함되어 있습니다. 그랬다고 하지도 않아도 제품에 어디에큐브의 공간적 복잡성은 너무 많이 포함되어 있습니다ㅠ\n\n## 공간은 우리를 나눕니다\n\n공간은 디자인과 개발 사이의 \"나는 이렇게 디자인했는데, 당신은 저렇게 만들었다\"라는 격차를 대표합니다. 우리는 오랫동안 디자인에 뿌려진 빨간색 가이드 스펙을 슬퍼했습니다. 그것은 절대로 그렇게 할 가치가 없는 것 같았습니다. 그럼에도 불구하고 그것들은 우리 제품의 완성된 재료인 HTML의 박스 모델에 의해 정보 없이 여전히 지속됩니다.\n\n비용이 막대합니다: 주석 달기, 번역하기, QA 중에 시각적으로 정제된 내용을 논의하기. 그 모든 작업... 여전히 충분하지 않은 것을 위해. 따라서 공간은 감정적인 대가를 냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 공간 개념은 기본적이에요\n\n디자인, 코드 및 대화를 통해 더 의도적인 공간 개념을 연결할 수 있어요. 하지만 그렇게 하지 않아요. 우리는 그냥 티셔츠 사이즈를 사용하고 하루를 마무리해요. 더 나은 방법이 있어요. 우리는 미래적 공간의 명확성을 향해 들이따, 눌렀다, 늘렸다, 쌓아가며 붉은 선이어터 붉은 얼굴의 분노를 대체할 수 있어요.\n\n그런 의미에서, 시스템 작업에 공간을 적용할 때 제가 경험한 기본 원리, 확장된 어휘 및 추가 경험을 소개해드릴게요.\n\n# 공간 기본 원리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그리드 ≠ 공간. 그리드는 컴포넌트이며, 공간을 활용합니다.\n\n그리드는 열, 거터, 외부 여백 및 반응형 뉴안스에 대한 공간 결정이 풍부합니다. 팀은 사용자가 쉽게 페이지를 만들 수 있도록 미리 그리드를 사용합니다. 유감스럽게도, 그것이 종종 공간 대화가 종료되는 시점입니다.\n\n그리드는 완전한 공간 시스템이 아닙니다. 그리드는 다른 모든 컴포넌트와 마찬가지로 공간을 활용하는 컴포넌트입니다. 그리드는 다른 느낌이 납니다. 보이지 않으며 빠르게 나오며 공간만 처리합니다. 그러나 공간은 그리드 이상입니다.\n\n결론: 그리드를 활용하여 공간 규칙을 도입하지만 거기서 멈추지 마십시오. 그리드의 여백, 거터 및 열 값은 전체 컴포넌트 라이브러리에 깊게 섞인 더 깊은 공간 개념과 일치시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기억에 남는 기본 숫자 선택하기 \u0026 기대치 설정하기\n\n팀은 다른 공간 값들을 기준으로 잡을 수 있는 기억에 남는 숫자를 선택합니다. 어떤 팀은 손가락으로 세는 방법에 따라 10진수를 선호합니다. 누군가는 2와 3의 도움이 되는 요인을 갖는 6진수를 사용하여 3, 4, 6, 8, 9, 12, 15, 16, 18, 21, 24, 32 등 다양한 숫자를 유연하게 사용하기도 했습니다. 너무 심각해지지 마세요!\n\n저는 지금까지 다양한 시스템들이 16을 사용하는 것을 보았습니다. 이는 기본 글꼴 크기로서 좋은 선택입니다. 이는 모든 화면 해상도(320, 768, 1024)의 배수이며, 시작점보다 크고(32, 64, ...) 시작점보다 작은 요인(8, 4, 2)을 제공합니다.\n\n요점: 기억에 남는 기본 숫자를 선택하여 공간 시스템의 범위를 설정하고 사용 방법에 대한 기대치를 제한하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비선형적인 비율 조정 옵션\n\n기존의 기반을 확립한 후에도 팀은 무작위 단계로 빠질 수 있습니다(12, 14, 18, 22, 24, 28, 30, 32, …). 이를 방지하기 위해 다른 사람들은 각 단계가 일정한 증분인 선형 척도(4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, …)를 사용합니다. 나에게는 어느 결과든 예측하기 어렵게 사용되며, 너무 가까운 선택지를 제공합니다. 언제 24 또는 28을 사용해야 할지 모르겠어요.\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_0.png)\n\n대안은 비선형적입니다. 선택지로는 황금 비율, 모듈러 척도 또는 각 단계를 두배씩 증가시킬 수 있는 비슷한 기하급수가 있습니다. 기본부터 시작하여 작은 중지점(16, 8, 4, 2)과 큰 중지점(16, 32, 64, 그리고... 여기서 마무리)으로 갈 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Space in Design Systems](/assets/img/2024-06-23-SpaceinDesignSystems_1.png)\n\n**요약:** 기하 급수나 유사하게 비선형적인 것을 고려해보세요. 16과 32 사이에 24를 추가하는 압박을 가끔 느낄 수 있습니다. 그러나 제 경험상 그러한 순간들은 드물고 간혹 그 간단한 시스템을 깰 정도로 정당화되는 경우는 거의 없습니다.\n\n## 기억하기 쉽고 정확하게 재사용할 수 있도록 각 단계에 이름 지정하기\n\n저는 Gmail의 Compact, Cozy, Comfortable 스페이스 토글을 좋아합니다. 그래서 우리의 공간 시스템을 만들 때 나는 우리의 작업에서 그 레이블을 사용하는 것을 제안했습니다. 곧바로 팀원 한 명이 나를 도전했습니다: \"다른 단계를 뭐라고 부르면 좋을까?\" 제 정찬, 작고, 그리고 호화로운 옵션들은 통과하지 못했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![SpaceinDesignSystems_2](/assets/img/2024-06-23-SpaceinDesignSystems_2.png)\n\n우리가 항상 하는 것처럼, 티셔츠 사이즈 척도를 사용했어요. 중간 크기는 기본값에 해당하며, S, XS, L, XL 그리고 필요에 따라 XXS와 XXL도 다른 옵션입니다. 대부분의 라이브러리(Bootstrap, Lightning 등)에서도 이렇게 사용하고 있어요.\n\n중요한 점은 이름 공간 옵션을 간단하게 유지하여, 사람들이 기억하고 정확히 적용할 수 있는 언어를 만들어내는 것이에요. 더 구체적인 라벨을 사용하려고 하면, 동료가 \"작은 것, 중간 크기, 큰 것 중에서 선택해주세요.\" 라고 응답할 준비를 해야 해요.\n\n많은 라이브러리를 검토하고 많은 디자이너들과 이야기를 나눠봤어요. 기본 숫자와 명명된 척도에 대한 간단한 관례가 대화의 종착점인 곳이었어요. 이 몇 가지 옵션은 간단하지만, 여전히 공간을 사용하는 데 있어서 약간 무작위한 느낌이 들었어요. 그래서 더 필요했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공간을 위한 어휘 확장\n\n우리의 최근 작업을 검토해 보면, 공간을 적용하는 명확한 의도는 많지 않습니다. 예를 들어, 제가 가장 좋아하는 컴포넌트인 카드를 살펴보겠습니다:\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_3.png)\n\n프론트엔드 개발자로써, 저는 모든 요소 상자들을 시각화하여 요소를 서로 맞춰 보는 것을 상상합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_4.png)\n\n카드는 우리가 사용하는 여러 공간 개념을 유용하게 보여줍니다: 가장자리에서 콘텐츠를 삽입, 삽입 모양을 다양화, 항목을 인라인으로 간격 지정하고 구성 요소 내부 및 사이에 항목을 쌓는 방법.\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_5.png)\n\n이 개념들 - 삽입, 삽입 압축, 삽입 늘이기, 쌓기, 인라인, 그리드 - 은 우리 라이브러리의 대부분의 CSS 규칙을 다룹니다: 패딩, 마진, 왼쪽, 오른쪽, 위, 아래. 또한 이러한 개념들은 각 원자 별로 독립적이며, 합성성을 향상시킵니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Concept 1: (Square) Inset\n\n인셋은 벽에 걸린 사진의 매트처럼 모든 네 면에 들어가는 콘텐츠를 표시합니다. 이 사용법은 3개의 모듈과 블록 메시지 중간 느낌의 컴팩트한 피르, 혹은 넓은 푸터와 말머리 등 다양한 크기의 여러 컴포넌트들에서 퍼져 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-SpaceinDesignSystems_6.png\" /\u003e\n\n말머리 클릭을 하여 더 읽기! 안 눌러미세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot](/assets/img/2024-06-23-SpaceinDesignSystems_7.png)\n\n## Concept 2: Squish Inset\n\nA squished inset reduces space top and bottom, in our case by 50%. While less common than its squared counterpart, a squish occurred frequently in elements (like a button) and cell-like containers like a data table or list item.\n\n![Screenshot](/assets/img/2024-06-23-SpaceinDesignSystems_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개념 3: 스트레치 인셋\n\n버튼이나 피랍처럼 압축되는 것과 대조적으로, 우리는 텍스트 상자, 텍스트 영역 및 기타 양식 요소들의 인셋을 수직으로 늘렸습니다.\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_9.png)\n\n## 개념 4: 스택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수평 스크롤 UI에 대한 존경을 표합니다. 압도적인 대다수는 수직으로 스크롤합니다. 이것은 한 가지를 의미합니다: 우리는 여러 가지를 쌓습니다. 메시지를 헤딩 위에 데이터 테이블에 쌓습니다. 레일즈에서 모듈을 쌓습니다. 카드 안에 총 데이터, 항목 및 도구 모두를 그리드에 각각 쌓습니다. 참나, 무한 스크롤은 무한하게 쌓이는 것을 의미합니다! 우리는 쌓고 쌓고 쌓습니다.\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_10.png)\n\n## 컨셉트 5: 인라인\n\n우리는 객체를 인라인으로 배열하기도 합니다. 흘러가는 것처럼 좌측 또는 우측에서 텍스트처럼 흘러가는 대로 포장합니다. 피맛으로, 태그, 경로, 그리고 더 많은 것과 같은 객체들은 독립적으로 서있을 수도 있고, 다른 객체들과 함께 쌓이고 섞일 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 태그를 Markdown 형식으로 변경해보세요.\n\n\n![SpaceinDesignSystems](/assets/img/2024-06-23-SpaceinDesignSystems_11.png)\n\n## Concept 6: Grid\n\n아, 격자를 마지막에 남겨두자구요? 간격이 안정화되면서, 격자 여백과 거터를 다시 살펴보게 되고, 이 공간들을 마법같은 시작점과 다른 용도에 맞춰 정렬합니다.\n\n그래서, 카드 컴포넌트에 적용되는 경우, 스타일이 적용된 패딩과 여백은 다음과 같이 보일 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배운 내용\n\n공간 개념을 사용하는 것은 새로운 것에 적응해야 한다는 것을 의미합니다. 제 팀에서는 가볍게 회의적인 태도를 가진 사람들이 새로운 모델을 받아들이기까지 하루가 걸렸습니다.\n\n## 시각적으로 공간 시스템 가르치기\n\n대부분의 협력자들은 공간을 볼 수 없습니다. 이것이 임의로 적용되는 이유 중 하나입니다. 그러나 이제 우리는 시스템을 가지고 있습니다: 각각이 제한된 옵션 범위를 제공하는 제한된 개념 수.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-SpaceinDesignSystems_12.png)\n\n요점: 골격 다이어그램이나 치트 시트를 사용하여 공간 개념을 가르치세요. 이러한 참고 자료를 활용하면 디자인과 코드를 통해 개념을 이해하고 적용하며 유지하는 속도가 빨라집니다.\n\n## 간단한 도우미 제공 및 사용 모니터링\n\n어리석은 짓은 하지 마세요. 이 여섯 가지 모델이 모든 문제를 해결하는 것은 아닙니다. 때로는 여전히 여기 저기 여백을 조정해야 합니다. 그러므로 더 일반적인 대안(예: $space-m)을 사용하여 더 의도적인 공간 옵션을 따르는 것이 타당합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약: 일반적인 옵션을 제공하되, 절약해서 사용하고 제품 팀이 사용할 것을 기대합니다. 비판 또는 풀 리퀘스트에 나타나면, 인셋 또는 스택과 같은 더 구체적인 개념을 팀원들에게 교육하세요.\n\n## 패딩이나 마진을 사용한 변수명 피하기\n\n더 복잡한 것을 소개할 때, 다른 사람들이 이해할 만한 것을 옹호하는 것은 정당합니다. 예를 들어, \"왜 변수명에 패딩과 마진을 사용할 수 없을까요?\" 이 경우, 패딩을 사용한 2개 이상의 공간 개념이 있고, 이러한 개념은 좌우 속성을 통해도 적용할 수 있습니다. 마진은 스택, 그리드 및 공간 인라인에 사용됩니다. 게다가, HTML을 사용하지 않는 비웹 플랫폼은 어떻게 할까요?\n\n요약: 속성 이름에서 개념을 분리하세요. 여러 개의 개념이 하나로 제한될 뿐만 아니라 특정 플랫폼에서만 재사용 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 충돌을 체계적으로 해결하고 줄 간격 시스템\n\n간단한 안쪽 여백과 스택 여백 규칙이 오랫동안 알려진 공간 적대 요소와 충돌하였습니다: 줄 높이입니다. 이 상호작용은 공간을 예측할 수 없게 증가시켜, 간단한 안쪽 기본값(16px) 위와 아래에 픽셀이 추가되었습니다.\n\n![Space in Design Systems](/assets/img/2024-06-23-SpaceinDesignSystems_13.png)\n\n그러나 우리는 아이디어의 발전을 따라가며 (@kevinmpowell의 “의사 요소를 사용하여 공간을 음수 여백하자! 그러나 얼마나?”) 일부 수학을 활용했습니다(내 대학 학위를 활용할 수 있게!). 결과적으로, 글꼴 크기와 줄 높이를 결합한 믹스인 공식이 타입 간격을 줄이고 충돌하는 객체 위와 아래의 공간을 축소시키는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포기하지 마세요. 예외 때문에 체계적인 명확성을 방치하지 마세요. 문제를 해결해 보세요. 이러한 세세한 사항을 극복할 수 있다면, CSS요령을 사용하여도 단순한 개념을 전달할 수 있다는 것을 기억하세요.\n\n## 공간 개념 활용하여 밀도 조절하기\n\ninset, stack 및 grid와 같은 개념을 사용하여 밀도 조절 다이얼을 섬세하게 조절할 수 있습니다. 저장소에서 관심 있는 inset 및 stack을 찾아 확장하거나 재정의하여 디스플레이 밀도를 섬세하게 조정하세요.\n\n![SpaceinDesignSystems_14](/assets/img/2024-06-23-SpaceinDesignSystems_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약: 약간 원시적인 옵션 세트로 심도를 조절할 수 있습니다. 이 옵션이 없으면 밀도 제어는 꿈일 뿐입니다. 그러나 이 옵션들이 있다면, 의도를 갖고 공간을 찾아 조정하고 조절할 수 있는 강력한 엔진을 점차적으로 구축할 수 있습니다. 이는 위험을 줄이고 클라이언트에게 좋은 의도를 갖고 디자인을 할 수 있게 해줍니다.\n\n디자인 시스템을 준비하려는가요? 제품 및 플레이어에 대해 논의를 진행하려면? EightShapes는 시스템 계획 워크숍을 진행하고 디자인 시스템에 대해 고객을 코칭합니다. 얘기 나눠볼까요?","ogImage":{"url":"/assets/img/2024-06-23-SpaceinDesignSystems_0.png"},"coverImage":"/assets/img/2024-06-23-SpaceinDesignSystems_0.png","tag":["Tech"],"readingTime":9},{"title":"완벽한 코드 블로그를 만드는 방법","description":"","date":"2024-06-23 14:18","slug":"2024-06-23-Howtocreatetheperfectcodeblog","content":"\n\n![Code Block Image](/assets/img/2024-06-23-Howtocreatetheperfectcodeblog_0.png)\n\n## 1. What is a code block\n\nA code block is a section of a website's content used to display the syntax of a programming language. It is commonly used in educational blogs, documentation, programming forums, and more. Having a functional and well-formatted code block is crucial for your website.\n\n## 2. Creating a basic code block\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 블록을 만들려면 두 가지 HTML 태그 중 하나를 사용합니다. `code` 태그는 일반적으로 텍스트 편집기에서 볼 수 있는 스타일로 내용을 표시하는 데 사용됩니다. 이 스타일링은 주로 글꼴에서 확인할 수 있습니다. 글꼴은 IDE와 같은 글꼴 패밀리로 변경됩니다. 다른 태그인 `pre`는 텍스트를 그대로 표시하는 데 사용됩니다. HTML에서 텍스트는 단일 공백과 단일 줄 바꿈만 존재하도록 다듬지만 `pre` 태그를 사용하면 작성하는 동안 입력한 모든 공백과 줄 바꿈이 고려됩니다.\n\n이 코드 블록에서는 모던한 기능이 있는 코드 블록을 만들기 위해 `code`와 `pre` 태그를 모두 사용할 것입니다. 첫 번째 단계는 아래 코드를 사용하는 것입니다:\n\n```js\n\u003cpre\u003e\n  \u003ccode\u003e\nfunction greetings() {\n  console.log(\"Hello World!\");\n}\n  \u003c/code\u003e\n\u003c/pre\u003ecopy\n```\n\n위 코드에서 보듯이, 코드가 태그로 둘러싸여 있기 때문에 코드 태그에 있는 모든 것이 그대로 형식화되도록 pre 태그를 사용하고, 동시에 코드 태그를 사용하여 글꼴을 변경하고 웹 사이트를 의미적으로 만듭니다. 이 코드의 형식은 깨져 보일 수 있지만, 이것이 바로 pre 태그에 내용을 작성할 때 들여쓰기 없이 작성해야 하는 방식입니다. 코드 태그에서는 코드 블록이 작동하는지 테스트하는 데 도움이 되는 간단한 JavaScript 코드만 작성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 문법 강조 기능 추가하기\n\n문법 강조 기능은 코드의 다른 부분의 색상을 변경하여 사용자가 코드의 구문을 쉽게 식별할 수 있도록 하는 것입니다. 문법 강조 기능에는 많은 규칙이 있으며 이 시스템을 직접 만드는 것은 도전이 될 수 있습니다(제가 블로그를 작성할 수도 있겠죠). 대신 구글에서 개발한 스택 오버플로 같은 웹사이트에서 사용되는 인기 있는 3rd party 라이브러리인 code-prettify를 사용할 것입니다. 사용법은 매우 간단합니다. 두 가지만 하면 됩니다. 첫 번째는 제공된 CDN을 사용하여 프로젝트에 포함하는 것입니다:\n\n```js\n\u003cscript src=\"https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js\"\u003e\u003c/script\u003e\n```\n\n두 번째로 해야 할 일은 우리 코드 태그에 \"prettyprint\" 클래스를 지정하여 라이브러리가 문법 강조 기능을 적용할 위치를 알 수 있게 하는 것입니다. 사용할 클래스는 이미 문서에서 미리 정해져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n\u003cpre\u003e\n  \u003ccode class=\"prettyprint\"\u003e\nfunction greetings() {\n  console.log(\"Hello World!\");\n}\n  \u003c/code\u003e\n\u003c/pre\u003ecopy\n```\n\n우리의 코드에 모든 구문 강조 효과를 제공합니다.\n\n# 4. 복사 버튼 추가\n\n코드 블록에 일반적인 기능으로 사용자가 코드를 선택하지 않고도 쉽게 복사할 수 있는 방법을 제공하는 것이 좋습니다. 특히 대규모 코드 블록을 다룰 때 마우스로 코드를 모두 선택해야 하는 것은 귀찮을 수 있습니다. 복사 버튼을 만드는 것은 매우 간단합니다. 먼저 HTML에 버튼을 포함시켜야 합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n\u003cpre\u003e\n  \u003ccode class=\"prettyprint\"\u003e\nfunction greetings() {\n  console.log(\"Hello World!\");\n}\n  \u003c/code\u003e\n  \u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003e\n\u003c/pre\u003ecopy\r\n```\n\n그런 다음 JavaScript를 사용하여 작업할 것입니다:\n\n```js\r\nconst btn = document.querySelector(\".copy-btn\")\nconst code = document.querySelector(\"code\")\n\nbtn.addEventListener(\"click\", () =\u003e {\n  navigator.clipboard.writeText(code.textContent)\n})copy\r\n```\n\n위의 코드에서 볼 수 있듯이, 방금 만든 버튼에 이벤트 리스너를 추가하고 `code`의 텍스트 콘텐트를 사용자 클립보드로 복사하는 JavaScript를 작성했습니다. navigator 객체를 사용하여 사용자가 실행 중인 시스템의 클립보드에 액세스합니다. inner-HTML 대신에 code의 텍스트 콘텐트를 사용하는 것에 유의하십시오. inner-HTML을 사용하면 하이라이트 라이브러리 code-prettify에서 생성된 추가 코드도 복사되기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 일반적인 스타일링 추가하기\n\n기술적으로 모든 것이 작동하는 것을 확인했으니, 이제 스타일링을 추가할 시간입니다. 이 블로그는 스타일에 관한 것은 아니지만, 아래에서 사용하고 싶은 스타일을 알려드리겠습니다:\n\n```js\npre {\n  max-width: 560px;\n  border: 1px solid #ccc;\n  border-radius: 8px;\n  padding: .5em 1em;\n  position: relative;\n}\n\nbutton {\n  font: inhreit;\n  font-size: 12px;\n  background: none;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  position: absolute;\n  top: .5rem;\n  right: 1rem;\n  cursor: pointer;\n}\n```\n\n위의 스타일을 공부하고 사용하며 원하는 대로 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그를 도움이 되었다면 새로운 블로그 포스트 알림을 받으려면 X(트위터)에서 저를 팔로우해보세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-Howtocreatetheperfectcodeblog_0.png"},"coverImage":"/assets/img/2024-06-23-Howtocreatetheperfectcodeblog_0.png","tag":["Tech"],"readingTime":4},{"title":"Tailwind Signals로 UI 강화하기 설정 및 예제","description":"","date":"2024-06-23 14:17","slug":"2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples","content":"\n\n테일윈드 신호는 Tailwind CSS 클래스에 반응적이고 동적인 동작을 추가하는 환상적인 방법입니다. 상태 변경, 사용자 상호작용 또는 웹 애플리케이션의 다른 이벤트에 응답하여 더 활발하고 매력적인 사용자 경험을 제공할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples_0.png)\n\n# 테일윈드 신호란?\n\n간단히 말해, 테일윈드 신호를 사용하면 클래스를 토글하고 요소를 애니메이션화하며 사용자 입력을 원활하게 처리할 수 있습니다. 이를 통해 작성해야 하는 JavaScript 양을 줄여주고, Tailwind CSS 작업 흐름에 새로운 동적 요소를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Tailwind Signals 설정하기\n\n프로젝트에 Tailwind Signals를 설정해봅시다. 이미 Tailwind CSS를 사용 중이라면, 이 설정은 간단할 것입니다.\n\n## 단계 1: Tailwind CSS 설치\n\n아직 Tailwind CSS를 설치하지 않았다면, npm을 사용하여 설치해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install tailwindcss\n```\n\n그런 다음 tailwind.config.js 파일을 생성해주세요:\n\n```js\nnpx tailwindcss init\n```\n\n## 단계 2: Tailwind Signals 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 Tailwind Signals 패키지를 설치해보세요:\n\n```js\nnpm install tailwind-signals\n```\n\n## 단계 3: Tailwind Signals 구성\n\ntailwind.config.js 파일을 열어 Tailwind Signals 플러그인을 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodule.exports = {\n  // ... 기존 테일윈드 설정\n  plugins: [\n    require('tailwind-signals'),\n  ],\n};\n```\n\n이제 Tailwind Signals를 프로젝트에서 사용할 준비가 되었습니다.\n\n# Tailwind Signals 사용 방법: 예시\n\n## 예시 1: 클래스 전환하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 예제로 시작해 봅시다. 버튼 클릭에 따라 클래스를 토글하는 것을 보여드리겠습니다. div 요소의 표시 여부를 토글하는 버튼을 생성할 것입니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003e토글 예제\u003c/title\u003e\n  \u003clink href=\"/dist/output.css\" rel=\"stylesheet\"\u003e\n\u003c/head\u003e\n\u003cbody class=\"p-6\"\u003e\n  \u003cbutton\n    class=\"bg-blue-500 text-white p-2 rounded\"\n    data-signal=\"toggle\"\n    data-target=\"#toggleDiv\"\n    data-class=\"hidden\"\n  \u003e\n    토글하기\n  \u003c/button\u003e\n  \n  \u003cdiv id=\"toggleDiv\" class=\"mt-4 p-4 bg-gray-100 hidden\"\u003e\n    이 div는 토글됩니다!\n  \u003c/div\u003e\n\n  \u003cscript src=\"https://cdn.jsdelivr.net/npm/tailwind-signals@latest\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n이 예제에서는 버튼을 클릭하면 div 요소의 hidden 클래스가 토글되어 표시되거나 숨겨집니다.\n\n## 예제 2: 요소 애니메이션화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 요소를 클릭할 때 애니메이션을 추가해 보겠습니다. 클릭하면 div 요소가 커졌다 줄어들게 애니메이션을 적용할 거에요.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"ko\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003e애니메이션 예제\u003c/title\u003e\n  \u003clink href=\"/dist/output.css\" rel=\"stylesheet\"\u003e\n\u003c/head\u003e\n\u003cbody class=\"p-6\"\u003e\n  \u003cdiv\n    id=\"animateDiv\"\n    class=\"bg-red-500 w-32 h-32\"\n    data-signal=\"toggle\"\n    data-class=\"transform scale-125\"\n  \u003e\n  \u003c/div\u003e\n\n  \u003cscript src=\"https://cdn.jsdelivr.net/npm/tailwind-signals@latest\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\r\n```\n\n이제 div를 클릭하면 transform scale-125 클래스가 토글되어 크기가 애니메이션되게 됩니다.\n\n## 예제 3: Tailwind Signals를 사용한 반응형 상태\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 카운터를 만들어보겠습니다. 버튼을 클릭할 때마다 카운터가 증가합니다. 이를 통해 Tailwind Signals가 반응적 상태와 함께 어떻게 작동하는지 보여줄 거예요.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003eCounter Example\u003c/title\u003e\n  \u003clink href=\"/dist/output.css\" rel=\"stylesheet\"\u003e\n\u003c/head\u003e\n\u003cbody class=\"p-6\"\u003e\n  \u003cdiv id=\"counter\" class=\"text-2xl mb-4\"\u003e0\u003c/div\u003e\n  \u003cbutton\n    class=\"bg-green-500 text-white p-2 rounded\"\n    data-signal=\"increment\"\n    data-target=\"#counter\"\n  \u003e\n    Increment\n  \u003c/button\u003e\n\n  \u003cscript src=\"https://cdn.jsdelivr.net/npm/tailwind-signals@latest\"\u003e\u003c/script\u003e\n  \u003cscript\u003e\n    const counter = document.getElementById('counter');\n    let count = 0;\n\n    document.querySelector('[data-signal=\"increment\"]').addEventListener('click', () =\u003e {\n      count++;\n      counter.textContent = count;\n    });\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n이 예제에서는 버튼을 클릭하면 div에 표시된 카운터 값이 증가합니다.\n\nTailwind Signals를 사용하면 Tailwind CSS 프로젝트에 상호작용적이고 동적인 동작을 쉽게 추가할 수 있어요. 간단한 JavaScript로 반응형이고 매력적인 사용자 인터페이스를 만들 수 있어요. 그러니 다음 프로젝트에서 Tailwind Signals를 한번 시도해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이와 유사한 기사들을 보려면 Medium에서 나를 팔로우하거나 새 이야기를 이메일로 받으세요. 또한 제 리스트들도 살펴보실 수도 있습니다. 또는 이와 관련된 다음 기사 중 하나를 확인해보세요:\n\n- Embracing Utility-First CSS with Tailwind: A Comprehensive Guide\n- React vs. Vue in 2024: A Detailed Framework Comparison for Web Developers\n- Elixir/Phoenix vs. Go in 2024: Comprehensive Backend Technology Comparison\n- Hystrix vs. Opossum for Microservices: A Comprehensive Guide to Circuit Breaker Choices","ogImage":{"url":"/assets/img/2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples_0.png"},"coverImage":"/assets/img/2024-06-23-SuperchargeYourUIwithTailwindSignalsSetupandExamples_0.png","tag":["Tech"],"readingTime":5},{"title":"Z-index 완벽 이해하기 - 흔한 오해와 CSS 작동 원리 분석","description":"","date":"2024-06-23 14:16","slug":"2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior","content":"\n\nUI 버그는 최고의 개발자들조차 괴롭히는 법이죠. 왜냐하면 백엔드 문제와는 달리, UI 문제를 디버깅하는 것은 코드 수정을 넘어 사용자가 보고 상호 작용하는 것이 완벽한지 확인하는 것이 중요하기 때문입니다. 화면 크기, 브라우저 버전 또는 심지어 사용자의 기기 등과 같은 요소에 영향을 받는 UI 버그는 사용자를 좌절시키고 브랜드 인식을 훼손시키며 전환을 방해할 수 있습니다. 심지어 보이는 것 같이 간단한 스타일링 문제조차 심각한 문제로 커질 수 있습니다.\n\n이러한 도전을 직접 경험할 수 있는 한 분야는 웹 페이지 스타일링입니다. CSS는 복잡하고 섬세할 수 있으며, 해당 속성을 오해하거나 잘못 사용하면 중대한 디버깅 노력을 필요로 합니다.\n\n## \"UI 혼란의 공통 원인은 z-index 속성입니다. z-index의 기본 동작 및 작동을 이해하는 것이 중요합니다. z-index가 어떻게 작동하는지 확실하게 이해하지 않으면 개발자들은 의도한대로 요소가 층으로 배치되지 않는 예상치 못한 레이아웃 문제를 쉽게 만날 수 있습니다.\"\n\n## Z-Index 속성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 내용을 여러 번 읽으시는 것을 권장합니다. 정의 자체가 모든 것을 설명해 주지만, 코드를 작성할 때 종종 세부 사항을 놓치곤 합니다.\n\n이 속성은 웹 페이지의 요소 쌓임 순서를 제어하는 데 중요한 역할을 합니다. 그러나 요소의 위치 지정과 그들을 포함하는 컨테이너의 표시 속성과 같은 여러 요소에 의해 행동이 영향을 받을 수 있습니다.\n\n# 자세히 살펴보겠습니다:\n\n## 위치 지정된 요소:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nz-index가 작동하려면 요소의 position 속성을 기본 값(static)이 아닌 다른 값으로 설정해야 합니다. 요소는 relative, absolute, fixed 또는 sticky 위치여야 합니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png)\n\n## Z-순서:\n\n이것은 화면에 수직인 z축을 따라 요소의 순서를 의미합니다. 이는 서로 위에 쌓인 종이 층으로 생각할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_1.png\" /\u003e\n\n## 자손:\n\nz-index는 위치가 지정된 요소 내의 모든 자식 요소에도 영향을 미칩니다. 이는 쌓임 순서가 요소 자체뿐만 아니라 해당 자식 요소에도 적용된다는 것을 의미합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 정적 위치 지정에서 — 'Z-Index는 무시됩니다'\n\n기본적으로 요소들은 정적으로 위치 지정되어 있어 HTML 마크업에 나타나는 순서대로 렌더링됩니다. 이 상황에서 z-index 속성은 전혀 영향을 미치지 않고, 요소들은 DOM 트리 내에서의 위치에 따라만 쌓입니다.\n\n이는 DOM 트리에서 나중에 나타나는 요소가 항상 앞에 나타나는 요소 위에 일관되게 표시된다는 것을 의미합니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 정적(static) 이외의 위치 지정 - 'Z-index가 예상대로 작동합니다.'\n\n요소들이 position: relative, position: absolute, position: sticky 또는 position: fixed와 같은 속성을 사용하여 명시적으로 위치 지정된 경우, z-index 속성이 적용됩니다. 더 높은 z-index 값을 가진 요소는 낮은 z-index 값을 가진 요소 위에 나타납니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_4.png)\n\n## 플렉스(flex) 또는 그리드(grid) 레이아웃 컨테이너\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랙스 또는 그리드 컨테이너에서 요소의 쌓임 순서는 z-index, 항목 순서 및 정렬을 결합한 요소로 결정됩니다. 요소들이 정적으로 배치되어 있더라도 z-index 속성은 컨테이너 내에서의 쌓임 순서에 영향을 줍니다.\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_5.png)\n\n이제 z-index 동작에 대한 기본적인 이해를 갖고 있으니, 스택 컨텍스트, 그 원리, 그리고 CSS가 코드를 어떻게 해석하거나 이해하는지에 대해 더 심층적으로 살펴보겠습니다.\n\n# 스택 컨텍스트란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS의 쌓이는 컨텍스트는 웹페이지의 요소들을 위한 레이어 시스템입니다. 이는 요소들이 서로 어떻게 겹치는지를 결정합니다.\n\n한 페이지의 컨테이너 안에 객체들이 담겨 있다고 상상해보세요. 기본적으로, 그들을 넣은 순서대로 보이게 됩니다. 마치 접시 쌓아놓은 것처럼 말이죠. z-index 속성은 특별한 라벨 같은 것으로, 일부 접시에 붙일 수 있는 것입니다. 이것은 컨테이너 내에서만 영향을 미치며, 특정 컨테이너 안에서 다른 접시들 위에 라벨이 붙은 접시들이 나타나는 순서를 정할 수 있게 해줍니다.\n\n# 또한 쌓이는 컨텍스트를 폴더를 만들고 각 폴더가 자체적인 컨텍스트를 가지는 디렉토리 시스템으로 생각할 수 있습니다. 쌓이는 컨텍스트는 폴더를 만들 수 있고, 각 폴더가 자체적인 컨텍스트를 가질 수 있습니다. 쌓이는 컨텍스트는 폴더 안에 하위 폴더를 만들 수 있는 것처럼 중첩될 수 있습니다.\n\n![image](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 새로운 쌓임 맥락은 무엇을 만들까요?\n\n새로운 쌓임 맥락은 여러 가지 방법으로 생성됩니다. 예를 들어:\n\n- 특정 CSS 속성을 사용하는 경우(static이 아닌 값으로 position, 값이 있는 z-index, 불투명도가 1 미만).\n- `iframe`과 같은 특정 요소 또는 transform, filter 또는 will-change와 같은 CSS 속성이 있는 요소.\n- 전체 목록을 보려면 이 곳을 방문하세요.\n\n# 예상치 못한 숨겨진 UI 요소: 쌓임 맥락에 대한 오해에서 발생하는 흔한 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 예제를 고려해 보세요:\n\n```js\n\u003cdiv class=”rectangular-bg”\u003e\n \u003cdiv class=”circle”\u003e\u003c/div\u003e\n \u003cdiv class=”triangle”\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n우리가 `.circle`에 음수 z-index와 position: relative를 적용하면 이미지에 표시된 대로 원이 사라집니다. 그 원은 실제로 부모인 직사각형 배경 뒤에 숨겨져 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기가 이유입니다: position: relative와 함께 z-index: -1을 추가하면 원에 대한 새로운 쌓임 맥락이 생성됩니다. 이 새로운 쌓임 맥락은 기본 루트 쌓임 맥락(전체 페이지)의 일부입니다.\n\n원의 z-index 속성은 해당 부모 쌓임 맥락에 대해 동작합니다. 부모 요소(직사각형 배경)에 z-index가 없기 때문에 원은 그 뒤에 렌더링됩니다.\n\n## - z-index는 부모 컨테이너에 상대적입니다\n\n![이미지](/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 원의 부모 쌓임 문맥은 z-index가 1인 직사각형 배경이며, 따라서 원의 z-index는 직사각형 배경 쌓임 문맥을 기준으로 계산됩니다. 즉, 1+(-1) = 0이 됩니다.\n\n## - 투명도를 사용한 쌓임 문맥\n\n원을 삼각형 위로 올리고 싶습니다. z-index를 사용하지 않고 이를 어떻게 구현할 수 있을까요?\n\n\u003cimg src=\"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_9.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동그라미의 불투명도를 1보다 작게 설정하거나 변형 속성을 사용하여 설정할 수 있습니다. 이전에 논의했던 대로 이는 새로운 콘텍스트를 생성하게 됩니다. 이것으로 원이 삼각형 위에 올라가게 됩니다.\n\n# 스택 컨텍스트와 다양한 복잡한 시나리오에서의 z-index 동작에 대한 흥미로운 예시들을 살펴봅시다.\n\n## z-index로 스택 컨텍스트 만들기\n\n모양이라는 div가 자체 스택 컨텍스트를 가지고 있다고 가정해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n삼각형이 지금은 사각형과 원 위에 있어요.\n\n- 사각형 위에 있는 이유는, 도형들과 관련해서 삼각형이 1층 위에 있기 때문이에요.\n- 원 위에 있는 이유는, 원이 z-index를 설정하지 않았고, 동생 폴리곤과 동일한 쌓임 맥락에 속하기 때문이에요. 즉, 원의 z-index는 부모 도형으로부터 전달된 1의 값을 가지고 있어요.\n\n이제 삼각형이 사각형 위에 위치하되 원 위에 위치하지 않게 하고 싶다고 해보죠. 이를 해결하기 위해서, 폴리곤의 z-index나 원의 z-index를 변경할 수 있어요. 아래 이미지를 확인해주세요.\n\n이미지의 두 번째 예시에서는 원의 z-index가 사각형보다 높은 값을 가지고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n삼각형이 원 앞에 나타나길 원한다면, 삼각형에 높은 z-index를 설정하는 것만으로는 동작하지 않습니다. 어떤 값이든 상관없이 삼각형의 z-index는 그 쌓임 맥락(다각형) 내에서만 적용되기 때문입니다.\n\nz-index에 대해 까다로운 점은 요소의 쌓임 맥락 내에서만 작동한다는 것입니다. 우리의 경우, 우리는 삼각형이 다각형 쌓임 맥락의 일부인 채로 원(다른 쌓임 맥락) 앞에 나타나길 원합니다. 이것은 불가능합니다.\n\n삼각형이 원 앞에 나타나게 하려면, 다각형에서의 쌓임 맥락을 제거해야 합니다.\n\n이제 삼각형과 원은 동일한 쌓임 맥락을 공유하게 되어, 높은 z-index로 삼각형이 원 앞에 나타나도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 학습 내용:\n\n- 위치 지정이 필요한 속성: z-index 속성은 요소의 위치를 상대적, 절대적, 고정된 또는 고정 흐름 속성으로 설정해야 합니다.\n- 플렉스 및 그리드 컨테이너: 이러한 컨테이너 내에서도 z-index는 항목 순서와 정렬에 영향을 받아 쌓이는 순서를 제어합니다.\n- Z-순서: 이것은 요소의 z 축을 따라 순서를 결정합니다. 높은 z-index 값은 위에 표시됩니다.\n- 쌓임 컨텍스트: 요소들을 위한 특별한 레이어입니다. 동일한 쌓임 컨텍스트 내의 요소는 z-index를 사용하여 쌓일 수 있지만 다른 쌓임 컨텍스트 내의 요소는 직접적으로 서로의 쌓임 순서에 영향을 줄 수 없습니다.\n- 쌓임 컨텍스트 생성: 불투명도, 변형, 필터 및 will-change와 같은 CSS 속성을 사용하여 새로운 쌓임 컨텍스트를 생성할 수 있습니다.\n\n# 결론:\n\nCSS는 복잡할 수 있으며 z-index와 같은 속성의 세부 사항을 이해하지 못하면 중대한 디버깅 노력을 초래할 수 있습니다. 요소들의 층을 올바르게 제어하는 방법을 알고 있다면 일반적인 함정을 피하고 시간을 절약하며 웹사이트에서 사용자 경험을 향상시킬 수 있습니다. 이러한 원칙을 구현하여 요소가 정확히 표시되고 의도한 대로 쌓이며 매끄럽고 매력적인 시각적 프레젠테이션에 기여하도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료:\n\n- https://web.dev/learn/css/z-index\n- https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context\n- https://ishadeed.com/article/understanding-z-index/\n\n# 저자 소개:\n\nKshitij은 React, Next.js 및 TypeScript에 튼튼한 기반을 갖춘 프론트엔드 개발자입니다. 그는 React와 WebGL의 힘을 활용하여 사용자 경험과 비즈니스 목표를 일치시키는 몰입형 웹 경험을 개발하는 전문가입니다. 대화형 3D 랜딩 페이지부터 복잡한 암호 웹 앱까지 다양한 20개 이상의 프로젝트에 참여했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더문데브 블로그 편집팀은 이 기사에서 제시된 코드 샘플 및 기술적 콘텐츠를 검토해 주신 수바카르 티키레디에게 감사의 마음을 전합니다.","ogImage":{"url":"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png"},"coverImage":"/assets/img/2024-06-23-DeconstructingZ-indexUnderstandingthecommonmisconceptionsandCSSbehavior_0.png","tag":["Tech"],"readingTime":7},{"title":"라이브러리나 커스텀 알고리즘 없이 모던 컬러 스케일 만드는 방법","description":"","date":"2024-06-23 14:14","slug":"2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms","content":"\n\n![이미지](/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png)\n\n## 왜 색상 척도를 사용해야 하는가?\n\n웹 애플리케이션에서 숫자를 단순히 숫자로만 표시하는 것보다 숫자에 해당하는 색상으로 숫자를 표현하는 것이 좋은 아이디어일 수 있습니다. 색상 척도에서 값의 위치에 해당하는 색상으로 채워진 숫자로만 수치적인 값을 전달하는 것이 더 쉽습니다. 모든게 빨간색으로 되어 있으면 상황을 이해하기 위해 숫자를 읽을 필요가 없을 수도 있습니다.\n\n텍스트의 색상도 유용할 수 있습니다. 예를 들어, 텍스트 분류 작업에서는 사용자가 입력 텍스트의 각 단어가 예측된 레이블에 미치는 기여도를 보는 것을 좋아합니다. 색상 척도는 각 단어의 점수를 시각적으로 나타내는 효과적인 수단입니다. 프랑스 명사의 끝과 성별 간 상관 관계에 대한 이전에 공유된 게시물에서 접미사의 양적 여성성과 남성성을 시각화하기 위해 분홍-파랑 척도를 사용했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의미 있는 색상으로 값을 강조하려면 두 가지 도구가 필요합니다:\n\n- 숫자 범위에 시각적으로 해당하는 균일한 색상 범위를 생성하는 함수\n- 사용된 범위 내에서 주어진 위치에 해당하는 색상을 반환하는 함수\n\n## 두 색상 사이에 선형 그라데이션을 생성하는 여러 가지 방법\n\n두 가지 다른 색상 사이의 경로는 완전히 다른 색이거나 심지어 자연적으로 관련이 없는 색 또는 한계 색의 음영일 수 있는 다른 색상을 통해 지나갑니다. 위의 이미지에서 확인할 수 있습니다. 경로상의 색상은 모든 가능한 색상이 계산 중에 어떻게 배열되는지에 따라 달라집니다. 현대 CSS는 15가지 색 공간을 지원합니다. 그 중 4가지는 극좌표입니다. 극좌표 공간의 두 색상 사이의 경로는 짧을 수도 있고 길 수도 있습니다. 따라서 브라우저는 CSS 함수 linear-gradient()를 사용하여 어떤 두 색상 사이의 19가지 서로 다른 경로를 생성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbackground: linear-gradient(in hsl shorter hue, limegreen, red);\n```\n\n일부 알고리즘의 결과는 매우 다른 이름을 갖고 있더라도 상당히 유사합니다. Limegreen과 red 사이의 모든 가능한 그라데이션을 담은 상단 이미지에서, 익숙한 노란색을 중간에 통과해야 하는 경우 hsl 또는 hwb의 더 짧은 방식을 선택할 수 있습니다. display-p3, a98-rgb, prophoto-rgb 또는 rec2020 방법을 사용하면 녹색에서 붉은색으로의 전이도 중간쯤에서 발생하지만 노란색 조합은 없습니다.\n\n그러나 red가 springgreen과 섞이면 19개의 방법 중 어느 것도 완벽한 그라데이션을 생성하지 못합니다. 같은 방법으로 생성된 그라데이션에서의 녹색에서 붉은색으로의 전환은 50% 아래로 보입니다. hsl 또는 hwb의 더 짧은 방식으로 생성된 그라데이션에서 노란색은 바로 40%에 위치합니다. 나에게는 srgb-linear 그라데이션이 가장 좋아 보입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 기본적으로 두 색상 사이의 점진적인 전환을 계산하는 다양한 방법이 있습니다. 그러나 모든 가능한 색상 조합에 대해 시각적으로 일정한 그라데이션을 만들어내는 보편적인 방법은 없습니다. 특정 두 색상을 균일하게 섞는 것이 항상 가능한 것도 아닙니다. 색상 척도를 만들려면 약간의 시도와 실험을 통해 두 색상을 선택하고 이를 균일하게 섞는 방법을 선택해야 합니다.\n\n## 숫자 값과 그라데이션 내 색상 매핑\n\n오늘날, 그라데이션의 특정 위치에 해당하는 색상을 검색할 수 있는 새로운 CSS 함수 color-mix()가 있습니다. 이 함수는 모든 브라우저에서 지원됩니다. 이 함수는 지정된 두 색상의 지정된 백분율을 사용하여 어떤 방법으로든 두 색상을 섞은 결과인 색상을 반환합니다. 다시 말해, 이 함수는 선형 그라데이션의 지정된 위치에 해당하는 색상을 반환합니다. 위치는 한 색상의 백분율로 지정되며, 두 번째 색상의 백분율은 100%에서 남은 값입니다. 예를 들어, hsl 더 긴색채에 대한 20의 색상 값을 사용할 때:\n\n```js\ncolor: color-mix(in hsl longer hue, limegreen, 20%, red)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 요약\n\n위의 화려한 백분율이 있는 그림들은 새로운 CSS 기능인 color-mix()에 의해 활성화됩니다. 색상 라벨, 그리드 라인 및 그라데이션은 쉬운 CSS를 사용하여 색상 스케일로 배열할 수 있습니다.\n\n전체 코드를 다음 페이지에서 확인할 수 있습니다: [링크](https://marianc000.github.io/colorScales/), 또는 [여기](https://github.com/marianc000/colorScales)에서 다운로드할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png"},"coverImage":"/assets/img/2024-06-23-Moderncolorscaleswithoutanylibrariesorcustomalgorithms_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular에서 이벤트 핸들링 HostListener와 HostBinding 탐구하기","description":"","date":"2024-06-23 14:13","slug":"2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png\" /\u003e\n\n안녕하세요!\n저는 Angular에서 거의 잊혀진 2가지 디렉티브를 소개하고 싶어요. 이 디렉티브들은 웹 페이지를 더 매혹적이고 매력적으로 만드는 열쇠를 쥐고 있어요.\n\n# 소개\n\nAngular에서 이벤트 처리는 상호작용적이고 동적인 애플리케이션을 만드는 데 중요한 역할을 합니다. HostListener와 HostBinding이라는 두 강력한 데코레이터는 컴포넌트나 디렉티브 내에서 호스트 요소의 이벤트를 처리하고 속성을 바인딩하는 중요한 기능을 제공합니다. 이 글에서는 HostListener와 HostBinding의 기술적 측면, 사용 방법, 예제, 차이점 및 최적 사용 방법에 대해 자세히 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# HostListener\n\nHostListener는 Angular에서 호스트 요소에서 이벤트를 수신할 수 있게 해주는 데코레이터입니다. 컴포넌트나 디렉티브의 호스트 요소에서 발생하는 이벤트를 수신하도록 할 수 있습니다. 클릭, 키 변경, 스크롤 등의 이벤트에 대응하여 DOM 요소에 이벤트 핸들러를 추가할 수 있습니다. 컴포넌트 메소드를 특정 이벤트에 바인딩하여 이벤트가 발생할 때 해당 메소드를 실행할 수 있습니다.\n\n## Import/Usage\n\nHostListener를 가져오고 사용하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1- @angular/core에서 필요한 데코레이터를 가져와주세요:\n\n```js\nimport { Component, Directive, HostListener } from '@angular/core';\n```\n\n2- 컴포넌트나 디렉티브 내에서 적절한 속성이나 메소드에 HostListener 데코레이터를 적용해주세요.\n\n## 예시 1:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component, HostListener } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\u003cbutton (click)=\"onClick()\"\u003eClick Here\u003c/button\u003e`\n})\nexport class ExampleComponent {\n  @HostListener('document:keydown', ['$event'])\n  handleKeyboardEvent(event: KeyboardEvent) {\n    console.log('Key pressed:', event.key);\n  }\n\n  onClick() {\n    console.log('Button clicked');\n  }\n}\n```\n\n이 예시에서는 HostListener를 사용하여 문서에서 keydown 이벤트를 감지하고 해당 이벤트가 트리거될 때 handleKeyboardEvent() 메소드를 호출합니다. 이 handleKeyboardEvent() 메소드는 키를 누를 때마다 메시지를 보여줍니다.\n\n또한 버튼에 일반 클릭 이벤트를 사용하여 onClick() 메소드를 호출합니다.\n\n## 예시 2:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { HostListener, Component } from \"@angular/core\";\n\n@Component({\n  selector: 'app',\n  template: `\u003ch1\u003eHello, you have pressed enter {counter} number of times!\u003c/h1\u003e Press enter key\nto increment the counter.\n  \u003cbutton (click)=\"resetCounter()\"\u003eReset Counter\u003c/button\u003e`\n})\nclass AppComponent {\n  counter = 0;\n  @HostListener('window:keydown.enter', ['$event'])\n  handleKeyDown(event: KeyboardEvent) {\n    this.counter++;\n  }\n\n  @HostListener('window:keydown.Backspace', ['$event'])\n  handleBackspace(event: KeyboardEvent) {\n    this.counter--;\n  }\n\n  resetCounter() {\n    this.counter = 0;\n  }\n}\n```\n\n이 경우, 이 예제에서는 Angular 컴포넌트가 정의되어 있습니다. 해당 컴포넌트는 카운터와 버튼을 표시합니다. Enter 키를 누를 때마다 카운터가 증가하고, BackSpace 키를 누를 때마다 카운터가 감소하며, 버튼을 클릭하여 0으로 재설정할 수 있습니다.\n\n@HostListener 데코레이터는 창에서 `keydown.enter` 이벤트를 감지하고 해당 이벤트가 발생할 때마다 handleKeyDown 메서드를 호출합니다. handleKeyDown 메서드에서는 카운터가 하나씩 증가합니다.\n\n비슷한 아이디어가 적용됩니다. HostListener 데코레이터가 창에서 `keydown.Backspace` 이벤트를 감지하고 'Backspace' 이벤트가 발생할 때마다 handleKeyDown 메서드를 호출합니다(카운터가 하나씩 감소).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 resetCounter 메서드는 카운터 변수에 0의 값을 할당합니다.\n\n## HostBinding\n\nHostBinding은 Angular에서 호스트 요소의 속성을 컴포넌트 또는 디렉티브의 속성에 바인딩할 수 있게 해주는 또 다른 데코레이터입니다. 이를 사용하여 호스트 요소에 속성 값을 설정하는 데 사용하며 컴포넌트 또는 디렉티브 속성의 값에 따라 호스트 요소에 속성 값을 설정합니다.\n\n## Import/사용법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHostBinding을 가져와 사용하려면 다음 단계를 따르세요:\n\n1- @angular/core에서 필요한 데코레이터를 가져옵니다:\n\n```js\nimport { Component, Directive, HostBinding } from '@angular/core';\n```\n\n2- HostBinding 데코레이터를 컴포넌트나 디렉티브의 적절한 속성에 적용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 1\n\n```js\nimport { Component, HostBinding } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\u003cdiv\u003e컴포넌트 내용\u003c/div\u003e`,\n  styles: [`\n    :host {\n      display: block;\n      background-color: yellow;\n    }\n  `]\n})\nexport class ExampleComponent {\n  @HostBinding('style.color') color = 'red';\n  @HostBinding('class.active') isActive = true;\n}\n```\n\n이 예시에서는 HostBinding을 사용하여 호스트 요소의 style.color 속성을 컴포넌트의 color 속성과 바인딩합니다. 또한 호스트 요소의 active 클래스를 컴포넌트의 isActive 속성과 바인딩합니다. 이를 통해 컴포넌트의 속성 값에 따라 호스트 요소에 값을 설정할 수 있습니다.\n\n# 예시 2\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component, HostBinding } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\u003cdiv\u003eComponent Content\u003c/div\u003e`,\n  styles: [`\n    :host {\n      display: block;\n      background-color: yellow;\n    }\n  `]\n})\nexport class ExampleComponent {\n  @HostBinding('attr.role') role = 'button';\n}\n```\n\n이 예제에서는 HostBinding을 사용하여 호스트 요소의 role 속성을 컴포넌트의 role 속성과 바인딩합니다. 이를 통해 호스트 요소의 role 속성을 동적으로 설정할 수 있게 됩니다.\n\n# 차이점 및 사용 방법\n\nHostListener와 HostBinding의 주요 차이점은 기능입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- HostListener은 호스트 요소에서 특정 이벤트를 수신하고 해당 이벤트에 따라 구성 요소나 지시문 메서드를 실행하는 데 사용됩니다. 예를 들어, 클릭 또는 키 변경과 같은 이벤트가 있습니다.\n- HostBinding은 구성 요소나 지시문 속성을 호스트 요소의 속성에 바인딩하고 이러한 속성 값에 따라 호스트 요소에 값을 설정하는 데 사용됩니다. 구성 요소나 지시문 속성 값에 따라 호스트 요소의 속성에 값을 설정해야 하는 경우에 사용하며, 스타일, 클래스 등과 같은 속성에 값을 설정하는 데 유용합니다.\n\n# 결론\n\n본 문서에서는 Angular에서 강력한 데코레이터인 HostListener와 HostBinding을 탐색했습니다. HostListener를 사용하면 호스트 요소에서 이벤트를 수신하고 해당 이벤트에 따라 메서드를 실행할 수 있습니다. HostBinding을 사용하면 구성 요소나 지시문 속성을 호스트 요소의 속성에 바인딩하여 호스트 요소를 동적으로 조작할 수 있습니다. 이러한 데코레이터를 사용하는 방법과 차이점을 이해하고 최선의 실천 방법을 알아보면 Angular 애플리케이션을 상호작용적이고 반응적으로 개선할 수 있습니다.\n\n관심 가져주셔서 감사합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- https://angular.io/api/core/HostListener\n- https://angular.io/api/core/HostBinding\n- https://www.digitalocean.com/community/tutorials/angular-hostbinding-hostlistener","ogImage":{"url":"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png"},"coverImage":"/assets/img/2024-06-23-EventHandlinginAngularExploringHostListenerandHostBinding_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular에서 Command 패턴 소개","description":"","date":"2024-06-23 14:12","slug":"2024-06-23-IntroductiontoCommandPatterninAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png\" /\u003e\n\n# 소개\n\n작업을 위임하는 몇 가지 방법이 있습니다. 이 상황에서는 드롭다운 옵션을 선택했을 때 경로 시각화의 표시 모드가 변경됩니다.\n\n직접적인 해결책은 컨트롤러 패널에서 SVG 경로로 작업을 위임하기 위해 옵저버 패턴을 사용하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 이 시나리오에 관찰자 패턴을 적용하는 데는 여전히 일부 단점이 있습니다. 이 글에서는 명령 패턴의 소개와 왜 더 나은 해결책이라고 생각했는지를 공유하고 싶습니다.\n\n## 안건\n\n이 글에는 몇 가지 주제가 있습니다.\n\n- 토론: 관찰자 패턴 vs 명령 패턴\n- 구현: 명령 패턴으로 제어 패널 리팩터링\n- RxJS를 사용한 실행 취소 및 재설정 구현\n- 데모\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이 시리즈에 대해\n\n이 시리즈는 프론트엔드 프레임워크와 디자인 패턴을 어떻게 사용하는지 배우는 데 목표를 두고 있습니다.\n\n- 기사 1. React에서 Angular로: 전략 패턴 및 동적 렌더링 구현\n- 기사 2. Angular에서 빌더 패턴과 책임 연쇄 패턴을 사용하여 객체 생성 프로세스를 리팩터링\n- 기사 3. Observer 패턴을 사용하여 다른 조상 React 컴포넌트 간의 통신 구현\n- 기사 4. Angular에서 Command 패턴 소개 (이 기사)\n\n# 토론: Observer 패턴 vs Command 패턴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 옵저버 패턴\n\n옵저버 패턴의 주요 역할을 보여주는 다음 다이어그램입니다.\n\n![Observer Pattern Diagram](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_1.png)\n\n옵저버 패턴은 옵저버와 서브젝트로 구성되어 있습니다. 우리의 시나리오에 이 패턴을 어떻게 매핑할 수 있는지 쉽게 상상해볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 드롭다운 선택이 변경되면 Subject가 Observer에게 알림을 보냅니다.\n- Subject에는 이벤트 유형과 필요한 매개변수가 포함됩니다.\n- 그런 다음 Observer는 이벤트에 따라 해당 작업을 수행할 수 있습니다.\n\n그러나 이 시나리오에이 패턴을 적용할 때 일부 단점이 있습니다.\n\n- 컨트롤 패널이 커질수록 SVG 경로 구성 요소가 커집니다 (해당 작업을 수행하기 전에 Subject를 분석해야 하기 때문)\n- 되돌리기 기능을 구현하는 것이 직접적이지 않습니다 (Observer 패턴이 자연스럽게 이벤트를 캡슐화하고 저장하지 않기 때문)\n\n![이미지](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Command Pattern\n\nCommand 패턴의 주요 역할을 보여주는 다음 다이어그램입니다.\n\n![Command Pattern Diagram](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_3.png)\n\nCommand 패턴의 Subject는 Observer에 이벤트와 분리된 매개변수를 보내는 대신, 매개변수를 하나의 객체로 캡슐화하고 Receiver를 직접 조작하기 위해 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해당 명령은 작업에 필요한 매개변수와 명령 유형을 분석하는 논리를 캡슐화합니다. 드롭다운 선택이 변경되면 인보커가 생성된 명령을 실행합니다.\n- 수신자(SVG 경로의 구성 요소)는 명령에 따라 해당 작업을 수행합니다.\n\n여러 가지 이점이 있습니다.\n\n- 제어 패널이 커질 때 SVG 경로의 구성 요소가 커지지 않습니다 (분석 논리가 명령 객체로 이동되기 때문)\n- Undo 기능에 대해 간단합니다 (명령 패턴이 명령을 캡슐화하고 저장하기 때문)\n\n![이미지](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구현: 명령 패턴을 사용하여 제어 패널 다시 구성하기\n\n이 구현은 이 기사의 예시 D3.js 프로젝트 (데모)를 기반으로 합니다. 이전에는 범례, 노드 및 엣지가 단일 구성 요소에 있었기 때문에 서로 다른 구성 요소 간의 작업을 위임할 필요가 없었습니다.\n\n이제 제어 패널 항목들을 독립적인 구성 요소 (호출자)로 이동하고 작업을 SVG 경로 구성 요소 (수신기)로 위임하는 명령 패턴을 구현하고자 합니다.\n\n## 준비하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 패키지 설치하기\n\n```js\nnpm install @ng-select/ng-select@^9.1.0\nnpm install lodash@^4.17.21\n```\n\n- 필요한 컴포넌트 및 서비스 생성하기\n\n```js\nng g c topology\nng g c topology/topology-controller/topology-controller-assistant\nng g s topology/topology-controller/topology-controller-assistant\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 모델을 생성하세요\n\n- Invoker, Receiver, 그리고 Command에 대한 필요한 인터페이스와 클래스를 생성하세요\n\n## Invoker 구현: 드롭다운 컴포넌트 업데이트\n\n이 경우에 Invoker는 ng-select 컴포넌트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- topology-controller-assistant.component.html을 업데이트하십시오.\n\n구현 세부 정보는 공개하지 않지만, Invoker가 어떻게 작동하는지에만 집중하세요.\n\n- topology-controller-assistant.service.ts를 업데이트하십시오.\n— 서비스는 드롭다운 컴포넌트에 옵션을 제공합니다 (라인 5 ~ 10)\n\n- topology-controller-assistant.component.ts를 업데이트하십시오.\n- 이 컴포넌트는 TopologyCommandInvoker 인터페이스를 구현해야 합니다.\n- 초기화할 때, 이 컴포넌트는 리소스를 검색할 것입니다 (라인 42)\n- Invoker는 호출할 때 커맨드를 스택에 저장할 것입니다 (라인 88)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 수신기 구현: SVG 경로 구성 요소 업데이트\n\n- topology.component.ts 파일을 업데이트하세요.\n- 이 구성 요소의 자세한 코드는 이 기사를 참조해주세요.\n- 이 구성 요소는 TopologyCommandReceiver 인터페이스를 구현해야합니다.\n\n## 클라이언트 구현: 루트 구성 요소 업데이트\n\n클라이언트는 Invokers와 Receivers 간의 다리 역할을 하며 ViewChild를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- app.component.html 파일을 업데이트하세요.\n- app.component.ts 파일을 업데이트하세요.\n- ViewChild를 사용하여 Invokers 및 Receivers를 검색하세요 (11 ~ 12번 라인).\n- commandStack 및 makeCommand를 Invokers와 Receivers에 위임하세요 (17 ~ 18번 라인).\n\n# RxJS를 이용한 실행 취소 및 재설정의 구현\n\n마지막 섹션에서 명령을 호출할 때 이미 명령을 스택에 푸시했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`undo` 기능을 구현할 때는 최신 Command를 제거하고 이전 Command를 되돌리는 Command를 실행하면 된다. `reset` 기능을 구현할 때는 스택을 지우고 이전 명령을 모두 되돌리면 된다.\n\n![CommandPattern](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_5.png)\n\n## Undo 버튼 구현: 루트 컴포넌트 업데이트\n\n- app.component.html 파일 업데이트\n- undo 및 reset을 위한 새로운 버튼 추가 (라인 15 ~ 18)\n- undoConfiguration$ 및 resetConfiguration$를 input() 매개변수로 전달 (라인 8 ~ 9)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- app.component.ts 파일을 업데이트해주세요\n\n## 옵저버 구현: 드롭다운 컴포넌트 업데이트하기\n\n- topology-controller-assistant.component.ts 파일을 업데이트해주세요\n- undoConfiguration$ 및 resetConfiguration$를 구독해주세요 (19 ~ 20번 라인)\n\n# 데모\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 리팩터링 전\n\n- 리팩터링 후\n\n# 참고\n\n- Callback/Command vs EventListener/Observer Pattern\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개요\n\n끝까지 참아주셔서 감사합니다. 저는 션입니다. 소프트웨어 엔지니어로 일하고 있어요.\n\n이 글은 제 노트입니다. 실수가 있으면 자유롭게 조언해주세요. 피드백을 기다리고 있겠습니다.\n\n- 구독하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기사를 위한 Facebook 페이지\n\n- 데일리 러닝 웹사이트\n\n- 데일리 러닝 라인 봇\n\n![image](/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 관련 주제\n\nKnout.js 및 ReactJS에서 양방향 바인딩을 사용하는 방법\n\nSignalR을 활용하여 채팅방 애플리케이션 만드는 법을 배워보세요\n\n'Effective SQL'에 대한 제 생각:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIT 및 네트워크:","ogImage":{"url":"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png"},"coverImage":"/assets/img/2024-06-23-IntroductiontoCommandPatterninAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular에서 꼭 알아야 할 RxJS 연산자들","description":"","date":"2024-06-23 14:10","slug":"2024-06-23-RxJSOperatorsinAngular","content":"\n\nRxJS 연산자는 Angular의 강력한 기능으로, 데이터 스트림을 조작하고 변환할 수 있는 기능입니다. Observable과 함께 사용하여 데이터를 필터링, 매핑, 축소하고 기타 작업을 수행할 수 있습니다.\n\n파이프 연산자(Pipeable Operator)는 Observable을 입력으로 받아 다른 Observable을 반환하는 함수입니다. 이는 순수한 작업입니다: 이전 Observable은 변경되지 않습니다.\n\n다음은 Angular에서 자주 사용되는 몇 가지 RxJS 연산자 예시입니다:\n\n- map: 이 연산자는 observable에서 방출되는 데이터를 변환하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 observable이 있다면, 각 숫자의 값을 두 배로 만들기 위해 map 연산자를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nimport 'of' from ‘rxjs’;\n\nimport 'map' from ‘rxjs/operators’;\n\n![Image 1](/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png)\n\n![Image 2](/assets/img/2024-06-23-RxJSOperatorsinAngular_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- filter : 이 연산자는 옵저버블에서 방출된 데이터를 필터링하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 옵저버블이 있다면, filter 연산자를 사용하여 짝수만 방출할 수 있습니다:\n\n```javascript\nimport { of } from ‘rxjs’;\nimport { filter } from ‘rxjs/operators’;\n```\n\n![RxJS Operators in Angular](/assets/img/2024-06-23-RxJSOperatorsinAngular_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_3.png)\n\n- mergeMap: 이 연산자는 여러 개의 옵저버블을 하나의 옵저버블로 병합하는 데 사용됩니다. 예를 들어 데이터 스트림을 방출하는 두 옵저버블이 있다면 mergeMap 연산자를 사용하여 두 스트림을 하나로 병합할 수 있습니다:\n\nimport { of } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-23-RxJSOperatorsinAngular_4.png)\n\n![이미지2](/assets/img/2024-06-23-RxJSOperatorsinAngular_5.png)\n\n- forkJoin: RxJS의 forkJoin 연산자는 여러 옵저버블이 완료될 때까지 기다린 다음 각 옵저버블이 발행한 마지막 값의 배열을 방출하는 데 사용됩니다. 이 연산자는 여러 요청을 동시에 수행하고 모든 요청이 완료된 후에만 작업을 수행해야 할 때 유용합니다.\n\n아래는 Angular에서 forkJoin을 사용하여 여러 HTTP 요청을 수행한 다음 결과를 결합하는 예시입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nimport { forkJoin, of } from 'rxjs';\n\nimport { HttpClient } from '@angular/common/http';\n\nconstructor(private http: HttpClient) {}\n\n![RxJS Operators in Angular 6](/assets/img/2024-06-23-RxJSOperatorsinAngular_6.png)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 HttpClient 모듈을 사용하여 두 개의 HTTP 요청을 보냈고 forkJoin 연산자를 사용하여 두 요청이 완료될 때까지 기다렸습니다. 그런 다음 구독(subscribe) 메서드를 사용하여 결과를 처리하는데, 이는 두 요청에서 마지막으로 방출된 값들의 배열입니다.\n\n또한 forkJoin은 observables의 배열을 사용할 수도 있으므로 2개 이상의 요청을 기다리는 데 사용할 수 있습니다.\n\nforkJoin은 여러 요청이 완료될 때까지 기다려야 하는 경우 유용한 연산자이며, 코드를 더 읽기 쉽고 유지 관리하기 쉽게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- switchMap: RxJS의 switchMap 연산자는 옵저버블에서 방출되는 값들을 주어진 함수를 적용하여 새로운 옵저버블로 평탄화하는 데 사용됩니다. 이 연산자는 현재 옵저버블의 값에 따라 요청을 만든 다음 값이 변경되면 새로운 옵저버블로 전환할 때 유용합니다.\n\n다음은 Angular에서 switchMap을 사용하여 검색 입력란에 입력된 텍스트를 기반으로 서버에서 사용자를 검색하는 방법의 예시입니다:\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_8.png)\n\n위 예시에서 fromEvent는 사용자가 검색 입력란에 타이핑할 때 이벤트를 방출하는 옵저버블을 만드는 데 사용되고, debounceTime 연산자는 사용자가 타이핑을 멈출 때까지 기다렸다가 값을 방출하는 데 사용됩니다. distinctUntilChanged 연산자는 값이 변경될 때만 값을 방출하고, 마지막으로 switchMap은 http 요청에 의해 생성된 새로운 옵저버블로 전환하는 데 사용됩니다. 각 새로운 keyup 이벤트마다 이전 요청이 취소되고 새로운 요청이 수행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`switchMap`는 현재 observable 값에 기반하여 새로운 observable로 전환해야 하는 시나리오를 처리하는 데 사용할 수 있는 강력한 연산자입니다. 새 값이 발행될 때 과거 요청을 취소하는 데 유용합니다.\n\n- **concatMap**: RxJS에서 Observable을 해체하여 각 값에 대해 매핑 함수를 적용하고, 그 결과 Observables를 발행된 순서대로 연결하는 연산자입니다. 배열의 각 항목에 대해 HTTP 요청을 만들기 위해 `concatMap`을 사용하는 예시가 다음에 나와 있어요:\n\n![2024-06-23-RxJSOperatorsinAngular_9.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_9.png)\n\n![2024-06-23-RxJSOperatorsinAngular_10.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제는 관찰 가능한을 만들기 위해 from을 사용하여 숫자 1, 2, 3을 방출합니다. 그런 다음 concatMap 연산자를 사용하여 각 숫자를 URL에서 JSON 객체를 가져오는 HTTP 요청으로 매핑합니다. 결과 관찰 가능은 숫자가 방출된 순서대로 JSON 객체를 방출할 것입니다.\n\n이것은 RxJS에서 사용 가능한 많은 연산자 중 일부 예시에 불과합니다. 이러한 연산자를 조합하여 다양한 사용 사례를 처리하는 강력하고 표현력 있는 데이터 파이프라인을 만들 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n계속 학습하려면 저를 따라 주세요!","ogImage":{"url":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular Reactive Forms setValue와 patchValue 함수 사용 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions","content":"\n\nsetValue() 및 patchValue() 함수는 Angular에서 반응형 폼 컨트롤을 채우는 데 사용됩니다. 두 함수의 사용 사례가 다릅니다.\n\n다음의 반응형 폼 예제와 함께 두 함수가 동작하는 방식을 이해해보겠습니다.\n\n```js\nmyForm: FormGroup;\n\nconstructor(private fb: FormBuilder) {}\n\nngOnInit() {\n  this.myForm = this.fb.group({\n    firstName: ['', Validators.required],\n    lastName: ['', Validators.required],\n    email: ['', [Validators.required, Validators.email]],\n  });\n}\n```\n\n- setValue() 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsetValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  setValueExample() {\n    this.myForm.setValue({\n      firstName: 'John',\n      lastName: 'Doe',\n      email: 'john.doe@example.com',\n    });\n  }\n```\n\nsetValue() 함수는 폼의 모든 컨트롤을 업데이트하고 싶을 때 사용됩니다. setValue() 함수를 사용할 때에는 모든 컨트롤 값을 제공해야 하므로 부분 데이터가 있는 경우나 폼의 모든 컨트롤을 채우고 싶지 않은 경우에는 이 함수를 사용할 수 없습니다.\n\n2. patchValue() 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npatchValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  patchValueExample() {\n    this.myForm.patchValue({\n      firstName: 'UpdatedFirstName',\n      lastName: 'UpdatedLastName',\n    });\n  }\n```\n\npatchValue() 함수는 반응형 폼의 모든 컨트롤을 업데이트하고 싶지 않을 때 사용됩니다. 폼의 일부 컨트롤만 채우고 싶을 때 사용됩니다.\n\n예를 들어, 폼에 선택 사항 입력란이 하나 있고 사용자가 해당 입력란을 작성하지 않았을 때, 이 값을 데이터베이스에 null 또는 빈 문자열로 저장할 수 있습니다. 따라서 폼 컨트롤을 채울 때 이 입력 컨트롤을 업데이트하거나 채우고 싶지 않을 수 있습니다. 이럴 때 patch value를 사용할 수 있습니다. 이 함수를 사용하면 부분 폼 컨트롤을 채울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발자들은 사용 사례 시나리오에 따라 두 함수를 모두 사용합니다. setValue() 함수는 양식의 모든 컨트롤을 필수적으로 채우려 할 때 사용하고, patchValue() 함수는 양식의 일부 컨트롤만 채우려 할 때 사용합니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png"},"coverImage":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates","content":"\n\n\n![Angular 17 Release](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png)\n\nAngular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.\n\n이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.\n\n다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (user.isHuman) {\n  \u003chuman-profile [data]=\"user\" /\u003e\n   @for (skill of user.skills; track $index) {\n     \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n   } @empty {\n    \u003cspan\u003e기술이 추가되지 않았습니다.\u003c/span\u003e\n   }\n} @else if (user.isRobot) {\n  \u003c!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. --\u003e\n  @defer {\n    \u003crobot-profile [data]=\"user\" /\u003e\n  }\n} @else {\n  \u003cp\u003e프로필을 알 수 없습니다!\u003c/p\u003e\n}\n```\n\n## @if 블록 조건\n\n@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.\n\n```js\n@if (loggedIn) {\n  환영합니다 {username}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntable 태그를 Markdown 형식으로 변경할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n}\n\n\n트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.\n\n콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:\n\n![contextual variables](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n} @empty {\n  \u003cspan\u003e 기술이 추가되지 않았습니다.\u003c/span\u003e\n}\n```\n\n## @switch 블록 — 선택\n\n다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@switch (condition) {\n@case (caseA) {\nCase A.\n}\n@case (caseB) {\nCase B.\n}\n@default {\nDefault case.\n}\n}\n```\n\nAngular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.\n\n## Angular에서 @를 선택한 이유는?\n\nAngular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 \"@-구문\"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 \"#-syntax\" 대신 커뮤니티가 제안한 \"@-syntax\"를 선호했습니다.\n\n이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:\n\n![Angular Team Survey](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png)\n\nAngular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 어떤 제어 흐름이 대체될 것인가\n\n- @switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.\n- @for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.\n\n## 구조 지시어에서 마이그레이션\n\n이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ ng generate @angular/core:control-flow\n```\n\n이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:\n\n- **박수**를 치고 작가를 팔로우 해 주세요 👏\n- 저를 팔로우 해 주세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"},"coverImage":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png","tag":["Tech"],"readingTime":4}],"page":"9","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"9"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>