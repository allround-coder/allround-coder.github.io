<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/16" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/16" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="PKG 모듈로 NestJS 빌드하기 리소스 절약의 게임 체인저" href="/post/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PKG 모듈로 NestJS 빌드하기 리소스 절약의 게임 체인저" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PKG 모듈로 NestJS 빌드하기 리소스 절약의 게임 체인저" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PKG 모듈로 NestJS 빌드하기 리소스 절약의 게임 체인저</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="100일 코딩 챌린지로 당신의 스킬을 향상시키는 방법" href="/post/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="100일 코딩 챌린지로 당신의 스킬을 향상시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="100일 코딩 챌린지로 당신의 스킬을 향상시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">100일 코딩 챌린지로 당신의 스킬을 향상시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="나쁜 추상화가 코드를 망치는 이유" href="/post/2024-06-22-BadAbstractionsCouldBeRuiningYourCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="나쁜 추상화가 코드를 망치는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BadAbstractionsCouldBeRuiningYourCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="나쁜 추상화가 코드를 망치는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">나쁜 추상화가 코드를 망치는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" Import Map, Micro Frontend, Nx Monorepo에 대해 이야기할 시간" href="/post/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" Import Map, Micro Frontend, Nx Monorepo에 대해 이야기할 시간" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" Import Map, Micro Frontend, Nx Monorepo에 대해 이야기할 시간" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl"> Import Map, Micro Frontend, Nx Monorepo에 대해 이야기할 시간</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 모멘텀 전략 구현하는 방법" href="/post/2024-06-22-MomentumStrategyusingPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 모멘텀 전략 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MomentumStrategyusingPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 모멘텀 전략 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬으로 모멘텀 전략 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PostgreSQL 데이터베이스 변경 사항을 벡터 스토어로 스트리밍하는 방법" href="/post/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PostgreSQL 데이터베이스 변경 사항을 벡터 스토어로 스트리밍하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PostgreSQL 데이터베이스 변경 사항을 벡터 스토어로 스트리밍하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PostgreSQL 데이터베이스 변경 사항을 벡터 스토어로 스트리밍하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2" href="/post/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">32<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="세션 고정이란 무엇인가요 Nodejs에서 방지하는 방법" href="/post/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="세션 고정이란 무엇인가요 Nodejs에서 방지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="세션 고정이란 무엇인가요 Nodejs에서 방지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">세션 고정이란 무엇인가요 Nodejs에서 방지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="V8 자바스크립트 엔진의 모든 것 속도, 기능, 사용법" href="/post/2024-06-22-TheV8JavaScriptEngine"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="V8 자바스크립트 엔진의 모든 것 속도, 기능, 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheV8JavaScriptEngine_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="V8 자바스크립트 엔진의 모든 것 속도, 기능, 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">V8 자바스크립트 엔진의 모든 것 속도, 기능, 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 스트림 사용하는 방법 2024 트렌드" href="/post/2024-06-22-StreamsinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 스트림 사용하는 방법 2024 트렌드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-StreamsinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 스트림 사용하는 방법 2024 트렌드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 스트림 사용하는 방법 2024 트렌드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link posts_-active__YVJEi" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"PKG 모듈로 NestJS 빌드하기 리소스 절약의 게임 체인저","description":"","date":"2024-06-22 05:55","slug":"2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_0.png\" /\u003e\n\n## 소개\n\nNestJS 개발 세계에서 효율성과 자원 관리는 매우 중요합니다. 기존의 NestJS 애플리케이션을 구축하는 전통적인 방법은 종종 오랜 시간이 소요되고 상당한 자원을 소비하는 경향이 있습니다. 가장 큰 문제 중 하나는 node_modules 디렉토리의 크기인데, 이는 많은 종속성으로 인해 지나치게 커질 수 있습니다. 이로 인해 빌드 시간이 느려지는 것뿐만 아니라 프로젝트를 관리하고 배포하기 어렵게 만들기도 합니다.\n\n여기에 pkg가 등장합니다. pkg를 활용하면 NestJS 애플리케이션 구축을 간소화하고 종속성 처리를 자동화하며 워크플로우를 최적화할 수 있습니다. 이 현대적인 방법은 일반적인 빌드 방법과 대조적으로 node_modules 디렉토리와 전체 프로젝트 크기를 대폭 줄여 자원을 효율적으로 활용하는 더 효율적이고 자원을 아끼는 대안을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, `pkg`는 코드를 바이너리로 컴파일하여 NestJS 앱을 독립적으로 만들어줍니다. 이를 통해 node_modules를 별도로 설치할 필요 없이 어디에서나 직접 실행할 수 있게 됩니다. 이 가변성은 응용 프로그램을 다양한 환경에 쉽게 배포할 수 있도록 하며, 설정 시간을 줄이고 의존성 관리와 관련된 잠재적인 문제를 줄일 수 있습니다.\n\n# 전통적인 빌드 과정\n\n전통적으로 NestJS 애플리케이션을 빌드하는 과정에는 여러 단계가 포함됩니다:\n\n- 의존성 설치: `npm install`을 사용하여 package.json에 나열된 모든 필수 패키지를 다운로드하고 설치합니다. 이로 인해 의존성이 많은 응용 프로그램의 경우 큰 node_modules 디렉토리가 생성될 수 있습니다.\n- 코드 변환: TypeScript를 사용하여 코드를 TypeScript에서 JavaScript로 변환합니다.\n- 배포: 번들 파일과 node_modules를 서버 또는 배포 환경에 업로드합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 효과적이지만 단점도 있습니다:\n\n- 크기: node_modules 디렉토리가 매우 커져서 응용 프로그램을 관리하고 배포하기 어려울 수 있습니다.\n- 시간: 각 단계는 종속성 설치부터 코드 변환 및 번들링까지 시간이 걸립니다.\n- 복잡성: 종속성 관리와 호환성 확보가 프로젝트가 커짐에 따라 어려울 수 있습니다.\n\n# PKG 접근법\n\npkg는 NestJS 애플리케이션을 단일 이진 파일로 컴파일하는 현대적인 대안을 제공합니다. 이것이 프로세스를 어떻게 간소화하는지 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 단일 이진 파일: pkg는 응용 프로그램 및 모든 종속성을 독립적인 이진 파일로 컴파일합니다. 이 이진 파일은 node_modules를 설치할 필요 없이 직접 실행할 수 있습니다.\n- 종속성 관리 축소: 종속성을 단일 이진 파일로 패키징함으로써, pkg는 배포 중 별도의 node_modules 디렉토리가 필요하지 않도록 합니다. 이를 통해 다양한 환경에서 종속성을 관리하는 복잡성을 줄일 수 있습니다.\n- 빠른 배포: 응용 프로그램이 이진 파일로 컴파일되기 때문에 배포는 더 빠르고 간단해집니다. 대상 환경에 종속성을 설치할 필요가 없어 배포 프로세스가 간소화됩니다.\n- 향상된 보안: 응용 프로그램을 이진 파일로 패키징하면 공격 표면을 줄이고 종속성을 빌드 시간에 잠금으로 설정하여 보안을 강화할 수 있습니다.\n\n## 안내: pkg 및 Docker를 사용하여 NestJS 응용 프로그램 구축 및 배포하기\n\n본 안내서에서는 NestJS 응용 프로그램을 설정하고, 리소스 효율성을 높이기 위해 pkg를 사용하여 최적화하고, Windows에서 Docker를 사용하여 배포하는 과정을 안내합니다.\n\n## 사전 요구 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 다음 항목들이 설치되어 있는지 확인하세요:\n\n- Node.js: 시스템에 Node.js가 설치되어 있는지 확인하세요. nodejs.org에서 다운로드할 수 있습니다.\n- NestJS: npm을 사용하여 NestJS를 글로벌로 설치하세요.\n\n```js\nnpm install -g @nestjs/cli\n```\n\n3. npm pkg: NestJS 애플리케이션을 독립적인 이진 파일로 패키징하는 데 전역으로 pkg를 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install -g pkg\n```\n\n4. Windows용 Docker Desktop: Docker Hub에서 Docker Desktop을 다운로드하여 설치하세요.\n\n## 단계 1: 새로운 NestJS 프로젝트 생성\n\n먼저, NestJS CLI를 사용하여 새로운 NestJS 프로젝트를 만들어보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnest new nestjs-pkg-app\ncd nestjs-pkg-app\n```\n\n이렇게 하면 nestjs-pkg-app 디렉토리에 새로운 NestJS 프로젝트가 생성됩니다.\n\n## 단계 2: pkg를 사용하여 응용 프로그램 컴파일하기\n\n다음으로, 프로젝트 디렉토리로 이동하여 pkg를 사용하여 dist 폴더 내의 main.js 파일을 컴파일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd nestjs-pkg-app\nnpm run build\npkg ./dist/main.js --out-path ./compiled\n```\n\n이 명령어는 NestJS 애플리케이션을 컴파일하여 compiled 디렉토리에 독립 실행 바이너리(main)로 만듭니다.\n\n## 단계 3: NestJS 애플리케이션을 도커화\n\n이제 NestJS 애플리케이션을 패키징하고 도커 컨테이너에서 실행할 수 있도록 Dockerfile을 생성해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 디렉토리(nestjs-pkg-app)에 Dockerfile이라는 파일을 만들어주세요. 아래 내용을 넣어주세요:\n\n```js\nFROM node:14-alpine\n\nWORKDIR /usr/src/app\n\nCOPY ./compiled ./compiled\n\nEXPOSE 3000\n\nCMD [\"/compiled/main\"]\n```\n\n## 단계 4: Docker 컨테이너 빌드 및 실행하기\n\n작성한 Dockerfile을 사용하여 Docker 이미지를 빌드해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n도커 파일에 작성된 지시 사항을 기반으로 nestjs-pkg-app라는 이름의 도커 이미지를 빌드하는 명령어입니다.\n\n이제 빌드된 이미지를 사용하여 도커 컨테이너를 실행하십시오.\n\ndocker run -p 3000:3000 nestjs-pkg-app\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령은 Docker 컨테이너를 시작하고 nestjs-pkg-app이라는 이름으로 지정하며, 로컬 머신의 포트 3000을 컨테이너 내부의 포트 3000에 매핑합니다.\n\n## 단계 5: NestJS 애플리케이션에 액세스\n\n웹 브라우저를 열고 http://localhost:3000으로 이동하여 Docker 컨테이너 내에서 실행 중인 NestJS 애플리케이션에 액세스하세요.\n\n# 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 전통적인 빌드 방식과 NestJS 애플리케이션을 빌드하고 배포하는 데 npm pkg를 사용하는 방법을 비교해보겠습니다.\n\n컴파일 없이: node_modules로 인해 대용량(약 200MB)\n\n![image](/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_1.png)\n\n컴파일 포함: 모든 종속성이 하나의 바이너리로 번들링되어 있는 속한 크기(약 51.5MB)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```\n![Building NestJS with PKG Module](/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_2.png)\n\n이 상세한 비교는 사이즈를 중점으로 하여 기존 빌드와 pkg 간의 선택 시 혜택 및 고려 사항을 독자들에게 명확히 전달해줄 것입니다.\n\n# 결론\n\n요약하면, NestJS 애플리케이션을 빌드하는 데 npm pkg를 활용하는 것은 개발 관행의 중요한 진보를 의미합니다. node_modules 디렉토리의 크기를 줄이고 싱글 이진 파일로의 간단한 배포를 통해, npm pkg는 개발자에게 더 효율적이고 확장 가능한 접근 방식을 제공합니다. 자원 사용량을 최적화하고 배포 워크플로우를 간소화하거나 보안을 강화하려는 경우, npm pkg는 현대적인 개발 요구에 부합하는 매력적인 솔루션을 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘 npm pkg를 활용하여 더 효율적이고 자원을 절약하는 NestJS 개발의 잠재력을 발휘해보세요. 당신의 프로젝트와 팀이 그것에 감사할 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingNestJSwithPKGModuleisaResource-SavingGameChanger_0.png","tag":["Tech"],"readingTime":5},{"title":"100일 코딩 챌린지로 당신의 스킬을 향상시키는 방법","description":"","date":"2024-06-22 05:54","slug":"2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge","content":"\n\n![이미지](/assets/img/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge_0.png)\n\n# 소개\n\n코딩 실력을 업그레이드할 준비가 되셨나요? 저희가 주최하는 100일 코딩 챌린지는 바로 이를 도와드립니다. GIAIC (신트 주지사 정보기술 이니셔티브)에서 이 챌린지를 진행하고 있는데, 현장에서 5만 명이 넘는 기술 학생들이 학습하고 있는 가운데 6천 명 이상이 참여해 실제로 인증을 받고 있는 것으로 확인됐습니다. 이 챌린지는 코딩에 대한 열정을 불러일으키고 여러분을 새로운 높이로 이끌어 줄 것입니다.\n\n# 배경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n100일 코딩 챌린지는 또 다른 코딩 프로젝트가 아닙니다. GIAIC의 학생 대사 및 교수진으로 활동 중인 제가 주도하는 잘 구성된 프로그램입니다. Sir Daniyal Nagori(CEO)와 Sir Ameen Alam(교수진원장)과 같은 산업 지도자들의 지원을 받아, 100명 이상의 교수진 구성원들과 함께 최신 코딩 기술을 가르치는 것이 목표입니다. 저희는 JavaScript, TypeScript, Web 개발, React 및 Next.js에 초점을 맞추고 있습니다.\n\n# 목표\n\n100일 동안 무엇을 이룰 수 있을까요? 우리가 추구하는 바는 다음과 같습니다:\n\n- 주요 기술 마스터: JavaScript, TypeScript, Web 개발, React 및 Next.js에 대해 심도있게 공부해 보세요.\n- 실제 프로젝트 구축: 산업에 준비되도록 하는 실용적인 프로젝트를 진행해 보세요.\n- 일관성 유지: 매일 코딩하는 습관을 길러주세요. 어떤 기술도 마스터하기에 중요합니다.\n- 커뮤니티 지원: 당신을 격려하고 모든 단계에서 도와 줄 번창하는 커뮤니티와 소통해 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 매일 참여\n\n매일 참여자들을 어떻게 숙련되고 동기부여시킬까요?\n\n저희의 디스코드 커뮤니티에서 매일 아침 새로운 도전이 당신을 기다리는 모습을 상상해보세요. 까다로운 코드 디버깅부터 완전한 웹 애플리케이션을 만드는 것까지, 매일의 과제는 학습 경험을 향상시키고 당신을 기습 상태로 유지하도록 설계되어 있습니다.\n\n- 구조화된 학습 경로: 매일의 도전은 이전에 배운 내용에 기반을 둡니다.\n- 동료 지원: 저희의 디스코드 커뮤니티는 항상 활동적이며, 지원을 제공하고 팁을 공유하며 마일스톤을 축하합니다.\n- 전문 가이드: 경험이 풍부한 멘토들로부터의 정기적인 체크인과 피드백을 통해 당신이 목표를 달성할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원\n\n코딩 여정을 지원하기 위한 다양한 자원을 제공합니다:\n\n- GitHub 저장소: GitHub 저장소에서 모든 챌린지와 프로젝트 템플릿에 액세스할 수 있습니다. 포크하고 스타를 눌러서 여러분만의 코딩 놀이터를 만들어보세요!\n- 공식 웹사이트: 챌린지에 대한 자세한 정보와 과제 및 자원의 날짜별 분할에 대해 알아보기 위해 공식 웹사이트를 방문해주세요.\n- 디스코드 커뮤니티: 활기찬 디스코드 커뮤니티에 참여하여 다른 코더들과 연결하고 토론에 참여하며 즉각적인 지원을 받아보세요.\n\n# 주요 분야\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발 세계에서 최신 기술을 업데이트하는 것이 중요합니다. 그래서 우리의 도전 과제는 다음과 같이 집중됩니다:\n\n- JavaScript: 웹 개발의 중추로, 동적 웹 애플리케이션을 만드는 데 필수적입니다.\n- TypeScript: TypeScript로 JavaScript를 업그레이드하여 타입 안전성을 추가하고 코드 품질을 향상시킵니다.\n- 웹 개발: 웹 애플리케이션을 구축하고 배포하는 기초를 마스터합니다.\n- 인터넷 기초: 인터넷이 제공하는 모든 훌륭한 기능과 함께 인터넷의 기초를 마스터합니다.\n- React: 가장 인기 있는 JavaScript 라이브러리 중 하나로 사용자 인터페이스를 구축하는 방법을 배웁니다.\n- Next.js: 이 강력한 React 프레임워크로 쉽게 서버 렌더링 애플리케이션을 구축합니다.\n\n# 커뮤니티 영향\n\n100일 코딩 챌린지의 실제 힘은 커뮤니티에 있습니다. 여기 우리 참가자들의 몇 가지 성공 이야기가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Sarah Khan: \"이 도전에 참여한 것이 내 커리어를 위해 한 최고의 결정 중 하나였어요. 매일의 과제는 도전적이었지만 보람 있었고, 커뮤니티의 지원이 제게 힘을 주었어요. 이제는 자신 있게 React 애플리케이션을 개발할 수 있어요!\"\n- Ali Raza: \"이 도전의 구조와 일관성 덕분에 저는 규율적으로 작업을 계속할 수 있었어요. 실습 프로젝트와 멘토들로부터의 실시간 피드백을 즐겼어요. 웹 개발에 진지한 분이라면 필수적인 도전이에요.\"\n- Fatima Ahmed: \"이 도전에 참여하기 전에 새로운 기술들과 발목을 잡혔었어요. 올바른 지침과 자원으로 100일 동안 얼마나 많은 것을 배울 수 있는지 놀라웠어요.\"\n\n# 결론\n\n코딩 스킬을 다음 수준으로 끌어올리기 준비가 되셨나요? 오늘 100일 코딩 도전에 참여하여 계속해서 배우고 성장하는 개발자들의 세계적인 운동의 일원이 되어보세요. 시작하려는 초보자든 기술을 갈고 닦고자 하는 숙련된 개발자든, 이 도전은 여러분을 위해 설계되었습니다.\n\n공식 웹사이트를 방문하고 GitHub 저장소를 확인하며, 디스코드 커뮤니티에 참여하여 시작해보세요. 함께 코딩하고 배우며 함께 성장해요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge_1.png)\n\n최신 첨단 기술 소식을 받아보세요! 저를 팔로우해주세요:\n\n- 트위터: @0xAsharib\n- 링크드인: Asharib Ali\n- 깃허브: AsharibAli\n- 웹사이트: asharib.xyz\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge_0.png"},"coverImage":"/assets/img/2024-06-22-TransformYourSkillswiththe100-Days-of-CodingChallenge_0.png","tag":["Tech"],"readingTime":3},{"title":"나쁜 추상화가 코드를 망치는 이유","description":"","date":"2024-06-22 05:50","slug":"2024-06-22-BadAbstractionsCouldBeRuiningYourCode","content":"\n\n상당히 큰 코드베이스에서 작업 중이라고 상상해 봅시다. 다음 코드에서 문제점을 발견하셨나요?\n\n```js\nconst icons = {\n  delete: getIconPath(\"delete\"),\n  edit: getIconPath(\"edit\"),\n  save: getIconPath(\"save\"),\n};\n```","ogImage":{"url":"/assets/img/2024-06-22-BadAbstractionsCouldBeRuiningYourCode_0.png"},"coverImage":"/assets/img/2024-06-22-BadAbstractionsCouldBeRuiningYourCode_0.png","tag":["Tech"],"readingTime":1},{"title":" Import Map, Micro Frontend, Nx Monorepo에 대해 이야기할 시간","description":"","date":"2024-06-22 05:47","slug":"2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo","content":"\n\n## Native Import Map Overrides를 활용하여 마이크로 프론트엔드 아키텍처에 상당한 이점을 얻는 방법\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_0.png)\n\n이 기사에서는 대규모 기업의 복잡한 인프라 및 팀 조직을 위한 소프트웨어 개발에 대한 내 인식을 근본적으로 바꾼 아키텍처에 대해 공유하고 있습니다.\n\n오랜 시간 동안 이 기사를 쓰고 싶었는데, 이제 그 때입니다! 언제나 표준을 준수하는 것을 중요시해왔고, 최신 도구로 이 아키텍처를 올바르게 다룰 준비가 되었다고 믿습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesbuild의 등장, 브라우저에서 ES 모듈의 네이티브 지원, import map의 널리 퍼져가는 채택, Native Federation과 같은 도구의 등장, 그리고 Nx 생태계가 모두 결합되어 유연하고 잘 유지되는 Micro Frontend Architecture를 형성하고 있습니다.\n\n제가 다룰 내용은:\n- 실제 이야기!\n- 브라우저에 대한 간단한 상기\n- 간략한 Micro Frontend Architecture 소개\n- Import Map이란 무엇인가?\n- Import Maps와 Overrides의 전체 잠재력 탐색\n- Nx가 확장 가능한 Micro Frontend Architecture를 가능하게 하는 이유\n- Native Federation은 무엇일까?\n- 마지막으로\n\n# 실제 이야기!\n\n컨텍스트를 조금 더 제공해 드리기 위해, 여러 개의 AngularJS 애플리케이션을 더 최신의 Angular 프레임워크로 마이그레이션하도록 주도했습니다. 클라이언트는 AngularJS가 폐기되었다는 공지를 받은 후에 마침내 그 결정을 내렸습니다 (최신 정보 확인을 부탁드려요 🙏).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 마이그레이션 프로세스를 사용하는 것이 불가능했어요. 여러 시나리오를 조사한 후에 마이크로 프론트엔드 아키텍처를 선택했어요. 저희가 본 것처럼, 이는 점진적인 마이그레이션을 용이하게 하고, 격리를 제공하며, 여러 팀의 앱을 하나의 통합 플랫폼으로 통합할 수 있도록 도와줄 수 있어요.\n\n당시에는 마이크로 프론트엔드 아키텍처가 아직 인기가 없었고, single-spa 라이브러리만 충분히 성숙했어요. 이는 AngularJS와 Angular을 포함한 여러 프레임워크를 지원하여 우리에게 완벽한 선택이었어요!\n\nSingle-spa는 기능 플래그를 기반으로 AngularJS 또는 Angular 구현체 간에 전환하여 마이크로 프론트엔드를 조정해줘요:\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsingle-spa를 사용하면서 마이크로 프론트엔드 아키텍처를 구현하는 것에 대한 이해가 크게 향상되었고, 특히 import map 및 마이크로 프론트엔드 오버라이드의 중요한 이점을 강조했습니다. 이러한 도구들은 로컬 개발, 테스트, 배포 경험을 크게 향상시켰습니다.\n\n# 브라우저에 대한 간단한 알림\n\n다음 내용을 이해하기 위해 먼저 브라우저가 웹 애플리케이션을 실행하는 기본 흐름에 대한 기본 사항을 상기하는 것이 중요하다고 생각합니다:\n\n![웹 브라우저 플로우](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 첫 번째 단계는 언제나 애플리케이션을 시작하는 데 필요한 모든 것을 갖춘 index.html 파일을 가져오는 것입니다.\n- 그런 다음, 브라우저는 index.html에서 지시한 모든 파일을 로드합니다. 이로는 주로 JavaScript 및 스타일 시트와 같은 애플리케이션의 주 파일들이 포함됩니다.\n- 그 후에는 애플리케이션 또는 사용자 상호작용에 의해 더 많은 요청이 발생하고, 예를 들어 API를 호출하거나 필요한 기능을 로드하는 것이 있습니다.\n\n# 간단히 말하는 마이크로 프론트엔드 아키텍처\n\n간단한 정의부터 시작해봅시다: 마이크로 프론트엔드 아키텍처는 프론트엔드 애플리케이션을 더 작고 관리하기 쉬운 조각으로 나누는 것을 포함합니다. 각 조각은 애플리케이션의 특정 기능이나 도메인을 담당합니다. 이는 종종 마이크로서비스 개념과 비교되지만 프론트엔드 레이어에서 이루어집니다.\n\n애플리케이션이 마이크로 프론트엔드 아키텍처를 따르는지 정확히 판단하는 것은 마이크로서비스의 이상적 크기를 정의하는 것과 마찬가지로 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핵심은 여러 기능을 통합해 하나의 애플리케이션을 만들 수 있는 플랫폼을 갖는 것입니다. 이러한 기능들이 Lazy-loaded 구성 요소이든 마이크로 프론트엔드이든, 원칙은 본질적으로 동일합니다.\n\n## 언제 잘 어울리나요?\n\n마이크로 프론트엔드 아키텍처가 유용한 다양한 사용 사례가 있습니다:\n\n![마이크로 프론트엔드 사용 예시](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 프레임워크: 가장 일반적인 사용 사례는 다양한 기술을 하나의 제품으로 통합하는 것인데, 특히 분리된 시스템을 통합하는 데 유용합니다.\n- 팀 분산화: 팀이 독립적으로 작동할 때, 모놀리폴더(monorepo) 내에서 작동하거나 다른 저장소에서 작동하는 경우, 마이크로 프론트엔드는 그들의 작업을 하나의 일관된 제품으로 통합하기를 쉽게 만들어줍니다.\n- 관심사의 분리: 응용 프로그램을 격리된 도메인 및 기능으로 구성하여 더 나은 조직을 위한 이상적입니다.\n- 복잡한 인프라: 기존 환경에 마이크로 프론트엔드를 플러그인하는 능력은 개발 경험을 크게 향상시킬 수 있습니다! 나중에 이 이미유에 대해 자세히 다루겠습니다.\n\n## 주요 개념\n\n마이크로 프론트엔드 아키텍처에서는 각기 다른 개념을 따르는 다양한 종류의 엔터티를 구분합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마이크로 프론트엔드(또는 마이크로 앱)은 호스트가 탐색 또는 라우팅 시에 로드됩니다. 각 마이크로 프론트엔드는 응용 프로그램 내에서 구분된 기능 또는 도메인에 대해 책임을 집니다. 다른 앱과 마찬가지로 자식 라우트와 여러 컴포넌트를 포함할 수 있습니다.\n- 파셀(컴포넌트 또는 노출로도 불림)은 필요 시 독립적으로 로드됩니다. 공유 컴포넌트나 공유 서비스가 될 수 있으며 어디에서나 플러그인할 수 있습니다.\n\n## 도구/프레임워크\n\n마이크로 프론트엔드 아키텍처의 여러 구현이 있으며, 여기서 세 가지 주목할 만한 것에 대해 알아보겠습니다:\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Single-spa: 이 프레임워크는 간단하게 유지되며 여러 기술과 함께 작동합니다. 하지만 그 간단함은 한 가지 기술만 사용하는 경우 더 많은 작업을 해야 할 수도 있음을 의미할 수 있습니다.\n- Webpack Module Federation: 거의 모두가 Webpack을 사용하며, 모듈 페더레이션 기능으로 이 사용자들에게 마이크로 프론트엔드를 쉽게 만들어줍니다. 하지만 다른 도구를 사용하는 경우 다른 해결책을 찾아야 할 수도 있습니다.\n- Native Federation: 이 방법은 Webpack의 방법론의 쉬움을 최신 도구인 esbuild나 Vite와 결합하여, 현대적인 개발 관행과 잘 어울리면서 마이크로 프론트엔드 아키텍처를 지원합니다.\n\n# Import Map이란 무엇인가요?\n\n가장 흥미로운 측면부터 시작해보죠. 내 의견으로는, 임포트 맵은 브라우저 기술 중에서 과소평가된 기술입니다. 모든 브라우저와 호환되며, 브라우저에서 직접 JavaScript 모듈을 지원하는 데 역할을 합니다.\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 어떻게 작동합니까?\n\n원리는 매우 간단합니다. ES 모듈이 JavaScript 생태계에 도입된 이후로, 우리 모두가 다음과 같은 구문을 사용하기 시작했습니다:\n\n```js\nimport moment from \"moment\";\nimport { partition } from \"lodash\";  \n```\n\n그러나 브라우저에서 ES 모듈을 네이티브로 사용할 때는 JS 파일의 전체 경로를 지정해야 합니다. 다음과 같이:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport moment from \"https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js\";\nimport { partition } from \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js\";\n```\n\n이 방식은 가독성이나 유지보수 측면에서 좋지 않죠? 그래서 라이브러리 이름을 URL에 매핑하는 import map이 만들어졌습니다:\n\n```js\n\u003cscript type=\"importmap\"\u003e\n{\n  \"imports\": {\n    \"moment\": \"https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js\",\n    \"lodash\": \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js\"\n  }\n}\n\u003c/script\u003e\n```\n\n이것은 TypeScript의 경로 매핑과 유사하게 동작하지만 브라우저에서 직접 작동합니다. 이제 동일한 구문을 사용하여 모듈을 로컬로 불러오거나 브라우저에서 불러올 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 임포트 맵은 다음과 같이 인라인으로 지정하거나 외부 파일로 지정할 수 있습니다.\n\n```js\n\u003cscript type=\"importmap\" src=\"assets/shared.importmap.json\"\u003e\u003c/script\u003e\n\u003cscript type=\"importmap\" src=\"assets/remotes.importmap.json\"\u003e\u003c/script\u003e\n```\n\n## 이것이 마이크로 프론트엔드 아키텍처와 어떤 관련이 있나요?\n\n제가 언급한대로, 마이크로 프론트엔드 아키텍처는 브라우저에서 번들을 동적으로로드하고 실제 앱에 통합하는 방법일 뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 관리는 호스트의 역할입니다. 그러나 호스트가 ES 모듈을 로드해야 할 때는, 간단히 JS import 시스템을 활용하여, import 맵의 도움을 받아 해당 모듈을 위치에 매핑할 수 있습니다.\n\n비슷하게, 파셀의 경우, 필요할 때 컴포넌트를 로드해야 할 경우, import 맵은 JS import를 현재 위치로 매핑할 것입니다.\n\n## Import Maps은 덮어쓸 수 있습니다!\n\n동일한 HTML에서 여러 import 맵을 선언할 수 있습니다. 이는 두 개의 import 맵이 동일한 키를 선언할 경우, 마지막 것이 이전 것을 덮어쓸 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'img' 태그를 Markdown 형식으로 바꿔보세요.\n\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_7.png)\n\nHTML에 새로운 import map을 주입함으로써, 어떤 번들이든 후킹/매핑할 수 있습니다. 따라서, 마이크로 프론트엔드, 구성 요소, 심지어 공유 라이브러리를 대체할 수 있습니다!\n\n## 보안\n\n웹 응용 프로그램에서 import map을 덮어 쓰는 것은 보안을 감소시키지 않습니다. 왜냐하면 모든 프론트엔드 자산은 공개되어 있고 클라이언트 측에서 수정할 수 있기 때문입니다. 그러나 여러 서버로부터 자산을로드하는 응용 프로그램의 경우, Content-Security-Policy (CSP)를 구성하는 것이 중요합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSP는 신뢰할 수 있는 도메인 목록을 화이트리스트로 지정하여 크로스사이트 스크립팅(XSS) 및 기타 보안 위협의 위험을 크게 줄입니다. 이 보안 조치는 클라이언트 측 수정이 가능하더라도 응용 프로그램의 무결성과 사용자 안전을 유지합니다.\n\n# Import Maps 및 Overrides의 전체 잠재력 탐색\n\n임포트 맵 및 번들 로딩을 브라우저에서 직접 오버라이드할 수 있다는 원리를 이해했으니, 이 개념을 개발 프로세스 내에서 어떻게 활용할 수 있는지 알아봅시다:\n\n![image](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 로컬 개발\n\n대규모 조직에서 복잡한 로컬 환경을 설정하는 것은 종종 다음과 같은 일들을 수반합니다:\n\n- 로컬 머신 설정을 위해 하루 이상 소요될 수 있음.\n- 백엔드 시스템, 로컬 데이터베이스 또는 외부 환경과의 연결, 로컬 대기 시스템 등과 같은 다양한 소프트웨어 설치.\n- 다중 테넌트에 대한 설정 조정.\n- 아침에 로컬 환경이 부팅될 때까지 기다리면서 커피를 마시며 그 날을 유지될 것을 기대하는 것.\n\n특히 UI를 소량 수정해야 할 때 이러한 복잡성은 상당히 괴로울 수 있습니다. 이 정확한 도전에 대처하기 위해 마이크로 프론트엔드 아키텍처와 import 맵 오버라이드를 결합한 방식으로 대응하려고 노력했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n복잡한 전체 시스템을 실행하는 대신, 로컬 환경을 외부 환경에 연결하여 이미 구축된 복잡성을 사용할 수 있습니다.\n\n이렇게 하려면 로컬에서 마이크로 프론트엔드를 제공하고 원격 환경에서 임포트 맵 오버라이드 원칙을 사용하면 됩니다.\n\n새로 고침 후 브라우저에서 로드되는 마이크로 프론트엔드는 원격 서버에 있는 것이 아니라 로컬 컴퓨터에 있는 것입니다.\n\n중요한 점은 최신 메인 브랜치를 포함하는 실제 환경에 코드를 직접 통합하고 있다는 것입니다. 이는 우리가 \"내 컴퓨터에서는 작동하는데!\"라는 유명한 시나리오를 넘어설 수 있음을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 풀 리퀘스트\n\n구현을 완료했고 (그리고 테스트까지 완료했다😋), 주로 공유 코드베이스로 코드를 병합하기 위해 풀 리퀘스트를 생성합니다.\n\n리뷰 용이성\n다시 한 번 중요한 것은, 리뷰 프로세스를 더 쉽게 만들기 위해 import map overriding의 이점을 활용할 수 있습니다. 리뷰어들이 배포하거나 로컬로 코드를 클론할 필요 없이 변경 사항을 확인할 수 있도록 해줍니다:\n\n이 단계에서 CI는 앱을 빌드하고 수정된 마이크로 프론트엔드를 위한 새 번들을 생성합니다. 또한 업데이트된 번들로 영향을 받는 importmap.json을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI e2e 테스트를 간소화하세요\nUI 테스트 (모의)에 영향을 받은 import 맵을 사용할 수도 있습니다. 이 시나리오에서 생성된 영향을 받은 importmap.json은 Playwright 또는 Cypress와 같은 도구에 주입되어 영향을 받은 마이크로 프론트엔드를 직접 테스트할 수 있습니다.\n\n## 승인\n\n이 단계는 코드가 프로덕션 배포 준비가 되었는지 확인해야 하는 시점을 의미합니다. 이를 CI에서 자동화하거나 수동으로 할 수 있습니다 (자동화 부탁드려요 🙏).\n\n일반적으로 이는 하루에 여러 번 실행되며, 가장 최신의 코드베이스가 프로덕션을 모방하는 환경에서 실행됩니다. 이 시나리오에서는 모든 번들의 최신 버전을 포함하는 importmap.json을 생성할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 생성된 최근 importmap.json이 성공적이라면, 이는 프로덕션을 위한 릴리스 후보가 될 수 있습니다.\n\n## 프로덕션\n\n릴리스가 검증되고 준비가 되었다면, 프로덕션으로 배포를 고려할 수 있습니다. 여기에서도 importmap.json을 갖는 것은 상당한 장점을 제공합니다.\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시큐리티에 배포\n프로덕션 환경으로 번들을 언제든지 배포하거나 업로드할 수 있습니다. importmap.json이 그들을 참조할 때까지 로드되지 않습니다. 그러므로 배포는 최신 import map을 수정하고 업로드하는 것만으로 이루어집니다. 이 배포 과정은 단순히 1초만 소요되며 동결이 필요하지 않으며 사용자에게는 완전히 투명합니다.\n\n이전 번들은 캐시에 유지\n또한 importmap.json은 이전 버전의 번들을 아직 참조할 수 있다는 점이 중요합니다. 사실, 일부 마이크로 프론트엔드가 수정되지 않았다면 그들을 위한 새 버전을 생성할 필요가 없습니다.\n\n이는 사용자들이 그들의 브라우저에 이미 캐시되어 있는 기존 버전을 다시로드할 필요가 없다는 것을 의미합니다. 반면, importmap.json은 절대로 캐시되어서는 안됩니다!\n\n카나리아 배포 및 A/B 테스팅\nimportmap.json의 마지막이자 무시할 수 없는 혜택은 동적으로 생성될 수 있다는 것입니다. 이는 마이크로 프론트엔드가 이전 버전 또는 새 버전을 로드해야 할지 결정할 수 있음을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로, 특징 플래그나 인증 사용자 기준에 따라 A/B 테스트나 카나리 배포를 쉽게 진행할 수 있습니다!\n\n# Nx가 확장 가능한 마이크로 프론트엔드 아키텍처를 가능하게 합니다\n\n이 글에서는 Nx의 모든 이점에 대해 깊이 파헤치지는 않겠습니다. 이에 관한 내용은 이전 글에서 상세히 다루었으니, 더 자세한 정보는 Nx 웹사이트를 참고하시기 바랍니다.\n\nJavaScript/TypeScript 저장소에만 한정되지 않고 어떤 코드베이스에도 제공되는 가치에 대한 나의 확신은 확고합니다. 공유, 가시성, 성능 향상, 그리고 관행 준수를 강화하는 Nx의 장점은 보편적으로 적용 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 표 형식을 Markdown 형식으로 변경해 보세요.\n\n## Monorepo와 Micro Frontend은 정반대인가요?\n\n결코 그렇지 않아요! Monorepo는 코드 유지 보수, 빌드 및 통합 프로세스를 향상시키는 가치를 더합니다. 반면, 마이크로 프론트엔드 아키텍처는 실행 시 혜택을 제공합니다.\n\n두 전략 모두 관심사 분리와 재사용성을 지지하며, 마이크로 프론트엔드를 모노레포에 포함시킴으로써 상당한 이점을 보여줍니다.\n\n## 영향을 받는 마이크로 프론트엔드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n녋스에서 중요한 개념은 영향을 받은 코드에서 작업을 수행하는 능력입니다. 이 기능은 로컬 개발을 간소화하여 원격 환경에서 한 번에 하나의 마이크로 프론트엔드에 작업할 수 있도록 도와줍니다.\n\n빌드, 린트, 테스트와 같은 작업을 영향을 받은 마이크로 프론트엔드에만 제한함으로써 CI/CD 프로세스의 효율성을 크게 향상시킬 수 있습니다. 영향을 받은 마이크로 프론트엔드를 나열하는 영향 파일(importmap.json)을 활용하면 기존 환경에서 PR을 테스트하고 e2e 테스트를 실행하며 점진적인 배포를 용이하게 할 수 있습니다.\n\n## 단일 버전 정책\n\n독립성과 격리는 마이크로 프론트엔드 아키텍처의 핵심 원칙이지만, 일부 서비스와 컴포넌트를 모든 인스턴스 간에 공유하는 것은 불가피합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단일 버전 정책과 결합된 모노 레포 접근 방식은 마이크로 프론트엔드가 서로 호환되어 융성적인 생태계를 유지하도록 보장합니다.\n\n# Native Federation에 대해 어떻게 생각하세요?\n\n처음에 언급한 것처럼, 이제 생태계가 충분히 성숙해져 Angular이나 esbuild를 사용하는 다른 프레임워크를 사용하여 Nx 모노레포 내에서 Native Federation을 적용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n죄송하지만 Native Federation과 함께 import map overrides를 구현하지 못했습니다. 그러나 이 문제는 현재 GitHub에서 논의 중입니다:\n\n해당 원칙은 변함없이 유지됩니다. importmap.json을 직접 사용하는 대신 federation.manifest.json을 재정의할 수 있는 옵션이 있습니다. 이는 응용 프로그램 내에서 사용자 정의 코드를 생성하여 번들 재정의를 활성화해야 합니다.\n\n## 해보고 싶으신가요?\n\n- 먼저, 내 GitHub 저장소를 복제하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngit clone git@github.com:jogelin/nx-nf.git \u0026\u0026 cd nx-nf\n```\n\n2. 원하는 패키지를 설치하기 시작하세요:\n\n```js\npnpm install\n```\n\n3. 다음으로, mf-admin과 같이 마이크로 프론트엔드 하나를 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx nx run mf-admin:serve\n```\n\n4. 그런 다음, 이미 배포된 애플리케이션의 URL인 https://nx-nf-a2d7c.web.app/admin 에 접속하세요. 아래의 이미지와 같이 애플리케이션을 확인할 수 있을 거예요:\n\n![애플리케이션 이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_11.png)\n\n5. 이제, 즐겨 사용하는 브라우저 디버깅 도구를 열고 로컬 서버를 원격 애플리케이션에 연결하려면 로컬 스토리지에 이 항목을 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlocalStorage.setItem('native-federation-override:mfAdmin', 'http://localhost:4203/remoteEntry.json') // mfAdmin을 로컬 서버로 오버라이드합니다\n```\n\n6. 이후에, mf-admin 마이크로 프론트엔드에 수정을 가해주세요. 예를 들어, \"어드민 페이지에 오신 것을 환영합니다\" 메시지를 \"로컬 어드민 페이지에 오신 것을 환영합니다\"로 변경하세요.\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_12.png)\n\n7. 변경 사항을 적용한 후 페이지를 새로고침하면, 원격 서버에 즉시 변경 사항이 반영된 것을 확인할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_13.png\" /\u003e\n\n8. 변경 사항을 되돌리려면 로컬 스토리지에서 항목을 제거하고 페이지를 새로 고쳐서 원래 상태를 다시 확인하실 수 있습니다.\n\n```js\nlocalStorage.removeItem('native-federation-override:mfAdmin');\n```\n\n이 방법을 사용하여 모든 마이크로 프론트 엔드를 재정의할 수 있습니다. 그러나 앞서 말씀드린 대로, 네이티브 페데레이션을 사용하는 방법은 import 맵의 기본 동작을 사용하지 않기 때문에 완전히 네이티브한 것은 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 GitHub 저장소에서 Native Federation, Angular 및 Nx를 활용한 모든 코드를 찾아볼 수 있어요.\n\n# 최종 생각\n\n이 탐구를 통해 브라우저의 네이티브 JavaScript 생태계의 강력함을 발견하고 네이티브 ES 모듈에 대한 지원이 더 빠른 빌드 시간 이상의 개발 경험을 향상시킨다는 것을 강조했어요.\n\nimport 맵 원칙의 단순함과 효과적인 접근 방식은 우아한 해결책으로 복잡한 문제를 해결하는 방법을 보여줍니다. 향후 개발이 더 원활하고 직관적으로 되는 곳을 힌트로 알려주며, 네이티브 브라우저 기능을 선호함으로써 맞춤형 프레임워크 구현에 대한 의존성이 줄어드는 미래를 예측합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게다가, 이 생태계의 일부로서 Nx의 사용은 개발자들이 증진된 민첩성과 정밀성으로 복잡한 프로젝트에 접근할 수 있도록 강력한 도구 모음을 제공합니다.\n\n이와 같은 네이티브 기능들에 대한 더 많은 기대가 높아지고 있으며, 더 간단하면서도 더 강력한 개발 환경이 약속되고 있습니다. Nx와 브라우저 기능의 발전으로, 우리는 고도의 웹 애플리케이션을 구축하는 것이 더욱 접근 가능하고 효율적인 미래로 나아가고 있습니다.\n\n🚀 기대해 주세요!\n\n# 크레딧\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 조엘 데닝\n\n조엘 데닝은 single-spa의 비전을 이루어낸 인물로, 웹의 진정한 메커니즘에 대한 깊은 통찰력을 자랑하며, 내 의견으로는 마이크로 프론트엔드 아키텍처의 선구자입니다. single-spa 웹사이트와 그의 유튜브 채널을 꼭 확인해보시길 권해드립니다. 비디오가 초창기로 보일지라도, 조엘은 시대를 앞서가고 있으며, 내용은 오늘날에도 여전히 매우 관련성 있습니다.\n\n![이미지](/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_14.png)\n\n## 만프레드 슈타이어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nManfred는 엔지니어, 건축가, 강연가, 트레이너, 컨설턴트 및 작가로, 이야기를 잘 알고 있습니다. Angular뿐만 아니라 모든 사람들을 위해, 마이크로 프런트엔드 및 웹 아키텍처에 관심이 있는 분들에게 Manfred의 책 'Enterprise Angular: Micro Frontends and Moduliths with Angular'과 Angular Architect 팀의 블로그를 살펴보기를 적극 권유합니다.\n\n# 관련 정보\n\n# 쉽게 이해하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수와 팔로우 해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_0.png"},"coverImage":"/assets/img/2024-06-22-ItsTimetoTalkAboutImportMapMicroFrontendandNxMonorepo_0.png","tag":["Tech"],"readingTime":14},{"title":"파이썬으로 모멘텀 전략 구현하는 방법","description":"","date":"2024-06-22 05:44","slug":"2024-06-22-MomentumStrategyusingPython","content":"\n\n이번 주에는 점심 시간에 몇몇 동료들과 흥미로운 대화를 나누었습니다. 그들은 투자에 어떤 방법론을 사용하는지 물어보았어요. 저는 '모멘텀 투자'를 사용한다고 언급했는데, 그들은 정확히 무슨 의미인지 이해하기 어려워했어요. 그래서 이 기사를 쓰기로 결심했습니다. 제가 모멘텀 투자를 위해 따르는 단계를 설명하겠습니다.\n\n# 모멘텀 투자란?\n\n모멘텀 투자는 시장에서 이미 존재하는 추세를 기반으로 이익을 얻고자 하는 강력한 전략입니다. 지난 성과가 우수한 주식에 집중함으로써, 투자자들은 모멘텀의 흐름을 타고 인상적인 수익을 얻을 수 있을지도 모릅니다. 이 기사에서는 Nifty 50 주식을 위한 모멘텀 전략에 대해 자세히 살펴보고, 그 방법론을 설명하며 해당 전략을 구현하는 데 도움이 되는 Python 코드 조각을 제공할 것입니다.\n\n모멘텀 투자는 과거에 우수한 성과를 보인 주식이 가까운 미래에도 계속 우수한 성과를 내리라는 전제에 기반합니다. 이 전략은 특정 기간 동안(예: 지난 1년) 우수한 성과를 보인 주식을 매수하고, 일정 기간(예: 1개월) 보유한 후 포트폴리오를 재평가하는 것을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전략 개요\n\n우리의 모멘텀 전략은 다음과 같은 간단한 단계로 구성되어 있습니다:\n\n- 주식의 우주 선택: 여기서는 Nifty 50 주식에 초점을 맞출 것입니다.\n- 과거 수익률 계산: 각 주식에 대해 12개월 수익률을 계산합니다.\n- 주식 순위 매기기: 주식을 12개월 수익률에 기반하여 순위 매깁니다.\n- 최고 주식 선택: 수익률이 가장 높은 상위 10개 주식을 선택합니다.\n- 매월 리밸런싱: 매달 포트폴리오를 재평가하고 리밸런싱합니다.\n\n# 전략 백테스팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백테스팅은 거래 전략의 성과를 평가하는 데 중요합니다. 이전 데이터에 전략을 적용하여 과거 성과를 평가하고 잠재적인 미래 성과에 대한 통찰력을 얻을 수 있습니다.\n\n파이썬을 사용하여 이 전략을 3년 동안 백테스트하고 해당 결과를 지수(여기서는 Nifty50)의 매수 및 보유 전략과 비교해보겠습니다.\n\n## 단계 1: 데이터 수집\n\n먼저, 지난 3년간 Nifty 50 주식의 히스토리컬 가격 데이터를 수집해야 합니다. 여기서는 야후 파이낸스 API를 사용하여 지난 3년간의 히스토리컬 데이터를 가져왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\n\n# Nifty 50 주식 기호 목록\nnifty50_symbols = [\"RELIANCE.NS\", \"HDFCBANK.NS\", \"INFY.NS\", \"ICICIBANK.NS\", \"TCS.NS\", \"KOTAKBANK.NS\", \n                   \"HINDUNILVR.NS\", \"SBIN.NS\", \"BHARTIARTL.NS\", \"HDFC.NS\", \"ITC.NS\", \"BAJFINANCE.NS\", \n                   \"ASIANPAINT.NS\", \"HCLTECH.NS\", \"LT.NS\", \"MARUTI.NS\", \"AXISBANK.NS\", \"ULTRACEMCO.NS\", \n                   \"WIPRO.NS\", \"NESTLEIND.NS\", \"ONGC.NS\", \"TITAN.NS\", \"SUNPHARMA.NS\", \"M\u0026M.NS\", \n                   \"POWERGRID.NS\", \"JSWSTEEL.NS\", \"TATASTEEL.NS\", \"TECHM.NS\", \"HDFCLIFE.NS\", \"COALINDIA.NS\", \n                   \"BPCL.NS\", \"INDUSINDBK.NS\", \"BAJAJ-AUTO.NS\", \"IOC.NS\", \"BRITANNIA.NS\", \"HEROMOTOCO.NS\", \n                   \"ADANIPORTS.NS\", \"DRREDDY.NS\", \"GRASIM.NS\", \"CIPLA.NS\", \"DIVISLAB.NS\", \"EICHERMOT.NS\", \n                   \"BAJAJFINSV.NS\", \"SHREECEM.NS\", \"TATAMOTORS.NS\", \"SBILIFE.NS\", \"ADANIENT.NS\", \n                   \"DABUR.NS\", \"VEDL.NS\", \"APOLLOHOSP.NS\"]\n\n# 시간 범위 정의\nend_date = datetime.today()\nstart_date = end_date - timedelta(days=365*3)  # 최근 3년간\n\n# 데이터 가져오기\ndata = yf.download(nifty50_symbols, start=start_date, end=end_date)['Adj Close']\n\n# 누락된 값 채우기\ndata = data.fillna(method='ffill').dropna()\n\n# 데이터의 처음 몇 행 표시\nprint(data.head())\n```\n\n## 단계 2: 전략 구현 및 수익률 계산\n\n그다음, 모멘텀 전략을 구현하고 지난 3년간 포트폴리오 수익률을 계산합니다.\n\n```js\ndef calculate_portfolio_returns(data, top_n=10):\n    # 월간 수익률 계산\n    monthly_returns = data.resample('M').ffill().pct_change()\n    \n    # 12개월 수익률 계산\n    twelve_month_returns = monthly_returns.rolling(window=12).apply(lambda x: np.prod(1 + x) - 1, raw=True)\n    \n    # 월별 포트폴리오 가치를 저장할 빈 목록 초기화\n    portfolio_values = []\n    \n    # 초기 자본 부여\n    initial_capital = 100000  # 1 lakh\n    capital = initial_capital\n    \n    # 13번째 달부터 시작하여 각 월 반복\n    for i in range(12, len(twelve_month_returns)):\n        # 현재 달의 12개월 수익률 가져오기\n        current_returns = twelve_month_returns.iloc[i]\n        \n        # 주식을 12개월 수익률에 따라 순위 매기기\n        ranked_stocks = current_returns.sort_values(ascending=False)\n        \n        # 상위 N개 주식 선택\n        top_stocks = ranked_stocks.head(top_n).index\n        \n        # 각 주식에 대한 동일 가중치 계산\n        weight = 1 / top_n\n        \n        # 현재 달의 포트폴리오 수익률 계산\n        portfolio_return = (monthly_returns.iloc[i][top_stocks] * weight).sum()\n        \n        # 자본 업데이트\n        capital = capital * (1 + portfolio_return)\n        \n        # 현재 자본을 포트폴리오 가치 목록에 추가\n        portfolio_values.append(capital)\n    \n    # 포트폴리오 가치 목록을 pandas Series로 변환\n    portfolio_values = pd.Series(portfolio_values, index=twelve_month_returns.index[12:])\n    \n    return portfolio_values\n\n# 포트폴리오 수익률 계산\nmomentum_portfolio_returns = calculate_portfolio_returns(data)\n\n# 포트폴리오 수익률 표시\nprint(momentum_portfolio_returns)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: Nifty 50 지수와 비교\n\n모멘텀 전략의 성능을 평가하기 위해 해당 전략의 수익률을 동일 기간 동안 Nifty 50 지수의 수익률과 비교합니다.\n\n```js\n# Nifty 50 지수 데이터 가져오기\nnifty50_index = yf.download(\"^NSEI\", start=start_date, end=end_date)['Adj Close']\n\n# Nifty 50 월간 수익률 계산하기\nnifty50_monthly_returns = nifty50_index.resample('ME').ffill().pct_change()\n\n# Nifty 50 누적 수익률 계산하기\nnifty50_cumulative_returns = (1 + nifty50_monthly_returns).cumprod()\n\n# 모멘텀 포트폴리오 누적 수익률 계산하기\nmomentum_cumulative_returns = (1 + momentum_portfolio_returns.pct_change()).cumprod()\n\n# 결과 그래프로 플로팅하기\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 6))\nplt.plot(momentum_cumulative_returns, label='모멘텀 포트폴리오')\nplt.plot(nifty50_cumulative_returns, label='Nifty 50 지수', linestyle='--')\nplt.title('모멘텀 포트폴리오 vs Nifty 50 지수')\nplt.xlabel('날짜')\nplt.ylabel('누적 수익률')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MomentumStrategyusingPython_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결과 및 분석\n\n위의 그림은 지난 3년간 모멘텀 포트폴리오의 누적 수익률을 Nifty 50 지수와 비교한 것입니다. 다음은 주요 관측 사항입니다:\n\n- 이 기간 동안 모멘텀 포트폴리오가 일반적으로 Nifty 50 지수를 능가하여 모멘텀 전략의 효과를 입증했습니다.\n- 모멘텀 포트폴리오가 상당한 변동을 겪는 등의 변동성이 있었는데, 이는 모멘텀 기반 전략에 특징적인 것입니다.\n- 전반적으로, 모멘텀 전략은 Nifty 50 지수를 단순 보유하는 것보다 더 높은 투자 수익을 제공했습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n니프티 50 주식들에 대한 모멘텀 투자 전략은 지난 3년 동안 기대를 불러일으켰어요. 12개월 수익률에 기반한 상위 10개 주식을 선택하고 매월 포트폴리오를 리밸런싱 함으로써, 이 전략은 니프티 50 지수를 능가했어요. 하지만 과거 성과가 미래 성과를 반영한다는 점을 명심해야 하며, 투자자는 이 전략을 실행하기 전에 위험 허용 수준 및 투자 목표를 신중히 고려해야 해요.\n\n제공된 Python 코드 스니펫을 사용하여 이 모멘텀 전략을 백테스트하고 원하는 대로 사용자 정의할 수 있어요. 모멘텀 투자는 투자자의 무기로 강력할 수 있지만, 일관된 성공을 거두기 위해서는 규율과 체계적인 접근이 필요해요.","ogImage":{"url":"/assets/img/2024-06-22-MomentumStrategyusingPython_0.png"},"coverImage":"/assets/img/2024-06-22-MomentumStrategyusingPython_0.png","tag":["Tech"],"readingTime":6},{"title":"PostgreSQL 데이터베이스 변경 사항을 벡터 스토어로 스트리밍하는 방법","description":"","date":"2024-06-22 05:42","slug":"2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore","content":"\n\n## CDC (Change Data Capture)를 사용하여 벡터 저장소를 최신 상태로 유지하는 방법, Python 및 Redpanda\n\n![Image](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_0.png)\n\n벡터 데이터베이스와 의미론적 검색의 등장으로 많은 애플리케이션의 검색 결과 품질이 향상되었습니다. 그러나 전통적인 인덱스 유지 보수 문제는 여전히 존재합니다. \"검색 가능한 콘텐츠\"(제품 설명, 웹 페이지, 연구 논문 요약)가 지속적으로 업데이트될 때 사용자의 검색 경험을 방해하지 않고 검색 인덱스를 새로 고치는 방법은 무엇일까요? 많은 팀은 이 문제를 점진적 색인화로 해결합니다.\n\n예를 들어, DoorDash 엔지니어링 팀이 2021년에 점진적 색인화에 대해 쓴 글에서는 CDC와 Apache Kafka를 사용하여 색인을 점진적으로 업데이트하는 방법을 설명했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 일반적인 검색 인덱스보다 계산량이 많을 수 있는 벡터 데이터베이스로 동일한 작업을 수행하는 방법을 보여드리려고 합니다.\n\n# 점진적 인덱싱을 위한 지속적인 이벤트 기반 벡터 입력 사용하기\n\nCDC를 기반으로 한 인덱싱 파이프라인의 간소화된 버전을 살펴봅시다. 데이터베이스에 새 제품 항목이 추가되는 즉시, 변경 내용의 세부 정보와 함께 이벤트가 Redpanda(카프카와 유사한 메시지 브로커)로 전송됩니다. 소비자 프로세스는 이벤트가 도착하는 즉시 이를 임베딩 모델에 전달합니다. 임베딩이 생성되고 세부 정보가 관련 벡터로 보강됩니다. 이 데이터는 다른 Kafka 토픽으로 스트리밍되어 인계 처리 프로세스가 이를 소비하고 벡터 데이터베이스가 처리할 수 있는 속도에 맞춰 벡터를 업서트합니다.\n\n저는 여러분이 직접 복제할 수 있는 프로토타입 애플리케이션을 작성했습니다. 메시지 브로커로 Redpanda의 로컬 설치를 사용합니다. 파이프라인의 각 단계는 각각의 Docker 컨테이너에서 실행되며, 각 컨테이너는 Quix Streams의 인스턴스를 실행합니다. Quix Streams는 Kafka 프로듀서/컨슈머(예: kafka-python)와 강력한 스트림 처리 라이브러리(예: Faust)인 오픈소스 파이썬 라이브러리입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 다이어그램은 파이프라인의 구성 요소를 보여줍니다.\n\n![다이어그램](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_1.png)\n\n이 파이프라인은 Qdrant(벡터 저장소)와 PostgreSQL(소스 데이터베이스)의 로컬 인스턴스를 사용하며, Redpanda의 토픽을 통해 Quix Streams를 사용하여 변경 사항을 스트리밍합니다.\n\n이 프로토타입의 전체 코드는 동봉된 GitHub 저장소에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 준비물\n\n- 파이프라인을 시도하려면 도커가 설치되어 있어야 합니다. 이를 설치하는 가장 간단한 방법은 Linux, Windows 또는 Mac에 Docker Desktop Docker를 설치하는 것입니다.\n- 또한 Git도 필요합니다. 이미 Git이 없다면 Git 웹 사이트에서 다운로드할 수 있습니다.\n\n먼저, 파이프라인을 실행하고 데이터를 입력하고 검색에 미치는 영향을 관찰하는 방법을 안내해 드리겠습니다. 그 후에는 파이프라인을 구동하는 코드를 안내해 드리겠습니다.\n\n# 코드 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널에서 다음 Git 명령을 실행하여 코드를 가져올 수 있어요.\n\n```js\ngit clone https://github.com/quixio/template-vector-cdc-local\n```\n\n그런 다음, Docker Compose를 실행하세요:\n\n```js\ndocker compose up -d\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령은 8080, 8082 및 5050 포트를 필요로 하는 여러 서비스를 시작합니다. 해당 포트에서 실행 중인 애플리케이션이 있으면 먼저 중지해야 합니다.\n\n콘솔에 다음 예제와 유사한 출력이 표시됩니다:\n\n```js\n[+] Running 10/10\n ✔ Network template-vector-cdc-local_default               Created                                                 0.0s\n ✔ Container template-vector-cdc-local-console-1           Started                                                 0.1s\n ✔ Container template-vector-cdc-local-redpanda-1          Started                                                 0.1s\n ✔ Container postgresdb                                    Started                                                 0.1s\n ✔ Container qdrant                                        Started                                                 0.1s\n ✔ Container create_embeddings                             Started                                                 0.0s\n ✔ Container template-vector-cdc-local-postgresql_cdc-1    Started                                                 0.0s\n ✔ Container streamlit_search                              Started                                                 0.0s\n ✔ Container template-vector-cdc-local-postgresql_admin-1  Started                                                 0.0s\n ✔ Container ingest_to_qdrant                              Started                                                 0.0s\n```\n\n# 데이터베이스 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 기본 테스트 데이터벤스에 테이블을 생성하고 일부 데이터를 추가하겠습니다.\n\n전자 상거래에 중점을 두고 있으므로 온라인 서점을 운영하고 있으며 도서 카탈로그를 지속적으로 업데이트하고 있습니다. 새로운 책이 추가될 때마다 최신 책 설명에 대한 임베딩이 있는 벡터 저장소를 확인해야 합니다.\n\n여기서 책 카탈로그 업데이트를 시뮬레이션하기 위해 pgAdmin을 사용하여 쿼리를 실행할 것입니다. 이는 PimCore와 같은 \"실제\" PIM(Product Information Management) 시스템을 대신하는 역할을 할 것입니다.\n\n먼저, demo PostgreSQL DB에 pgAdmin을 연결해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## pgAdmin에 로그인하기\n\n- 브라우저에서 http://localhost:5050으로 접속하여 pgAdmin UI를 엽니다.\n- 사용자 이름 \"admin@admin.com\"과 비밀번호 \"root\"로 pgAdmin에 로그인합니다.\n\n## PostgreSQL 데이터베이스에 대한 연결 구성\n\n- `Servers`를 클릭하고 `Register` 서버를 선택합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_2.png)\n\n- 나타나는 대화 상자에서 \"일반\" 탭에 이름을 입력한 후, 호스트를 \"postgresdb\"로 설정하고 \"root\"를 사용자 이름과 암호로 설정하고 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_3.png)\n\n# 데이터 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 데모 Postgresql 데이터베이스에는 “books” 테이블이 미리 구성되어 있어서 데이터를 추가하기만 하면 됩니다.\n\n- 서버 ' postgresdb ' 데이터베이스로 이동하여 test_db를 마우스 오른쪽 버튼으로 클릭하고 '쿼리 도구'를 선택합니다.\n\n![이미지](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_4.png)\n\n- 나타나는 쿼리 도구에 다음 쿼리를 붙여넣고 실행하여 첫 번째 일괄 Sci-fi 책을 추가합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nINSERT INTO books (name, description, author, year) VALUES\n('The Time Machine', 'A man travels through time and witnesses the evolution of humanity.', 'H.G. Wells', 1895),\n('Brave New World', 'A dystopian society where people are genetically engineered and conditioned to conform to a strict social hierarchy.', 'Aldous Huxley', 1932),\n('An Absolutely Remarkable Thing', 'A young woman becomes famous after discovering a mysterious alien artifact in New York City.', 'Hank Green', 2018),\n('Dune', 'A desert planet is the site of political intrigue and power struggles.', 'Frank Herbert', 1965),\n('Foundation', 'A mathematician develops a science to predict the future of humanity and works to save civilization from collapse.', 'Isaac Asimov', 1951),\n('Snow Crash', 'A futuristic world where the internet has evolved into a virtual reality metaverse.', 'Neal Stephenson', 1992),\n('The War of the Worlds', 'A Martian invasion of Earth throws humanity into chaos.', 'H.G. Wells', 1898),\n('The Hunger Games', 'A dystopian society where teenagers are forced to fight to the death in a televised spectacle.', 'Suzanne Collins', 2008);\r\n```\n\n위 내용대로 변경하면 자동으로 채택되고 데이터는 파이프라인을 통해 전송됩니다.\n\n로컬 Redpanda 인스턴스에서 Redpanda 콘솔로 확인할 수 있습니다: http://localhost:8080/overview\n\nTopics로 이동하여 `postgres-cdc-data`를 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“OFFSET” 드롭다운에서 “Newest”를 선택하면 메시지가 들어오기 시작해야 해요:\n\n\u003cimg src=\"/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_5.png\" /\u003e\n\n이제 벡터가 제대로 소화되었는지 확인해봐요.\n\n# Streamlit Vector Search UI 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데모 애플리케이션에는 벡터 검색을 테스트할 수 있는 간단한 검색 UI(스트림릿으로 구축됨)가 포함되어 있어요.\n\n다음 URL을 통해 액세스할 수 있어요: http:// localhost:8082\n\n검색 UI에서 \"battle in space\"를 검색해보세요 — 최상위 결과는 \"The War of the Worlds\"여야 해요. 지금은 지구에서 벌어지는 전투에 관한 책이지만, 우리 도서 카탈로그에서 현재 최고의 배치로 보여요.\n\n![이미지](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 \"화성\"이 \"우주\"와 의미적으로 가깝고 \"침공\"이 \"전투\"와 의미적으로 가깝기 때문에 상위 결과와 일치했을 가능성이 있다고 추측할 수 있습니다. 그러나 문장 임베딩 모델 같이 더 정교한 모델을 사용하면 결과가 다를 수 있습니다. 그러나 그 모델은 꽤 무거운 라이브러리이기 때문에 이 프로토타입에서는 제외했습니다.\n\n이제 목록에 몇 권의 책을 추가하고 검색 결과를 개선할 차례입니다.\n\npgAdmin (http://localhost:5050/)로 돌아가서 다음 SQL 쿼리를 실행하세요.\n\n```js\nINSERT INTO books (name, description, author, year) VALUES\n('Childhood''s End', '평화로운 외계 침공으로 인해 인류의 어린 시절이 종말을 맞이한다.', '아서 C. 클라크', 1953),\n('The Day of the Triffids', '유성우로 대부분의 인구가 실명하면서 공격적인 식물이 지배를 시작한다.', '존 윈덤', 1951),\n('The Three-Body Problem', '인류가 위기의 먼 외계 문명으로부터 가능한 침공을 직면한다.', '류씬', 2008),\n('The Puppet Masters', '찐렁이 모양의 외계인이 지구를 침공하여 인간에 붙어 그들의 마음을 통제한다.', '로버트 A. 하인라인', 1951),\n('The Kraken Wakes', '해양 심층에서 나오는 외계 생명체가 인류를 공격하기 시작한다.', '존 윈덤', 1953),\n('The Invasion of the Body Snatchers', '작은 마을이 주민 중 일부가 식물과 같은 씨앗에서 나오는 완벽한 물리적 사본에 교체되는 것을 발견한다.', '잭 핀니', 1955),\n('Out of the Dark', '외계종족이 지구를 침공하여 인류의 생존 의지를 과소평가한다.', '데이비드 웨버', 2010),\n('Old Man''s War', '지구의 노인들이 별간 전쟁에 참전하게 되며 새로운 외계 문화와 위협을 발견한다.', '존 스캘지', 2005);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이것이 프로덕션 상황이었다면, 새로운 제목은 책 카탈로그에 등록될 수 있지만 벡터 DB에는 등록되지 않을 수 있어요. 이 때문에 재고 팀에게 정기적으로 책 카탈로그의 스냅샷을 내보내서 벡터 스토어로 가져와야 할지도 모를 거예요. 한편으로, \"우주 전투\"에 관한 책을 찾는 사용자들은 그냥 기다려야 할 수도 있어요. 이건 그냥 안돼요! 그럼 그들이 카탈로그에 등록되면 바로 제목을 찾을 수 있게 해주는게 어때요?\n\n첫 번째 단계에서 한 것과 이번에 두 번째 단계에서 다시 한 것입니다. 벡터 DB를 책 카탈로그와 실시간으로 동기화했어요.\n\n우리의 유사성 검색 결과에 이 업데이트가 어떤 영향을 미쳤는지 확인해보세요.\n\nStreamlit 검색 UI에서 다시 \"우주 전투\"를 검색해보세요 - 이제 상위 결과는 \"Old man's war\"가 될 거예요 - 더 적절한 매치겠죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![StreamChangesfromaPostgreSQLDatabasetoaVectorStore_7](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_7.png)\n\n\"The War of the Words\"이 상위 자리에서 밀려난 이유는 새로 추가된 용어가 의미론적으로 더 관련된 설명을 갖고 있기 때문이다: 설명에서 \"전쟁\"이라는 용어는 의미에서 \"전투\"에 더 가깝고, \"국제 우주\"는 \"화성\"보다 \"우주\"라는 검색어에 의미론적으로 더 가까워진다.\n\n# 하드웨어 하에서 작동하는 방식\n\n이제 이 프로토타입이 무엇을 하는지 이해했으니, 어떻게 작동하는지 살펴보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 아키텍처 다이어그램의 처리 부분에 초점을 맞춰 봅시다.\n\n![이미지](/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_8.png)\n\n세 개의 서비스를 볼 수 있어요(메시지 브로커는 물론) — 각각은 작고 계속 실행 중인 파이썬 애플리케이션입니다: \"CDC\", \"임베딩 생성\", \"벡터 DB로 업서트\"\n\n각 애플리케이션은 데이터를 수신하고 처리한 후 Kafka 토픽으로 보내거나 어떠한 형태의 싱크에 쓰기 위해 Quix Streams 파이썬 라이브러리를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 응용 프로그램의 소스 코드를 함께 살펴봅시다.\n\n## CDC 구성\n\nCDC 프로세스 뒤의 코드로 들어가기 전에, 자체 PostgreSQL 데이터베이스에서 CDC를 수행하려면 몇 가지 추가 전제 조건을 언급하는 것이 좋습니다:\n\n1) Write Ahead Log를 논리적으로 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- \"SHOW wal_level;\" SQL 쿼리를 실행하여 현재 설정을 확인할 수 있어요.\n- 이미 \"logical\"로 설정이 되어 있지 않다면, postgresql.cong 파일을 업데이트하고 wal_level을 wal_level=logical로 설정해 주세요.\n\n2) PostgreSQL이 실행 중인 서버 또는 컨테이너에 wal2json 플러그인을 설치해야 해요.\n\n이 튜토리얼의 PostgreSQL 데이터베이스에는 이미 이러한 선행 조건이 준비되어 있어요. Debezium Source PostgreSQL Connector 대신 Quix Python CDC 커넥터를 사용합니다. 전체 CDC 코드 파일은 이 GitHub 폴더에서 찾을 수 있어요.\n\n## PostgreSQL 데이터베이스에 연결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포스트그레SQL 연결은 환경 변수를 통해 postgres_helper.py 파일에서 정의됩니다. 따라서, 여러분이 자신의 데이터베이스에 연결하고 싶다면, 관련 변수를 변경하기만 하면 됩니다.\n\n```js\nimport psycopg2\nimport os\n\ndef connect_postgres():\n    # PostgreSQL 상수\n    PG_HOST = os.environ[\"PG_HOST\"] # 기본값은 localhost\n    PG_PORT = os.environ[\"PG_PORT\"] # 기본값은 ??\n    PG_USER = os.environ[\"PG_USER\"] # 기본값은 ??\n    PG_PASSWORD = os.environ[\"PG_PASSWORD\"] # 기본값은 ??\n    PG_DATABASE = os.environ[\"PG_DATABASE\"] # 기본값은 ??\n    \n    conn = psycopg2.connect(\n        database=PG_DATABASE, user=PG_USER, password=PG_PASSWORD, host=PG_HOST, port=PG_PORT\n    )\n    return conn\n… \n```\n\n## 카프카로 변경 로그 항목 생성하기\n\n글을 간결하게 유지하기 위해서, 이 기사에서는 변경 데이터가 어떻게 캡처되는지에 대해 다루지 않겠습니다. 그러나 변경 사항을 캡처하는 데 write-ahead log가 어떻게 사용되는지에 대한 자세한 내용은 postgres_helper.py 파일을 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 데이터의 구조와 Kafka로 생성되는 방법에 초점을 맞춰 봅시다.\n\n먼저, Kafka 프로듀서를 초기화합니다. 저희는 프로듀서로 Quix Streams Python 라이브러리를 사용합니다. 이 라이브러리는 Streaming Dataframes 개념을 사용하여 데이터를 처리하고 정적 데이터셋에 대해 작성된 Pandas 코드를 재사용하기 쉽게 만들어줍니다.\n\nQuix Streams를 사용하여 main.py에서 어플리케이션 및 초기 출력 토픽을 정의합니다:\n\n```js\nfrom quixstreams import Application\n...\napp = Application(broker_address=os.environ['BROKER_ADDRESS']) # Redpanda의 기본값은 'localhost:19092'입니다.\n... \noutput_topic = app.topic(output_topic_name) # 토픽 이름은 환경 변수에 정의되어 있으며, 기본값은 \"posgres-cdc-source\"입니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 최신 데이터베이스 변경 사항을 가져와 버퍼에 추가하고, 버퍼를 반복하여 결과를 출력 Kafka 주제로 전송하는 함수를 추가합니다.\n\n```js\n...\n# 네트워크 트래픽을 줄이기 위해 메시지를 100밀리초 동안 버퍼링합니다\ndef main():\n    buffer = []\n    last_flush_time = time.time()\n\n    while run:\n        records = get_changes(conn, PG_SLOT_NAME)\n        for record in records:\n            changes = json.loads(record[0])\n            for change in changes[\"change\"]:\n                buffer.append(change)\n                \n        # 100밀리초가 지났는지 확인\n        current_time = time.time()\n        if (current_time - last_flush_time) \u003e= 0.5 and len(buffer) \u003e 0:\n           # 500밀리초가 지났다면, 버퍼에 있는 모든 메시지 전송\n    with app.get_producer() as producer:\n            for message in buffer:\n                producer.produce(topic=output_topic.name,\n                                    key=PG_TABLE_NAME,\n                                    value=json.dumps(message))\n                print(\"Kafka로 메시지 전송 완료\")\n                # 생산자를 플러시하여 메시지 전송\n                \n            # 버퍼 비우기\n            buffer = []\n            # 마지막 플러시 시간 업데이트\n            last_flush_time = current_time\n        time.sleep(WAIT_INTERVAL) # main.py의 전역 변수로 정의된 대기 간격(현재 0.1초)\r\n```\n\n결과 payload는 다음 구조를 가지고 있습니다:\n\n```js\r\n{\n  \"kind\": \"insert\",\n  \"schema\": \"public\",\n  \"table\": \"books\",\n  \"columnnames\": [\n    \"id\",\n    \"name\",\n    \"description\",\n    \"author\",\n    \"year\"\n  ],\n  \"columntypes\": [\n    \"integer\",\n    \"character varying(255)\",\n    \"text\",\n    \"character varying(255)\",\n    \"integer\"\n  ],\n  \"columnvalues\": [\n    60,\n    \"Old Man's War\",\n    \"지구의 어르신들이 화성간 전쟁에 참전하게 되어, 새로운 외계 문화와 위협을 발견하게 되는 이야기입니다.\",\n    \"John Scalzi\",\n    2005\n  ]\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에는 이 구조를 간단하게 만들어서 처리하기 쉽게 할 거예요.\n\n# 임베딩 생성\n\n이것이 우리가 \"변환\" 프로세스라고 부르는 것인데, 다른 말로 하면 두 개의 Kafka 토픽 사이에 위치하여 한 쪽에서 읽고 다른 쪽으로 쓰는 역할을 합니다. 전체 소스 코드 파일은 이 GitHub 폴더에 있습니다.\n\nQuix Streams 라이브러리는 변환을 구현하는 간단한 프로세스를 제공합니다. 다른 라이브러리와 달리 생산자와 소비자를 정의하는 대신, 관련 설정을 Application 생성자에 넣어주고 app 인스턴스를 통해 입력 및 출력 토픽을 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\nfrom quixstreams import Application\n...\napp = Application(\n    broker_address=os.environ['BROKER_ADDRESS'],\n    consumer_group=\"vectorsv1\",\n    auto_offset_reset=\"earliest\",\n    auto_create_topics=True,  # Quix 앱은 아직 존재하지 않는 경우 주제를 자동으로 생성하는 옵션이 있습니다\n)\n\n# JSON 변환기를 사용하여 입력 및 출력 주제 정의\ninput_topic = app.topic(os.environ['input'], value_deserializer=\"json\")\noutput_topic = app.topic(os.environ['output'], value_serializer=\"json\")\n```\n\n아래에서는 app.dataframe 메서드를 사용하여 데이터를 생산하고 소비하는 방법을 볼 수 있지만 먼저 데이터에 적용할 함수를 정의합니다.\n\n첫 번째 함수는 변경 데이터 캡처 페이로드의 구조를 압축합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef simplify_data(row):\n\n    # 새로운 딕셔너리를 생성하여 'kind' 및 zips 열 이름과 값으로 구성\n    new_structure = {\"kind\": row[\"kind\"],\"table\": row[\"table\"]}\n    new_structure.update({key: value for key, value in zip(row[\"columnnames\"], row[\"columnvalues\"])})\n\n    # 선택적으로 정수를 문자열로 변환\n    new_structure[\"year\"] = str(new_structure[\"year\"])\n\n    return new_structure\n```\n\n다음과 같은 페이로드 구조를 얻게 됩니다:\n\n```python\n{\n \"kind\": \"insert\",\n \"table\": \"books\",\n \"id\": 60,\n \"name\": \"Old Man's War\",\n \"description\": \"Earth's senior citizens are recruited to fight in an interstellar war, discovering new alien cultures and threats.\",\n \"author\": \"John Scalzi\",\n \"year\": 2005\n}\n```\n\n두 번째 함수는 단순화된 페이로드의 \"description\" 필드에 대한 임베딩을 생성하기 위해 Qdrant의 FastEmbed 라이브러리를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# 기존 모델 다운로드 및 초기화가 트리거됩니다.\nembedding_model = TextEmbedding()\nprint(\"모델 BAAI/bge-small-en-v1.5을 사용할 준비가 되었습니다.\")\n\n...\n\n# 임베딩 함수 정의\ndef create_embeddings(row):\n    text = row['description']\n    embeddings = list(embedding_model.embed([text]))\n    embedding_list = [embedding.tolist() for embedding in embeddings]\n    finalembedding = embedding_list[0]\n    print(f'벡터 생성됨: \"{finalembedding}\"')\n\n    return finalembedding\r\n```\n\n마지막으로 데이터를 소비하고 함수를 적용하여 데이터를 downstream Kafka 주제로 생성합니다.\n\n```js\r\n# 입력 주제의 메시지 스트림을 기반으로 스트리밍 데이터프레임 초기화:\nsdf = app.dataframe(topic=input_topic)\n\nsdf = sdf.filter(lambda data: data[\"table\"] == targettable) # \"books\" 테이블의 변경 사항만 필터링합니다.\n\nsdf = sdf.apply(simplify_data)\n\nsdf = sdf.update(lambda val: logger.info(f\"수신된 업데이트: {val}\"))\n\n# 필터링된 SDF에서 감지된 새 메시지(행)에 대해 임베딩 함수 트리거\nsdf[\"embeddings\"] = sdf.apply(create_embeddings, stateful=False)\n\n# 타임스탬프 열을 현재 시간(나노초 단위)으로 업데이트합니다.\nsdf[\"Timestamp\"] = sdf.apply(lambda row: time.time_ns())\r\n```\n\nsdf.apply()과 sdf.update()의 차이점에 유의하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`apply()`은 콜백 함수의 결과를 하류로 전달합니다. 원본 데이터를 가져와 처리하여 새 데이터를 생성합니다. 이 메서드는 원본 데이터 자체를 변경하지 않고 대신 원본을 기반으로 새 버전을 생성합니다.\n\n- 예를 들어, apply()를 사용하여 사전에 새 키를 추가하면 실제로 해당 추가가 포함된 새 사전이 생성됩니다.\n- 우리의 경우, sdf.apply(simplify_data)를 사용하여 CDC 페이로드를 간단한 사전으로 변환하고 sdf.apply(create_embeddings)를 사용하여 벡터를 계산하고 해당 사전 내의 새로운 \"embeddings\" 필드에 기록합니다.\n\n`update()`는 실제 콜백 인수를 하류로 전달합니다. 원본 데이터를 직접 수정하거나 사용할 수 있게 합니다. 그러나 주로 콘솔에 데이터를 기록하거나 외부 데이터베이스에 쓰는 데 사용됩니다(Kafka Streams의 peek() 메서드와 유사합니다).\n\n마지막으로, 우리는 sdf.to_topic을 사용하여 변환된 데이터를 하류 토픽으로 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsdf = sdf.to_topic(output_topic)\napp.run(sdf)\n```\n\n# 벡터 DB에 Upserting\n\n이 프로세스는 sdf.update() 방법을 다시 사용하지만 먼저 sdf.update()에 전달 할 함수를 정의해야합니다. 즉, 들어오는 벡터와 메타데이터를 벡터 DB에 입력하는 함수를 정의해야합니다. 전체 코드는 이 GitHub 폴더에서 찾을 수 있습니다.\n\n여기서는 환경 변수를 사용하여 벡터 DB에 연결을 정의하고, 스트리밍 데이터프레임 행에서 관련 데이터를 추출하며, upload_points() 메서드를 사용하여 벡터 DB(이 경우 로컬 Qdrant DB)에 항목을 추가합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom quixstreams import Application\nfrom qdrant_client import models, QdrantClient\nimport os\n\nhost = os.getenv(\"qd_host\", \"\")\nport = os.getenv(\"qd_port\", \"\")\ncollection = os.getenv(\"qd_collection\", \"\")\n\nqdrant = QdrantClient(host=host, port=port)\ncollection = collection\n\n# Create collection to store items\nif not qdrant.collection_exists(collection):\n    # Define the collection parameters\n    vector_size = 384\n    # Create the collection\n    qdrant.create_collection(\n        collection_name=collection,\n        vectors_config=models.VectorParams(\n            size=vector_size,  # Vector size is defined by used model\n            distance=models.Distance.COSINE\n        )\n    )\n    print(f\"Collection '{collection}' created.\")\nelse:\n    print(f\"Collection '{collection}' already exists.\")\n\n# Define the ingestion function\ndef ingest_vectors(row):\n\n  single_record = models.PointStruct(\n    id=row['id'],\n    vector=row['embeddings'],\n    payload={key: row[key] for key in ['name', 'description', 'author', 'year']}\n    )\n\n  qdrant.upload_points(\n      collection_name=collection,\n      points=[single_record]\n    )\n\n  print(f'Ingested vector entry id: \"{row[\"id\"]}\"...')\n\napp = Application(\n    consumer_group=\"ingesterV1\",\n    auto_offset_reset=\"earliest\",\n    auto_create_topics=True,  # Quix app has an option to auto create topics\n)\r\n```\n\n마지막으로, 입력 토픽에서 읽어와서 `ingest_vectors` 함수를 `sdf.update()`에 전달합니다. 상기한 바와 같이, 우리는 파이프라인의 종점에 도달했기 때문에 `sdf.update()`를 사용합니다. 데이터를 전달할 다운스트림 토픽이 없으므로 데이터를 \"위치에\" 업데이트하고(즉, 벡터 DB로 보내는 것) 있습니다.\n\n```python\n# JSON 디시리얼라이저와 함께 입력 토픽 정의\ninput_topic = app.topic(os.environ['input'], value_deserializer=\"json\")\n\n# 입력 토픽의 메시지 스트림을 기반으로 스트리밍 데이터프레임을 초기화합니다:\nsdf = app.dataframe(topic=input_topic)\n\n# 데이터 삽입이 이곳에서 발생합니다\nsdf = sdf.update(lambda row: ingest_vectors(row))\napp.run(sdf)\r\n```\n\n# 배운 점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 데이터를 신선하게 유지하는 것은 검색 품질의 중요한 구성 요소입니다. 제품 카탈로그에 새로운 항목이 도착할 때마다 벡터 저장소를 업데이트하여 사용자에게 의미론적으로 정확한 검색 결과를 제공할 수 있었음을 보았습니다.\n\n우리는 데이터베이스에서 데이터를 내보내어 일괄적으로 벡터 저장소에 쓰는 것과 같이 벡터 저장소를 수동으로 업데이트할 수 있었을 것입니다. 그러나 이렇게 하면 제품 카탈로그가 계속 변경되는 프로덕션 전자 상거래 시나리오에서 어떻게 작동하는지, 배치를 어떻게 조직화하며 제품이 카탈로그에 도착한 후에 사용자 검색 쿼리에 포함되기까지 허용할 수 있는 지연 시간이 어떻게 되는지와 관련된 여러 질문이 생깁니다.\n\n데이터가 입력됨과 동시에 임베딩이 생성되고 흡수되는 이벤트 기반 시스템을 설정하면(CDC를 통해), 이러한 질문들을 처리할 필요가 없습니다. 이것이 카프카 기반 아키텍처가 인기 있는 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 대규모 기업이 이미 DoorDash 예제에서 본 것처럼 전통적인 검색 색인 작업을 위해 Apache Kafka와 같은 이벤트 기반 솔루션을 사용하고 있습니다. 텍스트 임베딩을 최신 상태로 유지하는 데 관련된 도전 과제는 비슷하기 때문에 텍스트 임베딩에도 동일한 접근을 적용하는 것이 합리적입니다.\n\n프로덕션에서 점진적으로 데이터를 수집하는 경우 한 가지 주의할 점은 벡터 인덱스를 다시 완전히 계산해야 할 수도 있다는 것입니다. \"6 hard problems scaling vector search\" 라는 기사는 이 문제에 대해 자세히 다루고 있으며 규모에 맞게 이를 수행하려면 좋은 참고 자료가 될 것입니다. 서로 다른 벡터 데이터베이스는 이 문제를 다르게 해결합니다. 예를 들어 특정 벡터 저장소 세그먼트만 다시 계산함으로써 이 문제를 해결합니다. 따라서 프로덕션용 벡터 데이터베이스를 선택할 때 그들의 색인 전략을 고려하는 것이 중요합니다.\n\n그래도 이 간단한 프로토타입이 외부 소스에서 주기적으로 업데이트되는 신선한 데이터에 의존하는 검색 애플리케이션에 벡터 기반 검색을 통합하는 데 출발점을 제공했기를 희망합니다.\n\n- 만약 프로토타입을 작동시키는 데 문제가 있었다면, Quix Streams 사용자를 위한 Slack 커뮤니티에서 내게 메시지를 보내 주시기 바랍니다: https://stream-processing.slack.com/.","ogImage":{"url":"/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_0.png"},"coverImage":"/assets/img/2024-06-22-StreamChangesfromaPostgreSQLDatabasetoaVectorStore_0.png","tag":["Tech"],"readingTime":20},{"title":"NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2","description":"","date":"2024-06-22 05:37","slug":"2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22","content":"\n\n## 빠르고 똑똑한 데이터 조작을 위한 NumPy의 힘을 활용하세요.\n\n# 소개\n\nNumPy 튜토리얼의 두 번째 파트에 오신 것을 환영합니다! 이전에는 다음 목록의 처음 7개 챕터를 다루었습니다. 이번 포스트에서는 8장부터 14장까지 진행하려고 합니다.\n\n- NumPy 설치\n- 배열 초기화\n- NumPy 배열 제한\n- 계산 속도와 메모리 사용량\n- 데이터 유형\n- 색인 및 슬라이싱\n- 배열 생성 함수\n- 난수 생성\n- 보기 및 복사\n- 수학 함수\n- 논리 및 비트 연산자\n- 검색 및 정렬\n- 모양 및 재구성\n- 연결 및 분할\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 문서에서 사용된 모든 자료는 제 GitHub 저장소에서 확인할 수 있습니다. 여기에 링크를 남깁니다.\n\n# 8. 랜덤 숫자\n\nNumPy를 사용하면 랜덤 숫자를 생성할 수 있습니다. 제 경우에는 이 기능을 사용하여 기계 학습 및 딥 러닝 모델에서 무작위 가중치를 초기화하는 데 사용해 보았습니다. 제가 처음부터 구현하려고 노력했던 그때입니다. 이러한 유형의 NumPy 기능에는 다른 응용 프로그램이 있을 것이라고 믿습니다.\n\n## 균일 분포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 np.random.rand()로 시작해 봅시다. 이 함수는 [0.0, 1.0) 범위 내에서 균일 분포에서 무작위 숫자를 생성합니다. 이는 숫자가 정확히 0.0이 될 수는 있지만, 1.0에 근접할 뿐입니다. 이 함수를 사용하려면 우리가 원하는 배열의 형태를 전달해주기만 하면 됩니다. np.random.random()은 사실상 np.random.rand()와 동일합니다. 그러나 이 함수에 대한 입력은 튜플 형태여야 한다는 것을 염두에 두세요. 이 두 함수 중 어느 것이든 실제로 서로 교차하여 사용할 수 있습니다. 이는 단지 사용자의 취향에 따라 다를 뿐입니다.\n\n```js\n# Codeblock 1\nnp.random.rand(10,3)\n\n### 대안\n# np.random.random((10,3))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png\" /\u003e\n\n아직 무작위 균일 분포와 관련하여, 더 많은 유연성이 필요하다면 np.random.uniform()를 사용할 수 있습니다. 이 함수를 사용하면 분포의 범위를 지정할 수 있어 [0.0, 1.0)에 고정되어 있는 것보다 더 유연해집니다. 아래 코드 블록에서 수를 90부터 100 사이로 범위 설정하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 2\nnp.random.uniform(low=90, high=100, size=(5,5))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_1.png)\n\n만약 균일 분포에서 숫자를 np.histogram()에 넣으면, 모든 바구니(첫 번째 인덱스의 배열)에 유사한 빈도의 발생이 있음을 볼 수 있습니다. 아래 예제에서는 10개의 바구니로 분배된 50,000개의 숫자를 생성합니다. 이렇게 하면 각 바구니에 약 5,000개의 발생 횟수가 있습니다. 무작위 균일 함수의 세 가지 변형(np.random.rand(), np.random.random() 및 np.random.uniform())이 모두 이렇게 동작합니다.\n\n```js\n# 코드 블록 3\nnp.histogram(np.random.uniform(size=(50000)))\n\n### 유사한 결과를 제공합니다\n# np.histogram(np.random.rand(50000))\n# np.histogram(np.random.random(50000))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_2.png\" /\u003e\n\n## 정규 분포\n\n균일 분포 뿐만 아니라 np.random.randn()을 사용하여 정규 분포의 데이터도 생성할 수 있습니다. 여기서 전달할 수 있는 유일한 매개변수는 생성될 배열의 모양입니다.\n\n```js\n# 코드 블록 4\nnp.random.randn(6,4)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_3.png)\n\n안타깝게도 np.random.randn() 함수는 분포의 평균과 표준 편차를 변경할 수 있는 기능을 제공하지 않습니다. 이 함수에서 두 매개변수는 각각 0과 1로 고정되어 있습니다. 만약 이러한 값을 사용자 정의하고 싶다면 np.random.normal()을 사용해야 합니다. np.random.normal()에서는 평균을 loc 매개변수를 사용하여 조절하고, 표준편차는 scale 매개변수를 통해 수정할 수 있습니다.\n\n```js\n# Codeblock 5\nnp.random.normal(loc=8, scale=3, size=(5,5))\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 앞서 사용한 np.histogram() 함수는 np.random.randn() 및 np.random.normal()에 의해 생성된 배열이 실제로 정규 분포를 따르는지 확인하는 데 사용될 수 있습니다. 아래 그림 6은 이를 설명하는데, 첫 번째 배열을 통해 가운데 있는 bin이 가장 빈도가 높음을 보여줍니다.\n\n```js\n# 코드 블록 6\nnp.histogram(np.random.normal(loc=0, scale=1, size=50000))\n\n### 비슷한 결과를 출력\n# np.histogram(np.random.randn(50000))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_5.png\" /\u003e\n\n지금까지 많은 유사한 함수가 존재한다는 것을 알아차렸습니다. 특히, 무작위 숫자를 생성하는 데 사용되는 함수들은 균일 및 정규 분포와 관련된 함수들이 많습니다. 그런 경우에는 np.random.uniform() 및 np.random.normal()만 사용하는 것을 권장드립니다. 두 함수가 가장 유연하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 랜덤 정수\n\n우리가 이전에 논의한 함수들은 주로 랜덤 소수점 숫자를 생성하는 데 초점을 맞췄습니다. 실제로 Numpy는 랜덤 정수를 생성하는 함수인 np.random.randint()를 제공합니다. 이 함수의 매개변수 및 동작은 np.random.uniform()와 동일합니다. 지정된 범위 내의 모든 숫자는 선택될 확률이 완전히 동일합니다. 다시 말해, np.random.randint()는 숫자 선택을 위해 균일한 이산 분포를 사용합니다. 아래 예시에서 생성된 숫자들은 [5,10) 범위 내에 있을 것입니다 (즉, 10은 포함되지 않음).\n\n```js\n# Codeblock 7\nnp.random.randint(low=5, high=10, size=(20,3))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배열 섞기\n\n다음으로 이야기하고 싶은 함수는 np.random.shuffle()입니다. 그러나 더 진행하기 전에 먼저 배열 K를 초기화하고 싶습니다.\n\n```js\n# 코드 블록 8\nK = np.random.randint(1, 30, size=10)\nK\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마 알아챌 수 있었던 것처럼, np.random.shuffle()은 배열의 요소 순서를 섞어주는 함수입니다. 이 함수는 배열을 그 자리에서 섞기 때문에, 새로운 배열을 만드는 것이 아니라 원본 배열을 직접 섞는다는 것을 명심해 주세요.\n\n```js\n# 코드 블록 9\nprint('섞기 전 K\\t: ', K)\nnp.random.shuffle(K)\nprint('섞은 후 K\\t: ', K)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_8.png\" /\u003e\n\n## 랜덤 선택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아직 배열 K와 작업 중이시군요. 이제 그 중에서 숫자를 무작위로 선택하는 방법을 알려드릴게요. np.random.choice()를 사용하면 간단하죠. 아래 코드 블록에서 함수를 사용하는 여러 예제를 보여드릴게요.\n\n```js\n# 코드 블록 10\nprint(np.random.choice(K), end='\\n\\n')                #(1)\nprint(np.random.choice(K, size=(2,3)), end='\\n\\n')    #(2)\nprint(np.random.choice(K, size=(2,4), replace=False)) #(3)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_9.png\" /\u003e\n\n(1)에서 지정된 줄에서, 함수에 배열만 전달하면 해당 배열에서 한 개의 숫자를 반환합니다. (2)의 size 매개변수를 사용하여 출력의 차원을 지정할 수도 있어요. 출력 결과를 보면 16이 두 번 나타나는 것을 알 수 있어요. 이는 기본적으로 함수가 복원 선택으로 무작위 숫자를 선택하기 때문인데요, 즉, 원래 배열에서 하나의 숫자가 여러 번 선택될 수 있습니다. 이를 원치 않는 경우, replace=False를 써서 다음과 같이 쓸 수 있어요. (3)에서처럼요. 이렇게 하면 결과 배열의 요소 수가 원본 배열의 요소 수보다 크면 안 된다는 점에 유의하세요. 궁금하시다면, 세 번째 출력에서 두 번 나타나는 12는 배열 K에 12가 실제로 두 번 나타난 것 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 시드\n\n생성된 무작위 숫자를 재현 가능하게 하는 경우가 많습니다. 이를 위해 np.random.seed()를 사용할 수 있습니다. 사용 방법은 간단합니다. 단지 인수로 숫자를 넣고 동일한 숫자를 출력을 정확히 원하는 노트북 셀에서 사용하면 됩니다. 다음 예제를 살펴봅시다. 여기서 np.random.randint()로 생성된 배열이 두 연속된 코드 블록에서 정확히 동일하게 나오기를 원합니다. 이 예에서 시드를 99로 설정하기로 결정했습니다(원하는 정수를 선택할 수 있습니다). np.random.randint()가 정확히 동일한 숫자를 반환하려면, 동일한 시드로 np.random.seed()를 다시 호출해야 합니다.\n\n```python\n# 코드 블록 11\nnp.random.seed(99)\nnp.random.randint(low=0, high=10, size=(2,5))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n# 코드 블록 12\nnp.random.seed(99)\nnp.random.randint(low=0, high=10, size=(2,5))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_11.png)\n\n# 9. 뷰(View)와 복사(Copy)\n\n## 뷰(View)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 변수에서 다른 변수로 배열을 할당할 때 Numpy의 성질을 고려해야 합니다. 다음 예제를 살펴보겠습니다.\n\n```js\n# 코드 블록 13\nL = np.array([55, 66, 77, 88, 99])\nM = L\nprint(M)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_12.png\" /\u003e\n\n여기서 배열 L을 변수 M에 할당했으므로 두 변수가 동일한 배열을 포함하게 됩니다. 다음으로, 아래 코드 블록 14를 사용하여 M의 0번 인덱스를 변경하려고 합니다. 그러나 M의 첫 번째 요소만 바꾸려고 했지만 배열 L의 요소도 변경됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 14\nM[0] = 15\nprint('L:', L)\nprint('M:', M)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_13.png)\n\n이 결과가 나온 이유는 M이 단순히 L의 \"뷰(view)\"일 뿐이기 때문입니다. 다시 말해 위에서 보여준 방법은 배열을 복사하는 것이 아니라 두 변수가 여전히 \"연결\"되어 있기 때문입니다.\n\n## 복사\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 경우가 발생하지 않도록하려면, M에 할당할 때 copy() 메서드를 L에 넣으면 됩니다. 이렇게 하면 M에 저장된 배열이 완전히 다른 배열이 되어, 하나의 배열에 대한 수정이 다른 배열에 영향을 미치지 않도록 보장됩니다.\n\n```js\n# Codeblock 15\nL = np.array([55, 66, 77, 88, 99])\nM = L.copy()\nM[0] = 15\n\nprint('L:', L)\nprint('M:', M)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_14.png\" /\u003e\n\n# 10. 수학 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 수학 연산\n\n이 장에서는 Numpy의 수학 기능을 사용하는 방법에 대해 알아보려고 합니다. 시작하기 전에 사전에 배열 N과 O를 초기화해 봅시다.\n\n```js\n# Codeblock 16\nN = np.array([1,2,3], dtype='int32')\nO = np.array([4,5,6], dtype='int32')\n```\n\n우리는 가장 기초적인 것부터 시작할 것입니다: 덧셈, 뺄셈, 곱셈 및 나눗셈입니다. Numpy에서 배열에 이러한 연산자를 적용하면 연산은 요소별로 수행됩니다. 이러한 이유로 배열 피연산자의 차원이 정확히 일치하는지 확인해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 17\nprint(N + O)\nprint(N - O)\nprint(N * O)\nprint(N / O)\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_15.png)\n\n위의 코드블록 17에서 소개된 방법들은 Numpy 배열에서만 작동합니다. 리스트에 똑같은 작업을 시도하면 모든 예제가 오류가 발생할 것이며, 덧셈 연산은 두 리스트를 연결할 것입니다.\n\n대안으로 np.add(), np.subtract(), np.multiply() 및 np.divide()와 같은 Numpy에서 제공하는 함수들을 사용할 수도 있습니다. 연산자 기호와 함수 모두 정확히 같은 결과를 생성합니다. 따라서 이 경우에는 개인 취향에 따라 선택하면 됩니다. 아래 코드블록은 이러한 함수들을 어떻게 사용하는지 보여줍니다. 결과 출력은 Figure 16에 표시된 것과 완전히 동일합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 18\nprint(np.add(N, O))\nprint(np.subtract(N, O))\nprint(np.multiply(N, O))\nprint(np.divide(N, O))\n```\n\n넘파이(Numpy)에서 \"브로드캐스팅(broadcasting)\"이라는 개념이 있습니다. 이는 기본적으로 크기가 다른 배열 또는 배열과 스칼라 간의 연산을 수행할 수 있다는 것을 의미합니다. 다음 경우에는 숫자 5가 배열 N의 모든 요소로 브로드캐스팅된다고 말할 수 있습니다.\n\n```js\n# Codeblock 19\nprint(N + 5)\nprint(N - 5)\nprint(N * 5)\nprint(N / 5)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_16.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 다음으로 논의하고 싶은 것은 행렬 곱셈입니다. 이전에 언급한 대로, 네 가지 기본 수학 연산 함수는 요소별로 작동합니다. 이는 np.multiply() 함수가 행렬 곱셈을 위해 의도된 것이 아니라는 것을 의미합니다. 대신 np.matmul()을 사용해야 합니다. 이 경우 두 입력 행렬이 연산 가능한지 확인해야 합니다. 다음 예제에서는 각각 크기가 (4,3)과 (3,2)인 배열 O와 P 사이의 곱셈을 수행합니다.\n\n```js\n# 코드블록 20\nO = np.array([[2, 1, 0], \n              [5, 4, 3], \n              [8, 7, 6], \n              [1, 0, 9]])\n\nP = np.array([[4, 3], \n              [6, 5], \n              [8, 7]])\n\nnp.matmul(O, P)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_17.png\" /\u003e\n\n여전히 기본 수학 연산과 관련된 다른 함수에는 np.sign(), np.negative() 및 np.abs()가 있습니다. 이러한 함수들의 사용법을 배열 Q에 대해 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 21\nQ = np.array([-56, 92, -24, -66, 72, -75, 90, 0, 32, 51])\n\nprint(np.sign(Q))\nprint(np.negative(Q))\nprint(np.abs(Q))      # 대안: np.absolute()\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_18.png)\n\n함수 이름대로, np.sign()은 배열의 각 요소의 부호를 취하는 데 사용됩니다. -1, 0 또는 1만 표시됩니다. 다음으로, np.negative()를 사용하여 숫자의 부호를 뒤집을 수 있습니다. 위의 예시에서 -56은 56이 되고, 92는 -92가 됩니다. 마지막으로, np.abs() 또는 np.absolute()를 사용하여 숫자의 절대값을 취할 수 있습니다.\n\n## 최대공약수(GCD)와 최소공배수(LCM)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최대공약수(GCD)와 최소공배수(LCM)는 Numpy에서 각각 np.gcd()와 np.lcm()으로 구현되어 있습니다. 이러한 함수들을 사용하려면, 간단히 두 숫자나 배열을 입력인수로 넣으면 됩니다.\n\n```js\n# 코드블록 22\nprint(np.gcd(81, 72))    #(1)\nprint(np.lcm([3, 6, 9], 24))    #(2)\nprint(np.lcm([3, 12, 9], [24, 16, 3]))    #(3)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_19.png\" /\u003e\n\n위 코드블록 22의 예제를 살펴봅시다. #(1)으로 표시된 줄은 81과 72의 최대공약수인 하나의 숫자를 반환합니다. 한편, #(2) 줄에서는 숫자 24가 첫 번째 인수에 브로드캐스트되어 LCM이 24와 목록의 각 숫자 간에 계산됩니다. 마지막으로, 두 인수에 대해 리스트를 전달하면, LCM 또는 GCD 계산이 요소별로 수행됩니다 (#(3)).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 지수 함수\n\nnp.power() 함수를 사용하여 지수 연산을 수행할 수 있습니다. 이 함수는 두 개의 입력을 받습니다: 밑수와 지수입니다. 해당 함수는 지수로 분수를 전달하여 루트를 계산할 수 있도록 매우 유연합니다.\n\n```js\n# Codeblock 23\nprint(np.power(8, 3))\nprint(np.power([1,2,3,4], 2))\nprint(np.power(144, 1/2))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유연성이 있긴 하지만, np.power()은 실제로 연산 속도에 있어서 최상이라고 할 수는 없습니다. 실제로 더 빠른 계산을 제공하는 몇 가지 특정 목적을 위한 대안들이 있습니다. np.square(), np.sqrt(), np.cbrt() 및 np.exp()가 그 예입니다. 아래 코드 블록은 np.power()와 이러한 함수들의 동등한 사용법을 보여줍니다.\n\n```js\n# 코드 블록 24\nprint(np.square(6))             # np.power(6,2)와 동일\nprint(np.sqrt([144,16,9,4]))    # np.power([144,16,9,4], 1/2)와 동일\nprint(np.cbrt([343,27]))        # np.power([343,27], 1/3)와 동일\nprint(np.exp([2,3,4]))          # np.power(np.e, [2,3,4])와 동일\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_21.png\" /\u003e\n\n## 각도 변환 및 삼각함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넘파이에서는 삼각함수를 사용할 수 있습니다. np.sin(), np.cos() 및 np.tan()을 사용할 때 주의해야 할 점은 이 함수들이 라디안 단위의 각도를 입력으로 받는다는 것입니다. 따라서 각도가 도(degree)로 주어진 경우 np.deg2rad()를 사용하여 라디안으로 변환해야 합니다. 아래 Codeblock 25에서는 각도를 도와 라디안으로 변환하는 방법을 보여줍니다.\n\n```js\n# Codeblock 25\nR = np.array([0, 90, 180, 270])    # 각도 (도)가 담긴 배열\nS = np.array([0, np.pi/2, np.pi, np.pi*3/2])    # 각도 (라디안)가 담긴 배열\n\nprint(np.deg2rad(R))\nprint(np.rad2deg(S))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_22.png\" /\u003e\n\n각도 변환 방법을 이해했으니, 이제 삼각함수의 사용법을 실제로 보여드리겠습니다. 다음 코드에서 숫자 0, 45, 60이 각도 (도)를 나타낸다고 가정합니다. 이 숫자들은 라디안으로 변환된 후 배열 T에 저장되어 np.sin(), np.cos(), np.tan()의 입력으로 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 26\nT = np.deg2rad([0, 45, 60])\n\nprint(np.sin(T))\nprint(np.cos(T))\nprint(np.tan(T))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_23.png)\n\n## 로그 함수\n\n로그 함수에 대해 이야기할 때, 적어도 가장 기본적이라고 생각되는 세 가지 함수가 있습니다. 아래 코드 블록 27에서는 배열 U에 np.log(), np.log2() 및 np.log10() 함수를 어떻게 사용하는지 보여줍니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 27\nU = [1, 2, 10, np.e]\n\nprint(np.log(U))\nprint(np.log2(U))\nprint(np.log10(U))\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_24.png)\n\nNumpy에서 np.log()는 수학의 ln() 함수와 동일합니다 (밑이 e인 로그). 한편, np.log2()와 np.log10()은 각각 밑이 2와 10인 로그입니다.\n\n## 통계 함수\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 숫자 데이터 분포를 가지고 있다면, 통계적 특성을 계산하여 추가 분석을 수행할 수 있습니다. 우리에게 운이 좋은 것은 Numpy가 이 작업을 쉽게 수행할 수 있는 다양한 함수를 제공해준다는 것입니다. 이와 관련된 모든 함수들 — 아마도 이들 모두가 명확히 이해할 만한 함수들로 보입니다 — 이 코드 블록 28에 나와 있습니다.\n\n```js\n# 코드 블록 28\nV = np.array([1, 5, 4, 6, 8, 5, 4, 3, 2, 4, 7, 9, 5, 4, 3, 2, 0, 7, 9])\n\nprint('sum\\t:', np.sum(V))\nprint('mean\\t:', np.mean(V))\nprint('median\\t:', np.median(V))\nprint('var\\t:', np.var(V))\nprint('stddev\\t:', np.std(V))\nprint('q1\\t:', np.quantile(V, 0.25))\nprint('q2\\t:', np.quantile(V, 0.5))\nprint('q3\\t:', np.quantile(V, 0.75))\nprint('min\\t:', np.min(V))\nprint('max\\t:', np.max(V))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_25.png\" /\u003e\n\n이 주제 외에도 통계 측정과 직접적인 관련이 없지만 여전히 유용할 수 있는 두 가지 다른 함수가 실제로 있습니다. 말하고자 하는 두 함수는 np.argmin()과 np.argmax()인데, 이 두 함수는 배열에서 가장 작은 값과 가장 큰 값이 들어 있는 인덱스를 반환합니다. 가장 작거나 큰 값이 여러 개인 경우, 이 두 함수는 가장 낮은 인덱스를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 29\nprint('argmin\\t:', np.argmin(V))\nprint('argmax\\t:', np.argmax(V))\n```\n\n![image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_26.png)\n\n## 선형 대수\n\n넘파이는 선형 대수 계산을 수행하는데 다양한 도구를 제공합니다. 여기서 여러분께 보여드릴 수 있는 몇 가지 사항들이 있습니다. 코드 블록 30에 표시된 두 배열이 있다고 가정해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 30\nW = np.array([10, 20, 30, 40])\nX = np.array([3, 4, 5, 6])\n```\n\n넘파이에서 1차원 배열은 벡터로 생각할 수 있습니다. 따라서 np.dot()을 사용하여 W와 X의 내적을 계산할 수 있습니다.\n\n```js\n# 코드 블록 31\nnp.dot(W, X)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_27.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 NumPy는 np.inner() 및 np.outer()를 통해 내적과 외적을 계산할 수 있도록 합니다.\n\n```python\n# Codeblock 32\nprint(np.inner(W, X))\nprint(np.outer(W, X))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_28.png\" /\u003e\n\n이제 2D 배열을 다루고 있다면 우리가 할 수 있는 것들에 대해 좀 더 자세히 알아보겠습니다. 이를 시연하기 전에 배열 Y를 미리 초기화하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 33\nY = np.array([[2, 1, 0],\n              [0, 4, 5],\n              [2, 6, 3]])\n```\n\n행렬의 전치(transpose)를 얻으려면 np.transpose()를 사용하거나 해당 행렬의 T 속성을 사용할 수 있습니다. 아래 코드 블록을 확인해보세요.\n\n```js\n# 코드 블록 34\nnp.transpose(Y)\n\n### 대안\n# Y.T\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_29.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넘파이는 행렬의 역행렬을 계산하는 함수도 제공합니다. `np.linalg.inv()`를 사용하면 행렬 Y의 역행렬을 계산할 수 있습니다. \n\n```js\n# 코드 블록 35\nnp.linalg.inv(Y)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_30.png\" /\u003e\n\n그러나 중요한 점은 행렬이 특이행렬일 때, 즉 행렬식이 0일 때 `np.linalg.inv()`가 오류를 반환한다는 것입니다. 따라서 역행렬을 계산하기 전에 행렬의 행렬식 값을 확인하는 것이 좋은 아이디어라고 생각합니다. 확인을 위해 `np.linalg.det()`을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 36\nnp.linalg.det(Y)\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_31.png)\n\n더불어 Numpy는 np.linalg.eig()를 사용하여 고유값과 고유벡터를 계산할 수 있습니다. 이 함수는 두 값 모두 반환하므로 출력을 위해 두 변수를 할당해야 합니다.\n\n```js\n# Codeblock 37\neigenvalues, eigenvectors = np.linalg.eig(Y)\n\nprint(eigenvalues, end='\\n\\n')\nprint(eigenvectors)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_32.png\" /\u003e\n\n지금까지 Numpy에서 다양한 수학 함수에 대해 많이 이야기했습니다. 실제로 더 설명하지 않은 것도 많이 있습니다. 더 탐구하고 싶다면 [이 사이트](1)를 방문해보세요.\n\n# 11. 논리 및 비트 연산자\n\n## 논리 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사의 맨 처음에, NumPy가 우리에게 boolean 자료형의 배열을 만들 수 있게 한다고 언급했지만, 이 주제에 대해 아직 자세히 다루지는 않았습니다. 그리고 이제, 이 장에서 그에 대해 이야기하고 싶습니다. 먼저, Z와 AA라는 이름으로 두 배열을 초기화하는 것으로 시작합시다.\n\n```js\n# 코드블록 38\nZ = np.array([True, True, True])\nAA = np.array([False, True, True])\n```\n\nboolean 연산을 수행하는 가장 간단한 방법은 `np.logical_and()`, `np.logical_or()`, 및 `np.logical_xor()`를 사용하는 것입니다. 우리가 이 함수들을 인수로써 같은 차원의 두 배열을 넣어주면, 이 함수들은 요소별 연산을 수행할 것입니다. 다음 예제를 참조해주세요.\n\n```js\n# 코드블록 39\nprint(np.logical_and(Z, AA))\nprint(np.logical_or(Z, AA))\nprint(np.logical_xor(Z, AA))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_33.png)\n\nOR 및 AND 연산자와 약간 비슷한 두 가지 특수 기능이 실제로 있는데, np.any()와 np.all()입니다. np.any()는 배열에 하나 이상의 True가 있으면 True를 반환합니다. 반면에 np.all()은 배열의 모든 요소가 True인 경우에만 True를 반환합니다. 아래 코드 블록 40에서는 배열 Z와 AA에 대해 이 두 함수를 어떻게 사용하는지 보여줍니다.\n\n```js\n# 코드 블록 40\nprint('np.any(Z): ', np.any(Z))\nprint('np.all(Z): ', np.all(Z), end='\\n\\n')\nprint('np.any(AA):', np.any(AA))\nprint('np.all(AA):', np.all(AA))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_34.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 실제로 np.any()와 np.all()을 좀 더 고급으로 사용할 수 있어요. 다음 코드 블록에서 #(1) 행에서, np.any()는 배열 AB에서 4보다 큰 숫자가 하나 이상 있는 경우 True를 반환할 거에요. 다음으로, #(2) 행에서는 AB의 모든 요소가 4보다 큰 경우에만 True를 반환할 거에요.\n\n```js\n# Codeblock 41\nAB = np.array([2, 0, 3, -5, 5, -1, 2, -4])\n\nprint(np.any(AB \u003e 4))    #(1)\nprint(np.all(AB \u003e 4))    #(2)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_35.png\" /\u003e\n\n## 비트 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트 연산자는 논리 연산자만큼 직관적으로 보이지 않을 수 있습니다. 그럼에도 불구하고 두 가지의 기본 아이디어는 정확히 같습니다. 차이는 비트 연산자가 정수를 입력으로 사용한다는 점뿐입니다. 연산 중에 이러한 정수들은 이진으로 먼저 변환된 후 비트 단위로 작동됩니다. 아래 예시에서는 np.bitwise_and(), np.bitwise_or() 및 np.bitwise_xor()에 12와 13을 입력 인수로 넣었습니다.\n\n```js\n# Codeblock 42\nprint(np.bitwise_and(12, 13))\nprint(np.bitwise_or(12, 13))\nprint(np.bitwise_xor(12, 13))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_36.png\" /\u003e\n\n위 함수들은 모두 처음에 12와 13을 이진으로 변환하여 작동합니다: 1100과 1101. 이 값을 AND 연산자로 처리하면 1100이 됩니다. 한편 OR 연산자는 1101을 반환하고 XOR는 0001을 반환합니다. 이진 수열을 10진수로 변환하면 최종 결과로 12, 13 및 1이 나옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 주제에 추가로, np.binary_repr()을 사용하여 10진수의 이진 표현을 확인할 수 있습니다.\n\n```js\n# 코드 블록 43\nprint(np.binary_repr(12))\nprint(np.binary_repr(13))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_37.png)\n\n# 12. 검색 및 정렬\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 숫자를 찾을 때에는 불리언 인덱싱이라는 기법을 사용할 수 있어요. 이 방법을 마스킹처럼 생각할 수도 있죠. 여기서 저는 다음 코드 블록에서 초기화한 배열 AC를 이 아이디어로 설명하고 싶어요.\n\n```js\n# 코드블록 44\nAC = np.array([9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2])\n\nmask = AC \u003e 5  #(1)\nmask\n```\n\n이름이 \"mask\"인 것은 사실상 AC와 길이가 정확히 같은 다른 배열이며, 여기에는 불리언 값만 포함돼요. 이렇게 배열을 생성하려면 (1) 라인에서 하는 것처럼 조건을 적용하면 되요. 이 코드 라인에서는 배열 AC의 모든 요소가 지정된 조건을 충족하는지 확인해요. 만약 조건을 충족한다면 해당 인덱스는 True로 할당돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 마스킹은 아래의 코드블록 45를 사용하여 실행됩니다. 이렇게 하면 우리의 기준을 충족하는 숫자만 출력됩니다.\n\n```js\n# 코드블록 45\nAC[mask]\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_39.png\" /\u003e\n\n사실, 마스크를 별도의 변수에 저장할 필요는 없습니다. 대신, 다음과 같이 간단히 작성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드블록 46\nAC[AC \u003e 5]\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_40.png)\n\n논리 연산자도 사용할 수 있습니다. 다음 예시는 9를 제외한 모든 요소 중 5보다 큰 모든 요소를 출력합니다.\n\n```js\n# 코드블록 47\nAC[(AC \u003e 5) \u0026 (AC != 9)]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_41.png)\n\n실제로 np.where()를 사용하여 동일한 결과를 얻을 수 있습니다. 아래는 그 방법입니다. 결과 출력은 이전 것과 정확히 동일하기 때문에 나타내지 않습니다.\n\n```python\n# Codeblock 48\nAC[np.where((AC \u003e 5) \u0026 (AC != 9))]\n```\n\nnp.where() 함수 자체는 배열에서 지정된 기준을 충족하는 색인을 반환하여 작동합니다. 이 특정 경우에는 선택된 색인이 6, 8 및 6에 해당하는 5, 6 및 7이며, 이는 배열 AC에서의 값들과 일치합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드블록 49\nnp.where((AC \u003e 5) \u0026 (AC != 9))\n\n# AC의 요소를 떠올려보세요: [9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2].\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_42.png)\n\nnp.where() 함수는 3개의 인수를 전달할 때 더 유용할 수 있습니다. 즉, 조건, x 및 y를 정확한 순서로 전달합니다. 이러한 인수를 다음과 같이 생각할 수 있습니다: \"조건이 True를 반환하면 x를 수행하고, 그렇지 않으면 y를 수행합니다.\" 이를 더 잘 설명하기 위해 다음 코드는 배열 AC의 모든 요소를 5보다 큰 경우 0으로 변환합니다. 그렇지 않으면 숫자가 2씩 추가됩니다.\n\n\n# 코드블록 50\nprint(AC)\nprint(np.where(AC \u003e 5, 0, AC+2))\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_43 이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_43.png)\n\n만약 배열 내의 고유한 값의 수를 찾는다는 요청이 오면, np.unique()를 사용할 수 있습니다. 이 함수를 사용하는 방법은 간단합니다. 배열을 유일한 매개변수로 넣기만 하면 됩니다. 또는 만약 원한다면, return_counts=True를 사용하여 해당 값들의 발생 횟수도 얻을 수 있습니다.\n\n```python\n# 코드블록 51\nnp.unique(AC, return_counts=True)\n```\n\n![마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_44 이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_44.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 정렬\n\n함수의 이름이 나타내듯이, 배열을 정렬하는 데 필요한 것은 np.sort()입니다. 예를 들어, 여기서 배열 AD와 AE를 가지고 정렬 작업을 수행할 것입니다.\n\n```js\n# 코드 블록 52\nAD = np.array([77,33,44,99,22,88,55,11,66])\nAE = np.array([\"Elon Musk\", \"Bill Gates\", \"Joe Biden\", \"Barack Obama\"])\n\nprint(np.sort(AD))\nprint(np.sort(AE))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_45.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 결과에서 두 배열이 오름차순으로 정렬되어 있음을 확인할 수 있습니다. 실제로 np.sort()에는 결과 배열을 내림차순으로 정렬할 수 있는 매개변수가 없습니다. 따라서, 만일 원한다면 np.flip()을 사용하여 내림차순으로 정렬할 수 있습니다.\n\n```js\n# Codeblock 53\nprint(np.flip(np.sort(AD)))\nprint(np.flip(np.sort(AE)))\n\n### 대체 방법\n# print(np.sort(AD)[::-1])\n# print(np.sort(AE)[::-1])\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_46.png\" /\u003e\n\n만약 배열을 정렬하긴 하되 값이 아닌 인덱스만 필요한 경우, np.argsort()를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드블록 54\nnp.argsort(AD)\n\n# AD의 요소들을 상기해 봅시다: [77, 33, 44, 99, 22, 88, 55, 11, 66].\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_47.png)\n\nFigure 48에 표시된 출력은 기본적으로 AD 배열에서 가장 작은 숫자를 포함하는 7번째 인덱스를 보여줍니다. 이후로 AD[4], AD[1], 등이 따릅니다. 정렬이 제대로 작동하는지 확인하기 위해 np.argsort()의 전체 출력을 사용하여 다음과 같이 인덱싱을 수행할 수 있습니다:\n\n\n# 코드블록 55\nAD[np.argsort(AD)]\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_48.png\" /\u003e\n\n2차원 배열의 경우, axis 매개변수를 사용하여 정렬 방향을 결정할 수 있습니다. 이는 np.sort()와 np.argsort() 둘 다에 적용할 수 있습니다. 아래 배열 AF를 고려해 봅시다.\n\n```js\n# 코드블록 56\nAF = np.array([[3, 1, 5, 7],\n               [8, 9, 3, 2], \n               [4, 8, 2, 6]])\n```\n\n만약 위 행렬을 열을 따라 정렬하고 싶다면, axis=0을 사용해야 합니다. 반면, axis=1은 행을 따라 정렬할 수 있게 합니다. 아래 코드블록 57는 그 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 57\nprint(np.sort(AF, axis=0), end='\\n\\n')\nprint(np.sort(AF, axis=1))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_49.png\" /\u003e\n\n이 장에 대해 이야기하고 싶은 마지막 주제는 실제로는 정렬과는 크게 관련이 없지만, 여전히 배열 순서와 관련이 있는 주제입니다. 이야기하려는 함수는 np.roll()인데, 이 함수를 사용하여 요소들에 대한 순환 이동을 수행할 수 있습니다. 이 아이디어를 설명하기 위해 먼저 한 시퀀스를 생성할 것입니다.\n\n```js\n# Codeblock 58\nAG = np.arange(13)\nAG\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 codeblock를 사용하여 시퀀스를 shift 매개변수에 전달한 값에 따라 회전시킬 수 있습니다. 이 경우에는 AG를 오른쪽으로 3번(#(1)) 회전하고 왼쪽으로 3번(#(2)) 회전해 봅니다.\n\n```js\n# Codeblock 59\nprint(np.roll(AG, shift=3))     #(1)\nprint(np.roll(AG, shift=-3))    #(2)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_51.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 13. 형태와 변경\n\nPython 리스트에서는 len() 함수를 사용하여 요소의 개수를 알 수 있습니다. 그러나 이 방법은 다차원 배열에는 효과적이지 않을 수 있습니다. 다차원 배열에서는 len() 함수가 가장 바깥쪽 차원만을 세기 때문입니다. 아래의 코드 블록에서 len() 함수가 5를 반환하는 것을 볼 수 있습니다. 이는 전체 배열 차원을 나타내지 않습니다.\n\n```js\n# 코드 블록 60\nAH = np.array([[0,   1,  2,  3,  4,  5], \n               [6,   7,  8,  9, 10, 11], \n               [12, 13, 14, 15, 16, 17], \n               [18, 19, 20, 21, 22, 23], \n               [24, 25, 26, 27, 28, 29]])\n\nlen(AH)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_52.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlen() 함수와 다르게 Numpy 배열의 shape 속성을 활용하면 더 정확한 결과를 얻을 수 있어요. 아래의 코드블록 61의 출력 결과를 보면 배열 AH가 5개의 내부 배열로 구성되어 있고, 각 내부 배열은 6개의 요소로 이루어져 있음을 알 수 있어요. 이를 이전 챕터에서 설명했던 대로 5×6 크기의 행렬로 생각할 수 있어요. 또는 이미지 처리에 관심이 있는 경우, 이는 높이가 5이고 너비가 6인 픽셀을 가진 이미지에 해당해요.\n\n```js\n# 코드블록 61\nAH.shape\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_53.png)\n\nNumpy는 reshape() 메소드를 통해 배열의 모양을 변경할 수 있게 해줘요. 다음 예제에서는 AH를 사이즈 (3,10)으로 재구성하는 방법을 보여드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 62\nAH.reshape(3,10)\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_54.png)\n\n배열을 재구성할 때 중요한 점은 재구성 전후의 총 요소 수가 일정해야 한다는 것입니다. 다시 말해, 배열 차원은 총 요소 수의 인수여야 합니다. 이 요구 사항을 충족하지 못하면 오류가 발생합니다.\n\n배열 재구성은 2D 배열에만 국한되지 않습니다. 아래 코드 블록에서 배열을 3D로 변환하는 예시를 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 63\nAH.reshape(2,3,5)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_55.png)\n\n축에 대해 선택할 숫자를 확신할 수 없는 경우, 간단히 -1을 쓰면 Numpy가 해당 값을 자동으로 설정해줍니다. 그러나 한 번에 둘 이상의 -1을 전달할 수 없다는 점을 염두에 두세요.\n\n```js\n# 코드 블록 64\nAH.reshape(-1,5)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_56.png\" /\u003e\n\n다음은 또 다른 예시입니다. 이 경우에는 배열을 30행 1열로 설정했습니다.\n\n```js\n# 코드 블록 65\nAH.reshape(-1,1)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_57.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 다차원 배열을 1차원 배열로 재구성하고 싶다면 flatten()이나 reshape(-1) 메소드를 사용할 수 있어요.\n\n```js\n# Codeblock 66\nAH.flatten()\n\n### 대안\n# AH.reshape(-1)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_58.png\" /\u003e\n\n이 주제 외에도, 만약 배열에 빈 축을 추가하고 싶다면 np.newaxis를 사용할 수 있어요. 솔직히 말해서, 이 기술은 조금 직관적이지 않아요. 그래서, 제가 일반적으로 Codeblock 65에서 한 것과 같은 작업을 하는 데 np.reshape()를 사용해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 67\nAH.flatten()[:, np.newaxis]\n\n### 대안\n# AH.flatten().reshape(-1,1)\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_59.png)\n\n아래는 np.newaxis에 대한 또 다른 예제입니다. 여기서는 행에 새로운 축을 추가하는 데 사용했습니다.\n\n\n# 코드 블록 68\nAH.flatten()[np.newaxis, :]\n\n### 대안\n# AH.flatten().reshape(1,-1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_60.png)\n\n# 14. Concatenation and Splitting\n\n파이썬 리스트에 새 요소를 추가하려면 append() 메소드를 사용할 수 있습니다. Numpy에서는 np.vstack(), np.hstack(), np.append(), np.concatenate()와 같은 다양한 대안이 있습니다. 이러한 함수들은 모두 여러 배열을 결합하는 것이라는 기본 아이디어를 가지고 있지만, 이러한 함수들은 각각 다른 용도를 가지고 있습니다.\n\n이 주제를 논의하기 전에 먼저 두 개의 새 배열 AI와 AJ를 초기화하고 싶습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드블록 69\nAI = np.array(np.random.randint(0, 5, (2,4)))\nAJ = np.array(np.random.randint(5, 10, (2,4)))\n\nprint(AI, end='\\n\\n')\nprint(AJ)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_61.png)\n\n두 배열을 수직으로 연결하여 결합하려면 np.vstack()을 사용할 수 있습니다.\n\n```js\n# 코드블록 70\nnp.vstack((AI,AJ))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알수 있듯이, np.hstack()은 두 배열을 수평으로 쌓는 데 사용됩니다.\n\n```js\n# 코드 블록 71\nnp.hstack((AI, AJ))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnp.vstack()과 np.hstack() 함수는 여러 배열을 한 번에 쌓을 수 있습니다. 주의할 점은 배열의 열 수가 동일한 경우 수직 스택이 가능하다는 것입니다. 수평 스택의 경우, 배열의 행 수가 동일할 때만 작동합니다.\n\n```js\n# 코드블록 72\nprint(np.vstack((AI,AJ,AJ,AJ,AI)), end='\\n\\n')\nprint(np.hstack((AI,AJ,AJ,AJ,AI)))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_64.png\" /\u003e\n\n또한, np.append() 함수는 배열을 연결하기 전에 먼저 배열을 평평하게 만든 후 작동합니다. 따라서 결과적으로 얻는 출력물은 1차원 배열이 됩니다. 이 기본 동작과는 상관없이 np.append() 함수를 np.vstack() 및 np.hstack()와 동일하게 작동하도록 axis 매개변수를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 73\nprint(np.append(AI, AJ), end='\\n\\n')\nprint(np.append(AI, AJ, axis=0), end='\\n\\n')\nprint(np.append(AI, AJ, axis=1))\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_65.png\" /\u003e\n\n사실 np.append() 함수는 한 번에 두 개 이상의 배열을 결합할 수 없습니다. 만약 그렇게 하고 싶다면 np.concatenate()를 사용할 수 있습니다. axis 매개변수도 np.append()와 동일하게 작동합니다. 만약 axis에 값을 지정하지 않으면 np.concatenate() 함수는 수직 스택을 수행합니다.\n\n\n# 코드 블록 74\nprint(np.concatenate([AI, AI, AI], axis=None), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI]), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI], axis=1))\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 바꿔보세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_66.png\" /\u003e\n\n## Splitting\n\n스택에 사용되는 것뿐만 아니라 Numpy는 분할을 위한 몇 가지 함수도 제공합니다. 아래의 배열 AK를 고려해 봅시다.\n\n```js\n# Codeblock 75\nAK = np.random.randint(0, 10, (20))\nAK\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_67.png)\n\nnp.split() 함수를 먼저 소개하겠습니다. 이 함수는 두 가지 주요 매개변수를 받습니다: ary (나눌 배열) 및 indices_or_sections (분할 지점). 다음 코드에서는 배열 AL을 인덱스 3과 5에서 나누어 세 개의 새 배열을 얻으려고 합니다. 각 배열은 원본 배열에서 0부터 2까지, 3부터 4까지, 5부터 19까지의 범위를 갖습니다.\n\n```js\n# 코드 블록 76\nnp.split(AK, indices_or_sections=[3,5])\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_68.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2D 배열을 나누려면 np.hsplit() 또는 np.vsplit()을 사용할 수 있습니다. 사실 np.split()에 축 매개변수를 전달하여 동일한 작업을 수행할 수도 있습니다. 주요 아이디어는 기본적으로 동일하지만, np.vsplit() 및 np.hsplit()을 사용하여 분할 지점은 각각 행 번호와 열 번호를 참조합니다. 이러한 두 함수를 배열 AL에 대해 시연하겠습니다.\n\n```js\n# 코드블록 77\nAL = np.random.randint(0, 10, (5,6))\nAL\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_69.png\" /\u003e\n\n아래는 np.vsplit()을 사용하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 78\nnp.vsplit(AL, [2,4])\n\n### 대안\n# np.split(AL, [2,4], axis=0)\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_70.png\" /\u003e\n\n마지막으로 np.hsplit() 사용법입니다.\n\n\n# 코드 블록 79\nnp.hsplit(AL, [3,4])\n\n### 대안\n# np.split(AL, [3,4], axis=1) #동등한\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_71.png\" /\u003e\n\n# 마무리\n\n드디어 끝났어요! 지금까지 저가 자주 사용하는 NumPy 함수들을 다뤄봤어요. 사실 더 설명하지 않은 기능들도 많이 남아 있어요. 하지만 걱정하지 마세요. 이제 모든 기초를 마스터했기 때문에 쉽게 배울 수 있을 거예요.\n\n읽어 주셔서 감사해요. 이 글이 유용했기를 바라며, 다음 글에서 만나요. 안녕히 계세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n[1] Universal functions (ufunc). NumPy. https://numpy.org/doc/stable/reference/ufuncs.html [접속일: 2024년 1월 8일].\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 칭찬하고 팔로우하려면 클랩을 눌러주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서 저희를 만나보세요: CoFeed | Differ\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png","tag":["Tech"],"readingTime":32},{"title":"세션 고정이란 무엇인가요 Nodejs에서 방지하는 방법","description":"","date":"2024-06-22 05:31","slug":"2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs","content":"\n\n세션 고정(Session Fixation) 공격자는 유효한 사용자 세션을 탈취할 수 있으므로 이 취약점과 그에 대한 보호에 대해 알아야 합니다.\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_0.png)\n\n이를 알아가기 전에 세션이란 무엇이고 세션 인증이 어떻게 작동하는지 알아야 합니다. 이미 알고 계시다면 \"세션 고정이란 무엇이며 세션 고정을 방지하는 방법\" 부분으로 건너뛸 수 있습니다.\n\n# 세션이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTTP 요청이 상태를 유지하지 않는다는 것을 알고 계셨을 것입니다. 즉, 로그인 요청을 보내고 유효한 사용자 이름과 비밀번호가 있는 경우, 다음 요청을 보내는 같은 사람임을 알 수 있는 기본 메커니즘이 없습니다. 이 문제를 해결하고 요청을 상태 유지할 수 있도록 하는 방법으로 쿠키, 숨김 폼 필드, URL 매개변수, HTML5 웹 스토리지, JWT 및 세션과 같은 제안된 방법이 있습니다. 이 문서에서는 세션에 초점을 맞추었습니다.\n\n세션은 서버에 저장된 데이터입니다. 각 클라이언트는 서버에 있는 이 데이터와 관련된 고유한 식별자를 받습니다. 클라이언트는 각 요청에 이 고유한 식별자를 보내야 합니다. 이를 통해 누가 이 요청을 보내는지 알 수 있습니다. 이 식별자는 쿠키나 URL 매개변수로 전송될 수 있습니다.\n\nexpressjs 애플리케이션에서 세션과 식별자 (세션 ID)를 표시하는 간단한 예제입니다:\n\n```js\nconst app = require('express')();\nconst session = require('express-session');\napp.use(require('cookie-parser')());\napp.use(require('body-parser').json());\n\napp.use(session({\n    secret: 'secret',\n    cookie: { maxAge: 60000 },\n    name: 'sessionId'\n}));\n\napp.get('/', (req, res) =\u003e {\n    res.send('ping');\n});\n\napp.listen(3000, () =\u003e {\n    console.log('Server is running on port 3000');\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음 요청을 보낼 때 express-session 미들웨어는 새로운 고유 식별자를 생성하고 이를 쿠키로 설정한 후 어딘가에 저장합니다(이 경우에는 메모리에 저장되지만 사용자 정의 저장소도 전달할 수 있습니다). 세션 미들웨어의 옵션에서 sessionId를 우리가 이 고유 식별자를 저장하는 키의 이름으로 사용했기 때문에 요청을 보내면 다음과 같은 결과를 볼 수 있습니다:\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_1.png)\n\n이제 브라우저는 이 쿠키를 설정하고 나중 요청을 위해 자동으로 저장합니다. 유효한 세션을 포함하는 요청을 보내면(세션은 세션 저장소에 존재함 - 이 경우에는 메모리에) 응답에 Set-Cookie 헤더가 반환되지 않습니다:\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 로그인하면 사용자 정보를 쿠키에 저장(직렬화)하거나 데이터베이스에 저장하고 데이터를 세션 ID와 연결할 수 있습니다. 우리는 맵을 데이터베이스로 사용해 보겠습니다:\n\n```js\nconst db = new Map();\napp.get('/me', (req, res) =\u003e {\n    const user = db.get(req.sessionID);\n    res.json({ mySessionId: req.sessionID, me: user ? user : 'anonymous' });\n});\nconst users = [{ name: 'bob', age: 19 }, { name: 'joe', age: 20 }];\napp.post('/login', (req, res) =\u003e {\n    const { name } = req.body;\n    const user = users.find(u =\u003e u.name === name);\n    if (user) {\n        db.set(req.sessionID, user);\n        res.send('ok');\n    } else {\n        res.send('try again');\n    }\n});\n```\n\n로그인한 다음 쿠키를 사용하여 /me로 다른 요청을 보내면 다음 결과를 얻습니다:\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 세션을 사용해야 하는 이유와 그 방법을 간단히 요약한 것이었습니다.\n\n## 공격자가 유효한 세션 ID를 생성할 수 있나요?\n\nExpress-session을 사용하고 있는 경우에는 세션 미들웨어에 secret를 전달했음을 보았습니다. 이 secret는 쿠키 값에 서명을 하는 데 사용됩니다. 이것은 단순히 sessionId를 생성한 것이 우리임을 확신할 수 있도록 합니다. 클라이언트로 서명된 값을 보내고 있다면, 공격자가 세션 ID를 생성하는 것은 불가능합니다.\n\n세션의 샘플:\nsessionId=s%3AL6j4T8hBwMk1ulJqGoisZbAxUOkOuQqP.x5UxPQEtKrj3sWrIy6S01CQRjAtp4biVs4H2zgqmSs\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 부분: s%3A는 단순히 s:이라는 것을 의미합니다. 이는 우리의 쿠키-세션이 서명되었음을 나타내는 접두사입니다!\n\n두 번째 부분: L6j4T8hBwMk1ulJqGoisZbAxUOkOuQqP 이것은 세션 ID입니다. 데이터를 연관시키기 위해 데이터베이스에서 사용하고 있습니다.\n\n세 번째 부분: 이 부분은 세 번째 부분입니다. x5UxPQEtKrj3sWrIy6S01CQRjAtp4biVs4H2zgqmSs 이것은 서명 부분입니다. 이 텍스트는 우리의 비밀 정보를 사용하여 생성했으므로, 이 쿠키가 우리에 의해 생성되었음을 확신할 수 있습니다.\n\n우리는 이 서명을 간단히 다시 생성하고 이게 유효한지 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst crypto = require('crypto');\nconst secret = 'secret';\nconst sessionId = 'L6j4T8hBwMk1ulJqGoisZbAxUOkOuQqP';\nconst hmac = crypto.createHmac('sha256', secret);\nhmac.update(sessionId);\nconst signature = hmac.digest('base64').replace(/\\=+$/, '');\nconsole.log(signature); // x5UxPQEtKrj3sWrIy6S01CQRjAtp4biVs4H2zgqmSs\n```\n\n이렇게 express-session이 확인하는 것이에요.\n\n# 세션 고정이란?\n\n세션 고정 공격에서 공격자는 유효한 사용자 세션을 탈취합니다. 쿠키를 서명하여 다른 사용자의 유효한 세션을 탈취할 수 없도록 하는 걸로 말씀드렸죠. 그런데 만약 공격자가 자신의 유효한 세션을 가지고 또 다른 사용자와 연관시키려고 한다면 어떨까요? 이 경우에 공격자는 피해자를 대신하여 작업을 수행할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제는 로그인과 같은 작업에서 새로운 sessionId(고유 식별자)를 생성하지 않는 경우 발생합니다.\n\n## 공격자가 이를 어떻게 할 수 있을까요?\n\n공격자가 컴퓨터에 물리적으로 접근할 수 있는 경우가 있습니다. 예를 들어 공격자로서 대학에 가서 공유 컴퓨터 중 하나를 선택하고 취약한 웹사이트(vulnerablewebsite.com)에 내 계정으로 로그인한 다음 로그아웃을 하지 않고(일반적으로 서버 스토어에서 세션을 제거하는 작업), 취약한 웹사이트(vulnerablewebsite.com)에 로그인 페이지를 열어둔 채로, 그 전에 유효한 sessionId를 복사해야 합니다. 이제 피해자가 이 컴퓨터를 사용하고 있고 피해자가 로그인하면 공격자의 sessionId가 피해자의 계정에 연결됩니다. 복잡해 보일 수 있지만 전혀 그렇지 않습니다, 이를 실제로 확인해 봅시다.\n\n첫 번째 사용자인 Bob(공격자)로 로그인해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_4.png)\n\n이제 브라우저는이 웹 사이트에 대해 이 쿠키를 설정합니다. 다른 사람이 로그인 요청을 보내려고 시도하면 express-session이 새로운 세션 ID를 생성하지 않고 기존 세션 ID를 덮어쓰는 것을 의미합니다.\n\nJoe(피해자)가 이 공유 컴퓨터를 사용하기로 결정하면, Bob의 쿠키와 유효한 세션이 함께 전송된다:\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 새 세션이나 쿠키를 받지 못했어요!\n\n이런 일이 일어나버렸어요. 이제는 밥의 세션 ID가 조의 사용자와 연관되어 있어요. 그래서, 공격자(밥)가 /me로 요청을 보내면 조의 데이터를 돌려받게 될 거에요:\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_6.png)\n\n밥의 세션을 이용해서 조의 데이터를 얻는 데 성공했어요. 이 예시에서 공격자는 물리적 접근이 있었지만, XSS와 같은 다른 취약점이 있는 경우 물리적 접근 없이도 이를 할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 웹사이트는 요청 시 URL 매개변수로 sessionId를 전달합니다. 이 경우, 공격자가 URL 매개변수에 자신의 sessionId를 포함한 로그인 페이지 링크를 제공하면 악용 가능성이 있습니다.\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_7.png)\n\n이 방법의 보안 도전 과제에 대해 더 알고 싶다면, 스택 익스체인지 질문에서 확인하세요.\n\n# 세션 고정 방지 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 로그인 시 새 세션 생성!\n\n메인 솔루션은 정말 쉬운데, 그렇게 하면 항상 이 세션 덮어쓰기가 발생하지 않는지 확신할 수 있어요!\n\n우리 코드를 다음과 같이 변경해요:\n\n```js\napp.post('/login', (req, res) =\u003e {\n    const { name } = req.body;\n    req.session.regenerate(err =\u003e {\n        if (err) {\n            res.send('error');\n        } else {\n            const user = users.find(u =\u003e u.name === name);\n            if (user) {\n                db.set(req.sessionID, user);\n                res.send('ok');\n            } else {\n                res.send('try again');\n            }\n        }\n    });\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인할 때마다 새로운 세션을 할당하기 위해 regenerate 함수를 사용할 수 있습니다. 이제 세션 쿠키를 전달하든 말든 상관없이 새로운 세션 ID를 생성하여 Set-Cookie 헤더를 통해 클라이언트에게 전송합니다.\n\n![이미지](/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_8.png)\n\n## 오직 HTTP Only 쿠키를 사용하세요\n\nHTTP Only를 사용하면 서버만 Set-Cookie 헤더를 통해 쿠키를 설정할 수 있고 클라이언트 측 (브라우저 JavaScript)는 변경할 수 없습니다. 따라서 앱에 XSS 취약점이 있는 경우에도 공격자는 세션 ID (쿠키)를 변경할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## XSS 공격으로부터 보호하기\n\n세션 고정을 XSS 공격과 결합하여 더 효과적으로 사용할 수 있으므로 세션 고정에 대해 걱정한다면 XSS 공격에도 심각하게 대응하는 것이 좋습니다.\n\n## 합리적인 세션 만료 시간\n\n세션 만료 시간은 애플리케이션의 특정 요구 사항과 일치해야 합니다. 보안에 더 많은 관심을 가진다면 짧게 설정하는 것이 좋습니다. 반대로, 그렇지 않다면 더 길게 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 올바른 로그아웃 구현\n\n로그아웃 시 기존 세션을 올바르게 제거하여 관련 데이터와의 연결을 끊어야 합니다. 그렇지 않으면 로그아웃 이후에도 이 세션을 사용할 수 있습니다. (클라이언트 브라우저에서 쿠키를 제거하는 것만으로는 충분하지 않습니다!)\n\n# Passportjs가 세션 결정에 취약했나요?\n\n네, 0.6.0 버전 이전에는 이 문제가 있었습니다. Passport 개발자들은 세션 재생성을 애플리케이션 측에서 수행해야 한다고 생각했지만, 얼마 지나지 않아 이 문제의 중요성을 깨달았고 0.6.0 버전에서 수정되었습니다. 이 수정의 자세한 내용에 관심이 있다면 여기에서 자세한 내용을 읽을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n세션 고정이 발생할 수 있습니다. 기존 세션 ID를 다른 사용자 데이터로 덮어쓸 경우 발생할 수 있습니다. 이 문제를 해결하는 방법은 매번 누군가 로그인할 때마다 새 세션을 생성하고, HTTP Only 쿠키를 사용하며, 적절한 만료 시간을 설정하고, 올바른 로그아웃을 구현하는 것입니다.\n\n# 참고 자료\n\n[OWASP - 세션 고정](https://owasp.org/www-community/attacks/Session_fixation#)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://developer.mozilla.org/ko/docs/Web/Security/Types_of_attacks#session_fixation","ogImage":{"url":"/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_0.png"},"coverImage":"/assets/img/2024-06-22-WhatisSessionFixationandHowtoPreventitinNodejs_0.png","tag":["Tech"],"readingTime":8},{"title":"V8 자바스크립트 엔진의 모든 것 속도, 기능, 사용법","description":"","date":"2024-06-22 05:30","slug":"2024-06-22-TheV8JavaScriptEngine","content":"\n\n## Node.js 내부 심층 분석\n\n![이미지](/assets/img/2024-06-22-TheV8JavaScriptEngine_0.png)\n\n안녕하세요! 이 글은 고급 Node.js를 위한 시니어 엔지니어 시리즈의 첫 번째 글입니다. 이 글에서는 V8 엔진에 대한 자세한 설명과 작동 방식에 대해 설명하겠습니다. 고급 Node.js를 위한 시니어 엔지니어 시리즈의 다른 글은 아래에서 찾아볼 수 있습니다:\n\n```js\n포스트 시리즈 로드맵\n\n* The V8 JavaScript Engine (이 글)\n* Node.js의 비동기 IO\n* Node.js의 이벤트 루프\n* Worker Threads: Node.js의 멀티태스킹\n* Child Processes: Node.js의 멀티태스킹\n* 클러스터링 및 PM2: Node.js의 멀티태스킹\n* 흔한 Node.js 오해 해소\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n내용 목차\n\n* V8를 선택한 이유는?\n* Node.js에서 어떻게 사용되는가?\n* V8는 어떻게 작동하는가?\n* 자체적인 JavaScript 런타임 만들기\n\n\n우리는 Node.js의 가장 낮은 수준에 도달했는데, 여기서는 사물이 혼란스럽고 복잡해집니다. JavaScript는 동적으로 타입이 지정되고 해석되는 언어이며, 우리가 JavaScript에서 실행하는 모든 것은 엔진에 전달됩니다. 그런 다음 엔진은 환경과 상호 작용하여 기계가 프로그램을 실행할 수 있도록 필요한 바이트 코드를 생성합니다. 이를 담당하는 엔진은 Google에서 개발한 오픈 소스 고성능 JavaScript 및 WebAssembly 엔진인 V8입니다. V8는 C++로 작성되었으며 Chrome(또는 유사한 환경)과 Node.js에서 모두 사용됩니다. V8는 ECMAScript와 WebAssembly를 완전히 지원합니다. 흥미로운 점은 V8가 브라우저에만 제한되지 않고 독립적으로 실행되어 모든 C++ 애플리케이션에 임베드될 수 있다는 것입니다.\n\n# V8를 선택한 이유는?\n\n\u003cimg src=\"/assets/img/2024-06-22-TheV8JavaScriptEngine_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 낮은 레벨에 있을수록 더 많은 책임이 있습니다. C/C++을 어셈블리어(assembly)로 변환하기 위해서는 컴파일러가 필요합니다. 어셈블리를 기계어로 변환하기 위해서는 어셈블러(assembler)가 필요합니다. 그래서 Js를 실행 가능한 코드로 변환하기 위해서는 JS 엔진이 필요합니다. Firefox에서 Spidermonkey를 사용했으며 이후 Google Chrome에서 사용하기 위해 V8이 만들어졌고, 현재 Nodejs에서 사용되고 있습니다.\n\nSpidermonkey와 V8 사이의 주목할만한 차이점은, 코드를 바이트코드(bytecode는 기계 코드의 추상화)로 변환한 후 중간 언어로, 그리고 기계 코드로 변환해야 한다는 것입니다. 이것이 Spidermonkey의 작동 방식입니다. 그러나 V8은 JS를 바로 기계 코드로 변환합니다.\n\n# Nodejs에서는 어떻게 사용되는가?\n\nV8 코드 소스 코드를 살펴보면 객체, JSON, 날짜 등의 구현을 찾을 수 있지만 Chrome에서 사용되는 document 객체나 Nodejs에서 사용되는 require()와 같은 요소는 찾을 수 없을 것입니다. 왜냐하면 Nodejs와 Chrome은 이러한 새로운 기능을 C++에서 구현하고 V8을 통해 JavaScript 함수에 바인딩하기 때문입니다. 왜 이렇게 하는 걸까요? 앞서 말했듯이, 더 낮은 수준은 더 많은 책임과 권한을 의미합니다. 그래서 C/C++은 네트워크 카드와 같은 저수준 자원에 액세스하고 활용하는 방법이 있습니다. 그래서 JS는 cpp를 사용하여 자신이 원하는 작업을 수행합니다. 이에 따라 NodeJS 소스 코드에는 V8이 아닌 required가 나타납니다.\n\n다른 사람들도 자신의 사용 사례를 위해 동일한 작업을 수행할 수 있기 때문에 JavaScript가 많은 곳에서 사용되고 있는 이유입니다. 예를 들어, 자신의 cpp 기능 구현을 생성하고 이를 이동 오른쪽, 왼쪽과 같은 js 함수에 바인딩하여 로봇 공학에서 JavaScript를 사용하고 있습니다. 이에 따라 V8은 이 특정 사용 사례에 적합하지 않을 수 있으며, Duktape 또는 Jerryscript JS 엔진이 더 나은 선택일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js에서 V8은 결국 종속성이 되는데, 이는 공식 웹사이트에서 확인할 수 있어요.\n\n![V8 GIF](https://miro.medium.com/v2/resize:fit:448/1*YPcaZUJzouB2OhVpyzxv6w.gif)\n\n# V8 작동 방식\n\n![V8](/assets/img/2024-06-22-TheV8JavaScriptEngine_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nV8 엔진은 코드를 두 단계로 컴파일합니다. 먼저 빠르지만 최적화되지 않은 기계 코드로 컴파일하는 단계가 있습니다. 이는 충분히 시작하는 데 도움이 됩니다. 이 과정이 진행되는 동안 뒤에서 매우 최적화된 코드를 생성하는 느린 컴파일이 이루어집니다. 이렇게 생성된 느린 컴파일된 코드가 작성되면 Javascript는 이 최적화된 코드로 전환됩니다. 이 두 단계는 Ignition(빠르고 저수준 레지스터 기반 해석기)와 Turbofan(최적화 컴파일러)로 알려져 있습니다. Just-in-Time (JIT) 컴파일이라는 새로운 접근 방식이 만들어졌습니다. 이는 해석과 컴파일의 장점을 결합한 것입니다.\n\nV8는 Ignition이라는 해석기를 사용합니다. 먼저 추상 구문 트리를 받아 바이트 코드를 생성합니다. Ignition은 어느 정도 진행되지만, 함수가 충분히 최적화된 경우 컴파일러인 Turbofan을 통해 빠르게 만들어집니다.\n\n단계별로 살펴보겠습니다:\n\n- V8이 원시 코드를 구문 분석하여 Abstract Syntax Tree (AST)로 변환합니다. V8은 JS 코드를 이해하지 못하기 때문에 이 형태로 만들어야 합니다. 그리고 스코프도 생성됩니다.\n- 그 AST 및 스코프를 바탕으로 Ignition 해석기는 바이트 코드를 생성할 수 있습니다.\n- 엔진이 코드를 실행하고 타입 피드백을 수집하기 시작합니다. (실행 단계에서 코드에 대한 타입 피드백을 제공합니다.)\n- 코드를 더 빠르게 실행하기 위해 바이트 코드를 최적화하는 컴파일러에 타입 피드백 데이터와 함께 전달할 수 있습니다. 최적화 컴파일러는 이를 기반으로 가정을 설정하고 고효율의 머신 코드를 생성합니다. 이 과정은 병렬로 이루어지며 V8은 자주 사용되는 바이트 코드를 \"핫\" 코드로 표시하여 더 효율적인 머신 코드로 변환합니다. 그러나 바이트 코드 대신 머신 코드를 바로 사용하는 이유는 다음과 같습니다.\n- 머신 코드는 많은 메모리를 필요로 합니다.\n- 머신 코드가 항상 바이트 코드보다 빠르지 않습니다. 머신 코드는 컴파일하는 데 시간이 오래 걸리지만 실행 단계에서는 빠릅니다. 반면 바이트 코드는 컴파일하는 데 더 적은 시간이 필요하지만 실행 단계는 느립니다.\n- 어떤 가정이 잘못된 경우 최적화 컴파일러는 비최적화를 수행하고 해석기로 돌아갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자체 JavaScript 런타임 만들기\n\n자체 JS 런타임을 만들거나 이것이 가능한지 확인해보고 싶다면, 제가 최근에 만든 자체 JavaScript 런타임을 확인해보세요! 놀라운 V8 자바스크립트 엔진과 Libuv로 구동됩니다. V8, Libuv 및 C++로 구축된 기초 위에 놓여 있는데, 저는 강력한 Node.js를 처음부터 다시 만들기 위해 떠났습니다. JavaScript 런타임 개발의 세계로 깊이 파고들며 함께해 주세요.\n\n# 떠나시기 전에!\n\n- 더 많은 통찰을 기다려주세요! 팔로우하고 구독해 주세요.\n- 👏 버튼을 클릭하고 누르고 있는 동안 생기는 일을 보셨나요?","ogImage":{"url":"/assets/img/2024-06-22-TheV8JavaScriptEngine_0.png"},"coverImage":"/assets/img/2024-06-22-TheV8JavaScriptEngine_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs에서 스트림 사용하는 방법 2024 트렌드","description":"","date":"2024-06-22 05:29","slug":"2024-06-22-StreamsinNodejs","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-StreamsinNodejs_0.png\" /\u003e\n\n새로운 웹 개발자들에게는 메모리 관리와 데이터 스트리밍 같은 개념이 무서울 수 있습니다. 이러한 내용은 보통 웹 개발 튜토리얼의 일부가 아니지만, 인터넷에서 가장 인기 있는 사이트 중 일부에 필수적입니다: YouTube, Netflix, Spotify와 같은 스트리밍 사이트들이 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-StreamsinNodejs_0.png"},"coverImage":"/assets/img/2024-06-22-StreamsinNodejs_0.png","tag":["Tech"],"readingTime":1}],"page":"16","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"16"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>