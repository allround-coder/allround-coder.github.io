<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/2" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법" href="/post/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kotlin 멀티플랫폼 개발을 위한 IDE 선택 무엇이 최고일까" href="/post/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kotlin 멀티플랫폼 개발을 위한 IDE 선택 무엇이 최고일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kotlin 멀티플랫폼 개발을 위한 IDE 선택 무엇이 최고일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Kotlin 멀티플랫폼 개발을 위한 IDE 선택 무엇이 최고일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Rails 애플리케이션 성능 최적화 종합 가이드" href="/post/2024-07-01-OptimisingRailsApplicationPerformanceAOverviewGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Rails 애플리케이션 성능 최적화 종합 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-OptimisingRailsApplicationPerformanceAOverviewGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Rails 애플리케이션 성능 최적화 종합 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Rails 애플리케이션 성능 최적화 종합 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Alba로 루비 API 성능 향상하는 방법" href="/post/2024-07-01-BoostingYourRubyAPIPerformancewithAlba"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Alba로 루비 API 성능 향상하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-BoostingYourRubyAPIPerformancewithAlba_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Alba로 루비 API 성능 향상하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Alba로 루비 API 성능 향상하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="강력한 인사이트를 얻는 법 Rails에 New Relic Analytics 통합하기" href="/post/2024-07-01-UnlockPowerfulInsightsIntegratingNewRelicAnalyticsinRails"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="강력한 인사이트를 얻는 법 Rails에 New Relic Analytics 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-UnlockPowerfulInsightsIntegratingNewRelicAnalyticsinRails_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="강력한 인사이트를 얻는 법 Rails에 New Relic Analytics 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">강력한 인사이트를 얻는 법 Rails에 New Relic Analytics 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java 21  더 이상 필요 없는 public static void main" href="/post/2024-07-01-Java21Nomorepublicstaticvoidmain"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 21  더 이상 필요 없는 public static void main" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Java21Nomorepublicstaticvoidmain_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 21  더 이상 필요 없는 public static void main" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Java 21  더 이상 필요 없는 public static void main</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot 3로 분산 추적하는 방법  Micrometer와 OpenTelemetry 비교" href="/post/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot 3로 분산 추적하는 방법  Micrometer와 OpenTelemetry 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot 3로 분산 추적하는 방법  Micrometer와 OpenTelemetry 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Spring Boot 3로 분산 추적하는 방법  Micrometer와 OpenTelemetry 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java 8에서 Java 21까지 2024년에 코드를 업그레이드해야 하는 이유" href="/post/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 8에서 Java 21까지 2024년에 코드를 업그레이드해야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 8에서 Java 21까지 2024년에 코드를 업그레이드해야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Java 8에서 Java 21까지 2024년에 코드를 업그레이드해야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 선언형 프로그래밍과 명령형 프로그래밍 비교분석" href="/post/2024-06-30-DeclarativevsImperativeprogramminginSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 선언형 프로그래밍과 명령형 프로그래밍 비교분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 선언형 프로그래밍과 명령형 프로그래밍 비교분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Swift에서 선언형 프로그래밍과 명령형 프로그래밍 비교분석</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HNG 챔피언십을 위한 내 모바일 앱 개발 여정" href="/post/2024-06-30-MyMobileAppDevelopmentJourneyAQuestforHNGChampionship"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HNG 챔피언십을 위한 내 모바일 앱 개발 여정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-MyMobileAppDevelopmentJourneyAQuestforHNGChampionship_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HNG 챔피언십을 위한 내 모바일 앱 개발 여정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HNG 챔피언십을 위한 내 모바일 앱 개발 여정</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link posts_-active__YVJEi" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법","description":"","date":"2024-07-01 16:51","slug":"2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose","content":"\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png)\n\nℹ: 가끔 실수를 하거나 완전히 정확하지 않은 정보를 공유할 수도 있어요. 완벽하지 않으니 참고용으로만 사용해 주세요. 뭔가 이상하다고 느껴지면 공식 문서나 블로그를 확인하는 것이 좋아요.\n\n# ✨ 소개\n\n\"설정\" 메뉴를 응용 프로그램에 포함시키는 것이 표준적인 규칙이 되었습니다. 사용자의 선호에 맞춰 인터페이스를 사용자 정의할 수 있는 기능을 제공하여, 예를 들어 밝은 테마와 어두운 테마 간 전환 또는 알림을 켜거나 끄기 등이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“Settings” 정보는 사용자 기기에 지속적으로 저장되어 있어야 합니다 (앱이 삭제될 때까지). 그렇지 않으면 사용자가 앱을 닫을 때마다 저장된 사용자 설정이 손실되어 설정을 다시 처음부터 구성해야 합니다.\n\n이를 염두에 두고 오늘은 앱 설정 정보를 지속적으로 저장하기 위해 주로 사용되는 DataStore (Preferences)의 기본 구현 방법을 소개하겠습니다!\n\n# ☛ 구현 전 고려사항\n\nDataStore (Preferences) API를 사용하면 데이터를 키-값 형식으로 저장하고 관리할 수 있습니다. 그 자체로는 과도하게 복잡하지 않지만 구현에는 다음과 같은 기본 지식을 이해해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ViewModel을 사용한 UI 상태 관리의 기본 사항\n- Kotlin에서 비동기 처리의 기본 사항 (Coroutine)\n- DI (의존성 주입)의 기본적인 이해\n\n만약 이러한 주제들을 이해하지 못하고 있다면, 제가 소개할 샘플 코드의 역할을 이해하기 어려울 수도 있습니다.\n\n제가 작성한 글 속 코드에 대해 가능한 많은 설명을 제공하겠지만, 모든 세부 내용을 다 다루기는 이 글의 범위를 벗어나므로, 일정 수준의 이전 지식을 갖고 있다고 가정하겠습니다. 샘플 코드가 무엇을 하는지 완전히 이해할 수 없다면, Jetpack Compose와 Kotlin의 기본을 다시 공부하는 것이 좋을 수도 있습니다.\n\n아래는 참고 링크입니다 (공식 Google 및 Kotlin 문서):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ViewModel: [라이브러리 안드로이드 뷰모델 참조](https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel)\r\n- Kotlin 코루틴: [코루틴 개요 코틀린 문서](https://kotlinlang.org/docs/coroutines-overview.html)\r\n- Kotlin Flow: [코틀린 Flow 문서](https://kotlinlang.org/docs/flow.html)\r\n- DI (의존성 주입): [의존성 주입 안드로이드 교육](https://developer.android.com/training/dependency-injection)\n\n하지만 저자로서 제 생각으로는 코드를 즉시 이해하지 못해도 전혀 괜찮습니다. 코드를 그대로 복사하여 붙여넣고 '세부 정보를 모르겠지만 작동했다!' 라고 생각하는 지점에 도달하는 것도 중요한 단계입니다.\n\n기본을 이해하는 것은 필수적이지만, 코드의 의미가 처음에 분명하지 않더라도 진행하는 것은 괜찮습니다. 완전한 이해 없이 전진하는 것은 학습 과정의 중요한 부분일 수 있습니다.\n\n# ☛ 앱의 UI 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 사용자가 사용자 이름을 입력하고 SAVE 버튼을 탭하면 해당 사용자 이름이 기기에 영구적으로 저장되고 저장된 사용자 이름이 표시되는 앱을 만들고 싶어요.\n\n완성된 앱은 아래 이미지처럼 보일 거예요.\n\n![Image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_1.png)\n\n완료되면 \"SAVE\" 버튼을 탭한 후에도 앱을 닫아도 사용자 이름이 계속 저장되어 있어야 합니다. 그러나 \"SAVE\" 버튼을 탭했을 때 아무런 작업도 수행되지 않도록 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 이름이 표시되는 부분은 \"Hi, Name?\"으로 일단 고정 값으로 설정해보겠습니다.\n\n아래는 앱의 메인 화면(MainScreen.kt)에 대한 임시 코드입니다:\n\n```kotlin\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier\n) {\n\n   var userInput by remember {\n       mutableStateOf(\"\")\n   }\n\n   Column(\n       modifier = modifier.fillMaxSize(),\n       verticalArrangement = Arrangement.Center,\n       horizontalAlignment = Alignment.CenterHorizontally\n   ) {\n       Text(\n           text = \"Hi, Name?\",\n           style = MaterialTheme.typography.displaySmall,\n           modifier = Modifier\n               .padding(top = 32.dp)\n       )\n       TextField(\n           value = userInput,\n           onValueChange = { userInput = it },\n           modifier = Modifier\n               .padding(vertical = 32.dp)\n       )\n       Button(\n           onClick = { /*TODO*/ }\n       ) {\n           Text(text = \"SAVE\")\n       }\n   }\n}\n```\n\n현재 SAVE 버튼을 누르면 아무 일도 일어나지 않으며, 앱을 닫으면 입력한 사용자 이름 정보가 손실됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ☛ 1) Dependencies 설정하기\n\n이제 우리가 완성품의 명확한 비전을 갖고 있다면, DataStore (Preferences)의 소개를 진행해 봅시다.\n\n먼저, 의존성을 설정해야 합니다. 다음 의존성을 모듈 레벨의 build.gradle.kts 파일에 추가해주세요. (참고: ViewModel도 필요하므로 DataStore와 함께 나열되어 있습니다.)\n\n```js\n/* build.gradle.kts */\n// ViewModel 추가\nimplementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0\")\n\n// DataStore preferences 추가\nimplementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서는 이 글을 작성하는 시점에서 사용 가능한 최신 안정 버전을 지정했습니다. 그러나 구현할 때 사용 가능한 최신 안정 버전을 확인하고 지정하는 것이 좋습니다.\n\n코드를 추가한 후 '지금 동기화'를 클릭하여 동기화하세요. 이 시점에서 특별히 어려운 점은 없어야 합니다.\n\n# ☛ 2) UserRepository.kt 추가\n\n이제 본격적으로 시작합니다. 이 부분에서는 DataStore(Preferences)를 사용하여 기기에 사용자 설정 정보(이 경우 사용자 이름)를 영구적으로 저장하는 논리를 작성할 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, 이 패키지와 파일이 UI가 아닌 데이터를 관리하는 것임을 명확히 하기 위해 \"data\"라는 이름의 패키지를 생성하세요.\n\ncom.example.projectname 패키지에서 마우스 오른쪽 버튼을 클릭하고 \"새 패키지\"를 선택한 후 \"data\"라고 입력하여 생성하세요.\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_2.png)\n\ndata 패키지를 생성한 후에 이 패키지 내부에 UserRepository란 이름의 Kotlin 파일을 만드세요. 만들 때 Class를 선택해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_3.png\" /\u003e\n\n특정 패키지에 파일을 추가하는 프로세스는 이후 단계에서도 동일합니다.\n\n지금은 생성된 UserRepository.kt 파일의 UserRepository 클래스에서 DataStore(Preferences)를 사용하는 로직을 작성할 예정입니다.\n\n먼저 DataStore를 사용할 때는 애플리케이션의 최상위 컨텍스트를 사용해야 하므로, 생성자로 dataStore라는 DataStore 타입을 지정해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n/* UserRepository.kt */\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\n\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n  \n}\n\n\n이렇게 하면 UserRepository 클래스 내에서 컨텍스트를 정의할 필요가 없고, UserRepository 클래스는 오직 DataStore에 대한 로직만을 처리할 수 있습니다.\n\nDataStore(Preferences)에서 데이터는 키 및 값으로 관리되며, 여기서 다루는 값은 문자열인 사용자 이름입니다. 따라서 stringPreferencesKey()를 사용하여 다음과 같이 문자열 값이 포함된 키를 정의합니다:\n\n\n/* UserRepository.kt */\nimport androidx.datastore.preferences.core.stringPreferencesKey\n\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n    private companion object {\n        val USER_NAME = stringPreferencesKey(\"user_name\")\n    }\n}\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프라이빗 컴패니언 객체로 정의하면 각 Preferences 키를 클래스 내에서 한 번만 존재하는 정적 객체(싱글톤)로 관리할 수 있습니다. 사용자 이름만 관리하는 것은 쉽지만, 다른 설정을 토글하거나 관리해야 하는 경우처럼 여러 키를 관리해야 하는 경우에는 컴패니언 객체를 사용하는 것이 더욱 유리합니다.\n\n다음으로, 장치에 저장된 문자열 타입 값에 대한 속성을 정의합니다. 이는 데이터 스토어를 생성자로 받은 데이터의 데이터를 map()으로 확장하고, 앞서 컴패니언 객체에서 정의한 키를 지정하여 달성할 수 있습니다.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow\u003cString\u003e =\n       dataStore.data.map { preferences -\u003e\n           preferences[USER_NAME] ?: \"Unknown\"\n       }\n}\n```\n\n⚠️참고: 실제로는 데이터를 읽는 작업이 실패할 경우를 대비하여 에러를 처리하고 해당 코드를 포함해야 합니다. 그러나 코드를 간단하게 유지하기 위해 여기에서는 생략하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 설정으로 데이터를 읽을 수만 있기 때문에, 데이터를 저장하거나 업데이트하는 메소드를 추가해 봅시다. edit()를 사용하여 전달된 문자열을 저장하는 메소드를 추가해 보세요.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow\u003cString\u003e =\n       dataStore.data.map { preferences -\u003e\n           preferences[USER_NAME] ?: \"알 수 없음\"\n       }\n\n   suspend fun saveUserName(userName: String) {\n       dataStore.edit { preferences -\u003e\n           preferences[USER_NAME] = userName\n       }\n   }\n}\n```\n\n이로써 DataStore (Preferences)를 사용하기 위한 세 가지 필수 구성 요소가 완성되었습니다:\n\n- 문자열을 값으로 가지는 키를 설정하는 것\n- 값을 읽을 수 있는 프로퍼티\n- 값을 저장할 수 있는 메소드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUserRepository.kt 파일의 코드 작성이 완료되었습니다.\n\n하지만 우리는 아직 데이터 저장소를 생성자로 받을 준비를 하지 않았기 때문에 아직 작동하지 않을 것입니다. 다음 단계에서는 애플리케이션 컨텍스트를 사용할 준비를 하겠습니다.\n\n# ☛ 3) MyApplication 클래스 추가 및 설정\n\n이 단계에서는 UserRepository에서 사용할 애플리케이션 컨텍스트를 구성할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, com.example.projectname 패키지 내에 MyApplication.kt라는 파일을 만들어주세요 (클래스로 지정).\n\n그런 다음, MyApplication.kt 파일의 MyApplication 클래스 바깥에서 dataStore를 Context 확장 속성으로 정의하고 특정 DataStore 인스턴스에 위임해주세요.\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore\u003cPreferences\u003e by preferencesDataStore(\n   name = \"setting\"\n)\nclass MyApplication {\n}\n```\n\n이를 통해 어플리케이션의 모든 부분이 동일한 Context를 통해 DataStore에 액세스할 수 있게 되어 데이터 일관성을 보장하고 코드 재사용성을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore\u003cPreferences\u003e by preferencesDataStore(\n  name = \"setting\"\n)\nclass MyApplication: Application() {\n  lateinit var userRepository: UserRepository\n  override fun onCreate() {\n    super.onCreate()\n    userRepository = UserRepository(dataStore)\n  }\n}\n```\n\nuserRepository은 이전 단계에서 생성된 UserRepository 클래스를 상속받지만, 당연히 여기에서 초기화할 수 없습니다(데이터 스토어인 생성자를 지정할 수 없기 때문). 따라서 애플리케이션이 초기화될 때 이전에 정의한 Context.dataStore가 UserRepository 클래스로 전달되어야 합니다.\n\n이 과정은 애플리케이션 전체에서 일관된 데이터 저장 메커니즘을 제공하여 UserRepository 클래스가 이 데이터 스토어를 사용하여 사용자 설정 및 정보를 관리할 수 있도록 합니다. 결과적으로 데이터 저장, 검색 및 업데이트가 애플리케이션 내의 어디에서든 쉽게 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계의 마지막에 AndroidManifest.xml 파일의 애플리케이션 태그에 android:name을 다음과 같이 추가하는 것을 잊지 마세요:\n\n```js\n\u003c!-- AndroidManifest.xml --\u003e\n\u003capplication\n   android:name=\".MyApplication\"\u003e\n```\n\n이 사양을 따르면 MyApplication 클래스에 정의된 종속성이 MainActivity가 시작되기 전에 초기화됩니다.\n\nMyApplication 클래스와 관련된 코딩 및 설정이 이제 완료되었지만, 코드의 역할과 의미가 간결함 때문에 이해하기 어려울 수 있다는 것을 이해합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계에서는 \"DataStore(Preferences)와 애플리케이션 컨텍스트(전체 앱을 통틀어 말하는 맥락)를 사용할 수 있게 해준다\"는 넓은 이해를 바탕으로 시작하는 것이 좋아요.\n\n# ☛ 4) ViewModel 추가 및 구성하기\n\n이전 단계에서 DataStore(Preferences)를 사용할 준비가 되었지만, 현재 상태에서는 UI가 어떤 변경 사항도 반영하지 않을 것입니다. 이번 단계에서는 ViewModel을 사용하여 UI의 책임을 처리하여 앱을 완성에 더 가깝게 이끌 것입니다.\n\n먼저, 샘플.com.프로젝트명 `ui` 패키지 내에 MyAppViewModel이라는 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자연스럽게 MyAppViewModel 클래스는 응용 프로그램 컨텍스트에 따라 다르게 구성된 UserRepository 클래스의 속성 및 메서드를 활용할 것입니다. 따라서 MyAppViewModel 내에서 UserRepository를 직접 사용할 수 없습니다. 대신에 다음과 같이 생성자로 userRepository를 지정합니다:\n\n```js\n/* MyAppViewModel.kt */\nimport androidx.lifecycle.ViewModel\nimport com.example.datastoresample.data.UserRepository\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n이렇게 함으로써 UserRepository 클래스가 응용 프로그램 컨텍스트에 의존하고 있고, MyAppViewModel 클래스가 UserRepository 클래스에 의존하고 있는 관계를 설정했습니다. MyAppViewModel이 초기화될 때 UserRepository가 초기화되어야 하므로 ViewModel을 사용하기 어렵다고 걱정할 수도 있겠지만, 이 의존성 문제를 이번 단계의 끝에서 해결할 것입니다.\n\n지금은 의존성 해결을 제외하고, 저장된 사용자 이름을 검색하는 속성을 정의하기 위해 시작하겠습니다. 그 전에, UI 상태를 관리하는 UiState라는 데이터 클래스를 MyAppViewModel 클래스 외부에 정의해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* MyAppViewModel.kt */\ndata class UiState (\n   val userName: String\n)\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n그리고 UiState 데이터 클래스를 사용하여 UserRepository 클래스에 정의된 currentUserName 속성에서 데이터를 비동기적으로 로드합니다.\n\n```js\n/* MyAppViewModel.kt */\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n   val uiState: StateFlow\u003cUiState\u003e =\n       userRepository.currentUserName.map { userName -\u003e\n           UiState(userName)\n       }.stateIn(\n           scope = viewModelScope,\n           started = SharingStarted.WhileSubscribed(5000),\n           initialValue = UiState(\"Unknown\")\n       )\n}\n```\n\nViewModel의 UI 상태(UiState)는 StateFlow 형식으로 관리되어야 하므로, Flow 형식에서 StateFlow 형식으로 변환하고, .stateIn()을 사용하여 구독을 설정하고 초기 값이 설정되도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSharingStarted.WhileSubscribed(5000)은 구독이 종료된 후 5초 동안 여전히 값이 방출되며, 구독을 취소한 후에도 잠시 동안 UI 구성 요소가 데이터 업데이트를 받을 수 있습니다. 값 구독을 최적화하기 위한 이 조정은 복잡해 보일 수 있지만, 이를 \"값 구독을 최적화하는 설정\"으로 생각할 수 있습니다.\n\n그렇게 하면, 저장된 사용자 이름(문자열) 정보를 UI 상태 관리를 위한 값으로 읽을 준비가 되었습니다. 그 다음으로, 값을 저장하거나 업데이트하는 메서드를 추가해 봅시다. 이는 UserRepository 클래스에서 정의된 것과 비슷한 방식으로 구현할 수 있습니다.\n\n```kotlin\n/* MyAppViewModel.kt */\nfun saveUserName(userName: String) {\n    viewModelScope.launch {\n        userRepository.saveUserName(userName)\n    }\n}\n```\n\nUserRepository 클래스에서 정의된 saveUserName() 메서드는 suspend fun으로 정의되어 있기 때문에 coroutine scope 내에서 호출되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 값을 읽고 저장(업데이트)할 수 있게 되었는데, 남은 문제는 MyViewModel이 UserRepository에 의존하고 UserRepository가 애플리케이션 컨텍스트에 의존하는 문제입니다. 이를 해결해 봅시다.\n\n다음과 같이 MyViewModel 클래스에 companion object를 정의하세요:\n\n```js\n/* MyAppViewModel.kt */\ncompanion object {\n   val Factory: ViewModelProvider.Factory = viewModelFactory {\n       initializer {\n           val application = (this[APPLICATION_KEY] as MyApplication)\n           MyAppViewModel(application.userRepository)\n       }\n   }\n}\n```\n\n이전 코드와 비교했을 때, 처음에는 더욱 불분명해 보일 수 있습니다. 그러나 이 코드의 목적은 MyAppViewModel의 인스턴스를 생성할 때 애플리케이션 컨텍스트로부터 필요한 종속성(이 경우 userRepository)을 주입하는 것입니다. 이를 통해 ViewModel을 테스트하고 재사용하기 쉬워지며 종속성을 명시적으로 관리할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본질적으로, 이 사용자 정의는 ViewModel (MyAppViewModel)을 초기화할 때 발생하여 MyAppViewModel이 UserRepository에 의존하는 문제를 해결합니다.\n\n마지막 단계는 초기에 제시된 MainScreen.kt를 수정하여 버튼을 탭할 때 데이터(사용자 이름)를 영구적으로 저장하고 저장된 데이터를 문자열로 표시하여 앱을 완성하는 것입니다.\n\n# ☛ 5) 뷰 업데이트\n\n지금까지의 단계에서 DataStore (Preferences)를 사용하여 지속적인 데이터 저장 및 검색을 준비했으며 ViewModel을 사용하여 UI를 관리했습니다. 이제 MainScreen.kt를 업데이트하여 ViewModel을 통해 저장된 데이터가 UI에 반영되도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 다음과 같이 MainScreen()에 MyAppViewModel을 매개변수로 지정하세요.\n\n```js\n/* MainScreen.kt */\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier,\n   myAppViewModel: MyAppViewModel = viewModel(factory = MyAppViewModel.Factory)\n) { … }\n```\n\nMyAppViewModel에서 정의된 Factory를 factory 매개변수에 전달함으로써, 이 MyAppViewModel의 초기화는 이전 챕터에서 설정한 사용자 지정 초기화 설정이 적용됩니다.\n\n다음으로 UI 상태(이 경우 저장된 사용자 이름)를 정의하려면 MainScreen 함수 내에서 savedUserName을 다음과 같이 정의하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n/* MainScreen.kt */\nval savedUserName by myAppViewModel.uiState.collectAsState()\n\nText(\n   text = \"안녕하세요, ${savedUserName.userName}님\",\n   style = MaterialTheme.typography.displaySmall,\n   modifier = Modifier\n       .padding(top = 32.dp)\n)\n```\n\n마지막으로, TextField에 입력된 문자열이 버튼을 클릭했을 때 저장되도록 하려면, onclick 매개변수에 전달할 함수를 설정하면 됩니다. 이렇게 하면 끝이죠.\n\n```kotlin\n/* MainScreen.kt */\nButton(\n   onClick = { myAppViewModel.saveUserName(userInput) }\n) {\n   Text(text = \"저장\")\n}\n```\n\n앱을 빌드하고 사용자 이름을 입력한 후 SAVE 버튼을 탭한 다음, 앱을 완전히 종료하고 다시 엽니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 저장된 데이터가 앱을 종료한 후에도 지워지지 않고 유지되는 것을 확인할 수 있습니다.\n\n잘 했어요! 이렇게 하면 DataStore (Preferences)의 기본 구현이 완료됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ☛ 마무리로\n\n개발 초보자들이 필요한 코드를 외우기에 집중하는 경향이 있다는 것을 알았어요. 하지만, 중요한 것은 코드를 외우는 것이 아니에요. 시험이 아니기 때문에, 과거에 작성한 코드를 잊어버렸을 때는 열심히 다시 작성하기보다는 그냥 복사해서 붙여넣는 것이 괜찮아요.\n\n실제로, 무언가를 구현할 때마다 코드를 처음부터 쓰는 대신, 한 번 작성한 코드를 템플릿으로 관리하는 것이 더 효율적하다고 생각해요. Git이나 클라우드 서비스를 사용해서 작성한 코드를 손쉽게 재사용할 수 있게 만들어두면 좋아요.\n\n하지만, 코드를 복사하고 붙여넣을 때도 그 코드가 무엇을 의미하는지와 어떤 역할을 하는지 이해하는 것이 중요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"I'm happy to help you out! However, I might not fully understand the requested change. It's important to avoid blindly copying and pasting code; instead, try to understand its purpose to improve your coding skills. Here is the code snippet in Markdown format:\n\n\n```js\n\u003caside\u003e\n \u003cp\u003e\n   Thank you for reading!\u003cbr\u003e\n   If you enjoyed this post, \u003cbr\u003e\n   I'd appreciate claps. 😄\n \u003c/p\u003e\n\u003c/aside\u003e\n```","ogImage":{"url":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png","tag":["Tech"],"readingTime":15},{"title":"Kotlin 멀티플랫폼 개발을 위한 IDE 선택 무엇이 최고일까","description":"","date":"2024-07-01 16:50","slug":"2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment","content":"\n\n\u003cimg src=\"/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_0.png\" /\u003e\n\n# 계속하기 전에 명확히 해야 할 사항\n\nKotlin Multiplatform (KMP)은 Android, iOS, 데스크톱, 웹, 서버 등 다중 플랫폼에서 개발을 지원합니다. 가장 일반적인 사용 사례는 Android 및 iOS를 타겟팅하는 것이지만, 모바일 요소 없이 웹 및 서버에 집중하는 KMP 프로젝트를 만드는 것도 기술적으로 가능합니다. 따라서 KMP를 위한 최적의 IDE는 특정 프로젝트와 해당 요구 사항에 따라 다릅니다.\n\n저는 먼저 데스크톱 개발에 집중한 후 Android 및 iOS로 기능을 확장합니다. KMP의 웹 지원은 아직 알파 단계이기 때문에 사용 및 호환성 문제가 고려 사항이 될 수 있는 복잡성을 더하며, 따라서 일회성 장난감 앱이나 데모용으로 더 적합하다고 생각합니다. 현재로서는 특별히 그에 흥미를 느끼지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 점은 JetBrains가 Kotlin Multiplatform을 소유하고 있으며, JetBrains와 Google은 별개의 기업이라는 것입니다. 그들은 안드로이드 스튜디오, Kotlin, 그리고 안드로이드 개발자를 위한 Jetpack Compose를 개발하기 위해 긴밀히 협력하고 있지만, 독립적으로 운영되고 있습니다.\n\n# Kotlin Multiplatform의 공식 IDE는 JetBrains의 Fleet입니다\n\n안드로이드 스튜디오는 일부 KMP와의 호환성을 추가 플러그인을 통해 제공하지만, 구글 안드로이드에서 유지보수되고 있습니다. 반면 Fleet은 Kotlin Multiplatform을 위해 특별히 JetBrains에서 처음부터 개발한 새로운 IDE입니다.\n\n의도된 부정적인 내용 없이, Fleet은 처음부터 다시 시작하여 바퀴를 다시 발명하는 것으로 보입니다. 심지어 IntelliJ IDEA 플러그인은 Fleet과 호환되지 않습니다. 경험 많은 안드로이드 개발자들은 Eclipse ADT에서 안드로이드 스튜디오로 이주하는 초기 어려움을 기억할 수 있을 것인데, 그 당시에는 여러 해가 걸렸습니다. Fleet이 다른 기존 IDE 옵션들과 비교 가능해지기까지 얼마나 시간이 걸릴지 궁금합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJetBrains의 혁신 노력에 감사드립니다. 그러나 Fleet은 현재 Android Studio와 Xcode를 대체할 수 없습니다. Fleet은 코드 편집기를 넘어서는 범위를 가지고 있지만, Android Studio와 Xcode는 오랫동안 코드 편집기 이상의 역할을 해왔습니다. Google과 Apple의 독점 플랫폼 도구들 때문에 JetBrains가 Fleet을 자급자족시키고 개발자 경험을 맞춰 나갈 계획은 무엇인지 궁금합니다, 특히 유료 제품으로서 어떻게 할 생각인지요.\n\nFleet이 더 성숙해지면 다시 고려해볼 수 있을 것 같습니다. 현재는 다음과 같은 이유로 개발 시간을 투자하기에는 한계가 있어 보입니다:\n\n- Fleet에서의 개발 경험이 Android Studio나 Xcode의 실제 사용과 맞지 않습니다.\n- AGP 지원이 제한적입니다. Fleet이 아직 자급자족하지 못한 상태에서, Android Studio가 문제없이 처리할 수 있는 AGP를 프로젝트에서 Fleet을 사용하기 위해 다운그레이드하는 것은 불필요할 수 있습니다.\n\n![My IDE Choice for Kotlin Multiplatform Development](/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러그인 지원 부족 - Fleet은 IntelliJ IDEA 플러그인과 호환되지 않습니다. 예를 들어, SQLDelight 플러그인은 많은 사람들에게 필수적입니다. 또한, 포맷팅 및 명명된 인자를 지원하는 기타 Kotlin 플러그인들도 있습니다.\n\n![이미지](/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_2.png)\n\n- Compose Desktop 미리 보기 기능이 제한적입니다. 심지어 미리 보기 기능을 작동시키는 것조차 문제가 될 수 있습니다.\n- 벡터 드로어블 가져오기를 지원하지 않습니다. Multiplatform 리소스는 성숙해졌지만, Fleet는 여전히 벡터 드로어블을 변환하고 미리 보기할 수 있는 기능이 부족합니다.\n- Fleet는 완전한 개발 주기를 독립적으로 처리할 수 없습니다. Android Studio와 Xcode는 언젠가 필요합니다. 이미 확립된 IDE들과 함께 추가 IDE를 실행하는 것은 중복된 작업처럼 보입니다.\n\n# IntelliJ IDEA\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 처음에 컴포즈 데스크톱 앱을 만들 때 IntelliJ IDEA를 사용했는데, 안드로이드 스튜디오도 처리할 수 있다는 걸 몰랐어. IntelliJ IDEA의 장점 중 하나는 대부분의 안드로이드 스튜디오 플러그인과 호환된다는 것이야. Compose Multiplatform 플러그인을 사용하면 UI를 개발할 수 있지만 레이아웃 미리보기 기능이 제한된다는 점이 있어.\n\n안드로이드를 대상으로 하지 않는 프로젝트의 경우에는 IntelliJ IDEA가 좋아. 안드로이드 관련 애드온이 없는 상태에서 더 깔끔하고 반응이 빠르거든. 하지만 안드로이드 스튜디오가 사실상 IntelliJ IDEA의 향상된 버전이기 때문에 내 KMP 프로젝트가 안드로이드를 대상으로 할 경우에는 IntelliJ IDEA 대신 안드로이드 스튜디오를 사용하는 게 더 합리적이야.\n\n게다가 IntelliJ IDEA는 최신 AGP 버전에 대해 제한적인 지원을 하고 있어, JetBrains가 아직 해결되지 못한 알려진 문제랍니다.\n\n![이미지](/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 안드로이드 스튜디오\n\n일부 개발자는 안드로이드 경험이 제한된 상태에서 코틀린 멀티플랫폼 세계로 진입할 수 있습니다. 그러나 안드로이드 개발에 다양한 경험을 가진 사람들에게는 네이티브 안드로이드 개발과 안드로이드 스튜디오의 혜택을 포기하는 것이 업계 표준과 관행에서 손해일 수 있습니다. \n\n안드로이드 스튜디오는 코틀린 멀티플랫폼 및 Compose 멀티플랫폼 플러그인을 지원합니다. 비안드로이드 부분에 대한 expect/actual 선언을 처리하고, 데스크톱(JVM) 앱을 실행하며, 다양한 타겟에 대한 유닛 테스트를 수행할 수 있습니다. 저는 잠시 웹 개발을 해보았는데, 안드로이드 스튜디오에서 웹 앱을 실행하는 것이 가능했습니다.\n\n## 데이터베이스 지원\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQLDelight 플러그인은 안드로이드 스튜디오에서 작동합니다. Room Multiplatform을 사용할 때는 일부 해결책을 활용하여 Android 타겟에서 Database Inspector를 여전히 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_4.png)\n\n## 기존 안드로이드 개발 도구\n\nKtor 클라이언트로 OkHttp를 사용하면 내장된 네트워크 인스펙터를 여전히 사용할 수 있습니다. JetBrains Compose 대신 Jetpack Compose을 사용하는 공통 UI 코드에서도 레이아웃 인스펙터는 제대로 동작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 안드로이드 스튜디오는 상용급 제품 앱을 개발하는 데 필요한 모든 도구를 제공합니다. 런처 아이콘을 생성하고 베이스라인 프로필을 만드는 등의 기능을 제공합니다. Android Studio는 벡터 그래픽을 가져와 변환하는 경우에도 최고의 통합개발환경(IDE)입니다.\n\n![이미지](/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_5.png)\n\n## 미리 보기\n\nIntelliJ IDEA의 Compose Multiplatform 플러그인 및 Fleet를 통해 Compose Multiplatform 미리 보기는 여전히 기본적인 수준입니다. CommonMain에서 Compose Multiplatform composables의 미리 보기를 보기 위해 해결책이 필요할 수 있습니다. 미리 보기는 Fleet 및 IntelliJ IDEA에서 제공되는 제한적인 Compose Desktop 미리 보기와 동일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! Android Studio 데스크톱 앱의 한 가지 제한 사항은 IDE에서 데스크톱 앱을 실행하는 경우 데스크톱 앱을 닫기 전에는 Compose Desktop 미리보기를 빌드하거나 새로 고칠 수 없다는 점입니다.\n\n# 안드로이드 앱 품질과 개발자 경험을 손상시킬 이유가 없습니다\n\n우리의 안드로이드 앱은 KMP 프로젝트에서 대부분의 코드가 공유되지만, 여전히 네이티브 안드로이드 앱입니다. 코틀린 멀티플랫폼 때문에 안드로이드 개발 표준과 관행을 후퇴하는 것은 불합리합니다.\n\n# … 그리고 iOS용 Xcode\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 대상의 경우, 이유는 안드로이드 스튜디오와 비슷합니다. 저는 Xcode를 사용하고 있으며, 네이티브 iOS 앱을 빌드하고 제공하는 데 필요한 모든 것을 제공합니다. KMP 코드는 Gradle을 사용하여 컴파일되며, iOS 네이티브 기능을 널리 사용하지 않더라도 제 요구 사항에 충분합니다. Android 스튜디오와 Xcode만 사용해도 이동 및 데스크톱 앱을 제공하는 데 충분하며, MacBook Pro의 메모리와 디스크 공간을 절약할 수 있습니다.\n\n# 결론\n\nJetBrains에게 성가시운 사람으로 인식될 수 있지만, 제 코멘트는 수십만 파운드에 달하는 중요한 실제 개발 노력에 기반을 두고 있습니다.\n\n이 기사는 이해관계로 인해 몇몇 사람들을 성가시게 할 수 있지만, 특히 Kotlin Multiplatform에 대해 자신의 환경에서 실제로 사용해 보는 것이 중요하다는 점을 강조해야 합니다. 실직적 경험 없이 KMP를 지나치게 찬양하거나 비판하는 것은 실제 사용 사례를 반영하지 못합니다.","ogImage":{"url":"/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_0.png"},"coverImage":"/assets/img/2024-07-01-LetsTalkAboutMyIDEChoiceforKotlinMultiplatformDevelopment_0.png","tag":["Tech"],"readingTime":6},{"title":"Rails 애플리케이션 성능 최적화 종합 가이드","description":"","date":"2024-07-01 16:48","slug":"2024-07-01-OptimisingRailsApplicationPerformanceAOverviewGuide","content":"\n\n현재의 빠르게 변화하는 디지털 환경에서는 웹 애플리케이션의 성능이 사용자 경험을 결정할 수 있습니다. Rails 개발자로서 애플리케이션이 효율적으로 실행되도록 하는 것이 매우 중요합니다. 이 안내서에서는 코드 예시를 포함하여 Rails 애플리케이션 성능을 최적화하기 위한 필수 전략과 도구를 다룹니다.\n\n## 높은 오류율\n\n오류율을 감지하고 관리하는 것은 견고한 애플리케이션을 유지하는 데 중요합니다. New Relic APM과 같은 도구를 사용하여 비정상적으로 높은 오류 발생량을 식별할 수 있으며, 이는 종종 해킹 봇이 취약점을 이용하려는 문제의 신호일 수 있습니다.\n\n```js\n# New Relic APM을 사용하여 오류율 모니터링하기\nNewRelic::Agent.notice_error(StandardError.new(\"예시 오류\"))\n# ^-- 이 줄은 Rails 애플리케이션의 오류를 추적하려는 위치에 배치되어야 합니다. 이 오류율을 모니터링하여 잠재적인 보안 위협을 신속하게 대처하고 전체 애플리케이션 안정성을 향상시킬 수 있습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 성능 최적화\n\n파레토 원리는 종종 \"작업의 80%는 코드의 20%로 수행된다\"라고 언급되며, 목표로 하는 최적화의 중요성을 강조합니다. New Relic과 같은 도구를 사용하면 응용 프로그램의 어느 부분에 주의를 기울여야 하는지 식별하는 데 도움이 됩니다.\n\n```js\nNewRelic::Agent.add_custom_parameters(:method_name, :execution_time)\n# ^-- 메서드 성능을 추적하기 위해 사용할 수 있는 사용자 정의 매개변수 추가\n```\n\n## 벤치마킹\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n벤치마킹은 성능을 측정하기 위해 애플리케이션을 테스트하거나 시뮬레이션하여 속도, 처리량 및 응답 시간을 평가하는 것을 의미합니다. `wrk`와 같은 도구는 부하 테스트에 탁월합니다.\n\n```js\nwrk -t12 -c400 -d30s http://localhost:3000\n# ^-- 로컬호스트에서 12개 스레드, 400개 연결을 30초 동안 시뮬레이션하기 위해 wrk를 사용합니다.\n```\n\n## 프로파일링\n\n프로파일링은 애플리케이션의 런타임 동작을 분석하여 성능 문제를 식별하는 것을 말합니다. 프로파일링에는 통계적 프로파일링과 추적 프로파일링 두 가지 주요 유형이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nNewRelic::Agent.add_instrumentation(\"MyClass\", :method_name)\n# ^-- MyClass의 method_name을 통계 프로파일링을 위해 Instrument합니다. 추적 프로파일링\n```\n\n```js\nrequire 'ruby-prof'\n\nRubyProf.start\n# ^-- RubyProf로 코드 프로파일링을 시작합니다.\nresult = RubyProf.stop\n# ^-- 프로파일링을 멈추고 자세한 실행 데이터를 캡처합니다.\n```\n\n## Little's Law: 필요한 서버의 개수는?\n\nLittle's Law는 요청의 도착률을 시스템의 응답 시간과 필요한 서버 수와 관련시켜 용량 계획 및 성능 최적화를 돕는다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 예제 계산:\n도착률 = 100 # 초당 요청\n응답 시간 = 0.5 # 초\n필요한 서버 수 = 도착률 * 응답 시간\n# ^-- 요청 도착률과 응답 시간을 기반으로 필요한 서버 수를 계산합니다.\n```\n\n리틀의 법칙을 적용하여 인프라를 확장하는 데 유용한 결정을 내릴 수 있습니다.\n\n## 뉴 렐릭(New Relic)을 사용하여 레일즈(Rails)에서 N+1 쿼리 감지\n\nN+1 쿼리는 관련된 레코드를 가져오기 위해 애플리케이션이 여러 번의 데이터베이스 쿼리를 실행할 때 발생하여 성능 하락을 초래할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nN+1 쿼리를 감지하는 방법:\n\n- 트랜잭션 추적: 상세 실행 정보를 캡처합니다.\n- 트랜잭션 추적: 타임라인과 메트릭스를 확인합니다.\n- 데이터베이스 쿼리: 쿼리 패턴과 응답 시간을 분석합니다.\n\n```js\n# includes를 사용하여 N+1 쿼리 식별\nposts = Post.includes(:comments).all\n# ^-- includes를 사용하여 데이터 가져오기를 최적화하고 N+1 쿼리 문제를 피할 수 있습니다.\n```\n\nincludes, joins, eager_load와 같은 메서드를 사용하여 데이터 가져오기를 최적화하고 불필요한 데이터베이스 쿼리를 최소화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로파일링을 위한 Stackprof 젬\n\nstackprof 젬은 세부적인 메소드 수준의 실행 데이터를 제공하여 성능 병목 현상을 식별하는 데 도움을 줍니다.\n\n```js\nrequire 'stackprof'\n\nStackProf.run(mode: :cpu, out: 'tmp/stackprof-cpu-myapp.dump') do\n # 프로파일링할 코드\nend\n# ^-- StackProf를 사용하여 애플리케이션의 CPU 사용량을 프로파일링합니다.\r\n```\n\n프로파일링 데이터를 분석하여 성능에 상당한 영향을 미치는 메소드에 최적화 작업을 집중할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데이터베이스 최적화 기술\n\n데이터베이스 성능 최적화는 반응이 빠른 애플리케이션을 위해 중요합니다. 여기 몇 가지 주요 기술이 있습니다:\n\n- 활성 레코드 쿼리에 대한 설명\n\n```js\nputs Post.where(author_id: 1).explain\n# ^-- 특정 작성자의 게시물을 대상으로 하는 활성 레코드 쿼리의 쿼리 계획을 출력합니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 주요 데이터베이스 지표 측정:\n\n데이터베이스 작업을 효율적으로 유지하기 위해 CPU 사용률, 메모리 사용률 및 쿼리 시간과 같은 지표를 모니터링하세요.\n\n```js\n# 쿼리 성능 측정\nActiveRecord::Base.connection.execute(\"SHOW STATUS LIKE 'Queries'\")\n# ^-- 데이터베이스 쿼리 지표를 검색하고 표시합니다.\n```\n\n## 프론트엔드 및 HTTP 레이어 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드와 HTTP 레이어를 최적화하면 페이지 로드 시간을 줄이고 상호 작용성을 향상시켜 사용자 경험에 직접적인 영향을 줄 수 있어요.\n\n예시 기술:\n\n- HTTP 요청 최소화\n\n```js\n# CSS 스프라이트 사용\n\u003c%= image_tag 'sprite.png' %\u003e\n# ^-- 이미지 HTTP 요청 수를 줄이기 위해 CSS 스프라이트 사용.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 캐싱 활용하기\n\n```js\n# 조각 캐싱\n\u003c% cache @post do %\u003e\n \u003c%= render @post %\u003e\n\u003c% end %\u003e\n# ^-- @post의 렌더링을 캐싱하여 페이지 로드 시간을 개선합니다.\n```\n\n3. 이미지 최적화\n\n```js\n# 이미지 압축\n\u003c%= image_tag 'image.jpg', size: '200x200' %\u003e\n# ^-- 페이지 로드 크기를 줄이고 성능을 향상시키기 위해 이미지를 압축하고 크기를 조정합니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. Gzip 압축 기능 활성화\n\n```js\n# Rails에서 Gzip 활성화\nconfig.middleware.use Rack::Deflater\n# ^-- 데이터 전송 크기를 줄이고 로드 시간을 개선하기 위해 Gzip 압축을 활성화합니다.\n```\n\n## 가능한 경우 페이지네이션 사용하기\n\n페이지네이션은 한 번에 일부 데이터를 렌더링하여 보기 성능을 개선하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@posts = Post.paginate(page: params[:page], per_page: 10)\n# ^-- 한 페이지 당 로드되는 데이터 양을 제한하기 위해 @posts를 페이지네이션합니다.\n\n```\n\n## 데이터베이스 쿼리 캐싱\n\n캐싱은 성능을 크게 향상시킬 수 있지만, 데이터의 오래된 상태와 메모리 사용량 증가와 같은 문제를 피하기 위해 신중하게 사용해야 합니다.\n\n```js\n# 복잡한 쿼리 캐싱\nRails.cache.fetch(\"post_stats\", expires_in: 12.hours) do\n Post.calculate_stats\nend\n# ^-- 복잡한 쿼리를 캐시하여 응답 시간을 개선하고 데이터베이스 부하를 줄입니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nRails 애플리케이션 성능을 향상시키는 것은 프로파일링, 벤치마킹, 그리고 백엔드와 프론트엔드 모두를 최적화하는 지속적인 과정입니다. 이러한 기술을 적용하고 New Relic, stackprof 등의 도구 및 적절한 데이터베이스 인덱싱을 활용하여 빠르고 확장 가능하며 반응성 있는 애플리케이션을 보장할 수 있습니다.\n\n더 많은 내용 및 심층적인 예제를 보려면 다음 자료를 참고하세요:\n\n- Active Record 쿼리 성능 팁\n- 뷰 성능 최적화하기","ogImage":{"url":"/assets/img/2024-07-01-OptimisingRailsApplicationPerformanceAOverviewGuide_0.png"},"coverImage":"/assets/img/2024-07-01-OptimisingRailsApplicationPerformanceAOverviewGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"Alba로 루비 API 성능 향상하는 방법","description":"","date":"2024-07-01 16:47","slug":"2024-07-01-BoostingYourRubyAPIPerformancewithAlba","content":"\n\n요즘 빠르게 변화하는 세상에서 API 성능이 가장 중요합니다. 사용자들은 빠른 응답을 기대하며, 느린 API는 당황과 이탈로 이어질 수 있습니다. Ruby로 API를 개발하는 경우, Alba 젬이 큰 변화를 가져다 줄 수 있습니다.\n\nAlba가 무엇인가요?\n\nAlba는 Ruby용 빠른 JSON 직렬화 도구입니다. 세 가지 핵심 측면에 중점을 두고 있습니다:\n\n- 성능: Alba는 탁월한 속도로 유명하며, 대량의 데이터를 효율적으로 처리하는 데 이상적입니다.\n- 유연성: Alba는 높은 수준의 사용자 정의를 제공하여 직렬화 프로세스를 귀하의 요구에 맞게 조정할 수 있습니다.\n- 사용 편의성: 강력함에도 불구하고, Alba는 Ruby 프로젝트에 쉽게 사용하고 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알바를 사용해야 하는 이유\n\n다음은 다음 루비 프로젝트에서 알바를 고려해야 할 확실한 이유입니다:\n\n- 속도 악마: 표준 루비 라이브러리와 비교하여 알바를 사용하면 특히 복잡한 데이터 구조를 처리할 때 성능을 크게 향상시킬 수 있습니다.\n- 가벼우면서 깔끔: 다른 일부 JSON 직렬화 프로그램과 달리 알바는 최소한의 종속성만 있어 프로젝트를 깔끔하게 유지하고 잠재적인 충돌을 줄일 수 있습니다.\n- 레일즈와 궁합이 잘 맞음: 알바는 레일즈 애플리케이션과 완벽하게 통합되어 API 엔드포인트에 구현하는 데 편리합니다.\n\n알바를 사용하려면 먼저 Gemfile에 추가하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n젬 'alba'\n```\n\n그런 다음, 직렬화기를 정의하십시오:\n\n```js\nclass UserSerializer\n  include Alba::Serializer\n\n  attributes :id, :name, :email\n\n  attribute :full_name do |user|\n    \"#{user.first_name} #{user.last_name}\"\n  end\n\n  has_many :posts\nend\n```\n\n직렬화기를 사용하는 것은 간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nuser = User.find(1)\nUserSerializer.new(user).serialize\n```\n\nAPI에서 사용법\n\n```js\nclass UsersController \u003c ApplicationController\n  def index\n    users = User.all\n    render json: UserSerializer.new(users)\n  end\n\n  def show\n    user = User.find(1)\n    render json: UserSerializer.new(user)\n  end\nend\n```\n\n컬렉션과 단일 레코드 처리를 자동으로 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직렬화에서 Params 사용하기\n\n```js\nclass UserSerializer\n  include Alba::Serializer\n\n  attributes :id, :name, :email, :application_name\n\n  attribute :full_name do |user|\n    \"#{user.first_name} #{user.last_name}\"\n  end\n\n  attributes :application_name do |user|\n    user_application = user_application_for_user(user)\n    user_application.name\n  end\n\n  has_many :posts\n\n  private\n  def user_application_for_user(user)\n    UserApplication.find_by!(application_id: params[:application_id], user: user)\n  end\nend\n```\n\n직렬화기에 Params 전달하는 방법\n\n```js\nclass UsersController \u003c ApplicationController\n  def index\n    users = User.all\n    render json: UserSerializer.new(users, params: { application_id: current_application.id})\n  end\n\n  def show\n    user = User.find(1)\n    render json: UserSerializer.new(user, params: { application_id: current_application.id})\n  end\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트\n\n여기에서 직렬화기를 테스트할 수 있습니다. 기본 예제는 다음과 같습니다.\n\n```js\nRSpec.describe UserSerializer, type: :serializer do\n  let!(:user)             { FactoryBot.create(:user , name: \"name\", email: \"abc@arkhitech.com\"}\n  let!(:application)      { FactoryBot.create(:application, name: \"Arkhitech\") }\n  let!(:user_application) { FactoryBot.create(:user_application, application: application, user: user) }\n\n  describe 'serialization' do\n    context 'when correct user is passed' do \n      subject { described_class.new(user) }\n      it \"return correct json response\" do\n        serialized = JSON.parse(subject.to_json) \n        expect(serialized['id']).to eq(user.id)\n        expect(serialized['name']).to eq(user.name)\n        expect(serialized['email']).to eq(user.email)\n        expect(serialized['application_name']).to eq(application.name)\n      end\n    end\n  end\nend\n```\n\n## 기본 이외의 것들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAlba는 다음과 같은 고급 사용자를 위한 다양한 기능을 제공합니다:\n\n- Customizable Serialization: 특정 데이터 유형의 직렬화 방법을 제어하세요.\n- Error Handling: 직렬화 오류를 우아하게 처리하세요.\n- Compatibility: Ruby, JRuby, 그리고 TruffleRuby 구현과 호환됩니다.\n\n## 결론\n\nAlba는 루비에서 API 직렬화에 대한 혁신적인 방법을 제공하며, 사용 편의성과 높은 성능을 결합하고 있습니다. 새로운 API를 구축하거나 기존 API를 리팩토링할 때 Alba를 고려할 가치가 있습니다. 빠르고 유연하며 사용하기 쉬운 기능은 모든 루비 개발자에게 가치 있는 자산으로 다가올 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알바를 시도해보세요! 자세한 지침과 예제는 공식 문서 https://github.com/okuramasafumi/alba 에서 확인할 수 있어요!","ogImage":{"url":"/assets/img/2024-07-01-BoostingYourRubyAPIPerformancewithAlba_0.png"},"coverImage":"/assets/img/2024-07-01-BoostingYourRubyAPIPerformancewithAlba_0.png","tag":["Tech"],"readingTime":4},{"title":"강력한 인사이트를 얻는 법 Rails에 New Relic Analytics 통합하기","description":"","date":"2024-07-01 16:47","slug":"2024-07-01-UnlockPowerfulInsightsIntegratingNewRelicAnalyticsinRails","content":"\n\nNew Relic은 개발자가 애플리케이션의 상태와 성능을 모니터링할 수 있도록 도와주는 강력한 응용 프로그램 성능 모니터링 (APM) 도구입니다. New Relic 젬은 New Relic의 APM 기능을 Ruby 응용 프로그램에 통합하여 응용 프로그램 성능, 오류 추적 및 자세한 트랜잭션 추적을 제공하는 Ruby 라이브러리입니다.\n\n## New Relic 젬의 기능\n\n- 성능 모니터링: 이 젬은 Ruby 응용 프로그램의 성능을 추적하여 응답 시간, 처리량 및 데이터베이스 쿼리에 대한 실시간 데이터를 제공합니다.\n- 오류 추적: 오류를 식별하고 기록하여 디버그하고 문제를 해결하기 쉽게 합니다.\n- 트랜잭션 추적: 이 젬은 트랜잭션의 자세한 추적을 제공하여 응용 프로그램 내에서 시간이 소비되는 곳을 파악할 수 있습니다.\n- 사용자 정의 메트릭: 응용 프로그램의 특정 측면을 추적하기 위해 사용자 정의 메트릭을 만들 수 있습니다.\n\n## 단계 1: 젬 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGemfile에 New Relic Gem을 추가해주세요:\n\n```js\ngem 'newrelic_rpm'\n```\n\n그런 다음, `bundle install` 명령어를 실행하여 gem을 설치해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 구성\n\n뉴 렐릭 구성 파일을 생성하세요.\n\n```js\nbundle exec newrelic install --license_key=YOUR_NEW_RELIC_LICENSE_KEY\n```\n\n실제 뉴 렐릭 라이센스 키로 YOUR_NEW_RELIC_LICENSE_KEY를 대체하세요. 이 명령어는 구성 디렉토리에 newrelic.yml 파일을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: 환경 설정 구성\n\n적절한 환경 설정을 지정하려면 newrelic.yml 파일을 편집하십시오. 다른 환경(개발, 테스트, 프로덕션 등)에 대해 다른 구성을 지정할 수 있습니다. 라이선스 키와 애플리케이션 이름이 올바르게 설정되어 있는지 확인하세요.\n\n## 구성 예시:\n\n```js\ncommon: \u0026default_settings\n  license_key: 'YOUR_NEW_RELIC_LICENSE_KEY'\n  app_name: My Application (Development)\n\ndevelopment:\n  \u003c\u003c: *default_settings\n\nproduction:\n  \u003c\u003c: *default_settings\n  app_name: My Application\n  monitor_mode: true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: 애플리케이션을 배포합니다\n\n일반적으로 애플리케이션을 배포하세요. New Relic 젬은 데이터 수집을 시작하고 이를 New Relic 서버로 전송합니다.\n\n# 단계 5: 데이터 확인하기\n\nNew Relic 계정으로 로그인하고 APM 섹션으로 이동하세요. 여기에서 애플리케이션의 성능 데이터를 볼 수 있습니다. 응답 시간, 처리량, 오류율 등이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nNew Relic 젬은 루비 개발자들이 애플리케이션의 성능과 안정성에 대한 통찰력을 얻기 위해 가치 있는 도구입니다. 위에서 설명한 단계를 따라하면 New Relic을 쉽게 루비 애플리케이션에 통합하고 실시간으로 해당 건강 상태와 성능을 모니터링할 수 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-UnlockPowerfulInsightsIntegratingNewRelicAnalyticsinRails_0.png"},"coverImage":"/assets/img/2024-07-01-UnlockPowerfulInsightsIntegratingNewRelicAnalyticsinRails_0.png","tag":["Tech"],"readingTime":2},{"title":"Java 21  더 이상 필요 없는 public static void main","description":"","date":"2024-07-01 16:46","slug":"2024-07-01-Java21Nomorepublicstaticvoidmain","content":"\n\n## 새로운 main() 메서드로 길을 찾아가기\n\n![이미지](/assets/img/2024-07-01-Java21Nomorepublicstaticvoidmain_0.png)\n\n그렇습니다. Java 21에서는 public static void main() 메서드가 더 이상 필수적이지 않습니다.\n\n이것은 Java 애플리케이션의 코딩을 간소화하기 위해 Java 21에서 도입된 새로운 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바에서 main() 메서드는 모든 자바 프로그램의 시작점입니다. 자바 프로그램을 실행할 때 자바 가상 머신(JVM)은 main() 메서드를 호출하여 프로그램을 시작합니다.\n\n## 그런데, 그 이유는 뭘까요?\n\n# ✅ 간단함\n\n먼저, Java를 배우는 초보자들에게 더 쉽게 만들어 줍니다. main() 메서드는 새로운 프로그래머들에게 진입 장벽으로 여겨지기도 하는데, 이해하기에 혼란스러울 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ✅다른 프로그래밍 언어와 일관성을 유지하기 위해\n\n둘째, 이 변경으로 Java는 다른 프로그래밍 언어와 더 일관성있게 됩니다. 다른 많은 언어에서는 프로그램의 시작점이 main()과 같은 특정 메서드가 아니라, 시작 시에 실행되는 코드 블록입니다.\n\n그리고 이게 놀랍다구요 - Java는 Python이나 JavaScript와 같은 다른 프로그래밍 언어와 일관성을 유지하려고 노력하고 있어요. 이들 언어는 main() 메서드를 굳이 사용하지 않는데, Java가 왜 사용해야 하나요?\n\n# ✅유연성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 자바 프로그램의 구조를 더 유연하게 만들어 주는 새로운 가능성을 엽니다. 이제 main 클래스 없이도 자바 프로그램을 만들 수 있어 더 유연성이 증가했습니다.\n\n이전에는 main() 메서드를 선언하는 엄격한 방법을 따라야 했고, 새로운 시도를 하고 싶을 때 제한을 받았습니다. 그러나 이제 main() 메서드 없이, 당신은 다양한 프로그래밍 스타일을 탐험할 수 있습니다.\n\n예를 들어 함수형 프로그래밍과 같은 일부 프로그래밍 스타일은 main() 메서드를 전혀 사용하지 않습니다. 함수형 프로그래밍에서는 프로그램이 작고 재사용 가능한 함수들로 구축되며, 프로그램을 시작하는 중심적인 main() 메서드가 필요하지 않습니다.\n\n다음은 public static void main() 메서드 없이 자바 프로그램을 실행하는 샘플 코드입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nclass HelloWorld {\n\n     void main() {\n        System.out.println(\"Hello, world!\");\n    }\n\n}\n```\n\n## 이제 더 나아가서:\n\nJava 21에서 제공하는 '이름 없는 클래스(unnamed classes)' 기능을 사용하면 클래스를 선언하지 않고도 간단한 Java 프로그램을 작성할 수 있습니다.\n \n예를 들어, 개발자는 여러 개의 작고 자기 포함 함수로 구성된 프로그램을 작성할 수 있습니다. 각 함수는 자체 '이름 없는 클래스(unnamed class)'에 정의될 수 있고, 이러한 함수들은 main 메소드에서 호출될 수 있습니다. 이렇게 하면 프로그램이 모듈식이 되며, 각 함수가 특정한 작업을 수행할 수 있어 이해하기 쉬워집니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnew {\n    System.out.println(\"안녕, 세상아!\");\n}\n```\n\n전반적으로 main() 메서드의 제거는 자바에 대한 긍정적인 변화입니다. 이것은 언어를 더 접근 가능하고, 현대적이며 유연하게 만듭니다. 자바 개발자라면 한 번 시도해보는 것을 권장합니다.","ogImage":{"url":"/assets/img/2024-07-01-Java21Nomorepublicstaticvoidmain_0.png"},"coverImage":"/assets/img/2024-07-01-Java21Nomorepublicstaticvoidmain_0.png","tag":["Tech"],"readingTime":2},{"title":"Spring Boot 3로 분산 추적하는 방법  Micrometer와 OpenTelemetry 비교","description":"","date":"2024-07-01 16:44","slug":"2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry","content":"\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Micrometer 추적 시작하기\n\n기존의 Spring Boot 3 애플리케이션이 있다고 가정하면, 추적을 시작하는 간단한 방법은 Micrometer Tracing 라이브러리를 사용하는 것입니다. 아래 종속성을 추가해야 합니다:\n\n```js\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- 추적 API 추가 --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n    \u003cartifactId\u003emicrometer-tracing\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- 추적 구현체 추가 --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n    \u003cartifactId\u003emicrometer-tracing-bridge-otel\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- 추적을 저장하는 익스포터 추가 --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.opentelemetry\u003c/groupId\u003e\n    \u003cartifactId\u003eopentelemetry-exporter-otlp\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n추적에 사용되는 라이브러리(Micrometer)와 추적 데이터가 전송되는 익스포터(Jaeger)를 모두 교체할 수 있는 OpenTelemetry와 OTLP를 완전히 공급업체 중립적인 구현으로 사용할 수 있다는 점에 유의하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJaeger를 Exporter로 선택했기 때문에 실행해야 합니다. 아래 명령어로 시작해보세요:\n\n```js\ndocker run --rm -d --name jaeger \\\n  -p 16686:16686 \\\n  -p 4317:4317 \\\n  -p 4318:4318 \\\n  jaegertracing/all-in-one:1.53\n```\n\napplication.yaml 파일에 아래 항목을 추가하여 모든 요청이 추적되도록 설정하세요 (기본적으로는 요청의 10%만 추적됩니다). Jaeger의 엔드포인트도 구성되어 있습니다.\n\n```js\nspring:\n  application:\n    name: \"http-service1\"\n\nmanagement:\n  tracing:\n    sampling:\n      probability: 1.0\n  otlp:\n    tracing:\n      endpoint: http://localhost:4318/v1/traces\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"  \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 예제 애플리케이션은 두 개의 서비스로 구성되어 있어요. HTTP 서비스 1은 HTTP 서비스 2에 REST 호출을 하고, HTTP 서비스 2는 원격 서비스에 동기 REST 호출을 하여 커밋 메시지를 가져옵니다. 그리고 이 메시지를 서비스 1로 반환해요.\n\n![이미지](/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_1.png)\n\n이제 애플리케이션을 시작하고 HTTP 요청을 보내보세요. 브라우저에서 http://localhost:16686에 Jaeger를 방문하여 요청의 추적 정보를 확인할 수 있어요.\n\n![이미지](/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 많은 라이브러리가 자동으로 추적됩니다. Instrumented Projects에서 전체 목록을 확인할 수 있습니다. JDBC와 같은 일부 라이브러리는 추적을 활성화하려면 pom.xml에 특정 종속성을 추가해야 합니다.\n\n## Micrometer Observation API를 사용하여 사용자 정의 스팬 생성\n\n기본 추적은 좋지만 실제 추적의 가치를 실현하려면 비즈니스 컨텍스트를 가진 사용자 정의 스팬을 추가해야 합니다. 이를 통해 \"주문을 한 사용자는 누구인가?\", \"특정 테넌트의 요청이 왜 느린가?\", \"이 사용자가 이 추적 번호로 주문한 주문의 배송이 지연된 이유는 무엇인가?\"와 같은 질문에 답변할 수 있습니다.\n\n샘플 애플리케이션에서는 원격 서비스에서 가져온 실제 커밋 메시지를 추적하고 싶습니다. 다음은 원격 시스템에서 랜덤 \"커밋 메시지\"를 가져오기 위해 HTTP 호출을 수행하는 서비스의 예입니다. 실제 커밋 메시지는 스팬 태그로 캡처됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Service\nclass FetchCommitService {\n\n    private final RestTemplate restTemplate;\n    private final ObservationRegistry registry;\n\n    FetchCommitService(RestTemplate restTemplate, ObservationRegistry registry) {\n        this.restTemplate = restTemplate;\n        this.registry = registry;\n    }\n\n    String fetchCommit() {\n        var observation = Observation.createNotStarted(\"fetch-commit\", registry).start();\n\n        try (var ignored = observation.openScope()) {\n            String commitMsg = this.restTemplate.getForObject(\"https://whatthecommit.com/index.txt\", String.class);\n            observation.highCardinalityKeyValue(\"commit.message\", commitMsg);\n            observation.event(Observation.Event.of(\"commit-fetched\"));\n            return commitMsg;\n        } finally {\n            observation.stop();\n        }\n    }\n}\n```\n\n지켜볼 것은 두 가지 유형의 관찰이 있습니다. 낮은 cardinality와 높은 cardinality가 있습니다. 만약 키에 수천 개의 다른 값이 예상되면 높은 cardinality를 사용하세요. 값이 제한된 집합이라면 낮은 cardinality 관찰을 만드세요.\n\nJaeger에서 추적을 확인해 봅시다. 커밋 메시지를 포함한 commit.message 태그가있는 fetch-commit이라는 새로운 스팬에 주목하세요. 추적에서 비즈니스에 관련된 데이터를 캡처했습니다!\n\n\u003cimg src=\"/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_3.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObservation API를 사용하는 또 다른 장점은 모든 관측치가 메트릭과 추적을 모두 생성한다는 것입니다. 확인해보기 위해 액추에이터 메트릭 엔드포인트인 http://localhost:8081/actuator/metrics/fetch-commit을 호출해봅시다. 기본적으로 메트릭의 개수, 총 시간 및 최대 값이 계산됩니다. Micrometer Prometheus 라이브러리를 사용하면 이러한 메트릭을 특정 형식으로 변환하고 Prometheus에 저장할 수 있습니다.\n\n```js\n{\n  \"name\": \"fetch-commit\",\n  \"baseUnit\": \"seconds\",\n  \"measurements\": [\n    {\n      \"statistic\": \"COUNT\",\n      \"value\": 2.0\n    },\n    {\n      \"statistic\": \"TOTAL_TIME\",\n      \"value\": 1.836001333\n    },\n    {\n      \"statistic\": \"MAX\",\n      \"value\": 0.0\n    }\n  ],\n  \"availableTags\": [\n    {\n      \"tag\": \"error\",\n      \"values\": [\n        \"none\"\n      ]\n    }\n  ]\n}\n```\n\n또한 Observation API 대신 Micrometer의 저수준 추적 API를 직접 사용할 수도 있습니다. 이를 하는 유일한 이유는 메트릭을 생성하지 않기 위해서일 것입니다.\n\n## OpenTelemetry 자동 Instrumentation 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMicrometer은 Spring Boot 애플리케이션을 추적하는 권장 방법입니다만, 유일한 방법은 아닙니다. OpenTelemetry 자동 계측을 직접 사용하여 Micrometer가 제공하는 추상화 계층을 건너뛸 수 있습니다.\n\n아래 종속성을 pom.xml에 추가해보세요.\n\n```js\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- OTLP 프로토콜을 지원하는 익스포터 --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.opentelemetry\u003c/groupId\u003e\n    \u003cartifactId\u003eopentelemetry-exporter-otlp\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- 어노테이션을 활용한 사용자 지정 스패인을 위한 종속성 --\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.opentelemetry.instrumentation\u003c/groupId\u003e\n    \u003cartifactId\u003eopentelemetry-instrumentation-annotations\u003c/artifactId\u003e\n    \u003cversion\u003e${opentelemetry-instrumentation-annotations.version}\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\nOpenTelemetry를 직접 사용하기 위해서는 애플리케이션을 OpenTelemetry 에이전트와 함께 실행해야 합니다. 아래 명령어로 두 서비스를 시작해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\njava -javaagent:./opentelemetry-javaagent.jar \\\n  -Dotel.service.name=http-service1 \\\n  -Dotel.exporter.otlp.endpoint=http://localhost:4317 \\\n  -Dotel.exporter.otlp.protocol=grpc \\\n  -Dotel.traces.exporter=otlp \\\n  -Dotel.metrics.exporter=none \\\n  -jar otel-http/httpservice1/target/httpservice1-0.0.1-SNAPSHOT.jar\n\njava -javaagent:./opentelemetry-javaagent.jar \\\n  -Dotel.service.name=http-service2 \\\n  -Dotel.exporter.otlp.endpoint=http://localhost:4317 \\\n  -Dotel.exporter.otlp.protocol=grpc \\\n  -Dotel.traces.exporter=otlp \\\n  -Dotel.metrics.exporter=none \\\n  -jar otel-http/httpservice2/target/httpservice2-0.0.1-SNAPSHOT.jar\n```\n\n옵션 -Dotel.traces.exporter는 내보내기자를 지정합니다 (유효한 옵션은 otlp, zipkin, console 및 none). 옵션 -Dotel.exporter.otlp.protocol은 OTLP 전송 프로토콜을 지정합니다 (유효한 옵션은 grpc, http/protobuf 및 http/json). 선택은 백엔드 및 해당 지원 옵션에 따라 다릅니다.\n\ncurl 호출을 실행하고 Jaeger에서 추적을 확인하세요:\n\n\u003cimg src=\"/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 정의 span fetch-commit에는 commit.message 태그가 있는 사용자 정의 span이 있음을 알립니다. OpenTelemetry 자동 계측을 사용하면 아래와 같이 사용자 정의 span을 추가할 수 있습니다:\n\n```js\n@Service\nclass FetchCommitService {\n\n    private final RestTemplate restTemplate;\n    private final Tracer tracer;\n\n    FetchCommitService(RestTemplate restTemplate, OpenTelemetry openTelemetry) {\n        this.restTemplate = restTemplate;\n        this.tracer = openTelemetry.getTracer(FetchCommitService.class.getName());\n    }\n\n    String fetchCommit() {\n        Span span = tracer.spanBuilder(\"fetch-commit\").startSpan();\n        try (Scope ignored = span.makeCurrent()) {\n            String commitMsg = this.restTemplate.getForObject(\"https://whatthecommit.com/index.txt\", String.class);\n            span.setAttribute(\"commit.message\", commitMsg);\n            return commitMsg;\n        } finally {\n            span.end();\n        }\n    }\n}\n```\n\n코드가 매우 유사하지만 다른 라이브러리를 사용한다는 것을 알 수 있습니다. 이 접근 방식의 단점은 사용자 정의 메트릭이 생성되지 않는다는 것입니다. 반면, 자동으로 계측되는 라이브러리 목록은 Micrometer보다 훨씬 더 큽니다. pom.xml에 추가할 추가 종속성이 필요하지 않으며, 모든 것이 에이전트에서 제공됩니다. 계측된 라이브러리의 전체 목록은 다음을 참조하세요: https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks\n\n## Micrometer Tracing 또는 OpenTelemetry Auto Instrumentation을 사용해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 정해진 사항이 아닙니다. 이 기본 선택 사항이 틀리다는 것은 없어요. 스프링 애플리케이션에는 Micrometer Tracing이 가는 방법일 것입니다.\n\n자동 계측이 설정되면 중요 비즈니스 필드를 추가하여 컨텍스트를 확장하여 보다 유용하게 만드는 사용자 지정 스패를 천천히 추가할 수 있습니다.\n\nMicrometer Tracing은 여전히 발전 중인 라이브러리이며, 지난 번에 (특히 Sleuth 라이브러리와 함께) 소규모 버전을 업그레이드하는 동안 문제가 발생했던 경험이 있습니다. 하지만 계속해서 향상될 것이며, 단일 API로 사용자 정의 메트릭 및 트레이스를 생성하는 유혹에 저항하기 어려운 매력이 있습니다.\n\n## Micrometer을 활용한 통합 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비즈니스 컨텍스트를 제공하는 사용자 정의 span을 추가할 때, 실수로 삭제되지 않도록 하고 항상 새로운 코드가 계측되도록 하는 것이 중요합니다. Micrometer는 아래 종속성을 이용하여 코드를 테스트하고 spans 및 tags를 확인하는 방법을 제공합니다:\n\n```js\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n    \u003cartifactId\u003emicrometer-tracing-integration-test\u003c/artifactId\u003e\n    \u003cscope\u003etest\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n아래는 Micrometer Observability API에서 생성된 spans 및 metrics를 확인하는 통합 테스트의 예제입니다.\n\n```js\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\n        properties = {\n                \"whatthecommit.url=http://localhost:${wiremock.server.port}\",\n        })\n@AutoConfigureMockMvc\n@AutoConfigureWireMock(port = 0)\nclass ApplicationIT extends SampleTestRunner {\n\n    private static final String COMMIT_MESSAGE = \"A funny commit message\";\n\n    @Autowired\n    MockMvc mockMvc;\n\n    @Autowired\n    ObservationRegistry observationRegistry;\n\n    @Autowired\n    MeterRegistry meterRegistry;\n\n    @Override\n    protected ObservationRegistry createObservationRegistry() {\n        return this.observationRegistry;\n    }\n\n    @Override\n    protected MeterRegistry createMeterRegistry() {\n        return this.meterRegistry;\n    }\n\n    @Override\n    public TracingSetup[] getTracingSetup() {\n        return new TracingSetup[]{IN_MEMORY_OTEL};\n    }\n\n    @Override\n    public SampleTestRunnerConsumer yourCode() {\n\n        return (bb, meterRegistry) -\u003e {\n            stubFor(get(urlEqualTo(\"/\"))\n                    .willReturn(aResponse()\n                            .withStatus(SC_OK)\n                            .withResponseBody(new Body(COMMIT_MESSAGE)))\n            );\n\n            this.mockMvc.perform(MockMvcRequestBuilders.get(\"/\"))\n                    .andDo(print())\n                    .andExpect(status().isOk())\n                    .andExpect(content().string(containsString(COMMIT_MESSAGE)));\n\n            SpansAssert.assertThat(bb.getFinishedSpans())\n                    .haveSameTraceId()\n                    .hasNumberOfSpansEqualTo(3)\n                    // 스팬 1 확인\n                    .thenASpanWithNameEqualTo(\"http get\")\n                    .hasKindEqualTo(Kind.CLIENT)\n                    .hasTag(\"method\", \"GET\")\n                    .hasTag(\"status\", \"200\")\n                    .backToSpans()\n                    // 스팬 2 확인\n                    .thenASpanWithNameEqualTo(\"fetch-commit\")\n                    .hasTag(\"commit.message\", COMMIT_MESSAGE)\n                    .hasEventWithNameEqualTo(\"commit-fetched\")\n                    .backToSpans()\n                    // 스팬 3 확인\n                    .thenASpanWithNameEqualTo(\"http get /\")\n                    .hasKindEqualTo(Kind.SERVER)\n                    .hasTag(\"method\", \"GET\")\n                    .hasTag(\"http.url\", \"/\")\n                    .hasTag(\"status\", \"200\");\n\n            MeterRegistryAssert.assertThat(meterRegistry)\n                    .hasTimerWithNameAndTags(\"fetch-commit\", Tags.of(Tag.of(\"error\", \"none\")))\n                    .hasMeterWithName(\"fetch-commit.commit-fetched\");\n        };\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원격 서비스가 WireMock으로 대체되는 전형적인 IT입니다. REST 엔드포인트는 MockMvc로 호출되고 예상 응답이 확인됩니다. 또한, Micrometer에 의해 생성될 것으로 예상되는 스팬 및 메트릭을 검증합니다.\n\n게시물을 마치기 전에 몇 가지 일반적인 우려 사항에 대해 논의하려 합니다.\n\n## 자바 에이전트는 응용 프로그램 성능에 부정적인 영향을 미칩니다!\n\n모든 에이전트가 그렇지는 않습니다. 제대로 작성되지 않은 에이전트는 성능에 영향을 미치기 쉬우며 OpenTelemetry 에이전트는 해당 사례 중 하나가 아닙니다. 또한, 일반적으로 에이전트의 성능에 대한 잔류적인 영향이 여러분이 생각하는 것만큼 나쁘지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션의 성능이 중요하다면 몇 가지 테스트를 진행하고 결과를 측정한 다음 결정하세요. 그러나 에이전트 기반 솔루션을 맹목적으로 거부하는 것은 좋지 않아요.\n\n## 추적 코드가 내 비즈니스 로직과 얽혀 있어요!\n\n네, 안타깝게도 이것을 피할 수 없어요. 하지만 생각해보세요. 추적의 아이디어는 제품의 비즈니스 코드 동작에 대한 통찰력을 얻는 것이에요. 자동 계기 활성화는 최상의 경우에도 HTTP, JDBC, 메시징 및 기타 통합 지점 주변의 일반적인 통찰력을 제공할 뿐이에요. 그러나 제품에서 알 수 없는 사건을 이해하는 데 도움이 되는 진짜 통찰력을 얻으려면 캡처된 추적에 비즈니스 컨텍스트를 포함해야 해요.\n\n그래서 추적이 비즈니스 로직의 필수적인 부분임을 받아들이세요. 결국 로깅 문이 비즈니스 코드 내부에 배치될 수 있다면 왜 추적을 배치하지 않을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 추적이 필요하지 않아요. 로그에서의 상관 ID만 있으면 돼요!\n\n네, 그렇죠. 추적 대신 로그에서의 상관 ID를 요구하는 것은 자동차가 있는데 말 소마찬가지에 달려 있는 것을 요구하는 것과 같아요. 분산 추적은 단순히 서비스 간에 요청을 연결하는 것 이상을 제공해요. 각 서비스에서 요청의 지연 시간 측정을 제공해요. 쿼리 추적을 통해 N+1 쿼리 문제를 쉽게 식별할 수 있어요. 좋은 추적 저장 엔진은 이상 현상과 특이한 추세를 식별하는 데 도움이 되며 (Honeycomb에 감사드려요!).\n\n뿐만 아니라 Micrometer와 OpenTelemetry 라이브러리는 로그에 추적 및 Span ID를 주입할 수 있도록 지원하기 때문에 상관 ID를 포기할 필요가 없어요. 이제 더 이상 분산 추적을 피하기 위한 핑계는 없어요!\n\n## Spring Native GraalVM 애플리케이션은 어떨까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMicrometer과 OpenTelemetry은 둘 다 Spring 네이티브 애플리케이션에서 사용할 수 있어요. OpenTelemetry 에이전트는 직접 사용할 수 없지만, 특정 종속성을 추가할 수 있어요.\n\n다음 예시 코드를 따라서 Micrometer와 Spring Native, 그리고 OpenTelemetry와 Spring Native를 사용해 보세요. 저는 개인적으로 Micrometer가 네이티브 Spring 애플리케이션과 함께 사용하기에 더 쉽다고 생각해요. OpenTelemetry의 수동 계측 (에이전트 없음)은 다양한 계측 라이브러리와 설정의 적절한 구성이 필요해 번거로울 수 있어요.\n\n## 결론\n\n측정 및 추적을 통한 가시성은 몇 년 전과는 많이 다르죠. Java 스택에서는 이미 라이브러리들이 성숙해졌기 때문에 지금 바로 애플리케이션에 적용하고 프로 수준의 생산 문제 해결 능력을 갖추세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub에서 완전히 작동하는 코드 샘플을 확인하실 수 있어요.","ogImage":{"url":"/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_0.png"},"coverImage":"/assets/img/2024-07-01-DistributedTracingwithSpringBoot3MicrometervsOpenTelemetry_0.png","tag":["Tech"],"readingTime":14},{"title":"Java 8에서 Java 21까지 2024년에 코드를 업그레이드해야 하는 이유","description":"","date":"2024-07-01 16:43","slug":"2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21","content":"\n\n자바 8은 훌륭하지만, 후속 버전인 자바에는 멋진 새로운 기능들이 있습니다! 함께 새로운 기능들을 살펴봐요!\n\n## 자바 8에서 자바 9로의 새로운 기능 업데이트\n\n## 자바 9에서 자바 10으로의 새로운 기능 업데이트\n\n## 자바 10에서 자바 11로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n![Java 11 to Java 17 Features Update](/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_0.png)\n\n# Java 11 to Java 17 Features Update\n\n![Java 17 to Java 21 Features Update](/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_1.png)\n\n# Java 17 to Java 21 Features Update\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRef-\n1. [Java SE at a Glance](https://www.oracle.com/java/technologies/java-se-glance.html)\n\n# 🎉 여러분의 스킬이 업그레이드 되고 있는 것 같네요! 🎉\n\n![Java code makeover](/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_2.png)","ogImage":{"url":"/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_0.png"},"coverImage":"/assets/img/2024-07-01-Java8Java21YourCodeDeservesaMakeover-Hoponto21_0.png","tag":["Tech"],"readingTime":1},{"title":"Swift에서 선언형 프로그래밍과 명령형 프로그래밍 비교분석","description":"","date":"2024-06-30 22:52","slug":"2024-06-30-DeclarativevsImperativeprogramminginSwift","content":"\n\n선언적 및 명령형 프로그래밍은 코드 작성 방식에 영향을 미치는 두 가지 패러다임입니다. 이 두 패러다임이 Swift에서 어떻게 나타나는지 비교해보겠습니다:\n\n![이미지](/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_0.png)\n\n## 선언적 프로그래밍\n\n선언적 프로그래밍은 프로그램이 어떤 일을 수행해야 하는지 명시적으로 어떻게 달성해야 하는지를 명시하지 않고 요구 사항에 초점을 맞춥니다. Swift에서는 SwiftUI 및 Combine과 같은 프레임워크에서 선언적 프로그래밍이 종종 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 특징:\n\n- 무엇을 해야 하는지 설명합니다: 원하는 상태를 설명하고, 프레임워크가 하부 구현을 처리합니다.\n- 높은 수준의 추상화: 세부 사항을 추상화하는 고수준 구조를 사용합니다.\n- 불변성: 종종 불변 데이터 구조를 활용합니다.\n\n## Swift (SwiftUI)에서의 예시:\n\n![이미지](/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 SwiftUI 예제에서는 사용자 인터페이스 및 동작을 선언하지만 UI를 렌더링하고 업데이트하는 단계를 명시적으로 지정하지 않습니다.\n\n# 명령형 프로그래밍\n\n명령형 프로그래밍은 원하는 결과를 달성하는 방법에 초점을 둡니다. 작업을 수행하는 데 필요한 단계와 논리를 명시적으로 작성합니다. UIKit은 Swift에서 일반적으로 사용되는 명령형 스타일의 예입니다.\n\n## 특징:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 수행 방법 설명: 결과물을 얻는 방법에 대해 자세한 지침을 제공합니다.\n- 하위 수준 제어: 실행 세부 사항에 대해 더 많은 제어를 제공합니다.\n- 가변성: 종종 가변 상태와 변수를 사용합니다.\n\n## Swift에서의 예시 (UIKit):\n\n\u003cimg src=\"/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_2.png\" /\u003e\n\nUIKit 예시에서는 UI 구성 요소가 어떻게 생성되고, 뷰에 추가되며 배치되는지 명시적으로 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Summary\n\n- Declarative: *Focuses on what to do.* Higher-level, more abstract, often immutable.\n- Imperative: *Focuses on how to do it.* Lower-level, more control, often mutable.\n\nIn Swift, declarative style is becoming more prominent with frameworks like SwiftUI, which allows for more concise and readable code that is easier to reason about. However, both paradigms have their place, and understanding when to use each is key to effective Swift programming.","ogImage":{"url":"/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_0.png"},"coverImage":"/assets/img/2024-06-30-DeclarativevsImperativeprogramminginSwift_0.png","tag":["Tech"],"readingTime":2},{"title":"HNG 챔피언십을 위한 내 모바일 앱 개발 여정","description":"","date":"2024-06-30 22:52","slug":"2024-06-30-MyMobileAppDevelopmentJourneyAQuestforHNGChampionship","content":"\n\n저는 Victor Akanmidu이고, 인구 밀집 지역인 HNG 인턴십에서 모바일 앱 개발이라는 위대한 모험에 도전하고 있어요!\n\n### HNG 인턴십\n\nHNG 인턴십이 다시 시작되었어요. 제게는 낯설지 않지만, 매년 HNG 인턴십에서 기술을 연마할 수 있는 새로운 기회가 주어지고 있어요. 이 집중 프로그램은 저와 같은 개발자 지망생이 기술을 향상시키고 기술 분야에서 경력을 쌓을 수 있도록 도와준다고 해요. 빠르게 진행되는 학습 환경과 재능 있는 멘토들과의 협력 기회로 유명하죠. 흥미롭죠? 제가 개발 여정을 나아가는 동안 주시할게요.\n\n### 나의 훈련 과정: 모바일 개발 플랫폼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 원래 목표로 돌아갑시다! 우리 여행의 첫번째 정착지는 모바일 개발 플랫폼의 세계입니다. 이러한 플랫폼은 특정 운영 체제용 앱을 개발하는 데 필요한 도구와 프레임워크를 제공합니다. 여기 주요 두 가지 범주가 있습니다:\n\n- Native Development: 이 접근 방식은 각 운영 체제(안드로이드 및 iOS)에 대해 플랫폼별 언어(안드로이드에는 자바/코틀린, iOS에는 스위프트/Objective-C)를 사용하여 별도의 앱을 빌드하는 것을 포함합니다.\n- 장점: Native 앱은 최고의 성능, 사용자 경험 및 모든 기기 기능에 액세스를 제공합니다.\n- 단점: 여러 언어와 프레임워크에 대한 전문 지식이 필요하여 개발 시간과 비용이 증가합니다.\n- Cross-Platform Development: 여기서는 Android 및 iOS 모두에 대한 앱을 빌드하는 데 사용할 수 있는 단일 코드베이스를 작성합니다. 인기있는 프레임워크로는 React Native, Flutter, Xamarin 등이 있습니다.\n- 장점: 단일 코드베이스를 사용하여 개발 시간과 비용을 절약합니다. 두 플랫폼 모두에 대해 앱을 유지 관리하고 업데이트하기 더 쉽습니다.\n- 단점: 성능이 네이티브 앱만큼 좋지 않을 수 있습니다. 장치별 기능에 액세스하는 데 제약 사항이 있을 수 있습니다.\n\n기반 구축: 소프트웨어 아키텍처 패턴\n\n플랫폼을 선택했다면, 앱을 위한 구조적 청사진을 결정할 차례입니다. 일반적인 패턴은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Model-View-Controller (MVC): 이 전통적인 패턴은 앱을 Model(데이터), View(사용자 인터페이스) 및 Controller(사용자 상호작용 처리)의 세 부분으로 분리합니다.\n- 장점: 간단하고 이해하기 쉽며, 코드 유지보수를 장려합니다.\n- 단점: 대규모 앱에서 복잡해질 수 있으며, Model과 View 간의 강한 결합으로 인해 테스트가 어려울 수 있습니다.\n- Model-View-ViewModel (MVVM): MVC의 진화로, MVVM은 Model과 View 사이에서 중개자로 작용하는 ViewModel을 소개합니다.\n- 장점: 관심사 분리가 개선되고, 테스트가 더 쉬워지며, 코드 재사용을 장려합니다.\n- 단점: MVC에 비해 설정이 약간 복잡할 수 있습니다.\n- Clean Architecture: 이 패턴은 핵심 비즈니스 로직을 플랫폼별 세부사항으로부터 분리하는 데 초점을 둡니다.\n- 장점: 높은 유지보수 가능성 및 테스트 가능한 코드베이스, 느슨하게 결합된 구성 요소를 장려합니다.\n- 단점: 소프트웨어 설계 원칙에 대한 좋은 이해가 필요하며, 높은 학습 곡선이 있을 수 있습니다.\n\n나의 개발 상태\n\n나는 아직 모바일 개발 여정의 초기 단계에 있으므로, 내게 가장 잘 맞는 여러 플랫폼과 아키텍처를 실험할 예정입니다. 내가 겪는 도전, 발견하는 해결책 및 아마도 건설하게 될 멋진 앱들과 함께 여기에 내 경험을 문서화할 계획입니다.\n\n상상해보세요 — 새롭게 습득한 기술을 시험해보고, 훌륭한 머릿속과 협력하여 혹은 심지어 변화를 가져올 앱을 구축하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 이 모험에 함께 하세요! https://hng.tech 에서 가입하실 수 있어요. 모바일 개발의 흥미진진한 세계를 함께 탐험해봐요. 궁금한 점이나 제안이 있으시면 아래에 댓글을 남겨주세요. 혹시 당신도 모바일 개발 여정을 시작하고 있다면, 서로서로 알려주고 배울 수 있을지 모르겠네요!","ogImage":{"url":"/assets/img/2024-06-30-MyMobileAppDevelopmentJourneyAQuestforHNGChampionship_0.png"},"coverImage":"/assets/img/2024-06-30-MyMobileAppDevelopmentJourneyAQuestforHNGChampionship_0.png","tag":["Tech"],"readingTime":3}],"page":"2","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"2"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>