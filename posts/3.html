<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="도커 없이 Optimism 노드 실행하기" href="/post/2024-05-17-RunningOptimismNodewithoutDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커 없이 Optimism 노드 실행하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커 없이 Optimism 노드 실행하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">도커 없이 Optimism 노드 실행하기</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI를 고민해보다" href="/post/2024-05-17-SwiftUIThinking"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI를 고민해보다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-SwiftUIThinking_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI를 고민해보다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SwiftUI를 고민해보다</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구글 IO 2024 AI 혁신과 안드로이드 향상" href="/post/2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구글 IO 2024 AI 혁신과 안드로이드 향상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구글 IO 2024 AI 혁신과 안드로이드 향상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">구글 IO 2024 AI 혁신과 안드로이드 향상</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인프라스트럭처의 코드화" href="/post/2024-05-17-InfrastructureasCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인프라스트럭처의 코드화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-InfrastructureasCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인프라스트럭처의 코드화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">인프라스트럭처의 코드화</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="백스테이지 Kubernetes 플러그인 사용자 정의하기" href="/post/2024-05-17-CustomizingtheBackstageKubernetesPlugin"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="백스테이지 Kubernetes 플러그인 사용자 정의하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="백스테이지 Kubernetes 플러그인 사용자 정의하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">백스테이지 Kubernetes 플러그인 사용자 정의하기</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기" href="/post/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대타브릭 챔피언 여정" href="/post/2024-05-17-DatabricksChampionJourney"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대타브릭 챔피언 여정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-DatabricksChampionJourney_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대타브릭 챔피언 여정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대타브릭 챔피언 여정</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기" href="/post/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="규칙은 우리를 갇히는 우리의 속성일 뿐 그리고 나는 강아지 소녀야" href="/post/2024-05-17-RulesAreACageandImaPuppygirl"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="규칙은 우리를 갇히는 우리의 속성일 뿐 그리고 나는 강아지 소녀야" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="규칙은 우리를 갇히는 우리의 속성일 뿐 그리고 나는 강아지 소녀야" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">규칙은 우리를 갇히는 우리의 속성일 뿐 그리고 나는 강아지 소녀야</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Google IO에서 공식적으로 Kotlin Multiplatform을 지원한다고 발표되었습니다" href="/post/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Google IO에서 공식적으로 Kotlin Multiplatform을 지원한다고 발표되었습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Google IO에서 공식적으로 Kotlin Multiplatform을 지원한다고 발표되었습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Google IO에서 공식적으로 Kotlin Multiplatform을 지원한다고 발표되었습니다</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"도커 없이 Optimism 노드 실행하기","description":"","date":"2024-05-17 03:55","slug":"2024-05-17-RunningOptimismNodewithoutDocker","content":"\n\n\n![Optimism node](/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_0.png)\n\nOptimism 노드를 설치하는 것은 매우 간단합니다. 다른 슈퍼체인과 달리 많은 설정이 기본값으로 설정되어 있기 때문입니다.\n\n그래서 Docker 없이 스냅 동기화 모드로 Optimism 노드를 실행하는 방법을 설명하겠습니다. \"Docker 없이 베이스 노드 실행하기: 파트 2\"에서 파생된 글입니다.\n\n본 문서에서는 다음과 같은 설정을 하게 됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `/etc/environment`에 환경 변수 설정하기\n- op-node 및 op-geth용 systemd 파일 생성하기\n- op-node 및 op-geth 로그를 보존하기 위한 rsyslog 구성 파일 생성하기\n- op-node 및 op-geth용 로그 회전 파일 생성하기\n\n# 1. op-node 및 op-geth 설치하기\n\n다음 단계로 진행하기 전에 \"Running Base Node without Docker: Part 1\" 글을 참고하여 op-geth와 op-node를 설치해야 합니다.\n\n# 2. `/etc/environment`에 Optimism 노드 환경 변수 추가 및 데이터 디렉토리 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2–1. 당신의 노드에 `/etc/environment` 파일에 다음 템플릿을 추가해주세요.\n\n```js\n##########################\n#### OPTIMISM SETTING ####\n##########################\nOP_GETH_SEQUENCER_HTTP=https://mainnet-sequencer.optimism.io\n# [필수] 선호하는 L1 노드 RPC URL로 변경해주세요:\nOP_NODE_L1_ETH_RPC=[귀하의 L1 ETH RPC]\n# [필수] 선호하는 L1 CL 비컨 엔드포인트로 변경해주세요:\nOP_NODE_L1_BEACON=[귀하의 L1 BEACON RPC]\n# [필수] 공용 IP 주소로 변경해주세요:\nOP_NODE_P2P_ADVERTISE_IP=[귀하의 공용 IP 주소]\nOP_NODE_BETA_EXTRA_NETWORKS=true\nOP_NODE_L2_ENGINE_AUTH=/home/ethereum/data/engine-auth-jwt\nOP_NODE_L2_ENGINE_RPC=ws://localhost:8551\nOP_NODE_LOG_LEVEL=info\nOP_NODE_METRICS_ADDR=0.0.0.0\nOP_NODE_METRICS_ENABLED=true\nOP_NODE_METRICS_PORT=7300\nOP_NODE_NETWORK=op-mainnet\nOP_NODE_P2P_LISTEN_IP=0.0.0.0\nOP_NODE_P2P_LISTEN_TCP_PORT=9001\nOP_NODE_P2P_LISTEN_UDP_PORT=9001\nOP_NODE_P2P_PRIV_PATH=/home/ethereum/data/opnode_p2p_priv.txt\nOP_NODE_P2P_DISCOVERY_PATH=/home/ethereum/data/opnode_discovery_db\nOP_NODE_P2P_PEERSTORE_PATH=/home/ethereum/data/opnode_peerstore_db\nOP_NODE_RPC_ADDR=0.0.0.0\nOP_NODE_RPC_PORT=8547\nOP_NODE_SNAPSHOT_LOG=/home/ethereum/data/op-node-snapshot-log\nOP_NODE_VERIFIER_L1_CONFS=4\nOP_NODE_ROLLUP_LOAD_PROTOCOL_VERSIONS=true\nOP_NODE_SYNCMODE=execution-layer\n# OP_NODE_L1_TRUST_RPC 는 더 빠른 동기화를 지원하지만, 사용 시 반드시 L1 RPC 노드가 완전히 신뢰성 있는 경우에만 사용해야 합니다.\n# 또한 이는 저장 증명을 지원하지 않는 Erigon과 같은 클라이언트와 함께 작동할 수 있도록 합니다:\nOP_NODE_L1_TRUST_RPC=true\nGETH_DATA_DIR=/home/ethereum/data\nVERBOSITY=3\nRPC_PORT=8545\nWS_PORT=8546\nAUTHRPC_PORT=8551\nMETRICS_PORT=6060\nHOST_IP=\"0.0.0.0\"\nP2P_PORT=30304\nOP_GETH_GCMODE=full\nOP_GETH_SYNCMODE=snap\n```\n\n## 2–2. 당신의 네트워크에 대한 값 변경하기\n\n아래 세 가지 변수를 변경해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOP_NODE_L1_ETH_RPC: 귀하의 L1 노드 (이더리움) RPC URL 또는 L1 PRC 노드 공급 업체 URL입니다.\n\n- 예시 (게속 RPC)\n\n```js\nOP_NODE_L1_ETH_RPC=http://192.168.1.2:8545\n```\n\nOP_NODE_L1_BEACON: 귀하의 L1 노드 (이더리움) Beacon RPC URL 또는 L1 Beacon 노드 공급 업체 URL입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 예시 (등대 비콘 rpc)\n\n```js\nOP_NODE_L1_BEACON=http://192.168.1.2:5052\n```\n\nOP_NODE_P2P_ADVERTISE_IP: 공용 IP 주소(개인 IP 주소가 아닙니다!)\n\n- 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nOP_NODE_P2P_ADVERTISE_IP=34.149.58.211\n```\n\n참고:\n공개 IP 주소를 모르는 경우 노드에서 다음 명령을 사용하여 찾을 수 있습니다.\n\n```js\n$ curl http://api.ipify.org\n34.149.58.211\n```\n\n(선택 사항) 다른 P2P 포트를 사용하거나 L1 RPC를 신뢰하지 않는 경우 환경에 맞게 변경해야 합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nP2P_PORT=30304 # op-geth용 P2P 포트\nOP_NODE_P2P_LISTEN_TCP_PORT=9001 # op-node용 TCP P2P 수신 포트\nOP_NODE_P2P_LISTEN_UDP_PORT=9001 # op-node용 UDP P2P 수신 포트\nOP_NODE_L1_TRUST_RPC=true # L1 RPC를 신뢰하는 경우 true로 설정합니다.\n```\n\n위의 변경 사항을 기반으로 예시 /etc/environment 파일은 다음과 같습니다:\n\n```js\nsudo vim /etc/environments\n```\n\n```js\nPATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\"\n\n##########################\n#### OPTIMISM 설정 ####\n##########################\nOP_GETH_SEQUENCER_HTTP=https://mainnet-sequencer.optimism.io\n# [필수] 선호하는 L1 노드 RPC URL로 교체:\nOP_NODE_L1_ETH_RPC=http://192.168.1.2:8545\n# [필수] 선호하는 L1 CL beacon 엔드포인트로 교체:\nOP_NODE_L1_BEACON=http://192.168.1.2:5052\n# 공인 IP 주소로 교체\nOP_NODE_P2P_ADVERTISE_IP=34.149.58.211\nOP_NODE_BETA_EXTRA_NETWORKS=true\nOP_NODE_L2_ENGINE_AUTH=/home/ethereum/data/engine-auth-jwt\nOP_NODE_L2_ENGINE_RPC=ws://localhost:8551\nOP_NODE_LOG_LEVEL=info\nOP_NODE_METRICS_ADDR=0.0.0.0\nOP_NODE_METRICS_ENABLED=true\nOP_NODE_METRICS_PORT=7300\nOP_NODE_NETWORK=op-mainnet\nOP_NODE_P2P_LISTEN_IP=0.0.0.0\nOP_NODE_P2P_LISTEN_TCP_PORT=9001\nOP_NODE_P2P_LISTEN_UDP_PORT=9001\nOP_NODE_P2P_PRIV_PATH=/home/ethereum/data/opnode_p2p_priv.txt\nOP_NODE_P2P_DISCOVERY_PATH=/home/ethereum/data/opnode_discovery_db\nOP_NODE_P2P_PEERSTORE_PATH=/home/ethereum/data/opnode_peerstore_db\nOP_NODE_RPC_ADDR=0.0.0.0\nOP_NODE_RPC_PORT=8547\nOP_NODE_SNAPSHOT_LOG=/home/ethereum/data/op-node-snapshot-log\nOP_NODE_VERIFIER_L1_CONFS=4\nOP_NODE_ROLLUP_LOAD_PROTOCOL_VERSIONS=true\nOP_NODE_SYNCMODE=execution-layer\n\n# OP_NODE_L1_TRUST_RPC를 사용하면 더 빠른 동기화가 가능하지만, L1 RPC 노드를\n# 완전히 신뢰하는 경우에만 사용해야 합니다.\n# 또한 storage proofs를 지원하지 않는 Erigon과 같은 클라이언트와 상호 작용하도록 합니다:\nOP_NODE_L1_TRUST_RPC=true\n\nOP_NODE_SYNCMODE=execution-layer\nGETH_DATA_DIR=/home/ethereum/data\nVERBOSITY=3\nRPC_PORT=8545\nWS_PORT=8546\nAUTHRPC_PORT=8551\nMETRICS_PORT=6060\nHOST_IP=\"0.0.0.0\"\nP2P_PORT=30304\nOP_GETH_GCMODE=full\nOP_GETH_SYNCMODE=snap\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2-3. 블록체인 데이터를 보존하기 위한 data 디렉토리 생성\n\n```js\n$ cd ~\n$ mkdir data\n```\n\n당신의 환경에 기반하여 Optimism 노드 환경 변수를 성공적으로 설정하셨습니다.\n\n# 3. op-node systemd 파일 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n$ sudo touch /etc/systemd/system/op-node.service\n$ sudo vim /etc/systemd/system/op-node.service\n```\n\n다음 내용을 붙여넣고 저장하세요.\n\n```bash\n[Unit]\nDescription=Optimistic Node Client\nAfter=network.target\n\n[Service]\nUser=ethereum\nGroup=ethereum\nEnvironment=HOME=/home/ethereum\nEnvironmentFile=/etc/environment\nType=simple\nExecStart=/usr/bin/op-node\nKillMode=process\nKillSignal=SIGINT\nTimeoutStopSec=90\nRestart=on-failure\nRestartSec=10s\nStandardOutput=syslog\nStandardError=syslog\nSyslogIdentifier=op-node\n\n[Install]\nWantedBy=multi-user.target\n```\n\nop-node systemd 파일을 성공적으로 생성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. op-geth systemd 파일 만들기\n\n```js\n$ sudo touch /etc/systemd/system/op-geth.service\n$ sudo vim /etc/systemd/system/op-geth.service\n```\n\n다음 내용을 붙여 넣고 저장하세요.\n\n```js\n[Unit]\nDescription=옵티미즘 Go-이더리움 클라이언트\nAfter=network.target\n\n[Service]\nUser=ethereum\nGroup=ethereum\nEnvironment=HOME=/home/ethereum\nEnvironmentFile=/etc/environment\nType=simple\nExecStart=/usr/bin/op-geth --datadir=\"${GETH_DATA_DIR}\" \\\n--verbosity=\"${VERBOSITY}\" \\\n--http --http.corsdomain=\"*\" \\\n--http.vhosts=\"*\" \\\n--http.addr=0.0.0.0 \\\n--http.port=\"${RPC_PORT}\" \\\n--http.api=web3,debug,eth,net,engine \\\n--authrpc.addr=0.0.0.0 \\\n--authrpc.port=\"${AUTHRPC_PORT}\" \\\n--authrpc.vhosts=\"*\" \\\n--authrpc.jwtsecret=\"${OP_NODE_L2_ENGINE_AUTH}\" \\\n--ws \\\n--ws.addr=0.0.0.0 \\\n--ws.port=\"${WS_PORT}\" \\\n--ws.origins=\"*\" \\\n--ws.api=debug,eth,net,engine \\\n--metrics \\\n--metrics.addr=0.0.0.0 \\\n--metrics.port=\"${METRICS_PORT}\" \\\n--syncmode=\"${OP_GETH_SYNCMODE}\" \\\n--gcmode=\"${OP_GETH_GCMODE}\" \\\n--maxpeers=100 \\\n--nat=extip:${HOST_IP} \\\n--rollup.sequencerhttp=\"${OP_GETH_SEQUENCER_HTTP}\" \\\n--rollup.halt=major \\\n--op-network=\"${OP_NODE_NETWORK}\" \\\n--port=\"${P2P_PORT}\" \\\n--rollup.disabletxpoolgossip=true \\\n--state.scheme=path\n\nKillMode=process\nKillSignal=SIGINT\nTimeoutStopSec=90\nRestart=on-failure\nRestartSec=10s\nStandardOutput=syslog\nStandardError=syslog\nSyslogIdentifier=op-geth\n\n[Install]\nWantedBy=multi-user.target\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n# 5. 로그 보존을 위한 rsyslog 구성 파일 생성\n\n## 5-1. op-node rsyslog 구성 파일\n\n```js\n$ sudo touch /etc/rsyslog.d/24-op-node.conf\n$ sudo vim /etc/rsyslog.d/24-op-node.conf\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 설정을 붙여넣고 저장하세요.\n\n```js\nif $programname == 'op-node' then /var/log/op-node.log\nif $programname == 'op-node' then ~\n```\n\n## 5-2. op-geth rsyslog 구성 파일\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ sudo touch /etc/rsyslog.d/25-op-geth.conf\n$ sudo vim /etc/rsyslog.d/25-op-geth.conf\n\n\n참고:\n선호하는 파일 이름으로 변경해주세요.\n\n다음 설정을 붙여넣고 저장하세요.\n\n\nif $programname == 'op-geth' then /var/log/op-geth.log\nif $programname == 'op-geth' then ~\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5-3. rsyslog 데몬 재시작\n\n```js\n$ sudo systemctl restart rsyslog\n```\n\n## 6. 로그 회전 구성 파일 생성\n\n로그를 회전하지 않으면 많은 디스크 공간을 사용하므로 로그 회전을 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```shell\n$ sudo touch /etc/logrotate.d/op-client\n$ sudo vim /etc/logrotate.d/op-client\n```\n\n노트:\n원하시는 이름으로 파일 이름을 변경하세요.\n\n다음 설정을 붙여넣고 저장하세요.\n\n```shell\n/var/log/op-node.log\n/var/log/op-geth.log\n{\n        rotate 4\n        weekly\n        missingok\n        notifempty\n        compress\n        delaycompress\n        sharedscripts\n        postrotate\n                [ -x /usr/lib/rsyslog/rsyslog-rotate ] \u0026\u0026 /usr/lib/rsyslog/rsyslog-rotate || true\n        endscript\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 옵티미즘 노드 실행하기\n\n축하합니다! 드디어 옵티미즘 노드를 실행할 시간이 왔습니다.\n\n## 7-1. op-node 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ sudo systemctl enable op-node\n$ sudo systemctl start op-node\n$ sudo systemctl status -l op-node\n● op-node.service - Optimistic Node Client\n     Loaded: loaded (/etc/systemd/system/op-node.service; disabled; vendor preset: enabled)\n     Active: active (running) since Wed 2024-05-08 20:32:32 JST; 16h ago\n   Main PID: 259669 (op-node)\n      Tasks: 16 (limit: 18542)\n     Memory: 786.9M\n     CGroup: /system.slice/op-node.service\n             └─259669 /usr/bin/op-node\n```\n\n## 7–2. op-geth 실행하기\n\n```js\n$ sudo systemctl enable op-geth\n$ sudo systemctl start op-geth\n$ sudo systemctl status -l op-geth\n● op-geth.service - Optimism Go-ethereum client\n     Loaded: loaded (/etc/systemd/system/op-geth.service; disabled; vendor preset: enabled)\n     Active: active (running) since Wed 2024-05-08 20:36:22 JST; 16h ago\n   Main PID: 259742 (op-geth)\n      Tasks: 37 (limit: 18542)\n     Memory: 13.8G\n     CGroup: /system.slice/op-geth.service\n             └─259742 /usr/bin/op-geth --datadir=/home/ethereum/data --verbosity=3 --http --http.corsdomain=* --http.vhosts=* --http\u003e\n```\n\n## 7–3. 로그 확인하기\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 로그를 확인할 수 있어요:\n\n```js\n$ sudo tail -f /var/log/op-geth.log\n$ sudo tail -f /var/log/op-node.log\n```\n\n성공적으로 실행하면, op-node와 op-geth에서 다음과 같은 로그가 기록될 거예요:\n\n- Left (op-node), Right (op-geth)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image 1](/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_1.png)\n\nRoughly within 20 hours, op-geth will complete syncing with snap mode, as shown in the following image.\n\n![image 2](/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_2.png)\n\n- Synced Example\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*YTH6tEbhxERWqcUMkOsJxw.gif\" /\u003e\n## 7-4. 동기화 여부 확인\n\n다음 명령어를 사용하여 공개 Optimism 노드 블록 번호와 귀하의 Optimism 노드 블록 번호를 비교할 수 있습니다.\n\n- 공개 Optimism 노드에서 최신 블록 번호 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n$ curl -sX POST -H \"Content-Type: application/json\" \\\n-d '{\"jsonrpc\": \"2.0\", \"method\": \"eth_blockNumber\", \"params\": [], \"id\":1}' \\\nhttps://mainnet.optimism.io/ \\\n| jq -r \".result\" | printf \"%d\\n\" $(cat -)\n```\n\n- 로컬 노드에서 최신 블록 번호 가져오기\n\n```js\n$ curl -sX POST -H \"Content-Type: application/json\" \\\n-d '{\"jsonrpc\": \"2.0\", \"method\": \"eth_blockNumber\", \"params\": [], \"id\":1}' \\\nhttp://localhost:8545/ \\\n| jq -r \".result\" | printf \"%d\\n\" $(cat -)\n```\n\n- 출력 예시\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_3.png\" /\u003e\n\n# 첨부 1: 데이터 축소 시나리오\n\n만약 노드가 제대로 중지되지 않거나 갑작스럽게 정전이 발생하면 데이터가 손상될 수 있습니다. 데이터 디렉토리를 삭제하여 깨끗한 상태로 다시 시작할 수 있습니다.\n\n```js\n$ sudo systemctl stop op-node\n$ sudo systemctl stop op-geth\n$ cd ~\n$ rm -Rf ./data\n$ mkdir ./data\n$ sudo systemctl start op-node\n$ sudo systemctl start op-geth\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 부록 2: 사용자 정의\n\nOptimism 환경 변수를 기반으로 사용자 정의를 원하시는 경우, Optimism 노드 구성 참조를 참고하십시오.\n\n# 부록 3: CPU, 메모리 및 디스크 사용률\n\n## A3–1. CPU 사용량\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRock 5B에서 작동하는 Rockchip RK3588은 비용 효율적이고 겸손한 8코어 CPU입니다. 스냅 동기화 모드를 사용하는 Optimism 노드는 최대 사용량이 800%인 RK3588의 용량을 200%에서 300% 소비합니다.\n\n참고:\n이 글을 쓴 기본 노드보다 CPU를 더 많이 사용합니다.\n\n```js\n$ top -p $(pgrep op-geth)  -p $(pgrep op-node)\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## A3-2. 메모리 사용량\n\n```js\n$ free -h\n              total        used        free      shared  buff/cache   available\nMem:           15Gi       7.2Gi       498Mi       8.0Mi       7.7Gi       8.0Gi\nSwap:            0B          0B          0B\n```\n\n## A3-3. 디스크 사용량\n\n지금은 2024년 5월 16일이며, --state.scheme=path 옵션을 사용한 스냅 동기화 모드는 지금까지 404 GB만 소비되었습니다. 따라서 1 TB 미만의 SSD로도 노드를 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ du -sh ~/data\n404G    /home/ethereum/data\n\n\n# 소감\n\n옵티미즘 노드를 Docker 없이 구축해주신 여정에 대해 감사드립니다. 옵티미즘 노드 설치는 많은 단계가 필요하지만, 도커 환경보다는 더 많은 사용자 정의가 제공됩니다. 동일한 L1 노드나 다른 L2, L3 솔루션에서 실행하더라도 각 포트 설정을 유연하게 변경할 수 있습니다. 이 설정들에 대한 오류를 발견하거나 개선 제안이 있으시면 소중한 피드백 주시기를 부탁드리며, 더 나은 분산화를 위해 개선사항을 지속적으로 반영할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_0.png"},"coverImage":"/assets/img/2024-05-17-RunningOptimismNodewithoutDocker_0.png","tag":["Tech"],"readingTime":13},{"title":"SwiftUI를 고민해보다","description":"","date":"2024-05-17 03:53","slug":"2024-05-17-SwiftUIThinking","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_0.png\" /\u003e\n\nSwiftUI가 우리의 백로그에 올라온 지 어느 정도 되었네요. iOS 개발자로서, 우리는 SwiftUI를 기다리며 올바른 시기에 빠져들기를 기다리고 있었어요.\n\n여기에 SwiftUI에 대한 간략한 소개가 있습니다!\n\nSwiftUI의 시작점을 찾고 있다면, 여기서 시작하시면 됩니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적인 뷰 구성 요소와 속성들\n\nSwiftUI에는 UIKit과 유사하게 사용되는 몇 가지 인기 있는 UI 구성 요소가 있습니다.\n\n## Text\n\nText는 UILabel과 동일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nText(\"Hello World!\")\n    .font(.title.bold())\n    .foregroundStyle(.blue)\n```\n\n![SwiftUI Thinking](/assets/img/2024-05-17-SwiftUIThinking_1.png)\n\n## 버튼\n\n예상했던대로, Button은 UIButton에 해당합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nButton {\n    print(\"Button Action\")\n} label: {\n    Text(\"Hello World!\")\n        .font(.title.bold())\n        .foregroundStyle(.white)\n        .padding()\n        .background(.blue)\n        .clipShape(RoundedRectangle(cornerRadius: 16))\n}\n```\n\n![Image](/assets/img/2024-05-17-SwiftUIThinking_2.png)\n\n## 이미지\n\nImage는 UIImageView와 같다고 생각하면 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![시스템 이름을 사용한 이미지](Image(systemName: \"house.fill\")\n    .resizable()\n    .scaledToFit()\n    .foregroundStyle(.blue)\n)\n\n![SwiftUI를 학습하는 이미지](/assets/img/2024-05-17-SwiftUIThinking_3.png)\n\n## TextField\n\nTextField은 UITextField와 동일합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nTextField(\"placeholder\", text: .constant(\"\"))\n    .textFieldStyle(.roundedBorder)\n\n\n![SwiftUIThinking_4](/assets/img/2024-05-17-SwiftUIThinking_4.png)\n\n# HStack \u0026 VStack\n\n앱의 UI를 구조화할 때는 뷰를 서로 정렬하는 것이 중요합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwiftUI에서는 이를 위한 두 가지 주요 레이아웃 빌더가 있습니다: HStack과 VStack.\n\n이러한 레이아웃 빌더를 사용하면 각각 뷰를 수평 및 수직으로 정렬할 수 있습니다.\n\n보다 복잡한 레이아웃을 구현하기 위해 이들을 결합할 수도 있습니다.\n\n## HStack\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`HStack`은 뷰를 수평으로 정렬합니다.\n\n```js\nHStack {\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Text(\"Trailing Text\")\n        .fonts(.caption.bold())\n        .foregroundStyle(.orange)\n}\n```\n\n![SwiftUIThinking_5](/assets/img/2024-05-17-SwiftUIThinking_5.png)\n\n## VStack\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뷰를 수직으로 정렬합니다.\n\n```js\nVStack {\n    Text(\"상단 텍스트\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Text(\"하단 텍스트\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_6.png\" /\u003e\n\n# 뷰 간의 관계: Spacer로 유연한 UI\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpacer는 SwiftUI의 가벼우면서 강력한 구성 요소로 유연한 UI를 구축하는 데 사용됩니다.\n\n원하는 뷰를 다른 뷰에 일정한 여백(leading, top, trailing, bottom)을 사용하여 정렬하는 것은 지루할 수 있습니다.\n\n```swift\nHStack {\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Spacer()\n\n    Text(\"Trailing Text\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n}\n``` \n\n![SwiftUIThinking_7](/assets/img/2024-05-17-SwiftUIThinking_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpacer가 HStack 안의 두 개의 Text 사이에 배치되면, 디자인된대로 Text를 가장자리쪽으로 밀어냅니다.\n\n```js\nHStack {\n    Spacer()\n\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Spacer()\n\n    Text(\"Trailing Text\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n\n    Spacer()\n    Spacer()\n}\n```\n\nLeading Text 앞에 Spacer를 하나 추가하고, Trailing Text 뒤에 Spacer를 두 개 더 추가했어요.\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스페이서를 추가할 때, 선두 텍스트는 선도를 기준으로 한 스페이서 만큼 멀어지고, 추적 텍스트는 후도를 기준으로 두 스페이서 만큼 멀어집니다.\n\n그 결과로, 추적 텍스트는 선두 텍스트에 비해 기기 가장자리로부터 더 멀리 떨어지게 됩니다.\n\n# 데이터 목록 다루기\n\n데이터 목록에 대해, SwiftUI에는 List 또는 Foreach라는 두 가지 옵션이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 목록\n\n목록은 UIKit의 UITableView와 같습니다.\n\n```swift\nvar numbers = [1, 2, 3, 4, 5]\n\nList(numbers, id: \\.self) { number in\n    Text(\"\\(number)\")\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_9.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요!\n\nMarkdown 형식으로 표를 변환하려면 다음과 같이 해보세요.\n\nList에는 구분선, 카드 모양 등과 같은 준비된 UI가 포함되어 있습니다. 쉽죠!\n\n## Foreach\n\n```js\nvar numbers = [1, 2, 3, 4, 5]\n\nVStack {\n    ForEach(numbers, id: \\.self) { number in\n        Text(\"\\(number)\")\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-17-SwiftUIThinking_10.png)\n\nThe Foreach construct offers a leaner alternative to the List component. With Foreach, you have full control over building your list UI, resulting in a simpler and more customizable approach.\n\n## Updating UI with Observable Property\n\nSwiftUI differs from UIKit by embracing the Declarative Programming approach.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선언적 프로그래밍에서 UI는 Observable 값이나 속성의 변경을 관찰합니다.\n\n값이 변경될 때마다 UI는 동적으로 변경 사항을 반영합니다.\n\nSwiftUI의 기본 속성 래퍼(State 및 Binding)는 관찰 가능성을 활성화합니다:\n\nState: 단방향 연결을 용이하게 해 주며 주로 연결된 뷰 내에서 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바인딩: 양방향 연결을 수립하고 상태 속성을 다른 뷰로 전송하는 데 사용됩니다.\n\n## 지금은 상태에 집중해 보겠습니다\n\n```js\n@State var text: String = \"초기 텍스트\"\n\nVStack(spacing: 32) {\n    Button {\n        text = \"수정된 변경\"\n    } label: {\n        Text(\"텍스트 변경\")\n            .font(.title.bold())\n            .foregroundStyle(.white)\n            .padding()\n            .background(.blue)\n            .clipShape(RoundedRectangle(cornerRadius: 16))\n    }\n\n    Text(text)\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:590/1*UAzw-1G__azlbNUSfevu9Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경 텍스트 버튼 액션은 observable text 속성을 수정합니다. UI는 텍스트 속성의 변경 사항을 듣도록 설계되어 있으므로 자동으로 업데이트됩니다. 이 기능은 State 프로퍼티 래퍼로 가능해졌습니다.\n\n# 뷰\n\n모든 SwiftUI 뷰는 View 프로토콜을 준수하는 구조체입니다.\n\n구조체는 클래스 상속을 허용하지 않으므로 SwiftUI 뷰는 프로토콜에만 준수할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 특성들은 SwiftUI에서 뷰를 독립적이고 고유하게 보는 방식을 채택해야 함을 필요로 합니다.\n\nUIKit에서는 UIViewController 및 UITableViewController와 같은 특정 뷰를 위한 기본 클래스를 생성하는 것이 일반적입니다. 이 습관에서 벗어나는 것은 어려울 수 있지만, 마음가짐을 바꿈으로써 가능합니다!\n\n# 유용한 구성 요소\n\nSwiftUI의 핵심 원칙 중 하나는 작성 코드를 줄이고 더 많은 작업을 하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뒤에 표식을 확인 해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-17-SwiftUIThinking_11.png)\n  \n## Picker\n\nIt is a combination of UISegmentedControl and UIPickerView.\n\nIt provides various styles such as wheel, inline, segmented, and palette.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nlet numbers = [1, 2, 3, 4, 5]\n@State var selection: Int = 0\n\nPicker(\"Select\", selection: $selection) {\n    ForEach(numbers, id: \\.self) { number in\n        Text(\"\\(number)\")\n    }\n}\n.pickerStyle(.inline)\n``` \n\n![Image Scale](https://miro.medium.com/v2/resize:fit:590/1*fy8_zvsJAsM7_4dQB4QgdA.gif)\n\n# 이미지 크기 조절\n\nSwiftUI가 처음 나온 이후, Apple은 이미지 라이브러리인 SF Symbols를 제공해 왔습니다. Image 뷰를 사용하여 이 라이브러리의 이미지에 쉽게 액세스할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, Text 뷰의 글꼴 설정과 유사하게 이미지 크기를 조절할 수 있는 font 기능을 사용해 이미지의 크기를 조절할 수 있습니다.\n\n```js\nImage(systemName: \"house.fill\")\n    .font(.largeTitle)\n```\n\nSwiftUI는 Apple 환경에서 프로젝트를 개발하는 새로운 방법입니다.\n\nSwiftUI의 방식에 대해 생각을 조정하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한번 그것을 할 수 있다면, SwiftUI의 문들이 완전히 열릴 것입니다!","ogImage":{"url":"/assets/img/2024-05-17-SwiftUIThinking_0.png"},"coverImage":"/assets/img/2024-05-17-SwiftUIThinking_0.png","tag":["Tech"],"readingTime":7},{"title":"구글 IO 2024 AI 혁신과 안드로이드 향상","description":"","date":"2024-05-17 03:52","slug":"2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements","content":"\n\nGoogle I/O는 매년 5월 14일에 개최되는 개발자 회의로, 구글이 인공 지능(AI)의 경계를 넓히고 다양한 제품에 통합하는 데 헌신하는 모습을 선보였습니다. 특히 안드로이드에 초점을 맞춘 일련의 혁신적인 발표를 통해 사용자 경험을 재정의하고 개발자들에게 향상된 도구를 제공할 것을 약속했습니다.\n\n![Google I/O 2024](/assets/img/2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements_0.png)\n\n안드로이드: 인공 지능의 힘을 수용\n\n구글이 안드로이드를 위해 그림자 나노(Gemini Nano)라 부르는 온디바이스 기반 모델을 중심으로 한 비전은, 사용자의 개인 정보 보호와 성능을 우선시하면서 AI 능력을 혁신하려는 것입니다. 이 혁신적인 기술은 안드로이드 기기가 로컬에서 AI 모델을 활용할 수 있게 하여 지속적인 클라우드 연결이 필요 없도록 하며, 원활한 경험을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젠미나노와 멀티모달리티의 통합은 픽셀 폰의 기능을 향상시켜 텍스트 뿐만 아니라 이미지, 소리, 말로 된 언어까지 이해할 수 있도록 만듭니다. 이 멀티모달 이해력은 향상된 음성 어시스턴트부터 향상된 접근성 기능까지 다양한 가능성을 열어줍니다.\n\n개발자를 먹여 살리다: 안드로이드 스튜디오 이상\n\n안드로이드 생태계를 형성하는 데 개발자들이 하는 중요한 역할을 인식하여, Google은 안드로이드 앱 개발을 위한 주요 통합 개발 환경(IDE)인 안드로이드 스튜디오에 여러 가지 기능을 개선했습니다. 주목할 만한 업데이트로는 안드로이드 디바이스 스트리밍이 있습니다. 이 기능을 통해 개발자들은 다양한 디바이스에서 앱을 원격으로 테스트하여 테스트 프로세스를 간소화하고 다양한 안드로이드 환경에서의 호환성을 보장할 수 있습니다.\n\n게다가 앱 관리를 위한 중앙 허브인 Google Play 콘솔은 향상된 앱 릴리스 도구로 크게 강화되었습니다. 사전 검토 체크 및 간소화된 릴리스 관리 프로세스를 통해 앱 게시 워크플로우를 간소화하고 개발자들이 더 효과적으로 자신의 작품을 사용자에게 제공할 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! \n\n안드로이드 이상: 구글 맵 및 더 많은 소식\n\n안드로이드가 중심무대를 선보이는 동안, 구글 I/O 2024는 다른 제품들에 대한 업데이트도 선보였습니다. 구글 맵은 널리 사용되는 네비게이션 도구로서, 전기 자동차(EV) 충전소에 대한 필터와 개선된 도로 시각화 등 여러 가지 기능이 추가되었습니다. 이러한 업데이트는 지속 가능한 교통에 대한 성장하는 수요를 충족시키고 운전자 및 통근자들을 위한 전반적인 사용자 경험을 향상시킵니다.\n\n전진의 길: AI가 형성하는 미래\n\n구글 I/O 2024는 구글의 AI 혁신에 대한 끝없는 약속과 일상 제품으로의 통합을 보여주는 자리였습니다. Gemini Nano가 주도하는 안드로이드는 더욱 지능적이고 맞춤화된 플랫폼이 되며, 개발자들은 혁신적인 애플리케이션을 만들도록 촉진하는 향상된 도구를 활용할 수 있습니다. 구글이 AI의 경계를 더욱 넓히는 동안, 미래는 사용자와 개발자들 양쪽에 황홀한 가능성을 제공할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 깊이 있는 정보와 그 영향을 알고 싶다면, 다음 자료들을 살펴보세요:\n\n- Google I/O 2024 웹사이트: [https://io.google/](https://io.google/)\n- Android 개발자 블로그: [https://android-developers.googleblog.com/](https://android-developers.googleblog.com/)\n- Android에서의 Google AI에 관한 블로그 포스트: [https://blog.google/products/android/google-ai-android-update-io-2024/](https://blog.google/products/android/google-ai-android-update-io-2024/)","ogImage":{"url":"/assets/img/2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements_0.png"},"coverImage":"/assets/img/2024-05-17-GoogleIO2024AIInnovationsandAndroidEnhancements_0.png","tag":["Tech"],"readingTime":3},{"title":"인프라스트럭처의 코드화","description":"","date":"2024-05-17 03:50","slug":"2024-05-17-InfrastructureasCode","content":"\n\n\n![Infrastructure as Code 0](/assets/img/2024-05-17-InfrastructureasCode_0.png)\n\n![Infrastructure as Code 1](/assets/img/2024-05-17-InfrastructureasCode_1.png)\n\n# Infrastructure as Code (IaC)이란\n\nInfrastructure as Code 또는 IaC는 코드와 스크립트를 사용하여 인프라를 자동으로 프로비저닝하고 구성하는 것을 말합니다. IaC를 사용하면 환경을 생성하여 인프라 구성 요소를 자동화할 수 있으므로 필요한 시스템 및 장치를 수동으로 설정하는 대신 시스템과 장치를 설정할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IaC 사용의 장점\n\n비즈니스가 성장함에 따라 인프라 및 구성은 점점 복잡해지고 있습니다. 매우 상세한 문서를 유지하고 수동으로 구현하는 것은 언제나 확약할 수 없습니다. 우리는 인간이기 때문에 항상 100%의 오류를 보장할 수 없습니다. 똑같이 감사, 업데이트 구현 등은 인력과 시간이 필요하며, 요구되는 빈도 및 해당 사람이 IT 배경이 필요한지 여부에 따라 인력 및 기간이 달라집니다. 업데이트를 진행할 새 시스템 또는 여러 DR 환경을 유지하기 위해 회사들은 많은 비용을 지출합니다.\n\n인프라스트럭처( IaC )는 이러한 개념을 기반으로 개발되었습니다. 이는 회사가 위 언급된 도전에 대처할 수 있도록 돕습니다. 애플리케이션처럼, 인프라는 코드로 작성되며, IaC 코드는 리소스를 여러 번 구축하고 감사, 개선 등을 지속적으로 수행할 수 있도록 도와줍니다.\n\nIaC는 인프라스트럭처의 프로비저닝을 더 쉽고 빠르며 확장 가능하게 만들어줌으로써 중요합니다. IaC는 조직에 다양한 이점을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 투명성 및 보안\n\n- 인프라 및 인프라 관련 구성 요소 구성의 진실의 원천 및 IaC 코드 자체가 문서로 작용합니다.\n- 모든 수동 또는 무단 변경 사항과 감사를 추적할 수 있습니다.\n- 안전하게 관리되는 인프라 비밀 및 구현 준수/표준.\n\n## 안정성 및 생산성\n\n- 일관된 구성: IaC는 일관된 설정을 강제하므로 불안정성 위험을 줄입니다.\n- 오류 최소화: IaC의 자동화를 통해 인간 오류를 줄이고 인프라 안정성을 향상시킵니다.\n- 신속한 복구: IaC를 사용하여 재해 후 빠른 시스템 복구가 가능하며 안정성을 유지할 수 있습니다.\n- 버전 제어 롤백: IaC의 버전 제어를 통해 문제 발생 시 안정적인 상태로 빠르게 롤백할 수 있습니다.\n- 동시 배포: IaC를 사용하여 동시 환경 프로비저닝을 할 수 있어 안정성이 향상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비즈니스 가치\n\n- IT 시스템에서 '주요 인물 리스크' 감소\n- IT 종속성 감소\n- 더 빠르고 유연한 성과 달성\n- 비용 절감 및 예산 편성\n- 보안 및 준수 강화\n- 향상된 협업과 팀워크\n- 지속적인 개선 및 피드백 루프\n- 미래를 대비하고 확장성 확보\n\n# IaC의 원칙\n\n- 모든 인프라 구성 요소의 구축/재구축은 쉽고 효율적이어야 합니다. 쉽다는 것은 구성 요소를 재구축하는 방법에 대한 중요한 결정을 내릴 필요가 없다는 것을 의미합니다. 구성 요소를 선택하는 것부터 매개 변수를 구성하고 구성 요소 수를 결정하는 등의 결정은 스크립트를 통해 자동화될 것입니다. 이러한 스크립트는 필요한 입력을 동적으로 획득하며 그 안에 정적이거나 하드코딩된 값이 없습니다.\n- 항등성은 IaC를 실행하는 횟수나 시작 상태에 관계 없이 최종 상태가 동일하게 됩니다. 이는 인프라 프로비저닝을 단순화하고 일관되지 않은 결과의 가능성을 줄입니다.\n- 동적 입력을 고려하여 동일한 리소스에 대한 재사용성을 보장하며 인프라가 계속 변화할 것임을 주의하세요. 서버가 사라지고 나타나고 크기가 조정되더라도 애플리케이션이 계속 실행될 수 있습니다.\n- 일회성으로 구현합니다. 솔루션이 계층의 일부인 경우 최상위 층이 제거될 때 쉽게 파괴될 수 있어야 합니다.\n- 모든 변경 이력을 추적하고 코드와 실행 중인 인프라의 차이를 비교할 수 있는 방법을 마련하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IaC 원칙에 따른 코딩 표준.\n\n## - IaC 모듈 표준\n\n- 코드는 변경 추적 및 무단 액세스 또는 수정을 방지하기 위해 버전 관리되어야 합니다.\n- 각 클라우드 제공업체에 대해 별도의 프로젝트를 유지합니다.\n- 각 모듈에 대한 별도의 저장소를 유지합니다.\n- 리소스 그룹, 가상 머신, 서브넷, VPC, 보안 그룹, SQL 데이터베이스 및 스토리지와 같은 클라우드 개체를 위해 별도의 모듈을 개발합니다.\n- 모듈 저장소는 공통 네이밍 표준을 준수해야 합니다.\n- 모듈은 최대 재사용성을 활용하도록 개발되어야 합니다.\n\n- 가능한 경우 함수형(true | false) 또는 컬렉션 유형 (리스트, 맵)을 사용하세요.\n- 시퀀스 블록을 참조하는 count 변수를 사용하세요. 대안으로 다중/대량 실행을 위한 옵션을 열어 두세요.\n- 동적 리소스 이름을 사용하세요. 이는 리소스 이름이 접미사와 입력을 — 또는 _로 구분하여 생성됨을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: 리소스 그룹에 대한 템플릿\n\n```js\n{surfix}-{business_unit}-{application_type}-{subscription}-{env}-{region}-{sequence}\nrg-mark-k8-001-dev-eas-01\n```\n\n- 임시 버그 수정이 아닌 한 모듈은 여러 목적으로 개발되어야 합니다.\n- 모듈 버전 관리는 자동화된 프로세스를 따르고 의미 있는 버전 형식을 사용해야 합니다.\n- 고정된 파일 구조를 따르거나 도구별 표준 파일과 폴더를 사용해야 합니다.\n- 모듈은 CHANGELOG.md와 readme.md를 가져야 하며 명확한 지침과 자동으로 파이프라인을 통해 업데이트할 수 있는 방법이 있어야 합니다.\n- 코딩 내에서 정적이거나 하드 코딩된 값은 명확한 설명이나 승인이 없는 경우 사용하면 안 됩니다.\n- 변수 유형은 모듈 내에서 변수가 결정될 때 선언되어야 합니다.\n- 모듈은 배열이나 변수를 통해 다른 모듈로 값을 전달하고 출력을 생성할 수 있어야 합니다.\n\n# - IaC 솔루션 표준 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드는 변경을 추적하고 무단 액세스나 수정을 방지하기 위해 버전 제어되어야 합니다.\n- 각 클라우드 제공업체마다 별도의 프로젝트를 유지하세요.\n- 클라우드별 프로젝트 하위에 각 솔루션을 위한 별도의 저장소를 유지하세요.\n- 솔루션은 여러 개체의 조합 또는 단일 개체일 수 있습니다.\n\n예시:\n\n- 단일 데이터베이스를 배포하는 것은 솔루션입니다 (단일 개체)\n- K8를 배포하는 것은 솔루션입니다 (클러스터, 네트워킹, 스토리지 등과 같은 여러 항목)\n\n- 해결책 그룹 표를 따라 어떤 항목을 포함하고 공유하고 피해야 하는지 정의하세요.\n- 솔루션 저장소는 공통 네이밍 표준을 따라야 합니다.\n- 고정된 파일 구조나 특정 도구 표준 파일 및 폴더를 준수해야 합니다.\n- 솔루션은 재사용성을 활용할 수 있는 방식으로 개발되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동일한 배포의 예로는 여러 지역에 같은 구성 요소나 클러스터, 다른 이름을 가진 동일한 지역, 또는 다른 입력 세트를 가진 여러 배포 등이 있습니다.\n\n- 코딩 내부에 정적 또는 하드 코딩 값이 없습니다.\n- ENV 변수, 인수 및 파일 기반 입력과 같은 다양한 방식의 입력 프로세스 기능을 사용합니다. 비밀/자격 증명의 경우 항상 ENV 변수를 사용하며 보호는 로그 또는 다른 방법에 의해 공개됩니다.\n- 도구/코딩 관점에서 버전 번호는 고정되어야 하며 솔루션별입니다.\n- 전역 변수를 제외하고, 상태 관리, 변수 또는 변수 그룹, 입력 등과 같은 솔루션 관련 사항은 솔루션 저장소에 한정됩니다.\n\n솔루션 그룹 표\n\n![Solution Group Table](/assets/img/2024-05-17-InfrastructureasCode_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인프라스트럭처의 코드화 (IaC) 구현\n\n프로세스를 두 개의 독립적인 부분으로 나누는 것은 매우 효과적입니다. 이 방법을 통해 의존성을 피하고 코드 재사용성을 높이며 프로그래밍 구조를 정리하고 릴리스 관리를 간소화할 수 있습니다.\n\n두 독립적인 부분은 다음과 같습니다:\n\n1. 모듈 개발: 이 부분은 원하는 인프라를 만들기 위해 결합할 수 있는 개별 모듈을 개발하는 데 중점을 둡니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. IaC 프로젝트 코딩 및 구현: 이 파트에서 팀은 첫 번째 파트에서 개발된 모듈을 사용하여 IaC 프로젝트를 코딩하고 구현하는 데 초점을 맞춥니다.\n\n프로세스를 두 부분으로 나눔으로써 팀은 IaC의 원활하고 성공적인 구현을 달성할 수 있습니다. 이는 구현 프로세스의 서로 다른 부분 사이에 발생할 수 있는 충돌과 의존성을 방지하여 지연 및 기타 복잡성을 방지하는 데 도움이 됩니다.\n\n게다가, 산업 표준 최상의 관행 및 보안 프로토콜의 준수를 강제하기 위해 다양한 도구 및 프로세스를 구현하는 것이 중요합니다.\n\n![InfrastructureasCode_3](/assets/img/2024-05-17-InfrastructureasCode_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Infrastructure as Code Image](/assets/img/2024-05-17-InfrastructureasCode_4.png)\n\nCode Sample: [tf-sample-project-demo/main.tf](https://github.com/kernelv5/tf-sample-project-demo/blob/master/main.tf)\n\nProject: [tf-sample-project-demo](https://github.com/kernelv5/tf-sample-project-demo)\n\n![Infrastructure as Code Image](/assets/img/2024-05-17-InfrastructureasCode_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시 코드: https://github.com/kernelv5/tf-sample-project-demo 이 링크에서 두 모듈을 사용하여 리소스 그룹을 생성하고 스토리지 계정을 배포하세요.\n\n모듈 링크: https://github.com/kernelv5?submit=Search\u0026q=+az-tf-\u0026tab=stars\u0026type=\u0026sort=\u0026direction=\u0026submit=Search\n\n![이미지](/assets/img/2024-05-17-InfrastructureasCode_6.png)\n\n파일 구조: https://github.com/kernelv5/az-tf-storageaccount\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-17-InfrastructureasCode_7.png)\n\n# Auto-Generated Readme.md\n\n[Link to GitHub Repository with Terraform Documentation](https://github.com/kernelv5/tf-sample-project-demo)\n\n![image](/assets/img/2024-05-17-InfrastructureasCode_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Auto Version \u0026 Release\n\n[Semantic Release](https://github.com/semantic-release/semantic-release) \n[Commit Convention](https://www.conventionalcommits.org/en/v1.0.0/) \n[Example GitHub Action Workflow](https://github.com/kernelv5/tf-module-model-pipeline/blob/master/.github/workflows/main.yaml)\n\n[azure-tf-storage-account v1.1.0 release](https://github.com/kernelv5/az-tf-storage-account/releases/tag/v1.1.0) \n[azure-tf-resource-group v1.1.0 release](https://github.com/kernelv5/az-tf-resource-group/releases/tag/v1.1.0)\n\n![Image](/assets/img/2024-05-17-InfrastructureasCode_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Infrastructure as Code](/assets/img/2024-05-17-InfrastructureasCode_10.png)","ogImage":{"url":"/assets/img/2024-05-17-InfrastructureasCode_0.png"},"coverImage":"/assets/img/2024-05-17-InfrastructureasCode_0.png","tag":["Tech"],"readingTime":7},{"title":"백스테이지 Kubernetes 플러그인 사용자 정의하기","description":"","date":"2024-05-17 03:48","slug":"2024-05-17-CustomizingtheBackstageKubernetesPlugin","content":"\n\n백스테이지의 새로운 백엔드 시스템에서 쿠버네티스 플러그인을 사용자 정의하는 방법 소개\n\n![이미지](/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_0.png)\n\n# 소개\n\n스포티파이에서 개발한 백스테이지는 다양한 도구와 인터페이스를 통합하여 응용 프로그램 관리를 간편화하는 통합 플랫폼입니다. 이 글에서는 백스테이지의 아키텍처와 쿠버네티스 플러그인을 살펴보며 사용자 정의 옵션이 작업 흐름을 최적화하고 쿠버네티스 리소스의 중앙 집중화된 보기를 제공하는 방법을 소개합니다. 실용적인 예제를 통해 독자들은 백스테이지가 어떻게 응용 프로그램 관리를 혁신할 수 있는지 발견할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Backstage란 무엇인가요?\n\n많은 사람들이 자신의 애플리케이션에 대한 포괄적인 정보를 제공하는 도구가 필요합니다. 예를 들어, 각각의 애플리케이션은 CI/CD 파이프라인, Kubernetes 클러스터, 그리고 기타 여러 가지 문서를 가지고 있습니다. CI/CD 파이프라인을 관리하려면 Jenkins, GitLab 또는 기타 도구를 사용할 수 있습니다. Kubernetes 클러스터에 접속하여 애플리케이션 상태를 확인하려면 kubectl이나 Kubernetes 대시보드, 또는 기타 유사한 도구가 필요할 것입니다. 그리고 문서를 확인하기 위해서는 처리된 .md 파일에 접근하거나 Confluence를 방문하여 애플리케이션 문서를 볼 수 있을 것입니다. 그러나 만약 이 모든 정보를 한 곳에서 볼 수 있다면 어떨까요? Backstage는 여러 측면에서 당신의 애플리케이션에 대한 포괄적인 정보를 만들 수 있게 도와주는 도구입니다.\n\n# Backstage 아키텍처\n\nBackstage는 세 가지 구성 요소로 간단한 아키텍처를 가지고 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 백스테이지 프론트엔드\n- 백스테이지 백엔드\n- 데이터베이스\n\n![이미지](/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_1.png)\n\n# 백스테이지의 Kubernetes 플러그인\n\n백스테이지에는 응용 프로그램의 포괄적인 뷰를 만드는 데 사용할 수 있는 많은 플러그인이 있습니다. 몇 가지 플러그인은 프론트엔드 및 백엔드에 추가해야 합니다. Kubernetes 플러그인과 같은 경우입니다. Kubernetes 플러그인의 설치에 대한 공식 문서는 매우 상세하며 다음 링크에서 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Kubernetes 플러그인 사용자 정의\n\nKubernetes 플러그인에는 여러 모듈이 있고, 각각을 사용자 정의할 수 있습니다. Kubernetes 플러그인의 다음 동작 중 일부를 사용자 정의할 수 있습니다:\n\n- 클러스터 제공자: 이 모듈은 클러스터를 캐싱하고 주기적으로 새로 고칩니다. credentials를 인수로 전달하는 getClusters(credentials) 함수가 있으며 클러스터 목록이 필요할 때 호출됩니다.\n- 사용자 정의 리소스: 이 모듈은 Kubernetes 클러스터에서 사용자 정의 리소스 목록을 검색합니다.\n- 객체 제공자: 이 인터페이스는 엔티티와 관련된 Kubernetes 객체 및 사용자 정의 리소스를 검색하기 위한 메서드를 정의합니다. pods, services, configmaps와 같은 일반 Kubernetes 객체의 기본 목록이 있습니다.\n- Fetcher: Fetcher는 카탈로그-info.yaml 파일 내에서 정의된 주석을 기반으로 Kubernetes 리소스를 검색하는 역할을 맡습니다. 검색된 리소스를 장식하고 반환합니다.\n- 서비스 로케이터: 이 컨텍스트는 서비스 로케이터 요청을 처리하며, 가져올 객체 유형, 사용자 정의 리소스, 자격 증명 등을 포함합니다.\n- 프록시: 프록시는 중간자 역할을 수행하여 Backstage에서 Kubernetes API 서버로 요청을 전달합니다. 프록시에서 요청 또는 응답의 내용을 수정할 수도 있습니다.\n- 인증 전략 맵: 인증 전략 맵은 인증 전략을 식별자 또는 키와 연결합니다. 클러스터 세부 정보 또는 인증 메타데이터와 같은 기준에 따라 인증 전략을 관리하고 검색하는 데 사용될 수 있습니다.\n\n# Fetcher(검색기) 사용자 정의: 다중 Namespace 로켸터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 Kubernetes 클러스터에서 쿼리를 가져 오고 일부 동작을 변경하는 Fetcher 모듈의 사용자 정의에 중점을두려고합니다. 다음 GitHub 링크에서 기본 Fetcher 모듈을 찾을 수 있습니다:\n\n때로는 보안 문제로 Kubernetes 클러스터에 대한 클러스터 역할 서비스 계정을 만들 수없으며 네임 스페이스 범위의 서비스 계정 만 만들 수 있습니다. 이 경우 다양한 네임 스페이스에서 다른 파드를로드해야하며 backstage.io/kubernetes-namespace 필드 내에 모든 네임 스페이스를 하나씩 지정해야합니다. 이를 달성하기 위해 컴포넌트를 주석 처리하고 다양한 네임 스페이스에서 파드를로드해야합니다. 구체적으로 KubernetesFetcher.ts 파일을 사용자 정의해야합니다.\n\n예를 들어, 다음 catalog-info.yaml 파일에서 kubernetes-namespace 필드에 쉼표로 구분 된 두 개의 네임 스페이스를 포함하는 것을 볼 수 있습니다. 이 두 네임 스페이스에서 파드를로드하려고합니다.\n\n\napiVersion: backstage.io/v1alpha1\nkind: Component\nmetadata:\n  name: order-service\n  description: 주문 서비스\n  links:\n    - title: 웹 사이트\n      url: https://docs.spring.io/spring-cloud-config/docs/current/reference/html/\n  annotations:\n    backstage.io/techdocs-ref: dir:.\n    lighthouse.com/website-url: https://docs.spring.io/spring-cloud-config/docs/current/reference/html/\n    'backstage.io/kubernetes-label-selector': 'app=order-service'\n    'backstage.io/kubernetes-namespace': 'spring-cloud-config-dev, spring-cloud-config-prod'\n    'backstage.io/kubernetes-cluster': dev-cluster\nspec:\n  type: 서비스\n  owner: me@example.com\n  lifecycle: POC\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 달성하기 위해 fetchObjectsForService 함수에서 약간의 변경을 해야합니다. 그러나 npm 모듈에서 내보내지 않았기 때문에 KubernetesClientBasedFetcher 클래스를 직접 확장할 수 없습니다. 대신 해당 클래스를 복사하고 일부 동작을 수정해야 합니다. 아래는 packages/backend/src/plugins/CustomKubernetesClientBasedFetcher.ts 파일에 있는 사용자 정의 모듈의 예시입니다:\n\n```js\nexport class CustomKubernetesClientBasedFetcher implements KubernetesFetcher {\n  private readonly logger: LoggerService;\n  constructor({ logger }: KubernetesClientBasedFetcherOptions) {\n    this.logger = logger;\n  }\n\n  fetchObjectsForService(\n    params: ObjectFetchParams,\n  ): Promise\u003cFetchResponseWrapper\u003e {\n    const namespaces = params.namespace ? params.namespace.split(\",\") : [\"default\"];\n\n    const fetchResults = Array.from(params.objectTypesToFetch)\n      .concat(params.customResources)\n      .flatMap(({ objectType, group, apiVersion, plural }) =\u003e\n        namespaces.map(namespace =\u003e\n          this.fetchResource(\n            params.clusterDetails,\n            params.credential,\n            group,\n            apiVersion,\n            plural,\n            namespace.trim(),\n            params.labelSelector,\n          ).then(\n              ....\n          )\n        )\n      );\n\n    return Promise.all(fetchResults).then(fetchResultsToResponseWrapper);\n  }\n```\n\n위 스니펫의 전체 코드는 여기에서 확인할 수 있습니다:\n\nhttps://gist.github.com/mlkmhd/dc8a97449777b7dc0c30bff7b032e4d5\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 더 해야 할 일이 있어요. 패키지/백엔드(src/index.ts) 파일을 수정하여 새로운 사용자 정의 모듈을 추가해야 해요. 아래와 같이요:\n\n```js\n...\n\nimport { kubernetesFetcherExtensionPoint } from '@backstage/plugin-kubernetes-node';\nimport { CustomKubernetesClientBasedFetcher } from './plugins/CustomKubernetesClientBasedFetcher';\n\n...\n\n// 쿠버네티스 플러그인\nexport const kubernetesModuleCustomFetcher = createBackendModule({\n  pluginId: 'kubernetes',\n  moduleId: 'custom-fetcher',\n  register(env) {\n    env.registerInit({\n      deps: {\n        kubernetes: kubernetesFetcherExtensionPoint,\n        logger: coreServices.logger,\n      },\n      async init({ kubernetes, logger }) {\n        kubernetes.addFetcher(\n          new CustomKubernetesClientBasedFetcher({\n            logger: logger,\n          })\n        );\n      },\n    });\n  },\n});\n\nbackend.add(import('@backstage/plugin-kubernetes-backend/alpha'));\nbackend.add(kubernetesModuleCustomFetcher);\n\nbackend.start();\n```\n\n또한, 다른 네임스페이스의 역할에 연결된 서비스 계정을 생성하여 다른 팟에 액세스할 수 있도록 해야 해요:\n\n\u003cimg src=\"/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스 계정은 backstage 네임스페이스 내에 있어야 합니다:\n\n```yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: backstage-sa\n  namespace: backstage-ns\n```\n\nB 네임스페이스 내의 역할은 다음과 같을 수 있습니다:\n\n```yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: backstage-role\n  namespace: b-ns\nrules:\n- apiGroups: [\"\"]\n  resources:\n    - pods\n    - pods/log\n    - configmaps\n    - services\n    - limitranges\n    - resourcequotas\n  verbs:\n    - get\n    - list\n    - watch\n- apiGroups: [\"apps\"]\n  resources:\n    - deployments\n    - replicasets\n    - statefulsets\n    - daemonsets\n  verbs:\n    - get\n    - list\n    - watch\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nC 네임스페이스 내부의 롤 바인딩은 다음과 같을 수 있어요:\n\n```js\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: backstage-role-binding\n  namespace: b-ns\nsubjects:\n- kind: ServiceAccount\n  name: backstage-sa\n  namespace: backstage-ns\nroleRef:\n  kind: Role\n  name: backstage-role\n  apiGroup: rbac.authorization.k8s.io\n```\n\nC 네임스페이스 또는 각 새로운 네임스페이스에 대해 롤과 롤 바인딩을 생성해야 해요. 이렇게 하면 해당 파드에 액세스하여 백스테이지 서비스 계정에 연결할 수 있어요. 그리고 이후에 app-config.yaml 파일 내에서 Kubernetes 플러그인을 아래와 같이 구성해야 해요:\n\n```js\n...\nkubernetes:\n  serviceLocatorMethod: \n    type: 'multiTenant'\n  clusterLocatorMethods:\n    - type: 'config'\n      clusters:\n        - url: https://kubernetes-cluster-api-server.example.com\n          name: dev-cluster\n          authProvider: 'serviceAccount'\n          skipTLSVerify: true\n          serviceAccountToken: ${K8S_DEV_TOKEN}\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 다음 명령어를 실행하여 애플리케이션을 빌드하고 실행할 수 있어요:\n\n```js\n$ cd backstage\n$\n$\n$ yarn install\n[1/5] package.json 유효성 검사 중...\n[2/5] 패키지 해결 중...\nsuccess 이미 최신 상태입니다.\n완료: 0.92초\n$\n$\n$ yarn dev --config app-config.yaml\n[0] app-config.yaml에서 구성 로드됨, app-config.local.yaml\n[0] \u003ci\u003e [webpack-dev-server] 프로젝트가 실행 중:\n[0] \u003ci\u003e [webpack-dev-server] Loopback: http://localhost:3000/\n[0] \u003ci\u003e [webpack-dev-server] 웹팩이 아닌 내용은 '/home/coder/ecfd-backstage/packages/app/public' 디렉터리에서 제공됨\n[0] \u003ci\u003e [webpack-dev-server] 404에는 '/index.html'로 대체함\n[0] \u003ci\u003e [webpack-dev-middleware] 번들 완료 대기중: /\n[1] MergedConfigSource에서 설정 로드됨\n[1] 2024-05-12T22:26:37.074Z backstage 정보 구성 내에 레드액트될 2개의 새로운 시크릿 발견됨 \n[1] 2024-05-12T22:26:37.082Z rootHttpRouter 정보 :7007에서 수신 대기중\n...\n```\n\n그런 다음 다음 catalog-info.yaml 파일을 backstage 구성에 추가해주세요:\n\n```js\napiVersion: backstage.io/v1alpha1\nkind: Component\nmetadata:\n  name: order-service\n  description: 주문 서비스\n  links:\n    - title: 웹사이트\n      url: https://docs.spring.io/spring-cloud-config/docs/current/reference/html/\n  annotations:\n    backstage.io/techdocs-ref: dir:.\n    lighthouse.com/website-url: https://docs.spring.io/spring-cloud-config/docs/current/reference/html/\n    'backstage.io/kubernetes-label-selector': 'app=order-service'\n    'backstage.io/kubernetes-namespace': 'spring-cloud-config-dev,spring-cloud-config-prod'\n    'backstage.io/kubernetes-cluster': dev-cluster\nspec:\n  type: 서비스\n  owner: me@example.com\n  lifecycle: POC\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대시보드 안에 이렇게 테이블 태그를 변경해보세요:\n\n\n\u003cimg src=\"/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_3.png\" /\u003e\n\n\n위 이미지에서 order-service는 spring-cloud-config-dev 네임스페이스에만 배포되어 있습니다. 그러나 이 서비스를 spring-cloud-config-prod 네임스페이스에 배포하면 거기서도 볼 수 있을 겁니다.\n\n이 글에서 사용된 모든 다이어그램은 다음 저장소에서 찾아볼 수 있습니다: [링크입니다.]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 글은 Spotify가 개발한 Backstage의 Kubernetes 플러그인 내에서 사용자 정의가 어떻게 응용 프로그램 관리를 향상시키는지를 탐구합니다. Kubernetes 리소스의 통합된 보기를 제공함으로써 작업 흐름을 최적화하고 특정 요구 사항을 수용하는 방법에 대해 알 수 있습니다. Backstage의 아키텍처와 사용자 정의 옵션을 자세히 살펴보면, Kubernetes 클러스터에서 데이터를 검색하기 위해 Fetcher 모듈을 사용자 정의할 수 있는 내용을 다룹니다. 이를 통해 보안 제약 조건이 있는 상황에서도 여러 네임스페이스의 파드에 액세스할 수 있게 됩니다.\n\n# 블로그 후원하기 🍵\n\n내 무료 기술 블로그를 즐기고 가치 있게 여기신다면, 여기에서 커피 한 잔 사주시는 것을 고려해주세요. 여러분의 지원은 품질 높은 글과 콘텐츠를 더 많이 제작하는 데 큰 도움이 됩니다. 제 코드를 개선하는 데 대한 피드백이나 제안 사항이 있으면, 이 게시물에 댓글을 남기거나 LinkedIn 메시지를 보내주세요.","ogImage":{"url":"/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_0.png"},"coverImage":"/assets/img/2024-05-17-CustomizingtheBackstageKubernetesPlugin_0.png","tag":["Tech"],"readingTime":10},{"title":"Docker 이미지를 빌드하고 GitHub Actions를 사용하여 Docker Hub에 푸시하기","description":"","date":"2024-05-17 03:47","slug":"2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png\" /\u003e\n\n여기서는 GitHub actions workflow를 사용하여 도커 이미지를 빌드하고 도커 허브에 푸시하는 방법을 알아보겠습니다.\n\n## 단계 1: 도커 파일 만들기\n\n- 도커 이미지를 빌드하려면 도커 파일을 만들어야 합니다.\n- 이 튜토리얼에서는 매우 기본적인 도커 파일을 만들고 해당 파일을 사용하여 이미지를 빌드할 것입니다.\n- Dockerfile을 만들고 아래 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Docker Hub에서 공식 Apache HTTP 서버 이미지를 사용하세요\nFROM httpd:latest\n\n# 호스팅을 위해 사용자 정의 'index.html'을 Apache 서버의 루트 디렉토리에 복사하세요\nCOPY ./index.html /usr/local/apache2/htdocs/\n```\n\n- 위의 코드는 다음 단계에서 생성할 사용자 정의 index.html을 사용하여 Apache 이미지 위에 이미지를 빌드합니다.\n\n## 단계 2: index.html 파일 생성\n\n- index.html 파일을 생성하고 아래 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003eHello World\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ch1\u003eHello, World!\u003c/h1\u003e\n    \u003cp\u003eThis is a simple HTML page served from an Apache server in a Docker container.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n### 단계 3: 도커 허브 자격 증명 저장\n\n- 도커 이미지를 도커 허브로 푸시하려면 먼저 도커 허브에 로그인해야 합니다. 따라서 해당 자격 증명을 시크릿에 저장해야 합니다.\n- 귀하의 저장소에서 자격 증명을 시크릿에 저장하세요.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_1.png)\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: GitHub 액션 워크플로우 생성하기\n\n- 이제 .github/workflow/image-build.yml 파일을 만들고 아래 코드를 추가하세요.\n\n```js\nname: Build Docker Image\non:\n  push:\n    branches:\n      - main\njobs:\n    build:\n      name: push docker image to docker hub\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v2\n        - name: login to docker hub\n          id: docker-hub\n          env:\n            username: ${secrets.DOCKERHUB_USERNAME}\n            password: ${secrets.DOCKERHUB_PASSWORD}\n          run: |\n            docker login -u $username -p $password \n        - name: build the docker image\n          id: build-docker-image\n          run: |\n            ls -la \n            docker build . -f Dockerfile -t dhruvin30/demo-image-test:latest\n        - name: push the docker image\n          id: push-docker-image\n          run: docker push ${secrets.DOCKERHUB_USERNAME}/demo-image-test:latest\n```\n\n- 위 워크플로우는 main 브랜치에 커밋할 때마다 트리거됩니다.\n- 워크플로우는 secrets(사용자 이름 및 비밀번호)를 사용하여 docker hub에 로그인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 5: 코드를 커밋합니다\n\n- 이제 코드를 GitHub 저장소에 커밋하고 커밋하자마자 워크플로가 실행되는 것을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_2.png)\n\n## 단계 6: 변경 사항 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 한 번 Workflow가 성공적으로 실행되면 이미지가 도커 허브에 표시될 것입니다.\n\n![이미지](/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_3.png)\n\n오늘은 여기까지입니다. GitHub Actions를 사용하여 도커 이미지를 빌드하고 푸시하는 방법을 배웠습니다. 이제 코드를 수정하고 실험해보세요.\n\nLinkedIn에서 팔로우해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 이런 이야기를 보고 싶다면 팔로우해 주세요 😁","ogImage":{"url":"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-17-BuildPushtheDockerimagetoDockerHubusingGitHubActions_0.png","tag":["Tech"],"readingTime":3},{"title":"대타브릭 챔피언 여정","description":"","date":"2024-05-17 03:45","slug":"2024-05-17-DatabricksChampionJourney","content":"\n\n다음은 Databricks 챔피언 배지를 획득하고 지명되기 위한 요구 사항입니다.\n\n1. 다음 중 하나의 경로를 통해 Databricks 인증을 취득하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nA. 데이터 엔지니어링 트랙은 다음과 같은 자격 인증 요구 사항으로 구성됩니다.\n\n- 데이터 엔지니어링 어소시에이트 인증,\n- 고급 데이터 엔지니어링 인증\n\n또는\n\nB. 데이터 과학 트랙은 다음과 같은 자격 인증 요구 사항으로 구성됩니다.\n\n- ML 어소시에이트\n- ML 프로페셔널\n\n저는 현재 진행 중인 업무와 일치하기 때문에 데이터 엔지니어링 경로를 선택했습니다. 데이터 엔지니어링 어소시에이트 및 프로페셔널 인증 모두 완료했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 PySpark 기술을 강화하기 위해 Spark 개발자 어소시에이트 시험을 응시하여 해당 자격증을 획득했습니다.\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_1.png)\n\n2. 데이터브릭스 솔루션 아키텍트 필수 배지 획득을 위해 3일간의 세션에 참석하고 평가를 거쳤습니다.\n\n솔루션 아키텍트 필수 자격은 데이터브릭스 파트너 포털을 통해 수강할 수 있는 여러 과정과 평가를 거쳐야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-17-DatabricksChampionJourney_2.png)\n\n3. Panel review with Databricks experts from Databricks\n\nThis step requires preparing a deck with the following contents:\n\n- Candidate introduction\n- Business problem statement\n- Solution overview\n- Reference architecture\n- Deep-dive into architectural areas\n- Project outlook / next steps\n- Contribution to the community (I have shared my medium.com blogs relating to Databricks topics)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내부적으로 Databricks 챔피언들과 함께 덱을 검토하세요. 때로는 당신이 제출을 평가하고 있는 Databricks 직원과 함께 모의 실행도 할 수 있어요.\n\n마지막으로, 덱이 완성되면 Databricks 특정 질문에 대답하며 덱을 설명하는 패널 리뷰에 참여하게 됩니다. 패널이 당신의 대답과 Databricks에 대한 전문성에 만족한다면, 당신은 챔피언으로 인정받을 거예요.\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_3.png)\n\n![이미지](/assets/img/2024-05-17-DatabricksChampionJourney_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 여기 언급된 체크리스트는 경우에 따라 다를 수 있습니다.\n\nDatabricks 챔피언의 혜택:\n\n- 비슷한 마음가짐을 가진 작은 그룹의 Databricks 챔피언\n- Databricks 분기로드맵 업데이트에 대한 액세스\n- Databricks 학습 자료, 솔루션에 대한 액세스\n- Databricks 내부 기술 서밋 초대 (매년)\n- 데이터 및 AI 서밋 할인 쿠폰\n- 무료 Databricks 챔피언 재킷 :)","ogImage":{"url":"/assets/img/2024-05-17-DatabricksChampionJourney_0.png"},"coverImage":"/assets/img/2024-05-17-DatabricksChampionJourney_0.png","tag":["Tech"],"readingTime":2},{"title":"Route 53과 AWS Lambda, S3를 이용해 간편하게 DNS 레코드 백업 자동화하기","description":"","date":"2024-05-17 03:44","slug":"2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3","content":"\n\n# 소개\n\nDNS 레코드를 관리하는 것은 여러 개의 호스티드 존을 다룰 때 특히 복잡할 수 있습니다. 이러한 레코드의 백업을 자동화하면 유지 관리가 단순화되는데 그치지 않고 필요할 경우 언제든지 백업을 사용할 수 있도록 해줍니다. 이 튜토리얼에서는 AWS Lambda 함수를 생성하여 이를 수행하는 방법을 살펴보겠습니다: 여러 호스티드 존에서 모든 DNS 레코드를 백업하고 이러한 백업을 S3 버킷에 저장하여 레코드의 완전한 JSON을 생성하고 CSV 파일의 별도의 파일에 구성합니다.\n\n# 준비 사항\n\n- 적절한 자격 증명으로 구성된 AWS 콘솔.\n- Route 53 및 S3에 액세스 할 적절한 권한.\n- 백업을 저장할 S3 버킷이 만들어져 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계별 가이드\n\n# 1. 람다 함수 생성하기\n\n먼저 람다 함수를 생성해 봅시다. AWS 콘솔에서 Lambda 서비스로 이동하고 \"함수 생성\"을 클릭합니다.\n\n- 이름: Route53Backup\n- 런타임: Python 3.x\n- 역할: Lambda 기본 권한을 가진 새 역할을 생성하고 Route 53 및 S3에 액세스할 수 있는 권한을 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n람다 정책 권한:\n\n```js\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"logs:CreateLogGroup\",\n            \"Resource\": \"arn:aws:logs:us-east-1:12345678:*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:us-east-1:12345678:log-group:/aws/lambda/lamda-name:*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:GetHostedZone\",\n                \"route53:ListHostedZones\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:ListResourceRecordSets\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\",\n                \"s3:ListAllMyBuckets\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::bucket_name\"\n            ]\n        }\n    ]\n}\n```\n\n# 2. Write the Code\n\n우리 람다 함수의 코드입니다. 이 코드는 여러 호스팅된 존에서 DNS 레코드를 검색하여 이를 S3 버킷에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport boto3\nimport json\nfrom datetime import datetime\nimport csv\n\ndef lambda_handler(event, context):\n    # 연결된 ID와 도메인 목록\n    hosted_zones = [\n        {'id': '$HOSTED_ZONE_ID', 'domain': '$DOMAIN'},\n        {'id': '$HOSTED_ZONE_ID_2', 'domain': '$DOMAIN2'}\n    ]\n\n    # Route 53 및 S3 클라이언트 초기화\n    route53_client = boto3.client('route53')\n    s3_client = boto3.client('s3')\n\n    # 목록의 각 호스팅 영역을 돌아다니기\n    for hosted_zone in hosted_zones:\n        # 모든 영역 레코드 가져오기\n        response = route53_client.list_resource_record_sets(\n            HostedZoneId=hosted_zone['id']\n        )\n\n        # JSON 형식으로 변환\n        records = json.dumps(response['ResourceRecordSets'], indent=2)\n        records_formatted = response['ResourceRecordSets']\n        #CSV에 행 생성\n        csv_rows = [[\"Name\", \"Type\", \"DNS Name\"]]\n\n        for record_formatted in records_formatted:\n            name = record_formatted['Name']\n            record_type = record_formatted['Type']\n            if 'AliasTarget' in record_formatted:\n                dns_name = record_formatted['AliasTarget']['DNSName']\n            elif 'ResourceRecords' in record_formatted:\n                dns_name = \", \".join([r['Value'] for r in record_formatted.get('ResourceRecords', [])])\n            else:\n                dns_name = \"\"\n            #CSV에 행 추가\n            csv_rows.append([name, record_type, dns_name])\n\n        #CSV 파일에 레코드 추가\n        csv_buffer = csv.writer(open(\"/tmp/\" + backup_filename_csv, 'w'))\n        csv_buffer.writerows(csv_rows)\n\n        # 오늘 날짜와 시간을 포함한 아카이브 이름\n        backup_filename = f\"{datetime.now().strftime('%Y%m%d-%H%M')}.json\"\n        backup_filename_csv = f\"{datetime.now().strftime('%Y%m%d-%H%M')}.csv\"\n\n        # S3에 업로드\n        s3_key = f\"{hosted_zone['domain']}/data/{backup_filename}\"\n        s3_key_csv = f\"{hosted_zone['domain']}/data/{backup_filename_csv}\"\n        s3_client.put_object(\n            Bucket='$BUCKET_NAME',\n            Key=s3_key,\n            Body=records\n        )\n        \n        s3_client.upload_file(\"/tmp/\" + backup_filename_csv, '$BUCKET_NAME', s3_key_csv)\n\n    return {\n        'statusCode': 200,\n        'body': f'Success.'\n    }\n```\n\nHOSTED_ZONE_ID 및 BUCKET_NAME의 값을 교체해주세요. 필요하다면 backup_filename_formatted 및 backup_filename 변수를 원하는 파일 이름으로 교체해주세요.\n\n# 3. 함수 테스트\n\n함수를 테스트하려면 Lambda 콘솔에서 테스트 이벤트를 구성할 수 있습니다. 예를 들어 사용하지 않는 직접적인 입력이 없으므로 빈 JSON ''을 사용할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 실행 일정 예약하기 (선택 사항)\n\n만약 람다 함수를 주기적으로 실행하고 싶다면 CloudWatch Events 트리거를 구성할 수 있습니다. CloudWatch 콘솔에서 “Rules”로 이동하여 새로운 규칙을 만들고 원하는 간격(예: 매일)에 람다를 트리거하도록 설정하세요.\n\n# 5. CSV 보기\n\n여기에 당신의 도메인 레코드가 어떻게 포맷될지 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png\" /\u003e\n\n# 결론\n\nRoute 53에서 DNS 레코드를 백업하는 것을 자동화하기 위해 Lambda 함수와 S3를 사용하는 것은 항상 DNS 레코드의 최신 사본을 보유할 수 있는 효과적인 방법입니다. 이는 유지 보수를 간편하게 해주는 것뿐만 아니라 DNS 설정의 보안성을 향상시킵니다.\n\n궁금한 점이나 제안 사항이 있으시면 아래 댓글에 남겨주세요. 즐거운 자동화 되세요!","ogImage":{"url":"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png"},"coverImage":"/assets/img/2024-05-17-SimpleautomatingDNSRecordBackupsfromRoute53withAWSLambdaandS3_0.png","tag":["Tech"],"readingTime":5},{"title":"규칙은 우리를 갇히는 우리의 속성일 뿐 그리고 나는 강아지 소녀야","description":"","date":"2024-05-17 03:42","slug":"2024-05-17-RulesAreACageandImaPuppygirl","content":"\n\n테이블탑 RPG 룰북은 우리를 제약하고 가둬 놓는 역할만 한다고 생각할 때, 왜 좋은 것일까요?\n\n![image](/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png)\n\n테이블탑 RPG 중 어떤 것을 살펴볼 때, 나에게 이 게임이 무엇을 제공하며 친구들과 상상놀이로 이루어지는 게임으로 이루기 어려운 것을 제공하는지가 가장 먼저 나오는 질문입니다. 몇 명의 친구들을 모아 함께 앉아 던전 모험가나 슈퍼히어로 등으로 소괴 모험가들로 모습을 변하며 행동을 상상으로만 설명해도 상관이 없고 이를 위해 룰북이 없어도 될 것입니다. 그래서 우리는 왜 게임을 하려고 하는 걸까요?\n\n가끔 (자주) 사람들이 특정 게임을 하라고 제안하는 이유는 특정 행동을 할 수 있는 권한을 부여하거나, 보통 할 수 없는 것을 시키기 위함이라고 말합니다. 그것은 나에게는 매우 만족스럽지 않은 대답입니다 - 상상 속에서 나는 아무런 허락도 필요로하지 않아요. 비디오 게임이나 보드 게임을 하는 경우라면, 소설의 세계보다 규칙이 우선이 되는 게임이라면 특정 행동을 할 수 있는 규칙이나 허락을 받기 위한 규칙에 관심을 갖게 될 것입니다. 하지만 TTRPG에서 궁극적으로는 내가 원하는 대로 아무것이나 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔(자주) 사람들은 이 질문을 듣고 그들의 게임이나 게임 즐기는 방식에 대한 위협으로 받아들이기도 합니다. 어떤 사람들은 이를 받아들이고 결론을 내립니다: 게임을 할 이유가 전혀 없다고요. 이는 많은 사람들에게 괴롭기도 합니다, 왜냐하면 그들은 게임을 만들고 즐기기를 좋아하기 때문이죠! 때때로 이 질문을 하기만 해도 고통을 초래할 수 있습니다. 하지만 나는 항상 친구들과 허구놀이를 하는 것이 아닙니다: 아주 많은 경우에는 게임을 선택하는 편이죠. 그렇다면 왜일까요? 게임이 제게 제공하는 것은 무엇일까요, 허구놀이에서는 얻을 수 없는 것이 뭔가요?\n\n# 강아지소녀들에 대해\n\n(안내: 제 개인적인 삶에서 하는 일은 제 개인적인 문제이며, 제 성적 취향이나 개인적인 선호 사항에 대한 이상한 농담을 받아들일 의도가 없습니다. 이 블로그 글을 통해 제게 대해 가정하는 것을 좋아하지 않을 거에요!)\n\n가끔 사람들은 구속을 즐긴다고 합니다(저도 들어봤어요). 목걸이를 차거나 우리를 감아넣는 것, 손목을 침대 프레임에 잠금해두거나 눈가림을 하는 것이 즐겁습니다. 이는 통제를 위해 투쟁하길 원하기 때문에 즐거운 것입니다. 팔을 움직이거나 말을 하거나 뭐 보는 것은 원하지만, 누군가가 당신을 위해 조금 어렵게 만들 수 있게 허용합니다. 그래서 마찰로부터 생기는 재미가 있기 때문입니다. 제가 감옥에 있다면, 그 감옥은 긴장과 마찰의 원천이 됩니다. 그것과 씨름하고, 물고, 부딪히는 등 제가 그것에 맞설 수 있습니다. 이것은 일반적으로 성취할 수 있는 것의 한계로 기능합니다. 감옥을 밀어보았더니 문이 열리면 실망하게 된다, 왜냐하면 그것은 내가 더 노력할 수 없었다는 것을 의미하기 때문이죠. 나는 내가 자신을 감옥에 던져도 버틸 수 있는 단단한 감옥을 원합니다고 해봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 게임으로 돌아가기\n\n게임이 규칙을 제시하면, 해당 규칙은 내가 처음에 의도했던 것과 간섭합니다. 가짜놀이를 할 때는 원하는 대로 벽을 뛰어넘을 수 있습니다. 다만 뛰어넘고 싶지 않을 때는 그렇지 않습니다. 다만 Dungeons \u0026 Dragons를 할 때 12피트 높이의 벽을 뛰어넘고 싶다면, 고난도의 민첩성 체크를 굴려야 하며, 실패하면 벽을 넘을 수 없습니다. 이 규칙은 초기에 하던 가짜놀이를 방해하고, 내 행동력을 제한합니다.\n\n하지만 이런 것이 좋다는 것이죠!\n\n내가 가짜놀이를 하는 대신 특정한 테이블탑 RPG를 하는 이유는 게임이 내가 지나가는 상상 속 세계에 도전을 주고 괴롭히기를 바란다는 것입니다. 게임이 나를 감금하고, 일반적으로 할 수 있는 일을 어렵게 만들어줄 것을 원하고, 효율성을 떨어뜨리는 순간들을 만들어내며 내 행동 방식을 조각하는 것입니다. 우리가 테이블을 선택했던 이유가 바로 이것이기 때문이죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임이 우리 상상력에 개입하는 방식, 어디서 개입해야 하는지 아니면 뒤로 물러나야 하는지가 게임이 초점을 어디에 두는지를 반영합니다. 던전 앤 드래곤즈는 전투에 대한 많은 규칙을 갖고 있지만 사교적 상호작용에 대한 규칙은 매우 적습니다. 이는 던전 앤 드래곤즈 시스템이 전투에 참여하는 방법에 간섭하고 중재하는데 큰 투자를 하고 사회적 상호작용에 참여하는 방법에 간섭하지 않으려고 노력한다는 것을 의미합니다. \n\n이 사실을 해석하는 여러 가지 방법이 있습니다: 어떤 사람들은 던전 앤 드래곤즈가 전투에 더 관심을 두는 것으로 생각할 수 있지만, 다른 사람들은 던전 앤 드래곤즈가 전투를 피하면서 자유로운 사회적 장면을 위한 공간을 마련한다고 생각할 수도 있습니다.\n\n최종적으로 던전 앤 드래곤즈에서는 전투 주변에 큰 울타리가 있고, 사회적 상호작용 주변에는 넓은 공간이 펼쳐져 있습니다. 만약 우리가 던전 앤 드래곤즈가 제공하는 공간에서 게임을 하고 싶다면, 우리는 울타리 안에 갇히거나 마당을 살랑살랑 걸어다닐 수 있으며, 어느 쪽이 더 재미있고 유익한지는 우리에 달려 있습니다.\n\n## 게임 텍스트에 대한 한 가지 짧은 이야기\n\n나는 계속해서 \"게임이 이것을 원한다\" 또는 \"게임이 우리의 행동을 제한한다\"고 말하고 있습니다. 이는 물론 헛소리입니다 — 탁상 RPG는 규칙을 설명하는 게임 텍스트이지만 강제 실행 메커니즘이 없습니다. 우리는 그러한 규칙을 해석하고 우리의 게임에 적용하지만, 아무도 우리에게 그렇게 하도록 할 의무는 없습니다. 내가 게임 텍스트가 원하는 것에 대해 말할 때, 나는 게임 텍스트가 제시하는 규칙을 완전히 이해하고 적용하고 우리 게임에 사용하는 상황을 의미합니다. 규칙이 울타리라면, 그 울타리를 산 사람은 우리이고, 우리는 울타리를 세우거나 무시할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래도, 바닥에 앉아있는 케이지가 있는 경우, 그것을 무시하고 있더라도 우리가 하는 방식을 형성합니다. 우리가 던전 앤 드래곤을 하기로 결정하고, 주사위를 한 번도 굴리지 않고 상황을 탐험하려고 한다면(우리는 주사위를 굴리지 않는 세션을 진행한다), 규칙의 잠재력은 여전히 우리와 함께 존재합니다. 우리가 초대한 존재입니다(책을 테이블 위에 놓기로 선택했습니다), 하지만 그 존재는 우리의 행동을 조각하고, 마치 깜박이는 양초나 반지의 제왕이 그랬던 것처럼.\n\n## 원더홈 (예시)\n\n'Wanderhome'은 매우 적은 규칙을 갖춘 게임입니다. 최소한의 토큰 경제 관련 가볍고 쉽게 무시할 수 있는 것들과 서로가 어떻게 관련 지어지는지를 형성하는 많은 선택 목록이 있지만, 이 게임에서 유일하게 단호한 입장을 취하는 것은 이 게임에는 폭력이 없다는 주장이라는 것뿐입니다. 그리고 황제 역할의 경우, 폭력을 허용하는 단 하나의 규칙이 있습니다. 검을 빼내고 당신 앞에 있는 사람을 쳐서 황제를 플레이 공간에서 제외시키세요.\n\n몇 사람들은 폭력의 가능성을 피하면서 'Wanderhome'을 하는데, 가능한 한 이 제한에서 최대한 멀리 떨어져 있습니다. 그것 또한 괜찮습니다! 하지만 나는 그 제한에 가까이 다가가보고 얼마나 가까이 다가갈 수 있는지를 보는 방식을 좋아합니다. 지나갈 수 없는 케이지가 있다는 것을 알고 있는 것은 나에게 그 케이지의 모든 무게를 받쳐 밀어 넣을 수 있는 기회를 줍니다. 폭력은 허용되지 않는다는 것은 나에게 혼란과 참사적인 상황에 놓이게 하고, 상황이 폭력적으로 전개되는 것을 피하면서 어떻게 일으키지 않고 나갈 수 있는지 함께 해보는 과정을 보여줍니다. 황제의 폭력 행위는 유일한 탈출 가닥을 보여주며, 케이지 밖으로 나갈 수 있는 독특하고 참상적인 능력을 가진 황제가 어떻게 플레이되는지를 유일하게 형성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 상자에 쓰여 있는 문구가 “여기에 절대 가까이 오지 마세요\"가 아니라 \"나오기 어려울수록 정말 흥미로운 것이 있다!\" 라는 말이에요!\n\n# 마크 로즈워터에 대하여 알아보기\n\n마크 로즈워터는 유명한 말을 했어요: “제한은 창의력을 낳는다.” 제한이 창의력을 독려한다는 말이 사실이라고 생각해요. 또, 게임을 할 때 창의력을 발휘할 때도 그렇죠. 제한이라는 것은 예상치 못한 새로운 가능성을 제시해주기 때문에 놀라운 플레이 경로를 만들어내요! 만약 단순한 싸움으로는 패배할 걸 알고 있다면, 다른 방식으로 그 싸움에 참여하려고 할 거에요. 만약 랜덤한 테이블을 굴려 두 가지 이상의 이상한 아이디어를 결합하라는 지시를 받는다면, 정말 흥미진진한 결과가 나올 거에요!\n\n또한, 가끔씩 제한은 재미없을 수도 있어요 — 특히 “까탈스런” 제한은요. 플레이 시 불편함이 느껴지는 것이 반드시 즐거운 것은 아니죠. 로즈워터도 이에 대해 이야기했어요. 모든 사람들이 그 제한에 동의해야 하며, 그 제한에 대하여 즐거움을 느낄 수 있어야 해요. 플레이어와 게임 디자이너 사이의 사회 계약의 일부로서, 게임 디자이너는 그 한계가 흥미롭다고 보장했다는 것을 이해해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 세븐-파트 팩트 (또 다른 예시)\n\n세븐-파트 팩트는 저가 만드는 게임인데 (그리고 제 Patreon을 지원해주신다면 읽을 수 있어요) 세븐 마법사들이 세상을 유지하려고 노력하는 이야기입니다. 이 게임은 대부분 남성 우위적인 공간에서 존재하는 것과 관련이 있습니다 (마법사들은 남성이어야 한다고 기대되며, 주류 사회 기대가 게임 구조의 많은 부분을 통제합니다). 규칙은 제한적이고 시뮬레이션 중심적이며 복잡하며 제한적입니다. 아내와 자식들과의 시간을 보내면서 이에게 기계적 이득을 누릴 때만 장려받게 됩니다. 직무 수행에 주력하는 대신 그들과 시간을 보내기로 선택한다면 역할에 중점을 두는 데 어려움을 겪게 될 것입니다.\n\n이러한 규칙은 엄격하고 강렬한 남성 우위 사회 구조를 모델링하고자 하는 것이며, 플레이어들은 해당 플레이 영역을 즐기며 즐길 수 있습니다. 이것은 아내와 자식들과 시간을 보내는 것을 보상하는 것이 아니라, 스스로의 행동이 이기적인 행동이 되게끔 만든 인센티브입니다 - 다른 것을 소홀히 하는 것인지, 아니면 그렇게 하기 위해 보상을 받고 있는 것인지, 그로부터 인류가 느껴진다는 게 기분 나쁘게 느껴질 것입니다. 이 규칙은 잔인하고 부당합니다. 이를 깨기 위한 방법을 찾고, 벗어나고, 가족과 자유롭게 살 수 있는 방법을 찾고 싶어합니다. — \n\n혹은 그렇게 하지 않을 수도 있습니다. 캐릭터가 일에 초점을 맞춘 잔인한 사나이일 수도 있습니다. 아니면 그냥 냉담할 수도 있고, 플레이어로서 이를 깨닫지 못하고 무시하며 마법사를 경솔하게 방치할 수도 있습니다. 이러한 모든 것들이 인센티브 시스템으로부터 나오는 흥미로운 반응들입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 당신을 감옥에 가둔 상태에서 무엇을 할지 제어할 수 없어요. 혹시 그 위에 올라서거나 강간하거나 놀기 싫어하거나 무시하고 핸드폰으로 놀 수도 있죠. 이 모든 것들은 전혀 합리적인 정서적 반응들이에요. 게임 디자이너로서, 제가 당신의 감정을 제어하지는 않아요. 단지 당신의 즐거움을 위해 그 감옥을 설치할 뿐이죠.\n\n# Ouppy Play\n\n함께 놀아요! 함께 들판을 돌아다니며 우리가 할 수 있는 것의 한계를 찾아보고, 그 한계에 최대한 강하고 강렬하게 저항해봐요. 우리가 벽으로 만들어진 공간을 탐험할 수 있도록 선과 장막을 설치해요. 규칙이 방해될 때 그 시련으로부터 어떤 흥미로운 것들이 나오는지 보죠. 디자이너로서, 그 규칙이 싸워볼 가치가 있는지 확인합시다.\n\n이 블로그 글은 원래 저의 Patreon에 게시되었어요. Possum Creek Patreon을 지원하면 이런 블로그 게시물들을 몇 주 혹은 몇 달 앞서 볼 수 있을 뿐만 아니라 독점 아티클, 게임, 최초 미리보기 등의 혜택도 받을 수 있어요.","ogImage":{"url":"/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png"},"coverImage":"/assets/img/2024-05-17-RulesAreACageandImaPuppygirl_0.png","tag":["Tech"],"readingTime":6},{"title":"Google IO에서 공식적으로 Kotlin Multiplatform을 지원한다고 발표되었습니다","description":"","date":"2024-05-17 03:41","slug":"2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform","content":"\n\n## 그러나 Dagger/Hilt는 아직입니다.\n\n![이미지](/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png)\n\n요즘 구글 I/O 2024를 놓치셨다면:\n\n\"여러분이 코틀린을 얼마나 사랑하는지 잘 알고 있습니다! 커뮤니티의 성장과 열정을 보는 것이 정말 즐거웠습니다. 오늘, 안드로이드에서 Kotlin Multiplatform을 위한 일류 도구 및 라이브러리 지원으로 나아가는 미래로 큰 한걸음을 내딛었다는 것을 기쁘게 알려드립니다!\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 Datastore와 같은 선택된 JetPack 라이브러리에 Kotlin Multiplatform 지원을 추가해왔고, 이제는 Room과 같은 즐겨 사용하는 라이브러리로 확대하고 있습니다. Google에서는 Google Docs 앱을 Kotlin Multiplatform을 사용하여 Android, iOS 및 Web 간에 비즈니스 로직을 공유하기 위해 이주 작업을 진행 중입니다.\n\nWorkspace 팀은 앞으로 나머지 앱들에 Kotlin Multiplatform을 사용하여 투자할 수 있는 기회에 대해 흥분하고 있습니다. Google 앱들과의 작업을 통해 많은 것을 배우고 있으며, JetBrains 및 Kotlin 개발자 커뮤니티와 협력하여 KMP의 혜택을 여러분 모두에게 제공할 예정입니다. Kotlin Multiplatform은 플랫폼 간에 비즈니스 로직을 공유함으로써 생산성을 높일 것입니다.\n\n# 두 주 전에 Dagger 팀에게 KMP 지원 로드맵에 대해 물어보았습니다\n\n![이미지](/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 알아보니 Dagger/Hilt는 여전히 KSP 지원을 수정하는 데 어려움을 겪고 있지만, 적어도 두 주 전까지 KMP를 지원할 계획이 없었다고 합니다.\n\n# DI(Dependency Injection) 방법에 대해 사람들의 선호도가 아주 강하다는 것을 알고 있어요\n\n직접적인 의존성 주입, 서비스 로케이터, Dagger/Hilt, 그리고 Koin 사이의 논쟁은 제가 업무에서 어떤 DI 프레임워크를 사용하기 전에도 훨씬 일찍 시작되었을 겁니다. 저는 Koin을 시도해보고, 그리고 3년 전에 Dagger와 Hilt를 사용해 봤어요.\n\n이 주제는 새로운 것이 아니죠. 제가 처음 보는 것 처럼 논쟁하지는 않을 거에요. 당신이 선호하는 것/반대하는 것을 쉽게 검색해서 찾아볼 수 있어요. 제 생각과 다르지만 몇 가지 무작위 검색 결과를 여기에 정리해 봤어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 흥미로운 포인트?\n\nKMP로 이동할 때 DI 프레임워크를 전환하는 것만이 관심사가 아닙니다. 사람들이 네이티브 안드로이드에서 /app에서 KMP의 /composeApp으로 소스 코드를 이동할 때 논리적 추론을 어떻게 했는지를 보여줍니다.\n\n이 모든 해외에서 과거와 새로운 선호도를 지원하기 위한 의존성 주입에 대한 긴 기술적 토론을 어떻게 잊었을까요? DI 자체를 지원하기 위해 어떤 프레임워크를 선택하는 것보다 이게 더 흥미롭습니다.\n\nDI 프레임워크의 가용성 때문에 KMP 이주를 망설일 정도로 잘 알고 있는 사람들도 있습니다. 웹에서 검색할 수 있는 토론들이 분명 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 하지만 현재 이러한 대안들도 있어요:\n\n- Kodein\n- kotlin-inject\n- Koject\n- DI.kt\n- PopKorn\n\n그리고 당연히 의존성 주입을 위해 Koin을 사용하고 있어요.\n\n돈을 벌어야 해서 Koin을 사용하고 있지만, 시간이 될 때 다른 대안들을 시도해볼 수 있는지 보겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급한 것 중에 시도해 본 적이 있는 경우에는 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png"},"coverImage":"/assets/img/2024-05-17-ItwasclaimedatGoogleIOthattheyofficiallysupportKotlinMultiplatform_0.png","tag":["Tech"],"readingTime":3}],"page":"3","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>