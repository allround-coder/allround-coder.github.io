<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="React에서 Lazy Loading의 내부 작동 원리 이해하기" href="/post/2024-06-27-UndertheHoodofLazyLoadinginReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 Lazy Loading의 내부 작동 원리 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 Lazy Loading의 내부 작동 원리 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 Lazy Loading의 내부 작동 원리 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁" href="/post/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS 데이터 검증 및 변환하는 방법" href="/post/2024-06-27-NestJSDataValidationandTransformation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS 데이터 검증 및 변환하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS 데이터 검증 및 변환하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS 데이터 검증 및 변환하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보 프로그래머가 흔히 저지르는 실수 10가지" href="/post/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보 프로그래머가 흔히 저지르는 실수 10가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보 프로그래머가 흔히 저지르는 실수 10가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">초보 프로그래머가 흔히 저지르는 실수 10가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" href="/post/2024-06-27-AladoanewlightweightwebframeworkforNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " href="/post/2024-06-27-iBuildaCliToollikeShadcnforNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" href="/post/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 18로 뉴욕 타임스 웹 성능 향상 방법" href="/post/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 18로 뉴욕 타임스 웹 성능 향상 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 18로 뉴욕 타임스 웹 성능 향상 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 18로 뉴욕 타임스 웹 성능 향상 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" href="/post/2024-06-27-Itstimetokilltheweb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-Itstimetokilltheweb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" href="/post/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"React에서 Lazy Loading의 내부 작동 원리 이해하기","description":"","date":"2024-06-27 17:56","slug":"2024-06-27-UndertheHoodofLazyLoadinginReact","content":"\n\n우리와 함께 게으른 로딩의 세계로 들어가보세요! 이 블로그에서는 게으른 로딩 뒤에 숨겨진 비밀을 밝혀내며, 이 똑똑한 기술이 앱의 성능을 최적화하는 방법을 안내해 드릴 거에요. 리액트가 어떻게 구성 요소를 동적으로 로드하고 사용자 경험을 향상시키는 지 살펴보며 함께 재미있게 탐험해 봐요. 당신의 앱 속도와 효율을 높이기 준비가 되셨나요? 함께 시작해봅시다!\n\n# 게으른 로딩이란?\n\n게으른 로딩은 이미지와 같은 웹페이지의 일부를 필요할 때까지 로딩을 지연시키는 기술입니다. 모든 것을 한 번에 로딩하는 것이 아니라(열렬한 로딩), 브라우저는 사용자가 스크롤하거나 해당 부분과 상호 작용할 때에만 리소스를 요청합니다. 이는 웹페이지의 빠른 로딩과 성능 향상에 도움이 됩니다.\n\n# 왜 게으른 로딩이 필요할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트에서는 일반적으로 전체 코드가 번들링되어 한꺼번에 배포됩니다. 이는 성능에 큰 영향을 미치지 않기 때문에 작은 Single Page Applications (SPAs)에 대해 잘 작동합니다. 그러나 고객 및 관리자 포턄을 따로 두는 콘텐츠 관리 시스템과 같은 대규모 애플리케이션의 경우, 한꺼번에 모든 것을 로딩하는 것은 효율적이지 않습니다. 이는 불필요한 데이터 전송으로 이어져 웹사이트 로딩이 느려지게 됩니다. 고객은 관리자 기능이 필요 없으므로 이를 로딩하는 것은 메모리와 시간을 낭비하게 됩니다.\n\n# 리액트에서 어떻게 lazy loading을 구현할까요?\n\n리액트에서 lazy loading을 구현하려면 React.lazy 함수와 Suspense 컴포넌트를 함께 사용할 수 있습니다. 다음은 이를 어떻게 할 수 있는지 설명하는 간단한 예시입니다:\n\n- 리액트와 필요한 컴포넌트를 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { Suspense, lazy } from 'react';\n```\n\n2. \n적게 로드되는 구성 요소를 정의하십시오:\n\n구성 요소를 직접 가져 오는 대신 React.lazy를 사용하여 게으르게로드하십시오.\n\n```js\nconst LazyComponent = lazy(() =\u003e import('./LazyComponent'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. `Suspense`로 지연로드된 컴포넌트 감싸기:\n\n지연로드된 컴포넌트를 가져오는 동안 로딩 스피너와 같은 대체 UI를 제공하도록 `Suspense` 컴포넌트를 사용하세요.\n\n```js\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cLazyComponent /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n완성된 예시는 여기에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport React, { Suspense, lazy } from 'react';\n\n// 컴포넌트의 Lazy로딩\nconst LazyComponent = lazy(() =\u003e import('./LazyComponent'));\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eMy App\u003c/h1\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cLazyComponent /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\r\n```\n\n이 예시에서 LazyComponent는 필요할 때만 로드되어서 애플리케이션의 초기 로드 시간을 단축시킵니다. Suspense 컴포넌트는 LazyComponent가 로드될 때까지 대체 UI(이 경우 간단한 \"로딩 중...\" 메시지)를 보여줍니다.\n\n# 내부적으로 Lazy Loading은 어떻게 작동하나요?\n\n우선, 이 주제에서 React 내부에서 어떻게 Lazy Loading이 설정되는지 설명하겠습니다. 이 주제를 잘 이해하기 위해서는 Fiber 노드와 그 속성에 익숙해져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보를 원하시면 Fiber 노드에 관한 이 기사를 참조해보세요: React에서 Virtual DOM 구조 이해하기.\n\n여기에서 다이어그램은 레이지 로딩이 추가되었을 때 Fiber 노드 트리가 어떻게 작동하는지, 동적 import promise가 실행되는 방식, 그리고 폴백이 표시되는 방식을 보여줍니다.\n\n![다이어그램](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png)\n\nSuspense Fiber 노드: 이 노드는 동적 import의 promise를 포함하는 WeakSet을 추적합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: import('./LazyComponent')로 생성된 promise;\n\nReact.offScreen 노드: 이 노드는 나태한 promise를 추적하여 해결되었는지 여부를 결정합니다. 이 노드에서는 보류 중인 결과를 promise에서 기다립니다.\n\n![](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_1.png)\n\n_payload 프로퍼티에서 _result는 promise(동적 import)이 포함되어 있으며, _status에는 promise의 상태(예: 0은 대기 중)가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFallback Div Node: 만약 프라미스가 보류 상태인 경우, 대체 div가 표시됩니다. 이 대체 div는 React.offScreen의 형제 포인터에서 나옵니다.\n\n프라미스가 해결될 때 실제 컴포넌트가 표시되는 과정에 대한 설명입니다.\n\n![이미지](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_2.png)\n\nSuspense 노드: WeakSet은 프라미스를 추적하며, 프라미스가 해결되면 세트가 비워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact.offScreen 노드: 이 노드는 실제 구성 요소를 표시하도록 값을 업데이트합니다. 형제 포인터를 null로 설정하고 실제 구성 요소를 자식 포인터로 설정합니다. 대기 중인 props가 변경되어 memorizedProps 와 동일해집니다.\n\n그리고 Pending props가 변경되고 memorized props 와 동일해집니다.\n\n![이미지](/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_3.png)\n\n약속이 이행되면: _result 속성에는 실제 모듈이 저장됩니다. _status 속성은 약속이 오류 없이 이행되었음을 나타내는 1로 설정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 만약 지연 컴포넌트가 사용되지 않는다면?\n\n만약 지연 컴포넌트가 사용되지 않는다면, React.offScreen 노드가 트리에 생성되지 않고 프로미스가 실행되지 않습니다. 따라서 추가 작업이 수행되지 않습니다.\n\n# 요약\n\n- 프로미스가 해결되면, 실제 컴포넌트가 React.offScreen 노드를 업데이트하여 표시됩니다.\n- 지연 컴포넌트를 사용하지 않는 경우, 추가 노드나 프로미스가 생성되거나 실행되지 않습니다.","ogImage":{"url":"/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png"},"coverImage":"/assets/img/2024-06-27-UndertheHoodofLazyLoadinginReact_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬 숫자에 대해 미리 알았으면 좋았을 6가지 팁","description":"","date":"2024-06-27 17:55","slug":"2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers","content":"\n\n아래는 Mardown 형식을 사용한 표태그입니다:\n\n\n| 열1 | 열2 |\n|-----|-----|\n| 내용1 | 내용2 |\n| 내용3 | 내용4 |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ny: float = 3.45e-4\n\nprint(y) # 0.000345\n```\n\n- 1.25e5 means 1.25 * 10 ^ 5 (which is 100000)\n- 3.45e-4 means 3.45 * 10 ^ -4 (which is 0.0001)\n\nWith this, we can easily type out very large and very small numbers without having to ensure that we’ve typed the correct number of zeros.\n\n# 2) We can insert underscores in our numbers\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 숫자를 읽기 쉽게 하기 위해 0을 모아 놓을 수 있습니다.\n\n```js\nx: int = 1_000_000_000\n\nprint(x) # 1000000000\n```\n\n^ 여기서는 3개의 0 사이마다 _ 하나를 넣어서 한 눈에 10억이라는 것을 알 수 있도록 만듭니다.\n\n```js\ny: int = 1_0_0_00_000\n\nprint(y) # 10000000\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n^ 각 그룹당 3 개의 숫자가 있어야 하는 것은 의무적이 아닙니다. 원하는 만큼 많은 숫자 그룹당 0을 넣을 수 있지만, 저는 3개로 고정하는 것이 가장 읽기 쉽다고 생각했습니다.\n\n# 3) 음수 소수 자릿수로 round() 할 수 있습니다\n\n숫자를 -2 소수 자릿수로 round() 하면, 해당 숫자를 가장 가까운 100의 배수로 반올림합니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -2)) # 123500\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n숫자를 -3 소수점 자리로 round() 함수를 사용하면, 가장 가까운 1000으로 올립니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -3)) # 123000\n```\n\n숫자를 -4 소수점 자리로 round() 함수를 사용하면, 가장 가까운 10000으로 올립니다.\n\n```js\nx: int = 123456\n\nprint(round(x, -4)) # 120000\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4) divmod() 함수를 사용하여 //와 %를 동시에 수행할 수 있어요\n\n```js\na, b = divmod(57, 10)\n\nprint(a) # 5\nprint(b) # 7\n```\n\n내장 함수인 divmod(a, b)는 2개의 정수 a와 b를 입력으로 받고, (몫, 나머지)를 담은 튜플을 반환해요.\n\n- 57을 10으로 나눈 결과는 몫이 5이고, 나머지가 7이에요\n- a // b를 하면 몫을 얻을 수 있어요\n- a % b를 하면 나머지를 얻을 수 있어요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`divmod` 함수를 사용하면 동시에 이를 수행할 수 있어서, 우리가 `//`와 `%`를 동시에 해야 할 때 코드 한 줄을 절약할 수 있어요.\n\n# 5) 양수 무한대와 음수 무한대\n\n`float('inf')`를 사용하면, 사실 양의 무한대를 얻을 수 있어요.\n\n```js\nx: float = float('inf')\n\nprint(x) # inf\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 float(`-inf`)를 실행하면 음의 무한대를 얻습니다.\n\n```js\ny: float = float('-inf')\n\nprint(y) # -inf\n```\n\n양의 무한대는 다른 모든 숫자보다 큽니다. 반면 음의 무한대는 다른 모든 숫자보다 작습니다.\n\n```js\nx: float = float('inf')\n\nprint(x \u003e 1)          # True\nprint(x \u003e 1_000_000)  # True\nprint(x \u003e 3.14e100)   # True\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ny: float = float('-무한대')\n\nprint(y \u003c -1)          # True\nprint(y \u003c -1_000_000)  # True\nprint(y \u003c -1e1000)     # True\n```\n\n우리는 다른 모든 숫자보다 크거나 작은 숫자가 필요할 때 양의 무한대 혹은 음의 무한대를 사용할 수 있습니다.\n\n# 6) 내장 decimal 모듈\n\nPython에는 내장된 decimal 모듈이 있어서 간단히 가져와서 사용할 수 있으며, 십진수 숫자를 다룰 수 있는 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom decimal import Decimal\n\na: Decimal = Decimal(1) / Decimal(3)\n\nprint(a) # 0.3333333333333333333333333333\n```\n\n하지만 왜 우리는 보통의 부동 소숫점 숫자 대신 이것을 사용해야 할까요?\n\n- 부동 소숫점 숫자는 근사값입니다\n- 부동 소숫점 숫자는 부동 소수점의 정확도 문제가 발생할 수 있습니다\n- Decimal은 더 정확하게 설계되어 있습니다\n\n```python\na: float = 2.0\nb: float = 2.000000000000000000000001\n\nprint(a == b) # True\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 지점을 넘어서면 부동 소수점 정밀도 부정확성이 발생할 수 있으며, 이는 작은 숫자에 대해 문제가 될 수 있습니다.\n\n# 7) (보너스) 복소수\n\n수학 수업에서 복소수라는 이상한 개념을 다뤘던 기억이 나시나요? 파이썬에서도 이를 할 수 있습니다.\n\n```python\na: complex = complex(5, 7)\n\nprint(a)        # (5+7j)\nprint(type(a))  # \u003cclass 'complex'\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 5 + 7j는 5 + 7i를 의미해요 (실수 부분 5 + 허수 부분 7)\n\n```js\na: complex = complex(5, 7)\n\nprint(a.real)  # 5.0\nprint(a.imag)  # 7.0\n```\n\n^ 우리는 .real과 .imag을 사용하여 허수의 실수부와 허수부를 추출할 수 있어요.\n\n```js\nimport cmath\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n^ 내장 cmath 모듈을 가져와서 다양한 복소수 연산을 수행할 수 있어요! (자세히 설명하지는 않겠죠)\n\n저는 직장에서 이것을 사용해본 적이 없어요 (왜 쓰겠어요 ㅋㅋ), 그래도 재미있는 사실을 알게 되어서 기뻤어요.\n\n# 유머 콘텐츠\n\n# 제작자로서 저를 지원하고 싶으시다면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제 책을 구매해주세요! — 파이썬에 대해 알지 못했던 101가지 이야기\n- 어디서 찾을 수 있나요: https://payhip.com/b/vywcf\n- 이 이야기에 박수 50번 치세요\n- 당신의 생각을 남겨주세요\n- 이 이야기에서 가장 마음에 드는 부분을 강조해주세요\n\n감사합니다! 이 작은 행동이 큰 도움이 되며, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/","ogImage":{"url":"/assets/img/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers_0.png"},"coverImage":"/assets/img/2024-06-27-6ThingsIWishIKnewEarlierAboutPythonNumbers_0.png","tag":["Tech"],"readingTime":4},{"title":"NestJS 데이터 검증 및 변환하는 방법","description":"","date":"2024-06-27 17:54","slug":"2024-06-27-NestJSDataValidationandTransformation","content":"\n\n이 보고서는 Node.js 서버 측 애플리케이션 개발을 위한 프레임워크 인 NestJS에서 데이터 유효성 검사 및 변환 기술을 요약합니다.\n\n## 데이터 유효성 검사의 중요성\n\n데이터 유효성을 검사함으로써 컨트롤러 계층에 도달하기 전에 미리 정의된 규칙을 준수하는지 확인할 수 있습니다. 이를 통해 다음과 같은 문제가 방지됩니다:\n\n- 잘못된 또는 해로운 데이터: SQL 인젝션 및 예기치 않은 데이터 유형과 같은 공격에 대비합니다.\n- 오류 및 예외: 유효하지 않은 데이터 형식으로 인한 오류를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n높은 데이터 무결성: 데이터가 정의된 규칙을 준수하는 것을 보장합니다.\n오류 감소: 잘못된 데이터로 인한 문제를 방지합니다.\n더 깔끔한 코드: 데이터 유효성 검증 논리를 컨트롤러로부터 분리합니다.\n\n![이미지](/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png)\n\n# 컨트롤러 이전에 DTO 및 입력 데이터의 유효성 검사를 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/typestack/class-validator\n\n![image](/assets/img/2024-06-27-NestJSDataValidationandTransformation_1.png)\n\n# 패키지 설치\n\n```js\nyarn add class-validator class-transformer\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 문서 유효성 검사\n\n# 개발자 모드에서 실행\n\n```js\nyarn start:dev\n```\n\n# 파이프 컨트롤러 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmain.ts\n\n```js\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(new ValidationPipe());\n  await app.listen(3000);\n}\nbootstrap();\n```\n\nDTO 폴더\n\n```js\nimport { IsNotEmpty } from 'class-validator';\n\nexport class CreateTaskDto {\n  @IsNotEmpty()\n  title: string;\n\n  @IsNotEmpty()\n  description: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ID가 존재하는지 확인하기\n\n서비스\n\n```js\n  getTaskById(id: string): Task {\n    const found = this.tasks.find((task) =\u003e task.id === id);\n    if (!found) {\n      throw new NotFoundException(`ID가 \"${id}\"인 Task를 찾을 수 없습니다`);\n    }\n    return found;\n  }\n```\n\n# 요소가 삭제된 경우 ID가 존재하는지 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  deleteTask(id: string): void {\n    const found = this.getTaskById(id);\n    this.tasks = this.tasks.filter((task) =\u003e task.id !== found.id);\n  }\n```\n\n## 요소가 업데이트될 때 ID가 존재하는지 확인\n\n```js\n  updateTaskStatus(id: string, status: TaskStatus): Task {\n    const task = this.getTaskById(id);\n    task.status = status;\n    return task;\n  }\n```\n\n## 상태 업데이트 확인하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ndto 폴더에 update-task-status.dto를 추가해주세요.\n\n```js\nimport { IsEnum } from 'class-validator';\nimport { TaskStatus } from '../tasks.model';\n\nexport class UpdateTaskStatus {\n  @IsEnum(TaskStatus)\n  status: TaskStatus;\n}\n```\n\n컨트롤러\n\n```js\n@Patch('/:id/status')\nupdateTaskStatus(\n  @Param('id') id: string,\n  @Body() updateTaskStatusDto: UpdateTaskStatusDto,\n): Task {\n  const { status } = updateTaskStatusDto;\n  return this.tasksService.updateTaskStatus(id, status);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 검색을 위한 유효성 검사\n\ndto\n\n```js\nimport { IsEnum, IsOptional, IsString } from 'class-validator';\nimport { TaskStatus } from '../tasks.model';\n\nexport class GetTasksFilterDto {\n  @IsOptional()\n  @IsEnum(TaskStatus)\n  status?: TaskStatus;\n\n  @IsOptional()\n  @IsString()\n  search?: string;\n}\n```","ogImage":{"url":"/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png"},"coverImage":"/assets/img/2024-06-27-NestJSDataValidationandTransformation_0.png","tag":["Tech"],"readingTime":3},{"title":"초보 프로그래머가 흔히 저지르는 실수 10가지","description":"","date":"2024-06-27 17:48","slug":"2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer","content":"\n\n![이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png)  \n\n우선 한 가지 명백하게 말씀드리겠습니다. 당신이 초보 프로그래머라면, 이 기사는 당신이 저지르고 있는 실수로 인해 자책감을 느끼게 하려는 것이 아니라 오히려 그 실수에 대해 인식하게 하고, 그 실수의 징후를 알려주고, 피할 수 있도록 가르치려는 것입니다.  \n\n과거에 이런 실수들을 저도 했었고, 각각의 실수로부터 배웠습니다. 나 자신이 이를 피하도록 코딩 습관을 형성했어서 기쁩니다. 당신도 그렇게 해야 합니다.  \n\n이러한 실수들은 특정한 순서로 나열되어 있지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1) 계획 없이 코드 작성하기\n\n일반적으로 고품질의 쓰기 콘텐츠는 쉽게 만들어질 수 없습니다. 신중한 사고와 연구가 필요합니다. 고품질의 프로그램도 예외는 아닙니다.\n\n고품질의 프로그램을 작성하는 것은 흐름이 있는 과정입니다:\n생각하기. 연구하기. 계획하기. 쓰기. 확인하기. 수정하기.\n불행하게도 이에 대한 좋은 약어는 없습니다. 이 활동들의 적절한 양을 항상 거치도록 하는 습관을 만들어야 합니다.\n\n초보 프로그래머로서 내가 한 가장 큰 실수 중 하나는 많은 사고와 연구 없이 코드 작성을 곧바로 시작한 것입니다. 이 방법은 작은 독립형 응용프로그램에는 동작할 수 있겠지만, 큰 응용프로그램에는 큰 부정적인 영향을 미칩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 후회할 만한 말을 하기 전에 생각하는 것처럼, 후회할 만한 것을 코딩하기 전에도 생각해야 합니다. 코딩 또한 당신의 생각을 전달하는 방법이에요.\n\n요즘 가장 필요한 것, 현재 시스템에 어떻게 적합한 코드를 작성할지 조사하고 기존 코드를 읽고 작은 테스트 가능한 기능을 작성하는 계획을 세우는 것이 프로그래밍의 주된 부분입니다. 실제 코드를 작성하는 것은 전체 프로세스 중 약 10% 정도라고 볼 수 있어요.\n\n프로그래밍을 코드를 쓰는 것으로만 생각하지 마세요. 프로그래밍은 양육이 필요한 논리 기반의 창의력이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2) 코드를 작성하기 전에 계획을 너무 많이 세우지 마세요\n\n네. 코드를 작성하기 전에 계획을 세우는 것은 좋은 일이지만, 좋은 일도 너무 하면 해로울 수 있어요. 너무 많은 물도 독이 될 수 있어요.\n\n완벽한 계획을 찾지 마세요. 프로그래밍 세계에는 완벽한 계획이란 존재하지 않아요. 충분히 좋은 계획을 찾아보세요, 시작할 수 있는 것이요. 사실은, 당신의 계획은 변할 거예요, 하지만 좋았던 점은 코드에서 더 많은 명확성으로 이끄는 몇 가지 구조를 강요했던 것이죠. 너무 많은 계획은 단지 당신의 시간 낭비일 뿐이에요.\n\n작은 기능에 대한 계획만 얘기하고 있어요. 모든 기능을 한꺼번에 계획하는 건 단죄되어야 해요! 바로 폭포수 접근법이죠. 이것은 하나씩 완료되어야 할 명확한 단계가 있는 선형 계획 시스템을 뜻해요. 이러한 방식으로 얼마나 많은 계획이 필요한지 상상할 수 있죠. 이곳에서 얘기하고 있는 계획은 아니에요. 폭포수 접근법은 대부분의 소프트웨어 프로젝트에 적합하지 않아요. 복잡한 것은 현실에 대한 민첩한 적응을 통해 구현할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그램 개발은 민첩한 활동이어야 합니다. 폭포수 모델 계획에서는 상상조차 하지 못했을 기능을 추가하게 될 것입니다. 그리고 폭포수 모델 계획에서는 고려하지 못했던 이유로 인해 기능을 제거해야 할 때도 있을 것입니다. 버그를 수정하고 변화에 적응해야 합니다. 당신은 기민해야 합니다.\n\n하지만, 항상 다음 몇 가지 기능을 계획하세요. 이를 매우 신중하게 수행해야 합니다. 계획을 너무 적게 하거나 너무 많이 하는 것은 코드 품질에 해를 끼칠 수 있습니다. 코드 품질은 위험을 감수할 수 없는 요소입니다.\n\n# 3) 코드 품질의 중요성을 과소평가하기\n\n작성한 코드의 하나의 측면에만 집중할 수 있다면, 그것은 코드의 가독성이어야 합니다. 이해하기 어려운 코드는 쓰레기입니다. 심지어 재활용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 품질의 중요성을 절대 얕보지 마세요. 코딩을 구현을 전달하는 방법으로 생각해 보세요. 코더로서 귀하의 주요 업무는 작업 중인 해결책의 구현을 명확하게 전달하는 것입니다.\n\n프로그래밍에 관한 내가 좋아하는 명언 중 하나는 다음과 같습니다:\n\n\"우수한 조언이네요, 존!\"\n\n작은 것들조차 중요하다는 사실을 명심하세요. 예를 들어, 들여쓰기 및 대소문자 사용에 일관성이 없다면, 코드 작성 라이선스를 그냥 잃어버릴만 하다구요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이것은 \n  생각보다 훨씬 \n중요합니다.\n\n\n또 다른 간단한 것은 긴 줄의 사용입니다. 80자를 넘는 내용은 읽기가 훨씬 어렵습니다. if문 블록을 더 잘 보이게 하려면 동일한 줄에 긴 조건을 넣을 유혹을 느낄 수도 있습니다. 그렇게 하지 말아주세요. 80자 제한을 절대 넘지 마세요.\n\n이러한 간단한 문제들은 린팅 및 서식 지원 도구를 사용하여 쉽게 해결할 수 있습니다. JavaScript에서는 ESLint와 Prettier가 두 가지 우수한 도구로 완벽하게 작동합니다. 자신을 위해 항상 사용해보세요.\n\n다음은 코드 품질과 관련된 몇 가지 더 많은 실수입니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 함수나 파일에서 여러 줄을 사용하는 것은 좋은 습관이에요. 코드가 너무 길어지면 관리하기 힘들어지므로 작은 조각으로 나눠서 테스트하고 관리하세요. 제 개인적인 생각으로는 10줄 이상인 함수는 너무 길다고 생각해요. 하지만 이것은 대략적인 기준일 뿐이에요.\n\n- 부정문을 반복해서 사용하는 것은 피하세요. 그러지 말아주세요.\n\n- 변수 이름에 짧고 일반적인 이름을 사용하는 것도 좋지 않아요. 변수에는 명확하고 모호하지 않은 이름을 사용하세요.\n\n- 문자열이나 숫자를 하드코딩하는 것도 좋지 않아요. 고정된 값에 의존하는 로직을 작성하려면 상수에 값을 할당하고 의미 있는 이름을 지어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst answerToLifeTheUniverseAndEverything = 42;\n```\n\n- 간단한 문제 주변에서 더 많은 시간을 보내지 않기 위해 대충한 단축키와 해결책을 사용하지 마세요. 문제를 피하지 마세요. 현실에 직면하세요.\n\n- 더 긴 코드가 더 좋다고 생각하는 것. 대다수의 경우 더 짧은 코드가 더 나음. 코드를 더 읽기 쉽게 만드는 경우에만 더 긴 버전을 작성하세요. 예를 들어, 코드를 짧게 유지하기 위해 교묘한 한 줄 짜리 표현 및 중첩된 삼항 표현식을 사용하지 마세요. 또한 코드가 필요 이상으로 길어지지 않도록 의도적으로 만들지 마세요. 모든 프로그램에서 불필요한 코드를 삭제하는 것이 가장 좋습니다.\n\n- 조건 로직의 과도한 사용. 대부분의 경우 조건 로직이 필요하다고 생각하는 것은 없습니다. 모든 대안을 고려하고 가독성을 기준으로만 선택하세요. 측정할 수 없는 한 성능 최적화를 피하세요. 관련: Yoda 조건 및 조건 내 할당을 피하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4) 첫 번째 해결책 선택하기\n\n프로그래밍을 시작했을 때 나는 문제를 마주했을 때 해결책을 찾아낸 다음 즉시 그것을 실행해버렸던 것을 기억한다. 첫 번째로 발견한 해결책에 대한 복잡성과 잠재적 실패에 대해 생각하기 전에 즉시 구현을 서두르곤 했다.\n\n첫 번째 해결책은 유혹적일 수 있지만, 좋은 해결책은 일반적으로 발견된 모든 해결책을 의심하기 시작했을 때 얻어진다. 문제에 대해 여러 해결책을 고려할 수 없다면, 그것은 아마도 문제를 완전히 이해하지 못했다는 신호일 것이다.\n\n전문 프로그래머로서 여러분의 역할은 문제에 대한 해결책을 찾는 것이 아닙니다. 문제에 대한 가장 간단한 해결책을 찾는 것입니다. 여기서 \"간단\"하다는 것은 해결책이 제대로 작동하고 충분히 성능이 우수해야 하지만, 여전히 읽기, 이해 그리고 유지가 용이해야 한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5) 그만 두지 않기\n\n자주 인정하고 싶지 않았던 오류 중 하나는 처음에 발견한 것이 가장 간단한 방법이 아닐 것이라고 인식한 후에도 처음 방법을 계속 고수하는 것입니다. 이겢은 심리적으로 \"그만 두지 않기\" 마인드와 관련이 있을 것입니다. 대부분의 활동에서 가져야 할 좋은 마인드이지만 프로그래밍에는 해당되지 않습니다. 사실, 프로그래밍을 할 때 올바른 마인드는 일찍 실패하고 자주 실패하는 것입니다.\n\n해결책을 의심하기 시작하면, 그것을 버리고 문제를 다시 생각해보아야 합니다. 얼마나 그 해결책에 투자했든지 상관없이 말이죠. GIT 같은 소스 컨트롤 도구를 이용하면 쉽게 다양한 해결책을 시도할 수 있습니다. 그것을 활용하세요.\n\n# 6) 검색하지 않기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 경우에 보물 같은 시간을 낭비하면서 문제를 해결하려고 노력한 적이 많았어요. 그럴 때에는 먼저 구글에서 조사하는 게 더 현명한 선택이 되곤 해요.\n\n혈액순환이 잘 이루어지는 기술을 사용 중이지 않다면, 문제에 부딪혔을 때 누군가가 이미 같은 문제를 겪고 그에 대한 해결책을 찾았을 것입니다. 시간을 절약하고 먼저 구글링을 해보세요.\n\n가끔씩, 구글링을 하다가 여러분이 문제로 생각하고 있는 것이 실제로 문제가 아니라는 것을 알게 되고, 고쳐야 하는 게 아니라 받아들여야 하는 것이라는 사실을 깨닫게 될 때가 있어요. 문제에 대한 해결책을 선택하는 데 필요한 모든 정보를 알고 있다고 가정하지 마세요. 구글은 여러분에게 놀라운 정보를 제공해줄 거예요.\n\n하지만, 구글링할 때 주의해야 해요. 초보자의 특징 중 하나는 다른 사람의 코드를 이해하지 않고 그대로 복사해 사용하는 것입니다. 그 코드가 문제를 올바르게 해결할 수 있더라도, 완전히 이해하지 못하는 코드는 사용하지 말아야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n창의적인 코더가 되고 싶다면, 자신이 무엇을 하고 있는지 알고 있다고 생각하지 마세요.\n\n# 7) 캡슐화를 사용하지 않기\n\n이 포인트는 객체지향 패러다임을 사용하는 것과는 관련이 없습니다. 캡슐화 개념의 사용은 항상 유용합니다. 캡슐화를 사용하지 않으면 유지보수하기 어려운 시스템으로 이어지는 경우가 많습니다.\n\n어플리케이션에서 특정 기능은 그것을 처리하는 곳이 딱 하나 있어야 합니다. 보통 이것은 단일 객체의 책임입니다. 이 객체는 어플리케이션의 다른 객체가 사용하는 데 절대적으로 필요한 것만을 노출해야 합니다. 이는 비밀스러울 필요가 있는 것이 아니라 애플리케이션의 다른 부분 간 의존성을 줄이는 개념에 관한 것입니다. 이러한 규칙을 따르면 클래스, 객체 및 함수의 내부를 안전하게 변경할 수 있으며 큰 규모로 문제를 일으킬 걱정 없이 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n논리와 상태의 개념적 단위는 각각 고유한 클래스를 가져야 합니다. 여기서 클래스란, 일종의 청사진 템플릿을 의미합니다. 이는 실제 Class 객체이거나 Function 객체일 수 있습니다. 이를 Module이나 Package로도 식별할 수 있습니다.\n\n논리 클래스 내에서 자체적인 작업 조각들은 각자의 메소드를 가져야 합니다. 메소드는 한 가지 일을 잘 처리해야 합니다. 비슷한 클래스는 동일한 메소드 이름을 사용해야 합니다.\n\n초보 프로그래머로서, 항상 새로운 클래스를 시작하는 직감을 가지지 못했고, 무엇이 독립적일 수 있는지 식별하는 데 실패하기도 했습니다. 만약 함께 속하지 않는 여러 요소들을 함께 모아 놓은 \"Util\" 클래스를 보게 된다면, 이는 초보자 코드의 징후입니다. 간단한 변경을 하고 나서 이 변경이 파급 효과를 일으켜 다른 곳에 많은 변경이 필요하다고 발견한다면, 이 역시 초보자 코드의 징후입니다.\n\n클래스에 메소드를 추가하거나 메소드에 더 많은 책임을 추가하기 전에, 여러분의 직감을 생각하고 의문을 제기해야 합니다. 시간이 필요합니다. 이를 건너뛰지 마시고, 나중에 리팩토링할 것이라고 생각하지 마세요. 처음부터 올바르게 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 중요한 아이디어는 코드가 높은 응집도와 낮은 결합도를 갖는 것이 좋다는 것입니다. 이는 관련된 코드를 함께 유지하고(한 클래스 안에) 서로 다른 클래스 간의 의존성을 줄이는 것을 의미하는 멋진 용어일 뿐입니다.\n\n## 8) 알 수 없는 부분을 위한 계획\n\n자신이 작성하고 있는 솔루션 이상으로 생각하는 것이 종종 유혹적일 수 있습니다. 코드를 작성할 때마다 다양한 상황이 머릿속에 떠오르게 됩니다. 이것은 엣지 케이스 테스트에 좋은 것이지만 잠재적인 요구 사항으로 사용하는 것은 바람직하지 않습니다.\n\n이러한 '만약' 상황들이 어느 주요 범주에 속하는지 식별해야 합니다. 오늘 필요 없는 코드는 작성하지 마십시오. 미래를 위한 계획을 세우지 마십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래에 필요할 것 같아서 기능을 작성하는 것은 그저 잘못된 방법이에요. 그러지 마세요.\n\n당신이 현재 구현 중인 해결책을 위해 필요한 최소한의 코드만 작성하세요. 예외 상황은 다루되 예외적인 기능은 추가하지 마세요.\n\n# 9) 올바른 데이터 구조를 사용하지 않기\n\n면접 준비를 할 때 초보 프로그래머들은 보통 알고리즘에 너무 많은 초점을 둡니다. 필요할 때 좋은 알고리즘을 식별하고 사용하는 것은 좋지만, 그것들을 암기하는 것이 당신의 프로그래밍 천재성에 기여하지는 않을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 언어에서 사용할 수 있는 다양한 데이터 구조의 강점과 약점을 외우는 것은 분명히 여러분을 더 좋은 개발자로 만들 것입니다.\n\n잘못된 데이터 구조를 사용하는 것은 '신입코드입니다'라고 크고 강하게 밝힌 대형 게시판 같은 것입니다.\n\n본 글은 데이터 구조에 대해 가르치려는 것이 아니지만 간단한 예를 몇 가지 언급하겠습니다:\n\n- 레코드 관리에 배열 대신 객체(맵)을 사용하는 것\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 흔한 데이터 구조 오류는 레코드 목록을 관리할 때 리스트 대신 맵을 사용하는 것입니다. 네, 레코드 목록을 관리할 때는 맵을 사용해야 합니다.\n\n각 레코드에 식별자가 있고 이를 사용하여 해당 레코드를 찾는 경우에 대해 이야기하는 것이며 스칼라 값에 대한 목록을 사용하는 것은 괜찮으며 주로 값을 목록에 \"추가\"하는 것이 중점이라면 더 나은 선택입니다.\n\nJavaScript에서 가장 일반적인 목록 구조는 배열이며 가장 일반적인 맵 구조는 객체입니다(현대 JavaScript에는 맵 구조도 있습니다).\n\n레코드를 관리하기 위해 리스트 대신 맵을 사용하는 것은 종종 잘못된 방법입니다. 이 점은 주로 큰 컬렉션에 대한 이야기이지만, 저는 그냥 항상 이를 준수하는 것이 좋다고 말할 것입니다. 이것이 중요한 이유는 식별자를 사용하여 레코드를 조회할 때 맵이 리스트보다 훨씬 빠르기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n— 스택을 사용하지 않음\n\n재귀 형태의 코드를 작성할 때는 항상 간단한 재귀 함수를 사용하고 싶은 유혹이 있습니다. 그러나 특히 단일 스레드 환경에서 재귀 코드를 최적화하는 것은 어렵습니다.\n\n재귀 코드를 최적화하는 것은 재귀 함수가 무엇을 반환하는지에 따라 달라집니다. 예를 들어, 자신을 두 번 이상 호출하는 재귀 함수를 최적화하는 것은 자신을 한 번 호출하는 재귀 함수를 최적화하는 것보다 훨씬 어렵습니다.\n\n초보자로서 우리가 종종 간과하는 것은 재귀 함수를 사용하는 대안이 있다는 점입니다. 단순히 Stack 구조를 사용할 수 있습니다. Stack에 함수 호출을 직접 넣고, 호출을 되돌아가야 할 준비가 되면 이를 꺼내기 시작하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 10) 기존 코드를 더 나빠지게 만들기\n\n다음과 같이 엉망진창인 방을 받았다고 상상해보세요:\n\n![방 이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_1.png)\n\n그리고 그 방에 물건을 하나 추가해야 한다고 요청받았다고 상상해보세요. 이미 방이 큰 난잡한 상태이기 때문에 물건을 어디든 넣을 수 있을 것입니다. 몇 초만에 작업을 끝낼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지저분한 코드로 그렇게 하지 마십시오. 더 안 좋아지도록 만들지 마세요! 언제나 코드가 좀 더 깨끗하게 유지되도록 해야 합니다.\n\n위 방에 대한 올바른 작업은 새 항목을 올바른 위치에 배치하기 위해 필요한 것을 청소하는 것입니다. 예를 들어, 옷장에 넣어야 하는 의류라면 해당 옷장으로 가는 길을 비워야 합니다. 이것이 작업을 올바르게 수행하는 일의 일부입니다.\n\n일반적으로 코드를 더 복잡하게 만드는 몇 가지 잘못된 실천 방식(완전한 목록은 아님)은 다음과 같습니다:\n\n- 코드 복제. 코드 일부를 복사하여 그 뒤에 한 줄을 변경하면 코드를 복제하고 더 큰 혼란을 초래합니다. 방금 언급한 지저분한 방 예제의 맥락에서, 이것은 가변 높이의 새 의자에 투자하는 대신 더 낮은 베이스의 다른 의자를 소개하는 것과 같습니다. 언제나 추상화 개념을 기억하고 가능할 때 사용해야 합니다.\n- 구성 파일을 사용하지 않음. 다른 환경이나 다른 시기에 달라질 수 있는 값을 사용해야 한다면 해당 값은 구성 파일에 속합니다. 코드의 여러 위치에서 사용해야 하는 값이라면 해당 값은 구성 파일에 속합니다. 새 값이 코드에 도입될 때 이 질문을 항상 스스로에게 물어보십시오: 이 값은 구성 파일에 속하는가? 대답은 아마도 예일 것입니다.\n- 불필요한 조건문 및 임시 변수 사용. 매 if문은 최소 두 번 테스트해야 하는 논리 분기입니다. 가독성을 희생하지 않고 조건문을 피할 수 있는 경우 피해야 합니다. 이에 대한 주요 문제는 다른 함수를 도입하는 대신 함수에 분기 논리를 확장하는 것입니다. if문이나 새 함수 변수가 필요하다고 생각할 때마다 스스로에게 이 질문을 던져보십시오: 코드를 올바른 수준에서 수정하고 있는 것인가, 아니면 문제를 보다 높은 수준에서 생각해야 하는 것인가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불필요한 if문에 대해 얘기해보겠습니다. 다음 코드를 살펴보세요:\n\n```js\nfunction isOdd(number) {\n  if (number % 2 === 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n```\n\n위의 isOdd 함수에는 몇 가지 문제가 있지만 가장 눈에 띄는 문제를 알 수 있나요?\n\n이 함수는 불필요한 if문을 사용하고 있습니다. 다음은 동등한 코드입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\nfunction isOdd(number) {\n  return (number % 2 === 1);\n};\n```\n\n# 11) 당연한 것에 대한 코멘트 작성하기\n\n내가 경험적으로 알게 된 것은 가능한한 코멘트를 쓰지 않는 것이 좋다는 것이다. 대부분의 코멘트들은 코드 안에 더 명확한 이름으로 대체될 수 있다.\n\n예를 들어, 다음 코드 대신에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이 함수는 배열에서 홀수만 더합니다\nconst sum = (val) =\u003e {\n  return val.reduce((a, b) =\u003e {\n    if (b % 2 === 1) { // 현재 숫자가 홀수인 경우\n      a+=b;            // 현재 숫자를 누산기에 더합니다\n    }\n    return a;          // 누산기를 반환합니다\n  }, 0);\n};\r\n```\n\n같은 코드를 다음과 같이 주석 없이 작성할 수도 있습니다:\n\n```js\r\nconst sumOddValues = (array) =\u003e {\n  return array.reduce((accumulator, currentNumber) =\u003e {\n    if (isOdd(currentNumber)) { \n      return accumulator + currentNumber;\n    }\n    return accumulator;\n  }, 0);\n};\r\n```\n\n함수와 인수에 더 나은 이름을 사용하면 대부분의 주석이 필요 없어집니다. 주석을 작성하기 전에 이 사실을 염두에 두세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 때로는 코드에 명확성을 더할 수 있는 유일한 방법이 주석을 통한 설명일 때가 있습니다. 이때는 이 코드 대신 이 코드를 왜 사용했는지에 대한 질문에 대답할 수 있도록 주석을 작성해야 합니다.\n\n코드를 명확히 설명하기 위해 '무엇을 하는지'가 아닌 '왜 이 코드를 사용했는지'에 대한 질문에 대답하기 위해 주석을 작성해야 합니다. 코드를 명확히 설명하려는 유혹이 강하다면 당연한 것을 가리키지 않도록 주의하세요. 아래에 코드에 소음만 추가하는 쓸데없는 주석 예시가 있습니다:\n\n```js\n// 변수를 만들고 0으로 초기화합니다\nlet sum = 0;\n// 배열을 루프합니다\narray.forEach(\n  // 배열의 각 숫자에 대해\n  (number) =\u003e {\n    // 현재 숫자를 합계 변수에 더합니다\n    sum += number;\n  }\n);\n```\n\n그런 프로그래머가 되지 마세요. 그러한 코드를 받아들이지 마세요. 이와 같은 주석을 다루어야 할 때 이런 주석을 제거하세요. 가장 중요한 것은 이런 주석을 쓰는 프로그래머들에게 그것이 얼마나 나쁜지 깨달게 하는 것입니다. 위와 같은 주석을 쓰는 프로그래머를 고용하고 있다면 이 문제가 실제로 그들이 일자리를 잃을 수 있음을 알려주세요. 그래, 그 정도로 심각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 12) 테스트 코드 작성하지 않기\n\n이 포인트를 간단하게 유지하려고 합니다. 만약 당신이 전문 프로그래머라고 생각하고 그 생각으로 인해 테스트를 하지 않고 코드를 작성하는 것에 자신감이 생긴다면, 그것은 내 기준에서는 초보자 입니다.\n\n코드에 테스트를 작성하지 않는다면, 아마도 다른 방법으로 프로그램을 수동으로 테스트하고 있을 것입니다. 웹 애플리케이션을 개발 중이라면, 코드 몇 줄마다 애플리케이션을 새로고침하거나 상호 작용할 것입니다. 저도 그렇게 합니다. 코드를 수동으로 테스트하는 것에는 문제가 없습니다. 그러나 코드를 수동으로 테스트하여 어떻게 자동으로 테스트할지 알아내야 합니다. 애플리케이션과 상호 작용을 성공적으로 테스트했다면, 더 많은 코드를 프로젝트에 추가할 때 동일한 상호 작용을 자동으로 수행할 수 있도록 코드를 작성하라.\n\n당신은 사람입니다. 각 코드 변경 후 모든 이전에 성공했던 유효성 검사를 테스트하는 것을 잊을 것입니다. 컴퓨터에게 그 일을 맡기세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가능하다면 코드를 작성하여 이를 충족시키기 전에 유효성을 추측하거나 설계해 보는 것이 좋습니다. 테스트 주도 개발(TDD)은 그냥 화려한 날조가 아닙니다. 기능에 대해 생각하는 방식에 긍정적인 영향을 미치고 더 나은 설계를 고안하는 데 도움이 됩니다.\n\nTDD가 모두에게 적합한 것은 아니며 모든 프로젝트에 잘 작동하지 않지만, 가능하다면 (일부분이라도) 활용할 수 있다면 꼭 해보세요.\n\n# 13) 작동한다고 해서 옳다고 가정하기\n\nsumOddValues 기능을 구현하는 이 함수를 살펴보세요. 어떤 문제가 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst sumOddValues = (array) =\u003e {\n  return array.reduce((accumulator, currentNumber) =\u003e {\n    if (currentNumber % 2 === 1) { \n      return accumulator + currentNumber;\n    }\n    return accumulator;\n  }, 0);\n};\n \n \nconsole.assert(\n  sumOddValues([1, 2, 3, 4, 5]) === 9\n);\n```\n\n단언이 통과되었습니다. 즐거운 코딩하세요! 뭔가 빠진 부분이 있어요. 몇가지 문제를 설명해 드릴게요:\n\n— 문제 #1: 빈 입력에 대한 처리가 없어요. 함수를 인자 없이 호출하면 어떻게 동작해야 할까요? 현재 상태에서는 해당 경우에 함수의 구현이 노출되는 오류가 발생합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTypeError: 정의되지 않은 프로퍼티 'reduce'를 읽을 수 없습니다.\n```\n\n\u003cimg src=\"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_2.png\" /\u003e\n\n일반적으로 이는 두 가지 주요 이유로 나쁜 코드의 t수입니다.\n\n- 함수를 사용하는 사용자는 구현 세부 정보를 알아서는 안 됩니다.\n- 사용자에게 도움이 되지 않는 오류입니다. 사용자의 경우 함수가 단순히 작동하지 않았음을 알게 되는 것입니다. 그러나 오류가 사용 문제에 대해 더 명확하게 설명되면, 함수를 잘못 사용했음을 알 수 있습니다. 예를 들어, 함수가 이렇게 사용자 정의 예외를 throw하도록 선택할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTypeError: 빈 목록에 대해 함수를 실행할 수 없습니다.\n```\n\n에러를 발생시키는 대신, 빈 입력을 무시하고 0의 합계를 반환하도록 함수를 설계해야 할지도 모릅니다. 그래도 이 경우를 위해 뭔가를 해야 합니다.\n\n— 문제 #2: 잘못된 입력을 처리하는 방법이 없습니다. 배열이 아닌 문자열, 정수 또는 객체 값을 받았을 때 함수를 호출할 경우 어떻게 해야 할까요?\n\n이제 함수가 던지는 에러를 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsumOddValues(42);\n타입 에러: 배열.reduce는 함수가 아닙니다\n```\n\n그건 안좋은 일이에요. 왜냐하면 배열.reduce는 분명히 함수인데 말이에요!\n\n함수의 인자를 array로 이름을 지었기 때문에, 함수를 호출할 때 넘겨주는 값(예를 들어 위 예시의 42)은 함수 내에서 array로 라벨링됩니다. 이 에러는 실질적으로 42.reduce가 함수가 아니라는 걸 의미하죠.\n\n혼란스럽다고 느껴지시나요? 아마 더 도움이 될만한 에러 메시지는 다음과 같았으면 좋겠네요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTypeError: 42은(는) 배열이 아니야, 친구야.\n```\n\n문제 #1과 #2는 때때로 엣지 케이스라고 불리기도 합니다. 이들은 고려해야 할 일반적인 엣지 케이스들입니다. 하지만 생각해야 할 덜 명백한 엣지 케이스들도 보통 있습니다. 예를 들어 음수를 사용했을 때 어떻게 될까요?\n\n```js\nsumOddValues([1, 2, 3, 4, 5, -13]) // =\u003e 여전히 9\n```\n\n음수인 -13은 홀수입니다. 이 함수가 가져야 하는 동작인가요? 에러를 던져야 하나요? 음수를 합계에 포함해야 하나요? 아니면 현재와 같이 음수를 무시해야 하나요? 아니면 함수의 이름이 sumPositiveOddNumbers로 지어져야 하는지를 깨닫게 될지도 모릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제에 대한 결정은 쉽습니다. 더 중요한 점은, 당신의 결정을 문서화하기 위해 테스트 케이스를 작성하지 않으면, 함수를 유지보수하는 사람들은 당신이 음수를 무시한 것이 고의적인 것인지 버그인지 알 수 없을 겁니다.\n\n— 문제 #3: 유효한 여러 경우에 대해 테스트하지 않았습니다. 경계 경우를 잊고, 이 함수는 다루지 못하는 합리적이고 매우 간단한 경우가 있습니다:\n\n```js\nsumOddValues([2, 1, 3, 4, 5]) // =\u003e 11\n```\n\n위에서 2가 합산됐지만 합산되지 말아야 하는 경우입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책은 간단합니다. reduce 함수는 어큐뮈레이터의 초기값으로 사용될 두 번째 매개변수를 받습니다. 만약 해당 인수가 제공되지 않았다면(위의 코드처럼), reduce는 컬렉션의 첫 번째 값이 어큐뮈레이터의 초기값으로 사용됩니다. 이것이 테스트 케이스에서 위의 첫 번째 짝수 값이 합에 포함된 이유입니다.\n\n당신이 이 문제를 바로 발견했거나 코드가 작성된 시점에 눈치챘을지라도, 이 문제를 드러내는 이 테스트 케이스는 처음부터 여러분의 테스트에 포함되어야 했었습니다. 그리고 이 테스트와 함께, 전부 짝수인 숫자들, 0이 포함된 목록, 그리고 빈 목록과 같은 다른 많은 테스트 케이스들도 포함되어야 합니다.\n\n만약 여러분이 많은 경우를 다루지 않는 최소한의 테스트를 본다면 또는 경계 상황을 무시한다면, 그것은 초보자 코드의 또 다른 신호입니다.\n\n# 14) 기존 코드 의심하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상당한 분량의 코드를 혼자서 작업하지 않는 한, 당신이 삶 속에서 어떤 종류의 바보 같은 코드와 마주칠 가능성은 의심할 여지가 없습니다. 초심자들은 그것을 인식하지 못하며, 그것이 작동하는 것처럼 보이고 오랜 시간 동안 코드베이스의 일부이기 때문에 좋은 코드라고 가정합니다.\n\n더 나쁜 점은 나쁜 코드가 바람직하지 못한 방법을 사용한다면 초심자는 그 바람직하지 못한 방법을 코드베이스 다른 곳에서 반복하기 쉽습니다. 왜냐면 그들은 그것이 좋은 코드로 생각해서 배웠기 때문입니다.\n\n어떤 코드는 나빠 보일 수 있지만, 그것 주변에 특별한 조건이 있어 개발자가 그렇게 작성할 수 밖에 없었을 수 있습니다. 초심자에게 그 조건에 대해 가르치고 코드의 작성 방식에 대해 설명하는 자세한 주석이 필요한 좋은 장소입니다.\n\n초심자로서 이해하지 못하는 문서화되지 않은 코드는 나쁜 것이 될 가능성이 있다고 가정해야 합니다. 의문을 가져 보세요. 그것에 대해 질문하세요. git blame을 사용해 보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 그 코드의 작성자가 오래 전에 사라졌거나 기억하지 못한다면, 그 코드를 조사하고 이해하려고 노력하세요. 코드를 완전히 이해한 후에 그것이 좋은지 나쁜지에 대해 의견을 형성할 수 있습니다. 이 전에는 가정하지 마세요.\n\n# 15) 최적의 방법에 대해 집착하기\n\n\"최적의 방법\"이라는 용어는 실제로 해롭다고 생각합니다. 이것은 더 이상의 연구가 필요하지 않다는 것을 시사합니다. 이게 바로 최고의 방법입니다. 의문을 제기하지 마세요!\n\n최적의 방법은 없습니다. 오늘을 위한 좋은 방법이 있을 뿐이며, 이 프로그래밍 언어에 적합한 것이 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래밍에서 이전에 최선의 방법으로 인식되었던 것 중 일부는 오늘날 나쁜 방법으로 레이블이 지정됩니다. \n\n충분한 시간을 투자한다면 더 나은 방법을 항상 찾을 수 있습니다. 최상의 방법에 대해 걱정하지 말고 자신의 재능에 집중하세요.\n\n어딘가에서 읽은 인용구나 다른 사람이 그렇게 한 것을 보거나 누군가가 이것이 최선의 방법이라고 말한 대로 무언가를 하지 마세요. 이 글에서 제공하는 모든 조언도 이에 해당합니다! 모든 것을 의심하고 모든 이론에 도전하고 가능한 모든 옵션을 알아보고 교육된 결정을 내리세요.\n\n# 16) 성능에 대한 집착\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래밍은 도널드 누스가 위 문장을 쓴 이후에 상당히 변화했지만, 내 생각에는 지금도 유익한 조언으로 여겨집니다.\n\n이에 대해 기억해야 할 좋은 규칙은 다음과 같습니다: 코드로 의심되는 성능 문제를 측정할 수 없다면 최적화를 시도하지 말아야 합니다.\n\n코드를 실행하기 전에 최적화를 하려고 한다면, 아마 너무 이르게 최적화하고 있는 것일 수 있습니다. 또한 투자한 시간이 완전히 필요하지 않은 최적화에 사용되고 있는 가능성도 큽니다.\n\n물론 새 코드를 도입하기 전에 항상 고려해야 할 몇 가지 명백한 최적화가 있습니다. 예를 들어, Node.js에서 이벤트 루프를 즉시 차단하지 않거나 호출 스택을 차단하지 않는다는 것은 매우 중요합니다. 이것은 항상 염두에 두어야 할 초기 최적화의 한 예입니다. 자신에게 물어보세요: 고민 중인 코드가 호출 스택을 차단할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기존 코드에 대한 어떠한 명확하지 않은 최적화도 측정 없이 진행된다면 해로울 수 있으며 피해야 합니다. 당신이 생각하는 최적화가 성능 향상으로 작용할 것이라고 생각되더라도 예상치 못한 새로운 버그의 원인이 될 수 있습니다.\n\n측정되지 않은 성능 문제에 대한 최적화에 시간을 낭비하지 마십시오.\n\n# 17) 최종 사용자 경험에 목표를 두지 않기\n\n어플리케이션에 기능을 추가하는 가장 쉬운 방법은 무엇인가요? 자신의 관점에서 살펴보거나 현재 사용자 인터페이스에 어떻게 맞추는지를 고려해보는 것입니다. 그렇죠? 만약 사용자로부터 일종의 입력을 받는 기능을 추가해야 한다면, 이미 있는 양식에 추가하세요. 만약 페이지에 링크를 추가해야 한다면, 이미 있는 중첩된 링크 메뉴에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 개발자가 되지 마세요. 자신을 사용자의 입장에 놓아 생각해보세요. 특정 기능의 사용자가 필요로 하는 것과 그들이 어떻게 행동할지 상상해봅니다. 기능이 사용자들이 찾고 사용하기 쉽도록 만드는 방법을 고민하며, 그 기능이 어떻게 찾아지고 사용되는지에 대해 고민하지 않고 어떻게든 애플리케이션에 그 기능을 간단히 구현할 방법에만 집중하지 않습니다.\n\n# 18) 일에 적합한 올바른 도구를 고르지 않기\n\n모든 사람은 프로그래밍과 관련된 작업을 돕기 위해 사용하는 즐겨찾는 도구 목록을 갖고 있습니다. 일부 도구는 훌륭하고 일부는 나쁘지만 대부분의 도구는 한 가지 특정한 일에 탁월하며 다른 많은 작업에는 그리 탁월하지 않습니다.\n\n망치는 벽에 못을 박는 데 탁월한 도구이지만 나사를 조이는 데는 최악의 도구입니다. \"망치를 좋아한다\"는 이유로 나사에 망치를 사용하지 마세요. \"아마존에서 5.0 사용자 평가를 받은 가장 인기 있는 망치\"라는 이유로 나사에 망치를 사용하지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도구의 인기에 의존하는 것보다 문제에 얼마나 잘 맞는지가 더 중요하다는 건 진정한 초보자의 특징입니다.\n\n이러한 점에 대한 문제 중 하나는 특정 작업에 \"더 나은\" 도구를 아마 알지 못할 것이라는 것입니다. 현재 지식 내에서 특정 도구가 알려진 최고의 도구일 수 있습니다. 그러나 다른 옵션들과 비교했을 때 상위 목록에 들지 않을 수도 있습니다. 사용 가능한 도구에 익숙해지고 새로운 도구에 대해 열린 마음을 유지해야 합니다.\n\n일부 코더는 새로운 도구를 사용하기를 거부합니다. 그들은 기존 도구에 익숙하고 아마도 새로운 것을 배우고 싶어하지 않을 것입니다. 그 점을 이해하고 공감할 수 있지만, 단순히 잘못된 것입니다.\n\n원시 도구로 집을 짓고 맘편히 시간을 들일 수도 있지만, 좋은 도구에 시간과 돈을 투자하고 훨씬 빠르게 더 나은 집을 짓을 수도 있습니다. 도구는 계속 발전하고 있으며, 그에 대해 배우고 사용하는 데 편안해지는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 19) 코드 문제를 이해하지 못하면 데이터 문제가 발생할 수 있습니다\n\n프로그램의 중요한 측면 중 하나는 종종 어떤 형태의 데이터를 관리하는 것입니다. 프로그램은 새로운 레코드를 추가하고 이전 레코드를 삭제하며 다른 레코드를 수정하는 인터페이스가 될 것입니다.\n\n프로그램의 코드에 있는 가장 작은 버그도 관리하는 데이터에 대한 예측할 수 없는 상태로 이어질 것입니다. 특히 데이터에 대한 모든 유효성 검사가 동일한 버그가 있는 프로그램을 통해 수행된다면 더욱 그러합니다.\n\n초보자들은 코드-데이터 관계에 대한 연결을 즉시 이해하지 못할 수 있습니다. 중요하지 않은 기능 X가 작동하지 않아도 좋다고 느낄 수 있습니다. 문제는 버그 있는 코드가 초기에는 명확하지 않은 데이터 무결성 문제를 계속 도입할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 나쁜 것은 버그를 수정하는 코드를 배송할 때, 이 버그로 인해 발생한 미묘한 데이터 문제를 해결하지 않으면 \"회복 불가능 수준\"으로 갈수록 데이터 문제가 더 쌓일 것입니다.\n\n이런 문제에서 자신을 보호하는 방법은 무엇일까요? 여러 계층의 데이터 무결성 유효성 검사를 간단히 사용할 수 있습니다. 단일 사용자 인터페이스에 의존하지 마세요. 프론트엔드, 백엔드, 네트워크 통신 및 데이터베이스에 대해 유효성을 생성하세요. 이것이 선택 사항이 아니라면, 적어도 데이터베이스 수준의 제약을 사용해야 합니다.\n\n데이터베이스 제약을 숙지하고 데이터베이스에 열과 테이블을 추가할 때 모두 사용하세요:\n\n- 열의 NOT NULL 제약은 해당 열에 대해 NULL 값이 거부됨을 의미합니다. 애플리케이션이 해당 필드에 대한 값의 존재를 가정한다면, 데이터베이스에서 Source를 Not Null로 정의해야 합니다.\n- 열의 UNIQUE 제약은 해당 열이 전체 테이블 전체에서 중복 값을 가질 수 없음을 의미합니다. 예를 들어, 사용자 테이블의 사용자 이름이나 이메일 필드에 좋습니다.\n- CHECK 제약은 데이터가 수락되려면 true로 평가되어야 하는 사용자 정의 식입니다. 예를 들어, 값이 0과 100 사이여야 하는 보통 백분율 열이 있는 경우, 체크 제약을 사용하여 강제할 수 있습니다.\n- PRIMARY KEY 제약은 열의 값이 Not-Null이며 고유해야 함을 의미합니다. 아마 이것을 사용하고 있을 것입니다. 데이터베이스의 각 테이블은 레코드를 식별하기 위한 기본 키를 가져야합니다.\n- FOREIGN KEY 제약은 열의 값이 일반적으로 기본 키인 다른 테이블 열의 값과 일치해야 함을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 무결성과 관련된 또 다른 초보자 문제는 트랜잭션 관점에서 생각하지 않는 부분입니다. 여러 작업이 동일한 데이터 원본을 변경해야 하고 서로에게 의존하는 경우, 이러한 작업은 반드시 롤백할 수 있는 트랜잭션으로 묶여야 합니다. 그렇게 해야 한 작업이 실패할 경우 롤백할 수 있습니다.\n\n# 20) 바퀴를 다시 발명하기\n\n이것은 tricky 한 포인트입니다. 프로그래밍에서 일부 바퀴는 단순히 다시 발명할 가치가 있습니다. 프로그래밍은 명확하게 정의된 도메인이 아닙니다. 너무 많은 변화가 너무 빨리 일어나고 새로운 요구사항이 어떤 팀도 처리할 수 있는 것보다 더 빨리 도입됩니다.\n\n예를 들어, 하루 시간에 따라 다른 속도로 회전하는 바퀴가 필요한 경우, 우리가 알고 사랑하는 바퀴를 맞춤화하는 대신, 다시 생각할 필요가 있을 수 있습니다. 그러나 전혀 다른 디자인으로 사용되지 않는 바퀴가 필요하지 않다면, 바퀴를 다시 발명하지 마세요. 그냥 그 바퀴를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔 필요한 휠의 브랜드를 선택하는 것은 다양한 옵션이 있어 쉬운 일이 아닙니다. 사전 조사를 하고 살기 전에 시도해보세요! 소프트웨어 \"휠\"의 멋진 점은 대부분의 것들이 무료이며 내부 디자인을 볼 수 있습니다. 내부 디자인 품질에 따라 코딩 휠을 쉽게 판단할 수 있습니다. 가능하다면 오픈 소스 휠을 사용하세요. 오픈 소스 패키지는 쉽게 디버그하고 수정할 수 있습니다. 또한 쉽게 대체할 수도 있습니다. 또한 내부에서 용이하게 지원하기도 쉽습니다. \n\n하지만, 휠이 필요한 경우, 전체 새 차를 사서 유지 중인 차를 위에 올리지 마세요. 라이브러리 전체를 가져올 필요가 없는 경우에도 함수 두 개를 사용하려고 전체 라이브러리를 포함하지 마세요. 이와 관련된 좋은 예는 JavaScript의 lodash 라이브러리입니다. 배열을 섞기만 하려면 섞기 메소드만 가져와 사용하세요. 전체 lodash 라이브러리를 가져오지 마세요.\n\n# 21) 코드 리뷰에 대한 부정적인 태도 가지기\n\n코딩 초보자들의 한 가지 특징은 코드 리뷰를 비판으로만 바라본다는 것입니다. 코드 리뷰를 싫어합니다. 감사하지도 않습니다. 때로는 두렵기까지 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 완전히 잘못됐어요. 만약 그렇게 느낀다면, 당신도 이 태도를 곧바로 바꿔야 해요. 모든 코드 리뷰를 학습 기회로 여기세요. 환영하고 감사드리세요. 거기서 배우세요. 그리고 가장 중요한 건, 누군가가 당신에게 무언가 가르칠 때 그들에게 고맙다고 말해주세요.\n\n당신은 영원한 코드 학습자에요. 그 사실을 받아들여야 해요. 대부분의 코드 리뷰는 당신이 몰랐던 것을 가르쳐 줄 거에요. 그걸 학습 자원으로 분류하세요.\n\n가끔 리뷰어가 틀릴 때가 있고, 그때는 당신이 그들에게 뭔가를 가르쳐 줘야 할 차례일 거에요. 그러나 만약 코드만으로는 명백하지 않은 무언가를 가르쳐 줘야 한다면, 아마도 당신의 코드를 수정해야 할지도 모릅니다. 그리고 어쨌든 리뷰어에게 뭔가를 가르쳐 줘야 한다면, 그것이 바로 프로그래머로서 할 수 있는 가장 보람 있는 활동 중 하나인 것을 알아두세요.\n\n# 22) 소스 컨트롤 사용하지 않기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신입들은 때때로 좋은 소스/변경 관리 시스템이 갖는 힘을 과소평가합니다. 여기서 말하는 '좋은 시스템'은 Git을 의미합니다.\n\n소스 관리는 다른 사람들이 공유하고 발전시키기 위해 변경 사항을 푸시하는 것에 그치는 것이 아닙니다. 그것보다 훨씬 큰 의미가 있습니다. 소스 관리는 명확한 히스토리에 관한 것입니다. 코드는 의심 받을 수 있고 해당 코드의 진전 기록은 어려운 질문 중 일부에 대한 답을 찾을 수 있도록 도와줍니다. 그래서 우리는 커밋 메시지에 중요성을 둡니다. 이것은 당신의 구현을 전달할 또 다른 수단이며, 작은 커밋으로 사용하면 코드의 미래 유지보수자가 코드가 현재 상태에 도달한 과정을 이해하는 데 도움이 됩니다.\n\n자주 커밋하고 일찍 커밋하고, 일관성을 위해 커밋 제목에 현재형 동사를 사용해주세요. 메시지는 자세하게 작성해주시되, 요약 정보여야 합니다. 메시지가 몇 줄을 넘어가면, 그 커밋이 너무 길다는 신호일 수 있습니다. 리베이스를 사용하세요!\n\n커밋 메시지에 불필요한 정보를 포함하지 마세요. 예를 들어, 추가된, 수정된, 삭제된 파일들을 커밋 요약에 나열하지 마세요. 해당 목록은 커밋 객체 자체에 존재하며 몇 가지 Git 명령 인자를 사용하여 쉽게 표시할 수 있습니다. 요약 메시지에는 단순히 노이즈가 될 뿐입니다. 어떤 팀들은 각 파일 변경 별로 다른 요약을 가지는 것을 선호하지만, 그것은 커밋이 너무 크다는 또 다른 신호로 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스 제어는 발견 가능성과 관련이 있어요. 함수를 만나게 되면 그 함수에 대해 필요성이나 설계를 의심하기 시작할 수도 있는데, 소스 제어를 통해 해당 함수를 도입한 커밋을 찾아 해당 함수의 문맥을 확인할 수 있어요. 커밋은 프로그램에 버그를 도입한 코드를 식별하는 데도 도움이 되죠. Git은 심지어 커밋 내에서 이진 탐색(바이섹트 명령)을 제공하여 버그를 도입한 유일한 지시 커밋을 찾을 수도 있어요.\n\n소스 제어는 변경이 공식적인 커밋이 되기 전에도 멋진 방식으로 활용할 수 있어요. 변경 사항 스테이징, 선택적 패칭, 초기화, 숨김, 수정, 적용, 다이피, 반전 등과 같은 기능을 사용하면 코딩 플로에 다양한 도구를 추가할 수 있어요. 이 도구들을 이해하고 배우고 사용하여 그 가치를 인정해 주세요.\n\nGit을 잘 알고 있는 기능이 적을수록 제 책에서는 초보자라고 생각해요.\n\n# 23) 공유 상태 남발하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다시 말하지만, 함수형 프로그래밍 대비 다른 패러다임에 대한 이야기는 아닙니다. 이것은 다른 기사를 위한 주제입니다.\n\n공유 상태는 문제의 원인이 되므로 가능하면 피해야 합니다. 그렇지 않은 경우에는 공유 상태의 사용을 절대 최소화해야 합니다.\n\n초보 프로그래머로서 깨달지 못한 것은 우리가 정의하는 모든 변수가 공유 상태를 나타낸다는 것입니다. 해당 변수의 범위와 동일한 범위 내의 모든 요소에 의해 변경될 수 있는 데이터를 보유합니다. 범위가 더 길면 이 공유 상태의 영향이 심각해질 수 있습니다. 새로운 상태를 작은 범위에 포함시키고 상위로 누출되지 않도록 유의하세요.\n\n공유 상태의 주요 문제는 여러 자원이 이벤트 루프의 동일한 틱에서 함께 상태를 변경해야 할 때 발생합니다 (이벤트 루프 기반 환경에서). 경쟁 상태가 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 주제가 있어요: 초심자는 데이터 락 문제를 다룰 때, 특히 공유 상태 경쟁 조건 문제로 인해 타이머를 해결책으로 사용하려 할 수 있어요. 그렇게 하면 큰 경고 신호에요. 하지 마세요. 이를 주시하고, 코드 리뷰에서 지적하고, 절대 받아들이지 마세요.\n\n# 24) 오류에 대한 잘못된 태도\n\n오류는 좋은 것이에요. 당신이 진전을 만들고 있다는 것을 의미해요. 더 나은 진전을 이루기 위한 쉬운 후속 변경을 의미해요.\n\n전문 프로그래머는 오류를 좋아해해요. 초심자는 싫어해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 멋진 작은 빨간 에러 메시지를 보는 것이 괴롭다면, 태도를 바꾸어야 합니다. 이들을 도우미로 생각해야 합니다. 그들과 대응해야 합니다. 진행을 이끌기 위해 그들을 활용해야 합니다.\n\n어떤 오류는 예외로 업그레이드해야 합니다. 예외는 사용자 정의 오류로, 대비해야 하는 오류입니다. 어떤 오류는 그냥 내버려 둬야 합니다. 애플리케이션을 중단하고 종료하도록 해야 합니다.\n\n# 25) 휴식을 취하지 않기\n\n당신은 인간이고 당신의 뇌에는 휴식이 필요합니다. 당신의 몸에도 휴식이 필요합니다. 종종 자리에 묶여 휴식을 잊게 될 것입니다. 나는 이것을 초보자의 또 다른 신호로 보고 있습니다. 이것은 타협할 수 없는 것입니다. 작업 흐름에 휴식의 강제 요소를 통합하여 휴식을 취하도록 하세요. 짧은 휴식을 자주 취하세요. 의자를 떠나 짧게 산책을 하며 다음에 해야 할 일을 생각하도록 하세요. 신선한 눈으로 코드를 다시 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 긴 글을 읽느라 수고 많으셨어요.\n\n![이미지](/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_3.png)","ogImage":{"url":"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png"},"coverImage":"/assets/img/2024-06-27-TheMistakesIMadeAsaBeginnerProgrammer_0.png","tag":["Tech"],"readingTime":24},{"title":"Alado 2024 최신 Nodejs 경량 웹 프레임워크 소개","description":"","date":"2024-06-27 17:42","slug":"2024-06-27-AladoanewlightweightwebframeworkforNodejs","content":"\n\nNode.js 서버 측 개발 분야에서는 자주 새로운 도구와 프레임워크가 등장하여 개발자들의 작업을 간편화하고 응용 프로그램 성능을 향상시키려고 노력합니다. 그 중 하나인 Alado는 가벼운 백엔드 프레임워크입니다. \n\nAlado란 무엇인가요?\n\nAlado는 현대적인 Node.js 백엔드 프레임워크로, 간소화와 고성능을 중점으로 삼고 있습니다. 이 프레임워크는 개발자들에게 최소한의 리소스로 서버 측 응용 프로그램을 생성할 수 있는 간단하고 직관적인 도구를 제공하며 빠른 요청 처리 속도를 제공하면서 다양한 기능을 내장하고 있습니다.\n\nAlado의 주요 장점\n\n- 가벼움\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. Alado의 미니멀한 디자인은 로드 시간과 메모리 사용량을 크게 줄입니다. Node.js 코어 모듈과 문서화를 위해 swagger-ui-dist에만 의존하여 매우 가볍고 빠르게 만들어졌습니다.\n\n2. 뛰어난 성능\n\n현대 서버 응용프로그램 성능을 고려하여 설계된 Alado는 효율적인 요청 처리 알고리즘과 최소한의 추상화를 사용하여 높은 속도와 응답성을 보장합니다.\n\n3. 직관적인 API\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAlado는 심플하고 논리적인 API를 제공하여 개발자들이 신속하게 스피드를 내는 데 도움을 줍니다. 이는 Node.js 개발에 익숙치 않거나 새로운 도구로 전환하는 사람들에게 특히 유용합니다.\n\n**내장된 기능:**\n\n- 빠른 라우팅, 쿼리 및 바디 파싱, CORS\n- 파일 업로드: 파일 업로드를 지원하여 파일 처리 구현을 간단화합니다.\n- 자동 API 문서화: 정의된 라우트와 컨트롤러를 기반으로 문서를 생성하여 최신 API 문서를 유지보수하기 쉽게 합니다.\n\nAlado는 가벼운 디자인, 높은 성능 및 사용 편의성을 결합한 유망한 Node.js 백엔드 프레임워크입니다. 서버 측 응용 프로그램에 효율적인 솔루션을 찾는 개발자들에게 이상적인 선택입니다. 오늘 바로 Alado를 시도하고 이점을 경험해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보와 문서를 보려면 npm의 Alado 페이지를 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png"},"coverImage":"/assets/img/2024-06-27-AladoanewlightweightwebframeworkforNodejs_0.png","tag":["Tech"],"readingTime":2},{"title":"Shadcn 같은 Cli Tool을 Nextjs로 만드는 방법 ","description":"","date":"2024-06-27 17:41","slug":"2024-06-27-iBuildaCliToollikeShadcnforNextjs","content":"\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*OqSruG8nIPecbw8awLPfcQ.gif)\n\n![image](/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png)\n\nSo let’s Start 👇 and don’t Forget to “💖”.\n\nHello👋 Developers! Welcome to My Another Blog Post.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 이 블로그 글은 제 새로운 프로젝트 Mixcn-ui에 대해 이야기하고 싶어요. 제 친구 Md Taqui Imam입니다.\n\nMixcn-ui는 Nextjs를 위한 컴포넌트 컬렉션이 담긴 앱이에요.\n\nMixcn-ui를 확인해보세요 🚀\n\n가장 멋진 점은 컴포넌트의 코드를 복사하여 붙여넣기 하는 대신 shadcnui와 같은 CLI를 사용할 수 있다는 거예요.\n\n![이미지](/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어: npx mixcn-ui add hackerbutton\n\nGithub에 별을 한 개 눌러주세요⭐\n\n현재는 몇 가지 컴포넌트만 있지만, 멋진 컴포넌트를 만들고 있어요.\n\n\u003cimg src=\"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 프로젝트에 대한 멋진 아이디어나 제안이 있으시면 댓글로 남겨주세요 👇.\n\n# 여기까지 😁\n\n이 블로그를 읽어주셔서 감사합니다🙏, 새로운 장소를 발견할 수 있는 좋은 정보가 되었으면 좋겠어요!\n\n아이디어가 있다면 댓글로 표시해주세요 📩.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 \"💖\"을 꼭 남겨주세요!\n\nGithub에서 팔로우도 부탁드려요 ✅\n\n즐거운 코딩하세요 👋","ogImage":{"url":"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png"},"coverImage":"/assets/img/2024-06-27-iBuildaCliToollikeShadcnforNextjs_0.png","tag":["Tech"],"readingTime":2},{"title":"이미지를 최적화하는 Express 미들웨어 코드 작성법 성능 향상 방법","description":"","date":"2024-06-27 17:38","slug":"2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages","content":"\n\n\n![이미지](/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png)\n\n이 게시물에서는 이미지를 최적화하기 위해 sharp 패키지를 활용하는 express.js 미들웨어를 구현할 것입니다.\n\n중요 사항 요약; 이 스토리의 끝에 코드 전체가 gist로 제공됩니다.\n\n초기화\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nmkdir express-image-opt-middleware\ncd express-image-opt-middleware\nnpm init -y\ntouch index.js\ntouch utils.js\r\n```\n\n이제 의존성을 설치해 봅시다:\n\n```js\r\nnpm i express sharp\nnpm i -D nodemon\r\n```\n\nnpm 스크립트를 구성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n// package.json\n{\n  ...,\n  \"scripts\": {\n    \"dev\": \"nodemon index.js\",\n    \"start\": \"node index.js\"\n  },\n  ...\n}\n```\n\nExpress 서버를 초기화합니다:\n\n```js\n// index.js\n\nconst express = require('express');\nconst fs = require('fs/promises');\nconst path = require('path');\n\nconst app = express();\n\napp.listen(8080, () =\u003e {\n  console.log(\"서버가 http://localhost:8080에서 실행 중입니다.\");\n});\n```\n\n보통 express를 통해 정적 자산을 제공하려면 내장된 express.static 미들웨어를 사용합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\napp.use(express.static('public'));\n```\n\n이 미들웨어는 사용하지 않아도 됩니다. 왜냐하면 우리가 직접 구현할 것이기 때문입니다. 이미지를 표시하려고 할 때 이해해야 할 첫 번째 것은 이미지를 표시하려면 특정 URL로 GET 요청을 하는데, 서버에서 이미지를 가져와 표시하는 것입니다. 여기서 우리가 하는 일은 이 요청을 가로채서 URL에 제공된 쿼리 매개변수를 기반으로 필요할 때 최적화된 이미지를 제공하는 것입니다.\n\n```js\n// index.js\n\napp.get('*', async (req, res, next) =\u003e {\n  const storagePath = path.join(__dirname, 'public');\n  const fileName = req.params[0] ?? '';\n  const filePath = path.join(storagePath, fileName);\n\n  try {\n    const stats = await fs.stat(filePath);\n    if (!stats.isFile()) return next();\n\n    // * 여기에 코드를 추가합니다\n  } catch(err) {\n    console.error(err);\n    res.status(404).send('파일을 찾을 수 없습니다');\n  }\n});\n```\n\n요청된 이미지에 기반하여 적절한 Content-Type 헤더를 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// utils.js\nconst path = require('path');\n\nexports.getContentType = fileName =\u003e {\n  const ext = path.extname(fileName).slice(1);\n  let contentType;\n  \n  switch (ext) {\n    case 'jpg':\n    case 'jfif':\n    case 'jpeg':\n      contentType = 'image/jpeg';\n      break;\n    case 'png':\n      contentType = 'image/png';\n      break;\n    case 'webp':\n      contentType = 'image/webp';\n      break;\n    case 'svg':\n      contentType = 'image/svg+xml';\n      break;\n    default:\n      contentType = 'application/octet-stream';\n  }\n\n  return contentType;\n};\n```\n\n```js\n// index.js\n\n// * setting the Content-Type\n// * make sure to require getContentType\nconst contentType = getContentType(fileName);\nres.setHeader('Content-Type', contentType);\n  \n// * serve svg and unknown files as they are\nif (['image/svg+xml', 'application/octet-stream'].includes(contentType)) {\n  const readStream = createReadStream(filePath);\n  readStream.pipe(res);\n  readStream.on('error', next);\n  return;\n}\n```\n\nfs/promises API는 createReadStream 함수를 제공하지 않습니다. 두 방법을 모두 활용하려면 다음과 같이 사용하십시오:\n\n```js\nconst { createReadStream } = require('fs');\nconst fs = require('fs/promises');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 미들웨어는 다음 쿼리 매개변수를 이해합니다:\n\n- q — 품질\n- w — 너비\n- h — 높이\n\n모든 이 매개변수들이 선택 사항임을 유의하세요.\n\nw 또는 h 중 하나만 지정된 경우, 이미지의 원래 종횡비가 다른 차원을 계산하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// index.js\n\n// * sharp 패키지를 포함해야 합니다\nconst image = sharp(filePath);\nconst metadata = await image.metadata();\nconst aspectRatio = metadata.width / metadata.height;\nconst quality = Math.trunc(+(req.query.q ?? 100));\nlet width = Math.trunc(+(req.query.w ?? 0));\nlet height = Math.trunc(+(req.query.h ?? 0));\n\n// * 너비만 지정된 경우\nif (width \u0026\u0026 !height) {\n  height = Math.round(width * (1 / aspectRatio));\n\n  // * 높이만 지정된 경우\n} else if (height \u0026\u0026 !width) {\n  width = Math.round(height * aspectRatio);\n\n  // * 둘 다 지정되지 않은 경우\n} else {\n  width = metadata.width;\n  height = metadata.height;\n}\n\nconst stream = image\n  .resize({ width, height })\n  .jpeg({ quality, progressive: true, force: false })\n  .webp({ quality, progressive: true, force: false })\n  .png({ quality, progressive: true, force: false });\n\nstream.pipe(res);\nstream.on('error', next);\r\n```\n\nMiddleware의 전체 코드는 다음 gist에 있습니다: [link](gist 주소)\r\n","ogImage":{"url":"/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png"},"coverImage":"/assets/img/2024-06-27-Codeanexpressmiddlewaretooptimizeyourimages_0.png","tag":["Tech"],"readingTime":4},{"title":"React 18로 뉴욕 타임스 웹 성능 향상 방법","description":"","date":"2024-06-27 17:35","slug":"2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18","content":"\n\n## React 18 업그레이드가 뉴욕 타임스 웹 사이트에 활력을 불어넣었고 우리가 직면한 일부 도전에 대해 어떻게 대처했는지 알아봅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*rT1gMg-9ensw1FDxaAaq_Q.gif)\n\n작성자: 이리야 구레비치\n\n뉴욕 타임스의 소프트웨어 엔지니어로서 우리는 페이지 성능, SEO 및 최신 기술과의 연계 유지에 큰 가치를 둡니다. 이러한 우선 순위를 염두에 두고, React 18의 발표는 웹 개발의 끊임없이 확장되는 세계에서 상당하고 현실적인 발전으로 우리에게 돋보였습니다. React 기반 사이트의 경우, 이 업그레이드는 성능 향상과 흥미로운 새로운 기능에 접근할 수 있는 것을 약속했습니다. 지난 겨울, 우리는 주요 핵심 뉴스 사이트에서 React 18의 장점을 받아들이기로 결정했습니다. 이 과정에서 리액트와 우리 사이트의 고유한 특징을 극복해야 했지만, 최종적으로 우리는 큰 성능 향상을 이루어내고 향후 개선 가능성을 열어두었으며 아직 탐험 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 업그레이드 과정에 들어가기 전에, React 18에서 주요 이점과 변경 사항 몇 가지를 살펴보겠습니다:\n\n- Concurrent Mode로 더 부드러운 렌더링: React 18는 동시에 업데이트와 사용자 상호작용을 렌더링하는 새로운 패러다임인 Concurrent Mode를 소개했습니다. 이는 더 부드러운 애니메이션, 적은 화면 지연 및 누적 레이아웃 변경으로 이어지며 더 반응적인 사용자 경험을 제공합니다.\n- 자동 일괄 처리 및 전환: 동시성을 최대한 활용하기 위해 React 18는 단일 렌더 사이클 내에서 상태 업데이트를 자동으로 일괄 처리하여 성능을 최적화합니다. 이는 메인 스레드에서 작업을 분할하여 거의 모든 작업이 동기적으로 실행되는 이전 메커니즘과 큰 차이가 있습니다. 또한 새로운 useTransition 훅을 도입하여 특정 상태가 UI를 차단하지 않고 업데이트되도록 엔지니어들이 보장할 수 있습니다.\n- 흥미로운 새로운 기능: React 18은 서버 측 렌더링 및 선택적 가수분화를 통해 리액트 서버 컴포넌트를 통해 스트리밍 업데이트와 같은 흥미로운 기능을 제공하며 혁신적인 UI 패턴과 초기 렌더링을 가속화합니다.\n\n성능 향상은 특히 INP(Interaction to Next Paint) 점수에서 상당히 중요했기 때문에 우리에게 매우 의미가 있었습니다. INP는 페이지 응답성의 측정 항목이며 구글이 웹 사이트를 검색 결과에서 순위를 매기는 데 사용하는 Core Web Vital 중 최신 메트릭스입니다. SEO 점수는 뉴스 조직에게 매우 중요하며 우리의 INP 점수를 개선하는 것은 어려운 도전이었기 때문에 React 업그레이드가 우리에게 높은 우선 순위(그리고 위험 부담)의 이니셔티브로 자리 잡았습니다.\n\n# 우리의 이주 프로세스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용되지 않는 종속성 제거\n\n마이그레이션을 시작하기 전에 React 18과 호환되지 않은 폐기된 Enzyme 테스팅 라이브러리를 제거해야 했습니다. 이를 위해 모든 테스트 파일을 보다 최신 라이브러리인 @testing-library/react으로 수동으로 이관해야 했습니다. 시간을 투자하는 측면에서, 이것이 전체 프로젝트에서 가장 큰 작업이었을 수도 있습니다. Enzyme은 저희 리포지토리 전체에 걸쳐 수백 개의 테스트 파일에서 사용되었으며, 이를 완전히 대체하려면 상당한 인적 노력과 몇 십 개의 풀 리퀘스트가 필요했습니다. 우리는 다른 제품 작업을 수용하고 개발자의 피로를 피하기 위해 단계적인 풀 리퀘스트로 이 작업을 몇 달 동안 해내었습니다. 노력의 끝에, 우리는 분명히 @testing-library/react API에 대한 전문가가 되었으며, React 18 업그레이드로 넘어갈 수 있어 기쁘게 생각했습니다.\n\n2. 기반 설정\n\n테스트 파일 마이그레이션이 완료되면 React 18 통합 작업을 시작할 수 있었습니다. 이를 안전하게 수행하기 위해, 먼저 주요 종속성, 유형 및 테스트를 React 18에 맞게 업그레이드하는 작업을 시작했습니다. 실제 기능을 구현하는 것이 아니라 React 18에 적합하도록 간단히 @types/react, react-test-renderer, react-dom 및 @testing-library 등 모든 것을 우리 리포지토리 전체의 package.json 파일에서 최신 버전으로 업그레이드했습니다. 모든 주요 의존성을 업그레이드하는 것은 동일 버전에 맞도록 일부 테스트 및 유형 정의를 리팩토링하는 것도 필요했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 엔진 켜기\n\n우리가 패키지 업그레이드에 자신감을 갖게 되자, 우리는 React 18의 새로운 기능을 안전하게 통합할 준비가 되었습니다. 이 기능을 현실로 바꾸기 위해, 우리는 최신 API인 createRoot와 hydrateRoot를 활용해야 했습니다. 우리는 여러 웹 서버에 걸쳐 React Hydration을 통합한 몇 가지 인스턴스를 가지고 있었는데, 모든 서버 간에 렌더링되는 일련의 공유 UI 구성 요소가 있었기 때문에 우리는 가능한 한 많은 곳에서 React 18 기능을 활성화시키는 것이 중요했습니다. 처음 보기에는 ReactDOM.hydrate를 hydrateRoot로 변경하는 것만으로 간단해 보였지만, 정말 그럴까요?\n\n예기치 않은 도전\n\n개발자로써 \"운영 환경으로 전개\" 버튼을 누를 때 자신감이 생기기 쉽습니다. 엔드 투 엔드 통합 및 단위 테스트가 통과되었고, 다양한 환경과 장치에서 QA를 수행했으며, 최신 기능을 곧 출시할 단계에 있다면, 그 생각이 들 수 있습니다. 우리는 뉴욕 타임즈 웹사이트에 최신 React 버전을 처음으로 배포했을 때 모두 그러했습니다. 새로운 업그레이드를 초기에 배포한 직후, \"내장형 인터랙티브\"라고 하는 일부 고트래픽 콘텐츠에 문제가 발생했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 리액트 18에 임베디드 인터랙티브 적용\n\n![이미지](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png)\n\n뉴욕타임스에서는 custom 임베디드 인터랙티브를 사용하여 위험성 있는 `dangerouslySetInnerHTML`을 통해 서버 측에서 렌더링됩니다. 이러한 인터랙티브는 자체의 HTML, 링크 및 스크립트를 갖추며, React 트리와 독립적으로 실행됩니다. 편집자와 기자들은 코어 인프라를 변경하거나 다시 배포할 필요 없이 페이지에 일회용 및 독립적인 시각적 및 상호작용 요소를 삽입할 수 있습니다. 임베디드 인터랙티브는 우리의 일부 가장 중요한 보도 활동의 핵심 요소이지만, 개발자들에게 실제로 어려움을 초래할 수도 있습니다.\n\n간단한 예시는 다음과 같습니다(script 태그는 페이지가 열리자마자 DOM을 수정할 것입니다):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst embeddedInteractiveString = `\n  \u003cdiv id=\"server-test\"\u003e서버\u003c/div\u003e\n  \u003cscript\u003e\n    document.addEventListener(\"DOMContentLoaded\", () =\u003e {\n      const serverTestElement = document.getElementById(\"server-test\");\n      serverTestElement.textContent = \"클라이언트\";\n    });\n  \u003c/script\u003e\n`;\nreturn \u003cdiv dangerouslySetInnerHTML={ {__html: embeddedInteractiveString } } /\u003e;\n```\n\n이 설정에서 스크립트는 페이지 로드 후에 \"server-test\" 요소의 내용을 \"server\"에서 \"client\"로 수정합니다. 브라우저에서 렌더링된 스크립트가 React가 DOM을 하이드레이트하기 전에 실행되기 때문에 작동합니다. 이는 우리가 주입된 HTML 및 해당 스크립트가 의도한 대로 동작할 것을 신뢰하는 \"블랙 박스\"로 볼 수 있습니다.\n\n하이드레이션 장벽\n\nReact 18이 도입되면서 더 엄격해진 하이드레이션 불일치 요구 사항이 있습니다. 새로운 규칙에 따르면 초기 브라우저 로드와 클라이언트 측 하이드레이션 사이의 모든 DOM 수정은 클라이언트 측 렌더링으로 되돌아가도록 트리거됩니다. 우리의 예시에서는 스크립트 태그가 하이드레이션 전에 \"server-test\" 요소를 수정하더라도, 하이드레이션 불일치에서 React는 서버 측 렌더링된 콘텐츠를 버리고 클라이언트 측 렌더링으로 되돌아가게 됩니다. 이전 버전의 React에서는 하이드레이션 불일치가 있더라도 React 팀이 클라이언트에서 완전히 다시 렌더링하는 대신 DOM 버전을 무효한 상태로 남기기로 선택했기 때문에 과거에는 문제가 발생하지 않았던 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제적으로는 이게 무슨 뜻일까요? 사용자가 `dangerouslySetInnerHTML` 속성을 사용하여 클라이언트에 컴포넌트를 렌더링할 때, 안전성 상의 이유로 `script` 태그가 포함된 HTML은 브라우저에서 실행되지 않습니다. 이는 `dangerouslySetInnerHTML` 속성을 사용하여 클라이언트에서 재렌더링된 중에 하이드레이션 불일치 때문에 임베드된 상호 작용이 사실상 자바스크립트가 실행되지 않은 것처럼 렌더링됨을 의미합니다. 위의 예시에서, 텍스트 콘텐츠는 \"서버\"에서 \"클라이언트\"로 변경되지만, 하이드레이션 불일치로 인해 다시 \"서버\"로 렌더링됩니다. 이로 인해 일부 임베드된 상호 작용이 예상한 렌더와 매우 다르게 보여지게 되었습니다.\n\n예상:\n\n\u003cimg src=\"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_1.png\" /\u003e\n\n실제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_2.png\" /\u003e\n\n그래서 우리는 무엇을 해야 할까요?\n\nReact 18가 React 16보다 수분화 불일치에 더 민감하다는 사실을 감안할 때, 우리 앞에는 두 가지 선택지가 있었습니다. 첫 번째는 웹 사이트에서 발생할 수 있는 모든 수분화 불일치를 수정하는 것이었고, 두 번째는 수분화 불일치가 발생할 경우 클라이언트에서 재설치되도록 내장 상호작용형을 수정하는 것이었습니다. 이로 인해 우리는 애로 상황에 처해 있었습니다. 뉴욕 타임스는 수백 가지 다양한 구성 요소와 수만 개의 사용자 정의 임베디드 상호작용형을 포함한 수백만 개의 기사를 게시했습니다. 물론 모든 수분화 불일치를 수정하고 싶었지만, 어떻게 안전하게 할 수 있을까요?\n\n결국, 우리는 두 가지 문제를 동시에 해결하기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 내장 인터랙티브 스크립트 수동 추출 및 실행\n\ninnerHTML 프로퍼티를 통해 추가된 스크립트 태그나 클라이언트 측 재렌더링 도중 추가된 스크립트 태그는 브라우저 보안상의 이유로 자동으로 실행되지 않는다는 것을 알고 있습니다. 그렇다면 어떻게 해결할까요? 스크립트 태그는 수동으로 다른 DOM 요소의 자식 노드로 추가 또는 대체할 때에만 실행됩니다. 이는 스크립트 태그를 올바르게 실행하려면 먼저 대화형 HTML에서 추출하고 제거한 다음 컴포넌트가 다시 렌더링될 때 내장된 대화형 HTML의 올바른 위치에 다시 추가해야 한다는 것을 의미합니다.\n\n```js\n// 이 함수는 일반 HTML에서 스크립트 태그를 빈 플레이스홀더로 대체합니다.\n// 이렇게 하면 나중에 클라이언트 마운트에서 실제 스크립트로 스크립트 태그 참조를 현위치에 대체할 수 있습니다.\nexport const addsPlaceholderScript = (scriptText, id, scriptCounter) =\u003e {\n  let replacementToken = '';\n  let hoistedText = scriptText;\n\n  replacementToken = `\u003cscript id=\"${id}-script-${scriptCounter}\"\u003e\u003c/script\u003e`;\n  hoistedText = hoistedText.replace('\u003cscript', `\u003cscript id=\"${id}-script-${scriptCounter}\"`);\n\n  return {\n    replacementToken,\n    hoistedText,\n  };\n};\n\n// 이 함수는 대화형 HTML 문자열에서 `\u003cscript\u003e` 태그를 추출하고 제거하며\n// 클라이언트 마운트에서 실행할 스크립트 텍스트 배열과 스크립트를 제거한 빈 스크립트 참조가 있는 수정된 HTML 문자열을 포함하는 객체를 반환합니다.\nexport const extractAndReplace = (html, id) =\u003e {\n  const SCRIPT_REGEX = /\u003cscript[\\s\\S]*?\u003e[\\s\\S]*?\u003c\\/script\u003e/gi;\n  let lastMatchAdjustment = 0;\n  let scriptlessHtml = html;\n  let match;\n  const scriptsToRunOnClient = [];\n  let scriptCounter = 0;\n  while ((match = SCRIPT_REGEX.exec(html))) {\n    const [matchText] = match;\n    if (matchText) {\n      let hoistedText = matchText;\n      let replacementToken = '';\n      ({ hoistedText, replacementToken } = addsPlaceholderScript(hoistedText, id, scriptCounter));\n      scriptCounter += 1;\n      const start = match.index - lastMatchAdjustment;\n      const end = match.index + matchText.length - lastMatchAdjustment;\n      scriptlessHtml = `${scriptlessHtml.substring(\n        0,\n        start\n      )}${replacementToken}${scriptlessHtml.substring(end, scriptlessHtml.length)}`;\n      scriptsToRunOnClient.push(hoistedText);\n      lastMatchAdjustment += matchText.length - replacementToken.length;\n    }\n  }\n\n  return {\n    scriptsToRunOnClient,\n    scriptlessHtml,\n  };\n};\n\n// 클라이언트에서 스크립트 실행\nconst runScript = (clonedScript) =\u003e {\n    const script = document.getElementById(document.getElementById(`${clonedScript.id}`))\n    script.parentNode.replaceChild(clonedScript, script);\n}\n```\n\n어째서 서버에 스크립트를 유지하고 클라이언트에서 재실행하지 않고도 해결할 수 없을까요? 이를 몇 가지 시나리오에서 불가능한 이유 중 하나는 스크립트 태그 중 일부가 함수 클로저 내가 아닌 전역 변수를 선언하기 때문입니다. 서버에서 스크립트 태그를 미리 렌더링한 다음 클라이언트에서 재실행하면 전역 변수의 다시 선언으로 인한 오류가 발생하여 불가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 초기 솔루션으로 많은 내장 상호작용을 수정했습니다. 그러나 임의로 순서 지정된 스크립트 실행과는 잘 맞지 않는 상호작용이 있습니다. 여기서 몇 가지 세심한 사항을 살펴보겠습니다:\n\n스크립트 로드 순서\n\n일부 상호작용 스크립트는 다시 내장된 상호작용 HTML에 추가될 때 올바른 순서로 로드되어야 합니다. 이전 스크립트 실행 전략은 모든 `script` 태그가 이미 서버에 선언되고 사전 렌더링되었다고 가정했습니다. 이제는 스크립트 태그를 제거하고 클라이언트에 재부팅해야 하기 때문에 이러한 원칙을 기반으로 한 몇 가지 내재 논리가 깨지게 될 것입니다. 예시를 통해 함께 살펴보겠습니다.\n\n```js\n\u003cscript\u003e\n  const results = document.getElementById(\"RESULTS_MANIFEST\").innerHTML.ELECTION_RESULTS;\n  // 결과를 사용하여 추가적인 로직 수행\n\u003c/script\u003e\n\u003cdiv\u003e\n  대화형 DOM 내용이 여기로 이동합니다\n\u003c/div\u003e\n\u003cscript id=\"RESULTS_MANIFEST\"\u003e{\"ELECTION_RESULTS\": ['result1', 'result2', ....]}\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 시나리오에서는 두 번째 스크립트 태그의 ID를 사용하여 다른 스크립트 태그를 검색한 다음 두 번째 스크립트 태그의 innerHTML을 기반으로 일부 기존 논리를 활용하는 초기 스크립트가 있습니다. 이전 반복의 경우, 스크립트 태그는 서버에서 미리 렌더링되었기 때문에 기본적으로 문제 없이 DOM에서 스크립트 태그를 ID로 참조할 수 있었습니다.\n\n최적의 상호 작용을 위해 스크립트 실행은 다시 DOM에 추가될 때 특정 순서를 따라야 합니다. 이에는 다음이 포함됩니다:\n\n- 정적 데이터가 포함된 기능이 없는 manifest 스크립트를 먼저 추가합니다.\n- 다음으로 src 속성을 가진 스크립트를 비동기적으로 실행합니다.\n- 마지막으로 innerHTML에 있는 순수 JavaScript로 스크립트를 추가하고 실행합니다.\n\n이 순서대로 진행하면 스크립트가 제대로 로드되기 전에 서로를 참조하지 못하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 제공된 스크립트 태그를 구문 분석하여 정렬을 위한 우선순위를 반환합니다.\n// 우선순위 1: JSON 또는 기타 메타데이터 콘텐츠\n// 우선순위 2: 다른 바닐라 JS 또는 src 콘텐츠\nexport const getPriority = template =\u003e {\n  let priority;\n  try {\n    JSON.parse(template.innerHTML);\n    priority = 1;\n  } catch (err) {\n    priority = 2;\n  }\n  return priority;\n};\n\n\nscripts.sort((a, b) =\u003e getPriority(a) - getPriority(b));\n```\n\n# 즉시 퍼포먼스 개선\n\n매우 세심하게 조정된 이 내장형 인터랙티브 코드의 통합 후, 우리는 React 18을 다시 안전하게 출시할 수 있었습니다. 우리는 거의 40,000개의 사용자 정의 내장형 인터랙티브를 철저히 테스트할 수 없지만, 그래픽 팀이 자주 활용하는 재사용 가능한 몇 가지 템플릿을 신뢰할 수 있었습니다. 이를 통해 Svelte나 Adobe Illustrator 기반의 내장형 인터랙티브 내에서 특정 동작을 검증할 수 있었습니다. 장기적으로는 남아있는 하이드레이션 불일치를 해결하고 안심할 수 있는 상태에 도달하기 위한 노력을 계속하지만, 단기적으로는 다시 \"배포\" 버튼을 누르는 준비를 했습니다.\n\n새로운 기능을 출시한 후 (그리고 어떠한 문제도 발생하지 않는지를 신경 쓰면서 한 시간 동안 내부 알림을 신중히 확인한 후), 거의 즉시 성능 향상을 볼 수 있었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![React Upgrade Chart](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_3.png)\n\n이 차트에서 볼 수 있듯이, INP 스코어가 p75 범위에서 대략 30% 감소했어요!\n\n업그레이드 이전에, 우리의 가장 큰 과제 중 하나는 페이지를 로드하는 동안 뉴스 사이트가 거치는 빈번한 재렌더링이었어요. 이는 사용자가 아직 로드 중인 페이지와 상호 작용을 시도할 때 부정적인 사용자 경험(그리고 하위 수준의 INP 스코어)을 초래했어요.\n\nReact 18을 업그레이드한 후, 재렌더링이 거의 절반으로 줄었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_4.png)\n\n이 두 가지 매우 눈에 띄고 중요한 개선 사항은 React 18의 자동 일괄 처리와 병행성 기능의 직접적인 결과입니다. 이는 우리가 올바른 방향으로 나아가고 있다는 매우 명확하고 긍정적인 신호를 주었습니다.\n\n# 다음 단계\n\nReact 18 통합은 이미 우리에게 상당한 개선을 가져다 주었으며, 이전에 이용할 수 없었던 다양한 가능성의 문을 열어 주었습니다. 이제는 startTransition 및 React Server Components와 같은 새로운 기능의 잠재적 이점을 탐색하는 데 집중하고 있습니다. 우리의 핵심 의도는 지속적으로 INP 점수를 낮추고 전반적인 기능을 개선하는 것입니다. 그러나 이러한 개선 사항에 대해 답할 필요가 있는 질문에 대해 주의를 기울이고 있습니다. 현재 사용 중인 React 버전의 안정적이고 신뢰할 수 있는 성능을 보장하는 것이 현재 우리의 주요 업무입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뉴스 사이트 결과를 바탕으로, 우리는 유사한 성능 향상을 보인 기타 몇몇 사이트의 업그레이드를 추구할 자신감을 느꼈습니다. 3월 구글 데드라인 전에 INP 점수를 \"나쁨\" 영역을 벗어낼 수 있었으며, 구글의 검색 알고리즘 일부가 되었을 때 부정적인 SEO 결과를 보지 못했습니다. 우리는 독자들이 약간 빨라진 경험을 즐기고 있다고 생각합니다. 뉴스룸은 매일 강력하고 흥미로운 대화형 콘텐츠를 제공해왔으며, 가속화 프레임워크에 대해 두 번째 생각할 필요 없이 작업을 이어가고 있습니다.\n\nIlya Gurevich는 스타트업과 기업 환경에서 10년 이상의 경력을 가진 시니어 소프트웨어 엔지니어입니다. 그는 2019년 뉴욕타임스에 합류한 이후 현재 핵심 웹 플랫폼 팀의 일원입니다. 그는 주요 사이트를 구동하는 중앙집중식 NodeJS 플랫폼을 관리하며, 개발자 경험, 도구 및 수백 명 이상의 활발한 기여자가 있는 멀티 워크스페이스 모노레포의 빌드 프로세스에도 참여하고 있습니다. 그 전에는 레포터와 편집자를 위해 특별히 제작된 최첨단 실시간 협업 텍스트 편집기에 참여한 경력이 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png"},"coverImage":"/assets/img/2024-06-27-EnhancingTheNewYorkTimesWebPerformancewithReact18_0.png","tag":["Tech"],"readingTime":12},{"title":"웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석","description":"","date":"2024-06-27 14:25","slug":"2024-06-27-Itstimetokilltheweb","content":"\n\n무슨 일이 벌어지고 있어요. 사람들이 불만스러워하는 모양이에요. 시민 불안의 유령이 우리 프로그래밍 커뮤니티를 쫓고 있어요.\n\n처음으로, 많은 개발자들이 웹 플랫폼을 공개적으로 의심하고 있어요. 여기 한 편의 대표적인 기사와 토론이 있어요. 또 다른 것도 있어요. 더 있지만, 당신이 이것을 읽고 있는 만큼 프로그래밍에 흥미가 있는 분이라면, 올해에 대한 현대 웹 개발 상태에 대한 웃기는 항의 한 편은 이미 한 편 이상 읽었어요. 이 기사는 그러한 종류가 아니에요. 저는 상태 quo를 조롱하는 것보다, 매일 그것을 경험하는 불쌍한 사람들보다 더 나은 일을 할 수 없어요. 이 기사는 다른 종류에요.\n\n![이미지](/assets/img/2024-06-27-Itstimetokilltheweb_0.png)\n\n웹을 대체하고 흡수하여 최종적으로 그것을 대체할 만한 경쟁 프로그램을 만드는 방법에 대해 생각해보고 싶어요, 적어도 앱 작성 목적으로요. 웹은 문서를 배포하는 방법으로서도 문제점이 있지만, 걱정할 정도로 심각하지는 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 총 세 편으로 나뉩니다. 첫 번째 편에서는 웹 플랫폼에 대한 심각하고 수정할 수 없는 문제점을 검토할 것입니다. 나는 당신에게 이것을 완전히 폐기해야 한다고 설득하고 싶어요. 결국, 문제를 분석하지 않으면 해결할 수 없거든요. 또한 이 문제들에 대해 이제 정치적으로 이야기할 수 있는 이유를 간단히 살펴보겠어요. 비록 이러한 문제들이 사실 새로운 것은 아니지만 말이에요.\n\n제 2부와 3부에서는 작은 그룹이 합리적인 시간 내에 구축할 수 있는 새로운 앱 플랫폼을 제안하고, 오늘날의 것보다 훨씬 나은 것이어야 한다고 생각해요 (제 의견). 물론, 모두가 마지막 부분에 동의할 수는 없을 거에요. 문제에 동의하는 것은 해결책에 동의하는 것보다 항상 쉽거든요.\n\n제 1부. 시작합니다.\n\n# 왜 웹은 죽어야 할까요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 앱들. 그겟서요? 뭐든 문제가 많지만, 오늘은 두 가지만 얘기해볼게요.\n\n- 웹 개발은 천천히 1990년대를 되살리고 있죠.\n- 웹 앱들을 보안하는 건 불가능해요.\n\n요즘 핫한 Facebook의 최신 웹 프레임워크인 Flux에 관한 좋은 블로그 포스트가 있어요. 저자는 Flux가 1985년 발매된 Windows 1.0에서 사용된 프로그래밍 모델을 재현했다고 언급했어요. 마이크로소프트는 이 모델을 사용했는데, 그 당시 컴퓨터가 매우 느려서 적합했지만 개발하기가 어색했죠. 그래서 10년 미만이 지난 시간 동안, 이러한 WndProc 메시징 시스템을 추상화한 제품들(예: OWL)이 생겨났어요.\n\nReact/Flux가 사용하는 방식이 이러한 이유 중 하나는 웹 렌더링 엔진이 매우 느리기 때문이에요. 사용자가 실제로 보는 최종 결과물은 20년 전의 Windows 사용자가 본 것보다 약간 더 멋있을 뿐이라는 사실이 있답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_1.png\" /\u003e\n\n지금은 화면 해상도가 높아졌죠. 우리가 좋아하는 회색 음영도 바뀌었어요. 하지만 위에서 보는 UI는 아래에서 보는 UI와 복잡성 면에서 비슷합니다:\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_2.png\" /\u003e\n\n아이콘 스타일도 똑같아요! Windows 98는 예전에는 다채롭고 빽빽한 픽셀 아트 스타일이었던 플랫, 회색조 아이콘의 새로운 트렌드를 소개했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 오피스 2000은 75 Mhz CPU와 32mb RAM으로도 행복했지만, 위에 표시된 구글 독스는 2.5Ghz CPU와 거의 정확히 10배 더 많은 RAM을 사용하고 있어요.\n\n만약 생산성이나 기능이 10배 증가했다면 용서해도 될지도 모르지만, 사실은 그렇지 않아요. 1995년 개발자 플랫폼은 모두 이런 것들을 가져야 했어요. 이것이 '시작의 가치'였어요:\n\n- 레이아웃 제약 조건과 데이터 바인딩이 있는 시각적 UI 디자이너.\n- 다국어 소프트웨어 컴포넌트에 대한 정교한 지원. 정적으로 입력된 네이티브 코드와 스크립팅 언어를 혼합할 수 있었어요.\n- 몇 메가바이트의 RAM에서 실행될 수 있는 효율적인 출력 바이너리.\n- 데이터 그래픽, 테마, 3D 그래픽, 소켓 프로그래밍, 대화식 디버깅을 지원하는 것.\n\n이러한 기능 중 많은 것들이 지난 몇 년 동안에야 웹 플랫폼에 도입되었으며, 종종 불안정한 방식으로 도입되곤 했어요. 웹 앱은 실제 소켓을 사용할 수 없기 때문에 서버를 \"웹 소켓\"을 지원하도록 변경해야 합니다. UI 구성 요소와 같은 기본적인 것들조차도 끔찍한 상황입니다. 언급할 가치가 있는 웹 IDE는 없으며, 서로 다른 프로그래밍 언어를 혼합하는 것에 대해서는... 자바스크립트로 변환할 수 있어요. 때때로요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 앱을 개발자가 쓰는 이유 중 하나는 웹에서의 사용자 기대치가 극히 낮기 때문입니다. Windows 95용 앱은 아이콘, 드래그 앤 듭, 되돌리기, 파일 연관, 일관된 키보드 단축키, 백그라운드에서 유용한 작업을 수행하며 오프라인에서도 작동하는 것이 기본 기능으로 예상되었습니다. 하지만 이 모든 것들은 기본적인 앱 수준에 불과했습니다. 정말 인상적인 소프트웨어는 Office 문서 내에 임베드될 수 있거나 Explorer를 확장하거나 원래 개발자에게 알려지지 않은 임의의 플러그인으로 확장되어야 했습니다. 그러나 웹 앱은 보통 이러한 것들을 하지 않습니다.\n\n이 모든 것들이 쌓여 나에게는 데스크톱 앱을 작성할 때 훨씬 더 생산적인 느낌이 듭니다 (파일 유형용 아이콘을 만드는 것과 같은 \"세금\"을 지불해야 하는 것들을 포함하여도). 또한 사용하는 것을 선호합니다. 그리고 다른 이들과의 토론을 통해 나만 이런 것은 아니라는 것을 압니다.\n\n나는 웹이 이렇게 되어 있는 것은 HTML이 문서 플랫폼으로 시작했을 때 어떤 일관된 디자인 철학과 도구 세트를 갖고 있었기 때문이라고 생각합니다. 그러나 HTML이 앱 플랫폼으로 추상화된 것은 나중에 따로 추가되었고 결국 제대로 이루어지지 않았습니다. 따라서 파일 연관과 같은 기본 기능조차 존재하지 않지만 Google은 행아웃을 만들고 구글의 우선 순위가 무엇이 추가되는지를 결정하기 때문에 HTML5에는 P2P 비디오 스트리밍이 있습니다. 이러한 문제를 피하려면 처음부터 앱을 염두에 두고 설계된 플랫폼이 필요하며, 아마도 그 위에 문서를 추가하는 것이 더 좋을 것입니다.\n\n# 웹 앱은 보안이 불가능합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1990년대 말에 소프트웨어 산업에는 끔찍한 깨달음이 들었습니다: C/C++ 프로그램의 보안 버그는 적 spor한 실수가 아니었고, 임시 프로세스로 처리할 수 있는 것이 아니었습니다. 그것들은 어디에나 있었습니다. 사람들은 C/C++ 조각이 인터넷에 노출되면 악용이 따를 것이라는 것을 깨달았습니다.\n\n그 당시 세상이 얼마나 순진했는지 알 수 있습니다. 2001년 Code Red에 관한 SANS 보고서를 읽어보면 됩니다:\n\nWindows는 자동 업데이트 기능을 가지고 있었지만, 제대로 기본으로 활성화되지는 않았던 것으로 기억합니다. 사용자의 허락 없이 소프트웨어가 변경될 수 있다는 아이디어는 일종의 금기였습니다.\n\n\u003cimg src=\"/assets/img/2024-06-27-Itstimetokilltheweb_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n산업은 변화하기 시작했지만, 많은 비명과 부인과 함께였습니다. 당시에는 Linux와 Mac 사용자들 사이에서 이 문제가 Microsoft에만 특정한 문제로 여겨졌다는 것이 일반적인 지혜였죠... 그들의 시스템이 뛰어난 프로그래머들에 의해 만들어졌다는 것. Microsoft는 자신들이 존재적 위기에 직면하고 있다고 받아들였고 \"안전한 개발 수명주기\"를 도입했습니다(대규모의 교육 및 프로세스 프로그램). 그러나 경쟁사들은 거의 아무것도 하지 않았습니다. 레드먼드는 Windows XP에 방화벽을 추가하고 코드 서명 인증을 도입했습니다. 모바일 코드가 제한되었고, 보안 버그가 끝없는 것으로 드러나자 \"패치 화요일\"이 고안되었습니다. 영리한 해커들은 예전에 무해로 여겨졌던 버그 유형이 여전히 악용 가능하며, 강력하다고 여겨졌던 악용 방지가 우회될 수 있음을 지속적으로 발견했습니다. Mac 및 Linux 커뮤니티는 천천히 바이러스와 악용에 완전히 면역이 아니라는 사실을 깨달았습니다.\n\n2008년 구글이 Chrome을 출시하면서 최종적인 전환점이 왔습니다. 이 프로젝트는 거대한 노력을 들여 복잡하지만 완전히 투명한 렌더러 샌드박스를 도입한 점이 주목할 만합니다. 다시 말해, 산업 최고의 엔지니어들이 얼마나 노력해도 안전한 C++ 코드를 쓸 수 없다는 사실을 공개적으로 인정했다는 점입니다. 이 신념과 설계가 사실상의 표준이 되었습니다.\n\n## 이제 웹의 차례입니다\n\n유감스럽게도, 웹은 신뢰할만한 앱의 약속의 땅으로 우릴 이끌어가지 못했습니다. 웹 앱은 호스트 OS로부터 어느 정도 격리되어 있기는 하지만, 앱 자체는 2001년 경의 Windows 코드보다 훨씬 튼튼하지 못합니다. 우리의 레거시 문제를 영구적으로 해결하는 대신, 웹은 오히려 하나의 버퍼 오버플로우 종류를 다른 것으로 대체했습니다. 데스크톱 앱이 \"이중 해제\", \"스택 스매시\", \"이후 무료 사용\" 등과 같은 악용 카테고리를 가지고 있는 것과는 달리, 웹 앱은 이를 해결하고 나서도 자체적으로 유사한 실수를 반복하는 경향이 있었습니다: SQL 인젝션, XSS, XSRF, 헤더 인젝션, MIME 혼란 등입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 논문으로 이어집니다:\n\n나는 안전한 웹 앱을 작성하는 것이 불가능하다는 주장을 제기합니다.\n\n문제를 극복합시다. 이는 말그대로 모든 웹 앱에 해당하는 것이 아닙니다. 네, 안전한 HTML Hello World를 만들 수 있습니다. 멋지네요.\n\n저는 실제 규모의 웹 앱, 현실적인 조건에서 작성된 것에 대해 이야기하고 있습니다. 이는 가볍게 주장하는 것이 아닙니다. 이것은 제가 Google에서 8년간 지켜본 곳에서 얻은 신념입니다. 거기서 가장 뛰어난 웹 개발자들이 계속해서 취약한 소프트웨어를 배포하는 것을 지켜봤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 보안팀은 세계에서 가장 우수한 보안팀 중 하나일 수도 있고, 아마도 최고일 수도 있습니다. 그들은 내부 교육 프로그램의 일환으로 사람들이 하는 주요 실수들에 대한 유용한 가이드를 작성했습니다. 데이터를 안전하게 브라우저로 전송하여 표시하는 데 도움이 되는 이들의 조언을 여기에 소개합니다:\n\n이 믿기 힘든 마법과 전설 속의 뭉텅이를 읽으면 항상 웃음이 나옵니다. 농담이어야 할 것 같지만 실제로는 구글의 모든 웹 개발자가 알고 있어야 하는 기본적인 내용입니다. 화면에 데이터를 표시하기 위해 필요한 것뿐입니다.\n\n사실, 위의 모든 방어책을 구현하더라도 작동하지 않을 수 있습니다. HEIST 공격은 웹 플랫폼 자체의 수정할 수 없는 설계 결함을 이용하여 심지어 위의 모든 완화 조치를 채택한 웹 앱에서 데이터를 도난당할 수 있게 합니다. 게임 오버입니다.\n\n정말 그렇지 않습니다! 더 나빠집니다! REST/JSON 엔드포인트를 보호하는 것은 현대 웹 개발자가 이해해야 할 다양한 보안 문제 중 하나뿐입니다. 수십 가지 더 있습니다(여기 흥미로운 예제가 있고 다른 재미있는 것이 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 경험상 이 모든 덫 중 하나라도 들어본 웹 개발자를 고용하려고 시도하면 실패로 끝나기 마련이며, 이런 덫을 신뢰할 수 있는 방법으로 회피하는 개발자를 고용하는 것은 더욱 어렵습니다. 그래서 결론은 다음과 같습니다: 안전한 웹 앱을 작성하는 방법을 이해하지 못한 웹 개발자를 고용할 수 없다면 안전한 웹 앱을 작성할 수 없습니다.\n\n# 핵심 문제\n\n거의 모든 웹 보안 문제는 몇 가지 주요 설계 문제에서 발생합니다:\n\n- 길이를 명시하지 않은 버퍼\r\n- 문서가 아닌 앱을 위한 설계된 프로토콜\n- 동일 출처 정책\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버퍼 크기를 잃어버리는 것은 C 프로그램에서 취약점의 전형적인 원인이며 웹도 똑같은 문제를 가지고 있습니다: XSS와 SQL 인젝션 악용은 코드 버퍼가 시작되고 데이터 버퍼가 끝나는 곳이 어디인지 혼란을 야기하는 것에 기반합니다. 웹은 텍스트 프로토콜과 형식에 완전히 의존하기 때문에 버퍼는 반드시 구문 분석되어 길이를 알아내야 합니다. 이는 피할 수 있는 탈출, 대체 및 기타 문제들의 세계를 열어놓습니다.\n\n해결책: 모든 버퍼는 데이터베이스에서 프론트엔드 서버, 사용자 인터페이스로의 이동 과정에서 길이가 사전에 지정되어야 합니다. 끝을 결정하기 위해 어떤 마법적인 문자열을 스캔해야 하는 필요는 없어야 합니다. 이는 전체 스택에서 이진 프로토콜, 형식 및 UI 논리가 필요하다는 것에 유의해주세요.\n\nHTTP와 HTML은 문서를 위해 디자인되었습니다. Egor Homakov이 SMS 코드 입력 필드 안에 간단히 \"../sms\"를 입력하여 Authy의 2요소 인증 제품을 파괴할 수 있었던 이유는 Authy와 같은 모든 웹 서비스가 하이퍼텍스트를 위해 디자인된 스택에 기반에 두고 있기 때문입니다. 경로 이동이 유용한 것은 만약 접근하려는 것이 실제 HTML 파일이 들어 있는 디렉토리 세트라면 하는 것입니다, Sir Tim이 의도한 대로. 프로그래밍 API를 \"문서\"로 제공한다면 경로 이동이 치명적일 수 있습니다.\n\nREST가 XML을 반환했을 때만으로도 충분히 나빴지만 요즘에는 XML이 유행을 타지 않고 웹에서는 대신 JSON을 사용합니다. 이는 실제로 보안 문제에 대해 전체 섹션을 갖고 있는 wiki 페이지가 있는 식으로 설계되어 있어서 매우 나쁘게 디자인된 형식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정: REST를 좋은 아이디어인 것처럼 가정하는 것을 그만두죠. REST는 HTTP를 비틀어서 브라우저의 제약을 우회하기 위해 만들어진 좋은 아이디어가 아니에요. 브라우저까지 변형되어야 할 도구를 다른 용도로 바꾸는 것은 문제가 생길 수밖에 없어요. 이런 접근은 결국 좋은 결말을 가져다주지 않아요. 이전 내용을 고려할 때, 클라이언트/서버 간 통신은 RPC 사용 사례에 특별히 설계된 이진 프로토콜을 사용해야 해요.\n\n동일 출처 정책은 스티븐 킹의 소설에서 나온 것 같은 개발자 경험입니다. 위키에서 인용하자면:\n\nSOP는 넷스케이프가 문서 형식에 코드를 덧붙이면서 생긴 결과입니다. 이것은 실제로 어떤 의미도 갖지 않으며, 무엇보다도 10일 이상의 시간이 주어지지 않는다면 앱 플랫폼을 그렇게 설계하지 않겠죠. 그래도 우리는 자비심을 가지고 있어야 할지도 몰라요. 넷스케이프는 격려되는 시간 압력 속에서 일하는 스타트업이었고, 이미 언급한 대로, 그때는 보안에 대해 생각하는 사람이 별로 없었어요. 10일 코딩 마라톤이 더 심각한 상황을 만들었을 수도 있어요.\n\n우리의 동정을 떠나 SOP는 HEIST 공격의 근간이 되며, HEIST는 실제 웹 앱 거의 모두를 손상시키는 것으로 보이며, 아마 역호환성을 깨지 않고 고칠 수는 없을 겁니다. 이것이 안전한 웹 앱을 작성하는 것이 불가능하다는 하나의 더이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정 사항: 애플리케이션에는 명확한 식별이 필요하며 보안 토큰을 기본 설정으로 서로 공유해서는 안 됩니다. 서버에 액세스 권한이 없다면 해당 서버로 메시지를 보낼 수 없어야 합니다. 웹을 제외한 모든 플랫폼이 이를 올바르게 처리합니다.\n\n웹에는 보안을 어렵게 만드는 다른 디자인 문제들이 있지만, 위의 예시들만으로도 이를 납득시킬 수 있을 것입니다.\n\n# 결론\n\nHTML 5는 우리 산업에 해를 끼치는 요인입니다. 일부 기능은 잘 처리하지만 다른 앱 플랫폼과 쉽게 맞먹을 수 있는 이점도 있지만, 웹의 핵심적인 디자인 결함들은 대부분 수정할 수 없습니다. 따라서 웹은 모바일에서 패배했습니다: 유기적으로 성장하는 대신 실제로 설계된 경쟁 플랫폼이 나왔을 때, 개발자들은 대부분 네이티브 앱으로 전환하는 것을 선택했습니다. 그러나 모바일 외에는 좋은 대안이 없습니다. 데스크탑과 랩톱에 안전하게 분산할 수 있는, 보안된, 자동 업데이트된 앱을 편리하게 배포할 방법이 절실합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10년 전에는 이 기사를 쓴다고 사형당했을 겁니다. 지금에도 약간의 불만소리가 예상되지만, 최근에는 웹을 비판하는 것이 사회적으로 수용되는 것이 되었습니다. 그때는 웹이 Flash, Shockwave 및 Java와 같은 다른 독점적 플랫폼과 경쟁하고 있었습니다. 웹은 열려 있었지만 경쟁 플랫폼으로의 생존은 분명하지 않았습니다. 그러나 최종적으로 부활하고 승리하는 이야기는 우리 모두의 감정을 자극하는 계산된 이야기입니다: 열린 것이 폐쇄된 것보다 낫고, 집단 소유권이 독점보다 낫고, 다윗이 골리앗을 이길 수 있다는 것 등입니다. 많은 프로그래머들은 그것에 대해 족속적 충성심을 느끼게 되었습니다. \"웹\"이라는 단어 앞에 붙이면 급증이었습니다. 매크로미디어 플래시가 실제로 좋을지도 모른다고 제안하면 당신의 게크 카드가 취소될 겁니다.\n\n그러나 시대는 변하고 있습니다. 지금은 웹이 너무 비대해져서 열려있다고 부르는 것은 상당히 의미가 없어졌습니다: 몇 십억 달러를 태우고 싶다면 HTML5를 구현할 수있는 가능성이 없습니다. W3C는 사용자의 요구를 충족시키지 못했으며 지금은 관련이 없어졌습니다. 따라서 구글이나 마이크로소프트에서 일하지 않는 한 웹의 기술적 방향에 의미있는 영향을 미칠 수는 없습니다. 이전에는 닫혀 있던 몇 가지 경쟁 플랫폼도 오픈되었습니다. 그리고 자바스크립트 생태계는 자신의 의미없는 순환의 무게 아래서 붕괴하고 있습니다.\n\n드로잉 보드로 돌아가는 시간입니다. 이제 음료를 가져오고이 시리즈의 다음 기사를 읽어보세요: 웹의 후속편은 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-27-Itstimetokilltheweb_0.png"},"coverImage":"/assets/img/2024-06-27-Itstimetokilltheweb_0.png","tag":["Tech"],"readingTime":9},{"title":"Apple Watch와 위젯을 지원하는 React Native 앱 개발 방법","description":"","date":"2024-06-27 14:23","slug":"2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport","content":"\n\n## 사용자들의 손목에 앱을 확장해보세요\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*I9arFpW6WbVftid8urPmfQ.gif)\n\nReact Native를 사용하여 모바일 앱을 개발하는 것을 모두가 좋아합니다. 왜냐하면 iOS 및 Android 애플리케이션에 널리 사용되는 크로스 플랫폼 통합을 제공하기 때문이죠. 하지만 더 흥미로운 사실을 아시나요?\n\n맞죠! React Native 애플리케이션에서 스마트 워치 기기도 지원한다는 것이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 Apple watchOS 애플리케이션을 React Native 애플리케이션과 통합하는 방법을 배우겠습니다. 더불어, 워치 페이스의 복잡성으로 설정할 수 있는 위젯도 생성할 것입니다.\n\n# 준비물\n\n- React Native, Xcode 및 SwiftUI의 기본 지식\n- watchOS를 지원하는 장치 시뮬레이터가 포함된 Xcode\n\n# 개발 환경 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwatchOS 앱을 React Native 앱에 추가하기 위해 Apple에서 제공하는 IDE인 Xcode를 사용할 거에요.\n\n더불어, Apple이 제공하는 프레임워크인 WatchKit을 사용할 거에요. WatchKit을 이용하면 watchOS 앱을 만들고, 다른 Apple 기기의 앱과 연결하여 작동시킬 수 있어요.\n\n## watchOS 및 위젯을 위한 필수 종속성 설치\n\niOS와 watchOS 앱 간 통신을 구현하기 위해 react-native-watch-connectivity라는 라이브러리를 사용할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 패키지를 설치하려면 프로젝트에 따라 yarn 또는 npm을 사용할 수 있습니다:\n\n```js\nnpm install react-native-watch-connectivity --save\n```\n\n```js\nyarn add react-native-watch-connectivity\n```\n\n코코아팟도 설치하는 것을 잊지 마세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd ios \u0026\u0026 pod install \u0026\u0026 cd ..\n```\n\n다음으로, 우리는 플러스 및 마이너스 버튼이 있는 카운트 변수를 갖는 매우 기본적인 React Native 화면을 생성할 것입니다.\n\n# watchOS 앱 지원 추가\n\n이제 iOS 앱을 설정했으므로, watchOS 앱을 개발하기 시작해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXcode를 열어 iOS 프로젝트를 엽니다. 툴바에서 File - New - Target를 선택합니다.\n\n다음 창이 표시됩니다: 상단 탭에서 watchOS를 선택한 다음 해당 탭에서 App을 선택합니다.\n\n![이미지](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png)\n\n다음으로, watchOS 앱에 대한 자세한 정보를 제공하는 또 다른 창이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 창에서 워치OS 앱의 앱 이름과 번들 식별자를 제공해주세요.\n\n위의 창에서는 이미 기존의 iOS 앱이 있는지 여부를 선택할 수 있습니다. 우리의 경우 iOS 앱 프로젝트가 설정되어 있습니다. 그래서 Watch App for Existing iOS App을 선택하고 아래 드롭다운에서 iOS 앱의 타겟을 선택하겠습니다.\n\nFinish 버튼을 클릭한 후에는 Xcode 프로젝트에 새 폴더가 추가된 것을 알 수 있습니다. 해당 폴더에는 우리의 watchOS 프로젝트 파일이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 워치OS 앱의 UI 디자인\n\n이제 워치OS 애플리케이션의 UI를 디자인하기 시작합니다. 시작하려면 SwiftUI 코드가 포함된 ContentView.swift 파일을 열어주세요.\n\n우리의 SwiftUI 코드에서는 카운터의 값이 표시되는 간단한 텍스트 요소를 표시할 것입니다.\n\n우리의 ContentView는 다음과 같이 보여야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기능 구현하기\n\n이제 iOS 앱과 watchOS 앱 사이의 양방향 통신 메커니즘을 설정해 봅시다.\n\n## iOS 앱에서 watchOS 앱으로 메시지 보내기\n\n- iOS 앱이 발신자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워치OS 앱에 메시지를 보내려면 React Native 앱에 설치된 패키지를 사용해야 합니다.\n\nreact-native-watch-connectivity에서 sendMessage 및 getReachability 함수를 가져와서 시청 가능한 워치여부를 결정하고 count 변수를 워치OS 앱으로 보내기 위해 사용할 수 있습니다.\n\n다음과 같이 버튼 액션을 수정할 것입니다:\n\n- 수신자로서 워치OS 앱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwatchOS 앱이 iOS 앱에서 전송된 메시지를 수신하도록 설정하려면 새 Swift 파일을 만들어 ConnectionHelper.swift로 이름을 지정합시다. 이 클래스를 사용하여 iOS 앱에서 보내는 메시지와 이벤트를 캡처할 것입니다.\n\n먼저 ConnectionHelper라는 클래스를 만들고 그 안에 워치 세션과 이벤트를 설정하겠습니다.\n\n이 코드는 필수 메서드를 구현하도록 강제하여 오류를 발생시킬 것입니다. 우리의 클래스에서 워치 세션 델리게이트를 위해 필요한 메서드를 구현해야 합니다.\n\n코드를 깨끗하게 유지하기 위해 ConnectionHelper 클래스의 확장(extension)을 만들고 거기에 WCSessionDelegate를 구현하세요. 확장(extension)은 아래 표시된 메서드를 반드시 구현해야 한다는 필수 조건이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 WCSession의 활성화 상태에 변경이 있는지 표시하는 데 유용합니다. 이것은 iOS 앱과 페어링된 Apple Watch 간의 통신이 현재 활성화되어 있는지 확인할 수 있다는 뜻입니다. 그렇지 않으면 오류가 발생합니다.\n\n다음 단계는 iOS 앱에서 watchOS 앱으로 전송되는 이벤트 및 메시지를 가져오는 것인데, 이를 위해 확장에서 didReceiveMessage 메서드를 구현할 것입니다. 이제 우리의 ConnectionHelper 확장은 다음과 같이 보여야 합니다:\n\n위에서 선언한 방법을 사용하여 카운터의 값이 업데이트될 것입니다. 먼저 ConnectionHelper 클래스 내에 선언해 봅시다. 이제 우리의 클래스는 다음과 같이 보여야 합니다:\n\n변수 count를 선언하고 Published로 주석을 달고 ObservableObject 프로토콜을 클래스에 구현했습니다. 왜냐하면 이 count 변수가 변경될 때마다 추적하고 싶기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 iOS 앱에서 이벤트를 받을 때마다 count 값을 업데이트하는 로직을 구현해야 합니다. 이를 위해 ConnectionHelper 확장에서 정의한 didReceiveMessage 메서드를 사용할 것입니다.\n\n이제 우리가 counter 변수를 생성했으니, watchOS 앱의 UI 내에서 그것을 사용할 시간입니다. ContentView에서 ConnectionHelper 클래스를 인스턴스화하고 count 속성을 사용하여 텍스트 요소 아래에 표시합니다.\n\n이제 iOS 앱에서 watchOS 앱으로의 일방향 통신이 완료되었습니다.\n\n## watchOS 앱에서 iOS 앱으로 메시지 보내기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- watchOS 앱을 보낸 사람\n\nwatchOS 앱에서 iOS 앱으로 메시지를 보내기 위해, 먼저 ConnectionHelper 클래스 내부에 도우미 함수를 만들겠습니다. 이 함수는 watchOS로부터 이전에 생성한 watch 세션을 통해 count 변수를 메시지로 iOS 앱으로 보낼 것입니다.\n\n다음으로, ContentView 파일을 수정하여 +와 - 텍스트가 있는 버튼을 추가하고 해당 버튼에 동작을 추가할 것입니다. 아래 코드 스니펫에서 보시다시피, count 변수를 수정하고 sendNewCount 함수를 사용하여 iOS 앱으로 전송할 것입니다.\n\n그러나 기다려주세요! 아직은 iOS 앱을 설정하여 watchOS 앱에서 보낸 메시지를 수신할 준비를 마치지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **수신기로 사용되는 iOS 앱**\n\n이러한 수신 메시지를 처리하기 위해서는 먼저 react-native-watch-connectivity 패키지에서 가져온 watchEvents를 사용하여 메시지를 수신 대기해야 합니다.\n\n만세! 여기까지입니다. 이제 두 앱을 실행시켜서 한번 시도해보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1076/1*PqaAgPuCgE1W_RGKEC9r7Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 워치OS 애플리케이션에 위젯 추가하기\n\n## 위젯 익스텐션 타겟 설정\n\n우리의 워치OS 앱에 위젯 지원을 도입하려면 동일한 Xcode 프로젝트에 새로운 타겟을 생성해야 합니다.\n\n프로젝트에 '위젯 익스텐션'이라는 새로운 타겟을 추가할 것이며, 이는 워치OS 타겟과 유사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ReactNativeAppwithAppleWatchWidgetSupport image 2](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_2.png)\n\n다음을 클릭한 후 위젯 대상의 제품 이름을 제공하십시오.\n\n![ReactNativeAppwithAppleWatchWidgetSupport image 3](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_3.png)\n\n위젯 확장 대상을 설정한 후 프로젝트에 새 폴더가 표시됩니다. 이 경우 CounterWidget이라는 이름의 폴더가 있습니다. 이 폴더에는 처음에 AppIntent 및 CounterWidget이라는 두 개의 Swift 파일이 포함되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_4.png\" /\u003e\n\n## 위젯 UI 및 기능 설계 및 구현\n\nUI를 수정하기 전에 먼저 위젯 확장에 count 변수를 설정해보겠습니다.\n\n이를 위해 AppIntent 파일을 열고 currentCount라는 변수를 선언하고 다음 코드 스니펫에 표시된대로 생성자를 설정해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯 UI를 디자인하기 위해 CounterWidget 파일을 열어보세요. 위젯 확장을 생성할 때 Xcode에서 자동으로 생성한 EntryView로 스크롤하세요. 아래에 보여지는 대로 현재 카운트 변수를 보여줄 매우 간단한 텍스트 구성요소를 만들 것입니다:\n\n## watchOS 앱과 위젯 확장 간의 데이터 교환 및 공유\n\n이제 watchOS 앱에서 선언된 현재 카운트 변수를 위젯 UI에 표시하려고 합니다. 그러나 Apple은 watchOS 앱과 위젯 간에 데이터를 교환할 수 있는 직접적인 방법을 제공하지 않습니다. 따라서 우리는 Apple이 제공하는 로컬 저장소인 UserDefaults에 카운트 변수를 저장할 것입니다.\n\nwatchOS 앱과 위젯 확장 사이에서 공유할 단일 속성을 추가하려면 watchOS와 위젯 확장 모두에 App Groups이라는 새 능력을 추가해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 방법을 수행하려면, 프로젝트 설정을 열고, 타겟을 선택한 다음, Signing \u0026 Capabilities 탭을 선택하세요. 그러면 + Capability 버튼을 클릭하여 그 창에서 타겟을 선택하세요.\n\n![image](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_5.png)\n\nApp Groups을 기능으로 추가한 후에는, 이 창 안에 이 섹션이 표시될 것입니다. 이제 + 버튼을 눌러 식별자를 추가하세요.\n\n![image](/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 여러 대상에서 사용되고 프로젝트에서 데이터가 저장되고 사용될 컨테이너에 대한 유효한 식별자(또한 UserDefaults의 스위트 이름으로 사용될 것)를 제공해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_7.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_8.png\" /\u003e\n\nCounterWidget 파일에는 사용자 인터페이스(UI)를 관리하는 모든 로직과 해당 기능이 포함될 것입니다. 그러나, 주요 기능은 지정된 간격으로 위젯의 UI를 새로 고치는 timeline 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞으로 나아가면, 우리 앱 그룹이 준비되었으니, watchOS 앱과 위젯 익스텐션 간에 데이터를 공유하기 위한 메커니즘을 설정해 봅시다.\n\nwatchOS 타겟 폴더에 선언된 ConnectionHelper 클래스 내부에 appCount라는 새 변수를 선언할 것이며, 이 변수는 UserDefaults를 사용하여 AppStorage로 주석이 달릴 것입니다. 아래와 같이:\n\n또한, appCount 변수가 작동하도록 하기 위해, count가 변경될 때마다 새로운 값을 할당할 것입니다.\n\n다음 단계에서, 위젯의 UI 내에 이를 표시하고 싶다면, 위젯의 Timeline Provider를 수정해야 합니다. 이를 위해 CounterWidget 파일 내의 미리 생성된 Provider 구조로 이동하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 해당 구조체의 범위 내에서 appCount 변수를 선언하고 프로바이더 함수를 아래와 같이 수정해야 합니다:\n\n찬양하리로다! 우리는 성공적으로 watchOS 앱의 위젯 확장 프로그램을 설정하여 카운트 값을 표시했습니다. 이제 실행해서 시도해 보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:554/1*4W6YaN1I5FIM0FKJHUZ2BA.gif)\n\n이제 iOS 애플리케이션에서 카운트를 수정해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1196/1*u8y-X3CelS4YDm0JLFuIdg.gif)\n\n# 결론\n\nReact Native 앱을 watchOS와 연동하고 워치 페이스용 위젯을 지원하는 데 성공했습니다.\n\n이제 WatchKit과 WidgetKit을 사용하여 멋진 앱을 만들어보세요. 아이디어와 프로젝트를 아래 댓글에서 공유해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩! 😉","ogImage":{"url":"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png"},"coverImage":"/assets/img/2024-06-27-ReactNativeAppwithAppleWatchWidgetSupport_0.png","tag":["Tech"],"readingTime":8}],"page":"3","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>