<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/17" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/17" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="모조 파이썬보다 100만 배 빠른 언어, 드디어 등장" href="/post/2024-06-22-MojoAmillionTimesFasterThanPythonFinally"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모조 파이썬보다 100만 배 빠른 언어, 드디어 등장" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MojoAmillionTimesFasterThanPythonFinally_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모조 파이썬보다 100만 배 빠른 언어, 드디어 등장" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모조 파이썬보다 100만 배 빠른 언어, 드디어 등장</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="복잡한 리스트 컴프리헨션도 읽기 쉽게 만드는 방법" href="/post/2024-06-22-ComplexListComprehensionsCanBeReadable"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="복잡한 리스트 컴프리헨션도 읽기 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ComplexListComprehensionsCanBeReadable_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="복잡한 리스트 컴프리헨션도 읽기 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">복잡한 리스트 컴프리헨션도 읽기 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주말 동안 스킬을 향상시킬 5가지 파이썬 프로젝트" href="/post/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주말 동안 스킬을 향상시킬 5가지 파이썬 프로젝트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주말 동안 스킬을 향상시킬 5가지 파이썬 프로젝트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">주말 동안 스킬을 향상시킬 5가지 파이썬 프로젝트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 해시 테이블 구현하기 단계별 가이드" href="/post/2024-06-22-ImplementingaHashTableinPythonStep-by-Step"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 해시 테이블 구현하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 해시 테이블 구현하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬으로 해시 테이블 구현하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="퀀트 투자  알파 리서치를 위한 요소 구성 방법 피처 엔지니어링" href="/post/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="퀀트 투자  알파 리서치를 위한 요소 구성 방법 피처 엔지니어링" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="퀀트 투자  알파 리서치를 위한 요소 구성 방법 피처 엔지니어링" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">퀀트 투자  알파 리서치를 위한 요소 구성 방법 피처 엔지니어링</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JAX를 배워야 하는 이유 분자 동역학 쇼케이스" href="/post/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JAX를 배워야 하는 이유 분자 동역학 쇼케이스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JAX를 배워야 하는 이유 분자 동역학 쇼케이스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JAX를 배워야 하는 이유 분자 동역학 쇼케이스</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" href="/post/2024-06-22-SetUpandRunaSimpleNodeServerProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="간단한 Nodejs 서버 프로젝트 설정 및 실행 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">간단한 Nodejs 서버 프로젝트 설정 및 실행 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" href="/post/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Expressjs 프로젝트를 AWS EC2에 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Expressjs 프로젝트를 AWS EC2에 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" href="/post/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" href="/post/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link posts_-active__YVJEi" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"모조 파이썬보다 100만 배 빠른 언어, 드디어 등장","description":"","date":"2024-06-22 14:21","slug":"2024-06-22-MojoAmillionTimesFasterThanPythonFinally","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-MojoAmillionTimesFasterThanPythonFinally_0.png\" /\u003e\n\n인공지능 개발의 속도를 가속화하는 대담한 움직임으로, 모듈러 인코퍼레이티드가 Mojo의 핵심 구성 요소를 오픈소스로 공개했습니다. 이는 2024년 3월 29일자로 이뤄졌습니다. Mojo는 2023년 8월에 출시되었을 때 기술 세계를 매혹시키며 새롭게 등장한 프로그래밍 언어로, 인공지능 애플리케이션을 위해 특별히 제작되었습니다. Mojo는 간단함과 강력한 성능의 결합을 약속하며 출시되었음에도 불구하고, 곧 사랑받는 언어가 되어 175,000명 이상의 개발자와 50,000개 이상의 기관을 끌어들였습니다.\n\n# 🌟 제 독자를 위한 특별 제공 🌟\n\n# Mojo 해체: 인공지능 개발자의 꿈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMojo는 종종 여러 프로그래밍 언어를 다루는 일반적으로 복잡한 AI 개발 환경을 간단하게 만들어 줍니다. 개발자들은 보통 기본적인 신경망 구조를 만드는 데 파이썬에 의존해 왔습니다. 파이썬은 간단한 구문 때문에 선택되었지만 실행 속도가 느린 편입니다. 보다 무거운 작업에는 성능이 빠른 C++을 사용해 왔으나, 학습 곡선이 더 가파른 점이 단점으로 지적되었습니다.\n\nMojo가 등장했습니다. 편의성과 효율성 사이의 간격을 좁히기 위해 디자인된 Mojo는 Python과 유사한 구문을 제공하면서 성능 면에서 C++을 수천 배로 앞서는 성능을 약속합니다. 이 독특한 조합은 더 복잡한 언어의 난해함을 극복하지 않고도 빠른 AI 모델을 개발할 수 있도록 돕습니다.\n\n# 오픈 소스로의 여정: 게임 체인저\n\nMojo를 오픈 소스로 공개하기로 한 결정은 가벼운 마음으로 내린 것이 아니었습니다. 지난 한 해 동안, 오픈 소스 버전을 기다리는 기다림과 요구가 증가하면서, Discord와 같은 플랫폼에서 활기찬 토론이 벌어졌습니다. 의심하는 사람들과 열렬한 팬들 모두가 전략적인 결정에 대해 의문을 제기하며 커뮤니티에서 도구를 완전히 받아들이기를 주저하고 있었습니다. 오늘, 그러한 우려는 Modular Inc.가 Mojo를 공개할 뿐 아니라 투명성과 협업을 위한 약속과 함께 이를 실천한다는 것으로 안심됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMojo의 표준 라이브러리를 오픈 소스로 공개하는 것은 어떤 프로그래밍 언어의 중요한 기반입니다. 이 라이브러리는 AI 하이퍼파라미터를 최적화하는 데 필수적인 기능들로 가득하며, 아직 개발 중이라는 점에서 모듈러가 글로벌 개발자 커뮤니티와 함께 전진하고 싶어하는 역동적이고 발전 중인 프로젝트를 반영하고 있습니다.\n\n# 오픈 소스 전략: 단순히 코드 공유 이상\n\nModular의 오픈 소스 전략은 코드를 공유하는 것 이상으로 나아갑니다. 이는 GitHub 풀 리퀘스트를 통한 외부 기여를 허용하고,\n첫 번째 커밋부터 명확하고 투명한 변경 이력을 유지하며,\nMojo 컴파일러의 매일 빌드를 제공하여 최신 기능을 손쉽게 테스트하고 통합할 수 있도록 하는 견고한 프레임워크를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앞으로는 무엇이 있을까요? AI 플랫폼 MAX와 더 많은 것들\n\n앞으로 모듈러는 Mojo로 그치지 않을 것입니다. 이미 MAX의 일부 구성 요소를 점진적으로 오픈 소스로 공개하는 계획이 있습니다. MAX는 Kubernetes를 포함한 다양한 하드웨어 환경에서 고성능 AI 애플리케이션을 구축하고 배포하기 위한 포괄적인 툴킷을 제공하도록 설계되었습니다.\n\n# 라이선싱 및 향후 계획\n\nModular는 Apache 2 LLVM 라이선스를 채택하면서 이 프레임워크를 조정하여 GPL2 라이선스로 된 소프트웨어와의 호환성을 확보하여 Mojo의 다양한 프로젝트에서 Linux 커널 코드와 상호 작용하는 것을 포함한 적응성을 향상시켰습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AI 미래에서 Mojo의 위치\n\nMojo의 인상적인 성과, Python보다 최대 90,000배 빠르다는 주장과 같은 벤치마크는 Mojo를 AI 프로그래밍에서 잠재적으로 혁신적인 힘으로 만들고 있습니다. MLIR의 발전적인 라인에서 나온 LLVM의 최신 컴파일러 기술을 기반으로 하고 있는 Mojo는 AI 개발에서 성능 기준을 재정의할 준비가 되어 있습니다.\n\n우리가 새로운 시대의 바깥 가장자리에 서 있는 지금, Modular은 글로벌 개발자 커뮤니티를 초대하여 Mojo를 개선하고 확장하는 데 참여할 것을 권유합니다. Mojo의 핵심이 이제 세계에 공개되어 있기 때문에 Mojo는 단순히 도구가 아니라 AI 역경에서 성장하는 움직임입니다. 다음 50년 동안 AI를 위한 선호 언어가 될까요? 시간이 알려줄 것이지만, 거기로의 여정은 기술 자체만큼 혁신적일 것으로 기대됩니다.\n\n도움이 되었다면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 50박수로 사랑을 표현해주세요!\n- 댓글을 남겨주세요.\n- 가장 좋아하는 부분을 공유해주세요!\n\nAppMillers에서 제 온라인 강좌를 더 알아보세요 🚀\n\nLinkedIn: Elshad Karimov와 연결해보세요\n\nX (트위터) 팔로우: Elshad Karimov\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**최신 기술 동향을 받아보려면 뉴스레터를 구독하세요: 엘샤트 카리모프의 Newsletter**\n\n# 스택아데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해주세요! 👏\n- 저희 다른 플랫폼도 방문해주세요: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠를 확인하세요. ","ogImage":{"url":"/assets/img/2024-06-22-MojoAmillionTimesFasterThanPythonFinally_0.png"},"coverImage":"/assets/img/2024-06-22-MojoAmillionTimesFasterThanPythonFinally_0.png","tag":["Tech"],"readingTime":3},{"title":"복잡한 리스트 컴프리헨션도 읽기 쉽게 만드는 방법","description":"","date":"2024-06-22 14:18","slug":"2024-06-22-ComplexListComprehensionsCanBeReadable","content":"\n\n## PYTHON PROGRAMMING\n\n![image](/assets/img/2024-06-22-ComplexListComprehensionsCanBeReadable_0.png)\n\nPython comprehensions — including list, dictionary, and set comprehensions as well as generator expressions — constitute a powerful Python syntactic sugar. You can read about them in the following articles:\n\nPython comprehensions have two great advantages when compared to the corresponding for loops: they are faster and they can be much more readable.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 \"훨씬 더 가독성이 높을 수 있습니다\"라는 구절을 유의해주세요. 실제로 항상 더 가독성이 높은 것은 아닙니다. 그렇다면, 언제 가독성이 높아질까요?\n\n그것은 당신에 달렸습니다. 파이썬 컴프리헨션의 가독성은 개발자인 여러분이 결정합니다. 무심코 구현하는 것은 컴프리헨션의 가독성을 해치지만 for 루프에 대해서도 동일하게 말할 수 있습니다.\n\n파이썬에서 컴프리헨션은 영어 문장을 읽는 것과 매우 유사하게 읽도록 디자인되었습니다: 컴프리헨션은 왼쪽에서 오른쪽으로 (또는 여러 줄을 사용할 경우 위에서 아래로) 읽을 수 있습니다. 마치 영어 문장을 왼쪽에서 오른쪽으로 읽는 것과 같이요.\n\n많은 사람들은 복잡한 컴프리헨션을 사용해서는 안 된다고 말합니다. 이 기사에서는 이 범주에 속하는 잘 알려진 원칙 - 혹은 신화라고 해도 좋을 것 같습니다. 유감스럽게도, 많은 사람들은 성공적으로 사용될 수 있는 상황에서 파이썬 컴프리헨션을 지나치게 회피함으로써 이 원칙을 무리하게 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 읽기 이해\n\n나는 Python 내포를 알고리즘으로 생각하는 것을 좋아해요: 데이터 작업이 하나 이상의 루프에서 수행된 후 선택적인 조건 또는 여러 조건이 따라옵니다. 그러한 이해 방식은 내포를 이해하는 데 크게 도움이 됩니다, 비록 그것이 꽤 길고 복잡하다 해도요.\n\n기억하세요, Python 내포는 항상 다음 패턴을 사용합니다: 데이터 작업 → 루프(들) → 선택적 조건(들). 우리는 내포를 분석할 때마다 이로 돌아오겠어요.\n\n이 규칙에는 예외가 있어요. 월러스 연산자를 사용할 때, 이 알고리즘 패턴을 약간 변경해야 할 필요가 있는데요; 나중에 이에 대해 자세히 다룰 거에요. 그럼에도 불구하고, 연습을 많이 하면 이 변경이 큰 도전이 되지 않을 거에요, 알고리즘은 큰 가독성을 잃지 않을 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 사용 사례\n\n매우 간단한 예제를 고려해봅시다. 숫자 목록 x가 주어졌을 때, x의 제곱 요소 목록을 만들고 싶습니다. 이 작업은 보통의 for 루프를 사용하여 수행할 수 있습니다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 5, 100]\n\u003e\u003e\u003e x_squared = []\n\u003e\u003e\u003e for xi in x:\n...     x_squared.append(xi**2)\n\u003e\u003e\u003e x_squared\n[1, 4, 25, 10000]\n```\n\n두 번째 줄부터 코드를 읽어봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 먼저 비어있는 출력 리스트 x_squared를 만들어요. 이름 자체가 리스트가 어떤 내용을 포함할지를 말해줘요.\n- for 루프가 실행되는데, 각 반복은 xi에 대해 실행되며, xi의 값은 x 리스트의 연속 요소로 구성돼요.\n- 각 반복에서 우리는 xi**2를 출력 리스트 x_squared에 추가해요.\n\n해당 리스트 컴프리헨션을 고려해 봅시다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 5, 100]\n\u003e\u003e\u003e x_squared = [xi**2 for xi in x]\n\u003e\u003e\u003e x_squared\n[1, 4, 25, 10000]\n```\n\n이 간단한 예제에서 보듯이 컴프리헨션은 한 줄만 필요해요. 여기서 읽을 수 있는 방법은 다음과 같아요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 각 xi에 대해 xi**2를 계산하여 x 목록의 연속적인 값으로 결과를 출력 목록에 수집합니다.\n\n그게 다에요! 명확하고, 명백하며, 읽기 쉽습니다. 우리가 사용한 패턴을 주목했나요? 데이터 작업 → 반복이 아주 간단합니다.\n\n초보자들에게는 그렇게 명확하고 명백하며 읽기 쉽지는 않을 수 있습니다. 그러나 프로그래밍 언어를 배우고 그 강점을 활용하려면 연습이 필요합니다. 그런 다음에야 언어의 강점인 구문 슈가(Python 컴프리헨션과 같이)을 정말로 활용할 수 있습니다.\n\n진짜야: Python을 사용하고 싶다면 컴프리헨션을 사용하고 이해할 수 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 컴프리헨션을 자연스럽고 읽기 쉽지 않다고 생각하지 않더라도 계속 시도해보세요. Sooner or later, you’ll see in them what advanced Pythonistas see: simplicity joined with brevity and readability. 계속 노력해주세요.\n\n이것은 매우 간단한 사용 사례였지만, 사실은 이러한 컴프리헨션은 파이썬의 실무에서 매우 흔합니다. 우리는 if 문을 추가하여 조건을 추가함으로써 좀 더 복잡하게 만들어 볼 수 있습니다. 이 경우 홀수만 가져와서 xi % 2 != 0인 수만 가져와 봅시다. 이를 위해 for 루프를 다음과 같이 수정할 수 있습니다:\n\n```python\n\u003e\u003e\u003e x = [1, 2, 5, 100]\n\u003e\u003e\u003e x_squared = [xi**2 for xi in x if xi % 2 != 0]\n\u003e\u003e\u003e x_squared\n[1, 25]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서요:\n\n- 이전과 마찬가지로 빈 출력 목록인 x_squared를 생성하십시오.\n- for 루프가 실행되며, 각 반복은 xi에 대해 실행되고, xi의 값은 x 목록의 후속 요소를 구성합니다.\n- 각 반복에서 xi가 홀수인지 확인합니다. 그렇다면 xi**2 값을 출력 목록 x_squared에 추가합니다. 그렇지 않으면 xi는 무시됩니다.\n\n해당하는 리스트 컴프리헨션을 사용해 봅시다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 5, 100]\n\u003e\u003e\u003e x_squared = [xi**2 for xi in x if xi % 2 != 0]\n\u003e\u003e\u003e x_squared\n[1, 25]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한번 읽어 봅시다:\n\n- x 목록의 연속 값 xi에 대해 xi**2을 계산합니다.\n- 홀수 값 xi의 결과를 출력 목록에 수집합니다.\n\n위의 두 가지 상황에서도 목록 내포 버전이 더 간편하게 읽힌다고 생각합니다. for 루프를 사용하면 전체 코드를 읽어야 하며, 다양한 작업이 코드 전반에 흩어져 있습니다. 반면 목록 내포는 모든 작업을 전형적인 패턴에 모아 넣은 간결한 한 줄로 이루어져 있습니다: 데이터 작업 → 루프 → 조건.\n\n이러한 간단한 상황들이었습니다. 그러나, 파이썬 내포의 가독성이 떨어질 수 있는지도 알려진 사실은, 여러 층으로 중첩되어 복잡해진 경우입니다 (즉, 루프 안에 루프를 생성). 이러한 예제에 대해 다음 섹션에서 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 고급 사용 사례\n\n이번에는 보통 대응하는 목록 내포보다 조금 더 복잡하게 작성하고 읽기 어려운 사전 내포를 사용해보겠습니다. 또한 하나의 루프와 두 개의 if 문을 사용할 것입니다.\n\n다음 데이터로 작업할 것입니다:\n\n```js\n\u003e\u003e\u003e products = [\n...     \"위젯\", \"가제트\", \"띵가마직\",\n...     \"두다드\", \"무엇\",\n... ]\n\u003e\u003e\u003e prices = [19.99, 25.50, 9.99, 20.00, 22.50]\n\u003e\u003e\u003e discounts = [0.10, 0.25, 0.05, 0.20, 0.15]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n할인율이 최소 15%이고 가격이 $20에서 $30 사이인 제품에 대한 가격을 포함하는 사전을 만들고 싶습니다.\n\n일반적인 for 루프부터 시작해봅시다:\n\n```js\n\u003e\u003e\u003e discounted_products = {}\n\u003e\u003e\u003e prod_price_disc = zip(products, prices, discounts)\n\u003e\u003e\u003e for product, price, discount in prod_price_disc:\n...     if discount \u003e= 0.15 and 20 \u003c= price \u003c= 30:\n...         discounted_products[product] = price\n\u003e\u003e\u003e discounted_products\n{'Gadget': 25.5, 'Doodad': 20.0, 'Whatsit': 22.5}\n```\n\n위 코드를 이렇게 이해할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 먼저, 우리는 조건을 충족하는 제품들을 수집할 출력용 딕셔너리인 discounted_products를 초기화해야 합니다.\n- 그런 다음 제품 이름, 가격 및 할인을 동시에 반복하는 for 루프를 생성합니다. 이를 위해 zip() 함수를 사용하여 zip 객체를 만들어야 합니다.\n- 루프 내에서 모든 제품의 할인이 적어도 15% (할인 `= 0.15)이고 가격이 $20에서 $30 사이에 있는지 두 가지 조건을 확인합니다.\n- 두 조건이 모두 충족되면 제품과 해당 가격을 discounted_products 딕셔너리에 추가하며, 제품은 키가 되고 가격은 값이 됩니다.\n\n내가 본 바에 의하면 꽤 간단한 연습이지만 for 루프를 기반으로 한 코드는 비례적으로 간단하지는 않습니다. 따라서 해당하는 딕셔너리 컴프리헨션을 살펴보겠습니다:\n\n```js\n\u003e\u003e\u003e discounted_products = {\n...     product: price\n...     for product, price, discount\n...     in zip(products, prices, discounts)\n...     if discount \u003e= 0.15 and 20 \u003c= price \u003c= 30\n... }\n\u003e\u003e\u003e discounted_products\n{'Gadget': 25.5, 'Doodad': 20.0, 'Whatsit': 22.5}\n```\n\n보시다시피, 두가지 접근방식 모두 동일한 결과를 도출합니다. 코드를 읽어보죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전체 과정이 하나의 사전 컴프리헨션으로 압축됐어요. 하지만 매우 긴 줄을 받아들이는 준비가 되어 있지 않다면 한 줄에 맞지 않을 거예요. 저는 이렇게 너무 긴 한 줄보다 위에서 보여준 for 루프가 더 읽기 쉬울 수 있다고 생각해요.\n- 이 컴프리헨션을 해독하는 방법은 다음과 같아요. 제품(키)과 가격(값)을 가져와서, 제품, 가격 및 할인을 동시에 반복하면서 해당 zip 객체를 사용해서 할인 제품 그룹(할인 적용된 제품)을 만들어내는 zip() 함수를 사용해요 — 단, 두 가지 조건을 만족해야 해요. 각 제품의 할인이 적어도 15%여야 하고(discount `= 0.15) 가격은 $20부터 $30 사이여야 해요(20 `= price `= 30).\n- 이러한 키-값 쌍은 할인 된 제품(discounted_products)이라는 출력 사전에 보관돼요.\n\n나에게는 컴프리헨션 코드가 사전 구축, 데이터 처리, 루핑 및 조건 검사를 하나로 통합한 명확한 편이에요. 이제 하나의 줄이 아니지만 결과 코드는 여전히 매우 읽기 쉽고, 전체 과정을 우리가 이전에 사용한 알고리즘 패턴을 사용하여 구현해요: 데이터 처리 → 루프 → 조건. 두 가지 조건이 하나의 if 조건으로 압축돼 있음을 유의해요. 두 if 문을 쉽게 사용할 수도 있지만(이는 코드의 양 버전 모두에 적용됨), 여러분이 선택해야 할 것은 가독성입니다.\n- 즉, Python 컴프리헨션에서 a if b는 a and b와 동일한 의미를 갖습니다. 두 가지 해법의 벤치마킹이 결론적인 결과를 제공하지 않았기 때문에 선택은 가독성에 따라 달라져야 해요.\n\n더 나아가서 두 개의 중첩된 for 루프를 사용하는 더 복잡한 시나리오를 고려해볼게요. 이것이 사용할 데이터에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e products = ['사과', '바나나', '체리', '데이트']\n\u003e\u003e\u003e prices = [25, 15, 22, 35]\n\u003e\u003e\u003e discounts = [0.20, 0.10, 0.15, 0.25]\n\u003e\u003e\u003e locations = ['동쪽', '서쪽', '북쪽', '남쪽']\n\u003e\u003e\u003e available_in = [\n...     ['동쪽', '북쪽'],\n...     ['서쪽'],\n...     ['남쪽', '동쪽'],\n...     ['북쪽']\n... ]\n```\n\n가게가 네 곳에 있지만 제품은 특정 위치에만 한정적으로 판매됩니다. 'available_in' 목록에는 제공된 위치의 리스트로 제공됩니다. 따라서, 예를들어 사과는 동쪽과 북쪽 가게에서만 사용할 수 있고 바나나는 서쪽 가게에서만 사용할 수 있습니다. 이 조건을 따라 제품 및 해당 조건을 따라 가격을 적용해야 합니다.\n\n다음은 for 루프입니다:\n\n```js\n\u003e\u003e\u003e discounted_products = {}\n\u003e\u003e\u003e zipped = zip(products, prices, discounts, available_in)\n\u003e\u003e\u003e for product, price, discount, locations in zipped:\n...     for location in locations:\n...         cond1 = discount \u003e= 0.15\n...         cond2 = 20 \u003c= price \u003c= 30\n...         cond3 = location in ['동쪽', '북쪽']\n...         if cond1 and cond2 and cond3:\n...             discounted_products[(product, location)] = price\n\u003e\u003e\u003e discounted_products\n{('사과', '동쪽'): 25, ('사과', '북쪽'): 25, ('체리', '동쪽'): 22}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당하는 딕셔너리 함축 부분과 함께 테이블 태그를 마크다운 형식으로 변경하시려면 다음과 같이 작성하시면 됩니다:\n\n```js\n\u003e\u003e\u003e zipped = zip(products, prices, discounts, available_in)\n\u003e\u003e\u003e discounted_products = {\n...     (product, location): price\n...     for product, price, discount, locations in zipped\n...     for location in locations\n...     if discount \u003e= 0.15\n...        and 20 \u003c= price \u003c= 30\n...        and location in ['East', 'North']\n... }\n\u003e\u003e\u003e discounted_products\n{('Apples', 'East'): 25, ('Apples', 'North'): 25, ('Cherries', 'East'): 22}\n```\n\n세 가지 if 조건 대신에 세 개의 if 조건을 사용할 수도 있습니다:\n\n```js\n\u003e\u003e\u003e zipped = zip(products, prices, discounts, available_in)\n\u003e\u003e\u003e discounted_products = {\n...     (product, location): price\n...     for product, price, discount, locations in zipped\n...     for location in locations\n...     if discount \u003e= 0.15\n...     if 20 \u003c= price \u003c= 30\n...     if location in ['East', 'North']\n... }\n\u003e\u003e\u003e discounted_products\n{('Apples', 'East'): 25, ('Apples', 'North'): 25, ('Cherries', 'East'): 22}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 코드를 한 줄씩 설명해 드리지 않겠습니다. 스스로 시도해 보세요. 그러나 코드의 다음 측면을 강조하고 싶습니다:\n\n- 일반적인 for 루프에서는 조건 변수인 cond1, cond2 및 cond3를 정의했습니다. 이론적으로 이는 필요하지 않지만 가독성을 위해 이렇게 했습니다. 그렇지 않으면 조건이 포함된 줄은 매우 길어지거나 여러 줄로 나눠져야 했을 것입니다.\n- 딕셔너리 내장에서는 이를 할 필요가 없습니다. 세 가지 조건이 포함된 코드는 가독성이 좋지만 세 줄로 나뉩니다. 그러나 이 분할은 가독성을 저하시키지 않고 해당 데이터가 세 가지 조건을 충족해야 함을 보여줍니다.\n- 내장은 이전과 같은 패턴을 따릅니다: 연산, 루프, 조건. 다시 말하지만 일반 문장처럼 위에서 아래로 읽을 수 있습니다.\n- 추가 복잡성(두 버전 모두)은 중첩된 for 루프로 인해 도입됩니다: for location in locations. 위치별로 루핑하고 있는 것을 이해하는 것으로 충분합니다. 내게는 이 줄에는 복잡성이 너무 많이 포함되어 있지 않습니다, 적어도 중첩된 for 루프에서처럼요.\n\n이 기사의 요점은 Python 내장이 복잡한 상황에서도 간단할 수 있다는 주장을 하는 것이 아닙니다. 대신, 일부 복잡한 상황에서도 기존의 일반적인 for 루프보다 내장이 더 가독성이 높을 수 있다는 것을 보여주고 싶었습니다. 그러니까, 복잡해서 내장을 포기하기로 결정한 경우 대안을 상기시켜 주십시오. 즉, 해당 for 루프가 내지 말기로 결정한 내장보다 심지어 더 덜 가독성이 있을 수 있다는 것이죠.\n\n코드가 가독성이 좋은지 여부는 여러분의 몫입니다. 더 복잡한 상황에서는 코드가 읽기 어려워질 수 있습니다. 마지막 예제를 다시 써 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e discounted_products = {\n...     (product, location): price\n...     for product, price, discount, locations in zip(products, prices, discounts, available_in)\n...     for location in locations\n...     if discount \u003e= 0.15 and 20 \u003c= price \u003c= 30 and location in ['East', 'North']\n... }\n\u003e\u003e\u003e discounted_products\n{('Apples', 'East'): 25, ('Apples', 'North'): 25, ('Cherries', 'East'): 22}\n```\n\n이 버전은 이전 것보다 읽기 어렵지만, 나는 이것이 여전히 꽤 읽기 쉽다고 생각한다. 특히 전통적인 for 루프와 비교했을 때 요사이편한데? 중첩된 내포문이 읽기 어려운 것인가? 일반적으로 맞는 말인가요? 내가 보기에는 아무리 그래도 조금은 그럴 수 있습니다. zip() 함수의 강력함을 기억한다면, 상당히 읽기 쉬운 코드를 작성할 수 있습니다. 물론 zip 객체가 어떻게 작동하는지 알고 있다는 전제하에요.\n\n다음 예제를 고려해보세요. 복수의 for 루프가 정말 이해하기 어려울까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행 값인 x 및 열 값인 y를 사용하여 값 행렬을 계산해 보겠습니다. 이는 곱셈 표와 유사합니다.\n\n```js\n\u003e\u003e\u003e multi_table = {(x, y): x * y for x in range(10) for y in range(10)}\n\u003e\u003e\u003e multi_table[(5, 6)]\n30\n```\n\n여러 줄로 분할하여 더 가독성 있게 바꿀 수 있습니다.\n\n```js\n\u003e\u003e\u003e multi_table = {\n...     (x, y): x * y\n...     for x in range(10)\n...     for y in range(10)\n... }\n\u003e\u003e\u003e multi_table[(5, 6)]\n30\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 확실히 후자를 선호합니다. 한 명령어로 이루어진 5줄의 리스트 내포를 사용하는 것이 더 좋다고 생각해요. 각 줄이 프로세스의 개별 단계를 나타냅니다. \n\n여기에, 이것은\n\n- 데이터 작업: x*y를 계산하고 (x, y) 튜플로 저장\n- 반복문: 주어진 x 값에 대해, 주어진 y 값에 대해\n\n이겁니다. 이것은 간단한 곱셈이었지만, 첫 번째 줄을 더 고급 계산으로 바꿀 수 있고, 그러면 이러한 내포가 삶을 더 쉽게 만들고 코드를 훨씬 간단하고 가독성이 높게 만들 수 있다는 것을 알게 될 거에요.\n\n다음에 해당하는 코드보다 간단하지 않나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmulti_table = {}\nfor x in range(10):\n    for y in range(10):\n        multi_table[(x, y)] = x * y\nmulti_table\n```\n\n여기처럼 행렬을 계산해야 할 때는 zip 객체가 아닌 두 개의 루프가 필요하다는 점을 기억하세요. zip은 행렬을 계산하지 않기 때문입니다. 다음을 비교해보세요:\n\n```js\nx, y = range(3), range(3)\n[(xi, yi) for xi, yi in zip(x, y)] # list(zip(x, y))와 동일\n[(0, 0), (1, 1), (2, 2)]\n[(xi, yi) for xi in x for yi in y]\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n```\n\n이 계산 줄이 길지 않다면 이해하기 쉬운 내용일 때, 이해를 돕기 위해 리스트 내포가 항상 더 읽기 쉬울 것이라 주장하고 싶지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n월러스 연산자를 잊지 말아야합니다. 컴프리헨션 코드를 더욱 강력하게 만들 수 있죠. 파이썬 3.8 이상에서 사용 가능합니다:\n\n```js\n\u003e\u003e\u003e {\n...     (x, y): prod\n...     for x in range(7)\n...     for y in range(7)\n...     if (prod := x * y) % 2 != 0\n...     if y \u003e x\n... }\n{(1, 3): 3, (1, 5): 5, (3, 5): 15}\n```\n\n이 코드를 이해하는 데 문제가 없어야 합니다. 다음과 같이 사전을 만들고 있습니다:\n\n- 데이터 작업: x, y의 튜플에 대해 x와 y의 곱을 계산합니다.\n- 루프: range(7)에서 x 값에 대해, range(7)에서 y 값에 대해\n- 조건: 곱셈을 한 값이 홀수이고, y가 x보다 클 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 데이터 조작 결과에 대한 조건이었습니다. 원래 데이터와는 다른 조건이었죠. 그래서 우리는 위바다 연산자를 사용했습니다.\n\n이걸 사용하면 읽는 과정이 조금 복잡해질 수 있어요. 우리는 prod를 사용하는 줄에서 실제로 정의된 곳으로 이동해야 하고, 그 다음에 다시 같은 줄로 돌아와야 해요. 따라서 우리는 위바다 연산자 없이도 같은 작업을 할 수 있을까요?\n\n네, 가능해요:\n\n```js\n\u003e\u003e\u003e {\n...     (x, y): x * y\n...     for x in range(1, 7)\n...     for y in range(1, 7)\n...     if (x * y) % 2 != 0\n...     if y \u003e x\n... }\n{(1, 3): 3, (1, 5): 5, (3, 5): 15}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드에서 문제점을 발견했나요? 이번에는 가독성이 아니라 최적화에 관한 문제에요: 오타리스트(철학 연산자) 버전과 달리, 제품 (x * y)이 두 번 계산됩니다! 이는 오타리스트 연산자를 사용하지 않은 버전보다 느리다는 것을 의미해요.\n\n그럼 일반 for 루프로 어떠한지 확인해보겠습니다. 여기서는 오타리스트 연산자가 필요하지 않아요:\n\n```js\nmulti_table = {}\nfor x in range(7):\n    for y in range(7):\n        prod = x * y\n        if prod % 2 != 0 and y \u003e x:\n            multi_table[(x, y)] = prod\nmulti_table\n{(1, 3): 3, (1, 5): 5, (3, 5): 15}\n```\n\n정말이지, 함축 표현식의 다음 부분:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...     (x, y): x * y\n...     for x in range(1, 7)\n...     for y in range(1, 7)\n...     if (x * y) % 2 != 0\n...     if y \u003e x\n```\n\n제 생각에는 다음 부분이 일반 for 루프의 이 부분보다 훨씬 가독성이 좋습니다:\n\n```js\n\u003e\u003e\u003e for x in range(7):\n...     for y in range(7):\n...         prod = x * y\n...         if prod % 2 != 0 and y \u003e x:\n...             multi_table[(x, y)] = prod\n```\n\n이전의 코드에 왈러스 연산자가 있음에도 불구하고 그렇습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 복잡한 이해를 단순하게 하는 파이프라인\n\n한 번 더, 일반적인 이해 패턴으로 돌아가 봅시다: 데이터 조작 → 루프 → 선택적 조건. 첫 번째 단계인 데이터 조작은 간단할 수도 복잡할 수도 있습니다. 때로는 여러 데이터 조작으로 이루어질 수도 있습니다.\n\n하나의 이해 안에 여러 작업을 결합해야 한다면, 중요한 솔루션이 여러 가지 있습니다. 가장 중요한 것은 다음과 같습니다:\n\n작업을 합쳐라. 예를 들어, (x + 5)**2는 사실 두 작업, x + 5와 그 결과의 제곱을 계산하는 것을 합칩니다. 하지만 다른 예제로 작업을 한 번에 세 개 결합해야 한다고 가정해봅시다: str.lower(), str.strip(), 그리고 str.replace(` `,`_`). 이 경우에는 다음과 같이 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e texts = [\n...     \"Text 1\",\n...     \"the Second text   \",\n...     \" and FINALLY, the THIRD text!  \\t\"]\n\u003e\u003e\u003e output_join = [\n...     t.lower().strip().replace(' ', '_')\n...     for t in texts\n... ]\n```\n\n이 방법은 이런 단순한 경우에만 작동합니다. 이와 같이 연산을 간단한 방법으로 결합하고 추가적인 중간 계산이 불필요한 경우에만 성공합니다.\n\n함수를 사용해 보세요. 대신 함수를 사용하여 모든 연산을 함수로 이동하고 내포에서 해당 함수를 호출할 수 있습니다:\n\n```js\n\u003e\u003e\u003e def preprocess(text: str) -\u003e str:\n...     return text.lower().strip().replace(' ', '_')\n\u003e\u003e\u003e output_func = [preprocess(t) for t in texts]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 솔루션은 매우 복잡한 상황에서도 작동할 수 있습니다. 데이터에 대한 여러 고급 연산이 필요하고 계산이 필요한 여러 단계를 거치더라도 작동합니다.\n\n실제로 이해하기 매우 쉽습니다. 데이터 연산 로직이 내부적으로 처리되는 함수(preprocess()와 같이)로 이동하기 때문입니다. 때로는 한 번만 사용되는 함수를 정의하는 것이 좋지 않은 아이디어일 수 있지만 코드를 조직화하는 데 도움이 되는 경우에는 훌륭하게 작동할 수 있습니다.\n\n이 방법을 선택하면 함수에 정보를 제공하는 의미 있는 이름을 사용하는 것을 기억하십시오. 그렇게 함으로써 함수 내에 구현된 데이터 연산 로직이 복잡하더라도 이해할 수 있는 내용으로 이러한 이해를 읽을 수 있습니다.\n\n콤프리헨션 파이프라인을 사용하세요. 이 경우 단일 콤프리헨션은 사용하지 않고 단계별로 콤프리헨션을 호출합니다. 이를 콤프리헨션 파이프라인이라고 합니다. 제너레이터 파이프라인을 생성해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e step1 = (t.lower() for t in texts)\n\u003e\u003e\u003e step2 = (t.strip() for t in step1)\n\u003e\u003e\u003e output_gen_pipe= (t.replace(' ', '_') for t in step2)\n```\n\n그리고 목록을 기반으로 한 해당 파이프라인 (listcomp pipeline):\n\n```js\n\u003e\u003e\u003e step1 = [t.lower() for t in texts]\n\u003e\u003e\u003e step2 = [t.strip() for t in step1]\n\u003e\u003e\u003e output_list_pipe = [t.replace(' ', '_') for t in step2]\n```\n\n전자 버전은 생성기를 생성하므로 평가해야 합니다. 평가하기 위해 이를 위한 목록을 사용할 것입니다. 아래 참고해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노트: 모든 네 가지 접근 방식은 매우 유사한 결과를 보여줍니다:\n\n```js\n\u003e\u003e\u003e (output_join == output_func == list(output_gen_pipe) == output_list_pipe)\nTrue\n```\n\n이해를 돕기 위해 표현식 파이프라인이 강력한 솔루션을 제공할 수 있습니다. 그러나 실제 파이프라인에만 작동하는 것이 아니라는 점을 명심해 주세요.\n\n이 주제는 고급적이므로 여기에서 다루지 않겠습니다. 관심이 있다면 다음 기사에서 관련 정보를 많이 찾아볼 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이미 Python을 사용해온 지 얼마 되지 않았다면, 아마 단순한 상황에만 comprehension을 사용하고 그렇지 않은 경우에는 for 루프를 사용하라는 경고를 들어본 적이 있을 것입니다. 특정 상황이 comprehension으로 구현하기에 너무 복잡한지를 결정하는 방법은 무엇일까요?\n\n이를 위해서는 연습과 경험이 필요합니다. 숙련된 Python 개발자는 이러한 결정을 내릴 때 거의 망설임이 없습니다. 그들은 일반적인 맥락에서 어느 선택이 더 나은지 보통 알고 있습니다.\n\n고급 Python 개발자가 아니라면, 이러한 기술을 키워야 합니다. 아직 그 수준에 이르지 못했다면 걱정하지 마세요; 가능한 많은 comprehension을 구현하여 이 기술을 연습해보세요 — 심지어 맥락이 comprehension에는 너무 어려워 보이더라도 그렇게 해보세요. 맥락이 실제로 매우 복잡하고 각 반복마다 여러 작업이 필요한 경우가 아닌 이상, comprehension과 for 루프 둘 다 구현하고 비교해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 반복이 여러 데이터 작업을 필요로 할 때도, 우리가 위에서 논의한 간단한 비결을 활용하여 이해하기 쉬운 코드를 만들 수 있습니다: 데이터 작업을 함수로 이동시키고 이를 함축 표현의 루프 각 반복에서 호출하세요. 이러한 접근 방식은 모든 작업이 루프의 코드 블록 내에 구현된 for 룹보다 훨씬 간결한 코드를 제공할 수 있습니다.\n\n함축 표현이 너무 어려워 보일 때도 조기에 포기하지 마세요. 일단 시도해보고, 성공하면 꽤 깔끔한 해결책이 될 수 있습니다: 함축 표현의 코드의 어려움은 그것을 구현하는 어려움과 비례하지 않아도 됩니다.\n\n보통, for 룹과 해당 함축 표현 중에서 선택할 수 있습니다. 그러나 때로는 단일 명령(긴 경우도 다수의 줄로 분할될 수 있기 때문에)을 사용해야 할 때가 있으며, 이 경우엔 단순히 함축 표현이 필요합니다.\n\n예를 들어, Pytest의 픽스처(parametrization of fixtures)의 매개변수화를 고려해보세요. pytest.fixture() 호출 내부나 직접 params 인자로 전달하는 매개변수 목록을 만들 수 있습니다. 종종, 내부에서 작업하는 것이 좋습니다. 왜냐하면 이렇게 하면 코드가 더욱 명확하고 조직적으로 구성되기 때문입니다. 픽스처의 매개변수화 코드가 pytest.fixture() 호출 내부에 포함하기에 너무 복잡해질 때만 외부로 이동시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 구문 설탕인 컴프리헨션(제너레이터 표현식 포함), 데코레이터, 물고기 연산자 등은 파이썬을 강력하고 가독성 있게 만들어줍니다. 그래서 이러한 요소들을 피하지 마세요. 이들은 파이썬 프로그래밍을 더 쉽게 만들기 위해 존재합니다. 게다가, 컴프리헨션은 파이썬에 아름다움을 더해줍니다. 이를 배워서 사용하는 법을 익히면, 이제까지 못 느꼈던 만족감을 느낄 수 있을 거예요.\n\n모두가 이러한 이유를 동의하는 것은 아닙니다. 어떤 사람들은 파이썬을 잘 모르는 사람들이 그런 코드를 이해하지 못할 수 있다고 말하기도 합니다. 하지만 저는 그 접근 방식에 완전히 반대합니다. 프로그래밍 언어를 선택했다면, 해당 언어의 기본 구문과 구문 설탕을 사용하는 것이 당연하다고 생각해요. 이들은 종종 해당 언어에서 가장 강력한 프로그래밍 도구 중 하나에 속합니다.\n\n만약 C 구문을 사용하고 싶다면 C를 사용하세요, 파이썬을 사용하면서도 C 구문을 사용하면 사실상 파이썬다운 코드가 아니게 됩니다. 비록 올바르게 동작할지라도, 이러한 코드는 길고 최적화되지 않으며 이해하기 어려울 수 있습니다.\n\n컴프리헨션을 가장 단순한 상황에만 사용해야 한다는 주장은 오버 사용된 신화가 되어버렸습니다. 사실, 너무 복잡한 컴프리헨션 사용은 피해야 하지만, 이것이 무엇을 의미하는 걸까요? 두 개의 조건문이나 중첩된 루프는 컴프리헨션을 너무 복잡하게 만드는 것인가요? 아니요, 그렇지 않아요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 이 규칙을 따라주세요: Python 컴프리헨션이 해당하는 for 루프보다 이해하기 복잡하다면 컴프리헨션을 사용하지 마세요. 하지만, 컴프리헨션이 더 이해하기 쉽다면 무조건 사용해주세요. 심지어 여러 줄에 걸쳐 나타나고 어려울지라도요.\n\n다시 말해, 컴프리헨션을 사용할지 여부를 결정할 때는 가독성과 해당하는 for 루프의 이해도를 기반으로 하세요. 성능이 우려된다면 그것도 고려해주세요; 이는 종종 컴프리헨션을 for 루프보다 선호해야 한다는 것을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-22-ComplexListComprehensionsCanBeReadable_0.png"},"coverImage":"/assets/img/2024-06-22-ComplexListComprehensionsCanBeReadable_0.png","tag":["Tech"],"readingTime":18},{"title":"주말 동안 스킬을 향상시킬 5가지 파이썬 프로젝트","description":"","date":"2024-06-22 14:17","slug":"2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend","content":"\n\n\n![이미지](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_0.png)\n\n👆 👆👆👆👆\n\n프로그래밍을 배우다 그만둔 이유는 대부분 코딩 프로젝트를 시작하지 않기 때문입니다.\n\n수업을 수동적으로 시청하는 것만으로는 프로그래머가 되지 못합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래밍으로 역량을 향상시키는 방법을 알려드릴게요.\n\n그래서 이 글에서는 주말에 역량을 향상시킬 수 있는 5가지 파이썬 프로젝트 아이디어를 제공할 거에요.\n\n🦜 만약 이 내용이 마음에 든다면 Axel을 팔로우해주세요.\n\n# 프로젝트 1: 퀴즈 코드론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 초보자이고 간단한 프로젝트를 코딩하려는 경우, 퀴즈는 시작하기에 좋은 선택입니다.\n\n내 제안은 필요로 하는 주제에 대한 퀴즈를 만드는 것입니다.\n\n예를 들어, 나는 학부 논문에서 데이터 수집을 위해 많은 질문 조사를 사용했습니다.\n\n![이미지](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 퀴즈는 게임, 시험, 설문조사 등이 될 수 있어요.\n\n사용자의 선택에 기반한 게임 이야기를 만들어 텍스트 어드벤처 게임을 만들어 더 복잡하게 만들 수도 있어요.\n\n프로그래밍 실력이 향상되면 Django, tkinter 또는 Streamlit으로 사용자 인터페이스를 만들기 위해 이 퀴즈를 사용할 수 있어요.\n\n# 프로젝트 2: 스네이크 게임 코딩\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임은 즐기면서 프로그래밍을 빠르고 효과적으로 배울 수 있는 훌륭한 프로젝트입니다.\n\n![Python Project](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_2.png)\n\n누구나 프로그래밍 기초를 알고 있다면 할 수 있는 초보자 친화적인 프로젝트입니다.\n\n만약 올바른 방향으로 진행 중인지 확인이 필요하다면 GitHub에서 여러 비디오, 블로그, 코드를 찾아볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뱀 게임을 좋아하지 않거나 다른 게임을 선호한다면 행맨 게임, 스페이스 인베이더, 플래피 버드 등을 코딩해보세요.\n\n프로그래밍을 하면서 즐거움을 느낄 수 있는 다양한 옵션이 있어요!\n\n# 프로젝트 3: 데스크탑 클리너\n\n![이미지](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다운로드 폴더가 파일로 넘쳐납니다?\n\n그럼 이 프로젝트는 당신을 위한 것입니다.\n\n파일 유형에 따라 모든 파일을 정리하는 코드를 생성할 수 있습니다. 예를 들어, 모든 PDF, 엑셀 및 JPG 파일을 저장하는 Python 스크립트를 실행하여 다음과 같은 폴더에 저장할 수 있습니다:\n\n- PDF 폴더\n- Excel 폴더\n- JPG 폴더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 식이죠.\n\n데스크톱의 파일 정리의 정글을 정돈하는 데 도움이 되는 멋진 자동화 프로젝트입니다.\n\n또한 초보자에게 친숙하며 30분 이상 걸리지 않을 것입니다.\n\n# 프로젝트 4: 데이터 분석 앱 (고급)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 분석 분야에 발을 담그고 계신다면, 이 프로젝트는 여러분의 포트폴리오를 멋지게 만들어 줄 수 있는 훌륭한 기회입니다.\n\n데이터 분석에서 시각화는 매우 중요합니다.\n\n많은 기업들이 대시보드나 다른 사용자 인터페이스를 통해 데이터를 시각화하고 상담하는 것을 선호합니다.\n\n따라서 이 프로젝트에서는 Python 모듈인 Tkinter나 Streamlit과 같은 도구를 사용하여 놀 수 있는 데이터셋과 함께 멋진 사용자 인터페이스를 만들어볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Python project image](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_4.png)\n\n이를 위해서는 Kaggle이나 다른 곳에서 데이터 세트를 찾아 간단히 분석하고, 상호 작용하는 데이터로 몇 개의 플롯을 생성할 수 있습니다.\n\n데이터를 어디서 찾을지 모르겠다면, 이 글을 읽어보세요:\n\n이 프로젝트는 프론트엔드 프로그래밍에 대한 입문에 도움이 될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 5: 호텔 데이터 웹 스크래핑 (고급)\n\n웹 스크래핑은 데이터 프로그래머에게 가장 가치 있는 기술 중 하나입니다.\n\nFiverr 또는 Upwork과 같은 프리랜서 플랫폼의 많은 구인 공고에서 이를 요청하는 사람들을 발견할 수 있습니다.\n\n따라서 하나의 프로젝트는 호텔 데이터로 데이터셋을 만들어 보는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마도 몇 시간 정도 소요될 것 같아요.\n\n그래서 이 작업 아이디어에서는 최적의 호텔 옵션을 빠르게 찾기 위해 검색을 요약하여 단일 데이터 집합을 만들 수 있어요.\n\n이를 위해 호텔 검색에 가장 많이 사용되는 플랫폼 중 하나인 Booking을 사용할 수 있어요.\n\n여러 요청을 하지 않는다면, 공개 데이터를 스크랩하는 것은 합법적이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 표 태그를 Markdown 형식으로 변경해주세요.\n\n\n![Python Project Image](/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_5.png)\n\n이 글이 여러분에게 프로젝트 코딩을 시작하고 주말에 파이썬 기술을 향상시키는데 도움이 되기를 바랍니다.\n\n그리고 기억하세요:\n\n동영상을 수동적으로 시청하며 프로그래밍을 배울 수는 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래밍을 통해 프로그래머가 될 것입니다.\n\n초보자를 위한 더 많은 추천이 있으신가요? 대답으로 알려주세요.\n\n🦜 만약 이 컨텐츠를 좋아하시면 Axel을 팔로우해주세요.\n\n🦜 만약 제 포스트를 좋아하셨다면, 신경과학, 심리학, 생산성, 동물, 파이썬에 관한 더 많은 콘텐츠를 보려면 👏 50번 클랩 해주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 아래 사항을 참고하실 수 있습니다:\n\n다음에 봐요,\n\n악셀\n\n# 일반 언어로 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩(clap)하고 팔로우하기를 잊지 마세요! 👏️️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_0.png"},"coverImage":"/assets/img/2024-06-22-5PythonProjectstoBoostYourSkillsinAWeekend_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬으로 해시 테이블 구현하기 단계별 가이드","description":"","date":"2024-06-22 14:14","slug":"2024-06-22-ImplementingaHashTableinPythonStep-by-Step","content":"\n\n\n![image](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_0.png)\n\n# 1. 소개\n\n해시 테이블은 소프트웨어 개발에서 효율적인 데이터 저장 및 검색의 핵심입니다. 고유한 키를 통해 데이터에 빠르게 액세스하는 기능을 제공함으로써, 해시 테이블은 빠른 조회, 삽입 및 삭제를 가능하게 하여, 데이터베이스 인덱싱 및 캐싱 솔루션과 같이 성능이 중요한 시나리오에서 필수적입니다.\n\n해시 테이블의 본질은 키를 해시 함수를 사용하여 배열 인덱스로 변환하는 해싱 메커니즘에 있습니다. 선택된 인덱스는 배열에서 해당 값이 저장되는 위치를 결정합니다. 키를 배열 전체에 균일하게 분배하고 이중 해싱 및 이차 탐색과 같은 고급 충돌 해결 기술을 사용하여, 해시 테이블은 충돌을 최소화하고 데이터 검색 시간을 최적화할 수 있습니다. 이러한 방법은 해시 테이블이 고부하 요소에서도 빠른 액세스를 유지할 수 있는 능력을 향상시키며, 다양한 애플리케이션에서 성능을 유지하는 데 중요한 역할을 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 기초 이해하기\n\n## 2.1 해시 테이블의 주요 구성 요소 설명\n\n해시 테이블은 데이터를 효율적으로 저장하고 관리하기 위해 함께 작동하는 몇 가지 기본 구성 요소로 구성되어 있습니다:\n\n해시 함수: 해시 테이블의 핵심입니다. 해시 함수는 입력 키를 가져와 버킷이나 슬롯 배열의 인덱스를 계산하여 해당 값이 저장된 위치를 결정합니다. 해시 함수의 효율성은 데이터 분포에 영향을 미치기 때문에 매우 중요합니다. 좋은 해시 함수는 충돌을 최소화하고 항목을 균일하게 버킷에 분산시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버킷 또는 슬롯: 이들은 데이터 항목이 저장되는 배열의 위치를 나타냅니다. 각 버킷은 하나 이상의 항목을 저장할 수 있습니다. 가장 간단한 형태로는 하나의 키-값 쌍을 보유하는 버킷입니다. 그러나 충돌 처리 전략에 따라, 항목 목록이나 더 복잡한 데이터 구조를 포함할 수도 있습니다.\n\n충돌 처리: 두 개의 키가 동일한 인덱스로 해싱될 때 충돌이 발생합니다. 충돌을 효율적으로 관리하는 것은 해시 테이블의 성능을 유지하는 데 중요합니다. 충돌을 처리하는 여러 가지 방법이 있습니다. 그 중 일부는 다음과 같습니다:\n\n- 체이닝: 이 방법은 더 복잡한 데이터 구조(예: 연결 리스트 또는 다른 해시 테이블)를 사용하여 동일한 인덱스에 여러 요소를 저장하는 것을 포함합니다. 특정 인덱스의 각 버킷이나 슬롯은 동일한 해시 인덱스를 공유하는 항목 목록의 헤드를 가리킵니다.\n\n- 개방 주소 방식: 개방 주소 방식에서 모든 요소는 배열에 직접 저장됩니다. 충돌이 발생하면 해시 테이블은 미리 정의된 순서에 따라 다음 사용 가능한 슬롯을 탐색하거나 검색합니다. 일반적인 전략으로는 선형 조사, 제곱 조사 및 이중 해싱이 있습니다. 각 방법은 구현 용이성과 충돌 감소 효과 면에서 다양한 이점을 제공합니다.\n\n## 2.2 소프트웨어 개발에서 해시 테이블의 일반적인 사용 사례 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해시 테이블은 소프트웨어 개발에서 널리 사용되며 효율성과 다용성으로 인해 높이 평가받고 있어요. 여기 몇 가지 일반적인 사용 예시들이 있습니다:\n\n- 데이터베이스 인덱싱: 해시 테이블은 데이터베이스 인덱싱 시스템의 성능에 필수적인 빠른 데이터 검색을 제공해줘요.\n- 캐싱: 해시 테이블은 캐싱 애플리케이션에 이상적이며 캐시된 데이터의 빠른 조회가 중요한 경우에 적합해요. 효율적인 삽입, 조회 및 삭제가 가능합니다.\n- 데이터 중복 제거: 데이터 중복을 최소화해야 하는 상황에서 해시 테이블은 중복 데이터를 신속하게 식별하는 데 도움이 될 수 있어요.\n- 연관 배열: 많은 프로그래밍 언어에서 사용자 정의 키를 기반으로 데이터를 검색하고 저장할 수 있는 연관 배열(맵 또는 사전으로도 알려짐)을 구현하는 데 해시 테이블을 사용해요.\n- 고유 데이터 표현: 해시 테이블은 고유한 항목 집합을 유지하는 데 유용하며 반복에 대한 검사가 필요한 구현에서 널리 사용되고 있어요.\n\n# 3. 파이썬 환경 설정\n\n## 필수 도구 및 라이브러리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서 해시 테이블을 구현하려면, 파이썬 인터프리터와 텍스트 편집기 또는 통합 개발 환경(IDE)을 준비해야 합니다. 해시 테이블을 구축하는 데는 파이썬의 표준 라이브러리만으로도 충분하므로 이 기본 구현에는 추가적인 라이브러리가 필요하지 않습니다. 그러나 해시 테이블을 더 발전된 기능이나 특정 응용 프로그램에 적용하기 위해 고려한다면, 성능 최적화를 위해 NumPy와 같은 라이브러리를 사용하거나 pytest로 구현을 테스트하는 것이 좋습니다.\n\n시스템에 파이썬이 설치되어 있는지 확인하세요. 개선된 기능과 지원이 향상된 파이썬 3.8 이상 버전을 권장합니다. 공식 파이썬 웹사이트에서 최신 버전을 다운로드하거나 macOS의 brew나 Ubuntu Linux의 apt와 같은 패키지 관리자를 사용할 수 있습니다.\n\n## 해시 테이블을 위한 파이썬 스크립트 또는 모듈의 초기 설정\n\n- 새로운 파이썬 파일 생성: hash_table.py라는 새로운 파이썬 파일을 만들어 시작하세요. 이 파일에는 해시 테이블 구현과 관련된 모든 코드가 포함됩니다.\n- 해시 테이블 클래스의 구조 정의: HashTable이라는 클래스를 정의하여 해시 테이블의 모든 기능을 캡슐화하세요. 삽입, 삭제 및 검색과 같은 메서드를 포함합니다. 다음은 시작하기 위한 기본 구조입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_1.png\" /\u003e\n\n- 테스트 설정: 해시 테이블을 구축하는 과정에서 유효성을 검증하는 간단한 테스트 메커니즘을 설정하는 것이 좋은 실천입니다. Python의 내장된 unittest 프레임워크를 사용하여 테스트 케이스를 작성할 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_2.png\" /\u003e\n\n- 스크립트 실행: 명령 줄을 이용하여 디렉토리로 이동하고 python hash_table.py를 실행하여 스크립트를 실행하고 작성한 테스트를 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 해시 테이블 클래스 구현하기\n\n## 4.1 해시테이블 클래스 구조 정의\n\n해시테이블 클래스는 우리의 해시 테이블을 위한 청사진으로 작용합니다. 이 클래스는 키-값 쌍의 효율적인 저장, 검색, 및 삭제를 관리하기 위해 설계되었습니다. 아래는 우리 클래스의 기본 구조입니다. 이는 초기화, 데이터 처리를 위한 메서드, 및 해시 함수를 적용하는 메서드를 포함합니다:\n\n![hash-table-class-structure](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4.2 메소드 추가:\n\n- __init__: 해시 테이블의 초기화입니다. 이 메소드는 지정된 크기로 해시 테이블을 설정하고 버킷을 초기화합니다. 충돌 처리 전략에 따라 버킷은 체이닝을 위해 리스트로 구현되거나 오픈 어드레싱을 위해 빈 슬롯으로 구현될 수 있습니다.\n- insert: 해시 테이블에 항목 추가입니다. 이 메소드는 새로운 키-값 쌍을 해시 테이블에 삽입합니다. 해시 함수를 사용하여 키의 해시 인덱스를 계산하고 필요에 따라 충돌을 처리하여 값을 적절한 버킷에 배치합니다.\n- get: 키로 항목 검색입니다. get 메소드는 해시 테이블에서 키를 검색하고 해당 값(값)을 반환합니다. 잠재적인 충돌을 처리하고 키를 찾지 못하면 None을 반환하여 견고한 데이터 검색을 보장합니다.\n- delete: 키로 항목 제거입니다. 이 메소드는 키를 사용하여 해시 테이블에서 키-값 쌍을 제거합니다. 올바른 버킷을 찾아 항목을 제거하고, 이후 요소에 영향을 줄 수 있는 충돌을 처리합니다.\n- _hash: 해시 함수 적용을 위한 내부 메소드입니다. 이는 키에 해시 함수를 적용하여 키가 버킷 리스트의 범위 내에서 유효한 인덱스로 변환되도록 하는 도우미 메소드입니다.\n\n## 4.3 체이닝(연결 리스트) 또는 오픈 어드레싱을 사용한 충돌 처리 설명\n\n- 체이닝(연결 리스트): 체이닝은 충돌 해결 기술로, 배열의 특정 인덱스에 있는 각 버킷은 연결된 리스트를 시작할 수 있습니다. 동일한 인덱스에 해싱된 모든 키-값 쌍이 이 목록에 저장되어 같은 인덱스에 여러 항목을 저장할 수 있지만, 최악의 경우 요소를 검색하는 데 소요되는 시간 복잡성이 증가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Implementation of Linear Probing](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_4.png)\n\n- Open Addressing: Open addressing stores all elements directly in the array and resolves collisions by finding another empty slot within the array. The common strategies for open addressing include linear probing, quadratic probing, and double hashing, each with distinct approaches to resolving collisions efficiently.\n\nHere’s an implementation of linear probing:\n\n![Linear Probing](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 이차 탐사(quadric probing)의 구현입니다:\n\n![quadric probing](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_6.png)\n\n아래는 두 번째 해싱(double hashing)의 구현입니다:\n\n![double hashing](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 충돌 처리\n\n## 5.1 체이닝의 상세 설명과 Python에서의 구현\n\n체이닝은 해시 테이블에서 충돌을 처리하는 일반적인 방법으로, 특정 인덱스의 각 버킷이 하나 이상의 요소를 보유할 수 있습니다. 이 접근 방식은 링크드 리스트와 같은 보조 데이터 구조를 사용하여 동일한 인덱스에 해싱된 여러 항목을 저장합니다. 각 버킷이 항목 목록을 저장할 수 있도록 허용함으로써, 체이닝은 충돌을 우아하게 처리하고 높은 부하 요소에서도 성능을 유지합니다.\n\nPython에서의 구현: 링크드 리스트를 사용하여 해시 테이블에서 체이닝을 구현하는 예제를 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_8.png)\n\n이 구현에서 각 버킷은 링크드 리스트로 연결된 여러 항목을 저장할 수 있습니다. 새로운 키-값 쌍이 삽입될 때 해시 테이블은 계산된 인덱스에 이미 항목이 있는지 확인합니다. 버킷이 비어 있으면 새로운 노드를 삽입합니다. 그렇지 않으면 기존 키를 업데이트하거나 키가 없는 경우 체인 끝에 새 노드를 추가합니다. 이 방법은 메모리 사용량 면에서 효율적이며 충돌 처리를 간단하게 합니다.\n\n체이닝의 장점:\n\n- 체이닝은 구현이 간단합니다.\n- 해시 테이블이 버킷보다 더 많은 항목을 저장할 수 있어 고충돌 시나리오를 우아하게 처리합니다.\n- 전체 테이블의 크기를 조정할 필요가 없으며 영향을 받는 체인만 조정하면 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n체이닝의 단점:\n\n- 체이닝은 링크드 리스트 포인터와 관련된 오버헤드 때문에 더 많은 메모리를 사용합니다.\n- 많은 요소가 동일한 인덱스로 해싱되는 최악의 경우, 요소를 찾는 작업이 링크드 리스트를 순회해야 하므로 느려질 수 있습니다.\n\n이 충돌 처리 방법은 부하 계수가 높고 해시 테이블이 효율적으로 많은 충돌을 처리해야 하는 상황에 적합합니다.\n\n## 5.2 대체 방법: 개방 주소법 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경하겠습니다.\n\n선형 조사는 충돌을 해결하기 위해 배열 자체 내에서 다른 버킷 위치를 조사하는 방식입니다.\n\n선형 조사: 해시 테이블에서 충돌을 해결하는 데 사용되는 직관적인 오픈 어드레싱 전략입니다. 체이닝과 달리, 충돌이 동일한 인덱스에서 발생하고 항목을 연결하는 방식이 아니라 선형 조사는 새 항목을 저장할 배열 내의 다음 사용 가능한 슬롯을 찾습니다. 이 방법은 모든 항목이 배열 내에 직접 저장되므로 캐시 성능이 향상되고 공간을 효율적으로 사용할 수 있습니다.\n\nPython에서의 구현:\n\n![이미지](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구현에서는 충돌이 발생할 때(즉, 해싱된 인덱스가 이미 사용 중인 경우), 해시 테이블은 다음 사용 가능한 슬롯을 선형으로 검색합니다. 이 방법은 간단하고 효과적이지만 연속적인 슬롯이 채워져 클러스터링이 발생할 수 있어 테이블이 가득 차면 평균 검색 시간이 증가할 수 있습니다.\n\n선형 조사의 장점:\n\n- 주요 테이블 외에 추가 메모리가 필요 없어 공간을 효율적으로 사용합니다.\n- 구현 및 이해하기 쉽습니다.\n- 연속적인 메모리 사용으로 인해 좋은 캐시 성능을 제공합니다.\n\n선형 조사의 단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클러스터링은 특히 고로드 시나리오에서 성능에 큰 영향을 미칠 수 있습니다.\n- 부하 요소 임계값에 도달하면 전체 테이블의 크기를 조정해야 하며, 이는 계산 비용이 많이 들 수 있습니다.\n\n선형 조사는 부하 요소가 낮거나 보통인 테이블에서 잘 작동하며, 삭제 빈도가 낮을 때 특히 효과적입니다. 삭제는 조사 순서를 복잡하게 만들 수 있는 간격을 만들기 때문에 특히 유용합니다.\n\n제곱 조사는 해시 테이블에서 충돌을 해결하기 위해 사용되는 고급 개방주소 방식으로, 클러스터링 문제를 해결하는 데 선형 조사보다 큰 개선을 제공합니다. 선형 조사는 다음 사용 가능한 슬롯을 선형 시퀀스로 찾지만, 제곱 조사는 조사 사이의 간격을 계산하기 위해 이차 다항식을 사용하여 클러스터 생성 가능성을 감소시킵니다.\n\nPython에서의 구현:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_10.png\" /\u003e\n\n이 구현에서는 이차 조사법이 사용되어 선형 조사법에서 발생하는 주요 클러스터링 문제를 크게 줄이는데 기여합니다. 조사 함수는 (index + c1*trial + c2*trial^2) % table_size와 같이 사용되며, 여기서 c1 및 c2는 상수이고, trial은 각 조사에서 빈 슬롯을 찾거나 루프가 감지될 때까지 증가합니다.\n\n이차 조사법의 장점:\n\n- 선형 조사법에 비해 클러스터링을 줄입니다.\n- 주요 항목을 효율적으로 분산시킴으로써 해시 테이블 공간을 더 효율적으로 활용합니다.\n- 다음 인덱스를 계산하는 과정은 여전히 비교적 간단하고 빠릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제곱 프로빙의 단점:\n\n- 선형 프로빙보다는 심각하지 않지만, 여전히 순차 군집화가 발생할 수 있습니다.\n- c1 및 c2 값의 선택이 성능에 큰 영향을 미치며 조심스럽게 조정해야 합니다.\n- 다른 개방 주소 방식과 마찬가지로, 테이블이 너무 가득 차면 크기를 조정해야 합니다.\n\n제곱 프로빙은 중간 부하 요소에 대해 효과적인 충돌 해결 기술이며, 해시 테이블 크기를 충분히 크게 유지하여 빈번한 크기 조정을 피할 수 있는 시나리오에서 특히 유익합니다.\n\n더블 해싱: 오픈 어드레싱의 정교한 방법으로, 충돌 해결을 위해 두 개의 해시 함수를 사용하여 군집화 문제를 크게 줄이는 방법입니다. 선형이나 제곱 프로빙과 달리, 더블 해싱은 충돌 발생 후 단계 크기를 계산하기 위해 두 번째 해시 함수를 사용하여 각 프로브가 키를 기반으로 고유한 시퀀스를 따르도록 보장합니다. 이 방법은 해시 테이블 전체에 항목을 고르게 분산시키는 능률성과 효과성으로 알려져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬으로의 구현:\n\n![Implementation in Python](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_11.png)\n\n이 구현에서 첫 번째 해시 함수는 초기 슬롯을 결정하며, 충돌이 발생하면 두 번째 해시 함수가 다음 프로브를 위한 오프셋을 제공합니다. 단순 및 제곱 프로빙과 달리 단계가 고정되어 있거나 예측 가능한 패턴으로 증가하는 것과는 달리, 더블 해싱은 기본 및 보조 클러스터링을 모두 최소화하여 더 균일한 데이터 분포를 이끌어냅니다.\n\n더블 해싱의 장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 조사 기법보다 클러스터링을 더 효과적으로 최소화합니다.\n- 높은 로드 팩터를 갖는 해시 테이블에서 높은 성능을 제공합니다.\n- 각 키마다 고유한 조사 순서가 제공되어 다른 조사 방법보다 성능이 향상됩니다.\n\n더블 해싱의 단점:\n\n- 선형 또는 제곱 조사보다 구현이 더 복잡합니다.\n- 두 번째 해시 함수를 계산하기 위한 추가 계산이 필요합니다.\n- 성능은 두 해시 함수의 품질에 크게 의존합니다.\n\n더블 해싱은 해시 테이블이 높은 트래픽을 경험하거나 키 분포가 충돌을 자주 발생시킬 수 있는 응용 프로그램에서 특히 유용합니다. 항목을 효율적으로 분배하는 능력으로 인해 대규모 데이터 세트에 대한 훌륭한 선택이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5.3 각 충돌 해결 기술의 장단점\n\n체이닝: 장점: 구현이 간단함; 높은 충돌 시나리오를 우아하게 처리함; 크기 조정 시 전체 테이블을 재해싱할 필요가 없음. 단점: 더 많은 메모리 사용; 연결 리스트 작업이 연속적인 메모리 할당으로 인해 느릴 수 있음.\n\n오픈 어드레싱: 장점: 해시 테이블 배열에 모든 요소를 저장하기 때문에 공간을 더 효율적으로 활용함; 연속적인 메모리 사용으로 캐시 성능이 좋아짐. 단점: 클러스터링이 발생하여 효율성이 감소할 수 있음; 테이블이 가득 찰 수 있어 크기 조정이 필요함; 크기 조정이 복잡함.\n\n각 충돌 처리 방법에는 트레이드오프가 있으며 특정 유형의 응용 프로그램에 가장 적합합니다. 체이닝은 불특정 또는 매우 변동적인 부하를 가진 해시 테이블에 적합할 수 있으며, 오픈 어드레싱은 안정적인 데이터 집합 및 충돌 최소화를 위한 좋은 해시 함수가 있는 응용 프로그램에 더 적합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 테스팅 및 디버깅\n\n## 6.1 해시 테이블을 위한 테스트 케이스 작성\n\n해시 테이블의 효율적인 테스팅은 다양한 조건에서 데이터를 처리하는 신뢰성과 효율성을 보장하기 위해 중요합니다. 다양한 프로빙 기술을 사용하여 해시 테이블 구현에 대해 포괄적인 테스트 케이스를 작성하는 방법은 다음과 같습니다:\n\n요소 삽입, 검색 및 삭제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기본 작업(삽입, 가져오기, 제거)이 예상대로 작동하는지 확인하는 간단한 테스트를 시작해 보세요. 해시 테이블에 요소를 추가하고, 키를 사용하여 그 요소를 검색하고, 일부를 제거하여 테이블이 올바르게 업데이트되는지 확인합니다.\n\n- 고부하 상황에서 성능 확인: 해시 테이블이 로드 요소가 증가함에도 효율적으로 작동하는지 확인하세요. 많은 요소를 삽입하고 다양한 작업에 소요되는 시간을 측정하여 수행할 수 있습니다. 해시 테이블이 수용 한도에 가까워지면 어떻게 작동하고 크기 조정을 어떻게 처리하는지 테스트해 보세요.\n\n- 충돌 처리를 위한 스트레스 테스트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다수의 키가 동일한 값으로 해싱되는 시나리오를 만들어 충돌 처리를 어떻게 다루는지 테스트해 보세요. 이는 충돌 처리 메커니즘의 효율성(체이닝, 선형 조사, 제곱 조사, 이중 해싱) 및 스트레스 상황에서의 구조적 무결성을 테스트하는 것을 포함합니다.\n\n## 샘플 테스트 구현:\n\n- 체이닝: pytest fixtures를 사용하여 여러 항목이 동일한 버킷으로 해싱되는 시나리오를 만들고 해당 항목을 검색하고 삭제할 수 있는지 확인하세요. 버킷 내에 있는 범위가 광범위한 목록을 어떻게 처리하는지 테스트해 보세요.\n\n![이미지](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_12.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Linear Probing: 해시 테이블이 충돌을 해결하는 방법을 테스트해보세요. 다음 사용 가능한 슬롯을 찾아내는 방법을 확인해보세요. 필요에 따라 항목이 올바르게 덮어씌워지거나 업데이트되는지, 그리고 테이블이 필요할 때 확장되는지 확인하세요.\n\n![이미지](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_13.png)\n\n3. Quadratic Probing: 선형 조사와 유사하지만, 서로 다른 초기 충돌에 대해 테스트하고 이차 조사 계산이 항목을 충돌하지 않는 슬롯에 올바르게 배치하는지 확인하세요.\n\n![이미지](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 이중 해싱: 이차 해시 함수를 사용하여 충돌을 줄이는 효과를 테스트해 보세요. 이중 해싱 방법이 다른 방법보다 테이블에 항목을 더 고르게 분산시키는지 확인하세요.\n\n![image](/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_15.png)\n\n## 6.2 해시 테이블 구현에서의 일반적인 문제 해결 방법 디버깅\n\n해시 테이블을 디버깅하는 것은 주로 충돌 처리, 해시 함수 분배, 그리고 동적 크기 조정과 관련된 문제를 식별하는 과정을 포함합니다. 다음은 일부 전략입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 충돌 처리: 요소가 자주 손실되거나 덮어쓰이는 경우 충돌 해결 논리를 검토하십시오. 삽입, 삭제 및 조회가 충돌하는 키를 올바르게 처리하도록 확인하십시오.\n- 해시 함수 품질: 해시 함수에 의한 분포의 부족은 성능 병목 현상을 야기할 수 있습니다. 일부 버킷이 과도하게 사용되는 경우, 해시 함수를 수정하는 것을 고려하십시오. 키의 분포를 버킷 간에 테스트하면 이 문제를 강조할 수 있습니다.\n- 메모리 누수 및 오버플로우: 수동 메모리 관리가 필요한 언어에서 특히 관련이 있지만 Python에서는 쓰레기 수집을 방해하는 의도치 않은 참조를 확인하십시오. 또한, 크기 조정 논리가 오버플로우나 과도한 재할당을 유발하지 않고 메모리를 적절하게 관리하는 것을 확인하십시오.\n- 동시성 문제: 해시 테이블이 멀티스레드 응용 프로그램에서 사용되는 경우, 경합 조건이 데이터 구조를 손상시킬 수 있습니다. 락을 구현하거나 동시성 데이터 구조를 사용하여 쓰레드 안정성을 보장하십시오.\n\n# 7. 고급 주제\n\n## 7.1 동적 크기 조정을 통한 해시 테이블 성능 향상\n\n요소 수가 증가함에 따라 해시 테이블에서 효율적인 성능을 유지하기 위해 동적 크기 조정은 중요한 기능입니다. 크기 조정 없이 로드 팩터(요소 수와 버킷 수의 비율)가 증가하면 더 많은 충돌이 발생하여 검색 시간이 길어집니다. 성능을 향상시키기 위해 해시 테이블은 다음과 같이 동적으로 크기를 조정할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크기 두 배로 늘리기: 로드 팩터가 일정 임계치(일반적으로 0.7 또는 0.75로 설정)를 초과하면 해시 테이블의 크기가 두 배로 증가됩니다. 이 과정은 현재 버킷 수의 두 배인 새 해시 테이블을 생성하고 모든 기존 요소를 새 테이블로 재해싱하는 과정을 포함합니다.\n- 크기 반으로 줄이기: 이와 유사하게, 로드 팩터가 낮은 임계 값을 초과할 때(예: 0.1), 해시 테이블의 크기가 절반으로 줄어들어 공간을 절약하고 데이터 크기가 감소하는 시나리오에서 효율성을 유지합니다.\n\n동적 재크기 조정을 구현하는 것은 크기 조정 작업 중 데이터 무결성을 보장하고 최소한의 성능 영향을 미치도록 주의 깊게 처리해야 합니다.\n\n## 7.2 실제 응용 및 해시 테이블 최적화에 대한 논의\n\n해시 테이블은 소프트웨어 엔지니어링에서 널리 사용되며, 빠른 데이터 검색이 중요한 다양한 응용 프로그램에서 사용됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터베이스: 해시 테이블은 많은 데이터베이스 인덱스 메커니즘을 구동하며 레코드의 빠른 조회, 삽입 및 삭제를 가능케 합니다.\n- 캐싱 시스템: 많은 웹 및 응용프로그램 서버에서 해시 테이블을 사용하여 캐싱을 수행하여, 자주 액세스되는 데이터를 빠르게 검색 가능한 형식으로 저장함으로써 데이터베이스에 대한 요청 수를 줄입니다.\n- 고유 항목 추적: 해시 테이블은 일관된 시간 성능 특성으로 인해 고유 항목을 추적하거나 항목 존재 여부를 확인하는 작업에 이상적입니다.\n\n최적화에는 충돌을 최소화하는 적절한 해시 함수 선택, 유니버설 해싱과 같은 기술 사용, 캐시 성능을 향상시키기 위한 메모리 할당 전략 최적화가 포함될 수 있습니다.\n\n## 7.3 Python의 내장 dict와 사용자 정의 해시 테이블 비교\n\nPython의 내장 dict는 본질적으로 Python 언어에 통합된 높은 최적화 수준의 해시 테이블입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능: Python의 dict는 C로 구현되어 있어 순수 Python으로 작성된 사용자 지정 해시 테이블보다 속도가 빠릅니다. 낮은 수준의 최적화와 Python의 동적 타입 변환으로 인한 오버헤드가 없기 때문에 이점을 가지고 있습니다.\n- 기능: Python의 dict는 추가 기능으로, 순서를 유지하는 특성(파이썬 3.7 이후)과 같이 기본 해시 테이블 구현에서는 일반적으로 제공되지 않는 기능을 제공합니다.\n- 사용 편의성: 내장 타입인 dict는 Python의 구문과 표준 라이브러리에서 직접 지원되므로 사용자 정의 해시 테이블을 구현하는 것보다 사용하기 더 편리합니다.\n\n사용자 정의 해시 테이블은 특정 요구 사항에 맞게 맞춤화될 수 있지만 대부분의 응용 프로그램에서는 Python의 dict가 충분한 성능과 기능을 제공하므로 사용자 지정 해시 테이블을 구현할 필요가 없습니다. 단 dict가 지원하지 않는 특정 동작이 필요한 경우(충돌 처리 또는 실시간 크기 조정 임계값과 같은), 사용자 지정 해시 테이블을 구현해야 합니다.\n\n# 결론\n\n본 문서에서는 Python에서 해시 테이블을 구현하는 것에 대해 깊이 있는 내용을 제공했습니다. 충돌 해결 방법으로 연결, 선형 조사, 제곱 조사 및 이중 해싱을 포함하여 다양한 방법을 탐구했습니다. 우리는 각 방법이 충돌을 처리하고 해시 테이블의 성능을 최적화하는 방식에 대해 상세히 설명했으며, 효과적인 응용에 대한 포괄적인 안내서를 제공했습니다. 또한 다양한 시나리오에서 해시 테이블의 신뢰성과 효율성을 보장하기 위한 상세한 테스트 방법을 다루었습니다. 이 토론을 통해 데이터 구조에 대한 이해력을 향상시키는 동시에 Python 프로젝트에서 복잡한 데이터 관리 도전에 필요한 실무 기술을 갖출 수 있습니다. 철저한 테스트 방법을 통합하여 구현의 무결성과 성능을 향상하는 방법을 소개했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 평문 기술 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나기 전에:\n\n- 글쓴이를 클릭하고 팔로우하기를 잊지 마세요️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementingaHashTableinPythonStep-by-Step_0.png","tag":["Tech"],"readingTime":15},{"title":"퀀트 투자  알파 리서치를 위한 요소 구성 방법 피처 엔지니어링","description":"","date":"2024-06-22 14:12","slug":"2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_0.png\" /\u003e\n\n어린 계량 연구자를 위해, 판매 측면이든 매입 측면이든 교모명지의 목표는 언제나 모델을 적용하기 전에 어디서 시작하고 다양한 데이터 소스를 어떻게 모아야 하는지입니다. 제가 비슷한 어려움을 겪었고, 때때로 아직도 겪지만 이제는 데이터를 보완하는 가장 적합한 방법에 대해 고민하게 됩니다. 이로서 이전 버전보다 조금 더 정확성을 향상시킬 수 있는지 알아보고 있죠.\n\n그래서 이 기사를 작성하고 있는데, 여러분을 도와 처음 시작하도록 하는 것을 목표로 하고 있습니다. 아래와 같은 Factor를 구축하는 방법을 가르쳐 드리겠습니다:\n\n- 지연 수익 및 모멘텀 요인\n- Fama 요인\n- 산업 별과 같은 재량적 요인들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것들만으로 알파를 생성하기에는 충분하지 않지만, 같은 마음가짐과 방법론을 갖고 있으면 직접 기능을 개발할 수 있을 거에요.\n\n단계 1: 원시 데이터 가져오기\n\n제가 좋아하는 몇 가지 이름을 사용하여 매일의 티커 가격을 야후 파이낸스 패키지를 통해 가져오고 있어요.\n\n```python\nimport pandas as pd\nimport numpy as np\n# 필수 패키지 가져오기\nimport yfinance as yf\n\n# 티커 데이터를 검색하려는 시간 범위 설정\nPeriodStart = \"2000-01-01\"\nPeriodEnd  = \"2024-05-24\"\n# 티커 목록을 리스트에 넣기\ntickerlist = [\"NVDA\", \"AMZN\", \"AAPL\"]\n\n# 여기서는 조정 종가만 가져오고 있습니다(주식 분할/배당금 등이 반영된 가격입니다).\ndf = yf.download(tickerlist, start = PeriodStart, end = PeriodEnd)['Adj Close']\ndf.head()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_1.png\" /\u003e\n\n만약 이 패키지에 대해 아직 익숙하지 않거나 이 패키지를 통해 사용 가능한 다른 유용한 데이터 포인트에 대해 상기시키려면 다른 기사를 추천드릴게요. 지금까지 시장 데이터에 대한 최고의 무료 자료입니다.\n\n단계 2.1: 모멘텀 팩터 구성\n\n일반적으로 월간 리밸런스 전략을 사용합니다 (또한 파마 팩터는 월간 기준으로 업데이트됩니다). 그래서 제가 일별 티커를 월별로 리샘플링할 겁니다. 그리고 당신도 원하는 주기로 이 빈도를 변경할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndf_monthly = df.resample('M').last()\n\nprint(len(df), len(df_monthly))\ndf_monthly.tail()\n```\n\n![Image 2](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_2.png)\n\n![Image 3](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_3.png)\n\nWe then transform the data following these steps:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 각 티커에 대해 1개월, 2개월, 3개월 등 기간별 수익률을 계산합니다.\n- 이상값을 제거하기 위해 수익률을 winsorize합니다. 여기서는 상위 5%와 하위 5%를 정의합니다.\n- 한 달 이상의 수익률의 경우, 이를 월 단위로 복리화합니다.\n\n```js\nlags = [1,2,3,6,9,12,24]\ndf_momentum = pd.DataFrame()\noutlier_cutoff = 0.05\n\nfor lag in lags:\n    df_momentum[f'return_{lag}m'] = (df_monthly\n                           .pct_change(lag)\n                           .stack()\n                           .pipe(lambda x: x.clip(lower=x.quantile(outlier_cutoff),\n                                                  upper=x.quantile(1-outlier_cutoff)))\n                           .add(1)  \n                           .pow(1/lag)\n                           .sub(1)\n                           )\n\n\ndf_momentum = df_momentum.swaplevel().sort_index()\n\ndf_momentum\n```\n\n![이미지](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_4.png)\n\n말씀드린대로, 이 모든 숫자는 서로 다른 기간의 월간 비복리 수익률입니다. 월간 수익률 시리즈 상관 관계를 보여주는 간단한 플롯을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport seaborn as sns\nsns.clustermap(df_momentum.corr('spearman'), annot=True, center=0, cmap='vlag', figsize=(6, 6))\n```\n\n![Image](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_5.png)\n\n현재 월에 대한 금월 수익률의 차이를 계산하여 모멘텀을 얻습니다.\n\n```python\n# 더 긴 기간 수익률에서 지난달 수익률을 뺌으로써 모멘텀 팩터를 얻습니다\nfor lag in [2, 3, 6, 9, 12, 24]:\n    df_momentum[f'return_{lag}m_1m'] = df_momentum[f'return_{lag}m'] - df_momentum['return_1m']\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_6.png)\n\n단계 2.2: 파마 요인 구축하기\n\n파마 개념은 요인 모델의 기초를 구축합니다. 파마 요인 구축에 관한 다른 전체 기사가 있습니다. 그래서 여기에서는 자세한 내용을 생략하겠습니다. 다만, 파마 결과는 YYYYMM 형식으로 반환되며, 이러한 요인들을 위쪽의 모멘텀과 함께 결합하려면 이를 월말 날짜로 변환해야 합니다.\n\n```js\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport pandas_datareader.data as web\nfrom statsmodels.regression.rolling import RollingOLS\nimport statsmodels.api as sm\n\n# 파마 요인 받아오기\nfama_factors = web.DataReader('F-F_Research_Data_5_Factors_2x3', 'famafrench', start='2000')[0].drop('RF', axis=1)\nfama_factors.index = fama_factors.index.to_timestamp()\nfama_factors = fama_factors.resample('M').last()\n\n# 실제 월 별 수익과 요인 결합\nfama_factors = fama_factors.join(df_momentum['return_1m'])\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_7.png)\n\n그런 다음 각 요소의 베타를 롤링 12개월 회귀분석을 통해 계산합니다.\n\n```js\nT = 12\nbetas = (fama_factors.groupby(level='Ticker',\n                             group_keys=False)\n         .apply(lambda x: RollingOLS(endog=x.return_1m,\n                                     exog=sm.add_constant(x.drop('return_1m', axis=1)),\n                                     window=min(T, x.shape[0]-1))\n                .fit(params_only=True)\n                .params\n                .drop('const', axis=1)))\nbetas.describe()\n\nsns.clustermap(betas.dropna().corr(), annot=True, center=0, cmap='vlag')\n```\n\n![image](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_9.png)\n\n```js\ndf_momentum = df_momentum.join(betas.groupby(level='Ticker').shift()).dropna()\n\ndf_momentum.info()\ndf_momentum[['Mkt-RF', 'SMB', 'HML', 'RMW', 'CMA']].describe()\n```\n\n![image](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_10.png)\n\n**단계 2.3:** 판단 데이터에 대한 더미 요인 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n야후쿼리 패키지를 이 yahoo에도 적용하였습니다. 이 패키지를 이용하면 기업 수준의 모든 참조 데이터를 제공합니다. 여기서는 단순히 기업 섹터를 보조 데이터로 추가 기능으로 데이터 프레임에 추가하는 방법을 보여드리겠습니다.\n\n```js\nimport yahooquery as yq\ntickers = yq.Ticker(tickerlist)\ndf_ref = pd.DataFrame(tickers.asset_profile)\n\ndf_sector = df_ref.loc['sector', :].to_frame()  #.index.rename('Ticker')\ndf_sector.index = df_sector.index.rename('Ticker')\ndf_sector\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_11.png\" /\u003e\n\n```js\ndf_momentum = df_momentum.join(df_sector)\n\n# 더미 데이터 생성\ndf_dummy = pd.get_dummies(df_momentum, \n                          columns = ['sector'])\n\n# 이 방법으로 여러 열 이름을 체계적으로 변경하는 방법을 배웠습니다. 매우 효율적이에요!\ndf_dummy = df_dummy.rename(columns = lambda x: x.replace('sector_', ''))\ndf_dummy.info()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Feature Engineering](/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_12.png)\n\n이제 머신 러닝 알고리즘을 적용하기 전에 효과적으로 feature를 구성하는 방법을 보았습니다. 일반적인 주제는 dataframe에 일치하는 ticker 및 날짜의 일관된 인덱스 이름과 합병 전에 일관된 날짜를 보장하는 것입니다. 동일한 마인드셋으로 판매, 인적 자본 데이터와 같은 대체 데이터를 동일한 테이블에 결합할 수 있습니다.\n\n이 기사가 도움이 되었기를 바랍니다. 공감이나 댓글을 남기고 생각을 알려주세요!\n\n즐거운 코딩과 유익한 투자되세요 :)\n","ogImage":{"url":"/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_0.png"},"coverImage":"/assets/img/2024-06-22-QuantInvestmenthowIconstructFACTORSforalpharesearchfeatureengineering_0.png","tag":["Tech"],"readingTime":7},{"title":"JAX를 배워야 하는 이유 분자 동역학 쇼케이스","description":"","date":"2024-06-22 14:08","slug":"2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase","content":"\n\n제 파이썬 스크립트를 최적화하기 위해 PyTorch로는 실망을 경험한 후 JAX를 사용하기 시작했어요. 제 프로젝트는 주로 두 가지 요소로 구성되어 있었어요: 원자의 위치에 기반한 디스크립터 계산 및 이러한 디스크립터를 여러 신경망의 입력으로 사용하여 입자 시스템의 총 잠재 에너지와 힘을 예측하는 것이었죠. 신경망 부분은 충분히 빨랐지만, 디스크립터 계산, 특히 그라디언트 평가는 TorchScript를 사용한 후에도 효율적으로 수행되지 않았어요. 자동 미분을 지원하는 Python의 대안 프레임워크를 찾던 중 JAX를 발견했어요. JAX는 (물리학에 대한 인식이 있는) 기계 학습 모델을 구축하는 데 매우 효과적이었고, 필요한 유연성과 성능을 제공했어요.\n\n![JAX 이미지](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png)\n\nPyTorch를 사용하는 데 어떠한 이의도 없어요; 사실, 언어 처리나 객체 감지 작업을 포함한 기계 학습 모델을 구축할 때 자주 사용해요. 그러나 사용자 정의 및 최적화된 모델을 개발하려는 경우에는 파이썬에서 아마도 처음부터 사용자 정의 모델을 개발하는 것이 목표라면 최적의 선택이 아닐 수도 있어요. PyTorch는 많은 면에서 뛰어나지만, 매우 사용자 정의 및 특정한 모델 아키텍처에 대해서는 더 나은 성능을 제공하는 더 적합한 대안이 있을 수 있어요.\n\nJAX는 자동 미분(autodiff), Just-In-Time (JIT) 컴파일, GPU 가속 계산 및 벡터화된 계산을 지원하는 등 의도한 요구 사항을 완벽하게 충족하는 다양한 기능을 제공해요. 또한 JAX는 불변성을 다루는 방식으로 함수형 프로그래밍 패러다임에 부합하게 처리해요. 이 게시물을 통해 JAX에 대한 실질적 경험을 공유하고, 여러분의 프로젝트에 JAX를 주저없이 도입하고 사용할 동기를 제공하는 것이 제 목적이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 필수 패키지\n\n이 가이드를 따라하기 위해 몇 가지 파이썬 패키지를 설치해야 합니다.\n\n- JAX: Python에서 고성능의 수치 연산 라이브러리로, 자동 미분과 CPU 및 GPU에서 최적화된 실행을 제공합니다. 설치 지침에 따라 설치해 주세요.\n- ASE: 원자 구조 시뮬레이션을 설정, 조작 및 분석하는 데 사용되는 툴킷으로, 계산 재료과학 분야에서 널리 사용됩니다.\n설치: $ pip install ase\n- Pantea: 현재 개발 중인 내 Python 패키지로, 원자간 포텐셜을 위한 머신러닝 모델을 개발하는 데 사용됩니다.\n설치: $ pip install pantea\n- NGLView (선택적): 분자 구조와 궤적을 대화적으로 보는 데 사용되는 주피터 위젯입니다.\n설치: conda install nglview -c conda-forge\n\nJAX는 시스템의 GPU를 자동으로 사용하며, 그렇지 않은 경우 CPU를 기본적으로 활용합니다. 또한 JAX_PLATFORM_NAME 환경 변수를 사전에 조정하여 계산 장비를 수동으로 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 JAX는 싱글 포인트 정밀도를 나타내는 float32 데이터 유형을 사용합니다. 하지만 과학 시뮬레이션은 보다 높은 정확도를 위해 더블 정밀도 float64를 필요로 합니다. 계산 성능을 향상시키기 위해 가능한 경우 낮은 정밀도를 선택하고 메모리 사용량을 줄이는 것이 권장됩니다(대략적으로 2배). \n\n아래 스크립트는 JAX를 구성하여 디바이스를 선택하고 더블 정밀도를 활성화하는 방법을 보여줍니다.\n\n```js\nimport os\nos.environ[\"JAX_PLATFORM_NAME\"] = \"cpu\"  # GPU 컴퓨팅 비활성화\nos.environ[\"JAX_ENABLE_X64\"] = \"1\"       # 더블 정밀도 활성화\n\nimport jax\n...\n```\n\n간단한 예제에서는 기본 float32 정밀도를 사용하겠지만 분자 동력학 시연을 위해 더블 정밀도를 사용할 것입니다. 또한, 이 게시물의 모든 계산은 명시적으로 언급되지 않는 한 제 노트북의 GeForce MX130 GPU에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 설명된 단계를 따르면 이 포스트에서 다룬 예제를 재현하는 데 필요한 필수 도구를 제공받을 수 있습니다. 시작해 봅시다!\n\n# JAX의 이점\n\nJAX는 JIT 컴파일링, 가속 컴퓨팅, 그리고 자동 미분을 활용한 배열 지향 계산을 위한 오픈 소스 및 조립 가능한 Python 라이브러리로, 머신 러닝, 최적화, 과학적 시뮬레이션과 같은 고성능 숫자 계산을 가능하게 합니다. 사용자는 익숙한 NumPy 구문을 사용하여 코드를 작성할 수 있으며, 해당 코드를 자동적으로 효율적으로 변환하여 GPU 및 TPU에서 실행할 수 있습니다. 이는 계산이 집중적으로 필요한 작업에 매우 적합합니다. 선형 대수 가속 X (LAX)는 JAX 라이브러리 내의 서브 모듈로, 다양한 선형 대수 루틴의 최적화된 구현을 제공합니다. JAX의 문서 페이지를 방문해보시기를 강력히 권장하며, 그곳에서 다양한 정보와 리소스를 제공하고 있습니다. 예를 들어 이 튜토리얼을 참조해 보세요.\n\n일부 사람들은 JAX를 단순히 멀티 스레드 NumPy 라이브러리로 설명하지만, 저는 그렇지 않다고 주장합니다. JAX는 그 이상의 기능을 제공합니다. 다음 섹션에서는 내 프로젝트 개발에 중요한 역할을 한 JAX의 주요 기능 중 일부를 소개하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## I. JIT-컴파일\n\nJust-In-Time (JIT) 컴파일은 코드를 런타임에서 컴파일하는 방법으로, 미리 컴파일하는 것이 아니라 코드를 최적화하여 해당 시스템에서 실행되는 성능을 향상시킬 수 있습니다. Python 스크립트는 해석되며, 이는 코드가 Python 인터프리터에 의해 한 줄씩 읽히고 실행된다는 것을 의미합니다. 이는 인터프리터가 각 코드 라인을 처리한 후에 실행할 수 있기 때문에 컴파일된 코드보다 느릴 수 있습니다.\n\n그에 반해 JIT 컴파일은 Python 코드를 런타임에서 기계 코드로 변환하여 컴퓨터 CPU가 직접 실행할 수 있게 합니다. 이는 Python의 오버헤드를 효과적으로 제거하고 해석된 코드보다 성능을 향상시킬 수 있습니다. 배열을 입력으로 사용하여 결과를 반환하는 더미 커널 함수의 예시를 살펴보겠습니다:\n\n```python\nimport jax.numpy as jnp\n\ndef kernel(x):\n  \"\"\"더미 커널 함수입니다.\"\"\"\n  result = 0\n  for i in range(10):\n      result += i * jnp.sin(jnp.cos(x))\n  return result.sum()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n랜덤 입력 배열을 생성하고 JIT 컴파일 없이 구현된 함수 호출의 실행 시간을 측정해 봅시다.\n\n```js\nimport jax\n\nx = jax.random.normal(jax.random.key(2024), shape=(100_000, ))\n# Array([ 0.8188207 ,  0.70407075, -0.553007  , ..., -0.07251461,\n#       -1.353674  , -0.21451078], dtype=float32)\n\n%timeit kernel(x).block_until_ready()\n2.34 ms ± 134 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n%timeit은 Jupyter 노트북과 IPython에서 사용되는 매직 명령어로, 코드 조각의 실행 시간을 측정하는 데에 사용됩니다. 평균 실행 시간을 얻기 위해 코드를 여러 번 실행하여 성능의 정확한 측정을 제공합니다.\n\nJAX는 비동기 디스패치를 사용하므로, JAX 배열에 block_until_ready() 메서드를 호출하면 이러한 배열이 계산을 완료할 때까지 파이썬 프로그램 실행이 차단됩니다. 이는 계산 속도의 미세한 벤치마크를 작성할 때 권장되는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보고된 결과인 2.34 ms ± 134 µs는 각각 100번 실행한 7개의 루프를 기반으로 한 루프당 평균 시간과 표준 편차를 나타냅니다.\n\n이제 이 함수의 JIT 컴파일된 버전(데코레이터를 사용하여 적용할 수도 있음)을 만들고, 그 후에 실행 시간을 다시평가하겠습니다.\n\n```js\nimport jax \n\njitted_kernel = jax.jit(kernel)\n\n# 웜업 호출\n# jitted_kernel(x)\n\n%timeit jitted_kernel(x).block_until_ready()\n82.5 µs ± 1.9 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n속도 향상: 29배\n```\n\nJIT 함수의 웜업 호출은 일반적으로 성능을 컴파일하고 최적화하기 전에 실행됩니다. 함수 구현이 간단하기 때문에 이 단계를 생략했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일된 함수는 JIT 컴파일을 통해 달성한 상당한 성능 향상을 보여주며, 비컴파일된 버전보다 29배 빠르게 실행됩니다. 이러한 JAX 기능은 고성능 Python 함수를 작성하는 데 도움이 됩니다.\n\n## II. 자동 미분\n\n자동 미분은 함수의 도함수를 자동으로 계산하는 계산 기술이다. 수치 미분이 유한 차이를 사용하여 도함수를 근사하는 데 반해, 심볼릭 미분은 식을 조작하여 도함수를 찾는 반면, 자동 미분은 미분을 체인 룰을 체계적으로 적용함으로써 정확하고 효율적으로 평가합니다. 현재 자동 미분은 PyTorch, TensorFlow, 그리고 JAX와 같은 딥러닝 프레임워크에서 중요한 역할을 하는데, 그레이디언트 하강과 같은 최적화 알고리즘에 필요한 그레이디언트를 효율적으로 계산할 수 있기 때문에 매우 가치 있는 기능입니다.\n\n자동 미분은 JAX의 핵심 기능 중 하나로, 그레이디언트를 계산하는 프로세스를 단순화하고 가속화합니다. JAX는 미분을 수행하기 위한 여러 함수를 제공하는데, 그 중에서도 jax.grad가 가장 주목할 만한데, 이 함수는 입력에 대한 스칼라 값 함수의 그레이디언트를 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제 커널을 고려해 봅시다. jax.grad를 사용하여 다음 코드를 통해 각 입력에 대한 출력의 경사도를 쉽게 계산할 수 있습니다:\n\n```js\nimport jax \n\ngradient_kernel = jax.grad(kernel)\n\nkernel(x)\n# Array(2401043.5, dtype=float32)\n\ngradient_kernel(x)\n# Array([-25.491356 , -21.069756 ,  15.582619 , ...,   1.7687505,\n#        42.92778  ,   5.35899  ], dtype=float32)\n\n%timeit gradient_kernel(x).block_until_ready()\n56.3 ms ± 7.11 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n\n더불어 JAX의 조합 가능한 기능 덕분에 jax.grad를 jax.jit와 매끄럽게 결합하여 커널의 경사도를 자동으로 계산하는 최적화된 함수를 만들 수 있습니다. 이렇게 함으로써 JAX의 자동 미분 기능을 활용하여 효율적으로 경사도를 계산하면서, JIT 컴파일을 통해 성능을 향상시킬 수 있습니다.\n\n```js\nimport jax \n\njitted_gradient_kernel = jax.jit(gradient_kernel) \n\n%timeit jitted_gradient_kernel(x).block_until_ready()\n192 µs ± 37.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n분자 시뮬레이션의 맥락에서 물리 시스템 내의 원자간 힘은 총 포텐셜 에너지 함수의 기울기에서 얻어집니다. 이 관계는 자동 미분의 중요성을 강조하며, 이는 힘의 구성 요소를 정확하고 효율적으로 계산하는 수단을 제공합니다. 자동 미분을 통해 필요한 포텐셜 에너지 함수의 도함수를 정확하게 계산함으로써 힘의 구성 요소가 높은 정밀도로 결정될 수 있습니다.\n\n## III. 자동 벡터화\n\n벡터화된 계산은 개별 요소가 아닌 전체 배열에 연산을 적용하는 과정을 말합니다. 이를 통해 현대 CPU 및 GPU(i.e. SIMD)의 기능을 활용하여 병렬로 계산을 수행함으로써 전통적인 루프 기반 접근 방식보다 훨씬 빠른 실행 시간을 얻을 수 있습니다. Python에서 효율적인 코드를 작성하기 위해서는 대부분의 경우 루프 사용을 피하고 배열에 작용하는 범용 함수의 효율적인 구현에 의존하는 것이 좋습니다. 저의 경험 상, 수치 계산 Python으로 전환하는 과정은 사고 방식의 변화를 요구합니다. C/C++와 같은 저수준 프로그래밍 언어는 보통 다수의 루프를 사용하지만, 수치 계산 Python의 접근 방식은 루프를 피하고 논리를 벡터 함수로 변역하는 데 중점을 두고 있습니다. 벡터화된 계산을 활용하면 전체적인 성능이 크게 향상됩니다. NumPy는 벡터화된 계산을 활용하여 함수의 성능과 효율성을 크게 향상시킵니다.\n\njax.vmap 변환은 함수의 벡터화된 구현을 자동으로 생성하여 배열 상에서 함수를 병렬 및 효율적으로 적용하기 쉽게 만듭니다. 또한 명시적인 루프가 필요 없도록 코드를 간소화시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위치 벡터 배열 간의 거리를 계산하는 예제는 분자 시뮬레이션에서 원자 간의 거리를 결정하는 데 필수적이므로 이 문맥에서 특히 중요합니다. 두 배열 x와 y가 있는 상황을 가정해보겠습니다. 각 배열은 원자 집합에 대한 위치 벡터를 포함하고 있습니다. 두 배열 모두 차원이 (원자 수, 3)인데, 여기서 원자 수를 나타내는 natoms가 있고, 배열의 각 벡터는 원자의 3D 좌표를 포함합니다. 우리의 목표는 이러한 배열에서 각 벡터 쌍 간의 거리를 포착하는 거리 행렬을 계산하는 것입니다. 아래 함수는 두 입력 배열 간의 이 거리 행렬을 반환합니다:\n\n```js\nimport jax.numpy as jnp\n\ndef calculate_distances(x, y):\n    distances = []\n    nrows, _ = x.shape\n    for i in range(nrows):\n        distances_from_single_point = jnp.sqrt(((x[i] - y)**2).sum(axis=1))\n        distances.append(distances_from_single_point)\n    return jnp.array(distances)\n```\n\n여기서는 배열 계산을 사용하여 배열 x의 각 점에서 배열 y의 모든 점까지의 거리를 효율적으로 계산했습니다. 예를 들어, 브로드캐스트된 용어 x[i] — y는 명시적 루프가 필요 없이 요소별 뺄셈을 수행할 수 있도록 합니다. 이로써 연산 효율성과 명확성을 높일 수 있습니다.\n\n이 프로세스는 JAX에서 자동으로 효율적으로 벡터화될 수 있습니다. jax.vmap을 사용하여 배열의 포지션 벡터를 병렬로 처리하는 함수로 단일 포인트에서 작동하는 함수를 변환할 수 있습니다. 이를 달성하기 위해 우선 단일 포인트를 처리하는 함수인 calculate_distances_from_single_point를 정의한 다음, jax.vmap을 사용하여 이 함수를 입력 배열의 첫 번째 인덱스에 적용하여 for 루프 없이 배치에 걸쳐 효율적으로 계산할 수 있습니다. 이 접근 방식은 코드를 단순화하는데 도움이 되며, 빠른 실행을 위해 JAX의 최적화 능력을 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport jax\n\ndef calculate_distances_from_single_point(xi, y):\n    return jnp.sqrt(((xi - y)**2).sum(axis=1))\n\nvmapped_calculate_distances = jax.vmap(\ncalculate_distances_from_single_point, \nin_axes=(0, None)\n)\n```\n\nin_axes=(0, None)는 벡터화된 함수의 입력 축을 지정합니다. 이 경우 첫 번째 인자(xi)가 첫 번째 축(0)을 따라 매핑되고, 두 번째 인자(y)는 변경되지 않는 것(None)을 나타내며, 이는 모든 계산에서 동일하게 유지된다는 것을 나타냅니다.\n\n두 구현은 동일한 결과를 생성합니다. 아래의 어서션은 for-loop 구현으로 계산된 거리가 벡터화된 구현으로 계산된 거리와 동일함을 보장합니다.\n\n```js\nimport jax\n\n# 형태(shape)가 (natoms, dim)인 랜덤 배열 생성\nx = jax.random.normal(jax.random.key(2024), shape=(100, 3))\n\nassert jnp.allclose(\n  calculate_distances(x, x), \n  calculate_distances_vmap(x, x)\n) \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 매핑된 함수의 성능은 벡터화가 더 잘 되어 있기 때문에 현저히 빠릅니다. 또한 구현이 더 가독성이 좋습니다. 시간 프로파일링 결과는 다음과 같이 이러한 차이를 명확히 보여줍니다:\n\n```js\n%timeit calculate_distances(x, x).block_until_ready()\n93.5 ms ± 6.04 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n가속:  1배\n\n%timeit vmapped_calculate_distances(x, x).block_until_ready()\n2.54 ms ± 147 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n가속:  36배\n```\n\n이제 JIT 컴파일과 jax.vmap을 다시 결합하여 더 나은 성능을 얻을 수 있습니다.\n\n```js\njitted_vmapped_calculate_distances = jax.jit(vmapped_calculate_distances) \n\n%timeit jitted_vmapped_calculate_distances(x, x).block_until_ready()\n60.3 µs ± 1.59 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n가속: 1558배\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 조합은 JAX의 고급 최적화 기술을 최대한 활용하여 계산의 효율성을 극대화합니다. 이것은 이 게시물에서 논의하고 싶었던 내용입니다.\n\n다음 섹션에서는 JAX가 실제 문제를 해결하고 Python에서 고성능 애플리케이션을 구축하는 믿을 만한 프레임워크일 수 있다는 것을 보여주기 위해 분자 역학 쇼케이스를 제시할 것입니다.\n\n# 분자 역학 쇼케이스\n\n문서에서 직관적이고 명확한 코드 예제들은 복잡한 문제를 다룰 때 종종 부족함을 보입니다. 더 심각한 문제에 참여함으로써 우리는 항상 심층적으로 이해하고 최적화된 애플리케이션을 개발하기 위해 고급 기능을 활용할 수 있습니다. 이 쇼케이스가 분자 시뮬레이션의 복잡한 세부 사항에 집중하지 않더라도 도움이 될 것으로 기대합니다. 이 쇼케이스가 강조하려는 것은 스크립트를 최적화하는 데 필요한 주요 JAX 기능을 강조하기 위한 것입니다. 이 예제는 도메인 지식의 기본적인 이해를 돕기 위해 일부러 간단하게 유지되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## MD 시뮬레이션이란 무엇인가요?\n\n분자 역학(MD) 시뮬레이션은 원자와 분자의 물리적 움직임을 연구하는 강력한 계산 방법입니다. 이는 이러한 입자들의 움직임을 시뮬레이션하여 복잡한 시스템의 물리적 및 화학적 특성에 대한 자세한 통찰을 제공합니다. MD 시뮬레이션은 물리학, 화학, 재료과학 등 다양한 분야에서 널리 사용되며 실험적으로 포착하기 어려운 현상들을 미시적인 시각으로 제공합니다.\n\nMD 시뮬레이션의 중요한 부분은 힘 필드입니다. 이것은 분자 시스템의 잠재 에너지를 정의하는 수학적 함수와 매개변수의 집합입니다. 이것은 원자들이 서로 상호 작용하는 방식을 결정하여 그들의 움직임을 이끄는 힘을 제공합니다. 원자들은 뉴턴의 운동 방정식에 따라 움직이는데, 이는 힘에 의해 전달되는 작용에 반응하여 입자들의 위치와 속도가 어떻게 시간이 지남에 따라 변화하는지를 설명합니다. Verlet 알고리즘은 뉴턴의 운동 방정식을 해결하기 위한 흔히 사용되는 수치 적분 방법입니다.\n\n## 초기 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMD(simulation : Molecular Dynamics)를 시작하려면 원자의 위치와 속도를 일반적으로 특정 구성을 기반으로 초기화합니다. 예를 들어 실험 구조물이나 무작위로 생성된 배열을 기반으로 합니다. 아래의 코드는 ASE 패키지를 사용하여 헬륨 원자의 간단한 입방체 격자를 생성하고, 해당 구조를 Pantea에 만들어 JAX 배열에 저장된 원자 좌표 및 관련 정보를 나타내는 컨테이너를 생성합니다:\n\n```js\nfrom ase import Atoms\nfrom ase.visualize import view\nfrom pantea.atoms import Structure\n\nd = 6  # 원자 간 거리(애스트로름) \nunit_cell = Atoms('He', positions=[(d/2, d/2, d/2)], cell=(d, d, d))\ninitial_structure = Structure.from_ase(unit_cell.repeat((10, 10, 10)))\n\nview(atoms=initial_structure.to_ase(), viewer='ngl')\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_1.png\" /\u003e\n\n## 레너드-존스 힘장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 쌍의 원자 간 상호 작용을 설명하는 간단한 힘 필드 중 하나는 레너드-존스(LJ)입니다. 이것은 약한 분자간 인력과 척력 모델링에 특히 유용합니다. 주어진 입력 구조체에 대한 총 레너드-존스 포텐셜 에너지와 힘 성분을 계산하는 퍼텐셜 클래스를 정의해 봅시다.\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom jax import Array\nfrom pantea.atoms import Structure\nfrom typing import NamedTuple, Optional\n\nclass LJPotentialParams(NamedTuple):\n    epsilon: Array\n    sigma: Array\n\nclass LJPotential:\n    \"\"\"레너드-존스 포텐셜의 간단한 구현체입니다.\"\"\"\n    def __init__(\n        self,\n        sigma: float,\n        epsilon: float,\n        r_cutoff: float,\n    ) -\u003e None:\n        self.sigma = jnp.array(sigma)\n        self.epsilon = jnp.array(epsilon)\n        self.r_cutoff = jnp.array(r_cutoff)\n    def __call__(self, structure: Structure) -\u003e Array:\n        \"\"\"총 포텐셜 에너지를 계산합니다.\"\"\"\n        return _compute_total_energy(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n    def compute_forces(self, structure: Structure) -\u003e Array:\n        \"\"\"모든 원자에 대한 힘 성분을 계산합니다.\"\"\"\n        return _compute_forces(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n```\n\nLJPotentialParams는 레너드-존스 포텐셜을 위해 두 가지 필수 매개변수를 저장하는 NamedTuple입니다.\n\nLJPotential 클래스는 입력 구조체를 가져와서 두 내부 커널 함수인 _compute_total_energy와 _compute_forces로 필요한 인수를 전달합니다. 이 함수들은 실제 물리량을 계산하고 반환하는 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 JAX 기능을 활용하여 함수를 최적화하는 흥미로운 부분이 시작됩니다. 다음에는 에너지와 힘 계산의 커널을 따로 논의할 것입니다.\n\n## 포텐셜 에너지\n\n이론\n두 개의 원자 사이의 레너드-존스 포텐셜은 다음 방정식으로 정의됩니다:\n\n![equation](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nV(r)는 두 입자 간의 거리 r의 함수로써의 위치 에너지를 나타냅니다. ε 파라미터는 인력의 강도를 나타내는 위치 에너지 우물의 깊이를 나타냅니다. σ 파라미터는 입자 간 위치 에너지가 제로가 되는 유한 거리로, 원자의 유효 지름을 나타냅니다. 첫 번째 항목은 장거리에서 우세한 반 데르 발스 힘을 설명하며, 두 번째 항목은 매우 짧은 거리에서 오바하는 전자 궤도의 중첩으로 인한 폴리 청반작용을 설명합니다. rcut는 위치 에너지가 제로로 간주되는 자르기 반지름입니다. 자르기는 효율성과 물리적 정확성을 향상시키기 위해 상호 작용의 범위를 제한하는 데 사용됩니다.\n\nN 개의 입자 시스템에 대해서, 총 위치 에너지 U는 모든 입자 쌍에 대한 쌍별 상호작용의 합으로 다음과 같이 정의됩니다:\n\n![equation](https://carbon.now.sh/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_3.png)\n\n여기서, rij는 원자 i와 원자 j 사이의 거리를 나타냅니다. 각 입자 쌍이 한 번만 고려되도록 (중복 계산 없음)하고, 자기 상호작용은 무시해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구현\n아래 파이썬 코드는 원자 쌍 간의 레너드-존스 포텐셜 에너지를 계산하는 함수를 정의합니다.\n\n```js\ndef _compute_pair_energies(params: LJPotentialParams, r: Array) -\u003e Array:\n    term = params.sigma / r\n    term6 = term**6\n    return 4.0 * params.epsilon * term6 * (term6 - 1.0)\n```\n\n_compute_pair_energies 함수는 거리(r)를 이용하여 원자 쌍의 레너드-존스 포텐셜 에너지를 계산합니다. 이 함수는 포텐셜 매개변수(params)를 사용하고 계산을 수행하여 포텐셜 에너지 배열을 반환합니다.\n\n다음으로, 우리는 원자 시스템의 총 레너드-존스 포텐셜 에너지를 계산하기 위해 쌍별 포텐셜을 합산하는 JIT 컴파일된 함수를 다음과 같이 정의합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom pantea.atoms.neighbor import _calculate_masks_with_aux_from_structure\n\n@jax.jit\ndef _compute_total_energy(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -\u003e Array:\n    masks, (rij, _) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_energies = _compute_pair_energies(params, rij)\n    pair_energies_inside_cutoff = jnp.where(masks, pair_energies, 0.0)\n    return 0.5 * jnp.sum(pair_energies_inside_cutoff)\n```\n\n_calculate_masks_with_aux_from_structure 함수는 거리가 잘림 거리 이내에 있고 자기 상호 작용을 제외한 각 원자 쌍에 대해 부울 배열 (마스크)을 계산합니다. 또한, 두 원자 간 거리를 포함하는 배열 (rij)을 반환하여 원자 간 잠재 에너지 평가를 다시 계산하지 않도록 합니다. 이 함수는 이 토론을 간소화하기 위해 Pantea에서 가져왔습니다. 거리를 계산하기 위해 시뮬레이션 상자의 주기적 경계 조건 (lattice)도 고려합니다.\n\n앞서 설명한 대로, _compute_pair_energies 함수는 잠재 에너지 매개변수와 거리 (rij)를 사용하여 각 원자 쌍에 대한 LJ 잠재 에너지를 계산합니다.\n\njnp.where는 거리가 잘림 거리를 벗어난 쌍에 대해 에너지를 0으로 설정하여 마스크를 적용합니다. 이 방법은 루프를 사용하지 않고 배열에 조건 로직을 효율적으로 적용합니다. np.where는 내부적으로 높도 최적화된 C 코드로 구현되어 있습니다. 이는 한 번에 전체 배열에 작동하며, JAX가 벡터화된 작업을 수행할 수 있는 능력을 활용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n총 에너지는 jnp.sum을 사용하여 반환됩니다. 각 쌍 상호 작용을 두 번 계산했기 때문에 0.5를 곱하여 고려합니다.\n\n간단히 말해, _compute_total_energy 함수는 원자 시스템의 전체 레나드-존스(Lennard-Jones) 포텐셜 에너지를 계산합니다. 우리는 먼저 절단 거리 내에 있는 원자 쌍을 판별하기 위해 부울 마스크를 생성합니다. 그런 다음, rij를 사용하여 모든 쌍에 대한 Lennard-Jones 에너지를 계산하고, 절단 값 내의 쌍 에너지를 필터링한 후, 절단 거리를 고려하여 쌍 에너지를 합산합니다. 이 결과 함수는 원자 위치에 기반한 총 상호 작용 에너지를 제공하여 MD 시뮬레이션에 중요한 역할을 합니다.\n\n이 작업이 번거로워 보일 수 있지만, 원자의 쌍 에너지는 어차피 계산해야 합니다. 과거에 if 문을 추가하여 이를 피해보려고 했지만, 이 구현과 비교했을 때 성능은 상당히 떨어졌습니다. 이 방법은 벡터화된 계산을 사용하기 때문에 전통적인 저수준 언어 접근 방식에서 새로운 배열 계산에 주력해야 함을 강조합니다. C/C++에서 모든 것을 최적화하는 데 며칠을 들일 수도 있지만, Python에서 이 방법을 통해 벡터화로 더 나은 성능을 달성할 수 있으면서 개발 시간도 훨씬 절약할 수 있습니다. 또한 많은 JAX 연산은 내부적으로 병렬화되어 있고 실행 시간을 더 최적화하기 위해 여러 스레드를 활용합니다.\n\n아래의 예시 코드는 1000개의 원자를 포함하는 입력 구조체에 대한 총 포텐셜 계산 및 예상 실행 시간을 보여줍니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nljpot(initial_structure)\n# Array(-0.00114392, dtype=float64)\n\n%timeit ljpot(initial_structure).block_until_ready()\n5.12 ms ± 38.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each))\r\n```\n\n## 힘 벡터\n\n이론\n레너드-존스 시스템에서 두 입자 간의 힘은 포텐셜 에너지에서 유도될 수 있습니다. 입자 i에 대한 입자 j로 인한 힘 벡터 Fij는 레너드-존스 포텐셜 V(rij)의 음의 그래디언트로 주어집니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nrij = ri — rj은 입자 j에서 입자 i를 가리키는 벡터를 나타냅니다. 우리는 힘에 대한 cutoff도 적용합니다. 입자 i에 작용하는 총 힘을 계산하기 위해 다른 모든 입자 j로부터의 기여를 합산합니다:\n\n\n![image](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_5.png)\n\n\n이것은 시스템 내 다른 모든 입자들로부터 입자 i에 작용하는 순 힘을 제외한 것을 제공합니다.\n\n구현\n아래 코드는 방정식 3을 사용하여 두 원자 쌍 간의 힘을 계산합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef _compute_pair_forces(params: LJPotentialParams, r: Array, R: Array) -\u003e Array:\n    term = params.sigma / r\n    term6 = term**6\n    coefficient = -24.0 * params.epsilon / (r * r) * term6 * (2.0 * term6 - 1.0)\n    return jnp.expand_dims(coefficient, axis=-1) * R\n```\n\n`_compute_pair_forces` 함수는 레너드-존스(Lennard-Jones) 포텐셜을 사용하여 원자 쌍 간의 힘을 계산합니다. 이 함수는 포텐셜을 정의하는 매개변수, 원자 간 거리 및 상대 위치 벡터를 입력으로 사용합니다.\n\n`jnp.expand_dims(factor, axis=-1) * R`: 상대 위치 벡터 R을 계산된 힘 인자로 조정하고, 곱셈 연산에서 브로드캐스팅에 적합한 차원임을 보장하기 위해 expand_dims를 사용합니다. 결과 배열은 각 쌍의 원자 간의 힘을 나타냅니다.\n\n이어서 Equation 4를 사용하여 총 힘을 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n@jax.jit\ndef _compute_forces(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -\u003e Array:\n    masks, (rij, Rij) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_forces = _compute_pair_forces(params, rij, Rij)\n    pair_forces_inside_cutoff = jnp.where(\n        jnp.expand_dims(masks, axis=-1),\n        pair_forces,\n        jnp.zeros_like(Rij),\n    )\n    return jnp.sum(pair_forces_inside_cutoff, axis=1)  \n```\n\n_compute_forces 함수는 최적화를 위해 JIT 컴파일을 사용하여 각 원자에 작용하는 총 힘을 계산합니다.\n\n_calculate_masks_with_aux_from_structure 함수는 커프트 부울 마스크를 계산하고 추가로 pairwise 거리 (rij)와 상대적 위치 벡터 (Rij)를 반환합니다.\n\njnp.where은 마스크가 True인 경우에만 계산된 pairwise 힘을 적용합니다. jnp.expand_dims(masks, axis=-1)를 사용하여 마스크 차원이 Rij와 곱셈 브로드캐스팅을 일치시킵니다. 마스크가 False인 경우 0 힘 벡터(jnp.zeros_like(Rij))를 할당합니다. 또한 JAX는 오버헤드를 줄이기 위해 메모리 풀을 사용하므로 0 크기의 벡터를 할당하는 것은 계산적으로 부담이 없습니다. 배열에 대한 참조 재할당은 실제 메모리 할당을 포함하지 않기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 jnp.sum(pair_forces, axis=1)은 각 원자에 작용하는 총 힘을 구하기 위해 쌍별 힘을 합산합니다.\n\n상자 내의 모든 원자에 대해 힘 구성 요소를 계산하고 실행 시간을 측정하는 유사한 예시 코드:\n\n```js\nljpot.compute_forces(initial_structure)\n# Array([[ 1.11173074e-21,  1.11173074e-21,  1.11173074e-21],\n#       ...,\n#       [-1.87935435e-21, -1.87935435e-21, -1.87935435e-21]],  dtype=float64)\n\n%timeit ljpot.compute_forces(initial_structure).block_until_ready()\n6.71 ms ± 4.63 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\r\n```\n\n지금까지 잘 진행되고 있어요!\n지금까지 우리는 MD 시뮬레이션을 위해 필요한 Lennard-Jones 포텐셜의 JAX 버전을 구현했습니다. 다음 단계는 이 포텐셜과 초기 구조를 사용하여 시스템을 시간 동안 시뮬레이션하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 분자동력학 시뮬레이션\n\n시스템 시뮬레이션을 위해 Pantea에서 제공하는 MDSimulator 모듈을 사용합니다. 이 모듈은 시뮬레이션이 어떻게 진행될지를 정의하는데, 적분 알고리즘, 온도 조절기 및 기타 필수적인 시뮬레이션 설정을 포함합니다. 시스템을 일정한 온도에서 시뮬레이션하고 있으므로, 온도 조절기를 정의하는 것이 필요합니다.\n\n다음 매개변수를 사용하여 MD 시뮬레이터를 초기화해 보겠습니다:\n\n```js\nfrom pantea.simulation import MDSimulator, BrendsenThermostat\n\ntime_step = 0.5 * units.FROM_FEMTO_SECOND      # 0.5e-15 초\nthermostat = BrendsenThermostat(               # 온도를 제어 \n  target_temperature=300.0,                    # 26°C의 상온\n  time_constant=100 * time_step                # 온도 조절 속도\n)\nsimulator = MDSimulator(time_step, thermostat)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 우리는 사실상 원자들과 그들 사이의 상호작용의 표현에 불과한 시스템을 만듭니다. 이 시스템에는 원자 위치, 속도, 그리고 상호작용 매개변수와 같은 정보가 포함됩니다. 입력 구조에서 시스템을 다음과 같이 생성할 수 있습니다:\n\n```js\nfrom pantea.simulation import System\n\nsystem = System.from_structure(\n  initial_structure,   # 원자 초기 위치\n  potential=ljpot,     # 원자간 상호작용으로 LJ 설정\n  temperature=300.0    # 온도에 기반한 원자 속도 초기화\n)\n```\n\n마지막으로, MD 시뮬레이션을 실행하기 위해 simulate 함수를 호출합니다.\n\n```js\nfrom pantea.simulation import simulate\n\n# simulate(sys, simulator) # 예열\nsimulate(system, simulator, num_steps=10000, output_freq=1000)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nnum_steps=10000: 이 매개변수는 수행할 시뮬레이션 단계의 총 수를 설정합니다. 각 단계는 일반적으로 모의 시간의 작은 증분에 해당하며, 이 동안 원자의 위치와 속도가 업데이트됩니다.\n\noutput_freq=1000: 이 매개변수는 시뮬레이션 결과가 출력되는 빈도를 지정합니다. 이 경우에는 데이터가 매 1000개의 시뮬레이션 단계마다 저장되거나 출력됩니다.\n\n결과로는 각 1000단계 후에 스텝, 온도, 포텐셜 에너지 및 압력과 같은 물리적 특성이 출력됩니다.\n\n![이미지](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 그림은 주기성 상자 내의 1000개 헬륨 원자에 대한 MD 시뮬레이션이 시간에 따라 어떻게 진행되는지 보여줍니다:\n\n![MD 시뮬레이션](https://miro.medium.com/v2/resize:fit:1400/1*7S2L0PRoZSHhxMf3UtIvxA.gif)\n\n성능\n아래 그래프에서 보듯이, 저희의 JAX 커널은 GPU의 거의 모든 용량을 효율적으로 활용하여 시뮬레이션을 수행합니다 (Device 1). 이 높은 수준의 자원 활용은 GPU의 컴퓨팅 파워를 최대로 이끌어내어 시뮬레이션의 속도와 성능을 현저히 향상시킵니다.\n\n![GPU 활용 그래프](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 노트북 CPU와 더 강력한 GPU인 A100에서도 동일한 MD 시뮬레이션을 실시했습니다. 결과는 GPU 계산으로 상당한 속도 향상을 보여줍니다. GPU 하드웨어를 사용하는 중요성을 강조하기 위해 2000개의 원자를 포함한 시스템을 시뮬레이션했습니다. JAX의 훌륭한 기능 중 하나는 원본 코드를 수정하지 않고 CPU에서 GPU로 코드 실행을 매끄럽게 전환할 수 있다는 점인데, 이는 상당한 시간과 노력을 절약할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_8.png)\n\n나노초당 일(ND/day)은 MD 시뮬레이션의 성능과 효율을 측정하는 일반적인 지표로, 시뮬레이션이 얼마나 빨리 진행되는지를 나타냅니다. 그림에서 나타나듯이 GPU 가속 컴퓨팅은 코드의 성능을 수십 배 향상시킬 수 있습니다. 대규모 시뮬레이션의 경우, 도메인 분해를 사용하여 시스템을 병렬화하는 것이 최적의 접근 방식일 것입니다. 이 방법에서 각 도메인은 제한된 GPU 메모리 요구 사항을 가지며 힘을 계산하고 원자 상태를 업데이트하는 데 사용될 수 있습니다.\n\n# 마무리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물이 여러분의 호기심을 자극해 JAX를 탐험하고 배워보며 여러분만의 프로젝트에 적용해 보시기를 바라요.\n\n아래 링크된 저장소를 통해 JAX와 함께 하는 Pantea 프로젝트에 대해 더 많이 알아보실 수 있어요. 저는 거기서 JAX의 오토딥 핵심 기능을 광범위하게 활용하고 있어요. 이 작업은 아직 진행 중이니, 피드백이나 의견은 언제든 환영해요.\n\n읽어 주셔서 감사해요. 여러분의 작업을 위해 JAX의 가능성을 완전히 끌어올리기 위해 더 깊이 파고들 것을 촉구해요!","ogImage":{"url":"/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png"},"coverImage":"/assets/img/2024-06-22-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png","tag":["Tech"],"readingTime":22},{"title":"간단한 Nodejs 서버 프로젝트 설정 및 실행 방법","description":"","date":"2024-06-22 14:05","slug":"2024-06-22-SetUpandRunaSimpleNodeServerProject","content":"\n\n컴퓨터 프로그래밍을 거의 3년째 배우고 있는데, 다른 개발자들을 도울 기술적 지식이 생겨났어요. 그래서 내가 잘 알고 있는 내용을 적어놓아 기억에 도움이 되고 다른 사람들에게도 참고할 수 있게 하려고 했어요. 그래서 뭔가를 시작하기로 했고, 간단하게 시작해보려고 하는데요, Node 애플리케이션을 사용하여 요청에 정적 파일로 응답하는 것부터 시작하려고 해요. 실제로는 경험이 많은 개발자들에게는 간단해 보일 수 있지만, 저는 이 부분을 조금 더 자세히 설명해볼 거에요. 왜냐하면 최소한의 웹 개발 지식이 있는 사람도 이 Node 앱을 시작하고 다음으로 진행할 재미있는 것들에 굳은 기초를 쌓을 수 있도록 하고 싶거든요. 물론 모든 것을 설명할 수는 없어서, 알고 싶다면 때로는 더 배울 수 있는 곳으로 보내줄게요.\n\n## Level Up 인재 집단에 합류하세요\n\n이 튜토리얼에서는 Node 서버를 설정하는 단계를 따라가겠어요. 클라이언트의 관점에서 (클라이언트란 서버와 통신하는 사람/컴퓨터입니다), 이 서버는 단 하나의 작업을 수행할 거에요: 단일 정적 HTML 페이지를 표시할 거에요. CSS도 없고, 프론트엔드 JavaScript도 없고, 데이터베이스 연결도 없고, 그리고 필요한 최소한의 NPM 패키지만 사용할 거에요 (NPM이 무엇인지는 곧 설명할게요). 사실, 이를 실제 인터넷에서 실행하지 않고 로컬에서만 실행할 거에요. 그리고 서버 in general이 어떻게 작동하는지, 클라이언트-서버 통신의 메커니즘에 대해 설명을 찾고 있다면, 좀 더 진지한 Node 작업을 하려면 그것에 대해 다루지 않을 거에요.\n\n먼저, 전체 과정을 개략적으로 살펴봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NodeJS 웹사이트로 이동해서 NodeJS를 다운로드하세요.\n- Node와 NPM이 설치되었는지 확인하고 PATH가 정의되어 있는지 확인하세요.\n- 새로운 프로젝트 폴더를 생성하세요.\n- 프로젝트 폴더에서 NPM을 실행하세요 (백그라운드에서 실행됩니다).\n- 필요한 NPM 패키지를 설치하세요.\n- 프로젝트 폴더에 HTML 파일을 생성하세요 (이것이 클라이언트가 볼 내용입니다).\n- 프로젝트 폴더에 Node/JavaScript 파일을 생성하세요 (이것이 서버 파일입니다).\n- 서버를 실행하세요.\n- (로컬) 웹사이트를 방문하세요!\n\n단계 1: NodeJS 웹사이트로 이동해서 NodeJS를 다운로드하세요.\n\n여기에 NodeJS 웹사이트가 있습니다. 이 튜토리얼을 따른다면 LTS(장기 지원) 버전을 다운로드하는 것을 추천드립니다. 이는 대부분의 사람들이 사용하고 안정적인 버전으로 다운로드하는 경우 무언가가 고장났을 때 더 나은 도움을 얻을 수 있습니다. 이 섹션 제목은 기술적으로 그리스도를 이끌었다가와 착각을 일으키는 거라고 합니다. 사실, 여러분은 NodeJS 설치 프로그램을 다운로드한 것이며, 다운로드가 완료되면 해당 프로그램을 열고 지침에 따라 Node를 설치해야 합니다.\n\n단계 2: Node와 NPM이 설치되었는지 확인하고 PATH가 정의되어 있는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS를 다운로드하고 설치했다면, 터미널에서 다음 명령어를 실행하여 Node가 제대로 설치되었는지 확인하고 싶을 것입니다:\n\n```js\nnode -v\n```\n\n이 명령어를 실행하면 다음과 같이 버전 번호가 출력됩니다:\n\n```js\nv14.15.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode를 설치하면 Node Package Manager로도 알려진 NPM이 함께 설치됩니다. 명령 줄에서는 Node보다는 NPM과 더 많이 상호 작용할 가능성이 높습니다. 이 기능에 대해 설명하겠지만, 일단은 NPM이 설치되어 있고 PATH가 올바른지 확인하세요. 이를 확인하려면 노드를 확인한 것과 동일한 작업을 수행하세요:\n\n```js\nnpm -v\n```\n\n위 명령은 다음과 비슷한 숫자를 반환할 것입니다:\n\n```js\n6.14.8\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실, 명령 줄에서 대부분의 프로그램을 확인하는 일반적인 기술입니다. 명령 줄 구문에 너무 깊이 들어가지 않고, 대부분의 프로그램은 -v 플래그를 처리할 수 있으므로 명령 줄에서 상호 작용할 때 거의 항상 다음 형식을 따라 작동하는지 확인할 수 있습니다.\n\n```js\n프로그램명 -v\n```\n\n모든 것이 잘 작동하면 다음 단계에 준비된 것입니다. 만약 다음과 같은 메시지를 받는다면:\n\n```js\n'node'는(은) 내부 또는 외부 명령, 실행할 수 있는 프로그램 또는 배치 파일이 아닙니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 해야 할 일은 9/10 번 이 문제가 발생하는 이유입니다. 가능한한 이 게시물을 짧게 유지하기 위해 문제 해결 방법에 대해 자세히 설명하지는 않겠습니다. 그러나 많은 사람들이 온라인에서 물어본 일반적인 문제입니다. Node와 NPM이 작동하는지 확인한 후 다음 단계로 넘어갈 수 있습니다.\n\n단계 3: 새 프로젝트 폴더 만들기\n\n프로젝트 폴더를 컴퓨터의 원하는 위치에 만들고 원하는 이름을 지을 수 있습니다. 이 단계는 간단합니다. 누구나 새 디렉토리나 폴더를 만드는 방법을 알고 있죠?\n\n단계 4: 프로젝트 폴더에서 NPM 실행 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알겠어요, 그럼 NPM은 무엇인가요? 직접 웹사이트를 방문해서 확인해보세요. 하지만 Node를 배우고 있는 초심자를 위해 간단하게 설명하면, 패키지는 단지 Node 앱과 함께 작동하도록 설계된 프로그램입니다. 웹 앱이 무언가를 수행하거나 몇 가지 로직을 수행하거나 데이터를 조작하거나 다른 서비스와 통신해야 할 때, Node 파일에 직접 모든 코드를 작성하는 대신 패키지를 찾아서 다운로드하고 프로젝트에 추가할 수 있습니다. NPM 패키지를 사용하는 것이 항상 쉽다는 것은 아니라는 것을 의미합니다. 보통 여전히 패키지와 Node 프로젝트 간의 인터페이스를 생성하기 위해 일부 코드를 작성해야 하고 때로 그 코드가 다소 까다로울 수도 있습니다.\n\n프로젝트 폴더에서 NPM을 시작하는 방법은 다음과 같습니다:\n\n- 터미널을 열기\n- 프로젝트 폴더까지 디렉토리를 변경\n- 터미널에서 npm init 명령어를 실행\n\n이 시점에서 다음 정보를 입력하라는 프롬프트가 표시될 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n이 유틸리티는 package.json 파일을 생성하는 과정을 안내해줍니다.\n가장 일반적인 사항만 다루며 합리적인 기본값을 추측합니다.\n이 필드에 대한 확정적인 설명과 각각의 기능에 대한 정확한 문서는 `npm help init`을 확인하세요.\n나중에 `npm install \u003c패키지\u003e`를 사용하여 패키지를 설치하고\n이를 package.json 파일의 종속성으로 저장해주세요.\n```\n\n이후 다음과 같이 표시되어야 합니다:\n\n```js\nPress ^C at any time to quit.\npackage name: (simple-node-server)\n```\n\n패키지 이름: (simple-node-server)\"와 이 설정 과정 중에 나오는 모든 후속 라인은 무엇을 요청하는지를 먼저 말하고 (이 경우 패키지 이름), 오른쪽에는 괄호 안에 값이 있을 수도 있고 비어 있을 수도 있습니다. 괄호 안의 값은 기본값이며, 이러한 각 라인에 대해 기본값을 그대로 사용하거나(비어있는 기본값도 허용됨), 또는 자신의 값을 입력한 후 enter를 누를 수 있습니다. 초보자 대부분은 기본값을 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 설정에 대해 더 알아야 할 사항 하나 더 있어요. 진입점 변수는 대형 프로젝트에서는 보통 여러 서버 파일이 있기 때문에 Node가 앱을 시작할 때 진입점 파일을 사용하지만, 이처럼 간단한 경우에는 하나만 필요해요. Node와 작업을 시작할 때 헷갈렸던 점 중 하나는 주 서버 파일의 다른 이름들이었어요. 가장 흔히 본 것은:\n\n- index.js\n- app.js\n- server.js\n\n주 서버 파일의 이름은 임의로 정할 수 있고, 일부 Node를 사용하는 서비스는 서버 파일이 특정한 이름이어야 하거나 특정 위치에 있어야 하는 경우가 있는데, 이는 이 간단한 서버에 대해 굉장히 중요하지는 않지만 예제를 살펴볼 때 염두에 두어야 할 부분이에요.\n\n작업을 마치면 터미널이 이와 같이 보일 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png)\n\n프로젝트 폴더에 다음과 같이 보이는 package.json이라는 파일이 있어야 합니다:\n\n단계 5: NPM 패키지 설치하기:\n\n이제 NPM이 프로젝트와 연결되었으므로 명령줄을 사용하여 하나의 NPM 패키지를 설치할 것입니다. 이 특정 패키지는 대부분의 Node 서버 프로젝트에서 사용됩니다. Express.js라고 불리며 Node 자체와 밀접한 관계가 있습니다. 실제로 Express에서 제공하는 객체와 메소드를 사용하여 라우팅, 데이터베이스 통합, 오류 처리, 그리고 프론트엔드 템플릿 사용과 같은 일반적인 웹 개발 프로세스를 쉽게 처리할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 루트 프로젝트 폴더에 있는 package.json 파일은 앱에 대한 몇 가지 기본 정보를 담고 있지만, package.json 파일의 가장 일반적인 용도는 다운로드하고 프로젝트에 저장하는 모든 패키지의 레코드를 저장하는 것입니다. 이것은 우리의 프로젝트 코드가 다른 환경에서 실행되기 위해서 (예를 들어 팀과 함께 작업하거나, 오픈 소스 프로젝트를 다른 사람이 자신의 컴퓨터에서 작업할 수 있게 하거나, Amazon Web Services (AWS), Google App Engine (GAE), Heroku 또는 이와 유사한 서비스에 배포하고 싶은 경우) 필요합니다. 다른 환경은 프로젝트에서 사용하는 NPM 패키지를 알아야 하기 때문에 다운로드하고 저장할 수 있어야 합니다. 실제로 package.json이 수행하는 작업은 많지만, 당분간 꼭 알아야 할 것은 프로젝트의 기본 정보와 패키지를 포함한다는 것입니다.\n\n간단히 말해, 패키지를 앱에 연결하는 두 가지 단계가 있습니다:\n\n- NPM에서 패키지 다운로드/설치\n- package.json의 \"Dependencies\"에 패키지 이름과 버전 번호 저장\n\nNPM 패키지를 다운로드하고 프로젝트에 설치하려면, 이 경우 express를 사용할 때, 터미널에서 다음 명령을 실행해야 합니다 (이 명령을 실행할 때 프로젝트의 루트 폴더에 있는지 확인하십시오):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i -s express\n```\n\n- npm은 실행 중인 프로그램 이름입니다.\n- -i는 --install에 대한 약칭이며 둘 중 아무것이나 사용할 수 있습니다. 이 명령을 사용하면 express를 프로젝트 루트 폴더의 node_modules라는 폴더에 추가합니다. NPM으로 처음 패키지를 설치할 때까지 이 폴더가 프로젝트 폴더에 추가되지 않는다는 점을 유의해야 합니다. (그래서 아직 프로젝트 폴더에 보이지 않습니다).\n- -s는 --save에 대한 약칭이며 둘 중 아무것이나 사용할 수 있습니다. npm install 명령에 추가할 수 있는 태그로, 자동으로 package.json에 저장합니다. -s 또는 --save를 잊어버리면 package.json에 패키지 이름과 버전 번호를 수동으로 추가할 수 있습니다. 어떻게든 추가하되, 패키지 이름과 버전 번호가 package.json에 있는지 확인하세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*L-A4jgG4P2bgdYca0guC3w.gif)\n\nStep 6: HTML 파일 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더를 생성한 후에 완료해야 할 두 번째로 간단한 단계가 아닐까 싶어요. 폴더에 확장자 '.html'을 가진 파일을 추가하세요. 일반적으로 기본 html 파일의 이름은 'index.html'로 지정하지만, 이건 절대적인 규칙이 아니기 때문에 자유롭게 이름을 정하셔도 됩니다.\n\n이게 모두요! 이것만 있으면 HTML 파일에 완성된 거죠, 여기서부터 본인이 원하는 형식의 HTML 페이지로 만들어가시면 됩니다:\n\n7단계: 프로젝트 폴더에 Node/JavaScript 파일 만들기\n\n프로젝트의 루트 폴더에 'index.js'라는 파일을 만들어주세요. 그렇습니다, 이제 루트 폴더 안에 'index.html' 파일과 'index.js' 파일이 모두 있게 될 거에요. 헷갈린다면, 조금 익숙해지기까지 조금 걸릴 수 있지만, 실제로는 노드가 서버를 시작하거나 페이지를 렌더링하는 과정에서 문제가 발생했을 때 디버깅에 유용할 수 있어요. 이 규칙은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 프론트엔드 프레임워크들, Handlebars와 같은 템플릿 엔진부터 React와 같은 JavaScript 프레임워크까지, 이를 활용하여 특정 폴더를 살펴 index.js 파일을 해당 디렉토리의 진입점으로 사용합니다.\n\n어쨌든, 서버가 실제로 어떻게 작동하는지 전혀 모른다면, 서버가 하는 가장 기본적인 작업을 간단히 설명해 드리겠습니다:\n\n- 클라이언트로부터 수신되는 요청을 처리하기 위해 포트를 개방합니다.\n- 들어오는 각 요청에 대해 무엇을 해야 하는지 정의합니다 (서버의 응답).\n\n이것이 적절히 요청-응답 주기라고 불리는 것의 가장 간단한 설명이며, 대부분 인터넷이 작동하는 방식입니다. 따라서 우리는 서버를 이렇게 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드/익스프레스 앱에서는 다음과 같이 작업을 수행합니다:\n\n- 방금 설치한 Express 종속성을 가져옵니다.\n- Express 앱 객체의 인스턴스를 생성합니다. 이 앱 객체에는 서버에 사용할 수있는 다양한 내장 메서드와 변수가 있습니다. 그 중 일부를 곧 보게 될 것입니다.\n- 포트 번호를 변수에 저장합니다. 이 앱에서는 선택 사항이지만, 다른 사람들과 함께 앱을 개발하고 앱을 클라우드 기반 서비스에 배포할 때, 앱이 작동하는 환경을 결정하고 적절한 포트를 사용할 수 있도록 몇 가지 로직을 추가하고 싶어할 것입니다.\n- 루트를 설정합니다. 이 경우 하나의 루트를 설정하고 해당 루트의 역할은 앱의 루트(‘/’)에서 요청을 받아들여 클라이언트 브라우저로 HTML 파일을 보내는 것입니다. 다시 말하지만, 규모가 큰 Node 앱을 작업하면 여러 루트가 있고 종종 완전히 분리된 라우터 파일이 있으며, 각각에는 여러 루트가 연결되어 있습니다.\n- 마지막으로 서버를 위한 수신 포트를 설정해야 합니다. 이는 들어오는 연결을 대기하는 역할을 하며, Express 앱에서는 항상 파일의 끝에 있습니다.\n\n그럼, 작업 방법은 다음과 같습니다:\n\n- Node 파일에 종속성을 가져오려면 다음 형식을 따라야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst \u003cvariable-name\u003e = require('\u003cname-of-package\u003e');\n```\n\n여기 몇 가지 빠른 팁이에요:\n\n- `variable-name`은 임의의 이름이에요. 원하는 대로 사용할 수 있어요. 하지만, 이 변수들을 그들의 의존성에 따라 명명하는 것이 최선의 실천 방법이에요.\n- require()는 다른 Node 파일의 코드에 액세스할 수 있게 해주는 내장 Node 함수에요. 이 함수는 Node 서버에 가져오는 모든 의존성에 사용되며, 동일한 방식으로 자신의 Node 파일을 작성하고 주 서버 파일로 가져올 수 있어요.\n- `name-of-package`은 가져오려는 폴더나 파일의 정확한 이름이에요 (JavaScript 파일만 가져올 경우 파일 확장자를 뺄 수 있어요). 가져오는 것이 NPM 패키지인 경우, package.json을 참조할 수 있어요. 왜냐하면 package.json에 나열된 것이 Node 서버 파일에서 필요한 문자열과 동일해야 하거든요. 저희의 package.json에는 의존성이 이렇게 나와 있어요:\n\n```js\n\"dependencies\": {\n   \"express\": \"^4.17.1\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요렇게 table 태그를 Markdown 형식으로 변경해보세요.\n\n1. So, the package.json 파일에는 ‘express’가 있고 require() 함수는 'express' 문자열을 인수로 사용합니다.\n\n2. 다음으로 Express에서 앱 객체 인스턴스를 생성해야 합니다. 앱 객체는 Node.js로 애플리케이션을 만들고 싶다면 꼭 이해해야 할 내용입니다. 우리는 다음과 같이 인스턴스화합니다:\n\n```js\nconst app = express();\n```\n\n- 이 코드의 역할은 바로 위 줄에서 가져온 의존성을 실행하는 것뿐입니다. 그 의존성은 앱 객체를 내보내며 그 앱 객체가 app이라는 상수 변수에 저장됩니다. 이 앱 객체가 Express 코드를 보유하며, 여기서 가장 많은 상호작용을 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이건 쉬워요. 일단 변수 port에 포트 번호를 저장해 보세요. 3000에서 8000 사이의 숫자라면 어떤 숫자든 괜찮아요. 대부분의 사람들은 3000이나 8000을 주로 사용해요.\n\n```js\nconst port = 5000;\n```\n\n4. app 오브젝트에는 HTTP 메소드를 기반으로 요청을 라우팅하는 여러 함수가 포함되어 있어요. 이 함수들 중 가장 일반적인 것들은:\n\n- app.get()\n- app.post()\n- app.put()\n- app.delete()\n- app.use()\n- app.all()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 흔한 함수 중 하나는 app.get()입니다. 이 함수는 GET 요청에 사용되며, 웹사이트에 방문할 때마다 실행됩니다. GET 요청은 인터넷에서 가장 흔한 종류이므로 app.get()를 살펴보겠습니다. Express 문서에서는 다음과 같이 정의하고 있습니다:\n\n그리고 이에 대한 예시를 보여줍니다:\n\n```js\napp.get('/', function (req, res) {\n  res.send('GET request to homepage')\n})\n```\n\n이 정의를 보면 app.get() 함수가 path와 콜백 함수 두 가지 인수를 받을 것으로 예상됩니다. 예시에서는 두 개의 인수가 있는 것을 볼 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `/` = 경로\n- function (req, res) ' res.send(`홈페이지로의 GET 요청`)' = 콜백 함수\n\n이 예제에서는 하나의 콜백 함수만 있지만, 여러 개의 콜백 함수가 있을 수도 있어요. Express에서는 이러한 것들을 미들웨어라고 부르는데, 그 이유는 서버가 클라이언트 요청을 받는 시점과 응답을 다시 보내는 사이에 삽입되기 때문이에요. 게다가, 대규모 Node 프로젝트에서는 미들웨어 함수의 수가 상당히 많아지고, 종종 라우트가 여러 개의 미들웨어 함수를 가지게 되기도 해요. 또한, Node 프로젝트에서 사용할 수 있는 많은 NPM 패키지들이 미들웨어처럼 사용되도록 작성되어 있어요. 사실, Express도 이와 같은 것들뿐이에요:\n\nExpress에서는 많은 미들웨어가 다른 곳에 정의되어 이름과 함께 라우팅 함수로 전달될 수 있지만, 일반적으로 라우팅 함수의 마지막 콜백 함수는 이 예제와 비슷하게 보일 것이며, 이에 대해 아셔야 해요:\n\n- req와 res 두 가지 인수를 가지고 있어요. 이것들은 새로운 요청-응답 주기 동안 다양한 작업을 수행하는 데 도움이 되는 내장 객체들이에요. Express는 이를 미들웨어 함수에서 기대하고 있어요. 현재는 req 객체를 사용하지는 않지만, 앱에 입력이나 URL 인코딩된 데이터 (URL에 서버로 전달되는 데이터)가 있는 경우 req 객체를 통해 해당 정보에 액세스할 수 있어요. res 객체는 서버가 응답을 보낼 때 사용할 객체에요. 중요한 점은 꼭 req와 res로 명명할 필요가 없다는 점이에요. Express는 req와 res 대신 사용하는 이름을 사용할 것이지만, 문서는 모두 req와 res를 참조하고 있고, 대부분의 Node 서버가 이 관례를 따르고 있기 때문에 그대로 따르는 것이 좋을 거예요.\n- 이 함수는 대부분 미들웨어로 간주되는 것들과 약간 다르다는 점에 유의해야 해요. 왜냐하면 대부분의 미들웨어는 Express에게 다음 미들웨어로 계속 진행하라고 말하는 next 인수를 가지고 있는데, 이 함수는 res.sendFile()를 호출하기 때문에 요청-응답 주기의 끝을 의미하고, 서버는 해당 요청을 완료한 상태에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nres.sendFile()에 대해 더 알고 싶다면 문서를 참조해보세요. 하지만 지금 당장 알아두어야 할 점은 다음과 같습니다.\n\n```js\nres.sendFile('\u003cfile-name\u003e', {root: __dirname});\n```\n\n이것이 서버 파일(index.js)이 있는 같은 폴더(루트)에서 파일을 전송하는 방법입니다.\n\n5. 마지막으로, 서버가 들어오는 요청을 수신하기로 약속하려면 코드를 설정해야 합니다. Express의 app 객체에는 이를 수행하는 app.listen()이라는 함수가 있습니다. 모든 매개변수는 옵션으로, 포트 번호를 포함한 것들입니다. 하지만 일반적으로 포트 번호가 적어도 하나 보이며 종종 콜백 함수도 함께 전달됩니다. 제가 앱에서 사용하는 app.listen()의 전체 버전은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\napp.listen(port, () =\u003e {\n    console.log(`Now listening on port ${port}`);\n}); \r\n```\n\n알았어요, 이것을 자세히 살펴보고 마무리하도록 하죠.\n\n- port는 우리 index.js 파일 맨 위에서 정의한 것과 동일한 포트입니다.\n- () =\u003e {}은 화살표 함수로, JavaScript에서 일반 함수와 정확히 동일한 작업을 수행하지만 조금 더 깔끔하게 보입니다.\n- console.log()은 아마 이전에 본 적이 있을 것이라고 기대합니다. 그렇지 않은 경우, 이 줄은 단순히 주어진 문자열을 콘솔에 출력할 것입니다.\n\n총으로, 당신의 index.js 파일은 이렇게 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 8: Node 서버 시작하기\n\n코딩 부분은 여기까지입니다. 다음 단계는 실제로 서버를 시작하는 것입니다! 터미널을 열고 다음 명령을 실행하여 이를 수행할 수 있습니다:\n\n```js\nnode index.js\n```\n\n콘솔에 원하는 포트 번호가 표시된 console.log 메시지가 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Oqa--bT2xy4bNeErxLWxpA.gif)\n\nStep 9: 방문하고자하는 (로컬) 사이트 방문하기!\n\n이제 할 일은 자신의 사이트로 이동하는 것뿐입니다. 귀하의 사이트는 로컬호스트에 호스팅되어 있으며 지정한 포트에서 실행 중입니다. 브라우저를 열고 아래 URL을 사용하세요:\n\n```js\nlocalhost:\u003c포트번호\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지에서 포함한 내용을 얻을 수 있어요! 첫 번째 노드 사이트를 호스팅했군요! \n\n이 튜토리얼은 어떠셨나요? 모든 단계를 따라가고 로컬에서 간단한 HTML 페이지를 실행할 수 있었나요? 혼란스러운 용어가 있었다면 무엇이었나요? 댓글로 알려주세요.\n\n# 코딩 레벨업\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\n- 💰 무료 코딩 면접 코스 ⇒ 코스 보기\n- 🔔 팔로우하기: 트위터 | 링크드인 | 뉴스레터\n\n🚀👉 Level Up 인재 집단에 가입하여 놀라운 직업을 찾아보세요","ogImage":{"url":"/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png"},"coverImage":"/assets/img/2024-06-22-SetUpandRunaSimpleNodeServerProject_0.png","tag":["Tech"],"readingTime":13},{"title":"Expressjs 프로젝트를 AWS EC2에 배포하는 방법","description":"","date":"2024-06-22 14:03","slug":"2024-06-22-HowtodeployExpressjsprojecttoAWSEC2","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png\" /\u003e\n\n# 목차\n\n- AWS EC2 인스턴스 생성 (Linux)\n- SSH 액세스용 키페어 생성\n- 서버 환경 설정\n- 서버 어플리케이션 실행\n\n# 1. AWS EC2 인스턴스 생성 (Linux)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS 콘솔에 로그인하면 상단 바에 검색 상자가 나타납니다. \"ec2\"를 입력하고 EC2 대시보드를 엽니다.\n\n\n![이미지 설명](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_1.png)\n\n\nEC2 대시보드에서 '인스턴스 시작' 패널을 찾아 새 인스턴스를 생성하려면 '인스턴스 시작'을 클릭하세요. 이렇게 하면 아래와 같은 새 페이지가 열릴 것입니다.\n\n\n![이미지 설명](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인스턴스 이름을 입력하고 인스턴스 OS로 \"Amazon Linux\"을 선택하세요.\n\n\"Key pair(login)\" 패널에서 인스턴스용 키페어를 만드세요. 이미 키페어가 있는 경우, 기존 것을 선택하시면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_3.png\" /\u003e\n\n그리고 .pem 파일을 저장하여 EC2 인스턴스에 액세스하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. SSH 액세스를 위한 키페어 생성\n\n이미 Node 프로젝트용 EC2 인스턴스가 있으면이 단계를 건너 뛰세요.\n\nEC2 인스턴스가 있지만 SSH 액세스를 위한 키페어가 없는 경우 \"EC2 Key pair\" 페이지를 만들 수 있습니다.\n\n![EC2 Key pair](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_5.png)\n\n\"Create key pair\"를 클릭하여 .pem 파일을 다운로드할 수 있으며, 이것은 \"Key pairs\" 페이지 표에 나열됩니다.\n\n예를 들어, pem 파일 이름이 ec2-key.pem이고 인스턴스 이름이 ec2-012-345-678.computer-1.amazonaws.com이라고 가정해 봅시다.\n\n이제 터미널에서 EC2 인스턴스에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널을 열고 ec2-key.pem 파일이 있는 디렉토리로 이동해주세요.\n\n```js\n$ ssh -i ec2-key.pem ec2-user@ec2-012-345-678.computer-1.amazonaws.com\n\n\"Amazon Linux\"의 새로운 릴리스가 있습니다.\n  Version 2023.3.20240219:\n  Version 2023.3.20240304:\n  Version 2023.3.20240312:\n  Version 2023.4.20240319:\n  Version 2023.4.20240401:\n  Version 2023.4.20240416:\n  Version 2023.4.20240429:\n  Version 2023.4.20240513:\n  Version 2023.4.20240528:\n  Version 2023.4.20240611:\n전체 릴리스 및 버전 업데이트 정보 확인을 위해 \"/usr/bin/dnf check-release-update\"를 실행하세요.\n   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-\u003e\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\n마지막 로그인: 2024년 6월 20일 목요일 20:21:34, 91.74.112.249부터 로그인했습니다.\n-bash: export: `.bashrc': not a valid identifier\n[ec2-user@EC2_HOSTNAME ~]$\n```\n\n콘솔에 위와 같은 메시지가 나타날 것입니다.\n\n# 3. 서버 환경 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js 서버를 실행하려면 EC2에 Node를 설치해야 합니다.\n\nnvm을 사용하여 Node.js를 설치하세요.\n\nnvm 설치 방법:\n\n```js\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode(20)을 설치하세요:\n\n```js\nnvm install 20\n```\n\n올바르게 설치되었는지 확인하세요:\n\n```js\nnode --version\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 GitHub에 Express 프로젝트가 있다면, git clone 명령어를 사용하여 프로젝트를 EC2로 가져올 수 있습니다.\n\n파일과 디렉토리를 살펴보려면 ls를 사용하세요. 숨겨진 파일과 디렉토리를 모두 볼 때는 ls -a를 사용하세요. 그리고 마침표(.)로 시작하는 모든 파일과 디렉토리를 볼 수 있습니다.\n\n만약 GitHub 프로젝트가 없다면 지금은 괜찮습니다.\n\nnode-app이라는 폴더를 만들기 위해 mkdir node-app를 사용하세요. Node.js 프로젝트를 만들기 위해 npm init -y를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\ncd mkdir\nnpm init -y\n```\n\n그런 다음 이 간단한 Express.js 애플리케이션 코드를 붙혀넣어주세요.\n\n```js\nnpm install express\n\nnano app.js\n```\n\n이 코드를 app.js에 복사해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express');\n\n// express의 인스턴스 생성\nconst app = express();\n\n// 루트 URL (\"/\")에 대한 라우트 정의\napp.get('/', (req, res) =\u003e {\n    res.send('Hello World!');\n});\n\n// 포트 3000에서 서버 시작\nconst port = 3000;\napp.listen(port, () =\u003e {\n    console.log(`서버가 http://localhost:${port}에서 실행 중입니다.`);\n});\n```\n\n이제 간단한 hello-world Node 서버 애플리케이션이 준비되었습니다.\n\n`node app` 명령을 실행하면 콘솔에 '서버가 http://localhost:3000에서 실행 중입니다.' 메시지가 표시됩니다.\n\n브라우저를 열고 다음 URL을 입력하여 확인해보세요: `http://ec2-012-345-678.computer-1.amazonaws.com:3000`. 브라우저에 'Hello World!'가 표시될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 거의 완료하셨네요!\n\n보이지 않으신가요? 제게 알려주세요.\n\n# 4. 서버 애플리케이션 실행\n\n터미널을 닫으면 서버 애플리케이션이 종료됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 애플리케이션을 실행하려면 pm2 모듈을 사용할 수 있어요.\n\npm2 모듈을 전역으로 설치하고 프로젝트 폴더에서 pm2 start app을 실행하세요.\n\npm2에 대한 자세한 정보는 pm2 공식 웹사이트에서 확인할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png"},"coverImage":"/assets/img/2024-06-22-HowtodeployExpressjsprojecttoAWSEC2_0.png","tag":["Tech"],"readingTime":5},{"title":"NPM, YARN, PNPM 패키지 매니저 비교 고부하 분산 프로젝트에 알맞은 선택은","description":"","date":"2024-06-22 14:01","slug":"2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads","content":"\n\n\n![Image](/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png)\n\n만약 Frontend 또는 Full Stack 개발자라면, 아마도 NPM, YARN, PNPM 중 하나 이상을 사용해 보았을 것입니다. 이들은 프로젝트의 의존성을 관리하는데 도움이 되는 도구인데요, 라이브러리, 프레임워크, 유틸리티와 같은 것들을 관리할 수 있습니다.\n\n각 패키지 매니저에 대해 간단히 소개해 보겠습니다.\n\n# NPM\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNPM은 Node Package Manager의 약자입니다. JavaScript를 위한 기본이자 가장 인기 있는 패키지 매니저입니다. 2009년 Isaac Schlueter에 의해 만들어졌으며 Node.js 프로젝트에서 코드를 공유하고 재사용하는 방법으로 시작되었습니다. 그 이후로, 약 200만 개가 넘는 패키지로 구성된 거대한 저장소로 성장했습니다. 이 패키지는 프론트엔드와 백엔드 개발에 사용할 수 있습니다.\n\nNPM은 간단하고 직관적인 명령줄 인터페이스를 제공하여 패키지를 설치, 업데이트, 제거 및 게시할 수 있습니다. 또한 npmjs.com이라는 웹사이트도 있어 패키지를 탐색, 검색 및 다운로드할 수 있습니다. NPM은 프로젝트의 메타데이터(이름, 버전, 의존성, 스크립트 등)을 저장하는 package.json이라는 파일을 사용합니다. 또한 설치된 패키지를 저장하는 node_modules라는 폴더를 생성합니다.\n\n## 장점\n\n- JavaScript 커뮤니티에서 널리 사용되며 지원되고 있습니다.\n- 거의 모든 사용 사례에 대한 다양하고 방대한 패키지 컬렉션이 있습니다.\n- 프로젝트를 사용자 정의하는 데 유용한 다양한 기능과 옵션이 있습니다.\n- 종속성에서 취약점을 확인하는 내장된 보안 감사 도구가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단점\n\n- 패키지를 설치하거나 업데이트할 때 느리고 비효율적일 수 있습니다.\n- 중복된 또는 중첩된 종속성을 만들어 디스크 공간을 차지하고 충돌을 일으킬 수 있습니다.\n- 다른 환경 간에 패키지 버전이 일관되지 않거나 오래된 경우가 있을 수 있습니다.\n\n# YARN\n\nYARN은 Yet Another Resource Negotiator의 약자입니다. 이는 2016년 페이스북, 구글, 익스포넌트, Tilde에 의해 만들어진 JavaScript의 대체 패키지 매니저입니다. 이는 NPM의 속도, 신뢰성 및 보안과 같은 몇 가지 문제와 한계를 해결하기 위해 설계되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYARN은 NPM과 유사한 명령줄 인터페이스를 가지고 있지만 일부 차이점과 개선 사항이 있습니다. 그리고 NPM과 동일한 package.json 파일을 사용하지만 종속성의 정확한 버전을 잠그는 yarn.lock이라는 추가 파일이 있습니다. 또한 설치된 패키지를 저장하는 node_modules 폴더를 생성합니다.\n\n## 장점\n\n- 패키지를 설치하거나 업데이트할 때 NPM보다 빠르고 효율적입니다\n- 중복이나 패키지의 중첩을 피하는 평면적인 종속성 구조를 사용합니다\n- 로컬 캐시에서 패키지를 오프라인으로 설치할 수 있습니다\n- 일관된 및 결정적인 버전의 패키지를 다른 환경에서 보장하는 더 나은 해결 알고리즘을 제공합니다\n\n## 단점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JavaScript 커뮤니티에서 NPM만큼 널리 사용되거나 지원되는 것은 아닙니다.\n- 일부 NPM 패키지나 기능과 호환되지 않을 수 있습니다.\n- 아직 수정되지 않거나 해결되지 않은 버그나 문제가 있을 수 있습니다.\n\n# PNPM\n\nPNPM은 Performant Node Package Manager의 약자입니다. 2016년 Zoltan Kochan에 의해 만들어진 JavaScript용 대체 패키지 관리자입니다. NPM과 YARN보다 빠르고 가벼우며 더 안전하도록 설계되었습니다.\n\nPNPM은 NPM과 YARN과 유사한 명령줄 인터페이스를 가지고 있지만 일부 차이점과 개선점이 있습니다. 또한 NPM과 YARN과 동일한 package.json 파일을 사용하지만 의존성의 정확한 버전을 잠그는 pnpm-lock.yaml이라는 파일을 추가합니다. 또한 설치된 패키지를 저장하는 node_modules 폴더를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- 패키지 설치 또는 업데이트 시 NPM 및 YARN보다 빠르고 가벼움\n- 글로벌 저장소에서 하드 링크 또는 심볼릭 링크를 사용하여 패키지를 node_modules 폴더에 복사하는 대신 연결함\n- 패키지가 package.json 파일에 선언되지 않은 모듈에 액세스하는 것을 방지하는 엄격한 의존성 격리를 지원\n- 종속성 내의 취약점을 확인하는 내장된 보안 감사 도구를 제공\n\n## 단점\n\n- 자바스크립트 커뮤니티에서 NPM 또는 YARN만큼 널리 사용되거나 지원되지 않음\n- 일부 NPM 또는 YARN 패키지 또는 기능과 호환되지 않을 수 있음\n- 아직 수정되지 않거나 해결되지 않은 버그나 문제가 있을 수 있음\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비교\n\n## 요약\n\n## 성능\n\n패키지 관리자의 가장 중요한 측면 중 하나는 프로젝트의 종속성을 빠르게 설치하고 업데이트하는 데 얼마나 빠른지입니다. 이는 개발 워크플로우 및 배포 프로세스에 영향을 줄 수 있습니다. NPM, YARN 및 PNPM의 성능을 측정하기 위해 약 1000개의 종속성이 포함된 샘플 프로젝트를 사용하여 벤치마크를 실행했습니다. 여기에 결과가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPNPM이 가장 빠른 패키지 매니저인 것을 보실 수 있습니다. 그 다음으로 YARN, 그리고 NPM이 따릅니다. PNPM은 \"symlinked node_modules\"라는 혁신적인 접근 방식을 사용하여 각 프로젝트로 패키지를 복사하는 대신 전역 저장소에 대한 하드 링크를 생성합니다. 이렇게 하면 디스크 공간을 절약하고 중복을 줄일 수 있습니다. YARN도 전역 캐시를 사용하지만 여전히 각 프로젝트로 패키지를 복사합니다. NPM은 캐싱 메커니즘을 사용하지 않기 때문에 매 번 패키지를 다운로드하고 설치합니다.\n\n## 특징\n\n패키지 매니저의 또 다른 측면은 개발자로서 더 쉽게 일할 수 있도록 어떤 기능을 제공하느냐입니다. 제가 중요하게 생각하는 기능 중 일부는 다음과 같습니다:\n\n- Workspaces: 이 기능을 통해 단일 저장소 내에서 여러 하위 프로젝트를 관리하고 서로 의존성을 공유할 수 있습니다. 서로 의존하는 여러 패키지가 있는 monorepo 아키텍처에 유용합니다.\n- Lockfiles: 이 기능은 레지스트리나 package.json 파일의 변경과 무관하게 매번 정확한 버전의 종속성이 설치되도록 보장합니다. 빌드의 재현성과 신뢰성을 향상시킵니다.\n- Scripts: 이 기능을 사용하면 종속성을 설치하거나 업데이트하기 전이나 후에 컴파일, 테스트 또는 코드 린팅과 같은 사용자 지정 명령을 실행할 수 있습니다.\n- Hooks: 이 기능을 통해 패키지 매니저의 라이프사이클의 특정 이벤트 중에 사용자 지정 로직을 실행할 수 있습니다. 종속성을 해결하거나 가져오거나 링크 또는 감사하는 경우가 여기에 해당합니다.\n- Audit: 이 기능을 사용하면 종속성을 알려진 취약점이나 문제점을 확인하고 해결 방법에 대한 권장 사항을 받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자 모두 워크스페이스, 락파일, 스크립트 및 감사 기능을 지원합니다. 그러나 YARN과 PNPM만 후크를 지원하는데, 이를 통해 의존성 관리 프로세스를 유연하고 효율적으로 제어할 수 있습니다. 반면에 NPM과 YARN만 감사 기능을 지원하는데, 이를 통해 코드의 보안성과 품질을 향상시킬 수 있습니다.\n\n## 호환성\n\n패키지 관리자의 또 다른 측면은 프로젝트에서 사용할 수 있는 다른 도구 및 플랫폼과 얼마나 호환성이 있는지입니다. 호환성에 영향을 미치는 몇 가지 요소는 다음과 같습니다:\n\n- 레지스트리: 이는 패키지 관리자가 의존성을 설치하고 업데이트하는 데 사용하는 패키지의 원본입니다. 가장 일반적인 레지스트리는 npmjs.com인데, 이는 JavaScript 및 Node.js용으로 2백만 개 이상의 패키지를 호스팅합니다. 그러나 다른 목적으로 사용할 수 있는 개인 또는 범위가 지정된 패키지와 같은 다른 레지스트리도 있을 수 있습니다.\n- CLI: 이는 패키지 관리자가 상호 작용할 수 있도록 제공하는 명령줄 인터페이스입니다. 가장 일반적인 CLI는 Node.js와 함께 제공되는 npm-cli인데, 그러나 별도로 설치할 수 있도록 제공되는 standalone 도구인 yarn-cli나 일부 추가 기능을 추가하는 npm-cli 래퍼인 pnpm-cli와 같은 다른 CLI도 있을 수 있습니다.\n- 생태계: 이는 패키지 관리자가 통합하거나 지원하는 도구 및 플랫폼 세트입니다. 웹팩, 바벨, eslint, 모카, 익스프레스 또는 AWS와 같은 도구들을 포함하는 Node.js 생태계가 가장 보편적인데, 그러나 browserify, rollup, typescript, prettier, jest, react, 또는 firebase와 같은 도구를 포함하는 브라우저 생태계와 같이 다른 목적으로 사용할 수 있는 다른 생태계도 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자는 동일한 레지스트리와 생태계와 호환됩니다. 그러나 각각이 제공하는 다른 CLI를 통해 서로 다른 명령어와 옵션을 제공합니다. 예를 들어, YARN에는 작업 공간을 더 쉽게 관리할 수 있도록 해주는 \"yarn workspaces\"라는 명령어가 있습니다. PNPM에는 여러 하위 프로젝트에서 명령어를 한 번에 실행할 수 있도록 하는 \"pnpm recursive\"라는 명령어가 있습니다.\n\n## 보안\n\n비교할 패키지 관리자의 한 가지 더 중요한 측면은 얼마나 안전한지입니다. 보안은 종속성이 악의적인 코드나 취약점을 포함할 수 있어 프로젝트나 사용자를 위협할 수 있기 때문에 중요합니다. 패키지 관리자가 보안을 향상시키기 위해 취할 수 있는 조치 중 일부는 다음과 같습니다:\n\n- 확인: 이는 설치하거나 업데이트할 패키지의 무결성과 신뢰성을 확인하는 과정입니다. 이를 통해 변조나 위조 공격을 예방할 수 있으며, 패키지를 악의적인 것으로 대체하거나 변경하는 것을 방지할 수 있습니다.\n- 격리: 이는 설치하거나 업데이트하는 패키지의 액세스 및 권한을 제한하는 과정입니다. 이를 통해 특권 상승이나 코드 삽입 공격을 방지하여 시스템이나 사용자의 시스템에서 악의적인 코드가 실행되는 것을 방지할 수 있습니다.\n- 해결: 이는 설치하거나 업데이트하는 패키지의 최상의 버전을 선택하는 과정입니다. 이를 통해 종속성 지옥이나 충돌 문제를 방지하여 프로젝트가 손상되거나 예기치 않게 동작하는 것을 방지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 패키지 관리자는 모두 패키지의 무결성과 신뢰성을 보장하기 위한 형태의 확인을 사용합니다. 그러나 PNPM은 YARN(SHA-1)보다 더 강력한 알고리즘(SHA-512)을 사용하여 충돌 및 무차별 공격에 더 저항력을 가집니다. NPM과 YARN은 PNPM과 동일한 알고리즘(SHA-512)을 사용합니다.\n\n그러나 PNPM만이 패키지의 액세스 및 권한을 제한하기 위해 격리를 사용합니다. 이를 위해 각 패키지마다 별도의 node_modules 폴더를 생성하고 심볼릭 링크를 사용하여 이들을 함께 연결합니다. 이렇게 함으로써 패키지가 명시적인 허가 없이 다른 패키지의 파일 또는 모듈에 액세스하거나 수정하는 것을 방지합니다. NPM과 YARN은 격리 메커니즘을 사용하지 않기 때문에 패키지가 node_modules 폴더 내의 모든 파일 또는 모듈에 액세스하거나 수정할 수 있습니다.\n\n더불어, PNPM만이 엄격한 해상도를 사용하여 최상의 버전을 선택합니다. 이를 위해 package.json 파일에서 지정된 정확한 버전을 따르고 평평한 종속성 트리를 생성합니다. 이렇게 함으로써 중복되거나 호환되지 않는 버전의 패키지가 설치되거나 업데이트되는 것을 방지합니다. NPM과 YARN은 범위 또는 수정자에 따라 버전을 선택하는 semver 해상도를 사용하며 이로 인해 중복되거나 호환되지 않는 버전의 패키지가 설치되거나 업데이트 될 수 있습니다.\n\n# 최적의 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트 요구 사항, 기호 및 제약 사항에 가장 적합한 패키지 관리자를 선택해보세요. 일반 해결책은 없으며, 각 패키지 관리자는 각자의 장단점을 가지고 있습니다. 필요하다면 다른 패키지 관리자로 전환할 수도 있습니다. 그러나 다른 패키지 관리자로 설치하기 전에 기존 node_modules 폴더와 lockfile을 삭제해야 합니다.\n- 서로 다른 기기 및 환경에서 재현 가능한 설치를 보장하기 위해 로크 파일을 사용하세요. 로크 파일은 프로젝트가 의존하는 패키지의 정확한 버전과 출처를 기록한 파일로, 매번 일관되게 설치할 수 있도록 도와줍니다. NPM은 package-lock.json 파일을 사용하고, Yarn은 yarn.lock 파일을 사용하며, PNPM은 pnpm-lock.yaml 파일을 사용합니다. 이 파일들을 버전 관리 시스템에 커밋하고 패키지를 추가, 제거 또는 업데이트할 때마다 업데이트해야 합니다.\n- 패키지 관리자의 동작과 설정을 구성하기 위해 .npmrc 파일을 사용하세요. .npmrc 파일은 패키지 관리자의 구성 옵션인 레지스트리 URL, 프록시 설정, 캐시 위치 등의 키-값 쌍을 포함하는 파일입니다. 이 파일을 프로젝트의 루트 디렉토리나 홈 디렉토리에 생성하여 구성을 전역적으로 또는 로컬적으로 적용할 수 있습니다. 또한 환경 변수나 명령줄 플래그를 사용하여 구성 옵션을 재정의할 수도 있습니다.\n- 패키지 관리자와 자주 사용하는 작업 및 워크플로우를 자동화하기 위해 스크립트를 사용하세요. 스크립트는 \"scripts\" 속성 아래에 정의된 커맨드로, \"start\", \"test\", \"build\" 등과 같은 명령이 포함됩니다. 그런 다음 패키지 관리자의 CLI를 통해 이러한 스크립트를 실행할 수 있습니다. 예를 들어 npm run start, yarn start 또는 pnpm start와 같이 실행할 수 있습니다. 또한 pre- 및 post- 훅을 사용하여 다른 스크립트 전 또는 후에 스크립트를 실행할 수도 있습니다. 예를 들어 pretest 또는 postbuild와 같이 실행할 수 있습니다.\n- 하나의 저장소 내에서 여러 프로젝트 또는 패키지를 관리하기 위해 워크스페이스를 사용하세요. 워크스페이스는 자체의 package.json 파일과 종속성을 포함하는 폴더로, 공통 node_modules 폴더와 root 수준의 lockfile을 공유합니다. 이렇게 하면 중복을 피하고 프로젝트 또는 패키지 간의 종속성 관리를 간소화할 수 있습니다. NPM은 버전 7부터 워크스페이스를 지원하고, Yarn은 버전 1부터 워크스페이스를 지원하며, PNPM은 버전 2부터 워크스페이스를 지원합니다.\n\n# 결론\n\n각 패키지 관리자에는 각자의 장단점이 있습니다.\n\nNPM은 널리 사용되며 쉽지만 Yarn과 PNPM보다 느립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n야드는 NPM보다 더 빠르고 멋진 새로운 기능을 갖추고 있지만, NPM과 동일한 평평해진 node_modules 디렉토리를 사용합니다.\n\nPNPM은 가장 빠르고 가장 디스크 공간을 효율적으로 사용하는 패키지 매니저지만, 일부 패키지와의 호환성 문제가 있을 수 있습니다.\n\n프로젝트 요구사항에 가장 잘 맞는 패키지 매니저를 선택해보세요.","ogImage":{"url":"/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png"},"coverImage":"/assets/img/2024-06-22-ComparingNPMYARNandPNPMPackageManagersWhichOneisRightforYourDistributedProjecttohandleHighLoads_0.png","tag":["Tech"],"readingTime":8},{"title":"확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법","description":"","date":"2024-06-22 14:00","slug":"2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects","content":"\n\n요즘에는 마이크로서비스 아키텍처가 확장 가능하고 유지보수가 용이하며 유연한 애플리케이션을 개발할 수 있는 능력 때문에 상당한 인기를 얻고 있습니다. Nest.js는 점진적인 Node.js 프레임워크로, 마이크로서비스를 구축하기에 적합합니다. 본 문서에서는 Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계하고 구현하는 방법을 살펴볼 것입니다. 마이크로서비스를 구축하는 데 필요한 주요 개념, 장점 및 최선의 방법, 그리고 구현을 설명하는 실용적인 코드 예제를 포함하고 있습니다.\n\n![마이크로서비스 아키텍처 구축](/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png)\n\n## 목차\n\n- 마이크로서비스 소개\n- 마이크로서비스 아키텍처의 장점\n- Nest.js 프레임워크 이해\n- 마이크로서비스 아키텍처 설계\n  - 서비스 검색 및 레지스트리\n  - 부하 분산과 게이트웨이\n  - 데이터 저장 및 지속성\n  - 마이크로서비스 간 통신\n  - 오류 처리와 회복\n- Nest.js로 마이크로서비스 구현\n- Docker를 사용한 마이크로서비스 구축\n- 클라우드에 마이크로서비스 배포\n- 마이크로서비스 모니터링 및 확장\n- 마이크로서비스 테스트 및 디버깅\n- 마이크로서비스 개발을 위한 최선의 방법\n- 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 마이크로서비스 소개\n\n마이크로서비스는 응용 프로그램을 작은, 독립적이며 느슨하게 결합된 서비스 집합으로 나누는 아키텍처 스타일입니다. 각 마이크로서비스는 특정 업무 기능을 수행하며 다른 서비스와 API를 통해 통신합니다. 이 모듈식 접근법을 통해 팀은 각 서비스를 개발, 배포 및 확장할 수 있어 더 큰 유연성과 더 빠른 개발 주기를 제공합니다.\n\n# 2. 마이크로서비스 아키텍처의 장점\n\n마이크로서비스 아키텍처는 다음과 같은 여러 가지 장점을 제공합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 확장성: 각 마이크로서비스는 독립적으로 확장 가능하여 고효율로 대량 처리를 처리할 수 있습니다.\n- 유지보수성: 서비스들은 전체 애플리케이션에 영향을 주지 않고 독립적으로 유지보수 및 업데이트할 수 있습니다.\n- 유연성: 팀은 각 서비스의 요구 사항에 따라 다른 기술을 선택할 수 있습니다.\n- 오류 격리: 한 서비스가 실패해도 전체 시스템에 영향을 미치지 않아 높은 가용성을 보장합니다.\n- 빠른 개발: 작고 집중된 팀은 특정 서비스에 독립적으로 작업하여 개발 속도를 높일 수 있습니다.\n- 지속적인 배포: 서비스는 다른 구성 요소에 영향을 미치지 않고 개별적으로 배포할 수 있습니다.\n\n# 3. Nest.js 프레임워크 이해\n\nNest.js는 효율적이고 확장 가능하며 유지보수가 용이한 서버 측 애플리케이션을 구축하기 위해 설계된 강력한 Node.js 프레임워크입니다. API 생성, 의존성 주입 및 모듈화 아키텍처를 작성하는 데 내장 지원을 제공합니다. Nest.js는 Express.js 위에 구축되었으며 TypeScript를 활용하여 강한 타입 지정 및 향상된 생산성을 가능하게 합니다.\n\n# 4. 마이크로서비스 아키텍처 설계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 구현에 들어가기 전에, Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계해 봅시다.\n\n## 서비스 검색 및 레지스트리\n\n마이크로서비스 아키텍처에서는 서비스들이 서로를 발견하고 통신해야 합니다. Consul이나 Eureka와 같은 서비스 레지스트리를 사용하여 마이크로서비스를 등록하고 찾을 수 있습니다.\n\n## 부하 분산 및 게이트웨이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 인스턴스의 서비스 간에 오는 요청을 균등하게 분산시키기 위해 로드 밸런서가 필요합니다. 게이트웨이는 클라이언트의 입구 역할을 하고 요청을 적절한 마이크로서비스로 라우팅합니다.\n\n## 데이터 저장 및 지속성\n\n각 마이크로서비스는 독립적인 데이터 관리를 유지하기 위해 자체 데이터베이스나 데이터 저장소를 가져야 합니다.\n\n## 마이크로서비스 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마이크로서비스는 RabbitMQ나 Kafka와 같은 RESTful API 또는 메시지 큐를 통해 통신합니다.\n\n## 오류 처리와 내구성\n\n시스템이 실패에서 우아하게 복구할 수 있도록 견고한 오류 처리 및 내구성 패턴을 구현하세요.\n\n# 5. Nest.js로 마이크로서비스 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 우리의 디자인을 실행하여 Nest.js를 사용하여 마이크로서비스를 구현해 봅시다.\n\n단계 1: 새로운 Nest.js 프로젝트 생성\n시작하려면 Nest.js CLI를 설치하고 새 프로젝트를 만듭니다:\n\n```js\nnpm install -g @nestjs/cli\nnest new microservices-project\ncd microservices-project\n```\n\n단계 2: 종속성 설치\n다음으로, 마이크로서비스를 위해 필요한 종속성을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nnpm install @nestjs/microservices @nestjs/typeorm typeorm mysql\r\n\n\r\nStep 3: Create Microservice Modules\r\n각각의 마이크로서비스를 위한 별도의 모듈을 만듭니다:\r\n\r\n```typescript\r\n// app.module.ts (Gateway)\r\nimport { Module } from '@nestjs/common';\r\nimport { AppController } from './app.controller';\r\nimport { AppService } from './app.service';\r\nimport { ClientsModule, Transport } from '@nestjs/microservices';\r\n\r\n@Module({\r\n  imports: [\r\n    ClientsModule.register([\r\n      {\r\n        name: 'SERVICE_A',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3001,\r\n        },\r\n      },\r\n      {\r\n        name: 'SERVICE_B',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3002,\r\n        },\r\n      },\r\n    ]),\r\n  ],\r\n  controllers: [AppController],\r\n  providers: [AppService],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n```typescript\r\n// service-a.module.ts\r\nimport { Module } from '@nestjs/common';\r\nimport { ServiceAController } from './service-a.controller';\r\nimport { ServiceAService } from './service-a.service';\r\n\r\n@Module({\r\n  controllers: [ServiceAController],\r\n  providers: [ServiceAService],\r\n})\r\nexport class ServiceAModule {}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\n// service-b.module.ts\nimport { Module } from '@nestjs/common';\nimport { ServiceBController } from './service-b.controller';\nimport { ServiceBService } from './service-b.service';\n\n@Module({\n  controllers: [ServiceBController],\n  providers: [ServiceBService],\n})\nexport class ServiceBModule {}\n```\n\nStep 4: 각 Microservice를 위한 Controllers 및 Services 구현\n각 Microservice에 대한 controllers 및 services를 생성하십시오:\n\n```typescript\n// app.controller.ts (Gateway)\nimport { Controller, Get, Inject } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { ClientProxy } from '@nestjs/microservices';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService, @Inject('SERVICE_A') private readonly clientA: ClientProxy, @Inject('SERVICE_B') private readonly clientB: ClientProxy) {}\n\n  @Get()\n  async getHello(): Promise\u003cstring\u003e {\n    const resultA = await this.clientA.send('getHello', '').toPromise();\n    const resultB = await this.clientB.send('getHello', '').toPromise();\n    return this.appService.getHello(resultA, resultB);\n  }\n}\n```\n\n```typescript\n// service-a.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceAService } from './service-a.service';\n\n@Controller()\nexport class ServiceAController {\n  constructor(private readonly serviceAService: ServiceAService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceAService.getHello();\n  }\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// service-b.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceBService } from './service-b.service';\n\n@Controller()\nexport class ServiceBController {\n  constructor(private readonly serviceBService: ServiceBService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceBService.getHello();\n  }\n}\n```\n\nStep 5: 서비스 로직 구현\n각 마이크로서비스에 대한 비즈니스 로직을 추가하십시오:\n\n```js\n// app.service.ts (게이트웨이)\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(serviceA: string, serviceB: string): string {\n    return `서비스 A가 말합니다: ${serviceA}, 서비스 B가 말합니다: ${serviceB}`;\n  }\n}\n```\n\n```js\n// service-a.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceAService {\n  getHello(): string {\n    return '서비스 A에서 안녕하세요';\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// service-b.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceBService {\n  getHello(): string {\n    return 'Hello from Service B';\n  }\n}\n```\n\n# 결론\n\n축하합니다! Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 성공적으로 구축했습니다. 마이크로서비스는 확장성, 유지보수성 및 장애 분리와 같은 여러 가지 이점을 제공합니다. 응용 프로그램을 더 작고 독립적인 서비스로 나누면 매우 유연하고 견고한 시스템을 구축할 수 있습니다. 마이크로서비스 개발을 위한 최상의 방법론을 따르는 것이 중요합니다. 서비스 검색, 부하 분산 및 적절한 오류 처리를 구현하는 것과 같은 것들을 잊지마세요.\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png","tag":["Tech"],"readingTime":7}],"page":"17","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"17"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>