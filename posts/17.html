<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/17" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/17" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024년 최고의 Nodejs 백엔드 프레임워크 5가지" href="/post/2024-06-22-Top5NodejsBackendFrameworksin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 최고의 Nodejs 백엔드 프레임워크 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 최고의 Nodejs 백엔드 프레임워크 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 최고의 Nodejs 백엔드 프레임워크 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs 마스터하기 고급 개발 및 성능 향상 팁" href="/post/2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs 마스터하기 고급 개발 및 성능 향상 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs 마스터하기 고급 개발 및 성능 향상 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs 마스터하기 고급 개발 및 성능 향상 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="MongoDB에서 PostgreSQL로 대규모 전환 가이드" href="/post/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="MongoDB에서 PostgreSQL로 대규모 전환 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="MongoDB에서 PostgreSQL로 대규모 전환 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">MongoDB에서 PostgreSQL로 대규모 전환 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="UUID7이 RDBMS에서 클러스터드 인덱스로 UUID4보다 더 나은 이유" href="/post/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="UUID7이 RDBMS에서 클러스터드 인덱스로 UUID4보다 더 나은 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="UUID7이 RDBMS에서 클러스터드 인덱스로 UUID4보다 더 나은 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">UUID7이 RDBMS에서 클러스터드 인덱스로 UUID4보다 더 나은 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개발자들이 잘 모르는 자바스크립트 기능 10가지" href="/post/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발자들이 잘 모르는 자바스크립트 기능 10가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발자들이 잘 모르는 자바스크립트 기능 10가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">개발자들이 잘 모르는 자바스크립트 기능 10가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석" href="/post/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" href="/post/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" href="/post/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ES8에서 가장 혁신적인 자바스크립트 기능 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" href="/post/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React와 TailwindCSS로 반응형 NavBar 만드는 방법" href="/post/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React와 TailwindCSS로 반응형 NavBar 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React와 TailwindCSS로 반응형 NavBar 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React와 TailwindCSS로 반응형 NavBar 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link posts_-active__YVJEi" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024년 최고의 Nodejs 백엔드 프레임워크 5가지","description":"","date":"2024-06-22 05:27","slug":"2024-06-22-Top5NodejsBackendFrameworksin2024","content":"\n\n## 2024년 API를 구축하기 위해 Hapi, Express.js, NestJS, Koa.js 및 Adonis.js를 탐험해보세요\n\n# 소개\n\nNode.js는 2009년 이후로 핫한 주제였으며 대부분의 백엔드 개발자들은 Node.js를 선호합니다. 그 인기는 지난 몇 년간 계속 증가해 왔습니다.\n\n![이미지](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인기 증가의 이유는 로딩 시간의 감소와 성능 향상 때문입니다. 따라서, 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크를 분석하는 것이 중요합니다.\n\n따라서 이 기사에서는 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크, 그들의 특징, 그리고 일반적인 사용 사례에 대해 다룰 것입니다.\n\n![image](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_1.png)\n\n# Express.js: 검증된 챔피언\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Express.js](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_2.png)\n\nExpress.js는 Node.js의 가장 유명한 백엔드 프레임워크 중 하나입니다. 오픈 소스 웹 어플리케이션 프레임워크로, Node.js 플랫폼 위에 만들어져 있어 무료로 이용할 수 있습니다. Express.js는 미니멀한 프레임워크이기 때문에 초보자부터 경험이 풍부한 웹 개발자들이 선호합니다. 웹 애플리케이션 및 RESTful API를 작성하는 데 주로 사용됩니다.\n\n# 주요 기능: 높은 효율의 라우팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 다양한 HTTP 요청을 관리하고 특정 작업에 할당하는 간단하고 깔끔한 방법을 제공합니다. 아래 예제를 살펴봅시다.\n\n```js\n// app.js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\n// 홈페이지 라우트\napp.get('/', (req, res) =\u003e {\n  res.send('홈페이지에 오신 것을 환영합니다!');\n});\n\n// 사용자 라우트\napp.get('/user/:id', (req, res) =\u003e {\n  const userId = req.params.id;\n  res.send(`사용자 프로필 페이지 - ID: ${userId}`);\n});\n```\n\n2. 미들웨어 지원\n\nExpress.js는 HTTP 요청을 처리하기 위한 미들웨어 지원을 제공합니다. HTTP 요청 세부 정보를 기록하는 미들웨어를 만드는 간단한 예제를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use((req, res, next) =\u003e {\n  console.log(`[${new Date().toLocaleString()}] ${req.method} ${req.url}` );\n  next();\n});\n```\n\n3. 쉬운 데이터베이스 통합\n\nExpress.js는 데이터베이스에 구애받지 않습니다. 특정 데이터베이스 선택을 강요하지 않습니다. 개발자들은 원하는 데이터베이스를 선택할 수 있습니다. Express.js와 데이터베이스를 통합시키는 것은 모듈식이고 유연한 성질과 데이터베이스 연결을 제공하는 npm 패키지의 풍부한 생태계 덕분에 쉽습니다.\n\n4. 배우기 쉽습니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 간결하고 최소주의 디자인으로 유명하며, 특히 JavaScript와 Node.js에 익숙한 개발자들에게 배우기 쉬운 것으로 알려져 있어요.\n\n게다가 Bit와 같은 도구를 사용하여 Express.js를 쉽게 시작할 수 있어요. Bit는 추가 구성 가능한 소프트웨어를 위한 차세대 빌드 시스템입니다.\n\n예를 들어 미들웨어 구성 요소를 만들어 필요할 때마다 끼워 넣거나 빼낼 수 있어요.\n\n![이미지](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제목: Bit 및 독립 컴포넌트를 사용하여 설계된 Express API의 범위\n\n두 개의 컴포넌트를 볼 수 있어요: Authorizer와 API 앱입니다. 이 두 컴포넌트는 독립적인 Bit 컴포넌트로 구현되어 있으며 별도의 공간에서 유지 및 버전 관리됩니다.\n\n이렇게 함으로써 앱을 조합 가능한 방식으로 빠르게 설계할 수 있어요!\n\n이 완벽한 구현을 보려면 Bit Scope를 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# NestJS: 현대적이고 체계적인 방법\n\n![image](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_4.png)\n\nNestJS는 확장 가능하고 효율적인 Node.js 서버 측 애플리케이션을 구축하는 데 알려진 프레임워크입니다. Progressive JavaScript를 사용하며 TypeScript로 코드를 작성할 수 있는 기능을 갖추고 있습니다. TypeScript를 완전히 지원하지만, 순수 JavaScript로 코드를 작성할 수 있으며 객체지향 프로그래밍, 함수형 프로그래밍 및 함수형 반응형 프로그래밍을 포함하고 있습니다.\n\n# 주요 기능: 높게 평가되는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 모듈성\n\nNest.js는 코드를 별도의 관리 가능한 모듈로 분할할 수 있어 유지 보수가 더 쉬워집니다. 예를 들어 아래 모듈을 살펴봅시다.\n\n```js\nimport { Module } from '@nestjs/common';\n\n@Module({\n imports: [\n  CacheModule\n ],\n controllers: [PaymentController],\n providers: [PaymentService],\n})\nexport class PaymentModule {}\n```\n\n이 결제 모듈은 다른 모듈로 내보낼 수 있습니다. 이 예시에서는 이 모듈 내에서 공통 캐시 모듈을 내보냈습니다. Nest.js는 모듈 구조를 가지고 있기 때문에 관리가 용이합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 2. 확장 가능성\n\nNest.js는 어플리케이션을 관리 가능한 모듈로 분할하여 확장을 용이하게 합니다. 유연한 컴포넌트 교체를 지원하며, 마이크로서비스 및 비동기 작업을 통해 고트래픽을 처리할 수 있습니다. 늘어난 작업 부하를 효율적으로 처리하면서도 안정성을 유지합니다.\n\n### 3. 의존성 주입\n\n의존성 주입은 외부 종속성을 클래스 내부에서 생성하는 대신 클래스에 추가하는 간단한 방법입니다. 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {\n HttpException, Injectable, NotFoundException\n} from '@nestjs/common';\n\n@Injectable()\nexport class PaymentService {\n\n constructor() {}\n\n getReceipt() {\n   return 'Payment Receipt';\n }\n\n}\n```\n\n저희는 결제 서비스를 만들었고 @Injectable() 어노테이션을 추가하여 주입 가능하게 만들었습니다. 아래와 같이 만들어진 서비스를 사용할 수 있습니다.\n\n```js\nimport { Controller, Get, Post, Body } from '@nestjs/common';\nimport { PaymentService } from './payment.service';\n@Controller('payment')\nexport class PaymentController {\n constructor(private readonly paymentService: PaymentService) {}\n@Get()\n getPaymentReceipt() {\n return this.paymentService.getReceipt();\n }\n}\n```\n\n4. 타입 안전성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`Nest.js`에서는 TypeScript를 사용하여 유형 안전성을 제공하며, 개발 중 잠재적인 오류를 찾아내고 코드 유지보수성을 개선하는 데 사용할 수 있습니다. 예를 살펴봅시다.\n\n```js\nexport class PaymentDto {\n\n  @IsNotEmpty()\n  @IsEnum(SERVICE_PROVIDER_SLUG, {\n    message: `Invalid serviceProvider. Valid options are: ${Object.values(SERVICE_PROVIDER_SLUG).join(', ')}`,\n  })\n  serviceProvider: string;\n\n  @IsNotEmpty()\n  @IsNumber()\n  value: number;\n\n  @IsNotEmpty()\n  @IsString()\n  validityPeriod: string;\n\n  @IsNotEmpty()\n  @IsArray()\n  @ArrayNotEmpty()\n  @ValidateNested()\n  @Type(() =\u003e PaymentAttributesDto)\n  paymentAttributes: PaymentAttributesDto[]\n\n}\n```\n\n이 예시에서, 우리는 여러 매개변수를 포함하는 DTO를 생성하고 매개변수 유형을 유효성 검사하는 어노테이션을 추가했습니다. 예를 들어, \"value\" 매개변수에 문자열 값을 보내면 오류가 발생합니다.\n\n# Koa.js: 우아하고 가벼운\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_5.png\" /\u003e\n\nKoa.js는 Express.js 팀이 설계한 더 작고 표현력 있는 웹 프레임워크입니다. 이를 사용하면 콜백을 버릴 수 있고 async 함수를 활용하여 오류를 처리할 수 있습니다.\n\n# 주요 기능: 눈에 띄는 특징\n\n1. 컨텍스트 객체(ctx)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKoa.js에는 요청과 응답 세부 사항을 캡처하는 ctx라는 기능이 포함되어 있습니다. 이 컨텍스트는 각 미들웨어에 전달됩니다. 이 예시에서는 ctx 객체에서 메서드와 요청을 기록했습니다.\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx) =\u003e {\n  const { method, url, request, response } = ctx;\n  console.log('Method :' + method + ' Request : ' + request);\n});\n\napp.listen(3000);\n```\n\n2. 미들웨어 조합\n\nExpress Js와 유사하게, Koa는 HTTP 요청과 응답을 처리하기 위한 미들웨어 함수를 지원합니다. 이 예시에서는 간단한 미들웨어를 만들었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx, next) =\u003e {\n  await next(); \n});\n\napp.listen(3000);\n```\n\n3. Async/Await Support\n\nKoa는 비동기 코드를 더 동기적으로 보이게 작성하기 위해 async/await 구문을 사용합니다. 아래 예제는 async/await 키워드를 사용하는 예시입니다.\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx) =\u003e {\n  const data = await fetchData();\n  ctx.body = `Data: ${data}`;\n});\n\napp.listen(3000);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 오류 처리\n\nKoa.Js는 다양한 종류의 오류 처리를 지원합니다. 오류를 처리하기 위해 app.emit() 또는 ctx.throw()를 사용할 수 있습니다. 아래 예시는 언급된 오류 처리 방법을 포함하고 있습니다.\n\n```js\nconst koa = require('koa');\nconst app = new koa();\n\n// 오류 처리 방법 1\napp.use(async (ctx, next) =\u003e {\n  try {\n    await Promise.reject('문제가 발생했습니다');\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = err.message;\n    ctx.app.emit('error', err, ctx);\n  }\n});\n\n// 오류 처리 방법 2\napp.use(async (ctx, next) =\u003e {\n  ctx.throw(500, '에러');\n});\n\napp.on('error', (err, ctx) =\u003e {\n  console.log(err);\n});\n\napp.listen(3000);\n```\n\n# Hapi.js\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_6.png\" /\u003e\n\nHapi.js는 Http-API를 축약한 것으로, 확장 가능한 웹 애플리케이션을 개발하기 위한 오픈 소스 프레임워크입니다. hapi의 가장 기본적인 사용 사례 중 하나는 REST API를 구축하는 것입니다.\n\n# 주요 기능: 뛰어나게 만드는 요소\n\n1. 구성 중심 설계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHapi.js의 구성 객체를 사용하면 라우트, 설정 및 플러그인을 설정할 수 있습니다.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nconst server = Hapi.server({\n  port: 3000,\n  routes: {\n    cors: true,\n  },\n});\n\nserver.route({\n  method: 'GET',\n  path: '/',\n  handler: (request, h) =\u003e {\n    return 'Hello, Hapi!';\n  },\n});\n\nasync function start() {\n  await server.start();\n  console.log('서버가 ${server.info.uri}에서 실행 중');\n}\n\nstart();\n```\n\n2. 강력한 플러그인 시스템\n\nHapi.js는 플러그인을 간편하게 통합할 수 있는 기능을 제공합니다. 다음 예제를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst start = async function () {\n\n    const server = Hapi.server();\n\n    await server.register([{\n        plugin: require('plugin1'),\n        options: {}\n    }, {\n        plugin: require('plugin2'),\n        options: {}\n    }]);\n};\n```\n이 예제에서는 두 개의 플러그인이 통합되었습니다. 옵션은 options 키를 사용하여 플러그인에 전달할 수 있습니다.\n\n3. 인증 및 권한\n\nHapi.js는 다양한 인증 전략에 대한 내장 지원을 제공하며, 개발자들이 쉽게 액세스 제어 정책을 정의할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nserver.route({\n  method: 'GET',\n  path: '/private-data',\n  handler: (request, h) =\u003e {\n    // 인증된 경우에만 개인 데이터에 액세스합니다\n    const user = request.auth.credentials;\n    return `환영합니다, ${user.username}!`;\n  },\n  options: {\n    auth: 'jwt', // JWT 인증 전략 사용\n  },\n});\n```\n\n이 예제를 기반으로하여, 우리는 인증 전략을 'jwt'로 직접 정의할 수 있습니다.\n\n4. 입력 유효성 검사\n\n입력 유효성 검사는 hapi.js의 또 다른 중요한 측면입니다. route의 options 객체에서 어떤 입력을 검증해야 하는지 정의할 수 있습니다. 기본 validate 객체는 아래 값으로 구성됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{ \n   headers: true, \n   params: true, \n   query: true, \n   payload: true, \n   state: true, \n   failAction: 'error'\n}\n```\n\n# Adonis.js\n\n![Adonis.js Logo](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_7.png)\n\nAdonis.js는 Node.js를 위한 전체 기능을 갖춘 MVC 프레임워크입니다. 확장 가능하고 유지 보수 가능한 애플리케이션을 구축할 수 있습니다. Adonis.js는 Laravel과 유사한 구조를 따르며 ORM, 인증 및 라우팅과 같은 기능을 기본 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 핵심 기능: 두드러지는 이유\n\n1. 풀 스택 MVC 프레임워크\n\nAdonis.js는 MVC 아키텍처 패턴을 따릅니다. MVC 프레임워크를 사용하면 코드를 조직화하고 유지 관리하고 확장하기 쉬워집니다.\n\n2. 데이터베이스 상호 작용을 위한 통합된 ORM(Lucid)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAdonis.js는 Lucid라는 자체 ORM을 가지고 있어요. Lucid는 표현적인 쿼리 빌더를 제공하며 다양한 데이터베이스 시스템을 지원해요. Lucid에서는 데이터베이스에 읽고 쓰기 위해 모델을 생성할 수 있어요. 아래 예시를 살펴보세요.\n\n```js\nconst Model = use('Model')\n\nclass User extends Model {\n}\n\nmodule.exports = User\n```\n\n우리는 이 사용자 모델을 데이터베이스 쿼리 대신 사용하고 있어요. 이제 라우트를 생성하는데, 해당 내부에서 사용자를 가져오고 있어요. 사용자를 가져오기 위해, 간단히 `User.all()`을 사용할 수 있어요.\n\n```js\nconst Route = use('Route')\nconst User = use('App/Models/User')\n\nRoute.get('users', async () =\u003e {\nreturn await User.all()\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 인증 시스템\n\nAdonis.js에는 사용자 인증 및 권한 부여를 위한 기본 지원이 있습니다. 사용자 세션, 비밀번호 해싱, 및 접근 제어를 다루는 일련의 메서드와 미들웨어를 제공합니다.\n\n# 결론\n\n2024년에는 위에서 언급한 백엔드 프레임워크들이 시장에서 높은 위치를 차지하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 간결함 때문에, Nest.js는 구조 때문에, Adonis.js는 생산성 때문에, Koa.js는 우아함 때문에 선택했을지라도, 올바른 프레임워크를 선택하는 것이 중요합니다.\n\n또한, 2024년에 성공적인 백엔드 개발 여정을 하려면 최신 트렌드, 기존 프레임워크의 새로운 기능, 그리고 새로운 프레임워크를 찾는 것이 중요합니다.\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png"},"coverImage":"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png","tag":["Tech"],"readingTime":10},{"title":"Nodejs 마스터하기 고급 개발 및 성능 향상 팁","description":"","date":"2024-06-22 05:26","slug":"2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips","content":"\n\n![이미지](/assets/img/2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips_0.png)\n\n프론트엔드 열정가인 당신, 백엔드 개발의 세계로 다이빙하시나요? 🤔 Node.js의 복잡한 풍경을 통해 즐거운 여정을 준비하세요! 🎢\n\n이 모험에서는 Node.js 프레임워크를 사용하여 백엔드를 빠르게 만들고 성능 분석, 테스트, 메모리에 대해 심층적으로 다루는 백엔드의 수많은 이야기를 탐험할 겁니다...","ogImage":{"url":"/assets/img/2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips_0.png"},"coverImage":"/assets/img/2024-06-22-NodejsMasteryAdvancedDevelopmentPerformanceTips_0.png","tag":["Tech"],"readingTime":1},{"title":"MongoDB에서 PostgreSQL로 대규모 전환 가이드","description":"","date":"2024-06-22 05:24","slug":"2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL","content":"\n\n![이미지](/assets/img/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL_0.png)\n\n지난 해에 Infisical은 급속히 성장하여 플랫폼이 매일 5000만 개 이상의 비밀을 처리하고 있습니다. 이 비밀은 애플리케이션 구성 및 비밀 데이터를 필요로 하는 팀, CI/CD 파이프라인 및 서버/애플리케이션으로 전송됩니다.\n\n사용량이 계속 증가함에 따라 계속해서 스택을 업그레이드해야 했습니다. 더 최근에 Infisical은 MongoDB에서 PostgreSQL로의 전체 데이터베이스 이전을 진행했습니다. 이 프로세스에는 계획 수립, 새 기술 도입, 새 데이터베이스 스키마 생성, 로직 연결 변경, 쿼리 재작성 및 수십억 개 이상의 데이터베이스 레코드를 PostgreSQL로 마이그레이션하는 작업이 포함되었습니다. 복잡한 프로세스였지만, 플랫폼의 발전을 위해 필요한 작업이었습니다.\n\n이는 MongoDB에서 PostgreSQL로 이동한 이유와 그 과정에 대한 우리의 의사결정 이야기입니다. 아마도 이 글은 흥미로운 내용으로, 그 어느 날 비슷한 데이터베이스 이전을 고려할 여러분들에게 유용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시작점\n\n인피시컬(Invisical)을 처음 만들 때, 팀이 가장 익숙한 스택으로 만들었습니다. 그 스택 중 하나로 MongoDB + Mongoose ORM을 선택한 이유는 해당 조합이 최소한의 오버헤드를 제공하고 품질있는 기능을 빠르게 출시할 수 있었기 때문입니다. Tony Hoare 선생이 말하듯이 \"조기 최적화는 모든 악의 근원이다,\" 그 때는 확실히 더 나은 최적화가 필요하지 않았습니다.\n\n그 당시에는 인피시컬 클라우드를 구축하는 데 더 주력했었고, 이 중점 때문에 제품을 직접 호스팅하는 사용자가 많을 것이라고 예상하지 않았으므로 해당 사용 사례를 염두에 두지 않고 설계되지는 않았습니다.\n\n# 왜 MongoDB가 아닌가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몽고DB가 초기에 인피지칼에 잘 도움이 되었지만, 제품의 사용 사례가 관리 서비스를 넘어선 경우에 한계를 보이기 시작했습니다. 시간이 지남에 따라, 특히 규정 준수와 보안이 교차하는 기업들 중 많은 조직이 인피지칼을 자체 호스팅하는 것을 선호했으며, 다른 일부는 만족해야 하는 온프렘 요구 사항이 있었습니다.\n\n인피지칼의 자체 호스팅 수요가 증가함에 따라, 우리는 인피지칼을 자체 호스팅하는 데 필요한 학습 곡선을 줄이기 위해 여러 기능을 제공하고, 이 과정에서 몽고DB를 포스트그리스로 전환했습니다.\n\n실제로, 우리와 고객들은 자주 몽고DB의 기능과 사용성과 관련된 제약사항에 부딪히곤 했습니다. 트랜잭션 지원 부족, 정리, 클라우드 제공 업체의 관리 서비스 간 불일치한 버전 관리, 그리고 스키마 없는 데이터베이스 설계 구조와 관련된 문제 등이 있었습니다.\n\n위 몇 가지 도전 과제에 대해 자세히 설명하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터베이스 트랜잭션 구성의 어려움: MongoDB에서는 트랜잭션을 설정하는 것이 쉽지 않았습니다. 클러스터 모드에서 MongoDB를 실행해야 했으며 다양한 구성 오버헤드가 필요했습니다. 이로 인해 고객이 Infisical의 간단한 POC를 실행하기가 굉장히 어렵게 되었는데, 이는 MongoDB의 프로덕션 환경 설정을 필요로 했기 때문입니다. 데이터 무결성이 반드시 유지되어야 하는 매우 민감한 데이터를 다루는 제품에서는 적합하지 않았습니다.\n\n- 관계형 기능 부재: MongoDB에서는 선택할 수 있는 CASCADE와 같은 관계형 세계의 많은 편리한 기능을 잃게 되었습니다. 이 기능은 목표 리소스를 삭제할 때 다른 테이블을 통해 참조된 모든 리소스를 삭제합니다. 우리의 데이터가 매우 관계적이었기 때문에 특히 아플 정도였습니다. 그 결과, 우리는 이전 코드베이스에서 완전히 수행되지 않았고 MongoDB 데이터베이스에 매달려있는 리소스를 남기는 무거운 삭제 기능을 사용했습니다.\n\n- 클라우드 제공자 간 지원 부족: MongoDB의 라이선스 변경(SSPL) 이후 많은 클라우드 제공 업체가 MongoDB의 이전 버전을 제공하기 시작했습니다. 결과적으로, MongoDB의 최신 안정 버전 이외의 버전을 실행 중인 고객을 위해 Infisical의 기능의 가용성을 보장하는 것이 어렵다는 것을 깨달았습니다.\n\n- MongoDB 경험 부족: 더 많은 사람들이 SQL 기반 데이터베이스를 배포하는 데 친숙했기 때문에 MongoDB를 확장하고 적절히 구성하는 데 어려움을 겪기도 했습니다. 이로 인해 MongoDB에 익숙하지 않았기 때문에 특히 고객들에게 제공해야 하는 서비스 양이 불균형하게 증가했습니다.\n\n여러 이유 중에서 우리는 Infisical을 전 세계의 팀과 조직에 더욱 접근 가능하게 만들기 위해 궁극적인 기능으로 더욱 보편적인 것으로의 완전한 데이터베이스 이전이 필요하다는 깨달음을 얻었습니다.\n\n# 왜 PostgreSQL을 선택했는가?\n\n새 데이터베이스를 찾을 때, 우리는 우리에게 가장 중요한 측면을 나열하여 시작했습니다: 관리의 용이성(즉, 구성, 배포 및 확장 포함), 트랜잭션을 위한 내장 지원 및 관계적 기능. 논의의 일환으로, 우리는 직접 통합 저장소를 구축할지 외부 저장소 솔루션을 추구할지에 대해 고민하기도 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 옵션에 대한 의미는 다음과 같습니다:\n\n- 통합 스토리지: 우리는 SQLite와 같은 데이터베이스 시스템을 직접 Infisical에 포함시키고 추가 네트워크 합을 피해 지연 시간을 줄이기 위해 수평 복제 전략을 채택할 수 있었습니다. 이 모델에서 시스템의 확장은 Infisical의 여러 인스턴스를 배포하고 Raft와 같은 일치 알고리즘을 통해 서로 통신하도록 하는 것을 의미했습니다. 고객이 Infisical을 실행하기 위해 종속성을 연결할 필요가 없다는 점이 훌륭한 해결책으로 보였지만, 이 비전을 실행하기 위한 도구 생태계는 미숙하게 느껴지고, 그에 필요한 공학 노력은 어마어마한 것으로 느껴졌습니다.\n- 외부 스토리지: 우리는 단순히 MongoDB를 PostgreSQL이나 MySQL과 같은 다른 데이터베이스로 교체하고 내장된 확장 능력을 사용할 수 있었습니다. 이 해결책은 Infisical을 사용하기 위해 외부 종속성이 필요하다는 마찰을 완전히 제거하지는 않았지만, MongoDB가 아니라는 점만으로도 중요한 혜택을 제공한다고 느꼈습니다. 하나 이상의 데이터베이스를 지원하는 데 있어서 여러 데이터베이스를 지원한다면 각 솔루션의 고유한 장점을 놓칠 수 있을 뿐만 아니라 엔지니어링 부담도 증가할 것으로 판단했습니다.\n\n신중한 고려 끝에, 우리는 PostgreSQL을 선택했습니다. 활기찬 커뮤니티, 방대한 문서화, 다양한 솔루션과 확장 프로그램이 제공되는 것을 넘어서, 우리는 PostgreSQL의 오픈 소스 특성과 대부분의 클라우드 제공업체에서 PostgreSQL의 관리 서비스를 제공한다는 점을 가장 감사했습니다.\n\n이 모든 선택은 Infisical의 사용자들이 어떤 클라우드 제공 업체에서도 우리 플랫폼을 쉽게 자체 호스팅하고 해당 관리형 PostgreSQL 서비스와 함께 사용할 수 있음을 의미합니다. 더욱이, 이 데이터베이스가 널리 채택되었다는 점을 고려할 때, 사용자들이 Infisical을 사용할 때 데이터베이스를 운영하는 데 더 적은 문제가 있을 것으로 확신했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ORM은 어떻게 됐나요?\n\nPostgreSQL을 선택한 후, 어플리케이션이 데이터베이스와 상호작용하는 방법을 결정해야 했습니다. MongoDB에서 Mongoose ORM을 사용한 경험과 유사한 것을 원했기에 즉시 Drizzle ORM, Prisma ORM, TypeORM 및 질의 빌더인 Knex.js를 중점적으로 검토하기 시작했습니다.\n\n결국, 우리는 더 좋은 데이터베이스 제어를 위해 ORM 대신 쿼리 빌더인 Knex.js를 사용하기로 결정했습니다. 말은 듣기 어려워서 작업 유지가 어렵고, 특히 적절한 TypeScript 지원 없이는 실수하기 쉬울 것 같은 생각이 들었기 때문입니다. 게다가 Knex.js는 순수 SQL에 가깝지만 시드 및 마이그레이션을 위한 도구가 탑재되어 있었으며, 훌륭한 문서와 거의 모든 쿼리에 대한 답변을 갖춘 성숙한 생태계를 갖췄습니다. 몇 가지 사용자 정의 Zod 통합 작업과 결합하여 TypeScript 지원을 만족스러운 수준으로 유지할 수 있었습니다.\n\n데이터베이스와 ORM을 결정한 후, 이어지는 과정에서 수십 개의 데이터 구조 및 수백 개의 쿼리를 어플리케이션 전반에 걸쳐 다시 작성하는 작업을 시작했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마이그레이션 계획은 어떻게 세웠나요?\n\n코드 재작성이 끝나가는 시점에, 우리는 MongoDB 데이터를 PostgreSQL로 매핑하는 마이그레이션 작업을 수행하는 방법에 대해 고민하기 시작했습니다. 이 작업은 Infisical Cloud 플랫폼에 최소한의 방해를 주며 실시하는 것이 목표였습니다.\n\nInfisical이 고객 인프라에서 중대한 역할을 하는 점을 감안하여 절대 다운타임은 허용할 수 없다는 결론을 즉시 도출했습니다. 마이그레이션 기간 동안 쓰기 작업을 금지하는 것으로 일시적으로 타협해야 했지만(즉, 고객이 응용 프로그램 구성을 생성하거나 업데이트할 수 없는 경우), 더 높은 데이터 무결성을 보장하는 대신 이를 선택한 것이었습니다. 이러한 트레이드오프는 고객이 주로 Infisical에서 시크릿을 검색하고, 그 다음으로 두 번째로 응용 프로그램 구성을 초 단위로 업데이트하는 경우에 수용 가능해 보였습니다.\n\n이어서 실제 마이그레이션 작업에 대해 고민할 때 MongoDB에서 데이터를 덤프하고 신중히 변환한 후 PostgreSQL로 다시 삽입해야 했습니다. 마이그레이션 순서를 심사하면서, NoSQL에서 가져온 다양한 트리 형태의 구조를 관련된 상대적인 구조로 올바르게 변환해야 하는 등 다양한 어려움을 겪었습니다; 특히 재귀적인 고려가 필요한 폴더와 같은 데이터 구조에 대해 민감했습니다. 또한, MongoDB에서 PostgreSQL로 식별자를 저장하고 매핑하는 지속적인 방법이 필요하다는 사실을 발견했으며, 메모리에 저장하면 처리할 데이터 양을 고려할 때 동작하지 않을 것 같았습니다. 결과적으로, 우리는 식별자 저장 및 조회 작업을 돕기 위해 LevelDB 키-값 저장소를 사용하기로 결정했습니다. 이를 통해 결과적으로 각 테이블을 순차적으로 PostgreSQL로 이동할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위대한 이주\n\n드디어, 우리는 이주를 진행할 준비가 되었습니다. 이 시점에서 코드베이스 재작성에 직접 관여하지 않은 사람들은 Infisical의 기타 측면을 개선하는 데 매우 중요한 한 분기를 보내었는데, 프런트엔드 변경사항을 만들고 유지 관리 패치를 수행하며 클라이언트 기능을 확장하고 더 나은 문서를 작성했습니다. 이제 이주 자체를 준비하기 위해 모두가 모여 새로운 애플리케이션 코드베이스로 교체하고 데이터를 MongoDB에서 PostgreSQL로 이전하는 작업을 시작했습니다.\n\n준비과정에서 우리는 예상 일정을 포함한 자세한 이주 체크리스트를 작성했습니다.\n\n전반적으로 계획은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이주 동안 이주를 준비하는 동안, 사용자들에게 장기적인 데이터베이스 업그레이드에 대해 미리 이메일과 앱 내 배너를 통해 통지하겠습니다. 플랫폼의 모든 기능 flow에 대한 철저한 테스트를 수행하고, 이주를 위한 시범 운영도 진행할 것입니다.\n- 이주 자체는 단순히 소요되는 6시간 동안에만 읽기 작업만 허용되는 창을 통해 진행됩니다. 이 기간 동안 MongoDB에서 PostgreSQL로 데이터를 이동하는 이주 스크립트를 실행하고, 데이터 손실이 없는지 확인한 후 성공적으로 DNS를 새 인스턴스로 전환할 것입니다. 물론, 상황이 역행할 경우를 대비한 백업 계획도 마련되어 있습니다.\n- 마침내 이주 후, 어떠한 잔여 문제도 해결하고 Infisical과 PostgreSQL을 사용하여 새로운 문서를 점차 배포할 것입니다.\n\n계획이 준비되어 있다면, 실행으로 나아갑시다.\n\n# 결과\n\n다행히도, 이주 실행은 원활하게 진행되어 데이터 손실이 없었고, 몇 가지 중요하지 않은 기능 장애 사례만 발생했습니다. 이러한 버그는 소비자에게 미미한 영향을 미친 채 36시간 이후에 해결하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이주 후에 우리는 많은 이점을 발견했습니다:\n\n- 쿼리 최적화와 조인을 통한 성능 향상으로 인해 플랫폼이 상당한 성능 향상을 경험했습니다. MongoDB를 사용할 때, 필요한 기능을 얻기 위해 종종 비효율적인 집계 쿼리와 여러 네트워크 항해를 거쳐야 했었습니다. 핵심 데이터의 관계적 특성으로 인해 SQL에서 조인을 모방하려면 많은 $lookup 작업을 수행해야 했는데, 이러한 작업은 비효율적이었고 데이터베이스와 응용 프로그램 인스턴스를 모두 확장해야 했습니다. PostgreSQL로 이전하면서 이러한 비효율적인 작업을 피하고 데이터베이스 청구서 비용을 50% 절감했습니다.\n- 플랫폼은 이제 어플리케이션 레벨이 아닌 데이터베이스 레벨에서 더 나은 데이터 유효성 검사를 하게 되었습니다. MongoDB는 설계상 스키마가 없기 때문에 데이터 유형, 필수 필드 및 유효성 규칙을 정의하기 위해 Mongoose 프레임워크에 의존했습니다. PostgreSQL이 구축된 상태로 데이터 불일치를 더 이상 경험하지 않았으며, Mongoose 판권 범위를 벗어난 데이터베이스에 액세스하거나 수정시 발생하던 문제를 더 이상 겪지 않았습니다.\n- 마지막으로 매우 중요한 점은 고객이 MongoDB의 복제 집합을 다루는 추가 구성 부담 없이 증명 사례를 수행할 수 있는 등 Infisical이 이제 훨씬 쉽게 자체 호스팅될 수 있다는 것입니다.\n\n전체적으로, 목표, 업무 범위 및 실행 결과를 고려할 때, 이 이니셔티브를 매우 성공적으로 평가했습니다. 미래에 더 많은 데이터를 보유할 때 구체적인 결과를 발표할 계획입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몽고디비에서 포스트그레스큐엘로 이전하기로 한 결정은 처음부터 쉬운 일은 아니었습니다. 모든 과정을 신중하게 계획하고 논의한 후, 우리는 이 일을 수행하기 위해 3~4개월이 걸렸습니다. 왜 이렇게 해야 하는지, 어떻게 실행할 것인지에 대해 심도있게 고민한 끝에 모든 것을 신중히 실행할 수 있었습니다. 이 글을 읽는 누구에게든, 이러한 큰 작업에 속해들기 전에 사용 사례와 구현을 심각하게 고려하는 것을 강력히 권장합니다. 결국 모든 것이 계획대로 진행되어 매우 만족스럽습니다. 앞으로 인피지컬 사용자들에게 큰 변화를 가져다 줄 이런 거대한 업데이트를 성공적으로 전달할 수 있어 기쁩니다.\n\n몽고디비에서 포스트그레스큐엘로의 이주 계획을 완벽히 수행한 Akhil Mohan과 인피지컬의 다른 모든 분들께 감사드립니다.\n\n# 인피지컬 - 오픈 소스 시크릿 관리 플랫폼\n\n![이주 이미지](/assets/img/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nInfisical (11.6K+ ⭐️)은 수천 개의 팀과 조직이 팀 및 인프라 전반에 걸쳐 비밀을 저장하고 동기화하는 데 도움을 줍니다.\n\nGitHub 저장소: https://github.com/Infisical/infisical","ogImage":{"url":"/assets/img/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL_0.png"},"coverImage":"/assets/img/2024-06-22-TheGreatMigrationfromMongoDBtoPostgreSQL_0.png","tag":["Tech"],"readingTime":8},{"title":"UUID7이 RDBMS에서 클러스터드 인덱스로 UUID4보다 더 나은 이유","description":"","date":"2024-06-22 05:23","slug":"2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS","content":"\n\n데이터베이스 색인 소개 기사에서는 데이터베이스 인덱스, 그 종류, 표현 방법 및 사용 사례에 대해 논의했습니다.\n\n이 기사에서는 클러스터링된 인덱스로서 더 나은 성능을 발휘하는지 확인하기 위해 UUID 버전 4 대 UUID 버전 7 또는 6의 실험을 진행할 것입니다. 그런 다음 그 이유에 대해 논의할 것입니다.\n\n# UUID 버전 4란?\n\nUUID는 `Universally Unique Identifier`의 약자로, 대시로 구분된 문자와 숫자의 32자 시퀀스로 표현되는 128비트 식별자입니다. '8-4-4-4-12' 형식으로 포맷되며, \"123e4567-e89b-12d3-a456-426655440000\"와 같이 UUID 버전 4의 구조는 각 문자가 '1'에서 'f'까지의 16진수 값을 보여줍니다. 완전히 무작위로 생성되었던지 아니면 유사 난수 생성기를 통해 생성되었던지에 관계없이, UUID 버전 4는 그 독특한 고유성을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고 자료 #2에서 자세한 계산 내용을 찾을 수 있어요.\n\n# UUID 버전 7이 무엇인가요?\n\nUUID v7은 UUID v4와 유사한 128비트 식별자로, 문자와 숫자의 32글자 시퀀스로 표시되며, 8-4-4-4-12 형식으로 구성됩니다. UUID v7의 독특한 특징은 Unix 타임스탬프를 밀리초 단위로 가장 유의미한 48비트에 인코딩하는 시간순서 UUID로 있는 것입니다. UUID 형식에 따라 4비트는 UUID 버전을 지정하고, 2비트는 변형을 나타냅니다. 나머지 74비트는 무작위로 생성되어 이 식별자의 고유성에 기여합니다.\n\n![이미지](/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 UUID를 사용해야 할까요?\n\nUUID와 연속적인 ID를 비교한 장단점을 알아보겠습니다.\n\n- 장점:\n1. 충돌 확률 낮음: UUID는 구조상 충돌 확률이 매우 낮아서 서버가 레코드 삽입 전에 ID를 생성할 수 있습니다.\n2. 분산 시스템에 적합: UUID는 분산 데이터베이스 및 시스템에 적합하며 서버에서 독립적으로 생성할 수 있습니다.\n3. 향상된 보안: UUID는 레코드를 익명으로 유지하여 사용자(또는 악성 주체)가 레코드 생성 순서에 대한 정보를 유추하는 것을 방지하여 데이터베이스 보안에 기여합니다.\n\n- 단점:\n1. 저장 공간 증가: UUID는 전통적인 ID(예: INT에 4바이트 또는 BIGINT에 8바이트)보다 더 많은 공간(16바이트)을 차지합니다.\n2. 수동 데이터 입력의 어려움: UUID의 복잡성으로 인해 수동 데이터 입력이 어려울 수 있습니다.\n3. 쿼리 성능 감소: 큰 UUID 크기는 쿼리 성능을 감소시킵니다. 레코드 크기의 증가로 인해 데이터베이스 페이지 당 저장되는 레코드가 줄어들어 I/O 작업이 늘어나고 전체적인 성능이 감소합니다.\n4. 인덱스와 데이터 단편화: UUID는 인덱스 및 데이터 단편화에 영향을 줄 수 있어 데이터베이스 효율성에 영향을 미칠 수 있습니다.\n\n# 실험을 시작해봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개요:\n\n이 실험에서는 MySQL, Docker, Node 및 Go를 사용합니다.\nMySQL을 실행하고 구성하며 데이터를 볼륨에 저장하는 docker-compose 파일을 만들었습니다 (이 실험 후에는 이 볼륨을 자동으로 정리합니다).\n\n참고: MySQL은 기본적으로 기본 키에 대해 클러스터화된 인덱싱을 사용하므로 PostgreSQL에는 없는 기능이기 때문에 MySQL을 선택했습니다.\n\n노드.js 스크립트와 Go를 사용하여 100만 개의 레코드를 하나씩 삽입하여 삽입 성능을 테스트할 것입니다 (대량 사용 시 DB 엔진이 레코드를 정렬하고 실험을 망칠 수 있습니다). Go와 고루틴을 사용하여 여러 서버가 하나의 DB에 연결하여 200만 개의 레코드를 삽입하는 시나리오를 시뮬레이션할 것입니다. 코어 당 1개의 스레드를 실행하여 7개의 스레드를 실행합니다. 도커 데몬을 실행할 코어는 1개가 남도록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실험에서는 채팅 데이터베이스를 시뮬레이션했습니다. \"chat_messages\"라는 테이블 하나만 가지고 있으며 id, chat_id, sender_id, message 및 created_at이라는 열이 있습니다. id, chat_id 및 sender_id의 유형은 데이터를 Integer 또는 UUID v4 또는 UUID v7로 입력하는 방식에 따라 INT에서 BINARY(16)으로 다양합니다.\n\n## 메모:\n\n- 저는 삽입 시간을 애플리케이션 수준에서 측정했습니다. 이 방법이 가장 정확한 방법은 아니며 트리거 또는 저장 프로시저를 사용할 수도 있지만, 이 방법이 더 빨랐습니다. 실험을 한 번 이상 반복하고 서로 다른 기계 및 프로그램(node 및 go)에서 수행하여 결과가 유사한 것으로 확인했습니다.\n- 실험은 전용 기계에서 진행되었으며 실험 과정 중 시스템 자원이 동시에 사용되지 않도록 보장했습니다. 이러한 의도적인 격리는 측정된 삽입 시간에 영향을 줄 수 있는 외부 요소를 최소화하여 결과의 신뢰성을 향상시킵니다.\n\n## 단계:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 실험의 개요를 아래와 같이 정리해 봤어요:\n\n- 도커 컴포즈 파일 실행\n- 데이터베이스에 연결\n- chat_messages 테이블 생성 (UUID v4)\n- 레코드 삽입 및 시간 측정 (모든 삽입의 합) (UUID v4)\n- 도커 중지 및 볼륨 삭제 (UUID v7 삽입에 영향을 주지 않기 위해 매우 중요)\n- 이후 1초 대기 (시스템이 메모리와 스왑을 청소할 수 있도록)\n- chat_messages 테이블 생성 (UUID v7)\n- 레코드 삽입 및 시간 측정 (UUID v7)\n- 도커 중지 및 볼륨 삭제\n- 이후 1초 대기\n- chat_messages 테이블 생성 (정수)\n- 레코드 삽입 및 시간 측정 (정수)\n- 도커 중지 및 볼륨 삭제\n- 이후 1초 대기\n\n만약 원하신다면 이 리포지토리를 복제하고 실험을 직접 실행해 보실 수 있어요.\n\n## 결과:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드 프로세스가 100만 개의 레코드를 삽입하는 중입니다:\nUUIDV4: 24345338.406382076\nUUIDV7: 23579840.35688359\nINT: 23678315.194741927\nUUID V4 / UUID V7 비율: 1.0324640895745087\n\n여기서도 UUID V4가 UUID V7보다 3% 더 많은 시간을 소요한 것을 볼 수 있어요.\n\nGoLang 프로세스가 100만 개의 레코드를 삽입 중입니다:\nUUIDV4: 2.6320770985406373e+07\nUUIDV7: 2.5592608053863425e+07\nINT: 2.5759889825318027e+07\nUUID V4 / UUID V7 비율: 1.0284520799916297\n\n여기서도 UUID V4가 UUID V7보다 3% 더 많은 시간을 소요한 것을 볼 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7개의 스레드로 5백만 개의 레코드를 삽입하는 MultiThreaded Go 프로그램:\n8개의 코어를 사용하기 때문에 각 스레드를 하나의 코어에 고정시키려고 시도했습니다.\n\nUUID V4: 20634873.5100111 밀리초\nUUID V7: 16750775.02223781 밀리초\nINT: 164567295.36401817 밀리초\nUUID V4 / UUID V7 백분율: 1.2318757479947573\n\n여기서 UUID v4가 UUID v7보다 약 23.1% 더 오래 걸렸음을 볼 수 있습니다.\n그리고 정수보다 약 25.3% 더 오랜 시간이 걸렸습니다. (결과가 한 번 실행에서 다른 결과가 나올 수 있다는 점을 유의해 주세요)\n\n# UUID v7이 UUID v4보다 왜 더 빨랐을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인덱스 지역화:\n\n공유된 이해를 확립하기 위해, 참조된 기사에서 이전에 소개된 개념인 클러스터형 인덱스를 다시 살펴보겠습니다. 클러스터형 인덱스의 저장 메커니즘은 결과를 이해하는 데 중요합니다.\n\n클러스터형 인덱스는 어떻게 저장되나요?\n\n각 데이터 조각이 페이지에 저장된다고 언급했습니다. 그런 다음 인덱스는 페이지 내에 b+ 트리로 저장됩니다. 이것은 인덱스 내의 키가 정렬되어 있다는 것을 의미합니다. 따라서 새 키를 기존 키 사이에 삽입하는 경우에는 저장된 인덱스의 재조직이 필요합니다. 이 재조직 프로세스에는 여러 페이지를 검색하고 해당 페이지를 읽은 다음 새 페이지를 삽입하면서 다음 및 이전 포인터를 조정하는 작업이 포함될 수 있습니다 (페이지를 분할하는 대신).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Link to WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_1.png](/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_1.png)\n\n![Link to WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_2.png](/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_2.png)\n\n새 레코드 ID 8이 추가되었음을 알 수 있습니다. Figure 4에서 10, 15, 및 20을 포함하는 페이지가 분할되었습니다. 이 과정에서 데이터 페이지도 분할되었음을 강조해야 합니다.\n\n![Link to WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_3.png](/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞서 말한 대로, 비순서화된 ID가 성능에 어떤 영향을 미칠 수 있는지 짐작할 수 있게 되었습니다.\n\nUUID v4 ID는 서로 상관관계가 없어서, 완전히 무작위한 성격 때문에 인덱스 지역성이 떨어집니다. 따라서 새로 생성된 UUID v4가 이전 것보다 낮은 Hex 값일 수 있습니다. 클러스터 인덱스를 사용하고 있기 때문에, 원하는 순서를 유지하기 위해 새로 생성된 UUID v4를 이전 것보다 앞에 위치시키는 것이 필요합니다.\n\nUUID v7와 달리, 시간 기반 성격으로 내재적으로 정렬되어 있습니다. 이것은 값이 거의 순차적으로 생성되어 마지막 페이지 끝에 일관되게 삽입된다는 것을 의미합니다(모든 서버가 동기화되어 있다면). 이 특성은 인덱스 지역성 문제를 효과적으로 해결합니다.\n\n## 버퍼 풀:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 개념이 처음이라면 빠르게 소개해 드리겠습니다.\n데이터베이스 엔진은 우리의 기기에서 다른 실행 중인 프로세스와 마찬가지로 무한한 메모리를 갖고 있지 않습니다. 그들은 OS로부터 고정 크기의 메모리를 요청합니다. 데이터베이스 엔진은 쿼리 최적화, 레코드 구문 분석, 레코드 정렬, 레코드 조인 등 다양한 작업을 수행하는 데 사용됩니다. 하지만 중요한 것은 우리에게 있어서, 이 메모리 위치 중에는 저장소에서 읽은 페이지를 유지하거나 새 레코드를 삽입하기 위한 새 페이지를 생성하는 메모리 파티션인 \"버퍼 풀\"이 있습니다.\n\n이것은 읽기(선택) 작업에서 페이지를 저장하는 데만 사용되지 않습니다. 삽입, 업데이트 및 삭제 작업에도 사용됩니다. 데이터베이스 엔진은 대상 레코드가 존재하는 페이지를 가져오거나 삽입, 업데이트 또는 삭제해야 하는 페이지를 가져와야 합니다.\n\n우리 문제와 어떤 관련이 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUUID v4의 병목 현상 핵심입니다. 문제는 ID가 매우 무작위이며 버퍼 풀이 빠르게 가득 차서 매번 레코드가 다른 페이지에 저장됩니다. 따라서 데이터베이스 엔진은 해당 레코드를 가져와야 하는데 버퍼 풀이 가득 찬 경우 몇 개의 페이지를 디스크로 다시 기록하여 공간을 확보해야 합니다. 그리고 바로 옆에 있는 다음 레코드가 방금 기록한 페이지와 다를 수도 있기 때문에 이 작업이 계속 반복됩니다.\n\n그러나 UUID v7 또는 Serial Integer의 경우에는 이러한 일이 발생하지 않습니다. 왜냐하면 레코드의 ID가 증가하는 순서로 부여되기 때문입니다. 따라서 페이지 제한에 도달하면 레코드가 마지막 페이지에 추가될 것이고 데이터베이스 엔진은 새 페이지를 만들게 됩니다. 이전 페이지를 디스크에 기록할지 여부는, 버퍼 풀이 가득 차기를 기다릴지 아니면 WAL에만 쓸지를 결정할 것입니다.\n\n# 마지막 질문은 왜 Serial이 UUID보다 빨랐을까요?\n\n이제 이 질문은 매우 쉽게 대답할 수 있는 질문입니다. 데이터베이스에 각 레코드가 페이지에 삽입되고 페이지의 기본 크기는 16 KByte (MySQL) 및 8 KByte (PostgreSQL)로 고정됩니다. INT ID의 경우 레코드 크기는 271 바이트(4 + 4 + 4 + 255 + 4)(INT, INT, INT, VARCHAR(255), TIMES...)입니다. 그러나 UUID의 경우 레코드 크기는 307 바이트(16 + 16 +16 + 255 + 4)입니다.\n페이지 당 더 많은 레코드가 포함될 수 있다는 가정하에, INT ID의 페이지에는 더 많은 레코드가 포함되어 있기 때문에 IO가 적고 속도가 더 빠릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 작은 참고사항을 드리자면 타임스탬프 GUID를 추가하는 아이디어는 새로운 것이 아닙니다. UUID v1이 이를 수행했지만 단점이 있었고, Instagram의 ShardingID, Shopify는 UUID v4 대신 ULID를 사용하며, MongoDB ObjectID도 비슷한 방식을 사용합니다.\n\n마지막으로, 이 기사를 즐겁게 읽으셨기를 바랍니다. 새로운 것을 배우셨다면 좋겠습니다. 더 개선할 부분이 있다면 언제든지 알려주세요.\n\n# 향후 작업:\n\n- Rust로 테스트해 보고 싶습니다.\n- 각 인덱스 유형별로 인덱스 B+ 트리의 크기를 확인하고 싶습니다.\n- 단일 연결 대신 데이터베이스 연결 풀을 사용하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료:\n\n- 비슷한 아이디어를 설명하는 멋진 동영상\n- UUID 버전 4 형식\n- UUID 고유성\n- UUID RFC\n- UUID와 ID에 대한 더 많은 정보\n- UUID v7\n- 잘못된 분할\n- 정수 작별. UUIDv7 안녕하세요! 훌륭한 기사.","ogImage":{"url":"/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_0.png"},"coverImage":"/assets/img/2024-06-22-WhyUUID7isbetterthanUUID4asclusteredindexinRDBMS_0.png","tag":["Tech"],"readingTime":8},{"title":"개발자들이 잘 모르는 자바스크립트 기능 10가지","description":"","date":"2024-06-22 05:22","slug":"2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow","content":"\n\n\n![Image](/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png)\n\n현대의 대부분의 프로그래밍 언어는 일반적으로 두 가지 주요 부분을 갖추고 있습니다: 렉시컬 문법과 표준 라이브러리. 프로그래밍 언어 문법은 프로그래머들을 위해 예약된 키워드와 특별한 ASCII 문자를 사용하여 독특한 프로그래밍 구문을 구축합니다.\n","ogImage":{"url":"/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png"},"coverImage":"/assets/img/2024-06-22-JavaScriptFeaturesThatMostDevelopersDontKnow_0.png","tag":["Tech"],"readingTime":1},{"title":"우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-TheFront-EndDevelopmentwereusedtoisdying","content":"\n\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png)\n\n# 소개\n\nSPA가 등장하기 전에 웹 애플리케이션은 일반적으로 다중 페이지로 이루어져 있었습니다. 사용자가 애플리케이션과 상호 작용할 때마다 서버가 새로운 전체 페이지를 보내고 브라우저가 다시로드하는 방식이었습니다. 사용자가 페이지 간을 이동할 때마다 완전한 페이지 재로드가 발생했고, 이로 인해 속도가 느려지고 부자연스러운 사용자 경험이 발생할 수 있었습니다. 비슷한 애플리케이션들은 주로 PHP, Ruby on Rails, ASP.NET 등과 같은 서버 측 기술을 사용하여 구축되었는데, 이들은 서버 측에서 HTML 코드를 생성하여 브라우저로 보냈습니다.\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발자들은 만능 전문가였어요. 그들은 프론트엔드와 백엔드 부분을 동시에 책임지고 있었어요. 웹 기술의 발전과 사용자의 요구에 따라, 문제없이 상호작용 인터페이스로 작업할 수 있는 새로운 솔루션이 필요했죠.\n\n그래서 BackboneJs나 AngularJs를 사용한 SPA의 최초 솔루션이 나타났어요. 그것들은 서버 부하를 줄이고 상호작용을 제공함으로써 서버의 제한된 자원을 고려한 적이 없는 웹 페이지와 함께 새로운 페이지를 기다리지 않아도 됐답니다.\n\n이렇게 프론트엔드와 백엔드 부분으로의 분리가 나타났어요. 순수한 프론트엔드 개발자의 역할은 더욱 필요하고 다양해졌어요. 그들은 사용자 인터페이스 생성, HTML, CSS, JavaScript와 상호작용하는 API 및 서버와 작업하는 기술을 전문화하기 시작했어요. 그 반대로 백엔드 개발자들은 데이터 처리, 응용 프로그램 비즈니스 로직, 데이터베이스와 서버 API 생성에 더 집중했어요.\n\n그래서 React, Angular2, Vue 및 기타 웹 애플리케이션 개발 도구 시대로 진입했어요. 단순한 양식과 목록을 만드는 대신, js-routing, 상태 관리, 브라우저 API, 요청에 권한 토큰 바인딩, 데이터 매핑 등의 작업이 가능해졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식의 결과로 문제점이 발생했습니다:\n\n- 커뮤니케이션과 조정에 대한 어려움. Api 계약 및 통신 방법 — HTTP 1.1, Websocket, GraphQL. JSON 파싱과 유효성 검사.\n- 이해와 지식의 차이. 예를 들어, 여러 쿼리를 생성하는 프론트엔드 애플리케이션을 개발하고 일반적 및 최적화된 SPA로 간주할 수 있습니다. 그러나 백엔드에서는 데이터베이스 액세스가 많이 필요하고 이 데이터의 적절한 집계가 필요하므로 성능 및 유지 관리에 영향을 줄 수 있습니다.\n- 작업의 중복. 대부분의 CRUD 작업은 프론트엔드에서 동일한 동작을 가졌습니다. 이제 단순히 서버에서 목록을 가져오는 것이 아니라 store()에 넣었습니다. 각 사용자 작업은 dispatch()를 통해 처리되고 요청이 실행되기를 기다리며, 그 후에 결과에 따라 reducer()를 통해 store를 업데이트합니다. — 데이터베이스에서 백엔드가 수행하는 모든 작업을 프론트엔드에서 반복합니다. (페이지 다시로드 및 서버에서 현재 상태로 SPA를 복원하는 것도 언급할 가치가 있습니다 — 현재 별도의 고통입니다)\n- 디버깅 및 테스트의 어려움. 이제 가능한 통합 문제를 고려하고 응용 프로그램의 양쪽 컨텍스트에서 테스트해야 합니다. 네, 프론트엔드 애플리케이션에 대해 격리된 e2e-tests을 만들 수 있지만 제품 생산성을 보장할 수 없습니다. 네, ZoD가 서버 응답을 유효성 검사하기 위한 것이 있지만, 그 사용 비율은 얼마나 되는지요?\n- 개발 시간 및 비용 증가. API 계약에 대한 변경 사항은 동시에 두 명의 사람이 필요합니다. 서버로 직접 템플릿을 변경할 수 없습니다. 변경을 원활히 수행하려면 럴리를 필요로하고, 개별 작업으로 분할되며, 비즈니스 분석 전문가 등등이 필요합니다.\n- SEO. 우리 앱은 JS를 통해 완전히 형성되므로 검색 엔진은 앱 콘텐츠와 적절히 인덱싱 및 내비게이션 할 수 없기 때문에 SSR 및 SSG 솔루션이 필요했습니다.\n- 보안. 페이지에 입력된 모든 중요 데이터는 서버로 전달되기 전에 숨겨야 합니다. 또한 애플리케이션을 위해 서버로부터 많은 개인 정보를 요청해야하므로 액세스 토큰이 공개됩니다.\n\n# 그래서, 왜 보통의 프론트엔드가 사라지고 있는 걸까요?\n\n어떤 리소스로 가든 공고가 얼마나 많이 열려 있는지 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Python + Django\n- PHP + Laravel\n- NextJs + React\n- Nuxt + Vue\n\n이것들은 모두 서버 기반 웹 애플리케이션 개발을 위한 번들입니다. 수분화와 재개성 접근 방식 덕분에 서버는 페이지를 다시로드하지 않고 인터페이스의 수정된 부분만 렌더링할 수 있습니다.\n\n그들이 제공하는 것들:\n\n- 이제 서버 애플리케이션은 복잡한 HTTP 또는 WS 계약이 필요하지 않으며 양쪽에서 지원해야 하는 것들을 사용하지 않아도 됩니다. gRPC와 같은 다른 서비스와의 정보 교환에 대해 더 나은 방법을 사용할 수 있게 됩니다.\n- 변경 사항을 만드는 과정이 중간 승인 없이 빨라져 1명의 사람이 사용자가 바로 변화를 볼 수 있습니다.\n- 테스트를 통해 애플리케이션을 종합적으로 확인할 수 있어 통합 테스트를 없애고 오류를 줄일 수 있습니다.\n- HTML 마크업만 교환하므로 모든 \"요청-응답\" 로직이 사용자에게 숨겨집니다.\n- SPA를 올바른 상태로 복원하기 위해 JSON으로 많은 데이터를 전달할 필요가 없습니다. 이미 준비된 템플릿을 전달할 수 있습니다.\n- 페이지의 JS 코드가 최소화되므로 babel 및 기타 도구를 사용하여 브라우저 호환성에 대해 걱정할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노코드 솔루션의 등장, 인공지능을 활용한 템플릿 생성, 거대한 서버 자원, 그리고 SEO 요구사항으로 인해 현재는 프론트엔드 개발자 수와 도구들이 전체 애플리케이션을 개발하는 데 필요하지 않은 상황입니다.\n\n사업주들은 타당한 질문을 하고 있습니다. \"왜 단순한 애플리케이션을 개발하려면 순수한 프론트엔드 개발자와 백엔드 개발자를 고용해야 하죠?\"\n\n풀스택 개발자는 인력 비용을 절약하는 관리 쇼파로 여겨질 수 없습니다. 지금은 필수적인 존재입니다. 순수한 프론트엔드 개발자가 아니라, 데이터베이스에서 직접 간단한 작업을 수행하고 결과를 표시할 수 있는 개발자가 필요합니다.\n\n그렇습니다, 복잡하거나 헤드리스 애플리케이션은 프론트엔드와 백엔드를 분리해서 사용해야 할 것입니다. 그러나 대부분의 애플리케이션은 SPA에서 멀어져가고 이미 존재했던 방식으로 나아가게 될 것입니다. 지금은 그러한 문제들에 대한 해결책이 있습니다. HTMX의 등장으로 어떤 백엔드 개발자도 기본 지식만 있으면 웹 애플리케이션을 만들 수 있습니다. 이제는 조금의 논리를 사용하여 싱글 페이지 앱을 만들 때 심지어 JS를 알 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞단 개발자는 JS 로직 뿐만 아니라 CSS 및 적절한 선택자, HTML 및 그 의미론에도 책임이 있었는데, 이제 백엔드 개발자가 그것을 알아야 할까요? — 아니요, 이제는 인공지능 또는 \"HTML 레이아웃 디자이너\"가 Figma 레이아웃을 기반으로 템플릿 생성을 처리할 수 있습니다. HTML 템플릿의 로직과 상호작용은 이제 서버에서 정의됩니다.\n\n# 결론\n\n지금은 모든 이러한 정교한 프론트엔드 개발 도구가 실제로 필요한지, 순수한 프론트엔드 개발자로 남아야 할지를 고민할 때입니다.\n\n현재의 프론트엔드 개발자들이 60% 프론트엔드, 40% 백엔드로 분할된 풀스택 자격으로 이동해야 하는 것이 바람직합니다. HTMX는 시작에 불과하며, NextJs 또는 Nuxt 도구를 향한 벡터가 성장할 것이며, Angular 유형의 프레임워크는 새로운 구현에 적응할 수 없다면 죽을 것입니다. 물론 Angular 생태계에는 이미 AnalogJs에서 프로토타입이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원\n\n\"프론트 엔드 개발자\" 역할로 취업 정보 검색\n\n\"풀 스택 개발자\" 역할로 취업 정보 검색","ogImage":{"url":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png"},"coverImage":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png","tag":["Tech"],"readingTime":5},{"title":"이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode","content":"\n\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png)\n\nHow common is this?\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_1.png)\n\nIt’s yet another instance where we want a value that depends on whether or not there’s an exception.\n","ogImage":{"url":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png"},"coverImage":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png","tag":["Tech"],"readingTime":1},{"title":"ES8에서 가장 혁신적인 자바스크립트 기능 5가지","description":"","date":"2024-06-22 05:19","slug":"2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8","content":"\n\n\n![ES8](/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png)\n\nES8는 우리가 JavaScript를 작성하는 방식을 변화시키는 귀중한 기능으로 가득 찼습니다.\n\n코드가 더 깔끔해지고 작성하기 쉬워지며 새로운 기능이 추가되었습니다.\n\n지금 그것들을 확인해보고 놓친 것들을 확인해보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 트레일링 쉼표","ogImage":{"url":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png"},"coverImage":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png","tag":["Tech"],"readingTime":1},{"title":"모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술","description":"","date":"2024-06-22 05:16","slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\" /\u003e\n\n자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\n\n## 1. `var` 대신 `let` 및 `const` 사용하기\n\n문제: `var`은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 블록 스코프를 갖는 `let`과 `const`를 사용하세요.\n\n```js\nlet count = 0;\nconst PI = 3.14;\n```\n\n`let`과 `const`를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\n\n## 2. 기본 매개변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\n\n해결책: 기본 매개변수를 사용하여 대안 값 설정.\n\n```js\nfunction greet(name = '방문자') {\nreturn `안녕하세요, ${name}님!`;\n}\nconsole.log(greet()); // \"안녕하세요, 방문자님!\"\n```\n\n기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 템플릿 리터럴\n\n문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\n\n해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\n\n```js\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, John!\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\n\n## 4. 비구조화 할당\n\n문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\n\n해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane', age: 25 };\nconst { name, age } = user;\nconsole.log(name, age); // \"Jane\" 25\n```\n\n구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\n\n## 5. 화살표 함수\n\n문제: 기존 함수 표현식은 장황할 수 있고 `this`를 렉시컬하게 바인딩하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 `this`를 활용하세요.\n\n```js\nconst add = (a, b) =\u003e a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 `this`가 렉시컬하게 바인딩되어 있는지 보장합니다.\n\n## 6. 전개 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\n\n```js\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = […arr1, …arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n```\n\n전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 나머지 매개변수\n\n문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\n\n해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\n\n```js\nfunction sum(…args) {\nreturn args.reduce((total, num) =\u003e total + num, 0);\n}\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\n\n## 8. 단락 평가\n\n문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\n\n해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst isLoggedIn = true;\nconst user = isLoggedIn \u0026\u0026 { name: 'Jane', age: 25 };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n단축 평가는 논리적 `\u0026\u0026` 및 `||` 연산자를 사용하여 조건식을 간단하게 만듭니다.\n\n## 9. 선택적 체이닝\n\n문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 `null` 또는 `undefined`인 경우 오류를 발생시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\n\n```js\nconst user = { profile: { name: 'Jane' } };\nconst userName = user?.profile?.name;\nconsole.log(userName); // \"Jane\"\n```\n\n선택적 체이닝을 사용하면 `null` 또는 `undefined`인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\n\n## 10. 널리쉬 콜리싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: `||`를 사용하여 기본 값을 제공하는 경우, 값이 `0` 또는 `\"\"`이면 예상치 못한 결과가 발생할 수 있습니다.\n\n해결책: `nullish coalescing` (`??`)을 사용하여 `null` 또는 `undefined`일 때만 기본 값을 제공합니다.\n\n```js\nconst user = { name: '', age: 0 };\nconst userName = user.name ?? '익명';\nconst userAge = user.age ?? 18;\nconsole.log(userName); // \"\"\nconsole.log(userAge); // 0\n```\n\n`Nullish coalescing`은 왼쪽 피연산자가 `null` 또는 `undefined`일 때에만 기본 값을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 11. 객체 속성 축약\n\n문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\n\n해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\n\n```js\nconst name = 'Jane';\nconst age = 25;\nconst user = { name, age };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\n\n## 12. 동적 프로퍼티 이름\n\n문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\n\n해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst propName = '나이';\nconst user = { 이름: '제인', [propName]: 25 };\nconsole.log(user); // { 이름: '제인', 나이: 25 }\n```\n\n계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\n\n## 13. 배열 `map()`, `filter()`, 및 `reduce()`\n\n문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 일반적인 배열 작업에 `map()`, `filter()`, 및 `reduce()`를 사용하세요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num =\u003e num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(num =\u003e num % 2 === 0);\nconsole.log(evens); // [2, 4]\nconst sum = numbers.reduce((total, num) =\u003e total + num, 0);\nconsole.log(sum); // 15\n```\n\n이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\n\n## 14. 문자열 `includes()`, `startsWith()`, 및 `endsWith()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\n\n해결책: 더 간단한 문자열 확인을 위해 `includes()`, `startsWith()`, `endsWith()`를 사용하세요.\n\n```js\nconst str = 'Hello, world!';\nconsole.log(str.includes('world')); // true\nconsole.log(str.startsWith('Hello')); // true\nconsole.log(str.endsWith('!')); // true\n```\n\n이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 15. 함수 매개변수에서 배열 및 객체 비구조화\n\n문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\n\n해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\n\n```js\nconst user = { name: 'Jane', age: 25 };\nfunction greet({ name, age }) {\n    return `안녕, ${name}! 당신은 ${age}살 입니다.`;\n}\nconsole.log(greet(user)); // \"안녕, Jane! 당신은 25살 입니다.\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\n\n## 16. 구조 분해에서 기본값 활용\n\n문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\n\n해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane' };\nconst { name, age = 18 } = user;\nconsole.log(name); // \"Jane\"\nconsole.log(age); // 18\n```\n\n구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\n\n## 17. Object `assign()`\n\n문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `Object.assign()`을 사용하여 객체를 복제하거나 병합할 수 있습니다.\n\n```js\nconst target = { a: 1 };\nconst source = { b: 2 };\nconst merged = Object.assign(target, source);\nconsole.log(merged); // { a: 1, b: 2 }\n```\n\n`Object.assign()`을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\n\n## 18. Array `find()` 및 `findIndex()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\n\n해결책: 더 가독성있는 코드를 위해 `find()`와 `findIndex()`를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nconst user = users.find(u =\u003e u.id === 1);\nconsole.log(user); // { id: 1, name: 'Jane' }\nconst index = users.findIndex(u =\u003e u.id === 1);\nconsole.log(index); // 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\n\n## 19. 배열 `some()` 및 `every()`\n\n문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `some()` 및 `every()`를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num =\u003e num % 2 === 0);\nconsole.log(hasEven); // true\nconst allEven = numbers.every(num =\u003e num % 2 === 0);\nconsole.log(allEven); // false\n```\n\n이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\n\n## 20. 배열 `flat()` 및 `flatMap()`\n\n문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: 더 읽기 쉬운 코드를 위해 `flat()` 및 `flatMap()`을 사용하세요.\n\n```js\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(2);\nconsole.log(flat); // [1, 2, 3, [4]]\nconst mapped = [1, 2, 3].flatMap(x =\u003e [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n```\n\n이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\n\n## 21. Array `from()` and `of()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `Array.from()` 및 `Array.of()`를 사용하세요.\n\n```js\nconst set = new Set([1, 2, 3]);\nconst arrFromSet = Array.from(set);\nconsole.log(arrFromSet); // [1, 2, 3]\nconst arrOfNumbers = Array.of(1, 2, 3);\nconsole.log(arrOfNumbers); // [1, 2, 3]\n```\n\n`Array.from()`은 이터러블 객체에서 배열을 만들 수 있고, `Array.of()`은 인수 목록에서 배열을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 22. 콜백에서 파라미터 구조 분해\n\n문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nusers.forEach(({ id, name }) =\u003e {\nconsole.log(`User ID: ${id}, User Name: ${name}`);\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\n\n## 23. 선택적 콜백 함수\n\n문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\n\n해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction fetchData(url, callback) {\n    fetch(url)\n    .then(response =\u003e response.json())\n    .then(data =\u003e {\n        callback \u0026\u0026 callback(data);\n    });\n}\n```\n\n단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\n\n## 24. 콜백을 프로미스로 변환하기\n\n문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\n\n```js\nfunction promisify(fn) {\nreturn function (…args) {\nreturn new Promise((resolve, reject) =\u003e {\nfn(…args, (err, result) =\u003e {\nif (err) reject(err);\nelse resolve(result);\n});\n});\n};\n}\nconst readFile = promisify(require('fs').readFile);\nreadFile('path/to/file.txt', 'utf8')\n.then(data =\u003e console.log(data))\n.catch(err =\u003e console.error(err));\n```\n\n프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\n\n## 25. 동기적인 코드를 위한 Async/Await\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\n\n해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\n\n```js\nasync function fetchData(url) {\ntry {\nconst response = await fetch(url);\nconst data = await response.json();\nconsole.log(data);\n} catch (error) {\nconsole.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n}\n}\nfetchData('https://api.example.com/data');\n```\n\nAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 26. Promises 연쇄하기\n\n문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\n\n해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\n\n```js\nfetch('https://api.example.com/data')\n.then(response =\u003e response.json())\n.then(data =\u003e {\n    console.log('데이터:', data);\n    return fetch('https://api.example.com/more-data');\n})\n.then(response =\u003e response.json())\n.then(moreData =\u003e {\n    console.log('더 많은 데이터:', moreData);\n})\n.catch(error =\u003e {\n    console.error('에러:', error);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.**\n\n## 27. 동시 실행을 위한 Promise.all\n\n문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\n\n해결책: `Promise.all`을 사용하여 동시에 비동기 작업을 처리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst fetchData1 = fetch('https://api.example.com/data1').then(response =\u003e response.json());\nconst fetchData2 = fetch('https://api.example.com/data2').then(response =\u003e response.json());\nPromise.all([fetchData1, fetchData2])\n.then(([data1, data2]) =\u003e {\nconsole.log('Data 1:', data1);\nconsole.log('Data 2:', data2);\n})\n.catch(error =\u003e {\nconsole.error('Error:', error);\n});\n```\n\n`Promise.all`을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\n\n## 28. 디바운스 함수\n\n문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\n\n```js\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =\u003e func.apply(this, args), wait);\n  };\n}\nwindow.addEventListener('resize', debounce(() =\u003e {\n  console.log('창 크기 조정됨');\n}, 200));\n```\n\ndebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\n\n## 29. 스로틀 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\n\n해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\n\n```js\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n  return function (...args) {\n    if (!lastRan) {\n      func.apply(this, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() =\u003e {\n        if (Date.now() - lastRan \u003e= limit) {\n          func.apply(this, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() =\u003e {\n  console.log('창 스크롤됨');\n}, 200));\n```\n\n스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 30. 객체의 깊은 복제\n\n문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\n\n해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\n\n```js\nconst obj = { a: 1, b: { c: 2 } };\nconst deepClone = JSON.parse(JSON.stringify(obj));\nconsole.log(deepClone); // { a: 1, b: { c: 2 } }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\n\n## 31. 메모이제이션\n\n문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\n\n해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction memoize(func) {\nconst cache = new Map();\nreturn function (...args) {\nconst key = JSON.stringify(args);\nif (cache.has(key)) {\nreturn cache.get(key);\n}\nconst result = func.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\nconst expensiveFunction = memoize((num) =\u003e {\nconsole.log('계산 중…');\nreturn num * 2;\n});\nconsole.log(expensiveFunction(2)); // \"계산 중…\" 4\nconsole.log(expensiveFunction(2)); // 4\n```\n\n메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\n\n## 32. 함수 커링\n\n문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\n\n```js\nfunction curry(func) {\nreturn function curried(…args) {\nif (args.length \u003e= func.length) {\nreturn func.apply(this, args);\n}\nreturn function (…nextArgs) {\nreturn curried.apply(this, args.concat(nextArgs));\n};\n};\n}\nconst sum = (a, b, c) =\u003e a + b + c;\nconst curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\n```\n\n커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\n\n## 33. 부분 적용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\n\n해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\n\n```js\nfunction partial(func, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn func(...presetArgs, ...laterArgs);\n};\n}\nconst multiply = (a, b, c) =\u003e a * b * c;\nconst double = partial(multiply, 2);\nconsole.log(double(3, 4)); // 24\n```\n\n부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n34. 함수 합성\n\n문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\n\n```js\nconst compose = (…funcs) =\u003e (arg) =\u003e\nfuncs.reduceRight((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\n\n## 35. 함수 파이프라이닝\n\n문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\n\n해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst pipe = (...funcs) =\u003e (arg) =\u003e\nfuncs.reduce((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = pipe(add, multiply);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\n\n## 36. 스스로 호출하는 함수\n\n문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\n\n```js\n(function () {\nconsole.log('즉시 실행됩니다!');\n})();\n```\nIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\n\n## 37. 전역 변수 사용을 피하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\n\n해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\n\n```js\n// 지역 변수 사용\nfunction doSomething() {\n    let localVariable = '지역 변수입니다';\n    console.log(localVariable);\n}\n// 모듈 사용\nconst myModule = (function () {\n    let privateVariable = '비공개 변수입니다';\n    return {\n        publicMethod() {\n            console.log(privateVariable);\n        },\n    };\n})();\nmyModule.publicMethod(); // \"비공개 변수입니다\"\n```\n\n전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 38. 클로저를 사용한 캡슐화\n\n문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\n\n해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\n\n```js\nfunction createCounter() {\nlet count = 0;\nreturn {\nincrement() {\ncount++;\nreturn count;\n},\ndecrement() {\ncount--;\nreturn count;\n},\n};\n}\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\n\n## 39. 모듈 패턴\n\n문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\n\n해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst myModule = (function () {\nlet privateVariable = 'This is private';\nfunction privateMethod() {\nconsole.log(privateVariable);\n}\nreturn {\npublicMethod() {\nprivateMethod();\n},\n};\n})();\nmyModule.publicMethod(); // \"This is private\"\n```\n\n모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\n\n## 40. 싱글톤 패턴\n\n문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\n\n```js\nconst singleton = (function () {\nlet instance;\nfunction createInstance() {\nreturn {\nname: '싱글톤 인스턴스',\n};\n}\nreturn {\ngetInstance() {\nif (!instance) {\ninstance = createInstance();\n}\nreturn instance;\n},\n};\n})();\nconst instance1 = singleton.getInstance();\nconst instance2 = singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n```\n\n싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\n\n## 41. 팩토리 패턴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\n\n해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\n\n```js\nfunction createUser(name, role) {\nreturn {\nname,\nrole,\nsayHello() {\nconsole.log(`안녕하세요, 제 이름은 ${this.name}이고 ${this.role}입니다.`);\n},\n};\n}\nconst admin = createUser('Alice', 'admin');\nconst user = createUser('Bob', 'user');\nadmin.sayHello(); // \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\nuser.sayHello(); // \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\n```\n\n팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 42. 관찰자 패턴\n\n문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\n\n해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\n\n```js\nfunction Subject() {\nthis.observers = [];\n}\nSubject.prototype = {\nsubscribe(observer) {\nthis.observers.push(observer);\n},\nunsubscribe(observer) {\nthis.observers = this.observers.filter((obs) =\u003e obs !== observer);\n},\nnotify(data) {\nthis.observers.forEach((observer) =\u003e observer.update(data));\n},\n};\nfunction Observer(name) {\nthis.name = name;\n}\nObserver.prototype.update = function (data) {\nconsole.log(`${this.name} received data: ${data}`);\n};\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('새로운 데이터 이용 가능'); // \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\n\n## 43. 이벤트 위임\n\n문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\n\n해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndocument.getElementById('parent').addEventListener('click', (event) =\u003e {\nif (event.target \u0026\u0026 event.target.matches('button.className')) {\nconsole.log('Button clicked:', event.target.textContent);\n}\n});\n```\n\n이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\n\n## 44. `eval()` 사용 피하기\n\n문제: `eval()` 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `eval()`을 사용하지 말고 더 안전한 대안을 사용하세요.\n\n```js\n// 피하십시오\nconst code = 'console.log(\"Hello, world!\")';\neval(code); // \"Hello, world!\"\n// 더 안전한 대안 사용\nconst func = new Function('console.log(\"Hello, world!\")');\nfunc(); // \"Hello, world!\"\n```\n\n`eval()`을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\n\n## 45. `for…of`를 사용하여 반복하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\n\n해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nfor (const value of arr) {\nconsole.log(value);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n`for...of`는 간단하고 안전한 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":21},{"title":"React와 TailwindCSS로 반응형 NavBar 만드는 방법","description":"","date":"2024-06-22 05:04","slug":"2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS","content":"\n\n현재의 모바일 중심 세상에서는 반응형 디자인을 만들고 이를 구현하는 것이 모든 기기에서 원활한 사용자 경험을 제공하는 데 필수적입니다. \n오늘은 내비게이션 바에 반응 형성을 어떻게 구현할 수 있는지에 대해 이야기하겠습니다.\n\n1- NavBar.tsx 라는 컴포넌트를 생성하세요 (이 튜토리얼에서 TypeScript를 사용할 것입니다).\n\n2- 더 큰 화면에 대한 NavBar 세부 정보를 구현하십시오. 간단하게 말해서, 이것들은 nav를 플렉스 컨테이너로 만들고 그 안에 웹 사이트 로고, 정렬되지 않은 목록 및 오른쪽에 버튼이 있을 것입니다.\n\n```jsx\n  \u003cnav className=\"flexBetween max-container padding-container relative z-30 py-5\"\u003e\n      \u003cLink href=\"/\"\u003e\n        \u003cImage src=\"/hilink-logo.svg\" alt=\"logo\" width={74} height={29} /\u003e\n      \u003c/Link\u003e\n      \u003cul className=\"hidden h-full gap-12 lg:flex\"\u003e\n        {NAV_LINKS.map((link) =\u003e (\n          \u003cLink\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          \u003e\n            {link.label}\n          \u003c/Link\u003e\n        ))}\n      \u003c/ul\u003e\n\n      \u003cdiv className=\"lg:flexCenter hidden\"\u003e\n        \u003cButton\n          type=\"button\"\n          title=\"Login\"\n          icon=\"/user.svg\"\n          variant=\"btn_dark_green\"\n        /\u003e\n      \u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서, nav 태그에는 단순히 (flex items-center justify-between)인 flexBetween 특수 css 클래스가 있습니다. 이 컨테이너의 첫 번째 아이템은 로고이고, 그 다음은 웹 사이트 루트로의 내비게이션 링크가 있는 비순서 목록이며, 마지막으로 버튼이 있습니다.\n\n3- 작은 화면을 위한 내비게이션 구현하기.\n이제, 1024px보다 작은 화면에는 내비게이션이 없을 것임을 알았습니다 (lg:는 콜론 뒤에 넣은 클래스명이 대형 화면 및 이상에서만 사용된다는 의미입니다).\n\n작은 화면에는 햄버거 아이콘을 넣을 것입니다.\n\n![해당 이미지](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 작은 화면용 내비게이션을 넣기 위해 이 버튼이 클릭될 때 언제 체크해야 합니다.\n그를 위해:\n\n```js\nconst [isOpen, setIsOpen] = useState(false);\nconst changeIsOpen = () =\u003e {\n setIsOpen(!isOpen);\n};\nuseEffect(() =\u003e {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n또한 isOpen 상태 변화를 모니터링하기 위해 useEffect 훅을 사용할 수 있습니다:\n\n```js\nuseEffect(() =\u003e {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4- IsOpen 변수 및 changeIsOpen 함수 사용하기\n\n```js\n{isOpen \u0026\u0026 \u003cNavSmallScreen changeIsOpen={changeIsOpen}/\u003e}\n\n\u003cImage\n    src=\"menu.svg\"\n    alt=\"menu\"\n    width={32}\n    height={32}\n    className=\"inline-block cursor-pointer lg:hidden\"\n    onClick={changeIsOpen}\n```\n\n5- NavSmallScreen 컴포넌트 구현하기\n\n그다음으로 NavSmallScreen 컴포넌트를 만들겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {NAV_LINKS} from \"@/constants\";\nimport Link from \"next/link\";\nimport Image from \"next/image\";\n\nfunction NavSmallScreen({changeIsOpen}: {changeIsOpen: () =\u003e void}) {\n  return (\n    \u003cdiv\n      className=\"flex flex-col items-center min-w-[70vw] z-[105] p-10 h-full w-full fixed left-0 top-0 opacity-90 bg-black  backdrop-blur-md rounded-lg\"\u003e\n      \u003cul\n        className=\"flex flex-col items-center justify-center gap-10 text-xl h-full \"\u003e\n        {NAV_LINKS.map((link) =\u003e (\n          \u003cLink\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          \u003e\n            {link.label}\n          \u003c/Link\u003e\n        ))}\n\n        \u003cImage\n          src=\"close.svg\"\n          alt=\"menu\"\n          width={32}\n          height={32}\n          className=\"inline-block cursor-pointer lg:hidden\"\n          onClick={changeIsOpen}\n        /\u003e\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default NavSmallScreen;\r\n```\n\n![Responsive Navbar](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_1.png)\n\n저희는 부모 컴포넌트에서 changeIsOpen 함수를 자식 컴포넌트로 전달하고, 이 함수를 클릭시 닫기 아이콘(X)에 사용합니다. 그래서 메뉴가 닫힙니다.\n\n이 게시물을 읽어 주셔서 감사합니다. 여러분의 반응형 목표를 달성하는데 도움이 되었으면 좋겠습니다! 즐거운 하루 되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub repository 에서 소스 코드를 확인할 수 있습니다.\n[이 곳](https://github.com/egemenc21/camptraveler/blob/main/components/Navbar.tsx)에서 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png"},"coverImage":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png","tag":["Tech"],"readingTime":4}],"page":"17","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"17"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>