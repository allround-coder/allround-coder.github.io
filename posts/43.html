<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/43" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/43" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" href="/post/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" href="/post/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" href="/post/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" href="/post/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" href="/post/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 공부 순수하고 불량한" href="/post/2024-06-20-JavascriptattheNunneryPureUndefiled"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 공부 순수하고 불량한" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 공부 순수하고 불량한" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 공부 순수하고 불량한</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기" href="/post/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CDK 중첩 스택 - 왜와 어떻게" href="/post/2024-06-20-CDKNestedStacksTheWhyandHow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CDK 중첩 스택 - 왜와 어떻게" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CDK 중첩 스택 - 왜와 어떻게" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CDK 중첩 스택 - 왜와 어떻게</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드" href="/post/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쉬운 125번 유효한 회문" href="/post/2024-06-20-Easy125ValidPalindrome"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쉬운 125번 유효한 회문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Easy125ValidPalindrome_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쉬운 125번 유효한 회문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">쉬운 125번 유효한 회문</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link posts_-active__YVJEi" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기","description":"","date":"2024-06-20 02:54","slug":"2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm","content":"\n\n![image](/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png)\n\nAngular은 동적 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 새 프로젝트를 시작하거나 복잡한 폼을 디자인하더라도, Angular은 개발을 간소화하는 강력한 도구와 기능을 제공합니다. 본 문서에서는 새 Angular 프로젝트를 생성하고 샘플 폼을 디자인하는 방법을 안내해 드립니다.\n\n# 1. Angular CLI 설치\n\nAngular CLI (Command Line Interface)는 Angular 프로젝트를 관리하는 강력한 도구입니다. Angular CLI를 설치하려면 다음 명령어를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install -g @angular/cli\n```\n\n# 2. 새로운 Angular 프로젝트 생성하기\n\nCLI를 사용하여 새로운 Angular 프로젝트를 만들어보세요. 이 작업은 프로젝트 구조와 구성 파일을 자동으로 설정해줍니다.\n\n```js\nng new my-angular-app\ncd my-angular-app\nng serve\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령 시퀀스를 사용하세요:\n\n1. 새 Angular 프로젝트를 'my-angular-app'이라는 이름으로 초기화합니다.\n2. 프로젝트 디렉토리로 이동합니다.\n3. 개발 서버를 시작하여 애플리케이션을 http://localhost:4200에서 접근할 수 있도록 합니다.\n\n## 3. 새 컴포넌트 생성\n\n새로운 폼을 처리할 컴포넌트를 생성합니다. 컴포넌트는 Angular 애플리케이션의 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate component sample-form\n```\n\n이 명령어는 필요한 파일(HTML, CSS, TypeScript 및 테스트를 위한 spec)과 함께 새 컴포넌트를 생성합니다.\n\n# 4. 샘플 폼 디자인하기\n\n생성된 컴포넌트의 HTML 파일을 열고 Angular의 폼 지시문을 사용하여 폼을 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# sample-form.component.html #\n\u003cdiv class=\"container\"\u003e\n  \u003ch2\u003e샘플 양식\u003c/h2\u003e\n  \u003cform (ngSubmit)=\"onSubmit()\" #form=\"ngForm\"\u003e\n    \u003cdiv class=\"form-group\"\u003e\n      \u003clabel for=\"name\"\u003e이름:\u003c/label\u003e\n      \u003cinput type=\"text\" id=\"name\" class=\"form-control\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"\u003e\n      \u003cdiv *ngIf=\"name.invalid \u0026\u0026 name.touched\" class=\"alert alert-danger\"\u003e\n        이름을 입력해주세요.\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"form-group\"\u003e\n      \u003clabel for=\"email\"\u003e이메일:\u003c/label\u003e\n      \u003cinput type=\"email\" id=\"email\" class=\"form-control\" required [(ngModel)]=\"model.email\" name=\"email\" #email=\"ngModel\"\u003e\n      \u003cdiv *ngIf=\"email.invalid \u0026\u0026 email.touched\" class=\"alert alert-danger\"\u003e\n        유효한 이메일을 입력해주세요.\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"submit\" class=\"btn btn-primary\" [disabled]=\"form.invalid\"\u003e제출\u003c/button\u003e\n  \u003c/form\u003e\n\u003c/div\u003e\n```\n\n이 예제에서:\n\n- 이름과 이메일에 대한 두 개의 입력 필드가 만들어졌습니다. 둘 다 필수 입력 항목입니다.\n- Angular의 ngModel 지시문을 통해 양방향 데이터 바인딩이 이루어졌습니다.\n- 필드가 유효하지 않거나 사용자가 터치한 경우 유효성 검사 메시지가 표시됩니다.\n- 제출 버튼을 클릭하면 onSubmit 메서드를 통해 양식이 제출됩니다.\n\n# 5. 양식 제출 처리하기 #\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// sample-form.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-sample-form',\n  templateUrl: './sample-form.component.html',\n  styleUrls: ['./sample-form.component.css']\n})\nexport class SampleFormComponent {\n  model: any = {};\n\n  onSubmit() {\n    console.log('Form submitted!', this.model);\n  }\n}\n```\n\n여기 예제에서:\n\n- 모델 객체가 정의되어서 폼 데이터를 저장합니다.\n- `onSubmit` 메서드는 폼 제출 시 콘솔에 폼 데이터를 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAngular CLI와 폼 디렉티브를 사용하여 새 Angular 프로젝트를 생성하고 폼을 디자인하는 것은 간단합니다. Angular는 폼 처리와 유효성 검사에 강력한 도구를 제공하여 동적이고 반응적인 웹 애플리케이션을 구축하기 쉽게 만듭니다. 이러한 단계를 따라하면 빠르게 새 Angular 프로젝트를 설정하고 쉽게 복잡한 폼을 디자인할 수 있습니다.\n\n독자 여러분, 읽어주셔서 감사합니다! 궁금한 점, 생각 또는 피드백이 있으시면 아래 댓글을 남겨주시기 바랍니다. 여러분의 참여와 지원은 웹 개발에서 Angular의 가능성을 계속 탐구하는 데 큰 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png"},"coverImage":"/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기","description":"","date":"2024-06-20 02:53","slug":"2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload","content":"\n\n이 이야기는 몇 년 전에 썼던 것과 매우 비슷한 내용입니다. 그 이야기는 여러 파일을 업로드하는 진행 막대를 구현하는 것과 관련이 있었습니다. 각 파일의 업로드를 추적하는 데 사용되는 진행 막대가 1개 있었습니다.\n\n이 이야기에서는 Node Express 서버에서 5000개의 객체를 포함하는 photos.json 파일을 다운로드합니다.\n\n![이미지](/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png)\n\n아래는 애플리케이션의 간단한 데모입니다. Chrome 개발 도구를 사용하여 느린 3G 연결을 시뮬레이션하여 파일 다운로드가 천천히 진행되는 것을 볼 수 있습니다. 나중에는 추가적인 npm 모듈을 설치하지 않고 시스템에 파일을 다운로드하는 코드 작성 방법을 안내하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode Server 프로젝트\n\n![이미지](/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_1.png)\n\nindex.js\n\n위 파일에 설정된 \"Content-Length\" 응답 헤더에 유의해주세요. 이 헤더는 프로그레스 바를 구현하는 중요한 단계입니다. 이 헤더는 Angular 애플리케이션에게 받을 데이터의 총 크기를 알려줌으로써 프로그레스 바를 구현하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Content-Disposition\" 응답 헤더는 콘텐츠가 브라우저에서 인라인으로 표시되는지(Web 페이지 또는 웹 페이지의 일부로) 아니면 첨부 파일로 다운로드되어 로컬에 저장되는지를 나타내는 헤더입니다.\n\n우리는 콘텐츠가 \"photos.json\"이라는 파일로 다운로드되기를 원합니다.\n\nAngular 프로젝트\n\nAngular 프로젝트에는 AppComponent와 ProgressComponent 두 개의 컴포넌트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터를 가져오기 위해 노드 서버와 연결하는 FileDownloadService라는 단일 서비스를 가지고 있습니다.\n\nAppComponent 템플릿\n\n`app-progress`는 ProgressComponent를 위한 셀렉터입니다. 이미지 업로드 진행률을 @Input('ratio')로 ProgressComponent에 전달하고 있습니다. 업로드 진행률은 downloadprogressRatio$ observable을 구독하여 async 파이프를 통해 @Input('ratio')로 전달됩니다.\n\n```js\n\u003ch4\u003eDownloading\u003c/h4\u003e\n\u003capp-progress [ratio]=”downloadprogressRatio$|async”\u003e\u003c/app-progress\u003e\n\u003cbutton (click)=”download()”\u003eDownload JSON\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“Download JSON” 버튼을 클릭하면, 해당 클래스에서 download()을 호출하게 됩니다.\n\nAppComponent 클래스\n\n- downloadProgressRatio$는 observable입니다. 우리는 FileDownloadService에서 반환된 getDownloadingProgress()의 observable을 downloadProgressRatio$ observable에 할당합니다. 이 observable은 템플릿에서 async 파이프를 통해 구독됩니다.\n\n```js\n\u003capp-progress [ratio]=”downloadprogressRatio$|async”\u003e\u003c/app-progress\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 템플릿의 \"다운로드\" 버튼을 클릭하면, 해당 클래스의 download()이 호출되며, 이 메서드는 FileDownloadService의 downloadJson()을 호출합니다.\n\nFileDownloadService\n\n- downloadingProgressSub는 각 파일의 다운로드 진행 상황을 컴포넌트에 실시간 업데이트해 주는 중요한 역할을 하는 Subject입니다.\n- 이미 클래스의 ngOnInit()에서 getDownloadingProgress()가 호출되었음을 확인했습니다. 이 메서드는 해당 Subject에 대한 Observable을 반환하는 역할을 합니다.\n\n```js\ngetDownloadingProgress(){\n    return this.downloadingProgressSub.asObservable();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. \"Download JSON\" 버튼을 클릭하면 downloadJson() 함수가 호출됩니다. 우리는 Node 서버에서 photos.json을 가져오기 위해 GET 요청을 보냅니다.\n\n```js\ndownloadJson()\n{\nreturn this.http.get(`${environment.baseUrl}photos`,{reportProgress:true,observe:'events'}).pipe(\n  tap((response:any)=\u003e{\n    if(response.type==HttpEventType.DownloadProgress){ //3\n      this.setDownloadingProgress(response.loaded/response.total);\n    }\n    else if(response.type === HttpEventType.Response){\n      let blob = new Blob([JSON.stringify(response.body)]);\n      this.downloadBlob(response,blob);\n    }\n  }),\n  catchError(err=\u003e{\n    return throwError(err)\n  })\n)\n}\n```\n\n4. HTTP GET 요청에 전달되는 추가 옵션을 관찰해주세요.\n\n```js\nthis.http.get(`${environment.baseUrl}photos`,{reportProgress:true,observe:’events’})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 다운로드 진행 상황에 대한 피드백을 제공하여 사용자들에게 더 나은 경험을 제공하고 있습니다. 우리는 진행 상황 추적을 가능하게 하기 위해 reportProgress를 true로 설정했습니다.\n\nobserve 값은 관찰하고자 하는 내용에 따라 반환 유형을 결정합니다. \"events\"의 observe 값은 기본적으로 진행 상황 이벤트를 포함한 HttpEvent 스트림의 observable을 반환합니다.\n\n5. 서버로부터 데이터를 받기 때문에, HttpEvent의 유형은 DownloadProgress(UploadProgress가 아님)일 것입니다.\n\n```js\nif(event.type==HttpEventType.DownloadProgress){ //3\nthis.setDownloadingProgress(event.loaded/event.total);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nevent.load은 로드된 파일의 바이트 수입니다.\n\nevent.total은 로드해야하는 전체 바이트 수입니다.\n\nevent.load/event.total은 업로드 중인 파일의 진행률을 나타냅니다.\n\n저희는 setDownloadingProgress()를 호출하여 진행률을 인수로 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsetDownloadingProgress(data: any) {\n    this.downloadingProgressSub.next(data);\n}\n```\n\nsetDownloadingProgress() 메서드에서는 진행률 비율을 downloadingProgressSub Subject로 전달하고 있습니다.\n\nAppComponent 템플릿에서 이 Subject에 async pipe를 통해 구독하고 있다는 것을 기억하시나요?\n\n6. Node 서버로부터 본문을 포함한 전체 응답을 받으면, HttpEvent는 Response 유형이 됩니다. 그런 다음 응답 본문에서 Blob 객체를 생성하고 이 blob 객체 및 HttpResponse를 downloadBlob() 메서드에 인수로 전달합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nelse if(response.type === HttpEventType.Response){\nlet blob = new Blob([JSON.stringify(response.body)]);\nthis.downloadBlob(response, blob);\n}\n```\n\n7. Inside the `downloadBlob()`, we have written a common logic to perform automatic download of file received.\n\n```js\ndownloadBlob(response: any, blob: Blob){\n\nlet substringA = response.headers.get('content-disposition').substring(response.headers.get('content-disposition').indexOf(\";\") + 1);\nlet filename = substringA.substring(substringA.indexOf(\"=\") + 1).replace(/[\"\"]/g, \"\");\nlet link = document.createElement('a');\nlink.download = filename;\nlink.href = URL.createObjectURL(blob);\nlink.click();\n}\n```\n\nWe are first extracting the filename from the Content-Disposition response header.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet substringA=response.headers.get('content-disposition').substring(response.headers.get('content-disposition').indexOf(\";\")+1);\nlet filename= substringA.substring(substringA.indexOf(\"=\")+1).replace(/[“”]+/g,\"\");\n```\n\n이것이 Content-Disposition 헤더가 보이는 모습입니다.\n\n다음으로 앵커 요소인 `a`를 생성하고 요소의 다운로드 및 href 속성을 설정합니다. 다운로드 속성은 파일 이름으로 설정됩니다. href 속성은 Blob 객체에 대해 생성된 객체 URL로 설정됩니다. Blob는 createObjectURL()을 사용하여 내용을 보여주기 위해 `a`, `img` 또는 다른 태그를 사용할 수 있습니다.\n\n```js\nlet link = document.createElement('a');\nlink.download = filename;\nlink.href = URL.createObjectURL(blob);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 앵커 요소를 프로그래밍 방식으로 클릭하여 다운로드가 자동으로 시작되도록 합니다. 우리는 앵커 요소를 DOM에 첨부하고 싶지 않습니다.\n\n```js\nlink.click();\n```\n\nProgressComponent 템플릿\n\n```js\n\u003cdiv class=”container pending”\u003e\n\u003cdiv class=”progress-container” [ngClass]=”ratio === 1 ? ‘complete’ : ‘pending’”\u003e\n\u003cdiv [ngStyle]=”{width:progress}”\u003e\n\u003c/div\u003e\n\u003cdiv class=”progress-message”\u003e{progress}\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"complete\" 및 \"pending\" CSS 클래스는 아래와 같이 정의되어 있습니다:\n\n```js\n.complete {\n  background-color: lightgreen;\n}\n.pending {\n  background-color: rgb(243, 111, 111);\n}\n```\n\nProgressComponent 클래스\n\n이 클래스는 AppComponent로부터 속성 바인딩을 통해 @Input('ratio')를 수신합니다. 우리는 이 비율에 100을 곱하여 백분율을 얻은 다음 가장 가까운 정수로 반올림합니다. 이 백분율을 사용하여 진행 막대의 너비를 조정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 앵귤러 및 노드 프로젝트의 git 저장소입니다.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n- 작가를 클릭하고 팔로우해주시면 감사하겠습니다! 👏\n- 우리를 팔로우하세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 방문해주세요: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png","tag":["Tech"],"readingTime":7},{"title":"앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성","description":"","date":"2024-06-20 02:51","slug":"2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024","content":"\n\nAngular은 개발 커뮤니티에서 필수적인 프레임워크로 자리매김했습니다. GitHub에서 26만 개의 스타를 획득한 Angular은 개발자들에게 중요한 도구로 자리를 굳혀가고 있습니다. Angular은 범용 해법, 최적의 방법, 그리고 포괄적인 안내를 제공하여, 프론트엔드 개발자들에게 필수적인 도구로 자리매김하고 있습니다.\n\n파헤치기 전에 약간의 스포일러: 주요 내용 요약\n\nAngular은 싱글 페이지 애플리케이션 (SPA) 개발에 큰 영향을 미치는 다목적 TypeScript 기반 웹 애플리케이션 프레임워크입니다. 이 프레임워크는 효율적인 변경 탐지 시스템, 상태 변경 관리를 위한 Zones 사용, 그리고 Model-View-ViewModel (MVVM) 아키텍처로 유명합니다.\n\n주요 핵심내용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular의 역할: Angular은 현대 웹 개발에 필수적입니다.\n- 커뮤니티 주도의 로드맵: 모든 전문 지식 수준을 위한 구조화된 지침이 제공됩니다.\n- 기본 지식: 웹 기술과 TypeScript에 대한 튼튼한 이해가 필요합니다.\n- Angular CLI: 이 도구는 개발 프로세스를 간소화합니다.\n- 핵심 개념: 디렉티브, 반응형 폼, 의존성 주입 및 HTTP 클라이언트가 중요합니다.\n\n2024년 Angular 로드맵\n\nAngular는 개발자들의 요구를 충족시키기 위해 지속적으로 발전하며 다재다능한 프레임워크로 자리 잡았습니다. 고유한 변경 감지 메커니즘과 Zones의 사용은 성능 효율성과 반응형 사용자 인터페이스를 보장합니다. MVVM 아키텍처를 통해 SPA를 효과적으로 구축하고 상호 작용할 수 있습니다.\n\n주요 구성 요소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 변경 감지: Angular의 시스템은 가상 DOM 접근 방식과는 다르며, 성능과 응답성에 초점을 맞춥니다.\n- Zones: 원활한 사용자 경험을 보장하기 위해 비동기 작업을 관리합니다.\n- MVVM 아키텍처: SPA 개발에 견고한 기반을 제공합니다.\n\nAngular 로드맵 시작하기!\n\nAngular를 시작하려면 기본적인 웹 기술과 TypeScript를 시작으로 핵심 원리와 도구에 대한 꼼꼼한 이해가 필요합니다.\n\nAngular에 꼭 필요한 TypeScript의 핵심 개념\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구조적 타이핑: 유연한 데이터 관리를 위한 기능입니다.\n- 타입 인터페이스: 복잡한 타입 구조를 정의하고 재사용합니다.\n- 유니언 타입: 타입 정의에 다양성을 추가합니다.\n- 내장 타입: 일관된 데이터 처리를 보장합니다.\n- 타입 가드 및 제네릭: 안전한 코드 조합을 가능하게 합니다.\n- 데코레이터: 클래스 선언에 메타데이터와 로직을 추가합니다.\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png)\n\n프로젝트 부트스트래핑을 위한 Angular CLI 활용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular CLI는 프로젝트 설정 및 관리를 간단하게 해주며, 다음과 같은 명령어를 통해 생산성을 향상시킵니다:\n\n- 프로젝트 초기화\n- 모듈, 컴포넌트, 서비스 생성\n- 애플리케이션 빌드, 서빙, 컴파일\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'''HTML, CSS 및 핵심 JavaScript으로 기초 다지기'''\n\n앵귤러를 숙달하려면 HTML, CSS 및 JavaScript에 능숙해져야 합니다. 이들은 앵귤러 구조의 기본 구성 요소입니다:\n\n- HTML: 웹 콘텐츠의 의미론적 구조.\n- CSS: 응답 및 매력적인 인터페이스를 위한 스타일링.\n- JavaScript: 웹 애플리케이션의 동적 처리.\n\n예:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Angular](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_2.png)\n\n## Angular Roadmap의 핵심 개념 및 모범 사례\n\n각 지시자(directives), 반응형 폼(reactive forms), 의존성 주입(dependency injection), 그리고 HTTP 클라이언트 등 Angular의 핵심 개념을 이해하는 것은 효율적이고 확장 가능한 애플리케이션을 만드는 데 필수적입니다.\n\n- 지시자(directives): HTML 기능 확장\n- 반응형 폼(reactive forms): 복잡한 데이터 입력을 위한 모델 주도 접근 방식\n- 의존성 주입(dependency injection): 모듈화 및 단위 테스트 단순화\n- HTTP 클라이언트: 외부 API와의 통신 처리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 아래는 요청하신 내용에 대한 한국어 번역입니다.\n\n지시문 예시:\n\n- 구조 지시문: *ngFor, *ngIf\n- 속성 지시문: [ngStyle], [ngClass]\n\nAngular의 고급 기능 및 기술\n\n모듈화, 지연 로딩, 변경 감지 전략 및 서버 측 렌더링 (SSR)과 같은 고급 기능은 고성능 애플리케이션 구축에 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모듈 및 Lazy Loading: 시작 성능을 향상시킵니다.\n- 변경 감지 전략: 성능을 최적화합니다.\n- SSR용 Angular Universal: SEO 및 접근성을 개선합니다.\n\n예: Lazy Loading\n\n```typescript\nconst routes: Routes = [\n  { path: 'feature', loadChildren: () =\u003e import('./feature/feature.module').then(m =\u003e m.FeatureModule) }\n];\n```\n\n신생 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기계 학습(ML), 인공 지능(AI) 및 블록체인의 통합은 Angular의 기능을 변화시키고 성능과 적응성을 향상시키고 있습니다.\n\n- ML 및 AI: 적응형 물리학 및 예측 모델링.\n- 블록체인: 탈중앙화된 컴퓨팅 및 자산 상호 운용성.","ogImage":{"url":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png"},"coverImage":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png","tag":["Tech"],"readingTime":4},{"title":"제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요","description":"","date":"2024-06-20 02:47","slug":"2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference","content":"\n\n거의 10년 전에 Java 개발자로서 경력을 시작했고, 여전히 변수를 끊임없이 타이핑했던 기억이 나네요! TypeScript로 전향한 후에는 타입 추론에 의존하기 시작했습니다. 이 언어 기능을 넘어서 이를 이해하고 있고, 이 덕분에 일상적으로 많은 키 스트로크를 절약하고 있어요.\n\n명시적 추론을 사용할 수 있다는 것을 깨달았을 때 기쁜 충격을 받았어요. 한 줄로 배열과 반환 타입을 추출할 수 있다는 것이죠!\n\n첫 번째 스키마 라이브러리를 배운 후에 엄청난 획기가 왔어요.\n\n스키마 작성을 마스터한 뒤에는 말로써 일석이조였죠. 런타임에서 수신 데이터를 구문 분석하고 추론된 유형을 컴파일 타임에 사용할 수 있었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 발견으로 내 생산성이 향상되었어요. 이로 인해 더 빨리 프로젝트를 완료할 수 있었거든.\n\n왜 빠른 배송이 중요한가요?\n\n경쟁사보다 빨라야 한다고 얘기하는 사람도 있죠...\n\n빠르게 배송하지 않고 꾸준히 하지 않으면, 엔지니어링 프로세스에 문제가 있는 것이라고 볼 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png)\n\n위의 그림 속 핸들을 잡고 있는 사람은 배의 엔지니어링에 대해 의심하고 있는 걸까요?\n\n생산성 향상은 다음과 같은 개념에서 비롯되었습니다.\n\n파싱을 프로젝트의 핵심 요소로 취급하고 계약 프로그래밍을 강제 적용하기 시작했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 각 수신 구조를 구문 분석하면 데이터 처리가 시작되기 전에 보안 계층을 도입합니다. 유명한 속담을 바꿔 말하면, 수신 데이터를 테스트하지 않으면 결국 클라이언트가 테스트하게 될 것입니다!\n\n둘째로, 이는 또한 생산 중에 발생할 수 있는 버그의 수를 줄이며, 실행 시 오류를 컴파일 타입 오류로 대체합니다. 컴파일 할 수 없는 프로젝트를 배포해서는 안 됩니다!\n\n세 번째로, 적절한 애플리케이션 모니터링을 통해 구문 분석 오류(PPI를 고려함)를 오류 수집기로 보낼 수 있습니다. 문제가 발생한 위치를 이해하면 피드백 루프를 단축시킬 수 있습니다. 클라이언트가 문제를 알기 전에 문제에 대해 알고 싶습니다.\n\n마지막으로, LLM을 사용하여 스키마를 더 빨리 작성할 수 있습니다. 다시 말해, 인공지능을 습득한 사람들은 아마도 그렇지 않은 사람들의 직업을 대체할 것입니다. 이야기 끝에 별도의 섹션에서 LLM 사용에 대해 논의하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이야기를 써서 생산성을 향상시키는 발견을 설명했어요. 제 경험에서 배우고, 현재와 미래 프로젝트에 적용해 보세요!\n\n이야기에서 제시된 모든 코드 조각은 Bun 1.1.12에서 코딩하고 테스트했어요.\n\n# 스키마 라이브러리 선택\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택은 어려운 결정이죠.\n\n최근 몇 년 동안 다양한 스키마 라이브러리를 사용해봤는데, 특히 Zod, @effect/schema, 그리고 Yup을 주로 사용했어요. 이들은 일반적인 유효성 검증과 파싱에 사용할 때 거의 구별하기 어렵지만, 브랜드 타입이나 숫자 범위를 정의할 때 차이가 나타날 수 있어요.\n\n소프트웨어 엔지니어는 작업에 적합한 도구를 선택해야 해요. 함수형 프로그래밍에 대한 좋은 지원이 필요하다면, 불변성을 보장하고 모나드 구조를 지원하는 @effect/schema가 가장 적합할 거예요.\n\n최소한의 종속성을 유지하고 싶다면, 아무 종속성도 없는 Zod을 선호할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 언급된 라이브러리에 대한 동등한 코드를 제시하겠습니다.\n\n다음 명령어를 사용하여 이들을 설치할 수 있습니다:\n\n```js\nbun install @effect/schema yup zod\n```\n\n## 구문 분석이 검증을 이기는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제대로 시작하기 전에 TypeScript의 구조적 타이핑과 유효성 검사 및 구문 분석에 미치는 영향을 언급해야 합니다.\n\n두 타입을 비교할 때 컴파일러는 이름을 무시하고 속성 타입만 확인합니다. 예를 들어 다음 타입은 동일하다고 간주됩니다:\n\n```js\ntype User = { id: string };\ntype Company = { id: string };\n```\n\nTypeScript를 사용하기 시작할 때는 명백하지 않을 수 있지만, 더 많은 경험을 쌓으면 감이 올 것입니다. 그러나 객체 리터럴 주변에 더 많은 유의해야 할 점이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n타입 변수를 초기화할 때 컴파일러는 초과 속성에 대한 검사를 실행합니다. 우리는 이 할당의 오른쪽을 오브젝트 리터럴이라고 공식적으로 부릅니다. 다음 스니펫은 컴파일되지 않습니다:\n\n```js\nconst user: User = {\n  id: '1',\n  name: 'test username',\n};\n```\n\n저는 이 언어 기능의 이유에 동의합니다. 선택한 타입을 준수하지 않는다면 타입 변수를 지정하지 않는 것이 좋습니다. 이게 합리적으로 느껴지시나요?\n\n다음 스니펫에서 확인할 수 있듯이 함수에 오브젝트 인자를 전달할 때 초과 속성 검사는 작동하지 않습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  test: 1,\n};\n\nconst canAccessDashboard = (user: User) =\u003e (user.claims \u0026 0x01) !== 0;\n\ncanAccessDashboard(userWithExcessProperties);\n```\n\n프로그램은 함수를 통해 데이터가 흐르는 단순한 흐름입니다. 데이터를 구문 분석하면 반복적으로 함수에 전달됩니다. 이제 데이터를 구문 분석해야 하는 이유에 대해 설명하겠습니다.\n\n구조를 검증할 때는 해당 스키마에 적합한지만 확인합니다. 유효성 검사는 새 객체를 생성하지 않습니다. TypeScript에서 원본 구조를 함수에 전달할 때 초과된 속성도 함께 전달될 수 있습니다.\n\n로그에 사용자 데이터를 기록하면 개인 식별 정보를 저장할 수 있습니다! 그래서 그것을 피하기 위해 원하는 속성을 갖는 새 객체를 만들어 데이터를 구문 분석해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_2.png\" /\u003e\n\n# 추론\n\n스키마 라이브러리를 사용하여 한 방에 두 마리의 새를 잡고 싶어요. 어떤 API에든 딱 붙어보이지만 그 대신에 어떤 데이터든 수월하게 파싱하고 컴파일러에 대한 형식을 얻고 싶어요.\n\nZod를 사용하여 사용자 스키마를 작성하려면 아래 코드를 작성할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport z, { ZodType } from 'zod';\n\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  claims: z.number(),\n}).readonly();\r\n```\n\n이제 사용자 유형을 추론하겠습니다:\n\n```js\r\ntype User = z.infer\u003ctypeof userSchema\u003e;\r\n```\n\n이 문장은 다음 코드의 달신이 되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n유저 타입을 호출할 때 다음 메소드를 이용하여 구문 분석할 거에요:\n\nconst user: User = userSchema.parse(userWithExcessProperties);\n\n사용자들을 그룹화하고 싶다고 상상해 보세요. 그룹 스키마와 해당 유형을 비슷하게 작성할 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high')\n    ]),\n  })).readonly(),\n}).readonly();\n\ntype Group = z.infer\u003ctypeof groupSchema\u003e;\r\n\n## 추이추론\n\n별도의 변수로 스키마를 추출하지 않고 관심 수준 유형을 추출하는 방법은 무엇인가요?\n\nTypeScript 유형 메커니즘을 활용하여 다음과 같이 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntype InterestLevel = Group['interests'][number]['level'];\n\n만약 제가 스키마를 별도로 사용하지 않는다면, 제 다른 비즈니스 구조의 일부로 유지합니다.\n\n덧붙여, 최소 추론 규칙을 만들었습니다. 이미 추론한 타입이 있는 경우, 그 하위 타입을 추출하기 위해 다시 추론해서는 안 된다는 것입니다!\n\n## 일반 추론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 좀 더 고급 추론 패턴을 보여드릴게요. 이를 \"일반 추론\"이라고 부르겠어요.\n\n임의의 데이터와 그들의 체크섬을 포함하는 구조를 구문 분석해야 한다고 상상해봅시다. 우리는 이러한 구조를 보통 봉투(envelope)라고 부릅니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_3.png)\n\n그래서 우리는 일반 빌더 함수를 작성할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: ZodType\u003cT\u003e\n) =\u003e z.object({\n  datum: datumSchema,\n  checksum: z.string(),\n}).readonly();\n\n위의 코드 조각에서 `ZodType\u003cT\u003e`는 일반 타입 T로 구문 분석되는 스키마입니다.\n\n만약 사용자 및 그룹 스키마와 타입을 필요로 한다면, 다음과 같이 타입을 지정할 수 있습니다:\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = z.infer\u003ctypeof userEnvelopeSchema\u003e;\ntype GroupChecksumEnvelope = z.infer\u003ctypeof groupEnvelopeSchema\u003e;\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 우리가 일반적인 envelope 타입을 유지하고 싶다면 어떻게 할까요? 우리는 이를 사용하여 내용을 정확히 모르는 임의의 envelopes에 작업을 수행할 수 있습니다. 예를 들어, 체크섬을 계산하는 것과 같이요.\n\ntype ChecksumEnvelope\u003cT\u003e = z.infer\u003c\n  ReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n\n## 단수 schema\n\n스키마를 사용할 때, 저는 단수 구조만을 정의하는 것을 선호합니다. 예를 들어, 다음과 같이 작성하지 않겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst usersSchema = z.array(userSchema);\ntype Users = z.infer\u003ctypeof usersSchema\u003e;\n\n가능하다면 복수형 타입을 정의하지 않겠어요. 배열에는 `ReadonlyArray\u003cUser\u003e`나 `User[]`를 사용할 거에요. 혼란을 피하고 다른 명명 규칙을 만들지 않기 위해 가능한 한 타입 별칭을 적게 사용하려고 해요.\n\n## 내보내기\n\n일반적으로 schema와 비즈니스 구조체의 유추된 타입을 내보내요. 다른 개발자들이 혼란스럽지 않도록 helper schema를 절대 내보내지 않아요. 가져올 수 있는 문장을 줄이기 위해 노력해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 불변성\n\n저는 불변성의 충실한 지지자입니다.\n\n새로운 변수를 생성할 때만 데이터가 변경되므로 코드를 분석하기가 더 쉽다고 생각합니다. 제 스키마는 불변성을 일등 시민 개념으로 취급하길 원합니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불변성을 사용하는 것은 프로그래밍 언어의 규칙을 제한하기 위해 사슬을 사용하는 것과 같습니다. 깨지기 쉬운 링크만 깨뜨리면 됩니다. 저희 경우에는 스키마가 그런 링크일 수 있습니다.\n\nZod 스키마를 불변하게 만들기 위해 readonly 메서드를 호출합니다. Zod는 자동으로 불변의 추론된 유형을 생성합니다.\n\n예를 들어, 아래에 명시된 것처럼 그룹 스키마는 이미 불변성 원칙을 준수합니다:\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high'),\n    ]),\n  })).readonly(),\n}).readonly();\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 추론된 타입을 준수하는 인스턴스를 생성할 때 불변성에서 일시적으로 벗어나고 싶다면 어떻게 해야 할까요?\n\n해당 readonly 수정자를 무효화하는 타입을 사용해야 합니다. 일부 스키마에는 충분하지 않을 수도 있습니다. ReadonlyArray 타입을 가변으로 만들려면 어떻게 해야 할까요? 그리고 ReadonlySet은 어떻게 해야 할까요? ReadonlyMap은요?\n\n우리는 많은 실수를 저지르지 말고 전용 라이브러리를 사용해야 합니다. 예를 들어, ts-essentials 라이브러리와 많은 다른 라이브러리가 관련된 타입을 포함하고 있습니다.\n\n다음 명령어를 입력하여 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nbun install ts-essentials\n\n이제 아래의 코드를 작성할 수 있습니다:\n\nimport type { DeepWritable } from ‘ts-essentials’;\n\ntype WritableGroup = DeepWritable\u003cGroup\u003e;\n\n# Enumerations\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZod에서 열거형을 정의하는 세 가지 방법이 있습니다:\n\n- 네이티브 열거형 사용\n- Zod의 리터럴 유니언 사용\n- Zod의 열거형 사용\n\n각 방법은 적절한 구문 분석과 유추된 유형을 제공합니다. 차이점은 열거된 모든 값을 액세스하는 데 있습니다.\n\n예를 들어, 언어 목록이 있다면 사용자의 선택을 유효성 검사하고 목록을 프론트 엔드에 전송하여 드롭다운에서 표시해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_5.png\" /\u003e\n\n## 네이티브 열거\n\nTypeScript를 사용하면 컴파일 시에 존재하고 런타임에도 존재하는 열거형(enum) 타입을 선언할 수 있습니다. 예를 들어, 다음과 같이 관심 수준을 나타내는 enum을 정의할 수 있습니다:\n\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n};\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZod는 열거 유형에서 스키마를 작성하는 방법을 제공합니다. 아래 코드 스니펫에서와 같이:\n\nconst interestLevelSchema = z.nativeEnum(InterestLevel);\n\n만약 const 키워드로 InterestLevel 열거 유형을 선언했다면, 이전에는 컴파일 시간에만 존재했기 때문에 Zod 도우미를 사용할 수 없었습니다.\n\n열거된 모든 값을 추출하려면 다음 코드를 작성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevels = Object.values(InterestLevel);\n\n## Zod의 리터럴 유니언\n\n다른 패턴을 사용하여 열거 스키마를 정의할 수 있습니다. 결국, 열거는 문자열 또는 숫자 리터럴의 유니언입니다.\n\n각 관심 수준 리터럴에 대한 스키마를 작성해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevelLiteralSchemata = [\n  z.literal('low'),\n  z.literal('medium'),\n  z.literal('high'),\n] as const;\n\n자 이제 적절한 스키마와 타입을 정의할 시간입니다:\n\nconst interestLevelSchema = z.union(interestLevelLiteralSchemata);\ntype InterestLevel = z.infer\u003ctypeof interestLevelSchema\u003e;\n\n마지막으로, 모든 열거된 값을 추출할 수 있습니다:  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevels = interestLevelLiteralSchemata\n  .map((literal) =\u003e literal.value);\n\n## 조드의 열거\n\n열거 스키마를 정의하는 내가 가장 좋아하는 방법은 조드의 열거 도우미를 사용하는 것입니다.\n\n다음과 같은 방법으로 스키마를 작성하고 타입을 추론할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevelSchema = z.enum(['low', 'medium', 'high']);\ntype InterestLevel = z.infer\u003ctypeof interestLevelSchema\u003e;\n\n모든 열거된 값 추출을 한 줄로 처리할 수 있습니다:\n\nconst interestLevels = interestLevelSchema.options;\n\n# 구분된 연합(Unions)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 유니언 타입에서는 컴파일러가 많은 서로 다른 타입을 구분합니다. 디스크리미네이트 유니언에서는 컴파일러가 공유 프로퍼티를 기준으로 구분합니다. 예를 들어, 애플리케이션의 작업을 특정 액터인 사용자 또는 그룹에 할당할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_6.png)\n\n제가 액터 스키마를 구현하고 다음과 같이 타입을 추론할 것입니다:\n\n```js\nconst userActorSchema = z.object({\n  type: z.literal('user'),\n  id: z.string(),\n});\n\nconst groupActorSchema = z.object({\n  type: z.literal('group'),\n  id: z.string(),\n});\n\nconst actorSchema = z.discriminatedUnion(\n  \"type\",\n  [userActorSchema, groupActorSchema],\n).readonly();\n\ntype Actor = z.infer\u003ctypeof actorSchema\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 선택에는 설명이 필요해요!\n\n먼저, 사용자와 그룹 액터의 스키마를 명시적으로 정의했어요. 이 방법은 구분된 연합의 각 구성 요소를 명명하고 들여쓰기 수준을 낮게 유지하죠.\n\n누군가 액터 스키마를 읽으면, 여러 줄로 이루어진 스키마를 읽지 않아도 내 의도를 즉시 추측할 거에요!\n\n둘째, 액터 유형을 스키마에서 추론했어요. 코드 베이스에서 연합 유형의 연산이 멤버 대신 발생하기를 기대하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째로, 나는 사용자의 종류와 그룹 활동자의 유형을 추론하지 않았어. 나중에 그들을 정의해야 한다면, 다음 패턴을 사용하여 그렇게 할 수 있을 것 같아:\n\n```js\ntype UserActor1 = z.infer\u003ctypeof userActorSchema\u003e;\ntype UserActor2 = Extract\u003cActor, { type: 'user' }\u003e;\ntype UserActor3 = Actor \u0026 { type: 'user' };\n```\n\n각각이 동일한 결과를 가져오는 것에도 불구하고, 나는 첫 번째 것을 사용하지 않을 거야. 왜냐하면 그것은 최소한 추론 규칙에 어긋나기 때문이야. 이미 활동자 유형을 추론을 통해 얻었다면 TypeScript 유형 도우미를 사용하여 더 정확한 유형을 추출할 수 있어.\n\n그리고 discriminatedUnion 메서드를 사용하여 식별 속성의 이름을 명시해야 하는 이유를 궁금해할 수도 있어. 일치시켜야 할 내용을 알면 Zod가 적합한 스키마를 빠르게 찾을 수 있어. 이러한 최적화를 피하고 싶다면 union 도우미를 사용할 수도 있었겠지.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기존 유형 변환\n\n기존 TypeScript 프로젝트에는 많은 유형이 포함되어 있을 것입니다. 이를 수동으로 작성하는 것은 여러분의 시간을 낭비하는 일입니다. 대신 LLM 또는 코드 완성 도구를 사용할 수 있습니다. 정확한 법적 조언은 제공하지 않겠지만, 소유 코드베이스에서 이러한 기술을 사용할 수 있는지 항상 확인합니다.\n\n각 LLM 제공업체는 모델에 제공하는 데이터에 대해 무엇이 발생하는지 알려줄 것입니다!\n\n특정 LLM을 추천하지는 않겠지만, 주요 모델들이 이 문제를 상당히 잘 처리합니다. 유형을 정의하고 스키마 정의를 시작해보세요. 몇 번 시도한 후에는 고품질 자동완성 스키마가 나올 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM을 완전히 믿지 마세요. 항상 결과를 검증해야 합니다!\n\n다양한 유형이 있다면, 먼저 그들의 정규 표현을 얻는 것을 추천합니다. AST 추출기를 작성하거나 TypeScript Language Server에 요청하여 이를 수행하거나, LLM이 작업을 처리하도록 할 수 있습니다. 처음 두 가지 가능성에 대해 LLM을 사용할 수 있습니다!\n\n정규 표현을 구문 분석하여 스키마를 생성하는 스크립트를 작성할 수 있습니다. 가장 큰 어려움은 스키마를 생성하는 것이 아니라 구문 분석에 사용하는 것입니다. 프로젝트 아키텍처의 완전한 변경이 필요할 수도 있습니다!\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n나는 스키마와 유형 추론을 사용하는 것에 대한 설득력있는 주장을 펼쳤기를 희망합니다, 특히 LLMs와 함께. 아니라면, 의견을 남겨주세요! 다양한 기술적 주제에 대해 토론하는 것을 좋아합니다.\n\n가장 중요한 포인트를 되풀이하자면, 데이터를 단순히 유효성 검사하는 것이 아니라 파싱해야 한다고 생각합니다. 우리는 스키마를 작성하고 그로부터 유형을 추론해야 합니다. 나는 불변성을 지지하며 이 패러다임을 준수하는 스키마를 선호합니다. 또한 열거 유형 대신 스키마 리터럴을 사용하는 것을 좋아합니다.\n\n나는 내 코드가 파싱되지 않은 데이터에서 실행되지 않기 때문에 보다 빠르게 배포할 수 있습니다. 컴파일 시간 오류만 만날 것이라고 믿습니다. 애플리케이션 모니터링 덕분에 파싱이 실패할 때를 알 수 있습니다. 나는 LLM을 사용하여 스키마를 작성하고 유형을 더 빨리 추론할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이야기의 개념을 설명하는 부록을 작성했습니다. 이번에는 다른 스키마 라이브러리를 사용하여 @effect/schema와 yup을 설명합니다.\n\n# 부록 A: @effect/schema\n\n사용자 스키마를 정의하기 위해 다음과 같이 작성해야 합니다:\n\n```js\nimport { Schema } from \"@effect/schema\"\n\nconst userSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  claims: Schema.Number,\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 스키마는 이미 불변성을 준수합니다. 아래 스니펫을 사용하여 사용자 유형을 추론할 수 있습니다:\n\n```js\ntype User = Schema.Schema.Type\u003ctypeof userSchema\u003e;\n```\n\n위의 type helper는 다음 코드와 동일합니다:\n\n```js\ntype User = typeof userSchema.Type;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리는 객체를 구문 분석하고 초과 속성을 허용하지 않습니다. 아래 내용을 확인해주세요:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = Schema.decodeSync(userSchema)(userWithExcessProperties);\n```\n\n그룹 스키마와 해당 유형은 사용자 스키마와 유사하게 정의할 수 있습니다:\n\n```js\nconst groupSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  userIds: Schema.Array(Schema.String),\n  interests: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      level: Schema.Union(\n        Schema.Literal('low'),\n        Schema.Literal('medium'),\n        Schema.Literal('high'),\n      ),\n    })\n  ),\n});\n\ntype Group = Schema.Schema.Type\u003ctypeof groupSchema\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 추론을 달성하기 위해 다음 코드를 작성합니다:\n\n```js\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: Schema.Schema\u003cT\u003e\n) =\u003e Schema.Struct({\n  datum: datumSchema,\n  checksum: Schema.String,\n});\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype ChecksumEnvelope\u003cT\u003e = Schema.Schema.Type\u003c\n  ReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n```\n\n@effect/schema를 사용하여 열거 스키마를 정의하는 세 가지 방법을 찾았습니다.\n\n첫 번째 방법은 리터럴의 합집합을 사용하는 것입니다. 아래 예제를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst interestLevelSchema = Schema.Union(\n  Schema.Literal('low'),\n  Schema.Literal('medium'),\n  Schema.Literal('high'),\n);\n\ntype InterestLevel = Schema.Schema.Type\u003ctypeof interestLevelSchema\u003e;\n```\n\n스키마 속성에 액세스하여 관심 수준 목록을 추출할 수 있습니다. 아래에 나와있는 것처럼:\n\n```js\nconst interestLevels = interestLevelSchema\n  .members\n  .flatMap((member) =\u003e member.literals);\n```\n\n두 번째 접근 방법은 스키마 리터럴 도우미를 사용하는 것입니다. 한 줄로 스키마를 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst interestLevelSchema = Schema.Literal(‘low’, ‘medium’, ‘high’);\n```\n\n우리는 모든 값을 가져 오기위한 한 줄짜리도 사용할 것입니다:\n\n```js\nconst interestLevels = interestLevelSchema.literals;\n```\n\n이 라이브러리를 사용하면 네이티브 열거 유형을 사용할 수 있습니다! 다음 조각을 살펴보세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst interestLevelSchema = Schema.Enums(InterestLevel)\nconst interestLevels = Object.values(InterestLevel);\n```\n\n차별화 된 연합을 정의하는 것이 더 간단하지 않았을 것입니다. 아래 코드 조각을 읽어보세요.\n\n```js\nconst userActorSchema = Schema.Struct({\n  type: Schema.Literal('user'),\n  id: Schema.String,\n});\n\nconst groupActorSchema = Schema.Struct({\n  type: Schema.Literal('group'),\n  id: Schema.String,\n});\n\nconst actorSchema = Schema.Union(userActorSchema, groupActorSchema);\ntype Actor = Schema.Schema.Type\u003ctypeof actorSchema\u003e;\n```\n\n# 부록 B : Yup\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYup을 사용한 사용자 스키마는 다음과 같습니다:\n\n```js\nimport Yup from ‘yup’;\n\nconst userSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  claims: Yup.number().required(),\n}).noUnknown();\n```\n\n이 라이브러리에는 두 가지 주의 사항이 있습니다. 먼저, 필수 도우미를 사용하여 비널 값 받아들이기, 두 번째로 초과 속성을 제외하려면 noUnknown 도우미를 사용해야 합니다.\n\n하지만, 여기에 더 많은 내용이 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추론된 유형에서 스키마를 불변성을 보장하도록 강제하는 방법을 찾지 못했습니다. 다음과 같이 ts-essentials 라이브러리의 DeepReadonly 유형 도우미를 사용해야 했습니다:\n\n```js\ntype User = DeepReadonly\u003cYup.InferType\u003ctypeof userSchema\u003e\u003e;\n```\n\n위의 유형은 다음과 같습니다:\n\n```js\ntype User = DeepReadonly\u003ctypeof userSchema['__outputType']\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도서관은 내가 정의한 구문 분석을 수행하는 validateSync라는 메서드를 제공합니다:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = userSchema.validateSync(userWithExcessProperties);\n```\n\n그룹 스키마를 다음 형식으로 정의하기를 제안합니다:\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst groupSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  userIds: Yup.array(\n    Yup.string().required()\n  ).required(),\n  interests: Yup.array(\n    Yup.object({\n      id: Yup.string().required(),\n      level: Yup.mixed\u003cInterestLevel\u003e()\n        .oneOf(Object.values(InterestLevel))\n        .required(),\n    })\n  ).required(),\n}).noUnknown();\n\ntype Group = DeepReadonly\u003cYup.InferType\u003ctypeof groupSchema\u003e\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 주의깊게 살펴봤다면, 관심 수준을 위한 enum 형식을 볼 수 있었을 것입니다. 곧 enum을 사용하는 이유에 대해 설명할 것입니다.\n\n아래 예제에서 제시된대로 제네릭 추론을 달성할 수 있습니다:\n\n```js\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: Yup.Schema\u003cT\u003e\n) =\u003e Yup.object({\n  datum: datumSchema,\n  checksum: Yup.string().required(),\n}).noUnknown();\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = DeepReadonly\u003c\n  Yup.InferType\u003ctypeof userEnvelopeSchema\u003e\n\u003e;\n\ntype GroupChecksumEnvelope = DeepReadonly\u003c\n  Yup.InferType\u003ctypeof groupEnvelopeSchema\u003e\n\u003e;\n\ntype ChecksumEnvelope\u003cT\u003e = DeepReadonly\u003c\n  Yup.InferType\u003cReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n```\n\n약속한 대로, Yup에서 enum 유형을 사용하는 것이 가장 합리적인 이유를 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 열거형 유형의 스키마를 손쉽게 만들 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed\u003cInterestLevel\u003e()\n  .oneOf(Object.values(InterestLevel))\n  .required();\n```\n\n모든 값을 배열로 먼저 정의해야하는 두 번째 방법도 있습니다:\n\n```js\nconst interestLevels = [\n  'low',\n  'medium',\n  'high',\n] as const;\n\ntype InterestLevel = typeof interestLevels[number];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 한 줄로 스키마를 작성할 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed\u003cInterestLevel\u003e()\n  .oneOf(interestLevels)\n  .required();\n```\n\n여기에는 공용 체계에 대한 스키마를 작성하는 상세한 지침이 있어야 합니다. 유감스럽게도 Yup을 사용하여 지원하는 것을 찾지 못했습니다. 그러나 해결책을 찾았습니다.\n\n스키마 시퀀스가 있는 경우, 각 스키마를 사용하여 객체를 구문 분석하는 함수를 작성하여 일치하는 것을 찾을 때까지 시도할 수 있습니다. 빠르게 작성하는 데 도움이 되는 LLM을 사용할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정된 제한 시간이 초과되어 서비스에 영향을 줄 수 있습니다. 해당 작업에 대한 피드백이 필요하신 경우 언제든지 알려주세요!","ogImage":{"url":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"},"coverImage":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png","tag":["Tech"],"readingTime":19},{"title":"앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기","description":"","date":"2024-06-20 02:46","slug":"2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png\" /\u003e\n\n앵귤러, 인기 있는 자바스크립트 프레임워크로, 개발자에게 강력한 도구를 제공하여 동적이고 대화식 웹 애플리케이션을 만들 수 있게 합니다. 이 중요한 도구 중 하나는 디렉티브입니다. 이 블로그 게시물에서는 앵귤러의 디렉티브에 대해 깊이 있는 내용을 다루고, 그 종류를 탐색하며 사용법을 보여주는 코드 예제를 제공할 것입니다.\n\n# 디렉티브란 무엇인가요?\n\n디렉티브는 HTML을 확장하여 DOM 요소에 사용자 지정 동작을 부여하거나 새 HTML 요소를 생성하는 방법입니다. 이는 앵귤러의 선언적 사용자 인터페이스 구축 방식의 중요한 부분입니다. 디렉티브를 사용하면 DOM을 조작하거나 CSS 스타일을 적용하고 사용자 입력을 처리하는 등 다양한 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지시문의 종류\n\nAngular는 네 가지 종류의 지시문을 제공합니다.\n\n- 컴포넌트 지시문: Angular에서 가장 일반적인 지시문 유형입니다. 컴포넌트는 템플릿이 있는 지시문입니다. 사용자 인터페이스의 일부를 캡슐화하며 종종 연관된 로직을 갖습니다. 재사용 가능한 UI 구성 요소를 만드는 데 사용됩니다.\n- 속성 지시문: 속성 지시문은 요소, 컴포넌트 또는 다른 지시문의 외관 또는 동작을 변경합니다. 일반적으로 HTML 요소의 속성으로 적용됩니다. 예시로는 ngClass, ngStyle 및 ngModel이 있습니다.\n- 구조 지시문: 구조 지시문은 요소를 추가하거나 제거함으로써 DOM 구조를 수정합니다. 가장 잘 알려진 구조 지시문은 ngIf, ngFor 및 ngSwitch입니다.\n- 사용자 정의 지시문: 개발자는 Angular의 기능을 확장하기 위해 사용자 정의 지시문을 생성할 수 있습니다. 사용자 정의 지시문은 속성 지시문, 구조 지시문 또는 둘 다가 될 수 있습니다. 복잡한 동작을 캡슐화하고 코드를 더 모듈화하는 데 유용합니다.\n\n이제 Angular에서 지시문을 사용하는 방법을 이해하기 위한 일부 실용적인 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제 1: ngIf 구조 지시문 사용하기\n\nngIf 지시문은 주어진 표현식에 기반하여 요소를 조건부로 렌더링하는 데 사용됩니다.\n\n```js\n\u003c!-- app.component.html --\u003e\n\n\u003cdiv *ngIf=\"isLoggedIn\"\u003e\n  \u003cp\u003eWelcome, { username }!\u003c/p\u003e\n\u003c/div\u003e\n```\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  isLoggedIn = true;\n  username = 'John';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 isLoggedIn이 true인 경우에만 문단 요소가 렌더링됩니다.\n\n# 예제 2: 최소 글자 수를 위한 커스텀 디렉티브 생성\n\n텍스트 필드에 사용자 입력이 최소 글자 요구 사항을 충족하는지 확인하고 싶다고 상상해보세요. Angular의 커스텀 디렉티브를 사용하여 이를 달성할 수 있습니다. 이를 위해 appMinLength이라는 커스텀 디렉티브를 생성해 봅시다.\n\n## 디렉티브 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에있는 텍스트를 친절한 톤으로 한국어로 번역해 드리겠습니다.\n\n여기 AppMinLength 지시문을 만드는 방법이 있습니다:\n\n```js\n// min-length.directive.ts\nimport { Directive, Input, ElementRef, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[appMinLength]',\n})\nexport class MinLengthDirective {\n  @Input('appMinLength') minLength: number;\n  constructor(private el: ElementRef) {}\n  @HostListener('input') onInput() {\n    const inputValue: string = this.el.nativeElement.value;\n    if (inputValue.length \u003c this.minLength) {\n      this.el.nativeElement.setCustomValidity(`최소 길이는 ${this.minLength}자여야 합니다.`);\n    } else {\n      this.el.nativeElement.setCustomValidity('');\n    }\n  }\n}\n```\n\n이 지시문을 단계별로 이해해 봅시다:\n\n- 우리는 [appMinLength] 선택자를 사용하여 HTML 요소의 속성으로 사용될 것임을 나타내는 MinLengthDirective 라는 사용자 정의 지시문을 정의합니다.\n- @Input('appMinLength') minLength: number; 데코레이터를 사용하여 지시문에 최소 길이를 입력으로 전달할 수 있습니다. 이 길이는 템플릿에서 지시문을 사용할 때 지정됩니다.\n- 생성자에서 ElementRef를 주입하여 지시문이 적용된 DOM 요소에 액세스할 수 있습니다.\n- @HostListener('input') 데코레이터를 사용하여 요소에서 입력 이벤트를 청취합니다. 이 이벤트는 사용자가 입력 필드에 문자를 입력하거나 삭제할 때 트리거됩니다.\n- onInput 메서드 내에서 요소로부터 현재 입력 값을 검색합니다.\n- 입력 값의 길이를 지정된 minLength과 비교합니다. 입력 길이가 필요한 최소값보다 작으면 setCustomValidity를 사용하여 사용자에게 최소 문자 요구 사항을 보여주는 사용자 지정 유효성 메시지를 설정합니다.\n- 입력 길이가 최소 요구 사항을 충족하는 경우 사용자 정의 유효성 메시지를 지웁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 정의 지시문 적용\n\nAngular 컴포넌트 템플릿에서 이 사용자 정의 지시문을 사용하려면 다음과 같이 입력 필드에 속성처럼 적용할 수 있습니다:\n\n```js\n\u003c!-- app.component.html --\u003e\n\n\u003cinput type=\"text\" placeholder=\"텍스트 입력\" [appMinLength]=\"5\" required\u003e\n```\n\n이 예시에서는 입력 필드의 최소 길이를 5글자로 지정했습니다. 사용자가 다섯 글자 미만으로 양식을 제출하려고 시도하면 유효성 검사 오류가 발생하여 입력이 필요한 최소 길이를 충족시키도록 보장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이런 맞춤 지시문을 사용하면 Angular 애플리케이션에서 특정 동작이나 제약 조건을 강제할 수 있어요. 이렇게 하면 요소들 사이의 일관성과 사용성이 향상됩니다.\n\n# 예시 3: ngFor 구조 지시문 사용\n\nngFor 지시문은 컬렉션을 반복하고 각 항목에 대해 요소를 렌더링하는 데 사용됩니다.\n\n```js\n\u003c!-- app.component.html --\u003e\n\u003cul\u003e\n  \u003cli *ngFor=\"let item of items\"\u003e{ item }\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  items = ['Item 1', 'Item 2', 'Item 3'];\n}\n```\n\n이 예제에서는 items 배열의 각 요소마다 목록 항목이 생성됩니다.\n\n# 결론\n\nAngular 디렉티브는 동적이고 상호작용적인 웹 애플리케이션을 만드는 강력한 도구입니다. 이를 사용하여 DOM을 조작하고 요소 렌더링을 제어하고 재사용 가능한 동작을 캡슐화할 수 있습니다. 디렉티브를 이해하고 효과적으로 사용함으로써 유지보수 가능하고 유연한 Angular 애플리케이션을 만들 수 있습니다. 프로젝트에서 디렉티브를 실험해보고 진정한 잠재력을 발견할 수 있을 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 공부 순수하고 불량한","description":"","date":"2024-06-20 02:44","slug":"2024-06-20-JavascriptattheNunneryPureUndefiled","content":"\n\n가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png)\n\n## TLDR;\n\n자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# JavaScript의 문제\n\nJavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.\n\nJavaScript는 그 규칙의 예외입니다.\n\nJavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.\n\n# 커뮤니티의 문제\n\n진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.\n\n거짓말이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.\n\n# 해결책\n\n저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.\n\n## 클래스를 사용하지 않아요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!\n\n다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.\n\n![image](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png)\n\n그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png)\n\n클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.\n\n## 데코레이터는 사용하지 않아요\n\n사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.\n\n이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png)\n\n이 예제에서는 `speak` 함수를 우리의 `uppercase` 및 `emphasize` 데코레이터로 장식하여 `scream` 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 그런데 왜요?\n\n내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.\n\n## 클래스는 상태를 쌓는 경향이 있습니다\n\n이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png)\n\n객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.\n\n이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클래스 테스트하기 어렵습니다\n\n이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.\n\n저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.\n\n테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.\n\n함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 객체는 인지 부담을 줄입니다\n\n사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.\n\n결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.\n\n## 데코레이터는 영원히 함수에 데코레이터를 바인딩합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.\n\nspeak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png)\n\n나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장식자는 난해한 형식에 대한 지식이 필요합니다\n\n다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png\" /\u003e\n\n장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데코레이터들은 이를 필요로 합니다\n\n우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.\n\n저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.\n\n그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 \"잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요\" 입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png","tag":["Tech"],"readingTime":6},{"title":"모바일에서 Playwright와 TypeScript로 자동화 테스팅을 간편하게 하기","description":"","date":"2024-06-20 02:42","slug":"2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript","content":"\n\n\n![Playwright](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png)\n\n플레이 라이트는 모바일 및 웹 애플리케이션을 처리할 수 있는 다재다능한 도구로, 모든 주요 브라우저를 지원합니다. 이 유연성은 개발자와 테스터가 웹 애플리케이션이 다양한 화면 크기와 다른 조명 조건에서 어떻게 보이고 동작할지에 대한 통찰력을 얻을 수 있도록 합니다.\n\nPlaywright에서 모바일 장치 에뮬레이션은 테스트 범위를 크게 확장하지만, 실제 장치에서의 테스트 필요성을 대체하지는 않는다는 점을 기억하는 것이 중요합니다. 에뮬레이션은 사전 점검을 수행하고 애플리케이션이 다양한 장치 구성에 잘 적응하는지 확인하는 편리한 방법을 제공합니다. 그러나 성능 및 특정 하드웨어 상호작용에 대한 포괄적인 테스트, 특히 실제 장치에서의 테스트는 여전히 필수적입니다.\n\nPlaywright의 기능을 활용함으로써 개발 및 QA 팀은 다양한 장치 범주에 걸쳐 더 견고하고 사용자 친화적인 경험을 보장할 수 있으며, 궁극적으로 더 높은 품질의 웹 애플리케이션으로 이끌어 줄 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 목차\n\n- 주요 기능\n- 뷰포트 에뮬레이션\n- 색 구성표 유효성 검사\n- 지리 위치, 시간대, 및 지역 설정\n- 선행 조치\n- 프로젝트 초기화\n- tsconfig.json 생성\n- 테스트 케이스 생성 및 결과\n- 테스트 실행 방법\n- 결론\n\n# ↪️ 주요 기능\n\n# 뷰포트 에뮬레이션:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플레이라이트는 각종 모바일 기기의 뷰포트 크기를 에뮬레이트할 수 있어, 스마트폰과 태블릿을 포함한 다양한 모바일 기기의 화면 크기를 시뮬레이션할 수 있습니다. 이 기능을 통해 웹 애플리케이션이 다양한 화면 크기에 대응하여 레이아웃과 기능에 대한 잠재적인 문제를 해결하며, 모든 플랫폼에서 일관된 사용자 경험을 제공할 수 있습니다.\n\n# 색상 구성 검증:\n\n다크 모드와 다른 사용자별 색상 기본 설정의 인기가 높아지면서, 플레이라이트의 모바일 기기 에뮬레이션 기능을 활용하여 테스터들은 웹 애플리케이션의 디자인이 다른 색상 구성에서 어떻게 작동하는지 확인할 수 있습니다. 이는 밝은 모드와 어두운 모드에서 애플리케이션의 모습이 일관되고 접근성 있는지 확인하는 것을 포함합니다. 이렇게 함으로써, 개발자들은 사용자의 색상 구성 환경에 관계없이 시각적으로 매력적이고 사용자 친화적인 경험을 제공할 수 있습니다.\n\n# 지리적 위치, 시간대, 지역 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플레이라이트에는 위치정보, 시간대 및 로캘을 시뮬레이션하는 강력한 기능이 포함되어 있어 다양한 테스트 시나리오를 지원합니다. 이 기능을 통해 개발자들은 웹 애플리케이션이 전 세계 사용자를 대상으로 다양한 지리적 지역 및 시간대에서 어떻게 작동하는지 테스트할 수 있으며, 전 세계 사용자에게 올바른 동작을 제공할 수 있습니다. 예를 들어, 다른 로캘을 시뮬레이션하여 날짜 및 시간 형식, 언어 설정 및 기타 지역별 기능이 예상대로 작동하는지 확인할 수 있습니다. 이러한 포괄적인 테스트를 통해 애플리케이션이 전 세계의 다양한 지역의 사용자에게 원활하고 정확한 경험을 제공하는지 확인할 수 있습니다.\n\n프레임워크의 다양한 에뮬레이션 기능은 테스트 과정을 크게 향상시켜주며, 개발자와 테스터들에게 다양한 장치 및 설정에서 웹 애플리케이션의 고품질 성능과 사용자 경험을 제공할 수 있는 강력한 도구를 제공합니다.\n\n# 사전 준비 단계\n\nTypeScript로 Playwright 스크립트를 작성하여 제공된 웹사이트에서 모바일 기기 에뮬레이션(예: iPhone 11)을 사용하여 로그인 프로세스를 자동화하는 방법을 알아봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 초기화하기:\n\n- npm init -y\n- npm install playwright typescript ts-node @types/node\n- `npm` : JavaScript 패키지를 관리하는 유틸리티인 Node Package Manager입니다.\n- `init` : 새로운 Node.js 프로젝트를 초기화하고 `package.json` 파일을 생성합니다.\n- `-y` : 이 옵션은 모든 프롬프트에 \"예\"로 자동응답하여 기본 설정을 허용합니다.\n- `npm install` : 이 명령은 나열된 패키지를 설치하고 `package.json` 파일에 종속성으로 포함시킵니다.\n\n# tsconfig.json 파일 생성하기:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드의 각 줄에 대한 자세한 설명을 드리겠습니다:\n\ncompilerOptions:\n\n- TypeScript 컴파일러에 코드를 컴파일하는 방법을 알려주는 다양한 설정이 포함되어 있습니다.\n\ntarget:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript를 출력하는 버전을 지정합니다.\n\nModule:\n\n- 출력에 사용할 모듈 시스템을 정의합니다.\n\noutDir:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴파일된 파일이 배치될 디렉토리입니다.\n\nrootDir:\n\n- TypeScript 소스 파일이 포함된 디렉토리입니다.\n\nStrict:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모든 엄격한 유형 확인 옵션을 활성화합니다.\n\n**esModuleInterop**:\n\n- CommonJS와 ES 모듈간의 호환성을 보장합니다.\n\n**Include:**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴파일에 포함할 파일이나 디렉토리를 지정합니다.\n\n# 테스트 케이스 생성 및 결과:\n\n# TypeScript 스크립트 생성:\n\nsrc 디렉토리를 만들고 그 안에 mobileTest.ts라는 파일을 생성하고 다음과 같은 내용을 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { chromium, devices } from 'playwright';\nconst iPhone11 = devices['iPhone 11'];\n(async () =\u003e {\n  // Chromium 브라우저 실행\n  const browser = await chromium.launch({ headless: false });\n  // iPhone 11 디바이스 설정으로 새로운 브라우저 컨텍스트 생성\n  const context = await browser.newContext({\n    ...iPhone11,\n    locale: 'en-US',\n    geolocation: { latitude: 37.7749, longitude: -122.4194 },\n    permissions: ['geolocation'],\n  });\n  // 컨텍스트에서 새로운 페이지 생성\n  const page = await context.newPage();\n  // 로그인 페이지로 이동\n  await page.goto('https://practicetestautomation.com/practice-test-login/');\n  // 사용자 이름 입력\n  await page.fill('#username', 'student');\n  // 비밀번호 입력\n  await page.fill('#password', 'Password123');\n  // 로그인 버튼 클릭\n  await page.click('#submit');\n  // 특정 요소를 확인하여 로그인 성공 여부 확인\n  const successMessage = await page.textContent('.post-title');\n  if (successMessage?.includes('Logged In Successfully')) {\n    console.log('로그인 성공');\n  } else {\n    console.log('로그인 실패');\n  }\n\n  // 브라우저 닫기\n  await browser.close();\n})();\n```\n\n위의 코드 각 줄에 대한 자세한 설명:\n\n모듈 가져오기\n\n- 'playwright'에서 'chromium, devices' 가져오기;\n- chromium: Playwright에서 Chromium 브라우저 가져오기.\n- devices: Playwright에서 사전 정의된 디바이스 설명자(예: 모바일 디바이스) 가져오기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n모바일 기기 정의\n\n- const iPhone11 = devices['iPhone 11'];iPhone11: 이 줄은 iPhone 11에 대한 미리 정의된 기기 설명자를 변수 iPhone11에 할당합니다. 기기 설명자에는 뷰포트 크기, 사용자 에이전트 및 해당 기기를 흉내 내는 기타 설정과 같은 정보가 포함됩니다.\n\n비동기 함수\n\n- (async () =\u003e {\n- 이것은 비동기 함수를 시작합니다. async 키워드를 사용하면 함수 내에서 await을 사용할 수 있어서 동기적으로 보이는 방식으로 비동기 작업을 수행할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 브라우저 실행하기\n\n- const browser = await chromium.launch('headless: false');\n- chromium.launch(): 크로미엄 브라우저의 인스턴스를 실행합니다.\n- 'headless: false': 브라우저가 헤드리스 모드가 아닌, 즉 브라우저 창이 표시되는 모드로 실행됩니다.\n\n기기 설정을 갖춘 브라우저 컨텍스트 생성하기\n\n```js\nconst context = await browser.newContext({\n  ...iPhone11,\n  locale: 'en-US',\n  geolocation: { latitude: 37.7749, longitude: -122.4194 },\n  permissions: ['geolocation'],\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nbrowser.newContext(): 이것은 특정 설정으로 새로운 브라우저 컨텍스트를 만듭니다.\n\n…iPhone11: 전개 연산자 (…)는 iPhone11 설명자의 모든 속성을 컨텍스트 설정으로 복사하는 데 사용됩니다.\n\nlocale: 'en-US': 로캘(언어)을 영어(미국)으로 설정합니다.\n\ngeolocation: ' latitude: 37.7749, longitude: -122.4194 ': 지리적 위치를 캘리포니아 주 샌프란시스코에 해당하는 좌표로 설정합니다. permissions: ['geolocation']: 브라우저 컨텍스트에 지리적 위치 사용 권한을 부여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 페이지 생성\n\n- const page = await context.newPage();\n- context.newPage(): 브라우저 컨텍스트에 새 페이지(탭)를 만듭니다.\n\n로그인 페이지로 이동\n\n- await page.goto('https://practicetestautomation.com/practice-test-login/');\n- page.goto(): 이 코드는 지정된 URL로 이동합니다. 여기서는 제공된 웹사이트의 로그인 페이지로 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 이름 입력\n\n- await page.fill('#username', 'student');\n- page.fill(): 이 명령은 CSS 선택자 #username로 식별된 입력란에 'student'라는 텍스트를 입력합니다.\n\n비밀번호 입력\n\n- await page.fill('#password', 'Password123');\n- page.fill(): 이 명령은 CSS 선택자 #password로 식별된 입력란에 'Password123'이라는 텍스트를 입력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 버튼을 클릭해주세요.\n\n- await page.click(‘#submit’);\n- page.click(): 이것은 CSS 선택자 #submit로 식별된 버튼을 클릭합니다.\n- 로그인 성공 확인\n\n```js\nconst successMessage = await page.textContent('.post-title');\n  if (successMessage?.includes('Logged In Successfully')) {\n    console.log('로그인 성공');\n  } else {\n    console.log('로그인 실패');\n  }\n```\n\npage.textContent(): 이것은 CSS 선택자 .post-title로 식별된 요소의 텍스트 콘텐츠를 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성공 메시지?.includes('로그인 성공'): 이것은 검색된 텍스트 내용이 '로그인 성공'이라는 구문을 포함하는지 확인합니다.\n\nconsole.log('로그인 성공'): 해당 구문이 찾아진 경우 콘솔에 '로그인 성공'을 기록합니다. console.log('로그인 실패'): 해당 구문이 찾아지지 않은 경우 콘솔에 '로그인 실패'를 기록합니다.\n\n브라우저 닫기\n\n- await browser.close();\n- ')();\n- browser.close(): 이것은 브라우저를 닫습니다.')();: 이것은 비동기 함수를 종료하고 즉시 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트 실행 방법\n\n- 터미널을 열고 다음 명령을 입력하세요: npx ts-node src/mobileTest.ts\n\n![이미지 1](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_1.png)\n\n![이미지 2](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_3.png)\n\n![이미지2](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_4.png)\n\n![이미지3](/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_5.png)\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 Playwright 및 TypeScript를 사용하여 웹 사이트의 로그인 기능을 자동화하는 견고한 테스팅 프레임워크를 구축했습니다. iPhone 11을 모방하여 모바일 기기에서 사이트가 잘 작동하도록 보장했습니다. TypeScript 구성(`tsconfig.json`)은 코드 컴파일을 최적화하고, 스크립트(`loginTest.ts`)는 자격 증명 입력부터 성공 확인까지 전체 로그인 프로세스를 자동화했습니다.\n\n이 방법은 테스트를 간소화하고 모바일 환경에서 문제를 발견하여 웹 사이트 품질을 향상시킵니다. Playwright 및 TypeScript를 활용하여 신뢰할 수 있고 확장 가능한 테스트 솔루션을 개발했습니다. 그러나 모바일 기기 에뮬레이션은 실제 기기에서의 테스트를 대체하지 않으며, 초기 설정이 복잡할 수 있습니다.\n\n더 많은 강력한 도구를 소화하고 탐구하여 전문적인 테스팅 도구를 숙달하기 위해 'Jignect' 와 함께 노력해보세요.\n\n저희의 섬세한 접근 방식과 첨단 솔루션이 품질과 성능을 새로운 높이로 끌어올린 것을 목격하세요. 소프트웨어 테스팅 탁월성의 세계로 여정을 시작하세요. 더 자세한 내용은 \"Tools \u0026 Technologies \u0026 QA Services\"를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당사가 제공하는 멋진 서비스에 대해 더 알고 싶다면 언제든지 연락해 주세요.\n\n행복한 테스트하세요! 🙂\n\n원문: https://jignect.tech 에서 2024년 6월 19일에 게시됨.","ogImage":{"url":"/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-StreamliningAutomationTestinginMobilewithPlaywrightandTypeScript_0.png","tag":["Tech"],"readingTime":9},{"title":"CDK 중첩 스택 - 왜와 어떻게","description":"","date":"2024-06-20 02:39","slug":"2024-06-20-CDKNestedStacksTheWhyandHow","content":"\n\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png)\n\n## 시작말\n\n✔️ 우리는 중첩 스택의 필요성에 대해 이야기합니다.\n✔️ AWS CDK로 어떻게 이것이 실현될 수 있는지 논의합니다.\n\n# 소개 👋🏽\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 빠른 기사에서는 AWS CDK 중첩 스택에 대해 이야기하고, 언제 우리 서비스에 사용해야 하는지, 그리고 이를 어떻게 구현할 수 있는지에 대해 살펴볼 것입니다. 예제 코드 베이스를 통해 걸어 보기 위해 'Gilmore Cuisine'라는 가상 회사를 다룰 것입니다:\n\n![image](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_1.png)\n\n기사의 코드는 GitHub에서 여기에서 찾을 수 있습니다:\n\n더 자세한 기사와 예제는 Serverless Advocate 패턴 및 솔루션 레지스트리를 자유롭게 이용해 주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_2.png\" /\u003e\n\n# 어떻게 작동할까요? 💡\n\n애플리케이션을 구축할 때 클라우드포메이션에서 스택 당 500개의 리소스 제한에 도달하는 경우가 종종 있습니다.\n\n이것은 우리가 아마도 내부적으로 많은 리소스를 포함하는 우리만의 L3 구성을 사용했기 때문에 발생할 수 있습니다. 예를 들어 알람, 점진적 배포, 대시보드 등을 포함하는 람다 구성이 있는 경우이며, 우리는 이 구성을 스택에서 여러 번 사용하여 제한을 초과하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS CDK의 NestedStack 구조는 부모 스택 내에서 하나의 자원으로 계산하여 스택 당 AWS CloudFormation 500개 자원 제한을 우회할 수 있게 해줍니다. 이는 중첩 스택이 다른 중첩 스택을 포함하여 최대 500개의 자원을 가질 수 있다는 것을 의미합니다. 중첩 스택은 구조화된 스택의 계층을 가질 수 있습니다:\n\n![CDK Nested Stacks hierarchy](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_3.png)\n\n중첩 스택의 범위(본질적으로 부모)는 AWS CDK의 Stack 또는 NestedStack 구조여야 합니다. 기존의 스택과 마찬가지로 중첩 스택에서의 구조 정의는 동일합니다.\n\n합성 과정에서 중첩 스택은 자체 AWS CloudFormation 템플릿으로 변환되어 AWS CDK 스테이징 버킷에 업로드됩니다. 중첩 스택은 부모 스택에 바인딩되어 독립적인 배포 자산으로 처리되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부모 스택과 중첩 스택 간의 리소스 속성의 상호 참조는 AWS CDK를 사용할 때 자동으로 스택 매개변수와 출력으로 변환됩니다.\n\n다음 섹션의 코드를 살펴봅시다.\n\n👇 더 나아가기 전에 — 앞으로의 블로그 게시물과 서버리스 뉴스를 받으시려면 LinkedIn에서 저와 연결해주세요 https://www.linkedin.com/in/lee-james-gilmore/\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드를 통해 이야기하기👨‍💻\n\n내 작업을 따르는 사람들은 일반적으로 애플리케이션을 '상태 없음'과 '상태 있는' 리소스로 분할하는 것을 알고 있을 것입니다. 또한 깔끔한 코드 및 아키텍처에 대한 내 의견이 있습니다.\n\n이 경로를 계속 따라가서 중첩 스택을 사용하려면 폴더 구조 관점에서 다음과 같이 보일 것입니다:\n\n![Folder Structure](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이제는 'stateful' 및 'stateless'의 상위 스택 아래 하나 이상의 중첩된 스택을 가지고 있음을 쉽게 확인할 수 있습니다. 그리고 그 스택이 개념적 수준에서 무엇을 포함하는지 볼 수 있습니다(API 리소스, 데이터베이스 리소스, 이벤트 버스 리소스 및 컴퓨팅 리소스).\n\n이제 폴더 구조를 확장해 보면:\n\n![image](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_6.png)\n\n중첩된 스택에는 파일에 'nested'가 추가된 단어도 있습니다. 이는 생성된 파일과 콘솔에 표시되어 이해하기 쉽게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 상태 유지 스택 코드를 살펴보면 다음과 같은 내용을 볼 수 있습니다:\n\n```js\nimport * as cdk from 'aws-cdk-lib';\n\nimport { Construct } from 'constructs';\nimport { DatabaseResources } from './nested/database/database-nested';\nimport { EventBusResources } from './nested/event-bus/event-bus-nested';\n\nexport interface GilmoreCuisineStatefulStackProps extends cdk.StackProps {\n  stage: string;\n}\n\nexport class GilmoreCuisineStatefulStack extends cdk.Stack {\n  public databaseResources: DatabaseResources;\n  public eventBusResources: EventBusResources;\n\n  constructor(\n    scope: Construct,\n    id: string,\n    props: GilmoreCuisineStatefulStackProps\n  ) {\n    super(scope, id, props);\n\n    // 두 상태 유지 중첩 스택을 가져와서 인스턴스화합니다.\n    this.databaseResources = new DatabaseResources(this, 'DatabaseResources', {\n      stage: props.stage,\n    });\n\n    this.eventBusResources = new EventBusResources(this, 'EventBusResources', {\n      stage: props.stage,\n    });\n  }\n}\n```\n\n위에서 볼 수 있듯이, 우리의 상위 스택은 두 중첩된 스택을 가져와서 그것들을 인스턴스화합니다.\n\n그런 다음 DatabaseResources 중첩 스택을 살펴보면 다음과 같은 내용을 볼 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport * as cdk from 'aws-cdk-lib';\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\n\nimport { Construct } from 'constructs';\n\ninterface DatabaseResourcesProps extends cdk.NestedStackProps {\n  stage: string;\n}\n\nexport class DatabaseResources extends cdk.NestedStack {\n  public table: dynamodb.Table;\n\n  constructor(scope: Construct, id: string, props: DatabaseResourcesProps) {\n    super(scope, id, props);\n\n    // our database is a static resource\n    this.table = new dynamodb.Table(this, 'Table', {\n      tableName: `gilmore-cuisine-table-${props.stage}`,\n      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,\n      partitionKey: {\n        name: 'id',\n        type: dynamodb.AttributeType.STRING,\n      },\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n    });\n  }\n}\n```\n\n특히 이 스택이 cdk.Stack이 아닌 부모와 같이 cdk.NestedStack을 확장하는 것을 볼 수 있습니다.\n\n이제 상태 리소스를 사용하는 ComputeResources 중첩 스택으로 이동하면 다음과 같은 코드가 나옵니다:\n\n```js\nimport * as apigw from 'aws-cdk-lib/aws-apigateway';\nimport * as cdk from 'aws-cdk-lib';\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport * as events from 'aws-cdk-lib/aws-events';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as nodeLambda from 'aws-cdk-lib/aws-lambda-nodejs';\nimport * as path from 'path';\n\nimport { Construct } from 'constructs';\n\ninterface ComputeResourcesProps extends cdk.NestedStackProps {\n  stage: string;\n  api: apigw.RestApi;\n}\n\nexport class ComputeResources extends cdk.NestedStack {\n  private api: apigw.RestApi;\n  private table: dynamodb.Table;\n  private bus: events.EventBus;\n\n  constructor(scope: Construct, id: string, props: ComputeResourcesProps) {\n    super(scope, id, props);\n\n    this.api = props.api;\n\n    // 상태 리소스에서 테이블의 인스턴스 가져오기\n    this.table = dynamodb.Table.fromTableName(\n      this,\n      'Table',\n      `gilmore-cuisine-table-${props.stage}`\n    ) as dynamodb.Table;\n\n    // 상태 리소스에서 bus의 인스턴스 가져오기\n    this.bus = events.EventBus.fromEventBusName(\n      this,\n      'EventBus',\n      `gilmore-cuisine-event-bus-${props.stage}`\n    ) as events.EventBus;\n\n    // 람다 파우어툴즈 설정 생성\n    const lambdaPowerToolsConfig = {\n      LOG_LEVEL: 'DEBUG',\n      POWERTOOLS_LOGGER_LOG_EVENT: 'true',\n      POWERTOOLS_LOGGER_SAMPLE_RATE: '1',\n      POWERTOOLS_TRACE_ENABLED: 'enabled',\n      POWERTOOLS_TRACER_CAPTURE_HTTPS_REQUESTS: 'captureHTTPsRequests',\n      POWERTOOLS_SERVICE_NAME: 'gilmore-cuisine-service',\n      POWERTOOLS_TRACER_CAPTURE_RESPONSE: 'captureResult',\n      POWERTOOLS_METRICS_NAMESPACE: 'gilmore-cuisine',\n    };\n\n    // 람다 함수 생성\n    const listBookingsLambda: nodeLambda.NodejsFunction =\n      new nodeLambda.NodejsFunction(this, 'ListBookingsLambda', {\n        functionName: `${props.stage}-gilmore-cuisine-list-bookings`,\n        runtime: lambda.Runtime.NODEJS_20_X,\n        entry: path.join(\n          __dirname,\n          '../../src/adapters/primary/list-bookings/list-bookings.adapter.ts'\n        ),\n        memorySize: 1024,\n        handler: 'handler',\n        tracing: lambda.Tracing.ACTIVE,\n        bundling: {\n          minify: true,\n          sourceMap: true,\n        },\n        environment: {\n          NODE_OPTIONS: '--enable-source-maps',\n          ...lambdaPowerToolsConfig,\n          TABLE_NAME: this.table.tableName,\n          BUS: this.bus.eventBusName,\n        },\n      });\n\n    const createBookingLambda: nodeLambda.NodejsFunction =\n      new nodeLambda.NodejsFunction(this, 'CreateBookingLambda', {\n        functionName: `${props.stage}-gilmore-cuisine-create-booking`,\n        runtime: lambda.Runtime.NODEJS_20_X,\n        entry: path.join(\n          __dirname,\n          '../../src/adapters/primary/create-booking/create-booking.adapter.ts'\n        ),\n        memorySize: 1024,\n        handler: 'handler',\n        tracing: lambda.Tracing.ACTIVE,\n        bundling: {\n          minify: true,\n          sourceMap: true,\n        },\n        environment: {\n          NODE_OPTIONS: '--enable-source-maps',\n          ...lambdaPowerToolsConfig,\n          TABLE_NAME: this.table.tableName,\n          BUS: this.bus.eventBusName,\n        },\n      });\n\n    // 함수에 대한 테이블 권한 부여\n    this.table.grantReadData(listBookingsLambda);\n    this.table.grantWriteData(createBookingLambda);\n\n    // 함수가 메시지를 발행하도록 허용\n    this.bus.grantPutEventsTo(createBookingLambda);\n\n    // 올바른 API 리소스에 람다 함수 추가\n    const orders = this.api.root\n      .getResource('v1')\n      ?.getResource('bookings') as apigw.Resource;\n\n    orders.addMethod(\n      'GET',\n      new apigw.LambdaIntegration(listBookingsLambda, {\n        proxy: true,\n      })\n    );\n\n    orders.addMethod(\n      'POST',\n      new apigw.LambdaIntegration(createBookingLambda, {\n        proxy: true,\n      })\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 DynamoDB 테이블 및 EventBridge 이벤트 버스의 상태를 전달하는 것이 아니라, 다음 메서드를 사용하여 그들에 대한 참조를 얻고 있습니다.\n\n```js\n...\n// 상태를 가진 스택에서 테이블의 인스턴스를 가져옴\nthis.table = dynamodb.Table.fromTableName(\n  this,\n  'Table',\n  `gilmore-cuisine-table-${props.stage}`\n) as dynamodb.Table;\n\n// 상태를 가진 스택에서 이벤트 버스의 인스턴스를 가져옴\nthis.bus = events.EventBus.fromEventBusName(\n  this,\n  'EventBus',\n  `gilmore-cuisine-event-bus-${props.stage}`\n) as events.EventBus;\n...\n```\n\n그러나 이는 상태를 가진 스택이 상태가 없는 스택보다 먼저 배포되어야 함을 의미합니다. 이는 의존성에 관한 다음과 같이 메인 애플리케이션 파일에서 확실하게 할 수 있습니다.\n\n```js\n#!/usr/bin/env node\n\nimport 'source-map-support/register';\n\nimport * as cdk from 'aws-cdk-lib';\n\nimport { GilmoreCuisineStatefulStack } from '../stateful/stateful';\nimport { GilmoreCuisineStatelessStack } from '../stateless/stateless';\n\nconst stage = 'prod';\n\nconst app = new cdk.App();\n\nconst stateful = new GilmoreCuisineStatefulStack(\n  app,\n  'GilmoreCuisineStatefulStack',\n  {\n    stage,\n  }\n);\n\nconst stateless = new GilmoreCuisineStatelessStack(\n  app,\n  'GilmoreCuisineStatelessStack',\n  {\n    stage,\n  }\n);\n\n// stateless가 stateful보다 먼저 배포되도록 함\nstateless.addDependency(stateful);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 섹션에서 해결책을 배포하고 테스트해 봅시다.\n\n## 배포 및 테스트 🧑🏾‍💻\n\n그럼 이제 'gilmore-cuisine' 폴더에서 다음 명령을 실행하여 스택을 배포해 보겠습니다:\n\n\nnpm run deploy\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동일한 폴더에서 cdk 목록 명령을 실행하면 앞서 설명한대로 두 개의 상위 스택만 볼 수 있습니다:\n\n![CDK Nested Stacks](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_7.png)\n\n합성된 CloudFormation 템플릿 및 에셋이 포함된 cdk.out 폴더를 로컬로 확인하면 다음 파일들이 표시됩니다:\n\n두 개의 상위 템플릿, GilmoreCuisineStatefulStack.template.json 및 GilmoreCuisineStatelessStack.template.json,이 있음을 확인할 수 있습니다. 이들은 아래와 유사한 내용을 가지고 있으며 중첩 스택을 가리킵니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n\"UpdateReplacePolicy\": \"Delete\",\n\"DeletionPolicy\": \"Delete\",\n\"Metadata\": {\n  \"aws:cdk:path\": \"GilmoreCuisineStatefulStack/EventBusResources.NestedStack/EventBusResources.NestedStackResource\",\n  \"aws:asset:path\": \"GilmoreCuisineStatefulStackEventBusResourcesAC59B19D.nested.template.json\",\n  \"aws:asset:property\": \"TemplateURL\"\n}\n...\n```\n\n배포가 완료되면 콘솔로 전환하여 콘솔에 중첩 스택이 표시되지 않도록 설정하면 다음과 같이 표시됩니다:\n\n이제 콘솔에서 두 스택의 하위 중첩 스택을 살펴보겠습니다:\n\n이제 각 스택의 내용을 자세히 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ✔️ Stateful Stack\n\n상태 유지 스택 안에는 DatabaseResources와 EventBusResources에 대한 중첩 스택을 볼 수 있습니다:\n\n보다 자세한 내용을 살펴보면 다음과 같습니다:\n\nDatabaseResources\n우리의 DynamoDB 테이블이 포함된 DatabaseResources에 대한 중첩 스택을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEventBusResources\n이벤트 버스, CloudWatch 로그 그룹 및 이벤트 규칙 대상을 포함하는 EventBusResources의 중첩 스택을 볼 수 있습니다:\n\n이제 무상태 스택과 관련된 내용을 살펴보겠습니다.\n\n## ✔️ 무상태 스택\n\n무상태 스택에는 ApiResources 및 ComputeResources의 두 개의 중첩 스택이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApiResources\n아래에서 ApiResources에 대한 중첩 스택을 볼 수 있는데, API Gateway REST API, 스테이지, 배포 등이 포함되어 있습니다.\n\nComputeResources\n아래에서 ComputeResources에 대한 중첩 스택을 볼 수 있는데, 두 개의 람다 함수가 포함되어 있습니다:\n\n## 테스팅 🧪\n\n\u003cimg src=\"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Postman 파일을 사용하여 /bookings/의 POST 엔드포인트를 요청하면 다음과 같은 결과를 볼 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_9.png)\n\n그리고 CloudWatch 로그의 모든 이벤트를 캐치하는 대상을 살펴보면 아래와 같이 이벤트가 표시됩니다:\n\n![이미지](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 목록 예약 엔드포인트를 실행할 수도 있어요. \n\n이것을 보여 주겠죠: \n\n![List Bookings EndPoint](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_12.png)\n\n# 결론  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글을 읽어주셔서 감사합니다. 마지막으로 다룬 내용을 요약하면 다음과 같습니다:\n\n- 중첩 스택이 필요한 이유에 대해 이야기했습니다.\n- AWS CDK를 사용하여 이를 어떻게 구현할 수 있는지에 대해 이야기했습니다.\n\n# 마무리 인사 👋🏽\n\n이 짧은 글을 즐겁게 읽어주셨기를 바라며, 마음에 드셨다면 공유해 주시고 피드백을 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷한 콘텐츠를 더 보고 싶다면 제 YouTube 채널을 방문해주세요!\n\n![YouTube](/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_13.png)\n\n그리고 다음 링크를 통해 연락할 수도 있어요:\n\n[LinkedIn 프로필](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter 프로필](https://twitter.com/LeeJamesGilmore)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 게시물을 즐겼다면, 추가 포스트/시리즈를 확인하려면 제 프로필 Lee James Gilmore를 팔로우해 주세요. 또한 'clap' 기능을 이용해 주세요. 게시물 하단에 위치해 있습니다. 한 번 이상으로도 클랩을 할 수 있어요! \n\n# 나에 대해\n\n\"안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 글로벌 총괄인 Lee입니다. 현재 City Electrical Factors (UK) 및 City Electric Supply (US)에서 근무 중이며, 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 모든 것을 AWS, 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 사랑으로 서버리스를 옹호하는 사람이라고 생각해요.\n\n*** 제공된 정보는 제 개인적인 견해이며, 그에 따른 책임을 지지 않습니다. ***\n\n아래 내용도 관심이 있을지도 모릅니다:","ogImage":{"url":"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png"},"coverImage":"/assets/img/2024-06-20-CDKNestedStacksTheWhyandHow_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 맵이 무엇이며 어떻게 작동하는지 완벽한 가이드","description":"","date":"2024-06-20 02:37","slug":"2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide","content":"\n\n![JavaScript Maps](/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png)\n\n안녕하세요! 아마도 JavaScript 객체에 익숙하실 것입니다. 그런데 JavaScript에서 데이터 세트를 만드는 또 다른 방법인 'Maps'에 대해 알고 계셨나요? 지금은 JavaScript의 일반 객체를 사용하고 계실 수도 있는데, 문제 해결에 더 나은 해결책이 될 수 있는 맵(map)을 사용해볼까요?\n\nJavaScript 맵은 객체와 몇 가지 주요 면에서 다릅니다. typeof new Map()을 호출하면 object가 반환되지만, 이것에 속지 마세요! 객체와 맵 사이에 주요한 차이점들을 알아보겠습니다:\n\n- 객체와 달리 기본적으로 어떠한 키도 포함하지 않습니다. 객체는 프로토타입 객체를 포함하고 있습니다.\n- 맵은 삽입된 순서대로 정렬되는 것이 보장됩니다. 객체도 요즘은 이와 같이 동작하지만, 같은 보장을 제공하지는 않습니다.\n- 맵의 키는 함수나 객체를 포함하여 모든 것이 될 수 있습니다. 반면 JavaScript에서는 문자열이나 심볼이어야 합니다.\n- 데이터의 빠른 또는 빈번한 추가 또는 삭제 작업을 필요로 하는 작업에서 객체보다 더 나은 성능을 보여줍니다.\n- 객체와 달리 맵은 기본적으로 iterable(반복 가능)합니다.\n\n더 궁금한 점이 있으시면 언제든지 물어보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지도의 많은 혜택을 고려한다면, 작동 방식을 살펴보는 게 좋겠죠.\n\n# JavaScript Maps 작동 기본\n\nJavaScript에서의 모든 지도는 new Map() 생성자를 사용하여 초기화됩니다. 예를 들어, myFirstMap이라는 지도를 생성해 봅시다:\n\n```js\nlet myFirstMap = new Map();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차이점은 맵에서 키를 설정, 가져오거나 삭제하려면 Map과 함께 제공되는 특정 메서드를 사용해야 한다는 것입니다. 따라서 firstKey라는 키로 someValue의 새 값을 설정하려면 다음 메서드를 실행할 수 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\n```\n\n# JavaScript Map에서 항목 삭제\n\nJavaScript 맵에서 키를 삭제하려면 delete() 메서드를 호출해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.delete('firstKey');\n```\n\n또한 clear()를 사용하여 전체 맵을 삭제하고 내용을 비울 수도 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.clear();\nconsole.log(myFirstMap); // Map(0) 반환\n```\n\n# JavaScript Map에서 키 가져오기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 방법들과 비슷하게, firstKey의 값을 얻으려면 get()을 사용해야 합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.get('firstKey') // 'someValue'\n```\n\n# JavaScript Map에서 키가 존재하는지 확인하기\n\nJavaScript Maps에는 특정 키가 있는지 확인하려면 has() 메서드를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.has('firstKey') // true\n```\n\n# 주의: 일반 객체 속성을 Map과 함께 사용하지 마세요\n\n자바스크립트에는 많은 특이성이 있고, Map도 예외는 아닙니다. 놀랍게도, Map은 객체 표기법도 지원할 수 있습니다. 예를 들어, 다음과 같이 동작하는 것처럼 보입니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap['firstKey'] = 'someValue';\nconsole.log(myFirstMap); // Map(0) { firstKey: 'someValue' }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나, 이렇게 하면 안 돼요! 이것은 맵 자체에 새 항목을 만드는 것이 아니라 단순히 객체를 만드는 것이에요. 그러면 JavaScript 맵의 모든 이점을 잃게 되요.\n\n# JavaScript 맵의 크기를 알려주는 방법\n\n맵에 있는 키의 개수를 찾는 것은 객체보다 맵이 조금 더 사용하기 쉬운 경우 중 하나에요. 이를 위해 size() 메서드를 사용할 수 있어요. 이 메서드는 키의 개수를 반환해요:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set('firstKey', 'someValue');\nmyFirstMap.size // 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체의 크기를 알아내기 위해 일반적으로 Object.keys()와 length를 혼합하여 사용합니다:\n\n```js\nlet myObj = { \"name\" : \"John\" };\nlet sizeOfObj = Object.keys(myObj).length; // 1\n```\n\n# 문자열이 아닌 키로 Map 사용하기\n\n제가 언급했듯이, JavaScript Maps는 함수와 객체와 같은 비전통적인 키를 허용합니다. 반면 객체는 문자열과 심볼만 허용합니다. 예를 들어, Map에서는 다음과 같이 유효합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n맵의 키는 값이 아닌 참조 값에 기반합니다. 즉, 다음과 같이 작동합니다.\n\n```js\nlet myFirstMap = new Map();\nlet myFunction = function() { return \"someReturn\"; }\nmyFirstMap.set(myFunction, \"value\");\nmyFirstMap.get(myFunction); // \"someReturn\" 반환\n```\n\n아래는 작동하지 않습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet myFirstMap = new Map();\nlet myFunction = function() { return \"someReturn\"; }\nmyFirstMap.set(myFunction, \"value\");\nmyFirstMap.get(function() { return \"someReturn\"; }); // 결과는 정의되지 않습니다\nmyFirstMap.get('someReturn'); // 결과는 정의되지 않습니다\n```\n\n그 이유는 function() { return \"someReturn\"; }와 myFunction이 값으로는 같지만 시스템 메모리에 저장된 위치가 다르기 때문입니다. 그래서 완전히 동등하지는 않습니다. 비슷하게, 맵은 반환 값에 대해 작동하지 않으므로 myFirstMap.get('someReturn') 또한 정의되지 않은 값을 반환합니다.\n\n객체에 대해서도 같은 예제가 유사한 결과를 가져옵니다:\n\n```js\nlet myFirstMap = new Map();\nlet myObject = { \"someKey\" : \"someValue\" }\nmyFirstMap.set(myObject, \"value\");\nmyFirstMap.get({ \"someKey\" : \"someValue\" }); // 결과는 정의되지 않습니다\nmyFirstMap.get(myObject); // 결과는 'value'를 반환합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# JavaScript Maps 병합하기\n\n여러 맵을 하나로 병합하려면, 객체를 병합하는 방식과 마찬가지로 스프레드 구문을 사용하여 병합할 수 있습니다. 예를 들어, 여기서는 spread 구문을 사용하여 myFirstMap과 mySecondMap을 myNewMap으로 병합합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nlet mySecondMap = new Map();\nmySecondMap.set(\"someOther\", \"value\");\nlet myNewMap = new Map([...myFirstMap, ...mySecondMap]);\nconsole.log(myNewMap);\n// Map(2) { some: \"value\", someOther: \"value\" }\n```\n\n# 맵(Map)에서 반복하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n맵은 기본적으로 Iterable 합니다. 객체를 반복하려면 보통 Object.keys와 같은 함수를 사용해야 합니다. 결국, 우리는 다음과 같이 모든 맵에서 forEach를 사용할 수 있습니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.forEach(function(value, key, map) {\n    // value -\u003e 맵에서 키의 값\n    // key -\u003e 맵 안의 항목의 키\n    // map -\u003e 전체 맵\n    console.log(value, key, map);\n})\n```\n\n# JavaScript Map에서 for를 사용한 반복\n\n또한 for(let ... of )을 사용하여 맵을 반복할 수도 있습니다! 이렇게 하면 각 항목이 키와 값의 배열로 반환됩니다. 예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nfor(let x of myFirstMap) {\n    // Returns [ 'some', 'value' ]\n    console.log(x);\n}\n```\n\n# JavaScript Map에서 값 또는 키를 순회하기\n\nJavaScript에서 값 또는 키를 순회하는 또 다른 멋진 방법은 values() 또는 entries() 메서드를 사용하는 것입니다. 이들 메서드는 각각 map의 값과 항목에 대한 새로운 반복자를 반환합니다. 이는 생성기 함수에서와 마찬가지로 next() 함수를 사용하여 다음 키 또는 값을 액세스할 수 있다는 것을 의미합니다.\n\n예를 들어, entries()가 어떻게 작동하는지 살펴보겠습니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet allKeys = myFirstMap.entries();\nconsole.log(allKeys); // MapIterator {} 객체를 반환합니다\nconsole.log(allKeys.next()); // { value: [ 'some', 'value' ], done: false }를 반환합니다\nconsole.log(allKeys.next().value); // [ 'some', 'value' ]를 반환합니다\n```\n\nallKeys.next()에서 반환된 것은 객체입니다. 이 객체 안의 값은 [ `some`, `value` ] 입니다 - 맵의 첫 번째 항목을 나타내는 배열입니다. 계속해서 next()를 실행하여 맵의 다음 항목들을 얻을 수 있습니다. 정말 멋집니다! 값으로만 이 작업을 다시 할 수도 있습니다.\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet allValues = myFirstMap.values();\nconsole.log(allValues); // MapIterator {} 객체를 반환합니다\nconsole.log(allValues.next()); // { value: 'value', done: false }를 반환합니다\nconsole.log(allValues.next().value); // 'value'를 반환합니다\n```\n\n이러한 이터레이터들은 특정 상황에서 유용하며 맵에 있는 모든 데이터를 반복하는 멋진 방법이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자바스크립트에서 맵의 직렬화\n\n맵의 한 가지 단점은 JSON.parse() 및 JSON.stringify로 쉽게 직렬화할 수 없다는 점입니다. 이를 시도하면 비어 있는 객체가 반환되는데, 이는 맵의 객체가 항목으로만 채워졌을 때 비어 있기 때문에 어느 정도 이해됩니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\n// Returns {}\nconsole.log(JSON.stringify(myFirstMap));\n```\n\n맵을 직렬화하는 유일한 현실적인 방법은 객체나 배열로 변환한 후에 직렬화하는 것이며, 이를 위해 맵을 사용한다면 이 작업을 수행해주는 별도의 도우미 함수를 유지해야 합니다. 예를 들어, Array.from()을 사용하여 우리의 맵을 배열로 변환한 다음 JSON.stringify()를 사용하여 직렬화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\nlet arrayMap = Array.from(myFirstMap);\n// Returns [[\"some\",\"value\"],[\"someOther\",\"value\"],[\"aFinal\",\"value\"]]\nconsole.log(JSON.stringify(arrayMap));\n```\n\n그런 다음, 다시 Map으로 변환하려면 JSON.parse()를 사용하여 new Map()과 함께 사용해야합니다:\n\n```js\nlet myFirstMap = new Map();\nmyFirstMap.set(\"some\", \"value\");\nmyFirstMap.set(\"someOther\", \"value\");\nmyFirstMap.set(\"aFinal\", \"value\");\n// Map을 배열로 변환\nlet arrayMap = Array.from(myFirstMap);\n// Map의 JSON 문자열 버전:\nlet stringifiedMap = JSON.stringify(arrayMap);\n// 다시 Map으로 변환하려면 new Map(JSON.parse...)를 사용하세요:\nlet getMap = new Map(JSON.parse(stringifiedMap));\n// Map(3) {'some' =\u003e 'value', 'someOther' =\u003e 'value', 'aFinal' =\u003e 'value'}를 반환\nconsole.log(getMap);\n```\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 Maps는 객체의 모든 유연성이 필요하지 않을 때 데이터를 저장하는 훌륭한 방법입니다. 데이터의 순서가 굉장히 중요한 상황에서는 객체보다 성능이 우수합니다. 아이템을 자주 추가하거나 제거해야 하는 상황에서도 객체보다 효율적입니다. 이 안내서에서는 Maps에 대해 알아야 할 모든 것을 다뤘지만, 자바스크립트에 대해 더 알고 싶다면 여기를 클릭해주세요.\n\n이 내용이 유익했기를 바라며, 즐거운 하루 보내세요.\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요. 무료 주간 뉴스레터 구독 신청하세요. 트위터, 링크드인, 유튜브, 디스코드에서 팔로우하세요. 성장 해킹에 관심이 있다면 Circuit을 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-20-WhatareJavaScriptMapsandHowdoTheyWorkACompleteGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"쉬운 125번 유효한 회문","description":"","date":"2024-06-20 02:36","slug":"2024-06-20-Easy125ValidPalindrome","content":"\n\nLeetCode 50 두 포인터\n\n# 예시\n\n## 예시 1\n\n```js\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\"는 회문입니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예제 2\n\n```js\n입력: s = \"race a car\"\n출력: false\n설명: \"raceacar\"은 회문이 아닙니다.\n```\n\n## 예제 3\n\n```js\n입력: s = \" \"\n출력: true\n설명: 비어있는 문자열 \"\"은 알파벳이나 숫자가 아닌 문자를 제거한 후에 남는 문자열입니다. \n앞으로 읽거나 뒤로 읽어도 동일하기 때문에 회문입니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 해결책\n\n- 공간 복잡도: O( )\n- 시간 복잡도: O( )\n\n## 파이썬\n\n```js\nclass Solution:\n    def isPalindrome(self, s: str) -\u003e bool:\n        left, right = 0, len(s) - 1\n\n        while left \u003c right:\n            while left \u003c right and not s[left].isalnum():\n                left += 1\n            \n            while left \u003c right and not s[right].isalnum():\n                right -= 1\n            \n            if s[left].lower() != s[right].lower():\n                return False\n\n            left += 1\n            right -= 1\n        \n        return True\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript\n\n# Postscript\n\n## Python isalnum( )\n\n```js\ntxt1 = \"Company12\"\nprint(txt1.isalnum())  # 결과: True\n\ntxt2 = \"Company 12\"\nprint(txt2.isalnum())  # 결과: False\n\ntxt3 = \"Hello@World\"\nprint(txt3.isalnum())  # 결과: False\n\ntxt4 = \"HelloWorld\"\nprint(txt4.isalnum())  # 결과: True\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n1. https://github.com/TheExplainthis/LeetCodeJourney/","ogImage":{"url":"/assets/img/2024-06-20-Easy125ValidPalindrome_0.png"},"coverImage":"/assets/img/2024-06-20-Easy125ValidPalindrome_0.png","tag":["Tech"],"readingTime":2}],"page":"43","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"43"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>