<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/102" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/102" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="1999년에 개인 웹사이트를 만드는 방법" href="/post/2024-05-14-Howtocreateapersonalwebsitebutits1999"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="1999년에 개인 웹사이트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="1999년에 개인 웹사이트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">1999년에 개인 웹사이트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2" href="/post/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 Nodejs 테스트 러너 사용 방법" href="/post/2024-05-14-HowtoUsetheNewNodejsTestRunner"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Nodejs 테스트 러너 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Nodejs 테스트 러너 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 Nodejs 테스트 러너 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트의 해시맵" href="/post/2024-05-14-HashmapinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트의 해시맵" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HashmapinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트의 해시맵" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트의 해시맵</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구" href="/post/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs와 Expressjs" href="/post/2024-05-14-NodejsandExpressjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs와 Expressjs" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NodejsandExpressjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs와 Expressjs" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs와 Expressjs</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함" href="/post/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시맨틱 검색을 위한 MongoDB Atlas 시작하기" href="/post/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시맨틱 검색을 위한 MongoDB Atlas 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시맨틱 검색을 위한 MongoDB Atlas 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시맨틱 검색을 위한 MongoDB Atlas 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서의 동적 임포트" href="/post/2024-05-14-DynamicImportsinReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서의 동적 임포트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DynamicImportsinReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서의 동적 임포트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서의 동적 임포트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="작별인사, Ramda" href="/post/2024-05-14-FarewellRamda"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="작별인사, Ramda" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FarewellRamda_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="작별인사, Ramda" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">작별인사, Ramda</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link posts_-active__YVJEi" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"1999년에 개인 웹사이트를 만드는 방법","description":"","date":"2024-05-14 15:47","slug":"2024-05-14-Howtocreateapersonalwebsitebutits1999","content":"\n\n20년 전 웹 개발자의 삶이 어땠는지, 인터넷이 여전히 새로운 개념이었고 웹에 접속하기 전에 이상한 비프음과 부우우우음을 들어야 했던 시절에 JavaScript와 CSS는 궁금한 것 이상의 것이었으며 간단한 웹사이트를 만드는 데 흔히 사용되는 것보다 eer바나 클 친 인터넷익스플로러가 가장 인기 있었던 시기란게 궁금했나요? 아마도 그렇지 않았을 것입니다... 하지만 여유로운 몇 분이 있고 쓸데없는 새로운 것을 배우고 싶다면 — 이 ㄱㄷㄷ은 당신을 실망시키지 않을 겁니다!\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png)\n\n# 배경 이야기\n\n2022년 초에 향수에 젖어 어린 시절에 즐겨했던 게임(왕자와 겁쟁이 — 폴란드의 포인트 앤 클릭 게임이고, 맞아요, 저는 폴란드 출신입니다)을 하나 하고 싶어졌어요. 원본 게임 CD는 있었지만 실행할 수 있는 기계가 없었죠. 옛 스타일의 윈도우 PC에서 플레이하는 것이 더 재미있을 것 같아서, 내게 맞는 회사/중고 상품 웹사이트/온라인 시장을 통해 오랜만에 사용되는 기기(그리고 소프트웨어 — 윈도우 98)를 구매하고, 나를 위해 하나 짓기로 결심했어요... 어쨌든 제가 어떻게 만들었는지와 어떤 문제를 겪었는지에 대해서는 다음 이야기로 남겨둘게요.\n\n\n\n\n![게임을 완료한 후, 그리운 옛 마음은 사라지고 자리를 차지하고 먼지를 모으는 것들을 남겼어요. 이 PC에서 웹 개발을 시도해보자는 아이디어가 갑자기 떠올랐지만, 항상 더 좋은 일이 있는 것 같아요. 그래서 이 아이디어는 뒷전으로 밀려나 시간이 지난 후, 이 글을 쓰기로 결심했어요.\n\n# 1999\n\n그때 당시 저는 10살이었고, 적어도 3년 정도의 Microsoft Windows 운영 체제 경험이 있었죠. 웹 개발 여정은 2000년 초반에 시작했을 것이라고 확신하고 있어요. 처음으로 Macromedia Dreamweaver(2005년 Adobe가 Macromedia를 인수했어요)를 사용했고, CSS 없이 테이블 기반 레이아웃과 인터넷에서 복사한 JS 코드를 사용해 눈 오는 효과와 같은 트렌디한 효과를 적용한 \"프로젝트\"를 했어요.\n\n\n\n\n1999년에는 인터넷 자체가 나에게는 신비로웠어요. 아마 들어본 적은 있고 무엇인지 알았겠지만, 실제로 처음 접촉한 것은 21세기에 들어서였어요.\n\n![1999 이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_2.png)\n\n세상에서는 무슨 일이 벌어졌을까요? 유럽 연합이 새 통화인 유로를 도입했어요. 빌 클린턴은 미국 대통령이었죠. 세계 기상 기구는 90년대가 역대 가장 덥다(평균 온도를 얘기하죠)고 발표했어요. 스펀지밥 네모바지가 니켈로디언에서 데뷔했죠. 에미넴이 'The Slim Shady LP'를 발표했어요. '매트릭스'나 '스타워즈: 에피소드 1 - 마이너카의 위협' 같은 영화들이 세계 프리미어를 가졌죠.\n\n![1999 이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_3.png)\n\n\n\n모든 사람들이 천년 기리일 버그에 대해 이야기했어요. 2000년은 날짜 형식 문제로 인한 전 세계 컴퓨터 아포칼립스를 가져올 예정이었죠. 그래서, 이미 만들지 않은 경우에는 1999년이 개인 웹사이트를 만들기 마지막 기회였어요.\n\n# 프로젝트\n\n무엇을 할 건가요? 세 가지 탭을 갖춘 간단한 개인 웹사이트를 만들 거에요 — 홈(방문자에게 인사하기), 소개(간단한 소개) 및 연락(일부 연락처 정보). 레이아웃은 매우 복잡하지 않아도 괜찮아요 — 상단에 헤더(제목과 탭 탐색이 포함됨), 하단에 푸터, 그리고 탭 내용 영역이 사이에 위치하면 되요.\n\n![이미지를 참조하세요](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_4.png)\n\n\n\n최대한 CSS를 활용하고, 탭 간 전환은 JavaScript를 사용하여 구현하고 싶습니다. 서브페이지는 없을 것이며, HTML 인덱스 파일 하나, JS 파일 하나, CSS 파일 하나, 이미지 파일 몇 개(두 개)로 구성될 것입니다. 프로젝트 트리 구조는 다음과 같습니다:\n\n```js\nproject-root/\n├── assets/\n│   ├── scripts.js\n│   ├── styles.css\n|   ├── bg.gif (페이지의 배경으로 사용됨)\n|   └── mk.jpg (제 얼굴이 있는 about 섹션용 이미지)\n|\n└── index.html\n```\n\n해당 페이지는 그때 시점에서 이용 가능한 모든 (두 개의) 중요 브라우저인 MS Internet Explorer 5 및 Netscape Navigator 4.51에서 잘 작동하고 멋지게 보여야 합니다.\n\n# 도구\n\n\n\n클래식 스타일로 가서 웹 사이트의 모든 코드를 MS 메모장에 작성할 수도 있습니다. 그러나 조금 더 전문적으로 하기 위해 실제 코드 편집기를 사용합시다. 처음에는 Notepad++를 선택할 생각이었지만, 2003년에 출시되었으므로 1999년에는 존재하지 않았습니다. 내 마음속에는 1996년부터 제공되었던 폴란드어 코드 편집기인 Pajączek (스파이더)이 그렇게 욕심이 났었지만, 폴란드어로만 제공되고 무료가 아니었던 것으로 기억합니다. 구글과 위키피디아에서 몇 분동안 검색한 후에 Arachnophilia를 발견했습니다. 1996년에 출시된 이 툴은 무료이고 영어로 되어 있으며 이름도 거미와 관련이 있습니다. 이 정도면 충분합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*fHIISJOsPFdxcPnjQsnCgw.gif)\n\n내 Windows 98은 프리인스톨된 인터넷 익스플로러(v5.0)가 함께 있었지만, 다른 앱들을 얻어야 했습니다 — 넷스케이프 네비게이터와 아라크노필리아. 당연히 23년 전에 사용 가능했던 버전이어야 했습니다. 옛 소프트웨어를 찾는 것은 어렵지만 일반적으로 oldversion.com이 시작하기에 좋은 장소입니다. 유감스럽지만 그 사이트에 접속하려고 할 때 며칠 동안 다운되었으며, 그것이 완전히 없어진 것으로 확신했습니다. 그러나 이 단어들을 입력하는 동안, 현재 그것이 다시 온라인 상태인 것처럼 보입니다.\n\n그럼에도 불구하고 다른 곳에서 검색해야 했습니다. \"Netscape 4.5 다운로드\"와 같은 구글에 입력된 구문은 첫 번째 페이지에서 만족스러운 결과를 제공하지 않을 뿐 아니라 전혀 만족스럽지 않을 것입니다. 따라서 주변을 더 들여다봐야 했습니다. 결국, archive.org 페이지에서 필요한 정보를 제공해주는 것을 찾을 수 있었고, 1999년 5월에 제공된 apcmag.cd 디스크 이미지를 발견했습니다. 이 이미지에는 Netscape Navigator v4.51과 Arachnophilia v3.9가 포함되어 있었습니다.\n\n\n\n![링크 이름](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_5.png)\n\n내 초기 큰 계획은 로컬 서버를 사용하고 웹사이트를 로컬호스트에서 실행하는 것이었습니다(심지어 Windows 98에 Apache와 PHP를 설치하는 방법에 대한 오래된 기사를 찾았어요). 그러나 이 정도 규모의 프로젝트에는 좀 압도당하는 느낌이었고, 결국 그 아이디어를 포기했어요. 어쩌면 언젠가는 더 고급스러운 레트로 웹 요소를 사용하는 백엔드 로직이 필요한 프로젝트에 도전할지도 모르겠지만, 현재로서는 프론트엔드에만 집중할 거예요.\n\n# Arachnophilia\n\n내가 선택한 코드 에디터에 대해 간단히 얘기해보죠. 이것은 예전에는 꽤 좋게 여겨졌을지도 모르지만, 지금은 조금 싸구려 느낌이에요. 그럼에도 불구하고 일반적인 MS 메모장보다는 더 많은 것을 제공해줘요 — HTML 기본 구문 강조 기능과 미리보기 기능이 있어요(버튼을 클릭하면 Arachnophilia가 현재 HTML 코드를 임시 파일에 저장하고 IE에서 미리보기를 열어줘요; 페이지를 저장할 때마다 다시 불러오는 기능을 제공한다고 주장하지만, 불행히도 그 기능은 제게는 작동하지 않았어요).\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_6.png)\n\nJS 및 CSS 파일을 지원하지는 않지만, .js 또는 .css 확장자가 있는 txt 파일로 만들어 코드를 작성할 수 있어요.\n\n새 HTML 파일을 만들 때 페이지 제목, 텍스트 및 링크 색상을 설정할 수 있는 프롬프트 창이 나타납니다. 입력하신 내용에 따라 Arachnophilia가 초기 HTML 코드를 생성해줘요. 제목이 head 섹션에 설정되고, 텍스트와 링크 스타일이 body 태그의 속성으로 추가됩니다 (그냥 그대로 남길 건 아니에요).\n\n초기 HTML 코드는 대문자 태그 이름으로 작성되어 있는데, 이 올드 스쿨 느낌이 나쁘지 않아요. 그대로 따라해 볼게요. 물론 자동 들여쓰기는 없답니다.\n\n\n\n\n![Website Screenshot](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_7.png)\n\n# 먼저 로직을 고민해보세요\n\n전체 페이지를 구현하기 전에 JavaScript로 무엇을 할 수 있는지 알아보고 싶어요. 제 목표는 JS로 제어되는 탭을 만드는 거에요. 네비게이션 링크를 클릭하면 해당 탭이 표시되고 다른 탭은 숨겨져야 해요.\n\n먼저 인터넷 익스플로러에 집중했어요. 개발 도구도 JS 콘솔도 없어요. 뭔가 에러가 나오면 IE는 하단 표시줄에 경고 아이콘을 보여주는데, 그것을 더블 클릭하면 더 자세한 정보를 확인할 수 있어요 — 에러 메시지와 발생 위치가 표시돼요.\n\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_8.png)\n\n나는 익숙치 않은 것이지만 여전히 상당히 도움이 되었어. 문제가 있을 때 구글링을 해보면 대부분 해결책을 찾을 수 있었어 (결과는 잊혀진 포럼에 있는 오래된 글들을 가리킴) 아니면 caniuse.com을 사용해서 해당 메소드가 사용 가능한지 알아볼 수 있었어 (해당 사이트는 IE v6 이상만 나열하지만 내 경험 상 \"6-8\"로 표시된 경우 IE v5에서도 작동했어).\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_9.png)\n\n여기에는 Internet Explorer 5를 위한 PoC JavaScript 개발 중 발견한 몇 가지 사항이 있어:\n\n\n\n\n- getElementsByClassName은 지원되지 않지만 getElementsByName은 잘 작동합니다 (따라서 모든 네비게이션 링크를 선택하는 데 사용했습니다)...\n- ... 하지만 DIV로는 작동하지 않았습니다 (따라서 탭 콘텐츠를 선택하는 데 사용할 수 없었습니다),\n- addEventListener는 존재하지 않지만 IE에는 해당하는 방법이 있습니다 — attachEvent— 적어도 두 개의 인수를 사용해야 합니다 — 이벤트 이름 (그러나 on으로 시작해야 하며, 예: click 대신에 onclick) 및 콜백 (이벤트 객체를 인수로 받지 않습니다),\n- anchorElement.getAttribute(`href`)은 href 속성에 할당된 값만이 아닌 전체 URL 경로를 반환합니다 (따라서 속성에 #foobar와 같은 값이 지정된 경우 로컬에서 C:\\\\…\\#foobar와 같은 결과가 나올 것입니다)\n\n제가 탭 컨셉을 테스트하기 위해 작성한 HTML입니다:\n\n```js\n\u003cA href=\"#tab0\" tab=\"tab0\" name=\"link\"\u003e링크 1\u003c/a\u003e\n\u003cA href=\"#tab1\" tab=\"tab1\" name=\"link\"\u003e링크 2\u003c/a\u003e\n\u003cA href=\"#tab2\" tab=\"tab2\" name=\"link\"\u003e링크 3\u003c/a\u003e\n\u003cDIV id=\"tab0\"\u003e콘텐츠 1\u003c/div\u003e\n\u003cDIV id=\"tab1\" style=\"display: none;\"\u003e콘텐츠 2\u003c/div\u003e\n\u003cDIV id=\"tab2\" style=\"display: none;\"\u003e콘텐츠 3\u003c/div\u003e\n```\n\n보다 의미론적으로 유지하기 위해 href 속성을 유지했지만, JS에서 탭 ID를 쉽게 가져오기 위해 사용자 정의 속성 tab이 필요했습니다.\n\n\n\n그리고 탭 간 전환을 제어하는 JavaScript 코드가 여기 있어요:\n\n```js\nvar tabLinks = document.getElementsByName('link');\nvar currentOpenTabElement = document.getElementById('tab0');\n\nfor (var i = 0; i \u003c tabLinks.length; i++) {\n tabLinks[i].addEventListener('click', createOnClickHandler(i));\n}\n\nfunction createOnClickHandler(tabLinkIndex) {\n var tabLink = tabLinks[tabLinkIndex];\n var tabId = tabLink.getAttribute('tab');\n \n return function() {\n  openTab(tabId);\n }\n}\n\nfunction openTab(tabId) {\n var tab = document.getElementById(tabId);\n currentOpenTabElement.style.display = 'none';\n tab.style.display = '';\n currentOpenTabElement = tab;\n}\n```\n\n그리고 솔직하게 말하자면 — 놀랍네요. 코드가 꽤 잘 작성되어 있고 제가 원하는 대로 작동합니다(탭 간 전환). 1999년, 인터넷 익스플로러이고 작동합니다. 정말 놀랍네요.\n\n# 넷스케이프 네비게이터 — 첫 영향\n\n\n\n내 코드가 인터넷 익스플로러에서 작동한다면, 넷스케이프 브라우저에서 어떤 문제가 발생할 수 있을까? — 나 자신에게 물었습니다. 90년대에는 심지어 가장 인기 있는 브라우저였지만, 나중에 인터넷 익스플로러에 밀려난 후에도 걱정할 것이 없다고 확신했습니다. 그래서 넷스케이프 네비게이터에서 내 페이지를 열어 보았더니...\n\n...탭 컨트롤이 작동하지 않았습니다.\n\n내 첫 번째 추측은 attachEvent가 인터넷 익스플로러 전용 기능이기 때문에 넷스케이프에서 작동하지 않을 것이라는 것이었습니다. 하지만 어떻게 확인할 수 있을까요? 넷스케이프에서 JS 오류 메시지를 출력하는 위치가 있을까요? JS 콘솔이 있을까요? 아니요. IE와 같이 하단 표시줄에 정보가 표시되는가요? 아니요. JS 코드를 실행할 때 문제가 발생했음을 나타내는 표시가 있나요? 음... 작동하지 않으니 어떤 종류의 피드백이지만, 아니요, 없습니다.\n\n그렇다면 넷스케이프 네비게이터 4.51에서 JavaScript를 디버깅하는 방법은 무엇일까요? 여러분이 직접 에러 처리를 해야 합니다 — 에러 메시지를 포함한 경고 창을 호출하는 window.onerror 핸들러를 추가하면 됩니다 (이 점은 제가 스스로 생각한 것이 아니라 여기에서 찾았습니다).\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_10.png\" /\u003e\n\n앗, 그래서 getElementsByName은 넷스케이프 시대에 존재하지 않았어요. 그럼 getElementsByClassName은 어때요? 아니요. 아마 getElementById는 최소한 있겠지요? 아니요. 넷스케이프 네비게이터는 '아니요'만 있는 건가요? 아뇨, 그러나 분명히 많은 것들을 막아요.\n\ncaniuse.com에서 지원 정보를 찾을 수 없어요. 인터넷에 남아 있는 것으로만 제한돼요. 다행히도 여기 유용한 리소스가 하나 있어요 — 1999년에 발행된 넷스케이프 커뮤니케이션즈 코퍼레이션의 Client-Side JavaScript 참조서(버전 1.3). 제가 사용할 수 있는 것에 대한 어떤 아이디어를 제공해줬어요. 오, 넷스케이프 버전의 JavaScript는 완전히 다른 이야기 같아요. document.ids나 document.classes와 같은 컬렉션이 있긴 하지만 — 보통은 몇 가지 기본 스타일을 설정할 수 있지만, 브라우저가 페이지를 로드할 때 단 한 번만 할 수 있어요.\n\n제 아이디어는 클릭 핸들러를 부착하는 것을 담당하는 onClick 속성을 사용하는 것이었어요(크로스 브라우저 솔루션이라서요). 그러나 작동하지 않았어요. 다시 한 번, 구글 삼촌에게 기대야 했어요. 몇 개의 오래된 기사를 찾았지만 대부분이 제게 아무 방향도 제시하지 않았어요. 마침내 제 날을 구해 준 이 기사를 찾았어요. 넷스케이프는 페이지 내 요소를 위치시키고 애니메이션을 주려고 만든 자체 레이어 HTML 태그를 소개했어요.\n\n\n\n`layer` 태그의 유일한 문제는 CSS의 절대 위치 지정과 같은 동작 방식을 가지고 있다는 것입니다 (부모 레이어나 창을 기준으로). 다행히 `ilayer` 태그도 있습니다. 이것은 인라인 레이어입니다. 더 유용할 수 있지만 여전히 한 가지 작은 문제가 있습니다 - 레이어의 가시성 속성이 CSS 가시성 속성처럼 작동한다는 것이죠. 이는 요소를 숨길 수 있지만 여전히 공간을 차지한다는 것을 의미합니다. 결과적으로 첫 번째 탭은 원하는 위치에 표시되지만 다른 탭들은 아래에 나타나 버리고 이는 보기 좋지 않을 것입니다. 이를 해결하기 위해 올바른 위치로 이동시키기 위해 음수의 상단 속성 값을 사용해야 합니다. 휴...\n\n그러면 크로스 브라우저 버전은 어떻게 보일까요? 먼저, 넷스케이프 브라우저인지 확인하기 위해 문서의 `head`에 일부 인라인 스크립트를 추가해야 했습니다:\n\n```js\n\u003cSCRIPT\u003e\n   var probablyNetscape = !!document.layers \u0026\u0026 !!document.classes \u0026\u0026 !!document.ids;\n\u003c/SCRIPT\u003e\n```\n\n왜 페이지를 방문하는 브라우저를 확인하기 위해 navigator 속성을 사용하지 않았을까요? navigator.appName은 Netscape를 반환합니다. 그런데 2023년에는 Chrome도 반환합니다. navigator.userAgent는 Mozilla v4.51을 반환하는데, 이것은 더 구체적이지만 완전히 신뢰할 수 없습니다. document가 layers와 같은 속성을 가지고 있는지 확인하면, 이 속성들은 완전히 넷스케이프와 관련된 것들이므로 더 신뢰할 수 있습니다.\n\n\n\n어쨌든 - 나는 scripts.js 파일과 HTML에서 probablyNetscape인지를 사용할 거야. HTML에 대해 얘기하면, 여기 있어:\n\n```js\n\u003cA href=\"#tab0\" onClick=\"tabLinkClickHandler('tab0')\"\u003e링크 1\u003c/A\u003e\n\u003cA href=\"#tab1\" onClick=\"tabLinkClickHandler('tab1')\"\u003e링크 2\u003c/A\u003e\n\u003cA href=\"#tab2\" onClick=\"tabLinkClickHandler('tab2')\"\u003e링크 3\u003c/A\u003e\n\u003cDIV\u003e\n  \u003cILAYER name=\"tab0\" style=\"display: block;\"\u003e\n    \u003cDIV id=\"tab0\"\u003e콘텐츠 1\u003c/DIV\u003e\n  \u003c/ILAYER\u003e\n  \u003cILAYER name=\"tab1\" visibility=\"hide\" style=\"display: block;\"\u003e\n    \u003cDIV id=\"tab1\"\u003e콘텐츠 2\u003c/DIV\u003e\n  \u003c/ILAYER\u003e\n  \u003cSCRIPT\u003eif (!probablyNetscape) {document.getElementById('tab1').style.display = 'none';}\u003c/SCRIPT\u003e\n  \u003cILAYER name=\"tab2\" visibility=\"hide\" style=\"display: block;\"\u003e\n    \u003cDIV id=\"tab2\"\u003e콘텐츠 3\u003c/DIV\u003e\n  \u003c/ILAYER\u003e\n  \u003cSCRIPT\u003eif (!probablyNetscape) {document.getElementById('tab2').style.display = 'none';}\u003c/SCRIPT\u003e\n\u003c/DIV\u003e\n```\n\n보다시피, 내가 사용한 일부 인라인 스크립트로 브라우저가 Netscape가 아닌 경우에 초기에 숨겨져야 하는 탭에 display: none 스타일을 추가했어. 이걸 한 이유는 Netscape Navigator에서 JS로 display 속성을 수정하는 기능이 제대로 작동하지 않기 때문에(따라서 제거할 수 없었어), 그리고 가능한 빨리 저런 탭들을 숨기고 싶었기 때문이야(scripts.js가 로드되기 전에).\n\nvisibility나 top 같은 `ILAYER` 속성들은 Netscape에서만 이해될 거야. 다른 브라우저들은 이를 무시할 거야 (응, IE 5는 이를 무시하니까, 미래 브라우저들도 그럴 걸 바래).\n\n\n\n탭 탐색을 위한 링크에는 클릭 핸들러가 할당된 onClick 속성이 있습니다. 이 클릭 핸들러는 scripts.js 파일에 정의되어 있어요:\n\n```js\nvar activeTab = 'tab0';\n\nif (probablyNetscape) {\n  window.onerror = function(message, file, line) {\n   alert('JavaScript error!\\nFile: ' + file + '\\nLine: ' + line + '\\nMessage: ' + message);\n  }\n\n  // Netscape Navigator에서 레이어의 위치 설정\n  document.layers.tab1.top = -38;\n  document.layers.tab2.top = -76;\n}\n\nfunction tabLinkClickHandler(tab) {\n  if (tab === activeTab) return;\n\n  if (probablyNetscape) {\n    document.layers[activeTab].visibility = 'hide';\n    document.layers[tab].visibility = 'show';\n  } else {\n    document.getElementById(activeTab).style.display = 'none';\n    document.getElementById(tab).style.display = 'block';\n  }\n \n  activeTab = tab;\n}\n```\n\n아, 그리고 알아요 — 누군가가 스크립트 파일이 로드되기 전에 링크를 클릭하면 오류가 발생할 거라는 거, 그러니까 이 시점에서 제 스크립트 코드를 단순히 index.html 파일에 모두 넣을 수도 있지만... 전 그냥 이렇게 하고 싶어요.\n\n그리고 이제... 웹 브라우저 간의 개념 증명이 동작하는 레이아웃과 CSS 스타일링 작업을 할 시간이 왔어요! 아하 — Netscape Navigator 덕분에 조금 짜증이 나긴 했지만요. 지금은 편안한 파트인 레이아웃과 CSS 스타일링을 하는 시간이죠!\n\n\n\n# 잘 하고 있어요\n\n배운 것이 있어요 — IE5를 위해 특별히 무언가 개발한 다음에 Netscape Navigator에 맞추려고 하면 완전히 다른 코드를 얻게 될 것 같아요. 처음부터 두 브라우저에서 모두 작동하는 솔루션을 찾아야 한다는 걸 이해했어요.\n\n사용하고 싶은 HTML 구조와 CSS 스타일에 대한 아이디어가 있어서, 크로스 브라우저화를 위해 차근차근 작업하기 시작했어요. 이제 1999년에 HTML 레이아웃을 스타일링하는 미친 듯한 이야기를 들려줄게요.\n\n마진 왼쪽과 오른쪽을 자동으로 설정하여 요소를 가운데 정렬하는 것은 작동하지 않아요. `center` 태그나 `align=\"center\"` 속성이 있는 `div`의 두 가지 가능한 해결책이 있어요. 이 요소는 페이지 내용 컨테이너를 감싸야 해요 (너비는 480픽셀로 설정된 상태지요). 양쪽 브라우저에서도 내용을 가운데 정렬하기 위해서 IE는 후손의 내용도 가운데 정렬하기 때문에 페이지 컨테이너에 왼쪽으로 정렬 속성을 설정할 수 있어요. 하지만 Netscape는 전체 컨테이너를 왼쪽으로 이동시키기 때문에 이를 올바르게 만들려면 (내용은 왼쪽에 있지만) 왼쪽으로 정렬된 세 번째 컨테이너가 필요해요. 이해를 돕기 위한 코드를 여기에 제시할게요:\n\n\n\n```js\n\u003cDIV align=\"center\"\u003e\n  \u003c!-- styles.css에서 너비가 480픽셀로 설정되어 있음 --\u003e\n    \u003cDIV class=\"page-container\"\u003e\n      \u003cDIV align=\"left\"\u003e...\u003c/DIV\u003e\n    \u003c/DIV\u003e\n\u003c/DIV\u003e\n```\n\nCSS 플렉스박스 (그리드 시스템도 마찬가지)는 항상 사용 가능했던 것은 아니었습니다. 웹 개발을 한지 ~10년 이상이 된다면 아마도 그리드 레이아웃을 만들기 위해 개발자들이 float 속성을 사용했다는 것을 기억하실 것입니다 (Bootstrap도 그렇게 했습니다). 원래 float를 그 용도로 사용하도록 의도되지 않았지만, 개발자들이 그것을 웹사이트 레이아웃 스타일링 역사에서 상당히 중요한 위치에 부여해 왔다고 생각합니다.\n\n어쨌든, 탭 컨트롤(링크)을 정렬하기 위해 float를 사용했습니다. 여기에는 ul 및 li 태그를 사용하고 싶었지만, Netscape는 float와 목록 요소 조합을 좋아하지 않는 것 같습니다... 게다가, anchor 태그에 직접 float 스타일을 사용하면 모든 기본 앵커 스타일이 제거될 것입니다 (Netscape에 대해서 말하는 것이고, IE에서는 모두 잘 작동합니다). DIV 기반의 목록을 사용하게 되었습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_11.png\" /\u003e\n\n\n\n\nCSS로 설정된 DIV의 배경색은 넷스케이프 네비게이터 v4.51에서 심각한 문제입니다. CSS border 속성을 none으로 설정하지 않으면 (또는 다른 방법으로 설정하면, 그냥 테두리 스타일이 필요합니다) DIV 내부의 텍스트만 원하는 배경색이 적용됩니다 (일종의 텍스트 강조 스타일처럼).\n\n![이미지1](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_12.png)\n\n![이미지2](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_13.png)\n\n배경 이미지를 설정하려고 하니 또 다른 머리 아픔이 들었습니다. IE는 이미지(bg.gif) 경로가 styles.css 파일과 상대적이어야 하며 (그래서 url(`bg.gif`)이 괜찮음), 그러나 넷스케이프는 index.html 파일을 기준으로 상대적이어야 한다고 예상합니다 (url(`assets/bg.gif`)). 여기서 가장 간단한 해결책은 body 스타일 속성에서 배경을 직접 설정하는 것입니다 (물론 index.html을 기준으로 경로 설정 필요).\n\n\n\n내비게이션 작업 중에는 연결된 탭이 열릴 때 링크 스타일을 변경하고 싶었어요. Netscape의 제한 때문에 (i)layer 태그를 사용해야 했고, HTML을 수정하는 중에 Netscape가 치명적인 오류를 일으켰어요.\n\n```js\n...\n\u003cdiv class=\"tab-control\"\u003e\n  \u003cilayer name=\"start-link\" class=\"tab-control-layer\"\u003e\n    \u003cdiv class=\"tab-control-inner\"\u003e\n      \u003ca href=\"#start\" id=\"start-link\"\u003e시작\u003c/a\u003e\n    \u003c/div\u003e\n  \u003c/ilayer\u003e\n\u003c/div\u003e\n...\n```\n\n아마도 CSS와도 관련이 있었던 것 같아요. 하지만 그 부분은 확인하지 않았어요.\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_14.png\" /\u003e\n\n\n\n다음 문제는 여백입니다. 좀 더 명확하게 하죠: 넷스케이프 네비게이터 v4.51의 여백에 대해 말이죠. 모든 곳에 margin: 0을 설정할 수 있지만 넷스케이프는 신경쓰지 않아요. 그저 더 잘 알고 있는 거죠. 여백이 반드시 필요한거거든요. 물론 해결책은 있어요 — 음수 값 사용하기. 그러나 이렇게 하면 다른 브라우저(IE)에도 영향을 미치고, 다른 브라우저들은 'ZERO는 ZERO' 라는 거 알거든요. 여백은 없어! 넷스케이프, 너 뭘 하는 거야?\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_15.png)\n\n이 순간에 저는 넷스케이프 버전의 사이트를 내가 원하는 만큼 잘 만들지 못할 거라고 깨달았어요. 그래서 따로 스타일을 사용해야 했죠. 어떻게 구분할까요? 첫 번째 생각은 넷스케이프 브라우저가 아닐 때 body에 추가적인 클래스를 JavaScript로 추가하는 거였는데 (넷스케이프 JS 버전에서 클래스 이름을 설정할 수 없어요), 그러나 넷스케이프 네비게이터 4가 너무 망가져 있어서, 무시될 스타일이 쉽게 설정될 수 있다는 걸 알게 됐어요. html을 하위 선택자로 사용하면 될 거에요, 왜냐하면 넷스케이프는 이걸 유효한 것으로 인식하지 않거든요.\n\n나의 페이지를 위해 CSS를 작업하면서 넷스케이프 네비게이터 4에는 얼마나 많은 것들이 망가져 있는지 깨달았어요. 예를 들어, 모든 선택자는 한 번만 사용할 수 있고, 복합 선택자는 환영받지 않아요(.class.with-other-class 같은 것은 통하지 않아요).\n\n\n\n위 이미지에서 보이는 탭 링크들 사이의 공백을 제거할 수 없었어요.\n\n물론 Internet Explorer 5도 몇 가지 예상치 못한 동작이 있어서 완벽하지 않지만, Netscape Navigator 4는 정말 순수한 미쳤다고 해야 할까요.\n\nIE에 대해 이야기하자면 – 페이지 제목 아래 왼쪽에서 오른쪽으로 계속 슬라이딩하는 캐치프레이즈 (Welcome to 1999!)의 간단한 애니메이션을 구현하고 싶었어요. 그 목적으로 setInterval을 사용했는데, 콜백으로 익명 함수를 전달하면 IE가 몇 초 후에 크래시되는 문제가 발생했어요.\n\n```js\n// IE5 KILLER\nsetInterval(function() {...}, 100);\n```\n\n\n\nmd\n![198.png](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_16.png)\n\n함수를 먼저 정의하고, 그 후에 setInterval에 전달하는 것이 올바른 방법입니다.\n\n```js\n// 잘했어요!\nfunction animateCatchphrase() {...}\n\nsetInterval(animateCatchphrase, 100);\n```\n\n내 예상은 익스플로러가 익명 함수의 경우 메모리 관리에 문제가 있는 것 같습니다. 넷스케이프 네비게이터는 이런 문제가 없네요. 멋진 일이죠 넷스케이프, 그리핀도르에 10 포인트 들어가요.\n\n\n\n\n# 마침내\n\n내 1999페이지 프로젝트 작업 중 겪은 모든 문제를 설명하고 싶다면 책을 쓰는 수밖에 없을 것 같아. 이미 가장 흥미로운(짜증나는) 부분을 이미 알려준 것 같아. 하지만 믿어줘 — 당연히 더 많은 문제가 있어, 예를 들어 단락 스타일링 문제 — 이 경우에 나는 빨리 포기하고 DIV 대신 사용했어.\n\n어쨌든 몇 시간을 투자한 후에 내 페이지는 준비되었고 인터넷 익스플로러 5와 넷스케이프 네비게이터 4.51에서 작동했어.\n\n페이지를 실행하는 데 필요한 모든 파일의 총 크기는 ~42KB(압축되지 않은 html, css, js 및 두 이미지)야. 1999년도 인터넷 연결 평균 속도에 대한 신뢰할만한 정보를 찾을 수 없어서, 1990년대 후반에 56 kbit/s 속도를 달성할 수 있는 전화 기반 모뎀을 사용하여 데이터를 모두 받는 데 걸리는 시간을 계산해보자 — 그런 종류의 장치(최대 속도로 작동 중인)로는 모든 데이터를 가져오는 데 6초가 걸릴 것이야. 1999년에는 아마 수용 가능했을 거야.\n\n\n\n전체 코드를 여기에 붙여 넣지 않을 거예요 (길고 지루하거든요), Github 저장소 링크는 아래 어딘가에 있을 걸거에요. 이제 윈도우 98에서 촬영한 페이지의 몇 가지 스크린샷을 보겠습니다.\n\n## 인터넷 익스플로러 5\n\n![인터넷 익스플로러 5](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_17.png)\n\n![인터넷 익스플로러 5](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_18.png)\n\n\n\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_19.png)\n\n정말로 Internet Explorer에서 어떻게 끝났는지 정말로 자랑스럽다고 말해야겠어. 내가 원하는 대로 보이고 작동한다.\n\n## 넷스케이프 네비게이터 4.51\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_20.png)\n\n\n\n\n\n![](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_21.png)\n\n![](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_22.png)\n\nNetscape Navigator 버전에서 몇 가지 결함이 보입니다... 콘텐츠 섹션과 탭이 깨져 보이며, IE에서 달성한 것과 가능한 한 유사하게 보이도록 시간을 많이 들여 노력했지만 결국 실패했습니다... LAYERs로 모든 것을 수행했다면 성공했을지도 모르겠지만, 그것은 지나치게 복잡한 작업처럼 들립니다.\n\n# 미래로의 회귀\n\n\n\n\n2023년으로 돌아가서 구글 크롬과 같은 현대적 브라우저에서 내 페이지를 열어보세요.\n\n![이미지](/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_23.png)\n\n보기에는 작아 보이지만, 그 외엔 모든 것이 잘 보이고 작동합니다. 콘텐츠 상자의 크기에는 작은 문제가 하나 있어요 (오른쪽 하단 회색 상자를 보면 쉽게 알 수 있어요. 죄송하지만, 텍스트 버튼의 번역을 추천해 주실 수 있을까요? - Deepl Chat Team). 페이지 래퍼의 너비는 480px이고, 페이지 래퍼 내부의 콘텐츠 상자도 각쪽에 10px의 패딩을 가진 480px의 너비를 갖고 있어요. 이렇게 1999년에는 괜찮았지만 (IE와 넷스케이프 모두 버그라고 생각하지만), 이제는 콘텐츠 상자의 전체 너비가 500px (양쪽 투명도와 뉴스의 합)인 것이 더 예상됩니다. 다음 세 줄의 CSS 코드로 이 문제를 해결할 수 있어요:\n\n```css\n* {\n  box-sizing: border-box;\n}\n```\n\n\n\n옛날 브라우저들은 이해하지 못할 것이기 때문에 거기에는 아무것도 깨지지 않아야 합니다. 추가적인 변경 사항은 필요하지 않습니다(음, EU에 존재하는 GDPR 법에 따라 개인 정보 보호 정책에 대한 간단한 정보를 추가해야 합니다).\n\n만약 여러분이 이 페이지를 직접 확인하고 싶다면, 1999.mihau.co에 공개되어 있으며, 코드는 Github 저장소에서 찾을 수 있습니다.\n\n# 마지막으로\n\n이 작고 간단한 웹사이트를 만드는 데 처음에 예상한 것보다 훨씬 더 많은 시간이 걸렸는데, 그것은 작업 추정이 제 자신이 못하는 것 때문이 아니라서입니다(음, 가끔 그럴 때도 있긴 하지만, 이번엔 제 잘못이 아니었습니다). 현대 브라우저와 비교했을 때 인터넷 익스플로러 5의 가능성은 당연히 더 많이 부족하지만, 그것은 제가 알고 있던 세계와 비슷했습니다. 넷스케이프 네비게이터 4.51은 완전히 다른 우주였습니다. 매우 제한된 DOM 조작 및 이벤트 처리 능력을 가졌으며, CSS는 완전히 망가진 것처럼 느껴졌습니다(여기서 모든 버그가 설명되어 있습니다).\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_24.png\" /\u003e\n\n하지만 멈춰. 내가 그것에 대해 많이 불평했다. 나는 폴란드 사람이라 불평하는 것이 내 DNA에 새겨져 있는데, 이제는 그만이야. 여기에 몇 가지를 이해해보려고 해봅시다.\n\n우선, 그것은 1999년이었습니다. 초기 2000년대에도 테이블 레이아웃과 스타일링을 위한 속성이 CSS보다 더 인기가 있었다고 생각합니다. 그리고 콘텐츠 자체가 외모보다 중요했습니다. 자바스크립트? 상대적으로 새로운 기술이었고 표준화가 부족했습니다. 넷스케이프에서 나왔고, 마이크로소프트는 자체 버전을 구현했는데, 다른 API와 더 많은 가능성을 제공했습니다. 그리고 어차피 그 때는 플래시가 더 인기가 있었습니다.\n\n둘째로 — 4.51은 주요 버전이 아니었습니다, 인터넷 익스플로러 5가 주요 버전이었습니다. 넷스케이프가 네비게이터 v5에서 많은 것을 개선했고 수정했다고 강력히 믿습니다(2000년에 출시). 음, 확인은 안 해봤지만 언젠가는 시도해볼지도 몰라요.\n\n\n\n어쨌든, 고장 나서프 브라우저로 인한 모든 좌절에도 불구하고, 그것은 여전히 시간을 여행하는 즐거운 경험이었습니다. 이제는 미래로 돌아가서 이 쓰레기를 버리는 것보다 자주 업데이트되는 모든 JS 프레임워크와 브라우저들과 함께 긴행복한 삶을 살 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png"},"coverImage":"/assets/img/2024-05-14-Howtocreateapersonalwebsitebutits1999_0.png","tag":["Tech"],"readingTime":19},{"title":"IT 초보자 시리즈 JavaScript IF ELSE 연습문제 2","description":"","date":"2024-05-14 15:44","slug":"2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2","content":"\n\n![2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png](/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png)\n\n## IT 초보자 시리즈 소개\n\n- JavaScript FOR 루프 연습\n- SQL 연습\n\n프로그래밍을 배우는 여정에 착수하면서 조건문을 이해하는 것이 중요한 단계입니다. 이러한 문장은 특정 조건에 따라 코드의 흐름을 지시하는 결정 구조를 만들 수 있게 해줍니다. 이 IT 초보자 시리즈에서는 프로그래밍 논리의 핵심인 JavaScript if/else 문에 대해 자세히 살펴보고, 사용법을 효과적으로 이해할 수 있도록 10가지 간단한 연습 문제를 제공할 것입니다.\n\n\n\n# 소개\n\n프로그래밍의 영역에서 제어 흐름은 중요합니다. 특정 상황에서 어떤 코드가 실행되어야 하는지 지시할 수 있는 능력이 필요합니다. 여기서 조건문이 필요합니다. JavaScript는 if/else 문을 사용하여 정확히 그 목적을 달성할 수 있는 강력한 도구를 제공합니다. 이 문은 조건에 따라 코드가 선택되도록 해주어 해당 조건이 충족되는지에 따라 특정 코드 블록을 실행할 수 있게 합니다.\n\n# 구문\n\n연습을 시작하기 전에 JavaScript if/else 문의 구문을 익혀봅시다.\n\n\n\n```js\nif (condition) {\n  // 조건이 참인 경우 실행할 코드\n} else {\n  // 조건이 거짓인 경우 실행할 코드\n}\n```\n\n조건은 true 또는 false로 평가되는 논리식입니다. 조건이 참이면 첫 번째 블록 내의 코드가 실행됩니다. 조건이 거짓이면 else 블록 내의 코드가 실행됩니다 (해당할 경우).\n\n# 연습문제\n\n이제 if/else 문장을 직접 실습하며 경험을 쌓아보겠습니다. 각 연습문제에는 시나리오, 코드 솔루션 및 기대되는 출력이 제공됩니다.\n\n\n\n# 운동 목록\n\n- 주어진 숫자가 양수인지 음수인지를 결정하는 프로그램을 작성하십시오.\n- 주어진 숫자가 짝수인지 홀수인지를 확인하는 프로그램을 작성하십시오.\n- 두 숫자 중 더 큰 숫자를 결정하는 프로그램을 작성하십시오.\n- 숫자 등급을 문자 등급으로 변환하는 프로그램을 작성하십시오 (예: 등급 10은 \"A\"로 표시).\n- 나이에 따라 티켓 가격을 계산하는 프로그램을 작성하십시오. 다음 조건에 따라 나이가 12세 미만인 경우 티켓 가격은 5, 18세 미만인 경우 티켓 가격은 10, 60세 미만인 경우 티켓 가격은 20, 60세 이상인 경우 티켓 가격은 15입니다.\n- 윤년인지를 결정하는 프로그램을 작성하십시오.\n- 구매 금액에 따라 할인율을 계산하는 프로그램을 작성하십시오. 100 이상의 금액은 20의 할인율이 적용되며, 50 이상의 금액은 10의 할인율이 적용됩니다. 그 이외의 경우 할인율은 0입니다.\n- 사용자가 실행 시간에 따라 인사하는 프로그램을 작성하십시오. 실행할 때 시간에 따라 good morning, good afternoon 또는 good evening을 표시하십시오.\n- 체질량 지수 (BMI)를 계산하고 분류하는 프로그램을 작성하십시오. BMI 공식은 다음과 같습니다: 체중 / (키 * 키).\n- 간단한 숫자 추측 게임을 작성하십시오. 비밀 숫자와 추측 값을 제공하십시오. 이 숫자를 기반으로 그들의 추측이 더 높음, 더 낮음 또는 정확한지에 대한 단서를 제공하십시오.\n\n# 운동 솔루션 — 스포일러 주의, 아래에 솔루션 있음\n\n## 운동 #1 — 숫자가 양수인지 확인하기\n\n\n\n시나리오: 주어진 숫자가 양수인지 아닌지를 결정하는 프로그램을 작성해보세요.\n\n해결책:\n\n```js\nvar number = 5;\n\nif (number \u003e 0) {\n  console.log(\"주어진 숫자는 양수입니다.\");\n} else {\n  console.log(\"주어진 숫자는 양수가 아닙니다.\");\n}\n```\n\n결과:\n\n\n\n```js\n숫자는 양수입니다.\n```\n\n## 연습 #2 — 짝수 또는 홀수 확인하기\n\n시나리오: 숫자가 짝수인지 홀수인지 확인하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar number = 7;\nif (number % 2 === 0) {\n  console.log(\"숫자는 짝수입니다.\");\n} else {\n  console.log(\"숫자는 홀수입니다.\");\n}\n```\n\nOutput:\n\n```js\n숫자는 홀수입니다.\n```\n\n## 연습 문제 #3 — 더 큰 숫자 결정하기\n\n\n\n시나리오: 두 숫자 중 큰 값을 결정하는 프로그램을 작성하시오.\n\n해결책:\n\n```js\nvar num1 = 10;\nvar num2 = 15;\n\nif (num1 \u003e num2) {\n  console.log(\"num1 is greater.\");\n} else {\n  console.log(\"num2 is greater.\");\n}\n```\n\n출력:\n\n\n\n```js\nnum2가 더 큽니다.\n```\n\n## Exercise #4 — 성적 계산기\n\n시나리오: 숫자 등급을 기반으로 글자 등급을 할당하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar score = 85;\nvar grade;\n\nif (score \u003e= 90) {\n  grade = \"A\";\n} else if (score \u003e= 80) {\n  grade = \"B\";\n} else if (score \u003e= 70) {\n  grade = \"C\";\n} else if (score \u003e= 60) {\n  grade = \"D\";\n} else {\n  grade = \"F\";\n}\nconsole.log(\"Grade: \" + grade);\n```\n\nOutput:\n\n```js\nGrade: B\n```\n\n## Exercise #5 — 티켓 가격 설정\n\n\n\n시나리오: 연령에 따라 티켓 가격을 계산하는 프로그램을 작성합니다.\n\n해결책:\n\n```js\nvar age = 25;\nvar ticketPrice;\n\nif (age \u003c 12) {\n  ticketPrice = 5;\n} else if (age \u003e= 12 \u0026\u0026 age \u003c 18) {\n  ticketPrice = 10;\n} else if (age \u003e= 18 \u0026\u0026 age \u003c 60) {\n  ticketPrice = 20;\n} else {\n  ticketPrice = 15; // 노인 할인\n}\nconsole.log(\"티켓 가격: $\" + ticketPrice);\n```\n\n출력:\n\n\n\n```js\n티켓 가격: $20\n```\n\n## 연습 #6 — 윤년 판별\n\n시나리오: 주어진 해가 윤년인지 판별하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar year = 2024;\n\nif (year % 4 === 0 \u0026\u0026 (year % 100 !== 0 || year % 400 === 0)) {\n  console.log(year + \"은 윤년입니다.\");\n} else {\n  console.log(year + \"은 윤년이 아닙니다.\");\n}\n```\n\n결과:\n\n```js\n2024은 윤년입니다.\n```\n\n## 연습 #7 — 쇼핑 할인\n\n\n\n시나리오: 구매 금액에 따라 할인을 계산하는 프로그램을 작성해 보세요.\n\n솔루션:\n\n```js\nvar purchaseAmount = 120;\nvar discount;\n\nif (purchaseAmount \u003e= 100) {\n  discount = 20;\n} else if (purchaseAmount \u003e= 50) {\n  discount = 10;\n} else {\n  discount = 0;\n}\nconsole.log(\"Discount: \" + discount + \"%\");\n```\n\n출력:\n\n\n\n```js\n할인: 20%\n```\n\n## 연습 #8 — 시간대에 따른 인사\n\n시나리오: 사용자를 시간대에 따라 인사하는 프로그램을 작성하십시오.\n\n해결책:\n\n\n\n```js\nvar currentTime = new Date();\nvar currentHour = currentTime.getHours();\nvar greeting;\n\nif (currentHour \u003c 12) {\n  greeting = \"Good morning!\";\n} else if (currentHour \u003c 18) {\n  greeting = \"Good afternoon!\";\n} else {\n  greeting = \"Good evening!\";\n}\nconsole.log(greeting);\n```\n\n위 코드를 실행하는 시간대에 따라 출력 결과가 달라집니다:\n\n```js\nGood afternoon!\n```\n\n## Exercise #9 — BMI Calculator\n\n\n\n\n시나리오: 체질량 지수(BMI)를 계산하고 그에 따라 분류하는 프로그램을 작성해봅시다.\n\n해결책:\n\n```js\nvar weight = 70; // 킬로그램 단위\nvar height = 1.75; // 미터 단위\nvar bmi = weight / (height * height);\nvar category;\n\nif (bmi \u003c 18.5) {\n  category = \"저체중\";\n} else if (bmi \u003c 24.9) {\n  category = \"정상 체중\";\n} else if (bmi \u003c 29.9) {\n  category = \"과체중\";\n} else {\n  category = \"비만\";\n}\nconsole.log(\"BMI: \" + bmi.toFixed(2)); // .toFixed(2)를 사용하여 소수점 둘째 자리까지만 출력\nconsole.log(\"분류: \" + category);\n```\n\n출력:\n\n\n\n```js\n체질량 지수: 22.86\n카테고리: 정상 체중\n```\n\n## 연습 10 — 숫자 맞히기 게임\n\n시나리오: 간단한 숫자 맞히기 게임을 작성하세요.\n\n해결책:\n\n\n\n```js\nvar secretNumber = 7;\nvar guess = 5; // 플레이어가 추측한 숫자, 이 값을 변경해보면 조건에 따라 다른 코드 라인이 실행됩니다.\nif (guess === secretNumber) {\n  console.log(\"축하합니다! 정답을 맞췄습니다.\");\n} else if (guess \u003c secretNumber) {\n  console.log(\"숫자를 더 높게 시도해보세요.\");\n} else {\n  console.log(\"숫자를 더 낮게 시도해보세요.\");\n}\n```\n\n출력 (플레이어의 추측에 따라):\n\n```js\n숫자를 더 높게 시도해보세요.\n```\n\n# 결론\n\n\n\n축하합니다! IT 초보자 시리즈의 JavaScript if/else 연습을 모두 완료했어요. 코드에서 결정을 내리기 위해 조건문을 사용하는 실전 경험을 쌓았습니다. 이 연습을 통해 if/else 문이 어떻게 작동하는지 이해하는 데 튼튼한 기초를 제공했습니다.\n\n행운을 빕니다,\n안드레이\n\n## IT 초보자 시리즈에서 더 알아보기\n\n- JavaScript FOR 루프 연습\n- SQL 연습","ogImage":{"url":"/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png"},"coverImage":"/assets/img/2024-05-14-ITBeginnerSeriesJavaScriptIFELSEExercises2_0.png","tag":["Tech"],"readingTime":6},{"title":"새로운 Nodejs 테스트 러너 사용 방법","description":"","date":"2024-05-14 15:43","slug":"2024-05-14-HowtoUsetheNewNodejsTestRunner","content":"\n\nNode.js 20 버전이 출시되면서 Node.js 18의 실험적인 테스트 러너가 안정 상태를 달성했습니다. 우리의 코드를 테스트하기 위해 이 새로운 테스트 러너를 어떻게 사용할 수 있는지 살펴봅시다.\n\n이 테스트 러너는 test 및 describe/it 스타일 테스트를 지원하며, mocking, 여러 테스트 리포터 및 코드 커버리지도 포함하지만, 커버리지는 아직 실험 단계입니다.\n\n![이미지](/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png)\n\n가장 일반적인 사용 사례 중 하나인 서비스 계층 테스트 및 fetch 함수 모의(mock)에 대해 알아보겠습니다. 이 안내서는 A부터 Z까지 실전 예제를 제공할 것입니다.\n\n\n\n다음 명령을 터미널에서 실행하여 올바른 Node.js 버전을 사용하는지 먼저 확인해 보세요. \"v20\" 버전이 표시되어야 합니다. 다른 버전이 실행 중이라면 nvm을 사용하여 버전 20을 설치해주세요.\n\n```js\nnode -v\n// v20.4.0\n```\n\n우리가 테스트할 코드는 매우 간단한 데이터 검색 함수입니다. 이는 우리가 매일 작성하는 코드에서 매우 흔하게 사용됩니다. 이 예제는 100% 완벽하지는 않지만 이 글의 예시로는 충분히 작동할 것입니다. fetch를 종속성으로 사용한다는 점을 볼 수 있으므로 모의(mocking) 작업이 필요함을 알 수 있습니다.\n\n```js\nexport const getUserById = async(id)=\u003e{\n\n  const res = await fetch(`www.example.com/users/${id}`)\n  if(res.ok){\n    const contents = await res.json();\n    return contents.payload;\n  }\n  throw new Error('request failed');\n}\n```\n\n\n\n우리는 데이터 검색이 성공적이고 값을 반환하는 \"happy path\"와 오류가 발생하는 실패 조건을 테스트해야 합니다.\n\nget-user.test.mjs라는 테스트 파일을 생성해야 합니다. 우리는 node:test에서 사용할 함수들과 node:assert에서 assert 함수를 가져와야 합니다. 마지막으로, 테스트하고자 하는 함수를 가져와야 합니다.\n\n```js\nimport { describe, it } from 'node:test';\nimport assert from 'node:assert'\nimport { getUserById } from './index.mjs';\n```\n\n이러한 임포트가 완료되었으므로, 이제 우리는 테스트를 작성할 수 있습니다. 익숙한 describe/it 패턴을 가져왔지만, 만족하는 경우에는 단순히 test를 함수로 가져올 수도 있습니다.\n\n\n\n\ngetUserById 함수에 대한 행복한 시나리오 테스트가 있습니다. 저희 함께 살펴보죠. it 함수에는 테스트의 컨텍스트인 매개변수 t를 사용하는 콜백이 포함되어 있습니다. 이 컨텍스트에는 함수를 모킹하는 데 사용할 수 있는 mock 속성이 있습니다. 이 경우에는 fetch 함수를 모킹합니다.\n\nJest를 사용한 적이 있는 사람들에게 친숙한 mockImplementationOnce 메서드가 여기서 fetch 함수를 모킹하는 데 사용됩니다.\n\n이제 테스트 대상 함수를 호출하고 내장된 assert를 사용하여 결과를 확인할 수 있습니다.\n\n\n\n\n## 더 알아보기:\n\n## 에러 케이스 테스트\n\n이제 행복한 경로를 테스트했으니 100% 커버리지를 달성하기 위해 에러 케이스를 테스트해야 합니다.\n\n```js\n    it('ok이 아닌 경우 에러를 throw 해야 합니다', async (t) =\u003e {\n        const fn = t.mock.method(global, 'fetch');\n\n        fn.mock.mockImplementationOnce(() =\u003e\n            Promise.resolve({\n                ok: false,\n            })\n        );\n        await assert.rejects(async () =\u003e {\n            return await getUserById(2)\n        },\n        {\n            name: 'Error',\n            message: 'request failed',\n        });\n    });\n```\n\n\n\n우리는 지금 ok===false를 반환하는 모의 객체를 만들었습니다. 이것은 함수가 오류를 반환하는 결과를 가져옵니다. assert.rejects 함수는 이를 쉽게 파악하는 데 훌륭하며 오류 메시지를 정확하게 테스트할 수 있습니다. 작업을 마쳤습니다. 이제 테스트를 실행하는 방법을 살펴봅시다.\n\n# 테스트 실행하기\n\n테스트 실행은 쉽기만 하면서도 원시 구현에서 기대할 수 있는 것처럼 놀랍게 빠릅니다.\n\n파일 이름이 filename.test.js인 모든 테스트 파일을 실행하려면 터미널에서 다음을 실행하면 됩니다:\n\n\n\n```js\n노드 --test\n```\n\n제 노트북(라이젠 7과 리눅스 장착)에서 이 간단한 테스트는 150밀리초 이내에 실행되는데, 정말 빠릅니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_1.png\" /\u003e\n\n# 코드 커버리지\n\n\n\n\n코드 커버리지 모듈은 아직 실험 단계이지만 이 간단한 경우에서는 잘 작동하는 것 같아요. 사용하려면 다음 사항을 염두에 두시기 바랍니다. 이 기능은 더 최신 버전의 Node.js에서 작동을 멈출 수도 있습니다.\n\n다음 명령어로 커버리지를 실행해요:\n\n```js\nnode --experimental-test-coverage --test\n```\n\n그리고 우리는 Istanbul 커버리지 보고서와 매우 흡사한 다음 리포트를 받아요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_2.png\" /\u003e\n\n마무리로, 20버전에서 소개된 Node.js 테스트 러너는 개발자들에게 안정적이고 빠르며 포괄적인 테스트 솔루션을 제공합니다. 간단한 데이터 검색 기능부터 더 복잡한 코드까지 테스트하는 경우에도, Node.js의 테스트 기능이 네이티브로 구현되어 있어 테스트 경험을 간소화하고 풍부하게 해줄 것입니다. 더 이상 외부 테스트 러너가 필요하지 않고, 훌륭한 성능과 고품질 문서를 자랑합니다. 자세한 정보는 문서를 참조해주시고, 프로젝트 수준에서 사용하는 과정을 알려주시면 감사하겠습니다.\n\n독자분들을 조금 더 알고 싶습니다. 저는 다음에서 만날 수 있습니다.\n\nhttps://www.linkedin.com/in/laurentzuijdwijk/ https://mentorcruise.com/mentor/laurentzuijdwijk/\n\n\n\n## 자원\n\n테스트 러너 문서: [링크](https://nodejs.org/api/test.html)  \nAssert 문서: [링크](https://nodejs.org/api/assert.html)\n\n# 리유저블 컴포넌트로 구성 가능한 앱을 만들어 보세요. 레고처럼 재사용 가능한 컴포넌트로\n\n![이미지](/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_3.png)\n\n\n\n비트는 조합 가능한 소프트웨어 개발을 위한 오픈소스 도구체인입니다.\n\n비트를 사용하면 현대 웹 앱, UI 구성 요소, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 종류의 소프트웨어도, 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 전체에서 컴포넌트를 공유하여 협력이 쉽고 빠르게 빌드할 수 있도록 만들어보세요.\n\n함께 조립 가능한 소프트웨어를 개발하는 100,000명 이상의 개발자와 함께하세요.\n\n다음 자습서로 시작해보세요:\n\n\n\n# → Micro-Frontends: 비디오 // 가이드\n\n# → 코드 공유: 비디오 // 가이드\n\n# → 현대화: 비디오 // 가이드\n\n# → Monorepo: 비디오 // 가이드\n\n\n\n# → 마이크로서비스: 비디오 // 가이드\n\n# → 디자인 시스템: 비디오 // 가이드\n\n# 권장 문서:","ogImage":{"url":"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoUsetheNewNodejsTestRunner_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트의 해시맵","description":"","date":"2024-05-14 15:41","slug":"2024-05-14-HashmapinJavaScript","content":"\n\n자바스크립트에서 해시맵(연상 배열 또는 객체라고도 함)은 키-값 쌍을 저장할 수 있는 데이터 구조입니다. 해시맵의 키는 객체와 함수를 포함한 모든 값이 될 수 있고, 값은 모든 데이터 유형이 될 수 있습니다.\n\n자바스크립트에서 해시맵을 생성하고 사용하는 예시:\n\n```js\nlet map = {};\n\n// 맵에 키-값 쌍 추가\nmap['key1'] = 'value1';\nmap['key2'] = 'value2';\nmap['key3'] = 'value3';\n\n// 키를 사용하여 맵의 값에 접근\nconsole.log(map['key1']); // 결과: \"value1\"\nconsole.log(map['key2']); // 결과: \"value2\"\nconsole.log(map['key3']); // 결과: \"value3\"\n\n// 맵에서 키가 존재하는지 확인\nconsole.log('key1' in map); // 결과: true\nconsole.log('key4' in map); // 결과: false\n\n// 맵에서 키-값 쌍 제거\ndelete map['key2'];\nconsole.log('key2' in map); // 결과: false\n```\n\n이 예시에서 객체 리터럴을 사용하여 해시맵을 생성합니다. 대괄호 표기법을 사용하여 맵에 키-값 쌍을 추가하고 값을 가져올 수 있습니다. in 연산자를 사용하여 키가 맵에 존재하는지 확인하고, delete 연산자를 사용하여 맵에서 키-값 쌍을 제거할 수 있습니다.\n\n\n\n해시맵은 JavaScript에서 흔히 사용되며 배열의 요소 발생 빈도를 계산하거나 키를 사용하여 데이터 캐시를 유지하는 등의 작업에 사용됩니다. 이들은 유연하고 효율적이며 데이터를 저장하고 검색하기 위한 간단하고 직관적인 방법을 제공합니다.\n\nJavaScript에서 배열의 요소 발생 빈도를 계산하는데 해시맵을 사용하는 예시:\n\n```js\nlet array = [1, 2, 3, 2, 1, 3, 4, 4, 5];\n\nlet countMap = {};\n\n// 배열을 순회하며 각 요소의 발생 빈도를 계산합니다\narray.forEach(element =\u003e {\n  if (countMap[element] === undefined) {\n    countMap[element] = 1;\n  } else {\n    countMap[element]++;\n  }\n});\n\n// 각 요소의 발생 빈도를 출력합니다\nfor (let key in countMap) {\n  console.log(`요소 ${key}는 ${countMap[key]}번 발생합니다`);\n}\n```\n\n이 예시에서는 해시맵 countMap이 생성되어 배열의 각 요소의 개수를 저장합니다. forEach 루프는 배열을 순회하며 각 요소의 개수를 요소를 키로 사용하여 countMap에 업데이트합니다. 마지막으로, for 루프를 사용하여 countMap 내의 각 요소의 개수를 로그합니다.\n\n\n\n이 방법은 효율적이고 유연합니다. 모든 데이터 유형의 요소 발생 횟수를 계산하고 특정 요소에 대한 횟수를 상수 시간에 검색할 수 있도록 합니다.\n\n만약 배열의 배열이 있고 내부 배열의 요소 발생 횟수를 세고 싶다면, 중첩 루프를 사용하여 두 배열을 반복하고 hashmap에서 카운트를 업데이트할 수 있습니다.\n\n다음은 예시입니다:\n\n```js\nlet arrays = [[1, 2, 3], [2, 3, 4], [3, 4, 5]];\n\nlet countMap = {};\n\n// 외부 배열과 내부 배열을 반복\narrays.forEach(innerArray =\u003e {\n  innerArray.forEach(element =\u003e {\n    if (countMap[element] === undefined) {\n      countMap[element] = 1;\n    } else {\n      countMap[element]++;\n    }\n  });\n});\n\n// 각 요소의 카운트를 출력\nfor (let key in countMap) {\n  console.log(`Element ${key} occurs ${countMap[key]} times`);\n}\n```\n\n\n\n이 예시에서는 countMap이라는 해시맵이 생성되어 각 요소의 개수를 저장합니다. 첫 번째 forEach 루프는 외부 배열을 반복하고, 두 번째 forEach 루프는 각 내부 배열을 반복합니다. 각 요소의 개수는 키로 요소를 사용하여 countMap에 업데이트됩니다. 마지막으로 for 루프를 사용하여 countMap에서 각 요소의 개수를 기록합니다.\n\n# 해시맵 질문을 어렵게 만들 수 있는 요소들\n\n해시맵 질문을 어렵게 만들 수 있는 여러 요소들이 있습니다:\n\n- 복잡성: 해시맵은 복잡한 문제를 해결하는 데 사용될 수 있으며, 문제의 복잡성으로 인해 솔루션을 이해하기 어렵게 만들 수 있습니다.\n- 구현 세부사항: 해시맵을 구현하는 다양한 방법이 있으며, 구현 세부사항은 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어 해시 함수의 선택, 충돌 해결 전략 및 메모리 관리는 모두 해시맵의 성능과 동작에 영향을 줄 수 있습니다.\n- 성능 교환: 해시맵은 시간 복잡성과 공간 복잡성 사이의 균형을 제공하며, 서로 다른 작업 간의 교환을 이해하는 것이 도전적일 수 있습니다. 예를 들어, 해시맵 작업의 시간 복잡성은 하중 인자(load factor)와 해시맵의 크기에 따라 달라질 수 있으며, 공간 복잡성은 충돌 수와 키와 값의 크기에 따라 달라질 수 있습니다.\n- 언어별 차이: 서로 다른 프로그래밍 언어에는 해시맵의 다양한 구현이 있으며, 사용 중인 특정 언어는 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어, 일부 언어에는 내장된 해시맵 데이터 구조가 있고, 다른 언어는 그렇지 않을 수 있으며, 일부 언어는 충돌 처리 및 크기 조정을 다루는 다른 방법을 가질 수 있습니다.\n\n\n\n일반적으로 해시맵의 기본 원리를 이해하고 서로 다른 구현 사이의 trade-off를 이해하는 것이 해시맵 질문에 정확하고 효과적으로 대답하는 핵심입니다.\n\n자바스크립트에서 해시맵의 기본과 trade-off\n\n- 기본: 해시맵은 키를 값에 매핑하는 데이터 구조인데, 자바스크립트에서는 객체나 Map 객체를 사용하여 해시맵을 구현할 수 있습니다. 객체는 해시맵을 구현하는 간단한 방법이지만 일부 제한이 있습니다. 예를 들어, 키는 반드시 문자열이어야 하고 키는 추가된 순서대로 열거됩니다. Map 객체는 ECMAScript 6에서 도입되었으며 모든 유형의 키를 지원하고 순서가 지정된 반복을 제공하는 더 유연하고 강력한 해시맵 구현을 제공합니다.\n- 시간 복잡도: 자바스크립트에서 해시맵 연산의 시간 복잡도는 해시맵의 크기와 키의 분포에 따라 달라집니다. 일반적인 연산인 요소 추가, 요소 찾기 및 요소 삭제는 평균 시간 복잡도 O(1)를 가지며 평균적으로 일정한 시간이 소요됩니다. 그러나 해시맵이 잘못 설계되었거나 키가 고르게 분산되지 않은 경우 시간 복잡도가 저하되어 성능이 저하될 수 있습니다.\n- 공간 복잡도: 자바스크립트에서 해시맵의 공간 복잡도는 해시맵에 저장된 요소 수와 키와 값의 크기에 따라 달라집니다. 일반적으로 해시맵은 배열보다 메모리를 더 많이 필요로 합니다. 하지만 키와 값의 크기를 최적화하여 공간 복잡도를 줄일 수 있습니다.\n- 충돌: 두 개 이상의 키가 해시맵에서 동일한 인덱스로 매핑될 때 충돌이 발생합니다. 자바스크립트에서는 체이닝(각 인덱스에 연결 리스트 저장)이나 프로빙(충돌 후 빈 슬롯을 찾는)과 같은 다양한 전략을 사용하여 충돌을 해결할 수 있습니다. 충돌 해결 전략의 선택은 해시맵 연산의 시간 및 공간 복잡도에 영향을 미칠 수 있습니다.\n\n요약하면, 해시맵은 키를 기반으로 요소에 빠르게 액세스할 수 있는 강력하고 유연한 데이터 구조이지만 자바스크립트에서 해시맵을 사용할 때 시간과 공간 복잡도 사이의 trade-off와 구현 선택을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-HashmapinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-HashmapinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구","description":"","date":"2024-05-14 15:39","slug":"2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png\" /\u003e\n\n## BACK-END DEVELOPMENT\n\n# Introduction\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_1.png\" /\u003e\n\n\n\n\n안녕하세요! 미들웨어는 요청 및 응답 객체에서 작동하는 함수로, 종종 이러한 객체들을 최종 라우트 핸들러에 도달하기 전에 정보를 변경하거나 추가하거나 처리하는 방식으로 작동하기 때문에 서버 측 프로그래밍의 중요한 부분이 되었습니다.\n\n이러한 미들웨어의 유틸리티를 고려하면, 서버 측 기술들은 종종 이러한 도구의 개발과 사용을 용이하게 하는 프레임워크를 제공합니다. 본 문서에서는 Node.js 생태계에서 두 가지 인기 있는 프레임워크인 Express.js와 Koa.js에 대해 다룹니다.\n\n## Express.js와 Koa.js\n\nExpress.js는 Node.js를 위한 표준 서버 프레임워크로 인정받고 있으며 강력한 미들웨어 시스템을 포함한 강력한 기능들로 웹 개발의 풍경을 형성하는 데 중요한 역할을 하고 있습니다. 반면에 Koa.js는 Express.js를 개발한 팀에 의해 개발된 Node.js를 위한 최신 웹 프레임워크로, 더 작고 표현력이 뛰어나며 웹 애플리케이션과 API를 위한 훨씬 견고한 기반을 제공하려고 합니다. 이 프레임워크는 핵심에 어떤 미들웨어도 번들로 제공하지 않아 개발자들에게 더 많은 제어와 자유를 제공합니다.\n\n\n\n## 사례 연구\n\n이 문서는 Express.js와 Koa.js의 미들웨어 구현 능력에 중점을 두고 깊이 있는 비교를 제공합니다. 또한 인증, 권한 부여, 자세한 요청 분석 로깅 및 책 요청 로깅 및 유효성 검사와 같은 예시들을 탐구합니다. 이러한 예시들은 실제 사용 사례인 약학 마이크로서비스를 통해 설명될 것입니다. 이 서비스는 의약품 목록을 관리하고 새로운 의약품을 필요할 때 매입하여 추적하는 역할을 담당합니다.\n\n# Express.js를 이용한 미들웨어 구현\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_2.png)\n\n\n\n## Express.js: 간단한 개요\n\nExpress.js 또는 Express는 Node.js를 위한 강력한 백엔드 웹 애플리케이션 프레임워크로 널리 알려져 있습니다. 그 간결함, 유연성, 확장성으로 칭찬받고 있으며, MEAN/MERN 스택(MongoDB, Express, Angular/React, Node.js)의 필수 구성 요소이기도 합니다. 간소한 성격에도 불구하고, 라우팅, 템플릿 엔진, 미들웨어, 오류 처리 등의 기능을 포함한 강력한 기능을 자랑합니다.\n\n## Express.js가 미들웨어를 처리하는 방식\n\nExpress의 핵심은 미들웨어 시스템입니다. 미들웨어는 요청 객체(req), 응답 객체(res), 및 응용 프로그램의 요청-응답 주기 내의 다음 미들웨어 함수에 접근 권한이 있는 함수들입니다. 이들은 코드를 실행하거나 요청 및 응답 객체를 변경하며 요청-응답 주기를 종료하거나 다음 미들웨어 함수에 제어를 전달할 수 있습니다.\n\n\n\n이 미들웨어 파이프라인은 개발자가 중요한 유연성을 제공하여 애플리케이션의 고유한 요구 사항에 맞춰 미들웨어 기능을 추가하고 계층화할 수 있도록 합니다.\n\n## Express 미들웨어 예시\n\n의약품 마이크로서비스 시나리오를 살펴보면 Express를 사용하여 필요한 미들웨어 기능을 구현하는 방법을 알아볼 수 있습니다. 인증(Authentication), 권한 부여(Authorization), 분석을 위한 요청 로깅(Request Logging) 및 도서 요청 로깅 및 유효성 검사(Book Request Logging \u0026 Validation)가 포함됩니다. \n\n인증 미들웨어 — 인증은 사용자, 프로세스 또는 시스템의 신원을 확인하는 과정이며, Express에서는 미들웨어를 사용하여 유효 자격 증명이 있는지 확인하기 위해 요청 헤더를 검사하여 들어오는 요청을 인증할 수 있습니다.\n\n\n\n```js\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('Access Denied');\n\n  // 토큰을 확인하고 계속 진행\n  // ...\n  next();\n}\n```\n\n인증 미들웨어 — 인증 후에 사용되는 인가는, 인증된 사용자가 어떤 자원에 액세스할 수 있는지 결정하는 것이며, 다시 한 번 Express 미들웨어가 유용하게 사용됩니다.\n\n```js\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('Unauthorized access.');\n\n  next();\n}\n```\n\n로깅 미들웨어 — 그리고 우리는 로깅에 도달했습니다. 로깅은 애플리케이션 활동 추적과 디버깅에 중요하며, 여기 Express 미들웨어를 사용해 요청 세부 정보를 로깅할 수 있습니다.\n\n\n\n\n```js\nfunction logger(req, res, next) {\n  console.log(`요청 방법이 ${req.method}이고 URL이 ${req.url}인 요청을 받았습니다. 시간: ${Date.now()}`);\n  next();\n}\n```\n\n도서 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약품을 추가하는 경로와 같은 특정 경로를 다룰 때, 미들웨어는 요청 데이터를 유효성 검사하고 요청을 로그에 남길 수 있습니다.\n\n```js\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi와 같은 라이브러리 사용 가능)\n  // 유효하지 않으면 '400 Bad Request' 응답 반환\n\n  // 도서 요청 로깅\n  console.log(`도서 요청이 ${req.body.drugName}인 요청을 받았습니다. 시간: ${Date.now()}`);\n\n  next();\n}\n```\n\n## 더 알아보기:\n\n\n\n# 미들웨어 구현을 위한 Koa.js\n\n\u003cimg src=\"/assets/img/2024-05-14-Nodejs에서의미들웨어구현Expressjs와Koajs의비교연구_3.png\"/\u003e\n\nKoa.js 또는 간단히 Koa는 Express 팀이 디자인한 웹 프레임워크로, 더 현대적이고 최신 솔루션으로 웹 애플리케이션과 API를 위한 표현력이 풍부하고 견고하며 가벼운 기반을 제공하려고 합니다. Koa는 핵심 내부에 미들웨어를 번들로 제공하지 않으며 대신, 서버를 빠르고 즐겁게 작성할 수 있게 하는 우아한 메서드 모음을 제공합니다.\n\n## Koa.js가 미들웨어를 처리하는 방법\n\n\n\nKoa는 미들웨어 처리 방식에 혁신적인 접근을 제공합니다. 최신 JavaScript 기능인 특히 ES6 제너레이터 함수를 활용하여 콜백을 제거하고 에러 처리를 간소화함으로써 미들웨어 스택을 간단하게 만들고 여러 종류의 미들웨어 함수를 관리하는 복잡성을 줄입니다.\n\nKoa 미들웨어의 주요 차이점은 제너레이터 함수를 사용하며 실행을 일시 중지하고 재개할 수 있는 yield 키워드를 사용한다는 점입니다. 이는 미들웨어 함수가 어떻게 그리고 언제 실행되는지에 대한 높은 수준의 제어를 제공합니다.\n\n## Koa.js 미들웨어 예시\n\n약학 마이크로서비스 시나리오를 계속해가며, Express로 했던 것과 같은 미들웨어 함수를 만드는 방법을 살펴보겠습니다: 인증, 권한 부여, 요청 로깅 및 도서 요청 로깅 및 유효성 검사.\n\n\n\n인증 미들웨어 — 익스프레스처럼, Koa에서도 미들웨어를 사용하여 제공된 자격 증명을 확인하여 들어오는 요청을 인증할 수 있습니다.\n\n```js\nconst auth = async (ctx, next) =\u003e {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, 'Access Denied');\n\n  // 토큰을 확인하고 계속 진행합니다\n  // ...\n  await next();\n}\n```\n\n인가 미들웨어 — 인증된 사용자에 대한 자원 접근 가능성을 결정하기 위해 Koa 미들웨어를 사용할 수도 있습니다.\n\n```js\nconst authorize = async (ctx, next) =\u003e {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, 'Unauthorized access.');\n\n  await next();\n}\n```\n\n\n\nLogging Middleware — Koa의 로깅 미들웨어는 수신된 요청의 세부 정보를 기록하여 디버깅 및 분석을 지원합니다.\n\n```js\nconst logger = async (ctx, next) =\u003e {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n```\n\n책 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약물을 추가하는 라우트와 같은 특정 라우트는 데이터 유효성 검사와 로깅을 위해 Koa 미들웨어를 사용할 수 있습니다.\n\n```js\nconst validateAndLogBookRequest = async (ctx, next) =\u003e {\n  // 요청 데이터 유효성 검사 (다시 말해, Joi나 다른 라이브러리를 사용할 수 있음)\n  // 유효하지 않은 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 기록\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n```\n\n\n\n# 사례 연구: 제약 마이크로서비스에서 미들웨어 구현하기\n\n![image](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_4.png)\n\nNode.js에서 Express와 Koa를 사용하여 미들웨어를 실제로 구현하는 방법에 대해 더 깊이 이해하기 위해, 제약 마이크로서비스의 사례 연구를 살펴보겠습니다. 이 마이크로서비스는 약물 목록을 제공하고 필요할 때 새로운 약물을 재고에 등록할 수 있는 권한이 있는 사용자에게 이 서비스를 제공합니다.\n\n## 우리의 사용 사례 시나리오\n\n\n\n이 시나리오에서는 네 가지 유형의 미들웨어를 구현해야 하므로, 다시 한 번 정리해보겠습니다:\n\n- 사용자 자격 증명을 확인하기 위한 인증(Authentication)\n- 리소스 접근을 제어하기 위한 권한 부여(Authorization)\n- 분석을 위해 들어오는 요청의 세부 내용을 추적하는 요청 로깅(Request Logging)\n- 새로운 약품을 재고에 추가하는 요청을 기록하고 유효성을 검사하는 Book Request Logging and Validation\n\n여기서, Express와 Koa를 사용하여 각 유형의 미들웨어에 대한 코드 조각을 제공하며, 이 두 인기있는 Node 프레임워크의 미들웨어 접근 방식의 유사점과 차이점을 관찰할 수 있습니다.\n\n## Express.js 구현\n\n\n\n우리는 필요한 라이브러리를 요구하고, 미들웨어 함수를 정의한 다음, 이러한 미들웨어 함수를 사용하여 서버 라우트를 설정할 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\n// 인증 미들웨어\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('액세스 거부됨');\n\n  // 토큰 확인 및 계속 진행\n  // ...\n  next();\n}\n\n// 권한 미들웨어\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('인가되지 않은 액세스입니다.');\n\n  next();\n}\n\n// 로깅 미들웨어\nfunction logger(req, res, next) {\n  console.log(`요청 방식 ${req.method} 요청을 받음: ${req.url}, 시간: ${Date.now()}`);\n  next();\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 유효하지 않은 경우 '400 잘못된 요청' 응답 반환\n  \n  // 책 요청 로깅\n  console.log(`책 요청 받음: ${req.body.drugName}, 시간: ${Date.now()}`);\n\n  next();\n}\n\n// 서버 라우트 설정\napp.use(logger); // 모든 라우트에 로깅 사용\napp.use('/api/drugs', auth, authorize); // '/api/drugs' 라우트에 인증 및 권한 사용\napp.use('/api/book', validateAndLogBookRequest); // '/api/book' 라우트에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () =\u003e {\n  console.log('서버가 포트 3000에서 대기 중');\n});\n```\n\n## Koa.js 구현 방법\n\n이제 Koa에서 동등한 내용을 살펴봅시다.\n\n\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// 인증 미들웨어\nconst auth = async (ctx, next) =\u003e {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, '액세스 거부');\n\n  // 토큰 확인 및 진행\n  // ...\n  await next();\n}\n\n// 권한 부여 미들웨어\nconst authorize = async (ctx, next) =\u003e {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, '사용 권한이 없습니다.');\n\n  await next();\n}\n\n// 로깅 미들웨어\nconst logger = async (ctx, next) =\u003e {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nconst validateAndLogBookRequest = async (ctx, next) =\u003e {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 잘못된 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 로깅\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n\n// 서버 경로 설정\napp.use(logger); // 모든 경로에 로거 사용\napp.use(auth, authorize); // 모든 경로에 인증과 권한을 사용\napp.use(validateAndLogBookRequest); // 모든 경로에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000번 포트에서 수신 대기 중입니다.');\n});\n```\n\n이 간단한 예제에서는 모든 요청에 대한 로깅, 의약품 자원에 대한 인증 및 권한 부여, 그리고 책 요청 로깅 및 유효성 검사를 위해 미들웨어를 사용했습니다. Express와 Koa 사이의 구현이 매우 유사하다는 점을 알 수 있습니다. 주요 차이점은 Koa가 더 읽기 쉽고 유지보수하기 쉬운 코드를 위해 async/await 구문을 사용한다는 것입니다.\n\n# Express.js vs Koa.js: 두 미들웨어의 이야기\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_5.png\" /\u003e\n\n\n\n\nNode 마이크로서비스를 개발할 때 Express와 Koa 중 어떤 것을 선택할지는 특정 프로젝트 요구 사항, 팀이 프레임워크에 익숙한 정도, 장기적인 유지 보수 관점 등 여러 요소에 따라 결정됩니다. 그럼 각 프레임워크의 강점을 살펴보고 미들웨어 처리 면에서 어떻게 비교되는지 알아봅시다.\n\n## Express.js 장점\n\nExpress는 Koa보다 오랜 기간 사용되어 왔으며 현재 더 인기가 많습니다. 방대한 커뮤니티와 다양한 자원이 제공되어 많은 개발자들에게 특히 간단한 웹 애플리케이션이나 REST API 개발에 용이한 선택지입니다.\n\nExpress의 미들웨어 아키텍처는 간단하고 직관적으로 설계되어 있어, 가파른 학습 곡선 없이도 강력한 기능 세트가 필요한 애플리케이션에 좋은 선택으로 떠오릅니다.\n\n\n\n## Koa.js의 강점\n\nKoa는 미들웨어 관리에 대한 혁신적인 접근 방식을 제공하며, 비동기 함수의 사용으로 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 이는 Node.js에서 보편적으로 발생하는 콜백 지옥(callback hell)을 제거해줍니다.\n\nKoa는 더 가벼우면서도 표현력이 풍부하고 견고한 웹 애플리케이션과 API의 기반을 제공하며, async 함수를 통해 콜백을 버리고 에러 처리를 크게 향상시킬 수 있습니다. Koa는 자체적으로 미들웨어를 포함하지 않으며, 서버를 빠르고 즐겁게 작성할 수 있는 다양한 메서드를 제공합니다.\n\n![2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6.png)\n\n\n\n## 미들웨어 비교\n\n익스프레스와 코아는 각자 독특한 방식으로 미들웨어를 다루는데, 첫 번째는 더 전통적인 방식을 사용합니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며 직접 작동할 수 있어서 제어 흐름을 이해하고 디버깅하기 쉽습니다.\n\n반면, 코아는 현대적인 JavaScript 기능을 사용하며, 미들웨어가 실행을 다음 미들웨어에 \"양보\"하고 스택이 해제될 때 재개될 수 있도록 흐름을 제어하게 합니다. 이는 코드를 더 선형적이고 쉽게 읽을 수 있게 만드는 반면, JavaScript 제너레이터 및 프로미스에 대한 깊은 이해가 필요합니다.\n\n\n\n# 아직 끝나지 않았어요\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_8.png)\n\nExpress.js와 Koa.js를 비교한 결론을 도출해본 결과, Express는 직관적이고 간단한 방법론을 채택했으며, Koa는 JavaScript의 비동기 함수를 활용한 더 간략하고 현대적인 접근 방식을 취했습니다.\n\nMiddleware를 최적화하는 것은 Node.js 애플리케이션 전반의 성능을 향상시키는 일부분에 불과하다는 것을 명심해주세요. 저의 이전 글인 \"이벤트 루프를 통해 Node.js의 성능 향상하기: 사례 연구를 통해 더 나은 성능\"에서 Node가 이벤트 루프를 어떻게 활용해 효율적으로 작업을 처리하는지 심층적으로 살펴볼 수 있습니다. 이를 통해 성능 최적화에 대한 깊은 이해를 얻을 수 있습니다.\n\n\n\n반면에, 애플리케이션의 구조와 효율성을 더욱 향상시키기 위해 이벤트 주도 아키텍처를 채택하는 것을 고려해보세요. 또 다른 기사인 \"Node.js 및 TypeScript를 사용한 이벤트 주도형 REST API 만들기: 실용적인 접근\"에서는 Node와 TypeScript를 활용하여 강력하고 효율적인 REST API를 구축하는 방법을 안내하고 있습니다. 여기서는 간단한 이벤트 주도 접근 방식에 중점을 두며 독자를 안내합니다.\n\n즐거운 코딩하시고, 앞으로의 기사에서 더 많은 통찰과 실용적인 접근법을 공유하기를 기대하고 있습니다!\n\n# 레고처럼 재사용 가능한 컴포넌트로 구성 가능한 앱을 구축하자\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_9.png)\n\n\n\nBit는 본질적으로 조립 가능한 소프트웨어를 개발하기 위한 오픈 소스 도구 모음입니다.\n\nBit를 사용하면 현대적인 웹 애플리케이션, UI 컴포넌트, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 소프트웨어 요소든 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 간에 어떤 컴포넌트라도 공유하여 협업을 더 쉽게 하고 더 빠르게 빌드할 수 있습니다.\n\n조립 가능한 소프트웨어를 함께 만드는 100,000명 이상의 개발자 중 하나가 되어보세요.\n\n다음 자습서로 시작해보세요:\n\n\n\n# → 마이크로 프론트엔드: 비디오 // 안내\n\n# → 코드 공유: 비디오 // 안내\n\n# → 현대화: 비디오 // 안내\n\n# → 모노 레포: 비디오 // 안내\n\n\n\n# → 마이크로서비스: 비디오 // 가이드\n\n# → 디자인 시스템: 비디오 // 가이드\n\n# 추천 문서:","ogImage":{"url":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png","tag":["Tech"],"readingTime":12},{"title":"Nodejs와 Expressjs","description":"","date":"2024-05-14 15:37","slug":"2024-05-14-NodejsandExpressjs","content":"\n\n지금 이 시점에서 자바스크립트 노드 프레임워크에 대해 초보자인 경우, 이 글은 당신이 노드와 익스프레스가 어떻게 관련되는지 쉽게 이해하는 데 도움이 될 것입니다.\n\nNode.js는 웹 브라우저 외부에서 자바스크립트 코드를 실행할 수 있게 해주는 자바스크립트 런타임 환경입니다. 일반적으로 서버에서 실행됩니다. 그러나 HTTP 요청 및 응답 처리 및 웹 애플리케이션 구축을 위해 Express.js와 같은 프레임워크가 필요합니다.\n\nExpress.js는 Node.js를 위한 웹 애플리케이션 프레임워크로, 웹 애플리케이션 및 API를 구축하는 데 필요한 기능 세트를 제공합니다. Express.js는 HTTP 요청 처리, 라우팅, 미들웨어 통합 등의 프로세스를 단순화하며, Node.js를 사용하여 웹 애플리케이션을 개발하고 배포하기가 더 쉬워집니다.\n\n따라서 브라우저에서 노드.js로 구축된 웹 애플리케이션을 배포하거나 액세스하려면 일반적으로 Express.js를 사용하여 서버 측 로직 및 HTTP 통신을 처리합니다. Express.js를 사용하면 라우트를 생성하고 요청을 처리하며 정적 파일을 제공하고 웹 애플리케이션의 기능을 관리하는 등의 작업이 가능해집니다. 지금 이해됐으면 좋겠네요!\n\n\n\n해피 코딩!","ogImage":{"url":"/assets/img/2024-05-14-NodejsandExpressjs_0.png"},"coverImage":"/assets/img/2024-05-14-NodejsandExpressjs_0.png","tag":["Tech"],"readingTime":1},{"title":"NET Core 6와 React JS를 활용한 제품 관리 애플리케이션 개발하기 CRUD 작업 포함","description":"","date":"2024-05-14 15:36","slug":"2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png\" /\u003e\n\n# 소개\n\n이 글에서는 .NET Core 6을 사용하여 CRUD 작업을 수행하는 제품 관리 웹 API를 만들고 React JS의 도움으로 다양한 형식을 사용할 것입니다.\n\n# 사전 준비조건\n\n\n\n- Visual Studio 2022\n- VS Code\n- SQL Server\n- .NET Core SDK\n- Node JS\n\n# 제품 관리 응용 프로그램\n\n단계 1\n\n새 제품 관리 .NET Core Web API를 만드세요.\n\n\n\nStep 2\n\n데이터베이스 마이그레이션 및 SQL Server와의 연결에 사용하는 다음 NuGet 패키지를 설치하십시오.\n\n![NuGet Packages](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_1.png)\n\nStep 3\n\n\n\nentities 폴더 안에 product 클래스를 추가해주세요.\n\n```js\nnamespace ProductManagementAPI.Entities\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n    }\n}\n```\n\n4단계\n\ndata 폴더 안에 AppDbContext 클래스를 만들어 SQL Server 연결 및 DB 설정 속성을 추가해주세요.\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Data\n{\n    public class AppDbContext : DbContext\n    {\n        public DbSet\u003cProduct\u003e Products { get; set; }\n        protected readonly IConfiguration Configuration;\n        public AppDbContext(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n            options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n        }\n    }\n}\n```\n\nStep 5\n\n리포지토리 폴더 내에 제품 리포지토리를 추가하세요.\n\nIProductRepository\n\n\n\n\n```js\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public interface IProductRepository\n    {\n        void AddProduct(Product product);\n        void DeleteProduct(int id);\n        List\u003cProduct\u003e GetAllProducts();\n        Product GetProductById(int id);\n        void UpdateProduct(Product product);\n    }\n}\n```\n\nProductRepository\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public class ProductRepository : IProductRepository\n    {\n        private readonly AppDbContext _context;\n        public ProductRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n        public List\u003cProduct\u003e GetAllProducts()\n        {\n            return _context.Products.ToList();\n        }\n        public Product GetProductById(int id)\n        {\n            return _context.Products.FirstOrDefault(p =\u003e p.Id == id);\n        }\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Add(product);\n            _context.SaveChanges();\n        }\n        public void UpdateProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Entry(product).State = EntityState.Modified;\n            _context.SaveChanges();\n        }\n        public void DeleteProduct(int id)\n        {\n            var product = _context.Products.Find(id);\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n            _context.Products.Remove(product);\n            _context.SaveChanges();\n        }\n    }\n}\n```\n\n단계 6\n\n\n\n\n위 코드를 사용하여 다양한 작업을 수행하는 새 제품 컨트롤러를 만들었습니다. 이제 이를 호출하면 우리의 프런트엔드 애플리케이션을 통해 다양한 작업을 수행할 수 있습니다.\n\n```js\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing ProductManagementAPI.Entities;\nusing ProductManagementAPI.Repositories;\n\nnamespace ProductManagementAPI.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductRepository _productRepository;\n        public ProductController(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;\n        }\n        [HttpGet]\n        public IActionResult GetAllProducts()\n        {\n            var products = _productRepository.GetAllProducts();\n            return Ok(products);\n        }\n        [HttpGet(\"{id}\")]\n        public IActionResult GetProductById(int id)\n        {\n            var product = _productRepository.GetProductById(id);\n            if (product == null)\n            {\n                return NotFound();\n            }\n            return Ok(product);\n        }\n        [HttpPost]\n        public IActionResult AddProduct([FromBody] Product product)\n        {\n            if (product == null)\n            {\n                return BadRequest();\n            }\n            _productRepository.AddProduct(product);\n            return CreatedAtAction(nameof(GetProductById), new { id = product.Id }, product);\n        }\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateProduct(int id, [FromBody] Product product)\n        {\n            if (product == null || id != product.Id)\n            {\n                return BadRequest();\n            }\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.UpdateProduct(product);\n            return NoContent();\n        }\n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteProduct(int id)\n        {\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n            _productRepository.DeleteProduct(id);\n            return NoContent();\n        }\n    }\n}\n```\n\n7단계\n\n앱 설정 파일을 열어 데이터베이스 연결 문자열을 추가하세요.\n\n\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DESKTOP-8RL8JOG;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\"\n  }\n}\n```\n\n**단계 8**\n\n서비스 컨테이너 내에서 서비스를 등록하고 미들웨어를 구성하세요.\n\n```csharp\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Repositories;\n\nvar builder = WebApplication.CreateBuilder(args);\n// 컨테이너에 서비스 추가\nbuilder.Services.AddScoped\u003cIProductRepository, ProductRepository\u003e();\nbuilder.Services.AddDbContext\u003cAppDbContext\u003e();\nbuilder.Services.AddCors(options =\u003e {\n    options.AddPolicy(\"CORSPolicy\", builder =\u003e builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());\n});\n\nbuilder.Services.AddControllers();\n// Swagger/OpenAPI 구성에 대해 더 자세히 알아보려면 https://aka.ms/aspnetcore/swashbuckle을 참조하세요\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nvar app = builder.Build();\n// HTTP 요청 파이프라인 구성\napp.UseCors(\"CORSPolicy\");\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n\n\n9단계\n\n아래 엔터티 프레임워크 데이터베이스 마이그레이션 명령을 실행하여 데이터베이스와 테이블을 생성합니다.\n\n```js\nadd-migration \"v1\"\nupdate-database\n```\n\n10단계\n\n\n\n마지막으로, 애플리케이션을 실행하고 Swagger UI를 사용하여 다양한 API 엔드포인트를 실행하세요.\n\n![Swagger UI](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_2.png)\n\nReact JS를 사용하여 클라이언트 애플리케이션을 생성하고 위의 API 엔드포인트를 이용해보세요.\n\n1단계\n\n\n\n다음 명령어를 사용하여 새 React JS 애플리케이션을 만들어 보세요:\n\nnpx create-react-app react-netcore-crud-app\n\n단계 2\n\n프로젝트 디렉토리로 이동하세요.\n\n\n\ncd react-netcore-crud-app\n\n**단계 3**\n\n백엔드 API를 소비하고 호출하기 위해 Axios를 설치하고 디자인을 위해 bootstrap을 설치하세요.\n\nnpm install axios\n\n\n\nnpm install bootstrap\n\n단계 4\n\n다음 컴포넌트 및 서비스를 추가하세요:\n\n제품 목록 컴포넌트.\n\n\n\n```js\n// src/components/ProductList/ProductList.js\nimport React, { useState, useEffect } from 'react';\nimport ProductListItem from './ProductListItem';\nimport productService from '../../services/productService';\n\nconst ProductList = () =\u003e {\n    const [products, setProducts] = useState([]);\n    useEffect(() =\u003e {\n        fetchProducts();\n    }, []);\n    const fetchProducts = async () =\u003e {\n        try {\n            const productsData = await productService.getAllProducts();\n            setProducts(productsData);\n        } catch (error) {\n            console.error('제품을 불러오는 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleDelete = async (id) =\u003e {\n        try {\n            await productService.deleteProduct(id);\n            fetchProducts(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 삭제 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleEdit = () =\u003e {\n        fetchProducts(); // 편집 후 제품 목록 새로고침\n    };\n    return (\n        \u003cdiv className=\"container\"\u003e\n            \u003ch2 className=\"my-4\"\u003e제품 목록\u003c/h2\u003e\n            \u003cul className=\"list-group\"\u003e\n                {products.map(product =\u003e (\n                    \u003cProductListItem key={product.id} product={product} onDelete={() =\u003e handleDelete(product.id)} onEdit={handleEdit} /\u003e\n                ))}\n            \u003c/ul\u003e\n        \u003c/div\u003e\n    );\n};\nexport default ProductList;\n```\n\n제품 목록 항목 컴포넌트.\n\n```js\n// src/components/ProductList/ProductListItem.js\nimport React, { useState } from 'react';\nimport productService from '../../services/productService';\n\nconst ProductListItem = ({ product, onDelete, onEdit }) =\u003e {\n    const [isEditing, setIsEditing] = useState(false);\n    const [editedName, setEditedName] = useState(product.name);\n    const [editedPrice, setEditedPrice] = useState(product.price);\n    const handleEdit = async () =\u003e {\n        setIsEditing(true);\n    };\n    const handleSave = async () =\u003e {\n        const editedProduct = { ...product, name: editedName, price: parseFloat(editedPrice) };\n        try {\n            await productService.updateProduct(product.id, editedProduct);\n            setIsEditing(false);\n            onEdit(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 업데이트 중 오류가 발생했습니다:', error);\n        }\n    };\n    const handleCancel = () =\u003e {\n        setIsEditing(false);\n        // 수정된 값 초기화\n        setEditedName(product.name);\n        setEditedPrice(product.price);\n    };\n    return (\n        \u003cli className=\"list-group-item\"\u003e\n            {isEditing ? (\n                \u003cdiv className=\"row\"\u003e\n                    \u003cdiv className=\"col\"\u003e\n                        \u003cinput type=\"text\" className=\"form-control\" value={editedName} onChange={e =\u003e setEditedName(e.target.value)} required /\u003e\n                    \u003c/div\u003e\n                    \u003cdiv className=\"col\"\u003e\n                        \u003cinput type=\"number\" className=\"form-control\" value={editedPrice} onChange={e =\u003e setEditedPrice(e.target.value)} required /\u003e\n                    \u003c/div\u003e\n                    \u003cdiv className=\"col-auto\"\u003e\n                        \u003cbutton className=\"btn btn-success me-2\" onClick={handleSave}\u003e저장\u003c/button\u003e\n                        \u003cbutton className=\"btn btn-secondary\" onClick={handleCancel}\u003e취소\u003c/button\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            ) : (\n                \u003cdiv className=\"d-flex justify-content-between align-items-center\"\u003e\n                    \u003cspan\u003e{product.name} - ${product.price}\u003c/span\u003e\n                    \u003cdiv\u003e\n                        \u003cbutton className=\"btn btn-danger me-2\" onClick={onDelete}\u003e삭제\u003c/button\u003e\n                        \u003cbutton className=\"btn btn-primary\" onClick={handleEdit}\u003e편집\u003c/button\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            )}\n        \u003c/li\u003e\n    );\n};\nexport default ProductListItem;\n```\n\n제품 서비스.\n\n\n\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = 'https://localhost:7202/api/Product';\nconst productService = {\n    getAllProducts: async () =\u003e {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) =\u003e {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) =\u003e {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) =\u003e {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\nexport default productService;\n```\n\nApp component.\n\n```js\n// src/App.js\nimport React, { useState } from 'react';\nimport ProductList from './components/ProductList/ProductList';\nimport ProductForm from './components/ProductForm/ProductForm';\n\nfunction App() {\n    const [refresh, setRefresh] = useState(false);\n    const handleProductAdded = () =\u003e {\n        setRefresh(!refresh); // 상태를 토글하여 다시 렌더링을 트리거합니다.\n    };\n    return (\n        \u003cdiv\u003e\n            \u003cProductList key={refresh} /\u003e\n            \u003cProductForm onProductAdded={handleProductAdded} /\u003e\n        \u003c/div\u003e\n    );\n}\nexport default App;\n```\n\n5단계\n\n\n\n\n다음 명령을 사용하여 응용 프로그램을 실행하고 동일한을 사용하여 다양한 CRUD 작업을 수행하십시오.\n\n![image](/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_3.png)\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/React_NETCore_CRUD\n\n\n\n# 결론\n\n이 기사에서는 .NET Core 및 SQL Server를 사용하여 제품 관리 백엔드 응용 프로그램을 만들었고 CRUD 작업을 수행하는 데 필요한 다양한 API 엔드포인트를 만들었습니다. 나중에 React JS를 사용하여 프론트엔드 응용 프로그램을 만들었고 Axios의 도움을 받아 백엔드 응용 프로그램을 동일한 내에서 사용했습니다.","ogImage":{"url":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png"},"coverImage":"/assets/img/2024-05-14-ProductManagementApplicationusingNETCore6andReactJSwithCRUDOperations_0.png","tag":["Tech"],"readingTime":14},{"title":"시맨틱 검색을 위한 MongoDB Atlas 시작하기","description":"","date":"2024-05-14 15:33","slug":"2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch","content":"\n\n## 최신 MongoDB Atlas Vector Search 기능을 소개합니다\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png)\n\n6월 22일, MongoDB가 Atlas Vector Search를 미리 보기 모드로 출시했습니다.\n\n이 새로운 기능을 사용해봤어요!\n\n\n\n테이블 태그를 마크다운 형식으로 바꾸세요.\n\n\n\n이 검색 방법은 텍스트, 오디오, 비디오 및 이미지와 같이 구조화되지 않은 데이터를 효과적으로 검색하기 위해 기계 학습 모델을 활용합니다. 이를 통해 검색 항목과 유사하거나 관련된 항목을 찾을 수 있습니다. 추천 시스템, 챗봇 또는 검색 엔진과 같은 여러 사용 사례에 활용됩니다.\n\n텍스트 데이터를 다룰 때 벡터 검색을 통해 정확한 검색어가 검색된 문장에 없더라도 비슷한 의미의 단어나 구를 찾을 수 있습니다.\n\n벡터 검색은 임베딩 개념을 기반으로 합니다.\n\n## Embeddings\n\n\n\n벡터 검색은 고급 머신 러닝 모델(encoders)을 사용하여 구조화되지 않은 입력 데이터의 수치적 표현을 제공하는 벡터 임베딩을 생성합니다.\n\n벡터 임베딩은 컴퓨터에게 일반적으로 이해하기 어려운 구조화되지 않은 데이터를 숫자 형식으로 변환합니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_1.png)\n\n임베딩은 주로 수치 값 배열인 고차원 벡터입니다. 이러한 벡터는 데이터의 맥락적 및 의미적 정보를 포함하고 있어 유의미한 비교와 계산을 수행할 수 있도록 합니다.\n\n\n\n예를 들어, 텍스트 임베딩 모델(인코더)은 구절 내 단어들 사이의 관계를 학습하여 문장의 의미와 맥락 정보를 포착하는 임베딩을 생성할 수 있습니다.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_2.png)\n\n위 이미지에서 \"bovine buddies say\" 구절은 부동 소수점 숫자 배열([-0.005, 0.012, -0.008, ..., -0.010])로 인코딩되었습니다.\n\n벡터의 차원은 임베딩 모델에 따라 다르며 높을 수 있습니다(수천 개까지).\n\n\n\nMarkdown으로 테이블 태그를 변경하세요.\n\n\n\n## Atlas Vector Search\n\nAtlas Vector Search은 MongoDB Atlas의 새로운 기능으로, MongoDB의 검색 기능을 더욱 발전시킵니다.\n\nMongoDB Atlas Vector Search는 다음을 제공합니다:\n\n- 원하는 외부 ML 모델(OpenAI, Hugging Face 등)에서 생성된 임베딩 벡터를 보존하는 벡터 저장소;\n- 저장된 임베딩 벡터를 색인화하는 벡터 저장소 인덱스;\n- 저장된 벡터에서 의미 검색을 수행하기 위한 근사 최근 이웃(ANN) 알고리즘을 구현하는 검색 작업.\n\n\n\n몽고디비 Atlas Search를 사용하면 사용자는 기본 키워드 매칭 이상의 정보 검색 기능을 확장할 수 있습니다. 이 혁신적인 도구는 컨텍스트 인식 시맨틱 검색을 가능하게하여 사용자의 검색어에서 의미를 유추할 수 있도록 합니다.\n\n# 액션에서의 Atlas Vector Search\n\n이제 몽고디비 Atlas Vector Search의 새로운 기능을 시도해 보겠습니다.\n\n이 튜토리얼을 완료하기 위해 다음 단계를 실행해 보겠습니다:\n\n\n\n- 무료 MongoDB ATLAS 클러스터를 생성하세요.\n- 속담과 쿼리를 위한 MongoDB 컬렉션을 생성하세요.\n- Hugging Face API 토큰을 생성하세요.\n- 생성된 Hugging Face API 토큰을 Atlas에 임포트하세요.\n- Atlas Database Triggers 및 HF API 실행을 위한 함수를 만드세요.\n- 벡터 검색 인덱스를 생성하세요.\n- 속담 데이터셋을 MongoDB에 삽입하세요.\n- 의미론적 쿼리를 실행하세요.\n\n이번 튜토리얼에서는 Atlas UI만 사용하여 작업할 예정입니다.\n\n## 1. 무료 MongoDB ATLAS 클러스터 생성\n\n첫 번째 단계는 MongoDB Atlas 무료 클러스터(M0 클러스터)를 배포하는 것입니다.\n\n\n\n이 튜토리얼에서는 새로운 것을 만들기보다 기존의 Atlas 클러스터를 자유롭게 사용해도 괜찮습니다.\n\n## 2. 속담 및 질의를 위한 MongoDB 컬렉션 생성\n\n이 튜토리얼에서는 같은 데이터베이스에 속한 두 개의 컬렉션을 사용할 것입니다:\n\n- 속담과 그에 대한 내장 값을 저장하는 `vector_search.proverbs`\n- 질의와 답변을 저장하는 `vector_search.queries`\n\n\n\n데이터베이스와 컬렉션은 Atlas UI에서 생성됩니다.\n\n데이터베이스 배포에서 'Collections 찾아보기' 버튼을 클릭하십시오:\n\n![Collections 찾아보기](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_4.png)\n\n그런 다음 Collections 탭에서 + 데이터베이스 생성을 클릭하고 데이터베이스 이름 (vector_search), 첫 번째 컬렉션 이름 (proverbs)을 입력한 후 생성 버튼을 클릭하십시오.\n\n\n\nMarkdown 형식으로 테이블 태그를 바꿔 주세요:\n\n\n![이미지 1](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_5.png)\n\n두 번째 컬렉션을 만들기 위해 데이터베이스 vector_search를 선택하거나 호버한 후, 플러스(+) 아이콘을 클릭하세요.\n\n![이미지 2](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_6.png)\n\n다음으로 vector_search 데이터베이스 내에 queries 컬렉션을 생성하세요:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_7.png\" /\u003e\n\n이제 여러분의 컬렉션이 준비되었어요.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_8.png\" /\u003e\n\n## 3. Hugging Face API 토큰 생성\n\n\n\n프로버브에 대한 벡터 임베딩을 얻기 위해 무료 공개 Hugging Face 추론 API를 사용할 것입니다.\n\n텍스트 임베딩 API를 호출하기 전에 Hugging Face 사이트에서 읽기 액세스 토큰을 생성해야 합니다.\n\nHugging Face 웹사이트로 이동하여 로그인하거나 회원 가입하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_9.png)\n\n\n\n로그인한 후 오른쪽 상단으로 이동하여 프로필 아이콘을 클릭하고 설정을 선택하세요. 그런 다음 프로필 설정 페이지 왼쪽에 있는 Access Tokens를 클릭하고 New Token 버튼을 누르세요.\n\n![Access Tokens](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_10.png)\n\n토큰에 이름을 지정하고 read 역할을 선택한 후 Generate a token을 클릭하세요.\n\n![Generate a Token](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_11.png)\n\n\n\n위의 생성된 토큰을 안전한 위치에 복사하여 저장해주세요.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_12.png)\n\n## 4. 아틀라스로 허깅 페이스 API 토큰 가져오기\n\nHF API를 호출하기 전에 먼저 아틀라스에 이전에 생성된 허깅 페이스 토큰을 가져와야 합니다.\n\n\n\nAtlas UI의 App Services 페이지로 이동해주세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_13.png)\n\nTriggers 애플리케이션(가장 왼쪽 상자)을 클릭한 후, 왼쪽 메뉴에서 Values를 선택하고, Create New Value 버튼을 클릭해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_14.png)\n\n\n\n가장 먼저 할 일은 비밀을 만드는 것입니다. 값을 HF_secret로 지정하고 유형을 Secret으로 선택하여 허깅페이스 토큰을 Add Content 필드에 붙여넣은 다음 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_15.png)\n\n그런 다음, 함수에서 사용할 새 환경 변수를 생성해야 합니다. 이를 위해 오른쪽 상단 버튼의 Create New Value를 다시 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_16.png)\n\n\n\nHF_value라는 이름의 Value 타입의 값을 생성하고 Secret HF_secret에 링크를 걸고 저장을 누르세요. 아래에서 정확히 수행한 것을 따라해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_17.png)\n\n## 5. Atlas 데이터베이스 트리거 및 함수 생성하여 HF API 호출하기\n\nAtlas UI에서 우리는 격언 및 쿼리 컬렉션에 데이터베이스 트리거를 정의할 수 있습니다. 이를 통해 이 컬렉션에 새 문서가 삽입될 때마다 Hugging Face API를 호출할 수 있습니다.\n\n\n\n데이터베이스 트리거를 생성하려면 데이터베이스 배포로 이동한 다음 왼쪽 탐색 메뉴에서 트리거를 클릭하십시오.\n\n\"트리거 추가\" 버튼을 클릭하여 새 트리거를 구성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_18.png)\n\nHF_Create_Embeddings 트리거\n\n\n\nvector_search.proverbs 컬렉션에 대한 첫 번째 트리거인 HF_Create_Embeddings을 생성했습니다. 아래와 같이 트리거를 구성하세요:\n\n![trigger configuration](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_19.png)\n\n함수 섹션에서 Function을 이벤트 유형으로 선택하고, 다음의 자바스크립트 함수 코드를 아래 코드 블록에 붙여넣으세요.\n\n![javascript function code](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_20.png)\n\n\n\n위 양식에 붙여넣을 코드는 다음과 같습니다:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서를 가져옵니다.\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API의 URL과 키를 정의합니다.\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내부의 \"Values\" 유틸리티에서 API 키의 값을 지정한 이름을 사용합니다.\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`ID가 ${doc._id}인 문서 처리 중`);\n\n        // Hugging Face API를 호출하여 임베딩을 가져옵니다.\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 문서 내 데이터를 임베딩할 필드를 지정합니다. 여기서는 샘플 속담 데이터의 \"proverb\" 필드를 사용합니다.\n                inputs: [doc.proverb]\n            })\n        });\n\n        // JSON 응답을 파싱합니다.\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태를 확인합니다.\n        if(response.statusCode === 200) {\n            console.log(\"임베딩을 성공적으로 받았습니다.\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터를 가져옵니다.\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스명으로 변경하세요.\n            const collection = db.collection('proverbs'); // 컬렉션명으로 변경하세요.\n\n            // MongoDB에서 문서를 업데이트합니다.\n            const result = await collection.updateOne(\n                { _id: doc._id },\n                // 새로운 필드에 임베딩을 저장할 이름을 지정합니다.\n                { $set: { proverb_embedding: embedding }\n            );\n\n            if(result.modifiedCount === 1) {\n                console.log(\"문서를 성공적으로 업데이트했습니다.\");\n            } else {\n                console.log(\"문서를 업데이트하는 데 실패했습니다.\");\n            }\n        } else {\n            console.log(`임베딩을 받는 데 실패했습니다. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n트리거 HF_Create_Embeddings는 속담 콜렉션에 삽입된 각 속담에 대한 벡터 임베딩을 얻기 위해 Hugging Face all-MiniLM-L6-v2 모델 API를 호출합니다.\n\nSemantic_Query 트리거\n\n\n\n두 번째 트리거는 쿼리 컬렉션에 생성될 것입니다. 트리거 함수에서는 Hugging Face 임베딩 모델을 호출하여 사용자 쿼리의 임베딩을 가져와 MongoDB 집계 명령을 통해 벡터 검색을 실행할 것입니다.\n\n벡터 검색 결과는 쿼리 컬렉션에 저장될 것입니다.\n\n두 번째 트리거를 만들려면, 첫 번째 트리거와 동일한 프로세스를 따르되, 다음에 설명된 매개변수를 조정해야 합니다 (다른 모든 매개변수 값은 이전과 동일합니다):\n\n이름 Semantic_Query\n\n\n\n컬렉션 이름 쿼리\n\n함수 코드에 다음 블록을 붙여 넣으세요:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서 가져오기\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API URL 및 키 정의\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내의 \"Values\" 유틸리티에서 API 키의 값을 설정한 이름을 사용\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`아이디가 ${doc._id}인 문서 처리 중`);\n\n        // 쿼리의 임베딩을 가져오기 위해 Hugging Face API 호출\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 데이터를 임베딩할 문서 내 필드. 여기선 \"queries\" 컬렉션의 \"query\" 필드입니다.\n                inputs: [doc.query]\n            })\n        });\n\n        // JSON 응답 파싱\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태 확인\n        if (response.statusCode === 200) {\n            console.log(\"임베딩 성공적으로 수신\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터 가져오기\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스 이름으로 대체\n            const proverbs_collection = db.collection('proverbs'); // 컬렉션 이름으로 대체\n            const queries_collection = db.collection('queries'); // 컬렉션 이름으로 대체\n\n            // 유사 문서 쿼리\n            const documents = await proverbs_collection.aggregate([\n                {\n                    \"$search\": {\n                        \"index\": \"vector_search_index\",\n                        \"knnBeta\": {\n                            \"vector\": embedding,\n                            \"path\": \"proverb_embedding\",\n                            \"k\": 2\n                        }\n                    }\n                },\n                {\n                    \"$project\": {\n                        \"_id\": 0,\n                        \"proverb\": 1\n                    }\n                }\n            ]).toArray();\n            \n            // MongoDB에서 문서 업데이트\n            const result = await queries_collection.updateOne(\n                { _id: doc._id },\n                // \"answer\" 필드에 쿼리 결과가 포함됩니다.\n                { $set: { query_embedding: embedding, answer: documents }\n            });\n\n        } else {\n            console.log(`임베딩 수신 실패. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n## 6. 벡터 탐색 인덱스 생성\n\n\n\n우리는 직역 검색을 가능하게 하기 위해 속담 모음에 벡터 검색 인덱스를 생성해야 합니다. 속담 모음은 우리의 쿼리에 응답하기 위해 검색될 속담 문장의 임베딩(proverb_embedding 필드)을 포함할 것입니다.\n\n인덱스를 생성하려면 다음을 수행하세요. Atlas Search로 이동: 데이터베이스 배포 페이지에서 왼쪽 메뉴에서 검색을 클릭한 후, 데이터 원본 선택 드롭다운 메뉴에서 클러스터를 선택하고 Go to Atlas Search 버튼을 누릅니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_21.png)\n\n새로운 검색 인덱스를 구성하려면 Create Search Index 버튼을 클릭하세요:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_22.png)\n\n다음 페이지에서 JSON Editor 상자를 선택하고 Next 버튼을 누르세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_23.png)\n\n데이터베이스 및 컬렉션 영역에서 vector_search 데이터베이스와 proverbs 컬렉션을 선택하고, Index Name 필드에 vector_search_index라는 인덱스 이름을 지정하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_24.png\" /\u003e\n\n다음 JSON 문서를 텍스트 영역에 붙여넣고 '다음' 버튼을 클릭해주세요.\n\n```js\n{\n  \"mappings\": {\n    \"dynamic\": true,\n    \"fields\": {\n      \"proverb_embedding\": {\n        \"dimensions\": 384,\n        \"similarity\": \"dotProduct\",\n        \"type\": \"knnVector\"\n      }\n    }\n  }\n}\n```\n\n'검색 인덱스 생성'을 클릭하면 인덱스 생성이 시작됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_25.png\" /\u003e\n\n곧 새로운 인덱스가 활성 상태로 사용 가능할 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_26.png\" /\u003e\n\n## 7. 경구 데이터 세트를 MongoDB에 삽입하기\n\n\n\n우리는 임베딩 스토어를 채우기 위해 영어 속담을 속담 컬렉션에 삽입할 것입니다. Atlas UI에서 하나의 속담을 추가할 것입니다.\n\n우리가 삽입하는 첫 번째 속담은 다음과 같습니다:\n\n속담을 삽입하려면:\n\n- 데이터베이스 배포 페이지에서 Browse Collections로 이동하세요.\n- vector_search 데이터베이스 아래에 있는 proverbs 컬렉션을 선택하세요.\n- \"proverb\"를 필드 이름으로 하고 속담 문장을 값으로 하는 단일 필드 문서를 추가하세요.\n- 그런 다음 삽입을 눌러주세요.\n\n\n\n마법처럼 새로운 필드인 'proverb_embedding'이 문서에 추가됩니다:\n\n'proverb_embedding' 필드에는 HF_Create_Embeddings 트리거에서 호출된 Hugging Face 텍스트 임베딩 모델 API에 의해 생성된 임베딩 벡터(384개의 부동 소수점 요소가 있는 배열)가 포함되어 있습니다.\n\n\n\n자세한 것은 나중에 업데이트됩니다.\n\n\n\n늦게라도 하는 것이 낫죠.\n\n호기심은 고양이를 죽인다고 해요.\n\n불에 노는 바보는 불에 탄다고 하잖아요.\n\n정의를 미루면 결국 물거품이 돼버립니다.\n\n\n\n밤은 충고를 안겨줍니다.\n\n로마는 하루 만에 지어지지 않았어요.\n\n울타리 너머에 있는 잔디가 더 푸릅니다.\n\n우리 속담 컬렉션에는 10개의 문서가 있어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_29.png\" /\u003e\n\n## 8. Semantic queries 실행하기\n\n검색을 실행하기 위해 쿼리 컬렉션에 단일 필드 문서를 삽입할 것입니다. 필드 이름은 \"query\"이고 값은 다음과 같이 우리 검색어의 텍스트입니다:\n\n' \"query\": \"Things that look good outwardly may not be as valuable or good.\"'\n\n\n\n새로운 문서가 쿼리 컬렉션에 삽입되면 `Semantic_Query` 트리거가 실행됩니다:\n\n- 속담 문장을 전달하여 쿼리의 임베딩을 얻기 위해 Hugging Face API를 호출합니다.\n- 받은 임베딩 벡터를 문서 자체에 저장합니다 (query_embedding 필드).\n- MongoDB 집계 명령어를 통해 vector_search_index에서 벡터 검색을 실행합니다.\n- 검색 결과를 문서 자체에 저장합니다 (answer 필드).\n\n쿼리를 테스트하려면 \"Collections\" 탭으로 이동하여 쿼리 컬렉션에 쿼리를 삽입하세요:\n\n![2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png)\n\n\n\n여기 답변이 있어요:\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_31.png)\n\n우리 질문과 가장 유사한 의미를 가진 속담 두 개는 다음과 같습니다:\n\n\"반짝이는 것이 모두 금은 아니다.\" 그리고 \"만능 재주꾼은 아무것도 제대로 할 수 없다.\"\n\n\n\n정답이 잘 보입니다! 데이터셋과 쿼리를 실험해 볼 수 있습니다. 또한 OpenAI 텍스트 임베딩 API와 같은 다양한 임베딩 모델을 테스트하여 응답의 정확성을 평가할 수도 있습니다.\n\n# 참고 자료\n\n- MongoDB Atlas 매뉴얼\n- MongoDB Atlas 벡터 검색\n- MongoDB Atlas 검색 튜토리얼\n- 일반적인 영어 속담\n- Hugging Face 텍스트 임베딩 모델\n\nMongoDB에 대한 지식을 확장하고 싶다면 How MongoDB Works에 대한 제 논문을 살펴보세요.\n\n\n\n제가 쓰는 이야기를 좋아해주시고 지원하고 싶으시다면, Medium 회원이 되어서 지원해주실 수 있어요. 매달 $5를 내면 Medium의 모든 이야기에 무제한 액세스할 수 있어요. 저의 추천 링크를 사용해서 가입하면, 작은 커미션을 받을 수 있어요. 고려해 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png","tag":["Tech"],"readingTime":15},{"title":"리액트에서의 동적 임포트","description":"","date":"2024-05-14 15:30","slug":"2024-05-14-DynamicImportsinReact","content":"\n\n![Dynamic Imports in React](/assets/img/2024-05-14-DynamicImportsinReact_0.png)\n\nReact에서의 동적 가져오기는 런타임에서 JavaScript 모듈을 동적으로로드할 수 있게 해줍니다. 이는 응용 프로그램의 성능과로드 시간을 크게 향상시킬 수 있습니다. 이 기술은 코드 분할 및 지연 로드에 특히 유용하며 필요할 때만 필요한 코드를로드합니다.\n\nimport() 함수는 사용하고자하는 동적 가져오기 모듈로 해결되는 Promise를 반환합니다.\n\nJavaScript의 일반적인 import문(import 문을 사용)은 Promise를 반환하지 않습니다. 동기 작업이므로 가져온 모듈에서 내보낸 값을 반환합니다.\n\n\n\n```js\r\nimport React from 'react';\n\nconst AnotherComponent = () =\u003e {\n  return \u003cdiv\u003e다른 컴포넌트가 동적으로 로드되었습니다!\u003c/div\u003e;\n};\n\nexport default AnotherComponent;\r\n```\n\n```js\r\nconst MyComponent = () =\u003e {\n  const [importedComponent, setImportedComponent] = useState(null);\n\n  useEffect(() =\u003e {\n    const importComponent = async () =\u003e {\n      const module = await import('./AnotherComponent');\n      const AnotherComponent = module.default;\n      setImportedComponent(\u003cAnotherComponent /\u003e);\n    };\n\n    importComponent();\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      {importedComponent}\n      \u003cdiv\u003e이것은 내 기능적인 컴포넌트입니다!\u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\n///다른 방법은 ...///\nconst MyComponent = async () =\u003e {\n  const module = import('./AnotherComponent');\n  const {AnotherComponent} = await module;\n  return \u003cAnotherComponent /\u003e;\n};\n\nexport default MyComponent;\n\n// 콘솔에서 내보낸 모듈을 확인할 때 { default: \"\"}는 모든 함수 이름을 키로 하고 \n// 값으로 정의를 포함하며, default 키가 있으면 default로 가져온 것이 값이 되고, \n// 그렇지 않으면 정의가 없는 것이 됩니다.\r\n```\n\n## 동적 가져오기를 언제 사용해야 할까요?\n\n동적 가져오기는 React 애플리케이션의 성능을 향상시키는 좋은 방법이지만, React 앱에서 동적 가져오기를 사용하는 더 좋은 사용 사례가 있습니다.\n\n\n\n- 코드 모듈화: 동적 가져오기는 코드 모듈화와 서버에서 데이터를 가져올 필요가 있을 때 사용할 수 있습니다. 예를 들어 서버 측 렌더링 애플리케이션에서 이를 사용할 수 있습니다.\n- 애플리케이션이 아직 로딩 중인 경우 컴포넌트가 필요하지 않을 때 동적 가져오기를 사용할 수 있습니다.\n- 조건부 가져오기는 동적 가져오기에 대한 우수한 사용 사례입니다. 여기서 모듈 또는 컴포넌트는 필요한 페이지에서만 가져오며 애플리케이션에서 필요한 경우에만 가져옵니다.\n\n## React.lazy()\n\nReact.lazy() 함수를 사용하면 동적 가져오기를 일반 컴포넌트로 렌더링할 수 있습니다. 기본적으로 React.lazy()는 동적 가져오기를 호출하고 프로미스를 반환합니다.\n\n```js\nimport React, { lazy } from \"react\";\nconst Blog = React.lazy(() =\u003e \n  import('./Pages/Blog'));\n```\n\n\n\n# React.Suspense()\n\nReact.Suspense는 React 개발자가 React 컴포넌트의 렌더링을 로드될 때까지 중단시킬 수 있게 합니다. React.Suspense는 JSX 코드 조각 또는 React 컴포넌트인 React 요소를 허용하는 fallback 속성을 제공합니다.\n\nReact 동적 임포트를 이용해 페이지를 방문하는 사용자들은 종종 빈 페이지 화면을 경험합니다. 이는 애플리케이션이 모듈을 로드하는 동안 수행되며, 일부 사용자는 느린 인터넷 연결로 인해 오류가 발생할 수도 있습니다. React.lazy()와 React.Suspense를 결합하여 이 문제를 해결할 수 있습니다.\n\n이를 위해 React.Suspense를 사용하여 모든 종속성이 지연 로드될 때까지 컴포넌트의 렌더링을 중단하고, React.Suspense는 사용자를 위한 대체 UI를 표시할 것입니다.\n\n\n\n```js\nimport React, { Suspense } from 'react';\n\nconst LazyComponent = React.lazy(() =\u003e import('./LazyComponent'));\n\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cLazyComponent /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n알고 싶은 내용이 있다면 구독, 박수, 좋아요 및 공유하세요. 건배!","ogImage":{"url":"/assets/img/2024-05-14-DynamicImportsinReact_0.png"},"coverImage":"/assets/img/2024-05-14-DynamicImportsinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"작별인사, Ramda","description":"","date":"2024-05-14 15:28","slug":"2024-05-14-FarewellRamda","content":"\n\n## 옛날 코드를 해독하느라 수고스러운 적이 있으신가요? 종종 Ramda가 관련되어 복잡한 작업을 하게 만들어 다른 간단한 대안을 찾게 했었죠.\n\n![Ramda 이미지](/assets/img/2024-05-14-FarewellRamda_0.png)\n\n# 소개\n\n두 해 전의 코드를 만나서 변경을 하려고 애를 쓰시는 일이 있었나요? 수정할 곳을 찾기 위해 많은 시간을 들이지만 어디서 어떻게 변경을 해야 할지 알 수 없는 경우가 많아요. 가끔 그럴 때마다, 아주 놀라운 일인데 고대 문명의 암호화된 메세지를 해독하려는 느낌과도 같은 것이었어요. 저는 이런 경험을 여러 차례 해왔는데, 대부분 Ramda가 관련되어 있었습니다. 이 경험이 중복됨을 느끼며, 대안을 탐구하고 제 코드 유지보수 전략을 재고하게 되었죠.\n\n\n\n# 새로운 Ramda의 탐험\n\nRamda는 함수형 프로그래밍 원칙을 받아들이고 견고한 유틸리티 함수 세트를 제공하여 여러분을 강력하게 지원하는 환상적인 JavaScript 라이브러리입니다. 이 라이브러리는 불변 데이터를 다루고 함수를 조합하며 코드에 선언적인 풍미를 불어넣는 데 주력합니다. Ramda를 사용하면 자동으로 커링이 될 뿐만 아니라 함수를 부드럽게 조합하고 불변 데이터를 간편하게 다룰 수 있습니다. 또한, 함수의 인수를 명시적으로 언급하지 않고 정의하는 포인트프리 스타일의 우아함을 받아드리도록 격려합니다. Ramda는 JavaScript 프로젝트에서 함수형 프로그래밍을 더 접근하기 쉽고 표현력있고 즐거운 경험으로 만들어냅니다.\n\nRamda를 사용하기 시작했을 때, \"와우\" 효과를 경험했습니다. 선언적인 코드가 얼마나 우아해졌는지를 즐겼고, 툴킷의 유용한 함수들 덕분에 복잡한 논리를 한 문장으로 표현할 수 있었습니다. Ramda로 과제를 해결할 때마다 뇌에서 보상 느낌을 받았습니다. 더 많은 논리를 통합할 수 있었을 때 더 큰 만족감을 느꼈습니다. 또한 이 같은 감정 이외에도 Ramda는 데이터 불변성 유지, 선언적 표현을 강화하고 편리한 도우미 함수 세트를 통해 루틴 작업을 해결하는 등 여러 가지 방법으로 코드를 획기적으로 개선시켰습니다.\n\n# Ramda의 쇠퇴와 JavaScript의 부흥\n\n\n\n그러나 JavaScript가 진화함에 따라 저와 많은 동료들은 Ramda, Lodash 등의 라이브러리를 대체하여 언어의 기본 도구와 기능을 점차적으로 더 많이 활용하게 되었습니다.\n\n어떤가요? 언어의 기본 기능만을 사용하여 간단하고 깔끔한 코드를 작성하는 그 기분이 참 달콤하지 않나요? 제가 생각하기에 우리 모두가 한 번쯤은 느꼈을 거에요. 개발자로서 우리는 무엇을 가장 잘 알고 있는지에 자주 익숙해지는 경향이 있습니다. 그래서 이 경우에는 구식이지만 좋은 기존의 네이티브 JavaScript에 더 많이 기댈 때가 많아요.\n\n마치 꾸준하고 깔끔한 컵 커피를 즐기는 것처럼, 네이티브 JavaScript로 작업하는 것에는 특별한 즐거움이 있습니다. 이것은 우리에게 새로운 라이브러리의 세세한 사항을 배우지 않고도 즉시 시작할 수 있는 익숙함과 직관성을 제공해줍니다.\n\nES5 시절부터 ES2015, ES2017를 거쳐 새롭고 화려한 ES2020까지 자바스크립트는 크게 성장했습니다. 각 업데이트는 새로운 멋진 기능을 가져와 우리의 코딩 생활을 훨씬 더 간단하게 만들어주었으며, 자바스크립트 코드의 기능 및 선언적 성격을 크게 향상시켰습니다.\n\n\n\n먼저 배열을 다루는 map(), reduce(), filter()와 같은 고차 함수부터 시작해보죠. 이제 이들은 쉬울 정도로 쉽게 느껴졌어요. 만만한 일이었죠.\n\n다음으로 멋진 화살표 함수가 등장했어요. 이런 신규 추가 기능들은 간결하고 직관적이었어요. 코드를 읽고 이해하기 쉽게 만들어 주었죠.\n\n이어서 템플릿 리터럴이 등장했는데, 이것들은 문자열 다루기를 바꿔 놓았어요. 더 이상 복잡한 연결 작업은 사라지고, 부드럽고 신뢰할 수 있는 문자열 생성만 남았죠.\n\n펼침 구문은 또 다른 유용한 추가였어요. 배열이나 객체를 확장하거나 변경 불가능성을 유지하는 것이 쉬워졌죠. 마지막으로 파괴 할당, 옵셔널 체이닝, 널 병합 연산자라는 유용한 세 가지를 갖게 되었어요. 이들은 코드를 더 쉽고 눈에 잘 들어오도록 만들어 주었어요.\n\n\n\n네이티브 JavaScript 기능을 사용하면 익숙함과 간편함을 느낄 수 있어요. 이런 친숙함 덕분에 개발자들은 학습 과정 없이도 생성할 수 있어요. 우리 많은 이들은 이 언어의 핵심에 매료되어 있어요. JavaScript의 핵심이자 경량화되고 유연한 네이티브 기능들은 JavaScript의 핵심이자 최적화가 고려된 성능 또한 가지고 있어요.\n\n예를 들어, 람다(Ramda)와 같은 라이브러리는 코드를 추가적인 추상적인 단계로 둘러싸지만, 네이티브 JavaScript는 빠른 속도로 실행됩니다.\n\nJavaScript 엔진인 V8과 같은 엔진의 최적화로 이러한 기능들은 더욱 발전합니다. V8의 개발자들은 지속적으로 네이티브 기능들에 최적화를 진행하고 있어요. 이는 JavaScript 코드가 원활하고 빠르게 실행되도록 보장해줍니다. JavaScript 코드가 웰오일 된 기계처럼 돌아가게 해줘요.\n\n하지만 속도만이 중요한 것은 아니에요. 통합성과 호환성도 중요해요. 이러한 네이티브 기능은 다른 언어의 부분들과 원활하게 연계되어 작동하며, 다양한 API와 JavaScript의 광범위한 생태계와 조화롭게 작동해요.\n\n\n\n네이티브 JavaScript의 또 하나의 장점은 다양한 ECMAScript 버전과의 호환성 및 최소한의 종속성을 가지고 있다는 것입니다. 지속적인 ECMAScript 업데이트로 계속해서 발전하는 이 언어는 많은 개발자들에게 최고의 선택지입니다. 원래 것이 이렇게 잘되는데 새로운 것을 찾아야 할 이유가 무엇인가요?\n\n# \"람다마이즈드\" TypeScript에 머리를 쥐어박다\n\n프로젝트를 TypeScript로 전환하고 기존의 람다 코드를 통합하려고 할 때 새로운 문제가 발생할 수 있습니다. TypeScript는 정적 타입을 제공하여 코드 안전성을 향상시키고 개발자 생산성을 증가시키는 장점을 제공합니다. 그러나 TypeScript에 람다를 섞을 때는 타이핑 접근 방식과 호환성의 차이로 인해 약간 까다로워질 수 있습니다.\n\n람다 함수에서 사용하는 타입이 TypeScript typings와 일치하는지 확인하는 것이 주요한 고민거리입니다. 람다는 일부 TypeScript typings을 제공하지만 모든 시나리오를 다루지 못하거나 최신 람다 버전과 호환되지 않을 수 있습니다. 이로 인해 기대하는 타입과 추론된 타입 간의 불일치가 발생할 수 있어 소매를 걷어 올리고 타입 주석을 수동으로 처리하거나 사용자 정의 typings를 생성해야 할 수도 있습니다.\n\n\n\n또 다른 도전 과제는 Ramda의 함수형 프로그래밍 스타일인데, 함수 커링과 함수 조합이 있어 복잡할 수 있어요. TypeScript의 타입 추론은 이러한 각종 마무리를 따라가기에 어려울 수 있어요. 그래서 명시적인 타입 주석을 추가하거나 추가적인 어서션을 해야 모든 것이 제자리에 있도록 관리할 수 있어요. 이건 좀 복잡해지며 코드를 읽기 어렵고 유지보수하기 힘들 수 있어요.\n\n더군다나, Ramda 코드가 TypeScript를 염두에 두지 않고 작성됐다면, 적절한 타입 주석과 문서가 부족할 수 있어요. 이는 TypeScript 규칙을 맞추고 타입 안전성을 보장하기 위해 코드 베이스를 리팩토링하고 적응시키기 위해 추가 시간과 노력을 투자해야 할 수 있다는 걸 의미해요.\n\n한편, TypeScript와 함께 네이티브 JavaScript 기능을 사용하면 이러한 문제들을 해결할 수 있어요. TypeScript가 걱정 없이 타입을 정확하게 처리할 수 있어서 여러분의 삶을 훨씬 쉽게 만들 수 있어요. 원활한 통합과 향상된 TypeScript 지원은 네이티브 JavaScript 기능을 TypeScript 프로젝트에 매력적인 옵션으로 만들어 줘요, 특히 타입 안전성과 효과적인 개발을 목표로 할 때 더욱 그렇답니다.\n\n# 말은 그만하고 코드를 보여줘\n\n\n\nRamda로 작성된 이 코드를 살펴보겠습니다. 이 코드는 매우 복잡한 논리를 수행하지는 않습니다. 상황 자체는 꽤 직관적입니다. 그러나 이에도 불구하고 이 스니펫의 논리를 이해하기 위해 내 두뇌는 노력해야 합니다.\n\n```js\nconst result = R.pipe(\n  R.filter(R.both(\n    R.propSatisfies(R.gt(R.__, 25), 'age'),\n    R.pathEq(['address', 'country'], 'USA')\n  )),\n  R.map(R.prop('name'))\n)(users)\n\n// 🤔 🤔 🤔\n```\n\n이 코드는 사용자의 나이와 거주 국가에 따라 사용자 목록을 필터링하며, 특히 미국에 거주하며 25세 이상인 사용자를 찾습니다. 위의 Ramda 예시는 R.pipe()를 사용하여 다중 작업을 연결해 함수형 프로그래밍 원리를 적용합니다. 논리가 제일 복잡한 것은 아니지만, 함수들의 계층적인 조합은 이해하기 위해 잠깐의 고민(또는 두 번의 고민)이 필요합니다.\n\n이를 Lodash로 다시 작성하여 좀 더 나은 코드로 만들어볼 수 있습니다\n\n\n\n```js\nconst resultL2 = _.map(\n  _.filter(\n    users,\n    user =\u003e user.age \u003e 25 \u0026\u0026 user.address.country === 'USA'\n  ),\n  'name'\n)\n\n// 👌👌👌\n```\n\n바로 Lodash 버전은 더 친근하다 느껴집니다. filter()와 map()을 사용해 콜백 함수 내에서 필터 조건을 직접적으로 표현하여 우리의 삶을 간단하게 만들어 줍니다. 그럼에도 불구하고 개선의 여지가 있다면, 더 간소화할 수 있는 방법은 여전히 남아 있습니다.\n\n더 나아가서 이를 순수 JavaScript만 사용하여 다시 작성해 보겠습니다:\n\n```js\nconst result = users\n  .filter(\n    user =\u003e user.age \u003e 25 \u0026\u0026 user.address.country === 'USA'\n  )\n  .map(user =\u003e user.name)\n\n// 🥹🥹🥹\n```\n\n\n\n아름다운!\n\n구문은 간단하고 직관적이며 핵심 논리에서 우리 주의를 분산시키는 추상화 요소가 없습니다. 읽고 이해하기 쉬운 작업 목록이 표시됩니다. 동일한 필터링 및 매핑 작업을 수행하기 위해 filter() 및 map() 배열 메서드를 사용합니다. 필터링 조건은 콜백 함수 내부에 직접 작성되어 코드 스니펫을 더 읽기 쉽게 만듭니다. 실제로, 심지어 내 할머니도 이 코드를 읽어낼 수 있을 것 같아요.\n\n전통적 코딩 스타일에 익숙한 사람들은 Ramda의 함수형 프로그래밍 및 커링 사용량이 많고 사용되는 이름 짓기 관행 때문에 코드를 이해하기 어려울 수 있습니다. 특히 프로젝트 내에서 다른 코드 스타일 사이를 전환해야 할 때는 더 어려울 수 있습니다. 본질적으로 특정 관행에 익숙하지 않은 경우 Ramda 코드를 읽는 것은 퍼즐을 푸는 것과 같을 수 있습니다. 이러한 낯설음으로 인해 여러 코딩 패러다임을 동시에 처리할 때 특히 읽고 따라가기 어려울 수 있습니다.\n\n# 일부 변론의 말씀\n\n\n\n잘못 이해하지 마세요. 이전에 제기한 우려에도 불구하고 Ramda는 적절하게 활용될 때 강력한 도구임은 부인할 수 없어요.\n\n이 도구는 기능 프로그래밍에 완전히 헌신된 프로젝트에서 정말 빛을 발합니다. 하지만 프로젝트가 서로 다른 코딩 스타일을 오가는 혼합 모델이라면 JavaScript와 Lodash를 사용하는 게 더 편한 선택이 될 수도 있어요. 목표는 가장 멋진 도구를 사용하는 것이 아니라 명확하고 효율적인 코드를 작성하는 것이라는 걸 기억해 주세요.\n\nJavaScript는 기능 스타일을 손쉽게 처리할 수 있는 능력이 향상되어 지금껏 잘 작동해 왔고, Lodash 역시 너무 복잡함 없이 다양한 작업을 처리하는 데 탁월한 능력을 발휘해 왔어요.\n\n프로젝트 전체에 일관된 코딩 스타일을 유지하는 것도 도움이 될 수 있어요. 이는 팀에 새로 합류한 사람이 빠르게 적응할 수 있도록 단합감을 가져다 주기 때문에 매우 중요합니다. 빠르게 적응하면 빠르게 기여할 수 있어요.\n\n\n\n# 결론\n\nRamda는 분명 강점이 있고 함수형 프로그래밍 분야에서 중요한 위치를 차지하지만, 프로젝트에서 다양한 코딩 스타일을 사용하는 경우에는 항상 최적의 선택이 되지는 않을 수 있습니다. 이러한 상황에서는 현대 네이티브 JavaScript와 Lodash를 계속 사용하는 것이 더 나을 수도 있습니다. 궁극적으로, 우리의 목표는 단지 복잡한 도구만 사용하는 것이 아니라 효과적이고 명확한 코드를 작성하는 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-FarewellRamda_0.png"},"coverImage":"/assets/img/2024-05-14-FarewellRamda_0.png","tag":["Tech"],"readingTime":7}],"page":"102","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"102"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>