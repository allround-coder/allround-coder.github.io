<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/56" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/56" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 웹앱에서 SonarQube를 사용한 정적 분석" href="/post/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 웹앱에서 SonarQube를 사용한 정적 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 웹앱에서 SonarQube를 사용한 정적 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 웹앱에서 SonarQube를 사용한 정적 분석</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactjs 앱에서 Google 번역 API를 이용한 언어 번역 구현하기" href="/post/2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactjs 앱에서 Google 번역 API를 이용한 언어 번역 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactjs 앱에서 Google 번역 API를 이용한 언어 번역 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reactjs 앱에서 Google 번역 API를 이용한 언어 번역 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="7가지 리액트 상태 관리 방법(2024년 최신)" href="/post/2024-05-12-7BestPracticesReactStateManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="7가지 리액트 상태 관리 방법(2024년 최신)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="7가지 리액트 상태 관리 방법(2024년 최신)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">7가지 리액트 상태 관리 방법(2024년 최신)</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular16 애플리케이션에서 CORS 문제 해결하기" href="/post/2024-05-12-CORSIssuesFixinginAngular16Application"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular16 애플리케이션에서 CORS 문제 해결하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular16 애플리케이션에서 CORS 문제 해결하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular16 애플리케이션에서 CORS 문제 해결하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="상태 관리자인 Zustand와 JS 메모리" href="/post/2024-05-12-ZustandStateManagerAndJSMemory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="상태 관리자인 Zustand와 JS 메모리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="상태 관리자인 Zustand와 JS 메모리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">상태 관리자인 Zustand와 JS 메모리</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" href="/post/2024-05-12-SettingESLintonaReactTypescriptproject2022"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" href="/post/2024-05-12-DeepDiveintoImplementingreact-native-image-picker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브 이미지 피커 구현에 대한 심층 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브 이미지 피커 구현에 대한 심층 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" href="/post/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 페이지와 함께 페이지네이션하기" href="/post/2024-05-12-PaginationinReactNativewithPage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 페이지와 함께 페이지네이션하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 페이지와 함께 페이지네이션하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 페이지와 함께 페이지네이션하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" href="/post/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 웹앱에서 SonarQube를 사용한 정적 분석","description":"","date":"2024-05-12 22:25","slug":"2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp","content":"\n\n(2023년 11월 업데이트) 보안은 코드를 작성할 때 집중해야 하는 가장 중요한 주제 중 하나입니다. 안정적이고 품질 높은 제품을 갖기 위해서는 코드에 취약점이 없는지 확인해야 합니다. 프로젝트에 따라 우리는 더 정교한 소프트웨어를 사용하여 코드를 테스트해야 할 수도 있습니다. 이 글에서는 샘플 React JS 프로젝트에 SonarQube를 사용하여 정적 분석을 실행할 것입니다. 주 언어로 javascript를 사용하는 장점 중 하나는 Veracode 보고서에 따르면 심각도가 낮은 결함이 있다는 것입니다.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_0.png)\n\n# 정적 분석이란?\n\nOWASP에 따르면 정적 응용 프로그램 보안 테스트(SAST)는 보안 결함을 찾는 데 도움이 되도록 코드 소스나 컴파일된 코드 버전을 분석하는 도구입니다.\n\n\n\n# SonarQube가 무엇인가요?\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_1.png)\n\nSonarQube는 프로젝트에서 버그, 취약점 및 코드 향수를 탐지하는 자동 코드 검토 도구입니다. 이 도구는 27가지 다른 프로그래밍 언어를 지원합니다.\n\n다양한 요구 사항에 따라 다른 계획이 있지만, 이 게시물에서는 무료이며 오픈 소스인 커뮤니티 버전을 사용할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_2.png\" /\u003e\n\n# 왜 SonarQube를 사용해야 하는가?\n\n- 상용 제품과 비교하더라도 오픈 소스 버전은 무료이다.\n- 개발자가 더 깨끗하고 안전한 코드를 작성할 수 있도록 돕는다.\n- 깨끗하고 유지보수 가능한 코드로 기술 부채를 줄이고 개발자의 속도를 높이는 데 도움을 준다.\n- 프로덕션으로 이동하기 전에 가능한 보안 결함을 식별할 수 있도록 도와준다.\n- CI/DC 흐름에 추가할 수 있다.\n- 예방책은 문제가 발생했을 때 큰 보안 문제를 해결하는 것보다 항상 더 저렴하다.\n\n# 로컬 PC에 SonarQube 설정하기\n\n\n\n이 게시물은 ReactJS 프로젝트에 SonarQube를 구성하는 방법을 보여줍니다. 그러나 비슷한 설정은 React Native 또는 다른 Node.js 프로젝트에도 사용할 수 있습니다.\n\n단계 1: PC에 도커가 설치되어 있는지 확인하세요. 아직 설치하지 않았다면 여기서 다운로드할 수 있습니다.\n\nReact 프로젝트에 \"sonarqube-scanner\" 패키지를 설치하세요.\n\n```js\nyarn add --dev sonarqube-scanner\n```\n\n\n\n단계 2: 프로젝트 폴더의 루트에 docker-compose.yml 파일을 생성하고 아래 코드를 붙여넣으세요. 우리는 최신 LTS 버전인 sonarqube 8.9.10을 사용합니다.\n\n단계 3: 프로젝트 폴더 루트에 sonarqube 폴더를 만들어서 다음 내용을 담은 sonarscan.js 파일을 추가하세요.\n\n나중에 사용될 projectName과 projectKey를 사용자 정의할 수 있습니다. 또한 토큰은 그 때 업데이트될 것입니다.\n\n단계 4: SonarQube 서버를 시작하려면 다음 명령을 실행하세요.\n\n\n\n```js\r\n도커 컴포즈 업\r\n```\r\n\r\n단계 5: SonarQube에 로그인하려면 http://localhost:9000로 이동하십시오. 다음 자격 증명을 사용해야 합니다.\r\n\r\n```js\r\n로그인: admin\r\n비밀번호: admin\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_3.png\" /\u003e\n\n\n\n시스템에 로그인하면 비밀번호를 변경해야 하며, 마지막으로 주요 대시보드를 볼 수 있고 새 프로젝트를 생성할 준비가되었습니다. 수동으로 선택하십시오.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_4.png)\n\n단계 6: 프로젝트 이름을 선호하는대로 지정하십시오. React 프로젝트와 동일한 이름을 사용하는 것을 권장합니다.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_5.png)\n\n\n\nStep 7: 프로젝트를 위한 토큰을 생성하세요. 원하는 이름을 사용할 수 있습니다. 제가 my_test_app을 사용해서 쉽게 기억할 수 있도록 했어요. 토큰이 생성되면 안전한 곳에 저장해주세요. 나중에 필요할 거예요.\n\n로컬에서 선택하세요.\n\n![이미지 1](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_6.png)\n\n![이미지 2](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_7.png)\n\n\n\n이 토큰을 저장해야 합니다. 이 토큰은 나중에 분석을 실행하는 데 사용될 것입니다!\n\n![Image](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_8.png)\n\n단계 8: 새 스캔 시작.\n\n만약 git을 사용 중이라면, 다음 줄을 .gitignore 파일에 추가해주세요.\n\n\n\n```js\n.scannerwork\nsonarqube/extensions\nsonarqube/data\nsonarqube/logs\n```\n\n다음 명령어를 다른 터미널에서 실행해 주세요.\n\n```js\nnode ./sonarqube/sonarscan.js\n```\n\n만약 모든게 올바르다면, 잠시 기다리시면 콘솔에 성공 메시지가 표시됩니다.```\n\n\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_9.png)\n\n단계 9: 마지막으로 SonarQube 대시보드로 돌아가서 코드에 얼마나 많은 버그, 취약점, 보안 핫스팟, 코드 냄새가 있는지 확인하세요.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_10.png)\n\nSonarQube는 멋진 도구입니다. 코드 버그, 취약점, 코드 냄새를 보여줄 뿐만 아니라 해결 방법도 제시해줍니다.\n\n\n\n- 버그: 이것은 프로그래머가 특정 동작을 구현하려고 할 때 발생하는 문제로, 코드가 올바르게 이 동작에 부합하지 않는다는 것은 잘못된 코딩으로 인한 것입니다. 이것은 어제 고쳐져야 합니다. 빨리 해결해야 합니다.\n- 취약점: 이 결함은 해커가 코드를 악용하여 데이터를 추출하거나 소프트웨어를 변조하거나 더 나쁜 경우에는 모든 것을 삭제할 수 있는 문제를 초래할 수 있습니다.\n- 보안 핫스팟: 개발자가 수동으로 검토해야 하는 보안에 민감한 코드 부분입니다. 검토 후에 위협이 없다고 판단되거나 코드를 보안하기 위한 수정이 필요할 수 있습니다.\n- 코드 스멜: 코드 내에서 발생하는 유지보수 관련 문제입니다. 이는 나중에 발생하는 변경을 어렵게 만들며 미래의 변경으로 추가 오류를 발생시킬 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_11.png)\n\n추가 보너스 단계: 검사 보고서를 출력해야 하는 경우, 이 플러그인을 다운로드하고 설치할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_12.png)\n\n\n\n참고: 이 플러그인은 SonarQube의 최신 LTS 버전과만 호환됩니다.\n\n서버를 다시 시작하고 최종적으로 보고서를 내보내야 할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_13.png)\n\n여기에서 Github에서 샘플 프로젝트를 얻을 수 있습니다.\n\n\n\n\"저는 소나린트, HCL AppScan CodeSweep 및 ESLint를 사용하는 것을 추천합니다. 코드를 작성하는 동안 문제를 찾는 데 정말 도움이 됩니다.\n\n이 게시물을 읽어 주셔서 감사합니다 😃 !!\n\n# 도와드릴 일이 있나요?\n\n우리는 당신을 듣기 위해 준비되어 있습니다. 다음 큰 일을 위해 도움이 필요하다면 저희 팀에 웹사이트나 info@jrtec.io로 연락해 주세요.\"","ogImage":{"url":"/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_0.png"},"coverImage":"/assets/img/2024-05-12-StaticAnalysisUsingSonarQubeinaReactWebapp_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs 앱에서 Google 번역 API를 이용한 언어 번역 구현하기","description":"","date":"2024-05-12 22:23","slug":"2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI","content":"\n\n![이미지](/assets/img/2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI_0.png)\n\nReact.js 애플리케이션에 언어 번역 기능을 통합하고 싶으신가요? Google Translate API를 사용하면 쉽게 이 목표를 달성할 수 있습니다. React.js 프로젝트에서 언어 번역 기능을 설정하고 구현하는 간단한 단계를 따라보세요.\n\n1. Google Cloud 프로젝트 설정:\n\n- Google Cloud Console로 이동합니다.\n- 새 프로젝트를 생성하거나 기존 프로젝트를 선택합니다.\n- 프로젝트에 \"Cloud Translation API\"를 활성화합니다.\n\n\n\n2. API 키 얻기:\n\n- 클라우드 콘솔에서 “API 및 서비스\" → “자격 증명\"으로 이동합니다.\n- 새 API 키를 생성합니다.\n- API 요청을 만들 때 이 API 키가 필요하므로 이를 접근 가능한 상태로 유지하세요.\n\n3. 종속성 설치:\n\n- React.js 프로젝트의 터미널을 열고 필요한 패키지를 설치하세요.\n\n\n\n```js\nnpm install axios\n```\n\n4. API 요청 생성:\n\n- API 요청을 처리할 새 파일을 만듭니다. 예를 들어 GoogleTranslate.js 파일을 만듭니다.\n- Axios를 활용하여 Google 번역 API로 요청을 보냅니다.\n\n```js\n// GoogleTranslate.js\nimport axios from 'axios';\n\nconst API_KEY = 'YOUR_GOOGLE_TRANSLATE_API_KEY';\nconst API_URL = 'https://translation.googleapis.com/language/translate/v2';\n\nconst translateText = async (text, targetLanguage) =\u003e {\n  const response = await axios.post(\n    `${API_URL}?key=${API_KEY}`,\n    {\n      q: text,\n      target: targetLanguage,\n    }\n  );\n\n  return response.data.data.translations[0].translatedText;\n};\n\nexport default translateText;\n```\n\n\n\n## 제목: Google 번역 API를 사용한 React.js 앱에서 언어 번역 기능 구축하기\n\nReact.js 애플리케이션에 언어 번역 기능을 통합하고 싶나요? Google 번역 API를 사용하면 쉽게 이 목표를 달성할 수 있어요. React.js 프로젝트에서 언어 번역 기능을 설정하고 구현하는 간단한 단계를 따라보세요.\n\n1. Google Cloud 프로젝트 설정:\n\n- Google Cloud Console로 이동합니다.\n- 새 프로젝트를 만들거나 기존 프로젝트를 선택합니다.\n- 프로젝트에 \"Cloud 번역 API\"를 활성화합니다.\n\n\n\n2. API 키 얻기:\n\n- 클라우드 콘솔에서 \"API 및 서비스\" \u003e \"자격 증명\"으로 이동합니다.\n- 새 API 키를 생성합니다.\n- API 요청을 만들 때 필요하므로 이 API 키를 접근 가능한 상태로 유지하세요.\n\n3. 종속성 설치:\n\n- React.js 프로젝트의 터미널을 열고 필요한 패키지를 설치하세요:\n\n\n\n```js\nnpm install axios\n```\n\n4. API 요청 생성하기:\n\n- API 요청을 처리하는 새 파일을 만듭니다. 예를 들어, GoogleTranslate.js와 같이 지정할 수 있습니다.\n- Axios를 활용하여 Google 번역 API에 요청을 보냅니다.\n\n```js\nimport axios from 'axios';\n```\n\n\n\n```js\nconst API_KEY = 'YOUR_GOOGLE_TRANSLATE_API_KEY';\nconst API_URL = 'https://translation.googleapis.com/language/translate/v2';\nconst translateText = async (text, targetLanguage) =\u003e {\n  const response = await axios.post(\n    `${API_URL}?key=${API_KEY}`,\n    {\n      q: text,\n      target: targetLanguage,\n    }\n  );\n  return response.data.data.translations[0].translatedText;\n};\nexport default translateText;\n```\n\n5. React 컴포넌트에 통합하기:\n\n- React 컴포넌트에서 translateText 함수를 사용합니다.\n- 사용자가 텍스트를 입력하는 input 필드와 대상 언어를 선택하는 드롭다운을 가정합니다.\n- 사용자가 텍스트를 입력하고 언어를 선택하면 번역을 트리거합니다.\n\n```js\n// App.js\nimport React, { useState } from 'react';\nimport translateText from './GoogleTranslate';\n\nfunction App() {\n  const [inputText, setInputText] = useState('');\n  const [targetLanguage, setTargetLanguage] = useState('es'); // 기본값: 스페인어\n\n  const handleTranslate = async () =\u003e {\n    if (inputText) {\n      const translatedText = await translateText(inputText, targetLanguage);\n      // 번역된 텍스트를 처리합니다. 예: 페이지에 표시\n    }\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput\n        type=\"text\"\n        value={inputText}\n        onChange={(e) =\u003e setInputText(e.target.value)}\n      /\u003e\n      \u003cselect\n        value={targetLanguage}\n        onChange={(e) =\u003e setTargetLanguage(e.target.value)}\n      \u003e\n        \u003coption value=\"es\"\u003e스페인어\u003c/option\u003e\n        \u003coption value=\"fr\"\u003e프랑스어\u003c/option\u003e\n        {/* 다른 언어 옵션 추가 */}\n      \u003c/select\u003e\n      \u003cbutton onClick={handleTranslate}\u003e번역\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\n\n지금 ‘GoogleTranslate.js’ 파일에 있는 ‘YOUR_GOOGLE_TRANSLATE_API_KEY’를 실제 API 키로 교체하세요. 이제 React.js 애플리케이션을 더욱 향상시킬 수 있는 원활한 언어 번역 기능을 사용할 준비가 끝났습니다!\n\n요약하자면, Google Translate API를 React.js 앱에 통합하면 언어 번역이 간편해지며 전 세계적인 접근성이 향상됩니다. 초기 설정 복잡성에도 불구하고, 이 프로세스는 직관적인 UI 구성 요소로 사용자 친화적인 경험을 제공합니다. 이 방식은 언어 장벽을 허물어 포용력을 키우고 React.js 응용 프로그램에서 다양한 언어 선호도에 대한 유연한 플랫폼을 만듭니다.","ogImage":{"url":"/assets/img/2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingLanguageTranslationinaReactjsAppwithGoogleTranslateAPI_0.png","tag":["Tech"],"readingTime":4},{"title":"7가지 리액트 상태 관리 방법(2024년 최신)","description":"","date":"2024-05-12 22:22","slug":"2024-05-12-7BestPracticesReactStateManagement","content":"\n\u003cimg src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png\" /\u003e\n\n리액트 JS 애플리케이션이 상태들의 엉키는 꼬리에 끼게 된다면 지치셨나요? 컴포넌트 간 데이터 흐름을 계속 추적하기 어렵다고 느끼시나요? 이런 질문 중 어느 하나라도 \"네\"라고 대답하셨다면 행운이시군요! 이 글에서는 React JS에서 상태를 관리하는 최상의 방법을 탐구하고, 앱의 상태를 효과적으로 관리하는 방법을 안내해 드리겠습니다.\n\n목차:\n\n∘ 상태 관리의 중요성은 무엇인가요?\n∘ 1. React의 로컬 컴포넌트 상태 이해하기\n∘ 2. 상태를 사용하는 곳에 가깝게 유지하기\n∘ 3. 상태 업데이트에 불변성 사용하기\n∘ 4. 고급 상태 관리를 위해 Redux 또는 MobX 활용하기\n∘ 5. 메모이제이션으로 상태 업데이트 최적화하기\n∘ 6. React Context API 사용 고려하기\n∘ 7. React의 최신 기능과 라이브러리 업데이트에 주의하기\n\n## 상태 관리가 왜 중요할까요?\n\n최적의 방법에 대해 자세히 살펴보기 전에, React JS에서 상태 관리가 왜 중요한지 간단히 되짚어 보겠습니다. 상태는 애플리케이션에서 시간이 지남에 따라 변하는 데이터를 나타내며, 이를 적절하게 관리함으로써 앱이 올바르게 작동함을 보장할 수 있습니다.\n\n이를 통해 데이터 불일치, props 전달, 불필요한 다시 렌더링과 같은 일반적인 함정을 피할 수 있습니다. 이러한 최적의 방법을 따르면 앱을 더 잘 유지, 확장 가능하고 효율적으로 만들 수 있습니다.\n\n## 1. React의 로컬 컴포넌트 상태 이해하기\n\n\u003cimg src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_1.png\" /\u003e\n\nReact에서는 useState 또는 useReducer 훅을 사용하여 컴포넌트 내에서 상태를 관리합니다. 로컬 컴포넌트 상태와 Redux 또는 MobX와 같은 전역 상태 관리 라이브러리와 어떻게 다른지 이해하는 것이 중요합니다.\n\n로컬 상태는 단일 컴포넌트에 특정한 데이터에 사용되며 전체 응용 프로그램에서 공유할 필요가 없는 경우에 사용되어야 합니다. 복잡한 앱의 경우 여러 컴포넌트가 있는 경우 전역 상태 관리 솔루션을 고려해보세요.\n\n## 2. 상태를 사용하는 곳에 가까이 유지하기\n\n\u003cimg src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_2.png\" /\u003e\n\n상태를 가능한 한 필요로 하는 구성 요소 가까이에 유지하는 것이 좋은 습관입니다. 이 접근 방식인 \"상태 끌어올리기\"는 복잡성을 줄이고 응용 프로그램을 이해하기 쉽게 만듭니다.\n\n여러 구성 요소가 동일한 상태에 액세스해야 하는 경우 해당 상태를 가장 가까운 공통 조상으로 끌어올리세요. 그렇게 함으로써 해당 상태에 대한 단일 진실의 원천을 만들어 해당 상태를 관리하고 업데이트하기 쉬워집니다.\n\n## 3. 상태 업데이트에 불변성 사용하기\n\n\u003cimg src=\"/assets/img/2024-05-12-7BestPracticesReactStateManagement_3.png\" /\u003e\n\n리액트의 상태는 직접 변형해서는 안 됩니다. 대신 불변 데이터 구조와 기술을 사용하여 상태를 업데이트하세요. Immutable.js, Immer 또는 전개 연산자는 원본을 변형하지 않고 새로운 상태 객체를 만드는 데 인기 있는 선택지입니다. 이 관행을 따르면 상태 업데이트가 예측 가능하고 디버깅하기 어려운 부작용을 일으키지 않게 됩니다.\n\n## 4. 고급 상태 관리를 위해 Redux 또는 MobX 활용하기\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*jxPIxkKoyu-eN0Zr55zIMA.gif\" /\u003e\n\nReact JS 애플리케이션이 더 복잡해지면 더 견고한 상태 관리 솔루션이 필요할 수 있습니다. Redux와 MobX는 전역 상태를 관리하고 대규모 애플리케이션을 처리하는 강력한 도구를 제공하여 인기 있는 선택지입니다. 그러나 진정으로 필요한 경우에만 이러한 라이브러리를 도입하세요. 작은 프로젝트의 경우에는 로컬 컴포넌트 상태 관리만으로도 충분할 수 있습니다.\n\n## 5. 메모이제이션을 활용해 상태 업데이트 최적화하기\n\n![이미지](/assets/img/2024-05-12-7BestPracticesReactStateManagement_4.png)\n\nReact의 조정 알고리즘은 앱에 많은 상태와 복잡한 UI 컴포넌트가 있는 경우에 비용이 많이 들 수 있습니다. 성능을 최적화하려면 React.memo나 useMemo와 같은 메모이제이션 기법을 사용하여 불필요한 다시 렌더링을 방지하세요. 이러한 함수들을 사용하면 컴포넌트의 결과를 종속성에 기반하여 캐시하여 React의 조정 프로세스에 부하를 줄일 수 있습니다.\n\n## 6. React Context API 사용을 고려해보세요\n\n![React Context API](/assets/img/2024-05-12-7BestPracticesReactStateManagement_5.png)\n\nReact의 Context API는 전역 상태 관리 라이브러리를 사용하지 않고 컴포넌트 간 상태를 공유하기 위한 내장 솔루션입니다. 각 레벨에서 명시적으로 props를 전달하지 않고도 컴포넌트 트리를 통해 데이터를 전달할 수 있게 해줍니다.\n\nContext는 작은 애플리케이션이나 몇 개의 밀접한 관련 컴포넌트 사이에서 상태를 공유할 때 이상적입니다. 그러나 Context를 사용할 때 과용하면 성능 문제가 발생할 수 있으니 주의해야 합니다.\n\n## 7. React의 최신 기능과 라이브러리를 알아두세요\n\n![React](/assets/img/2024-05-12-7BestPracticesReactStateManagement_6.png)\n\nReact JS는 지속적으로 발전하는 프레임워크로, 새로운 기능과 라이브러리가 지속적으로 소개됩니다. 앱의 성능과 효율성을 유지하기 위해 최신 동향을 계속해서 파악하는 것이 중요합니다.\n\n이러한 모범 사례를 따라가면 React JS 애플리케이션에서 상태 관리에 대한 도전에 잘 대처할 수 있을 것입니다. 프로젝트의 규모와 복잡성에 맞는 적절한 접근 방식을 선택하고, 항상 간단하고 유지보수 가능한 코드를 지향해야 합니다.\n\n당신의 학습 여정은 여기서 끝나지 않아요! 만약 이 글에서 가치를 발견했다면, 더 많은 것이 준비되어 있어요. 흥미로운 업데이트를 받으려면 저희를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png"},"coverImage":"/assets/img/2024-05-12-7BestPracticesReactStateManagement_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular16 애플리케이션에서 CORS 문제 해결하기","description":"","date":"2024-05-12 22:21","slug":"2024-05-12-CORSIssuesFixinginAngular16Application","content":"\n\n```\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png)\n\nCross-Origin Resource Sharing (CORS)은 웹 브라우저가 제한하는 필수적인 보안 메커니즘입니다.\n\nCORS는 HTTP 헤더 기반 메커니즘으로, 서버가 브라우저가 리소스를로드 허용해야 하는 자신의 도메인, 스키마 또는 포트 이외의 모든 출처를 나타낼 수 있도록 허용합니다.\n\n여기에서는 Angular 애플리케이션에서 CORS 문제를 해결하는 방법과 CORS 문제 없이 애플리케이션을 실행하는 방법을 논의할 것입니다.\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_1.png\" /\u003e\n\n# CORS 문제를 어떻게 해결할 수 있을까요?\n\n\u003cimg src=\"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_2.png\" /\u003e\n\n- 적절한 헤더를 제공하기 위해 HTTP Interceptor를 생성하면 문제를 해결할 수 있습니다.\n- 또 다른 방법은 Proxy.conf.js 파일을 생성하는 것입니다.\n\n\n\nAngular 애플리케이션을 독립적으로 만들어 봅시다. 그리고 HTTP Interceptors를 생성해 보겠습니다.\n\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_3.png)\n\n인터셉터 파일 안에 다음 코드를 추가해주세요.\n\n![이미지](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_4.png)\n\n\n\n사이트를 설정하여 해당 사이트에 액세스할 수 있도록 허용할 수도 있습니다. \"*\" 와일드카드를 사용하여 모든 사이트에 액세스할 수 있도록 설정할 수 있습니다. 이것은 공개 API에만 사용해야 합니다. 비공개 API에는 *를 사용해서는 안 되며 대신 특정 도메인 또는 도메인이 설정되어야 합니다. 또한 와일드카드는 crossorigin 속성이 익명으로 설정된 요청에만 작동하며, 요청에 쿠키와 같은 자격 증명을 전송하는 것을 방지합니다.\n\n```js\nAccess-Control-Allow-Origin: *\n```\n프라이빗 API에 모든 사이트가 액세스할 수 있도록 \"*\" 와일드카드를 사용하는 것은 좋지 않은 방법입니다.\n\n일부 경우에는 헤더를 추가해도 CORS 문제가 해결되지 않을 수 있습니다. 이런 경우에는 프록시 서버를 추가하여 문제를 해결해야 합니다.\n\n\n\n글로벌 수준에서 proxy.conf.js 파일을 추가해주세요\n\n![그림](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_5.png)\n\n해당 파일 안에 다음 코드를 추가해야 합니다\n\n![그림](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_6.png)\n\n\n\nproxy.conf.js 파일에 프록시 설정을 추가한 후에는 이제 angular.json 파일에 해당 파일을 다음과 같이 등록해야 합니다.\n\n![Proxy Configuration](/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_7.png)\n\nCORS 프록시를 사용하면 클라이언트와 서버 사이에 브릿지 역할을 하는 프록시 서버를 사용하여 CORS 오류를 우회할 수 있습니다. 그래서 대상 서버에 요청하는 대신에 요청을 대신하여 프록시 서버로 보냅니다. 요청은 다음과 같이 보입니다: https://proxy.com/https://server.com.\n\n이 내용이 도움이 되었으면 좋겠네요!\n\n\n\n\"이 기사를 즐겼나요? 더 많은 유익한 콘텐츠를 위해 계속 연락을 유지하세요. 트위터와 링크드인에서 제를 팔로우하여 내 최신 기사, 튜토리얼, 발표 자료를 받아보세요. 함께 학습하는 여정을 떠나 새로운 아이디어를 탐험해봅시다! 놓치지 마세요, 지금 바로 팔로우하세요!\"","ogImage":{"url":"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png"},"coverImage":"/assets/img/2024-05-12-CORSIssuesFixinginAngular16Application_0.png","tag":["Tech"],"readingTime":3},{"title":"상태 관리자인 Zustand와 JS 메모리","description":"","date":"2024-05-12 22:19","slug":"2024-05-12-ZustandStateManagerAndJSMemory","content":"\n\n이 기사에서는 매우 간단하고 쉽게 관리할 수 있는 Zustand 상태 관리자를 검토할 것이며, 사용 시 고려해야 할 몇 가지 사항이 있습니다. 또한 기본적으로 JavaScript 메모리 관리가 어떻게 작동하는지 설명하겠습니다.\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png)\n\n여기 Zustand 상태 관리자에서의 기본 이슈 설명이 있습니다. 매우 간단한 구조를 가진 store를 선언했는데, 이 store는 목록으로 간단한 데이터를 유지하도록 설계되었고 setStoreData라는 단일 메서드만 있습니다. store를 사용할 수 있겠죠? 내가 store를 가져왔다면 모든 컴포넌트에서 store 데이터를 사용할 수 있고, setStoreData 메서드를 가져오면 store 데이터를 편집할 수도 있을 것입니다. 하지만 setStoreData 메서드를 가져오지 않아도 store 데이터를 편집할 수 있다면 어떨까요? 네, 그렇게 되어서는 안 될 것 같지만 Zustand에서 그렇게 되고 있어서 React 프로젝트에서 Zustand 상태 관리자를 사용할 때 매우 조심해야 합니다. 어떻게 그런 일이 발생하는지 살펴보겠습니다...\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_1.png)\n\n\n\n우리가 간단한 상점 예제를 보여드립니다. 꽤 기본적인 내용이죠. 하지만 이 상점을 사용하는 중에 작은 문제가 있습니다.\n\n![image](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_2.png)\n\n이 조건하에, `setStoreDATA` 함수를 전혀 사용하지 않는다는 점을 볼 수 있습니다. 그런데 이 함수가 메소드를 사용하지 않아도 상점 데이터를 설정할 수 있습니다. 어떻게 그런 일이 가능한 걸까요?\n\nJavaScript에서 기본 데이터 유형(숫자, 문자열, 불리언, null, undefined, 심볼, BigInt)은 변수가 액세스하는 위치에 직접 저장됩니다. 그러나 객체, 배열 및 함수와 같은 비-기본 유형은 참조로 저장되기 때문에 우리가 참조로 호출하면 데이터 유형을 조작할 수 있습니다. 이것은 프로그램 전체에 직접 영향을 미치며 우리가 수정한 공간이 아닌 모든 곳에서 변경을 가져옵니다. 그래서 데이터를 참조로 저장하는 것은 무엇인가요?\n\n\n\n참조에 의한 전달 및 값에 의한 전달\n\n## 값에 의한 전달\n\n값에 의한 전달을 사용할 때, 원래 데이터의 사본이 함수에 전달됩니다. 함수 내부에서 매개변수를 변경해도 원본 데이터에는 영향을 미치지 않습니다. 이는 함수에 전달된 값이 실제로 원래 값의 사본이기 때문입니다. 대부분의 기본 데이터 유형(정수, 부동 소수점 및 부울과 같은)은 보통 값에 의해 전달됩니다.\n\n```js\nfunction modifyValue(num) {\n    num = 15;\n    console.log(\"함수 내부 값:\", num);\n}\n\nlet x = 5;\nmodifyValue(x);\nconsole.log(\"함수 호출 후 x 값:\", x);\n```\n\n\n\n이 예시의 결과\n\n```js\n함수 내부의 값: 15\n함수 호출 후 x 값: 5\n```\n\n이 예시에서는 함수 내에서 x의 값이 변경되었지만 x의 값이 변하지 않았습니다. 이는 함수가 x의 사본만을 접근했기 때문입니다.\n\n# 참조로 전달\n\n\n\n자바스크립트에서 객체(배열 및 함수 포함)를 함수에 전달할 때, 기술적으로 \"공유\"로 전달됩니다 (간단히 말하면 참조에 의한 전달이라고도 합니다). 실제로 객체에 대한 참조를 전달하므로 함수 내에서 객체를 수정하면 원본 객체에 영향을 줍니다.\n\n```js\nfunction modifyArray(arr) {\n    arr.push(4);\n    console.log(\"함수 내부의 배열:\", arr);\n}\n\nlet myArray = [1, 2, 3];\nmodifyArray(myArray);\nconsole.log(\"함수 호출 후 배열:\", myArray);\n```\n\n이 예제의 출력\n\n```js\n함수 내부의 배열: [1, 2, 3, 4]\n함수 호출 후 배열: [1, 2, 3, 4]\n```\n\n\n\n요약하자면, 자바스크립트에서:\n\n- 값을 전달 (원시 값): 값만 전달되므로 함수 내부의 매개변수 변경은 원래 변수에 영향을 미치지 않습니다.\n- 참조로 전달 (객체): 객체에 대한 참조가 전달되므로 매개변수 변경은 원래 객체에 영향을 미칩니다.\n\n그렇다면 Zustand는 무엇일까요?\n\nZustand에서는 사용자가 스토어를 변경할 때 setStoreData 메서드를 사용하도록 강제하는 보호 기능이 배열을 유지하는 경우에는 없습니다.\n\n\n\n# 결론\n\n만약 당신이 리스트 구조를 유지하는 상점을 가지고 있다면, 자바스크립트에서 배열인 리스트는 참조 호출로 편집될 것입니다. 즉, 당신이 상점 데이터를 호출하고 그 데이터를 함수에서 사용하고 다른 리스트나 값을 동일하게 만들었다고 가정해봅시다. 이러한 경우, 선언한 설정 방법을 사용하지 않아도 상점이 변경될 것입니다.\n\n아마도 이것은 간단한 부족한 보호 또는 고의적으로 포기된 자유일 수 있습니다. 특히 상점이 리스트 구조를 포함하는 경우, Zustand 상점을 사용할 때 극도로 조심해야 합니다.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요! 👏\n- X를 팔로우하고 LinkedIn, YouTube, Discord에서 우리를 만나보세요.\n- 다른 플랫폼을 방문해보세요: In Plain English, CoFeed, Venture, Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png"},"coverImage":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 타입스크립트 프로젝트에서 ESLint 설정하기 2022","description":"","date":"2024-05-12 22:17","slug":"2024-05-12-SettingESLintonaReactTypescriptproject2022","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png\" /\u003e\n\n# 소개\n\n내 React Typescript 프로젝트에 ESLint를 설치하고 이해하려는 데 많은 어려움을 겪은 후, React Typescript 프로젝트에 ESLint를 설정하는 확정 가이드를 작성하기로 결정했습니다.\n\n이 튜토리얼의 주요 목표는 단계별로 설정하고 추가 또는 실행된 각 줄을 설명하는 것입니다. 단순히 여러 구성을 가진 많은 파일을 제공하고 무엇이 일어나고 있는지를 이해할 수 있기를 바랄 뿐인 대신 설명합니다.\n\n\n\n그럼 시작해볼까요!\n\n## 준비물\n\n참고: Node 버전 `= 10`이 설치되어 있어야 합니다. 설치되어 있지 않다면 NodeJS 웹사이트로 이동하여 로컬 머신에 다운로드하고 설치해 주세요. (https://nodejs.org/en/)\n\n## 단계 1: TypeScript로 React 프로젝트 생성\n\n\n\n다음 명령어는 my-app이라는 폴더 내에 프로젝트를 생성합니다.\n\n터미널에서 다음을 실행하세요:\n\n```js\nnpx create-react-app my-app --template typescript\n```\n\n# 단계 2: React 프로젝트에서 미리 설정된 ESLint 구성 제거하기\n\n\n\n래스크는 eslint 설정이 미리 설정되어 있어요. 이 설정을 제거해서 더 나은 설정을 할 수 있도록 해봐요. 이를 위해 'package.json' 파일에서 아래 코드를 제거해주세요.\n\n```js\n\"eslintConfig\": {\n   \"extends\":[\n      \"react-app\",\n      \"react-app/jest\"\n   ]\n}\n```\n\n# 단계 3: ESLint 패키지 설치하기\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n\n\n터미널에서 다음을 실행해 주세요:\n\n```js\nnpm install eslint --save-dev\n```\n\n위 명령을 실행하면 'package.json' 파일에서 \"eslint\"가 개발용 종속성으로 추가된 것을 확인할 수 있습니다.\n\n```js\n\"devDependencies\": {\n   \"eslint\": \"^7.20.0\"\n}\n```\n\n\n\n# 단계 4: ESLint 설정\n\n프로젝트 디렉토리 안에서 터미널을 열어주세요.\n\n터미널에서 다음을 실행하세요:\n\n\n\n```js\nnpx eslint --init\n```\n\n이 명령을 실행할 때 설정에 관한 몇 가지 질문에 답변해야합니다.\n\n이후, 설치해야 할 종속 항목을 확인한 다음 다음과 같이 물어볼 것입니다:\n\n그런 다음 필요한 모든 패키지를 설치합니다. 설치 프로세스가 완료되면 \"package.json\" 파일의 'devDependencies'는 다음과 같이 보여야 합니다:\n\n\n\n```js\n\"devDependencies\": {\n\"@typescript-eslint/eslint-plugin\": \"^4.15.1\",\n\"@typescript-eslint/parser\": \"^4.15.1\",\n\"eslint\": \"^7.20.0\",\n\"eslint-config-airbnb\": \"^18.2.1\",\n\"eslint-plugin-import\": \"^2.22.1\",\n\"eslint-plugin-jsx-a11y\": \"^6.4.1\",\n\"eslint-plugin-react\": \"^7.22.0\",\n\"eslint-plugin-react-hooks\": \"^4.2.0\"\n}\n```\n\nPS: 위 예시와 버전이 일치하지 않아도 괜찮아요.\n\n# Step 5: ESLint 실행하기\n\n프로젝트 디렉토리에서 터미널을 열어주세요.\n\n\n\nESLint를 실행하고 가리키는 오류를 확인하려면 다음을 실행하세요:\n\n```js\nnpx eslint \u003c대상파일\u003e\n```\n\n일부 오류를 자동으로 수정하려면 '--fix'를 사용할 수 있어요:\n\n```js\nnpx eslint \u003c대상파일\u003e --fix\n```\n\n\n\n만약 경고를 무시하고 싶다면 ‘--quiet’를 사용할 수 있어요.\n\n```js\nnpx eslint \u003c대상파일\u003e --quiet\n```\n\n# 단계 5.1: 실행해봅시다!\n\n만약 'src' 디렉토리 안의 모든 파일에 대해서 eslint를 실행하면 35개의 오류가 나타날 거예요. 와우!\n\n\n\n```js\nnpx eslint src/* \n```\n\nESLint 출력:\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_1.png\" /\u003e\n\n자동 수정으로 실행하면 무서운 부분은 줄어들었지만 해결해야 할 오류가 여전히 22개 남아 있어요. 대박이에요!\n\n\n\n```bash\nnpx eslint src/* --fix\n```\n\nESLint의 출력:\n\n![Setting ESLint on a React Typescript project](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_2.png)\n\n그래서 우리는 모든 단계를 거치고 Typescript로 ReactJS의 '안녕, 세계' 프로젝트를 수행했는데도 이 모든 오류가 발생했습니다. 대부분의 오류는 확장 파일 오류나 심지어 React 자체의 사용과 같은 무의미한 것들이었습니다.\n\n\n\n짜증나는 일이죠?\n\n좋은 소식은 이미 이 지옥을 겪어가며 이 문제들을 해결했고, 이제 ESLint를 제대로 사용할 수 있도록 모든 구성을 끝마칠 수 있습니다. 이 문제를 하나씩 살펴보고 어떻게 해결해야 하는지 알아보겠습니다!\n\n## 남은 문제 해결하기\n\n### 문제: \"'no-use-before-define'\"\n\n\n\n에러 샘플: 'React'가 정의되기 전에 사용되었습니다.\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"rules\" 섹션 아래에 다음을 추가하십시오:\n\n```js\n\"rules\": {\n  \"no-use-before-define\": \"off\",\n  \"@typescript-eslint/no-use-before-define\": [\"error\"]\n}\n```\n\n\n\n위 설명은 이 스택 오버플로 포스트에 있어요 (https://stackoverflow.com/questions/63818415/react-was-used-before-it-was-defined/64024916#64024916)\n\n# 문제: \"'react/jsx-filename-extension\"\n\n에러 샘플: 확장자 '.tsx'를 가진 파일에서 JSX가 허용되지 않음\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가하세요:\n\n```js\n\"rules\": {\n...\n\"react/jsx-filename-extension\": [ \"warn\", {\"extensions\": [\".tsx\"]} ]\n}\n```\n\n# 문제: \"import/no-unresolved\"\n\n에러 샘플: './App' 모듈에 대한 경로를 해결할 수 없음\n\n\n\n## 해결 방법\n\n- 프로젝트 디렉토리 내에서 터미널을 열고 eslint-import-resolver-typescript 패키지를 설치하세요.\n\n```js\nnpm install eslint-import-resolver-typescript --save-dev\n```\n\n- 'eslintrc.json' 파일에 다음과 같이 새로운 \"settings\" 속성을 추가하세요:\n\n\n\n```json\n\"settings\": {\n    \"import/resolver\": {\n        \"typescript\": {}\n    }\n}\n```\n\n# 문제: \"import/extensions\"\n\n에러 샘플: './App'에 대한 'tsx' 파일 확장자 누락\n\n## 해결책\n\n\n\n'eslintrc.json' 파일에서 \"rules\" 아래에 다음을 추가해 주세요:\n\n```js\n\"rules\": {\n…\n\"import/extensions\": [\n\"error\",\n\"ignorePackages\",\n{\n\"ts\": \"never\",\n\"tsx\": \"never\"\n}\n]\n}\n```\n\n# 문제: \"no-undef\"\n\n에러 샘플: 'test'가 정의되지 않았습니다\n\n\n\n## 해결 방법\n\n'eslintrc.json' 파일에서 \"extends\" 항목에 \"plugin:@typescript-eslint/recommended\"를 추가하십시오:\n\n```js\n\"extends\": [\n…\n\"plugin:@typescript-eslint/recommended\"\n],\n```\n\n# 문제: \"no-shadow\"\n\n\n\n에러 샘플: 'Enum'이 이미 상위 스코프에서 선언되었습니다.\n\n## 해결 방법\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가하십시오:\n\n```js\n\"rules\":{\n…\n\"no-shadow\": \"off\",\n\"@typescript-eslint/no-shadow\": [\"error\"]\n}\n```\n\n\n\n스택 오버플로우 게시물에 설명이 있습니다(https://stackoverflow.com/questions/63961803/eslint-says-all-enums-in-typescript-app-are-already-declared-in-the-upper-scope)\n\n# 문제: 'js', 'jsx', 'ts', 또는 'tsx' 확장자 파일이 아닌 파일에 대한 오류\n\n## 해결책:\n\n‘.eslintignore’ 파일에 추가하여 ESLint가 특정 파일을 무시하도록 할 수 있습니다.\n\n\n\n그럼,\n\n- 프로젝트 루트에 '.eslintignore' 파일을 만듭니다.\n- 다음 텍스트를 추가합니다:\n\n```js\n*.css\n*.svg\n```\n\n# 추가:\n\n\n\n# 적용해 볼 좋은 규칙들\n\n## 모든 함수에 명시적인 반환 유형을 강제로 적용하기\n\n‘eslintrc.json’ 파일에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n...\n\"@typescript-eslint/explicit-function-return-type\": [\n\"error\",\n{\n\"allowExpressions\": true\n}\n]\n}\n```\n\n\n\n## 코드 라인의 최대 길이\n\n'.'eslintrc.json' 파일에 \"rules\" 항목 아래에 다음 코드를 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"max-len\": [\"warn\", { \"code\": 80 }]\n}\n```\n\n## React Hooks 규칙\n\n\n\n'**eslintrc.json**' 파일에서 \"plugins\" 섹션에 다음을 추가해주세요:\n\n```js\n\"plugins\": [\n…\n\"react-hooks\"\n],\n```\n\n그리고 \"rules\" 섹션에도 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"react-hooks/rules-of-hooks\": \"error\",\n\"react-hooks/exhaustive-deps\": \"warn\"\n}\n```\n\n\n\n# 무시할 몇 가지 규칙:\n\n## 기본 내보내기 사용 선호\n\n`eslintrc.json`에서 \"rules\" 아래에 다음을 추가해주세요:\n\n```js\n\"rules\":{\n…\n\"import/prefer-default-export\": \"off\"\n}\n```\n\n\n\n## 프롭 타입 규칙\n\n`eslintrc.json` 파일에서 \"rules\" 항목에 다음 내용을 추가해 주세요:\n\n```js\n\"rules\":{\n…\n\"react/prop-types\": \"off\"\n}\n```\n\n# 결론\n\n\n\n그래서 이러한 구성을 통해 ReactJS with Typescript 프로젝트의 코드 품질을 향상시킬 수 있습니다. 즐기세요! :)\n\n# VS Code: 저장할 때 파일에서 ESLint 자동 수정 실행\n\n게다가, VS Code에서 자동 수정을 구성하는 방법을 보여드리겠습니다. 그러나 이는 선택 사항입니다. 코드를 저장할 때마다 ESLint를 자동 수정하려면 다음 단계를 수행하실 수 있습니다.\n\n- 프로젝트 루트에 '.vscode' 폴더를 생성합니다.\n- '.vscode/' 폴더 안에 'settings.json' 파일을 생성하고 다음 코드를 삽입합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_3.png\" /\u003e\n\n```js\n{\n\"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\",\n\"editor.formatOnSave\": true,\n\"eslint.alwaysShowStatus\": true,\n\"editor.codeActionsOnSave\": {\n\"source.fixAll.eslint\": true\n}\n}\n```\n\n- VS Code ESLint 확장 프로그램 설치\n\nVS Code 'Extensions' 섹션으로 이동하여 수동으로 설치할 수 있습니다:\n\n\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_4.png)\n\n또는 VS Code 빠른 열기(Ctrl+P)를 실행하고 다음 몤령어를 실행하세요:\n\n```js\next install dbaeumer.vscode-eslint\n```\n\n- VS Code에서 ESLint 익스텐션 사용 허용하기:\n\n\n\n처음 사용하는 경우 ESLint 확장 프로그램이 차단될 것입니다. 그럼에도 불구하고 허용해야 합니다:\n\n1. 상태 표시줄 아이콘을 클릭합니다.\n\n![이미지](/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_5.png)\n\n2. 팝업이 나타납니다. '허용' 옵션을 선택합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_6.png\" /\u003e\n\n완료되었습니다! 이제 모든 파일을 저장할 때마다 ESLint 규칙을 자동으로 수정할 수 있습니다.\n\n# 참고","ogImage":{"url":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png"},"coverImage":"/assets/img/2024-05-12-SettingESLintonaReactTypescriptproject2022_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 네이티브 이미지 피커 구현에 대한 심층 탐구","description":"","date":"2024-05-12 22:16","slug":"2024-05-12-DeepDiveintoImplementingreact-native-image-picker","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png\" /\u003e\n\n현대 애플리케이션에서 사용자가 프로필에 사진을 업로드할 수 있는 기능을 제공하는 것은 표준입니다. 사용자들이 계속해서 앱을 방문할 수 있도록 최상의 경험을 제공하는 것이 매우 중요합니다.\n\nReact-Native로 모바일 앱을 개발 중이라면, react-native-image-picker 덕분에 이것을 아주 쉽게 구현할 수 있습니다.\n\n# 내 앱은 어떤 이미지 형식을 지원해야 할까요?\n\n\n\n첫 번째로 해야 할 질문은 \"내 앱이 지원해야 하는 이미지 유형은 무엇인가?\"입니다. 다양한 이미지 유형이 존재하며, 모든 종류의 사람들을 대상으로 하는 앱을 원한다면 특히 혼란스럽고 압도될 수 있습니다. React Native는 이를 우리에게 아주 쉽게 만들어줍니다.\n\n그래서 선택지를 좁힐 수 있습니다. 이 목록에 언급되지 않은 것 중 하나는 Base64입니다. Base64는 이진 데이터를 나타내는 이진-텍스트 인코딩 체계의 한 그룹입니다.\n\n# React-Native-Image-Picker\n\n## React Native Image Picker란 무엇인가요?\n\n\n\nReact-Native-Image-Picker은 React Native 모듈로, 기기 라이브러리에서 미디어를 선택하거나 직접 카메라에서 가져 올 수 있도록 네이티브 UI를 사용할 수 있게 해줍니다. 현재 약 60,000명의 개발자가 사용 중이며, 제공되는 기능이 매우 견고하기 때문에 많은 사람들이 사용하고 있습니다.\n\n## React-Native-Image-Picker 설치 및 설정하는 방법\n\n먼저 패키지를 프로젝트에 설치합니다:\n\nAndroid:\n\n\n\n```js\nyarn add react-native-image-picker\n```\n\niOS:\n\n```js\nnpx pod-install ios\n```\n\nreact-native-image-picker 레포지토리에는 몇 가지 추가 설치 단계에 대한 조언이 있습니다. 그 중 일부는 다음과 같습니다:\n사용자가 사진 또는 비디오를 선택할 수 있도록 하는 경우 NSPhotoLibraryUsageDescription을 추가하세요.```\n\n\n\niOS\n\nAndroid\n\n`saveToPhotos` 속성을 `true`로 설정하지 않는 한 권한이 필요하지 않습니다.\n\niOS의 권한은 다음과 같이 test 폴더 내의 Info.plist 파일에 들어갑니다:\n\n\n\n```js\n\u003ckey\u003eNSPhotoLibraryUsageDescription\u003c/key\u003e\n \u003cstring\u003e$(PRODUCT_NAME)님의 사진 갤러리에 접근하려고 합니다\u003c/string\u003e\n\u003ckey\u003eNSCameraUsageDescription\u003c/key\u003e\n \u003cstring\u003e$(PRODUCT_NAME)님의 카메라를 사용하려고 합니다\u003c/string\u003e\r\n```\n\n## Android의 권한은 AndroidManifest.xml 파일에 작성해주세요 :\n\nReact-Native-Image-Picker 모듈은 사용자에게 작동을 위해 권한이 필요하지 않지만, 사용자가 앱에서 촬영한 이미지를 갤러리에 저장하는 옵션을 설정한 경우, 다음 권한이 필요합니다:\n\n```js\n\u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e\n```\n\n\n\n위에서 사용자에게 겔러리 접근 권한과 애플리케이션에서 캡처한 이미지를 사용자의 갤러리에 저장할 것인지에 대한 동의를 요청하는 것입니다.\n\n## React-Native-image-Picker 구현하기\n\n프로필 컴포넌트 Profile.js를 생성하십시오. react-native-image-picker에는 사용할 수 있는 두 가지 메서드가 있습니다. launchCamera()는 카메라를 실행하여 사진을 찍고, launchImageLibrary()는 갤러리를 실행하여 사진이나 비디오를 선택합니다. 이를 파일에 import할 것입니다.\n\nlaunchLibrary 메서드는 사용자의 갤러리를 열고 이미지 설정과 응답 두 가지 매개변수를 사용합니다.\n\n\n\n`launchCamera` 메소드는 사용자의 카메라를 실행하며 이미지의 구성 및 응답에 대한 두 개의 매개변수를 가져옵니다.\n\n`pickerResponse` 상태 변수는 이미지 피커에서의 응답을 저장하는 데 사용됩니다. `imageFromDB` 상태 변수는 데이터베이스에서 이미지를 저장하여 나중에 액세스할 수 있도록 합니다.\n\nImage 컴포넌트는 다음과 같이 사용됩니다:\n\n```js\n\u003cCard style=//카드 스타일, 특히 이미지에 고도를 원하는 경우\u003e\n    \u003cImage\n        source={\n          uri: `data:image/*;base64,${imageFromDB}`,\n          width: ..,\n          height: ...,\n        }\n        style=//추가 이미지 스타일\n    /\u003e\n\u003c/Card\u003e\n```\n\n\n\n이 코드 라인\n\n```js\nuri: `data:image/*;base64,${imageFromDB}`,\n```\n\n은 우리가 데이터베이스에서 이미지를 렌더링하는 데 `uri` 속성을 사용하고 `image/*`가 지정된 이미지 유형을 렌더링하도록 보장합니다.\n\n또한 사용자가 갤러리 또는 카메라에 액세스하여 이미지를 업로드할 수 있도록 모달을 활성화하는 프레서블 아이콘을 추가할 수도 있습니다.\n\n\n\n```js\n \u003cPressable\n    style={({ pressed }) =\u003e [\n        {\n            ...styles.cameraIconView,\n            opacity: pressed ? 0.5 : 1,\n        },\n    ]}\n    onPress={() =\u003e setVisible(true)}\n\u003e\n    \u003cIconComponent\n        source={icons.camera}\n        tintColor={themeColor.primaryWhite}\n    /\u003e\n\u003c/Pressable\u003e\r\n```\n\n저희는 프로필 컴포넌트에 모달을 넣고 필요한 모든 속성을 전달하고 싶어요.\n\n```js\r\n\u003cImagePickerModal\n    isVisible={visible}\n    onClose={() =\u003e setVisible(false)}\n    onImageLibraryPress={onImageGalleryPress}\n    onCameraPress={onCameraPress}\n/\u003e\r\n```\n\n마지막으로 ImagePickerModal 컴포넌트를 만들어야 할 것입니다.\n\n\n\n데이터베이스로 이미지를 그대로 보내기보다 base64 이미지를 사용하는 이유를 궁금해하는 분들을 위해, base64 인코딩을 사용하면 데이터 크기를 최대 33%까지 줄일 수 있으며 많은 프로그래밍 언어가 base64 인코딩을 내장 지원하고 있습니다.\n\n# 페이지 상태에 따라 이미지를 조건부로 렌더링하기\n\n이미지를 렌더링하기 위해 우리는 다음 3가지 경우를 살펴볼 것입니다:\n\n- 사용자가 로그인하지 않았을 때\n- 사용자가 로그인했지만 프로필 이미지가 없는 경우\n- 사용자가 로그인하고 프로필 이미지가 있는 경우\n- 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n```js\nuserLoggedIn ? {\n  uri ? (\n    \u003cCard style={styles.userDBImageView}\u003e\n        \u003cImage\n            source={\n                uri: uri,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n        /\u003e\n    \u003c/Card\u003e\n) : imageFromDB ? (\n    \u003cCard style={styles.userDBImageView}\u003e\n        \u003cImage\n            source={\n                uri: `data:image/*;base64,${imageFromDB}`,\n                width: styles.userDBImage.width,\n                height: styles.userDBImage.height,\n            }\n            style={styles.userDBImage}\n            // tintColor={colors.primaryWhite}\n        /\u003e\n    \u003c/Card\u003e\n) : (\n    \u003cCard\n        style={\n            ...styles.userImageView,\n            marginTop: '8%',\n            width: '25%',\n        }\n    \u003e\n        \u003cImage\n            source={icons.profileImage}\n            style={styles.userImage}\n            tintColor={colors.primaryWhite}\n        /\u003e\n    \u003c/Card\u003e\n)\n) : (\n\u003cCard style={styles.userImageView}\u003e\n    \u003cImage\n        source={icons.profileImage}\n        style={styles.userImage}\n        tintColor={colors.primaryWhite}\n    /\u003e\n\u003c/Card\u003e\n         )\n}\n```\n\n## 사용자가 로그인하지 않은 경우\n\n마지막 컴포넌트는 사용자가 로그인하지 않았을 때 호출될 것이므로 해당 이미지의 소스는 기본/대체 이미지여야합니다.\n\n## 사용자는 로그인했지만 프로필 이미지가 없습니다\n\n\n\n사용자가 로그인했지만 프로필 이미지가 없는 경우, 코드에서 두 번째로 나타나는 그림과 동일한 이미지를 표시할 것입니다.\n\n## 사용자가 로그인하고 프로필 이미지가 있는 경우\n\n두 번째 구성 요소는 사용자가 로그인했는지와 데이터베이스에서 이미지를 가지고 있는지 확인한 후 렌더링됩니다.\n\n## 사용자가 로그인하고 방금 프로필 이미지를 변경한 경우\n\n\n\n이 코드 조각은 먼저 사용자가 uri 변수를 사용하여 새 이미지를 선택/캡처했는지 확인합니다. uri에 값이 있는 경우, 삼항 연산자에서 다른 변수들 보다 우선순위가 높기 때문에 즉시 표시됩니다.\n\n# 결론\n\nreact-native-image-picker를 사용하면 이미지 업로드 기능을 쉽게 구현할 수 있습니다. 사용자가 이미지와 비디오를 업로드할 수 있는 애플리케이션을 쉽게 구축할 수 있을 정도로 강력합니다. 사용자 경험을 즐겁게 만들어주지만, 더 중요한 점은 개발자 경험까지 더욱 즐겁게 만들어준다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png"},"coverImage":"/assets/img/2024-05-12-DeepDiveintoImplementingreact-native-image-picker_0.png","tag":["Tech"],"readingTime":6},{"title":"함수 컴포넌트에서 React 고차 컴포넌트HOC 활용하기","description":"","date":"2024-05-12 22:15","slug":"2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png\" /\u003e\n\nReact Higher Order Components (HOC)은 React 애플리케이션에서 코드 재사용, 로직 공유 및 추상화를 위한 강력한 패턴입니다. 보통 클래스 컴포넌트와 관련이 있지만, 고차 컴포넌트는 함수형 컴포넌트와 함께 효율적으로 활용할 수도 있습니다. 이 글에서는 함수형 컴포넌트에서 고차 컴포넌트를 구현하고 활용하는 방법에 대해 살펴보겠습니다.\n\n고차 컴포넌트 이해하기:\n\n고차 컴포넌트는 컴포넌트를 인수로 받아 향상된 기능을 갖춘 새로운 컴포넌트를 반환하는 함수입니다. 인증, 권한 부여, 로깅 및 상태 관리와 같은 교차 관심사를 여러 컴포넌트에서 캡슐화하고 공유할 수 있도록 합니다.\n\n\n\n함수형 컴포넌트에서 고차 컴포넌트 구현하기:\n\n함수형 컴포넌트에서는 고차 컴포넌트를 일반 JavaScript 함수로 구현하며, 이 함수는 컴포넌트를 인수로 받아 새로운 함수형 컴포넌트를 반환합니다.\n\n다음 예제를 살펴보겠습니다:\n\n```js\nimport React from 'react';\n\nconst withLogging = (WrappedComponent) =\u003e {\n  const WithLogging = (props) =\u003e {\n    console.log('Component rendered:', WrappedComponent.name);\n    return \u003cWrappedComponent {...props} /\u003e;\n  };\n\n  return WithLogging;\n};\n\nconst MyComponent = () =\u003e {\n  return \u003cdiv\u003eHello, World!\u003c/div\u003e;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nexport default EnhancedComponent;\n```\n\n\n\n이 예시에서 withLogging은 렌더링된 컴포넌트의 이름을 콘솔에 로그하는 Higher Order Component입니다. 이는 컴포넌트(WrappedComponent)를 인수로 받아 원래 컴포넌트를 래핑하고 로깅 기능을 추가한 새로운 함수형 컴포넌트(WithLogging)를 반환합니다.\n\n함수형 컴포넌트에서 Higher Order Components 사용하기:\n\n한 번 Higher Order Component가 정의되면, 그것을 사용하여 함수형 컴포넌트를 래핑하여 향상시킬 수 있습니다. 다음은 withLogging Higher Order Component를 함수형 컴포넌트와 함께 사용하는 방법입니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () =\u003e {\n  return \u003cdiv\u003e안녕, 세상!\u003c/div\u003e;\n};\n\nconst EnhancedComponent = withLogging(MyComponent);\n\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cEnhancedComponent /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n\n\n이 예시에서 MyComponent는 일반 함수형 컴포넌트이고, EnhancedComponent는 withLogging Higher Order Component를 MyComponent에 적용한 결과입니다. App 컴포넌트 내에서 EnhancedComponent를 렌더링하면 감싸진 컴포넌트의 이름(MyComponent)이 콘솔에 기록됩니다.\n\n함수형 컴포넌트와 Higher Order Components의 장점:\n\n- 코드 재사용을 촉진하고 교차 관심사의 캡슐화를 장려합니다.\n- 로직을 표현으로부터 분리하여 관심사의 분리를 가능하게 합니다.\n- 여러 Higher Order Components를 함께 조합할 수 있는 합성 기능을 향상시킵니다.\n- 컴포넌트를 보다 집중적이고 격리된 상태로 테스트할 수 있도록 돕습니다.\n\n결론\n\n\n\n리액트 고차 컴포넌트는 재사용 가능한 로직과 동작을 확장하는 강력한 방법을 제공합니다. 공통 기능을 고차 컴포넌트 내에 캡슐화함으로써, 개발자들은 리액트 애플리케이션에서 코드 구성, 유지 관리성, 그리고 재사용성을 향상시킬 수 있습니다. 인증, 로깅 또는 기타 교차 관심사를 구현하려는 경우, 고차 컴포넌트는 기능 컴포넌트 강화를 위한 유연하고 효과적인 해결책을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png"},"coverImage":"/assets/img/2024-05-12-LeveragingReactHigherOrderComponentsHOCinFunctionalComponents_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 페이지와 함께 페이지네이션하기","description":"","date":"2024-05-12 22:14","slug":"2024-05-12-PaginationinReactNativewithPage","content":"\n\n소개:\n\n페이지네이션은 React Native에서 대량의 데이터 목록을 효율적으로 관리하고 표시할 수 있게 해주는 강력한 기술입니다. 이 글에서는 FlatList와 페이지네이션 버튼을 사용하여 고급 페이지네이션을 구현하는 방법에 대해 알아볼 것입니다. 페이지네이션의 논리, 각 페이지별 데이터 검색 방법 및 렌더링 프로세스의 최적화에 대해 논의할 것입니다. 함께 React Native 페이지네이션을 마스터해봅시다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Vj09FpPeRuOC7tDLGpBrsg.gif)\n\n```js\n..... 구성 요소 구조 ....\nconst handlePageClick = (p: number) =\u003e setCurrentPage(p);\n\n  const renderItem = ({item}: {item: ScoreCard}) =\u003e {\n    return \u003cCard item={item} key={item.id} /\u003e;\n  };\n\nreturn (\n\u003cSafeAreaView style={styles.container}\u003e      \n      \u003cFlatList\n        data={items}\n        renderItem={renderItem}\n        keyExtractor={item =\u003e item.id}\n        ListEmptyComponent={handleEmpty}\n        windowSize={10} // VirtualizedList의 기능 추가\n        refreshControl={\n          \u003cRefreshControl refreshing={refreshing} onRefresh={handleRefresh} /\u003e\n        }\n      /\u003e\n      \u003cView style={styles.paginationContainer}\u003e\n        {renderPaginationButtons()}\n      \u003c/View\u003e\n    \u003c/SafeAreaView\u003e\n)\n...\n```\n\n\n\n- 페이지네이션 로직\n\n저희 페이지네이션 구현의 핵심은 'Institution' 컴포넌트에 있습니다. 이 컴포넌트는 'useState'와 같은 React 훅을 사용하여 중요한 상태 변수를 관리합니다. 'currentPage' 상태는 현재 표시되는 페이지를 나타내고, 'totalPages'는 전체 목록에 대한 총 페이지 수를 저장합니다. 'itemsPerPage'를 설정하여 페이지 당 표시할 항목 수를 결정하여 로딩 프로세스를 최적화합니다.\n\n```js\nconst [totalPages, setTotalpages] = useState(0);\nconst [currentPage, setCurrentPage] = useState(0);\nconst [items, setItems] = useState([]);\nconst [refreshing, setRefreshing] = useState(false);\nconst itemsPerPage = 16;\n```\n\n2. 각 페이지의 데이터 가져오기\n\n\n\n'fetchData' 함수는 페이지네이션 로직의 중요한 부분입니다. 'Institution' 컴포넌트가 마운트되거나 'currentPage'가 변경될 때마다 해당 함수를 호출하여 현재 페이지의 데이터를 검색합니다. 우리는 데이터를 가져오는 작업을 처리하는 'fetcher' 유틸리티 함수를 사용합니다.\n\n```js\nuseEffect(() =\u003e {\n  fetchData();\n}, [currentPage]);\n\nasync function fetchData() {\n  setRefreshing(true);\n  try {\n    let response = await fetcher(currentPage, itemsPerPage);\n    setTotalpages(response.metadata.total / itemsPerPage);\n    let data: [] = response.results;\n    setItems(data);\n    setRefreshing(false);\n  } catch (error) {\n    setRefreshing(false);\n    console.log(error);\n  }\n}\n```\n\n3. 페이지네이션 버튼 처리\n\n사용자가 페이지별 목록을 탐색할 수 있도록 하기 위해, 페이지네이션 버튼을 렌더링할 때 TouchableOpacity 요소를 사용합니다. 'renderPaginationButtons' 함수는 'currentPage', 'totalPages', 그리고 표시할 최대 버튼 수('maxButtonsToShow')를 기반으로 표시할 페이지를 계산한 다음 적절한 버튼을 생성합니다.\n\n\n\n```js\nconst renderPaginationButtons = () =\u003e {\n  const maxButtonsToShow = 5;\n  let startPage = Math.max(0, currentPage - Math.floor(maxButtonsToShow / 2));\n  let endPage = Math.min(totalPages, startPage + maxButtonsToShow - 1);\n\n  if (endPage - startPage + 1 \u003c maxButtonsToShow) {\n    startPage = Math.max(0, endPage - maxButtonsToShow + 1);\n  }\n\n  const buttons = [];\n\n  for (let i = startPage; i \u003c= endPage; i++) {\n    buttons.push(\n      \u003cTouchableOpacity\n        key={i}\n        onPress={() =\u003e handlePageClick(i)}\n        style={[\n          styles.paginationButton,\n          i === currentPage ? styles.activeButton : null,\n        ]}\u003e\n        \u003cText style={{color: 'white'}}\u003e{i}\u003c/Text\u003e\n      \u003c/TouchableOpacity\u003e,\n    );\n  }\n\n  return buttons;\n};\n```\n\n4. Pull-to-Refresh 및 데이터 없음 처리\n\n더 나은 사용자 경험을 제공하기 위해 'RefreshControl'를 사용하여 pull-to-refresh 기능을 구현했습니다. 사용자는 필요할 때 목록을 수동으로 새로 고칠 수 있습니다. 추가로, 표시할 기관이 없는 시나리오를 처리하기 위해 '기관 없음' 메시지를 렌더링합니다.\n\n```js\nconst handleRefresh = () =\u003e {\n  setRefreshing(true);\n  setTimeout(() =\u003e setRefreshing(false), 1000);\n};\n\nconst handleEmpty = () =\u003e {\n  return \u003cText\u003e기관이 없습니다!\u003c/Text\u003e;\n};\n```\n\n\n\n5. 더 나은 사용자 경험을 위한 스타일링\n\n저희는 컴포넌트에 시각적 매력을 더하기 위해 StyleSheet를 활용합니다. 페이지네이션 버튼은 활성화될 때 색상과 크기가 변경되어 사용자에게 시각적 피드백을 제공하여 전체 앱 경험을 향상시킵니다.\n\n```js\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  paginationContainer: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingVertical: 8,\n    backgroundColor: 'transparent',\n  },\n  paginationButton: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    marginHorizontal: 4,\n    backgroundColor: 'gray',\n  },\n  activeButton: {\n    backgroundColor: '#22c55d',\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n  },\n  buttonText: {\n    color: 'white',\n  },\n});\n```\n\n맺음말\n\n\n\n이 코드에 대한 링크는 여기에서 확인할 수 있습니다 - ` paginate. React Native pagination을 FlatList와 페이지 버튼으로 마스터하여 대량의 데이터 목록을 손쉽게 처리하여 부드러운 성능과 더 나은 사용자 경험을 보장할 수 있습니다. 페이지네이션은 렌더링을 크게 최적화하며 네트워크 리소스 부하를 줄이고 전반적인 앱 대응성을 향상시킵니다. React Native 애플리케이션에서 고급 페이지네이션을 구현하는 것은 고품질이고 성능이 우수한 모바일 앱을 제공하는 데 유용한 기술입니다.","ogImage":{"url":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png"},"coverImage":"/assets/img/2024-05-12-PaginationinReactNativewithPage_0.png","tag":["Tech"],"readingTime":5},{"title":"React 19를 소개합니다 웹 개발의 다음 진화를 드러냅니다","description":"","date":"2024-05-12 22:13","slug":"2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment","content":"\n\n![이미지](/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png)\n\n페이스북에서 개발한 JavaScript 라이브러리인 React는 탄생 이후 현대 웹 개발의 최전선에 있었습니다. 각 버전마다 혁신적인 기능을 도입하여 견고한 사용자 인터페이스를 더 쉽고 효율적으로 구축할 수 있게 해 왔습니다. 이제 React 19가 출시되면서 커뮤니티는 최신 기능과 혁신에 대한 기대감으로 들뜹니다. 함께 React 19가 가져다주는 흥미로운 새로운 기능을 살펴보겠습니다.\n\n# 동시 렌더링\n\nReact 19의 가장 중요한 진보 중 하나는 동시 렌더링의 도입입니다. 이 혁신적인 기능을 통해 React는 여러 작업을 동시에 처리할 수 있어 응용 프로그램의 성능과 응답 시간을 크게 향상시킵니다. 동시 렌더링을 통해 React는 UI의 가장 중요한 부분을 렌더링하는 것을 우선시하고 덜 중요한 업데이트는 연기함으로써 더 부드러운 사용자 경험과 더 빠른 로드 시간을 제공할 수 있습니다.\n\n\n\n# 데이터 가져오기를 위한 Suspense\n\nReact 19에서는 이전 버전에서 소개된 suspense 개념을 발전시켜 데이터 가져오기에 특화된 suspense를 소개합니다. 이 강력한 메커니즘은 개발자가 로딩 상태와 오류 처리를 선언적으로 지정할 수 있도록 해줍니다. 이로써 API로부터 데이터를 가져오는 등의 비동기 작업을 간편하게 관리할 수 있습니다. React 생태계에 suspense를 원활하게 통합함으로써, 개발자는 복잡한 상태 관리 라이브러리를 사용하지 않고도 더 직관적이고 원활한 사용자 경험을 제공할 수 있습니다.\n\n# 개선된 서버 측 렌더링 (SSR)\n\n서버 측 렌더링은 빠른 초기 페이지 로드를 제공하고 SEO를 개선하는 데 필수적입니다. React 19에서는 SSR 능력에 상당한 향상이 이루어져 서버 렌더링된 애플리케이션을 구축하기가 더욱 쉬워졌습니다. 스트리밍 및 수분화 기능이 개선되어, React 19가 개발자에게 클라이언트 및 서버 환경 모두에 완벽하게 최적화된 동적 대화형 경험을 제공할 수 있게 되었습니다.\n\n\n\n# 더 나은 TypeScript 지원\n\nTypeScript는 초기에 오류를 미리 파악하고 코드 유지 관리를 개선하는 능력으로 React 커뮤니티에서 점차 인기를 얻고 있습니다. React 19는 TypeScript 지원을 한층 더 강화하여 더 나은 유형 추론, 인기 있는 TypeScript 기능과의 향상된 호환성, 향상된 개발자 도구를 제공합니다. 경험 많은 TypeScript 사용자이든 막 시작한 사용자이든, React 19를 통해 React 프로젝트에서 정적 유형의 혜택을 누리기가 이전보다 쉬워졌습니다.\n\n# 번들 크기 개선을 위한 선택적 기능\n\n번들 크기를 최적화하고 성능을 개선하기 위해 React 19는 선택적으로 필요한 컴포넌트와 기능만 포함할 수 있는 옵션 기능을 도입했습니다. 이러한 세부적인 번들링 접근법은 애플리케이션이 가볍고 효율적으로 유지되도록 보장하여 불필요한 오버헤드를 최소화하고 상호 작용 시간을 줄입니다. React 19가 개발자들에게 번들 크기를 더 많은 제어권을 부여함으로써 더 빠르고 더 스트리밍된 경험을 사용자에게 제공할 수 있도록 돕습니다.\n\n\n\n# 결론\n\nReact 19 버전을 통해 React 팀은 한 번 더 웹 개발의 기준을 높였으며, 사용자 인터페이스를 구축하는 방식을 바꿀 혁신적인 기능과 개선 사항을 제공했습니다. 병행 렌더링부터 향상된 TypeScript 지원까지, React 19는 개발자들에게 빠르고 기능이 풍부한 응용 프로그램을 만드는 데 필요한 도구를 제공합니다. React 생태계가 계속 발전함에 따라 확실한 것은 웹 개발의 미래가 이전보다 밝아졌다는 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-IntroducingReact19UnveilingtheNextEvolutioninWebDevelopment_0.png","tag":["Tech"],"readingTime":2}],"page":"56","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"56"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>