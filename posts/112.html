<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/112" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/112" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="피해야 할 5가지 실수 웹 개발자로서" href="/post/2024-05-14-AvoidThese5MistakesasaWebDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="피해야 할 5가지 실수 웹 개발자로서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="피해야 할 5가지 실수 웹 개발자로서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">피해야 할 5가지 실수 웹 개발자로서</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대용량 JSON 객체를 효율적으로 업데이트하는 방법" href="/post/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대용량 JSON 객체를 효율적으로 업데이트하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대용량 JSON 객체를 효율적으로 업데이트하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대용량 JSON 객체를 효율적으로 업데이트하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next JS 렌더링 패턴 - 포괄적인 안내" href="/post/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next JS 렌더링 패턴 - 포괄적인 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next JS 렌더링 패턴 - 포괄적인 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next JS 렌더링 패턴 - 포괄적인 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" href="/post/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs 어플리케이션의 성능 최적화 기술" href="/post/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs 어플리케이션의 성능 최적화 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs 어플리케이션의 성능 최적화 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs 어플리케이션의 성능 최적화 기술</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 172에서의 Material 3 실험적 지원" href="/post/2024-05-14-Material3ExperimentalSupportinAngular172"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 172에서의 Material 3 실험적 지원" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 172에서의 Material 3 실험적 지원" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 172에서의 Material 3 실험적 지원</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue 34의 State에 대한 개념 모델" href="/post/2024-05-14-AConceptualModelofStateinVue34"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue 34의 State에 대한 개념 모델" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue 34의 State에 대한 개념 모델" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue 34의 State에 대한 개념 모델</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" href="/post/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" href="/post/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular Routes반쯤 타입 지정하는 간단한 꿀팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs는 단일 스레드인가요" href="/post/2024-05-14-IsNodejssingle-threaded"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs는 단일 스레드인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IsNodejssingle-threaded_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs는 단일 스레드인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs는 단일 스레드인가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link posts_-active__YVJEi" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"피해야 할 5가지 실수 웹 개발자로서","description":"","date":"2024-05-14 12:46","slug":"2024-05-14-AvoidThese5MistakesasaWebDeveloper","content":"\n\n\n![Avoid These 5 Mistakes as a Web Developer](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png)\n\n우리는 모두 실수를 합니다. 배우고成長하며、경험을 쌓는 가장 효율적인 방법입니다. 실수를 돌아보고 그로부터 배우면 스스로를 향상시킬 수 있습니다.\n\n대부분의 사람들은 자신의 실수를 돌아보지 않습니다. 그들은 그 실수를 저지르지 않았어야 한다고 자책합니다. 다른 사람이 그들을 비난할 필요는 없습니다; 그들 스스로 힘을 줍니다.\n\n웹 개발자 경력 중에 백엔드 엔지니어가 범하는 십 가지 오류를 나열하겠습니다. 실수를 범하는 데는 현재 위치가 중요하지 않습니다. 우리는 경력 어디서든지 언제든지 실수를 합니다.\n\n\n\n\n# 실수 #1\n\n기술 부채. 지나친 공학. 종소리가 울리나요? 종종, 개발자들은 사용자가 응용 프로그램을 활용하는 방식을 이해하는 대신 기술적인 측면에 초점을 맞춥니다. 해당 요구 사항에 따라 코드를 작성하지 않습니다. 백엔드 엔지니어가 요구 사항을 기반으로 기술을 사용하면 필요한 노력과 비용을 크게 줄일 수 있습니다.\n\n대부분의 경우, 초보자들이 이 실수에 빠집니다. 분야에 새로 온 사람들은 사용자에게 효율적으로 제공되는 기술을 알지 못하기 때문에 기술적 부담을 줄이는 기술을 사용하지 않는 것입니다. 더 많은 기술과 처리가 필요할 때 응용 프로그램은 최종 사용자에게 느리게 나타납니다.\n\n어떤 분야, 취미 또는 습관에 새로 온 사람들은 프로세스를 지나치게 복잡하게 만들기 쉽습니다. 그러나 경력자들은 더 적은 기술을 사용하여 개발 및 사용자 시간을 절약하면서 노력과 비용을 줄입니다.\n\n\n\n더불어, 기술 부채는 읽기 어려운 코드를 나타냅니다. 다른 엔지니어들이 이해할 수 있는 로직을 작성하는 것이 개발의 첫 번째 규칙입니다. 이는 이러한 산업 표준 기술과 코딩 표준을 사용하거나 변수를 CamalCase 규칙으로 작성하는 것을 의미합니다.\n\n초보자들은 가능한 모든 것을 사용할 때 자부심을 느낍니다. 나중에는 동일한 선택이 응용 프로그램을 느리게 만들 때 머리가 아플 수 있습니다. 이로 인해 시니어들이 코드를 리팩토링해야 하며, 이는 시간 낭비입니다. 코드가 많아질수록 테스트 요구 사항과 버그 발생 확률이 증가합니다. 코드를 적게 작성하세요.\n\n자존심을 한쪽에 두고 필요한 기술만 선택하고 최고의 산업 표준을 준수함으로써 이러한 실수를 피할 수 있습니다. 프론트엔드 프레임워크와 라이브러리를 배울 때 이 실수를 저질렀습니다. 이에 따라 더 많은 코드, 더 많은 버그 및 대규모 리팩토링 비용이 발생했습니다. DRY, KISS 또는 YAGNI 표준을 따르세요.\n\n# 실수 #2\n\n\n\n내가 Udemy에서 React를 배우는 데 돈을 썼어. 그 스킬을 활용해서 모든 애플리케이션을 React로 만들어야겠지? 아니야. 모든 작업에 같은 기술, 라이브러리 또는 프레임워크를 사용하지 말아야 해. 이 프레임워크의 선택은 해결해야 하는 문제에 따라 다르니까.\n\nReact + Vite는 중급 웹 애플리케이션에 적합할 수도 있어. 그러나 성능 중심의 애플리케이션에는 적합하지 않아. 그럴 때는 성능을 향상시키기 위해 SolidJS, NextJS 또는 다른 프레임워크를 선택해야 해.\n\n주어진 작업에 따라 사용하는 기술을 바꿔. 선택한 언어인 JavaScript 같은 기본기는 튼튼히 갖추고 있고, 기술을 바꿔가며 학습해.\n\n하나의 기술에만 고수하지 마. 그것은 학습 능력을 제한하고 애플리케이션이 문제를 겪게 만들어. 나중에 그 기술을 바꿔야 하게 될 텐데, 처음부터 그렇게 할 수 있었을 텐데.\n\n\n\n# 실수 #3\n\n나쁜 의도를 가진 사람들은 데이터베이스를 공격하고 자격 증명을 도용하기 위한 엄청난 기술을 가지고 있습니다. SQL 인젝션은 흔한 기술 중 하나입니다. 그것이 빈번하다면, 사람들은 그럼에도 불구하고 여전히 그에 빠질까요? 네, 그렇습니다!\n\n이것은 시니어들이 데이터베이스를 수정하는 쿼리를 주입하는 것을 방지하는 코드를 작성할 수 있지만, 주니어들은 이 분야의 복잡함을 알지 못할 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_1.png)\n\n\n\n2022년을 기준으로 웹 응용프로그램에서 발생한 전체 취약점 중 33%가 SQL Injection 공격으로 인한 것입니다. 원치 않는 문자열을 표준 쿼리와 연결함으로써 개인들이 DB에 액세스하고 일반적으로 DML 명령을 실행합니다.\n\n이러한 실수를 피하기 위해 일반화된 쿼리를 사용하는 대신 쿼리 내에 구체적으로 필요한 매개변수를 전달하세요. 모든 작업에 대해 표준 쿼리를 만들지 마세요. 그렇게 하면 새벽 2시 30분에 전화를 받을 수도 있습니다. 여러 개의 데이터베이스를 사용하고 모든 과일을 한 바구니에 넣지 마세요.\n\n다양성이 중요합니다. 코드 리뷰를 수행하세요. 특히 실행 중인 쿼리에 대해 연결된 문자열을 검증하세요. 제품 DB를 백업하면서 유지하세요.\n\n# 실수 #4\n\n\n\n미적인 면에 초점을 맞추는 사람이신가요? 사용성보다는 미학에 더 집중하는 것은 일반적인 초보 실수입니다. 초보 개발자는 사용자가 응용 프로그램을 어떻게 활용하는지에 대해 덜 주의를 기울이고 디자인을 지나치게 복잡하게 만들곤 합니다. UI/UX는 테스트 단계까지 아름답게 보일 수 있어요.\n\n사용자들이 귀하는 응용 프로그램을 이용하게 될 때 비즈니스 매출이 감소합니다. 왜냐하면 그 중 95%는 사용하지 못하기 때문이죠. 복잡성 때문이라고 해야겠어요. 사용자들은 간단한 디자인을 선호합니다. 이미 본 적 있는 인터페이스가 원하는 것이죠. 사람들은 습관에 집중합니다. 어떤 작업에도 덜 노력을 기울이고 싶어해요.\n\n사용자들은 새로운 패턴을 배우도록 강요하면 응용 프로그램을 사용하지 않을 거예요. 이전 디자이너 세대에 의해 시작된 특정 패턴에 익숙해진 인간들이 존재합니다. 젊은 사람들은 습관을 변경할 수 있지만, 대부분의 사용자는 그렇지 않을 겁니다.\n\n대중을 대상으로 디자인하고 구축하세요. 기존 표준과 사용자 패턴이나 행동을 활용해 인터페이스를 작성함으로써 이러한 실수를 피해보세요. 사용자가 최소한의 노력으로 제품을 구매할 수 있도록 해주세요. 소셜 미디어는 이러한 실수에 대한 해결책을 제시했습니다. 그것이 중독성이 있는 이유가 있지요. 더 적은 노력, 더 큰 보상.\n\n\n\n# 실수 #5\n\n일단 해결책을 만들고 코드를 작성해 보세요. 나중에 어떻게 될지는 확인해 볼 거에요. 변경 사항은 나중에 하기로 했잖아요? 그렇지 않아요. 처음부터 확장 가능성을 고려하세요. 버그와 오류를 수정하는 데 필요한 리팩토링과 개발 시간은 이상적이지 않아요.\n\n시작부터 문제를 해결하는 데 특정 기술을 선택하고, 가능한 미래 지표에 기반해 확장 가능한지 파악하세요. 예를 들어, 우리가 다양화하기로 결정한 후 React 성능 특정 작업을 사용할 수 있을까요? 아니에요. 그러면 사용해야 할까요? 아니요. 다른 기술을 선택하세요.\n\n대부분의 백엔드 엔지니어는 모든 문제에 같은 기술 세트를 사용해요. 개발자들은 가능한 트래픽과 데이터 거래를 고려하지 않아요. 2013년, 해커들이 Snapchat의 확장 가능성이 없는 코드베이스를 악용하여 수백만 명의 사용자 데이터에 접근했어요. 그런 일이 발생하지 않길 바라지 않겠죠.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"},"coverImage":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png","tag":["Tech"],"readingTime":4},{"title":"대용량 JSON 객체를 효율적으로 업데이트하는 방법","description":"","date":"2024-05-14 12:45","slug":"2024-05-14-HowToUpdateLargeJSONObjectsEfficiently","content":"\n\n\n![JSON Patch](/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png)\n\nJSON Patch는 JSON 문서를 변경하는 방법을 설명하는 형식으로, JSON 데이터를 수정하는 방법을 보여주는 간결한 작업 지침의 시리즈를 사용합니다. 이 작업에는 새 데이터 추가, 이전 데이터 삭제, 기존 데이터 교체 또는 데이터 이동이 포함됩니다.\n\n## JSON Patch를 사용하는 이유\n\n대규모 웹 애플리케이션에서 클라이언트는 최신 데이터를 가져오거나 수정된 데이터를 서버에 제출하기 위해 서버와 자주 통신해야 합니다. 기존 방식은 모든 업데이트마다 전체 JSON 문서를 보내는 것이며, 실제 데이터의 일부분만 변경되었더라도 전송됩니다. 이는 네트워크 트래픽 증가, 네트워크 지연 증가, 서버 및 클라이언트 부하 증가로 이어집니다.\n\n\n\n\nJSON Patch는 네트워크 전송 양을 줄이고 데이터 업데이트 효율성을 향상시키는 효율적인 솔루션을 제공합니다. JSON Patch를 사용하면 클라이언트는 전체 JSON 문서가 아닌 수정이 필요한 데이터 부분만 전송할 수 있습니다. 서버가 JSON Patch를 수신한 후에는 해당 지침에 따라 해당 작업을 수행하여 데이터의 점진적 업데이트를 달성할 수 있습니다. 이는 네트워크 전송 양을 줄이고 네트워크 효율성을 향상시키며 서버와 클라이언트에 가하는 부하를 줄이는데 도움이 됩니다.\n\n## JSON Patch의 혜택은 무엇인가요?\n\n- 전송 양 감소: JSON Patch는 JSON 문서에 대해 수행할 구체적인 변경 사항만 전송하며 전체 JSON 문서를 전송하지 않습니다. 이는 특히 대규모 데이터 세트나 저속 네트워크 환경에서 네트워크 대역폭을 절약할 수 있습니다.\n- 점진적 업데이트: JSON Patch는 JSON 문서에 대한 점진적 업데이트를 지원합니다. 이는 전체 문서가 아닌 변경해야 하는 부분만 보낼 수 있기 때문에 실시간 애플리케이션 및 빈번한 업데이트가 필요한 상황에 유용합니다.\n- 유연성과 확장성: JSON Patch는 JSON 문서에서 수행할 수 있는 작업을 제한하지 않습니다. 필요에 따라 추가, 삭제, 교체, 이동 및 기타 작업을 수행할 수 있으며 필요에 따라 새 작업을 추가할 수도 있습니다.\n\n## JSON Patch는 어떤 작업을 지원하나요?\n\n\n\n1. 추가\n\nJSON 문서에 새로운 값을 추가하려면 경로와 추가할 값이 필요합니다.\n\n```js\n{ \"op\": \"add\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n2. 제거\n\n\n\nJSON 문서에서 값을 제거하려면 제거할 값을 가리키는 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"remove\", \"path\": \"/path\" }\n```\n\n3. 대체\n\nJSON 문서의 값을 교체하려면 대체할 값을 가리키는 경로와 새 값이 필요합니다.\n\n\n\n```js\n{ \"op\": \"replace\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n4. 이동\n\nJSON 문서에서 값을 다른 위치로 이동하려면 이동할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"move\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n\n\n5. 복사\n\nJSON 문서에서의 값을 다른 위치로 복사하려면 복사할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"copy\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n6. 테스트\n\n\n\nJSON 문서에서 값이 특정 값과 동일한지 확인하는 테스트를 수행하며, 이는 주로 작업이 성공적으로 실행될 수 있는지 확인하는 데 사용됩니다. 테스트할 값이 들어 있는 경로와 예상 값이 명시되어야 합니다.\n\n```js\n{ \"op\": \"test\", \"path\": \"/경로\", \"value\": \"예상 값\" }\n```\n\n## JSON 패치 사용 방법\n\n많은 개발 언어에서 JSON 패치 사양을 구현했습니다. JS 환경에서는 fast-json-patch 라이브러리를 사용할 수 있습니다.\n\n\n\n첫째로, npm 또는 pnpm을 사용하여 fast-json-patch를 설치해주세요:\n\n```js\nnpm install fast-json-patch\n또는 \npnpm add fast-json-patch\n```\n\nfast-json-patch 라이브러리를 성공적으로 설치한 후에는 제공되는 API를 활용하여 다음 기능을 수행할 수 있습니다:\n\n- 두 개의 객체를 비교하여 패치를 가져오기\n- 객체 변경을 관찰하고 변경사항을 감지할 때 패치를 생성하기\n- JS 객체에 단일 또는 여러 패치 적용하기\n- 패치 시퀀스를 유효성 검사하기\n\n\n\n- 두 객체를 비교하여 패치를 가져오기\n\n```js\nimport { compare } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst documentB = { user: { firstName: \"Albert\", lastName: \"Collins\" } };\n\nconst diff = compare(documentA, documentB);\n\n/**\n * diff: \n * [ { op: 'replace', path: '/user/lastName', value: 'Collins' } ]\n */\n```\n\n2. 객체 변경 사항을 관찰하고 변경이 감지되면 패치를 생성합니다.\n\n```js\nimport { generate, observe } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\nconst observer = observe(document);\ndocument.firstName = \"Albert\";\ndocument.contactDetails.phoneNumbers[0].number = \"123\";\ndocument.contactDetails.phoneNumbers.push({ number: \"456\" });\nconst patch = generate(observer);\n\n/**\n * patch：\n * [\n *  {\n *    op: 'replace',\n *    path: '/contactDetails/phoneNumbers/0/number',\n *    value: '123'\n *  },\n *  {\n *   op: 'add',\n *   path: '/contactDetails/phoneNumbers/1',\n *   value: { number: '456' }\n *  },\n *  { op: 'replace', path: '/firstName', value: 'Albert' }\n * ]\n */\n```\n\n\n\n3. JS 객체에 단일 또는 여러 패치 적용하기\n\n단일 패치 적용\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst patchedResult = applyPatch(documentA, [\n  { op: \"replace\", path: \"/user/lastName\", value: \"Collins\" },\n]);\n\n/**\n * patchedResult[0]:\n * {\n *   newDocument: { user: { firstName: 'Albert', lastName: 'Collins' } },\n *   removed: 'Einstein'\n * }\n */\n```\n\n다중 패치 적용\n\n\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\n\nconst patchedResult = applyPatch(document, [\n  {\n    op: \"replace\",\n    path: \"/contactDetails/phoneNumbers/0/number\",\n    value: \"123\",\n  },\n  {\n    op: \"add\",\n    path: \"/contactDetails/phoneNumbers/1\",\n    value: { number: \"456\" },\n  },\n  { op: \"replace\", path: \"/firstName\", value: \"Albert\" },\n]);\n\n/**\n * patchedResult[0]: \n * {\n *  newDocument: {\n *    firstName: \"Albert\",\n *    lastName: \"Wester\",\n *    contactDetails: { phoneNumbers: [{ number: \"123\" }, { number: \"456\" }] },\n *  },\n *  removed: \"555-123\",\n * }\n */\n```\n\n4. 패치 시퀀스 유효성 검사\n\n```js\nimport { validate } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst validatedResult = validate(\n  [{ op: \"replace\", path: \"/user/lastName\", value: \"Collins\" }],\n  documentA\n);\n```\n\n만약 패치 시퀀스가 JSON Patch 사양을 충족하지 않으면, 검증 중에 JsonPatchError 예외 객체가 발생합니다.\n\n\n\nJSON Patch와 fast-json-patch가 소개되었어요! 관심이 있다면 JSON Patch를 직접 경험해보세요. 다른 해결책이 있으면 메시지를 남겨주세요.\n\nTypeScript는 멋지고 배울 가치가 있어요. TypeScript를 배우고 싶다면, 저를 팔로우해서 더 많은 TS와 JS 정보를 읽어보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png"},"coverImage":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png","tag":["Tech"],"readingTime":6},{"title":"Next JS 렌더링 패턴 - 포괄적인 안내","description":"","date":"2024-05-14 12:43","slug":"2024-05-14-NextJSRenderingPatternsaComprehensiveGuide","content":"\n\n렌더링 패턴에 대한 정보는 문서, 자습서 또는 블로그 게시물 등이 끊임없이 있습니다. 그러나 시작하고 무언가를 구축하기 위해 얼마나 많은 지식이 필요할까요? 이 게시물에서는 무엇이 무엇인지 이해하고 렌더링이 Next.js에서 어떻게 작동하는지를 굳게 이해하는 데 도움이 되는 각기 다른 렌더링 패턴의 기본 내용을 요약하겠습니다.\n\n![image](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png)\n\n- 두 가지 주요 렌더링 패턴\n  - 클라이언트 측 렌더링\n    - 어떻게 작동합니까?\n    - 브라우저에서 구성 요소를 렌더링하는 방법?\n    - 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSG — 정적 사이트 생성\n    - 어떻게 작동합니까?\n    - 언제 사용해야 하나요?\n    - Next 13부터 페이지를 완전 정적으로 만들기:\n    - 동적 경로 생성 및 빌드 시간에 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSR — 서버 측 렌더링\n    - 어떻게 작동합니까?\n    - 유의할 사항:\n    - 페이지를 완전히 동적으로 만드는 방법:\n    - 이점:\n    - 제한 사항:\n  - ISR — 점진적 사이트 재생\n    - 어떻게 작동합니까?\n    - 이점:\n  - PPR — 부분 사전 렌더링:\n    - 부분 사전 렌더링 활성화:\n    - 필요성:\n    - 어떻게 작동합니까?\n- 기본 Next.js 렌더링 동작\n- 렌더링 위치 결정 방식\n\n# 두 가지 주요 렌더링 패턴\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드립니다.\n\n다음과 같이 렌더링 패턴을 넓게 분류할 수 있어요:\n\n- 클라이언트 측 렌더링\n- 사전 렌더링\n\n이름에서 알 수 있듯이 클라이언트 측 렌더링은 브라우저에서 구성 요소를 렌더링하는 것을 말해요.\n\n사전 렌더링은 다양한 방법으로 수행될 수 있어요.\n\n\n\n- SSG 또는 정적 사이트 재생성\n- SSR 또는 서버 사이드 렌더링\n- ISR 또는 증분 사이트 재생성\n- PPR 또는 부분 사전 렌더링 (Next 14에서 실험적 기능으로 제공됨)\n\n우리는 클라이언트 측 렌더링부터 시작해서 다양한 사전 렌더링 접근법으로 넘어갈 것입니다.\n\n# 클라이언트 측 렌더링\n\n## 어떻게 작동하나요?\n\n\n\nNext JS에서 클라이언트 구성 요소는 초기에 서버에서 사전 렌더링되고 DOM이 클라이언트로 전송되어 사용자가 볼 수 있는 내용이 제공됩니다. 그런 다음 JS 코드가 브라우저로 전송되어 DOM에 상호 작용을 추가합니다. DOM이 표시된 후 상호 작용을 천천히 추가하는 이 프로세스를 수분화(hydration)라고 합니다.\n\n## 브라우저에서 구성 요소를 렌더링하는 방법은 무엇인가요?\n\n파일의 시작 부분에 \"use client\" 지시문을 추가하면 됩니다.\n\n## 데이터 가져오기:\n\n\n\nNext JS 백엔드로 API 호출하거나 필요한 데이터를 가져오기 위해 외부 엔드포인트로 API 호출할 수 있어요.\n\n또는 Next JS 서버 컴포넌트에 정규 함수 호출을 할 수도 있어요.\n\n만약 백엔드도 Next JS로 작성되었다면 데이터베이스 액세스를 그 자체에서 수행할 수 있어요.\n\n## 혜택:\n\n\n\n- 페이지에 상호 작용성을 제공하기 위해 코드에 이벤트 리스너를 추가할 수 있어요.\n- 상태를 유지하고 라이프사이클의 다른 단계에서 특정 작업을 수행하거나 상태를 위한 중앙 저장소를 사용하는 훅을 사용할 수 있어요.\n\n## 제한 사항:\n\n- 콘텐츠 표시에 지연이 있을 수 있어요. JavaScript를 구문 분석한 후 HTML을 얻기 전에 사용자가 보여지는 내용에 대한 지연 때문이에요. 브라우저에서 렌더링 작업을 수행하는 동안 사용자가 빈 페이지를 보거나 상호 작용할 수 없는 페이지를 보게 될 수 있어요. 이는 JS 크기, 코드 내 존재하는 차단 작업(있는 경우), 사용자 디바이스의 제약 사항(인터넷 연결, 메모리 가용성)에 따라 다양합니다.\n- SEO 크롤러는 DOM 탐색을 통해 콘텐츠를 사용해 페이지를 색인화해요. JS가 로드되기를 기다려야 할 때 그들은 DOM을 스캔하기 전에 효과적으로 페이지를 색인화할 수 없어요.\n\n# SSG — 정적 사이트 생성\n\n\n\n## 어떻게 작동하나요?\n\n이 경우의 HTML은 빌드 시간에 생성되어 CDN(콘텐츠 전송 네트워크)에 저장되며, 사용자가 웹사이트/특정 경로에 접속할 때 캐시된 페이지의 버전을 제공합니다.\n\n## 언제 사용해야 하나요?\n\n만약 귀하의 웹사이트에 내용이 거의 변경되지 않고 한 번 오랜 기간에 한 번 변경을 계획하고 예약할 수 있다면, 빌드 시간에 해당 내용을 생성하는 것이 가장 좋습니다(서버에서 생성하지 않습니다).\n\n\n\nFAQ 페이지는 정적으로 생성될 수 있습니다. 회사 소개 페이지, 문서 페이지도 자주 다시 생성할 필요가 없으며 빌드 시간에 생성할 수 있습니다.\n\n## Next 13부터 페이지를 완전 정적으로 만드는 방법:\n\n페이지를 완전 정적으로 만들려면 (다시 말해, Next가 서버에서 렌더링할지 빌드 시간에 렌더링할지 결정하지 않고 우리가 스스로 결정하는 것), 관련 파일에서 동적 구성을 값이 force-static으로 내보냅니다:\n\n```js\nexport const dynamic = 'force-static';\n```\n\n\n\n## 동적 경로 생성 및 데이터 빌드 시간에 가져오기:\n\n이를 위해 generateStaticParams 메서드를 사용할 수 있습니다.\n\n이 블로그에서는 앱 라우터의 generateStaticParams가 페이지 라우터의 getStaticProps 및 getStaticPaths의 기능을 대체하는 방법에 대한 깔끔한 설명을 제공합니다.\n\n## 혜택:\n\n\n\n- 페이지의 내용이 자주 변경되지 않는 많은 페이지가 있다면, 서버에서 매번 미리 렌더링하는 것은 서버 부하를 늘립니다. 정적으로 생성하고 CDN에 저장하면 서버로부터 이 부하를 덜 수행할 수 있습니다.\n- 페이지 로드 시 콘텐츠가 즉시 제공되면 SEO 순위가 높아질 가능성이 높아집니다.\n\n## 제한 사항:\n\n- 데이터가 자주 업데이트되는 정적으로 생성된 페이지가 필요한 경우, 사용자에게 제공될 때 데이터가 오래되어 버릴 가능성이 있습니다.\n- 대량의 정적으로 생성된 페이지의 경우, 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n# SSR — 서버 측 렌더링\n\n\n\n이를 동적 렌더링이라고도 합니다.\n\n지시문이나 \"서버 사용\" 지시문이 없는 파일에서, 서버에서 초기 페이지 로드 후에는 클라이언트가 서버에 요청을 보낼 때 연속적으로 서버 측 렌더링이 발생합니다. 이 요청은 캐싱을 비활성화하거나 재검증된 데이터를 가져오는 형태로 발생할 수 있습니다. 페이지가 사용자나 클라이언트 측의 특정 변경 사항에 기반하여 다시 생성되어야 하기 때문에 이를 동적이라고 합니다.\n\n## 작동 방식은?\n\nHTML이 서버에 로드되고, JS 기능도 서버에 남아 있습니다. 그런 다음 HTML이 클라이언트로 전송되어 표시됩니다.\n\n\n\n## 알림:\n\n- 서버 구성 요소의 JavaScript는 서버에서 실행되며 클라이언트로 전달되지 않습니다. 이러한 구성 요소에 대해서는 브라우저에서 하이드레이션이 없습니다.\n- 서버 구성 요소 내에서는 개인 API 키를 안전하게 사용할 수 있습니다. 클라이언트에 노출되지 않기 때문입니다.\n- 서버 구성 요소 내에서 Node.js 코드를 작성할 수 있습니다. 예시: 파일 읽기/쓰기 코드.\n\n## 페이지를 완전히 동적으로 만들려면:\n\n```js\nexport const dynamic = \"force-dynamic\";\n```\n\n\n\n## 장점:\n\n- 사전 렌더링된 DOM은 검색 엔진에서 크롤링 및 색인화하기 쉽습니다.\n- 데이터 액세스를 할 수 있으며, 가져온 데이터는 즉시 사용하여 DOM을 작성할 수 있습니다 (사용자 세부정보 표시) 브라우저로 HTML을 전송하기 전에. 백엔드에 대한 api 호출을 하는 데 추가적인 시간이 필요하지 않습니다.\n- 데이터는 일정 간격으로 재유효성 검사될 수 있어 항상 최신 상태로 유지할 수 있습니다.\n- 브라우저는 컴포넌트를 렌더링하는 데 일을 하지 않아 클라이언트 측의 제약 사항인 네트워크 연결 부실, 메모리 부족 등이 페이지로드를 방해하지 않습니다.\n\n## 한계:\n\n- 서버 렌더링된 컴포넌트는 대화형이 아니며, 대화형은 이벤트 핸들러의 사용을 필요로 하며 이것은 브라우저에서만 가능합니다. 해결책으로는: 서버에서 정적 내용을 렌더링하고 대화형 내용을 클라이언트에 리프 컴포넌트로 렌더링할 수 있습니다. 예를 들어, 서버에서 렌더링된 내용이 풍부한 페이지 내에 클라이언트에서 렌더링된 양식 또는 버튼이 있는 것과 같습니다.\n- 서버 컴포넌트에는 마운팅/언마운팅 애니메이션을 사용할 수 없습니다. 이러한 애니메이션에 대해 React 훅을 사용하려면 컴포넌트가 마운트된 시점과 React 훅을 알아야 하는데 서버에서는 React 훅을 사용할 수 없습니다.\n- 서버 컴포넌트에서 브라우저 API인 웹 저장소 API (로컬저장소 및 세션저장소), WebRTC (웹 실시간 통신 API), Geolocation API (사용자의 위도 및 경도 가져오기)와 같은 브라우저 API를 사용할 수 없습니다.\n\n\n\n# ISR — 증분 사이트 재생성\n\n## 어떻게 작동하나요?\n\n페이지는 빌드 시에 데이터베이스에서 가져온 데이터로 정적으로 생성됩니다. 그러나 fetch 메서드 자체에서 페이지가 다시 생성될 시간 간격을 지정하고 최신 데이터를 가져와 재확인할 수 있습니다. 이 재확인은 서버에서 동적으로 발생합니다.\n\n```js\n// `app` 디렉토리\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, \n  { next: { revalidate: 60 } });\n  const data = await res.json();\n \n  return data.posts;\n}\n \nexport default async function PostList() {\n  const posts = await getPosts();\n \n  return posts.map((post) =\u003e \u003cdiv\u003e{post.name}\u003c/div\u003e);\n}\n```\n\n\n\nfetch 메서드는 값으로 60을 갖는 revalidate 속성을 지정합니다. 따라서 페이지는 매 60초마다 데이터를 다시 가져와 새 데이터로 다시 생성됩니다.\n\nfetch를 사용하지 않을 때 revalidate하는 방법: axios나 Prisma와 같은 ORM을 사용하는 경우 원하는 시간 간격으로 revalidate 구성을 내보내세요:\n\n```js\nexport const revalidate = 3600 // 최대 1시간마다 revalidate\n```\n\n## 혜택:\n\n\n\n더 빠른 로드 시간과 업데이트된 데이터로 정적 생성의 SEO 성능을 얻을 수 있어요. \n\n# PPR — 부분 사전 렌더링:\n\n이건 실험적인 기능이에요.\n\n## 부분 사전 렌더링 ( PPR )을 활성화하려면:\n\n\n\n최신 Next canary 버전을 설치해보세요:\n\n```js\nnpm install next@cannary\n```\n\n혹은,\n\n```js\nnpx create-next-app@latest .\n```\n\n\n\n프로젝트를 시작한 후, next.config.js 파일로 이동해서 다음과 같이 추가해주세요:\n\n```js\nexperimental: {\n ppr: true\n}\n```\n\n## 이것이 필요한 이유:\n\nNext 14 이전에는 전체 경로가 정적 또는 동적 중 하나여야 했습니다. 그러나 실제 요구사항은 몇 가지 요소가 동적으로 업데이트되어야 하는 정적 페이지일 수 있습니다.\n예를들어, 제품 상세 페이지의 경우 다음이 빌드 시간에 생성된 정적 컨텐츠로 문제없이 표시될 수 있습니다:\n1. 제품 이름\n2. 제품 설명\n3. 제품 가격 (가격이 업데이트될 수 있도록 재검증)\n4. 기타 제품 정보\n\n\n\n그리고 일부 내용들은 동적으로 생성되어야 합니다 (사용자 요청에 기반하여 서버에서 생성됨):\n1. 총 평가 및 리뷰 수\n2. 제품 평점\n3. 리뷰 섹션\n\n## 작동 방식은?\n\n따라서 정적 로딩 셸에 전체 제품 세부 정보 경로를 렌더링하고 그 안에 평가 수, 리뷰 수, 리뷰 섹션을 동적으로 만들 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_1.png)\n\n\n\n동적 콘텐츠는 비동기로 병렬로 스트림 처리되어 서로의 로딩 시간을 차단하지 않습니다.\n\nPPR이 활성화되면 사용자 지정 클라이언트 지시문이 표시되지 않은 모든 사전 렌더링된 페이지 (예:, 허용될 것입니다. 즉, 컴포넌트는 정적으로 생성된 로딩 쉘 내에서 렌더링될 것입니다.\n그런 다음 동적 컴포넌트를 React Suspense 경계 내로 래핑할 수 있습니다.\n그래서 중첩된 제품 세부 정보 라우트는 제품 이미지, 제품 설명, 제품 이름, 가격과 같이 모든 것이 정적으로 생성되고 리뷰, 리뷰 수, 평점 등은 적절한 후행 컴포넌트와 함께 Suspense로 래핑될 것입니다.\n코드가 이러한 Suspense로 래핑된 컴포넌트를 만나면 제공된 후행 컴포넌트를 가져와 그것들을 정적으로 생성하고 해당 컴포넌트의 데이터가 사용 가능할 때까지 래핑된 컴포넌트의 생성을 일시 중단할 것입니다.\n이러한 모든 Suspense로 래핑된 컴포넌트는 비동기로 되어 있으며 데이터를 병렬로 가져오며 한 컴포넌트의 데이터가 사용 가능해지면 렌더링될 것입니다.\n\n```js\nreturn (\n \u003cdiv\u003e\n  \u003cA/\u003e\n  \u003cB/\u003e\n  \u003cSuspense fallback={\u003cFallbackC/\u003e}\u003e\n   \u003cC data={fetch async data}/\u003e\n  \u003c/Suspense\u003e\n  \u003cD/\u003e\n  \u003cSuspense fallback={\u003cFallbackE/\u003e}\u003e\n   \u003cE data={fetch async data}/\u003e\n  \u003c/Suspense\u003e\n  \u003cF/\u003e\n \u003c/div\u003e\n)\n```\n\n여기서 A, B, FallbackC, D, FallbackE 및 F 컴포넌트는 빌드 시 정적으로 생성됩니다.\n사용자가 라우트를 요청하면 정적 컴포넌트가 즉시 사용 가능합니다. 동시에 C 및 E에 대한 데이터 가져오기가 병렬로 시작됩니다. 먼저 데이터를 받는 컴포넌트가 먼저 나타납니다.\n\n\n\nPPR에 대한 자세한 이해를 위해 이 블로그를 읽어보세요.\n\n## Next.js 기본 렌더링 동작\n\n기본적으로 Next JS는 정적 사이트 생성을 선택하려고 노력합니다. 따라서 동적 변수의 값은 자동으로 설정됩니다. 여 less 향을 변경하지 않는 한 Next는 모든 것을 캐시하려고 할 것입니다.\n\n의도적으로 동적 렌더링(서버 상에서)을 선택하기 위해 다음 중 하나를 수행해야 합니다:\n\n\n\n- 값이 'force-dynamic'인 동적 변수를 내보내세요.\n- 'generateStaticParams'를 사용하지 않고 '[id]'와 같은 동적 경로 이름을 사용하세요.\n- 값이 0으로 설정된 revalidate 구성을 내보내세요.\n\n```js\nexport const revalidate = 0;\n```\n\n4. cookies() 또는 header()와 같은 동적 함수를 사용하세요.\n\n5. fetch 요청을 생성하고 'cache: ‘no-store’ ' 또는 'next: 'revalidate: 0'을 전달하세요.\n\n\n\n# 렌더링 위치는 어떻게 결정되나요\n\n이미 \"use client\" 및 \"use server\" 지시문이 구성 요소를 각각 클라이언트와 서버에 렌더링하도록 표시하는 데 사용된다는 것을 알고 계실 것입니다. 그러나 이러한 지시문들이 실제로 어떻게 해석되는지 궁금하시죠?\n\n파일 상단에 \"use client\"를 추가하면 이 파일에 만들어진 구성 요소뿐만 아니라 해당 파일이 의존하는 모든 구성 요소가 브라우저에서 렌더링됩니다. \"use client\"로 표시된 파일의 종속성은 해당 파일의 모든 import 문을 확인하여 해결됩니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_2.png)\n\n\n\n상기 시나리오를 고려해보세요. 당신은 \"home\"이 브라우저에 렌더링되며, \"testimonials\"은 서버에 렌더링되도록 지정했습니다. 그러나 서버 구성 요소가 먼저 로드되고, 그 다음 클라이언트 구성 요소가 로드됩니다. 당신은 Next.js에게 Home 구성 요소가 클라이언트 측에 로드되기 전에 Testimonials를 서버에 렌더링하기 전에 기다리도록 요청했습니다. 하지만 Testimonials 구성 요소 중 하나인 의존성이 아직 렌더링되지 않았을 때 Next.js가 어떻게 Home 구성 요소를 클라이언트 측에 렌더링할 수 있을까요?\n\n이 문제를 해결하기 위해, 서버 구성 요소로 지정되었음에도 불구하고 Testimonials 구성 요소는 클라이언트 측에서 로드될 것입니다.\n\n다음을 해결하기 위해:\n\nHome 구성 요소에서 렌더링하는 동안 서버에서 여전히 Testimonials를 로드하려면 Testimonials 구성 요소를 부모 서버 구성 요소로 전달하여 Home 구성 요소에 자식 속성으로 전달하고 자식으로 렌더링하십시오:\n\n\n\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_3.png)\n\n홈페이지(home.js)에서 Testimonials에 대한 의존성이 페이지(page.js)로 전환되었습니다. 페이지(page.js)는 또한 서버 컴포넌트입니다.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n\n- 글을 박수로 환영하고 작가를 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기","description":"","date":"2024-05-14 12:40","slug":"2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD","content":"\n\n## Feature-Sliced Design과 Bit를 활용한 현대 프런트엔드 구축\n\n대규모 프런트엔드 앱을 작업해보셨다면, 프로젝트를 이해하기 어려운 상황에 직면했을 가능성이 높습니다.\n\n프로젝트 전체에 흩어진 파일 및 컴포넌트들이 서로 의존하는 상황이 발생하여 유지보수가 매우 복잡해지곤 했을 것입니다!\n\n따라서 이러한 문제를 방지하기 위해 프런트엔드 앱을 구성하는 최상의 방법을 보여주는 규칙과 규칙의 집합이 필요할 것입니다. 그리고 그것이 바로 Feature-Sliced Design이 하는 역할입니다.\n\n\n\n# 피처 슬라이스 디자인이란 무엇인가요?\n\n피처 슬라이스 디자인은 프론트엔드 아키텍처 패턴으로, 프론트엔드 앱을 구축하는 데 사용됩니다. 간단히 말해, 코드를 구성하는 규칙과 관례의 컴필레이션이라고 할 수 있습니다.\n\n프론트엔드 애플리케이션을 세 가지 구성 요소로 분해하여 이 작업을 수행합니다:\n\n피처 슬라이스 디자인으로 개발 중이라면, 당신의 앱은 이 세 가지 구성 요소, 즉 레이어(Layers), 슬라이스(Slices), 그리고 세그먼트(Segments)로 구성될 것입니다.\n\n\n\n- 레이어: 모든 프로젝트에서 표준화된 레이어는 수직으로 배치됩니다. 이는 통신이 위에서 아래로 이루어질 수 있음을 의미합니다. 예를 들어, Pages 레이어는 Widgets 레이어와 통신할 수 있지만 그 반대는 불가능합니다. 또한, 앱은 최대 6개의 레이어를 가질 수 있습니다:\n- shared — 프로젝트/비즈니스의 특정 내용에서 분리되어 재사용 가능한 기능입니다. (예: UIKit, 라이브러리, API)\n- entities — 비즈니스 엔티티입니다. (예: 사용자, 제품, 주문)\n- features — 사용자 상호작용, 사용자에게 비즈니스 가치를 제공하는 작업입니다. (예: SendComment, AddToCart, UsersSearch)\n- widgets — 엔티티와 기능을 의미 있는 블록으로 결합하는 구성 레이어입니다. (예: IssuesList, UserProfile)\n- pages — 엔티티, 기능 및 위젯을 사용하여 전체 페이지를 구성하는 구성 레이어입니다.\n- app — 앱 전체의 설정, 스타일 및 제공자입니다.\n- Slices: 각 레이어는 슬라이스로 구성됩니다. 이러한 슬라이스는 비즈니스 도메인을 기반으로 코드를 분할합니다. 이는 코드를 탐색하기 쉽도록 만들고 논리적으로 관련된 모듈을 가깝게 유지합니다. 그러나 기억해야 할 중요한 점은 슬라이스는 동일한 레이어 내의 슬라이스와 통신할 수 없으며 아래 레이어만 통신할 수 있다는 것입니다.\n- Segments: 각 슬라이스는 세그먼트로 구성됩니다. 세그먼트는 기술적 용도를 기준으로 슬라이스 내에서 코드를 분리하는 작은 모듈입니다. 예를 들어, UI, API, lib과 같은 다른 기술적 용도로 다른 세그먼트를 가질 수 있습니다.\n\n이러한 방식으로 코드를 구조화하면 다음과 같은 요소를 소개할 수 있습니다:\n\n- 통일성: 프론트엔드 앱은 이제 레이어, 슬라이스 및 세그먼트에 따라 준수해야 하는 정의된 표준 규칙을 갖게 됩니다.\n- 도메인 주도: 앱은 기술 중심보다 비즈니스 중심으로 구성됩니다. 이를 통해 프로젝트를 더 쉽게 탐색하고 기능을 더 깊이 이해할 수 있습니다.\n- 유지보수성 향상: 모듈이 동일한 레이어 내의 모듈이나 상위 레이어와 통신할 수 없기 때문에 리팩토링 후 앱이 쉽게 고장나지 않습니다.\n\n# 기능 구분 디자인을 사용해야 할까요?\n\n\n\n지금 보면, 특성 슬라이스 디자인을 프론트앤드 앱에 구현하는 데 상당한 노력이 필요하다는 것이 분명하게 드러납니다. 이것은 처음부터 시작하던지, 이전으로 마이그레이션하던지 관계없이 해당됩니다.\n\n따라서 특성 슬라이스 디자인이 모두에게 적합한 것은 아니라는 것을 이해하는 것이 중요합니다. 사실, 저는 다음과 같은 상황에서 특성 슬라이스 디자인을 사용하길 권장합니다:\n\n- 프론트엔드 앱을 구축 중이십니다. 백엔드 응용 프로그램을 특성 슬라이스 디자인으로 모델링하려고 하지 마십시오.\n- 사용자를 위한 애플리케이션을 구축 중이며 UI 라이브러리가 아닙니다. UI 라이브러리에는 비즈니스 도메인도 API 호출도 다루지 않습니다. 사용자를 위한 애플리케이션만이 도메인으로 분리될 수 있습니다.\n- 대규모 프로젝트를 구축 중이며 간단한 앱이 아닙니다. 간단한 할 일 애플리케이션을 만드는 경우에는 FSD의 장점을 알 수 없을 수도 있습니다. 그러나 WriterGate나 Medium과 같은 애플리케이션을 구축하는 경우, FSD가 유용할 수 있습니다.\n\n만약 이 세 가지 요구 사항을 충족하는 프론트엔드 앱이라면, FSD를 사용해 보세요!\n\n\n\n# Feature Sliced Design과 Bit를 사용하여 앱을 만드는 방법\n\n이렇게까지 오셨다면, 귀하의 앱은 Feature Sliced Design (FSD)의 강력한 후보일 가능성이 높습니다. 그러니, FSD를 사용하여 앱을 어떻게 만들 수 있는지 살펴보겠습니다!\n\n저는 Bit를 사용하여 FSD를 활용한 애플리케이션을 빌드할 것입니다. Bit는 조립 가능한 소프트웨어를 위한 혁신적인 빌드 시스템입니다.\n\nBit를 사용하면 독립적인 구성 요소를 빌드할 수 있습니다. 이러한 구성 요소는 격리된 공간에서 설계, 개발, 버전 관리되며 원격 범위에 호스팅됩니다. 이러한 범위는 컴포넌트를 더 잘 시각화하고 유지보수하기 쉽게 해주는 네임 스페이스를 통해 컴포넌트를 논리적으로 구조화하도록 장려합니다.\n\n\n\n위에서 보듯이, 브랜드, 요소, 폰트라는 다른 네임스페이스에서 구성 요소를 논리적으로 정렬했습니다. 이러한 네임스페이스를 활용하여 Bit를 사용하여 FSD를 쉽게 처리할 수 있습니다!\n\n# 단계 01: 필수 조건\n\n먼저 Bit의 버전 관리자(BVMM)를 사용하여 Bit을 전역적으로 설치한 다음 React로 워크스페이스를 초기화하십시오. 이를 통해 React 공간에서 FSD에 작업할 수 있습니다.\n\n```js\n# bit 설치\nnpx @teambit/bvm install \n\n# 워크스페이스 초기화\nbit new react workspace --default-scope dummyorg.fsd --aspect teambit.react/react-env\n```\n\n\n\n더미org.fsd를 본인의 비트 사용자 이름 및 범위 이름으로 교체하세요.\n\n작업 공간을 성공적으로 생성했다면 아래의 출력이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png\" /\u003e\n\n다음으로 로컬 서버를 시작하려면 bit start를 실행하세요. 아래의 출력이 나타날 것입니다:\n\n\n\n# 단계 02: Feature Sliced Design을 사용한 React 앱 정의하기\n\n이제 Bit Components를 사용하여 Feature Sliced Design을 기반으로 한 React 앱을 구축해보겠습니다. 이 데모에서는 블로그 목록을 가져오는 React 앱을 구축해보겠습니다.\n\n그래서, 우리 앱에서는 다음이 있을 것입니다:\n\n- 앱 전체를 유지하는 React 앱\n- 블로그 항목을 렌더링하는 Blog 페이지\n- 단일 블로그 항목을 렌더링하는 Card 컴포넌트\n- 블로그를 나타내는 엔티티\n- 블로그 목록을 가져오는 API 호출\n\n\n\n만약 이것을 FSD로 구조화한다면, 다음과 같이 논리적인 매핑이 있어야 합니다:\n\n- app: 이 디렉토리는 블로그 목록을 위한 React 앱 컴포넌트를 보관할 것입니다.\n- pages: 이 디렉토리는 블로그 목록 페이지를 위한 컴포넌트를 보관할 것입니다.\n- widgets: 블로그 목록을 정의하는 단일 슬라이스가 생성될 것입니다.\n- features: 첫 번째 기능으로 get-blog-posts 라는 슬라이스를 정의할 것입니다. 이 슬라이스에서는 기능이 작동하기 위한 데이터 가져오기 메커니즘을 정의하는 모델 세그먼트를 정의할 것입니다.\n- entities: blog 라는 슬라이스를 정의할 것입니다. 블로그 슬라이스 내에서는 모델과 ui 두 세그먼트가 있을 것입니다. 모델에서는 블로그 항목의 데이터 모양을 정의하고, ui에서는 블로그 포스트 카드를 정의하는 React 컴포넌트인 blog-card를 가질 것입니다.\n\n# 단계 03: Bit를 사용하여 컴포넌트 생성하기\n\n다음으로, Bit를 사용하여 모든 필요한 컴포넌트를 생성해보겠습니다.\n\n\n\n## 1: 엔티티 레이어 구축하기\n\n먼저, 엔티티 레이어를 구축해 봅시다. 이를 위해 다음 명령을 사용하여 블로그 슬라이스를 생성해 보세요:\n\n```js\nbit create react-hook entities/blog/model \u0026\u0026 bit create react entities/blog/ui/blog-item\n```\n\n아래와 같이 새 디렉토리가 생성된 것을 확인할 수 있어요:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_1.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_2.png\" /\u003e\n\n비트(Bit)를 사용하면 spec.tsx 파일과 composition.tsx 파일을 얻을 수 있다는 것을 이미 알아채셨을 것입니다. 단일 컴포넌트에 대한 테스트 케이스를 만들어 테스트 주도 개발(Test Driven Development)로 빌드할 수 있습니다. 또한 compositions 파일을 사용하여 소비자들에게 컴포넌트가 어떻게 사용될 수 있는지 보여주기 위해 컴포넌트의 다른 출력물을 생성할 수 있습니다.\n\n그 다음, 블로그 모델과 블로그 카드 UI를 모델.ts와 blog-item.tsx 파일을 아래와 같이 업데이트하여 정의해 보겠습니다:\n\n\n\n\n```js\n// blog-item.tsx\n\nimport type { ReactNode } from 'react';\nexport type BlogItemProps = {\n  id: string,\n  title: string,\n  description: string\n  tags: string[]\n};\nconst cardStyle: React.CSSProperties = {\n  border: '1px solid #ddd',\n  borderRadius: '8px',\n  padding: '16px',\n  margin: '16px',\n  boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',\n  backgroundColor: '#fff',\n};\nconst titleStyle: React.CSSProperties = {\n  fontSize: '1.5rem',\n  marginBottom: '8px',\n};\nconst tagsStyle: React.CSSProperties = {\n  marginTop: '8px',\n  color: '#555',\n};\nexport function BlogItem({ description, id, title, tags }: BlogItemProps) {\n  return (\n    \u003cdiv className=\"blog-card\"\n      key={id}\n      style={cardStyle}\u003e\n      \u003ch2 style={titleStyle}\u003e{title}\u003c/h2\u003e\n      \u003cp\u003e{description}\u003c/p\u003e\n      \u003cdiv className=\"tags\" style={tagsStyle}\u003e\n        \u003cstrong\u003eTags:\u003c/strong\u003e {tags.join(', ')}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n위에서 보듯이, 블로그 엔티티 및 블로그 카드를 정의하여 블로그를 볼 수 있는 기능을 구현할 수 있습니다. 전체 구현을 보려면 Bit Cloud에서 이 컴포넌트를 확인하세요.\n\n하지만 로컬 서버는 이후 이렇게 보여야 합니다:\n\n## 2: 기능 레이어 구축하기\n\n\n\n다음으로, get-blog-posts 기능을 구축해 봅시다. 이를 위해 하나의 세그먼트가 필요합니다:\n\n- model: 데이터를 가져오는 훅을 정의합시다.\n\n이를 위해 React 컴포넌트를 생성해 봅시다:\n\n```js\nbit create react-hook features/get-blog-posts/model\n```\n\n\n\n그런 다음 아래와 같이 표시된 결과물을 보게 될 거에요:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_3.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_4.png\" /\u003e\n\nmodel.ts 파일을 열어서 아래 코드를 포함시켜서 블로그를 가져와보세요:\n\n\n\n```js\nimport { useBlogStore } from '@dummyorg/fsd.entities.blog.model';\nimport { useEffect } from 'react';\n\nexport function useGetBlogs() {\n  const { blogs, getBlogs, loading } = useBlogStore();\n  useEffect(() =\u003e {\n    getBlogs();\n  });\n  return { blogs, loading };\n}\n```\n\n# 3: 위젯 레이어 구축하기\n\n이제 위젯인 블로그 목록을 만들어봅시다. 이를 위해 블로그 목록이라는 슬라이스와 슬라이스 내에 ui라는 세그먼트를 생성합시다. 다음 명령어를 사용하여 이 작업을 수행할 수 있습니다:\n\n```js\nbit create react widgets/blog-list/ui\n```\n\n\n\n새로운 디렉토리가 추가된 것을 확인해야 합니다:\n\n![새 디렉토리 추가 사진](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_5.png)\n\nui.tsx 파일을 열고 아래 코드를 추가해주세요:\n\n```js\nimport React from 'react';\nimport { Blog } from '@dummyorg/fsd.entities.blog.model';\nimport { BlogItem } from '@dummyorg/fsd.entities.blog.ui.blog-item';\n\nexport type UiProps = {\n  blogs: Blog[]\n};\nexport function Ui({ blogs = [] }: UiProps) {\n  return blogs.map((blog) =\u003e (\u003cBlogItem\n    key={blog.id}\n    description={blog.description}\n    id={blog.id}\n    tags={blog.tags}\n    title={blog.title}\n  /\u003e))\n}\n```\n\n\n\n지역 서버로 이동하여 다음을 볼 수 있어요:\n\n![Developing Scalable Frontends with Feature-Sliced Design](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_6.png)\n\nBit Cloud에서 해당 구성 요소의 전체 구현을 살펴볼 수 있어요.\n\n# 4: 페이지 레이어 구축\n\n\n\n다음으로, 블로그 목록을 나타내는 페이지를 만들어 보겠습니다. 이를 위해 슬라이스인  blog-list와 세그먼트인 ui를 생성해봅시다. 다음 명령어를 실행하세요:\n\n```js\nbit create react pages/blog-list/ui\n```\n\n이 명령을 실행하면 다음과 같이 출력됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_7.png\" /\u003e\n\n\n\n다음으로 ui.tsx 파일을 열고 다음 스니펫을 포함하세요:\n\n```js\nimport React from 'react';\nimport { useGetBlogs } from '@dummyorg/fsd.features.get-blog-posts.model';\nimport { BlogList } from '@dummyorg/fsd.widgets.blog-list.ui';\n\nexport function Ui() {\n  const { blogs, loading } = useGetBlogs();\n  if (loading) {\n    return \u003cp\u003e\n      Posts are loading...\n    \u003c/p\u003e\n  }\n  return (\n    \u003cBlogList\n      blogs={blogs}\n    /\u003e\n  );\n}\n```\n\n로컬 서버에서 아래와 같은 출력이 표시됩니다:\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해드리겠습니다.\n\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_10.png\" /\u003e\n\n우리는 이렇게 페이지를 설정했어요! 자세히 알아보려면 Bit Cloud에서 확인해보세요.\n\n# 5: 앱 레이어 구축\n\n\n\n\n마지막으로, 이 모든 것을 사용하는 앱을 만들어봅시다. 다음 명령을 실행하세요:\n\n```js\nbit create react-app app\n```\n\n이렇게 하면 앱 컴포넌트가 생성되며 아래와 같이 결과가 생성됩니다:\n\n![Output](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_11.png)\n\n\n\n이 앱을 Bit 서버 외부에서 로드할 수 있도록하려면 다음 몤령을 실행하십시오:\n\n```js\nbit use app\n```\n\n앱이 로드 가능한지 확인하려면 다음 몤령을 실행하십시오:\n\n```js\nbit app list\n```\n\n\n\n만약 당신의 앱이 로드될 수 있다면, 아래 출력을 확인할 수 있어야 합니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_12.png\" /\u003e\n\n다음으로, 파일인 — app.tsx을 열고 다음 단락을 포함하세요:\n\n```js\nimport React from \"react\";\nimport { BlogListPage } from \"@dummyorg/fsd.pages.blog-list.ui\";\n\nexport function App() {\n  return \u003cBlogListPage /\u003e\n}\n```\n\n\n\n다음으로, 명령어를 실행하여 앱을 시작해보세요:\n\n```js\nbit run app\n```\n\n로컬호스트에서 앱이 시작되는 것을 확인할 수 있어요.\n\n앱의 전체 구현을 보려면 Bit Cloud에서 확인해보세요.\n\n\n\n# 마무리\n\n보셨듯이, Feature Sliced Design은 응용 프로그램을 명확하고 구조화된 방식으로 구성할 때 매우 유용합니다. 팀원들이 프로젝트를 빠르게 탐색하고 기능을 더 잘 이해할 수 있도록 돕습니다.\n\n만약 우리가 만든 앱을 살펴보고 싶다면, Bit Cloud에서 확인해보세요.\n\n본문이 도움이 되었기를 바랍니다. FSD를 직접 시도해보고, 이 패턴에 대한 생각을 저에게 알려주세요!\n\n\n\n감사합니다.\n\n## 더 알아보기","ogImage":{"url":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png","tag":["Tech"],"readingTime":10},{"title":"Nodejs 어플리케이션의 성능 최적화 기술","description":"","date":"2024-05-14 12:37","slug":"2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png\" /\u003e\n\n웹 애플리케이션을 구축할 때 성능이 중요합니다. 빠르고 신뢰할 수 있는 애플리케이션을 구축하여 사용자 경험을 향상시키는 것이 목표입니다. 반응이 빠른 앱은 사용자를 끌어들이고 보유율을 향상시킵니다. 그에 반해, 느린 애플리케이션은 사용자를 좌절시키고 포기로 이끌 수 있습니다.\n\n특히 Node.js로 백엔드 서비스를 구축하는 경우, 성능은 후술할 수 없습니다. Node.js는 빠른 속도로 알려져 있지만, 이것이 반드시 애플리케이션이 최적으로 작동할 것이라는 것을 보장하지는 않습니다. Node.js의 잠재력을 극대화하려면 의도적인 조치를 취해야 합니다.\n\n이 기사에서는 Node.js 애플리케이션의 성능을 개선하기 위한 다양한 기술과 모범 사례를 살펴보겠습니다.\n\n\n\n# 성능 최적화의 중요성\n\n성능 최적화는 언제나 애플리케이션의 속도를 향상시키는 것만을 의미하는 것은 아닙니다. 또한 메모리, CPU, 대역폭과 같은 자원을 낭비하지 않는 것에 관한 것입니다. 최적화되지 않은 앱은 자원을 낭비하고 더 많은 비용이 들어갑니다. 하드웨어 자원이 제한적인 상황에서 최적화를 통해 현재의 자원을 최대한 활용할 수 있습니다. 불필요한 업그레이드를 하지 않고 예산 이상으로 지출하는 일을 피할 수 있습니다.\n\n확장성 또한 중요합니다. 적절히 최적화된 앱은 문제 없이 동시 사용자들을 처리할 수 있습니다.\n\nNode.js의 논블로킹 스타일 때문에 최적화가 더욱 중요합니다. Node는 병렬 IO에 좋지만 CPU 집약적인 작업이 전체적으로 성능을 늦추는 일이 발생할 수 있습니다. 이벤트 루프가 원활하게 작동하도록 유지해야 합니다. 최적화되지 않은 코드는 성능 저하로 이어지며, 이는 불만족스러운 사용자, 높은 비용, 그리고 놓치는 기회로 이어질 수 있습니다. 적절한 최적화는 이러한 문제를 방지하고 애플리케이션이 효율적이고 수익성 있게 운영될 수 있도록 유지해줍니다.\n\n\n\n# 성능 최적화를 고려해야 하는 시점은 언제일까요?\n\nNode.js 앱을 구축할 때 항상 성능 최적화를 고려해야 합니다. 초기 계획부터 배포 이후까지 항상 염두에 둬야 합니다. 그럼에도 불구하고 성능 최적화에 실제로 노력을 기울여야 하는 특정 시점들이 있습니다:\n\n- 초기 개발: 디자인, 아키텍처, 알고리즘 및 접근 방식을 처음부터 올바르게 정하는 것은 나중에 큰 이익을 가져다 줍니다. 효율성, 확장성 및 유지보수성을 초기에 우선시하는 것이 성공의 열쇠가 됩니다.\n- 기술적 부채 해결: 앱이 성장하고 발전함에 따라 기술적 부채가 늘어납니다. 이를 방치하면 시간이 지남에 따라 성능을 제한할 수 있습니다. 정기적인 리팩터링, 최적화 작업 및 코드 정리를 통해 볼륨을 줄이는 것이 중요합니다.\n- 새로운 기능: 새로운 기능을 추가하는 것은 성능에 반드시 영향을 미칩니다. 새로운 기능을 출시하기 전에 전반적인 사용자 경험을 감소시키지 않도록 작업해야 합니다.\n- 배포 전: 배포하기 전에 실제로 앱이 실제 워크로드를 처리할 수 있는지 확인해야 합니다! 배포 전에 철저한 성능 테스트와 튜닝은 필수입니다.\n- 병목현상 대응: 개발, 테스트 또는 프로덕션 중에 느려짐이나 문제가 발생할 때마다 성능 병목 현상을 신속히 식별하고 최적화를 통해 해결해야 합니다.\n- 운영 비용 절감: 최적화가 잘 된 앱은 CPU, 메모리, 대역폭 및 기타 부분에 더 관대하여 실행 및 확장 비용이 적게 들게 됩니다. 비용을 고려하는 팀에게 큰 이점이 됩니다.\n- 부하 테스트: 모의 트래픽을 사용하여 부하 테스트를 진행하면 스케일링 제한, 과도한 부하를 견뎌야 하는 병목 현상 및 출시 전 최적화 기회를 발견할 수 있습니다.\n- 인프라 확장: 수요를 충족하기 위해 인프라가 성장함에 따라 최적화 전략도 가져가야 합니다. 확장을 위한 튜닝을 재방문하여 효율성을 확보해야 합니다.\n- 제한된 환경 자원: 엣지 장치, 임베디드 시스템 또는 다른 제한된 사용 사례의 경우, 제한된 자원을 극대화하기 위해 가혹한 최적화가 필요합니다.\n- 지속적인 유지보수: 최적화는 일회성 작업이 아닙니다. 데이터가 증가하고 사용 패턴이 변하며 새 코드가 시간이 지남에 따라 도입될 때 계속해서 검토하고 조정해야 합니다.\n- 프로덕션 모니터링: 마지막으로, 프로덕션 환경에서 항상 귀를 기울이세요! 사용자 불만이나 느려짐을 나타내는 메트릭이 있으면 즉시 조사하고 개선 작업을 시작해야 합니다.\n\n# Node.js 앱 최적화 기술\n\n\n\n지금 당신이 Node.js 앱의 성능 최적화를 우선시해야 하는 시기를 이해했군요. 이제 Node.js 애플리케이션에서 최대 성능을 뽑아내는 가장 효과적인 방법을 알아봅시다:\n\n# 코드 프로파일링\n\nNode.js 애플리케이션을 최적화하려면 먼저 어디서 성능 병목 현상을 일으킬 수 있는지 알아야 합니다. 프로파일링을 통해 이를 파악할 수 있습니다. 이를 통해 코드 중 어느 부분이 가장 많은 시간과 자원을 소비하고 있는지를 보여줍니다. 느린 부분을 알면 그 부분을 개선하는 데 집중할 수 있습니다. 현재 앱의 상태를 결정하기 위해 다음 테스트를 수행해야 할 수도 있습니다:\n\n부하 테스트: 이는 앱이 정상적이고 예상대로의 사용자량과 트래픽을 처리하는 방식을 확인합니다. 앱을 정기적으로 사용할 때 발생하는 느림 현상이나 문제점을 발견할 수 있습니다.\n\n\n\n스파이크 테스팅: 이는 앱에 갑작스럽게 많은 사용자나 활동을 던집니다. 일반 부하보다 많습니다. 수요가 예상치 못하게 증가했을 때 앱이 어떻게 반응하는지, 어떤 한계에 도달하는지 보여줍니다.\n\n스트레스 테스팅: 이 테스트는 부하를 점진적으로 늘려서 앱을 한계까지 밀어붙입니다. 앱이 고장 나기까지 처리할 수 있는 최대치를 보여줘, 앱의 약점이나 부족한 리소스를 식별할 수 있게 해 줍니다.\n\n확장성 테스팅: 이는 앱이 추가적인 리소스(서버 또는 메모리)를 추가함으로써 더 많은 사용자와 트래픽을 쉽게 처리할 수 있는지를 살펴 봅니다. 앱의 확장을 원할하게 막는 병목 현상이나 구조적 문제를 확인합니다.\n\n이 상기 중 일부 또는 전부의 테스트를 수행하는 것은 여러 중요한 측정 항목을 제공합니다.\n\n\n\n- 응답 시간\n- 평균 지연 시간\n- 오류율\n- 초당 요청 수\n- 처리량\n- CPU 및 메모리 사용량\n- 동시 접속 사용자\n\n그리고 더 많은 정보.\n\n# 네이티브 클러스터 모듈 또는 PM2를 사용하여 확장하기\n\nNode.js에는 멀티코어 시스템을 활용하고 부하를 여러 워커 프로세스로 분산시킬 수 있는 내장 클러스터 모듈이 함께 제공됩니다. 이를 통해 사용 가능한 모든 CPU 코어를 활용하여 응용 프로그램의 성능과 확장성을 향상시킬 수 있습니다. 여러 워커 프로세스 간에 부하를 분산시키는 방법을 살펴봅시다:\n\n\n\n```js\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);\n  for (let i = 0; i \u003c numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) =\u003e {\n    console.log(`워커 ${worker.process.pid}가 코드 ${code}와 시그널 ${signal}로 종료되었습니다`);\n    console.log('새로운 워커를 시작 중');\n    cluster.fork();\n  });\n} else {\n  http.createServer((req, res) =\u003e {\n    res.writeHead(200);\n    res.end('워커 프로세스에서 안녕하세요\\\\n');\n  }).listen(8000);\n  console.log(`워커 ${process.pid}가 시작되었습니다`);\n}\n```\n\n마스터 프로세스는 각 사용 가능한 CPU 코어에 대해 새로운 워커 프로세스를 포크합니다. 각 워커 프로세스는 포트 8000에서 수신하는 HTTP 요청을 처리합니다. 워커 프로세스가 충돌하면 마스터 프로세스가 알림을 받고 충돌한 프로세스를 대체하기 위해 새로운 워커를 생성합니다.\n\n대부분의 경우, 추가 기능을 제공하며 편의성을 제공하는 PM2 (Process Manager 2)를 사용하는 것이 좋습니다. 보일러플레이트를 작성할 필요가 없습니다.\n\nPM2를 사용하여 확장하기 위해서는 먼저 설치해야 합니다:\n\n\n\n\n```js\nnpm install pm2 --save-dev\n```\n\n설치가 완료되면 PM2를 사용하여 애플리케이션을 시작하고 클러스터링을 활성화할 수 있습니다:\n\n```js\npm2 start app.js -i max\n```\n\n-i max 플래그는 PM2가 사용 가능한 CPU 코어 수만큼 애플리케이션 인스턴스를 시작하도록 지시합니다. PM2는 자동으로 이러한 인스턴스 간에 들어오는 요청을 로드 밸런싱합니다.\n\n\n\n다음과 같이 수동으로 시작할 인스턴스 수를 지정할 수도 있습니다:\n\n```js\npm2 start app.js -i 4\n```\n\n당신의 어플리케이션의 인스턴스를 네 개 시작할 것입니다.\n\nPM2는 제로 다운타임 리로드, 모니터링, 로깅과 같은 부가 기능을 갖추고 있어서 프로덕션 환경에서 Node.js 어플리케이션을 관리하고 확장하는 인기 있는 도구입니다.\n\n\n\n# Gzip 압축 활용하기\n\nGzip 압축은 서버와 클라이언트 간에 전송되는 데이터 양을 현저히 줄여 더 빠른 응답 시간과 향상된 성능을 제공할 수 있습니다. 특히 HTML, CSS, JavaScript와 같은 대량의 텍스트 기반 콘텐츠를 제공하는 애플리케이션에 대해 유용합니다.\n\nNode.js에서는 compression이라는 라이브러리를 사용하여 Gzip 압축을 활성화할 수 있습니다. compression을 사용하려면 먼저 npm을 통해 설치하고 express 프로젝트에 가져와야 합니다:\n\ncompression 라이브러리 설치하기:\n\n\n\n```js\nnpm install compression\n```\n\n압축 라이브러리를 사용하는 방법:\n\n```js\nconst express = require('express');\nconst compression = require('compression');\nconst app = express();\n\n// Gzip 압축 활성화\napp.use(compression());\n\napp.use(express.static('public'));\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000 에서 실행 중입니다');\n});\n```\n\n이 미들웨어는 요청의 Accept-Encoding 헤더와 응답의 콘텐츠 유형에 따라 응답 데이터를 자동으로 압축합니다.\n\n\n\n텍스트 기반 콘텐츠를 제공할 때 Gzip을 사용하면 서버와 클라이언트 간 전송되는 데이터 양을 줄일 수 있어 더 빠른 응답 시간을 얻을 수 있어요.\n\n# 타임아웃 블로킹 I/O 작업 사용하기\n\nNode.js는 많은 연결을 동시에 처리할 수 있도록 설계되어 있어서 묶이는 작업을 피해야 합니다. 그러나 파일을 읽는 등 느린 I/O 작업이 막히게 되면 Node.js가 효율적으로 다른 작업을 수행하는 것을 막을 수 있어요. 이를 방지하기 위해 느린 I/O 작업에는 타임아웃을 사용하세요. 타임아웃은 작업이 완료되는 데 걸리는 최대 시간을 설정해줘요. 너무 오랜 시간이 걸리면 작업을 취소하거나 다른 모든 것을 막지 않고 처리할 수 있어요.\n\n파일을 읽을 때 타임아웃을 설정하는 것은 매우 간단해요:\n\n\n\n```js\nconst fs = require('fs');\n\n\nconst MAX_TIMEOUT = 5000;\nconst readFile = (filePath, callback) =\u003e {\n  fs.readFile(filePath, (err, data) =\u003e {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, data);\n  });\n};\n\nconst readFileWithTimeout = (filePath, callback) =\u003e {\n  const timeoutId = setTimeout(() =\u003e {\n    callback(new Error('파일 읽기 작업 시간 초과'));\n  }, MAX_TIMEOUT);\n  readFile(filePath, (err, data) =\u003e {\n    clearTimeout(timeoutId);\n    if (err) {\n      return callback(err);\n    }\n    callback(null, data);\n  });\n};\n```\n\nreadFileWithTimeout 함수는 setTimeout을 사용하여 5초 타임아웃을 설정합니다. fs.readFile 작업에 더 오랜 시간이 걸리면 타임아웃 콜백이 트리거되어 제공된 콜백에 오류를 전달합니다.\n\n만약 타임아웃 전에 readFile이 완료되면 clearTimeout이 타임아웃을 취소하고 파일 데이터를 콜백에 전달합니다.\n\n타임아웃 값은 앱의 요구 사항을 균형있게 유지해야 합니다. 너무 짧으면 합법적인 긴 작업을 자르는 위험이 있고, 너무 길면 타임아웃을 사용하는 목적을 상쇄시킬 수 있습니다.\n\n\n\n\n# I/O 작업에는 스트리밍을 사용하세요\n\n스트리밍은 대용량 파일, 네트워크 응답 또는 데이터가 전체가 메모리로 로드되기를 기다리는 대신 도착하는 즉시 처리해야 하는 시나리오와 같이 데이터를 처리해야 하는 경우에 매우 유용합니다. 특히 대량의 데이터를 다루는 I/O 작업을 최적화할 때 Node.js 애플리케이션에 대한 강력한 기술 중 하나입니다.\n\n만약 수백만 개의 행이 있는 멀티 기가바이트 CSV 파일을 읽어야 한다고 가정해 봅시다. 스트림을 사용하여 데이터를 작은 조각 단위로 처리할 수 있습니다. 어떤 말인지 확인해 볼까요:\n\n```js\nconst fs = require('fs');\nconst stream = require('stream');\nconst csvParser = require('csv-parser');\n\nconst csvStream = fs.createReadStream('bigdata.csv')\n  .pipe(csvParser());\n\nconst writableStream = new stream.Writable({\n  write(chunk, encoding, next) {\n    console.log('CSV 데이터 청크를 받았습니다:', chunk);\n    next();\n  }\n});\n\ncsvStream.pipe(writableStream);\n\nwritableStream.on('error', (err) =\u003e {\n  console.error('에러 발생:', err);\n});\n\nwritableStream.on('finish', () =\u003e {\n  console.log('CSV 데이터 처리 완료.');\n});\n```\n\n\n\n가독성 있는 csvStream은 CSV 데이터를 작성 가능한 스트림으로 물 흐르듯이 전달합니다. write 메서드는 전체 CSV 파일이 메모리에 로드되기를 기다리지 않고 각 청크가 도착할 때마다 처리합니다.\n\n스트리밍은 메모리 블로트를 방지하고 대용량 CSV 파일과 같은 I/O 집중적 작업의 성능을 향상시킵니다. 메모리에 완전히 로드하는 것이 현실적이지 않거나 대용량 API 응답인 대규모 데이터 집합을 처리해야 하는 모든 시나리오에 이상적입니다.\n\n# 종속성 최소화\n\n의존성은 유용한 기능을 제공하고 작업 흐름을 가속화할 수 있지만, 너무 많은 종속성을 갖거나 오래된 또는 불필요한 종속성을 사용하는 것은 때로 응용 프로그램의 성능에 부정적으로 영향을 미칠 수 있습니다.\n\n\n\n자바스크립트 애플리케이션에서 종속성을 최소화하는 방법을 살펴봐요:\n\n- 검토하고 사용하지 않는 종속성 제거: 프로젝트의 종속성을 주기적으로 검토하고 사용되지 않거나 불필요한 패키지를 제거해요. npm-prune이나 depcheck과 같은 도구를 사용하여 사용되지 않는 종속성을 식별하고 제거할 수 있어요.\n\n```js\nnpm install -g npm-prune\n```\n\nprune 명령어를 실행하여 사용되지 않는 종속성을 제거하세요.\n\n\n\n```js\nnpm prune\n```\n\n- 정기적으로 의존성 업그레이드: 최신 안정 버전으로 정기적으로 업그레이드하여 의존성을 최신 상태로 유지하세요. 오래된 의존성은 보안 위험을 가져올 수 있고 버그를 발생시킬 수 있으며 성능 향상을 놓칠 수 있습니다. npm-check-updates나 npm outdated와 같은 도구를 사용하여 사용 가능한 업데이트를 확인할 수 있습니다.\n\n패키지 설치\n\n```js\nnpm install -g npm-check-updates\n```\n\n\n\n업데이트 가능한 내용을 확인해보세요:\n\n```bash\nnpm-check-updates\n```\n\n의존성 패키지를 업데이트하세요:\n\n```bash\nnpm-check-updates -u\nnpm install\n```\n\n\n\n- 번들러와 트리 쉐이킹 활용: Webpack이나 Rollup과 같은 모듈 번들러를 사용하여 트리 쉐이킹을 수행할 수 있습니다. 이는 응용 프로그램과 의존성에서 사용되지 않는 코드를 제거하는 프로세스로, 최종 번들 크기를 크게 줄이고 성능을 향상시킬 수 있습니다.\n- 작은 및 특정한 종속성 선호: 종속성을 선택할 때, 필요한 기능만 제공하는 작고 집중된 패키지를 선택하는 것이 좋습니다. 사용하지 않는 기능이 많은 대규모의 모놀리틱 라이브러리보다 낫습니다.\n- 사용자 정의 코드 작성 고려: 경우에 따라, 필요한 기능이 상대적으로 간단하거나 응용 프로그램에 특정한 경우에는 의존성에 의존하는 대신 사용자 정의 코드를 작성하는데 가치가 있을 수 있습니다.\n\n# 부하 분산\n\nNode.js 응용 프로그램이 성장하고 더 많은 트래픽을 처리할 때, 성능과 가용성을 유지하기 위해 해당 부하를 여러 서버에 분산해야 합니다. 여기서 부하 분산이 유용하게 사용됩니다. 부하 분산은 들어오는 요청을 여러 서버 그룹에 분산하여 어떤 서버가 과부하가 걸리지 않도록 합니다. 다음과 같은 소프트웨어 솔루션을 사용할 수 있습니다:\n\n- Nginx 또는 HAProxy\n- 클라우드 부하 분산 서비스 (AWS ELB, Google Cloud Load Balancing 등)\n\n\n\n효과적인 로드 밸런싱은 작업 부하를 공유하여 성능을 향상시킵니다. 또한 장애 허용성을 강화합니다. 한 대의 서버가 실패하면 트래픽이 건강한 서버로 리디렉션되어 가용성을 유지합니다.\n\nNode.js는 백엔드 서비스를 구축하는 데 훌륭한 도구입니다. 그러나 정적 파일을 제공하는 데 최적화되어 있지 않아 이 작업을 수행할 때 성능 병목 현상을 겪을 수 있습니다. Nginx를 사용하여 Node.js 응용 프로그램의 정적 자산을 제공하는 반대 프록시로 사용할 수 있습니다. 이렇게하면 Node.js 앱이 동적 요청과 응용 프로그램 논리를 처리하고 있는 동안 Nginx가 정적 파일 제공 능력을 최적화하여 성능과 확장성을 향상시킵니다.\n\n# CPU 집약적 작업 외부로 이전하기\n\n\n\nNode는 한 번에 여러 I/O 작업을 처리하는 데 능숙합니다. 그러나 숫자 처리나 미디어 처리와 같은 무거운 CPU 작업에 대해선 싱글 스레드로 구성되어 있어 성능이 떨어질 수 있습니다. 이 CPU 집약적인 작업은 모든 것을 늦추고 지연을 초래할 수 있습니다.\n\n해결책은 CPU 집약적인 작업을 별도의 프로세스나 서비스로 오프로드하는 것입니다. 이렇게 하면 주요 Node 프로세스가 일반 I/O 작업을 위해 재빠르게 유지됩니다.\n\n다음과 같은 것들을 사용할 수 있습니다:\n\n- 여러 코어에 병렬로 CPU 작업을 실행하기 위한 자식 프로세스\n- Node 내에서 별도의 스레드에서 CPU 작업을 실행하기 위한 워커 스레드\n- 클라이언트 측 CPU 스크립팅을 위해 백그라운드 스레드에서 사용되는 웹 워커\n- 코드를 클라우드에서 실행하기 위한 AWS Lambda와 같은 서버리스 함수\n- 이미지 처리와 같은 CPU 집약적인 작업을 위해 설계된 외부 API\n\n\n\n숫자를 계산하는 부분을 분리함으로써 Node의 단일 스레드를 너무 많이 사용하지 않도록 할 수 있어요. 앱은 기존에 좋은 성능을 보여주던 정상적인 네트워킹 및 I/O 작업에 반응하면서 원활하게 작동할 거에요. CPU도 다른 부분에서 충분히 활용할 수 있게 되죠.\n\n# 최신 Node.js 버전 사용하기\n\nNode.js는 적극적으로 개발 및 유지보수되는 프로젝트로, 새로운 기능, 성능 향상 및 버그 수정이 소개되는 빈도 높은 릴리스들을 발표하고 있어요. 구 버전의 Node.js를 사용하면 성능 문제, 보안 취약점 및 최신 라이브러리 및 프레임워크와의 호환성 문제가 발생할 수 있어요. 새로운 Node.js 릴리스는 V8 JavaScript 엔진에 대한 최적화와 개선 사항이 포함되어 있어 실행 시간 및 전체 성능을 향상시킬 수 있어요.\n\nNode.js를 업그레이드하려면 Node.js 공식 웹사이트에서 최신 버전을 다운로드하거나 nvm과 같은 버전 관리자를 사용할 수 있어요. 이 도구를 사용하면 다양한 Node.js 버전을 쉽게 설치하고 전환할 수 있어요.\n\n\n\n만약 이미 컴퓨터에 nvm이 설치되어 있다면, 최신 Node.js 버전을 쉽게 설치할 수 있어요.\n\n아래 명령어를 실행하여 사용 가능한 Node.js 버전을 확인할 수 있어요:\n\n```js\nnvm ls-remote\n```\n\n최신 Node.js 버전을 설치하세요:\n\n\n\n```js\nnvm install \u003cnodejs 버전\u003e\n```\n\n가장 최근에 설치된 버전을 사용하려면:\n\n```js\nnvm use \u003cnodejs 버전\u003e\n```\n\n호환성 문제로 인해 다른 Node.js 버전 간을 전환하려면 동일한 nvm use 명령을 사용할 수 있습니다. 즉, Node.js 버전을 최신 상태로 유지하여 응용 프로그램이 최신 성능 향상을 누리는 것이 좋습니다.\n\n\n\n## 마무리\n\n성능 최적화는 Node.js 애플리케이션의 전체 개발 수명 주기 동안 내재화되어야 하는 지속적인 반복 프로세스입니다. 구현할 최적화 기술을 선택하기 전에 각 전략을 귀하의 특정 응용 프로그램 요구 사항, 인프라 및 성능 목표에 대해 평가해보세요.\n\n해피 해킹!","ogImage":{"url":"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png"},"coverImage":"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png","tag":["Tech"],"readingTime":12},{"title":"앵귤러 172에서의 Material 3 실험적 지원","description":"","date":"2024-05-14 12:36","slug":"2024-05-14-Material3ExperimentalSupportinAngular172","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png\" /\u003e\n\n안녕하세요! Angular 17.2에서는 Angular Material에서 Material 3 테마를 실험적으로 지원한다는 기쁜 소식을 전합니다.\n\n본 블로그 포스트에서는 이 기능에 대한 최신 소식을 업데이트하고 Material 3 지원에 대한 미리보기를 제공할 예정입니다.\n\n# Material 3이란 무엇인가요?\n\n\n\nMaterial 3는 Material Design의 최신 진화 버전으로, 구글의 오픈 소스 디자인 시스템입니다. Angular용 Material 3는 대체 테마로 구현되어 있으며, 현재 사용 중인 Angular Material 구성 요소와 Sass 믹스인과 호환됩니다.\n\nMaterial 3 테마는 디자인 토큰을 기반으로 하며(CSS 사용자 정의 속성으로 구현됨), CSS 선택기 특이성을 증가시키지 않고도 테마를 더 쉽게 재정의할 수 있게 합니다. 이는 내부 Angular Material 요소에 CSS 선택기를 지정할 필요 없이 특정 속성을 세밀하게 재정의할 수 있도록 합니다.\n\n# 애플리케이션에서 Material 3 사용하기\n\n앱에서 Material 3를 사용하려면, matx.define-theme을 사용하여 Sass에서 M3 테마를 생성하고 현재 사용 중인 Angular Material Sass 믹스인에 전달하면 됩니다.\n\n\n\n```scss\n@use '@angular/material' as mat;\n@use '@angular/material-experimental' as matx;\n\n$m3-dark-theme: matx.define-theme((\n  color: (\n    theme-type: dark,\n    primary: matx.$m3-indigo-palette,\n    tertiary: matx.$m3-blue-palette,\n  )\n));\n\n$m3-light-theme: matx.define-theme((\n  color: (\n    primary: matx.$m3-indigo-palette,\n    tertiary: matx.$m3-blue-palette,\n    )\n));\n\n.dark-theme {\n  @include mat.all-component-themes($m3-dark-theme);\n}\n\n.light-theme {\n  @include mat.all-component-themes($m3-light-theme);\n}\n```\n\nM3 테마는 CSS 사용자 정의 속성을 기반으로 하므로, 테마, 색상, 타이포그래피, 밀도 믹스인은 모두 추가 선택기 가중치 없이 CSS 사용자 정의 속성만 출력됨이 보장됩니다. 이는 최상위 수준에서 사용자 정의 속성을 정의하고 해당 속성이 필요한 구성 요소로 흐르게 할 수 있음을 의미합니다. Sass에서 `.dark-theme` 및 `.light-theme`의 순서와 상관없이 다음 레이아웃들이 예상대로 작동합니다.\n\n```html\n\u003cbody class=\"light-theme\"\u003e\n  Light theme\n  \u003csidenav class=\"dark-theme\"\u003eWith a dark sidenav!\u003c/sidenav\u003e\n\u003c/body\u003e\n```\n\n```html\n\u003cbody class=\"dark-theme\"\u003e\n  Dark theme\n  \u003csidenav class=\"light-theme\"\u003eWith a light sidenav!\u003c/sidenav\u003e\n\u003c/body\u003e\n```\n\n\n\nSass API 이상의 세밀한 사용자 정의는 CSS 사용자 지정 속성을 직접 설정하여 가능합니다. 예를 들어, 사용자가 특히 주의해야 할 체크박스를 강조하려는 경우:\n\n```js\n\u003cmat-checkbox class=\"scary-setting\"\u003e내 계정 삭제\u003c/mat-checkbox\u003e\n```\n\n```js\n.scary-setting {\n  // 내부 체크박스 선택기를 대상으로할 필요가 없어요! 🎉\n  - mdc-checkbox-unselected-hover-state-layer-color: red;\n  - mdc-checkbox-unselected-hover-icon-color: red;\n}\n```\n\n공식 Sass 믹스인과 마찬가지로, 이러한 속성은 사용되는 곳으로 흘러내려가기 때문에, 전체 부분이 무서운 체크박스가 있는 경우 해당 클래스를 모두에 적용할 필요가 없습니다. 이러한 사용자 정의가 적용되어야 하는 가장 높은 수준 요소에만 적용하면 됩니다.\n\n\n\n```js\n\u003csection class=\"scary-setting\"\u003e\n  \u003cmat-checkbox\u003e내 계정 삭제하기\u003c/mat-checkbox\u003e\n  \u003cmat-checkbox\u003e내 은행 계좌 비우기\u003c/mat-checkbox\u003e\n\u003c/section\u003e\n```\n\n# Material 2 지원\n\n매우 기쁘게도 Material 3를 소개할 수 있어 흥분되고 있으며, Material 2 테마는 완전히 지원됩니다.\n\nM2와 M3 테마를 처리하는 방식에는 몇 가지 차이가 있습니다. 특히 컴포넌트 색상 변형과 관련된 점이 주목할 만합니다. Material 3 사용 가이드에서 이러한 차이에 대해 자세히 알아볼 수 있습니다.\n\n\n\n# 지금 시작하세요\n\n앵귤러 커뮤니티 여러분께 이번 업데이트 소식을 전하게 되어 너무 흥분되고 기쁩니다. 여러분의 피드백을 손꼽아 기다리고 있어요 — 이 게시물에 댓글을 남겨 의겢을 나눠주세요. Material 3 가이드로 이 기능을 오늘 바로 시도해볼 수 있어요. 우리는 안정적인 상태로 업그레이드하기 위해 사용자 정의 색상 팔레트 생성, 시스템 수준 토큰을 위한 CSS 변수, 그리고 API 개선에 계속해서 노력할 예정입니다.\n\n읽어주셔서 감사합니다. [전송 종료]","ogImage":{"url":"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png"},"coverImage":"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png","tag":["Tech"],"readingTime":3},{"title":"Vue 34의 State에 대한 개념 모델","description":"","date":"2024-05-14 12:33","slug":"2024-05-14-AConceptualModelofStateinVue34","content":"\n\n상태와 컴포넌트 경계의 배치를 이해하는 것은 현대 프론트엔드 웹 개발에서 가장 중요한 도전 중 하나이며, 어플리케이션의 규모가 커짐에 따라 개발을 가속화하거나 가장 큰 마찰 원인이 될 수 있는 팀이 내릴 수 있는 가장 중요한 결정 중 하나입니다.\n\n올바르게 수행하면 프론트엔드 컴포넌트의 구축, 구성, 리팩토링 및 테스트가 간단해집니다. 잘못 수행하면 코드베이스를 부서지기 쉽게 만들며 추적하기 어려운 유령 버그의 끝없는 근원이 될 수 있습니다.\n\nVue의 3.4 릴리스로 실험적인 상태에서 벗어나 정식 출시된 defineModel 마크로는 아마도 서로 다른 컴포넌트 간의 복잡한 상태 상호작용을 어떻게 생각하고 구현해야 하는지를 형성하는 방식에 대해 팀이 생각하는 방식을 바꿀 수 있는 가장 혁신적인 기능 중 하나일지도 모릅니다.\n\n이 설명은 꽤 무해한 것처럼 보입니다:\n\n\n\n표면적으로 보면, 이 매크로의 유용성은 미묘해 보일 수 있지만, 팀이 상태에 대해 생각하고 컴포넌트 경계를 관리하는 방식에 깊은 영향을 미칩니다. defineModel이 무엇을 하는지 알아보고 Vue 3.4에 추가된 것이 얼마나 패러다임 변화처럼 느껴지는지 살펴보겠습니다 — 비록 그것이 단순한 매크로일 뿐이라도요.\n\n# 상태에 대한 개념적 모델\n\n일반적으로, 현대 프론트엔드 애플리케이션을 생각할 때 상태에는 3가지 범위가 있습니다 (창 수준의 진정으로 전역 상태를 제외한 경우).\n\n![Conceptual Model of State](/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png)\n\n\n\n- 전역, 공유 상태. 이는 전체 계층 구조 내에서 여러 컴포넌트에서 액세스할 수 있는 상태로, 로그인한 사용자 계정 정보 및 경로 간에 공유되는 정보와 같이 실제로 글로벌 상태에 해당합니다.\n- 계층 구조 형태의 컴포넌트 상태. 이는 계층 구조의 하위 트리 내에서 여러 컴포넌트에서 액세스할 수 있는 상태입니다. 예시로는 목록-상세 편집기 뷰가 있습니다.\n- 단일 컴포넌트 레벨 상태. 이는 계층 구조 내의 단일 컴포넌트 내에서만 액세스할 수 있는 상태로, 상태 상호 작용이 트리를 올라가거나 내려가지 않아도 되는 컴포넌트의 경계 내에서 유지됩니다.\n\n글로벌 수준에서 이를 해결하기 위한 많은 라이브러리와 솔루션이 있습니다. 예를 들어, React의 Zustand, Jotai, Recoil, Redux (그 외 다른 라이브러리 및 프레임워크) 및 Vue의 Pinia는 컴포넌트 트리 내부에서 상태를 전역 범위로 끌어내어 트리를 가로질러 이동할 수 있도록 도와줍니다. 이러한 용도로 light/dark 모드나 테넌트 ID와 같은 실제로 전역 상태를 유지하는 것이 목적입니다.\n\n이 두 번째 상태 레이어에서, 팀이 마주치는 'prop drilling' 마찰이 발생합니다 — React, Vue 또는 다른 라이브러리나 프레임워크에서 발생하는 것일 수 있습니다. 그 중 일부는 수많은 상태를 컴포넌트 간에 상하로 이동하는 것을 관리하기 번거로운 점입니다.\n\n이 경우 팀이 자연스럽게 내리는 결정을 하는 것은 상태를 전역 스토어로 옮겨놓는 것이거나, 상태를 이동하는 대신 세 번째 컴포넌트 범위로 빠져 이 마찰을 피하고 단순히 하나의 거대한 컴포넌트에 계속 쌓는 것입니다 — 이로써 다른 종류의 고통이 생기게 됩니다.\n\n\n\n상태를 prop 트리거링 없이 쉽게 분리할 수 있다면 얼마나 좋을까요? Vue의 반응형 양방향 바인딩을 유지하면서 컴포넌트 간 상태를 이동하는 데 생기는 마찰과 고통을 크게 줄여줄 수 있는 defineModel이 나타납니다.\n\n# defineModel이란?\n\n먼저 무엇인지와 무엇을 하는지를 이해하는 것이 중요합니다. Vue에 익숙하지 않은 사용자들을 위해 컴포넌트 간으로 상태를 옮기는 유행적인 방식은 props와 emits를 사용했습니다.\n\n## defineModel 이전 - props와 emits\n\n\n\n예를 들어, 부모-자식 구성 요소를 고려해 봅시다:\n\n![이미지](/assets/img/2024-05-14-AConceptualModelofStateinVue34_1.png)\n\n양방향 바인딩을 위해 내부 NameInput.vue 컴포넌트를 다음과 같이 만들어야 합니다:\n\n```js\n\u003c!-- NameInput.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"NameInput.vue\"\u003e\n    \u003c!-- 👇 이 곳에 input을 바인딩합니다 --\u003e\n    \u003cinput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\n// 👇 프롭으로 들어옴\nconst props = defineProps\u003c{\n  modelValue: string\n}\u003e()\n\n// 👇 업데이트를 부모에게 emit\nconst emits = defineEmits\u003c{\n  'update:modelValue': [string]\n}\u003e()\n\n// 👇 연결하기 위한 writable 컴퓨티드\nconst name = computed({\n  get() {\n    return props.modelValue\n  },\n  set(val) {\n    emits('update:modelValue', val)\n  }\n})\n\u003c/script\u003e\n``` \n\n\n\n밖에 있는 예시1.vue 컴포넌트는 다음과 같습니다:\n\n```js\n\u003c!-- 예시1.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"예시1.vue\"\u003e\n    \u003ch1\u003e예시 1\u003c/h1\u003e\n    \u003cp\u003e안녕하세요, { name.length === 0 ? \"(아래에 이름을 입력하세요)\" : name }\u003c/p\u003e\n    \u003c!-- 👇 여기가 우리 컴포넌트입니다 --\u003e\n    \u003cNameInput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst name = ref('')\n\u003c/script\u003e\r\n```\n\n이제 텍스트 상자에 값을 입력하면 이 값이 prop의 값으로 자동으로 업데이트됩니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1358/0*f_imWYDRjdKfO_RA.gif\" /\u003e\n\n\n\n이렇게 간단한 것을 위한 보일러플레이트가 얼마나 지루해질 수 있는지 쉽게 알 수 있어요!\n\n## defineModel 이후 ✨\n\nVue 3.4에서 defineModel이 출시되면, 이것이 NameInput.vue를 어떻게 간단하게 만드는지 살펴봐요:\n\n```js\n\u003c!-- NameInput.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"NameInput.vue\"\u003e\n    \u003cinput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\n  // 🎉 한 줄로 끝!\nconst name = defineModel\u003cstring\u003e({ required: true })\n\u003c/script\u003e\r\n```\n\n\n\n## 탁상 속에서 이 변경은 상당히 사소해 보일지 모릅니다. 편의성이 약간 향상되긴 했지만, 개발자가 상태를 관리하는 방식에 이것이 어떻게 실제로 영향을 미치는 걸까요? 그저 간단한 매크로인데 이렇게 주장하는 건 너무나 황당한 일이 아닌가요?\n\n실제로 개발자들은 가급적 쉬운 길을 택하려고 합니다. 그리고 그 쉬운 길이 나쁜 관행 중 하나인 경우, 그렇다면 개발자들은 많은 많은 나쁜 관행을 갖춘 코드베이스를 만들어냅니다 — 일명 \"기술 부채(Tech Debt)\"라고도 불리는 것이죠. 1000줄 이상의 React나 Vue 컴포넌트를 보았다면(누구나 그런 경험이 있으시죠?), 그 이유는 컴포넌트가 유기적으로 성장함에 따라 상태를 관리하기 괴로워져서 새 컴포넌트를 분리하는 것보다 동일한 상태를 계속 공유하는 게 더 쉬웠기 때문이라고 할 수 있습니다.\n\n\n\n`defineModel`가 하는 일은 최소한의 저항력 경로를 만들어주는 동시에 팀이 상태에 대해 어떻게 생각할 수 있는 방법을 개선하는 데 도움이 되는 것입니다. 갑자기 계층적 컴포넌트 상태를 관리하는 중간 지점이 미미하게 쉬워지고 상태를 전역 범위로 옮기거나 대형 컴포넌트를 작은 구성 요소로 분해하기를 꺼린다는 유혹을 없애주어 상태를 오르내리는 게 골치 아프다는 것을 없애줍니다 (보통 1000줄 이상 컴포넌트가 생기는 방법).\n\n## 계층적 상태를 단순화하기 위해 defineModel 사용하기\n\n다음과 같은 간단한 연락처 관리 앱을 고려해보세요:\n\n![contact management app](/assets/img/2024-05-14-AConceptualModelofStateinVue34_2.png)\n\n\n\n이 예제에서 계층구조를 주의해서 보시기 바랍니다. 사용자가 Listing.vue에서 연락처를 선택하면 앱은 Details.vue에 세부 정보를 보여주어야 합니다. 사용자가 Details.vue에서 세부 정보를 편집하고 변경 사항을 저장하면 앱은 Listing.vue의 항목을 업데이트해야 합니다.\n\nListing.vue와 Details.vue 간에 상태를 공유하려면 전역 상태이거나 공통 부모 Example3.vue에서 시작하는 계층 상태 여야 합니다. 그렇지 않으면 한 거대한 컴포넌트에 모든 것을 모으려는 유혹이 큽니다!\n\n이 경우에는 우리의 계층구조 상태가 다음과 같습니다:\n\n![상태 개념 모델](/assets/img/2024-05-14-AConceptualModelofStateinVue34_3.png)\n\n\n\n바깥쪽부터 코드를 살펴봐봅시다.\n\n여기에는 부모 컴포넌트인 Example3.vue가 있습니다:\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Example3.vue\"\u003e\n    \u003ch1\u003eExample 3\u003c/h1\u003e\n\n    \u003cp v-if=\"!!selectedContact\"\u003e\n      선택된: { selectedContact.name } ({ selectedContact.handle })\n    \u003c/p\u003e\n\n    \u003cdiv class=\"parent\"\u003e\n      \u003c!-- 👈 왼쪽 가지 --\u003e\n      \u003cListing\n        v-model=\"contacts\"\n        v-model:selected=\"selectedContact\"/\u003e\n\n      \u003c!-- 👉 오른쪽 가지 --\u003e\n      \u003cDetails v-model=\"selectedContact\"/\u003e\n    \u003c/div\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selectedContact = ref\u003cContact\u003e()\n\nconst contacts = ref\u003cContact[]\u003e([{\n  name: 'Charles',\n  handle: '@chrlschn'\n}])\n\u003c/script\u003e\r\n```\n\n이것은 우리의 상태가 살고 있는 루트이며, Listing 및 Details 컴포넌트로 바인딩을 통해 전달됩니다.\n\n\n\n```js\n\u003c!-- Example3.vue에서 스니펫입니다--\u003e\n\u003cListing\n  v-model=\"contacts\"\n  v-model:selected=\"selectedContact\"/\u003e\n\n\u003cDetails v-model=\"selectedContact\"/\u003e\n```\n\n먼저 Details.vue 파일을 살펴봅시다:\n\n```js\n\u003c!-- Details.vue, 오른쪽 폼 입력란 --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Details.vue\"\u003e\n    \u003cdiv v-if=\"!!selected\"\u003e\n      \u003c!-- 사용자 이름 입력 --\u003e\n      \u003clabel\u003e\n        이름\n        \u003cinput v-model=\"name\"/\u003e\n      \u003c/label\u003e\n\n      \u003c!-- 사용자 핸들 입력 --\u003e\n      \u003clabel\u003e\n        핸들\n        \u003cinput v-model=\"handle\"/\u003e\n      \u003c/label\u003e\n\n      \u003c!-- 작업 버튼 --\u003e\n      \u003cdiv\u003e\n        \u003cbutton @click=\"handleCancel\"\u003e완료\u003c/button\u003e\n        \u003cbutton @click=\"handleDone\"\u003e저장\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cp v-else\u003e\n      연락처를 선택하세요\n    \u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selected = defineModel\u003cContact|undefined\u003e({\n  required: true\n})\n\nconst name = ref('')\n\nconst handle = ref('')\n\n// 선택된 값이 업데이트되면 로컬 사본을 업데이트합니다.\nwatch (selected, (contact) =\u003e {\n  if (!contact) {\n    return\n  }\n\n  name.value = contact.name,\n  handle.value = contact.handle\n})\n\n// 변경 내용을 취소하면 모든 것을 되돌립니다.\nfunction handleCancel() {\n  selected.value = undefined\n}\n\n// 변경 사항이 저장되면 선택한 객체를 업데이트합니다.\nfunction handleDone() {\n  if (!selected.value) {\n    return\n  }\n\n  selected.value.name = name.value;\n  selected.value.handle = handle.value;\n}\n\u003c/script\u003e\r\n```\n\n이 컴포넌트는 연락처 세부 정보의 사본을 얻는 state 집합을 가지고 작성되었습니다. 선택된 연락처가 변경되면 컴포넌트가 값들을 로컬 상태로 복사하여 사용자가 저장할 때 까지 상태(이름과 핸들)를 변경할 수 있게 합니다. 이로써 사용자는 편집을 취소할 수도 있습니다.\n\n\n\n(속성 집합이 큰 경우에는 개체의 완전한 반응형 사본을 만들고 직접 바인딩하는 것을 고려하십시오.)\n\n왼쪽에 있는 Listing.vue 컴포넌트에는 연락처 목록이 포함되어 있으며 새 연락처를 추가할 수 있는 옵션이 있습니다.\n\n```js\n\u003c!-- Listing.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Listing.vue\"\u003e\n    \u003cdiv class=\"container\"\u003e\n      \u003cContactItem\n        v-for=\"contact in contacts\"\n        :contact=\"contact\"\n        :selected=\"selected == contact\"\n        @click=\"selected = contact\"\u003e\n      \u003c/ContactItem\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n      \u003cbutton @click=\"handleAddContact\"\u003e Add contact \u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst contacts = defineModel\u003cContact[]\u003e({\n  required: true\n})\n\nconst selected = defineModel\u003cContact|undefined\u003e('selected', {\n  required: true\n})\n\nfunction handleAddContact() {\n  contacts.value.push({\n    name: '이름',\n    handle: '핸들'\n  })\n}\n\u003c/script\u003e\r\n```\n\n그런 다음 ContactItem.vue에서는 변형이 없으므로 (그리고 양방향 바인딩이 필요하지 않으므로) Listing.vue가 표시 값을 바로 전달합니다:\n\n\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer\n    label=\"Contact.vue\"\n    class=\"contact\"\n    :class=\"{\n      'selected': !!selected\n    }\"\u003e\n    \u003cp class=\"name\"\u003e{ contact.name }\u003c/p\u003e\n    \u003cp class=\"handle\"\u003e{ contact.handle }\u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\ndefineProps\u003c{\n  contact: Contact,\n  selected?: boolean\n}\u003e()\n\u003c/script\u003e\r\n```\n\n이것이 어떻게 모두 함께 작동하는지 봅시다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*EfFxU6oa6uYyKIFA.gif\" /\u003e\n\n간편하게 상호 작용을 단순화하도록 도와주는 defineModel 없이는 여러 emit 및 computed를 작성하는 것이 마찬가지로 이 작은 예시에서도 어느 정도의 마찰을 초래할 수 있기 때문에 바로 전역 상태로 이동하거나 단축키를 사용하는 것이 직관적으로 느껴질 수 있습니다!\n\n\n\n빌리 미즈가 말할 것 같이, \"그러나 기다려! 더 있어요!\"; 이 코드를 이해하기 쉽고 관리하기 쉽도록 만드는 더 많은 방법을 살펴보겠습니다.\n\n## Composables를 사용하여 defineModel\n\nComposables를 활용하면 상태를 컴포넌트에서 분리함으로써 코드를 더욱 간단하고 이해하기 쉽게 만들 수 있습니다. 컴포넌트가 커지면 특히 유용합니다.\n\nVue에서는 이를 쉽게 수행할 수 있으며 리팩토링 및 복잡성 재구성을 간편하게 수행할 수 있습니다.\n\n\n\n우리는 간단히 상태와 함수를 컴포넌트에서 끌어올려서 다른 함수로 넣어주기만 하면 됩니다:\n\n```js\n// useContacts 컴포저블\nexport function useContacts() {\n  const selectedContact = ref\u003cContact\u003e()\n\n  const contacts = ref\u003cContact[]\u003e([{\n    name: 'Charles',\n    handle: '@chrlschn'\n  }])\n\n  function addContact() {\n    contacts.value.push({\n      name: '이름',\n      handle: '핸들'\n    })\n  }\n\n  return {\n    selectedContact,\n    contacts,\n    addContact\n  }\n}\n```\n\n예를 들어, Details.vue에서 논리와 상태를 더 많이 가져와서 다른 컴포저블에 넣고 싶다면, 예를 들어 이름, 핸들 참조값들과 handleCancel() 및 handleDone() 함수들을 또 다른 컴포저블로 옮기고 공유하는 것은 매우 적은 마찰력을 가질 것입니다.:\n\n```js\n// useDetailsEditor.ts\n\n// 👇 선택된 연락처를 받아서 반응형으로 사용하는 방법\n// 여기서는 관찰할 수 있습니다.\nexport function useDetailsEditor(\n  selectedContact: Ref\u003cContact|undefined\u003e\n) {\n  const name = ref('')\n\n  const handle = ref('')\n\n  // 👇 여기서 selectedContact를 관찰하여\n  // 캡슐화된 상태를 업데이트합니다.\n  watch (selectedContact, (contact) =\u003e {\n    if (!contact) {\n      return\n    }\n\n    name.value = contact.name,\n    handle.value = contact.handle\n  })\n\n  function cancel() {\n    selectedContact.value = undefined\n  }\n\n  function done() {\n    if (!selectedContact.value) {\n      return\n    }\n\n    selectedContact.value.name = name.value;\n    selectedContact.value.handle = handle.value;\n  }\n\n  return {\n    name,\n    handle,\n    cancel,\n    done\n  }\n}\n```\n\n\n\n그리고 Details.vue를 업데이트합니다:\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Details.vue\"\u003e\n    \u003cdiv v-if=\"!!selected\"\u003e\n      \u003cdiv\u003e\n        \u003clabel\u003e\n          이름\n          \u003cinput v-model=\"name\"/\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n\n      \u003cdiv\u003e\n        \u003clabel\u003e\n          핸들\n          \u003cinput v-model=\"handle\"/\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n\n      \u003cdiv\u003e\n        \u003cbutton @click=\"cancel\"\u003e완료\u003c/button\u003e\n        \u003cbutton @click=\"done\"\u003e저장\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cp v-else\u003e\n      연락처를 선택하세요\n    \u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selected = defineModel\u003cContact|undefined\u003e({\n  required: true\n})\n\nconst {\n  name,\n  handle,\n  cancel,\n  done\n} = useDetailsEditor(selected)\n// 👆 여기에서 선택한 연락처를 사용하여 \n// composable에서 감시할 수 있도록 전달합니다\n\u003c/script\u003e\r\n```\n\nVue 3 콤포저블과 Vue 3.4의 defineModel 매크로를 사용하여 관련 상태 및 로직을 깔끔하게 분리하고 캡슐화하는 데 아주 효과적입니다. 이 패턴을 통해 코드를 이 패턴에 맞게 리팩토링하는 것이 얼마나 쉬운지 보여줍니다. 단순히 상태, 함수, 감시자 및 계산된 값을 전부 복사하여 컴포저블에 붙여넣으면 됩니다.\n\n이 패턴을 사용하면 대규모 하위 컴포넌트 트리도 쉽게 관리, 리팩토링 및 테스트할 수 있습니다.\n\n\n\n# 마무리\n\nVue 3.4의 defineModel 소개는 실은 팀이 최상의 방법을 따르고 더 나은, 더 관리 가능한 컴포넌트를 구축하는 데 도움을 줄 것입니다. 계층 형태의 상태를 구성하는 데 드는 많은 마찰을 제거함으로써 팀이 전역 상태에 바로 의존하거나 엉성한 방법을 사용할 가능성을 줄여줍니다.\n\ndefineModel을 Vue 컴포저블과 결합하면 팀이 관련 있는 상태와 로직을 체계적으로 구성하고 캡슐화하여 읽기 쉬운 컴포넌트를 만들 수 있습니다.\n\nEvan You가 Vue 3를 위해 Composition API를 처음 제안했을 때, Options API의 간단함과 접근성을 유지하고 싶어했던 커뮤니티로부터 많은 걱정과 항의가 있었습니다. 그러나 회고적으로 볼 때, Vue를 대규모 프로젝트를 구축하는 팀에 더 나아가게 도와줄 Evan You의 방향이 옳았다는 것을 분명히 알 수 있습니다.\n\n\n\n3.4버전으로 인해 비전이 더욱 완성됐다는 느낌을 받을 수 있어요. 상태 관리를 간소하고 명확하게 만들어서 종종 복잡한 과정에서 어디에 상태를 배치해야 하는지에 대한 결정을 명확하게 도와줍니다. defineModel은 작은 돌처럼 느껴집니다. 바다에 떨어뜨려진 작은 돌이 언젠가 대형파가 될 것 같은 기분이에요!\n\n이 글을 작성하도록 영감을 준 Lefan에게 특별히 감사드려요.","ogImage":{"url":"/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png"},"coverImage":"/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png","tag":["Tech"],"readingTime":12},{"title":"미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1","description":"","date":"2024-05-14 12:32","slug":"2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1","content":"\n\n![이미지](/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png)\n\n자바스크립트는 다양하고 동적인 언어로, 웹에 상호작용성과 기능을 추가하는 능력으로 웹을 채웁니다. 그러나 확장성과 인기 속에서 특정 측면은 \"이상한 부분\"으로 불릴 수 있습니다. 이것들은 개발자들을 종종 당혹케 하는 특이성과 기이함입니다. 특히 이 언어를 처음 사용하는 사람들에게 도움이 됩니다. 이러한 기이함을 이해하면 자바스크립트에 대한 깊은 이해를 가지게 되며 더 견고하고 효율적인 코드를 작성할 수 있는 도구가 됩니다. 이 흥미로운 이야기를 풀어내고 자바스크립트의 이상한 부분을 해소해봅시다.\n\n# 형 강제 변환:\n\n자바스크립트는 동적으로 타입이 지정되는 언어로, 변수는 모든 데이터 유형의 값을 보유할 수 있습니다. 이 유연성은 강력하지만, 유형 강제 변환으로 인해 예기치 않은 동작이 발생할 수 있습니다. 예를 들어, 덧셈 연산자(+)는 피연산자의 유형에 따라 다르게 작동합니다. 피연산자 중 하나가 문자열이면 문자열을 연결하고, 그렇지 않은 경우에는 덧셈을 수행합니다. 이러한 암묵적인 유형 변환을 이해하면 버그를 방지하고 코드 가독성을 향상시킬 수 있습니다.\n\n\n\n```js\nconsole.log(1 + \"2\"); // \"12\"\nconsole.log(1 + 2);   // 3\n```\n\n형 변환이 일부 경우에 유용할 수 있지만, 잠재적인 문제점에 대해 알고 있어야 합니다.\n\n```js\nconsole.log(1\u003c2\u003c3); // true\nconsole.log(3\u003c2\u003c1) ; // true \n// (이유: 3\u003c2=false이므로 false\u003c1이 되고, Number(false)=0 이므로, 0\u003c1= true)\n```\n\n# 프로토타입 상속:\n\n\n\n프로토타입 상속은 자바스크립트의 기본 개념 중 하나로, 객체가 다른 객체로부터 속성과 메서드를 상속하는 방식을 관리합니다. 자바나 C++과 같은 언어에서 볼 수 있는 고전적 상속과는 달리, 자바스크립트의 상속 모델은 프로토타입을 기반으로 하며 객체 지향 프로그래밍에 더 동적이고 유연한 접근법을 제공합니다.\n\n프로토타입 이해하기:\n\n자바스크립트에서 모든 객체는 프로토타입을 가집니다. 프로토타입은 단순히 다른 객체가 속성을 상속하는 객체입니다. 객체의 속성이나 메서드에 접근할 때, JavaScript는 먼저 해당 객체에서 직접 찾습니다. 찾지 못하면 프로토타입 체인을 따라 상위로 올라가 속성을 찾거나 체인의 끝에 도달할 때까지 계속합니다(프로토타입이 null일 때).\n\n```js\nconst person = {\n    firstName: 'John',\n    lastName: 'Doe',\n    fullName: function() {\n        return this.firstName + ' ' + this.lastName;\n    }\n};\n\nconst employee = {\n    position: 'Developer'\n};\n\nemployee.__proto__ = person; // employee의 프로토타입을 person으로 설정\n\nconsole.log(employee.fullName()); // \"John Doe\"\nconsole.log(employee.position);   // \"Developer\"\n```\n\n\n\n위의 예시에서 직원은 원형(person)에서 fullName 메서드를 상속받습니다. 직원.fullName()이 호출되면 JavaScript는 직원에게 fullName 속성을 찾아보고, 찾지 못하면 원형 체인을 따라가 원형에 있는 fullName을 찾습니다.\n\n생성자를 이용한 프로토타입 상속:\n\n생성자와 프로토타입은 종종 함께 사용되어 JavaScript에서 상속을 구현하는 데 사용됩니다. 공유 속성과 메서드를 가진 객체를 만드는 템플릿으로 사용될 생성자 함수를 만들 수 있습니다.\n\n```js\nfunction Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nPerson.prototype.fullName = function() {\n    return this.firstName + ' ' + this.lastName;\n};\n\nfunction Employee(firstName, lastName, position) {\n    Person.call(this, firstName, lastName); // Person 생성자 호출\n    this.position = position;\n}\n\nEmployee.prototype = Object.create(Person.prototype); // Person의 프로토타입에서 상속\nEmployee.prototype.constructor = Employee; // 생성자 재설정\n\nconst johnDoe = new Employee('John', 'Doe', 'Developer');\nconsole.log(johnDoe.fullName()); // \"John Doe\"\nconsole.log(johnDoe.position);   // \"Developer\"\n```\n\n\n\n이 예시에서, Employee 생성자는 Person으로부터 속성과 메서드를 상속받기 위해 그 프로토타입을 Person.prototype의 인스턴스로 설정합니다.\n\nObject.create() 메서드:\n\nObject.create() 메서드는 지정된 프로토타입을 가진 객체를 생성하는 또 다른 방법을 제공합니다.\n\n```js\nconst person = {\n    firstName: 'John',\n    lastName: 'Doe',\n    fullName: function() {\n        return this.firstName + ' ' + this.lastName;\n    }\n};\n\nconst employee = Object.create(person);\nemployee.position = 'Developer';\n\nconsole.log(employee.fullName()); // \"John Doe\"\nconsole.log(employee.position);   // \"Developer\"\n```\n\n\n\n# 스코핑과 클로저:\n\n스코핑과 클로저를 이해하는 것은 깔끔하고 효율적인 JavaScript 코드를 작성하는 데 매우 중요합니다. JavaScript는 함수 수준의 스코프를 가지고 있어 변수들이 선언된 함수 내에서만 유효합니다. 반면에 클로저는 외부 함수의 실행이 완료된 후에도 해당 범위 변수에 대한 접근 권한을 유지할 수 있도록 합니다.\n\n## 스코핑:\n\n스코프란 변수가 선언되고 액세스되는 컨텍스트를 의미합니다. JavaScript에서는 전역 스코프와 지역 스코프 두 가지 주요 유형의 스코프가 있습니다.\n\n\n\n글로벌 스코프: 어떤 함수 안에서도 선언되지 않은 변수들은 전역 스코프에 있게 되며 전체 스크립트 어디에서나 접근할 수 있어요.\n\n```js\nconst globalVar = '나는 글로벌';\n\nfunction foo() {\n    console.log(globalVar); // \"나는 글로벌\"\n}\n\nfoo();\n```\n\n로컬 스코프: 함수 안에서 선언된 변수들은 로컬 스코프에 있어서 해당 함수 내에서만 접근이 가능해요.\n\n```js\nfunction foo() {\n    const localVar = '나는 로컬';\n    console.log(localVar);\n}\n\nfoo(); // \"나는 로컬\"\nconsole.log(localVar); // 에러: localVar가 정의되지 않았어요\n```\n\n\n\n블록 범위: ES6에서 도입된 let 및 const를 사용하여 선언된 변수는 블록 범위로 지정되어 있습니다. 즉, 정의된 블록 내에서만 액세스할 수 있습니다.\n\n```js\nfunction foo() {\n    if (true) {\n        const localVar = '저는 블록 안에 있어요';\n        console.log(localVar);\n    }\n    console.log(localVar); // 에러: localVar가 정의되지 않았습니다\n}\n\nfoo();\n```\n\n## 클로저:\n\n클로저란 함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다. 이를 통해 함수는 외부 함수의 실행이 완료된 후에도 포함하는 범위의 변수에 액세스할 수 있습니다. 다시 말해, 클로저는 내부 함수에서 외부 함수의 범위에 액세스할 수 있게 해줍니다.\n\n\n\n```js\nfunction outer() {\n    const outerVar = 'I am from the outside';\n    \n    function inner() {\n        console.log(outerVar); // The inner function has access to outerVar\n    }\n    \n    return inner;\n}\n\nconst innerFunc = outer();\ninnerFunc(); // \"I am from the outside\"\n```\n\n이 예제에서 inner 함수는 outer 함수를 감싼 클로저를 형성하여 outerVar에 대한 액세스 권한을 유지합니다. outer 함수의 실행이 완료된 후에도 계속 사용할 수 있습니다.\n\n클로저의 일부 사용 사례:\n\n캡슐화: 클로저를 사용하여 비공개 변수를 캡슐화하고 모듈을 생성하여 구현 세부 정보를 숨기고 필요한 기능만 노출시킬 수 있습니다.\n\n\n\n```js\nfunction counter() {\n    let count = 0;\n\n    return {\n        increment: function() {\n            count++;\n        },\n        getCount: function() {\n            return count;\n        }\n    };\n}\n\nconst counterObj = counter();\ncounterObj.increment();\nconsole.log(counterObj.getCount()); // 1\n```\n\n함수 팩토리: 클로저를 사용하면 주변 범위에 따라 특정 동작을 하는 다른 함수를 생성하는 함수를 만들 수 있습니다.\n\n```js\nfunction multiplier(factor) {\n    return function(x) {\n        return x * factor;\n    };\n}\n\nconst double = multiplier(2);\nconsole.log(double(5)); // 10\n```\n\n이벤트 핸들러: 클로저는 이벤트 핸들러에서 널리 사용되며, 이벤트의 컨텍스트와 관련된 변수에 계속 액세스할 수 있도록 합니다.\n\n\n\n```js\nfunction setupCounter() {\n    let count = 0;\n    document.getElementById('btn').addEventListener('click', function() {\n        count++;\n        console.log(count);\n    });\n}\n\nsetupCounter();\n```\n\n# 결론:\n\n이 게시물에서는 JavaScript의 중요한 몇 가지 개념에 대해 다루고 소개했습니다. JavaScript의 이상한 부분들은 처음에는 어렵게 보일 수 있지만, 이를 마스터하는 것은 능숙한 JavaScript 개발자가 되는 데 필수적입니다. 타입 강제 변환, 프로토타입 상속, 스코핑, 클로저를 이해하여 더 예측 가능하고 효율적이며 유지보수 가능한 코드를 작성할 수 있습니다. JavaScript의 별난 점들을 받아들이고, 그것들은 더 이상 장애물이 아닌 코딩 여정에서 사용할 도구로 바뀝니다.\n\n아래 댓글란에 피드백을 주시면 감사하겠습니다.\n\n\n\n\n참고 자료:\n1. [Understanding JavaScript](https://www.udemy.com/course/understand-javascript/)\n   \n2. [Mozilla Developer Network](https://developer.mozilla.org/)","ogImage":{"url":"/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png"},"coverImage":"/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular Routes반쯤 타입 지정하는 간단한 꿀팁","description":"","date":"2024-05-14 12:31","slug":"2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped","content":"\n\n\n![Simple Trick To Make Your Angular Routes Semi-Typed](/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png)\n\n링크나 버튼 요소의 [routerLink] 지시문이 하드 코딩된 값을 입력받는 프로젝트를 많이 본 적이 있습니다. 예를 들어:\n\n```js\n\u003ca [routerLink]=\"['/movies', movie.id, 'edit']\"\u003e 영화 편집 \u003c/a\u003e\n```\n\n만약 언젠가 movie를 film으로, edit을 update로 변경하고 싶을 때 링크가 깨지는 경우가 발생할 수 있습니다. 그래서 저는 이에 대한 일종의 방어선으로 작동하는 작은 꼼수를 고안해보았습니다.\n\n\n\n\n## 단계 1: 라우트 정의하기\n\n우리가 몇 개의 인증 관련 라우트들 중 일부를 가지고 있다고 가정해봅시다. auth.routes.ts 파일을 만들고 먼저 타입 또는 인터페이스를 생성할 것입니다:\n\n```js\nexport type AuthRoutes = {\n    login: Route\n    register: Route\n    verifyEmail: Route\n}\n```\n\n이제 인터페이스에 따라 라우트를 선언해보겠습니다:\n\n\n\n```js\nexport const authRoutes: AuthRoutes = {\n    login: {\n        path: 'login',\n        loadComponent: () =\u003e import('./login.component')\n            .then((m) =\u003e m.LoginComponent),\n    },\n    register: {\n        path: 'register',\n        loadComponent: () =\u003e import('./register.component')\n            .then((m) =\u003e RegisterComponent),\n    },\n    verifyEmail: {\n        path: 'verify-email/:token',\n        loadComponent: () =\u003e import('./verify-email.component')\n            .then((m) =\u003e m.VerifyEmailComponent),\n    },\n}\n```\n\n동일한 방식으로, 편의에 맞게 다른 세분화된 route 파일을 만들어보세요.\n\n```js\nexport type MovieRoutes = {\n    movieByActor: Route\n}\n\nexport const movieRoutes: MovieRoutes = {\n    movieByActor: {\n        path: 'dashboard/actors/:actorId/movies/:movieId',\n        loadComponent: import('./movie-details.component')\n            .then(m =\u003e m.MovieDetailsComponent),\n    }\n}\n```\n\n또한 not-found-page.route.ts에 다음과 같은 캐치-올 route를 만들어봅시다:\n\n\n\n```js\nexport type NotFoundPageRoutes = {\n    index: Route\n}\n\nexport const notFoundPageRoutes: NotFoundPageRoutes = {\n    index: {\n        path: '**',\n        loadComponent: () =\u003e import('./not-found.page'),\n    },\n}\n```\n\n## 스텝 2: 라우트 등록하기\n\n앱 라우트 파일인 app.routes.ts로 돌아가거나 애플리케이션 라우트를 정의한 곳으로 이동하세요. 모든 그룹화된 라우트를 여기로 가져와주세요:\n\n```js\ntype GroupedRoutes = [\n    HomeRoutes,\n    AuthRoutes,\n    MovieRoutes,\n    // 모든 것을 수용하는 라우트는 마지막에 위치해야 합니다\n    NotFoundPageRoutes,\n]\n\nconst groupedRoutes: GroupedRoutes = [\n    homeRoutes,\n    authRoutes,\n    movieRoutes,\n    notFoundPageRoutes,\n]\n```\n\n\n\n우리의 루트는 객체 안에 있기 때문에 펼쳐주어야 해요:\n\n```js\nconst flattenedRoutes: Route[] = []\nfor (const routeGroup of groupedRoutes) {\n    for (const route of Object.values(routeGroup)) {\n        flattenedRoutes.push(route)\n    }\n}\n\nexport const AppRoutes = flattenedRoutes\n```\n\n앱 설정에 라우트를 등록해주세요 (일반적으로 app.config.ts 또는 main.ts 파일에 위치합니다):\n\n```js\nimport { ApplicationConfig, importProvidersFrom } from '@angular/core'\n// ... 다른 import들\n\nexport const appConfig: ApplicationConfig = {\n    providers: [\n        // ... 다른 프로바이더들\n        provideRouter(\n\n        \tAppRoutes, // \u003c-- 여기에 펼쳐진 라우트를 import 해요\n\n        ),\n    ],\n}\n```\n\n\n\n## 단계 3: 사용하기\n\n이 시점에서 우리의 솔루션이 준비되었습니다. 테스트 컴포넌트에서의 사용 예시:\n\n```js\nimport { authRoutes, AuthRoutes } from 'src/pages/auth/auth.routes.ts';\n\n@Component({\n    selector: 'app-test',\n    standalone: true,\n    imports: [CommonModule, RouterModule],\n    template: `\n      \u003ca\n        routerLink=\"{ '/' + authRoutes.login.path }\"\n      \u003e\n        로그인\n      \u003c/a\u003e\n          \n      \u003ca \n        routerLink=\"{ '/' + authRoutes.register.path }\"\n      \u003e\n        회원 가입\n      \u003c/a\u003e\n  \n      \u003c!-- 경로 매개 변수 대체 --\u003e\n      \u003ca \n        routerLink=\"{ \n          '/' + authRoutes.verifyEmail.path.replace(':token', token) \n        }\"\u003e\n          이메일 확인\n      \u003c/a\u003e\n\n      \u003c!-- 컨트롤러 클래스 내에서 사용 --\u003e\n      \u003cbutton (click)=\"goToMoviesHome()\"\u003e\n        내 대시보드\n      \u003c/button\u003e\n      \n      \u003cbutton (click)=\"goToMovie(actorId, movieId)\"\u003e\n        영화 상세 정보 보기\n      \u003c/button\u003e\n    `,\n    styleUrl: './test.component.scss',\n})\nexport class TestComponent {\n    readonly authRoutes: AuthRoutes = authRoutes\n    \n    token = 'abcd1234'\n    movieId = '2'\n    actorId = '1'\n    \n    goToMoviesHome() {\n      this.router.navigateByUrl('/' + this.movieRoutes.index.path)\n    }\n\n    goToMovie(actorId: string, movieId: string) {\n      this.router.navigateByUrl('/' + \n        this.movieRoutes.movieByActor\n          .replace(':actorId', this.actorId)\n          .replace(':movieId', this.movieId)\n      )\n    }\n}\n```\n\n이제 경로가 원치 않는 링크 차단에 대한 정도로 더 안전합니다. 한 곳에서 경로 값을 변경하면 모든 링크가 그에 맞게 업데이트됩니다.\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 반드시 글쓴이를 클랩하고 팔로우해 주세요 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png"},"coverImage":"/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png","tag":["Tech"],"readingTime":5},{"title":"Nodejs는 단일 스레드인가요","description":"","date":"2024-05-14 12:29","slug":"2024-05-14-IsNodejssingle-threaded","content":"\n\n\n![Node.js](/assets/img/2024-05-14-IsNodejssingle-threaded_0.png)\n\n아마도 노드.제이에스(Node.js)는 싱글 스레드, 비동기 런타임 환경이라고 들어봤을 것입니다. 그러나 이는 완전히 사실이 아닙니다. JavaScript 환경 자체는 하나의 스레드에서 실행되지만, 노드.제이에스 아키텍처에서 Libuv라는 중요한 구성 요소가 또 있습니다.\n\n## Libuv란?\n\nLibuv는 논 블로킹 I/O 작업을 추상화하기 위해 노드.제이에스를 위해 원래 작성된 C 라이브러리입니다.\n\n\n\n\n## Libuv를 신경 써야 하는 이유\n\nNode.js에서 Libuv를 이해하는 것이 중요한 이유는 Libuv가 비동기 I/O 기능을 제공하여 높은 동시성 및 I/O 바운드 작업을 효율적으로 처리하여 응답성과 확장성을 보장하기 때문입니다.\n\n이 게시물에서는 Libuv의 주요 기능 중 하나인 스레드 풀에 대해 더 자세히 살펴보겠습니다.\n\n## Libuv의 스레드 풀이란 무엇인가요?\n\n\n\nLibuv는 파일 시스템 및 DNS 작업과 같이 이벤트 루프를 차단할 수 있는 일부 I/O 작업을 오프로드하기 위해 작업자 스레드 풀을 사용합니다. 스레드 풀을 통해 이러한 작업이 주 이벤트 루프를 차단하지 않고 비동기적으로 수행되어 Node.js가 반응적이고 효율적으로 유지되도록합니다.\n\n## Libuv의 스레드 풀에서 무슨 일이 벌어질까요?\n\n태스크는 이벤트 루프에서 스레드 풀로 전달되며, 주로 두 가지 유형으로 분류됩니다:\n\n- I/O 집중적인\n\n\n\n- DNS: dns.lookup(), dns.lookupService(). \n- 파일 시스템: fs.FSWatcher()을 제외한 모든 파일 시스템 API\n\n2. CPU 집약적\n\n- Crypto: crypto.pbkdf2(), crypto.scrypt(), crypto.randomBytes(), crypto.randomFill(), crypto.generateKeyPair(). \n- Zlib: 명시적으로 동기화되지 않는 모든 zlib API는 libuv의 스레드 풀을 사용합니다.\n\n*C++ 애드온도 스레드 풀을 사용할 수 있습니다.\n\n\n\n기본 쓰레드 수는 4입니다. 위에서 언급한 작업들을 많이 의존한다면 UV_THREADPOOL_SIZE를 늘리거나 쓰레드 풀에 대한 경합을 피하기 위해 이러한 함수들을 사용하지 않는 것이 좋습니다.\n\n## 결론\n\nNode.js가 종종 완전히 싱글 스레드로 오해되는 반면, Libuv와 그 쓰레드 풀의 역할을 이해하면 좀 더 세밀한 그림이 드러납니다. Node.js는 Libuv의 기능을 활용하여 I/O와 CPU 집약적 작업을 효율적으로 처리합니다.","ogImage":{"url":"/assets/img/2024-05-14-IsNodejssingle-threaded_0.png"},"coverImage":"/assets/img/2024-05-14-IsNodejssingle-threaded_0.png","tag":["Tech"],"readingTime":2}],"page":"112","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"112"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>