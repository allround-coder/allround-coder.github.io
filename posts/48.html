<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트를 위한 전문 성능 향상 팁" href="/post/2024-05-14-ExpertPerformanceTipsforREACT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트를 위한 전문 성능 향상 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트를 위한 전문 성능 향상 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트를 위한 전문 성능 향상 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" href="/post/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="워커 스레드 NodeJS에서의 멀티태스킹" href="/post/2024-05-13-WorkerThreadsMultitaskinginNodeJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="워커 스레드 NodeJS에서의 멀티태스킹" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="워커 스레드 NodeJS에서의 멀티태스킹" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">워커 스레드 NodeJS에서의 멀티태스킹</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" href="/post/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" href="/post/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" href="/post/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시계열 데이터에서의 이상치 탐지와 ChatGPT" href="/post/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시계열 데이터에서의 이상치 탐지와 ChatGPT" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시계열 데이터에서의 이상치 탐지와 ChatGPT" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시계열 데이터에서의 이상치 탐지와 ChatGPT</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" href="/post/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러를 배우는 데 얼마나 비싼가요" href="/post/2024-05-13-HowExpensiveItIstoLearnAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러를 배우는 데 얼마나 비싼가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러를 배우는 데 얼마나 비싼가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러를 배우는 데 얼마나 비싼가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 프로세스와 스레드 이해하기" href="/post/2024-05-13-UnderstandingProcessesandThreadsinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 프로세스와 스레드 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 프로세스와 스레드 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 프로세스와 스레드 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트를 위한 전문 성능 향상 팁","description":"","date":"2024-05-14 10:11","slug":"2024-05-14-ExpertPerformanceTipsforREACT","content":"\n\n![Expert Performance Tips for REACT](/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png)\n\n웹 사이트의 성능은 사용자 경험, 검색 엔진 순위, 전환율, 비용 효율성, 경쟁 우위 및 접근성에 직접적인 영향을 미치기 때문에 중요합니다. 빠른 로딩 속도의 웹 사이트는 사용자 만족도를 높이고 이탈률을 낮추며 SEO 순위를 향상시킵니다. 또한 높은 전환율, 낮은 운영 비용 및 시장에서의 경쟁 우위를 가져다줍니다. 또한 최적화된 성능은 다양한 인터넷 연결과 장치를 사용하는 사용자를 대상으로하여 포용력을 보장합니다. 전반적으로 성능 최적화를 우선시함으로써 비즈니스 목표 달성과 웹 사이트 방문자에게 가치를 전달하는 것이 중요합니다.\n\n## 1. 비용이 많이 드는 계산에 useMemo 사용하기:\n\nReact 애플리케이션에서 데이터 변환과 같은 계산이 많이 드는 작업을 다룰 때 useMemo 훅을 사용하는 것이 중요합니다. 이를 통해 비용이 많이 드는 계산 결과를 기억하도록 할 수 있으며, 필요할 때만 다시 계산되도록 보장합니다. 종속성을 지정함으로써 언제 계산을 다시해야 하는지 제어하여 성능을 최적화할 수 있습니다.\n\n\n\n```js\nimport React, { useMemo } from 'react';\n\nconst MyComponent = ({ data }) =\u003e {\n  const transformedData = useMemo(() =\u003e {\n    // 여기에서 비싼 데이터 변환 수행\n    return data.map(item =\u003e item * 2);\n  }, [data]);\n  return (\n    \u003cdiv\u003e\n      {/* 변환된 데이터 사용 */}\n    \u003c/div\u003e\n  );\n};\n```\n\n## 2. 메모이제이션된 함수에 useCallback 사용하기:\n\nProps로 전달된 콜백 함수는 메모이제이션되지 않으면 불필요한 다시 렌더링을 유발할 수 있습니다. useCallback 훅을 활용하여 이러한 함수를 메모이제이션함으로써 종속성이 변경될 때까지 자식 구성요소의 다시 렌더링을 방지할 수 있습니다. 이 최적화는 불필요한 렌더링 주기를 줄이며 애플리케이션의 반응성을 향상시킵니다.\n\n```js\nimport React, { useCallback } from 'react';\n\nconst ParentComponent = () =\u003e {\n  const handleButtonClick = useCallback(() =\u003e {\n    // 여기에서 버튼 클릭 처리\n  }, []);\n  return (\n    \u003cChildComponent onClick={handleButtonClick} /\u003e\n  );\n};\n```\n\n\n\n## 3. React.memo를 사용하여 성능 최적화하기:\n\nReact.memo 고차 컴포넌트를 사용하여 함수형 컴포넌트를 최적화할 수 있습니다. 이를 통해 컴포넌트를 기억하고, props가 변경되지 않은 경우 다시 렌더링되지 않습니다. 이 최적화는 특히 정적 props를 받는 컴포넌트의 렌더링 성능을 최적화하는 데 유용합니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = React.memo(({ prop1, prop2 }) =\u003e {\n  // 컴포넌트를 여기에 렌더링\n});\n```\n\n## 4. 효율적인 렌더링을 위한 가상 목록 사용하기:\n\n\n\n긴 데이터 목록을 렌더링하면 성능에 부정적인 영향을 미칠 수 있습니다. React-window나 react-virtualized와 같은 가상 목록 라이브러리는 화면에 보이는 항목만 렌더링하여 DOM 조작을 최소화하고 렌더링 성능을 획기적으로 향상시킴으로써 이 문제를 해결합니다.\n\n```js\nimport React from 'react';\nimport { FixedSizeList } from 'react-window';\n\nconst MyListComponent = ({ data }) =\u003e {\n  const renderRow = ({ index, style }) =\u003e {\n    const item = data[index];\n    return (\n      \u003cdiv style={style}\u003e{item}\u003c/div\u003e\n    );\n  };\n  return (\n    \u003cFixedSizeList\n      height={300}\n      width={300}\n      itemSize={50}\n      itemCount={data.length}\n    \u003e\n      {renderRow}\n    \u003c/FixedSizeList\u003e\n  );\n};\n```\n\n## 5. 지연로딩을 위한 코드 분할 사용하기:\n\n코드를 작은 관리 가능한 조각으로 분할하고 동적으로 가져오기와 React lazy와 Suspense 구성 요소를 사용하여 지연 시간을 최적화하는 것은 초기 로드 시간을 최적화하는 데 중요합니다. 필요할 때만 필요한 코드를로드함으로써 응용 프로그램의 인지 성능을 향상시킬 수 있습니다.\n\n\n\n```js\nimport React, { lazy, Suspense } from 'react';\n\nconst LazyComponent = lazy(() =\u003e import('./LazyComponent'));\nconst App = () =\u003e {\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cLazyComponent /\u003e\n    \u003c/Suspense\u003e\n  );\n};\n```\n\n## 6. React.Fragment를 사용하여 렌더링 최적화:\n\n컨테이너 없이 여러 요소를 렌더링할 때 React.Fragment 또는 그 간략한 구문을 사용하면 추가적인 DOM 노드를 생성하지 않게 됩니다. 이 최적화는 DOM을 가볍게 유지하여 렌더링 성능을 향상시키는 데 도움이 됩니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cdiv\u003eElement 1\u003c/div\u003e\n      \u003cdiv\u003eElement 2\u003c/div\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n\n\n## 7. 인라인 함수 정의를 피하세요:\n\n렌더 메소드 내에서 함수를 인라인으로 정의하면 각 렌더링마다 새로운 참조를 생성하여 자식 컴포넌트가 불필요하게 다시 렌더링될 수 있습니다. 이러한 함수를 렌더 메소드 외부로 추출하거나 useCallback을 사용하여 메모이제이션함으로써 렌더링 성능을 최적화할 수 있습니다.\n\n```js\nimport React, { useState } from 'react';\n\nconst MyComponent = () =\u003e {\n  const [count, setCount] = useState(0);\n  const handleIncrement = () =\u003e {\n    setCount(count + 1);\n  };\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={handleIncrement}\u003e증가\u003c/button\u003e\n      \u003cp\u003e카운트: {count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n## 8. 성능 최적화를 위해 React.PureComponent 또는 React.memo를 사용하세요:\n\n\n\nReact.PureComponent 또는 React.memo를 활용하면 깊은 계층의 prop 비교를 수행하여 컴포넌트의 불필요한 다시 렌더링을 방지하는 데 도움이 됩니다. 이 최적화는 특히 클래스 컴포넌트 (PureComponent)와 함수형 컴포넌트 (React.memo로 메모이제이션된)에서 유용하며, prop 비교를 통해 렌더링 오버헤드를 크게 줄일 수 있습니다.\n\n```js\nimport React, { PureComponent } from 'react';\n\nclass MyComponent extends PureComponent {\n  render() {\n    // 여기서 컴포넌트 렌더링하기\n  }\n}\nexport default MyComponent;\n```\n\n## 9. 컴포넌트 프로파일링:\n\nReact DevTools와 같은 React의 내장 프로파일링 도구를 사용하여 컴포넌트에서 성능 병목 현상을 식별하세요. 프로파일링을 통해 불필요한 다시 렌더링이나 비효율적인 상태 관리와 같은 최적화가 필요한 부분을 파악할 수 있습니다.\n\n\n\n## 10. 트리 조정 최적화:\n\n컴포넌트 트리의 깊이를 최소화하고 복잡한 컴포넌트를 작고 관리하기 쉬운 부분으로 나누어 불필요한 렌더링을 피하세요. 이렇게 하면 업데이트 중에 조정해야 할 컴포넌트의 수를 줄여 성능을 향상시킬 수 있습니다.\n\n## 11. 불변 데이터 구조:\n\n불변 데이터 구조인 Immutable.js나 Immer와 같은 것을 사용하여 상태 관리를 최적화하세요. 불변 데이터를 사용하면 상태 변경을 비교하고 컴포넌트를 언제 업데이트해야 하는지 결정하는 것이 더 쉽습니다. 이렇게 하면 더 효율적인 렌더링과 성능 향상이 가능합니다.\n\n\n\n```js\nimport { Map } from 'immutable';\n\nconst initialState = Map({\n  counter: 0,\n  data: Map({}),\n});\n\n// 상태 업데이트\nconst newState = state.update('counter', counter =\u003e counter + 1);\n```\n\n## 12. 서버 측 렌더링 (SSR):\n\n서버 측 렌더링을 구현하여 React 컴포넌트를 서버에서 사전 렌더링하고 정적 HTML을 클라이언트에 제공하십시오. SSR은 초기 로드 시간을 줄이고 검색 엔진 크롤러가 콘텐츠를 효과적으로 색인화할 수 있도록 함으로써 지각된 성능을 향상시킵니다.\n\n## 13. Route-Based Splitting을 사용한 코드 분할:\n\n\n\n페이지 또는 라우트마다 필요한 JavaScript만로드하기 위해 라우트 기반 코드 분할을 구현하세요. 이 기술은 필요할 때 비동기적으로 코드를 로드하여 초기 번들 크기를 줄이고로드 시간을 개선합니다.\n\n```js\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst Home = lazy(() =\u003e import('./Home'));\nconst About = lazy(() =\u003e import('./About'));\n\nconst App = () =\u003e {\n  return (\n    \u003cRouter\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cSwitch\u003e\n          \u003cRoute exact path=\"/\" component={Home} /\u003e\n          \u003cRoute path=\"/about\" component={About} /\u003e\n        \u003c/Switch\u003e\n      \u003c/Suspense\u003e\n    \u003c/Router\u003e\n  );\n};\n\nexport default App;\n```\n\n## 14. 디바운싱과 스로틀링:\n\nAPI 요청이나 이벤트 핸들러와 같은 비용이 많이 드는 작업의 빈도를 제한하기 위해 디바운싱과 스로틀링 기술을 사용하세요. 디바운싱은 지정된 지연 후에 함수가 실행되도록 보장하고, 스로틀링은 함수가 호출될 속도를 제한하는데 사용됩니다. 둘 다 성능 병목 현상을 방지할 수 있습니다.\n\n\n\n```js\nimport React, { useState } from 'react';\nimport { debounce, throttle } from 'lodash';\n\nconst SearchInput = () =\u003e {\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // 지연된 검색 처리기\n  const handleDebouncedSearch = debounce(search =\u003e {\n    // 검색 작업 수행\n    console.log('다음을 검색 중입니다:', search);\n  }, 500);\n\n  // 스크롤 쓸대 처리기\n  const handleThrottledScroll = throttle(() =\u003e {\n    // 스크롤 관련 작업 수행\n    console.log('스크롤 중...');\n  }, 100);\n\n  const handleChange = event =\u003e {\n    const { value } = event.target;\n    setSearchTerm(value);\n    handleDebouncedSearch(value); // 지연된 검색\n  };\n\n  return (\n    \u003cinput\n      type=\"text\"\n      value={searchTerm}\n      onChange={handleChange}\n      onScroll={handleThrottledScroll} // 스크롤 쓸대\n    /\u003e\n  );\n};\n\nexport default SearchInput;\n```\n\n## 15. 이벤트 핸들러 최적화:\n\n렌더 메서드 내부에서 요소에 직접 이벤트 리스너를 추가하는 것은 메모리 누수 및 성능 문제를 일으킬 수 있습니다. 대신, 이벤트 위임을 사용하거나 렌더 주기 외부에서 프로그래밍 방식으로 이벤트 리스너를 추가하여 이벤트 처리를 최적화하세요.\n\n```js\nimport React, { useEffect, useRef } from 'react';\n\nconst ScrollListener = () =\u003e {\n  const scrollRef = useRef(null);\n\n  useEffect(() =\u003e {\n    const handleScroll = () =\u003e {\n      // 스크롤 관련 작업 수행\n      console.log('스크롤 중...');\n    };\n\n    // 마운트 시 이벤트 리스너 추가\n    scrollRef.current.addEventListener('scroll', handleScroll);\n\n    // 언마운트 시 이벤트 리스너 제거\n    return () =\u003e {\n      scrollRef.current.removeEventListener('scroll', handleScroll);\n    };\n  }, []); // 빈 종속성 배열은 효과가 한 번만 실행되도록 함\n\n  return (\n    \u003cdiv ref={scrollRef} style={{ overflowY: 'scroll', height: '300px' }}\u003e\n      {/* 스크롤 가능한 콘텐츠 */}\n    \u003c/div\u003e\n  );\n};\n\nexport default ScrollListener;\n```\n\n\n\n## 16. 불필요한 부작용 피하기:\n\n함수형 컴포넌트 내의 부작용에 주의하세요. API 호출이나 상태 변경과 같은 작용은 불필요한 재랜더링을 유발할 수 있습니다. useEffect 훅을 사용하여 적절한 의존성 배열을 설정하여 부작용이 발생하는 시기를 제어하고 컴포넌트 렌더링을 최적화하세요.\n\n## 17. 이미지 최적화:\n\n손실 없는 압축(품질을 희생하지 않고 파일 크기를 줄이는)이나 손실 압축(일부 품질을 희생하면서 파일 크기를 줄이는)과 같은 압축 기술을 사용하여 이미지 파일 크기를 줄이세요. WebP, JPEG XR 또는 AVIF와 같은 이미지 형식을 사용하여 JPEG나 PNG와 같은 전통적인 형식보다 더 나은 압축률과 품질을 제공하세요. 또한 사용자의 기기와 화면 크기에 따라 적절한 크기의 이미지를 제공하기 위해 srcset 및 sizes 속성을 사용하여 반응형 이미지를 서비스하세요. 이를 통해 불필요한 데이터 전송을 줄이고 로딩 시간을 향상시킬 수 있습니다. 화면에 바로 나타나지 않는 이미지에 대해 lazy loading을 구현하여 화면에 나타나면 로드되도록 하여 중요한 콘텐츠를 우선적으로 처리하고 초기 페이지 로딩 성능을 향상시키세요. 마지막으로 사용자의 기기와 네트워크 상황에 따라 이미지를 자동으로 최적화하고 제공하는 이미지 CDN 서비스를 고려해보세요.\n\n\n\n감사합니다. 끝까지 오셔서 기쁩니다.\n\n저랑 소통해요. 이 링크를 클릭해서 더 많이 알아보세요.\n\n다음 블로그를 게시할 때 알림을 받으려면 구독해주세요. 다음에 또 만나요.","ogImage":{"url":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png"},"coverImage":"/assets/img/2024-05-14-ExpertPerformanceTipsforREACT_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기","description":"","date":"2024-05-13 00:34","slug":"2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs","content":"\n\n![Node.js Logo](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png)\n\nNode.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!\n\n1. 이벤트 주도 아키텍처:\n\nNode.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.\n\n\n\n2. Node.js에서 이벤트 처리하기:\n\nNode.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.\n\n다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:\n\n```js\n// EventEmitter 클래스를 가져오기\nconst EventEmitter = require('events');\n\n// EventEmitter 클래스의 인스턴스 생성\nconst myEmitter = new EventEmitter();\n\n// 사용자 정의 이벤트 생성 및 리스너 붙이기\nmyEmitter.on('sayHi', () =\u003e {\n  console.log('Hi!');\n});\n\nmyEmitter.on('sayGoodbye', () =\u003e {\n  console.log('Goodbye!');\n});\n\n// 이벤트 발생\nmyEmitter.emit('sayHi'); // 출력: Hi!\nmyEmitter.emit('sayGoodbye'); // 출력: Goodbye!\n```\n\n\n\n3. 비동기 프로그래밍:\n\n비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.\n\nNode.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:\n\n- 콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.\n- 프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.\n- Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.\n\n\n\n```js\n// 콜백 함수를 사용한 예시\nconst fs = require('fs');\n\nfs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n  if (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n    return;\n  }\n  console.log('파일 내용:', data);\n});\n\nconsole.log('파일 읽는 중...');\n\n// 프로미스를 사용한 예시\nconst readFilePromise = new Promise((resolve, reject) =\u003e {\n  fs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n    if (err) {\n      reject(err);\n      return;\n    }\n    resolve(data);\n  });\n});\n\nreadFilePromise\n  .then(data =\u003e {\n    console.log('파일 내용:', data);\n  })\n  .catch(err =\u003e {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  });\n\nconsole.log('파일 읽는 중...');\n\n// Async/Await를 사용한 예시\nasync function readFileAsync() {\n  try {\n    const data = await fs.promises.readFile('example.txt', 'utf8');\n    console.log('파일 내용:', data);\n  } catch (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  }\n}\n\nreadFileAsync();\nconsole.log('파일 읽는 중...');\n```\n\n4. 이벤트 루프의 동작:\n\n이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.\n\n1. 이벤트 큐:\n\n\n\n- Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.\n- 대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.\n\n2. 이벤트 루프 반복:\n\n- 이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.\n- 이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.\n\n3. 실행 단계:\n\n\n\n- 이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.\n- 작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.\n\n4. Non-Blocking I/O:\n\n- 비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.\n- 비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.\n\n5. 콜백 큐:\n\n\n\n- 비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.\n- 이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.\n\n6. 콜백 실행:\n\n- 이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.\n- 이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.\n\n![이미지](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png)\n\n\n\n- 이벤트 기반 아키텍처:\n\n- Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.\n- 이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.\n\n2. Node.js에서 이벤트 처리:\n\n- Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.\n- 이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.\n\n\n\n3. 비동기 프로그래밍:\n\n- 비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.\n- 콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.\n- 콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.\n\n4. 이벤트 루프 동작:\n\n- Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.\n- I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.","ogImage":{"url":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"워커 스레드 NodeJS에서의 멀티태스킹","description":"","date":"2024-05-13 00:30","slug":"2024-05-13-WorkerThreadsMultitaskinginNodeJS","content":"\n\n## Worker 스레드의 심층 탐구\n\n![WorkerThreadsMultitaskinginNodeJS_0.png](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png)\n\n안녕하세요! 이 글은 고급 NodeJS를 다루는 시니어 엔지니어 시리즈의 네 번째 글입니다. 이 글에서는 Worker 스레드가 무엇이고, 왜 필요하며, 어떻게 작동하는지 자세하게 설명하고, Worker 스레드를 사용하여 최상의 성능을 얻는 방법에 대해 알려 드리겠습니다. 공식 문서는 worker_threads에서 확인할 수 있습니다. 이 시리즈의 다른 글들도 아래에서 찾아볼 수 있어요:\n\n```js\n글 시리즈 로드맵:\n\n* V8 자바스크립트 엔진\n* NodeJS의 비동기 IO\n* NodeJS의 이벤트 루프\n* Worker Threads: NodeJS에서의 멀티태스킹 (이 글)\n* Child Processes: NodeJS에서의 멀티태스킹\n* 클러스터링과 PM2: NodeJS에서의 멀티태스킹\n* 흔한 NodeJS 오해 허물기\n```\n\n\n\n```js\n목차\n\n* 왜 우리는 모든 일꾼 스레드가 필요한 걸까요?\n* 일꾼 스레드가 무엇인지 이해하려면 필수적으로 알아야 할 것들\n  * 동시성 vs 병렬성\n  * 프로세스와 스레드 이해\n  * 비유\n* 그렇다면 일꾼 스레드가 무엇인가요?\n* 하드웨어 레벨에서 어떻게 작동하는가요?\n* 어떤 것을 사용할 수 있을까요?\n  * isMainThread, threadId\n  * 일꾼 이벤트\n  * 일꾼 옵션\n  * MessageChannel\n  * MessagePort와 MessagePort 이벤트\n  * 스레드 간 데이터 전달 방법\n  * Atomics\n  * 포트 전송\n  * 배열 버퍼 전송\n  * 공유 배열 버퍼를 사용하여 데이터 공유\n* 일꾼 스레드에 유의해야 할 점\n```\n\n# 왜 우리는 모든 일꾼 스레드가 필요한 걸까요?\n\n서버는 CPU 집약적인 작업으로 인해 빠르게 작업량이 증가할 수 있습니다. 예를 들어, 간단하고 CPU 부담이 없는 작업을 수행하는 두 가지 엔드포인트가 있다고 상상해보세요. 다른 하나는 10초가 걸리는 복잡한 CPU 집약적인 작업을 처리하는 반면, 서버가 CPU 집약적인 요청으로 작업 중이라면 CPU 부담이 없는 요청에 즉각적으로 응답할 수 없을 것입니다. 이 문제는 NodeJS의 황금 규칙을 어기기 때문에 발생합니다: 즉, 이벤트 루프를 블록하지 말아라.\n\n우리는 NodeJS가 단일 스레드 아키텍처로 CPU 집약적인 작업에 적합하지 않다는 것을 잘 아고 있습니다. 그러나 이것은 CPU 집약적인 작업에 활용할 수 없다거나 멀티 스레드 아키텍처의 이점을 누릴 수 없다는 의미는 아닙니다. 그렇지 않습니다! 등장하세요 영웅: 일꾼 스레드가 구원에 나서는 거죠...\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*tp7TwTTtOJ1VYmYP9r3whQ.gif)\n\nNode.js v10.5.0에서 worker_threads 모듈을 통해 실험적인 Worker Threads 개념이 소개되었으며, 이후 Node.js v12 LTS부터 안정적인 기능으로 제공됩니다.\n\n# Worker threads가 무엇인지 이해하기 위한 선행 조건\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*qU8qdLnz7iixhKlwcsP9bw.gif)\n\n\n\n## 동시성 대 병렬성\n\n동시성은 한꺼번에 많은 일을 처리하는 것입니다. 병렬성은 한꺼번에 많은 일을 하는 것입니다. — Rob Pike\n\n![image](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_1.png)\n\n우리는 워커 스레드의 본질을 이해하는 데부터 시작해봅시다: 동시성이 아니라 병렬성입니다. 위의 이미지에서 보듯, 단일 스레드로 여러 작업을 수행하는 것(동시성)은 동시에 실행하는 것(병렬성)에 비해 더 많은 시간이 걸립니다.\n\n\n\n동시성 모델은 네트워크 통신, 파일/데이터베이스 읽기 및 쓰기와 같은 IO 작업에서 유용합니다. 왜냐하면 네트워크나 디스크가 실제 데이터를 제공할 때 기다려야 하기 때문입니다. 그리고 CPU나 스레드는 그 속도를 빠르게 할 수 없습니다. 그래서 대부분의 시간이 대기하는 데 사용됩니다. 그래서 스레드는 그 시간에 다른 일을 할 수 있고 그게 더 의미가 있습니다.\n\n그러나 이 접근 방식은 CPU 집약적인 작업에는 적합하지 않을 수 있습니다. 비록 작업 2가 비교적 빨랐지만, 단일 코어/스레드만 사용했기 때문에 더 많은 시간이 걸렸습니다. 여러 스레드/코어를 활용하여 CPU 집약적인 작업을 작업 스레드에 위임하고, 비 CPU 집약적인 작업을 주 스레드에서 실행함으로써 우리는 더 효율적으로 작업할 수 있었습니다.\n\n## 프로세스와 스레드 이해\n\n![WorkerThreadsMultitaskinginNodeJS_2](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_2.png)\n\n\n\n프로세스는 운영 체제에서 실행 중인 프로그램입니다. 각각의 프로세스는 자체 메모리를 갖고 있으며 다른 프로세스의 메모리를 볼거나 접근할 수 없습니다. 한 번에 한 가지 작업만 실행될 수 있습니다. 단일 코어 기계에서는 여러 프로세스가 동시에 실행됩니다. 즉, 운영 체제는 규칙적인 간격으로 프로세스 간을 전환합니다. 다중 코어 시스템에서는 운영 체제가 각 프로세스를 동시에 각 코어에서 실행하도록 일정하게 스케줄링합니다. 그러나 코어의 수보다 더 많은 프로세스를 생성하면, 각 코어가 완료될 때까지 동시에 여러 프로세스를 실행합니다.\n\n스레드는 한 번에 한 가지 작업을 실행할 수 있는 프로세스와 유사합니다. 프로세스와 달리 스레드는 자체 메모리를 갖지 않고 프로세스의 메모리 안에 존재합니다. 프로세스를 생성하면 병렬로 코드를 실행하는 여러 스레드가 있을 수 있습니다. 게다가 스레드는 메시지 전달이나 프로세스 메모리 내의 데이터 공유를 통해 서로 통신할 수 있습니다. 이는 스레드를 프로세스에 비해 가볍게 만듭니다. 왜냐하면 스레드 생성 시 운영 체제로부터 더 많은 메모리를 요청하지 않기 때문입니다. 스레드의 실행에 관해서는 프로세스와 유사한 동작을 합니다.\n\n## 비유\n\n요약하자면, 작업자 스레드는 레스토랑에서 주방장과 함께 추가 셰프가 여러 개의 음식을 동시에 준비하는 것과 같습니다.\n\n\n\n![WorkerThreadsMultitaskinginNodeJS_3](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_3.png)\n\n# 정확히 worker 스레드는 무엇인가요?\n\n이 섹션에서는 worker-threads 모듈을 사용하여 CPU 집약적 작업을 다른 스레드로 옮겨서 메인 스레드를 차단하지 않도록 하는 방법에 대해 알아볼 것입니다. 이를 위해 CPU 집약적 작업을 포함하는 worker.js 파일을 생성합니다. 그리고 parent.js 파일에서는 worker-threads 모듈을 사용하여 스레드를 초기화하고 worker.js 파일에서 작업을 시작하여 메인 스레드와 병렬로 실행될 수 있도록 합니다. 작업이 완료되면 worker 스레드는 결과를 포함한 메시지를 메인 스레드로 다시 보냅니다.\n\nparent.js에 아래와 같은 내용이 있습니다.\n\n\n\n```js\nconst {Worker} = require('worker_threads');\nconst worker = new Worker('./worker.js', {workerData: {num: 5});\nworker.on('message', (result) =\u003e {\nconsole.log('square of 5 is :', result);\n})\nworker.on(\"error\", (msg) =\u003e {\n    console.log(msg);\n });\nconsole.log('hurreyy')\n```\n\n먼저 worker_threads 모듈을 가져와서 Worker 클래스를 언팩합니다. Worker 클래스를 사용하여 new 키워드를 사용해 worker.js 파일 경로를 사용하여 Worker의 새 인스턴스를 생성합니다. 이렇게 하면 새 쓰레드가 만들어지며 worker.js 파일에 있는 코드가 다른 코어에서 쓰레드에서 실행됩니다.\n\n이후, worker 인스턴스에 on(\"message\") 메소드를 사용하여 메세지 이벤트를 듣도록 이벤트를 추가합니다. worker.js 파일에서 결과를 포함하는 메세지를 수신하면 해당 메소드의 콜백으로 전달되어 콘솔에 CPU 작업의 결과가 포함된 응답이 표시됩니다.\n\n그 다음, worker 인스턴스에 on(\"error\") 메소드를 사용하여 오류 이벤트를 듣도록 다른 이벤트를 추가합니다.\n\n\n\n\nworker.js 파일에 대한 설명입니다.\n\n```javascript\nconst {parentPort, workerData} = require('worker_threads');\nparentPort.postMessage(workerData.num * workerData.num)\n```\n\n첫 번째 줄은 worker_threads 모듈을 불러오고 parentPort 클래스를 추출합니다. 이 클래스는 주 스레드에 메시지를 보낼 수 있는 메서드를 제공합니다. WorkerData에는 스레드가 초기화될 때 주 스레드로부터 전달받은 데이터가 포함되어 있습니다. 그런 다음 parentPort 클래스의 postMessage() 메서드를 호출하여, CPU 바운드 작업의 결과가 저장된 제곱 값을 포함한 메시지를 주 스레드로 보냅니다.\n\nnode parent.js로 부모를 실행하면 아래 내용이 표시됩니다.\n\n\n\n```md\n훔쳐\n5의 제곱은: 25\n```\n\n# 하드웨어 안에서 무슨 일이 일어날까요?\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_4.png\" /\u003e\n\n이미 알고 있듯이 NodeJS 프로세스가 시작될 때 한 프로세스, 한 스레드, 한 이벤트 루프, 하나의 V8 엔진 인스턴스, 하나의 Node.js 인스턴스와 함께 시작된다는 것을 알고 있습니다. 메인 스레드와 마찬가지로 각 워커는 같은 프로세스 내에서 독자적인 V8, nod, libuv 인스턴스, 그리고 이벤트 루프를 갖게 됩니다.\n\n\n\n\nV8 isolate은 Chrome V8 런타임 내에서 별도의 엔티티를 가리킵니다. 각자의 JS 힙과 마이크로태스크 큐를 보유하고 있죠. 이 독특한 설정 덕분에 모든 Node.js 워커가 다른 워커들로부터 완전히 격리된 상태에서 자체 JavaScript 코드를 실행할 수 있게 되었습니다. 하지만 이런 격리는 비용이 딸리기도 합니다 — 각 워커들은 서로의 힙에 직접적으로 접근할 수 없습니다. 결과적으로 각 워커는 자신만의 libuv 이벤트 루프 버전을 유지하며, 다른 워커들과 부모 워커의 이벤트 루프와 독립적으로 작동합니다.\n\n워커 스레드를 사용하면 스레드가 어느 시점에 종료되더라도 이는 반드시 부모 프로세스의 종료를 의미하지는 않습니다. 워커에 의해 할당된 리소스가 워커가 사라진 후에 남아있는 것은 좋지 않은 관행입니다 — 그렇게 되면 메모리 누수가 발생하게 되고, 우리는 그렇게 하고 싶지 않습니다. 우리는 Node.js를 자체에 넣어주고, Node.js에 새로운 스레드를 생성하고 그 안에 새로운 Node.js 인스턴스를 만들어주고 싶습니다; 결국 동일한 프로세스 내에서 독립적인 스레드를 실행하고 싶은 것입니다.\n\nworker_threads 구현은 애플리케이션이 여러 격리된 JavaScript 워커를 사용할 수 있도록 함으로써 동시성을 제공합니다. 워커들 간 통신 및 부모 워커와의 통신은 Node가 제공하는 것입니다. 주 프로그램과 워커 \"스레드\" 간에는 암시적인 메모리 공유가 없습니다. 대신, 이벤트 기반 메시징 시스템이 제공되어 값들이 프로세스 간에 교환될 수 있게 됩니다.\n\n각 워커는 메시지 채널을 통해 부모 워커에 연결됩니다.\n\n\n\n![이미지](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_5.png)\n\n작업자 스레드는 뒷면에서 두 가지 구분된 단계로 작동합니다. 첫 번째 단계는 작업자 초기화입니다. 여기서 작업자 인스턴스가 생성되고 부모 및 자식 작업자 간의 초기 통신이 수립됩니다. 이를 통해 부모에서 자식 작업자로 작업자 메타데이터를 전송할 수 있습니다.\n\n이 초기화 메타데이터는 무엇일까요? 이는 작업자 실행 스크립트가 작업자를 시작하는 데 필요한 정보입니다: 작업자로 실행할 스크립트 이름, 작업자 데이터 및 추가 세부 정보입니다. 예를 들어, 이 초기화 메타데이터는 다음과 같은 메시지일 수 있습니다: \"안녕 작업자, worker-simple.js 파일을 'num: 5'와 함께 실행해 줄 수 있을까요?\"\n\n두 번째 단계는 작업자 실행입니다. 여기서 사용자의 작업자 JavaScript 스크립트가 사용자가 제공한 workerData 및 부모 작업자가 제공한 다른 메타데이터를 사용하여 실행됩니다. 이 과정에서 새로운 v8 인스턴스가 생성되고 작업자에 할당됩니다. 그런 다음 libuv가 자체 이벤트 루프로 초기화됩니다. 초기화 메타데이터가 읽히고 worker.js가 실행됩니다.\n\n\n\n# 무엇을 작업할 수 있을까요?\n\n## isMainThread, threadId\n\n워커용 새 파일을 만들고 싶지 않다면 워커 인스턴스 스크립트 경로로 __filename을 전달할 수 있습니다. 이렇게 하면 동일한 파일을 사용할 수 있습니다. 그리고 isMainThread을 사용하여 메인 스레드와 워커 스레드에서 실행하고 싶은 논리를 구분할 수 있습니다. 생성된 객체에는 고유한 threadId 속성이 있습니다.\n\n## 워커 이벤트\n\n\n\nWorker는 우리가 원하는 콜백과 연결할 수 있는 몇 가지 이벤트를 제공합니다.\n\n- 메시지: `message` 이벤트는 워커 스레드가 parentPort.postMessage()를 호출할 때 발생합니다.\n- 종료: `exit` 이벤트는 워커가 중지될 때 발생합니다. 워커가 process.exit()를 호출하여 종료된 경우 exitCode 매개변수는 전달된 종료 코드입니다. 워커가 종료된 경우, exitCode 매개변수는 1입니다. 이는 모든 Worker 인스턴스에서 발생하는 마지막 이벤트입니다.\n- 오류: `error` 이벤트는 워커 스레드가 처리되지 않은 예외를 throw할 때 발생합니다. 이 경우 워커가 종료됩니다.\n- 온라인: `online` 이벤트는 워커 스레드가 JavaScript 코드를 실행하기 시작했을 때 발생합니다.\n\n위 예제는 각 parseJSAsync() 호출을 위해 Worker 스레드를 생성합니다. 실제로는 이러한 작업을 수행할 Worker 풀을 사용하십시오. 그렇지 않으면 Worker를 생성하는 오버헤드가 혜택을 상회할 수 있습니다.\n\n\n\n## Worker 옵션\n\n파일명과 함께 worker를 생성할 때 두 번째 인자로 특정 옵션을 전달할 수 있습니다. const worker = new Worker(__filename, OptionsObject)\n일부 OptionObject 속성은 다음과 같습니다:\n\n- argv: worker에 process.argv에 추가되기 전 문자열화 및 연결될 인수 목록입니다. 이것은 대부분 workerData와 유사하지만, 값은 CLI 옵션으로 스크립트에 전달된 것처럼 전역 process.argv에서 사용할 수 있습니다.\n- workerdata: 워커 스레드에 전달하려는 데이터입니다. 이 데이터는 HTML 구조화된 클론 알고리즘을 사용하여 복제됩니다.\n- transferList: ArrayBuffer, MessagePort, FileHandle, X509Certificate, Blob로 이루어진 항목의 배열입니다. workerData에 하나 이상의 MessagePort와 같은 객체가 전달된 경우, 해당 항목에 대해 transferList가 필요하며, 전달되지 않은 경우에는 ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST가 throw됩니다. 자세한 내용은 아래에서 더 다루겠습니다.\n- env: 설정된 경우 Worker 스레드 내부의 process.env의 초기값을 지정합니다. 특별한 값으로 worker.SHARE_ENV를 사용하여, 부모 스레드와 자식 스레드가 환경 변수를 공유해야 함을 지정할 수 있으며, 이 경우 한 스레드의 process.env 객체에 대한 변경 사항은 다른 스레드에도 영향을 줍니다.\n- resourceLimits: 새 JS 엔진 인스턴스에 대한 리소스 제한의 선택적 집합입니다. 이러한 제한에 도달하면 Worker 인스턴스가 종료됩니다. 이러한 제한은 JS 엔진에만 영향을 미치며, ArrayBuffer를 포함한 외부 데이터는 영향을 받지 않습니다. 이러한 제한을 설정해도 전역 메모리 부족 상황을 만나게 되면 프로세스가 중단될 수 있습니다. 제약 사항 중 일부는 maxYoungGenerationSizeMb (MB의 메인 힙의 최대 크기), maxOldGenerationSizeMb, codeRangeSizeMb, stackSizeMb입니다.\n- name: 디버깅 / 식별 목적을 위해 워커 제목 뒤에 추가할 수 있는 선택적 이름이며, 최종 제목은 [worker $'id'] $'name'입니다. 기본값: ``.\n\n## MessageChannel\n\n\n\n쓰레드 간 통신을 위해 중요한 두 가지 구성 요소가 있습니다. 통신 채널과 통신할 포트입니다. 먼저 통신하기 전에 통신 채널인 MessageChannel을 설정해야 합니다. MessageChannel은 비동기, 양방향 통신 채널입니다. MessageChannel에는 별도의 메서드가 없습니다. new MessageChannel()은 port1과 port2 속성을 갖는 객체를 반환하는데, 이 속성들은 연결된 MessagePort 인스턴스를 가리킵니다. 기본적으로 port1과 port2는 채널의 두 끝점에 해당합니다.\n\n```js\nconst { MessageChannel } = require('node:worker_threads');\n\nconst { port1, port2 } = new MessageChannel();\nport1.on('message', (message) =\u003e console.log('received', message));\nport2.postMessage({ foo: 'bar' });\n// Prints: received { foo: 'bar' } from the `port1.on('message')` listener\n```\n\n메시지를 보내는 용도로 한 포트를 사용하고, 메시지를 수신하는 용도로 다른 포트를 사용합니다. 기본적으로 port1과 port2는 채널의 두 끝점에 해당합니다.\n\n[Worker Threads in Node.js](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_6.png)\n\n\n\n## MessagePort 및 MessagePort 이벤트\n\n이전에는 worker에서 부모로 메시지를 보내기 위해 `parentPort.postMessage()`를 사용했고 worker에서 메시지를 보내기 위해 `worker.postMessage()`를 사용했습니다. 이는 부모Port와 Worker가 모두 MessagePort 클래스의 인스턴스이기 때문입니다. 이 제공된 postMessage 및 message, close와 같은 이벤트들은 콜백을 태깅할 수 있습니다.\n\n- message: 어떠한 수신 메시지에 대해 이벤트가 발생합니다.\n- close: 채널의 어느 한 쪽이 연결을 해제했을 때 이벤트가 발생합니다.\n\n```js\nconst { MessageChannel } = require('node:worker_threads');\nconst { port1, port2 } = new MessageChannel();\n\n// 출력:\n//   foobar\n//   closed!\nport2.on('message', (message) =\u003e console.log(message));\nport2.on('close', () =\u003e console.log('closed!'));\n\nport1.postMessage('foobar');\nport1.close();\n```\n\n\n\n## 쓰레드 간 데이터 전달 방법\n\n- 데이터 복제\n두 개의 쓰레드 간 데이터를 전달하는 여러 가지 방법이 있습니다. 기본적으로 이 데이터는 복제됩니다. 즉, 송신자와 수신자가 데이터의 각각 고유한 사본을 갖게 됩니다. 이 데이터는 '구조화된 복제 알고리즘'을 통해 복제됩니다. 전달되는 데이터가 깊게 중첩된 경우 데이터를 복제하는 데 상당한 처리 능력이 필요할 수 있습니다. 따라서 데이터의 사본을 만들어 두는 것이 항상 최적적이라고 할 수 없습니다.\n- 데이터 전송\n위의 단점을 극복하는 한 가지 방법은 데이터를 전송하는 것입니다. transferList 옵션을 사용하여 이를 달성할 수 있습니다. transferList를 사용하면 송신자가 수신자에게 데이터를 직접 제공할 수 있습니다. 이렇게 하면 송신자의 쪽에서 해당 데이터에 액세스할 수 없게 됩니다.\ntransferList는 ArrayBuffer, MessagePort 및 FileHandle 객체의 목록일 수 있습니다. 전송 후에는 채널의 보내는 쪽에서 더 이상 사용할 수 없습니다 (value에 포함되어 있지 않더라도 해당됨). 네트워크 소켓과 같은 핸들을 전송하는 것은 현재 지원되지 않습니다 (이것은 자식 프로세스와 함께 가능합니다).\n- 동일한 데이터 공유\nSharedArray Buffer를 사용하여 송신자와 수신자 간에 동일한 데이터를 공유할 수 있습니다.\n\n## 원자성\n\n워커 또는 메인 쓰레드에서 동시에 공유 메모리를 생성하고 업데이트할 수 있으며, 이로 인해 경쟁 조건과 동기화 문제가 발생할 수 있습니다. 이 문제를 피하기 위해 Atomics를 사용할 수 있습니다. 메모리가 공유되면 여러 쓰레드가 메모리에서 동일한 데이터를 읽거나 쓸 수 있습니다. 원자 연산은 다음 연산이 시작되기 전에 작업이 완료되도록 하며, 작업이 중단되지 않도록 합니다.\nnew 연산자로 사용하거나 Atomics 객체를 함수처럼 호출할 수 없습니다. Atomics의 모든 속성과 메소드는 정적(static)입니다 (Math 객체와 마찬가지로).\n\n\n\nAtomics.load(): 배열의 지정된 인덱스에서 값 반환. 인덱스의 '게터'의 한 종류.\nAtomics.store(): 배열의 지정된 인덱스에 값 저장. 값 반환.\nAtomics.and()/Atomics.or()/Atomics.sub()/Atomics.xor()/Atomics.add(): 비트 연산\nAtomics.notify()/Atomics.wait(): 특정 조건이 충족될 때까지 대기하는 방법을 제공하며 일반적으로 블로킹 구조로 사용됨.\n\n이제 다양한 방법으로 데이터를 전달해 봅시다\n\n## 포트 전송\n\n이것은 일반적으로 전송 목록에서 포트를 전달하고 싶을 때 유용합니다. 이제 왜 그렇게 하고 싶을까요? 이 방법을 통해 메시지 채널을 재사용할 수 있습니다. 이를 해보겠습니다.\n\n\n\nIn parent.js\n\n```js\n// parent.js\n\nconst { Worker, MessageChannel } = require('worker_threads');\nconst { port1, port2 } = new MessageChannel()\n\nconst worker = new Worker('./worker.js')\nport1.on(\"message\", msg =\u003e {\n    console.log(`Worker로부터 온 메시지 ----\u003e ${msg}`)\n})\nworker.postMessage({ port: port2}, [port2])\n```\n\nIn worker.js\n\n```js\n// worker.js\n\nconst {parentPort} = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    msg.port.postMessage('전달된 포트를 사용하여 Hi를 보냈습니다')\n})\n```\n\n\n\n워커로부터의 메시지: Sent Hi from using transfered port\n\n## 배열 버퍼를 사용한 데이터 전송\n\n배열 버퍼(Array Buffer)는 고정 길이 및 연속된 메모리 영역이며 한 번 길이가 선언되면 변경할 수 없습니다. 보통 배열처럼 내부 값을 직접 액세스할 수 없고 데이터 뷰(Data view)라는 것이 필요합니다. 데이터 뷰는 선언된 배열 버퍼를 볼 때 어떤 렌즈로 보는지에 대한 것입니다. \n\n예를 들어, 16바이트 배열 버퍼를 선언한다면 (16바이트 === 128비트),\n```javascript\nconst arrayBuffer = new ArrayBuffer(16)\n```\n\n이제 이 128비트를 어떤 렌즈로 볼 것인지 다음과 같은 방법으로 할 수 있습니다. \n이 128비트를 8 * 16 블록 즉, 8비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int8Array(arrayBuffer, 0, 16)\n```\n\n또는,\n이 128비트를 16 * 8 블록 즉, 16비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int16Array(arrayBuffer, 0, 8)\n```\n\n또는,\n이 128비트를 32 * 4 블록 즉, 32비트 정수 배열로 볼 수 있습니다.\n```javascript\nconst dataview = new Int32Array(arrayBuffer, 0, 4)\n```\n\n이러한 Int8Array, Int16Array, Int32Array, Int64Array는 배열 버퍼 내부 데이터를 다양하게 표현하기 위한 배열 유형(Types arrays)이라고 불립니다.\n\nparent.js에서\n\n\n\n```js\nconst { Worker } = require('worker_threads');\n\nconst worker = new Worker('./worker.js')\nconst arrayBuffer = new ArrayBuffer(16)\nconst dataview = new Int8Array(arrayBuffer, 0, 16) // all 0 by default\nconsole.log('부모 안에서 전송하기 전' + dataview)\nworker.postMessage(dataview, [dataview.buffer])\n// console.log('부모 안에서 전송 후' + dataview)\n```\n\nworker.js 파일 내용\n\n```js\nconst { parentPort } = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    console.log('전송 후 워커 내에서' + msg)\n})\n```\n\n위 코드를 실행하면 출력은 다음과 같습니다.\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_7.png\" /\u003e\n\n그래서 데이터가 전송되었다는 것을 증명하는 것이죠.\n만약 parent.js의 마지막 줄의 주석을 해제한다면, parent.js가 이미 전송된 배열 버퍼에 액세스할 수 없다는 것을 보여주는 다음 오류가 발생할 겁니다.\n\n\u003cimg src=\"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_8.png\" /\u003e\n\n## SharedArray buffer를 사용하여 데이터 공유하기\n\n\n\n이제 배열 버퍼를 전송해 봅시다.\n부모.js 파일에서 다음과 같이 작성하세요.\n\n```js\nconst { Worker } = require('worker_threads');\n\nconst worker = new Worker('./worker.js')\nconst sharedArrayBuffer = new SharedArrayBuffer(16)\nconst dataview = new Int8Array(sharedArrayBuffer, 0, 16) // 기본적으로 모두 0\nconsole.log('부모 안에서 공유하기 전' + dataview)\nworker.postMessage(dataview)\nconsole.log('부모 안에서 공유한 후' + dataview)\n```\n\nworker.js 파일에서는 다음과 같이 작성하세요.\n\n```js\nconst {parentPort} = require('worker_threads');\nparentPort.on(\"message\", msg =\u003e {\n    console.log('작업자 안에서 공유한 후' + msg)\n})\n```\n\n\n\n![WorkerThreadsMultitaskinginNodeJS_9](/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_9.png)\n\n이번에는 부모로부터 온 마지막 로그가 발생하지 않습니다. 데이터가 실제로 공유되고 전송되거나 복사되지 않기 때문입니다.\n\n# 워커 스레드 주의사항\n\n- NodeJS 워커 스레드는 일반적인 스레드가 아닙니다. 다른 언어의 멀티스레딩과 같이 멀티스레딩이 되기를 기대한다면, 기본적으로 스레드는 동일한 상태를 공유해야 합니다. Node.js 워커 스레드는 자체 V8, libuv 인스턴스, 이벤트 루프 및 별도의 힙을 가지는 다른 워커 스레드와 독립적으로 작동합니다.\n- IO에 워커 스레드를 사용하는 것은 무의미합니다. 워커 프로세스를 생성하고 유지하는 비용은 Node의 비동기 I/O 구현보다 효율적이지 않습니다.\n- 워커 스레드는 성능 절약이 프로세스 생성 비용보다 쉽게 상쇄될 수 있는 경우에 사용해야 합니다.\n- 공유 워커 스레드 풀을 활용하면 비효율성을 줄이고 새로 생성하는 필요성을 제거할 수 있습니다. 이 접근 방식은 시간과 자원을 절약할 뿐만 아니라 워커 풀의 관리를 단순화시킵니다. Piscina와 Poolifier와 같은 라이브러리는 워커 풀을 관리하는 복잡성을 처리하여 더 중요한 작업에 집중할 수 있도록 해줍니다.\n- 워커 스레드의 디버깅은 이벤트, 해당 워커 및 결과적인 영향 사이의 명확한 연결 부재로 인해 매우 어려울 수 있습니다. 디버깅을 위해 console.log() 문으로만 의존하는 것은 지루하고 오류가 발생하기 쉽습니다. 그러나 문제 해결에 도움이 되는 솔루션이 있습니다. 풀에 AsyncResource를 첨부하여 편집되어진 비동기 스택 추적을 제공받을 수 있습니다. 이 가치 있는 도구를 사용하면 풀 내에서 발생한 활동을 정확하게 추적하는 상세한 비동기 스택 추적을 확인할 수 있습니다.\n- 자식 프로세스 또는 워커 스레드를 사용할지 헷갈릴 때, CPU 집중 작업에는 워커 스레드를 사용하고 앱을 확장하려면 자식 프로세스를 사용하세요.\n- 코어의 수보다 많은 스레드를 생성하면 성능 향상이 크지 않을 것입니다. CPU 활용률이 컨텍스트 전환에서 소비되기 때문입니다. 이런 이유로 스레드 풀을 신중하게 사용해야 합니다.\n- Piscina, Bree, Poolifier, WorkerPool 등 많이 사용되는 라이브러리들은 모듈을 더 편리하게 사용할 수 있도록 랩핑하거나 스레드 풀링과 같은 상위 수준의 기능을 제공합니다.\n\n\n\n## 참고 자료\n\n- [Node.js Worker Threads에 대한 심층적 탐구](https://blog.insiderattack.net/deep-dive-into-worker-threads-in-node-js-e75e10546b11)\n- [Node.js 스레드 풀 깊이 파헤치기](https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628)\n- [YouTube 영상 - Worker Threads 소개](https://www.youtube.com/watch?v=-JE8P2TiJEg)\n- [YouTube 영상 - Node.js 멀티스레딩 사용법](https://www.youtube.com/watch?v=P1sWw1bLyVg)\n- [Node.js 공식 블로그 - Worker Threads 소개](https://nodesource.com/blog/worker-threads-nodejs/)\n- [DigitalOcean 커뮤니티 - Node.js에서 멀티스레딩 사용 방법](https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js)\n- [Snyk 블로그 - Worker Threads를 활용한 Node.js 멀티스레딩](https://snyk.io/blog/node-js-multithreading-with-worker-threads/)\n- [Snyk 블로그 - Node.js Worker Threads 장단점](https://snyk.io/blog/node-js-multithreading-worker-threads-pros-cons/)\n- [YouTube 영상 - Node.js Worker Threads 사용 예시](https://www.youtube.com/watch?v=kDr7YycaZ5E)\n- [Stack Overflow 질문 - Node.js Worker Thread가 생성될 때 같은 코어를 이용하는가?](https://stackoverflow.com/questions/61831510/when-a-workerthread-is-created-in-nodejs-does-it-utilize-the-same-core-in-which)\n\n# 떠나시기 전에!\n\n- 추가 정보 받아보세요! 팔로우하고 구독해주세요.\n- 👏 버튼을 클릭하고 길게 누르면 무슨 일이 일어나는지 보셨나요?","ogImage":{"url":"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png"},"coverImage":"/assets/img/2024-05-13-WorkerThreadsMultitaskinginNodeJS_0.png","tag":["Tech"],"readingTime":17},{"title":"자바스크립트의 숨은 보석 돌연변이 감시자의 힘 탐구","description":"","date":"2024-05-13 00:28","slug":"2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver","content":"\n\n![Javascript Hidden Gem](/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png)\n\n# 웹사이트 변화의 호기심 깊은 사례\n\n경험이 풍부한 웹 개발자로 상상해보세요. 정교한 웹 애플리케이션을 작업 중입니다. 어느 날, 당신은 웹사이트의 행동에서 예상치 못한 변화를 발견합니다. 요소들이 이동하고, 스타일이 변경되는데, 여러분의 코드 한 줄로 인해 그렇게 되는 것이 아닙니다. 호기심을 자극받고 약간 헷갈리는 기분을 느끼며, 당신은 이 신비를 밝혀내기 위한 여정을 시작합니다. 이 여정은 JavaScript의 변이 감지자(Mutation Observer) 발견으로 이어집니다. 이 도구를 사용하면 돔(DOM)을 수맷돌처럼 지켜보고, 실시간으로 변경 사항에 대응할 수 있습니다. 이것이 동적 콘텐츠를 처리하는 방법을 혁신할 수 있다는 것을 깨닫게 됩니다.\n\n# 변이 감지자의 핵심으로의 여정\n\n\n\n조용한 저녁에 돌연변이 감시자(Mutation Observer)의 핵심 개념에 깊이 파고들었군요. 이것은 JavaScript API의 중요한 부분으로, DOM의 변화를 감시하기 위해 설계된 것입니다. DOM을 지키는 감시병 같은 존재로, 어떤 수정 사항이 있을 때 당신에게 경보를 울립니다. 오늘날의 동적 웹 환경에서 변동이 페이지 다시로드 없이 발생할 수 있는데, 이런 변화를 효율적으로 관리하고 원활한 사용자 경험을 보장하는 데 도움이 되는 중요한 요소임을 이해하게 됐습니다.\n\n# 첫 번째 돌연변이 감시자 소환하기\n\n이 새로운 도구를 탐험하고 싶어서, 첫 번째 돌연변이 감시자를 생성하기로 결심했군요. 이 작업은 놀랍도록 간단합니다. 감시할 DOM 요소를 선택하고 감시할 돌연변이 유형을 정의하는 것으로 시작합니다. 아래는 설정하는 방법입니다:\n\n```js\n// 감시할 노드 선택\nconst targetNode = document.getElementById(\"dynamicContentArea\");\n\n// 감시자를 위한 구성 정의\nconst config = { attributes: true, childList: true, subtree: true, characterData: true };\n\n// 돌연변이를 처리하는 콜백 함수 생성\nconst callback = function(mutationsList) {\n  for (const mutation of mutationsList) {\n    if (mutation.type === \"childList\") {\n      console.log(`자식 노드 개수 변화: ${mutation.addedNodes.length}개의 노드가 추가됨`);\n    } else if (mutation.type === \"attributes\") {\n      console.log(`속성이 변경됨: ${mutation.attributeName}`);\n    } else if (mutation.type === \"characterData\") {\n      console.log(\"노드 내의 텍스트 내용이 변경됨\");\n    }\n  }\n};\n\n// 돌연변이 감시자 생성\nconst observer = new MutationObserver(callback);\n\n// 감시 시작\nobserver.observe(targetNode, config);\n```\n\n\n\n당신은 관측자가 그 역할을 시작하는 것을 기다리면서 기대감에 가득 차 보고 있습니다. 대상 요소에서 DOM 변경 사항을 보고할 준비가 되어 있습니다.\n\n# DOM 왕국 관찰하기\n\n당신의 관측자가 경비를 지키는 동안, 당신은 그가 감지할 수 있는 다양한 종류의 변이를 탐험합니다. 새로운 요소가 DOM으로 몰래 들어오려는 경우, 속성이 외관을 변경하려는 경우, 또는 텍스트 내용이 조용히 메시지를 변경하는 경우까지 알려주는 수호자 같다는 것을 깨닫게 됩니다. 이것을 실제로 보기 위해 다양한 시나리오를 실험하며 요소를 수정하고 콘솔 로그를 관찰해 봅니다.\n\n예를 들어, 새로운 요소 추가를 시도해 봅니다:\n\n\n\n```js\n// 감시 영역에 새 요소를 추가합니다\nlet newNode = document.createElement(\"p\");\nnewNode.textContent = \"새 단락!\";\ntargetNode.appendChild(newNode);\n```\n\n그리고 시간이 지나면, 당신의 감시자가 추가를 보고할 것입니다.\n\n# 감시자 세부 조정하기\n\n감시자의 효율성을 향상시키기 위해 구성 옵션을 탐구합니다. 특정 요구 사항에 맞게 조정하여 특정 변형 유형에 집중함으로써 성능을 최적화하는 방법을 배울 수 있습니다. 예를 들어, 속성 변경에만 관심이 있다면, 구성을 해당 내용에 맞게 수정하면 됩니다:```\n\n\n\n```js\r\n// 설정을 조정하여 속성 변경만 관찰하도록 함\nconst attributeConfig = { attributes: true };\n\n// 새 설정으로 관찰 재시작\nobserver.disconnect(); // 기존 observer를 먼저 연결 해제\nobserver.observe(targetNode, attributeConfig);\r\n```\n\n이 집중된 방식으로 observer를 더 전문화되고 효율적으로 만듭니다.\n\n# 변이 레코드 해독\n\n감시하는 각 변이는 변이 레코드를 가져옵니다. 변이 레코드는 변경된 내용, 변경된 위치 및 방법에 대한 자세한 보고서입니다. 이러한 레코드를 구문 분석하여 소중한 통찰을 추출합니다. 이들은 DOM 내의 동적 변화를 이해하는 열쇠를 갖고 있습니다. 보다 명확한 그림을 얻기 위해 콜백을 수정하여 더 자세한 정보를 기록합니다:```\n\n\n\n```js\nconst detailedCallback = function(mutationsList) {\n  for (const mutation of mutationsList) {\n    console.log(\"Mutation detected:\", mutation);\n    if (mutation.type === \"attributes\") {\n      console.log(`Old attribute value: ${mutation.oldValue}`);\n    }\n  }\n};\n\n// 업데이트된 콜백으로 옵저버 설정\nobserver.disconnect();\nobserver = new MutationObserver(detailedCallback);\nobserver.observe(targetNode, config);\n```\n\n이 향상된 로깅은 각 변이에 대한 포괄적인 정보를 제공하여 당신을 해결해야 할 문제를 발견하는 탐정으로 만들어줄 것입니다.\n\n# 변이 관찰의 예술을 마스터하기\n\n변이 옵저버와의 여정이 점점 끝나가는 가운데, 당신은 습득한 깊은 통찰과 기술에 대해 반성합니다. 궁금한 변화의 관찰자에서 DOM 변경 사항을 감시하고 대응하는 마스터로 전환했습니다. 변이 옵저버에 대한 새로운 이해는 초기 미스터리를 해결할 뿐만 아니라 웹 개발에서의 가능성을 열어 주었습니다.```\n\n\n\nMutation Observer의 설정 및 구성에 대한 기술을 배웠습니다. 그리고 이를 특정 필요에 맞게 맞추고 변이 레코드를 효율적으로 처리하는 법을 익혔습니다. 이 과정에서 성능과 기능성의 균형을 유지하는 중요성을 깨달았습니다. 웹 애플리케이션이 효율적이고 반응성을 유지할 수 있도록 해야 한다는 것을 알게 되었습니다.\n\n하지만 여기서 여행은 끝나지 않습니다. 웹 개발의 영역은 끊임없이 발전하고 있으며, Mutation Observer는 여러분의 방대한 도구 상자 속의 하나뿐입니다. 배울 점은 더 많고, 탐험할 것도 더 많습니다. 웹 애플리케이션을 계속해서 구축하고 향상시킬 때, Mutation Observer에서 얻은 교훈은 여러분이 웹 개발의 동적이고 흥미로운 풍경을 탐험할 때 도와줄 유일한 빛이 될 것입니다.\n\n다른 개발자들과 교환하고 지식을 공유하면서, 그들에게 Mutation Observer의 탐험을 촉구합니다. 함께 여러분은 가능한 범위를 넓혀가며 상호작용적이고 동적이며 사용자 친화적인 웹 경험을 구축할 것입니다.\n\n그래서 성취감과 미래 모험에 대한 기대감을 가지고 이 장을 마치며, 새로운 도전과 기회에 여러분의 전문 지식을 적용할 준비가 되어 있습니다.\n\n\n\n# 🔥 이 개발자 글이 유용했나요? 🔥\n\n이런 심층 가이드 작성은 시간, 헌신, 그리고 네, 풍부한 커피가 필요해요! 만약 이 글이나 다른 글들이 여러분의 개발자 여정에 가치를 더했다면, 감사를 표시해주고 싶다면 고려해 보세요.\n\n👉 제 노력을 지원하고 커피 한 잔 사주세요! https://www.buymeacoffee.com/svetloslav ☕\n\n여러분이 기부해주는 각 커피는 이런 글이 더 나올 수 있도록 보장해줘요. 이 여정에 함께해 주셔서 감사합니다!\n\n\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 치고 팔로우 해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png"},"coverImage":"/assets/img/2024-05-13-JavaScriptsHiddenGemExploringthePowerofMutationObserver_0.png","tag":["Tech"],"readingTime":5},{"title":"5가지 팁과 트릭으로 Nextjs 14와 함께 더 쉽게 살아가는 방법","description":"","date":"2024-05-13 00:27","slug":"2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier","content":"\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png)\n\nNext.js 14은 서버 렌더링된 React 애플리케이션을 구축하는 프로세스를 간단화하는 강력한 React 프레임워크입니다. 그러나 고급 기능과 규칙 때문에 특히 이 프레임워크에 처음 접하는 개발자들에게 혼란과 모호함이 있을 수 있습니다. 이 블로그 포스트에서는 Next.js 14를 사용하여 일상을 더 편리하게 만드는 다섯 가지 팁과 요령을 살펴보겠습니다.\n\n## 팁 1: Next.js 이미지 작업\n\nNext.js에서 이미지 처리는 혼란스러운 부분입니다. 로컬 이미지 또는 원격 이미지와 작업하는 방법은 다르기 때문입니다.\n\n\n\n# 로컬 이미지\n\n로컬 이미지를 사용할 때는 너비와 높이를 지정할 필요가 없어요. Next.js가 자동으로 이미지 크기를 확인합니다. 이미지를 가져와 `next/image` 컴포넌트를 사용해 렌더링하세요.\n\n```js\nimport Image from \"next/image\";\nimport localImage from \"public/hoy.png\";\nexport default function MyComponent() {\n  return \u003cImage src={localImage} alt=\"로컬 이미지\" /\u003e;\n}\n```\n\n\n\n# 원격 이미지\n\n![Remote Image](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_2.png)\n\n원격 이미지를 사용할 때는 레이아웃 변동을 방지하기 위해 블러 플레이스홀더를 제공하고 너비와 높이를 지정해야 합니다. `placeholder=\"blur\"` 속성을 사용하여 이미지의 완전한 버전이 로드될 때까지 이미지의 흐린 버전을 표시할 수 있습니다.\n\n원격 이미지의 블러 데이터 URL을 생성하려면 `sharp` 및 `placeholder` 패키지를 사용할 수 있습니다:\n\n\n\n```js\nimport Image from \"next/image\";\nimport getBase64 from \"./utils/getBase64\";\nexport default async function MyComponent() {\n  const blurDataUrl = await getBase64(remoteImageUrl);\n  return (\n    \u003cImage\n      src={remoteImageUrl}\n      width={600}\n      height={600}\n      alt=\"Remote Image\"\n      placeholder=\"blur\"\n      blurDataURL={blurDataUrl}\n    /\u003e\n  );\n}\n```\n\n`getBase64` 유틸리티 함수는 원격 이미지를 가져와 ArrayBuffer로 변환한 다음 `placeholder` 패키지를 사용하여 해당 이미지의 base64 표현을 생성합니다.\n\n# 팁 2: 환경 변수 처리\n\n환경 변수를 `next.config.env.NEXT_PUBLIC_*`로 표시할 때 주의하십시오. 이러한 변수는 브라우저에서 노출되며 JavaScript 번들에 포함됩니다. 민감한 API 키나 비밀 정보가 있는 경우 `NEXT_PUBLIC_`로 접두사를 붙이지 않도록 주의하십시오. Node.js 환경에서만 사용할 수 있게 됩니다.```\n\n\n\n# 팁 3: Next.js에서 캐싱 이해하기\n\n![이미지](/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_3.png)\n\nNext.js의 캐싱 동작은 개발 환경과 프로덕션 환경에서 다릅니다. 개발 모드에서는 기본적으로 페이지가 동적으로 매 요청마다 렌더링됩니다. 그러나 프로덕션 모드에서는 Next.js가 페이지를 정적으로 렌더링하려고 시도합니다.\n\n프로덕션에서 캐싱을 제어하려면 `revalidate` 옵션을 사용하거나 페이지를 명시적으로 `dynamic`으로 표시할 수 있습니다.\n\n\n\n```js\n// 매 5초마다 다시 유효성 검사\nexport const revalidate = 5\n// 동적 렌더링 강제\nexport const dynamic = 'force-dynamic'\n```\n\n# 팁 4: 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트의 데이터를 가져오기 위해 API 라우트 핸들러를 사용하는 것을 피하십시오. 대신 서버 컴포넌트 내에서 데이터를 직접 가져오세요. 이 방법을 통해 Next.js가 여러 서버 컴포넌트 사이에서 데이터의 캐싱 및 재사용을 최적화할 수 있습니다.\n\n만약 여러 컴포넌트 사이에서 동일한 데이터 가져오기 로직을 재사용해야 한다면, `server/` 디렉토리에 서버 액션을 생성하는 것을 고려해보세요.\n\n\n\n```js\nexport async function getJoke() {\n  const res = await fetch(\"https://api.example.com/joke\");\n  const data = await res.json();\n  if (res.ok) {\n    return { success: true, joke: data.joke };\n  } else {\n    return { error: data.error };\n  }\n}\n// app/page.jsx\nimport { getJoke } from \"../server/actions\";\nexport default async function Page() {\n  const { success, joke, error } = await getJoke();\n  if (success) {\n    return \u003cdiv\u003e{joke}\u003c/div\u003e;\n  } else {\n    throw new Error(error);\n  }\n}\n```\n\n# Tip 5: 클라이언트 및 서버 구성 요소 이해하기\n\n기본적으로 Next.js의 페이지는 서버 구성 요소입니다. 서버 구성 요소 내에서 클라이언트 구성 요소를 렌더링하여 상호작용성을 추가할 수 있습니다.\n\n```js\n\"use client\";\nimport { useState } from \"react\";\nexport default function ClientComponent() {\n  const [count, setCount] = useState(0);\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n클라이언트 컴포넌트 내에 렌더링된 자식 컴포넌트는 '사용 클라이언트' 지시문이 필요 없이 자동으로 클라이언트 컴포넌트가 됩니다.\n\n프로바이더(예: 테마 제공자)를 사용할 때는 레이아웃에서 프로바이더로 자식 컴포넌트를 감싸면 자식 컴포넌트는 여전히 서버 컴포넌트로 렌더링됩니다.\n\n```js\n// app/layout.jsx\nimport { ThemeProvider } from \"your-theme-library\";\nexport default function RootLayout({ children }) {\n  return \u003cThemeProvider\u003e{children}\u003c/ThemeProvider\u003e;\n}\n```\n\n# 결론\n\n\n\nNext.js 14은 서버 렌더링된 React 애플리케이션의 개발을 최적화하는 강력하고 기능이 풍부한 프레임워크입니다. 새로운 개념과 규칙이 소개되었지만, 이 블로그 포스트에서 안내된 꿀팁과 요령을 따르면 혼동과 모호함이 발생할 수 있는 부분을 잘 헤쳐나갈 수 있을 거예요.\n\n이미지 사용 방법, 환경 변수 처리, 캐싱 관리, 서버 컴포넌트에서 데이터 가져오기, 그리고 클라이언트 및 서버 컴포넌트 간의 차이 등을 이해하면 Next.js 14로 튼튼하고 효율적인 애플리케이션을 개발하는 데 능숙해질 거예요.\n\n기술을 마스터하는 데 있어서 연습과 경험은 중요합니다. Next.js 문서를 탐험하고 커뮤니티 포럼에 참여하며 프레임워크의 기능을 실험해보면 보다 깊이 있는 이해를 다질 수 있을 거예요.","ogImage":{"url":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png"},"coverImage":"/assets/img/2024-05-13-5TipsandTricksToMakeYourLifeWithNextjs14Easier_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기","description":"","date":"2024-05-13 00:26","slug":"2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png\" /\u003e\n\nAPI 요청이 실패하는 이유는 네트워크 오류, 가용성 문제, 서버 문제 등이 많습니다. 응용 프로그램의 신뢰성과 안정성을 높이기 위해 재시도 메커니즘을 갖는 것이 좋은 실천 방법입니다. 실패할 경우 이 메커니즘은 동일한 API 호출을 백그라운드에서 다시 시도할 것입니다.\n\nAPI 호출이 일시적으로 실패하는 경우가 많아 재시도하면 응용 프로그램이 이러한 일시적 결함을 어느 정도 견딜 수 있음을 보장할 수 있습니다. 우리는 이러한 메커니즘을 달성하는 데 도움이 되는 구성 가능한 재시도 인터셉터를 Angular에서 만들 것입니다.\n\n# 구성(Configuration)\n\n\n\n위에서 말했듯이, 리트라이 인터셉터는 다음 구성으로 구성할 수 있습니다.\n\n- Count: API 호출을 다시 시도할 횟수입니다.\n- Delay: 다시 시도하기 전에 지연할 밀리초 수입니다.\n- Timeout: API 호출이 타임 아웃될 때까지 기다릴 밀리초 수입니다.\n\n이 구성을 위한 인터페이스와 각 구성에 대한 기본 값이 있습니다.\n\n```js\nexport interface RetryApiConfig {\n  count?: number;\n  delay?: number;\n  timeout?: number;\n}\n\n// Default Values\nconst CONFIG_DEFAULT: RetryApiConfig = {\n  count: 3, // 3번 재시도\n  delay: 500, // 500ms 대기\n  timeout: 20000, // 20초 후에 API 타임 아웃\n};\n```\n\n\n\n기본 구성은 제공되었지만 필요한 경우이를 재정의하는 방법을 제공할 것입니다.\n\n# HTTP Interceptor\n\n우리는 모든 API 호출에 대해 재시도 메커니즘을 추가하려고 합니다. Angular에서 HTTP Interceptor가 가장 적절한 위치일 것입니다.\n\nHttpInterceptor 인터페이스를 구현한 간단한 인터셉터를 만들어 봅시다.\n\n\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n\n    return next.handle(request).pipe(\n      // RxJS Operators\n    );\n}\n```\n\n옵저버블 파이프에는 재시도 메커니즘을 구현하기 위해 모든 필요한 RxJS 연산자를 추가할 것입니다. 다음 두 연산자를 사용할 예정입니다.\n\n## retry\n\n이름에서 알 수 있듯이 retry 연산자는 API 호출을 다시 시도합니다. HTTP 요청 옵저버블이 실패하면 이 방법은 다시 시도하기 위해 소스 원래 옵저버블에 다시 구독할 것입니다. 위에서 선언한 count와 delay 속성이 있는 구성 객체를 사용합니다.```\n\n\n\n## 타임아웃\n\n이 연산자는 주어진 밀리초 후에 오류 옵저버블을 발행합니다. 따라서, 임계값을 초과한 요청을 취소합니다.\n\n이제 위에서 선언한 기본 구성 개체와 함께 인터셉터에서 이 두 연산자를 사용해 봅시다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n\n    return next.handle(request).pipe(\n      retry(CONFIG_DEFAULT), // 요청 재시도\n      timeout(CONFIG_DEFAULT.timeout) // 주어진 시간 후 타임아웃\n  );\n}\n```\n\n\n\n만약 우리 애플리케이션에서 다음과 같이 이 인터셉터를 사용한다면, 예상대로 작동할 것입니다.\n\n```js\n@NgModule({\n  ...\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: RetryInterceptor,\n      multi: true\n    },\n  ],\n  ...\n})\nexport class AppModule { }\n```\n\n하지만, 누군가가 구성을 다른 값으로 재정의하고 싶다면 현재는 그 방법이 없습니다.\n\n# 구성 가능한 인터셉터\n\n\n\n여러 애플리케이션에서 사용 중인 라이브러리 내에 인터셉터가 있고, 각 애플리케이션마다 재시도 인터셉터의 다른 구성이 있는 경우, 애플리케이션이 인터셉터에 구성을 제공할 수 있는 방법이 있을까요?\n\n## Injection Tokens 사용하기\n\n애플리케이션이 구성을 재정의하려는 경우 제공할 수 있는 구성을 위한 인젝션 토큰을 생성할 수 있습니다.\n\n```js\n// 앱이 구성을 업데이트하는 데 사용할 수 있는 구성을 위한 토큰\n// 예시:\n//  {\n//     provide: RETRY_INTERCEPTOR_CONFIG,\n//     useValue: { count: 5, delay: 2000 },\n//  },\nexport const RETRY_INTERCEPTOR_CONFIG = new InjectionToken\u003cRetryApiConfig\u003e(\n  'retryConfig',\n  {\n    providedIn: 'root',\n    factory: () =\u003e {\n      return CONFIG_DEFAULT;\n    },\n  }\n);\n```\n\n\n\n이 인젝션 토큰의 유형은 우리가 위에서 선언한 인터페이스이며 \"retryConfig\"가 이름입니다. 두 번째 매개변수에서는 팩토리 함수를 사용하여 이 토큰의 기본 값을 제공합니다. 따라서 애플리케이션이 이 토큰을 제공하지 않으면 기본 객체가 대체값으로 사용됩니다.\n\n이제 이 토큰을 인터셉터에 주입해 보겠습니다.\n\n``` js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // Config 객체 주입\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n}\n```\n\n이제 애플리케이션이 제공한 구성과 기본 구성을 병합하는 방법이 필요합니다. 애플리케이션이 재시도 구성의 일부만(예: count 속성) 제공하고 다른 속성은 제공하지 않는 경우가 있을 수 있습니다.\n\n\n\n이 둘을 병합한 후 병합된 객체를 반환하는 프라이빗 함수를 만들 수 있습니다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // 구성 객체 주입\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n\n  // 병합된 객체 가져오기\n  private getConfig(): Required\u003cRetryApiConfig\u003e {\n    return {\n      count:\n        this.retryConfig.count ??\n        COUNT_DEFAULT,\n      delay:\n        this.retryConfig.delay ??\n        DELAY_DEFAULT,\n      timeout:\n        this.retryConfig.timeout ??\n        TIMEOUT_DEFAULT,\n    };\n  }\n}\n```\n\n이제 retryConfig 프로퍼티가 null 또는 정의되지 않았는지 확인하여 기본값을 취하는 것입니다.\n\n마지막으로, 이제 이 병합된 객체를 인터셉터에서 사용할 수 있습니다.\n\n\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 합쳐진 구성 가져오기\n    const config = this.getConfig();\n\n    return next.handle(request).pipe(\n      retry(config), // 여기에서 합쳐진 구성 사용\n      timeout(config.timeout)\n  );\n\n  private getConfig(): Required\u003cRetryApiConfig\u003e {\n    // 생략\n  }\n}\n```\n\n필요시 애플리케이션에서 기본 구성을 재정의할 수 있습니다.\n\n```js\n@NgModule({\n  ...\n  providers: [\n    {\n      provide: RETRY_INTERCEPTOR_CONFIG,\n      useValue: {\n        count: 2 // 이 애플리케이션에서는 count만 재정의함\n      }\n    }\n  ],\n  ...\n})\nexport class AppModule { }\n```\n\n하지만 아직도 마지막 문제가 있습니다. 특정 API 호출이 이 구성을 재정의하려면 어떻게 해야 할까요? 예를 들어, 네트워크 부하가 큰 호출은 재시도하지 않고 싶을 수 있습니다.```\n\n\n\n## HttpContext 사용하기\n\nAngular의 HttpContext에 대해 잘 모르신다면 먼저 여기를 읽어보세요. 우리는 어떤 API 호출이 응용 프로그램 레벨 또는 기본 구성을 재정의하고 싶을 때 제공할 수 있는 컨텍스트 토큰을 생성할 수 있습니다.\n\n```js\nexport const RETRY_INTERCEPTOR_CONTEXT =\n  new HttpContextToken\u003cRetryApiConfig | null\u003e(() =\u003e null);\n```\n\n컨텍스트의 기본값은 null입니다. HTTP 요청을 수행하는 동안 어떤 API 호출이라도 컨텍스트를 설정할 수 있습니다.\n\n\n\n```js\nthis.http.get(URL, {\n  context: new HttpContext().set(RETRY_INTERCEPTOR_CONTEXT, { count: 1 })\n})\n```\n\n또한 getConfig 메서드를 업데이트하여 구성을 병합할 때 context를 사용해야 합니다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // config 객체를 주입합니다.\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n\n  // 병합된 객체를 가져옵니다.\n  private getConfig(request: HttpRequest\u003cunknown\u003e): Required\u003cRetryApiConfig\u003e {\n    return {\n      count:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.count ??\n        this.retryConfig.count ??\n        COUNT_DEFAULT,\n      delay:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.delay ??\n        this.retryConfig.delay ??\n        DELAY_DEFAULT,\n      timeout:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.timeout ??\n        this.retryConfig.timeout ??\n        TIMEOUT_DEFAULT,\n    };\n  }\n}\n```\n\ncontext 토큰은 요청에서 검색됩니다. 먼저 context를 확인한 후 토큰 설정을 마지막으로 기본 설정을 확인하는 절차를 따릅니다.\n\n\n\n\n![이미지](/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_1.png)\n\n이로써 HTTP 호출에 대한 완전히 구성 가능한 재시도 메커니즘을 완성했습니다.\n\n지금까지 읽은 것이 마음에 든다면 박수 한 번 쳐주세요! 마음에 들지 않는다면 댓글을 남겨주세요😋!\n\n연결하고 싶으시다면? LinkedIn\n\n\n\n혹시 기부를 하고 싶으시다면, 커피 하나로 감사의 마음을 전해보세요! ☕️\n\n# 스택캇 🎓\n\n마지막까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해주시면 감사하겠습니다! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인해주세요","ogImage":{"url":"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png"},"coverImage":"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png","tag":["Tech"],"readingTime":7},{"title":"시계열 데이터에서의 이상치 탐지와 ChatGPT","description":"","date":"2024-05-13 00:24","slug":"2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png\" /\u003e\n\n# 소개\n\n이론적으로 아이디어는 간단해요\n\n문제는 간단하게 설명할 수 있지만 실제로, 특히 규모가 커지면, 그걸 하기가 상당히 어려워요. 이 기사 전체에서 사용할 예제를 들어보면, 특정 숫자 시리즈(아래에 그려짐)를 살펴볼 거에요\n\n\n\n```js\n[\n  1048, 829, 823, 783, 827, 894, 842, 865, 886, 894, 831, 371, 589, 391, 279,\n  246, 298, 2761, 20907, 6866, 871, 945, 844, 3516, 6242, 844, 894, 542, 797,\n  832, 828, 847, 891, 915, 896, 814, 680, 417, 177, 0, 0, 1376, 6111, 18184,\n  3546, 911, 480, 711, 820, 814, 793, 783, 834, 833, 845, 943, 882, 936, 840,\n  747, 576, 393, 261, 180, 303, 2975, 12446, 6882, 896, 919, 820, 749, 779, 812,\n  677, 903, 849, 806, 526, 796, 807, 791, 833, 813, 821, 482, 379, 245, 124,\n  382, 1776, 13503, 5255, 1757, 1945, 1615, 1092, 822, 856, 843, 862, 899, 835,\n  821, 825, 821, 837, 551, 725, 649, 412, 283, 134, 384, 886, 11587, 5876, 1251,\n  1012, 841, 855, 898, 936, 903, 921, 953, 919, 903, 904, 790, 811, 686, 522,\n  280, 179, 123, 293, 3781, 9501, 1409, 1911, 1329, 1039, 952, 894, 989, 982,\n  839, 889, 953, 937, 961, 1195, 938, 943, 458, 576, 322, 426, 248, 411, 671,\n  823, 850, 1278, 1081, 860, 820, 16,\n];\n```\n\n![2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_1](/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_1.png)\n\n우리가 관심있는 포인트는 마지막 숫자 (16)입니다. 여러분의 웹 쇼핑몰에서 지불 고객을 나타내는 숫자 목록을 상상해보십시오. 예상보다 낮은 숫자라면 경고를 받고 싶습니다. 이제 수백 개의 웹 쇼핑몰을 관리하고 있다고 상상해보십시오. 하나의 웹 쇼핑몰에서 지불 고객의 수가 감소하면 알림을 받을 수 있는 시스템에 자동으로 설정하는 방법은 무엇일까요?\n\n일반적으로는 비용이 많이 드는 SaaS 도구를 사용할 수 있지만, 그들은 비용 부담이 큽니다. 그 이유로 우리는 직접 설정할 것입니다. 기계 학습을 사용하여 이러한 유형의 문제를 해결하기를 시작하는 것은 이전 경험이 없다면 상당히 어렵습니다. Anodot 또는 유사한 서비스를 사용하고자 하지 않는 한 이 프로젝트를 시작하려면 상당한 초기 투자를 해야 할 것입니다.```\n\n\n\nChatGPT 및 유사한 도구를 사용하면, 일반적으로 몇 일 또는 몇 주가 걸리는 제품(이상 감지 엔드포인트)를 몇 시간 또는 몇 분 안에 만들 수 있습니다.\n\n# 예시\n\n우리는 상대적으로 빠르고 저렴하며 신뢰할 수 있는 방법으로 ChatGPT를 사용하여 이상 감지를 자동화할 수 있는지 확인하고 싶어요.\n\n- 우리가 필요한 첫 번째 것은 openai 라이브러리입니다.\n\n\n\nnpm install openai\n\n2. API 키를 받으세요\n\n![AnomalydetectionintimeseriesdatawithChatGPT_2 이미지](/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_2.png)\n\n3. 그리고 코드를 입력하세요\n\n\n\n```js\nimport OpenAI from 'openai';\n\nconst apiKey = 'YOUR_API KEY'\nconst model = \"gpt-3.5-turbo-0125\"\n\nconst openai = new OpenAI({\n    apiKey\n});\n\nconst formQuestion = dynamicContent =\u003e {\n    const question = `매일 사용자 수 (숫자로)가 주어졌을 때, 마지막 데이터포인트가 이상치인가요?  \n    [${dynamicContent}]\n    return json { outlier: boolean, value: number, belowLowerLimitBand: boolean}\n    outlier는 해당 지점이 이상치인지를 나타내야 합니다.\n    value는 해당 지점의 값을 가져야 합니다.\n    `\n    return question\n}\n\n\nconst askQuestion = async question =\u003e {\n    const completions = await openai.chat.completions.create({\n        messages: [{ \"role\": \"user\", \"content\": question }],\n        model,\n        response_format: { \"type\": \"json_object\" },\n        temperature: 0,\n    });\n    const { choices, usage } = completions\n    return { choices, usage }\n}\n\n\nconst answerMyQuestion = async (list) =\u003e {\n    const question = formQuestion(list)\n    const { choices, usage } = await askQuestion(question)\n    // const price = getPrice(usage, model)\n    // console.log(`The price was ${price} USD`);\n    choices.forEach(completion =\u003e {\n        const result = completion.message.content\n        const { outlier, belowLowerLimitBand, value } = JSON.parse(result)\n        console.log({ outlier, belowLowerLimitBand, value });\n    })\n}\n\n\nconst list =[\n  1048, 829, 823, 783, 827, 894, 842, 865, 886, 894, 831, 371, 589, 391, 279,\n  246, 298, 2761, 20907, 6866, 871, 945, 844, 3516, 6242, 844, 894, 542, 797,\n  832, 828, 847, 891, 915, 896, 814, 680, 417, 177, 0, 0, 1376, 6111, 18184,\n  3546, 911, 480, 711, 820, 814, 793, 783, 834, 833, 845, 943, 882, 936, 840,\n  747, 576, 393, 261, 180, 303, 2975, 12446, 6882, 896, 919, 820, 749, 779, 812,\n  677, 903, 849, 806, 526, 796, 807, 791, 833, 813, 821, 482, 379, 245, 124,\n  382, 1776, 13503, 5255, 1757, 1945, 1615, 1092, 822, 856, 843, 862, 899, 835,\n  821, 825, 821, 837, 551, 725, 649, 412, 283, 134, 384, 886, 11587, 5876, 1251,\n  1012, 841, 855, 898, 936, 903, 921, 953, 919, 903, 904, 790, 811, 686, 522,\n  280, 179, 123, 293, 3781, 9501, 1409, 1911, 1329, 1039, 952, 894, 989, 982,\n  839, 889, 953, 937, 961, 1195, 938, 943, 458, 576, 322, 426, 248, 411, 671,\n  823, 850, 1278, 1081, 860, 820, 16\n];\n\n\nanswerMyQuestion(list)\n\n// RESULT:\n// { outlier: true, belowLowerLimitBand: true, value: 16 }\r\n```  \n\n위의 내용을 보면, 시작하기에 필요한 상대적으로 작은 양의 코드입니다. 위의 코드에서 흥미로운 부분은 question 변수입니다. 이것은 ChatGPT에게 진짜 질문을 하게 하는 부분으로, 온라인 버전에서 진행하는 방법과 동일합니다.\n\n위 코드의 결과는 우리에게 다음 정보를 제공합니다:\n- 우리에게 이상치(이상현상)가 있음을 나타냅니다.\n- 우리가 기대하는 수치 이하에 있는지 여부(이 경우 더 많은 결제 고객은 문제가 아님)\n- 분석하는 값입니다.\n\n\n\n# 가격\n\n## Azure 제공품과 비교하여 (어차피 사용이 중지될 예정이지만):\n\n1000 거래에 대한 비용 (같은 질문에 대한 1000개의 답변이 있다고 가정합시다)은 0.314 미국달러입니다.\n\n이는 다른 \"이상 징후 감지\" SaaS 회사들이 부과하는 가격대 중에서도 저렴한 편에 속합니다. 그렇다면 ChatGPT가 이를 능가할 수 있을까요?\n\n\n\n## ChatGPT 가격\n\n위의 테스트에서는 현재 gpt-3.5-turbo-0125 모델을 사용 중이며, 가격은 다음과 같습니다:\n\n- 입력 토큰당 $0.0005\n- 출력 토큰당 $0.0015\n\n요청 당 가격을 계산하기 위해 OpenAI API가 요청에 사용된 토큰 양을 반환하므로 조금의 도움이 필요할 것입니다:\n\n```js\nconst getPrice = (usage, model) =\u003e {\n    const pricing = {\n        'gpt-3.5-turbo-0125': {\n            'prompt': 0.0005,\n            'completion': 0.0015,\n        }\n    }\n    const modelPrice = pricing[model]\n    const promptCost = usage['prompt_tokens'] * modelPrice['prompt'] / 1000\n    const completionCost = usage['completion_tokens'] * modelPrice['completion'] / 1000\n    const totalCost = promptCost + completionCost\n    return totalCost\n}\n```  \n\n\n\n예시 요청에 대한 응답 사용법은 다음과 같습니다.\n\n```js\n{ prompt_tokens: 440, completion_tokens: 25, total_tokens: 465 }\n```\n\n따라서, 하나의 \"답변\"에 대한 가격은 0.0002575 미국 달러입니다.\n\n따라서 1000개의 답변 당 가격은 0.2575 미국 달러입니다.\n\n\n\n그 가격은 Azure 솔루션보다 상당히 저렴하네요. 최적화를 적용하지 않은 상태에서도 여전히 동일한 결과를 얻을 수 있어요. ChatGPT에 질문을 할 때 질문의 크기를 줄이면서도 원하는 결과를 얻을 수 있다면 돈을 절약할 수 있어요!\n\n# 주의할 점\n\n모든 것을 완전히 자동화하려면 Open AI의 API를 사용해야 합니다.\n문제는 이것이 고급 챗봇 같다는 것인데, 우리가 묻는 질문에 대해 어떻게 하고 무엇을 물어볼 지에 대해 매우 신중해야 합니다. 말의 작은 변화가 완전히 다른 결과를 의미할 수 있습니다.\n이를 제한하는 방법이 있지만, 위에서 설명한 방식으로 ChatGPT를 사용할 때 결과가 어떻게 생산되었는지에 대한 통찰력이 없다는 점을 명심해야 합니다.\n특정 결과에 도달하는 방법이 중요한 경우도 있고 결과 자체가 중요한 경우도 있습니다.\n이러한 이유로 쿼리를 다양한 종류의 입력값으로 테스트하고, 잘못된 긍정 또는 부정을 받지 않도록하는 것이 현명합니다.\n\n## 결정론성\n\n\n\n현재 ChatGPT가 결정론을 보장하기 어려운 상황입니다. 즉, 동일한 질문이 다른 답변으로 이어질 수 있습니다. 이것은 자동화된 시스템을 만들고 싶을 때 매우 불편합니다. 이 문제를 피하기 위해 쿼리를 만들 때 특히 조심해야 합니다. API로 전송할 수 있는 옵션이 있어 이 문제를 최소화할 수 있지만, 장기적으로 세밀한 조정을 하는 것이 더 나은 접근법일 것으로 보입니다.\n\n# 결론\n\n큰 언어 모델은 아이디어와 현실 사이의 간극을 좁히는 데 성공했습니다. 이미 훈련된 모델을 사용하면 기계 학습에 대해 아무 것도 이해할 필요가 없습니다. 대부분의 사람들이 트랜지스터가 어떻게 작동하는지 모르지만 여전히 컴퓨터를 큰 이점으로 사용할 수 있는 방법과 마찬가지입니다.\n\n기타 SaaS 서비스가 이미 이상 탐지에 많은 \"것\"을 구축했음에도, 해당 서비스에 묶이거나 제한받지 않고 스스로 시작하는 과정은 일부 사람들이 생각하는 것만큼 어렵지는 않습니다. 그 주장의 반대 면은 OpenAI에 어느 정도 묶이게 될 것이라는 점입니다. 이는 부분적으로 사실이지만, 다른 대규모 언어 모델로 전환해도 많은 코드가 재사용 가능하다는 사실을 간과해서는 안 됩니다.\n\n\n\n이 방식을 통해 필요에 따라 자신의 속도로 프롬프트를 정제할 수 있습니다. 또한 상단에 원하는 도구를 구축할 수도 있습니다. 이는 경보 시스템, 차트 등이 될 수 있습니다.\n\n당신이 좋아할지도\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가를 칭찬하고 팔로우하는 걸 잊지 말아요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- 다양한 콘텐츠가 PlainEnglish.io에서 만나보세요","ogImage":{"url":"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png"},"coverImage":"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png","tag":["Tech"],"readingTime":8},{"title":"Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기","description":"","date":"2024-05-13 00:23","slug":"2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png\" /\u003e\n\nDay.js는 우리 앱에서 날짜를 조작할 수 있게 해주는 JavaScript 라이브러리입니다.\n\n이 기사에서는 JavaScript 앱에서 Day.js를 사용하여 날짜를 조작하는 방법을 살펴보겠습니다.\n\n# 주어진 시간 만큼 추가하거나 빼기\n\n\n\nDay.js의 Date 객체에 add 메소드를 사용하여 지정된 시간을 추가할 수 있어요.\n\n예를 들어, 다음과 같이 작성할 수 있어요:\n\n```js\nconst dayjs = require(\"dayjs\");\nconst result = dayjs().add(7, \"day\");\nconsole.log(result);\n```\n\n현재 날짜 및 시간에 7일을 추가하려면 이렇게 해보세요.\n\n\n\n우리는 첫 번째 인수로 `year`, `month`, `date`, `hour`, `minute`, `second`, 그리고 `millisecond` 단위 값 중 하나를 사용하여 add 메서드를 호출합니다.\n\n두 번째 인수는 설정할 값입니다.\n\n1월부터 시작하는 월은 JavaScript 날짜와 같이 0으로 시작합니다.\n\n각 인수 문자열에 대한 축약어도 있습니다.\n\n\n\n`y`는 `year`의 약어입니다.\n\n`M`은 `month`의 약어입니다.\n\n`D`는 `date`의 약어입니다.\n\n`d`는 `day`의 약어이며, 이는 주의 요일을 나타냅니다. 0은 일요일부터 시작하며, 6은 토요일을 의미합니다.\n\n\n\n`h`은 `시간`의 약자입니다.\n\n`m`은 `분`의 약자입니다.\n\n`s`는 `초`의 약자입니다.\n\n그리고 `ms`는 `밀리초`의 약자입니다.\n\n\n\n웹 애플리케이션에서 날짜를 조작할 수 있는 JavaScript 라이브러리인 Day.js를 사용해봤네요. \"add\"를 \"subtract\"로 대체하고 동일한 인수를 유지하여 특정 시간을 뺄 수 있습니다.\n\n# 결론","ogImage":{"url":"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png"},"coverImage":"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png","tag":["Tech"],"readingTime":1},{"title":"앵귤러를 배우는 데 얼마나 비싼가요","description":"","date":"2024-05-13 00:21","slug":"2024-05-13-HowExpensiveItIstoLearnAngular","content":"\n\n## 프로그래밍\n\n\u003cimg src=\"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png\" /\u003e\n\n앵귤러는 자주 높은 학습 비용이라고 설명됩니다. 하지만 실제로 그렇게 비싼 것은 아닙니다. 첫째, 리액트나 뷰와 같은 프레임워크와 비교하지 않겠습니다. 또한, 본문 주제로 정확히 이어지지 않는 에세이형 기사입니다. 그리고 저는 앵귤러를 사랑합니다. 이 기사는 앵귤러를 사랑하는 사람이 쓴 입장표를 가정하고 읽어주세요.\n\n\"학습 비용\"은 학습을 위해 지불하는 금액을 의미합니다. 하지만 우리는 프로그래밍을 배우기 위해 돈을 지불하는 일이 그렇게 많지 않습니다. 대신, 새로운 기술을 배우는 데 시간을 투자합니다.\n\n\n\n## 비용을 줄이고 싶으신가요?\n\n비용이라고 하면 \"줄일 수 있는\" 것이라는 생각이 듭니다. 한정된 예산 내에서 지출을 조절하기 위해 비용을 낮추고 싶어 합니다. 그렇다면 \"학습 비용\"은 얼마 정도일까요? 왜 학습 비용을 낮추어야 할까요?\n\n일본에서의 소프트웨어 개발 주류는 노동 집약적인 시스템 개발이었습니다. 이 모델로 수익을 늘리기 위해서는 노동 비용이 낮을수록 좋고, 개발 기간이 짧을수록 수익 기계가 더 잘 돌아갈 수 있습니다.\n\n시스템 요구 사항이 바뀔 때마다, 직원들이 필요한 기술을 보유하고 있는 것에 보증이 없습니다. 이런 경우 직원을 교육해야 할 필요가 있습니다. 당연히, 이 교육을 단기간에 완료하는 것이 바람직합니다. 다시 말해, 학습 비용이 낮은 기술을 선택하는 학습자에게는 동기부여가 있는 것입니다.\n\n\n\n한편, 학습자들은 어떨까요? 프로그래머의 목표가 기술을 향상시켜 시장 가치를 높이고 수입을 증가시키는 것이라면, 기술을 배우는데 드는 비용이 낮다는 것은 누구나 빠르게 이해할 수 있다는 것을 의미합니다.\n\n학습 비용이 낮은 기술은 시장 가치를 높이는 데 어려움을 겪을 것입니다. 하지만 많은 비용을 투자해 학습한 기술을 보유하더라도 일자리가 없다면 시장 가치는 증가하지 않을 것입니다.\n\n돈을 벌어들일 수 있는 기술은 시간이 지남에 따라 변할 수 있으며 도박이 될 수 있습니다. 중요한 것은 한 번 배운 기술을 다음 단계로 옮길 수 있는지 여부입니다.\n\n새로운 기술이 출시될 때마다 처음부터 다시 학습하는 데 더 많은 시간이 필요합니다. 한 번 지불한 학습 비용을 재사용하고 새로운 기술을 배움으로써 이자효과를 통해 기술을 향상시킬 수 있습니다. 다시 말하면, 단순히 학습 비용이 높거나 낮은 것이 아니라 \"무엇을 배웠는가\"가 의미 있는 것입니다.\n\n\n\n## 비용의 자본화\n\n두 가지 유형의 비용이 있습니다. 지출을 발생시키는 비용과 자산을 구매하는 비용입니다. 지불한 자본이 미래 이익을 확보하는 데 기여한다면, 비용이 아닌 자산입니다. \"일단 지불한 학습 비용을 재사용하여 새로운 기술을 배우는 것\"은 학습 비용을 자본화하는 것을 의미합니다. 학습 비용이 비싸더라도, 미래에 이윤을 창출할 자산이 될 경우 장기적인 관점에서 더 높은 비용을 지불하는 것이 나을 때가 있습니다.\n\n특정 기술을 학습하는 비용을 고려할 때, 세부 사항을 고려해야 합니다. 그 비용 가운데 일부는 자산이 되고 일부는 비용이 될 것입니다. 기술이 시장에서 가치 없어지고 낡아 날 경우, 그것은 돈 낭비에 불과합니다.\n\n반면, 패러다임 전환에도 살아남을 핵심 기술과 개념을 학습하는 것은 자산이 될 것입니다. 이는 비용과는 무관합니다.\n\n\n\n높은 비용의 기술은 주로 자산이지만, 저렴한 기술은 주로 비용이 많이 들 수 있습니다. 하나의 지침은 저렴한 제품을 사서 돈을 낭비하지 않도록 쉽게 자산으로 전환할 수 있는 기술을 선택하는 것입니다.\n\n자, 드디어 본격적으로 시작할 준비가 끝났네요. 이번 글에서는 Angular를 배우는 데 필요한 비용에 대해 이야기해 보고자 합니다. 토론을 기반으로 Angular를 배우는 데 필요한 비용과 분해를 고려해 보겠습니다.\n\n## Angular 학습 비용\n\n먼저, Angular를 시작하는 데 필요한 비용을 살펴보겠습니다. Angular를 사용하기 위해 배워야 할 기술은 HTML/CSS, TypeScript, Observable(RxJS)입니다. 게다가, npm 중심의 생태계에서 웹 개발에 대한 기본적인 이해도 필요합니다. 이러한 비용들은 어떨까요? 자산이 될까요?\n\n\n\n## HTML/ CSS\n\n이것은 자산입니다. 전 세계적으로 웹 페이지를 지원하는 주요 웹 기술입니다. 많은 사람들이 Angular을 배우기 전에도 이미 가지고 있는 자산입니다. Angular로 웹을 처음 배우는 사람들에게도 기억할 만한 기술입니다.\n\n## NPM 생태계\n\n오늘날 npm 명령을 사용하지 않고 웹 개발을 하는 것은 거의 불가능합니다. npm 주변의 생태계는 매우 발전되고 성숙하며 확립되었습니다. 물론 이것은 자산으로 기록되어야 합니다.\n\n\n\n## TypeScript\n\n이것 또한 훌륭한 자산이 될 것입니다. TypeScript는 지난 몇 년간 광범위하게 인기를 얻어왔습니다. Angular 및 React, Vue, 그리고 다른 프레임워크와 라이브러리들이 점점 더 채택하고 있습니다. Angular를 위해 배우는 TypeScript 기초는 다른 곳에도 적용할 수 있습니다.\n\n## Observable (RxJS)\n\nRxJS 자체가 Angular 외의 다른 것에 사용되지는 않을 수 있습니다. 그런 경우에는 비용으로 간주될 수 있습니다. 그러나 Observable 또는 Observer 패턴은 다양한 상황에 적용할 수 있습니다.\n\n\n\n또한 Android 및 iOS와 같은 모바일 앱을 개발할 때 RxJava 및 RxSwift와 같은 Rx 패밀리를 때때로 도입합니다. 플랫폼 간 개발 프레임워크인 Flutter에서 사용되는 Dart도 Observable과 유사한 Stream 메커니즘을 포함하여 언어 표준에 내장되어 있습니다.\n\n반응형 프로그래밍 패러다임에서 자주 발생하는 패턴이므로, Angular의 RxJS를 반응형 프로그래밍의 입문으로 간주한다면 자산으로 고려할 수 있습니다.\n\nAngular를 시작하는 데 필요한 모든 것이 자산입니다. 웹 개발에 처음 입문했더라도 Angular를 통해 습득한 기술은 미래에 도움이 될 것입니다. 시간을 쓸 가치가 있으므로 걱정할 시간이 있다면 한번 시도해 보세요.\n\n## Angular 학습 비용 (초급에서 중급)\n\n\n\n시작했더라도 배울 것이 많아요. Angular를 배우는 것은 정말 비용이 많은 공부죠. Angular에 특화된 요소에는 Component/Directive, 의존성 주입, 라우팅 등을 알아야 해요. 또한, 현대 웹 개발의 다른 측면으로는 상태 관리, 유닛 테스팅, 컴포넌트 설계, 성능 등이 있어요.\n\n당연히, 현대 웹 개발에 필요한 기술을 일반적인 자산으로 생각할 수 있어요. 여기서 Angular에 특화된 요소들을 좀 더 자세히 살펴보겠어요.\n\n## Component/Directive\n\nAngular의 Component, Directive 및 Template 메커니즘은 다른 용도로 이전할 수 없으며, 안타깝게도 대부분은 비용이 발생할 거예요. 하지만 모든 것이 그렇지는 않아요. 여기서 주의해야 할 것은 Web Components입니다.\n\n\n\nAngular의 컴포넌트는 Web Components 기술을 모델로 삼았어요. 컴포넌트에는 Custom Elements와 같이 태그가 있고, 내부 CSS는 Shadow DOM처럼 캡슐화돼 있어요. 기본 설정은 이중화된 Scoped CSS지만, 네이티브 Shadow DOM을 사용하도록 지시할 수도 있어요.\n\n더불어, Angular v7에서 소개된 Angular Elements를 사용하면 Angular 컴포넌트를 Custom Elements로 변환할 수 있어요. 커스텀 요소로 내보내면 프레임워크에 관계없이 어디에서나 사용할 수 있어요.\n\nAngular 컴포넌트는 Web Components 기술을 배우는 기회로 활용할 수 있을 뿐만 아니라 실제로 Web Components를 활용하는 응용 프로그램을 개발하는 도구로 활용할 수도 있어요. 이점을 고려해 Angular에 투자하는 것은 틀림없는 선택이 될 거예요.\n\n## 의존성 주입\n\n\n\n웹 프론트 엔드에서는 작은 부분이지만, 의존성 주입은 서버 측 언어에서 흔히 사용되는 기술입니다. 이미 의존성 주입을 배운 사람들에게는 Angular에서 알려진 의존성 주입보다 장벽이 낮아질 가능성이 더 높습니다.\n\n또한, TypeScript의 유형 정보를 사용하는 선언적 DI 시스템은 매우 칭찬받고 있으며, Angular 이외의 곳에서도 사용하기 위해 모방 메커니즘이 만들어진 경우가 있습니다. InversifyJS와 NestJS가 그 예시입니다. 이 관점에서도 총 비용이라고 말할 수 없습니다.\n\n## 라우팅\n\nAngular 라우팅은 프레임워크와 강하게 연관된 부분이므로 Angular 이외의 것으로 전환하는 것은 쉽지 않을 것입니다. 이것을 비용으로 처리하면서 학습해 보세요.\n\n\n\nAngular을 배우는 비용은 초보자에서 중급으로 스킬을 향상할수록 증가합니다. 그러나 중급 수준에 도달하면 응용 프로그램을 고려하는 데 더 많은 시간을 보내게 될 것입니다.\n\n당신은 컴포넌트 디자인, 테스트 디자인, Components/directives 활용 및 의존성 주입에 대해 생각하기 시작할 것입니다. 확장 가능성과 생산성을 향상시키는 수단으로 사용할 때, Angular을 손발처럼 사용하고 응용 프로그램에 집중할 수 있다는 것은 당신이 중급 장벽을 넘었음을 나타낸다는 신호입니다.\n\n## 결론: Angular을 배우는 비용이 높은가요?\n\n네, 저렴하지 않습니다. 응용 프로그램 개발의 최단 경로였다면 훨씬 저렴한 프레임워크로 배울 수 있었을 것입니다. 그러나 Angular는 웹 표준 및 생태계와 일치하는 미래 지향적 스택을 선택했습니다.\n\n\n\n이를 이루기 위해 어떤 학습을 해야 할 것입니다. 이 학습은 부수적으로 느껴질 수 있지만, 그 중 많은 부분이 자산이 될 것입니다. 습득한 자산을 기반으로 학습함으로써, 더욱 중요한 자산이 되어 여러분의 스킬을 복리로 향상시킬 수 있을 것입니다.\n\n극단적으로 말하자면, 수익이 비용을 웃돌 정도라면 비용이 어느 정도 높더라도 지불할 가치가 있습니다. 그러나 현실적으로는 수익이 발생할지 여부에 대해 불확실성이 있기 때문에 망설이게 됩니다. 하지만 그런 경우에는 리스크를 헤지하는 것을 고려해야 합니다. 실패하더라도, 일부 자산이라도 남아있다면 완전한 손실보다는 낫습니다. Angular 기술을 활용하면 많은 자산을 보호하고 리스크를 헤징할 수 있습니다.\n\n또한 커뮤니티가 학습 비용을 줄이도록 허용합니다. 여러분의 뒤를 이어서 누군가가 다른 이에게 이어풀 수 있도록 도움이 되는 지식을 남길 수 있습니다. 습득한 지식을 남기면 미래에 누군가에게 도움을 줄 수도 있습니다. 학습 비용을 평가할 때, 개방적인 커뮤니티의 존재를 고려해야 합니다.\n\n# Stackademic\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png"},"coverImage":"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs에서 프로세스와 스레드 이해하기","description":"","date":"2024-05-13 00:19","slug":"2024-05-13-UnderstandingProcessesandThreadsinNodejs","content":"\n\n\n![Understanding Processes and Threads in Node.js](/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png)\n\nNode.js는 주로 단일 쓰레드 이벤트 루프 모델에서 작동합니다. 이는 코드가 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 Node.js는 또한 libuv와 같은 라이브러리를 통해 파일 읽기와 같은 I/O 작업과 같은 특정 작업을 백그라운드 쓰레드로 제공합니다. 이러한 백그라운드 쓰레드는 파일 I/O, 네트워크 요청 및 DNS 조회와 같은 작업을 처리하여 주 쓰레드가 다른 이벤트를 계속 처리할 수 있도록 합니다.\n\n# 프로세스\n\n프로세스는 운영 체제에서 실행 중인 프로그램입니다. 각 프로세스는 자체 메모리를 가지며 다른 실행 중인 프로그램의 메모리에 접근할 수 없습니다. 무한 루프가 있는 노드 프로그램을 만들어 실행했을 때 종료되지 않도록 만들어 봅시다.\n\n\n\n`process.js` 라는 파일을 만들어서 다음 코드를 입력해 주세요:\n\n```js\nconst process_name = process.argv.slice(2)[0];\nlet count = 0;\nwhile (true) {\n  count++;\n  if (count === 200 || count === 400) {\n    console.log(`${process_name}: ${count}`);\n  }\n}\n```\n\n다음 명령어를 사용하여 이 프로그램을 실행해 봅시다. Node.js 명령어를 사용해주세요:\n\n```js\nnode process.js A \u0026\n```\n\n\n\nA는 프로그램에 전달되어 process_name 변수에 저장되는 명령행 인수입니다. 끝의 \u0026는 Node 프로그램을 백그라운드에서 실행할 수 있게 해서 쉘에서 더 많은 명령을 입력할 수 있도록 합니다.\n\n```js\n출력\n[1] 15228\nA: 200\nA: 400\n```\n\n숫자 7754는 운영 체제가 할당한 프로세스 ID입니다. A: 200 및 A: 400은 프로그램의 출력입니다.\n\nnode 명령을 사용하여 프로그램을 실행할 때(사용하는 것이 Node.js를 가정합니다), 프로세스가 생성됩니다. 운영 체제는 프로그램을 위한 메모리를 할당하고, 컴퓨터 디스크에서 프로그램 실행 파일을 찾아 메모리에 로드하는 작업 등을 처리합니다. 이후, 프로그램에 프로세스 ID(PID)를 할당하고 실행을 시작합니다. 이 단계에서 프로그램이 프로세스가 됩니다.\n\n\n\nNode 프로세스를 빠르게 요약하려면:\n\n```js\nps |grep node\n```\n\n```js\n출력\n15228 pts/1    00:00:15 node\n```\n\n하나의 프로그램에서 여러 프로세스를 만들 수 있습니다. 예를 들어, 다음 명령을 사용하여 서로 다른 인수로 세 개의 추가 프로세스를 만들고 백그라운드에 넣을 수 있습니다:\n\n\n\n```js\nnode process.js B \u0026 node process.js C \u0026 node process.js D \u0026\n```\n\n위 명령을 실행한 후에 출력은 아래와 유사할 수 있지만 순서가 달라질 수 있습니다:\n\n```js\nOutput:\n[1] 15925\n[2] 15926\n[3] 15927\nB: 200\nC: 200\nB: 400\nD: 400\nC: 400\nD: 400\n```\n\n출력을 주의 깊게 살펴보면 실행 순서가 고정되어 있지 않다는 것을 알 수 있습니다. B, C, D 순으로 시작했지만 다른 순서로 끝날 수 있습니다. 이 동작의 이유는 OS가 각 프로세스를 실행할 때 결정하는 스케줄링 알고리즘 때문입니다.\n\n\n\n단일 코어 머신에서는 프로세스가 동시에 실행됩니다. 이것은 OS가 프로세스 간을 일정 간격으로 전환하는 것을 의미합니다. 예를 들어, 프로세스 D가 일정 시간 동안 실행되고 나서 그 상태가 어딘가에 저장되고 OS가 프로세스 B를 실행할 때까지 일정 시간을 예약합니다. 이 작업은 모든 작업이 완료될 때까지 계속해서 번갈아가며 반복됩니다. 결과적으로 각 프로세스가 완료된 것처럼 보일 수 있지만 실제로는 OS 스케줄러가 계속해서 그 사이를 전환합니다.\n\n4코어(다중 코어) OS에서는 OS가 각 프로세스를 동시에 각 코어에서 실행하기 위해 예약합니다. 이를 병렬 처리라고 합니다. 그러나 4개의 프로세스(총 8개 프로세스)를 생성하면 각 코어가 완료될 때까지 두 개의 프로세스를 동시에 실행합니다.\n\n현재 실행 중인 모든 Node 프로세스를 kill 명령어로 중지하려면:\n\n```js\nsudo kill -9 `pgrep node`\n```\n\n\n\n# 쓰레드\n\nNode.js의 쓰레드는 프로세스와 유사하지만, 하나의 프로세스의 메모리 내에서 작동합니다. 프로세스는 자체 메모리 공간을 갖지만, 각 쓰레드는 부모 프로세스의 메모리를 공유합니다. Node.js에서 프로세스를 생성할 때 worker_threads 모듈을 사용하여 JavaScript 작업을 동시에 실행할 수 있는 여러 쓰레드를 생성할 수 있습니다. 쓰레드는 메시지 전달을 통해 서로 통신하거나 프로세스의 메모리에서 데이터를 공유하여 작동합니다. 프로세스와는 달리 쓰레드를 생성하는 것은 운영 체제에서 추가적인 메모리를 필요로하지 않아 가벼우며 작업을 병렬로 실행하는 데 효율적입니다.\n\n쓰레드를 실행할 때, 그들은 프로세스와 유사하게 작동합니다. 단일 코어 시스템에서 다중 쓰레드가 있는 경우, 운영 체제는 정기적으로 그들 사이를 전환하여 각 쓰레드가 단일 CPU에서 직접 실행될 수 있도록 합니다. 반면에, 다중 코어 시스템에서는 운영 체제가 모든 코어에 걸쳐 쓰레드를 스케줄링하여 JavaScript 코드가 동시에 실행되도록 합니다. 사용 가능한 코어보다 더 많은 쓰레드가 생성된 경우, 각 코어는 여러 쓰레드를 동시에 처리하여 리소스 사용을 최적화합니다.\n\n# 숨겨진 Node.js의 쓰레드\n\n\n\nNode.js는 종종 \"멀티스레드\"라고 불리는데, 이는 입력/출력(I/O) 작업을 더 효율적으로 처리하기 위해 추가 스레드를 활용하기 때문입니다. 작동 방식은 다음과 같아요:\n\n소개에서 설명한 대로, JavaScript 자체는 단일 스레드이므로 한 번에 한 가지 작업을 처리합니다. 프로그램이 파일을 읽거나 네트워크 요청을 하려고 할 때, 이러한 작업이 끝날 때까지 대기하여 주 스레드를 차단시킬 수 있습니다.\n\n그러나 Node.js는 libuv 라이브러리를 구현하여 4개의 추가 스레드를 Node.js 프로세스에 제공합니다. 이러한 스레드를 사용하여 I/O 작업이 따로 처리되며, 작업이 완료되면 이벤트 루프는 해당 I/O 작업에 연결된 콜백을 마이크로태스크 큐에 추가합니다. 주 스레드의 호출 스택이 비어있을 때, 콜백이 호출 스택에 푸시되어 실행됩니다. 명확히 하자면, 주어진 I/O 작업에 대한 콜백이 병렬로 실행되지는 않지만, 파일을 읽거나 네트워크 요청하는 작업 자체가 스레드의 도움으로 병렬로 실행됩니다. I/O 작업이 끝나면 해당 콜백이 주 스레드에서 실행됩니다.\n\n이 4개의 스레드 외에도 V8 엔진은 자동 가비지 수집과 같은 작업을 처리하기 위한 추가 2개의 스레드를 제공합니다.\n\n\n\n노드 프로세스마다 총 일곱 개의 스레드가 있다는 내용입니다. 우리가 process.js 파일을 다시 실행하고 백그라운드에서 돌리는 것으로 이를 확인해보겠습니다:\n\n```js\nnode process.js A \u0026\n```\n\n이제 스레드를 확인하기 위해 top 명령어를 사용하여 프로세스 ID를 전달하겠습니다.\n\n```js\ntop -H -p 19821\n```\n\n\n\n위의 명령을 실행하면, 출력물은 다음과 유사할 것입니다:\n\n![Image](/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_1.png)\n\n출력물에서 보듯이, Node.js 프로세스에는 총 일곱 개의 스레드가 있습니다: 자바스크립트를 실행하는 주 스레드 하나, 네 개의 Node.js 스레드, 그리고 두 개의 V8 스레드가 있습니다.","ogImage":{"url":"/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png","tag":["Tech"],"readingTime":4}],"page":"48","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"48"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>