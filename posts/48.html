<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="GitHub Copilot의 탑 10 기능" href="/post/2024-06-20-Top10GitHubCopilotFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GitHub Copilot의 탑 10 기능</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고급 데이터 구조 및 알고리즘 더미용 신경망" href="/post/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고급 데이터 구조 및 알고리즘 더미용 신경망</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 데이터 유형" href="/post/2024-06-20-JavaScriptDataTypes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 데이터 유형" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptDataTypes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 데이터 유형" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 데이터 유형</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" href="/post/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템 디자인 면접 아마존 플립카트" href="/post/2024-06-20-SystemDesignInterviewAmazonFlipkart"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템 디자인 면접 아마존 플립카트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템 디자인 면접 아마존 플립카트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시스템 디자인 면접 아마존 플립카트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" href="/post/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CORS를 활용한 효율적인 RSS JavaScript 파서 소개" href="/post/2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CORS를 활용한 효율적인 RSS JavaScript 파서 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CORS를 활용한 효율적인 RSS JavaScript 파서 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CORS를 활용한 효율적인 RSS JavaScript 파서 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="깃허브에서 SSH 키 생성하는 빠른 스텝별 가이드" href="/post/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="깃허브에서 SSH 키 생성하는 빠른 스텝별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="깃허브에서 SSH 키 생성하는 빠른 스텝별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">깃허브에서 SSH 키 생성하는 빠른 스텝별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="나는 UX 디자이너로서 웹앱을 코딩했어" href="/post/2024-06-20-IcodedawebappasaUXdesigner"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="나는 UX 디자이너로서 웹앱을 코딩했어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IcodedawebappasaUXdesigner_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="나는 UX 디자이너로서 웹앱을 코딩했어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">나는 UX 디자이너로서 웹앱을 코딩했어</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJs를 사용한 테이블 페이지네이션 구현하기 간단한 안내" href="/post/2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJs를 사용한 테이블 페이지네이션 구현하기 간단한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJs를 사용한 테이블 페이지네이션 구현하기 간단한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJs를 사용한 테이블 페이지네이션 구현하기 간단한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link posts_-active__YVJEi" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"GitHub Copilot의 탑 10 기능","description":"","date":"2024-06-20 01:18","slug":"2024-06-20-Top10GitHubCopilotFeatures","content":"\n\n## 더 행복하고 생산적인 개발자가 되어보세요\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png)\n\nGitHub Copilot은 인공 지능 기술을 활용한 페어 프로그래밍 도구로, 빠르게 코딩하고 생산성을 향상시킬 수 있습니다.\n\n이 글에서는 GitHub Copilot의 최고 10가지 기능에 대해 이야기해볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 워크스페이스 에이전트\n\nCopilot @workspace agent은 우리의 코드를 강화하여 워크스페이스의 전체 맥락을 분석하고 이해함으로써 프로젝트의 아키텍처와 의존성과 일치하는 권장 사항을 제공할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_1.png)\n\n# 2. 코딩 질문하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 확실하지 않거나 기억하지 못하는 경우, 문서를 찾아보거나 구글 검색하지 않고도 Copilot에게 문법이나 일반 프로그래밍 개념에 대해 물어보세요. Copilot은 자연어나 코드 스니펫 형식으로 답변을 제공합니다. 예를 들어, 배열의 합을 계산하는 방법에 대해 물어보는 등의 질문을 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_2.png)\n\n또한, 코드의 동작이나 작동 방식을 이해하고 싶은 경우, 설명을 요청할 수 있습니다.\n\n![다른 이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 코드 완성\n\n코딩을 시작하면 Copilot은 파일의 컨텍스트를 분석하고 편집기에서 제안을 제공합니다. 예를 들어, arraySum이라는 메서드 이름을 입력하면 Copilot이 코딩 스타일과 일치하는 구현을 제안합니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_4.png)\n\n# 4. 코드 리팩터링 및 개선\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCopilot에 선택한 코드를 리팩토링하거나 개선할 것을 요청할 수 있습니다. 이는 우리 코드베이스의 맥락을 활용하여 리팩터링이나 개선 사항을 분석하고 제안할 것입니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_5.png)\n\n## 5. 수정해주세요\n\n코드에 오류나 경고가 있는 경우, Copilot은 오류 메시지, 코드 구문 및 주변 코드를 기반으로 가능한 수정 사항을 제안할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_6.png)\n\n# 6. 유닛 테스트 케이스 생성\n\nCopilot은 우리의 테스트 프레임워크와 코딩 스타일을 식별하고 오류, 널 값 또는 예기치 않은 입력 데이터 유형을 다루기 위한 테스트 케이스를 제안합니다.\n\n이전 arraySum 함수에 대한 테스트 케이스를 생성해 보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_7.png\" /\u003e\n\n생성된 테스트 케이스:\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_8.png\" /\u003e\n\n# 7. 커밋 메시지 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 커밋 메시지를 작성하기 귀찮다면, Copilot이 우리를 위해 작성해줄 거예요. VS Code에서 커밋 메시지 텍스트 상자 옆의 화문 아이콘을 클릭해보세요.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_9.png)\n\n# 8. 언어 번역\n\n이제 다른 프로그래밍 언어를 배울 필요가 없어졌어요. Copilot은 선택한 코드를 다른 언어로 번역할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 arraySum JavaScript 함수를 Python으로 번역해 보겠습니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_10.png)\n\n## 9. 이름 바꾸기 제안\n\n코드에서 심볼의 이름을 변경할 때 Copilot은 해당 심볼의 문맥을 기반으로 새 이름을 제안합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전의 arraySum 함수의 이름을 바꾸어 봅시다:\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_11.png)\n\n# 10. VSCode Agent\n\n만약 VS Code 기능을 수행하거나 상호 작용할 방법을 찾고 계시다면, Copilot @vscode 에이전트가 원하시는 기능에 대해 자세히 설명하거나 명확히 해주는 데 도움이 될 수 있습니다. 예를 들어, 우리가 기능을 설명하면, Copilot이 VS Code에서 해당하는 기능을 결정하는 데 도움을 줄 것입니다. 파일을 저장할 때 끝에 새로운 라인을 추가하도록 요청해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_12.png\" /\u003e\n\n# 결론\n\n이제 GitHub Copilot의 최고 10가지 기능을 알았으니, 더 행복하고 생산적인 개발자가 되실 수 있습니다.\n\n읽어주셔서 감사합니다. 유용한 정보였기를 바라며, 즐겁게 코딩하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원","ogImage":{"url":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"},"coverImage":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"고급 데이터 구조 및 알고리즘 더미용 신경망","description":"","date":"2024-06-20 01:15","slug":"2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies","content":"\n\n## 자바스크립트에서 첫 번째 신경망 구현하기\n\n![image](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png)\n\n신경망은 매력적이고 흥미로운 것처럼 들립니다. 하지만 정확히 무엇이고, 어떻게 그런 마법을 달성하는 걸까요? 그리고 무엇보다 중요한 건, 전문적인 데이터 과학자가 아니어도 하나를 만들 수 있을까요?\n\n이 기사에서는 신경망의 기본 원리와 기존 도구를 사용하여 직접 구현하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 매우 실용적 일 것입니다. 마지막에 여러분께 자신만의 신경망을 만들어 터미널에서 기본 ASCII 그림을 그리는 방법을 안내해 드리겠습니다.\n\n시작해 봅시다!\n\n## 신경망 이해하기\n\n신경망은 \"뉴런(neurons)\"으로 알려진 개별 요소로 구성된 특수한 유형의 데이터 구조입니다. 뉴런은 레이어로 그룹화되어 있으며 다른 레이어의 다른 뉴런과 연결됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 기본적인 신경망 구조 중 하나는 피드포워드 신경망입니다. 이들은 입력 레이어, 하나 이상의 은닉 레이어 및 출력 레이어로 구성되어 있으며, 정보는 한 방향으로만 흐릅니다 (입력 레이어에서 출력 레이어로).\n\n이것이 무엇을 의미하는지 보여주는 기본 다이어그램이 있습니다:\n\n![다이어그램](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_1.png)\n\n기본적으로 입력 정보는 입력 레이어에 입력되고, 거기서 \"가중치\"라고 불리는 값과 특정 활성화 함수(값을 취하여 0과 1 사이의 값을 출력하는 함수)를 사용하여 데이터가 변환됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 뉴런 그룹을 결합하고 가중치를 적절하게 조정하면 (즉, 네트워크를 \"학습\"할 때 하는 것), 결합된 출력은 제공한 입력에 기초해 기대한 출력(또는 거의 동일한 값)이 됩니다.\n\n예를 들어, XOR 방정식을 해결하는 기본적인 예는 다음과 같습니다:\n\n\n[0,0] =\u003e 0\n[0,1] =\u003e 1\n[1,0] =\u003e 1\n[1,1] =\u003e 0\n\n\n하지만 2개의 입력과 1개의 출력 뉴런을 가진 피드포워드 네트워크를 만들면, 한 번 학습되면 0 또는 1의 모든 조합을 입력하고 실제로 XOR 동작을 프로그래밍하지 않고도 예상한 XOR 출력을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이 왜 신경망을 사용하고 싶어하는지의 주된 이유입니다. 실제로 모든 규칙을 코딩하지 않고도 일반화된 행동을 달성하기 위해서입니다.\n\n## 신경망의 종류\n\n다양한 종류의 신경망이 있으며, 각각의 특징과 용도가 있습니다. 여기에서 모든 종류를 나열하고 그들을 사용하고 구현하는 방법에 대해 깊게 설명하는 것은 이 글의 실용적인 접근을 방해할 수 있습니다.\n\n따라서 가장 흔한 신경망 유형의 목록을 여기에 제시합니다. (다른 유형도 있다는 것을 염두에 두세요):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 피드포워드 신경망: 앞에서 이미 다루었습니다. 이들은 가장 흔하고 간단한 신경망이지만 여전히 유효한 사용 사례가 있습니다.\n- 합성곱 신경망(CNNs): 이미지 인식 및 처리 작업용으로 설계된 신경망입니다. 이미지 데이터에서 특징을 학습하는 데 효과적이며 컴퓨터 비전 응용 프로그램에서 일반적으로 사용됩니다.\n- 순환 신경망(RNNs): 언어 번역이나 음성 인식과 같은 순차 데이터 처리 작업용으로 설계된 신경망입니다. 순차 데이터의 패턴을 학습하는 데 효과적이며 자연어 처리(NLP) 응용 프로그램에서 일반적으로 사용됩니다.\n- 오토인코더: 차원 축소 및 특성 학습 작업용으로 설계된 신경망입니다. 입력 레이어, 은닉 레이어 및 출력 레이어로 구성되어 입력 데이터를 출력 레이어에서 재구성하도록 훈련됩니다.\n- 생성적 적대 신경망(GANs): 가상 데이터 생성용으로 설계된 신경망입니다. 생성자 네트워크가 가상 데이터를 생성하고, 식별자 네트워크가 가상 데이터를 실제 데이터와 구분하려고 합니다.\n- 트랜스포머: NLP 및 텍스트 생성에 매우 효과적입니다. 많은 자연어 처리 작업에 대해 최첨단 결과를 크게 개선했으며 이 분야에서 널리 사용되고 있습니다. 예를 들어, ChatGPT는 훈련 과정에서 이러한 유형의 NN(신경망)을 사용했습니다.\n\n원하는 행동 유형에 따라 하나를 선택합니다. 이 기사에서는 간단하게 유지하고 첫 번째 신경망에 초점을 맞출 것입니다.\n\n읽어주셔서 감사합니다! 제 무료 뉴스레터를 구독해보시겠어요? IT 산업에서 20년 동안의 지혜를 모두가 공유하는 \"The Rambling of an old developer\"에 가입해보세요!\n\n# 첫 번째 신경망 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 우리의 첫 번째 시도이므로 실용적인 방법을 찾고 있기 때문에, 바퀴를 다시 발명할 필요가 없다고 생각해요. 우리가 원하는 것을 달성하는 데 도움이 되는 도구들이 많이 있으니, 우리가 지금 바로 선택하면 돼요.\n\n제 경우에는 저는 Synaptic을 선택했어요. 낮은 수준의 인터페이스를 제공하지만 기본적인 구성 요소는 이미 갖춰져 있어요. 그래서 심층 수학에 신경 쓸 필요없이 NN을 구축하는 데 필요한 요소를 잘 이해할 수 있어요.\n\n우리의 NN을 사용하여 XOR 방정식을 해결하는 대신, 그것을 사용하여 터미널에 ASCII 이미지를 \"그리고\" 싶었어요. 이미지는 상대적으로 작아서 교육 시간을 짧게 유지하려고 해요.\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 그려고 하는 행렬 또는 더 정확히 말하자면, NN에게 그리는 방법을 배우도록 요청하는 것입니다. 그래서 우리가 할 일은 이전과 동일한 3개의 레이어를 가진 NN을 생성할 것입니다:\n\n- X와 Y 좌표를 위한 2개의 뉴런이 있는 입력 레이어.\n- 15개의 뉴런이 있는 은닉 레이어.\n- 그리고 각 좌표 세트마다 1 또는 0을 출력해야 하는지 이해하기 위해 1개의 뉴런만 있는 출력 레이어.\n\n우리는 Synaptic을 사용하여 NN을 다음과 같이 설정할 것입니다.\n\n이제 훈련에 대해, 가중치 간의 학습률을 0.3으로 설정할 것입니다. 이는 뉴런 간의 가중치가 각 반복에서 0.3씩 값을 조정할 것을 의미합니다. 그런 다음 그 결과를 출력해야 하는 것과 비교하고, 다음 반복에서 이에 따라 조정할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상수 이미지에는 내가 원하는 출력이 포함되어 있어요. 이를 사용하여 네트워크를 훈련할 거에요. 0과 1로 이루어진 8x6 매트릭스에요.\n\n그런 다음 훈련을 위해 30,000회의 반복을 실행할 거에요. 매 \"픽셀\"마다 activate 메소드를 호출할 거에요. 이 메소드는 입력을 입력 레이어에 넣고 NN을 실행해요. 그런 다음 propagate 메소드를 사용하여 learningRate와 마지막 활성화값에 대한 예상 값을 사용해 네트워크가 자신을 조정하게 할 거에요.\n\n참고로, \"y * 8 + x\"라는 작은 공식은 직교 좌표를 사용하여 1차원 배열을 탐색하는 작은 속임수에요. 더 자세히 말하면 \"`y 좌표` * `폭` + `x 좌표`\"이고, 2차원 배열이 더 이상 필요하지 않아요.\n\n훈련이 끝나면 좌표를 다시 통과시키고 activate할 차례에요. 이번에는 결과를 출력할 거에요. 그를 위해 다음과 같은 함수를 만들었어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 Y 좌표에 대해 활성화 결과를 리스트에 저장하고, 한 행이 완료되면 (해당 Y에 대한 모든 X 좌표를 거쳤을 때) 출력합니다.\n\n여기서 Math.round를 사용하고 있는 이유는 NN의 출력이 0 또는 1이 아니라 둘 사이의 숫자일 것이기 때문입니다.\n\n결과를 보세요:\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 결과가 완벽하지 않음을 알 수 있어요. 그 이미지에는 2개의 오류가 있다는 걸 주목해주세요. 조금 더 훈련을 시키면 더 나은 결과를 얻을 수 있을지도 모르지만, 이것은 저가 얻은 최상의 결과 중 하나에요.\n\n정확한 알고리즘을 코딩하지 않고도 일반적인 행동을 달성하려고 노력하는 만큼, 항상 올바른 답을 얻을 수 있는 것은 아니며 그 유사한 정도에 그치게 될 거예요.\n\n그래서 Dall-e나 Midjourney로 이미지를 생성할 때 이상한 손이 나타나거나, ChatGPT가 가끔 사실이 아닌 문장을 작성하거나 버그가 있는 코드를 생성하는 이유에 대해 이해할 수 있어요. 그들의 훈련 결과에 기반하여 유사한 정도의 답변을 제시할 뿐이기 때문이에요.\n\n신경망은 입력값의 다양한 수를 적응시켜야 하는 행동을 달성하려는 경우나 특정하게 코딩하는 데 많은 노력이 필요할 때 매우 유용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 대신, 적절한 유형의 입력을 사용하여 훈련을 통해 충분히 가까운 결과를 얻을 수 있어요.\n\n이전에 NN을 사용해 보셨나요? 그것들을 어떤 목적으로 사용했나요?\n\n# 레고처럼 재사용 가능한 구성 요소로 앱을 만들어 보세요\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트의 오픈 소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고 여러 응용 프로그램 간에 공유하세요. 협업하고 빠르게 개발하기가 더욱 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 간단하게 만들고 원하는 작업 흐름에 대해 최상의 경험을 누리세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"},"coverImage":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png","tag":["Tech"],"readingTime":6},{"title":"자바스크립트 데이터 유형","description":"","date":"2024-06-20 01:14","slug":"2024-06-20-JavaScriptDataTypes","content":"\n\n이해하기 쉬워요\n\n## JavaScript는 총 여덟 가지의 다른 데이터 유형을 지원합니다. 일곱 가지의 기본 유형과 하나의 비 기본 유형이 있어요.\n\n이러한 데이터 유형을 이해하는 것은 효율적이고 버그 없는 코드를 작성하는 데 중요해요. 이 블로그에서는 각 데이터 유형에 대해 자세히 살펴볼 거에요.\n\n데이터 유형에 대해 계속 진행하기 전에 JavaScript의 console.log() 메서드에 대해 이야기하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`console.log()`은 웹 콘솔에 메시지를 출력하는 JavaScript의 메서드입니다. 일반적으로는 변수의 값이나 표현식의 결과와 같은 정보를 인쇄하기 위해 디버깅 목적으로 사용되며, 이를 통해 개발자들은 코드의 동작을 검사할 수 있습니다.\n\n```js\nconsole.log(\"Hello, world!\"); // 출력: Hello, world!\nconsole.log(42);              // 출력: 42\n\n// 변수 출력\nlet greeting = \"Hello, world!\";\nconsole.log(greeting); // 출력: Hello, world!\n```\n\n- Number\n\nNumber 타입은 정수와 부동 소수점 숫자를 모두 나타냅니다. JavaScript는 두 유형을 구분하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 정수 값\nconst age = 21;\n\n// 부동 소수점 값\nconst temperature = 32.5;\n```\n\n2. 문자열\n\n문자열 유형은 텍스트를 형성하는 문자 시퀀스를 나타냅니다.\n\n```js\n// 문자열 예시\nconst name = \"제 이름은 요기이고 웹 개발자입니다\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 불리언\n\n불리언 유형에는 true 또는 false의 두 가지 값만 있습니다. 일반적으로 조건문에서 사용됩니다.\n\n```js\n// 불리언 예시\n\n// True 저장\nconst isAdmin = true;\n\n// False 저장\nconst isLoggedIn = false;\n```\n\n4. 널\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnull 타입은 의도적으로 어떤 객체 값도 없음을 나타냅니다. 기본적으로 변수를 정의하고 그 때 어떤 값을 추가하고 싶지 않을 때, 그리고 나중에도 해당 변수에 값을 추가하고 싶지 않을 때 사용합니다.\n\n```js\n// Null의 예시\nconst dummy = null;\n```\n\n5. Undefined\n\n값이 할당되지 않은 변수는 undefined 타입입니다. 기본적으로 변수를 선언했지만 아직 값이 할당되지 않은 상태를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Undefined 예제\nlet name;\n```\n\n6. BigInt\n\nBigInt을 사용하면 Number 타입이 처리할 수 있는 정수보다 큰 정수를 표현할 수 있습니다.\n\nNumber에서 BigInt로 변환하려면 값 뒤에 `n`을 추가하기만 하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// BigInt의 예시\nlet Money = 54215484215484212n;\n```\n\n7. Symbol\n\nSymbol은 고유하고 변경할 수 없는 데이터 유형으로서, 객체 속성의 식별자로 사용할 수 있습니다.\n\n여기서 '변경할 수 없는'이란 한 번 선언된 심볼의 값은 변경할 수 없다는 의미이고, '고유한'이란 동일한 값으로 여러 심볼 변수를 만들더라도 각각 메모리에서 고유하다는 의미입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Symbol 예제\nconst Variable_one = Symbol(\"abc\");\nconst Variable_two = Symbol(\"abc\");\n```\n\n위 예제를 보면 변수 one과 two가 심볼 데이터 유형의 동일한 값을 가지고 있는 것처럼 보이지만, 두 변수 간에는 어떤 유사성도 없습니다. 두 변수는 서로 다릅니다.\n\n8. 객체\n\n객체는 속성들의 모음이며, JavaScript에서 유일한 원시 데이터 윕입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서는 객체 키가 객체 내의 특정 속성에 대한 고유 식별자로 작용합니다. 이러한 키는 문자열 또는 숫자가 될 수 있습니다.\n\n일반적으로 문자열은 키로 직접 사용되지만, 숫자는 사용될 때 자동으로 문자열로 변환됩니다.\n\n이 유연성을 통해 객체는 자바스크립트 응용 프로그램 내에서 구조화된 데이터의 저장 및 검색을 용이하게 합니다.\n\n```js\n// 객체 예제\nlet obj = {\n  name: \"yogi parmar\",\n  age: 21,\n  isGood: true,\n  storingNull: null,\n  undefinedPropertu: undefined,\n  1: \"one\",\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 다음 블로그에서는 자바스크립트에서 변수의 기초를 탐구할 것이며, 데이터를 저장하는 용기로서의 역할에 중점을 둘 것입니다.\n게다가, 변수의 이름 짓는 데 대한 최상의 실천법과 관습에 대해 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png","tag":["Tech"],"readingTime":3},{"title":"사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결","description":"","date":"2024-06-20 01:11","slug":"2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png\" /\u003e\n\n우리는 빠르게 움직이는 디지털 시대에 살고 있습니다. 사용자들은 내용에 즉시 접근하길 원하기 때문에 웹 사이트의 성능은 매우 중요합니다. 페이지가 느리게 로딩되면 사용자들은 답답함을 느끼고 잠재적인 고객을 놓칠 수 있습니다. 서버 측 렌더링(SSR)은 서버 측에서 HTML을 생성하여 사용자 경험에 부근을 가져다주는 축복처럼 나타났지만, 핵심적으로 최적화되어야 합니다.\n\n# 속도에 대한 필요성\n\n연구는 항상 느린 페이지가 사용자 참여와 전환율에 심각한 영향을 미친다는 것을 발견해왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 소비자들은 판단을 빨리 내립니다. 연구에 따르면, 88%의 사용자는 나쁜 경험 후 웹사이트로 다시 돌아오기를 더욱 꺼립니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_1.png)\n\n또 다른 연구에 따르면, 모바일 페이지 로드 시간을 0.1초 줄이면 소매 사이트의 전환율이 8.4% 상승하고 여행 사이트의 경우 10.1% 증가했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이거 엄청 커. 그렇기 때문에 웹 성능을 무시할 수 없어요.\n\n# Angelone SSR 아키텍처\n\n우리는 주요 UI 기술 스택으로 Sveltekit과 tailwind css를 선택했어요.\n\n사용자는 3가지 방법으로 웹 앱에 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angelone Android 네이티브 앱\n- Angelone iOS 네이티브 앱\n- 웹 브라우저\n\n네이티브 앱의 경우 웹 앱을 웹뷰 내에서 열고 있습니다.\n\n따라서 앱 내 다양한 부분을 이동할 때 사용자가 연결이 끊어졌다고 느끼지 않도록 성능이 더욱 중요합니다.\n\n# 병목 현상 식별 및 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기의 SSR 슈퍼차징 단계는 성능 제한 요인을 식별하는 것입니다. 이러한 제한 요인은 서버 측과 브라우저 측에서 발생할 수 있습니다.\n\n서버 측 제한 요인:\n\n- 비효율적인 코드 및 데이터 처리: 최적화되지 않은 코드와 비효율적인 알고리즘은 서버가 HTML을 생성하는 데 느릴 수 있습니다. 분석 및 코드 리팩토링을 통해 이러한 문제를 식별하고 해결할 수 있습니다.\n- 비효율적인 캐싱 전략: SSR에서 캐싱은 중요한 역할을 합니다. 올바르게 구성되지 않은 캐시는 불필요한 재랜더링과 지연을 초래할 수 있습니다. 효율적인 캐싱 메커니즘을 구현하면 성능을 크게 향상시킬 수 있습니다.\n- 네트워크 지연: 서버와 사용자 브라우저 간 데이터 전송에 소요되는 시간은 페이지 로드 시간에 큰 영향을 미칠 수 있습니다. 콘텐츠 전달 네트워크(CDN) 및 엣지 서버를 활용하여 콘텐츠를 사용자에게 더 근접하게 배포하고 지연을 줄일 수 있습니다.\n\n브라우저 측 제한 요인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 큰 JavaScript 번들: JavaScript는 상호 작용에 필수적이지만, 큰 번들은 페이지 렌더링을 지연시킬 수 있습니다. 코드 분할과 최소화를 통해 JavaScript 파일의 크기를 줄이고 로드 시간을 개선할 수 있습니다.\n- 최적화되지 않은 DOM 조작: 문서 객체 모델(DOM)의 과도하거나 비효율적인 조작은 성능 문제로 이어질 수 있습니다. DOM 업데이트를 신중히 최적화하면 렌더링 속도를 향상시킬 수 있습니다.\n- 최적화되지 않은 에셋: 큰 이미지, CSS 파일 및 폰트도 페이지 로드 시간을 늦출 수 있습니다. 이러한 에셋을 압축 및 최적화하면 상당한 차이를 만들 수 있습니다.\n\n# 웹 비탈스(Web Vitals)로 성능 모니터링하기\n\nGoogle의 웹 비탈스는 웹 페이지에서 사용자 경험을 측정하고 추적하기 위한 표준화된 메트릭을 제공합니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_4.png\" /\u003e\n\n여기서 페이지 로드 지표는 다음과 같습니다:\n\n- 가장 큰 콘텐츠 페인트 (LCP): 페이지에서 가장 큰 콘텐츠 요소가 보이기 시작하는 데 걸리는 시간을 측정합니다.\n- 첫 번째 콘텐츠 페인트 (FCP): 사용자가 페이지로 처음 이동한 시점부터 화면에 콘텐츠의 일부가 렌더링되기 시작하는 시간을 측정합니다.\n- 첫 번째 바이트까지의 시간 (TTFB): 리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시간을 측정하는 지표입니다.\n\n이러한 지표를 모니터링하면 최적화가 필요한 영역을 식별하고 노력의 영향을 추적할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전문가 도구\n\nSSR 최적화 여정을 돕기 위한 여러 도구들이 있습니다:\n\n- Lighthouse: 웹 사이트 성능, 접근성 등에 대한 포괄적인 통찰을 제공하는 구글의 오픈소스 도구입니다.\n- PageSpeed Insights: 페이지 속도 분석과 최적화 제안을 제공하는 또 다른 구글 도구입니다.\n- WebPageTest: 다양한 조건 하에서 웹 사이트 성능을 측정하는 강력한 도구입니다.\n- 실제 사용자 모니터링(RUM) 데이터: 실제 사용자들이 웹 사이트를 경험하는 방식에 대한 데이터를 수집하여 소중한 현실 세계의 통찰을 제공합니다.\n\n# 최적화 전략\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSR 페이지를 업그레이드하기 위한 주요 최적화 전략 몇 가지를 소개해 드릴게요:\n\n캐싱에 대해 언급할 때, 세 가지 방법으로 구현할 수 있어요\n\n- 단기 - 몇 분\n- 중기 - 몇 시간\n- 장기 - 몇 일\n\n우리는 초기 페이지 렌더링에 필요한 API 목록을 식별했고, 자주 변경되지 않는 데이터에 대한 단기 메모리 API 캐싱을 구현했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 마크다운 형식으로 변경한 내용입니다.\n\n\n![Image 1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_5.png)\n\n우리가 이 변경 사항을 배포한 후에는 Backend API에 대한 히트가 급격히 감소했습니다.\n\n![Image 2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_6.png)\n\n이는 이제 Backend 서버가 다른 중요 사항에 더 많은 시간을 할애하고 더 적은 부하로 인해 더 빠르고 지연 시간이 낮아질 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 프런트엔드 서버와 백엔드 서버는 같은 가상 사설 클라우드(VPC) 안에 있어요. 이 설정을 활용해서 백엔드 API의 내부 엔드포인트를 호출하기 시작했어요.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_7.png)\n\n장점:\n- 성능: 내부 API는 외부 엔드포인트를 통과하는 것보다 더 빠를 수 있어요.\n- 신뢰성: 내부 API는 덜 고장이 날 가능성이 높기 때문에 믿을 만해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 즉시 볼 수 있는 콘텐츠 렌더링을 우선시하세요.\n\n![image](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_8.png)\n\n혜택:\n\n- html, javascript 및 이미지를 포함한 데이터 양을 줄여 데이터 전송 양을 줄임\n- 즉 브라우저가 더 적은 작업을 해야 하므로 콘텐츠를 보다 빠르게 렌더링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로딩 프로세스 중에 필수 리소스를 미리 가져오세요.\n\n이렇게 하면 스타일이 적용되지 않은 텍스트(Flash of unstyled text, FOUT)가 방지됩니다.\n\n![image1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_9.png)\n\n![image2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPre-connect은 페이지 상단 콘텐츠가 제 3자 또는 CDN 네트워크에서 에셋이나 이미지를 필요로 하는 경우에 유용합니다.\n\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_11.png)\n\n\nPre-connect를 사용하지 않으면 브라우저는 우선 콘텐츠를 다운로드한 후, 다른 출처에 대한 에셋에 따라 특정 콘텐츠를 찾으면, 먼저 제 3자와 연결을 시도한 뒤 연결이 확립되면 콘텐츠를 다운로드하므로 중요한 시간이 소비됩니다.\n\nPre-connect를 사용하면 브라우저는 우선 콘텐츠를 다운로드하는 동안 제 3자와 연결을 설정하고 필요한 다운로드가 즉시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n폰트는 두 가지 방법으로 사용할 수 있어요.\n\n- 구글 폰트, 폰트 어썸 등과 같은 타사 서비스 사용\n- 폰트 자체 호스팅\n\n데이터에 따르면 웹 페이지의 20%만이 자체 호스팅된 폰트를 사용하는데, 나머지는 자체 호스팅 + 타사 혹은 단독으로 타사 폰트를 사용하고 있어요.\n\n이전에는 브라우저의 공유 캐시 때문에 타사 폰트를 사용하는 것에 성능상의 이점이 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 Chrome 버전 85부터 Chrome 팀이 캐시 파티션을 도입했는데, 이는 한 웹사이트의 캐시된 리소스를 다른 웹사이트가 사용할 수 없다는 뜻입니다. 따라서 성능 상의 이점이 없어졌습니다.\n\n이에 더해, 써드파티 원본과의 사전 연결(pre-connect)에 대한 추가적인 부담이 있습니다. 이는 고가 소요됩니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_12.png)\n\n하지만 자체 호스팅 폰트를 사용하면 도전이 발생합니다. 모든 자체 호스팅 폰트의 제 75 백분위수 크기는 75KB로 매우 큽니다. 이는 폰트가 많은 언어와 문자를 포함하기 때문인데, 대부분의 경우 사이트에서 실제로 필요하지 않은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 온라인으로 글꼴을 다운로드 받아서 (크기는 63kb였습니다) 모든 불필요한 문자를 제거하여 글꼴 크기를 7.2kb로 줄였어요. 이는 Yellow Lab 도구의 도움으로 88% 감소했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_13.png)\n\n# 최적화의 영향\n\n다행히도, SSR을 최대한 최적화하는 투자는 매우 좋은 수확을 낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔젤 원을 예로 들어보면, FCP 숫자를 1500ms 대신 1230ms로 개선했더니 전환율이 최대 30%까지 상승했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_14.png)\n\n작은 개선조치라도 비즈니스 결과로 이어질 수 있는 좋은 예시입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 서버 측 렌더링의 최적화는 현대 웹에서 모두에게 이상적인 경험을 제공하기 위해 반드시 해야 합니다.\n\n성능 병목 현상을 최적화하고 웹 핵심 지표를 모니터링하며 적절한 최적화 전략을 활용하면 SSR 페이지를 빠르게 만들어 사용자 참여도를 높이고 전환율을 높이는데 도움이 됩니다.\n\nhttps://www.youtube.com/watch?v=xUMgwaKkDg4\u0026ab_channel=DeveloperSummit","ogImage":{"url":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png"},"coverImage":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png","tag":["Tech"],"readingTime":7},{"title":"시스템 디자인 면접 아마존 플립카트","description":"","date":"2024-06-20 01:08","slug":"2024-06-20-SystemDesignInterviewAmazonFlipkart","content":"\n\n## 다루는 주제:\n\n- 아키텍처는 홈/검색 플로우, 추천 시스템, 주문 관리 및 재고 서비스와 같은 구성 요소를 포함합니다.\n- 비구조화된 데이터에는 MongoDB, 검색에는 Elasticsearch, 주문 트랜잭션에는 MySQL, 완료된 주문에는 카산드라와 같은 데이터베이스의 사용이 강조됩니다. Kafka와 Spark는 실시간 데이터 처리 및 분석에 사용됩니다.\n\n# 전자 상거래 시스템 아키텍처\n\n- 우버나 에어비앤비의 백엔드와 마찬가지로 아마존 및 기타 전자 상거래 플랫폼도 시스템에 대한 두 가지 면을 갖고 있습니다.\n- 아마존의 고객인 경우, 아마존의 자체 격리된 스토어를 통해 제품을 판매하거나 다른 판매자들이 제공하는 제품을 구매할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기능 요구 사항\n\n- 판매자 작업: 판매자는 제품을 추가, 삭제 및 수정할 수 있습니다.\n- 제품 카탈로그: 구매자가 제품을 이름, 키워드 또는 카테고리로 검색할 수 있는 포괄적인 카탈로그입니다.\n- 장바구니: 구매자는 장바구니에 제품을 추가, 삭제 또는 업데이트할 수 있습니다.\n- 주문 처리: 구매자는 제품을 구매하고 결제할 수 있습니다.\n- 주문 내역: 구매자는 이전 주문 내역을 확인할 수 있습니다.\n- 리뷰 및 평점: 구매자는 제품을 리뷰하고 평가할 수 있습니다.\n\n## 비기능 요구 사항\n\n- 높은 가용성: 시스템은 연중무휴로 운영되어야 합니다.\n- 높은 일관성: 시스템 전체의 정확한 데이터를 보장하며 특히 재고 및 거래에 대해 정확성을 유지해야 합니다.\n- 낮은 지연 시간: 원활한 사용자 경험을 위해 빠른 응답 시간이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 말한 것과 같이, Markdown 형식의 표로 변경해 보겣습니다:\n\n| Component              | Priority        | Description                                                                                  |\n|------------------------|-----------------|----------------------------------------------------------------------------------------------|\n| Payment service        | High            | Highly consistent                                                                            |\n| Inventory management   | High            | Highly consistent                                                                            |\n| Search service         | High            | Highly available and low latency, eventually consistent                                      |\n| Availability           | Low             | Low priority                                                                                 |\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자/구매자는 전자 상거래 웹 사이트를 방문하여 홈페이지에 도착할 것입니다.\n- 홈페이지는 추천 서비스에 의해 구동됩니다. 사용자가 무언가를 검색하면 시스템의 검색 서비스를 호출할 것입니다.\n- 고객이 검색을 완료하고 주문을 하려고 하면 주문 배치 아키텍처가 처리할 것입니다.\n- 시스템의 구매 단의 설계를 간단하게하기 위해 홈페이지/검색 아키텍처와 주문 배치 아키텍처를 따로 논의할 것입니다.\n\n## 홈 화면 및 검색 페이지\n\n우리가 제공할 두 가지 UI가 있을 것입니다.\n\n- 홈 화면에는 몇 가지 추천 사항이 있을 것입니다. 반환 사용자인지 새 사용자인지에 따라 개인화된 추천이거나 일반 추천일 수 있습니다.\n- 검색 페이지에서 사용자는 일부 검색 텍스트를 기반으로 결과를 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png)\n\n![이미지2](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_1.png)\n\n우리 시스템의 소비자 중 하나는 상품 서비스입니다\n\n## 상품 서비스\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Item 서비스는 Kafka를 청취하여 새 항목을 추가하고 업데이트하고 가져오는 API를 노출합니다.\n- 이 서비스는 해당 항목 관련 데이터가 비구조적이기 때문에 MongoDB에 위치합니다.\n- \"비구조적\"이라는 의미는 다양한 유형의 항목이 서로 다른 속성을 가질 것이라는 것입니다. 예를 들어, 셔츠에는 사이즈, 원단, 색상 속성이 있고, TV에는 화면 크기, 색상 기술, 무게, 해상도 등의 속성이 있을 수 있습니다.\n\n새 항목이 온보딩되자마자,\n\n- 검색 소비자는 해당 항목이 사용자에 의해 쿼리될 수 있도록 확인합니다. 새 항목을 읽고 처리하여 데이터베이스에 저장될 수 있도록 형식화하고 검색 시스템이 이해할 수 있도록합니다.\n- 형식화가 완료되면 검색 소비자는 이 데이터를 ElasticSearch 데이터베이스에 넣습니다.\n- 여기서 텍스트 기반 검색에 매우 효율적이고 원활한 사용자 경험을 위해 필요한 유사 검색을 지원하는 ElasticSearch를 사용합니다.\n\n이제 Search 서비스,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 ElasticSearch와 상호 작용하면 제품을 필터링, 정렬, 검색하는 API가 노출됩니다.\n- 기능 요구 사항에서 '배송 예상 시간으로 검색'을 언급했습니다. 이를 확장하여 사용자에게 전달할 수 없는 검색 결과를 표시하지 말아야 한다는 요구 사항으로 확장할 수 있습니다. 그렇지 않으면 사용자 경험이 좋지 않을 것입니다.\n- 이를 위해 검색 서비스는 Serviceability 및 TAT 서비스라는 것과 대화할 것입니다. Serviceability 및 TAT 서비스는 제품이 배송될 창고를 확인하고, 창고와 사용자의 우편번호 사이에 경로가 있는지, 그리고 그 경로를 통해 이 제품을 운반할 수 있는지를 확인합니다. 또한, 대략적인 배송 일정을 파악하고 이 모든 정보를 검색 서비스에 전달합니다. 검색 서비스는 이 정보를 사용자에게 추가로 전달할 것입니다.\n\n## 사용자 검색이 생성되는 방법\n\n- 이 검색 결과 또는 추천은 앞서 논의한 전자 상거래 애플리케이션의 다른 공급 업체, 상점 또는 판매자에 의해 생성됩니다.\n- 다이어그램의 가장 오른쪽에 상자로 표시된 판매 끝 부분을 찾을 수 있습니다.\n- 실제로, 판매 끝 부분 자체가 일련의 마이크로서비스로 완성된 아키텍처입니다.\n- 판매 끝 부분은 모든 상점에서 데이터를 가지고 있습니다.\n- 새로운 상점이 시스템에 합류하거나 기존 상점이 재고에 새 제품을 추가할 때마다 Kafka 대기열이 해당 이벤트를 가져올 것입니다.\n- Kafka 대기열에서 데이터를 읽는 일련의 Kafka 소비자가 이러한 데이터 변경 사항을 가져와서 Amazon 검색 페이지의 검색 결과를 제어하는 ElasticSearch에 통합할 것입니다.\n\n## 찜 목록 및 카트 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 검색 결과가 표시된 후 사용자는 서로 다른 제품의 속성을 확인하고 비교할 수 있습니다.\n- 다음으로, 사용자는 무언가를 선택하고 '위시리스트'나 '장바구니'에 추가할 수 있습니다. '위시리스트'에 추가하면 위시리스트 서비스가 호출되어 해당 항목을 위시리스트 MySQL 데이터베이스에 추가합니다.\n- 사용자가 항목을 장바구니에 추가하면 카트 서비스를 통해 카트 MySQL 데이터베이스에 저장됩니다.\n- 위시리스트와 장바구니에는 따로 데이터베이스를 사용하는 것이 타당합니다. 위시리스트는 장바구니에 있는 객체보다 훨씬 긴 기간 동안 저장될 수 있기 때문입니다.\n\n중요한 점을 다시 이해하세요,\n\n- 검색 화면에서 사용자는 제품을 위시리스트에 추가하거나 장바구니에 넣을 수 있어야 합니다. 이는 위시리스트 서비스와 카트 서비스를 통해 이루어집니다.\n- 위시리스트 서비스는 우리 시스템의 모든 위시리스트 저장소이고, 카트 서비스는 모든 장바구니 저장소입니다.\n- 이 두 서비스는 서로 완전히 동일한 방식으로 구축될 것이며, 각각 위시리스트나 장바구니에서 항목을 가져오고 업데이트하고 추가 또는 삭제할 API를 제공하며, 둘 다 MySQL DB에 저장될 것입니다.\n- 이들은 동일한 하드웨어 위에서 구축될 수 있지만, 특히 할인이 다가올 때 위시리스트가 매우 길어지는 경향이 있기 때문에 이 서비스들을 위한 별도의 하드웨어를 사용하는 것이 좋습니다. 이렇게 하면 각 서비스에 대한 하드웨어 확장이 훨씬 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자의 검색, 장바구니 및 위시리스트 항목은 추천 서비스를 지원하는 중요한 자원입니다.\n- 이러한 이벤트들은 사용자의 관심을 반영하며 해당 사용자에 맞는 추천을 만드는 데 활용될 수 있습니다.\n- 위 다이어그램에서 확인할 수 있듯이, 검색 서비스, 장바구니 서비스 및 위시리스트 서비스는 모두 발생하는 이벤트를 카프카 큐로 보내고 있습니다.\n- Spark Streaming 소비자는 실시간으로 카프카에서 읽어와 하둡 클러스터에 저장할 보고서를 생성하여 분석 목적으로 사용됩니다. 사용자가 가장 많이 검색하거나 위시리스트에 추가한 항목과 같은 특정 분석을 통해 이 사용자에게 추천을 생성할 수 있습니다.\n\n중요한 점을 다시 이해하면,\n\n- 우리의 카프카 서비스는 최근 시간 단위나 일별로 가장 인기 있는 제품, 가장 원하는 항목, 가장 많은 주문이 발생한 지역, 수익을 최대화하는 범주 등과 같은 실시간 보고서를 생성할 스파크 스트리밍 소비자에 연결될 것입니다.\n- 카프카에서 제공된 모든 이 데이터는 일반적인 추천을 제공할 수 있도록 ALS와 같은 표준 알고리즘을 실행할 수 있는 하둡 클러스터에 저장될 것입니다. 과거 구매 내역을 기반으로 사용자가 다음에 구매할 필요가 있는 제품을 식별하고 그에 따라 우리는 그들을 위해 개인 맞춤형 추천을 생성할 수 있습니다.\n- 또한 다른 비슷한 사용자가 검색한, 위시리스트에 추가한 또는 구매한 제품들에 대해 알려줄 것이며, 이를 특정 사용자에 대한 추천에 추가할 수 있습니다.\n- 이러한 추천이 생성되면 스파크 클러스터가 추천 서비스와 대화하는데, 이것은 시스템의 모든 추천을 포함하고 일반적인 추천 또는 제품 범주에 기반한 특정 사용자 ID에 대한 추천일 수 있습니다.\n- 이렇게 하면 사용자들은 홈페이지에서 일반적인 추천을 볼 수 있지만, 특정 제품 범주를 탐색 중인 경우 추천이 필터링될 것입니다.\n\n## 사용자 위치 데이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시스템은 사용자 데이터도 저장합니다.\n- 사용자 위치 정보를 통해 시스템이 특정 제품을 사용자에게 배달할 수 있는지 여부를 결정할 수 있습니다.\n- 예를 들어, 생활 필수품인 냉동식품의 배송이 원격 지역에서 제한될 수 있습니다.\n- 이러한 항목들은 추천 또는 검색 결과에 나타나지 않습니다.\n- 이는 추천 서비스와 검색 서비스가 사용자 데이터를 필요로 하여 사용자에게 특화된 결과를 생성해야 함을 의미합니다.\n- 이 서비스들은 초기에 REDIS와 통신합니다.\n- 사용자 데이터가 그곳에 저장되어 있으면, 이를 직접 서비스로 보냅니다. 캐시에 없다면 REDIS는 데이터베이스에서 정보를 불러와 서비스로 전달합니다.\n\n다시 한 번 중요한 점을 이해하세요,\n\n- 사용자 서비스는 모든 사용자의 저장소이며 시스템에서 사용자를 가져오거나 업데이트, 추가, 삭제하기 위한 API도 제공합니다.\n- 해당 서비스는 MySQL 데이터베이스에 위치하며 Redis 캐시를 유지합니다.\n- 따라서 검색 서비스가 서비스 가능성 서비스에 통신하기 위해 사용자의 우편번호를 가져오려면, 사용자 서비스는 먼저 Redis에서 확인하고, 정보가 없다면 MySQL 데이터베이스에서 조회하여 사용자 정보를 가져와 Redis에 저장하고, 그 정보를 검색 서비스에 반환합니다.\n\n## 창고 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 창고 서비스는 다양한 상점을 위해 창고에 있는 모든 제품에 대한 인덱스를 유지합니다.\n- 이 정보는 검색 서비스에 의해 가져와서 제품이 현재 사용 가능한지 여부를 표시하는 데 사용됩니다.\n\n# 구매 및 체크아웃 흐름\n\n![이미지](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_2.png)\n\n- 사용자가 주문을 배치하려고 할 때, 요청은 대규모 주문 관리 시스템의 일부인 주문 수신 서비스로 이동합니다.\n- 주문 관리 시스템은 MySQL 데이터베이스에 있습니다. 우리는 고객 테이블, 제품 테이블, 주문 테이블 등 여러 테이블을 예상대로 가지고 있으며, 이러한 테이블을 통해 다양한 거래가 진행됩니다.\n- 이제 우리는 데이터베이스가 변화를 즉시 반영하지 못해 창고에서 최신 AirPods의 마지막 제품을 두 명의 사용자가 주문할 수 없도록 하고 싶습니다. 이것은 관계형 데이터베이스의 ACID 특성이 필요하므로 MySQL이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 수신 서비스가 호출되면,\n\n- Redis에 주문 ID, 주문이 만들어진 날짜 및 시간, 주문 ID의 만료 시간이 포함된 레코드가 생성됩니다.\n- 이러한 세부 정보와 함께 해당 주문 ID에 대한 상태도 있을 것입니다. 일단이 상태는 \"생성됨\"이라고 가정합니다.\n- 다음 단계는 재고 서비스를 호출하는 것입니다. 예를 들어, 주문이 생성되기 전에 5개의 소니 65인치 스마트 TV가 재고에 있었습니다.\n- 주문을 배치한 후, 제품의 재고 수는 4로 감소하며, 이후에 사용자가 결제 페이지로 리디렉션됩니다.\n- 그러나 왜 결제가 완료되기 전에 재고를 업데이트하는 걸까요? 만약 5대가 아닌 1대만 재고가 있고 3명이 구매를 시도한다면 어떨까요? 결제 흐름으로 이동하기 전에 재고 수를 줄이면, 3명 중 2명은 상품이 이미 품절되었음을 알게 되어 결제 페이지로 이동하기 전에 흐름이 종료될 것입니다.\n- 이 제약 조건을 유지하여 재고 수가 음수가되면 주문을 배치할 수 없도록 충분히 쉽게 구현할 수 있습니다.\n\n# 서로 다른 서비스가 사용하는 데이터베이스:\n\n전형적인 전자 상거래 아키텍처에서 각 서비스가 사용하는 데이터베이스를 분석하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 제품 카탈로그\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL) 또는 NoSQL 데이터베이스 (예: MongoDB)\n- 목적: 제품의 이름, 설명, 가격, 이미지 및 속성과 같은 상세 정보를 저장합니다.\n- 참조: 제품 세부 정보를 빠르게 검색하고 확장성을 다루기 위해 사용됩니다 (Java Challengers) (CodeKarle).\n\n## 2. 사용자 관리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL) 및 캐싱 레이어 (예: Redis)\n- 목적: 사용자 계정, 인증 및 권한을 관리합니다. 사용자 정보, 예를 들어 이름, 주소 및 결제 방법을 저장합니다.\n- 참조: 관계형 데이터베이스는 ACID 속성을 유지하기 위해 사용되고, Redis는 성능을 향상시키기 위해 캐싱에 사용됩니다 (CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 쇼핑 카트 및 위시리스트\n\n- 데이터베이스: 예를 들어 MySQL과 같은 관계형 데이터베이스(영속성을 위해); 캐싱을 위해 Redis 사용\n- 목적: 쇼핑 카트와 위시리스트에 추가된 항목을 관리합니다. 항목을 가져오거나 업데이트하고, 추가하거나 삭제하는 API를 제공합니다.\n- 참고: 관계형 데이터베이스는 카트와 위시리스트 데이터의 일관성과 신뢰성을 보장하며, Redis는 빠른 액세스와 확장성에 도움이 됩니다. (CodeKarle).\n\n## 4. 주문 처리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL)\n- 목적: 항목 가용성을 확인하고, 트랜잭션을 처리하며, 재고를 업데이트하고, 주문 세부 정보를 저장합니다.\n- 참고: 관계형 데이터베이스 사용은 트랜잭션을 처리하고 주문 프로세스 중 데이터 무결성을 유지하는 데 중요한 ACID 속성을 보장합니다 (CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 결제 게이트웨이\n\n- 데이터베이스: 외부 결제 제공업체에 의존하기 때문에 특정 데이터베이스 명시되지 않음.\n- 목적: 외부 결제 제공업체와 통신하여 안전한 결제 처리를 담당.\n- 참조: 데이터베이스 관리보다는 안전한 통신에 더 초점을 둠.\n\n## 6. 재고 관리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL)\n- 목적: 제품 가용성을 추적하고 주문에 따라 재고를 업데이트.\n- 참조: 재고 수준을 정확하고 일관되게 추적함(CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 검색 기능\n\n- 데이터베이스: 검색 엔진 플랫폼 (예: Elasticsearch)\n- 목적: 빠르고 정확한 검색 결과 제공.\n- 참조: Elasticsearch는 효율적인 검색과 검색 결과를 제공하기 위해 설계되었으며, 이는 전자 상거래 플랫폼(Java Challengers)에 적합합니다.\n\n## 8. 리뷰 및 평점\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL)\n- 목적: 제품에 대한 사용자 리뷰 및 평점을 저장합니다.\n- 참조: 리뷰와 평점이 일관되고 신뢰할 수 있게 저장 및 검색되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 9. 추천 시스템\n\n- 데이터베이스: NoSQL 데이터베이스 (예: Cassandra, HBase) 및 데이터 처리를 위한 Hadoop\n- 목적: 사용자의 행동 및 선호도에 기반한 맞춤형 추천 제공\n- 참고: NoSQL 데이터베이스와 Hadoop은 확장성 및 대규모 데이터셋을 효율적으로 처리할 수 있는 능력 때문에 사용됨 (CodeKarle).\n\n## 10. 분석 및 모니터링\n\n- 데이터베이스: 데이터 웨어하우스 (예: Amazon Redshift, Google BigQuery) 및 대규모 데이터 처리를 위한 Hadoop\n- 목적: 사용자 상호작용, 매출 및 시스템 성능에 대한 데이터 수집 및 분석\n- 참고: 데이터 웨어하우스와 Hadoop은 대용량 데이터를 처리하고 복잡한 분석 쿼리를 수행하기에 적합함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 11. 캐싱과 콘텐츠 전달\n\n- 데이터베이스: 콘텐츠 전달 네트워크(CDN) 및 캐싱 레이어 (예: Redis, Memcached)\n- 목적: 정적 콘텐츠를 캐싱하여 성능을 향상시키고 웹 서버 부하를 줄임.\n- 참고: CDN 및 캐싱 레이어는 자주 요청되는 데이터에 빠르게 접근하여 사용자 경험을 향상시킴.\n\n## 참고,\n\n- https://www.systemdesignnotes.com/amazon-ecommerce-design\n- https://www.codekarle.com/system-design/Amazon-system-design.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전자 상거래 응용프로그램의 판매자용 아키텍처\n\n- 자세한 내용은 [이 기사](https://medium.com/double-pointer/system-design-interview-amazon-flipkart-ebay-or-similar-e-commerce-applications-35a0bc764421)를 확인해주세요!","ogImage":{"url":"/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png"},"coverImage":"/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png","tag":["Tech"],"readingTime":10},{"title":"HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내","description":"","date":"2024-06-20 01:06","slug":"2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png)\n\n- 소개\n- 프로젝트 개요\n- 요구 사양\n- 날씨 예보 어플리케이션의 기능\n- 코드 구조\n  - 단계 1. HTML 구조:\n  - 단계 2. CSS 스타일링:\n  - 단계 3. JavaScript 로직:\n- 테스트와 디버깅\n- 배운 점\n- 배포\n- 어플리케이션 사용 방법 안내\n- 향후 개선 사항\n- 결론\n\n# 소개\n\n이 안내서는 HTML, CSS 및 JavaScript를 사용하여 상호작용하는 날씨 예보 어플리케이션을 만드는 과정을 안내합니다. 사용자는 전 세계 어느 곳이든 현재 날씨 상황 및 예보에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 개요\n\n날씨 예보 앱은 간단하고 사용자 친화적인 인터페이스를 갖추고 있습니다. 사용자는 검색 창에 위치를 입력할 수 있고, 앱은 해당 지역의 현재 날씨 상황을 보여줍니다. 저는 사용자의 위치 입력을 기반으로 날씨 정보를 가져오기 위해 OpenWeather API를 사용했습니다. 앱은 온도, 습도, 풍속, 현재 상황을 보여주는 날씨 아이콘 및 검색된 위치의 배경 이미지와 같은 추가 정보도 제공합니다.\n\n# 준비물\n\n이 날씨 예보 애플리케이션을 만들기 위해서는 HTML, CSS 및 JavaScript에 대한 기본적인 이해가 필요합니다. 애플리케이션을 구성하기 위해 HTML에 익숙해야하며, 스타일링을 위해 CSS를 사용하고 애플리케이션의 로직을 구현하기 위해 JavaScript를 사용할 수 있어야합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 작성하는 데는 텍스트 편집기 또는 IDE(예: Visual Studio Code)가 필요하며, 테스트를 위해 웹 브라우저가 필요합니다. 선택 사항으로는 애플리케이션을 호스팅하기 위한 GitHub 계정이 필요합니다.\n\n# Weather Forecast Application의 기능\n\n이 프로젝트에서는 다음과 같은 기능이 있는 날씨 예보 앱을 만듭니다:\n\n- 위치 기반 날씨: 사용자는 위치(도시)를 입력하여 해당 지역의 현재 날씨 상황 및 예보를 볼 수 있습니다.\n- 현재 날씨 표시: 애플리케이션은 현재 온도, 날씨 상황(예: 맑음, 비, 흐림), 습도, 풍속 및 가시성을 보여줍니다.\n- 날씨 아이콘: 날씨 조건을 시각적으로 이해하기 쉽게 나타내기 위해 날씨 아이콘(예: 태양, 구름, 비)을 사용합니다.\n- 반응형 디자인: 애플리케이션이 다양한 기기 및 화면 크기에서 잘 작동하고 반응형임을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 구조\n\n프로젝트용 새 폴더를 생성하고, 폴더의 이름을 원하는 대로 지은 다음, 그 안에 index.html, style.css, script.js 세 개의 파일을 만듭니다. 이 파일들은 프로젝트의 기반으로 사용될 것입니다. 이제 텍스트 편집기나 IDE (예: Visual Studio Code)에서 폴더를 열고 아래 단계를 따릅니다:\n\n## 단계 1. HTML 구조:\n\nindex.html 파일을 열고, 날씨 예보 애플리케이션을 위한 다음 HTML 코드를 붙여넣으세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 HTML 코드는 검색 바와 날씨 정보 표시를 갖춘 날씨 애플리케이션 인터페이스를 설정합니다. 입력, 버튼, 도시 이름, 온도, 날씨 아이콘, 설명, 습도 및 풍속을 위한 요소가 포함되어 있습니다.\n\n디자인은 특정 도시에 대한 검색 기능과 날씨 세부 정보가 있는 카드 레이아웃을 특징으로 합니다. 외부 CSS 파일 및 JavaScript 파일에 대한 링크도 포함되어 있습니다.\n\n## 단계 2. CSS 스타일링:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstyle.css 파일을 열어 날씨 예보 애플리케이션을 스타일링하는 다음 CSS 코드를 붙여넣어주세요:\n\n```css\nbody {\n display: flex;\n justify-content: center;\n align-items: center;\n height: 100vh;\n background: darkgrey;\n margin: 0;\n font-size: 120%;\n background-image: url(\"https://source.unsplash.com/1600x900/?nature,landscape\");\n font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;\n} \n\n.card {\n background-color: black;\n padding: 2em;\n color: white;\n border-radius: 30px;\n width: 100%;\n max-width: 420px;\n margin: 1em;\n box-shadow: 1px 3px 5px rgba(141, 138, 138, 0.1);\n}\n\n.search {\n display: flex;\n align-items: center;\n justify-content: center;\n}\n\ninput.search-bar {\n border: none;\n outline: none;\n padding: 0.4em 1em;\n border-radius: 30px;\n background-color: #534b4b;\n color: white;\n font-size: 120%;\n width: calc(100% - 100px);\n font-family: 'Roboto';\n letter-spacing: 2px;\n}\n\nbutton {\n margin: 0.5em;\n border-radius: 50%;\n border: none;\n height: 3em;\n width: 3em;\n outline: none;\n background-color: #534b4b;\n color: white;\n cursor: pointer;\n transition: 0.3s ease-in-out;\n}\n\nbutton:hover {\n background-color: #9b7979;\n}\n\n.weather {\n font-weight: bold;\n}\n\n.weather.loading {\n visibility: hidden;\n max-height: 20px;\n position: relative;\n}\n\n.weather.loading::after {\n position: absolute;\n top: 0;\n color: white;\n visibility: visible;\n content: \"Page Loading...\";\n font-weight: bold;\n left: 30px;\n}\n\nh1.city {\n letter-spacing: 2px;\n text-transform: uppercase;\n font-size: 1.3em;\n}\n\nh1.temp {\n margin: 0;\n margin-bottom: 0.5em;\n font-size: 1.3em;\n}\n\n.flex {\n display: flex;\n align-items: center;\n margin-left: -10px;\n margin-bottom: 0.5em;\n}\n\n.flex .description {\n text-transform: capitalize;\n margin-left: 8px;\n}\n\n.humidity {\n font-size: 1.2em;\n margin-bottom: 0.5em;\n}\n\n@media screen and (max-width: 420px) {\n .card {\n   border-radius: 35px;\n   max-width: 320px;\n  }\n\n input.search-bar {\n  padding: 0.3em 0.8em;\n  border-radius: 30px;\n  background-color: #534b4b;\n  color: white;\n  width: calc(100% - 100px);\n  letter-spacing: 1px;\n }\n}\n```\n\n상기 CSS 코드는 중앙 정렬 레이아웃, 어두운 회색 배경, Unsplash의 배경 이미지를 사용하는 스타일링된 날씨 애플리케이션을 정의합니다. 정렬을 위해 flexbox를 사용하고, 검은색 배경과 흰색 텍스트로 카드 스타일을 설정하며, 입력과 버튼 요소를 스타일링합니다. 로딩 애니메이션은 기본적으로 숨겨져 있으며 활성화될 때 메시지를 표시합니다. 미디어 쿼리는 작은 화면에 맞게 스타일을 조정합니다.\n\n## 단계 3. 자바스크립트 로직:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nthescript.js 파일을 열고 다음 JavaScript 코드를 사용하여 Weather forecast 어플리케이션에 기능을 추가하세요:\n\n```js\nlet cityEl = document.querySelector(\".city\");\n\nlet iconEl = document.querySelector(\".icon\");\n\nlet descriptionEl = document.querySelector(\".description\");\n\nlet temperatureEl = document.querySelector(\".temp\");\n\nlet humidityEl = document.querySelector(\".humidity\");\n\nlet windEl = document.querySelector(\".wind\");\n\nlet searchBar = document.querySelector(\".search-bar\");\n\nlet searchEl = document.querySelector(\".search button\");\n\nlet weatherEl = document.querySelector(\".weather\");\n\nlet weather = {\n \"apikey\": \"a6f6fef1470f473cb0694459230605\",\n\n fetchWeather: function (city) {\n  fetch(\"http://api.weatherapi.com/v1/current.json?key=a6f6fef1470f473cb0694459230605%20\u0026q=\" + city + \"\u0026aqi=no\").then((response) =\u003e response.json()).then((data) =\u003e this.displayWeather(data));\n },\n\n displayWeather: function (data) {\n  const { name } = data.location;\n\n  const { icon, text } = data.current.condition;\n\n  const { temp_c, humidity } = data.current;\n\n  const { wind_kph } = data.current;\n\n  cityEl.innerText = `Weather in ${name}`;\n\n  iconEl.src = icon;\n\n  descriptionEl.innerText = text;\n\n  temperatureEl.innerText = `Temperature: ${temp_c}°C`;\n\n  humidityEl.innerText = `Humidity: ${humidity}%`;\n\n  windEl.innerText = `Wind Speed: ${wind_kph} km/hr`;\n\n  weatherEl.classList.remove(\"loading\");\n\n  document.body.style.backgroundImage = \"url('https://source.unsplash.com/1600x900/?\" + name + \"')\";\n },\n\n search: function () {\n  this.fetchWeather(searchBar.value);\n }\n};\n\nsearchEl.addEventListener(\"click\", () =\u003e {\n console.log(\"Clicked!\");\n weather.search();\n});\n\nsearchBar.addEventListener(\"keyup\", (event) =\u003e {\n if (event.key === \"Enter\") {\n  weather.search();\n }\n});\n\nweather.fetchWeather(\"Lagos\");\n```\n\n위의 JavaScript 코드는 사용자의 입력된 도시에 기반한 날씨 데이터를 가져오고 표시하는 weather라는 객체를 정의합니다. fetch API를 사용하여 날씨 API(api.weatherapi.com)로 요청을 보내고 검색된 데이터로 DOM을 업데이트합니다.\n\n또한 사용자가 특정 도시의 날씨 데이터를 검색할 수 있도록 검색 버튼 및 검색 창에 대한 이벤트 리스너를 포함하고 있습니다. 추가로, 검색된 도시에 따라 배경 이미지를 변경합니다. 페이지가 로드될 때 Lagos의 기본 날씨 정보가 가져와집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트 및 디버깅\n\n웹 브라우저에서 애플리케이션을 테스트하려면 다음 단계를 따를 수 있어요:\n\n- HTML 파일 열기: 이전에 언급된 것처럼 모든 HTML, CSS, JavaScript 파일을 동일한 폴더에 저장한 후, 해당 폴더에서 HTML 파일을 더블 클릭하여 웹 브라우저에서 열어주세요. 이렇게 하면 기본 웹 브라우저에서 파일이 열릴 거에요.\n- 요소 검사: 앱이 브라우저에 로드된 후 페이지를 마우스 오른쪽 버튼으로 클릭하고 \"검사\"를 선택하거나 \"Ctrl+Shift+I\"를 눌러 개발자 도구를 열어주세요. 이렇게 하면 콘솔에서 오류를 볼 수 있고 페이지 요소를 검사할 수 있어요.\n- 기능 테스트: 앱과 상호 작용하여 기능을 테스트해주세요. 이를 통해 코드 내의 버그나 문제를 식별할 수 있어요.\n- 디버깅: 오류나 문제가 발생하면 개발자 도구의 콘솔을 사용하여 JavaScript 코드를 디버깅하세요. 오류 메시지와 줄 번호를 찾아 문제가 발생하는 위치를 확인하세요.\n- 변경 사항 적용: 코드를 변경해야 하는 경우 코드 편집기로 돌아가 필요한 조정을 하고 파일을 저장한 후 브라우저를 새로고침하여 앱에 변경 사항이 반영되는지 확인하세요.\n\n# 배운 교훈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 코딩 프로세스를 시작하기 전에 응용 프로그램의 계획 및 로직을 설계하는 중요성을 이해했습니다. 또한 상호작용 웹 애플리케이션을 만드는 데 중요한 CSS 스타일, JavaScript 이벤트 및 DOM 조작에 대한 지식을 향상시켰습니다.\n\n# 배포\n\n날씨 예보 애플리케이션 프로젝트는 GitHub Pages에서 이용 가능하며, 아래 링크를 클릭하여 온라인으로 액세스할 수 있습니다:\n\n애플리케이션 테스트: [https://wasiu-akindoyin.github.io/Weather-Forecast-Web-Application/](https://wasiu-akindoyin.github.io/Weather-Forecast-Web-Application/)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub 저장소에 액세스하여 소스 코드를 확인하거나 기여할 수 있습니다.\n\n# 애플리케이션 사용 방법 안내\n\n다음 단계를 따라 날씨 예보 애플리케이션을 사용해보세요:\n\n- 위의 날씨 예보 애플리케이션을 위한 GitHub Pages URL을 방문하여 웹 브라우저에서 애플리케이션을 엽니다.\n- 앱이 로드되면 상단에 검색 창이 표시됩니다. 원하는 도시의 날씨를 확인하려면 도시 이름을 입력하고 Enter 키를 누르거나 검색 버튼을 클릭합니다.\n- 앱은 WeatherAPI에서 지정된 도시의 현재 날씨 데이터를 가져와 화면에 표시합니다. 도시 이름, 현재 온도, 날씨 설명, 습도, 풍속 등을 확인할 수 있습니다.\n- 아래로 스크롤하면 도시와 관련된 배경 이미지도 확인할 수 있습니다. 검색하는 도시에 따라 배경 이미지가 변경됩니다.\n- 다른 도시의 날씨를 확인하려면 간단히 검색 창에 새로운 도시 이름을 입력하고 Enter를 누르거나 다시 검색 버튼을 클릭하세요.\n- 여러 도시의 현재 날씨 조건을 확인하는 즐거움을 누려보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미래 개선 사항\n\n앞으로, 더 많은 기능을 추가할 계획입니다:\n\n- 위치 감지: 사용자의 현재 위치를 자동으로 감지하고 날씨를 표시하는 기능을 구현합니다.\n- 로컬 저장소: 사용자가 선호하는 위치나 설정을 로컬 저장소에 저장하여 방문 사이에 선택 사항을 기억합니다.\n- 오류 처리: API 요청 실패나 잘못된 사용자 입력에 대한 오류 처리를 추가합니다.\n- 여러 위치: 여러 위치를 추가하고 전환하여 날씨 정보를 볼 수 있는 기능을 활성화합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML, CSS, 그리고 JavaScript를 사용하여 이 날씨 예보 애플리케이션을 개발하는 것은 저에게 큰 만족감을 줬어요. API를 통합하고 비동기 작업을 관리하며 반응형 웹 애플리케이션을 개발하는 방법에 대해 배웠습니다. 이 애플리케이션은 사용자에게 유용한 서비스를 제공하여 어디서나 쉽게 날씨 정보에 접근할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"CORS를 활용한 효율적인 RSS JavaScript 파서 소개","description":"","date":"2024-06-20 01:04","slug":"2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS","content":"\n\n웹 개발 영역에서 RSS 피드와 같은 외부 콘텐츠를 애플리케이션에 통합하는 것은 종종 Cross-Origin Resource Sharing (CORS) 제약 때문에 도전이 될 수 있습니다. 이 보안 조치는 사용자 데이터를 보호하는 데 중요하지만 Medium과 같은 플랫폼에 호스팅된 RSS 피드와 같은 다른 출처에서 데이터를 검색하는 것을 복잡하게 만들 수 있습니다.\n\n이 기사에서는 CORS 제한을 다루면서 JavaScript를 사용하여 RSS 피드를 구문 분석하는 복잡성을 탐구합니다. 우리는 다양한 출처에서 동적 콘텐츠를 통합할 수 있도록 RSS 데이터를 원활하게 가져오고 구문 분석하는 방법을 탐구할 것입니다. 관련 코드는 여기서 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/asbedb/rss-parser-cors\n\n# RSS 피드를 사용하는 이유?\n\nRSS(Really Simple Syndication) 피드는 웹에서 콘텐츠 배포의 핵심 요소로 남아 있으며, 기사, 뉴스 업데이트, 블로그 글과 같이 자주 업데이트되는 콘텐츠를 게시하는 표준화된 형식을 제공합니다. 개발자와 콘텐츠 집계자들에게 RSS 피드는 여러 소스에서 실시간으로 큐레이션된 콘텐츠에 구조화된 방법으로 액세스하고 표시하는 기능을 제공합니다.\n\n# CORS 제약 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRSS 피드를 Medium과 같은 플랫폼에서 가져올 때 개발자가 주로 직면하는 문제 중 하나는 CORS 제한입니다. 브라우저는 이러한 정책을 강요하여 악성 스크립트가 명시적인 허가 없이 다른 도메인 간에 데이터에 접근하는 것을 방지합니다. 이 보안 계층은 중요하지만 종종 스마트한 솔루션을 요구하여 데이터 검색 및 통합을 원활하게 할 수 있게 합니다.\n\n# 자바스크립트가 해결책이다: RSS 파싱\n\n다양성과 풍부한 라이브러리 및 프레임워크 생태계를 통해 자바스크립트는 RSS 피드와 같은 XML 기반 콘텐츠의 파싱 및 조작을 위한 강력한 해결책을 제공합니다. 현대적인 기술과 라이브러리를 활용하여 개발자는 프록시나 서버 측 솔루션을 사용하여 CORS 제한을 우회하고 애플리케이션이 RSS 콘텐츠를 안전하고 효율적으로 가져오고 표시할 수 있도록 할 수 있습니다.\n\n# CORS 호환 RSS 파서 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 CORS Anywhere 및 jQuery를 사용하여 단일 RSS 소스에서 파싱하는 데 도움을 줄 것입니다. 이 기사는 매체(Medium)에 있으므로 내 매체(Medium) RSS 피드를 사용합시다!\n\n## CORS Anywhere\n\n## jQuery\n\n## 프로젝트 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 서버 측 기능을 로컬 또는 온라인으로 설정하는 데 필요한 기본 지식을 전제로 합니다.\n\n익숙하지 않은 경우, 로컬 개발을 위해 로컬 LAMP/XAMP 스택을 실행하거나 NodeJS 서버 측 기능을 실행하는 호스팅 제공 업체의 옵션을 찾아보는 것을 강력히 추천합니다.\n\n# 프로젝트 폴더 구조\n\n```js\njs/main.js\ncss/styles.css\nindex.html\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# index.html\n\n이 연습을 위해 아주 기본적인 HTML 구조를 사용하여 기초를 설정할 것입니다.\n\n여기서 고려해야 할 가장 중요한 세 가지 요소는 다음과 같습니다.\n\n- 페이지의 `head` 태그에 jQuery 스크립트를 호출하는지 확인하세요. 아래 예제는 CDN min.js 참조 점을 사용하며 구현할 수 있습니다.\n- 이 예에서는 생성된 HTML 코드를 `container id=\"rss-embed\"`의 컨테이너에 추가하는 방식으로 사용하며, 이 요소의 id가 js 파일이 이 컨테이너와 일치하는지 확인하는 것이 중요합니다.\n- 페이지 하단에 main.js에 대한 참조를 추가하여 페이지가 렌더링된 후에 스크립트가 호출되도록하여 특정성과 관련된 문제를 회피하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n    \u003chead\u003e\n        \u003cmeta charset=\"utf-8\"\u003e\n        \u003ctitle\u003e CORSJS Example\u003c/title\u003e\n        \u003clink rel=\"icon\" href=\"data:image/svg+xml,\u003csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22\u003e\u003ctext y=%22.9em%22 font-size=%2290%22\u003e💾\u003c/text\u003e\u003c/svg\u003e\"\u003e\n        \u003clink rel=\"stylesheet\" href=\"css/styles.css\"\u003e \n        \u003cscript src=\"https://code.jquery.com/jquery-3.6.0.min.js\"\u003e\u003c/script\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e \n      \u003ch1\u003ePosts\u003c/h1\u003e\n      \u003ccontainer id=\"rss-embed\"\u003e\u003c/container\u003e\n      \u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e\n    \u003c/body\u003e\n\u003c/html\u003e \n```\n\n# js/main.js\n\n아래에서 스크립트 기능을 볼 수 있습니다. 이 예제에서는 HerokuApp 버전의 CORS Anywhere를 사용하고 있습니다.\n\n참고: HerokuApp 버전의 CORS Anywhere는 데모 및 테스트 용도로만 사용해야 합니다. 프로덕션 환경에서 CORS Anywhere를 사용하려면 이 링크를 참조하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst RSS_URL = 'https://cors-anywhere.herokuapp.com/https://medium.com/feed/@asbedb';\n\n$.ajax({\n    url: RSS_URL,\n    dataType: \"xml\",\n    success: function(data) {\n        $(data).find(\"item\").each(function() {\n            const el = $(this);\n            const contentEncoded = el.find(\"content\\\\:encoded\").text();\n            const tempDiv = document.createElement('div');\n            tempDiv.innerHTML = contentEncoded;\n            const pTags = tempDiv.getElementsByTagName('p');\n            const firstImg = tempDiv.querySelector('img');\n            const firstImageUrl = firstImg ? firstImg.getAttribute('src') : 'img/medium.webp'; // \u003cimg\u003e 태그가 없는 경우 기본 이미지 URL 제공\n\n            let firstTwoSentences = '';\n            if (pTags.length \u003e 0) {\n                const firstPTagContent = pTags[0].textContent.trim();\n                const sentences = firstPTagContent.split(/[\\.\\?!]\\s+/);\n                firstTwoSentences = sentences.slice(0, 1).join('. ');\n            }\n            //HTML Message-Embedder//\n            const template = `\n            \u003ca href=\"${el.find(\"link\").text()}\" target=\"_blank\"\u003e\n                \u003cdiv class=\"message-embed\"\u003e\n                    \u003cdiv id=\"title\" style=\"color: lightseagreen;\"\u003e${el.find(\"title\").text()}\u003c/div\u003e\n                    \u003cdiv id=\"pub-date\" class=\"post-pubdate\"\u003e${el.find(\"pubDate\").text()}\u003c/div\u003e\n                    \u003cdiv id=\"post-image\"\u003e\u003cimg class=\"message-embed-image\" src=\"${firstImageUrl}\"/\u003e\u003c/div\u003e\n                    \u003cdiv id=\"leading-message\" class=\"leading-message\"\u003e${firstTwoSentences}\u003c/div\u003e\n                \u003c/div\u003e\n            \u003c/a\u003e\n            `;\n            $(\"#rss-embed\").append(template);\n        });\n    },\n    error: function(xhr, status, error) {\n        console.error(\"Error fetching RSS feed:\", error);\n    }\n});\n```\n\n이제 한번 알아봅시다.\n\n우선 RSS_URL을 정의하여 RSS 피드를 가져올 것입니다. Heroku를 사용 중이라면 데모 기능을 사용하기 전에 도전을 완료해야합니다 (브라우저에서 표시됩니다).\n\n```js\nconst RSS_URL = 'https://cors-anywhere.herokuapp.com/https://medium.com/feed/@asbedb';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 RSS_URL을 정의한 후에는 jQuery AJAX 요청이 발생합니다. 이 작업은 피드를 확인하여 XML 피드가 제대로 제공되고 있는지 확인합니다.\n\n```js\n$.ajax({\n    url: RSS_URL,\n    dataType: \"xml\",\n    success: function(data) {\n```\n\n여기서 우리는 파싱 프로세스를 시작합니다. 대부분의 RSS 피드는 파싱할 콘텐츠를 `item` 태그에 분류할 것입니다. 예시로 Medium의 RSS 피드를 살펴보겠습니다.\n\n![Medium RSS feed](/assets/img/2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n관련 태그를 살펴보기 시작하면 소화해야 할 내용이 많을지도 모르겠어요. 우리는 주로 `item``/item` 내에 중첩된 내용에 관심을 가지고 있어요.\n\n```js\n$(data).find(\"item\").each(function() {\n    const el = $(this);\n    const contentEncoded = el.find(\"content\\\\:encoded\").text();\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = contentEncoded; \n```\n\n성공적인 데이터 호출 후에는 이제 `items`를 반복하면서 각 \"게시물\"/\"기사\"를 수집하려고 해요. 더 중요한 것은 여기서 특정 요소를 구문 분석하고 읽기 쉬운 HTML 형식으로 표시할 수 있어야 한다는 거에요.\n\n위 코드는 우리가 다룰 것이 많은 핵심 요소들을 임시로 세 가지 상수에 보관할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 `el`은 `item` 태그 내에 있는 모든 콘텐츠로 구성됩니다.\n\n두 번째 `contentEncoded`는 Medium RSS 태그 `content:encoded`에서 기사 콘텐츠로 구성됩니다.\n\n그런 다음 이를 `tempDiv`라는 새롭게 생성된 임시 `div`에 저장합니다.\n\n```js\n  const pTags = tempDiv.getElementsByTagName('p');\n  const firstImg = tempDiv.querySelector('img');\n  const firstImageUrl = firstImg ? firstImg.getAttribute('src') : 'img/medium.webp';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 파서를 작성한 방식은 카드가 내용을 포함하고 있어 해당 카드는 세 개의 요소를 가지며 원본 기사로 연결될 것을 의도하여 작성되었습니다.\n\n단순히 말하면, 카드에는 제목, 기사의 짧은 오프닝 문장, 발행 날짜, 그리고 카드를 클릭할 수 있는 형태로 기사의 첫 번째 이미지가 둥근 아이콘으로 표시될 것입니다.\n\n일부 추가적인 jQuery/JavaScript 마법이 우리가 필요로 하는 요소의 데이터를 \"세척\"하는 데 도움이 될 것입니다.\n\n여기에서는 p 태그로 pTags를 정의하여 요소`p`를 가져옵니다 (이것은 Medium이 사용하는 방법이며, 귀하의 RSS/XML 소스에 따라 다를 수 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nfirstImg은 첫 번째 `img` 태그를 찾고 해당 첫 번째 태그에서 속성 src=\"\"의 URL을 가져옵니다.\n\n이제 요소 중 하나를 가져왔으므로 p태그를 첫 두 문장으로 정리해야 합니다.\n\n```js\nlet firstTwoSentences = '';\nif (pTags.length \u003e 0) {\n    const firstPTagContent = pTags[0].textContent.trim();\n    const sentences = firstPTagContent.split(/[\\.\\?!]\\s+/);\n    firstTwoSentences = sentences.slice(0, 2).join('. ');\n}\n```\n\n여기서 firstTwoSentences라는 새 변수를 문자열로 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 첫 번째 if 문은 길이를 확인하여 pTags에 실제 콘텐츠가 있는지 확인합니다.\n\n그런 다음 처음 `p` 태그를 잘라 문자를 반복하는 수를 줄이고 \" . \" 문자를 분리자로 사용합니다!\n\n그런 다음 첫 번째 두 문장을 함께 잘라 생성된 문자열로 firstTwoSentences 변수를 대체합니다!\n\n마법 같은 일이 일어납니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  const template = `\n  \u003ca href=\"${el.find(\"link\").text()}\" target=\"_blank\"\u003e\n      \u003cdiv class=\"message-embed\"\u003e\n          \u003cdiv id=\"title\" style=\"color: lightseagreen;\"\u003e${el.find(\"title\").text()}\u003c/div\u003e\n          \u003cdiv id=\"pub-date\" class=\"post-pubdate\"\u003e${el.find(\"pubDate\").text()}\u003c/div\u003e\n          \u003cdiv id=\"post-image\"\u003e\u003cimg class=\"message-embed-image\" src=\"${firstImageUrl}\"/\u003e\u003c/div\u003e\n          \u003cdiv id=\"leading-message\" class=\"leading-message\"\u003e${firstTwoSentences}\u003c/div\u003e\n      \u003c/div\u003e\n  \u003c/a\u003e\n  `;\n  $(\"#rss-embed\").append(template);\n```\n\n마지막으로 모든 변수를 HTML 요소로 넣고 이를 rss-embed `container`에 추가해야 합니다.\n\n여기에서는 template이라는 변수를 만들고 XML 피드에서 직접 요소를 가져와서 새롭게 구문 분석한 `p` 태그를 HTML 형식으로 넣는 작업을 시작합니다. 이 스크립트에서 고려해야 할 중요한 사항은 다음과 같습니다.\n\n```js\n${el.find(\"title\").text()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 변수는 우리의 원본 AJAX jQuery 선택기에서 가져온 것입니다. 이는 XML 피드의 'items'에서 `title` 태그를 직접 가져오는 것입니다. link, pubDate에도 동일한 논리가 적용됩니다.\n\n```js\n${firstImageURL}\n${firstTwoSentences}\n```\n\n이것들은 이전 코드에서 호출된 변수들입니다.\n\n# css/styles.css\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스타일링은 완전히 당신에게 달려 있어요! 시작하는 데 도움이 되는 몇 줄의 코드가 있어요.\n\n```js\n:root{\n    /* 배경 색상 */\n    --darker: #292b2f;\n    \n    /* 글꼴 색상 */\n    --light-white: #cfcfcf; \n}\n\nbody{\n    background-color: var(--darker);\n    color: var(--light-white);\n    padding: 10px;\n    overflow-y: hidden;\n    font-family: \"Lucida Console\", Monaco, monospace;\n    font-size: 32px;\n    letter-spacing: 0px;\n    word-spacing: -3.8px;\n    font-weight: 700;\n}\n\na{\n  text-decoration: none;\n}\n\n.message-embed{\n    display: inline-flex;\n    flex-direction: column;\n    user-select: none; \n    text-align: center;\n    outline-style: solid;\n    border-radius: 10px;\n    outline-width: 1px;\n    outline-color: lightseagreen;\n    width: 200px;\n    cursor: pointer;\n    padding: 20px;\n    min-height: 300px;\n}\n\n.message-embed:hover{\n    outline-color: white;\n    box-shadow: -1px -1px 35px 10px rgba(255, 255, 255, 0.4);\n\n}\n\n.message-embed-image{\n    padding-top: 5px; \n    width: 150px; \n    height: 150px;\n    border-radius: 100%;\n}\n\n.post-pubdate, .leading-message{\n    font-size: 15px;\n    padding-top: 12px;\n    color: white;\n}\n```","ogImage":{"url":"/assets/img/2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS_0.png"},"coverImage":"/assets/img/2024-06-20-IntroducinganEfficientRSSJavaScriptParserwithCORS_0.png","tag":["Tech"],"readingTime":10},{"title":"깃허브에서 SSH 키 생성하는 빠른 스텝별 가이드","description":"","date":"2024-06-20 01:03","slug":"2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub","content":"\n\n## 쉽고 간단하며 비기술적인 설명\n\n![이미지](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_0.png)\n\n친구들,\n\n이 튜토리얼은 우리 둘 다를 위한 것이에요. SSH 키를 설정해야 했던 적이 두세 번 있었는데, 매번 악몽이었죠. 즐겁게 경험한 적은 없어요. 제가 찾은 대부분의 튜토리얼은 복잡하고 따라가기 어려웠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 프로세스를 간단히 설명하겠습니다. SSH 키를 생성하는 간단한, 비기술적인, 단계별 가이드를 제공하겠습니다. 영어로 설명되어 있어 초등학생조차 따를 수 있을 것이며, 사진도 있습니다. 누가 사진을 싫어하겠어요?\n\n시작해봅시다.\n\n## Windows 터미널\n\n시작하기 위해 Windows 터미널을 여시면 됩니다. 이 튜토리얼에서는 Ubuntu 터미널을 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_1.png)\n\n현재 데스크톱 폴더에 있는지 확인해주세요. 위 스크린샷에서 보듯이, 저는 현재 데스크톱 폴더에 있어요.\n\n만약 데스크톱 폴더에 있지 않다면, 수정해봅시다.\n\n- 폴더에 들어가려면 cd 폴더명을 사용하세요. 폴더명 자리에 들어가고 싶은 폴더명을 넣어주세요.\n- 현재 폴더를 벗어나려면 cd ~를 사용하세요.\n- 현재 위치한 폴더 안의 폴더와 파일을 보려면 ls를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령어를 사용하여 데스크톱 폴더로 이동하세요.\n\n## SSH 폴더 열기\n\n교수님께서 .ssh 폴더에 SSH 키를 저장하라고 가르쳐 주셨어요. 그렇게 하면 모든 키가 동일한 폴더에 포함됩니다. 이제 그 방법을 보여 드릴게요.\n\n이 폴더를 생성하려면 다음을 실행하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir .ssh\n```\n\nmkdir은 현재 폴더에 새 디렉토리(즉, 폴더)를 만드는 명령어입니다. 현재 데스크톱 폴더에 있기 때문에 이 명령은 데스크톱에 .ssh라는 폴더를 만듭니다.\n\n그리고 나중을 위해, 만약 이 폴더가 이미 있는지 확인하고 싶다면, 다음을 실행할 겁니다:\n\n```js\nls -larths\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 표시된 이미지는 ls -larths 명령어의 결과입니다. 제일 아래에서 .ssh 폴더를 볼 수 있습니다. 저는 그것을 노란색으로 강조했어요.\n\n이 폴더를 생성한 후에는 이 폴더로 이동하고 싶어요. 다음 명령어로 폴더로 이동하세요:\n\n```js\ncd .ssh\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SSH 키 생성하기\n\nSSH 폴더 안에 있어요. 제 경우처럼 SSH 키가 이미 있는 경우가 있습니다. 우리는 개인 및 공개 RSA 키를 가지고 있습니다.\n\n키가 이미 있는지 확인하려면 ls를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 경우에는 그 키들이 존재합니다. 저희의 개인 키인 id_rsa가 있습니다. 아무에게도 공유하지 마세요. 그리고 우리의 공개 키인 id_rsa.pub도 있습니다. 이웃들과 자유롭게 공유하세요.\n\n만약 키가 없다면, 만들어 봅시다. .ssh 폴더 안에서 다음 명령어를 실행하세요:\n\n```js\nssh-keygen -b 4096 -t rsa\n```\n\n이 명령은 4096비트의 RSA 키를 생성합니다. 이는 고수준의 암호화를 제공합니다. 원한다면 다르게 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커스터마이징할 수 있는 내용을 보려면 man ssh-keygen 명령어를 실행해보세요. 여기서 사용할 수 있는 모든 플래그가 표시될 거에요. 하지만 초보자라면 위 명령어로 충분히 작동할 거예요. 일이 처리될 거에요.\n\n명령어를 실행해보세요. 공개 및 비공개 RSA 키 쌍을 생성하기 시작할 거에요. 파일, 비밀번호, 그리고 다시 한번 비밀번호를 요청할 거에요. 모두 엔터 키를 눌러 건너뛸 수 있어요.\n\n그러면 끝이에요. RSA 키가 생성되었습니다. 앞서 말한 대로 ls를 사용해 키가 이미 존재하는지 확인할 수 있어요.\n\n![image](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 확인하실 수 있어요.\n\n한 번, 우리가 id_rsa.pub 인 공개 키를 가지게 되면, 이것을 확인하고 싶어요. SSH 키를 확인하고 싶어요.\n\n다음 명령어를 사용하여 id_rsa.pub 파일을 열어봐요.\n\n```js\nless id_rsa.pub\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_5.png\" /\u003e\n\n요렇게 나와야 할 거에요. 전체 청크를 복사하시고요 — 전체 청크를 말이에요. 그 다음에 GitHub에 붙여넣을 거에요.\n\n# GitHub\n\n## GitHub에 로그인하고 설정으로 이동하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Step 6](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_6.png)\n\n## Open the Tab “SSH and GFG Keys”\n\n![Step 7](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_7.png)\n\n## Create a “NEW SSH KEY”\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_8](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_8.png)\n\nThe screen shown below will pop up.\n\n![QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_9](/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_9.png)\n\nGive your SSH key a meaningful title. I called mine ASUS LAPTOP.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 SSH 키를 붙여넣으세요. \"SSH 키 추가\" 버튼을 누르세요. GitHub에서 당신이 정말 본인임을 확인하려면 비밀번호를 입력하라는 메시지가 표시될 거에요. 비밀번호를 확인한 후에는 모두 준비된 거죠!\n\n이제 여러분은 SSH 키가 항상 데스크톱에 저장된다는 것을 기억할 수 있어요. 그 키들은 .ssh라는 폴더에 있답니다.\n\n끝났어요. 축하해요.","ogImage":{"url":"/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_0.png"},"coverImage":"/assets/img/2024-06-20-QuickStep-By-StepGuidetoGeneratinganSSHKeyinGitHub_0.png","tag":["Tech"],"readingTime":4},{"title":"나는 UX 디자이너로서 웹앱을 코딩했어","description":"","date":"2024-06-20 01:01","slug":"2024-06-20-IcodedawebappasaUXdesigner","content":"\n\n## ChatGPT 4.0을 이용하여\n\n![이미지](/assets/img/2024-06-20-IcodedawebappasaUXdesigner_0.png)\n\n저는 5년간 디자이너로 활동해왔습니다. 주로 전문 소프트웨어 프로젝트를 다루는 UX 기획 에이전시에서 일했어요. ERM과 기술 작업의 디지털화를 생각해보세요.\n\n제 커리어 동안 왜 소프트웨어가 종종 부적합하고 가끔 못생긴지 항상 궁금했습니다. 왜 디자이너들에게는 디자인이 개발자들에게는 복잡한 것인가? 이에 대한 답은 쉽게 얻을 수 있습니다. 개발자들은 코드 줄이나 수학적인 공식과 함께 작업하며 엄격한 문법을 갖춘 개발 언어에 집중해야 합니다. 한편 디자이너들은 시각적 도구로 작업하여 즉시 결과물을 표시하고 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 차이는 디자이너로서의 일상적인 작업에서 근본적인 것입니다. 무언가를 만들 때, 코드화해야 할 사람에 대해 생각하는 것이 중요합니다. 그래서 많은 구인 공고에서 디자이너들이 적어도 HTML, CSS, 그리고 Javascript에 대한 기본적인 이해를 갖추도록 요청합니다.\n\n나는 이러한 언어들 간의 관계와 작동 방식에 대한 전반적인 개념을 알고 있었지만, 풀 스택 디자이너가 되기 위한 탐구로, 프로젝트를 처음부터 실행하는 것을 실험해 보고 개발자의 역할을 경험해 보고 싶었습니다. 그것은 재미있었지만 답답한 경험이었습니다.\n\n![이미지](/assets/img/2024-06-20-IcodedawebappasaUXdesigner_1.png)\n\n## 왜 코딩을 배우는가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몇 년 전에 코딩을 시도해 봤어요. HTML에 대한 기본 과정을 따라했지만, 저에게는 너무 추상적이었어요. 시각적인 것에 집중하고, 사람들에게 미치는 심리적 영향에 관심이 많은 창의적인 사람이에요. 최소한의 것을 만들기 위해 많은 텍스트를 작성해야 한다는 것이 충분히 자극적이지 않았어요. 결국 이론을 이해하고 실습하지 않아도 만족했어요.\n\n얼마나 많이 변했나요? 2019년부터 모든 게 달라졌어요. 오늘 시장을 혁신하고 있는 두 가지 기술은 인공지능과 가상/증강 현실이에요. 디자이너들은 이러한 도구를 이해하여 그 주위의 경험을 설계해야 해요. 나는 미래를 두렵게 여기지 않아요, 왜냐하면 디자이너가 개발자와 사용자 사이의 인터페이스 역할을 하기 때문이에요. 모든 기술은 최종 사용자를 배려하여 무엇을 해야하고 하지 말아야하는지 정의해야 하는 사람이 필요하죠.\n\n인공지능을 이해하기 위해서는 어려운 개념을 완전히 파악해야 해요. LLM, 파이썬, 딥러닝. 나는 이러한 개념에 대한 전반적인 이해를 원하지 않아요, 더 공부하고 싶어요. 그래서 HTML, CSS, JS부터 시작해야 했어요. 그것에 만족하게 되면, 인공지능을 위해 Python에 투자하고, VR을 위해 Swift에 투자할 거예요.\n\n## 프로젝트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약 30대에 결혼하는 사람들이 많고, 결혼식에서 가장 이슈가 되는 부분 중 하나는 플랜 테이블입니다. 저는 결혼 계획 앱을 개발했어요.\n\n먼저, 어떻게 작동해야 하는지에 대한 몇 가지 명세를 작성했어요:\n\n- 사용자는 각 손님의 이름, 나이, 직업, 취미를 작성해야 합니다\n- 각 손님에 대해 관계를 세 가지 카테고리로 지정해야 합니다: 분할을 피하기 위해 부족할 수 없는 관계, 친구들이 같은 테이블에 앉을 가능성을 최대화하기 위해 좋아하는 관계, 충돌하는 사람들이 같은 테이블에 앉지 않도록 피해야 하는 관계.\n- 사용자는 몇 개의 테이블이 있고 각 테이블당 몇 개의 의자가 있는지 결정해야 합니다\n- \"플랜 테이블 생성\"을 클릭하면 관계가 지정된 것을 고려하여 목록이 무작위로 생성됩니다.\n\n저는 Figma에 스케치한 것이 있어요. 이번에는 개발자로서 최소한의 작업을 하기로 결정하여 단순한 지구를 만들어 구조를 염두에 두기로 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 나의 코딩 여정을 시작했다. 먼저, codédex.com의 무료 튜토리얼을 하루 동안 따르기로 했다. 이 사이트는 레트로 UI가 매우 재미있는 웹사이트다. 내가 곧 더 고급 부분의 튜토리얼을 따르기 위해 매달 6달러를 지불할 것을 알고 있다.\n\nVisual Studio를 다운로드하고 html 파일을 시작했다. HTML은 그리 어렵지 않다. '를 빼먹으면 열심히 한 디자인도 망칠 수 있다. Visual Studio는 초보자가 따라가는 데 도움이 되는 작은 힌트가 가득하다.\n\n내 첫 번째 문제는 div 컨테이너에서 요소들을 정렬하는 데서 생겼다. 그리 복잡하지 않을 것 같지만, 초보자는 가로 정렬 코드를 작성하기 위한 구문을 짐작하거나 새롭게 창의적으로 할 수 없다. 내 해결책은 ChatGPT 4.0에 도움을 요청하는 것이었다. 인공지능과 대화하는 것은 까다로울 수 있다. 모든 것을 과하게 설명하고 너무 많은 세부사항을 제공하기 때문이다. 그러나 그 역할을 \"20년간 HTML, CSS 및 JS 전문가인 코딩 교수\"로 정의하고 전체 문서를 다시 작성하는 대신 필요한 코드 줄만 필요하다고 말하니 잘 작동했다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 단계씩 나의 원하는 것을 설명했다. 생성된 IA 코드를 분석하고 설명을 요청했다. JS 부분에 도달했을 때, 처음부터 다시 시작하기로 결정했다. 모든 작업을 인공지능이 대신 하는 것은 좋지만, 학습과 정보 보존에 영향을 미친다.\n\n도움 없이 HTML을 다시 썼고, CSS는 ChatGPT 확인을 받으며 다시 썼으며, JS는 IA의 도움을 받았지만, 무엇이 실행되었는지 재현하는 학습에 집중했다. 내가 ID를 기준으로 요소에 초점을 맞추고, 이벤트를 듣고 함수를 시작하도록 하는 스크립트의 시작 부분을 자신 있게 작성할 수 있다.\n\n내가 작업하는 방법에서 두 가지 주요 문제를 발견했다:\n\n- 프로젝트를 혼자서 관리하기 위해 3개의 언어를 배워야 한다는 것이다. 그리 많지 않지만, 잘못된 구문을 사용함으로써 실수를 범하기가 매우 쉽다.\n- 두 번째로, 시스템을 어떻게 관리해야 할지 몰랐다. 이 프로젝트는 사실상 아무것도 아니다. 폼과 두 개의 목록이다. 그럼에도 CSS를 사용하여 다양한 구성 요소의 ID를 기억할 수 없어서 이를 수정하거나 JS를 호출하는 방법을 모르겠다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-20-IcodedawebappasaUXdesigner_3.png)\n\n## 결국...\n\n너무 야 ambicio했어요. 너무 많은 기능들을 원했어요, 특히 관계 부분이요. 코딩하는 것은 그리 어렵지 않을 것이지만, 이 프로젝트의 목표는 코딩의 최소를 배우는 것이었어요. 나는 손님 목록을 기반으로 무작위 테이블을 생성하는 MVP에 집중했어요. 여기 결과입니다:\n\n![결과](https://miro.medium.com/v2/resize:fit:1200/1*dSoEhPKNX2q2mRCwdeCVlA.gif)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFigma에 제 마음대로 디자인하고 동적으로 만드는 데는 작은 오후가 걸렸을 것 같아요. UI가 없는 반작동 MVP를 3일동안 만들었어요. 이제야 이해가 가네요. 이제부터는 MVP를 디자인하고, 개발자들에게 천천히 발전하는 과정을 보여주며 새로운 기능을 추가할 계획이에요. \n\n코딩은 그리 안 어렵지 않았어요. 새 코드 한 줄마다 그래픽적인 영향을 바로 볼 수 있도록 VisualStudio에서 라이브 서버 플러그인을 사용했기 때문에 즐거웠어요. HTML/CSS에서 상자의 논리는 Figma의 자동 레이아웃과 유사해요. \n\n다음 단계는 이 프로젝트를 완료하고, 아마 Gumroad에서 공개할지도 몰라요. 다음 실험은 머릿속에 있는 VR 기기를 모델링하는 Blender일 겁니다. 재미있게 배울 것이 너무 많아요. \n\n---\n본문이 이전과 다른 이유로 이것을 덧붙이고 있습니다. 처음부터 다시 번역하거나 수정이 필요하신 경우 말씀해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 이야기를 받아보고 싶다면, 구독하고 좋아요 버튼을 눌러주시면 저를 응원해주는 거에요 :)","ogImage":{"url":"/assets/img/2024-06-20-IcodedawebappasaUXdesigner_0.png"},"coverImage":"/assets/img/2024-06-20-IcodedawebappasaUXdesigner_0.png","tag":["Tech"],"readingTime":5},{"title":"ReactJs를 사용한 테이블 페이지네이션 구현하기 간단한 안내","description":"","date":"2024-06-20 00:59","slug":"2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide_0.png\" /\u003e\n\n안녕하세요!\n\n개발자로서 모두가 여행 중에 이러한 시나리오를 만난 적이 있을 거에요. 오랜 데이터가 있고 웹 페이지에 표시할 공간이 제한되어 있거나 표시해도 UI가 약간 느립니다. 그래서, 우리는 이 상황을 다루기 위해 Pagination이라는 기술을 사용합니다.\n\nPagination이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 UI 프레임워크에서는 테이블과 페이지네이션 기능을 제공하며, 이 포스트에서는 우리만의 방법으로 구현해보고 있습니다. 또한 페이지네이션은 기계 코딩 면접에서 자주 묻는 질문 중 하나입니다.\n\n요구 사항: React 및 CSS의 기본 지식\n\n그러니 이 데모를 만들어 봅시다! (이 GIF에서는 마우스 클릭이 보이지 않습니다)\n\n![데모](https://miro.medium.com/v2/resize:fit:1200/0*EkEwLTBUF_iIa5nL.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 에디터를 열고 터미널에서 아래 명령을 사용하여 'pagination-demo' 라는 리액트 앱을 생성하세요.\n\n```js\nnpx create-react-app pagination-demo\n```\n\n2. 폴더 구조에서 불필요한 파일을 모두 제거하고 메인 파일인 App.jsx만 남도록 하세요.\n\n3. components라는 폴더를 만들고 그 안에 Demo.jsx, Table.jsx 및 Demo.css 파일을 각각 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 표를 다른 구성 요소로 분리했습니다.\n\n우리의 데모에서는 https://jsonplaceholder.typicode.com/todos 와 같이 알려진 가짜 REST API에서 데이터를 가져올 것입니다. 해당 API는 길이가 200인 객체 배열을 반환할 것입니다.\n\n- Demo.css\n\n```js\n#container {\n  display: flex;\n  flex-direction: column;\n  width: 900px;\n  align-items: flex-end;\n  gap: 1rem;\n  margin-top: 3rem;\n  margin-left: 5rem;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\ncss\ntable {\n  border: 1px solid black;\n  width: 100%;\n}\ntable tr td {\n  max-width: 100%;\n  white-space: nowrap;\n  overflow: hidden;\n}\ntd,\nth {\n  padding: 5px;\n  border: 1px solid black;\n  text-align: center;\n}\ntd:nth-child(2) {\n  width: 70% !important;\n}\n#page-no-dropdown {\n  width: fit-content;\n  border: 1px solid black;\n  padding: 2px;\n}\nselect:focus-visible {\n  outline: none;\n  border: none;\n}\nbutton {\n  border: 1px solid black;\n  padding: 2px;\n}\n\n\n2. Table.jsx\n\n이 컴포넌트에서는 부모 컴포넌트로부터 dataToDisplay를 받아옵니다.\n\n테이블 헤더에는 (userId)를 제외한 3가지 헤더 값을 표시합니다. (포함하려면 포함할 수 있습니다). 테이블 본문에는 해당 값들을 표시합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nexport default function Table({ dataToDisplay }) {\r\n  return (\r\n    \u003ctable\u003e\r\n      \u003cthead\u003e\r\n        \u003ctr\u003e\r\n          {Object.keys(dataToDisplay[0]).map((key) =\u003e {\r\n            if (key != \"userId\") return \u003cth key={key}\u003e{key.toUpperCase()}\u003c/th\u003e;\r\n          })}\r\n        \u003c/tr\u003e\r\n      \u003c/thead\u003e\r\n      \u003ctbody\u003e\r\n        {dataToDisplay.map((obj) =\u003e {\r\n          return (\r\n            \u003ctr key={obj.id}\u003e\r\n              \u003ctd\u003e{obj.id}\u003c/td\u003e\r\n              \u003ctd\u003e{obj.title}\u003c/td\u003e\r\n              \u003ctd\u003e{obj.completed.toString()}\u003c/td\u003e\r\n            \u003c/tr\u003e\r\n          );\r\n        })}\r\n      \u003c/tbody\u003e\r\n    \u003c/table\u003e\r\n  );\r\n}\r\n```\r\n\r\n3. Demo.jsx.\r\n\r\n- 이 컴포넌트에서는 두 개의 버튼을 포함하고 있습니다. 한 버튼은 다음 페이지로 이동하고 다른 하나는 이전 페이지로 이동합니다. 또한 특정 페이지로 이동할 수 있는 셀렉트 드롭다운을 만들었습니다.\r\n- 앞서 말했듯이 API에서 데이터를 가져올 것이기 때문에 useEffect()에서 해당 호출을 수행했으며 모든 값은 setData()를 사용하여 data 변수에 저장됩니다.\r\n- 또한 페이지당 10개의 값만 표시할 것이기 때문에 응답 배열을 0부터 10까지 슬라이스하여 dataToDisplay 변수가 길이가 10인 배열을 가지게 합니다.\r\n\r\n```js\r\nconst [data, setData] = useState([]);\r\nconst [currentPageNumber, setCurrentPageNumber] = useState(1);\r\nconst [dataToDisplay, setDataToDisplay] = useState([]);\r\nconst TOTAL_VALUES_PER_PAGE = 10;\r\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nuseEffect(() =\u003e {\n    fetch(\"https://jsonplaceholder.typicode.com/todos\")\n      .then((response) =\u003e response.json())\n      .then((res) =\u003e {\n        setData(res);\n        setDataToDisplay(res.slice(0, TOTAL_VALUES_PER_PAGE));\n      });\n  }, []);\n```\n\n- 여기에는 총 3개의 함수가 있어요 = `goOnPrevPage(), goOnNextPage(), handleSelectChange()\n\n```js\nconst goOnPrevPage = () =\u003e {\n    if (currentPageNumber === 1) return;\n    setCurrentPageNumber((prev) =\u003e prev - 1);\n  };\n```\n\n```js\n  const goOnNextPage = () =\u003e {\n    if (currentPageNumber === data.length / TOTAL_VALUES_PER_PAGE) return;\n    setCurrentPageNumber((prev) =\u003e prev + 1);\n  };\n  const handleSelectChange = (e) =\u003e {\n    setCurrentPageNumber(e.target.value);\n  };\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 또 다른 useEffect가 있어요. currentPageNumber가 의존성으로 설정되어 있어서 페이지 번호가 변경될 때마다 이 블록이 실행되고 데이터 배열을 잘라내어 dataToDisplay를 업데이트할 거예요.\n\n```js\nuseEffect(() =\u003e {\n    const start = (currentPageNumber - 1) * TOTAL_VALUES_PER_PAGE;\n    const end = currentPageNumber * TOTAL_VALUES_PER_PAGE;\n    setDataToDisplay(data.slice(start, end));\n  }, [currentPageNumber]);\n```\n\n그리고 마지막으로 렌더링될 UI 코드가 있어요. 여기서 데이터가 가져오는 중이면 '로딩 중...'을 보여주는 조건이 추가되어 있어요.\n\n```js\nif (data.length == 0) return \u003cdiv\u003eLoading...\u003c/div\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  return (\n    \u003cdiv id=\"container\"\u003e\n      \u003cdiv id=\"page-no-dropdown\"\u003e\n        \u003cselect\n          name=\"page-number\"\n          onChange={handleSelectChange}\n          value={currentPageNumber}\n        \u003e\n          {Array.from(Array(data.length / TOTAL_VALUES_PER_PAGE))\n            .map((e, i) =\u003e i + 1)\n            .map((val) =\u003e {\n              return \u003coption key={val}\u003e{val}\u003c/option\u003e;\n            })}\n        \u003c/select\u003e\n      \u003c/div\u003e\n      \u003cTable dataToDisplay={dataToDisplay} /\u003e\n      \u003cdiv id=\"btn-container\"\u003e\n        \u003cbutton onClick={goOnPrevPage}\u003ePrev\u003c/button\u003e\n        \u003cbutton onClick={goOnNextPage}\u003eNext\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n```\n\n```js\n{Array.from(Array(data.length / TOTAL_VALUES_PER_PAGE))\n      .map((e, i) =\u003e i + 1)\n       .map((val) =\u003e {\n    return \u003coption key={val}\u003e{val}\u003c/option\u003e;\n})}\n```\n\n이 블록은 데이터가 페이지로 나뉘어진 개수만큼 1부터 페이지 번호까지의 배열을 생성합니다.\n\n데모에서 데이터 길이가 200이고 페이지 당 10개의 행을 표시하므로, totalPages = 200/10이므로 20이 됩니다. 따라서 [1,2,3……20]과 같은 배열이 생성되며, 이를 매핑하여 선택 드롭다운의 옵션을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 Markdown 형식으로 변경한 것입니다!\n\n```js\nimport React, { useEffect, useState } from \"react\";\nimport Table from \"./Table\";\nimport \"./table.css\";\n```\n\n```js\nexport default function HomeDashboard() {\n  const [data, setData] = useState([]);\n  const [currentPageNumber, setCurrentPageNumber] = useState(1);\n  const [dataToDisplay, setDataToDisplay] = useState([]);\n  const TOTAL_VALUES_PER_PAGE = 10;\n  const goOnPrevPage = () =\u003e {\n    if (currentPageNumber === 1) return;\n    setCurrentPageNumber((prev) =\u003e prev - 1);\n  };\n  const goOnNextPage = () =\u003e {\n    if (currentPageNumber === data.length / TOTAL_VALUES_PER_PAGE) return;\n    setCurrentPageNumber((prev) =\u003e prev + 1);\n  };\n  const handleSelectChange = (e) =\u003e {\n    setCurrentPageNumber(e.target.value);\n  };\n  useEffect(() =\u003e {\n    const start = (currentPageNumber - 1) * TOTAL_VALUES_PER_PAGE;\n    const end = currentPageNumber * TOTAL_VALUES_PER_PAGE;\n    setDataToDisplay(data.slice(start, end));\n  }, [currentPageNumber]);\n  useEffect(() =\u003e {\n    fetch(\"https://jsonplaceholder.typicode.com/todos\")\n      .then((response) =\u003e response.json())\n      .then((res) =\u003e {\n        setData(res);\n        setDataToDisplay(res.slice(0, TOTAL_VALUES_PER_PAGE));\n      });\n  }, []);\n  if (data.length == 0) return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  return (\n    \u003cdiv id=\"container\"\u003e\n      \u003cdiv id=\"page-no-dropdown\"\u003e\n        \u003cselect\n          name=\"page-number\"\n          onChange={handleSelectChange}\n          value={currentPageNumber}\n        \u003e\n          {Array.from(Array(data.length / TOTAL_VALUES_PER_PAGE))\n            .map((e, i) =\u003e i + 1)\n            .map((val) =\u003e {\n              return \u003coption key={val}\u003e{val}\u003c/option\u003e;\n            })}\n        \u003c/select\u003e\n      \u003c/div\u003e\n      \u003cTable dataToDisplay={dataToDisplay} /\u003e\n      \u003cdiv id=\"btn-container\"\u003e\n        \u003cbutton onClick={goOnPrevPage}\u003ePrev\u003c/button\u003e\n        \u003cbutton onClick={goOnNextPage}\u003eNext\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n즐겁게 코딩하고 계속 배워 나가세요!!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다! 좋아요와 댓글 부탁드려요...","ogImage":{"url":"/assets/img/2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide_0.png"},"coverImage":"/assets/img/2024-06-20-ImplementingTablePaginationwithReactJsASimpleGuide_0.png","tag":["Tech"],"readingTime":8}],"page":"48","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"48"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>