<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/48" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="ApolloClient와 함께 Fragment Colocation" href="/post/2024-06-20-FragmentColocationwithApolloClient"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ApolloClient와 함께 Fragment Colocation" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ApolloClient와 함께 Fragment Colocation" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ApolloClient와 함께 Fragment Colocation</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 최고의 권장사항" href="/post/2024-06-20-AngularBestPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 최고의 권장사항" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularBestPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 최고의 권장사항" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 최고의 권장사항</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제스트 테스트 스위트가 왜 느릴까요" href="/post/2024-06-20-WhyIsMyJestTestSuiteSoSlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제스트 테스트 스위트가 왜 느릴까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제스트 테스트 스위트가 왜 느릴까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">제스트 테스트 스위트가 왜 느릴까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주피터 랩 IDE 기본기 TypeScript와 Deno" href="/post/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주피터 랩 IDE 기본기 TypeScript와 Deno" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주피터 랩 IDE 기본기 TypeScript와 Deno" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">주피터 랩 IDE 기본기 TypeScript와 Deno</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 데이터 가져오기 패턴" href="/post/2024-06-20-DatafetchingpatternsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 데이터 가져오기 패턴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DatafetchingpatternsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 데이터 가져오기 패턴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 데이터 가져오기 패턴</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS, TCP 및 Typescript로 Microservices 구축하기" href="/post/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS, TCP 및 Typescript로 Microservices 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS, TCP 및 Typescript로 Microservices 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS, TCP 및 Typescript로 Microservices 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 Redux를 이용한 테마 설정" href="/post/2024-06-20-ThemingWithReduxinReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 Redux를 이용한 테마 설정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 Redux를 이용한 테마 설정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 Redux를 이용한 테마 설정</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 코드 향상을 위한 최상의 실천 방법" href="/post/2024-06-20-ReactBestPracticestoImproveYourCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 코드 향상을 위한 최상의 실천 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactBestPracticestoImproveYourCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 코드 향상을 위한 최상의 실천 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 코드 향상을 위한 최상의 실천 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Box UI Elements, React, Tailwind CSS, Vercel을 사용하여 콘텐츠 포털을 만드는 방법 - 파트 1" href="/post/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Box UI Elements, React, Tailwind CSS, Vercel을 사용하여 콘텐츠 포털을 만드는 방법 - 파트 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Box UI Elements, React, Tailwind CSS, Vercel을 사용하여 콘텐츠 포털을 만드는 방법 - 파트 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Box UI Elements, React, Tailwind CSS, Vercel을 사용하여 콘텐츠 포털을 만드는 방법 - 파트 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제목 파트 2 리액트  훅의 명명 규칙 및 반환 형식" href="/post/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제목 파트 2 리액트  훅의 명명 규칙 및 반환 형식" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제목 파트 2 리액트  훅의 명명 규칙 및 반환 형식" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">제목 파트 2 리액트  훅의 명명 규칙 및 반환 형식</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link posts_-active__YVJEi" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"ApolloClient와 함께 Fragment Colocation","description":"","date":"2024-06-20 00:20","slug":"2024-06-20-FragmentColocationwithApolloClient","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png\" /\u003e\n\n# Fragment이란 무엇인가요?\n\nFragment Colocation에 대해 논의하기 전에, 먼저 Fragment가 무엇인지 간단히 설명하겠습니다.\n\nGraphQL에서 Fragment는 쿼리의 재사용 가능한 조각입니다. Fragment를 사용하면 코드 중복을 피하고 쿼리를 구성할 때 특히 여러 쿼리에서 같은 데이터 조각을 검색할 때 쿼리를 조직화할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfragment UserDetails on User {\n  id\n  name\n  email\n}\n\nquery GetUser {\n  user(id: 1) {\n    ...UserDetails\n  }\n}\n\nquery GetAllUsers {\n  users {\n    ...UserDetails\n  }\n}\n```\n\n이 예제에서는 UserDetails라는 fragment가 정의되었고 GetUser 및 GetAllUsers 쿼리 내에서 재사용됩니다. 이렇게 하면 동일한 데이터 부분을 여러 번 작성할 필요가 없어집니다. (이 코드는 ChatGPT에 의해 생성됨.)\n\n# Fragment Colocation이란\n\n일본에서는 Fragment Colocation(apollo Client에서 fragment 일치)라고도 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFragment Colocation은 GraphQL fragments가 해당 컴포넌트와 함께 배치되는 디자인 접근 방식입니다. 이 방식은 어떤 컴포넌트가 어떤 데이터를 필요로 하는지 명확히 알려주어 데이터 의존성을 관리하기 쉽게 만들어줍니다.\n\n현대 프런트엔드 개발에서 데이터 가져오기와 표시는 밀접한 관련이 있습니다. 전통적인 방법은 종종 데이터 가져오기 로직을 여러 곳에 분산시켜 유지보수성과 재사용성이 감소하게 됩니다. Fragment Colocation은 이러한 문제를 중앙화하고 효율적으로 데이터 의존성을 조직화함으로써 해결합니다.\n\n# Shippio의 문제점 ⛴\n\nShippio에서는 Apollo Client를 GraphQL 클라이언트 라이브러리로 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 몇 가지 문제가 발생했습니다:\n\n- 자식 컴포넌트가 의존하지 않는 필드를 포함하여 불필요한 props가 전달됩니다.\n- 필요한 필드를 추가하려면 부모 컴포넌트의 쿼리 필드를 수정해야 했는데, 이는 상당한 영향을 미쳤습니다.\n- props를 통해 전달된 값이 서버에서 가져온 것인지 클라이언트에서 생성된 것인지 명확하지 않았습니다.\n- 위 문제를 해결하기 위해 여러 자식 컴포넌트에서 useQuery를 사용하여 필요한 값만 가져오도록 했지만, 이는 GraphQL 같지 않았고 요청 수가 증가했습니다.\n- 모든 쿼리를 단일 gql 디렉토리에 중앙 집중시키면 의존하는 컴포넌트를 식별하기 어려워졌습니다.\n\n## 코드 샘플 (실제 코드가 아닙니다)\n\n```js\n// 파일 트리\n\nsrc\n├── App.tsx\n├── components\n│   ├── ShipmentList.tsx\n│   ├── ShipmentListHeader.tsx (ShipmentList.tsx의 자식 컴포넌트)\n│   ├── ShipmentListItem.tsx (ShipmentList.tsx의 자식 컴포넌트)\n└── gql\n    ├── ShipmentListQuery.ts (쿼리)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n// gql 폴더의 ShipmentListQuery\n\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      team {\n       name\n      }\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n    }\n  }\n`);\n\nexport type ShipmentListQueryItem = ArrayType\u003cQuery['shipmentSearch']\u003e;\n```\n\n```javascript\n// ShipmentList.tsx (루트 컴포넌트)\n\nexport const ShipmentList = () =\u003e {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   \u003cStack\u003e\n     \u003cShipmentListHeader shipment={data.shipment} /\u003e\n     \u003cShipmentListItem shipment={data.shipment} /\u003e\n   \u003c/Stack\u003e\n}\n```\n\n```javascript\n// ShipmentListItem.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\nexport const ShipmentListItems = ({ shipment }: Props) =\u003e { \n  return (\n   \u003cStack\u003e\n     {shipment.milestones.map((milestone) =\u003e (\n       \u003cBox key={milestone.id}\u003e\n         \u003cText\u003e{milestone.milestoneType}\u003c/Text\u003e\n           \u003cText\u003e{milestone.status}\u003c/Text\u003e\n           \u003cText\u003e{milestone.completionDoneAt}\u003c/Text\u003e\n         \u003c/Box\u003e\n     )}\n   \u003c/Stack\n}\n```\n\n```javascript\n// ShipmentListHeader.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipment }: Props) =\u003e { \n  return (\n   \u003cStack\u003e\n     \u003cText\u003e{shipment.team.name}\u003c/Text\u003e\n   \u003c/Stack\u003e\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음에는 이 접근 방식이 좋아 보입니다. 하지만 컴포넌트가 더 복잡해지고 구조가 더 중첩되면 위에서 언급한 문제가 발생할 수 있습니다.\n\n## 이슈 예시\n\n- ShipmentListHeader에서 팀 ID를 표시하려면 부모인 ShipmentList 컴포넌트의 쿼리를 수정해야 합니다. (자식 컴포넌트의 변경 사항이 부모 컴포넌트에 영향을 미칩니다.)\n- 전체 data.shipment 객체를 전달하는 것은 의도하지 않은 처리로 이어질 수 있습니다.\n- ShipmentListItem은 마일스톤만 필요하지만 팀 정보도 받습니다.\n- ShipmentListHeader는 팀 정보만 필요하지만 마일스톤도 받습니다.\n\n# Apollo Client를 사용한 Fragment Colocation 연습\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 Fragment Colocation을 활용하여 개선해 봅시다.\n\n이 글을 사용하기 위해 다음 패키지들이 필요합니다.\n\n```js\n@apollo/client\n@graphql-codegen/cli\n@graphql-codegen/client-preset\n```\n\ncodegen.ts 파일의 설정은 아래와 같습니다. preset을 client로 설정하여 client-preset의 대부분 기능을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// codegen.ts\n\nimport { CodegenConfig } from '@graphql-codegen/cli'\n \nconst config: CodegenConfig = {\n  schema: '\u003cschema 경로\u003e',\n  documents: ['src/**/*.tsx'],\n  ignoreNoDocuments: true,\n  generates: {\n    './src/__codegen__/': {\n      preset: 'client'\n    }\n  }\n}\n \nexport default config\r\n```\n\n참고 링크: https://the-guild.dev/graphql/codegen/docs/guides/react-vue\n\n## Fragment Colocation을 사용한 코드 재작성\n\n```js\r\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      ...ShipmentListHeaderFragment\n      ...ShipmentListItemFragment\n    }\n  }\n`);\n\nexport const ShipmentList = () =\u003e {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   \u003cStack\u003e\n     \u003cShipmentListHeader shipment={data.shipment} /\u003e\n     \u003cShipmentListItem shipment={data.shipment} /\u003e\n   \u003c/Stack\u003e\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListItemFragment on Milestone {\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n  }\n`)\n\ntype Props = {\n shipmentListItems: FragmentType\u003ctypeof fragment\u003e\n}\n\nexport const ShipmentListItems = ({ shipmentListItems }: Props) =\u003e { \n   const fragmentData = useFragment(fragment, shipmentListItems)\n   \n  return (\n   \u003cStack\u003e\n     {fragmentData.map((milestone) =\u003e (\n       \u003cBox key={milestone.id}\u003e\n         \u003cText\u003e{milestone.milestoneType}\u003c/Text\u003e\n           \u003cText\u003e{milestone.status}\u003c/Text\u003e\n           \u003cText\u003e{milestone.completionDoneAt}\u003c/Text\u003e\n         \u003c/Box\u003e\n     )}\n   \u003c/Stack\u003e\n}\n```\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListHeaderFragment on Shipment {\n      team {\n       name\n      }\n  }\n`)\n\ntype Props = {\n shipmentHeader: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipmentHeader }: Props) =\u003e { \n   const fragmentData = useFragment(fragment, shipmentHeader)\n   \n  return (\n   \u003cStack\u003e\n     \u003cText\u003e{fragmentData.team.name}\u003c/Text\u003e\n   \u003c/Stack\u003e\n}\n```\n\n위 코드에서 다음과 같은 이점을 얻을 수 있습니다:\n\n- 명확한 데이터 종속성: 각 컴포넌트는 필요한 데이터를 명시적으로 정의하여 종속성이 명확해집니다. 자식 컴포넌트에서 GraphQL 서버에서 가져오는 값을 조사하는 것이 더 쉬워집니다.\n- 재사용성 향상: Fragment 사용은 코드 재사용을 촉진합니다. Fragment 유형도 생성되므로 타입 재사용이 가능합니다.\n- 유지보수성 향상: 쿼리에 대한 변경 사항이 지역화되어 유지보수가 쉬워집니다. 상위 컴포넌트의 쿼리를 수정할 필요가 없습니다.\n- 1 기능 컴포넌트에 1 루트 쿼리\n- 데이터 캡슐화: Fragment 마스킹을 사용하여 종속성이 없는 컴포넌트에서 의도하지 않은 필드 사용을 차단할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보충: Fragment Masking\n\nFragment Masking을 사용하면 Fragment 데이터의 속성을 상위 수준 구성 요소에서 숨기고 데이터 가시성을 제어할 수 있습니다. 다시 말해, 캡슐화를 강제합니다.\n\n![이미지](/assets/img/2024-06-20-FragmentColocationwithApolloClient_1.png)\n\n참고: [https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen](https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nFragment Colocation은 React와 GraphQL을 사용하는 현대 프론트엔드 개발에서 매우 유용한 패턴입니다. 데이터 종속성을 명확히하고 재사용성과 유지보수성을 향상시킴으로써, 개발자는 더 효율적으로 고품질의 코드를 작성할 수 있습니다. 여러분의 프로젝트에서 이 접근 방식을 채택해보고 직접 이점을 경험해보는 것도 좋을 것입니다.\n\n- - - - -\n만약 이 글이 여러분의 흥미를 자극했고, 이 지식을 활용하고 싶다면, 우리가 채용 중이니 확인해보세요!\n\n아래 링크를 확인해보세요.\n▼ 직업 기회\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**▼ 연락처**\nLinkedIn: [Shippio Inc.](https://www.linkedin.com/company/shippioinc/)\nShippio 인사팀 이메일 주소: shippiohr@shippio.io","ogImage":{"url":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png"},"coverImage":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png","tag":["Tech"],"readingTime":8},{"title":"앵귤러 최고의 권장사항","description":"","date":"2024-06-20 00:18","slug":"2024-06-20-AngularBestPractices","content":"\n\n![Angular Best Practices](/assets/img/2024-06-20-AngularBestPractices_0.png)\n\n안녕하세요, 개발자 여러분! Angular 개발에서 더 일관된 코딩 스타일을 찾고 계신가요? Angular 애플리케이션의 성능을 향상시키고 싶으신가요? 그렇다면 이 문서가 여러분을 위한 것입니다! 여기에서 Angular 개발자를 위한 스타일 가이드, 최고의 실천 방법 및 팁을 공유하겠습니다. 이를 통해 여러분의 Angular 프로젝트를 성능적이고 깔끔하게 유지할 수 있습니다.\n\n- 모듈화 아키텍처:\n확장성에 있어서 모듈화는 매우 중요합니다. 코드를 기능 모듈로 구성하고 각 모듈에 명확한 책임과 정의된 인터페이스를 부여하세요. 이는 코드 재사용, 관리 가능성 및 확장성을 촉진합니다.\n\n- 일관된 폴더 구조:\n표준화된 폴더 구조는 코드 조직화를 더 잘 할 수 있게 하며 팀원들 간의 원활한 협업을 촉진합니다. 파일을 논리적으로 분류하고 컴포넌트, 서비스, 모듈 및 기타 리소스에 특정 디렉토리를 할당함으로써, 개발자가 응용 프로그램의 아키텍처를 효율적으로 탐색할 수 있는 명확한 지도를 만듭니다. 이러한 조직화된 접근 방식은 관련 코드 세그먼트에 신속하게 액세스할 수 있게 하며 응용 프로그램 구조를 쉽게 이해할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsrc\n  |data-access\n    |auth\n       |facade\n          auth.facade.ts\n       |gateway\n          auth.gateway.ts\n  |feature\n     |auth\n        |login\n          login.component.ts\n          login.component.html\n          login.component.scss\n      auth.module.ts\n```\n\n3. 반응형 프로그래밍:\nRxJS 및 Angular Forms API와 같은 도구를 활용하여 데이터 및 이벤트 스트림을 효율적으로 처리하십시오. 이를 통해 코드의 간결성, 반응성 및 유지 관리성이 향상됩니다.\n\n```js\n// search.component.ts\nthis.search.valueChanges.pipe(\n debounceTime(300),\n distinctUntilChanged(),\n switchMap((query: string) =\u003e this.apiService.search(query))\n).subscribe((result: string[]) =\u003e {\n this.items = result;\n});\n```\n\n4. 지연 로딩:\n필요할 때에만 모듈을 지연로딩하여 성능을 향상시키십시오. 이는 초기 로드 시간을 줄이고 사용자 경험을 향상시킵니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\n// app-routing.module.ts\nconst routes: Routes = [\n { path: '', component: HomeComponent },\n { path: 'about', loadChildren: () =\u003e import('./about/about.module').then(m =\u003e m.AboutModule) }\n];\n```\n\n5. Ahead-of-Time Compilation (AOT):\n애헤드 오브 타임(AOT) 컴파일:\n빌드 프로세스 중에 AOT 컴파일을 활성화하여 애플리케이션 성능과 보안을 향상시킵니다.\n\n```bash\nng build --prod --aot\n```\n\n6. Change Detection Strategy OnPush:\n변경 감지 전략 OnPush:\n변경 감지는 Angular에서 근본적인 메커니즘으로, 애플리케이션 성능에 깊은 영향을 미칩니다. 이는 애플리케이션 데이터의 변화를 감지하고 이후에 뷰를 업데이트하는 것을 포함합니다. 기본적으로 Angular는 'Default' 변경 감지 전략을 사용하며, 이는 상당한 자원 소모를 요구할 수 있습니다. 그러나 'OnPush' 변경 감지 전략을 채택하여 성능을 최적화하는 것이 가능합니다. 'OnPush'를 사용하면 변경 사항이 컴포넌트의 입력 속성이 수정될 때나 이벤트가 트리거될 때에만 감지됩니다. 아래는 'OnPush' 전략의 구현을 보여줍니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-item',\n  template: `\n    \u003cdiv\u003e{ item.name }\u003c/div\u003e\n    \u003cdiv\u003e{ item.price | currency }\u003c/div\u003e\n    \u003cbutton (click)=\"addToCart()\"\u003eAdd to Cart\u003c/button\u003e\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ItemComponent {\n  @Input() item: Item;\n\n  constructor(private cartService: CartService) {}\n\n  addToCart() {\n    this.cartService.addItem(this.item);\n  }\n}\n```\n\n7. 반응형 폼:\nAngular 반응형 폼은 Angular 애플리케이션에서 동적이고 인터랙티브한 폼을 만들기 위한 견고한 매커니즘을 제공합니다. 템플릿 기반 폼과 달리 반응형 폼은 프로그래밍적으로 생성되어 폼 동작 및 유효성 검사에 대한 더 큰 유연성과 제어를 제공합니다. 반응형 폼을 사용하면 개발자들은 유지 보수성과 확장성을 보장하면서 쉽게 복잡한 폼을 생성할 수 있습니다.\n\n```js\n// contact.component.ts\nthis.contactForm = this.formBuilder.group({\n name: ['', Validators.required],\n email: ['', [Validators.required, Validators.email]],\n message: ['', Validators.required]\n});\n```\n\n8. 스마트 및 덤 컴포넌트:\n스마트 및 덤 컴포넌트 패턴을 채택하여 역할을 분리하세요. 스마트 컴포넌트는 애플리케이션 상태를 관리하고, 덤 컴포넌트는 표현에 집중합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// todo-list-container.component.ts\nexport class TodoListContainerComponent {\n todos$: Observable\u003cTodo[]\u003e;\n constructor(private todoService: TodoService) { … }\n}\n// todo-list.component.ts\nexport class TodoListComponent {\n @Input() todos: Todo[];\n}\n```\n\n9. Angular Material을 사용하여 UI 구성 요소:\nMaterial Design 가이드라인을 기반으로 사전 제작 및 사용자 정의 가능한 UI 구성 요소에 Angular Material을 사용하십시오. 이는 현대적이고 일관된 UI를 보장합니다.\n\n```js\nng add @angular/material\n```\n\n10. 단위 테스트 작성:\n컴포넌트, 서비스 및 응용 프로그램의 다른 부분에 대한 단위 테스트를 작성하여 코드 품질과 유지 관리를 보장하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// my.component.spec.ts\ndescribe('MyComponent', () =\u003e {\n  ...\n});\n```\n\n11. Angular CLI 사용법:\nAngular CLI를 활용하여 Angular 애플리케이션을 생성, 관리 및 빌드할 수 있습니다. 이를 통해 개발 작업을 간편화하고 최적의 관행을 준수할 수 있습니다.\n\n```js\nng generate component my-component\nng test\nng build\n```\n\n결론:\n이 11가지 모범 사례를 준수함으로써 확장 가능하고 유지보수가 용이하며 성능이 우수한 Angular 애플리케이션을 개발할 수 있습니다. 이러한 모범 사례에 더불어 Git과 같은 버전 관리 시스템을 사용해야 합니다. 계속해서 개발 관행을 검토하고 업데이트하여 발전하는 표준을 수용하고 애플리케이션 성능을 최적화해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 읽을 거리:\n\n피드백:\n만약 이 안내서가 도움이 되었다면, 공유해주시고 향후 개선을 위한 피드백을 제공해주십시오. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-AngularBestPractices_0.png"},"coverImage":"/assets/img/2024-06-20-AngularBestPractices_0.png","tag":["Tech"],"readingTime":5},{"title":"제스트 테스트 스위트가 왜 느릴까요","description":"","date":"2024-06-20 00:16","slug":"2024-06-20-WhyIsMyJestTestSuiteSoSlow","content":"\n\n우리 팀은 새 애플리케이션을 개발하고 있습니다. 현재 유닛 테스트 240개를 수행하는데 46초가 소요됩니다. 아직까지는 이 시간이 과도하지는 않지만 테스트의 개수에 비례해 증가하고 있습니다. 몇 달 뒤면 테스트 실행에 몇 분이 걸릴 것으로 예상됩니다.\n\n저희는 Jest가 빠른 성능으로 유명하다는 이유로 놀랐습니다. 그러나 Jest는 각 테스트가 40ms로 보고되었지만, 실제 각 테스트의 전체 실행 시간은 6초에 가깝다고 보고했습니다.\n\n우리의 레거시 응용 프로그램 중 하나에 대한 통합 테스트는 더 나쁘게 나타난다. 단일 테스트에 약 35초가 소요됩니다. 이 시간은 집중력을 잃기 시작하는 구간을 넘어서고, 테스트를 개발하는 데 집중하기 어렵습니다. 각 실제 테스트는 약 1초가 소요되는데, 추가 시간이 어디로 가는지 궁금합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 몇 주 동안 우리의 테스트 스위트가 왜 느린지 알아내기 위해 꽤 많은 시간을 삽질했었습니다. 불행히도 많은 아이디어들이 있었지만 거의 영향을 미치지 못했습니다. 게다가 우리의 테스트가 얼마나 빨라야 하는지에 대한 공감대조차 없는 것 같았습니다.\n\n이 조사 결과로 단위 테스트의 소요 시간이 46초에서 13초로 줄었습니다. 통합 테스트도 유사한 개선을 보였는데, 그들의 시간은 35초에서 15초로 감소했습니다. 더욱 중요한 것은 저는 별도의 글에서 다루는 파이프라인의 개선을 보았습니다.\n\n본 글에서는 가장 큰 차이를 만들어낸 개선 사항들을 공유하고, Jest의 성능을 저해하는 가능성 있는 잘못된 구성 및 남용에 대해 살펴보고자 합니다.\n\n다음 예시는 간단해 보여서 빠르게 실행될 것 같지만, 우리의 테스트를 지연시키는 의외로 매우 흔한 구성이 숨어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// TestComponent.tsx\nimport {Button} from \"@mui/material\";\n\nexport const TestComponent = () =\u003e {\n  return \u003cButton\u003eHello World!\u003c/Button\u003e;\n}\n\n// ComponentB.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport { TestComponent } from \"./TestComponent\";\n\ntest('TestComponent', () =\u003e {\n  render(\u003cTestComponent /\u003e);\n  expect(screen.getByText(\"Hello World!\")).toBeInTheDocument();\n});\n```\n\n그리고 테스트를 실행하면 다음과 같은 결과가 나옵니다:\n\n```js\nPASS src/components/testComponent/TestComponent.test.tsx\n√ TestComponent - 1 (34 ms)\n테스트 스위트: 통과 1, 총 1\n테스트: 통과 1, 총 1\n시간: 3.497 s\n```\n\n성능을 향상시키기 전에 Jest가 시간을 어디에 쓰고 있는지 이해해야 합니다. 테스트를 실행하는 데 34ms가 소요되는 것은 합리적이지만, 나머지 3.463초가 어디로 가는지 명확하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJest가 하는 일을 이해하지 않으면 잘못된 것을 최적화하려는 데 시간을 낭비할 수 있습니다. 예를 들어, TypeScript 컴파일 시간을 개선하기 위해 ts-jest나 babel-jest를 빠른 컴파일러로 교체하는 것이 일반적인 제안입니다.\n\n그러나 Jest는 캐싱을 많이 활용하므로 첫 번째 실행 후에는 TypeScript 컴파일의 영향이 미미합니다.\n\n## 1. Jest 시작 시간\n\n테스트 실행을 시작할 때 Jest는 자체를 로드하고 테스트 환경(jest-environment-jsdom과 같은)을 로드해야 합니다. Jest는 파일 간 종속성 맵을 빌드하고 테스트 순서에 대한 일부 결정을 내리며 플러그인을 로드하고 추가 스레드를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모든 작업은 대략 1초 정도 소요되지만, Jest에 완전히 달려있고 우리 애플리케이션과 크게 독립적이기 때문에 우리가 할 수 있는 것은 별로 없습니다. 또한, 이 설정은 쓰레드 당 한 번 발생하기 때문에 테스트와 테스트 파일 수가 증가함에 따라 확장되지 않습니다.\n\nJest가 시작될 때 무슨 작업을 하는지 궁금한 사람을 위해 해당 주제에 대한 자세한 비디오가 있습니다.\n\n## 2. 캐시 채우기\n\n애플리케이션에서 테스트를 처음 실행할 때, Jest는 캐시된 데이터를 활용할 수 없기 때문에 처음 실행할 때는 조금 더 오랜 시간이 걸릴 수 있습니다. Jest는 처음 실행할 때 대부분 시간을 TypeScript를 변환하는 데 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음 실행 후 TypeScript 파일을 다시 변환해야 하는 파일이 소수 있을 수 있지만, 그 외에는 Jest는 주로 캐시된 값만 사용합니다. 캐시되지 않은 시나리오는 드물며 성능 최적화에 중요한 영향을 미치지 않습니다.\n\n## 3. 테스트 파일 로드하기\n\nJest가 테스트 파일을 실행하기 전에 테스트 파일과 setupTests.ts에서 참조하는 모든 종속 항목을 로드하거나 모의(mock)해야 합니다. 이 단계는 테스트 실행 시간에 상당한 부하를 추가할 수 있으며, 테스트 성능을 크게 향상시킬 수 있는 부분입니다.\n\n## 4. 실제 테스트 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트가 단 34밀리초만에 완료되었고, 여기서 더 최적화할 부분은 거의 없습니다.\n\n다행히도, 위 작업 각각에 테스트하는 데 Jest가 얼마나 시간을 소요하는지 추측할 필요가 없습니다. Chrome의 DevTools를 사용하여 테스트 실행을 프로파일링할 수 있으며, 각 실행이 무엇을 하는지 확인할 수 있습니다.\n\n먼저, 브라우저에서 chrome:inspect로 이동한 다음 \"Node를 위한 전용 DevTools 열기\"를 클릭하여 DevTools를 엽니다.\n\n그런 다음, 터미널에서 다음 명령을 실행하세요: node --inspect-brk ./node_modules/jest/bin/jest.js src/components/testComponent/TestComponent.test.tsx --runInBand. Chrome에서 DevTools의 기본 중단점에 도달하면, 프로파일링 탭으로 이동하고 녹화를 시작하세요. 테스트가 완료되면, 프로파일러를 중지하고 녹화를 보고 \"차트\" 보기를 선택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_1](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_1.png)\n\n이 차트를 해석할 때 몇 가지 주의할 점이 있습니다:\n- 프로파일러의 존재로 인해 테스트의 성능이 약 30% 감소할 수 있습니다. 그러나 여전히 시간이 어디에 소비되는지를 비례적으로 잘 알 수 있습니다.\n- 의존성에 처음 접속하는 첫 번째 파일은 항상 가장 나쁜 성능을 보일 것입니다. 왜냐하면 Jest가 해당 의존성을 캐시하기 때문에 같은 스레드에서 같은 실행 동안 다른 테스트에 대해서도 사용합니다. (다른 실행 간에는 캐시되지 않음). 만약 TestComponent를 포함한 두 번째 테스트 파일을 포함한다면 해당 의존성을 로드하는 시간이 절반 정도 소요됩니다. 그러나 여전히 줄일 수 있는 시간이며, 물론 개발 중에 한 번에 하나의 파일만 실행하는 흔한 시나리오에서 첫 실행 성능이 매우 중요합니다.\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_2](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Barrel 파일\n\n지금 검사 자가 연결되어 있기 때문에, 우리는 문제를 즉시 볼 수 있습니다 — 테스트 파일을 로드하는 대부분의 시간이 @mui/material 라이브러리를 로드하는 데 걸립니다. 우리가 필요로 하는 버튼 구성 요소만 로드하는 대신에 Jest는 전체 라이브러리를 처리하고 있습니다.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_3.png)\n\n왜 이게 문제인지 이해하려면 Barrel 파일에 대해 좀 더 알아야 합니다. Barrel 파일은 여러 내보내기를 한 파일에 모아둔 접근 방식으로, 보통 index.ts라고 불립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴포넌트의 외부 인터페이스를 제어하고 모듈의 내부 구조와 구현에 대해 걱정할 필요 없도록 barrel 파일을 사용합니다. 대부분의 라이브러리는 일반적으로 내보내는 모든 것을 포함한 루트 디렉토리에 있는 barrel 파일을 가지고 있습니다.\n\n```js\n// @mui-material/index.ts\nexport * from './Accordion';\nexport * from './Alert';\nexport * from './AppBar';\n...\n```\n\n문제는 Jest가 우리가 가져오는 컴포넌트가 어디에 위치해 있는지 모르는 것입니다. barrel 파일은 그 사실을 의도적으로 숨겼습니다. 그래서 Jest가 barrel 파일에 도달하면 그 안에 참조된 모든 내보내기를 로드해야 합니다. 이 동작은 주로 @mui/material과 같은 대규모 라이브러리에 대해 신속하게 처리할 수 없습니다.\n\n우리는 단순히 하나의 버튼을 찾으려고 하는데 수백 개의 추가적인 파일을 로드하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도, Jest가 Button 컴포넌트를 정확히 어디에서 찾아야 하는지 알 수 있도록 임포트 구조를 업데이트하여이 문제를 쉽게 해결할 수 있습니다.\n\n```js\n// 이전\nimport { Button } from '@mui/material';\n// 이후\nimport Button from '@mui/material/Button';\n```\n\n![Jest 테스트 스위트가 왜 느린가요?](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_4.png)\n\neslint를 사용하여 미래에 더 이상 이러한 임포트가 추가되는 것을 막기 위해 구성 파일에 다음 규칙을 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nrules: {\n    \"no-restricted-imports\": [\n        \"error\",\n        {\n            \"name\": \"@mui/material\",\n            \"message\": \"대신 \\\"import foo from '@mui/material/foo'\\\"를 사용해주세요.\"\n        }\n    ]\n}\n```\n\n여기서는 주로 @mui/material을 타겟으로 잡았어요. 인기 있는 대형 라이브러리라서요. 그래도, 최적화되지 않은 방식으로 import하는 라이브러리가 많았어요.\n\n@mui/material-icons, lodash-es, 그리고 @mui-x-date-picker로부터 import를 수정해야 했고, 그 외에도 내부 라이브러리에서 import를 고쳐야 했어요. 이런 모든 import를 업데이트하는 데 걸리는 시간이 테스트 수행 시간의 약 50%를 절약할 수 있었어요.\n\n## setupTests.ts 확인하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\njest.config.js 파일에서 setupFilesAfterEnv에 대해 설정된 파일로 가는 유혹이 있습니다. 이 파일은 모든 테스트 파일에 원하지 않는 일회성 및 특이 케이스가 모두 이어지는 경향이 있습니다.\n\n이 파일이 모든 테스트보다 한 번 실행된다는 오해에서 비롯된 것으로 의심됩니다. 그러나 Jest가 각 테스트 파일을 제대로 격리할 수 있도록 이 파일의 내용은 실제로 각 테스트 파일 앞에서 실행됩니다.\n\nsetupTests.ts 파일의 영향을 확인하면 이전 단계에서의 flame 차트를 볼 수 있습니다. setupTests.ts에서 비싼 동작을 발견할 수 있으며, 해당 동작은 관련 테스트 파일로 다시 이동할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트 실행에서 타입 체크 제거하기\n\n만약 우리가 테스트용으로 TypeScript를 컴파일하는 데 ts-jest를 사용하고 있다면, 해당 도구의 기본 동작은 테스트 실행이 TypeScript 컴파일러의 타입 체크도 함께 실행하는 것입니다.\n\n이 동작은 TypeScript 컴파일러가 이미 빌드 과정 중에 그 역할을 수행하고 있기 때문에 중복됩니다. 이 추가적인 체크를 포함시키면 테스트 실행에 훨씬 더 많은 시간이 소요되는데, 특히 Jest가 별도로 TypeScript 컴파일러를 켜야 할 필요가 없는 경우입니다.\n\n이 동작을 비활성화하려면 jest.config.js 파일에서 다음 속성을 설정할 수 있습니다. isolatedModules 속성에 대한 자세한 설명은 ts-jest 문서에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodule.exports = {\n    transform: {\n      \"^.+\\\\.(ts|tsx|js|jsx)$\": [\n          'ts-jest', {\n              tsconfig: 'tsconfig.json',\n              isolatedModules: false\n          },\n      ]\n    },\n};\n```\n\n`isolatedModules` 설정에 대한 제 경험은 다양했어요. 이 설정을 업데이트하면 일부 레거시 애플리케이션에서 성능이 두 배로 향상되었지만, 작은 create-react-app 애플리케이션에서는 차이가 없었어요. 다시 한 번, 플레임 차트를 통해 이 추가 작업이 어떤 영향을 미치는지 확인할 수 있어요.\n\n![WhyIsMyJestTestSuiteSoSlow_6](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_6.png)\n\n## misconfigurations을 점검하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능 향상은 코드베이스를 개선하는 것만으로 이루어질 필요가 없어요. 책임 일부는 개발자들이 도구를 어떻게 활용하느냐에 달려 있답니다. package.json의 스크립트는 타이핑을 절약하고 복잡성을 숨기며, 프로젝트의 모든 사람들에게 최상의 CLI 구성을 공유하는 데 도움이 될 수 있어요.\n\n하지만 이들에는 심각한 단점이 따라와요. 시간이 지남에 따라 팀원들이 공통 도구의 CLI를 어떻게 사용해야 하는지를 잊고 기존 스크립트가 이미 최적의 구성인 것으로 무조건 믿는 문제가 생길 수 있어요. 제가 참여한 대부분의 프로젝트에서 package.json의 스크립트에는 중요한 설정 오류가 몇 개 있었고, 많은 시간이 낭비되었어요.\n\n사람들은 지속적 통합 파이프라인을 위해 원래 의도된 스크립트를 로컬 개발 환경에 맞는 스크립트로 혼동하기도 해요. 스크립트가 새로운 기능이나 도구의 변경에 대해 업데이트되지 않았을 수도 있고, 아니면 항상 잘못되었을 수도 있어요.\n\nJest의 경우 로컬 환경에서 실행하는 테스트에 피해야 할 몇 가지 플래그가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- --maxWorkers=2라는 옵션은 Jest가 두 개의 스레드에서만 실행되도록 제한합니다. CI 빌드 에이전트에서 유용하지만 개발용 강력한 머신에서는 Jest를 5개 이상 또는 6개 이상의 스레드로 실행할 수 있습니다.\n- --runInBand 옵션은 마찬가지로 Jest가 스레드를 전혀 사용하지 못하도록 합니다. Jest는 스레드가 필요없는 상황(예: 단일 테스트 파일 실행)을 스스로 인식할 수 있는 똑똑한 기능을 갖추고 있습니다.\n- --no-cache, --cache=false, --clearCache 옵션은 Jest가 실행 사이에 데이터를 캐싱하는 것을 방지합니다. Jest 문서에 따르면 캐시를 비활성화하면 Jest가 적어도 두 배 이상 느려질 수 있습니다.\n- --coverage 옵션은 대부분의 로컬 테스트 실행에서 코드 커버리지 보고서를 생성할 필요가 없습니다. 필요하지 않은 경우 이 단계를 건너뜁시켜 몇 초를 절약할 수 있습니다.\n\nJest에는 많은 설정이 있지만 대부분의 경우 기본 설정이 잘 작동할 것입니다. package.json 파일의 스크립트에 추가 플래그의 목적을 이해하는 것이 중요합니다.\n\n## 기본값은 watch 모드 사용\n\n로컬에서 애플리케이션을 실행할 때는 대부분 watch 모드를 사용하는 것으로 익숙하지만 테스트를 실행할 때는 그렇지 않을 수 있습니다. 빌드와 마찬가지로 테스트를 watch 모드에서 실행하면 다시 계산할 필요가 없는 많은 데이터를 우리의 도구에 저장할 수 있어 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJest의 대부분의 지연은 테스트 실행보다는 시작 시간에 있습니다. watch 모드를 사용하면 이를 건너뛸 수 있습니다.\n\n![2024-06-20-WhyIsMyJestTestSuiteSoSlow_7.png](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_7.png)\n\n저는 개발자들이 IDE의 인터페이스 때문에 watch 모드의 장점을 충분히 활용하지 못하는 경우가 많다고 생각합니다.\n\n테스트 파일을 작업할 때, 각 테스트 케이스 옆의 작은 녹색 \"테스트 실행\" 화살표를 클릭하여 테스트 실행을 시작하는 데 익숙합니다. 이들은 모든 테스트 실행하거나 일부 테스트를 실행하는 구문을 기억하려고 하는 것보다 편리하고 빠릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 나아가서, 그들은 테스트 결과를 우리 IDE의 테스트 결과 패널 안에 표시해줍니다. 이는 콘솔에 덤핑된 로그보다 더 유용합니다.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_8.png)\n\nWebStorm을 사용하면 \"테스트 실행\" 바로 가기에 사용되는 실행 구성을 업데이트할 수 있어, 이를 사용하여 워치 모드에서 테스트를 실행할 수 있습니다. Jest의 실행 템플릿도 업데이트하여 기본적으로 \"테스트 실행\" 바로 가기를 모두 워치 모드로 사용할 수 있습니다.\n\n## 우리는 모든 테스트를 실행할 필요가 없습니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발자들이 특정 테스트 파일에서 작업 중이 아닐 경우 대부분 모든 테스트를 실행하는 경향이 있다는 점을 알아챘어요. 이 행동은 보통 Jest가 변경된 파일을 기반으로 실행해야 할 테스트 하위 집합을 구별할 수 있기 때문에 중복될 수 있어요.\n\n테스트 스위트가 점점 커지면 전체 스위트를 실행하는 것은 시간이 낭비일 수 있어요. 하지만 이 기사의 조언이 정상적으로 통제를 도와줄 것을 희망합니다.\n\njest를 직접 호출하는 대신 jest --onlyChanged 또는 jest --changedSince을 사용하는 것이 좋아요. 100% 신뢰할 수 없지만, master 브랜치에 직접 커밋하지 않는 한 Jest가 테스트를 놓치는 예외적인 상황을 잡아내는 Continuous Integration 파이프라인이 있을 거에요.\n\n![이미지](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트 스위트는 거의 정적이지 않습니다; 애플리케이션과 함께 점점 커집니다. 느린 테스트 스위트는 더 느려질 것입니다. 다행히도, 소량의 작업으로 각 테스트의 소요 시간을 절반 이상 줄일 수 있습니다. 이 작업은 지금 시간을 절약할 뿐만 아니라 테스트 스위트의 소요 시간과 품질 전반의 궤적을 바꿉니다.\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 빌드하기\n\n![이미지 설명](/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_10.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소로 앱을 빌드할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 만들어 여러 응용 프로그램 간에 공유하세요. 협업이 더 쉬워지고 빠르게 구축할 수 있어요.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 응용 프로그램 개발을 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 리포\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_0.png"},"coverImage":"/assets/img/2024-06-20-WhyIsMyJestTestSuiteSoSlow_0.png","tag":["Tech"],"readingTime":11},{"title":"주피터 랩 IDE 기본기 TypeScript와 Deno","description":"","date":"2024-06-20 00:13","slug":"2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno","content":"\n\n## TypeScript 개발자를 위한 단계별 가이드\n\n![Image](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png)\n\n이 시리즈의 시작 부분에서는 최근 변경 사항을 요약하여 Typescript로 AI 앱을 쉽게 프로토타입 및 개발할 수 있는 내용을 소개했습니다.\n\n첫 번째 부분을 아직 읽지 않으셨나요? 이 프로젝트가 무엇인지 확인해보세요. 다가오는 몇 달, 아마도 몇 년 동안 새 AI 모델과 도구를 실험해가며 그 과정에서 배우는 모든 것을 여러분에게 보여줄 것입니다. 대중을 상대로 “공개로 빌드”하며 여정의 중요한 이정표를 여러분에게 보여줄 것입니다. 결과적으로 여러분은 이 지식을 실무에 적용할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 글에서는 Jupyter Lab IDE를 설치하는 방법과 빠른 프로토타이핑 환경을 위한 모든 필수 도구를 설명했습니다:\n\n- Jupyter Lab 웹 기반 대화형 개발 환경\n- Jupyter 노트북에서 Typescript로 Jupyter 노트북을 생성할 수 있게 해주는 Deno Typescript/Javascript 커널\n- LLMs를 로컬에서 실행할 수 있는 Ollama\n- 언어 모델을 활용하여 애플리케이션을 개발하는 프레임워크인 Langchain\n\n두 번째 글의 단계를 따라오셨다면, 이제 Typescript 지원을 갖춘 작동 중인 Jupyter Lab 환경과 로컬 LLMs 실행을 위한 Ollama 설치가 완료되었습니다.\n\n이 글에서는 Jupyter Lab의 사용 방법을 설명하고, 기본적인 코딩 워크플로우를 소개하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 예제가 포함된 샘플 노트북을 다운로드할 수 있어요.\n\n# 주피터 랩 기초\n\n주피터 랩은 주피터 노트북, 코드 및 데이터 작업을 위한 통합 개발 환경(IDE)입니다. 주피터 노트북에는 코드, 출력물, 시각화 및 설명 텍스트가 포함되어 있어요.\n\n주피터 랩의 사용자 인터페이스는 VSCode 또는 JetBrains IDE와 유사해요. \"파일 브라우저\"와 파일이 열린 주 작업 영역으로 구성되어 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![JupyterLab IDE Basics](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_1.png)\n\n“File browser”에서 원본 파일을 열고 편집할 수 있습니다. “File browser”의 루트 디렉터리는 Jupyter Lab을 시작한 디렉터리입니다.\n\n“File browser” 위에 있는 플러스 아이콘 버튼은 “Launcher”입니다. 새 노트북, 텍스트 파일, 터미널, 콘솔 및 기타 도구를 생성할 수 있는 바로 가기를 제공합니다:\n\n![Launcher](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왼쪽 사이드바에는 다음과 같은 도구들이 있습니다:\n\n- 파일 브라우저: 파일을 탐색하고 관리합니다\n- 실행 중인 터미널 및 커널: 현재 실행 중인 터미널과 커널 목록\n- 확장 관리자: Jupyter Lab 기능을 향상시키는 확장 관리\n- 명령 팔레트: 명령에 빠르게 액세스하고 Ctrl+Shift+C로 열기\n\n\"명령 팔레트\"에서는 모든 Jupyter Lab 명령과 단축키를 볼 수 있습니다:\n\n![Command Palette](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주피터 랩에서의 코딩 워크플로우\n\n## 새 노트북 만들기\n\n왼쪽 사이드바에 있는 + 아이콘을 클릭하여 \"런처\"를 엽니다. \"Notebook\" 아래에서 TypeScript(또는 JavaScript)용 새 노트북을 만들기 위해 \"Deno\"를 선택합니다. Ctrl+S로 노트북을 저장합니다. \"파일 브라우저\"에서 파일을 우클릭하여 \"이름 바꾸기\"를 선택하여 파일 이름을 변경합니다(F2를 눌러도 됨).\n\n## 코드 작성 및 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 노트북에서는 코드 셀 내에서 TypeScript 코드를 작성하고 실행할 수 있어요. 각 코드 셀을 사용하여 코드 스니펫을 입력하고 실행할 수 있어요. 예를 들어, 메시지를 표시하려면 다음과 같이 작성하세요:\n\n```js\nconsole.log('Hello Deno!')\n```\n\nShift+Enter를 눌러 코드를 실행하세요. 결과는 셀 아래에 바로 나타날 거예요:\n\n![이미지](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 커널\n\n커널은 주피터 노트북에서 코드를 실행합니다. 각 노트북은 자체 커널을 가지며, 변수, 가져오기 및 셀 실행 사이의 다른 런타임 정보를 유지합니다.\n\n# 커널 재시작\n\n노트북의 커널 메모리는 이전 실행에서 온 변수들로 어지럴 수 있습니다. 커널을 다시 시작하면 이 메모리가 지워지며 깨끗한 상태를 제공합니다. 또한 업데이트된 모듈도 다시 불러옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Kernel\" 메뉴에서 커널을 재시작할 수 있어요.\n\n# 마크다운 셀\n\n마크다운 셀은 노트북에 텍스트와 문서를 추가하여 정보 전달을 도와줘요. 마크다운 셀을 추가하려면 툴바의 + 버튼을 클릭하여 새 셀을 삽입한 후, 드롭다운 메뉴를 사용하거나 Esc + M을 눌러 셀 유형을 \"Markdown\"으로 변경하세요. 제목과 형식화된 텍스트를 만들려면 다음과 같이 작성하세요:\n\n```js\n### 출력\n\nJavaScript의 표준 출력 함수인 `console.log`을 사용하여 출력 셀에 쓸 수 있어요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운으로 표를 변환하려면, Shift+Enter를 누르세요.\n\n![image](/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_5.png)\n\n# Deno에서 패키지 가져오기\n\nDeno에서는 패키지를 가져오는 데 URL 기반 구문을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { escape } from \"https://deno.land/std/html/mod.ts\";\n```\n\nDeno에는 https://deno.land/std에서 사용 가능한 표준 라이브러리가 있습니다. 위 줄은 std 라이브러리에서 escape() 함수를 가져옵니다. 버전을 지정하려면 다음을 사용하세요:\n\n```js\nimport { escape } from \"https://deno.land/std@0.224.0/html/mod.ts\";\n```\n\n또한 Deno에는 서드 파티 모듈을 위한 저장소가 https://deno.land/x에 있습니다. html() 함수를 가져오려면 다음을 사용하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { html } from \"https://deno.land/x/display/mod.ts\";\n```\n\nDeno는 npm 모듈을 npm: 접두사를 사용하여 가져올 수 있습니다. 예를 들어 zod를 가져오기 위해서는 다음과 같이 합니다:\n\n```js\nimport { z } from \"npm:zod\";\n```\n\n# 결과 셀에 입력하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 코드 셀에서 출력할 수 있는 방법입니다:\n\n- console.* 함수 사용\n- html 함수 사용 (HTML 출력)\n- md 함수 사용 (Markdown 출력)\n\n예시:\n\n\u003cimg src=\"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 환경 변수\n\nDeno 또는 Node에서는 설정을 위해 환경 변수를 사용합니다. 예를 들어, Langchain의 OpenAI 래퍼는 OPENAI_API_KEY에서 키를 가져옵니다. .env 파일에 설정하세요:\n\n```js\nOPENAI_API_KEY=[여기에 키를 입력하세요]\n```\n\n다음 명령으로 이 파일을 불러옵니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport \"https://deno.land/std@0.215.0/dotenv/load.ts\";\n```\n\n아래 코드를 사용하여 값을 표시해보세요:\n\n```js\nconsole.log(Deno.env.get(\"OPENAI_API_KEY\"));\n```\n\n# 로컬 파일 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDeno는 로컬 파일 임포트를 지원합니다. 외부 파일을 변경한 후에는 커널을 다시 시작하여 다시로드하세요:\n\n```js\nimport { f1 } from './1.ts';\n\nf1();\n```\n\nDeno는 JSON 파일을 불러오는 것도 지원합니다:\n\n```js\nimport jsonData from \"./data.json\" with { type: \"json\" };\nconsole.log(jsonData);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n이 작은 튜토리얼을 완료한 것을 축하드립니다! 우리는 주피터 랩의 기본을 다뤘으니, 앞으로는 AI 관련 주제에 중점을 둘 수 있을 것입니다. 다음 글에서는 \"텍스트 리뷰어 앱\" 프로토타입을 어떻게 만들었는지 설명할 것입니다. 흥미로운 내용이니까 구독 부탁드립니다!\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이며, 많은 해간 데이터 과학자이자 풀스택 개발자로 일해왔습니다. 최근에는 Angular 기반 프론트엔드 개발에 중점을 둔 프론트엔드 기술 리드로 일하고 있습니다. 제 역할의 일환으로 Angular와 프론트엔드 개발 환경이 어떻게 발전하고 있는지 꾸준히 주시하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 몇 년 동안 Angular는 매우 빠르게 발전해 왔습니다. 특히 작년에는 생성 모델 AI의 등장과 함께 소프트웨어 개발 워크플로가 급속히 발전했습니다. AI 지원 소프트웨어 개발의 발전을 밀접히 따라가기 위해, 나는 공개적으로 AI 도구를 만들기로 결심했고 진행 상황은 AIBoosted.dev 에 게시할 것입니다. 구독하시려면 여기를 눌러주세요 🚀\n\nAngular에 대해 더 알고 AI, Typescript, React, 그리고 Angular로 AI 앱을 만드는 방법을 배우고 싶다면 Substack (Angular Addicts), Substack (AIBoosted.dev), Medium, Dev.to, X, 또는 LinkedIn에서 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png"},"coverImage":"/assets/img/2024-06-20-JupyterLabIDEbasicswithTypescriptandDeno_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러에서의 데이터 가져오기 패턴","description":"","date":"2024-06-20 00:10","slug":"2024-06-20-DatafetchingpatternsinAngular","content":"\n\n쥬타오 취(邱俊涛)는 최근 마틴 파울러의 웹사이트에 싱글 페이지 애플리케이션에서의 데이터 패칭 패턴에 관한 기사를 게시했어요. 꼭 읽어보길 추천하는데, 모든 예시는 React나 순수 JavaScript를 사용해요. 이어서 나오는 내용에서는 모든 설명된 패턴들을 Angular 애플리케이션에 적용하는 방법을 볼 거에요. Angular와 React 간의 알려진 차이 때문에 결과가 많이 다르게 나타나요.\n\n# 라이브러리와 프레임워크\n\nReact는 라이브러리로서 자신을 소개하지만, Angular는 웹 프레임워크로 간주될 수 있어요. 싱글 페이지 애플리케이션을 구축하는 데 필요한 모든 것을 포함하고 있으며 라우팅 및 데이터 패칭을 위한 도구가 함께 제공돼요. Angular는 이러한 도구들을 사용하도록 강요하지 않지만, 물론 사용할 수 있어야 해요. 이 모든 것에는 장단점이 있지만, 이는 또 다른 이야기에요. 결국, 두 접근 방식은 높은 품질의 코드를 생성하고 실행 가능한 웹 애플리케이션을 만들 수 있게 도와줘요.\n\n# 조금 다른 프로필 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 설명된 소스 코드는 Angular 애플리케이션에 내장되어 있으며 Codeberg에서 사용할 수 있습니다.\n\nJuntao Qiu는 프로필 구성 요소를 구현하는데, 사용자의 ID를 매개변수로 받습니다. 초기 렌더링 후에 그리고 이 ID가 변경될 때마다, 구성 요소는 해당 사용자의 프로필 데이터를 서버에서 가져옵니다. 그런 다음, 받은 정보를 UserBrief라는 다른 구성 요소를 사용하여 표시합니다. 나중에, 이 구성 요소는 Friends 구성 요소를 사용하여 사용자의 친구 목록을 표시합니다.\n\n서버가 없기 때문에, 여기서 설명된 구현은 사용자, 그들의 게시물 및 사진 앨범을 모델로 만듭니다. 이 모든 것은 공개적으로 사용 가능한 JSONPlaceholder API의 일부입니다.\n\nAngular의 HTTP 클라이언트의 주요 차이점 중 하나는 다른 구현과 비교했을 때 각 메서드가 RxJS Observable을 반환한다는 것입니다. RxJS는 반응형 프로그래밍을 위한 라이브러리로, Node.js와 TypeScript와 함께 Angular의 주요 종속성입니다. 이렇게 함으로써, Angular은 네트워크 요청을 만들 때 반응형 프로그래밍을 권장하지만 강제하지는 않는다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 다른 HTTP 클라이언트를 사용할 수도 있습니다. 또는 Observables를 Promises로 변환하고 Juntao Qiu의 구현을 약간 수정할 수도 있습니다. 그러나 두 경우 모두 몇 가지 이점을 잃게 될 것입니다. 예를 들어 Angular의 HTTP 클라이언트를 사용하면 쉽게 인터셉터를 사용할 수 있습니다. 또한 Observables은 취소할 수 있어서 소홀히 여길 수 없는 장점입니다. 애플리케이션의 다른 페이지로 빠르게 이동하는 사용자를 상상해보세요. Promises는 트리거하는 구성 요소가 이미 파괴되었더라도 네트워크 요청을 계속하므로 무언가를 반환할 때까지 지속됩니다.\n\n여기서 설명된 Angular의 데이터 가져오기 패턴 구현은 Angular의 내장 기능을 사용하여 반응형 프로그래밍 접근 방식을 따릅니다.¹\n\n# 비동기 상태 핸들러\n\n이 패턴의 일반적인 아이디어를 이해하려면 Juntao Qiu의 비동기 상태 핸들러 섹션을 읽어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 상태 핸들러의 아이디어는 비동기 작업을 명시적인 로딩 및 오류 상태와 결합하는 것입니다. 비동기 작업이 진행 중인 경우 상태는 로딩입니다. 작업은 오류 상태로 또는 작업의 실제 결과와 함께 끝납니다. 일반적인 작업 결과 T를考える 때, 비동기 상태 핸들러는 T 또는 `로딩` 또는 `오류`를 반환하는 함수입니다. 유니언 타입을 사용하면 결과가 항상 정확히 하나의 상태임을 강조합니다. 로딩 및 오류 상태를 나타내는 문자열 리터럴 타입을 사용하면 간단하지만 설명적입니다. 필요한 경우 다른 타입으로 대체할 수도 있습니다.\n\n패턴의 선택적 확장은 재시도 기능입니다. 따라서 비동기 상태 핸들러는 비동기 작업을 다시 반복적으로 실행할 수 있는 기능을 제공해야 합니다.\n\n## Angular에서 비동기 상태 핸들러 구현하기\n\n우리는 커스텀 RxJS 오퍼레이터로 Angular에서 비동기 상태 핸들러를 구현할 수 있습니다. 간단한 용어로, 오퍼레이터는 observable 형태의 임의의 비동기 작업을 입력 매개변수로 받습니다. 구독할 때 즉시 로딩 상태를 발행합니다. 비동기 작업이 완료되면 결과를 반환합니다. 무언가 잘못되면 오류 상태를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction toAsynchronousStateHandler\u003cT, R\u003e(\n  projection: (value: T) =\u003e Observable\u003cR\u003e,\n) {\n  return switchMap((value: T) =\u003e\n    projection(value).pipe(\n      startWith('loading' as const),\n      catchError(() =\u003e of('error' as const)),\n    ),\n  );\n}\n```\n\n프로필 컴포넌트에서는 사용자 ID를 포함하는 라우트가 변경될 때마다 해당 연산자를 사용합니다.\n\n```js\nprivate readonly httpClient = inject(HttpClient);\nprivate readonly activatedRoute = inject(ActivatedRoute);\n\nprotected readonly user$: Observable\u003cUserResponse | 'loading' | 'error'\u003e =\n  this.activatedRoute.params.pipe(\n    toAsynchronousStateHandler((params) =\u003e\n      this.httpClient.get\u003cUserResponse\u003e(\n        `https://jsonplaceholder.typicode.com/users/${params['id']}`,\n      ),\n    ),\n  );\n```\n\n컴포넌트의 마크업에서는 Asynchronous State Handler의 현재 유형을 결정하기 위해 협소화(narrowing)를 사용할 수 있습니다. 이는 순수 TypeScript와 거의 유사합니다. 사용자 Observable에 구독하여 초기 가져오기를 초기화하고, 구독 취소로도 중지할 수 있습니다. Angular의 비동기 파이프(async pipe) 덕분에 사용자 Observable을 수동으로 구독하고 취소할 필요가 없습니다. 컴포넌트가 렌더링된 후 자동으로 구독하며, 컴포넌트가 파괴될 때 HTTP 요청을 취소할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (user$ | async; as user) {\n  @if (user === \"loading\") {\n    Loading...\n  } @else if (user === \"error\") {\n    Error...\n  } @else {\n    \u003capp-user-brief [user]=\"user\" /\u003e\n  }\n}\n```\n\n현재 구현은 데이터를 다시 가져오는 가능성만 부족합니다. 반응형 프로그래밍에서는 물론 observable을 사용하여 이를 수행합니다. 기존 observable에 추가로 void 유형의 추가적이지만 선택적인 observable을 결합할 수 있습니다. 이 observable은 데이터를 포함하지 않고 작업을 트리거합니다.\n재사용 가능한 연산자에서 모든 것을 처리하기 위해 이제 함수를 반환합니다. 이렇게 하면 소스 observable에 액세스할 수 있고 트리거 observable과 결합할 수 있습니다. 이 트리거 observable은 언제든 무언가를 발행해서는 안되므로 시작 값으로 확장해야 합니다.\n결합된 observable 중 하나라도 무언가를 발행하면, 진행 중인 비동기 작업이 전부 취소되어 다시 시작되기 전에 취소됩니다.\n\n```js\nexport function toAsynchronousStateHandler\u003cT, R\u003e(\n  projection: (value: T) =\u003e Observable\u003cR\u003e,\n  reloadTrigger = new Observable\u003cvoid\u003e(),\n) {\n  return function (source: Observable\u003cT\u003e) {\n    return combineLatest([\n     source, \n     reloadTrigger.pipe(startWith(void 0))\n ]).pipe(\n      switchMap(([value, _]) =\u003e\n        projection(value).pipe(\n          startWith('loading' as const),\n          catchError(() =\u003e of('error' as const)),\n        ),\n      ),\n    );\n  };\n}\n```\n\n프로필 구성요소에서는 값을 발행할 수 있는 표준 Subject를 사용하고 있습니다. 이를 연산자에 전달하고 해당 Subject의 next() 함수를 사용하여 다시 가져오기를 트리거할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nprivate readonly refetchTrigger$$ = new Subject\u003cvoid\u003e();\n\nprotected readonly user$: Observable\u003cUserResponse | 'loading' | 'error'\u003e =\n  this.activatedRoute.params.pipe(\n    toAsynchronousStateHandler(\n      (params) =\u003e\n        this.httpClient.get\u003cUserResponse\u003e(\n          `https://jsonplaceholder.typicode.com/users/${params['id']}`,\n        ),\n      this.refetchTrigger$$.asObservable(),\n    ),\n  );\n\nprotected onRefetch() {\n  this.refetchTrigger$$.next();\n}\n```\n\n# 병렬 데이터 가져오기\n\n쥬닷오 치우의 병렬 데이터 가져오기 섹션을 읽어보시면 이 패턴의 일반적인 아이디어를 이해할 수 있습니다.\n\n이름 그대로, 병렬 데이터 가져오기 패턴은 데이터를 병렬로 가져오는 것을 다룹니다. 이를 통해 요청 폭포를 줄일 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Angular에서 병렬 데이터 가져오기 구현\n\nAngular 및 따라서 RxJS를 사용하면 여러 내장 Join Creation Operators를 사용할 수 있습니다. 이러한 연산자를 사용하면 여러 개의 observables로부터 발행된 값을 결합할 수 있습니다. Promise.all에 가장 가까운 것은 forkJoin 연산자입니다. 이 연산자는 배열 또는 observables 사전을 입력 매개변수로 사용하고 각각 배열 또는 값 사전을 발행합니다.\n\n비동기 상태 핸들러 연산자는 모든 observable에 대해 작동하기 때문에 프로필 컴포넌트를 간단한 사용자 정보뿐만 아니라 사용자의 게시물도 가져오도록 쉽게 확장할 수 있습니다.\n\n```js\nprotected readonly dataRequest$ = this.activatedRoute.params.pipe(\n  toAsynchronousStateHandler(\n    (params) =\u003e\n      forkJoin({\n        user: this.httpClient.get\u003cUserResponse\u003e(\n          `https://jsonplaceholder.typicode.com/users/${params['id']}`,\n        ),\n        posts: this.httpClient.get\u003cPostResponse[]\u003e(\n          `https://jsonplaceholder.typicode.com/users/${params['id']}/posts`,\n        ),\n      }),\n    this.refetchTrigger$$.asObservable(),\n  ),\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크업에서는 여전히 우리의 비동기 데이터 요청의 현재 유형(또는 상태)을 결정하기 위해 narrowing을 사용합니다. 로딩 중이거나 오류 상태가 아닌 경우에는 forkJoin 연산자에 전달한 구조에 안전하게 접근할 수 있습니다.\n\n```js\n@if (dataRequest$ | async; as dataRequest) {\n  @if (dataRequest === \"loading\") {\n    Loading...\n  } @else if (dataRequest === \"error\") {\n    Error...\n  } @else {\n    \u003capp-user-brief [user]=\"dataRequest.user\" /\u003e\n    \u003capp-posts [posts]=\"dataRequest.posts\" /\u003e\n  }\n}\n```\n\n# 대체 마크업\n\n이 패턴의 일반 아이디어를 이해하려면 전투 마크업에 대한 Juntao Qiu의 섹션을 읽어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFallback Markup 패턴의 아이디어는 로딩 또는 에러와 같은 비동기 작업의 다양한 상태를 처리하는 데 필요한 보일러플레이트 코드를 줄이는 데 있습니다.\n\n## Angular에서 Fallback Markup 구현\n\n프로필 컴포넌트의 마크업을 되짚어 봅시다. 우리는 비동기 작업의 상태를 모델링하기 위해 연합 유형을 사용하여 현실에 가깝게 표현했습니다(한 번에 하나의 상태). Angular의 제어 흐름과 유형 축소를 사용하여 비동기 작업의 현재 유형 또는 상태에 따라 조건부로 콘텐츠를 렌더링할 수 있습니다. 상태의 유형을 비호환적인 방법으로 변경하면 TypeScript 에러가 발생합니다.\n\n```js\n@if (dataRequest$ | async; as dataRequest) {\n  @if (dataRequest === \"loading\") {\n    Loading...\n  } @else if (dataRequest === \"error\") {\n    Error...\n  } @else {\n    \u003capp-user-brief [user]=\"dataRequest.user\" /\u003e\n    \u003capp-posts [posts]=\"dataRequest.posts\" /\u003e\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 React의 Suspense 컴포넌트와 유사한 방식을 적용할 수 있습니다. 그러나 타입을 좁게 하는 것을 잃을 가능성이 높습니다. 아니면 더 나쁜 경우에는 어떤 타입 안전성도 잃을 수 있습니다. Angular 템플릿을 다룰 때 이러한 일이 종종 발생합니다. 물론 로딩 및 오류 상태를 처리하는 전용 컴포넌트를 만들 수 있습니다. 또는 모든 네트워크 요청의 로딩 및 오류 상태를 처리하는 인터셉터를 사용할 수도 있습니다.\n\n그러나 Angular의 제어 흐름을 통해 이미 견고하고 가독성 좋은 내장 솔루션을 얻을 수 있습니다. 나머지는 각 어플리케이션 및 오류 처리 및 로딩 상태에 대한 일반적인 전략에 의존합니다. 예를 들어, 많은 표현 컴포넌트와 모든 비동기 작업을 처리하는 몇 개의 컨테이너 컴포넌트만 있는 접근 방식은 설계적으로 이 패턴에 대한 사용 사례를 줄일 수 있습니다.\n\n# 코드 분할\n\nJuntao Qiu의 코드 분할 섹션을 읽어 이 패턴의 일반 아이디어를 이해해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Angular에서 라우터를 사용하여 코드 분할 구현하기\n\nAngular의 내장 라우터를 사용하면 브라우저의 동적 `import` 표현식을 활용하여 모듈을 필요한 경우에만 Lazy로드할 수 있습니다. 여기서 모듈이란 Angular 모듈(NgModule), 독립적인 컴포넌트 또는 다른 라우터 구성을 의미합니다.\n\n프로필 컴포넌트를 제공하고 다른 라우트에서 사진 앨범을 표시하는 애플리케이션의 간략한 라우터 구성은 다음과 같이 보일 수 있습니다.\n\n```js\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  {\n    path: 'profile',\n    loadComponent: () =\u003e\n      import('./profile/profile.component').then(\n        (module) =\u003e module.ProfileComponent,\n      )\n  },\n  {\n    path: 'albums',\n    loadComponent: () =\u003e\n      import('./albums/albums.component').then(\n        (module) =\u003e module.AlbumsComponent,\n      )\n  }\n];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 표는 Markdown 형식으로 변경하였습니다.\n\n\n| Lazy chunk files  | Names            | Raw size  |\n| ----------------- | ----------------- | --------- |\n| chunk-OQXIE7JX.js | profile-component | 6.70 kB   | \n| chunk-FX2UNWRV.js | albums-component  | 4.96 kB   | \n| chunk-REKZS4LG.js | -                 | 500 bytes |\n\n\n기본적으로 Angular 라우터가 청크의 지연 로드를 수행할 때 특별한 표시가 없습니다. 사용자 경험을 향상시키기 위해 어플리케이션의 루트 수준에 일부 로딩 표시기를 표시하는 것이 유용할 수 있습니다. Angular 라우터는 지연 로드가 시작되거나 끝날 때 두 가지 특정 이벤트를 제공합니다.\n\n```typescript\nexport class AppComponent {\n  private readonly router = inject(Router);\n\n  protected readonly isRouterLazyLoading$ = this.router.events.pipe(\n    filter(\n      (event) =\u003e\n        event instanceof RouteConfigLoadStart ||\n        event instanceof RouteConfigLoadEnd,\n    ),\n    map((event) =\u003e {\n      if (event instanceof RouteConfigLoadStart) {\n        return true;\n      }\n      return false;\n    }),\n    startWith(false),\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Angular에서 Deferrable Views로 코드 분할 구현하기\n\nAngular의 최근에 도입된 Deferrable Views를 사용하면 컴포넌트 템플릿 내에서 컴포넌트를 지연로드할 수 있습니다. 이러한 Deferrable Views는 React의 Suspense 컴포넌트와 lazy 컴포넌트로드를 결합한 것과 유사하지만 추가 기능의 수에서 다릅니다.\n\n우리의 프로필 컴포넌트에서 사용자의 모든 게시물을 즉시 표시하고 싶지 않다고 가정해 보겠습니다. 대신에 사용자는 게시물을 표시하기 위해 전용 버튼을 클릭해야 합니다. 이를 위해 게시물을 표시하는 컴포넌트를 Deferrable View에 넣고 버튼을 플레이스홀더로 표시할 수 있습니다. Deferrable View에 상호작용 시로드하도록 지시하여 버튼을 클릭하면 실제 내용이 로드됩니다. 비동기 상태 핸들러와 유사하게 로딩 및 오류 상태를 위한 특별한 템플릿도 전달할 수 있습니다.\n\n```js\n@defer (on interaction) {\n  \u003capp-posts [posts]=\"dataRequest.posts\" /\u003e\n} @placeholder {\n  \u003cbutton\u003eShow Posts\u003c/button\u003e\n} @loading {\n  Loading posts...\n} @error {\n  Error...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 Angular가 하는 일은 Deferrable View의 내용을 별도의 청크로 분리하는 것입니다. 이 작업을 수행하려면 내용이 다른 곳에서 직접 참조되지 않아야 합니다. 빌드 결과에서 추가적인 청크를 확인할 수 있습니다.\n\n```js\n최적화 청크 파일    | 이름               |  원본 크기\nchunk-OQXIE7JX.js   | 프로필 컴포넌트    |   6.70 kB | \nchunk-FX2UNWRV.js   | 앨범 컴포넌트     |   4.96 kB | \nchunk-4UTUEDCN.js   | 게시물 컴포넌트  |   2.02 kB |\nchunk-REKZS4LG.js   | -                  | 500 bytes |\r\n```\n\n브라우저의 개발자 도구 네트워크 패널에서 버튼을 처음 클릭할 때 새로운 청크가 로드되는 것을 확인할 수 있습니다.\n\n## 이미지 최적화와 함께 Angular에서 코드 분할 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이미지를 청크로 간주하고 코드 분할이 \"필요할 때 로드되는 청크\"를 다루는 것이라면, 이미지도 다른 청크와 마찬가지로 처리하는 것이 좋을 수 있습니다. 뷰포트에 보이지 않는 이미지도 많이 담고 있는 수십 개의 이미지를 표시하는 컴포넌트를 상상해보세요. 브라우저에 따라 `img` 요소는 한 번에 모든 이미지를 로드하게 할 것입니다. 심지어 이미지 로딩이 시작되면 웹사이트를 닫아야만 취소할 수 있습니다. 사용자가 단일 페이지 애플리케이션 내에서 다른 경로로 이동할 때도 모든 이미지의 다운로드가 완료될 때까지 계속될 것입니다.\n\n샘플 애플리케이션의 앨범 컴포넌트는 사용자의 모든 사진 앨범을 표시할 것이며 각 사진의 썸네일을 모두 표시합니다.\n\n```js\n@for (album of albums; track album.id) {\n  @for (photo of album.photos; track photo.thumbnailUrl) {\n    \u003cimg [src]=\"photo.thumbnailUrl\" /\u003e\n  }\n}\n```\n\n이러한 단순한 방법론은 위에서 언급한 모든 문제점을 함께 가져올 수 있습니다. Angular에 통합된 이미지 최적화는 뷰포트와 가깝지 않은 이미지를 지연로드하는 크로스 브라우저 솔루션입니다. 이미지의 여러 가지 최적화 기법을 적용하는 것 외에도 플레이스홀더도 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@for (album of albums; track album.id) {\n  @for (photo of album.photos; track photo.thumbnailUrl; let index = $index) {\n    \u003cimg\n      [ngSrc]=\"photo.thumbnailUrl\"\n      width=\"150\"\n      height=\"150\"\n      [priority]=\"index \u003c 10 // 👈 처음 10개 이미지를 우선 순위로 지정\"\n      [placeholder]=\"placeholderImage\"\n    /\u003e\n  }\n}\n```\n\n브라우저의 개발자 도구 네트워크 패널에서 페이지를 스크롤할 때마다 어떻게 더 많은 이미지가 로드되는지 추적할 수 있습니다. 이것을 취소할 수 없는 방식으로 수백 개의 이미지가 로드되는 경향과 비교해보세요.\n\n# 사전로드\n\nJuntao Qiu의 사전로드 섹션을 읽어 이 패턴의 일반적인 아이디어를 이해해보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Angular에서 Deferrable Views로 선입(preload) 구현하기\n\nAngular의 Deferrable Views는 사용자 지정 조건이나 미리 정의된 트리거에 기초하여 지연된 뷰를 선입(preload)하는 기능을 지원합니다. 예를 들어, 브라우저가 유휴 상태일 때나 사용자가 플레이스홀더 위에 호버할 때 콘텐츠를 선입(preload)할 수 있습니다.\n\n```js\n@defer (on interaction; prefetch on hover) {\n  \u003capp-posts [posts]=\"dataRequest.posts\" /\u003e\n} @placeholder {\n  \u003cbutton\u003eShow Posts\u003c/button\u003e\n} @loading {\n  Loading posts...\n} @error {\n  Error...\n}\n```\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 도구를 선택하든, Juntao Qiu가 설명한 패턴들은 웹 애플리케이션을 개발할 때 항상 염두에 둬야 할 가치가 있습니다. Angular는 최근 도입된 기능들을 포함한 여러 내장 기능을 제공하며, 이 패턴들을 간단하고 표준화된 방식으로 적용하는 데 도움이 됩니다.\n\n2024년 6월 6일에 https://lukket.me에서 원본이 게시되었습니다.\n\n- 여기에 설명된 구현의 반응성은 읽기 전용 속성의 배타적 사용에 의해 지원됩니다.\n- 어떤 유형 안전성에 대해 이야기하고 있다는 것은 일부러 한 말장난입니다.\n- Angular 템플릿의 컨텍스트는 Angular 16 버전 이전에 미타입화된 객체였으며, 현재는 기본값으로 unknown이 지정된 일반적인 유형입니다. 마크업에서 일반 유형을 활용하는 방법에 대한 문서는 명확하지 않습니다.\n- Angular의 Deferrable Views는 플레이스홀더와 에러 케이스를 위한 전용 템플릿을 지원합니다. Deferrable View의 로드는 다양한 방법으로 트리거할 수 있으며, 사전로드도 내장 기능으로 제공됩니다. 그러나 Deferrable View는 컴포넌트의 패치 요청(XHR)을 가로채지 않지만 React의 Suspense 컴포넌트는 그렇습니다.\n- Firefox는 `img` 요소의 fetchPriority 속성을 아직 지원하지 않습니다.","ogImage":{"url":"/assets/img/2024-06-20-DatafetchingpatternsinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-DatafetchingpatternsinAngular_0.png","tag":["Tech"],"readingTime":13},{"title":"NestJS, TCP 및 Typescript로 Microservices 구축하기","description":"","date":"2024-06-20 00:09","slug":"2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript","content":"\n\n## 마이크로서비스가 서로 상호 작용하는 방법\n\n![이미지](/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_0.png)\n\n프로젝트가 점점 커지면서 더욱 고급 아키텍처가 필요해집니다. 그래서 소프트웨어 엔지니어로서, 현대적이고 인기 있는 마이크로서비스 아키텍처를 소개하고자 합니다. 이 아키텍처는 SOA (Service Oriented Architecture) 개념을 따릅니다.\n\n이 글에서는 단일체와 마이크로서비스 아키텍처의 차이를 이야기하고, NestJS, TCP 및 Typescript를 사용하여 이를 구축하는 방법을 보여드리려고 합니다. 먼저 마이크로서비스가 무엇인지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미크로서비스란 무엇인가\n\n미크로서비스는 소프트웨어 개발의 아키텍처적 관점으로, 소프트웨어가 작고 독립적인 서비스로 구성되어 서로 정의된 API를 통해 통신하는 방식입니다. 각 서비스는 특정 작업이나 비즈니스 목표를 지원하며 다른 모듈 및 서비스와 통신하기 위해 API를 사용합니다. 이를 통해 애플리케이션을 확장하고 더 빠르게 개발할 수 있어 혁신을 가능하게 하며 새로운 기능을 시장에 빠르게 내놓을 수 있게 됩니다.\n\n모놀리식 아키텍처와 미크로서비스 아키텍처의 주요 차이는 무엇인가요? 모놀리식 아키텍처에서는 모든 기능과 서비스가 결합돼 단일 단위로 작동합니다. 그러나 미크로서비스에서는 기반 로직을 서로 다른 작업이나 서비스로 분해하여 개별적으로 개발하고, 배포하며 API를 통해 노출하는 것이 특징입니다.\n\n더 나은 이해를 위해 저희는 함께 NestJS에서 미크로서비스 프로젝트를 개발할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 설정하기\n\n시작하기 전에, 저희 프로젝트의 두 가지 주요 측면을 강조하고 싶습니다:\n\n- auth-microservice: 사용자 권한을 관리하는 인증 서비스\n- API Gateway: 클라이언트와 마이크로서비스 사이에 위치하며 HTTP API 엔드포인트로부터 이벤트를 발생시키는 서비스\n\n간략히 설명하면, 사용자가 자격 증명으로 /api/login 엔드포인트를 통해 로그인하면 API 게이트웨이에 연결됩니다. API 게이트웨이는 그런 다음 요청-응답 스타일의 메시지 패턴을 사용하여 인증 마이크로서비스와 메시지를 주고받습니다. 이러한 방식으로 저희 앱이 작동할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 서비스를 구축할 예정이므로 여러 앱과 라이브러리가 포함된 단일 버전 관리 코드 저장소인 모노레포 프로젝트를 가지는 것이 좋습니다. 따라서 모노-저장소에서 웹 앱 및 서비스를 빌드하고 확장할 수 있는 Nx 도구를 사용할 것입니다.\n\n우선 다음 명령어로 모노레포 프로젝트를 만들어 봅시다:\n\n```js\nnpx create-nx-workspace nestjs-microservices --preset=nest\n```\n\n앱 이름을 api-gateway로 지정해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_1.png\" /\u003e\n\n이제 다음 명령을 실행하여 프로젝트 종속성을 설치해봅시다:\n\n```js\ncd nestjs-microservices\nnpm i @nestjs/microservices class-validator class-transformer\n```\n\n# Auth 모듈 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 프로젝트가 생성되었으므로, nx는 이미 API Gateway 서비스 애플리케이션을 생성해 주었습니다. 이제 API Gateway 앱에서 인증 모듈을 만들어서 인증 관련 요청을 처리할 것입니다.\n\n사용자가 앱에 요청을 보내면 API Gateway가 요청을 받아서 마이크로서비스로 전송합니다. 그래서 동일한 데이터 유형을 사용하기 때문에 중복되는 코드를 피하기 위해 모놀리포 내에서 공유 라이브러리를 만들겠습니다. 아래 명령어를 사용해 코드를 여기저기 중복 생성하지 않고 공유 라이브러리를 만드는 것이 좋습니다:\n\n```js\nnx g @nx/nest:lib shared\n```\n\n이제 dto 폴더를 만들어서 create-user.dto.ts 파일을 추가해 주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\n// shared/src/lib/dto/create-user.dto.ts\n\nimport { IsNotEmpty, IsString } from 'class-validator';\n\nexport class CreateUserDto {\n  @IsString()\n  @IsNotEmpty()\n  username: string;\n\n  @IsNotEmpty()\n  password: string;\n}\n```\n\n또한 tsconfig.base.json에 경로 항목을 추가하고 절대 경로로 가져올 수 있습니다:\n\n```json\n{\n  ...\n  \"compilerOptions\": {\n    ...\n    \"paths\": {\n      \"@nestjs-microservices/shared\": [\"shared/src/index.ts\"]\n    }\n  },\n  ...\n}\n```\n\nNestJS는 기본 TCP 전송 계층을 사용하여 서로 다른 마이크로서비스 인스턴스 간에 메시지를 전달합니다. NestJS는 microservice 전송자를 설명하는 객체 배열을 인자로받는 static register() 메서드를 노출하는 ClientsModule을 제공합니다. 다음 코드 라인을 사용하여 auth.service.ts를 추가하고 AUTH_MICROSERVICE를 등록해 보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// apps/api-gateway/src/auth/auth.module.ts\n\nimport { Module } from '@nestjs/common';\nimport { ClientsModule, Transport } from '@nestjs/microservices';\n\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\n\n@Module({\n  imports: [\n    ClientsModule.register([\n      {\n        name: 'AUTH_MICROSERVICE',\n        transport: Transport.TCP,\n        options: {\n          host: 'localhost',\n          port: 3001,\n        },\n      },\n    ]),\n  ],\n  providers: [AuthService],\n  controllers: [AuthController],\n})\nexport class AuthModule {}\n```\n\n위 코드에서 각 transporter는 name 속성, 선택적인 transport 속성 (기본값은 Transport.TCP), 그리고 선택적인 transporter에 특화된 options 속성을 가지고 있습니다.\n\n모듈을 import한 후에는 @Inject() 데코레이터를 사용하여 auth.service.ts 파일에서 AUTH_MICROSERVICE transporter 매개변수를 사용하여 구성된 ClientProxy 인스턴스를 주입할 수 있습니다. 아래와 같이 사용합니다:\n\n```js\n// apps/api-gateway/src/auth/auth.service.ts\n\nimport { Inject, Injectable } from '@nestjs/common';\nimport { ClientProxy } from '@nestjs/microservices';\n\nimport { CreateUserDto, User } from '@nestjs-microservices/shared';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    @Inject('AUTH_MICROSERVICE') private readonly authClient: ClientProxy\n  ) {}\n\n  getUser(createUserDto: CreateUserDto) {\n    return this.authClient.send\u003cUser, CreateUserDto\u003e('get_user', createUserDto);\n  }\n\n  createUser(createUserDto: CreateUserDto) {\n    return this.authClient.send\u003cUser, CreateUserDto\u003e('create_user', createUserDto);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 보듯이, get_user 또는 create_user 패턴을 사용하여 인증 마이크로서비스에 메시지를 보낼 수 있습니다. 사용자가 로그인하거나 등록할 때 이를 사용할 것입니다.\n\nsend 메서드는 마이크로서비스를 호출하고 응답으로 Observable을 반환하도록 설계되었습니다. 이는 두 가지 인수를 사용합니다:\n\n- pattern — @MessagePattern() 데코레이터에서 정의된 것 중 하나\n- payload — 마이크로서비스에 전달하려는 메시지\n\n마지막으로, login 및 signup을 위한 두 API 엔드포인트를 갖는 AuthController 클래스를 만들 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// apps/api-gateway/src/auth/auth.controller.ts\n\nimport { Body, Controller, Post, BadRequestException } from '@nestjs/common';\nimport { lastValueFrom } from 'rxjs';\n\nimport { CreateUserDto, User } from '@nestjs-microservices/shared';\n\nimport { AuthService } from './auth.service';\n\n@Controller('auth')\nexport class AuthController {\n  constructor(private readonly authService: AuthService) {}\n\n  @Post('login')\n  async login(@Body() createUserDto: CreateUserDto) {\n    const user: User = await lastValueFrom(this.authService.getUser(createUserDto), {\n      defaultValue: undefined,\n    });\n    if (!user) {\n      throw new BadRequestException('Invalid credentials');\n    }\n\n    const isMatch = user.password === createUserDto.password;\n    if (!isMatch) {\n      throw new BadRequestException('Incorrect password');\n    }\n\n    console.log(`User ${user.username} successfully logged in.`);\n\n    return user;\n  }\n\n  @Post('signup')\n  async signup(@Body() createUserDto: CreateUserDto) {\n    const user: User = await lastValueFrom(this.authService.getUser(createUserDto), {\n      defaultValue: undefined,\n    });\n    if (user) {\n      throw new BadRequestException(\n        `Username ${createUserDto.username} already exists!`\n      );\n    }\n\n    return this.authService.createUser(createUserDto);\n  }\n}\n```\n\n앞서 언급했듯이, getUser 및 createUser 인증 클라이언트 메서드는 Obserable을 반환하므로 메시지가 전송되기 전에 명시적으로 구독해야 합니다. 그러나 rxjs에서 가져온 lastValueFrom 메서드를 사용하여 Observable을 Promise로 변환할 수 있습니다.\n\n# 인증 마이크로서비스 생성\n\n이제 다음 명령을 실행하여 첫 번째 인증 마이크로서비스를 생성할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnx g @nx/nest:app auth-microservice\n```\n\n안녕하세요! auth-microservice 앱의 main.ts 파일 내 bootstrap() 함수 보일러플레이트 코드를 NestFactory.createMicroservice() 메소드로 업데이트해보겠습니다:\n\n```js\n// apps/auth-microservice/src/main.ts\n\nimport { Logger } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\nimport { Transport, MicroserviceOptions } from '@nestjs/microservices';\n\nimport { AppModule } from './app/app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice\u003cMicroserviceOptions\u003e(\n    AppModule,\n    {\n      transport: Transport.TCP,\n      options: {\n        host: 'localhost',\n        port: 3001,\n      },\n    }\n  );\n\n  await app.listen();\n\n  Logger.log('🚀 Auth microservice is listening');\n}\n\nbootstrap();\n```\n\nNestFactory 클래스의 createMicroservice() 메소드를 사용하여 마이크로서비스의 인스턴스를 생성할 수 있습니다. 아주 간단하죠! 만약 궁금한 점이 있거나 도움이 필요하시다면 언제든지 물어주세요! 😊✨\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 사용자 엔티티를 공유 라이브러리에서 생성하여 UsersRepository 클래스에서 사용할 겁니다. 이를 통해 사용자 데이터를 저장하고 사용자를 검색하는 작업을 수행할 수 있습니다.\n\n```js\n// shared/src/lib/entities/user.entity.ts\n\nexport class User {\n  id?: number;\n  username: string;\n  password: string;\n}\n```\n\n우리는 어떤 데이터베이스도 사용하지 않으며 간결함을 위해 이 데모에서는 데이터를 메모리에 저장할 겁니다. UserRepository 클래스를 포함한 간단한 user.repository.ts 파일을 만들어보죠.\n\n```js\n// apps/auth-microservice/src/app/user.repository.ts\n\nimport { Injectable } from '@nestjs/common';\n\nimport { CreateUserDto, User } from '@nestjs-microservices/shared';\n\n@Injectable()\nexport class UserRepository {\n  private users: User[] = [];\n\n  save(user: CreateUserDto): User {\n    const newUser = new User();\n    newUser.id = this.users.length + 1;\n    newUser.username = user.username;\n    newUser.password = user.password;\n    this.users.push(newUser);\n    return newUser;\n  }\n\n  findOne(username: string): User | undefined {\n    return this.users.find((user) =\u003e user.username === username);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 createUser() 및 getUser()를 app.service.ts에서 UserRepository 메소드를 사용하여 사용자를 생성하고 찾는 메소드를 추가할 것입니다:\n\n```js\n// apps/auth-microservice/src/app/app.service.ts\n\nimport { Injectable } from '@nestjs/common';\n\nimport { CreateUserDto, User } from '@nestjs-microservices/shared';\n\nimport { UserRepository } from './user.repository';\n\n@Injectable()\nexport class AppService {\n  constructor(private readonly userRepository: UserRepository) {}\n\n  createUser(newUser: CreateUserDto): User {\n    return this.userRepository.save(newUser);\n  }\n\n  getUser(username: string): User | undefined {\n    return this.userRepository.findOne(username);\n  }\n}\n```\n\n마지막으로, @nestjs/microservices 패키지에서 가져온 @MessagePattern() 데코레이터를 사용하여 요청-응답 패러다임을 기반으로 한 메시지 핸들러 메소드를 생성합니다.\n\n```js\n// apps/auth-microservice/src/app/app.controller.ts\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @MessagePattern('get_user') // get_user 메시지 패턴을 수신 대기\n  handleGetUser(user: CreateUserDto) {\n    return this.appService.getUser(user.username);\n  }\n\n  @MessagePattern('create_user') // create_user 메시지 패턴을 수신 대기\n  handleCreateUser(newUser: CreateUserDto) {\n    return this.appService.createUser(newUser);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드에서 handleGetUser() 메시지 핸들러는 get_user 메시지 패턴과 일치하는 메시지를 수신합니다. 이 메시지 핸들러는 클라이언트로부터 전달된 CreateUserDto 유형의 사용자를 인자로 취합니다.\n\n# 서비스 실행 및 테스트\n\n모든 서비스를 테스트하려면 다음 명령어를 개별적으로 별도의 터미널에서 실행해야 합니다:\n\n```js\nnx serve api-gateway\nnx serve auth-microservice\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 테스트하려면 Postman이나 다른 API 클라이언트를 사용할 수 있어요.\n\n## 잘못된 자격 증명으로 로그인\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_2.png\" /\u003e\n\n## 가입\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_3.png\" /\u003e\n\n## 로그인\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_4.png\" /\u003e\n\n## 동일한 사용자 이름으로 가입\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_5.png)\n\n# 결론\n\n코드를 모두 확인하려면 GitHub 링크를 클릭하세요.\n\n읽어 주셔서 감사합니다 — 이 글이 도움이 되셨으면 좋겠습니다. 즐거운 코딩 되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원","ogImage":{"url":"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingMicroserviceswithNestJSTCPandTypescript_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트 네이티브에서 Redux를 이용한 테마 설정","description":"","date":"2024-06-20 00:06","slug":"2024-06-20-ThemingWithReduxinReactNative","content":"\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png)\n\n왜 Theming을 할까요?\n\nTheming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.\n\nRedux로 Theming을 하는 이유는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.\n\n- 리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.\n- 개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.\n- 누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))\n\n우리가 이루고자 하는 목표\n\n이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- \"redux\": \"5.0.1\",\n- \"redux-logger\": \"3.0.6\",\n- \"redux-persist\": \"6.0.0\",\n- \"@react-native-async-storage/async-storage\": \"1.21.0\"\n\n이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.\n\n- 작업 환경을 설치하고 설정하기.\n- 서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.\n- 액션과 리듀서 만들기.\n- Redux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.\n- 리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.\n- 이 컴포넌트 내에서 저장된 상태 사용하기.\n- 마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.\n\n전제 조건\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Javascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.\n- 위의 패키지가 설치되었습니다.\n\n시작하기\n\n패키지 설치\n\n```js\n// npm을 사용하여\nnpm i redux redux-logger redux-persist @react-native-async-storage/async-storage\n// yarn을 사용하여\nyarn add redux redux-logger redux-persist @react-native-async-storage/async-storage\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n색구성 만들기\n\n누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.\n\n```js\nexport interface ColorProps {\n  screenColor: string;\n  primary: string;\n  primaryTextColor: string;\n  lighterBlack: string;\n  secondaryTextColor: string;\n  inActiveUnderlineTextInputColor: string;\n  tertiaryTextColor: string;\n  whiteColor: string;\n  lightPrimaryColor: string;\n  favouriteButtonColor: string;\n  addPhotoButtonColor: string;\n  ratingIconColor: string;\n  disabledButtonColor: string;\n  onboardingInactiveIconColor: string;\n  tabBarTextColor: string;\n  tabColor: string;\n  gradientColor: string;\n}\nexport const Colors: ColorProps = {\n  screenColor: '#E5E5E5',\n  primaryTextColor: '#000000',\n  lighterBlack: '#FFFFFF',\n  secondaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#FFFFFF',\n  gradientColor: '#61D2C4',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  lightPrimaryColor: '#61D2C4',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\n\nexport const DarkColors: ColorProps = {\n  primaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#1E1E1E',\n  secondaryTextColor: '#F5F5F5',\n  screenColor: '#1B1C1E',\n  lighterBlack: '#777777',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  lightPrimaryColor: '#61D2C4',\n  gradientColor: '#1B1C1E',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\nconst themes = {\n  light: {...Colors},\n  dark: {...DarkColors},\n};\n\nexport const getThemeColor = (\n  theme: 'light' | 'dark' = 'light',\n  useSystemTheme?: 'light' | 'dark',\n) =\u003e {\n  const themeMode = themes[theme];\n  return themeMode;\n};\n```\n\n더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.\n\n- 가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).\n- 이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.\n- 이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.\n\n우리의 리덕스 폴더 구조\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.\n\n```js\nexport default {\n  TOGGLE_STATUS: 'Toggle',\n};\nexport type ThemeData = {\n  theme: 'light' | 'dark' | 'system';\n};\nconst initialState: ThemeData = {\n  theme: 'light',\n};\n```\n\n이제 액션(고객)을 만들어 봅시다.\n먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다. \n\n```js\nexport const toggleTheme = (newTheme: string) =\u003e {\n  return {\n    type: types.TOGGLE_STATUS, // 모든 액션은 유형을 가져야 합니다\n    payload: newTheme,\n  };\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)\n\n여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.\n\n```js\nconst toggleThemeReducer = (\n  state: ThemeData = initialState,\n  {type, payload}: {type: string; payload: any},\n) =\u003e {\n  switch (type) {\n    case types.TOGGLE_STATUS:\n      return {...state, theme: payload};\n    default:\n      return state;\n  }\n};\n```\n\n리덕스 스토어 설정 중입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).\n\n우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.\n\n```js\nexport type ThemeState = ReturnType\u003ctypeof toggleThemeReducer\u003e;\n```\n\n그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst rootReducer = (state: ThemeState | undefined, action: any) =\u003e {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n```\n\n이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n```\n\n이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middlewares),\n);\n= 지속 = persistStore(모임);\n```\n\nRedux-logger\n\n이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.\n\n```js\nreduxlogger = createLogger({});\nmiddleware = [reduxlogger];\n\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middleware),\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Redux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.\n\n재수행(Rehydration)\n\n이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.\n\n```js\n{\"theme\": {\"theme\": \"light\"}\nGROUP  action persist/PERSIST @ 16:15:46.681\nLOG    prev state {\"theme\": {\"theme\": \"light\"}\nLOG    action     {\"register\": [Function register], \"rehydrate\": [Function rehydrate], \"type\": \"persist/PERSIST\"}\nLOG    next state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    {\"theme\": {\"theme\": \"light\"} 재수행상태 \nLOG    {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"} 페이로드 {\"theme\": \"light\"} 상태\nGROUP  action persist/REHYDRATE @ 16:15:46.923\nLOG    prev state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    action     {\"err\": undefined, \"key\": \"root\", \"payload\": {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}, \"type\": \"persist/REHYDRATE\"}\nLOG    next state {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 무슨 일이 일어나고 있는 거죠?\n\n앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 `light`를 AsyncStorage에 `persist/PERSIST` 액션을 사용하여 영속화합니다. 그런 다음, 이전에 `dark`로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 `persist/REHYDRATE` 액션을 사용하여 재수확합니다.\n\n이것이 스토어에 대한 완전한 코드입니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst rootReducer = (state: ThemeState | undefined, action: any) =\u003e {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nexport const store = createStore(\n  persistedReducer,\n  applyMiddleware(...middlewares),\n);\nexport const persistor = persistStore(store);\n\nexport type RootState = ReturnType\u003ctypeof rootReducer\u003e; // 사전 정의된 이 유형 추론을 돕기 위한 것.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.\n\n이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.\n\n```js\n인터페이스 DropDownData {\n  라벨: 문자열;\n  값: 문자열;\n}\n인터페이스 DropDownProps {\n  색상?: 문자열;\n}\nconst DropDown = (props?: DropDownProps) =\u003e {\n  const navigation = useNavigation\u003cRootStackNavigationProp\u003e();\n  const [selectedOption, setSelectedOption] = useState\u003cstring\u003e('');\n\n  const data: DropDownData[] = [\n    {label: '테마', 값: 'theme'},\n  ];\n\n  const dispatch = useDispatch();\n\n  const userTheme = useSelector((state: RootState) =\u003e state.theme);\n  const {theme} = userTheme;\n  const Colors = getThemeColor(theme);\n\n  const styles = StyleSheet.create({\n    dropDownItem: {\n      paddingHorizontal: screenWidth * 0.04,\n    },\n    dropdown: {\n      backgroundColor: Colors.screenColor,\n      position: 'absolute',\n      left: screenWidth * 0.55,\n      borderRadius: 20,\n      paddingVertical: 8,\n      width: screenWidth * 0.4,\n    },\n  });\n\n  const handleOptionSelect = (value: string) =\u003e {\n    setSelectedOption(value);\n\n    if (value === 'customTheme') {\n      dispatch(toggleTheme(theme === 'light' ? 'dark' : 'light'));\n    } else if (value === 'system') {\n      dispatch(toggleTheme('system'));\n    }\n  };\n  return (\n    \u003cView\n      style={\n        position: 'absolute',\n        top: screenHeight * 0.07,\n        right: screenWidth * 0.03,\n      }\u003e\n      \u003cSelectDropdown\n        data={data}\n        statusBarTranslucent\n        renderItem={(\n          selectedItem: DropDownData,\n          index: number,\n          isSelected: boolean,\n        ) =\u003e {\n          return (\n            \u003cView\n              style={\n                ...styles.dropDownItem,\n                borderBottomWidth: 1,\n                borderBottomColor: Colors.primary,\n              }\u003e\n              \u003cWText\n                style={\n                  paddingVertical: 13,\n                  paddingLeft: 5,\n                  fontSize: 18,\n                }\u003e\n                {selectedItem.label}\n              \u003c/WText\u003e\n            \u003c/View\u003e\n          );\n        }\n        dropdownOverlayColor=\"transparent\"\n        renderButton={() =\u003e {\n          return (\n            \u003cView\n              style={\n                alignItems: 'flex-end',\n                backgroundColor: Colors.lighterBlack,\n                borderRadius: 100,\n                padding: 5,\n              }\u003e\n              \u003cIonicons\n                name=\"ellipsis-vertical\"\n                color={Colors.primary}\n                size={30}\n              /\u003e\n            \u003c/View\u003e\n          );\n        }\n        onSelect={(selectedItem: DropDownData, index: number) =\u003e {\n          handleOptionSelect(selectedItem.value);\n        }\n        dropdownStyle={styles.dropdown}\n      /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default DropDown;\n```\n\n위에 무슨 일이 발생했나요? \"CustomTheme\"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 \"system\" 옵션을 선택하면 폰의 기본 테마를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템 기본 테마 사용하기\n\n마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.\n\n```js\nexport const getThemeColor = (theme: 'light' | 'dark' = 'light') =\u003e {\n  const systemTheme = useColorScheme() || 'light';\n  const userTheme = useSelector((state: RootState) =\u003e state.theme);\n  const {theme: storedTheme} = userTheme;\n  let themeMode;\n\n  if (storedTheme === 'system') {\n    const themeMode = themes[systemTheme];\n    return themeMode;\n  } else {\n    const themeMode = themes[theme];\n    return themeMode;\n  }\n};\n```\n\n아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userTheme = useSelector((state: RootState) =\u003e state.theme);\nconst {theme} = userTheme;\nconst Colors = getThemeColor(theme);\n```\n\n아래는 우리의 결과입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif)","ogImage":{"url":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png"},"coverImage":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png","tag":["Tech"],"readingTime":14},{"title":"React 코드 향상을 위한 최상의 실천 방법","description":"","date":"2024-06-20 00:04","slug":"2024-06-20-ReactBestPracticestoImproveYourCode","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactBestPracticestoImproveYourCode_0.png\" /\u003e\n\n리액트는 현대 웹 개발에서 중심 역할을 하며, 개발자들에게 비교할 수 없는 효율로 동적이고 인터랙티브한 사용자 인터페이스를 만들 수 있는 기회를 제공합니다. 그러나 리액트의 전체 잠재력을 활용하려면 기본적인 친숙함 이상이 필요합니다. 이 기사에서는 리액트 코딩 능력을 향상시키기 위한 포괄적인 다양한 모범 사례를 탐구하겠습니다. 이 원칙을 준수하면 튼튼하고 확장 가능하며 유지보수가 쉬운 어플리케이션을 만들 수 있습니다.\n\n# 1. 클래스 컴포넌트 대신 함수형 컴포넌트를 사용하세요\n\n- 가독성과 간결성: 클래스 기반 컴포넌트 대비 함수와 훅을 사용하면 더 간단하고 간결한 구문을 얻을 수 있습니다. 함수로 전환하면 클래스 없이 함수형 컴포넌트를 만들 수 있어 코드의 가독성과 이해도를 향상시킬 수 있습니다. 함수는 'this' 키워드, 생성자 및 라이프사이클 함수를 관리하는 복잡성을 제거하여 더 깔끔한 코드를 제공합니다.\n- 코드 재사용성: 여러 컴포넌트에서 로직을 추출하고 재사용할 수 있도록 허용함으로써 훅은 코드 재사용성을 향상시킵니다. 고차 컴포넌트나 렌더 속성을 사용하지 않고도 사용자 정의 훅으로 상태 변화와 상호작용할 수 있습니다.\n- 미래에 대한 유연성: 최근 몇 년간 리액트는 컴포넌트 작성의 주요 방법으로 훅의 널리 퍼지는 사용을 옹호해왔습니다. 리액트 팀은 함수를 사용하여 컴포넌트를 만드는 것을 권장하며 계속해서 능력을 향상하고 확장하기 위한 투자를 계속하고 있습니다.\n- 성능 향상: 훅을 사용하면 성능을 개선하기가 더 쉬워집니다. useCallback 및 useMemo와 같은 훅을 활용하면 함수와 값을 캐시하여 추가 렌더링 반복이 필요 없게 하고 컴포넌트 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Counter.js\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            count: 0,\n        };\n    }\n\n    incrementCount() {\n        this.setState({\n            count: this.state.count + 1,\n        });\n    }\n\n    render() {\n        return (\n            \u003cdiv\u003e\n                \u003ch1\u003eCount: {this.state.count}\u003c/h1\u003e\n                \u003cbutton onClick={() =\u003e this.incrementCount()}\u003e\n                    Increment\n                \u003c/button\u003e\n            \u003c/div\u003e\n        );\n    }\n}\n\nexport default Counter;\n```\n\n함수 구성 요소를 사용하면 더 명확하고 간단하게 재사용 가능하고 모듈식 코드를 개발할 수 있습니다.\n\n```js\n// Hook\nimport React, { useState } from 'react';\n\nconst Counter = () =\u003e {\n    const [count, setCount] = useState(0);\n\n    const incrementCount = () =\u003e {\n        setCount(prevCount =\u003e prevCount + 1);\n    };\n\n    return (\n        \u003cdiv\u003e\n            \u003ch1\u003eCount: {count}\u003c/h1\u003e\n            \u003cbutton onClick={incrementCount}\u003e\n                Increment\n            \u003c/button\u003e\n        \u003c/div\u003e\n    );\n};\n\nexport default Counter;\n```\n\n# 2. 구성 요소 조합\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트에서 컴포넌트 구성은 더 작은 컴포넌트를 조합하여 재사용 가능한 UI 컴포넌트를 생성하는 실천을 말합니다. 이를 통해 개발자들은 복잡한 UI를 작은, 더 관리하기 쉬운 부분으로 분해하여 응용 프로그램의 다른 부분에서 쉽게 재사용할 수 있게 됩니다.\n\nComponent Composition을 사용하는 여러 이점이 있습니다:\n\n- 재사용성: 컴포넌트는 응용 프로그램의 다른 부분에서 쉽게 재사용할 수 있어 UI를 유지하고 업데이트하기 쉽게 만듭니다.\n- 모듈성: UI를 더 작고 관리하기 쉬운 컴포넌트로 분해하면 특히 크고 복잡한 응용 프로그램에 대해 이해하고 작업하기가 쉬워집니다.\n- 관심사의 분리: UI를 더 작은 컴포넌트로 분리함으로써 각 컴포넌트가 자체 특정 기능에 집중할 수 있어 테스트하고 디버깅하기가 쉬워집니다.\n- 코드 유지보수성: 이해하고 유지 관리하기 쉬운 작은 컴포넌트를 사용하면 시간이 흐른 후 응용 프로그램을 업데이트하고 변경하기가 쉬워집니다.\n\n```js\nimport React from ‘react’;\nimport { PropTypes } from “prop-types”;\n\nconst Button = (props) =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cbutton type=“button”\u003eHandler\u003c/button\u003e\n    \u003c/div\u003e\n  )\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact PropTypes는 React 애플리케이션에서 코드 품질, 유지 관리성 및 개발자 생산성을 향상시키는 데 중요한 런타임 유형 검사, 문서화, 디버깅 지원 및 API 정의 기능을 제공합니다.\n\n# 3. 인라인 스타일 사용을 피하세요\n\n인라인 스타일의 가장 큰 문제점 중 하나는 코드 유지와 업데이트가 어려워진다는 것입니다. 웹 페이지의 모양을 변경하려면 스타일 속성이 있는 모든 요소를 수정해야 하며, 하나의 외부 또는 내부 스타일 시트를 수정하는 대신 수정해야 합니다. 이렇게 되면 복잡성이 증가하고 효율성이 감소하며, 웹 애플리케이션 스타일을 변경할 때 오류가 발생할 가능성이 더 높아집니다.\n\n```js\nimport React from \"react\";\n\nconst styles = {\n  width: 200,\n  height: 50,\n  backgroundColor: 'red'\n};\n\nconst Button = () =\u003e (\n  \u003cbutton style={styles}\u003eMy Button\u003c/button\u003e\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. Arrow 함수 사용하기\n\nArrow 함수를 사용하면 일반 함수 표현식과 비교하여 더 간결한 구문을 제공할 뿐만 아니라 코드 가독성을 향상시키고 작은 함수(예: 이벤트 핸들러 또는 콜백 함수)에 대해 불필요한 말을 줄일 수 있습니다. 이들의 간결한 구문은 코드베이스의 명확성을 유지하고 전반적인 가독성을 향상시키는 데 도움이 됩니다. 더불어 arrow 함수는 주변 코드의 렉시컬 스코프를 상속받아 특정 상황에서 명시적으로 'this'를 바인딩할 필요가 없게 하므로 더 깔끔하고 직관적인 코드를 작성할 수 있습니다. Arrow 함수를 활용하면 코드 유지 관리성을 향상시키고 개발 프로세스를 간소화하여 더 효율적이고 읽기 쉬운 코드를 작성할 수 있습니다.\n\n```js\nconst App = () =\u003e (\n  \u003cContainer\u003e\n    {/* 앱 코드의 나머지 부분 */}\n  \u003c/Container\u003e\n);\n``` \n\n# 5. lazy()와 Suspense() 함수 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact에서는 lazy() 함수와 component를 사용하여 코드 분할과 로딩 상태 처리를 조절하며, 특히 초기 로드 시간을 최적화하고 사용자 경험을 향상시키는 데 유용합니다. 이는 로딩 인디케이터를 표시함으로써 대규모 응용 프로그램에서 특히 유용합니다.\n\n- lazy() 사용:\n\nlazy() 함수를 사용하면 컴포넌트를 동적으로 가져올 수 있습니다. 이는 컴포넌트가 실제로 필요할 때만 로드되어 초기 렌더링 중에 미리 로드되지 않습니다. 특히 대규모 컴포넌트나 즉시 필요하지 않은 컴포넌트에 유용합니다.\n\n- `Suspense` 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 컴포넌트는 Lazy-로드되는 컴포넌트가 로드될 때까지 기다리는 동안 로딩 표시기를 지정할 수 있게 해줍니다. 이것은 Lazy-로드되는 컴포넌트를 감싸는 역할을 합니다.\n\n```js\nimport React, { lazy, Suspense } from 'react';\n\nconst LazyComponent = lazy(() =\u003e import('./LazyComponent'));\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n        \u003cLazyComponent /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n이 접근법은 실제로 필요할 때만 로드되는 Less Critical 컴포넌트로 인해 응용 프로그램의 초기 번들 크기와 로드 시간을 최적화하는 데 도움이 됩니다. 특히 초기 로드 크기를 줄이는 것이 성능에 중요한 대규모 응용 프로그램에서 특히 유익합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 애플리케이션에서 최적의 성능을 유지하기 위해서는 구성 요소 렌더링 효율을 향상시키는 것이 중요합니다, 특히 복잡하고 방대한 사용자 인터페이스를 가진 애플리케이션의 경우입니다. 아래의 전략을 통해 렌더링 성능을 향상시킬 수 있습니다:\n\nReact.memo 활용: 고차 컴포넌트인 React.memo를 활용하면 구성 요소 렌더링 결과를 메모화할 수 있습니다. 이를 통해 구성 요소의 props가 변경되지 않은 경우 불필요한 재렌더링을 방지할 수 있습니다.\n\n```js\nimport React from 'react';\n\nconst MyComponent = React.memo(({ prop1, prop2 }) =\u003e {\n  // 구성 요소 렌더링 로직\n});\n\nexport default MyComponent;\n```\n\n이 최적화 기술을 구현함으로써 React 애플리케이션의 전반적인 성능과 반응성을 크게 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. TypeScript 사용하기\n\nTypeScript는 JavaScript의 typed superset으로서 일반 JavaScript로 컴파일됩니다. 클래스, 모듈 및 인터페이스를 제공하여 견고한 구성 요소를 구축하는 데 도움이 됩니다.\n\n```js\nimport React from 'react';\n\ninterface Props {\n  name: string;\n}\n\nconst Hello: React.FC\u003cProps\u003e = ({ name }) =\u003e \u003cdiv\u003eHello {name}\u003c/div\u003e;\n```\n\n# 8. 유형 선언 도구 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 TypeScript를 사용할 수 없는 경우, prop-types나 다른 대안과 같은 타입 체크 도구나 라이브러리를 활용하는 것을 권장합니다. 이러한 도구들은 React 컴포넌트 내에서 타입 체크를 보장하여 각 prop으로 전달된 데이터의 정확성을 확보하는 데 도움을 줍니다. prop-types는 인기 있는 선택지이지만, 현대적인 개발 관행과 더 잘 부합하는 대안 라이브러리를 탐색하는 것이 좋습니다.\n\n- 타입 체크: 이러한 도구들을 사용하여 prop의 예상 데이터 타입을 정의할 수 있어, 타입 제약을 강제함으로써 런타임 오류를 최소화할 수 있습니다.\n- 디버깅: 타입 위반이 발생했을 때 경고가 발생하여, 잘못된 prop 사용과 관련된 문제를 식별하고 해결하는 데 도움이 됩니다.\n- 문서화: 명시적으로 prop 타입을 지정함으로써, 이러한 도구들은 예상하는 prop 및 각각의 데이터 타입에 대한 문서로서, 개발자들에게 명확한 정보를 제공합니다.\n- 코드 유지보수성: 이러한 도구들을 사용함으로써 코드의 가독성과 유지보수성이 향상되어, 개발자들이 구성 요소 인터페이스를 더 잘 이해하고 효과적으로 협업할 수 있습니다.\n\nprop-types가 오랜 기간 사용된 솔루션이긴 하지만, 생태계는 변화하고 있으며, 다른 도구를 탐색하여 현대적인 개발 관행과의 호환성을 확보하는 것이 중요합니다.\n\n# 9. ESLint 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nESLint은 React 애플리케이션에서 코드 품질, 일관성, 잠재적인 오류 또는 버그를 확인하는 데 사용되는 인기 있는 도구입니다. ESLint가 React 개발에서 널리 사용되는 이유와 중요한 기능들은 다음과 같습니다:\n\n- 정적 코드 분석: ESLint는 코드를 실행하지 않고 검사하는 정적 분석을 수행합니다. 이렇게 함으로써 ESLint는 개발 프로세스 초기에 오류와 잠재적인 문제를 감지하여 버그를 방지하고 코드 품질을 향상시킬 수 있습니다.\n- 사용자 지정 규칙: ESLint를 사용하면 React 개발에 맞게 사용자 정의 규칙을 정의하거나 사전 정의된 규칙 세트를 사용할 수 있습니다. 이러한 규칙은 프로젝트 내에서 코딩 표준, 최상의 실천 방법 및 규칙을 강요합니다. 예를 들어, 특정 React 패턴의 사용을 강제하거나 훅을 올바르게 사용하거나 사용되지 않는 메서드를 피하도록 할 수 있습니다.\n- 자동화된 코드 리뷰: ESLint를 CI/CD 파이프라인에 통합하여 개발 워크플로에 자동화된 코드 리뷰를 포함시킬 수 있습니다. 이를 통해 코드 품질 표준이 모든 코드 기여 부분에서 일관되게 유지되도록 보장하고 회귀를 방지할 수 있습니다.\n- 코드 일관성: ESLint는 일관된 코딩 스타일을 강요함으로써 코드베이스 전체에서 일관성을 유지하는 데 도움을 줍니다. 이는 여러 개발자가 코드를 기여하는 협업 프로젝트에서 특히 중요합니다. 일관된 코드는 읽기, 이해 및 유지 관리가 쉬워져 전체 프로젝트 품질을 향상시킵니다.\n\n# 10. 테스트 케이스 작성\n\n테스트는 React 개발의 중요한 측면이며 무시해서는 안 되는 부분입니다. 이를 통해 응용 프로그램이 높은 품질, 신뢰성 및 훌륭한 사용자 경험을 제공하는지 확인할 수 있습니다. 이러한 React 컴포넌트의 테스트 케이스는 방대한 수의 React 테스트 케이스를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 애플리케이션을 테스트하는 데 사용할 수 있는 여러 유형의 테스트가 있습니다.\n\n- 유닛 테스트: 유닛 테스트는 React 애플리케이션의 개별 컴포넌트를 테스트하는 데 사용됩니다. 각 컴포넌트의 기능을 독립적으로 테스트하여 의도한 대로 작동하는지 확인합니다. 유닛 테스트는 일반적으로 Jest 또는 Mocha와 같은 테스트 프레임워크를 사용하여 작성됩니다.\n- 통합 테스트: 통합 테스트는 애플리케이션의 다른 컴포넌트가 함께 작동하는 방식을 테스트하는 데 사용됩니다. 컴포넌트 간 상호 작용을 테스트하여 의도한 대로 작동하는지 확인합니다. 통합 테스트는 Cypress 또는 Selenium과 같은 테스트 프레임워크를 사용하여 작성할 수 있습니다.\n- End-to-End 테스트: 엔드투엔드 테스트는 전체 애플리케이션을 테스트하는 데 사용됩니다. 사용자의 관점에서 애플리케이션을 테스트하여 의도한 대로 작동하는지 확인합니다. 엔드투엔드 테스트는 Cypress 또는 Selenium과 같은 테스트 프레임워크를 사용하여 작성할 수 있습니다.\n- 컴포넌트 테스트: React 컴포넌트는 효율적으로 테스트할 수 있는 작고 재사용 가능한 코드 조각입니다. 이 단계에서는 DOM 상호 작용을 테스트하고자 합니다.\n\n리액트에서 테스트 케이스를 작성하는 것은 코드 신뢰성을 보장하고 코드 품질을 높이며 리팩토링을 용이하게 하며 CI/CD 파이프라인을 지원하고 개발자 신뢰도를 향상시키며 개발팀 간 협업을 촉진하는 데 중요합니다. 이는 리액트 애플리케이션의 총 안정성과 유지보수성에 기여하는 소프트웨어 개발 프로세스의 필수 요소입니다.\n\nTelegram / Instagram / Facebook / Threads / GitHub","ogImage":{"url":"/assets/img/2024-06-20-ReactBestPracticestoImproveYourCode_0.png"},"coverImage":"/assets/img/2024-06-20-ReactBestPracticestoImproveYourCode_0.png","tag":["Tech"],"readingTime":9},{"title":"Box UI Elements, React, Tailwind CSS, Vercel을 사용하여 콘텐츠 포털을 만드는 방법 - 파트 1","description":"","date":"2024-06-20 00:02","slug":"2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1","content":"\n\n\n![image](/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_0.png)\n\nBox는 그 자체로 훌륭하지만 때로는 특정 사용자 인터페이스를 가진 맞춤 환경을 외부 사용자에게 제공하고 싶은 경우가 있을 수 있습니다. 이때 컨텐츠 포털이 등장합니다!\n\n이 포털 시리즈의 첫 번째 부분에서 Box의 샘플 코드 저장소 중 하나를 사용하여 Box UI Elements, React, Tailwind CSS 및 Vercel을 이용해 포털 개발을 시작하는 방법을 살펴볼 것입니다.\n\n# 커스텀 포털 개요\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 알지 못하는 경우, 포털은 기본적으로 Box 위에 오버레이입니다. 이를 통해 내부 직원, 공급업체 또는 외부 고객이 비즈니스 프로세스의 저장 계층으로 Box를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_1.png)\n\n만든 포털은 완전히 사용자 정의된 사용자 경험을 제공하며, Box API를 사용하여 데스크톱이나 모바일 기기에서 콘텐츠 클라우드와 상호 작용하는 것이 쉽습니다.\n\n가장 좋은 부분은 Box의 산업 최고 수준의 보안 메커니즘이 유지되어, 콘텐츠에 접근해야 하는 사람만이 접근할 수 있도록 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 고객 사용 사례\n\n우리는 보험 청구나 자산 관리를 위해 포털을 사용하는 많은 고객들을 보유하고 있습니다. 아래는 몇 가지 예시입니다.\n\n모건 스탠리는 클라이언트가 컨설턴트와 협력하며 재정 및 세금 문서를 관리할 수 있도록 Box API를 사용한 디지털 보궐을 만들었습니다.\n\n새로운 고객 대출 신청 및 대출 문서 보관을 위해 포털을 활용하는, 신규 또는 소규모 비즈니스와 대출 업체를 연결하는 Fundwell도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n국가적으로는 보통 전체 보험 청구 처리과정에 Box 콘텐츠 포털을 사용합니다.\n\n# 안내\n\n오늘의 데모에서는 Box UI 요소를 사용하여 가상 뱅크 'Increo Financial'을 위한 간단한 금융 문서 포털을 만드는 방법을 안내하겠습니다. 이 예시 코드를 사용하여 여러분의 포털을 발전시키는 시작점으로 활용할 수 있습니다.\n\nUI Elements는 Box 플랫폼의 사용하기 쉽고 사용자 정의 가능한 React UI 구성 요소입니다. 버전 19부터는 반응형으로 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 유형이 있습니다. 파일 업로드, 다운로드 및 볼 수 있는 컨텐츠 탐색기(content explorer) 또는 파일을 사용자에게 표시하는 미리 보기 요소(preview element)와 같은 것들이 있습니다. 우리 포털은 다양한 것들을 사용할 것입니다.\n\n박스의 기능 및 범위가 내장되어 있습니다. 예를 들어, 사용자가 파일의 메타데이터를 볼 수 있게 하거나 Box AI를 사용하고 싶다면 작은 구성 변경으로 쉽게 가능합니다.\n\n모든 최신 데스크톱 및 모바일 브라우저가 지원되며, 로고도 사용자 정의할 수 있습니다.\n\nUI Elements v20부터 React v17.0.2 및 Node 18.18.0까지 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 🚨 중요 사항 🚨\n\n이 데모는 시연을 위한 것이며 실제 운영에 적합하지 않습니다. 완전한 인증 조치가 부족하기 때문에 추가 개발 없이는 실제 환경에 적합하지 않습니다.\n\n## 필요 사항\n\n튜토리얼의 첫 번째 부분을 완료하려면 다음 항목이 필요합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- GitHub 계정\n- Vercel 계정 — GitHub 계정으로 로그인하는 것이 좋습니다.\n- Box 개발자 계정 — Box 전체에서 고유한 이메일 주소를 사용해야 합니다.\n\n## Box 애플리케이션 구성\n\n- 새 애플리케이션 만들기: Box 개발자 콘솔에 가서 ‘새 앱 만들기’를 클릭하고, ‘사용자 정의 앱’을 선택하고, 앱 이름을 지정한 다음에 ‘JWT를 사용한 서버 인증(JWT)’을 선택합니다. 참고 — 실제 데모에는 필요하지 않지만, 앱 사용자 관리 및 보안 수준을 높이기 위해 실제 배포에서 JWT를 사용하는 것이 권장됩니다.\n- 애플리케이션 범위 설정: 필요한 권한이 있는지 확인합니다: 앱 + 기업, 모든 파일 읽기/쓰기, 사용자/그룹/기업 속성 관리, Box AI(Enterprise+ 라이선스 이상에서만 사용 가능) 및 사용자 액세스 토큰 생성하기. 다시 한 번 강조하지만, 이러한 범위 중 일부는 데모 배포에서 사용되지 않지만, 실제 시나리오에서는 필수입니다.\n- 공개/비공개 키 쌍 생성: 공개/비공개 키 쌍 생성 버튼을 클릭합니다. 이 작업은 2단계 인증이 필요합니다. 이전에 설정한 적이 없다면 설정해야 할 것입니다. 팝업이 나타나면 설정 방법을 안내합니다. 설정을 완료한 후, 키 페어 플로우를 다시 진행해야 합니다.\n- JSON 구성 파일 다운로드: 이 파일은 키 페어 생성시 자동으로 다운로드됩니다. 이 파일을 가까이 보관하세요. 나중 단계에서 이 파일의 정보가 필요합니다.\n- 저장: 우측 상단에 있는 버튼을 사용하여 변경 사항을 저장합니다.\n\n## Box 애플리케이션 인증\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n항상 그렇듯이, 서버 인증 애플리케이션을 사용하려면 Box 인스턴스의 관리자에 의해 승인해야 합니다. 애플리케이션을 승인하려면 사용자 지정 앱 승인에서 안내된 단계를 따르세요. 승인 후에는 서비스 계정 이메일이 앱에 할당됩니다. 누군가 변경을 가할 때마다 앱을 다시 승인해야 합니다.\n\n## Box 더미 콘텐츠 설정\n\n데모가 동작하려면 몇 가지 더미 콘텐츠를 생성해야 합니다. 실제 시나리오에서는 사용자가 생성되거나 Increo Financial에 가입할 때 대부분 자동화될 수 있습니다. 그러나 간단함과 신속성을 고려하여 여기서는 수동으로 진행하겠습니다.\n\n모든 포털 콘텐츠가 저장될 루트 폴더를 생성하세요. 폴더의 이름을 Portal Demo로 지정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 만든 JWT 애플리케이션의 서비스 계정 이메일 주소를 포털 데모 루트 폴더에 추가해보세요. 만일 어디서 해당 이메일을 가져와야 할지 기억하지 못한다면, Box 개발자 콘솔의 일반 설정 탭에서 찾을 수 있습니다.\n\n많은 종단 사용자가 사용할 예정인 포털을 상상해볼 때, 하나의 사용자를 위한 폴더를 만들어봅시다. 데모 루트 폴더에 새 폴더를 생성하세요. 가짜 사용자의 이름으로 이름을 지어주시면 되는데, 예를 들어 Robert Smith와 같이 해보세요.\n\n이번 데모에서는 앱 사용자를 사용하지는 않겠지만, 컨텐츠 포털의 프로덕션 구현에서는 앱 사용자를 활용하여 적합한 보안 포지셔닝을 유지하는 것이 매우 중요합니다. 이와 관련된 자세한 정보는 여기와 여기에서 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스미스 씨의 폴더 안에 두 개의 폴더를 더 만들어주세요: Applications와 Statements.\n\nStatements 폴더에 이 더미 명세서의 사본을 업로드해주세요.\n\n사용자의 루트 폴더에 이 더미 약관 파일의 사본을 업로드해주세요. 실제 시나리오에서는 이 파일이 다른 곳에 존재할 수 있지만, 미리뷰 상자 UI 요소를 보여드리기 위해 실제 파일이 필요합니다.\n\n우리가 생성한 각 요소마다 다음 단계에서 필요한 ID를 유지해야 하니 Box를 열어두세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Vercel을 사용하여 초기 사이트 배포하기\n\n이제 Box 애플리케이션을 만들고 더미 콘텐츠를 만들었으므로 Box의 샘플 저장소에서 기본 포털의 사본을 배포할 수 있습니다.\n\n🚨중요🚨\n\n이미 Vercel 계정을 생성하고 탭에서 열어 둔 상태여야 합니다. 계정이나 탭을 열지 않은 채로 Vercel에 배포하면 혼동이 발생할 수 있습니다. GitHub에서 무언가를 처음으로 배포할 때 GitHub와 Vercel을 서드 파티 통합을 통해 연결하라는 메시지가 표시될 것입니다. 이것은 정상적인 동작입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 링크를 클릭하여 Vercel에 배포해보세요. 여러 옵션을 선택해야 할 것이므로 함께 진행해 봅시다.\n\n먼저, 위의 링크를 클릭했을 때 아래 화면이 표시되지 않는다면 아마 Vercel에 로그인되지 않았을 것입니다. 오른쪽 상단에 있는 로그인을 클릭하여 로그인하고, 창을 닫은 다음 다시 링크를 클릭해주세요.\n\n아래 화면에 도달하면, 첫 번째 상자 오른쪽 하단의 '만들기'를 클릭해주세요. 이렇게 하면 귀하의 계정에 GitHub 저장소가 생성되고 Box의 샘플 저장소에서 코드를 복제합니다.\n\n다음 단계에서, 여러 환경 변수를 붙여넣어야 합니다. Vercel에 내장된 환경 변수를 사용하면 보안을 유지하는 훌륭한 방법입니다. 각 부분에 대한 Box 콘텐츠 ID는 해당 부분의 URL 막대에서 찾을 수 있습니다. 예를 들어, 아래 스크린샷에서 URL 슬러그 끝에 표시된 ID는 'Statements' 폴더의 폴더 ID입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 값 필드를 확인하고 요청된 변수를 채우세요. 완료하면 배포를 클릭해주세요.\n\n- REACT_APP_BOX_CONTENT_UPLOADER_FOLDER_ID 변수는 파일 folder와 함께 사용됩니다.\n- REACT_APP_UPLOADED_FOLDER_ID 변수는 폴더 applications와 함께 사용됩니다.\n- REACT_APP_BOX_PREVIEW_FILE_ID 변수는 파일 terms and conditions와 함께 사용됩니다.\n- 나머지 변수들은 자동으로 다운로드된 JSON 구성 파일에서 가져옵니다. 보안상의 이유로 이들을 표시하지는 않겠습니다. 단지 복사하여 붙여넣기하면 됩니다 — 따옴표 없이. 그 중에서 가장 긴 사설 키는 순서가 섞여 있고, 값에는 /n을 포함해야 합니다.\n\n배포를 클릭한 후 아래와 같은 화면이 표시될 것입니다. 이 프로세스는 몇 분 정도 걸릴 수 있습니다.\n\n다음과 같은 오류가 표시될 수 있습니다. 그럴 때는 해결 방법이 있습니다. 왼쪽 상단의 이름을 클릭하여 대시보드로 이동해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_3.png\" /\u003e\n\n포털 프로젝트를 클릭하여 선택하세요.\n\n프로젝트의 설정 탭에서 아래로 스크롤하여 Node.js 버전 섹션을 찾으세요. 드롭다운에서 18.x를 선택하세요. 저장을 클릭하세요.\n\n이제 포털 프로젝트의 배포 탭을 전환하세요. 실패한 배포를 볼 수 있어야 합니다. 점 세 개를 클릭하고 다시 배포를 선택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팝업에서 기본 설정을 그대로 두고, 다시 배포를 클릭해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_4.png\" /\u003e\n\n몇 분 후 성공하면, 준비 상태가 표시될 것입니다.\n\n방문 버튼을 클릭하세요. 배포된 샘플 콘텐츠 포털의 홈페이지가 나타날 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배포 후 설정\n\n기본 포털을 테스트하려면 Box 애플리케이션 구성 섹션에 CORS 도메인을 추가해야 합니다. 방문 버튼 아래에서 찾을 수 있습니다. 표준 페이지와 배포 URL을 모두 추가해야 합니다. 테스트 중에 배포 URL을 방문/사용할 계획이라면 둘 다 추가해주세요. URL 끝에 슬래시를 포함하지 마시고 쉼표로 구분해 주세요.\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_5.png\" /\u003e\n\nURL을 추가한 후, 우측 상단의 저장 버튼을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 포털 테스트\n\n기본으로 배포된 포털에는 내장된 인증이 없기 때문에 이메일 필드는 비워 둘 수 있습니다. 비밀번호 필드에는 Box 애플리케이션 구성 섹션에서 얻은 개발자 토큰을 붙여 넣을 수 있습니다.\n\n\"개발자 토큰 생성\"을 클릭합니다. 토큰을 복사합니다.\n\n토큰을 비밀번호 필드에 붙여 넣고 \"로그인\"을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 후 아래 화면이 표시됩니다. '내 명세서' 헤더 옵션을 클릭해주세요.\n\n모든 것이 예상대로 작동했다면, 업로드한 더미 명세서가 있는 명세서 폴더가 표시됩니다. 이 페이지는 콘텐츠 업로더 UI 요소를 사용하기 때문에 많은 기능을 수행할 수 있습니다! 명세서를 클릭해주세요.\n\n명세서의 미리 보기가 나타납니다. 이제 오른쪽 상단의 로그아웃을 클릭해주세요.\n\n홈페이지로 돌아가도록 초대받을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 다음에 올 내용\n\n이 포털 시리즈의 후속 블로그에서는 추가 페이지 추가, 인증 개선, Box AI 사용, 색상 사용자 정의 및 기타 기능 등 여러 가지 향상 사항을 살펴볼 예정입니다!\n\n# 마무리\n\n1부에서 확인한 것처럼, Box UI Elements 및 Box API를 사용하면 내부 또는 외부 사용자를 위한 사용자 정의 경험을 매우 쉽게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 부분에서는 기본 포털을 추가 기능으로 확장하는 데 중점을 둘 것입니다.\n\n그때까지, 즐거운 코딩하세요!\n\n항상, Box 개발자 관련팀에 피드백이 있으면 개발자 포럼에 연락해주세요.","ogImage":{"url":"/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_0.png"},"coverImage":"/assets/img/2024-06-20-BuildacontentportalusingBoxUIElementsReactTailwindCSSVercelPart1_0.png","tag":["Tech"],"readingTime":7},{"title":"제목 파트 2 리액트  훅의 명명 규칙 및 반환 형식","description":"","date":"2024-06-20 00:00","slug":"2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_0.png\" /\u003e\n\n# 📖 이전 파트\n\nPart 1은 여기에서 찾을 수 있어요: https://medium.com/p/e6af2696089a\n\nReact 훅은 함수형 컴포넌트에서 상태와 다른 React 기능을 사용할 수 있게 해주는 JavaScript 함수들입니다. 이 함수들의 이름은 use로 시작하는 것들이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 문서에서 인용한 내용입니다:\n\nReact 훅에 대해 기사를 작성해야 하는 이유가 궁금할 수 있습니다. 실은 전통적인 방식에는 문제가 없지만 몇몇 사람들은 더 나은 가독성과 이해를 위해 훅에 접근하는 방법을 발견했다는 것을 알게 되었거든요.\n\n이 기사를 작성하게 된 동기 중 하나는 저를 다른 방식으로 훅을 개선하는 방법을 보여준 존 마이클 도로이입니다. 이 기사에서는 우리의 방식을 공유하겠습니다.\n\n# 📜 사용자 지정 훅의 전통적인 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 형식으로 테이블 태그를 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_2.png)\n\n두 번째로 소개할 것은 창 크기를 반환하는 사용자 정의 훅입니다. 이 훅의 이름은 useWindow입니다.\n\n이전에 말씀드렸듯이, 이 네이밍 규칙에는 문제가 없습니다. 하지만 이 네이밍 규칙을 어떻게 개선할 수 있는지 살펴봅시다.\n\n# 📝 제안된 네이밍 규칙 및 반환 형식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 이용 수칙 중 하나는 후크 이름에 접두사나 접미사를 추가하여 해당 후크의 유형을 나타내는 것입니다.\n\n첫 번째 예로, 후크를 useTheme 대신 useThemeContext로 지정할 수 있습니다. 이렇게 하면 해당 후크가 컨텍스트에서 테마를 반환한다는 것을 쉽게 식별할 수 있습니다.\n\n두 번째 예로, 첫 번째 제안과 유사하게 후크의 이름을 useWindow 대신 useWindowSize로 지정할 수 있습니다. 마찬가지 이유로 해당 후크가 무엇을 하는지 쉽게 식별할 수 있습니다!\n\n해당 후크 이름을 더 구체적으로 지정하여 해당 작업이 무엇인지 이해하기 쉽게 하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n훅의 이름을 자명하게 만들어서 구현을 보지 않아도 훅이 하는 일을 이해할 수 있는 것을 선호해요.\n\n이제, 반환 시그니처로 넘어가 봅시다. 반환 시그니처는 함수가 반환하는 값입니다.\n\n훅의 반환 시그니처를 어떻게 개선할 수 있을지 생각해보세요.\n\n현재 훅은 값을 직접 반환하고 있습니다. 그렇다면 갑자기 다른 값을 반환해야 한다면 어떻게 해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n갑작스럽게 훅의 반환 시그니처를 변경하면 훅을 사용하는 컴포넌트에서 변경 사항이 발생할 수 있습니다.\n\n그래서 값을 직접 반환하는 대신, 값을 속성으로 가진 객체를 반환하는 것을 제안합니다.\n\n다음은 제안된 명명 규칙과 반환 시그니처로 보이는 훅의 예시입니다:\n\n![React Hooks return signature](/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Korean](/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_4.png)\n\n이렇게 하면 훅을 사용하는 컴포넌트를 변경하지 않고 반환 값에 더 많은 값을 쉽게 추가할 수 있습니다.\n\n작은 변화지만 미래에 더 많은 값을 반환해야 할 때 큰 차이를 만들어 줄 수 있습니다.\n\n# 🤔 반환 시그니처 문제를 정말 해결했을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 다 왔어요. 여기에서 John Michael Doroy의 아이디어를 가져오되 다른 예제로 해보려고 해요.\n\n대부분의 경우, 우리는 컴포넌트 내에서 다음과 같이 훅을 사용해요:\n\n\n\u003cimg src=\"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_5.png\" /\u003e\n\n\n당신이 생각하는 것 알아요. 구조 분해를 제거하고 객체를 직접 사용해야 한다고요. 네, 그렇게 할 수 있지만 경우에 따라 객체를 구조 분해하고 이 오류를 만날 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 훅을 사용할 때 변수 이름을 userSettings와 appSettings로 지정해야 한다는 걸 기억해야 해요. 실제로 괜찮지만, \n\n하지만, 다른 컴포넌트에서 사용하고 싶다고 가정해봅시다. 다시 변수를 userSettings로 지정해야 한다는걸 기억해야죠.\n\n![Image](/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_6.png)\n\n오탈자에 주목했나요? userSetings가 아니라 userSettings가 맞아요. 이게 문제의 핵심이에요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제안된 해결책은 후크 이름을 사용 접두사 없이 키로, 값은 값으로 하는 객체를 반환하는 것입니다.\n\n다음은 어떻게 보이는지입니다:\n\n![image](/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_7.png)\n\n이렇게 하면 컴포넌트에서 사용된 후크를 쉽게 식별할 수 있습니다. 또한 이전에 만난 오타를 피할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_8.png\" /\u003e\n\n충돌이나 오타가 없어질 것입니다. 이 작은 변화가 장기적으로 큰 차이를 만들어냅니다.\n\n- 훅을 더 일관되게 사용할 수 있습니다. 다른 컴포넌트에서 동일한 훅에 대해 다른 변수 이름을 사용하지 않아도 됩니다.\n- 오타를 방지할 수 있습니다. 더 이상 userSetings 대신 userSettings를 사용하지 않아도 됩니다.\n- 충돌을 피할 수 있습니다. useUserSettings와 useAppSettings에서 가져오는 설정 충돌을 막을 수 있습니다.\n\n# 🎁 추가 혜택: `react-query` 커스텀 훅을 위한 명명 규칙 + 반환 시그니처\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 얼마 전부터 react-query를 사용해오고 있어요. 지금은 우리가 react-query를 위해 훅을 어떻게 이름 짓는지 공유하고자 해요.\n\n이 내용이 문서화되었거나 문서에서 공유되었는지는 확실하지 않아요. 하지만 우리가 react-query를 위해 훅을 어떻게 이름 짓는지 알려드릴게요.\n\nreact-query에는 두 가지 유형의 훅이 있어요:\n\n- 쿼리 훅(Query hooks)\n- 뮤테이션 훅(Mutation hooks)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리 후크(Query hooks)에 대해서는 use`동사``도메인`Query와 같이 훅(hook)의 이름을 짓습니다.\n\n다음은 몇 가지 예시입니다:\n\n1. 사용자를 가져오고 싶을 때는 useGetUserQuery라고 이름을 지정합니다.\n\n2. 사용자 목록을 가져오고 싶을 때는 useGetUsersQuery라고 이름을 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 제품 목록을 가져오고 싶을 때, useGetProductsQuery라고 이름을 지정합니다.\n\n변이 훅의 경우, 훅의 이름을 use`동사``도메인`Mutation으로 지정합니다.\n\n여기 몇 가지 예시입니다:\n\n1. 사용자를 만들고 싶을 때, useCreateUserMutation으로 이름을 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 사용자를 업데이트하려면 `useUpdateUserMutation`이라고 이름을 붙입니다.\n\n3. 사용자를 삭제하려면 `useDeleteUserMutation`이라고 이름을 붙입니다.\n\n반환 시그니처에 대해서는, 우리는 훅 이름을 키로 사용접뒤에 `use` 접두사를 제외한 형식으로 객체를 반환하고, 값으로 값이 입력됩니다.\n\n다음과 같은 형식을 가집니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 표를 마크다운 형식으로 변경했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_10.png\" /\u003e\n\n다음은 이 네이밍 규칙 및 훅 반환 형식을 사용하는 이유입니다:\n\n- 컴포넌트에서 사용 중인 훅의 유형을 식별하는 데 도움이 됩니다.\n- 훅을 더 일관된 방법으로 사용할 수 있게 도와줍니다. 다른 컴포넌트에서 동일한 훅에 대해 서로 다른 변수 이름을 사용하지 않게 됩니다.\n- 변수 충돌을 피하는 데 도움이 됩니다. 각 훅에 고유한 이름이 있어 해당 훅 이름을 포함하는 객체를 반환하기 때문에 변수 충돌을 방지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 결론\n\n이것을 작성하기 전에, React 문서에서 이미 다뤄진 이 주제가 흔하기 때문에 말할 게 많지 않을 거라고 생각했어요.\n\n하지만 제가 깨달은 건, 우리가 다룰 수 있는 몇 가지 부분이 있고 우리의 경험을 통해 배운 것을 공유할 수 있다는 거예요.\n\n프로그래밍에서 네이밍 규칙과 일반적인 접근 방식은 중요합니다. 일관된 네이밍 규칙과 접근 방식이 없다면 코드베이스를 이해하고 유지 관리하기 어려울 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로, 사용할 방법은 당신에게 달려있습니다. 저가 공유한 전통적인 방법이나 제안된 방법 중 원하는 방법을 선택할 수 있습니다. 무엇을 선택하든, 선택한 방법을 유지하고 일관되게 사용하는 것이 중요합니다.\n\n당신은 미래의 자신과 팀을 위해 코드를 작성하고 있습니다. 이해하기 쉽고 유지보수하기 쉬운 코드를 작성하는 데 주의해주세요.\n\n언제든지 질문이나 제안이 있으면 아래에 댓글을 남겨 주세요. 당신의 의견을 기다리고 있을게요.\n\n읽어 주셔서 감사합니다. 이 글이 여러분의 여정에 도움이 되길 바랍니다! ❤️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쉽고 이해하기 쉽게 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요 👏️️\n- 팔로우 링크: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_0.png"},"coverImage":"/assets/img/2024-06-19-Part2ReactNamingConventionReturnSignaturesforHooks_0.png","tag":["Tech"],"readingTime":6}],"page":"48","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"48"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>