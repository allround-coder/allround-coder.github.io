<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/122" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/122" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" href="/post/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시계열 데이터에서의 이상치 탐지와 ChatGPT" href="/post/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시계열 데이터에서의 이상치 탐지와 ChatGPT" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시계열 데이터에서의 이상치 탐지와 ChatGPT" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시계열 데이터에서의 이상치 탐지와 ChatGPT</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" href="/post/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러를 배우는 데 얼마나 비싼가요" href="/post/2024-05-13-HowExpensiveItIstoLearnAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러를 배우는 데 얼마나 비싼가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러를 배우는 데 얼마나 비싼가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러를 배우는 데 얼마나 비싼가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 프로세스와 스레드 이해하기" href="/post/2024-05-13-UnderstandingProcessesandThreadsinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 프로세스와 스레드 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 프로세스와 스레드 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 프로세스와 스레드 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" href="/post/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS에서 PWA 우리가 지금 어디에 있는지" href="/post/2024-05-13-PWAsOniOSWhereWeAreNow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 PWA 우리가 지금 어디에 있는지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 PWA 우리가 지금 어디에 있는지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">iOS에서 PWA 우리가 지금 어디에 있는지</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" href="/post/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" href="/post/2024-05-13-Angularisnotforeveryoneandprobablynotforyou"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" href="/post/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link posts_-active__YVJEi" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"앵귤러에서 HTTP 호출용 재시도 인터셉터 구성하기","description":"","date":"2024-05-13 00:26","slug":"2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png\" /\u003e\n\nAPI 요청이 실패하는 이유는 네트워크 오류, 가용성 문제, 서버 문제 등이 많습니다. 응용 프로그램의 신뢰성과 안정성을 높이기 위해 재시도 메커니즘을 갖는 것이 좋은 실천 방법입니다. 실패할 경우 이 메커니즘은 동일한 API 호출을 백그라운드에서 다시 시도할 것입니다.\n\nAPI 호출이 일시적으로 실패하는 경우가 많아 재시도하면 응용 프로그램이 이러한 일시적 결함을 어느 정도 견딜 수 있음을 보장할 수 있습니다. 우리는 이러한 메커니즘을 달성하는 데 도움이 되는 구성 가능한 재시도 인터셉터를 Angular에서 만들 것입니다.\n\n# 구성(Configuration)\n\n\n\n위에서 말했듯이, 리트라이 인터셉터는 다음 구성으로 구성할 수 있습니다.\n\n- Count: API 호출을 다시 시도할 횟수입니다.\n- Delay: 다시 시도하기 전에 지연할 밀리초 수입니다.\n- Timeout: API 호출이 타임 아웃될 때까지 기다릴 밀리초 수입니다.\n\n이 구성을 위한 인터페이스와 각 구성에 대한 기본 값이 있습니다.\n\n```js\nexport interface RetryApiConfig {\n  count?: number;\n  delay?: number;\n  timeout?: number;\n}\n\n// Default Values\nconst CONFIG_DEFAULT: RetryApiConfig = {\n  count: 3, // 3번 재시도\n  delay: 500, // 500ms 대기\n  timeout: 20000, // 20초 후에 API 타임 아웃\n};\n```\n\n\n\n기본 구성은 제공되었지만 필요한 경우이를 재정의하는 방법을 제공할 것입니다.\n\n# HTTP Interceptor\n\n우리는 모든 API 호출에 대해 재시도 메커니즘을 추가하려고 합니다. Angular에서 HTTP Interceptor가 가장 적절한 위치일 것입니다.\n\nHttpInterceptor 인터페이스를 구현한 간단한 인터셉터를 만들어 봅시다.\n\n\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n\n    return next.handle(request).pipe(\n      // RxJS Operators\n    );\n}\n```\n\n옵저버블 파이프에는 재시도 메커니즘을 구현하기 위해 모든 필요한 RxJS 연산자를 추가할 것입니다. 다음 두 연산자를 사용할 예정입니다.\n\n## retry\n\n이름에서 알 수 있듯이 retry 연산자는 API 호출을 다시 시도합니다. HTTP 요청 옵저버블이 실패하면 이 방법은 다시 시도하기 위해 소스 원래 옵저버블에 다시 구독할 것입니다. 위에서 선언한 count와 delay 속성이 있는 구성 객체를 사용합니다.\n\n\n\n## 타임아웃\n\n이 연산자는 주어진 밀리초 후에 오류 옵저버블을 발행합니다. 따라서, 임계값을 초과한 요청을 취소합니다.\n\n이제 위에서 선언한 기본 구성 개체와 함께 인터셉터에서 이 두 연산자를 사용해 봅시다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n\n    return next.handle(request).pipe(\n      retry(CONFIG_DEFAULT), // 요청 재시도\n      timeout(CONFIG_DEFAULT.timeout) // 주어진 시간 후 타임아웃\n  );\n}\n```\n\n\n\n만약 우리 애플리케이션에서 다음과 같이 이 인터셉터를 사용한다면, 예상대로 작동할 것입니다.\n\n```js\n@NgModule({\n  ...\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: RetryInterceptor,\n      multi: true\n    },\n  ],\n  ...\n})\nexport class AppModule { }\n```\n\n하지만, 누군가가 구성을 다른 값으로 재정의하고 싶다면 현재는 그 방법이 없습니다.\n\n# 구성 가능한 인터셉터\n\n\n\n여러 애플리케이션에서 사용 중인 라이브러리 내에 인터셉터가 있고, 각 애플리케이션마다 재시도 인터셉터의 다른 구성이 있는 경우, 애플리케이션이 인터셉터에 구성을 제공할 수 있는 방법이 있을까요?\n\n## Injection Tokens 사용하기\n\n애플리케이션이 구성을 재정의하려는 경우 제공할 수 있는 구성을 위한 인젝션 토큰을 생성할 수 있습니다.\n\n```js\n// 앱이 구성을 업데이트하는 데 사용할 수 있는 구성을 위한 토큰\n// 예시:\n//  {\n//     provide: RETRY_INTERCEPTOR_CONFIG,\n//     useValue: { count: 5, delay: 2000 },\n//  },\nexport const RETRY_INTERCEPTOR_CONFIG = new InjectionToken\u003cRetryApiConfig\u003e(\n  'retryConfig',\n  {\n    providedIn: 'root',\n    factory: () =\u003e {\n      return CONFIG_DEFAULT;\n    },\n  }\n);\n```\n\n\n\n이 인젝션 토큰의 유형은 우리가 위에서 선언한 인터페이스이며 \"retryConfig\"가 이름입니다. 두 번째 매개변수에서는 팩토리 함수를 사용하여 이 토큰의 기본 값을 제공합니다. 따라서 애플리케이션이 이 토큰을 제공하지 않으면 기본 객체가 대체값으로 사용됩니다.\n\n이제 이 토큰을 인터셉터에 주입해 보겠습니다.\n\n``` js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // Config 객체 주입\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n}\n```\n\n이제 애플리케이션이 제공한 구성과 기본 구성을 병합하는 방법이 필요합니다. 애플리케이션이 재시도 구성의 일부만(예: count 속성) 제공하고 다른 속성은 제공하지 않는 경우가 있을 수 있습니다.\n\n\n\n이 둘을 병합한 후 병합된 객체를 반환하는 프라이빗 함수를 만들 수 있습니다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // 구성 객체 주입\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n\n  // 병합된 객체 가져오기\n  private getConfig(): Required\u003cRetryApiConfig\u003e {\n    return {\n      count:\n        this.retryConfig.count ??\n        COUNT_DEFAULT,\n      delay:\n        this.retryConfig.delay ??\n        DELAY_DEFAULT,\n      timeout:\n        this.retryConfig.timeout ??\n        TIMEOUT_DEFAULT,\n    };\n  }\n}\n```\n\n이제 retryConfig 프로퍼티가 null 또는 정의되지 않았는지 확인하여 기본값을 취하는 것입니다.\n\n마지막으로, 이제 이 병합된 객체를 인터셉터에서 사용할 수 있습니다.\n\n\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 합쳐진 구성 가져오기\n    const config = this.getConfig();\n\n    return next.handle(request).pipe(\n      retry(config), // 여기에서 합쳐진 구성 사용\n      timeout(config.timeout)\n  );\n\n  private getConfig(): Required\u003cRetryApiConfig\u003e {\n    // 생략\n  }\n}\n```\n\n필요시 애플리케이션에서 기본 구성을 재정의할 수 있습니다.\n\n```js\n@NgModule({\n  ...\n  providers: [\n    {\n      provide: RETRY_INTERCEPTOR_CONFIG,\n      useValue: {\n        count: 2 // 이 애플리케이션에서는 count만 재정의함\n      }\n    }\n  ],\n  ...\n})\nexport class AppModule { }\n```\n\n하지만 아직도 마지막 문제가 있습니다. 특정 API 호출이 이 구성을 재정의하려면 어떻게 해야 할까요? 예를 들어, 네트워크 부하가 큰 호출은 재시도하지 않고 싶을 수 있습니다.\n\n\n\n## HttpContext 사용하기\n\nAngular의 HttpContext에 대해 잘 모르신다면 먼저 여기를 읽어보세요. 우리는 어떤 API 호출이 응용 프로그램 레벨 또는 기본 구성을 재정의하고 싶을 때 제공할 수 있는 컨텍스트 토큰을 생성할 수 있습니다.\n\n```js\nexport const RETRY_INTERCEPTOR_CONTEXT =\n  new HttpContextToken\u003cRetryApiConfig | null\u003e(() =\u003e null);\n```\n\n컨텍스트의 기본값은 null입니다. HTTP 요청을 수행하는 동안 어떤 API 호출이라도 컨텍스트를 설정할 수 있습니다.\n\n\n\n```js\nthis.http.get(URL, {\n  context: new HttpContext().set(RETRY_INTERCEPTOR_CONTEXT, { count: 1 })\n})\n```\n\n또한 getConfig 메서드를 업데이트하여 구성을 병합할 때 context를 사용해야 합니다.\n\n```js\n@Injectable()\nexport class RetryInterceptor implements HttpInterceptor {\n  // config 객체를 주입합니다.\n  private retryConfig: RetryApiConfig = inject(RETRY_INTERCEPTOR_CONFIG);\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler) {\n    // 생략\n  );\n\n  // 병합된 객체를 가져옵니다.\n  private getConfig(request: HttpRequest\u003cunknown\u003e): Required\u003cRetryApiConfig\u003e {\n    return {\n      count:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.count ??\n        this.retryConfig.count ??\n        COUNT_DEFAULT,\n      delay:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.delay ??\n        this.retryConfig.delay ??\n        DELAY_DEFAULT,\n      timeout:\n        request.context.get(RETRY_INTERCEPTOR_CONTEXT)?.timeout ??\n        this.retryConfig.timeout ??\n        TIMEOUT_DEFAULT,\n    };\n  }\n}\n```\n\ncontext 토큰은 요청에서 검색됩니다. 먼저 context를 확인한 후 토큰 설정을 마지막으로 기본 설정을 확인하는 절차를 따릅니다.\n\n\n\n\n![이미지](/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_1.png)\n\n이로써 HTTP 호출에 대한 완전히 구성 가능한 재시도 메커니즘을 완성했습니다.\n\n지금까지 읽은 것이 마음에 든다면 박수 한 번 쳐주세요! 마음에 들지 않는다면 댓글을 남겨주세요😋!\n\n연결하고 싶으시다면? LinkedIn\n\n\n\n혹시 기부를 하고 싶으시다면, 커피 하나로 감사의 마음을 전해보세요! ☕️\n\n# 스택캇 🎓\n\n마지막까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해주시면 감사하겠습니다! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인해주세요","ogImage":{"url":"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png"},"coverImage":"/assets/img/2024-05-13-ConfigurableRetryInterceptorinAngularForHTTPCalls_0.png","tag":["Tech"],"readingTime":7},{"title":"시계열 데이터에서의 이상치 탐지와 ChatGPT","description":"","date":"2024-05-13 00:24","slug":"2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png\" /\u003e\n\n# 소개\n\n이론적으로 아이디어는 간단해요\n\n문제는 간단하게 설명할 수 있지만 실제로, 특히 규모가 커지면, 그걸 하기가 상당히 어려워요. 이 기사 전체에서 사용할 예제를 들어보면, 특정 숫자 시리즈(아래에 그려짐)를 살펴볼 거에요\n\n\n\n```js\n[\n  1048, 829, 823, 783, 827, 894, 842, 865, 886, 894, 831, 371, 589, 391, 279,\n  246, 298, 2761, 20907, 6866, 871, 945, 844, 3516, 6242, 844, 894, 542, 797,\n  832, 828, 847, 891, 915, 896, 814, 680, 417, 177, 0, 0, 1376, 6111, 18184,\n  3546, 911, 480, 711, 820, 814, 793, 783, 834, 833, 845, 943, 882, 936, 840,\n  747, 576, 393, 261, 180, 303, 2975, 12446, 6882, 896, 919, 820, 749, 779, 812,\n  677, 903, 849, 806, 526, 796, 807, 791, 833, 813, 821, 482, 379, 245, 124,\n  382, 1776, 13503, 5255, 1757, 1945, 1615, 1092, 822, 856, 843, 862, 899, 835,\n  821, 825, 821, 837, 551, 725, 649, 412, 283, 134, 384, 886, 11587, 5876, 1251,\n  1012, 841, 855, 898, 936, 903, 921, 953, 919, 903, 904, 790, 811, 686, 522,\n  280, 179, 123, 293, 3781, 9501, 1409, 1911, 1329, 1039, 952, 894, 989, 982,\n  839, 889, 953, 937, 961, 1195, 938, 943, 458, 576, 322, 426, 248, 411, 671,\n  823, 850, 1278, 1081, 860, 820, 16,\n];\n```\n\n![2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_1](/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_1.png)\n\n우리가 관심있는 포인트는 마지막 숫자 (16)입니다. 여러분의 웹 쇼핑몰에서 지불 고객을 나타내는 숫자 목록을 상상해보십시오. 예상보다 낮은 숫자라면 경고를 받고 싶습니다. 이제 수백 개의 웹 쇼핑몰을 관리하고 있다고 상상해보십시오. 하나의 웹 쇼핑몰에서 지불 고객의 수가 감소하면 알림을 받을 수 있는 시스템에 자동으로 설정하는 방법은 무엇일까요?\n\n일반적으로는 비용이 많이 드는 SaaS 도구를 사용할 수 있지만, 그들은 비용 부담이 큽니다. 그 이유로 우리는 직접 설정할 것입니다. 기계 학습을 사용하여 이러한 유형의 문제를 해결하기를 시작하는 것은 이전 경험이 없다면 상당히 어렵습니다. Anodot 또는 유사한 서비스를 사용하고자 하지 않는 한 이 프로젝트를 시작하려면 상당한 초기 투자를 해야 할 것입니다.\n\n\n\nChatGPT 및 유사한 도구를 사용하면, 일반적으로 몇 일 또는 몇 주가 걸리는 제품(이상 감지 엔드포인트)를 몇 시간 또는 몇 분 안에 만들 수 있습니다.\n\n# 예시\n\n우리는 상대적으로 빠르고 저렴하며 신뢰할 수 있는 방법으로 ChatGPT를 사용하여 이상 감지를 자동화할 수 있는지 확인하고 싶어요.\n\n- 우리가 필요한 첫 번째 것은 openai 라이브러리입니다.\n\n\n\nnpm install openai\n\n2. API 키를 받으세요\n\n![AnomalydetectionintimeseriesdatawithChatGPT_2 이미지](/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_2.png)\n\n3. 그리고 코드를 입력하세요\n\n\n\n```js\nimport OpenAI from 'openai';\n\nconst apiKey = 'YOUR_API KEY'\nconst model = \"gpt-3.5-turbo-0125\"\n\nconst openai = new OpenAI({\n    apiKey\n});\n\nconst formQuestion = dynamicContent =\u003e {\n    const question = `매일 사용자 수 (숫자로)가 주어졌을 때, 마지막 데이터포인트가 이상치인가요?  \n    [${dynamicContent}]\n    return json { outlier: boolean, value: number, belowLowerLimitBand: boolean}\n    outlier는 해당 지점이 이상치인지를 나타내야 합니다.\n    value는 해당 지점의 값을 가져야 합니다.\n    `\n    return question\n}\n\n\nconst askQuestion = async question =\u003e {\n    const completions = await openai.chat.completions.create({\n        messages: [{ \"role\": \"user\", \"content\": question }],\n        model,\n        response_format: { \"type\": \"json_object\" },\n        temperature: 0,\n    });\n    const { choices, usage } = completions\n    return { choices, usage }\n}\n\n\nconst answerMyQuestion = async (list) =\u003e {\n    const question = formQuestion(list)\n    const { choices, usage } = await askQuestion(question)\n    // const price = getPrice(usage, model)\n    // console.log(`The price was ${price} USD`);\n    choices.forEach(completion =\u003e {\n        const result = completion.message.content\n        const { outlier, belowLowerLimitBand, value } = JSON.parse(result)\n        console.log({ outlier, belowLowerLimitBand, value });\n    })\n}\n\n\nconst list =[\n  1048, 829, 823, 783, 827, 894, 842, 865, 886, 894, 831, 371, 589, 391, 279,\n  246, 298, 2761, 20907, 6866, 871, 945, 844, 3516, 6242, 844, 894, 542, 797,\n  832, 828, 847, 891, 915, 896, 814, 680, 417, 177, 0, 0, 1376, 6111, 18184,\n  3546, 911, 480, 711, 820, 814, 793, 783, 834, 833, 845, 943, 882, 936, 840,\n  747, 576, 393, 261, 180, 303, 2975, 12446, 6882, 896, 919, 820, 749, 779, 812,\n  677, 903, 849, 806, 526, 796, 807, 791, 833, 813, 821, 482, 379, 245, 124,\n  382, 1776, 13503, 5255, 1757, 1945, 1615, 1092, 822, 856, 843, 862, 899, 835,\n  821, 825, 821, 837, 551, 725, 649, 412, 283, 134, 384, 886, 11587, 5876, 1251,\n  1012, 841, 855, 898, 936, 903, 921, 953, 919, 903, 904, 790, 811, 686, 522,\n  280, 179, 123, 293, 3781, 9501, 1409, 1911, 1329, 1039, 952, 894, 989, 982,\n  839, 889, 953, 937, 961, 1195, 938, 943, 458, 576, 322, 426, 248, 411, 671,\n  823, 850, 1278, 1081, 860, 820, 16\n];\n\n\nanswerMyQuestion(list)\n\n// RESULT:\n// { outlier: true, belowLowerLimitBand: true, value: 16 }\r\n```  \n\n위의 내용을 보면, 시작하기에 필요한 상대적으로 작은 양의 코드입니다. 위의 코드에서 흥미로운 부분은 question 변수입니다. 이것은 ChatGPT에게 진짜 질문을 하게 하는 부분으로, 온라인 버전에서 진행하는 방법과 동일합니다.\n\n위 코드의 결과는 우리에게 다음 정보를 제공합니다:\n- 우리에게 이상치(이상현상)가 있음을 나타냅니다.\n- 우리가 기대하는 수치 이하에 있는지 여부(이 경우 더 많은 결제 고객은 문제가 아님)\n- 분석하는 값입니다.\n\n\n\n# 가격\n\n## Azure 제공품과 비교하여 (어차피 사용이 중지될 예정이지만):\n\n1000 거래에 대한 비용 (같은 질문에 대한 1000개의 답변이 있다고 가정합시다)은 0.314 미국달러입니다.\n\n이는 다른 \"이상 징후 감지\" SaaS 회사들이 부과하는 가격대 중에서도 저렴한 편에 속합니다. 그렇다면 ChatGPT가 이를 능가할 수 있을까요?\n\n\n\n## ChatGPT 가격\n\n위의 테스트에서는 현재 gpt-3.5-turbo-0125 모델을 사용 중이며, 가격은 다음과 같습니다:\n\n- 입력 토큰당 $0.0005\n- 출력 토큰당 $0.0015\n\n요청 당 가격을 계산하기 위해 OpenAI API가 요청에 사용된 토큰 양을 반환하므로 조금의 도움이 필요할 것입니다:\n\n```js\nconst getPrice = (usage, model) =\u003e {\n    const pricing = {\n        'gpt-3.5-turbo-0125': {\n            'prompt': 0.0005,\n            'completion': 0.0015,\n        }\n    }\n    const modelPrice = pricing[model]\n    const promptCost = usage['prompt_tokens'] * modelPrice['prompt'] / 1000\n    const completionCost = usage['completion_tokens'] * modelPrice['completion'] / 1000\n    const totalCost = promptCost + completionCost\n    return totalCost\n}\n```  \n\n\n\n예시 요청에 대한 응답 사용법은 다음과 같습니다.\n\n```js\n{ prompt_tokens: 440, completion_tokens: 25, total_tokens: 465 }\n```\n\n따라서, 하나의 \"답변\"에 대한 가격은 0.0002575 미국 달러입니다.\n\n따라서 1000개의 답변 당 가격은 0.2575 미국 달러입니다.\n\n\n\n그 가격은 Azure 솔루션보다 상당히 저렴하네요. 최적화를 적용하지 않은 상태에서도 여전히 동일한 결과를 얻을 수 있어요. ChatGPT에 질문을 할 때 질문의 크기를 줄이면서도 원하는 결과를 얻을 수 있다면 돈을 절약할 수 있어요!\n\n# 주의할 점\n\n모든 것을 완전히 자동화하려면 Open AI의 API를 사용해야 합니다.\n문제는 이것이 고급 챗봇 같다는 것인데, 우리가 묻는 질문에 대해 어떻게 하고 무엇을 물어볼 지에 대해 매우 신중해야 합니다. 말의 작은 변화가 완전히 다른 결과를 의미할 수 있습니다.\n이를 제한하는 방법이 있지만, 위에서 설명한 방식으로 ChatGPT를 사용할 때 결과가 어떻게 생산되었는지에 대한 통찰력이 없다는 점을 명심해야 합니다.\n특정 결과에 도달하는 방법이 중요한 경우도 있고 결과 자체가 중요한 경우도 있습니다.\n이러한 이유로 쿼리를 다양한 종류의 입력값으로 테스트하고, 잘못된 긍정 또는 부정을 받지 않도록하는 것이 현명합니다.\n\n## 결정론성\n\n\n\n현재 ChatGPT가 결정론을 보장하기 어려운 상황입니다. 즉, 동일한 질문이 다른 답변으로 이어질 수 있습니다. 이것은 자동화된 시스템을 만들고 싶을 때 매우 불편합니다. 이 문제를 피하기 위해 쿼리를 만들 때 특히 조심해야 합니다. API로 전송할 수 있는 옵션이 있어 이 문제를 최소화할 수 있지만, 장기적으로 세밀한 조정을 하는 것이 더 나은 접근법일 것으로 보입니다.\n\n# 결론\n\n큰 언어 모델은 아이디어와 현실 사이의 간극을 좁히는 데 성공했습니다. 이미 훈련된 모델을 사용하면 기계 학습에 대해 아무 것도 이해할 필요가 없습니다. 대부분의 사람들이 트랜지스터가 어떻게 작동하는지 모르지만 여전히 컴퓨터를 큰 이점으로 사용할 수 있는 방법과 마찬가지입니다.\n\n기타 SaaS 서비스가 이미 이상 탐지에 많은 \"것\"을 구축했음에도, 해당 서비스에 묶이거나 제한받지 않고 스스로 시작하는 과정은 일부 사람들이 생각하는 것만큼 어렵지는 않습니다. 그 주장의 반대 면은 OpenAI에 어느 정도 묶이게 될 것이라는 점입니다. 이는 부분적으로 사실이지만, 다른 대규모 언어 모델로 전환해도 많은 코드가 재사용 가능하다는 사실을 간과해서는 안 됩니다.\n\n\n\n이 방식을 통해 필요에 따라 자신의 속도로 프롬프트를 정제할 수 있습니다. 또한 상단에 원하는 도구를 구축할 수도 있습니다. 이는 경보 시스템, 차트 등이 될 수 있습니다.\n\n당신이 좋아할지도\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가를 칭찬하고 팔로우하는 걸 잊지 말아요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- 다양한 콘텐츠가 PlainEnglish.io에서 만나보세요","ogImage":{"url":"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png"},"coverImage":"/assets/img/2024-05-13-AnomalydetectionintimeseriesdatawithChatGPT_0.png","tag":["Tech"],"readingTime":8},{"title":"Dayjs로 날짜 조작하기 - 주어진 시간을 추가하거나 빼기","description":"","date":"2024-05-13 00:23","slug":"2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png\" /\u003e\n\nDay.js는 우리 앱에서 날짜를 조작할 수 있게 해주는 JavaScript 라이브러리입니다.\n\n이 기사에서는 JavaScript 앱에서 Day.js를 사용하여 날짜를 조작하는 방법을 살펴보겠습니다.\n\n# 주어진 시간 만큼 추가하거나 빼기\n\n\n\nDay.js의 Date 객체에 add 메소드를 사용하여 지정된 시간을 추가할 수 있어요.\n\n예를 들어, 다음과 같이 작성할 수 있어요:\n\n```js\nconst dayjs = require(\"dayjs\");\nconst result = dayjs().add(7, \"day\");\nconsole.log(result);\n```\n\n현재 날짜 및 시간에 7일을 추가하려면 이렇게 해보세요.\n\n\n\n우리는 첫 번째 인수로 `year`, `month`, `date`, `hour`, `minute`, `second`, 그리고 `millisecond` 단위 값 중 하나를 사용하여 add 메서드를 호출합니다.\n\n두 번째 인수는 설정할 값입니다.\n\n1월부터 시작하는 월은 JavaScript 날짜와 같이 0으로 시작합니다.\n\n각 인수 문자열에 대한 축약어도 있습니다.\n\n\n\n`y`는 `year`의 약어입니다.\n\n`M`은 `month`의 약어입니다.\n\n`D`는 `date`의 약어입니다.\n\n`d`는 `day`의 약어이며, 이는 주의 요일을 나타냅니다. 0은 일요일부터 시작하며, 6은 토요일을 의미합니다.\n\n\n\n`h`은 `시간`의 약자입니다.\n\n`m`은 `분`의 약자입니다.\n\n`s`는 `초`의 약자입니다.\n\n그리고 `ms`는 `밀리초`의 약자입니다.\n\n\n\n웹 애플리케이션에서 날짜를 조작할 수 있는 JavaScript 라이브러리인 Day.js를 사용해봤네요. \"add\"를 \"subtract\"로 대체하고 동일한 인수를 유지하여 특정 시간을 뺄 수 있습니다.\n\n# 결론","ogImage":{"url":"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png"},"coverImage":"/assets/img/2024-05-13-ManipulatingDateswithDayjsAddorSubtractaGivenAmountofTime_0.png","tag":["Tech"],"readingTime":1},{"title":"앵귤러를 배우는 데 얼마나 비싼가요","description":"","date":"2024-05-13 00:21","slug":"2024-05-13-HowExpensiveItIstoLearnAngular","content":"\n\n## 프로그래밍\n\n\u003cimg src=\"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png\" /\u003e\n\n앵귤러는 자주 높은 학습 비용이라고 설명됩니다. 하지만 실제로 그렇게 비싼 것은 아닙니다. 첫째, 리액트나 뷰와 같은 프레임워크와 비교하지 않겠습니다. 또한, 본문 주제로 정확히 이어지지 않는 에세이형 기사입니다. 그리고 저는 앵귤러를 사랑합니다. 이 기사는 앵귤러를 사랑하는 사람이 쓴 입장표를 가정하고 읽어주세요.\n\n\"학습 비용\"은 학습을 위해 지불하는 금액을 의미합니다. 하지만 우리는 프로그래밍을 배우기 위해 돈을 지불하는 일이 그렇게 많지 않습니다. 대신, 새로운 기술을 배우는 데 시간을 투자합니다.\n\n\n\n## 비용을 줄이고 싶으신가요?\n\n비용이라고 하면 \"줄일 수 있는\" 것이라는 생각이 듭니다. 한정된 예산 내에서 지출을 조절하기 위해 비용을 낮추고 싶어 합니다. 그렇다면 \"학습 비용\"은 얼마 정도일까요? 왜 학습 비용을 낮추어야 할까요?\n\n일본에서의 소프트웨어 개발 주류는 노동 집약적인 시스템 개발이었습니다. 이 모델로 수익을 늘리기 위해서는 노동 비용이 낮을수록 좋고, 개발 기간이 짧을수록 수익 기계가 더 잘 돌아갈 수 있습니다.\n\n시스템 요구 사항이 바뀔 때마다, 직원들이 필요한 기술을 보유하고 있는 것에 보증이 없습니다. 이런 경우 직원을 교육해야 할 필요가 있습니다. 당연히, 이 교육을 단기간에 완료하는 것이 바람직합니다. 다시 말해, 학습 비용이 낮은 기술을 선택하는 학습자에게는 동기부여가 있는 것입니다.\n\n\n\n한편, 학습자들은 어떨까요? 프로그래머의 목표가 기술을 향상시켜 시장 가치를 높이고 수입을 증가시키는 것이라면, 기술을 배우는데 드는 비용이 낮다는 것은 누구나 빠르게 이해할 수 있다는 것을 의미합니다.\n\n학습 비용이 낮은 기술은 시장 가치를 높이는 데 어려움을 겪을 것입니다. 하지만 많은 비용을 투자해 학습한 기술을 보유하더라도 일자리가 없다면 시장 가치는 증가하지 않을 것입니다.\n\n돈을 벌어들일 수 있는 기술은 시간이 지남에 따라 변할 수 있으며 도박이 될 수 있습니다. 중요한 것은 한 번 배운 기술을 다음 단계로 옮길 수 있는지 여부입니다.\n\n새로운 기술이 출시될 때마다 처음부터 다시 학습하는 데 더 많은 시간이 필요합니다. 한 번 지불한 학습 비용을 재사용하고 새로운 기술을 배움으로써 이자효과를 통해 기술을 향상시킬 수 있습니다. 다시 말하면, 단순히 학습 비용이 높거나 낮은 것이 아니라 \"무엇을 배웠는가\"가 의미 있는 것입니다.\n\n\n\n## 비용의 자본화\n\n두 가지 유형의 비용이 있습니다. 지출을 발생시키는 비용과 자산을 구매하는 비용입니다. 지불한 자본이 미래 이익을 확보하는 데 기여한다면, 비용이 아닌 자산입니다. \"일단 지불한 학습 비용을 재사용하여 새로운 기술을 배우는 것\"은 학습 비용을 자본화하는 것을 의미합니다. 학습 비용이 비싸더라도, 미래에 이윤을 창출할 자산이 될 경우 장기적인 관점에서 더 높은 비용을 지불하는 것이 나을 때가 있습니다.\n\n특정 기술을 학습하는 비용을 고려할 때, 세부 사항을 고려해야 합니다. 그 비용 가운데 일부는 자산이 되고 일부는 비용이 될 것입니다. 기술이 시장에서 가치 없어지고 낡아 날 경우, 그것은 돈 낭비에 불과합니다.\n\n반면, 패러다임 전환에도 살아남을 핵심 기술과 개념을 학습하는 것은 자산이 될 것입니다. 이는 비용과는 무관합니다.\n\n\n\n높은 비용의 기술은 주로 자산이지만, 저렴한 기술은 주로 비용이 많이 들 수 있습니다. 하나의 지침은 저렴한 제품을 사서 돈을 낭비하지 않도록 쉽게 자산으로 전환할 수 있는 기술을 선택하는 것입니다.\n\n자, 드디어 본격적으로 시작할 준비가 끝났네요. 이번 글에서는 Angular를 배우는 데 필요한 비용에 대해 이야기해 보고자 합니다. 토론을 기반으로 Angular를 배우는 데 필요한 비용과 분해를 고려해 보겠습니다.\n\n## Angular 학습 비용\n\n먼저, Angular를 시작하는 데 필요한 비용을 살펴보겠습니다. Angular를 사용하기 위해 배워야 할 기술은 HTML/CSS, TypeScript, Observable(RxJS)입니다. 게다가, npm 중심의 생태계에서 웹 개발에 대한 기본적인 이해도 필요합니다. 이러한 비용들은 어떨까요? 자산이 될까요?\n\n\n\n## HTML/ CSS\n\n이것은 자산입니다. 전 세계적으로 웹 페이지를 지원하는 주요 웹 기술입니다. 많은 사람들이 Angular을 배우기 전에도 이미 가지고 있는 자산입니다. Angular로 웹을 처음 배우는 사람들에게도 기억할 만한 기술입니다.\n\n## NPM 생태계\n\n오늘날 npm 명령을 사용하지 않고 웹 개발을 하는 것은 거의 불가능합니다. npm 주변의 생태계는 매우 발전되고 성숙하며 확립되었습니다. 물론 이것은 자산으로 기록되어야 합니다.\n\n\n\n## TypeScript\n\n이것 또한 훌륭한 자산이 될 것입니다. TypeScript는 지난 몇 년간 광범위하게 인기를 얻어왔습니다. Angular 및 React, Vue, 그리고 다른 프레임워크와 라이브러리들이 점점 더 채택하고 있습니다. Angular를 위해 배우는 TypeScript 기초는 다른 곳에도 적용할 수 있습니다.\n\n## Observable (RxJS)\n\nRxJS 자체가 Angular 외의 다른 것에 사용되지는 않을 수 있습니다. 그런 경우에는 비용으로 간주될 수 있습니다. 그러나 Observable 또는 Observer 패턴은 다양한 상황에 적용할 수 있습니다.\n\n\n\n또한 Android 및 iOS와 같은 모바일 앱을 개발할 때 RxJava 및 RxSwift와 같은 Rx 패밀리를 때때로 도입합니다. 플랫폼 간 개발 프레임워크인 Flutter에서 사용되는 Dart도 Observable과 유사한 Stream 메커니즘을 포함하여 언어 표준에 내장되어 있습니다.\n\n반응형 프로그래밍 패러다임에서 자주 발생하는 패턴이므로, Angular의 RxJS를 반응형 프로그래밍의 입문으로 간주한다면 자산으로 고려할 수 있습니다.\n\nAngular를 시작하는 데 필요한 모든 것이 자산입니다. 웹 개발에 처음 입문했더라도 Angular를 통해 습득한 기술은 미래에 도움이 될 것입니다. 시간을 쓸 가치가 있으므로 걱정할 시간이 있다면 한번 시도해 보세요.\n\n## Angular 학습 비용 (초급에서 중급)\n\n\n\n시작했더라도 배울 것이 많아요. Angular를 배우는 것은 정말 비용이 많은 공부죠. Angular에 특화된 요소에는 Component/Directive, 의존성 주입, 라우팅 등을 알아야 해요. 또한, 현대 웹 개발의 다른 측면으로는 상태 관리, 유닛 테스팅, 컴포넌트 설계, 성능 등이 있어요.\n\n당연히, 현대 웹 개발에 필요한 기술을 일반적인 자산으로 생각할 수 있어요. 여기서 Angular에 특화된 요소들을 좀 더 자세히 살펴보겠어요.\n\n## Component/Directive\n\nAngular의 Component, Directive 및 Template 메커니즘은 다른 용도로 이전할 수 없으며, 안타깝게도 대부분은 비용이 발생할 거예요. 하지만 모든 것이 그렇지는 않아요. 여기서 주의해야 할 것은 Web Components입니다.\n\n\n\nAngular의 컴포넌트는 Web Components 기술을 모델로 삼았어요. 컴포넌트에는 Custom Elements와 같이 태그가 있고, 내부 CSS는 Shadow DOM처럼 캡슐화돼 있어요. 기본 설정은 이중화된 Scoped CSS지만, 네이티브 Shadow DOM을 사용하도록 지시할 수도 있어요.\n\n더불어, Angular v7에서 소개된 Angular Elements를 사용하면 Angular 컴포넌트를 Custom Elements로 변환할 수 있어요. 커스텀 요소로 내보내면 프레임워크에 관계없이 어디에서나 사용할 수 있어요.\n\nAngular 컴포넌트는 Web Components 기술을 배우는 기회로 활용할 수 있을 뿐만 아니라 실제로 Web Components를 활용하는 응용 프로그램을 개발하는 도구로 활용할 수도 있어요. 이점을 고려해 Angular에 투자하는 것은 틀림없는 선택이 될 거예요.\n\n## 의존성 주입\n\n\n\n웹 프론트 엔드에서는 작은 부분이지만, 의존성 주입은 서버 측 언어에서 흔히 사용되는 기술입니다. 이미 의존성 주입을 배운 사람들에게는 Angular에서 알려진 의존성 주입보다 장벽이 낮아질 가능성이 더 높습니다.\n\n또한, TypeScript의 유형 정보를 사용하는 선언적 DI 시스템은 매우 칭찬받고 있으며, Angular 이외의 곳에서도 사용하기 위해 모방 메커니즘이 만들어진 경우가 있습니다. InversifyJS와 NestJS가 그 예시입니다. 이 관점에서도 총 비용이라고 말할 수 없습니다.\n\n## 라우팅\n\nAngular 라우팅은 프레임워크와 강하게 연관된 부분이므로 Angular 이외의 것으로 전환하는 것은 쉽지 않을 것입니다. 이것을 비용으로 처리하면서 학습해 보세요.\n\n\n\nAngular을 배우는 비용은 초보자에서 중급으로 스킬을 향상할수록 증가합니다. 그러나 중급 수준에 도달하면 응용 프로그램을 고려하는 데 더 많은 시간을 보내게 될 것입니다.\n\n당신은 컴포넌트 디자인, 테스트 디자인, Components/directives 활용 및 의존성 주입에 대해 생각하기 시작할 것입니다. 확장 가능성과 생산성을 향상시키는 수단으로 사용할 때, Angular을 손발처럼 사용하고 응용 프로그램에 집중할 수 있다는 것은 당신이 중급 장벽을 넘었음을 나타낸다는 신호입니다.\n\n## 결론: Angular을 배우는 비용이 높은가요?\n\n네, 저렴하지 않습니다. 응용 프로그램 개발의 최단 경로였다면 훨씬 저렴한 프레임워크로 배울 수 있었을 것입니다. 그러나 Angular는 웹 표준 및 생태계와 일치하는 미래 지향적 스택을 선택했습니다.\n\n\n\n이를 이루기 위해 어떤 학습을 해야 할 것입니다. 이 학습은 부수적으로 느껴질 수 있지만, 그 중 많은 부분이 자산이 될 것입니다. 습득한 자산을 기반으로 학습함으로써, 더욱 중요한 자산이 되어 여러분의 스킬을 복리로 향상시킬 수 있을 것입니다.\n\n극단적으로 말하자면, 수익이 비용을 웃돌 정도라면 비용이 어느 정도 높더라도 지불할 가치가 있습니다. 그러나 현실적으로는 수익이 발생할지 여부에 대해 불확실성이 있기 때문에 망설이게 됩니다. 하지만 그런 경우에는 리스크를 헤지하는 것을 고려해야 합니다. 실패하더라도, 일부 자산이라도 남아있다면 완전한 손실보다는 낫습니다. Angular 기술을 활용하면 많은 자산을 보호하고 리스크를 헤징할 수 있습니다.\n\n또한 커뮤니티가 학습 비용을 줄이도록 허용합니다. 여러분의 뒤를 이어서 누군가가 다른 이에게 이어풀 수 있도록 도움이 되는 지식을 남길 수 있습니다. 습득한 지식을 남기면 미래에 누군가에게 도움을 줄 수도 있습니다. 학습 비용을 평가할 때, 개방적인 커뮤니티의 존재를 고려해야 합니다.\n\n# Stackademic\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png"},"coverImage":"/assets/img/2024-05-13-HowExpensiveItIstoLearnAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs에서 프로세스와 스레드 이해하기","description":"","date":"2024-05-13 00:19","slug":"2024-05-13-UnderstandingProcessesandThreadsinNodejs","content":"\n\n\n![Understanding Processes and Threads in Node.js](/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png)\n\nNode.js는 주로 단일 쓰레드 이벤트 루프 모델에서 작동합니다. 이는 코드가 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 Node.js는 또한 libuv와 같은 라이브러리를 통해 파일 읽기와 같은 I/O 작업과 같은 특정 작업을 백그라운드 쓰레드로 제공합니다. 이러한 백그라운드 쓰레드는 파일 I/O, 네트워크 요청 및 DNS 조회와 같은 작업을 처리하여 주 쓰레드가 다른 이벤트를 계속 처리할 수 있도록 합니다.\n\n# 프로세스\n\n프로세스는 운영 체제에서 실행 중인 프로그램입니다. 각 프로세스는 자체 메모리를 가지며 다른 실행 중인 프로그램의 메모리에 접근할 수 없습니다. 무한 루프가 있는 노드 프로그램을 만들어 실행했을 때 종료되지 않도록 만들어 봅시다.\n\n\n\n`process.js` 라는 파일을 만들어서 다음 코드를 입력해 주세요:\n\n```js\nconst process_name = process.argv.slice(2)[0];\nlet count = 0;\nwhile (true) {\n  count++;\n  if (count === 200 || count === 400) {\n    console.log(`${process_name}: ${count}`);\n  }\n}\n```\n\n다음 명령어를 사용하여 이 프로그램을 실행해 봅시다. Node.js 명령어를 사용해주세요:\n\n```js\nnode process.js A \u0026\n```\n\n\n\nA는 프로그램에 전달되어 process_name 변수에 저장되는 명령행 인수입니다. 끝의 \u0026는 Node 프로그램을 백그라운드에서 실행할 수 있게 해서 쉘에서 더 많은 명령을 입력할 수 있도록 합니다.\n\n```js\n출력\n[1] 15228\nA: 200\nA: 400\n```\n\n숫자 7754는 운영 체제가 할당한 프로세스 ID입니다. A: 200 및 A: 400은 프로그램의 출력입니다.\n\nnode 명령을 사용하여 프로그램을 실행할 때(사용하는 것이 Node.js를 가정합니다), 프로세스가 생성됩니다. 운영 체제는 프로그램을 위한 메모리를 할당하고, 컴퓨터 디스크에서 프로그램 실행 파일을 찾아 메모리에 로드하는 작업 등을 처리합니다. 이후, 프로그램에 프로세스 ID(PID)를 할당하고 실행을 시작합니다. 이 단계에서 프로그램이 프로세스가 됩니다.\n\n\n\nNode 프로세스를 빠르게 요약하려면:\n\n```js\nps |grep node\n```\n\n```js\n출력\n15228 pts/1    00:00:15 node\n```\n\n하나의 프로그램에서 여러 프로세스를 만들 수 있습니다. 예를 들어, 다음 명령을 사용하여 서로 다른 인수로 세 개의 추가 프로세스를 만들고 백그라운드에 넣을 수 있습니다:\n\n\n\n```js\nnode process.js B \u0026 node process.js C \u0026 node process.js D \u0026\n```\n\n위 명령을 실행한 후에 출력은 아래와 유사할 수 있지만 순서가 달라질 수 있습니다:\n\n```js\nOutput:\n[1] 15925\n[2] 15926\n[3] 15927\nB: 200\nC: 200\nB: 400\nD: 400\nC: 400\nD: 400\n```\n\n출력을 주의 깊게 살펴보면 실행 순서가 고정되어 있지 않다는 것을 알 수 있습니다. B, C, D 순으로 시작했지만 다른 순서로 끝날 수 있습니다. 이 동작의 이유는 OS가 각 프로세스를 실행할 때 결정하는 스케줄링 알고리즘 때문입니다.\n\n\n\n단일 코어 머신에서는 프로세스가 동시에 실행됩니다. 이것은 OS가 프로세스 간을 일정 간격으로 전환하는 것을 의미합니다. 예를 들어, 프로세스 D가 일정 시간 동안 실행되고 나서 그 상태가 어딘가에 저장되고 OS가 프로세스 B를 실행할 때까지 일정 시간을 예약합니다. 이 작업은 모든 작업이 완료될 때까지 계속해서 번갈아가며 반복됩니다. 결과적으로 각 프로세스가 완료된 것처럼 보일 수 있지만 실제로는 OS 스케줄러가 계속해서 그 사이를 전환합니다.\n\n4코어(다중 코어) OS에서는 OS가 각 프로세스를 동시에 각 코어에서 실행하기 위해 예약합니다. 이를 병렬 처리라고 합니다. 그러나 4개의 프로세스(총 8개 프로세스)를 생성하면 각 코어가 완료될 때까지 두 개의 프로세스를 동시에 실행합니다.\n\n현재 실행 중인 모든 Node 프로세스를 kill 명령어로 중지하려면:\n\n```js\nsudo kill -9 `pgrep node`\n```\n\n\n\n# 쓰레드\n\nNode.js의 쓰레드는 프로세스와 유사하지만, 하나의 프로세스의 메모리 내에서 작동합니다. 프로세스는 자체 메모리 공간을 갖지만, 각 쓰레드는 부모 프로세스의 메모리를 공유합니다. Node.js에서 프로세스를 생성할 때 worker_threads 모듈을 사용하여 JavaScript 작업을 동시에 실행할 수 있는 여러 쓰레드를 생성할 수 있습니다. 쓰레드는 메시지 전달을 통해 서로 통신하거나 프로세스의 메모리에서 데이터를 공유하여 작동합니다. 프로세스와는 달리 쓰레드를 생성하는 것은 운영 체제에서 추가적인 메모리를 필요로하지 않아 가벼우며 작업을 병렬로 실행하는 데 효율적입니다.\n\n쓰레드를 실행할 때, 그들은 프로세스와 유사하게 작동합니다. 단일 코어 시스템에서 다중 쓰레드가 있는 경우, 운영 체제는 정기적으로 그들 사이를 전환하여 각 쓰레드가 단일 CPU에서 직접 실행될 수 있도록 합니다. 반면에, 다중 코어 시스템에서는 운영 체제가 모든 코어에 걸쳐 쓰레드를 스케줄링하여 JavaScript 코드가 동시에 실행되도록 합니다. 사용 가능한 코어보다 더 많은 쓰레드가 생성된 경우, 각 코어는 여러 쓰레드를 동시에 처리하여 리소스 사용을 최적화합니다.\n\n# 숨겨진 Node.js의 쓰레드\n\n\n\nNode.js는 종종 \"멀티스레드\"라고 불리는데, 이는 입력/출력(I/O) 작업을 더 효율적으로 처리하기 위해 추가 스레드를 활용하기 때문입니다. 작동 방식은 다음과 같아요:\n\n소개에서 설명한 대로, JavaScript 자체는 단일 스레드이므로 한 번에 한 가지 작업을 처리합니다. 프로그램이 파일을 읽거나 네트워크 요청을 하려고 할 때, 이러한 작업이 끝날 때까지 대기하여 주 스레드를 차단시킬 수 있습니다.\n\n그러나 Node.js는 libuv 라이브러리를 구현하여 4개의 추가 스레드를 Node.js 프로세스에 제공합니다. 이러한 스레드를 사용하여 I/O 작업이 따로 처리되며, 작업이 완료되면 이벤트 루프는 해당 I/O 작업에 연결된 콜백을 마이크로태스크 큐에 추가합니다. 주 스레드의 호출 스택이 비어있을 때, 콜백이 호출 스택에 푸시되어 실행됩니다. 명확히 하자면, 주어진 I/O 작업에 대한 콜백이 병렬로 실행되지는 않지만, 파일을 읽거나 네트워크 요청하는 작업 자체가 스레드의 도움으로 병렬로 실행됩니다. I/O 작업이 끝나면 해당 콜백이 주 스레드에서 실행됩니다.\n\n이 4개의 스레드 외에도 V8 엔진은 자동 가비지 수집과 같은 작업을 처리하기 위한 추가 2개의 스레드를 제공합니다.\n\n\n\n노드 프로세스마다 총 일곱 개의 스레드가 있다는 내용입니다. 우리가 process.js 파일을 다시 실행하고 백그라운드에서 돌리는 것으로 이를 확인해보겠습니다:\n\n```js\nnode process.js A \u0026\n```\n\n이제 스레드를 확인하기 위해 top 명령어를 사용하여 프로세스 ID를 전달하겠습니다.\n\n```js\ntop -H -p 19821\n```\n\n\n\n위의 명령을 실행하면, 출력물은 다음과 유사할 것입니다:\n\n![Image](/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_1.png)\n\n출력물에서 보듯이, Node.js 프로세스에는 총 일곱 개의 스레드가 있습니다: 자바스크립트를 실행하는 주 스레드 하나, 네 개의 Node.js 스레드, 그리고 두 개의 V8 스레드가 있습니다.","ogImage":{"url":"/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-UnderstandingProcessesandThreadsinNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요","description":"","date":"2024-05-13 00:18","slug":"2024-05-13-ThisTypeScriptProblemwillSharpenyourMind","content":"\n\n\n![이미지](/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png)\n\nTypeScript는 데이터를 강화하고 깨끗한 코드를 개발할 수 있게 해 주는 환상적인 도구입니다.\n\n오늘은 Mapped Types의 사용을 통해 현실적인 문제를 해결해 보겠습니다.\n\n그럼, 더 이상 미루지 말고 지금 바로 시작해 보겠습니다!\n\n\n\n## 문제\n\n여기서는 국가 코드와 통화 간의 매핑을 나타내기 위해 country-to-currency 패키지를 사용하고 있습니다. 다음과 같이 국가 코드와 통화 간의 매핑을 표현합니다:\n\n```js\nimport countryToCurrency, {\n  Currencies,\n  // 이것은 이해하기 쉬워 보이기 때문에\n  // `CountryCodes`로 이름 변경되었습니다.\n  Countries as CountryCodes,\n} from \"country-to-currency\"\n\n// 가독성을 위해 정의됨\ntype CountryToCurrency = typeof countryToCurrency\n\n// type Currencies = \"GBP\" | \"USD\" ...\n// type CountryCodes = \"GB\" | \"US\" ...\n// type CountryToCurrency = { GB: \"GBP\", US: \"USD\" ... }\n```\n\n입력 통화에 따라 특정 국가 코드를 반환하고, 동시에 유형 안전성을 유지할 수 있으면 좋을 것 같습니다.\n\n\n\n내가 무슨 말을 하는지 아래 코드를 통해 설명해보겠어:\n\n```js\ntype Result = CountryCodesFromCurrency\u003c\"GBP\"\u003e\n\n// 결과 타입: \"GB\" | \"GG\" | \"IM\" | \"JE\"\n```\n\n더 잘 이해할 수 있도록 문제를 다이어그램을 이용해 시각화해볼게:\n\n![이 타입스크립트 문제가 당신의 머리를 더 날카롭게 만들 것입니다](/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_1.png)\n\n\n\n우리는 기본적으로 통화를 해당 국가 코드로 역지도하는 작업을 하고 있어요.\n\n## 해결책\n\n이 작업을 Mapped Types를 사용하여 우아하게 처리할 수 있는 해결책이 있다는 것을 알게 되었어요.\n\n```js\n// 여기에 `Mapped Type`의 기본 예제가 있어요\n// 이것은 타입을 가져와서 모든 값을 부울 값으로 변경할 거에요.\n// 키는 그대로 유지한 채로요.\n\ntype OptionsFlags\u003cType\u003e = {\n  [Property in keyof Type]: boolean;\n};\n```\n\n\n\n화폐에서 국가 코드로의 역매핑을 달성하려면 다음과 같은 논리를 따라야 합니다:\n\n- Mapped 형식을 정의합니다.\n- CountryToCurrency 매핑에서 각 키 (국가 코드)에 대해 값을 우리의 입력 ThisCurrency와 일치하는지 확인합니다.\n- 일치하는 경우 해당 속성을 유지합니다.\n- 일치하지 않는 경우 키 유형을 never로 설정하여 이 속성을 제거합니다.\n\n그리고 이 작업을 수행하기 위한 코드는 다음과 같습니다:\n\n```js\n// 이해하지 못하면 아래에서 설명하는 코드 블록을 참조하세요.\ntype FilterMappingsFor\u003cThisCurrency extends Currencies\u003e = {\n  [CountryCode in keyof CountryToCurrency \n    as CountryToCurrency[CountryCode] extends ThisCurrency \n    ? CountryCode : never]: CountryToCurrency[CountryCode]\n}\n```\n\n\n\n- 이통화에 대한 국가 코드를 원하는 필터 매핑을 정의하였습니다.\n- 각 CountryCode 키를 반복합니다.\n- 각 CountryCode에 대해 해당하는 통화(CountryToCurrency[CountryCode])와 입력값 ThisCurrency를 비교합니다.\n- 통화가 일치하는 경우 현재 속성을 유지합니다.\n- 일치하지 않는 경우 해당 키를 never로 설정하여 현재 속성을 효과적으로 제거합니다.\n\n거의 다 왔어요!\n\n현재 FilterMappingsFor`ThisCurrency` 유형은 올바른 매핑을 반환하지만 우리는 국가 코드만 필요합니다.\n\n이제 새로운 유형 CountryCodesFromCurrency를 정의하여 필터된 매핑에서 모든 키를 추출합시다:\n\n\n\n```js\n// FilterMappingsFor 함수는 나라 코드와 통화에 대한 올바른 키-값 쌍을 반환하기 때문에,\n// 이 새로운 타입은 우리가 원하는 것만 추출할 것입니다; 나라 코드입니다.\ntype CountryCodesFromCurrency\u003cThisCurrency extends Currencies\u003e =\n  keyof FilterMappingsFor\u003cThisCurrency\u003e\n```\n\n마지막으로, 다음과 같이 새로운 타입 Result1과 Result2를 정의하여 이를 테스트할 수 있습니다:\n\n```js\ntype Result1 = CountryCodesFromCurrency\u003c\"GBP\"\u003e\ntype Result2 = CountryCodesFromCurrency\u003c\"NIO\"\u003e\n\n// 결과1: \"GB\" | \"GG\" | \"IM\" | \"JE\"\n// 결과2: \"NI\"\n```\n\n# 추천 기사\n\n\n\n\n# 제휴사\n\n- Figma 홈: 제 모든 프로젝트에서 사용하는 UI 디자인 도구입니다.\n- Figma 프로페셔널: 필요한 모든 UI 디자인 도구가 모두 이곳에 있습니다.\n- FigJam: 직관적인 다이어그램 및 브레인스토밍으로 마음을 자유롭게 펼쳐보세요.\n\n- Notion: 제 인생 전체를 조직하는 데 사용하는 도구입니다.\n- Notion AI: ChatGPT를 능가하는 AI 도구로 Notion 작업을 최적화해줍니다.\n\n# 참고문헌\n\n\n\n- TypeScript Mapped Types 문서\n- country-to-currency package","ogImage":{"url":"/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png"},"coverImage":"/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 PWA 우리가 지금 어디에 있는지","description":"","date":"2024-05-13 00:17","slug":"2024-05-13-PWAsOniOSWhereWeAreNow","content":"\n\n애플이 단 하나의 앱 스토어 대안을 없애려는 노력의 혼란스러운 세부 내용\n\n![이미지](/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png)\n\niOS 17.4에서 완전히 막아버리면서 Progressive Web Apps (PWA)에 초토화를 일으킨 애플은 전 세계 개발자들을 좌절시키고 혼란스럽게 만들었습니다. 최근 PWA 지원을 개선한 후에도 그들의 이상한 방향전환 때문뿐만 아니라 애플이 우리에게 남긴 상황이 더욱 놀랍기 때문입니다.\n\n이 기사에서 그 혼란을 해소하기 위해 노력하겠습니다.\n\n\n\n## 유럽 연합에서만 해당\n\n애플이 iOS 17.4 베타 1에서 PWA를 망가뜨렸다는 소문이 퍼지자, 혼란스러운 개발자들은 문제가 있는 버전을 실행하는 iPhone 시뮬레이터의 화면 녹화를 공유하기 시작했어요. 거기에서는 여전히 PWAs가 설치되고 문제없이 돌아가고 있었죠.\n\n하지만 EU에서 실제 iPhone을 실행시키면 이러한 상황이 아니었어요.\n\n애플은 DMA 규정을 준수하기 위해 이 변경을 EU에만 제한시켰으며, 지오펜싱을 통해 이를 이룩했어요. SIM 카드를 사용자의 위치를 결정하는 데 사용하며, 소프트웨어 기반 시뮬레이터에는 SIM 카드가 없기 때문에 이 문제가 나타나지 않을 거예요. EU에서 새 iPhone을 SIM 카드 없이 실행하면 PWAs는 여전히 잘 작동하며, 오래된 iPhone의 SIM 카드를 빼서 24시간 동안 비행 모드로 둔 채로도 문제 없이 돌아갈 거라고 보고됐어요.\n\n\n\n어쨌든, 문제를 경험하려면 유럽 연합(EU) 국가에 위치한 SIM 카드가 장착된 진짜 아이폰이 필요합니다.\n\n## 설치된 PWA는 이제 책갈피와 같습니다\n\n또 다른 혼란의 요소는 iOS 17.4에서 여전히 웹 앱을 \"설치\"할 수 있다는 것입니다. 즉, 사용자의 홈 화면에 아이콘이 배치되지만 여기서 끝납니다.\n\n아이콘을 클릭하면 앱이 브라우저 크롬 없이 독립적인 PWA로 열리지 않고 일반 웹사이트처럼 열립니다. 사실, 홈 화면에 추가할 때 PWA가 아닌 웹 사이트는 어떻게 열리는지를 보여줍니다. 즉, \"설치된\" 웹 앱이 실제로 설치된 것이 아니라 홈 화면에 책갈피로 추가된 것임을 의미합니다.\n\n\n\n현재 iOS에서 PWA를 설치할 수 있는 브라우저는 모두 뒷단에서 Webkit 브라우저이므로 이것이 사실입니다.\n\nPWA가 전체 화면 독립형 앱처럼 표시되게 하는 것은 `manifest.json` 파일의 `\"display\": \"standalone\"` 속성입니다. `manifest.json` 파일이 없는 웹사이트는 홈 화면에 추가되어 아이콘을 클릭하면 다른 웹사이트처럼 브라우저에서 열립니다. 만약 `manifest.json` 파일에 `\"display\": \"standalone\"`이라는 속성이 있다면, iOS 17.4에서는 이것이 간단히 무시되고 PWA가 책갈피로 줄어듭니다.\n\nUI가 완전히 망가지는 것 외에도 중요한 기능이 비활성화됩니다.\n\n## 더 이상 푸시 알림이 없음\n\n\n\n애플은 iOS 16.4에서 약 1년 전에 푸시 알림 지원을 추가했어요. 그들의 구현 방식이 최적이 아닌 채로, 푸시 알림은 설치된 PWA에 대해서만 지원되죠.\n\n즉, 스탠드얼론 앱처럼 실행되는 설치된 PWA입니다.\n\n이제 iOS에서 \"설치된\" 웹 앱은 더 이상 스탠드얼론 앱이 아닌 웹 사이트의 즐겨찾기일 뿐이라 푸시 알림과 배지가 더 이상 지원되지 않아요.\n\n미안해요, 친구야.\n\n\n\n## 더 이상 지속적인 저장 공간이 없어요\n\n최근에 Safari에서 iOS에 지속적인 저장 공간이 추가되었지만, 그것은 독립 실행 모드로 실행되는 설치된 PWA에만 해당되므로 해당 기능은 이제 안녕히 려드렸다고 말할 수 있어요.\n\nPWA는 예전에는 7일간 상호 작용되지 않은 웹 앱에 의해 저장된 데이터가 제거된다는 Apple의 제재 정책에서 제외되었지만, 이제 iOS 17.4에서 PWA가 웹사이트 북마크로 변환됨에 따라 더이상 해당되지 않게 되었어요.\n\n이것으로 인해 PWA는 완전히 쓸모없게 되었고, 아마도 Apple이 신중히 PWA를 위해 준비한 가장 큰 낙인일 것입니다.\n\n\n\n## 보안 문제?\n\n애플은 비-Webkit 브라우저를 통해 설치된 PWA가 보안 위험이라고 주장합니다. 왜냐하면 iOS는 Webkit 보안 아키텍처를 직접 구축하여 PWA를 지원하며, 이 보안 통합은 카메라에 액세스하려는 앱이 권한 프롬프트를 표시하고 격리된 저장 공간을 제공하는 것을 처리합니다.\n\niOS에서 비-Webkit 브라우저는 이러한 보안 통합이 없기 때문에 해당 브라우저를 통해 PWA를 설치하는 것은 안전하지 않으며, 사용자의 허락 없이 PWA가 설치되는 결과를 초래할 수 있습니다.\n\n물론 이것은 엉터리입니다. 왜냐하면 애플은 (맥OS에서 수년간 보여온 것처럼) 이러한 통합을 구축할 수 있지만 하고 싶지 않기 때문에 그렇습니다. 이러한 통합을 구축하도록 강제당하지 않기 위해 기술적 연기벽을 세우고 빠져나가려고 노력하지만 (하지만 그렇게 보이지 않습니다).\n\n\n\n모든 브라우저의 중요한 핵심 기능 중 하나는 권한과 데이터를 출처별로 분리하는 것이며, 애플이 자사 앱 스토어 독점을 보호하기 위해 만들어낸 것 외에는 보안 문제가 없습니다.\n\n애플은 자사 앱 스토어에 대한 합리적이지 않게 높은 수수료와 임의의 입장 기준에서 자유로운 유일한 대안을 없애려고 하고 있습니다.\n\n그들이 그렇지 않다고 생각하게 속지 마세요.\n\n현대 웹 플랫폼의 새로운 기능, 진행형 웹 앱(PWA), 웹 컴포넌트, 그리고 평이한 영어로 설명된 컨텐츠를 주간으로 업데이트하는 제 이메일 목록 '현대 웹 주간(Morden Web Weekly)'에 가입해주세요!","ogImage":{"url":"/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png"},"coverImage":"/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png","tag":["Tech"],"readingTime":3},{"title":"문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다","description":"","date":"2024-05-13 00:16","slug":"2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF","content":"\n\n만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:\n\n만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.\n\n# JavaScript는 duck-typed입니다\n\n![error](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png)\n\n\n\n자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.\n\nTypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.\n\n# TypeScript 구조적 유형 모델\n\n다음 인터페이스와 함수를 고려해보세요:\n\n\n\n```js\n인터페이스 Person {\n  firstName: string;\n  lastName: string;\n}\n\nfunction getFullName(person: Person): string {\n  return `${person.firstName} ${person.lastName}`;\n}\n```\n\n이제 다른 인터페이스를 만들어 봅시다:\n\n```js\n인터페이스 계정 {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n```\n\n만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?\n\n\n\n```js\nconst francesco: 계정 = { id: 123, email: 'borzifrancesco@gmail.com', firstName: 'Francesco', lastName: 'Borzì' };\n\nconst result = getFullName(francesco);\n```\n\n놀랍게도… 이건 오류가 발생하지 않아요!\n\ngetFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.\n\n다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).\n\n\n\n하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.\n\n## 구조적 타이핑의 결과\n\n함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 \"봉인된\" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.\n\n이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:\n\n\n\n```js\n인터페이스 GemCollection {\n  blueCount: number;\n  greenCount: number;\n  redCount: number;\n  yellowCount: number;\n  // purpleCount: number; // 나중에 구현 예정\n}\n```\n\n이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  let totalGemsCount = 0;\n\n  for (const key of Object.keys(gemCollection)) {\n    totalGemsCount += gemCollection[key];\n  }\n\n  return totalGemsCount;\n}\n```\n\n논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:\n\n\n\n\n![Issue Screenshot](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png)\n\n이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.\n\n우리의 함수는 다음과 같이 다시 작성되어야 합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  return gemCollection.blueCount\n    + gemCollection.greenCount\n    + gemCollection.redCount\n    + gemCollection.yellowCount;\n}\n```\n\n\n\n그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.\n\n# 구조적 타이핑의 장점\n\n구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.\n\n![이미지](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png)\n\n\n\n이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.\n\n또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:\n\n```js\nimport { SuperHttpClient } from '@some-library/http-client';\n\nfunction getGemsCollection(httpClient: SuperHttpClient, userId: number): GemCollection {\n  const gemsCollection = httpClient.get(`https://game.gems.org/users/${userId}/gems`) as GemCollection | undefined;\n\n  if (gemsCollection) {\n    return gemsCollection;\n  }\n\n  return {\n    blueCount: 0,\n    greenCount: 0,\n    redCount: 0,\n    yellowCount: 0,\n  };\n}\n```\n\n예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:\n\n\n\n```js\n인터페이스 HttpClient {\n  get: (query: string) =\u003e unknown;\n}\n\nfunction getGemsCollection(httpClient: HttpClient, userId: number): GemCollection {\n  // 구현 내용은 이전과 동일합니다\n}\n```\n\n저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.\n\n또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:\n\n```js\ndescribe('getGemsCollection', () =\u003e {\n  it('지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 스텁 보석 컬렉션을 준비합니다\n    const testCollection: GemCollection = {\n      blueCount: 2,\n      greenCount: 4,\n      redCount: 1,\n      yellowCount: 7,\n    };\n    // 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다\n    const testHttpClientWithGems = {\n      get: (_url: string) =\u003e testCollection,\n    };\n\n    // getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithGems, 10)).toEqual(testCollection);\n  });\n\n  it('지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다\n    const testHttpClientWithoutGems = {\n      get: (_url: string) =\u003e undefined,\n    };\n\n    // getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithoutGems, 10)).toEqual({\n      blueCount: 0,\n      greenCount: 0,\n      redCount: 0,\n      yellowCount: 0,\n    });\n  });\n});\n```\n\n\n\n새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.\n\n팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.\n\n# 결론\n\n- 자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;\n- 이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;\n- Structural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;\n- Structural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.\n\n\n\n## 참고 사항\n\nDan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.","ogImage":{"url":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"},"coverImage":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다","description":"","date":"2024-05-13 00:13","slug":"2024-05-13-Angularisnotforeveryoneandprobablynotforyou","content":"\n\n![이미지](/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png)\n\n2023년, Angular 팀은 커뮤니티에서 요청한 중요한 변경 사항들을 많이 반영했고, 정말 멋진 일이죠. 하지만 항상 그랬던 것은 아니었습니다.\n\n이 이야기에서 나는 4년 동안 Angular을 사용하면서 얻은 경험에 대해 이야기하고 싶습니다.\n\n우선, Angular은 애플리케이션을 개발하는 데 처음으로 선택할 기술이 되지 않아야 한다고 생각합니다.\n\n\n\n앵귤러가 발생시키는 문제와 개발자 및 팀 빌딩에 미치는 영향을 강조하고 싶어요. 이를 식별한 문제들에 대한 해결책도 제시하려고 해요. 이미 앵귤러를 사용하거나 사용하고 싶다면 도움이 될 거예요.\n\n아쉽게도 어떤 이유로 인해 일부 팀이나 회사들은 업그레이드를 미루는 경우가 있어요. 따라서 여기서 설명한 일부 문제는 여전히 관련이 있을 수 있어요.\n\n신입 개발자라면 이 글이 유용할 것이며 여러분이 첫 개발 스택을 선택하는 데 도움이 될 걸 거예요.\n\n# 편리함의 함정\n\n\n\n앵귤러는 라이브러리가 아닌 UI 프레임워크로 알려져 있어요. 앵귤러는 프론트엔드 애플리케이션 개발에 대한 자체 포괄적인 솔루션으로 위치하고 있어요. 앱마다 \"기술의 동물원\"같은 것은 없고, 모든 것이 일관되고 단조로운데, 이에는 단점도 있어요. 앵귤러가 제공하는 편의성에 익숙해지면, 나중에 그것들을 포기하기가 더 어려워질 수 있어요.\n\n## ReactiveForms\n\n한 때, 앵귤러 팀이 제안한 접근 방식, 폼과 해당 컨트롤을 HTML 템플릿과 JS 컨트롤러로 분리하는 것은 정말 폼 개발에 편리했던 것이 증명되었어요.\n\n그 문제는 다르네요. ReactiveForms에서 제공하는 유효성 검사에 의지하는 것에 너무 익숙해져서, HTML이 입력 필드를 유효성 검사하는 데 필요한 모든 속성을 제공한다는 것을 잊어버리곤 해요 — min, max, pattern, required, read-only 등.\n\n\n\n이 문제는 무엇인가요? — Angular을 넘어서면 ReactiveForms이 독립 라이브러리로 존재하지 않는다는 것을 알게 됩니다. 폼 개발 방법을 다시 배워야 할 것입니다 — 이벤트 (제출, 변경) 및 입력 필드 속성.\n\n## 애플리케이션 빌드\n\n애플리케이션 빌드를 사용자 정의할 필요가 없습니다. 그냥 \"build\" 또는 \"serve\" 명령을 실행하여 시작하면 됩니다. 빌더의 webpack.config.js 또는 vite.config.js 구성 파일을 보지 못할 것입니다.\n\n네 말씀하세요:\n\n\n\n- 어떻게 귀하의 애플리케이션이 구성되었나요?\n- 어떤 파일이 진입 지점인가요?\n- 어떤 도구가 귀하의 애플리케이션을 빌드하나요?\n- SCSS 파일이 CSS로 변환되는 방법은 무엇인가요?\n- HRM은 어떻게 작동하나요?\n\nAngular만 사용하면 애플리케이션을 빌드하는 기술을 키우는 성장 단계를 놓치게 될 거예요. Webpack, Gulp, Rollup, Vite, Esbuild 등에 대해 알지 못할 거예요. 만약 Angular 없이 HTML과 SCSS로 간단한 웹 페이지를 만들라고 하면, 아마 할 수 없을 거예요.\n\n## HTTP 클라이언트\n\n이것은 최근 XHR2 기능을 활용하여 Observable 패턴을 사용하는 XHR을 감싸주는 편리한 래퍼입니다. 이것을 통해 다중 매개변수로 쿼리를 생성하고, 쿼리의 진행 상황을 추적하며, 단 하나의 매개변수로 응답을 원하는 데이터 유형으로 변환할 수 있습니다.\n\n\n\n하지만 앵귤러 개발자로서 다음을 말할 수 있나요?\n\n- 네이티브 메서드(fetch 또는 XHR)를 사용하여 최근 HTTP를 처리한 적이 있나요?\n- 인터셉터를 사용하지 않고 전역적으로 요청과 오류를 처리할 수 있나요?\n- switchMap을 사용하지 않고 HTTP 요청을 되돌릴 수 있는 방법을 말할 수 있나요?\n- axios나 node-fetch 라이브러리를 알고 있나요?\n\n편의성은 좋지만, 앵귤러 없이 쿼리를 작성하는 방법을 알아야 합니다. 심지어 시니어 개발자도 부트스트랩 애플리케이션을 시작하기 전에 요청을 보내는 방법을 모르거나 RxJS.Ajax의 존재를 모르는 것에 놀라곤 합니다.\n\n요청과 응답의 본질에 대한 이해가 있어야 다음과 같은 작업을 수행할 수 있습니다:\n\n\n\n## 테이블을 마크다운 형식으로 변경\n\n- 에러 처리\n- 응답 분석\n- 요청 진행 상황 추적\n- FormData와 함께 작업\n\n# Zone.js\n\nAngular의 신기함과 골칫거리. Zone.js는 모든 브라우저 이벤트를 위임하고 그 후 Angular에게 알릴 도구로 소개되었습니다. 그 목적은? — 업데이트의 \"마법\"을 제공하기 위해서:\n\n- 마우스 클릭? — 업데이트\n- 요청 종료? — 업데이트\n- setTimeout 종료? — 업데이트\n\n\n\n전체 애플리케이션이 어떻게 업데이트되는지에 대해 생각해 본 적이 없죠. 그러나 이 프로세스를 이해하지 못하면 미래의 최적화에 큰 문제가 될 수 있습니다.\n\n루트 및 자식 존, 기본 및 OnPush, runOutsideAngular, ComponentsTree, ViewTree, Async-pipe 등 다양한 생각할 수 없는 주제와 라이브러리 변경 감지에 대한 글들이 많이 쓰였습니다.\n\n이 글들은 \"용기를 잡는 법\"을 이해하기 위해 필요한 것뿐입니다. 네, ChangeDetectorRef나 NoopZone를 통해 컴포넌트 및 애플리케이션 업데이트를 간접적으로 관리할 수 있지만, 이것은 편리함이 아니라 유지 관리 과제입니다.\n\n\n\n# 앵귤러는 RxJS를 제공했지만 어떻게 사용해야 하는지 알려주진 않았어요\n\n앵귤러에서 RxJS에 관한 가장 빈발한 주제는 무엇일까요? - 구독 관리와 메모리 누수입니다. 그리고 이게 아무 이유 없는 얘기가 아니에요.\n\n앵귤러에서 개발을 시작하는 개발자들은 Observable을 Promise처럼 then()으로 처리하려고 해요. 많은 멋진 코드와 좋지 않은 구현을 봤어요. RxJS에 대한 지식이 없으면 앵귤러에서 효과적으로 작업할 수 없기 때문에 강좌와 자료를 만드는 이유를 이해해요.\n\n일반적으로 알려진 앵귤러는 반응적인 접근이 아니라 스트림 접근에 관한 것이에요. 모든 값들은 '스트림'이에요. 스트림으로 생각하고 스트림과 어떻게 작업할지 알지 못한다면 어려움을 겪을 거에요.\n\n\n\n2024년에도 이런 주제들이 면접에서 확인됩니다:\n\n- 고차 연산자 — concatMap, mergeMap, switchMap, exhaustMap\n- 결합 연산자 — zip, forkJoin, combineLatest\n- 메모리 누수 모니터링\n- \"Hot\"과 \"cold\" Observables\n- takeUntil, takeWhile, takeUntilDestroyed(new)\n\n## RxJS의 사로잡힌 자\n\nAngular에서 스트림과 함수형 프로그래밍으로 마음가짐을 전환했다 하더라도, 모든 값이 스트림이 될 수 있는 것은 아니라는 점을 주의하세요.\n\n\n\n문제가 무엇인가요? — 기본형과 객체를 다루는 법을 까먹었나요? 이제는 필요하지 않은 값이 스트림에 있습니다. BehaviorSubject를 통해 모든 클래스 필드를 생성하려는 충동이 생길 것입니다. 이것은 큰 문제입니다. 이로 인해 여러 조합과 내부 구독을 가진 각 필드에 대해 10개 이상의 BehaviorSubject가 있는 상태 서비스의 많은 구현을 볼 수도 있습니다.\n\n# DI\n\n많은 개발자가 Angular를 선택하게 만드는 기능입니다. 하지만 스스로 발목을 쏘지 않는 방법을 알아야 합니다.\n\n## ProvidedIn과 사용하지 않는 코드\n\n\n\n@Injectable 데코레이터에서의 ProvidedIn 함수는 Angular에 서비스를 등록해야 하는 위치를 알려주는 용도로 만들어졌어요. 이를 통해 초기 스크립트의 크기를 최적화할 수 있었고, 필요하다면 사용되지 않는 서비스를 빌드에서 제거할 수도 있었죠. 이 접근 방식은 라이브러리 개발에 사용할 수 있어요. 여러분이 만든 라이브러리에서 다른 개발자가 얼마나 많은 서비스를 사용할지 모르는 경우에 유용해요.\n\n하지만 이 방식은 단일 앱을 갖는 통합형 저장소에는 적합하지 않아요. Angular가 불필요한 코드를 제거해주는 것은 좋지만, 코드베이스를 최신 상태로 유지하는 책임을 Angular에게 넘기게 된다는 문제가 있어요.\n\n## 제공의 마법\n\nProvidedIn은 모든 서비스를 자동으로 등록해주는데, 이 부분은 편리한 면이 있어요. 하지만 providedIn: root를 사용할 때 문제가 발생하기 시작해요.\n\n\n\n개발자들은 트리 쉐이킹 메커니즘에 매우 의지하고 있습니다. 이에 따라 응용 프로그램의 일부분에서만 사용되는 서비스도 리포지토리의 가장 깊은 곳에서 전역으로 등록합니다. 이렇게 하면 전역적인 요소를 만들어 리포지토리 구조를 파괴하게 된다는 점을 명심해주세요.\n\n## 서비스의 트리 쉐이킹은 코드의 트리 쉐이킹과 같습니다\n\n많은 사람들이 서비스의 트리 쉐이킹이 코드 전체에 적용되는 것으로 잘못 알고 있지만, 실상은 그렇지 않습니다.\n\nProvidedIn은 프로바이더 트리의 생성 및 그 안에 포함될 서비스의 수에만 영향을 줍니다. 최대로 절약할 수 있는 용량은 전체 빌드 중 10-15 kb로 매우 작은 값입니다.\n\n\n\n# 항상 현재 프론트엔드 기능의 뒤쳐지게 될 거에요\n\nAngular은 '프론트엔드 세계'에서 애플 제품으로 생각해야 합니다. 다른 브랜드들이 몇 달에 한 번씩 새로운 기능을 결합하고 개발하는 동안, 애플은 새로운 기능을 서둘러 추가하지 않고 제품을 연마다 조금씩 개선하는 것을 선호해요.\n\nAngular의 종속성이 닫힌 생태계를 가지고 있어, 어떤 종속성을 새로운 것으로 교체하는 것이 어려울 수 있어요. 중요한 것은 Angular 버전을 최신으로 유지해야 한다는 점이에요. 예를 들어, Angular 9에서 Typescript 5나 Webpack 5를 사용할 수 없어요 — 올바른 버전으로 업그레이드해 주세요. 업그레이드를 실패하거나 미룰 경우, 모든 기능이 그대로 지나가게 될 거에요.\n\nAngular 팀이 기대하는 기능이나 도구 지원을 추가하지 않기로 결정하면, 그대로 사용해야 할 수 있습니다. 영원히 무엇을 가지고 작업해야 할지도 모를 거에요.\n\n\n\n# 더 많은 사람 — 더 많은 아이디어 — 더 많은 해결책\n\nAngular는 현재 앱 개발을 위한 세 가지 가장 인기 있는 기술 중 하나입니다.\n\n만약 React나 Vue로 어플리케이션의 복제본을 구현하려고 한다면, 이 어플리케이션의 모든 종속성이 Angular에서는 대응하는 것이 없다는 것이 드러날 것입니다. 그것들은 존재하지 않거나 js 라이브러리에 대한 Ng-wrapper가 없거나 그런 래퍼가 있더라도 다른 기능을 가지고 있을 수 있습니다.\n\nReact나 Vue보다 커뮤니티가 작아서 이러한 도구들을 만들지 않았기 때문에 자체 솔루션을 구현하는 데 시간이 걸릴 것입니다.\n\n\n\n# 개발자 편의가 비즈니스보다 앞섭니다.\n\n인기 있는 도구와 Angular을 비교하는 모든 글과 토론은 내부 구현에 대해 이야기하지만 한 가지를 잊고 있습니다 — 성능, SEO, 빌드 크기 및 그 결과를 달성하는 데 소요된 시간이 동일할 때만 도구를 비교해야 한다는 것을 잊습니다.\n\n우선, 당신은 제품을 개발하는 대신 돈을 지급하는 비즈니스를 위해 일하고 있습니다. 최종 사용자는 제품을 누가 만들었는지, 몇 명이 만들었는지, 어떤 기술로 만들어졌는지는 모릅니다. 그가 중요하게 생각하는 것은 응답성이 뛰어나고 예상대로 작동하는 빠른 사이트입니다.\n\n\"모든 것을 갖췄다\"는 마인드셋으로 Angular을 선택하면 초기 개발 단계에 빠르게 진입할 수 있을 뿐입니다. 당신은 의도적으로 개발 옵션을 좁혀 선택해야 할 것이며 이제 Angular이 제공할 수 있는 것에 의존해야 합니다. 2018년이 아니라는 것을 명심하세요. 숙련된 개발자는 1~2시간 만에 프로젝트를 처음부터 만들 수 있고 미래 제품의 요구사항을 반영하는 도구 스택을 선택할 수 있습니다. 무언가 변경되면 어떤 부분이든 더 나은 것으로 대체할 수 있습니다.\n\n\n\n프론트엔드 개발자이시군요! 먼저 표 태그를 마크다운 형식으로 변경해주세요.\n\n그리고 Angular를 선택한다면, 도구의 인기와 개발자 수는 직접적으로 연관되어 있기 때문에 새로운 인재를 찾는 것이 더 어려워질 수 있다는 것을 염두에 두는 것이 좋습니다. 비즈니스 전략이 신속한 성장을 포함한다면, 후보자를 찾을 가능성을 높일 수 있는 보다 인기있는 도구를 살펴보세요.\n\n# Angular는 필요 없는 것을 사용하라고 제안합니다\n\n## Protractor\n\n이게 무엇인지 모른다면 괜찮아요. 이것은 최근까지 Angular 작업 공간을 생성할 때 설치되었던 e2e 테스트 도구입니다.\n\n\n\n이 솔루션을 사용한 개발자가 매우 적다는 것을 쉽게 짐작할 수 있습니다. 또한, 이 도구에 대한 문서, 안내서, 지침도 거의 찾아볼 수 없을 것입니다.\n\n일반적으로 저장소에 e2e 테스트가 필요하면 익숙한 Cypress나 Puppeteer 도구로 마이그레이션하는 방법을 찾았습니다.\n\n## Karma + jasmine\n\nAngular 패키지에서 기본적으로 제공되는 또 다른 도구입니다. Protractor와 달리 사용이 중단되지 않았으며 개발자들 사이에서 인기가 있습니다.\n\n\n\nJest는 종종 이 조합과 대조됩니다. 테스트 작성에는 특별한 차이가 없지만 구성 방식과 일반적인 작업 방식이 다를 수 있습니다.\n\nKarma + Jasmine을 사용하기 전에 몇 가지 질문에 답해 보세요:\n\n- Jest를 알고 대체 도구로 전환할 준비가 되었나요?\n- 테스트를 실행하기 위해 브라우저 기반 환경이 실제로 필요한가요?\n- Karma와 생태계를 사용자 정의할 준비가 되었나요?\n- CI/CD에서는 에이전트에 브라우저를 설치하여 Karma에서 테스트를 실행해야 한다는 것을 알고 계셨나요?\n\n## Angular Material\n\n\n\n기본적으로 내장된 종속성은 아니지만, 이 라이브러리를 우회할 수 없는 것은 정말 어렵습니다.\n\n개발자들과 팀들이 다른 UI 라이브러리 대신 Angular Material을 선택하는 주된 이유 중 하나는 공식 Angular 팀의 지원입니다. 다른 UI 라이브러리는 새로운 Angular 버전이 출시되길 기다리고 업데이트를 기다리지만, Angular Material은 거의 Angular과 동시에 출시됩니다. 이 시점에서는 Angular Material을 지지하는 어떤 주장도 없어지죠.\n\n익숙해지기까지 다소 복잡한 개발용 도구입니다:\n- 스타일링. 컴포넌트 스타일링을 추천하는 방식을 따르지 않으면 이 라이브러리와 별개의 문제가 됩니다. Angular Material은 css 선택자를 변경하거나 요소의 중첩 순서를 일방적으로 변경할 수 있으므로 이에 대비해야 합니다.\n- Angular 업그레이드. Angular Material 번들의 경우, Angular의 새 버전으로 처음 업그레이드하는 것은 불가능할 수 있습니다. 빌드를 가지고 있더라도 인터페이스가 원래 렌더링을 유지할 것이라는 보장은 없습니다. 그에 따라 회귀 또는 QA가 필요합니다. 이에 대한 리소스가 없는 경우, 모든 것을 개인적으로 직접 확인해야 할 준비가 필요합니다.\n- 컴포넌트의 사용자 정의 감소. Taiga-UI와 같은 다른 라이브러리는 각 엔티티를 사용자 정의할 수 있는 도구와 방법의 많은 목록을 제공하는 반면, 여기서는 컴포넌트를 처음부터 구현하거나 ViewChild를 사용하여 컴포넌트를 필요에 맞게 관리해야 할 것입니다.\n\n\n\n# Angular Universal\n\n저에게 있어서 Angular의 SSR을 사용하는 것은 컴포넌트 렌더링 버그를 고치는 게으른 방법입니다 (잊혀진 trackBy, ChangeDetection.Default, Critical CSS 등) 그리고 초기 빌드 크기도 통제하는 방법이에요.\n\nAngular Hydration이 추가되기 전인 16 버전 이전에는 Angular의 SSR 사용을 무의미하게 생각할 수 있어요.\n\n먼저 Angular은 대규모 기업 애플리케이션을 위한 도구에요. 랜딩 페이지, 포트폴리오 페이지 또는 다른 \"가벼운\" 앱을 만들 때 선택하는 것이 아니에요. Angular를 선택했다면, 최적의 SEO나 FCP를 가진 애플리케이션을 만드는 관점에서 출발하기 어렵겠네요. 이미 알고 있듯이 최종 Angular 빌드는 다른 라이브러리보다 크게 될 거라고 가정하고 시작하는 거죠.\n\n\n\n## SSR이 필요해질 때 언제든지 라인\n\n의외로도 당신의 Angular 애플리케이션이 SSR을 가지고 있지 않더라도 SSR을 위해 개발해야 합니다. 전역 API인 window를 포함하여 서버 환경에는 존재하지 않는 것들을 토큰화해야 합니다. 이 접근 방법에는 문제가 없지만, 이 사실을 알고 서로 지키는 Angular 개발자가 얼마나 되겠습니까?\n\n브라우저에서만 작동하는 기능이나 도구를 사용하는 경우, SSR을 추가하여 즉시 애플리케이션을 실행할 수 없게 됩니다. 현재 애플리케이션을 위해 SSR을 지원하는 과정에서 시간과 리소스를 낭비하게 되며, 여러 버그를 만들 수도 있습니다.\n\n## 유연성 제로\n\n\n\n이제 가장 최근에 소개된 Angular Hydration을 가지고 있지만, Qwik와 Resumability에 대해 배웠습니다. 이 지식을 활용하여 Angular 내에서 재현할 수 있을까요? — 아닙니다. 여러분의 경험을 모두 갖고 있더라도, Angular 팀이 Angular Universal에 대한 지원을 추가하기를 결정할 때까지 사용할 수 없습니다.\n\n# 결론\n\n각 개발자는 다른 개발자가 만든 다른 기술을 사용하는 소비자입니다. 가장 중요한 것은 자신이 편안한 느낌을 가질 수 있는 장소를 찾는 것입니다.\n\n첫 번째 스택을 형성할 수 있는 방향을 찾는 초보 프론트엔드 개발자라면, Angular를 포기하는 것이 더 나을 수 있습니다. 네이티브 JS 및 HTML 기능에 기반을 둔 React, Vue, Svelte 또는 기타 가벼운 UI 라이브러리를 선택하는 것이 더 낫습니다. 엄격히 규제된 종속성이 없기 때문에 특정 작업에 어떤 도구를 적용할지 스스로 결정할 수 있습니다. 이를 통해 할당된 작업의 범위 내에서 \"도구 평가\" 및 \"도구에 대한 요구 사항 형성\" 기술을 발전시킬 수 있습니다.\n\n\n\n\"React를 \"기술의 동물원\"이라고 말하기는 어렵습니다. 이미 React 주변에는 각각의 작업 유형에 대해 2~3개의 추천 도구가 형성되어 있습니다. 프로젝트마다 그들의 조합을 변경할 수 있지만, 응용 프로그램을 구축하는 아주 기본적인 방식은 변하지 않습니다. 또한 Angular와 마찬가지로 프로젝트 구조에 빨리 익숙해질 것입니다.\n\n합리적인 질문. \"Angular가 필요한가요\"? — 놀랍게도, 네요.\n\nSPA를 위해 과거에 Angular가 제공할 수 있던 것은 아직까지 아무도 반복할 수 없었습니다.\n\n다른 도구들보다 뒤처지고 여러 해 동안 문제를 겪음에도 불구하고, 개발자들은 강력한 솔루션을 즉시 가져오기 위해 Angular를 선택했습니다. 언제나 프로젝트에서 알고 있는 기술과 함께 작업을 해왔고, 이는 학습에 리소스를 낭비하지 않고 교차 기능 팀을 구축하는 데 도움이 되었습니다.\"\n\n\n\n만약 Angular 이전에 RxJS를 사용해 보았다면, 이것은 좋은 전이 보너스가 될 것입니다. 만든 모든 애플리케이션에 RxJS를 추가할 수 없었던 이유는 팀의 승인과 사용 사유를 정당화해야 했기 때문입니다. Angular는 RxJS의 사용을 권장하며 개발을 쉽게 만들기 위한 자체 연산자를 제공합니다.\n\nAngular로 전환하기 전에 재사용 가능한 솔루션을 개발하면서 오류 및 기술을 경험해보는 것이 좋습니다. 사용성을 느끼기 위해 Angular로 이주하기 전에 몇 가지 경험이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"},"coverImage":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png","tag":["Tech"],"readingTime":10},{"title":"TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험","description":"","date":"2024-05-13 00:10","slug":"2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper","content":"\n\n![My experience learning Rust as a TypeScript developer](/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png)\n\n많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.\n\n저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.\n\n저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...\n\n\n\n# 왜 Rust를 선택해야 할까요?\n\n저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.\n\nRust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.\n\nRust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.\n\n\n\n# 러스트 배우는 방법\n\n다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.\n\n다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.\n\n러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.\n\n\n\n유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.\n\n본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.\n\n# 컴파일러\n\nRust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!\n\n\n\nTypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.\n\n이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).\n\n그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.\n\n오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!\n\n\n\n# 유형 시스템\n\n모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.\n\n그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.\n\n그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 \u0026str과 String으로 충분히 커버돼 있어요!)\n\n\n\n물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.\n\n## 메모리 할당\n\nTypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.\n\nRust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.\n\n\n\n예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.\n\n```rust\nlet small_int = \"127\".parse::\u003ci8\u003e().unwrap();\n```\n\nparse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:\n\n```rust\nlet small_int: i8 = \"127\".parse().unwrap();\n```\n\n\n\n이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 \"128\"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.\n\n타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.\n\n```js\nconst x = 10 as unknown as string;\n```\n\n이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!\n\n\n\n그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.\n\n# 오류 처리\n\n다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.\n\n```js\nlet parsed_int = submitted_str.parse::\u003ci32\u003e().unwrap();\n```\n\n\n\n여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.\n\n우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e panic!(\n        \"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}\",\n        error\n    ),\n};\n```\n\n또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:\n\n\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e 0,\n};\n```\n\n이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .\n\n물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.\n\n또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.\n\n\n\n# 선택적 값\n\nRust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.\n\n```js\ninterface User {\n  _id: string;\n  name?: string;\n}\n\nfunction sayHello(user: User) {\n  return `Hello ${user.name}!`;\n}\n```\n\n이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!\n\n\n\n하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n    let name = user.name;\n    format!(\"Hello {name}!\")\n}\n```\n\n위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n  let name: String = match user.name {\n    Some(name) =\u003e name,\n    None =\u003e \"world\".to_string(),\n  };\n\n  format!(\"Hello {name}!\")\n}\n```\n\n\n\n한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 \"Hello undefined\"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.\n\n이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.\n\n# 소유권과 대여\n\n마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.\n\n\n\nTypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.\n\n```js\nconst arrayToBeMutated: string[] = [\"d\", \"c\", \"b\", \"a\"];\nconst arrayToBeCloned: string[] = [\"d\", \"c\", \"b\", \"a\"];\n\narrayToBeMutated.sort();\narrayToBeCloned.toSorted();\n\nconsole.log(arrayToBeMutated);  // [\"a\", \"b\", \"c\", \"d\"]\nconsole.log(arrayToBeCloned);   // [\"d\", \"c\", \"b\", \"a\"]\n```\n\n위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.\n\n일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.\n\n\n\n하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.\n\n먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.\n\n다음 코드는 오류를 발생시킵니다:\n\n```js\nlet foo = 10;\nfoo += 10;\n```\n\n\n\n이 코드는 다음을 수행하지 않습니다:\n\n```js\nlet mut foo = 10;\nfoo += 10;\n```\n\n이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.\n\n예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:\n\n\n\n```js\nlet mut nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nnums.push(6);\n```\n\n러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:\n\n```js\nlet nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nlet doubles: Vec\u003ci32\u003e = nums.into_iter().map(|n| n * 2).collect();\n\ndbg!(nums);     // 이 코드는 오류를 발생시킵니다.\ndbg!(doubles);\n```\n\n위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 \"소비형 반복자(consuming iterator)\"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.\n\n\n\nnums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.\n간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.\n\n```js\nfn main() {\n    let str = String::from(\"Hello world!\");\n    let len = calculate_length(str);\n    dbg!(str); // 오류 발생\n}\n\nfn calculate_length(s: String) -\u003e usize {\n    s.len()\n}\n```\n\n여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 \u0026를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:\n\n\n\n```rust\nfn main() {\n    let str = String::from(\"hello\");\n    let len = calculate_length(\u0026str);\n    dbg!(str, len);\n}\n\nfn calculate_length(s: \u0026String) -\u003e usize {\n    s.len()\n}\n```\n\n또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!\n\n내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.\n\nRust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!\n","ogImage":{"url":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"},"coverImage":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png","tag":["Tech"],"readingTime":11}],"page":"122","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"122"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>