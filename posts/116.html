<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/116" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/116" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브 또는 엑스포 앱에서의 I18n" href="/post/2024-05-14-I18ninYourReactNativeorExpoApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브 또는 엑스포 앱에서의 I18n" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브 또는 엑스포 앱에서의 I18n" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브 또는 엑스포 앱에서의 I18n</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest" href="/post/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SSR와 CSR란 무엇인가 간단히 설명하기" href="/post/2024-05-14-WhatisSSRandCSRAsimpleexplanation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SSR와 CSR란 무엇인가 간단히 설명하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SSR와 CSR란 무엇인가 간단히 설명하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SSR와 CSR란 무엇인가 간단히 설명하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="useRef 훅 렌더링 제로로 가는 길 안내" href="/post/2024-05-14-useRefHookGuidetozerore-render"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="useRef 훅 렌더링 제로로 가는 길 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="useRef 훅 렌더링 제로로 가는 길 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">useRef 훅 렌더링 제로로 가는 길 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요" href="/post/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트로 깨끗한 아키텍처 구현하기" href="/post/2024-05-14-CleanArchitectureWithReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트로 깨끗한 아키텍처 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CleanArchitectureWithReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트로 깨끗한 아키텍처 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트로 깨끗한 아키텍처 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native 웹 뷰와 React 앱 간의 통신" href="/post/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native 웹 뷰와 React 앱 간의 통신" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native 웹 뷰와 React 앱 간의 통신" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native 웹 뷰와 React 앱 간의 통신</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이 Go 라이브러리는 혁신적입니다" href="/post/2024-05-14-ThisGoLibraryIsGameChanging"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이 Go 라이브러리는 혁신적입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이 Go 라이브러리는 혁신적입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이 Go 라이브러리는 혁신적입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 네이티브 모듈 생성하기" href="/post/2024-05-14-CreatingaNativeModuleinReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 네이티브 모듈 생성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CreatingaNativeModuleinReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 네이티브 모듈 생성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 네이티브 모듈 생성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="왜 htmx를 사용해야 할까요" href="/post/2024-05-14-Whyhtmx"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="왜 htmx를 사용해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Whyhtmx_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="왜 htmx를 사용해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">왜 htmx를 사용해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link posts_-active__YVJEi" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 네이티브 또는 엑스포 앱에서의 I18n","description":"","date":"2024-05-14 11:51","slug":"2024-05-14-I18ninYourReactNativeorExpoApps","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png\" /\u003e\n\n현대 기술 생태계에서 지리적 경계를 넘어 전 세계 관객을 대상으로 서비스를 제공하는 것이 예외가 아닌 표준이 되었습니다.\n\ni18n-js로 시작하기\n\n# 설치\n\n\n\n```js\n# npm\nnpm install i18n-js expo-localization\n\n# yarn\nyarn add i18n-js expo-localization\n\n# pnpm\npnpm add i18n-js expo-localization\n\n# bun\nbun add i18n-js expo-localization\n```\n\n## 그런 다음 루트 또는 src 폴더에 i18n.ts 파일을 생성하십시오.\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en: {\n    hello: \"hello %{name}!\"\n  },\n  zh: {\n    hello: \"안녕하세요 %{name}!\"\n  },\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n## 그러면 locales 폴더에 다국어 JSON 파일을 생성할 수 있습니다.\n\n\n\n```js\n// (root)/src/locales/en.json\n{\n hello: \"안녕 %{name}!\"\n}\n```\n\n```js\n// (root)/src/locales/zh.json\n{\n hello: \"안녕하세요 %{name}!\"\n}\n```\n\ni18n.ts 변경사항\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\n+import en from '../locales/en.json';\n+import zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n+  en,\n+  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\n\ni18n.locale = deviceLanguage;\n```\n\n\n\n이제 컴포넌트에서 사용할 수 있어요. 여기 컴포넌트에서 translate 함수를 사용하는 예시가 있어요.\n\n```js\n// example.tsx\nimport { i18n } from '../lib/i18m';\n\nfunction Example() {\n return \u003cdiv\u003e{i18n.t(\"hello\", {name: \"Toy\"})}\u003c/div\u003e\n}\n```\n\n하지만 로컬을 변경하고 싶어요, 어떻게 해야 할까요?\n\n걱정 마세요, i18n.ts 파일에 changeLanguage 함수를 정의할 수 있어요.\n\n\n\n```js\n// (root)/src/lib/i18n.ts\nimport { I18n } from \"i18n-js\";\nimport { getLocales } from \"expo-localization\";\nimport en from '../locales/en.json';\nimport zh from '../locales/zh.json';\n\nexport const deviceLanguage = getLocales()?.[0]?.languageCode ?? \"en\";\n\nexport const i18n = new I18n({\n  en,\n  zh,\n});\n\ni18n.defaultLocale = deviceLanguage;\ni18n.locale = deviceLanguage;\n\n+ export function changeLanguage(lang: string) {\n+  i18n.locale = lang;\n+ }\n```\n\n그런 다음 이 함수를 언어 변경 컴포넌트에 사용할 수 있습니다.\n\n```js\n// example.tsx\nimport { i18n, changeLanguage } from '../lib/i18n';\nimport { View, Button } from 'react-native';\n\nfunction Example() {\n return (\n  \u003cView\u003e\n   \u003cView\u003e{i18n.t(\"hello\", {name: \"Toy\"})}\u003c/View\u003e\n   \u003cButton onPress={() =\u003e changeLanguage('zh')} title=\"언어 변경\"/\u003e\n  \u003c/View\u003e\n );\n}\n```\n\n너무 간단해 보이지 않나요? 이 패키지는 매우 강력하고 실용적입니다.\n\n\n\n\n이 라이브러리는 Rails-i18n에서 제공하는 기본 번역을 사용할 수 있습니다.\n\n마지막으로, i18n-js에서 더 많은 정보를 읽으려면 공식 문서로 이동할 수 있습니다.\n\nReact Native 및 Expo 앱에서 i18n을 채택하면 미래를 대비한 글로벌 확장의 길이 열립니다. 국제화는 일회성 작업이 아닌 앱이 전 세계에서 관련성을 유지하고 접근성이 있으며 사용자 친화적인 지속적인 의무라는 것을 명심해야 합니다.\n\n경험 많은 개발자이든 처음 국제화를 시작하는 중이든, 전 세계적인 모바일 앱을 개발하는 길은 당신 손안에 있으며, i18n-js는 이 추구에서 믿을 수 있는 동료입니다. React Native 및 Expo 앱의 최대 잠재력을 발휘하여 세계의 언어로 강화시키는 시간입니다.\n\n\n\n이 기사를 읽어 주셔서 감사합니다. 최대한 많이 박수/추천 해 주시고 친구들과 공유도 꼭 해주세요. 제게는 매우 중요한 일이죠.","ogImage":{"url":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png"},"coverImage":"/assets/img/2024-05-14-I18ninYourReactNativeorExpoApps_0.png","tag":["Tech"],"readingTime":3},{"title":"React에서 네비게이션 이벤트를 모의하고 테스트하는 방법 Vitest","description":"","date":"2024-05-14 11:50","slug":"2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest","content":"\n\n리액트 페이지 탐색 이벤트를 테스트하고 싶어서 노력 중이었는데, 가져온 모듈 함수를 MOCK 하는 것이 필요해 전혀 익숙하지 않았어요. \n\n마침내 어떻게 해결했는지 공유하고 싶어요. 물론, 이 예제는 정교하거나 높은 자격 요건을 갖춘 것은 아니라서 여러분의 생각과 추천 대안을 공유해주시면 정말 감사하겠어요. 이 글이 몇몇 독자들에게 도움이 되었으면 좋겠어요.\n\n** 이 문서는 테스트 환경 설정에 대한 내용을 다루지 않고 직접 내용으로 들어갑니다.\n\n## 무엇을 테스트할 것인가\n\n\n\n리액트 애플리케이션이 두 가지 접근 가능한 경로, /와 /todos를 가지고 있습니다. StartPage.test.tsx 파일은 홈 경로에 대한 유닛 테스트 파일이며, \"todos\" 텍스트를 가진 버튼이 클릭되었을 때 애플리케이션이 사용자를 /todos 페이지로 이동시키는지 테스트하고 싶습니다.\n\n## 문제 발생\n\n하지만 테스트 라이브러리 관점에서 이야기를 해보겠습니다. \"사용자를 다른 페이지로 이동시킨다\"는 것의 의미는 무엇인가요?\n\n```js\nimport useNavigation from \"@hooks/useNavigation\";\n\nexport default function StartPage() {\n  const { push } = useNavigation();\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003estart\u003c/h1\u003e\n      \u003cbutton\n        onClick={() =\u003e {\n          push(\"/todos\");\n        }\n      \u003e\n        todos\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n사용자가 \"todos\" 버튼을 클릭하면, onclick 핸들러가 실행되고, 그런 다음 push 함수가 실행됩니다. push 함수는 useNavigation 훅 호출에서 반환된 함수 중 하나입니다. 문제는 테스트 코드가 push 또는 useNavigation이 어떻게 구성되어 있는지를 모르기 때문에, 테스트 함수에 이 함수들이 어떻게 되어야 하는지 알려주어야 합니다. 이 과정을 함수 모의(mocking functions)라고 합니다.\n\n## `MemoryRouter` 내부의 단위\n\n테스트 함수를 작성하기 전에, 테스트된 컴포넌트가 react-router-dom의 Router 내에 있어야 한다는 점을 명확히해야 합니다. 그렇지 않으면 여러 경로가 없을 수 있고, 컴포넌트 함수에서 useNavigation 훅을 사용할 수 없습니다. 이 문제는 단위 컴포넌트를 react-router-dom의 `MemoryRouter` 컴포넌트로 감싸면 쉽게 처리할 수 있습니다. Router에 initialEntries prop을 제공하여 애플리케이션의 위치를 지정할 수 있습니다.\n\n```js\n// ...\n\nbeforeEach(() =\u003e {\n   render(\u003cStartPage /\u003e, {\n    wrapper: ({children}) =\u003e (\n      \u003cMemoryRouter initialEntries={[\"/\"]}\u003e\n        {children}\n      \u003c/MemoryRouter\u003e\n    ),\n  });\n});\n\n// ...\n```\n\n\n\n## 목 역할 하는 방법\n\n테스트 작업 환경인 jest와 비슷한 기능을 가진 vitest는 jest testing 환경의 vi 속성을 제공하여 변수와 함수를 mock할 수 있습니다. vi.fn 메소드는 \"함수를 스파이로 생성\"하고, vi.mock 메소드는 첫 번째 인수로 지정된 경로에서 import된 모든 모듈을 대체합니다.\n\n```js\nimport { vi } from \"vitest\";\n\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () =\u003e {\n  return {\n    // useNavigation\n    default: () =\u003e ({\n      push: mockPush,\n    }),\n  };\n});\n```\n\n위의 예시에서 vi.mock은 \"@hooks/useNavigation\" 경로에서 import된 모듈의 형태를 정의합니다. 이 모듈은 \"push\"라는 함수를 반환하는 기본 내보내기를 가지고 있습니다. 이제 모듈의 구조가 알려졌으며, 테스트 함수 내에서 스파이 변수인 mockPush를 사용하여 push 메소드에 접근할 수 있습니다. 이 모킹된 함수가 호출될 때 어떤 인수와 함께 호출되었는지 mockPush.mock.calls 또는 mockPush.mock.lastCall을 사용하여 확인할 수 있습니다. 이는 인수 목록을 제공합니다.\n\n\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () =\u003e {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  console.log(\"호출\", mockPush.mock.calls);\n  // calls [ [ '/todos' ] ]\n  console.log(\"마지막 호출\", mockPush.mock.lastCall);\n  // last call [ '/todos' ]\n});\n```\n\n여기서 만약 lastCall의 첫 번째 항목이 \"/todos\"이면, \"todos\" 버튼 클릭 이벤트의 예상 결과로써 push 메소드가 \"/todos\" 인자와 함께 호출된 것이라고 말할 수 있습니다.\n\n```js\ntest(\"버튼 클릭 시 /todos 페이지로 이동해야 함\", async () =\u003e {\n  const button = (await screen.findAllByText(\"todos\"))[0];\n  expect(button).toBeDefined();\n  await userEvent.click(button);\n\n  expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n});\n```\n\n마지막으로, 각 테스트 후에 mock 기록을 제거하기 위해 vi.clearAllMocks 메소드를 호출하는 것이 좋습니다.\n\n\n\n```js\nconst mockPush = vi.fn();\n\nvi.mock(\"@hooks/useNavigation\", () =\u003e {\n  return {\n    // useNavigation\n    default: () =\u003e ({\n      push: mockPush,\n    }),\n  };\n});\n\ndescribe(\"start page test\", () =\u003e {\n  beforeEach(() =\u003e {\n    render(\u003cStartPage /\u003e, {\n      wrapper: ({children}) =\u003e (\n        \u003cMemoryRouter initialEntries={[\"/\"]}\u003e\n          {children}\n        \u003c/MemoryRouter\u003e\n      ),\n    });\n  });\n  afterEach(() =\u003e {\n    vi.clearAllMocks();\n  });\n\n  test(\"should navigate to /todos page on button click\", async () =\u003e {\n    const button = (await screen.findAllByText(\"todos\"))[0];\n    expect(button).toBeDefined();\n    await userEvent.click(button);\n\n    expect(mockPush.mock.lastCall[0]).toEqual(\"/todos\");\n  });\n});\n```","ogImage":{"url":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png"},"coverImage":"/assets/img/2024-05-14-AwaytomockandtestnavigationeventsinReactbyVitest_0.png","tag":["Tech"],"readingTime":4},{"title":"SSR와 CSR란 무엇인가 간단히 설명하기","description":"","date":"2024-05-14 11:49","slug":"2024-05-14-WhatisSSRandCSRAsimpleexplanation","content":"\n\n웹 개발 세계에서 자주 만나는 두 용어는 SSR (서버 측 렌더링)와 CSR (클라이언트 측 렌더링)입니다. 두 용어는 웹 애플리케이션에서 콘텐츠가 표시되고 처리되는 방식에 상당한 영향을 미칩니다. 이 글에서는 이러한 개념을 자세히 살펴보고 그 차이점과 유사점을 알아보며, 어떤 경우에 한 가지를 다른 것보다 선호해야 하는지 이해해보겠습니다.\n\n![SSR](/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png)\n\n# 서버 측 렌더링 (SSR)\n\n## SSR이란?\n\n\n\n서버 측 렌더링(SSR)은 웹 페이지가 브라우저로 전송되기 전에 서버에서 생성되는 방식입니다. 다시 말해, 서버가 페이지의 로직과 구조를 처리하고 완전히 렌더링된 페이지를 사용자의 브라우저로 보냅니다.\n\n## SSR의 장점\n\n- SEO 개선: 서버에서 렌더링된 페이지는 컨텐츠가 이미 클라이언트로 전송되는 초기 HTML에 포함되어 있기 때문에 검색 엔진 친화적입니다.\n- 초기 성능 개선: 사용자들이 페이지 렌더링이 완료된 페이지를 처음부터 받기 때문에 컨텐츠를 빠르게 볼 수 있습니다.\n\n## React를 사용한 SSR의 예시\n\n\n\nNext.js는 인기 있는 React 프레임워크로, SSR을 간단하게 구현할 수 있게 해줘요.\n\n## Step 1: Next.js 설치하기\n\n```js\nnpx create-next-app my-nextjs-app\ncd my-nextjs-app\n```\n\n## Step 2: SSR 페이지 만들기\n\n\n\nIn pages/index.js 파일:\n\n```js\n// pages/index.js\nconst HomePage = ({ data }) =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport async function getServerSideProps() {\n  // API나 데이터베이스에서 데이터 가져오는 로직\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  return {\n    props: { data },\n  };\n}\n\nexport default HomePage;\n```\n\n# 클라이언트 사이드 렌더링 (CSR)\n\n## CSR이란?\n\n\n\n클라이언트 측 렌더링(CSR)은 브라우저가 빈 페이지를로드하고 JavaScript를 사용하여 해당 페이지를 콘텐츠로 채우는 것을 의미합니다. 이 경우 브라우저는 사용자 인터페이스를 만들고 제공하는 데 더 활발한 역할을 합니다.\n\n## CSR의 장점\n\n- 향상된 상호 작용: CSR 애플리케이션은 전체 페이지를 다시로드할 필요없이 사용자 인터페이스를 업데이트할 수 있어 더 많은 상호 작용성을 제공합니다.\n- 낮은 초기 로드: 초기 페이지로드가 더 빠를 수 있으며 브라우저로는 애플리케이션의 뼈대만 전송됩니다.\n\n## React를 활용한 CSR의 예시\n\n\n\nCreate React App를 사용하여 간단한 클라이언트 측 렌더링 예제를 만들어보겠습니다.\n\n## 단계 1: React 앱 만들기\n\n```js\nnpx create-react-app my-react-app\ncd my-react-app\n```\n\n## 단계 2: 클라이언트 측 렌더링 구현하기\n\n\n\n[src/App.js 파일]\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =\u003e {\n  const [data, setData] = useState({});\n\n  useEffect(() =\u003e {\n    // 앱이 로드된 후 데이터를 가져오기 위한 로직\n    fetch('https://api.example.com/data')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e setData(data));\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n# 각 접근 방식의 비교 및 언제 사용해야 하는지\n\n두 가지 방법에는 각각 장단점이 있습니다. SSR과 CSR 중 어떤 것을 선택할지는 애플리케이션의 특정 요구 사항에 따라 다릅니다. 일반적인 지침은 다음과 같습니다:\n\n\n\nSSR을 사용해보세요:\n\n- SEO를 개선하고 싶을 때.\n- 초기 성능을 향상시키고 싶을 때.\n\nCSR을 사용해보세요:\n\n- 매우 상호 작용형 애플리케이션을 갖고 있을 때.\n- 더 빠른 초기 로드를 원할 때.\n\n\n\n# 요약\n\n요약하자면, SSR과 CSR은 웹 페이지를 렌더링하는 데 사용되는 서로 다른 방법론입니다. SSR은 SEO 및 초기 성능 향상에 도움이 되지만, CSR은 보다 인터랙티브한 경험을 제공합니다. 둘 중 어떤 것을 선택할지는 애플리케이션의 목표와 구체적인 요구 사항에 따라 다릅니다.\n\n애플리케이션을 디자인할 때 사용자 요구 사항, 성능 요구 사항, 그리고 선택 사항이 검색 엔진에서 콘텐츠의 가시성에 어떻게 영향을 미칠지를 고려해야 합니다. 많은 경우, SSR과 CSR을 결합한 \"수분화\" 기술을 사용하는 것이 최상의 선택일 수 있습니다. 프로젝트의 고유한 특성에 따라 실험하고 조정해보세요.\n\n이 문서가 도움이 되었다면 망설이지 말고 팔로우, 구독, 박수를 부탁드립니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png"},"coverImage":"/assets/img/2024-05-14-WhatisSSRandCSRAsimpleexplanation_0.png","tag":["Tech"],"readingTime":3},{"title":"useRef 훅 렌더링 제로로 가는 길 안내","description":"","date":"2024-05-14 11:48","slug":"2024-05-14-useRefHookGuidetozerore-render","content":"\n\n리액트는 사용자 인터페이스를 구축하기 위한 인기 있는 자바스크립트 라이브러리로, 응용 프로그램의 문서 객체 모델(DOM)을 효과적으로 관리하는 중요한 useRef라는 강력한 후크를 제공합니다. 이 안내서에서는 useRef가 무엇인지, 어떻게 효과적으로 사용하는지, 그리고 실제 시나리오에서의 다양한 응용 방법을 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png)\n\n# useRef 소개:\n\nuseRef 후크는 리액트의 기본 요소로, 개발자가 ref라고 불리는 변경 가능한 객체를 만들 수 있게 합니다. 상태 변수와 달리 ref는 값이 변경되어도 다시 렌더링을 유발하지 않습니다. useRef의 주요 목적은 DOM에 직접 액세스하고 상호 작용하는 것으로, 개발자가 포커스를 관리하고 양식을 처리하며 애니메이션을 효과적으로 다룰 수 있도록 합니다.\n\n\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nfunction MyComponent() {\n  // ref 객체 생성\n  const myRef = useRef();\n\n  // ref를 React 요소에 연결\n  useEffect(() =\u003e {\n    myRef.current.innerText = '안녕하세요, useRef!';\n  }, []);\n\n  return \u003cdiv ref={myRef}\u003e\u003c/div\u003e;\n}\n```\n\n이 예제에서는 useRef를 사용하여 ref를 생성하고 div 요소에 연결합니다. useEffect 훅은 컴포넌트가 마운트될 때 div의 inner text를 설정하는 데 사용됩니다.\n\n```js\nimport React, { useEffect, useRef } from \"react\";\n\nfunction App() {\n  const inputRef = useRef();\n\n  useEffect(() =\u003e {\n    inputRef.current.innerText =\n      \"useRef의 초기 값은 useEffect가 초기 렌더링 시 실행되어 업데이트됩니다.\";\n  }, []);\n\n  const focusInput = () =\u003e {\n    // DOM 요소 직접 액세스 및 수정\n    inputRef.current.innerText = \"focusInput 호출됨\";\n  };\n\n  const focusOutput = () =\u003e {\n    // DOM 요소 직접 액세스 및 수정\n    inputRef.current.innerText = \"focusOutput 호출됨\";\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv ref={inputRef} className=\"mb-4 p-2\"\u003e\n        {/* 필요시 inner text에 스타일링 추가 */}\n      \u003c/div\u003e\n\n      \u003cbutton onClick={focusInput} className=\"bg-violet-400 p-2 block mb-4\"\u003e\n        Focus Input 호출\n      \u003c/button\u003e\n      \u003cbutton onClick={focusOutput} className=\"bg-cyan-400 p-2 block\"\u003e\n        Focus Output 호출\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*eTiF-2EjQFlx-u22tEPdpA.gif\" /\u003e\n\n\n\n\n## 최선의 실천방법:\n\n직접 DOM 조작을 피하세요: Refs는 DOM에 직접 액세스를 제공하지만 가능한 경우 React의 선언적 접근을 사용하는 것이 좋습니다.\n\n적절한 정리를 보장하세요: 컴포넌트 내에서 ref를 생성한 후에 해당 컴포넌트를 DOM에서 제거하면 메모리 누수를 방지하기 위해 ref를 정리해야 합니다.\n\n## 실제 적용 사례:\n\n\n\n## 서드파티 라이브러리 관리: 직접 DOM 조작이 필요한 서드파티 라이브러리 통합 시, useRef는 유용한 도구가 될 수 있어요.\n\n성능 최적화: 다시 렌더링을 유발하지 않고 렌더링 간 값 유지가 필요한 경우, useState 대신 useRef를 사용하면 성능상 이점을 제공할 수 있어요.\n\n## 다른 훅들과 비교:\n\nuseState: 업데이트될 때 다시 렌더링을 유발하는 상태를 관리하는 경우 useState를 사용하세요.\n\n\n\n`useEffect`을 사용할 때는 부가 효과와 라이프사이클 메소드에 주로 사용되지만, `useRef`는 DOM에 직접 접근하고 상호 작용하는 데 중점을 둡니다.\n\n# FAQ\n\n## React에서 useRef 훅의 주요 용도는 무엇인가요?\n\n`useRef`는 주로 React 컴포넌트에서 DOM에 직접 접근하고 상호 작용하는 데 사용됩니다.\n\n\n\n## useRef 객체의 주요 속성은 무엇이며 어떻게 접근할 수 있나요?\n\n주요 속성은 current이며 ref.current 구문을 통해 접근할 수 있습니다.\n\n## useRef와 useState의 다른 점은 무엇인가요?\n\n반면에 ref.current 값을 수정해도 다시 렌더링을 일으키지 않습니다. useRef는 컴포넌트가 다시 렌더링되지 않고도 값의 지속성을 유지하고 싶을 때 유용합니다.\n\n\n\n📚이전 포스트:\n\n👉 React Hooks: useState \u0026 useEffect\n👉 React 함수형 컴포넌트와 Hooks 이해하기\n👉 useContext Hooks를 활용한 React 상태 관리 재고\n👉 React Props 언플러그드: 데이터 흐름 해제하기\n\n🔍 다음에는:\n\n👉 useLayoutEffect Hook\n👉 useMemo Hook\n👉 useCallback Hook\n\n\n\n웹 개발 세계에서 더 많은 통찰력을 기대해주세요! 🚀📦\n\n🤝 LinkedIn에서 함께해요: [LinkedIn 프로필 링크](https://www.linkedin.com/in/omkarbhavare/)","ogImage":{"url":"/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png"},"coverImage":"/assets/img/2024-05-14-useRefHookGuidetozerore-render_0.png","tag":["Tech"],"readingTime":3},{"title":"Three JS와 React Three Fiber를 사용하여 웹사이트를 만들어보세요","description":"","date":"2024-05-14 11:45","slug":"2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber","content":"\n\nThree JS와 React Three Fiber(R3F)를 사용하여 웹사이트를 만드는 단계별 튜토리얼.\n\n참고: 저처럼 조금 게을러진 분들을 위해 😎, 최종 코드에 액세스하려면 이 링크를 따르는 게 좋아요. 코드는 아마 있을 거에요, 하지만 완벽하게 이해하지 못할 거에요 🤣. 믿어봐요 !!!. 복사/붙여넣기도 좋지만, 과정을 이해하는 게 더 낫죠 😉 그리고 빨간 선이 나오면 뭐라도 소리 내 면 안 된답니다 😂.\n\n# 단계 1: Vite를 사용하여 새 React 프로젝트 설정하기.\n\n터미널을 열고 다음 명령을 실행하여 Vite를 사용하여 새 React 프로젝트를 생성하세요:\n\n\n\n```js\nnpm create vite@latest\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png\" /\u003e\n\n프로젝트 이름을 작성하고 ENTER를 누르세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_1.png\" /\u003e\n\n\n\n\nVite는 선택할 수 있는 다양한 프레임워크를 제공합니다. 이 프로젝트에서는 React를 사용하고 있으니 React로 이동하려면 아래 방향키를 누르고 ENTER 키를 누르세요.\n\n![React](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_2.png)\n\nReact에서는 TypeScript 또는 JavaScript를 사용할 수 있습니다. 저희는 JavaScript를 사용할 예정이므로 아래 방향키를 사용하여 JavaScript를 선택하세요. ENTER 키를 누르세요.\n\n![JavaScript](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_3.png)\n\n\n\n위의 이미지에서 보이는 폴더 구조를 얻을 수 있습니다. 아직 종속성이 설치되지 않았으므로 먼저 설치해야 합니다. VS 코드 터미널에서 다음 명령어를 입력해주세요:\n\n```js\ncd project-name \n```\n\n여기서 cd는 디렉토리 변경을 의미합니다. 'project-name'을 여러분의 프로젝트 이름으로 바꾼 후 ENTER 키를 눌러주세요.\n\n그런 다음 VS 터미널에서 다음 몤령어를 입력하세요.\n\n\n\n```js\nnpm 설치\n```\n\n![Three JS and React Three Fiber](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_4.png)\n\n# 단계 2: 필수 종속성 설치하기.\n\n이제 종속성을 설치했으니 프로젝트에 Three JS, React Three Fiber 및 React Three Drei를 추가해야 합니다.\n\n\n\n터미널에 다음 명령어를 입력해주세요:\n\n```js\nnpm i three @react-three/fiber @types/three @react-three/drei\n```\n\n참고: npm i는 npm install의 약식 표현입니다.\n\n# 단계 3: 프로젝트 실행하기. \n\n\n\n이제 필요한 모든 종속 항목을 갖췄으니 브라우저에서 React 앱을 확인할 수 있습니다. 터미널에 다음 명령을 입력하세요:\n\n```js\nnpm run dev\n```\n\n![이미지](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_5.png)\n\n링크 위로 마우스를 올리고 링크를 ctrl 키를 누른 채 클릭하면, 브라우저가 열립니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_6.png\" /\u003e\n\n\"축하합니다\" React 앱을 만들었어요 😁.\n\n# 단계 4: 코드 정리.\n\n웹사이트는 이미 좋아 보이지만 우리가 원하는 것은 아닙니다. 코드를 정리할 시간입니다.\n\n\n\nApp.js 파일에서 다음 코드를 모두 제거해주세요:\n\n```html\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_7.png\" /\u003e\n```\n\n그리고 App.css와 index.css에서 모든 CSS 코드도 제거해주세요.\n\n이제 브라우저를 확인하면 하얗게 보일 거예요. 이제 \"멋진 웹사이트\"를 만들기 시작할 수 있습니다.\n\n\n\n# 단계 5: 장면 생성하기.\n\n리액트 앱에서 Three JS 장면을 사용하려면 캔버스를 만들어야 합니다. 물론 `canvas` HTML 태그를 사용할 수 있지만, 대신 React Three Fiber (R3F) 패키지를 설치했습니다. 이 패키지는 Three.js를 React 애플리케이션에 원활하게 통합할 수 있는 방법을 제공합니다.\n\n아래 코드를 App.js에 작성해주세요:\n\n```js\nimport * as THREE from \"three\"\nimport './App.css'\nimport { Canvas } from \"@react-three/fiber\"\n\nfunction App() {\n\n  return (\n    \u003c\u003e\n      \u003cCanvas\u003e\u003c/Canvas\u003e\n    \u003c/\u003e\n  )\n}\n\nexport default App\n```\n\n\n\n여기에서는 \"three\"로부터 세 개의 JS와 \"React Three Fiber\"로부터 Canvas를 가져왔습니다. 이제 모든 것을 Canvas 안에서 처리할 거에요. Canvas는 Three JS를 사용하여 3D 캔버스를 생성하기 위해 React Three Fiber에서 제공하는 구성 요소입니다.\n\n이제 Canvas에 속성을 추가해보세요 :\n\n```js\nfunction App() {\n\n  return (\n    \u003c\u003e\n      \u003cCanvas gl={{ antialias: false }} dpr={[1, 1.5]}\u003e\n        \n      \u003c/Canvas\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n여기서 :\ngl=' antialias: false ' : 이 속성은 WebGL(웹 그래픽 라이브러리) 렌더러 설정을 Canvas 구성 요소에 전달하는 데 사용됩니다. 이 경우에는 antialias 속성을 false로 설정합니다. 안티앨리어싱은 컴퓨터 그래픽의 날카로운 가장자리를 부드럽게 만드는 기술입니다. 이를 false로 설정하면 성능이 향상됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_8.png\" /\u003e\n\ndpr='[]' : 이 속성은 캔버스의 장치 픽셀 비율(device pixel ratio, dpr)을 설정합니다. 장치 픽셀 비율은 장치 화면의 물리적 픽셀과 논리적 픽셀의 비율입니다. 이 경우 배열 [1, 1.5]로 설정되어 있습니다. 이는 캔버스가 윈도우가 고해상도(DPI, 인치 당 점)가 아닐 때 장치 픽셀 비율이 1이 되고, 고해상도일 때 1.5가 됨을 의미합니다. 이는 고해상도 디스플레이에서 선명한 그래픽을 렌더링하는 데 도움이 될 수 있습니다.\n\n# 단계 6: 캔버스에 큐브 렌더링하기.\n\n이제 브라우저에 무언가를 표시해 봅시다.\n\n\n\n```js\n  function App() {\n  return (\n    \u003c\u003e\n      \u003cCanvas gl={{ antialias: false }} dpr={[1, 1.5]}\u003e\n        \u003cmesh\u003e\n          \u003cboxGeometry /\u003e\n        \u003c/mesh\u003e\n      \u003c/Canvas\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n위의 코드를 App.js에 추가하고 저장해주세요. 또한, 이 프로젝트에서는 mesh와 geometry를 사용하지 않기 때문에 Three JS 문서를 확인하여 더 자세한 내용을 알아보세요. 이제 브라우저를 확인해보면 다음과 같이 작은 사각형이 보입니다 :\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_9.png\" /\u003e\n\n이것은 우리의 코드가 작동 중이라는 것을 의미합니다 😳. 이제 사각형을 더 크게 만들기 위해 다음 CSS 코드를 App.css에 추가해주세요 :\n\n\n\n```js\n* {\n  box-sizing: border-box;\n}\n\nhtml,\nbody,\n#root {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\n```\n\n여기서는 Canvas에 100%의 높이와 너비를 제공하여 캔버스가 전체 화면을 차지할 수 있도록합니다. 또한 페이지의 모든 기본 여백과 간격을 제거합니다. 이제 브라우저에서 이렇게 나타날 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_10.png\" /\u003e\n\n# 단계 7: 텍스트 추가하기.\n\n\n\n이제 캔버스에 텍스트를 추가할 시간입니다. 이전에 사용한 코드 대신에 다음 코드를 App.js에 추가해보세요:\n\n```js\nimport * as THREE from \"three\";\nimport \"./App.css\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Scroll, ScrollControls } from \"@react-three/drei\";\n\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003cCanvas gl={ antialias: false } dpr={[1, 1.5]}\u003e\n        \u003cScrollControls damping={2} pages={5}\u003e\n          \u003cScroll html\u003e\n            \u003ch1 style={ position: \"absolute\", top: \"60vh\", left: \"0.2em\" }\u003e\n              Make\n            \u003c/h1\u003e\n            \u003ch1 style={ position: \"absolute\", top: \"120vh\", left: \"60vw\" }\u003e\n              Scroll\n            \u003c/h1\u003e\n            \u003ch1\n              style={\n                position: \"absolute\",\n                top: \"210.5vh\",\n                left: \"0.5vw\",\n                fontSize: \"20vw\",\n              }\n            \u003e\n              Creative\n            \u003c/h1\u003e\n            \u003ch1\n              style={\n                position: \"absolute\",\n                top: \"330.5vh\",\n                left: \"50rem\",\n                fontSize: \"10vw\",\n              }\n            \u003e\n              And Flawless\n            \u003c/h1\u003e\n          \u003c/Scroll\u003e\n        \u003c/ScrollControls\u003e\n      \u003c/Canvas\u003e\n    \u003c/\u003e\n  );\n}\n\nexport default App;\n```\n\n우리는 React Three Drei에서 scrollControls를 사용하고 있습니다. scrollControls는 캔버스 앞에 HTML 스크롤 컨테이너를 만듭니다. `Scroll` 컴포넌트에 추가하는 모든 것에 영향을 줄 것입니다.\n\n이제 props에 대해 이야기해볼까요:\n\n\n\ndamping='2' : 이 속성은 스크롤의 감쇠 계수를 제어합니다.\n\n감쇠는 물리학과 애니메이션에서 자주 사용되는 수학적 개념으로, 움직임이나 진동이 서서히 감소되는 것을 시뮬레이션하는 데 사용됩니다.\n\npages='5' : 이 속성은 사용자가 탐색할 수 있는 \"페이지\" 또는 스크롤 섹션의 총 수를 설정합니다. 콘텐츠의 여러 섹션을 제어하기 위해 사용될 스크롤 값의 범위를 결정합니다.\n\n또한 이 CSS를 App.css에 추가하세요:\n\n\n\n```js\n@import url('https://rsms.me/inter/inter.css'); /* 최상단에 이것을 추가하세요 */\n\nbody {\n  overscroll-behavior: none;\n  background: #efefef;\n  font-family: 'Inter var', sans-serif;\n  cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTAiIGZpbGw9ImJsYWNrIi8+PC9zdmc+'),\n    auto; /* 커스텀 커서 불러오기 */\n}\n\nh1 {\n  font-size: 10rem;\n  font-weight: 400;\n  letter-spacing: -0.05em;\n  line-height: 9rem;\n  margin: 0;\n  padding: 0;\n}\n```\n\n이제 브라우저에서 확인하면 텍스트가 나타날 것이며 스크롤할 때 애니메이션이 적용됩니다. 스크롤 애니메이션을 느낄 수 있을 것입니다. 따라서 우리는 잘 진행 중이랍니다.\n\n# 단계 8: 이미지 추가\n\n이 프로젝트의 가장 어려운 부분입니다. 하지만 이해해 보도록 해봅시다. 여기서는 이미지를 추가하고 스크롤 시에 애니메이션을 적용해야 합니다. 이미지가 확대되고 스크롤 시 줌인되는 것을 확인했다면 이를 만들어야 합니다. 이를 작은 작업으로 나누어 보겠습니다.\n\n\n\n\n- 이미지 추가\n- 스크롤할 때 애니메이션 효과 적용\n- 줌 애니메이션 추가\n\n## 이미지 추가:\n\n먼저 프로젝트에 추가할 이미지가 필요합니다. 리액트에서 이미지를 사용하는 여러 가지 방법이 있습니다. 저는 content.js에서 이미지를 내보내는 방법을 사용하고 있습니다. 이 방법을 사용하면 프로젝트 어디에서든 이미지를 가져올 수 있습니다.\n\ncontent라는 폴더를 생성하고, 해당 폴더에 content.js라는 파일을 추가해주세요:\n\n\n\n\n![Screenshot](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_11.png)\n\n이제 content.js 파일에 다음 코드를 추가해주세요:\n\n```js\nexport const image1 = \"https://images.pexels.com/photos/7631166/pexels-photo-7631166.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image2 = \"https://images.pexels.com/photos/15955004/pexels-photo-15955004/free-photo-of-a-man-walking-down-a-narrow-alleyway-in-black-and-white.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image3 = \"https://images.pexels.com/photos/15876173/pexels-photo-15876173/free-photo-of-sunrise-from-currumbin.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image4 = \"https://images.pexels.com/photos/15861750/pexels-photo-15861750/free-photo-of-sky-sunset-airplane-flight-background-wallpaper.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image5 = \"https://images.pexels.com/photos/19864134/pexels-photo-19864134/free-photo-of-two-horses-standing-in-a-field-in-black-and-white.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image6 = \"https://images.pexels.com/photos/16791339/pexels-photo-16791339/free-photo-of-man-standing-on-terrace-of-resort-apartment-with-swimming-pool.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image7 = \"https://images.pexels.com/photos/19882770/pexels-photo-19882770/free-photo-of-surfur-with-a-surfboard-walking-on-the-beach.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image8 = \"https://images.pexels.com/photos/1366919/pexels-photo-1366919.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image9 = \"https://images.pexels.com/photos/925683/pexels-photo-925683.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image10 = \"https://images.pexels.com/photos/15627686/pexels-photo-15627686/free-photo-of-a-velha-cabra.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\nexport const image11 = \"https://images.pexels.com/photos/10850828/pexels-photo-10850828.jpeg?auto=compress\u0026cs=tinysrgb\u0026w=1260\u0026h=750\u0026dpr=1\";\n```\n\n저는 pixels.com에서 이미지를 사용하고 있어요.\n\n\n\n\n- 먼저 이미지 주소를 복사하세요.\n- 상수를 만드세요.\n- 상수의 이름을 지으세요.\n- 이미지 주소를 \" \" (문자열) 안에 넣으세요.\n- 시작 부분에 export를 추가하세요.\n\n이제 App.js 파일에서 가져와야 합니다.\n\n```js\nimport {\n  image1,\n  image2,\n  image3,\n  image4,\n  image5,\n  image6,\n  image7,\n  image8,\n  image9,\n  image10,\n} from \"./content/content\";\n```\n\n지금까지의 코드는 :\n\n\n\n```js\nconst { height, width } = useThree((state) =\u003e state.viewport);\nconst data = useScroll();\n```\n\nuseThree는 React Three Fiber에서 제공하는 훅으로 Three.js 상태에 접근할 수 있게 해줍니다. 이 경우에는 뷰포트의 높이와 너비를 얻기 위해 사용되었습니다.\n\n\n\nuseScroll은 React Three Drei에서 가져올 수 있는 사용자 정의 후크(custom hook)로, 스크롤 관련 데이터를 제공합니다. 반환된 데이터 객체는 애니메이션 로직에 사용됩니다.\n\n```js\nconst group = useRef();\n```\n\nuseRef() 후크는 수정 가능한 객체(group)를 만들기 위해 사용되며, 이 객체는 Three.js 그룹 객체에 첨부될 것입니다. 이 ref는 애니메이션 루프에서 그룹의 자식들을 조작하는 데 사용될 것입니다.\n\n```js\nuseFrame(() =\u003e {\n  // 스크롤 데이터를 기반으로 한 애니메이션 로직\n  // 그룹 내 각 자식의 재질(zoom 속성)을 조정\n  // 애니메이션 로직은 스크롤 위치를 기반으로 하는 것으로 보입니다.\n  // `data.range` 메서드는 지정된 범위 내에서 값을 계산하는 데 사용됩니다.\n});\n```\n\n\n\nReact Three Fiber의 useFrame 훅은 애니메이션 루프를 정의하는 데 사용됩니다. 이 루프 안에서 그룹 내 각 자식의 재질의 줌 속성이 스크롤 데이터(data)에 기반하여 조정됩니다.\n\n```js\ngroup.current.children[0].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n```\n\ngroup.current:\n\ngroup은 useRef 훅을 사용하여 생성된 ref입니다. current는 ref의 현재 값에 액세스하는 데 사용되며 이 경우에는 Three.js 그룹을 가리켜야 합니다.\n\n\n\ngroup.current.children[0]:\n\n이 명령은 Three.js 그룹(group)의 첫 번째 자식에 액세스합니다. 이 그룹은 여러 자식을 가지고 있다고 가정합니다.\n\ngroup.current.children[0].material:\n\n이 명령은 첫 번째 자식의 재질(material)에 액세스합니다. Three.js에서 재질은 객체의 외관을 정의합니다.\n\n\n\ngroup.current.children[0].material.zoom:\n\n이는 첫 번째 자식의 재료의 줌 속성에 액세스하거나 설정하는 것입니다. 줌 속성은 Three.js 재료의 표준 속성이 아니므로 사용자 정의 속성이거나 사용자 정의 셰이더 데이터를 통해 추가된 속성인 것 같습니다.\n\ndata.range(0, 1 / 3) / 3\n\ndata는 scroll 관련 데이터를 제공하는 useScroll 훅에서 얻은 객체로 가정됩니다.\n\ndata.range(0, 1 / 3)는 현재 스크롤 위치를 기반으로 [0, 1/3] 범위 내에서 값을 계산합니다.\n\n\n\n결과는 그 후에 3으로 나누어져서 값이 축소될 수 있습니다.\n\n1 + data.range(0, 1 / 3) / 3:\n\n최종 값은 스크롤 범위에서 얻은 값의 축척된 값에 1을 더하여 계산됩니다. 이는 줌 요소가 적어도 아래에 있는 것을 보장하기 위해 사용될 수 있습니다.\n\n```js\nreturn (\n  \u003cgroup ref={group}\u003e\n    {/* 서로 다른 위치, 스케일 및 URL을 가진 Image 구성 요소의 여러 인스턴스 */}\n    \u003cImage position={[-1, 0, 0]} scale={[4, height, 1]} url={image1} /\u003e\n    {/* ... (다른 이미지에 대해서도 유사하게) */}\n  \u003c/group\u003e\n);\n```\n\n\n\n이미지 컴포넌트는 이미지 컴포넌트의 여러 인스턴스를 포함하는 `group` 컴포넌트를 반환합니다.\n\n각 이미지 컴포넌트는 특정 매개변수를 기반으로 위치 지정, 크기 조정 및 이미지 URL(url)가 할당됩니다.\n\n이미지 컴포넌트는 사용자 상호작용 또는 애니메이션 처리와 관련된 추가 기능을 제공하기 위해 Three.js 객체를 감싸는 사용자 정의 컴포넌트입니다.\n\n이제 브라우저에서 이미지를 확인하면 화면에 표시되고 스크롤할 때 애니메이션될 것입니다.\n\n\n\n노트: 값을 조정해 보면 무슨 일이 일어나는지 확인해보세요.\n\n![이미지](/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_12.png)\n\n모든 것이 완료되었지만 몇 가지 추가 스타일을 추가해 보겠습니다. 호버 시 이미지를 밝게 만들어 보겠습니다. 그러려면 이 코드 라인을 추가하세요:\n\n```js\nimport { useRef, useState } from \"react\";\nimport { Scroll, ScrollControls, useScroll, Image as ImageImpl } from \"@react-three/drei\";\n```\n\n\n\n앱 함수에 다음 코드 라인을 추가하세요 :\n\n```js\n function Image({ c = new THREE.Color(), ...props }) {\n    const ref = useRef();\n    const [hovered, hover] = useState(false);\n    useFrame(() =\u003e {\n      ref.current.material.color.lerp(\n        c.set(hovered ? \"white\" : \"#ccc\"),\n        hovered ? 0.4 : 0.05\n      );\n    });\n    return (\n      \u003cImageImpl\n        ref={ref}\n        onPointerOver={() =\u003e hover(true)}\n        onPointerOut={() =\u003e hover(false)}\n        {...props}\n      /\u003e\n    );\n  }\n```\n\n이제 이 코드를 분석해봅시다 :\n\n```js\nfunction Image({ c = new THREE.Color(), ...props }) {\n```\n\n\n\n이것은 Image라는 기능적 React 컴포넌트를 선언합니다.\n\n기본값이 있는 객체 비구조화 인자를 가져옵니다. 여기에는 새로운 THREE.Color() 인스턴스로 기본값으로 설정된 c 속성이 포함되어 있습니다.\n\n...props 구문은 컴포넌트에 전달된 추가 props를 수집하는 데 사용됩니다.\n\n```js\nconst ref = useRef();\nconst [hovered, hover] = useState(false);\n```\n\n\n\n`useRef()`은 `ImageImpl` 컴포넌트에 연결될 변경 가능한 객체(ref)를 생성하는 데 사용됩니다. 이를 통해 Three.js의 기본 객체에 액세스하고 상호 작용할 수 있습니다.\n\n`useState(false)`는 상태 변수 `hovered`를 초기화하고 해당 값을 업데이트할 함수 `hover`를 생성하는 데 사용됩니다. 기본값은 false로 설정됩니다.\n\n```js\nuseFrame(() =\u003e {\n  ref.current.material.color.lerp(\n    c.set(hovered ? \"white\" : \"#ccc\"),\n    hovered ? 0.4 : 0.05\n  );\n});\n```\n\n`useFrame`은 Three.js 씬에서 애니메이션을 실행하기 위해 React Three Fiber 라이브러리에서 제공하는 사용자 정의 후크입니다. 각 프레임마다 실행될 콜백 함수를 인수로 전달합니다.\n\n\n\n이 콜백에서 ref.current는 ref로 참조된 Three.js 객체에 액세스하는 데 사용됩니다. 그런 다음 Three.js 객체의 재질 색상을 업데이트합니다.\n\n색상은 두 개의 색상 사이를 선형 보간하는 lerp 메서드를 사용하여 업데이트됩니다. 보간되는 색상은 hovered의 값에 따라 결정됩니다. hovered가 true이면 색상이 흰색으로 설정되고, 그렇지 않으면 회색(#ccc)의 음영이 설정됩니다.\n\n보간 계수(0.4 또는 0.05)는 색상 전환 속도를 결정합니다. 더 높은 값은 객체 위에 마우스가 있을 때(즉, hovered가 true인 경우) 더 빠른 전환을 의미합니다.\n\n```js\nreturn (\n  \u003cImageImpl\n    ref={ref}\n    onPointerOver={() =\u003e hover(true)}\n    onPointerOut={() =\u003e hover(false)}\n    {...props}\n  /\u003e\n);\n```\n\n\n\n여기에는 이미지 컴포넌트가 ref 객체를 전달하여 `ImageImpl` 컴포넌트를 반환합니다. 이를 통해 useFrame 훅이 기본 Three.js 객체와 상호 작용할 수 있게 됩니다.\n\n`ImageImpl` 컴포넌트에는 이벤트 핸들러(onPointerOver 및 onPointerOut)가 제공되며, 이를 통해 마우스 상호작용에 따라 hover 상태가 트리거됩니다.\n\n이미지 컴포넌트로 전달되는 추가적인 속성은 '…props'를 사용하여 전달됩니다.\n\n이제 suspense와 preload를 추가해야 합니다:\n\n\n\n```js\nimport { Suspense, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport {\n  Scroll,\n  ScrollControls,\n  useScroll,\n  Image as ImageImpl,\n  Preload,\n} from \"@react-three/drei\";\nimport {\n  image1,\n  image2,\n  image3,\n  image4,\n  image5,\n  image6,\n  image7,\n  image8,\n  image9,\n  image10,\n} from \"./content/content\";\nimport \"./App.css\";\nfunction App() {\n  function Image({ c = new THREE.Color(), ...props }) {\n    const ref = useRef();\n    const [hovered, hover] = useState(false);\n    useFrame(() =\u003e {\n      ref.current.material.color.lerp(\n        c.set(hovered ? \"white\" : \"#ccc\"),\n        hovered ? 0.4 : 0.05\n      );\n    });\n    return (\n      \u003cImageImpl\n        ref={ref}\n        onPointerOver={() =\u003e hover(true)}\n        onPointerOut={() =\u003e hover(false)}\n        {...props}\n      /\u003e\n    );\n  }\n\n  function Images() {\n    const { height, width } = useThree((state) =\u003e state.viewport);\n    const data = useScroll();\n    const group = useRef();\n\n    useFrame(() =\u003e {\n      group.current.children[0].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n      group.current.children[1].material.zoom = 1 + data.range(0, 1 / 3) / 3;\n      group.current.children[2].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n      group.current.children[3].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 2;\n      group.current.children[4].material.zoom =\n        1 + data.range(1.25 / 3, 1 / 3) / 1;\n      group.current.children[5].material.zoom =\n        1 + data.range(1.8 / 3, 1 / 3) / 3;\n      group.current.children[6].material.zoom =\n        1 + (1 - data.range(2 / 3, 1 / 3)) / 3;\n      group.current.children[7].material.zoom =\n        1 + (1 - data.range(2 / 3, 1 / 3)) / 3;\n      group.current.children[8].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n      group.current.children[9].material.zoom =\n        1 + data.range(1.15 / 3, 1 / 3) / 3;\n    });\n\n    return (\n      \u003cgroup ref={group}\u003e\n        \u003cImage position={[-1, 0, 0]} scale={[4, height, 1]} url={image1} /\u003e\n        \u003cImage position={[4, 0, 1]} scale={5} url={image2} /\u003e\n        \u003cImage position={[-3, -height, 2]} scale={[2, 3, 1]} url={image3} /\u003e\n        \u003cImage position={[-0.6, -height, 3]} scale={[1, 2, 1]} url={image4} /\u003e\n        \u003cImage position={[0.75, -height, 3.5]} scale={1.5} url={image5} /\u003e\n        \u003cImage\n          position={[0, -height * 1.5, 2.5]}\n          scale={[1.5, 3, 1]}\n          url={image6}\n        /\u003e\n        \u003cImage\n          position={[0, -height * 2 - height / 4, 0]}\n          scale={[width, height / 2, 1]}\n          url={image7}\n        /\u003e\n        \u003cImage\n          position={[-5, -height * 2.7 - height / 3, 0]}\n          scale={[5, height, 1]}\n          url={image8}\n        /\u003e\n        \u003cImage\n          position={[-2, -height * 3 - height, 2]}\n          scale={[3, 3, 1]}\n          url={image9}\n        /\u003e\n        \u003cImage\n          position={[1.5, -height * 3 - height, 2]}\n          scale={[3, 3, 1]}\n          url={image10}\n        /\u003e\n      \u003c/group\u003e\n    );\n  }\n  return (\n    \u003c\u003e\n      \u003cCanvas gl={{ antialias: false }} dpr={[1, 1.5]}\u003e\n      \u003cSuspense fallback={null}\u003e\n          \u003cScrollControls damping={2} pages={5}\u003e\n            \u003cScroll\u003e\n              \u003cImages /\u003e\n            \u003c/Scroll\u003e\n            \u003cScroll html\u003e\n              \u003ch1 style={{ position: \"absolute\", top: \"60vh\", left: \"0.2em\" }}\u003e\n                Make\n              \u003c/h1\u003e\n              \u003ch1 style={{ position: \"absolute\", top: \"120vh\", left: \"60vw\" }}\u003e\n                Scroll\n              \u003c/h1\u003e\n              \u003ch1\n                style={{\n                  position: \"absolute\",\n                  top: \"210.5vh\",\n                  left: \"0.5vw\",\n                  fontSize: \"20vw\",\n                }}\n              \u003e\n                Creative\n              \u003c/h1\u003e\n              \u003ch1\n                style={{\n                  position: \"absolute\",\n                  top: \"330.5vh\",\n                  left: \"50rem\",\n                  fontSize: \"10vw\",\n                }}\n              \u003e\n                And Flawless\n              \u003c/h1\u003e\n            \u003c/Scroll\u003e\n          \u003c/ScrollControls\u003e\n          \u003cPreload /\u003e\n        \u003c/Suspense\u003e\n      \u003c/Canvas\u003e\n    \u003c/\u003e\n  );\n}\n\nexport default App;\n```\n\n위의 코드는 최종 코드입니다. 이제 suspense와 preload에 대해 배우겠습니다.\n\n```jsx\n\u003cSuspense fallback={null}\u003e\n  {/* ... */}\n\u003c/Suspense\u003e\n```\n\nSuspense 컴포넌트는 내장 React 컴포넌트로, 컴포넌트가 렌더링되기 전에 무언가를 기다리도록 허용하는 것입니다. 보통 데이터 가져오기나 코드 분할과 같은 비동기 작업을 처리하는 데 사용됩니다.\n\n\n\n\nfallback 속성은 비동기 작업이 진행 중일 때 렌더링할 내용을 지정합니다. 이 경우에는 null로 설정되어 있어서 아무것도 렌더링되지 않아야 함을 나타냅니다.\n\nSuspense는 아마초 또는 컴포넌트의 비동기 로딩을 처리하기 위해 사용되며, 내부 컨텐츠(ScrollControls, Scroll, Images 및 텍스트 요소를 포함한)가 비동기 작업이 완료될 때까지 렌더링되지 않도록 보장합니다.\n\n```js\n\u003cPreload /\u003e\n```\n\nPreload 컴포넌트는 아마도 react-three/drei 라이브러리의 일부일 것입니다. 이는 실제로 씬에서 사용되기 전에 텍스처 또는 모델과 같은 에셋을 미리로딩하는 데 사용됩니다.\n\n\n\n프리로딩은 필요한 경우에 자산이 필요하기 전에 메모리로 로드되어 있는지 확인하여 도움이 됩니다. 이는 사용되는 자산이 처음 사용될 때 런타임 중에 로딩 지연을 피하고 더 부드러운 사용자 경험을 제공합니다.\n\n리액트 쓰리 파이버로 웹사이트를 만들어 축하드립니다👏.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*Qo5FVr1hxVphASfQwIyd0Q.gif)\n\n이것은 무수히 많은 복잡하고 창의적인 아이디어를 위한 시작에 불과합니다. 계속해서 배우고 발전해나가세요.\n\n\n\n이 글을 읽어주셔서 마지막으로 \"감사합니다.\" 새로운 것을 배우셨기를 바라요. 만약 이 글을 좋아하셨다면 댓글을 남겨주시면 제가 더 이런 글을 작성할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png"},"coverImage":"/assets/img/2024-05-14-BuildWebsiteWithThreeJSandReactThreeFiber_0.png","tag":["Tech"],"readingTime":20},{"title":"리액트로 깨끗한 아키텍처 구현하기","description":"","date":"2024-05-14 11:42","slug":"2024-05-14-CleanArchitectureWithReact","content":"\n\n## 클린 아키텍처는 애플리케이션을 보다 쉽게 유지 보수하고 확장할 수 있게 만들어줍니다. 그러나 여러 가지 프레임워크 기반 코딩 스타일에 의해 우리의 코드는 편향될 수 있습니다. 이 기사에서는 React 기반 코드를 클린 아키텍처로 변환하는 방법을 보여드리고자 합니다.\n\n![클린 아키텍처 이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_0.png)\n\n클린 아키텍처는 수직으로 쌓인 여러 층으로 정의되며 각 층은 소프트웨어의 다른 영역을 나타냅니다. 상위 층은 애플리케이션의 기본 정책을 나타내며 하위 층은 메커니즘을 나타냅니다.\n\n![클린 아키텍처 이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_1.png)\n\n\n\n이 아키텍처가 작동하는 데 중요한 규칙은 의존성 규칙입니다. 이 규칙은 소스 코드 의존성은 위로만 가리킬 수 있다고 합니다. 계층과 의존성 규칙을 이용하면 데이터베이스와 프레임워크와 같은 기술 구현 세부 사항과 독립적인 매우 낮은 결합도를 가진 애플리케이션을 설계할 수 있습니다.\n\n이 문서에서 정의한 계층을 사용하여 다음과 같이 설명합니다:\n\n도메인 계층은 프로젝트나 애플리케이션이 하는 일을 설명합니다. 도메인 계층의 코드는 플랫폼과 프레임워크와 독립적이어야 합니다.\n\n- 모델은 문제와 관련된 현실 세계 객체를 나타냅니다.\n- 리포지토리는 모델에 액세스하기 위한 인터페이스를 제공합니다.\n- Use case는 애플리케이션의 모든 비즈니스 로직을 포함합니다.\n\n\n\n프레젠테이션 레이어는 애플리케이션이 외부 세계와 상호 작용하는 방식을 설명합니다.\n\n데이터 레이어는 애플리케이션이 데이터를 관리하는 방법을 설명합니다.\n\n주 레이어(가장 하단 레이어)는 다른 레이어의 모든 소프트웨어 구성 요소를 한 애플리케이션으로 통합하는 부트스트랩 코드를 제공합니다.\n\n하지만 실제 애플리케이션에서는 제어 흐름이 항상 상향 방향인 것은 아닙니다. 예를 들어 UseCase 레이어의 비즈니스 로직은 Repository 레이어의 인터페이스를 사용하며, Repository(상위 레이어)는 데이터 레이어(하위 레이어)에 있는 데이터에 액세스해야 합니다. 아래 그림을 참조하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_2.png\" /\u003e\n\n이 종속성 규칙 위반을 해결하려면 일반적으로 의존성 역전 원칙을 사용합니다. 인터페이스 (예: RepositoryX)와 해당 구현 (예: RepositoryImpl) 간의 관계를 위로 향하는 소스 코드 의존성을 가리키도록 정렬합니다. 이 기술을 사용하면 상위 레이어가 하위 레이어에서 정의된 구현을 호출할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_3.png\" /\u003e\n\n# React 애플리케이션을 클린 아키텍처로 변환하기\n\n\n\n애플리케이션 코드를 리액트 애플리케이션의 템플릿(예: create-react-app로 생성된 꼬겨받은)에서 시작하면 모든 코드가 처음에 프레젠테이션 레이어에 포함됩니다. 이는 리액트(그리고 모든 UI 프레임워크)가 데이터를 사용자에게 어떻게 표시할지에 중점을 둔 것이기 때문입니다. 이 섹션에서는 리액트 기반 애플리케이션 코드를 변형하여 청결한 아키텍처를 준수하도록 만들 것입니다.\n\n여기 공식 리액트 튜토리얼에서 사용된 TicTacToe의 원본 코드입니다.\n\n```js\nfunction Square(props) {\n  return (\n    \u003cbutton className=\"square\" onClick={props.onClick}\u003e\n      {props.value}\n    \u003c/button\u003e\n  );\n}\n\nclass Board extends React.Component {\n  renderSquare(i) {\n    return (\n      \u003cSquare\n        value={this.props.squares[i]}\n        onClick={() =\u003e this.props.onClick(i)}\n      /\u003e\n    );\n  }\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cdiv className=\"board-row\"\u003e\n          {this.renderSquare(0)}\n          {this.renderSquare(1)}\n          {this.renderSquare(2)}\n        \u003c/div\u003e\n        \u003cdiv className=\"board-row\"\u003e\n          {this.renderSquare(3)}\n          {this.renderSquare(4)}\n          {this.renderSquare(5)}\n        \u003c/div\u003e\n        \u003cdiv className=\"board-row\"\u003e\n          {this.renderSquare(6)}\n          {this.renderSquare(7)}\n          {this.renderSquare(8)}\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [\n        {\n          squares: Array(9).fill(null)\n        }\n      ],\n      stepNumber: 0,\n      xIsNext: true\n    };\n  }\n\n  handleClick(i) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice();\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\n    this.setState({\n      history: history.concat([\n        {\n          squares: squares\n        }\n      ]),\n      stepNumber: history.length,\n      xIsNext: !this.state.xIsNext\n    });\n  }\n\n  jumpTo(step) {\n    this.setState({\n      stepNumber: step,\n      xIsNext: (step % 2) === 0\n    });\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n    const winner = calculateWinner(current.squares);\n\n    const moves = history.map((step, move) =\u003e {\n      const desc = move ?\n        'Go to move #' + move :\n        'Go to game start';\n      return (\n        \u003cli key={move}\u003e\n          \u003cbutton onClick={() =\u003e this.jumpTo(move)}\u003e{desc}\u003c/button\u003e\n        \u003c/li\u003e\n      );\n    });\n\n    let status;\n    if (winner) {\n      status = \"Winner: \" + winner;\n    } else {\n      status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\n    }\n\n    return (\n      \u003cdiv className=\"game\"\u003e\n        \u003cdiv className=\"game-board\"\u003e\n          \u003cBoard\n            squares={current.squares}\n            onClick={i =\u003e this.handleClick(i)}\n          /\u003e\n        \u003c/div\u003e\n        \u003cdiv className=\"game-info\"\u003e\n          \u003cdiv\u003e{status}\u003c/div\u003e\n          \u003col\u003e{moves}\u003c/ol\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\n// ========================================\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\u003cGame /\u003e);\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6]\n  ];\n  for (let i = 0; i \u003c lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] \u0026\u0026 squares[a] === squares[b] \u0026\u0026 squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}\n```\n\n\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_4.png)\n\n## 디자인 모델 레이어\n\n먼저, Model 레이어에서 데이터 모델을 추출해보세요. 여기에 정의된 모델은 플랫폼과 프레임워크에 독립적이어야 하며, 순수하게 비즈니스 규칙에만 집중해야 합니다.\n\n원본 코드에 명확한 타입 정의가 없더라도, TypeScript의 타입 추론 메커니즘을 활용하기 위해 반드시 해당 타입들을 정의해야 합니다. 이렇게 하면 개발하는 동안 TypeScript가 지원할 수 있습니다.\n\n\n\n```js\nexport type Square = null | \"X\" | \"O\";\n\nexport type Board = Square[];\n\ntype HistoryStep = {\n  board: Board;\n};\n\nexport type History = HistoryStep[];\n```\n\n# 디자인 유스케이스 및 리포지토리 레이어 설계\n\n다음 단계는 유스케이스를 추출하는 것입니다. 유스케이스는 \"X가 발생했을 때, Y를 수행한다\"라고 형식화할 수 있습니다.\n\nReact 애플리케이션에서 유스케이스는 일반적으로 (1) React 프레임워크에서 호출되는 렌더링 함수로 구현되거나, (2) 사용자 입력을 처리하는 이벤트 핸들러, 또는 (3) 자율적인 효과로 구현됩니다. TicTacToe 예제에서는 세 가지 유스케이스가 있습니다.\n\n\n\n\n- render(): 데이터가 업데이트되면이 함수가 호출됩니다.\n- handleClick(i): 보드에서 사각형을 누르면이 함수가 호출됩니다.\n- jumpTo(step): \"이동 #x로 이동\"버튼을 누르면이 함수가 호출됩니다.\n\n그러나 원본 사용 사례 함수 (render(), handleClick(), jumpTo())에는 여러 레이어 (UseCase, Repository, Data, Presentation (react))의 코드가 포함되어 있다는 것을 알게되었습니다. 이 스파게티를 해결하고 적절한 레이어로 코드를 분배해야 합니다.\n\n보통 변수 간의 종속성을 분석하여 이 해결을 시작하고 다른 변수에서도 유추할 수 없는 기본 데이터 소스를 찾습니다. TicTacToe 예에서 아래 그림에 설명된 것처럼 history와 stepNumber 두 가지 주요 데이터 소스를 쉽게 감지할 수 있습니다. 이러한 기본 데이터는 영구 데이터 저장소에 저장해야하며 이를 Data 레이어에 놓습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-CleanArchitectureWithReact_5.png\" /\u003e\n\n\n\nUseCase 레이어와 Repository 레이어 간의 경계를 설계하는 것은 주관적이며 일부는 당신에게 달려 있어. Repository 레이어는 모든 모델별 작업을 보관하는 중심 장소로 정의됩니다. 또한 Repository 레이어에서의 작업을 정의하는 내 정책은 다음과 같습니다:\n\n- Repository 작업은 최소화되어야 합니다. 주요 데이터 소스에 대한 모든 노출된 setter/getter 함수를 노출하는 것은 좋은 아이디어가 아닙니다. 이는 쉽게 유효하지 않거나 일관성 없는 데이터로 이어질 수 있습니다.\n- Repository 작업은 UseCase 레이어에 정의된 비즈니스 로직과 중립적이며 독립적이어야 합니다.\n- 각 Repository 작업은 데이터 소스의 일관성을 유지하기 위해 일괄 작업으로 한 번에 변경할 필요가 있는 경우에만 여러 데이터 소스에 액세스해야 합니다.\n\n이 정책에 따라 UseCase 레이어와 Repository 레이어를 다음과 같이 분리합니다:\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_6.png)\n\n\n\n레포지토리 인터페이스를 정의해 봅시다. 구현은 나중에 이어집니다.\n\n```js\nexport type Step = {\n  board: Board;\n  stepNumber: number;\n  numOfAllSteps: number;\n};\n\n/**\n * 틱택토 단계의 기록을 관리하는 레포지토리.\n * 각 단계는 보드로 이루어져 있습니다.\n */\nexport interface Repository {\n  getCurrentStep(): Promise\u003cStep\u003e;\n  setCurrentStepNumber(stepNumber: number): Promise\u003cvoid\u003e;\n  deleteStepsAfterCurrentStepNumber(): Promise\u003cvoid\u003e;\n  addStep(board: Board): Promise\u003cvoid\u003e;\n}\n```\n\n그런 다음 유즈케이스 함수를 정의할 수 있습니다. 이제 비즈니스 로직을 더 명확하게 이해할 수 있어요.\n\n```js\nexport async function clickOnBoard(\n  indexOnBoard: number,\n  repository: Repository\n) {\n  const { board, stepNumber } = await repository.getCurrentStep();\n  const newBoard = board.slice();\n  if (calculateWinnerOnBoard(newBoard) || newBoard[indexOnBoard]) {\n    return;\n  }\n  newBoard[indexOnBoard] = isNextTurnX(stepNumber) ? \"X\" : \"O\";\n  await repository.deleteStepsAfterCurrentStepNumber();\n  await repository.addStep(newBoard);\n  await repository.setCurrentStepNumber(stepNumber + 1);\n}\n\nexport async function jumpToStep(\n  stepNumber: number,\n  repository: Repository\n): Promise\u003cvoid\u003e {\n  return repository.setCurrentStepNumber(stepNumber);\n}\n```\n\n\n\n# 디자인 프리젠테이션 레이어\n\n프리젠테이션 레이어에서 가장 중요한 팁은 MVC(Model-View-Controller)를 형성하는 것입니다. React 애플리케이션에서는 일반적으로 Presentation 레이어와 UseCase 레이어 사이의 다리 역할을 하는 하나의 객체로 \"모델\"과 \"컨트롤러\"를 통합합니다.\n\n아래 그림에서 TicTacToeModelController를 참조하세요. React 컴포넌트는 MVC에서 \"뷰\"로 작동하며, 사용자 정의 후크를 사용하여 \"모델-컨트롤러\"를 참조합니다. 이렇게 하면 순수한 렌더링 코드(\"뷰\")를 데이터 처리 코드(\"모델\" 및 \"컨트롤러\")에서 분리할 수 있습니다.\n\n\n\n이 코드는 TicTacToeModelController입니다.\n\n```js\nexport function useTicTacToeModelController(repository: Repository) {\n  const [currentStep, setCurrentStep] = useState\u003cStep | null\u003e(null);\n\n  useEffect(() =\u003e {\n    async function init() {\n      const initialStep = await repository.getCurrentStep();\n      setCurrentStep(initialStep);\n    }\n    init();\n  }, []);\n\n  const handleClickOnBoard = async (indexOnBoard: number) =\u003e {\n    await clickOnBoard(indexOnBoard, repository);\n    const newStep = await repository.getCurrentStep();\n    setCurrentStep(newStep);\n  };\n\n  const handleJumpToStep = async (stepNumber: number) =\u003e {\n    await jumpToStep(stepNumber, repository);\n    const newStep = await repository.getCurrentStep();\n    setCurrentStep(newStep);\n  };\n\n  return {\n    currentStep,\n    handleClickOnBoard,\n    handleJumpToStep,\n  };\n}\n```\n\n그리고 여기는 TicTacToeView입니다.\n\n```js\ntype TicTacToeViewProps = {\n  repository: Repository;\n};\n\nexport function TicTacToeView({ repository }: TicTacToeViewProps) {\n  const { currentStep, handleClickOnBoard, handleJumpToStep } =\n    useTicTacToeModelController(repository);\n\n  if (!currentStep) {\n    return null;\n  }\n\n  const winner = calculateWinnerOnBoard(currentStep.board);\n  const xIsNext = isNextTurnX(currentStep.stepNumber);\n  return (\n    \u003cdiv className=\"game\"\u003e\n      \u003cdiv className=\"game-board\"\u003e\n        \u003cBoardView board={currentStep.board} onClick={handleClickOnBoard} /\u003e\n      \u003c/div\u003e\n      \u003cdiv className=\"game-info\"\u003e\n        \u003cStatusView winner={winner} xIsNext={xIsNext} /\u003e\n        \u003cJumpToStepButtons\n          numOfAllSteps={currentStep.numOfAllSteps}\n          onClick={handleJumpToStep}\n        /\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n# 데이터 레이어 디자인\n\n데이터 레이어는 두 개의 서브 레이어로 구성됩니다. 데이터:저장소 레이어는 도메인:저장소 레이어에 정의된 동작을 구현하는 레이어입니다. 데이터:데이터원 레이어는 실제 데이터 저장소를 구현하는 곳으로, 예를 들어 메모리 저장소 또는 네트워크 저장소가 있습니다.\n\n아래 그림에서 보듯이, 도메인:저장소 레이어(위쪽 레이어)와 데이터:저장소 레이어(아래쪽 레이어) 사이에 의존성 역전 원칙을 적용합니다. 제어 흐름은 아래로 진행됩니다(예: 도메인이 데이터를 사용함), 그러나 소스 코드 의존성은 위로 향합니다.\n\n\n\n여기에 RepositoryImpl이 있습니다:\n\n```js\nexport class RepositoryImpl implements Repository {\n  dataSource: DataSource;\n\n  constructor(dataSource: DataSource) {\n    this.dataSource = dataSource;\n  }\n\n  async getCurrentStep(): Promise\u003cStep\u003e {\n    const [history, stepNumber] = await Promise.all([\n      this.dataSource.getHistory(),\n      this.dataSource.getStepNumber(),\n    ]);\n    const board = history[stepNumber].board;\n    const numOfAllSteps = history.length;\n\n    return { board, stepNumber, numOfAllSteps };\n  }\n\n  async setCurrentStepNumber(stepNumber: number): Promise\u003cvoid\u003e {\n    const history = await this.dataSource.getHistory();\n    if (stepNumber \u003c history.length) {\n      await this.dataSource.setStepNumber(stepNumber);\n    } else {\n      throw Error(\n        `Step number ${stepNumber} should be smaller than the history size (${history.length})`\n      );\n    }\n  }\n\n  async deleteStepsAfterCurrentStepNumber(): Promise\u003cvoid\u003e {\n    const [history, stepNumber] = await Promise.all([\n      this.dataSource.getHistory(),\n      this.dataSource.getStepNumber(),\n    ]);\n    const trimmedHistory = history.slice(0, stepNumber + 1);\n    await this.dataSource.setHistory(trimmedHistory);\n  }\n\n  async addStep(board: Board): Promise\u003cvoid\u003e {\n    const history = await this.dataSource.getHistory();\n    history.push({ board });\n    await this.dataSource.setHistory(history);\n  }\n}\n```\n\n# 디자인 메인 레이어\n\n마지막으로, 몇 개의 레이어에서 모든 구성 요소를 하나의 애플리케이션으로 짜바랍니닷.\n\n\n\n이 부트스트랩 코드에서는 저장소 구현을 만들고 TicTacToeView에 전달합니다. 그런 다음 저장소는 TicTacToeModelController를 통해 UseCase 레이어에 전달됩니다.\n\n```js\n// 의존성 주입\nconst dataSource = new OnMemoryDataSourceImpl();\nconst repository = new RepositoryImpl(dataSource);\n\nexport function App() {\n  return \u003cTicTacToeView repository={repository} /\u003e;\n}\n```\n\n이것은 의존성 주입(Dependency Injection, DI)이라는 기술입니다. 아래 다이어그램에서 보듯이, UseCase 레이어는 Repository 레이어를 사용하며 의존합니다. 그러나 UseCase 레이어의 코드에서는 하위 레이어(Data 레이어)에 의존하는 실제 객체를 Repository 레이어에서 만들어서는 안됩니다.\n\n객체 생성(Main 레이어)과 객체 사용(UseCase 레이어)을 분리함으로써, 의존성 규칙을 깨지 않고(lower layer에서 upper layer로 모든 참조 화살표가 위쪽 방향을 가져야 함) 인 것을 피할 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-CleanArchitectureWithReact_9.png)\n\n여기까지입니다! 최종 소스 코드를 확인할 수 있습니다.\n\n# 결론\n\nReact 애플리케이션 코드를 깔끔한 아키텍처로 변환하는 방법을 보여드렸습니다. 깔끔한 아키텍처에 익숙해지면 처음부터 깔끔한 아키텍처에 부합하는 코드를 설계할 수 있게 될 것입니다. 그러나 그런 경우에도 이 글에서 설명한 디자인 프로세스가 리팩터링에 좋은 안내를 제공해 줄 것으로 기대합니다.","ogImage":{"url":"/assets/img/2024-05-14-CleanArchitectureWithReact_0.png"},"coverImage":"/assets/img/2024-05-14-CleanArchitectureWithReact_0.png","tag":["Tech"],"readingTime":13},{"title":"React Native 웹 뷰와 React 앱 간의 통신","description":"","date":"2024-05-14 11:40","slug":"2024-05-14-CommunicationbetweenReactNativewebviewandReactapp","content":"\n\n이것은 React Native 웹 뷰와 React 응용 프로그램 간의 데이터 통신 방법 중 하나입니다.\n\n![CommunicationbetweenReactNativewebviewandReactapp](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png)\n\nReact Native 앱의 웹 뷰와 별도로 호스팅된 React 애플리케이션 간의 통신 방법은 여러 가지가 있을 수 있습니다. 저는 이러한 요구사항을 마주했고, 여기에 적용하기로 결정한 해결책을 공유하려 합니다.\n\n먼저, React 응용 프로그램과 React Native 응용 프로그램의 기본 구현을 살펴보겠습니다.\n\n\n\n간단한 React 어플리케이션:-\n\n- App.js의 useEffect() 안에 원시 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이는 HTML의 \"window\" 객체 내에 존재합니다. EventTarget 인터페이스의 addEventListener() 메소드는 특정 이벤트가 대상에 전달될 때마다 호출될 함수를 설정합니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n- 첨부한 리스너 함수 안에서는 React 네이티브 또는 HTML 문서로 전송되는 외부 소스에서 찾을 수 있는 데이터가 포함된 nativeEvent 객체를 얻습니다.\n- React에서 React 네이티브로 메시지를 보내려면 window.ReactNativeWebView.postMessage() 메소드를 사용할 수 있습니다. 추가적인 임포트나 패키지가 필요하지 않습니다. 이는 HTML의 \"window\" 객체에 내장되어 있습니다. window.postMessage() 메소드는 Window 객체 간 안전하게 교차 출처 통신을 가능하게 합니다. 예를 들어 페이지와 생성된 팝업 간 또는 페이지와 내장된 iframe 간의 통신입니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n\n\u003cimg src=\"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_1.png\" /\u003e\n\n간단한 React 네이티브 어플리케이션과 웹 뷰:-\n\n\n\n- 어떤 npm 패키지에서 간단한 웹뷰를 생성합니다.\n- 웹사이트에서 메시지를 받으려면 웹뷰의 onMessage = '' 속성을 가리키는 메소드를 첨부합니다. 해당 함수에서 들어오는 메시지를 처리할 수 있습니다.\n- React로 메시지를 보내려면 useRef()를 사용하여 참조를 가져와야 합니다. ref = 'webViewRef'와 함께 첨부합니다.\n- webViewRef.current.postMessage()를 사용하여 React 웹사이트로 메시지를 보낼 수 있습니다.\n- componentDidMount() 시점에 뭔가를 트리거하려면, webview의 onLoadEnd() 속성에 필요한 메소드를 추가하여 할 수 있습니다. 이것은 웹뷰가 웹사이트를 로드했을 때 콜백을 트리거합니다.\n- 최신 버전의 userAgents를 언급했습니다. 또한 domStorageEnabled, cacheEnabled, javaScriptEnabled 등과 같은 프롭스를 활성화하여 React Native 스크린의 성능이 향상되도록 했습니다.\n- 사이트가 로드될 때까지 사용자 정의 로더를 표시할 수도 있습니다.\n\n[이미지 바로가기](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_2.png)\n\n저의 Github 저장소 공유합니다: [react-zoom](https://github.com/svbala99/react-zoom) 및 [zoomsdk-sign-generator-express](https://github.com/svbala99/zoomsdk-sign-generator-express)\n\n이 저장소들은 React Native에서 웹뷰를 설정할 수 있게 해주고, 해당 웹뷰에서 zoom 미팅을 호스팅할 수 있게 합니다. 두 번째 저장소는 안전한 서명을 생성하는 데 도움이 됩니다. 이는 공식 Zoom에서 지시한 대로 입니다.\n\n\n\n누군가에게 도움이 되면 좋겣습니다. 읽어 주셔서 감사합니다. 또 다른 흥미로운 글로 돌아오겠습니다. 건강하세요, 챙기세요!!!","ogImage":{"url":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png","tag":["Tech"],"readingTime":3},{"title":"이 Go 라이브러리는 혁신적입니다","description":"","date":"2024-05-14 11:39","slug":"2024-05-14-ThisGoLibraryIsGameChanging","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png\" /\u003e\n\nReact의 강력한 기능 중 하나는 JSX입니다. React는 렌더링 로직이 다른 UI 로직과 본질적으로 결합되어 있다는 사실을 받아들입니다. Jinja와 같은 템플릿 엔진을 사용하는 것은 데이터를 컴포넌트로 전달하는 대신 엔진에 문맥을 '전달'해야 한다는 사실로 인해 같은 경험을 제공해주지 않습니다.\n\n# Templ은 HTML과 Go 사이의 간격을 좁히려고 합니다\n\n```js\npackage main\n\n// 우리 Component에서 사용할 수 있는 일반 Go 코드\nvar greeting = \"환영합니다!\"\n\n// templ Component\ntempl headerTemplate(name string) {\n  \u003cheader\u003e\n    \u003ch1\u003e{ name }\u003c/h1\u003e\n    \u003ch2\u003e\"{ greeting }\"은 일반 Go 코드에서 옵니다\u003c/h2\u003e\n  \u003c/header\u003e\n}\n```\n\n\n\n다음과 같이 templ은 Go에 자체 구문을 추가하지만 기본적으로 함수처럼 작동합니다.\n\n# 구성\n\n## Templ\n\n```js\npackage components\n\ntempl Link(name string, path string) {\n    - \u003cli\u003e\n    -     \u003ca href={templ.URL(path)}\u003e{name}\u003c/a\u003e\n    - \u003c/li\u003e\n}\n\ntempl NavBar() {\n    - @Link(\"Home\", \"home\")\n    - @Link(\"News\", \"news\")\n    - @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n\n\n## 리엑트\n\n```js\nfunction Welcome(props) {\n  return \u003ch1\u003e안녕, {props.name}\u003c/h1\u003e;\n}\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003cWelcome name=\"사라\" /\u003e\n      \u003cWelcome name=\"카할\" /\u003e\n      \u003cWelcome name=\"에디트\" /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n보시다시피 구문은 매우 유사합니다. 리엑트 컴포넌트는 HTML 스타일 요소로 변합니다.\n\n# For 루프\n\n\n\n```js\npackage main\n\ntempl nameList(items []Item) {\n  \u003cul\u003e\n  for _, item := range items {\n    \u003cli\u003e{ item.Name }\u003c/li\u003e\n  }\n  \u003c/ul\u003e\n}\n```\n\n여기서 Javascript가 약간 뛰어나다고 할 수 있습니다. Javascript에는 배열을 쉽게 반복할 수 있는 Map 함수와 같은 작은 도우미들이 많이 있습니다.\n\n# Javascript\n\n문법이 React와 비슷해 보이지만, 완전히 다릅니다. Templ은 Javascript와 상호 작용할 수 없도록 제한됩니다.\n\n\n\n```js\ntempl body() {\n \u003cscript\u003e\n  const chart = LightweightCharts.createChart(document.body, { width: 400, height: 300 });\n  const lineSeries = chart.addLineSeries();\n  lineSeries.setData([\n    { time: '2019-04-11', value: 80.01 },\n    { time: '2019-04-12', value: 96.63 },\n    { time: '2019-04-13', value: 76.64 },\n    { time: '2019-04-14', value: 81.89 },\n    { time: '2019-04-15', value: 74.43 },\n    { time: '2019-04-16', value: 80.01 },\n    { time: '2019-04-17', value: 96.63 },\n    { time: '2019-04-18', value: 76.64 },\n    { time: '2019-04-19', value: 81.89 },\n    { time: '2019-04-20', value: 74.43 },\n  ]);\n \u003c/script\u003e\n}\n```\n\n템플은 그냥 템플릿 엔진일 뿐이에요. 텍스트를 합쳐주는 거죠.\n\n# 템플 설치하기\n\n```js\ngo install github.com/a-h/templ/cmd/templ@latest\n```\n\n\n\n# Templ은 어떻게 작동하나요?\n\nTempl 문서에서는 모든 .templ 파일을 components 폴더/패키지에 저장하는 것을 권장합니다.\n\n```js\n//navbar.templ\npackage components\n\ntempl Link(name string, path string) {\n    \u003cli\u003e\n        \u003ca href={templ.URL(path)}\u003e{name}\u003c/a\u003e\n    \u003c/li\u003e\n}\n\ntempl NavBar() {\n    @Link(\"Home\", \"home\")\n    @Link(\"News\", \"news\")\n    @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n그런 다음 .templ 파일을 만든 후 다음 명령을 실행하면 됩니다:\n\n\n\n```js\ntempl generate\n```\n\n그런 다음, 코드 생성을 사용하여 별도의 ‘navbar_templ.go’ 파일을 생성합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_1.png\" /\u003e\n\n그런 다음 핸들러에서는 간단히 Render 함수를 호출할 수 있습니다.\n\n\n\n\n```js\npackage main\n\nimport (\n\"context\"\n\"templ-echo-test/components\"\n\n\"github.com/labstack/echo/v4\"\n)\n\nfunc Page(c echo.Context) error {\nreturn components.NavBar().Render(context.Background(), c.Response())\n}\n```\n\n코드 생성 패스 없이는 Go가 .templ 파일을 읽을 수 없습니다.\n\n# 핫 리로드\n\ntempl을 사용하는 Go 웹 애플리케이션에 웹 브라우저에서 액세스하려면 몇 가지 일이 발생해야 합니다:\n\n\n\n\n- templ generate 명령을 실행하여 *.templ 파일에서 Go 코드 (*_templ.go 파일)를 생성해야 합니다.\n- Go 코드는 포트에서 웹 서버를 시작해야 합니다. 예: (http.ListenAndServe(\"localhost:8080\", nil).\n- Go 프로그램을 실행해야 합니다. 예: go run .. 명령으로 실행합니다.\n- 웹 브라우저가 페이지에 접속하거나 새로고침해야 합니다. 예: http://localhost:8080.\n\n만약 *.templ 파일이 변경되면, #1과 #2를 실행해야 합니다.\n\n만약 *.go 파일이 변경되면, #3과 #4를 실행해야 합니다.\n\nTempl은 이러한 작업을 자동으로 수행하는 내장 툴을 제공합니다. Air와 같은 도구들도 사용할 수 있지만, 내장된 툴처럼 페이지를 자동으로 새로고침하지는 않습니다.\n\n\n\n아래 명령어를 실행하여 설정을 합니다\n\n```js\ntempl generate --watch --proxy=\"http://localhost:8080\" --cmd=\"go run .\"\n```\n\n# 내 이북을 확인해보세요: Go로 풀스택 애플리케이션 작성하기\n\nhttps://harryhtml.gumroad.com/l/tdbxl","ogImage":{"url":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png"},"coverImage":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 네이티브에서 네이티브 모듈 생성하기","description":"","date":"2024-05-14 11:38","slug":"2024-05-14-CreatingaNativeModuleinReactNative","content":"\n\n리액트 네이티브는 JavaScript와 React를 사용하여 모바일 앱을 개발할 수 있게 해주는 인기 있는 프레임워크입니다. 때때로 자바스크립트에서 사용할 수 없는 플랫폼별 기능에 액세스해야 할 수도 있습니다. 이때 네이티브 모듈이 필요한데, 이를 통해 iOS의 Swift나 안드로이드의 코틀린과 같은 네이티브 언어로 코드를 작성하여 사용할 수 있습니다.\n\n## 네이티브 모듈이란?\n\n네이티브 모듈은 JavaScript로 처리할 수 없는 작업을 수행할 수 있도록 해주는, 네이티브 플랫폼 언어(Swift, Kotlin 등)로 작성된 코드 조각입니다. 디바이스 하드웨어 기능에 액세스하거나 복잡한 계산을 수행하는 것 등이 그 예시에 해당합니다.\n\n## 요구 사항\n\n\n\n시작하기 전에 설치해야 할 사항들을 확인해 주세요:\n\n- Node.js와 npm\n- React Native CLI\n- Xcode (iOS 개발을 위해)\n- 안드로이드 스튜디오 (Android 개발을 위해)\n\n## 단계별 안내\n\n1. 개발 환경 설정하기\n\n\n\n우선, 아직 React Native 프로젝트를 설정하지 않았다면 다음을 따르세요:\n\n```js\nnpx react-native init MyNativeModuleProject\ncd MyNativeModuleProject\n```\n\n2. 네이티브 모듈 생성\n\niOS 및 Android 모두에서 기기 정보를 제공하는 네이티브 모듈을 생성해봅시다.\n\n\n\n안드로이드용으로:\n\n- Kotlin 파일 생성: 안드로이드 프로젝트 디렉토리로 이동하세요:\n\n```js\ncd android/app/src/main/java/com/mynativemoduleproject/\n```\n\n- 패키지 내에 DeviceInfoModule.kt라는 새로운 Kotlin 파일을 생성하세요.\n- Kotlin 파일 편집:\n\n\n\n이 네이티브 모듈의 Kotlin 코드입니다:\n\n```js\npackage com.mynativemoduleproject\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport com.facebook.react.bridge.Promise\n\nclass DeviceInfoModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName(): String {\n        return \"DeviceInfo\"\n    }\n\n    @ReactMethod\n    fun getDeviceInfo(promise: Promise) {\n        try {\n            val deviceInfo = mapOf(\"device\" to android.os.Build.MODEL, \"OS\" to android.os.Build.VERSION.RELEASE)\n            promise.resolve(deviceInfo)\n        } catch (e: Exception) {\n            promise.reject(\"Error\", e.localizedMessage)\n        }\n    }\n}\n```\n\n이 모듈은 기기 모델과 OS 버전을 반환합니다.\n\n시각적 표현:\n\n\n\n- 모듈 등록하기: 이 모듈을 당신의 주 애플리케이션 파일에 등록해야 합니다.\n- MainApplication.java 파일 편집하기:\n\n```js\npackage com.mynativemoduleproject;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.shell.MainReactPackage;\nimport com.facebook.soloader.SoLoader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MainApplication extends Application implements ReactApplication {\n\n    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {\n        @Override\n        public boolean getUseDeveloperSupport() {\n            return BuildConfig.DEBUG;\n        }\n\n        @Override\n        protected List\u003cReactPackage\u003e getPackages() {\n            return Arrays.\u003cReactPackage\u003easList(\n                new MainReactPackage(),\n                new DeviceInfoPackage()  // 여기에 패키지 등록\n            );\n        }\n\n        @Override\n        protected String getJSMainModuleName() {\n            return \"index\";\n        }\n    };\n\n    @Override\n    public ReactNativeHost getReactNativeHost() {\n        return mReactNativeHost;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        SoLoader.init(this, /* native exopackage */ false);\n    }\n}\n```\n\niOS 경우:\n\n- Swift 파일 생성하기: Xcode에서 iOS 프로젝트 디렉토리로 이동한 후 MyDeviceInfo.swift라는 새로운 Swift 파일을 생성합니다.\n- Swift 파일 편집하기:\n\n\n\n여기 네이티브 모듈을 위한 Swift 코드가 있어요:\n\n```js\n// MyDeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(MyDeviceInfo)\nclass MyDeviceInfo: NSObject {\n\n  @objc\n  func getDeviceInfo(_ callback: RCTResponseSenderBlock) {\n    callback([nil, [\"device\": UIDevice.current.model, \"OS\": UIDevice.current.systemVersion]])\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -\u003e Bool {\n    return true\n  }\n}\n```\n\n이 코드 스니펫은 안드로이드 버전과 유사한 기능을 제공하여, 디바이스 모델과 OS 버전을 반환해 주는 거예요.\n\n비주얼 표현:\n\n\n\n- 모듈 등록: Bridging-Header.h 파일을 편집하여 Swift 파일이 React Native에서 보이도록 합니다:\n\n```js\n#import \"React/RCTBridgeModule.h\"\n```\n\n- JavaScript에서 네이티브 모듈 사용\n\n이제 JavaScript 코드에서 네이티브 모듈을 사용할 수 있습니다.\n\n\n\n```js\nimport React, { Component } from 'react';\nimport { View, Text, NativeModules } from 'react-native';\n\nconst { DeviceInfo } = NativeModules;\n\nclass App extends Component {\n  state = {\n    deviceInfo: {}\n  };\n\n  componentDidMount() {\n    DeviceInfo.getDeviceInfo((error, info) =\u003e {\n      if (error) {\n        console.error(error);\n      } else {\n        this.setState({ deviceInfo: info });\n      }\n    });\n  }\n\n  render() {\n    const { deviceInfo } = this.state;\n    return (\n      \u003cView style={ flex: 1, justifyContent: 'center', alignItems: 'center' }\u003e\n        \u003cText\u003e기기 모델: {deviceInfo.device}\u003c/Text\u003e\n        \u003cText\u003eOS 버전: {deviceInfo.OS}\u003c/Text\u003e\n      \u003c/View\u003e\n    );\n  }\n}\n\nexport default App;\n```\n\n이 React 컴포넌트는 네이티브 모듈에서 불러온 기기 정보를 표시합니다.\n\n## 결론\n\nReact Native에서 네이티브 모듈을 생성하는 것은 플랫폼별 코드를 활용하여 앱의 기능을 확장하는 강력한 방법입니다. 이 단계를 따르면 네이티브 기능에 액세스하여 모바일 애플리케이션을 효과적으로 강화할 수 있습니다. 즐거운 코딩하세요!\n\n\n\n\n참고 : https://reactnative.dev/docs/native-modules-android","ogImage":{"url":"/assets/img/2024-05-14-CreatingaNativeModuleinReactNative_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingaNativeModuleinReactNative_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 htmx를 사용해야 할까요","description":"","date":"2024-05-14 11:37","slug":"2024-05-14-Whyhtmx","content":"\n\n![이미지](/assets/img/2024-05-14-Whyhtmx_0.png)\n\nHTMX는 JavaScript 라이브러리로, JavaScript를 작성할 필요 없이 HTML에서 직접 최신 브라우저 기능에 액세스할 수 있게 해줍니다. 이는 HTML 구문을 확장하여 AJAX, 웹소켓 및 서버 전송 이벤트와 같은 기능을 HTML에서 바로 사용할 수 있도록 합니다.\n\n클릭 버튼을 구현하고 싶다면 아마도 아래의 HTML과 JavaScript 코드를 작성해야 할 것입니다.\n\n![이미지](/assets/img/2024-05-14-Whyhtmx_1.png)\n\n\n\nhtmx를 사용하면 간단히 다음을 할 수 있어요:\n\n![Whyhtmx_2.png](/assets/img/2024-05-14-Whyhtmx_2.png)\n\n정말 간단하고 쉬워요.\n\nHTMX에서 hx-swap은 서버 요청으로 반환된 콘텐츠가 요소의 현재 콘텐츠를 대체하는 방법을 결정하는 속성입니다.\n\n\n\n\"hx-swap=\"outerHTML\"\"를 설정하면 해당 요소 전체(오픈 및 클로징 태그 포함)가 서버 응답으로 교체됩니다.\n\n예를 들어, 이 HTMX 코드를 살펴보십시오:\n\n```js\n\u003cdiv id=\"myDiv\" hx-get=\"/some/url\" hx-swap=\"outerHTML\"\u003eOriginal Content\u003c/div\u003e\n```\n\n“/some/url\"로의 요청이 발생하고 서버가 `span`New Content`/span`으로 응답하는 경우, hx-swap=\"outerHTML\"은 서버 응답으로 전체 div 요소를 교체합니다.\n\n\n\n서버에서 응답을 받은 후에, HTML이 다음과 같이 변경됩니다:\n\n```js\n\u003cspan\u003eNew Content\u003c/span\u003e\n```\n\n원본의 `div` 요소와 그 내용(\"Original Content\")은 완전히 새로운 `span` 요소로 대체되었습니다.\n\n## 리액트, 앵귤러, 뷰와 작별인가요?\n\n\n\n백엔드 개발자로서, 위의 프레임워크 중 하나를 배우는 것보다 htmx를 배우는 것이 훨씬 가벼운 일입니다.\n\n다음은 HTMX를 사용할 이유가 있는 몇 가지 이유입니다:\n\n간편함:\n\nHTMX는 HTML을 확장하여 JavaScript를 작성할 필요 없이 마크업에 직접 상호 작용성을 추가할 수 있습니다. 이렇게 하면 코드를 이해하고 유지하기 쉬울 수 있습니다.\n\n\n\n점진적 향상:\nHTMX를 사용하면 필요한 곳에 상호작용성을 추가하면서 전체 프론트엔드 코드를 완전히 다시 작성할 필요가 없이 HTML을 점진적으로 향상시킬 수 있습니다.\n\n서버 측 렌더링:\nHTMX를 사용하면 페이지의 대부분 컨텐츠에 대해 서버 측 렌더링을 활용할 수 있어서 성능과 SEO를 향상시킬 수 있습니다.\n\n\n\n적은 양의 자바스크립트:\n\nHTMX는 SPA 프레임워크보다 적은 양의 자바스크립트를 필요로 하며, 이는 더 빠른 로드 시간과 적은 복잡성으로 이어질 수 있습니다.\n\n기존 프로젝트 통합:\n\nHTMX는 많은 SPA 프레임워크와 달리 완전한 재작성 없이 기존 프로젝트에 쉽게 추가할 수 있습니다.\n\n\n\n하지만 HTMX가 모든 프로젝트에 가장 적합한 선택은 아닐 수 있습니다. React, Angular 및 Vue와 같은 SPA 프레임워크는 더 많은 기능을 제공하며 복잡하고 상태를 가지는 애플리케이션을 구축하기에 더 적합합니다. 최상의 선택은 프로젝트의 구체적인 요구 사항에 따라 다릅니다.\n\n내 경우에는 프로젝트 초기 단계에서 다른 것들보다 HTMX를 시도해 볼 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-Whyhtmx_0.png"},"coverImage":"/assets/img/2024-05-14-Whyhtmx_0.png","tag":["Tech"],"readingTime":2}],"page":"116","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"116"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>