<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/98" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/98" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="파워 BI로 복잡한 데이터 필터링하기 사례 연구" href="/post/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파워 BI로 복잡한 데이터 필터링하기 사례 연구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파워 BI로 복잡한 데이터 필터링하기 사례 연구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파워 BI로 복잡한 데이터 필터링하기 사례 연구</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SigmaHQ Rules 릴리스 하이라이트  r2024-05-13" href="/post/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SigmaHQ Rules 릴리스 하이라이트  r2024-05-13" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SigmaHQ Rules 릴리스 하이라이트  r2024-05-13" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SigmaHQ Rules 릴리스 하이라이트  r2024-05-13</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요" href="/post/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="맥OS 및 리눅스용 SSH 키 생성기" href="/post/2024-05-15-SSHKeyGeneratorforMacOSLinux"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="맥OS 및 리눅스용 SSH 키 생성기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="맥OS 및 리눅스용 SSH 키 생성기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">맥OS 및 리눅스용 SSH 키 생성기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 175가 출시되었습니다 지금 바로 시도해 볼 5가지 멋진 기능" href="/post/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 175가 출시되었습니다 지금 바로 시도해 볼 5가지 멋진 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 175가 출시되었습니다 지금 바로 시도해 볼 5가지 멋진 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">iOS 175가 출시되었습니다 지금 바로 시도해 볼 5가지 멋진 기능</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="레귤러 함수에서 컴포저블을 호출하는 것이 불가능한 이유" href="/post/2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="레귤러 함수에서 컴포저블을 호출하는 것이 불가능한 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="레귤러 함수에서 컴포저블을 호출하는 것이 불가능한 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">레귤러 함수에서 컴포저블을 호출하는 것이 불가능한 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테라폼을 사용한 Sumo Logic 통합" href="/post/2024-05-15-Sumologicintegrationusingterraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테라폼을 사용한 Sumo Logic 통합" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-Sumologicintegrationusingterraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테라폼을 사용한 Sumo Logic 통합" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">테라폼을 사용한 Sumo Logic 통합</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kubernetes 복잡성 해결하기 파트 I" href="/post/2024-05-15-NavigatingKubernetesComplexityPartI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kubernetes 복잡성 해결하기 파트 I" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kubernetes 복잡성 해결하기 파트 I" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Kubernetes 복잡성 해결하기 파트 I</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="최근 놓치고 있는 도커 빌드킷의 기능들" href="/post/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="최근 놓치고 있는 도커 빌드킷의 기능들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="최근 놓치고 있는 도커 빌드킷의 기능들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">최근 놓치고 있는 도커 빌드킷의 기능들</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 보안 Databricks의 열 수준 암호화" href="/post/2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 보안 Databricks의 열 수준 암호화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 보안 Databricks의 열 수준 암호화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 보안 Databricks의 열 수준 암호화</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link posts_-active__YVJEi" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"파워 BI로 복잡한 데이터 필터링하기 사례 연구","description":"","date":"2024-05-15 04:03","slug":"2024-05-15-FilteringComplexDatawithPowerBIACaseStudy","content":"\n\n![2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png)\n\n시작해 봅시다.\n\n안녕하세요, 데이터 열정가 여러분!\n\n데이터가 제멋대로 안 맞을 때 곤욕을 겪어본 적이 있나요? 제게도 그랬어요. 하지만 문제는 항상 뭔가 새로운 것을 배울 수 있는 기회라고 하죠. 그래서 저의 프로젝트에서 최근에 경험한 요구 사항에 대해 이야기해보려고 해요. Power BI에서 굉장히 고집 센 데이터와 씨름해야 했던 일에 대해 말이죠.\n\n\n\n상상해보세요: 클라이언트가 데이터 더미를 전달했는데, 이 데이터는 필터링을 시도해도 혼란스럽다고 느끼게 할 것 같습니다. 이것은 클라이언트의 잘못이 아니에요. 단순히 데이터의 문제일 뿐이죠. 하지만 수동으로 거두기보다는 Power BI의 다양한 기능을 파헤치는 기회로 삼았습니다.\n\n이 블로그 포스트에서는 Power BI에서 데이터 필터링을 탐색하는 과정을 공유할 거에요. 그 과정에서 Power BI를 완전히 새로운 수준에서 이해할 수 있게 도와준 몇 가지 중요한 개념에 대해 소개할 예정이에요.\n\n그래서, 소매 팔뚝을 걷어 올리고, 한 걸음 한 걸음 데이터 필터링 도전에 어떻게 극복했는지 알아보겠습니다.\n\n# 요구 사항 이해하기\n\n\n\n일단 보자마자 이 작업은 간단해 보였습니다: Power BI에서 슬라이서를 구현하여 특정 필드를 기반으로 데이터를 필터링하는 것입니다. 슬라이서를 클릭하면 데이터가 적절하게 조정되어 중복 행 없이 제공된 것과 정확히 일치하게 표시되어야 합니다. 간단하죠? 그렇지만, 사실 그렇지 않았습니다. 여기서 재미있는 일이 벌어졌습니다.\n\n# 도전 과제\n\n도전의 핵심은 필터링해야 할 필드의 특성에 있었습니다. 이 필드는 한 행당 하나의 단일 값이 포함되는 대신, 아래 그림에서 보여지는 것처럼 한 행에 여러 값이 포함될 수 있었습니다. 그러면 아마 궁금해 할 것입니다. 이게 문제인 이유는 무엇일까요?\n\n![그림](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_1.png)\n\n\n\n첫 번째 난관은 필드를 슬라이서 위로 끌어다 놓으려고 시도했을 때 발생한 당연한 문제였어요. 이게 그 문제죠: 필드에 여러 값을 포함할 수 있기 때문에, 슬라이서가 예상대로 작동하지 않았다는 거죠. 선택할 discrete 옵션을 깔끔하게 표시하는 대신, 값들의 얽힌 혼동스러운 모습이 나왔죠. 말할 필요도 없이, 이것이 내 고객이 원하는 것은 아니었습니다.\n\n슬라이서는 사용자가 선택한 기준에 따라 시각적으로 데이터를 필터링하는 도구로, 차트, 그래프, 또는 테이블과 같은 시각화된 데이터에서 데이터를 상호작용적으로 필터링할 수 있게 해줍니다. 데이터를 잘게 썰고 다루는 사용자 친화적인 방법을 제공하여 사용자가 기존 데이터 모델이나 쿼리를 수정하지 않고도 데이터의 특정 하위 집합에 집중할 수 있게 합니다. 슬라이서는 날짜, 범주, 숫자 범위와 같은 다양한 유형의 데이터 필드에 적용될 수 있으며, 사용자는 슬라이서에서 하나 이상의 값을 선택하여 시각화를 상응하게 필터링할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_2.png)\n\n다음으로 마주한 어려움은 슬라이서에서 중복되지 않는 값만 표시하는 방법과 동시에 여러 값을 포함하는 행들에서 값을 추출하는 것이었습니다. 몇 가지 아이디어 회의 끝에, 우리가 해결책을 찾았다고 생각했어요: Power BI에서 모든 중복되지 않는 값을 추출하는 별도의 테이블을 만드는 것. 이 접근 방식은 중복되지 않는 값을 제공했지만, 우리의 기대에 미치지 못했어요. 단 하나의 키워드와 정확히 일치하는 행만 보여주고 다른 변형이나 추가 키워드를 포함하는 행은 제외했죠. 또한, 이 새로운 테이블을 어떻게 생성하는지 주의해주지 않으면, 뒤에 더 많은 도전 과제를 안겨줄 수 있습니다. 이것에 대해 더 자세히 논의할 거예요.\n\n\n\n만난 도전이 나를 깊게 파고들게 만들었어요. 기억해주세요, 해결한 모든 문제는 작은 것일지라도 앞으로 한걸음 나아가는 것입니다. 그래서, 다음 단계로 가기 위해 슬라이서 안의 고유 값이 그 키워드를 포함하는 행을 필터링하도록 보장하기 위해 노력했어요.\n\n예를 들어, \"subject\"라는 필드를 생각해보죠. 값으로 \"CO, CN,\" \"CO,\" \"Python,\" \"DAA\" 같은 것이 있을 수 있습니다. \"CO\"를 클릭하면 \"CO, CN\"과 \"CO\"를 가진 행을 검색해야 합니다. 이 문제를 해결하기 위해 우리는 해결책을 고안했습니다: 두 개의 열을 가진 테이블을 만드는 것입니다. 한 열은 슬라이서의 고유 값이 들어가고, 다른 하나는 클릭했을 때 표시해야 하는 해당 값이 들어갈 거예요. 그러나, 이 방법은 중복을 생산할 수밖에 없습니다. 이를 해결하기 위해, 두 열을 선택하고 중복된 행을 제거했어요.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_3.png)\n\n다음 도전은 이 테이블과 주요 문제가 있는 주 테이블 간의 관계를 설정하는 것이었어요.\n\n\n\n테이블을 만들면서 독특한 과제가 있었어요. 해당 테이블에 기본 키가 없었거든요. 데이터의 특성으로 인해 두 열 모두 고유한 값을 가지지 않았죠. 예를 들어, 필드에는 “CO, CN\" 및 “CN, CO\"와 같은 값이 포함될 수 있었어요. 이러한 상황에서 “CO\"는 두 값 모두에 매핑되어야 했고, “CN\"도 그렇죠. 두 열 모두 고유한 값이 없는 상황에서 전통적인 기본 키 설정은 불가능했어요. 떠오른 해결책 중 하나는 주 데이터 세트 테이블과 새로 만든 테이블을 많이-대-많이(Many-to-Many) 관계로 연결하는 것이었어요. 그러나 신중한고려 끝에, 이 접근 방식에 대해 결정을 내렸어요. 많이-대-많이 관계는 복잡성을 도입하고 예상치 못한 결과나 성능 문제를 야기할 수 있어요. 데이터 집계를 모호하게 만들며, 데이터 모델을 복잡하게하고, 특히 대규모 데이터 세트에서는 성능에 영향을 미칠 수 있기 때문이죠. 따라서 더 효율적이고 관리하기 쉬운 해결책을 찾기로 했어요.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_4.png)\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_5.png)\n\n# 문제 해결\n\n\n\n이전에 언급한 여러 어려움을 극복한 후에, 저는 효율적이고 효과적인 해결책에 도달했습니다. 이 해결책은 데이터 필터링 요구 사항의 복잡성을 해결하면서 내 클라이언트의 요구를 충족하는 간소화된 접근 방식을 제공했습니다. 신중한 실험과 문제 해결을 통해, 작동뿐만 아니라 Power BI 기능에 대한 이해를 향상시키는 방법을 발견했습니다. 이제 솔루션으로 들어가 봅시다.\n\nPower Query 활용하기\n\nPower Query는 데이터 변환 및 데이터 준비 엔진입니다. Power Query에는 소스에서 데이터 가져오는 데 사용하는 그래픽 인터페이스와 변환을 적용하는 Power Query 편집기가 함께 제공됩니다. Power Query를 사용하여 데이터의 추출, 변환 및 로드 (ETL) 처리를 수행할 수 있습니다.\n\n- 슬라이서의 기능에 특별히 맞춘 별도의 테이블을 생성하여 시작했습니다. 이 과정은 슬라이서가 고유한 값을 표시하고 해당 키워드를 포함하는 행만 표시하도록 클릭하는 것을 확인하는 것을 포함했습니다. 이전에 강조했듯이 테이블을 만들 때 데이터를 그대로 복사하거나 중복해서 사용하지 않도록 주의해야 합니다. 그 대신, 데이터의 정확성과 일관성을 유지하기 위해 Power Query의 참조 기능을 사용했습니다. 참조 기능을 사용하면 기존 쿼리의 출력을 참조하는 새로운 쿼리를 생성할 수 있어 데이터의 일관성과 정확성을 보장합니다. 쿼리를 다른 경로로 분기하려는 경우 좋은 선택지입니다. 한 경로는 일련의 단계를 따르고, 다른 경로는 다른 단계를 따르고, 두 경로가 원본 쿼리의 일부 단계를 공유하는 경우에 유용합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_6.png\" /\u003e\n\n- 새 테이블을 생성한 후에는 다양한 기술을 활용하여 변형하였습니다. 불필요한 열을 제거하고 필요한 열만 유지하며, 열을 복제하고 구분자로 열을 분할하여 여러 값을 고려했습니다. 그 후에 두 열을 선택하고 중복 행을 제거했습니다. 이 과정을 통해 키워드와 해당 값이 정확하게 매핑된 필요한 매핑 테이블이 생성되었고, 데이터 조직화와 검색을 효율적으로 지원하게 되었습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_7.png\" /\u003e\n\n- 매핑 테이블을 생성한 후에는 다대다 관계를 처리하는 것이 정확한 데이터 분석을 보장하기 위해 필수적임을 알게 되었습니다. 따라서 Power BI 모델에 다리 테이블을 도입했습니다. 이 다리 테이블은 주 테이블 필드의 모든 고유한 값들을 포함하며, 매핑 테이블과 주 테이블 사이의 중요한 링크 역할을 합니다. 다리 테이블은 데이터 모델 내의 다대다 관계를 해결하는 데 중요한 역할을 합니다. 이를 위해 매핑 테이블과 주 테이블 둘 다와 일대다 관계를 설정합니다. 두 연결하는 테이블의 주요 필드의 고유한 조합을 포함합니다. 이러한 관계를 통해 주 테이블과 매핑 테이블 간의 직접 필터링이 가능해지며, 전체 모델 전반에 걸쳐 데이터가 일관되고 신뢰할 수 있도록 보장됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_8.png\" /\u003e\n\n효과적인 Power BI 모델링을 통한 관계 구축\n\n모델링은 분석과 시각화를 위해 데이터를 구조화하고 조직화하는 과정을 말합니다. 데이터를 다양한 소스에서 가져오고 분석적 요구에 맞게 조성하며, 테이블 간의 관계를 수립하고 DAX를 사용하여 계산을 정의하며, 시각화를 디자인하는 등의 작업을 포함합니다. 효과적인 모델링을 통해 데이터가 논리적으로 구성되고 관계가 정확하게 표현되며, 인사이트가 명확하게 제시되어 의사 결정에 도움이 되는 방향으로 제공됩니다.\n\n- 주 테이블과 브릿지 테이블 사이에 다대일 관계를 설정했습니다.\n- 브릿지 테이블과 맵핑 테이블 사이에 일대다 관계를 구현하여, 맵핑 테이블에서 주 테이블로의 원활한 필터링을 용이하게 하였습니다. 이 선택이 중요한 이유는, 양방향 선택을 하지 않으면 필터링이 브릿지 테이블에서 맵핑 테이블로 제한되어 클라이언트의 기대와 일치하지 않는 필터링 동작이 발생할 수 있었기 때문입니다. Power BI의 양방향 관계는 연결된 테이블 사이에서 필터링이 양방향으로 흐를 수 있도록 합니다. 이는 주 테이블이나 관련 테이블에서 필터링을 적용할 때 다른 테이블에도 영향을 미치게 됩니다. 이 양방향 필터링 흐름은 관련된 테이블 간에 관련 데이터가 정확하게 표시되어 데이터 분석 및 시각화 능력을 향상시켜 더 많은 통찰력 있는 의사 결정을 이끌어냅니다.\n\n\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_9.png)\n\nPower View\n\n- 매핑 테이블에서 단일 값 열을 최종 보고서 내 슬라이서에 통합하여 원활하게 고객 요구 사항을 충족시키고 기대대로 최적의 기능성을 보장했습니다.\n\n![이미지](/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_10.png)\n\n\n\n# 결론\n\n마치 *Power BI*의 데이터 필터링 과제를 해결해 나가는 것은 학습 기회와 통찰력으로 가득한 여정이었습니다. 보이는 것이 간단한 작업으로 시작했지만, 실제로는 데이터 모델링, 관계 설정 및 시각화 디자인의 복잡성에 대한 심층적인 탐구로 이어졌습니다. 중간에 여러 어려움을 만나면서, 단일 필드에서 여러 값을 처리하는 것부터 다대다 관계를 해결하는 데까지 다양한 장애물을 겪었습니다. 그러나 각각의 도전은 *Power BI*의 기능을 탐색하고 혁신적인 해결책을 개발하는 기회로 이어졌습니다.\n\n데이터 변환을 위해 *Power Query*를 활용하고, 효과적인 모델링을 통해 효율적인 관계를 설정하고, *Power View* 슬라이서를 활용하여 상호 작용성을 향상시키는 방법으로 데이터 필터링 도전을 성공적으로 극복할 수 있었습니다. 제안한 솔루션은 클라이언트의 요구를 충족시키는 데뿐만 아니라 *Power BI*의 기능과 모범 사례에 대한 이해를 확장시키는 데 도움이 되었습니다.\n\n도전을 받아들이고 우리가 보유한 도구와 기술을 활용하면 가장 고집 센 데이터 장애물도 극복할 수 있습니다. 데이터 탐색 및 분석 여정을 계속하면서, 해결한 각 문제는 성장과 학습의 기회임을 기억합시다. 앞으로도 많은 성공적인 데이터 모험을 기대합니다!\n\n\n\n이 사례 연구는 다양한 데이터 시나리오를 처리하는 데 Power BI의 강력함과 다재다능성을 강조하여 이러한 장벽을 극복하기 위한 가능한 한 가지 방법을 소개합니다. 또한 DAX(Data Analysis Expressions)를 활용하여 더 효율적이고 맞춤화된 솔루션을 탐색하는 등 더 많은 가능성을 탐색합니다.\n\nLinkedIn에서 저와 연결하고 더 많은 기사를 읽어보세요. 이제 제 여정의 시작이며, 여러분도 함께하고 싶습니다!","ogImage":{"url":"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png"},"coverImage":"/assets/img/2024-05-15-FilteringComplexDatawithPowerBIACaseStudy_0.png","tag":["Tech"],"readingTime":7},{"title":"SigmaHQ Rules 릴리스 하이라이트  r2024-05-13","description":"","date":"2024-05-15 03:57","slug":"2024-05-15-SigmaHQRulesReleaseHighlightsr20240513","content":"\n\n\n![SigmaHQRulesReleaseHighlights](/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png)\n\n2024년 5월 13일 Sigma Rule Packages가 발표되었습니다. 이번 릴리즈에는 16개의 새로운 규칙, 7개의 규칙 업데이트 및 1개의 규칙 수정이 7명의 기여자에 의해 추가되었습니다.\n\n# 새로운 규칙\n\n새로운 규칙 중 일부 하이라이트는 다음과 같습니다. Wbadmin을 이용하여 민감한 파일을 덤프/복원하고 백업을 삭제하는 다양한 사례를 다루는 규칙입니다.\n\n\n\n```js\n제목: Wbadmin.EXE를 통한 파일 복구\n아이디: 6fe4aa1e-0531-4510-8be2-782154b73b48\n관련:\n    - 아이디: 84972c80-251c-4c3a-9079-4f00aad93938\n      유형: 파생\n상태: 실험적\n설명: |\n    \"wbadmin.exe\"를 통한 백업 파일로부터 파일 복구를 감지합니다.\n    공격자는 NTDS.DIT 또는 레지스트리 하이브와 같은 민감한 파일을 백업에서 복원하여 자격 증명을 뽑아낼 수 있습니다.\n참고:\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-recovery\n    - https://lolbas-project.github.io/lolbas/Binaries/Wbadmin/\n작성자: Nasreddine Bencherchali (Nextron Systems), frack113\n날짜: 2024/05/10\n태그:\n    - attack.impact\n    - attack.t1490\n로그 소스:\n    카테고리: process_creation\n    제품: windows\n감지:\n    선택 이미지:\n        - Image|endswith: '\\wbadmin.exe'\n        - OriginalFileName: 'WBADMIN.EXE'\n    선택 CLI:\n        CommandLine|contains|all:\n            - ' recovery'\n            - 'recoveryTarget'\n            - 'itemtype:File'\n    조건: 모두 선택_*\n거짓 양성:\n    - 알 수 없음\n수준: 중간\n```\n\n```js\n제목: Wbadmin.EXE를 통한 민감한 파일 덤프\n아이디: 8b93a509-1cb8-42e1-97aa-ee24224cdc15\n상태: 실험적\n설명: |\n    \"NTDS.DIT\" 및 \"SECURITY\" 하이브와 같은 고도로 민감한 파일의 덤프를 감지합니다.\n    공격자는 \"wbadmin\" 유틸리티를 활용하여 자격 증명이나 민감한 정보가 포함된 민감한 파일을 덤프할 수 있습니다.\n참고:\n    - https://github.com/LOLBAS-Project/LOLBAS/blob/2cc01b01132b5c304027a658c698ae09dd6a92bf/yml/OSBinaries/Wbadmin.yml\n    - https://lolbas-project.github.io/lolbas/Binaries/Wbadmin/\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-recovery\n    - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/wbadmin-start-backup\n작성자: Nasreddine Bencherchali (Nextron Systems), frack113\n날짜: 2024/05/10\n태그:\n    - attack.credential_access\n    - attack.t1003.003\n로그 소스:\n    카테고리: process_creation\n    제품: windows\n감지:\n    선택 이미지:\n        - Image|endswith: '\\wbadmin.exe'\n        - OriginalFileName: 'WBADMIN.EXE'\n    선택 백업:\n        CommandLine|contains:\n            - 'start'\n            - 'backup'\n    선택 경로:\n        CommandLine|contains:\n            - '\\config\\SAM'\n            - '\\config\\SECURITY'\n            - '\\config\\SYSTEM'\n            - '\\Windows\\NTDS\\NTDS.dit'\n    조건: 모두 선택_*\n거짓 양성:\n    - 허가된 관리자에 의한 합법적인 백업 작업. 일치 사항은 감사하고 사안별로 허용되어야 합니다.\n수준: 높음\n```\n\n파워셸 cmdlet인 “Start-NetEventSession\" 및 “New-NetFirewallRule\" 사용을 다루는 새로운 규칙을 소개하였습니다. 공격자가 패킷을 캡처하거나 새 방화벽 규칙을 생성하는 데 사용할 수 있습니다.\n\n```js\n제목: New-NetFirewallRule Cmdlet을 통한 새 Windows 방화벽 규칙 추가 - ScriptBlock\n아이디: 8d31dd2e-b582-48ca-826e-dcaa2c1ca264\n관련:\n    - 아이디: 51483085-0cba-46a8-837e-4416496d6971\n      유형: 유사\n상태: 실험적\n설명: |\n    PowerShell 스크립트에 \"New-NetFirewallRule\" cmdlet 호출이 포함되어 있어 \"허용\" 동작을 하는 새 방화벽 규칙이 추가될 때 감지합니다.\n참고:\n    - https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1562.004/T1562.004.md#atomic-test-24---set-a-firewall-rule-using-new-netfirewallrule\n    - https://malware.news/t/the-rhysida-ransomware-activity-analysis-and-ties-to-vice-society/72170\n    - https://cybersecuritynews.com/rhysida-ransomware-attacking-windows/\n작성자: frack113\n날짜: 2024/05/10\n태그:\n    - attack.defense_evasion\n    - attack.t1562.004\n    - detection.threat_hunting\n로그 소스:\n    제품: windows\n    카테고리: ps_script\n    정의: '요구 사항: 스크립트 블록 로깅이 활성화되어 있어야 함'\n감지:\n    선택:\n        ScriptBlockText|contains: 'New-NetFirewallRule*-Action*Allow'\n    조건: 선택\n거짓 양성:\n    - 관리자 스크립트\n수준: 낮음\n```\n\n\n\n```yaml\ntitle: \"Start-NetEventSession를 통한 잠재적인 패킷 캡처 활동 - 스크립트 블록\"\nid: da34e323-1e65-42db-83be-a6725ac2caa3\nstatus: experimental\ndescription: |\n    \"Start-NetEventSession\" cmdlet을 호출하는 PowerShell 스크립트 실행을 감지합니다. 이를 통해 공격자는 네트워크 이벤트 세션에 이벤트 및 패킷 캡처를 시작할 수 있습니다.\n    이 기술을 통해 수행 중인 작업의 정보를 수집하기 위해 공격자가 네트워크를 캡처하려 할 수 있습니다.\n    이 기술을 통해 캡처된 데이터에는 특히 안전하지 않고 암호화되지 않은 프로토콜을 통해 전송된 사용자 자격 증명이 포함될 수 있습니다.\nreferences:\n    - https://github.com/redcanaryco/atomic-red-team/blob/5f866ca4517e837c4ea576e7309d0891e78080a8/atomics/T1040/T1040.md#atomic-test-16---powershell-network-sniffing\n    - https://github.com/0xsyr0/Awesome-Cybersecurity-Handbooks/blob/7b8935fe4c82cb64d61343de1a8b2e38dd968534/handbooks/10_post_exploitation.md\n    - https://github.com/forgottentq/powershell/blob/9e616363d497143dc955c4fdce68e5c18d28a6cb/captureWindows-Endpoint.ps1#L13\nauthor: frack113\ndate: 2024/05/12\ntags:\n    - attack.credential_access\n    - attack.discovery\n    - attack.t1040\nlogsource:\n    product: windows\n    category: ps_script\n    definition: 'Script Block Logging이 활성화되어 있어야 함'\ndetection:\n    selection:\n        ScriptBlockText|contains: 'Start-NetEventSession'\n    condition: selection\nfalsepositives:\n    - 적절한 네트워크 진단 스크립트.\nlevel: medium\n```\n\n또한 \"KeyScrambler.exe\"의 잠재적으로 의심스러운 자식 프로세스를 보와하는 새로운 규칙이 추가되었습니다.\n\n```yaml\ntitle: \"KeyScrambler.exe의 잠재적으로 의심스러운 자식 프로세스\"\nid: ca5583e9-8f80-46ac-ab91-7f314d13b984\nrelated:\n    - id: d2451be2-b582-4e15-8701-4196ac180260\n      type: similar\nstatus: experimental\ndescription: KeyScrambler.exe의 잠재적으로 의심스러운 자식 프로세스를 감지합니다.\nreferences:\n    - https://twitter.com/DTCERT/status/1712785421845790799\nauthor: Swachchhanda Shrawan Poudel\ndate: 2024/05/13\ntags:\n    - attack.execution\n    - attack.defense_evasion\n    - attack.privilege_escalation\n    - attack.t1203\n    - attack.t1574.002\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection_parent:\n        ParentImage|endswith: '\\KeyScrambler.exe'\n    selection_binaries:\n        - Image|endswith:\n              - '\\cmd.exe'\n              - '\\cscript.exe'\n              - '\\mshta.exe'\n              - '\\powershell.exe'\n              - '\\pwsh.exe'\n              - '\\regsvr32.exe'\n              - '\\rundll32.exe'\n              - '\\wscript.exe'\n        - OriginalFileName:\n              - 'Cmd.Exe'\n              - 'cscript.exe'\n              - 'mshta.exe'\n              - 'PowerShell.EXE'\n              - 'pwsh.dll'\n              - 'regsvr32.exe'\n              - 'RUNDLL32.EXE'\n              - 'wscript.exe'\n    condition: all of selection_*\nfalsepositives:\n    - 알 수 없음\nlevel: medium\n```  \n\n모든 새로운 규칙 목록의 전체 릴리스 변경 로그를 확인하세요.\n\n\n\n\n# 새로운 업데이트\n\n일부 이전 규칙들이 커버리지 및 메타데이터에서 개선되었습니다.\n\n우선, \"Microsoft-Windows-Windows Firewall With Advanced Security\"를 활용하는 몇 가지 규칙에서는 커버리지를 늘리기 위해 EID 2097이 추가되었습니다.\n\n```js\ntitle: 잠재적으로 의심스러운 응용 프로그램을 위한 Windows 방화벽 예외 목록에 새로운 방화벽 규칙이 추가되었습니다.\nid: 9e2575e7-2cb9-4da1-adc8-ed94221dca5e\nrelated:\n    - id: cde0a575-7d3d-4a49-9817-b8004a7bf105\n      type: derived\nstatus: experimental\ndescription: 잠재적으로 의심스러운 위치에 있는 응용 프로그램에 대한 Windows 방화벽 예외 목록에 새로운 규칙이 추가되는 것을 탐지합니다.\nreferences:\n    - https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/dd364427(v=ws.10)\n    - https://app.any.run/tasks/7123e948-c91e-49e0-a813-00e8d72ab393/#\nauthor: frack113\ndate: 2023/02/26\nmodified: 2024/05/10\ntags:\n    - attack.defense_evasion\n    - attack.t1562.004\nlogsource:\n    product: windows\n    service: firewall-as\ndetection:\n    selection:\n        EventID:\n            - 2004 # Windows Defender 방화벽 예외 목록에 규칙이 추가되었습니다. (Windows 10)\n            - 2071 # Windows Defender 방화벽 예외 목록에 규칙이 추가되었습니다. (Windows 11)\n            - 2097\n        ApplicationPath|contains:\n            - ':\\PerfLogs\\'\n            - ':\\Temp\\'\n            - ':\\Tmp\\'\n            - ':\\Users\\Public\\'\n            - ':\\Windows\\Tasks\\'\n            - ':\\Windows\\Temp\\'\n            - '\\AppData\\Local\\Temp\\'\n    filter_main_block:\n        Action: 2 # 차단\n    condition: selection and not 1 of filter_main_*\nfalsepositives:\n    - 알 수 없음\nlevel: 높음\n```\n\n\n\n```js\ntitle: Windows 방화벽 예외 목록에 추가된 새로운 드문한 방화벽 규칙\nid: cde0a575-7d3d-4a49-9817-b8004a7bf105\nstatus: experimental\ndescription: Windows 방화벽 예외 목록에 규칙이 추가된 것을 감지합니다\nreferences:\n    - https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/dd364427(v=ws.10)\nauthor: frack113\ndate: 2022/02/19\nmodified: 2024/05/10\ntags:\n    - attack.defense_evasion\n    - attack.t1562.004\nlogsource:\n    product: windows\n    service: firewall-as\ndetection:\n    selection:\n        EventID:\n            - 2004 # Windows Defender 방화벽 예외 목록에 규칙이 추가됨\n            - 2071 # Windows Defender 방화벽 예외 목록에 규칙이 추가됨. (Windows 11)\n            - 2097\n    filter_main_block:\n        Action: 2 # 차단\n    filter_main_generic:\n        ApplicationPath|contains:\n            - ':\\Program Files (x86)\\'\n            - ':\\Program Files\\'\n            - ':\\Windows\\System32\\'\n            - ':\\Windows\\SysWOW64\\'\n            - ':\\Windows\\WinSxS\\'\n    filter_optional_msmpeng:\n        ModifyingApplication|contains|all:\n            - ':\\ProgramData\\Microsoft\\Windows Defender\\Platform\\'\n            - '\\MsMpEng.exe'\n    filter_main_covered_paths:\n        # 이 필터는 9e2575e7-2cb9-4da1-adc8-ed94221dca5e로부터의 중복 경고 방지를 위해 추가되었습니다\n        ApplicationPath|contains:\n            - ':\\PerfLogs\\'\n            - ':\\Temp\\'\n            - ':\\Tmp\\'\n            - ':\\Users\\Public\\'\n            - ':\\Windows\\Tasks\\'\n            - ':\\Windows\\Temp\\'\n            - '\\AppData\\Local\\Temp\\'\n    condition: selection and not 1 of filter_main_* and not 1 of filter_optional_*\nlevel: medium\n```\n\n`PDQDeployRunner`를 사용하여 추가 경로 및 프로세스가 규칙에 추가되었습니다. 이는 악의적인 랜섬웨어 위협 행위자들이 환경 전체로 악성 소프트웨어를 배포하기 위해 종종 사용하는 유틸리티입니다.\n\n```js\ntitle: PDQDeployRunner의 잠재적으로 의심스러운 실행\nid: 12b8e9f5-96b2-41e1-9a42-8c6779a5c184\nrelated:\n    - id: d679950c-abb7-43a6-80fb-2a480c4fc450\n      type: 비슷함\nstatus: 테스트\ndescription: \"PDQDeployRunner\"의 의심스러운 실행을 감지합니다. 이는 원격 장치에서 명령과 패키지를 실행하는 PDQDeploy 서비스 스택의 일부입니다\nreferences:\n    - https://twitter.com/malmoeb/status/1550483085472432128\nauthor: Nasreddine Bencherchali (Nextron Systems)\ndate: 2022/07/22\nmodified: 2024/05/02\ntags:\n    - 공격.실행\nlogsource:\n    category: process_creation\n    product: windows\ndetection:\n    selection_parent:\n        ParentImage|contains: '\\PDQDeployRunner-'\n    selection_child:\n        # 다른 의심스러운 프로세스, 명령줄 또는 경로 추가하여 이 섹션을 개선\n        - Image|endswith:\n              # 다음 프로세스 중 하나를 정상적으로 사용할 경우 주석 처리\n              - '\\bash.exe'\n              - '\\certutil.exe'\n              - '\\cmd.exe'\n              - '\\csc.exe'\n              - '\\cscript.exe'\n              - '\\dllhost.exe'\n              - '\\mshta.exe'\n              - '\\msiexec.exe'\n              - '\\regsvr32.exe'\n              - '\\rundll32.exe'\n              - '\\scriptrunner.exe'\n              - '\\wmic.exe'\n              - '\\wscript.exe'\n              - '\\wsl.exe'\n        - Image|contains:\n              - ':\\ProgramData\\'\n              - ':\\Users\\Public\\'\n              - ':\\Windows\\TEMP\\'\n              - '\\AppData\\Local\\Temp'\n        - CommandLine|contains:\n              - ' -decode '\n              - ' -enc '\n              - ' -encodedcommand '\n              - ' -w hidden'\n              - 'DownloadString'\n              - 'FromBase64String'\n              - 'http'\n              - 'iex '\n              - 'Invoke-'\n    condition: all of selection_*\nfalsepositives:\n    - PDQDeploy 도구를 사용하여 이러한 명령을 실행하는 것이 정당할 경우\nlevel: medium\n```\n\n모든 업데이트 목록을 확인하려면 전체 릴리스 변경 로그를 확인하세요.\n\n\n\n\n# 수정 사항\n\n이 릴리스에서는 \"Forest Blizzard APT - 프로세스 생성 활동\" 규칙이 작동하지 않도록 만드는 누락된 수정 자를 처리한 것을 확인할 수 있었습니다.\n\n변경 사항 및 추가 사항의 전체 변경 로그를 확인하려면 아래 릴리스 페이지를 참조해주세요.\n\n# 기여자\n\n\n\n이 릴리스는 Sigma 커뮤니티 기여자 여러분 덕분에 가능해 졌어요. 다음 분들께 큰 감사를 전합니다.\n\n- @ahmedfarou22\n- @frack113\n- @hasselj\n- @joshnck\n- @nasbench\n- @pratinavchandra\n- @swachchhanda000","ogImage":{"url":"/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png"},"coverImage":"/assets/img/2024-05-15-SigmaHQRulesReleaseHighlightsr20240513_0.png","tag":["Tech"],"readingTime":12},{"title":"iPad Pro에 macOS 앱이 없다면, Apple은 그것을 그냥 죽여 버릴 수도 있을 거에요","description":"","date":"2024-05-15 03:53","slug":"2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png\" /\u003e\n\n애플의 \"Let Loose\" 이벤트가 지나가면서 새로운 iPad Pro 및 iPad Air 모델과 함께 완전히 필요 없는 드라마도 함께 등장했습니다. 이제 우리가 기다리는 건 실제 기기와 악세사리 자체입니다. 미디어에서 애플의 프레젠테이션, 발표 및 제품에 대해 다양한 의견이 있었지만 대부분의 댓글러들은 새로운 iPad Pro 모델은 인상적이었지만 업그레이드가 필요한 것은 하드웨어가 아니라는 데 동의했습니다. 실제로 iPadOS가 가장 강력한 iPad을 진정한 잠재력을 실현하지 못하게 하고 있습니다.\n\n말할 필요도 없이, 우리는 이미 이런 상황을 겪어본 적이 있습니다. 그러나 이번에는 다르게 보입니다. 사람들은 더 나은 iPadOS 버전을 요청하는 것이 아닙니다. 아니요. 그들이 요청하는 것은 iPad Pro에서 macOS 앱입니다. 이 개념은 듣기에는 듣던 대로인 것 같지만, 지금은 시기적절하거나 심지어 필수적으로 느껴집니다. 이것은 애플의 전략에서 주요 변화를 일으킬 가능성이 있고 전체적으로 태블릿 범주에 중요한 발전이 될 수도 있습니다. 이것이 그 이유이며, 왜 이제야 시간이 된 것인지 말씀드리겠습니다.\n\n## \"iPad에서 macOS 사용\" 사가: 왜 이쪽으로 오게 되었는가?\n\n\n\niPad Pro이 macOS 애플리케이션을 실행하는 아이디어는 결코 새로운 것이 아닙니다. 예를 들어, 저는 M1 기반 iPad Pro를 발표한 이후인 2021년 봄부터 iPad가 macOS에 액세스할 수 있도록 Apple에 촉구하고 있었습니다. 긴 시간이 너무 오래요? 네, 왜냐하면 그 때부터 iPad Pro가 잠재력을 충분히 발휘하지 못하고 있다는 것이 이미 분명해졌기 때문입니다. 그뿐만 아니라 \"Pro\" 장치로서가 아니라 기술 제품으로서 모두에서도 그랬습니다.\n\n![이미지](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_1.png)\n\nMonica Chin의 유명한 \"이 겁하지 마세요, iPad에 macOS를 넣으세요\"라는 기사가 그 때 The Verge에 게재된 후 여러 개의 유사한 기사가 이어졌습니다. 이것이 바로 대다수의 우리 기술 기자들이 이전 몇 년 동안 iPad Pro를 생산적으로 사용해 본 적이 있는데도 Tim Cook이 M1 프로세서를 iPad에 담아둔 그 유명한 영상을 보면서 느꼈던 정황과 정확히 일치했습니다.\n\n이후의 한 해 동안 Apple이 macOS를 iPad에 넣는 아이디어를 적어도 고려하기 시작한 것으로 보이는 몇 가지 신호가 있었습니다. 그러나 회사가 그 문제에 대해 어떠한 업데이트도 제공하지 않는 것이 계속되면서, M2 기반 iPad가 동일한 기존 iPadOS를 기반으로 할 경우 그것이 어떤 의미가 있는 지 의문을 품기 쉬워졌습니다. 저와 같은 많은 사람들은 심지어 진정한 데스크톱 수준의 프로페셔널 macOS 애플리케이션에 액세스할 수 없는 iPad \"Pro\"라는 개념을 심각하게 의심하기 시작했습니다.\n\n\n\n시간이 흐를수록 더 많은 사람들이 그 관점으로 기울어가는 것 같았고, 확실히 WWDC 2022에서 아무 변화도 없이 10월에 더 강력한 M2 기반 iPad Pro 모델을 출시한 후 실망을 표현하는 목소리가 훨씬 많아졌습니다. 이러한 태블릿들은 대체 누구를 위한 것이었을까요?\n\n하드웨어 면에서는 조용한 한 해였던 2023년 동안, “생산성을 위한 iPadOS를 개선하는\" 과정을 지켜보는 것은 점점 더 답답한 경험이 되었습니다. 이 운영 체제는 명백히 그 목적으로 설계된 것이 아니었기 때문에 다양한 시도나 미완성된 아이디어는 별다른 차이를 만들지 못했습니다. iPad Pro가 맥과 정확히 같은 하드웨어를 갖게 된 후, 프로페셔널들이 일을 위해 설계된 적합한 운영 체제를 요구하는 것은 당연했습니다. 그것이 macOS였습니다.\n\n이제 iPad Pro와 Magic Keyboard 조합은 맥북과 동등한 가격을 초과하게 되면서, 이전의 기기가 이후의 판매를 침해할 것을 기대하는 애플의 잘 알려진 두려움도 더 이상 타당하지 않습니다. 그 결과로 회사는 이제 macOS 애플리케이션을 iPad Pro에서 한 방이나 다른 방식으로 실행할 수 있도록 허용해야 하는 압박을 받고 있습니다. 그렇다면 회사가 어떻게 그런 일을 할 수 있을까요? 어떤 제약이나 제한을 이 기능에 부과할 것이며, 그것이 iPad Pro의 미래에 어떤 의미를 갖게 될까요?\n\n## iPad Pro에서 macOS가 어떻게 작동할까요?\n\n\n\nApple이 이를 처리할 수있는 몇 가지 다른 방법이 있지만, 소비자에게는 아마도 가장 간단한 것이 가장 좋을 것입니다: 듀얼 부팅 옵션입니다. 회사는 iPad Pro의 내부 저장 공간을 파티션하고 macOS를 다운로드하고 태블릿에 설치하는 과정을 안내하는 앱을 제공할 수 있습니다. 그러면 사용자들은 장치를 다시 시작하고 부팅 시 OS를 선택함으로써 이전에 인텔 기반 맥에서 macOS 및 Windows 간에 수행했던 것과 같은 방식으로 두 OS 사이를 전환할 수 있을 것입니다.\n\n![아이패드 프로에서 macOS 앱을 사용할 수 없다면 아예 없애버릴 수도 있어요](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_2.png)\n\nApple이 iPad Pro에서 macOS를 실행하는 또 다른 방법은 가상 머신을 통한 것입니다. 소비자들은 Apple의 태블릿에 macOS를 설치하기 위해 동일한 설정 앱을 사용하지만, 각각의 운영 체제를 전환할 때마다 재부팅하는 대신, 데스크톱 애플리케이션을 사용할 필요가 있을 때에는 macOS 환경을 (아마도 최대화하여) 열고, 완료되면 \"닫을\" 것입니다.\n\n이 접근법은 macOS와 iPadOS간의 즉각적인 전환을 제공할 뿐만 아니라 일부 보안 및 개인 정보 보호 이점도 제공할 것입니다. ── 가상 머신은 \"박스형 모드\" 즉, 특정하고 보호된 메모리 공간에서 조정 가능한 시스템 액세스 권한으로 실행할 수 있기 때문에 ── 그러나 시스템 리소스 공유로 인한 응용 프로그램 성능 저하가 발생할 수 있을 수도 있습니다.\n\n\n\n소비자들에게는 덜 투명한 세 번째 방법이 있을 수 있지만, 이는 iPad Pro에서 macOS 애플리케이션이 작동하는 방식에 대한 Apple의 최대 통제력을 제공할 것입니다. 회사는 \"투명하지 않은\" macOS의 설치를 허용할 수 있으며, 이는 소비자가 macOS 애플리케이션을 실행해야 할 때에만 요청될 것입니다. 이 시스템을 통해 iPad Pro에서 macOS 프로그램은 실제로 디바이스 소유자에게 운영 시스템을 노출시키지 않으면서 전체 기능을 유지할 수 있게 됩니다.\n\n## Apple에게 최선인 것이 소비자에게도 잘 맞을까요?\n\n상세히 설명한 세 번째 접근 방식은 소비자들에게 분명한 단점들을 가지고 있습니다. 예를 들어 파일 관리와 멀티태스킹이 더 어려워질 수 있습니다. 그러나 이는 Apple이 선호하는 익숙한 \"잠긴 상태\"로 작동하며, iPad Pro에서 애플리케이션은 여전히 전체 속도로 실행됩니다. 이 방식으로 사용자들은 Mac의 전통적인 데스크톱 환경에 액세스할 수 없지만, 애플리케이션은 iPad Pro에서 전체 속도로 실행됩니다. Apple은 \"iPad Pro에서 Mac 프로그램을 제공하고 있다\"고 주장할 수 있을 것인데, 기술적으로 거짓말하지 않게 될 것입니다. 그러나 전체 macOS 사용자 경험을 제공하는 것은 아니게 될 것입니다.\n\n상기한 세 가지 접근 방법 중에서, 듀얼 부팅 방식이 아마도 소비자들이 iPad Pro에서 macOS 소프트웨어를 경험하는 데 가장 좋은 방법이 될 것입니다. Apple은 같은 디바이스의 iPadOS와 macOS 파티션들이 서로 접근할 수 없도록 보장하기 위해 어떤 노력을 해야 할 것이지만 (다양한 이유들을 위해서), 가상 머신 방식도 가능할 것입니다. 이 방식도 작동할 수 있지만 시스템 리소스에 더 큰 부담을 줄 것이고, 이는 적절한 관리 없이 성능에 영향을 줄 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_3.png)\n\n만약 내가 내기하는 사람이었다면, '잠겨 있는' 방식이 가장 가능성이 높게 구현될 것이라고 돈을 거는 것이 올바른 것 같습니다. 사용자 경험을 제어하는 데 있어서 애플의 스타일과 일치합니다.\n\n그런데 아이패드 프로에서 macOS 아이디어를 구현할 때 애플이 가할 수 있는 제한 사항은 무엇인가요?\n\n\n\n당연히 어떠한 제약도 없이 제공된다면 좋을텐데, 애플이 애플답게 macOS가 iPad에서 제공될 경우에는 어떤 형태로든 제약이 따를 것입니다. 첫 번째, 분명한 제약 사항: 여기서는 iPad Pro 모델만이 어떠한 형태로든 macOS를 받게 될 것이라는 것입니다. 일반 iPad나 iPad 미니에서는 이 기능을 제공하는 것은 말도 안 되며 솔직히 그것이 괜찮습니다. 강력한 iPad를 생산적으로 사용하고자 하는 사람들이 실제로 macOS를 필요로 하는 것이기 때문입니다. 입문용 모델들은 다른 용도로 디자인되었기 때문에 불만이 없습니다.\n\n그리고, 2022년 5월에 Patently Apple에 의해 밝혀진 널리 논의된 특허는 iPad Pro에 macOS와 유사한 인터페이스를 제공한다면 Magic Keyboard와 같은 액세서리에 연결되어 있어야 한다는 것을 시사했습니다. 이는 여러 면에서 잘못될 수 있습니다 — 많은 소비자들이 자신의 선택에 따라 블루투스 키보드와 마우스를 사용하는 것을 선호하더라도, 애플이 해당 액세서리의 더 높은 매출을 원하는 욕심을 드러내는 것입니다. 하지만... 우리는 현실적으로 여기서 얘기하자면, 해당 기업은 이를 할 수 있고 그로 인해 이득을 얻을 수도 있습니다.\n\n애플이 가능한 듀얼 부팅 macOS/iPadOS 설치에 부과할 수 있는 다른 제약은 저장 공간과 관련이 있습니다. 현재 어떤 맥 컴퓨터든 최소 256GB의 저장 공간을 제공하고 있으며, 이는 사실상 2024년 기준으로는 절대 미약한 용량입니다. 애플은 iPad Pro에 macOS 파티션을 생성하는 것은 최소한 그것과 일치해야 한다고 주장할 수 있을 것입니다. 이 요구 사항은 512GB 또는 그 이상의 저장 공간이 장착된 iPad Pro 모델만이 macOS에 액세스할 수 있음을 의미하며, 이는 분명히 애플의 수익에 도움이 될 것입니다.\n\n이상적으로 소비자는 macOS 용으로 얼마의 내부 저장 공간을 예약하길 원하는지 조절할 수 있어야 합니다 — 최신 macOS조차도 실제로 자체적으로 32GB 이상의 용량이 필요하지 않기 때문입니다. 하지만 다시 한번 말하지만, 애플은 이 256GB 제약을 쉽게 시행할 수 있을 것입니다. 또한 애플은 원한다면 외부 SSD에 macOS를 설치할 수 있도록 허용할 수도 있겠지만, 이는 각자의 요구 사항과 제한 사항을 가지고 있을 것이기 때문에 대부분의 소비자들이 원하는 대로 원활하게 작동하지 않을 것입니다.\n\n\n\niPad Pro와 macOS를 함께 사용하는 데 Apple이 부과할 수 있는 제약 중 하나는 시스템 메모리와 관련이 있을 수 있지만, 이는 데스크톱 운영 체제가 회사의 가장 강력한 태블릿에서 실행되도록 구현되는 방식에 따라 달라집니다. 이 구현이 macOS가 iPadOS와 함께 실행되어 두 운영 체제 간의 전환을 순간적으로 만들어주는 방식으로 설계되었다면, Apple은 아마도 이러한 시나리오를 위해 16GB의 시스템 메모리가 필요하다고 주장할 수 있을 것입니다 (이는 1TB/2TB 저장 구성을 사용하는 iPad Pro 모델에서만 제공됩니다).\n\n![링크 이름](/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_4.png)\n\n반면에 간단한 듀얼 부팅 구현에 대해 언급하는 것이면, Apple이 8GB가 macOS를 효과적으로 실행하기에 충분하지 않다고 주장하기는 다소 어려울 것입니다... 그동안 모두에게 그 반대를 주장해 왔기 때문에 말이죠. 맞나요?\n\n마지막으로: Apple이 iPad Pro에서 macOS를 허용하기로 결정할 경우, M2 및 M4 세대의 프로세서에서 데스크톱 OS의 사용을 제한하기 위한 변명을 찾을 수도 있습니다. 이는 확실한 현금 잡기일 것입니다 - M1은 어떠한 문제없이 최신 macOS를 실행할 수 있기 때문에 - 그러나 2024년 가을에는 M1이 소개된지 거의 4년이 되어갈 때이니까요... 어쩔 수 없이. Apple이라니까요.\n\n\n\n## 아이패드 프로는 어려운 결정 앞에 있습니다 — 애플은 무엇을 할까요?\n\n아이패드의 macOS 호환성 측면에서 애플이 선택한 것이 무엇이든, 만약 제공하려는 선택을 구현하는 방법에 대해 계획한다면, 모두에게 분명한 것은 이것입니다: 아이패드 프로는 공식적으로 어려운 결정 앞에 있는 상황입니다.\n\n이 회사의 최고의 태블릿은 수년간 “거의, 그러나 그렇지 않은 컴퓨터\"라는 어색한 위치에 있었으며, 하드웨어 측면에 맞춰 소프트웨어 측면이 시행할 계획이 있었기 때문입니다. 애플은 아이패드 프로가 맥처럼 다재다능하고 유용할 정도로 발전하는 걸 원하지 않았기 때문에, 회사가 한 일은 주로 소비자가 업그레이드하도록 유도하기 위해 자사의 주력 태블릿을 점진적으로 강화하는 것뿐이었습니다.\n\n그래서 이제 아이패드 프로의 하드웨어 측면이 너무 발전해서 혼란스러운 수준에 이르렀다는 것에는 이유가 있습니다. 애플은 결국 너무 멀리 갔습니다: 단순히 아이패드 프로의 소프트웨어 측면에 대해 뭔가 해야할 필요가 있는데, 그것을 빨리 처리하지 않는다면 소말리아해야만 할지도 모릅니다. 만약 현재의 iPadOS에서 실행된다면 이 유형의 새로운 모델을 다시 출시하는 것에는 절대로 아무 의미가 없습니다. 그것을 시도해봤습니다. 제대로 작동하지 않습니다. 애플은 이 기기가 이제 드디어 자신이 어떤 것을 정말 제공할 수 있는지 증명할 수 있도록... 그리고 이것을 하는 방법은 하나뿐입니다: macOS와 데스크톱 애플리케이션이 아이패드 프로에서 실행되도록 허용하는 것이 바람직합니다. 가능하다면 듀얼 부팅 모드에서 실행되도록 하는 것이 좋습니다.\n\n\n\n그래서 WWDC 2024는 iPad의 역사상 가장 중요한 이벤트가 될 것입니다. 이 이벤트를 통해 애플이 iPad Pro를 항상 의도했던 디바이스의 본 모습을 세계에 증명할 것입니다. 회사는 변명의 여지가 없으며, 시간이 부족하다는 것을 알고 있습니다. 만약 우리가 iPad Pro를 iPad Deluxe로 사용하기로 결정한다면 - \"작업\"하는 척하는 대신, 사실상 어떤 일반 iPad나 심지어 iPad 미니에서 할 수 있는 것을 하는 것이라면 - 우리는 그냥 그렇게 하면 됩니다. 모두 연기를 그만 두고, iPad \"Pro\"를 잊고 간단한 iPad를 구입하고 이 모든 것을 마무리 지으세요. 결정은 애플에 달려 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png"},"coverImage":"/assets/img/2024-05-15-IfwecanthavemacOSappsontheiPadProApplemightaswellkillit_0.png","tag":["Tech"],"readingTime":8},{"title":"맥OS 및 리눅스용 SSH 키 생성기","description":"","date":"2024-05-15 03:50","slug":"2024-05-15-SSHKeyGeneratorforMacOSLinux","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png\" /\u003e\n\n우선, 제 코딩 인생에서 좋아하는 인용구부터 시작하겠어요:\n“어떤 일을 6분 동안 수동으로 할 때 6시간을 써서 자동화를 실패하는 것이 더 나을 때가 있다.\" — Zhuowei Zhang\n\n대부분의 개발자들이 SSH 키를 생성하고 연결하는 방법에 대해 문서를 참고해 왔을 겁니다. 지난 3년간 이 프로세스를 4~5번 되풀이했는데, 총 40~50분 정도 걸렸어요. 결국, 이러한 과업을 다시 찾아보지 않도록 스크립트를 작성하기로 결심했습니다. 아래에는 해당 스크립트를 공유하고 있어요. \"your_remote_server_url\"을(를) 실제 원격 서버 URL로 교체해 주시기 바랍니다.\n\n```js\n#!/bin/bash\n\n# Command existence 확인하는 함수\ncommand_exists() {\n  command -v \"$1\" \u003e/dev/null 2\u003e\u00261\n}\n\n# 현재 운영 체제 감지\nif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n  # macOS\n  CLIP_CMD=\"pbcopy\"\nelif [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n  # Linux\n  if command_exists \"xclip\"; then\n    CLIP_CMD=\"xclip -selection clipboard\"\n  elif command_exists \"xsel\"; then\n    CLIP_CMD=\"xsel --clipboard\"\n  else\n    echo \"클립보드 유틸리티(xclip 또는 xsel)를 찾을 수 없습니다. 계속 진행하려면 설치해 주세요.\"\n    exit 1\n  fi\nelif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"cygwin\" ]]; then\n  # Windows (Cygwin 또는 MSYS)\n  echo \"Windows에서는 클립보드 복사 명령을 지원하지 않습니다.\"\n  echo \"SSH 키를 수동으로 복사해 주세요.\"\n  CLIP_CMD=\":\"\nelse\n  echo \"지원되지 않는 운영 체제입니다.\"\n  exit 1\nfi\n\n# 사용자에게 GitHub 이메일 입력 요청\nread -p \"GitHub 이메일 주소를 입력하세요: \" email\n\n# SSH 키 생성\nssh-keygen -t rsa -b 4096 -C \"$email\"\n\n# SSH 키를 클립보드에 복사\ncat ~/.ssh/id_rsa.pub | $CLIP_CMD\n\n# 사용자에게 SSH 키가 클립보드에 복사되었음을 알림\necho \"SSH 키가 클립보드에 복사되었습니다.\"\n\n# GitHub 설정 페이지를 기본 브라우저에서 열기 (macOS 및 Linux 전용)\nif [[ \"$OSTYPE\" == \"darwin\"* || \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n  echo \"기본 브라우저에서 GitHub 설정 페이지를 엽니다...\"\n  open \"https://github.com/settings/ssh\" # 여기에 원격 서버 URL이 있어요\nfi\n\necho \"SSH 키를 GitHub 계정에 추가해 주세요.\"\n```\n\n\n\n원하는대로 스크립트를 수정하십시오!","ogImage":{"url":"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png"},"coverImage":"/assets/img/2024-05-15-SSHKeyGeneratorforMacOSLinux_0.png","tag":["Tech"],"readingTime":2},{"title":"iOS 175가 출시되었습니다 지금 바로 시도해 볼 5가지 멋진 기능","description":"","date":"2024-05-15 03:48","slug":"2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow","content":"\n\niOS 17.5가 iOS 17.4 이후 2개월 만에 출시되었는데, 몇 가지 새로운 변경 사항과 기능이 포함되어 있습니다.\n\n이 변경 사항들은 사용자들에게 유용하며, Apple 사용자 경험을 개선할 것입니다.\n\n새로운 기능 및 기능 목록:\n\n```js\n1. EU 사용자는 개발자 웹사이트에서 앱을 다운로드할 수 있습니다.\n2. 새로운 프라이드 컬렉션 배경화면이 제공됩니다.\n3. Apple이 Apple News Plus 사용자를 위해 퍼즐 게임 Quartiles를 출시했습니다.\n4. 팟캐스트 위젯이 새로운 색상으로 업데이트되었습니다.\n5. 이제 사용자들은 스포트라이트 검색에서 팟캐스트를 찾을 수 있습니다.\n6. 책 앱에 카운터 도구가 추가되었습니다. \n```\n\n\n\n# 이제 유럽 사용자들은 개발자 웹사이트에서 앱을 다운로드할 수 있어요.\n\n애플의 독점이 앱 유통에 대해 약해지고 있어요. 이전에는 앱을 다운로드하려면 앱스토어가 유일한 선택이었어요.\n\n이제 사용자들은 개발자 웹사이트에서 직접 앱을 다운로드할 수 있어요. 개발자들은 사용자에게 앱을 제공하기 전에 애플에서 승인을 받아야 해요.\n\n이 웹 유통 기능은 다가오는 iOS 17.5 업데이트에서 이용 가능할 거에요.\n\n\n\n3월 12일에 Apple이 이 새로운 기능을 발표했어요.\n\n# 새로운 프라이드 컬렉션 배경화면을 받을 거에요\n\n![](/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_0.png)\n\nApple은 LGBTQ+ 커뮤니티를 지원하기 위해 새로운 배경화면을 추가할 예정이라고 발표했어요.\n\n\n\nApple이 이견이 붙은 이유는 LGBTQ+ 커뮤니티를 지지하는 사람들이 모두 아니기 때문입니다.\n\n나의 기기에서는 해당 배경화면을 사용할 수 있습니다. 이 배경화면은 세 가지 다른 색상의 \"자랑\"을 나타냅니다.\n\n# Apple이 Apple News 플러스 사용자를 위해 퍼즐 게임 Quartiles를 출시했습니다.\n\n![이미지](/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_1.png)\n\n\n\n사용자는 쿼타일을 선택하고 해당 타일로 단어를 만듭니다. 이 게임에서 각 퍼즐은 20개의 타일로 시작하며, 플레이어는 1개에서 4개의 타일로 단어를 형성할 수 있습니다.\n\n플레이어는 쿼타일에서 모든 5개의 단어를 찾으면 게임에서 이기게 됩니다.\n\n쿼타일은 Apple News + 구독에서 교차어와 교차어 미니와 함께 추가됩니다.\n\niOS 17.5에서 세 게임이 모두 게임 센터와 병합되어 리더보드를 표시합니다.\n\n\n\nApple News App 안에 Quartiles는 Puzzles 아래에서 찾을 수 있어요.\n\nApple News + 구독은 다음 국가에서 이용 가능해요.\n\n- 미국\n- 호주\n- 캐나다\n- 영국\n\n하지만 새로운 퍼즐 기능은 미국과 캐나다에서만 이용 가능할 거예요.\n\n\n\nApple News Plus 는 오프라인 모드에서도 작동합니다.\n\n다가오는 iOS 17.5 업데이트에서 사용자들은 오프라인에서 뉴스, 최신 이야기, 퍼즐, 오디오 스토리를 읽을 수 있습니다.\n\n이를 위해 사용자는 Apple News Plus 구독자를 위해 오프라인 모드를 활성화해야 합니다.\n\n# 팟캐스트 위젯에 새로운 색상이 적용되었습니다.\n\n\n\n다가오는 iOS 17.5에서는 사용자가 청취 중인 팟캐스트 유형에 따라 팟캐스트 위젯의 색상이 변경될 예정입니다.\n\n만약 사용자가 청취 중인 팟캐스트의 아트워크가 분홍색이라면 위젯이 분홍색으로 변할 것입니다. 이것은 애플이 사용자들을 위해 가져온 인터페이스 변경 중 하나입니다.\n\n## 이제 사용자들은 스포트라이트 검색에서 팟캐스트를 찾을 수 있습니다.\n\n이제 사용자들은 최근 재생한 팟캐스트를 찾아보고, 팟캐스트 애플을 최근 팟캐스트와 함께 상단 히트바에서 찾을 수 있습니다.\n\n\n\n하지만 사용자는 팟캐스트 애플리케이션에서 오직 세 개의 팟캐스트만 볼 수 있어요.\n\n또한, 특정한 팟캐스트가 팝업되지 않고, 그것들을 찾기 위해 깊게 검색해야 해요.\n\n# 책 애플리케이션의 카운터 도구\n\n![이미지](/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_2.png)\n\n\n\n다가오는 iOS 17.5 업데이트에서, 사용자들은 이제 독서 목표와 진행 상황을 추적할 수 있어요.\n\n최신 업데이트에서, Book 앱은 앱 홈페이지의 오른쪽 상단에 카운터를 추가했어요.\n\n그 카운터를 클릭하면, 앱이 '독서 목표 메뉴'로 이동해요. 이 메뉴에서는 오늘 독서에 얼마나 시간을 사용했는지 보여줘요.\n\n'책 상점 발견하기'를 클릭하면 사용자는 책 상점에 접속할 수 있어요.\n\n\n\n북 앱에서 사용자는 5분부터 24시간까지 어디서든지 독서 목표를 설정할 수 있어요.\n\n이 새로운 기능들은 iPhone 사용자에게 새로운 사용자 경험을 제공할 거에요.","ogImage":{"url":"/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_0.png"},"coverImage":"/assets/img/2024-05-15-iOS175Released5AmazingFeaturesYouNeedtoTryNow_0.png","tag":["Tech"],"readingTime":3},{"title":"레귤러 함수에서 컴포저블을 호출하는 것이 불가능한 이유","description":"","date":"2024-05-15 03:46","slug":"2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible","content":"\n\n이것은 컴파일러입니다!\n\n![image](/assets/img/2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible_0.png)\n\n이 기본 질문에 대한 답변을 제공하려면 구성 가능한 함수의 작동 방식을 깊이 이해해야 합니다.\n\n함수를 @Composable로 표시하면 노드를 추가할 수 있는 슈퍼파워를 가지게 됩니다. 이를 간단히 설명하자면, Compose UI 트리에 노드를 추가할 수 있게 되는 것입니다. 어떻게 노드가 되는지 이해하기 위해 기본적인 컴포저블을 작성해 봅시다.\n\n\n\n\n```js\n@Composable\nfun IAmAComposable(){\n  Text(\"저는 콤포저블 함수입니다. 왜 함수냐면, 콤포즈는 즐겁거든!! 음, 즐겁지요\")\n}\n```\n\n우리가 정의한 콤포저블은 조합되면 반환할 것이 없지만, 만약 그렇지 않다면 UI는 어떻게 렌더링 될까요? 텍스트 콤포저블이 그 역할을 하고 있나요? 음, 아마요.\n\n조합이 일어날 때 콤포저블 트리 내에 노드가 생성되며, 모든 구현은 콤포저블 내부에 있습니다. 이 트리를 탐색하여 UI를 렌더링합니다. 이는 UI에만 국한되지 않고, 콤포즈 런타임 및 컴파일러를 사용하여 어떠한 종류의 트리 구조에 대해서도 효율적으로 탐색할 수 있습니다. 자세한 내용은 여기를 확인하세요.\n\n하지만 여러분이 여기로 왔는데도 계속 궁금한 점은, 왜 일반 함수에서 콤포저블을 호출할 수 없는 걸까요. 그래서 이에 대한 답변을 해볼게요.\n\n\n\n\n\nAndoroid 개발에서 fragment, activity 및 application context와 같은 다양한 종류의 context는 애플리케이션 내에서 리소스의 라이프사이클과 범위를 관리하는 데 중요한 역할을 합니다.\n\n각 context는 fragment나 activity와 같은 특정 구성요소의 라이프사이클과 관련이 있습니다. 이러한 context를 사용함으로써 서비스 및 리소스에 적절한 범위 내에서 액세스 및 관리되도록 보장할 수 있어서 애플리케이션의 전반적인 효율성과 신뢰성을 향상시킬 수 있습니다.\n\n비슷하게, 컴파일 후 각 콤포저블 함수는 \"콤포저(Composer)\"라는 추가 매개변수를 받습니다. 이 매개변수는 compose 컴파일러를 사용하여 주입됩니다.\n\n```js\n@Composable\nfun IAmAComposable($composer: $Composer\u003c*\u003e){ \n$composer.start(\\\\unique_key_here)\n    IAmComposablesChild($composer)\nText(\"I am a Composable fun, why fun? because compose is fun!! hmm fun ok\", $composer)\n$composer.end()\n}\n\n@Composable\nfun IAmComposablesChild($composer: Composer\u003c*\u003e){\n}\n```\n\n\n\n$composer은 그런 다컬저들에게 전달됩니다. 그때 이 composer은 유일한 키를 받는데요, 이 키는 다시 어떤 컴포저에 속한 노드인지 식별하는 데 사용됩니다. 이는 필수이며 트리 안의 각 노드에서 사용 가능해야 합니다. 위의 설명된 컴포저론, 부모 컴포저부터 트리의 마지막 컴포저까지 같은 composer 인스턴스가 사용될 것입니다.\n\n활동이 여러 프래그먼트를 가질 때와 같이, 모든 프래그먼트들의 활동 컨텍스트가 동일하게 됩니다.\n\n따라서 Composable 함수는 일반 함수에서 호출될 수 없습니다. 각 컴포저는 컴포저 형태의 상위 컨텍스트가 필요하기 때문에, 그 상위 컨텍스트가 없으면 구성이 되지 않습니다. 구성이란 무엇일까요? 그것은 컴포즈 트리를 탐색하고 (필요하다면) 각 노드를 화면에 렌더링하는 것이죠. 부모 노드가 없다면 렌더링할 수 없습니다.\n\n이 composer는 Compose 런타임에 의해 효율적으로 Compose UI 트리를 탐색하는 데 사용됩니다.\n\n\n\n이것은 상당히 간단한 예제와 설명입니다.하지만 이 모든 것을 자세히 배울 수 있습니다. 아래의 참고 자료들을 통해! \n\n즐거운 학습 되세요! ❤️","ogImage":{"url":"/assets/img/2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible_0.png"},"coverImage":"/assets/img/2024-05-15-WhyCallingaComposablefromaRegularFunctionIsntPossible_0.png","tag":["Tech"],"readingTime":3},{"title":"테라폼을 사용한 Sumo Logic 통합","description":"","date":"2024-05-15 03:43","slug":"2024-05-15-Sumologicintegrationusingterraform","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-Sumologicintegrationusingterraform_0.png\" /\u003e\n\n프로젝트에서 매우 기술에 능통한 고객을 위해 작업 중입니다. 그들은 매일 많은 수의 API를 활용하여 방대한 기술 생태계를 구축했습니다. 이들 API의 특정 활동을 분석하고 로깅하여 시스템을 더 잘 관리하고 개선하기 위해 다수의 활성 모니터를 가진 경보 시스템을 생성해야 했습니다.\n\n이 경보 시스템에서 그들은 Sumologic을 경보 시스템으로 선택했습니다.\n\n사용 사례:\n제 사용 사례는 다음과 같습니다. Sumologic 대시보드를 통해 모든 이러한 모니터를 수동으로 생성 및 구성했는데, 많은 수의 모니터를 관리하고 생성하는 작업은 번거로운 작업일 수 있습니다. 제 작업은 이 모니터 생성 및 관리 프로세스를 수동 작업에서 자동화된 방식 또는 코드를 통해 관리하는 것으로 변경하는 것이었습니다. 다시 말해, Sumologic 모니터를 Terraform과 통합하는 것입니다.\n\n\n\n아래 섹션에서는 수동으로 작성한 모든 Sumologic 모니터를 테라폼으로 변환하는 데 수행한 모든 단계를 안내할 것입니다.\n\n준비 사항:\n\n- 테라폼에 대한 기본 지식이 충분히 갖춰져 있다면 시작할 수 있습니다(테라폼 문서)\n\nSumologic 모니터:\n\n\n\n테라폼 코드를 올바르게 작성하여 Sumologic 모니터를 만들려면 먼저 Sumologic에서 이러한 모니터를 만드는 데 필요한 필드를 시각화해야 합니다.\n\nSumologic 대시보드에서 모니터를 만드는 \"Create a Monitor\"를 클릭하면 아래 화면이 나타납니다.\n\n![이미지](/assets/img/2024-05-15-Sumologicintegrationusingterraform_1.png)\n\n![이미지](/assets/img/2024-05-15-Sumologicintegrationusingterraform_2.png)\n\n\n\n![이미지](/assets/img/2024-05-15-Sumologicintegrationusingterraform_3.png)\n\n지금 보시는 예제 모니터의 설정을 테라폼 자원인 \"sumologic_monitor\"를 사용하여 생성할 수 있습니다. sumologic_monitor 자원 블록은 실제 모니터 필드와 매핑되는 몇 가지 특정 키-값 인수를 받아들일 것입니다.\n\n다음은 테라폼 코드와 SumoLogic 모니터 필드의 몇 가지 매핑 예시입니다.\n\n테라폼 모니터 생성:\n\n\n\n\n![Sumologic Integration using Terraform - Screenshot 4](/assets/img/2024-05-15-Sumologicintegrationusingterraform_4.png)\n\n```js\nresource \"sumologic_monitor\" \"any_name\" {\n\ntrigger_condition {\n   logs_static_condition {\n        ...\n   }\n}\n```\n\n![Sumologic Integration using Terraform - Screenshot 5](/assets/img/2024-05-15-Sumologicintegrationusingterraform_5.png)\n\n```js\nresource \"sumologic_monitor\" \"any_name\" {\n\ntrigger_condition {\n   logs_static_condition {\n     critical {\n       time_range = \"5m\"\n       alert {\n         thresold = \"0\"\n         thresold_type = \"GreaterThan\"\n       }\n       resolution {\n         thresold = \"0\"\n         thresold_type = \"LessThanOrEqual\"\n         resolution_window = \"5m\" \n       }\n     }\n   }\n}\n``` \n\n\n\n\n\n![image](/assets/img/2024-05-15-Sumologicintegrationusingterraform_6.png)\n\n```js\nresource \"sumologic_monitor\" \"any_name\" {\n  queries {\n    row_id = \"A\"\n    query = \"실행될 조건에 대한 실제 쿼리\"\n  }\n}\n```\n\n![image](/assets/img/2024-05-15-Sumologicintegrationusingterraform_7.png)\n\n통지를 위해 Slack, Webhook, Email 등과 같은 다양한 connection_type을 설정할 수 있습니다. sumologic 대시보드에 이미 있는 연결에 connection_id를 지정하거나 사용자 정의 연결을 만들고 알림 페이로드를 생성할 수 있습니다.\n\n\n\n\n|| Sumologic API를 참조하고 curl을 실행하여 모든 연결을 가져와서 connection_id를 이름으로 필터링할 수 있어요-\n\ncurl -u \"`accessId`:`accessKey`\" -X GET https://api.`deployment`.sumologic.com/api/v1/connections\n\n```js\nresource \"sumologic_monitor\" \"any_name\" {\n notifications: {\n  // 여러 알림 블록을 만들 수 있어요\n  notification: {\n   connection_type = \"Email\" //Slack | Webhook | Email 등\n   connection_id = \"\u003cID\u003e\" //기존 ID\n  }\n  notification: {\n   connection_type = \"Slack\"\n   //이것은 사용자 정의된 payload에요\n   payload_override = \u003c\u003cJSON \n    {\n     \"service_key\": \"your_pagerduty_api_integration_key\",\n     \"event_type\": \"trigger\",\n     \"description\": \"Alert: Triggered {TriggerType} for Monitor {Name}\",\n     \"client\": \"Sumo Logic\",\n     \"client_url\": \"{QueryUrl}\"\n    }\n   JSON\n  }\n  run_for_trigger_types = [\"Critical\", \"ResolvedCritical\"] //위의 알림 모니터 이미지용 체크박스를 선택할 거에요\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-15-Sumologicintegrationusingterraform_8.png\" /\u003e\n\n```js\nresource \"sumologic_monitor\" \"any_name\" {\n name = \"monitor_name\"\n parent_id = \"\u003cID\u003e\" //모니터가 생성될 폴더의 ID\n description = \"설명 문자열\"\n is_disabled = boolean // 이것은 모니터를 활성화 또는 비활성화할 거에요\n}\n```\n\n\n\n아래는 담당자의 작업 요약입니다:\n\n1. 'init.tf' 또는 'main.tf' 파일을 추가하여 Sumo Logic Terraform 공급자를 설치하고 초기화해야 합니다. main.tf 파일에 다음과 같은 코드를 추가하세요.\n\n```js\nterraform {\n\n backend \"s3\" {}\n\n required_providers {\n  sumologic = {\n   source = \"sumologic/sumologic\"\n   version = \"2.28.2\"\n  }\n }\n\n}\n\nprovider \"sumologic\" {\n access_id = \"\"\n access_key = \"\"\n}\n```\n\n2. 'sumologic-monitor.tf' 파일을 추가하여 위에서 언급한 내용이 포함된 'sumologic_monitor' 리소스를 추가하세요.\n3. 이후에는 테라폼 명령을 실행하면 됩니다.\n\n\n\n```js\nterrafrom init\nterrafrom plan\nterrafrom apply\n```\n\n참고 문서 -\n\n- Sumologic 모니터 생성에 대한 자세한 내용은 다음을 참조하세요: [Sumologic 모니터 생성](https://help.sumologic.com/docs/alerts/monitors/create-monitor/)\n- Terraform을 사용한 Sumologic 모니터 생성에 대한 자세한 내용은 다음을 참조하세요: [Sumologic 모니터 Terraform 문서](https://registry.terraform.io/providers/SumoLogic/sumologic/latest/docs/resources/monitor)\n- Sumologic API에 대한 자세한 내용은 다음을 참조하세요: [Sumologic API](https://api.sumologic.com/docs/#section/Getting-Started/API-Endpoints)","ogImage":{"url":"/assets/img/2024-05-15-Sumologicintegrationusingterraform_0.png"},"coverImage":"/assets/img/2024-05-15-Sumologicintegrationusingterraform_0.png","tag":["Tech"],"readingTime":5},{"title":"Kubernetes 복잡성 해결하기 파트 I","description":"","date":"2024-05-15 03:38","slug":"2024-05-15-NavigatingKubernetesComplexityPartI","content":"\n\n요즘 몇 년 동안 K8s 클러스터의 성장을 목격했습니다. 종종 서비스와 그를 사용하는 기업들... 실패하고 있다는 것을 보게 됩니다. 이러한 애플리케이션들은 작게 시작하여 유기적으로 성장하고 나중에는 느려지기 시작합니다. 디버깅 복잡성이 증가하고, 고객들이 짜증을 내며 불평을 하기 시작하고, 기업들은 성장 문제를 경험하며 등장했을 때와 같이 빠르게 사라지기도 합니다. 어떻게?!? 왜!?! 이 시리즈는 기업이 쿠버네티스 클러스터를 관리할 때 직면하는 어려움을 분석하여 실용적인 솔루션과 전문가의 통찰을 제공합니다. 지수적인 콜 수를 완화하고 소켓 이벤트 트래픽을 제어하는 등 각 기사는 성능을 최적화하고 안정성을 유지하는데 도움이 되는 선제적인 전략을 독자들에게 제공합니다.\n\n![image](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_0.png)\n\nK8s의 문제의 근본 원인은 매우 간단합니다: 복잡성! 그리고 우리는 개발자들을 탓할 수 없습니다 - K8s 위에 구축된 애플리케이션들은 일반적인 애플리케이션이 아니라 복잡한 분산 앱의 일부입니다. 분산 시스템은 쿠버네티스 클러스터 내에서 몇 백 개의 서비스만 작동하는 것보다 훨씬 복잡하며, 전반적인 그림을 파악하기는 매우 어려울 수 있습니다.\n\n![image](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_1.png)\n\n\n\n보통 시스템이 발전할수록 복잡성이 기하급수적으로 증가합니다. 특정 시기에는 내부 또는 외부 요청으로 인해 클러스터에 엄청난 부하가 걸리게 됩니다.\n\n나는 K8s를 좋아해요. 나의 의도는 그것을 깎아내릴 수 있는 것이 아니라, 실제 시스템에서 발생하는 상황들과 그 원인, 그리고 어떻게 방지할 수 있는지를 함께 알아보는 것입니다.\n\n# 1. 기하급수적 호출 수를 줄이기\n\n대부분의 K8s 앱은 다양한 서비스로 구성되어 있으며, 여기에 일반적인 앱 관리 서비스도 포함됩니다. 다음은 그 예시입니다:\n\n\n\n- Customers — 고객 상태 및 계획 확인\n- Users — 사용자 상태 확인\n- Permissions — 권한 관리\n\n이러한 공유 서비스들은 일반적으로 여러 서비스가 요청하여 해당 고객을 대신하여 작업을 중지해야 하는지 확인합니다. 이는 수신 요청 및 내부 서비스에도 적용됩니다.\n\n그래서, 다른 서비스를 호출할 수 있는 API 서비스를 만든다면, 간단한 요청이 여러 요청으로 변할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_2.png)\n\n\n\n예를 들어, 들어오는 요청(n)이 첫 번째 레벨에서 다섯 개의 요청(#1, #2, #3, #5, #7)을 생성하고 두 번째 레벨에서 세 개의 추가 요청(#4, #6, #8)을 생성했다고 가정해보겠습니다. 생성된 총 요청 수는 n*8가 될 것입니다. 이것은 매우 간단한 예시입니다. 코드를 깊게 파헤쳐보면 숨겨진 요청들 (DNS, 데이터베이스 쿼리, API 등)을 발견할 수 있을 것입니다.\n\n모든 것을 측정하면 여러분의 애플리케이션이 예상 이상으로 기하급수적으로 복잡함을 발견할 수 있을 것입니다.\n\n요청의 지수적인 효과는 초기 요청보다 여덟 배 더 큰 내부 부하를 만들어 낼 수 있으며, 이는 우리 앱을 다운시킬 수 있습니다.\n\n수식을 해봅시다: 클러스터가 120만 개의 내부 요청을 처리할 수 있다고 가정해봅시다. 매일 클러스터는 10만 개의 외부 요청을 처리하고, 이는 내부 요청을 여덟 배 더 생성합니다 (대략 80만 개의 내부 요청). 이는 클러스터에 추가로 40만 개의 내부 요청을 처리할 여유가 있다는 것을 의미합니다. 이는 상당히 크게 느껴질 수 있지만, 추가로 5만 개의 외부 요청이 더 들어오면 한계점에 다다를 수 있습니다. 더 흥미로운 사실은 각 내부 요청을 줄일수록 한계점과의 거리가 멀어진다는 것인데, 이는 더 작은 자원으로 더 많은 일을 처리하면서 지수적인 증가를 줄일 수 있다는 것을 의미합니다.\n\n\n\n현재로서는 로드가 더 이상 비선형이 아니라 지수적입니다. 추가 요청 몇 개만으로도 앱의 일부가 다운되거나 응답하지 않고 불안정해질 수 있습니다.\n\n이런 일이 일어나지 않도록 어떻게 할 수 있을까요? 다행히 우리가 시도해볼 수 있는 몇 가지 쉬운 전략이 있습니다.\n\n## 컨텍스트 전파 사용\n\n컨텍스트 전파를 사용하면 요청 사이에서 재사용 가능한 정보를 헤더를 통해 주입하고 전파할 수 있습니다. 이를 통해 모든 서비스가 동일한 데이터를 요청하는 대신 요청을 만드는 모든 서비스로 데이터 집합을 전파할 수 있습니다.\n\n일부캐시(near caches)가 익숙할 것입니다. 데이터는 수명이 몇 초간 유지되는 TTL(time-to-live)을 가집니다. 우리는 요청의 시작 시간 초과에 맞게 TTL이 설정된 헤더에서 데이터 전달의 소스로서 컨텍스트 전파를 사용할 수 있습니다. TTL이 만료되면 클라이언트는 데이터를 새로 고침하고 그 후손 자식 요청으로 전파하기 전에 데이터를 갱신할 수 있어야 합니다. 이를 통해 헤더가 Kafka와 같은 다른 시스템으로 전파될 수 있습니다.\n\n예를 들어 고객 정보(#2)를 자식 요청으로 전파하면 하류에서 세 개의 요청을 절약할 수 있습니다.\n\n\n\n\n![Screenshot 1](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_3.png)\n\nThis lets you propagate a previous request downstream:\n\n![Screenshot 2](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_4.png)\n\n## Apply near caching\n\n\n\n\n일반적인 모범 사례에 따르면 정보 제공 서비스는 캐싱과 데이터 관리에 책임을 져야 합니다. 그러나 네이어 캐시는 높은 호출량을 갖는 API에 필수적입니다. 왜냐하면 우리는 보통 같은 메서드를 반복적으로 호출하기 때문이죠. 인스턴스를 확장할 수는 있지만, 아무 것도 무한정으로 확장되지는 않습니다. 그래서 네이어 캐싱을 통해 클러스터를 안정화할 수 있습니다.\n\n네이어 캐싱은 단명한 (가끔 몇 초 동안 유지되는) 클라이언트 측 캐시를 이용한 기술입니다. 만약 일반적인 HTTP 클라이언트에서 전역 캐싱 정책을 정의한다면, 모든 서비스에서 공통 요청에 대해 그 정책을 사용할 수 있습니다. 이는 이미 포화된 인프라에서 요청을 번들로 처리하고 비용을 상당히 절감할 수 있습니다.\n\n요청은 보통 묶음으로 들어옵니다. 고객이 페이지를 로드하기 시작하면, 여러 요청이 일어납니다. 현재 요청 이전에 몇 개의 요청이 이미 이루어졌다면(예: 이 예시에서의 #1 및 #2), 저희의 캐시는 이미 워밍업되어 있기 때문에 다음 요청에서 그 정보를 재활용하여 일부 호출을 절약할 수 있습니다.\n\n그래서 대규모에서 매우 단순한 기술을 사용하여 8개 중 5개의 호출을 절약했습니다. 믿어주세요, 실제 시스템은 이 예시보다 훨씬 복잡하기 때문에 혜택은 더 커질 수 있습니다. 복잡성을 줄이고 지수적인 증가를 최소화하여 8개 중 5개의 요청을 절약했습니다.\n\n\n## 호출 추적 로깅\n\n호출 추적을 로깅하면 요청의 시작부터 끝까지의 단계를 감지하고 분석할 수 있으며 어떤 호출이 이루어지는지 볼 수 있습니다. Grafana Tempo는 여러분의 추적을 저장하고 조회할 수 있는 솔루션 중 하나입니다.\n\n\n\n아래는 마크다운 포맷으로 변경해 드릴게요.\n\n\n![image](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_6.png)\n\n## 대량 요청 실행\n\n동일한 API를 여러 번 호출해야 할 경우, 리소스를 절약하고 네트워크 시간을 절약하기 위해 한 번에 모두 요청하세요.\n\n## 요청 속도 제한 (HTTP 429 '요청이 너무 많음')\n\n\n\n\n글로벌, 고객 및 사용자별로 허용 가능한 속도 제한을 부과하여 클러스터의 사용성에 영향을 줄 수 있는 남용을 방지하세요. 웹 애플리케이션 방화벽 (WAF)을 추가하는 것도 필요합니다. 최근에는 암호화된 HTTPS 데이터를 푸시하여 요청을 실행하는 결정을 서버가 아닌 방화벽이 내리는 데 영향을 미치지 않는 경우가 있습니다.\n\n이러한 조치를 취하면 남용을 방지하고 K8s 클러스터가 받는 부하를 제어할 수 있습니다.\n\n![image](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_7.png)\n\n이렇게 함으로써 WAF가 원치 않는 요청을 차단할 수 있습니다. 다양한 수준에서의 속도 제한은 고객 및 사용자의 요청 남용을 제어하여 클러스터가 지나치게 많은 부하를 처리하지 않도록 합니다. 물론 클러스터 수준에서 불필요하게 차단하길 원치는 않지만, 그 지점에 도달하면 클러스터가 이미 불안정할 수 있습니다. 따라서 모든 요청을 대규모로 실패시키는 것보다 429 상태 코드를 반환하는 것이 나은 대안입니다.\n\n# 2. 소켓 이벤트 트래픽 제어하기\n\n\n\n모든 메이저 웹 애플리케이션은 현재 서버에서 브라우저로 푸시 알림을 받습니다. 브라우저가 거의 실시간 데이터를 받을 수 있다는 것이 멋지다고 생각하지만, 그것들은 전통적인 데스크톱 애플리케이션처럼 보이고 느끼게 만들어줍니다. 그러나 브라우저는 아니라는 것을 명심해야 합니다.\n\n가끔 앱의 능력에 대해 잘못된 가정을 할 때도 있습니다.\n\n\"우리 서버는 백엔드에서 수천 개의 이벤트를 처리할 수 있어요.\" 네... 그런데 당신의 고객 브라우저는 그것을 처리할 수 있을까요? 고객의 머신은 서버가 아닙니다. 그들은 서버와 같은 처리 능력과 메모리를 가지고 있지 않습니다. 클라이언트 측에서 동일한 처리 능력을 모방하려고 한다면 실패로 이어질 것입니다.\n\n![이미지](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_8.png)\n\n\n\n푸시 알림은 최선을 다해 전달되어야 합니다: 프론트엔드로 이벤트를 전송하려고 노력하지만 보장할 수는 없습니다.\n\n고객이 백만 개의 업데이트를 생성하는 시나리오에서는 브라우저로 그만큼의 이벤트를 전달하려고 시도조차 해서는 안 됩니다. 이렇게 하면 대량의 데이터가 브라우저로 전송되어 플러시하는 데 몇 분 또는 심지어 몇 시간이 걸릴 수 있으며 네트워크 레이턴시에도 영향을 미칠 수 있습니다. 결국 좋은 대역폭을 갖춘 곳도 있고 강력한 컴퓨터를 갖춘 곳도 모두가 아니기 때문입니다.\n\n마지막으로 이처럼 많은 정보를 고객의 브라우저로 전달하는 것은 비용이 들 수 있습니다. 일부 데이터 센터는 외부 트래픽에 대해 요금을 부과하기 때문입니다.\n\n가끔은 이러한 이벤트를 듣고 있는 컴포넌트가 있어 업데이트되고 다른 요청을 만들기도 합니다. 몇몇 업데이트는 더 많은 요청을 만들어 눈덩이 효과를 낼 수 있습니다. 때로는 컴포넌트를 숨기지만 계속 청취하도록 유지하는 경우도 있으며, 이로 인해 이벤트 당 렌더링을 생성해 보이지 않게 될 수도 있습니다.\n\n\n\n그래서, 그 대신 어떻게 해야 할까요?\n\n### 아웃바운드 트래픽 속도 제한\n\n너무 많은 데이터를 밀어넣으면 고객의 브라우저와 네트워크가 느려지고 비용이 증가합니다. 그래서 데이터를 수용 가능한 수준으로 유지해야 합니다. 특정 사용자가 여러 브라우저나 탭으로 인한 여러 연결을 가지고 있다면 연결 수로 속도 제한을 나누어 사용자로부터 푸시되는 데이터 양을 제어할 수 있습니다.\n\n## 서버 측 이벤트 삭제\n\n\n\n과거 몇 분 이전의 이벤트는 삭제합니다. 이는 데이터가 쌓여 시작될 때 즉시 데이터를 버린다는 의미입니다. 비상 이벤트는 어떻게 할까요? 우리는 중요한 데이터를 일회용이 아닌 것으로 취급해야 합니다. 그러나 브라우저에서 받아야 할 소규모의 중요한 데이터 묶음에 대해서는 그렇지 않습니다. 예를 들어, 작업 확인과 같은 이벤트들은 다른 이벤트들보다 먼저 도착할 수 있도록 우선순위 레인이 있어야 합니다.\n\n![이미지](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_9.png)\n\n## 모든 필요한 데이터를 보내기\n\n모든 필요한 데이터는 이벤트의 일부여야 합니다. 프론트엔드는 알림을 받은 후 추가 요청을 하지 말아야 합니다. 그렇게 하면 이벤트에 기반한 비선형 요청이 발생합니다. 하나의 이벤트가 도착하면 한 번의 요청을 보내지만, 100k개의 이벤트를 받으면... 문제가 생길 수 있습니다. 특히 수천 명의 활성 사용자가 있는 경우 더욱 그렇습니다.\n\n\n\nAPI 요청을 관리하는 API 클라이언트를 사용하고, 브라우저 측에 가까운 캐시를 유지하여 일정 기간 동안 데이터를 유지하고 동일한 데이터에 대한 반복적인 호출을 피하세요. 가능하면 일부 전역 구성을 사용해주세요.\n\n![이미지](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_10.png)\n\n## 대기 중인 숨겨진 구성 요소를 준비하세요\n\n데이터를 수신하지만 다시 보이고 마지막으로 다시 렌더링 될 때까지 렌더링을 건너뛰세요. 여러 이벤트를 보내고 여러 숨겨진 구성 요소를 렌더링하는 경우, 쓸모없는 구성 요소를 렌더링하여 브라우저 성능에 영향을 줍니다.\n\n\n\n싱글 페이지 애플리케이션도 잘못된 아키텍처 결정으로 성능 문제가 발생할 수 있어요. 데이터와 뷰를 분리해서 업데이트하면서 뷰를 렌더링하지 않고 업데이트할 수 있어요.\n\n![image](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_11.png)\n\n# 3. 자체 프런트엔드 DDoS (분산 서비스 거부)\n\n때로는 개발자들이 영향을 인식하지 못하는 경우가 있어요. 토론이나 회의 중에 나타나는 몇 가지 사소한 문제들이 있어요.\n\n\n\n\"내 컴포넌트에 추가 요청을 딱 하나만 넣었어요.\"\n\n딱 한 개죠? 실제로, 그 컴포넌트가 다른 사용자에게 표시되는 횟수에 따라 다를 수 있습니다. '단 하나'의 추가 요청이 기능을 망가뜨린 것은 처음이 아닙니다. 왜냐하면 그 요청으로 많은 요청이 생성되어 기능이 그렇게 많은 요청을 처리할 준비가 되어있지 않았기 때문입니다. 실제로 라이브로 이를 배포하면 거의 즉시 망가질 것입니다. 또한 사용되는 페이지와 트래픽 양에 따라 달라집니다.\n\n\"내 React 컴포넌트는 내부 상태에 예상치 못한 케이스가 있어서, 지속적인 렌더링으로 인해 API 호출 무한 루프에 빠졌어요.\"\n\n이를 수천 명의 고객들에 대해 곱한다면, 모든 것이 다운될 것입니다. 재밌는 점은 수정을 배포했다 하더라도, 브라우저가 이를 감지하고 Javascript를 새로 고칠 때까지 시간이 걸릴 것이며, 이러한 사고를 완전히 해결하기가 어려울 수 있습니다.\n\n\n\n\"브라우저 DOM에 일부 구성 요소를 캐시하기로 결정했습니다.\"\n\n이론적으로는 괜찮아요. 이론상으로는요!\n\n대부분의 경우에는 숨겨진 구성 요소들이 계속 백그라운드에서 작동하여 이벤트를 수신하고 렌더링하며, 비록 보이지는 않지만 계속 작업을 수행합니다. 더 나쁜 경우에는 때로는 요청이 필요하지 않은 상태로 계속 발생하기도 합니다. 이런 일이 반복되면 모든 것을 느리게 만드는 충분한 수의 요청이 생성됩니다. 이러한 이벤트들이 숨겨진 구성 요소와 API 호출과 결합되면, 완벽한 슬로우다운 현상이 발생합니다: 앞단과 뒷단에서의 느림 현상이 발생합니다.\n\n단일 요청이 문제가 될 수 없을 것 같죠? 그러나 규모를 고려할 때, 수천 명의 사용자가 있는 상황에서는 요청이 수천 개로 변합니다. 그 영향의 크기는 여러 요소에 의해 달라집니다. 해당 구성 요소가 주요 페이지에 사용되는지 혹은 사용자가 많이 이용하는 페이지에 있는지 여부는 어떨까요? 백엔드가 그러한 요청을 처리할 수 있는지? 데이터베이스에 캐싱이 되어 있어서 데이터베이스에 접근할 필요가 없는지? 데이터베이스에는 이러한 요청을 처리할 복제본이 있는지? 프론트엔드 코드가 예기치 않은 시나리오를 방지할 만큼 충분히 커버리지가 되어 있는지?\"\n\n\n\n이 문제를 어떻게 완화할 수 있는지 알아보겠습니다.\n\n## 요청의 적절한 수를 처리할 수 있도록 기능을 준비하세요\n\n캐싱을 추가하고, 계산을 해서 적절하게 확장하세요. 데이터베이스가 도움 없이 모든 요청을 처리할 수 있다고 가정하지 마세요.\n\n## 프론트엔드 구성 요소에는 좋은 코드 커버리지가 필요합니다\n\n\n\n그렇지 않으면 모든 상황에서 잘 작동하지 않을 수 있습니다. 이는 앱을 충돌시킬 수 있는 무한 루프를 발생시킬 수 있습니다. 이러한 무한 루프는 모든 브라우저에서 Javascript 코드를 무효화해야 하기 때문에 감지하고 되돌릴 때 매우 어려울 수 있습니다.\n\n## 충분한 경고가있는 서비스 또는 엔드 포인트 지표\n\n일주일 동안 종단점이 일반적으로 받는 요청의 주간 이동 평균을 계산하고 시간당 청크로 나누세요. 이제 시간별 이동 평균을 사용하세요.\n\n![이미지](/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_12.png)\n\n\n\n마크다운 형식으로 테이블 태그를 변경하실 수 있습니다.\n\n\n\n두 값을 나누면 예상 최대 및 최소 비율이 나오는데, 이는 적응성이 있고 시간에 따라 요청 변동을 따릅니다. 이 비율은 시간당 요청이 주간 요청을 초과하거나 이하한 빈도를 신호합니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_13.png\" /\u003e\n\n```js\n(sum(increase(docbase_api_web_request_count{service=\"docbase-api\"}[1h]))) / \n(sum(increase(docbase_api_web_request_count{service=\"docbase-api\"}[1w]))/7/24)\n```\n\n이제 이러한 요청에 대한 알림을 생성할 수 있습니다. 예를 들어, 임계값을 3.5 또는 4로 설정하면 트래픽의 예상치를 초과하는 경우에 알림을 받게 됩니다 (차트에서 지난 주에는 3을 넘지 않았음을 볼 수 있습니다). 요청 수에 기반한 알림을 설정하는 경우, 트래픽 패턴이 변경될 때마다 요청 번호를 업데이트해야 합니다.\n\n\n\n이 알림을 만들면 일반적으로 감지하기 어려운 트래픽 변화를 모니터링할 수 있습니다. 특히 자체 생성된 DDoS 공격의 경우, 합법적이고 인가된 트래픽이라도 감지하는 데 몇 주가 걸릴 수 있습니다.\n\n# 최종 메모\n\nK8s는 때로 잘못 사용되거나 제대로 이해되지 않을 수 있지만, 좋은 도구입니다. 이를 사용하는 것은 쉽지만, 우리가 원하는 대로 확장하는 것은 훨씬 복잡하며, 예상과 달리 일어나면 혼란스럽고 당황스럽게 만들 수 있습니다.\n\nK8s를 사용할 때 제안하는 바는 상식을 사용하는 것입니다. 상상력을 발휘하고 무엇이 일어나고 있는지, 어떻게 개선할 수 있는지 스스로에게 물어보고, 물론 규모에 맞게 생각하는 것입니다. 그냥 요청만 하는 것이 아닙니다. 그냥 구성 요소만 있는 것이 아닙니다. 모든 것이 제대로 최적화되지 않거나 고려되지 않으면 큰 영향을 줄 수 있습니다.\n\n\n\n\n적절한 도구를 갖추는 것도 매우 중요해요. 추적을 위해 Tempo를 사용하고, 로깅을 위해 Loki를 사용하며, 메트릭 및 경고를 위해 Grafana를 사용하세요. 이 도구들이 없다면, 기본적으로 맹목적일 거예요. K8s를 작동시키려면 백엔드에 OpenTelemetry를, 프론트엔드에는 Faro와 같은 RUM(실 사용자 모니터링) 도구를 사용해야 해요.\n\n쿠버네팅을 즐기세요.\n\n(계속됨…)\n\n참고 문헌:\n\n\n\nhttps://www.meetup.com/pipedrive-talks-lisbon/events/299275446/\n\nhttps://medium.com/dev-beinfra/k8s-pt-4-deployment-istio-aks-33201db9156a\nhttps://www.rawpixel.com/image/12649860/bomb-explosion-effect-png-transparent-background","ogImage":{"url":"/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_0.png"},"coverImage":"/assets/img/2024-05-15-NavigatingKubernetesComplexityPartI_0.png","tag":["Tech"],"readingTime":10},{"title":"최근 놓치고 있는 도커 빌드킷의 기능들","description":"","date":"2024-05-15 03:35","slug":"2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn","content":"\n\n![이미지](/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png)\n\nBuildKit 도입으로 Docker의 향상된 빌더 백엔드가 도입되었고, 많은 새로운 기능이 Docker에 추가되었습니다. 그 중 많이 알려지지 않은 기능들을 알아야 할 것이며, Docker를 더 잘 활용하기 위해 사용해야 할 것들에 대한 소개입니다.\n\n# 디버깅\n\n가장 일반적인 작업인 디버깅부터 시작해보겠습니다. Docker 빌드의 디버깅은 항상 고통스러운 작업이었습니다. RUN 또는 COPY 명령이 실패하면 일반적으로 문제가 발생한 상황을 확인하고 디버깅하기가 까다로웠습니다. 일반적으로 RUN ls -la와 같은 명령을 추가하여 더 많은 정보를 얻기 위해 시도했습니다. 그러나 이제는 docker buildx debug를 통해 이 상황이 바뀌었습니다.\n\n\n\n```js\nexport BUILDX_EXPERIMENTAL=1\ndocker buildx debug --invoke /bin/sh --on=error build .\n\n[+] Building 1.2s (14/18)                docker:default\n...\n------\n \u003e [builder 5/6] RUN exit 1:\n------\nDockerfile:10\n--------------------\n   8 |     RUN pip3 install -r requirements.txt\n   9 |     \n  10 | \u003e\u003e\u003e RUN exit 1\n  11 |     \n  12 |     COPY . /app\n--------------------\nERROR: process \"/bin/sh -c exit 1\" did not complete successfully: exit code: 1\n[+] Building 0.0s (0/0)                  docker:default\nLaunching interactive container. Press Ctrl-a-c to switch to monitor console\nInteractive container was restarted with process \"u6agxp1ywqapemxrt8iexfv4h\". Press Ctrl-a-c to switch to the new container\n/ # ls -la\ntotal 72\ndrwxr-xr-x    1 root     root          4096 May  5 12:59 .\ndrwxr-xr-x    1 root     root          4096 May  5 12:59 ..\ndrwxr-xr-x    1 root     root          4096 May  4 10:11 app\n...\n```\n\n위 스니펫에서 먼저 실험적인 BuildKit 기능을 BUILDX_EXPERIMENTAL 환경 변수로 활성화합니다. 그런 다음 docker buildx debug를 통해 빌드를 시작합니다. 빌드가 어느 시점에서든 실패하면 컨테이너로 이동하여 실행 문맥을 탐색하고 디버깅할 수 있습니다.\n\n빌드가 실패했을 때만 디버그 세션을 시작하는 --on=error 옵션을 포함했음에 유의하세요.\n\n자세한 내용은 디버깅 문서를 참조하십시오.\n\n\n\n# 환경 변수\n\n만약 이전에 BuildKit으로 빌드를 실행했다면 새롭고 멋진 로그 출력을 눈치챘을 것입니다. 멋져 보이긴 하지만 디버깅할 때는 그리 실용적이지 않죠. 그럴 때는 평범한 로그 출력으로 전환할 수 있는 환경 변수가 있습니다:\n\n```js\nexport BUILDKIT_PROGRESS=plain\n```\n\n원하는 경우 rawjson으로 설정할 수도 있지만, 이는 사람이 직관적으로 읽기 어려울 수 있지만 어떤 방식으로든 로그를 처리하고 싶을 때 유용할 수 있습니다.\n\n\n\n만약 TTY 기반의 동적 출력을 좋아하지만 색상을 싫어한다면, 간단히 다음과 같이 변경할 수 있습니다:\n\n```js\nBUILDKIT_COLORS=\"run=green:warning=yellow:error=red:cancel=cyan\" docker buildx debug --invoke /bin/sh --on=error build .\n```\n\n위와 같이 출력이 변합니다:\n\n\u003cimg src=\"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_1.png\" /\u003e\n\n\n\n기타 환경 변수에 대한 문서를 참조해보세요.\n\n# Exporters\n\nBuildKit은 빌드 결과물이 어떻게 저장될지를 정의하는 수출자(Exporters) 개념을 소개합니다. 가장 유용한 두 가지 옵션은 이미지(image)와 레지스트리(registry)입니다. image는 기대했을 것처럼 빌드 결과물을 컨테이너 이미지로 저장하며, 레지스트리 수출자는 자동으로 지정된 레지스트리로 푸시합니다:\n\n```js\ndocker buildx build --output type=registry,name=martinheinz/testimage:latest .\n```\n\n\n\n우리가 해야 할 일은 --output 옵션을 지정하고 registry의 유형과 대상을 설정하는 것뿐입니다. 이 옵션은 한 번에 여러 레지스트리를 지정하는 것도 지원합니다:\n\n```js\ndocker buildx build --output type=registry,\\\"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\\\" .\n```\n\n마지막으로, --cache-to 및 --cache-from 옵션을 제공하여 레지스트리에서 기존 이미지를 캐시 소스로 사용할 수도 있습니다:\n\n```js\ndocker buildx build --output type=registry,name=martinheinz/testimage:latest \\\n --cache-to type=inline \\\n --cache-from type=registry,ref=docker.io/martinheinz/testimage .\n\n...\n =\u003e CACHED docker-image://docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a858632727cf7a112fbfd19b17e94c4e84ced81e24ef1a0dbc\n...\n =\u003e CACHED [builder 2/5] WORKDIR /app                                                                                                  0.0초\n =\u003e CACHED [builder 3/5] COPY requirements.txt /app                                                                                    0.0초\n =\u003e CACHED [builder 4/5] RUN --mount=type=cache,target=/root/.cache/pip     pip3 install -r requirements.txt                           0.0초\n =\u003e CACHED [builder 5/5] COPY . /app                                                                                                   0.0초\n =\u003e CACHED [dev-envs 1/3] RUN \u003c\u003cEOF (apk update...)                                                                                    0.0초\n =\u003e CACHED [dev-envs 2/3] RUN \u003c\u003cEOF (addgroup -S docker...)                                                                            0.0초\n =\u003e CACHED [dev-envs 3/3] COPY --from=gloursdocker/docker / /                                                                          0.0초\n =\u003e preparing layers for inline cache                                                                                                  0.0초\n...\n```\n\n\n\n# 이미지 도구\n\n도커 빌드x의 간편하지만 유용한 서브커맨드인 imagetools는 이미지를 가져오지 않고도 레지스트리의 이미지를 검사할 수 있게 해줍니다. 자세한 내용은 많은 예시를 포함하고 있지만, 저에게 가장 유용한 것은 원격 이미지의 다이제스트를 가져오는 것입니다:\n\n```js\ndocker buildx imagetools inspect alpine --format \"{json .Manifest}\" | jq .digest\n\"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6a\"\n```\n\n# 최신 Dockerfile 구문\n\n\n\n빌드킷과 함께 새로운 Dockerfile 구문이 도입되었습니다. 이를 통해 Dockerfile 프론트엔드라는 것이 사용됩니다. 현재 최신 구문을 활성화하려면 Dockerfile 맨 위에 다음과 같은 지시문을 추가해야 합니다:\n\n```js\n# syntax=docker/dockerfile:1.3\nFROM ...\n```\n\n버전을 확인하려면 dockerfile-upstream 도커 허브 저장소를 확인하세요.\n\n\n\n지금부터 소개할 첫 번째 도커 파일 문법 개선 사항은 here-docs입니다. 여기서는 멀티 라인 스크립트를 RUN 및 COPY 명령어에 전달할 수 있게 해줍니다:\n\n```js\n# syntax = docker/dockerfile:1.3-labs\nFROM debian\nRUN \u003c\u003ceot bash\n  apt-get update\n  apt-get install -y vim\neot\n\n# 같은 내용:\nRUN apt-get update \u0026\u0026 apt-get install -y vim\n```\n\n과거에는 단일 RUN에 여러 명령어를 넣고 싶다면 \u0026\u0026을 사용해야 했지만, 이제는 here-docs를 사용하여 일반 스크립트를 작성할 수 있습니다.\n\n게다가, 첫 번째 줄에서 해석기를 지정할 수 있어 Python 스크립트를 작성할 수도 있습니다:\n\n\n\n```bash\n# syntax = docker/dockerfile:1.3-labs\nFROM python:3.6\nRUN \u003c\u003ceot\n#!/usr/bin/env python\nprint(\"hello world\")\neot\n```\n\n# COPY and ADD Features\n\n새로운 Dockerfile 구문에서는 COPY 및 ADD에 대한 변경 사항과 개선 사항도 더 많이 있습니다.\n\nCOPY는 이제 --parents 옵션을 지원합니다:\n\n\n\n\n```js\n# syntax=docker/dockerfile:1.7.0-labs\nFROM ubuntu\n\nCOPY ./one/two/some.txt /normal/\n\nRUN find /normal\n#10 [3/5] RUN find /normal\n#10 0.223 /normal\n#10 0.223 /normal/some.txt\n\nCOPY --parents ./one/two/some.txt /parents/\n\nRUN find /parents\n#12 [5/5] RUN find /parents\n#12 0.509 /parents\n#12 0.509 /parents/one\n#12 0.509 /parents/one/two\n#12 0.509 /parents/one/two/some.txt\n```\n\n만약 일반 COPY로 중첩된 파일을 복사하면 이미지에는 부모 디렉토리 없이 파일 자체만 포함되며, --parents로 전체 파일 트리가 복사됩니다. 이는 cp --parents의 작동 방식과 유사합니다.\n\n--exclude 옵션을 사용할 수 있는 것과 같이, --parents 옵션도 사용할 수 있습니다:\n\n```js\nCOPY --exclude=*.txt ./some-dir/* ./some-dest\n```\n\n\n\n파일을 복사할 때 제외된 파일 및 패턴을 무시하는 옵션입니다.\n\n마침내 ADD 명령어도 향상되었습니다 - 이제 Git 저장소를 직접 추가할 수 있습니다:\n\n```js\n# syntax=docker/dockerfile:1.7.0-labs\nFROM ubuntu\n\nADD git@github.com:kelseyhightower/helloworld.git /repo\nRUN ls -la /repo\n```\n\n이 Dockerfile을 빌드하면 다음과 같은 결과를 얻을 수 있습니다:\n\n\n\n\ndocker buildx build --ssh default --progress=plain .\n- [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo\n  - Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.\n  - ref: refs/heads/master HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   refs/heads/master\n  - ref: refs/heads/master HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\n    - From github.com:kelseyhightower/helloworld\n      - [new branch]      master     -\u003e master\n      - [new branch]      master     -\u003e origin/master\n  - DONE 7.4s\n- [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo\n  - DONE 0.0s\n\n\n이것은 비공개 저장소에도 작동합니다.\n\n더 많은 흥미로운 옵션을 문서에서 볼 수 있습니다. 예를 들어, --keep-git-dir이나 --checksum을 통해 아티팩트 체크섬을 유효성 검사할 수 있습니다.\n\n# 보너스: 들여쓰기\n\n\n\n그리고 BuildKit 기능은 아니지만, 최근에 발견한 하나의 사실은 Dockerfile에서 줄을 들여쓰면 잘 작동한다는 것입니다. 이렇게 하면 다단계 빌드를 진행할 때 가독성이 향상되는 효과를 얻을 수 있습니다:\n\n```js\n# syntax=docker/dockerfile:1\nFROM golang:1.21\n  WORKDIR /src\n  \n  COPY main.go .\n  RUN go build -o /bin/hello ./main.go\n\nFROM scratch\n  COPY --from=0 /bin/hello /bin/hello\n  CMD [\"/bin/hello\"]\n```\n\n처음에는 이상하게 보일 수 있지만, 내견에 따르면 더 읽기 쉬워져서 각 단계가 어디에서 시작되고 어떤 명령이 속해 있는지 명확해집니다.\n\n# 결론\n\n\n\n이 기사의 예시는 내가 가장 유용하다고 생각하는 기능들만을 보여줍니다. 그러나 Docker 공식 문서와 BuildKit 문서, 또한 최신 변경 사항을 확인해보십시오. Docker 블로그도 좋은 자료가 있으며 특히 표시된 글들을 확인해보세요.\n\n이 기사는 원래 martinheinz.dev에서 게시되었습니다.\n\n또한 다음 글들을 즐기실 수도 있습니다...","ogImage":{"url":"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png"},"coverImage":"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png","tag":["Tech"],"readingTime":8},{"title":"데이터 보안 Databricks의 열 수준 암호화","description":"","date":"2024-05-15 03:31","slug":"2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks","content":"\n\n데이터 보안은 모든 데이터 엔지니어링 플랫폼에서 중요한 개념 중 하나입니다. 대부분의 기업들은 데이터 플랫폼의 보안 기능을 구현하기 위해 많은 비용을 투자합니다.\n\n# 왜 데이터 보안이 중요한가요?\n\n- 민감한 정보 보호: 먼저, 민감한 정보를 보호해야 합니다. Databricks는 대량의 데이터를 저장하고 처리하는 데 사용됩니다. 그 중에는 금융 데이터, 개인 정보 또는 지적 재산과 같이 민감한 정보가 포함될 수 있습니다. 그러므로, 민감한 정보가 \"무단 접근\", \"도난\" 또는 \"남용\"으로부터 보호되도록 하는 것이 중요합니다.\n- 규정 준수: 대부분의 산업은 \"규정 준수\"와 같은 일정한 규제를 따릅니다. 그러한 \"규정\"은 민감한 데이터의 생산을 강제합니다. 이러한 \"규정\"을 준수하면 법적 제재를 피하는 데 도움이 됩니다.\n- 데이터 침해 방지: 데이터 침해는 \"재정적 손실\", \"계산적 피해\" 또는 \"법적 책임\"을 포함한 심각한 결과를 초래할 수 있습니다. 적절한 데이터 보안 조치를 통해 데이터 침해를 예방하고 영향을 최소화할 수 있습니다.\n- 고객과의 신뢰 유지: 고객과의 신뢰를 유지하는 것은 어떤 비즈니스에게 가장 중요한 부분 중 하나입니다. 고객과 클라이언트는 그들의 데이터를 기업에 신뢰합니다. 고객 데이터가 안전하다는 것을 보장하는 것은 그들의 신뢰를 유지하고 장기적인 관계를 유도하는 데 중요합니다.\n\n# Databricks 보안 기능\n\n\n\nDatabricks는 다음과 같은 보안 기능을 제공하여 Databricks 플랫폼에 저장되고 처리되는 데이터의 보안과 개인 정보 보호를 보장합니다 -\n\n- 휴식 시 암호화\n- 이동 중 암호화\n- 역할 기반 액세스 제어\n- 다중 인증 요소\n- 감사 로깅\n\n# 열 수준 휴식 중 암호화\n\nDelta Lake가 개발되거나 Databricks 내에서 데이터 웨어하우징 솔루션이 구축될 때마다 데이터를 \"열 수준\"에서 \"암호화\"할 수 있습니다.\n\n\n\n## 단계 1: 델타 테이블 만들기\n\n```js\nfrom delta.tables import *\n\nDeltaTable.create(spark)\\\n  .tableName(\"tbl_Person\")\\\n  .addColumn(\"Person_Id\", \"INT\")\\\n  .addColumn(\"Person_Name\", \"STRING\")\\\n  .addColumn(\"Person_Adhar_No\", \"STRING\")\\\n  .execute()\n```\n\n델타 테이블에서 \"Person_Adhar_No\" 열에는 민감한 정보, 즉 PII(개인 식별 정보)가 포함될 것입니다. 따라서 이 특정 열에 보안이 강제됩니다.\n\n## 단계 2: PII 데이터를 델타 테이블에 삽입하기\n\n\n\n```js\n%sql\nINSERT INTO tbl_Person VALUES(101, \"Oindrila Chakraborty\", \"123456789012\");\nINSERT INTO tbl_Person VALUES(102, \"Soumyajyoti Bagchi\", \"234567890123\");\nINSERT INTO tbl_Person VALUES(103, \"Abhirup Chakraborty\", \"345678901234\");\nINSERT INTO tbl_Person VALUES(104, \"Souvik Roy\", \"456789012345\");\n```\n\n## Step 3: View Data of the Delta Table\n\n```js\n%sql\nSELECT * FROM tbl_person;\n```\n\nOutput -\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks_0.png\" /\u003e\n\n## 단계 4: \"cryptography\" Python 라이브러리 설치\n\n테이블의 데이터를 쿼리할 때 민감한 정보가 그대로 표시됩니다. 이는 PII 데이터가 오용될 수 있는 보안 위협입니다.\n\n민감한 정보, 즉 PII(개인 식별 정보)가 그대로 표시되는 것을 방지하기 위해 \"Cryptography\"를 사용할 수 있습니다.\n\n\n\n파이썬 라이브러리인 \"cryptography\"를 설치해야 합니다.\n\n```js\npip install cryptography\n```\n\n## 단계 5: \"cryptography\" Python 라이브러리의 \"Fernet\" 라이브러리를 사용하여 암호화/복호화 키 생성\n\n\"암호화\" Python 라이브러리 내부에 있는 \"Fernet\"라는 라이브러리를 사용해야 합니다. \n\"Fernet\" 라이브러리에는 \"generate_key()\", \"encrypt()\", \"decrypt()\" 등 여러 메서드가 있습니다.\n\n\n\n이제 먼저 \"암호화 키\"를 생성해야 합니다. 이 키를 사용하여 데이터를 \"암호화\"하거나 \"복호화\"할 수 있습니다.\n\n```js\nfrom cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\nk = Fernet(key)\n```\n\n위 코드는 \"암호화 키\"를 생성하고 \"k\"라는 변수에 저장합니다.\n\n## 단계 6: 델타 테이블의 PII 데이터를 암호화하는 UDF 생성\n\n\n\nDelta Table \"tbl_person\"의 열인 \"Person_Adhar_No\"에서 PII 데이터를 받아 들이는 \"encrypt_data\"라는 UDF를 작성해 보겠습니다. 그리고 생성된 \"암호화 키\"도 받아들입니다. 그런 다음, 이 UDF는 수신된 데이터에 대해 암호화를 적용하기 위해 라이브러리 \"Fernet\"의 \"encrypt ()\" 함수를 호출할 것입니다.\n\n```python\ndef encrypt_data(data, key):\n    from cryptography.fernet import Fernet\n    k = Fernet(key)\n\n    data_in_byte = bytes(data, \"utf-8\")\n    encrypted_data = k.encrypt(data_in_byte)\n    encrypted_data = str(encrypted_data.decode(\"ascii\"))\n\n    return encrypted_data\n```\n\n## 단계 7: 델타 테이블의 암호화된 PII 데이터를 복호화하는 UDF 생성\n\n델타 테이블의 열 \"Person_Adhar_No\"에서 이미 암호화된 PII 데이터를 받아 들이는 다른 UDF를 만들어 보겠습니다. 그리고 생성된 \"암호화 키\"도 받아들입니다. 그런 다음, 이 UDF는 이미 암호화된 데이터를 복호화하기 위해 라이브러리 \"Fernet\"의 \"decrypt ()\" 함수를 호출할 것입니다.\n\n\n\n\n```js\ndef decrypt_data(encrypted_data, key):\n  from cryptography.fernet import Fernet\n  k = Fernet(key)\n\n  decrypted_data = k.decrypt(encrypted_data.encode()).decode()\n\n  return decrypted_data\n```\n\n## 단계 8: 생성한 UDF 등록하기\n\n데이터프레임에서 생성한 UDF를 사용하려면 해당 UDF를 등록해야합니다.\n\nUDF를 등록하려면 UDF를 사용하는 \"함수(udf())\"를 사용해야합니다. 이 함수는 생성한 UDF의 \"이름\"과 UDF가 수용하는 \"매개변수의 데이터 유형\"을 입력해야합니다.\n\n\n\n```js\nfrom pyspark.sql.types import StringType\n\nencrypt_func = udf(encrypt_data, StringType())\ndecrypt_func = udf(decrypt_data, StringType())\n```\n\n## 단계 9: 민감한 데이터 암호화\n\n이 예제에서는 먼저 Delta 테이블 \"tbl_person\"을 기반으로 DataFrame을 만듭니다.\n이제 생성된 DataFrame에 \"adhar_encrypted\"라는 추가 열이 추가됩니다. 이를 위해 \"등록된 UDF 함수\"인 \"encrypt_func\"이 호출됩니다.\n\"등록된 UDF 함수\"인 \"encrypt_func\"은 생성된 DataFrame의 \"Person_Adhar_No\" 열과 생성된 \"Encryption Key\"를 인수로 받습니다.\n마지막으로 \"암호화된 DataFrame\"인 \"encrypted_df\"를 표시합니다.\n\n```js\nfrom pyspark.sql.functions import *\n\ndf = spark.table(\"tbl_person\")\nencrypted_df = df.withColumn(\"adhar_encrypted\", encrypt_func(\"Person_Adhar_No\", lit(key)))\ndisplay(encrypted_df)\n```\n\n\n\n아래 이미지에서 볼 수 있듯이, 실제 값은 \"Person_Adhar_No\" 열에 존재하고, 암호화된 값은 \"adhar_encrypted\" 열에 있습니다.\n\n## 단계 10: 이미 암호화된 민감한 데이터 복호화하기\n\n\n\n델타 테이블의 일부 사용자는 원본 데이터를 볼 필요가 있습니다. 따라서 이미 암호화된 데이터를 동일한 \"암호화 키\"를 사용하여 복호화해야 합니다.\n\n이 예시에서는 \"암호화된 DataFrame\"인 \"encrypted_df\"에 또 다른 열인 \"adhar_decrypted\"가 추가되어 최종 \"복호화된 DataFrame\"인 \"decrypted_df\"가 생성됩니다. 이를 위해 \"등록된 UDF 함수\"인 \"decrypt_func\"이 호출될 것입니다. \"등록된 UDF 함수\"인 \"decrypt_func\"은 \"암호화된 DataFrame\"인 \"encrypted_df\"의 열 \"adhar_encrypted\"와 생성된 \"암호화 키\"를 매개변수로 받을 것입니다. 마지막으로 \"복호화된 DataFrame\"인 \"decrypted_df\"를 표시하세요.\n\n```js\ndecrypted_df = encrypted_df.withColumn(\"adhar_decreypted\", decrypt_func(\"adhar_encrypted\", lit(key)))\ndisplay(decrypted_df)\n```\n\n결과 -\n\n\n\n위 이미지를 보면 \"Person_Adhar_No\" 열에 실제 값이 존재하고, \"adhar_encrypted\" 열에 암호화된 값이 있음을 확인할 수 있습니다. 그리고 \"adhar_encrypted\" 열의 복호화된 값은 \"adhar_decrypted\" 열에 있으며, 이 값은 실제 값과 동일합니다.","ogImage":{"url":"/assets/img/2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks_0.png"},"coverImage":"/assets/img/2024-05-15-DataSecurityColumnLevelEncryptioninDatabricks_0.png","tag":["Tech"],"readingTime":6}],"page":"98","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"98"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>