<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/25" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/25" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" href="/post/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" href="/post/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" href="/post/2024-06-22-SettingupanExpressTypescriptServerwithVueVite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Express  Typescript 서버에서 Vue  Vite 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" href="/post/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법" href="/post/2024-06-22-Angular16SignalsExplainedWithFiveExamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈" href="/post/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들" href="/post/2024-06-22-oldhabitsdiesceaming"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-oldhabitsdiesceaming_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 DOCUMENT를 사용해야 하는 이유" href="/post/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 DOCUMENT를 사용해야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 DOCUMENT를 사용해야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 DOCUMENT를 사용해야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 Enum 파워 유저 되는 방법" href="/post/2024-06-22-BeaPowerUserofEnumsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 Enum 파워 유저 되는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BeaPowerUserofEnumsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 Enum 파워 유저 되는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 Enum 파워 유저 되는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular" href="/post/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link posts_-active__YVJEi" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법","description":"","date":"2024-06-22 03:26","slug":"2024-06-22-ExpressErrorHandlingLikeaProusingTypescript","content":"\n\n![2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png)\n\n# 소개\n\nExpress는 Node.js를 위한 인기 있는 서버 프레임워크로, 웹 애플리케이션과 API를 만드는 프로세스를 간단히하는 데 사용됩니다.\n\nExpress는 강력하고 유연한 환경을 제공하여 웹 애플리케이션을 구축하는 데 도움이 되지만, 배포 환경으로 사용할 때 신뢰성, 유지 보수성 및 보안을 보장하기 위해 개발자가 주의해야 할 에러 핸들링이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 구조화된 오류 처리 메커니즘은 예기치 못한 충돌을 방지하고 보안 취약점을 노출시키지 않으며, 무언가 잘못되었을 때 의미 있는 오류 메시지를 제공하여 사용자 경험을 향상시킬 수 있습니다. 우리는 Typescript를 사용하여 응용 프로그램에서 오류 처리를 실제로 개선하기 위한 강력한 도구인 이유를 살펴볼 것입니다. 이 기사에서는 프로덕션용 Express 애플리케이션에서 오류를 효과적으로 처리하기 위한 몇 가지 최상의 방법론과 전략을 탐색할 것입니다.\n\n다음 섹션에서 예시 Express 서버를 설정하는 것으로 시작하겠습니다!\n\n# Express 서버 설정\n\n이 기사에서는 Express 서버가 포함된 시작 프로젝트 템플릿을 준비했습니다. 해당 레포지토리에서 프로젝트를 복제할 수 있습니다. 프로젝트를 다운로드한 후, 다음 명령을 실행하여 모든 종속성을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd express-error-handling \u0026\u0026 npm install\n```\n\n이제 프로젝트 구조를 살펴보겠습니다:\n\n![프로젝트 구조](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_1.png)\n\n서버는 index.ts에서 8000 포트에서 시작되어 듣고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/index.ts **/\n\nimport app from \"./app\";\n\nconst initServer = async () =\u003e {\n  app.listen(8000, () =\u003e {\n    console.log(`Listening on port ${8000}`);\n  });\n}\n\ninitServer();\n```\n\nExpress 서버의 모든 설정은 아래와 같이 app.ts 내에서 수행됩니다:\n\n```js\n/** src/app.ts **/\n\n// 전역 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\nexport default app;\n```\n\n이 예제 서버에서는 routes/users.ts에 위치한 하나의 엔드포인트가 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/routes/users.ts **/\n\nimport { Request, Response, Router } from \"express\";\n\nconst router = Router();\n\nconst userData = [\n  {id: 1, name: \"Sam\"},\n  {id: 2, name: \"Bob\"},\n  {id: 3, name: \"Joe\"},\n];\n\nconst fetchUserData = (): Promise\u003ctypeof userData\u003e =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const randomNum = Math.floor(Math.random() * 10 + 1);\n    setTimeout(() =\u003e {\n      if(randomNum === 1) {\n        reject(\"오류: 뭔가 잘못되었습니다!\");\n      } else {\n        resolve(userData);\n      }\n    }, 1000);\n  })\n};\n\nconst getHandler = async (req: Request, res: Response) =\u003e {\n  const { id } = req.query;\n  if(!id) {\n    return res.status(400).send({ message: \"Id가 필요합니다!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    return res.status(500).send({ message: err });\n  }\n};\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    return res.status(400).send({ message: \"이름이 필요합니다!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\nrouter.get(\"/users\", getHandler);\nrouter.post(\"/users\", postHandler);\n\nexport default router;\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngetHandler가 비동기이고 postHandler는 동기입니다. 이는 각 라우트 핸들러에서 발생하는 오류를 어떻게 처리할지에 역할을 하며, 나중에 왜 그러한지 알게 될 것입니다. 우선 그것을 염두에두세요.\n\n제공된 코드의 오류 처리 기술은 일반적인 접근 방식과 구체적인 오류 처리의 부재로 인해 프로덕션 수준 애플리케이션에 적합하지 않습니다. 이것은 작은 프로젝트이기 때문에 즉시 영향을 보지 못할 수 있습니다. 그러나 가령 수백 개의 엔드포인트가 있는 익스프레스 서버가 있고 매일 여러 개발자가 작업하고 있다고 상상해봅시다. 서로 다른 엔드포인트를 통해 동일 유형의 오류에 대한 클라이언트 연결이 동일한 응답을 받도록 일관된 오류 인터페이스를 어떻게 보장할 수 있을까요?\n\n예를 들어, getHandler에서 요청에 id 쿼리 매개변수가 지정되지 않았다면 상태 코드 400과 메시지 속성이 있는 객체로 응답을 보냅니다. 새로운 개발자가 분리된 엔드포인트에서 작업하다가 동일 유형의 오류에 대해 같은 유형의 응답을 보내려고 하지만 오류 속성을 포함한 객체를 사용하기로 결정한다고 상상해 봅시다. 이 경우 연결된 클라이언트는 서버에서 유래할 수 있는 모든 가능한 오류 형식을 알아야 하므로 이는 지속 가능한 패턴이 아닙니다.\n\n다음 섹션에서 익스프레스 서버에서 올바른 오류 처리에 사용되는 기술을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Express 기본 오류 처리기\n\nExpress 기본 오류 처리기는 Express에서 제공하는 내장 오류 처리 미들웨어입니다. 이는 응닑-요청 주기 동안 발생하는 오류를 처리하는 대체 메커니즘으로 작용하지만 응용 프로그램의 라우트 핸들러나 사용자 정의 오류 미들웨어에서 명시적으로 처리되지 않은 경우에 대비합니다.\n\n기본 오류 처리기는 err, req, res 및 next라는 네 개의 인수를 취합니다. err 인수는 오류 객체를 나타내고, req와 res는 각각 요청 및 응답 객체입니다. next 함수는 미들웨어 스택에서 다음 오류 처리 미들웨어(있는 경우)로 오류를 전달하는 데 사용됩니다.\n\n기본 오류 처리기는 개발 중에 처리되지 않은 오류를 빠르게 식별하는 데 유용하지만, 일반적으로 프로덕션 환경에서는 적합하지 않습니다. 프로덕션에서는 보다 견고한 오류 처리를 제공하는 사용자 정의 오류 처리 미들웨어로 기본 오류 처리기를 대체하고, 적절한 로깅, 사용자 친화적인 오류 응답 및 서로 다른 유형의 오류를 구분하는 기능을 제공해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 오류 처리기를 교체하려면 네 가지 인수 (err, req, res 및 next)를 사용하는 사용자 지정 오류 미들웨어를 만들어 해당 미들웨어 내에서 오류 처리 로직을 정의할 수 있습니다. 이렇게 함으로써 오류 응답을 더욱 세밀하게 제어할 수 있으며 응용 프로그램이 제품 환경에서 신뢰성 있게 동작하고 안전하게 운영되도록 할 수 있습니다. 아래에 샘플 사용자 지정 오류 처리기 미들웨어가 표시되어 있습니다.\n\n```js\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) =\u003e {\n  console.error(err);\n  res.status(500).send({ errors: [{ message: \"Something went wrong\" }] });\n};\n```\n\n위의 핸들러는 간단히 err 객체를 가져와서 해당 객체를 로깅한 후에 500 상태로 클라이언트에게 응답을 보냅니다.\n\n미들웨어 폴더를 만들고, 해당 폴더 안에 위의 오류 처리기 코드를 담은 새로운 errors.ts 파일을 만들어 보도록 하겠습니다. 그리고 app.ts 파일 내에서 express 서버와 연결된 내보내기된 에러 핸들러를 연결할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/app.ts **/\n\n// 글로벌 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\nimport errorHandler from \"./middlewares/errors\";\n\n// 익스프레스 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우트\napp.use(userRouter);\n\n// 오류 처리\napp.use(errorHandler);  // \u003c--------- errorHandler를 사용 중\n\nexport default app;\n```\n\n즉, 라우트나 미들웨어에서 오류가 발생하면 errorHandler에서 처리됩니다. 그러나 여기에 한 가지 주의해야 할 점이 있습니다. 동기식 라우트 핸들러와 비동기식 라우트 핸들러에서 오류를 처리하는 방법이 다르며 다음 두 섹션에서 그 차이를 알아볼 것입니다.\n\n# 동기식 오류\n\n우선 동기식 라우트 핸들러에서 오류를 처리하는 방법을 살펴봅시다. 이것은 더 쉬운 방식으로 다룰 수 있습니다. users.ts의 postHandler를 아래와 같이 변경해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/routes/users.ts **/\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    throw new Error(\"Name is required!\");\n    // return res.status(400).send({ message: \"Name is required!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n```\n\n사용자 엔드포인트에 이름이 요청 본문에 포함되지 않은 요청을 보내보세요. 서버는 응답 본문에서 오류 배열과 함께 500 상태 코드로 응답합니다.\n\n동기적 루트 핸들러에서 오류가 발생하면 사용자 정의 오류 처리기 미들웨어가 즉시 잡아내고 클라이언트에 응답을 보내기 전에 사용자 정의 논리를 적용합니다. 이제 다음 섹션에서 비동기 루트 핸들러에서 발생하는 오류를 처리하는 방법을 살펴봅시다.\n\n# 비동기 오류\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 users.ts의 getHandler를 아래와 같이 변경해 봅시다:\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response) =\u003e {\n  const { id } = req.query;\n  if (!id) {\n    throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n이제 id 쿼리 매개변수 없이 사용자 엔드포인트로 GET 요청을 시도해보세요. 놀랍게도 전체 익스프레스 서버가 충돌할 것이고, 이것은 비동기 오류가 기본적으로 익스프레스 오류 처리기에서 잡히지 않기 때문입니다. 비동기 오류를 오류 처리기 미들웨어로 전달하려면 아래와 같이 익스프레스 next 함수를 사용해야 합니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { id } = req.query;\n  if (!id) {\n    return next(new Error(\"Id is required!\"));\n    // throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    next(err);\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 함수는 일반적으로 인수를 받지 않고 요청을 다음 미들웨어로 이동시키기 위해 호출됩니다. next 함수에 입력을 제공하면 Express 서버에게 모든 것을 건너뛰고 바로 에러 핸들러로 이동해야 한다는 신호를 보냅니다.\n\nfetchUserData가 프라미스를 반환하므로 오류 처리를 위해 try-catch 블록을 구현하고 catch 표현식에서 next 함수를 사용하여 오류를 전파해야 합니다. express-async-errors npm 패키지를 사용하면 next 함수를 사용하지 않고 비동기 라우트 핸들러에서 간단히 오류를 던질 수 있도록 express 라이브러리를 수정하는 방법을 제공합니다.\n\n다음 명령을 실행하여 패키지를 설치할 수 있습니다:\n\n```js\nnpm install express-async-errors\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.ts 파일 안에서 express 라이브러리에 대한 패치가 적용되도록 패키지를 import하세요.\n\n```js\n/** src/app.ts **/\n\n// Global dependencies\nimport express from \"express\";\nimport { json } from \"body-parser\";\nimport \"express-async-errors\";  // \u003c---------- apply async error patch\n\n// Project dependencies\nimport userRouter from \"./routes/users\";\nimport { errorHandler } from \"./middlewares/errors\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\n// 에러 처리\napp.use(errorHandler);\n\nexport default app;\n```\n\n그런 다음 users.ts 파일 안의 getHandler를 수정하여 서버가 크래시하는 걱정없이 간단히 에러를 throw할 수 있습니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { id } = req.query;\n  if(!id) {\n    throw new Error(\"Id is required!\");\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress에서 오류를 중앙 집중식으로 처리하는 데 도움을 주는 도구가 있으니, 해결해야 할 문제가 아직 몇 가지 더 있습니다:  \n- 모든 오류가 500 응답으로 처리되는 대신 다른 상태 코드로 응답을 보내는 방법은 무엇인가요?  \n- 클라이언트에게 오류 응답을 일관된 형식으로 보장하는 방법은 무엇인가요?  \n\n이것이 TypeScript가 우리를 도와줄 부분이며, 다음 섹션에서 왜 도와주는지 볼 것입니다.  \n\n# 사용자 정의 오류 클래스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고객에게 반환하는 오류에 일관된 인터페이스를 보장하기 위해 TypeScript에서 사용자 정의 오류 클래스를 만들 수 있습니다. 이를 통해 더 구조화되고 의미 있는 오류 응답을 제공할 수 있습니다. 사용자 정의 오류 클래스를 사용하면 특정 오류 정보를 캡슐화하고 응용 프로그램 전반에서 일관된 오류 객체를 만들 수 있습니다.\n\n우리는 아래와 같이 CustomError 추상 클래스를 생성하면서 시작합니다.\n\n```js\n/** src/errors/CustomError.ts **/\n\nexport type CustomErrorContent = {\n  message: string,\n  context?: { [key: string]: any }\n};\n\nexport abstract class CustomError extends Error {\n  abstract readonly statusCode: number;\n  abstract readonly errors: CustomErrorContent[];\n  abstract readonly logging: boolean;\n\n  constructor(message: string) {\n    super(message);\n\n    // 내장 클래스를 확장하고 있기 때문에 사용합니다.\n    Object.setPrototypeOf(this, CustomError.prototype);\n  }\n}\n```\n\nCustomErrorContent 유형은 오류 메시지의 구조를 정의합니다. 이는 필수 메시지 필드와 선택적 context 필드(추가적인 오류 관련 데이터를 보유하는 키-값 객체)를 포함합니다. 반면에 CustomError 추상 클래스는 특정 사용자 정의 오류 클래스를 만드는 데 기본 역할을 합니다. 이 클래스는 statusCode(오류 응답에 보낼 HTTP 상태 코드를 나타냄), errors(구체적인 오류 세부 정보를 가진 CustomErrorContent 객체 배열), logging(오류를 로깅해야 하는지 여부를 나타내는 부울값) 세 가지 추상 속성을 구현하도록 강제합니다. 이 추상 클래스 자체는 기본 내장 Error 클래스를 확장하므로 stack 및 cause와 같은 속성에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCustomError 클래스를 확장하고 추상 속성을 구현함으로써 다양한 오류 시나리오를 처리하는 일관성 있고 구조화된 확장 가능한 오류 클래스를 만들 수 있습니다. 예를 들어, 아래와 같이 일반적인 BadRequestError 클래스를 생성할 수 있습니다.\n\n```js\n/** src/errors/BadRequestError **/\n\nimport { CustomError } from \"./CustomError\";\n\nexport default class BadRequestError extends CustomError {\n  private static readonly _statusCode = 400;\n  private readonly _code: number;\n  private readonly _logging: boolean;\n  private readonly _context: { [key: string]: any };\n\n  constructor(params?: {code?: number, message?: string, logging?: boolean, context?: { [key: string]: any }) {\n    const { code, message, logging } = params || {};\n    \n    super(message || \"Bad request\");\n    this._code = code || BadRequestError._statusCode;\n    this._logging = logging || false;\n    this._context = params?.context || {};\n\n    // 내장 클래스를 확장하는 경우만 필요\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n\n  get errors() {\n    return [{ message: this.message, context: this._context }];\n  }\n\n  get statusCode() {\n    return this._code;\n  }\n\n  get logging() {\n    return this._logging;\n  }\n}\n```\n\n이 클래스는 CustomError 클래스를 확장하고 Express 서버 애플리케이션에서 잘못된 요청 시나리오를 처리하기 위해 설계되었습니다. 이 클래스에는 HTTP 상태 코드를 나타내는 _code, 로깅 플래그를 나타내는 _logging, 그리고 오류에 대한 추가적인 컨텍스트 데이터를 나타내는 _context라는 프라이빗 속성이 포함되어 있습니다. 클래스 생성자는 옵션 params 객체를 인수로 받아 코드, 메시지, 로깅, 컨텍스트를 지정하여 오류를 사용자 정의할 수 있도록합니다. params가 제공되지 않으면 생성자는 오류 메시지(\"Bad request\")와 상태 코드(400)에 대한 기본값을 설정합니다. 이 사용자 정의 오류 클래스를 위한 구체적인 오류 세부 정보를 반환하도록 구현된 errors, statusCode 및 logging Getter 메서드가 있습니다. 이것들이 CustomError 클래스에 의해 강제됨에 유의하세요.\n\n우리는 사용자 엔드포인트의 postHandler에서 BadRequestError 클래스를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n/** src/routes/users.ts **/\n\n// ***\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    throw new BadRequestError({code: 400, message: \"Name is required!\", logging: true});\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\n// ***\r\n```\n\n마지막으로, 사용자 지정 오류 처리 미들웨어 내에서 표를 Markdown 형식으로 변경할 수 있습니다. 아래의 예시와 같이 CustomError의 인스턴스를 특별히 찾도록 로직을 조정할 수 있습니다.\n\n```js\r\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\nimport { CustomError } from \"../errors/CustomError\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) =\u003e {\n  // 처리된 오류\n  if(err instanceof CustomError) {\n    const { statusCode, errors, logging } = err;\n    if(logging) {\n      console.error(JSON.stringify({\n        code: err.statusCode,\n        errors: err.errors,\n        stack: err.stack,\n      }, null, 2));\n    }\n\n    return res.status(statusCode).send({ errors });\n  }\n\n  // 처리되지 않은 오류\n  console.error(JSON.stringify(err, null, 2));\n  return res.status(500).send({ errors: [{ message: \"문제가 발생했습니다\" }] });\n};\r\n```\n\n미들웨어는 먼저 오류가 CustomError 클래스의 인스턴스인 처리된 사용자 정의 오류인지 확인합니다. 처리된 오류일 경우, 미들웨어는 사용자 지정 오류 객체에서 HTTP 상태 코드, 오류 세부 정보 및 로깅 플래그를 추출합니다. 이 오류에 대해 로깅이 활성화되어 있는 경우, 디버깅 목적으로 콘솔에 오류와 그 스택 트레이스를 로깅합니다. 그런 다음 추출된 오류 세부 정보로 클라이언트에 적절한 응답을 보냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미처리된 오류(사용자 정의 오류가 아닌 오류)의 경우 미들웨어가 오류를 콘솔에 기록하며, 오류 객체의 형식이 지정된 JSON 표현과 함께 스택 추적을 표시합니다. 로깅 후 미들웨어는 클라이언트에게 \"문제가 발생했습니다.\" 라는 기본 오류 메시지와 함께 일반적인 500 Internal Server Error 응답을 보냅니다.\n\n위 구현을 통해 이제 우리는 효과적이고 중앙집중화된 오류 관리를 보장하는 미들웨어를 보유하게 되었으며, 사용자 정의 오류에 대한 특정 응답을 제공하고 디버깅 목적으로 미처리된 오류를 로깅합니다.\n\n# 결론\n\n효과적인 오류 처리는 제품용으로 제작된 안정적이고 견고한 Express 서버 응용 프로그램을 구축하는 중요한 측면입니다. 이 기사에서는 Express 서버에서 TypeScript를 사용하여 프로처럼 오류를 처리하기 위한 다양한 전략과 모범 사례를 탐색했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 예시 Express 서버를 설정하고 Express에서 제공하는 기본 오류 처리 기술의 한계를 확인하며 시작했습니다. 이러한 한계를 극복하기 위해 우리는 사용자 정의 오류 처리 미들웨어를 구현하여 오류 응답을 더 세밀하게 제어하고 응용 프로그램 전반에 걸쳐 일관성을 유지할 수 있도록 했습니다.\n\n우리의 오류 처리 방법 중 하나는 TypeScript를 사용하여 사용자 정의 오류 클래스를 만드는 것이었습니다. 우리는 CustomError라는 추상 기본 클래스를 정의했는데, 이 클래스는 하위 클래스에 statusCode, errors 및 logging과 같은 특정 속성을 강제했습니다. 이 기본 클래스를 확장하고 사용자 정의 오류 클래스에서 이러한 속성을 구현함으로써 일정한 형식을 갖는 체계적이고 의미 있는 오류 응답을 얻었습니다.\n\n우리는 라우트 핸들러에서 동기적 및 비동기적 오류를 효과적으로 처리하는 방법을 배우며, next 함수를 사용하거나 express-async-errors 패키지를 활용하여 비동기적 오류 처리를 간단화했습니다.\n\n이러한 기술을 결합하여 우리는 중앙 집중화된 표준화된 오류 처리 메커니즘을 수립하여 클라이언트가 어떤 종류의 오류나 어떤 엔드포인트를 액세스하더라도 일관된 오류 응답을 받도록 했습니다. 또한, 적절한 경우 콘솔에 오류를 로깅함으로써 디버깅 능력을 향상시키고, 동시에 안전하고 사용자 친화적인 오류 인터페이스를 유지했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하면, TypeScript의 강력한 기능과 잘 구성된 오류 처리 전략을 활용하여 더 견고하고 유지보수가 쉬운 Express 서버 애플리케이션을 구축할 수 있으며, 프로덕션 환경에서 예기치 못한 다운타임을 최소화할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png"},"coverImage":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png","tag":["Tech"],"readingTime":16},{"title":"Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법","description":"","date":"2024-06-22 03:25","slug":"2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png\" /\u003e\n\n안녕하세요! 이번 튜토리얼에서는 NextJS 앱에 인증을 추가하는 방법을 Next Auth를 사용하여 보여드릴 거에요. 저는 NextJS 애플리케이션을 실행하기 위해 런타임으로 bun을 사용할 거에요.\n\nStep I : Next 14 프로젝트 설정하기\n\n```js\nbunx create-next-app@latest next-auth-prisma\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 명령어를 입력하시거나 프로젝트 설정을 위해 NextJS의 공식 문서를 참고하시면 됩니다.\n\n단계 II: NextAuth API route 설정\n\nNext 앱을 설치한 후에는 다음 명령어를 통해 앱 안에 next-auth 패키지를 설치해야 합니다.\n\n```js\nbun add next-auth\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 다음 인증에 사용할 인증 옵션을 구성해야 합니다. 기본 폴더로 이동하여 lib라는 새 폴더를 만들고 lib 폴더 안에 auth.ts라는 새 파일을 만들고 다음 코드를 복사하세요.\n\n/lib/auth.ts\n\n```js\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"Email and Password\",\n      credentials: {\n        email: {\n          label: \"Email\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        const user = { id: \"1\", name: \"Admin\", email: \"admin@admin.com\" };\n        return user;\n      },\n    }),\n  ],\n};\n```\n\n위 코드는 다음 인증 구성 설정 프로세스를 보여줍니다. 저는 next-auth에서 CredentialsProvider를 사용했지만 Google, Github, Facebook 등의 다른 프로바이더를 사용할 수 있습니다. 이러한 프로바이더를 구현하려면 해당 프로바이더의 구성에 대해 공식 문서를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 자격 증명 객체에는 로그인 양식에 표시되는 이메일과 비밀번호가 필드로 포함되어 있습니다. 인증 단계에는 목업 사용자 객체를 반환하는 더미 자격 증명이 있습니다.\n\n다음 단계는 NextAuth에서 인증 요청을 처리하는 API 경로를 생성하는 것입니다. 시작하려면 앱 디렉토리 내에 api라는 새 폴더를 만들고 그 안에 auth라는 새 폴더를 만들어주시고 auth 내부에 catch-all-routes 폴더 [...nextauth]을 만든 다음 auth 폴더 내에 route.ts라는 이름의 파일을 만들어주시고 다음 코드를 붙여넣어주세요.\n\n/app/api/auth/[…nextauth]/route.ts\n\n```js\nimport { authOptions } from \"@/lib/auth\";\nimport NextAuth from \"next-auth\";\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프렌들리하게 번역하면 다음과 같습니다:\n\n우리는 이전에 NextAuth 함수 안에서 미리 구성한 authOptions를 가져왔고, next auth 핸들러를 내보냈습니다.\n\n3단계: 버튼 만들기\n\n애플리케이션의 페이지 간 이동을 쉽게 하기 위해 브라우저에 수동으로 URL을 입력하는 대신 버튼을 만들겠습니다. 기본 폴더 내에 components라는 새 폴더를 만들고 buttons.component.tsx라는 파일을 생성하세요.\n\n/components/buttons.component.tsx\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\nimport Link from \"next/link\";\n\nexport const LoginButton = () =\u003e {\n  return (\n    \u003cbutton style={ marginRight: 10 } onClick={() =\u003e signIn()}\u003e\n      Sign in\n    \u003c/button\u003e\n  );\n};\n\nexport const RegisterButton = () =\u003e {\n  return (\n    \u003cLink href=\"/register\" style={ marginRight: 10 }\u003e\n      Register\n    \u003c/Link\u003e\n  );\n};\n\nexport const LogoutButton = () =\u003e {\n  return (\n    \u003cbutton style={ marginRight: 10 } onClick={() =\u003e signOut()}\u003e\n      Sign Out\n    \u003c/button\u003e\n  );\n};\n\nexport const ProfileButton = () =\u003e {\n  return \u003cLink href=\"/profile\"\u003eProfile\u003c/Link\u003e;\n};\n```\n\n이제 홈 컴포넌트에서 버튼들을 import하세요.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\n\nexport default function Home() {\n  return (\n    \u003cmain\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    \u003e\n      \u003cdiv\u003e\n        \u003cLoginButton /\u003e\n        \u003cRegisterButton /\u003e\n        \u003cLogoutButton /\u003e\n        \u003cProfileButton /\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n이제 NextAuth에서 JWT 인증을 추가해야 하므로 프로젝트의 루트 디렉토리 내 .env 파일에 JWT의 시크릿을 정의해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n#.env\n\nNEXTAUTH_SECRET=secret\nNEXTAUTH_URL=http://localhost:3000\n\n이제 http://localhost:3000/를 방문하여 애플리케이션에 액세스하고 홈페이지에서 클릭하여 로그인 버튼을 누르면 로그인 양식으로 이동합니다.\n\n![이미지](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_1.png)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWe have mock credentials, so feel free to use any email and password to submit the form. Once the submission is successful, you will be redirected back to the home page. At that point, you can view the application's cookies.\n\n![Cookie Image](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_2.png)\n\nStep IV: Integrating with database\n\nFor real-world users, we need to connect to a database. I will be using PostgreSQL as the database and Prisma as the ORM.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 데이터베이스를 생성하고 데이터베이스 URL을 .env 파일에 넣으세요\n\n```js\nDATABASE_URL=postgresql://postgres:pawan123@localhost:5432/next-auth?schema=public\n```\n\n이제 다음 명령어를 사용하여 prisma ORM과 bcryptjs를 설치하여 사용자 비밀번호를 해싱하세요.\n\n```js\nnpm add @prisma/client bcryptjs \u0026\u0026 npm add -D ts-node prisma @types/bcryptjs\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프리즈마를 설정하고 포스트그리스 데이터베이스에 연결하려면 다음 명령을 실행하여 프로젝트에서 프리즈마를 초기화하고 포스트그레스SQL용 데이터 소스를 만드세요.\n\n```js\nnpx prisma init --datasource-provider postgresql\n```\n\n이제 schema.prisma 파일 내에 User 모델을 만들어보세요.\n\n```js\n// 이것은 당신의 프리즈마 스키마 파일입니다.\n// 자세한 내용은 다음 문서에서 확인하세요: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id       String @id @default(uuid())\n  name     String\n  email    String @unique\n  password String\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 새 사용자를 생성하고 데이터베이스에 저장하는 등록 기능을 만들 수 있지만, 나는 직접 데이터베이스에 사용자를 입력할 것이다. 시작하려면 prisma 디렉토리에 seed.ts 파일을 만들고 아래 코드를 복사해 넣어라.\n\nprisma/seed.ts\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\nimport { hash } from \"bcryptjs\";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const password = await hash(\"password123\", 12);\n  const user = await prisma.user.upsert({\n    where: { email: \"admin@admin.com\" },\n    update: {},\n    create: {\n      email: \"admin@admin.com\",\n      name: \"Admin\",\n      password,\n    },\n  });\n  console.log({ user });\n}\nmain()\n  .then(() =\u003e prisma.$disconnect())\n  .catch(async (e) =\u003e {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n쉽게 테스트 사용자로 데이터베이스에 시드(seed)를 생성할 수 있도록 하기 위해 package.json 파일에 스크립트를 추가할 것이다. 파일을 열어 다음 스크립트를 추가하라:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n    \"prisma\": {\n        \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n    }\n}\n```\n\n이제 다음 명령을 사용하여 마이그레이션을 생성하고 사용자 스키마를 데이터베이스에 푸시하세요.\n\n```js\nnpx prisma migrate dev --name init\n```\n\n마이그레이션을 생성한 후 다음 명령을 사용하여 데이터베이스에 사용자를 시드하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx prisma db seed\n```\n\n이제 PostgreSQL 데이터베이스와 통신할 수 있도록 @prisma/client 패키지를 사용하여 전역 PrismaClient 인스턴스를 생성할 것입니다. 이를 위해 lib 폴더 안에 prisma.ts라는 파일을 만들고 다음 코드를 추가해주세요.\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: [\"query\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n```\n\nPrisma와 데이터베이스 설정을 완료했으니, 이제 auth.ts 파일에서 로그인 양식을 인증할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { prisma } from \"@/lib/prisma\";\nimport { compare } from \"bcryptjs\";\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"로그인\",\n      credentials: {\n        email: {\n          label: \"이메일\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"비밀번호\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !(await compare(credentials.password, user.password))) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          randomKey: \"일부 랜덤 키\",\n        };\n      },\n    }),\n  ],\n};\n```\n\n이제 사용자 정의 키를 추가할 수 있습니다. 다음은 NextAuth 구성의 콜백 속성에서 콜백을 수정하는 방법입니다. 이렇게 하면 세션 개체와 JWT에 필요한 정보를 포함시킬 수 있으며 응용 프로그램에 언제든지 어디서나 액세스할 수 있습니다.\n\n```js\ncallbacks: {\n    session: ({ session, token }) =\u003e {\n      console.log(\"세션 콜백\", { session, token });\n      return {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id,\n          randomKey: token.randomKey,\n        },\n      };\n    },\n    jwt: ({ token, user }) =\u003e {\n      console.log(\"JWT 콜백\", { token, user });\n      if (user) {\n        const u = user as unknown as any;\n        return {\n          ...token,\n          id: u.id,\n          randomKey: u.randomKey,\n        };\n      }\n      return token;\n    },\n  },\n```\n\nStep V: NextAuth 세션 데이터 가져오기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnext 앱 내에서 권한이 부여된 사용자 세션 데이터를 얻는 두 가지 방법이 있습니다.\n\ni. 서버 컴포넌트에서\n\n서버 컴포넌트 내에서 세션 데이터를 가져오기 위해 getServerSession 함수를 사용할 수 있습니다.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\nexport default async function Home() {\n  const session = await getServerSession(authOptions);\n  console.log(session);\n\n  return (\n    \u003cmain\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    \u003e\n      \u003cdiv\u003e\n        \u003cLoginButton /\u003e\n        \u003cRegisterButton /\u003e\n        \u003cLogoutButton /\u003e\n        \u003cProfileButton /\u003e\n\n        \u003ch1\u003eServer Session\u003c/h1\u003e\n        \u003cpre\u003e{JSON.stringify(session)}\u003c/pre\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 페이지를 무단 사용자로부터 보호하기 위해 미인가 사용자를 signin 페이지로 리다이렉트하는 다음 코드를 사용할 수 있습니다.\n\n```js\nif (!session) {\n    redirect(\"/api/auth/signin\");\n}\n```\n\nii. 클라이언트 컴포넌트\n\n클라이언트 컴포넌트에서 세션 데이터를 검색하려면 next auth에서 제공하는 세션 제공자를 사용하고 앱을 세션 제공자로 래핑해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 디렉토리에 providers 폴더를 만들고, NextAuthProvider.tsx라는 새 파일을 생성한 다음 아래 코드를 붙여넣어주세요.\n\n```js\n\"use client\";\n\nimport { SessionProvider } from \"next-auth/react\";\n\ntype Props = {\n  children?: React.ReactNode;\n};\n\nexport const NextAuthProvider = ({ children }: Props) =\u003e {\n  return \u003cSessionProvider\u003e{children}\u003c/SessionProvider\u003e;\n};\n```\n\n이제 layout.tsx 파일에서 프로바이더를 감싸주세요.\n\n```js\nimport { NextAuthProvider } from \"./providers/NextAuthProvider\";\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        \u003cNextAuthProvider\u003e{children}\u003c/NextAuthProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 세션 데이터를 가져오는 클라이언트 컴포넌트를 생성해보세요.\n\n```js\n\"use client\";\n\nimport { useSession } from \"next-auth/react\";\n\nexport const User = () =\u003e {\n  const { data: session } = useSession();\n\n  return (\n    \u003c\u003e\n      \u003ch1\u003eClient Session\u003c/h1\u003e\n      \u003cpre\u003e{JSON.stringify(session)}\u003c/pre\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n이제 권한이 없는 사용자로부터 클라이언트 컴포넌트를 보호하기 위해 아래 코드를 클라이언트 컴포넌트에 붙여넣어주세요.\n\n```js\nconst { status } = useSession({\n    required: true,\n    onUnauthenticated() {\n      redirect(\"/api/auth/signin\");\n    },\n  });\n\n  if (status === \"loading\") {\n    return \u003cp\u003eLoading....\u003c/p\u003e;\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n이 튜토리얼에서는 NextAuth를 새로운 Next.js 14 앱에 통합하는 방법에 대해 배웠습니다. 이 글이 유익하고 즐거웠기를 바랍니다. 피드백이나 질문이 있으면 언제든 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png","tag":["Tech"],"readingTime":12},{"title":"Express  Typescript 서버에서 Vue  Vite 설정하는 방법","description":"","date":"2024-06-22 03:22","slug":"2024-06-22-SettingupanExpressTypescriptServerwithVueVite","content":"\n\n\n\n![Setting up an Express TypeScript Server with Vue Vite](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png)\n\n백엔드 개발에 뛰어들기는, 특히 프론트엔드 개발자로써는 미지의 영역에 발을 딛는 것처럼 느껴질 수 있어요. \"프론트엔드 걸리\"를 자처하는 나로서는 솔직히 말하면, 백엔드 개발에 뛰어들기 전에 조심스럽게 느껴졌어요. 그러나 프로젝트의 일부 클라이언트 측 로직을 백엔드로 옮긴 후에야, 서버 측 작업이 상상했던 것만큼 무섭지 않다는 것을 깨달았어요.\n\n백엔드 개발에 대해 제가 느낀 불안을 공감한다면, 여기에 잘 왔어요. 이 블로그에서는 Express 서버를 TypeScript와 통합하는 방법을 안내할 거예요.\n\n초보자를 위한 이 포괄적인 가이드는 다음을 중점적으로 다룰 거예요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript로 Express 서버 설정하기\n- 클라이언트와 서버 간 통신 설정하기\n- Vite를 사용하여 요청 프록시 설정하기\n\n이제 프론트엔드와 백엔드 간의 간극을 좁히러 뛰어들어봅시다! 🚀\n\n# 시작하기\n\n이 튜토리얼의 전체 소스 코드에 액세스하려면 여기에 있는 GitHub 리포지토리를 방문해주세요. 서버 및 클라이언트 환경 변수를 추가하는 것을 잊지 마세요. 클론하거나 포크하거나 리포지토리를 별표로 표시하여 차후 참고 및 실험에 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. 터미널에서 명령어 node -v를 실행하여 Node.js가 설치되어 있는지 확인할 수 있습니다. 설치되어 있다면 설치된 버전이 표시됩니다. 그렇지 않다면 여기를 클릭하여 Node.js를 설치할 수 있습니다.\n\n## 서버 설정하기\n\n백엔드를 설정하는 첫 번째 단계는 적절한 기술 스택을 선택하는 것입니다. Express.js를 사용할 것이며, 이는 간결함과 유연성으로 유명한 Node.js 프레임워크입니다. 추가로 TypeScript를 활용하여 서버 측 코드베이스에 정적 타이핑을 도입할 것입니다.\n\n## 프로젝트 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 새 디렉토리를 만들고 npm을 사용하여 새 Node.js 프로젝트를 초기화할 것입니다. 초기화된 후 Express 및 TypeScript를 포함한 필수 종속성을 설치하기 위해 각각의 명령을 실행할 것입니다.\n\n- 새 디렉토리 만들기\n\n우리는 스타터 프로젝트를 위한 새 디렉토리를 만들어 시작할 것입니다. 이를 위해 당신의 운영 체제의 터미널 또는 파일 탐색기를 사용할 수 있습니다.\n\n```js\nmkdir express-starter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 프로젝트 디렉토리로 이동해주세요.\n\n디렉토리가 생성되면 cd 명령어를 사용하여 해당 디렉토리로 이동해주세요.\n\n```js\ncd express-starter\n```\n\n3. 서버 및 클라이언트 폴더를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nexpress-starter 디렉토리에 들어간 후, 두 개의 폴더를 만들어주세요: client와 server 폴더를 만들어주세요. 그런 다음 server 폴더로 이동해주세요.\n\n```js\nmkdir server client cd server\n```\n\n4. 새로운 Node.js 프로젝트 초기화하기.\n\nnpm init을 사용하여 새로운 Node.js 프로젝트를 초기화하세요. 이렇게 하면 package.json 파일이 생성되며, 프로젝트와 의존성에 대한 메타데이터가 저장됩니다. 프롬프트를 따르거나 -y 플래그를 사용하여 모든 프롬프트에 대한 기본값을 수락할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm init -y\n```\n\n5. 의존성 설치하기.\n\n이제, 프로젝트에 필요한 의존성을 설치해보겠습니다.\n\n```js\n# dependencies \nnpm install express cors dotenv  \n\n# development dependencies \nnpm install -D typescript @types/cors @types/node @types/express nodemon\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 종속성이 무엇을 하는지 간단히 살펴봅시다.\n\n- express: 우리가 서버를 구축하기 위해 사용할 Node.js의 웹 프레임워크입니다.\n- typescript: TypeScript 컴파일러 및 언어입니다. 프로젝트를 타입 안전하게 유지하고 런타임 이전에 버그를 잡을 수 있게 합니다.\n- cors: Cross-Origin Resource Sharing은 교차 출처 요청을 허용하여 백엔드 API가 다른 포트에서 실행되더라도 클라이언트에서 안전하게 액세스할 수 있도록 합니다.\n- dotenv: .env 파일에서 환경 변수를로드합니다.\n- nodemon: Nodemon은 변경 사항을 감지하면 자동으로 노드 응용 프로그램을 다시 시작합니다. 이는 변경 사항이 적용되기 위해 응용 프로그램을 중지하고 다시 시작할 필요가 없다는 것을 의미합니다.\n- @types/node, @types/cors 및 @types/express: Node.js, Cors 및 Express에 대한 유형 정의로 TypeScript 지원을 활성화합니다.\n\n의존성 대 개발 의존성\n\n-D 플래그를 사용하여 설치 중에 일부 dev 종속성을 추가했지만, 왜 필요했을까요? 개발 의존성은 개발 중에만 필요한 모듈로, 종속성은 런타임에서 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성\n\n의존성은 우리 애플리케이션이 올바르게 작동하기 위해 필요한 필수 패키지입니다. npm install을 실행하면 이러한 패키지가 설치됩니다. 이러한 패키지는 package.json 파일의 의존성 섹션에 나열됩니다. 이러한 패키지 없이 배포된 앱은 작동하지 않을 수 있습니다.\n\n개발 의존성\n\n반면에 개발 의존성은 개발 및 테스트 목적에만 필요합니다. 이러한 패키지는 앱이 정상적으로 실행되기 위해 반드시 필요한 것은 아니지만, 빌드, 테스트 및 코드 린팅과 같은 작업에 중요합니다. 이러한 패키지들은 package.json의 devDependencies 섹션에 명시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. tsconfig.json 생성하기\n\nTypeScript를 구성하기 위해 tsconfig.json 파일을 생성하세요. 이 파일은 TypeScript가 코드를 컴파일하는 방법을 지정합니다. npx tsconfig.json을 실행한 후 Node를 선택하세요. 이 명령은 일부 기본 설정이 포함된 tsconfig.json 파일을 생성합니다.\n\n```sh\nnpx tsconfig.json\n```\n\n7. 소스 파일 생성 및 package.json 업데이트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, src 디렉토리를 생성하세요. src 디렉토리 안에 우리의 주 파일인 main.ts를 만들 것입니다.\n\n```js\n# src 폴더 생성\nmkdir src\n\n# 폴더로 이동\ncd src\n\n# .ts 파일 생성\ntouch main.ts\n\n# src에서 나와서 서버 디렉토리로 돌아갑니다\ncd ..\n```\n\npackage.json에서 엔트리 포인트를 index.js 대신 main.js로 수정하세요.\n\n```js\n\"main\": \"main.js\",\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n8. .env 파일을 생성하세요.\n\n환경 변수를 구성하기 위해 .env 파일을 만듭니다 (예: API 키). 이 파일은 민감한 정보가 노출되지 않도록 버전 관리에서 제외되어야 합니다. 서버 폴더의 루트에 .env 파일을 생성하세요.\n\n```js\ntouch .env\n```\n\n9. .gitignore 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.gitignore 파일을 만들어서 버전 관리에서 무시해야 할 파일과 디렉토리를 지정하여 불필요한 파일을 커밋하는 것을 피해야 합니다. 서버 폴더의 루트에 .gitignore 파일을 생성하세요. 우선 node_modules와 .env*를 추가하겠습니다. *는 Git에게 .env로 시작하는 모든 파일이나 폴더를 무시하도록 지시합니다.\n\n```js\n.env* \nnode_modules/\n```\n\n이 시점에서 프로젝트 구조는 다음과 같을 수 있습니다:\n\n```js\nexpress-starter/\n├── client/\n└── server/\n    ├── node_modules/\n  └── src/\n        └── main.ts\n  ├── .env\n  ├── .gitignore\n    ├── package.json\n    ├── tsconfig.json\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 설정을 마쳤으니 이제 서버를 생성해봅시다.\n\n# 서버 생성\n\nsrc/main.ts 파일 안에 다음 스니펫을 추가하세요.\n\n```js\n// server/src/main.ts\n\nimport cors from 'cors';\nimport 'dotenv/config';\nimport express from 'express';\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst PORT = process.env.PORT || 3001;\n\napp.get('/api', (_req, res) =\u003e {\n  res.status(200).json({ message: '서버에서 안녕하세요!' });\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 기본 express 서버입니다. 이 앱은 서버를 시작하고 지정된 포트에서 연결을 수신 대기합니다. /api 경로에 대한 요청에 대해 \"서버에서 안녕하세요!\"라고 응답합니다. 코드가 무엇을 하는지 이해해 봅시다.\n\n- 미들웨어 설정\n\napp.use()는 미들웨어를 등록하는 방법입니다. 미들웨어는 서버가 특정 요청을 처리하기 전에 실행하는 특별한 함수들입니다. 미들웨어는 서버가 요청을 수신하고 클라이언트에게 응답을 보내는 순간 사이에서 작동합니다.\n\n우리의 경우, 몇 가지 전역 미들웨어를 등록했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- cors: 이 미들웨어는 서버가 서로 다른 소스/출처에서 오는 요청을 수락할 수 있도록 합니다.\n- express.json(): 들어오는 요청을 JSON 형식으로 파싱합니다.\n- express.urlencoded('extended: true'): 요청에서 폼 데이터를 파싱합니다.\n\n2. 라우트 설정\n\napp.get(`/api`)은 특히 /api URL로의 GET 요청에 대한 라우트 핸들러를 설정합니다. 이 라우트로 GET 요청이 올 경우, 서버는 상태 코드 200과 \"서버에서 인사합니다!\" 메시지로 응답합니다.\n\n3. 서버 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.listen()은 지정된 포트(PORT)에서 Express 앱을 수신하여 시작합니다. 환경 변수에 포트가 지정되지 않은 경우 기본값은 포트 3001입니다.\n\n이 설정으로 서버를 실행하는 한 걸음 더 나아갈 수 있습니다.\n\n# TypeScript로 Nodemon 구성하기\n\nmain.ts를 실행하려면 서버 디렉토리 내에서 node src/main.ts를 실행할 수 있지만, \".ts\" 라는 알 수 없는 파일 확장자 오류가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode와 TypeScript\n\n`node src/main.ts`를 실행할 때 Node.js가 TypeScript 파일을 직접 실행할 것으로 기대할 수 있습니다. 그러나 Node.js는 TypeScript를 네이티브로 이해하지 않습니다. JavaScript만을 이해합니다.\n\nTypeScript는 JavaScript의 확장이므로 TypeScript 코드는 Node.js에서 실행되기 전에 JavaScript로 컴파일되어야 합니다. 이 컴파일 과정은 .ts 파일을 Node가 이해할 수 있는 동등한 .js 파일로 변환합니다.\n\n서버 코드를 실행하려면 먼저 TypeScript 컴파일러(tsc)를 사용하여 TypeScript 코드를 JavaScript로 변환해야 합니다. 이를 통해 컴파일된 JavaScript 코드가 포함된 dist/main.js 파일이 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 모든 TypeScript 파일을 JavaScript로 컴파일\nnpx tsc\n\n# 생성된 JavaScript 파일 실행\nnode dist/main.js\n```\n\n위의 명령어에서 npx tsc는 TypeScript 컴파일러(tsc)를 호출하여 프로젝트의 모든 TypeScript 파일을 JavaScript로 컴파일합니다. 그 결과로 생성된 JavaScript 파일은 dist 디렉토리에 출력됩니다. 생성된 JavaScript 파일은 Node.js를 사용하여 실행할 수 있습니다.\n\n컴파일된 JavaScript 파일의 출력 디렉토리는 tsconfig.json 파일의 outDir 속성을 사용하여 지정됩니다.\n\n```js\n// server/tsconfig.json\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, dist 폴더를 .gitignore 파일에 포함시켜야합니다. 이렇게 하면 컴파일된 JavaScript 파일이 버전 관리에 포함되지 않습니다.\n\n```js\n// server/.gitignore\n\nnode_modules\ndist\n.env*\n```\n\nNodemon을 사용하여 변경 사항 감지\n\nTypeScript 파일을 수정할 때마다 npx tsc 및 node dist/main.js를 사용하여 파일을 수동으로 다시 컴파일하고 실행해야합니다. 이러한 반복 작업은 빠르게 지루해질 수 있습니다. 이 과정을 간소화하기 위해 nodemon이라는 도구를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodemon은 디렉토리 내 파일 변경을 감지하여 Node.js 기반 애플리케이션을 자동으로 다시 시작하는 도구입니다. 이를 이용하면 코드를 수정할 때마다 서버를 수동으로 중지하고 다시 시작하는 수고를 덜 수 있습니다.\n\nNodemon은 이미 설치했으므로 이제 구성만 남았습니다.\n\nNodemon 구성하기\n\nNodemon을 구성하려면 package.json에 nodemonConfig를 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n// server/package.json\n\n\"scripts\": {\n    \"dev\": \"nodemon\"\n  },\n  \"nodemonConfig\": {\n    \"watch\": [\n      \"src\"\n    ],\n    \"exec\": \"tsc \u0026\u0026 node ./dist/main.js\",\n    \"ext\": \"ts,js,json\"\n  },\n```\n\nnodemonConfig 섹션은 파일 변경을 모니터링할 때 nodemon이 어떻게 동작해야 하는지 알려줍니다:\n\n- watch: nodemon에게 src 폴더 내의 변경 사항을 모니터링하도록 지시합니다.\n- ext: 변경 사항을 모니터링할 파일 확장자를 지정합니다 (ts, js, json).\n- exec: 변경 사항이 감지되었을 때 실행할 명령을 정의합니다. 이 경우 TypeScript 파일을 컴파일하고 node ./dist/main.js를 실행하여 서버를 시작합니다.\n\n이제 npm run dev를 실행하여 간단히 nodemon과 함께 서버를 시작할 수 있습니다. 파일 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하는 프로세스가 자동화됩니다. 이 변경 사항으로 서버는 요청을 받을 준비가 되었습니다. Postman과 같은 API 플랫폼이 있다면 http://localhost:3001/api에 GET 요청을 보내보거나 브라우저에서 링크를 방문하여 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 클라이언트 설정\n\n저희 서버는 클라이언트로부터의 요청을 받을 준비가 되어 있습니다. 프론트엔드에서는 Vue를 사용할 것입니다. Vue는 Vite를 기반으로 한 빌드 설정을 사용하며, 이를 우리 서버와 통신하도록 구성할 것입니다. 시작해봅시다.\n\n- 클라이언트 디렉토리로 이동하기\n\n먼저 서버 디렉토리를 중지하고 종료한 후, 클라이언트로 이동해보겠습니다. 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러 중지한 다음, 다음 명령어를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 서버 디렉토리를 나와 클라이언트로 이동 \ncd ../client\n```\n\n2. Vue 프로젝트 생성\n\nVue 앱을 만들려면 다음 명령을 실행하세요. 이 명령은 . .에 의해 지정된 클라이언트 폴더에 직접 프로젝트를 생성합니다.\n\n```js\nnpm create vue@latest .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 선택지를 만들어 몇 가지 선택을 해야 할 것입니다. 패키지 이름과 TypeScript 지원에 대해 고민할 차례입니다. 당신의 프로젝트를 위해 express-vue로 이름을 지어주고 TypeScript 지원에 \"예\"를 선택하되, 다른 선택 가능한 기능들에 대해서는 \"아니요\"를 선택하여 프로젝트를 간단하게 유지해주세요.\n\n그 다음, 의존성을 설치하고 개발 서버를 시작해보세요.\n\n```js\n# 의존성 설치\nnpm install\n\n# 개발 서버 시작\nnpm run dev\n```\n\n이제 http://localhost:5173/에서 Vue 프로젝트가 실행 중일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. .env 파일 추가\n\n다음 변수를 사용하여 클라이언트 폴더의 루트에 .env 파일을 추가하십시오.\n\n```js\nVITE_SERVER_URL=http://localhost:3001\nVITE_SERVER_API_PATH=/api\n```\n\n.env 파일을 변경하면 서버를 다시 시작해야 할 수도 있습니다. 서버를 중지하려면 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러주세요. 그런 다음 서버를 다시 시작하려면 npm run dev를 다시 실행해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. vite.config.ts 파일 업데이트\n\n우리는 vite.config.ts 파일을 사용하여 클라이언트와 서버 간의 통신을 활성화하기 위해 파일을 사용자 정의하고 싶어요. defineConfig은 Vite 프로젝트에서 구성 옵션을 정의하는 데 사용되는 도우미 함수입니다. defineConfig은 객체나 함수 둘 중 하나를 인수로 받을 수 있어요. 환경 변수를 로드할 수 있도록 함수를 전달할 거에요.\n\n```js\nimport { fileURLToPath, URL } from 'node:url';\n\nimport vue from '@vitejs/plugin-vue';\nimport { defineConfig, loadEnv } from 'vite';\n\n// \u003chttps://vitejs.dev/config/\u003e\nexport default defineConfig((env) =\u003e {\n  const envars = loadEnv(env.mode, './');\n\n  const serverURL = new URL(\n    envars.VITE_SERVER_URL ?? '\u003chttp://localhost:3001\u003e'\n  );\n  const serverAPIPath = envars.VITE_SERVER_API_PATH ?? '/api';\n\n  return {\n    envDir: './',\n\n    // 클라이언트에서 API 경로를 전역적으로 사용할 수 있도록 함\n    define: {\n      __API_PATH__: JSON.stringify(serverAPIPath),\n    },\n\n    plugins: [vue()],\n    resolve: {\n      alias: {\n        '@': fileURLToPath(new URL('./src', import.meta.url)),\n      },\n    },\n\n    server: {\n      port: 5173,\n      proxy: {\n        // API 경로를 가진 요청을 서버로 프록시함\n        // \u003chttp://localhost:5173/api\u003e -\u003e \u003chttp://localhost:3001/api\u003e\n        [serverAPIPath]: serverURL.origin,\n      },\n    },\n  };\n});\n```\n\n이 설정의 각 부분이 어떤 역할을 하는지 살펴보도록 하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 환경 변수 로딩: loadEnv 함수를 사용하여 현재 모드(예: 개발, 프로덕션)에 기반하여 환경 변수를 로드합니다. 프로젝트 디렉토리에 있는 .env 파일을 읽고 변수를 envars 객체에 로드합니다.\n- 서버 URL 및 API 경로 구문 분석: 서버 URL 및 API 경로가 구문 분석되며, .env 파일에서 찾지 못한 경우 기본값이 제공됩니다.\n\n구성 옵션:\n\n- envDir: 환경 변수가 위치한 디렉토리를 지정합니다.\n- define: 빌드 과정 중에 대체될 전역 상수를 정의할 수 있습니다. 이 경우 __API_PATH__는 서버 API 경로 값으로 정의됩니다.\n- plugins: 프로젝트에서 사용하는 Vite 플러그인을 지정합니다. 여기서 Vue.js 플러그인(vue())이 추가됩니다.\n- resolve.alias: 모듈 해상도를 위한 별칭을 정의합니다. 이 경우 @ 별칭이 src 디렉토리로 설정됩니다.\n\n서버 구성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- server.port: Vite 개발 서버가 실행될 포트를 지정합니다. 여기서는 5173으로 설정되어 있어요.\n- server.proxy: 프록시 설정은 클라이언트와 서버 간 통신을 가능하게 합니다. API 경로와 일치하는 요청은 서버 URL로 전달됩니다. http://localhost:5173/api로 요청을 보내면 http://localhost:3001/api로 우리 서버로 전달됩니다.\n\n5. 전역 상수 선언\n\nvite.config.ts 파일에 전역 상수를 추가한 후, TypeScript가 이 상수를 인식하여 타입 확인을 수행하게 만들어야 합니다. env.d.ts 파일에 타입 정의를 선언하여 이를 달성할 수 있어요.\n\n```js\n// client/env.d.ts  \n\n/// \u003creference types=\"vite/client\" /\u003e \ndeclare const __API_PATH__: string;\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 선언에서는 TypeScript에 __API_PATH__ 상수의 존재를 알리고, 해당 타입을 문자열로 지정합니다. 이는 TypeScript가 프로젝트 전체에서 이 글로벌 상수에 대한 유형 확인 및 IntelliSense 지원을 제공하도록 보장합니다.\n\n6. 서버에 요청 보내기\n\n이제 Vite 프로젝트를 서버와 통신하도록 구성했으므로 App.vue 파일을 업데이트하여 서버로부터 요청을 보내고 응답을 화면에 표시해 보겠습니다. 다음 스니펫은 Vue.js composition API를 사용하여 서버에서 데이터를 가져와 앱에 표시하는 방법을 보여줍니다.\n\n```js\n// client/src/App.vue\n\n\u003cscript setup lang=\"ts\"\u003e\nimport { ref } from \"vue\";\n\n// API 기본 URL을 포함하는 전역 상수 -\u003e /api\nconst baseURL = __API_PATH__;\n\n// 로딩 상태 및 응답 메시지 관리를 위한 반응형 변수\nconst isLoading = ref(false);\nconst message = ref(\"\");\n\n// 서버에서 데이터를 가져오는 함수\nasync function fetchAPI() {\n  try {\n    // 로딩 상태를 true로 설정\n    isLoading.value = true;\n\n    // 서버에 GET 요청 보내기\n    const response = await fetch(baseURL);\n\n    // JSON 응답 해석\n    const data = await response.json();\n\n    // 응답 데이터로 메시지 업데이트\n    message.value = data.message;\n  } catch (error) {\n    // 오류 처리\n    message.value = \"데이터 검색 오류\";\n    console.error(error);\n  } finally {\n    // 로딩 상태 재설정\n    isLoading.value = false;\n  }\n}\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003c!-- fetchAPI 함수를 실행하는 버튼 --\u003e\n  \u003cbutton @click=\"fetchAPI\"\u003e가져오기\u003c/button\u003e\n\n  \u003c!-- 데이터를 가져올 때 로딩 메시지 표시 --\u003e\n  \u003cp v-if=\"isLoading\"\u003e로딩 중...\u003c/p\u003e\n\n  \u003c!-- 사용 가능한 경우 응답 메시지 표시 --\u003e\n  \u003cp v-else-if=\"message\"\u003e{ message }\u003c/p\u003e\n\u003c/template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 스니펫에서:\n\n- 우리는 Vue의 composition API에서 ref 함수를 가져와 반응형 변수를 생성하여 로딩 상태(isLoading)와 응답 메시지(message)를 관리합니다.\n- fetchAPI 함수는 fetch API를 사용해 서버로 GET 요청을 보내는 데 정의됩니다.\n- 요청이 처리되는 동안 로딩 상태가 true로 설정되고 로딩 메시지가 표시됩니다.\n- 요청이 완료되면 로딩 상태가 재설정되고 서버로부터의 응답 메시지가 표시됩니다.\n- 요청 중에 발생하는 모든 오류는 catch되어 메시지가 업데이트됩니다.\n\n이러한 업데이트로 인해, Vue 애플리케이션은 서버에서 데이터를 가져와 사용자에게 표시할 수 있습니다.\n\n7. 두 서버를 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 클라이언트가 실행 중이므로 서버를 시작해야 합니다. VS Code를 사용 중이라면, 메뉴 바에서 Terminal 옵션을 마우스 오른쪽 클릭하고 New Terminal을 선택하여 새 터미널을 열 수 있습니다. 또는 새 터미널 창을 열어 프로젝트 디렉토리로 이동할 수도 있어요. 프로젝트 디렉토리에 들어간 후 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\ncd server\nnpm run dev\n```\n\n위의 명령어를 실행하면 서버 디렉토리로 이동한 후 개발 모드에서 서버가 시작됩니다.\n\n8. 클라이언트 측 요청 초기화.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이언트에서 App.vue에서 버튼을 클릭하여 요청을 트리거하는 것이 마지막 단계입니다. 이렇게 하면 서버로 요청이 전송됩니다.\n\n# 결론\n\n축하합니다! 🎉 Express.js 및 TypeScript를 사용하여 백엔드에 Vue.js 및 Vite를 사용하는 풀스택 웹 개발 환경을 구축하는 방법을 성공적으로 배우셨습니다.\n\n이 가이드에서 다룬 내용은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 백엔드 설정: TypeScript로 Express.js 서버를 초기화하고 미들웨어를 구성하며 노드.js에서 실행할 수 있도록 코드를 컴파일하는 것부터 시작했습니다.\n- 프론트엔드 구성: 다음으로, 클라이언트와 서버 간의 통신을 허용하도록 Vite를 구성했습니다. 특정 요청을 서버로 프록시하기 위해 Vite의 서버 옵션을 활용했습니다.\n- 클라이언트-서버 통신: 환경을 설정한 후, Vue.js composition API를 사용하여 프론트엔드에서 백엔드로 요청을 보내는 방법을 배웠습니다. 서버에서 데이터를 가져와 UI를 업데이트하여 반응형 웹 애플리케이션을 만들었습니다.\n\n서버 측 로직 작업에 대한 걱정이 줄어들었기를 바라며, 동적 웹 애플리케이션을 구축하는 기초를 마련했으니 실험을 계속해보고, 계속해서 개발하고, 풀스택 부분에 더 깊이 파고들기를 주저하지 마십시오.\n\n즐거운 코딩!\n\n![이미지](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_1.png)","ogImage":{"url":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"},"coverImage":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png","tag":["Tech"],"readingTime":15},{"title":"TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트","description":"","date":"2024-06-22 03:21","slug":"2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights","content":"\n\n\n![Understanding TypeScript's Handling of Object Literal Types](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png)\n\n안녕하세요! TypeScript의 객체 리터럴 형식 처리는 때로 예상치 못한 동작을 일으킬 수 있다는 사실을 알고 계셨나요? TypeScript를 배우기 시작했을 때 나는 가끔 일어나는 이 문제로 어려움을 겪었습니다. 이것은 일관성이 없어 보이는 TypeScript의 동작 때문에 처음에는 감이 오지 않았습니다.\n\n맥락을 좀 더 설명하자면, TypeScript는 현대적 웹 애플리케이션을 구축하기 위한 타입 안전성과 고급 기능을 제공하는 Javascript의 상위 집합체로서 작용합니다. TypeScript는 선택적 정적 타이핑을 도입하여 개발자가 개발 과정 초기에 오류를 빨리 찾아내고 더 신뢰할 수 있는 코드를 작성할 수 있게 지원합니다.\n\n기본적으로, TypeScript는 이러한 상황에서 도와줍니다 (조금 미묘한 암시가 있음):-\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1.png)\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2.png)\n\n그러면 블로그 주제로 넘어가 보겠습니다. 타입스크립트에 의한 객체 리터럴의 일관되지 않은 처리에 대해 다루고 있습니다. 제가 말하는 것은 객체를 다룰 때 타입스크립트의 행동에 대해 어떤 불일치가 관찰될 수 있다는 것입니다. 설명을 듣겠습니까?\n\n# 이슈 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자를 생성하는 데 사용되는 기본 함수입니다. 기능이 작성되지 않은 빈 함수이지만, 여기서 다루는 문제는 기능의 유무가 아닙니다. 문제는 거의 동일한 약간의 차이가 있는 두 가지 다른 방법으로 호출할 때 발생합니다.\n\n다음과 같은 자잘한 차이점이 있습니다.\n\n함수에 기대하는 매개변수(이름 및 isPaid)에 email이라는 추가적인 인수를 전달하여 함수를 호출하면 오류가 발생합니다. 이는 함수를 선언할 때 정의되지 않았기 때문에 예상하지 못했던 것입니다. 꽤 기본적인 문제죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 우리가 객체를 함수의 인수로 전달하는 방식을 약간 수정하면 이 오류가 말이 안 되기 시작합니다. 우리가 바로 전달한 객체를 변수에 할당한 뒤에 변수를 함수에 전달하는 방식으로 바꾸는 것인데, 이전과 동일한 오류가 발생해야 했지만 오류가 발생하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_5.png)\n\n제가 말한 불일치입니다. 이런 일이 발생한 이유와 이를 방지할 수 있는 방법에 대해 논의하고 싶습니다.\n\n# 이런 일이 발생한 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript의 설계 결정 사항 중 Excess Property Checking과 Structural Typing 때문에 오류가 발생합니다.\n\n이 동작의 핵심은 TypeScript가 초과 속성을 확인하는 방식에 있습니다. 직접 객체 리터럴을 전달할 때 TypeScript는 함수에 추가적인 속성이 전달되지 않도록 엄격한 초과 속성 확인을 수행합니다. 이것은 잠재적인 오류를 빨리 발견하기 위한 것입니다.\n\n반면, 객체가 변수에 할당된 경우 TypeScript는 이 엄격한 확인을 건너뜁니다. 그 이유는 해당 추가 속성이 있는 객체가 코드 다른 곳에서 사용될 수 있으며, TypeScript는 이러한 경우에 더 많은 유연성을 허용합니다. 이를 구조적 타이핑이라고하며, TypeScript는 객체가 즉시 리터럴이 아닌 경우 필수 속성만을 확인하고 추가 속성을 무시합니다.\n\n## 관용구에는 말이 있듯이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_6.png\" /\u003e\n\n변수에 객체를 할당하고 함수에 전달할 때, TypeScript는 구조적 타이핑을 활용합니다. 이는 객체가 기대되는 타입 구조를 준수하는 한 추가적인 속성을 가질 수 있게 합니다. 이 접근법은 더 융통성이 있고 유연합니다.\n\n장점:-\n\n유연성: 객체를 다양한 맥락에서 더 다재다능하게 사용할 수 있습니다. 개발자는 코드의 관련없는 부분에서 오류를 일으키지 않고 추가적인 속성을 가진 객체를 생성할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n편의성: 이 기능은 복잡한 데이터 구조를 다룰 때나 다른 목적을 위해 객체에 추가 정보를 확장할 때 특히 객체 생성 및 조작을 용이하게 만듭니다.\n\n유형 안전성: TypeScript는 유연성을 유지하면서도 필수 속성이 존재하고 올바른 유형을 갖추도록 보장하여 유연성과 유형 안전성 사이의 균형을 제공합니다.\n\n# 이러한 오류를 보다 엄격한 유형 안전성을 보장하고 한정하려면 어떻게 해야 합니까?\n\n방법 1: 변경할 변수의 유형을 명시적으로 주석으로 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_7.png\" /\u003e\n\n여기서 우리는 추가 속성이 없도록 특정 유형으로 변수를 명시적으로 선언하고 있습니다.\n\n방법 2: 함수 매개변수를 설정할 때 엄격한 유형을 사용합니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 함수를 만들 때 매개변수가 엄격하게 형식화되므로 TypeScript가 알 수 없는 속성과 관련된 오류를 발생시킵니다.\n\n방법 3: 인터페이스 유형 사용\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_9.png)\n\n여기서는 유형 안전성을 위해 인터페이스를 사용하고, 추가 속성이 필요한 사용 사례에 대해 기본 인터페이스를 확장하고 있습니다.\n그러나 기본 인터페이스를 추가 속성과 함께 사용할 때 TypeScript가 알 수 없는 속성에 대한 오류를 내보내는 것을 볼 수 있습니다. 이는 맥락에 따라 쉽게 완화될 수 있으며 두 가지 목적을 제공합니다:-\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 만약 추가적인 이메일 속성이 필요한 상황이라면, 오류를 완화하기 위해 확장된 인터페이스를 사용할 수 있습니다.\n- 만약 추가적인 이메일 속성이 필요하지 않은 상황이라면, 인터페이스는 올바른 유형 확인기로 작용하여 이메일 매개변수를 잘못 설정한 오류를 알려줍니다.\n\n# 결론\n\n특히 직접적인 객체 리터럴과 변수 사이의 차이에 대한 TypeScript의 처리 방식은 유형 안전성과 유연성을 균형 있게 유지하는 의도적인 설계 선택입니다. 이 동작을 이해하면 보다 견고한 TypeScript 코드를 작성하고 기능을 효과적으로 사용하는 데 도움이 됩니다. 위에서 설명한 방법을 따르면 보다 엄격한 유형 안전성을 보장하고 과도한 속성과 관련된 잠재적인 위험 요소를 피할 수 있습니다. 처음에는 일관성이 없어 보일 수 있지만 (저에게도 그랬습니다), 이것이 유연성을 제공하기 위해 설계된 기능임을 알아차리면 개발 프로세스에서 TypeScript를 더 잘 활용할 수 있습니다.\n\n# Stackademic 🎓\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어주셔서 감사합니다! 이제 가시기 전에:\n\n- 작가를 격려하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 16 Signals 완벽 설명 5가지 예제로 배우는 법","description":"","date":"2024-06-22 03:19","slug":"2024-06-22-Angular16SignalsExplainedWithFiveExamples","content":"\n\nMarkdown 형식으로 테이블 태그를 변경해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시그널의 값은 항상 게터 함수를 통해 읽습니다. 이는 Angular이 시그널이 사용된 위치를 추적할 수 있게 합니다.\n\n그래서 이 개념을 실제로 적용하고 TypeScript에서 몇 가지 실용적인 예제로 배워봅시다:\n\n## 예제 1: 시그널을 사용하여 총 가격 업데이트하기\n\n가정해보죠. 사용자가 쇼핑 카트에 항목을 추가할 수 있는 전자 상거래 애플리케이션을 가지고 있다고 해봅시다. 항목의 총 가격을 표시하고 새 항목이 추가되거나 제거될 때마다 업데이트하고 싶습니다. 이를 달성하기 위해 시그널을 사용하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Component({\n  selector: 'my-cart',\n  template: `\n    \u003cul\u003e\n      \u003cli *ngFor=\"let item of items\"\u003e\n        {item.name} - ${item.price}\n        \u003cbutton (click)=\"removeItem(item)\"\u003eRemove\u003c/button\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n    Total Price: ${totalPrice()}\n  `,\n})\nexport class CartComponent {\n  items = [    { name: 'Product A', price: 10 },    { name: 'Product B', price: 15 },    { name: 'Product C', price: 20 },  ];\n  \n  // 장바구니의 항목 목록을 위한 신호인 itemList을 정의합니다.\n  itemList = signal(this.items);\n  \n  // 총 가격을 위한 계산된 값인 totalPrice를 정의합니다.\n  totalPrice = computed(() =\u003e {\n    return this.itemList().reduce((acc, curr) =\u003e acc + curr.price, 0);\n  });\n  \n  removeItem(item) {\n    // 선택한 항목을 제거하여 itemList 신호를 업데이트합니다.\n    this.itemList.set(this.itemList().filter((i) =\u003e i !== item));\n  }\n}\n```\n\n이 예제에서는 장바구니에 있는 항목 목록을 나타내는 신호인 itemList을 정의하고, itemList에 의존하는 총 가격인 totalPrice를 계산된 값으로 정의합니다. 장바구니에서 항목을 제거할 때 itemList 신호를 업데이트하여 totalPrice를 다시 계산합니다.\n\n## 예제 2: 신호를 사용하여 로딩 스피너를 보이거나 숨기기\n\nAPI에서 데이터를 가져와 테이블에 표시하는 컴포넌트가 있다고 가정해봅시다. 데이터를 가져오는 동안 로딩 스피너를 표시하려고 합니다. 이를 신호를 사용하여 구현하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Component({\n  selector: 'my-table',\n  template: `\n    \u003cdiv *ngIf=\"isLoading()\"\u003e\n      Loading...\n    \u003c/div\u003e\n    \u003ctable *ngIf=\"!isLoading()\"\u003e\n      \u003cthead\u003e...\u003c/thead\u003e\n      \u003ctbody\u003e...\u003c/tbody\u003e\n    \u003c/table\u003e\n  `,\n})\nexport class TableComponent {\n  // 로딩 상태를 위한 신호 loading을 정의하고 초기값을 true로 설정합니다.\n  \n  loading = signal(true);\n  \n  ngOnInit() {\n    // API에서 데이터를 가져옵니다.\n    fetchData().subscribe((data) =\u003e {\n      // 데이터가 수신되면 로딩 신호를 false로 업데이트합니다.\n      this.loading.set(false);\n      \n      // 테이블에 데이터를 렌더링합니다.\n      ...\n    });\n  }\n  \n  isLoading() {\n    return this.loading();\n  }\n}\n```\n\n이 예제에서는 로딩 상태를 나타내는 신호 loading을 정의하고 초기값을 true로 설정합니다. 컴포넌트가 초기화될 때 API에서 데이터를 가져와 데이터를 수신했을 때 로딩 신호를 false로 업데이트합니다. isLoading 메서드는 현재 로딩 신호의 값을 반환하며, 이 값은 로딩 스피너 또는 테이블을 조건부로 렌더링하는 데 사용됩니다.\n\n## 예제 3: 응용 프로그램에서 반응형 프로그래밍을 위한 신호 사용\n\n이 예제에서는 여러 가지 신호, 계산된 신호 및 이펙트를 활용하여 더 복잡한 시나리오에서의 사용법을 시연합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// Writable signals\nconst firstName = signal('John');\nconst lastName = signal('Doe');\nconst age = signal(30);\n\n// Computed signal to calculate the full name\nconst fullName = computed(() =\u003e `${firstName()} ${lastName()}`);\n\n// Computed signal to determine if the person is an adult\nconst isAdult = computed(() =\u003e age() \u003e= 18);\n\n// Effect to log the full name and adult status whenever any of the signals change\neffect(() =\u003e {\n  console.log(`Full Name: ${fullName()}`);\n  console.log(`Is Adult: ${isAdult()}`);\n});\n\n// Update the values of the writable signals\nfirstName.set('Jane');\nlastName.set('Smith');\nage.set(25);\n```\n\n여기 예제에서는 세 가지 쓰기 가능한 시그널이 있습니다: firstName, lastName 및 age입니다. firstName과 lastName을 결합하는 fullName 및 나이를 기반으로 사람이 성인인지 여부를 결정하는 isAdult라는 두 개의 계산된 시그널을 만듭니다. 그런 다음, 시그널이 변경 될 때마다 전체 이름 및 성인 여부를 기록하는 효과를 만듭니다.\n\n쓰기 가능한 시그널의 값을 업데이트하면, 해당 값이 변경되었을 때 효과가 실행되어 업데이트된 전체 이름과 성인 여부가 기록됩니다.\n\n이 예제는 시그널, 계산된 시그널 및 효과가 데이터의 변경을 추적하고 반응하여 애플리케이션에서 반응형 프로그래밍을 가능하게 하는 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예제 4: 다양한 조건에 따라 데이터를 필터링, 정렬 및 계산하는 신호 사용\n\n이 예제는 여러 신호를 통합하고 종속성을 가진 계산된 신호 및 효과를 포함하여 더 복잡한 시나리오를 다룹니다:\n\n```js\nimport { signal, computed, effect } from 'signal';\n\n// 쓰기 가능한 신호\nconst todos = signal([\n  { id: 1, title: '장보기', completed: false },\n  { id: 2, title: '세탁하기', completed: true },\n  { id: 3, title: '개 산책시키기', completed: false }\n]); // 할 일 목록\n\nconst showCompleted = signal(false); // 완료된 할 일을 표시해야 하는지 여부를 나타내는 플래그\n\n// showCompleted 플래그에 기반하여 할 일을 필터링하고 정렬하는 계산된 신호\nconst filteredTodos = computed(() =\u003e {\n  const filtered = todos().filter(todo =\u003e showCompleted() || !todo.completed);\n  return filtered.sort((a, b) =\u003e a.id - b.id);\n});\n\n// 남은 할 일 수를 계산하는 계산된 신호\nconst remainingTodosCount = computed(() =\u003e\n  todos().reduce((count, todo) =\u003e (todo.completed ? count : count + 1), 0)\n);\n\n// 변경 시 필터링된 할 일과 남은 수를 로그하는 효과\neffect(() =\u003e {\n  console.log('필터링된 할 일:');\n  console.log(filteredTodos());\n  console.log(`남은 할 일 수: ${remainingTodosCount()}`);\n});\n\n// 쓰기 가능한 신호의 값 업데이트\ntodos.mutate(value =\u003e {\n  value.push({ id: 4, title: '집 청소하기', completed: false });\n  value[1].completed = false;\n});\n\n// showCompleted 플래그 업데이트\nshowCompleted.set(true);\n```\n\n이 예제에서는 할 일 목록을 나타내는 쓰기 가능한 신호 todos가 있습니다. 또한 완료된 할 일을 표시해야 하는지를 나타내는 쓰기 가능한 신호 showCompleted가 있습니다. showCompleted 플래그에 따라 할 일을 필터링하고 정렬하는 computed 신호 filteredTodos를 생성합니다. 추가로, 남은 할 일 수를 계산하는 computed 신호 remainingTodosCount를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 그런 다음, 변경될 때마다 필터된 할 일 목록과 남은 항목 수를 기록하는 효과를 만듭니다. 결정이 변경될 때마다 이 효과가 여러 번 실행됩니다.\n\n할 일 목록을 업데이트하고 showCompleted 플래그를 변경하는 경우와 같이 쓰기 가능한 시그널의 값을 업데이트할 때, 이 효과가 실행되어 업데이트된 필터된 할 일 목록과 남은 항목 수를 기록합니다. 마지막으로 showCompleted 플래그를 업데이트하여 새로운 필터된 할 일 목록으로 다시 효과를 트리거합니다.\n\n이 예제에서는 시그널, 계산된 시그널 및 효과가 어떻게 함께 작동하여 필터링, 정렬 및 다양한 조건에 따라 데이터를 계산하는 복잡한 시나리오를 처리하는지 보여줍니다.\n\n## 예제 5: 다수의 사용자가 공유하고 수정할 수 있는 장보기 목록 애플리케이션을 구현하는 데 시그널을 사용하는 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 신호(Signals)를 활용하여 다수 사용자가 공유하고 수정할 수 있는 식료품 쇼핑 목록 애플리케이션을 만드는 방법 예제가 있어요.\n\n```js\n@Component({\n  selector: 'my-grocery-list',\n  template: `\n    \u003ch2\u003e식료품 목록:\u003c/h2\u003e\n    \u003cul\u003e\n      \u003cli *ngFor=\"let item of items\"\u003e\n        {item.name} - {item.quantity} - 최종 편집자: {item.lastEditedBy}\n        \u003cbutton (click)=\"removeItem(item)\"\u003e삭제\u003c/button\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n    \u003ch3\u003e아이템 추가:\u003c/h3\u003e\n    \u003cform (submit)=\"addItem()\"\u003e\n      \u003cinput type=\"text\" [(ngModel)]=\"newItemName\" placeholder=\"이름\"\u003e\n      \u003cinput type=\"number\" [(ngModel)]=\"newItemQuantity\" placeholder=\"수량\"\u003e\n      \u003cbutton type=\"submit\"\u003e추가\u003c/button\u003e\n    \u003c/form\u003e\n  `,\n})\nexport class GroceryListComponent {\n  items = [    { name: '사과', quantity: 5, lastEditedBy: null },    { name: '바나나', quantity: 3, lastEditedBy: null },    { name: '우유', quantity: 1, lastEditedBy: null },  ];\n  \n  // 아이템 목록에 대한 신호(signal) 정의\n  itemList = signal(this.items);\n  \n  // 현재 사용자의 이름에 대한 신호(signal) 정의\n  currentUser = signal('남편');\n  \n  addItem() {\n    // 현재 사용자의 이름을 마지막으로 편집한 값으로 하는 새로운 항목을 itemList 신호에 추가\n    this.itemList.set([...this.itemList(), { name: this.newItemName, quantity: this.newItemQuantity, lastEditedBy: this.currentUser() }]);\n    \n    // 입력 필드를 지웁니다\n    this.newItemName = '';\n    this.newItemQuantity = '';\n  }\n  \n  removeItem(item) {\n    // 선택한 항목을 itemList 신호에서 제거\n    this.itemList.set(this.itemList().filter((i) =\u003e i !== item));\n  }\n}\n```\n\n이 예제에서는 식료품 쇼핑 목록의 항목 리스트를 위한 itemList 신호와 현재 사용자의 이름을 위한 currentUser 신호를 정의했습니다. 새 항목을 추가하거나 기존 항목을 제거할 때 itemList 신호를 업데이트하여 뷰의 재계산이 일어나도록 합니다. 또한 수정된 항목의 lastEditedBy 속성을 currentUser 신호의 현재 값으로 설정합니다.\n\naddItem 메서드는 현재 사용자의 이름을 lastEditedBy 값으로 하는 새 항목을 itemList 신호에 추가합니다. removeItem 메서드는 선택한 항목을 itemList 신호에서 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글을 읽어주셔서 감사합니다. 제 글이 유익하고 생각을 자극했기를 바랍니다.\n\n만약 여러분이 이 글을 지금까지 즐겁게 읽으셨다면, 제 Medium 페이지를 팔로우하시고 박수를 쳐주세요! 🙂\n\n![image](/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_1.png)\n\n팔로우하신다면 댓글 섹션에서 다른 분들과 함께 소통할 수 있는 기회도 생기고, 여러분의 의견을 항상 환영합니다. 팔로워 여러분들의 의견을 매우 소중히 여깁니다. 💬🌟\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 다른 게시물에 대한 링크:\n1. PART ONE: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n2. PART TWO: 간단한 예제와 함께 마이크로서비스 애플리케이션에서 사용되는 가장 일반적인 Spring Boot 어노테이션\n3. MySQL 및 Rest 엔드포인트를 사용하는 간단한 Spring Boot 애플리케이션\n4. Spring Boot를 사용하여 마이크로서비스 애플리케이션에서 REST API를 개발할 때 따를 가장 좋은 방법들","ogImage":{"url":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png"},"coverImage":"/assets/img/2024-06-22-Angular16SignalsExplainedWithFiveExamples_0.png","tag":["Tech"],"readingTime":8},{"title":"Redux에서 Redux Toolkit으로 마이그레이션 3부작 시리즈","description":"","date":"2024-06-22 03:16","slug":"2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries","content":"\n\n## 파트 1: Redux 및 Typescript를 사용하여 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png)\n\n레거시 코드베이스를 React로 이관하는 것은 오래된 개발 방식에서 새로운 방식을 가르치는 것과 비슷합니다. 도전적이지만 보람이 있어요! 저희 애플리케이션 중 하나에서는 Redux Toolkit 없이 Redux를 사용하고 있는데, 이전 방식에 대한 리소스를 찾기는 바늘을 건삭하는 것과 같습니다. 대부분의 현대적인 앱은 이제 Redux Toolkit을 사용하며, 이것은 Redux가 공식적으로 추천하는 방식입니다.\n\n이것이 Redux에서 Redux Toolkit으로 마이그레이션하는 가이드를 작성하게 된 계기예요. 앱에 세련된 업그레이드를 해주는 것으로 생각해보세요! 이 튜토리얼은 3부작 시리즈로 이루어져 있을 것입니다: 먼저 전통적인 Redux를 사용하여 앱을 구축한 다음, Redux Toolkit으로 메이크오버할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 GitHub 프로필 찾기 애플리케이션을 만들어 보세요\n\n![GitHub profile finder](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_1.png)\n\n이 애플리케이션에서는 팔로워 수가 1000을 초과하는 인기 있는 사용자 목록을 선별해 두었습니다. 코딩 세계에서는 인기가 중요하니까요! 코딩 영웅들을 찾아보고 'View Repos' 옵션으로 그들의 공개 저장소로 들어가 보세요. 또한 즐겨찾기한 즐겨찾기기능(데이터 표시 제외)이 있어 좋아하는 사용자를 즐겨찾기할 수 있습니다.\n\n전제 조건\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact와 TypeScript에 대한 좋은 이해도가 있어야 하며, Redux와 Tailwind CSS의 기본 지식이 필요합니다.\n\nGitHub에서 우리 React 앱의 기본 설정을 찾을 수 있습니다.\n\n이 저장소에 대해:\n이 저장소 내에서, Vite 빌드 도구를 사용하여 구축된 기본 React 애플리케이션을 발견할 수 있습니다. 타입 안전성을 위해 TypeScript를 활용하고, 디자인을 위해 Tailwind CSS를 사용할 것입니다.\n\n이 애플리케이션에 필요한 라이브러리를 설치해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 인터넷 연결에 Axios를 사용하고 앱을 탐색하기 위해 React Router를 사용하며 물론 상태를 유지하기 위해 Redux를 사용할 것입니다. 이 라이브러리들을 설치해 봅시다!!\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_2.png)\n\n폴더 구조\n\n이 폴더 구조를 계속 사용할 것입니다. 함께 따라오고 싶다면 이 튜토리얼과 함께 feature/old-redux 브랜치를 확인해 주세요. 함께 여정을 즐길까요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_3.png)\n\n먼저, 쉬운 작업으로 시작해보죠 - API 요청 설정해보기.\n\n'redux' 폴더 아래에 'services'라는 폴더를 만들고, 그 안에 'index.ts'라는 파일을 만들어봅시다.\n\n이 파일에서는 네 가지 유용한 메소드를 사용하여 조금의 마법을 부릴 겁니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 'fetchTopUsersBySize': 상위 사용자 목록을 가져옵니다.\n- 'fetchUserBySearch': 사용자를 검색합니다.\n- 'fetchReposByUserName': 특정 사용자의 저장소를 검색합니다.\n- 'fetchRepoBySearch': 이름으로 저장소를 검색합니다.\n\n```js\nimport api from '../api';\n\nexport const fetchTopUsersBySize = async (size: number = 30) =\u003e {\n  const response = await api.get(\n    `/search/users?q=followers:\u003e1000\u0026sort=followers\u0026order=desc\u0026per_page=${size}`\n  );\n  return response.data;\n};\n\nexport const fetchUserBySearch = async (text: string) =\u003e {\n  const response = await api.get(`/search/users?q=${text}`);\n  return response.data;\n};\n\nexport const fetchReposByUserName = async (userName: string) =\u003e {\n  const response = await api.get(\n    `/users/${userName}/repos?sort=created\u0026direction=desc`\n  );\n  return response.data;\n};\n\nexport const fetchRepoBySearch = async (userName: string, text: string) =\u003e {\n  const response = await api.get(\n    `/search/repositories?q=user:${userName}+${text}`\n  );\n  return response.data;\n};\n```\n\n주요 Redux 개념 요약\n\n- Store: 애플리케이션 전체 상태를 보유하는 단일 진리의 소스입니다.\n- Actions: 발생한 일을 설명하는 일반적인 자바스크립트 객체입니다.\n- Reducers: 현재 상태와 동작을 인자로 받아 새로운 상태를 반환하는 순수 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스 폴더 구조\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_4.png)\n\n내 폴더 구조에 대한 자세한 내용은 다루지 않겠습니다. 다양한 개발자들은 서로 다른 관점으로 폴더 구조를 설정하기 때문입니다. 내 GitHub 저장소를 참조하여 내 코드 구조와 누락된 사항이 무엇인지 확인해보세요.\n\n가장 먼저, 우리 액션을 설정해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 액션 유형을 설정해 봅시다! 액션 유형을 다양한 섹션으로 분할하여 깔끔하게 유지합니다.\n\n- Action Types를 위한 Enum: UsersActionTypes라는 열거형을 정의하여 모든 액션 유형 상수를 포함시킵니다. 이렇게 하면 관리가 쉬워지고 오타를 방지할 수 있습니다.\n- 액션 인터페이스: 각 액션 유형에 대한 인터페이스를 정의합니다.\n- 액션을 위한 Union Types: 관련된 액션을 그룹화하기 위해 유니온 타입을 정의합니다.\n\n```js\nimport { Users } from '../../types/usersTypes';\n\nexport enum UsersActionTypes {\n  /** 사용자 가져오기 */\n  FETCH_TOP_USERS_REQUEST = 'FETCH_TOP_USERS_REQUEST',\n  FETCH_TOP_USERS_SUCCESS = 'FETCH_TOP_USERS_SUCCESS',\n  FETCH_TOP_USERS_FAILURE = 'FETCH_TOP_USERS_FAILURE',\n\n  /** 검색으로 사용자 가져오기 */\n  FETCH_USERS_BY_SEARCH_REQUEST = 'FETCH_USERS_BY_SEARCH_REQUEST',\n  FETCH_USERS_BY_SEARCH_SUCCESS = 'FETCH_USERS_BY_SEARCH_SUCCESS',\n  FETCH_USERS_BY_SEARCH_FAILURE = 'FETCH_USERS_BY_SEARCH_FAILURE',\n\n  /** 사용자 좋아요 옵션 전환 */\n  TOGGLE_USER_LIKE = 'TOGGLE_USER_LIKE',\n}\n\nexport interface FetchTopUsersRequestAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_REQUEST;\n}\n\nexport interface FetchTopUsersSuccessAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchTopUsersFailureAction {\n  type: typeof UsersActionTypes.FETCH_TOP_USERS_FAILURE;\n  payload: string;\n}\n\nexport interface FetchUsersBySearchRequestAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST;\n}\n\nexport interface FetchUsersBySearchSuccessAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS;\n  payload: Users;\n}\n\nexport interface FetchUsersBySearchFailureAction {\n  type: typeof UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE;\n  payload: string;\n}\n\nexport interface ToggleUserLikeAction {\n  type: typeof UsersActionTypes.TOGGLE_USER_LIKE;\n  payload: number;\n}\n\nexport type FetchTopUsersActions =\n  | FetchTopUsersRequestAction\n  | FetchTopUsersSuccessAction\n  | FetchTopUsersFailureAction;\n\nexport type FetchUsersBySearchActions =\n  | FetchUsersBySearchRequestAction\n  | FetchUsersBySearchSuccessAction\n  | FetchUsersBySearchFailureAction;\n\nexport type UserActions =\n  | FetchTopUsersActions\n  | FetchUsersBySearchActions\n  | ToggleUserLikeAction;\n```\n\n- FetchTopUsersRequestAction, FetchTopUsersSuccessAction, FetchTopUsersFailureAction: 상위 사용자 가져오기와 관련된 작업에 대한 인터페이스입니다. FETCH_TOP_USERS_SUCCESS에는 가져온 사용자 데이터가 포함된 Users 유형의 payload가 포함되어 있으며, FETCH_TOP_USERS_FAILURE에는 오류 메시지를 나타내는 문자열 유형의 payload가 포함되어 있습니다.\n- FetchUsersBySearchRequestAction, FetchUsersBySearchSuccessAction, FetchUsersBySearchFailureAction: 검색으로 사용자를 가져오기 위한 유사한 인터페이스입니다.\n- ToggleUserLikeAction: 좋아요 옵션을 전환하는 작업을 위한 인터페이스로, 사용자 ID를 나타내는 숫자 유형의 payload가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림: 계속 진행하기 전에 redux-thunk를 설치해 봅시다.\n\n![이미지](/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_5.png)\n\nRedux Thunk는 액션 생성자가 액션 객체 대신 함수를 반환할 수 있게 해주는 미들웨어입니다. 이 함수는 비동기 작업을 수행하고 해당 작업이 완료되면 일반 동기 액션을 디스패치할 수 있습니다.\n\n이제 우리의 액션 생성자와 thunk 함수를 준비해 봅시다. 이들은 데이터를 가져오고 필요한 액션을 디스패치하는 Redux 설정의 핵심 역할을 담당할 것입니다. 아래는 코드와 각 부분이 하는 역할에 대한 설명입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Users } from '../../types/usersTypes';\nimport { fetchTopUsersBySize, fetchUserBySearch } from '../../services';\nimport { ThunkAction } from 'redux-thunk';\nimport { ApplicationState } from '../../store';\nimport {\n  FetchTopUsersRequestAction,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  FetchUsersBySearchRequestAction,\n  FetchUsersBySearchSuccessAction,\n  FetchUsersBySearchFailureAction,\n  FetchTopUsersActions,\n  FetchUsersBySearchActions,\n  ToggleUserLikeAction,\n} from './types';\n\n// 액션 생성자\nexport const fetchTopUsersRequest = (): FetchTopUsersRequestAction =\u003e ({\n  type: UsersActionTypes.FETCH_TOP_USERS_REQUEST,\n});\n\nexport const fetchTopUsersSuccess = (\n  users: Users\n): FetchTopUsersSuccessAction =\u003e ({\n  type: UsersActionTypes.FETCH_TOP_USERS_SUCCESS,\n  payload: users,\n});\n\nexport const fetchTopUsersFailure = (\n  error: string\n): FetchTopUsersFailureAction =\u003e ({\n  type: UsersActionTypes.FETCH_TOP_USERS_FAILURE,\n  payload: error,\n});\n\nexport const fetchSearchUsersRequest = (): FetchUsersBySearchRequestAction =\u003e ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST,\n});\n\nexport const fetchSearchUsersSuccess = (\n  users: Users\n): FetchUsersBySearchSuccessAction =\u003e ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS,\n  payload: users,\n});\n\nexport const fetchSearchUsersFailure = (\n  error: string\n): FetchUsersBySearchFailureAction =\u003e ({\n  type: UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE,\n  payload: error,\n});\n\nexport const toogleUserLike = (userId: number): ToggleUserLikeAction =\u003e ({\n  type: UsersActionTypes.TOGGLE_USER_LIKE,\n  payload: userId,\n});\n\n// Thunk 함수\nexport const getTopUsersBySize =\n  (\n    size: number = 30\n  ): ThunkAction\u003cvoid, ApplicationState, unknown, FetchTopUsersActions\u003e =\u003e\n  async (dispatch) =\u003e {\n    dispatch(fetchTopUsersRequest());\n    try {\n      const users = await fetchTopUsersBySize(size);\n      dispatch(fetchTopUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchTopUsersFailure(error.message));\n      } else {\n        dispatch(fetchTopUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\n\nexport const getUsersBySearch =\n  (\n    userName: string\n  ): ThunkAction\u003cvoid, ApplicationState, unknown, FetchUsersBySearchActions\u003e =\u003e\n  async (dispatch) =\u003e {\n    dispatch(fetchSearchUsersRequest());\n    try {\n      const users = await fetchUserBySearch(userName);\n      dispatch(fetchSearchUsersSuccess(users));\n    } catch (error) {\n      if (error instanceof Error) {\n        dispatch(fetchSearchUsersFailure(error.message));\n      } else {\n        dispatch(fetchSearchUsersFailure('Oops something went wrong!!!'));\n      }\n    }\n  };\r\n```\n\n참고: ' ApplicationState '를 ‘../../store’에서 가져오는 것은 오류를 발생시킵니다. 하지만 걱정하지 마세요. 코드를 설정할 때 이를 수정할 것입니다.\n\n- 액션 생성자: Redux 스토어에 보내는 액션을 생성하는 함수들입니다.\n\n- fetchTopUsersRequest, fetchTopUsersSuccess, 그리고 fetchTopUsersFailure: 이러한 함수들은 상위 사용자를 가져오는 과정의 다른 단계(요청, 성공, 실패)을 위한 액션을 생성합니다.\n- fetchSearchUsersRequest, fetchSearchUsersSuccess, 그리고 fetchSearchUsersFailure: 검색을 통해 사용자를 가져오기 위한 유사한 함수들입니다.\n- toggleUserLike: 사용자의 좋아요 상태를 전환하는 액션을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Thunk 함수: 이는 비동기 작업을 처리하고 결과에 따라 액션을 디스패치하는 함수들입니다.\n\n- getTopUsersBySize: 이 Thunk 함수는 특정 크기를 기반으로 상위 사용자들을 가져옵니다. 먼저 요청이 시작되었음을 나타내기 위해 fetchTopUsersRequest를 디스패치합니다. 그런 다음 fetchTopUsersBySize를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 가져온 사용자와 함께 fetchTopUsersSuccess를 디스패치하고 오류가 발생하면 오류 메시지와 함께 fetchTopUsersFailure를 디스패치합니다.\n- getUsersBySearch: getTopUsersBySize와 유사하게,이 Thunk 함수는 검색어를 기반으로 사용자를 가져오는 작업을 처리합니다. 시작을 나타내기 위해 fetchSearchUsersRequest를 디스패치 한 후 fetchUserBySearch를 사용하여 사용자를 가져오려고 시도합니다. 성공하면 사용자와 함께 fetchSearchUsersSuccess를 디스패치하고 실패하면 오류 메시지와 함께 fetchSearchUsersFailure를 디스패치합니다.\n\n이러한 액션 생성자 및 Thunk 함수는 Redux 애플리케이션에서 데이터를 가져오고 상태 전환이 관리되는 논리를 처리하는 데 중요합니다. 이러한 방식으로 액션과 액션 유형을 구성함으로써 Redux 설정에서 다양한 사용자 관련 작업을 처리하기 위한 명확하고 관리 가능한 구조를 만들 수 있습니다. 이러한 구조가 갖춰지면 리듀서를 설정하여 이러한 작업을 처리하러 진행할 수 있습니다.\n\n다음으로 리듀서를 설정해 봅시다. 여기서 상태 관리가 게임을 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 조각은 애플리케이션의 상태가 Redux 스토어에 전달된 다양한 액션에 대한 응답으로 어떻게 업데이트되는지를 정의하기 때문에 중요합니다. 각 부분이 무엇을 하는지 살펴보겠습니다.\n\n```js\nimport {\n  UserActions,\n  UsersActionTypes,\n  FetchTopUsersSuccessAction,\n  FetchTopUsersFailureAction,\n  ToggleUserLikeAction,\n} from '../actions/users/types';\nimport { Users } from '../types/usersTypes';\n\ninterface UsersState {\n  loading: boolean;\n  users: Users | null;\n  error: string | null;\n}\n\nconst initialState: UsersState = {\n  loading: false,\n  users: null,\n  error: null,\n};\n\nexport const usersReducer = (\n  state = initialState,\n  action: UserActions\n): UsersState =\u003e {\n  switch (action.type) {\n    case UsersActionTypes.FETCH_TOP_USERS_REQUEST:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_REQUEST:\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_SUCCESS:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: (action as FetchTopUsersSuccessAction).payload,\n        error: null,\n      };\n    case UsersActionTypes.FETCH_TOP_USERS_FAILURE:\n    case UsersActionTypes.FETCH_USERS_BY_SEARCH_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        error: (action as FetchTopUsersFailureAction).payload,\n      };\n\n    case UsersActionTypes.TOGGLE_USER_LIKE: {\n      const userId = (action as ToggleUserLikeAction).payload;\n      if (!state.users) {\n        return state; // 사용자 데이터가 null인 경우 상태를 그대로 반환합니다.\n      }\n      const updatedUsers = state.users.items.map((user) =\u003e {\n        if (user.id === userId) {\n          return {\n            ...user,\n            isLiked: !user.isLiked, // 좋아하는 속성을 토글합니다.\n          };\n        }\n        return user;\n      });\n      return {\n        ...state,\n        users: {\n          ...state.users,\n          items: updatedUsers,\n        },\n      };\n    }\n    default:\n      return state;\n  }\n};\n```\n\n- 상태 인터페이스 및 초기값:\n\n- UsersState: 사용자의 Redux 상태의 모양을 정의하며, 데이터가 검색 중인지를 나타내는 loading, 사용자 데이터를 보유하거나 아직 검색되지 않은 경우 null 또는 오류 메시지를 저장하는 error를 포함합니다.\n- initialState: 기본값으로 UsersState를 초기화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Reducer Function:\n\n- usersReducer: 이 함수는 디스패치된 액션에 기반하여 상태 업데이트를 처리합니다. 상태와 액션을 매개변수로 받습니다.\n- switch 문: action.type을 평가하여 상태를 업데이트하는 방법을 결정합니다.\n- FETCH_TOP_USERS_REQUEST 및 FETCH_USERS_BY_SEARCH_REQUEST: loading을 true로 설정하고 기존 오류를 지웁니다.\n- FETCH_TOP_USERS_SUCCESS 및 FETCH_USERS_BY_SEARCH_SUCCESS: payload에서 가져온 사용자 데이터로 상태를 업데이트하고 loading을 false로 설정합니다.\n- FETCH_TOP_USERS_FAILURE 및 FETCH_USERS_BY_SEARCH_FAILURE: payload에서 가져온 오류 메시지로 상태를 업데이트하고 loading을 false로 설정합니다.\n- TOGGLE_USER_LIKE: userId로 식별된 사용자의 isLiked 속성을 토글합니다. 상태.users.items를 매핑하여 사용자를 찾고 isLiked를 토글한 후 새 배열인 updatedUsers를 반환합니다. 마지막으로 updatedUsers로 상태를 업데이트합니다. 왜 이렇게 많이 빙빙 돌까요? 상태는 불변이기 때문에 새 복사본을 만들어야 합니다.\n\n3. Default case: 액션 유형이 어떤 케이스와도 일치하지 않으면 상태를 그대로 반환합니다.\n\n이 리듀서는 우리 상태의 내비게이터 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 리듀서를 만들어 봅시다. combineReducers를 사용하여 rootReducer를 생성합니다. combineReducers를 사용하면 Redux 상태의 관리를 간단하게 만들 수 있습니다. 이를 통해 상태 관리 로직을 분리하여 전문화된 리듀서로 분할할 수 있습니다. 우리의 리듀서를 하나의 rootReducer로 결합함으로써, Redux 스토어가 애플리케이션의 다른 부분의 상태를 조직적이고 확장 가능한 방식으로 관리할 수 있도록 합니다.\n\n```js\nimport { combineReducers } from 'redux';\nimport { usersReducer } from './userReducer';\n\n// Combine Reducers\nconst rootReducer = combineReducers({\n  users: usersReducer,\n});\n\n// export type AppState = ReturnType\u003ctypeof rootReducer\u003e;\nexport default rootReducer;\n```\n\n이제 우리의 액션과 리듀서가 원활하게 함께 작동하고 있으니, Redux 상태의 기반인 스토어를 구축할 시간입니다!\n\n다음으로, 스토어 설정에 대해 자세히 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 그 전에 애플리케이션에서 사용할 액션 유형을 내보내보겠습니다.\n\n```js\nimport { UserActions } from '../actions/users/types';\n\nexport type AppActionTypes = UserActions;\n```\n\n여기는 Redux 스토어를 설정하는 코드입니다. 이곳에서 모든 마법이 일어납니다.\n\n```js\nimport {\n  applyMiddleware,\n  compose,\n  legacy_createStore as createStore,\n} from 'redux';\nimport { thunk, ThunkDispatch } from 'redux-thunk';\nimport rootReducer from '../reducers';\nimport { AppActionTypes } from '../types/types';\nimport loggingMiddleware from '../middlewares/logging';\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\n// 미들웨어 배열 정의\nconst middleware = [thunk, loggingMiddleware];\n\nconst composeEnhancers =\n  (typeof window !== 'undefined' \u0026\u0026\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n  compose;\n\nexport const store = createStore(\n  rootReducer,\n  undefined,\n  composeEnhancers(applyMiddleware(...middleware))\n);\n\nexport type ApplicationState = ReturnType\u003ctypeof rootReducer\u003e;\nexport type ApplicationDispatch = ThunkDispatch\u003c\n  ApplicationState,\n  unknown,\n  AppActionTypes\n\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 창 선언: 우리는 Redux DevTools Extension과 호환되는 저장소를 만들기 위한 전역 인터페이스를 선언하여, 둘 사이의 원활한 통신을 보장합니다.\n- 미들웨어 설정: 우리는 미들웨어 팀을 구성하며 thunk와 loggingMiddleware을 포함시켜, 비동기 작업 및 로깅 활동과 같은 작업을 처리할 준비를 합니다.\n- Enhancers 조합: 이 함수는 미들웨어를 결합하고 저장소를 향상시키는 조합자를 만들어서, 모든 것이 원활하게 동작하도록 합니다. Redux DevTools Extension과 통합되며, 보기 좋은 저장소가 되도록 세심하게 조정됩니다!\n- 저장소 생성: createStore를 사용하여 Redux 저장소를 만들어냅니다. rootReducer를 취하여 상태를 관리하며, 초기 상태로 undefined를 사용하며, 작업 및 상태 변경을 효과적으로 관리하기 위해 미들웨어를 적용합니다.\n- 타입 정의: 마지막으로 rootReducer가 관리하는 Redux 상태의 유형으로 ApplicationState를 정의하고, 디스패치 함수의 유형으로 ApplicationDispatch를 정의하여 Redux 여행 중에 타입 안전성을 보장합니다.\n\n```js\nimport { Middleware } from 'redux';\nimport { ApplicationState } from '../store';\n\nconst loggingMiddleware: Middleware\u003cobject, ApplicationState\u003e =\n  (store) =\u003e (next) =\u003e (action) =\u003e {\n    // 액션을 기록합니다.\n    console.log('Action:', action);\n\n    // 액션이 전달되기 전의 현재 상태를 가져옵니다.\n    const prevState = store.getState();\n\n    // 액션을 실행합니다.\n    const result = next(action);\n\n    // 액션이 전달된 후의 상태를 가져옵니다.\n    const nextState = store.getState();\n\n    // 상태 변경 사항을 기록합니다.\n    console.log('이전 상태:', prevState);\n    console.log('다음 상태:', nextState);\n\n    return result;\n  };\n\nexport default loggingMiddleware;\n```\n\n저장소가 설정되어 있으므로, Redux 상태 관리는 응용 프로그램의 복잡성을 처리할 준비가 되어 있습니다. 이제, 페이지를 구축하기 전에, 우리 전체 응용 프로그램을 `Provider store='store'`로 감싸봅시다. 이렇게 하면 Redux 저장소가 구성 요소 트리의 모든 구성 요소에서 사용할 수 있게 됩니다. store는 Redux 저장소의 인스턴스를 나타내는 속성으로 전달되며, 저장소는 여러분의 Redux 저장소 인스턴스를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인.tsx 파일에 이 코드를 추가해주세요.\n\n```js\n\u003cProvider store={store}\u003e\n      \u003cdiv className=\"min-h-screen flex  justify-center bg-gray-100\"\u003e\n        \u003cdiv class=\"w-full max-w-screen-lg m-4 p-4 bg-white rounded shadow-md\"\u003e\n          \u003ch1 className=\"text-4xl font-bold text-blue-900 mb-4 tracking-wider uppercase\"\u003e\n            GitHub Finder\n          \u003c/h1\u003e\n          \u003cRouterProvider router={router} /\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/Provider\u003e\r\n```\n\n이 글이 조금 무거워지고 있는 것 같지만, Redux 상태 관리를 설정하는 데에는 약간의 노력이 필요합니다. 그게 바로 Redux Toolkit이라는 것을 만들었기 때문이죠. 다음 시리즈에서 이에 대해 다룰 예정입니다. 이제 내가 당신의 신뢰를 되찾았길 바라며, 어플리케이션에 대해 살펴봐요!\n\nuseSelector와 useDispatch 훅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Redux에서 useSelector 및 useDispatch 훅을 사용하면 컴포넌트가 Redux 스토어와 상호작용하는 방법이 간소화됩니다.\n\nuseSelector: 이 훅을 사용하면 컴포넌트가 Redux 상태의 특정 슬라이스를 선택할 수 있어 데이터 접근을 최적화하고 불필요한 렌더링을 최소화할 수 있습니다.\n\nuseDispatch: 액션을 디스패치하는 데 사용되며, useDispatch를 사용하면 컴포넌트가 상태 변경을 트리거하고 응용 프로그램 내에서 비동기 작업을 관리할 수 있습니다.\n\n우리 애플리케이션에서 useSelector 훅을 사용하는 것은 다음과 같이 보입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst state = useSelector((state:ApplicationState) =\u003e state.users);\n```\n\n매번 ApplicationState를 import하는 것은 조금 귀찮을 수 있습니다. 그래서 대신 전체 애플리케이션에서 사용할 수 있는 사용자 정의 훅을 만드는 것을 선호합니다. 제 사용자 정의 훅은 이렇게 생겼어요:\n\n```js\nexport const useAppSelector: TypedUseSelectorHook\u003cApplicationState\u003e =\n  useSelector;\n```\n\n코드에서 단축키를 만드는 것과 비슷한데요 — 누가 코딩에서 단축키를 좋아하지 않겠어요? 😉\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, 우리 애플리케이션에서 useDispatch 훅을 사용하는 것은 다음과 같습니다:\n\n```js\nconst dispatch = useDispatch\u003cApplicationDispatch\u003e();\n```\n\n또한, 반복적으로 ApplicationDispatch를 다루는 것은 번거로울 수 있습니다. 그래서 여기 내가 만든 커스텀 훅이 어떻게 단순화시키는지 알아봅시다:\n\n```js\nexport const useAppDispatch: () =\u003e ApplicationDispatch = useDispatch;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 사용자 정의 훅을 사용할 수 있게 되었으니, 이제 사용자 목록 페이지 구축에 집중해 보겠습니다. Redux 상태에 접근하기 위한 useAppSelector 및 액션을 디스패치하기 위한 useAppDispatch를 사용하여 원활한 사용자 경험을 만들 준비가 되었습니다. 시작해 봅시다!\n\n```js\nimport React, { useEffect } from 'react';\nimport SearchBox from '../components/SearchBox';\nimport {\n  getTopUsersBySize,\n  getUsersBySearch,\n  toggleUserLike,\n} from '../redux/actions/users/actions';\nimport Loading from '../components/Loading';\nimport Error from '../components/Error';\nimport { NavLink } from 'react-router-dom';\nimport { useAppDispatch, useAppSelector } from '../hooks/hooks';\nimport LikeButton from '../components/LikeButton';\n\nconst Home: React.FC = () =\u003e {\n  const { loading, users, error } = useAppSelector((state) =\u003e state.users);\n  const dispatch = useAppDispatch();\n  const handleSearch = (query: string) =\u003e {\n    if (query) {\n      dispatch(getUsersBySearch(query));\n    } else {\n      dispatch(getTopUsersBySize());\n    }\n  };\n  useEffect(() =\u003e {\n    dispatch(getTopUsersBySize());\n  }, [dispatch]);\n\n  return (\n    \u003cdiv className=\"container mx-auto p-4 flex flex-col\"\u003e\n      \u003cdiv className=\"flex justify-center mb-6\"\u003e\n        \u003cdiv className=\"w-2/3\"\u003e\n          \u003cSearchBox placeholder=\"Search user...\" onSearch={handleSearch} /\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003chr /\u003e\n      \u003ch2 className=\"text-2xl text-blue-700 font-bold my-4\"\u003e\n        Users - {users?.total_count}\n      \u003c/h2\u003e\n      {loading ? (\n        \u003cLoading /\u003e\n      ) : error ? (\n        \u003cError message={error} /\u003e\n      ) : (\n        \u003cdiv\n          className=\"flex-grow  overflow-y-auto\"\n          style={{ maxHeight: 'calc(100vh - 300px)' }}\n        \u003e\n          \u003cul className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6\"\u003e\n            {users?.items.map((user) =\u003e (\n              \u003cli\n                key={user.login}\n                className=\"flex items-center space-x-4 p-4 bg-white rounded shadow hover:shadow-lg transition-shadow\"\n              \u003e\n                \u003cimg\n                  src={user.avatar_url}\n                  alt={`${user.login} avatar`}\n                  className=\"w-16 h-16 rounded-full\"\n                /\u003e\n                \u003cdiv className=\"flex flex-col gap-0.5\"\u003e\n                  \u003cspan className=\"text-lg text-blue-950 font-medium\"\u003e\n                    {user.login}\n                  \u003c/span\u003e\n                  \u003cdiv className=\"flex gap-2\"\u003e\n                    \u003cNavLink\n                      className=\"underline underline-offset-2 text-orange-500 hover:text-orange-600\"\n                      to={`/${user.login}/repos`}\n                    \u003e\n                      View repos\n                    \u003c/NavLink\u003e\n                    \u003cdiv\u003e\n                      \u003cLikeButton\n                        liked={!!user.isLiked}\n                        toggleLike={() =\u003e dispatch(toggleUserLike(user.id))}\n                      /\u003e\n                    \u003c/div\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n              \u003c/li\u003e\n            ))}\n          \u003c/ul\u003e\n        \u003c/div\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\n\nexport default Home;\n```\n\n- 상태 관리: useAppSelector 훅을 사용하여 Redux 상태에 접근하고, 특히 로딩 상태 (loading), 사용자 데이터 (users), 오류 메시지 (error)가 포함된 state.users에 접근합니다.\n- 디스패치 함수: useAppDispatch는 디스패치 함수 dispatch를 얻기 위해 사용되며, 컴포넌트가 getTopUsersBySize, getUsersBySearch, toggleUserLike와 같은 액션을 디스패치할 수 있도록 합니다.\n\n더 많은 라우팅 코드는 제 저장소에서 확인하실 수 있습니다\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 애플리케이션을 실행하면, 위대한 사용자 목록 페이지가 나타납니다! 축하해요, 성공했어요! 🎉 이 코드를 자유롭게 조작하고 도전하여 자체 Repository 페이지를 구현해 보세요. 그리고 기억하세요, 올바른 방향으로 가는 데 조금의 도움이 필요하다면, 우리의 저장소가 도와드릴 준비가 되어 있어요. 지금 바로 들어가서 새로 만든 것을 탐험해 보세요!\n\n제가 긴 글을 썼다는 것을 알고 있어요, 전통적인 Redux 애플리케이션을 설치하는 것은 실제로 시간이 걸릴 수 있습니다 — 이렇게 강력한 라이브러리조차 비판에 직면하기도 했죠. 하지만 걱정하지 마세요! Redux 팀은 이 피드백을 즐겁게 받아들이고 이러한 문제점을 해결하는 주요 업데이트인 Redux Toolkit을 소개했어요. 마치 Redux가 새 옷을 입고 다시 사랑에 빠지는 것 같아요!\n\n당신의 애플리케이션을 Redux Toolkit으로 마이그레이션하는 방법이 궁금하신가요? 계속 주목해 주세요. 더 간단하고 즐거운 상태 관리를 위한 건박스 스!!\n\n코딩 즐기세요!!!","ogImage":{"url":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png"},"coverImage":"/assets/img/2024-06-22-MigratingfromReduxtoReduxToolkitAThree-PartSeries_0.png","tag":["Tech"],"readingTime":23},{"title":"자꾸 사라지지 않는 오래된 습관들  고치기 위한 실질적인 방법들","description":"","date":"2024-06-22 03:15","slug":"2024-06-22-oldhabitsdiesceaming","content":"\n\n![이미지](/assets/img/2024-06-22-oldhabitsdiesceaming_0.png)\n\n정말 잘 되기를 바래요.\n\n과거를 돌아보지 않고 앞으로 나아가 주길 바래요. 다시 돌아가려는 유혹이 너무 압도적이지 않기를 바래요. 이번에는 누군가를 만나서 함께 잘 지내길 진심으로 바래요. 우리의 개인적인 재미있는 얘기들이 지난날의 무덤 속으로 속삭임으로 남길 바라며, 나와는 상관 없는 다른 사람과 나누는 웃음 소리로 대체되길 바라요. 우리의 노래가 너에게서 내 얼굴을 불러보지 않게 된 삶의 배경 속으로 사라지길 바래요. 다시 나를 그리워하지 않기를 바래요.\n\n네게 잘 되기를 원하지 않아요. 쓰러지길 바래요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누군가가 당신 앞에 바리케이드가 되어 차들이 경적을 울릴 때, 후방을 보기 위해 브레이크를 밟는다면 좋겠어요. 당신이 나를 남겨둔 자리를 여전히 후방 거울에 보고 싶어할 거라고 기대해요. 230km/h로 가속하고 U턴을 하려다가 실수로 차를 충돌시키고 자신을 파멸로 몰아넣을 거라고 기대해요. 누군가를 만나 어딘가로 데려가다가 갑자기 우리의 꿈 속에 엮인 비극적인 노래가 흘러나온다면 정말 좋겠어요. 그 노래 가사를 알지 못했으면 좋겠고, 그 순간 당신이 나를 그리워할 거라고 기대해요.\n\n당신이 아직도 내가 그리워지지 않는다는 걸 이해하지 못해서 그렇습니다.","ogImage":{"url":"/assets/img/2024-06-22-oldhabitsdiesceaming_0.png"},"coverImage":"/assets/img/2024-06-22-oldhabitsdiesceaming_0.png","tag":["Tech"],"readingTime":1},{"title":"Angular에서 DOCUMENT를 사용해야 하는 이유","description":"","date":"2024-06-22 03:14","slug":"2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular","content":"\n\n\n![image](/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png)\n\nDOCUMENT은 Angular에서 제공하는 의존성 주입 토큰으로, 문서 객체 모델(DOM)을 나타내는 주요 렌더링 컨텍스트를 나타냅니다. DOCUMENT 토큰은 @angular/common 패키지에서 import됩니다. 문서 객체 모델(DOM)은 웹 페이지를 스크립트나 프로그래밍 언어와 연결해주는 역할을 합니다. 일반적으로 JavaScript를 참조하지만, HTML, SVG 또는 XML 문서를 객체로 모델링하는 것은 JavaScript 언어의 핵심 부분은 아닙니다. DOCUMENT와 document 객체 모두 DOM에 액세스할 수 있지만, Angular 애플리케이션에서 전역 document 객체 대신 DOCUMENT를 사용하는 것에는 장점이 있습니다. 먼저, Angular 애플리케이션에서 DOCUMENT와 document를 사용하는 한 가지 사례를 살펴보겠습니다.\n\n다음 예제는 HTML 템플릿의 섹션을 보고자 할 때 document를 사용하는 방법을 보여줍니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n})\nexport class MyComponent implements OnInit {\n  constructor() {}\n  ngOnInit(): void {\n    const myButton = document.getElementById('myButton');\n    myButton.addEventListener('click', () =\u003e {\n      const targetElement = document.getElementById('targetElement');\n      targetElement.scrollIntoView({ behavior: 'smooth' });\n    });\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 예제는 이전 기능에 DOCUMENT를 사용하는 방법을 보여줍니다.\n\n```js\nimport { Component, Inject, OnInit } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n})\nexport class MyComponent implements OnInit {\n  constructor(@Inject(DOCUMENT) private document: Document) {}\n  ngOnInit(): void {\n    const myButton = this.document.getElementById('myButton');\n    myButton.addEventListener('click', () =\u003e {\n      const targetElement = this.document.getElementById('targetElement');\n      targetElement.scrollIntoView({ behavior: 'smooth' });\n    });\n  }\n}\n```\n\n위 예제에서는 DOCUMENT 서비스를 주입하고 Document 객체의 메서드와 속성에 액세스합니다. 두 구현은 거의 유사해 보이지만 DOCUMENT 주입 토큰을 사용하는 이점을 살펴보겠습니다.\n\n- 플랫폼에 독립적: DOCUMENT 토큰은 플랫폼에 독립적이므로 전역 document 객체가 사용할 수 없는 서버 측 렌더링 (SSR) 시나리오에서 사용할 수 있습니다. SSR을 사용할 때 document는 Domino에 의해 생성됩니다.\n- 의존성 주입: DOCUMENT 토큰은 Angular의 의존성 주입으로 주입될 수 있습니다. 이를 통해 컴포넌트를 전역 범위에서 분리함으로써 더 나은 코드 구성, 테스트 가능성, 유지 관리성이 증진됩니다.\n- 타입 안전성: DOCUMENT 토큰은 타입 정의를 제공하여 IDE에서 더 나은 타입 안전성과 코드 완성을 가능하게 합니다.\n- Angular zone 인식: Angular의 DOCUMENT는 Angular의 zone.js 라이브러리를 인식하고 변경 감지 메커니즘과 원활하게 통합됩니다. 이를 통해 Angular 컴포넌트에 의해 트리거된 DOM 업데이트가 올바르게 감지되고 처리되며, 변경 감지로 인한 발생할 수 있는 문제를 방지하여 일관된 사용자 경험을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전역 문서는 특정 시나리오에 적합할 수 있지만 Angular의 DOCUMENT 토큰은 플랫폼 중립성, 의존성 주입, 유형 안전성 및 Angular 특정 기능 측면에서 여러 가지 장점을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-WhyyoushoulduseDOCUMENTandnotdocumentinAngular_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular에서 Enum 파워 유저 되는 방법","description":"","date":"2024-06-22 03:13","slug":"2024-06-22-BeaPowerUserofEnumsinAngular","content":"\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 Enums\n\nAngular의 Enums은 기본적으로 숫자형입니다:\n\n```js\n// colors.enum.ts\n\nexport enum Color {\n  Blue,  // 0\n  Green, // 1\n  Red    // 2\n}\n```\n\n문자열 Enums도 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport enum TimeZone {\n  EasternTime = 'Eastern Time',\n  CentralTime = 'Central Time',\n  MountainTime = 'Mountain Time',\n  PacificTime = 'Pacific Time',\n  AlaskaTime = 'Alaska Time',\n  HawaiiAleutianTime = 'Hawaii-Aleutian Time'\n}\n```\n\n지금 필요에 따라 사용하면 됩니다.\n\n# HTML에서의 Enum\n\nEnum을 가지고 있으면 관련 데이터를 표현하는데 어디서든 사용하고 싶어질 것입니다. 그러나 Angular에서, HTML 코드에서 enum을 사용하는 것은 생각한 것만큼 간단하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 코드\n\n```js\n// colors.model.ts\n\nimport { Color } from 'colors.enum.ts';\n\nexport interface ColorsViewModel {\n  Color: typeof Color;\n  colors: Color[];\n  formGroup: FormGroup;\n}\n```\n\n```js\n// colors-example.component.ts\n\nimport { Color } from 'colors.enum.ts';\nimport { ColorsViewModel } from 'colors.model.ts';\n\n@Component({\n  selector: 'colors-example',\n  styleUrls: ['colors-example.component.scss'],\n  templateUrl: 'colors-example.component.html'\n})\nexport class ColorsExampleComponent implements OnInit {\n  @Input({ required: true }) public color: Color;\n\n  public vm: ColorsViewModel;\n\n  public ngOnInit(): void {\n    this.vm = {\n      Color,\n      colors: Object.values(Color),\n      formGroup: this.createFormGroup();\n  }\n\n  private createFormGroup(): FormGroup {\n    return new FormGroup({\n      colorOption: new FormControl\u003cColor\u003e(Color.Green)\n    });\n  }\n}\n```\n\n```js\n\u003c!-- colors-example.component.html --\u003e\n\n\u003cdiv *ngIf=\"vm\"\u003e\n  \u003cng-container [ngSwitch]=\"color\"\u003e\n    \u003cng-container *ngSwitchCase=\"vm.Color.Blue\"\u003e\n      \u003cp style=\"color: blue\"\u003e파란색\u003c/p\u003e\n    \u003c/ng-container\u003e\n    \u003cng-container *ngSwitchCase=\"vm.Color.Greed\"\u003e\n      \u003cp style=\"color: green\"\u003e초록색\u003c/p\u003e\n    \u003c/ng-container\u003e\n    \u003cng-container *ngSwitchCase=\"vm.Color.Red\"\u003e\n      \u003cp style=\"color: red\"\u003e빨간색\u003c/p\u003e\n    \u003c/ng-container\u003e\n  \u003c/ng-container\u003e\n\n  \u003cp *ngIf=\"color === vm.Color.Red\"\u003e대단해요!\u003c/p\u003e\n\n  \u003cform [formGroup]=\"vm.formGroup\"\u003e\n    \u003cmat-form-field\u003e\n      \u003cmat-label\u003e색상을 선택하세요\u003c/mat-label\u003e\n      \u003cmat-select formControlName=\"colorOption\"\u003e\n        \u003cmat-option *ngFor=\"let color of vm.colors\" [value]=\"color\"\u003e\n          { color }\n        \u003c/mat-option\u003e\n      \u003c/mat-select\u003e\n    \u003c/mat-form-field\u003e\n  \u003c/form\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 설명\n\n여기서는 Color enum을 HTML에서 세 가지 다른 방법으로 사용하는 방법을 보여줍니다.\n1. ngSwitch에서\n2. === 비교에서\n3. select/dropdown에서\n\nColor enum의 실제 값들을 참조하여 enum을 사용합니다. 그러기 위해 colors.model.ts에서 Color: typeof Color라는 중요한 코드가 있습니다. 이 코드는 enum을 뷰 모델 개체에 추가하여 *ngIf=\"color === 2와 같은 것을 코딩하지 않고도 HTML에서 참조할 수 있도록 합니다.\n\n그리고 dropdown에서는 Object.values(Color);를 사용하여 mat-select 옵션을 재입력할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n탁월하네요, 맞죠?\n\n# TypeScript에서 Enum 사용하기\n\nTypeScript에서 Enum을 사용하여 비교하는 것은 매우 간단합니다.\n\n```js\nif (this.color === Color.Blue) {\n  console.log('바다를 좋아하나요?');\n}\n\nswitch(this.color) {\n  case Color.Blue:\n    console.log('바다를 좋아하나요?');\n    break;\n  case Color.Green:\n    console.log('잔디를 좋아하나요?');\n    break;\n  case Color.Red:\n    console.log('일출을 좋아하나요?');\n    break;\n  default:\n    console.log('기본 색상이 아닙니다.');\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 열거형(enum)에서 모든 값을 사용하고 싶지 않을 때는 어떻게 해야 할까요?\n\n색상 열거형(enum)을 변경하고 확장해 봅시다:\n\n```js\n// colors.enum.ts\n\nexport enum Color {\n  Black,\n  Blue,\n  Brown,\n  Green,\n  Indigo,\n  Orange,\n  Red,\n  Yellow,\n  Violet\n}\n```\n\n이제 색상을 서버로 전달하여 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst coloredShoes: Shoes[] = await this.colorService\n  .getShoesOfColor(this.vm.formGroup.get('colorOption'));\n```\n\n이제, 모든 색상을 사용하고 싶다고 상상해 봅시다:\n\n```js\nconst allShoes: Shoes[] = await this.colorService\n  .getShoesOfColor(Object.values(Color));\n```\n\n하지만 만약 일부 색상만 사용하고 싶다면 어떻게 해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 할 수 있어요:\n\n```js\nconst rainbowShoes: Shoes[] = await this.colorService\n  .getShoesOfColor([\n     Color.Red,\n     Color.Orange,\n     Color.Yellow,\n     Color.Green,\n     Color.Blue,\n     Color.Indigo,\n     Color.Violet\n   ]);\n```\n\n하지만 만약 16개 색상, 64개 색상 또는 256개 색상이 있는 Color enum이 있다면 어떻게 될까요? 아이디어를 이해하셨죠. 경우에 따라서는 원하는 enum 값이 아닌 것을 지정하는 것이 더 쉬울 수 있습니다. 하지만 \"파란색 계통이 아닌 모든 신발\"과 같은 것을 어떻게 지정할 수 있을까요? Enum은 Object.values(Color).not([Color.Blue, Color.Indigo]);와 같이 쉬운 방법을 제공하지 않습니다.\n\nTypeScript 제네릭이 해결책을 제공합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/**\n * 주어진 enum 및 허용되지 않는 값에 따라 enum 값을 포함하는 배열을 반환합니다.\n *\n * @param myEnum enum의 이름입니다.\n * @param disallowedValues 반환되지 말아야할 myEnum 값들의 배열입니다.\n *\n * @return 허용되지 않는 값들을 제외한 모든 myEnum 값들의 배열입니다.\n */\nexport const numericEnumFilterOut: Function =\n  \u003cR extends number,\n   T extends {[key: string]: R}\u003e(myEnum: T, disallowedValues: R[]): R[] =\u003e\n    Object.entries(myEnum)\n      .filter((type: [string, string | R]): boolean =\u003e\n        typeof type[1] === 'number' \u0026\u0026 !disallowedValues.includes(type[1]))\n      .map((type: [string, R]): [string, R] =\u003e type as [string, R])\n      .map(([, value]: [string, R]): R =\u003e value);\n```\n\n## 사용법\n\n```js\nconst noBlue: Color[] =\n  numericEnumFilterOut(Color, [Color.Blue, Color.Indigo]);\n\n// noBlue = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Violet]\n```\n\n이제 다음과 같이 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n상수 비파란신: Shoes[] = await this.colorService\n  .getShoesOfColor(numericEnumFilterOut(Color, [Color.Blue, Color.Indigo]));\n```\n\n# 결론\n\nEnum은 깔끔한 코드를 작성하는 데 매우 강력한 도구입니다. TypeScript와 HTML 모두에서 사용하는 방법이 많습니다. 코딩할 때 강력한 무기가 될 수 있습니다. 즐거운 코딩하세요!\n\n# 간단히 말하면 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인 플레인 잉글리쉬 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: 스타카데믹 | 코피드 | 벤처 | 큐브드\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-22-BeaPowerUserofEnumsinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-BeaPowerUserofEnumsinAngular_0.png","tag":["Tech"],"readingTime":6},{"title":"기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular","description":"","date":"2024-06-22 03:12","slug":"2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform","content":"\n\nAngular 14+에서 우리는 기다리던 바대로 반응형 폼에 타입을 지정할 수 있는 기회를 얻었습니다. 문제는 폼 자체에 대한 특정 모델을 만들어야 하므로, 앱이 더 복잡한 객체를 사용할 때 폼 타입이 약간 더 복잡하고 유지하기 어려워진다는 점입니다.\n\n![이미지](/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png)\n\n간단한 모델이 있는 경우에는 어느 정도 쉽게 이해됩니다. 이런 식으로 User 인터페이스를 가진 경우를 살펴봅시다:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 인터페이스를 기반으로 강력한 유형화된 반응형 폼을 만들려면, 폼 컨트롤을 보유할 미러 모델이 필요합니다:\n\n```js\nexport interface UserForm {\n    id: FormControl\u003cnumber\u003e;\n    name: FormControl\u003cstring\u003e;\n}\n```\n\n그리고 많은 모델을 가지고 있을 때, 이 방법은 꽤 지루하고 시간이 많이 걸릴 수 있어요.\n\n## 모델을 복제하는 것은 해결책이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypescript의 힘을 이용해서, 우리는 인터페이스를 래핑할 타입을 만들 것이고, 이를 통해 프로젝트에서 모델 중복을 피할 수 있습니다.\n\n시작해봅시다!\n\n우리의 타입은 Generics을 사용하여 어떤 종류의 인터페이스든 받을 수 있어야 하며, 이를 FormGroup으로 변환하고 모든 속성을 FormControl로 변환해야 합니다.\n\n```js\nexport type ToFormType\u003cT\u003e = FormGroup\u003c{\n    [K in keyof T]: FormControl\u003cT[K] | null\u003e;\n}\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쉽죠? 이제 우리가 하는 일 인터페이스 T를 감싸는 슈퍼 타입을 만들어요. 이 슈퍼 타입은 FormGroup으로 변환하고 각 속성은 FormControl으로 변환하죠.\n\n사용법:\n\n```js\npublic myForm: ToFormType\u003cUser\u003e;\n\n...\n\nmyForm = this.fb.group(...);\n```\n\n기다려 주세요! 아직 끝나지 않았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 유저 인터페이스에 작은 변경사항을 가해보도록 하죠:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n```\n\n음... 이전 유형에서 오류가 발생했네요.\n\n```js\n'Type 'FormGroup\u003c{…}\u003e' is not assignable to type 'ToFormType\u003cUser\u003e'.\nTypes of property 'controls' are incompatible.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 했어요… FormControl과 FormGroup을 처리할 수 있도록 유형을 업데이트해야 해요.\n\n다음과 같이 시도해 봅시다:\n\n```js\nexport type ToFormType\u003cT\u003e = FormGroup\u003c{\n    [K in keyof T]: T[K] extends object\n        ? ToFormType\u003cT[K]\u003e\n        : FormControl\u003cT[K] | null\u003e;\n}\u003e;\n```\n\n작동하는 것으로 보이네요. 중첩된 객체가 있는 경우에도 처리할 수 있어요. 하지만, 한 가지 문제가 있어요: 만약 User에 birthDate 속성이 있다면 어떻게 될까요? Date는 object를 확장한다네요… 안타깝지만요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 있는 내용을 친한 톤으로 한국어로 번역해 드리겠습니다:\n\n말씀하신 대로, 쉽게 코드를 업데이트하여 작동시킬 수 있습니다:\n\n```js\nexport type ToFormType\u003cT\u003e = FormGroup\u003c{\n    [K in keyof T]: T[K] extends object\n        ? T[K] extends Date\n            ? FormControl\u003cT[K] | null\u003e\n            : ToFormType\u003cT[K]\u003e\n        : FormControl\u003cT[K] | null\u003e;\n}\u003e;\r\n```\n\n조금은 섬세하지 않지만, 대부분의 경우에는 작동할 것입니다.\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n    hobbies: Hobby[];\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n\nexport interface Hobby {\n    name: string;\n    description: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 번역됩니다:\n\n```js\n'Type 'FormGroup\u003c{…}\u003e'은(는) 'ToFormType\u003cUser\u003e' 유형에 할당할 수 없습니다. 'controls' 속성의 유형이 호환되지 않습니다.\n```\n\n익숙하신가요? 어떻게 해야 할 지 알겠어요! 다시 한번 형식을 발전시켜 봅시다!\n\n이렇게 하고 싶은 유혹을 느낄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nT[K]이 배열을 확장한다면 FormArray\u003cToFormType\u003cT[K]\u003e\u003e으로 ....를 설정합니다.\n\n그러나 이 방법은 작동하지 않을 것입니다. 이유는 타입이 일치하지 않기 때문입니다. \n\n이를 피하기 위해서는 배열로부터 타입을 « 추출 » 할 때 infer를 사용해야 합니다. (자세한 내용은 https://blog.logrocket.com/understanding-infer-typescript/에서 확인할 수 있습니다):\n\nexport type ToFormType\u003cT\u003e = FormGroup\u003c{\n    [K in keyof T]: T[K]이 객체를 확장한다면\n        ? T[K]이 날짜인 경우\n            ? FormControl\u003cT[K] | null\u003e\n            : T[K]이 알 수 없는 배열인 경우\n                ? FormArray\u003cToFormType\u003cT[K] extends (infer V)[] ? V : T[K]\u003e\u003e\n                : ToFormType\u003cT[K]\u003e\n        : FormControl\u003cT[K] | null\u003e;\n}\u003e;\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리에게 대부분의 인터페이스를 강력하게 입력 형식화된 반응 형식으로 변환할 수 있는 타입이 생겼어요!\n\n폼 내부에서 인터페이스를 풍부하게 제공하거나 부분적으로 사용하려면 Typescript의 Pick, Required, Intersection, Omit과 같은 기능을 활용할 수도 있어요. 예를 들면:\nToFormType\u003cPick\u003cUser, 'id' | 'name' \u003e\u003e;\n// OR\nToFormType\u003cUser \u0026 { birthDate: Date }\u003e;\n\n그리고 모든 사용 사례에 대해 중복으로 정의하지 않고 단일 인터페이스를 사용할 수 있어요:)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고 자료\n\n- [Typescript 공식 문서: 제네릭](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n- [TypeScript의 infer 키워드 이해하기](https://blog.logrocket.com/understanding-infer-typescript/)\n- [Typescript 공식 문서: 유틸리티 타입 - `Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)\n- [Typescript 공식 문서: 병합과 교차 타입](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)\n\n지금까지였습니다! 즐겁게 보셨길 바라요!\n\n이와 같은 글을 계속해서 놓치고 싶지 않다면, 저희를 팔로우해주시면 감사하겠습니다 :)","ogImage":{"url":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png"},"coverImage":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png","tag":["Tech"],"readingTime":5}],"page":"25","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"25"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>