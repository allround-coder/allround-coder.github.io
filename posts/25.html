<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/25" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/25" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법" href="/post/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="풀스택 NET 개발자 면접 대비 질문 목록" href="/post/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="풀스택 NET 개발자 면접 대비 질문 목록" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="풀스택 NET 개발자 면접 대비 질문 목록" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">풀스택 NET 개발자 면접 대비 질문 목록</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 프로젝트에서 React 컴포넌트 사용하는 방법" href="/post/2024-06-22-UseReactComponentInsideAngularProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 프로젝트에서 React 컴포넌트 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 프로젝트에서 React 컴포넌트 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 프로젝트에서 React 컴포넌트 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법" href="/post/2024-06-22-TemplateDrivenForminAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TemplateDrivenForminAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기" href="/post/2024-06-22-AngularAnimationsTutorialRouteTransitions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아답터 디자인 패턴을 Angular에서 사용하는 방법" href="/post/2024-06-22-DesignPatternsAdapterinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아답터 디자인 패턴을 Angular에서 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DesignPatternsAdapterinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아답터 디자인 패턴을 Angular에서 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아답터 디자인 패턴을 Angular에서 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" href="/post/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" href="/post/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" href="/post/2024-06-22-SettingupanExpressTypescriptServerwithVueVite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Express  Typescript 서버에서 Vue  Vite 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Express  Typescript 서버에서 Vue  Vite 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" href="/post/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link posts_-active__YVJEi" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular와 NET Core로 Google 캘린더에 이벤트 동기화하는 방법","description":"","date":"2024-06-22 03:36","slug":"2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png\" /\u003e\n\n이 기사에서는 앵귤러를 프론트엔드로 사용하고 백엔드 프로그래밍 언어로 닷넷 코어를 사용하여 우리 애플리케이션의 이벤트를 구글 캘린더에 동기화하는 방법을 단계별로 설명합니다.\n\n# 단계 1: 구글 콘솔 OAuth 2.0 클라이언트 ID 설정\n\n- 구글 콘솔로 이동하여 구글 계정으로 로그인합니다.\n- 새 프로젝트를 만들고 이름을 지정합니다.\n- APIs 및 서비스로 이동하고 Google 캘린더 API를 활성화합니다.\n- 다음으로 OAuth 동의 화면으로 이동합니다.\n- 여기에 처음 왔고 OAuth 동의 화면이 아직 구성되지 않았다면, OAuth 동의 화면을 구성하도록 강제하며 정보를 입력하고 다음 스코프 탭으로 이동합니다.\n- 스코프 추가 및 제거 버튼을 클릭하여 스코프 목록에서 \".../auth/calendar.events\" 스코프를 선택합니다.\n- 다음 단계에서는 테스트용 구글 사용자 ID를 입력합니다 (이것들은 캘린더 이벤트를 동기화 할 클라이언트의 구글 이메일 ID입니다).\n- 자격 증명으로 이동하여 자격 증명 만들기 링크를 클릭하고 OAuth 클라이언트 ID를 선택합니다.\n- 애플리케이션 유형을 웹 애플리케이션으로 설정합니다.\n- 다음 설정에서 승인된 Javascript 원본 (구글에 로그인 할 웹 애플리케이션 도메인 링크 예: http://www.example.com 또는 http://localhost:4200) 및 승인된 리디렉션 URI (구글이 로그인 후 우리 애플리케이션으로 리디렉션 할 링크 예: http://www.example.com/google-login 또는 http://localhost:4200/google-login)를 입력합니다.\n- 생성 후, 앵귤러 애플리케이션에서 사용할 클라이언트 ID를 복사하여 구글에 로그인하고 로그인 한 후 구글에서 액세스 토큰을 가져올 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_1.png\" /\u003e\n\n# 단계 2: Angular 애플리케이션 부분\n\n- 이 부분에서는 Google에 로그인하여 유효한 액세스 토큰을 받아 dot net core 웹 API 백엔드 서비스로 보낼 것입니다.\n- 위의 기능을 통합할 준비가 된 Angular 프로젝트를 가정합니다.\n- 패키지 \"angular-oauth2-oidc\"를 설치합니다.\n- npm i angular-oauth2-oidc를 실행합니다.\n- Google에 로그인하기 위해 새로운 컴포넌트(예: google-login)를 생성합니다.\n- 그 다음에 angular-oauth2-oidc에서 새로 생성한 컴포넌트로 라이브러리를 가져옵니다.\n\n```js\nimport { AuthConfig, OAuthService } from 'angular-oauth2-oidc';\n\nconstructor(private readonly oAuthService: OAuthService) {\n    this.signIntoGoogle(); // 클라이언트 측에 저장된 Google 인증 토큰을 확인하고, 없다면 Google 로그인 페이지로 리디렉션합니다.\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 클라이언트 ID를 사용하는 코드입니다.\n\n```js\n signIntoGoogle() {\n\n        const oAuthConfig: AuthConfig = {\n          issuer: 'https://accounts.google.com',\n          strictDiscoveryDocumentValidation: false,\n          redirectUri: window.location.origin + '/google-login', // Google에서 인증 후 리디렉션할 URL\n          clientId: your-client-id, //(Google 콘솔 OAuth2 클라이언트 ID)\n          scope: 'https://www.googleapis.com/auth/calendar'\n        }\n\n        this.oAuthService.configure(oAuthConfig)        \n\n        this.oAuthService.loadDiscoveryDocument().then(() =\u003e {\n          this.oAuthService.tryLoginImplicitFlow().then(() =\u003e {\n            if (!this.oAuthService.hasValidAccessToken()) { // 토큰이 유효한지 확인\n              this.oAuthService.initLoginFlow() // 로그인이 되어 있지 않다면 Google 로그인 페이지로 이동\n              console.log('Google에 로그인 중...') \n            } else {\n              console.log('Google에 로그인됨') \n              this.syncEvents(); // 이미 로그인되어 있다면 syncEvents 메서드 호출\n            }\n          },\n            (err) =\u003e {\n                console.log(\"액세스 거부, 다시 시도해 주세요!\") \n            })\n        })      \n  }\n\n syncEvents() {\n    if (this.syncing) {\n      return;\n    }\n\n    if (!this.oAuthService.hasValidAccessToken()) {\n      this.router.navigate(['/google-login']) \n      return; // 로그인되어 있지 않거나 유효한 액세스 토큰을 찾지 못했을 때\n    }\n\n    let scopes = this.oAuthService.getGrantedScopes() as Array\u003cstring\u003e;\n\n    if (!scopes.includes(\"https://www.googleapis.com/auth/calendar\")) {\n      console.log(\"액세스 거부, 다시 시도해 주세요!\")\n      this.oAuthService.logOut();\n      this.syncing = false;\n      return;\n    }\n\n    this.syncing = true;\n    console.log(\"동기화 중, 잠시 기다려 주세요...!\")\n\n    const token = {\n      accessToken: this.oAuthService.getAccessToken()\n    }\n    \n    // 데이터베이스에서 Google 캘린더로 약속, 이벤트 등을 동기화하도록 .NET Core 백엔드 웹 API 엔드포인트 호출\n    this.http.post(env.API_ENDPOINT + 'api/googlecal/sync-events', token, {\n    }).subscribe((response: any) =\u003e {\n      console.log(\"이벤트가 성공적으로 동기화되었습니다!\")\n      this.syncing = false;\n    }, err =\u003e {\n      console.log(err);\n      this.syncing = false;\n    });\n  }\n```\n\n7. 위 코드는 브라우저에 유효한 인증 토큰이 있는지 확인하고, 그렇지 않다면 Google에서 로그인 플로우를 시작합니다. Google에 성공적으로 로그인하면 Google이 Authorized Redirect Uris에서 정의한 유효한 URL로 리디렉트되고, 유효한 인증 토큰이 브라우저에 저장됩니다.\n\n8. 다음으로 해당 토큰이 .NET Core 백엔드 웹 API로 전송되어 동기화(약속, 이벤트 등을 애플리케이션에서 Google 캘린더로 동기화)가 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: Dotnet Core WebAPI 부분\n\n- 여기서는 Angular 애플리케이션에서 게시된 유효한 액세스 토큰을 사용하여 Google 서비스를 생성하고 Google 기본 캘린더에 이벤트를 만드는 방법을 알아봅니다.\n- NuGet에서 두 개의 패키지가 필요합니다.\n- dotnet add package Google.Apis.Auth.AspNetCore3 — 버전 1.68.0\n- dotnet add package Google.Apis.Calendar.v3 — 버전 1.68.0.3430\n- 다음과 같이 컨트롤러에서 패키지를 가져옵니다.\n\n```js\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Google.Apis.Auth.OAuth2;\nusing Google.Apis.Calendar.v3;\nusing Google.Apis.Calendar.v3.Data;\nusing Google.Apis.Services;\nusing Google.Apis.Util.Store;\n\nusing Google.Apis.Auth.AspNetCore3;\nusing Google.Apis.Auth.OAuth2.Responses;\n\nnamespace ngCommon.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class GoogleCalController : ControllerBase\n    {\n        static string calendarId = \"primary\";\n\n        [HttpPost, Route(\"sync-events\")]\n        public IActionResult CreateEventsToGoogleCalendar([FromBody] TokenResponse accessToken)\n        {\n            CalendarService _service = GetCalenderServiceFromAccessToken(accessToken.AccessToken);\n\n            // 데이터베이스에서 객체 변수를 가져와 이벤트를 생성합니다.\n            this.CreateCalenderEvent(_service, appointment); // 여러분의 애플리케이션 개체 변수\n\n            // 이미 만들어진 캘린더 이벤트 가져오기\n            List\u003cEvent\u003e listEvents = this.GetCalenderEvents(_service);\n\n            // 캘린더 이벤트를 반복하고 특정 이벤트를 업데이트합니다.\n            foreach (var event1 in listEvents)\n            {\n                this.UpdateCalenderEvent(_service, event1, appointment); // 여러분의 애플리케이션 개체 변수\n            }\n            // 여러분의 애플리케이션과 관련된 삭제된 이벤트 ID\n            var deletedApntIds = listEvents.Where(p =\u003e !appointments.Select(o =\u003e o.Id.ToString()).ToArray().Contains(p.ExtendedProperties.Private__.Where(k =\u003e k.Key == \"appointmentId\").FirstOrDefault().Value)).Select(p =\u003e p.Id).ToList(); \n            // 삭제된 ID를 반복하고 Google 캘린더에서 삭제합니다.\n            foreach (var eventId in deletedApntIds)\n            {\n                this.DeleteCalenderEvent(_service, eventId);\n            }\n\n            return Ok(new { result = true });\n        }\n\n\n        private CalendarService GetCalenderServiceFromAccessToken(string accessToken)\n        {\n            GoogleCredential credential;\n            credential = GoogleCredential.FromAccessToken(accessToken);\n\n            // Google 캘린더 API 서비스 생성\n            var service = new CalendarService(new BaseClientService.Initializer\n            {\n                HttpClientInitializer = credential,\n                ApplicationName = \"application name\"\n            });\n\n            return service;\n        }\n\n        private void CreateCalenderEvent(CalendarService _service, Models.Appointment appointment)\n        {\n            DateTime newDate = new DateTime();\n            Event body = new Event();\n\n            EventDateTime start = new EventDateTime();\n            start.DateTime = newDate; // 날짜와 시간\n\n            EventDateTime end = new EventDateTime();\n            end.DateTime = newDate;  // 날짜와 시간\n\n            body.Start = start;\n            body.End = end;\n            body.Summary = \"summary\"; // 이벤트의 표시 이름\n            body.Description = \"some description\";\n\n            body.ExtendedProperties = new Event.ExtendedPropertiesData()\n            {\n                Private__ = new Dictionary\u003cstring, string\u003e()\n                {\n                    {\"origin\",\"web\"},\n                    {  \"appointmentId\",    \"some-text\" },\n                    {   \"date\", \"some-text\" },\n                    {   \"time\", \"some-text\"},\n                    { \"patientId\", \"some-text\"}\n                    // 이러한 키-값 쌍을 사용하여 본인의 애플리케이션 관련 데이터를 삽입할 수 있습니다\n                }\n            };\n\n            try\n            {\n                EventsResource.InsertRequest request = new EventsResource.InsertRequest(_service, body, calendarId);\n                Event response = request.Execute();\n            }\n            catch (System.Exception ex)\n            {\n                throw;\n            }\n\n        }\n\n        private List\u003cEvent\u003e GetCalenderEvents(CalendarService _service)\n        {\n            DateTime dt1 = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 0, 0, 0);\n\n            var newDate = new DateTimeOffset(dt1, this.GetTimeZoneInfo().GetUtcOffset(dt1));\n\n            // 요청 매개변수 정의\n            EventsResource.ListRequest request = _service.Events.List(calendarId);\n            request.TimeMin = newDate.LocalDateTime;\n            request.ShowDeleted = false;\n            request.SingleEvents = true;\n            // request.MaxResults = 10;\n            request.OrderBy = EventsResource.ListRequest.OrderByEnum.StartTime;\n\n            // 이벤트 목록\n            Events events = request.Execute();\n            return events.Items.Where(p =\u003e p.ExtendedProperties != null \u0026\u0026 p.ExtendedProperties.Private__ != null \u0026\u0026\n                    p.ExtendedProperties.Private__.Where(p =\u003e p.Key == \"origin\").FirstOrDefault().Value == \"web\").Select(p =\u003e p).ToList();\n\n        }\n\n        private void UpdateCalenderEvent(CalendarService _service, Event event1, Models.Appointment appointment)\n        {\n            DateTime dt1 = new DateTime(appointment.Date.Year, appointment.Date.Month, appointment.Date.Day,\n            appointment.Time.Hours, appointment.Time.Minutes, appointment.Time.Seconds);\n\n            var newDate = new DateTimeOffset(dt1, this.GetTimeZoneInfo().GetUtcOffset(dt1));\n\n            EventDateTime start = new EventDateTime();\n            start.DateTime = newDate.LocalDateTime;\n\n            EventDateTime end = new EventDateTime();\n            end.DateTime = newDate.LocalDateTime;\n\n            event1.Start = start;\n            event1.End = end;\n\n            event1.ExtendedProperties = new Event.ExtendedPropertiesData()\n            {\n                Private__ = new Dictionary\u003cstring, string\u003e()\n                {\n                    { \"origin\",\"web\"},\n                    { \"appointmentId\",    appointment.Id.ToString() },\n                    { \"date\", appointment.Date.ToShortDateString() },\n                    { \"time\", appointment.Time.ToString()},\n                    { \"patientId\", appointment.Patient.Id.ToString()}\n                }\n            };\n\n            EventsResource.UpdateRequest request = new EventsResource.UpdateRequest(_service, event1, calendarId, event1.Id);\n            Event response = request.Execute();\n        }\n\n        private bool DeleteCalenderEvent(CalendarService _service, string eventId)\n        {\n            EventsResource.DeleteRequest request = new EventsResource.DeleteRequest(_service, calendarId, eventId);\n            string response = request.Execute();\n            return true;\n        }\n    }\n}\n```\n\n6. 이러한 위의 메서드를 사용하여 Google 캘린더에서 이벤트를 생성, 나열, 업데이트 및 삭제할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 캘린더 이벤트를 생성할 때, \"Events.ExtendedProperties\"를 사용하여 애플리케이션과 관련된 정보를 저장하고, 이전에 설정한 \"ExtendedProperties\"를 기반으로 이벤트를 검색하여 애플리케이션을 통해 생성된 이벤트만 반환받을 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png"},"coverImage":"/assets/img/2024-06-22-SynceventstoGooglecalendarusingangularanddotnetcore_0.png","tag":["Tech"],"readingTime":12},{"title":"풀스택 NET 개발자 면접 대비 질문 목록","description":"","date":"2024-06-22 03:35","slug":"2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png\" /\u003e\n\n풀 스택 개발자로서, 인터뷰어들은 다양한 기술에 관해 물을 수 있습니다. 그러나 나는 .NET, Angular, C#, SQL Server 및 Azure와 같은 주요 분야에 초점을 맞출 것입니다. 또한 MongoDB, 마이크로서비스 아키텍처, Docker 및 Kubernetes와 같은 보조 기술에 대한 질문에 대비할 필요가 있습니다.\n\nC# 및 .NET Framework/Core:\n\n- .NET Framework와 .NET (Core)의 차이점에 대해 설명해보세요.\n- C#을 사용하는 이점은 무엇인가요?\n- C#에서 다양한 컬렉션 유형과 사용 사례에 대해 설명해보세요.\n- .NET에서의 가비지 컬렉션에 대해 설명하고 작동 방식을 설명해보세요.\n- C# 애플리케이션에서 예외 처리를 어떻게 처리하나요?\n- C#에서 async/await 키워드는 어떻게 사용되나요?\n- 의존성 주입(Dependency Injection, DI)과 그 이점에 대해 설명해보세요.\n- C#에서 다양한 상속 유형에 대해 토론해보세요.\n- .NET 프로젝트에서 단위 테스트를 어떻게 구현하나요?\n- .NET 개발에서 일반적으로 사용되는 일부 디자인 패턴은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nASP.NET Core MVC/Web API:\n\n- ASP.NET Core에서 Model-View-Controller (MVC) 패턴을 설명해드릴게요.\n- ASP.NET Core MVC와 Web API의 차이점은 무엇인가요?\n- ASP.NET Core 애플리케이션에서 라우팅을 어떻게 처리하나요?\n- ASP.NET Core의 미들웨어와 기능에 대해 설명해드릴게요.\n- ASP.NET Core에서 인증과 권한 부여를 구현하는 다양한 방법에 대해 논의해볼까요?\n- ASP.NET Core에서 CORS(Cross-Origin Resource Sharing)를 구성하는 방법은 무엇인가요?\n- ASP.NET Core MVC에서 모델 바인딩과 유효성 검사를 설명해드릴게요.\n- ASP.NET Core 애플리케이션에서 캐싱을 구현하는 방법에 대해 알려드릴게요.\n- ASP.NET Core 애플리케이션의 성능을 향상시키기 위한 몇 가지 모범 사례는 무엇인가요?\n- ASP.NET Core에서 제공되는 로깅 메커니즘에 대해 논의해볼까요?\n\n데이터베이스(SQL Server):\n\n- SQL Server에서 다양한 종류의 조인(내부, 왼쪽, 오른쪽, 전체)을 설명해드릴게요.\n- SQL Server에서 저장 프로시저와 함수에 대해 논의하고 이점에 대해 알려드릴게요.\n- SQL Server에서 트랜잭션을 어떻게 구현하나요?\n- 데이터베이스 설계에서의 정규화와 중요성에 대해 설명해드릴게요.\n- SQL Server에서 다양한 종류의 인덱스 및 사용 시기에 대해 알려드릴게요.\n- 데이터베이스 작업 시 보안 고려 사항에 대해 논의해드릴게요.\n- .NET 애플리케이션에서 데이터베이스 마이그레이션을 어떻게 관리하나요?\n- Entity Framework(EF)와 데이터 액세스에서의 역할에 대해 설명해드릴게요.\n- .NET에서 데이터 액세스에 대한 다양한 접근 방식을 논의하고 ADO.NET, EF Core 등에 대해 이야기해볼까요?\n- 데이터베이스 쿼리의 성능을 최적화하는 방법에 대해 어떻게 생각하시나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 기술 (Angular):\n\n- Angular에서 컴포넌트의 개념을 설명해주세요.\n- Angular에서 데이터 바인딩 메커니즘을 논의해주세요 (일방향, 양방향).\n- Angular에서 서비스 및 의존성 주입을 어떻게 관리하나요?\n- Angular에서 라우팅을 설명하고 다양한 라우팅 전략에 대해 알려주세요.\n- Angular에서 모듈은 무엇이고 그 목적은 무엇인가요?\n- Angular에서 지시문을 사용하는 최선의 방법에 대해 논의해주세요.\n- Angular에서 컴포넌트 간 통신을 어떻게 구현하나요?\n- Angular에서 반응형 프로그래밍 개념을 설명해주세요 (Observables, RxJS).\n- Angular에서 양식 및 유효성 검사를 처리하는 기술에 대해 논의해주세요.\n- Angular 컴포넌트 및 서비스에 대한 유닛 테스트를 어떻게 구현하나요?\n\n클라우드 및 데브옵스 (Azure):\n\n- 다른 클라우드 컴퓨팅 서비스 모델을 설명해주세요 (IaaS, PaaS, SaaS).\n- .NET 애플리케이션에 Microsoft Azure를 사용하는 이점을 논의해주세요.\n- Azure App Service 및 Azure Functions은 무엇이며 사용 사례는 무엇인가요?\n- Azure Cosmos DB를 설명하고 SQL Server와 비교했을 때 차이점에 대해 설명해주세요.\n- Azure Active Directory (AAD)와 그 역할에 대해 논의해주세요.\n- Azure Storage 서비스는 무엇이며 어떻게 사용하나요?\n- Azure DevOps 도구 (Azure 파이프라인, Azure Repos) 및 기능에 대해 설명해주세요.\n- .NET 개발에서 CI/CD (지속적 통합/지속적 제공) 관행에 대해 논의해주세요.\n- .NET 애플리케이션을 Azure에 배포하기 위한 로깅 및 모니터링을 어떻게 구현하나요?\n- .NET 애플리케이션을 Azure에 배포하는 최상의 방법에 대해 설명해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보너스 질문:\n\n- 마이크로서비스 아키텍처 프레임워크(.NET Dapr 등)를 사용한 경험에 대해 이야기해주세요.\n- 개발 프로세스에서 성능 최적화에 대한 접근 방법은 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png"},"coverImage":"/assets/img/2024-06-22-QuestionstopreparetocrackaFullStackNETDeveloperInterview_0.png","tag":["Tech"],"readingTime":3},{"title":"Angular 프로젝트에서 React 컴포넌트 사용하는 방법","description":"","date":"2024-06-22 03:34","slug":"2024-06-22-UseReactComponentInsideAngularProject","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png\" /\u003e\n\n많은 글에서 어떤 인기 있는 프레임워크가 더 나은지에 대한 논쟁을 보았을 겁니다. React JS인지 Angular인지요. 그러나 제가 알기로는 대부분의 현대 프레임워크들은 비슷하다고 생각해요. (각 프레임워크의 백지상태의 자바스크립트 뒷단이 어떻게 돌아가는지 알고 있다면 말이죠.) 단지 작은 구문 변경과 브라우저에서 div를 렌더링하는 방식에 약간의 차이만 있을 뿐입니다.\n\nReact JS가 최고인지 Angular가 최고인지는 중요하지 않아요. 전문가들은 신경 쓰지 않으며 더 많이 솔루션을 제공하는데 초점을 맞추죠.\n\n그래서 만약 우리가 Angular와 React JS를 동시에 단일 프로젝트에서 사용하여 이 논쟁을 마무리짓는다면 어떨까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 위해 첫 번째 단계는 다음 명령을 CMD에서 실행하여 Angular 프로젝트를 초기화하는 것입니다:\n\n```js\nng new angular-react\n\ncd angular-react\n```\n\n위의 명령은 최신 버전의 새로운 Angular 프로젝트를 만들고, 그 후에 해당 프로젝트 루트 폴더로 이동합니다.\n\n이후에 Angular 내에서 React를 지원하기 위한 모든 종속성들을 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install react, react-dom\n```\n\n프로젝트 내에서 React 패키지가 설치되면, React 컴포넌트를 작성하기 위해 tsconfig.json 파일을 .tsx를 지원하도록 업데이트해야 합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    ...\n    \"jsx\": \"react\",\n    ...\n  },\n}\n```\n\ntsconfig.json 파일에서 compilerOptions 아래에 \"jsx\" 속성을 추가하고 값을 \"react\"로 설정하세요. 이렇게 하면 TypeScript 컴파일러가 JSX 또는 TSX 파일과 코드를 이해하고 지원할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypescript 구성이 완료되면 Angular에서 실제 React 코드가 작성된 새 컴포넌트를 생성할 것입니다.\n\n```js\nng g c react-comp\n```\n\n위 명령은 프로젝트의 app 폴더에 새 컴포넌트를 추가할 것입니다. 컴포넌트를 추가한 후에는 react-comp.component.ts의 확장자를 react-comp.component.tsx로 변경하십시오.\n\n```js\n/** 컴포넌트 폴더 구조 **/\n\n- react-comp\n    react-comp.component.css\n    react-comp.component.html\n    react-comp.component.ts -\u003e react-comp.component.tsx\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML 파일에 div를 추가하고 ID를 할당하세요. 이렇게 하면 React가 해당 루트 div를 찾도록 도와줍니다:\n\n```js\n\u003cp\u003ereact-comp works!\u003c/p\u003e\n\u003cdiv id=\"react-comp\"\u003e\u003c/div\u003e\n```\n\n.tsx 파일 안에 다음 코드를 복사하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport React from 'react'\nimport ReactDOM from 'react-dom/client';\nimport { MyComponent } from 'react-sample'\n\n@Component({\n  selector: 'app-react-comp',\n  standalone: true,\n  imports: [],\n  templateUrl: './react-comp.component.html',\n  styleUrl: './react-comp.component.css'\n})\nexport class ReactCompComponent {\n\n  ngOnInit(): void {\n    const root = ReactDOM.createRoot(\n      document.getElementById('react-comp') as HTMLElement\n    )\n\n    root.render(\n      \u003cdiv\u003e\n        \u003cMyComponent message='이거 에갈앵 안에 있는 리액트 컴포넌트입니다'  /\u003e\n      \u003c/div\u003e\n    )\n\n  }\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드는 Angular 컴포넌트이며, 컴포넌트 라이프사이클의 ngOnInit 이벤트에서 React 컴포넌트를 렌더링합니다.\n\n그러면 이제 Angular 내에서 React 컴포넌트를 실행할 수 있습니다.\n\n이 글의 자세한 설명을 원하시면 아래 링크를 참조해 주세요.\n\n링크: [https://youtu.be/iI8IMVMrzWc](https://youtu.be/iI8IMVMrzWc)","ogImage":{"url":"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png"},"coverImage":"/assets/img/2024-06-22-UseReactComponentInsideAngularProject_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년 최신 Angular에서 템플릿 기반 폼을 사용하는 방법","description":"","date":"2024-06-22 03:32","slug":"2024-06-22-TemplateDrivenForminAngular","content":"\n\n이 기사에서는 템플릿 폼과 언제 템플릿 드리븐 폼을 사용해야 하는지에 대해 안내하겠습니다.\n\n현실적인 예로 병원을 방문할 때 종이를 받아서 기본 정보를 적어야 하는 상황이나 학교 입학 신청서를 작성해야 하는 상황이 있습니다. 이 정보들은 소프트웨어에 업로드됩니다. 따라서 폼은 본질적으로 정보를 수집하는 종이라고 할 수 있습니다. 기술적 관점에서 Angular는 템플릿 드리븐 폼을 제공하여 사물에 대한 정보를 수집하게 됩니다.\n\n참고: Angular에서 폼을 사용하는 경우에는 AppModule에서 FormModule을 반드시 import해야 합니다.\n\n# 템플릿 드리븐 폼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용하기 쉽습니다\n- 간단한 시나리오에 적합합니다.\n- 복잡한 시나리오에는 권장하지 않습니다.\n- 구문은 이전 버전의 AngularJS와 유사합니다.\n- 템플릿 기반 폼에 사용되는 구문은 양방향 데이터 바인딩 [(NgModel)]로, 최소한의 컴포넌트 코드를 사용합니다.\n- 폼 및 데이터의 자동 추적(앵귤러에서 처리)\n- 템플릿 유효성 검사는 지시어를 통해 검증됩니다.\n- 템플릿 기반 폼의 단위 테스트는 값 변경과 유효성 검사가 비동기적이라는 문제가 있습니다.\n- 데이터 모델은 구조적이지 않습니다.\n- 템플릿 폼에서의 예측 가능성은 비동기적입니다.\n- 폼 유효성 검사는 필드에 보다 많은 유효성 검사 태그를 추가하거나 복잡한 교차 필드 유효성 검사를 추가할수록 폼의 가독성이 떨어집니다.\n\n# 언제 템플릿 기반 폼을 사용해야 하는가:\n\n로그인과 같이 기본적이고 간단한 요구사항을 갖는 앱에서는 템플릿 기반 폼을 사용해야 합니다.\n\n예제 템플릿 기반 폼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';        // FormsModule 가져오기\n \nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n \n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    FormsModule                    // Imports 배열에 추가\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n```js\n\u003cform #SingUpForm=\"ngForm\"\u003e\n\n// 템플릿에서 변수를 생성합니다. 앵귤러에서는 이를 템플릿 참조 변수라고 합니다\n```\n\n# ngForm이란 무엇인가요?\n\nngForm은 다음을 실행합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `Form` 지시문에 자체 바인딩\n- 최상위 FormGroup 인스턴스 생성\n- ngModel 지시문이있는 각 자식 컨트롤에 대해 FormControl 인스턴스 생성\n- NgModelGroup 지시문에 대해 각각 FormGroup 인스턴스를 생성\n\n# 템플릿 기반의 FormControl 인스턴스\n\n이들은 firstName, lastName 및 다른 필드입니다. 이들을 formControl 인스턴스에 바인딩해야 합니다. 이는 ngModel 지시문을 사용하여 수행합니다.\n\n```js\n\u003cinput type=\"text\" name=\"firstname\" ngModel\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n파일을 다음과 같이 수정해주세요. \n\n\n\u003cform #singUpForm=\"ngForm\" (ngSubmit)=\"onSubmit(singUpForm)\"\u003e\n \n  \u003cp\u003e\n    \u003clabel for=\"firstname\"\u003e이름\u003c/label\u003e\n    \u003cinput type=\"text\" name=\"firstname\" ngModel\u003e\n  \u003c/p\u003e\n \n  \u003cp\u003e\n    \u003clabel for=\"lastname\"\u003e성\u003c/label\u003e\n    \u003cinput type=\"text\" name=\"lastname\" ngModel\u003e\n  \u003c/p\u003e\n \n  \u003cp\u003e\n    \u003clabel for=\"email\"\u003e이메일\u003c/label\u003e\n    \u003cinput type=\"text\" id=\"email\" name=\"email\" ngModel\u003e\n  \u003c/p\u003e\n \n  \u003cp\u003e\n    \u003clabel for=\"gender\"\u003e성별\u003c/label\u003e\n    \u003cinput type=\"radio\" value=\"male\" name=\"gender\" ngModel\u003e 남성\n    \u003cinput type=\"radio\" value=\"female\" name=\"gender\" ngModel\u003e 여성\n  \u003c/p\u003e\n \n  \u003cp\u003e\n    \u003clabel for=\"isMarried\"\u003e결혼 여부\u003c/label\u003e\n    \u003cinput type=\"checkbox\" name=\"isMarried\" ngModel\u003e\n  \u003c/p\u003e\n \n  \u003cselect name=\"country\" ngModel\u003e\n    \u003coption [ngValue]=\"c.id\" *ngFor=\"let c of countryList\"\u003e\n      {c.name}\n    \u003c/option\u003e\n  \u003c/select\u003e\n \n  \u003cp\u003e\n    \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n  \u003c/p\u003e\n  \n\u003c/form\u003e\n\n\n```typescript\nimport { Component } from '@angular/core';\n \n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = '템플릿 기반 폼';\n \n  countryList:country[] = [\n    new country(\"1\", \"파키스탄\"),\n    new country('2', '아랍에미리트'),\n    new country('3', '미국')\n  ];\n}\n \nexport class country {\n  id:string;\n  name:string;\n \n  constructor(id:string, name:string) {\n    this.id=id;\n    this.name=name;\n  }\n\n onSubmit(contactForm) {\n    console.log(contactForm.value);\n  }\n}\n```\n\n# 내장 검증기\n\n내장 검증기는 필수(required), 최소 길이(minlength), 최대 길이(maxlength), 패턴(pattern)과 같은 HTML5 유효성 검사 속성을 사용합니다. Angular는 이러한 유효성 검사 속성을 해석하고, FormControl 인스턴스에 유효성 검사기 함수를 추가합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 필수 유효성 검사\n\n필수 유효성 검사는 양식 컨트롤에 비어있지 않은 값이 입력된 경우에만 true를 반환합니다.\n\n# 최소길이 유효성 검사\n\n이 유효성 검사기는 컨트롤 값이 유효성 검사기에 지정된 값보다 적은 수의 문자를 가져서는 안 된다는 것을 요구합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, minlength validator는 사용자 이름 값이 적어도 20자여야 함을 보장합니다.\n\n```js\n\u003cinput type=\"text\" id=\"userName\" name=\"userName\" required minlength=\"20\"\u003e\n```\n\n# Maxlength Validation\n\n이 Validator는 문자 수가 속성 값 이상으로 초과되지 않아야 함을 요구합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, maxlength 검증기는 사용자 이름 값이 최대 20자까지인지 확인합니다.\n\n```js\n\u003cinput type=\"text\" id=\"userName\" name=\"userName\" required maxlength=\"20\"\u003e\n```\n\n# 패턴 유효성 검사\n\n이 유효성 검사기는 컨트롤 값이 속성에 제공된 정규식 패턴과 일치해야 함을 요구합니다. 예를 들어, 패턴 ^[a-zA-Z]+$는 문자만 허용됨을 보장합니다 (공백도 허용되지 않음). 이 패턴을 사용자 이름에 적용해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 이메일 유효성 검사\n\n이 유효성 검사기는 제어 값이 유효한 이메일 주소여야 함을 요구합니다.\n\n```js\n\u003cinput type=\"text\" id=\"email\" name=\"email\" required email\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유효성 스타일링\n\n모델 기반 폼과 유사하게, 우리는 각 모델 폼 컨트롤의 상태에 접근할 수 있습니다. 이를 위해서는 최상위 폼 그룹을 통해 이동해야 합니다.\n\nngForm 지시자는 최상위 FormGroup를 form 속성을 통해 제공하므로, 이메일 필드의 유효성, 수정 여부, 터치 여부를 다음과 같이 표시할 수 있습니다:\n\n```js\n\u003cpre\u003e유효함? {f.form.controls.email?.valid}\u003c/pre\u003e\n\u003cpre\u003e수정됨? {f.form.controls.email?.dirty}\u003c/pre\u003e\n\u003cpre\u003e터치됨? {f.form.controls.email?.touched}\u003c/pre\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 엘비스 연산자\n\n? 기호를 엘비스 연산자라고 합니다. 만약 ? 왼쪽에 위치한 속성이 null이 아닌 경우에만 ? 오른쪽에 속성을 호출하려고 시도합니다. 템플릿 기반 형식에서 Angular이 페이지를 빌드할 때 컨트롤이 가끔 null 일 수 있으므로 안전을 위해 엘비스 연산자를 사용합니다.\n\n```js\n\u003cpre\u003eValid? {f.form.controls.email?.valid}\u003c/pre\u003e\n```\n\n# 폼 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cform (ngSubmit)=\"onSubmit()\" #myForm=\"ngForm\"\u003e\n```\n\n```js\n@ViewChild('myForm') form: any;\n\nonSubmit() {\n  if (this.form.valid) {\n    console.log(\"Form Submitted!\");\n    this.form.reset();\n  }\n}\n```\n\n## NgModelGroup 지시자\n\nngModelGroup 지시자를 사용하면 관련 있는 입력을 그룹화하여 폼에 의해 표현되는 객체를 유용하고 예측 가능한 방식으로 구조화할 수 있습니다. ngModelGroup는 주로 fieldset과 결합하여 사용되는데, 이들은 대부분 \"입력을 그룹화함\"이라는 같은 아이디어를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {Component, ViewChild} from \"@angular/core\";\n@Component({\n    selector: 'app',\n    template: `\n\u003cform \n    #formRef=\"ngForm\" \n    (ngSubmit)=\"onSubmit(formRef.value)\"\n    \u003e\n    \u003cfieldset ngModelGroup=\"login\"\u003e\n        \u003cinput \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        \u003e    \n        \u003cdiv *ngIf=\"usernameRef.errors?.required\"\u003eThis field is required\u003c/div\u003e\n        \u003cdiv *ngIf=\"usernameRef.errors?.minlength\"\u003eThis field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}\u003c/div\u003e\n        \n        \u003cinput type=\"password\" ngModel name=\"password\"\u003e\n    \u003c/fieldset\u003e\n    \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n\u003c/form\u003e \n{formRef.value | json}   \n{formRef.valid | json}   \n\n``` \n\n# 출력\n\n```js \n{ \"login\": { \"username\": \"Zeeshan\", \"password\": \"\" } } true\n```\n\n```js\nimport {Component, ViewChild} from \"@angular/core\";\n@Component({\n    selector: 'app',\n    template: `\n\u003cform \n    #formRef=\"ngForm\" \n    (ngSubmit)=\"onSubmit(formRef.value)\"\n    \u003e\n    \u003cfieldset ngModelGroup=\"login\"\u003e\n        \u003cinput \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        \u003e    \n        \u003cdiv *ngIf=\"usernameRef.errors?.required\"\u003eThis field is required\u003c/div\u003e\n        \u003cdiv *ngIf=\"usernameRef.errors?.minlength\"\u003eThis field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}\u003c/div\u003e\n        \n        \u003cinput type=\"password\" ngModel name=\"password\"\u003e\n    \u003c/fieldset\u003e\n     \u003cfieldset ngModelGroup=\"signUp\"\u003e\n        \u003cinput \n            #usernameRef=\"ngModel\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            type=\"text\"        \n            required\n            minlength=\"3\"\n        \u003e    \n        \u003cdiv *ngIf=\"usernameRef.errors?.required\"\u003eThis field is required\u003c/div\u003e\n        \u003cdiv *ngIf=\"usernameRef.errors?.minlength\"\u003eThis field must be longer than {usernameRef.errors?.minlength.requiredLength} characters. You only typed {usernameRef.errors?.minlength.actualLength}\u003c/div\u003e\n        \n        \u003cinput type=\"password\" ngModel name=\"password\"\u003e\n    \u003c/fieldset\u003e\n    \n    \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n\u003c/form\u003e \n{formRef.value | json}   \n{formRef.valid | json}   \n\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결과\n\n```js\n{ \"login\": { \"username\": \"Zeeshan\", \"password\": \"\" },\n  \"signUp\": { \"username\": \"Zeeshan\", \"password\": \"\" } } true\n```\n\n# 유효성 검사/오류 메시지 표시\n\nAngular은 각 필드에 적용된 ngModel 지시문을 갖는 각각의 필드에 대해 FormControl을 생성합니다. FormControl은 유효(valid), 변경된(dirty), 터치(touched) 등과 같은 폼 요소의 상태를 노출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFormControl에 대한 참조를 얻는 두 가지 방법이 있습니다.\n\n- 하나는 contactForm 변수를 사용하는 방법입니다. myForm.controls.firstname.valid를 사용하여 firstname이 유효한지 확인할 수 있습니다.\n- 다른 방법은 각 FormControl을 위해 새로운 로컬 변수를 만드는 것입니다. 예를 들어 다음과 같이 firstname=\"ngModel\"을 생성하면 firstname 변수에 FormControl 인스턴스가 만들어집니다.\n\n```js\n\u003cinput type=\"text\" id=\"firstname\" name=\"firstname\" required minlength=\"10\" \n            #firstname=\"ngModel\"\u003e\n```\n\n이제 firstname FormControl 인스턴스에 대한 참조가 있으므로 해당 상태를 확인할 수 있습니다. firstname에 오류가 있는지 확인하기 위해 valid 속성을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\n\u003cdiv *ngIf=\"!firstname?.valid \u0026\u0026 (firstname?.dirty || firstname?.touched)\"\u003e\nInvalid First Name\n\u003c/div\u003e\n```\n\n# 결론\n\n우리는 템플릿 주도형 폼이 여전히 모델 주도형 폼과 동일한 클래스를 사용하지만 템플릿 주도 접근 방식에서는 모델이 명시적으로 컴포넌트에서 생성되는 것이 아니라 템플릿에서 디렉티브에 의해 생성된다는 것을 배웠습니다.","ogImage":{"url":"/assets/img/2024-06-22-TemplateDrivenForminAngular_0.png"},"coverImage":"/assets/img/2024-06-22-TemplateDrivenForminAngular_0.png","tag":["Tech"],"readingTime":10},{"title":"앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기","description":"","date":"2024-06-22 03:31","slug":"2024-06-22-AngularAnimationsTutorialRouteTransitions","content":"\n\n만약 라우팅을 갖춘 Angular 애플리케이션을 다룬 적이 있다면, 루트 간 이동 시에 트랜지션을 추가하고 싶었을 것입니다. 이렇게 하면 애플리케이션이 전체적으로 더 우아해 보입니다. 알고 계셨나요? Animation 모듈을 이용하면 이를 쉽게 구현할 수 있습니다. 이번 예제에서 그 방법을 보여드리겠습니다. 그럼 시작해봅시다.\n\n# 시작하기 전에\n\n자, 그러기 전에 너무 멀리 나가기 전에 Angular의 애니메이션 프레임워크에 중점을 둔 다수의 포스트를 이미 만들었다는 것을 기억하는 것이 중요합니다.\n\n## Angular 애니메이션 자습서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기초 학습\n- 입장 및 퇴장 애니메이션\n- Keyframes 기능\n- 쿼리 및 Stagger 함수\n- 시작 및 완료 이벤트\n- 병렬 애니메이션\n- 알 수 없는 높이로 애니메이션 설정하기\n- 매개변수로 유연성 추가\n- 재사용 가능한 애니메이션 생성\n- 애니메이션 비활성화 및 활성화\n\n위 포스트들은 다양한 애니메이션 주제를 다루고 있습니다. 따라서 이 중 어떤 개념이 익숙하지 않다면, 이 포스트들을 먼저 확인해보는 것이 좋습니다. 그렇지 않으면 이 예제에서 헤맬 수 있습니다.\n\n그리고, 이것들을 쉽게 찾을 수 있도록 우리는 Angular Animation 재생 목록을 YouTube 채널에서 만들었으니 확인해보세요!\n\n좋아요, 충분하니까, 이제 이 포스트의 예제로 넘어가 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 애플리케이션\n\n이 예제에서는 이 간단한 데모 애플리케이션을 사용할 것입니다. 이동할 수 있는 몇 가지 다른 페이지가 있습니다. 주 메뉴에서 링크를 클릭하면 해당 페이지로 이동됩니다. \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*wysR9eAe-EwO7yxd.gif)\n\n하지만 서로 다른 페이지로 이동할 때 전환 효과가 있는 것이 더 좋을 것입니다. 여기서 보는 것처럼 횡단페이드 효과나 다른 효과가 있으면 좋을 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*-Szw6y8W09ki2NN9.gif)\n\n요번 예제에서 우리가 할 일이 바로 이것입니다. 하지만 먼저, 필요한 내용을 더 잘 이해하기 위해 기존 코드를 살펴보겠습니다.\n\n# 기존 코드\n\n그래, 언급했듯이, 이 앱은 이미 라우팅이 설정되어 있습니다. 따라서, 앱 컴포넌트를 살펴보면 템플릿에 router-outlet이 있다는 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## main.ts\n\n```js\n@Component({\n    selector: 'app-root',\n    template: `\n        \u003capp-nav\u003e\u003c/app-nav\u003e\n        \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n    `,\n    ...\n})\nexport class App {\n}\n```\n\n내비게이션 구성 요소의 링크 중 하나를 클릭하면 라우트된 구성 요소가 router-outlet 요소의 형제로 삽입됩니다. 라우트 구성을 살펴보면, 주소 표시줄에서 볼 경로와 해당 경로로 이동할 때 표시하려는 구성 요소를 모두 제공한 곳입니다.\n\n따라서 예를 들어 \"blog\" 경로로 이동하면 BlogComponent가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n    path: 'blog',\n    component: BlogComponent,\n    title: '우리 블로그',\n}\n```\n\n또는 \"contact\" 경로로 이동하면 ContactComponent가 표시됩니다.\n\n```js\n{\n    path: 'contact',\n    component: ContactComponent,\n    title: '문의하기',\n}\n```\n\n이해하셨죠? 새 경로의 활성 컴포넌트는 Angular 애니메이션 측면에서 \"입력\" 항목으로 간주됩니다. 그리고 이전 경로의 컴포넌트는 \"떠나는\" 항목으로 간주됩니다. 이것은 두 개를 모두 애니메이션화하는 방법을 갖게 될 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 \"입장\" 및 \"퇴장\" 애니메이션 개념이 익숙하지 않다면, 여기에 비디오가 있으니 꼭 확인해보세요. 개념을 더 잘 이해할 수 있습니다.\n\n# 라우트 전환 애니메이션 만들기\n\n자, 지금까지 모든 작업 방식에 대한 이해가 되었으니, 이제 애니메이션을 만드는 것부터 시작해봅시다. 이를 위해 애니메이션 코드를 추가하는 새 파일을 만들어야 합니다. \"route-transition.ts\" 라고 이름 짓겠습니다.\n\n이제 내보낼 수 있는 상수를 추가해야 합니다. 앱 구성 요소에이 애니메이션을 가져올 수 있도록 하기 위해 \"route-transition.ts\"라고 이름 짓습니다. 상수의 이름은 \"routeTransition\"으로 지정해보겠습니다. 우리는 Angular 애니메이션 모듈에서 trigger() 함수를 사용하여 이를 설정할 것입니다. 이름으로도 routeTransition으로 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## route-transition.ts\n\n```js\nimport { trigger } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n]);\n```\n\n그 다음, transition() 함수가 필요합니다. 이 라우트 전환에서는 라우트 데이터 변경 시마다 실행되길 원할 것입니다. 따라서 별표(*)가 있는 모든 상태에서 다른 상태로 애니메이션을 적용할 것입니다.\n\n```js\nimport { ..., transition } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n    ])\n]);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 애니메이션에서 처음 할 일은 항목이 \"숨겨진\" 상태에서 시작하도록 설정하는 것입니다. 그러니까, entering 컴포넌트를 쿼리하기 위해 query() 함수를 추가해봐요. 그런 다음 시작 스타일을 제공할 수 있도록 style() 함수를 추가할 거에요. 우리는 불투명도가 0이고 크기가 0.9인 상태로 시작할 거에요. 마지막으로 해야 할 일은 entering 항목을 찾지 못했을 때의 선택적 플래그를 추가하는 것이에요.\n\n```js\nimport { ..., query, style } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n        query(':enter', [\n            style({ opacity: 0, scale: 0.9 }),\n        ], { optional: true })\n    ])\n]);\n```\n\n그렇죠, 다음은 leaving 컴포넌트를 전환할거에요. 그래서 떠나는 항목을 쿼리하기 위해 또 다른 query() 함수를 추가해봅시다.\n\n이 항목의 경우 시작 스타일이 필요하지 않습니다. 왜냐하면 자동적으로 완전히 불투명하고 전체 크기로 시작하거든요. 우리가 해야 할 일은 애니메이션을 추가해서 animate() 함수를 추가하는 것이에요. 이 애니메이션을 정말로 볼 수 있도록 하기 위해 우리는 일 초 동안 애니메이션을 수행하도록 설정할 거에요. 그런 다음 애니메이션 효과를 줄 스타일을 추가하기 위해 다른 style() 함수를 사용하도록 해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n        ...,\n        query(':enter', [\n            animate('1s', style({ opacity: 1, scale: 1 }))\n        ], { optional: true })\n    ])\n]);\n```\n\n자, 애니메이션에 필요한 모든 것을 추가했습니다. 이제 전환하여 앱 컴포넌트에 추가할 수 있습니다.\n\n# 부모 컴포넌트에 라우트 전환 애니메이션 추가\n\n애니메이션을 사용하려면 먼저 컴포넌트 메타데이터에 애니메이션 배열을 추가해야 합니다. 이 배열 내에서 새 \"routeTransition\" 애니메이션을 추가해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## main.ts\n\n```js\nimport { routeTransition } from './route-transition';\n\n@Component({\n    selector: 'app-root',\n    ...,\n    animations: [\n        routeTransition\n    ]\n})\nexport class App {\n}\n```\n\n그럼, 이제 이것을 연결할 수 있습니다. 그전에 이 레이아웃이 어떻게 작동하는지 이해하는 것이 중요합니다. 그리드를 사용합니다. 첫 번째 열은 내비게이션을 위한 것이고, 두 번째 열은 라우트된 컴포넌트를 위한 것입니다. router-outlet의 형제인 모든 것은 두 번째 그리드 열에 배치됩니다. 즉, 들어오고 나가는 항목 모두 이 열 안에 서로 겹쳐 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*MTj1pIyBHdnErdu5.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타깝게도 여기서 해야할 일이 라우터 출력 주위에 컨테이너를 추가하는 것입니다. 애니메이션을 제대로 연결하려면 들어오고 나가는 항목을 쿼리할 수 있어야 하기 때문입니다.\n\n하지만 걱정하지 마세요. display: contents로 설정하여 사실상 보이지 않도록 만들 수 있습니다. 그래서, div를 추가하고 이 div에 display, contents 스타일을 추가합시다.\n\n```js\n\u003cdiv style=\"display: contents\"\u003e\n    \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\u003c/div\u003e\n```\n\n그래서 여기가 우리가 애니메이션 트리거를 바인딩할 곳이며, 어떤 것에 바인딩하여 경로를 변경할 때 트리거할 것인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 경로 전환을 트리거하는 방법\n\n루트를 변경할 때 활성 라우트의 스냅샷 데이터 개체를 사용할 수 있습니다.\n\n이를 위해 생성자를 추가해야 합니다. 그런 다음 ActivatedRoute를 주입해야 합니다. \"route\"라는 이름의 보호된 필드를 만들고 ActivatedRoute 클래스에 주입해야 합니다.\n\n```js\nimport { ..., ActivatedRoute } from '@angular/router';\n\n@Component({\n    selector: 'app-root',\n    ...\n})\nexport class App {\n    constructor(protected route: ActivatedRoute) {\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 애니메이션 트리거를 div에 바인딩해봅시다. route, snapshot, data 객체에 바인딩할 거에요. 이 객체는 route가 변경될 때마다 업데이트되니 우리 애니메이션을 제대로 트리거하게 될 거에요.\n\n```js\n\u003cdiv [@routeTransition]=\"route.snapshot.data\" style=\"display: contents\"\u003e\n    \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\u003c/div\u003e\n```\n\n좋아요, 거의 다 왔어요. 이 애니메이션이 작동하려면 providers 배열에 provideAnimations() 함수를 추가하여 애니메이션을 활성화해야 합니다.\n\n```js\nimport { provideAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(App, {\n    providers: [ \n        ...,\n        provideAnimations()\n    ]\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 라우트 간에 전환할 때 필요한 모든 것이 준비되었어요. 이제 저장하고 시도해봅시다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*ZC_28tRmHkrNc482.gif)\n\n좋아요, 나가는 구성 요소와 들어오는 구성 요소를 모두 제대로 애니메이션화하는 것 같아요. 이제 조금 이상해 보이죠, 주로 얼마나 느리게 애니메이션되는지 때문에요. 기억하시죠, 나가는 항목에 1초간, 들어오는 항목에 또 1초간 애니메이션을 주고 있어요. 이것은 이러한 유형의 전환에 대해 꽤 느린 속도에요. 하지만 이 애니메이션이 어떻게 작동하는지 제시하고 싶었어요.\n\n이제 작동하는 것을 볼 수 있고, 그것을 이해했으니, 0.2초와 같이 짧은 기간으로 전환해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## route-transition.ts\n\n```js\n    export const routeTransition = trigger('routeTransition', [\n        transition('* =\u003e *', [\n            ...,\n            query(':leave', [\n                animate('0.2s', ...)\n            ], ...),\n            query(':enter', [\n                animate('0.2s', ...)\n            ], ...)\n        ])\n    ]);\n```\n\n이제 저장하고 다시 시도해 보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*FyBZwrhqsmy4Y9XB.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 했어요!\n\n# 결론\n\n물론, 이러한 종류의 애니메이션을 만드는 다양한 방법이 있습니다. 이제 Angular 애플리케이션에 라우트 전환을 추가하기 위해 필요한 모든 것을 알았으니, 상상력만이 당신을 막는 것일 뿐입니다.\n\n아직도 Angular 애니메이션에 대해 다룰 내용이 많이 남아 있지만, 여기까지 하겠습니다. 앞으로 미래의 게시물을 계속 주시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실제로 보고 싶으세요?\n\nStackblitz 예시에서 이 기술들의 데모 코드와 예시를 확인해보세요. 궁금한 점이나 생각이 있으시면 언제든 댓글을 남겨주세요.\n\n# 이 내용 중에 도움이 되는 것이 있으셨나요?\n\n만약 도움이 되는 내용이 있다면, 사랑을 표현해주고 싶다면 언제든 커피 한 잔 사주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원래 2024년 6월 13일에 https://briantree.se에서 게시된 내용입니다.","ogImage":{"url":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png"},"coverImage":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png","tag":["Tech"],"readingTime":8},{"title":"아답터 디자인 패턴을 Angular에서 사용하는 방법","description":"","date":"2024-06-22 03:29","slug":"2024-06-22-DesignPatternsAdapterinAngular","content":"\n\n구조 패턴은 클래스와 객체를 더 큰 구조로 결합하는 방법을 설명합니다.\n\n구조 디자인 패턴에는 다음이 포함됩니다:\n1. 어댑터\n2. 컴포지트\n3. 프록시\n4. 플라이웨이트\n5. 퍼사드\n6. 브릿지\n7. 데코레이터\n\n어댑터 패턴은 한 클래스의 인터페이스를 클라이언트가 기대하는 인터페이스로 적응시킵니다. 이를 통해 그렇지 않았을 때 호환되지 않을 클래스 간의 협력이 가능해집니다. 이는 관련 없는 클래스끼리 협력할 수 있게 합니다.\n\nAdapter 패턴을 구현하는 두 가지 방법이 있습니다:\n- extends\n- 합성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n양쪽 경우 모두 예제로 설명하는 것이 가장 쉬울 것입니다.\n\n만약 전체 데모를 보고 싶다면, 제 데모 프로젝트를 확인해보세요.\n\n## 확장\n\n첫 번째 경우에는 부적절한 인터페이스를 가진 클래스에 파생 클래스를 배치하고 원하는 기능을 얻기 위해 해당 클래스에 메서드를 추가하는 방식으로 원하는 기능을 얻습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, AdapterComponent 예제 구성 요소에서 TableComponent 구성 요소를 배치합니다.\n\n아래에는 두 그룹의 버튼이 있습니다. 첫 번째 그룹인 Status에는 Status 열에 해당하는 값을 선택하는 라디오 버튼과 드롭다운 목록이 포함되어 있습니다. 두 번째 그룹인 Type 버튼에는 Type 열에 해당하는 값을 선택하는 라디오 버튼과 드롭다운 목록이 포함되어 있습니다. 아래는 AdapterComponent 구성 요소 템플릿입니다:\n\n```js\n\u003cdiv\u003e\n    \u003cdiv\u003e\n        \u003capp-table [items]=\"currentTasks()\" /\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n        \u003capp-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.status\" \n                   [label]=\"'Status'\" [isChecked]=\"true\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" /\u003e\n\n        \u003capp-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.status\" \n            [keys]=\"statusKeys\"\n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilterValue( FilterColumn.status, configFilter.statusValue = $event)\" /\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n        \u003capp-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.type\" \n                   [label]=\"'Type'\" [isChecked]=\"false\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" /\u003e\n\n        \u003capp-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.type\" \n            [keys]=\"typesKeys\"\n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilterValue(FilterColumn.type, configFilter.typeValue = $event )\" /\u003e\n    \u003c/div\u003e\n\u003c/div\u003e\n```\n\nTableComponent 구성 요소의 내용을 보여주는 클래스, 템플릿 및 스타일이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-table', \n  template: `\n  \u003ctable\u003e\n    \u003cthead\u003e\n        \u003cth *ngFor=\"let column of columns\"\u003e{ column }\u003c/th\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        @for (item of items; track item.id;) {\n        \u003ctr\u003e\n            \u003ctd *ngFor=\"let column of columns\"\u003e\n                \u003cng-container [ngSwitch]=\"column\"\u003e\n                    \u003cspan *ngSwitchCase=\"'status'\"\u003e{ item[column] | status }\u003c/span\u003e\n                    \u003cspan *ngSwitchCase=\"'type'\"\u003e{ item[column] | types }\u003c/span\u003e\n                    \u003cspan *ngSwitchDefault\u003e{ item[column] }\u003c/span\u003e\n                \u003c/ng-container\u003e\n            \u003c/td\u003e\n        \u003c/tr\u003e\n        }\n    \u003c/tbody\u003e\n  \u003c/table\u003e`,\n    styles:[`\n    table { border-collapse: collapse; }\n    th, td { \n      border: 1px solid black; \n      padding: 8px; }\n    th { background-color: #f2f2f2; }`]\n})\nexport class TableComponent {\n  @Input() items: any[] = [];\n  columns: string[] = [];\n\n  ngOnInit() {\n    if (this.items.length \u003e 0) {\n      this.columns = Object.keys(this.items[0]);\n    }\n  }\n}\n```\n\n라디오 버튼을 구현해야 하는데, 선택한 값을 위한 드롭다운 목록의 가시성을 토글하는 기능을 AdapterComponent 구성 요소에 구현해야 합니다. 재사용 가능한 컴포넌트를 구현하는 것이 가장 좋은 접근 방식입니다. 아래는 재사용 가능한 컴포넌트 RadioComponent의 제안된 구현입니다:\n\n```js\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { FilterColumn } from '../../model/model';\n\n@Component({\n  selector: 'app-radio',\n  template: ` \n  \u003clabel\u003e\n    \u003cinput \n        type=\"radio\" \n        name=\"{name}\" \n        value=\"{value}\" \n        (change)=\"onSelectionChange()\" \n        [checked]=\"isChecked\"\u003e\n    { label }\n  \u003c/label\u003e`,\n})\nexport class RadioComponent {\n\n  @Input() name: string = '';\n  @Input() value!: FilterColumn;\n  @Input() label: string = '';\n  @Input() isChecked: boolean = false;\n  @Output() selectedValue = new EventEmitter\u003cFilterColumn\u003e();\n\n  onSelectionChange() {\n    this.selectedValue.emit(this.value);\n  }\n}\n```\n\n값 선택 드롭다운 목록을 위한 재사용 가능한 컴포넌트는 아래와 같습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-select-dropdown',\n  template: `\n  \u003cselect [(ngModel)]=\"selectedValue\" (ngModelChange)=\"onSelectionChange()\"\u003e\n    \u003coption *ngFor=\"let key of keys\" [value]=\"key\"\u003e{ values[key] }\u003c/option\u003e\n  \u003c/select\u003e`\n})\nexport class SelectDropdownComponent {\n  @Input() keys: number[] = [];\n  @Input() values: Record\u003cnumber, string\u003e = {};\n  @Input() selectedValue: number | null = null;\n  @Output() selectionChange: EventEmitter\u003cnumber\u003e = new EventEmitter\u003cnumber\u003e();\n\n  onSelectionChange() {\n    this.selectionChange.emit(Number(this.selectedValue!));\n  }\n}\n```\n\nTasks 테이블에 대한 인터페이스 모델 및 우리가 집중할 값 선택을 위한 드롭다운 목록은 아래에 위치해 있습니다:\n\n```js\nexport interface Tasks {\n  readonly id: number;\n  readonly name: string;\n  readonly status: StatusKey;\n  readonly type: TypesKey;\n  readonly description: string;\n}\n\nexport const Status: Record\u003cnumber, string\u003e = {\n  1: 'done',\n  2: 'during',\n  3: 'not performed',\n};\n\nexport type StatusKey = keyof typeof Status;\n\nexport type TaskTypes = {\n  [key: number]: string;\n};\n\nexport const Types: TaskTypes = {\n  1: 'Urgent',\n  2: 'Important',\n  3: 'Routine',\n  4: 'Extra',\n  5: 'Training',\n};\n\nexport type TypesKey = keyof typeof Types;\n\nexport enum FilterColumn {\n  status = 'status',\n  type = 'type',\n}\n```\n\nTasks 테이블의 현재 데이터는 주입된 DataService 서비스 내에 위치한 getCurrentTasks() 메서드를 사용하여 가져옵니다. 여기서 객체 배열의 값은 Signals로 래핑됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경된 테이블 태그를 마크다운 형식으로 바꿨습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표, 라디오 버튼 및 드롭다운 목록은 서로 통신하지 않습니다. 비록 라디오 버튼과 드롭다운 목록이 표의 요소를 포함하고 있지만요. 라디오 버튼 Status 및 Type은 표의 열 이름과 대응됩니다. 드롭다운 목록에는 필터링에 사용할 수 있는 열의 요소가 포함되어 있습니다. 이러한 요소들 간의 통신은 필터 메서드를 구현하여 수행할 수 있습니다:\n\n```js\nimport { FilterColumn, Tasks } from '../../common/model/model';\n\nexport interface SingleColumnFilterable\u003cT\u003e {\n    filterBySingleColumn(tasks: T[], column: keyof T, value: number): T[];\n}\n\nexport class SingleColumnFilter implements SingleColumnFilterable\u003cTasks\u003e {\n    filterBySingleColumn(tasks: Tasks[], column: keyof typeof FilterColumn, value: number): Tasks[] {\n        const filteredTasks = tasks.filter(task =\u003e task[column] == value);\n        return filteredTasks;\n    }\n}\n```\n\n먼저, filterBySingleColumn 필터링 기능의 정의를 포함하는 SingleColumnFilterable 인터페이스를 구현합니다. 해당 함수는 매우 일반적이므로 SingleColumnFilterable 인터페이스는 다른 클래스에서 사용할 수 있습니다. filterBySingleColumn 메서드에는 열 이름 및 Tasks[] 개체 배열을 필터링하는 값을 포함하는 매개변수가 있습니다. 필터 값에 기반하여 필터링된 개체 배열을 반환합니다.\n\n이 기능이 우리의 어댑터입니다. 지정된 인터페이스를 가진 개체 배열을 가져와 지정된 매개변수에 기반한 개체 배열을 반환합니다. \n어댑터 함수는 데이터를 필터링할 필요는 없지만, 작업을 수행하거나 변환하는 등의 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`filterBySingleColumn` 함수는 `SingleColumnFilter` 클래스를 확장한 `AdapterComponent` 클래스에서 사용됩니다. `filterBySingleColumn` 함수는 재사용 가능한 `SelectDropdownComponent`의 `ngModelChangeFilterValue` 메서드 내에 있습니다. 이 함수의 결과는 `DataService`로 전달됩니다. 서비스는 Signal을 사용하여 Tasks 객체의 배열을 업데이트하고 현재 Tasks 객체의 배열을 AdapterComponent로 전달합니다. 아래는 AdapterComponent의 구현입니다:\n\n```js\nimport { Component, Inject, Signal, inject } from '@angular/core';\nimport { Status, Tasks, StatusKey, TypesKey, Types, FilterColumn } from '../../../common/model/model';\nimport { DataService } from '../../../common/service/data.service';\nimport { SingleColumnFilter,  } from '../../common/task-manager';\nimport { tasks } from '../../../common/service/data';\n\nexport interface FilterConfiguration {\n  filterKey: FilterColumn;\n  statusValue: keyof typeof Status | 0,\n  typeValue: keyof typeof Types | 0;\n}\n\n@Component({\n  selector: 'app-adapter',\n  templateUrl: './adapter.component.html',\n  styleUrl: './adapter.component.scss'\n})\nexport class AdapterComponent extends SingleColumnFilter {\n  private dataService = inject(DataService);\n  startupConfiguration: FilterColumn = FilterColumn.status;\n  FilterColumn = FilterColumn;\n  configFilter: FilterConfiguration = {\n    filterKey: this.startupConfiguration,\n    statusValue: 0,\n    typeValue: 0\n  }\n\n  statusKeys: StatusKey[] = Object.keys(Status).map(Number) as StatusKey[];\n  statusValues = Status;\n\n  typesKeys: TypesKey[] = Object.keys(Types).map(Number) as TypesKey[];\n  typesValues = Types;\n\n  protected currentTasks: Signal\u003cTasks[]\u003e = this.dataService.getCurrentTasks();\n\n  constructor() {\n    super()\n  }\n\n  onRadioSelectionChange(selectedValue: FilterColumn) {\n\n    selectedValue === FilterColumn.type ? this.configFilter.statusValue = 0 : this.configFilter.typeValue = 0\n    if (this.configFilter.statusValue === 0 \u0026\u0026 this.configFilter.typeValue === 0) {\n      this.dataService.updateTasks(tasks);\n    }\n    this.configFilter.filterKey = selectedValue\n  }\n\n  ngModelChangeFilterValue(typeFilter: keyof typeof FilterColumn, val: number) {\n\n    const filteredTasks = this.filterBySingleColumn(tasks, typeFilter, Number(val));\n    this.dataService.updateTasks(filteredTasks);\n  }\n}\n```\n\n## 조합\n\n두 번째 경우에는 조합의 사용은 기존 클래스를 구성 요소로 포함하는 새 클래스의 객체를 생성하는 것을 의미합니다. 예를 들어, 드롭다운 리스트는 Tasks 객체의 배열 요소를 포함하는 새 클래스의 객체를 생성합니다. 두 개의 드롭다운 리스트가 함께 배열을 필터링하도록 하는 예시를 구현해봅시다. Status 또는 Type 드롭다운 리스트에서 값을 선택하면 Tasks 테이블이 필터링됩니다. 그러므로, 필터링할 column 이름과 마지막으로 선택된 값을 매개변수로 하는 ngModelChangeFilter 메서드를 생성해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAdapterComponent 컴포넌트의 템플릿은 현재 다음과 같습니다:\n\n```js\n\u003cdiv\u003e\n    \u003cdiv\u003e\n        \u003capp-table [items]=\"currentTasks()\" /\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n\n        \u003capp-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.status\" \n                   [label]=\"'Status'\" \n                   [isChecked]=\"true\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" /\u003e\n\n        \u003capp-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.status\" \n            [keys]=\"statusKeys\"\n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilterValue( FilterColumn.status, configFilter.statusValue = $event)\" /\u003e\n\n    \u003c/div\u003e\n    \u003cdiv\u003e\n\n        \u003capp-radio [name]=\"'filter'\" \n                   [value]=\"FilterColumn.type\" \n                   [label]=\"'Type'\" \n                   [isChecked]=\"false\"\n            (selectedValue)=\"onRadioSelectionChange($event)\" /\u003e\n\n        \u003capp-select-dropdown \n            *ngIf=\"configFilter.filterKey === FilterColumn.type\" \n            [keys]=\"typesKeys\"\n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilterValue(FilterColumn.type, configFilter.typeValue = $event )\" /\u003e\n\n    \u003c/div\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv\u003e\n    \u003cdiv\u003e\n        \u003capp-table [items]=\"currentTasks()\" /\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n        \u003capp-select-dropdown [keys]=\"statusKeys\" \n            [values]=\"statusValues\" \n            [selectedValue]=\"configFilter.statusValue\"\n            (selectionChange)=\"ngModelChangeFilter(configFilter.filterKey = FilterColumn.status, configFilter.statusValue = $event)\" /\u003e\n\n\n        \u003capp-select-dropdown [keys]=\"typesKeys\" \n            [values]=\"typesValues\" \n            [selectedValue]=\"configFilter.typeValue\"\n            (selectionChange)=\"ngModelChangeFilter(configFilter.filterKey = FilterColumn.type, configFilter.typeValue = $event)\" /\u003e\n    \u003c/div\u003e\n\n\u003c/div\u003e\n```\n\n컴포넌트의 AdapterComponent 클래스:\n\n```js\nimport { Component, Signal, inject } from '@angular/core';\nimport { Status, Tasks, StatusKey, TypesKey, Types, FilterColumn } from '../../../common/model/model';\nimport { DataService } from '../../../common/service/data.service';\nimport { SingleColumnFilter, DoubleColumnFilter } from '../../common/task-manager';\nimport { tasks } from '../../../common/service/data';\n\n\nexport interface FilterConfiguration {\n  filterKey: FilterColumn;\n  statusValue: keyof typeof Status | 0,\n  typeValue: keyof typeof Types | 0;\n}\n\n\n@Component({\n  selector: 'app-adapter',\n  templateUrl: './adapter.component.html',\n  styleUrl: './adapter.component.scss'\n})\nexport class AdapterComponent extends SingleColumnFilter {\n  private dataService = inject(DataService);\n  startupConfiguration: FilterColumn = FilterColumn.status;\n  FilterColumn = FilterColumn;\n  configFilter: FilterConfiguration = {\n    filterKey: this.startupConfiguration,\n    statusValue: 0,\n    typeValue: 0\n  }\n\n  statusKeys: StatusKey[] = Object.keys(Status).map(Number) as StatusKey[];\n  statusValues = Status;\n\n  typesKeys: TypesKey[] = Object.keys(Types).map(Number) as TypesKey[];\n  typesValues = Types;\n\n  protected currentTasks: Signal\u003cTasks[]\u003e = this.dataService.getCurrentTasks();\n\n  constructor() {\n    super()\n  }\n\n  ngModelChangeFilter(typeSort: FilterColumn, val: number) {\n\n    const data = new DoubleColumnFilter(tasks)\n    const filteredTasks = data.filterByBothColumns(this.configFilter.statusValue, this.configFilter.typeValue)\n\n    this.dataService.updateTasks(filteredTasks);\n  }\n\n  onRadioSelectionChange(selectedValue: FilterColumn) {\n\n    selectedValue === FilterColumn.type ? this.configFilter.statusValue = 0 : this.configFilter.typeValue = 0\n    if (this.configFilter.statusValue === 0 \u0026\u0026 this.configFilter.typeValue === 0) {\n      this.dataService.updateTasks(tasks);\n    }\n    this.configFilter.filterKey = selectedValue\n  }\n\n  ngModelChangeFilterValue(typeFilter: keyof typeof FilterColumn, val: number) {\n\n    const filteredTasks = this.filterBySingleColumn(tasks, typeFilter, Number(val));\n    this.dataService.updateTasks(filteredTasks);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nngModelChangeFilter 메소드에는 DoubleColumnFilter 클래스의 객체가 포함되어 있습니다. DoubleColumnFilter 클래스의 매개변수는 tasks 객체의 배열을 전달합니다. 따라서 DoubleColumnFilter 클래스는 생성자에서 Tasks 객체의 배열을 받습니다. DoubleColumnFilter 클래스는 DoubleColumnFilterable 인터페이스를 구현합니다. 아래는 DoubleColumnFilter 클래스와 DoubleColumnFilterable 인터페이스의 구현 내용입니다:\n\n```js\nimport { StatusKey, Tasks, TypesKey } from '../../common/model/model';\n\nexport interface DoubleColumnFilterable\u003cT\u003e {\n    filterByBothColumns(status: StatusKey | 0, type: TypesKey | 0): T[];\n}\n\nexport class DoubleColumnFilter implements DoubleColumnFilterable\u003cTasks\u003e {\n    constructor(private tasks: Tasks[]) {}\n    \n    filterByBothColumns(status: StatusKey | 0, type: TypesKey | 0): Tasks[] {\n    \n        return this.tasks.filter(task =\u003e {\n            const statusMatches = status !== 0 ? task.status === status : true;\n            const typeMatches = type !== 0 ? task.type === type : true;\n            return statusMatches \u0026\u0026 typeMatches;\n        });\n    }\n}\n```\n\n필터링된 결과는 DataService 서비스의 updateTasks 메소드로 전달됩니다. updateTasks 메소드는 Tasks 객체의 배열을 업데이트합니다.\n\n생성자에 객체 배열을 주입하는 것은 정확히 합성입니다. 즉, 두 가지 추상화가 사용하는 것입니다. 이 경우에는 서로 다른 값과 서로 다른 열을 필터링하는 두 개의 드롭다운 목록이 추상화입니다. 그러나 둘 다 동일한 Tasks 객체 배열을 기반으로 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 요약\n\n어댑터 패턴은 응용 프로그램 내의 다른 인터페이스 간의 상호 운용성을 제공하는 특정 기능을 수행하는 추상화입니다.\n\n디자인 패턴의 전반적인 개념을 갖고 보면, 어댑터 패턴은 Liskov 대체 원칙(Liskov Substitution Principle, LSP) 및 단일 책임 원칙(Single Responsibility Principle, SRP)을 준수한다는 것이 분명합니다. LSP에서는 하위 클래스가 기본 클래스의 기능을 확장하면서 원래 동작을 변경하지 않습니다. SRP는 클래스를 작은 단위로 나누어 각각이 단일 기능을 수행하도록 하는 것을 포함합니다.","ogImage":{"url":"/assets/img/2024-06-22-DesignPatternsAdapterinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-DesignPatternsAdapterinAngular_0.png","tag":["Tech"],"readingTime":15},{"title":"타입스크립트를 사용하여 Express 에러를 프로처럼 처리하는 방법","description":"","date":"2024-06-22 03:26","slug":"2024-06-22-ExpressErrorHandlingLikeaProusingTypescript","content":"\n\n![2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png)\n\n# 소개\n\nExpress는 Node.js를 위한 인기 있는 서버 프레임워크로, 웹 애플리케이션과 API를 만드는 프로세스를 간단히하는 데 사용됩니다.\n\nExpress는 강력하고 유연한 환경을 제공하여 웹 애플리케이션을 구축하는 데 도움이 되지만, 배포 환경으로 사용할 때 신뢰성, 유지 보수성 및 보안을 보장하기 위해 개발자가 주의해야 할 에러 핸들링이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 구조화된 오류 처리 메커니즘은 예기치 못한 충돌을 방지하고 보안 취약점을 노출시키지 않으며, 무언가 잘못되었을 때 의미 있는 오류 메시지를 제공하여 사용자 경험을 향상시킬 수 있습니다. 우리는 Typescript를 사용하여 응용 프로그램에서 오류 처리를 실제로 개선하기 위한 강력한 도구인 이유를 살펴볼 것입니다. 이 기사에서는 프로덕션용 Express 애플리케이션에서 오류를 효과적으로 처리하기 위한 몇 가지 최상의 방법론과 전략을 탐색할 것입니다.\n\n다음 섹션에서 예시 Express 서버를 설정하는 것으로 시작하겠습니다!\n\n# Express 서버 설정\n\n이 기사에서는 Express 서버가 포함된 시작 프로젝트 템플릿을 준비했습니다. 해당 레포지토리에서 프로젝트를 복제할 수 있습니다. 프로젝트를 다운로드한 후, 다음 명령을 실행하여 모든 종속성을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd express-error-handling \u0026\u0026 npm install\n```\n\n이제 프로젝트 구조를 살펴보겠습니다:\n\n![프로젝트 구조](/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_1.png)\n\n서버는 index.ts에서 8000 포트에서 시작되어 듣고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/index.ts **/\n\nimport app from \"./app\";\n\nconst initServer = async () =\u003e {\n  app.listen(8000, () =\u003e {\n    console.log(`Listening on port ${8000}`);\n  });\n}\n\ninitServer();\n```\n\nExpress 서버의 모든 설정은 아래와 같이 app.ts 내에서 수행됩니다:\n\n```js\n/** src/app.ts **/\n\n// 전역 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\nexport default app;\n```\n\n이 예제 서버에서는 routes/users.ts에 위치한 하나의 엔드포인트가 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/routes/users.ts **/\n\nimport { Request, Response, Router } from \"express\";\n\nconst router = Router();\n\nconst userData = [\n  {id: 1, name: \"Sam\"},\n  {id: 2, name: \"Bob\"},\n  {id: 3, name: \"Joe\"},\n];\n\nconst fetchUserData = (): Promise\u003ctypeof userData\u003e =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    const randomNum = Math.floor(Math.random() * 10 + 1);\n    setTimeout(() =\u003e {\n      if(randomNum === 1) {\n        reject(\"오류: 뭔가 잘못되었습니다!\");\n      } else {\n        resolve(userData);\n      }\n    }, 1000);\n  })\n};\n\nconst getHandler = async (req: Request, res: Response) =\u003e {\n  const { id } = req.query;\n  if(!id) {\n    return res.status(400).send({ message: \"Id가 필요합니다!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    return res.status(500).send({ message: err });\n  }\n};\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    return res.status(400).send({ message: \"이름이 필요합니다!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\nrouter.get(\"/users\", getHandler);\nrouter.post(\"/users\", postHandler);\n\nexport default router;\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngetHandler가 비동기이고 postHandler는 동기입니다. 이는 각 라우트 핸들러에서 발생하는 오류를 어떻게 처리할지에 역할을 하며, 나중에 왜 그러한지 알게 될 것입니다. 우선 그것을 염두에두세요.\n\n제공된 코드의 오류 처리 기술은 일반적인 접근 방식과 구체적인 오류 처리의 부재로 인해 프로덕션 수준 애플리케이션에 적합하지 않습니다. 이것은 작은 프로젝트이기 때문에 즉시 영향을 보지 못할 수 있습니다. 그러나 가령 수백 개의 엔드포인트가 있는 익스프레스 서버가 있고 매일 여러 개발자가 작업하고 있다고 상상해봅시다. 서로 다른 엔드포인트를 통해 동일 유형의 오류에 대한 클라이언트 연결이 동일한 응답을 받도록 일관된 오류 인터페이스를 어떻게 보장할 수 있을까요?\n\n예를 들어, getHandler에서 요청에 id 쿼리 매개변수가 지정되지 않았다면 상태 코드 400과 메시지 속성이 있는 객체로 응답을 보냅니다. 새로운 개발자가 분리된 엔드포인트에서 작업하다가 동일 유형의 오류에 대해 같은 유형의 응답을 보내려고 하지만 오류 속성을 포함한 객체를 사용하기로 결정한다고 상상해 봅시다. 이 경우 연결된 클라이언트는 서버에서 유래할 수 있는 모든 가능한 오류 형식을 알아야 하므로 이는 지속 가능한 패턴이 아닙니다.\n\n다음 섹션에서 익스프레스 서버에서 올바른 오류 처리에 사용되는 기술을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Express 기본 오류 처리기\n\nExpress 기본 오류 처리기는 Express에서 제공하는 내장 오류 처리 미들웨어입니다. 이는 응닑-요청 주기 동안 발생하는 오류를 처리하는 대체 메커니즘으로 작용하지만 응용 프로그램의 라우트 핸들러나 사용자 정의 오류 미들웨어에서 명시적으로 처리되지 않은 경우에 대비합니다.\n\n기본 오류 처리기는 err, req, res 및 next라는 네 개의 인수를 취합니다. err 인수는 오류 객체를 나타내고, req와 res는 각각 요청 및 응답 객체입니다. next 함수는 미들웨어 스택에서 다음 오류 처리 미들웨어(있는 경우)로 오류를 전달하는 데 사용됩니다.\n\n기본 오류 처리기는 개발 중에 처리되지 않은 오류를 빠르게 식별하는 데 유용하지만, 일반적으로 프로덕션 환경에서는 적합하지 않습니다. 프로덕션에서는 보다 견고한 오류 처리를 제공하는 사용자 정의 오류 처리 미들웨어로 기본 오류 처리기를 대체하고, 적절한 로깅, 사용자 친화적인 오류 응답 및 서로 다른 유형의 오류를 구분하는 기능을 제공해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 오류 처리기를 교체하려면 네 가지 인수 (err, req, res 및 next)를 사용하는 사용자 지정 오류 미들웨어를 만들어 해당 미들웨어 내에서 오류 처리 로직을 정의할 수 있습니다. 이렇게 함으로써 오류 응답을 더욱 세밀하게 제어할 수 있으며 응용 프로그램이 제품 환경에서 신뢰성 있게 동작하고 안전하게 운영되도록 할 수 있습니다. 아래에 샘플 사용자 지정 오류 처리기 미들웨어가 표시되어 있습니다.\n\n```js\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) =\u003e {\n  console.error(err);\n  res.status(500).send({ errors: [{ message: \"Something went wrong\" }] });\n};\n```\n\n위의 핸들러는 간단히 err 객체를 가져와서 해당 객체를 로깅한 후에 500 상태로 클라이언트에게 응답을 보냅니다.\n\n미들웨어 폴더를 만들고, 해당 폴더 안에 위의 오류 처리기 코드를 담은 새로운 errors.ts 파일을 만들어 보도록 하겠습니다. 그리고 app.ts 파일 내에서 express 서버와 연결된 내보내기된 에러 핸들러를 연결할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/app.ts **/\n\n// 글로벌 의존성\nimport express from \"express\";\nimport { json } from \"body-parser\";\n\n// 프로젝트 의존성\nimport userRouter from \"./routes/users\";\nimport errorHandler from \"./middlewares/errors\";\n\n// 익스프레스 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우트\napp.use(userRouter);\n\n// 오류 처리\napp.use(errorHandler);  // \u003c--------- errorHandler를 사용 중\n\nexport default app;\n```\n\n즉, 라우트나 미들웨어에서 오류가 발생하면 errorHandler에서 처리됩니다. 그러나 여기에 한 가지 주의해야 할 점이 있습니다. 동기식 라우트 핸들러와 비동기식 라우트 핸들러에서 오류를 처리하는 방법이 다르며 다음 두 섹션에서 그 차이를 알아볼 것입니다.\n\n# 동기식 오류\n\n우선 동기식 라우트 핸들러에서 오류를 처리하는 방법을 살펴봅시다. 이것은 더 쉬운 방식으로 다룰 수 있습니다. users.ts의 postHandler를 아래와 같이 변경해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/** src/routes/users.ts **/\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    throw new Error(\"Name is required!\");\n    // return res.status(400).send({ message: \"Name is required!\" });\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n```\n\n사용자 엔드포인트에 이름이 요청 본문에 포함되지 않은 요청을 보내보세요. 서버는 응답 본문에서 오류 배열과 함께 500 상태 코드로 응답합니다.\n\n동기적 루트 핸들러에서 오류가 발생하면 사용자 정의 오류 처리기 미들웨어가 즉시 잡아내고 클라이언트에 응답을 보내기 전에 사용자 정의 논리를 적용합니다. 이제 다음 섹션에서 비동기 루트 핸들러에서 발생하는 오류를 처리하는 방법을 살펴봅시다.\n\n# 비동기 오류\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 users.ts의 getHandler를 아래와 같이 변경해 봅시다:\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response) =\u003e {\n  const { id } = req.query;\n  if (!id) {\n    throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n이제 id 쿼리 매개변수 없이 사용자 엔드포인트로 GET 요청을 시도해보세요. 놀랍게도 전체 익스프레스 서버가 충돌할 것이고, 이것은 비동기 오류가 기본적으로 익스프레스 오류 처리기에서 잡히지 않기 때문입니다. 비동기 오류를 오류 처리기 미들웨어로 전달하려면 아래와 같이 익스프레스 next 함수를 사용해야 합니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { id } = req.query;\n  if (!id) {\n    return next(new Error(\"Id is required!\"));\n    // throw new Error(\"Id is required!\");\n    // return res.status(400).send({ message: \"Id is required!\" });\n  }\n  \n  try {\n    const fetchedUserData = await fetchUserData();\n    let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n    return res.status(200).send({ data: filteredUserData });\n  } catch (err) {\n    next(err);\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 함수는 일반적으로 인수를 받지 않고 요청을 다음 미들웨어로 이동시키기 위해 호출됩니다. next 함수에 입력을 제공하면 Express 서버에게 모든 것을 건너뛰고 바로 에러 핸들러로 이동해야 한다는 신호를 보냅니다.\n\nfetchUserData가 프라미스를 반환하므로 오류 처리를 위해 try-catch 블록을 구현하고 catch 표현식에서 next 함수를 사용하여 오류를 전파해야 합니다. express-async-errors npm 패키지를 사용하면 next 함수를 사용하지 않고 비동기 라우트 핸들러에서 간단히 오류를 던질 수 있도록 express 라이브러리를 수정하는 방법을 제공합니다.\n\n다음 명령을 실행하여 패키지를 설치할 수 있습니다:\n\n```js\nnpm install express-async-errors\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.ts 파일 안에서 express 라이브러리에 대한 패치가 적용되도록 패키지를 import하세요.\n\n```js\n/** src/app.ts **/\n\n// Global dependencies\nimport express from \"express\";\nimport { json } from \"body-parser\";\nimport \"express-async-errors\";  // \u003c---------- apply async error patch\n\n// Project dependencies\nimport userRouter from \"./routes/users\";\nimport { errorHandler } from \"./middlewares/errors\";\n\n// Express 초기화\nconst app = express();\n\n// 미들웨어\napp.use(json());\n\n// 라우터\napp.use(userRouter);\n\n// 에러 처리\napp.use(errorHandler);\n\nexport default app;\n```\n\n그런 다음 users.ts 파일 안의 getHandler를 수정하여 서버가 크래시하는 걱정없이 간단히 에러를 throw할 수 있습니다.\n\n```js\n/** src/routes/users.ts **/\n\nconst getHandler = async (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { id } = req.query;\n  if(!id) {\n    throw new Error(\"Id is required!\");\n  }\n  \n  const fetchedUserData = await fetchUserData();\n  let filteredUserData = fetchedUserData.filter((user) =\u003e user.id === parseInt(id as string));\n  return res.status(200).send({ data: filteredUserData });\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress에서 오류를 중앙 집중식으로 처리하는 데 도움을 주는 도구가 있으니, 해결해야 할 문제가 아직 몇 가지 더 있습니다:  \n- 모든 오류가 500 응답으로 처리되는 대신 다른 상태 코드로 응답을 보내는 방법은 무엇인가요?  \n- 클라이언트에게 오류 응답을 일관된 형식으로 보장하는 방법은 무엇인가요?  \n\n이것이 TypeScript가 우리를 도와줄 부분이며, 다음 섹션에서 왜 도와주는지 볼 것입니다.  \n\n# 사용자 정의 오류 클래스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고객에게 반환하는 오류에 일관된 인터페이스를 보장하기 위해 TypeScript에서 사용자 정의 오류 클래스를 만들 수 있습니다. 이를 통해 더 구조화되고 의미 있는 오류 응답을 제공할 수 있습니다. 사용자 정의 오류 클래스를 사용하면 특정 오류 정보를 캡슐화하고 응용 프로그램 전반에서 일관된 오류 객체를 만들 수 있습니다.\n\n우리는 아래와 같이 CustomError 추상 클래스를 생성하면서 시작합니다.\n\n```js\n/** src/errors/CustomError.ts **/\n\nexport type CustomErrorContent = {\n  message: string,\n  context?: { [key: string]: any }\n};\n\nexport abstract class CustomError extends Error {\n  abstract readonly statusCode: number;\n  abstract readonly errors: CustomErrorContent[];\n  abstract readonly logging: boolean;\n\n  constructor(message: string) {\n    super(message);\n\n    // 내장 클래스를 확장하고 있기 때문에 사용합니다.\n    Object.setPrototypeOf(this, CustomError.prototype);\n  }\n}\n```\n\nCustomErrorContent 유형은 오류 메시지의 구조를 정의합니다. 이는 필수 메시지 필드와 선택적 context 필드(추가적인 오류 관련 데이터를 보유하는 키-값 객체)를 포함합니다. 반면에 CustomError 추상 클래스는 특정 사용자 정의 오류 클래스를 만드는 데 기본 역할을 합니다. 이 클래스는 statusCode(오류 응답에 보낼 HTTP 상태 코드를 나타냄), errors(구체적인 오류 세부 정보를 가진 CustomErrorContent 객체 배열), logging(오류를 로깅해야 하는지 여부를 나타내는 부울값) 세 가지 추상 속성을 구현하도록 강제합니다. 이 추상 클래스 자체는 기본 내장 Error 클래스를 확장하므로 stack 및 cause와 같은 속성에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCustomError 클래스를 확장하고 추상 속성을 구현함으로써 다양한 오류 시나리오를 처리하는 일관성 있고 구조화된 확장 가능한 오류 클래스를 만들 수 있습니다. 예를 들어, 아래와 같이 일반적인 BadRequestError 클래스를 생성할 수 있습니다.\n\n```js\n/** src/errors/BadRequestError **/\n\nimport { CustomError } from \"./CustomError\";\n\nexport default class BadRequestError extends CustomError {\n  private static readonly _statusCode = 400;\n  private readonly _code: number;\n  private readonly _logging: boolean;\n  private readonly _context: { [key: string]: any };\n\n  constructor(params?: {code?: number, message?: string, logging?: boolean, context?: { [key: string]: any }) {\n    const { code, message, logging } = params || {};\n    \n    super(message || \"Bad request\");\n    this._code = code || BadRequestError._statusCode;\n    this._logging = logging || false;\n    this._context = params?.context || {};\n\n    // 내장 클래스를 확장하는 경우만 필요\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n\n  get errors() {\n    return [{ message: this.message, context: this._context }];\n  }\n\n  get statusCode() {\n    return this._code;\n  }\n\n  get logging() {\n    return this._logging;\n  }\n}\n```\n\n이 클래스는 CustomError 클래스를 확장하고 Express 서버 애플리케이션에서 잘못된 요청 시나리오를 처리하기 위해 설계되었습니다. 이 클래스에는 HTTP 상태 코드를 나타내는 _code, 로깅 플래그를 나타내는 _logging, 그리고 오류에 대한 추가적인 컨텍스트 데이터를 나타내는 _context라는 프라이빗 속성이 포함되어 있습니다. 클래스 생성자는 옵션 params 객체를 인수로 받아 코드, 메시지, 로깅, 컨텍스트를 지정하여 오류를 사용자 정의할 수 있도록합니다. params가 제공되지 않으면 생성자는 오류 메시지(\"Bad request\")와 상태 코드(400)에 대한 기본값을 설정합니다. 이 사용자 정의 오류 클래스를 위한 구체적인 오류 세부 정보를 반환하도록 구현된 errors, statusCode 및 logging Getter 메서드가 있습니다. 이것들이 CustomError 클래스에 의해 강제됨에 유의하세요.\n\n우리는 사용자 엔드포인트의 postHandler에서 BadRequestError 클래스를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n/** src/routes/users.ts **/\n\n// ***\n\nconst postHandler = (req: Request, res: Response) =\u003e {\n  const { name } = req.body;\n  if(!name) {\n    throw new BadRequestError({code: 400, message: \"Name is required!\", logging: true});\n  }\n\n  const newUser = {\n    id: userData.length + 1,\n    name,\n  };\n\n  userData.push(newUser);\n  return res.status(201).send({ data: newUser });\n};\n\n// ***\r\n```\n\n마지막으로, 사용자 지정 오류 처리 미들웨어 내에서 표를 Markdown 형식으로 변경할 수 있습니다. 아래의 예시와 같이 CustomError의 인스턴스를 특별히 찾도록 로직을 조정할 수 있습니다.\n\n```js\r\n/** src/middlewares/errors.ts **/\n\nimport { NextFunction, Request, Response } from \"express\";\nimport { CustomError } from \"../errors/CustomError\";\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) =\u003e {\n  // 처리된 오류\n  if(err instanceof CustomError) {\n    const { statusCode, errors, logging } = err;\n    if(logging) {\n      console.error(JSON.stringify({\n        code: err.statusCode,\n        errors: err.errors,\n        stack: err.stack,\n      }, null, 2));\n    }\n\n    return res.status(statusCode).send({ errors });\n  }\n\n  // 처리되지 않은 오류\n  console.error(JSON.stringify(err, null, 2));\n  return res.status(500).send({ errors: [{ message: \"문제가 발생했습니다\" }] });\n};\r\n```\n\n미들웨어는 먼저 오류가 CustomError 클래스의 인스턴스인 처리된 사용자 정의 오류인지 확인합니다. 처리된 오류일 경우, 미들웨어는 사용자 지정 오류 객체에서 HTTP 상태 코드, 오류 세부 정보 및 로깅 플래그를 추출합니다. 이 오류에 대해 로깅이 활성화되어 있는 경우, 디버깅 목적으로 콘솔에 오류와 그 스택 트레이스를 로깅합니다. 그런 다음 추출된 오류 세부 정보로 클라이언트에 적절한 응답을 보냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미처리된 오류(사용자 정의 오류가 아닌 오류)의 경우 미들웨어가 오류를 콘솔에 기록하며, 오류 객체의 형식이 지정된 JSON 표현과 함께 스택 추적을 표시합니다. 로깅 후 미들웨어는 클라이언트에게 \"문제가 발생했습니다.\" 라는 기본 오류 메시지와 함께 일반적인 500 Internal Server Error 응답을 보냅니다.\n\n위 구현을 통해 이제 우리는 효과적이고 중앙집중화된 오류 관리를 보장하는 미들웨어를 보유하게 되었으며, 사용자 정의 오류에 대한 특정 응답을 제공하고 디버깅 목적으로 미처리된 오류를 로깅합니다.\n\n# 결론\n\n효과적인 오류 처리는 제품용으로 제작된 안정적이고 견고한 Express 서버 응용 프로그램을 구축하는 중요한 측면입니다. 이 기사에서는 Express 서버에서 TypeScript를 사용하여 프로처럼 오류를 처리하기 위한 다양한 전략과 모범 사례를 탐색했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 예시 Express 서버를 설정하고 Express에서 제공하는 기본 오류 처리 기술의 한계를 확인하며 시작했습니다. 이러한 한계를 극복하기 위해 우리는 사용자 정의 오류 처리 미들웨어를 구현하여 오류 응답을 더 세밀하게 제어하고 응용 프로그램 전반에 걸쳐 일관성을 유지할 수 있도록 했습니다.\n\n우리의 오류 처리 방법 중 하나는 TypeScript를 사용하여 사용자 정의 오류 클래스를 만드는 것이었습니다. 우리는 CustomError라는 추상 기본 클래스를 정의했는데, 이 클래스는 하위 클래스에 statusCode, errors 및 logging과 같은 특정 속성을 강제했습니다. 이 기본 클래스를 확장하고 사용자 정의 오류 클래스에서 이러한 속성을 구현함으로써 일정한 형식을 갖는 체계적이고 의미 있는 오류 응답을 얻었습니다.\n\n우리는 라우트 핸들러에서 동기적 및 비동기적 오류를 효과적으로 처리하는 방법을 배우며, next 함수를 사용하거나 express-async-errors 패키지를 활용하여 비동기적 오류 처리를 간단화했습니다.\n\n이러한 기술을 결합하여 우리는 중앙 집중화된 표준화된 오류 처리 메커니즘을 수립하여 클라이언트가 어떤 종류의 오류나 어떤 엔드포인트를 액세스하더라도 일관된 오류 응답을 받도록 했습니다. 또한, 적절한 경우 콘솔에 오류를 로깅함으로써 디버깅 능력을 향상시키고, 동시에 안전하고 사용자 친화적인 오류 인터페이스를 유지했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하면, TypeScript의 강력한 기능과 잘 구성된 오류 처리 전략을 활용하여 더 견고하고 유지보수가 쉬운 Express 서버 애플리케이션을 구축할 수 있으며, 프로덕션 환경에서 예기치 못한 다운타임을 최소화할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png"},"coverImage":"/assets/img/2024-06-22-ExpressErrorHandlingLikeaProusingTypescript_0.png","tag":["Tech"],"readingTime":16},{"title":"Nextjs 14 앱에서 NextAuth와 Prisma로 인증 구현하는 방법","description":"","date":"2024-06-22 03:25","slug":"2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png\" /\u003e\n\n안녕하세요! 이번 튜토리얼에서는 NextJS 앱에 인증을 추가하는 방법을 Next Auth를 사용하여 보여드릴 거에요. 저는 NextJS 애플리케이션을 실행하기 위해 런타임으로 bun을 사용할 거에요.\n\nStep I : Next 14 프로젝트 설정하기\n\n```js\nbunx create-next-app@latest next-auth-prisma\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 명령어를 입력하시거나 프로젝트 설정을 위해 NextJS의 공식 문서를 참고하시면 됩니다.\n\n단계 II: NextAuth API route 설정\n\nNext 앱을 설치한 후에는 다음 명령어를 통해 앱 안에 next-auth 패키지를 설치해야 합니다.\n\n```js\nbun add next-auth\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 다음 인증에 사용할 인증 옵션을 구성해야 합니다. 기본 폴더로 이동하여 lib라는 새 폴더를 만들고 lib 폴더 안에 auth.ts라는 새 파일을 만들고 다음 코드를 복사하세요.\n\n/lib/auth.ts\n\n```js\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"Email and Password\",\n      credentials: {\n        email: {\n          label: \"Email\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        const user = { id: \"1\", name: \"Admin\", email: \"admin@admin.com\" };\n        return user;\n      },\n    }),\n  ],\n};\n```\n\n위 코드는 다음 인증 구성 설정 프로세스를 보여줍니다. 저는 next-auth에서 CredentialsProvider를 사용했지만 Google, Github, Facebook 등의 다른 프로바이더를 사용할 수 있습니다. 이러한 프로바이더를 구현하려면 해당 프로바이더의 구성에 대해 공식 문서를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 자격 증명 객체에는 로그인 양식에 표시되는 이메일과 비밀번호가 필드로 포함되어 있습니다. 인증 단계에는 목업 사용자 객체를 반환하는 더미 자격 증명이 있습니다.\n\n다음 단계는 NextAuth에서 인증 요청을 처리하는 API 경로를 생성하는 것입니다. 시작하려면 앱 디렉토리 내에 api라는 새 폴더를 만들고 그 안에 auth라는 새 폴더를 만들어주시고 auth 내부에 catch-all-routes 폴더 [...nextauth]을 만든 다음 auth 폴더 내에 route.ts라는 이름의 파일을 만들어주시고 다음 코드를 붙여넣어주세요.\n\n/app/api/auth/[…nextauth]/route.ts\n\n```js\nimport { authOptions } from \"@/lib/auth\";\nimport NextAuth from \"next-auth\";\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프렌들리하게 번역하면 다음과 같습니다:\n\n우리는 이전에 NextAuth 함수 안에서 미리 구성한 authOptions를 가져왔고, next auth 핸들러를 내보냈습니다.\n\n3단계: 버튼 만들기\n\n애플리케이션의 페이지 간 이동을 쉽게 하기 위해 브라우저에 수동으로 URL을 입력하는 대신 버튼을 만들겠습니다. 기본 폴더 내에 components라는 새 폴더를 만들고 buttons.component.tsx라는 파일을 생성하세요.\n\n/components/buttons.component.tsx\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\nimport Link from \"next/link\";\n\nexport const LoginButton = () =\u003e {\n  return (\n    \u003cbutton style={ marginRight: 10 } onClick={() =\u003e signIn()}\u003e\n      Sign in\n    \u003c/button\u003e\n  );\n};\n\nexport const RegisterButton = () =\u003e {\n  return (\n    \u003cLink href=\"/register\" style={ marginRight: 10 }\u003e\n      Register\n    \u003c/Link\u003e\n  );\n};\n\nexport const LogoutButton = () =\u003e {\n  return (\n    \u003cbutton style={ marginRight: 10 } onClick={() =\u003e signOut()}\u003e\n      Sign Out\n    \u003c/button\u003e\n  );\n};\n\nexport const ProfileButton = () =\u003e {\n  return \u003cLink href=\"/profile\"\u003eProfile\u003c/Link\u003e;\n};\n```\n\n이제 홈 컴포넌트에서 버튼들을 import하세요.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\n\nexport default function Home() {\n  return (\n    \u003cmain\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    \u003e\n      \u003cdiv\u003e\n        \u003cLoginButton /\u003e\n        \u003cRegisterButton /\u003e\n        \u003cLogoutButton /\u003e\n        \u003cProfileButton /\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n이제 NextAuth에서 JWT 인증을 추가해야 하므로 프로젝트의 루트 디렉토리 내 .env 파일에 JWT의 시크릿을 정의해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n#.env\n\nNEXTAUTH_SECRET=secret\nNEXTAUTH_URL=http://localhost:3000\n\n이제 http://localhost:3000/를 방문하여 애플리케이션에 액세스하고 홈페이지에서 클릭하여 로그인 버튼을 누르면 로그인 양식으로 이동합니다.\n\n![이미지](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_1.png)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWe have mock credentials, so feel free to use any email and password to submit the form. Once the submission is successful, you will be redirected back to the home page. At that point, you can view the application's cookies.\n\n![Cookie Image](/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_2.png)\n\nStep IV: Integrating with database\n\nFor real-world users, we need to connect to a database. I will be using PostgreSQL as the database and Prisma as the ORM.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 데이터베이스를 생성하고 데이터베이스 URL을 .env 파일에 넣으세요\n\n```js\nDATABASE_URL=postgresql://postgres:pawan123@localhost:5432/next-auth?schema=public\n```\n\n이제 다음 명령어를 사용하여 prisma ORM과 bcryptjs를 설치하여 사용자 비밀번호를 해싱하세요.\n\n```js\nnpm add @prisma/client bcryptjs \u0026\u0026 npm add -D ts-node prisma @types/bcryptjs\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프리즈마를 설정하고 포스트그리스 데이터베이스에 연결하려면 다음 명령을 실행하여 프로젝트에서 프리즈마를 초기화하고 포스트그레스SQL용 데이터 소스를 만드세요.\n\n```js\nnpx prisma init --datasource-provider postgresql\n```\n\n이제 schema.prisma 파일 내에 User 모델을 만들어보세요.\n\n```js\n// 이것은 당신의 프리즈마 스키마 파일입니다.\n// 자세한 내용은 다음 문서에서 확인하세요: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id       String @id @default(uuid())\n  name     String\n  email    String @unique\n  password String\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 새 사용자를 생성하고 데이터베이스에 저장하는 등록 기능을 만들 수 있지만, 나는 직접 데이터베이스에 사용자를 입력할 것이다. 시작하려면 prisma 디렉토리에 seed.ts 파일을 만들고 아래 코드를 복사해 넣어라.\n\nprisma/seed.ts\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\nimport { hash } from \"bcryptjs\";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  const password = await hash(\"password123\", 12);\n  const user = await prisma.user.upsert({\n    where: { email: \"admin@admin.com\" },\n    update: {},\n    create: {\n      email: \"admin@admin.com\",\n      name: \"Admin\",\n      password,\n    },\n  });\n  console.log({ user });\n}\nmain()\n  .then(() =\u003e prisma.$disconnect())\n  .catch(async (e) =\u003e {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n쉽게 테스트 사용자로 데이터베이스에 시드(seed)를 생성할 수 있도록 하기 위해 package.json 파일에 스크립트를 추가할 것이다. 파일을 열어 다음 스크립트를 추가하라:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n    \"prisma\": {\n        \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n    }\n}\n```\n\n이제 다음 명령을 사용하여 마이그레이션을 생성하고 사용자 스키마를 데이터베이스에 푸시하세요.\n\n```js\nnpx prisma migrate dev --name init\n```\n\n마이그레이션을 생성한 후 다음 명령을 사용하여 데이터베이스에 사용자를 시드하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx prisma db seed\n```\n\n이제 PostgreSQL 데이터베이스와 통신할 수 있도록 @prisma/client 패키지를 사용하여 전역 PrismaClient 인스턴스를 생성할 것입니다. 이를 위해 lib 폴더 안에 prisma.ts라는 파일을 만들고 다음 코드를 추가해주세요.\n\n```js\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: [\"query\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n```\n\nPrisma와 데이터베이스 설정을 완료했으니, 이제 auth.ts 파일에서 로그인 양식을 인증할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { prisma } from \"@/lib/prisma\";\nimport { compare } from \"bcryptjs\";\nimport type { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\n\nexport const authOptions: NextAuthOptions = {\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"로그인\",\n      credentials: {\n        email: {\n          label: \"이메일\",\n          type: \"email\",\n          placeholder: \"example@example.com\",\n        },\n        password: { label: \"비밀번호\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !(await compare(credentials.password, user.password))) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          randomKey: \"일부 랜덤 키\",\n        };\n      },\n    }),\n  ],\n};\n```\n\n이제 사용자 정의 키를 추가할 수 있습니다. 다음은 NextAuth 구성의 콜백 속성에서 콜백을 수정하는 방법입니다. 이렇게 하면 세션 개체와 JWT에 필요한 정보를 포함시킬 수 있으며 응용 프로그램에 언제든지 어디서나 액세스할 수 있습니다.\n\n```js\ncallbacks: {\n    session: ({ session, token }) =\u003e {\n      console.log(\"세션 콜백\", { session, token });\n      return {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id,\n          randomKey: token.randomKey,\n        },\n      };\n    },\n    jwt: ({ token, user }) =\u003e {\n      console.log(\"JWT 콜백\", { token, user });\n      if (user) {\n        const u = user as unknown as any;\n        return {\n          ...token,\n          id: u.id,\n          randomKey: u.randomKey,\n        };\n      }\n      return token;\n    },\n  },\n```\n\nStep V: NextAuth 세션 데이터 가져오기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnext 앱 내에서 권한이 부여된 사용자 세션 데이터를 얻는 두 가지 방법이 있습니다.\n\ni. 서버 컴포넌트에서\n\n서버 컴포넌트 내에서 세션 데이터를 가져오기 위해 getServerSession 함수를 사용할 수 있습니다.\n\n```js\nimport {\n  LoginButton,\n  LogoutButton,\n  ProfileButton,\n  RegisterButton,\n} from \"@/components/buttons.component\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\nexport default async function Home() {\n  const session = await getServerSession(authOptions);\n  console.log(session);\n\n  return (\n    \u003cmain\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"70vh\",\n      }}\n    \u003e\n      \u003cdiv\u003e\n        \u003cLoginButton /\u003e\n        \u003cRegisterButton /\u003e\n        \u003cLogoutButton /\u003e\n        \u003cProfileButton /\u003e\n\n        \u003ch1\u003eServer Session\u003c/h1\u003e\n        \u003cpre\u003e{JSON.stringify(session)}\u003c/pre\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 페이지를 무단 사용자로부터 보호하기 위해 미인가 사용자를 signin 페이지로 리다이렉트하는 다음 코드를 사용할 수 있습니다.\n\n```js\nif (!session) {\n    redirect(\"/api/auth/signin\");\n}\n```\n\nii. 클라이언트 컴포넌트\n\n클라이언트 컴포넌트에서 세션 데이터를 검색하려면 next auth에서 제공하는 세션 제공자를 사용하고 앱을 세션 제공자로 래핑해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 디렉토리에 providers 폴더를 만들고, NextAuthProvider.tsx라는 새 파일을 생성한 다음 아래 코드를 붙여넣어주세요.\n\n```js\n\"use client\";\n\nimport { SessionProvider } from \"next-auth/react\";\n\ntype Props = {\n  children?: React.ReactNode;\n};\n\nexport const NextAuthProvider = ({ children }: Props) =\u003e {\n  return \u003cSessionProvider\u003e{children}\u003c/SessionProvider\u003e;\n};\n```\n\n이제 layout.tsx 파일에서 프로바이더를 감싸주세요.\n\n```js\nimport { NextAuthProvider } from \"./providers/NextAuthProvider\";\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        \u003cNextAuthProvider\u003e{children}\u003c/NextAuthProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 세션 데이터를 가져오는 클라이언트 컴포넌트를 생성해보세요.\n\n```js\n\"use client\";\n\nimport { useSession } from \"next-auth/react\";\n\nexport const User = () =\u003e {\n  const { data: session } = useSession();\n\n  return (\n    \u003c\u003e\n      \u003ch1\u003eClient Session\u003c/h1\u003e\n      \u003cpre\u003e{JSON.stringify(session)}\u003c/pre\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n이제 권한이 없는 사용자로부터 클라이언트 컴포넌트를 보호하기 위해 아래 코드를 클라이언트 컴포넌트에 붙여넣어주세요.\n\n```js\nconst { status } = useSession({\n    required: true,\n    onUnauthenticated() {\n      redirect(\"/api/auth/signin\");\n    },\n  });\n\n  if (status === \"loading\") {\n    return \u003cp\u003eLoading....\u003c/p\u003e;\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n이 튜토리얼에서는 NextAuth를 새로운 Next.js 14 앱에 통합하는 방법에 대해 배웠습니다. 이 글이 유익하고 즐거웠기를 바랍니다. 피드백이나 질문이 있으면 언제든 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAuthenticationinaNextjs14AppUsingNextAuthandPrisma_0.png","tag":["Tech"],"readingTime":12},{"title":"Express  Typescript 서버에서 Vue  Vite 설정하는 방법","description":"","date":"2024-06-22 03:22","slug":"2024-06-22-SettingupanExpressTypescriptServerwithVueVite","content":"\n\n\n\n![Setting up an Express TypeScript Server with Vue Vite](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png)\n\n백엔드 개발에 뛰어들기는, 특히 프론트엔드 개발자로써는 미지의 영역에 발을 딛는 것처럼 느껴질 수 있어요. \"프론트엔드 걸리\"를 자처하는 나로서는 솔직히 말하면, 백엔드 개발에 뛰어들기 전에 조심스럽게 느껴졌어요. 그러나 프로젝트의 일부 클라이언트 측 로직을 백엔드로 옮긴 후에야, 서버 측 작업이 상상했던 것만큼 무섭지 않다는 것을 깨달았어요.\n\n백엔드 개발에 대해 제가 느낀 불안을 공감한다면, 여기에 잘 왔어요. 이 블로그에서는 Express 서버를 TypeScript와 통합하는 방법을 안내할 거예요.\n\n초보자를 위한 이 포괄적인 가이드는 다음을 중점적으로 다룰 거예요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript로 Express 서버 설정하기\n- 클라이언트와 서버 간 통신 설정하기\n- Vite를 사용하여 요청 프록시 설정하기\n\n이제 프론트엔드와 백엔드 간의 간극을 좁히러 뛰어들어봅시다! 🚀\n\n# 시작하기\n\n이 튜토리얼의 전체 소스 코드에 액세스하려면 여기에 있는 GitHub 리포지토리를 방문해주세요. 서버 및 클라이언트 환경 변수를 추가하는 것을 잊지 마세요. 클론하거나 포크하거나 리포지토리를 별표로 표시하여 차후 참고 및 실험에 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. 터미널에서 명령어 node -v를 실행하여 Node.js가 설치되어 있는지 확인할 수 있습니다. 설치되어 있다면 설치된 버전이 표시됩니다. 그렇지 않다면 여기를 클릭하여 Node.js를 설치할 수 있습니다.\n\n## 서버 설정하기\n\n백엔드를 설정하는 첫 번째 단계는 적절한 기술 스택을 선택하는 것입니다. Express.js를 사용할 것이며, 이는 간결함과 유연성으로 유명한 Node.js 프레임워크입니다. 추가로 TypeScript를 활용하여 서버 측 코드베이스에 정적 타이핑을 도입할 것입니다.\n\n## 프로젝트 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 새 디렉토리를 만들고 npm을 사용하여 새 Node.js 프로젝트를 초기화할 것입니다. 초기화된 후 Express 및 TypeScript를 포함한 필수 종속성을 설치하기 위해 각각의 명령을 실행할 것입니다.\n\n- 새 디렉토리 만들기\n\n우리는 스타터 프로젝트를 위한 새 디렉토리를 만들어 시작할 것입니다. 이를 위해 당신의 운영 체제의 터미널 또는 파일 탐색기를 사용할 수 있습니다.\n\n```js\nmkdir express-starter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 프로젝트 디렉토리로 이동해주세요.\n\n디렉토리가 생성되면 cd 명령어를 사용하여 해당 디렉토리로 이동해주세요.\n\n```js\ncd express-starter\n```\n\n3. 서버 및 클라이언트 폴더를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nexpress-starter 디렉토리에 들어간 후, 두 개의 폴더를 만들어주세요: client와 server 폴더를 만들어주세요. 그런 다음 server 폴더로 이동해주세요.\n\n```js\nmkdir server client cd server\n```\n\n4. 새로운 Node.js 프로젝트 초기화하기.\n\nnpm init을 사용하여 새로운 Node.js 프로젝트를 초기화하세요. 이렇게 하면 package.json 파일이 생성되며, 프로젝트와 의존성에 대한 메타데이터가 저장됩니다. 프롬프트를 따르거나 -y 플래그를 사용하여 모든 프롬프트에 대한 기본값을 수락할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm init -y\n```\n\n5. 의존성 설치하기.\n\n이제, 프로젝트에 필요한 의존성을 설치해보겠습니다.\n\n```js\n# dependencies \nnpm install express cors dotenv  \n\n# development dependencies \nnpm install -D typescript @types/cors @types/node @types/express nodemon\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 종속성이 무엇을 하는지 간단히 살펴봅시다.\n\n- express: 우리가 서버를 구축하기 위해 사용할 Node.js의 웹 프레임워크입니다.\n- typescript: TypeScript 컴파일러 및 언어입니다. 프로젝트를 타입 안전하게 유지하고 런타임 이전에 버그를 잡을 수 있게 합니다.\n- cors: Cross-Origin Resource Sharing은 교차 출처 요청을 허용하여 백엔드 API가 다른 포트에서 실행되더라도 클라이언트에서 안전하게 액세스할 수 있도록 합니다.\n- dotenv: .env 파일에서 환경 변수를로드합니다.\n- nodemon: Nodemon은 변경 사항을 감지하면 자동으로 노드 응용 프로그램을 다시 시작합니다. 이는 변경 사항이 적용되기 위해 응용 프로그램을 중지하고 다시 시작할 필요가 없다는 것을 의미합니다.\n- @types/node, @types/cors 및 @types/express: Node.js, Cors 및 Express에 대한 유형 정의로 TypeScript 지원을 활성화합니다.\n\n의존성 대 개발 의존성\n\n-D 플래그를 사용하여 설치 중에 일부 dev 종속성을 추가했지만, 왜 필요했을까요? 개발 의존성은 개발 중에만 필요한 모듈로, 종속성은 런타임에서 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성\n\n의존성은 우리 애플리케이션이 올바르게 작동하기 위해 필요한 필수 패키지입니다. npm install을 실행하면 이러한 패키지가 설치됩니다. 이러한 패키지는 package.json 파일의 의존성 섹션에 나열됩니다. 이러한 패키지 없이 배포된 앱은 작동하지 않을 수 있습니다.\n\n개발 의존성\n\n반면에 개발 의존성은 개발 및 테스트 목적에만 필요합니다. 이러한 패키지는 앱이 정상적으로 실행되기 위해 반드시 필요한 것은 아니지만, 빌드, 테스트 및 코드 린팅과 같은 작업에 중요합니다. 이러한 패키지들은 package.json의 devDependencies 섹션에 명시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. tsconfig.json 생성하기\n\nTypeScript를 구성하기 위해 tsconfig.json 파일을 생성하세요. 이 파일은 TypeScript가 코드를 컴파일하는 방법을 지정합니다. npx tsconfig.json을 실행한 후 Node를 선택하세요. 이 명령은 일부 기본 설정이 포함된 tsconfig.json 파일을 생성합니다.\n\n```sh\nnpx tsconfig.json\n```\n\n7. 소스 파일 생성 및 package.json 업데이트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, src 디렉토리를 생성하세요. src 디렉토리 안에 우리의 주 파일인 main.ts를 만들 것입니다.\n\n```js\n# src 폴더 생성\nmkdir src\n\n# 폴더로 이동\ncd src\n\n# .ts 파일 생성\ntouch main.ts\n\n# src에서 나와서 서버 디렉토리로 돌아갑니다\ncd ..\n```\n\npackage.json에서 엔트리 포인트를 index.js 대신 main.js로 수정하세요.\n\n```js\n\"main\": \"main.js\",\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n8. .env 파일을 생성하세요.\n\n환경 변수를 구성하기 위해 .env 파일을 만듭니다 (예: API 키). 이 파일은 민감한 정보가 노출되지 않도록 버전 관리에서 제외되어야 합니다. 서버 폴더의 루트에 .env 파일을 생성하세요.\n\n```js\ntouch .env\n```\n\n9. .gitignore 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.gitignore 파일을 만들어서 버전 관리에서 무시해야 할 파일과 디렉토리를 지정하여 불필요한 파일을 커밋하는 것을 피해야 합니다. 서버 폴더의 루트에 .gitignore 파일을 생성하세요. 우선 node_modules와 .env*를 추가하겠습니다. *는 Git에게 .env로 시작하는 모든 파일이나 폴더를 무시하도록 지시합니다.\n\n```js\n.env* \nnode_modules/\n```\n\n이 시점에서 프로젝트 구조는 다음과 같을 수 있습니다:\n\n```js\nexpress-starter/\n├── client/\n└── server/\n    ├── node_modules/\n  └── src/\n        └── main.ts\n  ├── .env\n  ├── .gitignore\n    ├── package.json\n    ├── tsconfig.json\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 설정을 마쳤으니 이제 서버를 생성해봅시다.\n\n# 서버 생성\n\nsrc/main.ts 파일 안에 다음 스니펫을 추가하세요.\n\n```js\n// server/src/main.ts\n\nimport cors from 'cors';\nimport 'dotenv/config';\nimport express from 'express';\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst PORT = process.env.PORT || 3001;\n\napp.get('/api', (_req, res) =\u003e {\n  res.status(200).json({ message: '서버에서 안녕하세요!' });\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 기본 express 서버입니다. 이 앱은 서버를 시작하고 지정된 포트에서 연결을 수신 대기합니다. /api 경로에 대한 요청에 대해 \"서버에서 안녕하세요!\"라고 응답합니다. 코드가 무엇을 하는지 이해해 봅시다.\n\n- 미들웨어 설정\n\napp.use()는 미들웨어를 등록하는 방법입니다. 미들웨어는 서버가 특정 요청을 처리하기 전에 실행하는 특별한 함수들입니다. 미들웨어는 서버가 요청을 수신하고 클라이언트에게 응답을 보내는 순간 사이에서 작동합니다.\n\n우리의 경우, 몇 가지 전역 미들웨어를 등록했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- cors: 이 미들웨어는 서버가 서로 다른 소스/출처에서 오는 요청을 수락할 수 있도록 합니다.\n- express.json(): 들어오는 요청을 JSON 형식으로 파싱합니다.\n- express.urlencoded('extended: true'): 요청에서 폼 데이터를 파싱합니다.\n\n2. 라우트 설정\n\napp.get(`/api`)은 특히 /api URL로의 GET 요청에 대한 라우트 핸들러를 설정합니다. 이 라우트로 GET 요청이 올 경우, 서버는 상태 코드 200과 \"서버에서 인사합니다!\" 메시지로 응답합니다.\n\n3. 서버 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.listen()은 지정된 포트(PORT)에서 Express 앱을 수신하여 시작합니다. 환경 변수에 포트가 지정되지 않은 경우 기본값은 포트 3001입니다.\n\n이 설정으로 서버를 실행하는 한 걸음 더 나아갈 수 있습니다.\n\n# TypeScript로 Nodemon 구성하기\n\nmain.ts를 실행하려면 서버 디렉토리 내에서 node src/main.ts를 실행할 수 있지만, \".ts\" 라는 알 수 없는 파일 확장자 오류가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode와 TypeScript\n\n`node src/main.ts`를 실행할 때 Node.js가 TypeScript 파일을 직접 실행할 것으로 기대할 수 있습니다. 그러나 Node.js는 TypeScript를 네이티브로 이해하지 않습니다. JavaScript만을 이해합니다.\n\nTypeScript는 JavaScript의 확장이므로 TypeScript 코드는 Node.js에서 실행되기 전에 JavaScript로 컴파일되어야 합니다. 이 컴파일 과정은 .ts 파일을 Node가 이해할 수 있는 동등한 .js 파일로 변환합니다.\n\n서버 코드를 실행하려면 먼저 TypeScript 컴파일러(tsc)를 사용하여 TypeScript 코드를 JavaScript로 변환해야 합니다. 이를 통해 컴파일된 JavaScript 코드가 포함된 dist/main.js 파일이 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 모든 TypeScript 파일을 JavaScript로 컴파일\nnpx tsc\n\n# 생성된 JavaScript 파일 실행\nnode dist/main.js\n```\n\n위의 명령어에서 npx tsc는 TypeScript 컴파일러(tsc)를 호출하여 프로젝트의 모든 TypeScript 파일을 JavaScript로 컴파일합니다. 그 결과로 생성된 JavaScript 파일은 dist 디렉토리에 출력됩니다. 생성된 JavaScript 파일은 Node.js를 사용하여 실행할 수 있습니다.\n\n컴파일된 JavaScript 파일의 출력 디렉토리는 tsconfig.json 파일의 outDir 속성을 사용하여 지정됩니다.\n\n```js\n// server/tsconfig.json\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, dist 폴더를 .gitignore 파일에 포함시켜야합니다. 이렇게 하면 컴파일된 JavaScript 파일이 버전 관리에 포함되지 않습니다.\n\n```js\n// server/.gitignore\n\nnode_modules\ndist\n.env*\n```\n\nNodemon을 사용하여 변경 사항 감지\n\nTypeScript 파일을 수정할 때마다 npx tsc 및 node dist/main.js를 사용하여 파일을 수동으로 다시 컴파일하고 실행해야합니다. 이러한 반복 작업은 빠르게 지루해질 수 있습니다. 이 과정을 간소화하기 위해 nodemon이라는 도구를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodemon은 디렉토리 내 파일 변경을 감지하여 Node.js 기반 애플리케이션을 자동으로 다시 시작하는 도구입니다. 이를 이용하면 코드를 수정할 때마다 서버를 수동으로 중지하고 다시 시작하는 수고를 덜 수 있습니다.\n\nNodemon은 이미 설치했으므로 이제 구성만 남았습니다.\n\nNodemon 구성하기\n\nNodemon을 구성하려면 package.json에 nodemonConfig를 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n// server/package.json\n\n\"scripts\": {\n    \"dev\": \"nodemon\"\n  },\n  \"nodemonConfig\": {\n    \"watch\": [\n      \"src\"\n    ],\n    \"exec\": \"tsc \u0026\u0026 node ./dist/main.js\",\n    \"ext\": \"ts,js,json\"\n  },\n```\n\nnodemonConfig 섹션은 파일 변경을 모니터링할 때 nodemon이 어떻게 동작해야 하는지 알려줍니다:\n\n- watch: nodemon에게 src 폴더 내의 변경 사항을 모니터링하도록 지시합니다.\n- ext: 변경 사항을 모니터링할 파일 확장자를 지정합니다 (ts, js, json).\n- exec: 변경 사항이 감지되었을 때 실행할 명령을 정의합니다. 이 경우 TypeScript 파일을 컴파일하고 node ./dist/main.js를 실행하여 서버를 시작합니다.\n\n이제 npm run dev를 실행하여 간단히 nodemon과 함께 서버를 시작할 수 있습니다. 파일 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하는 프로세스가 자동화됩니다. 이 변경 사항으로 서버는 요청을 받을 준비가 되었습니다. Postman과 같은 API 플랫폼이 있다면 http://localhost:3001/api에 GET 요청을 보내보거나 브라우저에서 링크를 방문하여 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 클라이언트 설정\n\n저희 서버는 클라이언트로부터의 요청을 받을 준비가 되어 있습니다. 프론트엔드에서는 Vue를 사용할 것입니다. Vue는 Vite를 기반으로 한 빌드 설정을 사용하며, 이를 우리 서버와 통신하도록 구성할 것입니다. 시작해봅시다.\n\n- 클라이언트 디렉토리로 이동하기\n\n먼저 서버 디렉토리를 중지하고 종료한 후, 클라이언트로 이동해보겠습니다. 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러 중지한 다음, 다음 명령어를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 서버 디렉토리를 나와 클라이언트로 이동 \ncd ../client\n```\n\n2. Vue 프로젝트 생성\n\nVue 앱을 만들려면 다음 명령을 실행하세요. 이 명령은 . .에 의해 지정된 클라이언트 폴더에 직접 프로젝트를 생성합니다.\n\n```js\nnpm create vue@latest .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 선택지를 만들어 몇 가지 선택을 해야 할 것입니다. 패키지 이름과 TypeScript 지원에 대해 고민할 차례입니다. 당신의 프로젝트를 위해 express-vue로 이름을 지어주고 TypeScript 지원에 \"예\"를 선택하되, 다른 선택 가능한 기능들에 대해서는 \"아니요\"를 선택하여 프로젝트를 간단하게 유지해주세요.\n\n그 다음, 의존성을 설치하고 개발 서버를 시작해보세요.\n\n```js\n# 의존성 설치\nnpm install\n\n# 개발 서버 시작\nnpm run dev\n```\n\n이제 http://localhost:5173/에서 Vue 프로젝트가 실행 중일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. .env 파일 추가\n\n다음 변수를 사용하여 클라이언트 폴더의 루트에 .env 파일을 추가하십시오.\n\n```js\nVITE_SERVER_URL=http://localhost:3001\nVITE_SERVER_API_PATH=/api\n```\n\n.env 파일을 변경하면 서버를 다시 시작해야 할 수도 있습니다. 서버를 중지하려면 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러주세요. 그런 다음 서버를 다시 시작하려면 npm run dev를 다시 실행해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. vite.config.ts 파일 업데이트\n\n우리는 vite.config.ts 파일을 사용하여 클라이언트와 서버 간의 통신을 활성화하기 위해 파일을 사용자 정의하고 싶어요. defineConfig은 Vite 프로젝트에서 구성 옵션을 정의하는 데 사용되는 도우미 함수입니다. defineConfig은 객체나 함수 둘 중 하나를 인수로 받을 수 있어요. 환경 변수를 로드할 수 있도록 함수를 전달할 거에요.\n\n```js\nimport { fileURLToPath, URL } from 'node:url';\n\nimport vue from '@vitejs/plugin-vue';\nimport { defineConfig, loadEnv } from 'vite';\n\n// \u003chttps://vitejs.dev/config/\u003e\nexport default defineConfig((env) =\u003e {\n  const envars = loadEnv(env.mode, './');\n\n  const serverURL = new URL(\n    envars.VITE_SERVER_URL ?? '\u003chttp://localhost:3001\u003e'\n  );\n  const serverAPIPath = envars.VITE_SERVER_API_PATH ?? '/api';\n\n  return {\n    envDir: './',\n\n    // 클라이언트에서 API 경로를 전역적으로 사용할 수 있도록 함\n    define: {\n      __API_PATH__: JSON.stringify(serverAPIPath),\n    },\n\n    plugins: [vue()],\n    resolve: {\n      alias: {\n        '@': fileURLToPath(new URL('./src', import.meta.url)),\n      },\n    },\n\n    server: {\n      port: 5173,\n      proxy: {\n        // API 경로를 가진 요청을 서버로 프록시함\n        // \u003chttp://localhost:5173/api\u003e -\u003e \u003chttp://localhost:3001/api\u003e\n        [serverAPIPath]: serverURL.origin,\n      },\n    },\n  };\n});\n```\n\n이 설정의 각 부분이 어떤 역할을 하는지 살펴보도록 하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 환경 변수 로딩: loadEnv 함수를 사용하여 현재 모드(예: 개발, 프로덕션)에 기반하여 환경 변수를 로드합니다. 프로젝트 디렉토리에 있는 .env 파일을 읽고 변수를 envars 객체에 로드합니다.\n- 서버 URL 및 API 경로 구문 분석: 서버 URL 및 API 경로가 구문 분석되며, .env 파일에서 찾지 못한 경우 기본값이 제공됩니다.\n\n구성 옵션:\n\n- envDir: 환경 변수가 위치한 디렉토리를 지정합니다.\n- define: 빌드 과정 중에 대체될 전역 상수를 정의할 수 있습니다. 이 경우 __API_PATH__는 서버 API 경로 값으로 정의됩니다.\n- plugins: 프로젝트에서 사용하는 Vite 플러그인을 지정합니다. 여기서 Vue.js 플러그인(vue())이 추가됩니다.\n- resolve.alias: 모듈 해상도를 위한 별칭을 정의합니다. 이 경우 @ 별칭이 src 디렉토리로 설정됩니다.\n\n서버 구성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- server.port: Vite 개발 서버가 실행될 포트를 지정합니다. 여기서는 5173으로 설정되어 있어요.\n- server.proxy: 프록시 설정은 클라이언트와 서버 간 통신을 가능하게 합니다. API 경로와 일치하는 요청은 서버 URL로 전달됩니다. http://localhost:5173/api로 요청을 보내면 http://localhost:3001/api로 우리 서버로 전달됩니다.\n\n5. 전역 상수 선언\n\nvite.config.ts 파일에 전역 상수를 추가한 후, TypeScript가 이 상수를 인식하여 타입 확인을 수행하게 만들어야 합니다. env.d.ts 파일에 타입 정의를 선언하여 이를 달성할 수 있어요.\n\n```js\n// client/env.d.ts  \n\n/// \u003creference types=\"vite/client\" /\u003e \ndeclare const __API_PATH__: string;\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 선언에서는 TypeScript에 __API_PATH__ 상수의 존재를 알리고, 해당 타입을 문자열로 지정합니다. 이는 TypeScript가 프로젝트 전체에서 이 글로벌 상수에 대한 유형 확인 및 IntelliSense 지원을 제공하도록 보장합니다.\n\n6. 서버에 요청 보내기\n\n이제 Vite 프로젝트를 서버와 통신하도록 구성했으므로 App.vue 파일을 업데이트하여 서버로부터 요청을 보내고 응답을 화면에 표시해 보겠습니다. 다음 스니펫은 Vue.js composition API를 사용하여 서버에서 데이터를 가져와 앱에 표시하는 방법을 보여줍니다.\n\n```js\n// client/src/App.vue\n\n\u003cscript setup lang=\"ts\"\u003e\nimport { ref } from \"vue\";\n\n// API 기본 URL을 포함하는 전역 상수 -\u003e /api\nconst baseURL = __API_PATH__;\n\n// 로딩 상태 및 응답 메시지 관리를 위한 반응형 변수\nconst isLoading = ref(false);\nconst message = ref(\"\");\n\n// 서버에서 데이터를 가져오는 함수\nasync function fetchAPI() {\n  try {\n    // 로딩 상태를 true로 설정\n    isLoading.value = true;\n\n    // 서버에 GET 요청 보내기\n    const response = await fetch(baseURL);\n\n    // JSON 응답 해석\n    const data = await response.json();\n\n    // 응답 데이터로 메시지 업데이트\n    message.value = data.message;\n  } catch (error) {\n    // 오류 처리\n    message.value = \"데이터 검색 오류\";\n    console.error(error);\n  } finally {\n    // 로딩 상태 재설정\n    isLoading.value = false;\n  }\n}\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003c!-- fetchAPI 함수를 실행하는 버튼 --\u003e\n  \u003cbutton @click=\"fetchAPI\"\u003e가져오기\u003c/button\u003e\n\n  \u003c!-- 데이터를 가져올 때 로딩 메시지 표시 --\u003e\n  \u003cp v-if=\"isLoading\"\u003e로딩 중...\u003c/p\u003e\n\n  \u003c!-- 사용 가능한 경우 응답 메시지 표시 --\u003e\n  \u003cp v-else-if=\"message\"\u003e{ message }\u003c/p\u003e\n\u003c/template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 스니펫에서:\n\n- 우리는 Vue의 composition API에서 ref 함수를 가져와 반응형 변수를 생성하여 로딩 상태(isLoading)와 응답 메시지(message)를 관리합니다.\n- fetchAPI 함수는 fetch API를 사용해 서버로 GET 요청을 보내는 데 정의됩니다.\n- 요청이 처리되는 동안 로딩 상태가 true로 설정되고 로딩 메시지가 표시됩니다.\n- 요청이 완료되면 로딩 상태가 재설정되고 서버로부터의 응답 메시지가 표시됩니다.\n- 요청 중에 발생하는 모든 오류는 catch되어 메시지가 업데이트됩니다.\n\n이러한 업데이트로 인해, Vue 애플리케이션은 서버에서 데이터를 가져와 사용자에게 표시할 수 있습니다.\n\n7. 두 서버를 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 클라이언트가 실행 중이므로 서버를 시작해야 합니다. VS Code를 사용 중이라면, 메뉴 바에서 Terminal 옵션을 마우스 오른쪽 클릭하고 New Terminal을 선택하여 새 터미널을 열 수 있습니다. 또는 새 터미널 창을 열어 프로젝트 디렉토리로 이동할 수도 있어요. 프로젝트 디렉토리에 들어간 후 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\ncd server\nnpm run dev\n```\n\n위의 명령어를 실행하면 서버 디렉토리로 이동한 후 개발 모드에서 서버가 시작됩니다.\n\n8. 클라이언트 측 요청 초기화.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이언트에서 App.vue에서 버튼을 클릭하여 요청을 트리거하는 것이 마지막 단계입니다. 이렇게 하면 서버로 요청이 전송됩니다.\n\n# 결론\n\n축하합니다! 🎉 Express.js 및 TypeScript를 사용하여 백엔드에 Vue.js 및 Vite를 사용하는 풀스택 웹 개발 환경을 구축하는 방법을 성공적으로 배우셨습니다.\n\n이 가이드에서 다룬 내용은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 백엔드 설정: TypeScript로 Express.js 서버를 초기화하고 미들웨어를 구성하며 노드.js에서 실행할 수 있도록 코드를 컴파일하는 것부터 시작했습니다.\n- 프론트엔드 구성: 다음으로, 클라이언트와 서버 간의 통신을 허용하도록 Vite를 구성했습니다. 특정 요청을 서버로 프록시하기 위해 Vite의 서버 옵션을 활용했습니다.\n- 클라이언트-서버 통신: 환경을 설정한 후, Vue.js composition API를 사용하여 프론트엔드에서 백엔드로 요청을 보내는 방법을 배웠습니다. 서버에서 데이터를 가져와 UI를 업데이트하여 반응형 웹 애플리케이션을 만들었습니다.\n\n서버 측 로직 작업에 대한 걱정이 줄어들었기를 바라며, 동적 웹 애플리케이션을 구축하는 기초를 마련했으니 실험을 계속해보고, 계속해서 개발하고, 풀스택 부분에 더 깊이 파고들기를 주저하지 마십시오.\n\n즐거운 코딩!\n\n![이미지](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_1.png)","ogImage":{"url":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"},"coverImage":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png","tag":["Tech"],"readingTime":15},{"title":"TypeScript의 객체 리터럴 타입 이해하기 특이점과 인사이트","description":"","date":"2024-06-22 03:21","slug":"2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights","content":"\n\n\n![Understanding TypeScript's Handling of Object Literal Types](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png)\n\n안녕하세요! TypeScript의 객체 리터럴 형식 처리는 때로 예상치 못한 동작을 일으킬 수 있다는 사실을 알고 계셨나요? TypeScript를 배우기 시작했을 때 나는 가끔 일어나는 이 문제로 어려움을 겪었습니다. 이것은 일관성이 없어 보이는 TypeScript의 동작 때문에 처음에는 감이 오지 않았습니다.\n\n맥락을 좀 더 설명하자면, TypeScript는 현대적 웹 애플리케이션을 구축하기 위한 타입 안전성과 고급 기능을 제공하는 Javascript의 상위 집합체로서 작용합니다. TypeScript는 선택적 정적 타이핑을 도입하여 개발자가 개발 과정 초기에 오류를 빨리 찾아내고 더 신뢰할 수 있는 코드를 작성할 수 있게 지원합니다.\n\n기본적으로, TypeScript는 이러한 상황에서 도와줍니다 (조금 미묘한 암시가 있음):-\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_1.png)\n\n![UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_2.png)\n\n그러면 블로그 주제로 넘어가 보겠습니다. 타입스크립트에 의한 객체 리터럴의 일관되지 않은 처리에 대해 다루고 있습니다. 제가 말하는 것은 객체를 다룰 때 타입스크립트의 행동에 대해 어떤 불일치가 관찰될 수 있다는 것입니다. 설명을 듣겠습니까?\n\n# 이슈 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자를 생성하는 데 사용되는 기본 함수입니다. 기능이 작성되지 않은 빈 함수이지만, 여기서 다루는 문제는 기능의 유무가 아닙니다. 문제는 거의 동일한 약간의 차이가 있는 두 가지 다른 방법으로 호출할 때 발생합니다.\n\n다음과 같은 자잘한 차이점이 있습니다.\n\n함수에 기대하는 매개변수(이름 및 isPaid)에 email이라는 추가적인 인수를 전달하여 함수를 호출하면 오류가 발생합니다. 이는 함수를 선언할 때 정의되지 않았기 때문에 예상하지 못했던 것입니다. 꽤 기본적인 문제죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 우리가 객체를 함수의 인수로 전달하는 방식을 약간 수정하면 이 오류가 말이 안 되기 시작합니다. 우리가 바로 전달한 객체를 변수에 할당한 뒤에 변수를 함수에 전달하는 방식으로 바꾸는 것인데, 이전과 동일한 오류가 발생해야 했지만 오류가 발생하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_5.png)\n\n제가 말한 불일치입니다. 이런 일이 발생한 이유와 이를 방지할 수 있는 방법에 대해 논의하고 싶습니다.\n\n# 이런 일이 발생한 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript의 설계 결정 사항 중 Excess Property Checking과 Structural Typing 때문에 오류가 발생합니다.\n\n이 동작의 핵심은 TypeScript가 초과 속성을 확인하는 방식에 있습니다. 직접 객체 리터럴을 전달할 때 TypeScript는 함수에 추가적인 속성이 전달되지 않도록 엄격한 초과 속성 확인을 수행합니다. 이것은 잠재적인 오류를 빨리 발견하기 위한 것입니다.\n\n반면, 객체가 변수에 할당된 경우 TypeScript는 이 엄격한 확인을 건너뜁니다. 그 이유는 해당 추가 속성이 있는 객체가 코드 다른 곳에서 사용될 수 있으며, TypeScript는 이러한 경우에 더 많은 유연성을 허용합니다. 이를 구조적 타이핑이라고하며, TypeScript는 객체가 즉시 리터럴이 아닌 경우 필수 속성만을 확인하고 추가 속성을 무시합니다.\n\n## 관용구에는 말이 있듯이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_6.png\" /\u003e\n\n변수에 객체를 할당하고 함수에 전달할 때, TypeScript는 구조적 타이핑을 활용합니다. 이는 객체가 기대되는 타입 구조를 준수하는 한 추가적인 속성을 가질 수 있게 합니다. 이 접근법은 더 융통성이 있고 유연합니다.\n\n장점:-\n\n유연성: 객체를 다양한 맥락에서 더 다재다능하게 사용할 수 있습니다. 개발자는 코드의 관련없는 부분에서 오류를 일으키지 않고 추가적인 속성을 가진 객체를 생성할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n편의성: 이 기능은 복잡한 데이터 구조를 다룰 때나 다른 목적을 위해 객체에 추가 정보를 확장할 때 특히 객체 생성 및 조작을 용이하게 만듭니다.\n\n유형 안전성: TypeScript는 유연성을 유지하면서도 필수 속성이 존재하고 올바른 유형을 갖추도록 보장하여 유연성과 유형 안전성 사이의 균형을 제공합니다.\n\n# 이러한 오류를 보다 엄격한 유형 안전성을 보장하고 한정하려면 어떻게 해야 합니까?\n\n방법 1: 변경할 변수의 유형을 명시적으로 주석으로 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_7.png\" /\u003e\n\n여기서 우리는 추가 속성이 없도록 특정 유형으로 변수를 명시적으로 선언하고 있습니다.\n\n방법 2: 함수 매개변수를 설정할 때 엄격한 유형을 사용합니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 함수를 만들 때 매개변수가 엄격하게 형식화되므로 TypeScript가 알 수 없는 속성과 관련된 오류를 발생시킵니다.\n\n방법 3: 인터페이스 유형 사용\n\n![이미지](/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_9.png)\n\n여기서는 유형 안전성을 위해 인터페이스를 사용하고, 추가 속성이 필요한 사용 사례에 대해 기본 인터페이스를 확장하고 있습니다.\n그러나 기본 인터페이스를 추가 속성과 함께 사용할 때 TypeScript가 알 수 없는 속성에 대한 오류를 내보내는 것을 볼 수 있습니다. 이는 맥락에 따라 쉽게 완화될 수 있으며 두 가지 목적을 제공합니다:-\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 만약 추가적인 이메일 속성이 필요한 상황이라면, 오류를 완화하기 위해 확장된 인터페이스를 사용할 수 있습니다.\n- 만약 추가적인 이메일 속성이 필요하지 않은 상황이라면, 인터페이스는 올바른 유형 확인기로 작용하여 이메일 매개변수를 잘못 설정한 오류를 알려줍니다.\n\n# 결론\n\n특히 직접적인 객체 리터럴과 변수 사이의 차이에 대한 TypeScript의 처리 방식은 유형 안전성과 유연성을 균형 있게 유지하는 의도적인 설계 선택입니다. 이 동작을 이해하면 보다 견고한 TypeScript 코드를 작성하고 기능을 효과적으로 사용하는 데 도움이 됩니다. 위에서 설명한 방법을 따르면 보다 엄격한 유형 안전성을 보장하고 과도한 속성과 관련된 잠재적인 위험 요소를 피할 수 있습니다. 처음에는 일관성이 없어 보일 수 있지만 (저에게도 그랬습니다), 이것이 유연성을 제공하기 위해 설계된 기능임을 알아차리면 개발 프로세스에서 TypeScript를 더 잘 활용할 수 있습니다.\n\n# Stackademic 🎓\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어주셔서 감사합니다! 이제 가시기 전에:\n\n- 작가를 격려하고 팔로우해주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingTypeScriptsHandlingofObjectLiteralTypesTheQuirksandInsights_0.png","tag":["Tech"],"readingTime":5}],"page":"25","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"25"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>