<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="부적합한 프로그래머일지도 모르는 5가지 신호" href="/post/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="부적합한 프로그래머일지도 모르는 5가지 신호" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="부적합한 프로그래머일지도 모르는 5가지 신호" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">부적합한 프로그래머일지도 모르는 5가지 신호</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 GraphQL 대 REST API 포괄적 가이드" href="/post/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 GraphQL 대 REST API 포괄적 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 GraphQL 대 REST API 포괄적 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 GraphQL 대 REST API 포괄적 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기" href="/post/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라이프사이클 후크Lifecycle Hooks에 대한 LWC" href="/post/2024-05-14-LifecycleHooksinLWC"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라이프사이클 후크Lifecycle Hooks에 대한 LWC" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-LifecycleHooksinLWC_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라이프사이클 후크Lifecycle Hooks에 대한 LWC" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">라이프사이클 후크Lifecycle Hooks에 대한 LWC</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="피해야 할 5가지 실수 웹 개발자로서" href="/post/2024-05-14-AvoidThese5MistakesasaWebDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="피해야 할 5가지 실수 웹 개발자로서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="피해야 할 5가지 실수 웹 개발자로서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">피해야 할 5가지 실수 웹 개발자로서</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대용량 JSON 객체를 효율적으로 업데이트하는 방법" href="/post/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대용량 JSON 객체를 효율적으로 업데이트하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대용량 JSON 객체를 효율적으로 업데이트하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대용량 JSON 객체를 효율적으로 업데이트하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next JS 렌더링 패턴 - 포괄적인 안내" href="/post/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next JS 렌더링 패턴 - 포괄적인 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next JS 렌더링 패턴 - 포괄적인 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next JS 렌더링 패턴 - 포괄적인 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" href="/post/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs 어플리케이션의 성능 최적화 기술" href="/post/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs 어플리케이션의 성능 최적화 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs 어플리케이션의 성능 최적화 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs 어플리케이션의 성능 최적화 기술</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 172에서의 Material 3 실험적 지원" href="/post/2024-05-14-Material3ExperimentalSupportinAngular172"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 172에서의 Material 3 실험적 지원" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 172에서의 Material 3 실험적 지원" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 172에서의 Material 3 실험적 지원</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link posts_-active__YVJEi" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"부적합한 프로그래머일지도 모르는 5가지 신호","description":"","date":"2024-05-14 12:51","slug":"2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer","content":"\n\n## 프로그래밍 의견\n\n![프로그래밍](/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png)\n\n아무도 완벽하지 않으며 아래 목록 중 하나 또는 두 개의 항목이 모두 해당될 것입니다. 그러나 그 중 세 가지 이상이 해당된다면, 스스로를 비판하거나 다른 일을 찾아보는 것이 좋을 수도 있습니다.\n\n프로그래밍은 오랜 시간 약한 조건과 많은 스트레스 아래에서 가끔 열심히 할 필요가 있으므로 그것을 즐기지 않는다면 의미가 없습니다. 거기에 이르기까지의 교육 과정은 김이며, 실제로 좋아지려면 십 년의 경험이 필요합니다. 처음부터 그런 감정이 느껴지지 않는다면, 다른 것을 찾아보는 것이 좋은 이유가 될 수 있습니다.\n\n\n\n우리는 더 많은 우수한 프로그래머가 필요해요. 프로그래밍은 인지적 프로세스를 자동화하며, 이러한 합리화는 현재 세상에서 진보의 주요 원동력이자 번영의 주된 요인이에요. 제 시선에서 모든 프로그래머는 우리의 존경을 받을 만한 영웅이에요.\n\n당신이 하는 일에 대한 오피서, 신사, 데이터 전사가 되어주세요.\n\n프로그래밍은 일자리가 아니에요. 이는 일종의 사명이에요. 빠르게 돈을 벌 수 있는 다른 방법이 있지만, 프로그래밍은 오늘날 일의 가장 높은 가치 중 하나로 사회에 봉사하는 것이기도 해요.\n\n그러니 당신이 프로그래머라 자부심을 갖지만 오만해지지 마세요. 당신은 사회의 종복이며, 기계가 읽을 수 있는 책을 쓰고, 스크롤을 통해 작동되는 로프의 골렘을 프로그래밍하는 현대적 수도사이기도 해요.\n\n\n\n당신이 되어야 하는 사이버 수도승은 겸손과 자발성, 자신의 한계를 이해하는 것뿐만 아니라 프로그래밍보다는 예술과 철학, 윤리와 정치를 필요로 합니다. 또한 개인으로서와 창조적인 힘으로서 사회에서의 역할에 대한 인식도 필요합니다.\n\n이것과 자아가 충돌하지 않을 수도 있습니다. 자아는 자신의 가치를 알아야 하며, 당신의 의견에서 벗어나는 것에 확신을 가져야 합니다. 하지만 납득할 수 있고 생각을 바꿀 수 있는 능력 또한 이 중요합니다. 당신이 소왈되지 않은 자아를 가지고 있을 때만 이 위대함을 얻을 수 있습니다.\n\n만약 이 이상적인 것을 달성한다면, 당신은 좋은 프로그래머입니다. 목표는 이를 달성하기 위한 길입니다.\n\n그래서 여기 목록입니다:\n\n\n\n- 프로그래밍을 즐기지 않아요.\n- 참고 자료, 라이브러리 및 설명서를 읽지 않고, 그냥 주물러버려요.\n- 자기를 돌아보지 않고, 자신이나 자신의 프로그램, 사용 가능한 도구에 대해 자기비판이 없어요.\n- 듣는 모든 말을 믿어요. 스스로 생각하지 않고 해결책을 찾지 않아요.\n- \"그렇다고?\" 라는 질문을 하지 않아요. 과학적인 작업을 하지 않아요.\n- 자신의 프로그램을 오류로 테스트해보지 않아요.\n- 해결하려는 것이 이미 존재하는지 확인하려고 하지 않아요.\n- 기능의 작은 부분만 사용하려 할 때도 프레임워크를 사용해요.\n- 유행과 이데올로기에 영향을 받아요 - \"이달의 패러다임\".\n- 다른 사람의 코드를 테스트하지 않고 신뢰해요.\n- 필요하지 않은 자원인 CPU 및 처리 시간을 낭비해요.\n- 문제에 합리적인 알고리즘을 찾지 않아요.\n- 시스템의 하드웨어를 무시하고, 다른 방법으로 쉽게 할 수 있는 것도 있음에도 특히 취약한 작업을 해요.\n- 어떤 컴퓨터 아키텍처에서 작업하는지에 대한 이해가 없으며, 자부심을 갖고 있어요 (\"HLL 무지\").\n- 문제 해결에 집중하는 대신 힙 이데올로기를 사용해요 (\"OOP Mad Cow Disease\").\n- 형태의 중요성을 높이는 태도\n- 시스템을 이해하지 못하고 스스로 시스템 기능을 구현하려 하면 대개 실패합니다.\n- \"최적화\"를 무시해요.\n- 어셈블리에 관심을 둬요.\n- 디버거를 사용하는 방법을 모르겠어요.\n- 프로그램을 역공학적으로 분석해본 적이 없고, 그에 대한 호기심이 없어요.\n- 그냥 그 때 표준으로 인해 일을 하지만 그것에 대해 비판적으로 생각하거나 다른 사람과 의견을 교환하지 않아요. 요약하자면, 반성이 부족해요.\n- 자신의 도구의 한계 및 사용된 언어, 알고리즘, 시스템의 강점과 약점에 대한 지식이 전혀 없어요.\n- 목적지에 빨리 도착한다고 생각해서 항상 최적의 경로를 선택해요.\n- 세심하고 철저하게 일하지 않고, 어질어질하게 일해요.\n- 새로운 사람들이나 유지보수 담당자 앞에서 오만하게 행동하며 도우려 하지 않아요. 의자를 통해서 음해하고 협조적이지 않은 경력의 사고방식도 포함돼요. 안타깝게도 일반적이에요. 하지만 그렇게 일할 수 없어요. 누구든 그런 사람과 일할 수 없어요.\n- 일을 마음대로 처리하지 않고, 의도적으로 암호화된 코드로 직업을 안전하게 만들어요. 만약 필요하거나 아프다면 더 나은 사람으로 대체할 기회나 자리를 주지 않습니다. 이를 간단히 아 불효한 행동이라고 부릅니다. 질질짜는 질질짜기 대신에 실질적인 안전이 품질을 통해 실현돼요.\n- 일을 속이고, 자립적으로 결점을 드러내거나 인정하지 않아요. 스스로에게 대안을 제시하지 않아요.\n- 엔지니어로서의 자질이 당신에게 말하지만, 관리부와의 대면에서 등을 빼지 못할 때가 있어요. 이것은 종종 프로젝트의 파괴적 결과나 더 나쁜 일로 이어지곤 해요. 챌린저의 엔지니어들은 발사를 거부해야 했어요. 그 추운 날, 그들의 거부로 인해 일곱 명이 불필요하게 사망하게 됐어요. 나쁜 프로그래머들은 용기가 없고 직장에 대한 두려움이 있어요.\n- 경우에 따라 결론을 내릴 대신, 자격 없는 사람들이 무엇을 해야 하는지 지시하는 것을 허용해요. 프로그래머와 엔지니어로서, 살아가야 하는 엄청난 책임이 있어요. 혹은 그 분야에 위치할 자격이 없는 경우도 있어요.\n- 저지른 실수를 인정하지 않고, 오히려 숨기고 감추려 해요. (BOfH 현상)\n- 교육을 이어가지 않고, 새로운 것을 배우거나 시도할 의지가 없어요. 또한 능동적인 태도를 나타내지 않아요. 상투적인 길을 시도해보지 않아요.\n- 두려움.\n\n위 목록에 속하지 않는 것은 여러분의 프로그램 중 하나에 오류가 있다는 것이 아니에요. 모든 프로그램에는 오류가 있어요. 또한 예상보다 더 오랜 시간이 걸리는 것 역시 정상적이에요.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\n\n- 작가에게 박수를 보내 주시고 팔로우도 부탁드립니다! 👏\n- 팔로우하기 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png"},"coverImage":"/assets/img/2024-05-14-SignsYouMightBeaLess-Than-StellarProgrammer_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 GraphQL 대 REST API 포괄적 가이드","description":"","date":"2024-05-14 12:50","slug":"2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide","content":"\n\n\n![그래픽](/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png)\n\nGraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!\n\n# REST API란 무엇인가요?\n\nREST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.\n\n\n\n\n```js\n// REST API를 사용하여 데이터 가져오기\nfetch(\"https://api.example.com/items\") \n  .then(res =\u003e res.json())\n  .then(data =\u003e console.log(data));\n```\n\n위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.\n\n# GraphQL이란?\n\n2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.```\n\n\n\n```js\n// GraphQL을 사용하여 데이터를 가져옵니다\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{ \n      items { \n        id, \n        name \n      } \n    }`\n  })\n})\n.then(res =\u003e res.json())\n.then(data =\u003e console.log(data.data));\n```\n\n위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.\n\n# GraphQL과 REST API의 차이\n\n## 1. 데이터 가져오기\n\n\n\nREST API\n\nREST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.\n\n```js\nfetch(\"https://api.example.com/users/1\") // ID가 1인 사용자 가져 오기\n.then(/* */)\n\nfetch(\"https://api.example.com/users/1/posts\") // ID가 1인 사용자의 게시물 가져 오기\n.then(/* */)\n```\n\n위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.\n\n```js\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{\n      user(id: 1) {\n        name,\n        posts {\n          title,\n          body\n        }\n      }\n    }`\n  })\n})\n.then(/* */)\n```\n\n위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.\n\n\n\n## 2. Over-fetching and Under-fetching\n\nREST API\n\nRESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.\n\nGraphQL\n\n\n\nGraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.\n\n## 3. 버전 관리\n\nREST API\n\n버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.\n\n## REST API와 GraphQL을 언제 사용해야 할까요?\n\nREST API를 사용해야 하는 경우:\n\n\n\n- 당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.\n- 데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.\n\nGraphQL을 사용해야 하는 경우:\n\n- 애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.\n- 네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.\n- 앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.\n\n마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.\n\n\n\n# 만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏\n\n열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: [https://discord.gg/QyXEsb4C](https://discord.gg/QyXEsb4C)","ogImage":{"url":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기","description":"","date":"2024-05-14 12:49","slug":"2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues","content":"\n\n```\n\u003cimg src=\"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png\" /\u003e\n\nJavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.\n\nJavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.\n\n그렇다면, JavaScript는 이를 어떻게 성취할까요?\n```\n\n\n\n자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.\n\n이제 깊게 들어가 봅시다.\n\n자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.\n\n작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.\n\n\n\n자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png","tag":["Tech"],"readingTime":2},{"title":"라이프사이클 후크Lifecycle Hooks에 대한 LWC","description":"","date":"2024-05-14 12:48","slug":"2024-05-14-LifecycleHooksinLWC","content":"\n\n\n![Lifecycle Hooks in LWC](/assets/img/2024-05-14-LifecycleHooksinLWC_0.png)\n\n라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.\n\n이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.\n\n이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.\n\n\n\nLifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component\n\n라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 \"라이프사이클 훅(Lifecycle Hooks)\"의 세계입니다.\n\n# 라이프사이클 훅이란?\n\nLWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.\n\n\n\n여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:\n\n- constructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.\n- connectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.\n- renderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.\n- disconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.\n- errorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.\n\n# 라이프사이클 후크 흐름\n\n먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-LifecycleHooksinLWC_1.png)\n\n1. 생성:\n\n- `constructor()`: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.\n\n주의하세요!\n\n\n\n생성자()\n\n- 컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).\n- 부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.\n- 부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.\n- 컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.\n\n```js\nimport { LightningElement } from 'lwc';\n \nexport default class LifeCycleHookParent extends LightningElement {\n  constructor() {\n    super(); // LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');\n    let con = this.template // 호스트 요소에 액세스합니다.\n    console.log(con);\n  }\n}\n```\n\n2. 초기화:\n\n\n\n- `connectedCallback()`: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.\n\n주의!\n\nconnectedCallback()\n\n- 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 부모에서 자식으로 흐릅니다.\n- 데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.\n- 컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.\n\n\n\n```js\nconnectedCallback(){\n  console.log('Parent Connected Call Back called');\n  let cb = this.template\n  console.log('is connected=\u003e ' + cb.isConnected);\n}\n```\n\n3. 렌더링:\n\n- `renderedCallback()`: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.\n\n주의하세요!\n\n\n\n\nrenderedCallback()\n\n- 컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.\n- 자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.\n- 컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.\n- 렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.\n\n```js\nimport { LightningElement } from 'lwc';\nexport default class LifeCycleHookParent extends LightningElement {\n  isRendered = true // 컴포넌트가 렌더링되었는지 확인하기 위한 변수\n  renderedCallback() {\n    if (this.isRendered) {\n      console.log('부모 컴포넌트의 렌더링 콜백이 호출되었습니다');\n      this.isRendered = false\n    }\n  ?\n }\n```\n\n4. Reactivity:\n\n\n\n- 컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 `renderedCallback`을 다시 호출합니다.\n\n5. 소멸:\n\n- `disconnectedCallback()`: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.\n\n주의하세요!\n\n\n\n\ndisconnectedCallback()\n\n- 문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).\n- Parent에서 Child로 이어집니다.\n- connectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.\n- 메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.\n\n6. 오류 처리:\n\n- `errorCallback()`: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.\n\n\n\n\n알아두세요!\n\nerrorCallback()\n\n이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.\n\n하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.\n\n\n\n- 자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.\n- errorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.\n\n```js\n//Child Component\nconnectedCallback(){\n  console.log('Child Connected Call Back called');\n  throw new Error('problem in child component connectedCallback')\n  }\n```\n\n```js\n//Parent component\nerrorCallback(error, stack){\n  console.log(error 메시지);\n  console.log('Stack: - ' + stack);\n}\n```\n\n이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.\n\n\n\n# 라이프사이클 훅이 왜 중요한가요?\n\n라이프사이클 훅은 여러 이점을 제공합니다:\n\n- 최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.\n- 상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.\n- 자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.\n\n예시: 실용적인 사용 사례\n\n\n\n간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:\n\n```js\nexport default class CountdownTimer extends LightningElement {\n    seconds = 10;\n\n    connectedCallback() {\n        this.timer = setInterval(() =\u003e {\n            if (this.seconds \u003e 0) {\n                this.seconds--;\n            }\n        }, 1000);\n    }\n\n    renderedCallback() {\n        if (this.seconds === 0) {\n            clearInterval(this.timer);\n        }\n    }\n\n    disconnectedCallback() {\n        clearInterval(this.timer);\n    }\n}\n```\n\n이 예시에서 `connectedCallback`은 타이머를 설정하고, `renderedCallback`은 타이머가 0에 도달했을 때 UI를 업데이트하며, `disconnectedCallback`은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.\n\n자세한 내용은 아래 링크를 참조해주세요:\n\n\n\n읽어 주셔서 감사합니다 ☺️","ogImage":{"url":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png","tag":["Tech"],"readingTime":6},{"title":"피해야 할 5가지 실수 웹 개발자로서","description":"","date":"2024-05-14 12:46","slug":"2024-05-14-AvoidThese5MistakesasaWebDeveloper","content":"\n\n```\n![Avoid These 5 Mistakes as a Web Developer](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png)\n\n우리는 모두 실수를 합니다. 배우고成長하며、경험을 쌓는 가장 효율적인 방법입니다. 실수를 돌아보고 그로부터 배우면 스스로를 향상시킬 수 있습니다.\n\n대부분의 사람들은 자신의 실수를 돌아보지 않습니다. 그들은 그 실수를 저지르지 않았어야 한다고 자책합니다. 다른 사람이 그들을 비난할 필요는 없습니다; 그들 스스로 힘을 줍니다.\n\n웹 개발자 경력 중에 백엔드 엔지니어가 범하는 십 가지 오류를 나열하겠습니다. 실수를 범하는 데는 현재 위치가 중요하지 않습니다. 우리는 경력 어디서든지 언제든지 실수를 합니다.\n```\n\n\n\n# 실수 #1\n\n기술 부채. 지나친 공학. 종소리가 울리나요? 종종, 개발자들은 사용자가 응용 프로그램을 활용하는 방식을 이해하는 대신 기술적인 측면에 초점을 맞춥니다. 해당 요구 사항에 따라 코드를 작성하지 않습니다. 백엔드 엔지니어가 요구 사항을 기반으로 기술을 사용하면 필요한 노력과 비용을 크게 줄일 수 있습니다.\n\n대부분의 경우, 초보자들이 이 실수에 빠집니다. 분야에 새로 온 사람들은 사용자에게 효율적으로 제공되는 기술을 알지 못하기 때문에 기술적 부담을 줄이는 기술을 사용하지 않는 것입니다. 더 많은 기술과 처리가 필요할 때 응용 프로그램은 최종 사용자에게 느리게 나타납니다.\n\n어떤 분야, 취미 또는 습관에 새로 온 사람들은 프로세스를 지나치게 복잡하게 만들기 쉽습니다. 그러나 경력자들은 더 적은 기술을 사용하여 개발 및 사용자 시간을 절약하면서 노력과 비용을 줄입니다.\n\n\n\n더불어, 기술 부채는 읽기 어려운 코드를 나타냅니다. 다른 엔지니어들이 이해할 수 있는 로직을 작성하는 것이 개발의 첫 번째 규칙입니다. 이는 이러한 산업 표준 기술과 코딩 표준을 사용하거나 변수를 CamalCase 규칙으로 작성하는 것을 의미합니다.\n\n초보자들은 가능한 모든 것을 사용할 때 자부심을 느낍니다. 나중에는 동일한 선택이 응용 프로그램을 느리게 만들 때 머리가 아플 수 있습니다. 이로 인해 시니어들이 코드를 리팩토링해야 하며, 이는 시간 낭비입니다. 코드가 많아질수록 테스트 요구 사항과 버그 발생 확률이 증가합니다. 코드를 적게 작성하세요.\n\n자존심을 한쪽에 두고 필요한 기술만 선택하고 최고의 산업 표준을 준수함으로써 이러한 실수를 피할 수 있습니다. 프론트엔드 프레임워크와 라이브러리를 배울 때 이 실수를 저질렀습니다. 이에 따라 더 많은 코드, 더 많은 버그 및 대규모 리팩토링 비용이 발생했습니다. DRY, KISS 또는 YAGNI 표준을 따르세요.\n\n# 실수 #2\n\n\n\n내가 Udemy에서 React를 배우는 데 돈을 썼어. 그 스킬을 활용해서 모든 애플리케이션을 React로 만들어야겠지? 아니야. 모든 작업에 같은 기술, 라이브러리 또는 프레임워크를 사용하지 말아야 해. 이 프레임워크의 선택은 해결해야 하는 문제에 따라 다르니까.\n\nReact + Vite는 중급 웹 애플리케이션에 적합할 수도 있어. 그러나 성능 중심의 애플리케이션에는 적합하지 않아. 그럴 때는 성능을 향상시키기 위해 SolidJS, NextJS 또는 다른 프레임워크를 선택해야 해.\n\n주어진 작업에 따라 사용하는 기술을 바꿔. 선택한 언어인 JavaScript 같은 기본기는 튼튼히 갖추고 있고, 기술을 바꿔가며 학습해.\n\n하나의 기술에만 고수하지 마. 그것은 학습 능력을 제한하고 애플리케이션이 문제를 겪게 만들어. 나중에 그 기술을 바꿔야 하게 될 텐데, 처음부터 그렇게 할 수 있었을 텐데.\n\n\n\n# 실수 #3\n\n나쁜 의도를 가진 사람들은 데이터베이스를 공격하고 자격 증명을 도용하기 위한 엄청난 기술을 가지고 있습니다. SQL 인젝션은 흔한 기술 중 하나입니다. 그것이 빈번하다면, 사람들은 그럼에도 불구하고 여전히 그에 빠질까요? 네, 그렇습니다!\n\n이것은 시니어들이 데이터베이스를 수정하는 쿼리를 주입하는 것을 방지하는 코드를 작성할 수 있지만, 주니어들은 이 분야의 복잡함을 알지 못할 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_1.png)\n\n\n\n2022년을 기준으로 웹 응용프로그램에서 발생한 전체 취약점 중 33%가 SQL Injection 공격으로 인한 것입니다. 원치 않는 문자열을 표준 쿼리와 연결함으로써 개인들이 DB에 액세스하고 일반적으로 DML 명령을 실행합니다.\n\n이러한 실수를 피하기 위해 일반화된 쿼리를 사용하는 대신 쿼리 내에 구체적으로 필요한 매개변수를 전달하세요. 모든 작업에 대해 표준 쿼리를 만들지 마세요. 그렇게 하면 새벽 2시 30분에 전화를 받을 수도 있습니다. 여러 개의 데이터베이스를 사용하고 모든 과일을 한 바구니에 넣지 마세요.\n\n다양성이 중요합니다. 코드 리뷰를 수행하세요. 특히 실행 중인 쿼리에 대해 연결된 문자열을 검증하세요. 제품 DB를 백업하면서 유지하세요.\n\n# 실수 #4\n\n\n\n미적인 면에 초점을 맞추는 사람이신가요? 사용성보다는 미학에 더 집중하는 것은 일반적인 초보 실수입니다. 초보 개발자는 사용자가 응용 프로그램을 어떻게 활용하는지에 대해 덜 주의를 기울이고 디자인을 지나치게 복잡하게 만들곤 합니다. UI/UX는 테스트 단계까지 아름답게 보일 수 있어요.\n\n사용자들이 귀하는 응용 프로그램을 이용하게 될 때 비즈니스 매출이 감소합니다. 왜냐하면 그 중 95%는 사용하지 못하기 때문이죠. 복잡성 때문이라고 해야겠어요. 사용자들은 간단한 디자인을 선호합니다. 이미 본 적 있는 인터페이스가 원하는 것이죠. 사람들은 습관에 집중합니다. 어떤 작업에도 덜 노력을 기울이고 싶어해요.\n\n사용자들은 새로운 패턴을 배우도록 강요하면 응용 프로그램을 사용하지 않을 거예요. 이전 디자이너 세대에 의해 시작된 특정 패턴에 익숙해진 인간들이 존재합니다. 젊은 사람들은 습관을 변경할 수 있지만, 대부분의 사용자는 그렇지 않을 겁니다.\n\n대중을 대상으로 디자인하고 구축하세요. 기존 표준과 사용자 패턴이나 행동을 활용해 인터페이스를 작성함으로써 이러한 실수를 피해보세요. 사용자가 최소한의 노력으로 제품을 구매할 수 있도록 해주세요. 소셜 미디어는 이러한 실수에 대한 해결책을 제시했습니다. 그것이 중독성이 있는 이유가 있지요. 더 적은 노력, 더 큰 보상.\n\n\n\n# 실수 #5\n\n일단 해결책을 만들고 코드를 작성해 보세요. 나중에 어떻게 될지는 확인해 볼 거에요. 변경 사항은 나중에 하기로 했잖아요? 그렇지 않아요. 처음부터 확장 가능성을 고려하세요. 버그와 오류를 수정하는 데 필요한 리팩토링과 개발 시간은 이상적이지 않아요.\n\n시작부터 문제를 해결하는 데 특정 기술을 선택하고, 가능한 미래 지표에 기반해 확장 가능한지 파악하세요. 예를 들어, 우리가 다양화하기로 결정한 후 React 성능 특정 작업을 사용할 수 있을까요? 아니에요. 그러면 사용해야 할까요? 아니요. 다른 기술을 선택하세요.\n\n대부분의 백엔드 엔지니어는 모든 문제에 같은 기술 세트를 사용해요. 개발자들은 가능한 트래픽과 데이터 거래를 고려하지 않아요. 2013년, 해커들이 Snapchat의 확장 가능성이 없는 코드베이스를 악용하여 수백만 명의 사용자 데이터에 접근했어요. 그런 일이 발생하지 않길 바라지 않겠죠.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png"},"coverImage":"/assets/img/2024-05-14-AvoidThese5MistakesasaWebDeveloper_0.png","tag":["Tech"],"readingTime":4},{"title":"대용량 JSON 객체를 효율적으로 업데이트하는 방법","description":"","date":"2024-05-14 12:45","slug":"2024-05-14-HowToUpdateLargeJSONObjectsEfficiently","content":"\n\n\n![JSON Patch](/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png)\n\nJSON Patch는 JSON 문서를 변경하는 방법을 설명하는 형식으로, JSON 데이터를 수정하는 방법을 보여주는 간결한 작업 지침의 시리즈를 사용합니다. 이 작업에는 새 데이터 추가, 이전 데이터 삭제, 기존 데이터 교체 또는 데이터 이동이 포함됩니다.\n\n## JSON Patch를 사용하는 이유\n\n대규모 웹 애플리케이션에서 클라이언트는 최신 데이터를 가져오거나 수정된 데이터를 서버에 제출하기 위해 서버와 자주 통신해야 합니다. 기존 방식은 모든 업데이트마다 전체 JSON 문서를 보내는 것이며, 실제 데이터의 일부분만 변경되었더라도 전송됩니다. 이는 네트워크 트래픽 증가, 네트워크 지연 증가, 서버 및 클라이언트 부하 증가로 이어집니다.\n\n\n\n\nJSON Patch는 네트워크 전송 양을 줄이고 데이터 업데이트 효율성을 향상시키는 효율적인 솔루션을 제공합니다. JSON Patch를 사용하면 클라이언트는 전체 JSON 문서가 아닌 수정이 필요한 데이터 부분만 전송할 수 있습니다. 서버가 JSON Patch를 수신한 후에는 해당 지침에 따라 해당 작업을 수행하여 데이터의 점진적 업데이트를 달성할 수 있습니다. 이는 네트워크 전송 양을 줄이고 네트워크 효율성을 향상시키며 서버와 클라이언트에 가하는 부하를 줄이는데 도움이 됩니다.\n\n## JSON Patch의 혜택은 무엇인가요?\n\n- 전송 양 감소: JSON Patch는 JSON 문서에 대해 수행할 구체적인 변경 사항만 전송하며 전체 JSON 문서를 전송하지 않습니다. 이는 특히 대규모 데이터 세트나 저속 네트워크 환경에서 네트워크 대역폭을 절약할 수 있습니다.\n- 점진적 업데이트: JSON Patch는 JSON 문서에 대한 점진적 업데이트를 지원합니다. 이는 전체 문서가 아닌 변경해야 하는 부분만 보낼 수 있기 때문에 실시간 애플리케이션 및 빈번한 업데이트가 필요한 상황에 유용합니다.\n- 유연성과 확장성: JSON Patch는 JSON 문서에서 수행할 수 있는 작업을 제한하지 않습니다. 필요에 따라 추가, 삭제, 교체, 이동 및 기타 작업을 수행할 수 있으며 필요에 따라 새 작업을 추가할 수도 있습니다.\n\n## JSON Patch는 어떤 작업을 지원하나요?\n\n\n\n1. 추가\n\nJSON 문서에 새로운 값을 추가하려면 경로와 추가할 값이 필요합니다.\n\n```js\n{ \"op\": \"add\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n2. 제거\n\n\n\nJSON 문서에서 값을 제거하려면 제거할 값을 가리키는 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"remove\", \"path\": \"/path\" }\n```\n\n3. 대체\n\nJSON 문서의 값을 교체하려면 대체할 값을 가리키는 경로와 새 값이 필요합니다.\n\n\n\n```js\n{ \"op\": \"replace\", \"path\": \"/path\", \"value\": \"new value\" }\n```\n\n4. 이동\n\nJSON 문서에서 값을 다른 위치로 이동하려면 이동할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"move\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n\n\n5. 복사\n\nJSON 문서에서의 값을 다른 위치로 복사하려면 복사할 값의 경로와 대상 경로를 지정해야 합니다.\n\n```js\n{ \"op\": \"copy\", \"from\": \"/oldpath\", \"path\": \"/newpath\" }\n```\n\n6. 테스트\n\n\n\nJSON 문서에서 값이 특정 값과 동일한지 확인하는 테스트를 수행하며, 이는 주로 작업이 성공적으로 실행될 수 있는지 확인하는 데 사용됩니다. 테스트할 값이 들어 있는 경로와 예상 값이 명시되어야 합니다.\n\n```js\n{ \"op\": \"test\", \"path\": \"/경로\", \"value\": \"예상 값\" }\n```\n\n## JSON 패치 사용 방법\n\n많은 개발 언어에서 JSON 패치 사양을 구현했습니다. JS 환경에서는 fast-json-patch 라이브러리를 사용할 수 있습니다.\n\n\n\n첫째로, npm 또는 pnpm을 사용하여 fast-json-patch를 설치해주세요:\n\n```js\nnpm install fast-json-patch\n또는 \npnpm add fast-json-patch\n```\n\nfast-json-patch 라이브러리를 성공적으로 설치한 후에는 제공되는 API를 활용하여 다음 기능을 수행할 수 있습니다:\n\n- 두 개의 객체를 비교하여 패치를 가져오기\n- 객체 변경을 관찰하고 변경사항을 감지할 때 패치를 생성하기\n- JS 객체에 단일 또는 여러 패치 적용하기\n- 패치 시퀀스를 유효성 검사하기\n\n\n\n- 두 객체를 비교하여 패치를 가져오기\n\n```js\nimport { compare } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst documentB = { user: { firstName: \"Albert\", lastName: \"Collins\" } };\n\nconst diff = compare(documentA, documentB);\n\n/**\n * diff: \n * [ { op: 'replace', path: '/user/lastName', value: 'Collins' } ]\n */\n```\n\n2. 객체 변경 사항을 관찰하고 변경이 감지되면 패치를 생성합니다.\n\n```js\nimport { generate, observe } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\nconst observer = observe(document);\ndocument.firstName = \"Albert\";\ndocument.contactDetails.phoneNumbers[0].number = \"123\";\ndocument.contactDetails.phoneNumbers.push({ number: \"456\" });\nconst patch = generate(observer);\n\n/**\n * patch：\n * [\n *  {\n *    op: 'replace',\n *    path: '/contactDetails/phoneNumbers/0/number',\n *    value: '123'\n *  },\n *  {\n *   op: 'add',\n *   path: '/contactDetails/phoneNumbers/1',\n *   value: { number: '456' }\n *  },\n *  { op: 'replace', path: '/firstName', value: 'Albert' }\n * ]\n */\n```\n\n\n\n3. JS 객체에 단일 또는 여러 패치 적용하기\n\n단일 패치 적용\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst patchedResult = applyPatch(documentA, [\n  { op: \"replace\", path: \"/user/lastName\", value: \"Collins\" },\n]);\n\n/**\n * patchedResult[0]:\n * {\n *   newDocument: { user: { firstName: 'Albert', lastName: 'Collins' } },\n *   removed: 'Einstein'\n * }\n */\n```\n\n다중 패치 적용\n\n\n\n```js\nimport { applyPatch } from \"fast-json-patch/index.mjs\";\n\nconst document = {\n  firstName: \"Joachim\",\n  lastName: \"Wester\",\n  contactDetails: { phoneNumbers: [{ number: \"555-123\" }] },\n};\n\nconst patchedResult = applyPatch(document, [\n  {\n    op: \"replace\",\n    path: \"/contactDetails/phoneNumbers/0/number\",\n    value: \"123\",\n  },\n  {\n    op: \"add\",\n    path: \"/contactDetails/phoneNumbers/1\",\n    value: { number: \"456\" },\n  },\n  { op: \"replace\", path: \"/firstName\", value: \"Albert\" },\n]);\n\n/**\n * patchedResult[0]: \n * {\n *  newDocument: {\n *    firstName: \"Albert\",\n *    lastName: \"Wester\",\n *    contactDetails: { phoneNumbers: [{ number: \"123\" }, { number: \"456\" }] },\n *  },\n *  removed: \"555-123\",\n * }\n */\n```\n\n4. 패치 시퀀스 유효성 검사\n\n```js\nimport { validate } from \"fast-json-patch/index.mjs\";\n\nconst documentA = { user: { firstName: \"Albert\", lastName: \"Einstein\" } };\nconst validatedResult = validate(\n  [{ op: \"replace\", path: \"/user/lastName\", value: \"Collins\" }],\n  documentA\n);\n```\n\n만약 패치 시퀀스가 JSON Patch 사양을 충족하지 않으면, 검증 중에 JsonPatchError 예외 객체가 발생합니다.\n\n\n\nJSON Patch와 fast-json-patch가 소개되었어요! 관심이 있다면 JSON Patch를 직접 경험해보세요. 다른 해결책이 있으면 메시지를 남겨주세요.\n\nTypeScript는 멋지고 배울 가치가 있어요. TypeScript를 배우고 싶다면, 저를 팔로우해서 더 많은 TS와 JS 정보를 읽어보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png"},"coverImage":"/assets/img/2024-05-14-HowToUpdateLargeJSONObjectsEfficiently_0.png","tag":["Tech"],"readingTime":6},{"title":"Next JS 렌더링 패턴 - 포괄적인 안내","description":"","date":"2024-05-14 12:43","slug":"2024-05-14-NextJSRenderingPatternsaComprehensiveGuide","content":"\n\n렌더링 패턴에 대한 정보는 문서, 자습서 또는 블로그 게시물 등이 끊임없이 있습니다. 그러나 시작하고 무언가를 구축하기 위해 얼마나 많은 지식이 필요할까요? 이 게시물에서는 무엇이 무엇인지 이해하고 렌더링이 Next.js에서 어떻게 작동하는지를 굳게 이해하는 데 도움이 되는 각기 다른 렌더링 패턴의 기본 내용을 요약하겠습니다.\n\n![image](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png)\n\n- 두 가지 주요 렌더링 패턴\n  - 클라이언트 측 렌더링\n    - 어떻게 작동합니까?\n    - 브라우저에서 구성 요소를 렌더링하는 방법?\n    - 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSG — 정적 사이트 생성\n    - 어떻게 작동합니까?\n    - 언제 사용해야 하나요?\n    - Next 13부터 페이지를 완전 정적으로 만들기:\n    - 동적 경로 생성 및 빌드 시간에 데이터 가져오기:\n    - 이점:\n    - 제한 사항:\n  - SSR — 서버 측 렌더링\n    - 어떻게 작동합니까?\n    - 유의할 사항:\n    - 페이지를 완전히 동적으로 만드는 방법:\n    - 이점:\n    - 제한 사항:\n  - ISR — 점진적 사이트 재생\n    - 어떻게 작동합니까?\n    - 이점:\n  - PPR — 부분 사전 렌더링:\n    - 부분 사전 렌더링 활성화:\n    - 필요성:\n    - 어떻게 작동합니까?\n- 기본 Next.js 렌더링 동작\n- 렌더링 위치 결정 방식\n\n# 두 가지 주요 렌더링 패턴\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드립니다.\n\n다음과 같이 렌더링 패턴을 넓게 분류할 수 있어요:\n\n- 클라이언트 측 렌더링\n- 사전 렌더링\n\n이름에서 알 수 있듯이 클라이언트 측 렌더링은 브라우저에서 구성 요소를 렌더링하는 것을 말해요.\n\n사전 렌더링은 다양한 방법으로 수행될 수 있어요.\n\n\n\n- SSG 또는 정적 사이트 재생성\n- SSR 또는 서버 사이드 렌더링\n- ISR 또는 증분 사이트 재생성\n- PPR 또는 부분 사전 렌더링 (Next 14에서 실험적 기능으로 제공됨)\n\n우리는 클라이언트 측 렌더링부터 시작해서 다양한 사전 렌더링 접근법으로 넘어갈 것입니다.\n\n# 클라이언트 측 렌더링\n\n## 어떻게 작동하나요?\n\n\n\nNext JS에서 클라이언트 구성 요소는 초기에 서버에서 사전 렌더링되고 DOM이 클라이언트로 전송되어 사용자가 볼 수 있는 내용이 제공됩니다. 그런 다음 JS 코드가 브라우저로 전송되어 DOM에 상호 작용을 추가합니다. DOM이 표시된 후 상호 작용을 천천히 추가하는 이 프로세스를 수분화(hydration)라고 합니다.\n\n## 브라우저에서 구성 요소를 렌더링하는 방법은 무엇인가요?\n\n파일의 시작 부분에 \"use client\" 지시문을 추가하면 됩니다.\n\n## 데이터 가져오기:\n\n\n\nNext JS 백엔드로 API 호출하거나 필요한 데이터를 가져오기 위해 외부 엔드포인트로 API 호출할 수 있어요.\n\n또는 Next JS 서버 컴포넌트에 정규 함수 호출을 할 수도 있어요.\n\n만약 백엔드도 Next JS로 작성되었다면 데이터베이스 액세스를 그 자체에서 수행할 수 있어요.\n\n## 혜택:\n\n\n\n- 페이지에 상호 작용성을 제공하기 위해 코드에 이벤트 리스너를 추가할 수 있어요.\n- 상태를 유지하고 라이프사이클의 다른 단계에서 특정 작업을 수행하거나 상태를 위한 중앙 저장소를 사용하는 훅을 사용할 수 있어요.\n\n## 제한 사항:\n\n- 콘텐츠 표시에 지연이 있을 수 있어요. JavaScript를 구문 분석한 후 HTML을 얻기 전에 사용자가 보여지는 내용에 대한 지연 때문이에요. 브라우저에서 렌더링 작업을 수행하는 동안 사용자가 빈 페이지를 보거나 상호 작용할 수 없는 페이지를 보게 될 수 있어요. 이는 JS 크기, 코드 내 존재하는 차단 작업(있는 경우), 사용자 디바이스의 제약 사항(인터넷 연결, 메모리 가용성)에 따라 다양합니다.\n- SEO 크롤러는 DOM 탐색을 통해 콘텐츠를 사용해 페이지를 색인화해요. JS가 로드되기를 기다려야 할 때 그들은 DOM을 스캔하기 전에 효과적으로 페이지를 색인화할 수 없어요.\n\n# SSG — 정적 사이트 생성\n\n\n\n## 어떻게 작동하나요?\n\n이 경우의 HTML은 빌드 시간에 생성되어 CDN(콘텐츠 전송 네트워크)에 저장되며, 사용자가 웹사이트/특정 경로에 접속할 때 캐시된 페이지의 버전을 제공합니다.\n\n## 언제 사용해야 하나요?\n\n만약 귀하의 웹사이트에 내용이 거의 변경되지 않고 한 번 오랜 기간에 한 번 변경을 계획하고 예약할 수 있다면, 빌드 시간에 해당 내용을 생성하는 것이 가장 좋습니다(서버에서 생성하지 않습니다).\n\n\n\nFAQ 페이지는 정적으로 생성될 수 있습니다. 회사 소개 페이지, 문서 페이지도 자주 다시 생성할 필요가 없으며 빌드 시간에 생성할 수 있습니다.\n\n## Next 13부터 페이지를 완전 정적으로 만드는 방법:\n\n페이지를 완전 정적으로 만들려면 (다시 말해, Next가 서버에서 렌더링할지 빌드 시간에 렌더링할지 결정하지 않고 우리가 스스로 결정하는 것), 관련 파일에서 동적 구성을 값이 force-static으로 내보냅니다:\n\n```js\nexport const dynamic = 'force-static';\n```\n\n\n\n## 동적 경로 생성 및 데이터 빌드 시간에 가져오기:\n\n이를 위해 generateStaticParams 메서드를 사용할 수 있습니다.\n\n이 블로그에서는 앱 라우터의 generateStaticParams가 페이지 라우터의 getStaticProps 및 getStaticPaths의 기능을 대체하는 방법에 대한 깔끔한 설명을 제공합니다.\n\n## 혜택:\n\n\n\n- 페이지의 내용이 자주 변경되지 않는 많은 페이지가 있다면, 서버에서 매번 미리 렌더링하는 것은 서버 부하를 늘립니다. 정적으로 생성하고 CDN에 저장하면 서버로부터 이 부하를 덜 수행할 수 있습니다.\n- 페이지 로드 시 콘텐츠가 즉시 제공되면 SEO 순위가 높아질 가능성이 높아집니다.\n\n## 제한 사항:\n\n- 데이터가 자주 업데이트되는 정적으로 생성된 페이지가 필요한 경우, 사용자에게 제공될 때 데이터가 오래되어 버릴 가능성이 있습니다.\n- 대량의 정적으로 생성된 페이지의 경우, 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n# SSR — 서버 측 렌더링\n\n\n\n이를 동적 렌더링이라고도 합니다.\n\n지시문이나 \"서버 사용\" 지시문이 없는 파일에서, 서버에서 초기 페이지 로드 후에는 클라이언트가 서버에 요청을 보낼 때 연속적으로 서버 측 렌더링이 발생합니다. 이 요청은 캐싱을 비활성화하거나 재검증된 데이터를 가져오는 형태로 발생할 수 있습니다. 페이지가 사용자나 클라이언트 측의 특정 변경 사항에 기반하여 다시 생성되어야 하기 때문에 이를 동적이라고 합니다.\n\n## 작동 방식은?\n\nHTML이 서버에 로드되고, JS 기능도 서버에 남아 있습니다. 그런 다음 HTML이 클라이언트로 전송되어 표시됩니다.\n\n\n\n## 알림:\n\n- 서버 구성 요소의 JavaScript는 서버에서 실행되며 클라이언트로 전달되지 않습니다. 이러한 구성 요소에 대해서는 브라우저에서 하이드레이션이 없습니다.\n- 서버 구성 요소 내에서는 개인 API 키를 안전하게 사용할 수 있습니다. 클라이언트에 노출되지 않기 때문입니다.\n- 서버 구성 요소 내에서 Node.js 코드를 작성할 수 있습니다. 예시: 파일 읽기/쓰기 코드.\n\n## 페이지를 완전히 동적으로 만들려면:\n\n```js\nexport const dynamic = \"force-dynamic\";\n```\n\n\n\n## 장점:\n\n- 사전 렌더링된 DOM은 검색 엔진에서 크롤링 및 색인화하기 쉽습니다.\n- 데이터 액세스를 할 수 있으며, 가져온 데이터는 즉시 사용하여 DOM을 작성할 수 있습니다 (사용자 세부정보 표시) 브라우저로 HTML을 전송하기 전에. 백엔드에 대한 api 호출을 하는 데 추가적인 시간이 필요하지 않습니다.\n- 데이터는 일정 간격으로 재유효성 검사될 수 있어 항상 최신 상태로 유지할 수 있습니다.\n- 브라우저는 컴포넌트를 렌더링하는 데 일을 하지 않아 클라이언트 측의 제약 사항인 네트워크 연결 부실, 메모리 부족 등이 페이지로드를 방해하지 않습니다.\n\n## 한계:\n\n- 서버 렌더링된 컴포넌트는 대화형이 아니며, 대화형은 이벤트 핸들러의 사용을 필요로 하며 이것은 브라우저에서만 가능합니다. 해결책으로는: 서버에서 정적 내용을 렌더링하고 대화형 내용을 클라이언트에 리프 컴포넌트로 렌더링할 수 있습니다. 예를 들어, 서버에서 렌더링된 내용이 풍부한 페이지 내에 클라이언트에서 렌더링된 양식 또는 버튼이 있는 것과 같습니다.\n- 서버 컴포넌트에는 마운팅/언마운팅 애니메이션을 사용할 수 없습니다. 이러한 애니메이션에 대해 React 훅을 사용하려면 컴포넌트가 마운트된 시점과 React 훅을 알아야 하는데 서버에서는 React 훅을 사용할 수 없습니다.\n- 서버 컴포넌트에서 브라우저 API인 웹 저장소 API (로컬저장소 및 세션저장소), WebRTC (웹 실시간 통신 API), Geolocation API (사용자의 위도 및 경도 가져오기)와 같은 브라우저 API를 사용할 수 없습니다.\n\n\n\n# ISR — 증분 사이트 재생성\n\n## 어떻게 작동하나요?\n\n페이지는 빌드 시에 데이터베이스에서 가져온 데이터로 정적으로 생성됩니다. 그러나 fetch 메서드 자체에서 페이지가 다시 생성될 시간 간격을 지정하고 최신 데이터를 가져와 재확인할 수 있습니다. 이 재확인은 서버에서 동적으로 발생합니다.\n\n```js\n// `app` 디렉토리\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, \n  { next: { revalidate: 60 } });\n  const data = await res.json();\n \n  return data.posts;\n}\n \nexport default async function PostList() {\n  const posts = await getPosts();\n \n  return posts.map((post) =\u003e \u003cdiv\u003e{post.name}\u003c/div\u003e);\n}\n```\n\n\n\nfetch 메서드는 값으로 60을 갖는 revalidate 속성을 지정합니다. 따라서 페이지는 매 60초마다 데이터를 다시 가져와 새 데이터로 다시 생성됩니다.\n\nfetch를 사용하지 않을 때 revalidate하는 방법: axios나 Prisma와 같은 ORM을 사용하는 경우 원하는 시간 간격으로 revalidate 구성을 내보내세요:\n\n```js\nexport const revalidate = 3600 // 최대 1시간마다 revalidate\n```\n\n## 혜택:\n\n\n\n더 빠른 로드 시간과 업데이트된 데이터로 정적 생성의 SEO 성능을 얻을 수 있어요. \n\n# PPR — 부분 사전 렌더링:\n\n이건 실험적인 기능이에요.\n\n## 부분 사전 렌더링 ( PPR )을 활성화하려면:\n\n\n\n최신 Next canary 버전을 설치해보세요:\n\n```js\nnpm install next@cannary\n```\n\n혹은,\n\n```js\nnpx create-next-app@latest .\n```\n\n\n\n프로젝트를 시작한 후, next.config.js 파일로 이동해서 다음과 같이 추가해주세요:\n\n```js\nexperimental: {\n ppr: true\n}\n```\n\n## 이것이 필요한 이유:\n\nNext 14 이전에는 전체 경로가 정적 또는 동적 중 하나여야 했습니다. 그러나 실제 요구사항은 몇 가지 요소가 동적으로 업데이트되어야 하는 정적 페이지일 수 있습니다.\n예를들어, 제품 상세 페이지의 경우 다음이 빌드 시간에 생성된 정적 컨텐츠로 문제없이 표시될 수 있습니다:\n1. 제품 이름\n2. 제품 설명\n3. 제품 가격 (가격이 업데이트될 수 있도록 재검증)\n4. 기타 제품 정보\n\n\n\n그리고 일부 내용들은 동적으로 생성되어야 합니다 (사용자 요청에 기반하여 서버에서 생성됨):\n1. 총 평가 및 리뷰 수\n2. 제품 평점\n3. 리뷰 섹션\n\n## 작동 방식은?\n\n따라서 정적 로딩 셸에 전체 제품 세부 정보 경로를 렌더링하고 그 안에 평가 수, 리뷰 수, 리뷰 섹션을 동적으로 만들 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_1.png)\n\n\n\n동적 콘텐츠는 비동기로 병렬로 스트림 처리되어 서로의 로딩 시간을 차단하지 않습니다.\n\nPPR이 활성화되면 사용자 지정 클라이언트 지시문이 표시되지 않은 모든 사전 렌더링된 페이지 (예:, 허용될 것입니다. 즉, 컴포넌트는 정적으로 생성된 로딩 쉘 내에서 렌더링될 것입니다.\n그런 다음 동적 컴포넌트를 React Suspense 경계 내로 래핑할 수 있습니다.\n그래서 중첩된 제품 세부 정보 라우트는 제품 이미지, 제품 설명, 제품 이름, 가격과 같이 모든 것이 정적으로 생성되고 리뷰, 리뷰 수, 평점 등은 적절한 후행 컴포넌트와 함께 Suspense로 래핑될 것입니다.\n코드가 이러한 Suspense로 래핑된 컴포넌트를 만나면 제공된 후행 컴포넌트를 가져와 그것들을 정적으로 생성하고 해당 컴포넌트의 데이터가 사용 가능할 때까지 래핑된 컴포넌트의 생성을 일시 중단할 것입니다.\n이러한 모든 Suspense로 래핑된 컴포넌트는 비동기로 되어 있으며 데이터를 병렬로 가져오며 한 컴포넌트의 데이터가 사용 가능해지면 렌더링될 것입니다.\n\n```js\nreturn (\n \u003cdiv\u003e\n  \u003cA/\u003e\n  \u003cB/\u003e\n  \u003cSuspense fallback={\u003cFallbackC/\u003e}\u003e\n   \u003cC data={fetch async data}/\u003e\n  \u003c/Suspense\u003e\n  \u003cD/\u003e\n  \u003cSuspense fallback={\u003cFallbackE/\u003e}\u003e\n   \u003cE data={fetch async data}/\u003e\n  \u003c/Suspense\u003e\n  \u003cF/\u003e\n \u003c/div\u003e\n)\n```\n\n여기서 A, B, FallbackC, D, FallbackE 및 F 컴포넌트는 빌드 시 정적으로 생성됩니다.\n사용자가 라우트를 요청하면 정적 컴포넌트가 즉시 사용 가능합니다. 동시에 C 및 E에 대한 데이터 가져오기가 병렬로 시작됩니다. 먼저 데이터를 받는 컴포넌트가 먼저 나타납니다.\n\n\n\nPPR에 대한 자세한 이해를 위해 이 블로그를 읽어보세요.\n\n## Next.js 기본 렌더링 동작\n\n기본적으로 Next JS는 정적 사이트 생성을 선택하려고 노력합니다. 따라서 동적 변수의 값은 자동으로 설정됩니다. 여 less 향을 변경하지 않는 한 Next는 모든 것을 캐시하려고 할 것입니다.\n\n의도적으로 동적 렌더링(서버 상에서)을 선택하기 위해 다음 중 하나를 수행해야 합니다:\n\n\n\n- 값이 'force-dynamic'인 동적 변수를 내보내세요.\n- 'generateStaticParams'를 사용하지 않고 '[id]'와 같은 동적 경로 이름을 사용하세요.\n- 값이 0으로 설정된 revalidate 구성을 내보내세요.\n\n```js\nexport const revalidate = 0;\n```\n\n4. cookies() 또는 header()와 같은 동적 함수를 사용하세요.\n\n5. fetch 요청을 생성하고 'cache: ‘no-store’ ' 또는 'next: 'revalidate: 0'을 전달하세요.\n\n\n\n# 렌더링 위치는 어떻게 결정되나요\n\n이미 \"use client\" 및 \"use server\" 지시문이 구성 요소를 각각 클라이언트와 서버에 렌더링하도록 표시하는 데 사용된다는 것을 알고 계실 것입니다. 그러나 이러한 지시문들이 실제로 어떻게 해석되는지 궁금하시죠?\n\n파일 상단에 \"use client\"를 추가하면 이 파일에 만들어진 구성 요소뿐만 아니라 해당 파일이 의존하는 모든 구성 요소가 브라우저에서 렌더링됩니다. \"use client\"로 표시된 파일의 종속성은 해당 파일의 모든 import 문을 확인하여 해결됩니다.\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_2.png)\n\n\n\n상기 시나리오를 고려해보세요. 당신은 \"home\"이 브라우저에 렌더링되며, \"testimonials\"은 서버에 렌더링되도록 지정했습니다. 그러나 서버 구성 요소가 먼저 로드되고, 그 다음 클라이언트 구성 요소가 로드됩니다. 당신은 Next.js에게 Home 구성 요소가 클라이언트 측에 로드되기 전에 Testimonials를 서버에 렌더링하기 전에 기다리도록 요청했습니다. 하지만 Testimonials 구성 요소 중 하나인 의존성이 아직 렌더링되지 않았을 때 Next.js가 어떻게 Home 구성 요소를 클라이언트 측에 렌더링할 수 있을까요?\n\n이 문제를 해결하기 위해, 서버 구성 요소로 지정되었음에도 불구하고 Testimonials 구성 요소는 클라이언트 측에서 로드될 것입니다.\n\n다음을 해결하기 위해:\n\nHome 구성 요소에서 렌더링하는 동안 서버에서 여전히 Testimonials를 로드하려면 Testimonials 구성 요소를 부모 서버 구성 요소로 전달하여 Home 구성 요소에 자식 속성으로 전달하고 자식으로 렌더링하십시오:\n\n\n\n\n![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_3.png)\n\n홈페이지(home.js)에서 Testimonials에 대한 의존성이 페이지(page.js)로 전환되었습니다. 페이지(page.js)는 또한 서버 컴포넌트입니다.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n\n- 글을 박수로 환영하고 작가를 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"살려나가는 프론트엔드 기능별 디자인 FSD으로 확장 가능한 프론트엔드 개발하기","description":"","date":"2024-05-14 12:40","slug":"2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD","content":"\n\n## Feature-Sliced Design과 Bit를 활용한 현대 프런트엔드 구축\n\n대규모 프런트엔드 앱을 작업해보셨다면, 프로젝트를 이해하기 어려운 상황에 직면했을 가능성이 높습니다.\n\n프로젝트 전체에 흩어진 파일 및 컴포넌트들이 서로 의존하는 상황이 발생하여 유지보수가 매우 복잡해지곤 했을 것입니다!\n\n따라서 이러한 문제를 방지하기 위해 프런트엔드 앱을 구성하는 최상의 방법을 보여주는 규칙과 규칙의 집합이 필요할 것입니다. 그리고 그것이 바로 Feature-Sliced Design이 하는 역할입니다.\n\n\n\n# 피처 슬라이스 디자인이란 무엇인가요?\n\n피처 슬라이스 디자인은 프론트엔드 아키텍처 패턴으로, 프론트엔드 앱을 구축하는 데 사용됩니다. 간단히 말해, 코드를 구성하는 규칙과 관례의 컴필레이션이라고 할 수 있습니다.\n\n프론트엔드 애플리케이션을 세 가지 구성 요소로 분해하여 이 작업을 수행합니다:\n\n피처 슬라이스 디자인으로 개발 중이라면, 당신의 앱은 이 세 가지 구성 요소, 즉 레이어(Layers), 슬라이스(Slices), 그리고 세그먼트(Segments)로 구성될 것입니다.\n\n\n\n- 레이어: 모든 프로젝트에서 표준화된 레이어는 수직으로 배치됩니다. 이는 통신이 위에서 아래로 이루어질 수 있음을 의미합니다. 예를 들어, Pages 레이어는 Widgets 레이어와 통신할 수 있지만 그 반대는 불가능합니다. 또한, 앱은 최대 6개의 레이어를 가질 수 있습니다:\n- shared — 프로젝트/비즈니스의 특정 내용에서 분리되어 재사용 가능한 기능입니다. (예: UIKit, 라이브러리, API)\n- entities — 비즈니스 엔티티입니다. (예: 사용자, 제품, 주문)\n- features — 사용자 상호작용, 사용자에게 비즈니스 가치를 제공하는 작업입니다. (예: SendComment, AddToCart, UsersSearch)\n- widgets — 엔티티와 기능을 의미 있는 블록으로 결합하는 구성 레이어입니다. (예: IssuesList, UserProfile)\n- pages — 엔티티, 기능 및 위젯을 사용하여 전체 페이지를 구성하는 구성 레이어입니다.\n- app — 앱 전체의 설정, 스타일 및 제공자입니다.\n- Slices: 각 레이어는 슬라이스로 구성됩니다. 이러한 슬라이스는 비즈니스 도메인을 기반으로 코드를 분할합니다. 이는 코드를 탐색하기 쉽도록 만들고 논리적으로 관련된 모듈을 가깝게 유지합니다. 그러나 기억해야 할 중요한 점은 슬라이스는 동일한 레이어 내의 슬라이스와 통신할 수 없으며 아래 레이어만 통신할 수 있다는 것입니다.\n- Segments: 각 슬라이스는 세그먼트로 구성됩니다. 세그먼트는 기술적 용도를 기준으로 슬라이스 내에서 코드를 분리하는 작은 모듈입니다. 예를 들어, UI, API, lib과 같은 다른 기술적 용도로 다른 세그먼트를 가질 수 있습니다.\n\n이러한 방식으로 코드를 구조화하면 다음과 같은 요소를 소개할 수 있습니다:\n\n- 통일성: 프론트엔드 앱은 이제 레이어, 슬라이스 및 세그먼트에 따라 준수해야 하는 정의된 표준 규칙을 갖게 됩니다.\n- 도메인 주도: 앱은 기술 중심보다 비즈니스 중심으로 구성됩니다. 이를 통해 프로젝트를 더 쉽게 탐색하고 기능을 더 깊이 이해할 수 있습니다.\n- 유지보수성 향상: 모듈이 동일한 레이어 내의 모듈이나 상위 레이어와 통신할 수 없기 때문에 리팩토링 후 앱이 쉽게 고장나지 않습니다.\n\n# 기능 구분 디자인을 사용해야 할까요?\n\n\n\n지금 보면, 특성 슬라이스 디자인을 프론트앤드 앱에 구현하는 데 상당한 노력이 필요하다는 것이 분명하게 드러납니다. 이것은 처음부터 시작하던지, 이전으로 마이그레이션하던지 관계없이 해당됩니다.\n\n따라서 특성 슬라이스 디자인이 모두에게 적합한 것은 아니라는 것을 이해하는 것이 중요합니다. 사실, 저는 다음과 같은 상황에서 특성 슬라이스 디자인을 사용하길 권장합니다:\n\n- 프론트엔드 앱을 구축 중이십니다. 백엔드 응용 프로그램을 특성 슬라이스 디자인으로 모델링하려고 하지 마십시오.\n- 사용자를 위한 애플리케이션을 구축 중이며 UI 라이브러리가 아닙니다. UI 라이브러리에는 비즈니스 도메인도 API 호출도 다루지 않습니다. 사용자를 위한 애플리케이션만이 도메인으로 분리될 수 있습니다.\n- 대규모 프로젝트를 구축 중이며 간단한 앱이 아닙니다. 간단한 할 일 애플리케이션을 만드는 경우에는 FSD의 장점을 알 수 없을 수도 있습니다. 그러나 WriterGate나 Medium과 같은 애플리케이션을 구축하는 경우, FSD가 유용할 수 있습니다.\n\n만약 이 세 가지 요구 사항을 충족하는 프론트엔드 앱이라면, FSD를 사용해 보세요!\n\n\n\n# Feature Sliced Design과 Bit를 사용하여 앱을 만드는 방법\n\n이렇게까지 오셨다면, 귀하의 앱은 Feature Sliced Design (FSD)의 강력한 후보일 가능성이 높습니다. 그러니, FSD를 사용하여 앱을 어떻게 만들 수 있는지 살펴보겠습니다!\n\n저는 Bit를 사용하여 FSD를 활용한 애플리케이션을 빌드할 것입니다. Bit는 조립 가능한 소프트웨어를 위한 혁신적인 빌드 시스템입니다.\n\nBit를 사용하면 독립적인 구성 요소를 빌드할 수 있습니다. 이러한 구성 요소는 격리된 공간에서 설계, 개발, 버전 관리되며 원격 범위에 호스팅됩니다. 이러한 범위는 컴포넌트를 더 잘 시각화하고 유지보수하기 쉽게 해주는 네임 스페이스를 통해 컴포넌트를 논리적으로 구조화하도록 장려합니다.\n\n\n\n위에서 보듯이, 브랜드, 요소, 폰트라는 다른 네임스페이스에서 구성 요소를 논리적으로 정렬했습니다. 이러한 네임스페이스를 활용하여 Bit를 사용하여 FSD를 쉽게 처리할 수 있습니다!\n\n# 단계 01: 필수 조건\n\n먼저 Bit의 버전 관리자(BVMM)를 사용하여 Bit을 전역적으로 설치한 다음 React로 워크스페이스를 초기화하십시오. 이를 통해 React 공간에서 FSD에 작업할 수 있습니다.\n\n```js\n# bit 설치\nnpx @teambit/bvm install \n\n# 워크스페이스 초기화\nbit new react workspace --default-scope dummyorg.fsd --aspect teambit.react/react-env\n```\n\n\n\n더미org.fsd를 본인의 비트 사용자 이름 및 범위 이름으로 교체하세요.\n\n작업 공간을 성공적으로 생성했다면 아래의 출력이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png\" /\u003e\n\n다음으로 로컬 서버를 시작하려면 bit start를 실행하세요. 아래의 출력이 나타날 것입니다:\n\n\n\n# 단계 02: Feature Sliced Design을 사용한 React 앱 정의하기\n\n이제 Bit Components를 사용하여 Feature Sliced Design을 기반으로 한 React 앱을 구축해보겠습니다. 이 데모에서는 블로그 목록을 가져오는 React 앱을 구축해보겠습니다.\n\n그래서, 우리 앱에서는 다음이 있을 것입니다:\n\n- 앱 전체를 유지하는 React 앱\n- 블로그 항목을 렌더링하는 Blog 페이지\n- 단일 블로그 항목을 렌더링하는 Card 컴포넌트\n- 블로그를 나타내는 엔티티\n- 블로그 목록을 가져오는 API 호출\n\n\n\n만약 이것을 FSD로 구조화한다면, 다음과 같이 논리적인 매핑이 있어야 합니다:\n\n- app: 이 디렉토리는 블로그 목록을 위한 React 앱 컴포넌트를 보관할 것입니다.\n- pages: 이 디렉토리는 블로그 목록 페이지를 위한 컴포넌트를 보관할 것입니다.\n- widgets: 블로그 목록을 정의하는 단일 슬라이스가 생성될 것입니다.\n- features: 첫 번째 기능으로 get-blog-posts 라는 슬라이스를 정의할 것입니다. 이 슬라이스에서는 기능이 작동하기 위한 데이터 가져오기 메커니즘을 정의하는 모델 세그먼트를 정의할 것입니다.\n- entities: blog 라는 슬라이스를 정의할 것입니다. 블로그 슬라이스 내에서는 모델과 ui 두 세그먼트가 있을 것입니다. 모델에서는 블로그 항목의 데이터 모양을 정의하고, ui에서는 블로그 포스트 카드를 정의하는 React 컴포넌트인 blog-card를 가질 것입니다.\n\n# 단계 03: Bit를 사용하여 컴포넌트 생성하기\n\n다음으로, Bit를 사용하여 모든 필요한 컴포넌트를 생성해보겠습니다.\n\n\n\n## 1: 엔티티 레이어 구축하기\n\n먼저, 엔티티 레이어를 구축해 봅시다. 이를 위해 다음 명령을 사용하여 블로그 슬라이스를 생성해 보세요:\n\n```js\nbit create react-hook entities/blog/model \u0026\u0026 bit create react entities/blog/ui/blog-item\n```\n\n아래와 같이 새 디렉토리가 생성된 것을 확인할 수 있어요:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_1.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_2.png\" /\u003e\n\n비트(Bit)를 사용하면 spec.tsx 파일과 composition.tsx 파일을 얻을 수 있다는 것을 이미 알아채셨을 것입니다. 단일 컴포넌트에 대한 테스트 케이스를 만들어 테스트 주도 개발(Test Driven Development)로 빌드할 수 있습니다. 또한 compositions 파일을 사용하여 소비자들에게 컴포넌트가 어떻게 사용될 수 있는지 보여주기 위해 컴포넌트의 다른 출력물을 생성할 수 있습니다.\n\n그 다음, 블로그 모델과 블로그 카드 UI를 모델.ts와 blog-item.tsx 파일을 아래와 같이 업데이트하여 정의해 보겠습니다:\n\n\n\n\n```js\n// blog-item.tsx\n\nimport type { ReactNode } from 'react';\nexport type BlogItemProps = {\n  id: string,\n  title: string,\n  description: string\n  tags: string[]\n};\nconst cardStyle: React.CSSProperties = {\n  border: '1px solid #ddd',\n  borderRadius: '8px',\n  padding: '16px',\n  margin: '16px',\n  boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',\n  backgroundColor: '#fff',\n};\nconst titleStyle: React.CSSProperties = {\n  fontSize: '1.5rem',\n  marginBottom: '8px',\n};\nconst tagsStyle: React.CSSProperties = {\n  marginTop: '8px',\n  color: '#555',\n};\nexport function BlogItem({ description, id, title, tags }: BlogItemProps) {\n  return (\n    \u003cdiv className=\"blog-card\"\n      key={id}\n      style={cardStyle}\u003e\n      \u003ch2 style={titleStyle}\u003e{title}\u003c/h2\u003e\n      \u003cp\u003e{description}\u003c/p\u003e\n      \u003cdiv className=\"tags\" style={tagsStyle}\u003e\n        \u003cstrong\u003eTags:\u003c/strong\u003e {tags.join(', ')}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n위에서 보듯이, 블로그 엔티티 및 블로그 카드를 정의하여 블로그를 볼 수 있는 기능을 구현할 수 있습니다. 전체 구현을 보려면 Bit Cloud에서 이 컴포넌트를 확인하세요.\n\n하지만 로컬 서버는 이후 이렇게 보여야 합니다:\n\n## 2: 기능 레이어 구축하기\n\n\n\n다음으로, get-blog-posts 기능을 구축해 봅시다. 이를 위해 하나의 세그먼트가 필요합니다:\n\n- model: 데이터를 가져오는 훅을 정의합시다.\n\n이를 위해 React 컴포넌트를 생성해 봅시다:\n\n```js\nbit create react-hook features/get-blog-posts/model\n```\n\n\n\n그런 다음 아래와 같이 표시된 결과물을 보게 될 거에요:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_3.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_4.png\" /\u003e\n\nmodel.ts 파일을 열어서 아래 코드를 포함시켜서 블로그를 가져와보세요:\n\n\n\n```js\nimport { useBlogStore } from '@dummyorg/fsd.entities.blog.model';\nimport { useEffect } from 'react';\n\nexport function useGetBlogs() {\n  const { blogs, getBlogs, loading } = useBlogStore();\n  useEffect(() =\u003e {\n    getBlogs();\n  });\n  return { blogs, loading };\n}\n```\n\n# 3: 위젯 레이어 구축하기\n\n이제 위젯인 블로그 목록을 만들어봅시다. 이를 위해 블로그 목록이라는 슬라이스와 슬라이스 내에 ui라는 세그먼트를 생성합시다. 다음 명령어를 사용하여 이 작업을 수행할 수 있습니다:\n\n```js\nbit create react widgets/blog-list/ui\n```\n\n\n\n새로운 디렉토리가 추가된 것을 확인해야 합니다:\n\n![새 디렉토리 추가 사진](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_5.png)\n\nui.tsx 파일을 열고 아래 코드를 추가해주세요:\n\n```js\nimport React from 'react';\nimport { Blog } from '@dummyorg/fsd.entities.blog.model';\nimport { BlogItem } from '@dummyorg/fsd.entities.blog.ui.blog-item';\n\nexport type UiProps = {\n  blogs: Blog[]\n};\nexport function Ui({ blogs = [] }: UiProps) {\n  return blogs.map((blog) =\u003e (\u003cBlogItem\n    key={blog.id}\n    description={blog.description}\n    id={blog.id}\n    tags={blog.tags}\n    title={blog.title}\n  /\u003e))\n}\n```\n\n\n\n지역 서버로 이동하여 다음을 볼 수 있어요:\n\n![Developing Scalable Frontends with Feature-Sliced Design](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_6.png)\n\nBit Cloud에서 해당 구성 요소의 전체 구현을 살펴볼 수 있어요.\n\n# 4: 페이지 레이어 구축\n\n\n\n다음으로, 블로그 목록을 나타내는 페이지를 만들어 보겠습니다. 이를 위해 슬라이스인  blog-list와 세그먼트인 ui를 생성해봅시다. 다음 명령어를 실행하세요:\n\n```js\nbit create react pages/blog-list/ui\n```\n\n이 명령을 실행하면 다음과 같이 출력됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_7.png\" /\u003e\n\n\n\n다음으로 ui.tsx 파일을 열고 다음 스니펫을 포함하세요:\n\n```js\nimport React from 'react';\nimport { useGetBlogs } from '@dummyorg/fsd.features.get-blog-posts.model';\nimport { BlogList } from '@dummyorg/fsd.widgets.blog-list.ui';\n\nexport function Ui() {\n  const { blogs, loading } = useGetBlogs();\n  if (loading) {\n    return \u003cp\u003e\n      Posts are loading...\n    \u003c/p\u003e\n  }\n  return (\n    \u003cBlogList\n      blogs={blogs}\n    /\u003e\n  );\n}\n```\n\n로컬 서버에서 아래와 같은 출력이 표시됩니다:\n\n\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해드리겠습니다.\n\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_10.png\" /\u003e\n\n우리는 이렇게 페이지를 설정했어요! 자세히 알아보려면 Bit Cloud에서 확인해보세요.\n\n# 5: 앱 레이어 구축\n\n\n\n\n마지막으로, 이 모든 것을 사용하는 앱을 만들어봅시다. 다음 명령을 실행하세요:\n\n```js\nbit create react-app app\n```\n\n이렇게 하면 앱 컴포넌트가 생성되며 아래와 같이 결과가 생성됩니다:\n\n![Output](/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_11.png)\n\n\n\n이 앱을 Bit 서버 외부에서 로드할 수 있도록하려면 다음 몤령을 실행하십시오:\n\n```js\nbit use app\n```\n\n앱이 로드 가능한지 확인하려면 다음 몤령을 실행하십시오:\n\n```js\nbit app list\n```\n\n\n\n만약 당신의 앱이 로드될 수 있다면, 아래 출력을 확인할 수 있어야 합니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_12.png\" /\u003e\n\n다음으로, 파일인 — app.tsx을 열고 다음 단락을 포함하세요:\n\n```js\nimport React from \"react\";\nimport { BlogListPage } from \"@dummyorg/fsd.pages.blog-list.ui\";\n\nexport function App() {\n  return \u003cBlogListPage /\u003e\n}\n```\n\n\n\n다음으로, 명령어를 실행하여 앱을 시작해보세요:\n\n```js\nbit run app\n```\n\n로컬호스트에서 앱이 시작되는 것을 확인할 수 있어요.\n\n앱의 전체 구현을 보려면 Bit Cloud에서 확인해보세요.\n\n\n\n# 마무리\n\n보셨듯이, Feature Sliced Design은 응용 프로그램을 명확하고 구조화된 방식으로 구성할 때 매우 유용합니다. 팀원들이 프로젝트를 빠르게 탐색하고 기능을 더 잘 이해할 수 있도록 돕습니다.\n\n만약 우리가 만든 앱을 살펴보고 싶다면, Bit Cloud에서 확인해보세요.\n\n본문이 도움이 되었기를 바랍니다. FSD를 직접 시도해보고, 이 패턴에 대한 생각을 저에게 알려주세요!\n\n\n\n감사합니다.\n\n## 더 알아보기","ogImage":{"url":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png"},"coverImage":"/assets/img/2024-05-14-DevelopingScalableFrontendswithFeature-SlicedDesignFSD_0.png","tag":["Tech"],"readingTime":10},{"title":"Nodejs 어플리케이션의 성능 최적화 기술","description":"","date":"2024-05-14 12:37","slug":"2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png\" /\u003e\n\n웹 애플리케이션을 구축할 때 성능이 중요합니다. 빠르고 신뢰할 수 있는 애플리케이션을 구축하여 사용자 경험을 향상시키는 것이 목표입니다. 반응이 빠른 앱은 사용자를 끌어들이고 보유율을 향상시킵니다. 그에 반해, 느린 애플리케이션은 사용자를 좌절시키고 포기로 이끌 수 있습니다.\n\n특히 Node.js로 백엔드 서비스를 구축하는 경우, 성능은 후술할 수 없습니다. Node.js는 빠른 속도로 알려져 있지만, 이것이 반드시 애플리케이션이 최적으로 작동할 것이라는 것을 보장하지는 않습니다. Node.js의 잠재력을 극대화하려면 의도적인 조치를 취해야 합니다.\n\n이 기사에서는 Node.js 애플리케이션의 성능을 개선하기 위한 다양한 기술과 모범 사례를 살펴보겠습니다.\n\n\n\n# 성능 최적화의 중요성\n\n성능 최적화는 언제나 애플리케이션의 속도를 향상시키는 것만을 의미하는 것은 아닙니다. 또한 메모리, CPU, 대역폭과 같은 자원을 낭비하지 않는 것에 관한 것입니다. 최적화되지 않은 앱은 자원을 낭비하고 더 많은 비용이 들어갑니다. 하드웨어 자원이 제한적인 상황에서 최적화를 통해 현재의 자원을 최대한 활용할 수 있습니다. 불필요한 업그레이드를 하지 않고 예산 이상으로 지출하는 일을 피할 수 있습니다.\n\n확장성 또한 중요합니다. 적절히 최적화된 앱은 문제 없이 동시 사용자들을 처리할 수 있습니다.\n\nNode.js의 논블로킹 스타일 때문에 최적화가 더욱 중요합니다. Node는 병렬 IO에 좋지만 CPU 집약적인 작업이 전체적으로 성능을 늦추는 일이 발생할 수 있습니다. 이벤트 루프가 원활하게 작동하도록 유지해야 합니다. 최적화되지 않은 코드는 성능 저하로 이어지며, 이는 불만족스러운 사용자, 높은 비용, 그리고 놓치는 기회로 이어질 수 있습니다. 적절한 최적화는 이러한 문제를 방지하고 애플리케이션이 효율적이고 수익성 있게 운영될 수 있도록 유지해줍니다.\n\n\n\n# 성능 최적화를 고려해야 하는 시점은 언제일까요?\n\nNode.js 앱을 구축할 때 항상 성능 최적화를 고려해야 합니다. 초기 계획부터 배포 이후까지 항상 염두에 둬야 합니다. 그럼에도 불구하고 성능 최적화에 실제로 노력을 기울여야 하는 특정 시점들이 있습니다:\n\n- 초기 개발: 디자인, 아키텍처, 알고리즘 및 접근 방식을 처음부터 올바르게 정하는 것은 나중에 큰 이익을 가져다 줍니다. 효율성, 확장성 및 유지보수성을 초기에 우선시하는 것이 성공의 열쇠가 됩니다.\n- 기술적 부채 해결: 앱이 성장하고 발전함에 따라 기술적 부채가 늘어납니다. 이를 방치하면 시간이 지남에 따라 성능을 제한할 수 있습니다. 정기적인 리팩터링, 최적화 작업 및 코드 정리를 통해 볼륨을 줄이는 것이 중요합니다.\n- 새로운 기능: 새로운 기능을 추가하는 것은 성능에 반드시 영향을 미칩니다. 새로운 기능을 출시하기 전에 전반적인 사용자 경험을 감소시키지 않도록 작업해야 합니다.\n- 배포 전: 배포하기 전에 실제로 앱이 실제 워크로드를 처리할 수 있는지 확인해야 합니다! 배포 전에 철저한 성능 테스트와 튜닝은 필수입니다.\n- 병목현상 대응: 개발, 테스트 또는 프로덕션 중에 느려짐이나 문제가 발생할 때마다 성능 병목 현상을 신속히 식별하고 최적화를 통해 해결해야 합니다.\n- 운영 비용 절감: 최적화가 잘 된 앱은 CPU, 메모리, 대역폭 및 기타 부분에 더 관대하여 실행 및 확장 비용이 적게 들게 됩니다. 비용을 고려하는 팀에게 큰 이점이 됩니다.\n- 부하 테스트: 모의 트래픽을 사용하여 부하 테스트를 진행하면 스케일링 제한, 과도한 부하를 견뎌야 하는 병목 현상 및 출시 전 최적화 기회를 발견할 수 있습니다.\n- 인프라 확장: 수요를 충족하기 위해 인프라가 성장함에 따라 최적화 전략도 가져가야 합니다. 확장을 위한 튜닝을 재방문하여 효율성을 확보해야 합니다.\n- 제한된 환경 자원: 엣지 장치, 임베디드 시스템 또는 다른 제한된 사용 사례의 경우, 제한된 자원을 극대화하기 위해 가혹한 최적화가 필요합니다.\n- 지속적인 유지보수: 최적화는 일회성 작업이 아닙니다. 데이터가 증가하고 사용 패턴이 변하며 새 코드가 시간이 지남에 따라 도입될 때 계속해서 검토하고 조정해야 합니다.\n- 프로덕션 모니터링: 마지막으로, 프로덕션 환경에서 항상 귀를 기울이세요! 사용자 불만이나 느려짐을 나타내는 메트릭이 있으면 즉시 조사하고 개선 작업을 시작해야 합니다.\n\n# Node.js 앱 최적화 기술\n\n\n\n지금 당신이 Node.js 앱의 성능 최적화를 우선시해야 하는 시기를 이해했군요. 이제 Node.js 애플리케이션에서 최대 성능을 뽑아내는 가장 효과적인 방법을 알아봅시다:\n\n# 코드 프로파일링\n\nNode.js 애플리케이션을 최적화하려면 먼저 어디서 성능 병목 현상을 일으킬 수 있는지 알아야 합니다. 프로파일링을 통해 이를 파악할 수 있습니다. 이를 통해 코드 중 어느 부분이 가장 많은 시간과 자원을 소비하고 있는지를 보여줍니다. 느린 부분을 알면 그 부분을 개선하는 데 집중할 수 있습니다. 현재 앱의 상태를 결정하기 위해 다음 테스트를 수행해야 할 수도 있습니다:\n\n부하 테스트: 이는 앱이 정상적이고 예상대로의 사용자량과 트래픽을 처리하는 방식을 확인합니다. 앱을 정기적으로 사용할 때 발생하는 느림 현상이나 문제점을 발견할 수 있습니다.\n\n\n\n스파이크 테스팅: 이는 앱에 갑작스럽게 많은 사용자나 활동을 던집니다. 일반 부하보다 많습니다. 수요가 예상치 못하게 증가했을 때 앱이 어떻게 반응하는지, 어떤 한계에 도달하는지 보여줍니다.\n\n스트레스 테스팅: 이 테스트는 부하를 점진적으로 늘려서 앱을 한계까지 밀어붙입니다. 앱이 고장 나기까지 처리할 수 있는 최대치를 보여줘, 앱의 약점이나 부족한 리소스를 식별할 수 있게 해 줍니다.\n\n확장성 테스팅: 이는 앱이 추가적인 리소스(서버 또는 메모리)를 추가함으로써 더 많은 사용자와 트래픽을 쉽게 처리할 수 있는지를 살펴 봅니다. 앱의 확장을 원할하게 막는 병목 현상이나 구조적 문제를 확인합니다.\n\n이 상기 중 일부 또는 전부의 테스트를 수행하는 것은 여러 중요한 측정 항목을 제공합니다.\n\n\n\n- 응답 시간\n- 평균 지연 시간\n- 오류율\n- 초당 요청 수\n- 처리량\n- CPU 및 메모리 사용량\n- 동시 접속 사용자\n\n그리고 더 많은 정보.\n\n# 네이티브 클러스터 모듈 또는 PM2를 사용하여 확장하기\n\nNode.js에는 멀티코어 시스템을 활용하고 부하를 여러 워커 프로세스로 분산시킬 수 있는 내장 클러스터 모듈이 함께 제공됩니다. 이를 통해 사용 가능한 모든 CPU 코어를 활용하여 응용 프로그램의 성능과 확장성을 향상시킬 수 있습니다. 여러 워커 프로세스 간에 부하를 분산시키는 방법을 살펴봅시다:\n\n\n\n```js\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);\n  for (let i = 0; i \u003c numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) =\u003e {\n    console.log(`워커 ${worker.process.pid}가 코드 ${code}와 시그널 ${signal}로 종료되었습니다`);\n    console.log('새로운 워커를 시작 중');\n    cluster.fork();\n  });\n} else {\n  http.createServer((req, res) =\u003e {\n    res.writeHead(200);\n    res.end('워커 프로세스에서 안녕하세요\\\\n');\n  }).listen(8000);\n  console.log(`워커 ${process.pid}가 시작되었습니다`);\n}\n```\n\n마스터 프로세스는 각 사용 가능한 CPU 코어에 대해 새로운 워커 프로세스를 포크합니다. 각 워커 프로세스는 포트 8000에서 수신하는 HTTP 요청을 처리합니다. 워커 프로세스가 충돌하면 마스터 프로세스가 알림을 받고 충돌한 프로세스를 대체하기 위해 새로운 워커를 생성합니다.\n\n대부분의 경우, 추가 기능을 제공하며 편의성을 제공하는 PM2 (Process Manager 2)를 사용하는 것이 좋습니다. 보일러플레이트를 작성할 필요가 없습니다.\n\nPM2를 사용하여 확장하기 위해서는 먼저 설치해야 합니다:\n\n\n\n\n```js\nnpm install pm2 --save-dev\n```\n\n설치가 완료되면 PM2를 사용하여 애플리케이션을 시작하고 클러스터링을 활성화할 수 있습니다:\n\n```js\npm2 start app.js -i max\n```\n\n-i max 플래그는 PM2가 사용 가능한 CPU 코어 수만큼 애플리케이션 인스턴스를 시작하도록 지시합니다. PM2는 자동으로 이러한 인스턴스 간에 들어오는 요청을 로드 밸런싱합니다.```\n\n\n\n다음과 같이 수동으로 시작할 인스턴스 수를 지정할 수도 있습니다:\n\n```js\npm2 start app.js -i 4\n```\n\n당신의 어플리케이션의 인스턴스를 네 개 시작할 것입니다.\n\nPM2는 제로 다운타임 리로드, 모니터링, 로깅과 같은 부가 기능을 갖추고 있어서 프로덕션 환경에서 Node.js 어플리케이션을 관리하고 확장하는 인기 있는 도구입니다.\n\n\n\n# Gzip 압축 활용하기\n\nGzip 압축은 서버와 클라이언트 간에 전송되는 데이터 양을 현저히 줄여 더 빠른 응답 시간과 향상된 성능을 제공할 수 있습니다. 특히 HTML, CSS, JavaScript와 같은 대량의 텍스트 기반 콘텐츠를 제공하는 애플리케이션에 대해 유용합니다.\n\nNode.js에서는 compression이라는 라이브러리를 사용하여 Gzip 압축을 활성화할 수 있습니다. compression을 사용하려면 먼저 npm을 통해 설치하고 express 프로젝트에 가져와야 합니다:\n\ncompression 라이브러리 설치하기:\n\n\n\n```js\nnpm install compression\n```\n\n압축 라이브러리를 사용하는 방법:\n\n```js\nconst express = require('express');\nconst compression = require('compression');\nconst app = express();\n\n// Gzip 압축 활성화\napp.use(compression());\n\napp.use(express.static('public'));\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000 에서 실행 중입니다');\n});\n```\n\n이 미들웨어는 요청의 Accept-Encoding 헤더와 응답의 콘텐츠 유형에 따라 응답 데이터를 자동으로 압축합니다.\n\n\n\n텍스트 기반 콘텐츠를 제공할 때 Gzip을 사용하면 서버와 클라이언트 간 전송되는 데이터 양을 줄일 수 있어 더 빠른 응답 시간을 얻을 수 있어요.\n\n# 타임아웃 블로킹 I/O 작업 사용하기\n\nNode.js는 많은 연결을 동시에 처리할 수 있도록 설계되어 있어서 묶이는 작업을 피해야 합니다. 그러나 파일을 읽는 등 느린 I/O 작업이 막히게 되면 Node.js가 효율적으로 다른 작업을 수행하는 것을 막을 수 있어요. 이를 방지하기 위해 느린 I/O 작업에는 타임아웃을 사용하세요. 타임아웃은 작업이 완료되는 데 걸리는 최대 시간을 설정해줘요. 너무 오랜 시간이 걸리면 작업을 취소하거나 다른 모든 것을 막지 않고 처리할 수 있어요.\n\n파일을 읽을 때 타임아웃을 설정하는 것은 매우 간단해요:\n\n\n\n```js\nconst fs = require('fs');\n\n\nconst MAX_TIMEOUT = 5000;\nconst readFile = (filePath, callback) =\u003e {\n  fs.readFile(filePath, (err, data) =\u003e {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, data);\n  });\n};\n\nconst readFileWithTimeout = (filePath, callback) =\u003e {\n  const timeoutId = setTimeout(() =\u003e {\n    callback(new Error('파일 읽기 작업 시간 초과'));\n  }, MAX_TIMEOUT);\n  readFile(filePath, (err, data) =\u003e {\n    clearTimeout(timeoutId);\n    if (err) {\n      return callback(err);\n    }\n    callback(null, data);\n  });\n};\n```\n\nreadFileWithTimeout 함수는 setTimeout을 사용하여 5초 타임아웃을 설정합니다. fs.readFile 작업에 더 오랜 시간이 걸리면 타임아웃 콜백이 트리거되어 제공된 콜백에 오류를 전달합니다.\n\n만약 타임아웃 전에 readFile이 완료되면 clearTimeout이 타임아웃을 취소하고 파일 데이터를 콜백에 전달합니다.\n\n타임아웃 값은 앱의 요구 사항을 균형있게 유지해야 합니다. 너무 짧으면 합법적인 긴 작업을 자르는 위험이 있고, 너무 길면 타임아웃을 사용하는 목적을 상쇄시킬 수 있습니다.\n```\n\n\n\n# I/O 작업에는 스트리밍을 사용하세요\n\n스트리밍은 대용량 파일, 네트워크 응답 또는 데이터가 전체가 메모리로 로드되기를 기다리는 대신 도착하는 즉시 처리해야 하는 시나리오와 같이 데이터를 처리해야 하는 경우에 매우 유용합니다. 특히 대량의 데이터를 다루는 I/O 작업을 최적화할 때 Node.js 애플리케이션에 대한 강력한 기술 중 하나입니다.\n\n만약 수백만 개의 행이 있는 멀티 기가바이트 CSV 파일을 읽어야 한다고 가정해 봅시다. 스트림을 사용하여 데이터를 작은 조각 단위로 처리할 수 있습니다. 어떤 말인지 확인해 볼까요:\n\n```js\nconst fs = require('fs');\nconst stream = require('stream');\nconst csvParser = require('csv-parser');\n\nconst csvStream = fs.createReadStream('bigdata.csv')\n  .pipe(csvParser());\n\nconst writableStream = new stream.Writable({\n  write(chunk, encoding, next) {\n    console.log('CSV 데이터 청크를 받았습니다:', chunk);\n    next();\n  }\n});\n\ncsvStream.pipe(writableStream);\n\nwritableStream.on('error', (err) =\u003e {\n  console.error('에러 발생:', err);\n});\n\nwritableStream.on('finish', () =\u003e {\n  console.log('CSV 데이터 처리 완료.');\n});\n```\n\n\n\n가독성 있는 csvStream은 CSV 데이터를 작성 가능한 스트림으로 물 흐르듯이 전달합니다. write 메서드는 전체 CSV 파일이 메모리에 로드되기를 기다리지 않고 각 청크가 도착할 때마다 처리합니다.\n\n스트리밍은 메모리 블로트를 방지하고 대용량 CSV 파일과 같은 I/O 집중적 작업의 성능을 향상시킵니다. 메모리에 완전히 로드하는 것이 현실적이지 않거나 대용량 API 응답인 대규모 데이터 집합을 처리해야 하는 모든 시나리오에 이상적입니다.\n\n# 종속성 최소화\n\n의존성은 유용한 기능을 제공하고 작업 흐름을 가속화할 수 있지만, 너무 많은 종속성을 갖거나 오래된 또는 불필요한 종속성을 사용하는 것은 때로 응용 프로그램의 성능에 부정적으로 영향을 미칠 수 있습니다.\n\n\n\n자바스크립트 애플리케이션에서 종속성을 최소화하는 방법을 살펴봐요:\n\n- 검토하고 사용하지 않는 종속성 제거: 프로젝트의 종속성을 주기적으로 검토하고 사용되지 않거나 불필요한 패키지를 제거해요. npm-prune이나 depcheck과 같은 도구를 사용하여 사용되지 않는 종속성을 식별하고 제거할 수 있어요.\n\n```js\nnpm install -g npm-prune\n```\n\nprune 명령어를 실행하여 사용되지 않는 종속성을 제거하세요.\n\n\n\n```js\nnpm prune\n```\n\n- 정기적으로 의존성 업그레이드: 최신 안정 버전으로 정기적으로 업그레이드하여 의존성을 최신 상태로 유지하세요. 오래된 의존성은 보안 위험을 가져올 수 있고 버그를 발생시킬 수 있으며 성능 향상을 놓칠 수 있습니다. npm-check-updates나 npm outdated와 같은 도구를 사용하여 사용 가능한 업데이트를 확인할 수 있습니다.\n\n패키지 설치\n\n```js\nnpm install -g npm-check-updates\n```\n\n\n\n업데이트 가능한 내용을 확인해보세요:\n\n```bash\nnpm-check-updates\n```\n\n의존성 패키지를 업데이트하세요:\n\n```bash\nnpm-check-updates -u\nnpm install\n```\n\n\n\n- 번들러와 트리 쉐이킹 활용: Webpack이나 Rollup과 같은 모듈 번들러를 사용하여 트리 쉐이킹을 수행할 수 있습니다. 이는 응용 프로그램과 의존성에서 사용되지 않는 코드를 제거하는 프로세스로, 최종 번들 크기를 크게 줄이고 성능을 향상시킬 수 있습니다.\n- 작은 및 특정한 종속성 선호: 종속성을 선택할 때, 필요한 기능만 제공하는 작고 집중된 패키지를 선택하는 것이 좋습니다. 사용하지 않는 기능이 많은 대규모의 모놀리틱 라이브러리보다 낫습니다.\n- 사용자 정의 코드 작성 고려: 경우에 따라, 필요한 기능이 상대적으로 간단하거나 응용 프로그램에 특정한 경우에는 의존성에 의존하는 대신 사용자 정의 코드를 작성하는데 가치가 있을 수 있습니다.\n\n# 부하 분산\n\nNode.js 응용 프로그램이 성장하고 더 많은 트래픽을 처리할 때, 성능과 가용성을 유지하기 위해 해당 부하를 여러 서버에 분산해야 합니다. 여기서 부하 분산이 유용하게 사용됩니다. 부하 분산은 들어오는 요청을 여러 서버 그룹에 분산하여 어떤 서버가 과부하가 걸리지 않도록 합니다. 다음과 같은 소프트웨어 솔루션을 사용할 수 있습니다:\n\n- Nginx 또는 HAProxy\n- 클라우드 부하 분산 서비스 (AWS ELB, Google Cloud Load Balancing 등)\n\n\n\n효과적인 로드 밸런싱은 작업 부하를 공유하여 성능을 향상시킵니다. 또한 장애 허용성을 강화합니다. 한 대의 서버가 실패하면 트래픽이 건강한 서버로 리디렉션되어 가용성을 유지합니다.\n\nNode.js는 백엔드 서비스를 구축하는 데 훌륭한 도구입니다. 그러나 정적 파일을 제공하는 데 최적화되어 있지 않아 이 작업을 수행할 때 성능 병목 현상을 겪을 수 있습니다. Nginx를 사용하여 Node.js 응용 프로그램의 정적 자산을 제공하는 반대 프록시로 사용할 수 있습니다. 이렇게하면 Node.js 앱이 동적 요청과 응용 프로그램 논리를 처리하고 있는 동안 Nginx가 정적 파일 제공 능력을 최적화하여 성능과 확장성을 향상시킵니다.\n\n# CPU 집약적 작업 외부로 이전하기\n\n\n\nNode는 한 번에 여러 I/O 작업을 처리하는 데 능숙합니다. 그러나 숫자 처리나 미디어 처리와 같은 무거운 CPU 작업에 대해선 싱글 스레드로 구성되어 있어 성능이 떨어질 수 있습니다. 이 CPU 집약적인 작업은 모든 것을 늦추고 지연을 초래할 수 있습니다.\n\n해결책은 CPU 집약적인 작업을 별도의 프로세스나 서비스로 오프로드하는 것입니다. 이렇게 하면 주요 Node 프로세스가 일반 I/O 작업을 위해 재빠르게 유지됩니다.\n\n다음과 같은 것들을 사용할 수 있습니다:\n\n- 여러 코어에 병렬로 CPU 작업을 실행하기 위한 자식 프로세스\n- Node 내에서 별도의 스레드에서 CPU 작업을 실행하기 위한 워커 스레드\n- 클라이언트 측 CPU 스크립팅을 위해 백그라운드 스레드에서 사용되는 웹 워커\n- 코드를 클라우드에서 실행하기 위한 AWS Lambda와 같은 서버리스 함수\n- 이미지 처리와 같은 CPU 집약적인 작업을 위해 설계된 외부 API\n\n\n\n숫자를 계산하는 부분을 분리함으로써 Node의 단일 스레드를 너무 많이 사용하지 않도록 할 수 있어요. 앱은 기존에 좋은 성능을 보여주던 정상적인 네트워킹 및 I/O 작업에 반응하면서 원활하게 작동할 거에요. CPU도 다른 부분에서 충분히 활용할 수 있게 되죠.\n\n# 최신 Node.js 버전 사용하기\n\nNode.js는 적극적으로 개발 및 유지보수되는 프로젝트로, 새로운 기능, 성능 향상 및 버그 수정이 소개되는 빈도 높은 릴리스들을 발표하고 있어요. 구 버전의 Node.js를 사용하면 성능 문제, 보안 취약점 및 최신 라이브러리 및 프레임워크와의 호환성 문제가 발생할 수 있어요. 새로운 Node.js 릴리스는 V8 JavaScript 엔진에 대한 최적화와 개선 사항이 포함되어 있어 실행 시간 및 전체 성능을 향상시킬 수 있어요.\n\nNode.js를 업그레이드하려면 Node.js 공식 웹사이트에서 최신 버전을 다운로드하거나 nvm과 같은 버전 관리자를 사용할 수 있어요. 이 도구를 사용하면 다양한 Node.js 버전을 쉽게 설치하고 전환할 수 있어요.\n\n\n\n만약 이미 컴퓨터에 nvm이 설치되어 있다면, 최신 Node.js 버전을 쉽게 설치할 수 있어요.\n\n아래 명령어를 실행하여 사용 가능한 Node.js 버전을 확인할 수 있어요:\n\n```js\nnvm ls-remote\n```\n\n최신 Node.js 버전을 설치하세요:\n\n\n\n```js\nnvm install \u003cnodejs 버전\u003e\n```\n\n가장 최근에 설치된 버전을 사용하려면:\n\n```js\nnvm use \u003cnodejs 버전\u003e\n```\n\n호환성 문제로 인해 다른 Node.js 버전 간을 전환하려면 동일한 nvm use 명령을 사용할 수 있습니다. 즉, Node.js 버전을 최신 상태로 유지하여 응용 프로그램이 최신 성능 향상을 누리는 것이 좋습니다.\n\n\n\n## 마무리\n\n성능 최적화는 Node.js 애플리케이션의 전체 개발 수명 주기 동안 내재화되어야 하는 지속적인 반복 프로세스입니다. 구현할 최적화 기술을 선택하기 전에 각 전략을 귀하의 특정 응용 프로그램 요구 사항, 인프라 및 성능 목표에 대해 평가해보세요.\n\n해피 해킹!","ogImage":{"url":"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png"},"coverImage":"/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png","tag":["Tech"],"readingTime":12},{"title":"앵귤러 172에서의 Material 3 실험적 지원","description":"","date":"2024-05-14 12:36","slug":"2024-05-14-Material3ExperimentalSupportinAngular172","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png\" /\u003e\n\n안녕하세요! Angular 17.2에서는 Angular Material에서 Material 3 테마를 실험적으로 지원한다는 기쁜 소식을 전합니다.\n\n본 블로그 포스트에서는 이 기능에 대한 최신 소식을 업데이트하고 Material 3 지원에 대한 미리보기를 제공할 예정입니다.\n\n# Material 3이란 무엇인가요?\n\n\n\nMaterial 3는 Material Design의 최신 진화 버전으로, 구글의 오픈 소스 디자인 시스템입니다. Angular용 Material 3는 대체 테마로 구현되어 있으며, 현재 사용 중인 Angular Material 구성 요소와 Sass 믹스인과 호환됩니다.\n\nMaterial 3 테마는 디자인 토큰을 기반으로 하며(CSS 사용자 정의 속성으로 구현됨), CSS 선택기 특이성을 증가시키지 않고도 테마를 더 쉽게 재정의할 수 있게 합니다. 이는 내부 Angular Material 요소에 CSS 선택기를 지정할 필요 없이 특정 속성을 세밀하게 재정의할 수 있도록 합니다.\n\n# 애플리케이션에서 Material 3 사용하기\n\n앱에서 Material 3를 사용하려면, matx.define-theme을 사용하여 Sass에서 M3 테마를 생성하고 현재 사용 중인 Angular Material Sass 믹스인에 전달하면 됩니다.\n\n\n\n```scss\n@use '@angular/material' as mat;\n@use '@angular/material-experimental' as matx;\n\n$m3-dark-theme: matx.define-theme((\n  color: (\n    theme-type: dark,\n    primary: matx.$m3-indigo-palette,\n    tertiary: matx.$m3-blue-palette,\n  )\n));\n\n$m3-light-theme: matx.define-theme((\n  color: (\n    primary: matx.$m3-indigo-palette,\n    tertiary: matx.$m3-blue-palette,\n    )\n));\n\n.dark-theme {\n  @include mat.all-component-themes($m3-dark-theme);\n}\n\n.light-theme {\n  @include mat.all-component-themes($m3-light-theme);\n}\n```\n\nM3 테마는 CSS 사용자 정의 속성을 기반으로 하므로, 테마, 색상, 타이포그래피, 밀도 믹스인은 모두 추가 선택기 가중치 없이 CSS 사용자 정의 속성만 출력됨이 보장됩니다. 이는 최상위 수준에서 사용자 정의 속성을 정의하고 해당 속성이 필요한 구성 요소로 흐르게 할 수 있음을 의미합니다. Sass에서 `.dark-theme` 및 `.light-theme`의 순서와 상관없이 다음 레이아웃들이 예상대로 작동합니다.\n\n```html\n\u003cbody class=\"light-theme\"\u003e\n  Light theme\n  \u003csidenav class=\"dark-theme\"\u003eWith a dark sidenav!\u003c/sidenav\u003e\n\u003c/body\u003e\n```\n\n```html\n\u003cbody class=\"dark-theme\"\u003e\n  Dark theme\n  \u003csidenav class=\"light-theme\"\u003eWith a light sidenav!\u003c/sidenav\u003e\n\u003c/body\u003e\n```\n\n\n\nSass API 이상의 세밀한 사용자 정의는 CSS 사용자 지정 속성을 직접 설정하여 가능합니다. 예를 들어, 사용자가 특히 주의해야 할 체크박스를 강조하려는 경우:\n\n```js\n\u003cmat-checkbox class=\"scary-setting\"\u003e내 계정 삭제\u003c/mat-checkbox\u003e\n```\n\n```js\n.scary-setting {\n  // 내부 체크박스 선택기를 대상으로할 필요가 없어요! 🎉\n  - mdc-checkbox-unselected-hover-state-layer-color: red;\n  - mdc-checkbox-unselected-hover-icon-color: red;\n}\n```\n\n공식 Sass 믹스인과 마찬가지로, 이러한 속성은 사용되는 곳으로 흘러내려가기 때문에, 전체 부분이 무서운 체크박스가 있는 경우 해당 클래스를 모두에 적용할 필요가 없습니다. 이러한 사용자 정의가 적용되어야 하는 가장 높은 수준 요소에만 적용하면 됩니다.\n\n\n\n```js\n\u003csection class=\"scary-setting\"\u003e\n  \u003cmat-checkbox\u003e내 계정 삭제하기\u003c/mat-checkbox\u003e\n  \u003cmat-checkbox\u003e내 은행 계좌 비우기\u003c/mat-checkbox\u003e\n\u003c/section\u003e\n```\n\n# Material 2 지원\n\n매우 기쁘게도 Material 3를 소개할 수 있어 흥분되고 있으며, Material 2 테마는 완전히 지원됩니다.\n\nM2와 M3 테마를 처리하는 방식에는 몇 가지 차이가 있습니다. 특히 컴포넌트 색상 변형과 관련된 점이 주목할 만합니다. Material 3 사용 가이드에서 이러한 차이에 대해 자세히 알아볼 수 있습니다.```\n\n\n\n# 지금 시작하세요\n\n앵귤러 커뮤니티 여러분께 이번 업데이트 소식을 전하게 되어 너무 흥분되고 기쁩니다. 여러분의 피드백을 손꼽아 기다리고 있어요 — 이 게시물에 댓글을 남겨 의겢을 나눠주세요. Material 3 가이드로 이 기능을 오늘 바로 시도해볼 수 있어요. 우리는 안정적인 상태로 업그레이드하기 위해 사용자 정의 색상 팔레트 생성, 시스템 수준 토큰을 위한 CSS 변수, 그리고 API 개선에 계속해서 노력할 예정입니다.\n\n읽어주셔서 감사합니다. [전송 종료]","ogImage":{"url":"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png"},"coverImage":"/assets/img/2024-05-14-Material3ExperimentalSupportinAngular172_0.png","tag":["Tech"],"readingTime":3}],"page":"52","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"52"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>