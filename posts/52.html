<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Preact, HTM, 그리고 Signal을 활용한 빌드 없이 구축하는 JavaScript 애플리케이션" href="/post/2024-06-19-CreatingaBuildlessJavaScriptApplicationwithPreactHTMandSignal"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Preact, HTM, 그리고 Signal을 활용한 빌드 없이 구축하는 JavaScript 애플리케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CreatingaBuildlessJavaScriptApplicationwithPreactHTMandSignal_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Preact, HTM, 그리고 Signal을 활용한 빌드 없이 구축하는 JavaScript 애플리케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Preact, HTM, 그리고 Signal을 활용한 빌드 없이 구축하는 JavaScript 애플리케이션</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱을 Vite로 만드는 방법" href="/post/2024-06-19-HowToCreateaReactAppwithVite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱을 Vite로 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowToCreateaReactAppwithVite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱을 Vite로 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱을 Vite로 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 앱을 위한 GitLab과 Hostinger로 CICD 구현하기 단계별 안내" href="/post/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 앱을 위한 GitLab과 Hostinger로 CICD 구현하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 앱을 위한 GitLab과 Hostinger로 CICD 구현하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 앱을 위한 GitLab과 Hostinger로 CICD 구현하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="렌더링 전략 모든 React 개발자가 알아야 할 것들" href="/post/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="렌더링 전략 모든 React 개발자가 알아야 할 것들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="렌더링 전략 모든 React 개발자가 알아야 할 것들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">렌더링 전략 모든 React 개발자가 알아야 할 것들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="필수 준비물" href="/post/2024-06-19-Prerequisites"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="필수 준비물" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Prerequisites_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="필수 준비물" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">필수 준비물</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React의 Fiber 조정기는 어떻게 동작하나요" href="/post/2024-06-19-HowdoestheReactfiberreconcilerwork"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React의 Fiber 조정기는 어떻게 동작하나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React의 Fiber 조정기는 어떻게 동작하나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React의 Fiber 조정기는 어떻게 동작하나요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Fiber에 대한 설명 더 부드러운 UI를 위한 점진적 렌더링" href="/post/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Fiber에 대한 설명 더 부드러운 UI를 위한 점진적 렌더링" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Fiber에 대한 설명 더 부드러운 UI를 위한 점진적 렌더링" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Fiber에 대한 설명 더 부드러운 UI를 위한 점진적 렌더링</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="통계 학습에 대한 소개 - 소개" href="/post/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="통계 학습에 대한 소개 - 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="통계 학습에 대한 소개 - 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">통계 학습에 대한 소개 - 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GitHub Actions를 통한 간단한 모델 재학습 자동화" href="/post/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GitHub Actions를 통한 간단한 모델 재학습 자동화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GitHub Actions를 통한 간단한 모델 재학습 자동화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GitHub Actions를 통한 간단한 모델 재학습 자동화</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 하는 예상 향상 및 가우시안 프로세스 회귀 최적화에 대한 실습" href="/post/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 하는 예상 향상 및 가우시안 프로세스 회귀 최적화에 대한 실습" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 하는 예상 향상 및 가우시안 프로세스 회귀 최적화에 대한 실습" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬으로 하는 예상 향상 및 가우시안 프로세스 회귀 최적화에 대한 실습</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link posts_-active__YVJEi" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Preact, HTM, 그리고 Signal을 활용한 빌드 없이 구축하는 JavaScript 애플리케이션","description":"","date":"2024-06-19 23:57","slug":"2024-06-19-CreatingaBuildlessJavaScriptApplicationwithPreactHTMandSignal","content":"\n\n현대 웹 개발 시대에는 빌드 도구의 복잡성이 때로는 초보자들과 간단하게 유지하고 싶은 사람들에게 장벽이 될 수 있습니다 (K.I.S.S.).\n\n그러나 Preact, HTM, Signal과 같은 라이브러리들이 등장함으로써, 빌드가 필요 없는 JavaScript 애플리케이션을 생성하는 것이 가능할 뿐만 아니라 효율적으로 이루어질 수 있게 되었습니다.\n\n이 접근법은 빌드 구성의 부담 없이 프로젝트를 신속하게 설정할 수 있어 개발 프로세스를 빠르고 간편하게 만들어줍니다.\n\n## 왜 Preact, HTM, 그리고 Signal을 선택해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Preact: React의 3KB 빠른 대안인 Preact는 동일한 현대적 API를 제공하며, DOM 위에 가장 얇은 Virtual DOM 추상화를 제공합니다. 그 간결함과 작은 크기로 빌드 없이 설정이 필요한 환경에서 각 바이트가 중요한 경우 이상적입니다.\n- HTM: Hyperscript Tagged Markup (HTM)은 JSX와 유사한 구문을 변환 없이 브라우저에서 직접 사용할 수 있게 해줍니다. HTM은 Preact와 아름답게 결합되어, 빌드 단골 없이도 개발자 친화적인 템플릿 제작 경험을 제공합니다.\n- Signals: Preact와 원활하게 작동하는 상태 관리 라이브러리로, 애플리케이션 상태를 섬세하게 반응적 프로그래밍으로 처리할 수 있는 간단하고 효율적인 방법을 제공합니다.\n\n## 빌드 없는 환경 설정\n\n[여기](https://github.com/badpenguin/buildless-pwa)에서 GitHub에서 제 제작 App을 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빌드 없이 구현되는 전체 컨셉은 다음 두 가지 기반을 갖고 있어요:\n\n- 번들러 대신 ES 모듈과 ImportMap 사용;\n- JSX 대신 HTM 템플릿 리터럴 라이브러리 사용.\n\n그래서 브라우저가 ImportMap과 호환되어야 해요. 그것이 항상 그런 것은 아니에요. 그래서 시작할 때 다음 폴리필을 추가하는 것을 제안해요:\n\nhttps://github.com/guybedford/es-module-shims\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cscript async src=\"https://ga.jspm.io/npm:es-module-shims@1.7.3/dist/es-module-shims.js\"\u003e\u003c/script\u003e\n```\n\n그러면 \"fetch\" 및 기타 기능 지원 여부를 확인하는 몇 가지 확인 사항을 알게 될 것입니다.\n\n현대 브라우저에서도 이 기본 구조가 작동하지만, 기기의 기능을 항상 확인하는 것을 추천합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n외부에는 오래된 \"스마트 TV\"와 미친 JVM과 같은 이상한 오래된 장치들이 많이 있어요. 그래서 그들의 브라우저가 너무 오래되었다고 표시해 주는 것도 나쁘지 않겠죠.\n\n여기 importmap이 등장합니다.\n\n여기서 우리는 JS 엔진에게 import할 라이브러리를 어디에서 찾을 수 있는지를 지정해 줍니다.\n\nHTML 파일의 importmap은 종속성을 직접 선언하고, Preact, HTM, 그리고 Signal의 번들 버전을 가리키며, script 태그를 통해 로드할 수 있는 내용입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 설정은 개발 중에 번들러나 모듈 로더가 필요하지 않도록 만들어줍니다.\n\n```js\n\u003cscript type=\"importmap\"\u003e\n    {\n        \"imports\": {\n            \"preact\": \"/app/dist/standalone.js\",\n            \"preact/hooks\": \"/app/dist/standalone.js\",\n            \"htm\": \"/app/dist/standalone.js\",\n            \"@preact/signals\": \"/app/dist/standalone.js\",\n            \"@preact/signals-core\": \"/app/dist/standalone.js\",\n            \"preact-router\": \"/app/dist/preact-router.module.js\"\n        }\n    }\n\u003c/script\u003e\n```\n\n원격 라이브러리도 지정할 수 있지만 저는 항상 로컬 사본을 사용하는 것을 선호합니다. 특히 WebView(Cordova와 같은)를 사용하여 이 웹앱을 모바일 앱으로 번들하려고 할 때 말이죠.\n\nstandalone.js를 눈치채셨나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 몇 개의 라이브러리를 하나의 파일에 패키징했습니다. 이 프로젝트 덕분에:\n\nhttps://github.com/mujahidfa/preact-htm-signals-standalone\n\n이곳에서는 22KB 안에 훅과 시그널이 포함된 Preact와 HTM 템플릿 라이브러리를 받을 수 있습니다.\n\n이제 주 애플리케이션 컴포넌트를 부트스트랩할 준비가 되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cscript type=\"module\"\u003e\n  import {h, render} from 'preact';\n  import {MainApp} from '/app/main.js';\n\n  window.onload = function() {\n    console.log('* onload');\n    const app = h(MainApp);\n    render(app, document.getElementById(\"main\"));\n  }\n\u003c/script\u003e\n\u003cdiv id=\"main\"\u003e\u003c/div\u003e\n```\n\nReact에 익숙하다면, 이것은 단지 \"hello world\"일 뿐입니다.\n\n주목할 점은 main 구성요소가 별도의 파일인 main.js로 나뉘어져 있다는 것입니다. \"/app/main.js\"는 실제로 절대 또는 상대 URL이 될 수 있으며, 파일 경로가 아닙니다.\n\n## The splash screen example\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단순한 스플래시 화면 예제 역시 \"신호\"를 활용하는 방법을 보여드리기 위해 추가했어요.\n\n이 화면은 어플리케이션이 초기화되는 동안 보일 거에요.\n\n스플래시 화면에 대한 모든 CSS와 HTML은 외부 파일에 의존하지 말고 주요 index.html 파일 내에 넣어주세요.\n\n가능하다면 외부 HTTP 요청을 피하기 위해 이미지를 base64로 인라인으로 포함해주세요. 그렇지 않으면 여기서 \"사전로드(preload)\"의 개념을 잃을 것이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 프리로드\n\u003cpreload\u003e 요소에는 다음과 같은 스타일이 지정되어 있습니다.\n- 텍스트 색상: #6d1153\n- 배경색: #fff\n- 안쪽 여백: 1rem\n- 고정 위치: 화면 상단 좌측\n- 플렉스 박스로 설정, 세로 방향으로 정렬\n- 가운데 정렬\n- 글꼴: sans-serif\n- 글꼴 크기: 18px\n- 줄 높이: 1.7\n\npreload 요소의 이미지는 다음과 같이 스타일이 지정되어 있습니다.\n- 블록으로 표시\n- 아래 여백: 2rem\n\npreload 요소 내의 단락과 제목은 다음과 같은 스타일이 지정되어 있습니다.\n- 텍스트 색상: #333\n\npreload 요소 내의 링크는 다음과 같은 스타일이 지정되어 있습니다.\n- 링크 색상: #FF1978\n```\n\n이 main.js 파일에서 이것이 어떻게 숨겨지는지 상세히 보여드리겠습니다.\n\n## JSX 대신 HTML을 사용하여 개발\n\n그리고 이것이 \"Main\" 컴포넌트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {html} from 'htm';\nimport Router, {route} from 'preact-router';\nimport {signal} from '@preact/signals';\nimport {effect} from '@preact/signals-core';\n\nexport function MainApp() {\n console.debug('- render MainApp');\n return html`\n  ${$loading.value ? null : html`\n   \u003c${Router}\u003e\n    \u003c${PageHome} path=\"/\"/\u003e\n    \u003c${PageNotFound} default/\u003e\n   \u003c//\u003e`}\n `;\n}\n```\n\n위 코드에서는 JSX를 사용하는 대신 HTM 라이브러리를 사용하고 있습니다.\n\nHTM 구문은 브라우저에서 직접 JSX와 유사한 컴포넌트를 생성하는 데 사용되며, Signal은 상태 변경을 반응적으로 관리하여 사용자 상호 작용에 따라 UI를 업데이트합니다.\n\n이 구성 요소에서 $loading이 TRUE일 때만 렌더링되지 않습니다(널 값), 즉 div#main이 아닌 div#preload가 그대로 표시됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로딩이 완료되면 preact-router의 설정에 따라 페이지를 최종적으로 렌더링합니다.\n\n$loading 변수는 preact-signal로 생성된 오브젝트입니다.\n\n```js\nexport const $loading = signal(true);\n```\n\n메인 컴포넌트를 미리 채우는 초기화 함수를 만들고 작업이 완료되면 이 변수를 FALSE로 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsetTimeout(function(){\n console.log('- loading completed.');\n $loading.value = false;\n}, 1000);\n```\n\n“effect”와 “dispose”를 사용하여 $loading의 값이 변경될 때마다 “una tantum”(한 번만)을 가로채고 스플래시 화면을 숨길 수 있습니다:\n\n```js\nconst dispose = effect(() =\u003e {\n if ($loading.value) {\n  return;\n }\n console.debug('- app ready');\n // 프리로드 숨기기\n const preloadDiv = document.getElementById(\"preload\");\n preloadDiv.style.display = \"none\";\n dispose();\n});\n```\n\n$loading은 우리의 “Main” 컴포넌트 내에서 사용되므로, Main 컴포넌트를 자동으로 다시 렌더링하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 신호 및 HTM을 사용한 간단한 카운터 생성\n\n이 예제는 매우 간단합니다. 먼저 변수를 만들어주세요:\n\n```js\nexport const $counter = signal(0);\n```\n\n그리고 이 두 버튼으로 조작해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst PageHome = function() {\n console.debug('- render PageHome');\n return html`\n  \u003cdiv class=\"page active \"\u003e\n\n    \u003cdiv class=\"flex-row\"\u003e\n\n     \u003ca class=\"btn\" onclick=\"${() =\u003e {\n      $counter.value--;\n     }}\"\u003e\\u00AB\u003c/a\u003e\n\n     \u003cspan class=\"counter\"\u003e${$counter}\u003c/span\u003e\n\n     \u003ca class=\"btn\" onclick=\"${() =\u003e {\n      $counter.value++;\n     }}\"\u003e\\u00BB\u003c/a\u003e\n\n    \u003c/div\u003e\n\n  \u003c/div\u003e`;\n};\r\n```\n\n팁: HTM에서는 \u0026raquo;와 같은 HTML 엔티티를 사용할 수 없습니다. 왜냐하면 이들이 사용된 그대로 표시될 것이기 때문입니다. 해결책은 \\u0000 구문을 대신 사용하는 것입니다.\n\n그게 다 입니다.\n\n만약 풀 기능의 PWA를 만들기 위해 Manifest.json과 좋아하는 ServiceWorker 구현을 추가하고 싶다면 언제라도 추가해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 빌드 없는 접근 방식의 이점\n\n- 간편함: 웹팩, 롤업 또는 다른 빌드 구성을 유지할 필요가 없어 설정을 단순화하고 빌드 관련 문제의 가능성을 줄입니다.\n- 속도: 변경 사항이 즉시 브라우저 새로고침 후에 반영되어 개발 주기를 가속화합니다.\n- 코드에 집중: 개발자들은 특히 작은 프로젝트나 개발 초기 단계에서 도구보다 코딩에 더 집중할 수 있습니다.\n\n## 고려해야 할 단점\n\n- 확장성: 프로젝트가 커짐에 따라 빌드 시스템의 부재는 트리 쉐이킹, 최소화, 고급 번들링 전략과 같은 최적화 옵션을 제한할 수 있습니다.\n- 브라우저 호환성: 현대 브라우저 기능에 지나치게 의존할 경우 응용 프로그램이 이전 브라우저와 호환되는 것을 제한할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nPreact, HTM 및 Signals를 활용한 빌드 없는 JavaScript 애플리케이션은 현대적인 개발 관행과 간단함 사이에 뛰어난 균형을 제공합니다.\n\n특히 가벼운 애플리케이션이나 프로토 타입을 신속하게 작성하려는 개발자들에게 매력적입니다.\n\n모든 프로젝트에 적합하지는 않을 수 있지만, 특히 대규모 애플리케이션에는 해당하지 않을 수 있지만, 빠른 설정과 적은 종속성을 우선시하는 사람들에게 매력적인 옵션을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 나에 대해\n\n저는 오픈 소스 기술 분야에서 40년 이상의 경험을 가지고 있습니다. 개발자, 연설가 및 트레이너로 활동하고 있습니다. 제 LinkedIn 프로필이나 웹사이트 https://antoniogallo.it를 확인해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CreatingaBuildlessJavaScriptApplicationwithPreactHTMandSignal_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingaBuildlessJavaScriptApplicationwithPreactHTMandSignal_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 앱을 Vite로 만드는 방법","description":"","date":"2024-06-19 23:57","slug":"2024-06-19-HowToCreateaReactAppwithVite","content":"\n\n![이미지](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_0.png)\n\n이 튜토리얼은 처음으로 Vite를 사용하여 React 프로젝트를 만들고 싶어하는 분들을 위한 것입니다. React 프로젝트를 만드는 다양한 방법이 있지만, 이 튜토리얼에서는 Vite와 npm 패키지 매니저를 사용하여 React 프로젝트를 생성하는 방법을 안내하겠습니다. yarn과 같은 다른 패키지 매니저도 사용할 수 있습니다.\n\n# 준비 사항\n\n- Node 버전 ≥ 18\n- NPM 버전 8\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVite는 Node.js 버전 ≥ 18과 npm 버전 8을 필요로 합니다. 그러나 일부 템플릿은 작동하려면 더 높은 Node.js 버전이 필요합니다.\n\n# Vite 프로젝트 만들기\n\nVite를 사용하여 React 프로젝트를 만들려면 먼저 터미널을 사용하여 원하는 폴더로 이동해야 합니다.\n\n여기서 두 가지 다른 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 방법 1:\n\n다음 명령어를 실행해보세요\n\n```js\nnpm create vite@latest\n```\n\n![이미지](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 프로젝트 이름을 지정해주세요. 해당 이름은 프로젝트 폴더의 이름이 됩니다.\n\n![프로젝트 이미지](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_2.png)\n\n제 경우에는 프로젝트 이름이 my-app입니다.\n\n![프로젝트 이미지](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n키보드 화살표를 사용하여 React를 선택한 후 엔터키를 눌러주세요.\n\n![React image](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_4.png)\n\n타입스크립트 또는 자바스크립트 중 원하는 것을 선택해주세요. 저는 자바스크립트를 선택했습니다. 그리고 엔터키를 눌러주세요.\n\n![JavaScript image](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결되었습니다.\n\n## 접근법 2:\n\n또한, 한 번의 명령으로 Vite를 사용하여 React 프로젝트를 생성할 수 있습니다.\n\n```js\nnpm create vite@latest my-app -- --template react\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowToCreateaReactAppwithVite_6.png\" /\u003e\n\n완료되었습니다.\n\n## 의존성 설치 및 프로젝트 실행\n\n```js\ncd my-app\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 프로젝트 폴더로 이동하세요.\n\n```js\nnpm install\n```\n\n의존성을 설치하기 위해 실행하세요.\n\n```js\nnpm run dev\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 프로젝트를 시작해보세요.\n\n![이미지](/assets/img/2024-06-19-HowToCreateaReactAppwithVite_7.png)\n\n현재 저의 경우, 애플리케이션이 http://localhost:5173 에서 실행되고 있습니다. 다른 사람들이 이미 사용 중일 때에는 포트 번호가 다를 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 Vite를 사용하여 React 프로젝트를 만드는 방법을 보여드렸어요.\n공식 문서는 여기서 확인할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-HowToCreateaReactAppwithVite_0.png"},"coverImage":"/assets/img/2024-06-19-HowToCreateaReactAppwithVite_0.png","tag":["Tech"],"readingTime":2},{"title":"React 앱을 위한 GitLab과 Hostinger로 CICD 구현하기 단계별 안내","description":"","date":"2024-06-19 23:55","slug":"2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide","content":"\n\n\n![이미지](/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_0.png)\n\n이 가이드에서는 React 애플리케이션을 Hostinger에 배포하기 위한 파이프라인 설정 과정을 안내해 드릴 거에요. 목표는 GitLab 저장소로의 푸시가 웹사이트에 자동 업데이트를 유발하는 배포 프로세스를 자동화하는 것입니다. 이 튜토리얼에서는 GitLab의 강력한 CI/CD 기능을 활용하여 Hostinger에 React 애플리케이션을 배포하는 데 필요한 단계에 대해 자세히 살펴볼 거예요.\n\nGitlab CI/CD 파이프라인 설정하기\n\nCI/CD 파이프라인을 설정하려면 프로젝트의 루트 디렉토리에 .gitlab-ci.yml 파일을 생성해야 해요. 이 파일은 파이프라인의 단계와 작업을 정의할 거예요. 여기에 React 프로젝트에 대한 샘플 내용이 있어요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstages:\n  - build\n  - deploy\n\nbuild:\n  stage: build\n  image: node:latest\n  script:\n    - npm ci\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n\ndeploy:\n  stage: deploy\n  image: alpine:latest\n  before_script:\n    - apk update \u0026\u0026 apk add lftp\n  script:\n    - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_SERVER; mirror -Rev ./dist/ /your_hosting_directory --ignore-time --parallel=10; quit\"\n  only:\n    - main\n```\n\n이 파일에서 두 개의 스테이지인 build와 deploy를 정의했습니다. build 스테이지는 가장 최신의 Node.js 이미지를 사용하여 프로젝트 종속성을 설치하고 React 어플리케이션을 빌드합니다. 빌드된 파일은 dist/ 디렉터리 아래 artifacts로 저장됩니다.\n\ndeploy 스테이지는 가장 최신의 Alpine 이미지를 사용하고 lftp라는 명령 줄 FTP 클라이언트를 설치합니다. 그런 다음, lftp를 사용하여 $FTP_SERVER로 지정된 FTP 서버에 $FTP_USERNAME 및 $FTP_PASSWORD로 지정된 사용자 이름과 비밀번호로 연결합니다. 수정 시간을 무시하고 병렬로 최대 10개의 파일을 업로드하여 dist/ 디렉터리를 FTP 서버의 /your_hosting_directory 디렉터리로 미러링합니다. 이 스테이지는 main 브랜치에서만 실행됩니다.\n\n실제 FTP 자격 증명으로 $FTP_USERNAME, $FTP_PASSWORD 및 $FTP_SERVER를 교체해야 합니다. 이에 대해 확실하지 않다면 걱정하지 마세요. GitLab 프로젝트 설정에서 이러한 자격 증명을 비밀 변수로 설정하는 프로세스를 설명하는 단계에 따라 안내해 드릴 테니 걱정 마세요. 이 접근 방식을 통해 자격 증명이 안전하고 비밀 유지됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n호스팅에서 FTP 세부정보 가져오기\n\nHostinger 계정에 로그인합니다: 먼저 Hostinger 계정에 로그인하세요. 로그인 후에 Hostinger 제어판으로 이동하게 됩니다.\n\n호스팅 섹션으로 이동합니다: 제어판에서 \"호스팅\" 섹션으로 이동하세요. 여기서 모든 호스팅 목록을 볼 수 있습니다. 원하는 호스팅 옆의 \"대시보드\" 버튼을 클릭하여 FTP 세부정보를 가져오세요. 아래 스크린샷에서 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFTP 계정 섹션에 액세스하세요: 화면 왼쪽에 메뉴가 표시됩니다. \"파일\" 섹션 아래에 있는 \"FTP 계정\"을 클릭해보세요.\n\nFTP 세부정보를 가져오세요: FTP 계정 섹션에서 호스팅 계정과 관련된 FTP 계정 목록이 나열됩니다. 각 FTP 계정 옆에는 FTP 사용자 이름, FTP 서버, 그리고 숨겨진 비밀번호가 표시됩니다. FTP 비밀번호를 확인하려면 \"눈\" 아이콘을 클릭하세요.\n\n이 세부정보를 안전하게 보관하는 것을 기억하세요. 다음 섹션에서는 GitLab 프로젝트 설정에서 이러한 세부정보를 사용하여 비밀 변수를 설정하는 방법을 안내해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitLab에서 비밀 변수 설정하기\n\n- GitLab 프로젝트로 이동하기: GitLab 계정에 로그인하여 비밀 변수를 설정하려는 특정 프로젝트로 이동합니다.\n- 설정에 액세스하기: 프로젝트의 메인 페이지에서 왼쪽 메뉴에 있는 \"설정\" 옵션을 클릭합니다.\n- CI/CD 섹션으로 이동하기: 설정에서 \"CI / CD\" 섹션을 찾아 클릭합니다.\n- 변수 섹션 확장하기: CI / CD 섹션에서 \"변수\"라는 하위 섹션을 찾아 \"확장\" 버튼을 클릭합니다.\n- 새 변수 추가하기: \"변수 추가\" 버튼을 클릭합니다. 변수의 키와 값을 입력할 수 있는 필드가 표시됩니다.\n- FTP 상세 정보 입력하기: \"키\" 필드에 변수 이름(예: FTP_USERNAME)을 입력합니다. \"값\" 필드에 Hostinger에서 가져온 해당 값 입력합니다. 값이 안전하게 유지되도록 \"변수 가리기\" 옵션이 선택되어 있는지 확인합니다. FTP_PASSWORD 및 FTP_SERVER에 대해서도 이 과정을 반복합니다.\n- 변수 저장하기: 각 변수를 저장하려면 \"변수 추가\" 버튼을 클릭합니다. 모든 변수를 추가한 후 .gitlab-ci.yml 파일에서 사용할 수 있으며 안전하게 보호됩니다.\n\n![이미지](/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_3.png)\n\n이 변수들은 대소문자를 구분하며 .gitlab-ci.yml 파일에서 사용되는 변수와 정확히 일치해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 다 왔어요, 당신의 CI/CD 파이프라인이 준비되었습니다!\n\n이 튜토리얼에서는 React 애플리케이션을 위한 GitLab 및 Hostinger를 사용하여 CI/CD 파이프라인을 설정하는 과정을 안내했습니다. 우리는 빌드 및 배포 단계를 정의하는 .gitlab-ci.yml 파일을 만드는 방법, Hostinger에서 FTP 세부 정보를 가져오는 방법, 그리고 이러한 세부 정보를 GitLab의 시크릿 변수로 안전하게 설정하는 방법을 배웠습니다.\n\n이 설정을 통해 GitLab 저장소의 주 브랜치에 푸시할 때마다 자동 빌드 및 배포 프로세스가 트리거되어 Hostinger 사이트가 항상 최신 변경 사항과 함께 업데이트됨이 보장됩니다. 이렇게 하면 배포 프로세스를 자동화할 뿐만 아니라 수동 배포로 발생할 수 있는 오류 위험을 줄일 수도 있습니다.\n\n성공적인 CI/CD 파이프라인의 핵심은 정기적인 테스트와 모니터링입니다. 항상 GitLab에서 파이프라인 실행 로그를 확인하여 모든 것이 원활히 동작하는지 확인하세요. 즐거운 코딩하세요! 🙌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의견이나 질문이 있으시면 답글을 남겨주시거나 연락해주세요. 😊","ogImage":{"url":"/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-19-ImplementingCICDforReactAppswithGitLabandHostingerAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"렌더링 전략 모든 React 개발자가 알아야 할 것들","description":"","date":"2024-06-19 23:51","slug":"2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow","content":"\n\n\n![Image](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png)\n\n## 소개:\n\nReact는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.\n\n이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 렌더링 방법 이해하기\n\nReact의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png)\n\n렌더 단계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:\n\n- 가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.\n- 차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.\n- 작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.\n\n커밋 단계\n\n이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.\n- DOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.\n- 레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.\n\n커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.\n\n주요 개념:\n\n- Fiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.\n- 동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.\n\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png)\n\n주요 포인트:\n\n1. 동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.\n\n2. 향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. SEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.\n\n4. 초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.\n\n예시:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =\u003e {\n    fetch('https://api.example.com/data')\n      .then(response =\u003e response.json())\n      .then(data =\u003e setData(data));\n  }, []);\n\n  if (!data) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서:\n\n- useEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.\n- 상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.\n- 데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.\n\n장점:\n\n- 상호 작용 요소로 풍부한 사용자 경험.\n- 단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점:\n\n- 첫 페이지가 로딩하는 데 시간이 걸립니다.\n- 서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.\n\n## 서버 측 렌더링\n\n서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.\n\nKey Points:\n\n1. 향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.\n\n2. 초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Dynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.\n\n예시:\n\n```js\nconst express = require('express');\nconst fetch = require('node-fetch');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\n\nconst app = express();\n\napp.get('/', async (req, res) =\u003e {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const appString = ReactDOMServer.renderToString(\u003cHome data={data} /\u003e);\n\n  const html = `\n    \u003c!DOCTYPE html\u003e\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\"\u003e\n        \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u003ctitle\u003eServer-Side Rendering with Express\u003c/title\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e${appString}\u003c/div\u003e\n        \u003cscript\u003e\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        \u003c/script\u003e\n        \u003cscript src=\"/client.js\"\u003e\u003c/script\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.send(html);\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(`/`)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.\n- 데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(https://api.example.com/data)로 HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.\n- React 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.\n- HTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.\n- 클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.\n\n장점:\n\n- 사전 렌더링된 HTML로 SEO가 유리해집니다.\n- 더 빠른 로딩 속도.\n- 페이지가 항상 최신 상태를 유지합니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.\n- CSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.\n- 정적 렌더링보다 설정 및 유지 관리가 복잡합니다.\n\n## 스트리밍 렌더링\n\n스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 포인트:\n\n1. 느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.\n\n2. 점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.\n\n3. 첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst { Writable } = require('stream');\n\nconst app = express();\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\napp.get('/', async (req, res) =\u003e {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const htmlStart = `\n    \u003c!DOCTYPE html\u003e\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\"\u003e\n        \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u003ctitle\u003eStreaming Rendering\u003c/title\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e\n  `;\n\n  const htmlEnd = `\n        \u003c/div\u003e\n        \u003cscript\u003e\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        \u003c/script\u003e\n        \u003cscript src=\"/client.js\"\u003e\u003c/script\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.write(htmlStart);\n\n  const writable = new Writable({\n    write(chunk, encoding, callback) {\n      res.write(chunk, encoding, callback);\n    },\n    final(callback) {\n      res.write(htmlEnd);\n      res.end();\n      callback();\n    },\n  });\n\n  ReactDOMServer.pipeToNodeWritable(\u003cHome data={data} /\u003e, writable);\n});\n\napp.listen(3000, () =\u003e {\n  console.log('Server is running on http://localhost:3000');\n});\n```\n\n작동 방식:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.\n- 클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.\n\n장점:\n\n- 사용자가 페이지 일부와 상호 작용할 수 있습니다.\n- 핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.\n- 더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.\n- 페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.\n- 검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Implementation은 전통적 렌더링보다 복잡합니다.\n- 올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.\n- 모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.\n- 비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.\n- 제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.\n\n## 정적 사이트 생성\n\n정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.\n\n2. SEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.\n\n3. 보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Next.js를 사용한 SSG의 예시입니다.\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n}\n\nexport default Home;\n```\n\n이 예제에서는:\n\n• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.\n\n- HTML은 빌드 시 생성되어 정적 파일로 제공됩니다.\n\n장점:\n\n- 정적 파일의 빠른 로드 시간.\n- 사전 렌더링된 HTML로 SEO 향상.\n- 더 빠른 서버와 안전한 데이터.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단점:**\n\n- 내용 변경에 대한 유연성이 부족합니다.\n- 우선 구축해야 합니다.\n- 대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n## 증분 정적 재생\n\n증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 점:\n\n1. 요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.\n\n2. 향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.\n\n3. 유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n다음은 ISR을 보여주는 Next.js 사용 예시입니다:\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n    revalidate: 10, // 최대 10초마다 페이지를 다시 생성합니다.\n  };\n}\n\nexport default Home;\n```\n\n이 예시에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- getStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.\n- revalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.\n- 생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.\n\n장점:\n\n- 빠르고 유연합니다.\n- HTML로 인한 SEO 향상.\n- 빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정적 사이트 생성보다 설정하는 것이 더 복잡합니다.\n- 최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.\n\n## 재수전\n\nReact에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.\n\n주요 요점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.\n\n2. 클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.\n\n예시:\n\n다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 측\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst fs = require('fs');\nconst path = require('path');\n\nconst App = require('./App').default;\n\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, 'build')));\n\napp.get('*', (req, res) =\u003e {\n  const appString = ReactDOMServer.renderToString(\u003cApp /\u003e);\n\n  const indexFile = path.resolve(__dirname, 'build', 'index.html');\n  fs.readFile(indexFile, 'utf8', (err, data) =\u003e {\n    if (err) {\n      console.error('에러 발생:', err);\n      return res.status(500).send('앗!');\n    }\n\n    return res.send(\n      data.replace('\u003cdiv id=\"root\"\u003e\u003c/div\u003e', `\u003cdiv id=\"root\"\u003e${appString}\u003c/div\u003e`)\n    );\n  });\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.hydrate(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작동 방식:\n\n1. 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n\n2. 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.\n\n장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.\n- 미리 렌더링된 콘텐츠로 개선된 SEO.\n- 클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.\n\n단점:\n\n- JavaScript가 로드될 때까지 상호작용이 지연될 수 있음.\n- 서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.\n\n## 부분 유기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png)\n\n주요 포인트:\n\n- 선택적 상호 작용: 페이지의 일부만로드됩니다.\n- 더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.\n- 점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nif (rootElement.hasChildNodes()) {\n  ReactDOM.hydrate(\u003cApp /\u003e, rootElement);\n} else {\n  ReactDOM.render(\u003cApp /\u003e, rootElement);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Components (App.js와 InteractiveComponent.js)\n\n```js\n// src/App.js\nimport React from 'react';\nimport InteractiveComponent from './InteractiveComponent';\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e정적 콘텐츠\u003c/h1\u003e\n      \u003cInteractiveComponent /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/InteractiveComponent.js\nimport React, { useState } from 'react';\n\nfunction InteractiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e클릭하세요\u003c/button\u003e\n      \u003cp\u003e{count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default InteractiveComponent;\n```\n\n작동 방식:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n- 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.\n\n장점:\n- 더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.\n- 페이지의 필요한 부분만 적용.\n- 사용자들은 더 많은 인터랙션을 즐깁니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전체 페이지 하이드레이션보다 더 복잡합니다.\n- 주의 깊게 관리해야 합니다.\n\n## 점진적 하이드레이션\n\n점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.\n- 우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.\n- 성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.\n\n예시:\n\nReact 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nfunction hydrateComponent(selector, Component) {\n  const element = document.querySelector(selector);\n  if (element \u0026\u0026 element.hasChildNodes()) {\n    ReactDOM.hydrate(\u003cComponent /\u003e, element);\n  } else if (element) {\n    ReactDOM.render(\u003cComponent /\u003e, element);\n  }\n}\n\nhydrateComponent('#root', App);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/App.js\nimport React, { useEffect } from 'react';\n\nfunction App() {\n  useEffect(() =\u003e {\n    const observer = new IntersectionObserver((entries) =\u003e {\n      entries.forEach((entry) =\u003e {\n        if (entry.isIntersecting) {\n          import('./ProgressiveComponent').then(({ default: Component }) =\u003e {\n            hydrateComponent('#progressive', Component);\n          });\n          observer.disconnect();\n        }\n      });\n    });\n\n    observer.observe(document.querySelector('#progressive'));\n\n    return () =\u003e observer.disconnect();\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eStatic Content\u003c/h1\u003e\n      \u003cdiv id=\"progressive\"\u003eLoading...\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/ProgressiveComponent.js\nimport React, { useState } from 'react';\n\nfunction ProgressiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eClick me\u003c/button\u003e\n      \u003cp\u003e{count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ProgressiveComponent;\n```\n\n동작 방식:\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.\n- 클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.\n- 점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.\n- 사용자들이 더 나은 경험을 할 수 있습니다.\n- Javascript 파일이 줄어 듭니다.\n\n단점:\n\n- 전체 페이지 가득 채우기보다 복잡합니다.\n- 문제를 피하기 위해 신중하게 관리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 동적 렌더링\n\n동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.\n\n![랜더링 전략](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png)\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.\n\n2. SEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.\n\n3. 사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:\n\n```js\nconst express = require('express');\nconst puppeteer = require('puppeteer');\n\nconst app = express();\n\napp.get('*', async (req, res) =\u003e {\n  const userAgent = req.headers['user-agent'];\n  \n  if (/Googlebot|Bingbot|Baiduspider|YandexBot/i.test(userAgent)) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(`http://localhost:3000${req.originalUrl}`, {\n      waitUntil: 'networkidle2'\n    });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } else {\n    res.sendFile(__dirname + '/index.html');\n  }\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =\u003e {\n    fetch('/api/data')\n      .then(response =\u003e response.json())\n      .then(data =\u003e setData(data));\n  }, []);\n\n  if (!data) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 엔드포인트 (Node.js + Express)\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/api/data', (req, res) =\u003e {\n  res.json({\n    title: 'Dynamic Rendering Example',\n    content: 'This content is fetched from the server.'\n  });\n});\n\napp.listen(3001, () =\u003e {\n  console.log('API 서버가 http://localhost:3001에서 실행 중입니다.');\n});\n```\n\n이 예제에서:\n\n- 서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.\n- 요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.\n- 요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 서버 측 및 클라이언트 측 렌더링을 결합합니다.\n- 검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.\n- 사용자가 상호 작용할 수 있습니다.\n\n단점:\n\n- 서버 설치 및 유지 관리가 더 복잡합니다.\n- 프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.\n- 사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.\n\n중요 사항:\n\n1. 클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.\n\n3. 스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.\n\n4. 정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.\n\n5. 점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. 리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.\n\n7. 부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.\n\n9. 동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.\n\n적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWeb 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.","ogImage":{"url":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":20},{"title":"필수 준비물","description":"","date":"2024-06-19 23:49","slug":"2024-06-19-Prerequisites","content":"\n\n## Next.js 어플리케이션에서 Keycloak 인증 구현하기\n\n![Prerequisites](/assets/img/2024-06-19-Prerequisites_0.png)\n\n이 튜토리얼에서는 오픈 소스 신원 및 접근 관리 솔루션인 Keycloak을 Next.js 어플리케이션에 통합하는 방법을 탐색할 것입니다. 이 가이드를 마치면 Keycloak을 사용한 완전히 기능적인 인증 시스템을 갖게 될 것입니다.\n\n# Prerequisites\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계로 넘어가기 전에 다음 사전 요구 사항이 있는지 확인해 주세요:\n\n- Next.js의 기본적인 이해: Next.js의 기초 사항 및 페이지 및 컴포넌트를 생성하는 방법에 익숙해야 합니다.\n- Node.js 설치: 컴퓨터에 Node.js가 설치되어 있는지 확인해 주세요. nodejs.org에서 다운로드할 수 있습니다.\n- Keycloak 인스턴스: Keycloak 인스턴스를 설정해야 합니다. 아직 수행하지 않은 경우 Keycloak 시작 안내서를 따르세요.\n\n# 프로젝트 구조\n\n시작하기 전에, 프로젝트의 폴더 구조를 개요로 살펴봅시다. 각 파일이 어디에 속하는지 이해하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nnextjs-app\n├── auth\n│   ├── config\n│   │   └── keycloak.js\n│   ├── provider\n│   │   └── KeycloakProvider.js\n│   ├── middleware\n│   │   └── withAuth.js\n│   └── components\n│       └── LogoutButton.js\n├── pages\n│   ├── _app.js\n│   └── index.js\n└── public\n└── styles\n    └── globals.css\n\n# 단계 1: Keycloak 설정하기\n\n먼저, Next.js 프로젝트에서 Keycloak을 구성해야 합니다. Keycloak은 애플리케이션과 연결하기 위해 초기 구성이 필요합니다. 설정 파일을 만들어 시작하겠습니다.\n\nKeycloak 설정 파일 만들기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconfig 디렉토리에 keycloak.js라는 새 파일을 만들어주세요. 이 파일은 Keycloak 설정과 초기화 로직을 담을 것입니다.\n\nauth/config/keycloak.js\n\n```js\nimport Keycloak from 'keycloak-js';\n\nconst keycloakConfig = {\n  url: 'http://localhost:8080/auth', // 여러분의 Keycloak URL로 교체해주세요\n  realm: 'your-realm', // 여러분의 Keycloak realm으로 교체해주세요\n  clientId: 'your-client-id', // 여러분의 Keycloak client ID로 교체해주세요\n};\n\nlet keycloak;\n\nif (typeof window !== 'undefined') {\n  keycloak = new Keycloak(keycloakConfig);\n}\n\nlet isInitialized = false;\n\nexport const initKeycloak = () =\u003e {\n  if (!isInitialized \u0026\u0026 keycloak) {\n    isInitialized = true;\n    return keycloak\n      .init({ onLoad: 'login-required', checkLoginIframe: false })\n      .then(authenticated =\u003e authenticated)\n      .catch(err =\u003e {\n        isInitialized = false;\n        console.error('Failed to initialize Keycloak', err);\n        throw err;\n      });\n  }\n  return Promise.resolve(keycloak?.authenticated ?? false);\n};\n\nexport const logout = () =\u003e {\n  if (keycloak) {\n    keycloak.logout();\n  }\n};\n\nexport const getToken = async () =\u003e {\n  if (keycloak) {\n    if (keycloak.isTokenExpired()) {\n      try {\n        await keycloak.updateToken(30);\n      } catch (error) {\n        console.error('Failed to refresh the token', error);\n        keycloak.logout();\n        return null;\n      }\n    }\n    return keycloak.token ?? null;\n  }\n  return null;\n};\n\nexport { keycloak };\n```\n\n해설\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Keycloak 구성: 우리는 Keycloak 구성 객체를 정의하여 Keycloak 서버의 URL, realm 및 클라이언트 ID를 지정합니다.\n- Keycloak 초기화: Keycloak를 초기화하기 위해 initKeycloak 함수를 생성합니다. 이 함수를 통해 Keycloak가 한 번만 초기화되도록 합니다.\n- 토큰 관리: getToken 함수는 토큰이 만료되었는지 확인하고 필요한 경우 새로 고침을 시도합니다.\n- 로그아웃 함수: logout 함수는 로그아웃 프로세스를 트리거합니다.\n\n# 단계 2: Keycloak 프로바이더 생성\n\nKeycloak의 상태를 관리하고 애플리케이션 전체에서 제공하기 위해 컨텍스트 프로바이더를 생성할 것입니다. 이를 통해 애플리케이션의 모든 구성 요소가 인증 상태와 사용자 정보에 액세스할 수 있게 됩니다.\n\nKeycloak 프로바이더 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nauth/provider 디렉토리에 KeycloakProvider.js라는 새 파일을 만들어주세요.\n\nauth/provider/KeycloakProvider.js\n\n```js\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { initKeycloak, keycloak, logout } from '../config/keycloak';\n\nconst KeycloakContext = createContext({\n  initialized: false,\n  authenticated: false,\n  user: null,\n  logout: () =\u003e {},\n});\n\nexport const KeycloakProvider = ({ children }) =\u003e {\n  const [initialized, setInitialized] = useState(false);\n  const [authenticated, setAuthenticated] = useState(false);\n  const [user, setUser] = useState(null);\n\n  useEffect(() =\u003e {\n    if (typeof window !== 'undefined') {\n      initKeycloak()\n        .then(auth =\u003e {\n          setAuthenticated(auth);\n          if (keycloak \u0026\u0026 auth) {\n            setUser({\n              name: keycloak.tokenParsed?.preferred_username,\n              email: keycloak.tokenParsed?.email,\n            });\n          }\n          setInitialized(true);\n        })\n        .catch(err =\u003e console.error('Failed to initialize Keycloak', err));\n    }\n  }, []);\n\n  return (\n    \u003cKeycloakContext.Provider value={{ initialized, authenticated, user, logout }}\u003e\n      {children}\n    \u003c/KeycloakContext.Provider\u003e\n  );\n};\n\nexport const useKeycloak = () =\u003e useContext(KeycloakContext);\r\n```\n\n해당 내용입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컨텍스트 생성: 우리는 인증 상태를 유지하기 위해 KeycloakContext를 생성하고 애플리케이션에 제공합니다.\n- 제공자 컴포넌트: KeycloakProvider 컴포넌트는 Keycloak을 초기화하고 인증 상태를 관리합니다. 또한 로그아웃 기능과 사용자 정보를 제공합니다.\n- 사용자 지정 후크: useKeycloak 후크를 사용하여 어떤 컴포넌트에서든 Keycloak 컨텍스트에 쉽게 액세스할 수 있습니다.\n\n# 단계 3: 인증 미들웨어 생성\n\n우리의 경로를 보호하고 인증된 사용자만 액세스할 수 있도록 하기 위해 Higher-Order Component (HOC)를 생성할 것입니다.\n\n인증 미들웨어 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nauth/middleware/withAuth.js 파일을 새로 만들어주세요.\n\nauth/middleware/withAuth.js\n\n```js\nimport React from 'react';\nimport { useKeycloak } from '../provider/KeycloakProvider';\n\nconst withAuth = WrappedComponent =\u003e {\n  return props =\u003e {\n    const { initialized, authenticated } = useKeycloak();\n\n    if (!initialized) {\n      return \u003cdiv\u003eLoading...\u003c/div\u003e;\n    }\n\n    if (!authenticated) {\n      return \u003cdiv\u003eNot authenticated\u003c/div\u003e;\n    }\n\n    return \u003cWrappedComponent {...props} /\u003e;\n  };\n};\n\nexport default withAuth;\n```\n\n설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Higher-Order Component: withAuth HOC은 컴포넌트를 감싸고 사용자가 인증되었는지 확인합니다. 사용자가 인증되지 않은 경우 메시지를 표시하고, 그렇지 않은 경우 감싼 컴포넌트를 렌더링합니다.\n\n# 단계 4: 로그아웃 버튼 생성\n\n사용자가 세션에서 로그아웃할 수 있는 버튼 컴포넌트를 생성할 것입니다.\n\n로그아웃 버튼 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nauth/components/LogoutButton.js 파일을 auth/components 디렉토리에 만들어주세요.\n\n```js\nimport React, { useState, useRef, useEffect } from 'react';\nimport { useKeycloak } from '../provider/KeycloakProvider';\n\nconst LogoutButton = () =\u003e {\n  const { logout, user } = useKeycloak();\n  const [showDropdown, setShowDropdown] = useState(false);\n  const dropdownRef = useRef(null);\n\n  const toggleDropdown = () =\u003e {\n    setShowDropdown(!showDropdown);\n  };\n\n  useEffect(() =\u003e {\n    const handleClickOutside = event =\u003e {\n      if (dropdownRef.current \u0026\u0026 !dropdownRef.current.contains(event.target)) {\n        setShowDropdown(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () =\u003e {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, []);\n\n  return (\n    \u003cdiv className=\"relative inline-block text-left\"\u003e\n      \u003cbutton onClick={toggleDropdown} className=\"button\"\u003e\n        {user?.name.charAt(0).toUpperCase() || 'U'}\n      \u003c/button\u003e\n      {showDropdown \u0026\u0026 (\n        \u003cdiv ref={dropdownRef} className=\"dropdown\"\u003e\n          \u003cdiv className=\"dropdown-content\"\u003e\n            \u003cp\u003e{user?.name || 'Unknown User'}\u003c/p\u003e\n            \u003cp\u003e{user?.email || 'Unknown User'}\u003c/p\u003e\n            \u003cbutton onClick={logout}\u003eLogout\u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\n\nexport default LogoutButton;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태 관리: 우리는 dropdown 메뉴의 가시성을 관리하기 위해 useState를 사용합니다.\n- 드롭다운 토글: toggleDropdown 함수는 dropdown 메뉴의 가시성을 전환합니다.\n- 외부 클릭 핸들러: 우리는 useEffect를 사용하여 클릭 영역 밖을 클릭하면 dropdown 메뉴를 닫는 이벤트 리스너를 추가합니다.\n\n# 단계 5: 루트 레이아웃에서 Keycloak 제공자 사용하기\n\n마지막으로, 인증 상태를 응용 프로그램 전반에 걸쳐 제공하기 위해 Keycloak 제공자를 루트 레이아웃 파일에 통합해야 합니다.\n\n루트 레이아웃에서 Keycloak 통합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npages/_app.js\n\n```js\nimport React from 'react';\nimport { KeycloakProvider } from '../auth/provider/KeycloakProvider';\nimport '../styles/globals.css';\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    \u003cKeycloakProvider\u003e\n      \u003cComponent {...pageProps} /\u003e\n    \u003c/KeycloakProvider\u003e\n  );\n}\n\nexport default MyApp;\n```\n\n설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Keycloak Provider: KeycloakProvider으로 컴포넌트를 감싸면 전체 애플리케이션이 인증 상태에 액세스할 수 있도록 보장합니다.\n\n# 인증이 포함된 예제 페이지\n\n다음은 withAuth HOC를 사용하여 보호된 페이지를 만들고 LogoutButton을 표시하는 예시입니다.\n\npages/index.js\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React from 'react';\nimport withAuth from '../auth/middleware/withAuth';\nimport LogoutButton from '../auth/components/LogoutButton';\n\nconst HomePage = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome to the Home Page\u003c/h1\u003e\n      \u003cLogoutButton /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default withAuth(HomePage);\r\n```\n\n설명\n\n- 보호된 라우트: 홈 페이지는 withAuth HOC로 감싸져 있어 인증된 사용자만 접근할 수 있습니다.\n- 로그아웃 버튼: 홈 페이지는 LogoutButton 컴포넌트를 포함하고 있어 사용자들이 로그아웃할 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 포괄적인 튜토리얼에서는 Next.js 애플리케이션에서 Keycloak 인증을 설정하는 과정을 안내했습니다. 다음 사항을 다루었습니다:\n\n- Keycloak 설정: Keycloak 구성 및 초기화 로직 생성.\n- Keycloak 제공자 생성: Keycloak 상태를 관리하고 애플리케이션 전반에 제공하는 방법.\n- 인증 미들웨어 생성: 고차 컴포넌트를 사용하여 경로를 보호하는 방법.\n- 로그아웃 버튼 생성: 사용자가 세션에서 로그아웃할 수 있는 기능.\n- 루트 레이아웃에 Keycloak 통합: 인증 상태를 전체 애플리케이션에 제공하고 경로를 보호하는 방법.\n\n이러한 단계를 통해 Keycloak을 사용하여 Next.js 애플리케이션을 안전하게 보호하고 강력한 인증 및 액세스 관리 기능을 제공할 수 있습니다. 이 설정을 원하는 대로 사용자 정의하고 확장하여 특정 요구 사항에 맞게 조정하세요. 즐거운 코딩하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계를 따라하면 Keycloak을 사용하여 Next.js 애플리케이션을 안전하게 보호할 수 있습니다. 견고한 인증 및 액세스 관리를 제공합니다. 이 설정을 사용자의 요구 사항에 맞게 사용자 정의하고 확장해도 됩니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-19-Prerequisites_0.png"},"coverImage":"/assets/img/2024-06-19-Prerequisites_0.png","tag":["Tech"],"readingTime":9},{"title":"React의 Fiber 조정기는 어떻게 동작하나요","description":"","date":"2024-06-19 23:48","slug":"2024-06-19-HowdoestheReactfiberreconcilerwork","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_0.png\" /\u003e\n\n이 글에서는 React 세상에 대해 심층 탐구하고 React의 핵심 가치 제안, React 조정자가 무엇이고 버전 16 이전에 어떻게 작동했는지, 오늘은 어떻게 작동하는지 살펴볼 것입니다!\n\n1- 조정이 도대체 무엇입니까?\n\n우선, 조정이란 무엇인지 보겠습니다. 번역에 따르면 이를 의미합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**\"다른 뷰나 믿음을 함께 어우러지게 만드는 행위\"\n\n이것은 싱글 페이지 애플리케이션에서 React의 주요 목적을 나타냅니다. 이전에는 SPA 이전에 브라우저가 페이지 전환이 처리되는 속도가 느렸고 이를 개선하기 위해 React가 가상 DOM이라는 새로운 방식으로 웹 애플리케이션의 라우팅을 처리하도록 도입했습니다.\n\n기존의 브라우저 라우팅 및 네비게이션 대신, 우리는 그 모든 것을 자바스크립트 메모리에 유지하고 페이지 및 라우팅을 처리하기 위해 자바스크립트를 사용하며 그 결과로 페이지 전환은 훨씬 빨라집니다.\n\n이 목표를 달성하기 위해 React 팀은 가상 DOM과 스택 조정기를 도입하여 메모리에 있는 가상 DOM 트리를 처리하고 변경 사항을 실제 DOM에 선언적으로 적용하는 방법을 소개했습니다.\"**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2- 스택 조정기와 역사 수업!\n\n자, 리액트 훅을 도입하기 전 몇 년 전으로 돌아가서 리액트가 DOM 트리를 어떻게 구축했는지 살펴봅시다.\n아래는 리액트 15 버전 및 이전 버전에서 스택 조정기라고 불리는 조정기가 있었는데, 이것은 LIFO 데이터 구조로 작업을 선택하고 결과를 반환하는 역할을 했으며 마치 JavaScript 호출 스택이 작동하는 방식과 유사합니다.\n\n![이미지](/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_1.png)\n\n이 방식은 이미 혁신적인 접근이었지만 여러 문제점이 있었습니다. 주요 문제는 스택 조정기가 동기적이고 순차적이었기 때문에 병렬 또는 동시에 여러 단위의 작업을 처리할 기회가 전혀 없었다는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 사용자가 UI와의 아래 상호 작용을 가정해 봅니다:\n\n\n![React Fiber Reconciler](/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_2.png)\n\n\n스택 조정기에서 비응답 UI의 문제\n\n아래와 같이 스택 조정기의 동기 및 순차적인 순서로, 사용자가 텍스트 입력란에 무언가를 입력하려고 하면, 사용자에 대한 응답이 지연되고 반응이 없을 수 있습니다. 이것은 렌더링 순서에서 고우선순위이지만 스택에게 이를 더 높은 우선순위로 처리하라고 요청할 방법이 없기 때문입니다. 또 다른 문제는 이 과정 중에 오류가 발생하면 어디서 발생했는지, 어떤 스택 트레이스인지 찾을 방법이 없어서 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크고 복잡한 어플리케이션은 너무 많은 상태와 작업을 다루기 때문에 혼돈스러워질 수 있고 사용자 경험이 파괴될 수 있습니다.\n\n3- Fiber Reconciler, 그것이 우리가 찾던 것이었습니다!\n\nReact 버전 16 이상에서 React 팀은 새로운 방식인 Fiber Reconciler라는 새 메타를 사용하여 작업 단위와 가상 DOM 트리를 처리하는 새로운 방법을 소개했습니다. 이로써 두 가지 주요 도전 과제인 다음을 해결할 수 있습니다:\n\n1- 작업 단위를 동기적으로 처리하는 방식\n2- 작업 단위의 우선순위와 동시성 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재의 React Fiber Reconciler는 많은 Fiber 노드로 구성되어 있으며, 이러한 노드들은 작업을 처리하기 위한 많은 속성을 갖춘 일반적인 JavaScript 객체들입니다.\n\nFiber = ' 많은 속성 또는 작업 단위를 갖춘 JavaScript 객체 '.\n\nFiber Reconciler = Fiber 객체 또는 작업 단위를 기반으로 하는 현재의 React 조정자입니다.\n\n작업 단위란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트에서의 작업 단위는 props나 state의 변경, 또는 DOM 업데이트와 같이 화면 출력을 변경할 수 있는 모든 것입니다.\n\n파이버는 컴포넌트 인스턴스, DOM 노드 등과 1 대 1 관계를 가지고 있습니다. 파이버 객체의 타입은 태그에 저장되어 있습니다. 타입의 가능성은 다음과 같습니다:\n\n![Fiber 타입](/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_3.png)\n\n리액트-DOM 라이브러리의 소스 코드에서는 다음과 같이 명명된 함수들을 찾을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\ncreateFiberFromtText();\ncreateFiberFromElement();\ncreateFiberFromPortal();\n\nFibers는 DOM과 React 생태계에서 거의 모든 옵션에서 만들 수 있음을 보여줍니다. 이제 새로운 React Fiber Reconciler가 어떻게 작동하는지 알아봅시다!\n\nReact는 DOM 조작을 처리하는 선언적인 방법으로, 화면에 표시하길 원하는 내용을 알려주면 React가 하부에서 역할을 수행하여 비즈니스 로직 및 비즈니스에 필요한 중요한 부분에 집중할 수 있습니다.\n\n아래에는 페이지의 간단한 예시가 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_4.png)\n\n이제 React 피버 reconciler에서 어떻게 처리되는지 살펴보겠습니다:\n\n위 그림에서 보시는 대로, React Fiber Reconciler는 메모리 내에서 DOM 요소 트리(Virtual DOM)를 구성하고 실제 DOM의 청사진도 유지하여 실제 DOM에서 작업하고 Virtual DOM에 대한 업데이트를 렌더링한 다음 해당 변경 사항을 실제 DOM에 적용합니다.\n\n이 프로세스에는 두 단계가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1- 렌더 단계 (비동기)\n2- 커밋 단계 (동기)\n\n당신의 애플리케이션에서 업데이트가 발생할 때, Fiber 조정자는 실제 DOM에 있는 현재 트리, 진행 중인 작업 트리, 및 렌더링 레인을 매개변수로 사용하는 beginWork 함수를 호출하여 작업을 시작합니다.\n\n이 프로세스는 훨씬 더 복잡하지만 React 조정자 내부에서 무슨 일이 일어나는지에 대한 개요는 아래와 같습니다. 단순한 버튼 클릭 및 상태 변경 예시에서 어떻게 진행되는지 확인해보세요:\n\n1- 사용자가 버튼을 클릭하면 beginWork(currentTree, workInProgressTree, lanes)를 호출하여 트리를 위에서 아래로 재귀적으로 확인하며 형제 및 자식 노드까지 내려가는 과정이 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2- 작업이 필요한 동안에는 프롭스나 상태에 변경 사항이 발생하는지를 확인하여 노드를 업데이트해야 한다는 업데이트 플래그를 사용하여 노드를 표시합니다.\n\n3- Fiber 유닛 작업이 완료되면 업데이트를 표시하고 완료 가능한 작업을 completeWork(currentTree, workInProgressTree, lanes) 함수를 호출하여 작업 트리를 올라가는 역할을 수행합니다.\n\n4- 작업 완료는 또한 메모리에서 화면 밖에서 업데이트를 기반으로한 실제 DOM에 표시될 HTML 요소 트리를 작성합니다.\n\n5- 모든 작업이 완료되면 fiber가 작업을 마치고 더 이상 할 일이 없다면, 새롭게 구성된 DOM 트리를 실제 DOM에 반영하여 화면에 표시되는 변경 사항을 반영합니다.\n\n렌더링 단계와 메모리에서 DOM 트리에서 작업하는 것은 완전히 화면 밖 및 비동기적이므로 프로세스 중간에 업데이트나 중단이 발생하더라도 프로세스가 대기할 수 있거나 중단하여 다른 프로세스로 전환하여 다시 작업을 시작할 수 있습니다. 우선 순위를 매기거나 지연시킬 수 있으며 취소할 수도 있으며 동시에 여러 작업을 동시에 병렬로 수행할 수 있습니다. 이것은 이전에 스택 조정자의 문제를 해결하기 위해 찾던 해결책입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이버 조정기를 사용하여 이제 우리는 동시 렌더링, 중단 기능 및 렌더링 단계 오류를 잡아 사용자에게 폴백을 표시하고 전체 앱이 한꺼번에 크래시되지 않게 할 수 있습니다!\n\n이 프로세스에서 효과는 어떻게 작용하며 적용되나요?\n\n매우 좋은 질문입니다. 파이버 트리의 결과는 자체에만 의존하지 않습니다. 실제 DOM에서의 네트워크 요청, 돌연변이, 라이프사이클 메서드 호출 또는 React 생태계 외부에서 발생하는 모든 것과 같이 React 상태와 동기화해야 하는 효과 목록도 있습니다.\n\n커밋 단계에서 React는 모든 효과를 모든 컴포넌트 인스턴스에 적용하고 결과를 사용자에게 표시합니다. React는 이 모든 작업을 단일 패스로 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 우리는 모든 것을 다루고 있어요! 멋지지 않았나요? React를 사용할 때 내부에서 무슨 일이 일어나는지 알면 React 생태계를 이해하고 프로세스와 DOM을 어떻게 처리하는지 알 수 있어요.\n\n즐겁게 즐겼으면 좋겠어요. 미래에 더 많은 기사를 보고 싶다면 저를 팔로우해주세요. 안녕히 가세요! 즐거운 코딩하세요.\n\n자료:\n\n[유튜브 링크](https://www.youtube.com/watch?v=0ympFIwQFJw)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://www.youtube.com/watch?v=rKk4XJYzSQA\u0026t=9s\n\nhttps://www.youtube.com/watch?v=Zan16X8VvGM","ogImage":{"url":"/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_0.png"},"coverImage":"/assets/img/2024-06-19-HowdoestheReactfiberreconcilerwork_0.png","tag":["Tech"],"readingTime":5},{"title":"React Fiber에 대한 설명 더 부드러운 UI를 위한 점진적 렌더링","description":"","date":"2024-06-19 23:46","slug":"2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_0.png\" /\u003e\n\n# React Fiber이 무엇인가요?\n\nReact Fiber는 React 라이브러리의 완전히 새로운 핵심 조정 알고리즘입니다. 조정은 React가 UI를 응용 프로그램 데이터 상태에 맞게 최신 상태로 가져오는 방법입니다. 이는 렌더링 작업을 \"파이버(fibres)\"라고 불리는 작은 부분으로 분할합니다. 이렇게 하면 React가 이러한 부분들을 조각조각 처리하고 필요할 때 작업을 프레임 간에 분배할 수 있습니다. 이 방식은 렌더링 프로세스에서 더 많은 유연성을 제공하며 업데이트를 우선 순위 지정하고 스케줄링할 수 있는 기능을 제공합니다.\n\n## 이게 왜 중요한가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n산업에서 많은 개발자들이 React Fiber 아키텍처에 대해 완전히 알지 못하는 경우가 많습니다. React Fiber는 렌더링 프로세스를 작은 단위로 나눔으로써 훨씬 효율적인 애플리케이션을 만들 수 있는 기회를 제공하며, 웹 개발 분야에서 엄청난 발전을 이뤘습니다.\n\n## 이전 알고리즘 (스택 조정자)\n\n이전 조정 알고리즘인 스택 조정자는 React가 업데이트를 동기적으로 한 번 적용했습니다. 이는 컴포넌트의 상태가 변경될 때 React가 전체 컴포넌트 트리를 탐색하고 이전 트리와 비교한 다음 필요한 업데이트를 한 번에 DOM에 적용한 것을 의미합니다. 이 방법은 간단한 애플리케이션에는 좋았지만, 복잡한 애플리케이션에서는 브라우저를 렌더링하는 동안 브라우저를 잠그는 등의 문제가 발생할 수 있어서 쟁점이 되었습니다.\n\n## Fiber 조정자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Fiber는 렌더링 작업을 \"파이버(fibers)\"로 분할하여 점진적으로 처리할 수 있게 함으로써 우리가 논의하는 조정 유형에 새로운 시각을 제공합니다. 이를 통해 React는 렌더링 작업이 서로 다른 프레임에 고르게 분배되어 일시적으로 작동을 중지하고 나중에 다시 작동할 수 있게 됩니다. 이 접근 방식의 주요 이점은 전반적인 성능과 반응 속도 향상입니다.\n\n# React-Fiber 뒤에 숨겨진 주요 개념\n\n## 1. 점진적 렌더링\n\n우선순위 기반 업데이트: React Fiber는 모든 업데이트를 서로 다른 우선순위로 나눕니다. 사용자 상호작용과 같은 중요한 주의를 필요로 하는 업데이트는 즉시 처리되고, 데이터 가져오기와 같은 비교적 중요하지 않은 업데이트는 백그라운드에서 처리되어 시스템 반응성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 동시성\n\nReact Fiber은 멀티스레드이며 병렬 처리 또는 동시성을 지원합니다. 이는 응용 프로그램에서 상호 작용을 도입하는 다양한 하위 인터페이스가 있을 때 특히 유용합니다. 항상 순조로운 상호 작용 UI를 유지하기 위해 큐의 맨 위에 중요하게 처리해야 할 업데이트를 유지하면서 비교적 중요도가 낮은 작업에 대해 일정량의 진전을 보입니다.\n\n## 3. 트리 구조\n\nReact Fiber는 각 항목이 상태, 데이터 및 계층 위치와 함께 UI의 일부인 Fiber 트리를 사용합니다. 이 구조를 통해 React는 DOM의 부분을 업데이트하려는 필요한 변경 사항을 더 잘 이해하고 추적하여 전체 성능 및 렌더링 속도를 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 화해 과정\n\n![화해과정](/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_1.png)\n\n우리가 상태를 변경할 때, React는 메인 스레드가 비어있을 때까지 기다렸다가 작업 중인 트리(Work In Progress, WIP)를 구축하기 시작합니다. 이 WIP 트리는 fiber를 사용하여 구축되며, 그 구조는 코드 내의 컴포넌트를 반영합니다. 렌더링 또는 화해 단계에서는 WIP 트리를 구성하고 변경 사항을 식별하는 비동기 작업이 진행됩니다. 이 단계는 메인 스레드가 다른 작업을 처리해야 할 경우 중지될 수 있으며, 작업의 중요도에 따라 우선순위가 부여됩니다. 메인 스레드가 다시 비어있게 되면, 중단된 지점부터 WIP 트리를 계속 구축합니다.\n\n![화해과정](/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 단계인 커밋 단계는 전체 WIP 트리가 완료된 후 시작됩니다. 이 단계는 동기적으로 진행되며 중단될 수 없습니다. React는 이 단계에서 현재 트리와 진행 중인 작업 트리의 포인터를 교환하여 DOM에 변경 사항을 적용한 다음, 이러한 파이버를 DOM에 렌더링합니다. 교환 후, 새로운 진행 중인 작업 트리는 향후 상태 변경에 준비가 된 상태입니다.\n\n# 실제 세계 응용프로그램\n\n![이미지](/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_3.png)\n\nFacebook: 뉴스 피드 업데이트, 실시간 알림 및 실시간 채팅과 같은 기능.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인스타그램: 무한 스크롤링, 라이브 스토리, 실시간 댓글 등의 기능을 제공합니다.\n\nWhatsApp Web: 실시간 업데이트, 여러 채팅 창, 미디어 처리 등의 기능을 제공합니다.\n\n# 참고 자료\n\n이 참고 자료들이 React Fiber와 해당 아키텍처에 대한 이해를 돕는 데 도움이 되었습니다. 유용하게 활용하시기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Andrew Clark: 리액트의 다음 단계 - ReactNext 2016\n\n- 리액트 파이버 아키텍처 - Github 저장소\n\n- SMOOSHCAST: 다니엘 아브라모프와 함께하는 리액트 파이버 심층 탐구\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_0.png"},"coverImage":"/assets/img/2024-06-19-ReactFiberExplainedIncrementalRenderingforSmootherUIs_0.png","tag":["Tech"],"readingTime":4},{"title":"통계 학습에 대한 소개 - 소개","description":"","date":"2024-06-19 23:44","slug":"2024-06-19-AnIntroductiontoStatisticalLearningIntroduction","content":"\n\n## \"An Introduction to Statistical Learning: with Applications in Python by Hastie et. al.\" 에서의 첫 번째 날 메모를 공유합니다. 이것은 제 데이터 과학 학습 문서의 일부입니다.\n\n![이미지](/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_0.png)\n\n## 기계 (통계) 학습 (ML)은 데이터를 이해하는 데 사용되는 다양한 도구 모음을 가리킵니다.\n\n이것은 주로 다음과 같이 분류됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지도 학습: 하나 이상의 입력을 기반으로 출력을 예측하거나 추정하는 (통계적) 모델을 구축하는 것을 말합니다.\n- 비지도 학습: 데이터로부터 관계와 구조를 학습하는 시스템(모델 또는 알고리즘)을 구축하는 것으로, 입력은 있지만 지도 학습에서와 같이 지도 출력이 없습니다.\n\n지도 학습과 비지도 학습의 차이점은 출력 데이터(동의어: 종속 변수, 목표 변수 또는 결과로 \"y\"로 표시됨)의 가용성에 있습니다.\n\n먼저 필수 라이브러리를 가져와서 Python 코드를 준비해보겠습니다.\n\n```js\n# 라이브러리 가져오기\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom ISLP import load_data # 책의 저자가 제공하는 ISLP\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기계 학습의 경우 몇 가지 예시가 있습니다:\n\n## 1. 임금 데이터: 지도 학습 — 회귀\n\n데이터를 가져와 봅시다.\n\n```js\n## ISLP에서 임금 데이터 가져오기\ndf_wage = load_data('Wage')\ndf_wage\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_1.png)\n\n이 데이터는 미국 대서양 지역의 남성 집단의 임금과 관련된 요인을 조사하는 데 사용할 수 있습니다. 결과 변수는 임금이며 입력 변수는 데이터의 나머지 변수입니다.\n\n데이터에서 임금은 양적 값이므로 회귀 문제에 직면하고 있음을 의미합니다. 따라서 연속적 또는 양적 결과를 예측하는 작업에 참여하게 됩니다.\n\n만약 직원의 나이, 교육, 그리고 달력 연도와 임금 사이의 관련을 이해하고 싶다면, 각 입력 변수와 임금 간의 관계를 스캐터 플롯과 상자 그림을 사용하여 시각화하여 수행할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# matplotlib 서브플롯 설정하기\nfig, ax = plt.subplots(1, 3, figsize=(15,4))\n\n# 그림 1\nsns.regplot(data=df_wage, x='age', y='wage', lowess=True, ax=ax[0], scatter_kws={'edgecolor': 'grey', 'facecolor': 'none', 'alpha': 0.5}, line_kws={'color': 'red'})\n\n# 그림 2\nsns.regplot(data=df_wage, x='year', y='wage', lowess=True, ax=ax[1], scatter_kws={'edgecolor': 'grey', 'facecolor': 'none', 'alpha': 0.5}, line_kws={'color': 'red'})\n\n# 그림 3\ntemp = {}\nfor i in df_wage['education'].unique():\n    temp[i] = df_wage[df_wage['education'] == i]['wage'].reset_index(drop=True)\ntemp = pd.DataFrame(temp)\ntemp.columns = temp.columns.str.extract(r'(\\d)')[0].astype(int)\ntemp = temp[[i for i in range(1, 6)]]\ntemp.plot(kind='box', ax=ax[2], color='black', xlabel='교육 수준', ylabel='급여')\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_2.png\" /\u003e\n\n위 그래프를 통해 다음을 알 수 있습니다:\n\n- 연령이 증가함에 따라 급여가 증가하며, 약 40세까지 상승한 후 이후에는 약간 감소하는 경향이 있습니다.\n- 2003년부터 2009년 사이에 급여는 대략적인 선형으로 증가했지만, 데이터의 변동성에 비해 상승폭은 매우 작습니다.\n- 교육 수준이 높을수록 급여가 일반적으로 높습니다. 가장 낮은 교육 수준(1)을 가진 남성은 가장 높은 교육 수준(5)을 가진 사람보다 상당히 낮은 급여를 받는 경향이 있습니다. \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론 나이, 교육 및 연도를 개별적으로 사용하는 대신 이러한 요소를 결합하여 머신러닝 모델을 적합시키면 더 정확한 예측을 할 수도 있습니다. 이것은 나이, 교육 및 연도에 기반한 임금을 예측하는 머신러닝 모델을 적합하는 것으로 이루어질 수 있습니다.\n\n# 2. 주식 시장 데이터: 지도 학습 — 분류\n\n데이터를 가져와 봅시다.\n\n```js\n# ISLP에서 주식 시장 데이터 가져오기\ndf_smarket = load_data('Smarket')\ndf_smarket\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_3.png)\n\n이 데이터는 2001년부터 2005년까지 5년 동안의 S\u0026P 500 지수의 일일 움직임을 포함하고 있습니다. 이 경우, 우리는 양적 또는 범주적 결과, 즉 오늘의 주식 시장 방향을 예측하는 데 관련되어 있습니다. 이 유형의 문제는 분류 문제라고합니다. 시장이 어느 방향으로 움직일지 정확하게 예측할 수있는 모델은 매우 유용할 것입니다!\n\n마켓 방향이 Lag1, Lag2 및 Lag3의 S\u0026P 백분율 변화에 따라 상승 또는 하락하는 패턴을 이해함으로써 데이터를 조금 이해해 봅시다. 다음과 같이 박스플롯을 생성하여 수행할 수 있습니다:\n\n```javascript\n# matplotlib 서브플롯 설정\nfig, ax = plt.subplots(1, 3, figsize=(14, 4))\n\n# 그림 1\ntemp = {}\nfor i in df_smarket['Direction'].unique():\n    temp[i] = df_smarket[df_smarket['Direction'] == i]['Lag1'].reset_index(drop=True)\ntemp = pd.DataFrame(temp)\ntemp.plot(kind='box', color='black', ax=ax[0], xlabel='Today\\'s Direction', ylabel='Percentage Change in S\u0026P', title='Yesterday')\n\n# 그림 2\ntemp = {}\nfor i in df_smarket['Direction'].unique():\n    temp[i] = df_smarket[df_smarket['Direction'] == i]['Lag2'].reset_index(drop=True)\ntemp = pd.DataFrame(temp)\ntemp.plot(kind='box', color='black', ax=ax[1], xlabel='Today\\'s Direction', ylabel='Percentage Change in S\u0026P', title='Two Days Previous')\n\n# 그림 3\ntemp = {}\nfor i in df_smarket['Direction'].unique():\n    temp[i] = df_smarket[df_smarket['Direction'] == i]['Lag3'].reset_index(drop=True)\ntemp = pd.DataFrame(temp)\ntemp.plot(kind='box', color='black', ax=ax[2], xlabel='Today\\'s Direction', ylabel='Percentage Change in S\u0026P', title='Three Days Previous')\n\nplt.show()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_4.png)\n\n위의 그래프를 기반으로 하면, 오늘의 방향이 상승인지 하락인지에 따라 S\u0026P의 백분율 변화에 대한 lag1(어제), lag2(이틀 전), lag3(사흘 전)은 어떤 차이도 보이지 않습니다. 이는 이 3가지 변수를 기반으로 시장이 어떻게 움직일지 예측하는 간단한 전략이 없음을 시사합니다. 만약 패턴이 매우 단순하다면, 누구나 시장에서 수익을 얻기 위한 간단한 거래 전략을 채택할 수 있을 것입니다. 대신, 이러한 유형의 문제는 머신 러닝 모델을 사용하여 오늘의 시장을 고정도로 예측하는 데 해결될 수 있습니다.\n\n# 3. 유전자 발현 데이터: 비지도 학습 — 차원 축소 및 클러스터링\n\n머신 러닝의 중요한 문제 유형 중 하나는 출력 변수가 없이 입력 변수만 관찰되는 상황, 즉 비지도 학습이라고 불리는 상황을 다루는 것입니다. 이전 예제와 달리 여기서는 출력 변수를 예측하려는 것이 아니라는 점이 다릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 유전자 발현 데이터 예시를 확인해 봅시다:\n\n```js\n# 유전자 발현 데이터 가져오기\ndf_gen = load_data('NCI60')\ndf_gen\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_5.png\" /\u003e\n\n이 데이터에는 64개의 암 세포 주석마다 6,830개의 유전자 발현 측정값이 포함되어 있습니다. 특정 출력 변수를 예측하는 대신, 유전자 발현 측정값을 기반으로 세포 주석들 사이에 그룹 또는 클러스터가 있는지를 결정하는 데 관심이 있습니다. 이것은 어려운 질문이며, 그 이유 중 하나는 각 세포 주석당 수천 개의 유전자 발현 측정값이 있어 데이터를 시각화하기 어렵게 만든다고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 차원 축소와 클러스터링과 같은 비지도학습 기술을 사용하여 데이터의 패턴을 더 잘 이해할 수 있습니다.\n\n시작해 봅시다!\n\n```js\n# 첫 두 개요소에 대한 PCA\nfrom sklearn.decomposition import PCA\n\npca = PCA(n_components = 2)\nZ = pca.fit_transform(df_gen['data'])\n\n# 예시로 4개 클러스터에 대한 K-Means 클러스터링\nfrom sklearn.cluster import KMeans\n\nkmeans = KMeans(n_clusters=4)\nkmeans.fit(Z)\n\n# 결과 시각화\nfig, ax = plt.subplots(1, 2, figsize=(10, 4))\n\n# 그림 1\nax[0].scatter(x=Z[:,0], y=Z[:,1], edgecolors='black', facecolor='none')\nax[0].set_xlabel('Z1')\nax[0].set_ylabel('Z2')\n\n# 그림 2\nscatter = ax[1].scatter(x=Z[:,0], y=Z[:,1], c=kmeans.labels_)\nlegendc = ax[1].legend(*scatter.legend_elements(prop='colors'), loc=\"upper left\", title=\"Cluster\")\nax[1].set_xlabel('Z1')\nax[1].set_ylabel('Z2')\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터의 처음 두 주성분을 사용하고 있습니다. 이 주성분은 각 세포주에 대해 측정된 6,830개의 발현 측정치를 두 숫자 또는 차원으로 요약합니다. 이 차원 축소로 인해 일부 정보 손실이 있을 수 있지만, 이제는 데이터를 시각적으로 클러스터링하는 것이 가능해졌습니다. 클러스터의 수를 결정하는 것은 종종 어려운 문제입니다. 위 그래프에서는 설명을 위해 4개의 클러스터를 사용하고 있습니다. 이 그래프를 토대로 유사한 특성을 가진 세포주가 이차원 표현에서 서로 가까이에 위치하는 것을 명확히 알 수 있습니다.\n\n계속됩니다...\n\n이것은 제 100일 데이터 과학 학습 여정 중 일부입니다. 더 많은 학습 업데이트를 위해 저를 팔로우해주세요.\n\n제가 학습한 내용에서 여러분도 배울 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 팔로우하고 박수를 50번 치세요 ️👏️️\n- 우리를 팔로우하세요: 뉴스레터\n- 당신도 구루가 되고 싶나요? 우리의 관객에게 도달하기 위해 가장 좋은 기사나 초고를 제출해 보세요.","ogImage":{"url":"/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_0.png"},"coverImage":"/assets/img/2024-06-19-AnIntroductiontoStatisticalLearningIntroduction_0.png","tag":["Tech"],"readingTime":7},{"title":"GitHub Actions를 통한 간단한 모델 재학습 자동화","description":"","date":"2024-06-19 23:41","slug":"2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions","content":"\n\n\n![이미지](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_0.png)\n\n비즈니스에 엄청난 가치를 창출할 수 있는 것은 기계 학습 모델입니다. 그러나 이를 개발하는 것은 일회성 활동이 아닙니다. 대신 모델이 계속 가치를 제공할 수 있도록 지속적인 프로세스여야 합니다. 이것이 MLOps가 나오게 된 이유입니다.\n\nCI/CD 원칙과 기계 학습 개발을 결합한 것을 MLOps라고 합니다. 이를 통해 모델이 지속적인 가치를 제공할 수 있도록 합니다.\n\n기계 학습 모델이 지속적인 이점을 제공하는 한 가지 방법은 필요할 때 재학습하는 것입니다. 예를 들어, 데이터 드리프트가 감지될 경우 모델을 재학습하는 것입니다. 모델 재학습 자동화를 위해 재학습 트리거의 환경을 설정하여 수행할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub Actions는 GitHub에서 제공하는 기능으로, CI/CD 플랫폼에 사용되며 GitHub 저장소에서 소프트웨어 개발 프로세스를 자동화하는 데 사용됩니다.\n\n이 기사에서는 GitHub Actions를 사용하여 모델 재학습을 자동화하는 방법을 가르쳐 드립니다. 그 방법을 알아볼까요?\n\n# 준비\n\n이 프로젝트에서는 모델 개발 및 자동화 데모를 수행할 것입니다. 전체 프로젝트 구조는 아래 차트와 같을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_1.png)\n\n일단 GitHub Actions을 이 리포지토리에서 사용할 수 있도록 GitHub 리포지토리를 준비하는 것부터 시작해봅시다. 선호하는 이름으로 빈 리포지토리를 만들 수 있습니다. 저는 이 리포지토리를 만들었어요.\n\n추가로, Docker를 사용하여 모델을 배포하는 것을 시뮬레이션해볼 거예요. 이를 위해 Docker Desktop을 설치해봅시다. 그리고 Dockerhub에 가입하지 않은 경우에는 가입하세요.\n\n그런 다음, Repo 및 Workflow 범위를 지닌 GitHub 개인 액세스 토큰(PAT)을 생성해봅시다. 토큰을 어딘가에 보관하고, 방금 만든 빈 리포지토리로 돌아가봅시다. 설정으로 이동하여 \"비밀 값 및 변수\"를 선택합니다. 그런 다음, PAT, Docker 사용자 이름 및 Docker 비밀번호를 포함하는 리포지토리 비밀값을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_2.png)\n\nGitHub 저장소를 로컬 또는 작업하는 플랫폼에 복제하세요. 준비가 되었으면 튜토리얼 전체 구조를 준비해 봅시다. 좋아하는 IDE에서 다음과 같이 폴더를 생성하세요.\n\n```js\ndiabetes-project/\n├── data/\n├── notebooks/\n├── scripts/\n├── models/\n├── .github/\n│   └── workflows/\n``` \n\n폴더가 갖춰지면 가상 환경을 설정합니다. 고립된 환경을 원하기 때문에 이는 좋은 관행입니다. 루트 폴더로 이동하여 다음 CLI 코드를 사용하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npython -m venv your_environment_name\n```\n\n가상 환경을 활성화하려면 아래 코드를 실행하세요.\n\n```js\nyour_environment_name\\Scripts\\activate\n```\n\n가상 환경을 활성화한 후, 튜토리얼을 위해 필요한 모든 패키지를 설치할 것입니다. 루트 폴더에 requirements.txt 파일을 생성하고 아래 패키지를 채워넣어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfastapi\nuvicorn\npandas\nscikit-learn\nmatplotlib\nseaborn\nevidently\n```\n\n요구 사항이 준비되면 가상 환경에 패키지를 설치할 것입니다.\n\n```js\npip install -r requirements.txt\n```\n\n모든 준비가 완료되었으므로, 이제 모델을 개발하고 모델 재학습 자동화를 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모델 개발\n\n이 튜토리얼에서는 공개 도메인 데이터 세트인 Open-Source Diabetes 데이터 세트를 사용할 것입니다. 데이터 세트를 다운로드하여 Data 폴더에 넣어주세요. 저는 데이터 세트를 data.csv로 이름을 변경했지만, 원하시는 이름으로 변경하셔도 됩니다.\n\n우리는 주피터 노트북에서 초기 모델 개발을 진행할 것입니다. 노트북을 만들어서 notebooks 폴더에 넣으세요. 그런 다음, 데이터 세트를 읽어오는 것부터 시작해보겠습니다.\n\n```python\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndata_path = '..//data//data.csv'\n\ndf = pd.read_csv(data_path)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 GitHub Actions 능력을 자동으로 재교육하는 데 초점을 맞추기로 했어요. 데이터 탐색 이외의 것에 초점을 맞출 거예요. 노트북에서 데이터 탐색 부분을 포함했으니, 확인하고 싶다면 방문해주세요.\n\n이제 데이터 전처리와 파이프라인 시작으로 넘어갈게요. 데이터 파이프라인을 사용하여 표준 개발 프로세스를 모방할 거예요.\n\n```python\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\n\nX = df.drop('Outcome', axis=1)\ny = df['Outcome']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\nnumeric_features = X.columns\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='mean')),\n    ('scaler', StandardScaler())\n])\n\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features)\n    ])\n```\n\n파이프라인이 준비되면 머신 러닝 모델로 랜덤 포레스트 알고리즘을 사용할 거예요. 다른 목적에 맞는 다른 모델을 선택할 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nfrom sklearn.ensemble import RandomForestClassifier\n\npipeline = Pipeline(steps=[\n    ('preprocessor', preprocessor),\n    ('classifier', RandomForestClassifier(random_state=42))\n])\n\npipeline.fit(X_train, y_train)\r\n```\n\n모델을 평가하고 성능을 확인해봐요.\n\n```js\r\nfrom sklearn.metrics import classification_report\n\ny_pred = pipeline.predict(X_test)\n\n# 모델 평가\nreport = classification_report(y_test, y_pred)\nprint(report)\r\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전반적으로 성능은 만족스러운 수준입니다. 더 나아질 여지는 있지만, 현재 모델을 유지하고 이를 모델 폴더에 저장하겠습니다.\n\n```js\nimport pickle\n\nwith open('..//models//pipeline.pkl', 'wb') as f:\n    pickle.dump(pipeline, f)\n```\n\n모델이 완성되면 우리는 프로덕션 환경에 배포할 것입니다. 이를 API로 배포하고 모델을 컨테이너화하기 위해 Docker를 사용할 것입니다.\n\n모델을 API로 배포하기 위해 app.py라는 파일을 생성하여 스크립트 폴더에 저장해 봅시다. 파일 내부에 다음 코드를 사용하여 모델을 API로 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport pickle\nimport pandas as pd\n\napp = FastAPI()\n\ncolumns = ['임신횟수', '글루코스', '혈압', \n'피하지방', '인슐린', 'BMI', '당뇨위계보이지DNA', '나이']\n\ndict_res = {0: '당뇨가 아님', 1: '당뇨'}\n\npipeline_path = 'models/pipeline.pkl'\nwith open(pipeline_path, 'rb') as pipeline_file:\n    pipeline = pickle.load(pipeline_file)\n\nclass DataInput(BaseModel):\n    data: list\n\n@app.post(\"/predict\")\nasync def predict(input_data: DataInput):\n    try:\n        df = pd.DataFrame(input_data.data, columns=columns)\n        predictions = pipeline.predict(df)\n        results = [dict_res[pred] for pred in predictions]\n    \n        return {\"예측결과\": results}\n    \n    except Exception as e:\n        print(\"에러:\", str(e))\n        raise HTTPException(status_code=400, detail=str(e))\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n모델 API에 액세스할 수 있는지 테스트해 봅시다. 먼저, 응용 프로그램을 시작하려면 CLI에서 다음 코드를 실행합니다.\n\n```js\nuvicorn scripts.app:app --host 0.0.0.0 --port 8000\n```\n\n그런 다음, Jupyter Notebook에서 다음 코드를 실행하여 API를 테스트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport requests\n\nurl = \"http://localhost:8000/predict\"\n\ndata = {\n    \"data\": [\n        [1, 85, 66, 29, 0, 26.6, 0.351, 31]\n    ]\n}\n\nresponse = requests.post(url, json=data)\nprint(response.json())\n```\n\nAPI에 전달하는 데이터의 위치가 훈련 데이터와 동일한지 확인해주세요. API가 잘 작동하면 Docker 이미지를 빌드하고 허브에 푸시할 것입니다.\n\n먼저 루트 폴더에 dockerfile을 생성해주세요. 해당 파일에 다음 코드를 채워넣어주세요.\n\n```js\nFROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt requirements.txt\nRUN pip install -r requirements.txt\n\nCOPY scripts/app.py app.py\nCOPY models models\n\nEXPOSE 8000\n\nCMD [\"uvicorn\", \"app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드에서는 Python 환경을 설정하고 API를 실행하는 데 필요한 파일을 컨테이너로 복사하여 포트 8000에서 수신 대기하는 방법을 안내합니다.\n\nDockerfile로 이미지를 빌드하는 방법은 준비가 되면 다음 코드를 사용하면 됩니다.\n\n```js\ndocker build -t username/image_name -f Dockerfile .\ndocker login -u username\ndocker push username/image_name:latest\n```\n\n위 코드에서 username을 귀하의 Dockerhub 사용자명으로, image_name을 선호하는 응용 프로그램 이름으로 변경해주세요. 성공한다면, 내 것과 같이 Dockerhub에 귀하의 이미지가 표시될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 우리가 모델 API를 Docker에 넣고 Dockerhub에 푸시한 이유는 무엇인가요? 이것은 응용 프로그램을 실행할 모든 환경에서 일관성을 보장하기 때문입니다.\n\n또한 GitHub Actions가 다음 섹션에서 모델을 다시 학습하고 다시 이 컨테이너로 푸시하는 데 얼마나 강력한지를 보여줍니다. 따라서 우리는 모델을 배포하기 위해 이미지를 가져오기만 하면 됩니다.\n\n아래 코드를 실행하여 Dockerhub에서 이미지를 가져와 로컬 환경에서 실행해보세요.\n\n```js\ndocker login -u username\ndocker pull username/image_name:latest\ndocker run -d -p 8000:8000 username/image_name:latest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 제품 모델이 운영 중입니다. 다음 부분에서는 GitHub Actions를 사용하여 모델을 특정 트리거로 다시 학습하는 방법을 살펴보겠습니다.\n\n# GitHub Actions를 활용한 모델 재학습\n\n제가 언급했듯이, 머신 러닝 모델은 지속적인 프로젝트입니다. 이를 통해 어떤 가치를 제공하려면 중요한데, 왜냐하면 모델이 항상 동일한 품질을 유지할 것으로 기대하기 어렵기 때문입니다. 특히, 드리프트가 발생하면 더욱 그렇습니다.\n\n이 튜토리얼에서는 운영 데이터셋에서 데이터 드리프트가 감지될 때 자동으로 모델 재학습을 수행하는 방법을 배우겠습니다. 먼저, 데이터셋에서 드리프트를 감지하는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드를 사용하여 데이터셋에서 drift를 시뮬레이션해 보겠습니다.\n\n```js\nimport numpy as np\n\ndef introduce_drift(data, drift_features, drift_amount=0.1, random_seed=42):\n    np.random.seed(random_seed)\n    drifted_data = data.copy()\n    \n    for feature in drift_features:\n        if feature in data.columns:\n            drifted_data[feature] += np.random.normal(loc=0, scale=drift_amount, size=data.shape[0])\n    \n    return drifted_data\n    \nfeatures_to_drift = ['Glucose', 'BloodPressure', 'SkinThickness', 'Pregnancies']\n\ndrifted_data = introduce_drift(X_test, features_to_drift, drift_amount=50)\ndrifted_data = drifted_data.reset_index(drop=True)\n```\n\n위 코드에서는 Test 데이터의 일부 열을 drift했습니다. drift_amount를 조절하여 데이터가 얼마나 변하는지 제어할 수 있습니다.\n\n튜토리얼에는 학습 데이터(참조)와 drift 데이터(신규)가 필요합니다. 나중에 다시 학습할 때 사용할 타겟 열도 저장해두는 것이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nreference_data['Outcome'] = y_train.reset_index(drop=True)\r\ndrifted_data['Outcome'] = y_test.reset_index(drop=True)\r\n\r\ndrifted_data.to_csv('..//data//new_data.csv', index=False)\r\nreference_data.to_csv('..//data//reference_data.csv', index=False)\r\n\n\r\nEvidently(제가 Evidently와 어떤 제휴도 없습니다)를 사용하여 제품 데이터가 참조 데이터에 비해 드리프트했는지 확인할 수 있습니다. 다음 코드로 확인할 수 있습니다.\r\n\r\n```python\r\nfrom evidently.metric_preset import DataDriftPreset\r\nfrom evidently.report import Report\r\n\r\ndata_drift_report = Report(metrics=[DataDriftPreset()])\r\n\r\ndata_drift_report.run(current_data=drifted_data.drop('Outcome', axis=1), \r\nreference_data=reference_data.drop('Outcome', axis=1), column_mapping=None)\r\nreport_json = data_drift_report.as_dict()\r\ndrift_detected = report_json['metrics'][0]['result']['dataset_drift']\r\n```\r\n\r\n![이미지](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_4.png)\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과에는 나중에 재훈련 자동화를 위해 사용할 드리프트 데이터 세트가 나타납니다.\n\n드리프트 감지를 시뮬레이션하기 위해 drift_detection.py라는 파일을 만들어서 스크립트 폴더에 저장해보겠습니다. 아래 코드를 파일에 채워 넣어주세요.\n\n```js\nimport pandas as pd\nfrom evidently.metric_preset import DataDriftPreset\nfrom evidently.report import Report\n\nreference_data = pd.read_csv('data/reference_data.csv')\nnew_data = pd.read_csv('data/new_data.csv')\n\ndata_drift_report = Report(metrics=[\n    DataDriftPreset()\n])\n\ndata_drift_report.run(reference_data=reference_data.drop('Outcome', axis=1), \n                      current_data=new_data.drop('Outcome', axis=1), column_mapping=None)\n\nreport_json = data_drift_report.as_dict()\ndrift_detected = report_json['metrics'][0]['result']['dataset_drift']\n\nif drift_detected:\n    print(\"데이터 드리프트가 감지되었습니다. 모델을 재훈련합니다.\")\n    with open('drift_detected.txt', 'w') as f:\n        f.write('drift_detected')\nelse:\n    print(\"데이터 드리프트를 감지하지 못했습니다.\")\n    with open('drift_detected.txt', 'w') as f:\n        f.write('no_drift')\n```\n\n위 코드에서 우리는 드리프트 감지 여부를 drift_detected.txt 파일에 저장하고, 드리프트가 감지되었는지 여부에 따라 정보를 출력합니다. 드리프트가 감지된 경우, 모델을 재훈련하고 싶습니다. 이에 대비하여 훈련 스크립트를 준비해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스크립트 폴더에 train_model.py라는 파일을 만들고 다음 코드로 채워주세요.\n\n```python\nimport pandas as pd\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import RandomForestClassifier\nimport pickle\n\nreference_data = pd.read_csv('data/reference_data.csv')\nnew_data = pd.read_csv('data/new_data.csv')\n\ndf= pd.concat([reference_data, new_data], ignore_index=True)\n\nX = df.drop('Outcome', axis=1)\ny = df['Outcome']\n\nnumeric_features = X.columns\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='mean')),\n    ('scaler', StandardScaler())\n])\n\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features)\n    ])\n\npipeline = Pipeline(steps=[\n    ('preprocessor', preprocessor),\n    ('classifier', RandomForestClassifier(random_state=42))\n])\n\npipeline.fit(X, y)\n\nwith open('models/pipeline.pkl', 'wb') as f:\n    pickle.dump(pipeline, f)\n```\n\n위의 코드는 학습 및 드리프트 데이터를 새로운 학습 모델로 결합하고, 이를 사용하여 새 모델을 학습하는 것입니다. 이는 간단한 접근 방식일 뿐이며, 실제 세계의 학습 데이터는 더 많은 준비가 필요하고, 새 모델은 적절한 평가가 필요합니다.\n\n그러나 모든 스크립트가 준비되면, GitHub Actions를 통해 드리프트가 감지될 때 모델을 재학습할 수 있도록 준비할 것입니다. 재학습에 필요한 모든 구성을 포함하는 YAML 파일을 준비해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, .github\\workflows 폴더에 mlops_pipeline.yml 파일을 생성해봅시다. 폴더 이름이 제대로 되었는지 확인하세요; GitHub Actions은 적절한 이름이 필요합니다. 아래의 코드로 mlops_pipeline.yml을 채워넣어주세요.\n\n```js\nname: Diabetes Retraining Pipeline with Data Drift Detection\n\non:\n  push:\n    paths:\n      - 'data/new_data.csv'\npermissions:\n  contents: write\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2 \n      with:\n        python-version: 3.9\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Run data drift detection\n      run: |\n        python scripts/drift_detection.py\n      continue-on-error: true \n\n    - name: Check for data drift\n      id: check_drift\n      run: |\n        if grep -q 'drift_detected' drift_detected.txt; then\n          echo \"Data drift detected.\"\n          echo \"drift=true\" \u003e\u003e $GITHUB_ENV\n        else\n          echo \"No data drift detected.\"\n          echo \"drift=false\" \u003e\u003e $GITHUB_ENV\n        fi\n      shell: bash\n\n    - name: Model Retraining if Data Drift detected\n      if: env.drift == 'true'\n      run: |\n        python scripts/train_model.py\n\n    - name: Commit and push updated model\n      if: env.drift == 'true'\n      env:\n        GIT_COMMITTER_NAME: github-actions\n        GIT_COMMITTER_EMAIL: github-actions@github.com\n      run: |\n        git config --global user.name \"github-actions\"\n        git config --global user.email \"github-actions@github.com\"\n        git remote set-url origin https://x-access-token:${ secrets.ACTIONS_PAT }@github.com/username/image_name.git\n        git add models/pipeline.pkl\n        git commit -m \"Update model after retraining on $(date -u +'%Y-%m-%d %H:%M:%S UTC')\"\n        git push\n\n    - name: Build Docker image\n      if: env.drift == 'true'\n      run: |\n        docker build -t username/image_name -f dockerfile .\n\n    - name: Log in to Docker Hub\n      if: env.drift == 'true'\n      run: echo \"${ secrets.DOCKER_PASSWORD }\" | docker login -u \"${ secrets.DOCKER_USERNAME }\" --password-stdin\n\n    - name: Push Docker image to Docker Hub\n      if: env.drift == 'true'\n      run: |\n        docker push username/image_name:latest\n\n    - name: Notify about the process\n      run: |\n        if [[ \"$GITHUB_ENV\" == *\"drift=false\"* ]]; then\n          echo \"No data drift detected. No retraining necessary.\"\n        else\n          echo \"Data drift detected. Model retrained and deployed.\"\n        fi\n      shell: bash\n```\n\n위의 YAML에서 수행한 전체 설정 구조는 아래 이미지에 나와 있습니다.\n\n![Simple Model Retraining Automation via GitHub Actions](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub Actions에서 사용하는 트리거는 data 폴더 안에 new_data.csv 파일이 푸시될 때입니다. 그러나 모델 재학습은 drift가 감지될 때만 실행됩니다. 모델을 다시 훈련한 후, 해당 모델을 GitHub 저장소와 Docker Hub에 다시 푸시할 것입니다.\n\n사용자명/image_name Docker 식별자를 꼭 자신의 것으로 변경해주세요. 동일한 식별자를 사용하는 경우 Repository Secrets를 생성할 수도 있습니다.\n\n모든 파일이 준비되면 GitHub 저장소에 푸시해야 합니다. 그런 다음 새로운 drift 데이터를 생성하여 new_data.csv로 저장하고, 해당 데이터를 저장소에 다시 푸시해보세요.\n\nGitHub 저장소의 Actions 탭으로 이동해주세요. 성공적으로 실행되었다면, 'Success' 상태를 가진 'build'라는 작업이 하나 표시될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_6.png)\n\n작업을 클릭하여 프로세스의 모든 세부 정보를 확인할 수 있습니다. 각 단계의 정보를 확인하여 프로세스를 이해하거나 실행에 실패했는지 확인할 수 있습니다.\n\n![image](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_7.png)\n\n저장소의 모델로 이동하면 모델이 업데이트되었는지 확인할 수 있습니다. 모델을 다시 학습했을 때 커밋 메시지를 사용하여 알림을 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_8.png)\n\n도커 허브 저장소를 확인해서 이미지가 업데이트되었는지도 확인할 수 있어요.\n\n여기까지면 GitHub Actions를 사용해서 모델 재교육 프로세스를 간단히 할 수 있어요. 여러분이 원하는대로 스크립트를 조정할 수 있어요. 예를 들어 트리거, 재교육 조건, 데이터셋 등을 말이에요.\n\n이 글에서 사용한 코드들이 필요하면, 해당 레포지토리에 푸시해 놓았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 글에서는 GitHub Actions를 사용하여 모델 재학습 프로세스를 자동화하는 방법을 배웠습니다. YAML 파일을 통해 구성을 설정하고 트리거를 결정함으로써 GitHub Actions를 사용하여 필요한 모든 프로세스를 간편하게 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_0.png"},"coverImage":"/assets/img/2024-06-19-SimpleModelRetrainingAutomationviaGitHubActions_0.png","tag":["Tech"],"readingTime":16},{"title":"파이썬으로 하는 예상 향상 및 가우시안 프로세스 회귀 최적화에 대한 실습","description":"","date":"2024-06-19 23:38","slug":"2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_0.png\" /\u003e\n\n저희 아내는 비즈니스 전공자인데요, \"인공지능이 뭐에요?\"라고 물어보면 이렇게 답합니다:\n\n그리고 이게 사람들이 인공지능을 설명하는 방식과 매우 일치한다고 생각해요. 조금 수정하면 진실과 많이 다르지 않을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 만약 수학자나 물리학자와 이야기를 나누면, 답변은 훨씬 더 기술적이고 아마 지루할 것입니다 (나는 물리학자이기 때문에 그렇게 말할 수 있어요). 만약 AI를 정의한다면 이렇게 말할 거예요:\n\n...내가 말했던 것처럼 좀 지루하죠. 무슨 말일까요?\n\n# 0. 기계 학습은 최소화 문제로\n\n우리가 가상 지능을 사용해 집값을 예측한다고 가정해봅시다. 가상 지능을 사용하기 전에는 실제로 여러 요소들(위치, 크기, 건축 연도 등)을 기반으로 집 값 평가를 하는 사람이 있습니다. 우리 모두가 알다시피, 가상 지능에는 데이터가 필요하죠. 그래서 트레이닝 세트를 만들기 위해 이 일을 수많은 번 반복해야 합니다.\n다음과 같은 내용이겠지요:\n\n# 0. 기계 학습은 최소화 문제로\n\n우리가 가상 지능을 사용해 집값을 예측한다고 가정해봅시다. 가상 지능을 사용하기 전에는 실제로 여러 요소들(위치, 크기, 건축 연도 등)을 기반으로 집 값 평가를 하는 사람이 있습니다. 우리 모두가 알다시피, 가상 지능에는 데이터가 필요하죠. 그래서 트레이닝 세트를 만들기 위해 이 일을 수많은 번 반복해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이미지 파일: /assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_1.png\n\n이 집 모음과 해당하는 가격은 머신러닝 모델을 최적화하는 데 사용됩니다. 예를 들어, 우리가 사는 매우 단순한 상상 속 세계에서 집 값은 오직 크기에만 의존한다고 가정해 봅시다. 예를 들어, 만약 크기가 x이고 해당하는 가격이 y라면 다음과 같습니다:\n\n이미지 파일: /assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_2.png\n\n따라서 크기가 x = 2인 집은 가격이 50x2 = 100(임의의 단위)인 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 머신러닝 모델을 사용할 때 다음과 같이 가정해 봅시다:\n\n![이미지](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_3.png)\n\n예를 들어, 크기가 x = 1인 새 집이 있다고 가정하면, \nw 대비 오류(Error) 플롯은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 이제 우리는 오차를 0으로 만들고 싶습니다. 집의 정확한 가격을 예측하는 데 우리는 머신러닝 모델을 가지고 싶습니다.\n\n실제로는 이 그림에서 보는 것과 같이 플롯이 없습니다. 실제로는 랜덤한 w(또는 랜덤한 벡터 w)를 선택하고 최소 오차를 찾기 위해 최적화합니다.\n\n머신러닝 애호가라면 이 이야기가 낯설지 않을 것입니다. 예를 들어, 그레디언트 디센트라는 것을 들어본 적이 있을 수 있습니다.\n\n# 1. 그레디언트 디센트와 그 한계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGradient descent은 함수의 오류를 반복적으로 최소화하는 기술로, 기울기의 반대 방향을 따라가면서 이루어집니다. 이런식으로 말이죠:\n\n![이미지는 생략합니다]\n\n수식으로 지루하게 하고 싶진 않지만, 알고리즘의 논리는 다음과 같습니다:\n\n- 랜덤 매개 변수 벡터로 시작합니다. 위의 경우에는 매개 변수가 하나뿐인데, 모델의 차원은 보통 훨씬 더 큽니다 (백만 또는 십억 차원 벡터)\n- 랜덤 매개 변수에 대한 손실 함수의 기울기를 추정합니다.\n- 기울기 방향으로 한 걸음 움직입니다 (위의 그림에서 보는 것처럼)\n- \"수렴에 도달\"하면 중단하고, 그렇지 않으면 단계 2와 3을 반복합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그림에서 볼 수 있듯이, 기울기가 함수가 증가하는 곳을 알려주는 것이라면, \"기울기의 반대\"는 함수가 감소하는 곳을 알려줍니다: 손실 함수(최소화해야 하는 함수)의 감소 경로를 따르면 게임에 이기는 것이죠.\n\n하지만 모두가 그렇지는 않을까요? 그렇지 않거나, 적어도 항상은 아닙니다. 핵심은 4단계의 \"수렴에 도달할 경우\"라는 문장에 있습니다. \"수렴\"이란 무엇을 의미할까요? \"수렴\"이란 \"지역 수렴\"이나 원한다면 \"지역 최소값으로의 수렴\"을 의미합니다. 매우 혼란스럽죠. 알겠어요. 잠깐 인간처럼 이야기해 볼게요.\n\n위에서 보여드린 함수에 여러 가지 단순화가 있습니다. 단순화 중 하나는 1차원만 있다는 것입니다(이미 이야기했죠). 다른 큰(매우 큰) 단순화는 해당 함수에 최소값이 하나뿐이라는 것입니다. 많은(모든 것 같다고 말할게요) 기계 학습 사례에서는 여러 최솟값이 있는 손실 함수가 있고, 경사 하강 알고리즘을 실행하면 \"지역 최소값에 갇힌다\"는 것을 여기 비볼록 함수에서 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빨간 케이스에서는 알고리즘의 끝에 있는 파란 십자가가 실제로는 최소값이지만 지역 최소값입니다. 다시 말하면, 오차를 최소화하기 위해 노력하고 있지만 이를 부분적으로만 달성하고 있습니다: 문제의 전역 최소값을 찾지 못하고 있습니다.\n\n이것은 머신 러닝 커뮤니티에서 잘 알려진 문제이지만 사실 더 일반적인 문제입니다:\n\n이 문서에서는 예상 개선 방법을 사용합니다. 환영합니다! 🚂\n\n## 2. 가우시안 프로세스 회귀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 Global Minimum Search를 시작하기 전에 친구인 Gaussian Process Regression(GPR) 또는 Kriging을 알아야 합니다. 이름에서 알 수 있듯이 GPR은 회귀 알고리즘으로, 이 모델의 입력은 벡터이고 출력은 실수(필수적으로 정수일 필요는 없음)입니다.\n\n나는 Gaussian Process Regression을 너무 좋아해서 말을 멈추지 않으면 내 아내가 나를 떠나겠죠. 또한 Gaussian Process Regression을 이상치 탐지 알고리즘으로 사용하는 방법과 생성 모델로 사용하는 방법에 대해 기사를 쓰기도 했습니다.\n\n가우시안 프로세스는 매력적이어서 이에 관해 전문적인 연구를 할만한 충분한 자료가 있으나, Medium 기사를 통해 GPR의 아름다운 세계를 소개하려면 GPR을 기계학습 커뮤니티에서 유명하게 한 Christopher K. I. Williams와 Carl Edward Rasmussen의 말을 사용할 것입니다:\n\n정말 엄청 복잡하잖아요? 간단하게 만들어 볼게요. 내가 이전에 말한 것을 기억하나요? 입력이 벡터이고 출력이 실수인 것에 대해요? 출력이 실수뿐만 아니라 평균 값(평균)과 분산이라고 상상해봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n입력 데이터(학습 데이터) 세트는 확률의 조건부 조건으로 사용됩니다. 이것은 𝜇(𝑥), 𝐶(𝑥,𝑥′) 및 학습 데이터로부터 시작하여 다음 점에 대한 y의 예측을 제공합니다.\n\n예를 통해 이해해 보겠습니다.\n\n## 2.1 가우시안 프로세스 회귀 구현\n\n다음에 대한 매우 간단한 이 방정식부터 시작합시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_7.png)\n\n우리가 Python과 일부 라이브러리 친구들을 사용하여 그래프를 그리면 이렇게 됩니다:\n\n말씀드리는 대로, 확률 과정이 데이터를 평균 함수와 위에서 설명한 공분산 함수로 모델링한다고 가정할 수 있습니다. 아름다운 이야기입니다. 이제 새 데이터로 사전 확률을 업데이트할 것입니다. 지금 제가 철학을 하고 있는 것처럼 들릴 수 있지만, 실제로 말하고 싶은 것은 사전 확률(위에서 정의한 평균과 공분산)과 훈련 세트 사이의 조건부 확률을 작성하는 것입니다. 저와 같은 수학 좋아하는 사람들에게는 이것이 아이디어입니다:\n\n![image](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nf_'x*'가 모든 가능한 결과이며, k∗는 테스트 포인트와 트레이닝 포인트 간의 공분산 벡터이며, 요소는 𝑘∗(𝑖)=𝑘(𝑥𝑖,𝑥∗)이며, K는 공분산 행렬이며, \\sigma_'n'²는 잡음 값입니다. 요약하자면, 언제나 해야 할 것처럼, 훈련 세트와 테스트 세트가 필요합니다. 이를 수행하는 데는 몇 줄만 있으면 됩니다:\n\n그리고 이것이 플롯입니다:\n\n이제 이 함수를 최소화하려고 한다고 가정해 봅시다. 해당 평균과 분산을 얻기 위해 방정식 [2]를 적용합니다. 이 작업은 아주 몇 줄로 이루어집니다:\n\n이 그림에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 오렌지색 함수는 대상입니다: 우리가 모델링하려는 알 수 없는 함수입니다 (실제로는 알 수 없음)\n- 짙은 파란색 선과 음영은 평균과 2배의 표준 편차이며, 약 95%의 불확실성을 나타냅니다. 이는 오렌지색 선이 파란 음영 사이에 위치할 것이라는 것을 의미합니다.\n- 훈련 세트는 빨간 십자가 세트입니다. 불확실성은 항상 빨간 십자가에서 0입니다.\n- 테스트 세트는 파란 십자가 세트입니다.\n\n## 3. 전역 최적화\n\n좋아요, 하지만 최적화 문제를 약속했어요. 그게 어디에 있나요?\n\n이전 그림의 예측을 살펴보면, 예측된 최솟값이 있지만 지역 최솟값이며 올바른 전역 최솟값이 아닙니다. 이는 파란색 선의 최솟값이 2에서 4 사이에 위치하기 때문입니다. 오렌지색 선의 최솟값은 0에서 2 사이에 있습니다. 어떻게 찾을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 요령이 있어요: 가운데 큰 불확실성(큰 음영 영역)을 보세요. 이것은 해당 영역에서 무슨 일이 일어날지 전혀 모른다는 것을 의미합니다. 불확실성이 너무 커서 무엇이 발생하는지 알아보아야 해요! 우리는 추정을 개선할 수 있는 영역이 어디인지 알려주는 양을 발견해야 해요. 이를 '예상 향상'이라고 부릅니다.\n\n수학적 내용을 지루하게 설명하고 싶지 않아요(어쨌든 매우 간단해요)만 예상 향상은 다음과 같은 양으로 계산돼요:\n\n그림을 그려볼게요:\n\n초록 선을 보고 이를 위에 있는 GPR 그래프와 비교한다면, 매우 큰 불확실 영역이 있는데 경계가 매우 크고 따라서 예상 향상이 크다는 것을 알 수 있어요. 와! 그것이 우리가 필요한 것이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 큰 향상이 예상되는 영역에 1점을 추가할 예정이에요. 최소값의 변화가 더 이상 크게 없을 때까지 계속 이를 반복합니다. 9회 반복 예제를 보여드릴게요:\n\n사용할 이 블랙 박스 함수를 정의해볼게요:\n\n지금부터 블로그 게시물 아이디어는 아래 코드 라인에 있어요:\n\n![image](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과를 분석해 보겠습니다. 빨간 점은 GPR 예측을 학습하기 위해 사용된 이전 점으로, 파란색 선은 예측을 나타내며 파란색 음영은 불확실성 경계를 보여줍니다. 실제로는 모르는 검은 상자 함수는 주황색입니다. 다음 점은 초록색 점입니다.\n\n첫 번째 그림은 새로운 점을 지역 최소점에 추가하는 것을 보여줍니다.\n두 번째 그림은 도메인의 오른쪽 부분을 탐험하는 것을 보여줍니다 (거의 탐험되지 않은 부분).\n세 번째 그림은 알고리즘이 공간을 계속 탐색하여 지역 최소점을 찾는 것을 보여줍니다.\n네 번째 그림은 도메인의 왼쪽 부분을 탐색하는 것을 보여줍니다.\n다섯 번째 그림부터 아홉 번째 그림까지 알고리즘이 0과 2 사이의 최소값을 찾는 과정을 볼 수 있습니다. 이것이 우리의 전역 최소값입니다. 성공했습니다!\n\n# 4. 결론\n\n이 블로그 포스트에서는 글로벌 최적화 문제에 대해 논의했습니다. 다음 단계를 따라 수행했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저희는 머신 러닝을 최적화 문제로 정의했어요. 특히, 주택 가격에 대한 선형 회귀의 매우 단순한 예제로, ML 알고리즘을 오차 함수의 최소화로 형식화할 수 있는 방법을 보여드렸어요.\n- 저희는 경사 하강 알고리즘을 설명했어요. 경사 하강은 오차 함수를 수치적으로 최소화하는 기술이에요. 안타깝게도, 이 방법은 알고리즘의 성능이 저하될 수 있어요, 지역 (전역이 아닌) 최솟값에 갇힐 수 있기 때문이죠.\n- 저희는 GPR을 소개했어요. 이는 결과를 예측하는 것뿐만 아니라 불확실성을 측정하는 멋진 방법이에요. 아주 멋져요. 만점 받았네요. :)\n- 저희는 Expected Improvement (EI)을 정의했어요. 이는 우리가 가장 불확실한 지역을 탐색하도록 안내하는데 도움이 돼요. 결국, 이는 가능한 지역 최솟값을 갖는 영역을 탐색하도록 도와 전역 최솟값을 찾을 확률을 높여줘요.\n- 저희는 전역 최솟값 탐색 알고리즘을 수행했어요. 파이썬을 사용해 함수의 최솟값을 시각화와 함께 단계별로 찾는 방법을 보여드렸어요.\n\n# 7. 나에 대해!\n\n다시 한 번 시간 내어 주셔서 감사합니다. 정말로 소중해요 ❤\n\n제 이름은 Piero Paialunga이고, 이 사진 속에 제가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_10.png)\n\n안녕하세요! 저는 신시내티 대학교 항공우주공학부의 박사 후보이자 Gen Nine의 기계 학습 엔지니어입니다. 제 블로그 게시물과 LinkedIn에서 AI 및 기계 학습에 대해 이야기합니다. 만약 이 글을 좋아하시고 기계 학습에 대해 더 알고 싶으시다면:\n\nA. 제 LinkedIn을 팔로우해주세요. 거기서 제 이야기를 모두 공유합니다.\nB. 제 뉴스레터를 구독하세요. 새로운 이야기에 대한 최신 소식을 전해드리고 문의사항이나 의문을 보내주시면 모두 답변해드립니다.\nC. 추천 회원이 되어주세요. 그러면 매월 \"최대 이야기 수\"라는 제한이 없어지며, 전 세계의 기계 학습 및 데이터 과학 최고 작가들이 새로운 기술에 대해 쓴 글을 자유롭게 읽으실 수 있습니다.\nD. 저와 함께 일하고 싶으신가요? Upwork에서 내 요율과 프로젝트를 확인해보세요!\n\n질문이나 협업을 원하시면 메시지를 남겨 주시거나 LinkedIn에서 연락해주세요. 부담없이 문의 주시길 바랍니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n피에로 파이아룽가님, 전자 메일 주소를 제공해 주셔서 감사합니다. 호환성을 위해 표 태그를 마크다운 형식으로 변경해 드리겠습니다. 만약 추가로 도움이 필요하시면 언제든지 문의해 주세요.","ogImage":{"url":"/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_0.png"},"coverImage":"/assets/img/2024-06-19-HandsOnOptimizationwithExpectedImprovementandGaussianProcessRegressioninPython_0.png","tag":["Tech"],"readingTime":9}],"page":"52","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"52"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>