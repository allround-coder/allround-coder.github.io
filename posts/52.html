<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="네스트JS에서 인증 구현하는 방법에 대한 상세 가이드" href="/post/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네스트JS에서 인증 구현하는 방법에 대한 상세 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네스트JS에서 인증 구현하는 방법에 대한 상세 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네스트JS에서 인증 구현하는 방법에 대한 상세 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 제너레이터에 대해 두렵지 마세요" href="/post/2024-05-14-DontBeAfraidofJavaScriptGenerators"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 제너레이터에 대해 두렵지 마세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 제너레이터에 대해 두렵지 마세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 제너레이터에 대해 두렵지 마세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 17에서 Role-Based Access Control RBAC 구현하기" href="/post/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 17에서 Role-Based Access Control RBAC 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 17에서 Role-Based Access Control RBAC 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 17에서 Role-Based Access Control RBAC 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" href="/post/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" href="/post/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시작하기 JavaScript LLM 앱용 LangSmith" href="/post/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시작하기 JavaScript LLM 앱용 LangSmith" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시작하기 JavaScript LLM 앱용 LangSmith" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시작하기 JavaScript LLM 앱용 LangSmith</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 Angular 17 기능 새로운 제어 흐름 구문" href="/post/2024-05-14-NewAngular17featurenewcontrolflowsyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Angular 17 기능 새로운 제어 흐름 구문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Angular 17 기능 새로운 제어 흐름 구문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 Angular 17 기능 새로운 제어 흐름 구문</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" href="/post/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 함수에 대한 인터뷰 개념" href="/post/2024-05-14-InterviewConceptsonJavaScriptFunctions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 함수에 대한 인터뷰 개념" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 함수에 대한 인터뷰 개념" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 함수에 대한 인터뷰 개념</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" href="/post/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link posts_-active__YVJEi" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"네스트JS에서 인증 구현하는 방법에 대한 상세 가이드","description":"","date":"2024-05-14 14:21","slug":"2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS","content":"\n\n이 포괄적인 안내서는 강력한 Node.js 프레임워크인 NestJS에서 인증 구현에 대한 단계별 안내를 제공합니다. 기본 개념, 최선의 실천법 및 실전 예제를 다루며, 이 안내서는 NestJS 애플리케이션을 위한 견고한 인증 시스템을 구축하기 위한 지식을 개발자들에게 제공하는 것을 목표로 합니다.\n\n![이미지](/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png)\n\n인증은 많은 애플리케이션의 기능성에서 중요한 구성 요소로 자리 잡고 있습니다. 인증 관리는 특정 프로젝트의 특정 요구 사항에 맞게 맞춘 각기 다른 접근 방식과 전략을 탐색하는 과정을 포함합니다. 이 섹션에서는 여러 인증 접근 방식을 개요하여 다양한 응용프로그램의 명백한 요구 사항을 충족시킬 수 있는 사용자 정의 옵션을 설명합니다.\n\n특정 시나리오에서 클라이언트는 사용자 이름과 비밀번호로 인증하여 프로세스를 시작합니다. 성공적인 인증 후에 서버는 JWT(JSON Web Token)를 생성하고, 이를 인증 확인을 위한 후속 요청의 권한 부여 헤더로 전송할 수 있는 베어러 토큰으로 전송합니다. 더불어, 유효한 JWT가 포함된 요청에서만 접근 가능한 안전한 경로를 설정할 것입니다.\n\n\n\n# 스텝 바이 스텝 가이드:\n\n진행은 초기 요구 사항으로 시작됩니다: 사용자 인증. 그 다음으로는 JWT를 생성하고 발급함으로써 이를 확장합니다. 마지막으로는 수신 요청 내의 유효한 JWT의 존재를 확인하는 보호된 라우트를 구축합니다.\n\n## 1. 종속성 설치\n\n```js\nnpm install @nestjs/jwt passport-jwt @types/passport-jwt\n```\n\n\n\n## 2. 인증 및 사용자 모듈 생성하기\n\n```js\nnest g module auth\nnest g controller auth\nnest g service auth\n```\n\nAuthService를 구현할 때 유용하게 사용자 작업을 캡슐화하는 UsersService를 만드는 것이 좋습니다. 그러니 바로 해당 모듈과 서비스를 생성합시다:\n\n```js\nnest g module users\nnest g service users\n```\n\n\n\n## 3. 사용자 DTO 구현\n\nData Transfer Object (DTO)는 응용 프로그램의 다른 부분 간에 네트워크를 통해 전송될 데이터를 정의하고 유효성 검사하는 데 사용되는 디자인 패턴입니다.\n\n```js\n// backend/src/dto/user/base-user.dto.ts\n```\n\n```js\nimport { ApiProperty } from '@nestjs/swagger';\nexport class BaseUser {\n  @ApiProperty()\n  id?: string;\n  @ApiProperty()\n  username?: string;\n  @ApiProperty()\n  email: string;\n  @ApiProperty()\n  password: string;\n  @ApiProperty()\n  confirmPassword?: string;\n  @ApiProperty()\n  designation?: string;\n}\n```\n\n\n\n```js\n// backend/src/dto/user/create-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class CreateUserDto extends BaseUser {\n  createdAt: Date;\n}\n```\n\n```js\n// backend/src/dto/user/update-user.dto.ts\n```\n\n```js\nimport { BaseUser } from \"./base-user.dto\";\nexport class UpdateUserDto extends BaseUser {\n  updatedAt: Date;\n}\n```\n\n\n\n## 4. 사용자 엔티티 구현\n\n엔티티란 TypeScript 클래스 또는 오브젝트를 가리키며 데이터베이스 테이블이나 문서의 모델을 나타냅니다. 엔티티는 TypeORM이나 Sequelize와 같은 ORM 라이브러리와 함께 사용되어 데이터베이스와 상호 작용합니다. 엔티티는 데이터 구조를 정의하며 주로 데이터베이스 테이블의 직접적인 표현입니다.\n\n```js\n// backend/src/entities/user.entity.ts\n```\n\n```js\nimport { Column, Entity, ObjectId, ObjectIdColumn } from 'typeorm';\n@Entity()\nexport class UserEntity {\n  @ObjectIdColumn()\n  id: ObjectId;\n  @Column()\n  username: string;\n  @Column()\n  email: string;\n  @Column()\n  password: string;\n  @Column()\n  createdAt: Date;\n  @Column()\n  updatedAt: Date;\n}\n```\n\n\n\n**사용자 클래스**는 **@Entity 데코레이터**로 표시되어 엔티티를 나타낸다는 것을 나타냅니다. 클래스 속성 (id, username, email, password, confirmPassword, createdAt, updatedAt)은 @PrimaryGeneratedColumn 및 @Column과 같은 데코레이터로 주석이 달려 있어 데이터베이스 스키마에서의 역할을 지정합니다.\n\n## 5. Auth Controller 구현\n\n이 NestJS 컨트롤러, **AuthController**,는 인증 관련 HTTP 요청을 처리합니다. 라우트 처리를 위해 데코레이터를 활용하고, 설명서를 위해 Swagger를 통합하며, 타입 확인을 위해 DTO를 사용합니다. **@Public 데코레이터**는 특정 엔드포인트가 인증을 요구하지 않는 것을 나타내며, **AuthService**는 실제 인증 로직을 담당합니다.\n\n```js\n// backend/src/modules/auth/auth.controller.ts\n```\n\n\n\n\n## 6. 인증 모듈 구현\n\n이 NestJS 모듈인 AuthModule은 컨트롤러, 서비스 및 가드를 포함한 인증 관련 컴포넌트를 캡슐화하고 조직화하기 위해 설계되었습니다. 전반적으로, AuthModule은 코드 조직화를 촉진하고 재사용성을 촉진하며 인증 관련 컴포넌트를 관리하는 중앙 모듈로 작용합니다. 가드, 서비스의 사용 및 JwtModule 및 TypeOrmModule과 같은 외부 모듈의 구성은 NestJS에서 모듈화되고 확장 가능한 애플리케이션 아키텍처에 가장 적합한 방법을 따릅니다.\n\n```js\n// backend/src/modules/auth/auth.module.ts\n```\n\n\n\n```js\nimport { Module } from '@nestjs/common';\nimport { AuthController } from './auth.controller';\nimport { AuthService } from './auth.service';\nimport { UsersModule } from '../users/users.module';\nimport { JwtModule } from '@nestjs/jwt';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\nimport { jwtConstants } from './constants';\nimport { APP_GUARD } from '@nestjs/core';\nimport { AuthGuard } from './auth.guard';\n@Module({\n  imports: [\n    UsersModule,\n    JwtModule.register({\n      global: true,\n      secret: jwtConstants.secret,\n      signOptions: { expiresIn: '1d' },\n    }),\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n  controllers: [AuthController],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: AuthGuard,\n    },\n    AuthService\n  ],\n  exports: [AuthService]\n})\nexport class AuthModule {}\n```\n\n- JwtModule: JwtModule을 구성하고 가져와서 JSON Web Tokens (JWT)을 다루는 데 사용되며 비밀 및 만료 시간과 같은 지정된 옵션을 제공합니다.\n- TypeOrmModule.forFeature([UserEntity]): TypeORM을 구성하여 모듈 내에서 UserEntity를 제공하도록 설정합니다.\n- 'provide: APP_GUARD, useClass: AuthGuard': APP_GUARD 토큰을 사용하여 AuthGuard를 글로벌 가드로 등록합니다. 해당 가드는 JWT 토큰을 유효성 검사하고 사용자의 인증 상태를 보장하는 역할을 합니다.\n- AuthService: 해당 모듈 내에서 제공자로 AuthService를 등록합니다. 해당 서비스는 사용자 인증을 위한 비즈니스 로직을 포함하고 있을 것입니다.\n\n## 7. 인증 가드 구현:\n\nNestJS의 AuthGuard 클래스는 애플리케이션 내의 루트를 보호하기 위한 사용자 정의 인증 가드를 구현하는 역할을 합니다. 이 AuthGuard는 미들웨어로 사용되어 인증이 필요한 루트를 보호합니다. 루트의 메타데이터를 확인하고 JWT 토큰을 유효성 검사함으로써, 애플리케이션의 특정 부분에만 인증된 사용자만 접근하도록 보장합니다. 또한, 사용자 페이로드는 편리하게 요청 객체에 첨부되어 라우트 핸들러에서 추가 처리를 위해 사용됩니다.```\n\n\n\n```js\n// backend/src/modules/auth/auth.guard.ts\n```\n\n```js\nimport {\n  CanActivate,\n  ExecutionContext,\n  Injectable,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { jwtConstants } from './constants';\nimport { Request } from 'express';\nimport { Reflector } from '@nestjs/core';\nimport { IS_PUBLIC_KEY } from './public-strategy';\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private jwtService: JwtService, private reflector: Reflector) {}\n  async canActivate(context: ExecutionContext): Promise\u003cboolean\u003e {\n    const isPublic = this.reflector.getAllAndOverride\u003cboolean\u003e(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    if (isPublic) {\n      return true;\n    }\n    const request = context.switchToHttp().getRequest();\n    const token = this.extractTokenFromHeader(request);\n    if (!token) {\n      throw new UnauthorizedException();\n    }\n    try {\n      const payload = await this.jwtService.verifyAsync(\n        token,\n        {\n          secret: jwtConstants.secret\n        }\n      );\n      // 💡 We're assigning the payload to the request object here\n      // so that we can access it in our route handlers\n      request['user'] = payload;\n    } catch {\n      throw new UnauthorizedException();\n    }\n    return true;\n  }\n  private extractTokenFromHeader(request: Request): string | undefined {\n    const [type, token] = request.headers.authorization?.split(' ') ?? [];\n    return type === 'Bearer' ? token : undefined;\n  }\n}\n```\n\n## 8. Auth Service 구현\n\nNestJS 애플리케이션에서 이 AuthService 클래스는 사용자 인증 및 가입 프로세스를 처리하는 역할을 담당합니다.```\n\n\n\n\n\n```js\n// backend/src/modules/auth/auth.service.ts\n```\n\n```js\nimport { Injectable, UnauthorizedException } from \"@nestjs/common\";\nimport { UsersService } from \"../users/users.service\";\nimport { JwtService } from '@nestjs/jwt';\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\n@Injectable()\nexport class AuthService {\n  constructor(private usersService: UsersService, private jwtService: JwtService) {}\n  async signIn(email, pass) {\n    const user = await this.usersService.findOneBy(email);\n    if (user?.password !== pass) {\n      throw new UnauthorizedException();\n    }\n    const payload = { sub: user.id, email: user.email };\n    return {\n      access_token: await this.jwtService.signAsync(payload),\n    };\n  }\n  async signUp(payload: CreateUserDto) {\n    const user = await this.usersService.create(payload);\n    return user;\n  }\n}\n```\n\n## 9. JWT 사용하여 비밀 키를 보관하는 상수 구현\n\nJWT 기반 인증에서, 비밀 키는 토큰의 무결성과 신뢰성을 보장하기 위해 사용되는 중요한 정보입니다. 이는 토큰을 발급하는 서버와 토큰을 유효성을 검증하는 서버 또는 클라이언트 사이에서 공유되는 비밀 키로 작용합니다.```\n\n\n\n```js\n// backend/src/modules/auth/constants.ts\n```\n\n```js\nexport const jwtConstants = {\n  secret: \"JWTSecret#@!\",\n};\n```\n\n## 10: Implement Public Strategy\n\n이 전략은 AuthModule에서 위에서 AuthGuard를 사용하여 전역 인증을 활성화했기 때문에 인증이 필요하지 않음을 나타내는 루트 또는 핸들러를 표시하는 유틸리티를 정의합니다. route 또는 핸들러에 메타데이터를 첨부하기 위해 @nestjs/common 모듈에서 SetMetadata 함수를 사용합니다.```\n\n\n\n```js\n// backend/src/modules/auth/public-strategy.ts\n```\n\n```js\nimport { SetMetadata } from '@nestjs/common';\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const Public = () =\u003e SetMetadata(IS_PUBLIC_KEY, true);\n```\n\n## 11. 사용자 모듈 구현\n\n이 모듈인 UsersModule은 응용 프로그램 내에서 사용자 관리와 관련된 기능을 구성하고 제공하는 데 전념합니다.\n\n\n\n```js\n// backend/src/modules/users/users.module.ts\n```\n\n```js\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from 'src/entities/user.entity';\n\n@Module({\n  providers: [UsersService],\n  exports: [UsersService],\n  imports: [\n    TypeOrmModule.forFeature([UserEntity]),\n  ],\n})\nexport class UsersModule {}\n```\n\n- providers 배열: UsersService를 providers 배열에 포함합니다. 이는 UsersService가 모듈 전반에 걸쳐 injectable하게 만듭니다.\n\n2. exports 배열: UsersService를 exports 배열에 추가합니다. 즉, UsersModule을 import하는 다른 모듈에서 UsersService를 사용할 수 있습니다.\n  \n\n\n\n3. `imports` 배열: Utilizes `TypeOrmModule.forFeature([UserEntity])`를 사용하여 UserEntity를 모듈에 import합니다. 이를 통해 UserEntity와 관련된 TypeORM 기능에 액세스할 수 있습니다.\n\n## 12. 사용자 서비스 구현\n\nUsersService는 사용자 관련 데이터와 상호 작용하는 데 책임이 있으며, 이메일로 사용자를 찾거나 새 사용자를 생성하는 메서드를 제공합니다. 이 서비스에서 `@InjectRepository(UserEntity)`를 사용하여 MongoRepository`UserEntity`를 서비스에 주입합니다. 이 저장소는 UserEntity와 관련이 있으며 데이터베이스 상호 작용을 위한 메서드를 제공합니다.\n\n```js\n// backend/src/modules/users/users.service.ts\n```\n\n\n\n```js\nimport { Injectable } from \"@nestjs/common\";\nimport { InjectRepository } from \"@nestjs/typeorm\";\nimport { BaseUser } from \"src/dto/user/base-user.dto\";\nimport { CreateUserDto } from \"src/dto/user/create-user.dto\";\nimport { UserEntity } from \"src/entities/user.entity\";\nimport { MongoRepository } from \"typeorm\";\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(UserEntity)\n    private userRepository: MongoRepository\u003cUserEntity\u003e,\n) { }\n  async findOneBy(email: string): Promise\u003cUserEntity | undefined\u003e {\n    return await this.userRepository.findOneBy({ email: email });\n  }\n  async create(createUserDto: CreateUserDto) {\n    return this.userRepository.save({\n        ...createUserDto,\n        createdAt: new Date(),\n    });\n  }\n}\n```\n\nUsersService는 사용자 관련 작업에 대한 로직을 캡슐화하여 사용자 데이터와 상호 작용하는 깔끔하고 모듈식 방법을 제공합니다. 리포지토리 사용, 의존성 주입, 그리고 TypeORM과의 통합은 NestJS로 확장 가능하고 유지보수 가능한 애플리케이션을 구축하기 위한 모범 사례와 일치합니다.\n\n## Swagger에 따라 모든 것이 잘 설정되었습니다 😜:\n\n\u003cimg src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_1.png\" /\u003e\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_2.png\" /\u003e\n\n## 참고자료:","ogImage":{"url":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png"},"coverImage":"/assets/img/2024-05-14-ADetailedGuideonImplementingAuthenticationinNestJS_0.png","tag":["Tech"],"readingTime":11},{"title":"JavaScript 제너레이터에 대해 두렵지 마세요","description":"","date":"2024-05-14 14:20","slug":"2024-05-14-DontBeAfraidofJavaScriptGenerators","content":"\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png)\n\n솔직히 말해봅시다: 제너레이터를 사용한 코드를 얼마나 자주 만나게 되나요?\n\n매일 다양한 개발자들의 코드를 검토하지만, 제너레이터를 거의 만나지 못합니다.\n\n그 이유는 무엇일까요?\n\n\n\n사람들은 이해하지 못하나요? 아니면 혜택을 못 보는 건가요?\n\nJavaScript는 유연성과 폭넓은 기능으로 유명한데요, ECMAScript 2015에서 독특한 도구인 제너레이터를 소개했습니다. 이들은 비동기 프로그래밍을 제어하고, 반복 가능한 객체를 생성하며, 여러 값을 반환하는 강력한 수단입니다. 이 안내서에서는 제너레이터의 동작 방식, 적용 분야, 그리고 어떻게 잠재력을 활용할 수 있는지 배워볼 거에요.\n\n# 제너레이터란 무엇인가요?\n\n제너레이터는 전통적인 함수와 다릅니다. 그들은 실행을 여러 번 시작하고 중단할 수 있어요. 이는 여러 값을 반환하고 나중에 실행을 계속할 수 있게 해주어 비동기 작업을 관리하거나, 반복자를 생성하거나, 끝없는 데이터 스트림을 처리하는 데 완벽한 방법입니다.\n\n\n\n생성기는 function* 구문으로 구분됩니다. 다음 기본 예제를 살펴보세요:\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n```\n\n여기서 yield는 값을 반환하고 생성기의 실행을 일시 중단합니다. 각 호출마다, 생성기는 그 다음 값을 반환합니다.\n\n# 생성기 객체와 상호 작용하기\n\n\n\n제너레이터 함수를 호출하면 해당 바디가 직접 실행되지 않습니다. 대신, 실행을 제어할 수 있는 제너레이터 객체가 생성됩니다. 이 객체는 순회 가능하므로 for...of 루프 및 유사한 작업에 적합합니다.\n\n제너레이터 객체를 살펴봅시다:\n\n- next(): 이 메소드는 제너레이터를 다시 시작하고, 다음으로 순회된 값을 반환하며, 제너레이터가 완료되었는지(done 속성으로 확인합니다.\n이전에 작성한 generateSequence 예제를 사용하여:\n\n```js\nconsole.log(generator.next()); // { value: 1, done: false }\n```\n\n\n\n- return(): 이 메서드는 generator를 일찍 종료시키며, 마치 return 명령을 실행한 것처럼 동작합니다.\n\n```js\nconsole.log(numbers.return(100)); // { value: 100, done: true }\n```\n\n- throw(): 이 메서드는 오류를 삽입할 수 있게 해주며, generator 내부에서 오류 처리를 간편하게 할 수 있습니다.\n\n```js\nfunction* generateTasks() {\n  try {\n    yield \"작업 시작\";\n    yield \"작업 진행 중\";\n    yield \"작업 거의 완료\";\n  } catch (error) {\n    console.log('문제 발생:', error.message);\n  }\n}\n\nconst tasks = generateTasks();\n\nconsole.log(tasks.next().value); // 출력: \"작업 시작\"\nconsole.log(tasks.next().value); // 출력: \"작업 진행 중\"\ntasks.throw(new Error('이런! 문제가 발생했어요.')); \n// 출력: \"문제 발생: 이런! 문제가 발생했어요.\"\nconsole.log(tasks.next()); // 출력: { value: undefined, done: true }\n```\n\n\n\n위의 예제에서는 next() 메서드를 사용하여 몇 가지 작업을 시작한 후 throw() 메서드를 사용하여 오류를 발생시킵니다. 제너레이터는 try-catch 블록 덕분에이 오류를 캡처하여 오류 메시지를 기록하고 오류 시나리오를 단호하게 처리합니다.\n\n# 무한 데이터 스트림을 위한 제너레이터 활용\n\n제너레이터는 무한 데이터 스트림을 처리하는 데 뛰어납니다. 요청 시에만 값을 생성하는 잠재적으로 끝없는 데이터 구조를 설계할 수 있습니다. 웹 애플리케이션에서의 무한 스크롤링과 같은 상황을 생각해보세요.\n\n```js\nfunction* infiniteNumbers() {\n  let index = 0;\n  while (true) {\n    yield index++;\n  }\n}\n```\n\n\n\nI confess, while(true) could scare anyone at first glance, but that is the magic of generators.\n\n# Synchronous and Asynchronous Iteration with Generators\n\nWhen blended with promises, generators can emulate the async/await pattern, offering a neater, more intuitive method to draft asynchronous code. To illustrate, let’s fetch data using a generator:\n\n```js\nfunction* fetchData() {\n  const users = yield fetch('https://api.example.com/users');\n  console.log('Users:', users);\n  // ...\n}\n```\n\n\n\n# 제너레이터의 고급 활용\n\nasync/await는 간단한 비동기 작업에 유용하지만, 다양한 기능을 제공하는 제너레이터는 더 다양한 가능성을 제공합니다.\n\n- 제너레이터 조합: 이를 통해 여러 개의 제너레이터를 매끄럽게 통합하여 복잡한 값 시퀀스를 만들 수 있습니다.\n\n```js\nfunction* generateSequence() {\n  yield* generateNumbers();\n  yield* generateCharacters('A', 'Z');\n}\n```\n\n\n\n- 무한 생성기: 생성기는 무한한 값 시퀀스를 생성할 수 있어 연속 데이터 스트림이나 무한한 알고리즘에 이상적입니다. 위의 while (true)을 기억하시나요?\n\n# 실세계 시나리오 (업데이트): 무한 스크롤\n\n![이미지](/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_1.png)\n\n자바스크립트 생성기에 대한 중요하고 실용적인 응용 프로그램을 개념화하는 것이 어려울 수 있습니다. 그러나 생성기는 비동기 코드와 매끄럽게 통합되며 무한한 반복을 지원하는 등 다양한 기능을 제공합니다. 예시를 살펴보죠.\n\n\n\n하단에 제시된 코드는 순수히 예시로 제시된 것입니다. 실제로 사용할 준비가 된 코드는 다양한 예외 상황을 처리해야 합니다.\n\n무한 스크롤을 지원하는 소셜 미디어 피드를 구성하는 것을 제안합니다. 다시 말해, 사용자가 목록의 끝까지 스크롤하면 추가적인 게시물이 가져와서 피드에 추가됩니다.\n\n두 번째 주의: 제너레이터는 한 가지 접근법을 제공하지만, JavaScript 생태계에서 단독적인 것은 아닙니다. 비슷한 결과를 얻기 위한 대체 방법이 있습니다. 그럼에도 불구하고, 학습을 위해 사용자가 스크롤할 때 게시물을 계속해서 가져오는 메커니즘을 구성해보겠습니다.\n\n먼저, 데이터를 담을 기본적인 HTML/CSS 구조를 설정해보겠습니다. 실험해보고 싶다면 사용하실 수 있습니다:\n\n\n\n```js\r\n// CSS 코드\n.post {\n  height: 300px;\n}\n\n// HTML 코드\n\u003cdiv id=\"postsContainer\"\u003e\n  \n\u003c/div\u003e\r\n```\n\n다음은 \"10개의 게시물\"을 가져오기 위해 설계된 스크립트를 검토할 것입니다. 사용자가 스크롤하고 페이지 끝에 가까워지면 생성기가 작동하여 다음 10개의 게시물을 가져올 것입니다:\n\n```js\r\n// 일반 `fetch`를 대체하기 위한 것일 뿐입니다\n// 10개의 게시물을 생성하고 반환합니다\nasync function simulatedFetch(currentPage) {\n  const posts = Array.from({ length: 10 }, (_, i) =\u003e ({ content: `포스트 - ${currentPage}${i}` }));\n  return Promise.resolve(posts)\n}\n\nasync function* paginatedFetcher(apiUrl, itemsPerPage) {\n    let currentPage = 0;\n\n    while (true) {\n        // 현실적인 경우에 대한 주석\n        // const response = await fetch(`${apiUrl}?page=${currentPage}\u0026limit=${itemsPerPage}`);\n        const response = await simulatedFetch(currentPage)\n      \n        // const posts = await response.json();\n        const posts = response;\n      \n        if (posts.length === 0) {\n            return;  // 데이터의 끝\n        }\n      \n        yield posts;\n        currentPage++;\n    }\n}\n\n// 무한 스크롤과 함께 사용:\n// API는 설명적인 역할로 실제 사용되지는 않습니다\nconst getPosts = paginatedFetcher('https://api.example.com/posts', 10);\n\n// DOM에 게시물을 표시하는 함수\nfunction displayPosts(posts) {\n  const container = document.getElementById('postsContainer');\n    posts.forEach(post =\u003e {\n        const postElement = document.createElement('div');\n        postElement.className = 'post';\n        postElement.innerText = post.content;\n        container.appendChild(postElement);\n    });\n}\n\n// 무한 스크롤 로직\nwindow.onscroll = async function() {\n    if ((window.innerHeight + window.scrollY) \u003e= document.body.offsetHeight) {\n        const { value } = await getPosts.next();\n        if (value) {\n            displayPosts(value);\n        }\n    }\n};\n\n// 초기 데이터 가져오기\n(async () =\u003e {\n    const { value } = await getPosts.next();\n    displayPosts(value);\n})();\r\n```\n\n# 결론\n\n\n\nJavaScript에서의 생성기들은 그저 새로운 것뿐만이 아니라, 비동기 작업을 다루는 데 중요하며, 반복 가능한 객체를 만드는 데도 중요합니다.\n\n다음에 데이터를 실시간으로 관리해야 할 때, 생성기를 사용하기 주저하지 마세요.\n\n실제 시나리오에서 생성기를 효과적으로 활용한 경험이 있다면 공유해 주세요. 더 많은 예시를 만나면, 어디에 활용하는 게 가장 적절한지 더 쉽게 알 수 있을 거예요.\n\n저와 소통하세요! 저는 아래에서 찾을 수 있어요:\n- Medium: https://medium.com/@yuribett\n- Linkedin: https://www.linkedin.com/in/yuribett/\n- X (formerly Twitter): https://twitter.com/yuribett\n\n\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 향한 박수와 팔로우를 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 저희를 팔로우해 주세요.\n- 세계적으로 프로그래밍 교육을 민주화하는 Stackademic.com에서 더 많은 정보를 찾아보세요.","ogImage":{"url":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png"},"coverImage":"/assets/img/2024-05-14-DontBeAfraidofJavaScriptGenerators_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular 17에서 Role-Based Access Control RBAC 구현하기","description":"","date":"2024-05-14 14:19","slug":"2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png\" /\u003e\n\n앵귤러 17 애플리케이션에서 Role-Based Access Control (RBAC)을 구현하는 것에는 특정 경로 및 기능에만 인가된 사용자가 액세스할 수 있도록 여러 단계를 거쳐야 합니다. 앵귤러 17은 서비스, 가드, 지시문과 같은 Angular의 핵심 기능을 사용하여 이러한 시나리오를 처리합니다.\n\n여기에는 여러 부분으로 나뉘어진 완전한 예제가 있습니다:\n\n# 1. 앵귤러 프로젝트 설정\n\n\n\n먼저 Angular CLI가 설치되었는지 확인하세요:\n\n```js\nnpm install -g @angular/cli\n```\n\n새로운 Angular 프로젝트를 생성하세요:\n\n```js\nng new angular-rbac --routing=true --style=css\ncd angular-rbac\n``` \n\n\n\n# 2. 인증 모의 서비스\n\n사용자 로그인을 관리하고 역할을 저장하는 간단한 인증 서비스를 만들어보세요.\n\n```js\nng generate service auth\n```\n\nauth.service.ts를 편집하세요.\n\n\n\n```js\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nexport interface User {\n  username: string;\n  roles: string[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private currentUserSubject: BehaviorSubject\u003cUser | null\u003e;\n  public currentUser: Observable\u003cUser | null\u003e;\n\n  constructor() {\n    this.currentUserSubject = new BehaviorSubject\u003cUser | null\u003e(null);\n    this.currentUser = this.currentUserSubject.asObservable();\n  }\n\n  login(username: string, password: string): void {\n    // 데모용으로, 인증이 성공했다고 가정합니다.\n    const user: User = {\n      username: username,\n      roles: username === 'admin' ? ['admin', 'user'] : ['user'],\n    };\n    this.currentUserSubject.next(user);\n  }\n\n  logout(): void {\n    this.currentUserSubject.next(null);\n  }\n\n  public get currentUserValue(): User | null {\n    return this.currentUserSubject.value;\n  }\n\n  public isAuthorized(allowedRoles: string[]): boolean {\n    const user = this.currentUserValue;\n    if (!user) return false;\n    return user.roles.some(role =\u003e allowedRoles.includes(role));\n  }\n}\n```\n\n# 3. 라우트 보호를 위한 인증 가드\n\n사용자 역할에 따라 라우트를 보호하는 가드를 생성하세요.\n\n```js\nng generate guard auth\n```\n\n\n\nEdit the auth.guard.ts:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot): Observable\u003cboolean | UrlTree\u003e | Promise\u003cboolean | UrlTree\u003e | boolean | UrlTree {\n    const allowedRoles = next.data['roles'] as string[];\n    if (this.authService.isAuthorized(allowedRoles)) {\n      return true;\n    }\n\n    // Redirect to the login page or some other route\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n```\n\n# 4. Setup Routes with Role Protections\n\nEdit the app-routing.module.ts to define roles required for each route:\n\n\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { LoginComponent } from './login/login.component';\nimport { UserComponent } from './user/user.component';\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  { path: 'login', component: LoginComponent },\n  { path: 'admin', component: AdminComponent, canActivate: [AuthGuard], data: { roles: ['admin'] } },\n  { path: 'user', component: UserComponent, canActivate: [AuthGuard], data: { roles: ['user', 'admin'] } }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n# 5. Create Components for Each Route\n\n```js\nng generate component login\nng generate component admin\nng generate component user\n```\n\n각 컴포넌트는 필요에 따라 기본 정보 또는 양식을 렌더링하는 간단한 구조여야 합니다.```\n\n\n\n# 6. 로그인 기능 구현하기\n\n사용자 로그인을 처리하기 위해 login.component.ts를 업데이트하세요:\n\n```js\nimport { Component } from '@angular/core';\nimport { AuthService } from '../auth.service';\n\n@Component({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n  username: string = '';\n  password: string = '';\n\n  constructor(private authService: AuthService) { }\n\n  login(): void {\n    this.authService.login(this.username, this.password);\n  }\n}\n```\n\n# 7. 어플리케이션 테스트하기\n\n\n\nAngular 개발 서버를 실행해주세요:\n\n```js\nng serve\n```\n\nhttp://localhost:4200 으로 이동하여 다른 사용자로 로그인하여 다양한 경로를 테스트해보세요.\n\n이 설정은 Angular 17 애플리케이션에서 역할 기반 액세스를 위한 기본적인 프레임워크를 제공합니다. 실제 백엔드 통합, 토큰 기반 인증 처리, 그리고 더 정교한 사용자 관리 기능을 추가함으로써 더 확장시킬 수 있습니다.\n\n\n\n감사합니다\n\n찬단","ogImage":{"url":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinanAngular17_0.png","tag":["Tech"],"readingTime":5},{"title":"JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기","description":"","date":"2024-05-14 14:17","slug":"2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png\" /\u003e\n\n우리 스타트업은 아이들이 화면에서 색칠된 템플릿을 생동감있게 만들 수 있게 해줘. 종이에 색칠된 템플릿을 업로드하여 디지털 세계를 구축하는 것만으로도 흥미로운 경험이지만, 우리는 아이들에게 추가로 동물에 대한 목소리를 녹음할 기회를 주고 싶었어.\n\n\u003cimg src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_1.png\" /\u003e\n\n## 문제\n\n\n\n작업한 것을 기록합니다. 음성 녹음을 위한 MediaRecorder API 부분은 간단했지만, 업로드한 오디오 파일이 재생되지 않거나 손상된 것으로 보였습니다. 이는 브라우저가 mp3 또는 wav로 오디오를 기록하지 않고 webm으로 기록하기 때문입니다 (적어도 Chrome에서).\n\n우리가 할 일:\n\n- wav로 오디오 녹음\n- wav를 mp3로 변환\n- 오디오 파일을 서버에 업로드\n- 로컬 디스크 또는 S3에 파일 저장\n\n# 오디오 변환을 wav로 변경\n\n\n\n최종적으로 녹음을 mp3 파일로 변환하려면 먼저 wav 형식으로 변환해야 했습니다. 이를 위해 기본 MediaRecorder의 대체물인 확장 가능한 drop-in MediaRecorder인 chrisguttandin/extendable-media-recorder 라이브러리를 사용했습니다.\n\n다음과 같이 설치하세요:\n\n```js\nnpm install extendable-media-recorder\n```\n\n# 오디오 녹음\n\n\n\ngetUserMedia를 사용하여 오디오를 녹음하는 방법에 대한 많은 안내서가 있어요. 저는 간단하게 유효한 mp3 또는 wav 오디오 파일을 만드는 핵심 부분을 다룰 거에요.\n\n```js\nimport {MediaRecorder, register} from 'extendable-media-recorder';\nimport {connect} from 'extendable-media-recorder-wav-encoder';\n\nlet mediaRecorder = null;\nlet audioBlobs = [];\nlet capturedStream = null;\n\n// extendable-media-recorder-wav-encoder를 등록합니다.\nasync function connect() {\n  await register(await connect());\n}\n\n// 오디오 녹음을 시작합니다.\nfunction startRecording() {\n\n  return navigator.mediaDevices.getUserMedia({\n    audio: {\n      echoCancellation: true,\n    }\n  }).then(stream =\u003e {\n      audioBlobs = [];\n      capturedStream = stream;\n\n      // 확장된 MediaRecorder 라이브러리를 사용합니다.\n      mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/wav'\n      });\n\n      // 녹음 중 오디오 블롭을 추가합니다.\n      mediaRecorder.addEventListener('dataavailable', event =\u003e {\n        audioBlobs.push(event.data);\n      });\n\n      mediaRecorder.start();\n  }).catch((e) =\u003e {\n    console.error(e);\n  });\n\n}\n```\n\n그리고 녹음을 중지하는 함수:\n\n```js\nfunction stopRecording() {\n  return new Promise(resolve =\u003e {\n    if (!mediaRecorder) {\n      resolve(null);\n      return;\n    }\n\n    mediaRecorder.addEventListener('stop', () =\u003e {\n      const mimeType = mediaRecorder.mimeType;\n      const audioBlob = new Blob(audioBlobs, { type: mimeType });\n\n      if (capturedStream) {\n        capturedStream.getTracks().forEach(track =\u003e track.stop());\n      }\n\n      resolve(audioBlob);\n    });\n    \n    mediaRecorder.stop();\n    \n  });\n}\n```\n\n\n\n브라우저에서 오디오를 재생하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\n playAudio(audioBlob) {\n  if (audioBlob) {\n    const audio = new Audio();\n    audio.src = URL.createObjectURL(audioBlob);\n    audio.play();\n  }\n}\n```\n\n# Wav를 mp3로 변환\n\nWav를 mp3로 변환하기 위해 lamejs 라이브러리를 사용했어요:\n\n\n\n설치\n\n```js\nnpm install @breezystack/lamejs\n```\n\n이제 `convertWavToMp3` 함수를 만들고 녹음된 오디오Blob을 전달하여 mp3 Blob을 얻을 수 있습니다.\n\n```js\nimport * as lamejs from '@breezystack/lamejs';\n\nconvertWavToMp3(wavBlob) {\n  return new Promise((resolve, reject) =\u003e {\n    const reader = new FileReader();\n\n    reader.onload = function () {\n      const arrayBuffer = this.result;\n\n      // WAV 디코더 생성\n      // @ts-expect-error - 무슨 일인지 모르겠어요\n      const wavDecoder = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));\n\n      // WAV 오디오 데이터를 샘플 배열로 가져옴\n      const wavSamples = new Int16Array(arrayBuffer as ArrayBuffer, wavDecoder.dataOffset, wavDecoder.dataLen / 2);\n\n      // MP3 인코더 생성\n      const mp3Encoder = new lamejs.Mp3Encoder(wavDecoder.channels, wavDecoder.sampleRate, 128);\n\n      // WAV 샘플을 MP3로 인코딩\n      const mp3Buffer = mp3Encoder.encodeBuffer(wavSamples);\n\n      // MP3 인코딩 완료\n      const mp3Data = mp3Encoder.flush();\n\n      // MP3 헤더와 데이터를 새로운 ArrayBuffer로 결합\n      const mp3BufferWithHeader = new Uint8Array(mp3Buffer.length + mp3Data.length);\n      mp3BufferWithHeader.set(mp3Buffer, 0);\n      mp3BufferWithHeader.set(mp3Data, mp3Buffer.length);\n\n      // ArrayBuffer에서 Blob 생성\n      const mp3Blob = new Blob([mp3BufferWithHeader], { type: 'audio/mp3' });\n\n      resolve(mp3Blob);\n    };\n\n    reader.onerror = function (error) {\n      reject(error);\n    };\n\n    // 입력 Blob을 ArrayBuffer로 읽기\n    reader.readAsArrayBuffer(wavBlob);\n  });\n}\n```\n\n\n\n# 파일 업로드\n\n파일 업로드는 상당히 쉬운 부분이며 코드를 통해 자세하게 설명할 수 있어서 매우 쉽게 이해할 수 있을 겁니다:\n\n```js\n/**\n * 오디오 blob을 서버에 업로드합니다\n * @params {Blob} audioBlob - 오디오 blob 데이터\n * @params {string} fileType - 'mp3' 또는 'wav'\n * @return {Promise\u003cobject\u003e}\n */\nfunction uploadBlob(audioBlob, fileType) {\n  const formData = new FormData();\n  formData.append('audio_data', audioBlob, 'file');\n  formData.append('type', fileType || 'mp3');\n\n  // 오디오를 업로드하기 위한 서버 엔드포인트:\n  const apiUrl = \"http://localhost:3000/upload/audio\";\n\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    cache: 'no-cache',\n    body: formData\n  });\n\n  return response.json();\n}\n```\n\n# 전부 함께\n\n\n\n위의 모든 함수를 함께 사용하는 빠른 예제:\n\n```js\n// 초기화\nawait connect();\n\n// 사용자가 녹음 버튼을 클릭함\nstartRecording();\n\n// 사용자가 정지 버튼을 클릭하거나 정의된 시간 초과\nconst wavAudioBlob = await stopRecording();\n\n// 재미로: 재생\nplayAudio(wavAudioBlob);\n\n// mp3로 변환\n// 참고: mp3는 Chrome 및 Firefox에서만 작동했습니다\n// Safari는 이에 대한 호감을 잃어 보였으므로 Safari에는 .wav를 업로드했습니다\nconst mp3Blob = await convertWavToMp3(wavAudioBlob);\n\n// 서버에 블랍 업로드\nconst response = await uploadBlob(mp3Blob, 'mp3');\n```\n\ntry/catch를 사용하고 일부 변수가 null인지 확인하는 것이 좋습니다.\n\n# 파일 저장 — Flask\n\n\n\n오디오 파일을 엔드포인트에 POST한 후에는 저장을 원할 것입니다. Python Flask에서 파일을 로컬로 저장하거나 S3 버킷에 저장하는 방법을 보여드릴게요. 다른 언어(NodeJS, PHP 등)에서도 비슷하게 적용할 수 있어요.\n\n```js\ndef uploadAudio(request):\n\n  # 파라미터 가져오기\n  audio_file = request.files.get('audio_data')\n  file_type = request.form.get(\"type\", \"mp3\")\n  \n  # 파일명에 UUID 생성하는 것을 고려할 수 있어요\n  filename = \"myAudioFile.\" + file_type\n  \n  # 로컬 디스크에 저장하기\n  target_path = (\"your/local/dir/%s\" % filename)\n  audio_file.save(target_path)\n\n  # 또는: AWS S3에 파일 저장하기\n  session = boto3.Session(\"\"\" API 인증 정보 \"\"\")\n  s3 = session.resource('s3')\n  bucket = s3.Bucket(\"your-bucket-name\")\n  destination_dir = \"audiofiles/\"\n  response = bucket.upload_fileobj(audio_file, destination_dir, ExtraArgs={\n    \"ContentType\": \"audio/\" + file_type\n  })\n```\n\n버그를 발견하거나 개선 제안이 있다면 댓글로 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png"},"coverImage":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png","tag":["Tech"],"readingTime":6},{"title":"더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들","description":"","date":"2024-05-14 14:16","slug":"2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity","content":"\n\n![Chrome DevTools JavaScript Debugging Features for Better Productivity](/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png)\n\n소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.\n\n현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).\n\n생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!\n\n\n\n# 변수와 표현식 감시하기\n\n디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.\n\nDevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if(s === 60) {\n    m++;\n    s = 0;\n  }\n}, 1000);\n```\n\n\n\n위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif)\n\n매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif)\n\n\n\n# 콘솔에서 디버거 컨텍스트 사용하기\n\n우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:\n\n```js\nfunction getMagicDate(d) {\n  if(d.getDate() % 2 === 0) {\n    d.setDate(d.getDate() + 2);\n  }\n  else {\n    d.setMonth(d.getMonth() + 1);\n  }\n  return d;\n}\n\ngetMagicDate(new Date());\n```\n\n먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:\n\n\n\n![Live Expressions](https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif)\n\n# 중단점 없이 실시간 표현식 만들기\n\n첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.\n\n이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:\n\n\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if (s === 60) {\n    m++;\n    s = 0;\n  }\n\n  console.log(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);\n}, 1000);\n```\n\n\n\n# 마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법\n\n자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:\n\n![예제](https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif)\n\n위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.\n\n\n\n우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif\" /\u003e\n\n공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.\n\n다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:\n\n\n\n# 이벤트 리스너 브레이크포인트 설정하기\n\n풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.\n\n다음 코드를 살펴보세요:\n\n```js\nlet btn = document.getElementById('btn');\nlet count = 0;\n\nbtn.addEventListener('click', (e) =\u003e {\n  btn.innerText = `Clicked ${++count} times`;\n});\n```\n\n\n\n우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif)\n\n위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.\n\n다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:\n\n\n\n# 네트워크 요청 중단점 사용하기\n\nXHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:\n\n![네트워크 요청 중단점](https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif)\n\n이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.\n\n\n\n# 호출 스택 검사\n\n개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.\n\n스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif)\n\n\n\n호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:\n\n읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png","tag":["Tech"],"readingTime":6},{"title":"시작하기 JavaScript LLM 앱용 LangSmith","description":"","date":"2024-05-14 14:14","slug":"2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps","content":"\n\n대용량 언어 모델(Large Language Models, LLM)의 파워를 LangSmith와 함께 발휘하세요: 시작부터 끝까지 AI 개발을 최적화해보세요!\n\n대용량 언어 모델(LLM) 위에 챗봇을 구축하고 있다고 상상해보세요. 감정 분석, RAG 검색 또는 문맥 이해와 같은 복잡한 기능을 통합할 때 예기치 않은 오류에 직면합니다. 이러한 문제를 해결하더라도 새로운 도전이 나타나고 앱에 작은 변경 사항이나 LLM의 업데이트로 인해 발생할 수 있습니다. LLM과 작업하면 마법 상자에 연결된 것처럼 느껴지기도 합니다. 때로는 결과가 놀라울 정도로 훌륭하고 때로는 그렇지 않을 수도 있습니다. 그들이 왜 그렇게 행동하는지, 그것이 앱에 어떤 영향을 미치는지 알기 어려울 때가 있습니다.\n\nLangSmith는 개발부터 모니터링까지 LLM 애플리케이션의 전체 라이프사이클을 최적화하는 포괄적인 데브옵스 플랫폼으로 이 문제를 해결합니다. 이 통합은 개발을 단순화하는 것뿐만 아니라 개발자들 사이의 신뢰를 높이고 품질을 보장하며 비용을 관리하고 지연 시간을 줄여, LLM 애플리케이션 개발을 더욱 접근 가능하고 효율적으로 만듭니다.\n\n본 문서에서는 LangSmith가 무엇인지, 왜 사용해야 하는지, 어떻게 사용해야 하는지, 그리고 런 트레이스 기능의 빠른 데모를 진행하겠습니다.\n\n\n\nLangSmith을 사용해야 하는 이유는 무엇일까요?\n\n- 포괄적인 개발 도구: LangSmith는 LLM 애플리케이션을 위한 맞춤형 개발 도구를 제공하여 상세한 호출 순서 가시성, 실시간 디버깅, 및 성능 최적화 기능을 제공합니다.\n- 고급 테스팅 및 평가: 이 플랫폼은 강력한 테스트 프레임워크와 AI 지원 평가를 제공하여 응답의 품질을 보장하며, 관련성, 정확성, 민감성을 포괄합니다.\n- 배포 및 확장성: LangSmith는 리소스 집약적인 LLM 애플리케이션의 배포와 확장을 간소화하여 성능 저하 없이 증가된 부하를 관리합니다.\n- 실시간 모니터링 및 분석: 종합적인 모니터링은 비용, 지연 시간, 품질을 추적하며, 실시간 분석을 통해 신속한 결정을 내릴 수 있도록 지원합니다.\n- 비용 관리: LangSmith는 LLM 프로젝트의 재정 측면을 관리하는 데 도움을 줌으로써 지출을 최적화하고 애플리케이션 효율성을 극대화하는 통찰을 제공합니다.\n- 협업 기능: 이 플랫폼은 공유 작업 공간, 버전 관리, 그리고 커뮤니케이션 도구로 팀워크를 강화하여, 지역 간 원활한 협업을 지원합니다.\n\n# 주요 기능\n\nLangSmith에는 많은 기능이 있으며 새로운 기능을 지속적으로 추가합니다. 여기 몇 가지 주요 기능을 살펴보세요:\n\n\n\n## 실행 추적\n\n추적은 LLM 애플리케이션의 동작을 이해하는 데 도움이 되는 강력한 도구입니다. 추적을 사용하면 예기치 않은 결과나 에이전트가 루프를 도는 이유, 실행이 느린 이유, 비용이 얼마나 드는지, 또는 고객이 최적의 응답을 받지 못하는 이유 등의 문제를 진단할 수 있습니다.\n\n## 주석이 달린 큐\n\n주석이 달린 큐는 데이터를 빠르게 순환하고 주석을 달 수 있는 사용자 친화적인 방법입니다. 사람들이나 LLM이 결과를 평가할 수 있는 워크플로우를 만들 수 있습니다. 이 데이터는 애플리케이션의 테스트 및 개선에 사용될 수 있습니다.\n\n\n\n## 데이터셋 및 테스트\n\n데이터셋은 업로드할 수도 있고 실제 실행에서 파생될 수도 있습니다. 그런 다음 이 데이터를 사용하여 응용 프로그램의 성능과 정확도를 측정하는 평가자를 사용하여 테스트를 실행할 수 있습니다.\n\n## 허브\n\n허브를 사용하면 LLM 프롬프트용 GitHub과 같은 협업, 테스트 및 공유가 가능합니다. 프롬프트를 효과적으로 작성하는 방법을 확인하는 데 도움되는 것뿐만 아니라 프롬프트를 관리하는 훌륭한 방법이기도 합니다.\n\n\n\n이 기사에서는 실시간 디버깅에 대해 자세히 살펴보겠습니다.\n\n# LangChain과 프로젝트 통합\n\nLangChain.js를 사용하여 간단한 앱을 만들었는데, 이는 LangSmith와의 통합 설정에 좋은 시작점을 제공할 것입니다.\n\n- 저장소 복제: git clone git@github.com:kenzic/simple-langsmith-demo.git\n- 의존성 설치: yarn\n- LangSmith 계정 등록\n- API 키 받기\n- OpenAI API 키 받기\n- .env.example을 .env로 이동하고 다음 값을 채워 넣으세요:\n\n\n\n```js\nLANGCHAIN_PROJECT=\"langsmith-demo\"\nLANGCHAIN_TRACING_V2=true\nLANGCHAIN_API_KEY=\u003cyour-api-key\u003e\n\n# OpenAI API를 사용하여 LLM에 호출을 하지만, LangSmith를 사용하는 데 필수적이지는 않습니다\nOPENAI_API_KEY=\u003cyour-openai-api-key\u003e\r\n```\n\n시작하기 전에 코드를 이해하는 데 1 ~ 2분 정도 소요되도록 사전에 시간을 투자해보세요. 이 코드는 높은 수준에서 다음과 같은 작업을 수행합니다:\n\n- 입력값 \"프랑스의 수도는 무엇인가요?\"로 앱을 호출합니다.\n- 대화 검색 체인 (RunnableSequence):\n  - 문서 검색 체인을 호출하여 컨텍스트를 추가합니다. 이는 사용자의 질문에 답변하기 위해 데이터를 가져오는 사용자 지정 검색기를 사용합니다 (RunnableMap).\n  - 문서 검색 체인에서 가져온 컨텍스트를 사용하여 사용자 질문에 대한 LLM 답변을 Mr. Burns의 억양으로 작성하는 프롬프트를 생성합니다 (ChatPromptTemplate).\n  - LLM을 호출합니다 (ChatOpenAI).\n  - 응답을 구문 분석하여 문자열로 반환합니다 (StrOutputParser).\n\n# 실습하기```\n\n\n\n이 기사에서는 아마도 가장 강력한 기능인 실행 추적 및 디버깅 기능에 초점을 맞출 것입니다.\n\n이제 우리 앱을 테스트하고 디버깅할 준비가 되었어요!\n\n다음을 실행하여 시작하십시오: yarn start\n\n스크립트는 앱에 \"프랑스의 수도는 어디인가요?\"라고 묻습니다.\n\n\n\n우리가 받은 결과가 상당히 예상치 못한 것 같아요. 프랑스의 수도가 스프링필드라고 생각하고 있는 것 같아요. 이상하죠.\n\n우리 중 일부는 프랑스의 수도가 스프링필드가 아니라 파리임을 알고 있죠. 그래서 왜 이런 결과를 받는 걸까요? 게다가 앱이 답변을 제대로 주기까지 오래 걸리는 것 같아요. 이 부분을 빨리 처리할 수는 없을까요?\n\nhttps://smith.langchain.com/ 로 이동해서 \"langsmith-demo\" 프로젝트를 클릭해주세요. 프로젝트 내부에 들어가면 실행 기록을 볼 수 있어요. 최근 실행부터 시작해서 무슨 일이 일어나고 있는지 힌트가 있는지 확인해보겠어요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png)\n\n\n\n최상위 수준의 추적 결과 (RunnableSequence)를 살펴보면, 앱이 실행되는 데 3.33초가 걸리고 입력과 출력이 일치함을 볼 수 있지만 출력물은 명백히 잘못되었습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_1.png)\n\n다음 수준인 (RunnableMap)로 이동하면, 앱의 일부분이 LLM이 답변을 안내하는 데 사용할 문맥이나 지식을 검색하는 역할을 살펴볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_2.png)\n\n\n\n여기에서 무슨 일이 일어나고 있는지 빠르게 파악할 수 있어요. 저희 리트리버가 사실과 다른 정보를 제공하고 있네요. 이 데모에서는 \"프랑스의 수도는 파리입니다\"라는 내용으로 문서 내용을 바꿔서 수정할 수 있어요.\n\n쉬웠죠! 하지만 아직 앱이 조금 느린 것 같아요. 왜 그럴까요? 계속 추적해보면 ChatPromptTemplate은 잘 보이고 실행 시간은 0.00초가 걸리므로, 그 부분은 아닌 것 같아요.\n\n![image](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_3.png)\n\n다음으로, ChatOpenAI 단계는 조금 느린데, 인터넷을 통해 요청을 보내고 있기 때문에 예상대로 그럴 수 있어요. 또한 OpenAI에 대한 호출이 총 139개의 토큰을 사용하여 총 $0.0001165를 소비했다는 점을 알려드릴게요. 앱이 더 복잡해지면 이 비용을 이해하기 위해 이 숫자에 주의해야 할 거예요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_4.png\" /\u003e\n\n마침내 StrOutputParser로 이동합니다. 실행 시간이 0.00초이고 출력을 올바르게 구문 분석했으므로 여기서 모든 것이 정상인 것 같습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_5.png\" /\u003e\n\n그래서 앱에서 병목 현상이 어디에 있는지 궁금하신가요? RunnableMap으로 돌아가 봅시다. 이 부분이 2.01초가 걸리는 것을 볼 수 있습니다. 한 개의 하드코딩된 문서를 반환하는 간단한 작업에 대해 이 시간은 높아 보입니다. 코드를 살펴보면 기능 slowLookupTask이 있음을 알 수 있습니다. 이 기능은 데모를 위해 인위적으로 만들어졌지만, 실제 시나리오에서는 검색기가 응용 프로그램의 지연 원인이 될 수 있으며, 종종 제어할 수 있는 부분 중 하나입니다.\n\n\n\n마침내 스크립트를 다시 실행합시다. 어떻게나! 이제 쿼리에 올바른 답변을 받아, 2초를 절약했습니다!\n\n## 다음 단계\n\nLangSmith의 능력의 일부에 불과하지만, 이 짧은 글이 어떤 가능성을 밝혀주기를 바랍니다.\n\nLangSmith의 디버깅 기능을 활용하여 더욱 탐험하면, 그 가능성을 최대로 발휘할 수 있습니다:\n\n\n\n- 고급 테스트 및 평가 도구를 활용하여 응답 품질을 지속적으로 확인합니다.\n- 비용 관리 통찰력을 활용하여 리소스 사용량 및 비용을 최적화합니다.\n- 공동 작업 공간, 버전 관리 및 빠른 라이브러리를 활용하여 협업을 촉진합니다.\n- 감정 분석 및 맥락 이해와 같은 고급 기능을 통합합니다.\n- LangSmith의 미래를 형성하기 위해 새로운 릴리스에 주목하고 LangSmith 커뮤니티에 참여하세요.\n\nLLM 애플리케이션은 발전함에 따라 LangSmith가 개발을 간소화하고 성능을 보장하며 AI 혁신을 이끌어내는 도구를 제공합니다.\n\n# 마무리\n\nLangSmith 소개를 마치고 대형 언어 모델 애플리케이션 개발 마스터에 한 발짝 다가가셨습니다. 이 안내서에서는 고대형 언어 모델 프로젝트의 개발 및 유지 관리를 간소화하기 위해 LangSmith와 LangChain을 설정하고 사용하는 방법을 개요로 설명했습니다.\n\n\n\n다룬 내용을 간단히 요약해 드리겠습니다:\n\n- 프로젝트를 LangChain과 LangSmith와 통합 설정하는 방법.\n- 애플리케이션을 이해하고 최적화하기 위해 실시간 디버깅 및 실행 추적을 활용하는 방법.\n\nLangSmith로 수행할 수 있는 많은 작업이 있습니다. 이에 관한 내용은 나중에 다룰 것이지만, 오늘 LangSmith를 사용하고 있지 않다면 기술 스택에 추가할 가치가 있다는 것을 확신시켜 드릴 수 있기를 바랍니다.\n\n연결 유지하고 여정을 공유하기 위해 아래 채널을 통해 언제든지 연락해 주세요:\n\n\n\n- 👨‍💼 LinkedIn: LLM 개발 및 기술 혁신에 대한 자세한 통찰력을 얻으려면 저와 함께하세요.\n- 💻 GitHub: 제 프로젝트를 살펴보고 지속적인 작업에 기여하세요.\n- 📚 Medium: LangSmith, LangChain 및 기타 AI 기술에 대한 보다 심층적인 토론을 위해 제 기사를 팔로우하세요.\n\n귀하의 피드백 및 협업은 귀중합니다. 행복한 개발하고 LangSmith로 만드는 놀라운 응용 프로그램을 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png","tag":["Tech"],"readingTime":6},{"title":"새로운 Angular 17 기능 새로운 제어 흐름 구문","description":"","date":"2024-05-14 14:12","slug":"2024-05-14-NewAngular17featurenewcontrolflowsyntax","content":"\n\n# Angular의 새로운 선언적 제어 흐름을 시그널 기반 예시로 설명합니다\n\n![이미지](/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png)\n\nAngular 17은 11월 초에 출시될 예정이며, 선언적 제어 흐름을 갖는 새로운 템플릿 제어 블록 구문을 제공할 것입니다. 이 새로운 블록을 사용하는 두 가지 그룹의 특징이 있습니다:\n\n- 지연 로딩 블록: Angular 17은 블록 내용의 지연 로딩을 가능케 하는 @defer 제어 블록을 가집니다. 블록 내용의 종속 항목에도 지연 로딩이 적용됩니다: 모든 컴포넌트, 지시문 및 파이프도 지연 로딩이 될 것입니다. 이전 기사에서 defer 블록이 어떻게 작동하는지 예시로 보여드렸습니다.\n- 조건부 렌더링과 컬렉션 항목 렌더링을 제공하는 블록 (RFC): 이는 NgIf, NgFor 및 NgSwitch 지시문에 대한 대안입니다.\n\n\n\n이러한 새 제어 블록의 가장 중요한 이점 중 하나는 시그널을 통해 영역이 없는 애플리케이션을 지원한다는 것입니다.\n\n이 기사에서는 다음을 보여줍니다:\n\n- 새 제어 블록 구문을 사용하여 @if와 @else를 사용하여 조건에 따라 렌더링되는 블록 만들기\n- @switch, @case, @default를 사용하여 스위치 및 케이스 블록 만들기\n- @for를 사용하여 루프를 만들고 @empty 블록으로 빈 컬렉션을 처리하는 방법\n- ngIf, ngFor 및 ngSwitch를 새 제어 블록 구문으로 이전하는 방법\n\n전체 소스 코드는 여기에서 사용할 수 있습니다:\n\n\n\nhttps://github.com/gergelyszerovay/angular-17-control-flow\n\n저는 Angular v17.0.0-next.8을 사용했습니다. 독립 구성 요소와 시그널을 사용했습니다. 프론트엔드를 시작하려면 yarn run start 또는 npm run start를 입력하세요.\n\n# 조건적으로 렌더링되는 컨트롤 블록: @if 및 @else\n\n첫 번째 예제에서는 체크박스를 만들고 isChecked 시그널에 바인딩합니다. 시그널의 기본값은 true이므로 초기에 체크박스가 선택되고 @if 블록 내용이 렌더링됩니다. 아래 예제는 src\\app\\app.component.html 템플릿 파일에서 가져온 것입니다.\n\n\n\n```js\n\u003ch3\u003e\u0026#64;if and \u0026#64;else\u003c/h3\u003e\n\u003cdiv\u003e\n  \u003cinput #checkbox type=\"checkbox\" [checked]=\"isChecked()\" (change)=\"isChecked.set(checkbox.checked)\" id=\"checkbox\"/\u003e\n\u003c/div\u003e\n\u003cdiv\u003e\n@if (isChecked()) {\n  \u003cspan\u003eChecked\u003c/span\u003e\n} \n@else {\n  \u003cspan\u003eNot checked\u003c/span\u003e\n}\n\u003c/div\u003e\n```\n\n'@if (logical_expression)' 문은 논리 표현식을 사용하여 @if 블록을 생성합니다. 저는 논리 표현식으로 isChecked() 신호를 사용했는데, 이는 부울 값으로 평가됩니다.\n\n@else 블록을 @if 블록 아래에 추가했습니다. 이 블록은 @if 블록의 논리 표현식이 false로 평가될 때 렌더링됩니다. 즉, isChecked() 신호의 값이 false인 경우에 해당합니다. 따라서 체크박스를 해제하면 Angular가 @else 블록의 내용을 렌더링합니다.\n\n새로운 제어 블록 구문과 관련된 중요한 사항이 하나 더 있습니다: '@', '' 및 '' 문자에 특별한 의미가 있기 때문에 템플릿의 텍스트에서 이를 대체해야 합니다. HTML 엔티티를 사용해야 합니다:\n\n\n\n\n- '@' 대신에 \u0026#64;을 사용하세요. 위 코드의 'h3' 헤딩을 확인해보세요.\n- ' ' 대신에 \u0026#123;을 사용하세요.\n- ' ' 대신에 \u0026#125;을 사용하세요.\n\n그렇지 않으면 다음과 같은 컴파일 오류 중 하나가 발생할 수 있습니다:\n\n- [ERROR] NG5002: Incomplete block \"…\". If you meant to write the @ character, you should use the \"@\" HTML entity instead. [plugin angular-compiler]\n- [ERROR] NG5002: Unexpected character \"EOF\" (Do you have an unescaped \"'\" in your template? Use \"'' ‘'’ ''\") to escape it.)\n\n# Collection의 항목을 렌더링하기 위해 @for 블록 사용\n\n\n\n아이템 배열을 컴포넌트 클래스에서 정의해 봅시다:\n\n```js\ncollection = [\n    { id: 1, name: '아이템 1' },\n    { id: 2, name: '아이템 2' },\n    { id: 3, name: '아이템 3' }\n  ];\n```\n\n컬렉션 요소를 렌더링하기 위해 @for (item of items; track item.id) ' 블록을 사용할 수 있습니다:\n\n```js\n\u003cul\u003e\n@for (item of collection; track item.id; let index = $index, first = $first; let last = $last, even = $even, odd = $odd; let count = $count) {\n\u003cli\u003e\u003cstrong\u003e{item.name}\u003c/strong\u003e index={index} first={first} last={last} even={even} odd={odd} count={count}\u003c/li\u003e\n}\n\u003c/ul\u003e\n```\n\n\n\n컬렉션 내 각 항목은 고유한 속성(예: id와 같은)을 가져야 하며, 이 값을 track 인수로 참조해야 합니다. 컬렉션이 객체가 아닌 문자열이나 숫자를 포함하는 경우에는 항목 자체를 track 값으로 사용할 수 있습니다: @for (item of items; track item) '.\n\n현재 항목 옆에 @for 표현식을 사용하면 블록 내에서 다음 값에 액세스할 수 있습니다:\n\n- $index: 컬렉션 내 항목의 인덱스\n- $even: 인덱스가 짝수인 경우 true\n- $odd: 인덱스가 홀수인 경우 true\n- $count: 컬렉션 내 항목 수\n- $first: 현재 항목이 컬렉션 내 첫 번째인 경우 true\n- $last: 현재 항목이 컬렉션 내 마지막인 경우 true\n\n# @for에서 전달된 빈 컬렉션을 처리하기 위해 @empty 블록 사용하기\n\n\n\n@for 블록 아래에 @empty 블록을 추가할 수 있습니다. @empty 블록의 내용은 @for 블록에 전달한 컬렉션이 비어있을 때 렌더링됩니다:\n\n```js\n\u003cul\u003e\n@for (item of emptyCollection; track item.id;) {\n\u003cli\u003e\u003cstrong\u003e{item.name}\u003c/strong\u003e\u003c/li\u003e\n}\n@empty {\n  \u003cspan\u003e컬렉션이 비어 있습니다\u003c/span\u003e\n}\n\u003c/ul\u003e\n```\n\n# @switch, @case 및 @default로 제어 흐름 변경\n\n다음 예시에서 네 개의 라디오 버튼과 radioValue signal을 생성합니다. signal의 초기값은 1이며 사용자가 라디오 버튼을 클릭할 때 signal의 값이 1, 2, 3 또는 4로 변경됩니다:\n\n\n\n```js\n\u003cdiv\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 1\" (change)=\"radioValue.set(1)\" id=\"radio1\"/\u003e\n    \u003clabel for=\"radio1\"\u003e1\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 2\" (change)=\"radioValue.set(2)\" id=\"radio2\"/\u003e\n    \u003clabel for=\"radio2\"\u003e2\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 3\" (change)=\"radioValue.set(3)\" id=\"radio3\"/\u003e\n    \u003clabel for=\"radio3\"\u003e3\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 4\" (change)=\"radioValue.set(4)\" id=\"radio4\"/\u003e\n    \u003clabel for=\"radio4\"\u003e4\u003c/label\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv\u003e\n```\n라디오 버튼 3개를 선택했습니다.\n```js\n@switch (radioValue()) {\n  @case (1) {\n    \u003cspan\u003eCase 1\u003c/span\u003e\n  }\n  @case (2) {\n    \u003cspan\u003eCase 2\u003c/span\u003e\n  }\n  @default {\n    \u003cspan\u003eDefault case (Not 1 or 2)\u003c/span\u003e\n  }\n}\n\u003c/div\u003e\n```\n\n\n\n앱 템플릿의 이전 구조 지시문을 새 제어 블록으로 변환하려면 다음 스키마틱을 실행하세요:\n\n```js\nng g @angular/core:control-flow-migration\n```\n\n# 요약\n\n본 문서에서는 Angular 17의 새로운 제어 흐름이 어떻게 작동하는지를 보여드렸습니다: 새로운 제어 블록 구문을 사용하여 조건부 블록 및 반복문을 만드는 방법을 안내했습니다. 내 튜토리얼이 유용했기를 바라며!\n\n\n\n이 기사 시리즈의 첫 부분에서는 새로운 지연 블록의 작동 방식과 이러한 블록 내용의 로딩 및 렌더링을 트리거할 조건을 지정하는 방법에 대해 설명했습니다: 새로운 Angular 17 기능: 지연 로딩.\n\n그리고 언제든지 피드백을 주시면 감사하겠습니다!\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이고, 프론트엔드 개발 챕터 리드로 일하고 있습니다. Angular 가르치기 (및 배우기)는 제 소질 중 하나입니다. Angular 관련 콘텐츠를 매일 소비합니다 — 기사, 팟캐스트, 컨퍼런스 강연 등을 포함하여요.\n\n\n\n저는 매달 발견한 최고의 자료를 여러분에게 보낼 수 있도록 Angular Addict 뉴스레터를 만들었어요. 경험 많은 Angular Addict 이든 초보자든 모두 대상입니다.\n\n뉴스레터 외에도 Angular Addicts라는 제 판에서 — 맞아요! — 수집한 가장 유익하고 흥미로운 자료들을 소개하고 있어요. 글쓴이로 참여하고 싶다면 언제든지 알려주세요.\n\n함께 Angular를 배워봐요! 여기서 구독하기 🔥\n\nSubstack, Medium, Dev.to, Twitter 또는 LinkedIn에서 저를 팔로우해서 Angular에 대해 더 많은 정보를 얻어보세요!","ogImage":{"url":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png"},"coverImage":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1","description":"","date":"2024-05-14 14:09","slug":"2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1","content":"\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png)\n\n웹 3.0의 개념은 2000년대 초반에 나타나기 시작했으며, 웹 2.0의 잠재적인 후속자로 손에 잡히는 관심을 끌었습니다. 그 시작 시기는 정확히 정해져 있지 않지만, \"웹 3.0\"이라는 용어는 2000년대 중반쯤에 기술자들과 사고 선도자들이 인터넷 진화의 다음 단계를 상상하기 시작함에 따라 널리 통용되었습니다.\n\n웹 3.0은 인터넷 진화의 혁명적인 단계로 생겨나며, 분산된 신뢰성 없는 프레임워크로 전통적인 표준을 깰 준비를 하고 있습니다. 이 개혁적인 패러다임 변화는 중앙화된 권한으로부터 벗어나 개인 이해관계자 간에 권력이 민주화된 시대를 예고하고 있습니다. 블록체인, 분산저장 및 스마트 계약과 같은 최첨단 기술을 활용하여, 웹 3.0은 조직이 운영에서 향상된 보안, 투명성 및 효율성을 추구하는 동력적 제안을 제시하고 있습니다. 이 대대적인 변화는 거래의 모습을 재정립 뿐만 아니라, 점차적으로 디지턀 배경에서 혁신을 받아들여 번영하기 위한 필요성을 강조합니다. 조직이 웹 3.0의 모습을 탐색하는 동안, 그들은 새로운 기회의 가능성을 풀고 산업의 궤도를 형성할 수 있는 변형적인 여정에 나서며, 보다 분산된, 유연한 및 포용적인 생태계로 향하는 전환적인 여정을 시작합니다.\n\n# 웹 2.0의 문제점과 웹 3.0의 발명을 이끈 문제들\n\n\n\n웹 2.0는 여러 측면에서 혁명적이었지만 몇 가지 문제와 제약도 함께 가져왔습니다. 이 기사에서 몇 가지를 강조하고 싶습니다:\n\n## 권력의 중앙화\n\n웹 2.0 플랫폼은 대부분 중앙 집중화되어 있어서 소수의 대형 기업이 사용자 데이터, 콘텐츠 배포, 플랫폼 운영에 상당한 통제력을 갖고 있습니다. 이 중앙 집중화는 검열, 데이터 유출, 그리고 통제된 상업 관행과 같은 문제로 이어질 수 있습니다.\n\n## 프라이버시 부재\n\n\n\n웹 2.0 기반 애플리케이션은 일반적으로 명확한 동의나 적절한 개인정보 보호 없이도 사용자 데이터를 대상으로 한 광고 및 기타 목적을 위해 방대한 양을 수집합니다. 이러한 프라이버시의 부족은 사용자 신뢰를 약화시키고 데이터 남용과 감시에 대한 우려를 야기할 수 있습니다.\n\n## 상호 운용성 도전\n\n현재의 애플리케이션은 종종 재고를 축적하여 사용자가 서로 다른 서비스와 애플리케이션 간의 데이터와 정보를 원할하게 전송하는 것을 어렵게 만듭니다. 이러한 상호 운용성의 부족은 혁신을 억제하고 사용자 선택을 제한하며 새로운 경쟁 업체에 대한 진입 장벽을 만들 수 있습니다.\n\n## 보안 취약점\n\n\n\n오늘날의 웹 2.0 기반 구현은 때로 보안 취약점과 데이터 유출에 노출될 수 있어서 사용자 정보를 위험에 빠뜨릴 수 있습니다. 데이터의 중앙 집중 저장 및 단일 장애 지점에 의존하면 사이버 공격 및 민감한 정보에 대한 무단 액세스 가능성이 증가합니다.\n\n![그림](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_1.png)\n\n## 이용자 제어의 제한\n\n웹 2.0에서 사용자는 자신의 데이터, 신원 및 디지털 자산에 대해 제한된 제어권을 갖고 있습니다. 플랫폼은 종종 서비스 약관을 지시하고 컨텐츠를 검열하거나 액세스를 제한하거나 사용자에게 별다른 대응 기회 없이 계정을 해지할 권한을 갖고 있습니다.\n\n\n\n## 수익 모델\n\n애플리케이션은 주로 광고 수익과 사용자 데이터 활용을 통해 수익을 창출합니다. 이는 플랫폼이 사용자의 복지보다는 사용자 참여 지표를 우선시하도록 장려하며, 부정한 행위와 관심 조작으로 이어질 수 있습니다.\n\n## 신뢰 문제\n\n플랫폼은 불투명한 알고리즘, 편향적인 콘텐츠 관리, 그리고 의사결정 프로세스의 투명성 부족으로 인해 신뢰 문제를 겪을 수 있습니다. 이는 온라인 정보와 상호 작용의 정직성과 신뢰성에 대한 사용자의 신뢰를 약화시킬 수 있습니다.\n\n\n\n# 웹 3.0의 핵심 원칙\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_2.png)\n\n## 분산화\n\n웹 3.0은 통제를 분산화하고 중앙 당국 또는 중개인에 의존성을 제거하려고 합니다. 소수 기업이나 개체의 손에 집중시키는 대신 사용자 네트워크 사이에서 권력을 분산시켜 더 견고하고 포용적이며 검열 방지혁 인터넷 생태계를 만들려고 합니다. 이더리움 블록체인에 배포된 탈중앙화 애플리케이션(DApp)과 상호 작용하기 위해 web3.js 라이브러리를 사용하는 다음 예제를 확인해보세요.\n\n\n\n```js\n// Web3.js 라이브러리를 가져옵니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 ('http://localhost:8545'를 자신의 이더리움 노드 URL로 바꿉니다)\nconst web3 = new Web3('http://localhost:8545');\n\n// 스마트 계약의 주소와 ABI (Application Binary Interface)를 정의합니다\nconst contractAddress = '0x1234567890123456789012345678901234567890'; // 귀하의 계약 주소로 대체합니다\nconst contractABI: any[] = [\n  // 귀하의 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n\n// 계약 인스턴스를 생성합니다\nconst contract = new web3.eth.Contract(contractABI, contractAddress);\n\n// 스마트 계약에서 데이터를 가져오는 함수\nasync function fetchData(): Promise\u003cvoid\u003e {\n  try {\n    // 스마트 계약의 getData 함수 호출\n    const data: number = await contract.methods.getData().call();\n    console.log('스마트 계약에서 검색된 데이터:', data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n}\n\n// fetchData 함수 호출합니다\nfetchData();\n```\n\n## 상호 운용성\n\n웹 3.0의 개념은 서로 다른 플랫폼, 응용 프로그램 및 프로토콜간의 상호 운용성을 촉진합니다. 이는 다양한 생태계 간의 원활한 데이터 교환과 협력을 가능케 하며, 혁신을 촉진하고 사용자가 사일로된 데이터나 닫힌 시스템으로 제약받지 않고 웹을 더 유연하게 탐색할 수 있도록 합니다.\n\n다음은 서로 다른 네트워크에 배포된 두 개의 이더리움 기반 스마트 계약 간의 상호 운용성을 보여주는 TypeScript의 기본 예제입니다.```\n\n\n\n```js\n// Web3.js 라이브러리를 가져와서 사용합니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 (이더리움 노드 URL과 네트워크 ID를 교체해주세요)\nconst web3NetworkA = new Web3('http://networkA:8545');\nconst web3NetworkB = new Web3('http://networkB:8545');\n\n// 네트워크 A에 배포된 첫 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressA = '0x1234567890123456789012345678901234567890'; // 네트워크 A의 계약 주소로 교체해주세요\nconst contractABIA: any[] = [\n  // 네트워크 A에 배포된 스마트 계약의 ABI\n  // 네트워크 A의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 네트워크 B에 배포된 두 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressB = '0x0987654321098765432109876543210987654321'; // 네트워크 B의 계약 주소로 교체해주세요\nconst contractABIB: any[] = [\n  // 네트워크 B에 배포된 스마트 계약의 ABI\n  // 네트워크 B의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 두 계약의 인스턴스를 생성합니다\nconst contractA = new web3NetworkA.eth.Contract(contractABIA, contractAddressA);\nconst contractB = new web3NetworkB.eth.Contract(contractABIB, contractAddressB);\n\n// 두 계약 간 데이터 전송하는 함수를 정의합니다\nasync function transferData(): Promise\u003cvoid\u003e {\n  try {\n    // 계약 A에서 데이터를 검색하는 메서드 호출\n    const data = await contractA.methods.getData().call();\n\n    // 계약 B에서 데이터를 설정하는 메서드 호출\n    await contractB.methods.setData(data).send({ from: '0x당신의주소', gas: 500000 });\n    \n    console.log('계약 A에서 계약 B로 데이터 전송 성공:', data);\n  } catch (error) {\n    console.error('데이터 전송 중 오류 발생:', error);\n  }\n}\n\n// 상호운용성을 보여주기 위해 transferData 함수 호출\ntransferData();\n```\n\n## 개인정보\n\n개인정보 보호는 Web 3.0의 핵심 원칙으로, 사용자가 개인 데이터를 제어하고 소유하는 것을 강조합니다. 사용자 데이터가 수집되고 이익을 위해 활용되며 침해를 받는 Web 2.0과는 달리, Web 3.0은 사용자의 개인 정보를 보호하는 메커니즘을 우선시합니다. 이는 분산 저장, 암호화, 자기 주권 식별 솔루션 등을 포함합니다.\n\n다음은 TypeScript를 사용한 간단한 예제로, 암호 기술과 분산 인증 메커니즘을 활용하여 사용자의 개인 정보 보호를 강화하는 웹3-react 라이브러리를 이용한 탈중앙화 애플리케이션(DApp)과 상호 작용하는 방법을 보여줍니다.```\n\n\n\n```js\nimport { ethers } from 'ethers';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { useWeb3React } from '@web3-react/core';\n\n// 주입된 커넥터를 초기화합니다.\nconst injectedConnector = new InjectedConnector({ supportedChainIds: [1, 3, 4, 5, 42] });\n\n// 이더리움 프로바이더를 초기화합니다.\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n// 계정 세부 정보를 가져오는 함수\nasync function fetchAccountDetails(): Promise\u003cvoid\u003e {\n  try {\n    // 사용자의 이더리움 계정에 접근 권한을 요청합니다.\n    await provider.send('eth_requestAccounts', []);\n\n    // 서명자를 가져옵니다.\n    const signer = provider.getSigner();\n\n    // 사용자의 이더리움 주소를 가져옵니다.\n    const address = await signer.getAddress();\n\n    // 주소 출력\n    console.log('사용자 주소:', address);\n  } catch (error) {\n    console.error('계정 세부 정보 가져오기 오류:', error);\n  }\n}\n\n// 주요 함수\nasync function main(): Promise\u003cvoid\u003e {\n  // 계정 세부 정보 가져오기\n  await fetchAccountDetails();\n}\n\n// 주요 함수 실행\nmain();\n```\n\n## 사용자 권한 부여\n\n또한 사용자에게 온라인 경험, 아이덴티티 및 디지털 자산에 대한 더 큰 통제력을 제공하여 사용자들을 권한 부여하는 것을 목표로 합니다. Web 3.0에서 탈중앙화된 거버넌스, 자체 실행 스마트 계약 및 토큰화와 같은 기능을 통해 사용자들은 의사 결정 과정에 더 적극적으로 참여하고 새로운 경제적 기회에 접근하며 디지털 삶 소유권을 주장할 수 있습니다.\n\nTypeScript를 사용한 Web 3.0에서 사용자 권한 부여를 보여주는 간단한 예제로 탈중앙화된 아이덴티티(DID) 솔루션을 사용합니다. 이 예제에서는 이더리움에서 탈중앙화된 아이덴티티 관리의 인기 있는 선택인 uPort 라이브러리를 사용할 것입니다.\n\n\n\n\n```js\nimport { Connect, SimpleSigner } from 'uport-connect';\n\n// uPort 인스턴스 생성\nconst uport = new Connect('당신의앱이름', {\n  clientId: '당신의클라이언트아이디', // 여러분의 uPort 클라이언트 ID로 대체해주세요\n  signer: SimpleSigner('당신의개인키') // 여러분의 개인 키로 대체해주세요\n});\n\n// 사용자를 위한 탈중앙화 식별자(DID) 생성하는 함수\nasync function createDID(): Promise\u003cvoid\u003e {\n  try {\n    // 사용자에게 탈중앙화 식별자를 만들기 위한 동의를 요청함\n    const credentials = await uport.requestCredentials({\n      requested: ['name', 'avatar'], // 요청된 사용자 속성\n      notifications: true // 크리덴셜 요청을 위한 푸시 알림 활성화\n    });\n\n    // 사용자의 탈중앙화 식별자를 기록함\n    console.log('탈중앙화 식별자(DID):', credentials);\n  } catch (error) {\n    console.error('탈중앙화 식별자 생성 중 오류 발생:', error);\n  }\n}\n\n// 사용자를 위해 탈중앙화 식별자를 만들기 위해 createDID 함수 호출\ncreateDID();\n```\n\n# 웹 3.0에 대해 더 알아보기\n\n위의 기사에서 몇 가지 용어를 언급했는데, 분명 일부 용어가 블록체인과 관련이 있다는 걸 알아챘을 거예요. 그래서 우리는 블록체인이 웹 3.0을 위한 기술적 기반으로 작용한다고 할 수 있어요. 이제 웹 3.0 관련 용어 몇 가지 더 살펴봅시다.\n\n## 탈중앙화 애플리케이션 (DApp)```\n\n\n\n분산 애플리케이션(DApp)은 블록체인 기술을 활용하는 분산 네트워크에서 작동하는 소프트웨어 응용 프로그램 유형입니다. 일반적으로 중앙화된 서버에 호스팅되고 단일 엔티티에 의해 제어되는 전통적인 애플리케이션과는 달리, DApp은 컴퓨터(노드)들의 동등 네트워크에서 실행되며 데이터와 작업이 네트워크 상으로 분산됩니다. DApp의 주요 특징으로는 분산화, 오픈 소스, 토큰화, 스마트 계약, 변경할 수 없는 데이터와 상호 운용성이 있습니다.\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_3.png)\n\n분산화 응용 프로그램의 몇 가지 예시로는 분산 재무(DeFi) 플랫폼, 분산 거래소 (DEX), 블록체인 기반 게임, 소셜 네트워크 및 공급망 관리 시스템 등이 있습니다.\n\n## 스마트 계약 및 ABI\n\n\n\n스마트 계약은 합의 조건이 직접 코드로 작성된 자체 실행 계약입니다. 이러한 계약은 이더리움과 같은 블록체인 네트워크에 저장되고 실행되며 중개인 없이 당사자 간의 합의 조건을 자동으로 시행합니다. 스마트 계약의 주요 특징으로는 자치성, 신뢰 없음, 보안, 투명성, 효율성 및 분산화가 있습니다.\n\n위 예제에서 스마트 계약인 다음 코드를 주목했을 것입니다:\n\n```js\nconst contractABI: any[] = [\n  // 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n```\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_4.png)\n\n\n\nABI는 \"Application Binary Interface\"의 약자입니다. ABI는 이더리움 블록체인에 배포된 스마트 계약의 인터페이스를 JSON으로 나타낸 것입니다. 스마트 계약의 메서드와 속성을 정의하며, 해당 메서드와 속성의 이름, 매개변수, 반환 유형 및 가시성을 포함합니다.\n\nABI는 탈중앙화된 응용프로그램(DApps)이나 스크립트와 같은 외부 응용프로그램에서 스마트 계약과 상호작용하는 데 중요합니다. ABI는 이더리움 가상 머신(EVM)과 외부 응용프로그램 사이의 다리 역할을 하며, 배포된 스마트 계약에서 함수를 호출하고 상호작용할 수 있게 합니다.\n\nAPI와는 다른 ABI에 대한 내용을 자세히 다룬 좋은 기사가 있습니다.\n\n## 검열 저항력\n\n\n\nWeb 3.0 아키텍처는 검열에 강하게 설계되어 시각과 표현의 자유를 지킵니다. 탈중앙화된 네트워크와 프로토콜을 통해 어떠한 단일 엔티티도 콘텐츠를 통제하거나 검열하는 것이 어렵게 되어, 정보가 모든 이에게 접근 가능하도록 보장됩니다.\n\n다음은 IPFS Helia를 사용한 간단한 TypeScript 예제로, 탈중앙화된 저장소가 검열에 대항하는 데 어떻게 기여할 수 있는지 보여줍니다:\n\n```js\n// IPFS Helia 불러오기\nimport IPFSHelia from 'ipfs-helia';\n\n// IPFS Helia 노드에 연결하기 ('localhost'를 IPFS Helia 노드 주소로 대체)\nconst ipfsHelia = new IPFSHelia({ host: 'localhost', port: '5002', protocol: 'http' });\n\n// IPFS Helia에 파일을 업로드하는 함수\nasync function uploadFile(): Promise\u003cstring\u003e {\n  try {\n    const fileContent = Buffer.from('Hello, world!', 'utf-8');\n\n    // 파일을 IPFS Helia에 업로드\n    const result = await ipfsHelia.add(fileContent);\n    const ipfsHash = result.cid.toString();\n\n    console.log('해시 값으로 IPFS Helia에 파일 업로드 완료:', ipfsHash);\n    return ipfsHash;\n  } catch (error) {\n    console.error('IPFS Helia에 파일을 업로드하는 중 오류 발생:', error);\n    throw error;\n  }\n}\n\n// 해시 값을 사용하여 IPFS Helia에서 파일을 검색하는 함수\nasync function retrieveFile(ipfsHash: string): Promise\u003cvoid\u003e {\n  try {\n    // IPFS Helia에서 파일을 검색\n    const fileBuffer = await ipfsHelia.cat(ipfsHash);\n    const fileContent = fileBuffer.toString();\n\n    console.log('IPFS Helia로부터 검색된 파일 내용:', fileContent);\n  } catch (error) {\n    console.error('IPFS Helia로부터 파일을 검색하는 중 오류 발생:', error);\n  }\n}\n\n// 파일을 IPFS Helia에 업로드\nuploadFile()\n  .then((ipfsHash) =\u003e {\n    // IPFS Helia로부터 업로드된 파일 검색\n    retrieveFile(ipfsHash);\n  })\n  .catch((error) =\u003e {\n    console.error('오류:', error);\n  });\n```\n\n## 향상된 확장성과 성능\n\n\n\n웹 3.0은 이전 웹의 확장성과 성능 문제에 대응하기 위해 노력합니다. 샤딩, 레이어 2 솔루션 및 개선된 합의 메커니즘과 같은 혁신들은 웹 3.0 플랫폼이 더 높은 거래 및 상호 작용의 부하를 더 효율적으로 처리할 수 있도록 합니다.\n\n## 토큰화와 디지털 자산\n\n웹 3.0은 자산과 서비스를 블록체인 네트워크 상의 디지털 토큰으로 표현하는 토큰화 개념을 소개합니다. 이로써 부분 소유권을 용이하게 만들고 유동성을 향상시키며 새로운 형태의 가치 교환과 통화화를 가능하게 합니다. 다음은 이더리움 블록체인에서 ERC-20 표준을 사용하여 토큰화와 디지털 자산을 설명하는 간단한 예시입니다.\n\n```js\nimport Web3 from 'web3';\nimport { Contract, ContractFactory } from 'ethers';\nimport { ethers } from 'hardhat';\n\n// 이더리움 네트워크에 연결하기 ('http://localhost:8545'를 사용 중인 이더리움 노드 URL로 대체하세요)\nconst web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));\n\n// ERC-20 토큰 컨트랙트 ABI\nconst tokenABI: any[] = [\n  // ERC-20 표준 메소드 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  // 다른 메소드들...\n];\n\n// ERC-20 토큰 컨트랙트를 배포하는 함수\nasync function deployTokenContract(name: string, symbol: string, initialSupply: number): Promise\u003cvoid\u003e {\n  try {\n    // 서명자 얻기\n    const signer = ethers.provider.getSigner();\n\n    // ERC-20 토큰 컨트랙트 배포\n    const tokenFactory = new ContractFactory(tokenABI, ERC20Token.bytecode, signer);\n    const tokenContract = await tokenFactory.deploy(name, symbol, initialSupply);\n\n    console.log('ERC-20 토큰 컨트랙트 배포됨:', tokenContract.address);\n  } catch (error) {\n    console.error('ERC-20 토큰 컨트랙트 배포 중 오류 발생:', error);\n  }\n}\n\n// deployTokenContract 함수를 호출하여 ERC-20 토큰 컨트랙트를 배포합니다.\ndeployTokenContract('MyToken', 'MTK', 1000000);\n```\n\n\n\n여기까지 도착했다면, 이 글의 제2부를 계속 읽고 싶은 것 같네요. 아래 링크에서 제2부를 확인해보세요. \n\n[https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220](https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220)","ogImage":{"url":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"},"coverImage":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 함수에 대한 인터뷰 개념","description":"","date":"2024-05-14 14:08","slug":"2024-05-14-InterviewConceptsonJavaScriptFunctions","content":"\n\n![image](/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png)\n\n이 기사는 현재 작업 중인 JavaScript 인터뷰 컨셉을 준비하는 데 도움이 되는 안내서를 기반으로 합니다. 처음 두 장(chapter)는 지금 무료로 다운로드할 수 있습니다. 가이드에 대한 피드백을 주시면 감사하겠습니다.\nPDF 다운로드 링크는 여기에 있습니다. [PDF 다운로드 링크](https://9820419704756.gumroad.com/l/gdycz)\n\n이제, 이 기사의 주제로 넘어가 봅시다!\n\nJavaScript에서 함수를 여러 가지 방법으로 만들 수 있습니다.\n\n\n\n'function' 키워드를 사용하여 함수를 생성할 수 있습니다. 이를 함수 선언이라고 합니다. 아래는 예시입니다:\n\n```js\nfunction addNumbers(a, b) {\n  return a + b;\n}\n```\n\n이 예시에서 'addNumbers'라는 함수를 선언했습니다. 두 개의 인수 'a'와 'b'를 받습니다. 함수의 코드 블록에서는 + 연산자를 사용하여 두 인수를 더한 후 결과를 반환합니다.\n\n함수 선언을 사용하는 장점 중 하나는 호이스팅이 가능하다는 것입니다. 즉, 선언되기 전에 호출할 수 있다는 의미입니다.\n\n\n\n기능 표현식: 함수 표현식은 함수를 변수에 할당하여 선언하는 방법입니다. 예시입니다:\n\n```js\nconst multiply = function(a, b) {\n  return a * b;\n}\nconsole.log(multiply(2,3)); // 결과: 6\n```\n\n함수 표현식을 사용하는 장점은 다른 함수에 인수로 전달할 수 있다는 것입니다.\n\n화살표 함수: 화살표 함수는 JavaScript에서 함수를 선언하는 새로운 방법이며 `=` 연산자를 사용합니다. 여기 예시가 있습니다:\n\n\n\n```js\nconst divide = (a, b) =\u003e {\n  return a / b;\n}\nconsole.log(divide(6,3)); // 출력: 2\n```\n\n화살표 함수는 간결한 구문을 가지고 있어서 함수가 충분히 간단하다면 한 줄로 작성할 수 있습니다.\n\n익명 함수: 익명 함수는 이름이 없는 함수로 다른 함수의 매개변수로 사용됩니다. 다음은 예시입니다:\n\n```js\nconst numbers = [1, 2, 3, 4];\nconst double = numbers.map(function(num) {\n  return num * 2;\n})\nconsole.log(double); // 출력: [2, 4, 6, 8]\n```\n\n\n\n익명 함수를 사용하는 장점은 다른 함수의 콜백 함수로 사용할 수 있다는 것입니다.\n\n면접에서 기대할 수 있는 질문\n\n자바스크립트에서 함수 범위의 개념을 설명해주세요.\n\n함수 범위는 함수 내에서 변수의 가시성을 의미합니다. 함수 내에서 선언된 변수는 해당 함수 내에서만 지역 변수로써 사용되며 외부에서 접근할 수 없습니다. 이는 명명 충돌을 방지하고 캡슐화를 촉진하는 데 도움이 됩니다.\n\n\n\n```js\nfunction greet() {\n  let message = \"Hello!\";\n  console.log(message); // \"Hello!\"\n}\ngreet();\nconsole.log(message); // Uncaught ReferenceError: 'message' is not defined\n```\n\nJavaScript에서 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 함수의 인수로 전달되어 외부 함수 내에서 호출되는 함수를 말합니다. 콜백 함수는 주로 비동기 작업, 이벤트 처리 및 고차 함수에서 사용됩니다.\n\n```js\nfunction doSomething(callback) {\n   console.log(\"작업 중...\");\n   callback(); // 콜백 함수 실행\n}\nfunction callbackFunction() {\n   console.log(\"콜백 함수 실행됨!\");\n}\n// doSomething에 callbackFunction을 콜백으로 전달\ndoSomething(callbackFunction);\n// 출력\n/* \"작업 중...\"\n\"콜백 함수 실행됨!\"\n*/\n```\n\n\n\n자바스크립트에서 고차 함수란 무엇인가요?\n\n고차 함수는 다른 함수를 인수로 받거나 함수를 결과로 반환하는 함수를 말합니다. 고차 함수는 함수 합성, 커링, 콜백과 같은 기능적 프로그래밍 패러다임을 지원합니다.\n\n```js\n// 고차 함수 예시\nfunction operateOnArray(array, operation) {\n  return array.map(operation); // 'operation'은 콜백 함수입니다\n}\nfunction double(num) {\n  return num * 2;\n}\nlet numbers = [1, 2, 3];\nlet doubledNumbers = operateOnArray(numbers, double);\nconsole.log(doubledNumbers); // 출력: [2, 4, 6]\n```\n\n자바스크립트에서 함수 호이스팅이란 무엇인가요?\n\n\n\n펑션 호이스팅은 JavaScript의 행동 중 하나로, 펑션 선언들이 컴파일 단계에서 자신을 포함하는 스코프의 맨 위로 이동하는 것을 말합니다. 이로 인해 함수들이 코드 내에서 선언되기 전에 호출될 수 있게 됩니다.\n\n```js\nsayHello(); // 출력: \"Hello!\"\nfunction sayHello() {\n  console.log(\"Hello!\");\n}\n```\n\nJavaScript에서 클로저(concept of closure)란 무엇인가요?\n\n클로저는 함수와 해당 함수가 선언된 렉시컬 환경(lexical environment)의 조합을 의미합니다. 클로저를 통해 함수는 포함하는 스코프의 변수에 대한 참조를 유지하고 접근할 수 있게 되며, 포함하는 스코프의 실행이 완료된 이후에도 영향을 받습니다.\n\n\n\n```js\nfunction outerFunction() {\n  let outerVariable = \"외부 함수에서 왔어요\";\n  function innerFunction() {\n    console.log(outerVariable); // 클로저에서 outerVariable에 접근\n  }\n  return innerFunction;\n}\nlet closureFunc = outerFunction();\nclosureFunc(); // 출력: \"외부 함수에서 왔어요\"\n```\n\n자바스크립트 함수에서 `this` 키워드의 목적은 무엇인가요?\n\n자바스크립트 함수에서 `this` 키워드는 함수가 호출된 위치의 문맥을 가리킵니다. 이를 통해 함수들은 자신을 호출한 객체의 속성에 접근하고 조작할 수 있어 코드 재사용 및 객체지향 프로그래밍 원칙을 용이하게 합니다.\n\n```js\nlet person = {\n  name: \"John\",\n  greet: function() {\n    console.log(\"안녕, \" + this.name + \"!\");\n  }\n};\nperson.greet(); // 출력: \"안녕, John!\"\n```\n\n\n\n자바스크립트에서 함수 커링(function currying)이란 무엇인가요?\n\n함수 커링은 여러 인수를 받는 함수를 각각 하나의 인수를 받는 중첩된 함수들의 연속으로 변환하는 과정입니다. 커링은 함수의 부분 적용을 가능하게 하여 더 큰 유연성과 재사용성을 제공합니다.\n\n```js\n// 함수 커링 예시\nfunction multiply(a) {\n  return function(b) {\n    return a * b;\n  };\n}\nlet multiplyByTwo = multiply(2);\nconsole.log(multiplyByTwo(5)); // 출력: 10\n```\n\n자바스크립트에서 즉시 호출 함수 표현식(IIFE)이란 무엇인가요?\n\n\n\nIIFE는 JavaScript 디자인 패턴으로, 함수를 괄호로 둘러싸고 즉시 호출하는 것을 포함합니다. 함수에 대한 개인 스코프를 만들어 전역 스코프에서 변수 오염을 방지합니다.\n\n```js\n// 즉시 호출되는 함수 표현(IIFE)\n(function() {\n  let message = \"IIFE에서 안녕하세요\";\n  console.log(message);\n})();\n// 출력: \"IIFE에서 안녕하세요\"\n```\n\n메모이제이션의 개념은 무엇이며, JavaScript 함수에서 어떻게 구현할 수 있을까요?\n\n메모이제이션은 비싼 함수 호출의 결과를 저장하고 같은 입력이 다시 발생할 때 캐시된 결과를 반환하는 최적화 기술입니다. 클로저를 사용하여 이전에 계산된 결과를 캐싱함으로써 구현할 수 있습니다.\n\n\n\n```js\nfunction memoize(fn) {\n  let cache = {};\n  return function(...args) {\n    let key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = fn(...args);\n    }\n    return cache[key];\n  };\n}\n// 메모이제이션에 이점을 가지는 함수 예시\nconst fibonacci = memoize(function(n) {\n  if (n \u003c= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n});\nconst result = fibonacci(10);\nconsole.log(result); // 결과 55\n```\n\n이것으로 모두 마무리입니다! 이 기사 끝까지 읽어 주셔서 감사합니다. 계속해서 학습하고成長해 나가요.\n\nJavaScript Interview Concepts- A Guide를 다운로드하시기를 잊지 마세요. 한정 기간 동안 무료로 제공될 것입니다.\n\n만약 이 기사에서 가치 있는 내용을 좋아하고 배웠다면, 구독해주시고 기사에 박수를 보내주세요.","ogImage":{"url":"/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png"},"coverImage":"/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다","description":"","date":"2024-05-14 14:06","slug":"2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter","content":"\n\nGit 내부를 배우면서 더 나은 이해를 위해 간소화된 버전을 구현해 보세요!\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png)\n\n## Git 또는 일반적으로 버전 관리란?\n\n우리 프로젝트를 시간에 따라 추적하는 데 도움이 되는 것이에요. 좋은 예시 중 하나는 소스 코드를 쉽게 과거의 특정 시간에 어떻게 보였는지 볼 수 있다는 것이죠.\n\n\n\n# 왜 그것을 이해해야 할까요?\n\n우선, 무언가 잘못되었을 때 몇 가지 명령어를 무심코 알아서는 도움이 되지 않습니다. 둘째로, 매일 다루고 있는 것이 어떻게 작동하는지 이해하지 못한다면, 재미가 어디에 있을까요?\n\n이제 슈퍼 간단한 버전 관리 시스템인 Gitj를 구현하는 방법을 하나씩 이해해 보겠습니다.\n\n# 구현\n\n\n\ngit은 압축 및 데이터 저장 방식과 같이 더 고급 기능을 수행한다는 것을 염두에 두세요. 이 내용은 별도의 기사에서 다룰 수 있습니다.\n\n# 첫 번째 명령어 적용: Init!\n\n아마도 알고 계시다시피 프로젝트를 git init으로 시작하면 git은 .git 폴더를 생성하고 데이터를 그 안에 저장합니다. 이를 구현해보겠습니다:\n\ngit이 생성하는 두 가지 중요한 폴더는 refs와 objects입니다. objects는 git의 구성 요소입니다. 3가지 유형(사실 4가지!)이 있을 수 있습니다: commit, tree 및 blob입니다. 이러한 각 유형을 자세히 살펴보겠습니다. refs 폴더에는 브랜치와 각 브랜치의 최신 커밋이 포함된 heads라는 하위 폴더가 있습니다(이름에서 알 수 있듯이 브랜치의 헤드를 저장하는 것으로 보입니다). 또한 현재 브랜치 또는 커밋을 유지하는 HEAD라는 중요한 파일이 있습니다.(가끔은 브랜치 대신 커밋에서 checkout을 수행할 수 있습니다)\n\n\n\n\"이제 init 함수를 호출하면 이러한 폴더들을 만들어 보겠습니다.\n\n```js\nconst fs = require(\"fs\");\n\nfunction init() {\n    // .gitj라는 폴더를 만들고, .gitj/objects와 .gitj/refs, .gitj/refs/heads와 같은 하위 폴더들을 생성합니다.\n    fs.mkdirSync(\".gitj\");\n    fs.mkdirSync(\".gitj/objects\");\n    fs.mkdirSync(\".gitj/refs\");\n    fs.mkdirSync(\".gitj/refs/heads\");\n    // .gitj/refs/heads/master라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/refs/heads/master\", \"\");\n    // .gitj/HEAD라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/HEAD\", \"ref: refs/heads/master\");\n}\n\ninit();\n```\n\n# Git Add! 파일을 스테이징 영역에 추가하기\n\nGit에서 파일은 세 가지 다른 단계에 있을 수 있습니다:\"\n\n\n\n![image](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_1.png)\n\n- Working Directory: 평소 작업하는 디렉토리로 파일 및 폴더를 변경하고 구조를 수정합니다.\n\n- Staging Directory: 작업 디렉토리의 한 순간의 스냅샷이며 git add 명령을 사용하면 실제로 파일이 .git 폴더로 복사됩니다. 주의할 점은 스테이징 파일들이 이후에 리포지토리에 커밋하려는 최종 원고이라는 것입니다.\n\n- Repository: commit 명령을 실행하면 리포지토리에 새로운 스냅샷이 생성됩니다. 이제 이 커밋의 SHA 해시를 사용하여 이 스냅샷을 가리킬 수 있습니다(스테이징 파일을 가리킬 수는 없으며 스테이징 파일은 종이 딱지 같은 역할을 합니다).\n\n\n\n이제 git add 명령어를 구현해 봅시다.\n\ngit add에서 수행해야 할 단계는:\n\n- 파일 내용 읽기\n- 파일 내용을 해싱하기\n- 해시를 파일 이름으로 사용하여 객체 폴더에 저장하기\n- 파일이 이미 존재하는 경우 아무 작업도 수행하지 않습니다. 동일한 내용을 가진 파일이 10개 있다면(심지어 다른 파일 이름과 폴더 위치를 가지더라도), git은 그것들을 10번 복사하는 게 아니라 blob를 재사용할 수 있습니다.\n\n또한, git은 해시의 처음 두 글자를 사용하여 폴더 이름을 생성합니다. 예를 들어, 해시가 4f9be057f0ea5d2ba72fd2c810e8d7b9aa98b469라면 git은 이 폴더에 저장합니다: 4f 및 나머지는 파일로 생성합니다: 9be057f0ea5d2ba72fd2c810e8d7b9aa98b469. 왜냐하면 시간이 지남에 따라 단일 폴더에 많은 파일이 있으면 파일에 액세스하는 데 시간이 더 오래 걸릴 수 있기 때문에 git은 폴더에 처음 두 글자를 사용함으로써 이 문제를 방지하려고 합니다.\n\n\n\n```js\nconst fs = require(\"fs\");\nconst crypto = require(\"crypto\");\n\nfunction add(filename) {\n    try {\n        // 파일이 존재하는지 확인\n        fs.accessSync(filename);\n        // 파일 읽기\n        const content = fs.readFileSync(filename);\n        // 파일 해싱\n        const hash = crypto.createHash(\"sha1\");\n        hash.update(content);\n        const sha = hash.digest(\"hex\");\n        // 해시의 첫 두 문자로 폴더 생성 (폴더가 없는 경우)\n        if (!fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}`)) {\n            fs.mkdirSync(\".gitj/objects/\" + sha.slice(0, 2), { recursive: true });\n        }\n        if (fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`)) {\n            // 이미 같은 내용의 블롭이 존재함\n            process.exit(0);\n        }\n        // 파일을 objects 폴더에 쓰기\n        fs.writeFileSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`, content);\n    } catch (error) {\n        console.log(error);\n        console.log(`파일 ${filename}이(가) 존재하지 않습니다.`);\n        process.exit(1);\n    }\n}\n\nadd('./sample/src/readme.md')\n```\n\nadd.js를 실행하여 소스 코드에서 파일을 추가한 후, 객체 저장소에 다음과 같은 파일이 생겼어야 합니다.\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_2.png)\n\n# 변경사항을 커밋하세요!\n\n\n\n\n커밋 자체도 객체 유형입니다. 아마도 예측하신 것처럼 우리의 객체 폴더에 더 많은 파일을 생성해야 합니다.\n\n커밋의 목적은 현재 상황(파일 및 폴더)에 대한 포인터를 만들어 이 상태로 돌아올 수 있도록 하는 것입니다.\n\nGit의 커밋 객체에는 다음 정보가 포함됩니다:\n\n- 작성자: 변경사항을 만든 사람\n- 커미터: 변경사항을 커밋한 사람 (때로는 다른 사람으로부터 패치를 받아 변경사항을 커밋해야 할 수도 있습니다.)\n- 커밋일\n- 커밋 메시지\n- 트리 (작업 디렉토리의 모양을 생성 시점에 유지하는 또 다른 객체)\n- 부모(존재하는 경우)\n\n\n\n## Git Commit이 어떻게 보이는지 알아봅시다\n\n만약 git log 명령어를 사용하면 커밋 해시 목록을 확인할 수 있고, 이 중 하나를 복사하여 git show --pretty=raw commitHash 명령어를 사용할 수 있습니다. 이 몤령어의 결과 예시는 다음과 같습니다(날짜는 커미터와 저자 이름 뒤의 타임스탬프로 표시됩니다):\n\n![Git Commit](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_3.png)\n\n이 예제에서는 부모가 있지만, 만약 커밋이 모든 첫 번째 커밋이라면 부모가 없습니다.\n\n\n\n부모가 커밋 객체 내에 존재하는 이유는 이러한 커밋들을 연결하여 연결할 수 있기 때문입니다. 따라서 우리가 과거의 커밋을 수동으로 변경하면 모든 커밋 해시를 다시 계산해야 하므로 모든 것이 엉망이 됩니다. 이는 리베이스와 같은 명령어를 사용하여 수행하는 작업입니다.\n\n## Git에서 Tree 객체 유형은 무엇인가요?\n\n폴더와 파일의 구조를 유지하는 객체 유형입니다. 예를 들어, 저가 보여준 커밋 예제에서 Tree 객체를 확인하고 내용을 볼 수 있습니다. Tree를 확인하려면 git ls-tree treeHash를 사용해야 합니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_4.png)\n\n\n\n이것은 기본 트리입니다. 작업 디렉토리의 파일과 폴더를 포함하고 있습니다. 여기서 두 가지 다른 유형을 볼 수 있는데, 파일을 나타내는 blob과 이 경우 하위 폴더를 나타내는 다른 트리 객체를 가리키는 tree가 있습니다.\n\n결과에서 두 번째 열은 객체의 유형, 세 번째 열은 SHA이며, 마지막 열은 파일 또는 폴더 이름입니다(파일 이름을 blob 밖에 유지하는 것은 동일한 내용을 반복해서 재사용하는 데 도움이 된다는 점을 이미 언급했습니다). 아직 알지 못하는 것은 첫 번째 열입니다. 첫 번째 열은 파일 모드입니다. 파일 모드는 객체의 유형 (예: blob, tree)과 해당 권한을 지정합니다. 040000 또는 100644와 같은 앞부분의 숫자는 8진수 표기법으로 파일 모드를 나타냅니다. 가장 일반적인 모드는 다음과 같습니다:\n\n- 100644: 읽기-쓰기 권한이 있는 일반 파일 (blob)을 나타냅니다.\n- 100755: 읽기-쓰기-실행 권한이 있는 실행 파일 (blob)을 나타냅니다.\n- 040000: 디렉토리 (tree)를 나타냅니다.\n\n커밋 기능을 구현하기 위해 필요한 조치:\n\n\n\n- 현재 작업 디렉토리의 트리를 생성하세요\n- 커밋 객체를 생성하세요\n- 부모 커밋(Head)을 얻으세요. 만약 부모가 없다면 이 커밋 이후에 head(master)를 업데이트하세요.\n\n우리는 git이 하는 방식과 동일한 파일 및 폴더 구조를 생성하는 간단한 트리를 만들 것입니다.\n\n## 트리 생성 함수 구현!\n\n각 파일의 파일 모드를 가져오는 작은 함수:\n\n\n\n```js\nasync function getTreeFileMode(fileType, fileOrFolder) {\n    const { mode } = await fs.stat(fileOrFolder);\n    return fileType === 'tree' ? '040000' : '100' + ((mode \u0026 parseInt(\"777\", 8)).toString(8));\n}\n```\n\n파일의 해시 값을 가져오는 함수\n\n```js\nasync function getHashOfFile(path) {\n    const content = await fs.readFile(path);\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(content);\n    const sha = hash.digest(\"hex\");\n    return sha;\n}\n```\n\n이제 메인 함수입니다.\n\n\n\n```js\nasync function createTreeObjectsFromPaths(folderPath) {\n    let treeFileContent = '';\n    let treeHash = ''\n    // 이 함수의 설명:\n    // 1- fs.readdir 결과를 반복한다.\n    // 2- 만약 디렉토리라면 유형은 tree이고 이 함수를 재귀적으로 호출한다. 그렇지 않으면 파일 또는 blob이다.\n    //    그리고 우리는 해시를 계산해야 한다.\n    // 3- 우리는 트리 객체를 만들기 위해 파일 모드(040000, 100644, ...)를 가져온다.\n    // 4- 트리 객체의 내용을 가지고 있다. 이제 해시를 생성할 수 있다.\n    // 5- 객체(현재 트리의 해시)가 존재하면 아무것도 할 필요가 없고, 그렇지 않으면 객체를 만들어서 객체 폴더에 저장한다.\n\n    // 이 함수를 실행해서 제대로 작동하는지 확인해봅시다:\n}\n```\n\n이 함수를 실행해보고 정상적으로 작동하는지 확인해보겠습니다:```\n\n\n\n이제 폴더 구조는 이렇게 보입니다.\n\n![Folder Structure](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_5.png)\n\n이제 `createTreeObjectsFromPaths('.')`를 실행합니다. 결과로 Gitj 폴더에 두 개의 새 객체가 생성됩니다:\n\n![Result](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_6.png)\n\n\n\n이 중 하나의 객체 내용은 루트 폴더에 있는 package.json을 blob 유형으로 가지고 있을 것으로 예상되고 src 폴더를 가리키는 다른 tree 객체를 기대합니다:\n\n![image 1](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_7.png)\n\n이 tree 커밋 해시는 이제 src 폴더의 구조를 저장하는 다른 객체를 가리킵니다:\n\n![image 2](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_8.png)\n\n\n\n이제 커밋 기능을 구현할 시간입니다.\n\n```js\nconst fs = require('fs').promises;\nconst crypto = require('crypto');\nconst { createTreeObjectsFromPaths, folderOrFileExist } = require('./tree');\n\nasync function commit(commitMessage) {\n    const treeHash = await createTreeObjectsFromPaths('./sample');\n    const parentHash = await getLatestCommitHash();\n    const author = 'test';\n    const committer = 'test';\n    const commitDate = Date.now();\n    const commitContent = `tree ${treeHash}\\nparent ${parentHash}\\nauthor ${author}\\ncommitter ${committer}\\ncommit date ${commitDate}\\n${commitMessage}`;\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(commitContent);\n    const commitHash = hash.digest(\"hex\");\n    // commit 객체를 objects 폴더에 작성합니다.\n    if (!await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}`)) {\n        await fs.mkdir(`.gitj/objects/${commitHash.slice(0, 2)}`, { recursive: true });\n    }\n    if (await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`)) {\n        // 이미 동일한 내용의 커밋이 존재합니다.\n        console.log(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`);\n        return commitHash;\n    }\n    // 파일을 objects 폴더에 작성합니다.\n    await fs.writeFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, commitContent);\n    // 현재 브랜치의 헤드를 커밋 해시로 설정합니다.\n    await fs.writeFile('.gitj/refs/heads/master', commitHash);\n    return commitHash;\n}\n```\n\n어려운 부분은 트리 객체였는데, 이제 모든 데이터를 갖고 있고 이를 함께 묶어 새로운 커밋 객체를 만듭니다. 또한, 브랜치의 헤드를 업데이트하여 이 새로운 스냅샷을 가리키도록 해야 합니다 (당연히 커밋 해시).\n\n\n\n## 마스터 브랜치 또는 메인 브랜치 또는 다른 브랜치가 무엇을 의미하죠?\n\n브랜치는 단순히 커밋을 가리키는 참조 또는 책갈피입니다. 커밋의 구현에서 본 것처럼 파일 내용을 업데이트 했을 때 refs/head/master 와 같은 파일의 내용을 볼 수 있습니다. 그것은 단지 커밋 해시입니다. 이 커밋 해시에는 부모가 있을 수 있으며(첫 번째 커밋이 아닌 경우), 더 이상 커밋이 없을 때까지 과거로 돌아갈 수 있습니다. 즉, 이 브랜치 이름을 사용하여 최신 커밋(Head!)에 액세스할 수 있습니다. 간단히 말해, 특정 브랜치에 있는 것은 다른 head를 가리키고 있다는 것을 의미합니다.\n\nblob에 파일 이름을 저장하지 않으므로, 파일 이름이 다르더라도 git이 blob을 사용할 수 있는 이점이 있습니다.\n\n## Git Checkout를 어떻게 실행하나요?\n\n\n\n이미 커밋 기능을 구현했으므로, 커밋에는 트리 객체(모든 폴더와 파일을 재귀적으로 가리킨다)에 접근할 수 있고, 파일은 .git(우리 경우 .gitj)에 blob으로 저장되어 있습니다. 따라서 먼저 작업 디렉토리를 제거한 다음 누군가가 다른 커밋(또는 브랜치 - 브랜치 헤드는 커밋 해시를 가리킨다)을 확인할 때 전체 디렉터리를 다시 만들어야 합니다. 하지만 먼저 커밋 해시 또는 브랜치 이름을 HEAD 파일에 저장해야 합니다.\n\n그 전에, 해당 커밋의 트리 객체를 가져오는 작은 함수를 구현하고 싶습니다:\n\n```js\nasync function getTreeHashFromCommit(commitHash) {\n    const commitContent = await fs.readFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, 'utf-8');\n    const array = commitContent.split('\\n').map(e=\u003e e.split(' '))\n    const elem = array.find(e =\u003e e[1] === 'tree');\n    return elem[2];\n};\n```\n\n이제 트리를 가지고 있으면 전체 폴더를 다시 만들어야 합니다:\n\n\n\n먼저, 이 커밋을 HEAD 파일에 써서 헤드가 더 이상 마스터에 있지 않음을 기억합니다. 전체 폴더를 다시 만들기 위해 트리와 블롭을 재귀적으로 가져와야 합니다. 다음은 구현 내용입니다:\n\n```js\nasync function convertTreeObject(treeHash, folderPrefix = '', files = []) {\n    const treeObject = await fs.readFile(`.gitj/objects/${treeHash.slice(0, 2)}/${treeHash.slice(2)}`, 'utf-8');\n    const array = treeObject.split('\\n').map(e=\u003e e.split(' '))\n    for (const file of array) {\n        if (!file || file.length \u003c 2) continue;\n        const [mode, type, hash, name] = file;\n        if (type === 'tree') {\n            await convertTreeObject(hash, folderPrefix + name + '/', files);\n        } else {\n            files.push({\n                mode: mode,\n                type: type,\n                hash: hash,\n                name: folderPrefix + name\n            })\n        }\n    }\n    return files;\n}\n```\n\n만약 파일이 있다면 파일의 이름과 블롭(파일의 내용)을 배열에 추가합니다. 객체 타입이 tree이면 이것이 폴더라는 것이고, 이 함수를 재귀적으로 호출하여 올바른 파일 경로를 생성하기 위해 부모 폴더의 경로를 전달해야 합니다.\n\n\n\n## 앞으로 구현하고 싶은 몇 가지 기능\n\n- Git 상태 확인\n- Git 차이 확인\n\n# 결론\n\n우리는 git이 히스토리를 추적할 수 있는 능력을 제공하기 위해 해시 및 커밋 해시 체인을 사용하는 방법을 배웠습니다. 개인적으로는 이런 식의 심층적인 탐구가 내용을 정말 잘 배우는 가장 좋은 방법이라고 생각합니다. 유용했기를 바랍니다. 만약 git에 더 많은 기능을 구현하는 데 관심이 있다면 이 GitHub 저장소를 확인해보세요.\n\n\n\n# 참고 자료\n\n- [CS50 YouTube 영상](https://www.youtube.com/watch?v=lG90LZotrpo\u0026ab_channel=CS50)\n- [유튜브의 인코드된 비디오](https://www.youtube.com/watch?v=P6jD966jzlk\u0026pp=ygUgR2l0IGludGVybmFscyBob3cgaXQgc3RvcmVzIGRhdGE%3D)\n- [GOTO Conferences YouTube 채널](https://www.youtube.com/watch?v=dBSHLb1B8sw\u0026ab_channel=GOTOConferences)\n\n\n\nhttps://www.youtube.com/watch?v=52MFjdGH20o\u0026ab_channel=Brief","ogImage":{"url":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png","tag":["Tech"],"readingTime":12}],"page":"52","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"52"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>