<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/52" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JavaScript 개발을 간편하게 싱글톤 패턴 안내하기" href="/post/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 개발을 간편하게 싱글톤 패턴 안내하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 개발을 간편하게 싱글톤 패턴 안내하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 개발을 간편하게 싱글톤 패턴 안내하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 마이크로서비스 작성하기" href="/post/2024-06-19-WritingAMicroserviceUsingNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 마이크로서비스 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 마이크로서비스 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 마이크로서비스 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기" href="/post/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법" href="/post/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 버그 바운티 20 익스트림 에디션 2024" href="/post/2024-06-19-JSforBugBounties20ExtremeEdition2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 버그 바운티 20 익스트림 에디션 2024" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 버그 바운티 20 익스트림 에디션 2024" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 버그 바운티 20 익스트림 에디션 2024</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들" href="/post/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성" href="/post/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항" href="/post/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="장고의 왕국이 곧 종말을 맞이할 이유" href="/post/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="장고의 왕국이 곧 종말을 맞이할 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="장고의 왕국이 곧 종말을 맞이할 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">장고의 왕국이 곧 종말을 맞이할 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다" href="/post/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link posts_-active__YVJEi" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JavaScript 개발을 간편하게 싱글톤 패턴 안내하기","description":"","date":"2024-06-19 22:52","slug":"2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide","content":"\n\n이제부터 테이블 태그를 Markdown 형식으로 변경할게요: \n\n\n![이미지](/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png)\n\n싱글톤 패턴(Singleton Pattern)은 클래스가 하나의 인스턴스만을 가지고 전역적인 접근 지점을 제공하는 디자인 패턴입니다. 이 패턴은 1994년 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides가 공동으로 지은 \"Design Patterns: Elements of Reusable Object-Oriented Software\" 책에서 처음 소개되었습니다. 싱글톤 패턴은 게임 개발에서 널리 사용되지만, 자바스크립트를 포함한 웹 개발에도 광범위하게 적용됩니다.\n\n# 용어의 유래\n\n\"싱글톤(singleton)\"이라는 용어는 하나의 원소만 포함하는 단일한 집합을 나타내는 수학적 개념에서 유래되었습니다. 이 아이디어는 클래스에 대한 단일 인스턴스 개념과 일치합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 싱글톤 패턴의 주요 기능\n\n싱글톤 패턴을 사용하면 객체들이 다음을 보장할 수 있습니다:\n\n- 하나의 인스턴스만 가지도록 보장\n- 해당 인스턴스에 쉽게 액세스 제공\n- 인스턴스화를 제어함 (예: 클래스의 생성자를 숨기지만 추상화 원칙을 완전히 따르지는 않음)\n\n# 싱글톤 패턴을 사용하는 이유?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 패턴의 주요 목적은 클래스의 단일 인스턴스만 존재함을 보장하는 것입니다. 이는 클래스의 인스턴스가 참조될 때마다 항상 동일한 인스턴스가 반환되어 현재 상태를 유지할 수 있다는 것을 의미합니다. 이것은 클래스 인스턴스나 속성에 대한 단일 전역 수준 범위(액세스)를 유지해야 할 때 유용합니다.\n\n# JavaScript에서 싱글톤 패턴 사용 시나리오\n\nJavaScript에서 싱글톤 패턴을 사용하는 시나리오는 다음과 같습니다:\n\n1. 데이터베이스 연결:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 패턴은 하나의 데이터베이스 연결만 필요한 애플리케이션에서 데이터베이스 연결의 인스턴스가 한 개만 생성되도록 하는 데 사용될 수 있습니다. 불필요한 연결을 방지하는 것뿐만 아니라 이를 통해 리소스 관리에 도움이 될 수 있습니다.\n\n2. 로거 서비스:\n\n싱글톤 패턴은 애플리케이션의 다양한 섹션에서 로그를 수집하고 집중하는 로깅 서비스를 구성하는 데 사용될 수 있습니다. 이를 통해 로그 기록은 한 곳으로 집중되고 로거의 설정과 상태가 전체 애플리케이션에서 일관되게 유지되도록 보장됩니다.\n\n3. 구성 관리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글턴 패턴은 설정이 여러 코드 영역에서 접근 가능해야 하는 응용 프로그램에서 설정을 관리하고 액세스를 제공하는 데 사용할 수 있습니다. 이렇게 함으로써 설정의 진실이 하나뿐임을 보장합니다.\n\n4. 자원 관리:\n\n싱글턴 패턴을 사용하여 스레드 풀, 연결 풀 또는 캐싱 메커니즘과 같은 공유 자원을 관리할 수 있습니다. 이는 불필요한 중복을 줄이고 공통 자원에 대한 액세스를 조직하는 데 도움이 됩니다.\n\n5. 애플리케이션 상태:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 중앙 집중형 상태를 갖는 경우, 예를 들어 React의 Redux나 Vue.js의 Vuex와 같은 상태 관리 라이브러리에서 전역 저장소가 있을 때는 주로 싱글톤 패턴을 사용하여 애플리케이션의 상태를 관리합니다.\n\n6. 인증 서비스:\n\n싱글톤 패턴은 사용자 권한 부여 및 인증을 관리하는 인증 서비스를 구축하는 데 사용될 수 있습니다. 이를 통해 애플리케이션 전반에 걸쳐 사용자의 권한 부여와 인증이 일관되게 보장됩니다.\n\n7. 작업 스케줄러:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 패턴은 중앙 작업 스케줄러 또는 작업 대기열이 필요한 상황에서 사용할 수 있습니다. 이를 통해 단 하나의 인스턴스만이 스케줄링 및 작업 관리를 처리하도록 보장할 수 있습니다.\n\n8. 인쇄 스풀러:\n\n싱글 프린트 스풀러를 사용하여 프린터 스풀링이 필요한 시스템에서 모든 인쇄 작업을 담당하도록 보장할 수 있습니다.\n\n# JavaScript에서 싱글톤 패턴 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서 싱글톤 패턴의 구현은 다음과 같은 방법으로 할 수 있어요:\n\n## 1. 함수 클로저 활용\n\n다음은 함수 클로저를 사용하여 싱글톤 패턴을 구현하는 예제입니다. 특히 JS에서는 즉시 호출하는 함수 표현식(IIFE)을 사용합니다.\n\n```js\nconst Singleton = (function() {\n  let instance;\n  function createInstance() {\n    // 여기서는 프라이빗 멤버와 메서드를 정의할 수 있어요\n    return {\n      // 여기서는 퍼블릭 메서드와 프로퍼티를 정의할 수 있어요\n      getInstance: function() {\n        if (!instance) {\n          instance = createInstance();\n        }\n        return instance;\n      },\n    };\n  }\n  return createInstance();\n})();\n\n// 인스턴스 참조하기\nconst singletonInstance1 = Singleton.getInstance();\nconst singletonInstance2 = Singleton.getInstance();\n\nconsole.log(singletonInstance1 === singletonInstance2); // 두 인스턴스가 동일한 인스턴스를 가리키므로 true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. ES6 클래스 사용\n\nES6 클래스 정의에서 \"인스턴스\" 프로퍼티는 클래스의 정적 프로퍼티로 정의할 수 있습니다. 생성자는 클래스의 단일 인스턴스만 있는지 확인합니다.\n\n```js\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      // 여기서는 비공개 멤버 및 메서드를 정의할 수 있습니다\n      Singleton.instance = this;\n    }\n    \n    return Singleton.instance;\n  }\n\n  // 여기서는 공개 메서드와 프로퍼티를 정의할 수 있습니다\n  getInstance() {\n    return Singleton.instance;\n  }\n}\n\n// 인스턴스 참조\nconst singletonInstance1 = new Singleton();\nconst singletonInstance2 = new Singleton();\n\nconsole.log(singletonInstance1 === singletonInstance2); // 둘 다 공통 인스턴스를 가리키므로 true\n```\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 패턴은 JavaScript에서 클래스의 단일 인스턴스를 보장하고 해당 인스턴스에 대한 전역 액세스를 제공하여 인스턴스화를 제어하는 강력한 도구입니다. 그 응용 분야는 데이터베이스 연결부터 구성 관리 이상으로 다양합니다. 싱글톤 패턴을 이해하고 구현함으로써 리소스 관리를 크게 향상시킬 수 있고 응용 프로그램의 다양한 부분 간에 일관성을 유지할 수 있습니다.\n\n싱글톤 패턴에 대해 궁금한 점이나 통찰이 있다면 말씀해주세요! 프로젝트에서 디자인 패턴을 어떻게 활용하고 있는지 대화를 나누어보겠습니다.","ogImage":{"url":"/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png"},"coverImage":"/assets/img/2024-06-19-SimplifyingJavascriptDevelopmentYourSingletonPatternGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용하여 마이크로서비스 작성하기","description":"","date":"2024-06-19 22:49","slug":"2024-06-19-WritingAMicroserviceUsingNodejs","content":"\n\n\n![Image](/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png)\n\n자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.\n\nIT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.\n\n이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.\n\n# 소개\n\n이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:\n\n- 이름과 설명으로 작업 생성;\n- 식별자로 작업 가져오기;\n- 작업 상태/이름/설명 업데이트.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.\n\n몇 가지 애플리케이션 요구 사항:\n\n- 작업은 상태 'new'로 생성되어야 합니다.\n- 사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.\n- 경쟁 상태를 피하십시오 (자세한 내용은 나중에).\n\n주요 비기능 요구 사항은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.\n- 탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.\n- 성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.\n- 복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.\n- 모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.\n- 관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.\n- 테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.\n- 상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.\n- 배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.\n\nNode.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.\n\n# 스택\n\n웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.\n- 자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.\n- 노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.\n\n그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.\n\n## 데이터베이스\n\n웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.\n\nMongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:\n\n- 스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;\n- 확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;\n- 성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.\n\nNode.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 프레임워크\n\n웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.\n\nNode.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:\n\nexpress의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000;\n\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World!')\n})\napp.listen(port, () =\u003e {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.\n\n# 유효성 검사\n\n유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:\n\njoi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:\n\n```js\nconst createTask = {\n  body: Joi.object().keys({\n    name: Joi.string().required(),\n    description: Joi.string().optional(),\n  }),\n};\n```\n\n이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:\n\n# 설정\n\n동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.\n\n응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.\n\n# 정적 분석\n\nJavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:\n\nESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트\n\n애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.\n\nJavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:\n\nJest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로깅\n\n애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.\n\nJavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:\n\nwinston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 메트릭\n\n메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.\n\n제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.\n\n다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모니터링 스택\n\n로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.\n\n로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:\n\n- Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;\n- Promtail — 로그를 포함하고 전송하는 에이전트;\n- Loki — 로그 집계 시스템;\n- Grafana — 관측 가능성 시스템.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로컬 인프라스트럭처\n\n로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.\n\n도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.\n\n도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n도커 컴포즈 업 -d\r\n```\n\n# 지속적 통합\n\n커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.\n\n이를 위해, 저는 GitHub Actions를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.\n\n# 애플리케이션 개발\n\n애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:\n\n이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.\n\n나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:\n\n```js\nconst mongoose = require('mongoose');\nconst { Schema } = mongoose;\nconst TaskSchema = new Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: false,\n    },\n    status: {\n      type: String,\n      enum: ['new', 'active', 'completed', 'cancelled'],\n      default: 'new',\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now,\n    },\n    updatedAt: Date,\n  },\n  { optimisticConcurrency: true },\n);\nmodule.exports = mongoose.model('task', TaskSchema);\n```\n\n이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nasync function updateTaskById(id, { name, description, status }) {\n  if (!name \u0026\u0026 !description \u0026\u0026 !status) {\n    return { error: '적어도 하나의 업데이트가 필요합니다', code: AT_LEAST_ONE_UPDATE_REQUIRED_CODE };\n  }\n\nif (status \u0026\u0026 !(status in availableUpdates)) {\n    return { error: '잘못된 상태입니다', code: INVALID_STATUS_CODE };\n  }\n  for (let retry = 0; retry \u003c 3; retry += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    const task = await Task.findById(id);\n    if (!task) {\n      return { error: '작업을 찾을 수 없습니다', code: INVALID_STATUS_TRANSITION_CODE };\n    }\n    if (status) {\n      const allowedStatuses = availableUpdates[task.status];\n      if (!allowedStatuses.includes(status)) {\n        return {\n          error: `'${task.status}'에서 '${status}'(으)로 업데이트할 수 없습니다`,\n          code: TASK_NOT_FOUND_CODE,\n        };\n      }\n    }\n    task.status = status ?? task.status;\n    task.name = name ?? task.name;\n    task.description = description ?? task.description;\n    task.updatedAt = Date.now();\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      await task.save();\n    } catch (error) {\n      logger.warn('저장 중 오류 발생', { error });\n      if (error.name === 'VersionError') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    return task;\n  }\n  return { error: '병행성 오류', code: CONCURRENCY_ERROR_CODE };\n}\n```\n\n가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.\n\n두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.\n\nMongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서 예시:\n\n```js\n{\n  \"_id\": {\n    \"$oid\": \"654e03210948a61665b7c889\"\n  },\n  \"name\": \"damnatio\",\n  \"description\": \"Ciminatio totus spiritus suffoco damnatio blanditiis.\",\n  \"status\": \"completed\",\n  \"createdAt\": {\n    \"$date\": \"2023-11-10T10:17:05.039Z\"\n  },\n  \"__v\": 2,\n  \"updatedAt\": {\n    \"$date\": \"2023-11-10T10:17:05.064Z\"\n  }\n}\n```\n\n위의 문서는 속성 __v에 버전을 저장합니다.\n\n다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst updateTaskById = catchAsync(async (req, res) =\u003e {\n  const result = await taskService.updateTaskById(req.params.id, req.body);\n  if (result.error) {\n    switch (result.code) {\n      case taskService.errorCodes.AT_LEAST_ONE_UPDATE_REQUIRED_CODE:\n        res.status(400).json({ success: false, message: '적어도 하나의 업데이트가 필요합니다' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_CODE:\n        res.status(400).json({ success: false, message: '유효하지 않은 상태' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_TRANSITION_CODE:\n        res.status(404).json({ success: false, message: '작업을 찾을 수 없음' });\n        return;\n      case taskService.errorCodes.TASK_NOT_FOUND_CODE:\n        res.status(400).json({ success: false, message: result.error });\n        return;\n      case taskService.errorCodes.CONCURRENCY_ERROR_CODE:\n        res.status(500).json({ success: false, message: '동시성 오류' });\n        return;\n      default:\n        res.status(500).json({ success: false, message: '내부 서버 오류' });\n        return;\n    }\n  }\n\nres.status(200).json({\n    success: true,\n    task: toDto(result),\n  });\n});\n```\n\n이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:\n\n```js\nconst { Router } = require('express');\nconst taskController = require('../../../controllers/task');\nconst taskValidation = require('../../../validation/task');\nconst validate = require('../../../middlewares/validate');\n\nconst router = Router();\nrouter.get('/:id', validate(taskValidation.getTaskById), taskController.getTaskById);\nrouter.put('/', validate(taskValidation.createTask), taskController.createTask);\nrouter.post('/:id', validate(taskValidation.updateTaskById), taskController.updateTaskById);\nmodule.exports = router;\n\n/**\n * @swagger\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */\n```\n\n맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:\n\n```js\nconst Joi = require('joi');\nconst pick = require('../utils/pick');\n\nfunction validate(schema) {\n  return (req, res, next) =\u003e {\n    const validSchema = pick(schema, ['params', 'query', 'body']);\n    const object = pick(req, Object.keys(validSchema));\n    const { value, error } = Joi.compile(validSchema)\n      .prefs({ errors: { label: 'key' }, abortEarly: false })\n      .validate(object);\n    if (error) {\n      const errorMessage = error.details.map((details) =\u003e details.message).join(', ');\n      res.status(400).json({ success: false, message: errorMessage });\n      return;\n    }\n    Object.assign(req, value);\n    next();\n  };\n}\nmodule.exports = validate;\n```\n\n또한 업데이트 요청 유효성 검사 스키마가 있습니다:\n\n```js\nconst updateTaskById = {\n  params: Joi.object().keys({\n    id: objectId.required(),\n  }),\n  body: Joi.object().keys({\n    name: Joi.string().optional(),\n    description: Joi.string().optional(),\n    status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional(),\n  }),\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다. \n\n```js\nconst path = require('path');\nconst app = require('../../src/app');\nconst db = require('../../src/db');\nconst { createConfig } = require('../../src/config/config');\nconst logger = require('../../src/config/logger');\nconst setupServer = () =\u003e {\n  let server;\n  const configPath = path.join(__dirname, '../../configs/tests.env');\n  const config = createConfig(configPath);\n  beforeAll(async () =\u003e {\n    logger.init(config);\n    await db.init(config);\n    await new Promise((resolve) =\u003e {\n      server = app.listen(config.port, () =\u003e {\n        resolve();\n      });\n    });\n  });\n  afterAll(async () =\u003e {\n    await new Promise((resolve) =\u003e {\n      server.close(() =\u003e {\n        resolve();\n      });\n    });\n    await db.destroy();\n    logger.destroy();\n  });\n};\nmodule.exports = {\n  setupServer,\n};\n```\n\n그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:\n\n```js\ndescribe('태스크 생성 및 업데이트', () =\u003e {\n      const data = [\n        {\n          name: '상태만 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newStatus: '활성',\n        },\n        {\n          name: '영어 전체 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newTaskName: '태스크 1 새로운',\n          newDescription: '태스크 1 새로운 설명',\n          newStatus: '활성',\n        },\n        // 이하 생략\n      ];\n\ndata.forEach(({\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }) =\u003e {\n        it(name, async () =\u003e {\n          let response = await fetch(baseUrl, {\n            method: 'put',\n            body: JSON.stringify({\n              name: taskName,\n              description,\n            }),\n            headers: { 'Content-Type': 'application/json' },\n          });\n          expect(response.status).toEqual(201);\n          const result = await response.json();\n          // 여기서부터 이하는 생략\n        });\n      });\n    });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:\n\n```js\nFROM node:20-alpine\nWORKDIR /app\nCOPY package.json yarn.lock ./\nRUN yarn install --frozen-lockfile\nCOPY src /app/src\nCMD [\"node\", \"./src/index.js\"]\n```\n\n어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:\n\n```js\nversion: '3.9'\nservices:\n    app:\n        build: .\n        ports:\n            - '8081:80'\n        depends_on:\n            - mongo\n        volumes:\n            - ./configs/docker.env:/app/configs/.env\n            - logs:/app/logs:rw\n    mongo:\n        image: mongo:5\n        restart: always\n        ports:\n            - 27017:27017\n        volumes:\n            - mongodata:/data/db\n        healthcheck:\n            test: echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet\n            interval: 10s\n            timeout: 2s\n            retries: 5\n            start_period: 5s\n    loki:\n        image: grafana/loki:2.9.0\n        expose:\n            - 3100\n        command: -config.file=/etc/loki/local-config.yaml\n    promtail:\n        image: grafana/promtail:2.9.0\n        volumes:\n            - logs:/var/log:rw\n            - ./infrastructure/promtail.yml:/etc/promtail/config.yml\n        command: -config.file=/etc/promtail/config.yml\n    prometheus:\n        image: prom/prometheus:latest\n        volumes:\n            - ./infrastructure/prometheus.yml:/etc/prometheus/prometheus.yml\n        command:\n            - '--config.file=/etc/prometheus/prometheus.yml'\n        expose:\n            - 9090\n    grafana:\n        image: grafana/grafana:latest\n        volumes:\n            - grafanadata:/var/lib/grafana\n        environment:\n            - GF_PATHS_PROVISIONING=/etc/grafana/provisioning\n            - GF_AUTH_ANONYMOUS_ENABLED=true\n            - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin\n        ports:\n            - 3000:3000\nvolumes:\n    mongodata:\n    grafanadata:\n    logs:\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:\n\n```js\nname: App CI\non:\n  push:\n    branches:\n      - \"*\"\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 20\n          cache: \"yarn\"\n      - run: yarn install --frozen-lockfile\n      - run: yarn run lint\n      - run: docker-compose up -d mongo\n      - run: yarn test -- --verbose --coverage\n      - run: docker-compose build\n      - run: docker-compose logs\n        if: always()\n      - run: docker-compose down --volumes\n        if: always()\n```\n\n# 결론\n\nNode.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.\n\nNode.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.\n\nGoogle의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!\n\nNode.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png","tag":["Tech"],"readingTime":21},{"title":"뉴욕시의 거리 나무 인구 변동을 GeoPandas, Plotly, 그리고 JavaScript를 사용하여 시각화하기","description":"","date":"2024-06-19 22:45","slug":"2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript","content":"\n\n## Plotly Dash 및 JavaScript를 사용한 서버 및 클라이언트 측 렌더링의 성능 비교\n\n![image](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png)\n\n이 문서에서 다음을 다룰 것입니다:\n\n- 미국 인구 조사국 및 뉴욕시 공원국의 데이터를 사용하여 1995년부터 2015년까지 NYC의 거리 나무 면책을 매핑합니다.\n- Pandas/GeoPandas 및 Plotly를 사용하여 데이터를 정리, 집계, 분석 및 시각화하는 방법을 안내하고, 웹 앱을 사용하여 데이터를 대화식으로 제시합니다.\n- 1995년부터 2020년까지 나무와 인구 밀도가 공간적으로 어떻게 변화했는지와 이러한 변화의 사회적 함의에 대해 논의합니다.\n- 이 기간 동안 도시 전역에서 블록 당 나무의 중앙값이 크게 증가했지만, 변화의 규모가 자치구별 및 지역별로 상당히 다르며 일부 지역에서는 나무가 감소하는 것을 알 수 있습니다.\n- 1995년 이후의 대상 나무 심는 노력이 적은 숲이었던 역사적으로 레드라인 지역에서 도시열섬 효과를 개선하지만, 젠트리피케이션에도 기여했음을 발견합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 이 웹 앱의 서버 및 클라이언트 측 렌더링(Plotly Dash 및 JavaScript 사용)의 성능을 비교해보고 간단한 대화형 데이터 시각화의 경우 클라이언트 측 렌더링이 가장 우수함을 발견했습니다.\n\n# 동기\n\n작년 가을, 친구가 뉴욕 시티의 다른 동네들 사이의 나무 면적의 차이에 관한 뉴욕 타임스 기사를 보내줬어요. 2016년부터 사는 뉴욕에서 이 기사는 특히 나에게 와닿았어요.\n\n그때 이 기사가 나에게 매우 중요했던 이유는, 그 해 여름 동안 시애틀에 있던 때 전체 태평양 연안이 ‘천년에 한 번 일어나는 1급 이벤트’로 평가될 정도로 극적인 폭염을 경험했기 때문이었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUrban Heat Island (UHI) 효과에 대해 알려줬어요. 도시보다 주변 농촌 환경에서 기온이 높아지는 현상이에요. 또한 뉴욕시와 그 이상 지역에서 레드라인, 같은 역사적인 차별 패턴에 따라 강렬하고 치명적인 여름 폭염 지역들이 어떻게 공간적으로 재현되는지 소개했어요.\n\n극지역 도시 열섬의 강도에서 주요 물리적 변수는 나무의 존재에요. 제가 항상 환경 정의에 관심이 있었고, 마지막 두 시장 행정 기간 동안의 나무 심기 노력과 주택 건설 증가를 고려할 때, 최근에 NYC(뉴욕시)의 UHI가 어떻게 변화했는지 이해하고 5개 자치구 전역에서 기후 탄력의 변화하는 지리를 이해하고 싶었어요. 구체적으로는 다음을 이해하고 싶었어요:\n\n- 나무와 인구의 추세가 어떻게 변화했는지\n- 시간이 흘러 나무와 인구의 변화가 주택 재편에 관련되어 있는지\n- 1995년에 도시에 비해 가장 적은 나무를 가진 지역이 오늘날에도 여전히 상대적으로 나무가 부족한지\n- 레드라인으로 분류된 지역이 1995년과 오늘날에 도시에 비해 나무가 덜 있는지\n\n우선, 데이터를 필요로 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 수집 및 정제\n\n나는 NYC Open Data를 찾아 공원 부서의 'Street Tree Census' 프로젝트를 발견했어. 이 프로젝트는 1995년, 2005년 및 2015년에 모든 거리 나무의 수동 인벤토리를 수행했어.\n\n나는 모든 데이터를 다운로드하고 탐색을 시작했어. 데이터 사전을 읽은 후, 인구조사 구로 거리 나무를 비교하는 것이 가장 합리적인 데이터 처리 방법임을 깨달았어. 왜냐하면 97%의 나무에 대해 인구조사 구가 제공되었고 국세 데이터와 쉽게 병합할 수 있기 때문이야. UHI가 공간적으로 어떻게 변화했는지 이해하고 그 크기와 수를 결정하기 위해, 나는 시간이 지남에 따른 나무의 공간 분포, 나무의 상대 풍부도 및 거리 나무 인구의 총 성장을 비교하기로 결정했어.\n\n또한, 지난 시간 동안 어디에 열섬이 있었고 현재 어디에 있는지 확인하고 싶었어. 열섬을 추적하고 시간이 지남에 따라 그 심각성이 변하는 것을 측정하기 위해, 나는 수거된 주민들의 인구가 나무 인구와 어떻게 분포 변화했는지를 이해할 필요가 있었어. 안타깝게도 거리 나무 인구 조사는 10년 주기의 인구조사 사이에 정확히 발생했기 때문에, 나는 매 나무 인구조사마다 이전 또는 이후의 인구 데이터를 사용할지 결정해야 했어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 각 나무 수를 센 후 인구 조사 데이터를 사용하기로 결정했습니다. 최근인 2020년 인구 조사의 데이터를 활용할 수 있어서였고, 도시의 나무 수가 증가 추세에 있었기 때문에 나무 수를 과소 추정하는 대신 사람 수를 과소 추정하는 것보다 나에게 더 적합하다고 생각했어요. 이렇게 하는 것이 기후 변화의 인간적 요소를 강조하고 싶었기 때문이죠. IPUMS NHGIS에서 2000년, 2010년, 2020년 인구 조사 정보를 다운로드했어요.\n\n첫 번째 단계는 인구 조사 구역별로 나무를 집계하는 것이었어요. 이 일이 보다 복잡하게 나타나기도 했는데, 대부분의 나무에 대해 인구 조사 구역 코드가 포함되어 있었지만, 이 코드들은 카운티 수준에서만 고유했어요. 뉴욕시의 각 자치구가 각자의 카운티인 것을 감안하면, 이는 코드가 도시 내에서 고유하지 않음을 의미했죠.\n\n공원 부서의 분들이 친절하게도 해결책을 제공해 주셨어요. boroct 또는 \"자치구 인구 조사 구역\"이라는 열이 포함되어 있었는데, 이 열은 변수 길이의 인구 조사 구역 코드를 여섯 자리 숫자로 변환하고, 해당 나무가 위치한 자치구를 나타내는 1, 2, 3, 4, 또는 5를 접두사로 붙였어요. 결과적으로, 이는 도시 수준에서 고유한 7자리 지리 식별자로 이뤄졌습니다.\n\nboroct가 2015년 인구 조사의 거의 모든 나무에 제공되었지만, 2005년과 1995년 인구 조사에는 인구 조사 구역 코드만 있고 boroct 항목이 없는 나무가 많았어요 — 2005년에 모든 나무 중 거의 20%였죠. 이 문제를 인코딩하는 짧은 함수를 작성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# borocode, 총 인구 조사 구 코드의 길이 및 문자열 형태의 인구 조사 구 코드를 입력하면 boro_ct를 반환하는 함수\n\ndef encode_boroct(bc, l, sct):\n    bct = np.where(l == 1, bc+\"000\"+sct+\"00\",\n                  np.where(l == 2, bc+\"00\"+sct+\"00\",\n                  np.where(l == 3, bc+\"0\"+sct+\"00\",\n                  np.where(l == 4, bc+sct+\"00\",\n                  np.where(l == 5, bc+\"0\"+sct,\n                  np.where(l == 6, bc+sct,\n                                    \"NaN\"))))))\n    return bct\n```\n\n일부 나무에는 인구 조사 구가 나와 있지만 인구 조사 구 코드가 없는 것이 있었기 때문에 해당 부분은 삭제되었고, 각 인구 조사 연도별 인구 조사 구당 나무 수를 세 개의 데이터프레임에 저장했습니다. 총 1995년, 2005년 및 2015년 데이터에서 나무의 97%에는 인구 조사 구가 지정되어 있었으며, 모든 나무가 최종 데이터프레임에 포함되었습니다.\n\n2010년 인구 조사 구 지정이 세 인구 조사 연도에 모두 사용되었기 때문에 이러한 구역의 shapefile을 GeoPandas GeoDataFrame으로 가져와 NYC를 위해 하위 집합으로 만든 다음, boroct를 사용하여 2015년 나무 수 데이터와 결합했습니다.\n\n그런 다음 boroct를 사용하여 왼쪽 외부 조인을 계속 적용하여 각 인구 조사 구에 대한 2015년, 2005년 및 1995년 나무 수뿐만 아니라 각 인구 조사 구의 구 이름, 면적 및 지오메트리를 포함하는 최종 데이터프레임을 만들었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 인구 조사 데이터를 정리했습니다. 상대적으로 단순한 분석을 하고 있었기 때문에 작업은 간단했습니다. 인구를 조사구 단위로 집계하고, 연이어 왼쪽 조인을 사용하여 각 인구 조사 연도별로 열을 가진 단일 DataFrame을 만들었습니다.\n\n마지막으로, 2020년 인구 조사 구역의 형상 파일을 가져왔습니다. 최신 인구 조사 데이터를 최대한 활용하고 싶었기 때문입니다. 인구 조사 구역 단위로 집계하고, 2020년과 2010년 구역 지정 간의 차이가 최소한으로 유지되도록 확인했습니다. 총 나무 수의 미약한 손실에 만족하고 — 총 나무 수의 1% 미만을 차지하는 인구 조사 구역이 약 5% 미만으로 유지되었기 때문에 — 완전한 트리 GeoDataFrame을 완전한 인구 GeoDataFrame에 결합하여 그래프용 최종 GeoDataFrame을 만들었습니다.\n\n이 최종 GeoDataFrame에는 1995년, 2005년 및 2015년의 트리 카운트와 2000년, 2010년 및 2020년의 인구 통계가 포함되었습니다. 이들은 인구 조사 구역 단위로 집계되었으며, 최종 열에는 각 구역의 토지 면적 및 동네 이름이 저장되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 몇 가지 지표가 필요했어요. 시간이 지남에 따라 토지 면적 당 나무를 의미 있는 방식으로 비교하기 위해, 도시 주민들에게 직관적인 토지 면적 단위를 고안하는 것이 필요했죠.\n\n인구 조사 보고서는 평방 미터로 토지 면적을 측정하지만 뉴욕 시민들은 도시 블록 단위로 생각하니까, 저는 표준 단위 블록을 정의하고 블록 당 나무 수를 보고하기로 결정했어요.\n\n조사 및 StreetEasy의 도움을 받아 데이터셋에 합리적인 나눗셈자로 작용하는 평균 블록 크기를 찾았고, 대부분의 블록이 1에서 40 그루의 나무를 보유하도록 결정되었죠. 나무 조사 연도별 블록 수로 변환하고 각 나무 조사 연도의 블록 수로 나무 수를 나누었어요.\n\n인간 중심적 맥락에서 나무 인구를 관련 지었기 때문에 세 인구 조사 연도 모두에 대해 \"인당 나무 수\" 지수를 계산했어요. 산업지역의 도시열섬은 여전히 생태학적으로 중요하지만 이러한 공간에서의 인구 감소로 인해 인간 건강에 미치는 영향의 규모는 상당히 감소되었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 프로젝트의 초점은 주로 인구 밀집 지역을 살펴보고, 나무 덮개가 증가함에 따라 인간 건강에 미치는 영향을 조사하는 것이었습니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_2.png)\n\n이러한 지수를 계산한 후에는 데이터를 자세히 분석할 준비가 되었습니다.\n\n# 탐색적 데이터 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n총으로 뉴욕시는 조사 기간 동안 15만 7천 그루 이상의 나무와 58만 7천 명의 사람이 증가했습니다. 지역 수준에서 2022개의 택트 중 1604개(79%)가 나무를 추가했고, 2022개의 택트 중 1505개(74%)가 사람을 추가했습니다. 이 데이터는 2020년 인구조사 기간 모든 택트의 95%와 나무의 96%를 대표합니다.\n\n게다가, 1995년부터 2015년까지의 나무 심는 노력을 통해 각 인구 조사 구역의 평균 나무 수가 15에서 22로 증가하고, 도시 전체의 인당 나무 수가 19에서 15로 감소했습니다.\n\n이러한 추세는 자치구 수준에서도 유지되지만, 나무와 사람이 추가된 수에는 자치구 간에 유의미한 차이가 있었습니다. 평균 인구조사 택트의 통계는 아래 표에 나와 있습니다:\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표를 보면, 브롱스가 해당 기간 동안 가장 빠른 성장을 경험했음을 알 수 있습니다. 브롱스는 블록 당 가장 많은 나무를 추가했고, 스테튼 아일랜드와 비슷한 수의 인구를 블록 당 추가했습니다. 스테튼 아일랜드의 중앙 센서스 트랙트는 브롱스의 거의 5배 크기입니다. 브루클린은 브롱스의 두 배 이상인 720개의 센서스 트랙트를 가지고 가장 많은 나무와 인구를 추가했습니다. 퀸즈는 가장 낮은 중앙 값 증가율을 보여주었는데, 그로 인해 나는 각 자치구별 통계를 자세히 살펴보게 되었습니다. 나무와/또는 인구가 감소한 트랙트의 소수를 중점적으로 살펴보니 몇 가지 추가적인 맥락을 얻을 수 있었습니다.\n\n다섯 자치구 중에서 퀸즈가 나무 총 수가 감소한 센서스 트랙트 비율이 가장 높았으며, 브롱스는 10%로 가장 낮았습니다. 흥미로운 점은 브롱스를 제외한 모든 자치구에서 나무를 잃은 대부분의 트랙트가 전체적으로 인구 증가를 경험했다는 것입니다.\n\n맨해튼에서는 센서스 트랙트의 34%가 인구 감소를 경험했지만, 그 트랙트 중 거의 80%에 공원이 추가되었습니다. 종합하면, 몇 가지 트렌드가 나타납니다: 맨해튼의 도시림이 상당히 증가했지만, 우연히도 인구 재배치는 UHI(도시 열섬) 리스크가 실질적으로 줄었음에도 불구하고, 이 혜택이 공간 또는 인구통계에 공평하게 분배되지 않았다는 점을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n퀸즈(Queens) 지역에서는 인구가 증가하고 나무가 줄어든 센서스 트랙트(census tracts)의 높은 비율(21%)은 새 주택 개발의 결과일 수 있지만, 이 가설을 확인하기 위해 추가 연구가 필요합니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_5.png)\n\n이러한 변화의 공간 분포를 살펴보면, 맨해튼(Manhattan), 퀸즈(Queens) 및 브루클린(Brooklyn)에서 나무 심는 노력의 불일치가 확인되며, 특히 각 자치구 내의 분산이 가장 크다는 것을 보여줍니다. 맨해튼(Manhattan)에서는 센트럴 파크(Central Park) 북쪽의 트랙트에서 그 자치구의 대다수 나무가 심어지는 반면, 그 공원 남쪽 및 동쪽에 위치한 트랙트들은 대부분 나무를 유지하거나 순수한 거리의 나무가 감소했습니다.\n\n브루클린(Brooklyn)에서는 전체 자치구 곳곳에 나무가 심어졌지만, Prospect Park 북쪽 및 동쪽 트랙트에 대부분의 나무가 심어졌으며, 나무가 감소한 소수의 트랙트는 대부분 공원 남쪽에 거의 일체로 위치해 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n퀸즈 지역에서는 나무 인구 변화가 하이퍼로컬라이즈되었습니다. 잭슨 하이츠와 아스토리아 같은 특정 지역과 남쪽의 글렌데일, 리치몬드 힐 및 오존 파크는 대부분의 지역이 도시 나무 인구 수가 정체되거나 약간 증가하는 반면 가로수의 인구가 감소하는 극적인 변화가 있었습니다. 스태튼 아일랜드는 전체적으로 나무를 추가했지만, 남단 브롱스의 급증 비율보다는 낮은 속도로 나무를 추가했습니다. 이러한 특이점 중 하나는 리버데일을 제외한 대부분의 센서스 지역에서 나무 인구가 크게 증가했습니다.\n\n1995년의 코로플렛을 살펴보면, 도시의 나무 심기 노력이 대부분 가로수가 부족한 지역에 집중되었음을 알 수 있습니다. 특히 남쪽 브롱스와 북부 맨하탄 지역이 그 예시입니다. 또한, 퀸즈 지역의 이전에 가장 극단적인 산림파괴를 경험한 지역들이기도 하면서 1995년에는 상대적으로 많은 가로수가 있는 지역이었습니다.\n\n1995년부터 2015년까지의 나무 심기와 제거 작업을 종합하면 도시 전체적으로 가로수의 풍부함이 균등해졌습니다. 이는 두 해의 블록 당 나무 히스토그램을 비교함으로써 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image1](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_7.png)\n\n![image2](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_8.png)\n\n환경 정의 측면에서, 지난 20년간의 나무 심는 노력은 확실히 시내 전역에서 레드라인의 시각적 유산을 줄였습니다. 리치먼드 대학의 역사적 레드라인 지도와 1995년의 거리 나무 분포를 비교하면 수십 년 전에 내린 결정이 지금까지도 도시 지리를 지속적으로 영향을 미치고 있다는 것을 명확히 보여줍니다:\n\n![image3](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_10.png\" /\u003e\n\n트리가 풍부한 거리를 완벽하게 대변하는 것은 아니지만, 레드라인 지역 여부와 그에 포함된 나무 수 간에는 분명한 관계가 있었습니다. 그러나 2015년까지 는 20년 동안의 주로 적은 숲이 있는 지역을 대상으로 한 거리에 나무를 심는 노력을 통해 이 상관관계가 줄어든 것을 알 수 있습니다. 아래에서 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_11.png\" /\u003e\n\n새로 심은 나무들은 적어도 한 측면에서 역사적인 잘못을 해소하는 데 성공했지만, 이러한 노력의 사회적 영향이 오로지 좋은 것만은 아닙니다. 상대적으로 신속한 도시 녹화는 분명히 만약 뉴욕(특히 맨해튼과 브루클린) 전역에서 특별히 내달리피케이션을 가속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 연구에서는 도시 내 녹지 공간의 증가와 젠트리피케이션 사이에 인과 관계를 발견했으며, NYC의 데이터를 보다 자세히 살펴보면 이 연결이 명백해집니다. Urban Displacement Project의 NYC에서의 젠트리피케이션과 이주 문제 지도는 1995년부터 2015년까지 가장 많은 나무를 심은 지역이 젠트리피케이션을 겪고 있는 동시에 저소득 가구를 이주하고 있다는 것을 보여줍니다.\n\n나무를 추가하면서 인구가 감소한 지역만 나타내는 지도는 부시윅, 크라운 하이츠, 윌리엄스버그, 아스토리아, 이스트 할렘, 워싱턴 하이츠, 그리고 사우스 브롱스와 같은 젠트리피케이션의 요충지를 강조합니다.\n\n또한, 블록 당 나무 수와 블록 당 인구 변화의 도시 전체 이차원 히스토그램은 인구 밀도와 나무 수 모두 약간 증가하는 대부분의 센서스 트랙트들의 거의 정규 분포를 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Visualization 1](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_13.png)\n\nWhen this distribution is mapped according to the borough, however, vast differences can be observed between boroughs.\n\n![Visualization 2](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_14.png)\n\nAs is shown above, Queens and Brooklyn had a much larger number of tracts decreasing their population density in the sampled period than did Staten Island, Manhattan, and the Bronx.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 변경은 퀸즈의 나무 밀도 변화와는 독립적으로 일어났지만, 브루클린에서는 거리에 심겨진 나무의 증가와 함께 주로 발생했습니다.\n\n인구 밀도 감소는 일대 일 대응의 개발 동향을 반영하는 것은 아니지만, 연구에 따르면 인구 밀도 감소는 가구 규모 축소에서 비롯된 도심 내 개발 현상의 결과입니다. 특히 브루클린에서는 특정 지역에서 춘추화에 기여하는 가로수 증가가 있을 확률이 높습니다.\n\n# 그래프 만들기\n\n프로젝트 시작부터 나는 결과물을 명확히 전달하는 가장 좋은 방법으로 나무 변화를 보여줄 수 있는 코로플레쓰 집합이 되기를 원했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코로플레스는 지역의 하위 구획이 일정 지표에 따라 색칠된 지리적 지도입니다. Plotly는 다양한 유형의 코로플레스를 지원하며 기본적으로 상호작용이 가능하며, 파이썬 인터페이스가 GeoPandas를 지원하여 이 프로젝트에 쉽게 사용할 수 있었습니다.\n\n지도를 만들기 전에 해야 할 결정이 있었어요: 데이터를 분위로 나눌지 여부입니다. 기본적으로 Plotly는 숫자 값을 연속적인 데이터로 해석합니다. 이것은 많은 데이터셋에서 작동하지만 경우에 따라 이상치가 색상 척도를 심하게 왜곡시켜 데이터의 의미 있는 차이를 줄일 수 있습니다. 이 결정을 내리기 위해, 기본적으로 그래프로 사용할 '블록 당 나무 개수' 지수의 히스토그램을 살펴보았습니다.\n\n위 그래프를 보면, 1995년에 인구 조사 구역 대부분은 블록 당 3에서 25그루의 나무를 가지고 있었습니다. 분포는 로그 정규 분포로 보이며, 범위 양 끝에 몇몇 이상한 인구 조사 구역이 있어 한 구역에서는 72그루, 다른 구역에서는 0.5그루의 나무를 가지고 있습니다. 데이터의 대다수를 더 의미 있게 나타내기 위해, 나는 그래프로 사용할 데이터를 이산적인 분위로 나누기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 클리닝 단계에서 생성한 데이터프레임을 가져와서 px.choropleth를 사용하여 트레이스 기반 지도(즉, 배경 지도 없이)를 만들었어. 나는 지도를 뉴욕 시를 중심으로 설정하고 첫 번째 초안을 렌더링했어:\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_16.png)\n\n보다시피, 뉴욕 시의 대부분의 땅 면적이 표시되어 있어. 그럼에도 불구하고 나는 그 위에 베이스 레이어를 추가함으로써 시의 다양한 인구조사 지역을 비교하고 대조할 수 있는 능력을 향상시키고, 주요 공원의 위치를 중요하게 표시할 수 있다고 느꼈어.\n\n개선된 지도:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_17.png)\n\n이렇게 하면 더 좋아 보이고 사용자에게 데이터의 공백이 어디에 있는지 이해하는 데 도와주며 이러한 공백의 중요성을 판단할 수 있게 합니다.\n\n지도에 있는 토목은 \"블록 당 나무\" 지수에 따라 색칠되어 있습니다. 하지만 이 지수와 함께 제시하고 싶었던 여러 측정 항목이 더 있어서 이를 마우스 오버 팝업에 포함시켰습니다.\n\n![이미지](/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_18.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 세 개의 그림을 만들었어요. 각각은 나무 인구 조사 연도를 나타냅니다. 추가적으로 1995년 이후 모든 통계의 누적 변화를 보여주는 추가 그림을 만들고 싶었어요. 2015년부터 1995년까지 각 인구 조사 구역의 나무 수의 차이와 2020년부터 2000년까지 해당 지역의 차이를 계산하여 '블록당 나무 변화' 및 '나무 당 인구 변화' 열을 만들었어요.\n\n이전과 마찬가지로 '블록당 나무 변화'의 분포를 조사하고, 이를 이산화하기로 결정하고 합리적인 분위수(총 9개)를 만들었어요. 색상 척도를 분위수에 맞게 조정하고 더 많은 정보를 수용할 수 있도록 hover 템플릿을 수정했어요. 새로운 템플릿은 다음과 같아요:\n\n마지막으로 NaN을 \"-\"로 대체한 다섯 번째 데이터프레임을 만들어 hover 템플릿에 전달했어요. Plotly 그래프 엔진에 전달되는 동일한 데이터프레임 내 NaN을 더 읽기 쉬운 문자로 대체하지 않으면, 이전에 설정한 이산화된 색상 구성에 문제가 발생할 수 있기 때문에 이 작업이 필요했어요.\n\n이렇게 해서 그래프들이 완성되었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모두 온라인에 올리기: Dash vs JavaScript 성능\n\n내 프로젝트를 온라인으로 올리기로 결심했다. 사용자들이 등대를 찾아보는 작은 Dash 앱을 만들기로 했다. 슬라이더와 로딩 스피너를 추가하는 데 시간을 투자했고, 로컬 머신에서 결과에 만족한 후에 Heroku Dyno를 설정하여 앱을 테스트했다. 다른 사람들은 이 과정을 자세히 설명했다.\n\n거의 즉시 서버 측 응답 시간에 실망했다. 내 최종 등대는 각각 14~40mb로 비교적 작았지만, 슬라이더를 이동한 후 각 개별 그래프를 수신하고 표시하는 데 Dyno가 최대 25초가 걸렸다. 이것은 일정한 3~4초의 서버 응답 시간과 매우 가변적인 12~22초의 데이터 전송 시간으로 분해되었다. 초기 로드 시간에 추가로 5~10초가 걸렸다.\n\n내 옵션을 고려했다. Heroku가 더 나은 서비스를 위해 더 많은 돈을 지불할 수도 있었지만, 나에게는 불필요하고 게으르게 보였다. 클라이언트 측 캐싱을 추가할 수도 있었지만, 이는 초기 데이터 전달의 느리움을 해결하지 못했다. 서버의 결과를 저장하여 해당 입력이 동일한 경우에 다시 함수를 호출할 때 검색할 수 있게 하는 캐싱 유형인 메모이제이션을 추가했지만, 이것은 서버 응답 시간만 향상시키고 처리량 문제는 해결되지 않았다. 등대의 크기를 줄일 수도 있었지만, 이는 호버 박스의 정보를 대폭 줄이는 것을 의미했을 가능성이 높았다 — 이것은 나에게는 프로젝트의 목적을 완전히 잃게 되는 것으로 보였다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, Dash 사용을 완전히 포기하기로 결정했습니다. 사용자가 시각화되는 데이터 세트를 수정할 수 없다는 것을 깨달았기 때문에 과도한 엔지니어링을 하고 있었다는 것을 깨달았습니다. 결과적으로 서버 응답이 전혀 필요하지 않았습니다. 대신, Plotly.py가 단지 JavaScript 라이브러리 Plotly.js를 위한 Python 인터페이스일 뿐이라는 사실을 이용했습니다.\n\nPython 전용 구현에 갇혀들지 않고, orjson을 사용하여 완성된 그림을 JSON으로 내보내고, Dash에서 구축한 기본 HTML, CSS 및 JS를 사용한 베어본 웹페이지를 복사했습니다.\n\n생성된 웹페이지는 초기 로드 시간이 짧지만 여러 그래프 간에 전환 시 지연이 없습니다. 사용자 관점에서 봤을 때 훨씬 더 원활한 경험을 제공합니다.\n\nHeroku 구현 사이트를 여기에서 확인할 수 있으며 JavaScript 구현을 여기에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n요약하자면 다음을 발견했습니다:\n\n- 1995년부터 2020년까지 거리의 나무와 인구 모두 전체 도시에서 증가했지만, 이러한 증가의 폭은 자치구 간 및 그 사이에 상당한 공간적 변동이 있었으며, 일부 지역은 한쪽 또는 양쪽 범주에서 큰 손실을 겪었습니다.\n- 특정한 나무 심기 노력은 과거 레드라인 지역에서 열도심화 효과를 완화시켰으나, 이러한 새로운 나무들은 게트리피케이션에 기여하는 부차적 효과를 가졌습니다.\n\n성능 측면에서 데이터를 \"오프라인\"으로 처리하고 결과를 저장하는 것이 매번 \"온라인\"으로 처리하는 것보다 나은 방법이라는 것을 발견했습니다. 즉, 정적 데이터 집합을 특징으로 하는 데이터 시각화의 경우 오프라인 구현이 항상 더 좋은 선택입니다. 이 분석은 인종, 연령, 소득 및 신규 주택 건설과 같은 추가적인 인구 변수를 포함하여 나무 심기의 사회적 영향과 패턴을 더 체계적으로 이해하는 데 확장될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인구 및 나무 데이터를 보간하면 이러한 변화에 대한 보다 전체적인 시간적 이해를 얻을 수 있으며, 특히 각 나무 조사 연도에 대한 보다 정확한 인구 추정을 얻을 수 있습니다.\n\n나무 위치의 지리적 정밀도를 높이는 것으로 더 정밀한 분석을 실시할 수 있으며, 위도 및 경도 좌표 또는 LIDAR 포인트 클라우드 모델을 통해 이루어지며, 이러한 지리적 위치 데이터와 위시각화함으로써 정확한 인구 추정을 얻을 수 있을 것입니다. 지리적 정밀도\n\n이 연구 및 분석은 도시 기획가들에게 유용할 것으로, 이들은 물리적 환경 변화가 이웃의 사회적 특성이 발전하는 데 기여할 것이라는 점을 알고 있어야 합니다.\n\n이 프로젝트의 코드를 찾아서 GitHub에 올리고 최종 시각화를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신은 제 LinkedIn에서 저를 찾을 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png"},"coverImage":"/assets/img/2024-06-19-VisualizingStreetTreePopulationVarianceinNYCUsingGeoPandasPlotlyandJavaScript_0.png","tag":["Tech"],"readingTime":15},{"title":"HTML과 CSS를 사용하여 반응형 헤더를 만드는 방법","description":"","date":"2024-06-19 22:43","slug":"2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png\" /\u003e\n\n안녕하세요, 이 기사에서는 웹사이트 구축시 필수 요소 중 하나 인 반응형 헤더를 만드는 방법에 대해 이야기하겠습니다. 이 기사에서 모든 코드와 세부 정보를 찾을 수 있습니다.\n\n```js\n\u003cdiv class=\"hero\"\u003e\n      \u003cnav\u003e\n        \u003cnav\u003e\n          \u003ch2 class=\"logo\"\u003eİlhan \u003cspan\u003eBal\u003c/span\u003e\u003c/h2\u003e\n        \u003c/nav\u003e\n    \u003c/nav\u003e\n    \u003c/div\u003e\n```\n\n우선, 코드를 body 태그 사이에 작성합니다. 첫 번째 단계에서 고유한 클래스 이름을 가진 div 태그를 만듭니다. 이 div 태그 내부에 2개의 nav 태그를 엽니다. 두 번째 nav 태그 내에서 로고를 추가하기 위해 고유한 클래스 이름을 가진 h2인 서브 태그를 생성합니다. 여기서 h2 태그를 사용했지만, 선호하는 경우 h1, h3 등을 사용할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_1.png)\n\n다음으로 진행하기 전에, 코드 블록에 요소들을 포함해야 합니다. 이를 위해 정렬되지 않은 목록 태그인 ul을 사용할 것입니다.\n\n```js\n  \u003cdiv class=\"hero\"\u003e\n      \u003cnav\u003e\n        \u003cnav\u003e\n          \u003ch2 class=\"logo\"\u003eİlhan \u003cspan\u003eBal\u003c/span\u003e\u003c/h2\u003e\n        \u003c/nav\u003e\n      \u003cul\u003e\n        \u003cli class\u003e\u003ca href=\"yeni.html\"\u003eHome\u003c/a\u003e\u003c/li\u003e\n        \u003cli class\u003e\u003ca href=\"about.html\"\u003eAbout\u003c/a\u003e\u003c/li\u003e\n        \u003cli class\u003e\u003ca href=\"contact.html\"\u003eContact\u003c/a\u003e\u003c/li\u003e\n        \u003cli class\u003e\u003ca href=\"galeri.html\"\u003eGallery\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n        \u003c/nav\u003e\n        \u003c/div\u003e\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드 블록에서 볼 수 있듯이, 우리는 ul 클래스를 생성하고 요소를 추가했습니다. 우리의 요소는 홈, 소개, 연락처 및 갤러리입니다. 사용자가 마우스로 클릭하면 이러한 페이지로 이동하기 위해 요소 수만큼의 HTML 사본을 만들고 요소 이름에 따라 이름을 지정합니다. 그런 다음 href=\"about.html\"과 같이 링크를 제공합니다.\n\n![이미지](/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_2.png)\n\n우리의 출력물은 이렇게 보여야 합니다.\n\n페이지 오른쪽 상단에 있는 버튼과 같은 버튼을 만들려면 “button” 클래스 이름을 가진 버튼을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nOur HTML code block is completed. Now we can use CSS to enhance the appearance of our page.\n\nIn the second step, create a file with a .css extension. To link our existing HTML file with the CSS file we created, place the following code block between the head tags of our HTML page.\n\n```html\n\u003chead\u003e\n\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eİlhan Bal\u003c/title\u003e\n\n    \u003clink rel=\"stylesheet\" href=\"app.css\"\u003e \n \n\u003c/head\u003e\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 CSS 파일에서의 업데이트가 페이지에 반영되는 것을 확인할 수 있습니다.\n\n```js\n*{\n    margin: 0;\n    padding:0;\n    box-sizing: border-box;\n    font-family: 'Poppins' , sans-serif;\n}\n.hero{\n    height: 100vh;\n    width: 100%;\n    padding-right: 111px;\n}\nnav{\n    margin-top: 20px;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding-top: 20px;\n    padding-left: 5%;\n    padding-right: 10%;\n}\n.logo{\n    color: white;\n    font-size: 32px;\n    margin-top: 0px;\n}\nspan{\n    color: #4070f4;\n}\nnav ul li{\n    margin-top: 32px;\n    display:inline-block;\n    list-style-type: none;\n    padding: 10px 20px;\n}\nnav ul li a{\n    color: white;\n    text-decoration: none;\n    font-weight: bold;\n    align-items: center;\n}\n\nbutton{\n    margin-top: 32px;  \n    border: none;\n    background: #4070f4;\n    padding: 2px 30px;\n    border-radius: 30px;\n    color: white;\n    font-weight: bold;\n    font-size: 15px;\n    transition: .4s;\n}\n```\n\n홈, 소개, 연락처 및 갤러리 요소 위에 마우스를 올리면 텍스트 색상과 커서를 변경하는 추가 단계를 적용해야 하며, 구독 버튼 위에 마우스를 올리면 커질 수 있도록 하고 다시 작아져야 합니다.\n\n```js\nnav ul li a:hover{\n    color: #4070f4;\n    transition: .3s;\n}\n\nbutton:hover{\n    transform: scale(1.1);\n    cursor: pointer;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트가 완료되었습니다. HTML과 CSS를 사용하여 반응형 헤더를 완성했습니다. 이제 라이브 미리보기를 확인해보세요.\n\n이 튜토리얼은 여기까지입니다. 유용하게 활용하셨기를 바라겠습니다.\n\n이제 HTML과 CSS를 사용하여 성공적으로 반응형 헤더를 만들었습니다. 이 프로젝트를 직접 사용하려면 IDE에 복사하세요. 프로젝트를 이해했기를 바라며, 의문이 있으시면 언제든지 댓글을 달아주세요!\n\n독자 여러분, 읽어주셔서 감사합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n태그를 마크다운 형식으로 바꿔보세요.\n\n| follow : @ilhanbal577\n\n| Written By : İlhan Bal\n\n| Code by : İlhan Bal\n\n# 웹사이트 안에 헤더 섹션을 넣는 장점은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 헤더는 웹 사이트의 여러 섹션을 이동하는 데 사용될 수 있습니다.\n- 헤더는 다른 섹션 링크를 포함하는 컨테이너입니다.\n- 사용 편의성을 제공합니다.\n- 시간을 절약할 수 있습니다.\n\n## 헤더는 반응형인가요?\n\n네, 헤더는 반응형으로서 화면 크기에 따라 헤더의 크기를 조절합니다.\n\n## 웹 사이트 내에서 헤더의 목적은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헤더는 사용자 상호작용을 촉진하고 편안한 환경을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-06-19-HowtocreatearesponsiveheaderusingHTMLandCSS_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트 버그 바운티 20 익스트림 에디션 2024","description":"","date":"2024-06-19 22:41","slug":"2024-06-19-JSforBugBounties20ExtremeEdition2024","content":"\n\n안녕하세요 여러분,\n\n인도 출신 Aditya Shende로 알려진 Kongsec입니다. 저는 바운티 헌터, 바이커, 연구원 및 트레이너입니다. 지난 5년 동안 버그 바운티에서 사람들을 교육하고 기사를 읽었을 때 항상 틈새를 발견했습니다. 무엇을 악용했는지와 어떻게 악용했는지를 공유하는 것은 매우 다릅니다. 많은 연구원들이 어떤 취약점을 악용했는지 공유하지만 어떻게 이러한 것들을 대규모로 찾을 수 있는 방법은 아직 숨겨져 있습니다.\n\n이 기사가 사람들이 버그를 더 많이 집중하는 대신 더 많은 기술을 공유하도록 영감을 주기를 바랍니다. 물을 불 지피자 🔥\n\n이 기사는 특별 기사를 위해 완전히 업그레이드된 버전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png\" /\u003e\n\n안녕하세요! 아래와 같이 다양한 도구를 사용하여 점프할 수 있어요:\n\n- hakrawler — 쉽고 빠른 웹 크롤러로, 웹 애플리케이션 내의 엔드포인트와 에셋을 빠르게 발견할 수 있어요.\n- crawley — 고랭로 작성된 빠르고 기능 풍부한 유닉스 스타일 웹 스크래퍼/크롤러에요.\n- katana — 차세대 크롤링 및 스파이더링 프레임워크에요.\n- LinkFinder — JavaScript 파일에서 엔드포인트를 찾아주는 파이썬 스크립트에요.\n- JS-Scan — php로 제작된 .js 스캐너로, URL 및 다른 정보를 크롤링하는데 사용돼요.\n- LinksDumper — 응답에서 (링크/가능한 엔드포인트)를 추출하고 디코딩/정렬을 통해 필터링하는데 사용돼요.\n- GoLinkFinder — 빠르고 간단한 JS 엔드포인트 추출기에요.\n- BurpJSLinkFinder — 엔드포인트 링크를 패시브 스캔하는 Burp Extension에요.\n- urlgrab — 웹사이트를 스패이더링하여 추가 링크를 찾는 고랭 유틸리티에요.\n- waybackurls — 도메인에 대해 Wayback Machine이 알고 있는 모든 URL을 가져와요.\n- gau — AlienVault의 Open Threat Exchange, Wayback Machine 및 Common Crawl에서 알려진 URL을 가져와요.\n- getJS — 모든 자바스크립트 소스/파일을 빠르게 가져오는 도구에요.\n- linx — JavaScript 파일 내에 숨겨진 링크를 드러내는데 사용돼요.\n- waymore — Wayback Machine에서 더 많은 정보를 찾기 위한 도구에요.\n- xnLinkFinder — 특정 대상에 대한 엔드포인트, 잠재적 매개변수 및 대상별 워드리스트를 찾는 데 사용되는 파이썬 도구에요.\n\n하지만 다른 사용자와 같은 파일을 받고 있어요. 중복되는 결과를 생성하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기 발견 내용은 다음과 같았어요\n\n하지만 만약에 이 단어들을 대상 도메인에 대한 무차별 대입(bruteforce)해본다면 어떨까요? 아니면 당신이 추적 중인 어떤 대상에 대해서도요.\n\n여기 테스트를 위해 수집한 기본 단어 목록이 있어요:\n\ndialogs540f334e628dbce748a8js navigation_secondary55dfd8fe215f8edecd48js dialogsb18150a252f68f70f0c9js navigation_secondary147987372ed67d94de50js buttons147987372ed67d94de50jsnpmangular-animate8f9be52ce8a521f715a3js mainb18150a252f68f70f0c9js navigation7b5ba7de4b5e5fb011c7js dialogs147987372ed67d94de50js appmain7b5ba7de4b5e5fb011c7js main147987372ed67d94de50js buttons7b5ba7de4b5e5fb011c7jsnpmangulary-focus-store9327d7778ee0d85c3500js mainfb562f3396222d196abfjs breeze7b5ba7de4b5e5fb011c7js breezeb18150a252f68f70f0c9js breeze30886581e43164d9d721js breeze147987372ed67d94de50js navigationb18150a252f68f70f0c9js appmain147987372ed67d94de50js breezeee32c0b1526644e9b562js main7b5ba7de4b5e5fb011c7js dialogs7b5ba7de4b5e5fb011c7js navigationba64bbac173b1d655721js navigation147987372ed67d94de50js navigation_secondaryb18150a252f68f70f0c9js buttonscf9c75fee1de19837ae7js appmainb18150a252f68f70f0c9js navigation_secondary7b5ba7de4b5e5fb011c7js modalsb0f4a82ac6f25a46dc71js npmangular-ui-calendar423a597b943dc586730dns npmapollo-angular-link-httpe7a942f9925da8411a4ejsnpmangular-ui-switch90766204ecd17b03ca76js appmainaf9ea97e6139d8cd52c2js npmapollo-angular-link-http-common87eff82eb4bc194887bfjs npmapollo-angular22f1de8a666515c86242js npmapollo-cache53668769616dc1466d8js npmapollo-cache-inmemorydaeb4f1b88a15680fd12js buttonsb18150a252f68f70f0c9js npmangular-ui-bootstrapcd3d849d20f1a4f7dfacjs configjs npmattr-accept81d56f5e133bac14feb5js npmapollo-clientf1fffac92f44507c8f3ajs npmbase64-js61d2367f7816d6fec60fjs npmapollo-utilities9e092209349bda108468js npmaxiosb02cc1c0e336b6ce9d09js app147987372ed67d94de50js npmauth0b681a646eef51d083006js npmbraintree24d4f13fb9a355dadc24js npmbabel5fd8b43fabbd6864e9a2js npmcall-bind0f09a0bd48e4dac9d679js npmbreeze-client-labs03a64fb13d406c33bbc8js appaf9ea97e6139d8cd52c2js npmavailable-typed-arrays558d90654f4d4fc2aa04js npmcharacter-entities-legacy7f4022465f0c9c4a6fabjs npmblueimp-load-image3d0d2393c631d92c5a1ejs npmchartjs-color-stringbd3a54729bf6f60404afjs npmapollo-linka5d82a3252db6d3e8d15jsnpmaria-hiddena316c352eb617c047815js npmckeditorfde05d6a29366eaf2c71js npmcollapse-white-spacebdd075f4c3faca5c940fjs npmcharacter-reference-invalid2f9cdaeeea24c3f3897ejs npmbail2e238f58e0858fcf0e31js npmcolor-convert101a98cb8d9df306dc12js npmchartjs-color703b6867120bd9ebf784js npmbreeze-client75c1a11b2c8e46de7ce4js\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 명령어를 사용하여 새로운 대상에 대한 단어 목록을 사용할 수 있습니다.\n\n하는 방법은 다음과 같습니다:\n\nwaybackurls \"site.com\" | grep -Eo 'https?://[^/]+/[^\"]+\\.js' | sed 's|^https\\?://[^/]\\+/||' | awk -F '/' 'print $NF'\n\n\n명령어의 각 부분을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- waybackurls \"example.com\": 해당 명령어는 Wayback Machine 아카이브에서 \"example.com\"과 관련된 URL을 검색합니다.\n- grep -Eo `https?://[^/]+/[^\"]+\\.js`: 이 명령어는 .js 확장자를 가진 URL을 검색합니다. -E 플래그는 확장 정규 표현식을 활성화하고, -o 플래그는 grep이 일치하는 부분만 출력하도록 지시합니다.\n- sed `s|^https\\?://[^/]\\+/||`: 이 몤령어는 각 URL에서 프로토콜(http:// 또는 https://)과 도메인 이름을 제거하고 경로만 남깁니다.\n- awk -F `/` `'print $NF'`: 이 명령어는 URL을 /로 분할한 뒤 각 URL의 마지막 부분을 추출하여 도메인 부분을 제거합니다.\n\n따라서, 이 명령어를 실행하면 도메인 이름을 제외한 아카이브 스냅샷에서 추출된 .js 엔드포인트 목록이 제공됩니다. \"site.com\"을 원하는 도메인으로 대체하십시오. \n\n![2024-06-19-JSforBugBounties20ExtremeEdition2024_1](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_1.png)\n\n![2024-06-19-JSforBugBounties20ExtremeEdition2024_2](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 키워드가 새롭고 독특하다는 것을 확인할 수 있어요. 하나의 대상에서 JS 단어 목록을 정리하고 이를 새로운 대상에 활용할 수 있어요. 예를 들어,\n\n우리는 dell.com에서 JS 단어를 얻어서 data.samsung.com에서 사용했어요. 새로운 파일들, 스택 오류, 디렉터리 목록에 유용할 거예요.\n\n![JSforBugBounties20ExtremeEdition2024](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_3.png)\n\n우리는 최종적으로 새로운 대상에서 매우 새로운 JS 파일들을 얻을 수 있어요. 크기, 데이터 유형, 내용 등을 기준으로 정렬할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동일한 키워드를 쇼단에서 얻은 IP에 적용할 수 있습니다.\n\n![이미지1](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_4.png)\n\n![이미지2](/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_5.png)\n\n나머지 공격은 마찬가지지만 작은 수정점이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncurl -s https://app.site.com/config.js |\ngrep -E “environment: ‘Production’|storageUrl: ‘https://buildxact.blob.core.windows.net/’|googleApiKey: ‘|appInsightsInstrumentationKey: ‘|globalApiEndpoint: ‘|streamChatApiKey: ‘|auth0ClientId: ‘|auth0Domain: ‘|flatfileApiKey: ‘|webSpellCheckerServiceId: ‘|webSpellCheckerServiceUrl: ‘|clientPortalUrl: ‘|appVersion: ‘|appVersionDate: ‘|appDomainUrl: ‘|oneBuildKey: ‘|flatfilePlatformPublishableKey: ‘|flatfilePlatformEnvironmentId: ‘“ |\nsed “s/.*’\\([^']*\\)’.*/\\1/”\n\n\nWe can add the words which we think are sensitive here:\n\nExample:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식의 표입니다.\n\n\n| 변수명                           | 값                   |\n|------------------------------------|---------------------|\n| ANACONDA_TOKEN                    |                     |\n| ANALYTICS                         |                     |\n| ANDROID_DOCS_DEPLOY_TOKEN         |                     |\n| android_sdk_license               |                     |\n| android_sdk_preview_license       |                     |\n| ANSIBLE_VAULT_PASSWORD            |                     |\n| aos_key                           |                     |\n| aos_sec                           |                     |\n| API_KEY_MCM                       |                     |\n| API_KEY_SECRET                    |                     |\n| API_KEY_SID                       |                     |\n| API_KEY                           |                     |\n| API_SECRET                        |                     |\n| APIARY_API_KEY                    |                     |\n| APIDOC_KEY                        |                     |\n| APIGW_ACCESS_TOKEN                |                     |\n| apiKey                            |                     |\n| apiSecret                         |                     |\n| APP_BUCKET_PERM                   |                     |\n| APP_ID                            |                     |\n| APP_NAME                          |                     |\n| APP_REPORT_TOKEN_KEY              |                     |\n| APP_SECRETE                       |                     |\n| APP_SETTINGS                      |                     |\n| APP_TOKEN                         |                     |\n| appClientSecret                   |                     |\n| APPLE_ID_PASSWORD                 |                     |\n| APPLE_ID_USERNAME                 |                     |\n| APPLICATION_ID_MCM                |                     |\n| APPLICATION_ID                    |                     |\n| applicationCacheEnabled           |                     |\n| ARGOS_TOKEN                       |                     |\n| ARTIFACTORY_KEY                   |                     |\n| ARTIFACTORY_USERNAME              |                     |\n| ARTIFACTS                         |                     |\n| ARTIFACTS_AWS_ACCESS_KEY_ID       |                     |\n| ARTIFACTS_AWS_SECRET_ACCESS_KEY   |                     |\n| ARTIFACTS_BUCKET                  |                     |\n| ARTIFACTS_KEY                     |                     |\n| ARTIFACTS_SECRET                  |                     |\n| ASSISTANT_IAM_APIKEY              |                     |\n| ASYNC_MQ_APP_SECRET               |                     |\n\n\nJS URL을 얻으면 nuclei 노출 태그를 사용하여 더 많은 민감한 정보를 얻을 수 있습니다.\n\njs.txt 파일에서 노출 태그를 사용하여 Nuclei 명령을 실행하려면 다음 명령어를 사용하실 수 있습니다:\n\n```bash\nnuclei -l js.txt -t ~/nuclei-templates/exposures/ -o js_exposures_results.txt\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 명령어 각 부분에 대한 설명입니다:\n\n- nuclei: 이것은 빠르고 사용자 정의 가능한 취약점 스캐너 인 Nuclei를 실행하는 명령어입니다.\n- -l js.txt: -l 플래그는 Nuclei와 함께 스캔할 URL 목록이 포함된 파일(js.txt)을 지정합니다.\n- -t ~/nuclei-templates/exposures/: -t 플래그는 노출 태그에 대한 Nuclei 템플릿 디렉터리 경로를 지정합니다. 실제 Nuclei 템플릿이 저장된 경로에 맞게 경로 ~/nuclei-templates/exposures/를 조정하십시오.\n- -o js_exposures_results.txt: -o 플래그는 스캔 결과가 저장될 출력 파일(js_exposures_results.txt)을 지정하는 데 사용됩니다. 원하는 출력 파일 이름으로 js_exposures_results.txt를 대체할 수 있습니다.\n\nExploitation은 동일하게 유지되며 이 문서를 참조할 수 있습니다. 읽어 주셔서 감사합니다.\n\nJai Shree Ram","ogImage":{"url":"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png"},"coverImage":"/assets/img/2024-06-19-JSforBugBounties20ExtremeEdition2024_0.png","tag":["Tech"],"readingTime":10},{"title":"웹 콘텐츠를 더 빠르게 전달하는 새로운 패러다임들","description":"","date":"2024-06-19 22:38","slug":"2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster","content":"\n\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_0](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png)\n\nReact, Svelte, Vue 등 구성 요소 기반 프레임워크가 나오기 전에는 모든 콘텐츠를 서버에서 렌더링하는 것이 보편적이었습니다. 그때는 웹 사이트를 탐색하는 것이 서버로 여러 요청을 하게 되어 HTML, CSS 및 JS로 렌더링된 내용을 다시 웹 브라우저로 보내는 것이었습니다. 이를 서버 사이드 렌더링 (SSR)이라고 합니다.\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_1](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_1.png)\n\n이후 React 및 다른 구성 요소 기반 프레임워크들이 나오면서 조금 덜 일반적인 클라이언트 사이드 렌더링 (CSR) 방법이 개발자들의 가장 선호하는 선택이 되었습니다. 개발자들은 싱글 페이지 애플리케이션을 만들고, 렌더링 콘텐츠의 책임을 서버에서 브라우저로 옮기는 경향을 보였습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![TheEmergingParadigmsforDeliveringWebContentFaster_2](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_2.png)\n\n이러한 유형의 CSR은 시간이 지남에 따라 지나치게 발전되었습니다. 웹 사이트에서 애플리케이션의 모든 렌더링 논리를 브라우저로 보내는 것이 드문 일이 아닙니다. 문제는 JavaScript가 바이트 단위로 볼 때 브라우저에서 가장 느린 파일을 불러오는 것입니다. 서버는 사용자에게 정적 HTML로 콘텐츠를 렌더링하는 데 더 많은 리소스를 활용할 수 있으며 해당 콘텐츠를 더 빠르게 받을 수 있습니다. 제가 Islands Architecture에 대한 내 문서를 읽었다면 다른 옵션 몇 가지를 이미 알고 있을 것입니다.\n\n그러나 클라우드 컴퓨팅의 등장으로 인해, 클라이언트와 애플리케이션 서버만 고려해야 하는 것보다 더 많은 고려해야 할 사항이 있습니다. 정적 콘텐츠의 전달 속도를 높이는 데 도움이 되는 다른 글로벌 사용 가능한 기술이 있습니다.\n\n이 기사에서는 클라우드를 활용하여 정적 및 동적 콘텐츠의 캐싱 및 렌더링을 가속화하는 최근의 패러다임 중 하나인 정적 사이트 생성, 컨텐츠 전송 네트워크 및 Edge Computing에 대해 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 정적 사이트 생성 (SSG)\n\nSSR 및 CSR과 마찬가지로, 정적 사이트 생성은 웹 사이트를 HTML 콘텐츠로 렌더링하는 또 다른 방법입니다.\n\n## SSG란?\n\nSSG는 클라이언트 요청을 받기 전에 HTML을 미리 렌더링하는 방법입니다. SSG는 서버사이드 렌더링과 대조적으로 페이지가 빌드 타임에 정적으로 렌더링되므로 클라이언트가 서버에 요청할 때가 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_3.png\" /\u003e\n\n이 방법에는 몇 가지 장점이 있습니다. 클라이언트가 서버로부터 웹페이지를 요청할 때, 자동적으로 해당 콘텐츠로 응답할 수 있습니다. 렌더링이 필요하지 않습니다. JavaScript는 이미 정적 HTML로 변환되어 클라이언트로 직접 전송할 수 있습니다.\n\n## CSR 및 SSR의 단점 해결\n\n정적 사이트 생성은 SSR과 CSR의 문제를 해결하기 위한 솔루션으로 등장했습니다. SSR은 Time to First Byte (TTFB)가 낮다는 문제가 있습니다. 간단히 말해서, SSR 웹사이트를 요청하는 경우 서버에서 해당 웹페이지를 각 요청에 대해 렌더링해야 하므로 서버에서 느린 응답을 받을 수 있습니다. 반면에 CSR은 브라우저가 웹페이지 콘텐츠를 생성하는 데 걸리는 시간과 해당 생성된 콘텐츠가 상호작용 가능해지는 데 걸리는 시간인 First Contentful Paint (FCP), Largest Contentful Paint (LCP), Time to Interactive (TTI)가 더욱 느릴 수 있습니다. 이러한 지표는 브라우저가 웹페이지 콘텐츠를 생성하는 데 얼마나 오래 걸리는지 및 생성된 콘텐츠가 상호작용 가능해지기까지 얼마나 걸리는지를 측정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_4.png\" /\u003e\n\nSSG란 각 웹 사이트 경로에 대해 미리 HTML 파일을 생성하여 FCP, LCP 및 TTI가 빨라지도록 하는 것입니다. 내용은 이미 렌더링되어 있으며 요청이 발생할 때 서버에서 로직을 수행할 필요가 없어 TTFB가 더 빨라집니다. 내용은 서버나 CDN에 캐시될 수도 있어 매우 빠른 응답이 가능합니다. SSG는 자주 변경되지 않는 정적 콘텐츠에 이상적입니다. FAQ나 About 페이지와 같은 내용에 적합합니다.\n\n## SSG의 함정\n\n정적 사이트 생성은 데이터가 필요한 페이지에도 적용 가능합니다. 이 데이터는 빌드 시간에 HTML에 통합됩니다. 뉴스 기사나 블로그 게시물을 다루는 웹 사이트에서 해당될 수 있습니다. 안타깝게도, 이러한 경우는 SSG의 주요 단점 중 하나인 것을 강조합니다: 변경이 발생할 때마다 전체 페이지를 재구축해야 하며 캐시된 HTML 파일이 무효화됩니다. 이는 SSG가 매우 동적인 콘텐츠에 대해 최상의 선택이 아닐 수 있다는 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_5.png)\n\n또한, 사이트의 경로가 많다면 많은 사전 렌더링된 HTML 사이트가 필요할 수 있습니다. 예를 들어, 모든 블로그 게시물을 SSG를 통해 렌더링하는 경우 많은 HTML 파일을 저장할 수 있습니다. 기본 코드베이스에 변경 사항이 발생할 때마다 전체 사이트를 재구축하고 다시 배포해야 한다는 점을 기억하세요. 오타를 수정해야 할 때마다 사이트를 다시 배포해야 한다고 상상해보세요.\n\n## 증분 정적 사이트 생성 (iSSG)\n\nNext.js와 같은 프레임워크에서 제공하는 증분 정적 사이트 생성 (iSSG)을 사용하여 이러한 문제 중 일부를 해결할 수 있습니다. iSSG를 사용하면 서버가 백그라운드에서 사이트에 페이지를 업데이트하고 추가할 수 있으면서도 클라이언트 요청을 처리할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_6.png)\n\niSSG를 사용하면 페이지가 빌드 시간이 아닌 첫 요청 시 생성됩니다. 첫 번째 사용자는 서버가 페이지를 빌드할 때 약간의 지연된 응답을 받습니다. 그런 다음 서버는 페이지를 캐시합니다. 그 후의 요청은 이미 빌드되어 있기 때문에 캐시된 사전 렌더링된 HTML 페이지를 보다 빠르게 받을 수 있습니다. 이는 한 형태의 레이지 로딩입니다.\n\niSSG를 사용하면 만료 시간을 설정해야 합니다. 이후 서버가 페이지를 백그라운드에서 다시 생성합니다. 페이지가 재생성된 후에는 이전의 사전 렌더링된 HTML 복사본이 캐시에서 삭제되고 새 복사본이 이후 요청에 제공됩니다. 이는 상태 갱신 중 사용자가 백그라운드에서 HTML을 재생성하는 동안 사용자에게 이전 페이지가 제공되는 'stale-while-revalidate' 전략의 한 예입니다.\n\n# 컨텐츠 전송 네트워크 (CDN)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콘텐츠 전달 네트워크인 CDN은 정적 웹 콘텐츠의 전달을 혁신적으로 개선했습니다.\n\n## CDN이란?\n\n![CDN](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_7.png)\n\nCDN은 매우 간단한 개념입니다. 지리적으로 분산된 서버 네트워크로, 빠르게 콘텐츠를 최종 사용자에게 제공할 수 있습니다. 네트워크 작업을 하는 사람이라면 거리가 요청-응답 주기의 속도에 가장 큰 장애물 중 하나라는 것을 알고 있습니다. CDN은 클라이언트와 콘텐츠 사이의 거리를 제한합니다. 이는 서버가 전 세계 여러 데이터 센터에 존재하기 때문입니다. 이러한 센터들은 정적 콘텐츠를 메모리에 캐시하고, 그런 다음 요청 시 전달하며, 보통 소액의 요금으로 이용 가능합니다. Amazon CloudFront, Akamai, CloudFlare와 같은 예시가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SSG, iSSG 및 CDNs\n\nSSG 및 iSSG로 만든 정적 웹 콘텐츠는 CDN에 이상적이며 글로벌 규모에서도 콘텐츠를 전달하는 데 다음 수준의 속도를 제공할 수 있습니다.\n\nSSG 및 CDN을 사용한 전통적인 배포에서는 오리진 서버가 정적 페이지를 빌드하고 CDN으로 캐시할 것을 보냅니다. 사이트가 재구축될 때마다 CDN 캐시를 업데이트해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niSSG를 사용하면 CDN이 클라이언트 요청시 오리진 서버와 더 직접적으로 상호작용합니다. iSSG를 사용하면 페이지는 첫 요청시 빌드되며 만료될 때 백그라운드에서 다시 빌드됩니다. 클라이언트가 요청하면 CDN이 해당 페이지가 캐시되어 있는지 확인합니다. 캐시되어 있다면 해당 페이지를 클라이언트에 제공합니다. 그렇지 않으면 오리진 서버에서 페이지를 요청하고, 서버가 페이지를 빌드하면 해당 페이지가 CDN에 캐시되어 사용자에게 제공됩니다.\n\n첫 번째 사용자만 느린 응답을 받을 수 있습니다. 그 이후에는 일부 사용자가 지난 페이지에 대해 만료된 후 상태 정보를 받을 수 있습니다. 만료는 캐시 제어 HTTP 헤더의 max-age 속성을 사용하여 설정됩니다. Express.js를 사용하여 문서의 최대 나이를 설정하는 예시를 보여드리겠습니다:\n\n```js\nres.set('Cache-Control', 'public, max-age=120');\n```\n\nmax-age는 초 단위로 설정됩니다. 위 예시에서는 2분 후에 캐시된 사전 렌더링된 HTML을 무효화합니다. 그 후에는 iSSG를 통해 CDN이 새로운 페이지를 요청하지만, 오리진 서버가 백그라운드에서 요청을 처리함에 따라 만료된 페이지를 계속 제공합니다. 사용자는 일부 만료된 정보를 받을 수 있지만, CDN의 응답은 정적 및 동적 콘텐츠 모두에 대해 매우 빠릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 엣지 컴퓨팅\n\n지금까지 SSG와 iSSG가 CDN 캐시에서 빠르게 제공될 수 있는 정적, 사전 렌더링된 HTML 페이지를 만들 수 있다는 것을 살펴보았습니다. 그러나 이러한 예제에서는 클라이언트 요청이 여전히 원본 서버와 간접적으로 상호작용하고 있습니다. 페이지는 여전히 원본 서버에서 렌더링되고 CDN에서 제공됩니다. 중간 단계 없이 진행할 수 없을까요? 이 접근 방식을 유지하면서 CDN의 전역 아키텍처를 최적화할 수 있을까요?\n\n네, 가능합니다. 답은 엣지 컴퓨팅이라고 불리는 것에 있습니다.\n\n## 엣지 컴퓨팅이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Edge computing](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_9.png)\n\n에지 컴퓨팅은 IoT와 웹 애플리케이션 개발에서 부상하고 있는 패러다임입니다. 사용자에 가까운 위치에 컴퓨팅 로직과 데이터를 가져오려고 노력합니다. 클라우드와 마찬가지로 글로벌 아키텍처를 추구합니다. 그러나 클라우드와 달리 응용프로그램을 위한 상태 없는 분산 컴퓨팅 성능을 추구합니다.\n\nCDN 서버가 이 패러다임에 완벽하게 들어맞는 모습을 볼 수 있습니다. 이 서버들은 거의 웹 서버처럼 작동하여 클라이언트 요청에 응답하지만 많은 데이터 센터에 전 세계적으로 배치되어 정적 콘텐츠를 최대한 사용자에게 가까이 가져옵니다. CDN 서버의 근접성은 요청과 응답이 웹 페이지를 렌더링하는 데 필요한 거리를 줄이므로 전송 속도에 막대한 혜택을 제공합니다.\n\n![CDN servers](/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_10.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에지 컴퓨팅은, 애플리케이션 서버에 의해 점진적으로 업데이트되어야 하는 정적 콘텐츠를 넘어보며 개발자들이 에지 서버에서 자체 코드를 실행할 수 있게 합니다. 예를 들어, 정적 콘텐츠는 미리 렌더링되어 CDN 캐시에 저장될 수 있고 CDN의 에지 서버에서 실행할 수 있는 스크립트와 함께 저장될 수 있으며 먼 오리진 서버가 아닌 CDN의 에지 서버에서 실행될 수 있어 클라이언트 요청에 따라 진정한 동적 콘텐츠가 생성될 수 있습니다. 이것은 동적 콘텐츠를 캐싱하는 한 가지 방법입니다.\n\n에지는 CDN에만 한정되지 않습니다. 사용자의 기기나 로컬 네트워크에서 데이터를 처리하는 것이나 클라우드가 아닌 곳에서 처리하는 것이 될 수 있습니다. 이에는 사용자의 휴대폰이나 여러 IoT 장치가 포함될 수 있습니다.\n\n## 장단점\n\n에지 컴퓨팅은 정적 및 동적 콘텐츠를 사용자에게 최적화하는 방법이 많이 있습니다. 이러한 성능상의 이점은 이미 분명합니다 - 에지 위치의 근접성으로 인해 사용자가 응답을 받는 데 걸리는 시간이 줄어듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_11.png\" /\u003e\n\n성능 향상뿐만 아니라 이 패러다임은 비용 절감과 증가하는 보안을 제공합니다. 특히 IoT 기기로 콘텐츠를 전달하거나 데이터를 처리할 때 더욱 그렇습니다. 현재 전 세계 가정에 설치된 750억 개 이상의 IoT 기기로 인해 이전보다 훨씬 많은 데이터가 생성되고 있습니다. 모든 이 데이터를 원본 서버로 전송하여 처리하는 것은 시간이 오래 걸리고 비용이 많이 드는 작업일 것입니다. 이 데이터 중 일부는 민감할 수도 있고 시간이 중요한 경우도 있습니다. 엣지 컴퓨팅을 통해 사용자가 생성한 데이터와 가능한 가까운 곳에 유지할 수 있습니다. 사용자나 비즈니스 데이터의 실시간 처리도 가능합니다.\n\n그러나 기본 웹 콘텐츠의 전달에 엣지 컴퓨팅이 최적의 선택이라고 할 수는 없습니다. 이는 신흥 분야이며 엣지에서 일부 기술이 다른 기술(예: 서버리스 함수 등) 대비 40%의 속도 향상을 보여주기는 했지만, 여전히 단점도 있습니다. 예를 들어 데이터베이스를 쿼리해야 하는 경우 엣지에서 요청하는 것이 지연을 증가시킬 수 있습니다. 이는 데이터베이스가 원본 서버보다 엣지 위치에서 더 멀리 있을 수 있기 때문입니다. 이 차이를 줄이기 위한 몇 가지 엣지 데이터베이스는 이미 있지만, 이러한 기술들은 아직 초기 단계에 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_12.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게다가, 엣지 컴퓨팅은 민감한 데이터가 네트워크를 통해 전송되는 양을 줄이는 것으로 일부 보안 이점을 가질 수 있지만, 더 많은 공격 대상을 노출시킬 수도 있습니다. IoT 장치는 특히 공격에 취약한데, 이는 그들의 창조자들이 항상 보안을 최우선으로 하지 않기 때문입니다. 우리는 모두 해커들이 가정용 보안 카메라나 베이비 모니터를 해킹하는 동영상을 본 적이 있습니다. 이러한 공격은 특히 경고적이지만, 많은 민감한 데이터의 보안 침해가 IoT 장치에서 발생하고 완전히 눈에 띄지 않을 수 있습니다. 이러한 공격은 사용자의 개인 정보에도 심각한 피해를 줄 수 있습니다. 침해된 장치는 심지어 봇넷을 생성하고 웹 서버에 DDOS 공격을 발동할 수도 있습니다.\n\n# 신흥 패러다임\n\n현대 사회에서 분권화는 커지는 추세인 것으로 보입니다. 웹 콘텐츠 전달은 기술의 분권화의 다음 단계일 수 있습니다. 결국, 우리는 엔드 사용자에 가능한 한 가까운 곳에 있는 엣지 데이터베이스에 저장된 사용자 데이터가 엣지 서버와 상호 작용하여 개인화된 콘텐츠를 생성하는 것을 볼 수 있을 겁니다. 이러한 사용자 경험은 더 빠르고 더 상호 작용적이며, 희망적으로 더 안전할 것입니다.\n\n지금 당장, 개발자이면 CDNs와 기본적인 엣지 컴퓨팅을 탐험해보는 것이 좋습니다. 이미 사용 가능한 옵션인 Lambda@Edge나 Vercel Edge Functions과 같은 것은 동적 콘텐츠를 엔드 사용자에게 더 가까운 곳에 캐싱함으로써 성능과 보안을 향상시키고 비용을 절감하는 데 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSG 또는 iSSG에 대해 더 알고 싶다면, patterns.dev를 방문해보세요. 그곳에서 이 주제에 대해 더 깊이 파고들어 설명하고 있어요. Edge 컴퓨팅에 대해 더 알고 싶다면, Vercel Edge Functions나 AWS의 Lambda@Edge를 살펴보세요.","ogImage":{"url":"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png"},"coverImage":"/assets/img/2024-06-19-TheEmergingParadigmsforDeliveringWebContentFaster_0.png","tag":["Tech"],"readingTime":9},{"title":"타입스크립트에서 제네릭 마스터하기 유연하고 안전하며 중복이 없는 코드 작성","description":"","date":"2024-06-19 22:37","slug":"2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode","content":"\n\n![이미지](/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png)\n\n## 소개\n\nTypeScript의 제네릭은 소프트웨어의 견고성과 확장성을 향상시키는 뿐만 아니라 any를 대체함으로써 유형 정확성을 향상시킵니다. 이 개념은 TypeScript에만 한정되지 않고 Swift, Java, C#, C++ 등 다른 프로그래밍 언어에서도 널리 채택되었습니다.\n\n## 제네릭 미사용 방법 대 제네릭 사용 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction logInformations\u003cT\u003e(infos: T): T {\n  return infos;\n}\n\nlogInformations\u003cnumber\u003e(1234);\nlogInformations\u003cstring[]\u003e(['React Native', 'TypeScript']);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제네릭을 사용하면 logInformations 메서드를 이제 모든 데이터 유형과 함께 사용할 수 있어 코드 중복을 피하고 유연성을 제공할 수 있습니다. 이는 개발을 간소화할 뿐만 아니라 더 견고하고 확장 가능한 코드를 보장하여 유형 정확성을 높이는 장점이 있습니다.\n\n또 다른 흥미로운 특징은 제네릭의 유추 타입(type inference)입니다. TypeScript 컴파일러에서 수행되며, 일반 함수를 호출할 때 유형 명세가 선택 사항이 될 수 있도록 합니다:\n\n```js\nlogInformations(1234)\nlogInformations(['React Native', 'TypeScript'])\n```\n\n이 과정은 컴파일러가 자동으로 처리하여 유형 명세가 선택 사항이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 명명 규칙\n\nTypeScript에서 제네릭을 사용할 때, 일반적으로 T를 제네릭 유형 매개변수로 사용하는 것이 일반적입니다. 그러나 중요한 점은 T가 단지 관습이라는 것이며, 코드의 문맥에 맞는 의미있는 이름으로 대체할 수 있다는 것입니다. 예를 들어, 항목 목록을 다룰 때 T 대신 Item을 사용하면 코드 가독성을 높일 수 있습니다.\n\n## 제약 조건\n\n제약 조건은 사용되는 제네릭 유형에 제약 조건을 부여하여 특정 규칙이나 인터페이스를 준수하도록 하는 제네릭의 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 ExtraInformations {\n  createdAt: string;\n}\n\nfunction logInformations\u003cT extends ExtraInformations\u003e(infos: T): T {\n  return infos;\n}\n```\n\n따라서 logInformations 메서드에 전달된 제네릭 타입은 어떤 타입이든 될 수 있지만, 반드시 string 타입의 createdAt 속성을 가져야 합니다.\n\n## 결론\n\nTypeScript의 제네릭은 더 유연하고 안전한 코드를 작성하는 데 필수적이며, any를 사용한 적 less robust한 방식을 대체하고 불필요한 코드 중복을 제거합니다. 타입을 추론하고 제약을 부과할 수 있는 기능을 통해, 제네릭은 개발을 단순화하고 타입의 정확성을 크게 향상시켜 코드를 확장 가능하고 유지보수하기 쉽게 만듭니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소셜 미디어에서 나를 팔로우해 주세요: LinkedIn | GitHub","ogImage":{"url":"/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringGenericsinTypeScriptWriteFlexibleSecureandDuplicity-FreeCode_0.png","tag":["Tech"],"readingTime":2},{"title":"MySQL JOIN 뒤의 작업 공개 실행 흐름의 상세 분석과 최적화 권고사항","description":"","date":"2024-05-27 19:27","slug":"2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations","content":"\n\nMySQL JOIN 실행 프로세스의 복잡성을 탐색하고 데이터베이스 성능을 향상시키기 위해 깊이있는 분석과 실용적인 최적화 기술을 제공해 드립니다. 쿼리 작업을 원활하게 하는 비밀에 대해 해체하고 있습니다.\n\n![MySQL JOIN 동작의 세부 분석과 실행 흐름 및 최적화 권장 사항](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png)\n\nMySQL의 JOIN 작업에 대해 실행 프로세스를 고찰해 보거나 자신의 이해력에 대해 의문을 품어 보셨나요? 확인하는 방법이 불분명하다면, 다음 질문에 답하려고 시도해 보십시오.\n\n- MySQL이 주도 테이블을 선택하는 방법은 고찰할 가치가 있는 문제입니다. 그것은 라인업에서 첫 번째 테이블부터 시작하여 왼쪽에서 오른쪽 순차적인 순서로 선택됩니까?\n- 다중 테이블 조인을 수행할 때, 어떤 기준이 테이블을 조인하는 순서를 선택하는 데 도움이 되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 주행 테이블의 개념을 이해하는 것이 중요합니다.\n\n다중 테이블 조인 쿼리의 맥락에서 주행 테이블은 처리되는 첫 번째 테이블을 가리키며, 베이스 테이블이라고도 알려져 있습니다. 이 테이블의 레코드는 다른 테이블과 연관 지을 때 사용됩니다.\n\n주행 테이블을 선택하는 것은 원칙을 준수합니다: 최종 결과 집합에 영향을 주지 않는 한 가장 작은 결과 집합을 가진 테이블을 우선적으로 주행 테이블로 선택합니다.\n\n이 원칙은 이해하기 어려울 수 있습니다. 가장 작은 결과 집합을 추정하는 것은 가능하지만, 이것이 최종 결과 집합에 영향을 주지 않는 것을 판단하는 것은 더 복잡합니다. 그러나 이 과정은 파악할 수 있는 패턴이 존재합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLEFT JOIN은 일반적으로 왼쪽 테이블을 주도 테이블로 삼습니다 (RIGHT JOIN은 일반적으로 오른쪽 테이블을 포함합니다).\n\nINNER JOIN에서는 결과 세트가 더 작은 테이블이 일반적으로 주도 테이블로 선택됩니다.\n\n의문이 남는 경우, EXPLAIN을 사용하여 주도 테이블을 식별할 수 있습니다. 결과에서 첫 번째 테이블은 주도 테이블로 간주됩니다.\n\n그러나 EXPLAIN이 항상 정확하지는 않을 수 있음을 유의해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실행 계획은 실제 실행 중에 변경될 수 있습니다.\n\n데이터 준비 중입니다.\n\nInnoDB 엔진을 사용하여 MySQL 버전 5.7을 실행 중입니다.\n\n데이터에 대한 초기 SQL은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nDROP TABLE IF EXISTS tb_user;\n\nCREATE TABLE tb_user (\n  id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  user_name VARCHAR(50) NOT NULL,\n  gender TINYINT(1) NOT NULL,\n  created_at datetime NOT NULL,\n  updated_at datetime NOT NULL,\n  PRIMARY KEY (id)\n);\n\nINSERT INTO tb_user(user_name, gender, created_at, updated_at) VALUES\n('Girvan', 1, NOW(), NOW()),\n('Paul', 0, NOW(), NOW()),\n('Max', 1, NOW(), NOW()),\n('Brogan', 0, NOW(), NOW()),\n('Aydan', 1, NOW(), NOW()),\n('Colm', 0, NOW(), NOW()),\n('Jason', 1, NOW(), NOW()),\n('Quillan', 0, NOW(), NOW()),\n('Donnacha', 1, NOW(), NOW()),\n('Iarla', 0, NOW(), NOW());\n\nDROP TABLE IF EXISTS tb_login_log;\n\nCREATE TABLE tb_login_log (\n  id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,\n  user_name VARCHAR(50) NOT NULL,\n  ip VARCHAR(15) NOT NULL,\n  created_at datetime NOT NULL,\n  PRIMARY KEY (id)\n);\n\nINSERT INTO tb_login_log(user_name, ip, created_at) VALUES\n('Girvan', '192.168.1.101', '2024-01-01 12:01:01'),\n('Girvan', '192.168.1.102', '2024-01-02 12:02:02'),\n('Girvan', '192.168.1.103', '2024-01-03 12:03:33'),\n('Paul', '192.168.1.104', '2024-01-04 12:00:01'),\n('Max', '192.168.1.105', '2024-01-05 12:00:01'),\n('Brogan', '192.168.1.106', '2024-01-06 12:00:01'),\n('Aydan', '192.168.1.107', '2024-01-07 12:00:01'),\n('Colm', '192.168.1.108', '2024-01-08 12:00:01');\n\nSELECT * FROM tb_user;\nSELECT * FROM tb_login_log;\n``` \n\n단일 테이블 쿼리 실행 과정이 비교적 간단하며 다음과 같이 요약할 수 있습니다:\n\n![query_execution_flow](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_1.png)\n\n조인 알고리즘.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMySQL의 조인 알고리즘은 중첩 루프 알고리즘에서 파생되었으며, 다양한 조건에 따라 선택된 일련의 알고리즘을 포함하고 있습니다.\n\n인덱스 기반 조인을 사용할 때는 두 가지 알고리즘인 인덱스 중첩 루프 조인과 일괄 키 액세스 조인이 있습니다.\n\n인덱스 기반 조인이 없을 때는 두 가지 알고리즘인 단순 중첩 루프 조인과 블록 중첩 루프 조인이 있습니다.\n\n# 1. 단순 중첩 루프.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 중첩 루프 조인, 줄여서 SNL이라고도하는 것은 한 번에 한 레코드씩 일치시키는 것을 포함하며, 순차적으로 한 번에 하나씩 진행됩니다.\n\n```js\nfor each row in t1 matching range {\n  for each row in t2 matching reference key {\n    for each row in t3 {\n      if row satisfies join conditions, send to client\n    }\n  }\n}\n```\n\n![MySQL 조인의 실행 흐름 및 최적화 권장사항에 대한 자세한 분석 이미지](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_2.png)\n\n이 알고리즘은 직관적이지만 성능이 떨어지며, 시간 복잡성 측면에서 테이블의 레코드 수를 N, 조인된 테이블의 수를 M이라고 할 때 N의 M 제곱에 비례합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 최적화하기 위해 MySQL은 조인 쿼리에 대해 이러한 알고리즘을 사용하지 않습니다. WHERE 조건이 없고 ON 조인 키에 인덱스가 없는 경우에도 이 알고리즘을 사용하지 않습니다.\n\n# 2. 블록 중첩 루프.\n\n블록 중첩 루프 조인, 줄여서 BNL,은 SNL의 최적화 방법입니다.\n\n주행 테이블의 여러 행을 한꺼번에 조인 버퍼에 캐싱하는 것을 포함합니다. 그런 다음, 조인 버퍼의 데이터가 일치하도록 매치할 수 있게 배치되며, 이는 내부 루프에서 검색한 데이터와 유사한 방식으로 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfor each row in t1 matching range {\n  for each row in t2 matching reference key {\n    store used columns from t1, t2 in join buffer\n    if buffer is full {\n      for each row in t3 {\n        for each t1, t2 combination in join buffer {\n          if row satisfies join conditions, send to client\n        }\n      }\n      empty join buffer\n    }\n  }\n}\n\nif buffer is not empty {\n  for each row in t3 {\n    for each t1, t2 combination in join buffer {\n      if row satisfies join conditions, send to client\n    }\n  }\n}\n```\n\n내부 루프에서 검색된 각 행을 버퍼의 모든 레코드와 비교함으로써 내부 루프에서의 테이블 읽기 횟수를 줄일 수 있습니다.\n\n예를 들어, Join 버퍼가 없을 경우 주도 테이블이 30개 레코드를 가지고 있고 대입 테이블에 50개 레코드가 있을 때 내부 루프는 30 * 50 = 1500 개의 테이블 읽기를 요구합니다.\n\n그러나 Join 버퍼가 있고 10개 레코드를 저장할 수 있는 경우 (Join 버퍼에는 주도 테이블로부터 쿼리에서 사용된 열이 저장되며, SELEC 열, ON 열, WHERE 열이 포함됩니다), 내부 루프는 30 / 10 * 50 = 150 개의 테이블 읽기만 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주어진 테이블이 수행해야 하는 읽기 작업의 수를 한 차원 줄입니다.\n\n이 알고리즘은 주어진 테이블이 조인 키에 인덱스가 없고 WHERE 필터링 조건에도 인덱스가 없는 경우에 자주 사용됩니다. 이러한 경우에는 다음과 같이 접근합니다:\n\n![이미지 1](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_3.png)\n\n![이미지 2](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 인덱스 중첩 루프.\n\n인덱스 중첩 루프 조인(약어: INL)은 조인을 수행하기 위해 주도 테이블의 인덱스를 기반으로 하는 알고리즘입니다.\n\n이 알고리즘에서는 주도 테이블의 레코드가 주도 테이블의 인덱스와 일대일로 일치하도록 하나씩 매칭됩니다.\n\n이렇게 하면 주도 테이블의 모든 레코드와 비교할 필요가 없어져 주도 테이블과의 매칭 작업 수를 줄일 수 있습니다. 일반적인 프로세스는 아래 다이어그램에 설명되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image 5](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_5.png)\n\n실제 예제를 살펴보겠습니다. 먼저 쿼리를 사용하여 tb_login_log 테이블에 인덱스를 추가해 봅시다. ALTER TABLE tb_login_log ADD INDEX idx_user_name (user_name). 그 후에 조인을 위한 실행 계획을 확인해 봅시다.\n\n![image 6](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_6.png)\n\ntb_login_log 테이블에 대한 인덱스가 현재 작용하는 것을 관찰할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 WHERE 조건을 포함한 쿼리를 테스트하기로 하겠습니다.\n\n![image](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_7.png)\n\n흥미로운 사건이 발생했습니다: 주도 테이블이 tb_login_log로 변경되었고, tb_user가 이제 기동 테이블이 되었습니다.\n\ntb_login_log의 인덱스를 거쳐 결과 집합을 얻은 후, BNL 알고리즘이 이 결과 집합과 tb_user 테이블을 일치시키는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMySQL의 이 최적화는 tb_login_log에서의 인덱스 필터링을 통해 얻은 결과 집합이 tb_user의 레코드 수보다 작기 때문에 발생합니다. 결과적으로 MySQL은 주도 테이블로 tb_login_log를 선택했습니다.\n\n## 4. 배치 키 액세스.\n\n배치 키 액세스(Batched Key Access) 또는 BKA는 인덱스 중첩 루프(INL) 알고리즘의 최적화입니다.\n\n배치 키 액세스(BKA)가 인덱스 중첩 루프(INL) 알고리즘에 제공하는 최적화는 배치 키 액세스가 단순 중첩 루프(SNL) 알고리즘에 제공하는 향상과 유사합니다. 그러나 둘 사이에는 구별점이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 다음 쿼리를 사용하여 tb_user 테이블에 인덱스를 추가하세요: ALTER TABLE tb_user ADD INDEX i_aaa(user_name);.\n\n그 다음, 다음 쿼리를 사용하여 실행 계획을 확인하세요: EXPLAIN SELECT * FROM tb_login_log tl LEFT JOIN tb_user tu ON tl.user_name = tu.user_name.\n\n결과는 다음 다이어그램과 비슷해야 합니다:\n\n\u003cimg src=\"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 시점에서 조인 알고리즘은 INL입니다. 그 이유는 tb_login_log 테이블의 user_name 열에 색인이 없기 때문입니다.\n\n결과적으로, user_name 열에서 tb_login_log 테이블에서 검색된 값은 정렬되지 않습니다.\n\ntb_user와 연관시킬 때 일치 과정은 아래 다이어그램과 유사한 i_aaa 색인에 무작위 액세스를 포함합니다.\n\n![다이어그램](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBKA 기능은 기본적으로 비활성화되어 있습니다 (batched_key_access=off). 이를 활성화하려면 다음 명령을 실행하세요:\n\n```js\nSET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';\n```\n\n![이미지](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_10.png)\n\ntb_login_log에서 검색된 user_name의 값은 먼저 조인 버퍼에 배치됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조인 버퍼가 가득 차거나 데이터 검색이 완료되면 조인 버퍼의 값이 정렬됩니다.\n\n이후에 버퍼는 tb_user와 연관시켜 사용되어, i_aaa 인덱스와 연속적으로 일치시킵니다. 아래 다이어그램과 유사한 방식입니다.\n\n![다이어그램](/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_11.png)\n\n요약.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Index Nested-Loop join (INL)는 주테이블의 각 행을 드라이븐 테이블의 인덱스와 비교하여 레코드를 매칭하는 알고리즘입니다.\n- Batched Key Access join (BKA)는 INL의 최적화로, 주테이블의 값들이 먼저 조인 버퍼에 배치되고 정렬된 후 드라이븐 테이블의 인덱스와 순차적으로 매칭에 사용됩니다.\n- 조인 쿼리의 최적화를 위해 MySQL은 사용 가능한 인덱스, 결과 집합 크기 및 필터링 조건과 같은 요소를 기반으로 가장 효율적인 알고리즘을 동적으로 선택할 수 있습니다.\n- 실행 계획을 이해하고 EXPLAIN을 사용하며 인덱스를 고려하는 것은 MySQL에서 조인 쿼리의 성능을 최적화하고 분석하는 데 도움이 됩니다.\n\n이런 이야기를 좋아하시고 제 지원을 원하신다면, 박수를 부탁드립니다.\n\n여러분의 지원은 저에게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png"},"coverImage":"/assets/img/2024-05-27-UnveilingtheOperationsBehindMySQLJOINDetailedAnalysisofExecutionFlowandOptimizationRecommendations_0.png","tag":["Tech"],"readingTime":9},{"title":"장고의 왕국이 곧 종말을 맞이할 이유","description":"","date":"2024-05-27 19:25","slug":"2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution","content":"\n\n# 소개:\n\n안녕하세요, 개발자 여러분! 👋 웹 개발의 끊임없이 변화하는 세계에서 Django는 파이썬과 함께 견고하고 확장 가능한 웹 응용 프로그램을 구축하는 데 우리에게 신뢰할 만한 친구였습니다. 그러나 이 모든 새로운 기술들이 등장하면서, \"Django가 죽는 것인가?\" 궁금해할 수 있습니다. 이 대화에 뛰어들어 이들 소문에 진실이 있는지, 아니면 Django가 우리 모두처럼 진화하고 있는지 확인해보겠습니다.\n\n# 대체 기술의 부상:\n\nReact, Angular, Vue.js와 같은 JavaScript 프레임워크들이 인기를 끌면서, 일부 사람들은 Django와 같은 서버 측 프레임워크의 타당성을 의심하기 시작했습니다. 그리고 마이크로서비스 아키텍처, 서버리스 컴퓨팅, 헤드리스 CMS 솔루션 주변의 소문을 잊지 말아야 합니다. 이러한 트렌드로 인해 Django와 같은 단일 프레임워크가 구식이 되고 있는지 의심하기 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 신화를 해소하다:\n\n잠깐만 기다려주세요! 어떤 결론을 내기 전에, Django가 웹 개발에서 아직 강력한 위치를 차지하는 이유에 대해 자세히 알아봅시다:\n\n- 성숙한 생태계: Django는 그냥 프레임워크가 아닌 완전히 갖춰진 툴킷입니다. 포괄적인 문서와 활기찬 커뮤니티를 통해 Django는 효율적으로 웹 애플리케이션을 구축하는 데 필요한 모든 것을 제공합니다. ⚡\n- 확장성과 성능: 단일체로 불리기도 하지만, Django는 탁월한 확장성을 보여줄 수 있습니다. 캐싱, 비동기 처리, 수평 확장 등 적절한 최적화를 통해 Django는 대량의 트래픽을 처리할 수 있습니다. 📈\n- 다재다능성과 유연성: Django는 일일이 해줘야 할 일이 하나뿐인 것이 아닙니다. Django는 기존의 웹 애플리케이션부터 API, 마이크로서비스, 콘텐츠 관리 시스템(CMS)까지 다양한 프로젝트에 적합합니다. 🛠️\n- 보안과 안정성: 보안은 중요한 문제이며, Django는 이를 심각하게 대합니다. XSS, CSRF, SQL 인젝션 같은 일반적인 취약점에 대한 내장형 방어 기능을 통해 Django는 애플리케이션을 안전하게 유지합니다. 또한 역호환성에 대한 헌신은 장기 프로젝트에 안정성을 제공합니다. 🔒\n\n# Django의 진화:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과거에 머물고 있는 것이 아닌 Django는 현대 개발자의 요구를 충족시키기 위해 지속적으로 발전하고 있습니다:\n\n- Django REST Framework (DRF): RESTful API를 구축 중이라면 DRF를 찾을 필요가 없습니다. Django와 함께 강력하고 확장 가능한 웹 API를 만드는 데 필수 도구로 자리 잡았습니다. 이제 이보다 더 쉽습니다. 🌐\n- Django Channels를 통한 Async 지원: 실시간 반응형 웹 애플리케이션을 만들고 싶나요? Django Channels가 도와줄 겁니다. 비동기 통신을 지원하여 Django 생태계 내에서 채팅 플랫폼 등을 만들 수 있습니다. 📡\n- 현대 프론트엔드 기술 통합: Django는 다른 도구들과도 잘 어울립니다. React, Angular, Vue.js와 같은 프론트엔드 프레임워크와 원활하게 통합되어 두 가지 세계의 장점을 활용할 수 있습니다. 🎨\n\n# 결론:\n\n그래서 Django가 쇼에 가고 있는 걸까요? 전혀 그렇지 않습니다! Django가 앞으로 나아가고 있는 것은 오해입니다. 새로운 기술이 항상 등장하지만, Django는 견고하고 적응성이 뛰어난 도구로 남아 웹 개발의 미래에 도전할 준비가 되어 있습니다. Django의 진화는 능력을 높여줄 뿐 아니라 그 가치를 유지하고 강화함을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거대한 체계 속에서 Django는 강건한 생태계, 확장성, 보안 및 적응성으로 성장하고 있습니다. Django는 그저 살아있는 것뿐만이 아니라 진화하며 디지털 랜드스케이프에서 혁신과 영향력을 만들어내는 새로운 시대를 열고 있습니다.\n\n그래서 이런 소문들은 잊어버리세요. Django의 통치 시대는 멀었으며, 그 여정은 더욱 흥미진진해지고 있습니다! 🌟\n\n읽어 주셔서 감사합니다. 즐거운 코딩되세요! 🚀","ogImage":{"url":"/assets/img/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution_0.png"},"coverImage":"/assets/img/2024-05-27-UnveilingtheTruthIsDjangosReignOverDispellingMythsandEmbracingItsEvolution_0.png","tag":["Tech"],"readingTime":3},{"title":"Laravel 개발 혁신하기 매크로에 작별을 고하고 믹신스에 안녕을 외치다","description":"","date":"2024-05-27 19:24","slug":"2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png\" /\u003e\n\n안녕하세요! Laravel에서 Mixins를 전문적으로 사용하는 방법에 대한 포괄적인 안내서에 오신 것을 환영합니다! 이 가이드는 Mixins의 세계에 심취하여 Laravel 개발 기술을 향상시키도록 설계되었습니다. 그러나 먼저 Macros에 대해 간단히 설명하겠습니다. Macros는 Laravel의 주요 측면으로, 사용자 정의 메서드를 추가하여 클래스의 기능을 확장할 수 있게 해줍니다. Macros는 Laravel에서 재사용 가능하고 조직화된 코드를 개발하는 데 중요한 역할을 하며, Macro를 최대한 활용하여 효율적이고 확장 가능한 애플리케이션을 만드는 방법을 여러분께 보여드리겠습니다. 예를 들어, Laravel의 Str 및 Arr 헬퍼 클래스에 사용자 정의 메서드를 추가하고 싶을 수 있습니다.\n\nStr 헬퍼의 경우 다음과 같이 사용할 수 있습니다:\n\nfullName\ninitials\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nArr 도우미 클래스에 대해:\n\ncamelToSnake snakeToCamel filterNulls\n\n지금은 macros를 사용해서 AppServiceProvider.php의 boot 메서드 안에 위의 메서드들을 추가해보도록 합시다.\n\n```php\n\u003c?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Support\\Str;\n\nclass AppServiceProvider extends ServiceProvider\n{\n    /**\n     * 어플리케이션 서비스를 부트스트랩합니다.\n     */\n    public function boot(): void\n    {\n        Str::macro('fullName', function (string $firstname, string $lastname) {\n            return trim($firstname . ' ' . $lastname);\n        });\n\n        Str::macro('initials', function (string $firstname, string $lastname) {\n            return strtoupper($firstname[0] . $lastname[0]);\n        });\n\n        Arr::macro('camelToSnake', function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::snake($key) =\u003e $value];\n            });\n        });\n\n        Arr::macro('snakeToCamel', function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::camel($key) =\u003e $value];\n            });\n        });\n\n        Arr::macro('filterNulls', function (array $array) {\n            return Arr::where($array, function ($value) {\n                return !is_null($value);\n            });\n        });\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라라벨(Laravel)에서는 사용자 정의 메소드로 쉽게 확장할 수 있는 여러 클래스가 있습니다. 이러한 클래스들을 \"매크로 가능(Macroable)\" 클래스라고 합니다. 각 클래스마다 AppServiceProvider를 다른 매크로 메소드로 혼잡하게 만드는 대신에, 각 매크로 가능 클래스에 대한 개별 제공자 클래스를 만들고 config/app.php 파일에 등록할 수 있습니다. 그러나 이러한 방법은 모든 메소드를 추적하는 것이 조금 귀찮고 혼잡하게 만들 수 있습니다. 저는 보다 자연스럽고 가독성이 좋고 유지보수가 용이한 접근법을 선호합니다. 그렇다면 어떻게 해야 할까요? 여기에서 Mixins이 나옵니다. Mixins을 사용하면 클래스를 확장하는 프로세스를 간단하게 만들어 코드를 보다 구조적으로 관리하기 쉽게 할 수 있습니다.\n\n## Mixin이란 무엇인가요?\n\n매크로와 마찬가지로 Mixin은 넓은 라라벨 컨텍스트에서 기존 클래스의 기능을 확장하는 개념입니다. Mixin이 작동하는 방법을 살펴보겠습니다:\n\n- Mixin 클래스에는 다른 클래스에 추가하려는 메소드가 포함되어 있습니다. 이러한 메소드는 일반적으로:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `Table` 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nArrayMixin.php\n\n```js\n\u003c?php\n\nnamespace App\\Mixins;\n\nuse Closure;\nuse Illuminate\\Support\\Arr;\nuse Illuminate\\Support\\Str;\n\nclass ArrayMixin\n{\n    /**\n     * @return Closure\n     */\n    public function camelToSnake()\n    {\n        return function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::snake($key) =\u003e $value];\n            });\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function snakeToCamel()\n    {\n        return function (array $array) {\n            return Arr::mapWithKeys($array, function ($value, $key) {\n                return [Str::camel($key) =\u003e $value];\n            });\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function filterNulls()\n    {\n        return function (array $array) {\n            return Arr::where($array, function ($value) {\n                return !is_null($value);\n            });\n        };\n    }\n}\n```\n\nStringMixin.php\n\n```js\n\u003c?php\n\nnamespace App\\Mixins;\n\nuse Closure;\n\nclass StringMixin\n{\n    /**\n     * @return Closure\n     */\n    public function fullName()\n    {\n        return function (string $firstname, string $lastname) {\n            return trim($firstname.' '.$lastname);\n        };\n    }\n\n    /**\n     * @return Closure\n     */\n    public function initials()\n    {\n        return function (string $firstname, string $lastname) {\n            return strtoupper($firstname[0].$lastname[0]);\n        };\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 AppServiceProvider에 이 Mixin들을 등록하세요:\n\n```js\n/**\n* 어플리케이션 서비스를 초기화합니다.\n*/\npublic function boot(): void\n{\n    Str::mixin(new StringMixin());\n    Arr::mixin(new ArrayMixin());\n}\n```\n\n잘 했어요! 이제 프로젝트가 잘 정리되었고 코드를 더 쉽게 읽을 수 있게 되었어요.\n\n여전히 Str::initials(...), Arr::filterNulls(...)와 같이 이 도우미 메서드를 이전과 같은 방식으로 사용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n믹신의 장점:\n\n- 코드 재사용성: 믹신 클래스 내에 도우미 로직을 캡슐화함으로써 코드를 중복하지 않고 응용 프로그램의 다른 부분에서 재사용할 수 있습니다.\n- 코드 청결함: 믹신은 원래 클래스 코드를 청소하고 핵심 기능에 집중할 수 있도록 도와줍니다. 도우미 메서드는 전용 클래스로 분리됩니다.\n- 유지보수성 향상: 도우미 로직을 수정하거나 제거해야 할 경우, 모든 내용이 한 군데에 있습니다 - 믹신 클래스 내에 위치하고 있습니다.\n\n다음 기사에서 뵙겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png"},"coverImage":"/assets/img/2024-05-27-RevolutionizeLaravelDevelopmentSayGoodbyetoMacrosHellotoMixins_0.png","tag":["Tech"],"readingTime":5}],"page":"52","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"52"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>