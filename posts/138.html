<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="NextAuthJS를 Discord와 함께 사용하는 방법" href="/post/2024-05-12-HowtouseNextAuthJSwithDiscord"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextAuthJS를 Discord와 함께 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextAuthJS를 Discord와 함께 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextAuthJS를 Discord와 함께 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드와 백엔드를 한 번에 실행하는 방법" href="/post/2024-05-12-HowtorunFrontendandBackendwithonecommand"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드와 백엔드를 한 번에 실행하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드와 백엔드를 한 번에 실행하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드와 백엔드를 한 번에 실행하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React TypeScript와 Jest를 위한 테스트 환경 설정하기" href="/post/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React TypeScript와 Jest를 위한 테스트 환경 설정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React TypeScript와 Jest를 위한 테스트 환경 설정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React TypeScript와 Jest를 위한 테스트 환경 설정하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기" href="/post/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Router를 사용하여 React에서 단일 페이지 앱SPA 만들기" href="/post/2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Router를 사용하여 React에서 단일 페이지 앱SPA 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Router를 사용하여 React에서 단일 페이지 앱SPA 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Router를 사용하여 React에서 단일 페이지 앱SPA 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대기업 프론트엔드 단골 useState 질문" href="/post/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대기업 프론트엔드 단골 useState 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대기업 프론트엔드 단골 useState 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대기업 프론트엔드 단골 useState 질문</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 애플리케이션 보안 자바스크립트 난독화" href="/post/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 애플리케이션 보안 자바스크립트 난독화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 애플리케이션 보안 자바스크립트 난독화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 애플리케이션 보안 자바스크립트 난독화</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 스톱워치를 만드는 간단한 방법" href="/post/2024-05-12-Simplewaytocreateastopwatchinreactjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 스톱워치를 만드는 간단한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Simplewaytocreateastopwatchinreactjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 스톱워치를 만드는 간단한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 스톱워치를 만드는 간단한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자가 알아야 할 상위 15개 이상의 GitHub 저장소" href="/post/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자가 알아야 할 상위 15개 이상의 GitHub 저장소" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자가 알아야 할 상위 15개 이상의 GitHub 저장소" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모든 개발자가 알아야 할 상위 15개 이상의 GitHub 저장소</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Electron과 React를 활용한 최종 가이드" href="/post/2024-05-12-TheUltimateGuidetoElectronwithReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Electron과 React를 활용한 최종 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Electron과 React를 활용한 최종 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Electron과 React를 활용한 최종 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link posts_-active__YVJEi" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"NextAuthJS를 Discord와 함께 사용하는 방법","description":"","date":"2024-05-12 20:57","slug":"2024-05-12-HowtouseNextAuthJSwithDiscord","content":"\n\n## Discord API를 사용하여 NextJS에서 NextAuth.JS를 통한 \"Discord를 사용한 로그인\"을 구현하는 방법을 배워보세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png\" /\u003e\n\n최근 대시보드 프로젝트를 작업하던 중에 Discord 사용자들이 애플리케이션에 로그인하고 그들의 서버 중 하나를 수정할 수 있도록 하는 작업을 하게 되었습니다.\n\n이전에 NextJS로 인증을 구현해본 적이 없던 사람으로써 전혀 감이 안 왔습니다. NextAuth, Auth0, Clerk 및 Supabase 사이를 계속 왔다갔다했습니다. 오류가 발생했을 때, 처음 몇 초만에 NextAuth를 포기했습니다.\n\n\n\n신입 개발자로 시작하는 것은 어렵습니다. 대부분의 경우, 처음으로 선택한 옵션이 가장 이상적인 경우가 많아요. 저는 모든 것을 시도해보고 결국 NextAuth로 돌아왔어요. 어떻게 구현하는지 알아내고 끝없는 시간을 보냈기 때문에 당신은 그럴 필요가 없어요!\n\n이 글을 통해 우리가 어떻게 인증을 구현할 수 있는지 살펴보도록 하죠.\n\n# NextAuth를 위한 Discord 제공자\n\nNextAuth를 활용하면 Google, Facebook, Apple, Github 등 다양한 서비스를 위한 인증을 설정할 수 있어요. NextAuth는 이러한 서비스와 플랫폼을 제공자(provider)라고 부르죠. 다시 말해, 이러한 제공자는 서비스이며 사용자들은 이를 통해 애플리케이션에 로그인할 수 있어요.\n\n\n\n이 기사에서는 Discord Provider를 사용할 것입니다. 다른 공급업체와 달리, Discord는 인증 설정을 위해 추가 구성이 필요합니다. 우리는 먼저 이러한 요구 사항을 정렬해야 합니다.\n\nDiscord Developer Portal에서 애플리케이션을 생성하여 Discord API 및 Discord 인프라에 액세스해야 합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2IOmhM7_ZtM_Mf8zc6u5Dg.gif)\n\n그런 다음 Client ID와 Client Secret을 가져와야 합니다. 보안 목적을 위해 Client Secret을 재설정해야 합니다.\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*fXb5ABTdet-g_6FIqRwUpA.gif)\n\n필요한 자격 증명을 획득한 후 다음 단계로 진행할 수 있습니다. 관련 정보를 얻을 수 없는 경우, 선택한 브라우저에서 기본 검색을 수행하고 누군가가 안내해 줄 것입니다.\n\n## NextJS 앱 초기화\n\n이미 하지 않았다면 NextJS 애플리케이션을 설정해야 합니다. 다음 명령어를 터미널에서 사용하여 NextJS 애플리케이션을 초기화하고 단계를 따르세요.\n\n\n\n```js\nnpx create-next-app@latest\n```\n\n데모를 위해 프론트 엔드에서 인증 기능을 보여주기 위해 TypeScript보다는 JavaScript를 선택했어요 (화 angry지 마세요) 그리고 API 라우트를 용이하게 하기 위해 최신 App Router를 사용하고 전반적으로 더 나은 경험을 위해 TailwindCSS를 사용했어요.\n\n또한, src/ 구성을 선택하지 않았어요. 우리는 모든 것을 app/ 디렉토리 안에서 할 거예요. 그러나 당신의 어플리케이션에 맞춰 동일한 단계를 따르고 코드 스니펫을 조정할 수 있어요.\n\n## NextAuth 설치하기\n\n\n\n프로젝트에 NextAuth를 설치하려면 다음 명령을 사용해야 합니다.\n\n```js\nnpm install next-auth\n```\n\n설치가 완료되면 권한 부여와 관련된 다양한 요청을 처리하기 위한 새로운 API route를 생성해야 합니다. 먼저 app/ 디렉토리 안에 api/라는 폴더를 만듭니다.\n\n그런 다음 api/ 디렉토리 내에 nested 폴더를 만들어 auth/로 이름 지어주세요. 마지막으로 auth/ 디렉토리 내에 […nextauth]라는 디렉토리를 만듭니다. NextAuth는 이 디렉토리 구조를 엄격히 요구하므로 이러한 작업이 마법처럼 이루어질 것입니다.\n\n\n\n들어오는 요청을 처리하기 위해 app/api/auth/[...nextauth]/route.js 경로에 route.js 파일을 생성하세요. 이 파일은 동적 경로 핸들러입니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_1.png)\n\n## NextAuth를 위한 API Route 생성\n\n이 동적 경로 핸들러는 NextAuth 구성을 저장하고 NextAuth와 관련된 들어오는 요청을 처리할 것입니다.\n\n\n\n먼저 라우트 핸들러 파일에 NextAuth를 가져와보세요. 그런 다음 NextAuth에서 Discord Provider를 가져와주세요. 이 두 항목을 가져온 후, NextAuth를 구성하기 시작하겠습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n```\n\n이제 클라이언트 ID와 클라이언트 시크릿이 필요합니다. 준비해두세요. 이제 AuthOptions라는 객체를 만들 것입니다. 이 객체는 인증에 필요한 값들을 가진 객체입니다. 기억해주세요, 객체를 초기화할 때 export 키워드를 사용해야 합니다.\n\n이 객체를 사용하여 서버 컴포넌트에서 현재 세션에 액세스할 것입니다. 그런데, 세션은 서버 기반이며 DB와는 무관합니다.\n\n\n\n여기 파일이 보이는 모양입니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"클라이언트_시크릿\",\n      clientSecret: \"클라이언트_시크릿\",\n    }),\n  ],\n};\n```\n\n이제 NextAuth 함수를 사용하여 인증을 초기화해야 합니다. 이 함수는 AuthOptions와 해당 속성을 매개변수로 필요로 합니다. 따라서 AuthOptions 객체를 매개변수로 전달할 것입니다.\n\n```js\nconst handler = NextAuth(AuthOptions);\n```\n\n\n\nNextAuth와 구성 옵션을 성공적으로 통합했습니다. 하지만, 더 있습니다. 누군가가 계정에 Discord를 사용하여 로그인하는 경우, Discord가 애플리케이션이 처리하고 로그인한 사용자의 계정에 액세스하기 위한 코드를 생성합니다.\n\n이 고유 코드를 사용하여 직렬화된 토큰을 얻을 수 있습니다. 토큰은 로그인한 사용자를 나타내는 문자열의 일련 번호이며 Discord API에 액세스할 수 있는 열쇠 역할을 합니다. 우리는 봇의 토큰 또는 유효한 Discord 사용자의 토큰이 있을 때만 Discord API에 액세스할 수 있습니다.\n\n해당 고유 코드가 어디에 있는지 궁금해하는 분들도 있을 것입니다. Discord는 사용자가 로그인에 성공한 후 애플리케이션이 사용자를 리디렉션하는 URL에 넣습니다. 다음은 NextAuth가 어떻게 도와주는지에 대한 설명입니다.\n\n\n\n우리가 사용자 정의 리디렉션 URL을 대신 사용하는 대신 NextAuth의 도움을 받을 것입니다. Discord 개발자 포털에서 선택한 애플리케이션의 OAuth 섹션에 다음과 같은 리디렉션 URL을 삽입할 것이며, 이 URL은 사용자가 로그인에 성공한 후 NextAuth의 라우트 핸들러로 사용자를 리디렉션할 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*deLjJ2UZeiuCS8AcNZzm9A.gif)\n\n리디렉션 URL은 이전에 로컬로 저장된 애플리케이션에서 미리 만든 동적 라우트 핸들러의 경로입니다. 프로덕션 빌드에서는 localhost:3000을 여러분의 도메인 이름이나 VPS IP로 바꿔야 합니다.\n\n사용자가 로그인하면 NextAuth의 라우트 핸들링 시스템으로 리디렉션되며, NextAuth가 즉시 코드를 토큰으로 교환하고 저장합니다.\n\n\n\n## NextAuth 콜백\n\n유저가 로그인하면 다른 페이지로 리디렉션되기를 원합니다. 기본 NextAuth 페이지에 머무르지 않도록 하거나 기본적으로 루트 디렉토리(홈페이지)로 리디렉션되지 않도록 하고 싶습니다. 따라서 NextAuth에서 리디렉션을 처리하기 위해 콜백을 사용할 것입니다.\n\nNextAuth는 개발자가 고유한 사용 사례에 맞게 구성할 수 있는 콜백을 제공합니다. 특정 이벤트가 트리거될 때마다 NextAuth 콜백이 호출됩니다. 예를 들어, signIn() 콜백은 유저가 로그인했을 때 실행됩니다.\n\n우리의 경우, redirect() 콜백을 재정의할 것입니다. 이 콜백은 두 개의 매개변수를 가져야 하지만, 우리는 일반적으로 루트 디렉토리의 URL(localhost:3000/)을 필요로 합니다.\n\n\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n```\n\n또한 route 핸들러에서 NextAuth() 함수를 호출한 결과를 내보내야 합니다. 그렇지 않으면 세션에 액세스하거나 처리할 GET 및 POST 요청이 작동하지 않습니다.\n\n다음은 route.js 파일이어야 합니다. /dashboard를 원하는 경로로 바꿀 수 있습니다.\n\n```js\nimport NextAuth from \"next-auth/next\";\nimport DiscordProvider from \"next-auth/providers/discord\";\n\nexport const AuthOptions = {\n  providers: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n    }),\n  ],\n\n  callbacks: {\n    async redirect({ url, baseUrl }) {\n      return baseUrl + \"/dashboard\";\n    },\n  },\n};\n\nconst handler = NextAuth(AuthOptions);\n\nexport { handler as GET, handler as POST };\n```\n\n\n\n# 디스코드 권한\n\n기본적으로 로그인한 사용자의 사용자 이름과 이메일에만 액세스할 수 있습니다. 더 많은 정보에 액세스하려면 디스코드 API 및 엔드포인트를 사용해 볼 수 있지만, 디스코드는 접근을 거부할 것입니다. 이는 디스코드가 개인 정보 보호와 보안을 강화하기 때문입니다.\n\n더 많은 정보에 액세스하려면 사용자의 권한이 필요합니다. 사용자가 로그인을 시도할 때 그들로부터 권한을 얻을 수 있습니다. 주목했을 것인데, 디스코드는 사용자가 로그인 시도할 때 응용 프로그램에 부여하는 권한을 나열합니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_2.png)\n\n\n\n만약 무작위로 보였다면, 그것은 오산이었습니다. 개발자는 이러한 권한을 요청하며, 사용자들은 보통 그것을 무시합니다. 우리는 권한을 요청하기 위해 그것들을 권한 URL에 추가함으로써 실현할 수 있습니다. route.js 파일로 돌아가는 시간입니다.\n\nDiscordProvider 함수 안에, authorization이라는 또 다른 속성을 추가해야 합니다. 이 속성의 값은 애플리케이션 요구 사항에 따라 다를 것입니다. 이전에 말한대로, 저는 로그인한 사용자의 길드에 액세스하고 그것들을 표시하려고 합니다.\n\n그러므로, 저는 해당 권한을 요청하고 몇 가지 다른 것들도 포함할 것입니다. Discord 개발자 포털에서 그것들을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_3.png)\n\n\n\n페이지 URL 쿼리 매개변수에서 모든 권한 이름이 ' + ' 기호를 사용하여 연결될 것입니다.\n\n```js\nproviders: [\n    DiscordProvider({\n      clientId: \"YOUR_CLIENT_ID\",\n      clientSecret:\n        \"YOUR_CLIENT_SECRET\",\n      authorization:\n        \"https://discord.com/api/oauth2/authorize?scope=identify+guilds\",\n    }),\n],\n```\n\n이제 프론트 엔드를 구성하여 로그인 프로세스를 시작해 보겠습니다.\n\n# 프론트 엔드 구성하기\n\n\n\n새로운 애플리케이션을 시작했기 때문에 루트 디렉토리에서 수정을 할 것입니다. 만약 로그인 버튼을 다른 곳에 넣고 싶다면 그렇게 할 수 있어요. 단계 자체는 동일해요.\n\n루트 디렉토리에 LoginUsingDiscord.jsx라는 클라이언트 컴포넌트를 만들어서 onClick 이벤트를 처리할 거에요. 주요 페이지.js 파일은 여전히 기본 서버 컴포넌트 모드로 유지될 거에요.\n\n컴포넌트 내부에서는 \"next-auth/react\"에서 signIn() 함수를 import하여 \"Login\" 버튼을 클릭했을 때 호출할 거에요. signIn() 함수에는 하나의 매개변수를 전달할 수 있어요. 바로 클릭했을 때 호출될 로그인 버튼이 표현하는 프로바이더의 이름이에요.\n\n```js\n\"use client\";\n\nimport { signIn, signOut } from \"next-auth/react\";\n\nexport default function LoginUsingDiscord() {\n  return (\n    \u003csection className=\"flex gap-8 items-center justify-center mt-12\"\u003e\n      \u003cp className=\"font-bold text-lg\"\u003eDiscord를 사용하여 로그인\u003c/p\u003e\n      \u003cbutton\n        onClick={() =\u003e signIn(\"discord\")}\n        className=\"text-base py-3 px-4 bg-[#5865F2]\"\n      \u003e\n        로그인\n      \u003c/button\u003e\n    \u003c/section\u003e\n  );\n}\n```\n\n\n\n그것이에요. 버튼을 클릭하면 Discord 로그인 화면으로 리디렉션됩니다. 토큰의 직렬화가 완료되면 redirect() 콜백에서 선택한 URL로 이동합니다. 제 경우에는 /dashboard로 이동했어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6VWH3jSGprzfSPkHbafQfA.gif)\n\n성공적으로 로그인한 후에는 localhost:3000/api/auth/session에서 세션에 액세스할 수 있어요. 이 세션은 기본적으로 사용자 이름과 이메일만 포함하고 있어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*L3cZJJjMjQNvcKrWFXPAFw.gif)\n\n\n\nroute.js 파일 내에서 signIn()이라는 다른 콜백 함수를 덮어쓸 것입니다. 보안을 위해 토큰은 NextAuth의 범위 내에서만 접근할 수 있습니다.\n\n```js\nasync signIn({ account }) {\n  const discordToken = account.access_token;\n\n  return true;\n},\n```\n\nsignIn() 콜백은 사용자, 계정, 자격증명 등 다른 값들을 매개변수로 제공합니다. 우리는 access token을 검색하기 위해 account 매개변수만 필요합니다.\n\n대시보드 프로젝트에서 토큰을 해싱한 후 DB에 저장했습니다. 그러나 이곳에서는 그렇게 하지 않을 것입니다. 토큰을 사용하여 사용자에 대한 정보에 액세스하고 간소화를 위해 콘솔에 출력하려고 합니다.\n\n\n\n디스코드 API를 라우트나 서버 구성요소에서 사용하려면 토큰을 어딘가에 저장해야 합니다. 디스코드 API로의 모든 요청에는 디스코드 사용자 토큰이 필요합니다. 이 기사를 복잡하게 만들 수 없기 때문에 토큰을 어디에도 저장하지 않고 가져온 데이터를 콘솔에 표시할 것입니다.\n\n토큰을 어디에도 저장하지 않으므로 route.js 파일 외부에서 사용할 수 없습니다. 따라서 signIn() 콜백 내에서 디스코드 API에 대한 API 요청을 만들고 동작하는 방법을 보여드리겠습니다.\n\n# 디스코드 API 사용하기\n\nsignIn() 콜백을 계속 수정해보겠습니다. 사용자에 대한 정보를 가져와 콘솔에 출력하여 간단하게 표시하겠습니다. 이러한 API 요청의 엔드포인트는 디스코드 문서에 나와 있습니다.\n\n\n\nDiscord에서 제공하는 api/users/@me 엔드포인트로 GET 요청을 보내고, 로그인한 사용자의 정보가 포함된 객체를 받아오고 있어요. 사용자가 로그인했는지에 대해서는 중요하지 않아요. 각 액세스 토큰은 고유한 사용자를 나타내요.\n\n토큰은 매달 만료되며 갱신이 필요해요. 저는 사용자의 토큰을 사용할 때마다 그들을 대신해서 API 요청을 보내고 있어요. Discord는 저를 중재자로 취급해요.\n\n```js\nasync signIn({ account }) {\n   const discordToken = account.access_token;\n\n   const discordUser = await fetch(`https://discord.com/api/users/@me`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${discordToken}`,\n      },\n    }).then((res) =\u003e res.json());\n  \n    console.log(discordUser);\n\n    return true;\n},\n```\n\n액세스 토큰을 header의 Authorization 속성에 전달하면, 모든 것을 올바르게 수행했다면 API 엔드포인트로부터 응답을 받을 수 있어요.\n\n\n\n![Screenshot](/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_4.png)\n\n결국 LoginUsingDiscord 구성 요소 내에 로그아웃 버튼을 추가했어요. signOut() 함수를 사용했어요. 이 함수는 매개변수 없이 작동합니다. 왜냐하면 하나의 서비스만 활성 세션을 가질 수 있거든요. 여기에 코드가 있어요.\n\n```js\n\u003cbutton\n  onClick={() =\u003e signOut()} className=\"text-base py-3 px-4 bg-[#ED4245]\"\u003e\n  Sign Out\n\u003c/button\u003e\n```\n\n# 결론\n\n\n\n대부분의 애플리케이션에서 인증 구현은 어려운 작업입니다. NextAuth를 사용하면 이 작업을 더 쉽게 할 수 있습니다. 세션을 만드는 방법, 사용자가 Discord를 사용해 로그인할 수 있도록 하는 방법, 토큰을 사용해 Discord API에 API 요청을 보내는 방법 등을 배웠습니다.\n\n마찬가지로 Google과 같은 다른 제공업체를 사용할 수도 있습니다. 이 글이 도움이 되었기를 바랍니다. 소프트웨어 엔지니어로 취직하고 싶다면 대기 목록에 가입하는 것을 권장합니다.\n\n질문이 있다면 director@afankhan.com 이나 다른 곳에서 @whyafan 으로 연락해 주세요.\n\n# 평문으로 🚀\n\n\n\n플레인 영어 커뮤니티에 참여해 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 작가를 추천하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseNextAuthJSwithDiscord_0.png","tag":["Tech"],"readingTime":11},{"title":"프론트엔드와 백엔드를 한 번에 실행하는 방법","description":"","date":"2024-05-12 20:56","slug":"2024-05-12-HowtorunFrontendandBackendwithonecommand","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png\" /\u003e\n\n풀 스택을 개발할 때 각 서버를 수동으로 시작하는 것이 번거롭고 비효율적일 수 있습니다.\n\n일반적으로 새 터미널을 열고 node server 또는 nodemon server 명령을 실행하여 node.js 백엔드를 실행하고, 별도의 터미널을 열어 npm start 명령을 실행하여 React 프론트엔드를 실행하는 것을 가정해 봅시다. 왜 위의 과정 대신 한 번에 두 가지를 실행하지 않을까요?\n\n\"concurrently\" 라이브러리를 이용하거나 병렬로 여러 npm 스크립트를 실행할 수 있도록 설계된 \"npm-run-all\" CLI 도구를 사용하는 두 가지 효과적인 방법이 있습니다.\n\n\n\n## 동시성 라이브러리\n\nConcurrently 패키지에 대해 알아보겠습니다. Concurrently를 사용하면 단일 터미널에서 여러 명령 또는 스크립트를 동시에 실행하여 더 효율적인 작업 흐름을 제공합니다. 즉, package.json 파일에서 리액트 및 노드 서버를 시작하는 별도의 스크립트를 정의할 수 있고, \"concurrently\"가 이를 함께 실행할 수 있습니다.\n\n먼저 프로젝트에 \"concurrently\"를 설치해야 합니다. npm install concurrently 명령어 또는 npm install concurrently --save-dev 명령어를 사용하세요. 보통 개발 목적으로 사용되므로 concurrently를 devDependencies로 추가하는 것이 좋습니다. 프론트엔드와 백엔드를 위한 별도의 폴더를 만들었다면, 루트 폴더에 concurrently를 설치해야 합니다.\n\n```js\nnpm install concurrently \n\nnpm install concurrently --save-dev\n```\n\n\n\n패키지. Json 파일의 메인 폴더에 있는 \"start\" 스크립트를 찾아서 수정해보세요. 기본 구문은 다음과 같습니다:\n\n```js\n\"start\": \"concurrently \\\"script1\\\" \\\"script2\\\"\"\n```\n\n\"script1\"과 \"script2\"를 실제 실행하고 싶은 명령어로 대체하세요.\n\n또는 다음과 같이 더 맞춤 설정할 수도 있습니다:\n\n\n\n```js\n\"scripts\": {\n  \"start\": \"concurrently \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\",\n  \"start:frontend\": \"cd frontend의 실제 경로 \u0026\u0026 npm start\",\n  \"start:backend\": \"cd backend의 실제 경로 \u0026\u0026 node server\"\n}\n```\n\n\"frontend의 실제 경로\"와 \"backend의 실제 경로\"를 실제 경로로 변경하세요.\n\n만약 별도의 frontend와 backend 폴더가 있다면 아래와 같이 적용할 수 있습니다:\n\n```js\n\"start\": \"concurrently \\\"cd frontend \u0026\u0026 npm start\\\" \\\"cd backend \u0026\u0026 node server\\\"\"\n```\n\n\n\n앗, 이제 npm start를 실행하면 먼저 concurrently를 호출할 거야. 그리고 프론트엔드 코드가 있는 frontend 폴더가 있다면, frontend 디렉토리로 이동해야 해. (cd frontend) (해당 폴더로 이동하기 위한 필요한 명령어 사용) 그리고 npm start 명령어로 frontend를 실행해. 그리고 비슷하게 백엔드 코드가 있는 backend 폴더가 있다면, backend 디렉토리로 이동해야 해. (cd backend) (해당 폴더로 이동하기 위한 필요한 명령어 사용) 그리고 node server를 실행해.\n\n더 많은 명령어를 추가하려면 위의 형식처럼 각 스크립트에 백스플래시와 따옴표를 추가해야 해. 이제 새 터미널을 여시고 주 프로젝트 폴더에서 npm start를 실행하면 프론트엔드와 백엔드를 동시에 실행할 수 있어. 이 효율적인 접근법은 생산성을 향상시키고 빠른 반복을 가능하게 하며, 궁극적으로 더 나은 개발자 경험을 제공해.\n\nnpm \"concurrently\"를 사용하면 여러 작업을 원활하게 관리할 수 있어 개발 워크플로우를 간소화시킬 수 있어. 효율성을 향상시키고 복잡한 프로젝트를 유지보수하기 쉽게 만들어주는 유용한 도구야.\n\n\n\n“Concurrently\"은 개발 경험을 향상시키기 위해 추가적인 사용자 정의 및 유연성 옵션을 제공합니다. Concurrently에는 개발을 훨씬 쉽게 만드는 더 많은 기능이 있습니다.\n\n![이미지](/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_2.png)\n\n## 1. Named Commands:\n\n```js\n\"start\": \"concurrently --names 'FE,BE' \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\"\n```\n\n\n\n- --names 옵션을 사용하면 실행되는 명령에 이름을 할당할 수 있어요.\n- 이렇게 하면 콘솔 출력이 더 가독성 있고, 어떤 프로세스가 프론트엔드에 해당하는지 쉽게 식별할 수 있어요.\n\n## 2. 에러 시 종료:\n\n기본적으로 명령 중 하나라도 비정상 상태 코드(오류를 나타냄)로 종료되면, concurrently는 다른 모든 명령을 종료할 거에요. 그러나 다음 옵션으로 이 동작을 수정할 수 있어요:\n\n- --kill-others: 한 명령이 실패해도, 이 옵션으로 다른 명령을 종료하는 걸 막을 수 있어요.\n- --success first|last: 첫 번째 또는 마지막 명령이 성공하면 전체 실행을 성공으로 간주할지를 지정해요.\n\n\n\n이것은 특히 한 곳에서 오류가 발생해도 다른 프로세스를 계속 실행하고 싶을 때 유용할 수 있습니다.\n\n## 3. 색으로 구분된 출력:\n\n각 명령의 출력은 기본적으로 색으로 구분됩니다.\n\n```js\n\"start\": \"concurrently -n \\\"FRONTEND,BACKEND\\\" -c \\\"red,blue\\\" \\\"npm run start:frontend\\\" \\\"npm run start:backend\\\"\"\n```\n\n\n\n- -c \"red,blue\"는 이름이 지정된 명령에 대한 색상을 지정합니다. 이 경우, frontend 명령은 빨간색 출력을 가지고, backend 명령은 파란색 출력을 가질 것입니다.\n- 색으로 구분된 출력은 서로 다른 프로세스를 시각적으로 쉽게 구별할 수 있도록 하여 로그나 오류의 원천을 빠르게 식별하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png"},"coverImage":"/assets/img/2024-05-12-HowtorunFrontendandBackendwithonecommand_0.png","tag":["Tech"],"readingTime":4},{"title":"React TypeScript와 Jest를 위한 테스트 환경 설정하기","description":"","date":"2024-05-12 20:55","slug":"2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest","content":"\n\n![image](/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png)\n\n자동화된 테스트는 코딩 퍼즐에서 매우 중요한 부분입니다. 이 글에서는 React/TypeScript 앱을 @testing-library/react + jest로 테스트하는 환경을 설정하는 방법을 알려드릴 거에요. 이렇게 함으로써 코드/제품의 품질을 최대화할 수 있어요! 그런데 한 가지 주의할 점은, 이 글에서는 자동화된 테스팅의 \"무엇\"에 대해서는 다루지 않아요!\n\n먼저, 왜 자동화된 테스트를 해야 할까요? 마우스와 키보드로 앱을 테스트하면 안 되나요?\n\n그렇게 하면 안 돼요. 자기 자신의 이익을 위해 해야 합니다. 가장 극단적인 예로, 수천 명의 가상 사용자가 웹 애플리케이션과 상호작용하는 것을 모방하여 애플리케이션이 어떻게 동작하는지 확인할 수 있는데, 이러한 동작을 수동 테스트로 시뮬레이션하는 것은 불가능해요. 이런 기능은 개발자들에게 많은 시간을 절약시켜 줘요!\n\n\n\n이 설정에 필요한 패키지는 무엇인가요?\n\n먼저 jest, @types/jest, ts-jest를 설치해야 합니다:\n\n```js\nyarn add --dev jest @types/jest ts-jest\n```\n\n```js\nnpm install --save-dev jest @types/jest ts-jest\n```\n\n\n\n리액트와 타입스크립트가 모두 설치되어 있다고 가정하고\n\n이제 환경을 설정해 봅시다!\n\n위의 패키지를 설치한 후에 jest 구성 파일을 초기화해 봅시다:\n\njest.config.js 파일이 생성될 것입니다.\n\n\n\n테스트 폴더 및 목 모듈 생성:\n\n프로젝트 루트 디렉토리로 이동한 다음, 해당 디렉토리 내에 테스트 폴더를 만들어 목 폴더를 만듭니다:\n\n```js\n├── tests\n│   ├── components\n│   ├── mocks\n│   │   ├── fileMock.ts\n│   │   └── styleMock.ts\n│   ├── pages\n│   │   └── login.test.tsx\n│   └── setupTests.ts\n├── tsconfig.json\n├── webpack.config.ts\n├── jest.config.ts\n└── yarn.lock\n```\n\n이 트리를 보면, 모델, 서비스, 자산 등에 대한 목 모듈도 생성해야 합니다!\n\n\n\n3. 설정 파일 완성하기:\n\njest.config 파일을 마무리하려면 몇 가지 속성을 더 추가해야 합니다:\n\n그리고 더 매끄럽게 리액트와 함께 작동하도록 하려면 .babelrc (바벨 구성 파일)에서 다음을 추가하세요:\n\n```js\n{\n....\n\"presets\": [\n     \"@babel/env\",\n     [\"@babel/preset-react\", { \"runtime\": \"automatic\" }],\n     \"@babel/preset-typescript\"\n   ]\n}\n```\n\n\n\n4. 리액트를 위한 테스팅 라이브러리 설치 :\n\n이제, 일어나게 만들어줄 라이브러리들을 추가해야 합니다 (VDOM 액세스, 상호 작용 등), 이 라이브러리들은 \"@testing-library/dom\", \"@testing-library/jest-dom\", \"@testing-library/react\", 그리고 \"@testing-library/user-event\" 입니다.\n\n```js\nyarn add --dev @testing-library/dom @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n```js\nnpm install -D @testing-library/dom @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n\n\n5. package.json에 jest 추가해 주세요:\n\n```js\n\"scripts\": {\n    ...\n    \"test\": \"cross-env NODE_ENV=test jest tests/\"\n}\n```\n\n6. 코드를 테스트해 보세요:\n\n다음은 로그인 페이지를 테스트하는 예시입니다:\n\n\n\n![이미지](/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_1.png)\n\n결론:\n\n찾으시던 정보를 얻으셨길 바라요! 만일 제가 실수한 부분이 있으면 얼마든지 알려주세요!","ogImage":{"url":"/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png"},"coverImage":"/assets/img/2024-05-12-SetupTestingEnvironmentforReactTypeScriptwithJest_0.png","tag":["Tech"],"readingTime":3},{"title":"OpenAI의 Assistant API와 React를 사용하여 나만의 도우미 챗봇 만들기","description":"","date":"2024-05-12 20:53","slug":"2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact","content":"\n## 어시스턴트 API의 힘 이해하기\n\n![이미지](/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png)\n\n# 요약\n\n고속으로 발전하는 기술 세계에서 OpenAI는 인공 지능 분야에서 선두주자로 등장했습니다. 그들의 최신 작품인 어시스턴트 API는 이미 다양한 산업을 혁신하고 있습니다.\n\n자신만의 개인 비서를 가지고 싶었던 적이 있나요? 더 이상 찾을 필요가 없어요! OpenAI의 어시스턴트 API는 AI의 기능을 활용하고 이를 프로젝트에 원활하게 통합할 수 있는 강력한 도구입니다. 이 API를 활용하여 개발자들은 사용자와 동적 대화를 나누며 관련 정보와 맞춤 경험을 제공할 수 있는 지능형 챗봇을 만들 수 있습니다.\n\n이 글을 더 깊이 이해하면, 새로운 Assistant API를 사용하여 완전히 기능적인 챗봇을 구현하는 방법을 알아볼 것입니다. 이 챗봇은 아이스 하키 전문가로서 특정 지침을 줄 것입니다. 🏒\n\n시작해 봅시다! 👏👏👏👏\n\n## 단계 1: 개발 환경 설정\n\n새로운 리액트 프로젝트를 만들고 필요한 라이브러리와 의존성을 설치하는 것은 어떤 리액트 개발을 시작하는 핵심 단계입니다. 몇 가지 간단한 단계를 따르면 프로젝트를 신속하게 시작할 수 있습니다.\n\n- Node.js와 npm을 설치합니다 (이미 설치되어 있지 않은 경우)\n- 터미널이나 명령 프롬프트를 엽니다\n- 다음 명령어를 실행하여 Create React App을 설치합니다\n\n```js\nnpm install -g create-react-app\n```\n\n4. 다음 명령어를 실행하여 새로운 리액트 앱을 만듭니다 (여기서 \"my-app\"은 앱의 이름입니다)\n\n```bash\nnpx create-react-app my-app --template typescript\n```\n\n5. 해당 명령어를 실행하여 새 앱 디렉토리로 이동합니다.\n\n```bash\ncd my-app\n```\n\n6. Material-UI 및 그 종속성을 설치합니다.\n\n```js\nnpm install @mui/material @emotion/react @emotion/styled\n```\n\n7. 다음 명령어를 실행하여 개발 서버를 시작하세요.\n\n```js\nnpm start\n```\n\n이것으로 설정이 완료되었습니다! 이제 새로운 React 앱이 http://localhost:3000 에서 작동해야 합니다. 코드 편집기에서 앱을 열고 필요한 대로 코드를 사용자 정의할 수 있습니다.\n\n# 단계 2: React 앱 챗봇 컴포넌트 생성\n\n채팅 인터페이스를 위한 컴포넌트를 생성하세요. 각 메시지 컴포넌트를 렌더링하는 Chat 컴포넌트를 만들 수 있습니다.\n\n/src/components/Message.tsx\n\n```js\n// src/components/Message.tsx\nimport React from 'react';\n\ninterface MessageProps {\n  text: string;\n  isUser: boolean;\n}\n\nconst Message: React.FC\u003cMessageProps\u003e = ({ text, isUser }) =\u003e {\n  return (\n    \u003cdiv style={ textAlign: isUser ? 'right' : 'left', margin: '8px' }\u003e\n      \u003cdiv style={ backgroundColor: isUser ? '#DCF8C6' : '#b8e3fc', padding: '8px', borderRadius: '8px' }\u003e\n        {text}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Message;\n```\n\n/src/components/Chat.tsx\n\n```js\n// src/components/Chat.tsx\nimport React, { useState } from 'react';\nimport { TextField, Button, Container, Grid } from '@mui/material';\nimport Message from './Message';\n\nconst Chat: React.FC = () =\u003e {\n  const [messages, setMessages] = useState\u003cstring[]\u003e([]);\n  const [input, setInput] = useState\u003cstring\u003e('');\n\n  const handleSendMessage = () =\u003e {\n    setMessages([...messages, input]);\n    setInput('');\n    // 챗봇 응답을 처리하는 로직을 추가하세요\n  };\n\n  return (\n    \u003cContainer\u003e\n      \u003cGrid container direction=\"column\" spacing={2}\u003e\n        \u003cGrid item\u003e\n          {messages.map((message, index) =\u003e (\n            \u003cMessage key={index} text={message} isUser={index % 2 === 0} /\u003e\n          ))}\n        \u003c/Grid\u003e\n        \u003cGrid item\u003e\n          \u003cTextField\n            label=\"메시지를 입력하세요\"\n            variant=\"outlined\"\n            fullWidth\n            value={input}\n            onChange={(e) =\u003e setInput(e.target.value)}\n          /\u003e\n        \u003c/Grid\u003e\n        \u003cGrid item\u003e\n          \u003cButton variant=\"contained\" color=\"primary\" onClick={handleSendMessage}\u003e\n            전송\n          \u003c/Button\u003e\n        \u003c/Grid\u003e\n      \u003c/Grid\u003e\n    \u003c/Container\u003e\n  );\n};\n\nexport default Chat;\n```\n\n# 단계 3: Chat 컴포넌트를 App.tsx에 통합하세요\n\nChat 컴포넌트를 사용하도록 src/App.tsx를 수정하세요.\n\n/src/App.tsx\n\n```javascript\n// src/App.tsx\nimport React from 'react';\nimport Chat from './components/Chat';\n\nconst App: React.FC = () =\u003e {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n         {/* 가운데 정렬 */}\n        \u003ch1 style={ textAlign: 'center' }\u003eReact Chatbot\u003c/h1\u003e\n      \u003c/header\u003e\n      \u003cmain\u003e\n        \u003cChat /\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n다음 명령어를 사용하여 React 앱을 실행하세요:\n\n```javascript\nnpm start\n```\n\n# 단계 4: OpenAI 어시스턴트 API로 시작하기\n\n어시스턴트 API를 사용하면 사용자 쿼리를 이해하고 대화식 방식으로 응답하는 지능형 챗봇을 만들 수 있습니다. 이러한 챗봇은 다양한 애플리케이션 및 플랫폼에 통합되어 사용자에게 원활한 지원을 제공할 수 있습니다. 🤖\n\n⚠️ 진행하기 전에 API 키를 생성해야 합니다!\n\n⚠️ OpenAI는 SPA 웹 앱과 같은 클라이언트 사이드 환경에서 API 키를 노출하는 것을 권장하지 않습니다. 요청은 항상 API 키를 안전하게 보관할 수 있는 자체 백엔드 서버를 통해 라우팅해야 합니다. 그러나 간편함을 위해, 우리는 단순하게 유지하고 프론트엔드 개발에 집중할 것입니다.\n\nOpenAI에서 API 키를 얻으려면 다음 단계를 따르세요:\n\n- OpenAI 계정을 만들거나 로그인하세요. 이미 OpenAI 계정이 없는 경우 새로 만들어야 합니다. OpenAI 웹사이트로 이동하여 \"가입하기\" 버튼을 클릭하여 계정을 만들 수 있습니다.\n- API Keys 페이지로 이동하세요. 로그인한 후에는 화면 우측 상단의 계정 이름을 클릭한 다음 \"API Keys\"를 선택하여 API Keys 페이지에 액세스할 수 있습니다.\n- 새 API 키를 생성하세요. API Keys 페이지에서 \"새 비밀 키 생성\" 버튼을 클릭하세요. 이렇게 하면 API 키의 이름을 입력할 수 있는 모달 창이 열립니다.\n- API 키를 저장하세요. API 키를 만든 후에는 반드시 안전한 곳에 저장하세요. 다른 사람과 API 키를 공유하지 마세요. 그렇게 하면 그들이 OpenAI 계정에 액세스할 수 있게 됩니다.\n\nAPI 키를 획득했다면, OpenAI API에 요청을 인증하는 데 사용할 수 있습니다. 이에 대한 자세한 정보는 OpenAI API 설명서에서 찾을 수 있습니다.\n\n## OpenAI Assistant API의 주요 구성 요소:\n\n- 쓰레드: 쓰레드는 Assistant API에서 대화의 기초입니다. 사용자와 어시스턴트 간에 교환된 메시지의 시퀀스를 나타냅니다. 쓰레드는 지속적일 수 있으며, 나중에 사용할 수 있도록 저장하고 검색할 수 있습니다.\n- 메시지: 메시지는 쓰레드 내에서의 개별 통신 단위입니다. 사용자 또는 어시스턴트가 보낼 수 있습니다. 메시지에는 텍스트, 코드, 이미지 또는 다른 파일이 포함될 수 있습니다.\n- 모델: Assistant API는 GPT-3.5 및 GPT-4와 같은 OpenAI의 텍스트 생성 모델에 액세스를 제공합니다. 이러한 모델은 텍스트 생성, 언어 번역 및 정보적인 방식으로 질문에 대답하는 데 사용할 수 있습니다.\n- 도구: 도구는 추가 기능을 제공하는 Assistant API의 확장 기능입니다. 예를 들어, 코드 인터프리터, 정보 검색 및 함수 호출 도구가 있습니다.\n- 지침: 지침은 Assistant API가 모델 및 도구를 사용하는 방법을 제어하는 방법입니다. 사용할 모델, 따를 지침 및 통합할 도구를 지정하는 데 사용할 수 있습니다.\n- 실행: 실행은 어시스턴트의 실행을 의미합니다. 현재 쓰레드를 처리하고 응답을 생성하도록 어시스턴트를 트리거합니다. 실행은 대화에 대한 데이터 수집 및 어시스턴트의 성능을 측정하는 데 사용할 수도 있습니다.\n- 파일: 파일은 대화와 관련된 데이터를 저장하고 참조하는 데 사용됩니다. 사용자가 업로드하거나 어시스턴트가 생성할 수 있습니다. 파일은 텍스트, 코드 또는 이미지와 같은 다양한 형식일 수 있습니다. 이 문서에서는 파일에 대해 다루지 않습니다.\n- 역할: 역할은 쓰레드 내의 다른 유형의 메시지를 구별하는 데 사용됩니다. 현재 지원되는 역할은 사용자와 어시스턴트입니다.\n\n이러한 구성 요소가 함께 작동하여 챗봇 및 AI 어시스턴트를 구축하는 강력하고 유연한 플랫폼을 제공합니다. Assistant API는 아직 개발 중이지만, 컴퓨터와 상호 작용하는 방식을 혁신할 잠재력이 있습니다. 🦾🤖\n\n다음은 OpenAI Assistant API를 사용하는 방법입니다. Node.js를 사용하여 OpenAI의 Assistant API를 설정하려면 다음 단계를 따라야 합니다:\n\n1. OpenAI Node.js 라이브러리 설치하기:\n\n먼저 Node Package Manager (npm)을 사용하여 openai 패키지를 설치해주세요.\n\n```js\nnpm install openai\n```\n\n2. 환경 파일을 생성해보세요:\n\n루트 디렉토리에 .env 파일을 생성하여 OpenAI API 키를 안전하게 저장하세요. 다음 줄을 .env 파일에 추가해 주세요. YOUR_API_KEY를 실제 OpenAI API 키로 대체해주세요:\n\n```js\nREACT_APP_OPENAI_API_KEY = 당신의_API_KEY;\n```\n\n3. 필요한 라이브러리를 가져옵니다:\n\n/src/components/Chat.tsx 파일에서 OpenAI 라이브러리를 가져옵니다:\n\n```js\nimport OpenAI from \"openai\";\n```\n\n4. OpenAI 클라이언트를 초기화하세요:\n\nOpenAI 클래스를 사용하여 API 키를 이용해 OpenAI 클라이언트를 초기화하세요:\n\n```js\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true,\n});\n```\n\n다음 단계에서 OpenAI Assistant API를 기존 코드에 통합할 때 이러한 단계를 다시 요약하겠습니다.\n\n# 단계 5: React 앱에 OpenAI API 통합하기\n\n이제 우리는 이전 단계에서 만든 React 앱과 OpenAI Assistant API 코드를 통합하는 필요한 단계로 들어가보겠습니다. 다음 변경 사항을 수행해주세요:\n\n다음과 같은 MessageDto 클래스를 가지고 Models 폴더를 생성하세요:\n\n/src/models/MessageDto.ts\n\n```js\nexport class MessageDto {\n  isUser: boolean;\n  content: string;\n\n  constructor(isUser: boolean, content: string) {\n    this.isUser = isUser;\n    this.content = content;\n  }\n}\n```\n\nMessage.tsx 파일을 수정해주세요:\n\n/src/components/Message.tsx\n\n```js\n// src/components/Message.tsx\nimport React from \"react\";\nimport { MessageDto } from \"../models/MessageDto\";\n\ninterface MessageProps {\n  message: MessageDto;\n}\n\nconst Message: React.FC\u003cMessageProps\u003e = ({ message }) =\u003e {\n  return (\n    \u003cdiv style={{ textAlign: message.isUser ? \"right\" : \"left\", margin: \"8px\" }}\u003e\n      \u003cdiv\n        style={{\n          color: message.isUser ? \"#ffffff\" : \"#000000\",\n          backgroundColor: message.isUser ? \"#1186fe\" : \"#eaeaea\",\n          padding: \"15px\",\n          borderRadius: \"8px\",\n        }}\n      \u003e\n        {message.content.split(\"\\n\").map((text, index) =\u003e (\n          \u003c\u003e\n            {text}\n            \u003cbr /\u003e\n          \u003c/\u003e\n        ))}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Message;\n```\n\n마침내 새로운 Chat.tsx 파일을 구현해주세요:\n\n/src/components/Chat.tsx\n\n```js\n// src/components/Chat.tsx\nimport React, { useEffect, useState } from \"react\";\nimport { TextField, Button, Container, Grid, CircularProgress, LinearProgress } from \"@mui/material\";\nimport Message from \"./Message\";\nimport OpenAI from \"openai\";\nimport { MessageDto } from \"../models/MessageDto\";\n\nconst Chat: React.FC = () =\u003e {\n  const [isWaiting, setIsWaiting] = useState\u003cboolean\u003e(false);\n  const [messages, setMessages] = useState\u003cArray\u003cMessageDto\u003e\u003e(new Array\u003cMessageDto\u003e());\n  const [input, setInput] = useState\u003cstring\u003e(\"\");\n  const [assistant, setAssistant] = useState\u003cany\u003e(null);\n  const [thread, setThread] = useState\u003cany\u003e(null);\n  const [openai, setOpenai] = useState\u003cany\u003e(null);\n\n  useEffect(() =\u003e {\n    initChatBot();\n  }, []);\n\n  useEffect(() =\u003e {\n    setMessages([\n      {\n        content: \"Hi, I'm your personal assistant. How can I help you?\",\n        isUser: false,\n      },\n    ]);\n  }, [assistant]);\n\n  const initChatBot = async () =\u003e {\n    const openai = new OpenAI({\n      apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n      dangerouslyAllowBrowser: true,\n    });\n\n    // Create an assistant\n    const assistant = await openai.beta.assistants.create({\n      name: \"Hockey Expert\",\n      instructions: \"You are a hockey expert. You specialize in helping others learn about hockey.\",\n      tools: [{ type: \"code_interpreter\" }],\n      model: \"gpt-4-1106-preview\",\n    });\n\n    // Create a thread\n    const thread = await openai.beta.threads.create();\n\n    setOpenai(openai);\n    setAssistant(assistant);\n    setThread(thread);\n  };\n\n  const createNewMessage = (content: string, isUser: boolean) =\u003e {\n    const newMessage = new MessageDto(isUser, content);\n    return newMessage;\n  };\n\n  const handleSendMessage = async () =\u003e {\n    messages.push(createNewMessage(input, true));\n    setMessages([...messages]);\n    setInput(\"\");\n\n    // Send a message to the thread\n    await openai.beta.threads.messages.create(thread.id, {\n      role: \"user\",\n      content: input,\n    });\n\n    // Run the assistant\n    const run = await openai.beta.threads.runs.create(thread.id, {\n      assistant_id: assistant.id,\n    });\n\n    // Create a response\n    let response = await openai.beta.threads.runs.retrieve(thread.id, run.id);\n\n    // Wait for the response to be ready\n    while (response.status === \"in_progress\" || response.status === \"queued\") {\n      console.log(\"waiting...\");\n      setIsWaiting(true);\n      await new Promise((resolve) =\u003e setTimeout(resolve, 5000));\n      response = await openai.beta.threads.runs.retrieve(thread.id, run.id);\n    }\n\n    setIsWaiting(false);\n\n    // Get the messages for the thread\n    const messageList = await openai.beta.threads.messages.list(thread.id);\n\n    // Find the last message for the current run\n    const lastMessage = messageList.data\n      .filter((message: any) =\u003e message.run_id === run.id \u0026\u0026 message.role === \"assistant\")\n      .pop();\n\n    // Print the last message coming from the assistant\n    if (lastMessage) {\n      console.log(lastMessage.content[0][\"text\"].value);\n      setMessages([...messages, createNewMessage(lastMessage.content[0][\"text\"].value, false)]);\n    }\n  };\n\n  // detect enter key and send message\n  const handleKeyPress = (e: React.KeyboardEvent\u003cHTMLDivElement\u003e) =\u003e {\n    if (e.key === \"Enter\") {\n      handleSendMessage();\n    }\n  };\n\n  return (\n    \u003cContainer\u003e\n      \u003cGrid container direction=\"column\" spacing={2} paddingBottom={5}\u003e\n        {messages.map((message, index) =\u003e (\n          \u003cGrid item alignSelf={message.isUser ? \"flex-end\" : \"flex-start\"} key={index}\u003e\n            \u003cMessage key={index} message={message} /\u003e\n          \u003c/Grid\u003e\n        ))}\n        \u003cGrid item\u003e\n          \u003cTextField\n            label=\"Type your message\"\n            variant=\"outlined\"\n            disabled={isWaiting}\n            fullWidth\n            value={input}\n            onChange={(e) =\u003e setInput(e.target.value)}\n            onKeyDown={handleKeyPress}\n          /\u003e\n          {isWaiting \u0026\u0026 \u003cLinearProgress color=\"inherit\" /\u003e}\n        \u003c/Grid\u003e\n        {!isWaiting \u0026\u0026 (\n          \u003cGrid item\u003e\n            \u003cButton variant=\"contained\" color=\"primary\" onClick={handleSendMessage} disabled={isWaiting}\u003e\n              Send\n            \u003c/Button\u003e\n          \u003c/Grid\u003e\n        )}\n      \u003c/Grid\u003e\n    \u003c/Container\u003e\n  );\n};\n\nexport default Chat;\n```\n\nReact 앱을 다음 명령어로 실행해보세요:\n\n```js\nnpm start\n```\n\n# 단계 6: 당신의 어시스턴트와 상호 작용하기\n\n이제 prompt를 사용하여 새로 만든 어시스턴트와 상호 작용할 준비가 되었습니다. 응답은 짧은 지연 후 화면에 표시됩니다. 아래와 같이 표시됩니다:\n\nPrompt:\n\n```js\n누가 사람들에게 요리를 가르치는 데 가장 적합한 이가 되었습니까?\n```\n\n답변:\n\n```js\n\"가장 적합한 요리 교육자\"라는 타이틀은 팬들과 요리 역사학자들 사이에서 치열한 논의의 대상입니다. 그러나 토론에서 자주 언급되는 몇 가지 이름은 다음과 같습니다:\n\n- **웨인 그레츠키(Wayne Gretzky)**: \"위대한 사람\"이라고 불리는 그레츠키는 NHL 역대 최고의 골, 어시스트, 포인트 기록 보유자입니다. 그는 수많은 기록을 보유하고 4회의 스탠리컵 챔피언입니다.\n- **바비 오어(Bobby Orr)**: 공격 능력으로 수비수 위치를 혁신한 오어는 2회의 아트 로스 트로피를 수상한 유일한 수비수입니다.\n- **고디 하워(Gordie Howe)**: \"미스터 하키\"로 별명 붙은 하워는 스코어링 능력과 체력에 뛰어난 선수로 유명합니다. 그는 6회의 리그 MVP 및 4회의 스탠리컵 챔피언입니다.\n- **마리오 라미우(Mario Lemieux)**: 놀라운 기술과 스코어링 능력을 가진 라미우는 경력 동안 심각한 건강 문제와 싸우면서 필츠버그 펭귄스를 2회의 스탠리컵 우승으로 이끌었습니다.\n- **모리스 리차드(Maurice Richard)**: \"로켓\"으로 불리는 그는 50게임에서 50골을 넣는 최초의 선수였고 골을 넣는 능력과 강한 결의로 유명했습니다.\n\n하키 토론은 또한 서로 다른 시대, 포지션 및 게임의 변화를 고려합니다. 이 선수들 모두 그들의 시대에서 지배적이었으며 이들이 스포츠에 기여한 데 대해 널리 인정받고 있습니다.\n```\n\n🛠️ 제 개인 GitHub 계정에서 완전한 솔루션 코드를 확인하실 수 있습니다. 여기를 클릭해주세요.\n\n# 결론\n\nOpenAI의 Assistant API 도입으로 보조 인력의 접근성이 새로운 차원으로 발전했습니다. 이제 누구나 챗봇과 AI 보조 인력의 힘과 편의성을 누릴 수 있습니다.\n\nAssistant API는 개발자들이 AI 기반 보조 인력의 잠재력을 활용할 수 있는 손쉬운 방법을 제공합니다.\n\n결론적으로, OpenAI의 Assistant API를 통한 보조 인력의 접근성은 개인 및 기업이 AI 기술의 힘을 활용할 수 있게 합니다. 우리 손끝에 챗봇이 있음으로써 생산성을 향상하고 고객 경험을 향상하며 다양한 산업에서 새로운 기회를 극대화할 수 있습니다.\n\n지금까지였어요. 만약 이 이야기를 좋아하셨다면, 팔로우하고 박수를 부탁드려요. 👏👏\n\n## 참고 자료\n\n[1] https://platform.openai.com/docs/assistants/how-it-works. OpenAI\n\n[2] https://medium.com/@ralfelfving/tutorial-get-started-with-the-new-openai-assistants-api-7049c2517bfe. Ralf Elfving\n","ogImage":{"url":"/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png"},"coverImage":"/assets/img/2024-05-12-AStep-By-StepGuidetocreatingyourownassistantchatbotusingOpenAIsAssistantAPIandReact_0.png","tag":["Tech"],"readingTime":14},{"title":"React Router를 사용하여 React에서 단일 페이지 앱SPA 만들기","description":"","date":"2024-05-12 20:52","slug":"2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter","content":"\n\n## React 및 Typescript를 사용한 흐름 예제와 일부 패키지\n\n단일 페이지 어플리케이션(SPA)은 단일 HTML 페이지를로드하고 사용자가 애플리케이션과 상호 작용할 때 콘텐츠를 동적으로 업데이트하는 웹 어플리케이션입니다.\n\n최근에 React 코스를 마쳤는데 React Router를 사용하여 SPA를 만들어야 하는 React 애플리케이션을 작업해야 했습니다. 작업 중이던 애플리케이션은 단일 페이지 애플리케이션이었으며 목표는 여러 뷰를 가지는 것이었습니다. 새로운 뷰로 이동할 때 페이지를 다시로드하는 대신, 현재 URL에 기반하여 적합한 컴포넌트를 동적으로 렌더링하기 위해 React Router를 설치했습니다. 따라서 다양한 경로를 정의하고 각 경로는 적절한 경로와 렌더링할 컴포넌트가 지정된 Route 컴포넌트를 사용하여 정의되었습니다.\n\nReact Router에서 정말 감사한 점 중 하나는 다른 뷰 사이를 탐색하는 것이 얼마나 쉬웠는지입니다. Link 컴포넌트를 사용하여 다른 뷰 간의 링크를 만들 수 있었으며 React Router가 URL을 업데이트하고 적절한 컴포넌트를 렌더링하는 데 처리했습니다.\n\n\n\nReact Router를 사용하면 여러 뷰가 있는 복잡한 싱글 페이지 애플리케이션을 쉽게 만들 수 있다는 것을 발견했어요. 현재 URL에 기반하여 동적으로 컴포넌트를 렌더링하고 뷰 간의 탐색을 처리하는 것을 보는 것이 정말 좋았어요!\n\n![이미지](/assets/img/2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter_0.png)\n\n## 왜 SPA 응용 프로그램을 사용해야 할까요?\n\n- SPA는 페이지 새로고침을 최소화하고 빠른 로드 시간을 제공하여 사용자 경험을 개선합니다.\n- 모듈식 디자인으로 인해 유지 보수와 개발이 쉽고 전통적인 웹 애플리케이션과 비교했을 때 성능이 더 좋습니다. 필요한 리소스만을 로드하기 때문에 리소스 효율이 높아요.\n- 오프라인 이용이 가능하여 사용자 참여도를 높입니다.\n- 사용자 데이터를 보호하는 강력한 보안 기능을 갖추고 있을 수 있어요.\n\n\n\n## SPA가 사용되는 애플리케이션은 무엇인가요?\n\n- Facebook 및 Twitter와 같은 소셜 미디어 플랫폼\n- Gmail 및 Outlook와 같은 이메일 클라이언트\n- Trello 및 Asana와 같은 생산성 도구\n- Netflix 및 YouTube와 같은 비디오 스트리밍 서비스\n- Amazon 및 eBay와 같은 전자 상거래 사이트\n\n## React와 Typescript 및 일부 패키지를 사용하여 SPA를 만드는 방법에 대한 Flow 예제를 확인하세요.\n\n- create-react-app 명령을 사용하여 새 React 프로젝트를 생성합니다.\n- React, React-DOM, React-Router-DOM, Typescript 및 Webpack과 같은 필수 종속성을 설치합니다.\n- SPA 애플리케이션을 위한 새 컴포넌트를 만듭니다.\n- React Router를 사용하여 SPA 애플리케이션의 라우트를 정의합니다.\n- 예를 들어 Axios를 사용하여 서버에서 데이터를 가져오기 위한 API 호출을 수행합니다.\n- Redux 또는 React Context API를 사용하여 애플리케이션의 상태를 관리합니다.\n- 인증, 캐싱 및 오류 처리와 같은 추가 기능을 SPA 애플리케이션에 추가합니다.\n- Webpack을 사용하여 SPA 애플리케이션을 빌드합니다.\n- AWS, MongoDB 또는 Azure와 같은 웹 서버 또는 클라우드 플랫폼에 SPA 애플리케이션을 배포합니다.\n\n\n\n# 이제 React Router와 TypeScript를 사용하여 4개의 컴포넌트를 사용하여 React에서 가장 기본적인 싱글 페이지 앱을 만드는 예제입니다.\n\n우리는 create-react-app을 사용하여 React/Typescript 앱을 만듭니다:\n\n```js\nnpx create-react-app my-app --template typescript\n```\n\nReact Router를 설치하세요:\n\n\n\n```js\nnpm install react-router-dom @types/react-router-dom\n```\n\n자, 이제 쉬운 네비게이션 메뉴와 라우팅을 만들어 봅시다. 먼저 Router 컴포넌트를 생성하고 Route 컴포넌트를 사용하여 네 가지 경로를 정의합니다. 그리고 Link 컴포넌트를 사용하여 간단한 네비게이션 메뉴를 만들어 봅니다. 간단하죠?\n\n```js\nimport React from 'react';\nimport { BrowserRouter as Router, Link, Route, Switch } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nimport Products from './components/Products';\nimport Contact from './components/Contact';\n```\n\n```js\nconst App: React.FC = () =\u003e {\n  return (\n    \u003cRouter\u003e\n      \u003cnav\u003e\n        \u003cul\u003e\n          \u003cli\u003e\n            \u003cLink to=\"/\"\u003eHome\u003c/Link\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003cLink to=\"/about\"\u003eAbout\u003c/Link\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003cLink to=\"/products\"\u003eProducts\u003c/Link\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\n            \u003cLink to=\"/contact\"\u003eContact\u003c/Link\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/nav\u003e\n      \u003cSwitch\u003e\n        \u003cRoute exact path=\"/\" component={Home} /\u003e\n        \u003cRoute path=\"/about\" component={About} /\u003e\n        \u003cRoute path=\"/products\" component={Products} /\u003e\n        \u003cRoute path=\"/contact\" component={Contact} /\u003e\n      \u003c/Switch\u003e\n    \u003c/Router\u003e\n  );\n};\nexport default App;\n```\n\n\n\n그 다음, 몇 가지 기본 구성 요소를 생성해 봅시다! 먼저 환영 메시지를 표시하는 Home을 만들어 보겠습니다.\n\n```js\nimport React from 'react';\n```\n\n```js\nconst Home: React.FC = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eHome\u003c/h1\u003e\n      \u003cp\u003eWelcome to our website!\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default Home;\n```\n\n회사에 대한 정보를 표시하는 About 컴포넌트도 만들어봅시다.\n\n\n\n```js\nimport React from 'react';\n```\n\n```js\nconst About: React.FC = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eAbout\u003c/h1\u003e\n      \u003cp\u003eDiego의 회사에 대해 더 알아보세요!\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default About;\n```\n\n제품 목록을 보여주는 AProducts 컴포넌트입니다.\n\n```js\nimport React from 'react';\n```\n\n\n\n```js\nconst Products: React.FC = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e제품\u003c/h1\u003e\n      \u003cul\u003e\n        \u003cli\u003e제품 1\u003c/li\u003e\n        \u003cli\u003e제품 2\u003c/li\u003e\n        \u003cli\u003e제품 3\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n};\nexport default Products;\n```\n\n마지막으로 이름과 이메일을 요청하는 양식이 있는 Contact 컴포넌트입니다.\n\n```js\nimport React from 'react';\n```\n\n```js\nconst Contact: React.FC = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e문의하기\u003c/h1\u003e\n      \u003cform\u003e\n        \u003clabel\u003e\n          이름:\n          \u003cinput type=\"text\" name=\"name\" /\u003e\n        \u003c/label\u003e\n        \u003cbr /\u003e\n        \u003clabel\u003e\n          이메일:\n          \u003cinput type=\"email\n```  \n\n\n\n리액트 프로젝트에서는 React Router와 같은 라우팅 라이브러리를 사용하여 SPA 내에서 다른 페이지 간의 이동을 처리할 수 있습니다. 또한 Redux나 MobX와 같은 상태 관리 라이브러리를 사용하고 API를 사용하여 SPA 내에서 데이터를 동적으로 가져와 표시할 수도 있습니다. 이러한 도구들을 사용하면 강력하고 반응이 뛰어난 SPA를 만들어 부드러운 사용자 경험을 제공할 수 있습니다.\n\n# 이 게시물이 마음에 드셨나요? 언제든지 채팅해 주세요! :)","ogImage":{"url":"/assets/img/2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter_0.png"},"coverImage":"/assets/img/2024-05-12-CreatingaSingle-PageAppSPAinReactusingReactRouter_0.png","tag":["Tech"],"readingTime":5},{"title":"대기업 프론트엔드 단골 useState 질문","description":"","date":"2024-05-12 20:51","slug":"2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong","content":"\n\u003cimg src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png\" /\u003e\n\n리액트에서 `useState`는 함수 컴포넌트에서 상태를 관리하는 데 필수적인 도구입니다. 그 사용법은 직관적이고 유연합니다. 하지만 초보자들과 어떤 경험이 있는 개발자들도 `useState`가 어떻게 작동하는지와 관련된 세부 내용을 완전히 이해하지 못할 수 있습니다.\n\n다음 코드를 분석해보겠습니다. 버튼 A, B, C, D를 클릭한 후에 각 버튼에 표시된 숫자를 고려하고 이러한 결과가 발생하는 이유를 생각해봅시다.\n\n```js\nimport { useState } from \"react\";\n\nexport default function UseStateDemo() {\n  const [numberA, setNumberA] = useState(0);\n  const [numberB, setNumberB] = useState(0);\n  const [numberC, setNumberC] = useState(0);\n  const [numberD, setNumberD] = useState(0);\n\n  const handleButtonA = () =\u003e {\n    setNumberA(numberA + 1);\n    setNumberA(numberA + 1);\n  };\n\n  const handleButtonB = () =\u003e {\n    setNumberB((n) =\u003e n + 1);\n    setNumberB((n) =\u003e n + 1);\n  };\n\n  const handleButtonC = () =\u003e {\n    setNumberC(numberC + 3);\n    setNumberC((n) =\u003e n + 1);\n  };\n\n  const handleButtonD = () =\u003e {\n    setNumberD(numberD + 4);\n    setNumberD((n) =\u003e n + 1);\n    setNumberD(99);\n  };\n\n  return (\n    \u003c\u003e\n      \u003cbutton\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonA}\n      \u003e\n        Button A {numberA}\n      \u003c/button\u003e\n      \u003cbutton\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonB}\n      \u003e\n        Button B {numberB}\n      \u003c/button\u003e\n      \u003cbutton\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonC}\n      \u003e\n        Button C {numberC}\n      \u003c/button\u003e\n      \u003cbutton\n        type=\"button\"\n        className=\"rounded-md bg-white m-8 p-2 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300\"\n        onClick={handleButtonD}\n      \u003e\n        Button D {numberD}\n      \u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_1.png\" /\u003e\n\n버튼 A를 누른 후 각각 버튼 B, 버튼 C, 버튼 D를 순서대로 클릭하면 버튼에 적힌 숫자가 1, 2, 4, 99인 것을 확인할 수 있어요.\n\n\u003cimg src=\"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_2.png\" /\u003e\n\n결과가 기대와 일치했나요?\n\n# 결과 분석\n\n## 버튼 A:\n\nsetNumberA(numberA + 1)가 두 번 호출되었습니다. 각 호출은 현재 값에 따라 상태를 업데이트하지만 상태 업데이트는 비동기적입니다. useState의 set 함수는 값이 즉시 업데이트되지 않고 다음 렌더링 중에 적용됩니다. 따라서 두 호출 모두 numberA의 동일한 기본값을 사용하여 0부터 1로만 증가합니다.\n\n## 버튼 B:\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n| Button | 역할                                                                                                                                                              |\n| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| A      | setNumberB(n = n + 1)를 두 번 사용합니다. 이 접근 방식은 각 증가가 최신 상태 값에 기반하게 합니다. 결과적으로 카운트가 정확하게 2씩 증가합니다.                   |\n| C      | 초기에 setNumberB(numberC + 3)은 직접 카운트를 3씩 증가시킵니다. 그런 다음 setNumberC(n = n + 1)는 최신 상태 값을 기반으로 추가로 1씩 증가시켜 총 4씩 증가합니다. |\n| D      |                                                                                                                                                                   |\n\n첫 번째 setNumberD(numberD + 4)는 수를 4씩 증가시킵니다. 다음으로 setNumberD(n =` n + 1)은 1씩 추가 증가시킵니다. 마지막으로 numberD를 직접 99로 설정하면 이전 증가가 무시되고 값을 99로 고정시킵니다.\n\n# 이유\n\n콜백 함수가 인수로 사용될 때(예: n =` n + 1), 현재 상태 값을 기준으로 증분을 허용합니다. 이는 상태 업데이트가 서로 의존하거나 업데이트가 가장 최신 값에 기반하는 것을 보장해야 할 때 유용합니다.\n\n변수 값 직접 업데이트하기(예: setNumber(value))는 특정 양을 명시적으로 추가하는 장점이 있습니다. 그러나 여러 직접 업데이트는 이전 상태 값이 사용되어 오래된 상태 값으로 인해 부정확한 업데이트를 초래할 수 있습니다.\n\n따라서, 콜백 함수를 사용하는 것은 정확한 증분 및 순차적 상태 업데이트가 필요한 시나리오에 더 적합합니다. 특히 업데이트가 기존 상태 값에 따라 결정될 때 유용합니다. 직접적인 업데이트는 간단한 증분이 필요하거나 현재 상태를 고려할 필요가 없는 상황에 더 적합합니다.\n\n# 결론\n\nuseState 훅을 사용하면 함수 컴포넌트에서 상태 변수를 선언하고 상태를 업데이트하는 함수를 제공합니다. 이는 상태를 비동기적으로 업데이트하여 여러 `set` 호출이 즉시 컴포넌트의 현재 렌더링 주기에 반영되지 않도록합니다.\n\nuseState의 설계는 함수 컴포넌트에서 상태 관리를 더 유연하게 만들어줍니다. 비동기 및 콜백 메커니즘을 이해하면 정확한 여러 상태 업데이트에 대해 올바르게 사용하는 데 도움이 됩니다.\n\n일반적으로 콜백 함수를 사용하여 정확한 업데이트를 보장하는 것이 좋습니다. 특히 여러 개의 업데이트가 비동기 환경에서 발생하는 경우에는 더욱 중요합니다.\n\n# 쉽게 설명한 것 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수치고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해 보세요\n","ogImage":{"url":"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png"},"coverImage":"/assets/img/2024-05-12-AuseStateQuestionThatAlmostAllBeginnersGetWrong_0.png","tag":["Tech"],"readingTime":5},{"title":"앵귤러 애플리케이션 보안 자바스크립트 난독화","description":"","date":"2024-05-12 20:49","slug":"2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation","content":"\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*wEYlPHz1sMXAZ6802MPrrw.gif\" /\u003e\n\n앵귤러는 주로 클라이언트 측 애플리케이션이기 때문에 코드가 사용자에게 노출됩니다. 적절한 기술을 갖추면 애플리케이션을 역공학하거나 내부 로직을 이해할 수 있습니다. 이를 방지하기 위해 코드를 암호화하여 명확함을 줄이고 이해하기 어렵게 만드는 것이 좋습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png\" /\u003e\n\n기본 제공된 앵귤러를 사용할 때 노출되는 것들:\n\n\n\n- 서비스\n- 구성요소\n- 설정\n\n우리 애플리케이션을 안전하게 보호하기 위해 비즈니스 로직을 보호해야 합니다. 데이터를 안전하게 유지하기 위해 코드베이스를 난독화해야 합니다. 그러나 uglifyjs와 같은 도구를 사용할 수 있습니다. 이러한 도구들은 일정한 수준에서 유용하지만, 난독화가 더 나은 결과를 제공합니다.\n\n# 목차\n\n- JavaScript 난독화란 무엇인가요?\n- JavaScript 난독화 기법:\n- JavaScript 난독화 예시:\n- 설치 및 설정\n- 빌드 구성 업데이트:\n- JavaScript 난독화기에서 제공하는 옵션:\n- 결론\n- 다음 단계?\n\n\n\n# 자바스크립트 난독화란 무엇인가요?\n\n자바스크립트 난독화란 직관적이고 쉽게 읽을 수 있는 자바스크립트 코드를 어렵게 만들어서 이해하기 어렵고 역공학으로 해독하기 어렵도록 변환하는 일련의 코드 변환 기술을 말합니다.\n\n# 자바스크립트 난독화 기술 :\n\n자바스크립트 난독화 기술은 코드를 이해하기 어렵게 하거나 역공학을 어렵게 하거나 변경하기 어렵게 만들기 위해 사용됩니다. 이러한 기술은 코드의 논리와 구조를 흐리게 하면서 기능을 유지하는 것을 목표로 합니다. 여기에 몇 가지 자주 사용되는 자바스크립트 난독화 기술이 있습니다:\n\n\n\n변수 이름 변경:\n\n변수 이름을 설명적이지 않거나 짧거나 한 글자로 변경합니다. 이렇게 하면 각 변수의 목적을 이해하기 어려워집니다.\n\n함수 이름 변경:\n\n변수 이름 변경과 마찬가지로 함수의 이름을 변경하여 그 의도된 기능을 숨길 수 있습니다.\n\n\n\n문자열 암호화:\n\n코드에서 문자열 리터럴을 암호화하고 런타임에서 복호화하는 것입니다. 이는 코드를 이해하려는 누구에게 추가적인 복잡성을 더합니다.\n\n코드 분할:\n\n코드를 여러 작은 함수 또는 파일로 나눈 다음 동적으로 로딩하거나 결합하는 것을 말합니다. 이렇게 하면 코드 구조가 덜 명백해집니다.\n\n\n\n통제 흐름 난독화:\n\n코드의 논리를 혼란스럽게 만들기 위해 불필요하거나 오도하는 제어 흐름 문장(추가 루프 또는 조건문 등)을 도입합니다.\n\n죽은 코드 주입:\n\n사용되지 않거나 관련 없는 코드 조각을 주입하여 혼란을 빚습니다. 이로써 코드의 중요한 부분과 중요하지 않은 부분을 구분하는 것이 어려워집니다.\n\n\n\n문자열 연결:\n\n문자열을 분해하고 실행 중에 동적으로 연결하는 것을 말합니다. 이로 인해 코드에서 사용된 실제 문자열을 식별하기 어려워집니다.\n\n인코딩 및 디코딩:\n\n코드의 일부를 인코딩하고 실행 중에 디코딩하는 작업을 의미합니다. 이 과정에는 Base64 인코딩과 같은 기술을 사용합니다.\n\n\n\n숫자 변형:\n\n숫자를 수학적 표현이나 다른 숫자 표현으로 대체하여 상수 값을 숨기는 것입니다.\n\n디버깅 방지 기술:\n\n디버거 환경에서 애플리케이션이 실행 중인지 감지하는 코드를 포함하고, 코드의 동작을 이에 맞게 변경하는 것입니다.\n\n\n\n# JavaScript 난독화 예제:\n\n다음 코드를 고려해보세요:\n\n```js\nfunction getUserData() {\n  if(!user) {\n      return {};\n    }\n    let data = user.auth.providerData[0];\n    return {\n      name: data.displayName,\n      avatar: data.photoURL,\n      email: data.email,\n      provider: data.providerId,\n      uid: user.auth.uid\n    };\n}\nconsole.log(getUserData());\n```\n\n난독화/압축된 코드:\n\n\n\n```js\nfunction getUserData() {\n  if (!user) return {};\n  let e = user.auth.providerData[0];\n  return {\n    name: e.displayName,\n    avatar: e.photoURL,\n    email: e.email,\n    provider: e.providerId,\n    uid: user.auth.uid\n  };\n}\n\nconsole.log(getUserData());\n```\n\n여기서 코드가 변형되었습니다. 더 자세히 살펴보거나 포매터를 사용하면 코드의 기본 논리를 이해할 수 있습니다.\n\n다른 시나리오에서 억제된 후 :\n\n```js\n(function(_0x49e7cc, _0x35d5f6) {\n  const _0xdfe59 = _0x3b90,\n    _0xd4b26e = _0x49e7cc();\n\n  while (!![]) {\n    try {\n      const _0x20c64f = parseInt(_0xdfe59(0xf9)) / 0x1 * (-parseInt(_0xdfe59(0xfa)) / 0x2) + -parseInt(_0xdfe59(0xf7)) / 0x3 * (parseInt(_0xdfe59(0xfc)) / 0x4) + parseInt(_0xdfe59(0xee)) / 0x5 * (-parseInt(_0xdfe59(0xf1)) / 0x6) + parseInt(_0xdfe59(0xf5)) / 0x7 + \n        -parseInt(_0xdfe59(0xf4)) / 0x8 + -parseInt(_0xdfe59(0xf2)) / 0x9 + parseInt(_0xdfe59(0xf6)) / 0xa * (parseInt(_0xdfe59(0xf0)) / 0xb);\n      \n      if (_0x20c64f === _0x35d5f6) break;\n      else _0xd4b26e['push'](_0xd4b26e['shift']());\n    } catch (_0x29db07) {\n      _0xd4b26e['push'](_0xd4b26e['shift']());\n    }\n  })(_0x53ef, 0xd14a3);\n\nfunction getUserData() {\n  const _0x2d7b7b = _0x3b90;\n  if (!user) return {};\n  let _0x4c86a3 = user[_0x2d7b7b(0xef)]['providerData'][0x0];\n  return {\n    'name': _0x4c86a3['displayName'],\n    'avatar': _0x4c86a3[_0x2d7b7b(0xfb)],\n    'email': _0x4c86a3['email'],\n    'provider': _0x4c86a3[_0x2d7b7b(0xf8)],\n    'uid': user[_0x2d7b7b(0xef)][_0x2d7b7b(0xf3)]\n  };\n}\n\nfunction _0x3b90(_0x40fb4f, _0x21bcc3) {\n  const _0x53ef2b = _0x53ef();\n  return _0x3b90 = function(_0x3b900f, _0x3ce21b) {\n    _0x3b900f = _0x3b900f - 0xee;\n    let _0x3732d2 = _0x53ef2b[_0x3b900f];\n    return _0x3732d2;\n  }, _0x3b90(_0x40fb4f, _0x21bcc3);\n}\n\nfunction _0x53ef() {\n  const _0x2e2efd = ['providerId', '254438AtTuWZ', '10GIuQhB', 'photoURL', '4aVsWJI', '20vNbtpg', 'auth', '3729QVEYgK', '340284BhPkpf', '4165182zMXsCd', 'uid', '13082696dHfPHS', '10353784ybaJZp', '98830ItJwbd', '1125051BYspDY'];\n\n  _0x53ef = function() {\n    return _0x2e2efd;\n  };\n\n  return _0x53ef();\n}\n\nconsole['log'](getUserData());\n```\n\n\n\n위 코드는 이제 훨씬 복잡하고 이해하기 어려워졌는데, 이는 초기 접근 방식보다 훨씬 나은 결과입니다. 사실 더 많은 난독화 수준을 추가할 수 있으며, 이에 대해 더 이야기할 것입니다.\n\n이제 난독화를 위해 우리의 Angular 애플리케이션을 설정해 봅시다.\n\n# 설치 및 설정:\n\n우리는 javascript-obfuscator 및 wepack-obfuscator 플러그인을 사용하여 코드를 난독화할 것입니다.\n\n\n\n귀하는 Angular 어플리케이션에서 위의 패키지들을 다음 명령어를 사용하여 설치할 수 있습니다.\n\n```js\nnpm install --save-dev javascript-obfuscator webpack-obfuscator\n```\n\n웹팩 설정 파일 생성/업데이트 :\n\n위의 플러그인을 설치한 웹팩 설정 파일을 생성하거나 업데이트하려면 기존 웹팩 설정 파일을 다음과 같이 업데이트하실 수 있습니다.\n\n\n\n```js\nvar WebpackObfuscator = require('webpack-obfuscator');\nmodule.exports = {\n module: {\n  ...//옵션\n  },\n```\n\n```js\n// Webpack 플러그인 배열\nplugins: [\n    new WebpackObfuscator ({\n       debugProtection: true\n    }, ['vendor.js'])\n   ]\n}\n```\n\n우리는 앵귤러 애플리케이션의 빌드/배포를 구성할 것이며, 앞서 작성한 위의 webpack.config를 포함하기 위해 custom-webpack 빌더를 사용하는 angular.json을 업데이트할 것입니다.\n\n## 빌드 구성 업데이트:\n\n\n\n아래 명령어를 사용하여 custom-webpack 빌더를 설치하십시오:\n\n- 아래 명령어를 사용하여 앵귤러 커스텀 빌더를 설치하십시오:\n\n```js\nnpm i @angular-builders/custom-webpack\n```\n\n- 아래 코드를 사용하여 angular.json 빌더를 업데이트하십시오.\n\n\n\n```js\n{\n   ...\n   \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-builders/custom-webpack:browser\",\n          \"options\": {\n            \"customWebpackConfig\": {\n              \"path\": \"./extra-webpack.config.js\",\n              \"mergeStrategies\": {\n                \"module.rules\": \"prepend\"\n              },\n            },\n            \"outputPath\": \"dist\",\n            ...          \n          }\n        }\n   }\n}\n```\n\n이렇게 하면 우리 애플리케이션을 빌드하여 응용 프로그램의 난독화된 코드를 생성할 수 있습니다.\n\n난독화된 빌드 생성:\n\nAngular CLI 옵션을 사용하여 애플리케이션을 빌드하면 됩니다:\n\n\n\n\n```js\nng build\n```\n\n빌드 후 우리 애플리케이션에서 노출된 키가 더 이상 보이지 않는 것을 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_1.png\" /\u003e\n\n# JavaScript 난독화기에서 제공하는 옵션:\n\n\n\n위의 예제에서는 debugProtection을 true로 전달했을 때, 앱 내에서 디버깅을 방지하고 디버거를 활성화한 익명 함수를 삽입하는 결과를 가져옵니다.\n\n![이미지](/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_2.png)\n\n주요 옵션 몇 가지:\n\n- stringArray:\n문자열 리터럴을 제거하고 특수 배열에 배치합니다. 예를 들어, var m = \"Hello World\";의 \"Hello World\" 문자열은 var m = _0x13a678[0x2];와 같은 것으로 대체됩니다.\n- stringArrayThreshold:\n문자열 리터럴이 stringArray에 삽입될 확률을 조정하는 데 사용할 수 있습니다(0부터 1까지). 기본값은 0.8입니다(1로 유지하면 일부 단계에서 코드가 중단됩니다).\n- debugProtection:\n위에서 보았듯이 디버깅 보호를 활성화합니다. 활성화된 디버깅 보호 간격(밀리초 단위).\n- transformObjectKeys:\n객체 키에 대한 변환을 적용할지 여부를 결정합니다(기본값: false).\n- forceTransformStrings:\n문자열 리터럴 추가가 확률에 기반하기 때문에 특정 키를 강제로 문자열 배열에 추가할 수 있습니다. 정규 표현식 배열을 수락합니다(특수 문자를 포함하는 문자열을 사용할 때 이스케이프 문자를 사용하세요).\n- stringArrayEncoding:\n문자열 리터럴을 base64 또는 rc4를 사용하여 인코딩합니다. 배열을 수락합니다. 아래 구성에서 stringArray 값은 인코딩되지 않으며 일부 값은 base64 및 rc4 인코딩으로 인코딩됩니다:\n\n\n\n```kotlin\nstringArrayEncoding: [\n    'none',\n    'base64',\n    'rc4'\n]\n```\n\n이것들은 유용할 수 있는 몇 가지 인기있는 키들입니다. 관련 정보를 더 읽어보고 여기에서 시도해 볼 수 있어요.\n\n코드 문제가 발생할 경우(정의되지 않은 속성을 가져올 때, 정의되지 않은 속성을 누를 때 또는 prototype이 정의되지 않았을 때 등 몇 가지를 들어봤어요) 아래 구성을 사용해 보세요:\n\n```kotlin\nnew WebpackObfuscator({\n        compact: true,\n        controlFlowFlattening: false,\n        deadCodeInjection: false,\n        debugProtection: false,\n        identifierNamesGenerator: 'hexadecimal',\n        numbersToExpressions: false,\n        renameGlobals: false,\n        selfDefending: false,\n        simplify: false,\n        splitStrings: false,\n        stringArray: true,\n        transformObjectKeys: false,\n        stringArrayCallsTransform: false,\n        stringArrayEncoding: [],\n        stringArrayIndexShift: false,\n        stringArrayRotate: false,\n        stringArrayShuffle: false,\n        stringArrayWrappersCount: 0,\n        stringArrayWrappersChainedCalls: false,\n        stringArrayWrappersParametersMaxCount: 2,\n        stringArrayWrappersType: 'variable',\n        stringArrayThreshold: 1,\n        unicodeEscapeSequence: false,\n        renamePropertiesMode: 'safe',\n        renameProperties: false\n    },['vendor.js']),\n```\n\n\n\nangular 프레임워크 관련 오류를 위해 vendor.js를 포함했어요 (선택 사항입니다). 몇 가지 기본 옵션이 복원되었으며 제거할 수 있어요.\n\n# 결론\n\n우리는 우리의 Angular 코드베이스를 난독화하여 더 안전한 코드로 한 걸음 더 가까워졌어요. 우리가 Angular에 구현했지만, 리액트와 같은 다른 프레임워크에도 구현할 수 있어요.\n\n# 다음은 무엇인가요?\n\n\n\n암호화: AES 및 RSA를 사용하여 네트워크 요청을 암호화하여 데이터를 기밀 유지합니다.\n\n참고 문헌:","ogImage":{"url":"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png"},"coverImage":"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png","tag":["Tech"],"readingTime":9},{"title":"리액트 JS에서 스톱워치를 만드는 간단한 방법","description":"","date":"2024-05-12 20:48","slug":"2024-05-12-Simplewaytocreateastopwatchinreactjs","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*cpD3T-0TChZXMlfpRFBBAQ.gif)\n\n안녕하세요! 이번 튜토리얼에서는 React JS로 시간, 분, 초 및 밀리초가 표시된 스톱워치를 만드는 방법을 배워보겠습니다. 스톱워치는 이벤트의 시작부터 종료까지 경과된 시간을 측정하는 데 사용되는 장치입니다.\n\n이 튜토리얼을 시작하기 전에 React JS 및 그 구성 요소에 대한 기본적인 이해가 필요합니다. 또한 Visual Studio Code와 같은 코드 편집기가 컴퓨터에 설치되어 있어야 합니다.\n\n단계 1: React 프로젝트 생성하기\n\n\n\nReact 프로젝트를 만들려면 다음 명령을 사용할 수 있어요:\n\n```js\nnpx create-react-app stopwatch\n```\n\n단계 2: 컴포넌트 작성\n이 단계에서는 \"Stopwatch\"라는 새 컴포넌트를 만들겠어요. \"src\" 폴더에 \"Stopwatch.js\"라는 새 파일을 만들어주세요. 이 파일에는 스톱워치의 로직이 포함되어요.\n\n단계 3: 설명\nuseEffect 훅에서는 10밀리초마다 시간을 증가시키기 위해 setInterval을 사용해요. clearInterval 함수는 cleanup 함수에서 반환되어, 컴포넌트가 Unmount될 때 간격을 멈추게 돼요. 코드의 나머지 부분은 주석을 사용하여 설명되었어요.\n\n\n\n단계 4: 스타일 추가하기\n“src\" 폴더에 “stopwatch.css\"라는 새 파일을 만들어 아래의 CSS 코드를 파일 안에 추가하고, 그 후에 CSS 파일을 우리의 “Stopwatch.js\" 파일에 import하세요.\n\n단계 5: 스톱워치 import하기\nApp.js 파일에서 Stopwatch 컴포넌트를 import하고 return 문 안에 렌더링하세요.\n\n질문이 있으시다면 LinkedIn을 통해 저에게 연락하실 수 있습니다.\n\n아래에서 GitHub 저장소와 codesandbox에서의 데모를 찾으실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-Simplewaytocreateastopwatchinreactjs_0.png"},"coverImage":"/assets/img/2024-05-12-Simplewaytocreateastopwatchinreactjs_0.png","tag":["Tech"],"readingTime":1},{"title":"모든 개발자가 알아야 할 상위 15개 이상의 GitHub 저장소","description":"","date":"2024-05-12 20:47","slug":"2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout","content":"\n\n프로그래머가 되는 길을 가속화시키는 방법\n\n![이미지](/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_0.png)\n\nGitHub은 오픈 소스 정신을 대변하는 우리가 좋아하는 사이트 중 하나입니다. 거기서 무료 전자책을 찾을 수 있고, 오늘날 가장 인기 있는 기술 주제를 논의하며, 코딩 기술을 향상시킬 수 있습니다.\n\n이 게시물에서는 내가 가장 유용하게 느끼는 15가지 GitHub 저장소를 공유하고 싶고, 여러분이 즐길 것으로 기대합니다.\n\n\n\n# 1. 글쓰기로 돈 벌기\n\n만약 훌륭한 글을 쓰는 것을 즐기신다면, 여기 목록에서 돈을 벌 수 있는 적절한 방법을 찾을 수 있을 겁니다.\n\n이런 글들을 읽기 위해 돈을 주고자 하는 많은 사람들 때문에, 여러분은 많은 돈을 벌 수 있는 글쓰기 전문가가 될 수 있다고 믿습니다.\n\n# 2. 인터뷰를 쉽게 만들기\n\n\n\n경쟁적인 면접을 통과하는 방법이 뭘까요?\n\n오! 우리는 먼저 면접관을 만족시킬 이력서를 작성해야 해요. 이건 처음으로 해야 할 일 중 하나랍니다.\n\n나는 이 두 개의 GitHub 저장소를 정말 좋아해요. 여기에는 이력서부터 면접까지의 전체 과정을 담은 완성된 패키지가 하나 있다구요.\n\n거기에는 많은 고전적인 기술 면접 질문과 프로그램 코드 조각들이 많이 있답니다!\n\n\n\n# 3. # 무료 프로그래밍 서적(281k)\n\n와우!!! 정말 대단해요.\n\n이것은 저에게 많은 도움을 주었어요. 프론트엔드 개발 엔지니어로 성장하는 여정에서, 무료 프로그래밍 서적, 고품질 무료 온라인 강의, 그리고 비디오, 팟캐스트 등을 통해 많은 도움을 받았어요.\n\n우리 기술 스킬을 향상시키는 데 사용할 자료는 부족하지 않지만, 더 나은 사람이 되기 위한 결의와 행동이 부족합니다.\n\n\n\n# 4. # The Art of Command Line(137k)\n\n프로그래밍을 처음 시작했을 때는 그래픽 인터페이스 소프트웨어가 제일 즐겨 사용했어요. 터미널을 열고 명령어를 사용하는 것이 어렵다고 생각해서 심지어 두려워했죠.\n\n그런데 어느 날, 명령어줄의 매력을 정말로 깨달았어요. 고급 개발자가 되고 싶다면, 꼭 명령어줄을 배우는 데 시간을 투자해야 합니다.\n\n# 5. # javascript-algorithms(171k)\n\n\n\n솔직히 말해서, 프론트엔드 개발자로서 저는 업무에서 알고리즘을 거의 사용하지 않습니다. 오히려 그것이 전혀 중요하지 않다고 생각하며, 제 우수한 업무에는 영향을 미치지 않는다고 생각합니다.\n\n하지만 컴퓨터의 진정한 마법을 이해하고 싶다면, 자료 구조와 알고리즘을 배워야 한다는 것을 알고 있습니다.\n\n해당 저장소에는 다양한 인기 알고리즘과 자료 구조의 JavaScript 기반 예제가 포함되어 있습니다.\n\n프론트엔드 개발자에겐 안성맞춤입니다.\n\n\n\n```js\nimport Sort from '../Sort';\n```\n\n```js\nexport default class QuickSort extends Sort {\n  /**\n   * @param {*[]} originalArray\n   * @return {*[]}\n   */\n  sort(originalArray) {\n    // 수정을 방지하기 위해 원본 배열을 복제합니다.\n    const array = [...originalArray];\n    // 배열에 요소가 하나 이하면 이미 정렬된 상태입니다.\n    if (array.length \u003c= 1) {\n      return array;\n    }\n    // 좌측 배열과 우측 배열을 초기화합니다.\n    const leftArray = [];\n    const rightArray = [];\n    // 배열의 첫 번째 요소를 피벗으로 선택합니다.\n    const pivotElement = array.shift();\n    const centerArray = [pivotElement];\n    // 모든 배열 요소를 좌측, 중앙, 우측 배열로 분리합니다.\n    while (array.length) {\n      const currentElement = array.shift();\n      // 콜백 함수를 호출합니다.\n      this.callbacks.visitingCallback(currentElement);\n      if (this.comparator.equal(currentElement, pivotElement)) {\n        centerArray.push(currentElement);\n      } else if (this.comparator.lessThan(currentElement, pivotElement)) {\n        leftArray.push(currentElement);\n      } else {\n        rightArray.push(currentElement);\n      }\n    }\n    // 좌측과 우측 배열을 정렬합니다.\n    const leftArraySorted = this.sort(leftArray);\n    const rightArraySorted = this.sort(rightArray);\n    // 이제 정렬된 좌측 배열을 중앙 배열과 정렬된 우측 배열과 함께 결합합니다.\n    return leftArraySorted.concat(centerArray, rightArraySorted);\n  }\n}\n```\n\n# 6. # You-Dont-Know-JS(168k)\n\n프론트엔드 개발자로서 저는 주로 자바스크립트를 사용합니다. 그러나 자바스크립트는 매우 빠르게 변하므로 매년 새로운 기능과 프레임워크가 등장하여 학습 열정을 유지해야 합니다. \n\n\n\n# 7. 무료이지만 강력한 Api 목록(242k)\n\n애플리케이션을 작성할 무료 데이터를 찾고 있다면, 이 목록이 최선의 선택이 될 것입니다.\n\n음악, 뉴스, 소셜, 날씨 등이 포함되어 있습니다. 이 목록을 정말 좋아합니다. 음악 소프트웨어를 작성하거나 날씨에 관한 웹 사이트를 만드는 등 여러 가지 용도로 사용할 수 있어요.\n\n\n\n# 8. # 30-seconds-of-code(112k)\n\n와우! 이 아름다운 검색 페이지를 한번 보세요. 프로그래머의 성향에 아주 잘 맞죠.\n\n![image](/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_1.png)\n\n여기서 많은 코드 조각을 찾을 수 있어요. 이것들은 우리 업무에서 대부분의 문제를 해결하는 데 사용할 수 있어요.\n\n\n\n# 9. 비밀 지식의 책(99.1k)\n\n헤이커들의 백과사전, 기술 블로그, 원 라이너 등을 모두 담고 있어요. 개발자들이 일상적인 작업을 거의 모두 처리할 수 있도록 도와줘요.\n\n# 10. 프런트엔드 개발자 면접 질문들(57.2k)\n\n![이미지](/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_2.png)\n\n\n\n프론트엔드 개발자 인터뷰 준비하는 방법을 모르겠다면, 이 목록에서 적절한 정보를 찾아보세요.\n\n## 11. Gitignore (148k)\n\n새로운 프로젝트를 생성할 때마다 .gitignore 파일을 수동으로 작성해야 했는데, 이 작업은 매우 비효율적이고 엉망입니다.\n\n어느 날, 저는 유용한 .gitignore 템플릿이 많이 있는 보물을 발견했습니다. 정말 멋진 것이죠.\n\n\n\n# 12. # 33-js-concepts(56.3k)\n\nJavaScript 개발자가 알아야 할 33가지 개념.\n\nhttps://github.com/leonardomso/33-js-concepts\n\n# 13. # css-protips(25.4k)\n\n\n\n내 친구야, CSS를 배우는 게 JavaScript보다 쉬울 것 같아? 실제로는 CSS를 아주 잘 다루는 개발자라도 매우 어려운 일이죠.\n\n14. # design-resources-for-developers(51.7k)\n\n웹 템플릿, UI 라이브러리, 사진 등 필요한 모든 자원을 제공합니다.\n\n15. # web-skills(6.5k)\n\n\n\n10년의 업무 경험에서 기술을 배울 수 있어요\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 clapping하고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_0.png"},"coverImage":"/assets/img/2024-05-12-Top15GitHubReposEveryDeveloperShouldKnowAbout_0.png","tag":["Tech"],"readingTime":5},{"title":"Electron과 React를 활용한 최종 가이드","description":"","date":"2024-05-12 20:44","slug":"2024-05-12-TheUltimateGuidetoElectronwithReact","content":"\n\n![The Ultimate Guide to Electron with React](/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_0.png)\n\n가장 포괄적인 크로스 플랫폼 데스크톱 앱 개발 여정에 오신 것을 환영합니다.\n\n본문에서는 Electron과 React의 강력한 기능을 어떻게 구현하는지 배워보겠습니다. 이 글을 끝까지 읽으면 다음과 같은 구현 방법을 마스터하게 될 것입니다:\n\n- 데스크톱 앱 화면을 만드는 방법\n- Electron에서 react-router-dom을 사용하여 라우트를 구현하는 방법\n- React 컴포넌트에서 remote 모듈을 사용해 네이티브 호출을 하는 방법\n- React 컴포넌트 내에서 OS별 다이얼로그를 트리거하는 방법\n- Electron에서 IPC(Inter-process Communication)하는 방법\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:940/1*jkoCIr04_tZ6i8fACZQ5dQ.gif\" /\u003e\n\n# 일렉트론을 사용하여 제작된 주요 앱들\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*VwPQAQ_7t0Iw666IzEzdQw.gif\" /\u003e\n\n# 일렉트론? 물리학을 배우는 거면 나는 물러갈래요!\n\n\n\n일렉트론은 크로미움 엔진에서 작동하는 견고한 다중 프로세스 아키텍처 프레임워크입니다. 이는 무거운 I/O 및 CPU 바운드 작업이 UI(주 프로세스)를 차단하지 않도록 새 스레드에 넣어 처리한다는 것을 보장합니다.\n\n일렉트론은 최신 버전의 크롬을 함께 제공합니다. 그 강력한 기능을 활용해 애플리케이션 창(렌더러 프로세스)에서 무거운 계산을 조율할 수 있어 앱이 60fps로 실행될 수 있습니다.\n\n# 잠깐! 주 프로세스가 뭔가요? 무서워 보이는데요!\n\n주 프로세스는 일렉트론 앱의 주요 부분입니다. 여러 개의 하위 프로세스(렌더러 프로세스라고도 함)를 생성할 수 있습니다. 어떻게 할까요? 곧 알아볼게요.\n\n\n\nReact 앱을 Electron과 함께 빠르게 설정해보겠습니다.\n\nnode 및 npm이 설치되어 있다고 가정합니다. electron-app이라는 이름의 폴더를 만들고, 즐겨 사용하는 코드 편집기로 해당 폴더를 열어주세요.\n\n터미널을 열고 npx create-react-app . 명령어를 실행해주세요. 여기서 마지막에 점(.)을 붙여주면 현재 폴더에 React 앱이 생성됩니다.\n\npublic 폴더 아래에 main.js라는 파일을 생성해주세요.\n\n\n\n\n![이미지](/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_1.png)\n\n다음 코드를 main.js 파일에 복사하세요. 나중에 이 코드가 무엇을 하는지 돌아와서 설명하겠습니다.\n\n이제 package.json 파일을 엽니다.\n\n다음과 같이 main.js 파일을 가리키는 경로를 가진 main 엔트리를 추가하세요.\n\n\n\n```js\n// 이 줄에 쉼표를 추가하는 것을 잊지 마세요\n\"private\":true,\n// 다음 줄을 추가하세요\n\"main\":\"public/main.js\"\n```\n\n이제 Electron을 설치할 준비가 되었습니다. 터미널을 열고 다음을 실행하세요:\n\n```js\nnpm i electron\n```\n\n이제 package.json 파일의 scripts 섹션에 리액트 앱을 Electron에서 실행할 수 있는 항목을 추가해봅시다.\n\n\n\npackage.json 파일의 scripts 섹션에 아래와 같이 electron-dev 항목을 추가하세요. 이 항목의 값은 electron이어야 합니다.\n\n만약 모든 단계를 올바르게 따랐다면, package.json 파일은 아래와 같이 보여야 합니다.\n\n이제 electron 앱을 시작할 시간입니다. Electron은 react-app을 에뮬레이트하기 때문에 우선 react-app이 실행되어야 합니다.\n\n\n\n터미널 창을 열고 다음 명령어를 실행해주세요:\n\n```js\nnpm start\n```\n\n브라우저에서 리액트 앱이 실행되면, 다른 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nnpm run electron-dev\n```\n\n\n\n네이티브 데스크탑 창에서 첫 번째 일렉트론 앱이 실행되고 있어요!\n\n![이미지](/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_3.png)\n\n# 메인 프로세스\n\n일렉트론 앱은 메인 프로세스를 가지고 있어요. 이 프로세스는 BrowserWindows를 생성하여 GUI를 만들어요. 각 BrowserWindow는 독립적인 랜더러 프로세스를 실행하며, BrowserWindow가 닫힐 때 파괴돼요. npm run electron-dev (내부적으로 electron .를 실행) 명령어를 실행하면, 메인 프로세스가 시작되고 일렉트론 환경을 초기화해요.\n\n\n\n다음으로, 주 프로세스는 package.json 파일에서 주요 항목을 찾아 주 파일을 실행합니다.\n\nmain.js 파일에서 Electron은 ready 이벤트가 이미 발생했는지 확인합니다.\n\nwhenReady() 함수는 ready 이벤트가 발생했을 때에만 이행된 프로미스를 반환합니다.\n\n```js\napp.whenReady().then(createWindow)\n```\n\n\n\n만약 whenReady() 함수가 완료된 프로미스를 반환하면, createWindow() 함수가 실행됩니다. createWindow() 함수는 새 BrowserWindow 인스턴스를 생성하고 해당 창 안에 웹페이지를 로드합니다.\n\n# 렌더러 프로세스\n\n각 렌더러 프로세스는 그 안에서 실행 중인 웹페이지에 대해 관심을 갖습니다. BrowserWindow는 HTML 파일을 찾습니다. 우리의 경우, 리액트 앱은 포트 3000에서 실행 중인 index.html 파일을 가지고 있습니다. loadURL() 함수에 html 파일의 URL을 전달하면, 일렉트론은 BrowserWindow에서 해당 파일을 로드합니다.\n\n```js\nwin.loadURL('http://localhost:3000');\n```\n\n\n\n만약 모든 BrowserWindows가 닫혔을 때 앱 종료 작업을 알리면, window-all-closed 이벤트는 마지막 BrowserWindow 인스턴스가 닫힌 직후 정확히 발생합니다. app 모듈의 quit() 함수는 앱을 종료합니다.\n\n```js\napp.on('window-all-closed', () =\u003e {\n   if (process.platform !== 'darwin') {\n      app.quit()\n   }\n})\n```\n\n그러나 macOS(darwin)에서는 사용자가 명시적으로 종료할 때까지 앱이 dock에서 활성 상태로 남아있는 것이 일반적이므로, 우리는 dock에서 앱을 계속 활성 상태로 유지할 수 있습니다.\n\n# 원격 모듈\n\n\n\n리모트 모듈은 랜더러 프로세스가 일반적으로 주 프로세스에서만 사용할 수 있는 API에 액세스할 수 있도록 합니다. 랜더러 프로세스에서 이러한 API에 액세스하려면 리모트 모듈이 주 프로세스와 통신하기 위해 내부 IPC 채널을 사용합니다. 이 글에서는 나중에 IPC에 대해 자세히 다룰 것입니다. 리모트 모듈을 사용하면 인터프로세스 메시지를 명시적으로 보내지 않고도 GUI 모듈에 액세스할 수 있습니다.\n\n중요한 점은 랜더러 프로세스에서 GUI 모듈에 액세스할 수 있지만, 종종 모듈이 랜더러 프로세스에서 생성된 것으로 오해되는 경우가 있습니다. 실제로는 객체가 주 프로세스에서 생성되고 랜더러 프로세스와 원격으로 공유됩니다.\n\n```js\nimport React from 'react';\n// React 컴포넌트에서 리모트 모듈을 가져오는 방법은?\nconst electron = window.require('electron');\nconst remote = electron.remote\nconst {BrowserWindow, dialog, Menu} = remote\n```\n\n`enableRemoteModule` 옵션을 `true`로 설정하여 리모트 모듈을 활성화하세요.\n\n\n\n# BrowserWindow\n\n브라우저 창( BrowserWindow)이 무엇인지 그리고 어떤 일을 하는지 이미 살펴보았습니다. 이제 BrowserWindow의 속성을 살펴보겠습니다.\n\n## BrowserWindow를 어떻게 생성할까요?\n\n아래 줄은 빈 BrowserWindow를 생성합니다.\n\n\n\n```js\n// 너비와 높이는 기본값으로 800 x 600으로 설정됩니다\nconst window = new BrowserWindow()\n```\n\nloadURL() 함수를 사용하여 URL에서 HTML 파일을 로드하는 방법을 살펴보았습니다. 그러나 제품 환경에서는 가장 필요한 파일/모듈을 번들로 묶습니다. loadFile() 함수는 자산에서 HTML 파일을 로드하는 데 도움이 됩니다.\n\n다음은 실제 모습입니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*T1mZlyoO9B51rPlDSdf1kQ.gif\" /\u003e\n\n\n\n\n## 창 크기 설정\n\n`BrowserWindow API`는 BrowserWindow의 크기를 설정하는 속성을 제공합니다.\n\n```js\nfunction createWindow () {\nconst windowOne = new BrowserWindow({width:400,height:400})\n}\n```\n\n위 예시는 400x400 크기의 BrowserWindow을 만듭니다. 그러나 이 크기는 끝없이 늘어나는 현상을 초래할 수 있어 예상치 못한 동작을 일으킬 수 있습니다.\n\n\n\n마지막에 표시된 img 요소를 Markdown 형식으로 바꿔주시면 다음과 같이 됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*KtAHl31wk38Tf89ksEFdrA.gif)\n\n\n\n## 사용자 정의 제목\n\n아래에 표시된 것처럼 명시적으로 정의되지 않은 경우, BrowserWindow의 제목은 package.json 파일에 정의된 앱 이름과 동일합니다. 또는 HTML 파일에서 정의된 제목이 있으면 해당 제목이 제목으로 사용됩니다.\n\n```js\nfunction createWindow () {\n const windowOne = new BrowserWindow({\n           title:\"My First App\"\n })\n}\n```\n\n## 프레임 없는 BrowserWindow을 생성하는 방법?\n\n\n\n`frame` 속성을 `false`로 설정하면 BrowserWindow이 메뉴, 툴바, 닫기 및 최소화 버튼과 같은 네이티브 창의 일부를 제거합니다.\n\n```js\nfunction createWindow () {\n const windowOne = new BrowserWindow({\n           title:\"My First App\",\n           frame:false\n })\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_4.png\" /\u003e\n\n## 부모 및 자식 창 생성\n\n\n\n부모 속성이 BrowserWindow에 정의된 경우 해당 BrowserWindow은 부모 창으로 할당된 BrowserWindow의 자식 창이 됩니다.\n\n```js\nfunction createWindow () {\n  let heyparent = new BrowserWindow()\n  let heychild = new BrowserWindow({ parent: heyparent })\n  heychild.show()\n  heyparent.show()\n}\n```\n\n자식 창은 항상 부모 창 위에 유지됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*snqCjVLVAygSiP-B3qr0uQ.gif)\n\n\n\n## 모달 창\n\n부모 창이 자식 창이 나타날 때 비활성화되도록 하는 방법은 무엇인가요? 바로 모달 창이 하는 역할입니다. 모달 창을 만들려면 부모와 모달 속성을 모두 설정해야 합니다.\n\n```js\nconst parent = new BrowserWindow()\nconst child = new BrowserWindow({ parent: top, modal: true})\nchild.loadURL('https://github.com')\n```\n\n위 방법으로 모달 창을 성공적으로 만들지만, 일부 브라우저에서는 약간의 지연이 발생할 수 있습니다. 그래서 권장하는 방법은 show 속성을 false로 설정하는 것입니다.\n\n\n\n이제 자식 창이 렌더링되자마자 show 함수를 실행하여 표시하십시오. 그러나 페이지가 렌더링을 완료했을 때 어떻게 감지할까요?\n\n웹페이지가 렌더링된 즉시 ready-to-show 이벤트가 발생합니다.\n\nready-to-show 이벤트가 발생하면 지연 없이 show() 함수를 사용하여 웹페이지를 표시할 수 있습니다.\n\n```js\nconst parent = new BrowserWindow()\n// 권장됨\nconst child = new BrowserWindow({ \n    parent: parent,\n    modal: true, \n    show: false\n })\nchild.loadURL('https://github.com')\n// 파일이 렌더링된 즉시 표시\nchild.once('ready-to-show', () =\u003e {   child.show() })\n```\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Gv3oYJmHGXrzP1_cnH4JKQ.gif\" /\u003e\n\n## 메뉴바를 제거하거나 숨기는 방법은?\n\nremoveMenu() 함수를 호출하거나 setMenu() 함수를 사용하여 Menu를 null로 설정하십시오.\n\n다음은 메뉴 바가 제거된 BrowserWindow의 모습입니다.\n\n\n\n\n![이미지](/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_5.png)\n\n## React 컴포넌트에서 BrowserWindow 열기\n\n해당 컴포넌트에는 클릭 시 BrowserWindow를 열어주는 버튼이 있습니다.\n\n다음은 그 모습입니다.\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*rtOf3JpMRYHlptZCN7g4bg.gif)\n\n# Electron에서 React 컴포넌트에서 대화 상자를 열려면?\n\n세 가지 주요 다이얼로그에 대해 설명합니다. React 컴포넌트에서 각각의 버튼 클릭으로 각각을 트리거할 것입니다.\n\n## showErrorBox()\n\n\n\n다이얼로그를 표시하는 함수입니다. 두 개의 매개변수, 타이틀 (문자열)과 내용 (문자열)을 사용합니다. 시작 시 에러를 보고하는 데 사용됩니다. 따라서 준비 이벤트 이전에 안전하게 사용할 수 있습니다.\n\n```js\nimport React from 'react';\nconst electron = window.require('electron');\nconst remote = electron.remote\nconst {dialog} = remote\nconst App = () =\u003e{\nreturn(\n  \u003cbutton onClick={()=\u003e{\n   dialog.showErrorBox('Error Box','Fatal Error')\n  }\u003eShow Error Box\u003c/button\u003e\n )\n}\nexport default App\n```\n\n작동 확인해보세요\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*ntV47YaW4i6exyZ8pTOakg.gif)\n\n\n\n## showOpenDialog()\n\n`showOpenDialog()` 함수는 파일 선택기 또는 디렉터리 선택기 역할을 합니다. properties 배열을 설정하여 대화상자의 동작을 정의할 수 있습니다. 이 함수는 다음과 같은 속성을 갖는 객체를 반환하는 Promise를 반환합니다:\n\n- cancelled : Boolean — 대화상자가 취소되었는지 여부를 나타냅니다.\n- filePaths: Array — 선택된 파일 경로의 배열입니다.\n\n\n| Title | Message | Filters |\n| --- | --- | --- |\n| 'Title' | 'Message' | Images: jpg, png, gif |\n| | | Movies: mkv, avi, mp4 |\n| | | Custom File Type: as |\n| | | All Files: * |\n\n이렇게 생겼어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*3qDlBC3KOU27v_sv-vaPdg.gif)\n\n\n\n\n## showMessageBox()\n\n지정된 유형에 따라 다른 종류의 대화 상자를 표시합니다. 이 대화 상자 함수는 또한 버튼, 체크박스 등을 사용합니다. 대화 상자가 닫힐 때까지 프로세스를 차단합니다. 이 함수는 다음 속성을 포함하는 객체로 해결되는 Promise를 반환합니다:\n\nresponse: 클릭된 버튼의 인덱스\n\ncheckboxChecked: 부울값 — 체크박스가 선택되었는지 여부\n\n\n\n아래는 가장 많이 사용되는 매개변수와 함께 다양한 유형의 메시지 상자를 보여주는 데모입니다.\n\n이렇게 보입니다.\n\n![Message Boxes](https://miro.medium.com/v2/resize:fit:1400/1*5kfsVcdtp854xZJmIMc2dw.gif)\n\n# Electron에서 사용자 정의 메뉴를 만드는 방법\n\n\n\n\n일반적으로는 메뉴를 준비 이벤트에서 설정하는 것이 가장 좋습니다. 그러나 먼저 버튼 클릭에서 리액트 컴포넌트를 통해 설정해 봅시다.\n\n## buildFromTemplate\n\nbuildFromTemplate 함수는 옵션(템플릿) 배열을 가져와 Menu 인스턴스를 반환합니다. 각 옵션은 다음과 같은 매개변수를 가진 객체입니다: label: string, click: function, type: string, submenu: array(options) 및 role: name-of-a-role.\n\n```js\n// option:object\n{\n    label: 'options',\n    submenu: [\n        { role: 'selectall' },\n        { role: 'reload' }\n    ]\n}\n```\n\n\n\n## setApplicationMenu\n\n매개변수로 Menu 인스턴스를 가져와 각 창의 상위 메뉴로 설정합니다.\n\n실제 동작을 확인해보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*XNDUagIYg7RZrIWvG1njyQ.gif)\n\n\n\n### 역할, 구분자 및 하위 메뉴 속성이 있는 메뉴\n\n다음 예제에서는 구분자, 하위 메뉴 및 역할이 있는 메뉴를 살펴볼 것입니다.\n\n다음과 같이 보입니다.\n\n![menu](https://miro.medium.com/v2/resize:fit:1400/1*JOHdFj-znvZA7ZirWNTJpg.gif)\n\n\n\n# 일렉트론과 리액트에서 라우터 구현하는 방법\n\n## 왜 BrowserRouter를 사용하지 않는가?\n\n일반적으로 리액트 앱에서는 라우터를 BrowserRouter 컴포넌트로 감싸서 사용합니다. BrowserRouter 컴포넌트는 요청 기반 환경에 가장 적합한 라우팅 메커니즘을 구현합니다. 다음은 리액트 앱에서 라우팅을 보여주는 간단한 예제입니다.\n\nBrowserRouter 컴포넌트는 요청 기반 프레임워크인 리액트와 잘 작동하지만, 일렉트론과 같은 파일 기반 환경에서는 전혀 작동하지 않을 수 있습니다. 그러나 react-router-dom 패키지는 모든 라우팅 케이스를 처리하기 위해 제공됩니다.\n\n\n\n## 해시 라우터가 도와줍니다!\n\n리액트 라우터 돔 패키지에는 브라우저 라우터처럼 파일 기반 환경에서 작동하는 해시 라우터 컴포넌트가 포함되어 있습니다.\n\n해시 라우터 컴포넌트를 사용한 루트는 브라우저 라우터와 같은 방식으로 설정할 수 있습니다. 브라우저 라우터를 기반으로 한 구현에서 변경해야 할 것은 브라우저 라우터 컴포넌트를 해시 라우터 컴포넌트로 바꾸는 것뿐입니다. 여기에는 일렉트론에서 작동하도록 수정된 브라우저 라우터 기반 라우트가 있습니다.\n\n실제로 어떻게 동작하는지 확인해 보겠습니다.\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Gjv4nMUXuBiBEONKC9kXog.gif\" /\u003e\n\n좋아요! 지금까지 BrowserWindows를 생성/수정하는 방법과 페이지를 실행하여 특정 용도에 맞는 OS별 대화 상자를 트리거하고, HashRouter를 사용하여 라우트를 설정하고, main 프로세스에서만 액세스할 수 있는 렌더러 프로세스의 모듈에 액세스하는 방법에 대해 배웠어요. 이제 약간 더 깊게 파고들어 Electron 프레임워크의 핵심인 IPC를 이해해봐요!\n\n# 프로세스 간 통신(IPC)\n\n우리는 메인 프로세스와 렌더러 프로세스에 대해 배웠어요.\n\n\n\n일렉트론은 메인 프로세스가 BrowserWindows를 생성/처리해야 하며, 각 창은 자체 랜더러 프로세스를 운영하여 웹페이지를 실행합니다. 그래서 랜더러 프로세스가 네이티브 API를 활용해 GUI를 변경해야 할 경우, 일렉트론에서 필요한 네이티브 모듈을 직접 가져와 필요한대로 호출할 수 있을 것 같지만, 그렇지 않습니다!\n\n랜더러 프로세스는 서드파티 라이브러리/웹페이지를 실행하기 때문에, 네이티브 GUI API를 호출하는 것은 치명적인 오류가 될 수 있으며 데이터 누출로 이어질 수 있습니다.\n\n웹페이지에서 GUI 작업을 수행해야 하는 경우, 랜더러 프로세스는 메인 프로세스와 통신해야 하며 메인 프로세스는 네이티브 작업 요청이 유효한지 확인한 후에만 처리해야 합니다.\n\n메인 프로세스와 랜더러 프로세스 간의 통신은 요구 사항에 따라 동기적이거나 비동기적일 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_6.png)\n\n렌더러 프로세스는 특정 채널로 메인 프로세스에 요청을 보내서 일부 인수와 함께 네이티브 작업을 실행하도록 요청하고, 메인 프로세스는 웹페이지에서 해당 인수와 함께 네이티브 API에서 작업을 비동기적으로 실행하여 요청을 수행합니다.\n\n## on() 및 once()\n\nipcMain과 ipcRenderer 모듈 모두 특정 채널에서 이벤트를 수신하기 위해 'on' 및 'once' 메소드를 가지고 있습니다.\n\n\n\n```js\n// channel: 문자열 및 이벤트 및 인수를 함수 매개변수로 사용하는 콜백(listener)\n// main 프로세스\nipcMain.on(channel, listener)\nipcMain.once(channel, listener)\n// renderer 프로세스\nipcRenderer.on(channel, listener) \nipcRenderer.once(channel, listener)\n```\n\n특정 채널로 새 메시지가 도착하면 콜백(listener)이 전달된 매개변수와 함께 실행됩니다.\n\n'once' 함수도 동일한 방식으로 작동하지만, 한 번 이벤트를 청취한 후에는 제거됩니다.\n\n## send()\n\n\n\n\nipcRenderer 모듈에는 지정된 채널로 메시지를 보내는 'send' 메서드가 있습니다.\n\n```js\n// channel:string(채널 이름),\n// 채널을 통해 보낼 args\n// 주 프로세스로.\nipcRenderer.send(channel, ...args)\n```\n\n## removeListener() 및 removeAllListeners()\n\n주 프로세스에서 여러 렌더러 프로세스가 동일한 채널을 구독하는 상황이 있는데, 성능을 높이기 위해 한 번에 하나 이상의 청취자를 제거하고 싶을 수 있습니다. ipcMain 모듈에는 지정된 청취자를 제거하는 removeListener 및 채널에서 모든 청취자를 제거하는 removeAllListeners 메서드가 포함되어 있습니다.\n\n\n\n```js\n// 특정 채널에서 특정 청취자를 제거합니다\nremoveListener(channel, listener)\n// 채널에서 모든 청취자를 제거합니다\nremoveAllListeners([channel])\n```\n\n## 비동기적 메시지 교환\n\n렌더러 프로세스에서 네이티브 API를 호출하려면 주로 메인 프로세스에 IPC 호출을 수행해야 합니다. 렌더러 프로세스에서는 네이티브 API에 직접 액세스할 수 없기 때문입니다. 그런데 요청된 네이티브 작업이 무거운 작업이라면 어떨까요? 그렇다면 IPC 호출이 무거운 네이티브 작업의 실행이 완료될 때까지 UI를 차단하게 될 것입니다. 이를 해결하기 위해 비차단적인 비동기 전송 함수가 있습니다.\n\n메인 프로세스는 요청을 수행한 후 일부 메타데이터와 함께 비동기적으로 응답을 보낼 수도 있습니다.\n\n\n\n## 동기 메시지 교환\n\n일부 사용자 활동이 UI에 즉각적인 변경을 필요로 할 수있는 상황이 발생할 수 있습니다. UI에서의 모든 이러한 긴급 트리거에 대해 동기 방식의 교환을 사용할 수 있습니다.\n\nipcRenderer 모듈에는 'sendSync' 함수가 함께 제공되며 'send' 함수와 완전히 동일하게 작동하지만 동기적으로 작동합니다. 이는 동기적으로 보낸 모든 요청이 리소스 활용 면에서 가볍게 유지되어야 한다는 것을 의미하기도 합니다. 그렇지 않으면 UI가 원활하게 렌더링되는 것을 방해할 수 있습니다.\n\n지금까지 학습한 내용을 React에서 구현해 보겠습니다.\n\n\n\n# 리액트 컴포넌트에서 IPC를 확인해 봅시다\n\n리액트 컴포넌트에서 버튼을 클릭하여 주 프로세스에 메시지를 동기적 및 비동기적으로 보낼 것입니다.\n\nApp 컴포넌트에 두 개의 버튼을 생성해봅시다. 하나는 동기적으로 다른 하나는 비동기적으로 주 프로세스에 문자열을 보내기 위한 것입니다.\n\n## App.js\n\n\n\nmain.js 파일에서 ‘anything-synchronous’ 및 ‘anything-asynchronous’ 채널에서 보낸 메시지를 수신하기 위한 ‘on’ 함수를 생성하세요.\n\n## main.js\n\n다음은 예시입니다.\n\n![예시](https://miro.medium.com/v2/resize:fit:1400/1*zWv0lrOCxMyjfEqsPQRPKw.gif)\n\n\n\n## 메인 프로세스에서(Renderer 프로세스(앱 컴포넌트)에 동기적 및 비동기적으로 응답을 보내 봅시다.\n\n## 비동기적 응답\n\n비동기적 메시지에 대한 응답을 보내려면 'event.reply' 메서드를 사용합니다.\n\n비동기적 응답은 메타데이터가 원시 요청을 하는 메인 채널을 막지 않도록 다른 채널로 보내집니다.\n\n\n\nmain.js\n\nApp.js\n\n주된 프로세스에 의해 다른 채널로 응답이 전송되므로, 랜더러 프로세스는 응답을 수락하기 위해 이를 수신 대기해야 합니다.\n\n'arg' 매개변수로 전달된 응답을 캐치할 리스너(callback)와 함께 'on' 메서드가 사용됩니다.\n\n\n\n## 동기 응답\n\n동기적으로 응답을 보내려면 응답으로 전달 될 데이터를 'event.returnValue'로 설정하십시오.\n\nmain.js\n\nApp.js\n\n\n\n렌더러 프로세스인 App 컴포넌트에서 이를 잡는 방법은 다음과 같습니다.\n\n다음과 같이 보일 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*L33_yu2Npjsi0yEDuiO9Fw.gif)\n\n왼쪽에는 App 컴포넌트를 실행하는 렌더러 프로세스가 있고, 오른쪽에는 메인 프로세스가 있습니다. 브라우저 콘솔에서는 렌더러 프로세스가 보낸 비동기 및 동기 메시지에 대한 메인 프로세스의 응답 메시지를 볼 수 있습니다.\n\n\n\n## 놀라운 소식! 좋은 소식이 있어요!\n\n마이크로소프트는 빠른 WASM(WebAssembly)을 활용한 .NET 기반 크로스 플랫폼 응용프로그램 개발 프레임워크 BLAZOR를 Electron에 구현하려고 노력하고 있습니다. 이는 코드 베이스를 거의 변경하지 않고 Electron으로 만들어진 앱들을 대규모로 성능을 향상시킬 것입니다.\n\n시간 내어 주셔서 정말 감사합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*rHuMSNiP_9-VY9MwDXrzuA.gif)\n\n\n\n미래에 대한 모든 좋은 일들이 가득하길 바래요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*UX3p7WMPuQWnhcSw9EeVfQ.gif)","ogImage":{"url":"/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_0.png"},"coverImage":"/assets/img/2024-05-12-TheUltimateGuidetoElectronwithReact_0.png","tag":["Tech"],"readingTime":15}],"page":"138","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"138"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>