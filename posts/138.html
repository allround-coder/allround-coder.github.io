<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기" href="/post/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트  Props들어오는 값와 State내부값의 명명 규칙" href="/post/2024-05-12-ReactNamingConventionforPropsinoutandState"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트  Props들어오는 값와 State내부값의 명명 규칙" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트  Props들어오는 값와 State내부값의 명명 규칙" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트  Props들어오는 값와 State내부값의 명명 규칙</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법" href="/post/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="useCallback 훅 사용 방법" href="/post/2024-05-12-HowtouseuseCallbackhook"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="useCallback 훅 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="useCallback 훅 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">useCallback 훅 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대규모 확장을 위해 React Native 앱에서 디자인 시스템 활용하기 제3부" href="/post/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대규모 확장을 위해 React Native 앱에서 디자인 시스템 활용하기 제3부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대규모 확장을 위해 React Native 앱에서 디자인 시스템 활용하기 제3부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대규모 확장을 위해 React Native 앱에서 디자인 시스템 활용하기 제3부</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="윈도우에서 WSL2 및 도커 성능을 20배 높이세요" href="/post/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="윈도우에서 WSL2 및 도커 성능을 20배 높이세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="윈도우에서 WSL2 및 도커 성능을 20배 높이세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">윈도우에서 WSL2 및 도커 성능을 20배 높이세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 " href="/post/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 </strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용" href="/post/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부" href="/post/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서의 인증과 권한 부여 방법" href="/post/2024-05-12-AuthenticationandAuthorizationinreact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서의 인증과 권한 부여 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서의 인증과 권한 부여 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서의 인증과 권한 부여 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link posts_-active__YVJEi" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트JS를 사용하여 Amazon S3로 파일을 업로드하기 위한 사전 서명 된 URL 사용하기","description":"","date":"2024-05-12 20:26","slug":"2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS","content":"\n\n## 아마존 S3와 웹 애플리케이션을 연결하는 초보자 가이드\n\n파일을 아마존 S3에 업로드하는 것은 상대적으로 간단하고 흔한 작업일 줄 알았습니다. 버킷을 설정하고 자격 증명을 사용하여 요청을 보내기만 하면 되는 것 아닐까요? 그렇게 복잡할 수 없겠죠?\n\n유튜브, 스택 오버플로우, 그리고 AWS 자체 문서와 블로그에서 사용할 수 있는 다양한 리소스들이 있습니다 (리소스의 전체 목록은 아래에서 찾아볼 수 있습니다). 그러나 저 (그리고 아마 여러분도) 곧 깨닫게 될 것은, 특히 부주의한 실수를 범하기 쉬운 초보자라면 생각했던 것보다 간단하지 않다는 것입니다.\n\n본래 제 목표는 (이미지, 비디오 등등) 파일을 웹 애플리케이션을 통해 업로드하고 버튼을 클릭하면 S3 버킷에 업로드되도록 하는 것이었습니다. 이를 위해 제가 찾은 방법은 웹 애플리케이션과 AWS 백엔드 사이에서 요청을 보내기 위해 사전 서명된 URL을 사용하는 것입니다. 이런식으로 동작합니다:\n\n\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png)\n\n요약하면 이렇게 해야 합니다: 이 실제 작동 방식에 대한 더 자세한 내용은 하단의 자료에서 링크된 블로그 포스트를 확인하는 것을 추천합니다. 그러나 이 게시물에서는 가능한 단순한 용어로 설정하는 프로세스를 주로 살펴보려고 할 것이기 때문에 더 이해하기 쉽도록 노력하겠습니다. 준비되셨나요? 🙂 \n\n상상할 수 있겠지만, 설정해야 할 4가지 주요 구성 요소가 있습니다: Amazon S3, AWS Lambda, Amazon API Gateway, 그리고 물론 응용 프로그램 프론트엔드입니다. 이번에 우리가 따라갈 단계를 아래에서 요약해 보겠습니다:\n\n\n\n- Amazon S3 설정하기\n1.1 S3 버킷 생성\n1.2 S3 버킷에 CORS 활성화하기\n\n- AWS Lambda 설정하기\n2.1 AWS Lambda 함수 생성\n2.2 Lambda 함수 테스트하기\n2.3 Lambda 함수 IAM 역할에 S3 액세스 활성화하기\n\n- Amazon API GateWay 설정하기\n3.1 HTTP API 엔드포인트 생성\n3.2 Postman을 사용하여 엔드포인트 테스트하기\n\n- 업로더 컴포넌트 설정하기\n4.1 필수 라이브러리 설치하기\n4.2 API GateWay로 요청을 하는 함수 설정하기\n\n이 방법으로 간단한 작업을 수행하기 위해 배포 단계에서 많은 구성이 진행되며, 때로는 AWS의 오류 메시지가 모호하여 문제가 발생한 구체적인 위치를 파악하기 어려울 수 있습니다. (위의 비디오에 좋은 예시가 있음).\n\n# 단계 1: Amazon S3 설정하기\n\n## 단계 1.1: S3 버킷 생성하기\n\n\n\n먼저, 아직 S3 버킷이 없다면 만드세요. 설명적인 이름을 지정하고 보안상의 이유로 \"모든 공개 액세스 차단\"란에 체크하세요 (물론 공개 액세스를 허용하고 싶다면 그렇게 하셔도 됩니다).\n\n\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_1.png\" /\u003e\n\n## 단계 1.2: S3 버킷에 CORS 활성화하기\n\n다음으로, 방금 생성한 버킷을 클릭하고 \"Permissions(권한)\" 탭으로 이동하세요.\n\n\n\n`\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_2.png\" /\u003e`\n\n바닥으로 스크롤을 내려 CORS 섹션을 찾아 \"편집\"을 클릭하세요.\n\n`\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_3.png\" /\u003e`\n\n그리고 아래 JSON을 붙여넣으세요:\n\n\n\n```js\n[\n    {\n        \"AllowedHeaders\": [\n            \"*\"\n        ],\n        \"AllowedMethods\": [\n            \"PUT\",\n            \"GET\"\n        ],\n        \"AllowedOrigins\": [\n            \"*\"\n        ],\n        \"ExposeHeaders\": []\n    }\n]\n```\n\n작업을 마치면 외부 출처(예: React 애플리케이션)에 S3 버킷으로의 \"PUT\" 및 \"GET\" 요청을 허용할 수 있게 될 것입니다.\n\n# 단계 2: AWS Lambda 설정\n\nAWS Lambda는 서버리스 컴퓨트 서비스로, 어떤 종류의 응용 프로그램이나 백엔드 서비스에도 코드를 실행할 수 있도록 해주며 어떠한 관리도 필요하지 않습니다. 여기에서는 이전에 만든 S3 버킷에서 사전 서명된 URL을 얻는 데 AWS Lambda를 사용할 것입니다.\n\n\n\n## 단계 2.1: AWS 람다 함수 생성하기\n\n기본 설정을 사용하여 함수에 설명적인 이름을 지정하고 함수를 만듭니다:\n\n![lambda-function](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_4.png)\n\n함수가 생성되면 \"코드\" 탭으로 이동하여 \"index.js\" 파일을 엽니다.\n\n\n\n위의 템플릿 코드를 다음으로 대체해주세요:\n\n기본적으로 여기서 일어나는 것은 람다 함수가 S3 버킷에서 사전 서명된 URL을 요청하는 것입니다. 9번째 줄은 진입점이며, getUploadURL 함수(12번부터 정의됨)가 호출됩니다. 반환된 결과는 다음을 포함하는 JSON 객체입니다:\n\n- 실제 파일을 업로드하는 데 사용할 \"uploadURL\"\n- 파일 업로드 시 S3에 표시될 \"filename\" (파일이 성공적으로 업로드되면 표시되는 파일 이름)\n\n주의하세요! 필요에 맞게 변경하고 싶을 수 있는 3줄이 있습니다:\n\n\n\n- 4번 줄: 여기에 실제 버킷 이름을 사용하세요\n- 14번 줄: 업로드된 파일 이름을 사용자 정의하고 싶다면\n- 21번 줄: ContentType을 업로드할 파일과 일치하도록 변경하세요\n\n## 단계 2.2: Lambda 함수 테스트하기\n\n이제 Lambda에서 함수를 테스트할 준비가 되었습니다. 그러나 \"테스트\"를 클릭하기 전에 변경 사항을 배포했는지 확인하세요!\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_5.png)\n\n\n\n\"Test\"을 클릭하면 테스트에 이름을 지어서 만들어보세요.\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_6.png)\n\n실제로 함수를 테스트하면 실행 결과로 이와 같은 출력이 나올 것입니다:\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_7.png)\n\n\n\n응당이 JSON 본문을 포함하고 있어서 uploadURL과 filename이 나옵니다.\n\n## 단계 2.3: 람다 기능 IAM 역할에 대한 S3 액세스 활성화\n\n아마도 다음 단계는 덜 직관적일 수 있습니다. 이곳에서 우리는 람다 함수가 S3 버킷과 통신할 수 있도록 권한을 부여해야 합니다.\n\n\"구성\"으로 이동하여 \"실행 역할\" 아래의 IAM 역할 이름을 클릭하십시오. IAM은 Identity Access Management의 약자로, AWS가 각 도구나 서비스가 갖는 권한을 관리하는 데 사용됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_8.png\" /\u003e\n\n현재 IAM 역할을 검토하면 람다 함수를 실행하는 권한만 있고 S3에 대한 권한이 없는 것을 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_9.png\" /\u003e\n\n권한을 부여하려면 \"정책 연결\"을 클릭하고 검색 창에 \"S3\"를 입력한 다음 \"S3FullAccess\"를 선택한 후 \"정책 연결\"을 클릭하세요.\n\n\n\n이제 S3 버킷에 파일 개체를 넣을 수 있게 되었어요!\n\n참고: 더 나은 보안 관행을 위해 실제로는 Lambda 함수에 대해 S3 버킷과 관련된 객체를 가져오고 넣는 권한만 부여해야 합니다. 또한 해당 S3 버킷에 대해만 권한이 적용될 수 있도록 권한을 제한해야 합니다. 이 작업을 실제로 어떻게 수행하는지 확인하려면 AWS의 리소스 섹션에서 제공하는 비디오 자습서를 참조하세요.\n\n# 단계 3: Amazon API Gateway 설정\n\n좋아요, 그래서 AWS에서 Lambda 함수를 테스트했는데, 어떻게 웹 애플리케이션에서 동일한 Lambda 함수를 실행할 수 있을까요? 그렇게 하려면 호출할 수 있는 API 엔드포인트를 설정해야 합니다. 다행히도, AWS는 이를 우리에게 Amazon API Gateway를 통해 제공해줍니다.\n\n\n\n## 단계 3.1 HTTP API 엔드포인트 생성\n\nLambda 함수로 이동하여 \"추가 트리거\"를 클릭하여 Lambda 함수가 실행되도록 트리거할 HTTP 엔드포인트를 생성합니다.\n\n![Lambda function trigger](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_10.png)\n\n보안을 \"열림\"으로 설정하고 CORS를 활성화합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_11.png\" /\u003e\n\n트리거를 추가하면 \"Triggers\" 섹션에서 엔드포인트를 가져올 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_12.png\" /\u003e\n\n## 단계 3.2. Postman을 사용하여 엔드포인트를 테스트합니다\n\n\n\n지금까지 모든 것을 올바르게 설정했는지 확인하기 위해 Postman을 사용하여이 엔드포인트를 테스트할 수 있습니다. 엔드포인트를 복사하고 다음과 같이 GET 요청을 만들어보세요:\n\n[마크다운 링크](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_13.png)\n\n다음으로 uploadURL 값을 복사하고 다른 요청을 만들어보세요. 이번에는 메소드를 \"PUT\"로 변경하고 테스트를 위해 샘플 .jpeg 이미지를 업로드하세요. 이미지를 업로드하려면 'Body' 탭을 선택하고 파일 시스템에서 파일을 선택할 수 있게 해주는 'binary' 옵션을 선택하세요. 모두 준비가 되었으면 \"Send\"를 클릭하세요. 반응에 오류 메시지가 표시되지 않는다면, 그것은 좋은 신호입니다!\n\n\n[마크다운 링크](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_14.png)\n\n\n\n이제 S3 버킷을 확인해 보세요. 무작위로 생성된 파일 이름을 가진 파일이 업로드된 것을 확인할 수 있어요:\n\n![Uploaded File](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_15.png)\n\n# 단계 4: 업로더 컴포넌트 설정\n\n이제 거의 끝났어요! 프론트엔드 부분에서는 업로더 컴포넌트가 어떻게 보이길 원하는지는 자유롭게 결정할 수 있어요. 이 예시에서는 react-dropzone-uploader 패키지를 사용했지만, 여러분이 원하는 대로 사용할 수 있어요. 먼저 axios와 필요한 다른 패키지를 설치하세요. (이 경우, 나는 react-dropzone-uploader를 사용했어요)\n\n\n\n## 단계 4.1: 필수 패키지 설치\n\n```js\nnpm install axios react-dropzone-uploader\n```\n\n## 단계 4.2 API Gateway에 요청을 보내는 함수 설정\n\n웹 애플리케이션 코드에서 axios가 필요하며(API_GATEWAY_SECRET 엔드포인트 URL)를 API 엔드포인트 URL로 교체합니다.\n\n\n\n30번 라인에서 파일을 제출할 수 있게 해주는 Dropzone 컴포넌트가 있어요 (원하시면 마음에 드는 컴포넌트로 디자인해도 괜찮아요).\n\n이제 우리는 handleSubmit 함수(Line 13)를 사용하여 Postman에서 했던 두 단계 과정을 거의 똑같이 따를 거에요. 먼저 API 엔드포인트로 \"GET\" 요청을 보내고, 그런 다음 응답으로 반환된 사전 서명된 uploadURL로 \"PUT\" 요청을 보내면 돼요.\n\n그리고 이제 마침내 끝났어요! 이 예제에서 .jpeg 이미지 파일을 앱에 제출하면 Amazon S3로 업로드되는 것을 확인할 수 있을 걸요 👍\n\n# 마무리\n\n\n\n간단히 말해, AWS를 구성하는 것은 어렵고 지루해 보일 수 있지만, 이 기사가 여러분께 사전 서명된 URL을 사용하여 Amazon S3로 파일을 업로드하는 프로세스를 더 잘 이해할 수 있게 도움이 되기를 바랍니다. 도움이 되었다면 좋아요와 공유도 부탁드리며, 더 나은 방법이나 궁금한 점이 있으면 언제든지 연락해 주세요! 💪\n\n## 자료\n\n- AWS 블로그 글: [https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/](https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/)\n- AWS 유튜브 튜토리얼: [https://www.youtube.com/watch?v=mw_-0iCVpUc\u0026ab_channel=AmazonWebServices](https://www.youtube.com/watch?v=mw_-0iCVpUc\u0026ab_channel=AmazonWebServices)\n- AWS GitHub 저장소: [https://github.com/aws-samples/amazon-s3-presigned-urls-aws-sam](https://github.com/aws-samples/amazon-s3-presigned-urls-aws-sam)\n- 내 GitHub 저장소: [https://github.com/AllardQuek/react-demo](https://github.com/AllardQuek/react-demo)\n- CORS: [https://www.youtube.com/watch?v=4KHiSt0oLJ0](https://www.youtube.com/watch?v=4KHiSt0oLJ0)\n\n![이미지](/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_16.png)","ogImage":{"url":"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-UsingPre-SignedURLstoUploadFilestoAmazonS3FromReactJS_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트  Props들어오는 값와 State내부값의 명명 규칙","description":"","date":"2024-05-12 20:24","slug":"2024-05-12-ReactNamingConventionforPropsinoutandState","content":"\n\n프로그래밍에서 가장 어려운 일 중 하나가 이름 짓기라고 자주 들어봤을 거예요.\n\n대부분의 경우, 우리는 컴포넌트의 프로퍼티와 상태 변수를 어떻게 명명할지에 대해 많은 생각을 하게 됩니다.\n\n이 자료에서는 React를 사용할 때 내가 사용하는 명명 규칙을 공유하고, 여러분이 프로퍼티와 상태를 어떻게 명명할지 쉽게 결정할 수 있도록 도와드릴 거예요.\n\n# ☯️ 프로퍼티용 명명 규칙\n\n\n\n리액트 프롭(prop)을 보는 방식은 입력과 출력 두 가지로 구성되어 있다고 생각해요.\n\n그리고 이 두 가지는 서로 다른 네이밍 규약을 갖고 있어요.\n\n입력 프롭은 부모 컴포넌트에서 자식 컴포넌트로 전달되어 자식 컴포넌트의 동작을 커스터마이즈하는 데 사용돼요.\n\n![React Naming Convention for Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png)\n\n\n\n출력 props는 입력 props와 거의 동일하지만 그 주요 목적은 이벤트 핸들러로 알려진 것과 같이 자식 컴포넌트가 부모와 통신할 수 있도록 하는 것입니다.\n\n![React-Naming-Convention-for-Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_1.png)\n\n이제 입력 및 출력 props 간의 차이를 이해했으므로 네이밍 규칙으로 넘어가 봅시다.\n\n## 입력 props의 네이밍 규칙\n\n\n\n입력 프롭스에 대해 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 프롭스가 부울형인 경우 접두사로 is 또는 has를 사용하고 그 뒤에 프롭스의 이름을 붙입니다. 예를 들어: isDisabled, hasError, isActive, isOpen.\n\n- 프롭스가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우 그것을 값으로 명명합니다. 문자열, 숫자, 배열 또는 객체인지에 상관없이 모두 value로 명명합니다. 네이티브 HTML 요소 속성과 유사합니다. 예를 들어: value, defaultValue, initialValue.\n\n- 컴포넌트 내의 자식 컴포넌트의 스타일인 경우, 자식 컴포넌트의 이름 뒤에 Props를 붙입니다. 예를 들어: textProps, buttonProps, inputProps, switchProps.\n\n\n\n- 만약 prop이 ref prop이라면, 접미사 Ref 뒤에 ref의 이름을 사용합니다. 예를 들어, inputRef, buttonRef, textRef와 같이 사용합니다.\n\n## 출력 Props에 대한 네이밍 규칙\n\n출력 Props의 경우, 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 만약 prop이 렌더 prop이라면, 접두사 render를 사용하고 prop의 이름을 뒤에 붙입니다. 예를 들어, renderItem, renderHeader, renderFooter와 같이 사용합니다.\n\n\n\n- 만약 prop이 이벤트 핸들러인 경우에는 해당 이벤트의 이름 뒤에 on을 붙입니다. 예를 들어, onClick, onSubmit, onClose, onOpen입니다.\n\n일부 출력 props가 이벤트 핸들러일 때에는 해당 이벤트의 이름 앞에 handleOn을 붙입니다. 예를 들어, handleOnClick, handleOnSubmit, handleOnClose, handleOnOpen입니다.\n\n만약 이벤트가 변경(change) 이벤트인 경우에는 이름 뒤에 Change를 추가합니다. 예를 들어, handleOnChange, handleOnInputChange입니다.\n\n![React props naming convention](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_2.png)\n\n\n\n# ⚙️ 상태에 대한 네이밍 규칙\n\n상태 속성은 변수의 네이밍 규칙과 거의 동일합니다.\n\n만약 변수에 대해 이미 네이밍 규칙을 가지고 있고 익숙하다면, 동일한 네이밍 규칙을 상태 변수에 적용할 수 있습니다.\n\n하지만 변수에 대해 네이밍 규칙이 없다면, 다음 네이밍 규칙을 사용할 수 있습니다:\n\n\n\n- 만약 상태가 부울(Boolean) 값인 경우, 상태의 이름에 \"is\" 또는 \"has\" 접두사를 사용합니다. 예를 들면: [isDisabled, setIsDisabled], [hasError, setHasError], [isActive, setIsActive], [isOpen, setIsOpen].\n\n- 만약 상태가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우, 값을 value로 지정합니다. 이 값이 문자열, 숫자, 배열 또는 객체든 상관없이 모두 같은 value로 표기합니다. 네이티브 HTML 입력 요소와 유사합니다. 예를 들면: [value, setValue], [defaultValue, setDefaultValue], [initialValue, setInitialValue].\n\n위의 명명 규칙 중 어떤 것이 props와 충돌한다면, 구조분해 할 때 별칭으로 설정하세요.\n\n- 만약 상태가 메모이제이션(memoized)된 값인 경우, 상태/컴포넌트의 이름 뒤에 memoized/Memoized 접두사를 사용합니다.\n\n\n\n메모이즈된 값이 컴포넌트가 아닌 경우, 접두사는 소문자로 지정됩니다. 예를 들어: memoizedValue, memoizedSum, memoizedResult.\n\n![이미지1](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_3.png)\n\n메모이즈된 값이 컴포넌트인 경우, 접두사는 대문자로 지정됩니다. 예를 들어: MemoizedButton, MemoizedText, MemoizedHeader.\n\n![이미지2](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_4.png)\n\n\n\n# 🚀 결론\n\n이름 짓기는 어렵지만 결정을 돕는 가이드가 있다면 더 쉬울 수 있어요.\n\nReact 작업 시 사용하는 이 명명 규칙은 HTML 요소 속성에서 영감을 받았습니다. 비슷한 점을 찾아야 해서 일부 명명 규칙을 재사용하는 것을 좋아해요.\n\n만약 이 중 어떤 것도 도움이 되지 않는다면, 언제든지 여러분, 여러분의 사용 사례 및 팀에 가장 적합한 명명 규칙을 만들 수 있다는 것을 염두에 두세요.\n\n\n\n하루 마무리할 때 중요한 것은 일관되게 따를 수 있는 네이밍 규칙을 가지고 있다는 것입니다.\n\n언제든지 궁금한 점이 있거나 제안할 내용이 있다면 아래에 댓글을 남겨주세요. 당신의 의견을 듣는 것을 기쁘게 생각할 거에요.\n\n읽어주셔서 감사합니다. 여러분의 여정에 도움이 되기를 바랍니다! ❤️\n\n# 간단히 표현한 것 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클립하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png"},"coverImage":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png","tag":["Tech"],"readingTime":4},{"title":"React JS를 사용하여 어떤 패키지도 사용하지 않고 호버 시 드롭다운 메뉴를 만드는 방법","description":"","date":"2024-05-12 20:22","slug":"2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage","content":"\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:796/1*AXro4l-eefcJcsCr40yw2w.gif\" /\u003e\n\nReact에서 외부 패키지를 사용하지 않고 호버 시 드롭다운 메뉴를 만들려면 다음 단계를 따를 수 있습니다:\n\n단계 1: React 프로젝트 설정\n\n아직 React 프로젝트를 설정하지 않은 경우 터미널에 아래 명령을 붙여넣어 새로운 프로젝트를 만들어야 합니다.\n\n\n\n```js\nnpx create-react-app dropdown-menu\n```\n\n단계 2: 드롭다운 컴포넌트 생성\n\n프로젝트 디렉토리 내에 DropdownMenu이라는 이름의 컴포넌트를 생성하고 아래 코드를 붙여넣으세요.\n\n```js\nimport React from \"react\";\n\nconst DropdownMenu = () =\u003e {\n  return (\n    \u003cdiv className=\"dropdown-menu\"\u003e\n      \u003cul\u003e\n        \u003cli\u003e메뉴 1\u003c/li\u003e\n        \u003cli\u003e메뉴 2\u003c/li\u003e\n        \u003cli\u003e메뉴 3\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default DropdownMenu;\n```\n\n\n\n위의 코드에서는 호버 시에 표시되는 간단한 메뉴를 생성하고 있습니다.\n\n단계 3: 드롭다운 컴포넌트 가져오고 이벤트 처리하기\n\n당신의 주요 컴포넌트(App.js 등)에서 DropdownMenu 컴포넌트를 가져오고 호버 이벤트를 처리해보세요.\n\n```js\nimport { useState } from \"react\";\nimport DropdownMenu from \"./DropdownMenu\";\nimport \"./App.css\";\n\nfunction App() {\n  const [isDropdownVisible, setDropdownVisible] = useState(false);\n\n  const handleMouseEnter = () =\u003e {\n    setDropdownVisible(true);\n  };\n\n  const handleMouseLeave = () =\u003e {\n    setDropdownVisible(false);\n  };\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cdiv\n          className=\"menu\"\n          onMouseEnter={handleMouseEnter}\n          onMouseLeave={handleMouseLeave}\n        \u003e\n          \u003cbutton\u003eDropdown Menu\u003c/button\u003e\n          {/* \u003cDropdownMenu /\u003e */}\n          {isDropdownVisible \u0026\u0026 \u003cDropdownMenu /\u003e}\n        \u003c/div\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\n\n위의 코드에서 App 컴포넌트는 사용자가 요소 위로 마우스를 올리면 true로 설정되는 상태 변수 isDropdownVisible을 관리하며, 마우스가 요소를 벗어나면 false로 설정됩니다. handleMouseEnter 및 handleMouseLeave 함수는 상태를 적절히 업데이트하는 데 사용됩니다.\n\n단계 4: 스타일 추가\n\n이제 드롭다운 컴포넌트에 일부 스타일을 추가하세요. 아래 CSS를 App.css 파일에 붙여넣기만 하면 됩니다.\n\n```js\nheader {\n  width: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\nbutton {\n  background: #000;\n  box-shadow: 0px 10px 30px 0px rgba(82, 63, 105, 0.05);\n  color: #fff;\n  padding: 12px 25px;\n  border: none;\n  cursor: pointer;\n}\n\nul {\n  list-style: none;\n  padding: unset;\n  margin: unset;\n}\n\nli {\n  padding: 14px;\n  transition: all linear 0.3s;\n}\n\nli:hover {\n  background: gray;\n  cursor: pointer;\n  color: #fff;\n}\n\n.dropdown-menu {\n  background: #fff;\n  box-shadow: 0px 10px 30px 0px rgba(82, 63, 105, 0.05);\n  transition: all linear 0.3s;\n}\n```\n\n\n\n오늘은 여기까지입니다. 아래에서 GitHub 저장소와 Codesandbox 데모를 확인하실 수 있어요.\n\n궁금한 점이 있으시면 LinkedIn을 통해 연락해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage_0.png"},"coverImage":"/assets/img/2024-05-12-HowtocreateadropdownmenuonhoverinReactJSwithoutanypackage_0.png","tag":["Tech"],"readingTime":3},{"title":"useCallback 훅 사용 방법","description":"","date":"2024-05-12 20:22","slug":"2024-05-12-HowtouseuseCallbackhook","content":"\n\n## useCallback()을 사용하여 React 컴포넌트의 성능을 향상시키세요.\n\n![이미지](/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png)\n\nReact 애플리케이션의 성능 향상에는 불필요한 렌더링을 방지하고 렌더링이 전파되는 시간을 줄이는 것이 포함됩니다. useCallback()을 사용하면 몇 가지 불필요한 렌더링을 방지하고 성능을 향상시킬 수 있습니다.\n\n이 글에서는 useCallback() 훅을 자세히 살펴보고, 더 나은 React 코드를 작성하기 위해 올바르게 사용하는 방법에 대해 알아보겠습니다.\n\n\n\n# 1. 함수 동등성\n\nuseCallback()에 대해 자세히 알아보기 전에 참조 동등성과 함수 동등성의 개념을 간단히 상기해 보겠습니다.\n\nJavaScript에서 함수는 다른 변수와 마찬가지로 다룰 수 있습니다. 함수는 다른 함수에서 인수로 전달될 수 있고, 다른 함수에 의해 반환될 수 있으며, 변수에 값을 할당하거나 비교하는 등의 작업을 수행할 수 있습니다. 다시 말해, 객체가 할 수 있는 모든 작업을 수행할 수 있습니다.\n\nsumFunctionFactory()라는 함수를 구현하여 숫자를 더하는 다른 함수를 반환하는 함수를 만들어 보겠습니다. 그런 다음 이 함수를 사용하여 function1과 function2라는 두 가지 함수를 만들어 보겠습니다.\n\n위에서 function1과 function2 함수는 동일한 코드 소스를 공유하지만 별도의 함수 객체이며 서로 다른 인스턴스를 가리키기 때문에 그들을 비교하면 false가 나옵니다. 이것이 JavaScript가 동작하는 방식입니다.\n\n# 2. useCallback() 훅\n\nReact로 돌아와서, 컴포넌트가 다시 렌더링될 때, 컴포넌트 내부의 각 함수가 재생성되므로 이러한 함수의 참조는 렌더 간에 변경됩니다.\n\nuseCallback(callback, dependencies)은 의존성 중 하나가 변경되었을 때에만 변경되는 캐시된 콜백의 인스턴스를 반환합니다. 이는 매 렌더링마다 함수 객체를 재생성하는 대신 렌더 간에 동일한 함수 객체를 사용할 수 있음을 의미합니다.\n\n\n\n```js\nconst memoized = useCallback(() =\u003e {\n   // the callback function to be memoized\n},\n  // dependencies array\n[]);\n```\n\n# 3. 사용 사례 시나리오\n\n## 최적화된 자식 컴포넌트에 콜백 전달하기\n\nuseCallback은 참조 동등성에 의존하는 최적화된 자식 컴포넌트에 콜백을 전달할 때 불필요한 렌더링을 방지하는 데 특히 유용합니다. 항목 목록을 렌더링하는 컴포넌트를 가정해보십시오:\n\n\n\n비싸고 불필요한 리스트 다시 렌더링을 방지하기 위해 React.memo()로 묶어주세요.\n\n부모 컴포넌트 `ParentComponent`에서 자식 컴포넌트 `MyList`로 핸들러 함수를 제공합니다:\n\n핸들러 콜백은 useCallback()으로 메모이즈됩니다. 의존성이 동일한 한, useCallback()은 동일한 함수 객체를 반환합니다. `ParentComponent`가 다시 렌더링될 때, 핸들러 함수 객체는 동일하게 유지되어 `MyList`의 메모리제이션을 깨지지 않습니다.\n\n![이미지](/assets/img/2024-05-12-HowtouseuseCallbackhook_1.png)\n\n\n\n# 4. useCallback()를 사용하지 말아야 하는 경우\n\n과도하게 사용하지 않도록 주의합시다. useCallback()에는 주로 코드 복잡성이라는 단점이 있습니다. useCallback()를 추가하는 것이 의미가 없는 경우가 많이 있고, 함수를 계속 재생성해야 하는 경우도 있습니다.\n\nuseCallback()은 여전히 모든 컴포넌트 재렌더링에서 실행해야 하므로 성능적인 단점이 있습니다. 이 예제에서는 useCallback()이 최적화에 도움이 되지 않습니다. 왜냐하면 매번 렌더링할 때마다 clickHandler 함수를 생성하기 때문에, 오히려 최적화 비용이 최적화하지 않는 것보다 더 많이 듭니다.\n\n# 5. 결론\n\n\n\n`useCallback(callback, dependencies)`는 `useMemo()`처럼 사용할 수 있지만 값 대신 함수를 메모이징하여 매 렌더링마다 재생성을 방지합니다. 불필요한 다시 렌더링을 피할 수 있어 응용 프로그램을 더욱 효율적으로 만들어줍니다.\n\n성능 업그레이드를 고려할 때는 언제나 최적화 작업 이전에 컴포넌트의 속도를 측정(또는 프로파일링)해야 합니다. 최적화는 복잡성을 증가시키므로, 개발자로서 효과를 확실하게 확인해야 합니다.\n\n더 많은 멋진 콘텐츠와 이와 유사한 프로젝트를 확인하려면 저희를 팔로우해주세요. Github 리포지토리도 꼭 확인해보세요:","ogImage":{"url":"/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png"},"coverImage":"/assets/img/2024-05-12-HowtouseuseCallbackhook_0.png","tag":["Tech"],"readingTime":3},{"title":"대규모 확장을 위해 React Native 앱에서 디자인 시스템 활용하기 제3부","description":"","date":"2024-05-12 20:20","slug":"2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction","content":"\n\u003cimg src=\"/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_0.png\" /\u003e\n\n첫 번째와 두 번째 파트에서 일반적으로 디자인 시스템에 대해 논의하고 디자인 시스템을 만드는 데 사용할 도구에 대해 더 많이 이야기했습니다. React Native 개발자를 위한 기술 기사를 쓰는 것에 대한 다양한 요청을 받은 후, 디자인 시스템을 코드하는 방법에 대한 기술적 구현을 안내하겠습니다. 이 부분에서는 TypeScript를 사용하여 React Native 앱에서 디자인 시스템을 구현하며, 라이브러리로 React Native Paper를 사용하고 React Context를 사용하여 앱에 전달할 것입니다.\n\n다음을 구현할 것입니다. 컬러 팔레트를 정의하는 테마를 만들겠습니다. 이 테마에는 Dark 모드와 Light 모드가 포함됩니다. 또한 텍스트의 다양한 변형(글자 간격, 크기, 글꼴 두께, 줄 높이, 글꼴 패밀리)를 정의할 것입니다. 반응형 디자인을 위해 반응형 화면에 대한 React Native Size Matter 라이브러리를 사용할 것입니다. 이는 React Native Paper 제공자에서 인스턴스화되며 테마를 사용하는 방법을 이해할 수 있도록 버튼 예제가 포함될 것입니다. 추가로 다크 모드와 라이트 모드의 전환기를 구현할 것입니다.\n\n또한 화면에 테마 객체를 전달하고 react-navigation을 사용하여 내비게이션에 사용되는 기본 테마를 수정하기 위해 사용자 정의 후크를 사용할 것입니다.\n\n이 기술 기사에서 다음을 배울 수 있습니다:\n\n- 사용자 정의 색상 팔레트 만들고 사용하는 방법\n- 타이포그래피(글꼴) 만들고 사용하는 방법\n- 앱에서 Rtl 및 Ltr 방향 모두 처리하는 방법\n- 앱에서 사용자 정의 공간 차원 만드는 방법\n- 반응형 앱 디자인하는 방법\n- React Native Paper 테마 사용하여 디자인 시스템 만드는 방법\n- 사용자 정의 테마 사용하여 구성 요소 만드는 방법\n- React Context 사용법 및 앱에 변수 전달하는 방법\n- 다크 모드와 라이트 모드 사용하는 방법\n- 앱 구성 관리를 위해 Redux 사용하고 설정 화면에서 테마 변경 처리하는 방법\n- 사용자 정의 훅 사용하여 테마 객체 전달하는 방법\n- React Native Paper 테마에 대한 TypeScript 수정 사항\n\n# React Native Paper\n\nReact Native Paper는 React Native 애플리케이션을 위한 UI 컴포넌트 라이브러리로, Material Design 가이드라인을 따르는 사용 준비 상태의 컴포넌트를 제공하여 개발자가 간편하게 세련된 일관된 사용자 인터페이스를 구축할 수 있도록 도와줍니다.\n\n## 설치\n\n세부 사항에 대해 심층적으로 알 필요 없이, 공식 문서에서 제공하는 안내에 따라 라이브러리를 설치해보세요.\n\nReact 네이티브 및 React 네이티브 페이퍼 라이브러리를 함께 사용하려면 해당 문서를 확인하세요. 추가로 사용자 정의가 가능합니다.\n\n# React Context\n\n리액트 컨텍스트는 React의 고급 기능으로, props를 수동으로 각 레벨마다 전달하지 않고 컴포넌트 트리를 통해 데이터를 전달할 수 있게 해줍니다. 이를 통해 리액트 애플리케이션의 컴포넌트들 간에 테마, 사용자 인증 상태 또는 다른 전역 데이터와 같은 값을 공유하여 상태 관리를 효율적으로 할 수 있고 prop 전달을 줄일 수 있습니다.\n\n# 시작해봅시다\n\n# 단계 1: 색상 Scheme 정의하기\n\n디자인 시스템의 첫 번째 단계는 색상 Scheme을 정의하는 것입니다. 기본 색상, 배경 색상, 성공, 오류 및 보충 배경과 같은 다양한 색상을 포함해야 합니다. 우리는 라이트 모드와 다크 모드를 모두 사용할 예정이므로 다음과 같은 객체를 갖게 될 것입니다:\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_1.png)\n\n# 단계 2: 타이포그래피 정의하기\n\n## React Native Paper V3의 폰트 유형\n\nFonts 객체를 갖기 위해 MD3Typescale을 사용하기 위해 React Native Paper V3를 사용할 것입니다.\n\n사용자 지정 글꼴을 사용하려면 사용자 지정 글꼴 사용 방법에 대한 내 글을 확인해보세요.\n\nEnum 안에 글꼴을 정의한 후 LTR 및 RTL 방향으로 이동하여 MD3Type 스케일을 정의합니다. 각 유형마다 글꼴 크기와 줄 높이에 사용할 것입니다.\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_2.png)\n\n# 단계 3: 크기 정의\n\n앱에 포함하고 싶은 크기를 담을 파일이 있어야합니다 (예: 매번 16px 정도의 일반적인 패딩 및 가장 많이 사용되는 2, 4, 8과 같은 값들을 포함).\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_3.png)\n\n## 단계 4: 테마 객체 정의하기\n\n우리가 이미 색상 체계를 설정했다면, 이제 색상 테마 객체를 내보냅니다.\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_4.png)\n\n# 단계 5: 스토어를 통해 언어 및 테마 유형 정의하기\n\n사용자가 기본 언어와 원하는 테마를 설정할 수 있는 곳이 필요합니다. 저는 Redux 툴킷을 사용하여 이를 관리하고 있습니다. 이를 위한 셀렉터와 변경 액션을 가지고 있어야 합니다.\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_5.png)\n\n# 단계 6: 테마 컨테이너를 생성하세요\n\n![테마 이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_6.png)\n\n# 단계 7: 네비게이션에 테마 전달하기\n\n![테마 이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_7.png)\n\n# 단계 8: 컴포넌트 만들기: Text 컴포넌트의 예시\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_8.png)\n\n# 단계 9: 테마 후크 사용 방법 및 사용자의 다크 또는 라이트 모드 정의\n\n![이미지](/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_9.png)\n\n# 결론\n\n이 문서를 읽고 나면 사용자 정의 테마를 앱에 구현할 준비가 됩니다. 자유롭게 댓글을 남기거나 친구들과 공유해보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*jzfCO3_3Fkz2iJQpNWbP0w.gif)\n\nReact Native, React 및 TypeScript에 관한 통찰을 공유합니다. Linkedin이나 Medium에서 팔로우해주세요.\n\n메시지를 보내서 무엇에 대해 쓰길 원한다면 말씀해주세요. 그럼 그에 따라 목록에 추가할게요.\n\n#reactnative #react #typescript #mobiledevelopment #engineering #patterns #bestpractices #memoryleak #performance #scaleApp #fastApp #userexperience #designSystems #Theme #MaterialDesign #uiUX #scaling #redux #reduxtoolkit #reactContext\n","ogImage":{"url":"/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_0.png"},"coverImage":"/assets/img/2024-05-12-BuildforScaleUseaDesignSysteminyourReactNativeappPart3DevelopyourCustomThemeIntroduction_0.png","tag":["Tech"],"readingTime":5},{"title":"윈도우에서 WSL2 및 도커 성능을 20배 높이세요","description":"","date":"2024-05-12 20:19","slug":"2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x","content":"\n\n일단 해결 방법에 관심이 있다면 건너뛰고, 제 글이 마음에 들 경우 계속 읽어주세요.\n\n개발자로서 윈도우 사용 경험은 대체로 좋았고 술술 잘 되었습니다. 그러나 도커를 접하면서 여행이 조금 중단되었습니다. Linux로 전환하기 싫었어요. 그 귀찮고 번거로운 일들 때문에 말이죠. 개발자로서 그런 얘기를 하긴 이상하지만, 오늘날 OEM 노트북들에 있는 다양한 문제들 때문에 Linux로 전환하는 건 지금은 정말 괴로운 일입니다. Secure Boot, Bitlocker Encryption과 같은 여러 문제들 때문이죠.\n\n![image](/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_0.png)\n\n이 말이 사실이었을 거예요. WSL2(Windows Subsystem Linux)가 없었다면 말이죠. WSL2는 Microsoft가 제공하는 호환성 레이어로, 사용자가 Windows OS 내에서 Linux의 전체 기능을 활용할 수 있게 해 줍니다! 정말 멋지고 훌륭한 기술이에요.\n\n\n\n# 하지만 한 가지 함정이 있어요...\n\n기분 좋은 저는 유행에 동참했어요. 설정하는 것은 꽤 쉬웠고, 문서도 매우 명확했어요. 여기에서 찾을 수 있어요. 기쁘게도 Docker Desktop을 설치하고 기뻐서 오픈 소스 프로젝트에서 docker compose up을 실행했는데, 약속한 대로 되나 확인해봤더니...\n\n![image](/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_1.png)\n\nWSL2의 성능이 정말 좋지 않았어요. 정말 진지하게 말하면, 로컬 머신에서 2-3초가 걸릴 작업들을 Django에서 핫 리로드하는 데 엄청 오랜 시간이 걸렸어요. 이러한 성능으로 개발하는 것은 거의 불가능했죠. 그러나 조금의 조사와 문서 검색을 통해 해답을 찾을 수 있었어요.\n\n\n\n# 해결책\n\n해결책은 여기 문서에 기재되어 있습니다. 기술적인 용어를 간단히 하기 위해, Windows 파일 시스템에서 복제하거나 프로젝트를 만드는 대신 WSL2 자체에서 직접 작업해야 합니다. 이게 무슨 말인지 보여드릴게요.\n\n## 단계 1. WSL2 내에서 git clone/새 프로젝트 만들기:\n\n- 파일 탐색기를 열고 왼쪽 하단에 Linux가 표시됩니다. 메뉴를 확장합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_2.png\" /\u003e\n\n- 저는 우분투를 설치했어요. 원하시는 배포판의 WSL2에서 프로젝트를 만들거나 복제할 수 있어요.\n- /home/'Your-Name'/projects 폴더를 만들어주세요. 이 단계는 선택 사항이며, 리눅스에서 프로젝트가 보통 만들어지는 관례를 준수하는 것뿐이에요.\n\n\u003cimg src=\"/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_3.png\" /\u003e\n\n- 이제 projects 폴더 안에서 터미널을 열고, 마우스 오른쪽 버튼을 클릭하여 이 폴더 내에서 새 프로젝트를 만들거나 복제해주세요.\n\n\n\n도커 컴포즈를 실행하고 와! 성능이 밤낮으로 달라졌어요. 아래 이미지에서 핫 리로드 속도의 차이를 명확히 확인할 수 있어요.\n\nIDE에서 코드를 편집하려면 몇 가지 추가 단계가 필요해요. Visual Studio Code 사용자는 WSL 확장을 설치하기만 하면 됩니다. Linux 파일 시스템에서 프로젝트를 열 때 아래와 같은 프롬프트가 표시됩니다. 다른 IDE 사용자는 아래 기사를 참조하세요.\n\n![이미지](/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_4.png)\n\n# 결론\n\n\n\n저는 WSL2를 발견한 이후로 엄청난 성능 향상을 경험하며 행복하게 사용해왔고, 그로 인해 쉽게 WSL2를 추천할 수 있어요. 하지만 왜 Windows 파일 시스템에서 성능이 저하되는지 궁금해하시나요? 이는 Linux 파일 시스템과 Windows 파일 시스템이 본질적으로 다르기 때문에, Windows에서 도커 컴포즈를 실행하면 Docker가 서로 다른 파일 시스템 간 호환성을 유지하기 위해 힘들게 작업해야 하기 때문이에요.\n\n이 간단하고 깔끔한 팁이 유용하게 느껴지시면, 이 기사에 박수를 치고 동료들 사이에서 공유해보세요. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_0.png"},"coverImage":"/assets/img/2024-05-12-IncreaseWSL2andDockerPerformanceonWindowsBy20x_0.png","tag":["Tech"],"readingTime":3},{"title":"취업 전에 반드시 알아야하는 Reactjs의 10가지 핵심 개념 ","description":"","date":"2024-05-12 20:18","slug":"2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment","content":"\n![이미지](/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png)\n\n안녕, 친구들! 오늘은 웹 개발의 슈퍼히어로인 React.js의 마법같은 세계를 함께 즐겁게 탐험할 거에요. 생각해봐요, 당신이 주방에서 요리사라고 상상해봐요. 그리고 React.js가 여러분의 음식에 넣으면 모든 요리(웹 애플리케이션)가 맛있고 아름답게 보이게 만들어주는 비밀 재료라고 생각해봐요. 이제 React.js를 주인공으로 뽑아낸 10가지 핵심 개념을 알아봐요.\n\n#1. VirtualDOM: 성능의 슈퍼히어로\n\n비디오 게임을 하고 있는데 매번 버튼을 누를 때마다 화면 전체가 번쩍이면 재미없겠죠? React.js는 VirtualDOM을 사용하여 이 문제를 해결해요. 이는 당신의 웹사이트가 어떻게 보일지 미리 보여주는 것인데, 실제로 화면을 업데이트하지 않아요. 이렇게 함으로써 React.js는 필요한 내용만 업데이트해서 여러분의 웹사이트를 부드럽게 만들어줘요. 완전히 버터 같죠!\n\n# 2. JSX: React 언어\n\nJSX는 React.js가 사용하는 비밀 언어 같아요. HTML처럼 보이지만 실제로는 JavaScript에요. 온라인으로 피자를 주문할 때 특별한 코드로 말하는 것과 비슷해요. 한번 익숙해지면 재미있고 코드를 읽기 쉽게 만들어 줘요.\n\n# 3. Components: React의 구성 요소\n\nReact.js 세계에서 모든 것은 구성 요소로 이루어져 있어요. 그들을 레고 블록처럼 생각해보세요. 간단한 버튼부터 복잡한 양식까지 아무 것이나 만들 수 있고, 이 블록(구성 요소)을 다시 재사용할 수도 있어요. 원하는 모든 모양으로 변할 수 있는 마법 상자를 가지고 있는 것과 비슷해요.\n\n# 4. 프롭스: 메신저\n\n프롭스는 한 컴포넌트에서 다른 컴포넌트로 전송되는 편지처럼 작동합니다. 그들은 정보를 전달하고 컴포넌트에게 어떤 것을 표시할지 알려줍니다. 친구에게 메시지를 보내고, 그들이 다시 답장하는 상황을 상상해보세요. 이것이 React.js에서 프롭스가 동작하는 방식입니다. 모든 컴포넌트들이 같은 페이지에 있는지 확인합니다.\n\n# 5. 상태: 기억 보관함\n\n상태는 컴포넌트가 자체 정보를 기록하는 다이어리와 같습니다. 그것은 지난 일들을 기억하고 시간이 지남에 따라 변경됩니다. 지난 여름에 어떤 맛의 아이스크림을 좋아했는지 기억하는 것과 비슷합니다.\n\n# 6. 라이프사이클 메소드: 이야기꾼\n\n라이프사이클 메소드는 책의 장(chapters)과 같아요. 컴포넌트의 수명 주기를 이야기하는데, 그것은 그 컴포넌트가 태어나서 성장하고 마침내 떠날 때까지의 이야기 같아요. 마치 내가 좋아하는 영화 캐릭터의 생일을 알고 있는 것 같은 느낌이에요.\n\n# 7. 훅: 게임 체인저\n\n훅은 비디오 게임에서의 치트 코드와 같은 역할이에요. 클래스를 작성하지 않고도 상태(state) 및 다른 리액트(React) 기능을 사용할 수 있게 해줘요. 마법 지팡이를 휘두르지 않고도 모든 것을 할 수 있는 그런 느낌이에요.\n\n# 8. 문맥: 글로벌 소문\n\n문맥은 마을의 장난꾸러기처럼 동작합니다. 다른 구성 요소끼리 속삭이지 않아도 모두에게 정보를 공유합니다. 마을의 최신 소문을 알게 되는 느낌이죠.\n\n# 9. 조정: 평화지기\n\n조정은 축구 경기의 심판과 같습니다. 새로운 계획(가상 DOM)을 이전 계획과 비교하여 업데이트가 필요한 부분을 결정합니다. 모두가 동의할 수 있도록 싸움을 일으키지 않고 모든 사람이 같은 페이지에 있는지 확인하는 느낌입니다.\n\n# 10. 리액트 라우터: 여행 안내서\n\n리액트 라우터는 당신의 웹사이트를 위한 여행 안내서와 같아요. 사용자들이 길을 잃지 않고 서로 다른 페이지를 탐험할 수 있게 도와줍니다. 다음으로 어디로 가야할지 보여주는 지도가 있다고 생각해봐요.\n\n여기서 보았던 바와 같이, 리액트.js의 10가지 핵심 개념이 즐겁고 이해하기 쉬운 방식으로 설명되었어요. 당신이 기술 마법사라도, 웹 개발의 세계에 호기심 가득하더라도, 리액트.js는 흥미로운 것을 제공해줘요. 그래서 뭐해요? 리액트.js의 세계에 뛰어들어서 멋진 웹 애플리케이션을 만들기 시작해보세요. 언제나 기억하세요, 천 마일의 여정은 한 번의 클릭으로 시작됩니다. 즐거운 코딩 하시고, 당신의 리액트.js 여정이 소금버터처럼 부드럽기를 기원합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-10CoreConceptsofReactjsAFunJourneyThroughtheWorldofWebDevelopment_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트가 fetch를 왜 제거했는지 지금 RSC-fetch를 작성하기 위해 반드시 알아야 하는 내용","description":"","date":"2024-05-12 20:17","slug":"2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png\" /\u003e\n\n몇 일 전, React 팀이 암시적인 fetch 캐시를 제거했습니다. 그리고 fetch 요청의 결과를 명시적으로 캐시하는 데 `React.cache`를 사용하는 것을 제안했습니다. 새로운 `React.cache` API의 장점을 최대한 활용하려면 RSC에서 fetch 호출을 작성하는 새로운 방법을 이해하는 것이 중요합니다. 그러나 새로운 방법에 대한 이해에 접어들기 전에, 개발자가 캐시를 명시적으로 관리하는 것이 왜 유익한지 먼저 이해해 봅시다.\n\n암시적 캐싱의 위험성\n\n캐싱은 전반적으로 유익해 보이지만, 브라우저나 프레임워크가 개발자의 제어 없이 자동으로 데이터를 캐시하는 암시적 캐싱은 예상치 못한 동작과 버그를 일으킬 수 있습니다. 여기에 이유가 있습니다:\n\n\n\n- 만료된 데이터: API 응답이 자주 변경되는 경우, 암시적으로 캐싱을 하면 사용자에게는 오래된 정보가 제공될 수 있어서 보여지는 데이터와 실제 상태 사이에 불일치가 발생할 수 있습니다.\n- 일관성이 없음: 다른 브라우저나 브라우저 설정은 캐싱을 다르게 구현할 수 있어 사용자 경험 사이에 불일치가 생길 수 있습니다.\n- 디버깅 문제: 만료된 데이터로 인한 문제가 발생할 때, 캐싱 메커니즘을 명시적으로 제어하지 않는 경우 원인을 파악하기 어려울 수 있습니다.\n\n성능과 유지보수성을 위한 명시적 제어\n\n명시적 캐싱을 선택함으로써, 개발자가 데이터가 어떻게 그리고 언제 캐싱되는지에 대한 소유권을 갖도록 장려합니다. 이를 통해 우리는 다음과 같은 이점을 가질 수 있습니다:\n\n- 캐싱 전략 정의: 데이터의 특성과 업데이트 빈도에 기반하여 적절한 캐싱 전략을 선택할 수 있습니다. 예를 들어, 정적 데이터는 무기한 캐싱될 수 있으며, 자주 변경되는 데이터는 유효성 검사 메커니즘이 필요할 수 있습니다.\n- 무효화 처리: 캐시 만료 시간이나 무효화 리스너와 같은 기술을 구현하여 캐시가 적합하고 오래된 정보를 제공하지 않도록 할 수 있습니다.\n- 개선된 디버깅: 캐싱을 명시적으로 제어함으로써 데이터 흐름을 쉽게 이해하고 캐싱 문제의 원인을 식별할 수 있어 개발자들이 문제 해결을 용이하게 할 수 있습니다.\n\n\n\nReact fetch 캐시는 무엇인가요?\n\nfetch 호출을 하면 React가 fetch 결과를 캐싱했습니다. 다른 컴포넌트들이 동일한 데이터를 필요로 하여 동일한 fetch 호출을 하면, React는 엔드포인트로 새로운 요청을 보내지 않고 대신에 캐시로부터 데이터를 다른 컴포넌트에 제공합니다. 이는 성능을 위해 좋지만, 예상치 못한 동작을 일으킬 수도 있습니다. 예를 들어, 아래 코드에서 다섯 개의 컴포넌트가 fetch 호출을 하고 모두 동일한 데이터가 필요합니다. 이렇게 요청을 만들 경우에 React는 결과를 캐시하지 않고 동일한 엔드포인트에 다섯 번의 요청을 보냅니다. 여기서 `React.cache` API가 캐시를 명시적으로 관리하기 위해 등장합니다.\n\n\n\n**Reach.cache()** 새로운 방법으로 fetch 호출 작성하기\n\n이제는 동일한 데이터가 필요한 다른 컴포넌트가 있다면 새로운 요청을 수행하지 않도록 fetch 호출을 React.cache로 래핑해야 합니다. 이것은 한 번의 요청만을 수행합니다.\n\n```js\nimport React from \"react\"\n\nconst getMessiStats = React.cache(async () =\u003e {\n    const stats = await fetch('https://api.football-data.org/v2/players/52')\n    return stats.json()\n})\n\nasync function MessiStats() {\n    const data = await getMessiStats()\n    return (\n        \u003cdiv\u003e\n            {JSON.stringify(data)}\n        \u003c/div\u003e\n    )\n}\n\nexport async function RSCFetch() {\n    const stats = await getMessiStats()\n    return (\n        \u003c\u003e\n            \u003cdiv\u003e{JSON.stringify(stats)}\u003c/div\u003e\n            \u003cMessiStats /\u003e\n            \u003cMessiStats /\u003e\n            \u003cMessiStats /\u003e\n            \u003cMessiStats /\u003e\n        \u003c/\u003e\n    )\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png"},"coverImage":"/assets/img/2024-05-12-WhyReactRemovedthefetchyoumustknowthisfornowtowriteRSC-fetch_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트에서 useMemo 사용하기 - 코드 예제와 함께 1부 2부","description":"","date":"2024-05-12 20:15","slug":"2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png\" /\u003e\n\nReact에서 useMemo는 계산에 대한 메모지와 같은 역할을 합니다. 그것은 답을 기억하기 때문에 매번 다시 계산할 필요가 없습니다.\n\n# 계산 시간을 단축하기\n\nuseMemo를 처음에 사용하여 결과를 저장하고 매번 컴포넌트가 업데이트될 때마다 다시 계산하는 것을 피하세요.\n\n\n\n```js\nimport { useMemo } from 'react';\n\nfunction TodoList({ todos, tab, theme }) {\n  const visibleTodos = useMemo(() =\u003e filterTodos(todos, tab), [todos, tab]);\n  // ...\n}\n```\n\n컴포넌트가 다시 렌더링될 때마다 비싼 계산을 방지하려면 useMemo를 사용할 수 있어요. 이는 컴포넌트에 계산에 대한 단기 기억을 제공하는 것 같아요. 작동 방식은 다음과 같아요:\n\n- 두 가지 요소: useMemo에는 두 가지 요소가 필요해요:\n\n- 계산: 메모이즈하려는 계산을 수행하는 함수. 이 함수는 어떤 인수도 받지 않아야 해요 (() =` ...).\n- 감시 목록(의존성): useMemo가 계산 내부에서 사용하는 값들을 계속 지켜보아야 하는 목록. 이 값 중 하나라도 변경되면 계산을 다시 해야 해요.\n\n\n\n- 초기 렌더링: 컴포넌트가 처음 렌더링될 때 useMemo는 계산을 실행하고 결과를 저장합니다.\n- 이후 렌더링: 나중에 업데이트될 때 useMemo는 현재 종속성을 이전 렌더링에서 사용된 값과 비교합니다. 감지된 값 중 하나도 변경되지 않은 경우 (깊은 동등성을 위해 Object.is로 비교), useMemo는 이전에 계산된 결과를 단순히 반환하여 시간을 절약합니다.\n- 계산 재실행 트리거: 종속성 중 하나라도 변경된 경우, useMemo는 계산이 업데이트되어야 함을 이해합니다. 함수를 다시 실행하고 새로운 결과를 반환합니다.\n\n요약하면 useMemo는 계산 결과를 캐시처럼 저장하여 종속된 데이터가 변경될 때까지 유지합니다.\n\n실제 유용한 예제를 살펴보겠습니다.\n\n## 느린 계산 시뮬레이션과 useMemo의 힘\n\n\n\nuseMemo의 가치를 보여주기 위해, 이 예시에서는 filterTodos 함수에 의도적으로 지연을 추가했습니다. 이는 계산이 계산적으로 비싸다고 할 수 있는 실제 시나리오를 모방합니다.\n\n테스트해보세요!\n\n탭 간을 전환하고 테마를 토글해보세요. 특히 테마를 토글할 때 느린 반응을 느낄 수 있을 겁니다.\n\n왜 느려질까요?\n\n\n\n이 버전에서는 useMemo를 사용하지 않았어요. 그 결과로, sluggish한 filterTodos 함수가 모든 리렌더링마다 호출되는데, 테마에 변경이 있는 경우에도 호출됩니다 (필터링 로직에는 영향을 주지 않는 경우). 이 불필요한 다시 계산이 지연을 유발해요.\n\nApp.js\n\n```js\nimport { useState } from 'react';\nimport { createTodos } from './utils.js';\nimport TodoList from './TodoList.js';\n\nconst todos = createTodos();\n\nexport default function App() {\n  const [tab, setTab] = useState('all');\n  const [isDark, setIsDark] = useState(false);\n  return (\n    \u003c\u003e\n      \u003cbutton onClick={() =\u003e setTab('all')}\u003e\n        All\n      \u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setTab('active')}\u003e\n        Active\n      \u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setTab('completed')}\u003e\n        Completed\n      \u003c/button\u003e\n      \u003cbr /\u003e\n      \u003clabel\u003e\n        \u003cinput\n          type=\"checkbox\"\n          checked={isDark}\n          onChange={e =\u003e setIsDark(e.target.checked)}\n        /\u003e\n        Dark mode\n      \u003c/label\u003e\n      \u003chr /\u003e\n      \u003cTodoList\n        todos={todos}\n        tab={tab}\n        theme={isDark ? 'dark' : 'light'}\n      /\u003e\n    \u003c/\u003e\n  );\n}\n```\n\nTodoList.js\n\n\n\n```js\nimport { filterTodos } from './utils.js';\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = filterTodos(todos, tab);\n  return (\n    \u003cdiv className={theme}\u003e\n      \u003cul\u003e\n        \u003cp\u003e\u003cb\u003e참고: \u003ccode\u003efilterTodos\u003c/code\u003e가 인위적으로 느려집니다!\u003c/b\u003e\u003c/p\u003e\n          {visibleTodos.map(todo =\u003e (\n            \u003cli key={todo.id}\u003e\n              {todo.completed ?\n                \u003cs\u003e{todo.text}\u003c/s\u003e :\n                todo.text\n              }\n            \u003c/li\u003e\n          ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n``` \n\nutils.js\n\n```js\nexport function createTodos() {\n  const todos = [];\n  for (let i = 0; i \u003c 50; i++) {\n    todos.push({\n      id: i,\n      text: \"할 일 \" + (i + 1),\n      completed: Math.random() \u003e 0.5\n    });\n  }\n  return todos;\n}\n\nexport function filterTodos(todos, tab) {\n  console.log('[인위적으로 느려짐] \"' + tab + '\" 탭을 위해 ' + todos.length + '개의 할 일을 필터링합니다.');\n  let startTime = performance.now();\n  while (performance.now() - startTime \u003c 500) {\n    // 극도로 느린 코드를 흉내 내기 위해 500ms 동안 아무것도 하지 않습니다.\n  }\n\n  return todos.filter(todo =\u003e {\n    if (tab === 'all') {\n      return true;\n    } else if (tab === 'active') {\n      return !todo.completed;\n    } else if (tab === 'completed') {\n      return todo.completed;\n    }\n  });\n}\n```\n\n모든 것에 끈적이지 않는 쪽지가 필요한 것은 아닙니다 (useMemo)\n\n\n\n\n대부분의 경우, 메모이제이션 없이도 코드는 완벽하게 작동합니다. 응용 프로그램이 반응적이고 상호 작용이 원활하다면, 일단 useMemo를 사용할 필요가 없을 수도 있습니다.\n\n성능 테스트\n\nutils.js에 더 많은 할 일 항목을 추가해보고 동작을 관찰해보세요. 이 예제에서 필터링 자체는 그다지 느리지 않았습니다. 그러나 대량의 할 일이 있는 경우 대부분의 성능 병목 현상이 필터링에서 다시 렌더링 프로세스로 옮겨질 수 있습니다.\n\n# 스마트 업데이트: 필요할 때만 다시 렌더링하기\n\n\n\n일부 상황에서 useMemo는 구성 요소 내에서의 계산 뿐만 아니라 하위 구성 요소의 다시 렌더링을 최적화하는 데 도움이 될 수도 있습니다.\n\n예를 살펴봅시다\n\n우리의 TodoList 구성 요소가 필터링된 visibleTodos를 자식 List 구성 요소로 전달할 때를 상상해보세요. 이 내용은 다음 섹션에서 useMemo가 이 시나리오에서 어떻게 사용될 수 있는지 탐구하는 데 기초를 제공합니다.\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // ...\n  return (\n    \u003cdiv className={theme}\u003e\n      \u003cList items={visibleTodos} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n리액트는 일반적으로 부모 컴포넌트가 다시 렌더링될 때 자식 컴포넌트 전체를 다시 렌더링합니다. 이것이 TodoList에서 theme이 변경되어도 List 컴포넌트가 다시 렌더링되는 이유입니다 (visibleTodos prop에 영향을 주지 않는 한).\n\n그러나 자식 컴포넌트에서 느린 다시 렌더링 프로세스를 식별했다면, 성능을 개선할 수 있는 memo라는 기술을 활용할 수 있습니다. List 컴포넌트를 memo로 감싸면, List가 이전 렌더링과 비교해 실제로 변경된 props가 없다면 React에게 불필요한 다시 렌더링을 건너뛰도록 지시할 수 있습니다.\n\n```js\nimport { memo } from 'react';\n\nconst List = memo(function List({ items }) {\n  // ...\n});\n```\n\nList 컴포넌트를 memo로 감싸면, List의 props가 실제로 변경될 때만 List를 다시 렌더링하도록 React에 지시하는 셈입니다. 이는 특히 다시 렌더링 비용이 높은 컴포넌트에 대해서는 성능을 크게 향상시킬 수 있습니다.\n\n\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // 테마가 변경될 때마다, 이는 다른 배열이 됩니다...\n  const visibleTodos = filterTodos(todos, tab);\n  return (\n    \u003cdiv className={theme}\u003e\n      {/* ... 따라서 List의 props는 항상 동일하지 않으며 매번 재랜더링됩니다 */}\n      \u003cList items={visibleTodos} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이전 예시에서 filterTodos 함수는 배열의 내용이 동일해도 항상 새 배열 객체를 반환합니다. 이 동작은 ''를 사용하여 객체 리터럴을 만들 때 항상 새로운 객체가 생성되는 방식과 유사합니다.\n\n보통, 이는 큰 문제가 되지 않을 수 있습니다. 그러나 우리의 경우에는 List 컴포넌트를 최적화하기 위해 memo를 사용하는데, 렌더링 사이에 props를 비교하는 데 의존합니다. filterTodos가 내용이 동일하더라도 항상 새 배열을 생성한다면, memo는 항상 다른 props로 인식하여 List를 다시 렌더링합니다. 이는 최적화의 목적을 무효화시킵니다.\n\n```js\nexport default function TodoList({ todos, tab, theme }) {\n  // React에게 다시 렌더링 사이에 계산을 캐시하도록 알립니다...\n  const visibleTodos = useMemo(\n    () =\u003e filterTodos(todos, tab),\n    [todos, tab] // ...따라서 이러한 종속성이 변경되지 않는 한...\n  );\n  return (\n    \u003cdiv className={theme}\u003e\n      {/* ...List는 동일한 props를 받고 렌더링을 건너뛸 수 있습니다 */}\n      \u003cList items={visibleTodos} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\nvisibleTodos 계산을 useMemo로 감싸면, 필터링에 사용된 데이터(할 일 항목)가 변경되지 않는 한, 다시 렌더링 사이에 동일한 배열 참조를 반환함을 보장합니다. 이는 memo가 효과적으로 프롭을 비교하고 List 컴포넌트의 불필요한 다시 렌더링을 건너뛸 수 있도록 합니다.\n\n# 훅 체인에서 중복 계산 방지\n\n컴포넌트 코드 내에서 직접 정의한 사용자 지정 객체에 계산이 의존하는 경우는 어떻게 될까요?\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const searchOptions = { matchMode: 'whole-word', text };\n\n  const visibleItems = useMemo(() =\u003e {\n    return searchItems(allItems, searchOptions);\n  }, [allItems, searchOptions]); // 🚩주의: 컴포넌트 내에서 생성된 객체에 의존성\n  // ...\n```\n\n\n\n## 컴포넌트 내 객체의 도전\n\n`useMemo`를 사용할 때 컴포넌트 코드 내에서 직접 생성된 객체와 관련된 잠재적인 함정이 있습니다. 해당 컴포넌트 내의 모든 코드가 다시 렌더링될 때마다 실행되므로, 매번 객체를 생성하는 것은 메모이제이션의 목적을 무효화시킵니다.\n\n## 왜 동작하지 않는지\n\n검색옵션이라는 객체에 의존하는 계산이 있다고 상상해보십시오. 이 객체를 컴포넌트 본문 안에서 직접 생성하고 `useMemo`의 의존성으로 추가한다면 문제가 발생합니다. React는 모든 코드를 다시 실행하기 때문에, 다시 렌더링될 때마다 검색옵션 객체를 재생성합니다. 심지어 그 내용이 동일하더라도 말이죠. 이는 `useMemo`가 항상 새로운 객체 참조를 보게 하고 실제 데이터가 변경되지 않았더라도 다시 계산을 시작하도록 유발합니다.\n\n\n\n## 해결책: 사전에 객체를 메모이즈(Memoize)하세요\n\n이 문제를 해결하기 위해, useMemo에 전달하기 전에 검색 옵션 객체 자체를 메모이즈하세요. 이렇게 하면 관련 데이터가 변경되지 않을 때 useMemo이 일관된 객체 참조를 받아들여 적절히 계산 결과를 캐시할 수 있습니다.\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const searchOptions = useMemo(() =\u003e {\n    return { matchMode: 'whole-word', text };\n  }, [text]); // ✅ 텍스트가 변경될 때만 변경됩니다\n\n  const visibleItems = useMemo(() =\u003e {\n    return searchItems(allItems, searchOptions);\n  }, [allItems, searchOptions]); // ✅ allItems 또는 searchOptions가 변경될 때만 변경됩니다\n  // ...\n```\n\n## 더 간략한 방법\n\n\n\n이전 예제에서는 useMemo에 전달하기 전에 searchOptions 객체를 기억하도록 언급했습니다. 그것은 동작하지만, 더 원할한 방법이 있습니다.\n\n## 모든 것을 함께 유지\n\n객체를 따로 기억하는 대신, 그것을 useMemo 계산 함수 내부에 직접 이동시키면 어떨까요? 이렇게 하면 객체의 생성이 사용하는 계산과 밀접하게 연관됨이 보장됩니다.\n\n## 장점\n\n\n\n`useMemo` 내에서 객체 정의를 배치함으로써, 계산이 실제로 실행될 때만 객체가 생성된다는 것을 보장합니다. 게다가, 객체의 로직에 대한 모든 변경 사항이 자동으로 계산에 반영되어 동기화를 유지합니다. 이는 코드를 닍고 일관성을 보장하여 모든 것을 간단하게 만들어 줍니다.\n\n```js\nfunction Dropdown({ allItems, text }) {\n  const visibleItems = useMemo(() =\u003e {\n    const searchOptions = { matchMode: 'whole-word', text };\n    return searchItems(allItems, searchOptions);\n  }, [allItems, text]); // ✅ allItems 또는 text가 변경될 때만 변경됩니다\n  // ...\n```\n\n# 함수 캐싱\n\nForm 컴포넌트가 React.memo()를 사용하여 성능 최적화되어 있다고 가정해봅시다. 이 컴포넌트에 함수를 속성(prop)으로 제공하고 싶습니다.\n\n\n\n상상해봐요. 뭔가를 담을 상자('')가 있다고 생각해봐요. 새 상자를 사용할 때마다 새로운 빈 상자를 얻게 돼요. 마찬가지로 React에서 두 가지 방식으로 함수를 정의하면(함수() ''와 () =` ''), 매번 완전히 새로운 함수가 만들어져요. 이것 자체로는 나쁜 것이 아니에요. 하지만 Form 컴포넌트를 최적화하고 불필요한 업데이트를 방지하기 위해 React.memo()를 사용하는 경우, 계속 변하는 함수 prop은 해당 최적화를 무의미하게 만들 수 있어요.\n\n함수를 다시 렌더링하지 않도록 useMemo를 사용하려면, useMemo 내부의 함수는 다른 함수를 반환해야 해요.\n\n```js\nexport default function Page({ productId, referrer }) {\n  const handleSubmit = useMemo(() =\u003e {\n    return (orderDetails) =\u003e {\n      post('/product/' + productId + '/buy', {\n        referrer,\n        orderDetails\n      });\n    };\n  }, [productId, referrer]);\n\n  return \u003cForm onSubmit={handleSubmit} /\u003e;\n}\n```\n\n\n\n그 솔루션은 약간 어색할 수 있을 것 같아요. 다행히 React에서는 이 상황을 고려하여 특별히 설계된 useCallback이라는 내장 후크를 제공해요. useMemo로 중첩 함수를 생성하는 대신 useCallback을 사용하여 함수를 간단히 래핑할 수 있어요. useCallback은 의존성을 추적하고 해당 의존성이 변경될 때에만 새로운 함수를 생성해요.\n\n```js\nexport default function Page({ productId, referrer }) {\n  const handleSubmit = useCallback((orderDetails) =\u003e {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails\n    });\n  }, [productId, referrer]);\n\n  return \u003cForm onSubmit={handleSubmit} /\u003e;\n}\n```\n\n우리가 보았던 두 가지 방법(useMemo와 중첩 함수, useCallback)은 같은 결과를 얻을 수 있어요. useCallback의 유일한 장점은, useMemo 내에서 추가적인 함수가 필요하지 않아져 코드를 보다 깔끔하게 유지할 수 있다는 점이에요. 이 외에는 다른 기능은 제공하지 않아요. useCallback에 대해 더 알고 싶다면, 추가 자료를 참고해보세요.\n\n# 요약\n\n\n\n- 최상위 또는 사용자 정의 후크: useMemo은 컴포넌트의 시작 부분에서만 호출하거나 직접 만든 사용자 정의 후크 안에서만 호출할 수 있습니다. 반복문이나 조건문 내에서는 작동하지 않습니다. 그 기능이 필요하다면 계산을 위한 별도의 컴포넌트를 만들어보세요.\n- 개발 중 두 번 호출 확인 (Strict Mode): 활성화되면 React는 고의로 계산 함수를 두 번 호출하여 계산 그 자체에 잠재적 문제가 없는지(“불순물\"라고 함) 확인합니다. 이는 오직 개발 목적으로만 사용되며 프로덕션에서는 발생하지 않습니다. 계산이 순수하다면(즉, 입력에만 의존하고 부작용이 없는 경우) 코드에 영향을 주지 않습니다. 추가된 결과는 그냥 무시됩니다.\n- 스마트 캐싱: React는 필요할 때가 아니면 캐시된 값을 버리지 않습니다. 개발 시 컴포넌트 코드를 편집할 때에는 클리어될 수 있습니다. 개발 및 프로덕션 모두에서 초기 렌더링 중 컴포넌트가 보류될 때 캐시가 클리어될 수 있습니다. React는 효율을 위해 캐시를 클리어하는 미래 기능을 도입할 수도 있습니다(가상 리스트와 같은 경우). 성능 최적화를 위해 useMemo를 사용한다면 이것이 문제가 되지 않을 것입니다. 그러나 다시 렌더링 간에 캐시된 값을 의존하는 경우 다른 이유로 상태 변수나 ref를 대신 사용하는 것을 고려해보세요.\n\n만약 이 글을 좋아하셨다면 박수나 댓글 부탁드립니다. 이를 통해 포스트의 퀄리티를 향상시킬 수 있고, 여러분에 대해 더 많이 알 수 있습니다. 많이 감사합니다!\n\n아래에서 제 소셜 미디어 및 새로운 글을 구독할 수 있는 링크를 찾으실 수 있습니다. 팁은 언제나 환영합니다.\n\n```js\ntype SocialMedia = {\n  LinkedIn: string;\n  GitHub: string;\n  StackOverflow: string;\n  Litsy: string;\n  Email: string;\n  X: string;\n}\n\nfunction newSocialMedia(): SocialMedia {\n  return {\n    LinkedIn: \"https://www.linkedin.com/in/edwardcasanova/\",\n    GitHub: \"https://github.com/ed3899\",\n    StackOverflow: \"stackoverflow.com/users/11941146/edward-casanova\",\n    Litsy: \"https://www.litsy.com/web/stack/edca3899/read\",\n    Email: \"ed.wacc1995@gmail.com\",\n    X: \"https://twitter.com/edca3911\"\n  };\n}\nconst subscribe = (): string =\u003e {\n  return \"https://medium.com/@ed.wacc1995/subscribe\";\n};\nconst tip = (): string =\u003e {\n  return \"https://paypal.me/edca3899?country.x=MX\u0026locale.x=es_XC\";\n};\n```","ogImage":{"url":"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoWorkwithuseMemoinReactwithCodeExamples12_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트에서의 인증과 권한 부여 방법","description":"","date":"2024-05-12 20:14","slug":"2024-05-12-AuthenticationandAuthorizationinreact","content":"\n우리는 이 튜토리얼에서 React 앱에 대한 인증 및 권한 부여 기능을 활용할 것입니다. 시작해 봅시다...\n\n인증이란 무엇인가요?\n\n인증은 제공된 자격 증명을 사용하여 사용자의 신원을 확인하는 과정입니다. 사용자가 정당한지 확인하는 것이 일반적입니다.\n\n권한이란 무엇인가요?\n\n인증은 사용자 클라이언트의 권한이나 액세스 수준을 결정하는 보안 절차입니다. 인증된 사용자가 작업을 수행할 수 있는 권한 또는 액세스 여부를 확인하는 것은 표준 절차입니다.\n\n파일과 폴더를 정리해 봅시다.\n\nsrc 하위에 components 폴더를 만듭니다.\n그런 다음 다음 파일을 만듭니다: Unauthorized.js, Navbar.js, Profile.js, Extra.js, Home.js, About.js, Extra.js.\n\n![이미지](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png)\n\n리액트 라우터 패키지를 사용할 것이기 때문에 다음 명령어를 사용하여 설치해 보겠습니다.\n\nNPM을 사용하는 경우\n\n```js\nnpm install react-router-dom@6\n```\n\nYarn을 사용하는 경우\n\n```js\nyarn add react-router-dom@6\n```\n\n새로운 폴더를 만들어서 routes라고 이름 짓기로 하자.\n\n다음 파일을 만들어보세요: Authentication.js, Authorization.js, 그리고 RoutePath.js.\n\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_1.png\" /\u003e\n\n\npermissions와 provider라는 이름의 두 개의 추가 폴더를 만들어 주세요. permissions 폴더 안에 permissions.js 파일을, provider 폴더 안에는 authprovider.js 파일을 만들어 주세요.\n\n우린 이제 폴더 구조를 마칩니다.\n\n![Authentication and Authorization in react](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_2.png)\n\n인증 및 권한 부여가 어떻게 구현되는지 이해하는 것이 우리의 유일한 목표이기 때문에 복잡한 코드나 디자인에 신경쓰지 않을 거에요.\n\n지금 파일을 수정하기 시작하세요!!!\n\nPermissions.js\n\n```js\nconst PERMISSIONS = {\n  CAN_VIEW_ABOUT: \"view_about\",\n  CAN_VIEW_EXTRA: \"view_extra\",\n};\nexport default PERMISSIONS;\n```\n\n일부 데이터에 무단으로 접근을 막기 위해 권한을 만들었습니다.\n\nAuthProvider.js\n\n```js\nimport React, { createContext, useContext, useState } from \"react\";\nimport { useNavigate, useLocation } from \"react-router-dom\";\nconst AuthContext = createContext(null);\nexport const AuthProvider = ({ children }) =\u003e {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const redirectPath = location.state?.path || \"/profile\";\n  const [user, setUser] = useState({\n    username: \"\",\n    permissions: [],\n  });\n  const login = (user) =\u003e {\n    if (user === \"admin\") {\n      setUser({ username: user, permissions: [\"view_extra\"] });\n    } else {\n      setUser({ username: user, permissions: [\"view_about\"] });\n    }\n    navigate(redirectPath, { replace: true });\n  };\n  const logout = () =\u003e {\n    setUser({ username: \"\", permissions: [] });\n  };\n  return \u003cAuthContext.Provider value={(user, login, logout)}\u003e{children}\u003c/AuthContext.Provider\u003e;\n};\nexport const useAuth = () =\u003e {\n  return useContext(AuthContext);\n};\n```\n\n현재 로그인한 사용자와 부여된 권한을 저장하기 위해 사용자라는 상태 변수 객체를 만들었습니다.\n\nlogin() 함수는 사용자 매개변수를 받습니다. 사용자가 관리자이면 할당된 권한은 view_extra가 되고, 그렇지 않으면 view_about이 됩니다. 사용자 이름은 사용자와 동일합니다. 그 후, 페이지를 보려고 시도한 경로 또는 프로필 페이지로 이동합니다.\n\n사용자 변수는 logout()에 의해 클리어됩니다.\n\n우리는 context를 구축하고 user, login, logout 값을 provider를 통해 props로 전달했습니다. 앱 전체에서 어디서든 이를 액세스할 수 있습니다.\n\nAuthentication.js\n\n```js\nimport React from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\nimport { Navigate, useLocation } from \"react-router-dom\";\n\nconst Authentication = ({ children }) =\u003e {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user.username) {\n    return \u003cNavigate to=\"/login\" state={{ path: location.pathname }} /\u003e;\n  }\n\n  return children;\n};\n\nexport default Authentication;\n```\n\nuseAuth()를 통해 사용자 객체에 액세스할 수 있었습니다. username 속성이 없다면 로그인되지 않은 상태로 간주되어 로그인 페이지로 이동합니다. 그 외의 경우에는 요청한 페이지가 표시됩니다.\n\nAuthorization.js\n\n```js\nimport React from \"react\";\nimport { Navigate, useLocation, Outlet } from \"react-router-dom\";\nimport Unauthorized from \"../components/Unauthorized\";\nimport { useAuth } from \"../provider/AuthProvider\";\nconst Authorization = ({ permissions }) =\u003e {\n    const { user } = useAuth();\n    const location = useLocation();\n    if (user.username) {\n        const userpermission = user.permissions;\n        const isAllowed = permissions.some((allowed) =\u003e userpermission.includes(allowed));\n        return isAllowed ? \u003cOutlet /\u003e : \u003cUnauthorized /\u003e;\n    }\n    return \u003cNavigate to=\"/login\" state={ path: location.pathname } replace /\u003e;\n};\nexport default Authorization;\n```\n\n코드를 조각 단위로 해석해 보겠습니다.\n\n당신이 사용자 이름에 따라 권한이 설정되어 있는 것을 염두에 두셨나요? 현재 로그인한 사용자를 통해 해당 권한에 액세스할 수 있게 됐습니다.\n\n권한 획득은 사용자가 로그인했는지에 따라 달라집니다. 현재 로그인한 사용자가 부모 구성 요소를 통해 권한이 부여되었는지 확인하고 싶습니다. 사용자가 권한이 부여된 경우 컴포넌트는 `Outlet/` (하위 라우트)를 렌더링하고, 그렇지 않은 경우 권한이없다는 컴포넌트를 반환합니다.\n\n사용자가 이미 로그인되어 있지 않은 경우 로그인 페이지가 표시됩니다.\n\nRoutepath.js에서\n\n```js\n\u003cRoute element={\u003cAuthorization permissions={[PERMISSIONS.CAN_VIEW_ABOUT]} /\u003e}\u003e\n  \u003cRoute path=\"about\" element={\u003cAbout /\u003e} /\u003e\n\u003c/Route\u003e\n```\n\nAuthorization 컴포넌트를 Route의 element로 전달하여 권한이 포함된 CAN_VIEW_ABOUT을 가진 사용자가 about 페이지를 방문할 수 있습니다.\n\nAuthorization.js에서\n\n```js\nconst Authorization = ({ permissions }) =\u003e {};\n```\n\nRoutePath Component에 의해 권한 prop이 전달되었으며 이 경우 부모이다. 따라서 우리는 이제 해당 prop에 액세스할 수 있습니다.\n\n```js\nconst { user } = useAuth();\n```\n\nuseAuth()를 통해 현재 사용자에 액세스할 수 있습니다.\n\n```js\nif (user.username) {\n  const userpermission = user.permissions;\n  const isAllowed = permissions.some((allowed) =\u003e userpermission.includes(allowed));\n  return isAllowed ? \u003cOutlet /\u003e : \u003cUnauthorized /\u003e;\n}\nreturn \u003cNavigate to=\"/login\" state={{ path: location.pathname }} replace /\u003e;\n```\n\n사용자가 로그인한 경우에는 사용자 이름과 권한 속성에 액세스할 수 있습니다. 우리는 부여한 권한이 로그인한 사용자의 권한을 포함하는지 여부를 결정해야 합니다.\n\n```js\nconst isAllowed = permissions.some((allowed) =\u003e userpermission.includes(allowed));\n```\n\n사용자에게 권한이 있는 경우 (Children Route)이 렌더링되고, 그렇지 않으면 Unauthorized 컴포넌트가 반환됩니다.\n사용자가 이미 로그인하지 않은 경우 로그인 페이지가 표시됩니다.\n\nAbout.js\n\n```js\nimport React from “react\";\nconst About = () =\u003e {\n  return \u003cdiv\u003eAbout Page\u003c/div\u003e;\n};\nexport default About;\n```\n\nExtra.js\n\n```js\nimport React from \"react\";\nconst Extra = () =\u003e {\n  return \u003cdiv\u003eExtra Page\u003c/div\u003e;\n};\nexport default Extra;\n```\n\nHome.js\n\n\n\n\n\n```js\nimport React from \"react\";\nconst Home = () =\u003e {\n    return \u003cdiv\u003e홈 페이지\u003c/div\u003e;\n};\nexport default Home;\n```\n\nLogin.js\n\n```js\nimport React, { useState } from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\nconst Login = () =\u003e {\n  const [user, setUser] = useState(null);\n  const { login } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const redirectPath = location.state?.path || \"\";\n  const handleLogin = () =\u003e {\n    login(user);\n  };\n  return (\n    \u003c\u003e\n      \u003ch1\u003e로그인 페이지\u003c/h1\u003e\n      \u003clabel\u003e이름\u003c/label\u003e\n      \u003cinput type=\"text\" onChange={(e) =\u003e setUser(e.target.value)} /\u003e\n      \u003cbutton type=\"submit\" onClick={handleLogin}\u003e\n        로그인\n      \u003c/button\u003e\n    \u003c/\u003e\n  );\n};\nexport default Login;\n```\n\n우리는 사용자 상태 변수를 생성하고 입력 필드를 추가했습니다. 입력란에 입력된 데이터는 사용자를 위해 보관되며 로그인할 때 전달됩니다.\n\n\n\n\n\nNavbar.js\n\n```js\nimport React from \"react\";\nimport { NavLink } from \"react-router-dom\";\nimport { useAuth } from \"../provider/AuthProvider\";\nexport const Navbar = () =\u003e {\n    const { user } = useAuth();\n    return (\n        \u003cnav\u003e\n            \u003cNavLink to=\"/\"\u003e홈\u003c/NavLink\u003e\n            \u003cNavLink to=\"/about\"\u003e소개\u003c/NavLink\u003e\n            {user.username \u0026\u0026 \u003cNavLink to=\"/profile\"\u003e프로필\u003c/NavLink\u003e}\n            {!user.username \u0026\u0026 \u003cNavLink to=\"/login\"\u003e로그인\u003c/NavLink\u003e}\n            \u003cNavLink to=\"/extra\"\u003e추가\u003c/NavLink\u003e\n        \u003c/nav\u003e\n    );\n};\n```\n\n서로 다른 경로 간 이동이 간단해지도록 navbar를 추가했습니다. 프로필 링크는 로그인한 사용자를 위해 제공되지만, 아직 인증을 받지 않은 사용자에게는 로그인 링크가 표시됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_3.png\" /\u003e\n\n\n![Authentication and Authorization in React](/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_4.png)\n\nProfile.js\n\n```js\nimport React from \"react\";\nimport { useAuth } from \"../provider/AuthProvider\";\n\nconst Profile = () =\u003e {\n  const { user, logout } = useAuth();\n\n  const logoutHandler = () =\u003e {\n    logout();\n  };\n\n  return (\n    \u003c\u003e\n      \u003ch1\u003eWelcome {user.username}\u003c/h1\u003e\n      \u003cbutton type=\"submit\" onClick={logoutHandler}\u003e\n        Logout\n      \u003c/button\u003e\n    \u003c/\u003e\n  );\n};\n\nexport default Profile;\n```\n\n\nWe used useAuth() to access user and logout(). We added a logout button to handle logout operations and displayed the username of the user who is presently logged in.\n\n\n\n\n\nUnauthorized.js\n\n```js\nimport React from \"react\";\nconst Unauthorized = () =\u003e {\n return \u003cdiv\u003e이 페이지를 보기 위한 권한이 없습니다\u003c/div\u003e;\n};\nexport default Unauthorized;\n```\n\nRoutePath.js\n\n```js\nimport React from \"react\";\nimport { Routes, Route } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport About from \"../components/About\";\nimport Login from \"../components/Login\";\nimport Profile from \"../components/Profile\";\nimport Authentication from \"./Authentication\";\nimport Authorization from \"./Authorization\";\nimport PERMISSIONS from \"../permissions/Permissions\";\nimport Extra from \"../components/Extra\";\nconst RoutePath = () =\u003e {\n  return (\n    \u003cRoutes\u003e\n      \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e\n      \u003cRoute element={\u003cAuthorization permissions={[PERMISSIONS.CAN_VIEW_ABOUT]} /\u003e}\u003e\n        \u003cRoute path=\"about\" element={\u003cAbout /\u003e} /\u003e\n      \u003c/Route\u003e\n      \u003cRoute\n        path=\"profile\"\n        element={\n          \u003cAuthentication\u003e\n            \u003cProfile /\u003e\n          \u003c/Authentication\u003e\n        }\n      /\u003e\n      \u003cRoute element={\u003cAuthorization permissions={[PERMISSIONS.CAN_VIEW_EXTRA]} /\u003e}\u003e\n        \u003cRoute path=\"extra\" element={\u003cExtra /\u003e} /\u003e\n      \u003c/Route\u003e\n      \u003cRoute path=\"login\" element={\u003cLogin /\u003e} /\u003e\n    \u003c/Routes\u003e\n  );\n};\nexport default RoutePath;\n```\n\n`Routes` 구성 요소에서 루트를 캡슐화했습니다.\n\n```js\n\u003cRoute\n  path=\"profile\"\n  element={\n    \u003cAuthentication\u003e\n      \u003cProfile /\u003e\n    \u003c/Authentication\u003e\n  }\n/\u003e\n```\n\n접근하기 전에 인증이 필요하기 때문에 `Authentication` 구성 요소로 루트를 래핑했습니다.\n\n```js\n\u003cRoute element={\u003cAuthorization permissions={[PERMISSIONS.CAN_VIEW_EXTRA]} /\u003e}\u003e\n  \u003cRoute path=\"extra\" element={\u003cExtra /\u003e} /\u003e\n\u003c/Route\u003e\n```\n\n또한 인가가 필요한 루트에 대해 인가를 요소로 전달했는데, 이 인가는 권한을 가진 자식 루트들을 감싸는 역할을 했어요. 이 경우 관리자 권한을 가진 사용자만 `Extra /` 컴포넌트를 볼 수 있어요.\n\n아래는 최종 결과물입니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*8u590rCf0gvThvAdNOAqoQ.gif)\n\n그래서, 새로운 것을 배웠나요? 마음대로 바꾸고 실험해보세요. 즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationandAuthorizationinreact_0.png","tag":["Tech"],"readingTime":10}],"page":"138","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"138"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>