<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/138" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 앱 만들기 Create React App 없이" href="/post/2024-05-12-CreateReactAppwithoutCreateReactApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱 만들기 Create React App 없이" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱 만들기 Create React App 없이" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱 만들기 Create React App 없이</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항" href="/post/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 " href="/post/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기" href="/post/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기" href="/post/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요" href="/post/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요" href="/post/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법" href="/post/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="패키지-락json 완전 가이드" href="/post/2024-05-12-package-lockjsonTheCompleteGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="패키지-락json 완전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="패키지-락json 완전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">패키지-락json 완전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션" href="/post/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link posts_-active__YVJEi" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 앱 만들기 Create React App 없이","description":"","date":"2024-05-12 19:42","slug":"2024-05-12-CreateReactAppwithoutCreateReactApp","content":"\n\n\n![이미지](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png)\n\n이 기사는 \"create-react-app\", \"NextJS\" 등의 라이브러리 또는 프레임워크를 사용하지 않고 리액트 앱을 만드는 과정에 대해 이야기합니다.\n\n## 사전 지식 개념\n\n- Webpack — 코드를 하나의 파일로 번들링하는 데 도움을 줍니다.\n- Babel — ECMAScript 2015+ (ES6+) 코드를 이전 JavaScript 엔진에서 실행할 수 있는 하위 호환 버전으로 변환하는 데 사용됩니다.\n- Node.js — 노드 설치, package.json 생성 및 npm을 사용하여 노드 모듈 설치\n\n\n\n\n## 이 기사는 다음 사항을 이해하는 데 도움이 됩니다\n\n- 웹팩(webpack)과 바벨(babel)이 어떻게 실제로 작동하는지;\n- 리액트(React) 앱을 빌드하는 시작부터 끝까지의 흐름;\n- 개발 및 프로덕션 빌드 설정 방법 및 중요성;\n- 필요한 서버 세부 정보 설정;\n- 웹팩(webpack)과 바벨(babel) 구성 파일 작성 및 그곳에 존재하는 논리 이해;\n- 클라이언트 측 및 서버 측 렌더링 구성 방법;\n- React에서 HMR(Hot Module Replacement)이 작동하는 방식 이해.\n\n## 소스 코드\n\n- 리포지토리 — https://github.com/kannanagasamy/react-app-without-cra\n- 브랜치 — main\n\n\n\n더 알아보기:\n\n## 절차\n\n1. 시스템에 node가 설치되어 있는지 확인합니다\n\n시스템에 Node.js를 설치하고 터미널에서 node -v를 입력하여 설치되어 있는지 확인합니다.\n\n\n\n## 2. 프로젝트 폴더 및 package.json 생성하기\n\n아무 이름으로 프로젝트 폴더를 생성하고 해당 폴더로 이동한 후 npm init을 사용하여 폴더 안에 package.json 파일을 생성합니다. 폴더로 이동하세요.\n\n## 3. 웹팩 종속성 설치하기\n\n```js\nnpm i --save-dev webpack webpack-cli webpack-dev-server\n```\n\n\n\n- 웹팩 — 코드를 모두 번들로 묶어 최종 빌드를 생성할 수 있습니다.\n- 웹팩-cli — 개발자가 커스텀 웹팩 프로젝트를 설정할 때 속도를 높이기 위해 유연한 명령 집합을 제공하는 CLI 도구입니다. 웹팩 v4 이상을 사용하고 명령 줄에서 웹팩을 호출하려면 이 도구가 필요합니다.\n- 웹팩-dev-server — 웹팩 개발 서버는 미니 노드.js 익스프레스 서버입니다. SockJS라는 라이브러리를 사용하여 웹 소켓을 흉내냅니다. 로컬호스트 개발 환경을 만들 수 있게 해줍니다.\n\n## 4. Babel 종속성 설치\n\n```js\nnpm i --save-dev babel-loader @babel/preset-env @babel/core \n@babel/plugin-transform-runtime \n@babel/preset-react \n@babel/eslint-parser \n@babel/runtime\n@babel/cli\n```\n\n- babel-loader — JavaScript 파일을 babel과 웹팩을 사용하여 변환할 수 있게 해줍니다. 각 파일에 대한 Babel 구성의 사용자 정의 처리를 추가할 수 있는 로더 빌더 유틸리티를 노출합니다.\n- @babel/preset-env — 해당 환경에 필요한 syntax 변환 및 브라우저 폴리필을 세밀하게 관리하지 않고 최신 JavaScript를 사용할 수 있도록 합니다. 이렇게 함으로써 JavaScript 번들이 더 작아지고 개발자의 작업을 더욱 쉽게 할 수 있습니다!\n- @babel/core — 코어 패키지\n- @babel/plugin-transform-runtime — Babel의 주입된 도우미 코드를 재사용하여 코드 크기를 줄이도록 하는 플러그인\n- @babel/preset-react — Reactjs를 사용할 때 React 프리셋을 사용합니다. HTML 파일을 React 기반 파일로 변환하는 데 도움이 됩니다.\n- babel-eslint — Babel에 의해 변환된 소스 코드에서 ESLint를 실행할 수 있게 하는 파서\n- @babel/runtime — 폴리필 및 다른 Babel이 참조할 수 있는 것들을 포함하는 패키지\n- @babel/cli — Babel을 사용하기 위한 명령 줄 인터페이스\n\n\n\n## 5. 필요한 린터 및 경로 설치하기\n\n```js\nnpm i --save-dev eslint eslint-config-airbnb-base \neslint-plugin-jest \neslint-config-prettier\npath\n```\n\n## 6. 리액트와 리액트 돔 설치하기\n\n```js\nnpm i react react-dom\n```\n\n\n\n## 7. index.html 파일 생성하기\n\n프로젝트의 루트에 \"public\"이라는 폴더를 생성하세요. 그 안에 index.html 파일을 만들어주세요.\n\n## 8. App.js 파일 생성하기\n\nsrc 폴더를 생성하고 그 안에 App.js 파일을 만드세요. 다음 코드를 추가해주세요:\n\n\n\n## 8. index.js 파일 만들기\n\n프로젝트의 루트 또는 원하는 곳에 index.js 파일을 만듭니다. 이 파일은 webpack의 진입점으로 작동할 것입니다.\n\n다음 코드를 추가합니다:\n\n## 9. webpack.config.js 파일 만들기\n\n\n\n프로젝트 루트에 webpack.config.js 파일을 생성하고 다음 코드를 추가하세요. 더 나아가 이 파일은 파일들을 하나의 닠 파일로 번들링하고 개발 서버를 설정하는 구성을 포함하고 있습니다.\n\n코드 내의 주석은 각 줄이 무엇을 하는지 이해하는 데 도움이 됩니다:\n\n## 10. .babelrc 파일 생성\n\n루트에 .babelrc 파일을 생성하고 다음 코드를 추가하세요.\n\n\n\n이것은 Babel을 위한 설정 파일입니다. babel이 내부에 정의된 플러그인과 프리셋을 사용하도록 지시할 것입니다.\n\n## 11. package.json 파일 업데이트\n\n7번째와 8번째 줄에 start 및 build 스크립트를 추가하십시오.\n\n- start 스크립트는 웹팩 개발 서버를 현재 프로젝트의 public 폴더에서 9500 포트로 실행하라는 것입니다.\n- build 명령은 main.js 파일에 이 패키지를 빌드하라는 것입니다. 이는 사실상 webpack.config.js 파일의 모든 논리를 실행합니다.\n\n\n\n## 12. 최종 프로젝트 폴더 구조가 이렇게 되어야 합니다\n\n![프로젝트 폴더 구조](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_1.png)\n\n## 13. \"npm run build\" 실행하기\n\n- 위의 코드를 추가한 후 npm run build를 실행하세요. 이렇게 하면 public 폴더에 main.js 파일이 생성됩니다. 이 파일은 실제로 1MB 이상의 크기를 가지고 있습니다. 이것이 개발용 빌드입니다.\n\n\n\n## 14. \"npm start\" 명령 실행하기\n\n터미널에서 `npm start` 명령을 실행하여 애플리케이션을 시작하세요. 이렇게 하면 개발 서버가 시작됩니다.\n\n코드 전체는 위에서 공유한 저장소 링크에서 찾을 수 있습니다.\n\n# 기타 주요 사항\n\n\n\n## 프로덕션 빌드로 변경하기\n\n- 이제 프로덕션 빌드로 변경해 볼 수 있어요. 이를 위해 webpack.config.js 파일에 다음 변경을 해야 합니다.\n\n```js\nmode: \"production\"\n```\n\n- 이제 npm run build를 실행하면 다시 main.js 파일이 생성되지만 사이즈가 매우 작아질거에요 (`200kb).\n- 1000KB에서 200KB로 최적화되어 더 나은 프로덕션 빌드를 사용하는 것이 좋을 수 있어요. 하지만 개발 중에는 핫 리로딩이 더 빠르기 때문에 개발 모드를 사용해야 해요.\n\n\n\n## 핫 모듈 교체\n\n- HMR은 webpack-dev-server에서 처리됩니다. 페이지 로드 옵션 없이도 HMR을 사용할 수 있습니다. 필요한 옵션을 설정하면 성능 측면에서 큰 도움이 됩니다.\n- 다양한 시나리오에 대한 아래 코드 스니펫을 확인해보세요:\n\n```js\n//HMR을 사용하지만 라이브 리로드를 사용하지 않으려면 webpack.config.js에서 아래 구성을 사용하세요.\ndevServer: {\n        hot: true ,\n        liveReload:false\n    }\n\n//HMR을 사용하고 싶지 않지만 라이브 리로드를 사용하려면,\ndevServer: {\n        hot: false ,\n        liveReload: true\n    },\n\n//라이브 리로드를 사용하고 싶지 않다면,\ndevServer: {\n        hot: false , //이 옵션은 필수로 false로 설정해야 합니다.\n        liveReload: false\n    },\r\n```\n\n## 참고문헌\n\n\n\n- 웹팩의 HMR — https://webpack.js.org/guides/hot-module-replacement/\n- 번들 크기를 줄이는 다양한 방법 — https://blog.jakoblind.no/3-ways-to-reduce-webpack-bundle-size/\n- devserver 이해 및 자세한 작업 방법 — https://webpack.js.org/configuration/dev-server/#devserverlivereload\n- 프로덕션을 위한 번들 최소화 — https://webpack.js.org/plugins/mini-css-extract-plugin/#minimizing-for-production\n- 웹팩을 사용한 프로덕션 사이트 구축 방법 — https://webpack.js.org/guides/production/\n- 완벽한 devpack 서버 설정 — https://linguinecode.com/post/how-to-setup-webpack-dev-server-react-babel\n- 로더 자세히 살펴보기 — https://webpack.js.org/concepts/loaders/\n- babel-preset-env 자세히 이해하기 — https://blog.jakoblind.no/babel-preset-env/\n\n이 글이 도움이 되셨기를 바라며. 다음 글도 기대해주세요.\n\n# 리액트 앱을 레고처럼 재사용 가능한 컴포넌트로 만들기\n\n![이미지](/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_2.png)\n\n\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자가 컴포넌트를 사용하여 앱을 개발할 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 전환하고 애플리케이션 간에 공유하세요. 협업이 더 쉽고 빠르게 개발할 수 있습니다.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 쉽게 만들고 원하는 워크플로에 최상의 경험을 누릴 수 있습니다:\n\n\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n\n\n## 더 알아보기:","ogImage":{"url":"/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png"},"coverImage":"/assets/img/2024-05-12-CreateReactAppwithoutCreateReactApp_0.png","tag":["Tech"],"readingTime":6},{"title":"React 개발을 향상시키는 새로운 훅과 19버전의 개선 사항","description":"","date":"2024-05-12 19:41","slug":"2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19","content":"\n\n![React 19 new features](/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png)\n\n안녕하세요! React 19이 출시되었는데요, 새로운 도구와 개선 사항이 많아져 개발자들에게 일을 더 쉽게 만들어 줍니다. 이 블로그 포스트에서는 무엇이 새로운지 살펴보고 React 개발을 어떻게 더 나아지게 하는지 알아보겠습니다.\n\n새로운 훅 요약:\n- use: 이 새로운 훅은 비동기 데이터 가져오기와 처리를 간단하게 만들어 주어 약속이 해결될 때까지 컴포넌트를 중단할 수 있습니다.\n- useFormStatus: 개발자들은 이제 양식 제출 상태를 효과적으로 추적하여 사용자에게 양식 처리 중 더 나은 피드백을 제공할 수 있습니다.\n- useActionState: 이 훅은 액션 상태를 추적하고 직접적으로 상태를 업데이트할 수 있어 UI 피드백을 강화하고 UI 액션 관리를 향상시킵니다.\n- useOptimistic: 이 훅을 사용하면 낙관적 업데이트를 쉽게 관리할 수 있어 서버로부터 확인을 받기 전에 즉시 변경 사항을 반영할 수 있습니다.\n\n\n\n새로운 훅의 장점:\n\n- 간소화된 비동기 데이터 가져오기: use 훅을 사용하면 구성 요소가 데이터 가져오기가 완료될 때까지 대기하도록 설정하여 프로세스를 최적화하고 사용자 경험을 향상시킵니다.\n- 더 나은 폼 피드백: useFormStatus를 사용하면 개발자가 양식 제출 중에 사용자에게 향상된 피드백을 제공하여 더 직관적인 인터페이스를 제공할 수 있습니다.\n- 동작 상태 추적: useActionState를 활용하면 동작 상태를 직접 제어하며 UI 피드백을 향상시키고 상호 작용을 더 부드럽게 만들 수 있습니다.\n- 낙관적 UI 업데이트: useOptimistic을 활용하면 개발자가 효율적인 서버 동기화로 사용자에게 즉각적인 피드백을 제공하여 원활한 사용자 경험을 만들 수 있습니다.\n\n결론:\nReact 19의 새로운 훅과 개선 사항은 상태 관리, 이벤트 처리, 애플리케이션 성능 향상에 필요한 강력한 도구를 개발자에게 제공합니다. 이벤트 처리를 간소화하고 낙관적 업데이트를 개선하며 동시 렌더링을 더 잘 제어함으로써 React 19는 고성능 애플리케이션 개발의 기반을 마련합니다.\n\n이러한 발전을 통해 개발자는 React 프로젝트를 새로운 수준으로 끌어올려 사용자 경험을 혁신하고 웹 개발에서 혁신을 이끌 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png"},"coverImage":"/assets/img/2024-05-12-EnhancingReactDevelopmentwithNewHooksandImprovementsinVersion19_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs, React 및 TypeScript에서 인증 및 권한 부여 방법 ","description":"","date":"2024-05-12 19:37","slug":"2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2","content":"\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png\" /\u003e\n\n# 소개\n\n이것은 웹 애플리케이션에서 사용자 인증 및 권한을 구현하는 두 부분 튜토리얼의 두 번째 기사입니다.\n\n튜토리얼의 첫 번째 부분은 현대 웹 애플리케이션 내에서 인증 및 권한의 개념을 설명하는 데 전념되었습니다. 아직 보지 않았다면, 진행하기 전에 첫 번째 부분을 확인하는 것을 추천합니다.\n\n기초를 다룬 기초를 바탕으로, React, Node.js 및 TypeScript를 사용하여 토큰 기반 사용자 인증 및 권한 부여를 하는 풀 스택 시스템을 단계별로 구현할 것입니다. 이 튜토리얼의 완전한 코드베이스를 이 GitHub 저장소에서 찾을 수도 있습니다. 먼저 다음 섹션에서 프로젝트 구조에 익숙해져 봅시다.\n\n# 프로젝트 구조\n\n![프로젝트 구조](/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_1.png)\n\n위의 그림 1에서 전체 풀 스택 프로젝트 구조가 나와 있습니다. 서버 및 사용자 인터페이스(UI) 내 각 구성 요소의 목적에 대해 논의해 봅시다.\n\n## 사용자 인터페이스\n\n사용자 인터페이스는 매우 기본적이며, 프레젠테이션 레이어의 Auth 컴포넌트로 구성됩니다. 사용자는 이러한 컴포넌트와 상호작용하여 사용자 지정 후크 useApi 및 ApiProvider 클래스를 통해 서버에 인증을 요청합니다. 서버가 사용자가 제출한 자격 증명을 유효성 검사하면 응답 내에서 JWT 토큰을 반환합니다. 유효한 서버 응답시, 컴포넌트로부터 AuthReducer로 작업이 디스패치됩니다. 디스패치된 작업은 관련 AuthState로 줄어들고, AuthContext를 통해 전체 어플리케이션 인터페이스에 제공됩니다. 사용자 인터페이스는 React 및 TypeScript를 사용하여 구현될 것입니다.\n\n## 서버\n\n서버는 인터페이스에서 사용자 자격 증명 데이터와 함께 요청을 받게 될 것입니다. 먼저 Cors(Cross-Origin-Resource-Sharing) 규칙을 위반하지 않는지 확인하고 제출된 입력 데이터가 유효한지를 검증할 것입니다. 이러한 단계 중 하나라도 통과하지 못하면 오류 응답이 반환됩니다. 사용자 인증은 사용자/가입 route에서 새로운 사용자가 생성되거나 사용자/로그인 route에서 기존 사용자가 인증됩니다. 이 프로젝트에서는 InMemoryDataProvider가 구현되며 사용자 데이터는 간단한 객체에 저장됩니다. 이는 튜토리얼이 복잡해지지 않도록 의도된 것이며 사용자 인증 및 권한 부여에 중점을 두었습니다. DataProviderInterface는 데이터 검색 기능을 추상화하기 위해 사용되며, 나중에 이를 구현하는 다른 제공자로 쉽게 전환할 수 있도록 설계되었습니다. 사용자가 가입 또는 로그인을 성공적으로 완료하면 서명된 서버와 함께 만료 가능한 JWT(JSON Web Token)가 생성되어 사용자 인터페이스로 반환됩니다. 이 토큰, 일반적으로 인증 토큰으로 알려져 있으며, 사용자 인터페이스에서 /resource 엔드포인트를 통해 보호된 서버 측 리소스에 액세스하기 위해 요청에 포함됩니다.\n\n# 사전 준비 사항\n\n이 튜토리얼을 성공적으로 완료하기 위한 전제 조건 목록은 다음과 같습니다:\n\n- 해당 튜토리얼을 완료하려면 컴퓨터에 Node.js가 설치되어 있어야 합니다.\n- Node Package Manager (NPM)은 Node.js가 설치되어 있으면서 Yarn을 선호하며 프로젝트 종속성 관리에는 Yarn이 사용될 것입니다.\n- 웹이 작동하는 방식에 대한 알맞은 지식이 있어야 하며 인증 및 권한 부여 시스템을 구현한 시스템을 사용하거나 본적이 있어야 합니다.\n- 본 문서 이전에 Node.js, React 및 Typescript와 함께 작업한 경험이 있어야 하지만, 코드 안내를 받을 예정이므로 심층적인 지식은 선택 사항입니다.\n\n자, 소개는 이제 끝내고 실제 프로젝트 구현으로 넘어가 봅시다. 멋지네요! 😁\n\n# 1. 서버 설정\n\n## 1.1 의존성 설치\n\n먼저 다음 명령어를 사용하여 프로젝트 디렉토리를 만들고 서버 코드 기반을 설정해보겠습니다:\n\n```js\nmkdir authentication-and-authorization \u0026\u0026\\\ncd authentication-and-authorization \u0026\u0026\\\nmkdir server \u0026\u0026\\\ncd server \u0026\u0026 mkdir src\n```\n\n시작 서버 폴더 구조는 아래와 같이 표시됩니다:\n\n```bash\n/authentication-and-authorization\n  |__ /server\n      |__ /src\n```\n\n/server 폴더 안에 있는 터미널에서 다음 명령어를 실행하여 노드 프로젝트를 초기화하세요:\n\n```bash\nnpm init -y\n```\n\n이제 서버 프로젝트의 시작점이 있으니 다음 명령어를 사용하여 Typescript 프로젝트로 설정하겠습니다:\n\n```js\nyarn add typescript @types/node --dev \u0026\u0026 npx tsc --init\n```\n\n위 명령은 /server 폴더 안에 tsconfig.json 파일을 생성했을 겁니다. 해당 파일의 내용을 아래 코드와 같이 변경해주세요:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"es2016\",\n    \"module\": \"commonjs\",\n    \"rootDir\": \"./src\",\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\n가장 중요한 설정은 rootDir입니다. 이 설정은 TypeScript 컴파일러에게 .ts 파일을 어디에서 찾아 .js 파일로 변환하고 outDir로 지정된 디렉토리에 배치해야 하는지 알려줍니다.\n\n이제 서버에 필요한 초기 패키지 종속성을 설치하겠습니다:\n\n```js\nyarn add express dotenv cors \u0026\u0026\\\nyarn add @types/express @types/dotenv @types/cors --dev\n```\n\n3rd party 패키지에 대한 타입 정의 파일도 개발 종속성으로 설치했다는 것에 유의하세요.\n\n## 1.2 Express 서버 만들기\n\n먼저 Express 서버의 기본 구조를 생성하고 본 강좌를 통해 이를 확장해 나갈 것입니다. /server/src 디렉토리 안에서 다음 명령을 실행하여 app.ts와 index.ts를 생성하세요:\n\n```js\ntouch app.ts \u0026\u0026 touch index.ts\n```\n\napp.ts 안에는 서버 환경 변수를 초기화하고 관련 미들웨어를 사용하여 Express 앱 객체를 생성할 것입니다. app.ts의 내용은 아래와 같습니다 (이것은 해당 파일의 최종 코드가 아닙니다):\n\n```js\n/* app.ts */\n\n// 전역 종속성\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수를 초기화합니다\n\n// 프로젝트 종속성\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// 미들웨어\napp.use(express.json());\n\n// 라우트\napp.use(routes);\n\nexport default app;\n```\n\nindex.ts에서는 아래와 같이 SERVER_PORT 환경 변수로 지정된 포트에서 express 서버를 실행할 것입니다:\n\n```js\n/* index.ts */\n\n// 프로젝트 종속성\nimport app from \"./app\";\nconst { SERVER_PORT } = process.env;\n\n// 앱이 listening중\napp.listen(SERVER_PORT, () =\u003e {\n  console.info(`앱이 포트 ${SERVER_PORT}에서 실행 중입니다`);\n});\n```\n\nGit에서 무시될 수 있는 .env 파일에 프로젝트 환경 변수를 지정하는 것은 좋은 관행입니다. 이 파일은 /server폴더에 생성할 것입니다:\n\n```js\n# .env\n\nSERVER_PORT=8000\n```\n\n익스프레스 서버를 실행하려면 /server 폴더 내에서 다음 명령을 실행할 수 있습니다:\n\n```js\nrm -rf ./dist \u0026\u0026 npx tsc \u0026\u0026 cp .env ./dist/.env \u0026\u0026 cd ./dist \u0026\u0026 node index.js\n```\n\n위 명령은 먼저 ./dist 디렉토리를 제거하고, ./src 디렉토리에 있는 모든 코드를 타입 확인하고 ./dist 디렉토리 내의 JavaScript로 변환합니다. 컴파일 단계가 완료되면 .env 파일이 ./dist 디렉토리로 복사되어 서버를 node index.js로 실행할 때 환경 변수가 올바르게 초기화됩니다. 매번 이 명령을 실행하는 것은 지루할 수 있으므로 server/package.json 내에 몇 가지 스크립트를 만들어 프로세스를 단순화하겠습니다:\n\n\n\n\n\n```json\n{\n  \"name\": \"server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"npx tsc \u0026\u0026 cp .env ./dist/.env\",\n    \"start\": \"rm -rf ./dist \u0026\u0026 yarn build \u0026\u0026 cd ./dist \u0026\u0026 node index.js\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@types/cors\": \"^2.8.13\",\n    \"@types/dotenv\": \"^8.2.0\",\n    \"@types/express\": \"^4.17.15\",\n    \"@types/node\": \"^18.11.18\",\n    \"typescript\": \"^4.9.4\"\n  },\n  \"dependencies\": {\n    \"cors\": \"^2.8.5\",\n    \"dotenv\": \"^16.0.3\",\n    \"express\": \"^4.18.2\"\n  }\n}\n```\n\n이제 start 스크립트를 사용하여 아래와 같이 서버를 실행할 수 있습니다:\n\n```bash\nyarn start\n```\n\n![이미지](/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_2.png)\n\n\n\n\n\n서버 프로젝트가 이제 설정되었습니다. 다음 섹션에서는 백엔드 인증 및 권한 시스템 설정 과정을 보여드릴 것입니다.\n\n## 1.3 사용자 데이터 제공자\n\n데이터 저장 레이어는 인증 시스템에 필수적입니다. 새 사용자가 생성될 때, 그들의 데이터는 유지되어야 합니다. 나중에 로그인할 때 사용자가 제출한 자격 증명을 확인할 수 있도록 합니다. 간단히 말해서, 사용자 데이터 저장을 위해 인메모리 저장을 구현할 것이지만, 나중에 실제 데이터베이스로 구현을 교체하는 것이 쉽도록 인터페이스를 사용하여 구현할 것입니다.\n\n/server/src/data_providers 폴더를 생성하고 아래와 같이 인터페이스 IDataProvider를 정의할 것입니다.\n\n\n\n```js\n// server/src/data_providers/IDataProvider.ts\n\nexport default interface IDataProvider\u003cResource\u003e {\n  createData: (resource: Resource) =\u003e Promise\u003cvoid\u003e;\n  readData: (args: {id: string, matchField: string}) =\u003e Promise\u003cResource\u003e;\n  updateData: (args: {id: string, resource: Resource}) =\u003e Promise\u003cvoid\u003e;\n  deleteData: (id: string) =\u003e Promise\u003cvoid\u003e;\n}\n```\n\n이 인터페이스는 일반적인 CRUD 작업을 나타내는 네 가지 메서드로 구성되어 있습니다. 이 메서드들은 Resource 타입의 일반적인 값을 소비하거나 반환합니다. IDataProvider의 InMemoryDataProvider 구현은 아래와 같이 보여집니다.\n\n```js\n// server/src/data_providers/InMemoryDataProvider.ts\n\nimport IDataProvider from \"./IDataProvider\";\n\nexport default class InMemoryDataProvider\u003cResource extends {id: string, data: any}\u003e implements IDataProvider\u003cResource\u003e {\n  private _data: Resource[];\n\n  constructor() {\n    this._data = [];\n  };\n\n  public async createData(resource: Resource) {\n    this._data.push(resource);\n    return;\n  }\n\n  public async readData(args: {id: string, matchField: string}) {\n    return this._data.filter(x =\u003e x.data[args.matchField] === args.id)[0];\n  };\n\n  public async updateData(props: { id: string; resource: Resource; }) {\n    const {id, resource} = props;\n    for(const datum of this._data) {\n      if(datum.id === id) {\n        datum.data = resource.data;\n      }\n    }\n\n    return;\n  };\n\n  public async deleteData(id: string) {\n    this._data = this._data.filter(datum =\u003e datum.id !== id);\n    return;\n  };\n}\n```\n\nInMemoryDataProvider는 IDataProvider에서 정의된 공개 메서드를 엄격하게 구현합니다. 실제 데이터 저장소는 InMemoryDataProvider 클래스 인스턴스에 특정한 private \\_data 배열 속성입니다. InMemoryDataProvider의 generic 타입은 Resource이며 'id: string, data: any'를 확장하였기 때문에 입력 자원은 id 및 데이터를 포함하고 기타 속성을 추가로 가져야합니다. TypeScript의 이 인터페이스 중심적 접근의 장점은 IDataProvider 인터페이스를 준수한다면 데이터 저장소를 다른 구현체로 쉽게 교체할 수 있다는 점입니다(예: SQL 데이터베이스 사용).\n\n사용자 관련 데이터에서 CRUD 작업을 실행하기 위해 비즈니스 로직을 데이터 액세스 계층에서 분리하는 사용자 저장소를 추가로 생성할 것입니다. 먼저, 다음과 같이 정의된 추상화 Repository를 작성할 것입니다. 이 Repository는 다양한 데이터 소스 유형에서 확장될 수 있는 인터페이스를 정의합니다.\n\n```js\n// server/src/repositories/Repository.ts\n\nimport IDataProvider from \"../data_providers/IDataProvider\";\n\nexport default class Repository\u003cResource\u003e {\n  protected _provider: IDataProvider\u003cResource\u003e;\n\n  constructor(args: {provider: IDataProvider\u003cResource\u003e}) {\n    this._provider = args.provider;\n  };\n\n  public get provider(): IDataProvider\u003cResource\u003e {\n    return this._provider;\n  }\n}\n```\n\nRepository에서 파생된 클래스는 데이터 액세스 계층을 형성하는 IDataProvider를 구현하는 제공자(provider)를 가져야 합니다. 그리고 UserRepository 클래스는 Repository를 확장하고 사용자 데이터와 상호작용하는 자체 public 메서드를 갖습니다. 아래에서 자세히 살펴봅시다.\n\n```js\n// server/src/repositories/UserRepository.ts\n\nimport IDataProvider from \"../data_providers/IDataProvider\";\nimport Repository from \"./Repository\";\nimport { randomUUID } from \"crypto\";\nimport InMemoryDataProvider from \"../data_providers/InMemoryDataProvider\";\n\ntype UserData = {\n  email: string,\n  name: string,\n  password: string,\n  createdAt: string,\n  updatedAt: string\n};\n\nexport class UserResource {\n  private _id: string;\n\n  constructor(private _data: UserData) {\n    this._id = randomUUID();\n  };\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public get data(): UserData {\n    return this._data;\n  }\n}\n\nexport class UserRepository extends Repository\u003cUserResource\u003e {\n  constructor(args: {provider: IDataProvider\u003cUserResource\u003e}) {\n    super({provider: args.provider});\n  }\n\n  public async createUser(user: UserResource) {\n    await this.provider.createData(user);\n    return;\n  }\n\n  public async getUserBy(args: {id: string, matchField: string}) {\n    return this.provider.readData({id: args.id, matchField: args.matchField});\n  }\n}\n\nconst dataProvider = new InMemoryDataProvider\u003cUserResource\u003e();\nconst userRepository = new UserRepository({provider: dataProvider});\n\nexport default userRepository;\n```\n\n사용자 데이터의 구조는 UserData 유형에 의해 정의되며, 리소스 구조는 UserResource 클래스에 의해 정의됩니다. 이 클래스는 id 및 data 공개 속성으로 구성되어 있습니다. 또한, creatUser 및 getUserBy 메서드는 데이터 액세스 레이어와 상호 작용하여 데이터를 검색하고 쓰기 위해 IDataProvider의 구현을 통해 사용됩니다.\n\n참고: 우리는 InMemoryDataProvider의 인스턴스를 사용하여 UserRepository의 인스턴스를 생성합니다. 나중에 데이터를 데이터베이스에 저장하려면, InMemoryDataProvider 대신 IDataProvider 인터페이스를 구현하는 다른 클래스를 사용할 수 있습니다. 우리는 이제 UserRepository를 사용하여 사용자 등록 및 로그인 API 엔드포인트의 비즈니스 논리에서 사용할 수 있습니다. 이는 다음 섹션에서 설명될 것입니다.\n\n## 1.3 사용자 등록 및 로그인을 위한 라우트\n\n다음으로, express 라우트를 모두 보관할 폴더를 생성할 것입니다. 터미널에서 아래 명령어를 입력하세요:\n\n```js\nyarn add bcrypt jwt \u0026\u0026\\\nyarn add @types/bcrypt @types/jwt --dev \u0026\u0026\\\ncd server/src \u0026\u0026\\\nmkdir routes \u0026\u0026\\\ncd ./routes \u0026\u0026\\\ntouch index.ts user.ts\n```\n\n알림: 추가적으로 npm 패키지 bcrypt 및 jwt를 서버 프로젝트 내에 설치했습니다. 사용자 비밀번호를 암호화하는 데 bcrypt를 사용하고, 성공적인 사용자 등록 및 로그인 요청에 대한 응답에 반환될 인증 토큰을 생성하기 위해 jwt를 사용할 것입니다. /server 내부의 폴더 구조는 아래와 같이 표시됩니다:\n\n```js\n/server\n  |__ /src\n      |__ ...\n      |__ /routes\n        |__ index.ts\n        |__ user.ts\n```\n\nindex.ts 내에서는 응용 프로그램의 모든 가능한 경로를 포함하는 중앙 라우터를 만들 것입니다. 현재는 등록 및 로그인을 위한 특정 /user 경로만 가질 것입니다.\n\n```js\n// server/src/routes/index.ts\n\n// 전역 종속성\nimport { Router } from \"express\";\nconst router = Router();\nimport userRoute from \"./user\";\n\n// API에 대한 모든 라우트\nrouter.use(\"/user\", userRoute);\n\nexport default router;\n```\n\nuserRoute는 다음과 같이 user.ts에 구현되어 있습니다.\n\n```js\n// server/src/routes/user.ts\n\n// 전역 종속성\nconst { ENCRYPTION_KEY, AUTH_TOKEN_KEY } = process.env;\nimport {Router} from 'express';\nconst userRoute = Router();\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\n\n// 프로젝트 종속성\nimport {UserResource} from '../repositories/UserRepository';\nimport { validateHasParameters, validateEmailFormat, validatePasswordLength } from \"../middleware/validation\";\nimport userRepository from '../repositories/UserRepository';\n\n/**\n * 이메일, 비밀번호 및 이름을 입력하여 사용자 등록\n */\nuserRoute.post(\n  \"/register\",\n  validateHasParameters(\"email\", \"password\", \"name\"),\n  validateEmailFormat,\n  validatePasswordLength,\n  async (req, res) =\u003e {\n    const { name, email, password } = req.body;\n    try {\n      const userExist = await userRepository.getUserBy({id: email, matchField: 'email'});\n      if (userExist) {\n        return res.status(409).json({ error: \"User already exist\" });\n      }\n\n      const date = new Date().toISOString();\n\n      // 사용자 비밀번호 암호화\n      const passwordHash = await bcrypt.hash(password, ENCRYPTION_KEY!);\n\n      // 사용자 정보와 만료 날짜로 인증 토큰 생성\n      const userData = {\n        name: name,\n        email: email,\n        password: passwordHash,\n        createdAt: date,\n        updatedAt: date,\n      };\n      const newUser = new UserResource(userData);\n\n      // 사용자 데이터 저장\n      await userRepository.createUser(newUser);\n\n      const jwtOptions = {\n        expiresIn: '24h',  // 24시간 후 토큰 만료\n      };\n\n      const authToken = jwt.sign(newUser.data, AUTH_TOKEN_KEY!, jwtOptions);\n\n      return res.status(200).json({\n        success: true,\n        user: {\n          user_id: newUser.id,\n          email: newUser.data.email,\n          name: newUser.data.name,\n          auth_token: authToken,\n        },\n      });\n    } catch (error) {\n      console.error(error);\n      return res.status(500).json({ error: `내부 오류` });\n    }\n  }\n);\n\n/**\n * 입력된 이메일과 비밀번호를 사용하여 사용자 로그인 세션 인증\n */\nuserRoute.post(\n  \"/login\",\n  validateHasParameters(\"email\", \"password\"),\n  async (req, res) =\u003e {\n    const { email, password } = req.body;\n\n    try {\n      // 사용자 존재 여부 및 제공된 비밀번호가 올바른지 확인\n      const user = await userRepository.getUserBy({id: email, matchField: 'email'});\n      const userExists = !!user;\n      const passwordCorrect = userExists \u0026\u0026 (await bcrypt.compare(password, user.data.password));\n      if(userExists \u0026\u0026 passwordCorrect) {\n\n        const jwtOptions = {\n          expiresIn: '24h',  // 24시간 후 토큰 만료\n        };\n\n        const authToken = jwt.sign(user.data, AUTH_TOKEN_KEY!, jwtOptions);\n\n        return res.status(200).json({\n          success: true,\n          user: {\n            user_id: user.id,\n            email: user.data.email,\n            name: user.data.name,\n            auth_token: authToken,\n          },\n        });\n      }\n\n      return res.status(400).json({error: '잘못된 인증 정보'});\n    } catch (error) {\n      console.error(error);\n      return res.status(500).json({ error: `서버 오류` });\n    }\n  }\n);\n\nexport default userRoute;\n```\n\nPOST /user/register 엔드포인트에서는 요청 본문에 이름, 이메일 및 비밀번호 세 개의 매개변수를 받습니다. 사용자가 이메일을 통해 존재하는지 확인한 후, 참이면 오류를 반환합니다. 그런 다음 저장을 위해 사용자 관련 데이터 userData를 생성하며, 제공된 비밀번호는 이전에 설치한 bcrypt를 사용하여 ENCRYPTION_KEY로 암호화됩니다. 사용자 데이터의 지속성은 userRepository.createUser를 사용하여 수행하며, 사용자 생성이 성공하면 24시간 만료 기간이 있는 JWT 토큰이 초기화됩니다. JWT 토큰은 이전에 설치한 jwt를 사용하여 AUTH_TOKEN_KEY로 서명되며 사용자 관련 데이터를 포함합니다. 브라우저가 서버 응답을 받으면 이 JWT 토큰이 프론트엔드에 저장됩니다.\n\n\n\n\n\nPOST /user/login 엔드포인트에서는 요청 본문 내 email과 password 세 개의 매개변수를 받습니다. 먼저 사용자가 실제로 존재하는지 확인하고 제공된 비밀번호가 해당 사용자 이메일에 대해 찾은 복호화된 비밀번호와 일치하는지 확인합니다. 성공적인 사용자 유효성 검사 후, 동일한 JWT 서명 프로세스가 반복됩니다.\n\n/register 및 /login 엔드포인트에 대한 사용자 입력 유효성 검사용 미들웨어도 구현했다는 것을 알았을 겁니다. 다음 명령어를 사용해 /middleware 디렉토리와 그 안에 validation.ts 파일을 생성해 보세요.\n\n```js\ncd server/src \u0026\u0026\\\nmkdir middleware \u0026\u0026\\\ntouch validation.ts\n```\n\nvalidation.ts 파일에서는 사용자 입력을 검증하기 위한 함수들을 정의할 것입니다.\n\n```js\n// server/src/middleware/validation.ts\n\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const validateHasParameters = (...args: string[]) =\u003e {\n  return (req: Request, res: Response, next: NextFunction) =\u003e {\n    const body = req.body;\n    let valid = true;\n\n    for (const arg of args) {\n      if (body[arg] === undefined) {\n        res.status(403).json({ error: arg + \" not specified\" });\n        valid = false;\n        break;\n      }\n    }\n\n    if (valid) {\n      next();\n    }\n  };\n};\n\nexport const validatePasswordLength = (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { password } = req.body;\n  if (!!password \u0026\u0026 password.length \u003e 7) {\n    next();\n  } else {\n    res.status(403).json({ error: \"The password provided is not valid\" });\n  }\n};\n\nexport const validateEmailFormat = (req: Request, res: Response, next: NextFunction) =\u003e {\n  const { email } = req.body;\n  const re =\n    /^(([^\u003c\u003e()[\\]\\\\.,;:\\s@\"]+(\\.[^\u003c\u003e()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  if (!!email \u0026\u0026 re.test(String(email).toLowerCase())) {\n    next();\n  } else {\n    res.status(403).json({ error: \"The email provided is not valid\" });\n  }\n};\n```\n\nvalidateHasParameter은 모든 POST 요청에 사용되며 특정 매개변수가 제출되었는지 확인합니다. validatePasswordLength 및 validateEmailFormat 미들웨어는 /user/register 엔드포인트에서 요청에 대해 유효한 비밀번호 길이와 이메일 형식을 보장하는 데 사용됩니다.\n\n마지막으로, app.ts에서 routes를 사용하여 루터를 express 앱에 연결해야 합니다. 아래에 표시된대로 routes를 파일 맨 위에서 가져오는 것에 유의하십시오.\n\n```js\n/* app.ts */\n\n// 전역 종속성\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수 초기화\n\n// 프로젝트 종속성\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// 미들웨어\napp.use(express.json());\n\n// 라우터\napp.use(routes);\n\nexport default app;\n```\n\n이제 사용자가 방금 만든 엔드포인트를 사용하여 등록하고 로그인할 수 있습니다. 다음 섹션에서는 서버 측에서 보호된 리소스에 대한 사용자 권한 추적을 다룰 것입니다.\n\n## 1.4 사용자 권한\n\n사용자 권한은 인증된 사용자가 보호된 서버 리소스에 액세스하려고 시도하는 프로세스입니다. 이를 위해서는 사용자 등록 또는 로그인 이벤트에서 생성된 토큰이 사용자 브라우저 세션에서 시작된 모든 요청에 첨부되어야 합니다. 토큰은 각 사용자의 브라우저 세션에서 사용된 AUTH_TOKEN_KEY와 같은 것으로 확인될 것입니다. 앞으로 토큰이 요청과 함께 전달되는 방법을 나준에 다룰 것이며, 지금은 서버 측에서 미들웨어 사용자 권한을 구현할 것입니다.\n\n서버/src/middleware 디렉토리 안에 auth.ts라는 추가 파일을 만들 것입니다.\n\n```js\ncd server/src/middleware \u0026\u0026 touch auth.ts\n```\n\nauth.ts 파일 안에는 들어오는 요청을 가로채고 토큰 유효성 검사 프로세스를 수행하는 checkAuthToken 미들웨어를 정의할 것입니다.\n\n```js\n// server/src/middleware/auth.ts\n\n// 전역 의존성\nimport jwt, { JwtPayload } from 'jsonwebtoken';\nconst { AUTH_TOKEN_KEY } = process.env;\n\n// 프로젝트 의존성\nimport userRepository from '../repositories/UserRepository';\n\nexport const checkAuthToken = async (req: any, res: any, next: any) =\u003e {\n  const auth_token = req.headers[\"x-access-token\"] as string;\n\n  try {\n    if (!auth_token) {\n      throw new Error('Unauthorized');\n    }\n\n    const decodedUserInfo = jwt.verify(auth_token, AUTH_TOKEN_KEY!) as JwtPayload;\n    // 사용자가 실제로 데이터베이스에 존재하는지 확인\n    const user = await userRepository.getUserBy({ id: decodedUserInfo.email, matchField: 'email' });\n    if(!user) {\n      throw new Error('Unauthorized');\n    }\n\n    req.user = {...user.data, ...decodedUserInfo};\n  } catch (error) {\n    return res.status(403).json({error: 'Unauthorized'});\n  }\n\n  return next();\n};\n```\n\n확인할 토큰은 요청 헤더 X-ACCESS-TOKEN 안에 포함될 것입니다. 추출된 토큰은 AUTH_TOKEN_KEY를 사용하여 검증되며, 해당 데이터 페이로드는 decodedUserInfo에 할당될 것입니다. 그런 다음 제출된 토큰의 유효성을 보장하기 위해 데이터 저장소에 사용자가 실제로 존재하는지 추가로 확인할 것입니다. 토큰 유효성 검사에 실패하면 403 오류 'Unauthorized' 메시지로 응답할 것입니다.\n\n인증 논리를 테스트하려면 보호된 서버 리소스를 흉내 내는 더미 /resource API 엔드포인트를 설정할 수 있습니다. 먼저 다음 명령을 사용하여 resource.ts 파일을 만듭니다.\n\n```js\ncd server/src/routes \u0026\u0026 touch resource.ts\n```\n\nresource.ts 파일의 내용은 간단하며 단일 GET 엔드포인트로 구성되어 일부 정적 HTML을 반환합니다.\n\n```js\n// server/src/routes/resource.ts\n\nimport { Router } from \"express\";\nconst resourceRoute = Router();\n\nresourceRoute.get(\"/\", async (req, res) =\u003e {\n  return res.status(200).send(\"\u003ch1\u003eYou have successfully access resource!\u003c/h1\u003e\");\n});\n\nexport default resourceRoute;\n```\n\nserver/src/routes/index.ts 파일 안에 /resource 엔드포인트를 아래와 같이 추가할 수 있습니다.\n\n```js\n// server/src/routes/index.ts\n\n// 전역 의존성\nimport { Router } from \"express\";\nconst router = Router();\nimport userRoute from \"./user\";\nimport resourceRoute from \"./resource\";\nimport { checkAuthToken } from \"../middleware/auth\";\n\n// API에 대한 모든 라우트\nrouter.use(\"/user\", userRoute);\nrouter.use(\"/resource\", checkAuthToken, resourceRoute);\n\nexport default router;\n```\n\n또한 checkAuthToken 미들웨어를 import하고 /resource 엔드포인트와 연결했습니다. 이를 통해 해당 엔드포인트로 들어오는 모든 요청이 토큰 권한 부여를 위해 유효성을 검사받도록 됩니다.\n\n## 1.5 CORS 구현\n\n앞서 말한 튜토리얼의 제1부에서는 CORS 규칙이 서버에 의해 지정되어 특정 출처 도메인으로부터의 요청을 허용할 수 있도록합니다. 이를 위해 외부 패키지인 cors를 사용할 것이며, 따라서 다음 명령을 사용하여 먼저 서버 프로젝트에 추가해야합니다.\n\n```js\ncd server \u0026\u0026 yarn add cors \u0026\u0026 yarn add @types/cors --dev\n```\n\n실제 CORS 규칙은 다음과 같이 서버/src/app.ts에서 미들웨어로 지정됩니다.\n\n```js\n/* app.ts */\n\n// global dependencies\nimport * as dotenv from \"dotenv\";\ndotenv.config(); // 로컬 .env 파일을 사용하여 환경 변수를 초기화합니다.\nimport cors from \"cors\";\n\n// project dependencies\nimport routes from \"./routes\";\n\n// express 앱 설정\nimport express from \"express\";\nconst app = express();\n\n// CORS 설정\napp.use(\n  \"/\",\n  cors({\n    origin: true, // 참고: 여기서 모든 출천을 허용하고 있습니다.\n    optionsSuccessStatus: 200,\n    preflightContinue: false,\n    methods: \"GET,POST,OPTIONS\",\n    credentials: true,\n  })\n);\n\n// 미들웨어\napp.use(express.json());\n\n// 라우트\napp.use(routes);\n\nexport default app;\n```\n\n가장 중요한 설정은 origin: true로 설정해야 합니다. 이 설정은 모든 도메인에서의 요청을 허용합니다. 이 설정은 로컬 개발에 충분하지만 운영 환경에서는 프로젝트별 도메인 목록에서 요청을 허용해야 합니다.\n\n이제 서버에 필요한 모든 작업을 완료했습니다. 다음에는 사용자가 서버 애플리케이션과 상호 작용하는 방법을 보여주기 위해 프론트엔드 로그인 폼을 구현할 것입니다.\n\n# 2. 사용자 인터페이스 설정\n\n## 2.1 종속성 설치\n\n사용자 인터페이스에 대해 우리는 React 코드를 호스팅하기 위해 ./authentication-and-authorization 폴더에 별도의 폴더를 만들 것입니다:\n\n```js\nmkdir ui \u0026\u0026 cd ui\n```\n\n/ui 디렉토리 내에서 Typescript를 활성화한 React 프로젝트를 설정하기 위해 다음 명령을 실행하십시오:\n\n```js\nyarn create react-app ./ --template typescript\n```\n\n설치 프로세스가 완료되면 '/ui' 폴더 내 불필요한 파일들을 정리하고 아래에 표시된 디렉토리와 동일하게 보이도록 조정할 것입니다:\n\n```js\n/ui\n  |__ /node_modules\n      |__ ...\n  |__ /public\n      |__ favicon.ico\n      |__ index.html\n      |__ logo192.png\n      |__ logo512.png\n      |__ manifest.json\n      |__robots.txt\n  |__ /src\n      |__ App.css\n      |__ App.tsx\n      |__ index.css\n      |__ index.tsx\n      |__ react-app-env.d.ts\n  |__ .gitignore\n  |__ package.json\n  |-- README.md\n  |__ tsconfig.json\n  |__ yarn.lock\n```\n\nindex.tsx와 App.tsx에서 불필요한 코드와 잘못된 import를 제거하여 아래에 표시된 파일과 동일하게 만들어야 합니다:\n\n```js\n/* index.tsx */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cApp /\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\n```js\n/* App.tsx */\n\nimport \"./App.css\";\n\nfunction App() {\n  return \u003cdiv className=\"App\"\u003e안녕\u003c/div\u003e;\n}\n\nexport default App;\n```\n\n좋은 소식은 사용자 인터페이스에 대한 모든 설정이 완료되었으며 이제 실제 리액트 애플리케이션을 만들 준비가 되었다는 것입니다!\n\n## 2.2 전역 인증 상태 관리\n\n어플리케이션이 동작하려면 인터페이스가 사용자의 인증 상태에 대해 알아야 합니다. 이를 React Context와 useReducer 훅을 사용하여 전역 상태로 관리할 것입니다. 먼저 ui/src/ 안에 전역 인증 상태를 위한 스토어 디렉토리를 생성합니다:\n\n\n\n\n\n```js\ncd ui/src \u0026\u0026\\\nmkdir store \u0026\u0026\\\ncd store \u0026\u0026 mkdir auth \u0026\u0026\\\ntouch authAction.ts AuthContextProvier.tsx authReducer.ts\n```\n\nauthAction.ts는 사용자가 인터페이스 내에서 트리거할 수 있는 가능한 액션을 포함하고 있습니다:\n\n```js\n/* ui/src/store/auth/authActions.ts */\n\nexport enum AuthActionEnum {\n  LOG_IN = 'LOG_IN',\n  LOG_OUT = 'LOG_OUT',\n};\n\nexport type AuthAction = {\n  type: AuthActionEnum.LOG_IN,\n  payload: {\n    authToken: string;\n    userId: string;\n    email: string;\n    name: string;\n  }\n} | {\n  type: AuthActionEnum.LOG_OUT,\n  payload: null,\n}\n```\n\nauthReducer.ts 내부에서는 인증 관련 액션을 해당 상태로 매핑하는 리듀서를 생성할 것입니다:\n\n```js\n/* ui/src/store/auth/authReducer.ts */\n\nimport { Reducer } from \"react\";\nimport { AuthAction } from \"./authActions\";\n\nexport interface AuthState {\n  isLoggedIn: boolean;\n  authToken?: string;\n  userId?: string;\n  name?: string;\n  email?: string;\n}\n\nexport const defaultAuthState: AuthState = {\n  isLoggedIn: false,\n};\n\nconst authReducer: Reducer\u003cAuthState, AuthAction\u003e = (state, action) =\u003e {\n  // 사용자가 성공적으로 인증되면\n  if (action.type === \"LOG_IN\") {\n    localStorage.setItem(\"user\", JSON.stringify(action.payload));\n    return {\n      ...state,\n      isLoggedIn: true,\n      authToken: action.payload.authToken,\n      userId: action.payload.userId,\n      name: action.payload.name,\n      email: action.payload.email,\n    };\n  }\n\n  // 사용자 로그아웃\n  if (action.type === \"LOG_OUT\") {\n    localStorage.removeItem(\"user\");\n    return defaultAuthState;\n  }\n\n  return defaultAuthState;\n};\n\nexport default authReducer;\n```\n\n기본 상태는 false로 설정된 하나의 필드인 isLoggedIn으로 구성됩니다. 사용자가 인증을 한 번하면 리듀서는 LOG_IN 액션을 처리하고 사용자 관련 정보를 localStorage에 유지하며 새 인증 상태를 반환하여 동일한 정보를 유지합니다. 사용자 정보를 계속 유지해야 하는 이유는 사용자가 페이지를 나가고 나중에 방문할 때 인증 상태가 유지되어야 하기 때문입니다. LOG_OUT 액션은 리듀서에 의해 처리되어 모든 상태 및 저장된 사용자 정보가 기본 값으로 재설정됩니다.\n\n이제 액션과 리듀서가 정의되었으므로 AuthContextProvider.tsx에서 전체 응용 프로그램에 인증 상태를 제공하는 컨텍스트 제공자 구성 요소를 만듭니다:\n\n```js\n/* ui/src/store/auth/AuthContextProvider.tsx */\n\n// 전역 가져오기\nimport React, { createContext, useReducer, useCallback, useEffect } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\n// 프로젝트 종속성\nimport { AuthActionEnum } from \"./authActions\";\nimport authReducer, { AuthState, defaultAuthState } from \"./authReducer\";\n\ntype AuthProviderProps = {\n  children: React.ReactElement,\n};\n\nexport type UserData = {\n  authToken: string,\n  userId: string,\n  name: string,\n  email: string,\n};\n\nexport interface AuthContext {\n  authState: AuthState;\n  globalLogInDispatch: (props: UserData) =\u003e void;\n  globalLogOutDispatch: () =\u003e void;\n}\n\n// Auth 컨텍스트\nconst authCtx =\n  createContext \u003c\n  AuthContext \u003e\n  {\n    authState: defaultAuthState,\n    globalLogInDispatch: () =\u003e {},\n    globalLogOutDispatch: () =\u003e {},\n  };\n\nexport const AuthContextProvider = (props: AuthProviderProps) =\u003e {\n  const { children } = props;\n\n  const [authState, authDispatch] = useReducer(authReducer, defaultAuthState);\n  const navigate = useNavigate();\n\n  // 사용자 세부 정보가 지속되는지 확인, 대부분 브라우저 새로 고침에 대응\n  useEffect(() =\u003e {\n    const user = localStorage.getItem(\"user\");\n    if (user) {\n      const userData: UserData = JSON.parse(user);\n      authDispatch({ type: AuthActionEnum.LOG_IN, payload: userData });\n    }\n  }, []);\n\n  const globalLogInDispatch = useCallback(\n    (props: UserData) =\u003e {\n      const { authToken, email, name, userId } = props;\n      authDispatch({\n        type: AuthActionEnum.LOG_IN,\n        payload: {\n          authToken,\n          userId,\n          name,\n          email,\n        },\n      });\n      navigate(\"/resource\");\n    },\n    [navigate]\n  );\n\n  const globalLogOutDispatch = useCallback(() =\u003e {\n    authDispatch({ type: AuthActionEnum.LOG_OUT, payload: null });\n    navigate(\"/user/login\");\n  }, [navigate]);\n\n  // 하위 컴포넌트로 전달할 컨텍스트 값\n  const ctx = {\n    authState,\n    globalLogInDispatch,\n    globalLogOutDispatch,\n  };\n\n  return \u003cauthCtx.Provider value={ctx}\u003e{children}\u003c/authCtx.Provider\u003e;\n};\n\nexport default authCtx;\n```\n\nAuthContextProvider 컴포넌트는 authState 및 관련 디스패치 메서드를 authCtx 컨텍스트 내의 모든 자식 컴포넌트에 제공하는 Higher Order Component (HOC)입니다. globalLogInDispatch와 globalLogOutDispatch 함수는 각각 LOG_IN 및 LOG_OUT 액션을 리듀서에 디스패치하여 인증 상태를 업데이트하는 데 사용됩니다. 인증 액션이 디스패치될 때 해당 경로로 이동하기 위해 react-router-dom도 사용하고 있습니다. 마지막으로, 사용자가 이전에 로그인했는지 여부를 확인하고 필요할 경우 localStorage에 저장된 정보를 찾아 LOG_IN 액션을 디스패치하는 useEffect 훅을 정의했습니다.\n\n마지막 단계는 index.tsx에서 애플리케이션을 AuthContextProvider로 래핑하여 컨텍스트를 제공하는 것입니다.\n\n```js\n/* index.tsx */\n\nimport ReactDOM from 'react-dom/client';\nimport React from 'react';\nimport './index.css';\nimport App from './App';\nimport { BrowserRouter } from 'react-router-dom';\nimport { AuthContextProvider } from './store/auth/AuthContextProvider';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cBrowserRouter\u003e\n      \u003cAuthContextProvider\u003e\n        \u003cApp /\u003e\n      \u003c/AuthContextProvider\u003e\n    \u003c/BrowserRouter\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\n## 2.3 서버와 통신하기\n\n인증 상태 관리가 완료되었으니 이제 내부 메모리 데이터베이스에서 사용자 데이터를 검색해야 하는 서버와의 통신에 집중해 봅시다. 이를 위해 React 컴포넌트에서 서버 엔드포인트를 요청하는 논리를 모두 재사용할 수 있도록 useApi라는 커스텀 훅을 생성할 것입니다. ui/src 내부에 코드를 호스팅할 수 있는 관련 파일이 있는 hooks 폴더를 만들어 보겠습니다:\n\n```js\ncd ui/src \u0026\u0026 mkdir hooks \u0026\u0026 cd hooks \u0026\u0026\\\nmkdir api \u0026\u0026 cd api \u0026\u0026\\\ntouch apiData.ts useApi.ts\n```\n\napiData.ts 파일에는 사용자 로그인 및 등록 이벤트에 대한 서버에서 반환될 데이터 구조가 포함되어 있습니다:\n\n```js\n/* ui/src/hooks/api/apiData.ts */\n\nexport type AuthData = {\n  success: boolean,\n  user: {\n    user_id: string,\n    email: string,\n    name: string,\n    auth_token: string,\n  },\n};\n```\n\nuseApi.ts 파일에는 서버와 통신하기 위한 커스텀 훅이 들어 있어요:\n\n```js\n/* ui/src/hooks/api/useApi.ts */\n\n// 전역 의존성\nimport { useState, useCallback, useContext } from \"react\";\n\n// 프로젝트 의존성\nimport AuthContext from \"../../store/auth/AuthContextProvider\";\n\nconst BASE_URL = \"http://localhost:8000\";\n\nconst useApi = () =\u003e {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const { authState, globalLogOutDispatch } = useContext(AuthContext);\n\n  const request = useCallback(\n    async (\n      endpoint: string,\n      params: { [key: string]: any },\n      handleSuccessResponse: (data: any) =\u003e void,\n      handleErrorResponse?: (error: Error) =\u003e void\n    ) =\u003e {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // NOTE: 사용자가 로그인 중이면 요청 헤더에 auth 토큰 삽입\n        if (authState.isLoggedIn) {\n          params.headers[\"x-access-token\"] = authState.authToken;\n        }\n\n        const response = await fetch(BASE_URL + endpoint, { ...params });\n        if (!response.ok) {\n          const data = await response.json(); // 항상 json 응답을 가정\n          throw new Error(data.error);\n        }\n        const data = await response.json(); // 항상 json 응답을 가정\n\n        // 응답이 정상적이고 오류가 없는 경우, 성공 응답 처리\n        handleSuccessResponse \u0026\u0026 (await handleSuccessResponse(data));\n      } catch (error: any) {\n        // NOTE: 권한이 없는 오류인 경우 사용자 로그아웃\n        if (error \u0026\u0026 error.message \u0026\u0026 error.message === \"Unauthorized\") {\n          globalLogOutDispatch();\n        }\n\n        // 지정된 오류 처리\n        if (handleErrorResponse) {\n          handleErrorResponse(error.message || error.error || error);\n        } else {\n          setError(error.message || error.error || error);\n        }\n      }\n\n      setLoading(false);\n    },\n\n    [authState.isLoggedIn, authState.authToken, globalLogOutDispatch]\n  );\n\n  return {\n    loading: loading,\n    error: error,\n    request: request,\n    setError: setError,\n  };\n};\n\nexport default useApi;\n```\n\nuseApi 훅은 request 함수 내에서 fetch 요청을 보내는 것을 담당하고 있어요. 전역 인증 상태를 통해 사용자가 로그인했는지 먼저 확인하고, 사용자가 인증되면 요청 헤더 x-access-token에 authToken을 첨부합니다. 이 토큰은 요청과 함께 전송되어 서버가 사용자가 특정 리소스에 액세스할 권한이 있는지 확인할 수 있게 해줍니다. 또한, 커스텀 훅은 요청-응답 사이클 및 오류 처리의 상태 관리도 관리합니다. 서버에서 성공적인 응답을 받았다면 handleSuccessResponse 콜백을 통해 데이터를 처리하고, 응답이 실패한 경우 handleErrorResponse 콜백을 통해 오류를 처리합니다. 응답 오류에 \"Unauthorized\" 메시지가 있으면 globalLogOutDispatch 함수를 트리거하여 사용자 인증 상태를 재설정합니다.\n\n## 2.4 인증 구성 요소\n\n우리 애플리케이션의 모든 비즈니스 로직을 완료했고, 이제 화면 인터페이스를 작업할 차례입니다. 먼저 React 컴포넌트를 호스팅할 폴더를 만들어봅시다:\n\n```js\ncd ui/src \u0026\u0026 mkdir components \u0026\u0026\\\ncd components \u0026\u0026 mkdir auth \u0026\u0026\\\ntouch Auth.tsx LogInForm.tsx RegisterForm.tsx validations.ts\n```\n\n먼저, LogInForm.tsx와 RegisterForm.tsx에서 각각 로그인 및 사용자 등록을 위한 양식 컴포넌트를 생성해보겠습니다:\n\n```js\n/* ui/src/components/auth/LoginForm.tsx */\n\nimport { FormEventHandler } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from \"./Auth.module.css\";\n\ntype Props = {\n  onSubmit: FormEventHandler\u003cHTMLFormElement\u003e,\n};\n\nconst LoginForm = (props: Props) =\u003e {\n  const { onSubmit } = props;\n  return (\n    \u003cform onSubmit={onSubmit} className={styles.Form}\u003e\n      \u003cdiv className={styles.Input}\u003e\n        \u003clabel htmlFor=\"email\"\u003e이메일\u003c/label\u003e\n        \u003cinput id=\"email\" name=\"email\" type=\"email\" required placeholder=\"이메일 주소\" /\u003e\n      \u003c/div\u003e\n      \u003cdiv className={styles.Input}\u003e\n        \u003clabel htmlFor=\"password\"\u003e비밀번호\u003c/label\u003e\n        \u003cinput id=\"password\" name=\"password\" type=\"password\" required placeholder=\"비밀번호\" /\u003e\n      \u003c/div\u003e\n      \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n      \u003cLink className={styles.Link} to={\"/user/register\"}\u003e\n        아직 계정이 없으신가요? 가입하기\n      \u003c/Link\u003e\n    \u003c/form\u003e\n  );\n};\n\nexport default LoginForm;\n```\n\n```js\n/* ui/src/components/auth/RegisterForm.tsx */\n\nimport { FormEventHandler } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport styles from \"./Auth.module.css\";\n\ntype Props = {\n  onSubmit: FormEventHandler\u003cHTMLFormElement\u003e,\n};\n\nconst RegisterForm = (props: Props) =\u003e {\n  const { onSubmit } = props;\n  return (\n    \u003cform onSubmit={onSubmit} className={styles.Form}\u003e\n      \u003cdiv className={styles.Input}\u003e\n        \u003clabel htmlFor=\"name\"\u003e이름\u003c/label\u003e\n        \u003cinput id=\"name\" name=\"name\" type=\"text\" required placeholder=\"전체 이름\" /\u003e\n      \u003c/div\u003e\n      \u003cdiv className={styles.Input}\u003e\n        \u003clabel htmlFor=\"email\"\u003e이메일\u003c/label\u003e\n        \u003cinput id=\"email\" name=\"email\" type=\"email\" required placeholder=\"이메일 주소\" /\u003e\n      \u003c/div\u003e\n      \u003cdiv className={styles.Input}\u003e\n        \u003clabel htmlFor=\"password\"\u003e비밀번호\u003c/label\u003e\n        \u003cinput id=\"password\" name=\"password\" type=\"password\" required placeholder=\"비밀번호\" /\u003e\n      \u003c/div\u003e\n      \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n      \u003cLink className={styles.Link} to={\"/user/login\"}\u003e\n        이미 계정이 있으신가요? 로그인하기\n      \u003c/Link\u003e\n    \u003c/form\u003e\n  );\n};\n\nexport default RegisterForm;\n```\n\n두 양식은 각각 이름, 이메일과 비밀번호 속성을 포함한 폼 제출 이벤트를 처리할 콜백 프롭인 onSubmit을 전달받습니다.\n\n그 다음으로, Auth.tsx에서 사용자 브라우저 내의 네비게이션 경로에 따라 LogInForm 또는 RegisterForm 구성 요소 중 하나를 표시할 컴포넌트를 만들겠습니다:\n\n```js\n/* ui/src/components/auth/Auth.tsx */\n\n// 전역 imports\nimport { useEffect, useState, useContext, FormEventHandler } from \"react\";\n\n// 프로젝트 의존성\nimport useApi from \"../../hooks/api/useApi\";\nimport AuthContext from \"../../store/auth/AuthContextProvider\";\nimport { validatePasswordLength, validateEmailFormat } from \"./validations\";\nimport { AuthData } from \"../../hooks/api/apiData\";\nimport { useLocation } from \"react-router-dom\";\nimport LoginForm from \"./LoginForm\";\nimport RegisterForm from \"./RegisterForm\";\n\nconst Auth = () =\u003e {\n  const [authData, setAuthData] = useState\u003cAuthData\u003e();\n  const { request, setError } = useApi();\n  const { globalLogInDispatch } = useContext(AuthContext);\n  const location = useLocation();\n  const currentPathArray = location.pathname.split('/');\n  const isLogin = currentPathArray[currentPathArray.length - 1] === 'login';\n\n  // 로그인 사용자에 대한 api 응답 성공 시, 전역 auth LOG_IN 이벤트를 디스패치합니다\n  useEffect(() =\u003e {\n    if (authData \u0026\u0026 \"success\" in authData) {\n      globalLogInDispatch({\n        authToken: authData.user.auth_token,\n        userId: authData.user.user_id,\n        name: authData.user.name,\n        email: authData.user.email,\n      });\n    }\n  }, [authData, globalLogInDispatch]);\n\n  const authHandler: FormEventHandler\u003cHTMLFormElement\u003e = async (event) =\u003e {\n    event.preventDefault();\n    const data = new FormData(event.currentTarget);\n    // 먼저 유효성 검사!\n    const userEmail = data.get(\"email\");\n    const userPassword = data.get(\"password\");\n    const userName = data.get(\"name\");\n    try {\n      if (\n        !validateEmailFormat(userEmail?.toString() || \"\") ||\n        !validatePasswordLength(userPassword?.toString() || \"\")\n      ) {\n        throw new Error(\"잘못된 자격 증명 형식입니다!\");\n      }\n      const params = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email: userEmail,\n          password: userPassword,\n          name: userName,\n        }),\n      };\n\n      const endpoint = `/user/${isLogin ? 'login' : 'register'}`\n      await request(endpoint, params, setAuthData);\n    } catch (error: any) {\n      setError(error.message || error);\n    }\n  };\n\n  return (\n    \u003c\u003e\n      \u003ch2\u003e{isLogin ? '로그인' : '가입하기'}\u003c/h2\u003e\n      {\n        isLogin\n          ? \u003cLoginForm onSubmit={authHandler} /\u003e\n          : \u003cRegisterForm onSubmit={authHandler} /\u003e\n      }\n    \u003c/\u003e\n  );\n};\n\nexport default Auth;\n```\n\n우리는 react-router-dom에서 제공하는 useLocation을 사용하여 사용자가 브라우저에서 어떤 경로에 있는지 추출합니다. 경로에 따라, LoginForm 또는 RegisterForm을 표시하도록 선택합니다. 각 폼에 대한 onSubmit 핸들러는 authHandler에 정의된 대로 작동하며, 이 핸들러는 양식 제출 이벤트에서 모든 입력 폼 속성을 추출하고 서버에서 사용자/로그인 또는 사용자/등록 엔드포인트를 요청하기 전에 이를 유효성 검사합니다.\n\n양식 제출 이벤트에 대한 유효성 검사 로직은 기본적이며 아래 validation.ts에서 보여진 것과 같습니다:\n\n```js\n/* ui/src/components/auth/validations.ts */\n\nexport const validatePasswordLength = (password: string) =\u003e {\n  return !!password \u0026\u0026 password.length \u003e 7;\n};\n\nexport const validateEmailFormat = (email: string) =\u003e {\n  const re =\n    /^(([^\u003c\u003e()[\\]\\\\.,;:\\s@\"]+(\\.[^\u003c\u003e()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return !!email \u0026\u0026 re.test(String(email).toLowerCase());\n};\n```\n\n## 2.5 Resource component\n\n마지막으로 만들 인터페이스 구성 요소는 보호된 리소스 경로를 시뮬레이션하는 더미 페이지입니다. 코드를 호스팅할 폴더를 만들기 위해 먼저 다음 명령어를 실행하세요:\n\n```js\ncd ui/src/components \u0026\u0026\\\nmkdir resource \u0026\u0026\\\ncd resource \u0026\u0026\\\ntouch Resource.tsx\n```\n\nResource.tsx 파일 내부에 아래와 같이 구성 요소를 생성할 것입니다:\n\n```js\n/* ui/src/components/resource/Resource.tsx */\n\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport useApi from \"../../hooks/api/useApi\";\nimport authCtx from \"../../store/auth/AuthContextProvider\";\nimport styles from \"./Resource.module.css\";\n\nconst Resource = () =\u003e {\n  const [data, setData] = useState();\n  const { request, setError } = useApi();\n  const { globalLogOutDispatch } = useContext(authCtx);\n\n  const fetchData = useCallback(async () =\u003e {\n    try {\n      const params = {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      };\n      await request(\"/resource\", params, (result) =\u003e {\n        setData(result.data);\n      });\n    } catch (error: any) {\n      setError(error.message || error);\n    }\n  }, [request, setError]);\n\n  useEffect(() =\u003e {\n    fetchData();\n  }, [fetchData]);\n\n  return (\n    \u003cdiv className={styles.Resource}\u003e\n      \u003ch1\u003e{data}\u003c/h1\u003e\n      \u003cbutton onClick={globalLogOutDispatch}\u003e로그아웃\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Resource;\n```\n\n이 컴포넌트는 간단하며 useEffect 훅을 사용하여 서버의 /resource 엔드포인트로 호출하는 로직으로 구성되어 있습니다. 이 호출에는 pre-existing auth 토큰이 필요합니다. 반환된 데이터는 페이지에 표시되며 로그아웃 버튼을 클릭하면 auth 컨텍스트에서 globalLogOutDispatch를 트리거하여 전역 auth 상태를 재설정합니다.\n\n## 2.6 모든 것을 연결하기\n\n인터페이스 애플리케이션을 위한 비즈니스 로직과 프레젠테이션 컴포넌트를 작성했으니, App.tsx에서 react-router-dom을 사용하여 프론트엔드 라우팅을 통해 모든 것을 연결해보겠습니다 :\n\n```js\n/* ui/src/App.tsx */\n\nimport \"./App.css\";\nimport { Route, Routes, Navigate, useLocation } from \"react-router-dom\";\nimport AuthContext from \"./store/auth/AuthContextProvider\";\nimport { useContext } from \"react\";\nimport Resource from \"./components/resource/Resource\";\nimport Auth from \"./components/auth/Auth\";\n\nfunction App() {\n  const { authState } = useContext(AuthContext);\n  const location = useLocation();\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cRoutes\u003e\n        \u003cRoute path=\"/\" element={\u003cNavigate to={authState.isLoggedIn ? location.pathname : \"/user/login\"} /\u003e} /\u003e\n        {!authState.isLoggedIn \u0026\u0026 (\n          \u003cRoute path=\"user\"\u003e\n            \u003cRoute path=\"register\" element={\u003cAuth /\u003e} /\u003e\n            \u003cRoute path=\"login\" element={\u003cAuth /\u003e} /\u003e\n          \u003c/Route\u003e\n        )}\n        {authState.isLoggedIn \u0026\u0026 \u003cRoute path=\"resource\" element={\u003cResource /\u003e} /\u003e}\n      \u003c/Routes\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\nApp.tsx 파일 내에서는 지금 애플리케이션의 모든 라우팅이 구성되어 있습니다. /user/register, /user/login 및 /resource로 구성되어 있습니다. 컨텍스트에서 제공된 전역 인증 상태가 사용자가 인증된 상태를 나타내면 사용자에게 /resource 경로에 액세스할 수 있도록 허용하여 해당 서버의 엔드포인트로 이동하여 'protected' 데이터를 표시합니다.\n\n# 결론\n\n이 글에서는 풀스택 인증 시스템을 구현하는 데 필요한 기능을 만들었습니다. 인증 방법은 토큰 기반 방식으로, 이는 이 튜토리얼 시리즈의 첫 번째 글에서 논의되었습니다. 애플리케이션의 각 구성 요소에 대해 많은 세부 정보를 다뤘지만, 아직 할 일이 많습니다. 예를 들어 다음과 같은 작업을 수행할 수 있습니다:\n\n- 프론트엔드 애플리케이션의 스타일링 개선, 이 리포지토리에서 설정한 기본 스타일링을 가져올 수 있습니다.\n- 프론트엔드 및 백엔드에서 적절한 사용자 입력 유효성 검사, SQL 인젝션 방지 또는 데이터 유형 유효성 검사와 같은 작업.\n- 잘못된 자격 증명을 제출했을 때 사용자 경험을 향상시키기 위한 에러 처리.\n- 실제 데이터베이스를 구축하여 사용자 데이터 저장.\n- AWS 또는 GCP와 같은 클라우드 제공 업체를 사용하여 애플리케이션을 컨테이너화하고 배포.\n\n나머지는 네가 알아서 해주면 돼! 그리고 언제든지 애플리케이션을 개선하거나 다른 방법으로 작업할 수 있는 좋은 제안이 있다면 댓글을 남겨줘! 이 튜토리얼의 최종 코드는 여기서 확인할 수 있어.\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationandAuthorizationwithNodejsReactandTypescriptPart2_0.png","tag":["Tech"],"readingTime":39},{"title":"프로젝트에 따라 Nodejs의 올바른 버전으로 자동 전환하기","description":"","date":"2024-05-12 19:36","slug":"2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject","content":"\n\nNode.js 개발의 끊임없이 변화하는 풍경 속에서는 다양한 프로젝트 요구 사항과 호환성 문제를 관리하는 것이 부담스러운 작업일 수 있습니다. 이 기사에서는 프로젝트의 요구 사항에 기반하여 Node.js의 올바른 버전으로 자동 전환하는 컨셉을 탐구합니다.\n\nNVM이란 무엇인가요?\nNVM, Node Version Manager, 여러 개의 Node.js 설치를 시스템에서 원활하게 관리하는 데 사용되는 go-to 솔루션입니다. 다양한 Node.js 버전 요구 사항을 가진 여러 프로젝트에서 작업하는 개발자이거나 최신 기능과 업데이트를 탐구하고 싶어하는 열정적인 사용자라면, NVM은 몇 가지 간단한 명령어로 다양한 Node.js 버전 간에 간편하게 전환할 수 있도록 해줍니다.\n\nNVM GitHub 레포지토리에서 예시를 확인해보세요\n\n```js\n$ nvm use 16\nNow using node v16.9.1 (npm v7.21.1)\n$ node -v\nv16.9.1\n$ nvm use 14\nNow using node v14.18.0 (npm v6.14.15)\n$ node -v\nv14.18.0\n$ nvm install 12\nNow using node v12.22.6 (npm v6.14.5)\n$ node -v\nv12.22.6\n```\n\n\n\n.nvmrc이 무엇인가요?\n\nNode.js 생태계에서 .nvmrc 파일은 Node Version Manager(nvm)에서 사용되는 간단한 구성 파일입니다. 이 파일은 일반적으로 프로젝트의 루트 디렉토리에 위치하며 해당 프로젝트에서 작업할 때 사용해야 하는 특정 Node.js 버전을 지정합니다.\n\n![사진](/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png)\n\n.nvmrc 파일 만들기 및 사용하기\n\n\n\n\"`.nvmrc` 파일을 만들고 사용하는 것은 매우 간단합니다.\n\n1. 프로젝트 디렉토리로 이동합니다.\n\n2. `.nvmrc`라는 새 파일을 만들고 원하는 노드 버전을 입력합니다.\n\n여기 샘플 내용 파일이 있습니다.\"\n\n\n\n```js\nv18.18.2\n```\n\n3. 터미널에서 nano ~/.bashrc를 입력하여 .bashrc를 엽니다.\n\n4. 이 코드를 .bashrc 파일 끝에 붙여넣고 저장하세요.\n\n```js\n# .nvmrc 파일이 있으면 .nvmrc의 노드 버전을 사용합니다.\n\n# 터미널이 시작될 때 호출\nif [[ -f .nvmrc ]]\nthen\n  nvm use\nfi\n\n# cd 명령어를 통해 디렉토리가 변경될 때 호출\nfunction cd() {\n builtin cd \"$@\"\n  if [[ -f .nvmrc ]]\n  then\n    nvm use\n  fi\n}\n```\n\n\n\n5. 컴퓨터를 다시 부팅하거나 터미널에서 다음 명령어를 입력하여 다시 시작하세요: source .bashrc\n\n6. 이제 .nvmrc 파일이 있는 디렉토리에서 터미널을 열 때마다 터미널이 노드 버전을 자동으로 전환할 것입니다.\n\n이것은 .nvmrc 파일이 있는 모든 프로젝트에 대해 작동할 것입니다.\n\n요약하자면, 다음에 프로젝트를 시작할 때 .nvmrc 파일을 생성하고 버전 관련 문제를 해결하세요.","ogImage":{"url":"/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png"},"coverImage":"/assets/img/2024-05-12-AutomaticallySwitchtoCorrectVersionofNodeJsBasedonProject_0.png","tag":["Tech"],"readingTime":2},{"title":"리플렛js와 리액트로 시작하기 간단한 지도 렌더링하기","description":"","date":"2024-05-12 19:34","slug":"2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap","content":"\n\n![Leaflet.js와 React를 사용하여 간단한 지도 렌더링 시작하기](/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png)\n\n# 소개\n\n이 시리즈에서는 강력한 오픈 소스 JavaScript 라이브러리인 Leaflet.js를 활용하여 React, HTML 및 CSS로 Google 지도 대안으로 상호 작용하는 지도를 생성하는 방법을 살펴볼 것입니다. 주니어 또는 중급 개발자라면 Leaflet.js 사용 방법을 이해함으로써 위치 데이터를 표시하고 사용자 정의 맵 기반 애플리케이션을 쉽게 구축할 수 있습니다. 이 첫 번째 글에서는 개발 환경을 설정하고 기본적인 지도를 렌더링하는 것부터 시작하겠습니다.\n\n이후의 글에서는 대화식 맵핑의 세계로 더욱 깊이 파고들어, 마커 추가, 부드러운 확대 기능 활성화, 클릭 이벤트 처리, 외부 데이터 작업 및 다각형 및 팝업 사용자 정의 등의 주제를 다룰 것입니다.\n\n\n\n이 튜토리얼과 더 나아가기 위해 다음 도구들을 활용할 것입니다:\n\n- Leaflet\n인터랙티브 지도를 생성하는 JavaScript 라이브러리\n- React\n사용자 인터페이스를 구축하는 JavaScript 라이브러리\n- React-Leaflet\nLeaflet 지도용 React 컴포넌트들\n\n# Leaflet은 무엇인가요?\n\nLeaflet.js는 오픈 소스이며 가벼운 JavaScript 라이브러리로, 웹을 위한 인터랙티브 지도를 손쉽게 만들 수 있습니다.\n\n\n\n약 38,000개의 스타를 보유한 Leaflet.js는 휴대폰 친화적 대화형 지도를 위한 주요 오픈 소스 JavaScript 라이브러리 중 하나입니다.\n\n만약 \"Leaflet\"이라는 이름의 유래에 대해 궁금하다면, 이것은 단편적이고, 표시하고, 지도를 손쉽게 탐색할 수 있도록 도와주는 편리한 도구로 생각해보세요 - 마치 바람에 흩날리는 나뭇잎처럼 손쉽게 움직일 수 있습니다.\n\nLeaflet을 선택하는 이유는?\n\n- 가볍고 빠름: 개발자들이 Leaflet을 좋아하는 주요 이유 중 하나는 가벼운 무게에 있습니다 - 약 42KB의 무게를 상하. 웹 페이지가 무거운 스크립트에 늘어지지 않도록 보장하여 부드럽고 신속한 사용자 경험을 제공합니다.\n- 사용자 친화적이고 직관적: Leaflet의 API는 명쾌하고 직관적이어서 모든 수준의 개발자에게 완벽히 적합합니다. 경험이 풍부한 전문가든 막 시작한 초심자든 쉽게 이해하고 구현할 수 있을 것입니다.\n- 사용자 정의 가능 및 다재다능: Leaflet은 가볍지만 강력한 기능을 제공합니다! 당신의 특정 요구에 맞게 지도를 맞춤화하기 위해 원활하게 통합할 수 있는 다양한 플러그인과 확장기능을 제공합니다. 마커 및 폴리곤 표시부터 상호작용 처리까지, 가능성은 거의 무한합니다.\n- 크로스 플랫폼 호환성: Leaflet으로 생성한 지도는 다양한 플랫폼과 장치에서 어려움 없이 볼 수 있습니다. 사용자가 데스크톱, 스마트폰 또는 태블릿에서 애플리케이션을 접근하더라도, 지도는 아름답게 작동할 것입니다.\n- 활발한 커뮤니티 및 지속적인 개발: 열정적이고 활발한 개발자 및 기여자들의 커뮤니티로 Leaflet은 계속 발전하고 개선되고 있습니다. 업데이트, 버그 수정 및 흥미로운 새로운 기능이 정기적으로 출시되어 당신이 최신의 지도 기술을 선도하도록 보장합니다.\n\n\n\n리플렛은 웹 페이지에서 지도를 렌더링하기 위해 HTML, CSS, 및 JavaScript를 조합하여 사용합니다. 최신 브라우저의 강력한 기능을 활용하며 OpenStreetMap, Mapbox 및 기타 인기 있는 맵 제공업체를 활용하여 다양한 스타일과 데이터 오버레이를 가진 지도를 표시할 수 있습니다.\n\n재미있는 사실: 리플렛의 \"잎\" 로고!\n\n리플렛의 재미있는 잎 로고를 본 적이 있을 지도 모릅니다. 귀여운 외양 뿐만 아니라 라이브러리의 가벼운 특성을 상징합니다. 마치 단 한 잎이 바람에 가볍게 나부끼는 것처럼, 리플렛의 최소주의 디자인은 사용자에게 부드럽고 빠른 지도 상호작용을 제공합니다.\n\n\n\n이제 Leaflet.js의 마법을 소개했으니, 소마건을 걸고 React와 함께 재미있는 상호작용 맵핑의 흥미진진한 세계에 뛰어들어 봅시다. 함께 멋진 지도 애플리케이션을 만들어 사용자에게 오랫동안 기억에 남는 경험을 선사하며 이 학습 여정을 즐겨봅시다!\n\n멋진 모험을 지도에 표현할 준비가 되셨나요? 시작해 봅시다!\n\n그런데..\n\nReact로 들어가기 전에, 일반적인 html, css 및 js를 통해 Leaflet의 기본을 이해해 봅시다. 이를 위해 Leaflet 지도를 설정하고, 마커 및 팝업을 사용하는 간단한 예제를 만들 것입니다.\n\n\n\n# Leaflet 라이브러리로 단순한 HTML, CSS 및 JS 예제 만들기\n\n이 섹션에서는 Leaflet.js 라이브러리를 포함한 간단한 HTML 페이지를 만들고, 기본 지도를 렌더링하고 마커 및 팝업을 추가하는 방법을 보여줄 것입니다.\n\n단계 1: HTML 구조 설정\n\n좋아하는 텍스트 편집기를 열고 새 HTML 파일(예: index.html)을 만들고 기본 구조를 설정하세요:\n\n\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003e간단한 Leaflet 지도\u003c/title\u003e\n  \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\" /\u003e\n  \u003cstyle\u003e\n    /* 지도 컨테이너 크기 설정 */\n    #map {\n      height: 400px;\n      width: 100%;\n    }\n  \u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"map\"\u003e\u003c/div\u003e\n  \u003cscript src=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\"\u003e\u003c/script\u003e\n  \u003cscript src=\"app.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\nStep 2: JavaScript 파일 생성 (app.js)\n\n다음으로, HTML 파일과 동일한 디렉토리에 'app.js'라는 새 JavaScript 파일을 만듭니다. 여기에 지도를 렌더링하고 마커 및 팝업을 추가하는 코드를 작성할 것입니다.\n\n```js\n// 문서가 준비되기를 기다립니다.\ndocument.addEventListener('DOMContentLoaded', function () {\n  // 맵 인스턴스를 생성하고 초기 뷰 좌표 및 확대 수준을 설정합니다.\n  var map = L.map('map').setView([51.505, -0.09], 13);\n\n  // OpenStreetMap으로부터 지도에 타일 레이어 추가\n  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '\u0026copy; \u003ca href=\"https://www.openstreetmap.org/copyright\"\u003eOpenStreetMap\u003c/a\u003e contributors'\n  }).addTo(map);\n\n  // 팝업이 있는 마커를 생성하고 지도에 추가합니다.\n  var marker = L.marker([51.505, -0.09]).addTo(map);\n  marker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n});\n```\n\n| Name      | Age | Location |\n|-----------|-----|----------|\n| John      | 25  | New York |\n| Emily     | 28  | Paris    |\n| Matthew   | 23  | London   |\n\n\n지도 만들기 및 타일 레이어 추가하기\n\n```js\n// 지도 인스턴스 생성 및 초기 보기 좌표 및 확대 수준 설정\nvar map = L.map('map').setView([51.505, -0.09], 13);\n```\n\n여기서 `L.map()` 메서드를 사용하여 새 지도 인스턴스를 생성하고 우리의 지도가 렌더링될 `div` 요소의 ID를 전달했습니다.\n\n`setView()` 메서드는 맵의 초기 보기를 지정한 위도(51.505) 및 경도(-0.09)와 확대 수준 13으로 설정합니다. 확대 수준이 높을수록 지도가 더 가깝게 표시됩니다.\n\n\n\n```js\n// 지도에 OpenStreetMap에서 타일 레이어 추가\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\nattribution: '\u0026copy; \u003ca href=\"https://www.openstreetmap.org/copyright\"\u003eOpenStreetMap\u003c/a\u003e contributors'\n}).addTo(map);\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n```\n\n위 코드에서 L.tileLayer() 메서드를 사용하여 타일 레이어를 생성했습니다.\n\n타일 레이어는 지도의 시각적 표현을 구성하는 이미지 타일 세트입니다. 이 예에서는 https://'s'.tile.openstreetmap.org/'z'/'x'/'y'.png로 제공되는 OpenStreetMap 타일 레이어를 사용하고 있습니다. 's', 'z', 'x', 'y'는 서브도메인, 줌 레벨 및 타일 좌표를 나타내는 자리 표시자입니다. Leaflet은 자동으로 이러한 자리 표시자를 교체하여 지도를 이동하고 확대/축소할 때 올바른 타일을 로드합니다.\n\n타일 레이어의 attribution 옵션은 OpenStreetMap 기여자들에게 크레딧을 주기 위해 사용됩니다. 제3자 소스에서 지도 데이터를 사용할 때 적절한 소유권을 제공하는 것이 중요합니다.\n\n\n\n팝업이 달린 마커 추가하기\n\n```js\n// 팝업이 달린 마커를 생성하고 맵에 추가하기\nvar marker = L.marker([51.505, -0.09]).addTo(map);\nmarker.bindPopup(\"안녕하세요, 저는 마커입니다!\").openPopup();\n```\n\n맵에 마커를 추가하려면 L.marker() 메소드를 사용하고 위도와 경도를 배열 [51.505, -0.09]로 전달합니다. 이로 인해 마커가 맵의 해당 위치에 배치됩니다.\n\n그런 다음 bindPopup() 메소드를 사용하여 마커에 팝업을 추가합니다. 팝업 내용은 \"안녕하세요, 저는 마커입니다!\" 라는 문자열입니다. 그리고 openPopup() 메소드를 사용하여 팝업을 마커가 맵에 추가된 직후에 바로 표시합니다.\n\n\n\n다른 타일 레이어 사용하기\n\nLeaflet은 지도의 외관과 스타일을 변경할 수 있는 다양한 타일 레이어를 제공합니다. OpenStreetMap 이외에도 Mapbox, Stamen, Esri 등 다른 제공 업체를 사용할 수 있습니다.\n\nMapbox 타일 레이어를 사용하는 예시입니다:\n\n```js\n// Mapbox 타일 레이어 사용하기\nL.tileLayer('https://{s}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}.png?access_token={accessToken}', {\n  attribution: '© \u003ca href=\"https://www.mapbox.com/about/maps/\"\u003eMapbox\u003c/a\u003e',\n  mapId: 'your-mapbox-map-id', // 여러분의 Mapbox 맵 ID로 대체해주세요\n  accessToken: 'your-mapbox-access-token' // 여러분의 Mapbox 액세스 토큰으로 대체해주세요\n}).addTo(map);\n```\n\n\n\nMapbox 타일 레이어를 사용하려면 Mapbox 계정에 가입하고 액세스 토큰과 맵 ID를 획득해야 합니다. 'your-mapbox-map-id'와 'your-mapbox-access-token'을 실제 Mapbox 자격 증명으로 대체해주세요.\n\n# React-Leaflet\n\n이제 Leaflet과 순수 JavaScript를 사용하여 지도를 생성하고 마커를 추가하는 방법을 알게 되었습니다. React를 사용하여 동일한 결과를 어떻게 얻을 수 있는지 알아봅시다.\n\n필수 전제 조건\n\n\n\n리액트 구현에 들어가기 전에 컴퓨터에 다음이 설치되어 있는지 확인하세요:\n\n- Node.js (최신 LTS 버전) 및 npm (Node Package Manager)\n- 선호하는 코드 편집기 (예: Visual Studio Code, Sublime Text, 또는 Atom)\n\n개발 환경 설정하기\n\n먼저 터미널이나 명령 프롬프트를 열고 다음 단계를 따르세요:\n\n\n\n- Create React App을 사용하여 새로운 React 프로젝트를 만들어보세요:\n\n\nnpx create-react-app leaflet-map-app\n\ncd leaflet-map-app\n\n\n2. 필요한 종속성을 설치하세요:\n\n\n\nnpm install leaflet\n\nnpm install react-leaflet\n\n3. 이제 코드 편집기에서 프로젝트를 엽니다.\n\n간단한 지도 컴포넌트 생성\n\n\n\n프로젝트의 'src' 폴더에 'SimpleMap.js'라는 새 파일을 만들어 주세요. 이 파일은 맵을 렌더링하는 주요 리액트 컴포넌트가 될 거에요.\n\n맵 설정하기\n\nSimpleMap.js 안에서 필요한 모듈을 먼저 import 하는 것으로 시작해요:\n\n```js\nimport React, { useRef } from \"react\";\nimport { MapContainer, TileLayer } from \"react-leaflet\";\nimport \"leaflet/dist/leaflet.css\";\n```\n\n\n\n지도 렌더링하기\n\n이제 SimpleMap 컴포넌트를 구현하고 지도를 렌더링합시다:\n\n```js\nconst SimpleMap = () =\u003e {\n  const mapRef = useRef(null);\n  const latitude = 51.505;\n  const longitude = -0.09;\n\n  return ( \n    // 지도 컨테이너의 높이와 너비를 설정해야지만 지도가 표시됩니다.\n      \u003cMapContainer center={[latitude, longitude]} zoom={13} ref={mapRef} style={{height: \"100vh\", width: \"100vw\"}}\u003e\n        \u003cTileLayer\n          attribution='\u0026copy; \u003ca href=\"https://www.openstreetmap.org/copyright\"\u003eOpenStreetMap\u003c/a\u003e contributors'\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        /\u003e\n        {/* 추가 지도 레이어나 컴포넌트를 이곳에 추가할 수 있습니다 */}\n      \u003c/MapContainer\u003e\n  );\n};\n\nexport default SimpleMap;\n```\n\n중요 사항!\n\n\n\n\nMapContainer center='[위도, 경도]' zoom='13' ref='mapRef' style='높이: \"100vh\", 너비: \"100vw\"'\n\nMapContainer의 높이와 너비를 설정하지 않으면 지도가 렌더링되지 않습니다.\n\nmapRef 사용 이유:\n\nuseRef로 mapRef를 사용하면 React-Leaflet이 관리하는 Leaflet 지도 인스턴스에 직접 액세스할 수 있습니다. 이는 표준 속성이나 이벤트 처리의 범위를 벗어나야 하는 작업을 수행해야 할 때 특히 유용합니다. 예를 들어 지도와 상호 작용하거나 지도의 중심을 동적으로 업데이트하거나 Leaflet의 기본 API에 직접 액세스해야 할 수 있습니다.\n\n\n\n\nmapRef을 사용하면 맵 인스턴스를 더 많은 제어력과 유연성을 가질 수 있어요. 이는 응용 프로그램에서 더 고급 맵 기능이나 상호 작용을 구현할 때 유용해요.\n\n다음 기사에서 더 자세히 살펴보겠습니다.\n\nMapContainer 구성 요소\n\nMapContainer는 첫 번째 예제와 같이 맵을 위한 `div` 요소 컨테이너를 렌더링합니다.\n\n\n\nMapContainer이 DOM에 렌더링되는 방법:\n\nJSX 코드에 MapContainer 컴포넌트를 포함하면, 다른 React 컴포넌트와 마찬가지로 DOM에 렌더링됩니다. 그러나 MapContainer와 일반 HTML 요소 사이에 중요한 차이가 있습니다:\n\nReact-Leaflet은 내부적으로 Leaflet의 코어 라이브러리를 사용하여 DOM을 직접 조작하여 지도를 렌더링합니다. MapContainer 컴포넌트가 DOM에 렌더링되면, 지정된 높이와 너비로 `div` 요소가 생성되는데, 이는 지도의 컨테이너 역할을 합니다.\n\n초기 렌더링 후에 React가 가상 DOM의 변경 사항을 조정할 때, Leaflet의 코어 라이브러리가 제어를 가져와 맵의 모양과 업데이트를 효율적으로 관리하면서 React 컴포넌트를 전체 재렌더링시키지 않습니다. 이 접근 방식은 상호작용 형식의 맵을 다룰 때 빈번한 업데이트가 필요한 경우에 최적의 성능을 보장합니다.\n\n\n\n모든 것을 함께 적용하기\n\nApp.js 파일에서 SimpleMap 컴포넌트를 import하여 주요 응용 프로그램에서 사용합니다:\n\n```js\nimport React from 'react';\nimport SimpleMap from './SimpleMap';\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e내 Leaflet.js 및 React 지도\u003c/h1\u003e\n      \u003cSimpleMap /\u003e\n    \u003c/div\u003e\n  );\n}\nexport default App;\n```\n\n프로젝트 디렉토리에서 npm install을 실행하여 필요한 패키지를 설치해야 합니다. 모든 것이 설정되면 npm start로 개발 서버를 실행하고 브라우저에서 http://localhost:3000을 방문하여 지도를 확인할 수 있습니다.\n\n\n\n아래는 Markdown 형식으로 테이블을 변경한 결과입니다.\n\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_2.png\" /\u003e\n\n# React-Leaflet의 한계\n\nReact-Leaflet은 상호작용적 지도를 만드는 데 훌륭한 도구이지만 몇 가지 재미있는 한계가 있습니다.\n\n\n\n\nLeaflet은 로드될 때 DOM에 직접 호출을 하기 때문에 React Leaflet은 서버 측 렌더링과 호환되지 않습니다.\n\n노출된 구성 요소는 Leaflet 레이어의 추상화이며 DOM 요소가 아닙니다. 일부 구성 요소는 Leaflet에서 노출된 세터를 호출하여 직접 업데이트할 수 있는 프로퍼티를 가지고 있으며, 다른 구성 요소는 key 프로퍼티에 고유한 값이 설정되어 React의 알고리즘이 정확히 처리할 수 있도록 완전히 대체되어야 합니다.\n\n이러한 도전을 극복하기 위해 개발자들은 다양한 접근 방식을 사용해 왔습니다. 예를 들어:\n\n- 조건부 렌더링: 일반적인 접근 방식 중 하나는 Leaflet 구성 요소를 클라이언트 측에서만 조건부로 렌더링하는 것입니다. 동적 임포트 또는 useEffect 훅과 같은 기술을 사용하여 초기 렌더링 후 클라이언트에서만 실행되도록 보장합니다.\n- Leaflet-Headless: 일부 개발자들은 Leaflet의 headless 버전인 \"leaflet-headless\"와 같이 Leaflet의 headless 버전을 만들어 왔습니다. 이를 통해 DOM 없이 서버에서 Leaflet 지도를 렌더링할 수 있습니다. 그러나 이러한 해결책은 제한 사항을 가질 수 있으며 Leaflet의 모든 기능을 제공하지 않을 수도 있습니다.\n\n\n\nNext.js에서 조건부 렌더링의 예 및 간단한 해결책입니다:\n\n```js\nimport dynamic from 'next/dynamic'\n\nfunction HomePage() {\n  const Map = dynamic(\n    () =\u003e import('@components/map'), // 컴포넌트 위치인 '@components/map'을 교체해주세요\n    { \n      loading: () =\u003e \u003cp\u003e지도를 불러오는 중입니다\u003c/p\u003e,\n      ssr: false // 이 줄이 중요합니다. 서버 측 렌더링을 막습니다\n    }\n  )\n  return \u003cMap /\u003e\n}\n\nexport default HomePage\n```\n\n# 공식 문서 자세히 살펴보기\n\n더 많은 고급 사용 사례를 탐색하거나 React-Leaflet 컴포넌트의 속성과 기능에 대해 더 깊이 파고들고 싶다면, 공식 문서를 참조해보세요! 이 문서에는 Leaflet을 React 애플리케이션 내에서 최대한 활용할 수 있도록 가능한 모든 컴포넌트, 옵션, 특징에 대한 포괄적인 정보가 제공되어 있습니다.\n\n\n\n문서 링크: React-Leaflet 공식 문서\n\n# GitHub에서 코드 살펴보기\n\n코드를 탐험하고 지도 뒤에 숨겨진 마법을 확인하고 싶다면, 이 기사 시리즈의 전체 소스 코드가 GitHub에서 사용 가능합니다! 🚀🔍\n\nGitHub에서 코드를 확인해보세요\n\n\n\n자유롭게 살펴보고 실험하며 예제를 활용해보세요. 코딩 즐기세요! 🌟🖥️\n\n# 결론\n\n이 시리즈의 첫 번째 기사를 완료한 것을 축하합니다! 저는 개발자 기사를 쓰고 지식을 공유하는 이 여정에 기쁨을 느낍니다. Leaflet.js와 React를 함께 사용하면 쉽게 대화형 지도를 생성할 수 있어 구글 맵에 대한 무료이면서 강력한 대안을 제공합니다.\n\n다음 기사에서는 지도에 마커 추가 및 부드러운 확대 기능을 가능하게 함으로써 대화형 매핑의 세계로 더 깊이 들어갈 것입니다. 함께 하면 주니어 및 중급 개발자가 지도 시각화 기술을 마스터하기 위해 가치 있는 풍부한 애플리케이션을 만들 수 있을 것입니다.\n\n\n\n우리가 다룰 다가오는 주제들에 대해 정말 기대돼요. 여러분들도 마찬가지겠죠? 이 시리즈를 통해, 개발자들이 새로운 기술을 탐험하고 창의력을 발휘하여 멋진 애플리케이션을 만들도록 돕고 영감을 주는 것이 제 목표입니다.\n\n이 여정에 함께해 주셔서 감사드리고, 다음 시리즈를 여러분과 함께 나누는 것을 기대할 뿐입니다. 즐겁게 코딩하시고, 다음에 뵙겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedwithLeafletjsandReactRenderingaSimpleMap_0.png","tag":["Tech"],"readingTime":12},{"title":"Reactforce를 사용하는 것이 좋은 아이디어라고 생각하는 ChatGPT세요","description":"","date":"2024-05-12 19:32","slug":"2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea","content":"\n\n다음 글은 ChatGPT가 쓴 것입니다:\n\n![image](/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png)\n\n나: \"salesforce.com에 웹사이트를 배포하는 데 React를 사용하는 장점에 관한 글을 써 주세요.\"\n\nChatGPT:\n\n\n\n# Salesforce에서 웹 배포를 향상시키기 위한 React 활용: IT 임원을 위한 안내서\n\n## EXECUTIVE SUMMARY\n\n기업 기술 분야의 경쟁적 환경에서 IT 임원들은 지속적으로 효율성과 혁신을 향상시키는 전략을 모색하고 있습니다. Salesforce.com과 React를 통합함으로써 복잡한 비즈니스 요구에 부합하는 강력하고 확장 가능한 웹사이트를 배포하는 혁신적인 방법론을 제시합니다. 본 기사는 Salesforce에서 웹 배포를 위해 React를 활용하는 전략적 이점에 대해 다루며 비즈니스 영향과 관리적 통찰을 강조합니다.\n\n## 전략적 개발 장점\n\n\n\n1. 구성 요소 중심의 효율성: React의 구성 요소 기반 구조는 재사용 가능한 코드를 촉진하여 개발 시간과 비용을 줄이며 Salesforce 애플리케이션 전체에서 일관성을 보장합니다. 이 모듈식 접근 방식은 기민한 개발 방법을 용이하게 하여 IT 팀이 비즈니스 요구 사항의 변화에 신속히 대응할 수 있도록 합니다.\n\n2. 간소화된 개발 및 유지 관리: JSX를 활용하여 코딩하는 것은 개발 프로세스를 단순화하여 컨셉에서 배포까지 걸리는 시간을 크게 줄입니다. React의 아키텍처는 미래 업데이트와 유지 보수를 간소화하기도 하며, 비즈니스 영향을 최소화하면서 장기적 기업 애플리케이션을 유지하는 데 중요한 역할을 합니다.\n\n## 사용자 참여 및 성능 향상\n\n3. 고성능 웹사이트: React의 가상 DOM은 웹사이트 성능을 최적화하여 기업 환경에서 일반적인 대규모 데이터셋을 처리하는 데 중요합니다. 이는 더 빠르고 반응적인 웹 애플리케이션을 통해 사용자 만족도와 참여도를 향상시킵니다.\n\n\n\n4. Salesforce Lightning과의 원활한 통합: React를 Salesforce Lightning과 조율함으로써 기관은 생산성과 사용자 도입을 향상시키는 통합 사용자 경험을 누릴 수 있습니다. 이 조합은 비즈니스 사용자를 위한 강력한 인터페이스를 제공하며 Salesforce의 강력한 백엔드 기능을 React의 동적 프론트엔드 기능과 결합합니다.\n\n## 확장성 및 기업 성장\n\n5. 확장 가능한 솔루션: React의 유연성은 비증분 솔루션을 지원하여 비즈니스와 함께 성장할 수 있습니다. 기능을 확장하거나 새로운 서비스를 통합하거나 더 많은 사용자를 수용하기 위해 확장하는 경우, React를 Salesforce와 결합함으로써 웹 인프라가 효율적으로 적응할 수 있도록 보장합니다.\n\n6. 커뮤니티 및 혁신: React의 광범위한 개발자 커뮤니티와 풍부한 생태계를 활용하면 Salesforce 배치에 첨단 혁신을 가져올 수 있습니다. 이러한 다양한 도구 및 라이브러리에 접근하는 것은 개발을 가속화하고 기업의 과제에 첨단 솔루션을 제공할 수 있습니다.\n\n\n\n## 결론\n\n디지털 생태계 내에서 가능한 경계를 넓히려는 IT 임원들에게는 Salesforce 웹사이트 배포를 위해 React를 도입하는 것이 전략적 이점을 제공합니다. 이 조합은 개발을 간소화하고 사용자 경험을 향상시키는 데에 그치지 않고 비즈니스 성장 및 적응성 목표와도 일치합니다. React를 받아들임으로써 기업은 비즈니스 성공을 이끄는 더 매력적이고 성능이 우수하며 확장 가능한 웹 솔루션을 만들 수 있습니다.\n\n## 행동 요령\n\n조직의 웹 전략에 대한 다음 단계를 고려할 때, Salesforce와 React 통합의 잠재적인 영향을 곰곰히 생각해보세요. 이 기술을 귀사의 특정 비즈니스 요구에 맞게 맞춤화하는 방법에 대해 깊이 있게 탐구하려면 귀사의 기업 맥락에 맞춘 통찰력과 실행 전략을 제공할 수 있는 전문가와 상담을 고려해 보세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n## 전략적 개발 장점 (내 생각)\n\n나는 React의 컴포넌트 프레임워크와 미리 만들어진 컴포넌트의 오픈 소스 제공이 Lightning의 동일한 개념보다 훨씬 선두라고 제안할 것입니다. 차이를 알기 위해 둘 다 배워야 하지만... 그저 요약하자면: React = Best\n\n또한 React 개발 과정이 극적으로 더 나은 것에 동의합니다. 당사의 Reactforce 솔루션에는 여기에 약간의 비밀 소스가 있습니다.... 개발에서 Hot Reloading을 지원하고 Salesforce 환경에 오프라인 프록시 액세스도 지원합니다. 이는 개발 워크스테이션에서 로컬로 실행되는 React 서버에서 Salesforce 스크래치 조직(또는 샌드박스)에서 라이브 데이터를 사용하여 React 앱을 구축할 수 있다는 것을 의미합니다. 이것은 React 및 Salesforce 개발자들에게 자랑스럽게 보여주는 소프트웨어 마술입니다.\n\n위 기사에서 ChatGPT가 실제로 이해하지 못하는 것은 React 사이트를 네이티브 Salesforce.com 조직에 배포함으로써, 데이터의 다수 복사본을 관리하기 위해 필요한 모든 데이터 통합, 변환 및 지속적인 지원을 우회하고 있다는 점입니다. React는 JavaScript remoting 또는 LWC 컨트롤러를 통해 Salesforce에 직접적으로 대화하며, 데이터웨어하우스나 운영 데이터 저장소로 미들웨어를 통해 고통스럽게 연결된 중요한 데이터뿐만 아니라 Salesforce 데이터 중 어떤 것이든지 솔루션을 구축하는 놀라운 속도와 유연성을 제공합니다.\n\n\n\n## 사용자 참여 및 성능 향상 (내 생각)\n\nReact에 익숙하지 않다면, 대부분의 사람들이 사용한다는 것만 말씀드립니다. 마이크로소프트 팀즈는 React로 작성되었습니다. Netflix와 지라도 마찬가지입니다. 끝이 없이 많이 있습니다. React로 작성된 웹사이트를 언제든지 표시해주는 크롬 확장 프로그램을 설치할 수 있습니다. 제가 직접 수행한 완전히 비과학적인 연구에 의하면, 가장 빠르고 시각적으로 매력적이며 반응성 있는 사이트 대부분은 대부분 React를 사용하고 있습니다.\n\nReact는 Salesforce Lightning과 비교할 수조차 없습니다. React는 단일 페이지 애플리케이션으로, 전체 사이트가 처음 로드될 때 브라우저로 다운로드됩니다. 애플리케이션은 브라우저로 푼다음 Salesforce (또는 원하는 데이터 소스)로 API 호출을 수행합니다. 단일 페이지 애플리케이션 (SPA)의 최종 결과는 브라우저가 거의 다시로드하지 않고 전체 사이트가 잘 만들어진 iOS 앱처럼 느껴진다는 것입니다. 웹 개발 세계에서 오신 분이라면 이것이 상당히 명백한 사실일 것입니다. Salesforce에서 오신 분이라면... 무엇을 놓치고 있는지 꼭 확인해보세요.\n\nReactforce에는 Salesforce 내부에서는 물론 Classic 또는 Lightning 경험 내에서도 절대적으로 매끈하게 작동하는 React의 비밀 소스가 있습니다. 더 나아가 전체 응용 프로그램을 완전히 렌더링하는 경우(예: 디지털 커뮤니티 경험)에 사용할 때 더욱 우수한 결과를 얻을 수 있습니다. 우리는 React를 사용하여 Salesforce.com에서 네이티브로 호스팅되는 금융 서비스 및 의료 포털을 구축하는 전문가입니다. 대안솔루션과의 차이는 즉시 눈에 띄며, 전체 솔루션에 대해 배울수록 혜택만 커집니다.\n\n\n\n## 확장성 및 기업 성장 (내 생각)\n\nSalesforce에서 실행 중인 React의 확장성에는 몇 가지 기술적 고려 사항이 있습니다. 먼저, React 앱이 페이지 레이아웃에서 내부적으로 실행되는지 아니면 외부적으로 커뮤니티에서 실행되는지에 따라 솔루션이 변경됩니다. 내부에서 실행할 때는 Javascript 리모팅을 사용하여 API 호출을 완전히 우회할 수 있습니다. 이것은 React에서 데이터베이스로 무제한 API 호출을 할 수 있다는 것을 의미합니다. React 앱을 내부적으로 렌더링하고 이 능력을 활용하기 위해 원격 메서드나 라이트닝 컨트롤러를 사용해야합니다.\n\n커뮤니티에서 React 앱을 외부에서 렌더링하는 경우에도 페이지 뷰(원격 메서드 및 Ajax 호출이 페이지 뷰로 계산됨)에 주의해야합니다. 우리는 규모에 맞게 외부 API 호출에 React를 사용하는 것이 비용 효율적인 대안임을 발견했습니다. Salesforce에서 필요한 API 호출을 구매하고, 예전에 고민했던 대부분의 확장성 문제에 대해서는 더 이상 생각하지 않아도 됩니다.\n\n기업은 React를 열렬히 환영할 것입니다. React 앱은 자가 포함되어 배포될 수 있으며 배포된 Salesforce 환경의 모든 보안 규칙을 존중합니다. 이는 혁신적인 창작물을 매우 빠르게 반복할 수 있음을 의미합니다. 또는 Reactforce Enterprise Portal(현재 베타)을 사용하여 회사 인트라넷 또는 익스트라넷을 철저한 솔루션으로 구성할 수 있습니다. 이 솔루션에는 완전히 사용자 정의 가능한 사용자 관리, 고급 경로 구성, 다양한 사이트 테마도 포함되어 있습니다. 마치 당신의 포털을 위한 포털 같아요. 이 애플리케이션에 대해 자랑스럽다고 생각하며, 몇 달 내에 일반 사용자에게 제공될 것으로 기대합니다.\n\n\n\n## 챗지피티(ChatGPT)가 아직은 이해하지 못하는 것들\n\nUI 계층으로 React를 채택하면 CRM 생태계에서 아직은 이해되지 않는 성숙함과 세련됨의 수준을 조직에 제공합니다. 이는 귀하의 직원, 파트너, 그리고 고객들에게 실제로 사용하고 싶어하는 UI 경험을 제공합니다.\n\n웹사이트의 백엔드로 Salesforce를 활용하면 견고하고 확장 가능하며 거의 제로 서포트 솔루션을 제공받을 수 있습니다. Salesforce의 놀라운 데이터베이스와 기업 보안 솔루션에 액세스할 수 있습니다. 귀하의 애플리케이션은 CIO들과 세계 각지의 아키텍트들이 사랑하고 존경하는 안전하고 견고한 인프라에 배포되면서 즉시 귀하의 고객들과 프로젝트 이해관계자들에게 감명을 줄 것입니다.\n\n## 내 인간적 요약\n\n\n\n재밌는 이유가 많아요! Salesforce에서 React를 사용해보는 것을 고려해볼 가치가 충분해요. 사실 저는(15년 경험의 Salesforce.com 및 AWS 전문 기술 아키텍트) 그냥 말하는 게 아니에요. ChatGPT도 이 솔루션이 얼마나 멋진지 아는 것 같아요. 더 많은 정보를 원한다면 직접 이메일 보내주세요: greg@cloudpremise.com.\n\n해피 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png"},"coverImage":"/assets/img/2024-05-12-EvenChatGPTthinksusingReactforceisagoodidea_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요","description":"","date":"2024-05-12 19:30","slug":"2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment","content":"\n\nReact 18가 이미 2년 이상 지난 후에, 이제는 React 19를 환영할 때가 왔습니다. 우리가 모두 사랑하는 주요 혁신은 React 컴파일러입니다! 이는 수동 메모이제이션 최적화가 필요 없어져서 프론트엔드 개발을 영원히 간단히 해 줄 것을 약속합니다.\n\n이 안내서에서는 React 컴파일러가 무엇인지, 어떻게 작동하는지, 어떤 이점을 제공하는지, 그리고 응용 프로그램을 준비하는 방법에 대해 이해하게 될 것입니다.\n\n# React 19가 가져올 혜택\n\nReact 19는 2024년 5월 15일부터 16일에 React Conf 2024에서 발표될 예정이며, 이 프레임워크의 오랫동안 기다려온 다음 버전입니다. React 18은 2022년에 출시되었고, 그 이후로 웹 기술이 크게 발전해 왔습니다. 이제는 업데이트할 때가 왔습니다.\n\n\n\n![React Compiler](/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png)\n\n버전 19는 앞으로 나아갈 한 걸음일 뿐만 아니라, React 애플리케이션을 만드는 방법을 영원히 바꾸어 놓을 것입니다. React 19가 소개할 가장 흥미로운 기능 중 일부는 다음과 같습니다:\n\n- 서버 컴포넌트: 더 빠른 페이지 로딩과 더 나은 SEO를 위한 컴포넌트 서버사이드 렌더링. 서버에서 컴포넌트를 처리하여 페이지를 사용자에게 제공하기 전에, React 19는 웹사이트의 로딩 시간을 빠르게 하고, 검색 엔진 노출도를 향상시키며, 더 부드러운 데이터 관리를 가능하게 합니다. 이미 Next.js가 이 기능을 사용하고 있습니다.\n- 액션: 웹 페이지 내 데이터 및 상호작용 관리를 간소화합니다. 액션은 양식을 통해 페이지 정보를 업데이트하는 작업을 간단하게 만들어 복잡성을 줄이고 사용자 경험을 단순화합니다.\n- 최적화된 자산 로딩: 더 부드러운 페이지 전환을 위해 사이트 자산을 백그라운드에서 로드합니다. React 19는 사용자가 현재 페이지를 둘러 보는 동안 이미지 및 다른 파일을 백그라운드에서 로드하여 페이지 전환 중 대기 시간을 줄입니다.\n- 문서 메타데이터: 새로운 `DocumentHead` 컴포넌트 덕분에 간단한 SEO 관리. 페이지에 제목 및 메타 태그를 추가하는 것이 더 직관적으로 되어 검색 엔진 최적화를 향상시키는 반복적인 코딩을 필요로 하지 않습니다.\n- 웹 컴포넌트: 더 유연하고 호환성이 높은 프론트엔드 개발을 위한 웹 컴포넌트 표준과의 향상된 호환성.\n- 향상된 훅: 기존 및 새로운 훅을 통해 컴포넌트의 라이프사이클과 상태를 더 세밀하게 제어합니다. 최종 목표는 코딩 프로세스를 단순화하여 React 개발을 더 효율적이고 즐겁게 만드는 것입니다.\n- React 컴파일러: React 코드를 표준화된 최적화된 JavaScript 코드로 자동 변환합니다. 상태 변경 시 UI의 올바른 부분만 자동으로 렌더링하도록 컴파일된 React 코드를 허용하여 useMemo, useCallback 및 memo의 필요성을 줄입니다. 이는 단순화된 코드 기반으로 빠른 React 애플리케이션을 의미합니다.\n\n이 모든 기능들은 훌륭하지만 가장 눈에 띄는 것은 React 컴파일러입니다. 이 업그레이드는 React 개발을 영원히 바꿀 것을 약속합니다. 이제 왜 그렇게 생각하게 되었는지와 어떠한 혜택을 제공할지 이해해보도록 하겠습니다!\n\n\n\n# React 컴파일러: 알아야 할 모든 것\n\nReact 19 컴파일러 도구를 자세히 살펴보며, 이 도구가 무엇인지와 어떻게 작동하는지 알아봅니다.\n\n# React의 핵심 메인 모델\n\nReact 컴파일러 뒤에 숨겨진 이유를 이해하려면 먼저 몇 가지 주요한 React 개념을 탐구해야 합니다.\n\n\n\nReact의 핵심은 선언적이고 컴포넌트 기반의 메타 모델에 있습니다. 프론트엔드 개발에서 선언적 프로그래밍은 UI의 원하는 최종 상태를 설명하되 DOM 조작을 통해 각 단계를 명시하지 않고 도달하는 방법을 설명하는 것을 의미합니다. 한편, 컴포넌트 기반 접근 방식은 UI 요소를 재사용 가능하고 간결하며 독립적인 빌딩 블록으로 분해하여 모듈화 및 유지 보수의 용이성을 촉진합니다.\n\n특정 DOM 요소를 식별하여 업데이트해야 할 때, React는 가상 DOM이라고 불리는 사용자 인터페이스의 인메모리 표현을 활용합니다. 애플리케이션 상태 변경이 발생할 경우, React는 가상 DOM을 실제 DOM과 비교하여 필요한 최소한의 변경 사항을 식별하고 정확하게 실제 DOM을 업데이트합니다.\n\n간단히 말하면, React는 애플리케이션의 상태가 변경될 때마다 다시 렌더링합니다. 그러나 때로는 React가 지나치게 반응적일 수 있어 애플리케이션을 심각하게 느리게 만드는 불필요한 다시 렌더링이 발생할 수 있습니다.\n\n# 다시 렌더링 지옥: 컴파일러 필요성\n\n\n\n리액트는 애플리케이션 상태 변화에 민첩하게 대응하는 데 장단점이 있어요. 한편으로는 선언적인 방식을 통해 프론트엔드 개발을 간단하게 만들어 줍니다. 다른 한편으로는 상태 변경에 따른 UI 내 컴포넌트의 지나친 다시 렌더링으로 이어질 수 있어요.\n\n자바스크립트 데이터 구조인 객체와 배열을 다룰 때 특히 다시 렌더링 문제가 일반적으로 발생할 수 있어요. 문제는 두 객체나 배열이 동등한지(동일한 키와 값들을 가지고 있는지) 비교할 수 있는 계산적으로 효율적인 방법이 자바스크립트에는 없다는 것이에요.\n\n다음 시나리오를 고려해 보세요. 각 렌더링마다 새 객체나 배열을 생성하는 리액트 컴포넌트가 있다고 가정해 봅니다. 아래 예시와 같이요:\n\n```js\nimport React from \"react\";\n```\n\n\n\n```js\nconst AlphabetList = () =\u003e {\n  // 알파벳 배열 정의\n  const alphabet = Array.from({ length: 26 }, (_, i) =\u003e String.fromCharCode(65 + i));\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003e알파벳 목록\u003c/h2\u003e\n      \u003cul\u003e\n        {/* 알파벳을 목록 항목으로 렌더링 */}\n        {alphabet.map((letter, index) =\u003e (\n          \u003cli key={index}\u003e{letter}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n};\nexport default AlphabetList;\n```\n\n로컬 배열의 내용이 각 렌더링마다 동일할지라도, React는 그 사실을 효율적으로 알 수 없습니다. 결과적으로, 배열 값에 의존하는 구성 요소의 중첩 DOM 요소에서 재렌더링이 발생할 수 있으며 UI가 동일하게 유지되어야 한다는 사실을 인식하지 못합니다. 이러한 재렌더링 메커니즘은 빠르게 무제한적으로 힘을 쏟아내어 애플리케이션 성능과 사용자 경험에 상당한 영향을 미칠 수 있습니다.\n\n재렌더링 동작을 최적화하고 이러한 문제를 피하기 위해 React 개발자들은 구성 요소에 수동으로 메모이제이션을 도입해야 합니다. React에서 메모이제이션은 비싼 계산 또는 구성 요소 출력의 결과를 캐싱하는 것을 포함하며 입력 매개변수에 기반합니다. 이러한 결과를 저장하고 재사용함으로써 메모이제이션은 구성 요소의 불필요한 다시 읽기를 방지하고 React 애플리케이션의 전체 효율성과 성능을 향상시킵니다.\n\nReact 18은 여러 가지 메모이제이션 도구를 제공합니다:\n\n\n\n\n- React.memo(): 프롭이 변경되지 않은 경우 컴포넌트의 다시 렌더링을 피하기 위한 하이어오더 함수입니다.\n- useMemo(): 재렌더링 사이에 계산 결과를 캐시하는 React 훅으로, 중복된 계산을 줄입니다.\n- useCallback(): React에서 함수 정의를 캐시하여 불필요한 함수 재생성을 피하는 훅입니다. React의 useCallback() 훅에 대해 자세히 알아보세요.\n\nuseMemo() 훅 덕분에 `AlphabetList` 컴포넌트를 최적화하여 불필요한 재렌더링을 피할 수 있습니다. 아래와 같이 구현할 수 있습니다:\n\n```js\nimport React, { useMemo } from \"react\";\n```\n\n```js\nconst AlphabetList = () =\u003e {\n  // useMemo()을 사용하여 알파벳 배열을 정의합니다.\n  const alphabet = useMemo(() =\u003e {\n    return Array.from({ length: 26 }, (_, i) =\u003e String.fromCharCode(65 + i));\n    // 의존성이 없으므로 첫 렌더링 시에만 계산됩니다.\n  }, []);\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003e알파벳 리스트\u003c/h2\u003e\n      \u003cul\u003e\n        {/* 알파벳을 리스트 아이템으로 렌더링합니다. */}\n        {alphabet.map((letter, index) =\u003e (\n          \u003cli key={index}\u003e{letter}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n};\nexport default AlphabetList;\n```\n\n\n\n리액트에서 제공하는 메모이제이션 도구들은 정말 강력해요. 동시에 이를 도입하는 것은 리액트의 핵심적인 메타모델인 선언적 철학과는 명확히 달라요. 개발자들에게 부담을 주는데, UI의 최종 상태뿐만 아니라 렌더링 최적화를 명시적으로 관리해야 해요. 수동 메모이제이션은 코드 복잡성과 유지보수의 어려움을 도입하게 해요.\n\n해결책은 무엇일까요? 리액트 코드를 최적화된 JavaScript 코드로 변환하는 고급 컴파일러입니다. 이를 통해 상태 값이 크게 변경된 경우에만 컴포넌트가 자동으로 다시 렌더링되도록 할 수 있어요.\n\n# 리액트 컴파일러란 무엇인가요?\n\n리액트 컴파일러, 또는 리액트 포겟으로도 알려진 이것은 리액트를 위한 최적화 컴파일러에요. 지금은 인스타그램의 웹 포털에서 사용되고 있으며, 첫 번째 오픈 소스 릴리스 전에 다른 메타 어플리케이션에 배포될 예정이에요.\n\n\n\n컴파일러의 초기 목표는 React의 핵심 프로그래밍 모델을 강제로 적용하여 memo, useMemo 및 useCallback 호출의 동등물을 자동으로 생성하여 다시 렌더링 비용을 최소화하는 것이었습니다. 이 프로젝트는 \"자동 메모이징 컴파일러\"에서 \"자동 반응성 컴파일러\"로 크게 발전했습니다.\n\n지금의 React Forget의 진짜 목표는 React 애플리케이션이 기본적으로 적절한 반응성을 갖도록 보장하는 것입니다. 다시 말해, 앱은 상태 값이 의미 있는 변화가 있을 때에만 다시 렌더링되어야 합니다. 현재 React는 객체 식별이 변경될 때 구성요소를 다시 렌더링합니다. 그러나 React Forget를 사용하면 객체의 의미적 값이 변경될 때에만 다시 렌더링되지만 심층 비교의 런타임 비용을 지불하지 않습니다.\n\n구현 관점에서 React Compiler는 자동 메모이제이션을 적용합니다. 그러나 이를 제작한 팀은 반응성 프래밍을 이해하는 더 완전한 방법으로 간주합니다. React 컴파일러의 내부 작업 및 논리에 대해 자세히 알고 싶다면 React Labs 섹션의 해당 내용을 읽어보세요.\n\n아래 비디오에서 React Forget의 작동을 확인하세요: [여기를 클릭하세요](https://www.youtube.com/watch?v=qOQClO3g8-Y\u0026)\n\n\n\n자바스크립트는 동적 성격과 느슨한 규칙 때문에 최적화하기 어렵다는 것으로 유명합니다. 그러나 React Compiler는 JavaScript 규칙과 \"React의 규칙\"을 모델링하여 코드를 안전하게 컴파일할 수 있습니다. 이러한 규칙은 개발자들이 할 수 있는 일을 제한하여 컴파일러가 최적화 작업을 수행할 안전한 공간을 마련합니다.\n\n# React의 규칙\n\nReact는 고품질 웹 애플리케이션을 지원하기 위해 고안된 규칙 세트와 함께 제공됩니다. 개발자들은 이러한 규칙을 따라야 하며, 이는 React Compiler가 기반으로 하는 것과도 일맥상통합니다.\n\nReact의 가장 중요한 규칙 중 일부는 다음과 같습니다:\n\n\n\n- 컴포넌트는 idempotent해야 합니다: React 컴포넌트는 항상 동일한 출력물을 생성해야 합니다. 입력값으로는 props, state 및 context가 포함됩니다.\n\n- 사이드 이펙트는 렌더링 외부에서 실행되어야 합니다: 데이터 가져오기, 구독 또는 수동으로 DOM을 변경하는 사이드 이펙트는 컴포넌트의 렌더링 프로세스 중에 수행해서는 안 됩니다. 대신에 useEffect와 같은 라이프사이클 훅에서 실행되어야 합니다.\n\n- Props와 state는 불변해야 합니다: React 컴포넌트의 props와 state는 불변으로 취급되어야 합니다. 직접 수정해서는 안되며, props 또는 state를 직접 변경하는 것은 버그와 예측할 수 없는 작동을 유발할 수 있습니다.\n\n- 훅에 대한 반환 값 및 인수는 불변해야 합니다: 값이 React 훅에 전달된 후에는 수정해서는 안 됩니다. 훅은 인수와 반환 값을 변경하지 않음으로써 컴포넌트 동작의 일관성과 예측 가능성을 유지합니다.\n\n- JSX에 전달된 값은 불변해야 합니다: 렌더링된 후 JSX에서 사용된 값은 변형해서는 안 됩니다. 필요한 변형은 렌더링된 JSX 이전에 수행되어야 하며, 이를 통해 렌더링된 출력물이 일관되게 유지됩니다.\n\n- 컴포넌트 함수를 직접 호출하지 말아야 합니다: React 컴포넌트는 JSX 내부에서만 사용되어야 하며, 일반 함수처럼 직접 호출해서는 안 됩니다.\n\n- 훅을 일반 값처럼 전달하지 마세요: useState나 useEffect와 같은 React 훅은 함수형 컴포넌트 내부에서만 호출되어야 합니다. 이를 일반 값으로 사용하는 것은 예상치 못한 동작을 유발하고 훅 규칙을 위반할 수 있습니다.\n\n- 훅은 항상 최상위 수준에서 호출해야 합니다: React 훅은 항상 함수형 컴포넌트의 최상위 수준에서 호출해야 하며, 어떠한 조건문이나 반복문보다 먼저 호출되어야 합니다. 이렇게 함으로써 훅이 모든 렌더링에서 동일한 순서로 호출되고 의도한 동작을 유지합니다.\n\n- React 함수에서만 훅을 호출해야 합니다: 훅은 React 함수 컴포넌트나 사용자 정의 훅 내부에서만 호출해야 합니다. 일반 JavaScript 함수에서 훅을 호출하는 것은 오류를 유발할 수 있으며 훅 규칙을 위반합니다.\n\nStrict Mode를 활성화하고 React의 ESLint 플러그인을 구성하여 React 애플리케이션이 이러한 규칙을 준수하도록하세요.\n\n# 이점과 희망\n\nReact Compiler에 의해 제공되는 주요 이점은:\n\n\n\n- 더 이상 메모이제이션에 대한 골치 아픔이 없어졌어요: 개발자들은 이제 코드에서 메모이제이션 전략을 수동으로 구현하고 관리할 필요가 없습니다. 이로 인해 복잡성과 오류 가능성이 줄어들며 개발 프로세스가 간소화됩니다.\n- 개발자 경험이 더 나아졌어요: 개발자들은 기능 구축에 더 집중하고 성능 최적화에 덜 신경 쓸 수 있어서 생산성과 만족도가 높아졌어요. 이제 React 선언적 접근 방식을 완전히 받아들일 수 있을 거에요.\n- 빠른 React 애플리케이션: 필요할 때만 컴포넌트를 렌더링하여 불필요한 계산과 오버헤드를 최소화해요. 이로 인해 빠르고 반응성이 높은 사용자 인터페이스를 구현할 수 있어 전체 성능과 사용자 경험이 개선됩니다.\n\n이 모든 것들은 흥미로운 변화이지만, 이 새로운 도구가 코드 개발에 미치는 영향을 아직 보지 못했어요. 컴파일러가 제대로 작동하기 위해서는 코드가 React 규칙을 준수해야 해요. 공식팀이 ESLint와 같은 도구를 도입하여 React 컴파일러를 위해 애플리케이션을 준비하는 것을 권장하는 이유가 여기 있어요.\n\n# React 컴파일러: 프론트엔드 혁명?\n\nReact 컴파일러가 프론트엔드 개발 영역에서 진정한 혁명을 일으킬 만큼 충분할지는 곧 알 수 있을까요. 확실한 것은, 이 컴파일러가 미래의 React 애플리케이션 개발을 크게 변화시킬 자격이 있다는 것입니다. 자동 메모이제이션을 도입함으로써, 이 컴파일러는 React 애플리케이션의 속도를 자동으로 향상시키고 개발자 경험을 향상시킬 수 있어요. 이 야심찬 프로젝트가 가져다 주는 혜택 중 일부일 뿐이에요.\n\n\n\nReact Conf 2024가 곧 다가오고 있으니, 이 야심찬 프로젝트가 프론트엔드 세계에 미칠 혁신을 기대해 봅니다!\n\n원문은 2024년 5월 9일 https://semaphoreci.com에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png"},"coverImage":"/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 앱이 정상적으로 작동할 때 리액트 네이티브 문제를 해결하는 방법","description":"","date":"2024-05-12 19:29","slug":"2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks","content":"\n\n지난번에 React Native 앱을 작업한 건 이미 3년 전이에요. 그리고 이에 대해 글을 쓰고 싶은 마음은 오랫동안 가지고 있었는데 항상 잊어버렸었어요. 그 때는 블록체인 NFT 프로젝트도 함께 진행했었는데, 그 이야기는 다른 날에 별도로 다룰 거예요 (이 \"팁\" 글 말고 흥미로운 이야기가 될 거라고 약속해요). 비슷한 문제에 직면하고 있다면 임시 방편을 이용할 아이디어를 제공하려고 해요.\n\n# 상황\n\n이전 프로젝트는 '비전을 가진' 창업자들이 이끄는 스타트업 회사에 관련된 건데, 안타깝게도 구체적인 계획이 부족했고 성공적인 자금 마련을 할 수 없었기 때문에 제 봉급을 지급하지 못했어요 🤷‍♂️. 저는 랜딩 페이지와 모바일 앱을 동시에 만드는 것을 담당한 유일한 개발자였어요.\n\n앱은 3D 아바타를 특징으로 하는 모바일 커뮤니케이션(채팅) 플랫폼이었고, 사용자들은 채팅 앱 내에서 사용할 NFT를 구매할 수 있었어요. React에 익숙했기 때문에 3D 렌더링 라이브러리를 조사하고 React로 작동하는 PoC를 몇 시간 동안 개발한 후, React Native를 사용하여 앱을 만들기로 결정했어요. \"결국 React인데; 얼마나 다를까?\" 라고 생각했어요.\n\n\n\n# 문제\n\n“채팅 앱\"을 마치고 기분 좋았는데, 팔을 걷어내고 내 헤비 메탈 플레이리스트에서 고함 소리를 들으며 흥을 냈습니다. 간단한 3D 모델들은 잘 작동했지만, 이후 이를 렌더링할 수 없는 문제가 발생했어요. 이는 애니메이션이 포함된 3D .FBX 파일인 이진 파일을 렌더링할 수 없었던 것이었습니다. 찾아봐도 (그 때 chatGPT는 그리 도움이 되지 못했습니다) React Native 자체가 배열 버퍼를 지원하지 않는다는 것을 알 수 없었죠. 현재 해결되었는지는 확실하지 않습니다.\n\n시간이 없어서 일반 React 앱에서 로드해보았는데, 잘 작동했어요. 핸드폰으로 웹 앱을 시작해봤을 때도 문제없이 작동했습니다. 데모 날이 다가오고 있어서 그 주에 문제를 해결해야 했어요.\n\n그래서 React Native 기술 스택을 사용하는 시니어 모바일 개발자인 전 동료에게 도움을 요청했지만, 안타깝게도 그도 문제를 해결하지 못했습니다.\n\n\n\n내가 가진 제한된 시간과 기술로 React Native 코어에 깊게 파보는 일은 할 수 없었어요. 그 당시에는 절망에 빠져 있었습니다.\n\n# “가끔 어둠이 너에게 빛을 비춰줄 수도 있어\" — Disturbed\n\n어둔 시기에 멘토가 제안했어요: “React Native 앱에 웹 앱을 넣어본다면 어떨까?\"\n\n![이미지](/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png)\n\n\n\n그래서, 나는 React 앱을 Vercel에 호스팅하고 React Native 앱으로 WebView로로드하는 것을 시도했고 완벽하게 작동했어요.\n\niframe과 상호 작용하기 위해 수백만 개의 블로그가 안내를 제공하고 있어, 또는 그냥 chatGPT에게 물어보면 돼요, 그래서 여기에는 넣을게 없어요.\n\n문제는 해결됐지만, 문제는 전체 블록체인 및 NFT 트렌드가 붕괴되었을 때 피칭이 잘못된 시간에 있었고, 정말 필요한 때에 돈을 사칭 당했어요—내 결혼식을 위해서!!!\n\n고객 중심적 사고 방식을 가지고 있다면(https://medium.com/@whoz_/beyond-code-dont-just-be-a-coder-a9bad8007dca), 다양한 경우에이 해결책이 도움이 될 수 있어요. 시장을 빨리 점령하기 위해 제대로 작동하도록 시간을 낭비하지 않아도 돼요. 시장에 올 때 좋은 앱을 가지고 있다해도, 고객이 정말 필요하지 않을 때나 피드백에 따라 다시 작업하기에 너무 늦었을 때 그 점이 어떤 의미가 있겠어요?\n\n\n\ntldr; 만약 React Native 앱에 문제가 있지만 React 앱은 핸드폰 브라우저에서 잘 작동한다면 WebView을 통해 React Native에 임베드해보세요.","ogImage":{"url":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png"},"coverImage":"/assets/img/2024-05-12-AWorkaroundforYourReactNativeIssuesWhentheStandardBrowserReactAppWorks_0.png","tag":["Tech"],"readingTime":2},{"title":"패키지-락json 완전 가이드","description":"","date":"2024-05-12 19:28","slug":"2024-05-12-package-lockjsonTheCompleteGuide","content":"\n\n## package-lock.json이란 무엇이고, 왜 신경 써야 하나요?\n\n### package.json이란?\n\npackage.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.\n\n또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png\" /\u003e\n\n# 고유한 문제\n\n위의 package.json에서 \"dependencies\" 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png\" /\u003e\n\n\n\n이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.\n\n게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.\n\n그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ ` ||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x, `=2.3.4, `1.0.9 ||\n\n![image](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png)\n\n\n\n이 기호들은 npm에게 다른 정보를 전달해요:\n\n예를 들어, \"foo\" 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:\n\n```js\n{\n  \"dependencies\": {\n    \"foo\": \"^2.3.0\",\n    ...\n    ...\n  }\n}\n```\n\n여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:\n\n\n\n^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)\n\n~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)\n\n다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.\n\n따라서 \"foo\": \"^2.3.0\"의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...\n\n\n\n# 패키지 잠금파일(package-lock.json)이란?\n\n![이미지](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png)\n\n패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).\n\n- 이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.\n- 패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.\n- 이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.\n- 저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png\" /\u003e\n\n# 패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?\n\n네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.\n\n# 참고로\n\n\n\n저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:\n\n# npm install이 package-lock.json을 다시 작성하는 이유 / 시기\n\n- 📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.\n- 잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.\n- package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.\n\n예를 들어,\n\n\n\n패키지.json에서는 종속성을 다음과 같이 선언합니다:\n\n```js\n\"foo\": \"^2.3.0\"\n```\n\n그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:\n\n```js\n\"foo\": \"2.3.0\"\n```\n\n\n\n몇 일 후에, \"foo\"의 새로운 부 버전인 \"2.4.0\"이 출시됩니다. 그리고 이렇게 됩니다:\n\nnpm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.\nnpm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.\n\n다음으로, package.json을 수동으로 업데이트합니다:\n\n```js\n\"foo\": \"^2.4.0\"\n```\n\n\n\n그럼 다시 실행해주세요:\n\nnpm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:\n\"foo\": \"2.4.0\"\n\nnpm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.\n\nnpm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)\n\n\n\n# 간단히 말해요:\n\n- npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.\n- package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.\n- 최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.","ogImage":{"url":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"React-js를 이용한 초보자를 위한 Socketio를 활용한 간단한 채팅 애플리케이션","description":"","date":"2024-05-12 19:26","slug":"2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners","content":"\n\n안녕하세요 여러분! 이 글에서는 socket.io와 React js를 사용하여 간단한 채팅 애플리케이션을 만드는 방법에 대해 알아볼 거에요. 특히 초보자분들을 위한 내용으로 모든 단계를 차근차근 알려드릴 거에요. 마지막에는 React-js로 간단한 채팅 애플리케이션을 만들게 될 거에요.\n\n![SimpleChatappusingSocketioInReact-jsForBeginners](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png)\n\n## Socket.io란 무엇인가요?\n\nSocket.IO는 웹 클라이언트와 서버 간 실시간 양방향 통신을 용이하게 하는 강력한 JavaScript 라이브러리입니다. 사용자와 응용 프로그램 간 즉각적인 데이터 교환을 허용하는 다리 역할을 하며, 라이브 채팅, 멀티플레이어 게임 및 협업 편집 도구와 같은 참여형 경험을 만들기에 이상적입니다. 강력한 기능과 사용 편의성을 갖춘 Socket.IO는 현대적이고 인터랙티브한 웹 애플리케이션을 구축하기 위한 주요 기술로 자리잡았습니다.\n\n\n\n단계 1: 새 폴더 생성하기\n\n여기서 빈 폴더를 생성합니다. 이 폴더 안에 클라이언트 측(react)과 서버 측(socket.io)의 2개 개별 폴더를 생성합니다.\n\n```js\nmkdir react-chatapp\ncd react-chatapp\n```\n\n단계 2: socket.io를 사용하여 소켓 만들기\n\n\n\n먼저 서버 측 작업을 위해 서버 폴더를 만들어야 해요. 다음 명령어를 사용하세요.\n\n```js\nmkdir server\ncd server\n```\n\n새로운 Node.js 프로젝트를 초기화하세요:\n\n```js\nnpm init -y\n```\n\n\n\n\nsocket.io 라이브러리 설치하기\n\n```js\nnpm install socket.io\n```\n\nsocket.io를 설치한 후 server.js 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst server = http.createServer((req, res) =\u003e {\n    res.end('Hello World');\n});\n\nconst io = new Server(server, {\n    cors: {\n        origin: \"*\",\n        methods: [\"GET\", \"POST\"]\n    }\n});\n\nio.on('connection', (socket) =\u003e {\n    console.log('사용자가 연결되었습니다.');\n\n    socket.on('message', (message) =\u003e {\n        io.emit('message', message);\n    });\n\n    socket.on('disconnect', () =\u003e {\n        console.log('사용자가 연결을 끊었습니다.');\n    });\n});\n\nconst PORT = process.env.PORT || 4000;\n\nserver.listen(PORT, () =\u003e {\n    console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n\n\n여기, 이 코드는 Node.js의 내장 http 모듈을 사용하여 기본 HTTP 서버를 설정하고 Socket.IO 서버를 연결하는 방법을 보여줍니다. Socket.IO 서버는 클라이언트 연결을 수신하고 모든 연결된 클라이언트에 메시지를 브로드캐스트하며 클라이언트가 연결 또는 연결 해제될 때 로그를 기록합니다.\n\n단계 3: React js에서 Socket.io 구현\n\n\"react-chatapp\" 폴더로 이동하여 리액트 프로젝트를 만듭니다.\n\n```sh\nnpx create-react-app client\n```\n\n\n\n리액트 프로젝트를 설치한 후 프로젝트 안으로 이동하여 의존성을 설치하세요.\n\n```js\ncd client\nnpm start\n```\n\n리액트 기본 의존성을 설치한 후 socket.io-client와 부트스트랩 라이브러리를 리액트에 설치하세요.\n\n```js\nnpm install socket.io-client bootstrap\n```\n\n\n\n- Socket.IO-Client:\n\n- socket.io-client은 Socket.IO를 위한 클라이언트 측 라이브러리로, 실시간 양방향 통신 라이브러리입니다.\n- 이를 통해 웹 클라이언트(예: 브라우저)가 Socket.IO 서버와 연결을 설정하고 실시간으로 통신할 수 있습니다.\n- 서버에 이벤트를 전송하거나 서버로부터 받은 이벤트를 처리하는 방법을 제공합니다.\n- socket.io-client를 사용하면 채팅, 실시간 업데이트, 협업과 같은 기능을 지원하는 대화형 웹 애플리케이션을 개발할 수 있습니다.\n\n2. Bootstrap:\n\n- Bootstrap은 반응형 및 모바일 우선 웹 프로젝트를 구축하기 위한 인기 있는 프론트엔드 프레임워크입니다.\n- 버튼, 폼, 내비게이션 바와 같은 사전 스타일이 적용된 CSS 컴포넌트 및 모달, 툴팁과 같은 JavaScript 플러그인을 제공합니다.\n- Bootstrap의 그리드 시스템을 통해 다양한 화면 크기와 장치에 대응하는 반응형 레이아웃을 생성할 수 있습니다.\n- Bootstrap을 사용하면 다양한 준비가된 컴포넌트와 스타일을 제공하여 웹 애플리케이션을 디자인하고 스타일링하는 데 시간과 노력을 절약할 수 있습니다.\n\n\n\n그럼 src/App.js 파일로 이동하여 다음 코드로 교체하세요\n\nsrc/App.js\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport '../src/App.css';\nimport io from 'socket.io-client';\n\nconst socket = io('http://localhost:4000');\n\nfunction App() {\n  const [messages, setMessages] = useState([]);\n  const [username, setUsername] = useState('');\n  const [isUsernameSubmitted, setIsUsernameSubmitted] = useState(false);\n  const [inputMessage, setInputMessage] = useState('');\n  const [isUsernameSet, setIsUsernameSet] = useState(false);\n\n  useEffect(() =\u003e {\n    const storedUsername = localStorage.getItem('username');\n    if (storedUsername) {\n      setUsername(storedUsername);\n      setIsUsernameSet(true);\n    }\n\n    socket.on('message', (message) =\u003e {\n      setMessages((prevMessages) =\u003e [...prevMessages, message]);\n    });\n\n    return () =\u003e {\n      socket.off('message');\n    };\n  }, []);\n\n  const handleUsernameChange = (e) =\u003e {\n    setUsername(e.target.value);\n  };\n\n  const handleUsernameSubmit = () =\u003e {\n    localStorage.setItem('username', username);\n    setIsUsernameSubmitted(true);\n  };\n\n  const handleMessageSend = () =\u003e {\n    if (!inputMessage.trim()) return;\n\n    socket.emit('message', {\n      username,\n      text: inputMessage\n    });\n\n    setInputMessage('');\n  };\n\n  return (\n    \u003cdiv className=\"container mt-5\"\u003e\n      \u003cdiv className=\"row justify-content-center\"\u003e\n        \u003cdiv className=\"col-md-6\"\u003e\n          \u003cdiv className=\"card\"\u003e\n            \u003cdiv className=\"card-body\"\u003e\n              \u003ch5 className=\"card-title text-center mb-4\"\u003eChat App\u003c/h5\u003e\n              {!isUsernameSubmitted ? (\n                \u003cdiv\u003e\n                  \u003cdiv className=\"mb-3\"\u003e\n                    \u003cinput\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"사용자 이름 입력\"\n                      value={username}\n                      onChange={handleUsernameChange}\n                    /\u003e\n                  \u003c/div\u003e\n                  \u003cbutton\n                    className=\"btn btn-primary btn-block\"\n                    onClick={handleUsernameSubmit}\n                  \u003e\n                    사용자 이름 설정\n                  \u003c/button\u003e\n                \u003c/div\u003e\n              ) : (\n                \u003cdiv\u003e\n                  \u003ch4 className=\"text-center mb-4\"\u003e환영합니다, {username}님!\u003c/h4\u003e\n                  \u003cdiv className=\"message-container row\"\u003e\n                    {messages.map((msg, index) =\u003e (\n                      \u003cdiv key={index} className=\"message col-md-8 offset-md-2\"\u003e\n                        \u003cstrong\u003e{msg.username}:\u003c/strong\u003e {msg.text}\n                      \u003c/div\u003e\n                    ))}\n                  \u003c/div\u003e\n                  \u003cdiv className=\"input-group mb-3\"\u003e\n                    \u003cinput\n                      type=\"text\"\n                      className=\"form-control\"\n                      placeholder=\"메시지 입력...\"\n                      value={inputMessage}\n                      onChange={(e) =\u003e setInputMessage(e.target.value)}\n                    /\u003e\n                    \u003cbutton\n                      className=\"btn btn-primary\"\n                      onClick={handleMessageSend}\n                    \u003e\n                      전송\n                    \u003c/button\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n              )}\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n이 코드에서는 React와 Socket.IO를 사용하여 실시간 채팅 애플리케이션을 만드는 과정을 안내하겠습니다. 우리는 먼저 애플리케이션의 기본 구조를 설정한 다음 사용자가 실시간으로 메시지를 보내고 받을 수 있도록 기능을 점진적으로 추가할 것입니다.\n\n\n\n단계 1: 사용자 이름 입력 컴포넌트 생성\n\n- 먼저 UsernameInput이라는 React 컴포넌트를 만드세요. 이 컴포넌트는 사용자가 사용자 이름을 입력할 수 있는 입력 필드를 렌더링합니다.\n- useState 훅을 사용하여 사용자 이름 입력 필드의 상태를 관리하세요.\n- 사용자 이름이 제출되었는지 여부에 따라 채팅 인터페이스를 조건부로 렌더링하세요.\n\n단계 2: 채팅 인터페이스 표시\n\n- 사용자가 사용자 이름을 제출하면 채팅 인터페이스를 표시하세요.\n- 메시지를 입력할 수있는 입력 필드와 메시지를 전송하는 버튼을 제공하세요.\n- 사용자 이름이 제출되었을 때에만 채팅 인터페이스를 표시하도록 조건부 렌더링을 사용하세요.\n\n\n\n단계 3: 메시지 제출 처리\n\n- 메시지 제출을 처리하기 위해 handleMessageSend라는 함수를 정의하십시오.\n- 사용자가 전송 버튼을 클릭하면이 함수를 호출하여 Socket.IO를 통해 서버로 메시지를 전송하십시오.\n- useState 훅을 사용하여 입력 메시지 필드의 상태를 관리하고, 메시지를 전송 한 후에 필드를 지우십시오.\n\n단계 4: 실시간 통신을 위한 Socket.IO 통합\n\n- socket.io-client 라이브러리를 가져와 Socket.IO 서버에 연결을 설정하십시오.\n- 서버에 io 함수를 사용하여 연결하고 서버 URL을 제공하십시오.\n- 서버에서 수신된 메시지를 처리하는 이벤트 리스너를 정의하십시오.\n- 사용자가 메시지를 보낼 때 서버로 메시지를 발신하고, 클라이언트와 서버 간의 양방향 통신을 보장하십시오.\n\n\n\n그럼 src/App.css 파일 안으로 들어가서 다음 코드를 다음과 같이 바꿔주세요.\n\nsrc/App.css\n\n```css\nbody{\n  background-color: cadetblue;\n}\n\n/* Card를 가운데 정렬 */\n.card {\n  margin-top: 50px;\n}\n\n/* 메시지 컨테이너를 스타일링 */\n.message-container {\n  max-height: 300px;\n  overflow-y: auto;\n  padding: 10px;\n}\n\n/* 각각의 메시지 스타일링 */\n.message {\n  background-color: burlywood;\n  padding: 10px;\n  margin-bottom: 5px;\n  border-radius: 5px;\n}\n\n/* 입력 그룹을 스타일링 */\n.input-group {\n \n  /* bottom: 0;\n  left: 0;\n  right: 0; */\n  padding: 15px;\n  /* background-color: #f9f9f9;\n  border-top: 1px solid #ccc; */\n}\n```\n\n위 단계를 모두 완료하면 서버를 실행할 시간입니다.\n서버 폴더로 이동하여 다음 명령어를 실행하세요.\n\n\n\n```js\nnode server.js\n```\n\n다음으로, client 폴더로 이동하여 다음 명령어를 실행하세요\n\n```js\nnpm start\n```\n\n결과:\n\n\n\n![이미지 1](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_1.png)\n\n![이미지 2](/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_2.png)\n\n도움이 되길 바라요...","ogImage":{"url":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png"},"coverImage":"/assets/img/2024-05-12-SimpleChatappusingSocketioInReact-jsForBeginners_0.png","tag":["Tech"],"readingTime":8}],"page":"138","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"138"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>