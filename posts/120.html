<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/120" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/120" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기" href="/post/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="400줄의 코드로 나만의 Reactjs 만들기" href="/post/2024-05-14-BuildYourOwnReactjsin400LinesofCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="400줄의 코드로 나만의 Reactjs 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="400줄의 코드로 나만의 Reactjs 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">400줄의 코드로 나만의 Reactjs 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법" href="/post/2024-05-14-HowToCreateTabsComponentWithReactContextAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다음 시리즈 101 Inversify를 활용한 IoC 구현" href="/post/2024-05-14-Next101IoCImplementationwithInversify"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다음 시리즈 101 Inversify를 활용한 IoC 구현" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다음 시리즈 101 Inversify를 활용한 IoC 구현" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">다음 시리즈 101 Inversify를 활용한 IoC 구현</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라이언트 측 React 문제 해결을 위한 Date API 수정하기" href="/post/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라이언트 측 React 문제 해결을 위한 Date API 수정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라이언트 측 React 문제 해결을 위한 Date API 수정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">클라이언트 측 React 문제 해결을 위한 Date API 수정하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해" href="/post/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자큐 리 틱톡 비디오 논쟁 공개 휴스턴 학교 선생님의 학생들과의 논란 끝 판결" href="/post/2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자큐 리 틱톡 비디오 논쟁 공개 휴스턴 학교 선생님의 학생들과의 논란 끝 판결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자큐 리 틱톡 비디오 논쟁 공개 휴스턴 학교 선생님의 학생들과의 논란 끝 판결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자큐 리 틱톡 비디오 논쟁 공개 휴스턴 학교 선생님의 학생들과의 논란 끝 판결</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에 Husky를 추가하는 방법" href="/post/2024-05-14-HowtoaddhuskytoReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에 Husky를 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoaddhuskytoReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에 Husky를 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에 Husky를 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다" href="/post/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱에서 ESLint와 Prettier 설정하기" href="/post/2024-05-14-SetupESLintandPrettierinReactApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱에서 ESLint와 Prettier 설정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱에서 ESLint와 Prettier 설정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱에서 ESLint와 Prettier 설정하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link posts_-active__YVJEi" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"TurboRepo, Nextjs 및 Tailwind CSS를 사용하여 Monorepo 설정하기","description":"","date":"2024-05-14 10:31","slug":"2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS","content":"\n\n현대 웹 애플리케이션이 크기와 복잡성 모두 증가함에 따라, 개발자들은 코드베이스를 더 효율적으로 관리할 방법을 찾고 있습니다. 모노리포는 여러 프로젝트를 단일 저장소에서 관리할 수 있는 솔루션을 제공합니다.\n\n그러나 모노리포를 수동으로 설정하는 것은 거대한 작업일 수 있습니다. 여기서 Turborepo가 나타납니다. Turborepo는 여러 단계를 자동화하여 모노리포를 만드는 프로세스를 간소화하는 도구입니다. 이 글에서는 Turborepo를 사용하여 Next.js(기본 프로젝트)를 프로젝트 베이스로, Tailwind CSS를 스타일링으로 포함하는 모노리포를 설정해보겠습니다.\n\n시작해봅시다!\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png)\n\n\n\n# 1. 새로운 Monorepo 생성하기\n\n먼저 다음 명령어를 사용하여 Turborepo Monorepo를 만들어보겠습니다:\n\n```js\nnpx create-turbo@latest\n```\n\n이 명령어를 실행하면, 생성 위치를 선택하고 패키지 매니저를 선택하라는 프롬프트가 표시됩니다. 본 문서에서는 yarn을 사용하겠지만, npm이나 pnpm과 같은 원하는 패키지 매니저를 선택할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_1.png\" /\u003e\n\n설치가 완료되면 디렉토리로 이동하세요 (cd yourProjectName) 그리고 원하는 IDE에서 프로젝트를 열어보세요.\n\n이제 다음 명령어를 사용하여 실행 테스트를 할 수 있습니다.\n\n```js\nyarn install \u0026\u0026 yarn dev\n```\n\n\n\n만약 당신의 터미널이 아래와 같이 나타나면, 세팅이 완료된 것입니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_2.png)\n\n## 2. 디렉터리 설명\n\n자, 이제 Turborepo에 의해 생성된 폴더 구조와 프로젝트에 대해 이야기해보겠습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_3.png)\n\n- apps는 이 단일 리포지토리에 있는 모든 애플리케이션입니다. 기본적으로 (npx create-turbo@latest로부터), docs 및 web 애플리케이션(Next.js)이 생성됩니다.\n- packages 파일에는 eslint, tsconfig 및 모든 리포지토리 전체에 걸쳐 요소를 지배하는 공유 구성요소가 포함됩니다.\n- package.json 이 설정의 주목할만한 측면 중 하나는 Yarn 작업 영역을 사용하여 단일 리포지토리 내에서 여러 패키지와 종속성을 관리할 수 있다는 것입니다. package.json에는 또한 apps 디렉터리에서 단일 리포지토리의 애플리케이션을 실행하는 데 필요한 종속성 및 스크립트도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_4.png)\n\n- turbo.json은 Turborepo가 파이프라인을 구성하고 관리하는 데 사용하는 구성 파일입니다. 이 파이프라인은 특정한 순서로 실행되는 일련의 명령을 조직화하고 관리합니다. 예를 들어 빌드 파이프라인은 신뢰성과 효율성을 위해 ^로 표시된 dependsOn 기호와의 위상적인 종속성에 의존할 수 있습니다.\n\n\n\n# 3. Tailwind CSS 설정하기\n\n다양한 프로젝트에서 tailwind.config.js 파일이 단일 정보 원천으로 작용하도록 보장하기 위해, packages 폴더 내에 새 구성 패키지를 생성할 예정입니다. 이는 앱과 packages/ui 디렉토리 모두에서 Tailwind 클래스를 사용할 수 있게 해줍니다.\n\n다음 단계를 따를 것입니다:\n\n## A. packages 폴더에 Tailwind CSS 구성 설정하기\n\n\n\n- 먼저 packages 디렉토리 내에 configs 폴더를 생성합니다. 이 폴더 안에 package.json, tailwind.config.js 및 postcss.config.js와 같은 설정에 필요한 여러 필수 파일을 생성할 것입니다.\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_5.png)\n\npackage.json\n\n```js\n{\n  \"name\": \"@mrizkiaiman/configs\",\n  \"version\": \"0.0.0\",\n  \"private\": true\n}\n```  \n\n\n\n```js\ntailwind.config.js\n\nmodule.exports = {\n  content: [\n    \"../../packages/ui/**/*.{js,ts,jsx,tsx}\",\n    \"./**/*.{js,ts,jsx,tsx}\",\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n};\n```\n\npostcss.config.js\n\n```js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n```\n\n\n\n## B. 앱 내에서 Tailwind CSS 구성 구현\n\n- 루트 디렉토리에서 다음 명령을 실행하세요\n\n```js\nyarn workspace docs add -D tailwindcss autoprefixer\n```\n\n2. tailwind.config.js 및 postcss.config.js 파일을 생성하세요\n\n\n\n좋아요! 여기서 테이블 태그를 마크다운 형식으로 변경했습니다:\n\n\n| 파일명            | 설정 내용                                       |\n|----------------------|-----------------------------------------------------|\n| tailwind.config.js    | `module.exports = require(\"@mrizkiaiman/configs/tailwind/tailwind.config\");` |\n| postcss.config.js       | `module.exports = require(\"@mrizkiaiman/configs/tailwind/postcss.config\");` |\n\n\n\n\n3. 패키지/ui 폴더로 이동하여 다음 파일을 생성하세요: tailwind.config.js, postcss.config.js, 그리고 styles.css\n\ntailwind.config.js\n\n```js\nmodule.exports = require(\"@mrizkiaiman/configs/tailwind/tailwind.config\");\n```\n\npostcss.config.js\n\n\n\n```js\r\nmodule.exports = require(\"@mrizkiaiman/configs/tailwind/postcss.config\");\r\n```\n\nstyles.css\n\n```js\r\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\r\n```\n\n4. apps/docs 폴더로 돌아가서 pages 디렉토리로 이동하세요. 모노레포의 Tailwind CSS 초기화를 위해 이전에 생성한 전역 스타일을 가져오는 _app.tsx 파일을 만드세요.\n\n\n\n_app.tsx\n\n```js\nimport \"ui/styles.css\";\n\nimport type { AppProps } from \"next/app\";\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return \u003cComponent {...pageProps} /\u003e;\n}\n```\n\n설정이 완료되었습니다. 이제 테스트해 봅시다!\n\n![이미지](/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_6.png)\n\n\n\n테스트 중:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*z9BAP-pz5fi8N9eR8Gpc4Q.gif)\n\n`monorepo` 내의 기타 앱, 예를 들어 `apps/web`와 같은 앱에 대해 동일한 단계를 따를 수 있습니다.\n\n요약하면, Turborepo로 단일 저장소(monorepo)를 구축하면 업무 흐름을 혁신적으로 개선할 수 있습니다. 구성된 구조와 간소화된 프로세스를 통해 이 조합은 대규모 프로젝트와 다중 응용 프로그램을 쉽게 관리하고 시간을 절약하며 신뢰성을 향상시킬 수 있습니다. 직접 시도하고 작업 방식을 변화시킬 수 있는 방법을 확인해 보세요.\n\n\n\n읽어 주셔서 감사합니다. 어떤 피드백이든 정말 감사히 받겠습니다.\n\nGitHub 저장소: https://github.com/mrizkiaiman/turborepo-withtailwind","ogImage":{"url":"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png"},"coverImage":"/assets/img/2024-05-14-SetupaMonorepowithTurborepoNextjsandTailwindCSS_0.png","tag":["Tech"],"readingTime":5},{"title":"400줄의 코드로 나만의 Reactjs 만들기","description":"","date":"2024-05-14 10:30","slug":"2024-05-14-BuildYourOwnReactjsin400LinesofCode","content":"\n\n## 리액트 원리 심도있는 공부\n\n![image](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png)\n\n내 뉴스레터에 원본으로 게시되었습니다.\n\n리액트 v19 베타 버전이 출시되었습니다. React 18과 비교해 보면 사용자 친화적인 많은 API를 제공하지만, 핵심 원칙은 크게 변하지 않았습니다. 리액트를 오랫동안 사용해 왔을 수도 있지만, 그것이 어떻게 작동하는지 아시나요?\n\n\n\n이 기사는 비동기 업데이트를 지원하며 중단될 수 있는 React 버전을 약 400줄의 코드로 빌드하는 방법에 대해 도와줄 것입니다. 이는 많은 고수준 API가 의존하는 React의 핵심 기능입니다. 최종 효과 GIF는 다음과 같습니다:\n\n![Final Effect Gif](https://miro.medium.com/v2/resize:fit:1400/0*x5ppDSDgiUaSz82X.gif)\n\nReact 공식 웹사이트에서 제공한 틱택토 튜토리얼 예제를 사용하여 잘 작동하는 것을 확인했습니다.\n\n현재 이 코드는 내 GitHub에 호스팅되어 있으며 직접 시도해 볼 수 있는 온라인 버전도 방문할 수 있습니다.\n\n\n\n# JSX와 createElement\n\nmini-react.ts의 원리에 깊이 파볼 때, JSX가 무엇을 나타내는지를 이해하는 것이 중요합니다. 우리는 JSX를 사용하여 DOM을 설명하고 JavaScript 논리를 쉽게 적용할 수 있습니다. 그러나 브라우저는 JSX를 기본적으로 이해하지 못하기 때문에 우리가 작성한 JSX는 브라우저가 이해할 수 있는 JavaScript로 컴파일됩니다.\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_1.png)\n\nReact.createElement을 호출하는 것을 볼 수 있습니다. 여기에는 다음 옵션이 제공됩니다:\n\n\n\n- 유형: 현재 노드의 유형을 나타냅니다. div와 같은 것입니다.\n- 구성: 현재 엘리먼트 노드의 속성을 나타냅니다. 예를 들어 'id: \"test\"'입니다.\n- 자식: 여러 엘리먼트, 간단한 텍스트 또는 React.createElement로 생성된 노드일 수 있는 자식 엘리먼트들입니다.\n\n경험이 풍부한 React 사용자라면, React 18 이전에 JSX를 올바르게 작성하기 위해 `react`에서 React를 import해야 했다는 것을 기억할 수 있습니다. 그러나 React 18부터는 이러한 작업이 더 이상 필요하지 않아 개발자 경험을 향상시켰지만, 여전히 React.createElement가 내부적으로 호출됩니다.\n\n![image](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_2.png)\n\n우리의 단순화된 React 구현에는 JSX를 직접적으로 React.createElement 구현으로 컴파일하도록 Vite를 `jsxRuntime: 'classic'`으로 구성해야 합니다.\n\n\n\n그럼 우리 자체를 구현할 수 있어요:\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_3.png\" /\u003e\n\n# 렌더\n\n다음으로, 이전에 생성된 데이터 구조를 기반으로 JSX를 실제 DOM에 렌더링하는 간소화된 버전의 렌더 함수를 구현해보겠습니다.\n\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_4.png)\n\n온라인 구현 링크가 여기 있습니다. 현재 JSX를 한 번만 렌더링하므로 상태 업데이트를 처리하지 않습니다.\n\n# Fiber 아키텍처와 동시성 모드\n\nFiber 아키텍처와 동시성 모드는 주로 한 번 완전한 요소 트리가 재귀되면 중단될 수 없는 문제를 해결하기 위해 개발되었습니다. 이는 주 스레드를 오랜 기간 블로킹할 수 있습니다. 사용자 입력 또는 애니메이션과 같은 고우선 순위 작업이 적시에 처리되지 않을 수 있습니다.\n\n\n\nReact의 소스 코드에서 작업은 작은 단위로 나누어집니다. 브라우저가 유휴 상태일 때 작은 작업 단위들을 처리하여 주요 작업을 우선적으로 처리할 수 있도록 메인 스레드의 제어를 양보합니다. 한 작업의 모든 작은 단위가 완료되면 결과는 실제 DOM에 매핑됩니다.\n\n주요 포인트는 메인 스레드를 양보하는 방법과 작업을 관리 가능한 단위로 나누는 방법입니다.\n\n# requestIdleCallback\n\nrequestIdleCallback은 브라우저가 유휴 상태일 때 콜백을 실행하는 실험적인 API입니다. 아직 모든 브라우저에서 지원되지 않습니다. React에서는 requestIdleCallback보다 복잡한 스케줄링 로직을 갖춘 스케줄러 패키지에서 사용되며, 이 패키지는 작업 우선순위 업데이트와 같은 기능을 포함하고 있습니다.\n\n\n\n그러나 여기서는 비동기 인터럽트성만을 고려합니다, 그래서 React를 흉내 내는 기본 구현이 있습니다:\n\n![이미지](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_5.png)\n\n일부 주요 포인트에 대한 간단한 설명은 다음과 같습니다:\n\nMessageChannel을 왜 사용해야 하나요?\n\n\n\n기본적으로 이 방법은 각 단위 작업 라운드를 처리하기 위해 매크로 테스크를 사용합니다. 하지만 왜 매크로 테스크를 사용해야 할까요?\n\n이는 브라우저가 DOM을 업데이트하거나 이번 휴식 기간 동안 이벤트를 받을 수 있도록 주 스레드의 제어를 양보해야 하기 때문입니다. 브라우저가 DOM을 업데이트할 때는 별도의 작업으로 처리되며, 그때에는 JavaScript가 실행되지 않습니다.\n\n주 스레드는 한 번에 하나의 작업만 처리할 수 있습니다. 즉, JavaScript를 실행하거나 DOM 계산, 스타일 계산, 입력 이벤트 처리 등을 수행할 수 있습니다. 그러나 마이크로 테스크는 주 스레드의 제어를 양보하지 않습니다.\n\nsetTimeout을 사용하지 않는 이유는 무엇일까요?\n\n\n\n현대 브라우저는 중첩된 setTimeout 호출을 다섯 번 이상으로 간주하며 그 최소 지연 시간을 4밀리초로 설정하므로 충분히 정밀하지 않습니다.\n\n# 알고리즘\n\nReact는 계속 발전하고 있으므로 제가 설명하는 알고리즘들이 최신이 아닐 수 있지만, 이는 React의 기본 원리를 이해하는 데 충분합니다.\n\nReact 패키지가 매우 큰 이유 중 하나입니다.\n\n\n\n다음은 작업 단위 간 연결을 보여주는 다이어그램입니다:\n\n![work-units-connections](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_6.png)\n\nReact에서 각 작업 단위는 Fiber 노드라고 불립니다. 이들은 연결 리스트와 유사한 구조를 사용하여 서로 연결되어 있습니다:\n\n- child: 부모 노드에서 첫 번째 자식 요소로의 포인터.\n- return/parent: 모든 자식 요소는 부모 요소로 돌아가는 포인터를 가지고 있습니다.\n- sibling: 첫 번째 자식 요소에서 다음 형제 요소로의 포인터가 있습니다.\n\n\n\n위의 데이터 구조가 구축되면 구체적인 구현을 살펴보겠습니다.\n\n단순히 렌더 로직을 확장하여 workLoop -` performUnitOfWork -` reconcileChildren -` commitRoot 호출 시퀀스를 재구성합니다.\n\n- workLoop: requestIdleCallback을 계속 호출하여 유휴 시간을 가져옵니다. 현재 유휴 상태이고 실행할 unit 작업이 있는 경우 각 unit 작업을 실행합니다.\n- performUnitOfWork: 특정 unit 작업을 수행합니다. 이는 연결 리스트 아이디어의 구현입니다. 구체적으로 한 번에 하나의 Fiber 노드만 처리하고 처리할 다음 노드를 반환합니다.\n- reconcileChildren: 실제로 가상 DOM을 비교하고 변경 사항을 기록하는 현재 Fiber 노드를 조정합니다. 이제 JavaScript 객체의 수정만 있는 것이므로 실제 DOM에는 영향을 주지 않고 각 Fiber 노드에 직접 수정 및 저장했다는 것을 볼 수 있습니다.\n- commitRoot: 현재 업데이트가 필요하고 (wipRoot에 따라) 다음 unit 작업을 처리해야 할 필요가 없는 경우 (!nextUnitOfWork에 따라), 가상 변경 사항을 실제 DOM에 매핑해야 합니다. commitRoot는 Fiber 노드의 변경에 따라 실제 DOM을 수정하는 것입니다.\n\n이러한 접근으로 Fiber 아키텍처를 실제 DOM 업데이트에 인터럽트 할 수 있지만 아직 트리거가 부족합니다.\n\n\n\n# 업데이트 트리거\n\nReact에서 가장 일반적인 트리거는 useState로, 가장 기본적인 업데이트 메커니즘이에요. 저희 Fiber 엔진을 발화하기 위해 이를 구현해봅시다.\n\n여기 구체적인 구현이 있는 간단한 함수입니다:\n\n![Function implementation](/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_7.png)\n\n\n\n훅의 상태를 Fiber 노드에 지능적으로 유지하고 큐를 통해 상태를 수정하는 방식으로 작동합니다. 여기서 React 훅 호출의 순서를 변경해서는 안 되는 이유를 이해할 수 있습니다.\n\n# 결론\n\n비동기 및 중단 가능한 업데이트를 지원하는 React의 최소한의 모델을 구현했습니다. 의존성이 없으며 주석 및 유형을 제외하면 400줄 미만의 코드일 수 있습니다. 도움이 되었으면 좋겠습니다.\n\n만약 이 내용이 도움이 되었다면, 웹 개발에 대한 자세한 통찰을 더 얻고 싶다면 제 뉴스레터 구독을 고려해보세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png"},"coverImage":"/assets/img/2024-05-14-BuildYourOwnReactjsin400LinesofCode_0.png","tag":["Tech"],"readingTime":5},{"title":"React 와 Context API를 활용하여 탭 컴포넌트를 만드는 방법","description":"","date":"2024-05-14 10:28","slug":"2024-05-14-HowToCreateTabsComponentWithReactContextAPI","content":"\n\n우리가 Medium Stats Chrome 확장 프로그램에서 사용 중인 동일한 탭 구성 요소입니다.\n\n![탭 구성 요소 이미지](/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png)\n\n이 아이디어는 구성 요소 라이브러리나 서드파티 모듈 없이 재사용 가능한 컴포넌트를 만드는 것이었습니다.\n\n# 단계 1 — 컨텍스트 생성\n\n\n\n활성 탭의 인덱스는 컨텍스트에 저장되어야 합니다. 해당 인덱스 내에는 변경 함수도 저장됩니다. TabsContext.jsx 파일을 생성하세요.\n\n```js\nimport React, { createContext, useState, useContext } from 'react';\n\nconst TabsContext = createContext({});\n\nexport const TabsProvider = ({ children, defaultIndex = 0 }) =\u003e {\n  const [activeTab, setActiveTab] = useState(defaultIndex);\n\n  return (\n    \u003cTabsContext.Provider value={{ activeTab, setActiveTab }}\u003e\n      {children}\n    \u003c/TabsContext.Provider\u003e\n  );\n};\n\nexport const useTabs = () =\u003e {\n  const context = useContext(TabsContext);\n  if (!context) {\n    throw new Error('useTabs must be used within a TabsProvider');\n  }\n  return context;\n};\n```\n\nTabsProvider와 가장 중요한 부분인 useTabs 훅이 준비되어 있습니다. 이를 사용하면 활성 인덱스에 액세스하고 탭을 변경할 수 있습니다.\n\n# Step 2 — styles\n\n\n\n우리는 Tailwind와 같은 스타일링 라이브러리를 사용하지 않아요. 마음대로 사용하셔도 돼요. 이 데모는 스타일에 구애받지 않아요. CSS 모듈을 사용할 거에요. styles.module.css 파일을 생성해주세요.\n\n```js\n.tabsList {\n    display: flex;\n    border-bottom: 1px solid #f2f2f2;\n}\n\n.tab {\n    padding: 10px 15px;\n    cursor: pointer;\n    border: 1px solid #f2f2f2;\n    background: #f2f2f26b;\n    border-radius: 8px 8px 0 0;\n    position: relative;\n    top: 1px;\n    color: #242424;\n}\n\n.activeTab {\n    background: #fff;\n    border-bottom: 1px solid #fff;\n}\n\n.tabPanel {\n    padding: 10px;\n    min-width: 750px;\n}\n```\n\n# 단계 3 — 탭 컴포넌트\n\n가장 중요한 부분 — 탭, 탭리스트, 탭 및 탭패널 컴포넌트를 만들 거에요. 모두 하나의 파일에 들어갈 거에요. 그들은 작아서 개발하기 편할 거에요 (개발자 경험). Tabs.jsx 파일을 생성해주세요.\n\n\n\n```js\nimport { TabsProvider, useTabs } from './TabsContext.jsx';\nimport styles from './tabs.module.css';\n\nexport const Tabs = ({ children, defaultIndex }) =\u003e {\n  return \u003cTabsProvider defaultIndex={defaultIndex}\u003e{children}\u003c/TabsProvider\u003e;\n};\n\nexport const TabList = ({ children }) =\u003e {\n  return \u003cdiv className={styles.tabsList}\u003e{children}\u003c/div\u003e;\n};\n\nexport const Tab = ({ index, children }) =\u003e {\n  const { activeTab, setActiveTab } = useTabs();\n  return (\n    \u003cbutton className={`${styles.tab} ${activeTab === index ? styles.activeTab : ''}`} onClick={() =\u003e setActiveTab(index)}\u003e\n      {children}\n    \u003c/button\u003e\n  );\n};\n\nexport const TabPanel = ({ index, children }) =\u003e {\n  const { activeTab } = useTabs();\n  return activeTab === index ? \u003cdiv className={styles.tabPanel}\u003e{children}\u003c/div\u003e : null;\n};\n```\n\nTabs — 탭 컨텍스트를 제공하는 빈 컨테이너입니다. 모든 하위 컴포넌트가 컨텍스트에 액세스할 수 있습니다.\n\nTabList — 클릭할 탭 목록을 보여주는 컨테이너입니다. 스타일링을 위해서만 필요합니다.\n\nTab — 탭 자체입니다. 클릭할 수 있는 버튼뿐입니다. 활성 여부를 확인하고 클릭 이벤트를 처리하여 활성 탭을 변경합니다.\n\n\n\n\nTabPanel — 탭의 내용.\n\n# 단계 4 — 마지막 단계. 탭 컴포넌트 사용법\n\n이제 필요한 곳이면 어디에서나 이 컴포넌트를 사용할 수 있습니다. 여기에 샘플이 있습니다.\n\n```js\n\u003cTabs\u003e\n    \u003cTabList\u003e\n      \u003cTab index={0}\u003e통계\u003c/Tab\u003e\n      \u003cTab index={1}\u003e도구\u003c/Tab\u003e\n    \u003c/TabList\u003e\n    \u003cTabPanel index={0}\u003e내용 1\u003c/TabPanel\u003e\n    \u003cTabPanel index={1}\u003e내용 2\u003c/TabPanel\u003e\n\u003c/Tabs\u003e\n```\n\n\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_1.png\" /\u003e\n\n코딩 재밌게 하세요!\n\n## ✉️ 뉴스레터 구독은 여기에서 할 수 있어요.\n\n\n\n또는\n\n이전 이야기를 읽어보세요:\n\n- 내가 처음으로 미디움에서 첫 100달러를 벌게 된 과정은? 💰💰💰","ogImage":{"url":"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png"},"coverImage":"/assets/img/2024-05-14-HowToCreateTabsComponentWithReactContextAPI_0.png","tag":["Tech"],"readingTime":4},{"title":"다음 시리즈 101 Inversify를 활용한 IoC 구현","description":"","date":"2024-05-14 10:26","slug":"2024-05-14-Next101IoCImplementationwithInversify","content":"\n\nTypescript IoC를 Next 14에 Inversify와 함께 올바르게 구현하는 방법을 배우세요.\n\n![image](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png)\n\nIoC(Inversion of Control)는 객체의 동작 제어가 뒤바뀌거나 객체 외부로 이동되는 디자인 패턴입니다. 이는 소프트웨어 응용 프로그램 내 객체의 흐름을 관리하는 데 도움이 됩니다.\n\n제어가 역전되고 컨테이너가 의존성을 관리하는 책임을 맡아 모듈성, 유연성 및 테스트 용이성을 높이게 됩니다.\n\n\n\n아래는 [공식 줄임말(Markdown)](https://www.markdownguide.org/cheat-sheet/) 형식으로 업데이트한 내용입니다.\n\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_1.png)\n\n의존성 주입에 익숙하다면, IoC 디자인을 구현하는 기술 중 하나입니다.\n\n이 패턴은 단순히 \"너가 객체를 만들지 마세요. 제가 그것을 제공할게요.\"라고 말합니다.\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_2.png)\n\n\n\n\n## 그렇지만 왜?\n\n디자인 패턴? 또 다시요? 진짜로, 이걸로 충분히 지쳤어요 🤣. 처음에 IoC나 의존성 주입이 Next 프레임워크와 진짜 유용하다고 생각하지 않았어요. 보통 사람들도 사용하지 않잖아요, ㅎㅎ.\n\n하지만, 제게 호기심을 자극하는 흥미로운 점이 있어요. 만약 Next에서 Repository 패턴을 사용한다면 어떨까요? Next는 자바스크립트나 타입스크립트로 작성됐다는 걸 알고 있어요. 이는 OOP보다 함수형 접근 방식을 기본으로 사용한다는 데 특별히 신경쓰지 않아도 되겠죠.\n\n저는 보통 백엔드에 더 많이 관심이 있는데, 주로 Rust나 PHP와 같은 OOP 언어로 대화를 나눠요. 제가 매일 사용하는 프레임워크는 Laravel이에요. 물론, 개발한 모든 프로젝트에 Repository 및 Service 패턴을 항상 구현해요.\n\n\n\n저장소(repository)는 데이터가 저장되는 곳입니다. 서비스(service)는 데이터를 조작합니다. 간단하죠? 이러한 패턴을 사용하면 API를 통해 데이터를 관리해야 하는 경우나 프로젝트에서 데이터베이스에 직접적으로 접근해야 하는 경우에 견고하고 유지보수하기 쉬운 코드베이스를 개발하는 데 도움이 될 것입니다.\n\n아래의 기사에서 더 많은 정보를 찾아볼 수 있습니다. 관심이 생긴다면 읽어보세요.\n\n## Inversify\n\nNext 프레임워크에서 IoC를 구현하기 위해 InversifyJS를 사용할 예정입니다.\n\n\n\n이것은 TypeScript로 구동되는 JavaScript 및 Node.js 앱을 위한 강력하고 가벼운 제어 반전 컨테이너입니다. 사용하기 쉬운 친절한 API 세트를 갖추고 있어서 최상의 OOP 및 IoC 모범 사례 사용을 촉진할 수 있습니다.\n\n다른 IoC 및 DI 라이브러리 중에서, 제품 환경에서 사용할 수 있는 안정성을 고려하여 이것을 사용하는 것을 선호합니다. 그리고 가벼운 크기인 4 KB만큼만 차지한다는 점도 좋은데요.\n\nInversify는 다음과 같은 모던 JavaScript 엔진을 필요로 합니다:\n\n- Reflect metadata\n- Map\n- Promise (공급자 주입 사용 시에만 필요)\n- Proxy (활성화 핸들러 사용 시에만 필요)\n\n\n\n## 시작해봅시다\n\n일반적으로 Typescript와 App 기반 Router를 사용하여 새 Next 프로젝트를 만든 후에는 프로젝트 디렉토리 구조가 아래와 같이 나타날 것입니다.\n\n```js\nproject\n|\n+-- app                  -\u003e 애플리케이션 디렉토리\n|\n+-- components           -\u003e UI 컴포넌트 디렉토리\n|\n+-- public               -\u003e 공용 에셋 디렉토리\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n다음 명령어를 사용하여 필요한 종속성을 설치해주세요.\n\n\n\n```js\nnpm install inversify reflect-metadata --save\n```\n\nInversify는 TypeScript에서 IoC를 구현하는 데 필요하며, reflect-metadata는 Typescript 파일에서 데코레이터 및 데코레이터 메타데이터를 사용하는 데 필요합니다.\n\n이러한 유형의 정의는 inversify npm 패키지에 포함되어 있습니다. tsconfig.json 파일에 experimentalDecorators, emitDecoratorMetadata, types 및 lib와 같은 몇 가지 컴파일 옵션이 필요합니다. \n\n```js\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"lib\": [\"es6\", \"dom\"],\n        \"types\": [\"reflect-metadata\"],\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\n```\n\n\n\n시작하려면 Inversify의 컨테이너 및 reflect-metadata에 필요한 파일을 만들어보세요.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\n\nconst container = new Container();\n\nexport default container;\n```\n\n```js\n// @/lib/di/reflect-metadata.ts\n\n\"use client\";                           // -\u003e 클라이언트-컴포넌트로 표시\n\nimport \"reflect-metadata\";\n```\n\n다음으로 각 페이지 또는 구성 요소에 대해 기본적으로 SSR(서버 사이드 렌더링)를 사용하지만 reflect-metadata 라이브러리가 클라이언트 측에서 가져와지지 않으면 이상한 오류가 발생할 수 있어요. 그래서 reflect-metadata.ts를 루트 레이아웃 파일에 가져와야 해요.\n\n\n\n```js\n// @/app/layout.tsx\n\nimport \"@/lib/di/reflect-metadata\";    // -\u003e reflect-metadata를 import합니다\n\nexport default function RootLayout({\n  children,\n}: Readonly\u003c{\n  children: React.ReactNode;\n}\u003e) {\n  ...\n}\n```\n\n이제 프로젝트 디렉토리 구조는 다음과 같을 것입니다.\n\n```js\nproject\n|\n+-- app                            -\u003e 애플리케이션 디렉토리\n|\n+-- components                     -\u003e UI 컴포넌트 디렉토리\n|\n+-- public                         -\u003e 퍼블릭 에셋 디렉토리\n|\n+-- lib                            -\u003e 라이브러리 디렉토리\n|  |\n|  +-- di                          -\u003e 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -\u003e 컨테이너\n|     |\n|     +-- reflect-metadata.ts      -\u003e reflect-metadata 클라이언트 컴포넌트\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n그리고 이제 Inversify가 제대로 작동하고 사용할 준비가 되었습니다.\n\n\n\n\n## 모델\n\n이라고 불리는 모델은 당신이 코드에서 사용하는 데이터에 대한 엄격한 타입 정의입니다. \"모델\" 이라는 이름을 사용하는 이유는 이에 더 익숙하기 때문입니다. 이것을 \"타입\" 이라고 부르고 프로젝트 루트에 types 라는 디렉토리를 생성할 수도 있습니다.\n\n예를 들어, 내 애플리케이션에서 제품으로 사용될 데이터에 대한 Product 모델을 생성할 것입니다.\n\n```js\n// @/models/product.ts\n\ntype Product = {\n  id: string;\n  image_url: string;\n  image_blur_data_url: string | undefined;\n  name: string;\n  price: number;\n  unit: string;\n  short_description: string;\n  description: string;\n  statement_description: string;\n  marketing_feature: string;\n};\n\nexport default Product;\n```\n\n\n\n## 저장소\n\n저장소 클래스는 데이터 저장소(창고)로 사용되어 다른 코드가 이 클래스를 통해 필요한 데이터에 액세스할 수 있도록 합니다. 저장소는 앱에서 단일 진실의 원천입니다.\n\n예를 들어, ProductRepository라는 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/repositories/product-repository.ts\n\nimport \"reflect-metadata\";\nimport { injectable } from \"inversify\";\nimport type Product from \"@/models/product\";\n\n// 더미 제품 데이터 목록\nconst products = [ ... ];\n\n@injectable()\nexport default class ProductRepository {\n  async getProducts(): Promise\u003cArray\u003cProduct\u003e\u003e {\n    return products.map((product: any) =\u003e product as Product);\n  }\n\n  async getProduct(id: string): Promise\u003cProduct | undefined\u003e {\n    const product = products.find((product: any) =\u003e product.id === id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n위 코드는 더미 데이터 목록에서 데이터를 얻는 시뮬레이션입니다.\n\n`@injectable` 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 삽입할 수 있다는 것을 인지합니다.\n\n비동기로 코드를 실행해야 하는 경우 `async`가 일반적으로 필요합니다. 왜냐하면 완료되기까지 시간이 걸리기 때문입니다. 데이터베이스나 외부 API와 상호 작용해야 하는 경우에 이를 사용할 수 있습니다.\n\n## 서비스\n\n\n\n레포지토리 클래스를 통해 데이터를 조작하는 서비스 클래스입니다. 필요한 경우 서비스 클래스에서 여러 레포지토리를 사용할 수 있습니다.\n\n이 곳에서 Inversify를 사용한 의존성 주입이 도움이 됩니다. @inject 데코레이터를 통해 서비스 클래스에 필요한 레포지토리를 자동으로 주입할 수 있습니다.\n\n예를 들어, ProductService 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 ProductRepository와 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/services/product-service.ts\n\nimport \"reflect-metadata\";\nimport { inject, injectable } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport type Product from \"@/models/product\";\n\n@injectable()\nexport default class ProductService {\n  @inject(ProductRepository)\n  private productRepository: ProductRepository;\n\n  async getProducts(query: string): Promise\u003cArray\u003cProduct\u003e\u003e {\n    let products = await this.productRepository.getProducts();\n\n    if (query !== \"\") {\n      return products.filter((product: Product) =\u003e\n        product.name.toLowerCase().includes(query.toLowerCase()),\n      );\n    }\n\n    return products;\n  }\n\n  async getProduct(id: string): Promise\u003cProduct | undefined\u003e {\n    const product = await this.productRepository.getProduct(id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n당신의 요구에 따라, 이 서비스 클래스를 사용하여 데이터를 관리하는 데 도움이 되는 추가적인 메서드를 추가할 수 있습니다.\n\n@Injectable 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 주입할 수 있다는 것을 알 수 있습니다.\n\n@Inject 데코레이터를 사용해야만 Inversify에 해당 클래스의 필수 인스턴스를 주입하도록 알릴 수 있으므로 이 인스턴스를 사용하여 리포지토리의 메서드에 액세스할 수 있습니다.\n\n## 컨테이너\n\n\n\n이제 올바르게 작동하는 IoC를 위해 수행해야 할 마지막 단계입니다.\n\n모델(타입), 리포지토리, 서비스 클래스를 생성한 후, 이러한 클래스를 IoC 컨테이너에 등록해야 합니다. 클래스가 컨테이너에 등록되면 앱의 런타임 중에 필요한 인스턴스에 주입될 수 있습니다.\n\n컨테이너는 항상 앱의 런타임에 이용 가능할 것입니다.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nconst container = new Container();\n\ncontainer.bind(ProductRepository).to(ProductRepository).inSingletonScope();\n\ncontainer.bind(ProductService).to(ProductService).inSingletonScope();\n\nexport default container;\n```\n\n\n\n클래스 인스턴스에 대한 scope를 지정할 수도 있어요.\n\n- inTransientScope: 매 의존성 요청마다 새로운 인스턴스를 보장하여 가벼우면서도 일회용 의존성을 유지합니다. 이것이 기본 스코프에요.\n- inSingletonScope: 의존성에 대한 중앙 접근점을 생성하여 모든 곳에서 동일한 인스턴스를 사용하며 효율성과 상태 관리를 촉진합니다.\n- inRequestScope: 단일 해결 프로세스 내에서 중복된 객체 생성을 피해 성능 최적화를 제공하지만 HTTP 요청 당 단일 인스턴스를 보장하지는 않아요.\n\n## The Hook\n\n이 단계는 선택 사항으로, 앱의 다른 구성 요소에서 컨테이너에 액세스하는 데 도움을 줍니다.\n\n\n\n```js\n// @/lib/di/hook.ts\n\nimport container from \"@/lib/di/container\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nexport function getProductRepository(): ProductRepository {\n  return container.get(ProductRepository);\n}\n\nexport function getProductService(): ProductService {\n  return container.get(ProductService);\n}\n```\n\n마침내, 이제 프로젝트 디렉토리 구조는 다음과 같이 보일 것입니다.\n\n```js\nproject\n|\n+-- app                            -\u003e 애플리케이션 디렉토리\n|\n+-- components                     -\u003e UI 컴포넌트 디렉토리\n|\n+-- public                         -\u003e 공용 에셋 디렉토리\n|\n+-- lib                            -\u003e 라이브러리 디렉토리\n|  |\n|  +-- di                          -\u003e 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -\u003e 컨테이너\n|     |\n|     +-- hook.ts                  -\u003e 컨테이너 후크\n|     |\n|     +-- reflect-metadata.ts      -\u003e reflect-metadata 클라이언트 컴포넌트\n|\n+-- models                         -\u003e 모델 디렉토리\n|  |\n|  +-- product.ts                  -\u003e 제품 모델\n|\n+-- repositories                   -\u003e 리포지토리 디렉토리\n|  |\n|  +-- product-repository.ts       -\u003e 제품 리포지토리\n|\n+-- services                       -\u003e 서비스 디렉토리\n|  |\n|  +-- product-service.ts          -\u003e 제품 서비스\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n## 앱에서 사용하기\n\n\n\n컨테이너를 사용하여 인스턴스를 가져오는 것은 정말 쉽습니다.\n\n예를 들어, 제품 데이터 목록을 표시해야 하는 페이지가 있습니다.\n\n```js\n// @/app/page.tsx\n\nimport { getProductService } from \"@/lib/di/hook\";\nimport { Suspense } from \"react\";\nimport ProductList from \"@/components/product-list\";\nimport ProductListSkeleton from \"@/components/product-list-skeleton\";\n\ntype Props = {\n  searchParams?: {\n    search?: string;\n    page?: string;\n  };\n};\n\nexport default async function Page({ searchParams }: Props) {\n  // 쿼리 매개변수 가져오기\n  const query = searchParams?.search || \"\";\n  const currentPage = Number(searchParams?.page) || 1;\n\n  // 제품 항목 가져오기\n  const items = await getProductService().getProducts(query);\n\n  return (\n    \u003cSuspense key={query + currentPage} fallback={\u003cProductListSkeleton /\u003e}\u003e\n      \u003cProductList items={items} /\u003e\n    \u003c/Suspense\u003e\n  );\n}\n```\n\n정말 쉽죠? 이제 코드가 더 깔끔해 보입니다. 데이터 액세스가 IoC에 의해 중앙 집중화되고 관리되기 때문에 🎉.\n\n\n\n## 결론\n\n\u003cimg src=\"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_3.png\" /\u003e\n\n의존성 주입과 함께 역제어(IoC)를 사용하면 코드베이스를 더 깨끗하고 견고하며 유지보수하기 좋게 만들 수 있습니다.\n\n코드베이스 전체에 중복되는 나쁜 냄새나는 코드를 제거할 수도 있어요. 끔찍해! 🤮\n\n\n\n만약 Next 앱에서 Server Action을 더 선호한다면 IoC도 함께 사용할 수 있어요. 간단해요, 한 번 배우면 어디서든 사용할 수 있어요.\n\nNext와 함께 Repository Pattern을 구현하는 기술과 지식을 향상시키기 위해 이 두 글을 읽어보길 권장해요.\n\n## 🚀 샘플 프로젝트\n\nInversify를 IoC로 사용하여 개발한 데모 프로젝트를 실행해볼 수 있어요. 이 프로젝트는 MIT 라이센스로 라이선스가 부여되어 있어요.","ogImage":{"url":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png"},"coverImage":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png","tag":["Tech"],"readingTime":11},{"title":"클라이언트 측 React 문제 해결을 위한 Date API 수정하기","description":"","date":"2024-05-14 10:25","slug":"2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png\" /\u003e\n\n리액트.js 19 버전이 곧 출시되면서 Next.js를 사용하여 새로운 기능을 활용할 수 있게 되었습니다. 하지만, 특히 자바스크립트의 Date API와 관련된 문제가 발생하는데, 서버에서 생성된 콘텐츠와 클라이언트 측의 동작을 조율하는 것이 주요 도전 과제입니다. 이 기사는 Date API로 인해 발생하는 구체적인 문제와 리액트 코드가 클라이언트 측에서 실행될 때 발생하는 이러한 문제가 웹 애플리케이션에서 예상되는 원활한 사용자 경험을 방해하는 수행 오류로 어떻게 이어질 수 있는지에 대해 다룹니다.\n\n# 클라이언트 측 리액트에서의 Date 문제\n\n클라이언트 측 렌더링에서 리액트의 수분화 메커니즘은 이벤트 리스너 및 기타 상호작용 기능을 서버에서 원래 생성된 정적 HTML에 첨부하도록 설계되어 있습니다. 이 프로세스에서 서버 출력과 클라이언트의 초기 렌더 간의 정확한 대응이 필요합니다. 그러나 JavaScript의 Date 객체 사용은 그 자체의 실행 특성 때문에 이 시스템에서 기본적인 문제를 도입하게 됩니다.\n\n\n\n```js\n\"use client\";\n\nexport default function DateError() {\n  const date = new Date();\n  return \u003cdiv\u003e{date.toLocaleString()}\u003c/div\u003e;\n}\n```\n\n`new Date()`함수는 호출 시점을 기반으로 한 타임스탬프를 생성합니다. 이 코드가 SSR 중인 서버와 이후 클라이언트에서 실행될 때 거의 항상 두 개의 다른 타임스탬프가 생성됩니다. 이러한 불일치는 React에서 \"수분 불일치\"로 알려져 있습니다. 클라이언트는 서버의 HTML을 기반으로 기대한 내용과 로컬 생성한 내용 사이의 차이를 감지하고, 오류를 발생시키며 때로는 사용자 경험을 망가뜨리기도 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_1.png\" /\u003e\n\n# React 코어 팀의 제안하는 해결책\n\n\n\n\nDate 불일치로 인한 지속적인 문제에 대응하여, React 코어 팀이 혁신적인 해결책을 제안했습니다: 서버 측 렌더링(SSR) 및 수분화 중에 Date API를 수정하는 것입니다. 이 방식은 Date 함수의 출력을 서버와 클라이언트 환경에서 표준화하여 두 환경이 동일한 타임스탬프를 렌더링하도록 보장함으로써 수분화 불일치를 제거하는 데 목적을 두고 있습니다.\n\n![이미지](/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_2.png)\n\n제안된 패치는 SSR 및 수분화 중에 Date API의 동작을 변경하여 실행 시간에 따라 새로운 타임스탬프를 생성하는 대신 초기 서버 렌더링 중에 사용된 타임스탬프를 일관되게 반환하도록합니다. 이것은 서버에서 생성된 날짜 및 시간이 클라이언트에서의 수분화 과정 중에 \"고정\"되어, 클라이언트 측 React 애플리케이션이 실제로 코드를 실행하는 시점에 관계없이 서버에서 렌더링된 시간 값을 보게 하는 것을 의미합니다.\n\n![이미지](/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_3.png)\n\n\n\n# 패치 구현이 이루어질 때까지의 임시 해결책\n\n실용적인 접근 방식 중 하나는 서버에서 날짜 생성을 관리한 다음 이 값을 props로 클라이언트에 전달하는 것입니다. 이 전략을 통해 서버와 클라이언트가 동일한 타임스탬프로 작업하므로 하이드레이션 중 불일치를 피할 수 있습니다.\n\n```js\n//부모\nimport DateError from \"./components/DateError\";\n\nexport default function Home() {\n  const date = new Date();\n\n  return (\n    \u003cmain\u003e\n      \u003cDateError date={date} /\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n```js\n//자식\n\"use client\";\n\ninterface DateErrorProps {\n  date: Date;\n}\nexport default function DateError({ date }: DateErrorProps) {\n  return \u003cdiv\u003e{date.toLocaleString()}\u003c/div\u003e;\n}\n```\n\n\n\n이 방법은 서버에서 한 번 생성된 날짜를 클라이언트에서 재사용하여, 재렌더링 및 수분을 통해 일관성을 유지함으로써 문제를 효과적으로 우회합니다.\n\n# 결론\n\n해당 패치는 React 개발의 한 측면인 날짜 불일치로 인한 수분 불일치를 해결하기 위해 약속하고 있습니다. 그러나 중요한 변경 사항과 마찬가지로, 네이티브 JavaScript API를 수정하는 최선의 방법에 대한 커뮤니티 내에서 대화를 일으키고 있습니다.\n\n개발자들은 이 토론에 참여하고 이 패치의 진행 상황을 주시하도록 권장받습니다. Twitter에서 Andrew Clark와 같은 거장들의 이야기를 따르면 React 생태계 내에서 이 주제 및 다른 개발에 대한 가치 있는 통찰과 업데이트를 얻을 수 있습니다.\n\n이 글은 Theo의 영감을 받아 작성되었습니다. 더 많은 업데이트 및 React 최신 개발에 대한 심도 있는 토론을 위해 그의 채널을 구독하는 것을 강력히 권장합니다.\n\n\n\n마크다운 형식으로 테이블 태그를 변경하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png"},"coverImage":"/assets/img/2024-05-14-PatchingtheDateAPItoSolveClient-SideReactIssues_0.png","tag":["Tech"],"readingTime":3},{"title":"React Native가 어떻게 작동하는지 이해하기 아키텍처에 대해","description":"","date":"2024-05-14 10:24","slug":"2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactNativeArchitecture.png\" /\u003e\n\n# React Native이란 무엇인가요?\n\nReact Native은 React와 JavaScript를 사용하여 네이티브로 렌더링된 iOS 및 Android 앱을 작성할 수 있게 해주는 훌륭한 기술입니다.\n\n이 방식에는 두 가지 주요 장점이 있습니다. 첫째로, 이는 웹 개발자들이 가장 인기 있는 JavaScript UI 라이브러리를 사용하여 네이티브한 느낌의 모바일 애플리케이션을 쉽게 작성할 수 있게 합니다.\n\n\n\n둘째, React Native로 작성된 대부분의 코드는 iOS 및 Android 모두 개발을 간편하게 해주는 동시 개발을 간소화합니다.\n\n# 그래서, 어떻게 작동하는 거죠?\n\nReact Native의 아이디어는 두 가지 별개의 부분인 JavaScript 코드와 Native 코드(안드로이드의 경우 Java/Kotlin, iOS의 경우 Objective-C/Swift)를 결합하여 함께 작동시키는 것입니다. 네이티브 코드는 기기에서 직접 실행되지만, JavaScript는 가상 머신이 필요합니다.\n\niOS 기기에는 C++로 작성된 내장 JavaScript 엔진인 JavaScriptCore가 내장되어 있어 JavaScript 코드를 컴파일하고 실행할 것입니다. 안드로이드 기기에는 내장된 JS 엔진이 없으므로 JavaScriptCore는 React Native 프레임워크와 함께 제공될 것입니다.\n\n\n\n자바/Obj-C와 자바스크립트는 서로 다른 프로그래밍 언어이기 때문에 직접적으로 대화할 수 없습니다. 그러나 둘 모두 이해하는 형식의 데이터를 사용하여 간접적으로 대화할 수 있습니다. 그 형식이 JSON입니다. 이 통신은 Bridge라는 프로그램 세트에 의해 처리됩니다.\n\n![](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_1.png)\n\nReact Native의 빌드 및 런타임\n\n빌드 시간에, 자바 또는 Objective-C로 작성된 네이티브 코드는 Java 및 C++ 이진 파일로 컴파일되며, 자바스크립트 코드는 Metro 번들러를 사용하여 번들로 묶입니다. Metro는 웹 개발에서 사용되는 웹팩 번들러와 유사하게 작동하지만 React Native에 최적화되어 있습니다.\n\n\n\n바이너리와 JS 번들은 최종적으로 대상 플랫폼용 실행 파일 내에 패킹될 것입니다.\n\n런타임 시점에서, JavaScript 코드는 JavaScript 가상 머신에서 실행되고 네이티브 코드는 장치에서 직접 실행될 것입니다. 브릿지는 이 두 영역 사이에서 직렬화된 메시지를 전송할 것입니다. 이러한 메시지는 그 후 역직렬화되어 처리될 것입니다.\n\n# React Native 스레드\n\n사용자가 애플리케이션을 실행하면, 장치는 세 개의 주요 스레드와 필요에 따라 추가 백그라운드 스레드를 시작할 것입니다.\n\n\n\n![React Native 아키텍처 이해: React Native가 어떻게 작동하는가](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_2.png)\n\n- Main Thread — 이것은 애플리케이션이 실행될 기본 네이티브 스레드입니다. 디바이스 화면에 사용자 상호작용 및 UI 렌더링을 담당합니다. 모든 완전 네이티브 빌드 애플리케이션에서 실행 중인 동일한 스레드입니다.\n\n- JavaScript Thread — 여기서 애플리케이션의 비즈니스 로직(즉, JavaScript 및 React 코드)이 실행됩니다.\n\n- Shadow Thread — 이 스레드는 JavaScript 스레드와 함께 시작됩니다. 그 역할은 뷰의 위치를 계산하고 JS 스레드에 작성된 레이아웃 트리를 구성하는 것입니다. React Native는 네이티브 호스트가 이해할 수 있는 레이아웃 시스템으로 플렉스박스 기반의 레이아웃을 변환하는 Yoga 레이아웃 엔진을 활용합니다.\n\n\n\n네이티브 모듈 스레드 - 어플리케이션이 플랫폼 API에 액세스해야 할 때, 예를 들어, 기기의 저장소와 같은 경우, 이 스레드에서 처리됩니다.\n\n# React Native의 브릿지\n\n브릿지는 의심의 여지 없이 React Native 아키텍처의 가장 중요한 부분입니다. 이를 통해 JavaScript 및 네이티브 레이어 사이에서 JSON 메시지를 통해 정보를 교환할 수 있습니다.\n\n이 논리는 웹 응용 프로그램의 경우와 동일합니다. 여기서 프론트엔드 및 백엔드 레이어는 서로에 대해 알 필요가 없으며 (따라서 JavaScript 및 Python과 같은 다른 기술로 작성할 수 있음), 그들은 교환하는 정보를 이해하여 처리해야 합니다.\n\n\n\n한 예시를 통해 알아보겠습니다.\n\n![React Native Architecture](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_3.png)\n\n- 네이티브 이벤트가 발생합니다. 예를 들어 터치나 스크롤 이벤트.\n- 네이티브 측에서 필요한 모든 데이터와 함께 직렬화된 메시지가 브릿지를 통해 전송됩니다.\n- JavaScript가 메시지를 수신하고 역직렬화하여 다음 단계를 결정합니다. 이 경우 아이콘을 변경합니다.\n- JavaScript 레이어에서 요청된 작업에 관한 정보와 함께 메시지가 브릿지를 통해 전송됩니다.\n- 네이티브 측이 메시지를 수신하고 역직렬화하여 뷰를 업데이트합니다.\n\n# 브릿지의 문제\n\n\n\n위에서 언급한대로, 브릿지는 비동기적이기 때문에 특정 경우에 문제가 발생할 수 있습니다.\n\n브릿지를 통해 정보를 비동기적으로 교환하는 것은 매우 빠르지만 때로는 충분하지 않을 수 있으며 동기적인 방식이 더 나을 수 있습니다.\n\n사용자가 신용카드 번호를 입력하는 입력 상자를 가정해 봅시다. 번호를 읽기 쉽게 하기 위해 매 네 자리마다 공백을 삽입하고 싶습니다. 그를 위해 사용자가 문자를 입력할 때마다 간단한 JS 함수를 작성하여 호출하면 됩니다.\n\n![이미지](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_4.png)\n\n\n\n이렇게 작동하는 것을 확인해 봅시다.\n\n![React Native architecture](/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_5.png)\n\n네이티브 측에서 사용자가 입력한 문자에 대한 정보가 이미 렌더링된 이후에 올 것을 확인할 수 있습니다. 그런 다음, 저희의 JavaScript 코드가 그 변경 사항을 처리하여 필요한 경우 공백을 삽입하고 새 입력 상태를 설정하면, 이 정보가 다시 네이티브 측으로 전송되어 새 UI가 렌더링됩니다.\n\n이로 인해 사용자가 텍스트를 서식 지정하고 업데이트하기 전에 볼 수 있는 상황이 발생할 수 있습니다(즉, “42578\" 대신에 “4257 8\"을 보여 줘야 할 때). 이 상황은 브릿지가 처리 중인 유일한 사항이라면, 상태의 이러한 점프는 눈에 띄지 않을 수 있습니다. 이 작업이 얼마나 빠르게 수행되는지 때문입니다. 그러나 동시에 많은 업데이트를 처리하는 것은 실생활의 다리와 같은 교통량을 초래할 수 있습니다. 복잡한 애플리케이션에서 문제가 될 수 있음을 상상해 볼 수 있습니다.\n\n\n\n다른 문제는 브릿지의 정보 교환에 사용되는 JavaScript와 네이티브 영역 사이에 직렬화하고 역직렬화해야 한다는 것인데, 이는 시간이 많이 소요되며, 애플리케이션이 커질수록 차이가 발생할 수 있습니다.\n\n이러한 문제를 해결하기 위해 React Native 팀은 JavaScript와 네이티브 코드를 더 잘 조합하는 효율적인 방법을 찾아 새 아키텍처에 JavaScript Interface를 도입했습니다.\n\n# JSI — JavaScript Interface\n\n0.68 버전부터 새 React Native 아키텍처를 사용할 수 있어 브릿지 메커니즘 대신 JavaScript Interface를 채택했습니다.\n\n\n\nJSI(JavaScript Interface)는 모든 JavaScript 엔진에서 활용할 수 있는 통합된 경량 범용 레이어입니다. 이를 사용함으로써 우리는 네이티브 API에 직접적인 연결을 할 수 있게 됩니다.\n\n하지만 어떻게 할까요?\n\nC++은 네이티브 Java/Obj-C 메서드/객체들을 JavaScript에 \"HostObject\"를 통해 노출시킬 것입니다. JavaScript는 이 객체에 대한 참조를 보유하여 Java/Obj-C API에 직접적으로 액세스할 수 있게 됩니다.\n\n이 작업은 동일한 스레드에서 동기적으로 수행될 수도 있고 새로운 스레드를 생성하여 비동기적으로 처리될 수도 있습니다.\n\n\n\n이 기능은 React Native를 새로운 차원으로 끌어 올려 주며, 제공하는 많은 장점 때문에 곧 널리 받아들여질 것입니다.\n\n이 주제를 보다 자세히 살펴보고 싶다면, Parashuram N의 새로운 아키텍처 프레젠테이션을 시청하고 공식 React Native 문서를 참고해보시기를 권장합니다.\n\n# 결론\n\n지금쯤 React Native가 어떻게 작동하는지와 그 아키텍처가 어떻게 구성되어 있는지에 대한 간략한 개요를 얻었을 것입니다. 이 글이 도움이 되었기를 바라며, React Native 세계를 더 깊이 탐험하길 격려합니다.","ogImage":{"url":"/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_0.png"},"coverImage":"/assets/img/2024-05-14-HowdoesReactNativeworkUnderstandingthearchitecture_0.png","tag":["Tech"],"readingTime":5},{"title":"자큐 리 틱톡 비디오 논쟁 공개 휴스턴 학교 선생님의 학생들과의 논란 끝 판결","description":"","date":"2024-05-14 10:23","slug":"2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents","content":"\n\n![JaQ Lee TikTok Video](/assets/img/2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents_0.png)\n\n의견은 개인적인 인식에 의해 형성되며, 행동과 상황을 해석하는 방식에 영향을 미칩니다. 휴스턴 출신의 고등학교 교사인 JaQ Lee가 두 학생에게 머리를 풀어 주는 TikTok 동영상을 생각해보세요. 이 비디오는 광범위한 토론을 촉발시켜 상호 작용에 대한 다양한 해석을 드러내었습니다.\n\n교사-학생 사이의 동태가 더욱 친밀한 관계로 발전한 현대 교육 환경에서, 이러한 상황들은 경계와 적절한 행동에 대한 반성을 일으킵니다. 내 11살 아들과의 경험은 이 변화를 강조합니다. 학교에서 인기가 많은 그가 최근에 난간에 오르게 되어 심각한 일이 발생했습니다. 질문을 받자 그는 행동을 정당화하며 해당 교사를 “내 친구\"라고 지칭했습니다.\n\n이 사건은 학생들 사이에서 교사에 대한 인식이 변화하고 있다는 것을 보여줍니다. 전통적인 교사-학생 관계가 교육자가 권위자보다는 동료로 인식되는 더 비형식적인 동적으로 대체되었습니다. 그러나 이 가늘어진 경계는 적절한 경계에 대한 질문을 던집니다.\n\n\n\nJaQ Lee의 비디오는 이보다 더 큰 사회적 변화의 소우주적인 모습을 보여줍니다. 어떤 사람들은 그가 학생들과의 상호작용을 해 Harmless하게 여기며 긍정적인 관계의 표시라고 생각할 수도 있습니다. 그러나 다른 사람들은 그러한 친밀함의 적절성에 의문을 제기할 수도 있습니다.\n\n인식들!","ogImage":{"url":"/assets/img/2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents_0.png"},"coverImage":"/assets/img/2024-05-14-JaQLeeTikTokVideoSparksDebateHoustonTeachersControversialInteractionwithStudents_0.png","tag":["Tech"],"readingTime":1},{"title":"React에 Husky를 추가하는 방법","description":"","date":"2024-05-14 10:22","slug":"2024-05-14-HowtoaddhuskytoReact","content":"\n\n## Husky를 사용하여 오류를 줄이고 일관된 코드베이스를 유지하세요\n\n이 스토리는 원래 이곳에서 발행되었습니다.\n\nHusky는 현대적인 네이티브 Git 훅을 React 프로젝트에서 쉽게 사용할 수 있게 해줍니다. 커밋 메시지의 린트, 테스트 실행, 코드 린팅 등 커밋하거나 푸시할 때 수행할 수 있습니다.\n\n그렇다면 Git 훅은 무엇이며 어떻게 프로젝트에 Husky를 추가할 수 있을까요?\n\n\n\n## Git 훅이란 무엇인가요?\n\nGit 훅은 git의 실행 중 일정 시점에 실행될 수 있도록 설정할 수 있는 스크립트/프로그램입니다 (git 라이프사이클). 이러한 시점은 커밋의 다른 스테이지를 포함하며, 커밋 전(pre-commit)이나 커밋 후(post-commit)와 같은 시점이 있습니다.\n\nGit 훅을 사용하면 npm 테스트를 커밋 전에 실행하거나 eslint 오류 및 경고를 피하기 위해 eslint를 실행하는 것과 같이 다른 스크립트를 자동화하여 작업을 실행하여 개발자가 표준을 강제할 수 있습니다.\n\nHusky는 모든 Git 훅을 지원합니다. 제공되는 모든 Git 훅 목록은 여기에서 확인할 수 있습니다.\n\n\n\n# 리액트 프로젝트에 husky 추가하기\n\n프로젝트에 husky를 설치하는 두 가지 방법이 있어요:\n\n- 자동 (권장)\n- 수동\n\n## 자동 설치 (권장)\n\n\n\n패키지 husky-init은 husky와 함께 프로젝트를 빠르게 설치하고 초기화하는 데 사용됩니다.\n\n프로젝트 루트에서 husky를 설치하려면 다음 명령어를 입력하세요 (사용 중인 패키지 매니저에 따라 달라집니다).\n\n중요: package.json이 하위 디렉토리에 있는 경우 husky와 함께 사용자 정의 디렉토리를 설정하는 방법을 확인하세요.\n\n```bash\nnpx husky-init \u0026\u0026 npm install       # npm\nnpx husky-init \u0026\u0026 yarn              # Yarn 1\nyarn dlx husky-init --yarn2 \u0026\u0026 yarn # Yarn 2+\n```\n\n\n\n이 스크립트를 성공적으로 실행한 후 몇 가지 일이 발생했습니다:\n\n- 프로젝트 루트에 .husky라는 폴더가 추가되었습니다. 이 폴더에는 pre-commit이라는 파일이 포함되어 있습니다. 이 파일은 초기 pre-commit 후크입니다. 또한 자동으로 생성된 husky를 위한 셸 스크립트가 있는 _라는 폴더도 있습니다. (이것을 커밋하지 마세요, .gitignore를 참조하세요)\n- package.json이 수정되었습니다. prepare 스크립트가 추가되었고 husky가 devDependency로 추가되었습니다.\n- 그리고 package-lock.json이 업데이트되었습니다.\n\n이제 React 프로젝트에서 husky를 사용할 준비가 되었습니다. 😀\n\n## 수동 설치\n\n\n\n세 개 단계, 그러나 결과물은 자동 설치와 동일해야 합니다.\n\n- Husky 설치하기\n\n```js\nnpm install husky --save-dev\n```\n\n- Git 훅 활성화하기\n\n\n\n```js\nnpx husky install\n```\n\n- 설치 후 자동으로 Git 훅을 활성화하려면 package.json을 편집하세요.\n\n```js\nnpm pkg set scripts.prepare=\"husky install\"\n```\n\n## 훅 사용하기\n\n\n\n성공적인 설치 후에는 이미 pre-commit 훅이 설치되어 있어야 합니다.\n\n생성된 pre-commit 훅의 내용은 다음과 같습니다:\n\n```js\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm test\n```\n\n이는 매 commit 전에 npm test 스크립트가 실행된다는 것을 의미합니다. 테스트가 실패하면 오류가 발생하고, 테스트를 수정하지 않는 이상 commit할 수 없습니다. 이미 작은 규모의 프로젝트에서도 이것이 얼마나 유용한지 알 수 있을 것 같습니다.\n\n\n\n## 훅 생성\n\n훅에 명령을 추가하거나 새 훅을 만드는 구문은 다음과 같습니다:\n\n```js\nhusky add \u003cfile\u003e [cmd]\n```\n\n예를 들어, pre-commit 훅에서 npm test 이후 ng lint를 실행하려면 다음과 같이 합니다.\n\n\n\n```js\nhusky add .husky/pre-commit ng lint\n```\n\n프리 커밋 후크가 업데이트되었습니다:\n\n```js\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm test\nng lint\n```\n\n🌟축하합니다🌟 React 프로젝트에 husky가 성공적으로 설치되었고 설정되었습니다.\n\n\n\n## TL;DR\n\n- Husky는 git 훅을 쉽게 사용하여 git 라이프사이클 이벤트에서 스크립트를 자동으로 실행하는 도구입니다.\n- 예를 들어: 코드를 커밋하기 전에 npm 스크립트를 실행하려면 pre-commit 훅을 사용하세요.\n\n읽어 주셔서 감사합니다. 궁금한 점이 있으시면 댓글 기능을 사용하거나 @mariokandut으로 메시지를 보내주세요. React에 대해 더 알고 싶다면 React 튜토리얼을 확인해보세요.\n\n참고문헌 (그리고 큰 감사): Git hooks, React, Husky, NPM — husky","ogImage":{"url":"/assets/img/2024-05-14-HowtoaddhuskytoReact_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoaddhuskytoReact_0.png","tag":["Tech"],"readingTime":3},{"title":"이들 생물들은 종종 그들의 문화 속 전설과 신화에 깊게 뿌리박혀 있으며, 그들의 믿음, 공포, 환경의 다양한 측면을 대표합니다","description":"","date":"2024-05-14 10:21","slug":"2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment","content":"\n\n## 신화적인 존재나 전설적인 이야기를 믿으시나요?\n\n![이미지](/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png)\n\n다양한 나라들의 역사를 살펴보면, 서로 다른 이름을 가진 다양한 신화적인 존재들의 전설을 발견할 수 있습니다. 각 나라마다 자신만의 신화적인 존재들과 이야기들을 가지고 있습니다.\n\n## 다양한 나라의 신화적인 존재들입니다.\n\n\n\n## 일본:\n\n여우 정령인 키츠네, 새처럼 생긴 도깨비 텐구, 물 정령인 카파 및 오니(흉악하고 강인한 정령).\n\n## 그리스:\n\n다두한 뱀 하이드라, 천하태평한 세계를 지키는 세두리를 맡은 세개 머리의 개 케르베로스, 그리고 날개 달린 영혼 하피들.\n\n\n\n## 북유럽 신화:\n\n요트나 (거인), 발키리 (여전사), 그리고 펜리르 (거대한 늑대).\n\n## 이집트:\n\n스핑크스 (사람의 머리를 가진 사자), 아누비스 (여우 머리를 가진 신), 그리고 암미트 (사자, 하마, 악어의 일부).\n\n\n\n## 인도:\n\n가루다(새 형태의 생물), 나가(뱀 형태의 존재), 그리고 락샤사(악마 형태의 존재).\n\n## 중국:\n\n용, 봉황, 그리고 치린(한콘류 생물).\n\n\n\n## 멕시코 :\n\n추파카브라 (염소 흡혈귀), 나후알 (모양 변이자), 라 요로나 (울부짖는 여성).\n\n## 러시아 :\n\n바바 야가 (마녀), 루살카 (물 정령), and 지메이 고르이치 (3머리 용).\n\n\n\n## 아프리카:\n\nMngwa(거대하고 사나운 고양이), Inkanyamba(거대한 장어), Adze(흡혈귀와 같은 존재).\n\n## 호주:\n\nBunyip(물 정령), Yowie(털불다리인간), Drop bear(허구적인 코알라와 유사한 생물).\n\n\n\n# 이들 생물은 종종 그들의 문화 속 전설과 신화에 깊이 뿌리를 내리며, 그들의 믿음, 두려움, 환경의 다양한 측면을 대표합니다.\n\n어떤 나라의 신화적 생물을 아시는 분은 댓글에 언급해 주세요.\n\n## 읽어 주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png"},"coverImage":"/assets/img/2024-05-14-Thesecreaturesareoftendeeplyrootedinthefolkloreandmythologyoftheirrespectiveculturesrepresentingvariousaspectsoftheirbeliefsfearsandenvironment_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 앱에서 ESLint와 Prettier 설정하기","description":"","date":"2024-05-14 10:20","slug":"2024-05-14-SetupESLintandPrettierinReactApp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png\" /\u003e\n\nESLint와 Prettier 설정은 초보자에게는 조금 긴장스러울 수 있어요. 저도 이 문제에 직면한 적이 있어서 잘 알고 있어요. 인터넷에는 린팅 설정에 관한 많은 기사가 있을 거예요. 그 중 일부는 여러분에게 맞을 지도 모르지만, 일부는 그렇지 않을 수도 있어요. 그 중 대부분은 라이브러리가 계속 업데이트되기 때문에 오래되었을 가능성이 크답니다.\n\n그래서, 우리는 ESLint와 Prettier에 대해 이해해야 해요.\n\n## ESLint이란?\n\n\n\nESLint는 구성 가능한 JavaScript 린터입니다. JavaScript 코드에서 문제를 찾아 해결하는 데 도움을 줍니다. 문제는 잠재적인 런타임 버그, 최적의 관행을 따르지 않는 것, 스타일링 문제 등 무엇이든 포함될 수 있습니다.\n\nESLint는 ECMAScript/JavaScript 코드에서 발견된 패턴을 식별하고 보고하는 도구로, 코드를 일관되게 만들고 버그를 피하기 위해 사용됩니다.\n\n## Prettier란 무엇인가요?\n\nPrettier는 대부분의 언어와 호환되는 주관적인 코드 형식 지정 도구입니다.\n\n\n\n## 먼저 React 앱을 만들어봐요\n\ndemo-app이라는 프로젝트를 생성하려면 다음 명령어를 실행하세요:\n\n```js\nnpx create-react-app demo-app\ncd demo-app\nnpm start\n```\n\n## ESLint와 Prettier 설정\n\n\n\n스텝 1: 프로젝트 루트 폴더에서 터미널을 열고 ESLint를 개발 의존성으로 설치하세요.\n\n```js\nnpm install eslint --save-dev\n 또는\nyarn add eslint --dev\n```\n\n스텝 2: 아래 명령어를 실행하여 .eslintrc.json 파일을 생성하세요.\n\n```js\nnpx eslint --init\n 또는\nyarn run eslint --init\n```\n\n\n\n이 프로세스를 통해 여러 옵션이 표시됩니다. 먼저 \"구문을 확인하고 문제를 찾습니다\"를 선택한 후 JavaScript 모듈(가져오기/내보내기)를 선택하고 React를 선택하세요. 그런 다음 프로젝트에 TypeScript를 사용하는지 물어볼 것입니다. 제 경우 TypeScript를 사용하지 않으므로 \"아니요\" 옵션을 선택하겠습니다. 브라우저를 선택한 후 JSON 옵션을 선택하세요. 그런 다음 eslint-plugin-react를 설치하라는 메시지가 표시됩니다. \"예\"를 클릭하세요.\n\n프로젝트 루트 폴더에 .eslintrc.json 파일이 표시됩니다.\n\n```json\n{\n    \"env\": {\n        \"browser\": true,\n        \"es2021\": true\n    },\n    \"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\"\n    ],\n    \"parserOptions\": {\n        \"ecmaVersion\": \"latest\",\n        \"sourceType\": \"module\"\n    },\n    \"plugins\": [\n        \"react\"\n    ],\n    \"rules\": {\n    }\n}\n```\n\n\n\n**단계 3: 규칙 추가**\n\n리액트 - 18.0.0에서 파일에 리액트를 가져오는 것은 선택 사항입니다. 이를 해결하기 위해 .eslintrc.json 파일에 규칙을 추가할 겁니다. 따라서 .eslintrc 파일을 열고 규칙 내부에 이 줄을 추가해주세요. \"react/react-in-jsx-scope\": \"off\"\n\n```js\n\"rules\": {\n    \"react/react-in-jsx-scope\": \"off\"\n}\n```\n\n**단계 4: Jest를 사용 중이라면**\n\nJest를 사용 중이라면, eslint가 test 또는 expect가 정의되지 않았다는 오류를 보여줄 수 있습니다. 이를 해결하기 위해 env 내부에 \"jest\": true를 추가해야 합니다.\n\n\n\n```js\n\"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"jest\": true\n  }\n```\n\n단계 5: 이제 리액트와 함께 작동하도록 eslint 플러그인을 추가하고, eslint 및 prettier가 서로 충돌하지 않도록 적절한 구성을 만들어주세요.\n\n```js\nnpm install eslint-config-prettier eslint-plugin-prettier prettier --save-dev\nor \nyarn add eslint-config-prettier eslint-plugin-prettier prettier --dev\n```\n\n단계 6: 위 모듈을 모두 설치한 후, .eslintrc.json 파일에 몇 가지 prettier 구성을 추가해야 합니다. 따라서 extends 내부에 \"plugin:prettier/recommended\"라는 줄을 추가해주세요.\n  \n\n\n\n```js\n\"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\",\n        \"plugin:prettier/recommended\"\n    ],\n```\n\nstep7: .prettierrc.json 파일을 생성하고 아래 코드를 붙여넣으세요\n\n```js\n{\n  \"semi\": true,\n  \"tabWidth\": 2,\n  \"printWidth\": 100,\n  \"singleQuote\": true,\n  \"trailingComma\": \"none\",\n  \"jsxBracketSameLine\": true\n}\n```\n\n이제 eslint와 prettier가 설정되었으니 package.json에 스크립트를 추가합시다.\n\n\n\n```js\n\"lint\": \"eslint .\",\n\"lint:fix\": \"eslint . --fix\",\n\"format\": \"prettier --write ./**/*.{js,jsx,ts,tsx,css,md,json} --config ./.prettierrc.json\"\n```\n\n위 명령어를 사용하여 소스 코드를 수정하고 확인할 수 있어요.\n\n읽어 주셔서 감사합니다.\n\n소스 코드: https://github.com/DreamSky1996/react-lint-prettier\n\n\n\n아란 그랜트가 만들었습니다","ogImage":{"url":"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png"},"coverImage":"/assets/img/2024-05-14-SetupESLintandPrettierinReactApp_0.png","tag":["Tech"],"readingTime":4}],"page":"120","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"120"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>