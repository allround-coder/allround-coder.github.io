<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/120" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/120" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 Context와 useState 함께 사용하는 방법" href="/post/2024-05-14-HowtouseReactContextwithuseState"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 Context와 useState 함께 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 Context와 useState 함께 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 Context와 useState 함께 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Server Components와 NextJS Best Practices, 팁" href="/post/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Server Components와 NextJS Best Practices, 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Server Components와 NextJS Best Practices, 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Server Components와 NextJS Best Practices, 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" href="/post/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" href="/post/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS에서 상태 관리 다루기 흔한 문제와 해결책</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" href="/post/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 컴포넌트 슬롯과 리액트" href="/post/2024-05-14-WebComponentsslotsandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 컴포넌트 슬롯과 리액트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextAuth v5를 사용한 보호된 라우팅 구현하기" href="/post/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextAuth v5를 사용한 보호된 라우팅 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" href="/post/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" href="/post/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 19 베타 버전이 출시되었어요" href="/post/2024-05-14-React19betaisout"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 19 베타 버전이 출시되었어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-React19betaisout_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 19 베타 버전이 출시되었어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 19 베타 버전이 출시되었어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link posts_-active__YVJEi" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 Context와 useState 함께 사용하는 방법","description":"","date":"2024-05-14 11:32","slug":"2024-05-14-HowtouseReactContextwithuseState","content":"\n\n래엑트 앱에서 props를 도대체 어디서 사용해야 하는지 지친 적이 있나요? Redux에 대한 대안을 찾고 계신가요? 자식 컴포넌트가 props를 사용하지 않고 계속해서 전달하고 있나요? 더 나은 방법이 여기 있어요!\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png)\n\n필수 요구 사항: props, state, 컴포넌트 및 훅에 대한 기본적인 React 지식이 필요합니다. 더불어 TypeScript 지식도 약간 필요합니다. 이 예시에서는 함수형 컴포넌트를 사용할 것입니다. (그리고 제 동료 요한네스가 쓴 React 컴포넌트 작성을 위한 고려 사항 기사도 확인해보세요)\n\n## 개요\n\n\n\n1. 문제와 Context 사용 시기\n2. 쉬운 구현과 기본 사항\n3. 더 현실적인 예제\n4. 고려할 사항\n\n# 1. 문제와 Context 사용 시기\n\nContext를 사용하는 가장 흔한 문제 또는 고려 사항 중 하나는 prop drilling 문제입니다. 이 문제를 설명하기 위해 음식 주문 앱을 예시로 사용하겠습니다. 새롭고 멋진 음식 주문 앱을 작성했다고 상상해보세요. 앱에는 리스트에 표시하고 싶은 음식 항목이 있습니다. 각 음식 항목에는 쇼핑 카트에 항목을 추가할 수 있는 카운터가 있습니다. 주문하기 전에 음식의 양을 보여주는 쇼핑 카트 컴포넌트를 작성했다고 가정해 보겠습니다. 이 앱의 컴포넌트 트리는 다음과 유사할 수 있습니다:\n\n![그림](/assets/img/2024-05-14-HowtouseReactContextwithuseState_1.png)\n\n\n\n음식 항목의 현재 개수를 추적하는 방법을 간단히 보여주는 코드 예제가 있어요. 계수 상태는 FoodCounter 및 FoodSummary 구성 요소에 필요하기 때문에 트리 상단에 있어요.\n\n우리는 상태를 전체 트리를 통해 prop으로 전달하고 있는 것을 알 수 있어요. FoodItem 구성 요소에서는 심지어 상태가 필요하지 않을 수도 있지만, 우리는 단지 FoodCounter 구성 요소에 전달하기 위해 prop을 전달하고 있어요. 이것이 프롭 드릴링 문제에 관한 것이죠. (코드 예제에 표시되어 있지 않은 ShoppingCart 및 FoodSummary 구성 요소에서도 비슷한 일이 발생할 수 있어요)\n\n이렇게 하면 구성 요소가 혼잡해지고, 다른 사람이 코드를 읽는 데 어려워질 수 있어요. 특히 여러 속성을 전달하기 시작하면 더 나빠질 수도 있어요. 그러나 우리가 원하는 것은 구성 요소를 깔끔하게 유지하고 실제 필요한 곳에만 상태를 갖도록 하는 것이에요. 이때 React Context가 도움을 줄 거예요.\n\n# 2. 쉬운 구현으로 기초를 익히기\n\n\n\n자, 이 예제를 조금 더 자세히 살펴볼게요. 모든 구성 요소를 'Component'로 이름을 변경해서 우리가 중점을 두어야 할 중요한 부분, 즉 Context를 구축하는 작업에 집중하도록 할 거에요. 우리는 Context, Context Provider 및 Context Consumer를 생성하여 상태를 다르게 관리할 거에요.\n\n## 세 가지 주요 구성 요소\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_2.png)\n\n위 이미지에서 보다 싶이, 세 가지 주요 구성 요소는 Context, Provider 및 Consumer이기 때문에 우리는 다음을 해야해요:\n\n\n\n- 컨텍스트 생성하기\n- 부모 컴포넌트를 Provider로 감싸기\n- 컨텍스트 사용하기\n\n### 1. 컨텍스트 생성하기\n\n코드 예시에서 보는 것처럼 React에서 컨텍스트를 생성하는 것은 정말 쉽습니다. createContext 함수를 호출하기만 하면 됩니다. 선택적으로 기본값을 전달할 수 있습니다. 이 경우에는 \"defaultValue\"라는 문자열을 전달했습니다.\n\n### 2. 부모 컴포넌트를 Provider로 감싸기\n\n\n\n부모 컴포넌트에서는 반환하는 요소들을 우리의 Context로 감쌀 수 있습니다. 구체적으로, MyContext의 Provider 속성으로 MyParentComponent를 감싸고 있습니다. 이는 우리가 React에서 Context를 생성한 후에 얻는 기본 속성입니다. 다른 파일에서 Context를 생성했다면 쉽게 여기에서 불러와서 사용할 수 있습니다. 예제에서 보시다시피 Provider는 React에서 일반 컴포넌트처럼 사용할 수 있습니다.\n\n게다가, Context Provider 컴포넌트에는 value 속성이 함께 제공됩니다. 우리는 이를 사용하여 마음에 드는 어떤 값을 전달할 수 있습니다. 이 경우 \"My Context Value\" 문자열을 만들어서 Context Provider에 전달해 보겠습니다.\n\n## 3. Context를 사용하고 값을 활용하기\n\nMyComponent 내부나 트리 아래의 다른 자식 컴포넌트에서 이를 사용할 수 있습니다:\n\n\n\n그래서 이제 우리는 MyComponent에서 또는 그 하위 컴포넌트 중 어디에서든 Context를 직접 사용할 수 있습니다. Context를 사용하려면 useContext 훅을 호출하고 Context(MyContext)를 인수로 전달하면 됩니다. 이렇게 하면 Provider에서 제공한 값을 얻을 수 있습니다. 이름이 어디에서 유래했는지 이제 아시겠죠 😉\n\n값을 얻으면 다른 종류의 프롭(prop)이나 상태 변수와 마찬가지로 사용할 수 있습니다. 여기서는 그 값을 단락 안에 반환하기만 합니다.\n\n## 중요: React가 어떻게 해당 값 사용 여부를 알 수 있을까요?\n\n# 3. 좀 더 현실적인 예제\n\n\n\n첫 번째 예는 React Context 개념을 설명하기 위해 범용적이고 최소한의 내용이었습니다. 이제 실제 응용 프로그램에서 찾을 수있는 것과 훨씬 가까운 예제를 살펴볼 것입니다. 예를 들어, 사용자가 앱에서 가입하는 온보딩 또는 등록 흐름을 사용할 것입니다.\n\n이 예제에서 TypeScript를 사용할 것입니다. 또한 useState 훅을 사용할 Provider 컴포넌트를 직접 만들 것입니다. 온보딩 흐름에는 여러 단계가 있어 각 단계 간에 데이터를 공유하고 요약 화면에 데이터를 표시하려는 경우를 상상해보세요. 모든 데이터를 props로 전달하고 싶지 않기 때문에 OnboardingContext를 사용할 것입니다.\n\n우선, 사용자 이름 상태와 사용자 이름 상태를 업데이트하는 setUsername 액션을 가진 Context를 위한 인터페이스를 생성합니다. 여기에서는 단순화를 위해 사용자 이름만 사용합니다. 물론 메일 주소나 사용자의 생일과 같은 속성을 추가할 수 있습니다.\n\n이후에 이전과 같이 Context를 생성하며, 이는 OnboardingContextValue 또는 undefined 유형이 될 수 있습니다. 기본값으로 undefined를 전달합니다. 이제 사용자 정의 Provider 컴포넌트를 만들어봅시다.\n\n\n\n여기서는 평소처럼 useState 훅을 호출하고 사용자 이름과 setUsername 함수를 언팩합니다. 그런 다음 모든 하위 구성 요소를 사용하여 우리의 온보딩 컨텍스트 프로바이더를 반환합니다. 값으로는 사용자 이름과 setUsername 함수만 전달합니다. 물론, 이 시점에서 더 많은 상태를 추가하고 값을 프로바이더에 전달할 수도 있습니다. 아마도 이미 우리가 컨텍스트 생성 시 기본 값으로 undefined를 전달한 이유에 궁금증을 품었을 수도 있습니다. 여기에 그 답이 있습니다:\n\n컨텍스트가 생성되고 일치하는 프로바이더를 찾지 못할 때 undefined가 기본 값으로 사용됩니다. 이는 우리에게 에러를 throw해줍니다. 실제로 이 에러가 발생하길 원합니다. 왜냐하면 우리는 컨텍스트에서 기본 값을 사용하고 싶지 않기 때문입니다. 우리는 커스텀 프로바이더 컴포넌트에서 정의한 상태를 사용하려고 합니다. 그러나 온보딩 컨텍스트가 undefined인 경우 부모 컴포넌트를 커스텀 프로바이더로 감싸놓지 않았을 수도 있습니다.\n\n이 문제를 해결하기 위해 부모 컴포넌트를 커스텀 프로바이더로 감싸놓습니다:\n\n상태 값들을 사용하려면 하위 구성 요소 중 하나에서 커스텀 훅을 사용할 수 있습니다. 그냥 사용자 이름과 setUsername 함수를 언팩하면 됩니다. 이제 이들을 다른 상태 값이나 상태 액션처럼 사용할 수 있습니다. 마치 이 컴포넌트에서 useState 훅을 직접 사용했을 때와 유사합니다. 이렇게 하면 단일 컴포넌트에서 상태를 컨텍스트로 쉽게 옮기는 것도 가능합니다.\n\n\n\n# 4. 고려해야 할 사항\n\n코드베이스에 Context를 도입하기 전에 고려해야 할 몇 가지 사항이 있습니다. 먼저, 데이터에 대해 고민해야 합니다. 컴포넌트에 어떤 데이터가 필요한가요? 그리고 이 데이터가 정확히 어디에 필요한가요? 이를 통해 일반적으로 전체 응용 프로그램을 더 잘 이해할 수 있습니다. 이는 또한 어떤 데이터가 어울리는지, 그리고 데이터가 정말 공유 Context에 있어야 하는지에 대한것도 포함합니다.\n\n이후, 다음 질문을 통해 계속할 수 있습니다. \"현재 사용 중인 상태는 무엇인가요?\" 여전히 이러한 상태가 필요할 수 있지만, 이를 Context로 옮길 수도 있습니다. 어떤 상태를 Context에 넣고 싶은지 스스로에게 묻고, 그 상태가 단 하나의 컴포넌트에만 필요하기 때문에 Context에 필요하지 않은 상태도 파악해야 합니다. 또한 상태를 어떻게 변경하는지도 고민해보세요. set state 함수를 Context로 이동할 수 있지만, 사용자 지정 처리기까지 이동하는 등 더 나아간 방향으로 진행할 수도 있습니다.\n\n마지막으로, prop drilling이 정말 큰 문제인지 스스로에게 물어보아야 합니다. Context를 생성하면 특정한 오버헤드가 발생합니다. 이는 응용 프로그램을 변경하거나 리팩토링하는 데 어렵게 만들 수 있습니다. 예를 들어, Context는 컴포넌트를 테스트하기 어렵게 만들 수 있습니다. 컴포넌트에 모킹된 props를 전달하는 것이 Context로 컴포넌트를 감싼 사용자 지정 테스트 렌더 함수를 작성하는 것보다 쉽습니다. Context의 오버헤드가 props를 전달하는 작은 번거로움만큼 가치가 있는지 스스로에게 물어보세요.\n\n\n\n컨텍스트를 사용하면 컴포넌트 간 데이터 흐름을 이해하기 어려울 수 있어요. 하지만 프롭스를 사용하면 어떤 데이터가 컴포넌트로 들어오고 나가는지 항상 명확하게 알 수 있어요. 컨텍스트를 사용하면 실제 데이터가 어디에서 오는지 찾기 위해 조사를 먼저 해야할 수도 있어요.\n\n## 요약하자면\n\n우리가 하는 일을 좋아하시나요? 함께 하고 싶으신가요? 저희의 최신 채용정보를 확인해보세요: https://www.comsystoreply.com/career\n\n이 블로그 포스트는 Comsysto Reply GmbH에서 발행되었습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png"},"coverImage":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"React Server Components와 NextJS Best Practices, 팁","description":"","date":"2024-05-14 11:30","slug":"2024-05-14-ReactServerComponentswithNextJSBestPracticesTips","content":"\n\nReact Server Components (RSCs)는 React 애플리케이션의 서버 측 렌더링(SSR)에 대한 생각 방식을 변경할 것으로 약속합니다. 이 개념은 개발자 커뮤니티 내에서 긍정적인 관심을 불러일으켰어요. Next.js가 이제 RSCs를 지원함에 따라, 개발자들은 전통적인 싱글 페이지 애플리케이션에 일반적으로 연관된 복잡성 없이 SSR을 받아들일 수 있게 되었습니다. 그러나, 새로운 프레임워크나 기술에는 항상 개발자가 알아야 할 도전과 함정이 따르게 됩니다.\n이 가이드는 NextJS와 함께 RSCs를 탐험하려는 프론트엔드 개발자를 대상으로 합니다.\n\n## 서버 측 렌더링에 대한 간단한 소개:\n\n서버 측 렌더링은 자바스크립트 코드를 실행하고, 서버 측에서 웹 페이지의 초기 HTML을 생성한 후, 완전히 렌더링된 페이지가 브라우저로 전달됩니다.\n\n이 방식에는 몇 가지 장점이 있습니다:\n\n\n\n- SEO 순위 향상: 검색 엔진이 이미 HTML로 렌더링된 페이지 컨텐츠를 쉽게 색인화할 수 있습니다.\n- 빠른 성능: 브라우저가 서버로부터 HTML을 받자마자 페이지 컨텐츠의 렌더링을 시작할 수 있습니다. 이는 인지되는 성능을 최적화합니다.\n- 접근성: JavaScript를 비활성화한 사용자도 페이지 컨텐츠를 볼 수 있습니다.\n\n전통적인 클라이언트 렌더링:\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png)\n\n서버 측 렌더링:\n\n\n\n\n![React Server Components with Next.js Best Practices and Tips](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_1.png)\n\nRSC와 함께 사용할 때 고려해야 할 몇 가지 최상의 실천 방안을 살펴보겠습니다.\n\n## 서버-클라이언트 경계 이동하기:\n\nNextJS 13+에서는 기본적으로 트래디셔널 페이지 라우터 대신 App 라우터를 제공합니다. 이 경계를 이해하는 것은 효과적인 컴포넌트 관리에 중요합니다. App 라우터를 사용하면 우리가 생성하는 모든 컴포넌트는 클라이언트로 명시되지 않는 한 서버 컴포넌트로 간주됩니다.\nhttps://nextjs.org/docs/app/building-your-application/routing\n\n\n\n\n지금 '서버 클라이언트 경계'가 뭔가요?\n\n이것은 NextJS의 서버 및 클라이언트 구성 요소 사이의 가상의 경계입니다. 서버 구성 요소는 엄격히 서버 측에서 처리되어 클라이언트 번들의 일부로 다운로드되지 않습니다.\n\n이 경계는 어떻게 정의되나요?\n\n이전에 설명했듯이, App 라우터의 모든 구성 요소는 기본적으로 서버 구성 요소이며 클라이언트로 지정되지 않는 한입니다.\n\n\n\n그래서, 클라이언트 구성 요소를 지정하는 방법은 무엇인가요?\n\n클라이언트 번들의 일부로 구성 요소가 해석되도록 하려면 JavaScript/TypeScript 파일의 맨 위에 'use client'를 언급해야 합니다.\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_2.png)\n\n서버 측으로 이동할 컴포넌트와 클라이언트 측으로 이동할 컴포넌트를 선택하는 방법:\n\n\n\n서버 구성 요소 (데이터 가져오기): 서버 구성 요소를 루트 구성 요소로 설정하는 것이 좋습니다. 루트 구성 요소는 모든 클라이언트 구성 요소를 감싸야 합니다. 이 구성 요소의 목적은 API 호출을 수행하고 내부 구성 요소를 위한 래퍼 HTML을 생성하는 것입니다. 서버 구성 요소의 장점 중 하나는 민감한 데이터(인증/로그인 정보)를 처리하는 데 사용할 수 있다는 것입니다.\n\n클라이언트 구성 요소 (상호작용): 상호작용이 많은 하위 구성 요소로 설정해야 합니다. 이 구성 요소들은 훅 같은 기능을 사용할 필요가 있습니다. Redux와 같은 상태 관리 도구는 클라이언트 구성 요소에서만 사용할 수 있습니다. 이들은 부모 구성 요소로부터 데이터를 prop drilling을 통해 전달받을 수 있습니다.\n\n## 우선 순위에 따른 사전 렌더링:\n\n사전 렌더링은 NextJS의 가장 강력한 기능 중 하나입니다. 브라우저가 웹페이지를 요청할 때 NextJS는 클라이언트 및 서버 구성 요소를 사용하여 사전 렌더링된 HTML을 생성합니다. 이는 백그라운드에서 NextJS/React가 상호작용을 위해 구성 요소를 업데이트하는 동안 초기 페이지 콘텐츠를 빠르게 전달하는 데 도움이 됩니다.\n그렇다면 '우선 순위에 따른 사전 렌더링'이란 무엇을 의미할까요?\nNextJS는 초기 페이지 로드 시 고객에게 표시되는 부분과 그렇지 않은 부분을 모두 사전 렌더링합니다. 이는 느린 네트워크에서 로드할 때 FCP (첫 콘텐츠 렌더링) 지연이 몇 초까지 발생할 수 있습니다.\n예를 들어 드롭다운을 개발 중이라고 가정해 봅시다. 일반적으로 초기 페이지 로드 시 드롭다운 제목만 표시되고 실제 콘텐츠는 마우스를 가져가면 활성화됩니다. 따라서 이상적으로는 컴포넌트를 분할하고 요청 시 부분을 동적으로 로드해야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_3.png)\n\n페이지 전체에 최적화되면 웹페이지의 FCP(첫 번째 콘텐츠 표시)가 줄어들고 페이지가 더 빠르게 렌더링됩니다.\n\n## 동적/레이지 로딩:\n\n위 주제를 더 확장하기 위해 웹페이지 전체에 대한 리액트 컴포넌트의 레이지 로딩 또는 동적 로딩으로 많은 최적화를 수행할 수 있습니다. 모든 것을 사전 렌더링할 필요는 없습니다.\n'react.lazy' 또는 Next/dynamic과 함께 동적 임포트를 사용할 수 있습니다.\n\n\n\n리액트.lazy는 좋지만 클라이언트 측에서 컴포넌트를 렌더링하지 않는 옵션을 제공하지 않습니다. 컴포넌트를 가져올 때 'ssr: false' 플래그를 사용하여 서버 측에서 렌더링되지 않도록 할 수 있습니다.\n\n## 서버 컴포넌트와 CSS:\n\n서버 컴포넌트는 발전 중이지만 몇 가지 제한 사항이 여전히 존재합니다. 서버 컴포넌트로 HTML을 렌더링할 수 있지만, 기기별로 지나치게 구체적이거나 CSS가 많이 사용된 컴포넌트는 피하는 것이 좋습니다. 오직 드문드문한 HTML/CSS만 남기는 주요 이유 중 하나는 서버가 웹 페이지를 요청하는 기기를 모르기 때문에 기기별 HTML 블록을 렌더링하는 것을 방지하기 때문입니다.\n\n모든 최상의 실천 방법을 모두 포함하지는 않겠지만 RSCs를 시작하는 데 도움이 되리라 생각됩니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png"},"coverImage":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png","tag":["Tech"],"readingTime":4},{"title":"Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기","description":"","date":"2024-05-14 11:28","slug":"2024-05-14-ReactComponentLibrarywithViteandDeployinNPM","content":"\n\n![ReactComponentTutorial](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png)\n\n안녕하세요! 이 튜토리얼은 React 및 Vite를 사용하여 TypeScript 템플릿으로 React 컴포넌트를 빌드하고, 그것을 NPM에 게시하는 방법을 안내하기 위해 만들어졌어요. 이 빌드 패키지는 다른 React 애플리케이션에서도 재사용할 수 있어요. 저희는 빌드 도구 및 로컬 개발 환경으로 Vite를 사용할 거예요. 로컬 개발 환경으로 storybook을 사용할 수도 있지만, 간단함을 위해 vite를 사용할 거에요.\n\n# 준비물\n\n- Git이 설치되어 있어야 해요.\n- NodeJs와 NPM이 설치되어 있어야 해요.\n- NPM 계정이 있어야 해요. 계정이 없다면, NPM 계정을 만들어 주세요.\n\n\n\n# 초기 설정 및 컴포넌트 라이브러리 생성\n\n## 단계 1: Vite를 사용하여 React 프로젝트 생성하기\n\nVite를 사용하여 TypeScript 템플릿을 갖춘 React 프로젝트를 생성해보세요. 아래 명령어를 사용하여 React 프로젝트를 생성할 수 있습니다.\n\n```js\nnpm init vite@latest react-vite-library -- --template react-ts\n```\n\n\n\n프레임워크를 선택하라는 안내가 있을 것입니다.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_1.png)\n\nReact를 선택하고 입력하라고 하면\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_2.png)\n\n\n\nTypeScript 변형을 선택하고 입력하세요. TypeScript로 만들어진 React 프로젝트가 생성됩니다.\n\n## 단계 2: Prettier와 ESLint 구성\n\nPrettier와 ESLint를 구성하는 이유는 프로그래밍 및 스타일 오류에 대한 일련의 규칙에 대해 분석하여 소스 코드를 평가하고 디버깅하는 데 도움이 되기 때문입니다. 이를 통해 개발자가 코드를 실행하기 전에 오류를 찾을 수 있습니다. 규칙은 또한 최상의 코드 표준과 관행을 시행하며, 더 좋은 코드 품질, 더 가독성이 좋고 유지보수하기 쉬운 코드를 제공합니다.\n\n프로젝트에 ESLint를 설치해 봅시다.\n\n\n\n```js\nyarn global add eslint // 전역에 설치합니다\nyarn add -D eslint  // 이 명령어는 package.json의 devDependencies에 eslint를 추가합니다\n```\n\neslint를 설치한 후, eslint --init을 실행하여 프로젝트에서 eslint를 구성하세요. 그럼 질문이 나올 텐데, 주어진 옵션을 선택하고 eslint가 프로젝트에 구성될 때까지 계속 입력하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_3.png\" /\u003e\n\n프로젝트용 모듈 유형을 선택하고 입력하세요.\n\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_4.png)\n\nReact 프레임워크를 선택하고 입력해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_5.png)\n\n프로젝트는 TypeScript를 사용하므로 '예'를 선택하고 입력해주세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_6.png\" /\u003e\n\nJSON을 선택하고 입력하세요\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_7.png\" /\u003e\n\n마지막 단계에서 패키지를 설치하라는 메시지가 표시됩니다. 이때 yes를 선택하면 npm이 패키지를 설치해 줍니다. 만약 yarn을 사용 중이라면 no를 선택하고 yarn을 사용하여 패키지를 설치할 수 있습니다.\n\n\n\nmd\n![React Component Library with Vite and Deploy in NPM](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_8.png)\n\n프로젝트 루트에 .eslintc.json 파일이 생성됩니다. 이 파일에는 기본 구성이 포함되어 있습니다. 필요에 따라 규칙을 추가할 수 있습니다. 아래의 구성을 직접 사용할 수도 있습니다: .eslintc.json.\n\n위 구성에는 prettier, react-hooks 및 simple-import-sort가 포함되어 있습니다. 다음 명령어를 사용하여 패키지를 설치할 수 있습니다.\n\n```js\nyarn add -D react-hooks eslint-plugin-simple-import-sort prettier\n\nnpm install -D react-hooks eslint-plugin-simple-import-sort prettier\n``` \n\n\n\n\n프로젝트 루트에 .prettierrc 파일을 만들고 다음 코드를 포함하세요. 이 코드는 코드를 서식 맞추는 데 사용됩니다.\n\npackage.json에 다음 스크립트를 추가하세요.\n\n```js\n\"lint\": \"eslint 'src/**/*.{js,jsx,ts,tsx}'\",\n\"lint:fix\": \"eslint --fix 'src/**/*.{jsx,ts,tsx}'\",\n\"format\": \"prettier --write src//**/*.{ts,tsx,css} --config ./.prettierrc\",\n```\n\n## 단계 3: husky 및 lint-staged 구성하기\n\n\n\nGit 훅은 git 실행 중 특정 시점에서 액션을 트리거할 수 있게 해줍니다. 코드베이스를 깨끗하게 유지하는 데 중요한 역할을 합니다. 코드 형식을 확인하거나 린트를 실행하거나 코드가 커밋되거나 원격 저장소로 푸시되기 전에 테스트를 실행하는 등의 작업을 수행할 수 있습니다. Husky를 사용하면 git 훅을 더 쉽게 사용할 수 있습니다. 이 프로젝트에서는 pre-commit 훅만 사용하며 lint-staged 패키지를 사용하여 git 훅을 staged 파일에만 적용합니다.\n\n```js\nnpm install husky --save-dev\nyarn add -D husky\n```\n\npackage.json에 다음 스크립트를 추가하고 yarn prepare를 실행합니다. 스크립트를 실행한 후 프로젝트 루트에 .husky 폴더가 생성됩니다.\n\n```js\n\"prepare\": \"husky install\"\n```\n\n\n\n그런 다음 다음 명령을 실행하여 pre-commit 훅을 추가합니다.\n\n```js\nnpx husky add .husky/pre-commit \"yarn lint-staged\"\ngit add .husky/pre-commit\n```\n\n이제 아래 내용으로 package.json 파일을 업데이트하십시오.\n\n프로젝트에 Husky와 lint-staged가 성공적으로 추가되었습니다.\n\n\n\n## 단계 4: 라이브러리에 포함시킬 컴포넌트들 생성하기\n\nsrc/components 폴더 안에 컴포넌트들을 생성하세요.\n\n- src/components/HelloWorld.tsx\n- src/components/style.css\n\n\n\nsrc/components/index.ts: 이 파일은 모든 것이 이 한 파일에서 내보내어지는 컴포넌트의 주 진입점입니다.\n\n## 단계 5: vite.config.ts 설정\n\n컴포넌트 라이브러리의 빌드 버전을 생성하기 위해 vite.config.ts 파일을 구성해야 합니다.\n\n- 에디터에서 /vite.config.js를 열고 다음을 붙여넣으세요:\n\n\n\n2. linterPlugin은 프로젝트의 린트를 확인하는 데 사용됩니다. dts은 구성 요소 라이브러리에서 사용되는 유형 정의를 생성하는 데 사용됩니다. dts 내부에는 구성 요소가 포함된 폴더의 위치가 포함되어 있습니다.\n\n3. name: `ReactViteLibrary`를 귀하의 구성 요소의 이름으로 교체하는지 확인하십시오.\n\n4. 마찬가지로, fileName 값의 react-vite-library가 귀하의 구성 요소의 이름으로 변경되었는지 확인하십시오.\n\n5. entry: resolve(\"src\",\"component.index.ts\")를 귀하의 구성 요소에서 모든 것이 내보내지는 주 파일의 경로로 대체하십시오. 이는 귀하의 구성 요소의 주 진입점입니다.\n\n\n\n6. `rollupOptions`은 직접적으로 기존의 Rollup 번들을 사용자 정의할 수 있습니다. 이는 Rollup 구성 파일에서 내보낼 수 있는 옵션들과 동일하며, Vite의 내부 Rollup 옵션과 병합됩니다.\n\n## 단계 6: tsConfig.json 및 tsConfig.node.json 구성하기\n\ntsConfig.json에 다음 코드를 포함하세요.\n\n위의 예시에서, `react-vite-library: [\"src\",\"component.index.ts\"]`는 `componentLibraryName: main entry file 위치`를 나타내며, `typeRoots`는 빌드 요소에 포함될 유형을 나타냅니다.\n\n\n\ntsConfig.node.json에 다음 코드를 포함하세요.\n\n## 단계 7: package.json 구성\n\n다음 내용으로 package.json을 업데이트하세요.\n\n- react-vite-library의 모든 인스턴스를 귀하의 컴포넌트/패키지 이름으로 바꿉니다. 다른 npm 패키지에서 이미 존재하지 않아야 합니다. 이 이름은 사용자가 프로젝트에 귀하의 컴포넌트를 설치하는 데 입력할 것이기 때문에 예를 들어: npm install my-component. 해당 이름이 이미 사용 중인지 npm 웹 사이트에서 검색하여 확인할 수 있습니다.\n- description, author 및 keywords에 자체 값 추가\n- 라이선스를 선호하는 대로 변경\n- React를 개발 종속성으로 설치하세요. 리액트 앱은 귀하의 컴포넌트 패키지에 대한 React 제품 의존성을 책임지기 때문에 프로덕션 종속성으로 설치하지 않습니다.\n- repository, bugs 및 homepage에 자체 GitHub 저장소 링크를 추가하세요\n\n\n\n## 단계 8: 빌드\n\n만약 yarn build를 실행하면, 프로젝트 루트에 dist 폴더가 생성됩니다. 이 폴더 안에는 4단계에서 빌드한 컴포넌트들이 포함되어 있습니다.\n\n# 버전 태그 생성\n\n빌드한 패키지를 릴리스하기 위해 버전 태그를 생성해야 합니다. package.json 파일에서 버전 태그를 간단하게 편집할 수 있습니다. 여기서는 버전을 개발하기 위해 GitHub 액션을 사용할 것입니다.\n\n\n\n- GitHub 저장소로 이동해서 액션을 클릭해주세요\n\n![액션 클릭](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_9.png)\n\n2. 직접 workflow를 설정하고 아래 코드를 복사하여 붙여넣기해주세요\n\n버전 태그를 생성하기 위해 이 액션을 패치해야 합니다. 이를 위해 액션으로 이동해야 합니다.\n\n\n\n- 버전을 생성하는 GitHub 액션을 선택하고 아래에 표시된 \"Run workflow\"를 클릭하세요:\n\n![GitHub 액션](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_10.png)\n\n2. GitHub 액션이 완료되면 버전 태그를 받게 됩니다.\n\n![버전 태그](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_11.png)\n\n\n\n# NPM에 발행하기\n\n컴포넌트 라이브러리를 NPM에 발행하려면 NPM 계정이 있어야 합니다. 계정이 없다면 NPM에 발행하기 전에 먼저 계정을 만들어주세요. NPM에 컴포넌트 라이브러리를 발행하는 방법은 두 가지가 있습니다: NPM 명령줄을 사용하여 직접 발행하거나 GitHub 작업을 사용해 발행합니다.\n\n명령줄 도구를 사용하여 발행하기\n\n단계 1: 먼저 package.json 파일의 버전 번호가 올바른지이며, 의미론적 버전 규칙을 준수하는지 확인하세요. 각 새로운 버전 번호로 NPM에 발행할 때마다 이 작업을 수행해야 합니다.\n\n\n\n단계 2: 테스트를 작성했다면, 테스트 및 린트 규칙을 모두 통과하는지 확인하세요.\n\n```js\nyarn run test\nyarn run lint\n```\n\n단계 3: 컴포넌트를 빌드하려면 `yarn build`를 실행하세요. UMD 및 ESM 모듈 형식이 생성되고 `/dist` 폴더에 배치됩니다.\n\n단계 4: npm에 로그인되어 있는지 확인하세요. 그렇지 않은 경우 다음을 입력하세요:\n\n\n\n```js\nnpm login\n```\n\n단계 5: 컴포넌트를 게시합니다\n\n```js\nnpm publish\n```\n\nGitHub 작업을 사용하여 게시하기\n\n\n\n단계 1: GitHub 리포지토리로 이동하여 Actions를 클릭하세요.\n\n단계 2: 새 워크플로우를 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_12.png)\n\n단계 3: 직접 워크플로우를 설정하기를 클릭하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_13.png)\n\n단계 4: 다음 코드를 복사하여 GitHub 작업을 생성합니다.\n\n단계 4: GitHub 작업 위에 secrets.NPM_TOKEN이 있습니다. 따라서 NPM에서 액세스 토큰을 생성해야 합니다.\n\n- https://www.npmjs.com/으로 이동하여 계정에 로그인합니다. 프로필 아이콘을 클릭하면 다음 드롭다운 메뉴가 표시되며, 액세스를 선택합니다.\n\n\n\n![새 토큰 생성하기](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_14.png)\n\n2. 새 토큰을 생성하세요\n\n![정보 작성 및 액세스 토큰 생성](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_15.png)\n\n3. 정보를 작성하고 액세스 토큰을 생성하세요\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_16.png\" /\u003e\n\n4. 방금 생성한 액세스 토큰을 복사한 후 깃허브 리포지토리 설정으로 이동하십시오. 그리고 새 리포지토리 시크릿을 클릭하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_17.png\" /\u003e\n\n5. 액세스 토큰을 붙여넣고 시크릿을 추가하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_18.png\" /\u003e\n\n비밀 키를 리포지토리에 성공적으로 추가했습니다.\n\n단계 5: 이제 '새 릴리스 만들기'를 클릭하여 릴리스를 생성하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_19.png\" /\u003e\n\n\n\n단계 6: 버전 태그를 선택하고 정보를 입력한 후 '릴리스 게시'를 클릭하세요.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_20.png)\n\n단계 7: 게시를 클릭한 후에는 만든 GitHub 작업이 실행됩니다. \"액션\"으로 이동하여 확인할 수 있습니다.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_21.png)\n\n\n\n8단계: 패키지가 성공적으로 게시되었습니다. NPM 계정으로 이동하여 확인해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_22.png)\n\n# 결론\n\nReact 컴포넌트 라이브러리를 성공적으로 만들었고 NPM에 게시했습니다. 이제 할 일 중 하나는 테스트 애플리케이션을 만들고 NPM에서 컴포넌트를 설치하는 것입니다. 그런 다음 의도한 대로 작동하는지 확인할 수 있습니다.\n\n\n\n# 보너스\n\n저는 이 간단한 방법을 사용하여 구축한 또 다른 컴포넌트 라이브러리가 있습니다. 해당 라이브러리를 사용하면 하나의 패키지로 다른 종류의 모달을 사용할 수 있습니다. https://www.npmjs.com/package/react-global-modal\n\n코딩 즐기세요. 👨🏻‍💻","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png","tag":["Tech"],"readingTime":9},{"title":"ReactJS에서 상태 관리 다루기 흔한 문제와 해결책","description":"","date":"2024-05-14 11:25","slug":"2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution","content":"\n\n![이미지](/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png)\n\nReactJS는 구성 요소 기반 아키텍처와 가상 DOM으로 유명한 JavaScript 라이브러리입니다. 그러나 ReactJS에서 상태를 관리하는 것은 응용 프로그램이 복잡해질수록 어려울 수 있습니다. 이 기사에서는 ReactJS 상태 관리에서 발생하는 일반적인 문제를 탐구하고 해결책을 제시할 것입니다.\n\n## 문제: 상태와 인스턴스 속성을 혼동하는 문제\n\n클래스 구성 요소에서 개발자들은 자주 로컬 상태 객체를 정의하고 `this`로 접근합니다. 그러나 상태 이외에도 로컬 인스턴스 속성을 정의할 수도 있습니다. 이로 인해 혼란이 생길 수 있습니다. 다음 코드에서 확인할 수 있습니다:\n\n\n\n```JavaScript\r\n1class 인사 extends React.Component { \n2  user = { \n3    name: \"World\", \n4  };\n5\n6  state = { \n7    name: \"World\", \n8  };\n9\n10  render() { \n11    return `안녕하세요 ${this.user.name}`; // \"안녕하세요 World\"을 반환합니다.\n12  }\n13}\r\n```\r\n\r\n이 예에서 사용자 속성과 상태 객체는 둘 다 값이 \"World\"인 name 속성을 포함하고 있습니다. 그러나 render 메서드는 상태 객체 대신 사용자 속성에 접근합니다. 이는 예상치 못한 동작을 유발할 수 있으며 상태를 일관된 방법으로 관리하기 어렵게 만들 수 있습니다. \r\n\r\n## 해결책: 애플리케이션 상태 관리에 상태(State)를 전적으로 사용하기\n\n\n\n혼란을 피하기 위해 응용 프로그램 상태를 관리할 때는 상태를 전적으로 사용하는 것이 좋습니다. 이것은 개발자들이 상태와 유사한 데이터가 포함된 로컬 인스턴스 속성을 정의하는 것을 피해야 함을 의미합니다. 대신에 모든 상태는 상태 객체에 정의되어야하며 this.state를 사용하여 액세스되어야 합니다.\n\n다음은 권장되는 방법을 사용하여 클래스 컴포넌트에서 상태를 관리하는 예시입니다:\n\n```js\nclass Greeting extends React.Component { \n  state = { \n    name: \"World\", \n  };\n\n  render() { \n    return `Hello ${this.state.name}`; // \"Hello World\"를 반환합니다.\n  }\n}\n```\n\n\n\n\n이 예제에서는 name 속성이 state 객체에 정의되어 있고 this.state.name을 사용하여 액세스됩니다. 이렇게 함으로써 name 속성이 애플리케이션 상태의 일부임을 명확히하고 적절히 관리되어야 함을 나타냅니다.\n\n## 결론\n\nReactJS에서 상태를 관리하는 것은 도전일 수 있지만, 최선의 방법을 따르면 도움이 될 수 있습니다. 이 글에서는 ReactJS 상태 관리에서 흔한 문제인 상태와 인스턴스 속성을 혼동하는 문제를 탐구하고 해결책을 제시했습니다. 애플리케이션 상태를 관리하기 위해 state를 전적으로 사용함으로써, 개발자들은 혼란을 피하고 애플리케이션을 유지보수 가능하고 확장 가능하도록할 수 있습니다.\n\n또한, React는 훅의 도입으로 상태를 관리하는 새로운 방법을 제공하는데, 이를 통해 클래스를 작성하지 않고도 디벨로퍼들이 상태와 다른 React 기능을 사용할 수 있습니다. 이는 상태 관리를 간소화하고 최선의 방법을 따르기 쉽도록 도와줄 수 있습니다.\n\n\n\n요약하면, ReactJS에서 상태를 관리하는 것은 세심한 주의와 일관된 방법을 요구합니다. 상태를 응용 프로그램 상태를 관리하기 위해 전적으로 사용하고 모베스트 프랙티스를 따르면, 개발자들은 애플리케이션이 유지보수 가능하고 확장 가능하며 이해하기 쉬운 것을 보장할 수 있습니다.\n\n# 쉽게 설명한 것 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 꼭 박수를 보내고 작가를 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"},"coverImage":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png","tag":["Tech"],"readingTime":3},{"title":"첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내","description":"","date":"2024-05-14 11:24","slug":"2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide","content":"\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png)\n\n이전에 작성한 기사에서(https://medium.com/@regondaakhil1509/getting-started-with-react-a-beginners-guide-to-setting-up-your-first-application-a6d8a1ae414), React 애플리케이션을 설정하는 과정을 안내했습니다. 이제 로컬 코드를 GitHub에 올리는 방법을 배우는 것이 시간입니다. 이 단계별 가이드는 새로운 리포지토리를 GitHub에 생성하고 로컬 리포지토리에 연결하고 코드를 원격 리포지토리에 푸시하는 방법을 보여줍니다.\n\nReact가 처음이거나 GitHub를 시작한지 얼마 안 된 경우에도 이 튜토리얼은 프로젝트를 온라인으로 만들어 공동 작업자나 잠재적인 고용주에게 접근 가능하도록 도와줄 것입니다. React 스킬을 다음 수준으로 끌어 올리기 위해 준비하세요!\n\n# 소개 - Git 및 GitHub에 대해\n\n\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png)\n\n깃\n\n- 깃은 코드 변경을 관리하는 버전 관리 시스템입니다.\n- 깃을 사용하면 개발자들은 코드 버전을 추적하고, 다른 사람들과 협업하며, 필요할 때 이전 버전으로 되돌릴 수 있습니다.\n- 깃은 여러 개발자가 동시에 동일한 프로젝트에 작업할 수 있는 분산 버전 관리 시스템입니다. 각 개발자는 자신의 로컬 머신에 코드 저장소의 완전한 복사본을 가지고 있습니다.\n- 깃에 대해 더 알아보려면 https://git-scm.com/about를 방문해보세요.\n\n깃허브\n\n\n\n- GitHub은 Git 저장소를 호스팅하는 웹 기반 플랫폼입니다.\n- 협업을 더 쉽게 만드는 풀 리퀘스트, 이슈 추적 및 코드 리뷰와 같은 기능을 제공합니다.\n- GitHub에는 개발자들이 서로를 팔로우하고 자신의 작업을 보다 넓은 커뮤니티와 공유할 수 있는 소셜 측면도 있습니다.\n- GitHub에 대해 더 알아보려면 https://github.blog/category/company/에서 확인할 수 있습니다.\n\n- GitHub는 Git 호스팅을 제공하는 유일한 플랫폼이 아닙니다.\n- 다른 Git 호스팅 플랫폼으로는 GitLab, Bitbucket 및 SourceForge 등이 있습니다.\n- GitHub는 사용하기 쉽고 다양한 기능을 갖춘 편리한 플랫폼이어서 인기가 많습니다.\n\n## 설정\n\n시작하기 전에 기술적 선행 조건이 모두 갖추어져 있는지 확인하는 것이 중요합니다. 가장 중요한 요구 사항은 로컬 머신에 Git이 설치되어 있어야 한다는 것입니다. 아직 Git을 설치하지 않은 경우 https://git-scm.com/downloads 에서 Git을 다운로드하고 설치할 수 있습니다.\n\n\n\n설치 과정을 확인하려면 터미널에서 다음 명령을 실행하세요:\n\n```js\ngit -v\n```\n\n예시(숫자는 시스템에 따라 다를 수 있습니다):\n\n![예시 이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_2.png)\n\n\n\n다음 단계는 아직 GitHub 계정을 만들지 않으셨다면 GitHub 계정을 생성해야 합니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_3.png)\n\nGitHub 대시보드에서 새 저장소를 만들려면 페이지의 오른쪽 상단을 나타내는 플러스 기호로 표시된 드롭다운 메뉴를 클릭하십시오. 거기서 \"New repository\"로 표시된 옵션을 선택하거나 New Repository를 클릭할 수 있습니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_4.png)\n\n\n\n그 다음으로, 양식을 완성해야 합니다.\n\n- \"저장소 이름\" 필드에 저장소 이름을 입력하세요.\n- 선택사항으로 \"설명\" 필드에 저장소에 대한 설명을 추가할 수 있습니다.\n- 저장소의 가시성 설정을 선택하세요. 저장소를 비공개로 유지하려면 \"비공개\"를 선택하세요. 그렇지 않으면 \"공개\"를 선택하세요.\n- 저장소에 README 파일을 만들고 싶다면 \"이 저장소에 README 파일 추가\" 확인란을 선택하세요.\n- 원하는 경우 저장소에 라이선스를 선택하세요. 인기 있는 오픈소스 라이선스 목록 중에서 선택하거나 라이선스를 추가하고 싶지 않다면 \"없음\"을 선택하세요.\n- \"저장소 만들기\" 버튼을 클릭하세요.\n\n![Image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_5.png)\n\n만세! 새로운 저장소를 만들었어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_6.png\" /\u003e\n\n다음 단계는 코드를 로컬에서 GitHub로 이동하는 것입니다.\n\n만약 처음으로 git을 설정하고 있다면, git을 이름 및 이메일로 구성해야 합니다. 터미널에서 다음 명령어를 실행하세요.\n\n```js\ngit config --global user.email \"Your_Email\"\ngit config --global user.name \"Your_Name\"\n```\n\n\n\n로컬 React 프로젝트에서 Git을 초기화하려면:\n\nVS Code에서 \"your_local_repo\" 폴더(저의 경우, my_portfolio)를 열고 터미널을 열어 해당 디렉토리에서 Git을 초기화하는 명령을 실행하세요.\n\n```js\ngit init\n```\n\n\n\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_7.png)\n\nGitHub의 원격 저장소 링크는 저장소 페이지에서 \"Code\" 버튼을 클릭하여 찾을 수 있습니다. 적절한 프로토콜을 선택(우리의 경우 HTTPS), URL을 클립보드에 복사하고, VS 코드 터미널에서 다음 명령을 실행합니다.\n\n```js\ngit remote add origin https://github.com/your-username/your-repo.git\n```\n\n변경 내용을 스테이징하고 커밋하세요:\n\n\n\n\nReact 프로젝트의 모든 파일을 준비하는 \"git add\" 명령어를 사용하고, 그 변경 사항을 커밋하기 위해 \"git commit\" 명령어를 사용하세요.\n\n```js\ngit add .\ngit commit -m \"커밋 메시지 작성\"\n```\n\nGitHub로 변경 사항을 푸시하세요:\n\n마지막으로, 커밋된 변경 사항을 GitHub 리포지토리에 푸시하기 위해 \"git push\" 명령어를 사용하세요.\n\n\n\n```js\ngit push -u origin main\n```\n\n와우! 이렇게 하면 로컬 React 파일이 GitHub에 업로드되어 원격 저장소에서 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_8.png)\n","ogImage":{"url":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 컴포넌트 슬롯과 리액트","description":"","date":"2024-05-14 11:22","slug":"2024-05-14-WebComponentsslotsandReact","content":"\n\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_0.png)\n\nReact에서 컨텐츠는 children 속성을 통해 컴포넌트로 전달됩니다. 이 속성은 요소의 JSX 태그 내에 캡슐화된 컨텐츠를 위해 특별히 설계되었습니다. 그러나 이 방법은 더 복잡한 템플릿이나 JSX를 컴포넌트의 다른 섹션에 배치해야 하는 경우 부족할 수 있습니다. 다행히 JSX는 함수와 JSX를 모두 props를 통해 전달할 수 있기 때문에 문제없이 이를 구현할 수 있습니다.\n\nWeb Components에서 컨텐츠 처리는 React와 약간 다릅니다. 컴포넌트가 HTML로 렌더링되기 때문에 함수나 HTML(또는 JSX)을 props를 통해 전달할 수 없습니다. 대신, SLOTS를 사용합니다. 이것들은 컴포넌트 내에서 다양한 유형의 HTML 블록을 배치할 수 있는 지정된 영역입니다. 복잡한 컴포넌트에서 적절한 구성을 위해 사용됩니다. 브라우저의 인스펙터에서 슬롯이 약간 다르게 나타날 수 있다는 점을 주목하는 것이 중요합니다.\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_1.png)\n\n\n\n\n웹 페이지의 코드 인스펙터에서는 리다이렉트 기호와 함께 'reveal' 옵션을 볼 수 있습니다. 이 옵션을 클릭하면 DOM 내에서 다른 블록으로 이동하며, 해당 지점에서 렌더링됩니다. 이 기능을 통해 개발자는 Web Components의 복잡한 구성 요소 구조에서 컨텐츠가 정확히 어디에 렌더링되는지 추적할 수 있습니다.\n\nStencil에서는 속성을 통해 HTML 내용을 전달하는 것이 가능합니다 (코드 인스펙터에서 'right'로 된 div에서 확인할 수 있습니다). 그러나 이는 Vanilla JS와 유사하게 처리됩니다. 이를 위해 HTML 내용은 문자열 형태로 속성을 통해 전달되어야 합니다. 그런 다음 componentDidLoad() 라이프사이클 메서드 내에서 @Watch로 데코레이팅된 함수가 트리거되어야 합니다. 이 함수는 querySelector를 사용하여 HTML 블록이 삽입될 특정 div를 찾습니다. 마지막으로, 찾은 요소의 innerHTML이 HTML 내용을 삽입하도록 변형됩니다.\n\n고려해야 할 주요 요소: HTML은 문자열로 시작하지만 중요한 점은 HTML이다. 따라서 style 태그가 사용되면 kebab-case 규칙을 준수해야 합니다. useRef()와 같이 특정 리액트 기능은 이 문맥에서 사용할 수 없으므로 자식 요소를 효율적으로 전달하는 가장 최적의 방법이 아닙니다. 결과적으로, 이러한 환경에서 자식 요소를 효과적으로 전달하는 유일한 방법은 슬롯(slots)을 통해 이루어지게 됩니다.\n\n```js\nimport { Prop, h, Component, Element, Watch } from '@stencil/core';\n\n@Component({\n  tag: 'mtf-slots',\n  styleUrl: 'mtf-slots.scss',\n  shadow: true,\n})\nexport class MotifSlots {\n  @Element() el: HTMLMtfSlotsElement;\n\n  @Prop() rightContent: string;\n\n  @Watch('rightContent')\n  rightContentChanged(newValue: string) {\n    const rightSlot = this.el.shadowRoot.querySelector('.right-slot');\n    if (rightSlot) {\n      rightSlot.innerHTML = newValue;\n    }\n  }\n\n  componentDidLoad() {\n    this.rightContentChanged(this.rightContent);\n  }\n\n  render() {\n    return (\n      \u003cdiv class=\"container\"\u003e\n        \u003cdiv class=\"flexrow\"\u003e\n          \u003cdiv class=\"border-left\"\u003e\n            \u003cslot name=\"left\"\u003eLeft for Defect\u003c/slot\u003e\n          \u003c/div\u003e\n          \u003cslot name=\"middle\"\u003e\u003c/slot\u003e\n          \u003cdiv class=\"right-slot\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n\n\n이 그림에서 왼쪽과 가운데의 슬롯에 대한 두 가지 다른 접근 방식과 오른쪽 슬롯에 대한 프롭스가 표시되어 있습니다. 슬롯은 복잡성이 없지만 프롭스의 경우 코드를 많이 추가해야 합니다. 클래스, componentDidLoad 함수, 쿼리 선택기와 함께 @watch 함수 및 innerHTML을 사용하여 이러한 프롭스를 추가해야 하기 때문에 하나의 작업에 대해 많은 코드가 필요합니다.\n\nReact에서 웹 구성 요소와 상호 작용할 때 슬롯을 활용하는 데 완전한 호환성을 보장합니다. 간단히 해당 위치에 웹 구성 요소의 슬롯 이름을 가진 'slot' 속성을 할당하면 됩니다. 이는 React의 'children' 프롭과 유사하게 작동하여 useRef의 사용 및 그 안에서 상태를 표현하는 것을 허용합니다. 이렇게 함으로써 '슬롯'과 동일한 기능을 구현할 수 있습니다. 프롭스를 사용할 경우 HTML이 해당 위치에 '베이크'됩니다. 그러나 슬롯의 경우 — React 구성 요소에서 소비되는 경우이든 아니든 — DOM의 다른 부분을 참조하는 링크가 해당 섹션에 포함됩니다.\n\n# 결론\n\n\n\n대부분의 경우 HTML을 프롭스를 통해 웹 컴포넌트로 전송하여 작동하지만, 이것은 가장 최적의 방법은 아니며 필요한 모든 기능을 갖추지 못할 수 있습니다. 따라서 React와 100% 호환되는 슬롯을 사용하는 것이 항상 권장됩니다.","ogImage":{"url":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"},"coverImage":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png","tag":["Tech"],"readingTime":3},{"title":"NextAuth v5를 사용한 보호된 라우팅 구현하기","description":"","date":"2024-05-14 11:21","slug":"2024-05-14-ImplementingProtectedRoutingwithNextAuthv5","content":"\n\n![이미지](/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png)\n\n이 글에서는 Next.js 애플리케이션에서 NextAuth v5를 사용하여 클라이언트 측 및 서버 측 경로를 보호하는 방법을 알려드릴 거에요.\n\nNextAuth.js는 Next.js 애플리케이션에서 널리 사용되는 인증 라이브러리로, 버전 5가 출시되면서 여러 가지 주목할만한 개선 사항과 변경 사항이 소개되었어요. 이 최신 버전에서 중요한 업데이트 중 하나는 미들웨어 시스템에서 관찰되어요. 미들웨어 API가 향상되어 인증 흐름과 접근 제어에 대해 더 많은 유연성과 제어를 제공하고 있어요.\n\n그럼 시작해봅시다!\n\n\n\n## 단계 1 — 새로운 Next.js 프로젝트를 생성하고 필요한 패키지 설치하기\n\n이 글에서는 Next.js 애플리케이션을 만드는 방법에 대해 자세히 다루지는 않겠지만, nextAuth를 사용하기 위해서는 최신 버전이 필요합니다.\n\n```js\nnpm install --save next-auth\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_1.png\" /\u003e\n\n\n\n## 단계 2— 애플리케이션 내에 nextAuth 제공자 설정하기\n\n이 예제에서는 Google을 인증 제공자로 사용할 것입니다. 이제 Next 앱 내에 \"services\"라는 새 폴더를 만들고 그 안에 auth.ts라는 새 파일을 생성하세요. 파일을 만든 후 아래 코드를 추가하세요.\n\n```js\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\n\nexport const {\n  handlers: { GET, POST },\n  auth\n} = NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID as string,\n      clientSecret: process.env.GOOGLE_SECRET as string\n    })\n  ],\n  pages: {\n    signIn: '/login'\n  }\n});\n```\n\n반드시 .env 파일을 만들어서 google 클라이언트 ID와 clientSecret를 추가해주세요.\n\n\n\n다음으로, Next 앱 내에서 api 디렉토리(페이지 디렉토리 내부) 안에 새 폴더를 만들어주세요. 폴더의 이름은 `auth`로 지어주세요. 그 폴더 안에 `...nextAuth`(대소문자 구분 필수)라는 폴더를 만들고, 그 안에 `route.ts` 파일을 생성해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_2.png\" /\u003e\n\n해당 파일을 생성한 후, 아래 코드를 추가해주세요.\n\n```js\nexport { GET, POST } from '../../../../services/auth';\nexport const runtime = 'edge';\n```\n\n\n\n이제 제공자 설정이 모두 끝났으니, useContext API와 유사하게 전체 앱에 인증 상태를 제공하는 다른 컴포넌트를 사용하여 모든 구성 요소와 라우트를 감싸는 작업을 진행해 보겠습니다.\nrootlayout.ts 파일 내에서 세션 제공자(SessionProvider)를 사용하여 컴포넌트를 감싸세요.\n\n```js\nimport './globals.css';\n\nimport Navbar from '../components/nav-bar/navbar';\nimport { SessionProvider } from 'next-auth/react';\n\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\" className=\"h-full\"\u003e\n      \u003cbody className=\"h-full flex flex-col\"\u003e\n          \u003cSessionProvider\u003e\n            \u003cNavbar /\u003e\n            \u003cmain className=\"flex-1\"\u003e{children}\u003c/main\u003e\n          \u003c/SessionProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n## 단계 3 — 모든 signIn 및 signOut 함수 구현\n\n그런 다음 nextAuth를 사용하여 모든 signIn 및 signOut 함수를 구현해야 합니다. 그러나 이 문서에서는 해당 함수를 구현하지 않겠습니다. 필요한 라우트를 보호하는 방법만 안내해 드리겠습니다.\n\n\n\n## 단계 4 — 클라이언트 측과 서버 측 라우트를 보호하는 미들웨어 생성\n\n이 접근 방식에서는 클라이언트 측과 서버 측 라우트를 보호하기 위해 미들웨어를 사용할 것입니다. 먼저 src 폴더 안에 middleware.ts라는 새 파일을 만들고 다음 코드를 추가해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_3.png\" /\u003e\n\n```js\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nconst protectedRoutes = [\n  '/dashboard',\n  '/profile',\n];\nconst unprotectedRoutes = ['/', '/login'];\n\nimport { auth } from './services/auth';\n\nexport default async function middleware(request: NextRequest) {\n  const session = await auth();\n\n  const isProtectedRoute = protectedRoutes.some((prefix) =\u003e\n    request.nextUrl.pathname.startsWith(prefix)\n  );\n\n  if (!session \u0026\u0026 isProtectedRoute) {\n    const absoluteURL = new URL('/', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n  if (session \u0026\u0026 unprotectedRoutes.includes(request.nextUrl.pathname)) {\n    const absoluteURL = new URL('/dashboard', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n}\n```\n\n\n\n해당 코드에는 \"protectedRoutes\"와 \"unprotectedRoutes\"라우트가 몇 개 있습니다. 다음 js 애플리케이션에서 라우트를 보호하려면 이 배열에서 원하는 라우트를 추가하거나 제거할 수 있습니다.\n\n전체 문서를 보려면 방문해주세요.\n세미콜론 — 기술 블로그 (semicolon-blog.vercel.app)\n\n우리는 클라이언트 측과 서버 측 라우트를 성공적으로 보호했다고 생각합니다. 감사합니다! 👏👏👏","ogImage":{"url":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드","description":"","date":"2024-05-14 11:19","slug":"2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents","content":"\n\n![이미지](/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png)\n\n안녕하세요! 제 페이지로 돌아오신 여러분을 환영합니다. 당신이 경험 많은 팔로워이든 처음 방문자이든, 여기 오신 것을 매우 기쁘게 생각합니다.\n\n오늘의 주제는 귀여울 정도로 흥미로울 것입니다. 그 녀석이야; CSS-in-JS를 사용한 스타일링의 궁극적인 안내서인 Styled Components입니다. 우리는 JavaScript 내에서 CSS를 직접 작성하는 세계로 들어가보겠습니다. 이 방법이 React 애플리케이션의 스타일링에 제공하는 힘, 효율성 및 유연성을 탐구할 것입니다.\n\n# 소개:\n\n\n\n오케이, 웹 애플리케이션을 스타일링하는 것은 음식을 준비하는 것과 같다고 상상해 봅시다. 당신은 재료가 가득한 식료품실(스타일)과 따를 레시피(HTML 구조)가 있습니다. 그러나 전통적인 냄비나 프라이팬 대신에 당신은 마법의 지팡이 🪄 를 휘두르면서 쉽게 쿨리너리 창작물을 창조할 수 있는 마법을 갖고 있습니다. 이것이 CSS-in-JS의 마법입니다, 특히 Styled Components의 힘을 빌릴 때에는요.\n\n이 포괄적인 기사에서, 저는 Styled Components 설정과 활용, 시각적 및 실용적 예제 탐구, 이 강력한 스타일링 방법론의 모든 잠재력을 발휘하는 방법을 안내하겠습니다.\n\n# CSS-in-JS가 필요한 이유? 캐스케이딩 스타일시트 괴물을 물리치다\n\nCSS-in-JS는 스타일을 구성하는 더 \"원자적\"인 방법을 제공하여 그 스타일을 사용하는 컴포넌트로만 제한하는 방법을 제공합니다. 반면에, 전통적인 CSS는 스타일에 대한 세심한 통제를 제공하지만, 스타일링에 대한 도전과 같은 문제점도 도입합니다.\n\n\n\n- 특이성 전쟁: 이름 충돌과 스타일 재정의로 CSS 코드가 꼬인 문제가 발생할 수 있어 유지 보수가 악몢화될 수 있습니다.\n- 전역 범위 오염: 전역 스타일은 의도하지 않은 부분에 영향을 미칠 수 있습니다.\n- 컴포넌트 재사용성 문제: 스타일링 컴포넌트가 코드베이스 전체에 흩어져 있어 번거로울 수 있습니다.\n\nCSS-in-JS는 스타일을 JavaScript 컴포넌트 내에 직접 통합함으로써 이러한 문제에 대응합니다. 동적 스타일링과 향상된 유지 보수성 및 재사용성과 같은 여러 가지 이점을 제공합니다.\n\n참고: Styled-Components는 React/JavaScript 라이브러리를 위해 설계된 라이브러리이기 때문에 HTML 및 CSS에서 직접 사용할 수 없습니다. React 컴포넌트 구조와 JSX 구문과 같은 기능을 활용하여 CSS 스타일을 React 컴포넌트 내에 통합하도록 특별히 설계되었습니다.\n\n여기에서 CSS-in-JS의 이점을 확인해보세요.\n\n\n\n# 스타일드 컴포넌트 시작하기\n\n## 설치 및 설정\n\n스타일드 컴포넌트를 시작하기 위해 준비해야 할 사항은 다음과 같습니다:\n\n- React 설정: 기본적인 React 프로젝트가 설정되어 있어야 합니다. Create React App과 같은 도구를 사용하여 이 프로세스를 간편화할 수 있습니다 (https://create-react-app.dev/).\n- Styled Components 설치: npm 또는 yarn을 사용하여 Styled Components 라이브러리를 설치하세요.\n\n\n\n```js\nnpm install styled-components\n```\n\n설치가 완료되면 Styled Components를 프로젝트에 import하여 즉시 사용할 수 있습니다.\n\n# 심층 분석, 기본 구문 및 사용\n\n## - 기본 사용법 및 구문\n\n\n\nStyled Components는 스타일을 정의하기 위해 태그된 템플릿 리터럴을 활용합니다. 아래는 styled button 컴포넌트를 만드는 기본적인 예제입니다:\n\n```js\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: #007bff;\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return \u003cButton\u003eClick me\u003c/Button\u003e;\n};\n```\n\n## 스타일링된 컴포넌트 만들기\n\nStyled Components를 사용하면 HTML 요소나 재사용 가능한 컴포넌트 기본 요소의 사용자 정의된 스타일 버전을 생성할 수 있습니다. 예를 들어;\n\n\n\n```js\nconst StyledDiv = styled.div`\n  background-color: #f0f0f0;\n  padding: 1rem;\n`;\n\n// 사용 방법\nconst MyComponent = () =\u003e {\n  return \u003cStyledDiv\u003eHello, world!\u003c/StyledDiv\u003e;\n};\n```\n\nStyled Components를 사용하면 가능성이 무한합니다. 전통적인 CSS로 스타일을 지정하는 것과 동일하게 모든 컴포넌트나 HTML 요소에 스타일을 적용할 수 있지만, 스코피잉 및 재사용성의 추가 혜택이 있습니다.\n\n## - Styled Components in Action: Building Common UI Elements (with Illustrations)\n\n핵심 개념을 이해했으니, Styled Components를 사용하여 다양한 UI 요소를 스타일링하는 방법을 살펴보겠습니다.\n\n\n\n\n- 버튼: 이전 예제에서 볼 수 있듯이, 스타일된 컴포넌트는 사용자 정의 스타일을 가진 재사용 가능한 버튼을 만드는 데 뛰어납니다.\n- 카드: 스타일된 컴포넌트를 사용하여 시각적으로 매력적이고 정보를 제공하는 카드를 만들어보세요.\n- 아바타 이미지: 카드용 스타일링된 아바타 이미지를 만들어보세요.\n\n```js\nimport styled from \"styled-components\";\n\nconst Card = styled.div`\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 4px rgba(0.1, 0.1, 0.1, 0.2);\n  padding: 20px;\n  margin: 10px;\n`;\nconst CardTitle = styled.h2`\n  font-size: 1.2em;\n  margin-bottom: 10px;\n  align-item: center;\n  text-align: center;\n`;\nconst CardContent = styled.p`\n  margin-bottom: 10px;\n`;\nconst Button = styled.button`\n  padding: 10px 20px;\n  background-color: #007bff;\n  color: #fff;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\nconst AvatarImage = styled.img`\n  margin: 0px 20px 0px 0px;\n  height: 40px;\n  border-radius: 50%;\n  display: block;\n  margin: auto;\n`;\n\nfunction ProductCard() {\n  return (\n     \u003cCard\u003e\n    \u003cCardTitle\u003eJames Washington\u003c/CardTitle\u003e\n    \u003cAvatarImage\n      src=\"https://miro.medium.com/v2/resize:fit:740/1*ooOH6jo8I0ns0J-BE0SAow.jpeg\"\n      alt={name}\n    /\u003e\n    \u003cCardContent\u003e\n      Imagine styling your web applications like preparing a dish. You have a\n      pantry full of ingredients (styles) and a recipe (HTML structure) to\n      follow. But instead of traditional pots and pans, you wield a magic wand\n      🪄 that lets you conjure up your culinary creations effortlessly. This\n      is the magic of CSS-in-JS, particularly when wielded with the power of\n      Styled Components.\n    \u003c/CardContent\u003e\n    \u003cButton\u003eTry Now\u003c/Button\u003e\n  \u003c/Card\u003e\n  );\n}\n```\n\n실시간 미리보기🛠️:\n\n이 샌드박스 환경에서 실시간 미리보기를 살펴보세요. 자유롭게 실험하고 플레이그라운드 내에서 여러 가지 스타일링 기술을 적용해보세요.\n\n\n\n엔지니어로서 프로젝트를 진행하며 복잡성이 증가함에 따라 개발을 간소화하기 위해 재사용 가능한 구성 요소의 가치를 깨달았어요. 그래서 Styled Components를 주요 스타일링 방법으로 사용하여 만든 컴포넌트 라이브러리인 Vinyl Component Blocks를 만들었죠. Vinyl Component Blocks는 UI 컴포넌트 생성과 관련된 반복 작업을 줄이고 효율성을 촉진하며 일관된 개발 경험을 제공하는 것을 목표로 합니다. GitHub에서 라이브러리를 살펴보고, Styled Components를 사용하여 복잡한 UI 아키텍처를 어떻게 활용하는지 확인해보세요.\n\n더 많은 정보는 아래 링크를 확인해보세요:\n\n- Styled Components 공식 문서: 라이브러리의 기능과 API 참조를 더 깊이 파고들어보세요: https://styled-components.com/docs\n- Styled Components를 활용한 고급 기술: 테마 지정, 중첩, 전역 스타일 등과 같은 고급 기술을 탐구해보세요: https://styled-components.com/docs/api\n- Vinyl Component Blocks: 컴포넌트 라이브러리 및 기능을 탐색하고, Styled Components를 활용하여 복잡한 UI 아키텍처를 어떻게 구현하는지 확인하세요: https://github.com/Vinyl-Davyl/vinyl-component-blocks\n\n## - Styled Components를 활용한 스타일링 전략\n\n\n\n스타일드 컴포넌트의 힘을 발휘해보세요: 동적이고 재사용 가능한 UI를 위한 전략들. 스타일드 컴포넌트는 스타일링 능력을 향상시키는 다양한 기능을 제공합니다:\n\n- 전역 스타일 대 컴포넌트별 스타일\n\n스타일드 컴포넌트는 전역 스타일과 컴포넌트별 스타일을 정의하는 데 유연성을 제공합니다. 전역 스타일은 createGlobalStyle API를 사용하여 정의할 수 있습니다.\n\n```js\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyles = createGlobalStyle`\n  body {\n    font-family: 'Roboto', sans-serif;\n    background-color: #f8f8f8;\n  }\n`;\n\nconst MyApp = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cGlobalStyles /\u003e\n      \u003cMyComponent /\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n\n\n컴포넌트별로 스타일이 캡슐화되어 있습니다. 이전 예제와 같이요.\n\n이 방식을 통해 응용 프로그램 전체에서 일관된 디자인 시스템을 유지할 수 있으면서도 컴포넌트별 스타일의 모듈성을 누릴 수 있어요.\n\n2. Props로 테마 적용 및 사용자 정의\n\nStyled Components의 주요 기능 중 하나는 컴포넌트 props에 따라 스타일을 사용자 정의할 수 있는 기능이에요. 이는 동적 스타일 및 테마를 가진 재사용 가능한 컴포넌트를 생성하는 데 특히 유용합니다.\n\n\n\n```js\nconst Button = styled.button`\n  background-color: ${(props) =\u003e (props.primary ? '#007bff' : '#6c757d')};\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cButton primary\u003e주 버튼\u003c/Button\u003e\n      \u003cButton\u003e보조 버튼\u003c/Button\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n프롭스(props)를 활용하여 중복 코드를 방지하면서도 다양한 사용 사례에 맞게 유연한 컴포넌트를 생성할 수 있습니다.\n\n- 중첩(Nesting): 보다 복잡한 레이아웃 및 조직을 위해 서로 중첩된 스타일을 활용할 수 있습니다.\n- Styled System 통합: 통합 스타일링 접근을 위해 Styled Components와 같은 인기 있는 스타일링 시스템(Bootstrap 또는 Material-UI)을 활용할 수 있습니다.\n\n# Styled Components 이상: 대안 탐색하기\n\n\n\n\nStyled Components는 React 애플리케이션을 스타일링하는 인기 있는 선택지입니다. 그러나 탐색할 가치가 있는 여러 가지 대안이 있습니다. Emotion, JSS, CSS Modules는 각각 고유한 특징과 사용 사례를 가진 실용적인 옵션입니다.\n\n## Emotion\n\nEmotion은 다른 CSS-in-JS 라이브러리로, Styled Components와 유사한 기능을 제공하지만 자체 CSS 프롭 지원 및 자동 벤더 프리픽싱과 같은 추가 기능을 제공합니다.\n\n## JSS\n\n\n\nJSS (JSS는 인라인 스타일 및 테마에 매우 좋습니다)은 인라인 스타일과 테마에 중점을 둔 CSS-in-JS 라이브러리입니다. 이는 컴포넌트 속성에 따라 스타일을 동적으로 생성하기 위한 강력한 API를 제공하여 매우 사용자 정의 가능한 UI 컴포넌트를 구축하기에 이상적입니다.\n\n## CSS 모듈\n\nCSS 모듈은 React 애플리케이션에서 스타일링하는 다른 접근 방식으로, 웹팩과 같은 번들러에서 내장된 CSS 모듈 지원을 활용합니다. CSS 모듘을 사용하면 전통적인 CSS 파일을 작성하고 컴포넌트로 가져와 로컬 범위 및 자동 클래스명 생성과 같은 이점을 누릴 수 있습니다.\n\n저는 모든 JavaScript 스타일링 라이브러리에 대해 전문가는 아니에요. 제 경험이 주로 스타일드 컴포넌트와 관련이 있습니다. 이것은 내가 한 대부분의 작업에서 인기가 많은 훌륭한 도구입니다.\n\n\n\n# 결론 및 다음 단계\n\n축하해요!🎊 이제 Styled Components를 사용한 CSS-in-JS 스타일링의 기술을 정복했어요. 이 지식을 바탕으로 멋진 UI 구성 요소를 만들어 웹 애플리케이션을 더 생동감 있게 만들 수 있을 거예요.\n\n하지만 스타일링을 정복하는 것은 계속되는 여정이에요. 새로운 기술을 탐험하고 다양한 라이브러리를 실험하며 프론트엔드 개발의 최신 트렌드를 계속해서 따라가 주세요. 헌신과 실력 향상으로 함께 하겠습니다. 더 많은 업데이트와 이런 콘텐츠를 기대해 주세요!\n\n# 그림 및 참고자료\n\n\n\n- 스타일된 컴포넌트 공식 문서\n- Emotion 공식 문서\n- JSS 공식 문서\n- CSS Modules 공식 문서\n- 멋진 리액트 컴포넌트를 위한 GitHub 저장소\n- Vinyl-Component-Blocks, 스타일된 컴포넌트 기반 UI 라이브러리\n\nStyled Components 💅🏻를 사용하여 CSS-in-JS의 스타일링 세계를 정복하기 준비가 되었습니다. 다음에 또 만나요, Merci!","ogImage":{"url":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"},"coverImage":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png","tag":["Tech"],"readingTime":8},{"title":"코딩 슈퍼파워를 발휘해보세요 React 및 React Native용 상위 10개의 VS 코드 확장 프로그램","description":"","date":"2024-05-14 11:18","slug":"2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative","content":"\n\nReact 또는 React Native 개발자이신가요? 코딩 경험을 더욱 향상시켜보고 싶다면요? Visual Studio Code(VS Code)는 이미 웹 및 모바일 앱 개발에 대한 환상적인 선택지입니다. 하지만 이 멋진 10가지 확장 기능을 추가하여 더욱 효율적으로 개발할 수 있습니다. 이 확장 기능들은 시간을 절약할 뿐만 아니라 코딩을 더욱 쉽게 만들어줍니다.\n\n1. ESLint\n\nESLint에 대해 들어본 적이 있을 것입니다. 그것이 그렇듯 유용하답니다. ESLint는 여러분의 코드를 훌륭한 동반자로 만들어 줍니다. 자바스크립트 및 리액트 코드에서 오류를 찾아주고 최고의 관행을 준수하도록 도와줍니다. 이 확장 기능을 사용하면 코드를 작성하는 도중 문제점을 발견하여 깨끗하고 일관된 코드를 유지할 수 있습니다.\n\n2. Prettier — Code Formatter\n\n\n\n끝없는 코드 형식에 대한 논쟁을 되새김없이 안녕하세요! Prettier가 미리 정의된 규칙에 따라 코드를 자동으로 서식 지정하여 코드베이스를 균일하고 아름답게 만들어 줍니다. 개인 코드 스타일리스트가 있는 것 같아요.\n\n3. React 스니펫\n\n일일이 입력하는 대신 몇 글자만 입력하면 코드가 마법처럼 나타납니다! React 스니펫은 다양한 React 코드 스니펫을 제공하여 시간을 절약하고 오타를 방지합니다.\n\n4. Bracket Pair Colorizer\n\n\n\n중첩된 코드 블록을 추적하는 것은 머리 아플 수 있어요. Bracket Pair Colorizer가 여기 있어 요. 괄호에 구별되는 색상을 할당하여 일치하는 쌍을 빠르게 확인할 수 있게 해 줍니다.\n\n5. Auto Close Tag\n\n이제 HTML 또는 XML 태그를 닫는 것을 잊을 일이 없어요. Auto Close Tag은 열린 태그를 입력하는 즉시 자동으로 닫히는 태그를 추가하여 구조화된 마크업을 보장해 줍니다.\n\n6. Auto Rename Tag\n\n\n\n매칭 태그는 훌륭하지만 하나를 변경하려면 어떻게 할까요? Auto Rename Tag 기능이 모두 처리해줍니다. 하나의 태그 이름을 변경하면 다른 태그도 자동으로 업데이트됩니다. \n\n7. 경로 인텔리센스\n\n더 이상 파일 경로를 추측하거나 가져오기로 번뜩임 없이 고민할 필요가 없습니다. 경로 인텔리센스는 파일 경로에 대한 자동 제안을 제공하여 내비게이션을 쉽게 만듭니다.\n\n8. GitLens — Git Supercharged\n\n\n\nGitLens가 여러분의 버전 관리에 슈퍼파워를 더해줍니다. 한 줄을 마지막으로 수정한 사람을 보여주고, 히스토리를 쉽게 탐색할 수 있게 해주며, 코드의 Git 기록에 대한 통찰력을 제공해줍니다.\n\n9. 코드 맞춤법 검사기\n\n오타는 발생할 수 있습니다, 심지어 코드 주석과 문자열에서도요. 코드 맞춤법 검사기는 슬기롭게 잡아내어라는 몸소 보여줌으로써 여러분의 문서가 전문적으로 보일 수 있도록 도와줍니다.\n\n10. React Native 도구\n\n\n\n만약 React Native로 작업 중이라면, 이 확장 프로그램은 정말 대단해요. React Native에 특화된 디버깅 및 인텔리센스를 제공하여 모바일 개발이 쉬워집니다.\n\n이 툴킷에 있는 이 10가지 VS Code 확장 프로그램을 사용하면 React 및 React Native 코딩 닌자로 성장할 수 있어요. 한번 시도해보세요. 생산성이 그리고 코딩 즐거움이 두 배로 늘어나는 걸 보게 될 거예요. 코딩 즐겁게! 🚀","ogImage":{"url":"/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png"},"coverImage":"/assets/img/2024-05-14-UnlockYourCodingSuperpowersTop10VSCodeExtensionsforReactandReactNative_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 19 베타 버전이 출시되었어요","description":"","date":"2024-05-14 11:17","slug":"2024-05-14-React19betaisout","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-React19betaisout_0.png\" /\u003e\n\nReact 19 베타가 출시되었습니다. React 생태계에 독특한 업데이트와 기능을 가져왔어요. 이번 글에서는 React 19가 가져온 새로운 Hooks 및 API를 살펴보며, 이러한 변경 사항이 앞으로 React 애플리케이션 개발하는 방식을 개선할 수 있는 방법을 알아볼 거에요.\n\n이 글은 \"대용량 앱 구축\" 뉴스레터 커뮤니티에 보내는 첫 정보 제공 자료입니다. 뉴스레터에서는 대규모 웹 애플리케이션을 구축하고 유지하는 데 중점을 둔 프론트엔드 엔지니어링과 JavaScript 기술에 관한 콘텐츠를 공유합니다.\n\n저희가 공유하는 일부 콘텐츠는 코드 변경 및 API 향상에 더 초점을 맞출 거에요 (이와 같은 글 같죠!), 다른 콘텐츠는 대규모 웹 애플리케이션을 다루는 산업에서 종사하는 경험이 풍부한 엔지니어들의 경험, 사례 연구 또는 통찰력 있는 일화를 공유할 거에요.\n\n\n\n이런 문제들을 이메일로 받아보려면 구독해주세요!\n\n## React 19\n\nReact 19가 2024년 4월 25일에 공식 베타 릴리스로 무대에 등장했습니다. 이 새로운 버전에는 새로운 Hooks 및 API, React 서버 컴포넌트, 일부 만료된 React API의 제거 등 다양한 변경 사항이 포함되어 있습니다. 오늘의 이슈에서는 주로 React 19가 소개한 흥미로운 새로운 Hooks 및 API를 살펴볼 것입니다.\n\nReact 19는 아직 베타 버전이며 주로 라이브러리 개발자를 대상으로 만들어졌습니다. 이들은 새로운 변경 사항에 대해 실험하고 라이브러리를 적응시키기 위해 업그레이드해야 합니다. 일반 앱 개발자들은 React 18.3로 업그레이드하고 React 19의 안정 버전을 기다리는 것이 좋습니다. React 19로 업그레이드하는 더 자세한 정보는 React 팀이 제공한 React 19 베타 업그레이드 가이드를 확인할 수 있습니다.\n\n\n\n# 양식 제출 및 낙관적 업데이트\n\n지금날 웹 애플리케이션을 사용하는 방법 중 상당 부분은 사용자 인증부터 데이터 제출, 전자 상거래 거래, 피드백 수집, 검색 쿼리 등 다양한 목적의 양식과 상호 작용하는 것에 관련되어 있습니다. 그 결과로 React 컴포넌트 개발에서 매우 흔한 행동 중 하나는 양식 제출을 처리하고 제출될 때 양식이 무엇을 해야 하는지의 비동기 업데이트를 다루는 것입니다.\n\n이러한 비동기 업데이트를 처리하는 양식 컴포넌트의 간단한 예시는 다음과 같이 보일 수 있습니다:\n\n![예시 이미지](/assets/img/2024-05-14-React19betaisout_1.png)\n\n\n\n위 예제에서 Component는 양식의 상태를 관리하고 양식 제출을 비동기적으로 처리합니다. 제출 후 submitForm() 함수는 서버로 양식 정보를 제출하고 응답을 반환합니다. 컴포넌트는 상태를 업데이트하여 제출 프로세스에 대한 사용자 피드백을 표시합니다.\n\nReact 18에서 UI를 비긴요하지 않은 방식으로 한 뷰에서 다른 뷰로 전환하는 개념을 전환으로 명명했습니다. React 19는 이제 비동기 전환에서 async 함수를 사용할 수 있으며 useTransition Hook을 사용하여 비동기 데이터 검색 중에 로딩 지시자나 플레이스홀더를 관리할 수도 있습니다.\n\n# 작업\n\nReact 19에서 비동기 전환을 사용하는 기능은 작업으로 더 이상 발전되었으며, 비동기 전환을 사용하는 함수를 작업이라고 합니다. 위에서 본 것처럼 사용하기 위해 useActionState Hook과 같은 몇 가지 전문화된 Hook이 있으며, 첫 번째로 살펴볼 것은 useActionState Hook입니다.\n\n\n\n## useActionState\n\nuseActionState() 훅은 세 가지 매개변수를 받습니다:\n\n- \"action\" 함수는 폼 액션이 트리거될 때 실행됩니다.\n- 초기 상태 객체는 사용자 상호작용 전에 폼의 시작 상태를 설정합니다.\n- [옵션] 이 폼을 수정하는 고유 페이지 URL을 가리키는 퍼머링크입니다.\n\n그리고 튜플로 세 가지 값을 반환합니다:\n\n\n\n- 현재 양식의 상태.\n- 양식 동작을 트리거하는 함수.\n- 동작이 진행 중인지를 나타내는 부울 값.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_2.png)\n\nuseActionState Hook에 첫 번째 인자로 전달된 작업 함수는 양식을 제출할 때 트리거되고, 양식 제출이 성공하거나 오류가 발생할 때 전환할 양식 상태를 반환합니다. 이 함수는 두 개의 매개변수를 받습니다 - 현재 양식의 상태와 작업이 트리거된 시점의 양식 데이터입니다.\n\n다음은 작업() 함수를 만드는 예시입니다. 이 함수는 가상의 submitForm() 함수를 호출하고 이후에 서버로 양식 데이터를 제출하는 API 호출을 트리거합니다. 작업이 성공하면, 다음 양식 상태를 나타내는 양식 상태 객체를 반환합니다. 작업이 실패하면, 사용자가 문제를 해결하는 데 도움이 될 수 있는 오류 메시지 또는 표시기를 포함한 오류 상태를 반영하는 양식 상태 객체를 반환합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-React19betaisout_3.png\" /\u003e\n\n저희가 설정한 useActionState() 훅으로, 폼 상태, 디스패치 및 보류 중인 값들을 폼 템플릿에서 사용할 수 있습니다.\n\n## `form` 액션\n\nReact 19에서는 `form` 요소에 이제 action 속성이 있어서, 폼을 제출할 때 트리거될 수 있는 액션 함수를 받을 수 있습니다. 여기에서는 useActionState() 훅에서 디스패치 함수를 전달할 것입니다.\n\n\n\n\n![React 19 beta is out](/assets/img/2024-05-14-React19betaisout_4.png)\n\n폼 템플릿에서 상태를 표시하고 isPending 값 사용하여 비동기 액션이 처리 중임을 사용자에게 전달할 수 있습니다.\n\n![React 19 beta is out](/assets/img/2024-05-14-React19betaisout_5.png)\n\n이렇게 하면, React의 이러한 새로운 변경 사항으로 인해 폼에서 비동기 전환을 다룰 때 처리 중인 상태, 오류 및 순차 요청을 수동으로 처리할 필요가 없어집니다. 대신, 이러한 값들은 useActionState() Hook에서 직접 액세스할 수 있습니다.\n\n\n\n\n## useFormStatus\n\n리액트 19는 useFormStatus라는 새로운 훅을 소개합니다. 이 훅은 중첩된 자식 컴포넌트가 그들이 위치한 폼에 대한 정보에 액세스할 수 있게 해줍니다 (마치 폼이 컨텍스트 제공자인 것처럼).\n\n![이미지](/assets/img/2024-05-14-React19betaisout_6.png)\n\n부모 폼 정보에 액세스하는 행동은 컨텍스트를 통해 수행할 수 있지만, 리액트 19에서는 useFormStatus 훅을 소개하여 중첩된 컴포넌트 내에서 폼 데이터를 처리하는 일반적인 경우를 훨씬 쉽게 만들었습니다.\n\n\n\n## useOptimistic\n\nuseOptimistic() 훅은 React 19에서 추가된 또 다른 새로운 훅입니다. 네트워크 요청과 같은 백그라운드 작업이 완료될 때 낙관적 업데이트를 수행할 수 있습니다. 이를 통해 사용자 상호작용에 빠른 응답을 제공하여 사용자 경험을 향상시킬 수 있습니다.\n\n아래는 부모에서 전달된 메시지 상태 속성을 관리하기 위해 useOptimistic() 훅을 사용하는 예시입니다.\n\n![img](/assets/img/2024-05-14-React19betaisout_7.png)\n\n\n\n위의 컴포넌트 예시에서는 useOptimistic Hook을 사용하여 메시지 상태를 낙관적으로 업데이트하는 것을 관리합니다. 이 상태는 prop으로 전달됩니다.\n\n사용자가 \"Add Message\" 버튼을 클릭하여 폼을 제출하면 submitForm() 함수가 트리거됩니다. 메시지를 업데이트하기 위한 API 요청을 시작하기 전에, 새 메시지 값을 폼 데이터에서 얻어 setOptimisticMessage() 함수가 호출됩니다. 이렇게 하면 즉시 UI가 낙관적인 변경을 반영하여 사용자에게 즉각적인 피드백을 제공합니다.\n\n업데이트가 완료되거나 오류가 발생하면 React가 자동으로 메시지 prop 값으로 전환됩니다.\n\n# 새로운 API 사용\n\n\n\nReact 19에서는 Promise 또는 context와 같은 리소스에서 값을 읽는 다재다능한 방식으로 새 use API가 소개되었습니다.\n\n예를 들어, context 값을 읽으려면 단순히 context를 use()에 전달하면 함수가 컴포넌트 트리를 탐색하여 가장 가까운 context 제공자를 찾습니다.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_8.png)\n\nuseContext() Hook과 달리, use() 함수는 조건문과 루프 내에서 컴포넌트에서 사용할 수 있습니다!\n\n\n\n\n![React19betaisout_9](/assets/img/2024-05-14-React19betaisout_9.png)\n\nuse()도 Suspense와 에러 경계와 매끄럽게 통합됩니다. 프라미스를 읽기 위해서(React 문서의 서버에서 클라이언트로 데이터 스트리밍에서 더 자세히 참조).\n\n# React 서버 컴포넌트\n\nReact 서버 컴포넌트는 React 19에서 소개되는 새로운 기능으로, 서버에서 실행되는 상태 없는 React 컴포넌트를 만들 수 있게 해줍니다. 이러한 컴포넌트는 클라이언트 응용 프로그램이나 서버 측 렌더링 서버와 다른 환경에서 번들링되기 전에 미리 실행됩니다.\n\n\n\n\n리액트 서버 컴포넌트는 웹 서버에서 실행할 수 있기 때문에 API와 상호 작용하지 않고도 데이터 레이어에 액세스할 수 있어요!\n\n![이미지](/assets/img/2024-05-14-React19betaisout_10.png)\n\n정말 멋지죠! 이를 통해 API 엔드포인트를 노출할 필요가 없고, 데이터를 컴포넌트로 직접로딩하기 위해 추가적인 클라이언트 측 fetching 로직을 사용할 필요가 없어요. 모든 데이터 처리는 서버에서 이루어져요.\n\n서버 컴포넌트는 서버에서 실행되며 브라우저에서 실행되지 않습니다. 결과적으로 이러한 컴포넌트들은 useState와 같은 전통적인 리액트 컴포넌트 API를 사용할 수 없어요. 리액트 서버 컴포넌트 환경에 상호 작용성을 도입하기 위해서는 서버 컴포넌트와 상호 작용을 처리하기 위한 클라이언트 컴포넌트들을 결합해야 해요.\n\n\n\n위의 블로그 포스트 예시를 계속하면, 이런 식으로 Comment 컴포넌트가 상태(state)와 상호작용을 포함하는 클라이언트 컴포넌트로 렌더링된다는 것을 보여줄 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-React19betaisout_11.png)\n\n위 예시에서 컴포넌트 파일의 맨 위에 \"use client\"를 선언하는 것에 유의하세요. React 서버 컴포넌트와 작업할 때, \"use client\"는 해당 컴포넌트가 클라이언트 컴포넌트임을 나타냅니다. 이는 상태를 관리하고 사용자 상호작용을 처리하며 브라우저별 API를 사용할 수 있는 것을 의미합니다. 이 지시어는 명시적으로 React 프레임워크와 번들러에게 이 컴포넌트를 서버에서 실행되는 상태 없는 서버 컴포넌트와 구분하여 다르게 취급하도록 알려줍니다.\n\n그 반대로 React 서버 컴포넌트는 기본값이기 때문에 서버 컴포넌트 파일의 맨 위에 \"use server\"를 명시하지 않습니다. 대신에 \"use server\"는 클라이언트 컴포넌트에서 호출할 수 있는 서버 측 함수를 표시하는 데에 사용되어야 합니다. 이것을 서버 액션(Server Actions)이라고 합니다.\n\n\n\nReact Server Components는 React 애플리케이션 구조를 변경하여 클라이언트와 서버 간의 관심사를 분리합니다. React 팀은 그들이 결국 광범위하게 채택되고 React 애플리케이션을 구축하는 방법을 변화시킬 것이라고 믿고 있습니다. 이 순간, 저희는 \"Building Large Scale Web Apps\" 책에 추가할 새로운 장 \"React in 2024\"의 일환으로 React Server Components를 깊이 파헤치고 있습니다. 이에 대해 더 많은 정보를 곧 공유할 예정입니다!\n\n이 기사를 즐겼다면? 이 뉴스레터를 직접 받아보기 위해 https://largeapps.substack.com에서 구독하세요.\n\nReact 19의 새로운 기능에 대한 자세한 내용과 베타 버전을 시도하는 방법에 대해서는 공식 React 문서의 React 19 베타 설명서를 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-14-React19betaisout_0.png"},"coverImage":"/assets/img/2024-05-14-React19betaisout_0.png","tag":["Tech"],"readingTime":7}],"page":"120","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"120"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>