<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/127" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/127" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" href="/post/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 5 게임 만들기  타일 게임 튜토리얼" href="/post/2024-05-12-MakeHTML5GamesTileGameTutorial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 5 게임 만들기  타일 게임 튜토리얼</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현대 웹을 위해 새롭게 탄생한 자동완성 상자" href="/post/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">현대 웹을 위해 새롭게 탄생한 자동완성 상자</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 18의 새로운 기능 정리 비교" href="/post/2024-05-12-Angular18NewFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Angular18NewFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 18의 새로운 기능 정리 비교</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" href="/post/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DOM 기반 XSS에 대해서 알아보자" href="/post/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DOM 기반 XSS에 대해서 알아보자" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DOM 기반 XSS에 대해서 알아보자" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">DOM 기반 XSS에 대해서 알아보자</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" href="/post/2024-05-12-MockingDatainreactjsorjavascript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" href="/post/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업" href="/post/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원" href="/post/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link posts_-active__YVJEi" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기","description":"","date":"2024-05-12 23:37","slug":"2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia","content":"\n\n![이미지](/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png)\n\nVue 2에서 Vue 3로 이주하면서 Pinia가 이제 Vue 3를 위한 권장 스토어 플러그인이 되었고 Vuex가 아니게 되어 전환이 필요했습니다. 우리 아키텍처와 팀 전체가 Vuex와 작업하는 데 익숙했기 때문에 모든 스토어를 하나의 전역 변수 $store로 액세스하고 모든 곳에서 손쉽게 액세스할 수 있을 때를 좋아합니다!\n\n그래서 우리는 Pinia에서 부족해 보이는 3가지 핵심 기능을 지원하기 위해 일부 사항을 수정했습니다.\n\n- 우리 아직까지 사용 중인 this.$store를 통해 스토어에 액세스하기\n- 중첩 구조의 스토어 보유\n- 액션 내에서 Vue Router에 액세스하기\n\n\n\n# 기본 설정\n\n우리는 src/stores 안에 비슷한 디렉토리 구조를 가진 모든 스토어를 생성했습니다.\n\n```javascript\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n```\n\n주요 index.js는 중첩과 모든 것을 포함한 완전한 스토어의 진입점 역할을 하며, 중첩이 어떻게 작동하는지 등에 대한 설명은 다음 단계에서 설명하겠습니다.\n\n\n\n```js\n// src/store/index.js\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\nexport default {\n  token: null\n}\n```\n\n\n\n```js\n// src/store/auth/getters.js\n\nexport default {}\n```\n\n# 1. Pinia에서 스토어 중첩하기\n\n기본적으로 Pinia는 필요할 때 스토어를 직접 가져와서 사용하는 것이지만, 우리가 원하는 것은 그게 아닙니다. Vuex에서 했던 것처럼 쉽게 접근하고 싶습니다. 그래서 다음과 같이 했습니다.\n\n메인 스토어에 스토어 이름(예: auth)으로 새로운 상태 변수를 만듭니다.\n\n\n\n```js\n// src/store/state.js\nexport default {\n  auth: null\n}\n```\n\n이 변수를 사용하려는 Pinia 스토어에 초기화하고 설정하세요. 예를 들어, authStore 를 사용하시려면 주요 스토어의 액션에 추가하여 필요한 모든 스토어를 초기화할 수 있습니다. 예를 들어, setStores()에 다음을 추가하세요.\n\n```js\n// src/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore() // 액션 내에서 스토어를 초기화합니다.\n    },\n    ... // 다른 메서드\n  }\n})\n```\n\n주요 스토어를 초기화한 후에 이 액션을 호출하세요.\n\n\n\n```js\n// main.js\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\nexport const $store = store() // 메인 스토어 초기화\n$store.setStores() // 모든 중첩 스토어 초기화하는 액션 호출\n```\n\n그게 다야! 이제 모든 스토어에 메인 스토어에서 직접 액세스할 수 있습니다. 다음은 예시입니다 (Options API),\n\n```js\n\u003cscript\u003e\nimport { $store } from \"@/main.js\"\n\nexport default {\n    mounted() {\n       console.log($store.auth.token) // auth 상태에 액세스\n       console.log($store.auth.setToken(\"12345\")) // auth 액션 호출\n       console.log($store.someState) // 메인 스토어 상태에 액세스\n    }\n}\n\n\u003c/script\u003e\n```\n\n# 2. 핀니아 스토어를 전역적으로 접근 가능하게 만들기\n\n\n\n이제 한 변수를 통해 중첩된 상점에 접근할 수 있게 되었으니, 이제 그것을 컴포넌트 내에서 직접 액세스할 수 있도록 만들어보겠습니다. 그렇게 하려면 vue의 Global Properties를 사용하여 매핑해야 합니다. 다음과 같이 해보세요.\n\n- main.js에서 메인 상점을 초기화하십시오.\n- $store라는 전역 속성을 설정하고 해당 상점을 할당하십시오.\n- 즐기세요!\n\n```js\n// main.js\n\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\n\nexport const $store = store() // 주 상점 초기화\napp.config.globalProperties.$store = $store // 상점을 전역적으로 액세스 가능하게 만듦\napp.config.globalProperties.$store.setStores() // 모든 중첩된 상점을 초기화하는 작업 호출\n```\n\n이것으로 끝났습니다! 이제 옵션 API를 사용하는 컴포넌트 내에서 다음과 같이 액세스할 수 있습니다:\n\n\n\n```js\n\u003cscript\u003e\nexport default {\n    mounted() {\n       console.log(this.$store.auth.token) // \"auth\" 상태에 접근하기\n       console.log(this.$store.auth.setToken(\"12345\")) // \"auth\" 액션 호출하기\n       console.log(this.$store.someState) // 메인 상점의 상태에 접근하기\n    },\n    watch: {\n        '$store.auth.token'() { console.log(\"변경 발생\") } // 워치하여 변경 감지하기\n    } \n}\n\n\u003c/script\u003e\n```\n\n# 3. 핀이아 액션 내부에서 Vue Router에 액세스하기\n\n우리는 상점에서 라우터 인스턴스를 직접 가져오고 사용하려고 시도했지만, 올바르지 않은 것처럼 보였습니다. 그때 우리는 특정 속성을 설정할 수 있는 방법을 찾았고 이렇게 설정할 수 있습니다.\n\n```js\n// main.js\n\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기서 라우터를 설정하여 상점 내에서 접근할 수 있도록 하기\napp.use(pinia)\n\n...\n```\n\n\n\n이렇게 하면 우리는 스토어 내에서 언제든지 라우터 인스턴스에 액세스할 수 있어요.\n\n```js\n// srcs/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    logRoute() {\n       console.log(this.router) // Router Instance\n       console.log(this.router.currentRoute) // 현재 라우트 가져오기 (this.$route)\n    }\n    ... // 다른 메서드\n  }\n})\n```\n\n그리고 이렇게 함으로써 우리는 세 가지 고통을 해결했어요! 세 가지가 모두 구현된 완전한 스크립트는 다음과 같아요.\n\n```js\n디렉토리 구조\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n  -\u003e main.js\n  -\u003e router\n     -\u003e index.js\n```\n\n\n\n```js\n// src/store/index.js\n\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\n\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\n\nexport default {\n  token: null\n}\n```\n\n\n\n```js \n// src/store/auth/getters.js\n\nexport default {}\n```\n\n```js\n// main.js\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기에 router를 설정하여 store 내부에서 접근할 수 있게 함\napp.use(pinia)\n...\n\nexport const $store = store() // 주요 Store 초기화\napp.config.globalProperties.$store = $store // Store를 전역적으로 접근 가능하게 함\napp.config.globalProperties.$store.setStores() // 모든 중첩 Store를 초기화하는 작업 호출\n```\n\n여기까지입니다! 같은 결과를 달성할 수 있는 다른 방법을 발견하면 알려주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"},"coverImage":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML 5 게임 만들기  타일 게임 튜토리얼","description":"","date":"2024-05-12 23:33","slug":"2024-05-12-MakeHTML5GamesTileGameTutorial","content":"\n\n## 모든 필요한 것\n\n이 튜토리얼과 매칭 비디오 튜토리얼에서는 HTML 5 Canvas와 JavaScript를 사용하여 타일 게임을 코딩하는 단계를 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png)\n\n타일 게임은 기본적으로 그리드로 배열된 게임이거나 타일을 드래그하는 게임입니다. 이 경우, 우리는 객체의 나머지가 변화하는 것과 달리 어떤 객체가 변하지 않는지 알아내는 그리드 기반 게임을 가지고 있습니다. 이 게임은 또한 패턴 게임이라고도 불릴 수 있습니다.\n\n\n\n화면 하단에는 찾아야 할 \"영원한\" 물체의 수와 소요된 시간이 표시됩니다. 다섯 개의 레벨이 있으며, 각 레벨마다 더 많은 물체와 찾아야 할 더 많은 물체가 있습니다. 리더보드를 사용하여 가장 낮은 시간을 추적합니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_1.png)\n\n간단한 Tile 게임과 완전한 Tile 게임 두 가지 예제가 있습니다. 먼저 간단한 것을 살펴보셔도 좋지만, 튜토리얼에서는 완전한 게임을 만드는 단계를 안내해드립니다.\n\n## 준비하기\n\n\n\n아무도 따라 할 수 있어야 하지만, 이러한 종류의 게임을 직접 만드는 데 사용되는 많은 기술과 기술이 있습니다. 이 마법의 세계를 소개하는 ◎ 캔버스에서 코딩 창의성 가이드를 확인해보세요.\n\n![게임 만들기](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_2.png)\n\n우리는 코딩 창의성을 위한 ZIM JavaScript 캔버스 프레임워크로 게임을 만들 것입니다! ZIM으로 만들 수 있는 다양한 것들을 확인해보기를 원할 수도 있습니다. ZIM으로 만들 수 있는 많은 것들이 있는 사이트도 확인해보세요. Zapp이 많이 있는 온라인 편집기도 있습니다!\n\n## 편집기\n\n\n\n일반적으로 Microsoft의 무료이고 빠르게 설치할 수 있는 VS Code와 같은 데스크탑 편집기에서 게임을 만듭니다. 여러분이 VS Code를 사용 중이라고 가정하고 튜토리얼을 진행할 것입니다. 하지만 원한다면 온라인에서 모두 코딩할 수 있는 ZIM 편집기에서도 작업할 수 있어요.\n\n## 템플릿\n\nVS Code에서 시작하려면 tile.html이라는 새 파일을 만들고 https://zimjs.com/code에서 ZIM 템플릿을 가져오세요. \"COPY\" 버튼을 눌러 페이지에 붙여넣기하세요. ZIM 편집기에서 작업 중이라면 이 과정이 필요하지 않아요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_3.png\" /\u003e\n\n\n\n저장 후 브라우저에서 페이지를 확인해보세요. 파일 시스템에서 페이지를 찾아 브라우저에 끌어다 놓거나 마우스 오른쪽 버튼을 클릭하여 Chrome 등으로 열 수 있습니다. 또한 VS Code에 Open In Browser 또는 Live Server 확장 프로그램을 설치하여 핫키로 또는 마우스 오른쪽 버튼으로 바로 VS Code에서 파일을 열 수 있습니다.\n\n![MakeHTML5GamesTileGameTutorial_4](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_4.png)\n\n브라우저에서 보면 창에 맞는 회색 상자 안에 끌어올릴 수 있는 보라색 원이 있을 것입니다. 이 원, 가운데 정렬 및 드래그 코드를 삭제하세요. 테스트해보면 회색 상자가 표시될 것입니다.\n\n![MakeHTML5GamesTileGameTutorial_5](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_5.png)\n\n\n\n## 템플릿 코드 대 ZIM 편집기\n\n# 게임 만들기\n\n이 게임에서는 타이머와 소리 아이콘에 대한 ZIM 게임 및 Pizzazz 모듈을 사용할 것입니다. 프레임 내의 크기와 색상을 조정하려면 아래와 같이 코드를 조정해봅시다:\n\n```js\nimport zim from \"https://zimjs.org/cdn/016/zim_game\";\nimport zim2 from \"https://zimjs.org/cdn/016/zim_pizzazz\";\n\n// FIT, FILL, FULL 및 TAG에 대한 Frame의 Docs 참조\nnew Frame(FIT, 720, 1280, black, darker, ready);\n```\n\n\n\n만약 ZIM 편집기를 사용 중이라면, 상단의 Phone에서 P를 눌러서 portrait 모드로 설정하고, Game과 Pizzazz 상자를 위로 올려놓으세요. 또한 F.color를 black으로 설정하세요.\n\n![image](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_6.png)\n\n## 타일 살펴보기\n\n간단한 ZIM Tile()을 살펴봅시다. 이는 항목의 그리드입니다.\n\n\n\n```js\n// Tile(obj, cols, rows, spacingH, spacingV, ... lots more)\nconst pods = new Tile(new Circle(50, [pink, blue, yellow]), 6, 10, 10, 10)\n  .center();\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_7.png)\n\nCircle에 전달된 색상 배열은 ZIM VEE 값이라고 불리며, ZIM VEE의 버전 5에서 동적 매개변수를 위해 고안된 것입니다. 이를 통해 Tile은 배열에서 무작위로 항목을 선택하여 생성할 수 있습니다. Pick 문서를 참조하세요. 다른 ZIM VEE 값은 시리즈입니다. Circle 코드를 아래와 같이 수정하세요:\n\n```js\nnew Circle(50, series(pink, blue, yellow))\n```\n\n\n\n\n![Tutorial Step 8](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_8.png)\n\n각 항목을 누를 때마다 빨간색으로 변경해 봅시다. ZIM이 구축된 CreateJS는 JavaScript의 addEventListener()와 비슷한 on() 메소드를 제공하는데, 짧고 간결하며 mousedown 이벤트를 캡처할 수 있습니다. 'e'는 이벤트 객체로서 우리에게 목표물인 이벤트를 일으킨 객체와 같은 추가 정보를 제공합니다. 변화가 갱신되도록 stage update()를 사용합니다. 자동으로 업데이트하지 않아 배터리 소모를 줄입니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n e.target.color = red;\n S.update();\n});\n```\n\n![Tutorial Step 9](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_9.png)\n\n\n\n만약 선택된 색상이 분홍색인 경우에만 색상을 빨간색으로 변경할 수도 있어요:\n\n```js\npods.on(\"mousedown\", e=\u003e{\n if (e.target.color == pink) {\n  e.target.color = red;\n  S.update();\n } \n});\n```\n일정 시간마다 발생하는 ZIM interval로 색상을 변경할 수도 있어요:\n\n```js\ninterval(.2, ()=\u003e{ // 초 단위로 지정하며 호출할 함수\n // pluck은 임의의 항목을 가져오고 true는 해당 항목을 제거합니다\n pluck(pods.items, true).color = purple;\n S.update();\n}, pods.items.length); // interval을 실행할 횟수\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_10.png\" /\u003e\n\n## 포드\n\n우리 타일은 플라즈마 포드들이에요! 백 개의 포드를 담고 있는 그림을 만들었어요.\n\n우리는 Frame()의 자산 및 경로 매개변수를 사용해서 자산을 로드합니다. 혹시 ZIM 에디터를 사용 중이라면, Frame의 loadAssets() 메서드를 사용하여 완료 이벤트를 추가하세요. VS 코드에서 작업 중이라면, Tile 코드를 삭제하거나 주석 처리하고 다음 코드를 추가하세요. 기억하세요, Frame과 ready의 끝 부분을 교체하고 있습니다.\n\n\n\n```js\n// FIT, FILL, FULL 및 TAG에 대한 프레임을 참조하세요\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.org/assets/\";\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path);\nfunction ready() {\n    \n // 주어진 F (Frame), S (Stage), W (너비), H (높이)\n // 여기에 코드를 넣으세요\n\n new Pic(\"plasmapods.jpg\").center().drag();\n\n} // 준비 끝\n```\n\n만약 ZIM 편집기를 사용 중이라면, 이 코드를 사용하세요:\n\n```js\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.com/assets/\";\nF.loadAssets(assets, path);\nF.on(\"complete\", () =\u003e {\n\n new Pic(\"plasmapods.jpg\").center().drag();\n // 이제부터 여기에 코드를 작성하세요\n\n S.update();\n}) // loadAssets 끝\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_11.png\" /\u003e\n\n\n\n\n## 스프라이트\n\n우리는 플라즈마 팟 사진을 스프라이트 시트로 사용하여 ZIM Sprite()를 만들 것입니다. 이것에 대한 다른 용어로는 텍스처 아틀라스가 있습니다. 새로운 Pic()을 100개의 팟을 50초 동안 표시하는 새로운 Sprite()로 교체합니다. 우리는 선택 링을 쉽게 찾을 수 있도록 등록 지점을 중앙에 맞추기도 합니다.\n\n```js\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).centerReg().run(50);\n```  \n\n## 타일\n\n\n\n모든 pod를 가로와 세로 갯수를 정하는 ZIM Tile()로 타일링해보세요. 이 함수는 obj, cols, rows, spacingH, spacingV를 받습니다. 여러분의 코드를 다음과 같이 변경해보세요:\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \nlet cols = 4;\nlet rows = 5;\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n// 모든 pod를 반복하며 처리합니다\npods.loop(pod=\u003e{  \n pod.frame = rand(99); \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_12.png\" /\u003e\n\n## 고유한 Pods\n\n\n\n일부 팟들이 반복되는 것을 주목해주세요. 그것은 우리가 원치 않습니다. 그래서 0부터 99까지의 100개 인덱스를 ZIM shuffle()을 사용해서 무작위로 섞고 싶습니다.\n\n```js\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100개\nshuffle(options);\n\n// 모든 팟들을 순회합니다\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_13.png\" /\u003e\n\n## Eternals\n\n\n\n특별한 오브를 \"영원한 것\"이라고 부를 거에요. 이건 배열 조작이 조금 복잡해질 거에요.\n\n첫 번째 레벨에서는 무작위 목록에서 두 개를 빼야 해요. JavaScript의 splice()를 사용해 첫 번째 두 개를 제거하고 저장할 거에요. 우리는 타일의 랜덤하게 선택된 두 곳의 프레임 넘버를 우리의 영원한 프레임 넘버로 변경할 거에요. 여기에 전체 코드가 있어요. 위에 있는 변경 사항을 주목해 주세요.\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \n\n// LEVELS\nlet level = 0;\n\n// TILE\nlet cols = 4;\nlet rows = 5;\nlet stable = level+2; // 변하지 않는 것의 수\n\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n\n// 프레임 설정\n\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100\nshuffle(options); // 섞음\n\nconst eternals = options.splice(0,stable); // 100개 중 두 개의 프레임\n\n// 영원한 프레임의 위치 찾기\n// 가능한 모든 타일 인덱스 생성\nconst allSpots = [];\nloop(cols*rows, i=\u003e{allSpots.push(i)});\n// 영원한 프레임을 위해 두 개의 랜덤 지점 가져오기\nconst spots = shuffle(allSpots).splice(0,stable);\n\n// 모든 파드 반복\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n let index = spots.indexOf(i); // i의 인덱스 찾기, 없으면 -1\n if (index \u003e= 0) pod.frame = eternals[index]; // 영원한 것으로 덮어씀 \n});\n\n// 영원한 것 테스트:\nSTYLE = {dashed:true}\nloop(spots, index=\u003e{\n // 팟의 너비는 크기 조정된 타일 안에 있음\n // 하지만 원형 링은 밖에 있으므로 크기에 맞게 조정\n new Circle(pod.width/2*pods.scale, clear, white, 10)\n  .loc(pods.items[index]);\n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_14.png\" /\u003e\n\n\n\n## 간격\n\n다른 팟들을 변경할 수 있게끔 ZIM interval()을 사용해봐요. 먼저 초 단위로 설정하고, 호출할 함수, 실행횟수, 그리고 바로 시작할지 여부를 넣어야 해요. 우리는 기존 팟들 사이를 반복하는 함수 주변에 간격 함수를 설정할 거예요. 그리고 이를 즉시 실행할 거예요. 각 번마다 옵션을 섞어주는 것도 잊지 않도록 하죠. 스테이지 업데이트도 필요해요.\n\n```js\nlet inter = interval(1, ()=\u003e{\n shuffle(options);\n // 모든 팟들을 반복\n pods.loop((pod,i)=\u003e{  \n  pod.frame = options[i]; \n  let index = spots.indexOf(i); // i의 spots 내 인덱스, 없으면 -1\n  if (index \u003e= 0) pod.frame = spots[index]; // 영구 프레임으로 덮어쓰기\n });\n S.update()\n}, null, true); // 바로 실행하려면 true로 설정\n```\n\n우리의 영구들은 변하지 않아요! 우리는 그들 주위에 링을 둘러보았어요... 게임을 플레이할 수 있도록 링들을 주석처리해볼까요 (선택 후 CTRL 또는 ⌘ / 를 눌러주세요)?\n\n\n\n```js\n// // test eternals:\n// STYLE = {dashed:true}\n// loop(spots, index=\u003e{\n//  // the width of the pod is inside a scaled Tile \n//  // but circle ring is outside, so adjust for scale\n//  new Circle(pod.width/2*pods.scale, clear, white, 10)\n//   .loc(pods.items[index]);\n// });\n```\n\n## 상호작용\n\n이제, pods를 눌러서 정답을 맞는지 확인하고 싶습니다. .cur()를 사용하여 타일의 커서를 활성화할 수 있습니다. 그래서 타일에 그것을 추가해 보겠습니다. 또한 타일에 mousedown 이벤트를 추가할 것입니다. 일단은... 우리가 누른 팟을 제거하는 것으로만 테스트해 보겠습니다. 다음과 같이 팟 코드를 조정하세요:\n\n```js\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n const pod = e.target;\n pod.removeFrom();\n S.update();\n});\n```\n\n\n\n## 틀린 방법과 올바른 방법\n\n타일(좇) 안의 각 아이템은 해당 인덱스와 일치하는 tileNum을 가지고 있습니다. 우리는 해당 tileNum이 eternals의 인덱스를 보유하는 spots 배열 안에 있는지 확인할 수 있습니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 스팟의 인덱스 중 하나를 눌렀는지 알아냅니다\n // 타일의 각 요소는 tileNum을 가지고 있습니다\n // spots 배열은 영구 요소의 타일 내 인덱스를 보유합니다\n // 따라서 우리가 누른 요소의 tileNum이 spots 안에 있는지 확인합니다\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0) {  // 올바른 방법\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역이며, 크기가 조정된 타일 내부가 아닙니다\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n } else { // 틀린 방법\n  e.target.sca(.5); // 일단은 무언가를 수행합니다...\n }\n S.update();\n});\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_16.png\" /\u003e\n\n## 레벨 완료\n\n우리가 추측을 끝냈는지 어떻게 알 수 있을까요? 만약 우리가 같은 것을 두 번 이상 추측하면 어떻게 해야 할까요? 이 문제를 해결하기 위해 우리는 올바른 추측을 추적하기 위해 배열을 사용하고, 이미 배열에 있는 경우 올바른 추측으로 계산하지 않습니다. 배열의 길이가 레벨에 대한 stable 변수와 같아지면 레벨을 완료한 것입니다.\n\n```js\nconst correct = [];\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 위치의 색인을 눌렀는지 확인합니다.\n // 타일의 각 요소는 타일번호를 가지고 있습니다.\n // spots 배열은 영구적인 위치의 타일 인덱스를 보유합니다.\n // 따라서 누른 것의 타일번호가 spots에 있는지 확인해 봅니다.\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정확하고 이미 찾은 것이 아닌 경우\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역 변수이며, 스케일 조정된 타일 내에 있지 않습니다.\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n  correct.push(ind);\n  if (correct.length == stable) nextLevel();\n } else { // 틀린 경우\n  e.target.sca(.5); // 지금은 그냥 무언가를 해 봅니다...\n }\n S.update();\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 위해 F12를 사용하세요 (또는 노트북의 기능 키 F12)\n}\n```\n\n\n\n# 레벨\n\n코드의 레벨 부분을 찾아 아래와 같이 조정하세요. 패턴을 따르지 않는 레벨 열과 행을 보유한 배열을 만들 것입니다. 또한 다가오는 makeLevel() 함수 외부에서 필요한 몇 가지 변수를 준비합니다. 기존 코드에서 inter의 let을 제거해야 합니다.\n\n```js\n// 레벨\nlet level = 0;\n\n// 각 레벨의 열과 행을 나타내는 배열을 만듭니다.\n// 이를 사용해서 더 짧은 테스트를 실행하세요\n// const levels = [[4,5],[5,7]];\nconst levels = [[4,5],[5,7],[6,8],[7,10],[8,11]];\n\nlet lastPods;\nlet inter;\n\n// 정확한 추측 링을 보유합니다.\nconst rings = new Container(W,H).addTo();\n```\n\n```js\n// 기존 간격 코드에서 let을 제거하세요:\ninter = interval(1, ()=\u003e{\n```\n\n\n\n위의 코드를 makeLevel() 함수로 감싸세요. TILE 섹션 위에서부터 시작하는 코드를 makeLevel() 함수로 감싸세요. 또한 cols와 rows를 levels 배열을 사용하도록 조정하세요. makeLevel() 함수의 맨 위 코드는 다음과 같습니다.\n\n```js\nfunction makeLevel() {\n            \n // TILE\n const cols = levels[level][0];\n const rows = levels[level][1];\n const stable = level+2; // 원하는 만큼 고정될 타일 수\n```\n\n가장 아래 부분까지 이동해서 VS Code에서 end ready if 내에 남은 makeLevel() 함수의 끝 부분을 추가하세요. 그리고 함수를 호출하세요.\n```js\n} // makeLevel 함수의 끝\n\nmakeLevel();\n```\n\n\n\n## 단계 진행하기\n\n새 단계를 위한 새로운 타일을 만들기 전에 이전 타일과 링을 제거해야 합니다. 이미 rings Container를 만들었습니다. 이것을 사용하여 링을 보관할 것입니다. 그러므로 링 코드를 조정하세요. 우리는 링을 loc()에 추가했다는 것을 주목하세요. 나중에 rings의 모든 하위 항목을 제거할 수 있게 될 것입니다.\n\n```js\nnew Circle(pod.width/2*pods.scale, clear, white, 18)\n .loc(e.target, null, rings);\n```\n\n\n\n이제 nextLevel() 함수 위에 이 코드를 추가하세요. 이것은 NEXT 레벨이며 makeLevel이 아닌 것입니다. 여기서는 pods을 alpha 0에서 animate하여 불투명도를 조절합니다. 이렇게 하면 레벨 간에 서서히 사라집니다. 현재 pods을 lastPods에 저장하여 다음 레벨로 이동할 때 기억합니다. 반지를 퇴장시키고 완료되면 제거합니다.\n\n```js\n// LEVEL 처리\n\npods.alp(0).animate({\n wait:lastPods?1:0,\n props:{alpha:1},\n time:.5\n});\nlastPods = pods;\n\n// 반지를 숨기고 지우고 표시합니다.\nrings.top().animate({\n rewind:true,\n time:.5,\n props:{alpha:0},\n rewindCall:()=\u003e{\n  rings.removeAllChildren();\n }\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 열려면 F12 키(혹은 노트북의 Function F12 키)를 사용하세요\n}\n```\n\nnextLevel() 함수 안에 이 코드를 추가하세요. 마지막 pods를 animate하여 사라지게 하고, 마지막 간격을 지우고, 레벨을 늘리고, 게임의 끝인지 확인한 후 makeLevel()을 호출하세요.\n\n```js\nfunction nextLevel() {\n\n // 마지막 pods를 animate하여 사라지게 함\n // 캐싱은 모바일에서의 부드러운 애니메이션에 도움이 됨\n lastPods.cache().animate({\n  props:{alpha:0},\n  time:.5,\n  call:target=\u003e{target.dispose();}\n });   \n\n inter.clear(); // 현재 간격을 지움\n\n level++;\n if (level \u003c levels.length) { // 더 많은 레벨\n  makeLevel();\n } else { // 게임 종료\n\n  zogr(\"게임 끝\");   \n  \n } // 게임 종료\n\n} // nextLevel의 끝\n```  \n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_17.png\" /\u003e\n\n## 발신자\n\n선택 사항을 ZIM Emitter()로 향상시킬 수 있습니다. 이는 입자를 방출합니다. 발신자를 링 컨테이너 아래에 만들어보세요:\n\n```js\n// 정확한 추측 링을 보관합니다\nconst rings = new Container(W, H).addTo();\n\nSTYLE = {dashed: true};\nconst emitter = new Emitter({\n obj: new Circle(90, clear, series(pink, purple), 18),\n interval: .3,\n gravity: 0,\n force: 0,\n animation: {props: {scale: 5},\n startPaused: true\n});\nSTYLE = {}\n```\n\n\n\nemitter에서 pod의 mousedown 이벤트가 발생했을 때 spurt() 함수를 호출하세요. 기존의 nextLevel() 함수 호출 아래에 추가하세요.\n\n```js\ncorrect.push(ind);\nif (correct.length === stable) nextLevel();\n\nemitter.loc(e.target).spurt(2);\nemitter.particles.top(); // 입자들이 emitter와 별개로 존재하기 때문에 tricky 함\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_18.png)\n\n흰색 링은 emitter 작업이 대부분 완료될 때까지 표시되지 않아야 하므로 기존 링 Circle에 페이드 인 애니메이션을 추가하세요. 세미콜론(;)을 확인해주세요.\n\n\n\n```js\n새 Circle(pod.width / 2 * pods.scale, clear, white, 18)\n .loc(e.target, null, rings)\n .alp(0)\n .animate({\n  wait: .5,\n  alpha: .9\n });\n```\n\n## 보상 화면\n\n우리는 한 수준에서 다른 수준으로 애니메이션화되는 것에 만족하지 않습니다. 어떤 보상이 필요합니다. 소리는 도움이 될 것입니다... 하지만 이쁜 구체들이 있습니다. 플레이어에게 수집한 영구 구체들을 보여주는 약간 더 많은 시간을 쓰도록 합시다. 기존의 lastPods animate 코드 하단에 기다림을 조절하고 한 번 보여주세요!\n\n```js\nlastPods.cache().animate({\n wait:1, // 기다리기 추가\n props: {alpha: 0},\n time: .5,\n call: target =\u003e {target.dispose();}\n});\n\n// 영구 보여주기 – 플레이어에게 잠시 휴식 시간을 줌과 더 큰 플라즈마를 보여줍니다\nconst showcase = new Tile({\n obj: pod.clone().sca(1.5),\n cols: 2,\n rows: 3,\n spacingH: 20,\n spacingV: 20,\n count: stable\n})\n .center();\nshowcase.loop((pod, i) =\u003e {\n // eternals는 영구 구체들의 인덱스를 저장합니다\n pod.run({startFrame: eternals[i], endFrame: eternals[i]});\n});\nshowcase\n .alp(0)\n .animate({\n  props: {alpha: 1},\n  wait: 1.5,\n  time: .5,\n  rewindWait: 1,\n  rewind: true,\n  call: target =\u003e {target.dispose();}\n });\n\ninter.clear(); // 현재 간격을 지웁니다\n```\n\n\n\n이제 우리는 팟 애니메이트 대기 시간을 조정해야 합니다:\n\n```js\npods.alp(0).animate({\n wait:lastPods?3.5:0, // 3.5로 변경\n props:{alpha:1},\n time:.5\n});\n```\n\n# 마무리\n\n이제 기본 게임 구성은 완료되었습니다. 실제 게임을 먼저 코딩하고 이를 수행할 수 있고 마음에 드는지 확인해야 합니다. 그런 다음 소리, 점수, 패널, 인터페이스 등과 같은 최종 터치를 추가하십시오. 종종 이미지는 마지막에 남겨두지만 스프라이트와 함께 작업하는 것도 좋았습니다.\n\n\n\n## 더 많은 에셋\n\n로고를 위한 폰트와 몇 가지 사운드를 로드할 예정입니다. Frame() 영역에 이를 추가하세요. 기존 Frame() 함수에는 추가된 progress 매개변수가 있음을 주의하세요.\n\n```js\nconst audioSpriteData = {\n  src: \"audiosprite.mp3\",\n  audioSprite: [\n    // [id, 시작시간(초), 끝시간(초)] \n    // 프리미어에서 확인 - 다른 형식들도 존재함\n    ['blackball', 1.041, 2.475],\n    ['bounce', 3.567, 4.232],\n    ['end', 5.396, 9.315],\n    ['help', 10.373, 10.499],\n    ['powerdown', 11.607, 14.254],\n    ['powerup', 15.672, 17.081],\n    ['slow', 18.354, 19.163],\n    ['start', 20.151, 23.594],\n    ['submit', 24.931, 27.673],\n    ['wallend', 28.632, 29.351],\n    ['wallstart', 30.640, 32.323]\n  ]\n};\n\nconst assets = [\"gf_Honk\", \"plasmapods.jpg\", \"intro.mp3\", audioSpriteData];\nconst path = \"https://zimjs.com/assets/\";\nconst progress = new Waiter();\n\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path, progress);\nfunction ready() {\n```\n\n만약 ZIM Editor를 사용 중이라면, 아래와 같이 사용하세요:\n\n\n\n```js\nF.loadAssets(assets, path, progress);\n```\n\n## 로고\n\n로고를 맨 위에 추가하세요. 로고에 사용자 지정 글꼴이 얼마나 더 좋은지 확인해보세요! Google Fonts로 가는 바로 가기를 사용하면 assets에 있는 gf_… 를 사용하는 것이 정말 쉬워집니다. ready 함수 내부의 맨 위에 다음을 추가하세요:\n\n```js\nnew Label(\"ETERNAL ORBS\", 110, \"Honk\").pos(0, 50, CENTER);\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_19.png\" /\u003e\n\n## 컨트롤\n\n우리는 밑부분에 인터페이스를 추가할 것입니다. 이 인터페이스에는 음소거 버튼, 찾아야 할 무한루프 수를 보여주는 라벨, 그리고 타이머가 있을 것입니다. 이를 위해 타일을 사용하여 이쁘게 정렬할 것입니다. 이 코드를 로고 아래에 추가해주세요.\n\n```js\n// 밑에 있는 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n})\n\nconst find = new Label(\"찾기 2\", 85, \"Honk\");\n\nconst timer = new Timer({\n backgroundColor: new GradientColor([yellow, red], 90),\n down: false,\n time: 0\n});\n\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM);\n```\n\n\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_20.png)\n\n각 레벨을 찾기 위한 'eternals'의 수를 업데이트해야 합니다. HANDLE LEVELS 섹션에 다음 라인을 추가해주세요:\n\n```js\n// HANDLE LEVELS\n\nfind.text = \"FIND \" + stable;\n```\n\n## Sound\n\n\n\n위에, 로고 아래에 우리의 모든 소리를 준비해봅시다. 우리는 새로운 Aud()를 사용해서 소리 객체를 만들어요. 그리고 우리가 그 소리를 듣고 싶을 때에는 play() 메소드를 사용해요. 상호작용을 할 때 까지 소리를 재생할 수 없지만, 그 부분은 맨 처음에 LeaderBoard를 추가하여 처리할 거에요.\n\n```js\n// SOUND\n// 파일, 볼륨, 루프, 등 여러 가지가 있어요\nconst introSound = new Aud(\"intro.mp3\", .1, true); \nconst startSound = new Aud(\"wallstart\", .3);\nconst rightSound = new Aud(\"powerup\", .3);\nconst wrongSound = new Aud(\"wallend\", .3);\nconst endSound = new Aud(\"submit\", .3);\nlet intro; // 이 변수는 mute fading을 위해 introSound SoundInstance를 보관할 거에요\n```\n\n코드 전체에 소리를 뿌리뿌리 흩뿌려봅시다. LeaderBoard를 소개할 때 intro 소리를 들려줄 거에요. play() 코드가 들어간 줄을 추가하고 있어요.\n\n```js\npods.alp(0).animate({\n wait: lastPods ? 3.5 : 0,\n waitedCall: () =\u003e {if (!mute.toggled) startSound.play();},\n props: {alpha: 1},     \n time: .5\n});\n```\n\n\n\n그리고 파드의 마우스 다운시에 play() 코드를 추가하고 있습니다.\n\n```js\nif (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정답이고 이미 찾은 것이 아니라면\n if (!mute.toggled) rightSound.play();\n```\n\n틀린 추측에서는 play() 코드를 추가하고 있습니다.\n\n```js\n} else { // 틀렸을 때\n if (!mute.toggled) wrongSound.play();\n e.target.sca(.5); // 일단은 무언가를 해보세요...      \n}\n```\n\n\n\n## 리더 보드\n\n기존 BOTTOM INTERFACE 코드 아래에 다음 코드를 추가하세요. bottom을 removeFrom()하여 Play 버튼을 누를 때까지 표시되지 않도록 하고 bottom을 addTo() 하세요. 코드 맨 아래에는 이미 가지고 있는 SPRITE 코드가 있으므로 중복해서 작성하지 말아주세요. 그리고 startGame() 함수의 괄호를 닫아주세요. 그 다음 작업을 해보겠습니다.\n\n```js\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM)\n .removeFrom();\n\n// 리더 보드\nconst lb = new LeaderBoard({\n data: \"Y9HC384\",\n corner: 0,\n backgroundColor: dark,\n titleColor: light,\n title: \"Lowest Finish Times\",\n reverse: true\n}).scaleTo(S, 90, 90).center().mov(0, 20);\nlb.on(\"close\", startGame);\n\nconst play = new Button({\n label: \"PLAY\",\n backgroundColor: new GradientColor([orange, purple], 90)\n})\n .pos(0, 40, CENTER, BOTTOM).tap(() =\u003e {\n  lb.removeFrom();\n  startGame();\n });\n\n\n// 시작 게임\n\nfunction startGame() {\n\n bottom.addTo();\n timer.time = 0;\n\n // 나중에 음소거하려면 play SoundInstance를 저장하세요\n if (!mute.toggled \u0026\u0026 !intro) intro = introSound.play(); \n if (!mute.toggled) startSound.play();\n\n play.removeFrom();\n\n // SPRITE\n const pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER);\n}\n\nstartGame 함수를 호출한 후 makeLevel()을 호출하여 startGame() 함수를 종료하세요. 문서를 올바르게 들여쓰기하여 형식을 유지해주세요. VS Code에서 오른쪽 클릭하여 \"Format Document\"를 실행해주세요.\n\n\n\n } // makeLevel 함수 끝\n\n makeLevel();\n\n} // startGame 함수 끝\n\n![MakeHTML5GamesTileGameTutorial 이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_21.png)\n\n## 음소거 버튼\n\n음소거 기능을 추가하세요. 기존 버튼에 expand()와 tap()을 추가하세요. expand는 모바일에서 쉽게 누를 수 있게 만듭니다.\n\n\n\n// 하단 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n}).expand().tap(() =\u003e {\n if (mute.toggled \u0026\u0026 intro) intro.fade(0);\n else if (!mute.toggled \u0026\u0026 intro) intro.fade(.1);\n});\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_22.png\" /\u003e\n\n## 게임 종료\n\n여기까지 오지 못할 것 같았나요? 오답을 수정해봅시다. 틀린 답을 맞출 때마다 타이머를 늘릴 겁니다.\n```\n\n\n\n```js\n} else { // 잘못됨\n if (!mute.toggled) wrongSound.play();\n timer.time += 10;   \n}\n```\n\n게임의 조건이 끝날 때, 시간을 리더보드에 추가하고 모든 것을 멈추기 위해 끝 코드를 추가합니다.\n\n```js\n} else { // 게임 종료\n\n // 게임 끝났습니다\n\n inter.clear();\n rings.animate({\n  time: .2,\n  props: {alpha: 0}\n });\n // 점수를 리더보드로 전송\n // 상위 열 개 안에 들지 않으면 무시됩니다\n lb.score(timer.time);\n // 최종 쇼케이스를 보기 위해 시간을 제공합니다\n timeout(3.5, () =\u003e {\n  bottom.removeFrom();\n  pods.dispose();\n  rings.dispose();\n  lb.addTo();\n  play.addTo();\n  if (!mute.toggled) endSound.play();\n });\n\n} // 게임 종료의 끝\n```\n\n이를 쉽게 테스트하기 위해 레벨을 줄일 수 있습니다. LEVELS 코드에서 찾아서 게임을 두 레벨(또는 한 레벨) 후에 종료되도록 변경하세요. 도전적인 레벨을 다시 시도하려면 다시 변경해야 합니다!\n\n\n\n```js\n// 이것은 각 레벨마다 열과 행이 얼마나 있는지 나타냅니다\n// 간단한 테스트 실행에 사용하세요\nconst levels = [[4,5],[5,7]];\n// const levels = [[4, 5], [5, 7], [6, 8], [7, 10], [8, 11]];\n```\n\n# 결론\n\n이 튜토리얼에서는 로고와 커스텀 폰트, 리더보드, 오디오 스프라이트와 음소거 버튼을 포함한 완전한 타일/패턴 게임을 만들기 위해 시간을 들였습니다. 또한, 레벨, 리워드 이밋터 및 스프라이트 텍스처 애트라스를 포함하였습니다.\n\n우리는 ZIM을 사용하여 여러 가지 타일형 게임을 만들었습니다. 게임 및 ZIM 예제에 대해 ZIM 배너 페이지를 살펴보세요.\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_23.png)\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_24.png)\n\nZIM의 Learn Apps 섹션에는 많은 종류의 타일 게임을 사용하는 e러닝 게임이 있습니다. 메모리 게임과 스크램블 퍼즐과 같은 게임들이 있습니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_25.png)\n\n\n\n**HTML 5 Games 튜토리얼 및 자료**\n\n- HTML 5 게임 만들기 - 이소메트릭 보드 게임 튜토리얼\n- HTML 5 게임 만들기 - 사이드 스크롤러 게임 튜토리얼\n\n더 많은 ZIM 기능과 ZIM 예제가 있습니다. ZIM 포럼이나 디스코드에 참여하시면 즐거운 도움을 받을 수 있습니다!\n\nDr Abstract\n\n\n\n![MakeHTML5GamesTileGameTutorial](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_26.png)","ogImage":{"url":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"},"coverImage":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png","tag":["Tech"],"readingTime":22},{"title":"현대 웹을 위해 새롭게 탄생한 자동완성 상자","description":"","date":"2024-05-12 23:31","slug":"2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb","content":"\n\n## 모든 곳에서 작동하며 의존성이 전혀 없는 다재다능한 접근 가능한 자동완성 웹 구성 요소.\n\n![이미지](/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png)\n\n생각해 보면, 텍스트 상자에서의 자동완성은 일종의 상용품이 되어가고 있고, 수많은 UI 프레임워크가 자체적인 구현을 제공하고 있습니다.\n\n큰 프레임워크를 사용하지 않거나 자동완성 UI 구성 요소를 포함한 기존 디자인 시스템을 사용하지 않고 현대적인 웹 앱을 구축할 때, 우리는 혼자서 해결해야 합니다.\n\n\n\n지금까지.\n제가 AutoComplete ECMAScript 클래스를 작성했고 해당 클래스를 구현하는 `omni-box`라는 표준 기반 웹 컴포넌트를 만들었습니다.\n\n# OmniBox\n\nAutoComplete 클래스는 모든 기본 로직을 호스팅하며, 텍스트 기반 HTML 입력 요소에 자동 완성 로직을 연결하는 데 사용할 수 있습니다.\n\n\n\nOmniBox 웹 컴포넌트는 검색 입력을 생성하고 AutoComplete 컴포넌트를 연결합니다.\n\n## 왜 OmniBox를 사용해야 하는가?\n\n이는 의존성이 전혀 없는 매우 다재다능한 자동완성 컴포넌트로, 모든 브라우저에서 실행되며 웹 컴포넌트로 구현되었습니다. OmniBox라는 이름은 이 컴포넌트로 간단한 자동완성 시나리오를 용이하게 할 수 있을 뿐만 아니라 LinkedIn, Facebook 또는 Office.com에서 보는 것처럼 복잡한 다중 소스 시스템도 구현할 수 있다는 사실을 나타냅니다.\n\n자동완성 결과는 고정(Array) 데이터에서 가져올 수 있지만, REST API와 같은 여러 소스와 연동해야 하는 더 복잡한 상황에서도 작업할 수 있습니다. 여러 호출 결과를 집계해야 하는 상황도 다룰 수 있습니다.\n\n\n\n또한 자동 완성 결과 항목을 선택할 때 단순히 입력란을 채우는 대신 사용자 정의 작업을 호출하도록 구성할 수도 있습니다.\n\n# 기능\n\n- 표준 기반의 웹 컴포넌트.\n- 의존성 없음.\n- 타입하는 대로 자동 완성 결과가 집계되는 구성 가능한 자동 완성 카테고리.\n- 각 카테고리에는 Array, Function 또는 Promise를 반환할 수 있는 'getItems' 속성이 있습니다.\n- 각 카테고리에는 정렬 색인이 있습니다.\n- 각 카테고리에는 'getItems'가 호출되는 시점을 결정하는 트리거 함수가 있습니다.\n- 각 카테고리에는 항목 선택을 위해 정의된 사용자 정의 작업을 가질 수 있습니다.\n\n# CodePen\n\n\n\n아래 Markdown 형식을 사용하여 CodePen에서 컴포넌트를 살펴보세요:\n\n# 더 많은 표준 기반의 유용한 것들\n\n다음의 탭 스트립도 확인해보세요. Marc van Neerven 저, CTO-as-a-Service 블로그의 The TabStrip, reinvented for the Modern Web 기사에서도 볼 수 있습니다.\n\n## PurePWA\n\n\n\n저는 PurePWA를 소개하는 \"웹 개발의 급격한 전환\"의 저자입니다. 이 책에서는 시맨틱 HTML과 ECMAScript를 사용하여 현대적인 PWA를 구축할 때 프레임워크, 빌드 시스템 또는 기타 종속성 없이 어떤 가능성이 있는지 탐구하고 있어요.\n\n🔗 LinkedIn에서 제 소식을 받아보세요","ogImage":{"url":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"},"coverImage":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular 18의 새로운 기능 정리 비교","description":"","date":"2024-05-12 23:30","slug":"2024-05-12-Angular18NewFeatures","content":"\n\u003cimg src=\"/assets/img/2024-05-12-Angular18NewFeatures_0.png\" /\u003e\n\n웹 어플리케이션을 구축하기 위한 주요 프레임워크 중 하나인 Angular은 현대 웹 개발 요구 사항을 충족하기 위해 지속적으로 발전해 왔습니다. 각 버전마다 새로운 기능, 최적화, 개선 사항을 가져왔습니다. 커뮤니티는 Angular 18의 릴리즈를 열심히 기다리며, 다음 주요 버전에서 기대할 수 있는 것을 살펴보겠습니다.\n\nAngular 18은 2024년 5월에 발매 예정이며, 이미 다가오는 버전에 포함될 확정된 여러 기능이 있어서 이번 버전에서 논의할 수 있습니다.\n\n# 함수를 이용한 경로 리디렉션\n\nAngular 18에서는 리디렉트를 관리하는 새로운 기능이 도입되었습니다. 이제 라우트 객체의 redirectTo 속성 내에서 리디렉트 URL을 지정하기 위해 문자열 대신 함수를 사용할 수 있습니다. 이 향상된 기능은 라우팅에서 더 많은 유연성을 제공하며 새로운 가능성을 열어줍니다.\n\n해당 함수 내에서는 URL 정보를 포함하는 객체에 액세스가 허용됩니다.\n\n```js\n//\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: \"/page2\",\n    pathMatch: \"full\",\n  },\n];\n\n//redirectTo function\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: (url) =\u003e {\n      return \"/page2\";\n    },\n    pathMatch: \"full\",\n  },\n];\n```\n\n함수는 문자열 또는 UrlTree를 반환해야 합니다. Angular에서 UrlTree는 URL을 나타내는 데이터 구조입니다. 이는 Angular 라우터가 응용 프로그램 내에서 탐색하는 데 사용하는 URL의 구문 분석된 표현입니다. UrlTree에는 URL 세그먼트, 쿼리 매개변수 및 조각과 같은 정보가 캡슐화되어 있습니다. 이는 Angular의 라우팅 시스템에서 URL 조작, 탐색 및 라우팅 가드와 같은 작업에 일반적으로 사용됩니다. UrlTree를 사용함으로써 Angular은 응용 프로그램 내에서 일관된 신뢰할 수 있는 탐색 동작을 보장합니다.\n\n“url\" 객체에는 라우트에 관한 모든 정보가 포함되어 있습니다. 이 정보에는 데이터, 제목, 쿼리 매개변수, 라우팅 세그먼트 등이 포함됩니다.\n\n# 새로운 RedirectCommand\n\nAngular 버전 18에서는 NavigationExtras를 처리하기 위해 설계된 새 RedirectCommand 클래스가 소개되었습니다. 이 추가로 Guards 및 Resolvers 내에서 향상된 리디렉션 기능을 구현할 수 있습니다. RedirectCommand 클래스의 통합은 유지보수성과 유연성을 크게 향상시키며, Angular 애플리케이션에서 복잡한 네비게이션 패턴을 보다 쉽게 관리할 수 있습니다.\n\n```js\nconst route: Route = {\n  path: \"page1\",\n  component: PageComponent,\n  canActivate: [\n    () =\u003e {\n      const router: Router = inject(Router);\n      const urlTree: UrlTree = router.parseUrl(\"./page2\");\n      return new RedirectCommand(urlTree, { skipLocationChange: true });\n    },\n  ],\n};\n```\n\n# ng-content 기본 콘텐츠\n\n이제는 ng-content 태그에 기본 콘텐츠를 넣을 수 있습니다. 이 기능은 ng-content 요소의 논리적 확장입니다. 콘텐츠를 위한 태그가 있는 경우, 기본 콘텐츠도 해당 태그 자체에 포함되어야 합니다.\n\n예를 들어, 템플릿에서 ng-content가 포함된 컴포넌트가 있다면 제공된 콘텐츠가 없을 경우 렌더링될 기본 콘텐츠도 포함할 수 있습니다.\n\n```js\n\u003cdiv\u003e\n  \u003ch1\u003e헤더\u003c/h1\u003e\n  \u003cng-content\u003e기본\u003c/ng-content\u003e\n\u003c/div\u003e\n```\n\n# Zoneless applications\n\nSignals의 주요 목표 중 하나는 zone.js 없이 응용 프로그램이 작동할 수 있도록 하는 것입니다. 초기에는 이 것이 Signal Components를 통해서만 가능했을 것입니다. 그러나 그 이후에 상황이 변화했습니다. 이제 Angular 18부터는 Signal Components를 사용하지 않고도 이것을 달성할 수 있을 것입니다. Angular 18은 다음 달에 발표될 예정입니다.\n\nMatthieu Riegler와 Enea Jahollari는 이 주제에 집중한 각각의 기사를 게시했습니다.\n\nMatthieu의 기사는 새로운 하이브리드 변경 감지 시스템을 탐구하며, 어느 Signal 변경, 비동기 파이프 또는 markForCheck를 호출하는 다른 작업이 zone.js 외부에서 발생하더라도(예외적인 상황) 이제 자동으로 변경 감지가 트리거될 것이라고 합니다.\n\nEnea의 글은 zone.js를 완전히 비활성화하고 응용 프로그램 상태 변경을 관리하는 데 이러한 새로운 트리거 메커니즘에만 의존하는 과정을 논의합니다.\n\n# 읽어 주셔서 감사합니다!\n\n여러분의 생각을 듣고 싶어요. 그러니 자유롭게 댓글을 남겨주시거나 박수를 보내거나 팔로우해 주세요. 👏\n\n이 글이 마음에 들었다면, 여러분의 커뮤니티, 기술 친구 및 흥미를 가질 것으로 생각되는 다른 사람들과 공유하는 것도 생각해보세요. LinkedIn에서도 제 소식을 더 받아보기 위해 팔로우를 잊지 말아주세요!\n","ogImage":{"url":"/assets/img/2024-05-12-Angular18NewFeatures_0.png"},"coverImage":"/assets/img/2024-05-12-Angular18NewFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까","description":"","date":"2024-05-12 23:28","slug":"2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png\" /\u003e\n\n# 목차\n\nChrome의 성능 패널에 익숙해지기\n\n- 프로파일러의 사용자 인터페이스 이해\n- 사전 설정 단계\n\n\n\n프로파일링을 시작해봐요!\n\n- CPU 활용률\n- 네트워크 요청 타임라인\n- 프레임 및 이벤트 타이밍\n- JavaScript 주 스레드\n\n팁: 프로파일러를 효과적으로 사용하는 방법\n\n- 예시 1: LCP 성능 저하 조사하기\n- 예시 2: 클릭 동작 시 어플리케이션이 멈추는 현상 조사하기\n\n\n\n프론트엔드 개발자로서, 크롬의 성능 패널에 있는 자바스크립트 프로파일러를 들어본 적이 있거나 마주쳐 본 적이 있을지도 모릅니다. 초안에서는 차트와 그래프가 압도적으로 보일 수 있습니다.\n\n![Chrome Performance Panel](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_1.png)\n\n처음에는 다소 복잡해 보일 수 있지만, 자바스크립트 프로파일러는 디버깅에 매우 유용합니다. 이 도구를 사용하면 애플리케이션을 실행할 때 자바스크립트 메인 스레드에서 발생하는 모든 일들을 살펴볼 수 있습니다. 이 글에서는 크롬의 성능 패널을 사용한 프로파일링에 관한 제 경험을 공유하겠습니다.\n\n# 크롬의 성능 패널에 친숙해지기\n\n\n\n## 프로파일러의 사용자 인터페이스 이해하기\n\n프로파일러의 모든 설정을 다루지는 않겠습니다. 오직 몇 가지 중요한 기능만이 필수이며 앱 프로파일링을 위해 구성될 것입니다.\n\n![프로파일러](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_2.png)\n\n- 녹화 및 프로파일링 시작 및 페이지 다시로드하는 작업 버튼과 Clear 버튼이 있습니다.\n- 프로파일링 레코드의 이력.\n- 스크린샷 및 JavaScript 힙 메모리 사용량을 프로파일링과 함께 보여주는 옵션.\n- CPU 및 네트워크 쓰로틀링.\n\n\n\n기능에 대한 포괄적인 문서를 원하시면 Chrome DevTools 성능 문서를 참고해보세요.\n\n## 사전 구성 단계\n\n정확한 결과를 보장하고 디버깅 프로세스를 쉽게 해 하기 위해 다음 설정을 고려해보세요:\n\n- 시크릿 모드: 시크릿 모드에서 Chrome을 실행하면 브라우저에 영향을 미치지 않도록 확장 프로그램을 비활성화하고 캐시를 지움으로써 성능 측정에 영향을 주지 않도록합니다.\n- Localhost 대 Production: 저는 TypeScript, React 또는 Webpack과 같은 번들러를 사용하는 프로젝트에서 트랜스 파일 된 또는 최소화된 코드에 문제가 발생하는 것을 피하기 위해 localhost에서 프로필링을 선호합니다. 소스 코드 추적을 쉽게 하기 위해 Chrome DevTools에 소스 맵을 업로드하여 제품 프로필링을 위해 정확한 소스 코드를 파일에 매핑하세요.\n- CPU 쓸개 (4배 느리게): 주요 사용자 그룹이 모바일 기기를 사용하는 경우 CPU 쓸개를 활성화하는 것을 고려해보세요. 주의할 점은 쓸개 속도가 귀하의 기기의 CPU 성능을 기준으로 하며 결과가 다른 기기에서 달라질 수 있다는 점입니다.\n- 네트워크 쓸개 (느린 3G): 네트워크를 Fast 3G 또는 Slow 3G로 설정하는 것을 추천합니다. 이 접근 방식은 네트워크 병목 현상을 더 명확하게 드러낼 수 있습니다.\n\n\n\n# 프로파일링을 시작해봐요\n\n만약 우리가 index.html 파일에 다음과 같은 코드 조각이 있다고 가정해봅시다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003cbody\u003e\n    \u003ch1\u003eAPI에서 데이터 가져오기:\u003c/h1\u003e\n    \u003cdiv id=\"api-data\"\u003e로딩 중...\u003c/div\u003e\n    \u003cscript\u003e\n      const getData = async () =\u003e {\n        const apiUrl = \"https://jsonplaceholder.typicode.com/todos/1\";\n        try {\n          const response = await fetch(apiUrl);\n          if (!response.ok) {\n            throw new Error(\"네트워크 응답이 올바르지 않습니다.\");\n          }\n          const data = await response.json();\n          document.getElementById(\"api-data\").innerHTML = `\n                    \u003cp\u003e제목: ${data.title}\u003c/p\u003e\n                `;\n        } catch (error) {\n          document.getElementById(\"api-data\").innerText =\n            \"데이터를 불러오는 데 실패했습니다.\";\n        }\n      };\n      document.addEventListener(\"DOMContentLoaded\", getData);\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n이 코드는 로딩한텍스트를 출력한 후 더미 데이터를 가져 오기 위해 HTTP 요청을 보내고 그것으로 로딩 텍스트를 바꾸는 역할을 합니다. 이렇게 간단해요.\n\n\n\n인크ognito Chrome 창에서 index.html을 열고 \"프로파일링 시작 및 페이지 다시로드\" 버튼을 클릭해 보세요.\n\n다음은 결과입니다.\n\n## CPU 활용률\n\n![Image](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_3.png)\n\n\n\n상단 섹션(빨간 상자)은 CPU 활용을 나타내며, 다양한 브라우저 활동을 나타내는 다양한 색상이 있습니다. 예를 들어 스크립팅, 렌더링, 페인팅 또는 아이들 활동이 있습니다. 이러한 것들은 보통 JavaScript 주 스레드 활동에 상응합니다.\n\n이 특정 시간대에 CPU는 대부분 유휴 상태입니다. HTML 구문 분석, DOMContentLoaded의 이벤트 핸들러 실행 및 레이아웃 단계에 사용되는 것들이 필요합니다. 레이아웃 단계는 브라우저 렌더링 단계 중 하나이며, 모든 노드의 차원과 위치를 계산하고 페이지의 각 객체의 크기와 위치를 결정합니다. 브라우저 렌더링 프로세스에 대해 더 자세히 알아보려면 여기를 읽어보세요: 브라우저 작동 방식 - 렌더링.\n\n## 네트워크 요청 타임라인\n\n![Network Request Timeline](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_4.png)\n\n\n\n네트워크 요청 타임라인에서는 API 엔드포인트인 https://jsonplaceholder.typicode.com/todos/1이 호출되고 응답이 약 2초 후에 반환되는 것을 볼 수 있습니다.\n\n## 프레임 및 이벤트 타이밍\n\n![Frames and Event Timings](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_5.png)\n\n프레임 타임라인은 API 응답이 반환될 때 텍스트 로드부터 결과를 렌더링하는 과정을 알려줍니다. 이벤트 타이밍 타임라인에서는 DCL (DOM 내용 로드됨), FCP (첫 번째 콘텐츠 페인트), L (로드됨), LCP (가장 큰 콘텐츠 페인트)와 같은 다양한 이벤트를 보여줍니다.\n\n\n\n## 자바스크립트 메인 스레드\n\n![자바스크립트 메인 스레드](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_6.png)\n\n자바스크립트 메인 스레드의 모든 활동과 각 활동을 완료하는 데 소요된 시간을 보여줍니다. 호출 스택을 시각화하며 각 레이어가 작업을 나타냅니다. 각 작업을 완료하는 데 소요된 자체 시간과 총 시간을 제공합니다.\n\n![작업 시간 시각화](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_7.png)\n\n\n\n자기 시간은 해당 메서드가 그 안에서 호출된 다른 메서드로 인해 발생한 시간을 제외하고 코드 라인 전체를 실행하는 데 걸리는 시간을 의미합니다. 총 시간은 해당 메서드 자체와 내부에서 호출된 다른 메서드에 의해 소요된 시간을 포함합니다.\n\n화염 차트에서는 위에서 아래로 쌓인 함수들을 볼 수 있습니다. JavaScript 이벤트 루프는 호출 스택을 확인하고 다음 호출 스택을 시작하기 전에 비어 있는 상태에서 LIFO (Last In, First Out) 순서로 쌓인 모든 작업을 실행합니다. 이는 JavaScript가 단일 스레드 언어임을 나타내며, 즉 한 번에 하나의 작업을 수행할 수 있다는 것을 보여줍니다.\n\n위의 화염 차트에서 JavaScript 메인 스레드에서 어떤 작업이 발생하는지 설명하기 위해 몇 가지 중요한 부분에 대해 강조해 보겠습니다.\n\n\n\n초록 상자 안에는 최상위 함수가 DOMContentLoaded에 대한 이벤트 핸들러이고, 콜백 함수는 getData() 함수입니다. 이 함수는 Fetch API를 호출하여 HTTP 요청을 보내는 것을 담당합니다. 이 시점에서 fetch 작업은 브라우저의 Web API로 전달됩니다.\n\n자바스크립트 이벤트 루프에서 자바스크립트 엔진은 다음 매크로태스크를 시작하기 전에 실행할 마이크로태스크가 있는지 확인합니다. API 호출이 메인 자바스크립트 스레드 외부에서 처리되므로, 데이터가 도착하기 전에 브라우저 렌더링 단계(빨간 상자에 표시됨)나 기타 동기 코드와 같은 다른 매크로태스크를 계속 실행합니다.\n\n데이터가 도착하면 프로미스의 해결(resolve) 부분(try-catch 블록 내 await 뒤에 배치된 코드)이 마이크로태스크로 예약됩니다. 현재 매크로태스크가 완료되면, 이벤트 루프는 다음 매크로태스크로 넘어가기 전에 모든 누적된 마이크로태스크를 처리합니다.\n\n\n\n이 문서는 단일 스레드 JavaScript가 매크로태스크와 마이크로태스크 개념을 사용하여 I/O 작업을 비차단으로 수행하는 방법을 완벽하게 보여줍니다. 이를 통해 UI가 상호작용하고 응답성을 유지할 수 있습니다.\n\n# 팁: 프로파일러를 효율적으로 활용하는 방법\n\nJavaScript 메인 스레드 타임라인에서 특정 함수를 검색하려면 키보드 단축키 Command + F를 사용할 수 있습니다. 일반적으로, 조사하려는 이벤트나 네트워크 요청을 먼저 찾고, 그런 다음 JavaScript 메인 스레드의 작업들을 살펴보곤 합니다.\n\n## 예시 1: LCP 성능 저하 조사하기\n\n\n\n앱이 콘텐츠를 로드하는 데 오랜 시간이 걸리거나 LCP 점수가 낮은 이유를 알아보고 싶다면 DOMContentLoaded 이벤트를 검색하여 콜 스택에서 발생하는 작업을 확인할 수 있습니다. 프리즈는 일반적으로 오랜 작업으로 인해 발생하며, 이는 콜 스택이 50ms 이상 소요되는 것을 의미합니다.\n\n## 예시 2: 클릭 작업에서 앱 프리징 조사하기\n\n버튼을 클릭할 때 앱이 왜 멈추는지 조사하고 싶다면 녹화를 시작하고 해당 작업을 수행하세요. 그런 다음 마우스 이벤트인 Event: pointerdown 또는 Event: mousedown을 검색하고 콜 스택의 기능을 검토하세요.\n\n또한 스크린샷을 사용하여 조사하고자 하는 특정 시간대를 파악할 수도 있습니다.\n\n\n\n프로파일러는 디버깅 및 브라우저, JavaScript, 심지어 프레임워크 작동 이해에 매우 유용한 도구입니다! 여기서 무언가를 배웠으면 좋겠네요. 프로파일링을 즐기세요!","ogImage":{"url":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png"},"coverImage":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png","tag":["Tech"],"readingTime":6},{"title":"DOM 기반 XSS에 대해서 알아보자","description":"","date":"2024-05-12 23:27","slug":"2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration","content":"\n안녕하세요 여러분, 모두 잘 지내시길 바랍니다.\n이 글은 DOM XSS에 관한 것이며, 클라이언트 측 JavaScript의 소스 코드 분석만으로도 DOM XSS를 찾아낼 수 있는 방법에 대해 다룹니다.\n\n웹 애플리케이션의 클라이언트 측 코드를 분석하는 중에 보안 취약점이 발견되었습니다. 이 취약점은 DOM 기반 크로스사이트 스크립팅(XSS) 공격을 허용합니다.\n\n![DOM XSS](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png)\n\n이 취약점은 URL 매개변수에서 가져온 사용자 입력을 잘못 처리한 것에서 비롯됩니다. 애플리케이션은 window.location.search 함수를 사용하여 utm_source 및 utm_campaign 두 매개변수를 가져옵니다. 이 매개변수는 그런 다음 getUrlParameter() 함수로 전달됩니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_1.png)\n\n이 함수는 URL 쿼리 문자열에서 특정 매개변수의 값을 추출하고 디코딩한 후 해당 값을 반환하는 데 목적을 둡니다. 예를 들어, URL이 다음과 같은 경우 https://exapmle.com/redact?utm_source=hello Figure 1의 아래 코드가 실행됩니다.\n\ngetUrlParamter(`utm_source`, queryString) 함수는 utm_source 매개변수인 hello의 값을 반환하여 utm_source 변수에 저장할 것이며, utm_campaign 매개변수에 대해서도 동일합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_2.png)\n\n그림 3에서 utm_campaign 매개변수 값이 \"closedDomains\"로 설정되면, 애플리케이션은 utm_source의 값에 따라 switch case 문을 실행합니다. 일치하는 case가 없는 경우, 애플리케이션은 utm_source의 값으로 brandName() 함수를 호출합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_3.png)\n\n그림 4에서 brandName 함수는 매개변수 값에 따라 .js-brandname-container 클래스를 가진 요소를 숨기거나 .js-brandname 클래스를 가진 요소의 inner HTML을 설정하는 방식으로 설계되었습니다. brandName 값이 false로 설정되면 지정된 요소를 숨기고, 그렇지 않으면 요소의 inner HTML을 제공된 brandName 값으로 설정합니다.\n\n그림 3에서 이미 알 수 있듯이, 우리는 URL 매개변수 utm_source를 통해 함수brandName(utm_source)에 전달되는 매개변수 값을 제어할 수 있으므로 이제 HTML 태그를 삽입하고 임의의 JavaScript 코드를 실행할 수 있습니다.\n\n프론트 엔드 개발자입니다. 위의 텍스트를 친절한 어조로 한국어로 번역해 주세요.\n\n아카마이 방화벽이 구출 작업을 수행했습니다. 이제 (WAF)가 잠재적으로 존재할지라도 XSS 공격을 실행하기 위해 성공적으로 우회했습니다. 다음 payload를 자유롭게 사용하세요.\n\nhttps://your-server/x.js를 자신의 서버로 바꿔주세요. 자바스크립트 파일을 업로드한 서버에 대체하세요. 해당 파일은 payload를 실행할 것입니다.\n\n\"Click Me\" 버튼을 클릭하면 됩니다.\n\n![DOM-based XSS Attack](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_6.png)\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png"},"coverImage":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기","description":"","date":"2024-05-12 23:23","slug":"2024-05-12-MockingDatainreactjsorjavascript","content":"\n\n- React.js나 JavaScript에서 모킹 데이터는 개발이나 테스트 중에 API나 백엔드 서비스로부터의 응답을 시뮬레이션하기 위해 가짜 데이터를 생성하는 것을 의미합니다.\n- 이를 통해 백엔드에 독립적으로 프론트 엔드 애플리케이션을 개발하고 테스트할 수 있습니다. 서버가 실제로 반환한 데이터와 상관없이 UI 컴포넌트가 예상대로 작동하는지 확인할 수 있습니다.\n\n다음은 React.js나 JavaScript에서 모킹 데이터를 하는 일반적인 방법 몇 가지입니다:\n\n- 하드코딩된 데이터: 코드 내에서 모의 데이터를 직접 정의합니다. 작은 데이터 세트나 정적 콘텐츠의 경우 특히 간단한 방법입니다.\n\n```js\nconst mockData = [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 },\n  // 기타 모킹 데이터...\n];\n```\n\n\n\n2. JSON 파일: 모의 데이터를 JSON 파일에 저장하고 필요할 때 코드로 가져옵니다. 이렇게 하면 모의 데이터를 코드베이스와 별도로 구성하고 관리할 수 있습니다.\n\n```js\n// mockData.json\n[\n  { \"id\": 1, \"name\": \"John Doe\", \"age\": 30 },\n  { \"id\": 2, \"name\": \"Jane Smith\", \"age\": 25 }\n  // 더 많은 모의 데이터...\n]\n```\n\n- `./mockData.json`에서 mockData를 가져옵니다;\n\n모의 라이브러리: faker.js 또는 mockjs와 같이 데이터를 모의하는 데 특별히 설계된 라이브러리를 사용하십시오. 이러한 라이브러리는 미리 정의된 스키마나 템플릿에 따라 랜덤하거나 현실적으로 보이는 모의 데이터를 생성합니다.\n\n\n\n```js\n// Using faker.js\nimport faker from 'faker';\n\nconst mockData = Array.from({ length: 10 }, () =\u003e ({\n  id: faker.datatype.uuid(),\n  name: faker.name.findName(),\n  age: faker.datatype.number({ min: 18, max: 100 })\n}));\n```\n\n4. API 모킹: 만일 당신의 애플리케이션이 API와 통신한다면, axios-mock-adapter나 msw (Mock Service Worker)와 같은 도구를 사용하여 API 응답을 모킹할 수 있습니다. 이러한 도구들은 HTTP 요청을 가로채 미리 정의된 응답을 반환함으로써 다양한 시나리오와 예외 상황을 시뮬레이션할 수 있게 합니다.\n\n```js\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\nconst mock = new MockAdapter(axios);\n\nmock.onGet('/users').reply(200, [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 }\n  // 더 많은 모킹 데이터...\n]);\n```\n\n이것들은 React.js나 JavaScript에서 데이터를 모킹하는 방법의 일부 예시일 뿐입니다. 선택하는 접근 방식은 특정 사용 사례, 기호 및 애플리케이션의 복잡성에 따라 다릅니다. 데이터 모킹은 효과적인 개발과 테스트를 위해 필수적이며, 애플리케이션의 각 부분을 독립적으로 분리하고 유효성을 검사할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png"},"coverImage":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png","tag":["Tech"],"readingTime":2},{"title":"단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포","description":"","date":"2024-05-12 23:21","slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker","content":"\n\n모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\n\n저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\n\n![이미지](/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png)\n\n시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\n\n\n\n- 표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\n- 이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\n- 여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\n- 한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\n\n이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\n\n- pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\n- 클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\n- 서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\n\n전제 조건:\n\n\n\n- NodeJS: Node.js 설치 방법\n- pnpm: pnpm 설치 방법\n\n## pnpm 워크스페이스\n\n- 루트 폴더에 pnpm 워크스페이스 생성하기\n\n```js\npnpm init\n```\n\n\n\n- 패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\n\n```js\nmkdir packages\n```\n\n- pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\n\n```js\ntouch pnpm-workspace.yaml\n```\n\n\n\n- 우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\n\n```js\n//pnpm-workspace.yaml\npackages:\n  - 'packages/*'\n```\n\n- 루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\n\n```js\ntouch docker-compose.yml\n```\n\n\n\n## 클라이언트\n\n- 우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\n\n```js\n pnpm create vite\n```\n\n- 클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\n\n\n\n```js\ncd client\npnpm install\npnpm run dev\n```\n\n- 클라이언트용 도커 파일\n\n```js\ntouch Dockerfile\n```\n\n## 서버\n\n\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n```\n\n- 서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\n\n```js\nnpm init\n```\n\n\n\n- 그리고 Express 프레임워크를 설치하세요.\n\n```js\nnpm install express\n```\n\n- 서버용 도커 파일도 만들어주세요.\n\n```js\ntouch Dockerfile\n```\n\n\n\n- 멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\n\n연결이 얼마나 잘 되었는지 확인해봐요!\n\n## 서버 + 클라이언트\n\n- 서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 http://localhost:3000에서 제공할 목록이 있어요\n\n\n\n```js\ntouch index.js\n```\n\n```js\n// server/index.js\nconst express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) =\u003e {\n  res.json([\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Bob\", age: 35 },\n  ]);\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`I am doing great and serving at ${PORT}`);\n});\n```\n\n- 패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\n\n```js\n\"scripts\": {\n    \"dev\": \"node index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n},\n```\n\n\n\n- 그리고 물론 실행해 주세요\n\n```js\npnpm run dev\n```\n\n- 이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 http://localhost:3000을 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n\n\n- vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 http://localhost:3000을 /api를 호출하여 프록시합니다.\n- 이제 App.ts 파일에서는 /api를 호출하여 http://localhost:3000에서 데이터를 가져옵니다.\n\n```js\nimport { useEffect, useState } from \"react\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [data, setData] = useState\u003cany\u003e(null);\n  useEffect(() =\u003e {\n    const fetchData = async () =\u003e {\n      const response = await fetch(\"/api\");\n      const data = await response.json();\n      console.log(data);\n      setData(data);\n    };\n    fetchData();\n  }, []);\n\n  return \u003c\u003e{data \u0026\u0026 \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e}\u003c/\u003e;\n}\n\nexport default App;\n```\n\n- 목록을 보려면 프론트앱을 시작해주세요.\n\n```js\npnpm run dev\n```\n\n\n\n이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\n\n개선 사항\n\n- 이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\n\n```js\n\"scripts\": {\n    \"client\": \"pnpm --filter \\\"client\\\" run dev\",\n    \"server\": \"pnpm --filter \\\"server\\\" run dev\",\n    \"app\": \"pnpm run client \u0026 pnpm run server\"\n},\n```\n\n\n\n- 클라이언트용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/client\n\n# 클라이언트 package.json 복사\nCOPY package.json .\n\n# 의존성 설치 \nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 8080\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n- 서버용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/server\n\n# 서버 package.json 복사\nCOPY package.json .\n\n# 의존성 설치\nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 3000\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n\n\n- 도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\n\n```js\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target:\n          process.env.NODE_ENV === \"docker\"\n            ? \"http://server_c:3000\"\n            : \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n- 루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\n\n```yaml\nservices:\n  client:\n    build: ./packages/client\n    container_name: client_c\n    ports:\n      - \"8080:8080\"\n    environment:\n      - NODE_ENV=docker\n\n  server:\n    build: ./packages/server\n    container_name: server_c\n    ports:\n      - \"3000:3000\"\n```\n\n\n\n여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\n\n```js\ndocker-compose up\n```\n\n더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\n- 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png","tag":["Tech"],"readingTime":7},{"title":"마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업","description":"","date":"2024-05-12 23:20","slug":"2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle","content":"\n\nReact의 useEffect 훅은 함수 컴포넌트에서 부작용을 관리하는 강력한 도구입니다. 하지만 적절한 처리 없이 사용하면 코드베이스의 최악의 악몽이 될 수 있습니다. 오늘은 제가 즐겨 사용하는 API 중 하나인 TheCatAPI를 사용하여, useEffect에서 비동기 작업을 정리하는 방법에 초점을 맞추어 React 컴포넌트를 가능한 깨끗하고 효율적으로 유지하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png)\n\n## useEffect에서 정리 작업이 중요한 이유\n\nReact 컴포넌트는 마운트되고 업데이트되며 마침내 언마운트됩니다. useEffect 훅을 사용하면 이러한 단계를 우회하여 코드를 실행할 수 있습니다. DOM을 조작하거나 서비스에 구독하거나 타이머를 설정하거나 데이터를 가져오는 등의 작업을 수행할 수 있습니다. 그러나 중요한 건 이러한 작업을 설정하는 것뿐 아니라 그것들을 언제, 어떻게 해제해야 하는지를 알고 있는 것입니다.\n\n\n\n적절한 정리가 없으면 애플리케이션이 더는 필요하지 않은 효과를 계속 실행하거나, 더 나쁜 경우에는 DOM에서 사라진 구성 요소를 참조할 수 있습니다. 이러한 문제는 성능 문제, 메모리 누수 및 디버깅하기 어려운 오류로 이어질 수 있습니다.\n\n# 먼저, 고양이 사진을 가져와 봅시다\n\n아마도 많은 분들이 이 고양이 서비스 API를 이미 알고 있을 겁니다. 이 글에서는 이미지 엔드포인트만 사용할 것입니다. 만약 이 API에 대해 더 알고 싶다면, 이 링크를 확인해보세요:\n\n프로그램이 초기 페이지 로드 시 10개의 고양이 사진을 표시하도록 해 봅시다.\n\n\n\n```js\nimport { useState, useEffect } from \"react\";\n\nfunction App() {\n  const [catImageUrl, setCatImageUrl] = useState([]);\n\n  useEffect(() =\u003e {\n    const fetchCatImage = async () =\u003e {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10\u0026api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (data.length \u003e 0) {\n          const imageURLS = data.map((obj) =\u003e obj.url);\n          setCatImageUrl(imageURLS); // 첫 번째 이미지 URL을 설정하려 가정합니다\n        }\n      } catch (error) {\n        console.error(\"데이터를 가져오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n  }, []); // 의존성 배열이 비어 있어서 효과가 한 번만 실행됩니다\n\n  return (\n    \u003c\u003e\n      \u003ch1\u003e당신의 하루 고양이 사진\u003c/h1\u003e\n      \u003cdiv\n        style={{\n          display: \"flex\",\n          flexWrap: \"wrap\",\n          gap: \"10px\",\n        }}\n      \u003e\n        {catImageUrl.map((url, index) =\u003e (\n          \u003cimg\n            key={index}\n            src={url}\n            alt=\"랜덤한 고양이\"\n            style={{ flex: \"0 0 200px\", height: \"200px\" }}\n          /\u003e\n        ))}\n      \u003c/div\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_1.png\" /\u003e\n\n아주 좋아요, 의도한 대로 10개의 고양이 사진을 요청했지만 잠재적인 문제가 있습니다: 데이터 가져오기가 비동기적인 것으로 인해 작업이 완료되기 전에 컴포넌트가 언마운트될 수 있습니다 (예: 경로 변경 또는 DOM에서 컴포넌트가 제거되는 경우). 그런 경우에 컴포넌트가 언마운트된 상태에서 상태를 업데이트하려고 하면 \"Can’t perform a React state update on an unmounted component\"와 같은 오류가 발생할 수 있습니다.\n\nuseEffect 내에서 데이터를 가져올 때 주요 도전 과제는 컴포넌트의 라이프사이클을 처리하는 것입니다.\n\n\n\n\n그러니까, 코드에 버그가 없도록 정리를 해봅시다!\n\n# 효과에서 직접 함수를 반환하기\n\nReact의 useEffect 훅을 사용할 때, 정리를 처리하는 일반적이고 권장되는 방법은 효과에서 직접 함수를 반환하는 것입니다.\n\n```js\nuseEffect(() =\u003e {\n  // 코드 로직\n\n  return () =\u003e {\n    // 정리 작업 \n  };\n}, []); //효과가 한 번만 발생해야 하는 경우, 의존성을 비워둡니다\n```\n\n\n\n# 효율적인 데이터 가져오기 정리를 위해 AbortController 사용\n\nAbortController는 현대 브라우저와 node-fetch를 사용하는 Node.js 환경에서 널리 지원되지만, 모든 환경에서 지원되지 않을 수 있다는 점을 고려하는 것이 중요합니다 (예: IE의 모든 버전이나 일부 오래된 브라우저).\n\nAbortController를 사용하면 fetch가 시작된 시점에 컨트롤러 신호를 추가하여 fetch 요청을 취소할 수 있습니다. isMounted 플래그를 사용하는 것과 비교해 (곧 다룰 예정), fetch 요청과 같은 비동기 작업을 취소하는 표준화된 방법을 제공합니다.\n\n먼저, 새 AbortController를 만들어야 합니다:\n\n\n\n```js\nconst controller = new AbortController();\nconst { signal } = controller;\n```\n\nAbortController 인스턴스를 생성하면 signal 속성을 포함한 객체가 반환됩니다. 이 signal은 fetch 요청이 중단되어야 함을 신호하는데 사용되는 AbortSignal의 인스턴스입니다.\n\n그런 다음 signal을 옵션 객체로 fetch 요청에 전달할 수 있습니다. 이를 통해 컨트롤러의 signal을 fetch 요청과 연결할 수 있습니다.\n\n```js\nconst fetchCatImage = async () =\u003e {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10\u0026api_key=${APIKEY}`, { signal } // 이곳에 signal 전달\n      );\n        const data = await response.json();\n        if (data.length \u003e 0) {\n          const imageURLS = data.map((obj) =\u003e obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        if (error.name === \"AbortError\") {\n          console.log(\"Fetch aborted\"); // fetch가 중단된 경우 처리\n        } else {\n          console.error(\"데이터를 불러오는 중 오류 발생:\", error); // 다른 오류 처리\n        }\n      }\n    };\n    \n    fetchCatImage();\n\n    return () =\u003e {\n      controller.abort(); // 컴포넌트가 언마운트 될 때 fetch 요청 중단\n    };\n  }, []);\n```\n\n\n\n\"AbortError\"은 AbortController에서 abort() 함수가 호출될 때 발생하는 고유한 오류 객체입니다. catch 블록에서 AbortError에 대한 특정 메시지를 추가할 수 있습니다.\n\n이제 각 새로운 효과가 발생하기 전이나 컴포넌트가 마운트 해제되기 바로 전에 fetch 요청이 즉시 취소됩니다.\n\nAbortController를 useEffect 정리 함수와 함께 사용하면 React에서 비동기 작업을 처리하는 견고한 해결책을 제공할 수 있습니다. 이 패턴을 사용하면 컴포넌트가 마운트 해제된 후에 상태를 업데이트하려고 시도하지 않도록 보장할 수 있습니다.\n\n# IsMounted 플래그 설정:\n\n\n\n오래된 브라우저나 제한된 JavaScript 환경에서 개발 중이라면 IsMounted 플래그를 사용하면 간단한 대안이 될 수 있습니다.\n\n컴포넌트가 초기에 마운트될 때 isMounted를 true로 설정합니다. 컴포넌트가 여전히 마운트된 상태인 경우에만 상태를 업데이트합니다. 마지막으로 useEffect에서 반환된 정리 함수에서 컴포넌트가 마운트 해제되면 isMounted를 false로 설정하여 컴포넌트가 마운트 해제된 후 데이터 가져오기가 완료된 경우 상태 업데이트를 방지합니다.\n\n```js\n  useEffect(() =\u003e {\n    let isMounted = true; // 컴포넌트가 마운트된 상태를 추적하는 플래그\n\n    const fetchCatImage = async () =\u003e {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10\u0026api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (isMounted \u0026\u0026 data.length \u003e 0) {\n          const imageURLS = data.map((obj) =\u003e obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        console.error(\"데이터를 불러오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n\n    return () =\u003e {\n      isMounted = false; // 컴포넌트가 언마운트될 때 isMounted를 false로 설정하여 정리\n    };\n  }, []);\n```\n\n그러니, 간략히 정리하면:\n\n\n\n- useEffect 정리: 권장하는 방법은 정리를 수행하는 함수를 직접 반환하는 것입니다.\n- AbortController 사용: 대부분의 경우에 해당합니다. 주요 비동기 작업(예: 데이터 가져오기)에 신호를 첨부하고 정리 함수에서 컨트롤러를 중지합니다.\n- isMounted 플래그 사용: 일부 오래된 환경이나 제한적인 환경에서 AbortController을 지원하지 않을 때\n\n여기까지 하면 useEffect가 스스로 정리할 수 있어요! 고양이 사진을 즐기세요!\n\n이 게시물을 읽어주셔서 감사합니다!! 💜\n\n게시물이 마음에 들었다면 👏 또는 댓글을 남겨주세요.\n\n\n\n질문이나 제안이 있으시거나 저와 함께 일하고 싶으시다면 언제든지 연락해 주세요:\n\n- 이메일: renashen314@gmail.com\n- LinkedIn","ogImage":{"url":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png"},"coverImage":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs가 더욱 쉬워졌어요 env 파일에 대한 네이티브 지원","description":"","date":"2024-05-12 23:19","slug":"2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles","content":"\n\n\n![Node.js Gets Even Easier Native Support for env Files](/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png)\n\nNode.js 작업을 한다면 환경 변수 사용법에 익숙할 것입니다. 다양한 환경(개발, 테스트, 프로덕션)에서 설정을 관리하거나 민감한 데이터를 저장하는 데 사용되는 것으로 추측됩니다.\n일반적으로.env 파일에서 이러한 변수를 로드하는 전통적인 방법은 이전에 \"dotenv\"와 같은 패키지를 설치해야 했습니다.\n\n하지만 Node.js v20.6.0부터 상황이 바뀌었습니다! 지금은.env 파일이 네이티브로 지원됩니다.\n\n왜 중요한 이유인가요\n\n\n\n- 더 간단한 설정: 더 적은 외부 종속성을 갖는 경량 구조의 프로젝트입니다.\n- 표준화: .env 파일을 사용하는 것이 일반적이며, 네이티브 지원이 있어서 Node.js 코드를 다양한 백그라운드를 갖는 개발자가 이해하기 쉬워집니다.\n- 다양한 구성: 다른 환경 간에 쉽게 전환하기 위해 다른 .env 파일을 활용합니다.\n\n사용 방법\n\n- .env 파일 생성: 프로젝트의 루트 디렉토리에 .env이라는 일반 텍스트 파일을 추가합니다.\n- 변수 설정: KEY=VALUE와 같은 형식으로 변수를 정의합니다. 예를 들어:\nPORT=3000\n- 변수 접근: Node.js 코드에서 이들에 접근하기 위해 process.env를 사용합니다.\n- 기본 위치: Node.js는 프로젝트의 루트에서 .env 파일을 자동으로 찾습니다. 사용자 정의 위치가 필요하다면 앱을 실행할 때 --env-file 플래그를 사용하세요 (예: node app.js --env-file=./config/.env).\n\n단순함을 환영합니다.\n\n\n\n이 작은 변경은 다른 프레임워크에서의 표준 절차와 일치하게 만들어 Node.js 개발 프로세스를 약간 더 쉽게 만들어줍니다. 한 번 시도해 보세요!\n\nNode.js 프로젝트에서 환경 변수의 특정 응용 프로그램에 대해 논의하거나 문의 사항이 있으시면 언제든지 연락해 주세요!\n\n읽어주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png"},"coverImage":"/assets/img/2024-05-12-NodejsGetsEvenEasierNativeSupportforenvFiles_0.png","tag":["Tech"],"readingTime":2}],"page":"127","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"127"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>