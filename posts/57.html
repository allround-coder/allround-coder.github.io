<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기" href="/post/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reset.css로 프로젝트 스타일을 초기화 하는 방법" href="/post/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reset.css로 프로젝트 스타일을 초기화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reset.css로 프로젝트 스타일을 초기화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reset.css로 프로젝트 스타일을 초기화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인라인 스타일과 CSS의 성능 차이 정리 및 비교" href="/post/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인라인 스타일과 CSS의 성능 차이 정리 및 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인라인 스타일과 CSS의 성능 차이 정리 및 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">인라인 스타일과 CSS의 성능 차이 정리 및 비교</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법" href="/post/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트를 TailwindCSS로 만들어야하는 이유 " href="/post/2024-05-27-Tailwindischangingthelandscapeofuserexperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트를 TailwindCSS로 만들어야하는 이유 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트를 TailwindCSS로 만들어야하는 이유 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트를 TailwindCSS로 만들어야하는 이유 </strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 뉴스 - 2024년 5월 20일" href="/post/2024-05-27-FrontendWeeklyDigest3642026May2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 뉴스 - 2024년 5월 20일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 뉴스 - 2024년 5월 20일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 뉴스 - 2024년 5월 20일</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법" href="/post/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 신호 컴포넌트 입력을 위한 새로운 시대" href="/post/2024-05-27-AngularSignalsANewEraforComponentInputs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 신호 컴포넌트 입력을 위한 새로운 시대" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AngularSignalsANewEraforComponentInputs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 신호 컴포넌트 입력을 위한 새로운 시대" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 신호 컴포넌트 입력을 위한 새로운 시대</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v18 성능 향상 및 개발자 경험 향상" href="/post/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v18 성능 향상 및 개발자 경험 향상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v18 성능 향상 및 개발자 경험 향상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v18 성능 향상 및 개발자 경험 향상</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개" href="/post/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link posts_-active__YVJEi" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Google Apps Script의 스크립트 편집기에서 HTML 및 Javascript 개발 기능 향상하기 서식 지정 문제 극복하기","description":"","date":"2024-05-27 19:09","slug":"2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges","content":"\n\n\n![EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScript](/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png)\n\n# 개요\n\n2022년 4월에 시작된 Google Apps Script IDE가 개선되었음에도 불구하고 HTML 및 Javascript 개발에 대한 어려움이 발생합니다. 특히 스크립트 편집기의 내장된 언어 형식 지정은 큰 Javascript 코드베이스에 대해 불충분하며, 잠재적으로 오류를 일으킬 수 있습니다. 본 보고서는 이러한 형식 지정 문제를 해결하고 스크립트 편집기 내에서 개발을 원활하게 할 수 있는 솔루션을 제안합니다.\n\n# 소개\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle Apps Script 통합 개발 환경(IDE) 스크립트 편집기가 2022년 4월 13일에 중요한 업데이트를 받아 더 현대적이고 간소화된 개발 환경으로 변모했습니다. 이 향상된 IDE를 통해 개발자들은 그들의 조직을 위해 구글 워크스페이스 애플리케이션의 기능을 확장하는 사용자 정의 솔루션을 만들 수 있습니다.\n\n스크립트 편집기는 Google Apps Script 개발에 유용한 도구지만, HTML 및 Javascript를 사용할 때 문제가 발생할 수 있습니다. 현재 스크립트 편집기 내에서 HTML 및 Javascript 개발은 직접 HTML 파일에서 발생합니다. 편집기는 서식 지원 기능을 제공하지만, Javascript 코드 포맷팅은 HTML 포맷팅과 비교했을 때 덜 견고해 보입니다. 이로 인해 큰 Javascript 코드베이스를 다룰 때 특히 오류가 발생할 수 있습니다.\n\n본 보고서는 이 특정 문제에 대한 해결책을 제안합니다. Google Apps Script 스크립트 편집기 내에서 HTML 및 Javascript를 효과적으로 개발하는 방법을 탐구하고, 개발 효율성을 향상시키고 오류를 줄일 수 있도록 올바른 Javascript 코드 포맷팅을 보장합니다.\n\n# 사용법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. Google Apps Script 프로젝트 만들기\n\n이 샘플에서는 HTML 및 Javascript를 사용하기 위해 Google Spreadsheet에서 대화 상자를 사용합니다. 따라서 새 Google Spreadsheet를 만들고 스크립트 편집기를 열어주세요.\n\n# 2. 샘플 스크립트 1\n\n이 섹션에서 현재 문제를 설명합니다. 아래 스크립트와 HTML을 복사하여 스크립트 편집기에 붙여넣어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# code.gs\n\n```js\nfunction openDialog() {\n  const html = HtmlService.createHtmlOutputFromFile(\"index\");\n  SpreadsheetApp.getUi().showModalDialog(html, \"sample\");\n}\n```\n\n# index.html\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cbase target=\"_top\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv id=\"sample\"\u003e\u003c/div\u003e\n\u003cscript\u003e\nconst array = [[\"A1\", \"B1\", \"C1\"],[\"A2\", \"B2\", \"C2\"],[\"A3\", \"B3\", \"C3\"]];\nconst div = document.getElementById(\"sample\");\nconst table = document.createElement('table');\ntable.border = \"1\";\ntable.style.width = \"100%\";\ntable.style[\"border-collapse\"] = \"collapse\";\nfor (let i = 0; i \u003c array.length; i++) {\n  const tr = document.createElement('tr');\n  for (let j = 0; j \u003c array[i].length; j++) {\n    const td = document.createElement('td');\n    const text = document.createTextNode(array[i][j]);\n    td.appendChild(text);\n    tr.appendChild(td);\n  }\n  table.appendChild(tr);\n}\ndiv.appendChild(table);\n\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트\n\nopenDialog 함수를 실행하면 대화 상자가 열리고 대화 상자에서 다음 테이블을 볼 수 있습니다. HTML과 JavaScript가 잘 작동하는 것을 확인할 수 있습니다.\n\n![Table Image](/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_1.png)\n\n다음 단계로 넘어가면 index.html을 볼 때 JavaScript 형식이 지정되지 않았고 가독성이 낮다는 것을 알 수 있습니다. 이 코드를 스크립트 편집기에서 형식을 맞추면 다음과 같이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*AQlYdIS3NlLn6zcy.gif\" /\u003e\n\n코드를 서식화하면 HTML이 올바르게 서식이 적용됩니다. 그러나 Javascript는 올바르게 서식이 적용되지 않는 것을 볼 수 있습니다. 이 상황은 Javascript를 개발하는 데 문제가 될 수 있다고 생각합니다.\n\n# 3. 샘플 스크립트 2\n\n본 섹션에서는 상기 상황을 피하기 위한 해결책으로 샘플 스크립트 2를 소개하고자 합니다. 따라서 아래 스크립트를 복사하기 전에 상기 섹션에서 사용된 code.gs 및 index.html을 지우고, 다음 스크립트와 HTML을 스크립트 편집기에 복사하여 붙여넣어 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# code.gs\n\n```js\nfunction javascript_() {\n  const array = [[\"A1\", \"B1\", \"C1\"],[\"A2\", \"B2\", \"C2\"],[\"A3\", \"B3\", \"C3\"]];\n  const div = document.getElementById(\"sample\");\n  const table = document.createElement('table');\n  table.border = \"1\";\n  table.style.width = \"100%\";\n  table.style[\"border-collapse\"] = \"collapse\";\n  \n  for (let i = 0; i \u003c array.length; i++) {\n    const tr = document.createElement('tr');\n    \n    for (let j = 0; j \u003c array[i].length; j++) {\n      const td = document.createElement('td');\n      const text = document.createTextNode(array[i][j]);\n      td.appendChild(text);\n      tr.appendChild(td);\n    }\n    \n    table.appendChild(tr);\n  }\n  \n  div.appendChild(table);\n}\n\nfunction openDialog() {\n  const html = HtmlService.createTemplateFromFile(\"index\");\n  html.javascript = javascript_\n    .toString()\n    .match(/^function javascript_\\(\\) {([\\s\\S\\w]*)}$/)[1];\n  SpreadsheetApp.getUi().showModalDialog(html.evaluate(), \"sample\");\n}\n```\n\n# index.html\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cbase target=\"_top\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv id=\"sample\"\u003e\u003c/div\u003e\n\u003cscript\u003e\n\u003c?!= javascript ?\u003e\n\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스팅\n\nopenDialog 함수를 실행하면 대화 상자가 열리고 대화 상자에서 다음 표를 볼 수 있습니다. 위 섹션에서 동일한 결과를 볼 수 있습니다.\n\n다음 단계로, 현재 index.html 및 code.gs를 확인하면 두 형식 모두 미완료되고 가독성이 낮음을 알 수 있습니다. 이러한 코드가 스크립트 편집기로 형식이 지정되면 다음과 같이 됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*Sszz38pwq-gqhqju.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html과 code.gs를 형식화하면 두 파일 모두 적절한 서식으로 표시되어 가독성이 향상됩니다. 또한 JavaScript 코드는 대화 상자 내에서 올바르게 작동합니다.\n\n이전에 언급했듯이 스크립트 편집기는 현재 code.gs 스크립트 파일 내의 Google Apps 스크립트를 형식화할 수 있습니다. 이 보고서는이 기능을 해결책으로 활용합니다. JavaScript는 code.gs 스크립트 파일에서 개발되며 개발된 코드는 index.html HTML 파일로 가져옵니다. 이 작업 흐름을 통해 JavaScript 코드를 적절히 형식화하여 개발할 수 있습니다.\n\n# 중요\n\nJavaScript 코드에 스크립트 편집기와 호환되지 않는 구문이 포함된 경우 이 해결책을 적용할 수 없음에 유의해 주세요. 이러한 시나리오에서 주의해 주시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고\n\n- 최상단의 추상 이미지는 Gemini에게 이 보고서를 제공하여 생성되었습니다.","ogImage":{"url":"/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png"},"coverImage":"/assets/img/2024-05-27-EnhancingHTMLandJavascriptDevelopmentinScriptEditorofGoogleAppsScriptOvercomingFormattingChallenges_0.png","tag":["Tech"],"readingTime":6},{"title":"Reset.css로 프로젝트 스타일을 초기화 하는 방법","description":"","date":"2024-05-27 19:08","slug":"2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024","content":"\n\n\n![Reset CSS](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png)\n\n웹 사이트 소스를 확인하면 이곳저곳에서 이 reset.css를 만날 수 있습니다. CSS Reset은 무엇이며 왜 필요한 걸까요?\n\n이 기사에서 다양한 reset.css를 확인할 수 있는 간단한 코드펜을 만들었어요! CSS Reset을 느껴보기 위해 한 번 시도해보세요!\n\nCSS Reset 스타일 시트는 기본 브라우저 스타일을 모두 재정의하는 CSS 스타일 목록입니다. 대부분의 브라우저는 테두리, 패딩 및 마진, 확대 축소, 글꼴 등에 자체 스타일을 가지고 있습니다. reset.css를 사용하면 이러한 기본 동작을 모두 제거하고 다양한 브라우저에서 일관된 UI/UX를 유지할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크롬\n- 사파리\n- 파이어폭스\n- 엣지\n\n웹 디자인을 일관되게 유지하는 옵션을 찾고 있다면, reset.css 외에도 normalize.css를 사용할 수 있는 옵션이 있습니다.\n\nreset.css와는 다르게 normalize.css는 브라우저 기본값을 지우는 대신 일부를 보존합니다. 이는 sub와 같은 요소를 사용하는 경우 유용할 수 있습니다. 이 경우 reset.css 대신 normalize.css를 사용하면 일반 텍스트와 거의 동일하게 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 normalize.css를 사용하면, 사전 서식이 지정된 텍스트의 글꼴 크기를 수정하는 등의 일반적인 버그를 수정할 수 있습니다.\n\n그러나 저는 기본 스타일을 모두 초기화하고 싶습니다! 그래서 reset.css를 사용하기로 결정했고, 이 문서에서 제 추천을 공유하려고 합니다!\n\n# reset.css 사용하기\n\nreset.css를 다른 스타일 시트처럼 사용할 수 있습니다. 여기서 염두에 두어야 할 유일한 것은 reset.css가 가장 먼저 와야 한다는 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003chead\u003e\n    \u003clink rel=\"stylesheet\" href=\"reset.css\" /\u003e\n    \u003clink rel=\"stylesheet\" href=\"otherStyles.css\" /\u003e\n\u003c/head\u003e\n\n\n# 2024년을 위한 추천\n\n안녕하세요! 실제로 reset.css는 서로 다른 방식으로 서로 다른 정도의 스타일을 초기화합니다. 여기서 내가 정말 좋아하는 것들 중 일부를 공유하고 싶어요!\n\n자세히 알아보거나 시각화를 더 잘 하고 싶다면, 우리가 이 글에 포함시킨 모든 다른 reset.css를 비교할 수 있는 간단한 코드펜을 사용해보세요. 이 글에는 normalize.css도 포함되어 있으며 스타일시트를 추가하지 않은 선택 사항도 비교할 수 있도록 포함해 두었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*wjXmIrPgLX_afnYKDhvj4w.gif\" /\u003e\n\n(PS: CSS 내용은 무시해도 괜찮아요, 시각화를 위한 것뿐이에요!)\n\n## 현대 CSS 리셋\n\n여기서 제공하는 것은 아마도 현대 브라우저에 가장 흔하게 사용되는 CSS 리셋 중 하나일 것입니다. 테일윈드에서 리셋 스타일시트로 사용되었던 것으로 알고 있는데요 (이제는 normalize.css를 사용하러 가는 것 같아요). (그런 의미로, 이것은 제가 독특하다고 보지 않아서 가장 마음에 들지 않는 것이에요!)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 reset.css의 가장 좋은 부분 중 하나는 파일을 작고 유지하기 때문에 로딩 속도가 정말 빠르다는 점입니다. 또한 모든 요소에 대해 box-sizing을 border-box로 정의하고 양식과 목록을 정의하는 데 많은 주의를 기울입니다.\n\n이 리셋은 실제로 내 개인적인 의견으로는 모든 `h1`과 같은 태그에 대해 글꼴 크기를 유지해 normalize.css에 더 가깝다고 생각합니다.\n\n저자는 GitHub 저장소를 성공적으로 이루었고 reset.css를 여기에 게시했습니다. 로컬 파일에 복사하여 붙여 넣거나 CDN인 https://unpkg.com/modern-css-reset/dist/reset.min.css를 사용하여 추가할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Reboot.css\n\n부트스트랩에서 사용하는 리셋 CSS입니다. 퀄리티가 보장되죠!\n\n사실 이건 normalize.css에 더 가깝습니다. 위의 것과 비교했을 때 요소들의 폰트 크기(`h1` 등)를 유지합니다. 아래 스크린샷에서 보시다시피 패딩도 그대로 유지됩니다.\n\n(사실 이거 쓰고 아무것도 안 쓰는 거랑 차이가 크게 느껴지지는 않았던 것 같아요…)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_2.png)\n\n다음 방법으로 추가할 수 있어요\n\n- CDN 사용: [https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap-reboot.css](https://cdn.rawgit.com/twbs/bootstrap/v4-dev/dist/css/bootstrap-reboot.css), 또는\n- Github에서 다운로드하세요.\n\n## @acab/reset.css\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@acab/reset.css는 최신 CSS 기능을 활용한 스타일 리셋이에요. 이 리셋 스타일시트를 다른 것과 구별하는 두 가지 주요 기능이 있어요.\n- iOS Safari에서 100vh가 전체 높이를 채우지 않는 문제를 해결했어요.\n- color-scheme을 활용하여 자동 다크 모드를 지원해요.\n\n@acab/reset.css를 사용하는 방법:\n- npm을 이용해 설치하기: npm install @acab/reset.css,\n- CDN 이용: https://unpkg.com/@acab/reset.css,\n- 소스 코드 다운로드 후 로컬 파일로 추가하기.\n\n해보세요! 🙂\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 보시다시피, 위의 것과 많이 다른데요, 제 지역의 컬러 스킴에 적응하고 있어요!\n\n![이미지](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_3.png)\n\n### 새로운 CSS 초기화\n\n이 새로운 CSS 초기화는 제가 가장 좋아하는 스타일이에요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 스타일을 제외한 모든 것이 제거됩니다. 그러나 display 속성 및 iframe, canvas, img, svg, video와 같은 특수 HTML 요소는 유지됩니다.\n\n![이미지1](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_4.png)\n\n![이미지2](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_5.png)\n\n네, 스타일이 하나도 남지 않습니다. 입력 상자나 라디오 버튼조차 없어요! 모든 것을 제거하고 처음부터 직접 디자인하고 싶다면 완벽해요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n너무 복잡한 것 같나요? 특정 요소의 기본 스타일을 되찾는 데는\n\n- 전역 CSS 리셋 키워드, unset 및 revert 키워드.\n- 모든 속성을 초기화하는 all 속성을 결합할 수 있어요.\n\n특정 HTML 요소의 브라우저 기본 스타일을 되찾으려면, 예를 들어 input의 경우, 다음과 같이 할 수 있어요\n\n```js\ninput {\n    all: revert;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 이제 우리가 사용하는 일반적인 형식으로 돌아왔어요!\n\n![2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_6.png](/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_6.png)\n\n이 새로운 CSS 리셋은 특정성을 제거하는 :where() 가상 클래스와 여러 인수를 가진 :not() 가상 클래스와 같은 다른 CSS 기능도 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저기요!\n\n저희 프로젝트에서는 다음 방법으로 사용할 수 있어요:\n\n- CDN을 이용하는 방법: https://cdn.jsdelivr.net/npm/the-new-css-reset@1.11.2/css/reset.min.css,\n- 최신 버전 다운로드하는 방법, 또는\n- NPM 패키지로 사용하는 방법\n\n읽어 주셔서 감사합니다! 마음에 드는 방법을 찾으셨나요?\n\n즐거운 스타일링 되세요!","ogImage":{"url":"/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png"},"coverImage":"/assets/img/2024-05-27-ResetcssandEntirelyPersonalRecommendationsfor2024_0.png","tag":["Tech"],"readingTime":5},{"title":"인라인 스타일과 CSS의 성능 차이 정리 및 비교","description":"","date":"2024-05-27 19:06","slug":"2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences","content":"\n\n![Are inline styles better than CSS? Performance differences](/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png)\n\n웹 개발에 있어서 인라인 스타일과 CSS 스타일 시트의 성능 차이에 대한 논쟁이 일반적으로 있습니다. 각 접근 방식의 미묘한 차이를 이해하는 것은 효율적이고 유지보수가 용이하며 확장 가능한 웹 애플리케이션을 만드는 데 중요합니다. 이 블로그 포스트에서는 인라인 스타일과 CSS에 대한 성능 측면, 실용적 사용 및 최선의 방법에 대해 탐구해 보겠습니다.\n\n# 인라인 스타일과 CSS 이해하기\n\n# 인라인 스타일:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인라인 스타일은 HTML 요소 내에서 직접 정의됩니다. 스타일 속성을 사용하여 스타일을 지정할 수 있습니다. 예시:\n\n```html\n\u003cdiv style=\"color: red; font-size: 16px;\"\u003eHello, World!\u003c/div\u003e\n```\n\n# CSS 스타일시트:\n\nCSS 스타일은 별도의 CSS 파일에 정의할 수 있고, HTML 문서에 연결하거나 HTML 문서 내에 `style` 태그를 사용하여 포함시킬 수 있습니다. 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- 외부 CSS --\u003e\n\u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e\n\n\u003c!-- 내장 CSS --\u003e\n\u003cstyle\u003e\n  .example {\n    color: red;\n    font-size: 16px;\n  }\n\u003c/style\u003e\n\u003cdiv class=\"example\"\u003eHello, World!\u003c/div\u003e\n```\n\n# 성능 고려사항\n\n# 로딩과 구문 분석\n\n## 인라인 스타일:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이니셜 로드 시간: 인라인 스타일은 HTML 내에서 직접 정의되기 때문에 브라우저는 외부 스타일 시트를 로드하기 위해 추가적인 요청을 보내지 않아도 됩니다. 특히 소규모 웹사이트의 경우, 이는 초기 로드 시간을 약간 줄일 수 있습니다.\n- 구문 분석 속도: 인라인 스타일은 HTML이 처리됨과 동시에 즉시 구문 분석됩니다. 소수의 인라인 스타일의 경우, 성능 차이는 무시할 수 있습니다. 그러나 인라인 스타일의 수가 증가함에 따라 오버헤드가 상당히 증가할 수 있습니다.\n\n## CSS 스타일시트:\n\n- 이니셜 로드 시간: 외부 스타일 시트는 추가적인 HTTP 요청이 필요하며, 이는 초기 로드 시간을 증가시킬 수 있습니다. 그러나 HTTP/2와 캐싱과 같은 현대적인 기술을 사용하면 이 영향을 최소화할 수 있습니다.\n- 구문 분석 속도: 스타일 시트는 한 번 해석되고 문서에 적용되므로, 많거나 복잡한 스타일이 있는 페이지에 효율적입니다. 브라우저 최적화와 캐싱은 후속 페이지 로드의 성능을 크게 향상시킬 수 있습니다.\n\n# 렌더 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인라인 스타일:\n\n- 효율성: 인라인 스타일은 즉시 적용되어 위험하거나 페이지의 상위 부분 콘텐츠를 빠르게 렌더링하기 위해 유용할 수 있습니다. 그러나 너무 많은 인라인 스타일을 사용하면 HTML 크기가 커져 렌더링 속도가 느려질 수 있습니다.\n- 특이성과 오버헤드: 인라인 스타일은 가장 높은 특이성을 가지고 있어 다른 스타일을 무력화시킬 수 있으며, 이는 코드의 복잡성 증가와 유지보수가 어려워지는 가능성이 있습니다.\n\n## CSS 스타일시트:\n\n- 효율성: 외부 스타일시트는 한 번 로드되고 해석되면 여러 요소와 페이지에 스타일을 적용하는 데 효과적입니다. 중복을 줄이고 재사용성을 촉진하는 데 도움이 됩니다.\n- 브라우저 최적화: 최신 브라우저는 대용량 CSS 파일을 효율적으로 처리할 수 있는 최적화된 기능을 갖추고 있으며, CSS 최소화와 압축과 같은 기술은 성능을 더욱 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실용적인 용도 및 최선의 방법\n\n## 인라인 스타일을 사용해야 하는 경우\n\n**빠른 프로토타이핑:**\n\n전체 스타일시트에 영향을 미치지 않으면서 특정 스타일을 빠르게 테스트하거나 프로토타입을 만들 때 인라인 스타일은 빠르고 효과적인 해결책이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 동적 스타일링:\n\n사용자 상호작용이나 데이터에 따라 동적으로 생성된 스타일이 필요할 때 JavaScript와 함께 인라인 스타일을 효과적으로 사용할 수 있습니다. 예를 들어, 버튼 클릭 시 요소의 배경색을 변경하는 방법은 다음과 같습니다:\n\n```js\ndocument.getElementById(\"myDiv\").style.backgroundColor = \"blue\";\n```\n\n# Critical Rendering Path:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요하거나 화면 상단에 표시되는 콘텐츠에는 인라인 스타일을 사용하여 외부 스타일시트가 로드될 때까지 기다리지 않고 즉시 필수 스타일이 적용될 수 있습니다.\n\n# CSS 스타일시트 사용 시기\n\n## 확장성 및 유지보수성:\n\n대규모 프로젝트의 경우 CSS 스타일시트를 사용하면 조직화, 유지보수 및 확장성이 더 잘 이루어집니다. 스타일은 콘텐츠와 분리되어 관리되며 관심사의 분리 원칙을 준수합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 재사용성:\n\nCSS 스타일시트에 정의된 스타일은 여러 페이지와 요소에서 재사용될 수 있어 중복을 줄이고 웹 사이트 전체에서 일관성을 유지할 수 있습니다.\n\n## 브라우저 캐싱:\n\n외부 스타일시트는 브라우저에 의해 캐싱될 수 있어, 스타일시트를 한 번로드한 후에는 이후 페이지로드에 재사용할 수 있어 성능을 획기적으로 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인라인 스타일과 CSS의 조합에 대한 최상의 방법\n\n인라인 스타일이 CSS보다 빠른지에 대한 일반적인 해답은 없지만, 일반적으로 두 가지 방법을 결합하여 각 방법의 강점을 활용하는 것이 최상의 방법입니다. 다음은 몇 가지 최상의 방법입니다:\n\n## 1. 중요한 CSS:\n\n렌더링 차단 문제를 줄이기 위해 인쇄 스타일을 사용하여 필요한 중요한 CSS를 사용하여 위에서부터 페이지 콘텐츠를 로드합니다. 그런 다음 페이지의 나머지 부분을위한 외부 CSS를 로드하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 과도한 인라인 스타일 피하기:\n\n너무 많은 인라인 스타일을 사용하지 않도록 주의하세요. 이는 HTML 크기와 복잡성을 증가시킬 수 있습니다. 인라인 스타일은 성능이나 조직적 이점이 명확한 경우에만 사용하세요.\n\n## 3. 재사용 가능성을 위해 외부 스타일시트 사용하기:\n\n비 비상요 속성과 재사용 가능한 스타일에 대해 외부 스타일시트를 선호하세요. 이렇게 하면 HTML을 깔끔하게 유지하고 스타일을 중앙 집중화하여 관리와 유지보수가 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. CSS 전달 최적화:\n\n- 최소화 및 압축: CSS 파일을 최소화하고 압축하여 로드 시간을 줄입니다.\n- HTTP/2: HTTP/2를 활용하여 여러 CSS 파일을 로드하는 효율을 향상시킵니다.\n- 사전로드 및 사전요청: `link rel=”preload”` 또는 `link rel=”prefetch”`를 사용하여 중요한 CSS 파일을 우선적으로 처리합니다.\n\n# 5. JavaScript를 활용한 동적 스타일링:\n\n동적으로 스타일을 적용할 때는 인라인 스타일보다 클래스 토글링을 선호합니다. 이렇게 하면 CSS의 힘을 활용하면서 HTML을 더 깔끔하게 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 웹 애플리케이션의 성능 영향을 더 잘 이해하기 위해,\n// 가상의 웹 애플리케이션 사례 연구를 고려해 보겠습니다.\n\n# 시나리오:\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뉴스 웹사이트는 사용자 기호에 따라 동적으로 생성된 테마를 기반으로 기사를 표시해야 합니다. 이 테마에는 다양한 색상 구성표와 글꼴 스타일이 포함됩니다.\n\n# 방법 1: 인라인 스타일\n\n- 장점: 사용자 기호에 따라 스타일을 빠르게 적용할 수 있습니다.\n- 단점: HTML 크기 증가, 유지 관리가 줄어들고 기사 수가 많아질수록 성능 저하 가능성이 있습니다.\n\n# 방법 2: CSS 스타일시트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 장점: 스타일의 중앙 집중 관리, 캐싱을 통한 성능 향상, HTML 크기 감소.\n- 단점: 사용자 환경에 따라 올바른 클래스를 적용하기 위해 추가 로직이 필요합니다.\n\n# 해결책:\n\n화면 상단 콘텐츠에 대한 중요한 스타일은 인라인으로 적용하여 빠른 화면 표시를 보장하고, 나머지 스타일은 외부 CSS를 통해 관리하는 혼합 접근 방식을 사용합니다. 다음과 같이 달성할 수 있습니다:\n\n## 인라인 중요 스타일:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```css\n/* 뷰포트 상단 컨텐츠를 위한 필수 스타일 */\n.header {\n  font-family: Arial, sans-serif;\n  color: #333;\n}\n```\n\n## 스타일된 테마용 외부 CSS:\n\n```html\n\u003clink rel=\"stylesheet\" href=\"themes.css\"\u003e\n\u003cscript\u003e\n  // 올바른 테마 클래스 적용을 위한 JavaScript\n  function applyTheme(theme) {\n    document.body.classList.add(theme);\n  }\n\n  // 예시: 사용자 선호도 적용\n  applyTheme('dark-theme');\n\u003c/script\u003e\n```\n\n## Themes.css:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndark-theme {\n  background-color: #121212;\n  color: #ffffff;\n}\n\nlight-theme {\n  background-color: #ffffff;\n  color: #000000;\n}\n```\n\n# 결론\n\n인라인 스타일이 CSS 스타일시트보다 빠른지에 대한 논쟁은 프로젝트의 크기와 복잡성, 고려되는 특정 성능 측정 항목, 그리고 웹 응용 프로그램의 전체 구조 등 다양한 요소에 달려있습니다.\n\n일부 소스에 따르면, 특정 시나리오에서 인라인 스타일은 CSS 스타일시트보다 최대 2.4배 빠를 수 있으며 특히 중요한 내용 또는 화면 상단에 있는 내용을 렌더링할 때 이점이 있을 수 있습니다. 이 성능 향상은 스타일을 즉시 적용하면서 추가 HTTP 요청이나 외부 파일의 구문 분석 없이 가능하기 때문에 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인라인 스타일은 핵심 렌더링 경로 및 동적 스타일링에 대한 성능 이점을 제공할 수 있지만, 사용량이 증가함에 따라 처리하기 번거로워지고 유지 관리하기 어려워질 수 있습니다. 반면 CSS 스타일시트는 더 나은 확장성과 유지 관리성을 제공하며 여러 페이지 로드에서 성능을 향상시키기 위해 브라우저 캐싱을 활용할 수 있습니다.\n\n최종적으로, 인라인 스타일과 CSS 스타일시트의 장점을 모두 활용하는 균형 잡힌 접근 방식이 현대 웹 애플리케이션의 성능과 유지 관리성을 최대화할 것입니다. 각 방법을 언제 어떻게 사용할지 신중히 고려함으로써 개발자는 빠르고 유지 관리 가능한 웹 애플리케이션을 만들 수 있습니다.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가에게 박수를 보내 주시고 팔로우 부탁드려요! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 대한 강요를 받는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png"},"coverImage":"/assets/img/2024-05-27-AreinlinestylesbetterthanCSSperformancedifferences_0.png","tag":["Tech"],"readingTime":7},{"title":"사용자 경험(UX) 크로스 문서 뷰 전환 하는 방법","description":"","date":"2024-05-27 19:05","slug":"2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions","content":"\n\n## 파워포인트 슬라이드쇼처럼 웹사이트를 만드는 방법\n\n![Image](/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png)\n\n웹사이트의 링크를 클릭하면서 왜 PowerPoint 슬라이드쇼처럼 부드럽지 않을까 궁금했던 적이 있나요?\n\n표준적인 불편한 페이지 로딩에 짜증이 나시나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도 매우 간단한 해결책이 있습니다. CSS와 JavaScript에 대한 약간의 경험만 있으면 사용자 정의 전환을 시작할 수 있습니다.\n\n이 문서에서는 다음 프로젝트에서 이를 사용해야 하는 이유를 설명하고, 웹사이트에 구현하는 방법을 보여드릴 것입니다.\n\n# 왜 Cross-Document View 전환을 사용해야 하는가?\n\n- 웹사이트를 사용할 때 사용자 경험과 만족도가 향상되고 개선됩니다.\n- 이는 웹사이트의 일관성을 높이고, 내용에 대한 이해를 증진시켜줍니다.\n- 특수 효과를 위해 일반적으로 외부 라이브러리 및 프레임워크를 사용하지만, 이는 성능 손실로 이어질 수 있습니다. 반면 내부 방법은 더 빠르고 효과적인 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 문서 간 보기 전환 구현\n\n문서 간 보기 전환을 구현하려면 HTML, CSS, 그리고 JavaScript를 조합하여 사용해야 합니다.\n\n아래에서는 이러한 전환을 설정하고 구현하는 데 필요한 단계를 안내해 드리겠습니다.\n\n## 기본 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다중 페이지 애플리케이션을 위한 기본적인 HTML 구조부터 시작해보겠습니다. 두 개의 간단한 HTML 페이지를 생성해보겠습니다.\n\n페이지 1: index.html\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003e페이지 1\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003e페이지 1\u003c/h1\u003e\n        \u003ca href=\"page2.html\" class=\"transition-link\"\u003e페이지 2로 이동\u003c/a\u003e\n    \u003c/div\u003e\n    \u003cscript src=\"transition.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003e페이지 2\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003e페이지 2\u003c/h1\u003e\n        \u003ca href=\"index.html\" class=\"transition-link\"\u003e페이지 1로 이동\u003c/a\u003e\n    \u003c/div\u003e\n    \u003cscript src=\"transition.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n## 트랜지션을 위한 CSS\n\n트랜지션을 위한 CSS 스타일을 정의합니다. 여기서는 간단한 페이드 인 및 페이드 아웃 효과를 사용할 것입니다.\n\n```js\n/* styles.css */\nbody {\n    margin: 0;\n    font-family: Arial, sans-serif;\n}\n\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n    transition: opacity 0.5s ease;\n}\n\n.hidden {\n    opacity: 0;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 페이지 전환 처리를 위한 JavaScript\n\n페이지 간 전환을 처리하는 JavaScript 로직을 구현하세요. 이는 링크에 이벤트 리스너를 추가하고 전환 효과를 관리하는 것을 포함합니다.\n\n```js\n// transition.js\ndocument.addEventListener('DOMContentLoaded', () =\u003e {\n    const links = document.querySelectorAll('.transition-link');\n\n    links.forEach(link =\u003e {\n        link.addEventListener('click', event =\u003e {\n            event.preventDefault();\n            const targetUrl = event.target.href;\n\n            document.body.classList.add('hidden');\n\n            setTimeout(() =\u003e {\n                window.location.href = targetUrl;\n            }, 500);\n        });\n    });\n});\n\nwindow.addEventListener('pageshow', () =\u003e {\n    document.body.classList.remove('hidden');\n});\n```\n\n# 모두 함께 적용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nindex.html과 page2.html 모두 CSS와 JavaScript 파일이 올바르게 연결되어 있는지 확인해주세요. 사용자가 다른 페이지로 이동하려는 링크를 클릭하면 현재 페이지가 페이드아웃되고 새 페이지가 페이드인되어 부드러운 전환 효과가 만들어집니다.\n\n![다음 수준의 사용자 경험을 위한 문서 간 뷰 전환](/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_1.png)\n\n## 고급 전환\n\n기본 페이드 전환은 좋은 시작점이지만, 슬라이드, 스케일 또는 사용자 정의 애니메이션과 같은 더 복잡한 전환으로 창의적으로 구성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 슬라이드 전환의 예시입니다:\n\n```css\n/* styles.css */\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    height: 100vh;\n    transition: transform 0.5s ease, opacity 0.5s ease;\n}\n\n.hidden {\n    opacity: 0;\n    transform: translateX(-100%);\n}\n```\n\n또한 다양한 탐색 컨텍스트에 따른 다양한 종류의 전환을 처리하기 위해 더 복잡한 JavaScript를 추가할 수도 있습니다.\n\n더 많은 정보를 위해 이 웹사이트도 확인해보세요: [https://developer.chrome.com/docs/web-platform/view-transitions/cross-document](https://developer.chrome.com/docs/web-platform/view-transitions/cross-document)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최종 인사\n\n문서 간 보기 전환이란 기능은 멀티페이지 애플리케이션의 사용자 경험을 향상시키는 강력한 기능입니다.\n\n페이지간 부드럽고 일관된 전환을 구현함으로써, 웹 애플리케이션을 더 현대적이고 반응성있게 느끼게 할 수 있습니다.\n\n서로 다른 종류의 전환을 실험하여 애플리케이션 디자인과 사용자 경험 목표에 가장 적합한 것을 찾아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행운을 빕니다!","ogImage":{"url":"/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png"},"coverImage":"/assets/img/2024-05-27-Next-levelUserExperienceWithCross-documentViewTransitions_0.png","tag":["Tech"],"readingTime":5},{"title":"웹사이트를 TailwindCSS로 만들어야하는 이유 ","description":"","date":"2024-05-27 19:04","slug":"2024-05-27-Tailwindischangingthelandscapeofuserexperience","content":"\n\n다르실 자댭, Think In Bytes의 풀스택 엔지니어가 말하길, Tailwind는 개발자들 사이에서 널리 사용되어 동적이고 매력적이며 견고한 프런트엔드 애플리케이션을 구축하는 데 인기를 끌고 있다.\n\n![이미지](/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png)\n\n## 소개\n\nThink In Bytes에서는 Tailwind CSS를 사용하여 고객을 위한 동적이고 인터랙티브한 웹 인터페이스를 만들기 시작했습니다. 이 블로그는 Tailwind가 웹 개발을 혁신하고 있는 방식에 대해 탐구하며, 이에 대한 모든 기본적인 질문에 대답하고 여러분의 팀 또는 프로젝트에 적합한지 결정하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 조직은 주로 Next.js를 사용하여 제품을 개발하는데, 이는 Tailwind와 시원하게 통합됩니다. 이를 통해 우리는 프로젝트 전반에 걸쳐 Tailwind를 널리 사용할 수 있게 되었습니다. 그러나 이는 Next.js에만 국한된 것이 아닙니다; 우리는 Angular 및 React 앱에도 성공적으로 통합시켰습니다. 이 다양성은 Tailwind의 유연성을 보여줍니다. 한 번 마스터하면 거의 모든 프레임워크에 구현할 수 있습니다. 이 프레임워크에 대해 더 알고 싶다면, Tailwind가 빛나게 만드는 것에 대해 자세히 알아보겠습니다.\n\n## Tailwind란?\n\nTailwind는 전통적인 방법보다 더 빠르게 웹 사이트를 스타일링하는 데 도움이 되는 현대적인 CSS 프레임워크입니다. 부트스트랩과 비슷하게, Tailwind는 인라인 스타일처럼 보이는 사전 구축 클래스를 제공하지만 실제로는 인라인 스타일이 아닙니다.\n\nTailwind는 반응형 디자인을 크게 향상시키는 모바일 우선 접근 방식을 채택했습니다. 이는 CSS를 더 빠르고 효율적이며 더 깨끗하게 작성하는 것을 단순화합니다. 예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Hello world!\n\nIn this snippet, we use three classes:\n\n- text-3xl: sets the font size to 3xl.\n- font-bold: makes the text bold.\n- underline: adds an underline.\n\nThis is more straightforward than traditional CSS, where you need to define and name each class, adding extra steps to the process. Tailwind strikes a balance between the customization of vanilla CSS and the speed of frameworks like Bootstrap.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![테일윈드 로고](/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_1.png)\n\n## 왜 테일윈드를 사용해야 할까요?\n\n- 개발 속도 향상: 테일윈드를 사용하여 프로젝트 일정을 크게 단축했습니다. 개발자들이 쉽게 습득할 수 있어 CSS와 HTML 사이의 격차를 줄이고 꾸준한 소통 필요성을 제거했습니다.\n- 독특한 디자인: 종종 비슷해 보이는 부트스트랩 기반 사이트와는 달리, 테일윈드는 고유하고 맞춤형 디자인을 가능하게 하여 귀하의 웹사이트를 돋보이게 만들어줍니다.\n- 고급 기능: 테일윈드에는 호버 상태, 비활성 상태 및 다크 모드와 같은 클래스가 포함되어 있어 사용자 선호도에 자동으로 적응할 수 있습니다. 예를 들어 사용자가 다크 모드로 기기를 전환하는 경우가 있습니다.\n\n아래는 다크 모드를 고려한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cdiv class=\"bg-white dark:bg-slate-800 rounded-lg px-6 py-8 ring-1\"\u003e\n  \u003cdiv\u003etest\u003c/div\u003e\n  \u003ch3 class=\"text-slate-900 dark:text-white\"\u003esome text\u003c/h3\u003e\n\u003c/div\u003e\n\n\n\n\u003c!-- dark:text-white will be applied to dark mode only, for light mode it will take \ntext-slate-900 --\u003e\n\n\n- Enhanced Workflow: Tailwind를 사용하기 전에 일반 CSS에 의존했던 개발자로서, 저는 Tailwind가 효율성을 20~30% 향상시켰다는 사실을 발견했습니다. 반응형 디자인을 간소화하여 최근 Angular과 Tailwind를 사용하여 개발한 학교 정적 웹사이트 프로젝트 등에 도움이 되었습니다.\n\nTailwind 사용 방법\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설치 지침은 다음을 방문하십시오: Tailwind CSS 설치\n\n자바스크립트 프레임워크에서 Tailwind는 tailwind.config.js에서 글로벌 스타일을 정의할 수 있도록 해주며, 다음과 같은 클래스를 사용하여 반응형 디자인을 최적화할 수 있습니다:\n\n```js\n\u003cimg class=\"w-16 md:w-32 lg:w-48\" src=\"...\"\u003e\n```\n\n이 모바일 우선 접근 방식은 디바이스 크기에 따라 적절한 스타일이 적용되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테일윈드 사용 시기\n\n- 경험이 풍부한 CSS 사용자에게: CSS에 대한 견고한 이해가 있는 경우 테일윈드는 생산성을 향상시킬 수 있습니다.\n- 중대형 프로젝트에 적합: 개발 속도가 중요한 큰 규모의 프로젝트에는 특히 효과적입니다.\n- Next.js를 사용할 때: Next.js는 테일윈드를 내장 지원하므로 설정이 매우 간편합니다.\n\n테일윈드 사용하지 말아야 할 때\n\n- CSS 초보자에게: CSS에 익숙하지 않다면 테일윈드로 시작하는 것이 어려울 수 있습니다.\n- 매우 사용자 정의된 디자인에: 프로젝트가 복잡한 애니메이션이나 독특한 효과를 요구하는 경우 전통적인 CSS가 더 적합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테일윈드의 장단점\n\n장점:\n\n- 시간을 절약하고 노력을 줄입니다.\n- 부트스트랩보다 더 많은 유연성을 제공합니다.\n- 개발자 커뮤니티 내에서 강력한 지원을 제공합니다.\n- 모바일 우선 접근 방식을 채택하여 인터넷 사용량이 모바일 기기로 이동함에 중요합니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡한 디자인에 대해 베니야 CSS보다는 덜 유연합니다.\n- 설정 및 구성 중에 특히 초보자에게 압도적일 수 있습니다.\n\n테일윈드의 미래\n\n테일윈드는 매일 더 많은 개발자가 채택하면서 인기를 누리고 있습니다. Next.js와 같은 플랫폼에 통합되면 사용량이 더욱 증가할 것으로 예상됩니다. 테일윈드를 사용하는 주목할만한 기업으로는 OpenAI, Netlify, Shopify, Vercel, 1Password, Brave 등이 있으며, 기술 산업에서의 영향력이 계속 성장하고 있음을 강조합니다.\n\n블로그 크레딧: Think In Bytes의 Fullstack 개발자 Darshil Jadav.","ogImage":{"url":"/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png"},"coverImage":"/assets/img/2024-05-27-Tailwindischangingthelandscapeofuserexperience_0.png","tag":["Tech"],"readingTime":4},{"title":"프론트엔드 주간 뉴스 - 2024년 5월 20일","description":"","date":"2024-05-27 19:03","slug":"2024-05-27-FrontendWeeklyDigest3642026May2024","content":"\n\n\n![Web-development](/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png)\n\n- Web-development\n\n  - Switching It Up With HTML’s Latest Control\n  - How Spotify used the Picture-in-Picture API to build the Spotify Miniplayer\n  - When should we use components and when should we just use HTML?\n  - Understand errors and warnings better with Gemini\n  - Animating the Dialog Element\n\n- Performance\n  - Visualize Your Website’s Render-Blocking Scripts\n  - Quantifying the Impact of Styled Components on Server Response Times\n  - How Do Chrome Extensions Impact Website Performance In 2024?\n  - Comprehensive guide to JavaScript performance analysis using Chrome DevTools\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CSS\n\n- Pigment CSS 소개: CSS-in-JS의 차세대\n- 현대적인 CSS 레이아웃: 프레임워크가 필요하지 않을 수도 있습니다\n- 적합성 대 가독성: CSS로 텍스트 색상 생성하기\n- 우리는 이제 컨테이너 쿼리를 가지고 있지만, 실제로 사용하고 있을까요?\n- contrast-color()은 좋은 것입니다만, 잘못된 레이어에서 문제를 해결하고 있기도 합니다\n- 헤드라인에 text-emphasis CSS 속성을 사용해야 할까요?\n- Bulma CSS 도입 안내: 개요, 예시 및 대안\n- Velvette로 CSS 뷰 전환을 더욱 향상시키세요\n\n# JavaScript\n\n- JavaScript 프레임워크의 새로운 소식 (2024년 5월)\n- 최신 JavaScript 기술 5가지\n- 웹소켓 대안: Firestore를 사용하여 실시간 이벤트를 듣는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- React\n  - React Conf 2024 Recap\n  - React Conf 2024 Highlights\n  - Auto Generate Open Graph Images in NextJS\n  - How to Style React Components\n  - Restyle — Zero Config CSS for React\n  - React Compiler With React 18\n  - Merging Remix and React Router\n  - Using Mountaineer to develop a React app with Python\n- Vue\n  - Building Real-Time Applications with Vue.js and WebSockets\n  - Building CatGPT: A Vue 3 and Vuetify Guide for Cat Image Lovers\n- Angular\n  - Angular v18 is now available!\n  - Saying Goodbye to Zone.js: What’s New in Angular 18?\n  - Updating to Angular Material 18: Keeping Support for Material 2 and Adding Support for Material 3\n  - Debugging techniques — Angular DevTools\n  - Debugging techniques — Chrome DevTools\n  - Angular Tutorial: Using @HostBinding with Signals","ogImage":{"url":"/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png"},"coverImage":"/assets/img/2024-05-27-FrontendWeeklyDigest3642026May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"앵귤러에서 마이크로 프론트엔드 애플리케이션 만드는 방법","description":"","date":"2024-05-27 19:02","slug":"2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png\" /\u003e\n\n# 안내 내용\n\n이 안내서에서 다룰 내용은 다음과 같습니다:\n\n- Angular에서 Micro-Frontend 애플리케이션 소개\n- Angular에서 간단한 호스트 및 Micro-Frontend 애플리케이션 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소개\n\n크고 화려한 생일 파티를 준비한다고 상상해보세요. 엄청나게 큰 케이크를 굽고, 장식을 꾸미고, 게임을 설치하고, 음식을 준비해야 합니다. 이 모든 것을 혼자 다 처리하려고 하면 압도될 수 있습니다. 하지만 친구들에게 작업을 분담할 수 있다면 어떨까요? 한 명은 케이크를 굽고, 다른 한 명은 장식을 하고, 또 다른 한 명은 게임을 설치하고, 한 명은 음식을 책임지죠. 모두가 독립적으로 일하지만 모여서 멋진 파티를 만들어냅니다.\n\n웹 애플리케이션이 커지고 복잡해지면 단일 대규모 코드베이스를 유지하는 것이 어려워질 수 있습니다. 이러한 문제를 해결하기 위해 마이크로 프론트엔드와 모듈 연합이라는 개념이 소개되었습니다. 이러한 개념을 활용하면 개발자들이 모듈식, 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 만들 수 있습니다. 이 기사에서는 마이크로 프론트엔드의 기본 개념, Webpack 5의 기능, 그리고 Angular 프로젝트에서 모듈 연합을 구현하는 방법에 대해 자세히 살펴보겠습니다.\n\n# 마이크로 프론트엔드란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마이크로 프론트엔드 아키텍처를 생각해보면 번화한 쇼핑몰의 푸드코트와 비슷합니다. 각 음식점(마이크로 프론트엔드)은 독립적으로 운영되어 독특한 요리를 제공합니다. 피자 전문점, 스시 전문점, 햄버거 전문점 등이 있습니다. 각 음식점은 독립적으로 관리되고 운영되며 재고가 구비되지만, 함께하면 쇼핑몰 방문객들에게 즐거운 다이닝 경험을 선사합니다.\n\n마이크로 프론트엔드는 이 개념을 웹 애플리케이션에 적용한 것입니다. 큰 웹 애플리케이션을 더 작고, 준 독립적인 \"마이크로\" 애플리케이션으로 분할합니다. 각 마이크로 프론트엔드는 별도로 개발, 배포, 유지보수할 수 있습니다. 이 접근 방식을 통해 서로 다른 팀이 서로 다른 프론트엔드 부분에 작업을 할 수 있으며, 서로 간섭하지 않게 되어 확장성, 유지보수성이 향상되며 동일한 애플리케이션 내에서 다른 기술을 사용할 수 있습니다.\n\n# 웹팩 5이란?\n\n캠핑용품을 준비하는 것과 같습니다. 텐트, 음식, 옷, 캠핑 장비가 필요합니다. 이 모든 것을 하나의 큰 가방에 랜덤하게 넣는 대신, 특정 카테고리에 지정된 여러 작은 가방을 사용합니다. 이렇게 하면 물건을 싸고, 찾고, 사용하는 것이 훨씬 쉽고 효율적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩 5은 자바스크립트 애플리케이션을 위한 궁극적인 패킹 시스템 같아요. 자바스크립트 파일, 스타일, 이미지, 그리고 다른 에셋들을 효율적으로 정리하고 패킹하는 모듈 번들러에요. 아래는 웹팩 5의 주요 기능들이에요:\n\n- 모듈 연맹: 다른 캠퍼들 사이에서 공급을 공유하는 것처럼, 모듈 연맹은 여러 웹팩 빌드가 함께 작동하도록 하여, 애플리케이션 간의 코드 공유를 가능하게 함.\n- 개선된 캐싱: 미래의 패킹을 빠르게 만들어주는, 잊지 않게 해주는 매우 체계적인 체크리스트와 같은 것으로 생각해봐요.\n- Tree Shaking: 가방에서 불필요한 물건을 제거하여 가벼우고 효율적으로 만드는 것과 같아요.\n- 에셋 모듈: 에셋 파일(예: 이미지와 폰트)을 다루기 쉽게 해주어 모든 것이 제 위치에 있도록 해요.\n- 웹 어셈블리 지원: WebAssembly에 대한 향상된 지원으로, 여러 가지 고급 캠핑 가전들을 위한 특별한 칸나 있는 것처럼 생각해봐요.\n\n# 독립형 컴포넌트란 무엇인가요?\n\n레고 블럭을 사용해 건물을 지을 때, 각각의 레고 블럭은 독립적인 부분으로, 독립적으로 사용하거나 다른 블럭들과 결합하여 더 큰 것을 만들 수 있어요. 각 블럭이 어느 세트에서 왔는지 고민할 필요는 없어요; 어디에 놓든 그대로 작동해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 독립형 컴포넌트는 다양하고 다재다능한 레고 블록과 같습니다. 이들은 특정 NgModule에 바인딩되지 않은 Angular 컴포넌트로, NgModule 선언 내에서 명시적으로 가져오기 및 내보내기가 필요 없이 응용 프로그램의 여러 부분에서 사용할 수 있습니다.\n\n- 높은 재사용성: 레고 블록처럼 독립형 컴포넌트는 서로 다른 모듈 및 프로젝트에서 사용할 수 있습니다.\n- 관계 단순화: 복잡한 가져오기/내보내기 관계가 제거되어 컴포넌트 계층 구조가 단순화됩니다.\n- 지연 로드 모듈과 함께 작동: 독립형 컴포넌트는 지연 로드된 모듈과 원활하게 통합됩니다.\n- 제3자 라이브러리 통합: NgModule 선언을 수정하지 않고 제3자 라이브러리와 함께 사용할 수 있습니다.\n- 복잡성 감소: 의존성 관리가 쉬워지며, 마치 레고 모형을 조직하는 것과 같습니다.\n- 더 깔끔한 코드 분리 유도: 코드베이스가 깔끔하고 모듈식으로 유지되어, 마치 레고 모형의 구분된 섹션을 구성하는 것과 같습니다.\n- 더 이동 가능: 독립형 컴포넌트는 이동, 리팩토링 또는 이주가 쉽습니다. 마치 레고 조각을 재배열하는 것과 같습니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩되세요! :)\n\n# 관련 링크:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 1**  \n- **Angular에서 모듈 연합 및 마이크로 프론트엔드 애플리케이션 가이드 - 파트 2**  ","ogImage":{"url":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png"},"coverImage":"/assets/img/2024-05-27-AGuidetoModuleFederationandMicro-FrontendApplicationsinAngularPart1_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러 신호 컴포넌트 입력을 위한 새로운 시대","description":"","date":"2024-05-27 19:00","slug":"2024-05-27-AngularSignalsANewEraforComponentInputs","content":"\n\n## 안녕하세요 👋\n\n이 문서는 시그널에 사용되는 새로운 입력 API에 대해 소개하고 있습니다. 시그널을 사용하여 Angular 앱 내에서 통신을 활성화하기 위해 사용되는 모든 새로운 API에 대해 이미 다뤘습니다. 아래에는 Angular 앱 내에서 시그널을 사용하여 통신하는 새로운 방법에 대해 더 자세히 알아볼 수 있는 구체적인 예제가 있습니다:\n\n이전에 언급했듯이, 이 문서는 특히 새로운 입력 API에 대한 간략한 개요를 제공하는 데 초점을 맞추고 있습니다.\n\n기존 Angular은 컴포넌트 입력을 처리하기 위해 setter나 ngOnChanges를 사용합니다. 이러한 방법은 작동하지만 명령형 스타일에 의존합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n➡️ 신호 입력:\n\n- 신호 입력은 구성 요소 입력을 관리하는 선언적인 방법을 제공합니다.\n- 입력 값이 변경될 때 Angular에게 통지함으로써 반응적인 접근 방식을 제공합니다.\n- 이를 통해 더 세밀한 변경 감지와 효율적인 업데이트가 가능해집니다.\n\n➕ 신호 입력의 장점:\n\n- 성능 향상: 변경 감지가 최적화되어 불필요한 다시 렌더링을 최소화하며, Angular 앱의 존리스 이동에 중요한 역할을 합니다.\n- 단순화된 코드: 코드가 더 깨끗하고 이해하기 쉬워집니다.\n- 증진된 반응성: 신호는 계산 및 효과와 같은 Angular의 반응적 기능과 원활하게 통합됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🗝️ 중요한 개념:\n\n- input: 입력 속성을 위한 신호를 생성합니다 (예시).\n- computed: 기존 신호로부터 새 값을 파생합니다 (예시).\n- effects: 신호 변경으로 인해 트리거된 부작용을 실행합니다 (더 자세한 내용은 여기에서 찾을 수 있습니다).\n\n```js\n...\nexport class AComponent {\n  \n  anInput = input.required\u003cnumber\u003e();\n      \n  constructor(){\n    // ⚠️ 주입 환경에서 호출되어야 합니다\n    effect(() =\u003e console.log(this.anInput());\n  }\n\n...\n}\n```\n\n- 선택적 및 필수 입력: 신호는 초기값과 함께 선택적이거나 필수로 지정할 수 있습니다 (예시).\n- 입력 변환: 입력 신호는 입력 값의 의미를 변경하지 않고 강제 혹은 구문 분석이 필요할 때 변환될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\nexport class AComponent {\n\n  disabled = input(false, {\n    transform: (value: boolean|string) =\u003e typeof value === 'string' ? value === '' : value,\n  });\n\n}\n\n// In consumer cmp\n\u003ca-cmp disabled /\u003e\n```\n\n- Input Aliasing: 신호를 사용하면 입력 속성에 별칭을 지정할 수 있습니다. (자세한 내용은 여기에서 찾을 수 있습니다)\n\n```js\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `...`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AComponent {\n  \n  aName= input.required\u003cstring\u003e({alias: 'aliasName'});\n...\n}\n\n// a-cmp 소비자\n\u003ca-cmp [aliasName]=\"'a name'\" /\u003e\n```\n\n🎬 신호 입력을 실행하는 중:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시그널로 라우트 파라미터에 액세스: 라우터에 withComponentInputBinding 옵션을 활성화하여 반응형 시그널로 라우트 파라미터에 액세스할 수 있습니다.\n\n```js\n// 1 - 앱 구성 파일( AppModule에서도 제공할 수 있음)\nexport const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes, withComponentInputBinding())]\n};\n\n// 2 - 라우트 내부\nconst routes: Routes = [\n  {\n    title: 'Route X',\n    path: 'route-x/:id',\n    component: AComponent\n  },\n  ...\n]\n\n// 3 - AComponent 내부\nid = input\u003cstring\u003e(); // 👈 이제는 라우트 파라미터에서 id 값을 추출할 필요가 없습니다\n```\n\n- 시그널로 데이터 가져오기: 시그널을 사용하여 서비스에서 데이터를 가져올 수 있습니다.\n\n```js\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `{ data() }`,\n})\nexport default class AComponent {\n  private readonly aService = inject(AService);\n\n  id = input.required\u003cstring\u003e();\n  \n  /*💡toSignal로 생성된 구독은 toSignal을 호출하는 컴포넌트 또는 서비스가 제거될 때 주어진 Observable에서 자동으로 구독을 해제합니다.*/\n  data = toSignal(this.aService.getData(i), {initialValue: []}); // 👈 toSignal 사용 예시\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡한 시나리오: toSignal이 강력하긴 하지만, Observables를 사용해야 하는 특정 상황이 있습니다. 이는 주로 RxJS 연산자를 활용하여 데이터를 보다 효과적으로 처리하는 데 도움이 되기 때문입니다. 이를 위해 필요한 모든 프로세스를 처리하고 데이터를 신호로 쉽게 추적할 수 있는 스트림을 생성하는 toObservable 유틸리티를 사용할 수 있습니다. 다음 예시는 id 입력이 변경될 때마다 가장 최신의 새로운 id를 기반으로 즉시 getData으로 전환하고 싶을 때 간단한 케이스를 제공합니다.\n\n```js\n...\n@Component({\n  standalone: true,\n  selector: 'a-cmp',\n  template: `{ data() }`,\n})\nexport default class AComponent {\n  private readonly aService = inject(AService);\n\n  id = input.required\u003cstring\u003e();\n\n  /* id 신호가 변경될 때, toObservable(this.id)는 가장 최신의 id를 발행하고 서비스의 getData(id) 함수를 트리거합니다. */\n  data = toSignal(\n      toObservable(this.id) // 👈 toObservable 사용\n        .pipe(\n          switchMap((i) =\u003e this.aService.getData(i))\n        )\n      );\n}\n```\n\n🎯 신호 입력 이상:\n\n이 새로운 API는 Angular 애플리케이션의 반응성과 효율성을 향상시키는 데 중요한 역할을 합니다. 이것들은 더 간단하고 반응적인 컴포넌트 디자인을 생성할 수 있게 해주며, zoneless 애플리케이션을 구축하는 데 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 목표는 미래에 존리스(Zoneless) 모드의 보급을 촉진하는 것입니다. 특히, 이 기능을 지원하는 실험적 API는 이미 Angular의 최신 버전(현재 버전 17)에서 사용할 수 있습니다(첫머리에서 언급된 글을 참조하세요).\n\n여기까지가 이 기사의 내용입니다. 마음에 드셨으면 좋겣어요. 만약 이 형식을 좋아하시고 이와 유사한 간결하고 명료한 기사를 더 원하신다면 알려주세요.\n\n오늘은 여기까지, 안녕🙋\n\n질문이나 피드백이 있으면 댓글을 남기거나 LinkedIn을 통해 저에게 연락해주세요 — 기다리고 있겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부지런히 커피 한 잔 사 줄래요? ☕️\n\n만약 제 글을 좋아하셨다면 👏, 공유 🔗, 그리고 최신 글을 받기 위해 구독 🔔 해주세요.\n\n저와 소통하고 싶다면 Medium, Linkedin, Facebook, Instagram, YouTube, 또는 Twitter에서 연락해 주세요.\n\n# 쉬운 용어로 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 박수치고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-27-AngularSignalsANewEraforComponentInputs_0.png"},"coverImage":"/assets/img/2024-05-27-AngularSignalsANewEraforComponentInputs_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular v18 성능 향상 및 개발자 경험 향상","description":"","date":"2024-05-27 19:00","slug":"2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png\" /\u003e\n\n# Angular v18: 성능 향상 및 개발 경험 향상\n\n안녕하세요, Angular 개발자 여러분! 기다리시던 순간이 왔습니다. Angular v18이 공식적으로 출시되었으며, 여러분의 개발 경험을 향상시키기 위해 설계된 다양한 흥미로운 기능과 개선 사항을 가져왔습니다. 몇 가지 주요 기능을 살펴보겠습니다:\n\n1. Zoneless Change Detection (실험적): Angular v18은 zoneless change detection을 실험적으로 지원합니다. 이 혁신적인 접근 방식은 Angular이 컴포넌트 내에서 변경 사항을 감지하는 방식을 최적화하여 응용 프로그램 성능을 혁신적으로 개선할 수 있습니다. 아직 실험 단계이지만, Angular의 성능 최적화의 미래를 엿볼 수 있는 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Angular.dev: Your New Developer Hub: Angular 개발자를 위한 공식 홈인 Angular.dev로 옮겼습니다. 이 간소화된 플랫폼은 깊이 있는 가이드와 자습서부터 최신 뉴스와 업데이트까지 모든 Angular 요구 사항에 대한 중앙 집중지를 제공합니다.\n\n3. Stable Material 3 and More: Material 3, deferrable views 및 내장 제어 흐름이 모두 v18에서 안정적인 상태로 졸업했습니다. 이는 이러한 기능을 확신을 갖고 활용할 수 있음을 의미하며, 그들이 철저히 테스트되고 제품으로 출시 준비가 되어 있음을 알 수 있습니다. 또한 v18은 개발자 경험과 사용성을 향상시키기 위한 다양한 개선 사항을 포함하고 있습니다.\n\n4. Server-Side Rendering Boost: 서버 측 렌더링(SSR)을 사용하는 개발자들을 위해 v18에서 다양한 개선 사항이 제공됩니다. 이에는 i18n 수분화 지원, 향상된 디버깅 기능, 그리고 Angular Material 내의 수분화 지원이 포함됩니다. 또한, Google Search를 구동하는 동일한 라이브러리가 제공하는 이벤트 리플레이 기능이 이제 사용 가능해져 원활한 사용자 상호작용이 가능해졌습니다.\n\n5. Stay Ahead of the Curve: Angular v18을 사용하면 항상 진화하고 경계를 넓히는 프레임워크에 접근할 수 있습니다. v18로 업그레이드하면 최신 개발 사항과 최고의 실천법을 갖춤으로써 여러분의 애플리케이션을 웹 개발 분야의 선두에 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업그레이드하고 탐험하기:\n\nAngular v18로 업그레이드하는 것은 매우 쉽습니다. Angular 팀은 원활한 전환을 보장하기 위해 포괄적인 이주 안내서를 제공했습니다. 당신이 경험且 개발자이든, Angular을 처음 시작한 사용자이든, v18은 개발 워크플로우를 향상시키고 고성능 웹 애플리케이션을 개발하는 매력적인 기회를 제공합니다.\n\n그러니 무엇을 기다리고 있나요? Angular v18로 뛰어들어 기대가 되는 새로운 기능을 탐험해보세요! 자세한 정보 및 심층 가이드는 공식 Angular 블로그 포스트를 참조하세요.","ogImage":{"url":"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png"},"coverImage":"/assets/img/2024-05-27-Angularv18APerformanceBoostandDeveloperExperienceEnhancer_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular의 경로 리다이렉션 로직을 개선하는 방법 RedirectFunction 소개","description":"","date":"2024-05-27 18:59","slug":"2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png\" /\u003e\n\n최근 업데이트에서 Angular는 RedirectFunction을 통해 유연한 경로 리다이렉션 접근 방식을 소개하여 라우팅 기능을 크게 개선했습니다. 이 새로운 기능을 통해 개발자는 문자열이나 UrlTree를 반환할 수 있는 함수를 사용하여 리디렉션을 정의할 수 있어 라우팅 로직에서 향상된 제어와 다양성을 제공합니다.\n\n# RedirectFunction 이해하기\n\nAngular에서의 전통적인 접근 방식은 Route.redirectTo 속성 내에서 직접 문자열 경로를 지정하는 것이었습니다. 효과적이지만, 이 방법은 특히 라우트 매개변수와 데이터를 기반으로 동적으로 리디렉션 경로를 생성하는 능력에서 한계가 있었습니다. 새로운 RedirectFunction은 이러한 제한을 극복하여 함수가 리디렉트 대상을 결정할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리다이렉트 기능의 주요 특징:\n\n- 동적 리다이렉트: 이 기능은 이전의 정적 리다이렉트와 유사하게 문자열을 반환하거나 더 복잡하고 절대적인 리다이렉트를 가능하게 하는 UrlTree를 반환할 수 있습니다.\n- 라우트 파라미터 및 데이터에 접근: 이전 방법과 달리, 개발자는 현재 라우트에서만 파라미터와 데이터에 액세스할 수 있었지만 RedirectFunction을 사용하면 일치하는 부모 라우트에서 파라미터와 데이터에 액세스할 수 있습니다. 이는 라우트 매칭 과정 중에 파라미터 및 데이터를 집계함으로써 달성됩니다.\n- 개선된 컨텍스트 인식: 매치 중에 params와 데이터를 상속받음으로써 함수는 보다 광범위한 컨텍스트를 활용하여 더 더욱 정보에 기반한 리다이렉션 결정을 내릴 수 있습니다.\n\n# 제약 사항 및 고려 사항:\n\n- RedirectFunction은 전체 ActivatedRouteSnapshot 인터페이스를 제공하지 않습니다. 해결된 제목이나 레이지로드된 컴포넌트와 같은 특정 속성들은 라우트 매칭 단계에서 사용할 수 없습니다. 사용 가능한 속성은 다음과 같습니다: routeConfig, url, params, queryParams, fragment, data, outlet, title.\n- 전체 라우트 트리에 의존하는 속성(예: root, parent, pathFromRoot, firstChild, children)은 아직 전체 라우트 매칭이 이루어지지 않았기 때문에 제외됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실용적인 예시\n\n검색 쿼리 매개변수에 기반하여 사용자를 리디렉션해야 하는 시나리오를 고려해보세요. 새로운 RedirectFunction을 사용하면 이를 매끄럽게 구현할 수 있습니다:\n\n```js\nexport const routes: Routes = [\n  {\n    path: 'search',\n  redirectTo: ({ queryParams }) =\u003e {\n    const router = inject(Router);\n    const searchQuery = queryParams['q'];\n\n    return searchQuery\n      // UrlTree 반환\n      ? router.createUrlTree(['/results'], {\n          queryParams: { q: searchQuery },\n        })\n     // 또는 문자열\n      : 'home';\n  },\n},\n{\n  path: 'results',\n  component: ResultsComponent,\n},\n{\n  path: 'home',\n  component: HomeComponent,\n},\n];\n```\n\n이 예시에서 redirectTo 함수는 검색 쿼리 매개변수가 있는 경우 동적으로 사용자를 리디렉션하는 UrlTree를 생성합니다. 검색 쿼리가 있는 경우 쿼리 매개변수를 포함하여 결과 페이지로 리디렉션하고, 없는 경우 홈 페이지로 리디렉션합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nAngular의 RedirectFunction 소개는 프레임워크의 라우팅 기능을 크게 향상시킨 것으로 평가됩니다. 이 업데이트는 라우트 컨텍스트에 더 많은 유연성과 접근성을 제공하여, 개발자들이 더 동적이고 컨텍스트에 민감한 리디렉션을 만들 수 있게 해주며, 결과적으로 Angular 애플리케이션의 전반적인 사용자 경험을 향상시킵니다.\n\nAngular와 JS에 대해 더 많은 내용을 읽으려면 Medium나 Twitter에서 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png"},"coverImage":"/assets/img/2024-05-27-EnhancingAngularsRouteRedirectionLogicIntroducingRedirectFunction_0.png","tag":["Tech"],"readingTime":3}],"page":"57","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"57"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>