<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" href="/post/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" href="/post/2024-05-12-HowToUseApexChartsinaNextjsProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 프로젝트에서 ApexCharts를 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 프로젝트에서 ApexCharts를 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트와 리덕스 툴킷으로 할 일 앱 만들기" href="/post/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트와 리덕스 툴킷으로 할 일 앱 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트와 리덕스 툴킷으로 할 일 앱 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트와 리덕스 툴킷으로 할 일 앱 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" href="/post/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" href="/post/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Router의 useParams 훅을 적용하는 실용적인 단계" href="/post/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Router의 useParams 훅을 적용하는 실용적인 단계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Router의 useParams 훅을 적용하는 실용적인 단계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Router의 useParams 훅을 적용하는 실용적인 단계</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS란 무엇인가요 왜 사용하나요" href="/post/2024-05-12-WHATISREACTJSWHYWEUSEIT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS란 무엇인가요 왜 사용하나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS란 무엇인가요 왜 사용하나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS란 무엇인가요 왜 사용하나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다" href="/post/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WP Bones 140 출시 완료" href="/post/2024-05-12-WPBones140isout"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WP Bones 140 출시 완료" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WPBones140isout_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WP Bones 140 출시 완료" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">WP Bones 140 출시 완료</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 REST API 인터셉터 사용하기" href="/post/2024-05-12-RESTAPIInterceptorsinReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 REST API 인터셉터 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 REST API 인터셉터 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 REST API 인터셉터 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link posts_-active__YVJEi" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"CI CD 마스터하기 GitHub Actions로 React 앱을 AWS S3에 배포하고 호스팅하기","description":"","date":"2024-05-12 22:12","slug":"2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt","content":"\n\n## AWS S3를 사용하여 GitHub Actions로 React.js 앱을 배포하고 호스팅하는 포괄적인 가이드\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png)\n\nAWS S3와 GitHub Actions의 강력함을 느껴보세요. 이 포괄적인 가이드는 GitHub Actions를 사용하여 AWS S3에 React.js 앱을 배포하고 호스팅하는 간소화된 과정을 안내합니다. 워크플로우를 간소화하고 확장성을 확보하여 사용자에게 탁월한 경험을 제공하세요. AWS S3 및 GitHub Actions의 잠재력을 펼쳐보세요!\n\n# 목표:\n\n\n\n- React.js 애플리케이션의 배포 프로세스를 간단하게 만들어보세요.\n- GitHub Actions를 활용하여 배포 파이프라인을 자동화하세요.\n- AWS S3를 사용하여 React.js 앱을 확장 가능하게 호스팅하세요.\n- 신뢰할 수 있는 배포를 통해 사용자에게 뛰어난 경험을 제공하세요.\n- 효율적인 배포와 호스팅을 위한 지식과 도구로 개발자를 지원하세요.\n\n# 요구 사항 :\n\n- React.js에 대한 기본적인 이해\n- GitHub 계정으로 저장소 호스팅 및 GitHub Actions 사용\n- AWS S3 계정으로 React.js 애플리케이션 호스팅\n- GitHub 및 AWS S3에 대한 액세스 및 권한\n- YAML 설정에 익숙함\n- 명령 줄 인터페이스(CLI) 능숙함\n\n# 따라 할 단계:\n\n\n\n- IAM 사용자를 생성하고 AmazonS3FullAccess 정책을 연결하세요.\n- 비밀 액세스 키의 .csv 파일을 다운로드하세요.\n- S3 버킷을 생성하세요: ACL을 활성화하고 모든 공개 액세스 차단 옵션을 해제하세요.\n- GitHub으로 이동하여 공개 저장소를 만드세요.\n- 설정으로 이동하여 시크릿을 클릭하세요.\n- 다음을 저장할 새로운 리포지토리 시크릿 생성: 액세스 키 ID(AWS_ACCESS_KEY_ID), 비밀 액세스 키(AWS_SECRET_ACCESS_KEY) 및 버킷 이름(AWS_S3_BUCKET).\n- React 애플리케이션을 만들고 GitHub 워크플로우를 추가하세요.\n- GitHub에 푸시하세요.\n- 작업 섹션으로 이동하여 애플리케이션 빌드부터 S3로 업로드까지의 모든 단계를 확인하세요.\n- S3의 정적 파일 호스팅을 활성화하고 호스팅된 웹 앱을 볼 수 있는 엔드포인트를 열어보세요.\n\n## 단계 1: IAM 사용자 생성\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_1.png)\n\n![이미지 제목](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_2.png)\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_3.png\" /\u003e\n\n## 단계 2: 새로 생성된 사용자의 보안 자격 증명 섹션에서 액세스 키 생성\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_4.png\" /\u003e\n\n## 단계 3: S3 버킷 만들기\n\n\n\n버킷에 이름을 지어주시고 ACL을 활성화해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_5.png\" /\u003e\n\n모든 공개 액세스 차단 해제를 선택 해제하고 경고를 읽은 후에 선택하세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_6.png\" /\u003e\n\n\n\n위의 표를 Markdown 형식으로 변경해주세요.\n\n\n\n## 5단계: 레포지토리의 설정으로 이동하여 왼쪽 섹션에서 시크릿을 선택합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_8.png)\n\n## 6단계: 새로운 레포지토리 시크릿을 클릭하고 모든 세부 정보를 추가합니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_9.png)\n\n\n\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_10.png)\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_11.png)\n\nAfter creating this, you can see like this\n\n![Image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_12.png)\n\n\n\n## 단계 7: React 앱을 만들고 GitHub Actions 워크플로우 추가하기\n\n```js\nnpx create-react-app react-gh-action-s3\n```\n\nReact 앱을 만든 후에, \".github\\workflows\" 라는 폴더를 하나 추가하고 새 파일을 만들어 \"main.yaml\"이라고 이름 짓습니다. 아래 코드를 main.yaml 파일에 복사하세요:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_13.png)\n```\n\n\n\n```yaml\nname: 웹사이트 업로드\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 코드 확인\n        uses: actions/checkout@v2\n\n      - name: Node.js 설정\n        uses: actions/setup-node@v2\n        with:\n          node-version: '14'\n\n      - name: 의존성 설치\n        run: npm install\n\n      - name: 앱 빌드\n        run: npm run build\n\n      - name: S3에 업로드\n        uses: jakejarvis/s3-sync-action@master\n        with:\n          args: --acl public-read\n        env:\n          SOURCE_DIR: build/\n          AWS_S3_BUCKET: ${ secrets.AWS_S3_BUCKET }\n          AWS_ACCESS_KEY_ID: ${ secrets.AWS_ACCESS_KEY_ID }\n          AWS_SECRET_ACCESS_KEY: ${ secrets.AWS_SECRET_ACCESS_KEY }\n```\n\n## 단계 8: GitHub에 추가하기\n\n\u003cimg src=\"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_14.png\" /\u003e\n\n## 단계 9: Action 섹션으로 이동하여 프로세스 보기하기\n\n\n\n코드를 업로드한 후 Action 섹션으로 이동하여 GitHub Actions가 코드를 빌드하고 S3로 업로드하는 과정을 확인해보세요. 처음에는 시간이 조금 걸릴 수 있지만 첫 번째 푸시 이후에는 변경 사항이 처음과 비교했을 때 적으므로 시간이 줄어들 것입니다.\n\n클릭한 후 최근 커밋을 볼 수 있습니다. 그리고 빌드를 클릭하세요. 진행 중인 모든 프로세스를 볼 수 있습니다. 모든 작업이 완료되면 다음을 볼 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_15.png)\n\n이것은 모든 프로세스가 완료되었고 빌드 파일이 aws에서 제공된 버킷 이름으로 업로드되었음을 의미합니다.\n\n\n\n## 단계 10: S3를 웹 호스팅으로 구성\n\nGitHub에서 업로드된 파일을 여기서 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_16.png)\n\n이제 프로퍼티 섹션으로 이동하여 맨 아래로 스크롤합니다. 정적 웹사이트 호스팅 옵션을 볼 수 있습니다. 편집을 클릭하고 활성화하고 index.html을 index 문서 섹션에 작성하십시오. 그런 다음 변경 사항을 저장하십시오.\n\n\n\n![Main image](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_17.png)\n\n이제 정적 웹사이트 호스팅 섹션에 링크가 보입니다. 새 탭에서 열어보세요.\n\n![Image 18](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_18.png)\n\n![Image 19](/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_19.png)\n\n\n\nReact 애플리케이션이 이제 실시간으로 작동 중이에요. 코드를 변경하고 GitHub에 푸시하면, 여기서 몇 초 내에 새로운 변경 사항이 보입니다.\n\n이 게시물을 읽어주셔서 감사합니다! AWS S3에서 GitHub Actions를 사용하여 React.js 애플리케이션을 배포하고 호스팅하는 여정에서 도움이 되었기를 바랍니다. 질문, 피드백 또는 제안이 있으시면 언제든지 연락해주세요. 여러분의 의견은 소중하고 큰 도움이 됩니다.\n\n## 추가 읽을거리:","ogImage":{"url":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringCICDDeployingaReactApptoAWSS3withGitHubActionsandHostingIt_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 프로젝트에서 ApexCharts를 사용하는 방법","description":"","date":"2024-05-12 22:10","slug":"2024-05-12-HowToUseApexChartsinaNextjsProject","content":"\n\n![이미지](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png)\n\nNext.js는 확실히 프런트엔드 랜드스케이프에서 주요 메타 프레임워크 중 하나입니다. 그러나 인기 있는 차트 라이브러리인 ApexCharts를 Next.js와 함께 사용할 때 특정 문제가 발생하는 것 같습니다. 이 글에서는 그 문제가 무엇인지와 해결 방법에 대해 논의하겠습니다.\n\n# 새 프로젝트를 초기화하는 방법을 살펴봅시다\n\n다음은 새 Next.js 프로젝트를 초기화하는 명령 프롬프트입니다(이미 초기화하는 방법을 잘 알고 계실 것 같지만, 문서를 열 필요 없이 편리하게 확인하실 수 있도록 제공드립니다)\n\n\n\n```js\n#npm\nnpx create-next-app@latest\n\n#pnpm\npnpm create next-app\n```\n\nApexCharts를 위한 필요한 의존성을 모두 설치하는 것을 잊지 마세요. 리액트 래퍼를 포함하면 됩니다.\n\n```js\n#npm\nnpm i react-apexcharts apexcharts\n\n#pnpm\npnpm i react-apexcharts apexcharts\n```\n\n우리는 기존의 신뢰받는 페이지와 새롭고 반짝이는 앱 디렉토리를 함께 사용할 것입니다. 두 가지의 구현 차이는 크지 않으니 시작해 봅시다.```\n\n\n\n두 가지 디렉토리 유형 중에서, 저는 개인적으로 폴더 구조를 이렇게 선호합니다 (특히 components 폴더 위치). 여러분은 자신의 구조 선호도에 맞게 조정하시면 됩니다.\n\n```js\nnextjs_project\n├── node_modules\n├── public\n└── src\n    ├── components\n    └── pages/app\n```\n\n# 그래프 컴포넌트 만들기\n\ncomponents 폴더 안에, charts.tsx/jsx 파일을 만들어 보겠습니다.\n\n\n\n```js\n// charts.tsx/jsx\n\n'use client' // 앱 디렉토리를 사용한다면, 이 줄을 빼먹지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst ApexChart = dynamic(() =\u003e import(\"react-apexcharts\"), { ssr: false });\n\n\nexport function ExampleChart(){\n\n    const option = {\n        chart: {\n          id: 'apexchart-example'\n        },\n        xaxis: {\n          categories: [1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999]\n        }\n      }\n\n    const series = [{\n        name: 'series-1',\n        data: [30, 40, 35, 50, 49, 60, 70, 91, 125]\n      }]\n\n    return(\n        \u003c\u003e\n            \u003cApexChart type=\"line\" options={option} series={series} height={200} width={500} /\u003e\n        \u003c/\u003e\n    )\n    \n}\n```\n\n만약 react-apexcharts — npm (npmjs.com)에서 아래와 같이 가져오려고 한다면\n\n```js\nimport Chart from 'react-apexcharts'\n```\n\n아마도 이런 에러를 마주하게 될 것입니다```\n\n\n\n마크다운 형식을 사용하면 더 좋을 것 같아요.\n\n![HowToUseApexChartsinaNextjsProject_1](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_1.png)\n\n혹은 터미널에서는 이렇게 보일지도 몰라요.\n\n![HowToUseApexChartsinaNextjsProject_2](/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_2.png)\n\n이 에러는 Next.js의 자동 프리랜더링(렌더링: 자동 정적 최적화 | Next.js (nextjs.org)) 때문에 발생한 것 같아요. ApexChart 라이브러리는 클라이언트 쪽에 있는 window 인터페이스에 의존하기 때문에 본문 작성 시점에는 서버에서 프리랜더링할 수 없는 것으로 보입니다.\n\n\n\n그래서 Next.js가 이 경우를 해결하기 위해 제공한 솔루션은 내장된 next/dynamic을 사용하여 동적 가져오기를 수행하고 서버 측 사전 렌더링을 중지하도록 명시적으로 구성하는 것입니다.\n\n```js\n'use client' // 전체 파일을 클라이언트 측 컴포넌트로 표시하려면 앱 디렉터리를 사용하는 경우 이 부분을 잊지 마세요\n\nimport dynamic from \"next/dynamic\";\nconst Chart = dynamic(() =\u003e import(\"react-apexcharts\"), { ssr: false });\n```\n\n# 직접 해 보세요!\n\n이것은 페이지 디렉터리를 위한 것입니다.\n\n\n\n그리고 이것은 앱 디렉토리를 위한 것입니다.\n\n지금까지 제가 전달할 내용은 여기까지입니다. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png"},"coverImage":"/assets/img/2024-05-12-HowToUseApexChartsinaNextjsProject_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트와 리덕스 툴킷으로 할 일 앱 만들기","description":"","date":"2024-05-12 22:09","slug":"2024-05-12-BuildingaTodoAppwithReactandReduxToolkit","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png\" /\u003e\n\n# 소개:\n\n이 튜토리얼에서는 React와 Redux Toolkit을 사용하여 간단한 할 일 앱을 구축할 것입니다. Redux Toolkit은 유틸리티 함수와 추상화를 제공하여 Redux에서 상태 관리를 간소화하는 강력한 라이브러리입니다. 이 튜토리얼을 마치면 React 애플리케이션에서 상태를 관리하는 데 Redux Toolkit을 사용하는 방법에 대해 확고한 이해를 얻을 것입니다.\n\n## 전제 조건:\n\n\n\n시작하기 전에 컴퓨터에 Node.js와 npm이 설치되어 있는지 확인해 주세요. React 기초 지식이 있다면 더 좋습니다.\n\n## 단계 1: 프로젝트 설정하기\n\n시작하려면 Create React App을 사용하여 새 React 프로젝트를 만들어야 합니다. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nnpx create-react-app todo-app\n```\n\n\n\n## 단계 2: 의존성 설치\n\n프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 필요한 의존성을 설치하세요:\n\n```js\ncd todo-app\nnpm install @reduxjs/toolkit react-redux\n```\n\n## 단계 3: Redux 슬라이스 이해하기\n\n\n\n코딩에 들어가기 전에 Redux 슬라이스 개념을 간단히 이해해 봅시다. 슬라이스는 애플리케이션의 상태와 연결된 리듀서의 논리적인 부분입니다. 초기 상태를 포함하고 상태가 액션에 응답하여 업데이트되는 방법을 정의합니다.\n\n## 단계 4: Redux 슬라이스 생성\n\n`src` 디렉토리에서 `todoSlice.js`라는 새 파일을 생성하세요. 이 파일은 할 일 관리를 위한 Redux 슬라이스를 담고 있을 것입니다. `todoSlice.js` 안에서 `@reduxjs/toolkit`에서 `createSlice` 함수를 가져와서 할 일 슬라이스의 초기 상태와 리듀서를 정의하세요.\n\n```js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst todoSlice = createSlice({\n  name: \"todos\",\n  initialState: [],\n  reducers: {\n    addTodo: (state, action) =\u003e {\n      const newTodo = {\n        id: Date.now(),\n        text: action.payload,\n        completed: false,\n      };\n      state.push(newTodo);\n    },\n    toggleComplete: (state, action) =\u003e {\n      const todo = state.find((todo) =\u003e todo.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo: (state, action) =\u003e {\n      const index = state.findIndex((todo) =\u003e todo.id === action.payload);\n      if (index !== -1) {\n        state.splice(index, 1);\n      }\n    },\n  },\n});\nexport const { addTodo, toggleComplete, deleteTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n```\n\n\n\n## 단계 5: Redux 스토어 구성하기\n\n이제 우리의 애플리케이션 상태를 보유할 Redux 스토어를 생성해 봅시다. `src` 디렉토리 내에 `store.js`라는 새 파일을 생성하세요. 이 파일 안에서 `@reduxjs/toolkit`에서 `configureStore` 함수와 `todoSlice` 리듀서를 import합니다. 그 후 `configureStore`를 사용하여 Redux 스토어를 생성하세요.\n\n```js\nimport { configureStore } from '@reduxjs/toolkit';\nimport todoReducer from './todoSlice';\n\nconst store = configureStore({\n reducer: {\n todos: todoReducer,\n },\n});\n\nexport default store;\n```\n\n## 단계 6: Todo 컴포넌트 구성하기\n\n\n\n이제 `src` 디렉토리에 `Todo.js` 파일을 만들어 봅시다. 이 파일에는 할 일 리스트의 표시 및 관리를 처리할 `Todo` 컴포넌트가 포함됩니다. `Todo.js` 내에서 React, `react-redux`에서 필요한 훅 및 컴포넌트, 그리고 `todoSlice`에서 액션을 import하세요.\n\n```js\nimport React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { addTodo, toggleComplete, deleteTodo } from \"./todoSlice\";\n\nconst Todo = () =\u003e {\n  const [text, setText] = useState(\"\");\n  const todos = useSelector((state) =\u003e state.todos);\n  const dispatch = useDispatch();\n\n  const handleInputChange = (e) =\u003e {\n    setText(e.target.value);\n  };\n\n  const handleAddTodo = () =\u003e {\n    if (text) {\n      dispatch(addTodo(text));\n      setText(\"\");\n    }\n  };\n\n  const handleToggleComplete = (id) =\u003e {\n    dispatch(toggleComplete(id));\n  };\n\n  const handleDeleteTodo = (id) =\u003e {\n    dispatch(deleteTodo(id));\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput type=\"text\" value={text} onChange={handleInputChange} /\u003e{\" \"}\n      \u003cbutton onClick={handleAddTodo}\u003e 할 일 추가 \u003c/button\u003e{\" \"}\n      \u003cul\u003e\n        {\" \"}\n        {todos.map((todo) =\u003e (\n          \u003cli\n            key={todo.id}\n            style={{\n              textDecoration: todo.completed ? \"line-through\" : \"none\",\n            }}\n          \u003e\n            {todo.text}{\" \"}\n            \u003cbutton onClick={() =\u003e handleToggleComplete(todo.id)}\u003e\n              {\" \"}\n              {todo.completed ? \"미완료 처리\" : \"완료 처리\"}{\" \"}\n            \u003c/button\u003e{\" \"}\n            \u003cbutton onClick={() =\u003e handleDeleteTodo(todo.id)}\u003e 삭제 \u003c/button\u003e{\" \"}\n          \u003c/li\u003e\n        ))}{\" \"}\n      \u003c/ul\u003e{\" \"}\n    \u003c/div\u003e\n  );\n};\n\nexport default Todo;\n```\n\n## Step 7: App 컴포넌트 업데이트하기\n\n`Todo` 컴포넌트를 렌더링하려면 `App.js` 파일을 약간 수정해야 합니다. React, `react-redux`의 `Provider` 컴포넌트, 그리고 `store.js` 파일에서 `store`를 import하세요. 그런 다음, `Todo` 컴포넌트를 `Provider` 컴포넌트로 감싸고 store를 prop으로 전달하세요.\n\n\n\n```js\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport Todo from \"./Todo\";\n\nconst App = () =\u003e {\n  return (\n    \u003cProvider store={store}\u003e\n       \u003cTodo /\u003e \n    \u003c/Provider\u003e\n  );\n};\n\nexport default App;\n```\n\n## 단계 8: 앱 실행하기\n\n이제 할 일 앱을 실제로 실행해보는 시간입니다! 터미널에서 다음 명령어를 실행해주세요:\n\n```js\nnpm start\n```\n\n\n\n브라우저에서 http://localhost:3000을 방문하면 할 일 앱이 정상적으로 작동하는 것을 확인할 수 있습니다. 할 일을 추가하고 완료로 표시하거나 삭제할 수 있습니다. Redux Toolkit은 상태 관리를 효율적이고 쉽게 처리하게 해줍니다.\n\n![이미지](/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_1.png)\n\n# 결론:\n\n이 튜토리얼에서 React와 Redux Toolkit을 사용하여 할 일 앱을 만드는 방법을 배웠습니다. Redux 슬라이스의 개념을 살펴보고 Redux Toolkit의 `createSlice` 함수를 사용하여 할 일을 관리하는 상태와 리듀서를 정의했습니다. 이 튜토리얼을 따라하면 Redux Toolkit을 사용해 React 애플리케이션의 상태를 관리하는 뛰어난 기초를 마련할 수 있을 것입니다.\n\n\n\n더 많은 기능을 추가하여 할 일을 편집하거나 완료 상태에 따라 필터링하는 등 앱을 사용자 정의하고 향상시키는 것에 자유롭게 도전해보세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaTodoAppwithReactandReduxToolkit_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 JS에서 리액트 폼 훅과 useFieldArray 훅을 함께 사용하는 방법","description":"","date":"2024-05-12 22:08","slug":"2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS","content":"\n\n소프트웨어 개발자로서, React Form Hook에서 useFieldArray 훅을 사용하는 방법에 대해 여러분과 공유할 수 있어서 정말 기쁩니다. 이 훅은 동적으로 폼 필드를 추가하거나 제거할 수 있는 강력한 도구로, 다수의 입력 필드가 있는 복잡한 폼을 쉽게 관리할 수 있게 해줍니다.\n\n먼저, 필요한 종속성을 설치하는 방법부터 시작해보겠습니다. React Hook Form 라이브러리와 useFieldArray 훅을 설치해야 합니다. 터미널에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다:\n\n```js\nnpm install react-hook-form\n```\n\n의존성을 설치했다면, React 폼에서 useFieldArray 훅을 구현할 수 있습니다. 이 훅을 사용하는 예시를 보여드리겠습니다:\n\n\n\n```js\nimport React from 'react';\nimport { useForm, useFieldArray } from 'react-hook-form';\n\nfunction MyForm() {\n  const { register, control, handleSubmit } = useForm({\n    defaultValues: {\n      items: [{ name: 'item1' }, { name: 'item2' }],\n    },\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: 'items',\n  });\n\n  const onSubmit = (data) =\u003e console.log(data);\n\n  return (\n    \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n      {fields.map((field, index) =\u003e (\n        \u003cdiv key={field.id}\u003e\n          \u003cinput\n            {...register(`items.${index}.name`)}\n            defaultValue={field.name}\n          /\u003e\n          \u003cbutton type=\"button\" onClick={() =\u003e remove(index)}\u003e\n            Remove\n          \u003c/button\u003e\n        \u003c/div\u003e\n      ))}\n      \u003cbutton type=\"button\" onClick={() =\u003e append({ name: '' })}\u003e\n        Add Item\n      \u003c/button\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n\nexport default MyForm;\n```\n\n이 예제에서는 useForm 훅을 사용하여 기본값으로 form을 초기화했습니다. 또한 useFieldArray 훅을 사용하여 \"items\" 필드 배열을 관리했습니다. \"control\" 속성은 useForm 훅과 상호 작용할 수 있도록 useFieldArray 훅에 전달됩니다.\n\nfields.map 함수는 \"items\" 배열의 각 입력 필드를 렌더링하는 데 사용됩니다. \"Remove\" 버튼을 클릭하면 제거 함수가 호출되고, \"Add Item\" 버튼을 클릭하면 추가 함수가 호출됩니다.\n\nuseFieldArray 훅을 사용하면 form의 상태를 수동으로 관리하지 않고도 form에서 필드를 쉽게 추가하거나 제거할 수 있습니다. 이를 통해 동적 입력이 있는 복잡한 form을 쉽게 생성할 수 있습니다.\n```\n\n\n\n하지만 \"items\" 배열에서 더 많은 필드를 사용하고 싶다면 어떻게 해야 할까요? 걱정하지 마세요! 단순히 양식에 더 많은 입력을 추가하면 됩니다. \"name\"과 \"quantity\" 두 필드를 \"items\" 배열에 포함한 예제를 보여드리겠습니다:\n\n```js\nimport React from 'react';\nimport { useForm, useFieldArray } from 'react-hook-form';\n\nfunction MyForm() {\n const { register, control, handleSubmit } = useForm({\n defaultValues: {\n items: [{ name: 'item1', quantity: 1 }, { name: 'item2', quantity: 2 }],\n },\n });\n \n const { fields, append, remove } = useFieldArray({\n control,\n name: 'items',\n });\n\n const onSubmit = (data) =\u003e console.log(data);\n\n return (\n \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n {fields.map((field, index) =\u003e (\n \u003cdiv key={field.id}\u003e\n \u003cinput\n {…register(`items.${index}.name`)}\n defaultValue={field.name}\n /\u003e\n \u003cinput\n {…register(`items.${index}.quantity`)}\n defaultValue={field.quantity}\n /\u003e\n \u003cbutton type=\"button\" onClick={() =\u003e remove(index)}\u003e\n Remove\n \u003c/button\u003e\n \u003c/div\u003e\n ))}\n \u003cbutton type=\"button\" onClick={() =\u003e append({ name: '', quantity: 0 })}\u003e\n Add Item\n \u003c/button\u003e\n \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n \u003c/form\u003e\n );\n}\n\nexport default MyForm;\n```\n\n이 업데이트된 예제에서 \"quantity\"에 대한 두 번째 입력 필드가 추가되었습니다. 여전히 \"items\" 배열의 각 입력 필드를 렌더링하는 데 이전과 동일한 접근 방식을 사용하고 있습니다. \"Remove\" 버튼을 클릭하면 여전히 remove 함수가 호출되고, \"Add Item\" 버튼을 클릭하면 여전히 append 함수가 호출됩니다.\n\nuseForm 및 useFieldArray 훅을 함께 사용하면 React JS에서 여러 입력을 가진 복잡한 양식을 쉽게 관리할 수 있습니다. useFieldArray 훅은 폼에서 동적으로 필드를 추가하거나 제거할 수 있는 강력한 도구로, 동적이고 사용자 친화적인 양식을 만드는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoUsetheuseFieldArrayHookwithReactFormHookinReactJS_0.png","tag":["Tech"],"readingTime":4},{"title":"코드 형태의 형상  코드 생성을 활용하여 개발자의 작업 흐름 최적화하기","description":"","date":"2024-05-12 22:06","slug":"2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration","content":"\n\n스타터 템플릿과 코드 생성기는 개발자들이 새로운 언어나 프레임워크로 시작하는 인기 있는 방법입니다. 그러나 많은 경우 이들은 효율적이고 견고한 개발 워크플로우를 지원하지 못하는 것이 문제입니다. 대부분의 코드 생성기는 프로덕션 품질의 도구가 없으며 생성 능력이 제한되어 사용자 정의를 공유하기 어렵게 만듭니다.\n\n![Code Shape 사진](/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png)\n\n오늘은 이러한 문제를 해결하기 위해 전면부터 설계된 코드 생성 플랫폼인 Code Shaper를 소개하고 싶습니다. 여기 몇 가지 주요 기능을 소개합니다:\n\n- 모듈식이므로 프로덕션 품질의 도구 추가 가능\n- React, Next.js, Remix와 같은 인기있는 프레임워크용 사전 제공 생성기 포함\n- 린팅, 테스팅, 컴포넌트 개발, API 모킹에 대한 의견이 분분한 선택 제공\n- 워크플로우 사용자 정의가 필요한 경우 사용자 정의 생성기 빌드 가능\n- npm 등의 레지스트리를 사용하여 팀과 생성기 공유 가능\n\n\n\nCode Shaper은 작업 흐름을 신속하고 일관되게 그리고 표준화된 방식으로 만들어줍니다. Code Shaper가 어떻게 여러분의 작업 흐름을 최적화할 수 있는지 느껴보기 위해 간단한 Next.js 앱을 만들어보겠습니다.\n\n아래는 Code Shaper 사이트의 전체 설명서를 요약한 것입니다. 여러분은 전체 연습을 직접 경험하거나 다른 프레임워크를 시도해볼 수 있는 곳으로 바로 이동할 수 있습니다.\n\n# 시작하기\n\nCode Shaper를 사용하면 단일 저장소에서 여러 아티팩트를 생성할 수 있습니다. 이는 웹 애플리케이션, 재사용 가능한 라이브러리, 코드 생성기 또는 상상할 수 있는 모든 것일 수 있습니다. 각 아티팩트에는 자체 워크스페이스가 있습니다. 워크스페이스는 저장소의 구성 요소로 생각할 수 있습니다.\n\n\n\n코드 쉐이퍼를 설정하는 것은 두 단계로 이루어져요:\n\n- 새로운 레포지토리 생성하기\n- 그 안에 하나 이상의 아티팩트 추가하기\n\n단계 2는 서로 다른 언어와 프레임워크를 사용하는 아티팩트를 추가하기 위해 여러 번 반복할 수 있어요.\n\n그럼 이제 새로운 레포지토리를 만들어 시작해볼까요?\n\n\n\n## 새로운 레포지토리 만들기\n\n먼저, 앱과 라이브러리와 같은 다양한 아티팩트를 추가할 기반으로 사용할 새로운 레포지토리를 만들겠습니다. 계속하기 전에 가져야 할 몇 가지 전제 조건이 있습니다:\n\n- 머신에 Node Version Manager (NVM)가 설치되어 있는지 확인하세요. NVM을 통해 명령 줄을 통해 다양한 노드 버전을 사용할 수 있습니다. NVM을 설치하려면 아래 지침을 따르세요:\n  NVM for MacOS\n  NVM for Windows\n- TypeScript를 이해하는 IDE가 설치되어 있는지 확인하세요. Visual Studio Code (무료)와 WebStorm (유료) 모두 좋은 선택지입니다.\n\n```js\n# 보통 새 프로젝트를 만드는 위치(예: ~/projects)로 디렉터리 변경\ncd ~/projects\n\n# 레포지토리용으로 빈 디렉터리를 만들고 해당 디렉터리로 이동합니다.\n# 레포지토리는 일반적으로 케밥 케이스로 명명됩니다.\nmkdir movie-magic\ncd movie-magic\n\n# 빈 package.json 파일 생성\nnpm init -y\n\n# Code Shaper 및 해당 레포지토리 플러그인 설치\nnpm install code-shaper @code-shaper/repo\n\n# Code Shaper 실행하고 프롬프트에 따라 turborepo를 초기화합니다.\nnpx shaper\n? 어떤 플러그인을 실행하시겠습니까? Repo\n? 어떤 생성기를 실행하시겠습니까? turborepo\n? 이 생성기는 레포지토리의 일부 파일을 덮어쓸 것입니다. 계속 하시겠습니까? y\n```\n\n\n\nCode Shaper가 Turborepo와 새로운 package.json 파일을 사용하여 저장소를 초기화했습니다. 아래 명령을 실행하여 새로운 종속성을 설치한 후 첫 번째 커밋을 만들어보세요:\n\n```js\n# 현재 디렉토리에 git 저장소를 초기화합니다\ngit init\n\n# 필요한 Node.js 버전을 사용합니다.\n# 필요한 Node.js 버전이 설치되어 있지 않으면\n# 설치하라는 프롬프트가 표시됩니다.\nnvm use\n\n# 새로 생성된 package.json 파일로 초기 설치를 수행합니다\nrm -rf package-lock.json node_modules\nnpm install\n\n# 첫 번째 커밋을 만듭니다\n# 매 단계가 끝날 때마다 커밋하여 완료된 단계를 표시합니다.\n# 커밋 메시지에는 일반적인 규약을 따르는 것에 주의하세요.\n# `npm run commit` 명령을 사용하여 프롬프트를 통해 도와줍니다.\n# 다음 git 명령을 직접 실행하는 것과 동일합니다:\n#   git commit -m \"chore: initial commit\"\ngit add .\nnpm run commit\n ? 이 변경 내용의 유형을 선택하세요 (필수): chore\n ? 이 변경 내용의 범위를 선택하세요 (선택사항) (Enter를 눌러 건너뛰기): \u003cEnter 키\u003e\n ? 이 짧은 문장을 완료하세요 (필수): \"이 커밋을 적용하면...\": (최대 100자)\n initial commit\n ? 변경 사항에 대한 자세한 설명을 제공하세요 (선택사항): (Enter를 눌러 건너뛰기): \u003cEnter 키\u003e\n ? 파손되는 변경 사항이 있나요?: 아니요\n [master (root-commit)] chore: initial commit\n```\n\n이제 저장소가 모두 설정되었으니, 첫 번째 아티팩트를 추가해봅시다. 우리는 Next.js 앱으로 시작할 것입니다.\n\n## Next.js 앱 만들기\n\n\n\nCode Shaper 플러그인을 Next.js에 설치해보세요.\n\n```js\nnpm install @code-shaper/nextjs\n```\n\n이제 Next.js 애플리케이션을 생성해봅시다. 관례적으로 애플리케이션은 apps 디렉토리에 만들어집니다. 거기에 하나를 만들어볼까요?\n\n```js\nnpx shaper\n? 어떤 플러그인을 실행하고 싶으신가요? Next.js\n? 어떤 생성기를 실행하고 싶으신가요? app\n? 애플리케이션 이름은? movie-magic-nextjs\n? 상위 디렉토리는? apps\n? 패키지 이름(게시용)? @movie-magic/movie-magic-nextjs\n? Tailwind CSS를 사용하시겠습니까? Yes\n```\n\n\n\n다음 명령어를 실행하여 추가 설정을 하고 모든 변경 사항을 커밋하세요:\n\n```js\n# 영화 매직을 위한 로컬 환경 파일 생성\ncp apps/movie-magic-nextjs/.env.example apps/movie-magic-nextjs/.env.local\n\n# 의존성 설치:\nnpm install\n\n# 앱 빌드 및 실행하여 작동 확인\nnpm run build\nnpm run dev\n\n# 브라우저를 http://localhost:3000/ 로 이동하세요.\n# 실행 중인 앱을 볼 수 있어야 합니다.\n\n# Storybook 실행하여 작동 확인\nnpm run storybook\n\n# 브라우저를 http://localhost:6006/ 로 이동하세요.\n# 실행 중인 Storybook을 볼 수 있어야 합니다.\n\n# 커밋\ngit add .\ngit commit -m \"chore: add movie-magic-nextjs app\"\n```\n\n이제 우리는 스타터 앱을 확장할 준비가 되었습니다. 앱 이름에서 짐작하실 수 있듯이, 세계에서 가장 놀라운 최고 10개의 영화를 보여주는 앱을 만들 것입니다. 🎬\n\n\u003cimg src=\"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_1.png\" /\u003e\n\n\n\n## 앱 확장하기\n\n이 예제에서 사용할 라이브러리를 설치하려면 레포지토리의 루트 디렉토리에서 다음 명령을 실행하세요.\n\n```js\nnpm install clsx axios @tanstack/react-query --workspace @movie-magic/movie-magic-nextjs\n```\n\nTypeScript 정의 생성\n우리 앱에서 필요한 데이터 구조에 대한 TypeScript 정의를 생성해봅시다. 완료된 예제에서 다음 4개의 파일을 복사하여 앱의 movie-magic-nextjs/src/models 폴더에 붙여넣어주세요.\n\n\n\n- index.ts\n- Movie.ts\n- PaginationInfo.ts\n- QueryParams.ts\n\n영화 목록 컴포넌트 만들기\n이제 우리는 영화 목록을 받아와서 보여주는 MovieList 컴포넌트를 생성할 것입니다. 이러한 컴포넌트들은 presentational components라고 불립니다 - 데이터를 어떻게 얻었는지에 대해 걱정하지 않고, 단순히 렌더링하는 것이 그들의 일입니다.\n\nNext.js 플러그인이 제공하는 컴포넌트 생성기를 사용하여 `MovieList` 컴포넌트를 생성할 것입니다. 아래 단계를 따라주세요:\n\n```js\nnpx shaper\n? 어떤 플러그인을 실행하시겠습니까? Next.js\n? 어떤 생성기를 실행하시겠습니까? component\n? 컴포넌트 이름은? MovieList\n? 이 작업은 어느 워크스페이스에 속하나요? apps/movie-magic-nextjs\n? 워크스페이스 내 어느 디렉토리에 위치시키시겠습니까? src/components/MovieList\n```\n\n\n\n예를 위해 MovieList 컴포넌트를 위한 플레이스홀더가 생성되었습니다. 또한 Storybook 스토리를 위한 플레이스홀더가 생성되었습니다. 이제 Storybook를 사용하여 MovieList를 인터랙티브하게 구현해 봅시다.\n\n```js\nnpm run storybook\n```\n\n브라우저를 http://localhost:6006 주소로 연결하세요. Storybook은 MovieList의 플레이스홀더 구현을 보여줍니다.\n\nMovieList 컴포넌트 구현하기\n이제 우리는 실제 MovieList를 구현할 준비가 되었습니다.\n\n\n\n- 영화 데이터를 렌더링할 데이터를 만드세요. 완료된 예제에서 movies.ts 파일을 앱/movie-magic-nextjs/src/mocks 폴더로 복사하세요.\n- 완료된 예제에서 MovieList 컴포넌트의 placeholder 구현을 덮어쓰세요. 앱/movie-magic-nextjs/src/components/MovieList/MovieList.tsx에 있습니다.\n- 완료된 예제에서 MovieList의 placeholder 스토리를 덮어쓰세요. 앱/movie-magic-nextjs/src/components/MovieList/MovieList.stories.tsx에 있습니다.\n\n다음은 최종 Storybook 스토리의 스냅샷입니다.\n\n![코드 형태 최적화를 통해 개발자 워크플로우를 개선하는 2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_2.png](/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_2.png)\n\n## MovieList 컴포넌트를 테스트하세요\n\n\n\n컴포넌트에 대한 유닛 테스트를 작성하면 다음을 보장할 수 있어요:\n\n- 정상적으로 작동하는지 확인할 수 있고,\n- 리포지토리의 어떤 코드가 변경되더라도 계속해서 정상적으로 작동하는지 확인할 수 있어요.\n\nMovieList 컴포넌트에 대한 유닛 테스트를 작성해봅시다. 이 테스트는 올바른 영화 수를 렌더링하는지 확인할 거에요. React Testing Techniques에서 더 많은 유닛 테스트에 대한 모범 사례를 찾을 수 있어요.\n\n완성된 예시에서 apps/movie-magic-nextjs/src/components/MovieList/MovieList.test.tsx의 플레이스홀더 테스트를 덮어씌워주세요.\n\n\n\n루트 디렉토리에서 테스트를 실행하세요. 모든 테스트가 통과해야 해요.\n\n```js\nnpm test\n```\n\nMovieList가 이제 완전히 구현되었습니다. 코드를 커밋합시다:\n\n```js\n# 커밋\ngit add .\ngit commit -m \"feat: MovieList 추가\"\n```\n\n\n\n# 요약\n\n이 연습을 통해 코드 생성을 통해 작업 흐름을 최적화 할 수 있는 Code Shaper가 어떻게 도움이 될 수 있는지 감을 잡았을 것입니다. 이제 샘플 앱을 만들었으니, 품질 좋은 코드 생성 플랫폼이 어떻게 빠르게 견고한 응용프로그램을 개발하는 데 도움이 될 수 있는지 보실 수 있을 것입니다.\n\n다음은 추가로 살펴볼 수 있는 자료입니다:\n\n- 시작하기 — Code Shaper의 더 많은 기능을 다루는 심층 튜토리얼\n- Off-the-shelf 플러그인\n- 자체 사용자 정의 생성기 만들기\n- Movie Magic — 다양한 프레임워크를 사용하여 응용프로그램을 생성하는 방법의 예제\n\n\n\n이 기사는 원문을 참조하여 작성되었습니다: [https://www.nareshbhatia.dev/articles/code-shaper-optimizing-developer-workflows](https://www.nareshbhatia.dev/articles/code-shaper-optimizing-developer-workflows)","ogImage":{"url":"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png"},"coverImage":"/assets/img/2024-05-12-CodeShaperoptimizingdeveloperworkflowsusingcodegeneration_0.png","tag":["Tech"],"readingTime":7},{"title":"React Router의 useParams 훅을 적용하는 실용적인 단계","description":"","date":"2024-05-12 22:03","slug":"2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter","content":"\n\n![이미지](/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png)\n\nuseParams 훅은 React에서 친숙한 사용자 인터페이스를 개발하는 데 필수적입니다. 따라서 React 개발자가 익숙해져야 할 중요한 지식입니다. useParams 훅을 사용하면 전자 상거래 및 블로깅 웹 사이트와 같은 다중 매개변수를 가진 복잡한 React 인터페이스를 개발할 수 있습니다.\n\n이 튜토리얼은 React 애플리케이션에서 useParams 훅을 적용하는 방법에 대한 실용적인 단계와 지식을 제공하는 데 초점을 맞춥니다. 이 튜토리얼에서는 다음 주제를 다룰 것입니다:\n\n1. useParams 훅이란 무엇인가요?\n\n\n\n2. `useParams` 훅을 적용하기 위한 요구 사항\n\n3. `useParams` 훅을 사용하는 장점\n\n4. `useParams` 훅을 적용하는 실제적인 단계\n\n# 전제 조건:\n\n\n\n이것은 React와 React-router의 useParams 훅을 배우고 적용하는 것에 관심 있는 초보자를 위한 친절한 튜토리얼입니다. 이 튜토리얼에서 최대한 많은 도움을 받으려면 몇 가지 기본적인 React와 JavaScript 도구에 익숙해져야 합니다. 이러한 도구로는 다음이 포함됩니다:\n\n- React Routing,\n- Map 함수, 그리고\n- 구조 분해.\n\n또한 HTML 및 CSS에 익숙해져 있어야 합니다. 따라서 이 튜토리얼을 진행하기 전에 위의 개념들을 먼저 익히는 것을 권장합니다.\n\n# useParams 훅이란 무엇인가요?\n\n\n\n`useParams` 훅은 웹사이트의 여러 매개변수를 생성하고 액세스하는 데 사용되는 React 라우터 훅입니다. 본질적으로 `useParams` 훅은 동일한 URL 경로에서 여러 콘텐츠에 액세스할 수 있도록 해줍니다. `useParams` 훅을 통해 각 매개변수에 고유한 식별자를 부여할 수 있습니다. 이 고유한 식별자를 통해 동일한 URL 경로에서 각 매개변수에 액세스하고 렌더링할 수 있습니다.\n\n전자 상거래 및 블로그 앱은 여러 매개변수가 있는 애플리케이션의 예시입니다. `useParams` 훅이 적용되는 다른 예시로는 학습 관리 시스템(LMS) – 즉, 온라인 튜토리얼 사이트, 웹사이트의 검색 버튼, 기사/신문 웹사이트 등이 있습니다.\n\n예를 들어, 블로그 앱에는 여러 블로그가 포함되어 있습니다. 각 블로그에는 고유한 ID가 있어서 각 블로그에 접근할 수 있습니다.\n\n# `useParams` 훅을 적용하는 요구 사항\n\n\n\nReact 앱에서 useParams 훅을 적용하려면 몇 가지 기본 도구와 라이브러리가 필요합니다. 이 섹션에서는 이러한 기본 요구 사항을 살펴볼 것입니다.\n\n## 1. React-router-dom\n\nreact-router-dom은 React 애플리케이션에서 라우팅을 제공하는 외부 React 라이브러리입니다. react-router-dom에는 useParams 훅이 함께 제공됩니다. 따라서 useParams 훅을 적용하려면 react-router-dom을 React 앱에 설치해야 합니다. 아래 섹션에서는 react-router-dom을 설치하는 방법을 안내합니다.\n\n## 2. Component\n\n\n\n컴포넌트는 HTML 요소를 반환하는 JavaScript 코드 집합입니다. React의 컴포넌트는 브라우저에 표시할 내용을 결정합니다.\n\nuseParams 훅을 적용하려면 컴포넌트를 만들고 해당 컴포넌트로 useParams를 가져와야 합니다. 그런 다음 객체 비구조화를 사용하여 useParams 메서드에 변수를 할당하세요. 아래 코드 예시를 참고하세요.\n\n```js\nimport { useParams } from 'react-router-dom';\n\nfunction Blog(){\n  let { blogid } = useParams();\n  return\u003cp\u003e내 고유 ID는 {blogid}입니다.\u003c/p\u003e\n}\n```\n\n### 3. Route 태그\n\n\n\nRoute 태그는 브라우저의 URL 경로를 나타냅니다. Route 태그는 두 가지 속성을 받습니다. path 속성과 element 속성이 포함되어 있습니다. path 속성은 URL 경로에 할당됩니다. element 속성은 렌더링할 컴포넌트에 할당됩니다.\n\nuseParams 훅을 적용하려면 path 속성에도 자리 표시자가 포함되어야 합니다. 자리 표시자의 역할은 해당 값을 기반으로 동적 콘텐츠를 반환하는 것입니다. 아래 예제를 참조해보세요.\n\n```js\n\u003cRoutes\u003e\n    \u003cRoute path='/blog/:blogid' element={\u003cBlog /\u003e}\u003e\u003c/Route\u003e\n\u003c/Routes\u003e\n```\n\n다음 사항을 주의하십시오:\n\n\n\n- blogid은 플레이스홀더이며 임의의 이름을 사용할 수 있습니다.\n- 일반적으로 플레이스홀더는 값 이전에 `:`를 포함합니다.\n- 플레이스홀더 이름은 컴포넌트의 useParams 메서드에 할당된 값과 일치해야 합니다.\n- 따라서 URL 경로인 /blog/2는 id 번호가 2인 블로그 콘텐츠를 반환합니다.\n\n# useParams 훅을 사용하는 장점\n\nuseParams 훅을 사용하는 것은 React 개발자와 사용자 양쪽에 많은 이점이 있습니다. useParams 훅을 사용하는 장점 중 일부는 다음과 같습니다.\n\n- 다중 매개변수: useParams 훅은 동적 콘텐츠를 포함하는 여러 매개변수를 만드는 데 사용됩니다. 따라서 응용 프로그램에서 useParams 훅을 사용하면 사용자에게 친숙한 방식으로 다양한 정보를 제공할 수 있습니다.\n- 앱 성능 향상: useParams 훅은 동적 콘텐츠를 동일한 URL 경로에 렌더링합니다. 이는 앱의 성능을 향상시키고로딩 시간을 줄입니다.\n- 쉬운 접근성: useParams 훅은 사용자 친화적인 도구로, 다중 매개변수와 콘텐츠에 쉽게 접근할 수 있습니다.\n- 더 적은 코드: useParams 훅을 사용하면 몇 줄의 코드로 여러 매개변수를 만들 수 있습니다. 결국, 이는 불필요한 반복을 제거하고 작성해야 하는 코드 양을 줄여줍니다.\n\n\n\n# React에서 useParams 훅을 적용하는 실용적인 단계\n\n이 섹션에서는 여러 제품을 표시하는 간단한 전자 상거래 인터페이스를 구축하는 방법을 살펴볼 것입니다. 각 제품은 고유한 ID를 갖고 있어 해당 ID를 통해 액세스할 수 있습니다.\n\n이 섹션은 세 부분으로 나뉘어집니다.\n\n- 첫 번째 부분에서는 React 앱을 만드는 방법을 안내합니다.\n- 두 번째 부분에서는 간단한 전자 상거래 인터페이스를 만드는 방법을 안내합니다.\n- 세 번째 부분에서는 프로젝트에서 useParams 훅을 적용하는 방법을 안내합니다.\n\n\n\n시작해 봅시다.\n\n# 첫 번째 부분 — React 프로젝트 생성\n\n아래 단계는 React 앱을 생성하고 react-router-dom을 설치하는 데 도움이 됩니다.\n\n## 단계 1: React 앱 생성\n\n\n\nReact 앱을 만들려면 아래 지시사항을 따라주세요.\n\n- 터미널을 열고 React 앱을 위한 새 폴더를 만드세요.\n- 새롭게 만든 폴더로 이동한 후 React 앱을 만드세요. 아래 명령어 중 하나를 사용하세요.\n\n```js\nC:\\Users\\Username\\Desktop\u003emkdir react-app\nC:\\Users\\Username\\Desktop\u003ecd react-folder\nC:\\Users\\Username\\Desktop\\react-folder\u003enpx create-react-app my-app\n```\n\n\n\n```js\nC:\\Users\\Username\\Desktop\\react-folder\u003enpm init react-app my-app\n```\n\n또는\n\n```js\nC:\\Users\\Username\\Desktop\\react-folder\u003eyarn create react-app my-app\n```\n\n다음 사항을 주의하십시오:\n\n\n\n- 리액트 앱을 만들기 전에 시스템에 node.js가 설치되어 있어야 합니다. 시스템에 node.js가 없는 경우 https://node.js.org를 방문하여 설치하세요.\n- react-app과 my-app은 각각 폴더와 리액트 앱의 이름입니다. 이름은 원하는 대로 지정할 수 있습니다.\n\n## 단계 2: React-router-dom 설치\n\n아래 지시 사항은 우리의 리액트 프로젝트에 React-router-dom을 설치하는 방법을 안내합니다.\n\n- 터미널에서 앱 디렉토리로 이동합니다.\n- npm이나 yarn을 사용하여 react-router-dom을 설치하세요.\n\n\n\n아래의 코드 예시를 확인해보세요.\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder\u003ecd my-app\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app\u003enpm install react-router-dom\n```\n\n## 단계 3: 서버 시작\n\n여전히 앱 디렉토리 안에 있는 경우, 아래의 코드와 같이 React 앱 서버를 시작하세요.\n\n\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app\u003enpm start\n```\n\nYarn 사용자:\n\n```js\nC:\\Users\\사용자명\\Desktop\\react-folder\\my-app\u003eyarn start\n```\n\n참고: React 앱을 만들 때 사용하는 npm 또는 yarn을 사용하여 React 종속성을 설치하고 React 스크립트를 실행하세요. 원하는 방법에 따라 npm이나 yarn을 사용하세요.```\n\n\n\n시작 스크립트는 로컬호스트 3000번 포트에서 React 앱 서버를 실행합니다.\n\n# 두 번째 파트 — 간단한 전자 상거래 인터페이스 설정\n\n우리는 React 앱을 성공적으로 생성하고 react-router-dom을 설치했습니다. 이제 간단한 전자 상거래 인터페이스를 만들어볼 수 있습니다.\n\n## 단계 1: index.js 파일 수정\n\n\n\nReact 앱을 선택한 코드 편집기로 열고 아래 지침을 따라 index.js 파일을 수정하십시오.\n\n- src 디렉토리에서 index.js 파일을 엽니다.\n- 객체 비구조화를 사용하여 react-router-dom에서 BrowserRouter를 가져옵니다.\n- App 컴포넌트를 BrowserRouter 태그로 둘러싸는 방식으로 root const를 업데이트합니다.\n\n최종 index.js 파일의 코드는 아래 예시와 같이 보여야 합니다.\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  \u003cBrowserRouter\u003e\n    \u003cApp /\u003e\n  \u003c/BrowserRouter\u003e\n);\n```\n\n\n\n## 단계 2: 제품 컴포넌트 만들기\n\n이 컴포넌트는 제품 데이터를 보유할 것입니다. 하지만 제품 컴포넌트를 만들기 전에 먼저 src 디렉토리에 이미지 폴더를 생성하세요. 이미지 폴더에는 사용할 모든 필요한 이미지가 포함되어야 합니다. 그리고 아래 지침을 따라 제품 컴포넌트를 만드세요.\n\n- src 디렉토리에 components 폴더를 생성하세요.\n- components 폴더에 Products.js 파일을 만드세요.\n- Products.js 파일을 열고 Products 변수를 만드세요.\n- Products 변수를 객체 배열에 할당하세요. 각 객체는 고유한 id, 타이틀, 설명, 이미지를 포함해야 합니다.\n- Products 컴포넌트를 내보내세요.\n\n아래 코드 예시를 참고하세요.\n\n\n\n```js\nconst Products = [\n    {\n        id: 1,\n        title: \"제품 이름\",\n        description: \"이것은 id가 1인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-1.png')\n    },\n    {\n        id: 2,\n        title: \"제품 이름\",\n        description: \"이것은 id가 2인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-2.png')\n    },\n    {\n        id: 3,\n        title: \"제품 이름\",\n        description: \"이것은 id가 3인 상품의 설명입니다. Provident nihil minus qui consequatur non omnis maiores. Eos accusantium minus dolores iure perferendis tempore et consequatur. \",\n        image: require('../images/product-3.png')\n    }\n]\n\nexport default Products;\r\n```\n\n## Step 3: 카드 컴포넌트 생성\n\n카드 컴포넌트의 본질은 제품들을 순회하고 조직적인 방식으로 렌더링하는 것입니다. 다음 지침은 카드 컴포넌트를 만드는 방법을 안내합니다.\n\n- components 디렉토리에 Card.js 파일을 생성합니다.\n- Card.js 파일을 열고 Products 컴포넌트를 import합니다.\n- return 메소드를 가진 Card 함수를 생성합니다.\n- 카드 함수 내에 return 메소드 전에 productItems 변수를 생성합니다.\n- productItems 변수를 우리 Products를 순회하는 map 함수에 할당합니다. map 함수는 아래 코드 예시와 같아야 합니다.\n```\n\n\n\n```js\nconst productItems = Products.map(store =\u003e{\n    const {id, title, description, image} = store;\n    return(\n      \u003cdiv key={ id } className=\"card\"\u003e\n        \u003cimg src={image} alt=\"\"\u003e\u003c/img\u003e\n        \u003ch3\u003e{title}\u003c/h3\u003e\n        \u003cp\u003e{description}\u003c/p\u003e\n      \u003c/div\u003e\n    )\n})\n```\n\n6. Card 함수의 return 메소드 안에 section 태그를 생성하세요. section 태그 사이에는 중괄호 안에 productItems가 들어가야 합니다.\n\n7. Card 컴포넌트를 export하세요.\n\nCard.js 파일의 최종 코드는 아래의 코드 예시와 같을 것입니다.```\n\n\n\n```js\nimport Products from \"./Products\";\n\nfunction Card(){\n\n    const productItems = Products.map(store =\u003e{\n        const {id, title, description, image} = store;\n        return(\n            \u003cdiv key={ id } className=\"card\"\u003e\n                \u003cimg src={image} alt=\"\"\u003e\u003c/img\u003e\n                \u003ch3\u003e{title}\u003c/h3\u003e\n                \u003cp\u003e{description}\u003c/p\u003e\n            \u003c/div\u003e\n        )\n    })\n\n    return (\n        \u003c\u003e\n            \u003csection className=\"card-section\"\u003e\n                {productItems}\n            \u003c/section\u003e\n        \u003c/\u003e\n    );\n};\n\nexport default Card;\n```\n\n## 단계 4: 카드 컴포넌트 스타일링\n\nindex.css 파일에 Card 컴포넌트에 CSS 스타일을 추가하십시오.\n\n참고: Card 컴포넌트 내부의 div 태그와 section 태그에는 className 속성이 포함되어 있습니다. 이 className 속성은 목적에 맞게 CSS 스타일링을 위해 만들어졌습니다.```\n\n\n\nsrc 폴더 내의 index.css 파일을 열고 아래 CSS 스타일을 적용하세요.\n\n```js\n.card-section{\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 20px;\n  margin: 40px;\n}\n\n.card{\n  padding: 1.2rem;\n  font-size: 1.2rem;\n  border: 1px solid rgb(104, 101, 101);\n}\n```\n\n## 단계 5: 홈 페이지 만들기\n\n홈 페이지는 앱의 기본 페이지로 사용되며 카드 컴포넌트를 렌더링할 것입니다. 아래 안내 사항을 따라 홈 페이지를 만들어 보세요.\n\n\n\n- src 디렉토리에 페이지 폴더를 생성하세요.\n- 페이지 폴더 안에 Home.js 파일을 만들어주세요.\n- Home.js 파일을 열고 Card 컴포넌트를 import 해주세요.\n- return 메소드를 포함하는 Home 함수를 생성해주세요. return 메소드는 Card 요소를 포함해야 합니다.\n- Home.js 파일을 export 해주세요.\n\n아래 코드를 참조해주세요.\n\n```js\nimport Card from \"../components/Card\"\n\nfunction Home(){\n    return (\n        \u003c\u003e\n            \u003ch1\u003eHome Page\u003c/h1\u003e\n            \u003cCard /\u003e\n        \u003c/\u003e\n    )\n}\n\nexport default Home;\n```\n\n## 단계 6: App.js 파일 수정하기\n\n\n\nApp.js 파일은 브라우저에 무엇을 렌더링할지를 결정하는 루트 컴포넌트입니다. 이 단계에서는 App.js 파일을 수정하여 페이지를 렌더링하겠습니다. 아래 지시사항을 따라 App.js 컴포넌트를 수정해봅시다.\n\n- App.js 파일을 열고 Home 컴포넌트를 import 합니다.\n- App.js 파일의 return 메서드를 아래 코드에서와 같이 Home 엘리먼트를 포함하도록 업데이트합니다.\n\n```js\nimport React from 'react';\nimport './App.css';\nimport Home from './pages/Home';\n\nfunction App() {\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cHome /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n모든 파일을 저장하고 브라우저에서 localhost:3000 으로 이동해보세요. 결과는 아래 스크린샷과 같을 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_1.png\" /\u003e\n\n저희 이커머스 인터페이스를 만드는 데 정말 멋진 작업을 했네요. 하지만 아직 해야 할 작업이 많습니다. 예를 들어, 제품 설명은 더 적은 단어로 작성되어야 하며 각 카드에 제품별로 이동할 수 있는 링크가 있어야 합니다. 그래서 useParams 훅을 적용할 것입니다.\n\n# 세 번째 부분 — useParams 훅 적용하기\n\nuseParams 훅을 사용하면 각 제품에 대한 고유 ID를 통해 액세스 권한을 갖는 친숙한 인터페이스를 만들 수 있습니다. useParams 훅은 React-router-dom 패키지와 함께 제공됩니다. 따라서 우리는 이를 적용하기 전에 react-router-dom에서 useParams 훅을 가져와야 합니다. 시작해봅시다.\n\n\n\n## 단계 1: 제품 상세 페이지 만들기\n\n제품 상세 페이지는 각 제품의 고유 ID에 따라 완전한 세부 정보를 포함하고 렌더링할 것입니다. 아래 지침은 제품 상세 페이지를 만드는 데 도움이 됩니다.\n\n- 페이지 폴더에 ProductDetail.js 파일을 만듭니다.\n- ProductDetail.js 파일을 열고 다음 내용을 가져옵니다:\n\n- component 폴더에서 Products 컴포넌트\n- 객체 비구조화를 사용하여 react-router-dom에서 useParams.\n\n\n\n3. return 메소드가 있는 ProductDetail 함수를 생성하세요.\n\n4. ProductDetail 함수 내에서 return 메소드 이전에 useParams 메소드에 `id` 를 할당하세요. 아래 코드 예시를 참고해보세요.\n\n```js\nlet { id } = useParams()\n```\n\n5. product 변수를 생성하고 find 메소드에 할당하세요. 예시:\n\n\n\n```js\nconst product = Products.find(product =\u003e String(product.id) === id);\n```\n\n여기서 find 메서드를 사용하여 각 제품의 id를 일치시켜 제품의 다른 세부 정보에 액세스할 수 있습니다.\n\n6. ProductDetails 함수의 return 메서드에서 섹션 태그를 만드세요. 섹션 태그는 중괄호 안에 id에 할당된 키 속성을 포함해야 합니다.\n\n7. 코드 아래처럼 다른 태그를 만드세요.\n\n\n\n8. ProductDetail.js 파일을 내보내기하세요.\n\nProductDetail.js 파일의 최종 코드는 아래 예시 코드와 같이 될 것입니다.\n\n```js\nimport { useParams } from \"react-router-dom\";\nimport Products from \"../components/Products\";\n\nfunction ProductDetail() {\n \n   let { id } = useParams();\n    const product = Products.find(product =\u003e String(product.id) === id);\n\n    return (\n        \u003c\u003e\n            \u003csection key={id} className=\"details-section\"\u003e\n                \u003cimg src={product.image} alt=\"\"\u003e\u003c/img\u003e\n                \u003cdiv\u003e\n                    \u003ch3\u003e{product.title}\u003c/h3\u003e\n                    \u003cp\u003e{product.description}\u003c/p\u003e\n                \u003c/div\u003e\n            \u003c/section\u003e\n       \u003c/\u003e\n    )\n}\n\nexport default ProductDetail;\n```\n\n## 단계 2: productDetail 페이지 스타일링\n\n\n\n\n```css\n.details-section {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 30px;\n  margin: 90px;\n  font-size: 1.3rem;\n}\n```\n\n## 단계 3: 라우트 생성\n\n라우트는 URL 경로로 콘텐츠에 액세스하는 것을 안내합니다. App.js 파일에 모든 필요한 라우트를 생성할 것입니다. 아래 지침은 라우트를 생성하는 데 도움이 됩니다.\n\n\n\n- App.js 파일을 열고 다음을 가져와주세요:\n  - 페이지 폴더에서 ProductDetail,\n  - react-router-dom에서 Routes 및 Route.\n\n- App.js 함수의 반환 방법을 다음과 같이 업데이트하세요:\n  1. Routes 태그를 만드세요.\n  2. Routes 태그 사이에 두 개의 Route 태그를 생성하세요. Routes와 Route의 차이를 알아두어 혼동하지 않도록 주의하세요.\n  3. 각 Route 태그에는 path와 element 속성이 포함되어야 합니다.\n\n아래 코드 예시를 참고하세요.\n\n```js\nimport React from 'react';\nimport './App.css';\nimport Home from './pages/Home';\nimport ProductDetails from './pages/ProductDetails';\nimport { Route, Routes } from 'react-router-dom';\n\nfunction App() {\n\n  return (\n\n    \u003cdiv className=\"App\"\u003e\n\n      \u003cRoutes\u003e\n        \u003cRoute path='/' element={\u003cHome /\u003e}\u003e\u003c/Route\u003e\n        \u003cRoute path='/product/:id' element={\u003cProductDetails /\u003e}\u003e\u003c/Route\u003e\n      \u003c/Routes\u003e\n\n    \u003c/div\u003e\n\n  );\n}\n\nexport default App;\n```\n\n주의할 점:\n\n\n\n- 첫 번째 Route 경로는 `/`에 할당되어 있으며, 기본 URL 경로를 나타냅니다. 기본 URL 경로는 Home 컴포넌트를 표시합니다.\n- 두 번째 Route 경로는 product로 할당되어 있으며, 플레이스홀더 :id를 가지고 있습니다.\n\n## 단계 4: card.js 컴포넌트 수정\n\n아래 지침은 card 컴포넌트를 수정하는 방법을 안내합니다.\n\n- Card.js 파일을 열고 react-router-dom에서 Link를 import합니다.\n- card 컴포넌트의 return 메소드 안에 p 태그 사이에 Link 태그를 삽입합니다. Link 태그는 to 속성을 포함해야 합니다. 아래 코드 예시를 참고하세요.\n\n\n\n```js\n\u003cLink to={`/product/${id}`}\u003e자세히 보기\u003c/Link\u003e\n```\n\n우리 `to` 속성의 값은 backtick (` )과 템플릿 리터럴 ( `$''` )을 사용하여 id의 값을 포함합니다. 각 매개변수의 URL 경로에 접근하는 표준 방법입니다.\n\n3. 슬라이스(Slice) 메서드를 사용하여 설명 단어를 줄입니다.\n\n최종 카드 컴포넌트 코드는 아래의 코드 예시와 같이 되어야 합니다.```\n\n\n\n```js\nimport { Link } from \"react-router-dom\";\nimport Products from \"./Products\";\n\nconst Card = () =\u003e {\n\n   const productItems = Products.map(store =\u003e{\n        const {id, title, description, image} = store;\n        return(\n            \u003cdiv key={ id } className=\"card\"\u003e\n                \u003cimg src={image} alt=\"\"\u003e\u003c/img\u003e\n                \u003ch3\u003e{title}\u003c/h3\u003e\n                \u003cp\u003e{description.slice(0, 100)}\u003cLink to={`/product/${id}`}\u003e더 보기\u003c/Link\u003e\u003c/p\u003e\n            \u003c/div\u003e\n        )\n    })\n\n    return (\n        \u003c\u003e\n            \u003csection className=\"card-section\"\u003e\n                {productItems}\n            \u003c/section\u003e\n        \u003c/\u003e\n    );\n};\n\nexport default Card;\r\n```\n\n모든 파일을 저장하고 브라우저로 이동하세요. 아래의 gif 이미지는 프로젝트 결과물을 보여줍니다. 이제 각 제품은 고유한 ID를 통해 액세스할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1380/0*_YFGAyjrfYyg-Q7b.gif\" /\u003e\n\n# 결론\n\n\n\n이 문서는 useParams 훅에 대한 포괄적인 지식을 제공합니다. useParams 훅은 여러 매개변수가 필요한 React 애플리케이션을 만드는 데 필수적입니다. 따라서 사용자 친화적인 방식으로 각 매개변수에 쉽게 액세스할 수 있습니다.\n\n독서해 주셔서 감사합니다. 이 튜토리얼이 유용하게 활용되기를 바랍니다.\n\n# 추가 자료\n\n- React Router: useParams() 훅 사용법\n- React Router에서 useParams 훅 사용 방법\n\n\n\n감사합니다. 끝까지 읽어주셔서 감사합니다. 저와 이 출판물을 팔로우해 주시기를 고려해 주세요. 전 세계적으로 무료 프로그래밍 교육을 더 democrazing 하고 있는 Stackademic을 방문하여 더 많은 정보를 얻어보세요.","ogImage":{"url":"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png"},"coverImage":"/assets/img/2024-05-12-PracticalStepsonHowtoApplytheuseParamsHookofReactRouter_0.png","tag":["Tech"],"readingTime":15},{"title":"리액트 JS란 무엇인가요 왜 사용하나요","description":"","date":"2024-05-12 22:02","slug":"2024-05-12-WHATISREACTJSWHYWEUSEIT","content":"\n\n![React.js](/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png)\n\n# React.js가 무엇인가요?\n\nReact.js 또는 간단히 React는 Facebook에서 개발한 오픈 소스 JavaScript 라이브러리입니다. 이는 사용자 인터페이스를 구축하는 데 사용되며 특히 단일 페이지 애플리케이션(SPA)의 경우 UI가 매우 동적이고 반응적이어야 할 때 사용됩니다.\n\nReact.js의 핵심은 선언적이고 컴포넌트 기반의 UI 구축 방식을 제공합니다. 이는 개발자가 상태를 관리하는 캡슐화된 컴포넌트를 생성할 수 있으며, 데이터가 변경될 때 React가 효율적으로 업데이트하고 렌더링하는 컴포넌트를 관리할 수 있습니다. React는 가상 DOM(Document Object Model)을 사용하여 렌더링 성능을 최적화하며 필요한 컴포넌트만 업데이트하고 전체 페이지를 다시 렌더링하지 않도록합니다.\n\n\n\n# React.js를 사용해야 하는 이유\n\nReact.js가 개발자들 사이에서 엄청 인기를 얻은 몇 가지 이유가 있어요:\n\n- 컴포넌트 기반 아키텍처: React의 컴포넌트 기반 아키텍처는 재사용성과 모듈성을 장려해요. 개발자들은 작고 독립적인 컴포넌트를 만들고 이를 조합하여 복잡한 UI를 구축할 수 있어서 유지 및 확장이 쉽습니다.\n- 가상 DOM: React는 가상 DOM을 사용하여 UI를 메모리에 나타내어 효율적으로 업데이트하고 렌더링할 수 있어요. 브라우저의 DOM을 직접 조작하는 대신, React는 실제 DOM을 업데이트하는 가장 효율적인 방법을 계산하여 성능을 향상시킵니다.\n- 선언형 구문: React는 선언형 구문을 사용하는데, 개발자들이 현재 애플리케이션 상태에 기반하여 UI가 어떻게 보일지를 설명합니다. 이는 명령형 방식에 비해 코드를 이해하고 추론하기 쉽게 만들어줘요.\n- 일방향 데이터 바인딩: React는 단방향 데이터 흐름을 따르는데, 데이터가 부모에서 자식 컴포넌트로 props를 통해 흐릅니다. 데이터 변경을 추적하고 디버깅하기 쉬워져서 예상치 못한 부작용이 발생할 가능성을 줄입니다.\n- 큰 생태계: React는 핵심 기능을 보완하는 라이브러리, 도구 및 확장 프로그램들이 풍부한 생태계를 가지고 있어요. 이는 Redux와 같은 상태 관리 라이브러리, React Router와 같은 라우팅 솔루션, Jest와 React Testing Library와 같은 테스팅 프레임워크를 포함합니다.\n- 커뮤니티 지원: React에는 지속적인 개발에 기여하는 개발자들의 활성화된 커뮤니티가 있어요. 이들은 포럼, 블로그, 소셜 미디어를 통해 지식을 공유하고 튜토리얼, 코스, 플러그인과 같은 가치 있는 리소스를 만듭니다.\n\n# React.js 역사와 배경\n\n\n\n리액트.js는 처음 Facebook의 소프트웨어 엔지니어인 Jordan Walke에 의해 개발되었고, 2011년 Facebook의 뉴스피드에서 처음으로 배포되었습니다. 이후 2013년에 오픈 소스로 공개되어 Facebook 외부의 개발자들이 라이브러리를 사용하고 기여할 수 있게 되었습니다.\n\n릴리스 이후 리액트.js는 큰 변화를 거쳐 사용자 인터페이스를 구축하는 데 가장 인기 있는 JavaScript 라이브러리 중 하나가 되었습니다. Facebook, Instagram, Netflix, Airbnb 등과 같은 대규모 기업들을 포함해 모든 규모의 기업에서 널리 채택되고 있습니다.\n\n리액트의 성공은 리액트 네이티브(React Native)의 개발로 이어졌습니다. React Native는 React.js 원칙을 활용하여 크로스 플랫폼 모바일 애플리케이션을 개발하기 위한 프레임워크입니다. React Native를 사용하면 JavaScript로 모바일 앱을 작성하면서 네이티브 플랫폼 기능을 활용할 수 있어, 웹 개발 이상으로 React의 영향력을 확장하고 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png"},"coverImage":"/assets/img/2024-05-12-WHATISREACTJSWHYWEUSEIT_0.png","tag":["Tech"],"readingTime":2},{"title":"넥스트js 파일 이름 규칙은 ESLint 규칙으로 확인됩니다","description":"","date":"2024-05-12 22:01","slug":"2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png\" /\u003e\n\n현재 프론트엔드 환경에는 많은 네이밍 규칙이 있어요. 예를 들어, 컴포넌트는 파스칼 케이스로 작성해야 하지만, 훅 관련 파일은 카멜 케이스로 작성해야 하며, 훅 프로세스는 파일 이름의 시작에 use를 붙여야 해요. 예를 들어, useHooks.ts 같은 식이죠. 프론트엔드 환경 뿐만 아니라 여러분의 환경에도 암묵적인 네이밍 규칙이 있을 거라고 확신해요.\n\n여기 네이밍 규칙 예시가 있어요. 여러분은 프로젝트에서 네이밍 규칙을 어떻게 관리하나요?\n\n```js\nsrc\n├ app // app 디렉터리 아래는 케밥 케이스입니다.\n│ ├ layout.tsx\n│ ├ not-found.tsx\n│ ├ page.tsx\n│ └ about\n│   ├ layout.tsx\n│   └ page.tsx\n├ components // components 디렉터리 아래는 파스칼 케이스입니다.\n│ └ Button\n│   ├ Button.tsx\n│   ├ Button.modules.css\n│   └ index.tsx\n└ features\n  └ serach-feature\n    ├ components\n    │ └ SerchField\n    ├ hooks // hooks 디렉터리 아래는 카멜 케이스입니다. 파일 이름에 \"use\"를 추가해주세요.\n    │ └ useSearch.tsx\n    ├ providers // providers 디렉터리 아래는 카멜 케이스입니다. 파일 이름에 \"Provider\"를 추가해주세요.\n    │ └ searchProvider.tsx\n    └ utils\n```\n\n\n\n그래서 ESLint 규칙과 통합하는 아이디어를 생각해냈고, Next.js 프로젝트에 완벽하게 어울리는 eslint-plugin-validate-filename을 만들었어요. 이 아이디어를 공유해주시면 피드백과 이슈를 주시면 감사하겠어요.\n\nVSCode는 이렇게 오류를 표시할 거에요.\n\n![image](/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_1.png)\n\n# 설치\n\n\n\n먼저 필요한 패키지를 설치하세요.\n\n```js\nnpm install --save-dev eslint-plugin-validate-filename\n```\n\n다음으로 ESLint 구성을 추가하세요. 구성 파일에는 .eslintrc 및 .eslint.json이 포함됩니다. validate-filename은 네이밍 규칙을 가지고 있습니다.\n\n```js\n{\n  \"plugins\": [\"validate-filename\"],\n  \"rules\": {\n    \"validate-filename/naming-rules\": [\n      \"error\",\n      {\n        \"rules\": [\n          // 여기에 규칙을 추가하세요\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n\n# 컴포넌트 네이밍 규칙\n\n컴포넌트를 만들 때는 PascalCase를 사용하는 것이 좋습니다. 이 규칙은 컴포넌트와 일반 HTML 요소를 쉽게 구별할 수 있도록 도와줍니다.\n\n케이스에는 camel, pascal, snake, kebab, flat이 있습니다. 대상은 폴더 경로의 이름이어야 합니다. index 이름은 무시됩니다.\n\n```js\n{\n  \"case\": \"pascal\",\n  \"target\": \"**/components/**\"\n}\n```\n\n\n\n여기 유효한 예와 유효하지 않은 예가 있어요.\n\n```js\n/components/App/App.tsx // 유효함\n/components/App/app.tsx // 유효하지 않음\n```\n\n# 앱 라우터 네이밍 규칙\n\nNext.js의 앱 라우터 디렉터리 아래에서는 케밥 케이스로 작성하는 것이 좋습니다. 파일 이름이 고정되어 있고 모두 케밥 케이스이기 때문입니다.\n\n\n\n규칙은 다음과 같습니다.\n\n```js\n{\n  \"case\": \"kebab\",\n  \"target\": \"**/app/**\",\n}\n```\n\n다음은 유효한 예와 유효하지 않은 예시입니다.\n\n```js\n/app/page.tsx // 유효\n/app/not-found.tsx // 유효\n/app/appRoute.tsx // 유효하지 않음\n```\n\n\n\n앱 디렉토리 내에서 특정 파일 이름으로의 사용을 제한하려면 patterns에서 규칙을 설정하여 이를 달성할 수 있습니다.\n\n```js\n{\n  \"case\": \"kebab\",\n  \"target\": \"**/app/**\",\n  \"patterns\": \"^(page|layout|loading|error|not-found|route|template).tsx$\"\n}\n```\n\n# 훅 네이밍 규칙\n\n훅 디렉토리 아래에 파일 이름에 use를 추가하세요. use를 포함하면 해당 파일이 훅 로직을 포함한다는 것을 나타내게 됩니다.\n\n\n\n```js\n{\n  \"case\": \"camel\",\n  \"target\": \"**/hooks/**\",\n  \"patterns\": \"^use\"\n}\n```\n\n위는 유효하고 무효한 예제입니다.\n\n```js\n/hooks/useHooks.ts // 유효\n/hooks/hooks.tsx // 무효\n```\n\nProviders 하위 요소에 대해서도 동일한 규칙을 만들 수 있습니다.\n\n\n\n```js\n{\n  \"case\": \"camel\",\n  \"target\": \"**/providers/**\",\n  \"patterns\": \"^[a-zA-Z]*Provider\"\n}\n```\n\n# 요약\n\n마지막으로, 파일 네이밍 규칙에 대한 ESLint 규칙을 구현하면 프로젝트의 가독성, 유지보수성 및 깨끗함이 향상됩니다. 프론트엔드 개발에서 여러 암시적 네이밍 규칙이 존재하므로 eslint-plugin-validate-filename을 사용하여 규칙을 수립하는 것이 좋습니다.\n\n피드백과 이슈를 제공해 주시면 감사하겠습니다.```\n\n\n\n최종 설정\n\n```js\n{\n  \"plugins\": [\"validate-filename\"],\n  \"rules\": {\n    \"validate-filename/naming-rules\": [\n      \"error\",\n      {\n        \"rules\": [\n          {\n            \"case\": \"pascal\",\n            \"target\": \"**/components/**\"\n          },\n          {\n            \"case\": \"kebab\",\n            \"target\": \"**/app/**\",\n            \"patterns\": \"^(page|layout|loading|error|not-found|route|template).tsx$\"\n          },\n          {\n            \"case\": \"camel\",\n            \"target\": \"**/hooks/**\",\n            \"patterns\": \"^use\"\n          },\n          {\n            \"case\": \"camel\",\n            \"target\": \"**/providers/**\",\n            \"patterns\": \"^[a-zA-Z]*Provider\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```","ogImage":{"url":"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png"},"coverImage":"/assets/img/2024-05-12-NextjsfilenamingconventionsarecheckedwithESLintrules_0.png","tag":["Tech"],"readingTime":4},{"title":"WP Bones 140 출시 완료","description":"","date":"2024-05-12 22:00","slug":"2024-05-12-WPBones140isout","content":"\n\nWP Bones 애호가 여러분, 환영합니다! 최신 버전인 1.4.0이 출시되어 WordPress 개발 환경을 새로운 차원으로 끌어올릴 다양한 흥미로운 기능과 개선 사항이 도입되었습니다. 이 릴리스의 주요 내용을 자세히 살펴보면 WordPress 프로젝트를 구축하고 관리하는 방식을 혁신할 것으로 예상되는 핵심 기능에 대해 알아봅시다.\n\n![이미지](/assets/img/2024-05-12-WPBones140isout_0.png)\n\n## ReactJS 애플리케이션 개발 소개\n\nWP Bones 1.4.0에서 가장 주목할 만한 추가 기능 중 하나는 WordPress 환경 내에서 완전한 ReactJS 애플리케이션을 생성할 수 있는 기능입니다. Material UI 및 React Router Dom과 같은 인기 있는 패키지를 비롯한 다양한 추가 패키지를 지원하여 동적이고 인터랙티브한 웹 애플리케이션을 만들 수 있는 가능성이 이제 끝없이 펼쳐집니다. 경험 많은 React 개발자이든 초보자이든, 이 통합은 프로젝트를 위한 창의적인 가능성의 새로운 영역을 열어줍니다.\n\n\n\n실제로 확인해 보세요\n\n# 향상된 버전 관리\n\n개선된 PHP Bones 버전 명령어로 버전 및 릴리스 관리가 더욱 간단하고 견고해졌습니다. 이 업데이트는 패치 및 사전 릴리스 처리를 최적화하여 작업 흐름을 더욱 원활하게하고 버전 관리 프로세스를 보다 세밀하게 제어할 수 있도록 합니다. 변경사항을 추적하거나 새로운 배포에 대비할 때 이 향상된 기능을 활용하면 개발 주기를 보다 원활하게 만들고 생산성을 높이는 데 큰 도움이 될 것입니다.\n\n문서 자세히 보기\n\n\n\n# 새롭게 갱신된 설명서\n\n이 기능 업그레이드에 추가로, WP Bones 1.4.0은 문서를 크게 개선하여 플랫폼의 기능을 쉽게 활용하고 탐색할 수 있도록 만들었습니다. 새로운 ReactJS 애플리케이션에 대한 섹션은 WordPress 프로젝트에서 React의 힘을 활용하려는 개발자들을 위한 포괄적인 안내서 역할을 합니다. 게다가, 서비스 제공 업체에 대한 개선된 문서는 자세한 통찰과 예제를 제공하여 사용자가 이 핵심 기능을 최대한 활용할 수 있도록 돕습니다.\n\n# 결론\n\nWP Bones 1.4.0의 출시로 WordPress 개발 환경이 영원히 변화했습니다. ReactJS의 통합과 향상된 버전 관리 및 개선된 문서의 결합은 WP Bones를 현대적인 웹 개발을 위한 선도적인 프레임워크로 고착시킵니다. 혁신적인 웹 애플리케이션을 구축하려는 개발자이든 온라인 존재감을 향상시키려는 비즈니스이든, WP Bones 1.4.0은 오늘날의 디지털 생태계에서 성공하기 위해 필요한 도구와 자원을 제공합니다.\n\n\n\n포럼에 참여해주세요\n\nWP Bones 1.4.0으로 업그레이드하고 워드프레스 프로젝트에 대한 가능성의 세계를 열어보세요. 혁신과 다양성이 만나는 곳, WP Bones로 웹 개발의 미래를 받아들이세요.\n\nWP Bones와 함께 워드프레스 개발 여정을 최대로 이용하는 방법에 대한 업데이트, 자습서 및 통찰력을 기대해주세요. 즐거운 코딩하세요!\n\nWP Bones를 읽어주셔서 감사합니다! 새 게시물을 받으려면 무료로 구독하고 제 작업을 지원해주세요.\n\n\n\n구독 완료\n\n한 가지 더...\n\nhttps://twitter.com/wpbonesx/","ogImage":{"url":"/assets/img/2024-05-12-WPBones140isout_0.png"},"coverImage":"/assets/img/2024-05-12-WPBones140isout_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트에서 REST API 인터셉터 사용하기","description":"","date":"2024-05-12 21:59","slug":"2024-05-12-RESTAPIInterceptorsinReact","content":"\n\n![이미지](/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png)\n\n리액트는 프론트엔드 자바스크립트 라이브러리로 잘 알려져 있어요. 리액트의 주요 책임은 웹 애플리케이션의 사용자 인터페이스(UI)를 개발하는 것이에요. 애플리케이션의 UI 구성 요소와 상태를 관리할 때, 리액트는 외부 소스나 백엔드 시스템과 상호 작용하기 위해 API(응용 프로그램 프로그래밍 인터페이스)에 의존해요. API는 서버에서 데이터를 가져오는, 사용자 상호 작용에 기반한 UI 업데이트, 인증, 권한 부여, 그리고 데이터 조작과 같은 다양한 기능을 다룰 때 핵심적인 역할을 합니다.\n\n리액트에서의 API 사용 예시:\n\n- 데이터 가져오기: 리액트 컴포넌트들은 데이터베이스나 제3자 서비스와 같은 외부 소스로부터 데이터를 가져오기 위해 API 요청을 합니다.\n- 서버 통신: API는 프론트엔드가 서버와 상호 작용할 수 있는 표준화된 방법을 제공하여, 폼 제출, 데이터 업데이트, 정보 검색 등의 작업을 수행할 때 사용돼요.\n- 상태 관리: API는 리액트 컴포넌트가 서버로부터 상태를 업데이트하거나 검색할 수 있도록 요청을 보낼 수 있게 하여 상태 관리를 용이하게 해줍니다.\n- 인증과 권한 부여: API는 리액트 컴포넌트가 로그인, 등록, 권한 부여 프로세스를 다루기 위해 인증 서버와 통신할 수 있도록 지원해줘요.\n- 제3자 통합: API를 통해 제3자 서비스와 통합하고, 소셜 미디어 공유, 결제 처리, 외부 데이터 소스 접근과 같은 기능들을 사용할 수 있게 됩니다.\n\n\n\n가능한 접근 방법 중에서 리액트 애플리케이션에서 REST API를 소비하는 두 가지 인기있는 방법은 액시오스(Axios) (프로미스 기반 HTTP 클라이언트)와 페치 API(Fetch API) (브라우저에 내장된 웹 API)입니다. 이 글에서는 액시오스와 페치 API에 대한 인터셉터를 어떻게 구현할 수 있는지에 대해 논의해보겠습니다.\n\n인터셉터는 리액트 자체에서 제공하는 기능은 아니지만, 주로 액시오스나 페치 API와 같은 라이브러리와 함께 사용됩니다. 우리는 다음과 같은 이유로 인해 리액트에서 인터셉터가 필요합니다.\n\n- 중앙화된 요청 처리: 개발자가 전역 요청 핸들러를 정의하여 나가는 HTTP 요청을 가로채는 방법을 제공합니다. 이 접근 방식은 헤더 추가, 로깅, 오류 처리를 여러 요청에 일관되게 적용할 때 유용합니다.\n- 전역 오류 처리: 응답 인터셉터를 정의함으로써 개발자는 서버에서의 오류 응답을 가로채고 사용자에게 오류 메시지를 표시하거나 오류 유형에 따라 특정 작업을 수행하는 등 일관된 오류 처리 로직을 구현할 수 있습니다.\n- 요청 변형: 서버로 보내기 전에 요청 구성 또는 페이로드를 수정하는 것을 가능하게 합니다. 이를 통해 인증 토큰 추가, 요청 데이터 변형, 사용자 지정 요청 로직 적용 등의 작업을 수행할 수 있습니다.\n- 응답 변형: 응답이 호출 코드로 전달되기 전에 응답 데이터나 구성을 수정합니다. 이 기능은 응답 데이터 구문 분석, 데이터 구조 정규화, 특정 응답 조건 처리 등과 같은 작업에 유용합니다.\n- 권한 처리: 리액트 애플리케이션 내에서 권한 로직을 관리하는 데 자주 사용됩니다. 나가는 요청을 가로채어 개발자가 인증 토큰이나 자격 증명을 확인하고 이를 요청 헤더에 추가하여 허가된 요청이 서버로 전송되도록 할 수 있습니다.\n\n이 글의 나머지 부분에서는 가장 인기 있는 REST API 메서드인 액시오스와 페치 API에 인터셉터를 구현하는 방법을 살펴보겠습니다.\n\n\n\n## Axios를 위한 인터셉터 구현\n\nAPI 헤더에 API 키를 추가해야 하는 상황이라고 가정해봅시다. 인터셉터를 사용하여 이를 어떻게 처리할 수 있는지 알아봅시다.\n\n이를 위해 axiosRequestInterceptor라는 인터셉터를 만들었는데, 이는 axios API에 API 키를 추가합니다. 이는 일종의 공통 함수이므로 모든 REST 엔드포인트에서 재사용할 수 있습니다.\n\n```js\nimport axios from \"axios\";\n\nexport const axiosRequestInterceptor = (baseEndPoint, apiKey) =\u003e {\n  const api = axios.create({\n    baseURL: baseEndPoint, // API의 기본 URL\n  });\n\n  api.interceptors.request.use(\n    (config) =\u003e {\n      // 만약 API 키를 사용한다면\n      if (apiKey) {\n        config.headers[\"x-api-key\"] = apiKey;\n      }\n      // 만약 Bearer 토큰을 사용한다면\n      // config.headers.Authorization = `Bearer ${apiKey}`;\n\n      return config;\n    },\n    (error) =\u003e {\n      return Promise.reject(error);\n    }\n  );\n\n  return api;\n};\n```\n\n\n\n헤더에 대한 API 키 이외에도 인터셉터를 사용하여 Axios 요청에 대한 타임아웃 및 콘텐츠 유형과 같은 다양한 추가 사항을 할 수 있습니다. \n\n요청 뿐만 아니라 axios.interceptors.response를 사용하여 Rest 엔드포인트의 응답에 대한 인터셉터를 정의할 수도 있습니다. 자세한 내용은 Axios 문서를 참조해주세요.\n\n## Fetch API Intercepters\n\nFetch API에 대한 인터셉터를 구현하는 두 가지 방법이 있습니다.\n\n\n\n- Monkey patching 방법 사용\r\n- fetch-intercept 라이브러리 사용\r\n\r\nMonkey patching 방법을 사용하여 Fetch API 인터셉터 구현하기\r\n\r\nMonkey patching은 프로그래밍에서 사용되는 기술로, 기존 코드나 기능을 수정하는 것을 의미합니다. Fetch API에 대한 인터셉터를 구현할 때 monkey patching은 fetch()와 같은 Fetch API 메서드의 동작을 업데이트하여 인터셉터를 삽입하고 사용자 정의 기능을 추가하는 것을 의미합니다.\r\n\r\n다음은 Monkey patching 방법을 사용하여 엔드포인트에 API 토큰을 헤더에 추가하는 방법을 나타냅니다.\n\n\n\n```js\n익스포트된 상수 fetchAPIRequestInterceptor을 사용하여 Fetch API 인터셉터를 설정합니다. endPoint, apiKey 및 config를 매개변수로 받습니다. \n\n```js\nexport const fetchAPIRequestInterceptor  = async (endPoint, apiKey, config) =\u003e {\n    const { fetch: originalFetch } = window;\n    window.fetch =  async (...args) =\u003e {\n        //setting the api token for the header\n        config.headers = config.headers || {};\n        config.headers[\"x-api-key\"] = apiKey;\n        config.method = 'GET';\n        try {\n            const response = await originalFetch(endPoint, config);\n            return response;\n        } catch (error) {\n            console.error('Error fetching data:', error);\n            throw error;\n        }\n    };  \n}\n```\n\nfetch-intercept npm 라이브러리를 사용한 Fetch API 인터셉터입니다.\n\n먼저, 아래 명령어를 사용하여 npm 라이브러리를 설치해야 합니다.\n\n```js\nnpm i fetch-intercept\n```\n\n\n\n인터셉터는 Fetch API 호출을 위해 인터셉터를 등록할 수 있는 register 메서드를 사용하여 정의할 수 있습니다. 이는 request, requestError, response, responseError 콜백을 포함하는 객체를 가지고 있습니다. 여기서 register 메서드는 인터셉터를 등록할 때 사용하는 unregister 메서드를 반환합니다. 필요하지 않을 때 인터셉터를 등록 해제할 수 있습니다. 아래는 인터셉터 구현을 나타냅니다.\n\n```js\nimport * as fetchIntercept from 'fetch-intercept';\n\nexport const fetchInterceptRequestInterceptor  = async (endPoint, apiKey) =\u003e {\n    const unregister = fetchIntercept.register({\n        request: function (url, config) {\n            config = { ...config };\n            const modifiedUrl = endPoint;\n            config.headers = config.headers || {};\n\n            // API 토큰 설정\n            return [modifiedUrl, config];\n        },\n      \n        requestError: function (error) {\n            return Promise.reject(error);\n        },\n      \n        response: function (response) {\n            return response;\n        },\n      \n        responseError: function (error) {\n            return Promise.reject(error);\n        },\n      }); \n}\n```\n\n## 요약\n\n인터셉터는 응용 프로그램에서 요청이나 응답을 가로채고 필요에 따라 수정할 수 있는 함수 또는 미들웨어입니다. 이를 통해 인증, 로깅 또는 오류 처리와 같은 일반적인 작업을 중앙 처리할 수 있습니다. React 컨텍스트에서는 Axios와 Fetch API 모두를 위해 인터셉터를 정의할 수 있습니다. 본문에서는 Axios 및 Fetch API에 대한 인터셉터를 어떻게 구현하는지 설명합니다.\n\n\n\n내 Git 저장소에서 구현 세부사항을 참조하세요.","ogImage":{"url":"/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png"},"coverImage":"/assets/img/2024-05-12-RESTAPIInterceptorsinReact_0.png","tag":["Tech"],"readingTime":6}],"page":"57","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"57"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>