<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/57" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" href="/post/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" href="/post/2024-05-27-NestJSTheGoodTheBadandTheUgly"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" href="/post/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 개발자가 반드시 알아야 하는 10가지 도구" href="/post/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 개발자가 반드시 알아야 하는 10가지 도구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 개발자가 반드시 알아야 하는 10가지 도구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 개발자가 반드시 알아야 하는 10가지 도구</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript와 TypeScript 비교 정리" href="/post/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript와 TypeScript 비교 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript와 TypeScript 비교 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript와 TypeScript 비교 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">53<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs에서 CRON 작업으로 일정 관리하기" href="/post/2024-05-27-SchedulingTaskswithCRONJobsinNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs에서 CRON 작업으로 일정 관리하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs에서 CRON 작업으로 일정 관리하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs에서 CRON 작업으로 일정 관리하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Hooks useState, useEffect를 제대로 사용하는 방법" href="/post/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Hooks useState, useEffect를 제대로 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Hooks useState, useEffect를 제대로 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Hooks useState, useEffect를 제대로 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " href="/post/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 </strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" href="/post/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" href="/post/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">글의 가능성을 높이는 단어 카운터와 텍스트 분석기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link posts_-active__YVJEi" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기","description":"","date":"2024-05-27 18:22","slug":"2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram","content":"\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 살펴보겠습니다. 우리는 프로젝트 구조를 설계하여 관심사를 분리하고 코드베이스를 깔끔하게 유지할 것입니다.\n\n## 목차\n\n- 소개\n- 프로젝트 구조\n- 환경 설정\n- Python 이메일 발신 스크립트 생성\n- Node.js 컨트롤러 생성\n- 라우트 설정\n- 서버 생성\n- 결론\n\n### 1. 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 경우에는 Node.js 애플리케이션에서 Python의 기능을 활용하고 싶을 수 있습니다. 이 튜토리얼은 Node.js 백엔드에서 Python을 사용하여 이메일을 보내는 방법을 보여줍니다. 우리는 Node.js의 child_process 모듈에서 spawn 함수를 사용하여 Python 스크립트를 호출할 것입니다.\n\n# 2. 프로젝트 구조\n\n다음은 우리 프로젝트의 구조입니다:\n\n\nserver/\n  ├── Controller/\n  │   └── mailController.js\n  ├── route/\n  │   └── mailRoute.js\n  ├── Utils/\n  │   └── mailSender.py\n  └── server.js\n  └── .env\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 환경 설정하기\n\n## 단계 1: Node.js 프로젝트 초기화\n\n```js\nmkdir email-sender\ncd email-sender\nnpm init -y\nnpm install express dotenv body-parser\n```\n\n## 단계 2: 환경 변수 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉토리에 다음 내용을 사용하여 .env 파일을 만들어주세요:\n\n```js\nGMAIL_USER=your-email@gmail.com\nGMAIL_APP_PASSWORD=your-app-password\n```\n\nyour-email@gmail.com 및 your-app-password를 실제 Gmail 주소 및 앱 비밀번호로 교체해주세요. Gmail 보안 탭 내에서 앱 비밀번호를 얻을 수 있습니다.\n\n# 4. 파이썬 이메일 발신 스크립트 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUtils 디렉토리에 mailSender.py라는 Python 스크립트를 만들어주세요:\n\n```python\nimport smtplib\nimport os\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\ndef send_email(to_email, subject, body):\n    from_email = os.environ['GMAIL_USER']\n    app_password = os.environ['GMAIL_APP_PASSWORD']\n\n    msg = MIMEMultipart()\n    msg['From'] = from_email\n    msg['To'] = to_email\n    msg['Subject'] = subject\n    msg.attach(MIMEText(body, 'plain'))\n\n    try:\n        server = smtplib.SMTP('smtp.gmail.com', 587)\n        server.starttls()\n        server.login(from_email, app_password)\n        text = msg.as_string()\n        server.sendmail(from_email, to_email, text)\n        server.quit()\n        print(\"이메일을 성공적으로 전송했습니다.\")\n    except Exception as e:\n        print(f\"이메일 전송에 실패했습니다: {str(e)}\")\n\nif __name__ == \"__main__\":\n    import sys\n    to_email = sys.argv[1]\n    subject = sys.argv[2]\n    body = sys.argv[3]\n    send_email(to_email, subject, body)\n```\n\n# 5. Node.js Controller 생성\n\nController 디렉토리에 mailController.js라는 파일을 만들어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nexports.sendEmail = (req, res) =\u003e {\n  const { to, subject, body } = req.body;\n  const pythonProcess = spawn('python3', [path.join(__dirname, '../Utils/mailSender.py'), to, subject, body]);\n\n  pythonProcess.stdout.on('data', (data) =\u003e {\n    console.log(`stdout: ${data}`);\n  });\n\n  pythonProcess.stderr.on('data', (data) =\u003e {\n    console.error(`stderr: ${data}`);\n  });\n\n  pythonProcess.on('close', (code) =\u003e {\n    console.log(`child process exited with code ${code}`);\n    res.send('Email sent');\n  });\n};\n```\n\n# 6. Setting Up the Routes\n\n라우트 설정하기\n\nroute 디렉토리에 mailRoute.js라는 파일을 만드세요:\n\n```js\nconst express = require('express');\nconst router = express.Router();\nconst mailController = require('../Controller/mailController');\n\nrouter.post('/send-email', mailController.sendEmail);\n\nmodule.exports = router;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 서버 생성\n\n루트 디렉토리에 server.js라는 파일을 생성하세요:\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst dotenv = require('dotenv');\nconst mailRoute = require('./route/mailRoute');\n\ndotenv.config();\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.use('/api', mailRoute);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n# 8. 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 소개했습니다. 프로젝트 구조 설정, 환경 변수 구성, Python 전자 메일 발신자 스크립트 작성, 그리고 Node.js 백엔드를 설정하여 spawn 함수를 사용하여 Python 스크립트를 호출하는 방법에 대해 다뤘습니다. 이 접근 방식은 Node.js와 Python의 강점을 활용하여 유연하고 강력한 이메일 발송 솔루션을 제공합니다.\n\n이 단계를 따라가면 Python 스크립트를 Node.js 애플리케이션에 매끄럽게 통합하여 두 언어의 최상의 기능을 활용할 수 있습니다.\n\n더 나아가 향상된 이메일 처리 및 추가 기능을 위해 Python의 smtplib의 능력과 다양한 이메일 콘텐츠 및 첨부 파일을 처리하는 방법을 탐색하고 싶을 것입니다. 즐거운 코딩 하세요!","ogImage":{"url":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png"},"coverImage":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png","tag":["Tech"],"readingTime":5},{"title":"네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유","description":"","date":"2024-05-27 18:21","slug":"2024-05-27-NestJSTheGoodTheBadandTheUgly","content":"\n\n## 다음 프로젝트에 NestJS를 선택하시겠습니까?\n\n![이미지](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png)\n\n지난 몇 년 동안 수백, 수천, 심지어 수백만 명의 유럽 고객에 의해 활용된 여러 애플리케이션을 NestJS를 사용하여 개발했습니다. 이러한 애플리케이션은 다양한 규모의 팀(스타트업, 스케일업, 기업 조직)에서 구축되었습니다. 모듈화된 단일체에서 이벤트 기반 마이크로서비스, GraphQL 및 REST까지 NestJS를 사용하여 개발했습니다. 그러나 모든 좋은 면이 있는 동시에 나쁜 면과 심지어 추악한 면이 있습니다.\n\n본 기사에서는 이 기간 동안 NestJS를 사용한 후 내 생각을 공유하려고 합니다. 개발자, 기술 리더 및 팀 리더가 NestJS 사용 중 발생할 수 있는 잠재적인 문제를 예상하고 해결하는 데 필요한 도구를 제공하는 것이 목표입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 좋은 점\n\n다양한 크기의 팀에서 깨끗한 코드에 대한 다른 의견과 응용프로그램이 완료되었을 때의 정의에 대한 다른 의견을 가지고 일해 왔습니다. 회사마다, 팀마다, 심지어 사람마다 다르게 다양합니다. 팀 내 개인의 의견은 종종 주관적이며, 이로 인해 개발 가이드라인과 코딩 스타일을 형성하기 어렵게 만들 수 있습니다. 실제로, 모든 팀이 언젠가는 다이어그램이 나타내는 것처럼 동일한 학습 곡선 단계를 따릅니다.\n\n![Diagram](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_1.png)\n\n여기서 Nest가 실제로 가치를 증명합니다. Nest는 팀을 특정 방향으로 안내하고 이미 작업을 대부분 처리하는 디자인 패턴을 제공합니다. Nest는 매우 주관적이며, 그것이 좋은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팀용 Nest의 가치는 팀 간 일관성 및 코드베이스의 일관성에서 그 자체를 입증합니다. 프레임워크를 사용하면 GraphQL 애플리케이션에 실제로 참여할 수 있으며, 내부를 깊이 파악할 필요 없이 즉시 사용할 수 있습니다. Nest는 훌륭한 코드 예제들을 제공하여 이를 가능하게 만듭니다.\n\n비즈니스가 빠르게 움직이는 가운데, 비즈니스 방향성에 따라 유연하게 이동할 수 있는 개발 프레임워크를 사용하는 것은 큰 장점입니다. Nest를 사용하면 팀이 온보딩 프로세스보다는 제품 출시에 집중할 수 있습니다. 새로운 개발자를 쉽게 통합할 수 있으며, 훌륭한 문서와 발전하는 커뮤니티 덕분에 신입 개발자도 즉시 기여하기 시작할 수 있습니다.\n\n# 아쉬운 점\n\n좋은 것과 함께 항상 나쁜 점이 있습니다. 솔직히 말해서 이것은 프레임워크 자체보다는 종종 팀 또는 개인이 프레임워크 내에서 개념을 오용하거나 오해하는 데 직접적으로 책임이 있는 경우가 많습니다. 하지만 내가 경험한 Nest의 몇 가지 부분에서 어떤 팀들이 반복해서 고민하는 부분을 지적하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원형 의존성 문제\n\nSooner or later each NestJS project will face the moment that circular dependencies are introduced. Not only can I relate from experience, but also Nest elaborates on this common issue and the community-built package nestjs-spelunker identifies similar problems as well (even though it’s focused a bit more on the dependency injection tree in general).\n\nThe circular dependency issue is quite a nasty one, that could potentially slow down the entire development team in the long run — if not solved properly. Fortunately, quite recently an article about circular dependencies was published by Trilon, where a core contributor of Nest points out a tool, called Madge, to identify circular dependencies early.\n\n## Swallowed logs on application startup\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n서로 의존하는 문제가 발생하는 경우 종종 나타나는 또 다른 문제는 시작 시 오류가 발생할 때 로그가 소진되는 것입니다. 이로 인해 개발자들이 실제로 무슨 일이 발생했는지 이해하기가 매우 어려워집니다.\n\n오류를 식별하기 위한 일반적인 접근 방식은 오류 발생 시 중단을 비활성화하고 오류 메시지를 다시 던지는 것입니다.\n\n이제 콘솔에 실제 오류가 기록됩니다.\n\n# 실망하기 쉬운 부분\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋은 것과 나쁜 것이 있는 것처럼 추악한 면도 존재합니다. 솔직히 말해서, 이것은 항상 프레임워크가 직접 책임지는 것은 아니라, 그보다는 팀 또는 개인들이 프레임워크 내의 개념을 오용하거나 오해하는 경우가 많습니다. 저는 함께 일한 팀들이 Nest의 일부 영역에서 여러 번 고민을 겪었다는 점을 지적하고 싶습니다.\n\n## 단위 테스트\n\nNest에서의 단위 테스트는 프레임워크 자체와 매우 통합되어 있습니다. 단위와 통합 테스트 사이의 차이를 정의하는 것은 팀마다, 심지어 사람마다 달라집니다. Nest 내에서 가장 작은 단위를 테스트하려면 상당한 부가 코드와 다양한 기술에 대한 지식이 필요합니다. 특히 새로운 개발자들에게는 테스트 작성이 복잡할 수 있습니다. 왜냐하면 Nest가 어떻게 의존성 주입 트리를 해결하는지에 대한 지식이 필요하기 때문입니다.\n\n간단한 애플리케이션을 테스트하려고 하면 아래와 비슷한 테스트 파일에 맞닥뜨리게 되실 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 실제 응용 프로그램에서 하나의 제공 업체에 대해 여러 종속성이 있을 것이며, 이로 인해 단위 테스트의 복잡성이 심각하게 증가할 것입니다. 시간이 지남에 따라 이러한 테스트는 팀이 단위 자체를 테스트하는 대신 어떻게 테스트를 작성하고 종속성 주입 트리를 구축할지에 더 많은 주의를 기울이면서 병목 현상이 될 수도 있습니다.\n\n다르게 할 수 있을까요? 물론, 테스트의 복잡성을 해결하는 팀들을 본 적이 있습니다. 클래스 메소드에 구현하는 대신 별도의 함수에 로직을 구현함으로써 테스트의 복잡성에 대응합니다. 이 접근 방식의 장점은 테스트가 간편해지고, 새로운 개발자가 JavaScript를 알고 있기 때문에 더 쉽게 익힐 수 있다는 것입니다. 다음을 고려해 보세요:\n\n모든 좋은 면에는 단점이 따르지만, 이러한 접근 방식의 구현으로 단위 테스트의 복잡성을 해결할 수 있을 뿐 아니라 다른 일면에서도 타협 사항이 있을 수 있습니다.\n\n## 동적 컨트롤러의 부재\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest에는 강력한 프로바이더 개념이 함께 제공됩니다. 이러한 프로바이더는 사용자 정의된 것이며 어떤 형태든 될 수 있습니다. 프로젝트가 더 성숙해지면 이러한 프로바이더는 매우 유용해집니다. 하지만 Nest의 의존성 주입 트리를 해결하는 방법에 대해 알아야 하는 개발자들에게는 어느 정도의 지식이 필요합니다.\n\n어쨌든, 실제로 필요한 것은 이러한 사용자 정의 프로바이더에 해당하는 사용자 정의 컨트롤러의 대응물입니다. Nest의 창시자에 따르면 이러한 컨트롤러는 Nest의 아이디어와 완전히 반대되지만, 프로젝트가 성장할 때 실제로 매우 유용합니다. Nest의 한계를 극복하기 위해 이러한 접근 방식을 구현할 수 있습니다. GitHub 쓰레드에 설명된 factory 접근 방식으로 구현할 수 있습니다:\n\n(하지만 오직 이것만이 아닌) Dynamic Modules를 통해 이 factory를 사용할 수 있습니다.\n\n하지만 모든 것은 좋음으로 이어지는 나쁨이 따르며, 이러한 접근 방식을 구현하면 동적 컨트롤러를 다루게 되는 반면에 한편으로는 Nest의 컨트롤러에 대한 의견이 있는 패턴을 포기하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nNest는 Node 랜드스케이프 내에서 정말 성숙하고 잘 문서화되어 있어서 많은 사람들이 선택하는 프레임워크입니다. 하지만 모든 것에는 좋은 점뿐만 아니라 나쁜 점과 가장 나쁜 점 등도 있습니다. 그러니 NestJS와 같은 프레임워크를 선택할 때 팀이 직면할 수 있는 잠재적인 문제점을 식별하는 것이 중요합니다.\n\n마지막 질문은 — 다음 프로젝트에 NestJS를 선택할 것인가. 음, 항상 그렇지만, 상황에 따라 다를거에요 ;)!","ogImage":{"url":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png"},"coverImage":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png","tag":["Tech"],"readingTime":5},{"title":"structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법","description":"","date":"2024-05-27 18:19","slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\" /\u003e\n\n# 1. 서문\n\n왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\n\n이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 객체를 깊은 복제하는 두 가지 방법\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png)\n\n내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\n\n```js\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  domNode: document.createElement(\"div\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 testData를 테스트 데이터로 사용할 것입니다.\n\n# 2.1# JSON.parse와 JSON.stringify\n\n이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\n\n```js\ntry {\n  const jsonClone = JSON.parse(JSON.stringify(testData))\n  console.log(jsonClone)\n} catch (error) {\n  console.log(\"JSON 메서드가 이 데이터를 처리할 수 없습니다\")\n}\n// 출력\n/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지를 포함한 코드 블록:\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nJSON.parse(JSON.stringify(obj))\n```\n\nMarkdown 형식으로 변환 된 표:\n\n# 2.2# lodash.clone\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\n\n```js\nconst _ = require('lodash')\nconst lodashClone = _.cloneDeep(testData)\nconsole.log(lodashClone)\n\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\n```\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png)\n\n# 3.1# 새로운 API: structuredClone?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\" /\u003e\n\nmdn에서 가져왔어요!\n\n2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\n\n아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  // function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  // domNode: document.createElement(\"div\")\n}\n\nconst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: undefined, // Functions are not cloned\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: undefined // DOM nodes are not cloned\n}\n*/\n\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\" /\u003e\n\n우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\n\n# 3.2# structuredClone의 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\n\n하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3.3 구조화된 복제의 일부 제한 사항\n\n친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\n\n함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\n\n```js\nconst obj = { fn: () =\u003e {} }\n\nstructuredClone(obj)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\" /\u003e\n\n```js\nconst obj = { domNode: document.createElement('div') }\n\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\" /\u003e\n\n이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 보내고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 개발자가 반드시 알아야 하는 10가지 도구","description":"","date":"2024-05-27 18:18","slug":"2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3","content":"\n\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png)\n\n10 fantastic web dev tools to level up your productivity and achieve your coding goals faster than ever.\n\nFrom breathtaking animations to rapid project creation, these tools will boost your workflow and make a lot of things easier.\n\n# 1. Fira Code\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 코드 편집기의 기본 글꼴은 지루해요 (예: Consolas).\n\n대신 이 아름다운 고정폭 글꼴을 사용해보세요:\n\n![](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_1.png)\n\n글꼴 리거처는 항상 뛰어난 특징 중 하나였어요 — 일반적인 코딩 문자 그룹을 세련된 직관적인 방식으로 병합하는 기능이에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVS Code의 글꼴을 변경하는 것은 매우 간단해요. 설정으로 이동해 보시면 \"자주 사용하는\" 옵션 중에 있을 거에요:\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_2.png)\n\n# 2. Barba JS\n\n웹페이지에 창의적인 멋을 더하고 사용자들을 기쁘게 만들어줄 멋진 전환 효과를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경된 텍스트입니다.\n\n![Image 1](https://miro.medium.com/v2/resize:fit:1400/0*X8tn7Y3ovmldXD_B.gif)\n\n당연히 클라이언트 측 라우팅을 사용하여 앱과 같은 경험을 제공합니다:\n\n![Image 2](https://miro.medium.com/v2/resize:fit:1400/0*hR4-kwV-JDKmMfW2.gif)\n\n# 3. Consola\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nConsolas을 방금 비난했는데, 그건 오타가 아니에요.\n\n이 아름다운 사용자 친화적인 콘솔 래퍼에요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_3.png)\n\n정교한 CLI 도구를 만드는 데 완벽해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_4.png\" /\u003e\n\n# 4. Preact JS\n\n리액트의 빠른 대안 - 10 배 이상 가볍습니다!\n\n들어가 보면 훅, JSX, 함수형 컴포넌트가 있습니다... 사실상 드롭인 대체물입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApp 컴포넌트를 확인해 보세요. 제 오른손으로 (아니면 왼손으로) 차이점을 거의 세어볼 수 있어요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_5.png)\n\n그리고 36,000개 이상의 GitHub 스타 — 진지하게 다룰 만하죠.\n\n# 5. Carbon\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사람들을 지루하게 만들 필요는 없어요. \n\n카보너(Carbon)를 사용하여 코드 스니펫을 아름답게 만들어 세상에 아름다움을 더해보세요:\n\n![Carbon](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_6.png)\n\n여러 가지 테마 중에서 선택할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_7.png\" /\u003e\n\n# 6. Firestore\n\n아마도 가장 좋은 NoSQL 데이터베이스입니다.\n\n넓고 무료 제한으로 새로운 아이디어를 시도하기에 훌륭합니다. 제가 여러 차례 해봤던 것처럼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표를 바꾼 것입니다.\n\n\n![Amazing Tools Part 1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_8.png)\n\nJS 개발자로써 매우 쉽고 직관적일 것입니다.\n\n![Amazing Tools Part 2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_9.png)\n\n심지어 클라이언트 측에서 사용하고 서버 요청을 완전히 건너뛸 수도 있습니다 — 비용 절감과 앱 성능 향상을 도모할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 이전에 무료 웹 소켓 서버를 사용한 적이 있었는데, 서버 측 보호장치와 완벽하게 작동했었어요.\n\n# 7. react-input-autosize\n\n입력 자동 조절: 만연한 웹 디자인 문제: \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*piupw_8S7ljNmEAL.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 이유로 react-input-autosize가 문제를 해결하고 나서 매주 수백만 번의 다운로드를 받게 되었습니다:\n\n![이미지1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_10.png)\n\n매우 쉽게 사용할 수 있는 UI 컴포넌트:\n\n![이미지2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8. VS Code용 라이브 서버\n\n정적 HTML 페이지를 신속하게 작성하는 강력한 도구 — 4800만 회 다운로드!\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_12.png)\n\n웹페이지를 수동으로 다시로드할 필요가 없습니다 — 브라우저에서 페이지를 불러오고 파일 내용과 화면을 동기화해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*XyzPx0jn9viCwfGa.gif)\n\n# 9. Parcel\n\nParcel: 아무 설정 없이 제로 설정으로 사용 가능한 번들러 - 고대의 Create React App보다 훨씬 더 유연합니다.\n\n모든 최신 웹 기술을 지원하며 우수한 성능을 자랑합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_13.png)\n\n우리는 index.jsx에서 새로운 React 앱을 빠르게 생성할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_14.png)\n\n# 10. SendGrid\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강력하고 인기 있는 API로 마케팅 및 거래 이메일을 보내고 99%의 전달률을 유지하세요.\n\n스팸 폴더를 건너뛰고 인박스에 직접 도착하는 아름다운, 매력적인 이메일을 디자인하세요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_15.png)\n\n# 마지막으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 생산성과 개발자의 삶의 질을 높이는 데 이 멋진 도구들을 사용해보세요.\n\n# 자바스크립트가 하는 모든 미친짓\n\n당신이 이미 모든 특이점을 알고 있다고 생각했을 때,\n자바스크립트가 하는 모든 미친짓은 자바스크립트의 세세한 함정과 잘 알려지지 않은 부분에 대한 흥미진진한 안내서로 귀하의 소중한 시간을 절약하면서 고통스러운 버그를 피하는 데 도움이 됩니다.\n\n오늘 무료 복사본을 받아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 코드입니다.\n\n\n![이미지 설명](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_16.png)\n","ogImage":{"url":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png"},"coverImage":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png","tag":["Tech"],"readingTime":5},{"title":"JavaScript와 TypeScript 비교 정리","description":"","date":"2024-05-27 18:10","slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years","content":"\n\n\n![2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png](/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png)\n\n이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\n\n다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\n\n많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JavaScript / ECMAScript (가장 오래된 것부터)\n- TypeScript (가장 오래된 것부터)\n\n# 내용\n\n# ECMAScript\n\n## 과거 (아직도 중요한 이전 소개들)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\n\n```js\n// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\n// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n\n// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) =\u003e accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n```\n\n- Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\n\n```js\nconst obj: { [index: string]: string } = {};\n\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\n\nconsole.log(symbolA.description); // \"a\"\n\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\n\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n\n// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n\n// for ... in을 사용할 때 키가 열거되지 않습니다.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ES2020\n\n- Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\n\n```js\n// 이전:\n// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\n// 속성에 쉽게 액세스할 수 없습니다.\nconst object: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\n\n// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\nconst objectOld: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n\n// 새로운 방법:\n// 대신 선택적 연결을 사용할 수 있습니다.\nconst objectNew: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n\n// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\nconst array: string[] | undefined = Math.random() \u003e 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() =\u003e string) | undefined = Math.random() \u003e 0.5 ? undefined : () =\u003e 'test';\nconst result = func?.();\n```\n\n- 널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst value: string | undefined = Math.random() \u003e 0.5 ? undefined : 'test';\n\n// 이전:\n// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\nconst anotherValue = value || 'hello';\nconsole.log(anotherValue); // \"test\" 또는 \"hello\"\n\n// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\nconst incorrectValue = '' || 'incorrect';\nconsole.log(incorrectValue); // 항상 \"incorrect\"\nconst anotherIncorrectValue = 0 || 'incorrect';\nconsole.log(anotherIncorrectValue); // 항상 \"incorrect\"\n\n// 새로운 방법:\n// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\nconst newValue = value ?? 'hello';\nconsole.log(newValue) // 항상 \"hello\"\n\n// 이제 falsy 값들이 교체되지 않습니다.\nconst correctValue = '' ?? 'incorrect';\nconsole.log(correctValue); // 항상 \"\"\nconst anotherCorrectValue = 0 ?? 'incorrect';\nconsole.log(anotherCorrectValue); // 항상 0\n```\n\n- import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\n\n```js\nlet importModule;\nif (shouldImport) {\n  importModule = await import('./module.mjs');\n}\n```\n\n- String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst stringVar = 'testhello,testagain,';\n\n// 이전:\n// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n\n// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n\n// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\n// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n\n// 새로운 방법:\n// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n```\n\n- Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\n\n```js\nasync function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n\n// 이전:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// 하지만:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\n\n// 이전 해결 방법 (정말 최적이 아님):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e =\u003e { console.log(e); }),\n  success2().catch(e =\u003e { console.log(e); }),\n  fail1().catch(e =\u003e { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =\u003e { console.log(e); })])); // \"fail 2\"\n\n// 새로운 방법:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result =\u003e result.status === 'fulfilled')\n  .map(result =\u003e (result as PromiseFulfilledResult\u003cstring\u003e).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result =\u003e result.status === 'rejected').forEach(error =\u003e {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// 또는:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n```\n\n- BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n \u003c 2); // true\nconsole.log(2n \u003e 1); // true\nconsole.log(2 \u003e 2); // false\nconsole.log(2n \u003e 2); // false\nconsole.log(2n \u003e= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n\n\n- globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\n\n\nconsole.log(globalThis.Math); // Math Object\n\n\n- import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(import.meta.url); // \"file://...\"\n```\n\n- export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\n\n```js\nexport * as am from 'another-module'\n```\n\n```js\nimport { am } from 'module'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ES2021\n\n- String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\n\n```js\nconst testString = 'hello/greetings everyone/everybody';\n// 이전:\n// 첫 번째 인스턴스만 대체함\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n\n// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\n// 전역 플래그(/g)를 참고하세요.\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n\n// 새로운 기능:\n// replaceAll을 사용하면 더 명확하고 빠릅니다.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n```\n\n- Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// 그러나:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\n\n// 이전 수정 (정말 최적화되지 않음):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e =\u003e { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =\u003e { console.log(e); }), // \"fail 2\"\n  success1().catch(e =\u003e { console.log(e); }),\n  success2().catch(e =\u003e { console.log(e); })]));\n\n// 새로운:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n```\n\n- Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n\n// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\n// 또한 참고: getNewValue()가 실행되지 않습니다.\nx2 ??= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- Logical and assignment (\u0026\u0026=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx1 \u0026\u0026= getNewValue();\nconsole.log(x1) // undefined\n\n// 문자열은 참이므로 새 값이 x2에 할당됩니다.\nx2 \u0026\u0026= 'b';\nconsole.log(x2) // \"b\"\n```\n\n- 논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n\n// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx2 ||= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst ref = new WeakRef(element);\n\n// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// 객체가 더는 존재하지 않는 것 같습니다.\n```\n\n- 숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\n\n```js\nconst int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n```\n\n## ES2022\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\n\n```js\nasync function asyncFuncSuccess() {\n  return 'test';\n}\n\nasync function asyncFuncFail() {\n  throw new Error('Test');\n}\n\n// 이전:\n// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\n// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\n// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\ntry {\n  (async () =\u003e {\n    console.log(await asyncFuncSuccess()); // \"test\"\n    try {\n      await asyncFuncFail();\n    } catch (e) {\n      // 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\n      console.error(e); // Error: \"Test\"\n      throw e;\n    }\n  })();\n} catch (e) {\n  // 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\n  console.error(e);\n}\n\n// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\nconsole.log('Hey'); // \"Hey\"\n\n// 새로운:\n// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\nconsole.log(await asyncFuncSuccess()); // \"test\"\ntry {\n  await asyncFuncFail();\n} catch (e) {\n  console.error(e); // Error: \"Test\"\n}\n\n// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\nconsole.log('Hello'); // \"Hello\"\n```\n\n- #private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\n\n```js\nclass ClassWithPrivateField {\n  #privateField;\n  #anotherPrivateField = 4;\n\n  constructor() {\n    this.#privateField = 42; // 유효\n    delete this.#privateField; // 구문 오류\n    this.#undeclaredField = 444; // 구문 오류\n    console.log(this.#anotherPrivateField); // 4\n  }\n}\n\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // 구문 오류\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\n\n```js\nclass Logger {\n  static id = 'Logger1';\n  static type = 'GenericLogger';\n  static log(message: string | Error) {\n    console.log(message);\n  }\n}\n\nclass ErrorLogger extends Logger {\n  static type = 'ErrorLogger';\n  static qualifiedType;\n  static log(e: Error) {\n    return super.log(e.toString());\n  }\n}\n\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n\n// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\nconst log = new Logger();\n\nErrorLogger.log(new Error('Test')); // 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n\n// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\nconsole.log(log.log()); // log.log is not a function\n```\n\n- 클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\n\n```js\nclass Test {\n  static staticProperty1 = '속성 1';\n  static staticProperty2;\n  static {\n    this.staticProperty2 = '속성 2';\n  }\n}\n\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. `import ... from ... assert ' type: `json` '`로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\n\n```js\nimport json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n```\n\n- 정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\n\n```js\nconst matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n\n// 이전:\nconsole.log(matchObj?.index);\n\n// 새로운:\nif (matchObj) {\n  // 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\n  console.log(matchObj.indices[0]); // [9, 18]\n\n  // 캡처 그룹의 시작 및 끝 인덱스.\n  console.log(matchObj.indices[1]); // [9, 13]\n  console.log(matchObj.indices[2]); // [13, 18]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\n\n```js\nconsole.log([4, 5].at(-1)) // 5\n\nconst array = [4, 5];\narray.at(-1) = 3; // SyntaxError: Assigning to rvalue\n```\n\n- hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\n\n```js\nconst obj = { name: 'test' };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\n\n```js\ntry {\n  try {\n    connectToDatabase();\n  } catch (err) {\n    throw new Error('데이터베이스 연결에 실패했습니다.', { cause: err });\n  }\n} catch (err) {\n  console.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n```\n\n## 미래 (이미 TypeScript 4.9에서 사용 가능)\n\n- Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Person {\n  accessir name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name) // 'test'\n  }\n}\n\nconst person = new Person('test');\n```\n\n# TypeScript\n\n## 기초 (추후 소개를 위한 문맥)\n\n- 제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 `any` 또는 `unknown` 대신 이를 선호해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\n  return list[0];\n}\n\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n\n// WITH:\nfunction getFirst\u003cType\u003e(list: Type[]): Type {\n  return list[0];\n}\n\nconst first = getFirst\u003cstring\u003e(['test']); // typed as string\n\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List\u003cT extends string | number\u003e {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nconst list = new List\u003cstring\u003e();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List\u003cboolean\u003e(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n```\n\n## 과거 (아직도 유효한 이전 소개)\n\n- 유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\n\n```js\ninterface Test {\n  name: string;\n  age: number;\n}\n\n// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\ntype TestPartial = Partial\u003cTest\u003e; // typed as { name?: string | undefined; age?: number | undefined; }\n// Required 유틸리티 타입은 반대로 동작합니다.\ntype TestRequired = Required\u003cTestPartial\u003e; // typed as { name: string; age: number; }\n// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\ntype TestReadonly = Readonly\u003cTest\u003e; // typed as { readonly name: string; readonly age: string }\n// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\nconst config: Record\u003cstring, boolean\u003e = { option: false, anotherOption: true };\n// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\ntype TestLess = Pick\u003cTest, 'name'\u003e; // typed as { name: string; }\ntype TestBoth = Pick\u003cTest, 'name' | 'age'\u003e; // typed as { name: string; age: string; }\n// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\ntype TestFewer = Omit\u003cTest, 'name'\u003e; // typed as { age: string; }\ntype TestNone = Omit\u003cTest, 'name' | 'age'\u003e; // typed as {}\n// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters\u003ctypeof doSmth\u003e; // typed as [value: string, anotherValue: number]\n// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\ntype Return = ReturnType\u003ctypeof doSmth\u003e; // typed as string\n\n// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\n\n```js\n// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\ntype Flatten\u003cT\u003e = T extends any[] ? T[number] : T;\n\n// 요소 타입을 추출합니다.\ntype Str = Flatten\u003cstring[]\u003e; // string 타입으로 지정됨\n\n// 타입을 그대로 유지합니다.\ntype Num = Flatten\u003cnumber\u003e; // number 타입으로 지정됨\n```\n\n- 조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\n\n```js\n// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\ntype FlattenOld\u003cT\u003e = T extends any[] ? T[number] : T;\n\n// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\ntype Flatten\u003cT\u003e = T extends (infer Item)[] ? Item : T;\n\n// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\ntype GetReturnType\u003cType\u003e = Type extends (...args: any[]) =\u003e infer Return ? Return : undefined;\n\ntype Num = GetReturnType\u003c() =\u003e number\u003e; // number 타입으로 지정됨\n\ntype Str = GetReturnType\u003c(x: string) =\u003e string\u003e; // string 타입으로 지정됨\n\ntype Bools = GetReturnType\u003c(a: boolean, b: boolean) =\u003e void\u003e; // undefined 타입으로 지정됨\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 튜플 Optional Elements와 Rest: 튜플에서 `?`를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\n\n```js\n// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\nconst list: [number, number?, boolean?] = [];\nlist[0] // number 타입으로 지정됩니다\nlist[1] // number 또는 undefined 타입으로 지정됩니다\nlist[2] // boolean 또는 undefined 타입으로 지정됩니다\nlist[3] // Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\n\n// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\n// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\nfunction padStart\u003cT extends any[]\u003e(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\n\nconst padded = padStart([1, 2], 'test'); // [string, number, number] 타입으로 지정됩니다\n```\n\n- 추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\n\n```js\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// 추상 메소드는 확장 시 구현되어야 합니다.\nclass Cat extends Animal {} // 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n\n// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\nnew Animal(); // 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\n\nconst dog = new Dog().makeSound(); // \"woof\"가 출력됩니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\n\n```js\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass AnotherTest {\n  age: number;\n}\n\nfunction makeObj(n: ConstructsMyInterface) {\n  return new n('hello!');\n}\n\nconst obj = makeObj(Test); // Test로 타입 지정됨\nconst anotherObj = makeObj(AnotherTest); // 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\n```\n\n- ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\n\n```js\n// makeObj 함수에 생성자 인수를 얻고 싶다면?\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters\u003cConstructsMyInterface\u003e) {\n  return new test(...args);\n}\n\nmakeObj(Test); // 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\nconst obj = makeObj(Test, 'test'); // Test로 타입 지정됨\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 4.0\n\n- Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\n\n```js\n// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\n\n// 이전:\n// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat\u003cA\u003e(arr1: [A], arr2: []): [A];\ndeclare function concat\u003cA, B\u003e(arr1: [A], arr2: [B]): [A, B];\n// 이하 생략\n\n// 대신에 타입을 결합할 수 있습니다.\ndeclare function concatBetter\u003cT, U\u003e(arr1: T[], arr2: U[]): (T | U)[];\n// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\n\n// 새로운 기능:\n// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\ndeclare function concatNew\u003cT extends Arr, U extends Arr\u003e(arr1: T, arr2: U): [...T, ...U];\n\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\nconsole.log(tuple[6]); // 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\n```\n\n- Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\n\n```js\nclass Animal {\n  // 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\n  name;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name); // 문자열로 타입이 지정됨\n  }\n}\n```\n\n- JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n/** @deprecated 메시지 */\ntype Test = string;\n\nconst test: Test = 'dfadsf'; // 타입 오류: '테스트'가 사용되지 않습니다.\n```\n\n## TypeScript 4.1\n\n- 템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\n\n```js\ntype VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\n\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\nconst dir3: Direction = 'left top'; // 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\n\n// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\ndeclare function makeId\u003cT extends string, U extends string\u003e(first: T, second: U): `${Capitalize\u003cT\u003e}-${Lowercase\u003cU\u003e}`;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\n\n```js\n// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\n```\n\n- 재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\n\n```js\ntype Awaited\u003cT\u003e = T extends PromiseLike\u003cinfer U\u003e ? Awaited\u003cU\u003e : T;\n\ntype P1 = Awaited\u003cstring\u003e; // string으로 타입이 지정됩니다.\ntype P2 = Awaited\u003cPromise\u003cstring\u003e\u003e; // string으로 타입이 지정됩니다.\ntype P3 = Awaited\u003cPromise\u003cPromise\u003cstring\u003e\u003e\u003e; // string으로 타입이 지정됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * 다른 값의 복사본\n * @see originalValue\n */\nconst value = originalValue;\n```\n\n- tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\n\n```js\ntsc --explainFiles\n\n\u003c\u003coutput\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es5.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n...\noutput\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\n\n```js\nconst [_first, second] = [3, 5];\nconsole.log(second);\n\n// 심지어 더 짧게\nconst [_, value] = [3, 5];\nconsole.log(value);\n```\n\n## TypeScript 4.3\n\n- 속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Test {\n  private _value: number;\n\n  get value(): number {\n    return this._value;\n  }\n\n  set value(value: number | string) {\n    if (typeof value === 'number') {\n      this._value = value;\n      return;\n    }\n    this._value = parseInt(value, 10);\n  }\n}\n```\n\n- override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\n\n```js\nclass Parent {\n  getName(): string {\n    return 'name';\n  }\n}\n\nclass NewParent {\n  getFirstName(): string {\n    return 'name';\n  }\n}\n\nclass Test extends Parent {\n  override getName(): string {\n    return 'test';\n  }\n}\n\nclass NewTest extends NewParent {\n  override getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\n    return 'test';\n  }\n}\n```\n\n- static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이전 코드:\nclass Test {}\n\nTest.test = ''; // 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\n\n// 새로운 코드:\nclass NewTest {\n  static [key: string]: string;\n}\n\nNewTest.test = '';\n```\n\n- JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * {@link originalValue}의 복사본\n */\nconst value = originalValue;\n```\n\n## TypeScript 4.4\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\n\n```js\nclass Test {\n  name?: string;\n  age: number | undefined;\n}\n\nconst test = new Test();\ntest.name = undefined; // 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\ntest.age = undefined;\nconsole.log(test.age); // undefined\n```\n\n## TypeScript 4.5\n\n- Awaited`` 유형 및 Promise 개선: 새로운 Awaited`` 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\n// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\n// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\ntype P1 = Awaited\u003cstring\u003e; // 문자열로 타입 지정\ntype P2 = Awaited\u003cPromise\u003cstring\u003e\u003e; // 문자열로 타입 지정\ntype P3 = Awaited\u003cPromise\u003cPromise\u003cstring\u003e\u003e\u003e; // 문자열로 타입 지정\n```\n\n- Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\n\n```js\n// 이전:\n// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// 이 파일에 대해 두 개의 import 문이 필요했습니다.\n\n// 새로운:\n// 이제 이를 하나의 문으로 결합할 수 있습니다.\nimport { something, type SomeType } from './file';\n```\n\n- Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이전:\nconst obj = { name: 'foo', value: 9, toggle: false }; // { name: string; value: number; toggle: boolean; }으로 타입 지정됨\n// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\nobj.name = 'bar';\n\nconst tuple = ['name', 4, true]; // (string | number | boolean)[]으로 타입 지정됨\n// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\ntuple[0] = 0;\ntuple[3] = 0;\n\n// 새로운 방식:\nconst objNew = { name: 'foo', value: 9, toggle: false } as const; // { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\n// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\nobjNew.name = 'bar'; // 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\n\nconst tupleNew = ['name', 4, true] as const; // readonly [\"name\", 4, true]으로 타입 지정됨\n// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\ntupleNew[0] = 0; // 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\ntupleNew[3] = 0; // 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\n```\n\n- 클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*31No189vLt2Kdx5Ay_Ihig.gif\" /\u003e\n\n## TypeScript 4.6\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\n\n```js\ninterface AllowedTypes {\n  'number': number;\n  'string': string;\n  'boolean': boolean;\n}\n\n// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\ntype UnionRecord\u003cAllowedKeys extends keyof AllowedTypes\u003e = { [Key in AllowedKeys]:\n{\n  kind: Key;\n  value: AllowedTypes[Key];\n  logValue: (value: AllowedTypes[Key]) =\u003e void;\n}\n}[AllowedKeys];\n\n// 함수 logValue는 Record의 값만을 허용합니다.\nfunction processRecord\u003cKey extends keyof AllowedTypes\u003e(record: UnionRecord\u003cKey\u003e) {\n  record.logValue(record.value);\n}\n\nprocessRecord({\n  kind: 'string',\n  value: 'hello!',\n\n  // 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\n  // 이제 올바르게 오직 string으로 추론됩니다.\n  logValue: value =\u003e {\n    console.log(value.toUpperCase());\n  }\n});\n```\n\n- TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\n\n```js\ntsc --generateTrace trace\n\ncat trace/trace.json\n\u003c\u003c출력\n[\n{\"name\":\"process_name\",\"args\":{\"name\":\"tsc\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"thread_name\",\"args\":{\"name\":\"Main\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"TracingStartedInBrowser\",\"cat\":\"disabled-by-default-devtools.timeline\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"program\",\"ts\":...,\"name\":\"createProgram\",\"args\":{\"configFilePath\":\"/...\",\"rootDir\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"E\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"X\",\"cat\":\"program\",\"ts\":...,\"name\":\"resolveModuleNamesWorker\",\"dur\":...,\"args\":{\"containingFileName\":\"/...\"},\n...\n출력\n\ncat trace/types.json\n\u003c\u003c출력\n[{\"id\":1,\"intrinsicName\":\"any\",\"recursionId\":0,\"flags\":[\"...\"]},\n{\"id\":2,\"intrinsicName\":\"any\",\"recursionId\":1,\"flags\":[\"...\"]},\n{\"id\":3,\"intrinsicName\":\"any\",\"recursionId\":2,\"flags\":[\"...\"]},\n{\"id\":4,\"intrinsicName\":\"error\",\"recursionId\":3,\"flags\":[\"...\"]},\n{\"id\":5,\"intrinsicName\":\"unresolved\",\"recursionId\":4,\"flags\":[\"...\"]},\n{\"id\":6,\"intrinsicName\":\"any\",\"recursionId\":5,\"flags\":[\"...\"]},\n{\"id\":7,\"intrinsicName\":\"intrinsic\",\"recursionId\":6,\"flags\":[\"...\"]},\n{\"id\":8,\"intrinsicName\":\"unknown\",\"recursionId\":7,\"flags\":[\"...\"]},\n{\"id\":9,\"intrinsicName\":\"unknown\",\"recursionId\":8,\"flags\":[\"...\"]},\n{\"id\":10,\"intrinsicName\":\"undefined\",\"recursionId\":9,\"flags\":[\"...\"]},\n{\"id\":11,\"intrinsicName\":\"undefined\",\"recursionId\":10,\"flags\":[\"...\"]},\n{\"id\":12,\"intrinsicName\":\"null\",\"recursionId\":11,\"flags\":[\"...\"]},\n{\"id\":13,\"intrinsicName\":\"string\",\"recursionId\":12,\"flags\":[\"...\"]},\n...\n출력\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 4.7\n\n- Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"module\": \"es2020\"\n]\n...\n```\n\n- package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n\"type\": \"module\"\n...\n```\n\n- 인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\n\n```js\nclass List\u003cT\u003e {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nfunction makeList\u003cT\u003e(items: T[]): List\u003cT\u003e {\n  const list = new List\u003cT\u003e();\n  items.forEach(item =\u003e list.push(item));\n  return list;\n}\n\n// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\n// 이전:\n// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\nfunction makeStringList(text: string[]) {\n  return makeList(text);\n}\n\n// 새로운 방법:\n// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\nconst makeNumberList = makeList\u003cnumber\u003e;\n```\n\n- 추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\n// 이를 위해 조건부 유형을 사용할 수 있습니다.\n\n// 이전:\ntype FirstIfStringOld\u003cT\u003e =\n  T extends [infer S, ...unknown[]]\n    ? S extends string ? S : never\n    : never;\n\n// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\ntype FirstIfString\u003cT\u003e =\n  T extends [string, ...unknown[]]\n    // `T`에서 첫 번째 유형을 가져옵니다.\n    ? T[0]\n    : never;\n\n// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\n\n// 새로운 방식:\n// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\ntype FirstIfStringNew\u003cT\u003e =\n  T extends [infer S extends string, ...unknown[]]\n    ? S\n    : never;\n// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\n\ntype A = FirstIfStringNew\u003c[string, number, number]\u003e; // string으로 유형 지정\ntype B = FirstIfStringNew\u003c[\"hello\", number, number]\u003e; // \"hello\"로 유형 지정\ntype C = FirstIfStringNew\u003c[\"hello\" | \"world\", boolean]\u003e; // \"hello\" 또는 \"world\"로 유형 지정\ntype D = FirstIfStringNew\u003c[boolean, number, string]\u003e; // never로 유형 지정\n```\n\n- 유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\n\n```js\n// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\ninterface Animal {\n  animalStuff: any;\n}\n\ninterface Dog extends Animal {\n  dogStuff: any;\n}\n\n// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\ntype Getter\u003cT\u003e = () =\u003e T;\n\ntype Setter\u003cT\u003e = (value: T) =\u003e void;\n\n// Getter\u003cT1\u003e과 Getter\u003cT2\u003e 또는 Setter\u003cT1\u003e과 Setter\u003cT2\u003e가 일치하는지 확인하려면 분산에 따라 달라집니다.\nfunction useAnimalGetter(getter: Getter\u003cAnimal\u003e) {\n  getter();\n}\n\n// 이제 함수에 Getter를 전달할 수 있습니다.\nuseAnimalGetter((() =\u003e ({ animalStuff: 0 }) as Animal));\n// 당연히 작동합니다.\n\n// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\nuseAnimalGetter((() =\u003e ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\n\nfunction useDogGetter(getter: Getter\u003cDog\u003e) {\n  getter();\n}\n\n// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\nuseDogGetter((() =\u003e ({ animalStuff: 0 }) as Animal); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\n\nuseDogGetter((() =\u003e ({ animalStuff: 0, dogStuff: 0 }) as Dog);\n// 그러나 이 경우는 작동합니다.\n\n// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\nfunction setAnimalSetter(setter: Setter\u003cAnimal\u003e, value: Animal) {\n  setter(value);\n}\n\n// 동일한 유형의 Setter를 전달해도 작동합니다.\nsetAnimalSetter((value: Animal) =\u003e {}, { animalStuff: 0 });\n\nfunction setDogSetter(setter: Setter\u003cDog\u003e, value: Dog) {\n  setter(value);\n}\n\n// 여기도 마찬가지로 작동합니다.\nsetDogSetter((value: Dog) =\u003e {}, { animalStuff: 0, dogStuff: 0 });\n\n// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\nsetAnimalSetter((value: Dog) =\u003e {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) =\u003e void' is not assignable to parameter of type 'Setter\u003cAnimal\u003e'.\n\n// 이번에는 상황이 반대로 작동합니다.\nsetDogSetter((value: Animal) =\u003e {}, { animalStuff: 0, dogStuff: 0 });\n\n// 새로운 방법:\n// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\ntype GetterNew\u003cout T\u003e = () =\u003e T;\ntype SetterNew\u003cin T\u003e = (value: T) =\u003e void;\n```\n\n- moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n]\n...\n```\n\n```js\nimport * as foo from './foo';\n// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\n```\n\n- 에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*y45nF8mb-nfBuVIUPt7KJQ.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif)\n\n## TypeScript 4.9\n\n- `satisfies` 연산자: `satisfies` 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\n\n```js\n// 이전:\n// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\nconst obj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\n\n// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\nconst rgb1 = obj.fireTruck[0]; // 숫자로 타입 지정\nconst hex = obj.bush; // 문자열로 타입 지정\n\n// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\nconst oldObj: Record\u003cstring, [number, number, number] | string\u003e = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // Record\u003cstring, [number, number, number] | string\u003e 타입으로 정의됨\n// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\nconst oldRgb1 = oldObj.fireTruck[0]; // string 또는 number로 타입 지정\nconst oldHex = oldObj.bush; // string 또는 number로 타입 지정\n\n// 새롭게:\n// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\nconst newObj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} satisfies Record\u003cstring, [number, number, number] | string\u003e // { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\n// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\nconst newRgb1 = newObj.fireTruck[0]; // 숫자로 타입 지정\nconst newRgb4 = newObj.fireTruck[3]; // 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\nconst newHex = newObj.bush; // 문자열로 타입 지정\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif)\n\n## TypeScript 5.0\n\n- ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\n\n// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\n// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\n// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\n\n// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\nfunction logMethod\u003cThis, Args extends any[], Return\u003e(originalMethod: (this: This, ...args: Args) =\u003e Return, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n\n  function replacementFunction(this: This, ...args: Args) {\n    console.log(`LOG: 메서드 '${methodName}' 진입 중.`)\n    const result = originalMethod.call(this, ...args);\n    console.log(`LOG: 메서드 '${methodName}' 나감.`)\n    return result;\n  }\n\n  return replacementFunction;\n}\n\n// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\n// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\nclass Test {\n  @logMethod\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testObj = new Test();\n\n// 메서드를 실행하면 대체 메서드가 호출됩니다.\nconsole.log(testObj.doSomething()); // \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\n\n// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\nfunction logMethodCustom(customMessage: string) {\n  return \u003cThis, Args extends any[], Return\u003e(originalMethod: (this: This, ...args: Args) =\u003e Return, context: ClassMethodDecoratorContext) =\u003e {\n    const methodName = String(context.name);\n\n    function replacementFunction(this: This, ...args: Args) {\n      console.log(`${customMessage}: 메서드 '${methodName}' 진입 중.`)\n      const result = originalMethod.call(this, ...args);\n      console.log(`${customMessage}: 메서드 '${methodName}' 나감.`)\n      return result;\n    }\n\n    return replacementFunction;\n  }\n}\n\n// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\nclass TestCustom {\n  @logMethodCustom('테스트 로그')\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testCustomObj = new Test();\n\n// 메서드 실행시 모든 작업이 예상대로 작동합니다.\nconsole.log(testCustomObj.doSomething()); // \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\n\n// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\n// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\n// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\nfunction bindThis(_: unknown, context: ClassMethodDecoratorContext) {\nconst methodName = context.name;\nif (context.private) {\n  throw new Error(`'bound'는 ${methodName as string}과 같은 비공개 속성을 데코레이션할 수 없습니다.`);\n}\ncontext.addInitializer(function (this: any) {\n  const methodName = context.name;\n    if (typeof methodName === 'string') {\n      this[methodName] = this[methodName].bind(this);\n    }\n  });\n}\n\n// 바인딩하지 않은 상태로 한번 정의합니다.\nclass TestUnbound {\n  private returnVal = '작업 중';\n\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testUnboundObj = new TestUnbound();\n\n// 메서드에 다시 \"데코레이터\"를 적용합니다.\nclass TestBound {\n  private returnVal = '작업 중';\n\n  @bindThis\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testBoundObj = new TestBound();\n\n// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\nconst unboundFunc = testUnboundObj.doSomething;\nconsole.log(unboundFunc()); // 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\n\n// 그러나 바인딩하면 예상대로 작동합니다.\nconst boundFunc = testBoundObj.doSomething;\nconsole.log(boundFunc()); // \"작업 중\"\n```\n\n- const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\n\n- 타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\n\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"./tsconfig1.json\", \"./tsconfig2.json\"],\n...\n```\n\n- 모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\n\n```js\n// 열거형은 각 값마다 다른 타입을 만듭니다.\nenum Color {\n  Red, Green, Blue, Orange, Yellow, Violet\n}\n\n// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\n\n// 하지만:\n// 값이 동적으로 할당되면 고정된 값이 없습니다.\n// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\n// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\nenum ColorRandom {\n  Red = Math.random(),\n  Green = Math.random(),\n  Blue = Math.random(),\n  Orange = Math.random(),\n  Yellow = Math.random(),\n  Violet = Math.random()\n}\n\n// 그래서 이전에는 좁혀지지 못했습니다.\ntype PrimaryColorRandom = ColorRandom.Red | ColorRandom.Green | ColorRandom.Blue; // 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\n// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\n```\n\n- --moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"moduleResolution\": \"bundler\"\n]\n...\n```\n\n```json\nimport * as foo from './foo';\n// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\n```\n\n- 해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"allowImportingTsExtensions\": false,\n  \"resolvePackageJsonExports\": true,\n  \"resolvePackageJsonImports\": true,\n  \"allowArbitraryExtensions\": false,\n  \"customConditions\": [\"my-condition\"]\n  // 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\n  // TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\n]\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\n- **--verbatimModuleSyntax:** 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\n\n```js\n// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\nimport { Car } from './car';\n// 이 import는 아무 경우에나 제거될 것입니다.\nimport type { Car } from './car';\n// 이 import는 절대로 제거되지 않습니다.\nimport { logCar } from './car';\n\nexport function drive(car: Car) {\n  logCar(car);\n  // ...\n}\n```\n\n- **export type * 지원:** 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\nexport type * as am from 'another-module';\n// 또는 다시 기본 내보낸 것으로 제공합니다.\nexport type * from 'another-module';\n```\n\n```js\nimport type { am } from 'module';\n// 또는\nimport type { } from 'module';\n```\n\n- --build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\n\n```js\n# 이것은 `tsconfig.json`에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif)\n\n- Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif)","ogImage":{"url":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"},"coverImage":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png","tag":["Tech"],"readingTime":53},{"title":"Nodejs에서 CRON 작업으로 일정 관리하기","description":"","date":"2024-05-27 18:09","slug":"2024-05-27-SchedulingTaskswithCRONJobsinNodejs","content":"\n\nCRON 작업은 특정 간격으로 실행되는 작업을 예약하는 강력한 방법입니다. 이는 뉴스레터를 보내거나 정기 백업을 수행하거나 오래된 데이터를 정리하는 등 다양한 애플리케이션에 매우 유용합니다.\n\n예: 매주 월요일에 세일 소식을 기존 사용자에게 이메일로 보내고 싶다면, CRON이 그 역할을 수행해줄 것입니다.\n\n이것들은 OS에서 실행되는 주기적인 작업이며, 주어진 간격에 대해 OS에 명령을 내리고 특정 작업을 실행할 수 있습니다.\n\n이 블로그에서는 Node.js에서 CRON 작업을 설정하고 관리하는 방법을 알아볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCRON 작업을 왜 사용해야 하나요?\n\nCRON 작업은 다음과 같은 용도로 사용됩니다:\n\n- 백업하기: 정기적으로 데이터베이스나 파일을 백업합니다.\n- 로깅: 주기적으로 로그를 생성하고 저장합니다.\n- 통지: 이메일이나 푸시 알림을 사용자에게 보냅니다.\n- 정리: 데이터베이스에서 오래된 파일이나 레코드를 제거합니다.\n\nCRON 작업을 시작하려면, CRON 작업에 대한 좋은 지식이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Node.js\n- Npm\n\nNode.js에서 CRON 작업을 생성하는 방법\n\n1. Node.js 프로젝트 생성하기\n\n새로운 Node.js 프로젝트를 초기화하거나 기존 프로젝트를 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 패키지 설치\n\n사용할 패키지는 \"node-cron\" 입니다.\n아래 명령을 실행하여 패키지를 설치하세요.\n\n```js\nnpm install node-cron\n```\n\n3. 서버용 express 패키지 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n익스프레스 패키지를 설치하여 서버를 실행하거나 따르고자 하는 다른 방법을 사용할 수 있어요.\n\n지금은 익스프레스를 사용해보겠습니다.\n\n```js\nnpm install express \n```\n\n4. 크론 작업 작성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일정에 따라 실행되는 함수를 생성해보겠습니다. 이 예제에서는 콘솔에 메시지를 기록할 것입니다:\n\n```js\nfunction logMessage() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n```\n\n이제 함수를 만들었으니 주기적으로 실행해봅시다.\n\nCRON 작업의 문법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncron.schedule(\"* * * * *\", function() {\n    // Task\n});\n```\n\n별표에 대해 이해해 봅시다.\n\n이제 각 별표가 무언가를 정의합니다.\n\n예를 들어 ( * * * * * * )\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 표는 왼쪽부터 두 번째, 분, 시간, 월 별일, 월, 및 주를 나타냅니다.\n\n- 초 — 선택사항\n- 분: 0–59\n- 시간: 0–23\n- 월 별일: 1–31\n- 월: 1–12\n- 요일: 0–7 (0과 7은 모두 일요일을 나타냅니다)\n\n예시 :\n\n- ( * * * * * ) — 매 분 실행\n- ( 0 * * * * ) — 매 시간 실행\n- ( 0 15 15 * * ) — 매달 15일 오후 3시에 실행\n- ( * * 5 * * ) — 매월 5일에 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 번역해 드리겠습니다. 친근한 어조로 작성되었습니다.\n\n```js\n// 일반적인 임포트\nconst cron = require(\"node-cron\");\nconst express = require(\"express\");\n\n// 익스프레스 초기화\napp = express();\n\n// 당신이 만든 함수\nfunction message() {\n    console.log('작업이 실행됨:', new Date().toLocaleString());\n}\n\n// cron 스케줄\ncron.schedule(\"* * * * *\", function() {\n    message();\n});\n\napp.listen(3000);\n```\n\n위 스크립트를 'script.js'로 저장하세요.\n\n5. 스크립트를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드.js 애플리케이션을 시작하세요\n\n```js\nnode script.js\n```\n\n파일 이름에 맞게 파일 이름을 변경해주세요\n\n이렇게 하면 코드가 실행되고 함수가 주어진 간격대로 작동할 것입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약간의 예시\n\n다음은 CRON 작업의 몇 가지 더 예시입니다:\n\n- 자정에 매일 정리\n\n```js\ncron.schedule('0 0 * * *', () =\u003e {\n    console.log('자정에 작업을 실행중입니다');\n    // 여기에 정리 코드를 추가하세요\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 매주 월요일에 보고서 생성\n\n```js\ncron.schedule('0 9 * * 1', () =\u003e {\n    console.log('주간 보고서 생성 중');\n    // 보고서 생성 코드를 여기에 추가\n});\n```\n\n일부 최상의 사례\n\n- 에러 처리: CRON 작업에 적절한 에러 처리가 있어 예기치 않은 실패를 피할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncron.schedule('0 0 * * *', () =\u003e {\n    try {\n        // 작업 내용\n    } catch (err) {\n        console.error('CRON 작업 중 오류가 발생했습니다:', err);\n    }\n});\n```\n\n- Logging: 작업이 실행되는 시간과 결과를 추적하기 위해 로깅 구현 필요\n\n가능한 함정\n\n- 시간대 문제: CRON 작업은 서버의 시간대에 따라 실행됩니다. 애플리케이션이 전 세계 사용자를 대상으로 하는 경우 시간대 차이에 유의해야 합니다.\n- 동시성: 작업이 CRON 간격보다 오래 걸릴 경우, 작업이 예기치 않게 겹쳐지지 않도록 주의해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 절차를 따라서, Node.js 애플리케이션에서 CRON 작업을 효과적으로 활용하여 간단한 로깅부터 복잡한 데이터 처리까지 다양한 작업을 자동화할 수 있습니다.\n\n코딩해요!","ogImage":{"url":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png"},"coverImage":"/assets/img/2024-05-27-SchedulingTaskswithCRONJobsinNodejs_0.png","tag":["Tech"],"readingTime":4},{"title":"React Hooks useState, useEffect를 제대로 사용하는 방법","description":"","date":"2024-05-20 23:26","slug":"2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png\" /\u003e\n\n개발자로서, 우리는 종종 useState와 useEffect의 힘을 활용하여 애플리케이션에 생명을 불어넣는 황홀한 모험을 떠납니다. 그러나 흥분 속에, 조심하지 않는 이들을 덫에 걸릴 위험한 함정이 숨어 있습니다.\n\n걱정하지 마세요. 이 안내서에서는 이 위험한 영역을 통과하기 위한 코스를 제시하여 안전하게 항해할 수 있는 지식과 도구를 갖춰 드립니다. 함께 useState와 useEffect의 신비를 해독하고 모험을 떠나 봅시다! 🌟\n\n# useState\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n- 상태와 상태를 변경하는 함수를 반환합니다.\n- 초기 렌더링 중에 반환된 상태(state)는 첫 번째 인수로 전달된 값(initialState)과 동일합니다.\n- setState 함수는 상태를 업데이트하는 데 사용됩니다. 새 상태 값을 받아 구성 요소의 다시 렌더링을 대기열에 넣습니다.\n\n## 상태 업데이트\n\nsetState 메서드를 통해 상태를 업데이트할 수 있습니다. 예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst [count, setCount] = useState(0);\n\nfunction handleOnClick(){\n  setCount(prevCount =\u003e prevCount + 1)\n  setCount(prevCount =\u003e prevCount + 1)\n  setCount(prevCount =\u003e prevCount + 1)\n}\n\nreturn (\n    \u003cdiv\u003e\n        \u003cdiv\u003e\n            count: {count}\n        \u003c/div\u003e\n        \u003cbutton onClick={handleOnClick}\u003e\n            +1\n        \u003c/button\u003e\n    \u003c/div\u003e\n);\n```\n\n버튼을 클릭할 때 setCount(count + 1)을 세 번 연속 호출하면 인터페이스에 표시된 카운트 값이 +3이 아니라 +1씩만 증가하는 것을 알 수 있어요. 🔄\n\n## 함수형 업데이트\n\n새 상태를 이전 상태를 사용하여 계산해야 할 경우 setState에 함수를 전달할 수 있어요. 이 함수는 이전 상태를 받고 업데이트된 값을 반환할 거예요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsetCount(count =\u003e count + 1);\nsetCount(count =\u003e count + 1);\nsetCount(count =\u003e count + 1);\n```\n\n## 객체 업데이트\n\nuseState의 값이 객체일 때, 뷰가 업데이트되지 않는 상황이 발생할 수 있습니다. 예를 들어:\n\n```js\nconst [list, setList] = useState([0, 1, 2]);\nconst [userInfo, setUserInfo] = useState({\n  name: 'Bob',\n  age: 20\n});\n\nfunction handleOnClick(){\n  list.push(4);\n  list.push(4);\n  setList([...list]);\n\n  userInfo.name = 'Jack';\n  userInfo.age = 30;\n  setUserInfo({...userInfo});\n}\n\nreturn (\n    \u003cdiv\u003e\n        \u003cp\u003eName：{userInfo.name}\u003c/p\u003e\n        \u003cp\u003eAge：{userInfo.age}\u003c/p\u003e\n        \u003cp\u003elist.length: {list.length}\u003c/p\u003e\n        \u003cbutton onClick={handleOnClick}\u003e\n            Edit\n        \u003c/button\u003e\n    \u003c/div\u003e\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제의 원인: 문제는 React의 기본 얕은 비교 메커니즘에서 발생합니다. 상태가 객체인 경우 React는 객체의 참조(주소)를 스택에 저장합니다. setState를 호출하면 힙에있는 데이터가 수정되지만 스택의 참조는 변경되지 않습니다. React의 얕은 비교는 참조가 변경되었는지 확인하고, 그렇지 않으면 상태가 변경되지 않았다고 가정하고 페이지를 다시 렌더링하지 않습니다. 🔄\n\n해결책: 단순히 원본 객체의 주소를 변경하면 이를 다음과 같은 방법으로 달성할 수 있습니다.\n\n- 원본 객체를 복제합니다.\n- ES6 전개 연산자를 사용합니다.\n\n배열의 경우 배열의 자체 메서드 중 일부를 사용하여 깊은 복사를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Array.slice\nconst nextList = list.slice(0);\nnextList.push(\"slice\");\nsetList(nextList);\n\n// Array.concat\nconst nextList = list.concat();\nnextList.push(\"concat\");\nsetList(nextList);\n```\n\n요약: useState에서나 함수로 전달된 매개변수에서, 객체 자체를 직접 조작하지 말아야 합니다. 먼저 복사본을 만들고 그 복사본을 조작하여 예상치 못한 문제가 발생하는 것을 피하세요.\n\n## setState 이후 최신 값 가져올 수 없음\n\nsetState는 즉시 업데이트되지 않기 때문에, React는 업데이트 전 어느 시점에서 여러 setState 호출을 병합합니다. 따라서 setState 이후 최신 값을 가져오는 것은 어려울 수 있습니다. 다음은 몇 가지 접근 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. useRef를 사용해보세요: 이 방법은 useState의 값을 저장하지만 화면 업데이트를 트리거하지 않습니다.\n\n2. useEffect를 활용하세요: 효과적이지만 항상 적합한 방법은 아닙니다. 왜냐하면 이 방법은 모든 업데이트마다 내용을 실행하기 때문에 특정 요구에 부합하지 않을 수 있습니다.\n\n3. 함수 업데이트를 사용하세요.\n\n4. [useGetstate 훅 사용 원칙]: 최신 상태에 안전하게 액세스할 수 있는 hand를 제공하기 위해 useState값을 저장하는 useRef를 활용하세요. 🔄\n\n```js\nconst [count, setCount] = useState(0);\nconst countRef = useRef(0);\n\nuseEffect(()=\u003e{\n  console.log(\"useEffect\", count);\n},[count]);\n\nfunction handleOnClick(){\n  countRef.current += 1;\n  setCount(count + 1);\n  setCount((count) =\u003e {\n    return count;\n  });\n}\n\nreturn (\n    \u003cdiv\u003e\n        \u003cdiv\u003e\n            count: {count}\n        \u003c/div\u003e\n        \u003cbutton onClick={handleOnClick}\u003e\n            +1\n        \u003c/button\u003e\n    \u003c/div\u003e\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst useGetState = (initiateState) =\u003e {\n  const [state, setState] = useState(initiateState);\n  const stateRef = useRef(state);\n  stateRef.current = state;\n\n  const getState = useCallback(() =\u003e stateRef.current, []);\n\n  return [state, setState, getState];\n};\n```\n\n## 타이머에서 최신 값을 가져오기\n\n다음 예제에서는 뷰나 출력과 관계없이 count의 값은 항상 0입니다.\n\n```js\nconst [count, setCount] = useState(0);\nuseEffect(()=\u003e{\n  const interval = setInterval(() =\u003e {\n    setCount(count + 1);\n  },1000);\n  return () =\u003e {\n    clearInterval(interval);\n  }\n},[]);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제의 원인: 타이머가 생성된 후에 정리되지 않아 내부 상태가 항상 초기값을 반영하게 되었습니다.\n\n해결책:\n\n1️⃣ 타이머는 최신 상태를 캡처하기 위해 함수 업데이트를 사용하여 내부적으로 상태를 업데이트해야 합니다. 이렇게 하면 화면 업데이트 문제가 해결되지만 타이머는 여전히 0을 출력합니다.\n\n2️⃣ useEffect에서 상태를 종속성으로 활용합니다. 이를 통해 상태 변경 후에 타이머가 다시 생성되어 문제가 해결됩니다. 🔄\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useEffect\n\ncomponentDidMount와는 달리, useEffect 훅에 전달된 함수는 브라우저가 레이아웃 및 그리기를 완료한 후 지연 이벤트로 호출됩니다. 🎨 이 특성은 구독 설정 및 이벤트 처리와 같은 여러 일반 부작용 시나리오에 적합하게 만듭니다. 🔄 이러한 작업은 일반적으로 브라우저의 화면 업데이트를 차단해서는 안됩니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction Example(){\n  const [count, setCount] = useState(0);\n\n  useEffect(()=\u003e{\n    document.title = `You clicked \u0026{count} times`;\n  });\n\n    return (\n    \u003cdiv\u003e\n      \u003cp\u003eYou clicked {count} times\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\n        Click me\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nuseEffect는 첫 번째 렌더링 및 모든 업데이트를 포함한 모든 렌더링 후에 실행됩니다. React는 효과가 실행될 때마다 DOM이 업데이트된 것을 보장합니다. 🔄✨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 `useEffect`를 언제 실행할지 결정하는 두 번째 매개변수에 대한 설명입니다.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nexport default () =\u003e {\n   const [count, setCount] = useState(0);\n   const [number, setNumber] = useState(0);\n\n   // 의존성이 없는 경우, 매번 다시 렌더링될 때마다 실행됩니다.\n   useEffect(() =\u003e {\n     console.log(\"null\", count);\n   });\n\n   // 의존성 값이 비어 있으며, 처음 렌더링 후 한 번만 실행됩니다.\n   useEffect(() =\u003e {\n     console.log(\"[]\", count);\n   }, []);\n\n   // 의존성 값이 변경될 때만 실행되며, 첫 렌더링 시에도 실행됩니다.\n   useEffect(() =\u003e {\n     console.log(\"count\", count);\n   }, [count]);\n\n    function addCount() {\n    setCount(count + 1);\n    }\n  \n    function addNumber() {\n      setNumber(number + 1);\n    }\n  \n    return (\n      \u003cdiv\u003e\n        \u003cdiv\u003ecount: {count}\u003c/div\u003e\n        \u003cdiv\u003enumber: {number}\u003c/div\u003e\n        \u003cbutton onClick={addCount}\u003ecount+1\u003c/button\u003e\n        \u003cbutton onClick={addNumber}\u003enumber+1\u003c/button\u003e\n      \u003c/div\u003e\n    );\n}\n```\n\n## 의존성 값이 객체인 경우\n\n자주 객체를 사용하여 의존 관계를 설정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseEffect에서 객체의 변경 사항 처리하는 것이 중요합니다. 보통은 객체의 내용이 변경되었을 때 특정 작업을 수행하고 싶어합니다. 그러나 실제 비즈니스 개발 중에는 이유를 알 수 없는 문제가 발생할 수 있습니다. 몇 가지 흔한 현상을 살펴보겠습니다:\n\n🤔 객체의 내용이 분명히 변경되었는데, 왜 useEffect가 작동하지 않을까요?\n\n🤔 객체의 내용이 분명히 변경되지 않았는데, 왜 useEffect가 항상 작동할까요?\n\n이것은 말장난처럼 들릴 수 있지만, 이 문제의 본질은 객체가 참조 유형이라는 점에 있습니다. 아래 예시를 통해 보다 깊은 이해를 얻을 수 있습니다. 🔄✨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCase 1️⃣: 객체의 속성 값을 변경하면 useEffect가 트리거되지 않습니다\n\n```js\nconst [info, setInfo] = useState({\n  name: \"Bob\",\n  age: 20\n});\n\nuseEffect(() =\u003e {\n  console.log(\"info\", info);\n},[info]);\n\nfunction handleChangeName(e){\n  const value = e.target.value;\n  setInfo((info)=\u003e{\n    info.name = value;\n    return info;\n  });\n}\n\nreturn \u003cinput onChange={handleChangeName} /\u003e;\n```\n\n문제의 원인: setInfo를 호출할 때 입력 매개변수가 직접 변경됩니다. 이때 변경된 정보가 반환되며 그 참조가 변경되지 않습니다.\n\n참고: 어떠한 경우에도 입력 매개변수를 직접 변경하거나 상태 값을 직접 변경해서는 안 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n//잘못된 작성법\ninfo.name = value;\nsetInfo(info);\n\n//잘못된 작성법\nsetInfo((info) =\u003e {\n   info.name = value;\n   return info;\n});\n\n//올바른 작성법\nsetInfo({\n     ...info,\n     name: value\n});\n\n// 올바른 작성법\nsetInfo((info) =\u003e {\n   return {\n     ...info,\n     name: value\n   };\n});\n```\n\nCase 2️⃣: 부모 구성 요소의 객체 속성을 종속성으로 수락하여 useEffect가 자주 트리거됨\n\n컴포넌트를 개발할 때 일부 속성에 대한 기본 값을 설정하는 것이 종종 필요합니다. 전형적인 접근 방식은 props를 구조화하고 기본 값 동시에 할당하는 것입니다. 🛠️🔧\n\n```js\nconst {\n    count = 0,\n    list = []\n} = \n```\n \n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부모 컴포넌트에서 \"list\" 속성을 전달하지 않으면, 자식 컴포넌트는 부모 컴포넌트가 다시 렌더링될 때마다 다시 렌더링되어 useEffect가 각 렌더링마다 트리거됩니다. 🔃\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () =\u003e {\n  const [count, setCount] = useState(0);\n  \n  function handleOnClick(){\n    setCount((count) =\u003e count + 1);\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={hanleOnClick}\u003eadd\u003c/button\u003e\n      \u003cSubCom count={count} /\u003e\n    \u003c/div\u003e\n  );\n};\n\nconst SubCom  = (props) =\u003e {\n  const { list = [], count } = props;\n  \n  useEffect(() =\u003e {\n    console.log(list)\n  },[list])\n\n  return \u003cdiv\u003echild component: {count}\u003c/div\u003e;\n\n};\n\nexport default Com;\n```\n\n문제의 원인: 부모 컴포넌트가 업데이트될 때, 자식 컴포넌트가 다시 렌더링되어 각 렌더링마다 새로운 props.list 참조가 제공됩니다. 빈 배열로 표시되더라도, useEffect는 list의 참조 변경을 감지하여 실행됩니다. 복잡한 시나리오에서 빈번한 업데이트는 화면이 흰색으로 나타나는 문제를 야기할 수 있습니다.\n\n올바른 접근법: 컴포넌트가 사용된 곳에서 호환성 처리를 구현하고, 기본값을 직접 할당하는 것을 피하십시오. 🛠️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCase 3️⃣: 객체 내용이 변경되지 않았을 때 useEffect가 트리거되지 않도록 설정하고 싶어요.\n\n객체가 의존성으로 사용될 때, 해당 실행이 내용이 변경될 때 트리거되는 것이 일반적입니다. 그러나 useEffect의 본질은 참조 변경을 모니터하는 것이라, 실제 비즈니스 개발과 다소 일치하지 않을 수 있어요. 🤔\n\n- 비즈니스 레이어는 종종 일부 상태를 재설정하고, setState([]) 또는 setState('')을 사용합니다. 상태 값 자체가 [] 또는 ''일 수 있으며, 재설정 후 내용은 변경되지 않았지만 참조가 변경되어 useEffect가 트리거되는 경우가 생길 수 있어요.\n\n```js\nimport { useState, useEffect } from \"react\";\n\nconst Com = () =\u003e {\n   const [list, setList] = useState([]);\n\n   function reset() {\n     setList([]);\n   }\n\n   return (\n     \u003cdiv\u003e\n       \u003cp\u003e{list.join(\",\")}\u003c/p\u003e\n       \u003cbutton onClick={reset}\u003ereset\u003c/button\u003e\n       \u003cSubCom list={list} /\u003e\n     \u003c/div\u003e\n   );\n};\n\nconst SubCom = (props) =\u003e {\n   const { list } = props;\n\n   useEffect(() =\u003e {\n     console.log(list);\n   }, [list]);\n\n   return \u003cdiv\u003e자식 컴포넌트\u003c/div\u003e;\n};\n\nexport default Com;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션:\n\n- 오브젝트를 문자열로 변환한 뒤 useEffect의 의존성으로 사용하세요.\n\n```js\nuseEffect(() =\u003e {\n  console.log(list);\n}, [JSON.stringify(list)]);\n```\n\n- 문제를 해결하기 위해 훅의 useDeepCompareEffect을 사용하세요. 사용 방법은 useEffect와 동일하지만 deps는 lodash isEqual을 통해 깊게 비교됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nCase 4️⃣: 두 개의 useEffect 업데이트가 서로에게 의존하며 무한 업데이트로 인해 화면이 흰색으로 나타납니다.\n\n```js\nconst {\n     value,\n     defaultValue = 0.5,\n     onChange\n} = props;\n\nconst [innerValue, setInnerValue] = useState\u003cnumber\u003e(defaultValue);\n\n// useEffect1이라고 명명된 효과\nuseEffect(() =\u003e {\n     if (value !== undefined) {\n         setInnerValue(value);\n     }\n}, [value]);\n\n// useEffect2라고 명명된 효과\nuseEffect(() =\u003e {\n     onChange?.(innerValue);\n}, [innerValue]);\n```\n\n문제:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 🔍 첫 번째 로드 시, useEffect2가 트리거되어 onChange 메서드가 호출됩니다.\n- 🔄 비즈니스 레이어에서 값이 수동으로 변경되면, onChange도 트리거됩니다.\n\n올바르게 작성하는 방법:\n\n- 🛠️ 실제로 양식 값 변경을 수동으로 하는 경우, useEffect를 직접 사용하는 대신 innerValue의 변경 사항을 모니터링하기 위해 onChange를 호출하세요.\n\nCase 5️⃣: useRef 값을 모니터링하는데 의존하면, 때로는 업데이트가 트리거될 수 있지만 때로는 업데이트가 트리거되지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { useState, useEffect, useRef } from \"react\";\n\nexport default () =\u003e {\n   const [count, setCount] = useState(0);\n   const countRef = useRef(0);\n    \n   // Named useEffect1\n   useEffect(() =\u003e {\n     console.log(\"count\", count);\n   }, [count]);\n\n   // Named useEffect2\n   useEffect(() =\u003e {\n     console.log(\"countRef\", countRef);\n   }, [countRef.current]);\n\n  \n\n   return (\n     \u003cdiv\u003e\n       \u003cp\u003e{count}\u003c/p\u003e\n       \u003cbutton onClick={() =\u003e setCount((c) =\u003e c + 1)}\u003ebutton1\u003c/button\u003e\n       \u003cbutton onClick={() =\u003e (countRef.current += 1)}\u003ebutton2\u003c/button\u003e\n     \u003c/div\u003e\n   );\n};\n```\n\n현상:\n🔘 버튼1을 클릭하면 useEffect1이 실행됩니다.\n🔘 버튼2를 클릭하면 useEffect2가 실행되지 않습니다.\n🔘 버튼1을 다시 클릭하면 useEffect1과 useEffect2가 모두 실행됩니다.\n\n문제의 원인:\n🔍 상태가 변경될 때만 업데이트가 트리거됩니다. useState와 useReducer는 업데이트를 시작할 수 있는 유일한 훅입니다.\n\n사용 안내:\n📌 useRef의 값은 useRef의 변경으로 상태 변경이 필요한 경우가 확실한 경우에만 의존성으로 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\nReact 개발의 광활한 바다에서 useState와 useEffect는 우리의 애플리케이션에 생명과 기능을 부여할 수 있는 강력한 동료들입니다. 그러나 강력한 도구처럼, 그들만의 문제와 함정이 따릅니다.\n\n올바른 상태 업데이트를 보장하고 의존성과 부작용을 처리하는 등, 이 안내서는 React 개발의 위험한 지형을 안전하게 탐험하기 위해 필요한 지식과 전략을 제공했습니다.\n\n여정을 계속하면서 주의를 기울이고 철저하게 테스트하며, 동료 개발자로부터 지식을 얻거나 신뢰할 만한 자료를 참고하는 것을 꺼리지 마세요. useState와 useEffect를 잘 이해하고 인내심을 가지면 가장 어려운 React 프로젝트도 정복하고 우수한 애플리케이션을 구축할 수 있습니다. 즐거운 코딩하세요! 🚀🌟","ogImage":{"url":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png"},"coverImage":"/assets/img/2024-05-20-NavigatingPitfallsAGuidetoReactHooksuseStateuseEffect_0.png","tag":["Tech"],"readingTime":12},{"title":"5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 ","description":"","date":"2024-05-20 23:24","slug":"2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives","content":"\n\n파이썬 스크립트를 실행하는 방법이 궁금하거나 파이썬 애플리케이션을 서버에 배포하는 방법을 알고 싶거나, 파이썬 프로젝트에 대한 최상의 클라우드 호스팅 솔루션을 찾고 계신다면 망설이지 마세요.\n\n![이미지](/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png)\n\n본 비교에서는 네이티브 파이썬 지원을 제공하는 다섯 가지 인기 호스팅 플랫폼을 살펴볼 것입니다. 비교를 도와줄 이전 멘션되지 않은 Heroku가 마지막에 포함되어 있습니다.\n\n본 비교는 다음 기준을 탐색합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어\n- 가장 저렴한 유료 인스턴스의 비용\n- 배포 방법\n- 지원되는 워크로드\n- 네이티브 파이썬 지원\n- 도커 파일 지원\n- 지원되는 지역\n- 기본 인프라\n- 파이썬 배포에 대한 문서\n\n모든 이 솔루션은 클라우드에서 애플리케이션을 신속하게 배포하는 데 도움이 됩니다. 이 비교 기준은 귀하의 프로젝트에 가장 적합한 솔루션을 식별하는 데 도움이 될 것입니다. 이제 소개 없이 2024년에 당신의 파이썬 애플리케이션을 호스팅할 수 있는 최고의 호스팅 플랫폼을 살펴보겠습니다.\n\n# 1. Koyeb\n\n웹사이트: https://www.koyeb.com/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어: 서비스 하나 및 관리형 PostgreSQL 데이터베이스 하나 배포 가능합니다.\n- 가장 저렴한 유료 인스턴스 비용: eNano 인스턴스는 초 단위로 과금됩니다. 한 달 동안 실행하면 $1.61이 소요됩니다.\n- 배포 방법: Git을 통한 배포 및 Docker 기반의 배포가 가능합니다. CLI 및 제어판을 통해 실행할 수 있습니다.\n- 지원하는 워크로드: 풀 스택 애플리케이션, 웹 서비스, API, 백그라운드 작업 및 데이터베이스를 지원합니다.\n- 네이티브 Python 지원: ✅ 플랫폼에 배포된 Python 프로젝트를 식별하고 빌드하는 네이티브 빌드팩이 제공됩니다.\n- Dockerfile 지원: ✅ Dockerfile에서 빌드할 수 있어 빌드 프로세스를 더 세밀하게 제어할 필요가 있는 경우에도 지원됩니다.\n- 지원하는 지역: 세계 세 대륙에 걸쳐 총 여섯 개의 지역을 지원합니다. 샌프란시스코(미국), 워싱턴 D.C.(미국), 프랑크푸르트(독일), 파리(프랑스), 도쿄(일본) 및 싱가포르.\n- 기반이 되는 인프라: Koyeb는 베어 메탈 머신에서 직접 실행됩니다.\n\nPython 배포용 문서\n\n- Koyeb에서 Python Flask 배포\n- Koyeb에서 Python Django 배포\n- Koyeb에서 Python FastAPI 배포\n- Koyeb에서 Git을 통한 Python 배포\n- Koyeb에서 Celery Worker 배포\n\n# 2. pythonanywhere.com\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어: 웹 애플리케이션 1개\n- 가장 저렴한 유료 인스턴스 비용: 월 $5\n- 배포 방법: GitHub 또는 Bitbucket을 통해 배포합니다. 도커 컨테이너를 배포할 수 없습니다. CLI 및 대시보드 사용 가능\n- 지원하는 작업 부하: 웹 애플리케이션, 크론 작업, 데이터베이스 및 정적 사이트\n- 네이티브 파이썬 지원: 가능\n- Dockerfile 지원: Dockerfile에서 빌드 지원 불가\n- 지원하는 지역: 미국 동부의 1개 위치. 플랫폼의 EU 버전은 프랑크푸르트 지역에 작업 부하를 실행합니다.\n- 기반이 되는 인프라: PythonAnywhere은 AWS 위에서 실행됩니다.\n\nPython 배포를 위한 문서\n\n- PythonAnywhere에서 Python Flask 배포하기\n- PythonAnywhere에서 Python Django 배포하기\n\n# 3. Render\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹사이트: https://render.com/\n\n- 무료 티어: 매달 한 서비스당 750시간.\n- 가장 저렴한 유료 인스턴스 비용: 월 $7.\n- 배포 방법: Git 및 Docker 기반 배포. CLI 및 제어판 제공.\n- 지원되는 Workloads: 웹 서비스, 정적 사이트, 데이터베이스 및 cron 작업.\n- 네이티브 파이썬 지원: Render에서 파이썬을 배포할 수 있도록 네이티브 런타임 제공.\n- Dockerfile 지원: Dockerfile에서 빌드하는 기능도 지원됩니다.\n- 지원되는 지역: 세 대륙에 걸쳐 네 개 지역 – 오리건 (미국), 오하이오 (미국), 프랑크푸르트 (독일), 싱가포르.\n- 기본 인프라: Render는 AWS 및 GCP 상에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n- Render에서 Python Django 배포하기\n- Render에서 Python Flask 배포하기\n- Render에서 Celery Worker 배포하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. Fly.io\n\n- 무료 티어: $5 회원 가입 크레딧. 무료 자원을 사용하여 최대 3개의 서비스를 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월 $1.94\n- 배포 방법: 애플리케이션, 크론 작업, 대기열 및 데이터베이스.\n- 지원되는 워크로드: 도커화된 애플리케이션.\n- 내장된 Python 지원: 내장 Python 빌더 탑재.\n- Dockerfile 지원: Dockerfile에서 빌드 지원됨.\n- 지원되는 지역: 전 세계 35개 지역 지원.\n- 기반이 되는 인프라: Fly.io는 베어 메탈 머신 상에서 실행됩니다.\n\nPython 배포에 대한 문서\n\n- Fly.io에서 Python Flask 배포하기\n- Fly.io에서 Python Django 배포하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. DigitalOcean 앱 플랫폼\n\n웹사이트: https://www.digitalocean.com/products/app-platform\n\n- 무료 티어: 무료로 3개의 정적 사이트를 빌드하고 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월별 $5.\n- 배포 방법: Git 기반의 배포 및 미리 빌드된 Docker 이미지 사용 가능.\n- 지원하는 워크로드: 어플리케이션, 정적 사이트, 크론 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네이티브 빌드팩으로 파이썬 프로젝트를 식별하고 빌드합니다.\n- Dockerfile 지원: Dockerfile로부터 빌드하는 기능을 지원합니다.\n- 지원되는 지역: 9개 지역을 지원합니다.\n- 기반 인프라: DigitalOcean 앱 플랫폼은 DigitalOcean의 인프라에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DigitalOcean 앱 플랫폼에 Python Flask 배포\n- DigitalOcean 앱 플랫폼에 Python Django 배포\n\n# 6. Heroku\n\n웹사이트: https://www.heroku.com/\n\n- 무료 티어: Heroku는 무료 티어를 중단했습니다.\n- 가장 저렴한 유료 인스턴스 비용: 매월 $5.\n- 배포 방법: Git 기반의 배포 및 미리 구축된 Docker 이미지 사용.\n- 지원되는 작업 부하 유형: 애플리케이션, 백그라운드 작업, cron 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네, Heroku의 네이티브 빌드팩은 파이썬 프로젝트를 인식하고 빌드합니다.\n- Dockerfile 지원: Heroku는 Dockerfile에서 빌드하는 것을 지원하지만, Heroku는 고급 사용 사례에 대해 Heroku 컨테이너 스택 사용을 권장합니다. Heroku의 기본 빌드팩 시스템이 권장됩니다.\n- 지원되는 지역: 유럽과 미국 두 군데의 지역이 지원됩니다. 엔터프라이즈 플랜이 없으면.\n- 기본 인프라: Heroku는 AWS 위에서 운영됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 배포에 대한 문서\n\n- 파이썬 시작하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/getting-started-with-python)\n- Heroku에서 파이썬 및 장고 앱 배포하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/deploying-python)\n\n# 결론: 원하는 곳에 배포하세요!\n\n다뤄 본 내용: 무료 티어, 배포 방법, 워크로드 호환성, 기본 인프라 및 예산을 그대로 유지할 수 있는 유료 요금제에 대해 다루었습니다. 아마도 여러분의 프로젝트에 가장 적합한 선택을 할 수 있도록 도움이 될 통찰력을 발견했을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 비교를 마무리하면, 여러분의 호스팅 플랫폼은 앱의 성능에 영향을 미칠 뿐만 아니라 데브옵스에서 시간을 확보하여 앱 개발에 집중할 수도 있습니다. 행복하고 빠른 배포를 기원합니다!","ogImage":{"url":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png"},"coverImage":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png","tag":["Tech"],"readingTime":5},{"title":"Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션","description":"","date":"2024-05-20 23:21","slug":"2024-05-20-SymfonyMulti-TenantApplicationswithEcotone","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png\" /\u003e\n\n비즈니스 도메인에 따라 멀티 테넌시를 어떻게 구현하는지가 달라집니다. 데이터베이스를 공유해야 할 수도 있고 완전히 격리된 별도의 데이터베이스를 필요로 할 수도 있습니다. 테넌트가 몇 개뿐인 경우도 있지만 수백 개인 경우도 있습니다. 주어진 테넌트의 성능에 대한 쿼터링 또는 성능 향상이 필요할 수 있습니다. 이 모든 것은 멀티 테넌시가 기술적인 측면 뿐만 아니라 비즈니스적인 고려 사항이기도 함을 의미합니다.\n\n이전 기사에서는 최소한의 노력으로 Laravel 및 Ecotone을 사용하여 멀티 테넌트 시스템을 구축하는 방법에 대해 설명했습니다. 이번에는 Symfony 프레임워크에 대해 동일한 작업을 수행할 것입니다.\n\n이 기사의 시나리오는 각 섹션의 끝에 연결된 데모와 함께 제시될 것입니다. 이렇게 하면 예제를 논의할 뿐만 아니라 실행 가능한 데모를 참고할 수도 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테넌트별 데이터베이스로 메시지 전송\n\n만약 전자 상거래 도메인에서 활동 중이고 각각이 별도의 데이터베이스를 가지고 있는 두 개의 테넌트가 있다고 가정합시다(DB per Tenant 전략).\nE-커머스 시스템에서 가장 먼저 발생해야 하는 것은 새로운 고객 등록이며, 이것에 대해 지금 집중하겠습니다.\n\n새로운 고객을 등록하는 과정은 다음과 같이 진행됩니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 Command Handler로 등록 고객 Command Message를 보낼 것입니다.\n\nCommand Bus를 사용하여 Command Handler에 등록 고객 Command를 보내서 새로운 고객을 데이터베이스에 저장할 것입니다. 중요한 부분은 주어진 테넌트와 관련된 데이터베이스에 고객을 저장하려고 한다는 것입니다.\n\n시작하기 위해 Symfony용 Ecotone을 설치해 봅시다:\n\n이를 통해 Ecotone의 Symfony 통합 및 데이터베이스 지원 도구를 제공받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테넌트에 대한 연결 매핑\n\n우리는 예제로 Doctrine ORM을 사용할 것입니다. 각 테넌트는 자체 데이터베이스 연결을 갖게 될 것이므로, 먼저 각 테넌트에 대한 Doctrine 구성을 정의해야합니다(doctrine.yaml).\n\n연결이 정의되면, 이제 어떻게 테넌트 이름에 매핑될지 설정할 수 있습니다. Ecotone의 ServiceContext 속성으로 표시된 구성 방법을 사용하여 수행합니다.\n\n이것이 기본적으로 전부입니다. Ecotone은 이제 지정된 테넌트 이름이 지정된 연결에 매핑되는 방법을 알게 됩니다. 따라서 어떤 종류의 메시지(명령/쿼리/이벤트)를 보내면 어떤 연결을 사용해야 하는지 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Multi-Tenant Command Handler\n\n우리는 다중 테넌트 시스템에 Ecotone의 CQRS를 사용할 것입니다. 이를 통해 다중 테넌트 시스템에서 사용할 수 있는 다양한 기본 기능을 제공받습니다.\n\n우리의 Register Customer Command Handler를 정의해봅시다:\n\nCommand Handler를 보면 특별한 것이 없는 것을 알 수 있습니다. PHP 속성으로 표시된 비즈니스 로직을 수행하는 메서드일 뿐입니다. 우리의 Command Handler는 Command Class를 가져와 Doctrine ORM을 사용하여 고객을 저장합니다. 이 코드는 단일 테넌트 환경에서도 문제없이 작동할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 꼼꼼한 부분은 특정 Tenant에 대한 ObjectManager/EntityManager를 사용해야 한다는 것입니다. 각 Tenant마다 자체 데이터베이스 연결이 있기 때문입니다.\n#[MultiTenantObjectManager] 속성을 추가함으로써 Ecotone에게 현재 활성화된 Tenant에 대한 ObjectManager를 주입하도록 알려줍니다. 이렇게 하면 고객을 올바른 Tenant의 데이터베이스에 저장하고 코드를 Multi-Tenancy에 대해 직관적으로 유지할 수 있습니다.\n\n이제 RegisterCustomer Command Class를 정의해봅시다:\n\nCommand Class는 간단한 POPO (Plain Old PHP Object)이며 특정 프레임워크 클래스를 확장하거나 구현하지 않습니다. Command에는 고객 등록에 필요한 모든 데이터가 포함되어 있습니다.\n\n# Multi-Tenant Message Bus\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 코드베이스에 Command Handler를 소개한 후에는 이제 주어진 테넌트에 대해 Command를 보낼 수 있습니다.\n우리는 주어진 테넌트의 문맥에서 주어진 Command를 실행할 것입니다:\n\n여기서는 Command를 Command Bus를 통해 보내고 메타데이터 (메시지 헤더)를 사용하여 테넌트 이름을 전달합니다. 이렇게 하면 Ecotone이 해당 Command Handler를 주어진 테넌트의 데이터베이스 context에서 수행하고 있다는 것을 이해할 것입니다. 일반적으로 HTTP 도메인 또는 사용자 세션을 기반으로 여기서 테넌트 이름을 해결할 것입니다.\n\n이것이 말 그대로 다중 테넌트 환경에서 고객을 저장하는 데 필요한 모든 것입니다. 기본적으로 우리의 코드는 단일 테넌트 또는 다중 테넌트 모두에 대해 작동할 것입니다. 다중 테넌시에 완전히 중립적이기 때문입니다. 이제 우리의 다중 테넌트 시스템에서 필요할 수 있는 더 많은 시나리오를 확인해 봅시다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공유 및 다중 데이터베이스 테넌트\n\n기본적으로 우리는 각 테넌트를 동일한 데이터베이스에 넣지만, 고객이 프리미엄을 구매하면 별도의 데이터베이스 인스턴스를 받게되는 비즈니스 모델을 가질 수 있습니다.\n\n이러한 경우를 처리하기 위해 Ecotone은 기본 연결을 제공합니다. 따라서 주어진 테넌트 이름에 대한 매핑이 없는 경우 기본값이 사용됩니다:\n\n# 메시지 핸들러에서 현재 테넌트에 액세스하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 시나리오에서는 실행이 수행되는 테넌트의 맥락을 인식해야 할 수도 있습니다. 예를 들어, 특정 테넌트가 고급 상점을 가지고 있을 때는 주문 후 즉시 배송이 이뤄져야 하지만, 다른 테넌트에게는 시간이 중요하지 않을 수도 있습니다.\n\nEcotone의 경우, 메시지 헤더(메타데이터)를 통해 전송하는 모든 것은 메시지 핸들러 수준에서 접근할 수 있습니다. 따라서 필요에 따라 특정 메타데이터를 무시하거나 접근할 수 있습니다. 그리고 메시지 헤더를 통해 테넌트 이름을 전송하므로 필요한 경우 이를 접근할 수 있습니다:\n\n헤더 속성은 접근하려는 메시지 헤더를 나타냅니다. 우리의 경우, 우리가 이전에 커맨드 버스를 통해 전송한 테넌트 헤더에 접근하려고 합니다.\n\n# 테넌트 전환에 연결하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 멀티 테넌트 애플리케이션이 실행 중이라면, 사용자 정의 라이브러리나 통합을 사용하고 있을 가능성이 높습니다. 이러한 경우 특정 테넌트가 활성화되거나 비활성화될 때 일부 코드를 트리거해야 할 수도 있습니다.\n\nEcotone은 테넌트 전환 프로세스에 훅을 걸 수 있는 가능성을 엽니다. 여기에서 활성화될 Connection과 테넌트 이름을 제공할 수 있습니다.\n\n활성화할 메소드를 OnTenantActivation 또는 OnTenantDeactivation으로 표시하기만 하면 되며, 지정된 메소드는 트리거될 것이며 이에 따라 작업이 수행됩니다. 이 방법으로 특정 어트리뷰트로 메소드를 표시함으로써, 흐름에 훅을 걸고 필요한 로직을 수행할 수 있습니다.\n\n데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이벤트 및 테넌트 전파\n\n고객이 등록되면 환영 메시지가 포함된 이메일을 보내는 등 부수 효과를 발생시키고 싶을 수 있습니다. 이러한 상황에서는 이벤트 및 이벤트 핸들러를 정의할 수 있습니다.\n\n고객이 등록되면 Event Bus를 사용하여 CustomerWasRegistered 이벤트 메시지를 발행합니다. 그런 다음 구독하는 이벤트 핸들러에 대한 모든 메서드(첫 번째 매개변수는 구독하는 이벤트를 지정)가 실행됩니다.\n\nEcotone을 사용하면 이벤트 핸들러에서 테넌트 메시지 헤더에 액세스할 수 있습니다. 이는 Ecotone의 메타데이터 전파 기능 덕분에 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 링크에서 데모 구현을 찾을 수 있습니다.\n\n# 컨텍스트 및 메타데이터 전파\n\nEcotone은 기본적으로 모든 메시지 헤더를 자동으로 전파합니다. 이를 통해 컨텍스트인 테넌트를 보존합니다. 우리의 경우, 고객 등록이 진행된 테넌트의 컨텍스트에서 알림을 보낼 것입니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메타데이터는 명령에서 발행된 이벤트로 자동 전파됩니다.\n\n물론 우리는 Event Handlers에서 또한 테넌트 이름에 접근할 수 있습니다.\n\n## 비동기 이벤트\n\n우리는 기본적으로 이벤트 핸들러를 동기적으로 실행할 수 있지만 비동기적으로 실행할 수도 있습니다. Ecotone은 RabbitMQ, Redis, Database 채널과 같은 비동기 처리를 위한 통합 세트를 제공하며 Symfony Messenger Transport를 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터베이스 채널을 사용하려고 합니다. 이는 주어진 테넌트의 메시지를 해당 테넌트의 데이터베이스에 저장할 것으로 기대됩니다. 이를 위해 Ecotone의 데이터베이스 메시지 채널을 사용할 것입니다. 이는 멀티 테넌시를 지원하기 때문에 사용합니다.\n\n![Image](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_3.png)\n\n이제 이벤트 핸들러를 비동기적으로 처리하도록 표시해 봅시다.\n\n해당 이벤트 핸들러는 이제 비동기적으로(백그라운드에서) 처리된다는 것을 의미하고, 이벤트 메시지는 \"notifications\" 메시지 채널로 전송될 것입니다. 그래서 이 채널을 데이터베이스 큐로 정의합시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 이벤트 핸들러를 비동기로 구성하는 데 필요한 모든 작업은 여기까지입니다. 이제 이벤트 핸들러가 실행될 때마다 이벤트 메시지가 주어진 테넌트의 데이터베이스 대기열로 먼저 이동한 다음 비동기적으로 소비될 것입니다.\n\n# 비동기 메시지 소비자 실행\n\n비동기 메시지 채널(우리 경우 데이터베이스 대기열)에 메시지를 발행하면 이를 소비해야 합니다.\n메시지 소비자를 실행하기 위해 내장된 콘솔 명령 \"ecotone:run\"을 사용할 것입니다:\n\n이 명령은 \"notifications\" 채널로 오는 메시지를 가져와 실행하는 별도의 메시지 소비 프로세스가 실행될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 테넌트 환경에서 운영 중이며 우리의 \"알림\"은 데이터베이스 큐입니다. 이는 각 테넌트마다 별도의 대기열을 가진 별도의 데이터베이스가 있음을 실제로 의미합니다. 이것은 소비 과정에서 고려되어야 합니다.\n\n작업 중인 비즈니스 도메인에 따라 수백 개의 테넌트가 있을 수 있으므로 수백 개의 메시지 소비자를 실행하는 것이 이상적이라고는 할 수 없습니다. 이러한 상황에서 Ecotone은 기본적으로 라운드로빈 전략을 사용하여 단일 프로세스를 사용하여 수용합니다. 이는 각 테넌트에서 순서대로 가져올 것을 의미합니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_4.png)\n\nEcotone은 다중 테넌트에서 메시지를 소비하는 데 라운드 로빈 전략을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법으로 소비하는 것은 즉시 작동합니다. 이를 실현하기 위해 고객 구성을 할 필요가 없습니다. 메시지 소비 속도를 높이고 싶다면 해당 프로세스를 여러 개 실행할 수 있습니다.\n사실, 우리는 특정 프리미엄 테넌트의 메시지 소비 속도를 높이거나, 많은 메시지를 생성하는 테넌트의 제어를 가져가서 전체 프로세스를 관리할 수 있습니다. 그러나 이 부분은 별도의 기사에서 탐구할 것입니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 데이터베이스 트랜잭션 및 아웃박스 패턴\n\n시스템을 장애에 강하게 만들기 위해 데이터베이스 트랜잭션을 활성화하고 싶을 수 있습니다. 물론 우리의 경우에는 트랜잭션을 지정된 테넌트의 데이터베이스에 대해 시작하길 원할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_5.png\" /\u003e\n\nCommand Bus가 실행될 때 자동으로 데이터베이스 트랜잭션이 시작됩니다.\n\n우리가 Command를 실행할 때 Ecotone은 올바른 테넌트 데이터베이스를 자동으로 시작하기 위해 데이터베이스 트랜잭션을 시작합니다. 이것은 Symfony Starter와 함께 설치된 Dbal Module에서 사용 가능한 기능으로, 추가 구성이 필요하지 않습니다. 트랜잭션을 구성하는 방법에 대해 더 알고 싶다면 문서를 참조해 주세요.\n\n이벤트를 데이터베이스 큐로 비동기적으로 발행할 때 이 역시 트랜잭션으로 처리됩니다. 이렇게 함으로써 예외가 발생한 경우 모든 과정이 함께 롤백될 것임을 확신할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![SymfonyMulti-TenantApplicationswithEcotone_6](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_6.png)\n\n이 작업은 Multi-Tenant 시스템에서 Outbox 패턴으로 작동합니다. 이외에도 Ecotone은 메시지가 데이터베이스에서 메시지 브로커(예: RabbitMQ, Redis, SQS)로 자동으로 이동될 수 있는 결합된 메시지 채널을 제공합니다. 이렇게 하면 메시지 처리가 메시지 브로커 소비자(그리고 그것들을 확장할 수 있음)를 위해 이루어지고, 데이터베이스 소비자가 아닙니다.\n\n# Dbal Business Methods\n\nDbal 모듈은 Business Interface를 제공하는데, 이는 추상화된 형태로 감춰진 데이터베이스 쿼리를 쉽게 작성할 수 있는 방법입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이루고 싶은 것의 인터페이스를 정의하고 Ecotone이 해결방안을 처리합니다. 이것은 우리가 해야 할 일은 인터페이스를 작성하는 것뿐이며 구현은 제공되며 의존성 컨테이너에 등록될 것임을 의미합니다.\n비즈니스 인터페이스는 메시지 핸들러(Command/Query/Event Handlers)에서 호출될 때 자동으로 테넌트의 연결을 상속받습니다.\n\n더 많은 정보를 알고 싶다면 Dbal을 기반으로 한 비즈니스 인터페이스 사용에 대한 이 기사를 읽어보세요.\n\n# 명령을 직접 모델로 보내기\n\nEcotone은 명령을 우리의 Doctrine ORM Entity에 직접 보내는 것을 지원합니다. 이 방법으로는 어떤 위임 수준의 코드도 작성할 필요가 없습니다.\n물론, 이는 멀티 테넌시와 함께도 작동합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서 보듯이 정적 팩토리 메서드를 생성했습니다. 이 방법으로 Ecotone에게 이 팩토리 메서드 \"register\"가 새로운 고객을 생성한다고 알려줍니다. 이 메서드가 실행된 후, Ecotone은 해당 테넌트에 대해 EntityManager를 사용하여 올바른 데이터베이스에 저장합니다.\n이것은 더 이상 이와 같은 코드를 작성할 필요가 없다는 것을 의미합니다:\n\n컨트롤러 측에서는 아무 것도 바뀌지 않고 이전과 똑같이 보냅니다:\n\n중요한 점은 이것이 Action 기반 메서드에 대해서도 작동하며, 일부 시나리오에서 Command 클래스를 완전히 없앨 수 있게 합니다:\n\n그리고 다음과 같이 Command Bus를 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmetadata를 통해 aggregate.id를 전달하여 어떤 Customer 인스턴스에서 메서드를 실행할지를 나타낼 수 있습니다. 이 주제에 대해 더 알아보려면 Doctrine ORM을 Aggregate로 사용하는 방법에 대해 이 기사에서 읽을 수 있습니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 이벤트 소싱\n\n시스템에서 다른 뷰를 구축하거나 변경 사항을 감사하는 경우, Event Sourcing을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEcotone는 다양한 테넌트 시스템을 위해 프로덕션에 적합한 이벤트 소싱 애플리케이션을 신속하게 구현할 수 있는 완전한 이벤트 소싱 지원이 제공됩니다.\n\n이 프로세스는 이전에 살펴본 Doctrine ORM 집합체와 동일하게 작동합니다. 차이점은 이벤트 소싱된 집합체가 내부 상태를 변경하는 대신 이벤트 클래스를 반환한다는 것입니다.\n\n## Auto-Setup\n\n물론, 각 테넌트의 이벤트를 저장할 곳이 필요한데, 이를 위해 테넌트의 데이터베이스에 이벤트 저장소를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에코톤은 이벤트의 직렬화와 역직렬화, 주어진 테넌트 데이터베이스에 이벤트 스토어 설정(포스트그레SQL, MySQL, MariaDB에 내장된 지원) 및 리드 모델 프로젝션 설정을 도와줍니다.\n\n## 리드 모델 프로젝션\n\n프로젝션은 이벤트에서 다양한 뷰를 만드는 데 사용됩니다. 각 프로젝션은 데이터베이스의 별도의 테이블이나 테이블 세트일 수 있으며 동적으로 생성됩니다:\n\n이벤트가 발행되면 관련 프로젝션이 트리거됩니다. 메타데이터에 기반하여 에코톤은 어떤 테넌트와 관련이 있는지 이해하고 이전에 발생하지 않은 경우 프로젝션을 초기화할 것입니다.\n초기화 후 우리 프로젝션의 이벤트 핸들러가 트리거됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 모든 작업은 동기적으로 발생하며, 이는 이벤트 소싱을 작업하기 매우 쉽게 만듭니다. 필요한 경우 프로젝션을 비동기적으로 실행하도록 전환할 수도 있습니다.\n\n더 많은 내용을 알고 싶다면 문서를 참조하세요. 이벤트 소싱 주제에 대해 더 탐구하고 싶다면 데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n# 요약\n\n이 문서에서는 미리 계획된 코드를 사용하여 Multi-Tenant 친화적인 Symfony 애플리케이션을 구축하는 방법을 활성화했습니다. 이 방식을 통해 우리가 작성한 코드는 어떠한 변경 없이도 단일 테넌트 및 멀티 테넌트 환경에서 작동할 수 있어 애플리케이션을 쉽게 구축하고 유지할 수 있습니다. Ecotone은 컨텍스트 전파를 처리해 줍니다. 따라서 코드가 동기적인지 비동기적인지에 상관없이 작업이 실행되는 테넌트의 컨택스트가 우리를 위해 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 처리와 백그라운드 작업을 시작하게 되면 더 정교한 큐 기반 솔루션이 필요할 수 있습니다. 메시지를 너무 많이 생성하는 테넌트의 처리량을 제어하고, \"프리미엄\" 테넌트의 처리 속도를 높이며, 쉽게 작업할 수 있는 방식으로 실패 및 재시도를 처리하고자 할 때 이러한 문제가 발생할 수 있습니다. Ecotone은 이를 제공하지만, 이 주제는 별도의 글이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png"},"coverImage":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png","tag":["Tech"],"readingTime":10},{"title":"글의 가능성을 높이는 단어 카운터와 텍스트 분석기","description":"","date":"2024-05-20 23:19","slug":"2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer","content":"\n\n텍스트 분석을 통해 더 나은 글을 작성할 수 있는 잘 알려진 도구입니다\n\n![Image](/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png)\n\n참고: 이것은 제가 Medium에 작성한 첫 번째 기사이므로, 부디 제 미숙한 글쓰기와 오타를 용서해 주시기 바랍니다. 😊\n\n안녕하세요 여러분!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 잘 알려진 속담으로 기사를 시작하려고 합니다:\n\n\"정확하게 사용한다면 모든 말이 할 수 있는 일을 강조하는 가장 좋은 방법입니다.\"\n\n기사를 발행할 글이나 시험 답안을 분석해야 하는 상황에 처해본 적이 있나요?\n\n그렇다면, 저는 텍스트를 분석하고 단어 수, 불용어, 고유한 단어, 단락, 문장, 줄 수 등과 같은 중요한 통계 정보를 제공하며 독해, 쓰기, 말하기, 타이핑 시간과 같은 시간 관련 측정값을 제공하는 효과적인 도구를 개발했다는 것을 기쁘게 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것을 고려해도 무료이며 모든 기능에 무제한 액세스가 가능합니다.\n\n이 도구를 사용하려면 여기에서 이용할 수 있습니다: [https://livingtocode.com/word-counter/](https://livingtocode.com/word-counter/) 자유롭게 확인해보세요.\n\n이 도구는 SEO 전문가, 학생, 작가, 연구자, 저자, 선생님들이 일상생활에서 글을 평가하고 최적화하는 데 도움이 될 수 있습니다.\n\n위의 모두에 대해 처음이더라도 이 도구는 여전히 글쓰기 기술을 향상시키는 데 도움이 되며, 동기부여를 제공하고 제한 내에서 텍스트를 최적화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"많은 도구들이 이미 같은 작업을 수행하고 있지만, 가능성을 탐험하기 위해 한 번 만들어 보고 싶었습니다.\n\n건의나 개선 아이디어가 있으면 언제든 환영합니다.\n\n의견을 공유해 주세요.\n\n읽어 주셔서 감사합니다.\"","ogImage":{"url":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png"},"coverImage":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png","tag":["Tech"],"readingTime":2}],"page":"57","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"57"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>