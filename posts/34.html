<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/34" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/34" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="다음 JS 어드민 대시보드 템플릿 무료" href="/post/2024-05-14-NextJSAdminDashboardTemplateFree"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다음 JS 어드민 대시보드 템플릿 무료" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다음 JS 어드민 대시보드 템플릿 무료" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">다음 JS 어드민 대시보드 템플릿 무료</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 Font Awesome 아이콘 사용하기" href="/post/2024-05-14-conesdoFontAwesomenoReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 Font Awesome 아이콘 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 Font Awesome 아이콘 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 Font Awesome 아이콘 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 Context와 useState 함께 사용하는 방법" href="/post/2024-05-14-HowtouseReactContextwithuseState"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 Context와 useState 함께 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 Context와 useState 함께 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 Context와 useState 함께 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Server Components와 NextJS Best Practices, 팁" href="/post/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Server Components와 NextJS Best Practices, 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Server Components와 NextJS Best Practices, 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Server Components와 NextJS Best Practices, 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" href="/post/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" href="/post/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS에서 상태 관리 다루기 흔한 문제와 해결책" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS에서 상태 관리 다루기 흔한 문제와 해결책</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" href="/post/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 컴포넌트 슬롯과 리액트" href="/post/2024-05-14-WebComponentsslotsandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 컴포넌트 슬롯과 리액트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 컴포넌트 슬롯과 리액트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextAuth v5를 사용한 보호된 라우팅 구현하기" href="/post/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextAuth v5를 사용한 보호된 라우팅 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextAuth v5를 사용한 보호된 라우팅 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" href="/post/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"다음 JS 어드민 대시보드 템플릿 무료","description":"","date":"2024-05-14 11:34","slug":"2024-05-14-NextJSAdminDashboardTemplateFree","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png\" /\u003e\n\n# Next JS란 무엇인가요?\n\nNextJS 관리 대시보드 템플릿은 편의성과 견고함으로 큰 인기를 끌고 있습니다. 그리고 개발자로서, 일을 더 쉽게 만들어주는 프레임워크를 찾는 것만큼 멋진 일은 없죠. 개발자로서 업무 흐름을 간소화하고 코드를 더욱 효율적으로 만드는 방법을 찾고 계신다면 정말 좋은 선택일 것입니다. 여기서 Next JS가 등장합니다. 하지만 템플릿을 살펴보기 전에 Next JS 기술에 대해 알아보겠습니다.\n\n더 나아가서, Next.js는 React를 사용하여 서버 측 렌더링 (SSR) 및 정적 웹 응용 프로그램을 구축할 수 있게 해주는 인기 있는 오픈 소스 JavaScript 프레임워크입니다. 자동 코드 분할, 서버 측 렌더링, 동적 가져오기 등의 기능을 제공하여 뛰어난 개발 경험을 제공하며, 성능이 우수하고 확장 가능한 웹 응용 프로그램을 구축하는 데 도움을 줍니다. 또한 Next.js를 사용하면 대량 트래픽을 처리하고 서버 리소스를 효율적으로 활용할 수 있는 웹 응용 프로그램을 만들 수 있습니다.\n\n\n\nNext JS의 다른 장점 중 하나는 디자인 매니저 도구를 사용하여 블로그 템플릿을 사용자 정의할 수 있는 기능이 있습니다. 또한 헤더와 푸터 HTML에 사용자 정의 코드나 스크립트를 추가하고 블로그에 스타일 시트를 첨부할 수도 있습니다. 더불어 서버 측 렌더링을 제공하여 페이지 로드 시간 및 SEO를 개선할 수도 있습니다. 또한 편리한 내비게이션을 위한 통합 라우팅 시스템을 제공하므로 응용 프로그램 내의 다른 페이지 간에 쉽게 이동할 수 있습니다.\n\nNext.js의 또 다른 멋진 기능은 서버리스 함수를 사용하여 서버에서 직접 실행되는 웹 사이트의 일부를 구축할 수 있다는 점입니다. 이를 통해 동적 콘텐츠를 만들고 서버 비용을 줄일 수 있습니다. 각 요청 시 사용된 리소스에 대해서만 지불하면 되기 때문입니다.\n\nNext JS를 선택해야 하는 이유\n\n- Next.js는 서버 측 렌더링, 자동 코드 분할 및 쉬운 구성을 제공하는 인기 있는 React 프레임워크입니다.\n- 개발자들이 쉽고 빠르게 확장 가능한 웹 애플리케이션을 구축할 수 있도록 지원하며 우수한 SEO 기능을 제공합니다.\n- 템플릿은 핫 리로딩과 빠른 새로고침을 기본적으로 지원하여 개발자 경험을 향상시킵니다.\n- 많은 특징과 플러그인이 함께 제공되어 웹 애플리케이션을 더 쉽고 효율적으로 구축할 수 있습니다.\n- Netflix, Uber, Hulu 등 인기있는 회사들이 사용하는 만큼 확장성과 신뢰성에 대한 확증입니다.\n\n\n\n# NextJS 템플릿\n\n개발자들은 다양한 Next.js 대시보드 템플릿을 활용하여 완전히 기능이 구현된 Production-Ready 대시보드를 작성하는 개발 프로세스를 가속화할 수 있습니다. 이러한 템플릿은 일반적으로 사용자 관리, 데이터 시각화 및 인증과 같은 표준 대시보드 기능을 지원하는 미리 구축된 레이아웃과 구성 요소를 포함하고 있습니다.\n\n개발자 사이에 인기있는 Next.js 대시보드 템플릿으로는 Dash UI, salvia-kit, chris-trapstar, Modernize, CoreUI PRO, Tokyo Free White 등이 있습니다. 따라서 우리는 다음 섹션에서 모든 NextJS 관리자 대시보드 템플릿을 자세히 살펴볼 것입니다. 이러한 대시보드 템플릿을 활용하면 개발자들은 개발 시간을 절약하고 앱의 독특한 기능을 구축하는 것을 우선시할 수 있습니다.\n\n# Dash UI — NextJS 관리자 템플릿\n\n\n\nDash UI는 무료이며 다양한 기능을 제공하는 Next.js 기반 관리 대시보드 템플릿입니다. 이는 웹 애플리케이션에 쉽게 통합될 수 있는 모바일 우선 responsiv 레이아웃을 포함하고 있으며 카드, 테이블, 인증 양식과 같은 사전 구축된 UI 구성요소가 포함되어 있습니다.\n\n![다운로드](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_1.png)\n\n또한, Dash UI NextJS Admin Dashboard Template은 다음 프로젝트용 웹 앱과 페이지를 구축하는 데 좋은 선택일 수 있습니다. 이 개발자 친화적이고 매우 사용자 정의 가능한 템플릿은 프로세스를 더 쉽게 만들어주고 필요한 대로 정확히 만들 수 있도록 도와줄 수 있습니다.\n\n- 적절히 문서화됨\n- 프로필, 청구, 404 등 9개 이상의 페이지\n- 회원가입 및 로그인과 같은 인증 페이지\n- 댓글 기능\n- 대부분의 브라우저와 호환됨\n- Github에서 이용 가능\n\n\n\n테이블 태그를 마크다운 형식으로 변경하면 다음과 같습니다.\n\n| Preview |\n|--------|\n| Download |\n\nNext.js로 전문적이고 효율적인 웹 애플리케이션을 만들고 싶으신가요? 그렇다면 Starter NextJS Admin 대시보드 템플릿을 확인해 보세요.\n\n# 시작하기: NextJS Admin 템플릿\n\n\n\n---  \n![template image](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_2.png)\n\n이 템플릿은 현대적이고 효율적인 웹 애플리케이션을 구축하려는 사람들에게 우수한 선택지입니다. 또한 현대적인 디자인, 확장성 및 성능 최적화로 그 어떤 것과도 차별화됩니다. 이 템플릿은 당신의 웹 애플리케이션을 다음 수준으로 이끌 수 있는 힘을 가지고 있습니다.\n\n- 고도로 확장 가능\n- 차트 및 그래프, 폼 입력, 테이블 등 구성 요소 사용 가능\n- 최적화 및 사용자 정의\n\n미리보기\n\n\n\n다운로드\n\n# Tokyo Free White — NextJS Admin Template\n\n이 관리자 대시보드 템플릿은 가장 최신 버전의 Next.js를 사용합니다. 또한 암호화폐를 모티브로한 대시보드이며, 모든 노드 종속성이 최신 상태이며, 미래의 버전에서도 그대로 유지될 것입니다. 더불어, 이 템플릿은 현대적인 파란색 강조 색상을 사용하여 UI 구성 요소 프레임워크인 MUI(Material-UI)와 완벽하게 조화를 이룹니다.\n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_3.png)\n\n\n\n더불어, Next JS 관리 대시보드는 오픈 소스이며 꼭 당신의 엔드 투 엔드 개발 프로세스를 지원할 것입니다. 개발자들에 의해 쉽게 수정될 수 있는 전체적인 외관을 가지고 있습니다.\n\n- 웹 앱을 위한 다양한 페이지 제공\n- 무료 오픈 소스\n- 공통 컴포넌트 제공\n- 메신저 페이지\n\n미리보기\n\n다운로드\n\n\n\n# Materio — 무료 MUI React NextJS Admin 템플릿\n\n이것은 개발자를 위해 특별히 만들어진 상세하고 결과 중심적인 Next JS 관리자 대시보드입니다. 따라서 다음 프로젝트를 위한 세련되고 현대적인 관리자 템플릿을 찾고 있다면 Materio를 무료로 이용할 수 있습니다. \n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_4.png)\n\n이 템플릿은 다양한 기능으로 가득 차 있으며 완전히 반응형이므로 모든 프로젝트에 적합한 좋은 선택입니다. 그리고 가장 좋은 점은 무료로 사용할 수 있다는 것입니다. 맞습니다 — 지출하지 않고도 모든 기능을 활용할 수 있습니다. Materio의 특징 중 하나는 MUI (Material-UI) 프레임워크의 사용입니다. 이를 통해 템플릿 전체에서 일관된 통합된 디자인을 구현할 수 있어 사용하기 쉬우며 탐색하기 쉽습니다.\n\n\n\n- The Next JS 관리자 대시보드에는 사용자 정의 페이지와 컴포넌트가 포함되어 있어요.\n- 사용자 목록, 사용자 보기, 이메일, 채팅, 캘린더, 송장 및 역할 및 권한과 같은 애플리케이션을 받아보세요.\n- 빠른 검색 및 탐색\n- 3개의 차트 라이브러리\n\n미리 보기\n\n다운로드\n\n# CoreUI Pro NextJS Admin Template\n\n\n\nNextJS 관리자 템플릿은 당신이 비즈니스를 관리하고 직원을 관리하며 워크플로우를 손쉽게 최적화할 수 있도록 도와주는 현대적인 템플릿입니다.\n\n![NextJS Admin Template](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_5.png)\n\n게다가 Core UI Pro NextJS Admin 대시보드 템플릿은 반응형 디자인으로 모든 기기에서 멋지게 보이는 다양한 커스터마이즈 가능한 UI 구성 요소 및 직관적인 사용자 인터페이스를 제공하여 내비게이션을 쉽게 할 수 있습니다.\n\n하지만 이 관리자 템플릿을 독특하게 만드는 것은 놀라운 유연성입니다. 프로젝트를 관리하거나 데이터를 추적하며 비즈니스 성과를 모니터링하는 경우 Core UI Pro는 작업을 완료하기 위한 도구를 제공합니다. 간단한 대시보드부터 복잡한 워크플로까지, 이 템플릿은 모두 해낼 수 있습니다.\n\n\n\n- Next.js 13, Bootstrap 5 및 React 18을 따릅니다.\n- 반응형입니다.\n- 다이나믹한 Bootstrap 기반 테마\n- 완벽히 사용자 정의 가능합니다.\n- Dark 및 Light와 같은 다양한 테마\n\n미리보기\n\n다운로드\n\n# NextJS 관리자 템플릿을 현대화하세요\n\n\n\n복잡하고 혼란스러운 관리자 대시보드를 만들 때 몇 시간을 보내는 데 지쳤나요? 그렇다면 Modernize의 Next JS 관리자 대시보드 템플릿을 확인해보는 것이 시간이길래요.\n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_6.png)\n\nModernize는 직관적이고 사용자 친화적이며 정확한 필요에 맞게 사용자 정의할 수 있는 템플릿을 디자인했어요. 세련된 디자인과 미리 디자인된 구성 요소가 담긴 이 템플릿은 모양도 아름답고 기능적인 대시보드를 쉽게 만들 수 있게 해줘요.\n\n더욱이, 이 템플릿의 가장 좋은 점은 인기 있는 React 프레임워크인 Next JS로 제작되었다는 것이에요. 따라서 데이터 시각화 및 분석 도구와 같은 필요한 React 라이브러리 및 기능을 쉽게 통합할 수 있다는 뜻이에요.\n\n\n\n또한 사용하기 쉬운 인터페이스와 반응형 디자인으로, Modernize Next JS 관리자 대시보드 템플릿은 업무 프로세스를 간소화하고 생산성을 향상시킬 수 있습니다. 그러므로 더 이상 복잡한 코드를 이해하거나 작업을 느리게 만드는 다소 불편한 대시보드에 시달리지 않아도 됩니다.\n\n- 완전히 사용자 정의 가능한 구성 요소: Next JS, React 및 다른 라이브러리를 사용하여 템플릿 내의 모든 구성 요소를 사용자 정의할 수 있습니다.\n- 반응형 디자인: 데스크톱, 태블릿 또는 모바일에서 언제든지 부드러운 경험을 누릴 수 있습니다.\n- 다크 모드: 몇 번의 클릭만으로 다크 모드 테마로 전환할 수 있습니다.\n- 다양한 레이아웃: 여러 레이아웃 중에서 대시보드에 가장 적합한 것을 선택할 수 있습니다.\n- 검증된 기술: 신뢰할 수 있는 인기 있는 기술로 구축되어 신뢰성, 확장성 및 보안을 보장합니다.\n\n미리보기\n\n다운로드\n\n\n\n# Windmill-Next JS 관리 대시보드\n\n강력하고 신뢰할 수 있으며 견고한 Next JS 관리 대시보드 템플릿입니다. 동적 기능으로 응용 프로그램에 전원을 공급합니다. 이 직관적이고 사용자 친화적인 대시보드는 비즈니스가 데이터 및 지표를 추적하는 데 명확하고 사용하기 쉬운 플랫폼을 제공하여 운영을 최적화하도록 설계되었습니다.\n\n![대시보드 이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_7.png)\n\n이 대시보드의 뛰어난 점 중 하나는 쉬운 사용자 정의 기능입니다. 간단한 코딩 수정으로 사용자는 대시보드에서 색상, 글꼴 및 아이콘을 자사의 고유한 브랜드 아이덴티티에 맞게 조정할 수 있습니다. 결과적으로 기능적이면서 시각적으로 매력적인 대시보드를 찾는 비즈니스 또는 개인에게 우수한 선택지가 됩니다.\n\n\n\n위트있는 톤으로 한국어로 번역해 드리겠습니다.\n\n\"맞춤 설정 옵션 외에도, 윈드밀 대시보드 프로젝트는 어떤 대시보드에도 쉽게 통합할 수 있는 다양한 컴포넌트를 제공합니다. 또한, 드롭다운 메뉴와 탭부터 모달창과 테이블까지 모든 요소를 포괄하여 대답할 수 있습니다. 이로 인해 매우 다재다능하며 어떤 대시보드에도 적응할 수 있습니다.\n\n- 자세한 접근성\n- 다크 테마\n- 다양한 개발 컴포넌트\n- 코드 분할 기능\n\n미리보기\n\n다운로드\"\n\n\n\n# Salvia-Kit’s: Next JS Admin 대시보드 템플릿\n\nSalvia-kit의 대시보드는 강력하고 효율적인 프레임워크 인 Next JS에서 구축되어 빠른 성능과 원활한 탐색을 보장합니다.\n\n![대시보드 이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_8.png)\n\n이 대시보드는 사용자 친화적이며 시각적으로 매력적입니다. 직관적인 인터페이스로 원하는 기능을 쉽게 찾아 액세스할 수 있어 소중한 시간을 절약하고 생산성을 향상시킵니다. 또한 NextJS admin 대시보드 템플릿은 매우 사용자 정의가 가능하여 개인적인 요구에 맞게 수정할 수 있습니다. 여러 가지 다른 색상 구성표와 레이아웃을 선택하거나 위젯을 추가하거나 삭제할 수도 있습니다.\n\n\n\n또한 Salvia-kit 대시보드의 뛰어난 기능 중 하나는 실시간 데이터 시각화입니다. 또한, 실시간으로 업데이트되는 동적 차트와 그래프를 통해 웹사이트의 트래픽, 매출 및 기타 주요 지표를 손쉽게 추적할 수 있습니다.\n\n- 활성화된 경로 지원\n- 상세한 사용자 정의\n- 공급 업체 잠금 없음\n- 선호에 따른 좌우 네비게이션\n\n미리보기\n\n다운로드\n\n\n\n# Salvia-kit/dashboard-v6\n\nSalvia-kit 관리자 대시보드 템플릿은 6번째 버전에서 Next.js의 진보된 사용으로 다음 수준으로 나아갑니다. 이 인기있고 강력한 프레임워크는 빠른 개발 능력, 사용 편의성 및 성능 최적화 기능으로 알려져 있습니다.\n\n![Salvia-kit](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_9.png)\n\n또한 Salvia-kit 대시보드에 Next.js를 사용하는 가장 중요한 이점 중 하나는 복잡한 데이터 세트를 쉽게 관리하고 조직화할 수 있는 것입니다. 이 새 버전을 통해 사용자는 특정 요구 사항에 맞는 사용자 정의 데이터 시각화 및 인터랙티브 구성 요소를 유연하게 생성할 수 있습니다. 게다가 Next.js의 모듈식 설계는 컴포넌트를 이전보다 더 빠르게 구축하고 배포할 수 있습니다.\n\n\n\n- 브라우저 호환성\n- 여러 개의 웹 페이지\n- 자세한 사용자 정의\n\n미리보기\n\n다운로드","ogImage":{"url":"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png"},"coverImage":"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트 JS에서 Font Awesome 아이콘 사용하기","description":"","date":"2024-05-14 11:33","slug":"2024-05-14-conesdoFontAwesomenoReactJS","content":"\n\nReact JS에서 Font Awesome 아이콘을 사용하는 방법:\n\n![Font Awesome](/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png)\n\n- SVG Core 설치하기 (아이콘이 작동하는 유틸리티가 포함 된 패키지):\nnpm i — save @fortawesome/fontawesome-svg-core\n- 사용할 키트 패키지 설치. 참고: Font Awesome의 무료 패키지는 다음과 같습니다:\nnpm i — save @fortawesome/free-solid-svg-icons\nnpm i — save @fortawesome/free-regular-svg-icons\nnpm i — save @fortawesome/free-brands-svg-icons\n- Font Awesome 컴포넌트 설치하기:\nnpm i — save @fortawesome/react-fontawesome@latest\n\n- Font Awesome 컴포넌트와 사용할 아이콘들을 import 하기:\nimport 'FontAwesomeIcon' from ‘@fortawesome/react-fontawesome’;\nimport 'icon1, icon2' from ‘@fortawesome/kit that contains the icon’;\n\n\n\n예시:\nimport ' faHtml5, faCss3Alt ' from ‘@fortawesome/free-brands-svg-icons’;\n\n- 프로젝트에 아이콘 삽입:\n`FontAwesomeIcon icon=' 아이콘 ' /`\n\n예시:\n`FontAwesomeIcon icon='faHtml5' /`\n`FontAwesomeIcon icon='faCss3Alt' /`\n\nFont Awesome 문서:","ogImage":{"url":"/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png"},"coverImage":"/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png","tag":["Tech"],"readingTime":1},{"title":"리액트 Context와 useState 함께 사용하는 방법","description":"","date":"2024-05-14 11:32","slug":"2024-05-14-HowtouseReactContextwithuseState","content":"\n\n래엑트 앱에서 props를 도대체 어디서 사용해야 하는지 지친 적이 있나요? Redux에 대한 대안을 찾고 계신가요? 자식 컴포넌트가 props를 사용하지 않고 계속해서 전달하고 있나요? 더 나은 방법이 여기 있어요!\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png)\n\n필수 요구 사항: props, state, 컴포넌트 및 훅에 대한 기본적인 React 지식이 필요합니다. 더불어 TypeScript 지식도 약간 필요합니다. 이 예시에서는 함수형 컴포넌트를 사용할 것입니다. (그리고 제 동료 요한네스가 쓴 React 컴포넌트 작성을 위한 고려 사항 기사도 확인해보세요)\n\n## 개요\n\n\n\n1. 문제와 Context 사용 시기\n2. 쉬운 구현과 기본 사항\n3. 더 현실적인 예제\n4. 고려할 사항\n\n# 1. 문제와 Context 사용 시기\n\nContext를 사용하는 가장 흔한 문제 또는 고려 사항 중 하나는 prop drilling 문제입니다. 이 문제를 설명하기 위해 음식 주문 앱을 예시로 사용하겠습니다. 새롭고 멋진 음식 주문 앱을 작성했다고 상상해보세요. 앱에는 리스트에 표시하고 싶은 음식 항목이 있습니다. 각 음식 항목에는 쇼핑 카트에 항목을 추가할 수 있는 카운터가 있습니다. 주문하기 전에 음식의 양을 보여주는 쇼핑 카트 컴포넌트를 작성했다고 가정해 보겠습니다. 이 앱의 컴포넌트 트리는 다음과 유사할 수 있습니다:\n\n![그림](/assets/img/2024-05-14-HowtouseReactContextwithuseState_1.png)\n\n\n\n음식 항목의 현재 개수를 추적하는 방법을 간단히 보여주는 코드 예제가 있어요. 계수 상태는 FoodCounter 및 FoodSummary 구성 요소에 필요하기 때문에 트리 상단에 있어요.\n\n우리는 상태를 전체 트리를 통해 prop으로 전달하고 있는 것을 알 수 있어요. FoodItem 구성 요소에서는 심지어 상태가 필요하지 않을 수도 있지만, 우리는 단지 FoodCounter 구성 요소에 전달하기 위해 prop을 전달하고 있어요. 이것이 프롭 드릴링 문제에 관한 것이죠. (코드 예제에 표시되어 있지 않은 ShoppingCart 및 FoodSummary 구성 요소에서도 비슷한 일이 발생할 수 있어요)\n\n이렇게 하면 구성 요소가 혼잡해지고, 다른 사람이 코드를 읽는 데 어려워질 수 있어요. 특히 여러 속성을 전달하기 시작하면 더 나빠질 수도 있어요. 그러나 우리가 원하는 것은 구성 요소를 깔끔하게 유지하고 실제 필요한 곳에만 상태를 갖도록 하는 것이에요. 이때 React Context가 도움을 줄 거예요.\n\n# 2. 쉬운 구현으로 기초를 익히기\n\n\n\n자, 이 예제를 조금 더 자세히 살펴볼게요. 모든 구성 요소를 'Component'로 이름을 변경해서 우리가 중점을 두어야 할 중요한 부분, 즉 Context를 구축하는 작업에 집중하도록 할 거에요. 우리는 Context, Context Provider 및 Context Consumer를 생성하여 상태를 다르게 관리할 거에요.\n\n## 세 가지 주요 구성 요소\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_2.png)\n\n위 이미지에서 보다 싶이, 세 가지 주요 구성 요소는 Context, Provider 및 Consumer이기 때문에 우리는 다음을 해야해요:\n\n\n\n- 컨텍스트 생성하기\n- 부모 컴포넌트를 Provider로 감싸기\n- 컨텍스트 사용하기\n\n### 1. 컨텍스트 생성하기\n\n코드 예시에서 보는 것처럼 React에서 컨텍스트를 생성하는 것은 정말 쉽습니다. createContext 함수를 호출하기만 하면 됩니다. 선택적으로 기본값을 전달할 수 있습니다. 이 경우에는 \"defaultValue\"라는 문자열을 전달했습니다.\n\n### 2. 부모 컴포넌트를 Provider로 감싸기\n\n\n\n부모 컴포넌트에서는 반환하는 요소들을 우리의 Context로 감쌀 수 있습니다. 구체적으로, MyContext의 Provider 속성으로 MyParentComponent를 감싸고 있습니다. 이는 우리가 React에서 Context를 생성한 후에 얻는 기본 속성입니다. 다른 파일에서 Context를 생성했다면 쉽게 여기에서 불러와서 사용할 수 있습니다. 예제에서 보시다시피 Provider는 React에서 일반 컴포넌트처럼 사용할 수 있습니다.\n\n게다가, Context Provider 컴포넌트에는 value 속성이 함께 제공됩니다. 우리는 이를 사용하여 마음에 드는 어떤 값을 전달할 수 있습니다. 이 경우 \"My Context Value\" 문자열을 만들어서 Context Provider에 전달해 보겠습니다.\n\n## 3. Context를 사용하고 값을 활용하기\n\nMyComponent 내부나 트리 아래의 다른 자식 컴포넌트에서 이를 사용할 수 있습니다:\n\n\n\n그래서 이제 우리는 MyComponent에서 또는 그 하위 컴포넌트 중 어디에서든 Context를 직접 사용할 수 있습니다. Context를 사용하려면 useContext 훅을 호출하고 Context(MyContext)를 인수로 전달하면 됩니다. 이렇게 하면 Provider에서 제공한 값을 얻을 수 있습니다. 이름이 어디에서 유래했는지 이제 아시겠죠 😉\n\n값을 얻으면 다른 종류의 프롭(prop)이나 상태 변수와 마찬가지로 사용할 수 있습니다. 여기서는 그 값을 단락 안에 반환하기만 합니다.\n\n## 중요: React가 어떻게 해당 값 사용 여부를 알 수 있을까요?\n\n# 3. 좀 더 현실적인 예제\n\n\n\n첫 번째 예는 React Context 개념을 설명하기 위해 범용적이고 최소한의 내용이었습니다. 이제 실제 응용 프로그램에서 찾을 수있는 것과 훨씬 가까운 예제를 살펴볼 것입니다. 예를 들어, 사용자가 앱에서 가입하는 온보딩 또는 등록 흐름을 사용할 것입니다.\n\n이 예제에서 TypeScript를 사용할 것입니다. 또한 useState 훅을 사용할 Provider 컴포넌트를 직접 만들 것입니다. 온보딩 흐름에는 여러 단계가 있어 각 단계 간에 데이터를 공유하고 요약 화면에 데이터를 표시하려는 경우를 상상해보세요. 모든 데이터를 props로 전달하고 싶지 않기 때문에 OnboardingContext를 사용할 것입니다.\n\n우선, 사용자 이름 상태와 사용자 이름 상태를 업데이트하는 setUsername 액션을 가진 Context를 위한 인터페이스를 생성합니다. 여기에서는 단순화를 위해 사용자 이름만 사용합니다. 물론 메일 주소나 사용자의 생일과 같은 속성을 추가할 수 있습니다.\n\n이후에 이전과 같이 Context를 생성하며, 이는 OnboardingContextValue 또는 undefined 유형이 될 수 있습니다. 기본값으로 undefined를 전달합니다. 이제 사용자 정의 Provider 컴포넌트를 만들어봅시다.\n\n\n\n여기서는 평소처럼 useState 훅을 호출하고 사용자 이름과 setUsername 함수를 언팩합니다. 그런 다음 모든 하위 구성 요소를 사용하여 우리의 온보딩 컨텍스트 프로바이더를 반환합니다. 값으로는 사용자 이름과 setUsername 함수만 전달합니다. 물론, 이 시점에서 더 많은 상태를 추가하고 값을 프로바이더에 전달할 수도 있습니다. 아마도 이미 우리가 컨텍스트 생성 시 기본 값으로 undefined를 전달한 이유에 궁금증을 품었을 수도 있습니다. 여기에 그 답이 있습니다:\n\n컨텍스트가 생성되고 일치하는 프로바이더를 찾지 못할 때 undefined가 기본 값으로 사용됩니다. 이는 우리에게 에러를 throw해줍니다. 실제로 이 에러가 발생하길 원합니다. 왜냐하면 우리는 컨텍스트에서 기본 값을 사용하고 싶지 않기 때문입니다. 우리는 커스텀 프로바이더 컴포넌트에서 정의한 상태를 사용하려고 합니다. 그러나 온보딩 컨텍스트가 undefined인 경우 부모 컴포넌트를 커스텀 프로바이더로 감싸놓지 않았을 수도 있습니다.\n\n이 문제를 해결하기 위해 부모 컴포넌트를 커스텀 프로바이더로 감싸놓습니다:\n\n상태 값들을 사용하려면 하위 구성 요소 중 하나에서 커스텀 훅을 사용할 수 있습니다. 그냥 사용자 이름과 setUsername 함수를 언팩하면 됩니다. 이제 이들을 다른 상태 값이나 상태 액션처럼 사용할 수 있습니다. 마치 이 컴포넌트에서 useState 훅을 직접 사용했을 때와 유사합니다. 이렇게 하면 단일 컴포넌트에서 상태를 컨텍스트로 쉽게 옮기는 것도 가능합니다.\n\n\n\n# 4. 고려해야 할 사항\n\n코드베이스에 Context를 도입하기 전에 고려해야 할 몇 가지 사항이 있습니다. 먼저, 데이터에 대해 고민해야 합니다. 컴포넌트에 어떤 데이터가 필요한가요? 그리고 이 데이터가 정확히 어디에 필요한가요? 이를 통해 일반적으로 전체 응용 프로그램을 더 잘 이해할 수 있습니다. 이는 또한 어떤 데이터가 어울리는지, 그리고 데이터가 정말 공유 Context에 있어야 하는지에 대한것도 포함합니다.\n\n이후, 다음 질문을 통해 계속할 수 있습니다. \"현재 사용 중인 상태는 무엇인가요?\" 여전히 이러한 상태가 필요할 수 있지만, 이를 Context로 옮길 수도 있습니다. 어떤 상태를 Context에 넣고 싶은지 스스로에게 묻고, 그 상태가 단 하나의 컴포넌트에만 필요하기 때문에 Context에 필요하지 않은 상태도 파악해야 합니다. 또한 상태를 어떻게 변경하는지도 고민해보세요. set state 함수를 Context로 이동할 수 있지만, 사용자 지정 처리기까지 이동하는 등 더 나아간 방향으로 진행할 수도 있습니다.\n\n마지막으로, prop drilling이 정말 큰 문제인지 스스로에게 물어보아야 합니다. Context를 생성하면 특정한 오버헤드가 발생합니다. 이는 응용 프로그램을 변경하거나 리팩토링하는 데 어렵게 만들 수 있습니다. 예를 들어, Context는 컴포넌트를 테스트하기 어렵게 만들 수 있습니다. 컴포넌트에 모킹된 props를 전달하는 것이 Context로 컴포넌트를 감싼 사용자 지정 테스트 렌더 함수를 작성하는 것보다 쉽습니다. Context의 오버헤드가 props를 전달하는 작은 번거로움만큼 가치가 있는지 스스로에게 물어보세요.\n\n\n\n컨텍스트를 사용하면 컴포넌트 간 데이터 흐름을 이해하기 어려울 수 있어요. 하지만 프롭스를 사용하면 어떤 데이터가 컴포넌트로 들어오고 나가는지 항상 명확하게 알 수 있어요. 컨텍스트를 사용하면 실제 데이터가 어디에서 오는지 찾기 위해 조사를 먼저 해야할 수도 있어요.\n\n## 요약하자면\n\n우리가 하는 일을 좋아하시나요? 함께 하고 싶으신가요? 저희의 최신 채용정보를 확인해보세요: https://www.comsystoreply.com/career\n\n이 블로그 포스트는 Comsysto Reply GmbH에서 발행되었습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png"},"coverImage":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"React Server Components와 NextJS Best Practices, 팁","description":"","date":"2024-05-14 11:30","slug":"2024-05-14-ReactServerComponentswithNextJSBestPracticesTips","content":"\n\nReact Server Components (RSCs)는 React 애플리케이션의 서버 측 렌더링(SSR)에 대한 생각 방식을 변경할 것으로 약속합니다. 이 개념은 개발자 커뮤니티 내에서 긍정적인 관심을 불러일으켰어요. Next.js가 이제 RSCs를 지원함에 따라, 개발자들은 전통적인 싱글 페이지 애플리케이션에 일반적으로 연관된 복잡성 없이 SSR을 받아들일 수 있게 되었습니다. 그러나, 새로운 프레임워크나 기술에는 항상 개발자가 알아야 할 도전과 함정이 따르게 됩니다.\n이 가이드는 NextJS와 함께 RSCs를 탐험하려는 프론트엔드 개발자를 대상으로 합니다.\n\n## 서버 측 렌더링에 대한 간단한 소개:\n\n서버 측 렌더링은 자바스크립트 코드를 실행하고, 서버 측에서 웹 페이지의 초기 HTML을 생성한 후, 완전히 렌더링된 페이지가 브라우저로 전달됩니다.\n\n이 방식에는 몇 가지 장점이 있습니다:\n\n\n\n- SEO 순위 향상: 검색 엔진이 이미 HTML로 렌더링된 페이지 컨텐츠를 쉽게 색인화할 수 있습니다.\n- 빠른 성능: 브라우저가 서버로부터 HTML을 받자마자 페이지 컨텐츠의 렌더링을 시작할 수 있습니다. 이는 인지되는 성능을 최적화합니다.\n- 접근성: JavaScript를 비활성화한 사용자도 페이지 컨텐츠를 볼 수 있습니다.\n\n전통적인 클라이언트 렌더링:\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png)\n\n서버 측 렌더링:\n\n\n\n\n![React Server Components with Next.js Best Practices and Tips](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_1.png)\n\nRSC와 함께 사용할 때 고려해야 할 몇 가지 최상의 실천 방안을 살펴보겠습니다.\n\n## 서버-클라이언트 경계 이동하기:\n\nNextJS 13+에서는 기본적으로 트래디셔널 페이지 라우터 대신 App 라우터를 제공합니다. 이 경계를 이해하는 것은 효과적인 컴포넌트 관리에 중요합니다. App 라우터를 사용하면 우리가 생성하는 모든 컴포넌트는 클라이언트로 명시되지 않는 한 서버 컴포넌트로 간주됩니다.\nhttps://nextjs.org/docs/app/building-your-application/routing\n\n\n\n\n지금 '서버 클라이언트 경계'가 뭔가요?\n\n이것은 NextJS의 서버 및 클라이언트 구성 요소 사이의 가상의 경계입니다. 서버 구성 요소는 엄격히 서버 측에서 처리되어 클라이언트 번들의 일부로 다운로드되지 않습니다.\n\n이 경계는 어떻게 정의되나요?\n\n이전에 설명했듯이, App 라우터의 모든 구성 요소는 기본적으로 서버 구성 요소이며 클라이언트로 지정되지 않는 한입니다.\n\n\n\n그래서, 클라이언트 구성 요소를 지정하는 방법은 무엇인가요?\n\n클라이언트 번들의 일부로 구성 요소가 해석되도록 하려면 JavaScript/TypeScript 파일의 맨 위에 'use client'를 언급해야 합니다.\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_2.png)\n\n서버 측으로 이동할 컴포넌트와 클라이언트 측으로 이동할 컴포넌트를 선택하는 방법:\n\n\n\n서버 구성 요소 (데이터 가져오기): 서버 구성 요소를 루트 구성 요소로 설정하는 것이 좋습니다. 루트 구성 요소는 모든 클라이언트 구성 요소를 감싸야 합니다. 이 구성 요소의 목적은 API 호출을 수행하고 내부 구성 요소를 위한 래퍼 HTML을 생성하는 것입니다. 서버 구성 요소의 장점 중 하나는 민감한 데이터(인증/로그인 정보)를 처리하는 데 사용할 수 있다는 것입니다.\n\n클라이언트 구성 요소 (상호작용): 상호작용이 많은 하위 구성 요소로 설정해야 합니다. 이 구성 요소들은 훅 같은 기능을 사용할 필요가 있습니다. Redux와 같은 상태 관리 도구는 클라이언트 구성 요소에서만 사용할 수 있습니다. 이들은 부모 구성 요소로부터 데이터를 prop drilling을 통해 전달받을 수 있습니다.\n\n## 우선 순위에 따른 사전 렌더링:\n\n사전 렌더링은 NextJS의 가장 강력한 기능 중 하나입니다. 브라우저가 웹페이지를 요청할 때 NextJS는 클라이언트 및 서버 구성 요소를 사용하여 사전 렌더링된 HTML을 생성합니다. 이는 백그라운드에서 NextJS/React가 상호작용을 위해 구성 요소를 업데이트하는 동안 초기 페이지 콘텐츠를 빠르게 전달하는 데 도움이 됩니다.\n그렇다면 '우선 순위에 따른 사전 렌더링'이란 무엇을 의미할까요?\nNextJS는 초기 페이지 로드 시 고객에게 표시되는 부분과 그렇지 않은 부분을 모두 사전 렌더링합니다. 이는 느린 네트워크에서 로드할 때 FCP (첫 콘텐츠 렌더링) 지연이 몇 초까지 발생할 수 있습니다.\n예를 들어 드롭다운을 개발 중이라고 가정해 봅시다. 일반적으로 초기 페이지 로드 시 드롭다운 제목만 표시되고 실제 콘텐츠는 마우스를 가져가면 활성화됩니다. 따라서 이상적으로는 컴포넌트를 분할하고 요청 시 부분을 동적으로 로드해야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_3.png)\n\n페이지 전체에 최적화되면 웹페이지의 FCP(첫 번째 콘텐츠 표시)가 줄어들고 페이지가 더 빠르게 렌더링됩니다.\n\n## 동적/레이지 로딩:\n\n위 주제를 더 확장하기 위해 웹페이지 전체에 대한 리액트 컴포넌트의 레이지 로딩 또는 동적 로딩으로 많은 최적화를 수행할 수 있습니다. 모든 것을 사전 렌더링할 필요는 없습니다.\n'react.lazy' 또는 Next/dynamic과 함께 동적 임포트를 사용할 수 있습니다.\n\n\n\n리액트.lazy는 좋지만 클라이언트 측에서 컴포넌트를 렌더링하지 않는 옵션을 제공하지 않습니다. 컴포넌트를 가져올 때 'ssr: false' 플래그를 사용하여 서버 측에서 렌더링되지 않도록 할 수 있습니다.\n\n## 서버 컴포넌트와 CSS:\n\n서버 컴포넌트는 발전 중이지만 몇 가지 제한 사항이 여전히 존재합니다. 서버 컴포넌트로 HTML을 렌더링할 수 있지만, 기기별로 지나치게 구체적이거나 CSS가 많이 사용된 컴포넌트는 피하는 것이 좋습니다. 오직 드문드문한 HTML/CSS만 남기는 주요 이유 중 하나는 서버가 웹 페이지를 요청하는 기기를 모르기 때문에 기기별 HTML 블록을 렌더링하는 것을 방지하기 때문입니다.\n\n모든 최상의 실천 방법을 모두 포함하지는 않겠지만 RSCs를 시작하는 데 도움이 되리라 생각됩니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png"},"coverImage":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png","tag":["Tech"],"readingTime":4},{"title":"Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기","description":"","date":"2024-05-14 11:28","slug":"2024-05-14-ReactComponentLibrarywithViteandDeployinNPM","content":"\n\n![ReactComponentTutorial](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png)\n\n안녕하세요! 이 튜토리얼은 React 및 Vite를 사용하여 TypeScript 템플릿으로 React 컴포넌트를 빌드하고, 그것을 NPM에 게시하는 방법을 안내하기 위해 만들어졌어요. 이 빌드 패키지는 다른 React 애플리케이션에서도 재사용할 수 있어요. 저희는 빌드 도구 및 로컬 개발 환경으로 Vite를 사용할 거예요. 로컬 개발 환경으로 storybook을 사용할 수도 있지만, 간단함을 위해 vite를 사용할 거에요.\n\n# 준비물\n\n- Git이 설치되어 있어야 해요.\n- NodeJs와 NPM이 설치되어 있어야 해요.\n- NPM 계정이 있어야 해요. 계정이 없다면, NPM 계정을 만들어 주세요.\n\n\n\n# 초기 설정 및 컴포넌트 라이브러리 생성\n\n## 단계 1: Vite를 사용하여 React 프로젝트 생성하기\n\nVite를 사용하여 TypeScript 템플릿을 갖춘 React 프로젝트를 생성해보세요. 아래 명령어를 사용하여 React 프로젝트를 생성할 수 있습니다.\n\n```js\nnpm init vite@latest react-vite-library -- --template react-ts\n```\n\n\n\n프레임워크를 선택하라는 안내가 있을 것입니다.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_1.png)\n\nReact를 선택하고 입력하라고 하면\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_2.png)\n\n\n\nTypeScript 변형을 선택하고 입력하세요. TypeScript로 만들어진 React 프로젝트가 생성됩니다.\n\n## 단계 2: Prettier와 ESLint 구성\n\nPrettier와 ESLint를 구성하는 이유는 프로그래밍 및 스타일 오류에 대한 일련의 규칙에 대해 분석하여 소스 코드를 평가하고 디버깅하는 데 도움이 되기 때문입니다. 이를 통해 개발자가 코드를 실행하기 전에 오류를 찾을 수 있습니다. 규칙은 또한 최상의 코드 표준과 관행을 시행하며, 더 좋은 코드 품질, 더 가독성이 좋고 유지보수하기 쉬운 코드를 제공합니다.\n\n프로젝트에 ESLint를 설치해 봅시다.\n\n\n\n```js\nyarn global add eslint // 전역에 설치합니다\nyarn add -D eslint  // 이 명령어는 package.json의 devDependencies에 eslint를 추가합니다\n```\n\neslint를 설치한 후, eslint --init을 실행하여 프로젝트에서 eslint를 구성하세요. 그럼 질문이 나올 텐데, 주어진 옵션을 선택하고 eslint가 프로젝트에 구성될 때까지 계속 입력하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_3.png\" /\u003e\n\n프로젝트용 모듈 유형을 선택하고 입력하세요.\n\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_4.png)\n\nReact 프레임워크를 선택하고 입력해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_5.png)\n\n프로젝트는 TypeScript를 사용하므로 '예'를 선택하고 입력해주세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_6.png\" /\u003e\n\nJSON을 선택하고 입력하세요\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_7.png\" /\u003e\n\n마지막 단계에서 패키지를 설치하라는 메시지가 표시됩니다. 이때 yes를 선택하면 npm이 패키지를 설치해 줍니다. 만약 yarn을 사용 중이라면 no를 선택하고 yarn을 사용하여 패키지를 설치할 수 있습니다.\n\n\n\nmd\n![React Component Library with Vite and Deploy in NPM](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_8.png)\n\n프로젝트 루트에 .eslintc.json 파일이 생성됩니다. 이 파일에는 기본 구성이 포함되어 있습니다. 필요에 따라 규칙을 추가할 수 있습니다. 아래의 구성을 직접 사용할 수도 있습니다: .eslintc.json.\n\n위 구성에는 prettier, react-hooks 및 simple-import-sort가 포함되어 있습니다. 다음 명령어를 사용하여 패키지를 설치할 수 있습니다.\n\n```js\nyarn add -D react-hooks eslint-plugin-simple-import-sort prettier\n\nnpm install -D react-hooks eslint-plugin-simple-import-sort prettier\n``` \n\n\n\n\n프로젝트 루트에 .prettierrc 파일을 만들고 다음 코드를 포함하세요. 이 코드는 코드를 서식 맞추는 데 사용됩니다.\n\npackage.json에 다음 스크립트를 추가하세요.\n\n```js\n\"lint\": \"eslint 'src/**/*.{js,jsx,ts,tsx}'\",\n\"lint:fix\": \"eslint --fix 'src/**/*.{jsx,ts,tsx}'\",\n\"format\": \"prettier --write src//**/*.{ts,tsx,css} --config ./.prettierrc\",\n```\n\n## 단계 3: husky 및 lint-staged 구성하기\n\n\n\nGit 훅은 git 실행 중 특정 시점에서 액션을 트리거할 수 있게 해줍니다. 코드베이스를 깨끗하게 유지하는 데 중요한 역할을 합니다. 코드 형식을 확인하거나 린트를 실행하거나 코드가 커밋되거나 원격 저장소로 푸시되기 전에 테스트를 실행하는 등의 작업을 수행할 수 있습니다. Husky를 사용하면 git 훅을 더 쉽게 사용할 수 있습니다. 이 프로젝트에서는 pre-commit 훅만 사용하며 lint-staged 패키지를 사용하여 git 훅을 staged 파일에만 적용합니다.\n\n```js\nnpm install husky --save-dev\nyarn add -D husky\n```\n\npackage.json에 다음 스크립트를 추가하고 yarn prepare를 실행합니다. 스크립트를 실행한 후 프로젝트 루트에 .husky 폴더가 생성됩니다.\n\n```js\n\"prepare\": \"husky install\"\n```\n\n\n\n그런 다음 다음 명령을 실행하여 pre-commit 훅을 추가합니다.\n\n```js\nnpx husky add .husky/pre-commit \"yarn lint-staged\"\ngit add .husky/pre-commit\n```\n\n이제 아래 내용으로 package.json 파일을 업데이트하십시오.\n\n프로젝트에 Husky와 lint-staged가 성공적으로 추가되었습니다.\n\n\n\n## 단계 4: 라이브러리에 포함시킬 컴포넌트들 생성하기\n\nsrc/components 폴더 안에 컴포넌트들을 생성하세요.\n\n- src/components/HelloWorld.tsx\n- src/components/style.css\n\n\n\nsrc/components/index.ts: 이 파일은 모든 것이 이 한 파일에서 내보내어지는 컴포넌트의 주 진입점입니다.\n\n## 단계 5: vite.config.ts 설정\n\n컴포넌트 라이브러리의 빌드 버전을 생성하기 위해 vite.config.ts 파일을 구성해야 합니다.\n\n- 에디터에서 /vite.config.js를 열고 다음을 붙여넣으세요:\n\n\n\n2. linterPlugin은 프로젝트의 린트를 확인하는 데 사용됩니다. dts은 구성 요소 라이브러리에서 사용되는 유형 정의를 생성하는 데 사용됩니다. dts 내부에는 구성 요소가 포함된 폴더의 위치가 포함되어 있습니다.\n\n3. name: `ReactViteLibrary`를 귀하의 구성 요소의 이름으로 교체하는지 확인하십시오.\n\n4. 마찬가지로, fileName 값의 react-vite-library가 귀하의 구성 요소의 이름으로 변경되었는지 확인하십시오.\n\n5. entry: resolve(\"src\",\"component.index.ts\")를 귀하의 구성 요소에서 모든 것이 내보내지는 주 파일의 경로로 대체하십시오. 이는 귀하의 구성 요소의 주 진입점입니다.\n\n\n\n6. `rollupOptions`은 직접적으로 기존의 Rollup 번들을 사용자 정의할 수 있습니다. 이는 Rollup 구성 파일에서 내보낼 수 있는 옵션들과 동일하며, Vite의 내부 Rollup 옵션과 병합됩니다.\n\n## 단계 6: tsConfig.json 및 tsConfig.node.json 구성하기\n\ntsConfig.json에 다음 코드를 포함하세요.\n\n위의 예시에서, `react-vite-library: [\"src\",\"component.index.ts\"]`는 `componentLibraryName: main entry file 위치`를 나타내며, `typeRoots`는 빌드 요소에 포함될 유형을 나타냅니다.\n\n\n\ntsConfig.node.json에 다음 코드를 포함하세요.\n\n## 단계 7: package.json 구성\n\n다음 내용으로 package.json을 업데이트하세요.\n\n- react-vite-library의 모든 인스턴스를 귀하의 컴포넌트/패키지 이름으로 바꿉니다. 다른 npm 패키지에서 이미 존재하지 않아야 합니다. 이 이름은 사용자가 프로젝트에 귀하의 컴포넌트를 설치하는 데 입력할 것이기 때문에 예를 들어: npm install my-component. 해당 이름이 이미 사용 중인지 npm 웹 사이트에서 검색하여 확인할 수 있습니다.\n- description, author 및 keywords에 자체 값 추가\n- 라이선스를 선호하는 대로 변경\n- React를 개발 종속성으로 설치하세요. 리액트 앱은 귀하의 컴포넌트 패키지에 대한 React 제품 의존성을 책임지기 때문에 프로덕션 종속성으로 설치하지 않습니다.\n- repository, bugs 및 homepage에 자체 GitHub 저장소 링크를 추가하세요\n\n\n\n## 단계 8: 빌드\n\n만약 yarn build를 실행하면, 프로젝트 루트에 dist 폴더가 생성됩니다. 이 폴더 안에는 4단계에서 빌드한 컴포넌트들이 포함되어 있습니다.\n\n# 버전 태그 생성\n\n빌드한 패키지를 릴리스하기 위해 버전 태그를 생성해야 합니다. package.json 파일에서 버전 태그를 간단하게 편집할 수 있습니다. 여기서는 버전을 개발하기 위해 GitHub 액션을 사용할 것입니다.\n\n\n\n- GitHub 저장소로 이동해서 액션을 클릭해주세요\n\n![액션 클릭](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_9.png)\n\n2. 직접 workflow를 설정하고 아래 코드를 복사하여 붙여넣기해주세요\n\n버전 태그를 생성하기 위해 이 액션을 패치해야 합니다. 이를 위해 액션으로 이동해야 합니다.\n\n\n\n- 버전을 생성하는 GitHub 액션을 선택하고 아래에 표시된 \"Run workflow\"를 클릭하세요:\n\n![GitHub 액션](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_10.png)\n\n2. GitHub 액션이 완료되면 버전 태그를 받게 됩니다.\n\n![버전 태그](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_11.png)\n\n\n\n# NPM에 발행하기\n\n컴포넌트 라이브러리를 NPM에 발행하려면 NPM 계정이 있어야 합니다. 계정이 없다면 NPM에 발행하기 전에 먼저 계정을 만들어주세요. NPM에 컴포넌트 라이브러리를 발행하는 방법은 두 가지가 있습니다: NPM 명령줄을 사용하여 직접 발행하거나 GitHub 작업을 사용해 발행합니다.\n\n명령줄 도구를 사용하여 발행하기\n\n단계 1: 먼저 package.json 파일의 버전 번호가 올바른지이며, 의미론적 버전 규칙을 준수하는지 확인하세요. 각 새로운 버전 번호로 NPM에 발행할 때마다 이 작업을 수행해야 합니다.\n\n\n\n단계 2: 테스트를 작성했다면, 테스트 및 린트 규칙을 모두 통과하는지 확인하세요.\n\n```js\nyarn run test\nyarn run lint\n```\n\n단계 3: 컴포넌트를 빌드하려면 `yarn build`를 실행하세요. UMD 및 ESM 모듈 형식이 생성되고 `/dist` 폴더에 배치됩니다.\n\n단계 4: npm에 로그인되어 있는지 확인하세요. 그렇지 않은 경우 다음을 입력하세요:\n\n\n\n```js\nnpm login\n```\n\n단계 5: 컴포넌트를 게시합니다\n\n```js\nnpm publish\n```\n\nGitHub 작업을 사용하여 게시하기\n\n\n\n단계 1: GitHub 리포지토리로 이동하여 Actions를 클릭하세요.\n\n단계 2: 새 워크플로우를 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_12.png)\n\n단계 3: 직접 워크플로우를 설정하기를 클릭하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_13.png)\n\n단계 4: 다음 코드를 복사하여 GitHub 작업을 생성합니다.\n\n단계 4: GitHub 작업 위에 secrets.NPM_TOKEN이 있습니다. 따라서 NPM에서 액세스 토큰을 생성해야 합니다.\n\n- https://www.npmjs.com/으로 이동하여 계정에 로그인합니다. 프로필 아이콘을 클릭하면 다음 드롭다운 메뉴가 표시되며, 액세스를 선택합니다.\n\n\n\n![새 토큰 생성하기](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_14.png)\n\n2. 새 토큰을 생성하세요\n\n![정보 작성 및 액세스 토큰 생성](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_15.png)\n\n3. 정보를 작성하고 액세스 토큰을 생성하세요\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_16.png\" /\u003e\n\n4. 방금 생성한 액세스 토큰을 복사한 후 깃허브 리포지토리 설정으로 이동하십시오. 그리고 새 리포지토리 시크릿을 클릭하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_17.png\" /\u003e\n\n5. 액세스 토큰을 붙여넣고 시크릿을 추가하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_18.png\" /\u003e\n\n비밀 키를 리포지토리에 성공적으로 추가했습니다.\n\n단계 5: 이제 '새 릴리스 만들기'를 클릭하여 릴리스를 생성하세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_19.png\" /\u003e\n\n\n\n단계 6: 버전 태그를 선택하고 정보를 입력한 후 '릴리스 게시'를 클릭하세요.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_20.png)\n\n단계 7: 게시를 클릭한 후에는 만든 GitHub 작업이 실행됩니다. \"액션\"으로 이동하여 확인할 수 있습니다.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_21.png)\n\n\n\n8단계: 패키지가 성공적으로 게시되었습니다. NPM 계정으로 이동하여 확인해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_22.png)\n\n# 결론\n\nReact 컴포넌트 라이브러리를 성공적으로 만들었고 NPM에 게시했습니다. 이제 할 일 중 하나는 테스트 애플리케이션을 만들고 NPM에서 컴포넌트를 설치하는 것입니다. 그런 다음 의도한 대로 작동하는지 확인할 수 있습니다.\n\n\n\n# 보너스\n\n저는 이 간단한 방법을 사용하여 구축한 또 다른 컴포넌트 라이브러리가 있습니다. 해당 라이브러리를 사용하면 하나의 패키지로 다른 종류의 모달을 사용할 수 있습니다. https://www.npmjs.com/package/react-global-modal\n\n코딩 즐기세요. 👨🏻‍💻","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png","tag":["Tech"],"readingTime":9},{"title":"ReactJS에서 상태 관리 다루기 흔한 문제와 해결책","description":"","date":"2024-05-14 11:25","slug":"2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution","content":"\n\n![이미지](/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png)\n\nReactJS는 구성 요소 기반 아키텍처와 가상 DOM으로 유명한 JavaScript 라이브러리입니다. 그러나 ReactJS에서 상태를 관리하는 것은 응용 프로그램이 복잡해질수록 어려울 수 있습니다. 이 기사에서는 ReactJS 상태 관리에서 발생하는 일반적인 문제를 탐구하고 해결책을 제시할 것입니다.\n\n## 문제: 상태와 인스턴스 속성을 혼동하는 문제\n\n클래스 구성 요소에서 개발자들은 자주 로컬 상태 객체를 정의하고 `this`로 접근합니다. 그러나 상태 이외에도 로컬 인스턴스 속성을 정의할 수도 있습니다. 이로 인해 혼란이 생길 수 있습니다. 다음 코드에서 확인할 수 있습니다:\n\n\n\n```JavaScript\r\n1class 인사 extends React.Component { \n2  user = { \n3    name: \"World\", \n4  };\n5\n6  state = { \n7    name: \"World\", \n8  };\n9\n10  render() { \n11    return `안녕하세요 ${this.user.name}`; // \"안녕하세요 World\"을 반환합니다.\n12  }\n13}\r\n```\r\n\r\n이 예에서 사용자 속성과 상태 객체는 둘 다 값이 \"World\"인 name 속성을 포함하고 있습니다. 그러나 render 메서드는 상태 객체 대신 사용자 속성에 접근합니다. 이는 예상치 못한 동작을 유발할 수 있으며 상태를 일관된 방법으로 관리하기 어렵게 만들 수 있습니다. \r\n\r\n## 해결책: 애플리케이션 상태 관리에 상태(State)를 전적으로 사용하기\n\n\n\n혼란을 피하기 위해 응용 프로그램 상태를 관리할 때는 상태를 전적으로 사용하는 것이 좋습니다. 이것은 개발자들이 상태와 유사한 데이터가 포함된 로컬 인스턴스 속성을 정의하는 것을 피해야 함을 의미합니다. 대신에 모든 상태는 상태 객체에 정의되어야하며 this.state를 사용하여 액세스되어야 합니다.\n\n다음은 권장되는 방법을 사용하여 클래스 컴포넌트에서 상태를 관리하는 예시입니다:\n\n```js\nclass Greeting extends React.Component { \n  state = { \n    name: \"World\", \n  };\n\n  render() { \n    return `Hello ${this.state.name}`; // \"Hello World\"를 반환합니다.\n  }\n}\n```\n\n\n\n\n이 예제에서는 name 속성이 state 객체에 정의되어 있고 this.state.name을 사용하여 액세스됩니다. 이렇게 함으로써 name 속성이 애플리케이션 상태의 일부임을 명확히하고 적절히 관리되어야 함을 나타냅니다.\n\n## 결론\n\nReactJS에서 상태를 관리하는 것은 도전일 수 있지만, 최선의 방법을 따르면 도움이 될 수 있습니다. 이 글에서는 ReactJS 상태 관리에서 흔한 문제인 상태와 인스턴스 속성을 혼동하는 문제를 탐구하고 해결책을 제시했습니다. 애플리케이션 상태를 관리하기 위해 state를 전적으로 사용함으로써, 개발자들은 혼란을 피하고 애플리케이션을 유지보수 가능하고 확장 가능하도록할 수 있습니다.\n\n또한, React는 훅의 도입으로 상태를 관리하는 새로운 방법을 제공하는데, 이를 통해 클래스를 작성하지 않고도 디벨로퍼들이 상태와 다른 React 기능을 사용할 수 있습니다. 이는 상태 관리를 간소화하고 최선의 방법을 따르기 쉽도록 도와줄 수 있습니다.\n\n\n\n요약하면, ReactJS에서 상태를 관리하는 것은 세심한 주의와 일관된 방법을 요구합니다. 상태를 응용 프로그램 상태를 관리하기 위해 전적으로 사용하고 모베스트 프랙티스를 따르면, 개발자들은 애플리케이션이 유지보수 가능하고 확장 가능하며 이해하기 쉬운 것을 보장할 수 있습니다.\n\n# 쉽게 설명한 것 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 꼭 박수를 보내고 작가를 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png"},"coverImage":"/assets/img/2024-05-14-HandlingStateManagementinReactJSACommonProblemandSolution_0.png","tag":["Tech"],"readingTime":3},{"title":"첫 번째 React 앱을 GitHub에 푸시하는 방법 단계별 안내","description":"","date":"2024-05-14 11:24","slug":"2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide","content":"\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png)\n\n이전에 작성한 기사에서(https://medium.com/@regondaakhil1509/getting-started-with-react-a-beginners-guide-to-setting-up-your-first-application-a6d8a1ae414), React 애플리케이션을 설정하는 과정을 안내했습니다. 이제 로컬 코드를 GitHub에 올리는 방법을 배우는 것이 시간입니다. 이 단계별 가이드는 새로운 리포지토리를 GitHub에 생성하고 로컬 리포지토리에 연결하고 코드를 원격 리포지토리에 푸시하는 방법을 보여줍니다.\n\nReact가 처음이거나 GitHub를 시작한지 얼마 안 된 경우에도 이 튜토리얼은 프로젝트를 온라인으로 만들어 공동 작업자나 잠재적인 고용주에게 접근 가능하도록 도와줄 것입니다. React 스킬을 다음 수준으로 끌어 올리기 위해 준비하세요!\n\n# 소개 - Git 및 GitHub에 대해\n\n\n\n![2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_1.png)\n\n깃\n\n- 깃은 코드 변경을 관리하는 버전 관리 시스템입니다.\n- 깃을 사용하면 개발자들은 코드 버전을 추적하고, 다른 사람들과 협업하며, 필요할 때 이전 버전으로 되돌릴 수 있습니다.\n- 깃은 여러 개발자가 동시에 동일한 프로젝트에 작업할 수 있는 분산 버전 관리 시스템입니다. 각 개발자는 자신의 로컬 머신에 코드 저장소의 완전한 복사본을 가지고 있습니다.\n- 깃에 대해 더 알아보려면 https://git-scm.com/about를 방문해보세요.\n\n깃허브\n\n\n\n- GitHub은 Git 저장소를 호스팅하는 웹 기반 플랫폼입니다.\n- 협업을 더 쉽게 만드는 풀 리퀘스트, 이슈 추적 및 코드 리뷰와 같은 기능을 제공합니다.\n- GitHub에는 개발자들이 서로를 팔로우하고 자신의 작업을 보다 넓은 커뮤니티와 공유할 수 있는 소셜 측면도 있습니다.\n- GitHub에 대해 더 알아보려면 https://github.blog/category/company/에서 확인할 수 있습니다.\n\n- GitHub는 Git 호스팅을 제공하는 유일한 플랫폼이 아닙니다.\n- 다른 Git 호스팅 플랫폼으로는 GitLab, Bitbucket 및 SourceForge 등이 있습니다.\n- GitHub는 사용하기 쉽고 다양한 기능을 갖춘 편리한 플랫폼이어서 인기가 많습니다.\n\n## 설정\n\n시작하기 전에 기술적 선행 조건이 모두 갖추어져 있는지 확인하는 것이 중요합니다. 가장 중요한 요구 사항은 로컬 머신에 Git이 설치되어 있어야 한다는 것입니다. 아직 Git을 설치하지 않은 경우 https://git-scm.com/downloads 에서 Git을 다운로드하고 설치할 수 있습니다.\n\n\n\n설치 과정을 확인하려면 터미널에서 다음 명령을 실행하세요:\n\n```js\ngit -v\n```\n\n예시(숫자는 시스템에 따라 다를 수 있습니다):\n\n![예시 이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_2.png)\n\n\n\n다음 단계는 아직 GitHub 계정을 만들지 않으셨다면 GitHub 계정을 생성해야 합니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_3.png)\n\nGitHub 대시보드에서 새 저장소를 만들려면 페이지의 오른쪽 상단을 나타내는 플러스 기호로 표시된 드롭다운 메뉴를 클릭하십시오. 거기서 \"New repository\"로 표시된 옵션을 선택하거나 New Repository를 클릭할 수 있습니다.\n\n![image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_4.png)\n\n\n\n그 다음으로, 양식을 완성해야 합니다.\n\n- \"저장소 이름\" 필드에 저장소 이름을 입력하세요.\n- 선택사항으로 \"설명\" 필드에 저장소에 대한 설명을 추가할 수 있습니다.\n- 저장소의 가시성 설정을 선택하세요. 저장소를 비공개로 유지하려면 \"비공개\"를 선택하세요. 그렇지 않으면 \"공개\"를 선택하세요.\n- 저장소에 README 파일을 만들고 싶다면 \"이 저장소에 README 파일 추가\" 확인란을 선택하세요.\n- 원하는 경우 저장소에 라이선스를 선택하세요. 인기 있는 오픈소스 라이선스 목록 중에서 선택하거나 라이선스를 추가하고 싶지 않다면 \"없음\"을 선택하세요.\n- \"저장소 만들기\" 버튼을 클릭하세요.\n\n![Image](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_5.png)\n\n만세! 새로운 저장소를 만들었어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_6.png\" /\u003e\n\n다음 단계는 코드를 로컬에서 GitHub로 이동하는 것입니다.\n\n만약 처음으로 git을 설정하고 있다면, git을 이름 및 이메일로 구성해야 합니다. 터미널에서 다음 명령어를 실행하세요.\n\n```js\ngit config --global user.email \"Your_Email\"\ngit config --global user.name \"Your_Name\"\n```\n\n\n\n로컬 React 프로젝트에서 Git을 초기화하려면:\n\nVS Code에서 \"your_local_repo\" 폴더(저의 경우, my_portfolio)를 열고 터미널을 열어 해당 디렉토리에서 Git을 초기화하는 명령을 실행하세요.\n\n```js\ngit init\n```\n\n\n\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_7.png)\n\nGitHub의 원격 저장소 링크는 저장소 페이지에서 \"Code\" 버튼을 클릭하여 찾을 수 있습니다. 적절한 프로토콜을 선택(우리의 경우 HTTPS), URL을 클립보드에 복사하고, VS 코드 터미널에서 다음 명령을 실행합니다.\n\n```js\ngit remote add origin https://github.com/your-username/your-repo.git\n```\n\n변경 내용을 스테이징하고 커밋하세요:\n\n\n\n\nReact 프로젝트의 모든 파일을 준비하는 \"git add\" 명령어를 사용하고, 그 변경 사항을 커밋하기 위해 \"git commit\" 명령어를 사용하세요.\n\n```js\ngit add .\ngit commit -m \"커밋 메시지 작성\"\n```\n\nGitHub로 변경 사항을 푸시하세요:\n\n마지막으로, 커밋된 변경 사항을 GitHub 리포지토리에 푸시하기 위해 \"git push\" 명령어를 사용하세요.\n\n\n\n```js\ngit push -u origin main\n```\n\n와우! 이렇게 하면 로컬 React 파일이 GitHub에 업로드되어 원격 저장소에서 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_8.png)\n","ogImage":{"url":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-14-PushingYourFirstReactApptoGitHubAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 컴포넌트 슬롯과 리액트","description":"","date":"2024-05-14 11:22","slug":"2024-05-14-WebComponentsslotsandReact","content":"\n\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_0.png)\n\nReact에서 컨텐츠는 children 속성을 통해 컴포넌트로 전달됩니다. 이 속성은 요소의 JSX 태그 내에 캡슐화된 컨텐츠를 위해 특별히 설계되었습니다. 그러나 이 방법은 더 복잡한 템플릿이나 JSX를 컴포넌트의 다른 섹션에 배치해야 하는 경우 부족할 수 있습니다. 다행히 JSX는 함수와 JSX를 모두 props를 통해 전달할 수 있기 때문에 문제없이 이를 구현할 수 있습니다.\n\nWeb Components에서 컨텐츠 처리는 React와 약간 다릅니다. 컴포넌트가 HTML로 렌더링되기 때문에 함수나 HTML(또는 JSX)을 props를 통해 전달할 수 없습니다. 대신, SLOTS를 사용합니다. 이것들은 컴포넌트 내에서 다양한 유형의 HTML 블록을 배치할 수 있는 지정된 영역입니다. 복잡한 컴포넌트에서 적절한 구성을 위해 사용됩니다. 브라우저의 인스펙터에서 슬롯이 약간 다르게 나타날 수 있다는 점을 주목하는 것이 중요합니다.\n\n![Web Components and React](/assets/img/2024-05-14-WebComponentsslotsandReact_1.png)\n\n\n\n\n웹 페이지의 코드 인스펙터에서는 리다이렉트 기호와 함께 'reveal' 옵션을 볼 수 있습니다. 이 옵션을 클릭하면 DOM 내에서 다른 블록으로 이동하며, 해당 지점에서 렌더링됩니다. 이 기능을 통해 개발자는 Web Components의 복잡한 구성 요소 구조에서 컨텐츠가 정확히 어디에 렌더링되는지 추적할 수 있습니다.\n\nStencil에서는 속성을 통해 HTML 내용을 전달하는 것이 가능합니다 (코드 인스펙터에서 'right'로 된 div에서 확인할 수 있습니다). 그러나 이는 Vanilla JS와 유사하게 처리됩니다. 이를 위해 HTML 내용은 문자열 형태로 속성을 통해 전달되어야 합니다. 그런 다음 componentDidLoad() 라이프사이클 메서드 내에서 @Watch로 데코레이팅된 함수가 트리거되어야 합니다. 이 함수는 querySelector를 사용하여 HTML 블록이 삽입될 특정 div를 찾습니다. 마지막으로, 찾은 요소의 innerHTML이 HTML 내용을 삽입하도록 변형됩니다.\n\n고려해야 할 주요 요소: HTML은 문자열로 시작하지만 중요한 점은 HTML이다. 따라서 style 태그가 사용되면 kebab-case 규칙을 준수해야 합니다. useRef()와 같이 특정 리액트 기능은 이 문맥에서 사용할 수 없으므로 자식 요소를 효율적으로 전달하는 가장 최적의 방법이 아닙니다. 결과적으로, 이러한 환경에서 자식 요소를 효과적으로 전달하는 유일한 방법은 슬롯(slots)을 통해 이루어지게 됩니다.\n\n```js\nimport { Prop, h, Component, Element, Watch } from '@stencil/core';\n\n@Component({\n  tag: 'mtf-slots',\n  styleUrl: 'mtf-slots.scss',\n  shadow: true,\n})\nexport class MotifSlots {\n  @Element() el: HTMLMtfSlotsElement;\n\n  @Prop() rightContent: string;\n\n  @Watch('rightContent')\n  rightContentChanged(newValue: string) {\n    const rightSlot = this.el.shadowRoot.querySelector('.right-slot');\n    if (rightSlot) {\n      rightSlot.innerHTML = newValue;\n    }\n  }\n\n  componentDidLoad() {\n    this.rightContentChanged(this.rightContent);\n  }\n\n  render() {\n    return (\n      \u003cdiv class=\"container\"\u003e\n        \u003cdiv class=\"flexrow\"\u003e\n          \u003cdiv class=\"border-left\"\u003e\n            \u003cslot name=\"left\"\u003eLeft for Defect\u003c/slot\u003e\n          \u003c/div\u003e\n          \u003cslot name=\"middle\"\u003e\u003c/slot\u003e\n          \u003cdiv class=\"right-slot\"\u003e\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n\n\n이 그림에서 왼쪽과 가운데의 슬롯에 대한 두 가지 다른 접근 방식과 오른쪽 슬롯에 대한 프롭스가 표시되어 있습니다. 슬롯은 복잡성이 없지만 프롭스의 경우 코드를 많이 추가해야 합니다. 클래스, componentDidLoad 함수, 쿼리 선택기와 함께 @watch 함수 및 innerHTML을 사용하여 이러한 프롭스를 추가해야 하기 때문에 하나의 작업에 대해 많은 코드가 필요합니다.\n\nReact에서 웹 구성 요소와 상호 작용할 때 슬롯을 활용하는 데 완전한 호환성을 보장합니다. 간단히 해당 위치에 웹 구성 요소의 슬롯 이름을 가진 'slot' 속성을 할당하면 됩니다. 이는 React의 'children' 프롭과 유사하게 작동하여 useRef의 사용 및 그 안에서 상태를 표현하는 것을 허용합니다. 이렇게 함으로써 '슬롯'과 동일한 기능을 구현할 수 있습니다. 프롭스를 사용할 경우 HTML이 해당 위치에 '베이크'됩니다. 그러나 슬롯의 경우 — React 구성 요소에서 소비되는 경우이든 아니든 — DOM의 다른 부분을 참조하는 링크가 해당 섹션에 포함됩니다.\n\n# 결론\n\n\n\n대부분의 경우 HTML을 프롭스를 통해 웹 컴포넌트로 전송하여 작동하지만, 이것은 가장 최적의 방법은 아니며 필요한 모든 기능을 갖추지 못할 수 있습니다. 따라서 React와 100% 호환되는 슬롯을 사용하는 것이 항상 권장됩니다.","ogImage":{"url":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png"},"coverImage":"/assets/img/2024-05-14-WebComponentsslotsandReact_0.png","tag":["Tech"],"readingTime":3},{"title":"NextAuth v5를 사용한 보호된 라우팅 구현하기","description":"","date":"2024-05-14 11:21","slug":"2024-05-14-ImplementingProtectedRoutingwithNextAuthv5","content":"\n\n![이미지](/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png)\n\n이 글에서는 Next.js 애플리케이션에서 NextAuth v5를 사용하여 클라이언트 측 및 서버 측 경로를 보호하는 방법을 알려드릴 거에요.\n\nNextAuth.js는 Next.js 애플리케이션에서 널리 사용되는 인증 라이브러리로, 버전 5가 출시되면서 여러 가지 주목할만한 개선 사항과 변경 사항이 소개되었어요. 이 최신 버전에서 중요한 업데이트 중 하나는 미들웨어 시스템에서 관찰되어요. 미들웨어 API가 향상되어 인증 흐름과 접근 제어에 대해 더 많은 유연성과 제어를 제공하고 있어요.\n\n그럼 시작해봅시다!\n\n\n\n## 단계 1 — 새로운 Next.js 프로젝트를 생성하고 필요한 패키지 설치하기\n\n이 글에서는 Next.js 애플리케이션을 만드는 방법에 대해 자세히 다루지는 않겠지만, nextAuth를 사용하기 위해서는 최신 버전이 필요합니다.\n\n```js\nnpm install --save next-auth\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_1.png\" /\u003e\n\n\n\n## 단계 2— 애플리케이션 내에 nextAuth 제공자 설정하기\n\n이 예제에서는 Google을 인증 제공자로 사용할 것입니다. 이제 Next 앱 내에 \"services\"라는 새 폴더를 만들고 그 안에 auth.ts라는 새 파일을 생성하세요. 파일을 만든 후 아래 코드를 추가하세요.\n\n```js\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\n\nexport const {\n  handlers: { GET, POST },\n  auth\n} = NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID as string,\n      clientSecret: process.env.GOOGLE_SECRET as string\n    })\n  ],\n  pages: {\n    signIn: '/login'\n  }\n});\n```\n\n반드시 .env 파일을 만들어서 google 클라이언트 ID와 clientSecret를 추가해주세요.\n\n\n\n다음으로, Next 앱 내에서 api 디렉토리(페이지 디렉토리 내부) 안에 새 폴더를 만들어주세요. 폴더의 이름은 `auth`로 지어주세요. 그 폴더 안에 `...nextAuth`(대소문자 구분 필수)라는 폴더를 만들고, 그 안에 `route.ts` 파일을 생성해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_2.png\" /\u003e\n\n해당 파일을 생성한 후, 아래 코드를 추가해주세요.\n\n```js\nexport { GET, POST } from '../../../../services/auth';\nexport const runtime = 'edge';\n```\n\n\n\n이제 제공자 설정이 모두 끝났으니, useContext API와 유사하게 전체 앱에 인증 상태를 제공하는 다른 컴포넌트를 사용하여 모든 구성 요소와 라우트를 감싸는 작업을 진행해 보겠습니다.\nrootlayout.ts 파일 내에서 세션 제공자(SessionProvider)를 사용하여 컴포넌트를 감싸세요.\n\n```js\nimport './globals.css';\n\nimport Navbar from '../components/nav-bar/navbar';\nimport { SessionProvider } from 'next-auth/react';\n\nexport default function RootLayout({\n  children\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\" className=\"h-full\"\u003e\n      \u003cbody className=\"h-full flex flex-col\"\u003e\n          \u003cSessionProvider\u003e\n            \u003cNavbar /\u003e\n            \u003cmain className=\"flex-1\"\u003e{children}\u003c/main\u003e\n          \u003c/SessionProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n## 단계 3 — 모든 signIn 및 signOut 함수 구현\n\n그런 다음 nextAuth를 사용하여 모든 signIn 및 signOut 함수를 구현해야 합니다. 그러나 이 문서에서는 해당 함수를 구현하지 않겠습니다. 필요한 라우트를 보호하는 방법만 안내해 드리겠습니다.\n\n\n\n## 단계 4 — 클라이언트 측과 서버 측 라우트를 보호하는 미들웨어 생성\n\n이 접근 방식에서는 클라이언트 측과 서버 측 라우트를 보호하기 위해 미들웨어를 사용할 것입니다. 먼저 src 폴더 안에 middleware.ts라는 새 파일을 만들고 다음 코드를 추가해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_3.png\" /\u003e\n\n```js\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nconst protectedRoutes = [\n  '/dashboard',\n  '/profile',\n];\nconst unprotectedRoutes = ['/', '/login'];\n\nimport { auth } from './services/auth';\n\nexport default async function middleware(request: NextRequest) {\n  const session = await auth();\n\n  const isProtectedRoute = protectedRoutes.some((prefix) =\u003e\n    request.nextUrl.pathname.startsWith(prefix)\n  );\n\n  if (!session \u0026\u0026 isProtectedRoute) {\n    const absoluteURL = new URL('/', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n  if (session \u0026\u0026 unprotectedRoutes.includes(request.nextUrl.pathname)) {\n    const absoluteURL = new URL('/dashboard', request.nextUrl.origin);\n    return NextResponse.redirect(absoluteURL.toString());\n  }\n}\n```\n\n\n\n해당 코드에는 \"protectedRoutes\"와 \"unprotectedRoutes\"라우트가 몇 개 있습니다. 다음 js 애플리케이션에서 라우트를 보호하려면 이 배열에서 원하는 라우트를 추가하거나 제거할 수 있습니다.\n\n전체 문서를 보려면 방문해주세요.\n세미콜론 — 기술 블로그 (semicolon-blog.vercel.app)\n\n우리는 클라이언트 측과 서버 측 라우트를 성공적으로 보호했다고 생각합니다. 감사합니다! 👏👏👏","ogImage":{"url":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingProtectedRoutingwithNextAuthv5_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS-in-JS를 활용한 Styled Components로 스타일링하는 최종 가이드","description":"","date":"2024-05-14 11:19","slug":"2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents","content":"\n\n![이미지](/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png)\n\n안녕하세요! 제 페이지로 돌아오신 여러분을 환영합니다. 당신이 경험 많은 팔로워이든 처음 방문자이든, 여기 오신 것을 매우 기쁘게 생각합니다.\n\n오늘의 주제는 귀여울 정도로 흥미로울 것입니다. 그 녀석이야; CSS-in-JS를 사용한 스타일링의 궁극적인 안내서인 Styled Components입니다. 우리는 JavaScript 내에서 CSS를 직접 작성하는 세계로 들어가보겠습니다. 이 방법이 React 애플리케이션의 스타일링에 제공하는 힘, 효율성 및 유연성을 탐구할 것입니다.\n\n# 소개:\n\n\n\n오케이, 웹 애플리케이션을 스타일링하는 것은 음식을 준비하는 것과 같다고 상상해 봅시다. 당신은 재료가 가득한 식료품실(스타일)과 따를 레시피(HTML 구조)가 있습니다. 그러나 전통적인 냄비나 프라이팬 대신에 당신은 마법의 지팡이 🪄 를 휘두르면서 쉽게 쿨리너리 창작물을 창조할 수 있는 마법을 갖고 있습니다. 이것이 CSS-in-JS의 마법입니다, 특히 Styled Components의 힘을 빌릴 때에는요.\n\n이 포괄적인 기사에서, 저는 Styled Components 설정과 활용, 시각적 및 실용적 예제 탐구, 이 강력한 스타일링 방법론의 모든 잠재력을 발휘하는 방법을 안내하겠습니다.\n\n# CSS-in-JS가 필요한 이유? 캐스케이딩 스타일시트 괴물을 물리치다\n\nCSS-in-JS는 스타일을 구성하는 더 \"원자적\"인 방법을 제공하여 그 스타일을 사용하는 컴포넌트로만 제한하는 방법을 제공합니다. 반면에, 전통적인 CSS는 스타일에 대한 세심한 통제를 제공하지만, 스타일링에 대한 도전과 같은 문제점도 도입합니다.\n\n\n\n- 특이성 전쟁: 이름 충돌과 스타일 재정의로 CSS 코드가 꼬인 문제가 발생할 수 있어 유지 보수가 악몢화될 수 있습니다.\n- 전역 범위 오염: 전역 스타일은 의도하지 않은 부분에 영향을 미칠 수 있습니다.\n- 컴포넌트 재사용성 문제: 스타일링 컴포넌트가 코드베이스 전체에 흩어져 있어 번거로울 수 있습니다.\n\nCSS-in-JS는 스타일을 JavaScript 컴포넌트 내에 직접 통합함으로써 이러한 문제에 대응합니다. 동적 스타일링과 향상된 유지 보수성 및 재사용성과 같은 여러 가지 이점을 제공합니다.\n\n참고: Styled-Components는 React/JavaScript 라이브러리를 위해 설계된 라이브러리이기 때문에 HTML 및 CSS에서 직접 사용할 수 없습니다. React 컴포넌트 구조와 JSX 구문과 같은 기능을 활용하여 CSS 스타일을 React 컴포넌트 내에 통합하도록 특별히 설계되었습니다.\n\n여기에서 CSS-in-JS의 이점을 확인해보세요.\n\n\n\n# 스타일드 컴포넌트 시작하기\n\n## 설치 및 설정\n\n스타일드 컴포넌트를 시작하기 위해 준비해야 할 사항은 다음과 같습니다:\n\n- React 설정: 기본적인 React 프로젝트가 설정되어 있어야 합니다. Create React App과 같은 도구를 사용하여 이 프로세스를 간편화할 수 있습니다 (https://create-react-app.dev/).\n- Styled Components 설치: npm 또는 yarn을 사용하여 Styled Components 라이브러리를 설치하세요.\n\n\n\n```js\nnpm install styled-components\n```\n\n설치가 완료되면 Styled Components를 프로젝트에 import하여 즉시 사용할 수 있습니다.\n\n# 심층 분석, 기본 구문 및 사용\n\n## - 기본 사용법 및 구문\n\n\n\nStyled Components는 스타일을 정의하기 위해 태그된 템플릿 리터럴을 활용합니다. 아래는 styled button 컴포넌트를 만드는 기본적인 예제입니다:\n\n```js\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: #007bff;\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return \u003cButton\u003eClick me\u003c/Button\u003e;\n};\n```\n\n## 스타일링된 컴포넌트 만들기\n\nStyled Components를 사용하면 HTML 요소나 재사용 가능한 컴포넌트 기본 요소의 사용자 정의된 스타일 버전을 생성할 수 있습니다. 예를 들어;\n\n\n\n```js\nconst StyledDiv = styled.div`\n  background-color: #f0f0f0;\n  padding: 1rem;\n`;\n\n// 사용 방법\nconst MyComponent = () =\u003e {\n  return \u003cStyledDiv\u003eHello, world!\u003c/StyledDiv\u003e;\n};\n```\n\nStyled Components를 사용하면 가능성이 무한합니다. 전통적인 CSS로 스타일을 지정하는 것과 동일하게 모든 컴포넌트나 HTML 요소에 스타일을 적용할 수 있지만, 스코피잉 및 재사용성의 추가 혜택이 있습니다.\n\n## - Styled Components in Action: Building Common UI Elements (with Illustrations)\n\n핵심 개념을 이해했으니, Styled Components를 사용하여 다양한 UI 요소를 스타일링하는 방법을 살펴보겠습니다.\n\n\n\n\n- 버튼: 이전 예제에서 볼 수 있듯이, 스타일된 컴포넌트는 사용자 정의 스타일을 가진 재사용 가능한 버튼을 만드는 데 뛰어납니다.\n- 카드: 스타일된 컴포넌트를 사용하여 시각적으로 매력적이고 정보를 제공하는 카드를 만들어보세요.\n- 아바타 이미지: 카드용 스타일링된 아바타 이미지를 만들어보세요.\n\n```js\nimport styled from \"styled-components\";\n\nconst Card = styled.div`\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 4px rgba(0.1, 0.1, 0.1, 0.2);\n  padding: 20px;\n  margin: 10px;\n`;\nconst CardTitle = styled.h2`\n  font-size: 1.2em;\n  margin-bottom: 10px;\n  align-item: center;\n  text-align: center;\n`;\nconst CardContent = styled.p`\n  margin-bottom: 10px;\n`;\nconst Button = styled.button`\n  padding: 10px 20px;\n  background-color: #007bff;\n  color: #fff;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\nconst AvatarImage = styled.img`\n  margin: 0px 20px 0px 0px;\n  height: 40px;\n  border-radius: 50%;\n  display: block;\n  margin: auto;\n`;\n\nfunction ProductCard() {\n  return (\n     \u003cCard\u003e\n    \u003cCardTitle\u003eJames Washington\u003c/CardTitle\u003e\n    \u003cAvatarImage\n      src=\"https://miro.medium.com/v2/resize:fit:740/1*ooOH6jo8I0ns0J-BE0SAow.jpeg\"\n      alt={name}\n    /\u003e\n    \u003cCardContent\u003e\n      Imagine styling your web applications like preparing a dish. You have a\n      pantry full of ingredients (styles) and a recipe (HTML structure) to\n      follow. But instead of traditional pots and pans, you wield a magic wand\n      🪄 that lets you conjure up your culinary creations effortlessly. This\n      is the magic of CSS-in-JS, particularly when wielded with the power of\n      Styled Components.\n    \u003c/CardContent\u003e\n    \u003cButton\u003eTry Now\u003c/Button\u003e\n  \u003c/Card\u003e\n  );\n}\n```\n\n실시간 미리보기🛠️:\n\n이 샌드박스 환경에서 실시간 미리보기를 살펴보세요. 자유롭게 실험하고 플레이그라운드 내에서 여러 가지 스타일링 기술을 적용해보세요.\n\n\n\n엔지니어로서 프로젝트를 진행하며 복잡성이 증가함에 따라 개발을 간소화하기 위해 재사용 가능한 구성 요소의 가치를 깨달았어요. 그래서 Styled Components를 주요 스타일링 방법으로 사용하여 만든 컴포넌트 라이브러리인 Vinyl Component Blocks를 만들었죠. Vinyl Component Blocks는 UI 컴포넌트 생성과 관련된 반복 작업을 줄이고 효율성을 촉진하며 일관된 개발 경험을 제공하는 것을 목표로 합니다. GitHub에서 라이브러리를 살펴보고, Styled Components를 사용하여 복잡한 UI 아키텍처를 어떻게 활용하는지 확인해보세요.\n\n더 많은 정보는 아래 링크를 확인해보세요:\n\n- Styled Components 공식 문서: 라이브러리의 기능과 API 참조를 더 깊이 파고들어보세요: https://styled-components.com/docs\n- Styled Components를 활용한 고급 기술: 테마 지정, 중첩, 전역 스타일 등과 같은 고급 기술을 탐구해보세요: https://styled-components.com/docs/api\n- Vinyl Component Blocks: 컴포넌트 라이브러리 및 기능을 탐색하고, Styled Components를 활용하여 복잡한 UI 아키텍처를 어떻게 구현하는지 확인하세요: https://github.com/Vinyl-Davyl/vinyl-component-blocks\n\n## - Styled Components를 활용한 스타일링 전략\n\n\n\n스타일드 컴포넌트의 힘을 발휘해보세요: 동적이고 재사용 가능한 UI를 위한 전략들. 스타일드 컴포넌트는 스타일링 능력을 향상시키는 다양한 기능을 제공합니다:\n\n- 전역 스타일 대 컴포넌트별 스타일\n\n스타일드 컴포넌트는 전역 스타일과 컴포넌트별 스타일을 정의하는 데 유연성을 제공합니다. 전역 스타일은 createGlobalStyle API를 사용하여 정의할 수 있습니다.\n\n```js\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyles = createGlobalStyle`\n  body {\n    font-family: 'Roboto', sans-serif;\n    background-color: #f8f8f8;\n  }\n`;\n\nconst MyApp = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cGlobalStyles /\u003e\n      \u003cMyComponent /\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n\n\n컴포넌트별로 스타일이 캡슐화되어 있습니다. 이전 예제와 같이요.\n\n이 방식을 통해 응용 프로그램 전체에서 일관된 디자인 시스템을 유지할 수 있으면서도 컴포넌트별 스타일의 모듈성을 누릴 수 있어요.\n\n2. Props로 테마 적용 및 사용자 정의\n\nStyled Components의 주요 기능 중 하나는 컴포넌트 props에 따라 스타일을 사용자 정의할 수 있는 기능이에요. 이는 동적 스타일 및 테마를 가진 재사용 가능한 컴포넌트를 생성하는 데 특히 유용합니다.\n\n\n\n```js\nconst Button = styled.button`\n  background-color: ${(props) =\u003e (props.primary ? '#007bff' : '#6c757d')};\n  color: #fff;\n  padding: 0.5rem 1rem;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`;\n\n// 사용 예시\nconst MyComponent = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cButton primary\u003e주 버튼\u003c/Button\u003e\n      \u003cButton\u003e보조 버튼\u003c/Button\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n프롭스(props)를 활용하여 중복 코드를 방지하면서도 다양한 사용 사례에 맞게 유연한 컴포넌트를 생성할 수 있습니다.\n\n- 중첩(Nesting): 보다 복잡한 레이아웃 및 조직을 위해 서로 중첩된 스타일을 활용할 수 있습니다.\n- Styled System 통합: 통합 스타일링 접근을 위해 Styled Components와 같은 인기 있는 스타일링 시스템(Bootstrap 또는 Material-UI)을 활용할 수 있습니다.\n\n# Styled Components 이상: 대안 탐색하기\n\n\n\n\nStyled Components는 React 애플리케이션을 스타일링하는 인기 있는 선택지입니다. 그러나 탐색할 가치가 있는 여러 가지 대안이 있습니다. Emotion, JSS, CSS Modules는 각각 고유한 특징과 사용 사례를 가진 실용적인 옵션입니다.\n\n## Emotion\n\nEmotion은 다른 CSS-in-JS 라이브러리로, Styled Components와 유사한 기능을 제공하지만 자체 CSS 프롭 지원 및 자동 벤더 프리픽싱과 같은 추가 기능을 제공합니다.\n\n## JSS\n\n\n\nJSS (JSS는 인라인 스타일 및 테마에 매우 좋습니다)은 인라인 스타일과 테마에 중점을 둔 CSS-in-JS 라이브러리입니다. 이는 컴포넌트 속성에 따라 스타일을 동적으로 생성하기 위한 강력한 API를 제공하여 매우 사용자 정의 가능한 UI 컴포넌트를 구축하기에 이상적입니다.\n\n## CSS 모듈\n\nCSS 모듈은 React 애플리케이션에서 스타일링하는 다른 접근 방식으로, 웹팩과 같은 번들러에서 내장된 CSS 모듈 지원을 활용합니다. CSS 모듘을 사용하면 전통적인 CSS 파일을 작성하고 컴포넌트로 가져와 로컬 범위 및 자동 클래스명 생성과 같은 이점을 누릴 수 있습니다.\n\n저는 모든 JavaScript 스타일링 라이브러리에 대해 전문가는 아니에요. 제 경험이 주로 스타일드 컴포넌트와 관련이 있습니다. 이것은 내가 한 대부분의 작업에서 인기가 많은 훌륭한 도구입니다.\n\n\n\n# 결론 및 다음 단계\n\n축하해요!🎊 이제 Styled Components를 사용한 CSS-in-JS 스타일링의 기술을 정복했어요. 이 지식을 바탕으로 멋진 UI 구성 요소를 만들어 웹 애플리케이션을 더 생동감 있게 만들 수 있을 거예요.\n\n하지만 스타일링을 정복하는 것은 계속되는 여정이에요. 새로운 기술을 탐험하고 다양한 라이브러리를 실험하며 프론트엔드 개발의 최신 트렌드를 계속해서 따라가 주세요. 헌신과 실력 향상으로 함께 하겠습니다. 더 많은 업데이트와 이런 콘텐츠를 기대해 주세요!\n\n# 그림 및 참고자료\n\n\n\n- 스타일된 컴포넌트 공식 문서\n- Emotion 공식 문서\n- JSS 공식 문서\n- CSS Modules 공식 문서\n- 멋진 리액트 컴포넌트를 위한 GitHub 저장소\n- Vinyl-Component-Blocks, 스타일된 컴포넌트 기반 UI 라이브러리\n\nStyled Components 💅🏻를 사용하여 CSS-in-JS의 스타일링 세계를 정복하기 준비가 되었습니다. 다음에 또 만나요, Merci!","ogImage":{"url":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png"},"coverImage":"/assets/img/2024-05-14-TheUltimateGuidetoStylingwithCSS-in-JSUsingStyledComponents_0.png","tag":["Tech"],"readingTime":8}],"page":"34","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"34"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>