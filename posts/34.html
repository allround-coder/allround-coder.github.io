<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/34" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/34" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" href="/post/2024-06-20-Why3in123falseinJavaScriptTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC 인터뷰 질문 시리즈 1" href="/post/2024-06-20-LWCInterviewQuestionsSeries1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC 인터뷰 질문 시리즈 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC 인터뷰 질문 시리즈 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC 인터뷰 질문 시리즈 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" href="/post/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 현재 시간을 가져오는 방법" href="/post/2024-06-20-HowtoGetCurrentTimeinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 현재 시간을 가져오는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 현재 시간을 가져오는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 현재 시간을 가져오는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" href="/post/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" href="/post/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 DSA 모험 - 3장 - 배열-01" href="/post/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 DSA 모험 - 3장 - 배열-01" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 DSA 모험 - 3장 - 배열-01" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 DSA 모험 - 3장 - 배열-01</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" href="/post/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" href="/post/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactjs 심층 분석 1  createElement와 jsx-runtime" href="/post/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactjs 심층 분석 1  createElement와 jsx-runtime" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactjs 심층 분석 1  createElement와 jsx-runtime" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reactjs 심층 분석 1  createElement와 jsx-runtime</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link posts_-active__YVJEi" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요","description":"","date":"2024-06-20 07:31","slug":"2024-06-20-Why3in123falseinJavaScriptTypeScript","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png\" /\u003e\n\n안녕 친구들, 이번 주에는 몇 가지 재미있는 것들을 배웠어요. 오늘은 그 중 일부를 공유하고 싶습니다. 주제는 in 연산자에 대한 것이에요. 간단한 예제로 시작해보죠:\n\n```js\nconsole.log(3 in [1, 2, 3]) // false\n```\n\n의아하지 않나요? 3이 [1, 2, 3] 안에 없어요. 왜 그럴까요??? 그 이유를 알아보기 위해 in 연산자를 살펴보도록 해요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것에 대해 아시지 못하는 분들을 위해, in 연산자는 지정된 속성이 지정된 객체나 해당 프로토타입 체인에 있는지 확인하여 true를 반환합니다. (MDN에 따르면). 이해가 되지 않는다면, 아래에서 in 연산이 하는 일을 살펴봅시다:\n\n- 속성이 객체 자체에 있는지 여부를 확인합니다.\n- 속성이 객체에 있으면 true를 반환하고, 그렇지 않으면 이 객체의 부모 클래스를 확인합니다.\n- 단계 2는 이 JavaScript 및 TypeScript (Object 클래스)의 모든 객체의 부모 클래스를 확인할 때까지 반복됩니다. 속성이 존재하면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n이 개념을 설명하기 위해 빠른 예시를 살펴봅시다:\n\n```js\nclass Person {\n    constructor(public name: string, public age: number) { }\n}\n\nlet person: Person = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log('name' in person); // true\nconsole.log('age' in person); // true\nconsole.log('job' in person); // false\n\n// 결과\n// true\n// true\n// false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nperson 객체에는 이름과 나이가 있습니다. 따라서 `name` 및 `age`가 age에 대해 true를 반환하며, age도 마찬가지입니다. 그러나 person은 직업을 가지고 있지 않으므로 `job`은 person에서 false를 반환합니다.\n\n이제 Person 클래스를 상속한 Developer 클래스를 만들고 새로운 개발자 객체를 생성합니다:\n\n```js\nclass Developer extends Person {\n    constructor(name: string, age: number, public job: string) {\n        super(name, age);\n    }\n}\n\nlet developer: Developer = new Developer('John Doe', 24, 'Software Developer');\n\nconsole.log('name' in developer); // true\nconsole.log('age' in developer); // true\nconsole.log('job' in developer); // true\n\n// 출력\n// true\n// true\n// true\n```\n\n이제 developer 객체에는 job 속성이 있지만 명시적으로 이름과 나이가 없습니다. 이러한 속성은 Person 클래스에서 상속되었습니다. 그러나 `name` in developer는 여전히 true를 반환합니다. 왜냐하면 name은 Person 클래스의 속성이며 Developer 클래스가 이를 상속하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알았어요. 그건 운영 동작을 위한 것이에요. 간단하죠? 그런데 왜 '운영 동작은 위험하다'고 말할까요? 제 의견으로는 두 가지 주요 이유가 있어요.\n\n1. 배열에서 요소를 확인하기 위해 in을 사용\n\n먼저, 사람들은 일반적으로 배열에 요소가 포함되어 있는지 확인할 때 in을 사용해요. 이렇게 하면 위험한데요, 왜냐하면 이 경우 in이 기대한 대로 작동하지 않기 때문이에요. 간단한 예제를 통해 살펴볼게요:\n\n```js\nlet arr = [1, 2, 3];\n\nconsole.log(1 in arr); // true\nconsole.log(2 in arr); // true\nconsole.log(3 in arr); // false\n\n// 출력 결과\n// true\n// true\n// false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 1과 2와 잘 동작하는 것을 볼 수 있지만, 3에서는 그렇지 않다는 것을 알 수 있어요. 왜 그럴까요? JavaScript와 TypeScript에서 배열은 인덱스가 키이고 값이 값인 객체입니다. 다른 버전에서 이 예시를 다시 작성해보도록 할게요.\n\n```js\nlet arr = {\n    0: 1, 1: 2, 2: 3\n}\n\nconsole.log(1 in arr); // true\nconsole.log(2 in arr); // true\nconsole.log(3 in arr); // false\n\n// 출력\n// true\n// true\n// false\n```\n\n이 예시는 이전과 완전히 동일하지만, 배열 형태로 나타내지 않고 객체 형태로 다시 작성했어요. 이렇게 하면 arr[0] = 1, arr[1] = 2, arr[2] = 3를 볼 수 있죠. 이전과 마찬가지로, 이제 모든 것이 명확해졌어요. 사실 키 3은 arr에 없기 때문에 3 in arr은 false를 반환합니다. 이것이 글 맨 위의 질문에 대한 답이에요. 이 동작은 매우 위험하며 배열에 요소가 포함되어 있는지 확인할 때 in을 사용해서는 안 돼요. 대신 includes를 사용해야 해요.\n\n```js\nlet arr = [1, 2, 3];\n\nconsole.log(arr.includes(1)); // true\nconsole.log(arr.includes(2)); // true\nconsole.log(arr.includes(3)); // true\n\n// 출력\n// true\n// true\n// true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 정의되지 않은 속성과 함께 사용하기\n\n자바스크립트에서는, 객체가 특정 속성을 가지고 있지 않은 경우, 예를 들어 person이 직업을 가지고 있지 않으면 person.job = undefined가 됩니다 (이 동작은 자바스크립트에만 해당되며, TypeScript에서 person 객체의 job에 접근하려고 시도하면 오류가 발생합니다). 그래서 사람들(나 포함)은 일반적으로 undefined 값을 가진 속성은 객체에 해당 속성이 존재하지 않음을 의미한다고 생각합니다. 그러나 이 직관은 전혀 사실이 아닙니다. 예를 살펴보겠습니다:\n\n```js\ninterface IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\nperson.name = undefined;\n\nconsole.log(person.name, 'name' in person); // undefined true\n```\n\n명시적으로 person의 name을 undefined로 설정해도, `person`에 `name`이 여전히 true를 반환하는 것을 볼 수 있습니다. JavaScript와 TypeScript는 이 경우를 “name은 여전히 person 안에 있으며, 그저 정의되지 않았지만 여전히 존재한다”로 처리합니다. 이 경우는 디버깅하기 매우 어렵습니다. 왜냐하면 어디서 실수를 저질렀는지조차 알 수 없기 때문입니다. 그래서 우리가 해야 할 일은 무엇일까요? person.name = undefined로 설정하는 대신, 객체의 속성을 완전히 제거할 수 있는 삭제(delete) 작업이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\ndelete person.name;\n\nconsole.log(person.name, 'name' in person); // undefined false\n```\n\n\n아하, 그러니까 이제 없어졌네요. 속성을 삭제하지 않고 값을 undefined로 설정하고 싶다면 in 대신 !== 연산자를 사용할 수 있습니다:\n\n```js\n인터페이스 IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\nperson.name = undefined;\n\nconsole.log(person.name, person.name !== undefined); // undefined false\n```\n\n빠르게 다시 한 번 요약해보면\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본문 전체를 읽을 시간이 없는 분들을 위해 복습해 드릴게요:\n\n- 객체와 함께 작업할 때에만 in 연산자를 사용해야 하며, 배열과 함께 사용해서는 안 됩니다.\n- 속성을 undefined로 설정하는 대신에 완전히 제거하려면 delete 연산자를 사용하세요.\n- 만약 속성을 undefined로 설정하길 원한다면 in 연산자 대신 !== 연산자를 사용하세요.\n\n이번 글은 여기까지입니다. 읽어주셔서 감사합니다. 다음 흥미로운 글에서 만나요 :)","ogImage":{"url":"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"LWC 인터뷰 질문 시리즈 1","description":"","date":"2024-06-20 07:28","slug":"2024-06-20-LWCInterviewQuestionsSeries1","content":"\n\n## (2024)\n\n![LWC Interview Questions](/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png)\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 개발 분야에서 동적이고 반응적인 사용자 인터페이스를 개발하는 강력한 도구입니다. 성능을 향상시키고 개발 프로세스를 더 효율적으로 만들어 주는 능력 덕분에 LWC는 현대 Salesforce 플랫폼 앱의 기본 구성 요소가 되었습니다. 자격 있는 LWC 개발자를 찾는 것은 이 기술을 완벽히 활용할 수 있는 유능한 팀을 구성하기 위해 매우 중요합니다.\n\n우리는 이러한 노력을 돕기 위해 개념적 이해와 현실 시나리오에 대한 LWC 인터뷰 문제를 철저하게 수집했습니다. 이러한 질문의 목적은 후보자의 문제 해결 능력, LWC 개발에 대한 전문 지식, 그리고 Salesforce 개발의 최선의 실천 방법의 적용을 평가하는 데 도움을 주는 것입니다. 이제 시작해 보겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주의 !\n\nLWC 인터뷰 준비는 압도적인 과제일 수 있습니다. LWC 개념, 최고의 실천 방법 및 실무 경험을 철저히 이해해야 합니다. 여러분의 여정을 돕기 위해 LWC 관련 다양한 주제를 다루는 면접 질문 목록을 엄선했습니다.\n\n이 블로그 시리즈에서는 LWC 개발자들이 면접에서 자주 묻는 개념 및 시나리오 기반의 LWC 인터뷰 질문을 모두 다루려고 노력했습니다.\n\n## 인터뷰 시리즈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번쨰 인터뷰 시리즈를 시작해볼까요? 라이트닝 웹 컴포넌트에 대해 얘기해보려고 해요. 인터뷰어와 인터뷰 대상자 사이에서 진행될거에요.\n\n# 개념적인 질문들:\n\n## 인터뷰어: 라이트닝 웹 컴포넌트(Lightning Web Components, LWC)란 무엇이고, Aura 컴포넌트와 어떻게 다른가요?\n\n## 인터뷔 대상자:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번개 웹 컴포넌트(LWC)는 Salesforce 플랫폼에서 번개 컴포넌트를 구축하기 위한 새로운 프로그래밍 모델입니다. 이는 ECMAScript 6와 같은 현대 웹 표준을 활용하여 Aura 컴포넌트와 비교하여 더 나은 성능을 제공합니다. Aura와 달리 LWC는 더 가벼운 프레임워크를 사용하며 웹 개발에 더 간단하고 표준 기반의 접근을 촉진합니다.\n\n## 주목하세요!\n\n여기서 인터뷰어는 위의 질문을 다른 방식으로도 할 수 있습니다.\n\n## 인터뷰어: LWC와 Aura 컴포넌트의 주요 차이점은 무엇인가요? 아키텍처, 성능 및 개발 경험을 비교해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터뷰ee: LWC와 헤일로 컴포넌트 사이의 차이점:\n\n## 1. 구조:\n\n헤일로 컴포넌트:\n\n- 클라이언트 측 JavaScript 프레임워크 및 서버 측 Apex 컨트롤러를 활용하는 Aura 프레임워크에 기반함.\n- 마크업, JavaScript 컨트롤러 및 스타일이 하나의 파일 내에 캡슐화된 컴포넌트 기반 구조를 따름.\n- 이벤트, 속성 및 메소드를 포함한 컴포넌트 간 통신을 위해 Aura 컴포넌트 모델을 활용함.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLWC (라이트닝 웹 컴포넌트):\n\n- W3C가 지원하는 최신 웹 컴포넌트 표준을 기반으로 한 웹 표준에 맞춰 개발되었습니다.\n- 형태, 자바스크립트 및 스타일을 위한 별도의 파일을 사용하여 모듈화 아키텍처를 따르며, 캡슐화를 위해 셰도우 DOM을 준수합니다.\n- 컴포넌트 개발을 위해 ECMAScript 모듈과 표준 DOM API를 활용하여, 다른 프레임워크와의 상호 운용성을 제공합니다.\n\n## 2. 성능:\n\nAura 컴포넌트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능은 프레임워크의 오버헤드와 통신을 위한 Aura 컴포넌트 모델의 사용으로 영향을 받을 수 있습니다.\n- 데이터 검색 및 업데이트를 위한 서버 라운드트립은 지연을 유발하고 전체적인 성능에 영향을 줄 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- Shadow DOM 및 가상 DOM과 같은 최적화 기술을 사용하여 원시 웹 표준을 사용하므로 성능이 향상됩니다.\n- 클라이언트 측 렌더링 및 최소한의 서버 라운드트립은 더 빠른 로딩 시간과 더 나은 응답성에 기여합니다.\n\n## 3. 개발 경험:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오로라 컴포넌트:\n\n- 개발 경험은 오로라 프레임워크의 학습 곡선과 복잡성에 의해 특징 지어질 수 있습니다.\n- 컨트롤러, 헬퍼 및 이벤트와 같은 오로라 특정 개념에 대한 친숙함이 필요합니다.\n- 오로라 개발에 대한 도구 지원은 다른 현대 웹 개발 프레임워크와 비교하여 더 제한적일 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- ECMAScript 6+ 기능과 표준 웹 API를 지원하여 더 간소화되고 현대적인 개발 경험을 제공합니다.\n- Salesforce CLI 및 VS Code 확장 프로그램과 같은 현대적인 도구를 활용하여 효율적인 개발 워크플로우를 위해 지원합니다.\n- 오로라와 비교하여 더 깨끗하고 직관적인 구문을 제공하여 코드의 가독성과 유지 보수성이 향상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개요: 전반적으로 LWC는 Aura 구성 요소에서 중요한 발전을 나타내며, Salesforce 플랫폼에서 구성 요소를 구축하기 위해 더 현대적이고 성능 중심적인 접근 방식을 제공합니다. Aura 구성 요소는 계속 지원되지만, LWC는 Salesforce 개발의 미래 방향으로 위치하고 있으며, 개발자들에게 더 효율적이고 확장 가능한 프레임워크를 제공하여 Lightning UI를 구축합니다.\n\n## 인터뷰어: LWC(Lightning Web Components)에서 데이터 바인딩 개념을 설명해 주세요. 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 통신을 어떻게 용이하게 하는가요?\n\n## 인터뷉이:\n\n라이트닝 웹 컴포넌트(LWC)에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 연결을 설정하는 메커니즘입니다. 이를 통해 두 요소 간에 데이터의 동기화를 가능케 하여 JavaScript 컨트롤러에서 수행한 변경 사항이 HTML 템플릿에 반영되고 그 반대도 성립합니다. 데이터 바인딩은 컴포넌트 내에서 무결한 통신과 상호작용을 용이하게 하며, 데이터나 사용자 입력의 변경에 따라 동적으로 업데이트하고 콘텐츠를 렌더링할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데이터 바인딩이 어떻게 통신을 용이하게 하는지:\n\n## 1. 속성 바인딩:\n\n- 속성 바인딩은 JavaScript 속성을 HTML 템플릿의 요소나 속성에 바인딩하는 데 사용됩니다.\n- 중괄호 구문 `''`을 사용하여 HTML 템플릿 내에서 JavaScript 속성을 참조합니다.\n- JavaScript 컨트롤러에서 속성 값이 변경되면 HTML 템플릿의 해당 요소나 속성이 자동으로 새 값으로 업데이트됩니다.\n- 마찬가지로 HTML 템플릿의 값이 변경되면 JavaScript 컨트롤러에 다시 반영됩니다.\n\n## 2. 이벤트 바인딩:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 바인딩을 사용하면 DOM 이벤트를 JavaScript 컨트롤러의 메서드나 함수에 바인딩할 수 있습니다.\n- HTML 템플릿에서 이벤트 바인딩을 지정하려면 이벤트 이름 뒤에 `on-` 접두사를 사용합니다.\n- 지정된 DOM 이벤트가 트리거될 때, JavaScript 컨트롤러의 연관된 메서드나 함수가 호출됩니다.\n- 이를 통해 컴포넌트의 로직 내에서 사용자 상호작용이나 브라우저 이벤트를 처리할 수 있습니다.\n\n아래는 LWC에서 데이터 바인딩을 보여주는 예시입니다:\n\nHTML 템플릿 (dataBinding.html):\n\n```js\n\u003c!--dataBinding.html--\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"Input Component Example\" variant=\"narrow\"\u003e\n    \u003cdiv class=\"slds-p-around_medium\"\u003e\n      \u003cp\u003e{message}\u003c/p\u003e\n      \u003cdiv class=\"slds-m-top_medium\"\u003e\n        \u003clightning-input type=\"text\" onchange={handleChange}\u003e\u003c/lightning-input\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript Controller (dataBinding.js):\n\n```js\n//dataBinding.js\nimport { LightningElement,track } from 'lwc';\n \nexport default class DataBinding extends LightningElement {\n  @track message = 'Initial message';\n \n  handleChange(event) {\n      this.message = event.target.value;\n  }\n}\n```\n\n## 이 예제에서:\n\n- HTML 템플릿에서 `'message'` 구문은 속성 바인딩을 나타내며, JavaScript 컨트롤러의 `message` 속성이 ``p`` 요소의 내용에 바인딩됩니다.\n- 입력 필드의 값이 변경될 때 (`onchange` 이벤트), JavaScript 컨트롤러의 `handleChange` 메서드가 호출되어 `message` 속성이 업데이트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로, ``p`` 요소의 내용이 `message` 속성의 새 값으로 자동으로 업데이트됩니다.\n\n## 결과:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*erCBAckytrHhVEgu.gif\" /\u003e\n\nLWC에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간에 원활한 통신을 용이하게 합니다. 이를 통해 컴포넌트의 UI 내에서 동적 업데이트와 상호 작용이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인터뷰어: 쉐도우 DOM이란 무엇이며, LWC가 어떻게 활용하는가?\n\n## 인터뷔이:\n\n쉐도우 DOM(쉐도우 문서 객체 모델)은 웹 컴포넌트의 기본 기능으로, 스타일, 마크업 및 동작을 문서의 나머지 부분과 분리된 범위 내에 캡슐화하는 것을 허용합니다. 이 캡슐화는 스타일 및 스크립트가 누출되지 않고 페이지의 다른 부분과 충돌하지 않도록 방지하여 더 나은 모듈성과 재사용성을 제공합니다.\n\n라이트닝 웹 컴포넌츠(LWC)에서는 쉐도우 DOM이 컴포넌트의 마크업과 스타일을 주변 문서와 격리시키는 데 활용됩니다. 이는 컴포넌트 내에서 정의한 스타일이 해당 컴포넌트의 쉐도우 DOM 내 요소에만 적용되도록 함으로써 페이지의 다른 컴포넌트나 요소와의 의도치 않은 스타일 충돌을 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시:\n\n간단한 LWC 컴포넌트인 helloWorld를 고려해 보겠습니다. 이 컴포넌트는 인사 메시지를 표시합니다:\n\n```javascript\n\u003c!-- helloWorld.html --\u003e\n\u003ctemplate\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003e{greeting}\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c/template\u003e\n```\n\n```javascript\n// helloWorld.js\nimport { LightningElement } from 'lwc';\n\nexport default class HelloWorld extends LightningElement {\n    greeting = 'Hello, World!';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는:\n\n- `helloWorld` 컴포넌트는 `greeting` 속성의 값을 표시하는 `h1` 제목이 있는 `div` 컨테이너로 구성됩니다.\n- `greeting` 속성은 JavaScript 파일에 정의되어 \"Hello, World!\" 값으로 초기화됩니다.\n\n## 결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`helloWorld` 컴포넌트가 렌더링되면 라이트닝 웹 컴포넌트 컨텍스트에서 자체 Shadow DOM을 생성합니다. 브라우저에 나타나는 결과물은 다음과 같습니다:\n\n```js\n\u003c!----shadow-root (open)----\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eHello, World!\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c!----/shadow-root----\u003e\r\n```\n\n``div class=”container”``와 ``h1`` 요소는 `helloWorld` 컴포넌트의 Shadow DOM 경계 내에 캡슐화됩니다. 이러한 요소에 적용된 스타일은 컴포넌트 내의 요소에만 영향을 미치므로 격리되어 의도치 않은 스타일 충돌을 방지합니다.\n\n요약하자면, LWC의 Shadow DOM은 컴포넌트 마크업, 스타일링, 동작을 캡슐화하는 메커니즘을 제공하여 향상된 모듈성, 재사용성, 그리고 컴포넌트 기능의 더 나은 캡슐화를 도모합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: LWC의 맥락에서 명령형과 선언형 프로그래밍을 구별하십시오.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)의 맥락에서 명령형과 선언형 프로그래밍은 컴포넌트를 구축하고 상호 작용하는 두 가지 다른 방식을 나타냅니다.\n\n## 명령형 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명령형 프로그래밍은 작업이 어떻게 수행되어야 하는지를 명시적으로 정의하는 상세한 지시 사항을 지정하는 것을 포함합니다. LWC의 맥락에서 명령형 프로그래밍은 일반적으로 DOM을 직접 조작하거나 외부 리소스와 상호 작용하기 위해 명령형 API 호출을 하는 것을 포함합니다.\n\nLWC에서의 명령형 프로그래밍 예시:\n\n```js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n \nexport default class ImperativeExample extends LightningElement {\n    recordId;\n    error;\n \n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터 처리\n        } else if (error) {\n            // 오류 처리\n        }\n    }\n \n    handleClick() {\n        // 레코드 데이터를 로드하기 위한 명령형 호출\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n## 선언적 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반면에 선언적 프로그래밍은 어떻게 해야 하는지 자세히 설명하지 않고 달성해야 할 목표를 지정하는 것을 포함합니다. LWC에서 선언적 프로그래밍은 주로 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능 및 기능을 활용하는 것을 포함합니다.\n\nLWC에서 선언적 프로그래밍의 예시:\n\n```js\n\u003c!--declarativeExample.html--\u003e\n\u003ctemplate\u003e\n    \u003clightning-card title=\"Declarative Example\"\u003e\n        \u003cdiv if:true={isDataLoaded}\u003e\n            \u003c!-- 데이터에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003e{accountName}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv if:true={error}\u003e\n            \u003c!-- 오류에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003eError: {error}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003clightning-button label=\"Load Data\" onclick={handleClick}\u003e\u003c/lightning-button\u003e\n    \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n//declarativeExample.js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n\nexport default class DeclarativeExample extends LightningElement {\n    recordId = '001XXXXXXXXXXXXXXX';\n    error;\n    accountName;\n    isDataLoaded = false;\n\n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터를 선언적으로 처리\n            this.accountName = data.fields.Name.value;\n            this.isDataLoaded = true;\n        } else if (error) {\n            // 오류를 선언적으로 처리\n            this.error = error.body.message;\n        }\n    }\n\n    handleClick() {\n        // 레코드 데이터 로드를 선언적으로 트리거\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 예시입니다:\n\n- `accountName`과 `isDataLoaded`는 컴포넌트 속성으로 초기화됩니다.\n- recordId는 JavaScript 클래스의 속성 `recordId`에 직접 할당됩니다. 이로써 `handleClick()` 내에서 `this.recordId = ‘001XXXXXXXXXXXXXXX’;`를 호출할 필요가 없어집니다.\n- 컴포넌트가 로드될 때, 와이어 어댑터를 사용하여 자동으로 계정 레코드의 이름을 불러옵니다.\n- 버튼 클릭 이벤트가 레코드 데이터 로드를 트리거하지만, 정적 recordId를 사용하기 때문에 시각적으로 변화는 없습니다.\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차이점:\n\nLWC에서 명령형과 선언적 프로그래밍의 주요 차이점은 구성 요소 동작이 어떻게 정의되고 구현되는지에 있습니다:\n\n## 1. 명령형 프로그래밍:\n\n- 작업을 수행하는 방법에 명확한 지시사항을 지정하는 것을 포함합니다.\n- 주로 DOM을 직접 조작하거나 명령형 API 호출을 하는 것을 포함합니다.\n- 더 많은 제어와 유연성을 제공하지만 길고 가독성이 떨어지는 코드로 이어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 선언형 프로그래밍:\n\n- 어떻게 해야 하는지를 명시하지 않고 무엇을 달성해야 하는지를 정의하는 것을 포함합니다.\n- 종종 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능을 활용하는 것을 포함합니다.\n- 구성 요소 동작을 정의하는 더 간결하고 표현력이 있는 방식을 제공하여 더 깨끗하고 유지보수가 쉬운 코드를 만들어줍니다.\n\nLWC 개발에서 명령형 및 선언형 프로그래밍 패러다임은 각각의 장소를 가지고 있으며, 개발자는 종종 구성 요소의 특정 요구사항과 복잡성에 가장 적합한 방법을 선택합니다.\n\n## 인터뷰어: LWC는 구성 요소 간 통신을 어떻게 용이하게 해주나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\nLWC는 구성 요소 통신을 위한 여러 메커니즘을 제공합니다. 속성 전달, 이벤트 처리 및 pub-sub 패턴을 포함합니다. 구성 요소는 속성과 속성을 통해 데이터를 교환하거나 이벤트를 발행하고 처리하거나 라이트닝 메시지 서비스나 플랫폼 이벤트를 사용하여 사용자 정의 이벤트에 가입함으로써 데이터를 교환할 수 있습니다.\n\n## 주의!\n\n여기서 인터뷰관은 위의 질문들을 다른 방식으로도 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: 라이트닝 웹 컴포넌트 간 통신하는 다양한 방법은 무엇인가요? 컴포넌트 이벤트, 공개 속성, 그리고 메소드의 사용법에 대해 비교하고 대조해보세요.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서는 컴포넌트 간 통신을 위한 여러 방법이 있으며, 각각의 사용 사례와 장단점을 갖고 있습니다. 주요 방법으로는 컴포넌트 이벤트, 공개 속성, 그리고 메소드가 포함됩니다. 이러한 접근 방식을 비교하고 대조해보겠습니다:\n\n## 1. 컴포넌트 이벤트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목적: 컴포넌트 이벤트는 컴포넌트 계층 구조에서 직접적으로 관려되지 않은 컴포넌트 간의 통신을 가능하게 합니다. 이를 통해 컴포넌트가 서로의 구현 세부 정보를 알 필요 없이 통신할 수 있는 느슨한 결합을 가능하게 합니다.\n\n사용법: 컴포넌트는 `CustomEvent` 생성자나 `dispatchEvent` 메서드를 사용하여 이벤트를 발송합니다. 다른 컴포넌트는 이러한 이벤트를 템플릿 안의 이벤트 핸들러를 통해 처리할 수 있습니다.\n\n예시:\n\n```js\n// 커스텀 이벤트 발송\nthis.dispatchEvent(new CustomEvent('customEventName', { detail: eventData }));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 컴포넌트를 분리함으로써 재사용성이 높아지고 모듈화가 용이해집니다.\n- 계층적 관계와 무관하게 컴포넌트 간의 통신이 가능합니다.\n\n단점:\n\n- 다른 방법에 비해 추가 설정과 오버헤드가 필요합니다.\n- 특히 초보자에게는 구현과 이해가 더 복잡할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 공개 속성:\n\n목적: 공개 속성은 컴포넌트에서 노출되는 속성으로, 다른 컴포넌트가 설정하거나 액세스할 수 있습니다. 부모-자식 간 통신을 가능하게 해 부모 컴포넌트가 데이터나 구성을 자식 컴포넌트에 전달할 수 있게 합니다.\n\n사용법: 공개 속성은 자식 컴포넌트에서 `@api` 데코레이터로 표시됩니다. 부모 컴포넌트는 자식 컴포넌트를 인스턴스화할 때 이러한 속성의 값을 설정합니다.\n\n예제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```html\n// 자식 컴포넌트\nimport { LightningElement, api } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    @api message;\n}\n```\n\n장점:\n\n- 구현하기 간단하고 직관적입니다.\n- 부모 및 자식 컴포넌트간의 통신을 용이하게합니다.\n\n단점:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 더 복잡한 통신 시나리오에는 사용할 수 없는 부모-자식 관계로 제한됩니다.\n- 컴포넌트 내부를 부모 컴포넌트에 노출하여 긴밀한 결합을 유발할 수 있습니다.\n\n## 3. 메서드:\n\n목적: 메서드를 사용하면 다른 컴포넌트에서 호출할 수 있는 기능을 노출시킬 수 있습니다. 부모-자식 및 자식-부모 간 통신을 가능하게 하여 컴포넌트가 상호작용하고 협업할 수 있습니다.\n\n사용법: 메서드는 컴포넌트의 JavaScript 클래스에서 정의되며 다른 컴포넌트에서 메서드 호출을 통해 호출될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\n// 하위 컴포넌트\nimport { LightningElement } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    handleClick() {\n        // 클릭 로직 처리\n    }\n}\n```\n\n장점:\n\n- 컴포넌트가 서로 기능을 호출하여 상호작용하고 협업하는 방법을 제공합니다.\n- 부모에서 자식으로, 그리고 자식에서 부모로 통신을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점:\n\n- 상호 참조를 가진 구성 요소에 제한되어 더 자유롭게 결합된 시나리오에는 사용이 제한될 수 있습니다.\n- 과도하게 사용되거나 잘못 사용될 경우 강력한 결합을 초래할 수 있습니다.\n\n요약하면, 구성 요소 이벤트, 공용 속성 및 메서드는 모두 라이트닝 웹 컴포넌트 간의 통신을 촉진하는 데 유용한 도구입니다. 어떤 방법을 사용할지 선택하는 것은 통신 시나리오의 특정 요구 사항, 관련된 구성 요소 간의 관계 및 원하는 캡슐화 및 결합 수준에 따라 달라집니다.\n\n## 인터뷰어: LWC에서 라이프사이클 훅의 개념을 설명해주세요. 사용 가능한 여러 라이프사이클 훅은 무엇이며, 구성 요소 라이프사이클 중에 언제 호출되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서의 라이프사이클 훅은 컴포넌트의 라이프사이클 중 특정 시점에 자동으로 호출되는 메서드입니다. 이러한 훅을 사용하면 초기화, 렌더링 및 소멸과 같은 컴포넌트의 라이프사이클의 다양한 단계에서 사용자 정의 로직을 실행할 수 있습니다. 라이프사이클 훅을 활용하여 데이터 초기화, 외부 리소스 가져오기 및 컴포넌트가 소멸될 때 리소스 정리와 같은 작업을 수행할 수 있습니다.\n\nLWC의 다양한 라이프사이클 훅:\n\n1. constructor():\n   생성자 함수는 생성자 메서드로서 객체 인스턴스가 생성될 때 호출되는 훅입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트가 생성될 때 호출됩니다.\n- 컴포넌트 속성 및 상태를 초기화하는 데 사용됩니다.\n\n예시:\n\n```js\nconstructor() {\n    super();\n    // 초기화 로직\n}\n```\n\n2. connectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에 구성 요소가 삽입될 때 호출됩니다.\n- DOM에 액세스가 필요한 설정 작업을 수행하는 데 사용됩니다.\n\n예:\n```js\nconnectedCallback() {\n    // 설정 작업\n}\n```\n\n3. renderedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소 템플릿 렌더링 후에 호출됩니다.\n- 렌더링된 DOM에 따라 동작을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nrenderedCallback() {\n    // DOM 조작\n}\n```\n\n4. disconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에서 구성 요소가 제거될 때 호출됩니다.\n- 리소스 정리 또는 정리 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\ndisconnectedCallback() {\n    // 정리 작업\n}\n```\n\n5. render():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트 템플릿을 렌더링하기 위해 호출됩니다.\n- 컴포넌트 UI의 구조와 내용을 정의하는 데 사용됩니다.\n\n예시:\n\n```js\nrender() {\n    return html`\u003cdiv\u003eHello, World!\u003c/div\u003e`;\n}\n```\n\n6. reconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소가 제거된 후 DOM에 다시 삽입될 때 호출됩니다.\n- 상태를 재설정하거나 설정 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nreconnectedCallback() {\n    // 초기화 작업\n}\n```\n\n라이프사이클 훅 호출:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성자(Constructor): 컴포넌트가 생성될 때 호출됩니다.\n- 연결된 콜백(Connected Callback): 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 렌더링된 콜백(Rendered Callback): 컴포넌트의 템플릿이 렌더링된 후 호출됩니다.\n- 연결 해제된 콜백(Disconnected Callback): 컴포넌트가 DOM에서 제거될 때 호출됩니다.\n- 렌더(Render): 컴포넌트가 템플릿을 렌더링해야 할 때 호출됩니다.\n- 다시 연결된 콜백(Reconnected Callback): 컴포넌트가 제거된 후 다시 DOM에 삽입될 때 호출됩니다.\n\nLWC(Lightning Web Components)에서 제공되는 라이프사이클 훅과 그 호출 순서를 이해함으로써, 개발자들은 컴포넌트 초기화, 렌더링 및 정리 작업을 효과적으로 관리하여 컴포넌트의 라이프사이클 동안 최적의 성능과 동작을 확보할 수 있습니다.\n\n더 궁금한 점이 있다면 아래 링크를 방문해주세요:\n\n희망하건대, 이번 Lightning Web Components (LWC) 인터뷰 시리즈가 LWC 개념에 관한 질문들을 명확히 이해하고 인터뷰에 성공하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png"},"coverImage":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png","tag":["Tech"],"readingTime":15},{"title":"리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요","description":"","date":"2024-06-20 07:26","slug":"2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry","content":"\n\n## 리스코프 치환 원칙을 더 잘 이해할 수 있는 가이드\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png)\n\n# 소개\n\n우리 모두가 알다시피, 소프트웨어 요구 사항은 항상 변합니다. 그리고 우리 개발자로서는 이러한 변경으로 기존 코드가 망가지지 않도록 해야 합니다. 그래서 객체지향 설계에서 SOLID 원칙이 소개되었습니다. 이를 통해 이 프로세스를 더 쉽게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSOLID 원칙은 로버트 C. 마틴 (Bob 삼촌)이 만든 원칙 세트입니다. 이 원칙들은 더 유연하고 유지보수 가능하며 이해하기 쉬운 소프트웨어를 만드는 데 도움을 줍니다. 이 원칙들은 다음과 같습니다:\n\n- 단일 책임 원칙 (Single Responsibility Principle)\n- 개방-폐쇄 원칙 (Open-Closed Principle)\n- 리스코프 치환 원칙 (Liskov Substitution Principle)\n- 인터페이스 분리 원칙 (Interface Segregation Principle)\n- 의존성 역전 원칙 (Dependency Inversion)\n\n이전 글에서 개방-폐쇄 원칙을 소개한 후 이번 글에서는 SOLID 약어에서의 \"L\"인 리스코프 치환 원칙 (LSP)에 대해 논의하겠습니다.\n\n# 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수학적으로 LSP의 정의를 소개하고 자세히 알아보겠습니다. Barbara Liskov는 1988년에 이를 도입했습니다.\n\n기본 객체지향 설계는 상속 또는 구성을 사용하여 객체 간의 관계를 제어합니다. 상속은 IS-A 관계로, 어떤 것이 다른 것의 한 종류이면 발생합니다. 예를 들어, 말은 동물의 일종이라고 할 수 있습니다.\n\n반면에, 구성은 다른 것과의 HAS-A 관계로 이루어집니다. 예를 들어, 주소는 그와 관련된 도시를 가지고 있습니다. LSP는 객체지향 설계에 추가적인 제약을 가져와서 이러한 관계가 충분하지 않으며 IS-SUBSTITUTABLE-FOR로 대체되어야 함을 명시합니다.\n\n하지만 이것이 의미하는 바는 무엇일까요? 간단히 말해, 슈퍼타입은 서브타입으로 대체될 수 있어야 하며 기존 코드를 망가뜨리지 않고 대체될 수 있어야 합니다. 다시 말해, 슈퍼타입은 서브타입과 동일하게 동작해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 어떻게 우리가 슈퍼타입을 서브타입으로 교체해도 기존 코드에 부작용이 없는지 보장할 수 있을까요?\n\n# LSP은 OCP를 확장한다\n\n5가지 SOLID 원칙이 어떤 방식으로 연관돼 있는지 고려해 보세요. 하나의 원칙을 따르는 것이 다른 원칙을 올바르게 따르는 것을 보장하지 않는다는 점을 명심하세요.\n\n우리가 보게 되겠지만, LSP는 Open-Closed 원칙을 확장하며, OCP의 규칙을 따르는 것만으로는 코드가 확장을 허용하고 수정을 닫는지 보장할 수 없습니다. 하지만 코드는 부작용을 피하기 위해 리스코프 치환 원칙에도 준수해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 이 점을 더 잘 이해하는 데 도움이 되는 예시입니다:\n\n![예시 이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_1.png)\n\n보시다시피, 이 예시는 OCP를 완벽하게 따릅니다. 새로운 직원 역할을 추가하고 싶다면, 새로운 클래스를 추가하면 되며, 해당 클래스는 IEmployee 계약에 준수하는 새로운 역할 기능을 포함하면 됩니다.\n\n좋아 보이네요. 그러나 한 가지 질문이 있습니다. 게스트 역할을 어떻게 구현하겠습니까? 네, 게스트 역할은 listPosts를 수행할 수 있지만, 게스트 직원에 대한 인증이 없으므로 로그인 기능을 어떻게 처리할지 궁금합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 텍스트를 번역해 드리겠습니다.\n\n당신이나 빈 기능이 없이 빈칸으로 남겨 둘 수 있거나 로그인 메소드에서 지원되지 않는 예외를 throw할 수 있다고 생각해 볼 수 있어요. 네, 이런 해결책들은 LSP를 고려하지 않는다면 직관적일 수 있어요.\n\n다시 말해, OCP를 완벽하게 준수했다면 문제를 발생시키는 것이 LSP를 어기는 것이 무엇인지에 대해 물어볼 수 있습니다. 이 질문은 암묵적으로 옳은 점을 지적합니다: 일부 원칙이 다른 것보다 중요하다는 것을 의미합니다. 그러나 어떤 원칙이 중요하지 않다고 해서 무시해서는 안 됩니다.\n\n우리가 이미 알고 있듯이, LSP는 상위 유형과 하위 유형을 교체하더라도 기존 클라이언트 코드에 영향을 미치지 않는 것입니다. 이 점을 염두에 두고 다시 당신의 해결책들을 살펴보죠:\n\n- 기능이 없이 빈칸으로 남겨 둘 경우: 이제 클라이언트 코드는 인증된 사용자 토큰을 반환하는 로그인 함수를 기대합니다. 아무것도 반환하지 않는 Guest.login을 사용하면 어떻게 될까요? 기존 코드가 망가질 거예요, 맞죠?\n- 지원되지 않는 예외를 throw하는 경우: 다시 말해서, 기존 코드는 Guest.login으로부터 이 새로운 예외를 처리하지 않습니다. 결과적으로 Guest.login을 사용하면 기존 코드가 망가질 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의왕 교체하신 것에 깜짝 놀랐네요! 요 디자인은 OCP를 완벽하게 따르고 있어요. 그러나 LSP를 위반하고 있군요.\n\n# LSP 규칙\n\n![Liskov Substitution Principle](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_2.png)\n\n아쉽게도 이 원칙을 코드에 강제로 적용하는 쉬운 방법은 없어요. 그러나 코드에서 이 원칙을 올바르게 적용하려면 두 가지 유형의 규칙, 즉 서명과 동작을 따라야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바와 같은 컴파일된 언어를 사용하여 서명 규칙을 강제할 수는 있지만 행동 규칙을 강제할 수는 없습니다. 대신 특정 동작을 강제하기 위해 검사를 구현해야 합니다.\n\n## 먼저, 서명 규칙을 소개해 보겠습니다.\n\n1. 메서드 인수의 반변성: 이것은 보다 구체적인 유형에서 보다 일반적인 유형으로의 변환입니다. 다시 말해, 오버라이드된 서브 유형 메서드 인수는 수퍼 유형이나 더 넓은 유형과 동일해야 합니다.\n\n클라이언트 코드가 SuperType에서 문자열 인수만 예상한다면, 해당 SuperType을 문자열 또는 숫자 인수 (더 넓은)를 허용하는 SubType으로 대체하면 클라이언트 코드에는 차이점이 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 반환 유형의 공변성: 보다 일반적인 유형에서 보다 구체적인 유형으로 변환됩니다. 다시 말해, 오버라이드된 서브유형 메서드의 반환 유형은 수퍼유형이나 더 좁은 유형과 같아야 합니다.\n\n클라이언트 코드는 이미 슈퍼유형에서 오는 문자열이나 숫자 응답을 처리했습니다. 따라서 만약 슈퍼유형을 문자열 응답만 반환하는 서브유형으로 대체한다면, 클라이언트 코드가 손상되지 않을 것입니다.\n\n3. 예외: 서브유형 메서드는 슈퍼유형이나 더 좁은 예외를 던져야 합니다. 모든 컴파일된 언어가이 규칙을 강제할 수는 없습니다. Java와 같이 이를 강제할 수 있는 언어와 TypeScript와 같이 강제할 수 없는 언어가 있습니다.\n\n이전 규칙과 마찬가지로, 클라이언트 코드가 슈퍼유형에 더 많은 예외를 처리하도록 의존한다면, 이 슈퍼유형을 더 적은 예외를 처리하는 서브유형으로 대체한다 해도 클라이언트 코드에는 차이가 없을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그 다음, 행동 규칙을 소개할게요\n\n1. 클래스 불변성 (속성 규칙): 서브타입 메서드는 슈퍼타입의 클래스 불변성을 유지하거나 강화해야 합니다.\n\n서브타입은 같은 슈퍼타입의 불변성을 유지하거나 강화해야 합니다. 생각해보세요, 만약 서브타입이 같은 슈퍼타입의 불변성을 유지하지 않는다면, 슈퍼타입 대신 사용될 수 없으며 슈퍼타입에서 특정 동작을 기대하는 클라이언트 코드가 망가질 수 있습니다.\n\n2. 이력 제약 (속성 규칙): 서브타입 메서드는 슈퍼타입이 허용하지 않는 상태 변경을 허용해서는 안 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 SubType이 상속받은 제약을 무시한다면, 이는 이러한 제약에 의존하는 클라이언트 코드를 손상시킬 수 있습니다. 따라서 SubType은 SuperType으로 대체될 수 없습니다.\n\n2. 사전조건 (메서드 규칙): 서브타입 메서드는 오버라이드된 수퍼타입 메서드의 사전조건을 보존하거나 약화해야 합니다. 여기서 조건을 약화한다면 그 제약을 완화합니다.\n\n이전 예제에서, SuperType 조건 hour ` 0 \u0026\u0026 hour ` 12가 적용된 시간 입력을 제공하는 클라이언트 코드는 SubType에서 시간 ` 0 \u0026\u0026 시간 ` 23의 더 넓은 범위를 적용받습니다. 다시 말해, 부작용 없이 SubType이 SuperType을 대체할 수 있습니다.\n\n3. 사후조건 (메서드 규칙): 서브타입 메서드는 오버라이드된 수퍼타입 메서드의 사후조건을 보존하거나 강화해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제처럼 SuperType으로부터 반환된 값의 최댓값이 50이라고 클라이언트 코드가 기대한다면, 이를 SubType으로 변경하여 30의 최댓값을 반환하는 값으로 대체하면 유효해질 것입니다.\n\n# 나처럼 혼동스럽지 마세요\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_3.png)\n\n처음에는 Liskov 치환 원칙이 상속에 관한 모든 것이라고 생각할 수 있지만, 그렇지 않습니다. 이 원칙을 배우는 동안 많이 혼란스러웠기 때문에 이 점을 강조하기 위해 별도의 섹션을 할애하는 것을 선호했습니다. LSP는 상속을 사용할 때만 적용할 수 있다고 생각했었죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스코프 치환 원칙은 상속과는 아무런 관련이 없습니다. LSP는 단순히 서브타이핑에 관한 것입니다. 그럼에도 불구하고, 이 서브타이핑은 상속이나 합성에서 나올 수 있습니다. LSP는 상속과는 관련이 없기 때문에 상속을 사용하든 말든 LSP가 적용되는지 여부는 중요하지 않습니다. StackExchange의 이 해결책을 살펴보세요.\n\n그러므로, LSP와 상속 개념을 엄격하게 연결하지 마세요. 대신, 상속을 사용해야 할 때에 LSP를 염두에 두세요. \"LSP는 OCP를 확장한다\" 섹션 예제를 다시 살펴보세요.\n\n# LSP 위반\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 일반적인 LSP 위반 사례를 소개하고 LSP를 준수하도록 다시 디자인해보겠습니다.\n\n## 1. Type checking\n\n폴리모픽 코드 내부에서 변수의 유형을 확인하는 경우입니다. 아래 예제를 살펴보세요:\n\n코드에서 보듯이 이 루프는 직원 유형에 따라 두 가지 다른 기능을 수행합니다. 그러나 이 구현에서 어떤 문제가 있는 것일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 더 생각해보세요. 여기서 첫 번째 문제는 직원과 작업할 때마다, 특정 기능을 실행하기 위해 이 직원이 '게스트' 유형인지를 확인해야 할 수도 있다는 것입니다. 또 다른 유형인 경우 다른 기능을 실행해야 할 수도 있습니다.\n\n두 번째 문제는 추후 새로운 유형을 추가할 수 있으며, 이러한 새로운 유형을 지원하기 위해 이 확인이 존재하는 모든 곳을 방문해야 할 수 있다는 것입니다. 게다가 이는 개방-폐쇄 원칙을 위반하는 것이기도 합니다.\n\n그렇다면 이 문제를 어떻게 해결할 수 있을까요? 한 가지 해결책은 '말하고, 물어보지 말 것' 원칙 또는 캡슐화를 사용하는 것입니다. 이는 인스턴스에게 해당 유형에 대해 질문하고 조건부로 특정 작업을 실행하는 대신, 그 로직을 유형에 캡슐화하고 작업을 수행하도록 지시하는 것을 의미합니다. 이를 이전 예제에 적용해봅시다:\n\n## 2. Null checking\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 형식 검사와 동일한 동작을 갖습니다. 아래 예제를 확인해보세요. Guest 유형을 확인하는 대신, 이처럼 null 값에 대해 확인하고 있습니다. (employee === null) 이것은 LSP를 위반합니다.\n\n하지만 이 문제를 어떻게 해결할 수 있을까요? 이 문제에 대한 일반적인 해결책 중 하나는 Null Object 디자인 패턴을 사용하는 것입니다. 이 재설계를 살펴보세요:\n\n## 3. 구현되지 않은 예외 던지기\n\n이것은 인터페이스나 기본 클래스의 부분적 구현으로 인해 발생하는 일반적인 문제입니다. \"LSP extends OCP\" 섹션의 예제를 다시 살펴보세요. Guest 하위 유형의 login 메소드에서는 IEmployee 인터페이스 (상위 유형)를 완전히 구현할 수 없기 때문에 Not Implemented Exception을 던져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제의 해결책은 수퍼타입을 완전히 구현하는 것입니다. 이것이 인터페이스인지 기본 클래스인지에 상관없이요.\n\n하지만 때로는 예시처럼 인터페이스를 완전히 구현하는 것이 어려울 수 있다는 점을 주장할 수 있습니다. 맞아요. 그런 경우에는 수퍼타입과 서브타입 간의 관계를 더 신중하게 확인해야 할 것입니다. 서브타입이 이 수퍼타입의 대체 가능성을 충족하지 못할 수도 있으며, 다시 말해 인터페이스 분리 원칙을 위반한 것일 수 있습니다.\n\n# 결론\n\n이 글에서는 리스코프 치환 원칙을 소개했습니다. LSP가 객체 지향 설계에 새로운 제약 조건을 추가한다는 것을 이해했습니다. 이것은 관계만으로는 충분하지 않고 서브타입이 수퍼타입을 대체할 수 있는지 확인해야 한다는 것을 말합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 원칙을 올바르게 적용하기 위해 따라야 하는 규칙을 알고 계셨습니다. 그리고 이러한 규칙은 서명 및 행동 규칙으로 분류할 수 있습니다.\n\n이후에는 이 원칙을 위반하는 몇 가지 일반적인 사례들과 그에 대한 해결책을 소개했습니다.\n\n# 떠나시기 전에\n\n만일 이 글이 유용하다고 느끼셨다면, 아래의 글도 함께 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 단일 책임 원칙을 정말로 이해하고 계신가요?\n- 개방-폐쇄 원칙: 어려운 부분\n- 전략 vs 상태 vs 템플릿 디자인 패턴\n- SQL Server에서의 잠금 기반 격리\n\n지금까지 함께해 주셔서 정말 감사합니다. 이 기사를 읽으시는 데 즐거움이 있기를 바랍니다.\n\n![image](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_5.png)\n\n# 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- C# 개발자를 위한 SOLID 원칙\n- 자바에서의 Liskov 대체 원칙\n- 코드 예제와 함께 설명하는 SOLID 디자인 원칙: Liskov 대체 원칙\n- 사전조건/사후조건 강화/약화에 대한 혼란\n- 이것이 Liskov 대체 원칙 위반인가요?\n\n원문은 https://mayallo.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png"},"coverImage":"/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png","tag":["Tech"],"readingTime":8},{"title":"JavaScript에서 현재 시간을 가져오는 방법","description":"","date":"2024-06-20 07:24","slug":"2024-06-20-HowtoGetCurrentTimeinJavaScript","content":"\n\n`img` 태그를 Markdown 형식으로 변경해주세요.\n\n![How to Get Current Time in JavaScript](/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png)\n\n이미지 출처: How to Get Current Time in JavaScript\n\n이 글은 JavaScript를 사용하여 현재 시간을 얻는 다양한 방법을 안내합니다.\n\n## 1. `Date` 객체 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 현재 시간을 가장 직접적으로 얻는 방법은 `Date` 객체를 사용하는 것입니다. `Date` 객체는 플랫폼에 독립적인 형식으로 시간을 나타냅니다.\n\n```js\n// 새 Date 객체 생성\nlet currentDate = new Date();\n// 현재 시간 가져오기\nlet currentTime = currentDate.toLocaleTimeString();\nconsole.log(\"현재 시간은:\", currentTime);\n```\n\n이 예제에서:\n- 우리는 새로운 `Date` 객체 'currentDate'를 생성합니다. 이 객체는 현재 날짜와 시간으로 초기화됩니다.\n- `toLocaleTimeString()` 메서드를 사용하여 시간 부분을 로캘에 맞게 포맷합니다.\n\n## 2. `Date` 객체 사용 (UTC)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 시각을 UTC 형식으로 가져오려면:\n\n```js\n// 새 Date 객체 생성\nlet currentDateUTC = new Date();\n// 현재 UTC 시간 가져오기\nlet currentUTCTime = currentDateUTC.toUTCString();\nconsole.log(\"현재 UTC 시간은:\", currentUTCTime);\n```\n\n여기서 `toUTCString()`은 날짜를 UTC 형식의 문자열로 변환합니다.\n\n## 3. 시간, 분, 초 표시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 시간, 분, 초를 따로 표시해야 하는 경우:\n\n```js\n// 새 Date 객체 생성\nlet currentTimeDetails = new Date();\n// 시간, 분, 초 가져오기\nlet hours = currentTimeDetails.getHours();\nlet minutes = currentTimeDetails.getMinutes();\nlet seconds = currentTimeDetails.getSeconds();\nconsole.log(`현재 시간: ${hours}:${minutes}:${seconds}`);\n```\n\n## 4. 외부 라이브러리 사용\n\n또는 Moment.js와 같은 외부 라이브러리를 사용하여 더 고급의 날짜 및 시간 조작이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Moment.js 라이브러리 사용\nlet now = moment();\nconsole.log(\"Moment.js를 사용한 현재 시간:\", now.format('YYYY-MM-DD HH:mm:ss'));\n```\n\n프로젝트에 Moment.js를 포함시키면서 사용하세요.\n\n## 결론\n\n본문에서는 JavaScript에서 현재 시간을 얻는 다양한 방법을 탐색했습니다. 네이티브 `Date` 객체를 선택하거나 Moment.js와 같은 라이브러리를 선호하든, JavaScript는 다양한 요구 사항에 맞는 유연한 솔루션을 제공합니다. 이러한 방법을 이해하면 현재 시간 기능을 웹 애플리케이션에 효과적으로 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 요구 사항에 가장 잘 맞는 방법을 선택하는 것을 기억하세요. 단순성, 지역화 및 추가 기능을 고려해 선택하세요. 이러한 예제들을 실험하여 날짜와 시간을 효과적으로 다루는 JavaScript의 능력을 향상시키고 활용해보세요.","ogImage":{"url":"/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoGetCurrentTimeinJavaScript_0.png","tag":["Tech"],"readingTime":2},{"title":"JavaScript 프록시와 리플렉션을 활용한 메타 프로그래밍","description":"","date":"2024-06-20 07:21","slug":"2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection","content":"\n\n개요, 응용 프로그램, 모범 사례 및 제한 사항\n\n![이미지](/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png)\n\n# 소개\n\n제목을 읽은 후에, 메타프로그래밍이 무엇인지 궁금할 수 있습니다. 일반 프로그래밍과 어떻게 다른가요? 주요 개념 및 기술은 무엇일까요? 실제 예시는 어떻게 될까요? 다양한 언어에서는 어떻게 구현되는가요? 장단점은 무엇일까요? 그리고 JavaScript에서는 어떻게 활용될 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 질문이 참 많죠! 그런데 걱정하지 마세요. 제가 이 기사에서 여러분의 궁금증을 해소하고 각 질문에 대답할 거에요. 여기 제가 제안하는 개요입니다:\n\n- 지구 상의 첫 발자국\n  - 메타 프로그래밍이란 무엇인가요?\n  - JavaScript에서의 메타 프로그래밍\n- 프록시와 리플렉트 API 실습\n  - 프록시와 리플렉트를 사용해 프로퍼티 접근 (get) 가로채기\n  - 프록시와 리플렉트를 사용해 프로퍼티 할당 (set) 가로채기\n  - get과 set 대신 임의의 키를 사용할 수 있을까요?\n  - 프록시와 리플렉트의 실용적인 예제\n- 사례 연구와 실제 예시\n  - 반응형 스토어 생성\n  - 유효성 검사 및 정제를 위한 라이브러리 생성\n  - 안전한 API 게이트웨이 구축\n  - 프록시와 리플렉트를 사용하는 실세계 프레임워크 및 라이브러리\n- 모범 사례, 일반적인 오류 및 권고 사항\n  - 모범 사례\n  - 일반적인 오류 및 권고 사항\n- 결론\n\n만약 이 개념을 탐험하는 데 열성적이고 궁금하시다면, 이 여정에 함께 참여하실 것을 초대합니다. 준비가 되셨죠! 함께 이륙합니다! 🚀\n\n## 지구 상의 첫 발자국\n\n### 메타 프로그래밍이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메타 프로그래밍의 간단한 정의를 찾아보려면, 다양한 프로그래밍 언어 예제를 살펴보는 것부터 시작해보겠습니다:\n\n```js\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n```\n\n위의 코드는 C 및 C++과 같은 언어에서 흔히 볼 수 있습니다. 이것은 상수를 정의하고 함수를 생성하며 조건부 컴파일을 수행하는 매크로 전처리기입니다.\n\n#define 지시어는 매크로를 생성하며, 이는 소스 코드 전체에서 재사용할 수 있는 코드의 자리 표시자입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nint main() {\n    int radius = 5;\n    double area = PI * SQUARE(radius); // placeholders\n    printf(\"Area: %f\\n\", area);  // Output: Area: 78.539750\n    return 0;\n}\r\n```\n\n프리프로세서(preprocessor)가 소스 코드에서 매크로를 만나면 매크로를 정의된 내용으로 대체합니다:\n\n```js\r\n// 전처리 전:\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n\nint main() {\n    int radius = 5;\n    double area = PI * SQUARE(radius);\n    printf(\"Area: %f\\n\", area);\n    return 0;\n}\n\n// 전처리 후:\nint main() {\n    int radius = 5;\n    double area = 3.14159 * ((5) * (5));\n    printf(\"Area: %f\\n\", area);\n    return 0;\n}\r\n```\n\n프리프로세서(preprocessor)는 #if, #ifdef, #ifndef, #else, #endif와 같은 지시문을 사용하여 특정 조건에 따라 코드의 일부를 포함하거나 제외할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n#define DEBUG\n\n#ifdef DEBUG\nprintf(\"Debug mode\\n\");\n#endif\r\n```\n\n전처리 후 확장된 코드는 컴파일러에 의해 기계 코드로 컴파일됩니다.\n\n매크로의 힘은 코드 재사용성, 조건부 컴파일, 코드 생성 및 변환에 대한 강력한 도구를 제공하는 능력에 있습니다.\n\n매크로가 메타 프로그래밍의 한 형태라는 것을 알고 계셨나요? 여기 메타 프로그래밍의 초기 정의가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🚩 컴파일러와 메타프로그래밍은 서로 다른 개념임을 명심하는 것이 중요합니다. 두 가지 모두 코드 조작을 포함하지만 목표와 방법이 다릅니다:\n\n- 메타프로그래밍은 코드를 생성하거나 수정하여 작업을 자동화하고 더 높은 수준의 추상화를 생성하는 데 중점을 둡니다.\n- 반면에 컴파일러 이론은 코드를 한 형식에서 다른 형식으로 번역하는 것에 관심이 있으며 일반적으로 고수준 소스 코드를 실행을 위한 기계 코드나 바이트 코드로 변환합니다.\n\nRust는 Macro도 가지고 있습니다:\n\n```rust\nmacro_rules! say_hello {\n    () =\u003e {\n        println!(\"Hello, world!\");\n    };\n}\n\nfn main() {\n    say_hello!(); // 확장 결과: println!(\"Hello, world!\");\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 알다시피, 매크로는 컴파일 중에 다른 코드를 생성하거나 변환하는 코드를 작성할 수 있게 해줍니다.\n\n메타프로그래밍에서 매크로는 사용되는 다양한 도구 및 기술 중 하나에 불과합니다. 메타프로그래밍은 프로그램이 다른 프로그램을 생성, 조작 또는 변환할 수 있는 다양한 방법을 포괄합니다. 매크로 이외의 몇 가지 주요 기술은 다음과 같습니다:\n\n1️⃣ 주석 및 속성 (Java): Java의 주석은 코드에 메타데이터를 추가하는 강력한 방법을 제공하며, 컴파일 시간 또는 런타임에서 처리하여 특정 동작, 구성 또는 제약을 강제적으로 적용할 수 있습니다.\n\n```js\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n// 컴파일 시간 retention을 가진 사용자 정의 주석\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\n@interface MyAnnotation {\n    String value();\n}\n\n// 런타임 retention을 가진 사용자 정의 주석\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface MyRuntimeAnnotation {\n    String value();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2️⃣ 템플릿 메타프로그래밍 (C++): 템플릿 메타프로그래밍은 컴파일러를 활용하여 효율적이고 타입 안전한 코드를 생성하는 강력한 기법으로, 성능 및 유지보수 측면에서 상당한 이점을 제공합니다.\n\n```cpp\n#include \u003ciostream\u003e\n\n// 주 템플릿\ntemplate\u003cint N\u003e\nstruct Factorial {\n    static const int value = N * Factorial\u003cN - 1\u003e::value;\n};\n\n// 기본 케이스를 위한 템플릿 특수화\ntemplate\u003c\u003e\nstruct Factorial\u003c0\u003e {\n    static const int value = 1;\n};\n\nint main() {\n    // 컴파일 시간에 5의 팩토리얼을 계산\n    std::cout \u003c\u003c \"5의 팩토리얼은 \" \u003c\u003c Factorial\u003c5\u003e::value \u003c\u003c \"입니다.\" \u003c\u003c std::endl;\n    return 0;\n}\n```\n\n3️⃣ 리플렉션 (Java): 리플렉션은 코드와 동적으로 상호작용하는 강력한 메커니즘을 제공하여 클래스, 메서드, 필드 등을 검사하거나 메서드를 호출하거나 필드에 접근할 수 있게 합니다.\n\n```java\nimport java.lang.reflect.Method;\n\n// 리플렉션을 사용하여 호출할 간단한 메서드가 있는 클래스 정의\npublic class ReflectExample {\n    public void sayHello(String name) {\n        System.out.println(\"안녕, \" + name + \"!\");\n    }\n\n    public static void main(String[] args) {\n        try {\n            // 클래스의 인스턴스 생성\n            ReflectExample example = new ReflectExample();\n\n            // ReflectExample과 관련된 Class 객체 가져오기\n            Class\u003c?\u003e clazz = example.getClass();\n\n            // sayHello 메서드를 나타내는 Method 객체 가져오기\n            Method method = clazz.getMethod(\"sayHello\", String.class);\n\n            // 예제 인스턴스에서 \"World\" 인수를 사용하여 sayHello 메서드 호출\n            method.invoke(example, \"World\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4️⃣ 동적 평가 (JavaScript):\n\n```js\nconst code = 'console.log(\"안녕, 세상!\");';\neval(code);  // 출력: 안녕, 세상!\n```\n\n⚠️ 조심해주세요, JavaScript에서 eval을 사용하는 것은 권장되지 않습니다.\n\n요약하면, 메타프로그래밍은 프로그램이 다른 프로그램을 데이터로 취급할 수 있는 프로그래밍 패러다임입니다. 이는 일반적으로 다음을 포함합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드 조작: 코드를 동적으로 생성, 변환 또는 검사할 수 있는 능력입니다.\n- 자동화: 코드 조작을 통해 반복적이거나 복잡한 작업을 자동화합니다.\n- 추상화: 코드 내의 중복을 간소화하고 줄이기 위해 높은 수준의 추상화를 만듭니다.\n- 동적 동작: 프로그램의 동작을 다양한 조건이나 입력에 기반하여 런타임 시에 적응시킵니다.\n\n지금까지 익힌 것으로 보아, 자바스크립트에서 eval을 사용하는 것을 넘어서 메타프로그래밍을 어떻게 적용할 수 있는지 궁금해하고 있군요. 함께 알아보도록 해요!\n\n## 자바스크립트에서의 메타프로그래밍\n\n자바스크립트에는 프락시(Proxies), 리플렉트 API, 그리고 데코레이터(Decorators)와 같이 메타프로그래밍에 활용할 수 있는 강력한 도구들이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오, 걱정 마세요! 제가 말한 건 자바스크립트이고, 자바가 아니에요. 😊\n\n각각의 기술은 서로 다른 목적을 가지고 다른 기능을 제공해요:\n\n- Proxy: 동적 동작, 유효성 검사, 로깅 등에 유용한 객체에 대한 다양한 작업을 가로채는 높은 유연성을 제공해요.\n- Reflect: 일반적인 객체 작업을 수행하기 위한 일관된 간편한 API를 제공하며, 대부분 프락시와 함께 사용되어 트랩의 구현을 간소화하기 위해 종종 사용돼요.\n- 데코레이터 (제안됨): 클래스와 메소드를 선언적으로 수정하여 어노테이션을 통해 향상하거나 동작을 변경할 수 있도록 해줘요.\n\n아마 궁금하실 거예요: 자바스크립트 프락시는 메타프로그래밍 개념과 어떻게 관련이 되는 걸까요? 자바스크립트 프락시는 동적 코드 조작, 작업 자동화, 추상화 생성, 그리고 실행 중에 동작을 조정하여 메타프로그래밍 원칙과 일치해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체에 대한 기본 작업을 가로채고 사용자 정의하여, 프록시는 메타프로그래밍의 핵심 목표를 달성하며 코드의 유연성을 향상시키고 중복을 줄이며 복잡성을 관리하는 강력한 방법을 제공합니다.\n\n이런 다소 이론적인 메타프로그래밍의 주요 개념을 소개한 후에, 이제 JavaScript 프록시를 사용한 실용적인 예제로 넘어 가볼까요? 시작해봅시다! 💻\n\n# 실습으로 알아보는 프록시와 Reflect API\n\n## Proxy 및 Reflect를 사용하여 속성 접근(GET) 가로채기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 이전에 보았듯이, JavaScript에서의 프록시는 객체에 대한 기본 작업들을 가로채고 재정의할 수 있도록 해줍니다. 속성에 접근하거나 할당, 열거, 함수 호출 등이 해당됩니다.\n\n프로퍼티 접근을 가로채기 위한 기본적인 방법은 다음과 같습니다:\n\n\nYou can play with the code [here](\u003clink\u003e)\n\n\n✳️ target은 단일 속성 message를 가진 간단한 객체로, \"Hello, World!\"라는 문자열이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✳️ 핸들러(handler)는 get 트랩을 정의하는 객체입니다. get 트랩은 대상 객체의 속성 접근을 가로채는 메서드입니다.\n\n✳️ 프록시(proxy)의 속성에 액세스할 때 get 트랩이 트리거되어 해당 속성이 어떤 것인지 나타내는 메시지가 기록됩니다.\n\n✳️ Reflect.get 메서드는 대상 객체에서 속성 값을 검색하는 기본 동작을 수행하는 데 사용됩니다. Reflect.get은 Reflect API의 일부로, 일관되고 표준화된 방법으로 일반적인 객체 작업을 수행할 수 있는 메서드 세트를 제공합니다.\n\n## 프록시(Proxy)와 Reflect를 사용하여 속성 할당(set)을 가로채는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티 설정을 가로채기 위해 프록시를 생성하는 기본적인 방법을 소개해 드립니다:\n\n여기서 코드를 테스트해볼 수 있어요.\n\n✳️ 핸들러 객체는 set 트랩을 정의합니다. set 트랩은 대상 객체에서 프로퍼티 할당을 가로채는 함수입니다.\n\n✳️ 프록시의 프로퍼티에 값이 할당되면, set 트랩이 작동됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✳️ 설정된 함정 안에서:\n\n- 어떤 속성이 설정되고 어떤 값으로 설정되는지를 나타내는 메시지를 기록합니다.\n- target[prop] = value;은 실제로 값을 대상 객체의 속성에 할당합니다.\n- return true;은 할당이 성공적으로 수행되었음을 나타냅니다. true를 반환하는 것은 작업이 올바르게 처리되었음을 프록시에 신호하는 데 중요합니다.\n\n## get과 set 대신 임의의 키를 사용할 수 있을까요?\n\nJavaScript 프록시의 맥락에서 get과 set 키는 속성 접근 및 설정 작업을 가로채기 위해 Proxy API에서 제공하는 특정 함정입니다. 이러한 키는 사전에 정의되어 있어 임의의 키로 대체할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 우리는 다른 종류의 작업을 가로챌 수 있는 미리 정의된 다른 함정들을 사용할 수도 있습니다. Proxy API에서 사용 가능한 모든 함정 목록은 다음과 같습니다:\n\n![Proxy API](/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_1.png)\n\nhas 함정은 in 연산자를 가로챕니다:\n\ndeleteProperty 함정은 delete 연산자를 가로챕니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`apply` 트랩은 함수 호출을 가로챕니다:\n\n`ownKeys` 트랩은 Object.getOwnPropertyNames와 Object.keys와 같은 작업을 가로챕니다:\n\n여기 하나의 프록시에 여러 트랩이 결합된 예제가 있습니다:\n\n여기서 코드를 실험해 볼 수 있어요. 멋지네요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프록시 API와 리플렉트 API는 서로 보완적입니다. 프록시 API는 다양한 작업을 가로채는 트랩을 제공하여 사용자 정의 동작을 정의할 수 있게 해주고, 리플렉트 API는 이러한 트랩을 반영하는 일련의 메서드를 제공하여 트랩 내에서 기본 동작을 수행하기 쉽게 만듭니다:\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`속성 ${prop} 가져오기`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.get(target, prop, receiver);\n    },\n    set: function(target, prop, value, receiver) {\n        console.log(`속성 ${prop}을(를) ${value}로 설정`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.set(target, prop, value, receiver);\n    },\n    has: function(target, prop) {\n        console.log(`속성 ${prop}이 대상에 있는지 확인`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.has(target, prop);\n    },\n    deleteProperty: function(target, prop) {\n        console.log(`속성 ${prop} 삭제`);\n        // 기본 동작 수행을 위해 Reflect 사용\n        return Reflect.deleteProperty(target, prop);\n    },\n....\n\n```\n\n다시 말해, 리플렉트 API는 프록시를 사용할 때 기본 객체 동작을 복원하는 데 도움이 됩니다. 프록시 트랩 내에서 리플렉트 메서드를 사용하여 사용자 정의 논리를 자바스크립트의 표준 동작과 함께 사용할 수 있으므로 더 예측 가능하고 신뢰할 수 있는 코드를 작성할 수 있습니다.\n\n프록시 트랩 내에서 리플렉트 API를 사용하지 않으면, 가로챈 작업의 기본 동작을 수동으로 처리해야 합니다. 이는 오류를 유발할 수 있으며 항상 리플렉트를 사용하는 것만큼 일관성과 신뢰성을 보장하지는 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 get 케이스에서 발생할 수 있는 것들입니다.\n\n```js\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`속성 ${prop}을(를) 가져오는 중`);\n        return target[prop];  // 속성에 직접 접근\n    }\n};\n\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.name);  // 로깅: 속성 name을(를) 가져오는 중. 결과: Alice\n```\n\n잠재적인 문제: target[prop]에 직접 접근하는 것은 상속된 속성이나 게터(getter)와 같은 모든 경우를 올바르게 처리하지 못할 수 있습니다.\n\n```js\nconst parent = {\n  inheritedProp: \"상속되었어요\"\n};\n\nconst target = {\n  ...parent,\n  ownProp: \"내 소유 속성이에요\",\n};\n\n\nconst handler = {\n  get: function(target, prop, receiver) {\n    console.log(`속성 ${prop}을(를) 가져오는 중`);\n    return target[prop]; // 속성에 직접 접근\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 로깅: 속성 ownProp을(를) 가져오는 중. 결과: 내 소유 속성이에요\nconsole.log(proxy.ownProp); \n\n// 로깅: 속성 inheritedProp을(를) 가져오는 중. 결과: 아무것도 출력되지 않습니다\nconsole.log(proxy.inheritedProp); \n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토타입 체인에서 상속된 속성은 target[prop]에 의해 고려되지 않습니다.\n\n그러나 get 트랩에서 Reflect.get을 사용하면 상속된 속성과 getter가 있는 속성이 올바르게 처리됩니다:\n\n```js\nconst parent = {\n  inheritedProp: \"상속받은 속성입니다.\"\n};\n\nconst target = {\n  ...parent,\n  ownProp: \"자체 속성입니다.\",\n};\n\nconst handler = {\n  get: function(target, prop, receiver) {\n    console.log(`속성 ${prop}을(를) 가져옵니다.`);\n    return Reflect.get(target, prop, receiver);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 콘솔에 출력: 속성 ownProp를 가져옵니다. 결과: 자체 속성입니다.\nconsole.log(proxy.ownProp); \n\n// 콘솔에 출력: 속성 inheritedProp를 가져옵니다. 결과: 상속받은 속성입니다.\nconsole.log(proxy.inheritedProp); \n```\n\n💡Reflect를 사용하면 JavaScript에서 일반적으로 작동하는지 확인하여 내장 동작을 유지하고 이러한 작업을 수동으로 구현할 때 놓치기 쉬운 특수 상황을 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Proxy와 Reflect의 작동 방식을 이해했으니, Proxy를 사용하는 것이 권장되는 실제 예시를 살펴보겠습니다.\n\n## Proxy와 Reflect의 실용적인 예시\n\n✴️ 예시 1: 속성 접근 및 수정 로깅\n\n디버깅 및 객체 상호작용 모니터링을 위해 Proxy와 Reflect를 사용하여 속성 접근 및 수정을 로깅하는 것이 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        console.log(`Getting property ${prop}`);\n        return Reflect.get(target, prop, receiver);\n    },\n    set: function(target, prop, value, receiver) {\n        console.log(`Setting property ${prop} to ${value}`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.name);  // 콘솔: Getting property name. 결과: Alice\nproxy.age = 31;           // 콘솔: Setting property age to 31\nconsole.log(proxy.age);   // 콘솔: Getting property age. 결과: 31\n```\n\n✴️ 예시 2: 유효성 검사\n\n속성 값 설정 전에 유효성 규칙을 강제하기 위해 프록시를 사용:\n\n```js\nconst target = {\n    age: 25\n};\n\nconst handler = {\n    set: function(target, prop, value, receiver) {\n        if (prop === 'age' \u0026\u0026 (typeof value !== 'number' || value \u003c= 0)) {\n            throw new TypeError('나이는 양의 숫자여야 합니다');\n        }\n        console.log(`Setting property ${prop} to ${value}`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.age = 30;  // 콘솔: Setting property age to 30\nconsole.log(proxy.age);  // 결과: 30\n// proxy.age = -5;  // 에러: TypeError: 나이는 양의 숫자여야 합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✴️ 예제 3: 동적 속성 생성\n\nProxy를 사용하여 속성을 동적으로 생성하고 존재하지 않는 속성을 고상하게 처리하는 방법:\n\n```js\nconst target = {};\n\nconst handler = {\n    get: function(target, prop, receiver) {\n        if (!(prop in target)) {\n            target[prop] = `속성 ${prop}이(가) 존재하지 않아 동적으로 생성되었습니다`;\n        }\n        console.log(`${prop} 속성을 가져오는 중`);\n        return Reflect.get(target, prop, receiver);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\n// 로그: name 속성을 가져오는 중. 결과: name 속성이 존재하지 않아 동적으로 생성됨\nconsole.log(proxy.name);  \n\n// 로그: age 속성을 가져오는 중. 결과: age 속성이 존재하지 않아 동적으로 생성됨\nconsole.log(proxy.age);   \n```\n\n✴️ 예제 4: 함수 추적\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프록시를 사용하여 함수 호출을 추적하고 인수를 기록합니다:\n\n```js\nconst targetFunction = function(a, b) {\n    return a + b;\n};\n\nconst handler = {\n    apply: function(target, thisArg, argumentsList) {\n        console.log(`Called with arguments: ${argumentsList}`);\n        return Reflect.apply(target, thisArg, argumentsList);\n    }\n};\n\nconst proxy = new Proxy(targetFunction, handler);\n\nconsole.log(proxy(1, 2));  // Logs: Called with arguments: 1,2. Output: 3\nconsole.log(proxy(5, 10)); // Logs: Called with arguments: 5,10. Output: 15\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst target = {\n    name: 'Alice',\n    age: 30\n};\n\nconst handler = {\n    deleteProperty: function(target, prop) {\n        console.log(`Deleting property ${prop}`);\n        return Reflect.deleteProperty(target, prop);\n    }\n};\n\nconst proxy = new Proxy(target, handler);\n\ndelete proxy.age;  // Logs: Deleting property age\nconsole.log(target.age);  // Output: undefined\n```\n\n💡 Production 모드에서는 console 문을 백엔드 호출로 대체하여 로그를 추적하고 저장합니다.\n\n이 예제의 아름다움은 기존 코드와의 원활한 통합에 있으며, 라이브러리 및 프레임워크 개발에 매우 유용합니다. 함께 살펴보겠습니다!\n\n# 사례 연구 및 실제 예제\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 리액티브 스토어 생성\n\n이 저장소를 사용하는 예제입니다:\n\n```js\n// 사용 예시\nconst store = createStore({ count: 0 });\n\n// 상태 변경 구독\nstore.subscribe(state =\u003e {\n  console.log(\"상태 변경됨:\", state);\n});\n\n// 게터를 통해 속성에 액세스\nconsole.log(store.getState().count); // 출력: 0\n\n// 세터를 통해 상태 업데이트\nstore.getState().count = 10; // 출력: \"상태 변경됨: { count: 10 }\"\n\n// 게터를 통해 속성에 액세스\nconsole.log(store.getState().count); // 출력: 10\n```\n\n여기에서 코드를 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 스토어는 React 기능 컴포넌트에서도 사용할 수 있습니다:\n\n```js\nconst store = createStore({ count: 0 });\n\n// 상태에 기반한 UI를 렌더링하는 함수 컴포넌트\nfunction Counter() {\n  // 스토어의 현재 상태를 보유하는 상태\n  const [state, setState] = useState(store.getState());\n\n  // 컴포넌트가 마운트될 때 상태 변경 사항을 구독하는 효과\n  useEffect(() =\u003e {\n    // 상태 변경 사항을 구독합니다.\n    const unsubscribe = store.subscribe((newState) =\u003e {\n      // 스토어에서 새 상태로 로컬 상태를 업데이트합니다.\n      setState({ ...newState });\n    });\n\n    // 구독을 정리하는 해제 함수를 반환합니다.\n    return () =\u003e {\n      unsubscribe();\n    };\n  }, []);\n\n  // 5초마다 카운트를 증가시키는 효과\n  useEffect(() =\u003e {\n    // 5초마다 카운트를 증가시키는 타이머를 설정합니다.\n    const interval = setInterval(() =\u003e {\n      // 스토어의 상태에서 카운트를 업데이트합니다.\n      store.getState().count += 1;\n    }, 1000);\n\n    // 컴포넌트가 언마운트될 때 인터벌 타이머를 지웁니다.\n    return () =\u003e {\n      clearInterval(interval);\n    };\n  }, []);\n\n  // 로컬 상태에서 카운트를 렌더링합니다.\n  return \u003cdiv\u003eCount: {state.count}\u003c/div\u003e;\n}\n\nexport default Counter;\n```\n\n여기에서 코드를 사용해 볼 수 있습니다.\n\n## 검증 및 살균을 위한 라이브러리 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n입력이 속성에 할당되기 전에 유효성을 검사하기 위해 set 트랩을 사용하여 시스템에 유효하지 않은 데이터가 들어가는 것을 방지합니다:\n\n💡데이터가 예상 형식 및 제약 조건에 부합하는지 확인하여 보안과 일관성을 향상시킵니다.\n\n## 안전한 API 게이트웨이 구축\n\nJavaScript의 Proxy와 Reflect API를 사용하여 안전하고 유연하며 유지보수가 용이한 API 게이트웨이를 만들 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 코드를 사용해 놀 수 있어요. 이 예제는 익스프레스와 라우팅을 떠올리게 합니다.\n\n이제 산업 응용 프로그램으로 넘어가봅시다. 즉, 실제 세계의 프레임워크와 라이브러리에 초점을 맞춘다구요. 💫\n\n## Proxy와 Reflect를 사용한 실제 세계의 프레임워크 및 라이브러리\n\n✳️ Vue 3: Vue 3에서 반응성 시스템은 프록시 주변에 구축되어 있어 상태 변경을 가로채고 관리하는 방식으로 처리되어 반응성을 다루는 능률적이고 성능 좋은 방법을 제공해줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [Vue.js 공식 문서 - 반응성](https://v3.ru.vuejs.org/guide/reactivity.html#how-vue-tracks-these-changes)\n- [Vue.js 공식 문서 - 반응성 기본 개념](https://github.com/vuejs/docs/blob/main/src/guide/essentials/reactivity-fundamentals.md?plain=1#L46)\n- [Vue.js Core GitHub - 컴포넌트 렌더링 유틸리티 코드](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/componentRenderUtils.ts#L81)\n- [Vue.js Core GitHub - 인스턴스 호환성 관련 코드](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/compat/instance.ts#L101)\n- [Vue.js 공식 문서 - 반응성 핵심 API](https://github.com/vuejs/docs/blob/main/src/api/reactivity-core.md?plain=1#L135)\n\n✳️ MobX: 기본적으로 MobX는 배열과 일반 객체를 observable하게 만들기 위해 프록시를 사용합니다:\n\n- [MobX 설정 관련 문서](https://mobx.js.org/configuration.html#proxy-support)\n- [MobX 설치 관련 문서](https://github.com/mobxjs/mobx/blob/main/docs/installation.md?plain=1#L55)\n- [MobX observable 상태 관련 문서](https://github.com/mobxjs/mobx/blob/main/docs/observable-state.md?plain=1#L281)\n\n✳️ Svelte에서는 반응성 시스템이 의존성을 추적하고 상태 변경 시 효율적으로 DOM을 업데이트합니다. 상태 변이를 가로채고 반응하기 위해 프록시 객체를 사용하여 이를 구현합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/proxy.js\n- https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/reactivity/props.js#L83\n\n이들 실제 예제는 프록시와 Reflect API가 현대 자바스크립트 개발에 가져다 주는 중요한 능력과 다양성을 강조합니다.\n\n실제 예제와 실제 적용을 통해 프록시를 살펴봤으니, 이제는 그것들을 구현하는 데 있어서 좋은 방법과 피할 수 있는 일반적인 함정들을 고려하고 완벽한 이해를 위해 권장하는 것이 중요합니다. 🌟\n\n# 최선의 방법, 흔한 오류, 그리고 권장사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 최상의 방법\n\n🔵 프록시 트랩 내에서 반복되는 기본 동작을 유지하려면 Reflect API를 사용하세요:\n\n```js\nconst handler = {\n    get(target, prop, receiver) {\n        console.log(`속성 ${prop}을 가져옵니다`);\n        return Reflect.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n        console.log(`속성 ${prop}을 ${value}로 설정합니다`);\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\n```\n\n🔵 프록시를 상태 관리, 로깅, 유효성 검사 또는 반응형 프로그래밍과 같은 시나리오에 적용하세요. 프록시는 오버헤드를 도입할 수 있으므로 혜택이 명확한 곳에서만 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🔵 데이터가 할당되기 전에 데이터를 유효성 검사하기 위해 set 트랩을 사용하세요:\n\n```js\nconst handler = {\n    set(target, prop, value, receiver) {\n        if (prop === 'age' \u0026\u0026 (typeof value !== 'number' || value \u003c 0)) {\n            throw new TypeError('나이는 양수여야 합니다.');\n        }\n        return Reflect.set(target, prop, value, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\nproxy.age = 30;  // 잘 작동합니다\n// proxy.age = -1;  // 오류 발생\n```\n\n🔵 디버깅 목적으로 작업을 기록하기 위해 프록시를 사용하되, 프로덕션 환경에서는 이러한 로깅을 비활성화하거나 제거하거나 백엔드 API를 사용하세요.\n\n🔵 무한 재귀를 발생시킬 수 있는 자기 참조 루프를 피하기 위해 프록시 핸들러를 설계하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst handler = {\n    get(target, prop, receiver) {\n        if (prop === 'self') return receiver;\n        return Reflect.get(target, prop, receiver);\n    }\n};\nconst proxy = new Proxy({}, handler);\n```\n\n이제 피해야 할 실수에 대해 이야기해 봅시다. 🚫\n\n## 흔한 오류와 권장 사항\n\n🔴 오류: 프록시는 성능이 중요한 부분에서 성능 오버헤드를 일으킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 권장: 성능 영향을 측정하고 프록시를 신중하게 사용하세요. 성능이 중요할 때는 대안을 고려해보세요.\n\n🔴 오류: 프록시는 행동이 추상화되고 가로채기 때문에 디버깅을 복잡하게 만들 수 있습니다.\n\n✅ 권장: 프록시 트랩 내에서 명확하고 간결한 로깅을 사용하고 프록시 동작을 이해하기 위해 철저한 테스트를 수행하세요.\n\n🔴 오류: 프록시는 민감한 데이터를 노출하거나 미인가 수정을 허용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 권장 사항: 프록시 트랩 내에서 철저한 유효성 검사와 액세스 제어 구현하기\n\n🔴 오류: 모든 JavaScript 환경이 프록시를 완전히 지원하지는 않습니다, 특히 오래된 브라우저들에서.\n\n✅ 권장 사항: 대상 환경이 프록시를 지원하거나 대체 메커니즘을 제공하는지 확인하기\n\nJavaScript에서 프록시와 Reflect API를 사용함으로써 코드는 상당히 유연하고 강력해지며, 동적 동작과 고급 메타프로그래밍 기능을 제공할 수 있습니다. 최대 혜택을 누리기 위해 여러분은 최상의 관행을 준수하고 일반적인 오류들을 인지하는 것이 중요합니다. 🎯\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 기사에서는 프록시와 Reflect API에 중점을 두어 JavaScript 메타 프로그래밍의 강력한 기능을 탐구했습니다. 개념, 최선의 실천 방법, 흔한 함정 및 실제 응용 프로그램을 살펴보았습니다.\n\n프록시와 Reflect API는 객체 작업을 가로채는 방법을 통해 로깅, 유효성 검사 및 세밀한 반응성과 같은 동적 행위를 가능케 합니다.\n\n최선의 실천 방법은 기본 동작을 유지하기 위해 Reflect를 사용하고 견고한 보안 검사를 구현하는 것이며, 흔한 함정은 성능 부담과 디버깅 복잡성을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVue.js와 MobX와 같은 프레임워크는 상태 관리와 반응성을 위해 프록시를 활용합니다. 반응형 프로그래밍으로의 전환은 반응성 및 효율적인 애플리케이션 구축의 중요성을 강조합니다.\n\n실시간 대화형 애플리케이션에 대한 수요가 증가하고 WebAssembly와 같은 기술이 웹 개발 능력을 더욱 향상시키는 한, 이러한 추세는 계속될 것으로 예상됩니다.\n\n새로운 글과 신선한 모험에서 다시 만나요! ❤️\n\n제 글을 읽어주셔서 감사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nWant to Connect? \nYou can find me at GitHub: https://github.com/helabenkhalfallah\n","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptMeta-programmingwithProxiesandReflection_0.png","tag":["Tech"],"readingTime":21},{"title":"네스트JS는 ASPNET 팀이 노드js로 이전하거나 그 반대로 이동할 때 완벽한 프레임워크입니다","description":"","date":"2024-06-20 07:18","slug":"2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa","content":"\n\n## Nest.js 대 ASP.NET: 프레임워크 비교\n\n![이미지](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png)\n\n웹 개발 여정을 시작하는 여러 가지 방법이 있습니다. 현대 웹에는 다양한 프레임워크가 있으며, 어떤 것이 최선인지 선택하는 것이 새로운 사용자들에게는 더 어려워지고 있습니다. 웹 프레임워크는 웹을 위해 만들어졌지만 사용해야 하는 다양한 이유가 있습니다.\n\n구축할 웹 사이트 유형, 사이트의 성능 요구 사항, 사용 가능한 개발자 풀, 그리고 사용하는 클라우드 제공 업체에 따라 만들어야 할 결정에 영향을 줄 것입니다. 결과적으로, 프레임워크를 선택할 때 고려할 사항이 많이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Nest.js와 ASP.NET이 무엇인가요?\n\n먼저 Nest.js부터 알아보겠습니다.\n\n## Nest.js\n\nNest.js는 TypeScript 프로그래밍 언어를 사용하여 완전히 구현된 Node.js 웹 프레임워크입니다. 다른 Node.js 웹 프레임워크와 비교할 때, Nest.js는 코드의 잘 정리된 프로젝트 구조에 중점을 둡니다. 경험 많은 개발자들은 Nest.js가 코드를 Angular 같은 다른 프레임워크로 어떻게 정리하는지를 알아볼 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js는 Express의 함수형 접근 방식과 비교하여 TypeScript의 객체 지향 프로그래밍을 완전히 활용합니다. 그러나 내부적으로 Nest.js는 HTTP 서버를 실행하기 위해 Express 또는 Fastify(구성에 따라 다름)를 사용합니다. 따라서 다른 프레임워크 위에 있는 추상화 계층으로 생각할 수 있습니다.\n\n## ASP.NET\n\nASP.NET은 Microsoft가 만든 웹 프레임워크입니다. Microsoft의 C# 프로그래밍 언어를 사용합니다. ASP.NET은 2002년 초반부터 오랫동안 사용되어 왔습니다. 하지만 이전부터 지속적으로 새로운 버전을 출시하며 지속적으로 향상되어 왔습니다. 이러한 결과로 ASP.NET은 이제 C#으로 거의 모든 것을 구축할 수 있는 프로그래밍 도구 모음인 .NET으로 더 널리 알려지게 되었습니다.\n\n웹 프레임워크는 이제 보편적으로 .NET Core로 불리며, .NET 6가 최신 버전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TypeScript과 C#이 무엇인가요?\n\nTypeScript과 C#은 모두 Microsoft가 만들었습니다. Microsoft는 닷컴 붐 속에서 수요가 증가함에 따라 C#을 만들었습니다. Sun Microsystems의 Java와 같은 언어가 웹 개발자들에 의해 가장 인기 있는 프로그래밍 언어 중 하나로 발전하는 가운데, Microsoft는 자사의 언어를 만들어 시장에 진입하기로 결정했습니다.\n\nJavaScript도 닷컴 붐 이후 지금까지 인기를 얻고 있었습니다. 2010년대 초, Microsoft 엔지니어들은 강력한 타입 시스템을 갖춘 JavaScript의 상위 집합인 TypeScript을 만들었습니다. 그러나 TypeScript은 2016년부터 맹활약하기 전에 성숙 과정을 거쳤습니다.\n\n동일한 회사가 두 프로그래밍 언어를 만들었기 때문에 두 언어는 공통점이 많으며, 익숙함으로 인해 개발 경험이 증진되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 언어 모두 컴파일되기 때문에 컴파일러가 컴파일 시간에 오류를 확인합니다.\n\n## TypeScript에서의 객체 지향 프로그래밍\n\nTypeScript에서의 객체 지향 프로그래밍은 JavaScript보다 조금 더 나은 편입니다. 그러나 JavaScript와 TypeScript 모두 클래스를 지원하며, 두 언어 모두 코드 캡슐화를 구현하는 것은 꽤 간단해 보입니다.\n\n```typescript\nclass Car {\n  color: string;\n  getColor() {\n    return this.color;\n  }\n  setColor(_color: string) {\n    this.color = _color;\n  }\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript에는 JavaScript에 없는 인터페이스가 있습니다.\n\n```js\n인터페이스 Car {\n  type: string;\n  getType(): string;\n  setType(_type);\n}\n```\n\n인터페이스의 구현은 다음과 같이 보일 것입니다:\n\n```js\nclass Audi implements Car{\n  type: string;\n  color: string;\n  getName() {\n    return this.color;\n  }\n  setName(_color: string) {\n    this.color = _color;\n  }\n  getType(): string {\n    return this.type;\n  }\n  setType(_type: any) {\n    this.type = _type;\n  }\n}\n인터페이스 Car {\n    type: string;\n    getType(): string;\n    setType(_type);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js는 TypeScript에서 OOP를 가장 효율적으로 활용하는 프레임워크 중 하나입니다. 모든 것이 인터페이스, 클래스 및 의존성 주입과 같은 OOP 개념에 기반을 두고 있습니다.\n\n## C#에서의 객체 지향 프로그래밍\n\nC#은 당시 가장 인기 있는 OOP 프로그래밍 언어인 Java를 모델로 삼았습니다. 최근까지 C#에서 코딩하는 것은 항상 Java에서 코딩하는 것과 동일한 단점을 가지고 있었습니다. main 함수를 만들어야 하고 복잡한 프로젝트 구조를 유지해야 하는 등의 단점이 있었습니다. 또한, 프로바이더, 서비스 또는 컨트롤러와 같은 클래스 이름이 유사하거나 충돌할 수 있습니다.\n\nC#에서 유사한 베이스 클래스를 만드는 방법은 다음과 같을 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Car\n{\n  private string color;\n  \n  public void getColor() \n  {\n    return this.color;\n  }\n  \n  public void setColor(string color) \n  {\n    this.color = color;\n  }\n}\n```\n\n인터페이스는 다음과 같이 보일 것입니다:\n\n```js\ninterface ICar\n{\n    string getType();\n    void setType(type);\n}\n```\n\n전체 구현은 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Audi : ICar\n{\n  private string type;\n  private string color;\n  public void getColor() \n  {\n    return this.color;\n  }\n  public void setColor(string color) \n  {\n    this.color = _color;\n  }\n  public void getType() \n  {\n    return this.type;\n  }\n  public void setType(string type) \n  {\n    this.type = _type;\n  }\n}\n```\n\n개발자분께서 경험상 TypeScript와 비교하여 C#은 더 풍부한 객체지향 프로그래밍(OOP) 기능을 제공한다는 것을 알게 될 것입니다. 인터페이스는 C#이 할 수 있는 것들 중 일부에 불과합니다. 더 발전된 개념은 리플렉션(reflection)을 사용하는 것인데, 지금은 제가 먼저 가려고 하는 것 같네요.\n\n## Nest.js vs. ASP.NET\n\n이제 논란이 될 부분으로 향하고 있습니다. 프로젝트에는 무엇을 선택해야 할까요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n둘 다 놀라운 프레임워크인데 고려해야 할 일부 결정은 개인적인 기호에 따라 다르게 결정될 수 있습니다. 이 둘 사이에서 선택을 하는 것은 얼마나 유사한지 때문에 까다로운 일입니다.\n\n## 주요 기능 비교\n\nNest.js와 ASP.NET은 인증, 캐싱 및 데이터베이스 액세스와 관련된 기능을 쉽게 제공합니다. 두 프레임워크 모두 사용할 수 있는 기능입니다. Nest.js는 @nestjs/passport, @nestjs/cache-manager 및 @nestjs/typeorm 패키지를 사용하여 이러한 기능을 제공합니다. 한편 ASP.NET은 Microsoft.AspNetCore.Authentication, Microsoft.AspNetCore.Caching.Memory 및 유명한 Microsoft.AspNetCore.Identity.EntityFrameworkCore와 같은 패키지를 통해 인증, 캐싱 및 데이터베이스 액세스(및 더!) 기능을 제공합니다.\n\nTevpro의 기사에서는 Nest.js가 제공하는 기본 기능의 집합을 설명하고 있습니다. Nest.js와 ASP.NET 간의 사용 가능한 패키지를 비교한 테이블을 참조하여 더 자세한 내용을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 프레임워크의 주요 기능 간 결과는 비슷하지만, Nest.js와 ASP.NET은 둘 다 거대한 커뮤니티를 뒷받침하고 있습니다. 예를 들어, Nest.js는 Node.js 커뮤니티를 의지할 수 있고, ASP.NET은 거의 모든 대규모 기업 시스템에서 사용되기 때문에 대규모 기업 후원을 받고 있습니다.\n\n당연히 ASP.NET 웹 프레임워크 쪽에는 Nest.js보다 더 많은 패키지가 있습니다. 이는 ASP.NET이 더 오래되었기 때문입니다. 그러나 언젠가는 Nest.js도 JavaScript 및 TypeScript 개발자들의 수가 더 많아지면서 혜택을 받을 것입니다.\n\n## 유사점\n\nNest.js와 ASP.NET 사이에는 많은 유사점이 있다는 것이 놀라울 수도 있습니다. 그러나 둘 다 일상적으로 OOP에 크게 의존하고 있으며 TypeScript와 C#이 프로그래밍 언어로서 얼마나 유사한지를 고려할 때, 어떤 프레임워크를 사용하는지에 따라 앱을 비교할 때 큰 차이가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 Nest.js 프로젝트를 위한 서비스 컨트롤러는 아래와 같이 보일 것입니다:\n\n```js\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n  \n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n```\n\nAppController는 의존성 주입을 통해 AppService를 받아오며, getHello 함수는 문자열을 응답으로 반환합니다. 예를 들어, ASP.NET의 유사한 컨트롤러는 다음과 같이 보일 것입니다:\n\n```js\nnamespace Backend.AppController\n{\n    [ApiController]\n    public class AppController\n    {\n        private readonly AppService appService;\n        \n        public AppController(AppService _appService)\n        {\n            this.appService = _appService;\n        }\n        \n        [HttpGet]\n        public async Task\u003cIActionResult\u003e GetHello()\n        {\n            return Ok(this.appService.GetHello());\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest.js와 비교하면 ASP.NET에서 작성하는 것이 더 장황해 보입니다. 그리고 두 가지 모두 컴파일된 언어를 사용하기 때문에 컴파일러가 런타임 전에 유형 오류와 같은 사소한 오류를 잡아줄 수 있습니다.\n\n## Nest.js 대 ASP.NET 성능평가\n\n두 프레임워크 간 속도를 비교하는 것은 논란이 될 수 있고, 최소한 몇몇 비평을 유발할 것입니다. 하지만 프레임워크를 선택할 때 약간 고려해 볼 가치가 있습니다.\n\n2022년 Tech Empower Web Benchmarks에 따르면 ASP.NET Core는 14위로 세계에서 14번째로 빠른 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image 1](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_1.png)\n\nWhile Nest.js, using a Fastify backend, is ranked at #239.\n\n![image 2](/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_2.png)\n\nPlease note that these benchmarks are arbitrary speed calculations of how fast a framework would respond. You don’t necessarily need a fast framework most of the time. And the most important metric is (arguably) your development speed, but that’s VERY subjective, bringing us to the next point.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n---\n\n# Nest.js 대신 ASP.NET을 고려해야 하는 시기 (또는 그 반대)\n\n대중들의 의견을 살펴보면 결정을 내리기 어려울 것입니다. 두 프레임워크를 비교하는 의견은 주로 물어보는 커뮤니티에 따라 (또는 이 경우에는 Sub Reddit에 따라) 다를 수 있습니다.\n\nReddit을 살펴보면, 몇 개의 게시물이 두 프레임워크를 비교하는데 (일부 게시물은 Node.js를 직접적으로 ASP.NET과 비교합니다) 있습니다. 토론에서 주로 나오는 의견은 \"Node.js에서 ASP.NET으로 전환하려면 먼저 TypeScript를 고려해보라\"로 요약됩니다.\n\nNest.js는 이미 TypeScript를 사용하고 있으니, 이것이 문제를 해결해 줄 것이라 생각할 수 있겠죠? 그렇지 않습니다. 그렇게 간단하지는 않습니다. TypeScript를 사용하는 것이 더 나은 이유는 frontend 언어와 backend 언어를 결합해 소규모 팀이 제품을 성장시키기 더 쉬워지기 때문이라고 주장하기는 하지만, ASP.NET을 사용하는 경우 더 합리적인 상황이 있을 수 있습니다.\n\n---\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어 클라우드 공급업체가 Azure이고 벤더 락인이 신경 쓰이지 않는다면 ASP.NET이 더 나은 선택입니다.\n\n그러나 보다 넓은 시각에서 볼 때 Nest.js와 ASP.NET 사이에 큰 차이가 많이 없습니다. 두 프레임워크가 추구하는 철학에는 많은 중첩이 있어서 OOP의 활발한 사용이 그 중 하나입니다. 때로는 특히 언어별 차이 덕분에 두 프레임워크 사이에 인상적인 유사성을 찾을 수 있습니다.\n\n실용적으로 중요한 것은 기본 속도, 프로젝트 구조, 라이브러리 이용 가능성 및 커뮤니티 지원을 고려할 필요가 없습니다. 다음 사항만 고려하면 됩니다:\n\n- 팀의 특정 기술 세트.\n- 제품 개발 일정.\n- 사용 중인 클라우드 공급업체.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 프레임워크 모두 서버 측 렌더링 프레임워크로, 전통적인 MVC 애플리케이션을 간편하게 연결하여 밀접하게 통합된 모노리스를 만들 수 있습니다.\n\n프레임워크를 선택할 때 흔히 발생하는 함정에 대해 알아야 합니다. 이전 선택사항에 과도하게 고집하지 말고, 시대가 변화하고 어떤 프레임워크가 인기 경쟁에서 우승한 것뿐만 아니라 그 기능적인 우수성 때문에 더 많이 채택될 수도 있다는 점을 인식해야 합니다. 사소한 문제 때문에 발목을 잡지 마세요, 더 나은 선택을 해보세요!\n\n# 결론\n\nNest.js와 ASP.NET은 놀라운 프레임워크이지만, 일반적으로 사용 사례는 구축하고 있는 팀(또는 가지게 되는 팀) 유형에 제한됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프레임워크들을 명백하게 선택해야 하는 이유는 없어요. 다른 언어보다 여기서 사용하라고 강제하거나 산업에 특화된 작업을 진행하는 경우, 게임 개발에 Unity를 사용하면서 C#을 사용해야 하는 경우처럼 특정 언어 집합을 사용해야 하는 경우를 제외하고는 백엔드로 ASP.NET을 고려해 보세요.\n\nNest.js와 ASP.NET 중에서 선택하는 것은 Nest.js와 고성능 Go/Rust 웹 프레임워크 중에서 선택하는 것만큼 중대하지 않아요. 각각의 독특함은 있지만 전반적으로 차이보다는 중첩된 부분이 더 많아요. 그러니 기술에 대해 너무 꼼꼼하게 고려할 필요 없어요. 시대에 맞춰 움직이세요. 즐겁게 코딩하세요! \n\n원문: https://blog.logrocket.com, 2022년 11월 22일에 발행됨.","ogImage":{"url":"/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png"},"coverImage":"/assets/img/2024-06-20-WhyNestJSisthePerfectFrameworkforASPNETTeamsMigratingtoNodejsOrVice-Versa_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 DSA 모험 - 3장 - 배열-01","description":"","date":"2024-06-20 07:17","slug":"2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01","content":"\n\n이 블로그에서는 프로그래밍에서 핵심적이고 널리 사용되는 배열 데이터 구조를 알아볼 것입니다.\n\n배열은 메모리가 서로 옆에 위치한 선형 데이터 구조입니다. 우리는 배열 요소에 인덱스 번호로 액세스할 수 있습니다. 배열은 대량의 데이터를 저장하는 데 자주 사용됩니다. 메모리 할당과 차원을 기반으로 범주화된 다양한 유형의 배열이 있습니다.\n\n# 메모리 할당에 따른 배열\n\n정적 배열: 배열 크기가 고정된 배열로, 메모리 할당이 배열 생성 시에 이루어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet arr=[1,2,3,4,5];\n```\n\n동적 배열: 크기가 동적으로 커질 수 있는 배열이며, 메모리 할당이 동적으로 이루어집니다.\n\n```js\nlet arr= new Array(5);\n```\n\n# 차원에 따른 배열\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\na. 일차원\n\nb. 다차원\n\n# 미리 정의된 배열 메소드의 복잡성 분석\n\n- push(): 배열의 끝에 요소를 추가하며 다른 인덱스를 업데이트하지 않습니다.\n시간 복잡도: O(1)\n공간 복잡도: O(1)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*opzqu5bRV6657AZwySuS5g.gif)\n\n2. pop(): 배열의 끝에서 요소를 제거하고 다른 인덱스를 업데이트하지 않습니다.\n시간 복잡도: O(1)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*cP7tauXB0AkDx9P0ECRooA.gif)\n\n3. shift(): 배열의 시작에서 요소를 제거하고 남은 인덱스를 업데이트합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*wDYt2Kg8rb0miocg8amjYw.gif)\n\n4. unshift(): 배열의 시작 부분에 요소를 추가하고 남은 인덱스를 업데이트합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*HagypKnHwgJPgAA53o2IAQ.gif)\n\n5. splice(): 기존 요소를 이동하여 요소를 추가하거나 제거합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (요소가 추가되면 새로운 요소에 대한 추가 공간이 필요합니다)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. concat(): 두 배열을 병합합니다.  \n시간 복잡도: O(n + m) (여기서 'n'과 'm'은 병합되는 배열의 길이입니다)  \n공간 복잡도: O(n + m) (결과를 저장하기 위해 새로운 배열이 생성됨)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*u4_C14uNAEPERs71mjPssQ.gif)\n\n7. 요소에 접근 (arr[index]): 인덱스를 사용하여 요소에 직접 액세스합니다.  \n시간 복잡도: O(1)  \n공간 복잡도: O(1)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6OuIlKR5RJiLwCS3SAM3lg.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n8. map(): 호출한 배열의 각 요소에 대해 함수를 호출하여 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (동일한 크기의 새 배열이 생성됨)\n\n9. forEach(): 배열 요소마다 한 번씩 제공된 함수를 실행합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n10. reduce(): 누산기에 대해 함수를 적용하고 배열의 각 요소마다 하나의 값을 줄입니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n11. filter(): 제공된 함수에 의해 구현된 테스트를 통과하는 모든 요소로 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (필터링된 요소를 보유하는 새 배열이 생성됨)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n12. slice(): 기존 배열의 일부를 추출하여 새 배열을 생성합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(n) (추출된 요소로 새 배열이 생성됩니다)\n\n13. includes(): 배열에 특정 값이 포함되어 있는지 여부를 확인합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qAvY1uZYVoruLu2hiDG7Ow.gif)\n\n14. indexOf(): 주어진 요소가 처음으로 발견되는 인덱스를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vjlt1A3ss8ncvINiuD4QJg.gif)\n\n15. find(): 주어진 테스트 함수를 만족하는 배열 내 첫 번째 요소를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*dK0xCiis9Aia7wgpR86Stg.gif)\n\n16. findIndex(): 주어진 테스트 함수를 만족하는 배열 내 첫 번째 요소의 인덱스를 반환합니다.\n시간 복잡도: O(n)\n공간 복잡도: O(1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vjlt1A3ss8ncvINiuD4QJg.gif)\n\n17. sort(): 배열 요소를 정렬하며 일반적으로 Timsort의 변형을 사용합니다.\n시간 복잡도: O(n log n)\n공간 복잡도: O(n) (정렬 중 임시 배열에 대한 추가적인 공간이 필요합니다)\n\n# 왜 배열을 사용해야 할까요?\n\n배열은 요소에 쉽게 액세스하고 더 나은 캐시 지역성을 갖고 싶을 때 유용합니다. 캐시 지역성은 상대적으로 가까운 저장 위치 내에서 데이터 요소를 사용하는 것을 의미합니다. 프로세서가 메모리 위치에 액세스할 때 그것이 필요한 특정 데이터뿐만 아니라 인접한 데이터 블록도 캐시로 로드합니다. 배열은 연속적으로 저장되어 있기 때문에 한 요소에 액세스하면 캐시로 로드된 인접 요소가 있을 수 있습니다. 이는 인접한 요소에 대한 후속 액세스가 빠르다는 것을 의미합니다. 왜냐하면 이미 캐시에 들어있기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음에 코딩할 때는 이 통찰을 잘 기억하고 자신감을 가지고 DSA(Data Structures and Algorithms) 모험을 떠나보세요!\n\n다음 블로그에서 만나요, 코드 마법사들!","ogImage":{"url":"/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScript-DSAAdventures-Chapter03-Array-01_0.png","tag":["Tech"],"readingTime":4},{"title":"새로운 React Native IDE 탐험 개발자들에게 혁신적인 변화","description":"","date":"2024-06-20 07:16","slug":"2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers","content":"\n\nReact Native 개발자들이 기대할만한 새로운 것이 있습니다 — 현재 베타 단계에 있는 새로운 React Native IDE입니다. 이 흥미로운 새로운 도구는 Visual Studio Code (VS Code) 확장 프로그램으로 제공되며, macOS에서 안드로이드와 iOS 플랫폼 모두에 대한 개발을 지원합니다. 이 블로그에서는 이 IDE의 기능, 이점 및 잠재적인 도전 과제에 대해 탐구하고, React Native 개발 커뮤니티에 중요한 발전을 뜻하는 이유를 살펴보겠습니다.\n\n# React Native IDE 시작하기\n\n# 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 네이티브 IDE 설치는 간단합니다. VS Code에 확장 프로그램을 추가하여 리액트 네이티브 프로젝트를 위해 특별히 설계된 강력한 개발 도구 모음을 활성화할 수 있습니다. 아래는 시작하는 방법입니다:\n\n- VS Code 열기: 최신 버전이 설치되어 있는지 확인해주세요.\n- 확장 프로그램으로 이동: 활동 표시줄의 확장 프로그램 아이콘을 클릭하거나 Ctrl+Shift+X를 눌러 확장 프로그램 뷰로 이동합니다.\n- 리액트 네이티브 IDE 검색: 검색 상자에 \"리액트 네이티브 IDE\"를 입력합니다.\n- 확장 프로그램 설치: 설치 버튼을 클릭하여 확장 프로그램을 VS Code 환경에 추가합니다.\n\n설치 후, 이 확장 프로그램은 원활하게 통합되어 리액트 네이티브 개발에 특화된 고급 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 자동 시뮬레이터 관리\n\n시뮬레이터 및 에뮬레이터 관리는 귀찮은 일일 수 있지만, React Native IDE는 자동 시뮬레이터 관리 기능으로 이를 간단하게 처리합니다. 이 기능은 프로젝트에 적합한 시뮬레이터를 감지하고 시작하여 구성보다는 코딩에 집중할 수 있도록 합니다.\n\n# 2. 고급 디버깅 도구\n\nReact Native에서 디버깅하는 것은 이제 더 쉽지 않을 수 있습니다. IDE는 중단점 설정, 코드 스텝 진행 및 변수 검사를 포함한 견고한 디버깅 도구를 제공합니다. 이러한 도구는 문제를 신속하게 식별하고 해결하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 요소 검사\n\n클릭하여 검사하는 기능이 특히 주목할 만합니다. 웹 개발 도구와 유사하게, 이 기능을 사용하면 시뮬레이터에서 어떤 요소를 클릭해도 VS Code 내에서 해당 요소의 속성을 직접 검사할 수 있습니다. 이 익숙한 작업 흐름은 사용하기 쉽고 효과적으로 인정 받고 있습니다.\n\n# 4. 라우팅 및 내비게이션\n\nExpo 라우터와 통합된 IDE를 사용하면 프로젝트 내에서 탐색을 간편화 할 수 있습니다. URL 바를 통해 경로를 지정하여 서로 다른 화면과 구성 요소를 테스트하고 디버그하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 로그 통합\n\nIDE 내에서 로그를 통합하면 개발 환경을 떠나지 않고 콘솔 출력과 오류 로그를 모니터링할 수 있습니다. 이 통합은 디버깅 프로세스를 간편하게 만들어주고 생산성을 향상시켜줍니다.\n\n# 6. 독립적인 컴포넌트 개발\n\nReact Native IDE의 특징 중 하나는 독립적인 환경에서 컴포넌트를 개발할 수 있는 기능입니다. 이 기능을 통해 개발자는 개별 컴포넌트에 집중하여 해당 컴포넌트가 완벽하게 작동하는지 확인한 뒤 더 큰 응용 프로그램에 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 도전 과제 및 베타 단계에서 발생하는 문제\n\n모든 베타 소프트웨어와 마찬가지로, React Native IDE에는 고려해야 할 도전 과제가 있습니다. 초기 설정은 일부 사용자에게 번거로울 수 있으며, 기능적인 결함이 예상되기도 합니다. 그러나 이러한 것들은 도구가 점차 성숙해지면 개선될 가능성이 높습니다.\n\n## 결론\n\n베타 단계에 있음에도 불구하고 React Native IDE는 React Native 개발자들에게 상당한 진전을 제공합니다. 개발 프로세스를 간소화하고 디버깅 기능을 강화하며 강력한 기능을 제공함으로써, 이 IDE는 생산성을 향상시키고 개발을 보다 쉽게 만들어주는 것을 약속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 React Native 개발자이신 경우, 이 IDE의 베타 버전에 액세스를 요청하는 것은 워크플로우를 크게 향상시킬 수 있습니다. 이 인상적인 새로운 도구로 React Native 개발의 미래를 받아들이고 시대를 앞서가세요.\n\nIDE가 발전함에 따라 더 많은 안정성과 기능이 기대됩니다. 이는 React Native 개발자 툴킷의 필수적인 부분이 될 것입니다. React Native IDE가 완전히 출시될 때까지 업데이트와 개선 사항을 기대해주세요.\n\n🌟 읽어 주셔서 감사합니다!\n\n- 🚀 이 링크를 클릭하여 내 작업을 지원하세요: Support Me 🌟\n- 👏 이 기사에 박수를 보내어 감사의 표시를 전하세요.\n- 📌 더 많은 통찰력 있는 콘텐츠를 얻기 위해 Avishek Kumar를 팔로우하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n📣 계속 참여해 주세요\n\n- 🔔 트위터에서 팔로우하기(X)\n- 🔗 링크드인에서 연결하기\n\n# 스택아데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 응원하고 팔로우하기를 고려해 주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png"},"coverImage":"/assets/img/2024-06-20-ExploringtheNewReactNativeIDEAGameChangerforDevelopers_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 스크레이퍼로부터 사이트를 안전하게 보호하는 방법","description":"","date":"2024-06-20 07:15","slug":"2024-06-20-HowtoSecureYourSiteAgainstWebScrapers","content":"\n\n## 가장 좋은 브라우저 지문 기술입니다. 당신만의 지문 코드를 몇 분 안에 구현하는 법을 배워보세요!\n\n![이미지](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png)\n\n브라우저 지문 기술은 사용자를 고유하게 식별하고 싶은 다양한 상황에서 사용되는 보안 기술입니다. 물론, 그러한 상황 중 하나는 당신의 웹 사이트를 스크랩하는 경우입니다. 사용자 에이전트나 IP를 확인하는 것과 같은 제한적인 탐지 기술을 사용하면 그 정보를 쉽게 변경할 수 있으며 당신은 알지 못할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 브라우저 핑거프린트와 같은 것을 구현한다면, 그들의 작업을 훨씬 더 어렵게 만들 수 있습니다. 왜냐하면 가짜로 만들기 어려운 정보를 사용하기 때문이죠.\n\n이 기사에서는 이렇게 불리는 \"브라우저 핑거프린트\"를 만드는 가장 일반적인 기술 중 일부를 다루고, 그 중 하나를 구현하는 방법을 안내해 드릴 거예요.\n\n# 일반적인 브라우저 핑거프린팅 기술\n\n이 제목이 어려운 것처럼 들릴 수 있지만, 핑거프린트란 특정 입력 데이터 집합으로부터 생성된 해시에 불과합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 핵심은 어떻게 그것에 도달하는지에 있어요.\n\n### 캔버스 요소 사용하기\n\n지문을 얻는 한 가지 방법은 사용자가 보지 못하도록 뭔가를 그려내고 그 결과를 확인하는 것입니다.\n\n각 브라우저는 캔버스 요소에 콘텐츠를 렌더링하는 방식에 약간의 차이가 있습니다. 이들은 미묘한 차이이므로 찾고 있지 않다면 정말로 발견하기 어렵습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정한 사용 사례는 여러 사실을 활용합니다:\n\n- 모든 시스템에 폰트가 제공되지 않아서 그런 경우에는 대체 옵션을 사용해야 합니다.\n- 적용된 안티 앨리어싱이 항상 동일하지는 않습니다.\n- 브라우저의 구현에 따라 다른 세부 사항이 있습니다.\n\n한 번 렌더링된 후 이미지를 해시로 변환해야 하며, 그렇게 하면 지문이 생성됩니다.\n\n최고의 부분은 캔버스 요소를 숨길 수 있어서 사용자가 실제로 무엇을 하는지 알 수 없다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 미디어 장치 목록\n\n브라우저의 지문을 식별하는 또 다른 방법은 시스템에 연결된 미디어 장치 목록을 수집하고 그 정보를 기반으로 해시를 생성하는 것입니다.\n\n이를 어떻게 할 수 있을까요? 실은 매우 간단합니다. 모든 최신 브라우저에는 연결된 모든 장치를 나열할 수 있는 미디어 장치 API가 있습니다.\n\n다음 코드는 시스템에서 모든 미디어 장치를 나열합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMDN 공식 문서에서 가져온 코드입니다. 제 Firefox에서 실행하면 다음 출력이 나옵니다:\n\n```html\n\u003cimg src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_1.png\" /\u003e\n```\n\n미래 요청에서 식별자 역할을 할 수 있는 단일 해시 값을 생성하는 방법을 쉽게 파악할 수 있을 것 같습니다. 브라우저 구성을 변경하더라도 식별 가능합니다.\n\n## 오디오 파형 지문분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스 요소 기술과 마찬가지로 Web Audio API를 사용하여 오디오 클립을 생성할 수도 있습니다. 고정된 소스(모든 시스템에 동일한 입력을 제공하는 발진기)를 기반으로 하고 출력의 해시를 계산할 수도 있습니다.\n\nWeb Audio API의 복잡성을 고려하면, 많은 수학과 부동 소수점 수학이 관련되어 있습니다. 이는 각 브라우저가 조금씩 다른 구현을 갖게 되며, 이는 누가 작성했는지와 해당 운영 체제에 따라 달라집니다. 이러한 차이점은 실행 중인 시스템이 매 실행에서 일관된 고유값을 생성할 수 있을 정도로 충분히 누적됩니다.\n\n이러한 값은 브라우저와 운영 체제를 식별하는 데 사용할 수 있는 신뢰할 수 있는 지문으로 사용할 수 있습니다. 특히, 브라우저의 시크릿 모드를 사용하더라도 동일한 지문이 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직접 지문코드를 구현해 봅시다\n\n가장 흔한 지문 기술 중 일부를 이해했으니, 여기서는 그 중 하나를 구현하는 방법에 대해 빠르게 살펴보겠습니다.\n\n미디어 장치 목록에 대한 코드 일부를 이미 보았지만, 캔버스 요소에 중점을 둘 것입니다. 많은 데이터 포인트를 수집하는 것보다 더 흥미로운 것이라고 생각하기 때문입니다.\n\n이 기술을 사용하려면 텍스트가 포함된 그림을 캔버스 요소 내부에 그리고, 그 그림을 단일 해시로 변환해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 해야 할 일은 캔버스를 정의하고 그 안에 몇 가지 모양을 그리고 텍스트를 추가한 다음, 그 위에서 toDataURL 메서드를 호출하는 것 뿐이에요. 기본적으로 캔버스는 우리의 이미지를 PNG로 변환하고, 그것을 단일 해시 값으로 변환할 겁니다.\n\n특히, 우리의 \"해시\"는 단일 정수가 될 겁니다. 본인이 원하는 해싱 방법을 사용해도 돼요. 저는 코딩하기 쉽고 빠른 성능을 가진 하나를 선택했어요.\n\n이 코드는 다음과 같은 출력물을 생성합니다:\n\n![How to Secure Your Site Against Web Scrapers](/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 실제 이미지는 상당히 추악합니다. 우리는 지금 아름다운 것을 만들려는 것이 아니라 해시에 대해 걱정하고 있습니다. 크롬과 시크릿 모드의 크롬의 값이 동일하고 파이어폭스에서는 다르다는 것을 주목하세요.\n\n이것은 중요한 포인트입니다. 이는 크롤러/스크레이퍼가 그들의 브라우저에서 음해모드를 사용함으로써 \"속이려\" 하려고 할 때 언제인지 알 수 있다는 것을 의미합니다.\n\n그들은 브라우저를 변경할 수 있고, 그러면 당신은 몰라도 될 것입니다. 그러나 스크레이퍼/크롤러는 보통 자신을 다른 것처럼 식별하려고 하는 동일한 브라우저를 항상 사용합니다 (User Agent 문자열과 같이).\n\n이 상황에서 당신은 웹사이트를 크롤링/스크래핑하려는 헤드리스 브라우저에 대해 보호할 수 있습니다. 위 코드를 숨겨진 Canvas 요소에 실행하는 스크립트를 갖고, 해시를 가져와서 자체 \"블랙리스트\" 값 목록과 비교하세요. 그들이 거기에 있다면, 그럼 무슨 일을 해야하는지 알 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저 지문 추적은 사용자가 시스템과 상호 작용하는 방식을 원치 않을 때 보호하는 데 훌륭한 도구일 수 있습니다. 사이트를 스크랩하려는 사람부터 사용자가 유료 콘텐츠를 속일 수 없도록 하는 데 사용되며, 또는 콘텐츠에 제한된 횟수로만 액세스하도록 하는 데도 사용될 수 있습니다. 정말로 여러분의 상상력이 한계입니다.\n\n그리고 이론이 복잡해 보이지만 실제 구현은 그렇지 않다는 것을 알 수 있습니다. 여러분은 손쉽게 자체 지문 코드를 작성할 수 있습니다.\n\n이런 기술 중 하나를 사용해 보셨나요? 혹은 더 나아가, 과거에 한 번 속여 본 경험이 있으신가요? 그렇다면 어떻게 하셨는지 이야기를 공유해 주세요!\n\n# 재사용 가능한 컴포넌트로 마이크로프론트엔드 구축하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_3.png\" /\u003e\n\nBit의 오픈소스 도구를 통해 25만 명 이상의 개발자가 컴포넌트로 앱을 만들 수 있습니다.\n\n어떤 UI, 기능 또는 페이지도 재사용 가능한 컴포넌트로 변환하여 여러 애플리케이션에서 공유할 수 있습니다. 협업이 더 쉬워지고 빠르게 개발할 수 있습니다.\n\n→ 자세히 알아보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 구성 요소로 나누어 앱 개발을 쉽게 만들고 원하는 워크플로우에 최적의 경험을 즐기세요:\n\n- **Micro-Frontends**   \n- **Design System**   \n- **Code-Sharing and reuse**  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 모노리포\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoSecureYourSiteAgainstWebScrapers_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs 심층 분석 1  createElement와 jsx-runtime","description":"","date":"2024-06-20 07:13","slug":"2024-06-20-ReactjsDeepDive1createElementandjsx-runtime","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png\" /\u003e\n\nReact는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리로, 상호작용적이고 동적인 웹 애플리케이션을 만들기 위한 다양한 도구와 기능이 풍부합니다. React의 최신 버전(React 17부터)에서는 JSX 변환 방법이 크게 변경되었습니다. React 17에서 소개된 새로운 JSX 변환은 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime 및 react/jsx-dev-runtime 패키지에서 jsx, jsxs, jsxDEV 등의 새로운 함수를 도입하였습니다. 이 글은 \"React.js Deep Dive\" 시리즈 중 첫 번째로, React.createElement, jsx-runtime을 사용한 새 버전 및 React 생태계에서의 역할을 탐구합니다.\n\n이 새로운 변환 방법이 작동하는 방식에 대한 개요는 다음과 같습니다:\n\n# React 17 이전\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에는 JSX가 React.createElement 호출로 컴파일되었습니다. 예를 들어, 다음 JSX:\n\n```js\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      My App\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n백그라운드에서 JSX는 React.createElement 호출로 변환됩니다:\n\n```js\nfunction App() {\n  return React.createElement(\"div\", {\n    children: \"My App\"\n  });\n}\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React 17버전 이후\n\n새 JSX 변환 기능을 사용하면 같은 JSX 코드:\n\n```js\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      My App\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n다음으로 변환됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction App() {\n  return /*#__PURE__*/_jsx(\"div\", {\n    children: \"내 앱\"\n  });\n}\nexport default App;\n```\n\n개발 모드에서는 더 나은 디버깅 정보를 제공하기 위해 react/jsx-dev-runtime의 jsxDEV을 사용할 수 있습니다:\n\n```js\nfunction App() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n    children: \"내 앱\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 3,\n    columnNumber: 5\n  }, this);\n}\n```\n\n# 왜 이 변화가 있었을까요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 JSX 트랜스폼에는 여러 가지 이점이 있습니다:\n\n- 범위 내에서 React 사용량이 필요 없음: 새로운 트랜스폼을 사용하면 JSX를 사용하는 모든 파일 맨 위에 React를 가져오지 않아도 됩니다. 이는 코드를 간소화하고 보일러플레이트를 줄일 수 있습니다.\n- 더 작은 번들 크기: 새로운 트랜스폼은 좀 더 최적화된 코드를 생성하기 때문에 조금 더 작은 번들 크기로 이어질 수 있습니다.\n- 미래 지향적: 이 변경 사항은 React 생태계를 미래 개선과 최적화를 위해 준비시킵니다.\n\n이 함수를 더 자세히 살펴보면 반환 값이 이와 같아야 합니다:\n\n```js\n{\n  $$typeof: Symbol(react.element),\n  type: \"div\",\n  props: {children: 'My App'},\n  key:null,\n  ref:null,\n  _owner: null,\n  _store: {validated: false}\n  _self: undefined\n  _source: {\n    fileName: '/my-app/src/App.tsx', \n    lineNumber: 3, \n    columnNumber: 5\n  }\n  [[Prototype]]: Object\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 반환된 각 속성을 자세히 살펴보겠습니다:\n\n타입\n\n전달한 요소의 유형입니다. HTML 태그나 React 컴포넌트를 나타내는 문자열일 수 있습니다. 위의 코드에서는 타입이 HTML 태그 div입니다.\n\n프롭스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전달 된 props 중에서 ref 및 key를 제외한 항목들. 컴포넌트의 타입이 defaultProps 속성을 가지고 있다면, 누락되거나 정의되지 않은 props는 기본 값으로 설정됩니다.\n\nref\n\n전달된 ref입니다. ref가 전달되지 않았다면, 이 속성은 null이 될 것입니다. Ref를 사용하면 DOM 노드에 직접 액세스할 수 있어 입력란에 초점을 맞추거나 스크롤 위치를 읽거나 DOM에 직접 액세스가 필요한 타사 DOM 라이브러리와 통합하는 등의 작업을 수행할 수 있습니다.\n\nkey\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n# 내부 메커니즘\n\n전달된 키가 문자열로 강제 변환됩니다. 키가 전달되지 않았다면, 이 속성은 null이 될 것입니다.\n\n중요한 점은 $$typeof, _store, _owner 및 _self가 React에서 개발 시 사용되는 내부 메커니즘임을 알아두어야 합니다. 이들은 React 작동에 중요한 역할을 하지만, 애플리케이션 코드에서 사용되도록 의도된 것은 아닙니다.\n\n$$typeoff\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 React 요소를 고유하게 식별하기 위해 $$typeof 속성을 사용합니다. 심볼을 초기에 사용한 선택은 다른 환경에서 전역 고유성을 보장하고 다른 라이브러리나 전역 범위의 코드와의 이름 충돌을 피하기 위한 욕구에서 비롯되었습니다.\n\n_store\n\nReact 요소 객체의 _store 속성은 주로 개발 모드(__DEV__)에서 유효성 검사를 위해 사용됩니다. 이 속성에는 validated라는 단일 부울 속성이 포함되어 있습니다. 이 속성은 React 요소가 특정 규칙에 대해 유효성을 검사했는지 여부를 나타내는 플래그 역할을 합니다. 예를 들어, 요소가 목록의 일부이고 고유한 키 속성이 없는 경우, React의 유효성 검사 논리는 _store.validated를 false로 표시할 것입니다. 요소를 유효성을 검사한 후, React는 _store.validated를 true로 설정하여 요소가 검사되었고 해당 요소에 대해 추가 유효성 검사가 필요하지 않음을 나타냅니다.\n\n_owner\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact에서 _owner 속성은 구성 요소 인스턴스의 소유자를 추적하는 데 내부적으로 사용됩니다. 이것은 React의 조정 프로세스에 중요한데요, 여기서 구성 요소가 다시 렌더링해야 하는지 여부를 결정합니다. 부모 구성 요소가 렌더링되면, 해당 자식 구성 요소의 인스턴스가 생성됩니다. 이러한 각 자식 인스턴스는 _owner 속성을 통해 부모에 대한 참조를 가지게 됩니다. 이를 통해 React는 구성 요소의 계층 구조를 추적하고 상태 변경을 효율적으로 관리할 수 있습니다.\n\n_self\n\nReact 요소의 _self 속성은 개발 모드 확인 및 최적화를 위해 React에서 사용되는 또 다른 내부 속성입니다. 이는 이벤트 위임 중에 원래 이벤트 대상을 저장하는 데 사용됩니다.\n\n이벤트가 트리거될 때 React는 _self를 사용하여 이벤트의 원래 대상을 기억합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n_소스\n\n리액트 요소에서 _소스 속성은 공식 리액트 문서나 표준 리액트 자원에서 직접적으로 문서화되지 않았습니다. 그러나 맥락을 고려하면, _소스는 리액트의 합성 이벤트 시스템 내에서 이벤트 원천 또는 소스를 내부적으로 추적하는 데 관련이 있을 수 있습니다.\n\n# 결론\n\n요약하면, 리액트는 React 17부터 도입된 새 JSX 변환에서 더 이상 React.createElement을 직접적으로 사용하지 않습니다. 대신, react/jsx-runtime(jsx, jsxs) 및 react/jsx-dev-runtime(jsxDEV)에서 함수를 사용합니다. 이 변경으로 JSX를 사용할 때 React를 가져와야 하는 필요성을 제거하고, 잠재적으로 더 작은 번들 크기를 갖게 하며, 미래의 향상을 대비합니다. 해당 기능을 이해함으로써 리액트의 작동 방식에 대해 보다 깊은 통찰을 얻을 수 있어서 효율적이고 효과적인 리액트 애플리케이션을 작성하는 능력을 향상시킬 수 있습니다. 다음 글에서는 가상 DOM을 탐험하고, 리액트가 렌더링 성능을 최적화하기 위해 어떻게 사용하는지 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 더 많은 통찰과 즐거운 코딩을 기대해 주세요!\n\n참고 자료:\n\n- React 문서: React 17: 새로운 JSX 변환\n- Babel 문서: Babel: JSX 런타임\n- Webpack 문서: Webpack: 모드 구성","ogImage":{"url":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png"},"coverImage":"/assets/img/2024-06-20-ReactjsDeepDive1createElementandjsx-runtime_0.png","tag":["Tech"],"readingTime":5}],"page":"34","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"34"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>