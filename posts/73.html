<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/73" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/73" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="React 19의 새로운 기능 - 문서 메타데이터" href="/post/2024-05-12-NewFeaturesinReact19DocumentMetadata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19의 새로운 기능 - 문서 메타데이터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19의 새로운 기능 - 문서 메타데이터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19의 새로운 기능 - 문서 메타데이터</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="무료 오픈 소스 ReactJS 템플릿 10가지 공유" href="/post/2024-05-12-10FreeOpenSourceReactJSTemplates"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="무료 오픈 소스 ReactJS 템플릿 10가지 공유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="무료 오픈 소스 ReactJS 템플릿 10가지 공유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">무료 오픈 소스 ReactJS 템플릿 10가지 공유</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Redux, React Typescript, Electron 및 Vite로 시작하기" href="/post/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Redux, React Typescript, Electron 및 Vite로 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Redux, React Typescript, Electron 및 Vite로 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Redux, React Typescript, Electron 및 Vite로 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Microsoft Authentication Library MSAL을 사용한 인증" href="/post/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Microsoft Authentication Library MSAL을 사용한 인증" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Microsoft Authentication Library MSAL을 사용한 인증" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Microsoft Authentication Library MSAL을 사용한 인증</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query" href="/post/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="상태 관리의 잠금 해제 리액트 컨텍스트에 대한 심층 분석" href="/post/2024-05-12-UnlockingStateManagementADeepDiveintoReactContext"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="상태 관리의 잠금 해제 리액트 컨텍스트에 대한 심층 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-UnlockingStateManagementADeepDiveintoReactContext_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="상태 관리의 잠금 해제 리액트 컨텍스트에 대한 심층 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">상태 관리의 잠금 해제 리액트 컨텍스트에 대한 심층 분석</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="외부 라이브러리 없이 React에서 간단한 드래그 앤 드롭하기" href="/post/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="외부 라이브러리 없이 React에서 간단한 드래그 앤 드롭하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="외부 라이브러리 없이 React에서 간단한 드래그 앤 드롭하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">외부 라이브러리 없이 React에서 간단한 드래그 앤 드롭하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native에서 기기에서 파일을 업로드하는 방법" href="/post/2024-05-12-HowtoUploadFilesFromDeviceinReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native에서 기기에서 파일을 업로드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtoUploadFilesFromDeviceinReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native에서 기기에서 파일을 업로드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native에서 기기에서 파일을 업로드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="undefined" href="/post/undefined"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="undefined" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/undefined_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="undefined" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">undefined</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요" href="/post/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link posts_-active__YVJEi" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"React 19의 새로운 기능 - 문서 메타데이터","description":"","date":"2024-05-12 21:40","slug":"2024-05-12-NewFeaturesinReact19DocumentMetadata","content":"\n\n🚀 React 19에서 SEO 및 접근성 향상하기 🌟\n\n![React 19 새로운 기능 문서 메타데이터](/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png)\n\n안녕하세요, 개발자 여러분! 웹 개발에서 매우 중요한 주제를 이야기해보려고 해요: SEO 최적화와 접근성 보장하기입니다. \"제목,\" \"메타 태그,\" \"설명\"과 같은 요소들은 이러한 목표를 달성하는 데 중요한 역할을 합니다. 그러나 React에서는 특히 싱글 페이지 애플리케이션에서 이러한 요소들을 관리하는 것이 조금 어려울 수 있어요.\n\nReact SEO 최적화에서의 어려움:\n\n\n\n요즘 개발자들은 자체 코드를 작성하거나 리액트 헬멧과 같은 패키지를 활용하여 경로 변경을 처리하고 메타 데이터를 업데이트하는 일에 자주 마주합니다. 그러나 이 과정은 메타 태그와 같은 SEO에 민감한 요소들을 다룰 때 반복적이고 오류를 범하기 쉽습니다.\n\n리액트 19 이전:\n\n이전에, 개발자들은 이러한 요소를 업데이트하기 위해 자체 코드를 작성해야 했습니다. 예를 들어, 다음 코드 조각을 살펴보세요:\n\n```js\nimport React, { useEffect } from 'react';\n\nconst HeadDocument = ({ title }) =\u003e {\n  useEffect(() =\u003e {\n    document.title = title;\n\n    const metaDescriptionTag = document.querySelector('meta[name=\"description\"]');\n    if (metaDescriptionTag) {\n      metaDescriptionTag.setAttribute('content', '새로운 설명');\n    }\n  }, [title]);\n\n  return null;\n};\n\nexport default HeadDocument;\n```\n\n\n\n위의 코드에서는 프롭에 따라 제목과 메타 태그를 업데이트하는 HeadDocument 컴포넌트가 있습니다. 우리는 이를 useEffect 훅에서 업데이트합니다. 또한 JavaScript를 사용하여 제목과 메타 태그를 업데이트합니다. 이 컴포넌트는 경로 변경시 업데이트됩니다. 이는 이 작업을 수행하는 깔끔한 방법은 아닙니다.\n\n이 접근 방식으로는 작동하지만 React에서 SEO 요소를 관리하는 가장 깔끔한 방법은 아닙니다.\n\nReact 19부터:\n\nReact 19에서는 SEO 요소를 관리하는 것이 훨씬 간단하고 직관적으로 되었습니다. 이제 React 컴포넌트에서 직접 제목과 메타 태그를 사용할 수 있습니다. 아래와 같이요:\n\n\n\n```js\nconst HomePage = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003ctitle\u003eFreecodecamp\u003c/title\u003e\n      \u003cmeta name=\"description\" content=\"Freecode camp blogs\" /\u003e\n      {/* 페이지 콘텐츠 */}\n    \u003c/\u003e\n  );\n}\n```\n\nReact 19 이전에는 React 컴포넌트에서 SEO 요소를 직접 사용할 수 없었습니다. 이제 React 19부터는 react-helmet과 같은 외부 패키지에 의존하지 않고 React 애플리케이션의 SEO 요소를 쉽게 관리할 수 있게 되었습니다.\n\n결론:\n\nReact 19의 개선된 기능을 통해 컴포넌트 내에서 SEO 요소를 직접 관리할 수 있게 되어 React 애플리케이션의 SEO 최적화와 접근성 향상을 더욱 간편하게 할 수 있습니다. 더 많은 업데이트를 기대해 주시고 즐거운 코딩되세요! 👩‍💻👨‍💻\n```\n\n\n\n관련 링크:\n\n- React 19의 새로운 기능\n\n- React 19의 새로운 기능 — React 컴파일러\n\n- React 19의 새로운 기능 — 서버 컴포넌트\n\n\n\nReact 19의 새로운 기능들 — 액션\n\nReact 19의 새로운 기능들 — 웹 컴포넌트\n\nReact 19의 새로운 기능들 — 자산 로딩\n\nReact 19의 새로운 기능들 — 새로운 React Hooks","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19DocumentMetadata_0.png","tag":["Tech"],"readingTime":3},{"title":"무료 오픈 소스 ReactJS 템플릿 10가지 공유","description":"","date":"2024-05-12 21:38","slug":"2024-05-12-10FreeOpenSourceReactJSTemplates","content":"\n이 글에서는 신중하게 선택된 10가지 무료 오픈 소스 ReactJS 템플릿을 소개합니다.\n\n- Atomize\n- Open\n- MUI 대시보드\n- MatX\n- Star Admin\n- React 이력서 템플릿 v2\n- 현대적인 React 포트폴리오 템플릿\n- Soumya-jit 포트폴리오\n- React vscode 포트폴리오\n- Gitprofile\n\n# 1. Atomize\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png)\n\nAtomize React는 귀하의 스타일과 일치하는 완전히 반응 형 웹 사이트 및 제품을 구축하는 데 도와줍니다.\n\nGitHub에서 1.5k개의 스타를 받았어요\n\n## 특징\n\n- 웹 앱용 UI 디자인 시스템\n- 우아하고 아름다운 React 구성 요소\n- 테마 설정을 위한 미리 정의된 색상\n- 각 구성 요소에 대한 자세한 설명서\n\n## 링크\n\n## 라이브 데모\n\n# 2. 오픈\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_1.png)\n\nMarkdown 형식의 요소로 변경해 보겠습니다:\n\n**Open**은 GitHub에서 2.4k개의 별을 받았어요.\n\n## 기능\n\n- 완전히 반응형 디자인\n- 쉽게 사용자 정의 가능\n- Google Fonts\n- 레티나 대응\n- 특별 제작 일러스트 및 Nucleo 앱(아이코노그래피)\n- 스크롤 리벨 애니메이션\n\n## 링크\n\n## 실시간 데모\n\n# 3. MUI 대시보드\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_2.png)\n\n태스크바와 미니 변형 그림이 있는 간단한 대시보드입니다. 차트는 Recharts에서 제공되지만 다른 대안으로 쉽게 대체할 수 있습니다.\n\nMUI는 GitHub에서 83,000개의 스타를 받았어요\n\n## 특징\n\n- Material UI 구성 요소 및 요소\n- 대시보드 및 분석 뷰\n- Recharts, 구성 가능한 차트 라이브러리\n\n## 링크\n\n## 라이브 데모\n\n# 4. MatX\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_3.png)\n\nMatX는 놀라운 무료 React 관리자 템플릿이에요. React, Redux, 그리고 Material UI로 개발되었답니다.\n새로운 웹 애플리케이션을 시작하기 위해 필요한 모든 기능을 구현했어요. 이 무료 React\n관리자 템플릿에는 모든 Material UI 컴포넌트, 폼 요소, 및 검증이 포함되어 있어요. 또한, JWT\n인증, 로그인, 회원가입 페이지, 세로 네비게이션, 레이지 로딩 등이 있답니다.\n게다가, 여러 가능성을 제공하는 다양한 React 컴포넌트 모음이 함께 제공돼요.\n따라서 관리자 패널, 관리 시스템, 프로젝트 관리, CMS, CRM, 웹 및 모바일 애플리케이션 백엔드로 사용할 수 있어요...\n\nMatX는 GitHub에서 778k개의 별을 받았어요.\n\n## 주요 기능\n\n- 대시보드\n- JWT 인증\n- Material UI 컴포넌트\n- 기본 폼\n- 세로 네비게이션\n- 레이지 로딩\n- 코드 분할\n- SASS 통합\n- 로그인\n- 회원가입\n- 구글 맵\n- 드래그 앤 드롭\n- 다중 수준 메뉴\n\n## 링크\n\n## 데모 보기\n\n# 5. Star Admin\n\nStar Admin React은 BootstrapDash의 놀라운 관리자 템플릿 중 하나로, Bootstrap 프레임워크를 기반으로 합니다. 이 템플릿은 섬세하게 디자인되었으며 완벽하게 코딩되었습니다. Star Admin React에는 많은 부트스트랩 구성 요소, UI 요소 및 내장된 샘플 페이지가 포함되어 있어 프로젝트를 손쉽게 시작할 수 있습니다.\n\n템플릿은 매우 맞춤화할 수 있어서 디자인을 변경하여 필요에 맞게 조정하고 독특한 외관을 제공할 수 있습니다. 또한 문서화가 아주 잘 되어 있어 어떤 문제도 없이 시작할 수 있습니다.\n\nStar Admin은 GitHub에서 212개의 스타를 받았어요.\n\n## 기능\n\n- Bootstrap\n- Material Design Icons\n- React\n- Chart.js\n\n## 링크\n\n## 라이브 데모\n\n# 6. React 이력서 템플릿 v2\n\n\u003cimg src=\"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_4.png\" /\u003e\n\n이것은 React 기반의 개인 이력서 웹 사이트 템플릿입니다. Next.js 프레임워크에서 TypeScript로 제작되었으며 Tailwind CSS로 스타일을 지정하고 단일 파일에서 데이터를 가져와 손쉽게 개인 웹 사이트를 만들고 사용자 정의하고 호스팅할 수 있습니다. 게다가 사이트는 모바일에 완벽하게 최적화되어 있으며 서버 측 렌더링되어 빠른로딩과 어떤 기기에서든 깨끗한 UI가 제공됩니다. 자세한 내용은 계속 읽어보세요.\n\nGitHub에서 React 이력서 템플릿은 1.1k개의 스타를 받았습니다.\n\n## 특징\n\n- React와 TypeScript 지원을 완벽히 갖춘 다시 설계된 사이트\n- 쉬운 서버 측 렌더링/정적 생성, 이미지 최적화, API 경로 및 배포를 위해 Next.js 프레임워크에서 구축\n- TailwindCss로 완전한 스타일 적용\n- 사용자 정의를 위해 데이터 모음 파일 재구성\n- 모든 사이트 섹션의 중요한 개선/현대화\n\n## 링크\n\n## 실시간 데모\n\n# 7. 현대적인 React 포트폴리오 템플릿\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_5.png)\n\n최신 Next.js 및 TailwindCSS를 기반으로 한 현대적인 React 포트폴리오 무료 템플릿입니다.\n\nGitHub에서 현대적인 React 포트폴리오 템플릿은 768개의 스타를 받았습니다.\n\n## 특징\n\n- 현대적인 스택 (Next.js + TailwindCSS)\n- 심플한 디자인\n- 쉽게 탐색할 수 있음\n- GUI로 세부 정보를 쉽게 사용자 정의할 수 있음\n- 블로그 CRUD (Create, Read, Update, Delete 블로그를 쉽게 이용할 수 있는 UI로)\n- 다크 모드\n\n## 링크\n\n## 라이브 데모\n\n# 8. Soumya-jit 포트폴리오\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_6.png)\n\n개발자를 위한 인적 포트폴리오 템플릿\n\nSoumya-jit 포트폴리오는 GitHub에서 1.4천개의 스타를 받았어요\n\n## 특징\n\n- 다양한 페이지 레이아웃\n- React-Bootstrap 및 CSS로 스타일이 적용되어 있어 색상을 쉽게 사용자 정의할 수 있어요\n- 완벽하게 반응형입니다\n\n## 링크\n\n## 데모 보기\n\n## 9. React vscode 포트폴리오\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_7.png)\n\n프로젝트는 Visual Studio Code와 caglarturali.github.io에서 영감을 받았어요. 포트폴리오 페이지들은 마크다운으로 구성되어 있어서 쉽게 수정하거나 자신만의 내용을 추가할 수 있어요.\n\nReact vscode Portfolio는 GitHub에서 51개의 스타를 받았어요.\n\n## 특징\n\n- 마크다운을 이용해 구성\n- 다크 모드와 라이트 모드 사용 가능\n- 닫을 수 있는 탭\n- 접을 수 있는 탐색기\n- 반응형 웹 디자인\n- Google Analytics 지원\n- GitHub 액션을 이용하여 자동으로 gh-pages에 배포 가능\n\n## 링크\n\n## 라이브 데모\n\n# 10. Gitprofile\n\n![이미지](/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_8.png)\n\nGitProfile은 GitHub 사용자 이름만 제공하면 포트폴리오 페이지를 자동으로 생성하는 쉬운 포트폴리오 빌더입니다. React.js 위에 Vite를 사용하여 구축되었습니다. 그러나 시작하기에 이들에 대한 지식이 필요하지는 않습니다. 코딩 경험이 전혀 없어도 직접 복사본을 만들 수 있습니다.\n\nGitHub에서 GitProfile은 530개의 스타를 받았어요.\n\n## 주요 기능\n\n- 쉬운 설정\n- 30가지 테마\n- 구글 애널리틱스\n- 핫자르\n- SEO\n- 아바타 및 소개\n- 소셜 링크\n- 기술 섹션\n- 경험 섹션\n- 인증 섹션\n- 교육 섹션\n- 프로젝트 섹션\n- 블로그 게시물 섹션\n\n## 링크\n\n## 실시간 데모\n","ogImage":{"url":"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png"},"coverImage":"/assets/img/2024-05-12-10FreeOpenSourceReactJSTemplates_0.png","tag":["Tech"],"readingTime":5},{"title":"Redux, React Typescript, Electron 및 Vite로 시작하기","description":"","date":"2024-05-12 21:36","slug":"2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite","content":"\n\n![Vite](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png)\n\n안녕하세요\n\nVite는 새 프론트엔드 프로젝트를 빠르게 시작할 수 있는 놀라운 방법입니다. Vanilla JS, Vue, React 등 다양한 템플릿을 지원합니다. 빌드 시간이 빠르고 빠르게 작동하는 개발 서버도 기본 제공됩니다. Vite는 또한 Electron을 사용하여 새 프로젝트를 만드는 것도 지원합니다. Electron은 크로미움 기반의 프레임워크로, HTML, CSS 및 Javascript만을 사용하여 여러 플랫폼용 데스크톱 앱을 빌드하는 데 사용됩니다. Redux는 리액트 프로젝트에서 사용되는 상태 관리 도구 및 라이브러리로, 애플리케이션 전체에서 컴포넌트 주변에 있는 기존 상태를 추적하는 데 사용됩니다. 이 블로그에서는 React, Redux, Typescript 및 Electron을 사용하여 Vite를 사용하여 스타터 프로젝트를 빠르게 설정하는 방법을 살펴볼 것입니다. 이 튜토리얼은 문서에서 Redux를 사용하는 방법을 따릅니다.\n\n설정\n\n\n\n첫 번째로 터미널을 열고 데스크탑이나 프로젝트를 보관하는 폴더 중 하나로 이동해야 해요. 거기서 다음 명령어를 실행할 거예요.\n\n```js\nyarn create vite .\n```\n\n이렇게 하면 현재 디렉토리에 Vite 프로젝트가 생성되고 어떻게 프로젝트를 구성할지 물어볼 거예요.\n\n\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_1.png)\n\n위의 스크린샷에서 프로젝트에 패키지 이름을 지정하고 싶습니다. 이것이 우리 프로젝트의 이름이 될 것입니다. 이름을 비워두지 않고 디렉토리 안에 다른 이름을 지정하면 현재 디렉토리 내에 별도의 폴더 안에 프로젝트가 생성됩니다.\n\nVite 설정 cli에서 다음 단계는 어떤 프레임워크를 사용할지 선택하는 것입니다. Others로 이동하여 Enter 키를 눌러주세요. create-electron-vite를 선택하세요.\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_2.png)\n\n\n\n다시 패키지 이름을 입력하라는 프롬프트가 나타날 것입니다. 이번 단계는 간단하게 Enter 키를 눌러 건너뛰세요. 마지막 단계는 프로젝트 템플릿을 선택하는 것입니다. React를 선택해주세요.\n\n![이미지](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_3.png)\n\n이렇게 하면 src, electron 및 public 폴더가 포함된 Vite 프로젝트가 Electron, Typescript 및 React를 사용하여 생성되며, Typescript, Vite 및 Electron용 구성 파일도 함께 제공됩니다.\n\n```js\n.\n├── electron\n│   ├── electron-env.d.ts\n│   ├── main.ts\n│   └── preload.ts\n├── electron-builder.json5\n├── index.html\n├── package.json\n├── public\n│   ├── electron-vite.animate.svg\n│   ├── electron-vite.svg\n│   └── vite.svg\n├── src\n│   ├── App.css\n│   ├── App.tsx\n│   ├── assets\n│   │   └── react.svg\n│   ├── index.css\n│   ├── main.tsx\n│   └── vite-env.d.ts\n├── tsconfig.json\n├── tsconfig.node.json\n└── vite.config.ts\n```\n\n\n\n위의 표를 마크다운 형식으로 변경하세요.\n\n\n공정하고 깔끔하게 나왔습니다. 위의 표를 마크다운 형식으로 변경하겠습니다.\n\n\n\n전주가전격 스타터 앱을 띄울 새 창이 열립니다. 앱에는 데모 카운터가 포함되어 있습니다.\n\n![Getting Started with Redux React TypeScript Electron using Vite](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_4.png)\n\n기존 프로젝트에 Redux 통합하기\n\nRedux의 시작 가이드에 따르면 Redux 프로젝트를 시작할 때 Vite의 공식 템플릿을 사용하는 것이 최선의 방법입니다. 그러나 우리의 기존 일렉트론 프로젝트에 Redux를 통합하는 것은 간단합니다. 다음 종속성을 프로젝트에 설치해야 합니다.\n\n\n\n```js\nyarn add @reduxjs/toolkit  \nyarn add react-redux                        \nyarn add redux\n```\n\n위 명령을 실행하면 redux의 기본 기능, react에 대한 바인딩 및 redux toolkit을 위한 필수 종속성이 설치됩니다. 이러한 패키지를 설치한 후에는 첫 번째 Redux 스토어를 생성할 수 있습니다.\n\n첫 번째 Redux 스토어 생성하기\n\nRedux 스토어를 생성하기 전에 slice를 정의해야 합니다. slice는 Redux 스토어의 독립된 모듈입니다. 프로젝트의 src 폴더로 이동하여 slices라는 폴더를 만듭니다. 이 폴더는 redux 스토어의 독립된 모듈 또는 slice를 보관할 것입니다. 나중에 이를 redux 스토어에 삽입할 것입니다.\n```\n\n\n\n![GettingStartedWithReduxReactTypescriptElectronusingVite_5](/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_5.png)\n\n다음 코드를 `counterSlice.ts` 파일에 추가하세요.\n\n```js\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\"\n\nexport type CounterState = {\n   value: number\n}\n\nconst initialState: CounterState = {\n   value: 0\n}\n\nconst counterSlice = createSlice({\n   name: 'counter',\n   initialState: initialState,\n   reducers: {\n      increment: (state) =\u003e {\n         state.value += 1\n      },\n      decrement: (state) =\u003e {\n         state.value -= 1\n      },\n      incrementByValue: (state, action: PayloadAction\u003cnumber\u003e) =\u003e{\n         state.value = action.payload\n      }\n   }\n})\n\nexport const { increment, decrement, incrementByValue } = counterSlice.actions\nexport default counterSlice.reducer\n```\n\n코드를 분석해 봅시다.\n\n\n\n```js\nexport type CounterState = {\n   value: number\n}\n```\n\n친구야, 저희는 카운터 상태에 대한 유형을 만들었어요. 여기서 카운트에 대한 유형은 숫자입니다.\n\n```js\nconst initialState: CounterState = {\n   value: 0\n}\n```\n\n여기서 count의 초기 상태를 CounterState 유형으로 정의한 초기 상태입니다. 초기 상태는 slice를 정의할 때 전달되는 매개변수 중 하나에요.\n\n\n\n```js\nconst counterSlice = createSlice({\n   name: 'counter',\n   initialState: initialState,\n   reducers: {\n      increment: (state) =\u003e {\n         state.value += 1\n      },\n      decrement: (state) =\u003e {\n         state.value -= 1\n      },\n      incrementByValue: (state, action: PayloadAction\u003cnumber\u003e) =\u003e{\n         state.value = action.payload\n      }\n   }\n})\n```\n\n우리는 createSlice()를 사용하여 슬라이스가 생성되고 저장되는 상수를 정의합니다. createSlice()는 자체 포함 모듈 또는 redux 스토어의 슬라이스를 만들 수 있게 하는 redux 함수입니다. 이 슬라이스는 생성된 액션 유형을 이름 공간화하기 위해 사용되는 슬라이스의 이름, 상태 값을 초기화하는 초기 상태 및 리듀서 함수 또는 상태 조작을 허용하는 액션을 유지합니다.\n\n첫 번째 슬라이스를 정의한 후에는 이 슬라이스를 보유하는 store를 생성합니다. 이를 프로젝트에서 만들어 봅시다. src 폴더 안에 stores라는 새 폴더를 만들어주세요. 그 안에 store.ts라는 새 파일을 만드세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_6.png\" /\u003e\n```\n\n\n\nstore.ts 파일에 다음 코드를 추가하겠습니다.\n\n```js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"../slices/counterSlice\";\n\nexport const store = configureStore({\n   reducer: {\n      counter: counterReducer\n   }\n})\n\nexport type RootState = ReturnType\u003ctypeof store.getState\u003e\nexport type AppDispatch = typeof store.dispatch\n```\n\n각 코드 조각을 자세히 살펴보겠습니다.\n\n```js\nexport const store = configureStore({\n   reducer: {\n      counter: counterReducer\n   }\n})\n```\n\n\n\n`configureStore()`은 React 앱 전반에서 참조할 수 있는 store를 구축하는 데 사용되는 또 다른 Redux 함수입니다. 이 store는 생성된 모든 slice의 저장소 역할을 합니다. 안에는 우리가 이전에 counterSlice.ts 파일에서 내보낸 counterReducer를 저장합니다. 나중에는 루트 컴포넌트에서 provider 태그를 통해 우리의 store를 주입할 것입니다.\n\n```js\nexport type RootState = ReturnType\u003ctypeof store.getState\u003e\nexport type AppDispatch = typeof store.dispatch\n```\n\nRedux 문서에 따르면 redux toolkit은 추가적인 typings가 필요 없지만, 우리가 필요할 때 참조할 수 있도록 RootState와 AppDispatch를 추출해야 합니다. 우리의 store가 커지고 더 많은 slice가 추가될수록, 이러한 유형을 추론하는 것은 이들이 정확히 업데이트되도록 하기 위함입니다.\n\n또한 Redux 문서는 TypeScript와 작업할 때 useDispatch()와 useSelector()에 대한 사용자 정의 타입된 훅을 정의하는 것이 최선의 실천 방법임을 강조합니다. 이러한 함수들은 컴포넌트에서 상태 값을 청취하고 상태 값을 업데이트하는 데 사용될 것이며, 이렇게 함으로써 값이 업데이트 될 때 store 내에서 업데이트된 내용이 반영되도록 합니다. 각 훅이 하는 일에 대한 간단한 개요는 다음과 같습니다.\n```\n\n\n\n`useSelector()`은 리덕스 스토어에서 값을 가져오고 구독할 수 있게 해주는 훅 함수입니다. 해당 값에 구독된 모든 컴포넌트는 그 값을 현재 값과 업데이트된 변경 사항을 반영합니다.\n\n`useDispatch()`는 사용자가 스토어의 값을 변경할 이벤트를 트리거할 수 있게 해주는 훅 함수입니다. useSelector()를 통해 스토어의 값을 참조하는 모든 컴포넌트도 마찬가지로 그 값이 업데이트됩니다.\n\nsrc 폴더 안에 우리의 훅을 위한 폴더를 만들고 storeHooks.ts 파일을 생성합니다. 이 파일은 useDispatch()와 useSelector()를 위한 사용자 정의 훅을 보유할 것입니다.\n\n타입스크립트와 리덕스를 통합하는 자세한 방법은 Redux 문서의 타입스크립트 퀵 스타트 가이드를 참조해주세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_7.png\" /\u003e\n\n```js\nimport { AppDispatch, RootState } from './../stores/store';\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\n\nexport const useAppDispatch: () =\u003e AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook\u003cRootState\u003e = useSelector\n```\n\n마지막으로, 컴포넌트들이 스토어에 액세스할 수 있도록 하려면, Provider 태그 내에서 스토어를 주입해야 합니다. Provider에 등록된 모든 컴포넌트는 스토어 내의 값을 액세스하고 수정할 수 있습니다.\n\n```js\nReactDOM.createRoot(document.getElementById('root')!).render(\n  \u003cReact.StrictMode\u003e\n    \u003cProvider store={store}\u003e \n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  \u003c/React.StrictMode\u003e,\n)\n```\n\n\n\n# Counter 컴포넌트 생성하기\n\n이제 우리가 스토어, 슬라이스를 정의하고 스토어를 프로바이더에 주입했으니, 카운터 컴포넌트를 생성할 시간입니다.\n\nsrc로 이동하여 Counter.tsx 컴포넌트를 생성하세요.\n\n```js\nimport { useAppDispatch } from \"./hooks/storeHooks\";\nimport { increment, decrement } from \"./slices/counterSlice\";\nimport { Row, Col, Button } from \"antd\";\n\nexport default function Counter() {\n  const dispatch = useAppDispatch();\n\n  function incrementCounter() {\n    dispatch(increment());\n  }\n\n  function decrementCounter() {\n    dispatch(decrement());\n  }\n\n  return (\n    \u003c\u003e\n      \u003cRow\u003e\n        \u003cCol\u003e\n          \u003cButton type=\"primary\" onClick={incrementCounter}\u003e\n            Increment +\n          \u003c/Button\u003e\n        \u003c/Col\u003e\n        \u003cCol\u003e\n          \u003cButton type=\"primary\" onClick={decrementCounter}\u003e\n            Decrement -\n          \u003c/Button\u003e\n        \u003c/Col\u003e\n      \u003c/Row\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n\n\n이 컴포넌트에서는 incrementCounter 및 decrementCounter 함수를 사용하여 카운터를 증가 및 감소시키는 컴포넌트를 만듭니다.\n\nuseAppDispatch() 훅을 사용하여 사용자 지정 형식의 디스패치 함수를 저장합니다. 이 함수는 구독 중인 컴포넌트가 변경 사항을 이에 따라 수정할 수 있도록 저장소의 값 변경을 담당합니다. incrementCounter 및 decrementCounter는 모두 전달된 슬라이스의 리듀서 함수를 사용하여 디스패치를 호출합니다. UI 컴포넌트로 ANTD를 사용하고 있지만 React용 다른 UI 라이브러리에서도 작동합니다.\n\nANTD 라이브러리를 더 알아보고 싶다면 문서를 확인해보세요. ANTD를 프로젝트에 통합하는 것은 간단하며, 라이브러리는 Vue.js 및 Angular에도 제공됩니다.\n\n이제 카운트를 수정하는 컴포넌트를 정의했으므로 App.tsx로 이동하여 Vite 프로젝트를 처음 설정할 때 생성된 코드를 제거하는 시간입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_8.png\" /\u003e\n\n우리가 useSelector()에 대한 사용자 정의된 타입된 후크를 호출할 때, Typescript는 우리가 counter를 위한 상태를 생성했다는 것을 감지하고 initialState에서 정의된 값의 자동완성을 제공합니다. 이는 redux 스토어로부터 상태 구조를 추론하여 유형 안전성을 제공할 수 있습니다. 이것이 Typescript와 함께 redux를 사용하는 아름다움입니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_9.png\" /\u003e\n\n여기가 최종 코드 조각입니다.\n\n\n\n```js\nimport { useAppSelector } from \"./hooks/storeHooks\"\nimport Counter from \"./Counter\";\nimport { useAppSelector } from \"./hooks/storeHooks\";\nimport { Row, Col } from \"antd\";\n\nfunction App() {\n  const count = useAppSelector((state) =\u003e state.counter.value);\n  return (\n    \u003cRow justify={'center'}\u003e\n      \u003cCol\u003e\n        \u003cRow justify={\"center\"}\u003e\n          \u003cCol\u003e\n            \u003ch1\u003e카운트는 {count} 입니다. \u003c/h1\u003e\n          \u003c/Col\u003e\n        \u003c/Row\u003e\n        \u003cRow justify={\"center\"}\u003e\n          \u003cCol\u003e\n            \u003cCounter /\u003e\n          \u003c/Col\u003e\n        \u003c/Row\u003e\n      \u003c/Col\u003e\n    \u003c/Row\u003e\n  );\n}\n\nexport default App;\n```\n\n터미널에서 다시 yarn dev를 실행하면 아래와 같은 결과를 얻을 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_10.png\" /\u003e\n\n결론\n\n\n\n축하합니다! React, Vite, Typescript 및 Redux를 사용하여 기본 전자 앱을 만들었습니다. 우리는 카운터의 초기 상태를 보유하는 slice를 작성했고, 카운터를 증가 및 감소시키는 reducer 함수를 만들었습니다. 또한 store를 생성하여 모든 slice를 보관하고, store 내의 값을 조작하는 기본 컴포넌트를 생성했고 App.tsx 컴포넌트에서 store 내의 값에 구독했습니다. 이는 Redux를 사용한 기본 사용 사례이며, Redux를 실제 프로젝트에 적용하는 다른 예시로는 인증 상태 구독, 다크 모드 설정, 사용자 데이터 변경을 감시하는 것 등이 있습니다.\n\nElectron, Vite 및 Redux에 대해 더 자세히 알아보려면 다음 문서 링크를 확인해보세요.\n\n- Redux — https://redux.js.org/\n- Vite — https://vitejs.dev/\n- Electron — https://www.electronjs.org/","ogImage":{"url":"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png"},"coverImage":"/assets/img/2024-05-12-GettingStartedWithReduxReactTypescriptElectronusingVite_0.png","tag":["Tech"],"readingTime":11},{"title":"Microsoft Authentication Library MSAL을 사용한 인증","description":"","date":"2024-05-12 21:34","slug":"2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL","content":"\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png\" /\u003e\n\n# 소개:\n\n인증 및 안전한 액세스 제공은 모든 웹 애플리케이션의 중요한 부분입니다. 우리는 직접 구축하거나 Microsoft 인증 라이브러리(MSAL)와 같은 타사 서비스를 사용할 수 있습니다. 이렇게 함으로써 개발 작업과 리소스를 절약할 뿐만 아니라 신뢰할 수 있고 효율적이며 검증된 솔루션을 제공받을 수 있습니다. MSAL은 웹 애플리케이션이나 Rest API에 안전한 액세스를 제공합니다. JavaScript, Java, Python과 같은 다양한 응용 프로그램 아키텍처 및 플랫폼을 지원합니다. 구성 파일 및 일부 코드를 사용하여 MSAL을 통합할 수 있기 때문에 OAuth 라이브러리를 사용할 필요가 없습니다. 애플리케이션은 Microsoft 개인 계정이나 클라우드에 설정된 사용자로 로그인할 수 있습니다. Microsoft의 데이터 보안 및 확장성에 대한 신뢰성이 추가로 제공됩니다.\n\n그러니 바로 시작하여 구현에 필요한 단계를 살펴보겠습니다. 이는 다음과 같습니다.\n\n- Microsoft Azure 플랫폼에 애플리케이션 등록\n- Auth 구성 파일 구성\n- 애플리케이션에 MSAL 코드 추가\n- 로그인 구성 요소 추가\n- 애플리케이션에 로그인 통합\n- 보호된 Rest API에 액세스\n\n# 1. Microsoft Azure 플랫폼에 애플리케이션 등록\n\n먼저, Azure 구독 또는 무료 Azure 계정이 필요합니다. 계정에는 애플리케이션을 등록할 수 있는 권한이 있어야 합니다. 홈페이지에서 Microsoft Entra ID 서비스를 선택할 수 있습니다. 여기서 계정의 테넌트 ID를 볼 수 있고 새로운 앱 등록을 추가할 수 있습니다.\n\n![Microsoft Azure Platform](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_1.png)\n\n![이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_2.png)\n\n인증 구성 파일을 설정하는 동안 테넌트 ID가 필요합니다.\n\n애플리케이션 이름 및 리디렉션 URI를 입력할 수 있습니다. 리디렉션 URI는 성공적인 인증 이후 MSAL이 리디렉션해야 하는 애플리케이션의 홈페이지 또는 페이지입니다.\n\n![이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_3.png)\n\n[Register] 버튼을 클릭하면 애플리케이션에 대한 Application Id를 받을 수 있습니다.\n\n![image](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_4.png)\n\n이제 테넌트 Id와 Application Id가 있으므로 Auth 구성 파일을 만들어 나아갈 수 있습니다.\n\n# 2. Auth 구성 파일\n\nsrc 폴더 안에 애플리케이션에 필요한 authConfig 파일을 추가할 수 있습니다. 이 파일에는 Msal 인스턴스 생성 시 전달될 구성이 포함되어 있습니다. 일반적인 authConfig 파일은 아래와 같이 나타날 것입니다.\n\n```js\n// Code snippet 1 – src/authConfig.js\nexport const msalConfig = {\n  auth: {\n    clientId: \"어플리케이션 ID\",\n    authority: \"https://login.microsoftonline.com/테넌트 ID\",\n    redirectUri: \"https://dev-example-app.com/\",\n  },\n  cache: {\n    cacheLocation: \"sessionStorage\", // 캐시가 저장될 위치를 구성합니다.\n    storeAuthStateInCookie: false, // IE11이나 Edge에서 문제가 있는 경우 \"true\"로 설정하세요.\n  },\n};\n/** 여기에 추가한 스코프는 사용자 로그인 시 동의를 받습니다.\n * 기본적으로 MSAL.js는 OIDC 스코프 (openid, profile, email)를 로그인 요청에 추가합니다.\n */\nexport const loginRequest = {\n  scopes: [\"User.Read\"],\n};\n```\n\n# 3. 애플리케이션에 MSAL 코드 추가\n\n@azure/msal-browser와 @azure/msal-react 패키지를 설치해야 합니다.\n\n```js\n// 코드 조각 2 - 터미널\nnpm i @azure/msal-browser @azure/msal-react\n```\n\n애플리케이션 진입점에서 PublicClientApplication 객체를 초기화하고 애플리케이션을 MsalProvider 컴포넌트로 감쌉니다.\n\n```js\n// 코드 조각 3 - src/index.js\nimport ReactDOM from \"react-dom/client\";\nimport { PublicClientApplication } from \"@azure/msal-browser\";\nimport { MsalProvider } from \"@azure/msal-react\";\nimport { msalConfig } from \"./authConfig\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nroot.render(\n  \u003cMsalProvider instance={msalInstance}\u003e\n    \u003cApp /\u003e\n  \u003c/MsalProvider\u003e\n);\n```\n\n# 4. 로그인 컴포넌트\n\n```\n\n\n\n여기에서는 authConfig 파일로부터 loginRequest를 가져 와서 Msal 인스턴스에 제공해야합니다. 페이지 또는 팝업으로 로그인을 추가할지에 따라 loginRedirect 또는 loginPopup 함수를 사용할 수 있습니다.\n\n```js\n// 코드 스니펫 4 - src/components/SignIn.js\nimport { useMsal } from '@azure/msal-react';\nimport { loginRequest } from '../../authConfig';\nconst SignIn = () =\u003e {\n  const { instance } = useMsal();\n  const handleLogin = () =\u003e {\n    instance.loginRedirect(loginRequest).catch((e) =\u003e {\n       console.log(e);\n  };\n  return (\n    \u003cSignInContainer\u003e\n      \u003cSignInPageComponents /\u003e\n      \u003cSignInButton onClick={() =\u003e handleLogin()}\u003e\n         Microsoft 계정으로 로그인\n      \u003c/SignInButton\u003e\n    \u003c/SignInContainer\u003e\n  );\n}\nexport default SignIn;\n```\n\n만약 로그인이 팝업으로 되는 경우, Msal 인스턴스는 loginPopup 함수를 사용합니다.\n\n```js\n// 코드 스니펫 5 - src/components/SignIn.js\ninstance.loginPopup(loginRequest).catch((e) =\u003e {\n  console.log(e);\n});\n```\n\n비슷하게, Sign-Out은 logoutRedirect 또는 logoutPopup 함수로 처리할 수 있습니다.\n\n```js\n// 코드 스니펫 6 - src/components/SignOut.js\ninstance.logoutRedirect({\n  postLogoutRedirectUri: \"/\",\n});\n```\n\n```js\n// 코드 스니펫 7 - src/components/SignOut.js\ninstance.logoutPopup({\n  postLogoutRedirectUri: \"/\",\n  mainWindowRedirectUri: \"/\",\n});\n```\n\n# 5. 애플리케이션과 Sign-In 페이지 통합하기\n\nSign-In 버튼을 클릭한 후에 MSAL이 사용자를 인증합니다. 애플리케이션은 useIsAuthenticated 함수를 사용하여 인증이 성공했는지 확인할 수 있습니다. 또한, useMsal 함수는 instance, inProgress, accounts 세 개의 객체를 반환합니다. accounts 객체에는 인증된 사용자의 세부 정보가 포함되어 있습니다.\n\n```js\n// 코드 스니펫 8 - src/App.js\nimport { useMsal, useIsAuthenticated } from \"@azure/msal-react\";\nimport Header from \"./components/header\";\nimport SignIn from \"./components/signin\";\nimport Home from \"./pages/home\";\n\nconst App = () =\u003e {\n  const isAuthenticated = useIsAuthenticated();\n  const { accounts } = useMsal();\n  useEffect(() =\u003e {\n    if (accounts.length \u003e 0) {\n      sessionStorage.setItem(\n        \"user-details\",\n        JSON.stringify({\n          name: accounts.length \u003e 0 \u0026\u0026 accounts[0].name,\n          email: accounts.length \u003e 0 \u0026\u0026 accounts[0].username,\n        })\n      );\n    }\n  }, [accounts]);\n  return (\n    \u003cdiv\u003e\n      {isAuthenticated ? (\n        \u003c\u003e\n          \u003cHeader name={accounts.length \u003e 0 \u0026\u0026 accounts[0].name} email={accounts.length \u003e 0 \u0026\u0026 accounts[0].username} /\u003e\n          \u003cHome /\u003e\n        \u003c/\u003e\n      ) : (\n        \u003cSignIn /\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\nexport default App;\n```\n\n이 작업을 수행하는 다른 방법이 있습니다. useIsAuthenticated 함수 대신 AuthenticatedTemplate 및 UnauthenticatedTemplate 컴포넌트를 사용할 수도 있습니다. AuthenticatedTemplate으로 둘러싸인 컴포넌트는 인증이 성공한 경우에만 렌더링됩니다.\n\n```js\n// 코드 스니펫 9 - src/App.js\n\nimport { useMsal, AuthenticatedTemplate, UnauthenticatedTemplate } from '@azure/msal-react';\n. . . . (이전 코드와 같음)\nreturn (\n    \u003cdiv\u003e\n      \u003cAuthenticatedTemplate\u003e\n          \u003cHeader\n             name={accounts.length \u003e 0 \u0026\u0026 accounts[0].name}\n             email={accounts.length \u003e 0 \u0026\u0026 accounts[0].username}\n          /\u003e\n          \u003cHome /\u003e\n      \u003c/AuthenticatedTemplate\u003e\n      \u003cUnauthenticatedTemplate\u003e\n          \u003cSignIn /\u003e\n      \u003c/UnauthenticatedTemplate\u003e\n    \u003c/div\u003e\n);\n```\n\n또한 인증 중에 로더를 표시하는 inProgress를 사용할 수도 있습니다.\n\n```js\n// 코드 스니펫 10 - src/components/AnyComponent.js\n\nconst { inProgress } = useMsal();\nreturn inProgress ? \u003cLoader /\u003e : \u003cComponent /\u003e;\n```\n\n다음 이미지는 애플리케이션의 실행을 보여줍니다.\n\n![애플리케이션 실행 이미지](/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_5.png)\n\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_6.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_7.png\" /\u003e\n\n# 6. Accessing protected Rest APIs\n\n응용 프로그램은 acquireToken 메소드 중 하나를 사용하여 보호된 Rest API에도 액세스할 수 있습니다.\n\n```js\n// Code snippet 11  - src/components/AnyComponent.js\nimport { InteractionRequiredAuthError, InteractionStatus} from \"@azure/msal-browser\";\nimport { useMsal } from \"@azure/msal-react\";\nconst AnyComponent = () =\u003e {\n  const { instance, inProgress, accounts } = useMsal();\n  useEffect(() =\u003e {\n    const accessTokenRequest = {\n      scopes: [\"user.read\"],\n      account: accounts[0],\n    };\n    if (!apiData \u0026\u0026 inProgress === InteractionStatus.None) {\n      instance\n        .acquireTokenSilent(accessTokenRequest)\n        .then((accessTokenResponse) =\u003e {\n          let accessToken = accessTokenResponse.accessToken;\n          callApi(accessToken).then((response) =\u003e {\n            // process the response data\n          });\n        })\n        .catch((error) =\u003e {\n          if (error instanceof InteractionRequiredAuthError) {\n            instance.acquireTokenRedirect(accessTokenRequest);\n            // OR  instance.acquireTokenPopup(accessTokenRequest)\n          }\n        });\n    }\n  }, [instance, accounts, inProgress]);\n  return (...)\n}\nexport default AnyComponent;\n```\n\nAPI 엔드포인트는 액세스 토큰을 Bearer Token으로 전달하여 호출됩니다.\n\n```js\n// Code snippet 12\nconst callApi = async (accessToken) =\u003e {\n  try {\n    return await axios.method(endPoint, {\n      headers: { Authorization: `Bearer ${accessToken }` });\n  } catch (error) {\n    return error.response;\n  }\n};\n```\n\n# 결론\n\n```\n\n\n\n이 기사에서는 응용 프로그램을 등록하고 구성 파일을 만들고 로그인 및 로그아웃을 구현하고 응용 프로그램과 통합하는 다양한 방법을 살펴보았습니다. 추가적으로 MSAL을 사용하여 보호된 API에 액세스할 수도 있습니다. 조직에 새 직원이 합류하는 시나리오를 고려해 보겠습니다. 새 직원은 마이크로소프트 계정만 만들면 되고, 이를 통해 Outlook 및 조직의 내부 응용 프로그램에 액세스할 수 있습니다. 따라서 로그인하면 기술 지원 티켓을 작성하거나 타임시트를 기록하거나 프로젝트 세부 정보를 보거나 이메일을 보낼 수 있습니다. 또한, 관리 및 사용자 모니터링 관점에서 사용자를 관리하는 것이 더 쉬워집니다.\n\n이 기사가 유익하게 느껴졌고 필요에 따라 프로젝트에 활용할 수 있기를 바랍니다. 읽어 주셔서 감사합니다!\n\nEdstem 웹사이트에서 더 많은 통찰력 있는 블로그와 실용적인 안내서를 살펴보세요. 저희 팀은 복잡한 응용 프로그램 개발을 전문으로 하는 젊고 뛰어난 열정적인 소프트웨어 엔지니어로 구성되어 있습니다. Agile 소프트웨어 개발, 고급 DevOps 실천법, 인공지능 기능을 활용하여 소프트웨어 프로젝트를 가속화하고 혁신적인 솔루션을 제공합니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png"},"coverImage":"/assets/img/2024-05-12-AuthenticationUsingMicrosoftAuthenticationLibraryMSAL_0.png","tag":["Tech"],"readingTime":9},{"title":"TanStack Router는 SPA 개발을 위한 가장 강력한 옵션 중 하나입니다, TanStack Query","description":"","date":"2024-05-12 21:31","slug":"2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery","content":"\n\n![이미지](/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png)\n\nReact에서 라우팅과 데이터 가져오기는 특히 중요한 역할을 합니다.\n\n물론 Next.js나 Remix와 같은 프레임워크를 채택하면 프레임워크에서 제공하는 API를 사용하여 라우팅부터 데이터 가져오기까지 모든 것을 구현할 수 있습니다.\n\n그러나 BtoB 서비스의 경우 SPA만으로 충분하며, Next.js와 같은 프레임워크를 채택하는 것은 불필요하게 과분할 수 있습니다.\n\n\n\n우리가 원하는 것은 안전한 유형의 파일 기반 라우팅과 효율적인 데이터 가져오기입니다.\n\n본 문서는 2024년 2월 기준으로, TanStack Router가 기술 선택에서 SPA용 라우팅 라이브러리로 매우 강력한 옵션이라는 것을 소개합니다.\n\n# 소개\n\n본 문서에서는 TanStack Router 및 TanStack Query가 기능과 실제 설계 구조 예제에 기반하여 SPA 애플리케이션에 대한 최적의 해결책 중 하나가 될 수 있는 방법에 대해 논의할 것입니다.\n\n\n\nTanStack Router은 SSR (서버 측 렌더링) 기능을 제공하지만, 이 대화에서는 특히 SPA에 적용된 부분에 초점을 맞출 것입니다.\n\n## 대상\n\n- React와 함께 SPA를 위한 기술 선택을 고려 중인 개발자\n- 안전한 유형의 개발 경험을 찾는 개발자\n- Next.js와 같은 프레임워크 도입이 너무 많다고 느끼는 개발자\n- React + Vite와 호환되는 라이브러리를 찾고 있는 개발자\n\n# TanStack Router 소개\n\n\n\nTanStack Router는 2023년 크리스마스에 버전 1.0으로 출시된 비교적 새로운 라이브러리입니다. 이 트윗에 게시된 비디오에서는 그 기능을 쉽게 이해할 수 있도록 설명하고 있으니 한번 보세요.\n\n# 타입 안전 및 간편한 라우팅\n\nTanStack Router의 주요 기능 중 하나는 타입 안전성입니다. `Link /` 또는 useNavigate를 사용하여 탐색할 때 코드 완성을 제공합니다. 경로뿐만 아니라 경로 매개변수와 검색 매개변수를 타입 안전하게 처리할 수 있어 매우 강력합니다.\n\n게다가 API는 매우 간단하고 이해하기 쉽습니다. 이것이 높은 품질의 개발 경험을 제공한다고 느낄 수 있는 이유 중 하나입니다.\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*JdXNcU_oldH_BlIQhZeNPQ.gif)\n\n# 파일 기반 라우트 생성\n\n저는 TanStack Router의 파일 기반 라우팅 및 자동 생성 기능을 특히 좋아합니다. 이는 파일을 통해 라우팅을 정의할 수 있으며, Next.js나 Remix의 App Router와 유사하게 라우팅이 자동으로 생성됩니다. 이는 코드베이스에 라우팅을 구현할 필요가 없다는 것을 의미합니다.\n\n물론 코드를 기반으로 라우팅을 구현하는 것도 가능하지만, 공식 권장사항은 파일 기반 라우팅을 하는 것입니다.\n\n\n\n참고: 이 문서는 폴더 경로 방식 라우팅을 소개합니다. 플랫 라우트가 아닙니다.\n\n```js\n__root.tsx // 루트 파일은 모든 라우트에 적용됩니다.\nposts/\n  route.tsx // `/posts`\n  $postId/\n    route.tsx // `/posts/$postId\r\n```\n\n위와 같은 디렉토리 구조를 가지고 있을 때, /posts 및 /posts/$postId의 라우트가 생성됩니다. 또한 TanStack Router는 고유한 파일 정의를 갖고 있기 때문에 특히 중요한 것들을 소개할 것입니다.\n\n## 특별한 역할을 하는 파일 이름\n\n\n\n__root.tsx\n\n이 파일은 모든 경로에 적용되는 파일입니다. 특정 경로가 없으며 여기에서 정의된 컴포넌트는 항상 렌더링됩니다.\n\n```js\nimport { createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute()\n```\n\n또한, createRootRoute 대신 createRootRouteWithContextAPI를 사용하면 의존성 주입이 가능합니다.\n\n\n\n```js\nimport { createRootRouteWithContext, createRouter } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  queryClient: QueryClient\n}\n\nconst rootRoute = createRootRouteWithContext\u003cMyRouterContext\u003e()({\n  component: App,\n})\n\nconst queryClient = new QueryClient()\n\nconst router = createRouter({\n  routeTree: rootRoute,\n  context: {\n    queryClient,\n  },\n})\n```\n\n$token（예: $postId）\n\n$를 접두어로 사용하면 URL 경로로 사용될 것을 의미합니다. 또한, 일치하는 경로 매개변수는로더 함수나 컴포넌트 내에서 참조할 수 있습니다.\n\n```js\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params }) =\u003e {\n    return fetchPost(params.postId)\n  },\n})\n```\n\n\n\n_ 접두사\n\n_를 접두어로 사용할 때, 레이아웃 경로로 사용되며 URL 경로에 표시되지 않습니다. 이는 디렉토리 구조와 라우팅이 다음과 같이 일치한다는 것을 의미합니다.\n\n```js\n_layout/\n  layout-a.tsx // → /layout-a\n  layout-b.tsx // → /layout-b\n```\n\n이렇게 하면 서로 관련된 라우트들을 일치시킬 수 있습니다.\n\n\n\n## RouteOptions 유형\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // skip\n  loader,\n  errorComponent,\n  pendingComponent,\n  validateSearch,\n})\n```\n\nloader\n\n```js\ntype loader = ({/** 생략 */}) =\u003e Promise\u003cTLoaderData\u003e | TLoaderData | void\n```\n\n\n\n이 기능은 Remix/React-Router의 로더와 유사합니다. 경로가 호출될 때 트리거가 발동되며, 실패할 경우 오류를 발생시킵니다.\n\n로더가 Promise를 반환할 때, 경로는 보류 상태가 되며, 렌더링은 Promise가 해결될 때까지 일시 중단됩니다. Promise가 거부되면 경로는 오류 상태가 됩니다.\n\n오류 구성요소, 보류 구성요소\n\n위에서 언급한 로더 함수의 맥락에서, Promise의 상태에 따라 렌더링이 일시 중단되거나 오류 상태가 될 수 있다고 설명했습니다. 따라서 TanStack Router는 각 경로에 대해 오류 및 보류 상태를 위한 구성 요소를 정의할 수 있습니다.\n\n\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // success\n  errorComponent, // error\n  pendingComponent, // pending\n})\n```\n\nvalidateSearch\n\nvalidateSearch을 사용하여 검색 매개변수를 유효성 검사하고 안전하게 처리할 수 있습니다. 또한 zod와 같은 유효성 검사 라이브러리와 결합할 수 있습니다.\n\n```js\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer\u003ctypeof productSearchSchema\u003e\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search) =\u003e productSearchSchema.parse(search),\n})\n```\n\n\n\n# 번들 크기를 줄이기 위한 코드 분할\n\nTanStack 라우터는 코드 분할을 위한 기능을 내장하고 있습니다. 코드 분할 (또는 지연 로딩)의 주요 목적은 세 가지입니다:\n\n- 초기 페이지 로드에 필요한 코드량을 줄입니다.\n- 필요할 때만 대상 코드를 로드합니다.\n- 코드를 청크(chunk)로 나눠서 더 세분화된 수준에서 캐싱을 가능하게 합니다.\n\n## 코드 분할 사용 방법\n\n\n\nTanStack Router로 코드 분할하는 방법은 간단해요:\n\n이를 통해 Critical Routes와 Lazy Routes를 구별할 수 있어요.\n\nCritical Route\n\n- 초기에 로드되는 코드입니다.\n\n\n\n게으른 루트\n\n- 요청 시 로드되는 코드, 지연이 발생합니다.\n\n그렇다면, 코드 분할을 위한 대상을 선택하기 위해 어떤 기준을 사용해야 할까요?\n\nTanStack 라우터 문서에서 명확히 설명되어 있습니다.\n\n\n\nCritical Route에 대한 목표 (route.tsx)\n\n- 경로 구문 분석/직렬화\n- 검색 매개변수 유효성 검사\n- 로더, 로드 전\n- 라우트 컨텍스트\n- 메타\n- 링크\n- 스크립트\n- 스타일\n- 아래에 나열되지 않은 모든 다른 라우트 구성\n\nLazy Route에 대한 목표 (route.lazy.tsx)\n\n- 라우트 컴포넌트\n- 오류 컴포넌트\n- 대기 중인 컴포넌트\n- 찾을 수 없는 컴포넌트\n\n\n\n각 경로와 연관된 컴포넌트는 Lazy Loading을 위해 지정할 수 있습니다.\n\n## 로더는 코드 분할 대상이 아닌가요???\n\n로더를 Lazy Routes의 일부로 만들지 않는 세 가지 이유가 있습니다:\n\n- 로더를 대상으로 지정하면 두 번의 왕복이 필요합니다: 하나는 로더 자체의 청크를 가져오기 위한 것이고, 다른 하나는 그를 실행하기 위한 것입니다.\n- 일반적으로 로더에는 상대적으로 적은 양의 코드가 포함되어 있기 때문에, 이를 포함시켜도 번들 크기를 크게 줄이지 않습니다.\n- 경로에 대해, 로더는 프리로딩을 위한 중요한 요소입니다.\n\n\n\n# 검색 매개변수를 사용한 상태 관리\n\nTanStack Router는 검색 매개변수를 전역 상태로 간주하며, 타입 안전성 및 유효성 검사 기능을 통해 이를 안전하게 관리할 수 있게 해줍니다.\n\n사용자들에게는 다음과 같은 시나리오에서 상태가 일관되게 유지되는 것을 기대합니다:\n\n- Cmd/Ctrl + 클릭으로 새 탭 열기\n- 즐겨찾기나 링크 공유\n- 페이지 새로고침\n\n\n\n개발자들에게는 다른 상태 관리 솔루션과 같이 유연하고 안전하며 유효성을 갖춘 방식으로 검색 매개변수를 관리하는 이 접근 방식이 검색 매개변수를 더 효율적으로 처리할 수 있게 합니다.\n\n## 왜 URLSearchParams를 사용하지 않나요?\n\nURLSearchParams에는 다음과 같은 단점이 있습니다:\n\n- 항상 문자열 유형임.\n- 대부분의 경우 평면 구조입니다.\n- 검색 매개변수를 업데이트할 때 URL 경로를 고려해야 합니다.\n\n\n\n그러나 검색 매개변수를 전역 상태로 고려할 때, 이러한 단점은 중대한 도전 과제가 됩니다.\n\n이상적인 해결책은 다음과 같습니다:\n\n- 중첩된 배열 및 객체와 같은 복잡한 데이터 유형을 조작할 수 있는 능력을 포함하여 상태 관리 라이브러리와 유사한 유형의 여러 가지 처리.\r\n- URL 경로와 상호 작용하지 않고 검색 매개변수를 관리합니다.\n\nTanStack Router는 이러한 도전에 대처합니다.\n\n\n\n## JSON-first 검색 매개변수\n\nTanStack Router는 강력한 구문 분석기를 갖추고 있어서 검색 매개변수를 자동으로 구조화된 JSON으로 변환할 수 있습니다. 이는 JSON으로 직렬화 가능한 데이터를 검색 매개변수로 사용할 수 있다는 것을 의미합니다.\n\n```js\nconst link = (\n  \u003cLink\n    to=\"/shop\"\n    search={\n      pageIndex: 3,\n      includeCategories: ['electronics', 'gifts'],\n      sortBy: 'price',\n      desc: true,\n    }\n  /\u003e\n)\n// → /shop?pageIndex=3\u0026includeCategories=%5B%22electronics%22%2C%22gifts%22%5D\u0026sortBy=price\u0026desc=true\n```\n\n## 유효성 검사와 유형 정의\n\n\n\n검색 매개변수의 유효성 검사 및 유형 정의는 createFileRouteAPI의 validateSearch 옵션을 사용합니다. 이를 통해 구성 요소에서 검색 매개변수를 검색하고 조작할 때 유형 안전성을 제공할 수 있습니다.\n\n```js\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record\u003cstring, unknown\u003e): ProductSearch =\u003e {\n    // 검색 매개변수를 유효성 검사하고 구문 분석하여 유형화된 상태로 반환합니다.\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n```\n\n# 캐시를 이용한 데이터 로딩\n\nTanStack Router는 SWR 캐싱이 가능한 기능을 제공하여 일반적인 로더 역할을 뛰어넘습니다. 이 기능을 통해 데이터를 사전로드하고 캐시된 데이터를 표시하거나 이전에 검색한 데이터를 캐시하고 다시 사용할 수 있습니다.\n\n\n\n## 의존성 기반 Stale-While-Revalidate 캐싱\n\n캐시는 경로 의존성에 의해 제어됩니다. 여기서 의존성은 다음과 같은 요소들입니다:\n\n- 라우트의 경로명\n/posts/1 대 /posts/2\n- loaderDeps가 제공하는 추가적인 의존성\nloaderDeps: (' search: ' index, size ' ') =` (' index, size ')\n\n## 캐시 제어\n\n\n\nTanStack Router의 캐시는 TanStack Query와 비슷하며, TanStack Query에 익숙한 사람들은 학습 비용을 낮추면서 처리할 수 있습니다.\n\nstaleTime\n\n- 캐시된 데이터가 오래되었다고 간주되기까지의 시간입니다. 기본값은 0입니다.\n\ngcTime\n\n\n\n- 사용되지 않은 캐시가 폐기되기까지의 시간입니다. 기본값은 30분입니다.\n\n# TanStack Query의 Suspense\n\n지금까지 TanStack Router에 대해 이야기했지만, TanStack Query v5와 함께 안정화된 suspense 기능에 대해 설명하려고 합니다.\n\n일반 useQuery와 useSuspenseQuery의 주요 차이점은 이제 데이터가 정의되지 않은 상태에 대한 계산이 필요하지 않다는 것입니다.\n\n\n\nTanStack Query을 사용할 때, 데이터가 없을 경우 pendingComponent가 표시되고 오류가 발생할 경우 errorComponent가 표시되도록 구현했습니다. 아래 코드는 이를 예시로 보여줍니다.\n\n```js\nfunction Todos() {\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n  if (query.status === \"pending\") {\n    return \u003cPending /\u003e\n  }\n\n  if (query.status === \"error\") {\n    return \u003cError /\u003e\n  }\n\n  return (\n    \u003cdiv\u003e\n      할 일 목록\n    \u003c/div\u003e\n  )\n}\n```\n\n그러나 useSuspenseQuery를 사용할 때는 데이터가 정의되지 않은 상태를 고려할 필요가 없으므로 코드가 다음과 같이 변경됩니다:\n\n```js\nfunction Todos() {\n  const { data } = useSuspenseQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n\n  // 🎉 로딩 또는 오류 상태를 처리할 필요가 없습니다\n\n  return (\n    \u003cdiv\u003e\n      { /* TypeScript가 데이터가 undefined일 수 없다는 것을 알고 있습니다 */ }\n      {data.map((todo) =\u003e (\n        \u003cdiv\u003e{todo.title}\u003c/div\u003e\n      ))}\n    \u003c/div\u003e\n  )\n}\n```\n\n\n\n```js\nfunction App() {\n  // 🚀 경계(Boundaries)는 로딩 및 오류 상태를 처리합니다\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cErrorBoundary fallback={\u003cdiv\u003eOn no!\u003c/div\u003e}\u003e\n        \u003cTodos /\u003e\n      \u003c/ErrorBoundary\u003e\n    \u003c/Suspense\u003e\n  )\n}\n```\n\n이전에는 컴포넌트 자체에서 \"대기 중\" 및 \"오류\" 상태를 처리해야했습니다. 이제 이러한 과제를 별도로 관리할 수 있게 되었습니다.\n\n- 대기 중 상태: Suspense의 대기 중 대체(fallback)로 처리됩니다.\n- 오류 상태: ErrorBoundary의 대체(fallback)로 처리됩니다.\n\n일부 분들께서는 이러한 역할 분담의 분리가 TanStack Router의 파일 기반 접근 방식과 잘 맞는다는 것을 알아채셨을 것입니다. TanStack Router에서는 각 경로(route)별로 컴포넌트, 대기 중 컴포넌트(pendingComponent) 및 오류 컴포넌트(errorComponent)를 정의할 수 있었습니다.```\n\n\n\n```js\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  component, // 성공\n  errorComponent, // 오류\n  pendingComponent, // 보류 중\n})\n```\n\n이는 컴포넌트 내에서 사용되는 useSuspenseQuery의 보류 및 오류 상태 처리를 TanStack Router를 통해 경로별로 구성할 수 있다는 것을 의미합니다.\n\n## Loader 또는 TanStack Query를 사용해야 할까요?\n\nTanStack Query의 suspense 기능이 TanStack Router와 호환되는 방법을 설명했습니다. 그러나 데이터 가져오기 관점에서는 TanStack Router의 로더를 사용하거나 SWR 캐싱 기능을 가진 TanStack Router를 사용하는 것도 가능합니다.\n\n\n\n그래서 그것들을 어떻게 구분하고 활용해야 할까요?\n\n공식 문서에서는 TanStack Router의 Cache의 장단점을 언급했습니다.\n\nTanStack Router Cache의 장점\n\n- 쉽게 사용할 수 있음\r\n- 경로별 중복 제거, 사전로딩, 로딩 처리를 가능하게 함\r\n- 자동으로 가비지 수집을 지원함\n\n\n\nTanStack Router Cache의 단점\n\n- 지속성을 위한 어댑터나 모델 없음\n- 라우트 간 캐시 공유 또는 중복 제거 기능 없음\n- 업데이트를 위한 API가 부족함\n\n로더는 대상 라우트와 관련이 있으며, 라우트 간에 캐시를 공유할 수 없습니다.\n\n따라서 응용 프로그램 상태 관리 도구로서의 TanStack Query의 존재가 필요하며, TanStack Router와 효과적으로 결합되어야 합니다.\n\n\n\n## 캐시 데이터 미리 로딩\n\nTanStack Router에는 미리 로딩하는 기능이 내장되어 있습니다. 예를 들어 사용자가 다른 화면으로 이동하려는 `Link`에 마우스를 가져가면 해당 경로에 필요한 데이터를 미리 로드합니다.\n\n이 기능은 매우 강력하며 TanStack Query와 결합하여 데이터 가져오기를 보다 효율적으로 만들어주고 때로는 폭포 모델 문제까지 해결할 수 있습니다.\n\n다음은 코드 예시입니다:\n\n\n\nTanStack Router의 로더를 사용하여 데이터를 미리 준비하고, TanStack Query의 캐시에 저장하세요. 그래서 useSuspenseQuery가 호출되는 시점에는 데이터가 이미 준비되어 있는 것이 보장됩니다.\n\n```js\n// src/routes/posts.tsx\n\nconst postsQueryOptions = queryOptions({\n  queryKey: 'posts',\n  queryFn: () =\u003e fetchPosts,\n})\n\nexport const Route = createFileRoute('/posts')({\n  // 데이터가 로드되도록 'loader' 옵션 사용\n  loader: () =\u003e queryClient.ensureQueryData(postsQueryOptions),\n  component: () =\u003e {\n    // 캐시에서 데이터를 읽고 업데이트에 구독합니다\n    const posts = useSuspenseQuery(postsQueryOptions)\n\n    return (\n      \u003cdiv\u003e\n        {posts.map((post) =\u003e (\n          \u003cPost key={post.id} post={post} /\u003e\n        ))}\n      \u003c/div\u003e\n    )\n  },\n})\n```\n\nTanStack Router의 로더를 사용하여 데이터를 미리 로드하고, TanStack Query의 useSuspenseQuery로 캐시된 데이터 상태를 관리하세요.\n\n# TanStack Router의 디렉터리 디자인\n\n\n\n지금까지 TanStack 라우터의 기능과 TanStack 쿼리와의 호환성에 대해 논의해왔습니다. 마지막으로, TanStack 라우터의 디렉토리 구조를 소개하며 해당 특징과 장점에 대해 설명하겠습니다.\n\n다음은 디렉토리 구조입니다:\n\n```js\n.\n├── __root.tsx // 루트 파일\n├── posts\n│   ├── -components // 🐢 경로 내부에서 사용되는 UI 구성 요소\n│   ├── -api // 🦋 경로 내부에서 사용되는 API 통신 훅\n│   ├── -types // 🐠 경로 내부에서 사용되는 타입 정의\n│   ├── -functions // 🦐 경로 내부에서 사용되는 함수\n│   ├── route.lazy.tsx // 🐕 지연 로드 라우트\n│   ├── route.tsx // 🦈 주요 라우트\n│   └── $postId // /posts와 유사\n│       ├── -components\n│       ├── -api\n│       ├── -types\n│       ├── -functions\n│       ├── route.lazy.tsx\n│       └── route.tsx\n```\n\n## 특징 1: 특징 기반 디렉토리 구조\n\n\n\n제공된 예시에서 각 라우트는 다음과 같은 디렉토리를 포함하고 있어요:\n\n- -components: 해당 라우트 내에서 사용하는 UI 구성 요소들이 들어 있어요.\n- -api: 해당 라우트 내에서 사용하는 API 통신에 사용되는 후크들이 들어 있어요. 여기에는 TanStack Query와 같은 API가 활용돼요.\n- -types: 해당 라우트 내에서 사용하는 타입 정의들이 들어 있어요.\n- -functions: 해당 라우트 내에서 사용되는 함수들이 들어 있어요. 각 함수는 자체 단위 테스트가 구현될 수도 있어요.\n\n이 접근 방식을 통해, 디렉토리인 components나 api와 같은 레이어 기반 접근 방식과는 달리 기능 기반 디자인이 가능해져요.\n\n물론, 모든 기능이 직접적으로 라우트에 해당하는 것은 아닐 거예요. 그런 경우에는 관련된 관심사를 그룹화하기 위해 _접두사를 사용하는 것이 효과적일 수 있어요.\n\n\n\n## 기능 2: 라우트 훅 사용을 특정 라우트에 제한\n\nTanStack Router에서는 각 특정 라우트에 대응하는 Route Hooks를 사용하여 경로 매개변수와 검색 매개변수를 안전하게 처리할 수 있습니다.\n\n```js\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  const { postId } = Route.useParams()\n  return \u003cdiv\u003e포스트 {postId}\u003c/div\u003e\n}\n```\n\n위와 같은 디렉토리 디자인으로 캡슐화된 라우트 내에서 사용되는 컴포넌트들이 있을 때, /posts 하위의 라우트에 대해 /posts에 특화된 Route Hooks가 사용됨을 명확하게 알 수 있습니다.\n\n\n\n```md\n.\n├── pages\n├── components\n│   ├── Post.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Todo.tsx // 해당 컴포넌트 라우트 훅을 사용하나요?\n│   ├── Form.tsx // ???\n│   └── Card.tsx // ???\n```\n\n아주 극단적인 예시라고 하더라도, 컴포넌트가 최상위 계층에 배치된 디자인에서는 어떤 라우트 훅이 어디에 사용되고 있는지를 구분하는 것이 어렵습니다.\n\n특집 기반의 디자인에 초점을 맞추면, 특정 라우트 내에서 사용되는 컴포넌트만을 고려하게 됩니다.\n\n```md\n.\n├── posts\n│   ├── -components // /posts 라우트 훅이 사용됨\n│   │   ├── Card.tsx\n│   │   └── Form.tsx\n│   └── $postId \n│       └── -components // /posts/$postId 라우트 훅이 사용됨\n```\n\n\n\n## 기능 3: Suspense를 위한 명확한 경계\n\nTanStack Query의 useSuspenseQuery를 사용하면 보류 및 오류 상태에 대한 문제를 외부화하여 컴포넌트 측이 데이터가 정의되지 않은 경우를 예상할 필요가 없어집니다.\n\nTanStack Router와 잘 어울린다고 언급한 이유 중 하나는 각 라우트마다 pendingComponent 및 errorComponent를 정의할 수 있으므로 사용자 정의 Suspense 경계를 정의할 필요가 없다는 것입니다.\n\n더 많은 정보를 원한다면 TanStack Router 문서에 게시된 샘플을 참조해주세요.\n\n\n\n위의 이미지에서 빨간색과 파란색 프레임으로 표시된 Suspense 바운더리가 있습니다. 이는 파란 프레임 내에서 발생하는 보류 및 오류 상태가 /post/$postId 경로에 정의된 처리에 의해 처리되는 반면 빨간 프레임 내에서 발생하는 상태는 /posts 경로에 정의된 처리에 의해 처리된다는 것을 의미합니다.\n\n(아래는 실제 코드 예시입니다.)\n\n# 요약\n\n\n\n이번 세션에서는 TanStack Router의 기능과 TanStack Query와의 호환성, 그리고 디렉토리 디자인을 소개했습니다. Next.js와 Remix와 같은 프레임워크의 발전은 놀라운데, React를 사용하여 Single Page Applications (SPAs)을 개발하는 도중에 완전히 해결되지 않은 어려움이 있었다는 느낌이 있었습니다.\n\n그러나 이번에 소개된 TanStack Router의 파일 기반 및 높은 개발 경험(DX) 접근 방식은 React 라이브러리 선택 시 효과적인 선택일 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png"},"coverImage":"/assets/img/2024-05-12-TanStackRouterisoneofthemostpowerfuloptionsforSPAdevelopmentTanStackQuery_0.png","tag":["Tech"],"readingTime":14},{"title":"상태 관리의 잠금 해제 리액트 컨텍스트에 대한 심층 분석","description":"","date":"2024-05-12 21:30","slug":"2024-05-12-UnlockingStateManagementADeepDiveintoReactContext","content":"\n\nReact Context은 React 애플리케이션 내의 컴포넌트 트리를 통해 데이터를 수동으로 props를 전달하지 않고 전달할 수 있는 방법을 제공합니다. Props Drilling이라고도 합니다. 이것의 목적은 React 애플리케이션 내에서 상태 관리를 단순화하고 컴포넌트 간에 전역 데이터 공유를 활성화하는 것입니다.\n\n# 시작해봅시다:\n\n이제 우리가 React Context가 무엇인지 알았으니, 언제 사용할지 알아봅시다:\n- 애플리케이션이 UI 테마, 언어 설정 또는 사용자 인증 상태와 같은 비교적 간단한 상태 관리 요구사항을 갖고 있거나, 사이드 드로어의 현재 상태 또는 상태 값의 수가 적은 경우, Redux의 복잡성 없이 React Context가 가벼운 솔루션을 제공할 수 있습니다.\n- Redux와 비교하여 보일러플레이트 코드가 줄어들 수 있으며, 특히 상태 관리 요구사항이 간단한 프로젝트나 작은 프로젝트의 경우에 해당합니다.\n- 의존성 주입에 사용될 수 있으며, 의존성 (서비스 또는 구성 객체와 같은)을 컴포넌트에 수동으로 전달하지 않고 주입할 수 있습니다. 이는 특히 테스트와 컴포넌트를 구체적인 구현과 분리하는 데 유용할 수 있습니다.\n\n\n\n이제 React Context를 피해야 할 때를 확인해 봅시다:\n\n- React Context는 강력하지만, 특히 실제로 전역적이지 않은 데이터에는 신중하게 사용해야 합니다.\n- React Context를 과도하게 사용하면 불필요한 다시 렌더링과 성능 하락을 초래할 수 있습니다.\n- 상태 값이 매우 빈번하게 변경될 때에는 React Context가 Redux만큼 효율적이지 않습니다.\n- 컴포넌트 재구성도 React Context의 사용을 현명하게 피할 수 있습니다.\n\n# 한번 만들어 봅시다\n\n온라인 쇼핑 애플리케이션을 고려해 봅시다. 여기서는 장바구니 값을 처리하는 온라인 쇼핑 애플리케이션을 생각해 보겠습니다. React Context를 활용하는 것은 4가지 간단한 단계로 이루어질 수 있습니다.\n\n\n\n스텝 1:\n\n애플리케이션의 컨텍스트를 createContext 메서드를 사용하여 생성합니다. 컨텍스트를 생성하는 동안 객체 매개변수로 공유해야 하는 값과 메서드를 전달합니다. 이렇게 하면 컨텍스트 값을 사용할 때 자동 완성에 도움이 됩니다.\n\n```js\nimport React, { createContext } from 'react';\n\nexport const CartContext = createContext({\n  items: [],\n  addItemToCart: () =\u003e {},\n  updateCartItemQuantity: () =\u003e {},\n});\n```\n\n스텝 2:\n\n\n\n다음으로, 방금 생성한 컨텍스트의 Provider 구성 요소로 구성 요소를 래핑해야 합니다. 컨텍스트 값을 액세스할 모든 컴포넌트는 Provider 구성 요소로 둘러싸야 합니다. 예를 들어, 아래 예제에서 Header 컴포넌트는 현재 장바구니 아이템 수를 표시하기 위해 장바구니 심볼을 액세스합니다. 각 제품의 클릭 이벤트는 항목을 추가하여 장바구니를 업데이트하고 장바구니 항목 수도 업데이트합니다.\n\n```js\nimport React, { useState } from 'react';\nimport { CartContext } from \"../store/shopping-cart-context.jsx\";\n\nfunction App() {\n  return (\n    \u003cCartContext.Provider\u003e\n      \u003cHeader/\u003e\n      \u003cShop\u003e\n        {PRODUCTS.map((product) =\u003e (\n          \u003cli key={product.id}\u003e\n            \u003cProduct {...product} /\u003e\n          \u003c/li\u003e\n        ))}\n      \u003c/Shop\u003e\n    \u003c/CartContext.Provider\u003e\n  );\n}\n```\n\n3단계:\n\nProvider에는 컨텍스트가 사용할 기본 값을 전달해야 합니다.\n\n\n\n현재 항목 상태 값을 전달했습니다. 또한 addItemToCart와 updateCartItemQuantity 두 공유 메소드의 참조를 전달했습니다.\n\n```js\nimport React, { useState } from 'react';\nimport { CartContext } from \"../store/shopping-cart-context.jsx\";\n\nfunction App() {\n  const [items, setItems] = useState([]);\n  const handleAddingItemToCart = (id) =\u003e {\n      ...\n  }\n  const handleUpdateCartItemQuantity = () =\u003e {\n      ...\n  }\n\n  const defaultCartValue = {\n      items: items,\n      addItemToCart: handleAddingItemToCart,\n      updateCartItemQuantity: handleUpdateCartItemQuantity,\n  }\n\n  return (\n    \u003cCartContext.Provider value={defaultCartValue}\u003e\n      \u003cHeader /\u003e\n      \u003cShop\u003e\n        {PRODUCTS.map((product) =\u003e (\n          \u003cli key={product.id}\u003e\n            \u003cProduct {...product} /\u003e\n          \u003c/li\u003e\n        ))}\n      \u003c/Shop\u003e\n    \u003c/CartContext.Provider\u003e\n  );\n}\n```\n\nStep 4:\n\n이제 자식 컴포넌트에서 컨텍스트 값을 사용할 때입니다.\n\n\n\n첫 번째로 useContext 후크를 사용하여 현재 컨텍스트에 액세스합니다. 여기서는 해당 컴포넌트가 필요로하는 컨텍스트 속성 및 메서드를 구조 분해할 수 있습니다.\n\n```js\nimport React, { useContext } from 'react';\n\nexport default function Header() {\n  const cartCtx = useContext(CartContext);\n  const cartItemsCount = cartCtx.items.length;\n  // OR\n  const { items } = useContext(CartContext);\n  const cartItemsCount = items.length;\n  ...\n  return (\n    \u003cdiv\u003e\n        \u003cLogo/\u003e\n        \u003cp\u003e온라인 쇼핑\u003c/p\u003e\n        \u003cbutton\u003e장바구니 ({cartItemsCount})\u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n```js\nimport { useContext } from \"react\";\nimport { CartContext } from \"../store/shopping-cart-context\";\n\nexport default function Product({ image, title, price, description }) {\n  const { addItemToCart } = useContext(CartContext);\n\n  return (\n    \u003carticle className=\"product\"\u003e\n      \u003cimg src={image} alt={title} /\u003e\n      \u003cdiv className=\"product-content\"\u003e\n        \u003cdiv\u003e\n          \u003ch3\u003e{title}\u003c/h3\u003e\n          \u003cp className='product-price'\u003e${price}\u003c/p\u003e\n          \u003cp\u003e{description}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cp className='product-actions'\u003e\n          \u003cbutton onClick={() =\u003e addItemToCart(id)}\u003e장바구니에 추가\u003c/button\u003e\n        \u003c/p\u003e\n      \u003c/div\u003e\n    \u003c/article\u003e\n  );\n}\n```\n\n# 꿀팁\n\n\n\n- 메인 App 컴포넌트에 너무 많은 메소드가 있으면 컴포넌트가 과부하될 수 있어요. 이를 해소하기 위해 공유 메소드와 상태 값을 모두 사용자 정의 후크로 추출할 수 있어요.\n- Context API를 과도하게 사용하면 상태 값이 변경될 때마다 다시 렌더링되어 성능에 영향을 줄 수 있어요.\n- 여러 개의 컨텍스트 프로바이더가 있을 때는 코드 유지보수를 쉽게하기 위해 하나로 결합하여 슬라이스를 만들어야 해요.\n- 컨텍스트는 별도의 파일에서 처리되어야 해요.\n\n# 결론\n\nReact Context를 상태 관리 도구로서의 개념, 사용 사례, 이용 방법 및 주의 사항에 대해 쉽게 이해하는 데 도움이 되었으면 좋겠어요.\n\n즐거운 코딩하세요!!!","ogImage":{"url":"/assets/img/2024-05-12-UnlockingStateManagementADeepDiveintoReactContext_0.png"},"coverImage":"/assets/img/2024-05-12-UnlockingStateManagementADeepDiveintoReactContext_0.png","tag":["Tech"],"readingTime":5},{"title":"외부 라이브러리 없이 React에서 간단한 드래그 앤 드롭하기","description":"","date":"2024-05-12 21:29","slug":"2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_0.png\" /\u003e\n\n## 리액트에서 드래그 앤 드롭이란?\n\n드래그 앤 드롭은 화면에서 마우스나 터치패드를 사용하여 요소를 이동하거나 조작하는 방식입니다. 목록의 항목을 재정렬하거나 항목을 한 목록에서 다른 목록으로 이동하는 데 이상적입니다. React에서 매우 간단한 방법으로 드래그 앤 드롭 컴포넌트를 구축할 수 있습니다. \n여러분의 리액트 앱에서 항목이거나 테이블이 있는데 이 목록이나 테이블 행의 순서를 변경하고 싶다면 이 단계를 따라 드래그 앤 드롭을 구축해보세요.\n\n## 1. 요소를 드래그할 수 있도록 만드세요.\n\n\n\n여기서 해야 할 일은 각 목록 항목 또는 테이블 행에 \"draggable\" prop을 전달하는 것뿐입니다. 이 prop을 사용하면 요소를 드래그할 수 있게 됩니다.\n\n![Drag and Drop](/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_1.png)\n\n이제 목록/테이블의 모든 요소/행을 드래그할 수 있습니다. (참고: 요소만 드래그할 수 있습니다)\n\n## 2. 드래그하는 요소 가져오기\n\n\n\nuseRef 훅을 사용하여 끌어 올리고 있는 항목을 보관한 다음, \"onDragStart\" 메서드를 사용하여이를 드래그하고 다른 요소로 붙여 넣습니다.\n\n![드래그 앤 드롭](/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_2.png)\n\n## 3. 우리가 떠 다니는 요소를 가져 오거나 요소가 교체 될 요소를 가져옵니다.\n\n이 단계에서는 끌어올린 요소가 떠 다니는 요소를 찾아야합니다. UseRef를 사용하여이를 달성 할 수 있으며 “onDragEnter\" 이벤트 리스너도 이 작업을 수행합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_3.png)\n\n## 4. 다른 항목으로 드래그 가능한 아이템 바꾸기.\n\n마지막 단계 중 하나는 드래그한 요소를 다른 요소 위에 놓거나 다른 위치에 놓았을 때 목록을 재배열하는 것입니다. 이를 \"onDragEnd\" 메서드를 사용하여 달성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_4.png)\n\n\n\n드래그 앤 드롭을 즐기세요.","ogImage":{"url":"/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_0.png"},"coverImage":"/assets/img/2024-05-12-SimpleDragandDropinReactwithoutanexternallibrary_0.png","tag":["Tech"],"readingTime":2},{"title":"React Native에서 기기에서 파일을 업로드하는 방법","description":"","date":"2024-05-12 21:28","slug":"2024-05-12-HowtoUploadFilesFromDeviceinReactNative","content":"\n\n사용자들이 갤러리에서 이미지를 선택할 수 있는 기능을 제공하는 모바일 애플리케이션을 개발 중이신데요, React Native는 expo-image-picker를 통해 이를 쉽게 구현할 수 있어요. 이 라이브러리는 사용자들이 카메라 롤에서 기존 사진을 손쉽게 선택하거나 카메라를 통해 새 이미지를 캡처할 수 있는 기능을 제공합니다.\n\n![이미지](/assets/img/2024-05-12-HowtoUploadFilesFromDeviceinReactNative_0.png)\n\n# 설치\n\n시작하기 전에 React Native 프로젝트가 설정되어 있고 Expo와 통합되어 있는지 확인해주세요. Expo는 expo-image-picker 라이브러리를 제공하는데, 이를 통해 기기의 카메라와 사진 라이브러리에 접근할 수 있습니다.\n\n\n\n```js\nnpx expo install expo-image-picker\n```\n\n# 코드\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport { Button, View, Image, Platform, StyleSheet, Text } from 'react-native';\nimport * as ImagePicker from 'expo-image-picker';\nimport { Pressable } from 'react-native';\n\n\nconst ImagePickerScreen = () =\u003e {\n  const [image, setImage] = useState(null);\n\n  useEffect(() =\u003e {\n    (async () =\u003e {\n      if (Platform.OS !== 'web') {\n        const libraryStatus = await ImagePicker.requestMediaLibraryPermissionsAsync();\n        if (libraryStatus.status !== 'granted') {\n          alert('죄송합니다. 이 기능을 사용하려면 카메라 롤 권한이 필요합니다.');\n        }\n\n        const cameraStatus = await ImagePicker.requestCameraPermissionsAsync();\n        if (cameraStatus.status !== 'granted') {\n          alert('죄송합니다. 이 기능을 사용하려면 카메라 권한이 필요합니다.');\n        }\n      }\n    })();\n  }, []);\n\n  const pickImage = async () =\u003e {\n    let result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.All,\n      allowsEditing: true,\n      aspect: [4, 3],\n      quality: 1,\n    });\n\n    if (!result.cancelled) {\n      setImage(result.uri);\n    }\n  };\n\n  return (\n    \u003cView style={styles.container}\u003e\n      \u003cButton title=\"카메라 롤에서 이미지 선택\" onPress={pickImage} /\u003e\n      {image \u0026\u0026 \u003cImage source={{ uri: image }} style={styles.image} /\u003e}\n        \u003cPressable onPress={navigateProfile}\u003e\n            \u003cText style={{ fontSize: 18, marginBottom: 10, color: '#003F5C', padding: 25 }}\u003e프로필로 이동\u003c/Text\u003e\n        \u003c/Pressable\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default ImagePickerScreen;\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  image: {\n    width: 200,\n    height: 200,\n    marginTop: 20,\n  },\n});\n```\n\n# 코드 설명\n```\n\n\n\n이제 코드를 분해하여 각 부분을 이해해 봅시다.\n\n## 필요한 모듈 가져오기\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport { Button, View, Image, Platform, StyleSheet, Text } from 'react-native';\nimport * as ImagePicker from 'expo-image-picker';\nimport { useNavigation } from '@react-navigation/native';\nimport { Pressable } from 'react-native';\n```\n\n이 섹션에서는 다음을 가져옵니다:\n\n\n\n- 기본 기능과 렌더링을 위한 React 훅과 컴포넌트를 사용합니다.\n- 이미지 선택을 처리하기 위해 expo-image-picker의 ImagePicker를 사용합니다.\n- 화면 전환을 위한 네비게이션 도구를 사용합니다.\n\n```js\nconst ImagePickerScreen = () =\u003e {\n  const [image, setImage] = useState(null);\n  const navigation = useNavigation();\n  ...\n};\n```\n\n여기서:\n\n- ImagePickerScreen 함수형 컴포넌트를 정의합니다.\n- 선택한 이미지를 관리하기 위해 useState를 사용합니다.\n- 네비게이션을 설정합니다.\n\n\n\n## 권한을 위한 useEffect 훅\n\n```js\nuseEffect(() =\u003e {\n  (async () =\u003e {\n    if (Platform.OS !== 'web') {\n      const libraryStatus = await ImagePicker.requestMediaLibraryPermissionsAsync();\n      if (libraryStatus.status !== 'granted') {\n        alert('죄송합니다, 이 기능을 사용하려면 사진 라이브러리 권한이 필요합니다!');\n      }\n\n      const cameraStatus = await ImagePicker.requestCameraPermissionsAsync();\n      if (cameraStatus.status !== 'granted') {\n        alert('죄송합니다, 이 기능을 사용하려면 카메라 권한이 필요합니다!');\n      }\n    }\n  })();\n}, []);\n```\n\n이 코드 블록은 컴포넌트가 마운트된 후 실행되는 useEffect 훅을 사용하고 있습니다:\n\n- 플랫폼 확인:\n\n\n\n먼저 플랫폼이 웹 브라우저가 아닌지 확인합니다 (Platform.OS !== `web`). 이것은 권한 처리가 일반적으로 모바일 기기 관련 문제이므로 웹 플랫폼에는 적용되지 않기 때문에 중요합니다.\n\n2. 권한 요청:\n\n미디어 라이브러리 권한: 미디어 라이브러리에 액세스하기 위한 권한을 요청합니다 (ImagePicker.requestMediaLibraryPermissionsAsync()). 이것은 앱이 기기에 저장된 사진에 액세스할 수 있도록 하는 데 필요합니다.\n\n카메라 권한: 마찬가지로, 카메라 사용 권한을 요청합니다 (ImagePicker.requestCameraPermissionsAsync()). 이 권한은 앱이 기기의 카메라를 사용하여 새로운 사진을 찍을 수 있도록 해야 합니다.\n\n\n\n3. 권한 상태 처리:\n\n만약 권한이 허용되지 않았을 경우 (상태 !== `granted`), 사용자에게 경고창을 보여줍니다. 이 경고창은 앱이 올바르게 작동하기 위해 이러한 권한이 필요하다는 것을 사용자에게 알리는 간단한 방법입니다.\n\n## 이미지 선택을 위한 pickImage 함수\n\n```js\nconst pickImage = async () =\u003e {\n  let result = await ImagePicker.launchImageLibraryAsync({\n    mediaTypes: ImagePicker.MediaTypeOptions.All,\n    allowsEditing: true,\n    aspect: [4, 3],\n    quality: 1,\n  });\n\n  if (!result.cancelled) {\n    setImage(result.uri);\n  }\n};\n```\n\n\n\n이 함수는 기기의 이미지 라이브러리를 열고 사용자가 이미지를 선택할 수 있도록 담당합니다:\n\n- 이미지 라이브러리 열기: ImagePicker.launchImageLibraryAsync은 이미지 라이브러리를 열어주는 비동기 함수입니다.\n- 구성:\n\n  - mediaTypes: ImagePicker.MediaTypeOptions.All: 이 설정은 사용자가 사진 및 동영상을 포함한 모든 미디어 유형을 선택할 수 있게 합니다.\n  - allowsEditing: true: 사용자는 이미지를 선택하기 전에 (자르기와 같은) 편집할 수 있습니다.\n  - aspect: [4, 3]: 이미지 편집기의 종횡비를 설정합니다.\n  - quality: 1: 선택한 이미지의 품질을 결정합니다. 여기서 1은 최상의 품질을 의미합니다.\n\n3. 선택 처리:\n\n\n\n- 해당 기능은 사용자가 이미지를 선택할 때까지 대기합니다. 이미지를 선택하면 결과 객체에 선택에 관한 세부 정보가 포함됩니다.\n- 작업이 취소되지 않은 경우 (!result.cancelled), 이미지 URI는 setImage(result.uri)를 호출하여 컴포넌트의 상태에 저장됩니다. 그런 다음 이 URI를 사용하여 이미지를 표시하거나 서버에 업로드할 수 있습니다.\n\n# 결론\n\nExpo의 Image Picker를 React Native 앱에 통합하면 사용자 경험을 향상시키는 강력한 방법을 시연합니다. 권한을 책임 있게 처리하고 이미지 선택 및 편집을 가능하게 함으로써, 이 앱은 사용자의 개인 정보를 존중할 뿐만 아니라 개인화되고 대화식인 접촉을 제공합니다. 이 기능은 현대적인 모바일 앱에서 중요하며, 사용자 참여를 풍부하게 해주고 앱을 보다 다양하고 사용자 친화적으로 만듭니다\n\nGitHub: https://github.com/sanchit0496/react_native_scaffolding\n\n\n\n# 더 많은 정보를 위해 Sanchit의 LinkedIn을 팔로우해 주세요","ogImage":{"url":"/assets/img/2024-05-12-HowtoUploadFilesFromDeviceinReactNative_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoUploadFilesFromDeviceinReactNative_0.png","tag":["Tech"],"readingTime":6},{"title":"undefined","description":"","date":"2024-05-12 21:27","slug":"undefined","content":"\n\nXchat과의 여정: 협업을 통해 배우고 성장하기\n\n소프트웨어 엔지니어링의 끊임없이 발전하는 세계에서, 각 프로젝트는 학습하고 성장하며 새로운 가능성을 탐험할 수 있는 기회입니다. Xchat은 그저 채팅 애플리케이션이 아니라, ALX 최종 프로젝트의 일환으로 Egor Philip과 함께 협업하며 배우고 성장한 여정을 나타내는 것입니다.\n\nXchat은 간단한 채팅 애플리케이션을 만들기 위한 간단한 아이디어로 시작되었습니다. 코딩에 대한 열정과 우리의 한계를 넘어 나아가려는 열망으로, 우리는 함께 이 여정을 시작했습니다. 노트북과 열정으로 무장해 React, Next.js, 그리고 Firebase의 세계로 뛰어들었습니다.\n\n우리의 여정은 성공과 도전, 승리와 어려움으로 가득했습니다. 늦은 밤까지 지속되는 코딩 세션에서부터 디버깅 마라톤까지, 우리는 모두 해결해 나갔습니다. 각 코드 라인은 배운 교훈이었고, 각 버그 해결은 축하할 만한 승리였습니다.\n\n\n\nXchat 퍼즐을 맞췄을 때 우리는 실시간 메시징의 마법과 사용자 인증의 중요성, 아이디어가 화면에서 현실로 만들어지는 즐거움을 발견했습니다. Xchat은 단지 프로젝트가 아니었어요 - 자아 발견, 성장, 그리고 우정이 깃든 여정이었죠.\n\n그렇죠, Xchat이 완벽하지 않다 해도 좋아요. 코드에 숨어 있는 버그와 추가되어야 할 기능, 배워야 할 교훈들이 있지만 그것이 아름다운 건데요 - 계속 진화 중인 작품이고, 그려지기를 기다리는 캔버스이며, 펼쳐지기를 기다리는 이야기거든요.\n\n그래서, 학습과 성장의 여정에 함께 나아가요. Xchat을 탐험해봐요, 완성된 제품으로서가 아니라 우리 여정의 한 장면으로 - 늦은 밤, 깨달음의 순간, 코딩 속 불에서 형성된 우정들이 담긴 공간으로요. 다음으로 이 여정이 어디로 향할지는 아무도 모르겠지만 확실한 건, 정말 멋진 여정이 될 거라는 거에요.\n\n당신만의 코딩 모험을 떠날 준비가 되셨나요? Xchat에 몰두하고, 함께 소프트웨어 엔지니어링의 세계를 탐험해봐요.\n\n\n\nhttps://x-chat-seven.vercel.app\n\nhttps://youtu.be/7NWMCrdzCLg?feature=shared","ogImage":{"url":"/assets/img/undefined_0.png"},"coverImage":"/assets/img/undefined_0.png","tag":["Tech"],"readingTime":2},{"title":"Vercel이 가격 정책을 변경했어요  어떤 차이가 있을까요","description":"","date":"2024-05-12 21:25","slug":"2024-05-12-VercelJustChangeditsPricingHowDoesitCompare","content":"\n\n## 인기 있는 NextJS 프론트엔드 인프라 서비스는 과거 높은 비용에 대한 비판을 받아왔습니다.\n\n![이미지](/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png)\n\nVercel은 NextJS를 위한 회사로, GitHub에서 12만 개 이상의 스타를 받은 제작용 React 애플리케이션에 대한 널리 알려진 무료 및 오픈소스 소프트웨어(FOSS) 프레임워크입니다. 실제로 NextJS는 React 팀이 공식 문서 웹사이트에서 프로젝트를 시작하기 위한 권장 솔루션입니다.\n\nFOSS NextJS 프로젝트 외에도 Vercel은 NextJS 프로젝트를 배포하기 위한 무료 및 유료 인프라 서비스(IaaS) 옵션을 제공합니다. 이 서비스는 프로젝트를 손쉽게 구축하고 실행하는 과정에서 복잡성을 제거하는 많은 기능때문에 많은 개발자들에게 좋아지고 있습니다. AWS EC2와 같은 웹 애플리케이션을 배포하는 보다 기본적인 옵션과 비교했을 때, Vercel은 훨씬 추상화되어 있으며, 몇 번의 클릭으로 NextJS 프로젝트를 배포하고 사용자에게 제공할 수 있습니다.\n\n\n\n그러나 Vercel은 가격 정책에 대해 지속적인 비판을 받아왔습니다. Hobby 및 Pro 티어는 소규모에서 비교적 저렴하지만, 포함된 초기 단위를 모두 사용한 후 가격이 급격히 상승합니다.\n\n# 주요 변경 사항\n\n2024년 6월 25일부터, Vercel은 비용을 더 증분 단위로 분할하여 개발자들이 비용을 더 효율적으로 최적화할 수 있도록 할 것입니다.\n\n## 대역폭\n\n\n\n버셀의 요금 체계에서 주요 고민거리는 과거에 고대로 높았던 대역폭 비용이었습니다. 대역폭은 버셀 서버 간 및 외부로 전송된 데이터 양을 의미합니다. 예를 들어, 랜딩 페이지에 많은 이미지나 다른 정적 파일이 포함되어 있다면, 이 비용이 빠르게 누적될 수 있습니다.\n\n현재 Pro 티어는 한 사용자당 월 $20이며 1TB의 대역폭을 포괄하는데 상당히 관대합니다. 그 이후로는 100GB당 $40 또는 다른 말로 $400/TB입니다.\n\n변경 후에도 Pro 티어의 요금은 한 사용자당 월 $20으로 유지되지만, 대역폭 비용은 다음과 같은 지표와 대부분의 지역에서의 소비 비용으로 분할될 것입니다 (지역별 요금은 여기서 확인하세요: https://vercel.com/docs/pricing#regional-pricing):\n\n- 아웃 바운드 데이터 전송 (버셀에서 사용자로): 1TB 포함, 한계 초과 후 $0.15/GB (또는 $150/TB)\n- 오리진 데이터 전송 (버셀 함수에서 버셀 엣지 네트워크로, 주로 캐시 미스와 API 루트): 월 100GB 포함, 한계 초과 후 $0.06/GB (또는 $60/TB)\n- 엣지 요청 (요청 횟수): 월 10백만 건 포함, 한계 초과 후 $2.00/백만 건\n- 증분형 정적 재생성: 포함 없음, 캐시 읽기당 $0.40백만 건 및 캐시 쓰기당 $4.00백만 건\n\n\n\n또한 100GB 단위로 청구되던 것 대신 이제는 1GB 단위로 청구됩니다. 이는 더 정확하고 독점적으로 더 낮거나 동등한 비용을 제공하게 됩니다 (예: 105GB를 사용한다면 200GB가 아니라 105GB에 대해 청구됩니다).\n\n## 기능\n\n대역폭 가격 변경 외에도, 기능 가격도 변경되었는데, 이것은 주로 엣지 네트워크 캐시 미스와 ISR 렌더링을 수행하고 API 루트를 제공하기 위해 사용됩니다.\n\n현재 Pro 티어에는 1,000 GB-시간의 컴퓨팅 및 100만 회 호출이 포함되어 있으며 추가 사용량에 대한 비용은 GB-시간 당 $0.40입니다.\n\n\n\n변경 사항 후, Pro 티어의 기능 비용은 다음 지표 및 소비 비용으로 분해될 것입니다:\n\n- 호출: 1개월에 1백만 건이 포함되어 있으며, 한계를 넘은 후에는 백만 당 $2.00\n- 컴퓨팅: 1,000GB-시간/월이 포함되어 있으며, 한계를 넘은 후에는 GB-시간 당 $0.18\n\n## 무료 티어\n\nVercel은 공지에서 Hobby/무료 티어에는 변경 사항이 없을 것이라고 밝혔습니다.\n\n\n\n# 평가\n\n이 발표에 관심이 있는 대부분의 사람들이 한 가지 궁금증을 가지고 있습니다. \"이것이 내 프로젝트의 청구서에 어떤 영향을 미칠까?\" Vercel은 기존 프로젝트 비용에 대한 변경 사항에 대해 다음과 같이 말했습니다:\n\n내가 가격을 살펴보면, 현재 프로젝트의 주요 비용 요인이 상당히 줄어들었으므로 일반적으로 이 성명에 동의할 것 같습니다. 그러나 구체적인 응용 프로그램에 따라 상황이 달라질 수 있습니다. 일부 응용 프로그램은 보다 추상적인 메트릭을 최대한 활용하도록 구축되어 있어, 이러한 새로운 세세한 메트릭을 사용하지 못할 수도 있습니다. 지금까지 우리는 기존의 이메일 중 일부를 보고, 고객들로부터 증가와 감소가 모두 나타났고, 때로는 양 방향으로 극심히 발생했다는 것을 알아냈습니다.\n\n예를 들어, 이 사용자는 예상 월 청구서가 $242에서 $188로 22% 감소했다고 보고했습니다:\n\n\n\n한편, 이 사용자는 간단한 $20/월 Pro 월간 요금에서 10배인 $201/월로 예상 청구액이 증가한 것을 발견했습니다.\n\n# 비용 최적화\n\n이 경우 높은 요금이 발생한 가장 가능성이 높은 이유는 ISR의 높은 사용량(희망적으로 최적화 가능)이거나 높은 요청 수(이 프로젝트들이 이전에는 대역폭에 미친 영향이 적었음을 의미)일 것 같습니다. Vercel은 이러한 새로운 지표에 대한 프로젝트 최적화 팁을 몇 가지 제공했는데, 이는 여기에서 확인할 수 있습니다:\n\n- 네트워킹 (데이터 전송 및 엣지 요청): [링크](https://vercel.com/docs/pricing/networking)\n- 함수: [링크](https://vercel.com/docs/pricing/serverless-functions)\n- ISR 데이터 캐시: [링크](https://vercel.com/docs/pricing/data-cache)\n\n\n\n게다가 Vercel은 \"100% 할인 (Fast Origin Transfer 및 Edge Requests)\"을 통해 비용이 증가하는 프로젝트에 대한 최적화 시간을 추가로 3개월 제공하고 있습니다.\n\n가격 변화가 발생하기 전에 새로운 비용에 대한 프로젝트 최적화에 대한 자세한 안내서를 Vercel 및 커뮤니티로부터 더 많이 보고 싶습니다. 이상적으로는 Vercel이 현재 프로젝트를 평가할 수 있는 계산기/비용 추정프로그램을 제공하여 이러한 지표를 최적화하는 프로젝트를 조정한 후 어떤 가격이 될지 확인할 수 있으면 좋겠습니다.\n\n# 대안(가장 저렴한 것부터 가장 비싼 것까지)\n\n## Vercel 대 AWS (OpenNext)\n\n\n\n가장 저렴한 대안은 Vercel의 인프라를 활용하는 것이고, Vercel은 기본적으로 AWS 서버리스 기술을 사용하여 인프라를 구축합니다. Vercel이 제공하는 서버리스 확장성과 동일한 기능을 갖추기 위해 AWS를 NextJS에 활용하는 것은 쉽지 않습니다. 왜냐하면 Vercel은 오픈 소스 NextJS 프로젝트에 포함된 것보다 더 많은 빌드 단계를 추가했기 때문입니다. 그러나 SST의 OpenNext 프로젝트를 사용하면 AWS Lambda, CloudFront 및 기타 AWS 서비스로 배포하여 Vercel의 기능과 유사한 결과를 얻을 수 있습니다.\n\n가격\n\n- 구독 비용: 월 $0\n- 아웃바운드 데이터 전송 (AWS CloudFront에서 사용자로): 1TB/월 포함, 한계 초과 후 가격: $0.085/GB (또는 $85/TB)로 감소 단계적으로 최대 $0.025/GB까지 페타바이트 규모 애플리케이션에 대한\n- 오리진 데이터 전송 (CloudFront에서 AWS Lambda로, 특히 POST, PUT 등에 대해 - 주의: AWS Lambda에서 CloudFront로는 무료): 포함 없음, $0.02/GB\n- 엣지 요청 (CloudFront 요청 수): 10백만 개/월 포함 + 20만 개/월 캐시 미스 포함, 한계 이후 $1.00/백만 요청 + $0.40/백만 캐시 미스 S3 GET 요청\n- 증분 정적 재생성: 포함 사항 없음, 이를 양적으로 측정하는 쉬운 방법은 없으나 여기 아키텍처를 확인해보세요: https://open-next.js.org/inner_workings/architecture\n- 기능 호출: 1백만 개/월 포함, 한계 이후 $0.20/백만\n- 기능 컴퓨트: 888GB-시/월 포함, 한계 이후 $0.06/GB-시\n- 추가 사항: 모든 AWS 비용을 포함하는 것은 어려울 수 있습니다. 특히 Vercel은 많은 기능을 추상화하므로 인증서, 호스팅 영역, WAF 등 애플리케이션 비용에 추가 여유 마진을 고려해야 합니다. 또한 이는 CI/CD, 빌드 프로세스, 캐시 무효화 등을 포함하지 않으므로 배포 비용에 대한 여유 마진도 고려해야 합니다.\n\n제한 사항\n\n\n\n- 앱 라우터 지원이 부족합니다.\n- 개발자 도구가 없습니다.\n- 클라우드 기반 배포 파이프라인/프로세스가 포함되어 있지 않습니다.\n- Git 제공업체와의 통합이 포함되어 있지 않습니다.\n- 배포 미리보기가 지원되지 않습니다.\n- 모니터링이 포함되어 있지 않습니다.\n- WAF 가 포함되어 있지 않습니다.\n\n## Vercel vs Cloudflare Pages + Workers\n\nCloudflare는 매우 널리 사용되는 CDN 및 방화벽으로, NextJS 애플리케이션을 호스팅할 수 있는 옵션이 있습니다.\n\n가격\n\n\n\n- 구독 비용: 월 $5–30(페이지 티어에 따라 다름)\r\n- 아웃바운드 데이터 전송 (AWS CloudFront에서 사용자로): 무료\r\n- 오리진 데이터 전송 (Cloudflare 서비스에서 다른 Cloudflare 서비스로): 무료\r\n- 엣지 요청 (CloudFront의 수): 무료\r\n- 증분 정적 재생성: CloudFlare에서 지원되지 않음\r\n- 함수 호출: 1개월당 100만 회 포함, 한계 초과 시 100만 달러당 $0.15\r\n- 함수 컴퓨트: 월 111GB-시간 포함, 한계 초과 시 GB-시간 당 $0.45\r\n- 데이터 저장(정적 파일 및 ISR 캐시): 월 당 $0.023/GB\n\n제한 사항\n\n- 증분 정적 재생성(ISR) 지원되지 않음\n- 특정 노드 API와의 호환성 문제가 발생할 수 있는 엣지 런타임만 지원\n\n## Vercel vs AWS(Amplify)\n\n\n\nAWS는 Amplify라는 프레임워크를 사용하여 프론트엔드 인프라를 더 간단하게 관리할 수 있는 서비스를 직접 제공합니다. Amplify를 사용하면 NextJS를 간편하게 배포할 수 있습니다.\n\n가격\n\n- 구독 비용: 월 0달러\n- 아웃바운드 데이터 전송 (AWS Amplify에서 사용자로): 포함 안 함, 1GB당 0.15달러(또는 1TB당 150달러)\n- 오리진 데이터 전송 (AWS 서비스에서 다른 AWS 서비스로): 무료\n- 엣지 요청 (요청 횟수): 무료\n- 증분 정적 재생성: 이 지표로 측정되지 않음\n- 함수 호출: 포함 안 함, 임계점 이후 1백만 번당 0.30달러\n- 함수 컴퓨트: 포함 안 함, 임계점 이후 1GB-시간당 0.20달러\n- 데이터 저장 (정적 파일 및 ISR 캐시): 월 1GB당 0.023달러\n- 빌드 및 배포: 분당 0.01달러\n\n제한 사항\n\n\n\n- Edge API routes (Edge middleware 포함)는 지원되지 않습니다\n- On-demand incremental static regeneration (ISR)는 지원되지 않습니다\n- 국제화(i18n) 자동 로캘 탐지는 지원되지 않습니다\n- Next.js streaming은 지원되지 않습니다\n\n## Vercel vs Netlify\n\n마지막으로, Netlify는 NextJS 애플리케이션에 좋은 지원을 제공하는 다른 인기 있는 프론트엔드 인프라 솔루션입니다.\n\n가격\n\n\n\n- Netlify로부터 사용자들로의 아웃바운드 데이터 전송: 1TB 포함, 임계치 이후 $0.55/GB (또는 $550/TB)\n- 오리진 데이터 전송 (Netlify 서비스로부터 다른 Netlify 서비스로): 무료\n- 에지 요청 (요청 횟수): 무료\n- 증분 정적 재생성: 이를 양적으로 측정하기 어려우나 이 링크를 통해 작동 방식을 확인해보세요: [여기를 클릭하여 Netlify 문서 확인](https://docs.netlify.com/frameworks/next-js/runtime-v4/incremental-static-regeneration/)\n- 호출 + 컴퓨팅: 125,000 요청/월 + 100시간 컴퓨팅 포함, 그 후 1,875,000 요청 + 900시간에 대해 $25, 이후 500,000 요청 + 500시간마다 $19/증분\n\n제한사항\n\n- 에지 런타임에 설정된 SSR 페이지는 함수 영역에서 실행됩니다\n- Next.js 구성에서의 리라이트는 public 디렉토리의 정적 파일을 가리킬 수 없습니다\n- 안정성이나 실험적으로 표시된 Next.js 기능은 지원되지 않을 수 있습니다\n- next/image 이미지는 Netlify에서 작동하지 않습니다\n\n# 결론\n\n\n\n벌써 많은 개발자들에게는 Vercel의 요금 체계 변화가 이긴 것 같아요. Vercel을 사용할지 고려하던 많은 사람들에게 오랫동안 골칫거리였어요. 일부 요금 인상 때문에 많은 개발자들이 회의적인데, 적절한 최적화를 통해 그 인상을 크게 느끼지 않을 수도 있어요. 말하고자 하는 바는, 다른 옵션들이 계속해서 NextJS 기능을 지원해오면서, 편의성과 기능 지원 수준에 따라 더 저렴한 옵션을 제공하는 것이 많다는 거예요. Vercel이 여전히 NextJS 앱을 배포하기 위한 가장 편리한 옵션이긴 하지만, 다른 옵션들도 작년이나 최근 두 해 사이에 매력적으로 발전해왔고, 그들의 비용 대비 이득을 고려할 만하다고 생각돼요.","ogImage":{"url":"/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png"},"coverImage":"/assets/img/2024-05-12-VercelJustChangeditsPricingHowDoesitCompare_0.png","tag":["Tech"],"readingTime":7}],"page":"73","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"73"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>