<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/39" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/39" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular 번들을 분석하는 방법" href="/post/2024-06-20-HowToAnalyzeAngularBundle"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 번들을 분석하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowToAnalyzeAngularBundle_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 번들을 분석하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 번들을 분석하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Services in Angular" href="/post/2024-06-20-ServicesinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Services in Angular" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ServicesinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Services in Angular" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Services in Angular</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러와 고랭 빠른 안내 - 고급" href="/post/2024-06-20-AngularandGolangARapidGuideAdvanced"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러와 고랭 빠른 안내 - 고급" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularandGolangARapidGuideAdvanced_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러와 고랭 빠른 안내 - 고급" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러와 고랭 빠른 안내 - 고급</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="각진 노하우 프로젝트 구조와 조직에 대한 팁" href="/post/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="각진 노하우 프로젝트 구조와 조직에 대한 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="각진 노하우 프로젝트 구조와 조직에 대한 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">각진 노하우 프로젝트 구조와 조직에 대한 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" href="/post/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" href="/post/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" href="/post/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" href="/post/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" href="/post/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 공부 순수하고 불량한" href="/post/2024-06-20-JavascriptattheNunneryPureUndefiled"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 공부 순수하고 불량한" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 공부 순수하고 불량한" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 공부 순수하고 불량한</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link posts_-active__YVJEi" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular 번들을 분석하는 방법","description":"","date":"2024-06-20 03:01","slug":"2024-06-20-HowToAnalyzeAngularBundle","content":"\n\n## 세 가지 간단한 도구를 사용하여 Angular 번들 크기를 분석해 보세요\n\n만약 당신의 Angular 애플리케이션의 번들 크기를 알고 싶다면 단순히 `ng build`를 실행하고 터미널에서 결과를 확인할 수 있습니다. 다음과 같은 결과를 얻게 될 것입니다:\n\n![분석 이미지](/assets/img/2024-06-20-HowToAnalyzeAngularBundle_0.png)\n\n이 경우에 원본 크기는 1.02 MB이고 예상 전송 크기는 245.35 kB입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! \n\n결과 아래에는 애플리케이션 번들 크기의 구성 요소가 가장 큰 것부터 가장 작은 것까지 나열되어 있습니다.\n\n요령으로 Angular 번들을 살펴볼 수 있는 빠른 방법이겠죠.\n\n이제 이것을 시각화해보고 싶다면 어떻게 할까요? 적어도 몇 가지 방법이 있습니다:\n\n- Webpack Bundle Analyzer (클래식)\n- Source Map Explorer\n- Esbuild Analyze (Angular `17)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹팩 번들 분석기\n\n웹팩 번들 분석기는 \"웹팩 출력 파일의 크기를 대화식 확대/축소 트리맵으로 시각화하는 매우 인기 있는 방법\"입니다. 그냥 설치하면 바로 사용할 수 있고 충분히 좋을 수도 있습니다.\n\n다음 명령어로 웹팩 번들 분석기를 설치하세요:\n\n```js\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번들 내용을 시각화하는 가장 쉬운 방법은 package.json에 스크립트를 추가하는 것입니다. 예를 들어:\n\n```js\n// package.json\n\n{\n    \"name\": \"your-app-name\",\n    \"scripts\": { \n        \"ng\": \"ng\",\n        \"e2e\": \"ng e2e\",\n        \"analyze-webpack\": \"ng build --stats-json \u0026\u0026 webpack-bundle-analyzer dist/your-app-name/stats.json\"\n    },\n    ...\n}\n```\n\n그래서 다음 명령을 실행하면\n\n```js\nnpm run analyze-webpack\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 여러분의 앱을 빌드하고 새롭게 생성된 dist/your-app-name 폴더 내에 stats.json 파일을 만듭니다.\n\n마지막으로 webpack-bundle-analyzer는 기본 주소인 http://127.0.0.1:8888/에서 새 탭을 자동으로 엽니다.\n\nWebpack Bundle Analyzer 문서에 나와 있는 대로 번들을 보기 쉽고 간단하게 확인할 수 있습니다.\n\n![Webpack Bundle Analyzer](https://miro.medium.com/v2/resize:fit:1400/0*wsCwLvr_n3lt96pc.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n덤으로, Webpack Bundle Analyzer는 청크를 필터링할 수 있는 편리한 사이드바를 제공합니다. 가장 큰 부분에 집중하기에 매우 유용합니다.\n\n![이미지](/assets/img/2024-06-20-HowToAnalyzeAngularBundle_1.png)\n\n내 결론: Webpack Bundle Analyzer는 제 요구에 완벽하게 작동합니다. 그러나 2020년에 Angular 팀은 이 빌드 정보가 정확하지 않을 수 있다고 제안했습니다.\n\n해결책으로는 소스 맵 익스플로러를 권장했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소스 맵 익스플로러\n\n소스 맵 익스플로러는 코드의 원본을 파악하고 디버깅하는 데 도움을 주는 트리 맵 시각화를 제공합니다.\n\n문서를 따라 설치하려면 전역으로 다음을 실행하세요:\n\n```js\nnpm install -g source-map-explorer\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번들 내용을 가장 쉽게 시각화하는 방법은 package.json에 스크립트를 추가하는 것입니다. 예를 들어,\n\n```js\n// package.json\n\n{\n    \"name\": \"your-app-name\",\n    \"scripts\": { \n        \"ng\": \"ng\",\n        \"e2e\": \"ng e2e\",\n        \"analyze-webpack\": \"ng build --stats-json \u0026\u0026 webpack-bundle-analyzer dist/your-app-name/stats.json\",\n        \"analyze-sourcemap\": \"ng build --source-map \u0026\u0026 source-map-explorer dist/your-app-name/main.js\"\n    },\n    ...\n}\n```\n\n그래서 다음을 실행하면\n\n```js\nnpm run analyze-sourcemap\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! Angular 애플리케이션을 개발하실 예정이시군요. 소스 맵이 함께 제공되어 Source Map Explorer에서 분석할 수 있습니다.\n\n위 스크립트는 main.js를 분석하고 \"덜 화려하고\" 최소한의 방식으로 시각화할 것입니다. 조금은 슬픕니다.\n\n하지만 상호작용성이 뛰어나고 사용하기 쉽습니다.\n\n![이미지](/assets/img/2024-06-20-HowToAnalyzeAngularBundle_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 경우에는 Webpack Bundle Analyzer와 Source Map Explorer로 보고된 정보 사이에 일부 차이점을 발견할 수 있어요. main.js의 크기는 다음과 같습니다:\n\n- Webpack Bundle Analyzer — 630.38 KB\n- Source Map Explorer — 630.45 KB\n\n# Esbuild Analyze\n\nAngular v17부터 2024년에는 번들 크기를 검사할 수 있는 esbuild analyze 또는 esbuild-visualizer를 사용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 문서에 따르면 다음과 같습니다.\n\n![image](/assets/img/2024-06-20-HowToAnalyzeAngularBundle_3.png)\n\nng build your-app-name --stats-json 명령을 실행하면 응용 프로그램의 루트 폴더 안에 stats.json 파일이 생성됩니다.\n\n그러나 문서에서 제안하는 대로 새로 생성된 stats.json을 esbuild 번들 크기 분석기에 가져오려고 시도하면 작동하지 않는데, 그 이유는 stats.json이 분석기에서 요구하는 메타데이터 JSON 형식과 일치하지 않기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약간 실망스럽네요. 제가 기대했던대로 쉽게 작동될 줄 알았는데요.\n\n그래서 \"https://esbuild.github.io/analyze/\"으로 분석할 수 있는 'stats.json' 파일을 생성한다는 말은 반 정도 맞습니다. 파일은 받을 수 있지만 사용할 수는 없죠.\n\n아래는 구석통을 설치하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nnpm install --save-exact --save-dev esbuild\n```\n\n그런 다음 다음과 같은 명령을 루트 폴더의 터미널에서 실행하세요:\n\n```js\n./node_modules/.bin/esbuild src/main.ts --bundle --metafile=meta.json --outfile=out.js\n```\n\n이렇게 길고 이상한 명령을 한 번에 실행하려면 package.json에 스크립트를 만들었습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// packjage.json\n\n{\n   \"name\": \"your-app-name\",\n    \"scripts\": { \n        \"ng\": \"ng\",\n        \"e2e\": \"ng e2e\",\n        \"analyze-webpack\": \"ng build --stats-json \u0026\u0026 webpack-bundle-analyzer dist/your-app-name/stats.json\",\n        \"analyze-sourcemap\": \"ng build --source-map \u0026\u0026 source-map-explorer dist/your-app-name/main.js\",\n        \"analyze-esbuild\": \"ng build \u0026\u0026 esbuild dist/your-app-name/main.js --bundle --metafile=dist/your-app-name/meta.json --outfile=out.js\"\n    },\n    \"dependencies\": { ... },\n    \"devDependencies\": { ... },\n}\n```\n\n따라서,\n\n```js\nnpm run analyze-esbuild\n```\n\n을 실행하면, 애플리케이션 루트 폴더에 meta.json 파일이 생성됩니다. 그런 다음 meta.json을 esbuild 번들 크기 분석기에서 사용하여 번들을 시각화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 시각화는 썬버스트 차트이지만 다른 유형으로 이동할 수 있어요.\n\n![Sunburst Chart](/assets/img/2024-06-20-HowToAnalyzeAngularBundle_5.png)\n\n## 결론\n\n대부분은 당신의 요구에 따라 다릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 의견으로는, 대부분의 사용자들이 ng build에서 출력된 원본 크기를 확인하는 것이 도움이 될 것이라고 생각합니다. 원본 크기가 \"너무 크다\"고 판단될 경우, 어떤 의미인지 논의할 수 있지만 번들 분석 도구를 활용해보는 것이 좋습니다.\n\n내 의견으로는 가장 빠른 해결책은 webpack-bundle-analyzer입니다. 그러나 esbuild-analyze와 비교했을 때 시각화 가능성 면에서 약간 부족하다고 생각합니다.","ogImage":{"url":"/assets/img/2024-06-20-HowToAnalyzeAngularBundle_0.png"},"coverImage":"/assets/img/2024-06-20-HowToAnalyzeAngularBundle_0.png","tag":["Tech"],"readingTime":6},{"title":"Services in Angular","description":"","date":"2024-06-20 02:58","slug":"2024-06-20-ServicesinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-ServicesinAngular_0.png\" /\u003e\n\n알다시피, Angular은 Google이 개발한 TypeScript 프레임워크로 싱글 페이지 응용 프로그램을 개발하는 데 사용됩니다. Angular의 가장 중요한 기능 중 하나는 서비스입니다.\n\n이 기사에서는 Angular 서비스가 무엇인지, 왜 중요한지, 그리고 애플리케이션에서 서비스를 생성하고 사용하는 방법을 살펴볼 것입니다. 또한 애플리케이션에서 사용할 수 있는 다양한 유형의 서비스와 그들과 작업하는 데 가장 좋은 방법을 살펴볼 것입니다. 중간에 우리는 코드 예제와 실제 사용 사례를 제공하여 개념을 더 잘 이해하고 실무에 적용하는 방법을 돕겠습니다.\n\n이 기사를 마치면 Angular 서비스에 대한 sol 이름을 갖추게 되고 보다 효율적이고 효과적인 애플리케이션을 구축하는 방법을 알 수 있을 것입니다. Angular를 막 시작했다면 또는 기술을 향상시키려는 숙련된 개발자라면, 이 기사는 여러분을 위한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 목차:\n\n- Angular 서비스 소개\n- Angular 서비스 생성\n- 서비스의 싱글톤 특성 이해\n- 내장 서비스 (예: HttpClient, Router)\n- 사용자 정의 서비스\n- Angular 애플리케이션에서 서비스의 중요성\n- Angular 서비스 작업을 위한 최상의 방법\n- 추가 학습 자료\n\n시작해 봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 앱의 중요한 구성 요소 중 하나는 Angular 서비스입니다. 서비스는 종종 데이터 검색, 조작 및 저장과 같은 기능을 그룹화하는 데 사용됩니다. 이러한 기능은 여러 구성 요소에서 사용할 수 있습니다.\n\n또한, 서비스는 계산 수행, 비즈니스 로직 구현 및 외부 API와 통신하는 데 활용될 수 있습니다.\n\nAngular에서 클래스로 선언되기 때문에 서비스는 의존성 주입 시스템을 사용하여 구성 요소 또는 다른 서비스에 주입될 수 있습니다.\n\n일관성 유지와 메모리 누수를 방지하기 위해 Angular 서비스는 싱글톤입니다. 이는 애플리케이션 전체에서 서비스의 단일 인스턴스만 존재한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 서비스 생성하기\n\n## 단계 1: 새 서비스 생성\n\nAngular에서 새로운 서비스를 생성하려면 Angular CLI 명령 ng generate service를 사용해야 합니다. 터미널이나 명령 프롬프트를 열고 Angular 애플리케이션의 루트 디렉토리로 이동해주세요. 다음 명령을 실행하여 새로운 서비스를 생성하세요:\n\n```js\nng generate service my-service\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령은 응용 프로그램의 app 폴더에 my-service.service.ts라는 새 파일을 만듭니다. 이 파일은 서비스의 기본 구조를 포함하고 있습니다.\n\n## 단계 2: 서비스 클래스 정의하기\n\n이전 단계에서 만들어진 my-service.service.ts 파일을 엽니다. 이 파일은 서비스를 위한 기본 클래스 정의를 포함하고 있습니다. 이 클래스에 우리만의 메서드와 속성을 추가하여 서비스의 기능을 정의해야 합니다. 아래는 간단한 서비스 클래스의 예시입니다:\n\n```js\nimport { Injectable } from '@angular/core';\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  private data: string[] = [];\n  getData(): string[] {\n    return this.data;\n  }\n  addData(newData: string) {\n    this.data.push(newData);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 MyService라는 서비스를 정의했습니다. 이 서비스에는 문자열 배열인 data라는 private 속성과 getData() 및 addData()라는 두 가지 메서드가 있습니다. getData() 메서드는 간단히 data 속성을 반환하고, addData() 메서드는 새로운 문자열을 data 배열에 추가합니다.\n\n이 클래스가 서비스임을 나타내기 위해 @Injectable 데코레이터를 사용했음을 주목하세요. 또한 providedIn 속성을 `root`로 설정하여 서비스가 싱글톤으로 생성되고 응용 프로그램의 루트 모듈에 주입될 것임을 나타냈습니다.\n\n## 단계 3: 서비스를 컴포넌트에 주입하기\n\n컴포넌트에서 서비스를 사용하려면 Angular의 의존성 주입 시스템을 사용하여 서비스를 주입해야 합니다. app.component.ts와 같은 컴포넌트 파일을 열고 다음 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from '@angular/core';\nimport { MyService } from './my-service.service';\nexport class AppComponent {\n  data: string[];\n  newItem: string;\n  constructor(private myService: MyService) {\n    this.data = myService.getData();\n  }\n  addItem() {\n    this.myService.addData(this.newItem);\n    this.newItem = '';\n  }\n}\n``` \n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003eData:\u003c/h2\u003e\n  \u003cul\u003e\n    \u003cli *ngFor=\"let item of data\"\u003e{{item}}\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cinput [(ngModel)]=\"newItem\" placeholder=\"New item...\"\u003e\n  \u003cbutton (click)=\"addItem()\"\u003eAdd\u003c/button\u003e\n\u003c/div\u003e\n```\n\n이 코드에서는 MyService 클래스를 가져와서 구성 요소의 constructor에 주입했습니다. 또한 서비스의 data 속성으로 구성 요소에 프로퍼티 data를 추가했습니다. 마지막으로 사용자가 데이터 배열에 새 항목을 추가할 수 있도록 input과 button을 추가했습니다.\n\n서비스의 데이터를 구성 요소의 템플릿에 표시하려면 *ngFor 지시문을 추가하여 데이터 배열을 반복하고 각 항목을 목록에 표시했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴포넌트의 newItem 속성도 양방향 데이터 바인딩인 [(ngModel)]을 이용하여 입력 필드에 바인딩했습니다. 사용자가 \"추가\" 버튼을 클릭하면 컴포넌트의 addItem() 메서드가 호출됩니다. 이 메서드는 서비스의 addData() 메서드를 호출하여 새로운 항목을 데이터 배열에 추가합니다.\n\n## 단계 4: 모듈에 서비스 추가\n\n서비스를 주입 가능하게 하려면 해당 서비스를 모듈의 providers 배열에 추가해야 합니다. app.module.ts 파일을 열고 아래 코드를 추가하세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\nimport { AppComponent } from './app.component';\nimport { MyService } from './my-service.service';\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [\n    MyService\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드에서는 MyService 클래스를 가져와 @NgModule 데코레이터의 providers 배열에 추가했습니다. 이렇게하면 서비스가 응용 프로그램 전반에 걸쳐 주입 가능하게 됩니다.\n\n# 서비스의 싱글톤 특성 이해하기\n\nAngular에서 서비스는 일반적으로 싱글톤으로 설계됩니다. 이는 서비스가 컴포넌트나 다른 서비스에 주입될 때 항상 동일한 서비스 인스턴스를 반환한다는 것을 의미합니다. 이 동작은 서비스를 응용 프로그램 전체에서 일관되고 예측 가능하게 사용할 수 있도록 해주어 종종 원하는 바입니다.\n\n서비스의 싱글톤 특성을 이해하는 것은 서비스를 설계하고 사용하는 방식에 영향을 미치기 때문에 중요합니다. 이 기사에서는 싱글톤 개념을 자세히 살펴보고 Angular 응용 프로그램에서 어떻게 사용될 수 있는지 예를 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 싱글턴이란 무엇인가요?\n\n싱글턴은 클래스의 인스턴스화를 단 한 번으로 제한하고 해당 인스턴스에 대한 전역 액세스 지점을 제공하는 디자인 패턴입니다. 즉, 싱글턴은 한 번만 인스턴스화될 수 있는 클래스이며, 이 인스턴스는 클래스의 모든 사용자에 의해 공유됩니다.\n\nAngular 서비스의 맥락에서, 싱글턴 서비스는 한 번 생성되고 애플리케이션 전반에 걸쳐 공유되는 서비스입니다. 서비스가 컴포넌트나 다른 서비스에 주입될 때, Angular은 항상 동일한 서비스 인스턴스를 반환합니다.\n\n# Angular에서 싱글턴을 사용하는 이유는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 애플리케이션에서 싱글톤이 일반적으로 사용되는 몇 가지 이유가 있습니다:\n\n## 일관성\n\n서비스가 싱글톤임을 보장함으로써 해당 서비스를 사용하는 모든 컴포넌트와 서비스가 동일한 서비스 인스턴스에 액세스 할 수 있다고 확신할 수 있습니다. 이는 애플리케이션 전체에서 일관성을 유지하는 데 도움이 될 수 있습니다.\n\n## 메모리 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 서비스 인스턴스를 만드는 것은 메모리 누수와 다른 문제를 야기할 수 있습니다. 서비스를 싱글톤으로 만들면 서비스의 유일한 인스턴스가 있음을 보장하여 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다.\n\n## 성능\n\n서비스를 만들고 초기화하는 것은 특히 서비스가 해결해야 할 종속성이 있는 경우 비용이 많이 드는 작업일 수 있습니다. 서비스를 싱글톤으로 만들면 서비스를 여러 번 만들고 초기화하는 오버헤드를 피할 수 있습니다.\n\n## 내장 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 웹 애플리케이션을 개발하는 데 사용할 수 있는 여러 내장 서비스를 제공합니다. 이러한 서비스는 Angular 프레임워크의 일부이며 컴포넌트로 쉽게 가져올 수 있습니다. 이 기사에서는 Angular에서 가장 일반적으로 사용되는 내장 서비스 몇 가지를 탐색하고, Angular 애플리케이션에서 어떻게 사용될 수 있는지 예제를 제공하겠습니다.\n\n## 1. HttpClient\n\nHttpClient 서비스는 서버에 HTTP 요청을 보낼 수 있는 Angular 모듈입니다. RESTful API와 상호 작용하고 백엔드 서버에서 데이터를 검색하는 데 사용할 수 있는 강력한 서비스입니다.\n\n- Angular 프로젝트에서 todo.service.ts라는 새 서비스 파일을 만들고 HttpClient 서비스를 가져오세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TodoService {\n  constructor(private http: HttpClient) { }\n  \n  getTodos() {\n    return this.http.get\u003cany[]\u003e('https://jsonplaceholder.typicode.com/todos');\n  }\n  \n  getTodoById(id: number) {\n    return this.http.get\u003cany\u003e(`https://jsonplaceholder.typicode.com/todos/${id}`);\n  }\n}\n```\n\n- 당신의 컴포넌트에서 TodoService를 가져와서 메서드에 구독하세요:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { TodoService } from './todo.service';\n\n@Component({\n  selector: 'app-todo-list',\n  template: `\n    \u003ch1\u003e할 일 목록\u003c/h1\u003e\n    \u003cul\u003e\n      \u003cli *ngFor=\"let todo of todos\"\u003e{{ todo.title }}\u003c/li\u003e\n    \u003c/ul\u003e\n  `\n})\nexport class TodoListComponent implements OnInit {\n  todos: any[];\n  \n  constructor(private todoService: TodoService) { }\n  \n  ngOnInit() {\n    this.todoService.getTodos().subscribe(response =\u003e {\n      this.todos = response;\n    });\n  }\n}\n```\n\n- 별도의 컴포넌트에서 getTodoById() 메서드를 사용하세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { TodoService } from './todo.service';\n\n@Component({\n  selector: 'app-todo-details',\n  template: `\n    \u003ch1\u003eTodo Details\u003c/h1\u003e\n      \u003cp\u003eTitle: { todo.title }\u003c/p\u003e\n      \u003cp\u003eCompleted: { todo.completed }\u003c/p\u003e\n  `\n})\nexport class TodoDetailsComponent implements OnInit {\n  todo: any;\n\n  constructor(\n    private route: ActivatedRoute,\n    private todoService: TodoService\n  ) { }\n\n  ngOnInit() {\n    const id = +this.route.snapshot.paramMap.get('id');\n    this.todoService.getTodoById(id).subscribe(response =\u003e {\n      this.todo = response;\n    });\n  }\n}\n```\n\n이 예시에서는 두 개의 메서드, getTodos()와 getTodoById(),를 가진 별도의 TodoService를 만들었습니다. 이러한 메서드는 HttpClient 서비스를 사용하여 원격 서버에서 할 일 목록을 검색하기 위해 HTTP 요청을 수행합니다. TodoListComponent에서 TodoService를 주입하고 getTodos() 메서드를 구독하여 할 일 목록을 검색하고 해당 내용을 템플릿에 표시했습니다. TodoDetailsComponent에서는 getTodoById() 메서드를 사용하여 라우트 매개변수에서 ID로 특정 할 일을 검색하고 그 내용을 템플릿에 표시했습니다.\n\n## 2. Router\n\nAngular 라우터 서비스는 Angular에서 내장된 서비스로, Angular 애플리케이션의 다른 뷰나 컴포넌트 간의 탐색을 관리하는 역할을 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 홈 컴포넌트인 home.component.ts를 생성하고 about 컴포넌트로 이동할 수 있는 링크를 추가하세요:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-home',\n  template: `\n    \u003ch1\u003e홈 페이지에 오신 것을 환영합니다!\u003c/h1\u003e\n    \u003ca routerLink=\"/about\"\u003e회사 소개\u003c/a\u003e\n  `\n})\nexport class HomeComponent { }\n```\n\n- 어바웃 컴포넌트인 about.component.ts를 생성하고 홈 컴포넌트로 돌아갈 수 있는 링크를 추가하세요:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-about',\n  template: `\n    \u003ch1\u003e회사 소개\u003c/h1\u003e\n    \u003cp\u003e우리는 멋진 소프트웨어를 만드는 회사입니다!\u003c/p\u003e\n    \u003ca routerLink=\"/\"\u003e홈으로 돌아가기\u003c/a\u003e\n  `\n})\nexport class AboutComponent { }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- app-routing.module.ts 파일에서 앱 라우팅을 설정하세요:\n\n```typescript\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AboutComponent } from './about.component';\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n- 앱 컴포넌트 템플릿에 router-outlet 지시자를 추가하세요:\n\n```html\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 실행하면 HomeComponent가 표시되어 AboutComponent로 이동할 수 있는 링크가 나타납니다. 링크를 클릭하면 AboutComponent로 이동하고, AboutComponent에는 HomeComponent로 돌아갈 수 있는 링크가 있습니다.\n\n템플릿에서 routerLink 지시문을 사용하여 링크를 클릭하여 다른 경로로 이동할 수 있습니다. AppRoutingModule의 RouterModule를 사용하면 앱의 경로를 정의하고 컴포넌트 뷰에 매핑할 수 있습니다. 앱 컴포넌트 템플릿의 router-outlet 지시문은 Angular에 현재 경로에 따라 컴포넌트 뷰를 렌더링할 위치를 알려줍니다.\n\n# 3. 제목\n\nAngular의 Title 서비스는 현재 HTML 문서의 제목을 동적으로 설정하는 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 HTML 문서의 제목은 페이지의 head 섹션에서 `title` 태그를 사용하여 설정됩니다. Angular로 구축된 단일 페이지 애플리케이션(SPA)에서 사용자가 다른 뷰나 컴포넌트 간을 이동할 때 페이지의 제목을 동적으로 변경할 수 있습니다.\n\nTitle 서비스를 사용하면 Angular 컴포넌트에서 현재 HTML 문서의 제목을 동적으로 설정할 수 있습니다. Title 서비스를 컴포넌트에 주입하고, setTitle() 메서드를 호출하여 HTML 문서의 제목을 설정할 수 있습니다.\n\n- Angular CLI를 사용하여 새로운 Angular 서비스인 TitleService를 만드는 방법:\n\n```js\nng generate service TitleService\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- src/app 폴더에 생성된 title.service.ts 파일을 열어서 다음 코드를 추가해주세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { ActivatedRoute, NavigationEnd, Router } from '@angular/router';\nimport { filter, map } from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TitleService {\n  constructor(\n    private title: Title,\n    private router: Router,\n    private activatedRoute: ActivatedRoute\n  ) {}\n\n  setTitle() {\n    this.router.events\n      .pipe(\n        filter((event) =\u003e event instanceof NavigationEnd),\n        map(() =\u003e {\n          let route = this.activatedRoute;\n          while (route.firstChild) {\n            route = route.firstChild;\n          }\n          return route;\n        }),\n        filter((route) =\u003e route.outlet === 'primary'),\n        map((route) =\u003e {\n          const title = route.snapshot.data['title'];\n          if (title) {\n            return title;\n          }\n          return '내 앱 타이틀';\n        })\n      )\n      .subscribe((title) =\u003e this.title.setTitle(title));\n  }\n}\n```\n\n- 컴포넌트에서 TitleService를 import하고 setTitle() 메서드를 호출해주세요:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { TitleService } from './title.service';\n\n@Component({\n  selector: 'app-root',\n  template: `\u003crouter-outlet\u003e\u003c/router-outlet\u003e`\n})\nexport class AppComponent implements OnInit {\n  constructor(private titleService: TitleService) {}\n\n  ngOnInit() {\n    this.titleService.setTitle();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라우트 파일에 다음과 같이 각 라우트에 title 속성을 갖는 데이터 객체를 추가해 주세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AboutComponent } from './about.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: HomeComponent,\n    data: { title: '홈 페이지' }\n  },\n  {\n    path: 'about',\n    component: AboutComponent,\n    data: { title: '소개 페이지' }\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n```\n\n이제 TitleService 인스턴스의 setTitle() 메서드가 호출되면 라우트 데이터를 기반으로 웹페이지의 타이틀이 동적으로 업데이트됩니다.\n\n이것은 내장 서비스 중 일부일뿐이며, Angular 공식 문서에서 더 많은 것을 배울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 커스텀 서비스\n\nAngular에서는 커스텀 서비스를 만들어서 로직과 기능을 캡슐화하고 다양한 컴포넌트나 모듈 간에 공유할 수 있습니다. Angular에서 커스텀 서비스를 만드는 예제를 살펴보겠습니다:\n\n- 먼저, 프로젝트에서 새 파일을 만들어서 커스텀 서비스를 정의해야 합니다. 이 파일을 custom.service.ts라고 이름 짓겠습니다.\n- 이 파일에서 @angular/core 모듈에서 Injectable 데코레이터를 가져와야 합니다.\n\n```js\nimport { Injectable } from '@angular/core';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 다음으로, 우리는 사용자 정의 서비스 클래스에 @Injectable 데코레이터를 추가해야 합니다. 이는 Angular에게 이 클래스가 종속성과 함께 주입될 수 있다는 것을 알려줍니다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class CustomService {\n  constructor() { }\n  \n  // 여기에 사용자 정의 서비스 메서드 정의\n}\n```\n\n4. 이제 원하는 만큼 CustomService 클래스에 사용자 정의 메서드와 속성을 추가할 수 있습니다. 예를 들어, 인사 메시지를 반환하는 간단한 메서드를 만들어봅시다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class CustomService {\n  constructor() { }\n  \n  sayHello(name: string): string {\n    return `안녕, ${name}!`;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. 컴포넌트에서 사용자 정의 서비스를 사용하려면 해당 서비스를 컴포넌트의 생성자에 주입해야 합니다. MyComponent라는 새 컴포넌트를 생성하고 CustomService를 주입해 보겠습니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { CustomService } from './custom.service';\n@Component({\n  selector: 'app-my-component',\n  template: '\u003cp\u003e{ message }\u003c/p\u003e'\n})\nexport class MyComponent {\n  message: string;\n  constructor(private customService: CustomService) {\n    this.message = this.customService.sayHello('World');\n  }\n}\n```\n\n이 예시에서는 CustomService를 MyComponent 생성자에 주입하고 해당 서비스를 사용하여 컴포넌트의 메시지 속성을 설정했습니다. CustomService 클래스의 sayHello 메소드를 'World' 인자와 함께 호출하여 반환된 인사 메시지를 메시지 속성에 저장했습니다.\n\n이제 Angular 애플리케이션 전반에 걸쳐 사용할 수 있는 사용자 정의 서비스를 갖게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Angular에서 서비스의 중요성\n\n확장 가능하고 유지 보수가 쉬운 애플리케이션을 만들기 위해서는 최선의 방법을 따르고 올바른 아키텍처 패턴을 사용하는 것이 중요합니다. 서비스는 Angular 애플리케이션에서 중요한 역할을 합니다.\n\n- 코드 구성 — Angular 애플리케이션은 매우 크고 복잡해질 수 있으며, 모든 코드를 단일 구성 요소에서 관리하는 것이 어려울 수 있습니다. 서비스를 사용하여 관련 기능을 별도의 모듈로 구성할 수 있어 더 쉽게 관리하고 유지할 수 있습니다. 이는 코드 유지 관리성과 가독성을 개선하며 코드 중복 가능성을 줄입니다.\n- 재사용성 — 서비스는 여러 구성 요소에서 재사용할 수 있어 애플리케이션 내에서 코드 중복을 줄입니다. 이는 특정 기능을 수정해야 할 경우 해당 서비스를 한 곳에서 업데이트하면 해당 서비스를 사용하는 모든 구성 요소에 변경이 반영됩니다.\n- 의존성 주입 — Angular의 의존성 주입 시스템을 사용하여 서비스를 구성 요소에 주입할 수 있어 데이터 및 기능을 쉽게 공유할 수 있습니다. 이를 통해 느슨하게 결합된 구성 요소를 개발하기가 쉬워지며, 이는 테스트와 유지 보수가 쉬워집니다.\n- 관심사 분리 — 서비스를 사용하면 애플리케이션의 표현 계층과 비즈니스 로직을 분리할 수 있습니다. 비즈니스 로직을 별도의 서비스에 유지함으로써 표현 계층과 사용자 상호작용을 위해 책임을 지는 구성 요소를 개발하는 데 집중할 수 있습니다. 이러한 관심사 분리는 앞으로의 애플리케이션을 테스트, 유지 보수 및 수정하기 용이하게 만듭니다.\n- 코드 유지 보수성 — 서비스를 사용하여 향후 변경될 가능성이 높은 기능을 표현 계층에서 격리시킴으로써 미래에 코드를 유지 및 수정하는 것이 쉬워집니다. 이는 애플리케이션에서의 디버깅 및 문제 해결에 소요되는 시간을 줄일 수 있습니다.\n- 테스트 — 서비스는 쉽게 테스트할 수 있는 구조로 설계되어 있어 기능의 개별 요소를 테스트하고 예상대로 동작하는지 확인하기 쉽습니다. 비즈니스 로직을 서비스로 분리함으로써 해당 서비스에 대해 더 포괄적인 단위 테스트를 작성할 수 있어 애플리케이션에서 버그 발생 가능성을 줄일 수 있습니다.\n\n# Angular 서비스 사용시 최선의 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 서비스는 응용 프로그램 전체에서 기능을 구성하고 공유하는 데 중요한 역할을 합니다. Angular에서 서비스를 최대한 활용하기 위해서는 최상의 관행을 따르는 것이 중요합니다. 이 글에서는 Angular 서비스 작업 시의 최상의 관행에 대해 알아보겠습니다.\n\n- 서비스를 한 가지 역할에 집중하세요\n\n서비스를 한 가지 역할에 집중하는 것이 중요합니다. 여러 역할을 갖는 서비스는 관리와 유지보수가 어려워질 수 있습니다. 이는 일반적으로 단일 책임 원칙(Single Responsibility Principle, SRP)이라고 알려져 있습니다. 서비스를 한 가지 역할에 집중시킴으로써 코드를 더 모듈식으로 만들고 테스트하기 쉽게 할 수 있습니다.\n\n- Injectable 데코레이터를 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 의존성 주입을 활성화하려면 서비스에 @Injectable 데코레이터가 있어야 합니다. 이 데코레이터는 Angular이 서비스에 의존성을 주입하는 데 사용하는 메타데이터를 제공합니다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  // 서비스 코드를 여기에 작성합니다\n}\n```\n\n@Injectable 데코레이터의 providedIn 속성은 Angular에 서비스를 루트 수준에서 제공하도록 지시합니다. 이는 서비스가 응용 프로그램 전체에서 사용 가능하다는 것을 의미합니다.\n\n- 서비스에서는 비공개 속성을 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스에서 비공개 속성을 사용하는 것이 좋은 방법입니다. 비공개 속성은 서비스 외부에서 직접 액세스할 수 없기 때문에 서비스의 상태에 예기치 않은 변경을 방지하는 데 도움이 됩니다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  private myProperty: any;\n  \n  // 서비스 코드 작성\n}\n```\n\n- 의존성 주입에 생성자 인젝션 사용하기\n\n서비스에 의존성을 주입하려면 생성자 인젝션을 사용합니다. 이를 위해 생성자 매개변수에 의존성을 선언하고, Angular가 의존성 주입을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  constructor(private httpClient: HttpClient) {\n    // Service code goes here\n  }\n}\n```\n\n- providers 배열에 서비스를 추가하는 대신 providedIn 속성을 사용하세요\n\nAngular의 이전 버전에서는 서비스가 NgModule의 providers 배열에 추가되었습니다. 그러나 Angular의 최신 버전에서는 @Injectable 데코레이터의 providedIn 속성을 대신 사용할 수 있습니다. 이는 트리 쉐이킹을 가능하게 하여 최종 애플리케이션 번들의 크기를 줄일 수 있는 더 나은 접근 방식입니다.\n\n- 컴포넌트 간에 통신하기 위해 서비스를 사용하세요\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스는 컴포넌트 간에 통신하는 데 사용될 수 있으며 데이터 및 기능을 서로 공유할 수 있도록 합니다. 이것은 서로 직접적으로 관련이 없지만 서로 통신해아하는 컴포넌트들에게 특히 유용합니다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  private dataSubject = new BehaviorSubject\u003cany\u003e(null);\n  public data$ = this.dataSubject.asObservable();\n  \n  setData(data: any) {\n    this.dataSubject.next(data);\n  }\n}\n```\n\n이 예제에서는 BehaviorSubject를 사용하여 데이터를 서비스에 저장하고 있습니다. setData 메서드를 사용하여 데이터를 업데이트하고, data$ observable을 사용하여 데이터의 변경 사항을 구독할 수 있습니다.\n\n# 추가 학습 자료\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가 학습을 위한 다양한 자원이 많이 있어요. 아래는 Angular에 대한 깊은 이해를 돕는 데 도움이 되는 몇 가지 자원들이에요:\n\n- Angular 문서 — 공식 Angular 문서는 시작부터 고급 개념까지 모든 것을 다루는 종합적인 자원이에요. 튜토리얼, 안내서, API 참조 등이 포함돼 있어요. Angular에서 찾아볼 수 있어요.\n- Angular University — Angular University는 Angular을 포함한 온라인 강좌와 자원을 제공하는 교육 회사에요. Angular, RxJS 등 관련 기술에 대한 강좌를 제공하고 있어요. Angular University에서 찾아볼 수 있어요.\n- TekTutorialsHub — Tektutorialshub은 Angular을 비롯한 여러 기술에 대한 튜토리얼과 기사를 제공하는 웹사이트에요. Angular 튜토리얼에는 Angular 시작하기부터 반응형 폼, Angular material 등 고급 개념까지 다양한 주제가 포함돼 있어요. Angular 튜토리얼은 TekTutorialsHub에서 찾을 수 있어요.\n- TutorialsPoint — TutorialsPoint는 다양한 기술에 대한 광범위한 튜토리얼, 강좌 및 책을 제공하는 인기 있는 온라인 학습 플랫폼이에요. Angular 튜토리얼에는 Angular 기본 개념부터 Angular CLI, 반응형 폼, 단위 테스트 등의 고급 주제까지 다양한 주제가 포함돼 있어요. Angular 튜토리얼은 TutorialsPoint에서 찾을 수 있어요.\n- JavaTPoint — JavaTPoint는 Angular을 포함한 다양한 기술에 대한 튜토리얼과 강좌를 제공하는 온라인 학습 플랫폼이에요. Angular 튜토리얼에는 Angular 라우팅, 서비스, 애니메이션 등의 기본 개념부터 고급 주제까지 다양한 주제가 포함돼 있어요. Angular 튜토리얼은 JavaTPoint에서 찾을 수 있어요.\n\n이것들은 Angular에서 추가 학습을 위한 몇 가지 자원일 뿐이에요. 프레임워크를 계속 다루면서 더 많은 자원을 발견할 가능성이 높아요. 중요한 것은 호기심을 갖고, 계속 배우고, Angular 커뮤니티의 최신 트렌드와 모베스트 프랙티스를 따라가는 것이에요.\n\n여기까지 읽어주셔서 정말 감사드려요! 이 기사를 끝까지 읽어보시고 도움이 되셨기를 바래요. 저는 Medium, Twitter, Linkedin 및 Facebook에서도 저를 팔로우하실 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n질문이 있으면 언제든지 물어보세요.\n\n커피 사주시면 감사하겠어요.\n\n더 많은 재미있는 프로그래밍 코드 조각을 기대해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-ServicesinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-ServicesinAngular_0.png","tag":["Tech"],"readingTime":19},{"title":"앵귤러와 고랭 빠른 안내 - 고급","description":"","date":"2024-06-20 02:57","slug":"2024-06-20-AngularandGolangARapidGuideAdvanced","content":"\n\n![Angular and Golang Course](/assets/img/2024-06-20-AngularandGolangARapidGuideAdvanced_0.png)\n\nAngular와 Golang을 활용하여 Ambassador 앱을 개발하는 과정을 이 포괄적인 코스를 통해 경험해보세요. Admin, Ambassador, 그리고 Checkout과 같이 세 가지 다른 프론트엔드 애플리케이션을 구축하는 방법에 대한 통찰을 얻을 수 있습니다. 각각이 견고한 Golang API를 효율적으로 사용할 수 있도록 설계된 애플리케이션이에요. 이 코스는 10년 이상의 산업 경험을 자랑하는 숙련된 FullStack 개발자가 선별했으며, 학습 여정 전반에 걸쳐 원활하고 고품질의 코드를 유지하는 데 강한 강조가 되어 있습니다.\n\n저의 가르침 스타일은 매우 직관적이며, 제 강의를 길게 만들기 위해 불필요한 정보들을 설명하거나 시간을 낭비하지 않을 거에요. 빠르게 배우고 싶다면 이 코스가 딱 맞을 거예요.\n\nGo에서는 아래 내용을 배울 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Docker 사용\n- express.js에서 영감을 받은 Fiber 프레임워크 사용\n- 공개 및 보안 라우트 만들기\n- MySQL과 연결\n- 마이그레이션 실행\n- Jwt 토큰 생성\n- HttpOnly 쿠키 사용\n- 스코프로 로그인\n- Goroutine 사용\n- 채널 사용\n- Redis와 함께 Golang 사용\n- Stripe 사용\n- 이메일 전송\n- 캐시된 제품 필터링\n\nAngular에서는 다음을 배울 수 있습니다:\n\n- Angular CLI\n- 인터셉터 사용\n- 공개 및 비공개 라우트 만들기\n- 반응형 폼 사용\n- Angular Material\n- Angular Universal을 사용한 서버 측 렌더링\n- 이벤트 에미터 사용\n- TypeScript 사용\n\n지금 시청하세요!","ogImage":{"url":"/assets/img/2024-06-20-AngularandGolangARapidGuideAdvanced_0.png"},"coverImage":"/assets/img/2024-06-20-AngularandGolangARapidGuideAdvanced_0.png","tag":["Tech"],"readingTime":1},{"title":"각진 노하우 프로젝트 구조와 조직에 대한 팁","description":"","date":"2024-06-20 02:55","slug":"2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization","content":"\n\n새로운 프로젝트를 처음부터 구축하기 시작할 때 첫 번째 질문은 무엇이 좋은 프로젝트 아키텍처여야 하는가인데요. 어떤 기술 스택을 사용하든, 우리는 프로젝트 아키텍처가 새로운 애플리케이션을 구축하는 과정에서의 건축 기본 요소임을 알고 있습니다.\n\n모든 프로젝트와 사용 사례에 가장 적합한 아키텍처를 찾는 것은 거의 불가능하지만, 확장 가능한 구조를 찾아야 합니다. 본 글은 확장 가능하고 유지보수가 용이한 Angular 프로젝트 구조에 대한 상세한 정보를 제공합니다.\n\n![AngularBestPractices](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_0.png)\n\n# 전체 프로젝트 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 좋은 프로젝트 아키텍처는 애플리케이션의 성능을 향상시키지 않거나 더 빠르게 또는 더 잘 실행되지 않습니다. 그러나 Angular 아키텍처의 최상의 실천 방법을 활용하면 소스 파일로 신속하게 이동하고 모든 것이 어디에 보관되는지 이해할 수 있습니다. 그럼으로써 쉬운 디버깅을 실현하고 개발자나 신입사원들이 파일을 찾으려고 여기저기 배회하는 노력을 최소화하는 데 도움이 됩니다.\n\nAngular 프로젝트 구조의 최상의 실천 방법으로 Angular 팀이 소개하는 LIFT 원칙은 다음과 같습니다:\n\n- 코드 신속하게 찾기 — 관련 파일을 쉽게 찾을 수 있는 그룹에 유지합니다.\n- 한눈에 코드 식별하기 — 파일명을 사용하여 즉시 해당 내용과 표현물을 알 수 있도록 합니다.\n- 평평한 폴더 구조 — 가능한 한 평면 폴더 구조를 유지하여 모든 것을 하나의 차원에 제공합니다.\n- DRY 하게 유지하기 — DRY(Don’t Repeat Yourself)를 따르지만 가독성을 희생하지 않는 한도 내에서 DRY해야 합니다.\n\n초보 Angular 구조는 Angular CLI 명령을 사용하여 작성된 것처럼 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_1.png)\n\n## 전체 프로젝트 구조를 이해해봅시다. 일반적으로 워크스페이스 구성 파일, 애플리케이션 프로젝트 파일 및 소스 파일이 포함됩니다.\n\n.vscode — 이 폴더는 코드베이스가 VS Code 편집기에서 열릴 때 Visual Studio Code에 의해 생성 및 e2e로 대체되었습니다. 프로젝트 워크스페이스 설정을 보관합니다.\n\nnode_modules/ — 전체 워크스페이스에 npm 패키지를 제공합니다. 이 폴더를 열어서 사용 가능한 패키지를 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**Src/** - 애플리케이션의 모든 코드를 포함합니다.\n\n**.editorconfig** - 코드 편집기 설정을 보유합니다.\n\n**.gitignore** - Git이 무시해야 하는 의도적으로 추적되지 않은 파일을 지정합니다.\n\n**angular.json** - Angular 앱 구성을 보유합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npackage-lock.json은 설치된 각 종속성의 정확한 버전을 기록합니다. 그에 포함된 하위 종속성과 그들의 버전도 함께 포함됩니다.\n\npackage.json에는 프로젝트에 관한 설명적이고 기능적인 메타데이터가 포함되어 있습니다. 프로젝트의 이름, 버전 및 종속성 등이 포함됩니다.\n\nREADME.md는 애플리케이션에 대한 문서화를 위한 Markdown 파일입니다.\n\ntsconfig.app.json은 애플리케이션 기준으로 구성을 조정할 수 있는 추가적인 설정 파일입니다. Angular CLI 워크스페이스에 여러 애플리케이션이 있는 경우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntsconfig.json은 TypeScript 구성을 포함하는 일반 파일입니다. 여러 개의 Angular 하위 프로젝트가 있는 경우, 각각의 tsconfig.app.json 구성을 가지고 있어 유용합니다.\n\ntsconfig.spec.json은 애플리케이션 테스트를 위한 TypeScript 구성을 보관합니다.\n\n# 디렉토리 구조\n\n디렉토리 구조, 각 디렉토리의 필요성 및 사용에 대해 자세히 알아봅시다. 파일을 기능 및 목적에 따라 디렉토리 구조를 활용하여 조직화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## node_modules\n\n`node_modules`는 빌드 도구를 위한 디렉토리입니다. 앱 내 `package.json` 파일은 `npm install`을 실행할 때 `node_modules`에 설치될 라이브러리를 정의합니다. 타사 패키지를 설치할 때마다 `node_modules` 디렉토리에 그들의 폴더가 저장됩니다.\n\n참고: 앱을 프로덕션 서버로 배포하거나 git 저장소에 커밋할 때 `node_modules`는 제외해야 합니다. 프로젝트를 다른 위치로 이전할 때도 이 폴더는 포함해서는 안 되며, 대신 `npm`을 실행하여 `node_modules`를 생성해야 합니다.\n\n## SRC\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어플리케이션의 모든 소스 코드를 넣어야 하는 곳입니다. Angular 애플리케이션을 생성하면 기본적으로 angular CLI가 src 디렉토리에 여러 파일과 디렉토리를 생성합니다. 또한 각 모듈, 컴포넌트, 서비스 및 관련 소스 코드를 src 디렉토리에 넣어야 합니다.\n\n![Angular Best Practices](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_2.png)\n\n## App\n\napp 디렉토리는 루트 애플리케이션 폴더로 작동하며 앱 모듈 역할을 합니다. 앱 모듈 또한 src 디렉토리 내에 위치합니다. Angular 애플리케이션은 적어도 하나의 컴포넌트와 모듈이 있어야 하며 기본적으로 앱 모듈입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_3.png\" /\u003e\n\n앱 모듈에는 모듈 파일 (app.module.ts), 라우팅 파일 (app-routing.module.ts) 및 컴포넌트 (app.component.ts)이 포함되어 있습니다.\n\napp.module.ts — 이 파일은 Angular에 다른 특정 Angular 모듈에 대해 알려줍니다. 이 파일에는 Imports, Declarations, Providers, Bootstraps 및 기타 구성 옵션이 포함됩니다. Imports 섹션에서 다른 모듈을 가져와서 Declarations 섹션에 컴포넌트를 선언하고 Providers 섹션에 서비스를 제공합니다.\n\napp-routing.module.ts — 라우팅을 위해 라우트 목록과 해당 컴포넌트를 선언합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 섹션에서는 남은 구성 파일에 대해 이야기할 예정입니다.\n\n자산\n\n자산 파일에는 애플리케이션에 필요한 정적 데이터가 저장됩니다. 예를 들어 이미지, 아이콘 등이 있습니다.\n\n`\u003cimg src=\"/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_4.png\" /\u003e`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환경\n\n여러 환경을 설정하기 위해 이 디렉토리를 생성해야 합니다. 여기에 환경 파일을 추가하여 환경별 설정을 저장할 수 있습니다. 예를 들어:\n\n![environment](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_5.png)\n\n운영 환경용 environment.prod.ts 파일을 만들어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 환경을 위한 설정\n\n스타일\n공유 CSS 파일을 styles 디렉토리에 넣는 것이 좋은 아이디어입니다. 전체 애플리케이션에서 사용할 사용자 정의 CSS 파일(예: 색 변수 파일, 공유 타이포그래피 등)을 추가해야 합니다.\n\n![이미지](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_6.png)\n\n# 모듈 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular Module은 관련 기능을 그룹화하고 정리하는 개념입니다. 각 Module은 독립적이고 분리된 기능을 나타냅니다. Angular 애플리케이션의 초기 기본은 app module이라고 하는 단일 모듈만 있습니다. 이는 작은 애플리케이션의 경우에 효과적입니다. Angular Modules를 사용하면 디렉터리 구조를 효과적으로 구성할 수 있는 훌륭한 시작점을 제공받을 수 있습니다.\n\n우리는 Angular Module의 모베스트를 따라 잘 정리된 애플리케이션을 만들 수 있습니다. 좋은 실천으로 코드를 모듈로 묶고, 모듈을 최대한 활용하기 위해 아래와 같이 네 가지 카테고리로 모듈을 지정합니다.\n\n- App Module\n- Core Module\n- Features Module\n- Shared Module\n\n## App Module\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 CLI에 의해 생성된 루트 모듈인 앱 모듈은 애플리케이션의 진입점입니다. 애플리케이션이 시작될 때 앱 모듈이 로드되며, 모든 다른 모듈도 함께 로드됩니다. 애플리케이션이 성장함에 따라 루트 모듈을 발전시킵니다. 앱 모듈에는 코어, 기능 및 공유 모듈이 모두 포함되어 있습니다.\n\n![image](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_7.png)\n\n## 코어 모듈\n\n애플리케이션 전반에 걸쳐 전역적으로 공유되는 코어 기능, 서비스 및 모델은 기능 모듈과 관련이 없는 경우 코어 모듈의 일부여야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 서비스는 애플리케이션 당 하나의 인스턴스만 가져야 하므로 여기에 구현되어야 합니다. 이 모듈에는 인증 서비스 및 헤더, 푸터, 네비게이션 바, 사이드바, 인터셉터, 가드, 상수, 열거형, 유틸리티 및 범용 모델과 같은 정적 구성 요소가 포함되어 있습니다.\n\n앱 루트 모듈에서는 핵심 모듈만 가져와야 합니다. 다른 모듈은 핵심 모듈을 가져오면 안 됩니다.\n\n## 공유 모듈\n\n여러 모듈 간에 공유되는 구성 요소, 지시문 및 파이프는 공유 모듈에 유지해야 합니다. 예를 들어, 검색 및 로더는 여러 기능에서 사용될 수 있습니다. 공유 모듈에 저장된 항목은 다른 기능 모듈에 선언된 구성 요소에 의해 재사용 및 참조됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Shared Module](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_8.png)\n\n큰 애플리케이션 작업 시 공유 모듈이 더 유용합니다. 이는 애플리케이션의 번들 크기와 초기 빌드 시간을 줄이고 성능을 향상하기 위해 애플리케이션의 지연 로딩을 고려할 때 더 유용합니다. 공유 모듈은 애플리케이션의 다른 모듈에 의존해서는 안 됩니다.\n\n참고: 여기서 서비스를 정의해서는 안 됩니다. 공유 모듈은 어디서든 가져오기(import) 때문에 지연 로딩된 모듈에서 가져오면 서비스의 새 인스턴스가 생성될 수 있습니다.\n\n## 기능 모듈\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 응용 프로그램 요구 사항을 분리하고 응용 프로그램을 기능으로 분해해서 Feature Based Architectures로 불리는 것에 대해 이야기했어요. 우리는 src/app/features/ 모듈 아래 각 기능에 대한 별도 서브 모듈을 만들어야 해요. 이렇게 하면 코드가 독립적이고, 특정 기능에 중점을 둔 단일 책임을 갖게 됩니다.\n\n![Angular Best Practices Tips for Project Structure and Organization](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_9.png)\n\n의료 응용 프로그램을 구축한다고 가정해 봅시다. 우리는 예약, 처방, 환자, 결제 등을 위한 기능을 가져야 해요.\n\n## Feature Based Architecture\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 모듈은 모듈 이름 또는 기능을 따라 폴더 이름을 지정해야 합니다. 각 모듈에는 해당 모듈에서 필요로 하는 컴포넌트, 디렉티브, 파이프, 페이지, 다이얼로그, 및 서비스가 있으며, Redux 패턴을 사용하는 경우 각각을 블록으로 작성합니다.\n\n이러한 방식으로 코드를 구조화하면 특정 요소를 쉽게 찾을 수 있고 코드의 재사용성이 증가합니다. 모듈은 코드를 구성하고 분리하는 방법입니다. 여러 모듈을 가질 수 있으며 일부 모듈은 지연로드할 수 있습니다.\n\n![Angular Best Practices](/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_10.png)\n\n# 컴포넌트 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 어플리케이션을 만드는 데 구성 요소는 필수적입니다. 이들은 거대한 애플리케이션을 사용자 뷰를 정의하는 코드 조각들로 나눕니다. 구성 요소는 더 모듈화되고 유지보수하기 쉬운 어플리케이션을 만듭니다. 재사용 가능하고...자세히 알아보려면 여기를 클릭하세요","ogImage":{"url":"/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_0.png"},"coverImage":"/assets/img/2024-06-20-AngularBestPracticesTipsforProjectStructureandOrganization_0.png","tag":["Tech"],"readingTime":7},{"title":"새로운 Angular 프로젝트 생성 및 샘플 폼 디자인하기","description":"","date":"2024-06-20 02:54","slug":"2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm","content":"\n\n![image](/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png)\n\nAngular은 동적 웹 애플리케이션을 구축하기 위한 강력한 프레임워크입니다. 새 프로젝트를 시작하거나 복잡한 폼을 디자인하더라도, Angular은 개발을 간소화하는 강력한 도구와 기능을 제공합니다. 본 문서에서는 새 Angular 프로젝트를 생성하고 샘플 폼을 디자인하는 방법을 안내해 드립니다.\n\n# 1. Angular CLI 설치\n\nAngular CLI (Command Line Interface)는 Angular 프로젝트를 관리하는 강력한 도구입니다. Angular CLI를 설치하려면 다음 명령어를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install -g @angular/cli\n```\n\n# 2. 새로운 Angular 프로젝트 생성하기\n\nCLI를 사용하여 새로운 Angular 프로젝트를 만들어보세요. 이 작업은 프로젝트 구조와 구성 파일을 자동으로 설정해줍니다.\n\n```js\nng new my-angular-app\ncd my-angular-app\nng serve\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령 시퀀스를 사용하세요:\n\n1. 새 Angular 프로젝트를 'my-angular-app'이라는 이름으로 초기화합니다.\n2. 프로젝트 디렉토리로 이동합니다.\n3. 개발 서버를 시작하여 애플리케이션을 http://localhost:4200에서 접근할 수 있도록 합니다.\n\n## 3. 새 컴포넌트 생성\n\n새로운 폼을 처리할 컴포넌트를 생성합니다. 컴포넌트는 Angular 애플리케이션의 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate component sample-form\n```\n\n이 명령어는 필요한 파일(HTML, CSS, TypeScript 및 테스트를 위한 spec)과 함께 새 컴포넌트를 생성합니다.\n\n# 4. 샘플 폼 디자인하기\n\n생성된 컴포넌트의 HTML 파일을 열고 Angular의 폼 지시문을 사용하여 폼을 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# sample-form.component.html #\n\u003cdiv class=\"container\"\u003e\n  \u003ch2\u003e샘플 양식\u003c/h2\u003e\n  \u003cform (ngSubmit)=\"onSubmit()\" #form=\"ngForm\"\u003e\n    \u003cdiv class=\"form-group\"\u003e\n      \u003clabel for=\"name\"\u003e이름:\u003c/label\u003e\n      \u003cinput type=\"text\" id=\"name\" class=\"form-control\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"\u003e\n      \u003cdiv *ngIf=\"name.invalid \u0026\u0026 name.touched\" class=\"alert alert-danger\"\u003e\n        이름을 입력해주세요.\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"form-group\"\u003e\n      \u003clabel for=\"email\"\u003e이메일:\u003c/label\u003e\n      \u003cinput type=\"email\" id=\"email\" class=\"form-control\" required [(ngModel)]=\"model.email\" name=\"email\" #email=\"ngModel\"\u003e\n      \u003cdiv *ngIf=\"email.invalid \u0026\u0026 email.touched\" class=\"alert alert-danger\"\u003e\n        유효한 이메일을 입력해주세요.\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"submit\" class=\"btn btn-primary\" [disabled]=\"form.invalid\"\u003e제출\u003c/button\u003e\n  \u003c/form\u003e\n\u003c/div\u003e\n```\n\n이 예제에서:\n\n- 이름과 이메일에 대한 두 개의 입력 필드가 만들어졌습니다. 둘 다 필수 입력 항목입니다.\n- Angular의 ngModel 지시문을 통해 양방향 데이터 바인딩이 이루어졌습니다.\n- 필드가 유효하지 않거나 사용자가 터치한 경우 유효성 검사 메시지가 표시됩니다.\n- 제출 버튼을 클릭하면 onSubmit 메서드를 통해 양식이 제출됩니다.\n\n# 5. 양식 제출 처리하기 #\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// sample-form.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-sample-form',\n  templateUrl: './sample-form.component.html',\n  styleUrls: ['./sample-form.component.css']\n})\nexport class SampleFormComponent {\n  model: any = {};\n\n  onSubmit() {\n    console.log('Form submitted!', this.model);\n  }\n}\n```\n\n여기 예제에서:\n\n- 모델 객체가 정의되어서 폼 데이터를 저장합니다.\n- `onSubmit` 메서드는 폼 제출 시 콘솔에 폼 데이터를 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAngular CLI와 폼 디렉티브를 사용하여 새 Angular 프로젝트를 생성하고 폼을 디자인하는 것은 간단합니다. Angular는 폼 처리와 유효성 검사에 강력한 도구를 제공하여 동적이고 반응적인 웹 애플리케이션을 구축하기 쉽게 만듭니다. 이러한 단계를 따라하면 빠르게 새 Angular 프로젝트를 설정하고 쉽게 복잡한 폼을 디자인할 수 있습니다.\n\n독자 여러분, 읽어주셔서 감사합니다! 궁금한 점, 생각 또는 피드백이 있으시면 아래 댓글을 남겨주시기 바랍니다. 여러분의 참여와 지원은 웹 개발에서 Angular의 가능성을 계속 탐구하는 데 큰 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png"},"coverImage":"/assets/img/2024-06-20-CreatingaNewAngularProjectandDesigningaSampleForm_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 파일 다운로드 및 다운로드 추적을 위한 프로그레스 바 구현하기","description":"","date":"2024-06-20 02:53","slug":"2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload","content":"\n\n이 이야기는 몇 년 전에 썼던 것과 매우 비슷한 내용입니다. 그 이야기는 여러 파일을 업로드하는 진행 막대를 구현하는 것과 관련이 있었습니다. 각 파일의 업로드를 추적하는 데 사용되는 진행 막대가 1개 있었습니다.\n\n이 이야기에서는 Node Express 서버에서 5000개의 객체를 포함하는 photos.json 파일을 다운로드합니다.\n\n![이미지](/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png)\n\n아래는 애플리케이션의 간단한 데모입니다. Chrome 개발 도구를 사용하여 느린 3G 연결을 시뮬레이션하여 파일 다운로드가 천천히 진행되는 것을 볼 수 있습니다. 나중에는 추가적인 npm 모듈을 설치하지 않고 시스템에 파일을 다운로드하는 코드 작성 방법을 안내하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode Server 프로젝트\n\n![이미지](/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_1.png)\n\nindex.js\n\n위 파일에 설정된 \"Content-Length\" 응답 헤더에 유의해주세요. 이 헤더는 프로그레스 바를 구현하는 중요한 단계입니다. 이 헤더는 Angular 애플리케이션에게 받을 데이터의 총 크기를 알려줌으로써 프로그레스 바를 구현하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Content-Disposition\" 응답 헤더는 콘텐츠가 브라우저에서 인라인으로 표시되는지(Web 페이지 또는 웹 페이지의 일부로) 아니면 첨부 파일로 다운로드되어 로컬에 저장되는지를 나타내는 헤더입니다.\n\n우리는 콘텐츠가 \"photos.json\"이라는 파일로 다운로드되기를 원합니다.\n\nAngular 프로젝트\n\nAngular 프로젝트에는 AppComponent와 ProgressComponent 두 개의 컴포넌트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터를 가져오기 위해 노드 서버와 연결하는 FileDownloadService라는 단일 서비스를 가지고 있습니다.\n\nAppComponent 템플릿\n\n`app-progress`는 ProgressComponent를 위한 셀렉터입니다. 이미지 업로드 진행률을 @Input('ratio')로 ProgressComponent에 전달하고 있습니다. 업로드 진행률은 downloadprogressRatio$ observable을 구독하여 async 파이프를 통해 @Input('ratio')로 전달됩니다.\n\n```js\n\u003ch4\u003eDownloading\u003c/h4\u003e\n\u003capp-progress [ratio]=”downloadprogressRatio$|async”\u003e\u003c/app-progress\u003e\n\u003cbutton (click)=”download()”\u003eDownload JSON\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“Download JSON” 버튼을 클릭하면, 해당 클래스에서 download()을 호출하게 됩니다.\n\nAppComponent 클래스\n\n- downloadProgressRatio$는 observable입니다. 우리는 FileDownloadService에서 반환된 getDownloadingProgress()의 observable을 downloadProgressRatio$ observable에 할당합니다. 이 observable은 템플릿에서 async 파이프를 통해 구독됩니다.\n\n```js\n\u003capp-progress [ratio]=”downloadprogressRatio$|async”\u003e\u003c/app-progress\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 템플릿의 \"다운로드\" 버튼을 클릭하면, 해당 클래스의 download()이 호출되며, 이 메서드는 FileDownloadService의 downloadJson()을 호출합니다.\n\nFileDownloadService\n\n- downloadingProgressSub는 각 파일의 다운로드 진행 상황을 컴포넌트에 실시간 업데이트해 주는 중요한 역할을 하는 Subject입니다.\n- 이미 클래스의 ngOnInit()에서 getDownloadingProgress()가 호출되었음을 확인했습니다. 이 메서드는 해당 Subject에 대한 Observable을 반환하는 역할을 합니다.\n\n```js\ngetDownloadingProgress(){\n    return this.downloadingProgressSub.asObservable();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. \"Download JSON\" 버튼을 클릭하면 downloadJson() 함수가 호출됩니다. 우리는 Node 서버에서 photos.json을 가져오기 위해 GET 요청을 보냅니다.\n\n```js\ndownloadJson()\n{\nreturn this.http.get(`${environment.baseUrl}photos`,{reportProgress:true,observe:'events'}).pipe(\n  tap((response:any)=\u003e{\n    if(response.type==HttpEventType.DownloadProgress){ //3\n      this.setDownloadingProgress(response.loaded/response.total);\n    }\n    else if(response.type === HttpEventType.Response){\n      let blob = new Blob([JSON.stringify(response.body)]);\n      this.downloadBlob(response,blob);\n    }\n  }),\n  catchError(err=\u003e{\n    return throwError(err)\n  })\n)\n}\n```\n\n4. HTTP GET 요청에 전달되는 추가 옵션을 관찰해주세요.\n\n```js\nthis.http.get(`${environment.baseUrl}photos`,{reportProgress:true,observe:’events’})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 다운로드 진행 상황에 대한 피드백을 제공하여 사용자들에게 더 나은 경험을 제공하고 있습니다. 우리는 진행 상황 추적을 가능하게 하기 위해 reportProgress를 true로 설정했습니다.\n\nobserve 값은 관찰하고자 하는 내용에 따라 반환 유형을 결정합니다. \"events\"의 observe 값은 기본적으로 진행 상황 이벤트를 포함한 HttpEvent 스트림의 observable을 반환합니다.\n\n5. 서버로부터 데이터를 받기 때문에, HttpEvent의 유형은 DownloadProgress(UploadProgress가 아님)일 것입니다.\n\n```js\nif(event.type==HttpEventType.DownloadProgress){ //3\nthis.setDownloadingProgress(event.loaded/event.total);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nevent.load은 로드된 파일의 바이트 수입니다.\n\nevent.total은 로드해야하는 전체 바이트 수입니다.\n\nevent.load/event.total은 업로드 중인 파일의 진행률을 나타냅니다.\n\n저희는 setDownloadingProgress()를 호출하여 진행률을 인수로 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsetDownloadingProgress(data: any) {\n    this.downloadingProgressSub.next(data);\n}\n```\n\nsetDownloadingProgress() 메서드에서는 진행률 비율을 downloadingProgressSub Subject로 전달하고 있습니다.\n\nAppComponent 템플릿에서 이 Subject에 async pipe를 통해 구독하고 있다는 것을 기억하시나요?\n\n6. Node 서버로부터 본문을 포함한 전체 응답을 받으면, HttpEvent는 Response 유형이 됩니다. 그런 다음 응답 본문에서 Blob 객체를 생성하고 이 blob 객체 및 HttpResponse를 downloadBlob() 메서드에 인수로 전달합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nelse if(response.type === HttpEventType.Response){\nlet blob = new Blob([JSON.stringify(response.body)]);\nthis.downloadBlob(response, blob);\n}\n```\n\n7. Inside the `downloadBlob()`, we have written a common logic to perform automatic download of file received.\n\n```js\ndownloadBlob(response: any, blob: Blob){\n\nlet substringA = response.headers.get('content-disposition').substring(response.headers.get('content-disposition').indexOf(\";\") + 1);\nlet filename = substringA.substring(substringA.indexOf(\"=\") + 1).replace(/[\"\"]/g, \"\");\nlet link = document.createElement('a');\nlink.download = filename;\nlink.href = URL.createObjectURL(blob);\nlink.click();\n}\n```\n\nWe are first extracting the filename from the Content-Disposition response header.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet substringA=response.headers.get('content-disposition').substring(response.headers.get('content-disposition').indexOf(\";\")+1);\nlet filename= substringA.substring(substringA.indexOf(\"=\")+1).replace(/[“”]+/g,\"\");\n```\n\n이것이 Content-Disposition 헤더가 보이는 모습입니다.\n\n다음으로 앵커 요소인 `a`를 생성하고 요소의 다운로드 및 href 속성을 설정합니다. 다운로드 속성은 파일 이름으로 설정됩니다. href 속성은 Blob 객체에 대해 생성된 객체 URL로 설정됩니다. Blob는 createObjectURL()을 사용하여 내용을 보여주기 위해 `a`, `img` 또는 다른 태그를 사용할 수 있습니다.\n\n```js\nlet link = document.createElement('a');\nlink.download = filename;\nlink.href = URL.createObjectURL(blob);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 앵커 요소를 프로그래밍 방식으로 클릭하여 다운로드가 자동으로 시작되도록 합니다. 우리는 앵커 요소를 DOM에 첨부하고 싶지 않습니다.\n\n```js\nlink.click();\n```\n\nProgressComponent 템플릿\n\n```js\n\u003cdiv class=”container pending”\u003e\n\u003cdiv class=”progress-container” [ngClass]=”ratio === 1 ? ‘complete’ : ‘pending’”\u003e\n\u003cdiv [ngStyle]=”{width:progress}”\u003e\n\u003c/div\u003e\n\u003cdiv class=”progress-message”\u003e{progress}\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"complete\" 및 \"pending\" CSS 클래스는 아래와 같이 정의되어 있습니다:\n\n```js\n.complete {\n  background-color: lightgreen;\n}\n.pending {\n  background-color: rgb(243, 111, 111);\n}\n```\n\nProgressComponent 클래스\n\n이 클래스는 AppComponent로부터 속성 바인딩을 통해 @Input('ratio')를 수신합니다. 우리는 이 비율에 100을 곱하여 백분율을 얻은 다음 가장 가까운 정수로 반올림합니다. 이 백분율을 사용하여 진행 막대의 너비를 조정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 앵귤러 및 노드 프로젝트의 git 저장소입니다.\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n- 작가를 클릭하고 팔로우해주시면 감사하겠습니다! 👏\n- 우리를 팔로우하세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 방문해주세요: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDownloadingfilesandimplementingaprogressbarfortrackingthedownload_0.png","tag":["Tech"],"readingTime":7},{"title":"앵귤러 로드맵 믿기 특히 2024년에 앵귤러의 모든 가능성","description":"","date":"2024-06-20 02:51","slug":"2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024","content":"\n\nAngular은 개발 커뮤니티에서 필수적인 프레임워크로 자리매김했습니다. GitHub에서 26만 개의 스타를 획득한 Angular은 개발자들에게 중요한 도구로 자리를 굳혀가고 있습니다. Angular은 범용 해법, 최적의 방법, 그리고 포괄적인 안내를 제공하여, 프론트엔드 개발자들에게 필수적인 도구로 자리매김하고 있습니다.\n\n파헤치기 전에 약간의 스포일러: 주요 내용 요약\n\nAngular은 싱글 페이지 애플리케이션 (SPA) 개발에 큰 영향을 미치는 다목적 TypeScript 기반 웹 애플리케이션 프레임워크입니다. 이 프레임워크는 효율적인 변경 탐지 시스템, 상태 변경 관리를 위한 Zones 사용, 그리고 Model-View-ViewModel (MVVM) 아키텍처로 유명합니다.\n\n주요 핵심내용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular의 역할: Angular은 현대 웹 개발에 필수적입니다.\n- 커뮤니티 주도의 로드맵: 모든 전문 지식 수준을 위한 구조화된 지침이 제공됩니다.\n- 기본 지식: 웹 기술과 TypeScript에 대한 튼튼한 이해가 필요합니다.\n- Angular CLI: 이 도구는 개발 프로세스를 간소화합니다.\n- 핵심 개념: 디렉티브, 반응형 폼, 의존성 주입 및 HTTP 클라이언트가 중요합니다.\n\n2024년 Angular 로드맵\n\nAngular는 개발자들의 요구를 충족시키기 위해 지속적으로 발전하며 다재다능한 프레임워크로 자리 잡았습니다. 고유한 변경 감지 메커니즘과 Zones의 사용은 성능 효율성과 반응형 사용자 인터페이스를 보장합니다. MVVM 아키텍처를 통해 SPA를 효과적으로 구축하고 상호 작용할 수 있습니다.\n\n주요 구성 요소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 변경 감지: Angular의 시스템은 가상 DOM 접근 방식과는 다르며, 성능과 응답성에 초점을 맞춥니다.\n- Zones: 원활한 사용자 경험을 보장하기 위해 비동기 작업을 관리합니다.\n- MVVM 아키텍처: SPA 개발에 견고한 기반을 제공합니다.\n\nAngular 로드맵 시작하기!\n\nAngular를 시작하려면 기본적인 웹 기술과 TypeScript를 시작으로 핵심 원리와 도구에 대한 꼼꼼한 이해가 필요합니다.\n\nAngular에 꼭 필요한 TypeScript의 핵심 개념\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구조적 타이핑: 유연한 데이터 관리를 위한 기능입니다.\n- 타입 인터페이스: 복잡한 타입 구조를 정의하고 재사용합니다.\n- 유니언 타입: 타입 정의에 다양성을 추가합니다.\n- 내장 타입: 일관된 데이터 처리를 보장합니다.\n- 타입 가드 및 제네릭: 안전한 코드 조합을 가능하게 합니다.\n- 데코레이터: 클래스 선언에 메타데이터와 로직을 추가합니다.\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png)\n\n프로젝트 부트스트래핑을 위한 Angular CLI 활용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular CLI는 프로젝트 설정 및 관리를 간단하게 해주며, 다음과 같은 명령어를 통해 생산성을 향상시킵니다:\n\n- 프로젝트 초기화\n- 모듈, 컴포넌트, 서비스 생성\n- 애플리케이션 빌드, 서빙, 컴파일\n\n예시:\n\n![이미지](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'''HTML, CSS 및 핵심 JavaScript으로 기초 다지기'''\n\n앵귤러를 숙달하려면 HTML, CSS 및 JavaScript에 능숙해져야 합니다. 이들은 앵귤러 구조의 기본 구성 요소입니다:\n\n- HTML: 웹 콘텐츠의 의미론적 구조.\n- CSS: 응답 및 매력적인 인터페이스를 위한 스타일링.\n- JavaScript: 웹 애플리케이션의 동적 처리.\n\n예:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Angular](/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_2.png)\n\n## Angular Roadmap의 핵심 개념 및 모범 사례\n\n각 지시자(directives), 반응형 폼(reactive forms), 의존성 주입(dependency injection), 그리고 HTTP 클라이언트 등 Angular의 핵심 개념을 이해하는 것은 효율적이고 확장 가능한 애플리케이션을 만드는 데 필수적입니다.\n\n- 지시자(directives): HTML 기능 확장\n- 반응형 폼(reactive forms): 복잡한 데이터 입력을 위한 모델 주도 접근 방식\n- 의존성 주입(dependency injection): 모듈화 및 단위 테스트 단순화\n- HTTP 클라이언트: 외부 API와의 통신 처리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 아래는 요청하신 내용에 대한 한국어 번역입니다.\n\n지시문 예시:\n\n- 구조 지시문: *ngFor, *ngIf\n- 속성 지시문: [ngStyle], [ngClass]\n\nAngular의 고급 기능 및 기술\n\n모듈화, 지연 로딩, 변경 감지 전략 및 서버 측 렌더링 (SSR)과 같은 고급 기능은 고성능 애플리케이션 구축에 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모듈 및 Lazy Loading: 시작 성능을 향상시킵니다.\n- 변경 감지 전략: 성능을 최적화합니다.\n- SSR용 Angular Universal: SEO 및 접근성을 개선합니다.\n\n예: Lazy Loading\n\n```typescript\nconst routes: Routes = [\n  { path: 'feature', loadChildren: () =\u003e import('./feature/feature.module').then(m =\u003e m.FeatureModule) }\n];\n```\n\n신생 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기계 학습(ML), 인공 지능(AI) 및 블록체인의 통합은 Angular의 기능을 변화시키고 성능과 적응성을 향상시키고 있습니다.\n\n- ML 및 AI: 적응형 물리학 및 예측 모델링.\n- 블록체인: 탈중앙화된 컴퓨팅 및 자산 상호 운용성.","ogImage":{"url":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png"},"coverImage":"/assets/img/2024-06-20-IbelieveintheAngularRoadmapEspeciallyAngularsFullPotentialin2024_0.png","tag":["Tech"],"readingTime":4},{"title":"제가 TypeScript, Schemata 및 추론을 사용하여 어떻게 깨른 배송을 할 수 있는지 알려드릴게요","description":"","date":"2024-06-20 02:47","slug":"2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference","content":"\n\n거의 10년 전에 Java 개발자로서 경력을 시작했고, 여전히 변수를 끊임없이 타이핑했던 기억이 나네요! TypeScript로 전향한 후에는 타입 추론에 의존하기 시작했습니다. 이 언어 기능을 넘어서 이를 이해하고 있고, 이 덕분에 일상적으로 많은 키 스트로크를 절약하고 있어요.\n\n명시적 추론을 사용할 수 있다는 것을 깨달았을 때 기쁜 충격을 받았어요. 한 줄로 배열과 반환 타입을 추출할 수 있다는 것이죠!\n\n첫 번째 스키마 라이브러리를 배운 후에 엄청난 획기가 왔어요.\n\n스키마 작성을 마스터한 뒤에는 말로써 일석이조였죠. 런타임에서 수신 데이터를 구문 분석하고 추론된 유형을 컴파일 타임에 사용할 수 있었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 발견으로 내 생산성이 향상되었어요. 이로 인해 더 빨리 프로젝트를 완료할 수 있었거든.\n\n왜 빠른 배송이 중요한가요?\n\n경쟁사보다 빨라야 한다고 얘기하는 사람도 있죠...\n\n빠르게 배송하지 않고 꾸준히 하지 않으면, 엔지니어링 프로세스에 문제가 있는 것이라고 볼 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png)\n\n위의 그림 속 핸들을 잡고 있는 사람은 배의 엔지니어링에 대해 의심하고 있는 걸까요?\n\n생산성 향상은 다음과 같은 개념에서 비롯되었습니다.\n\n파싱을 프로젝트의 핵심 요소로 취급하고 계약 프로그래밍을 강제 적용하기 시작했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 각 수신 구조를 구문 분석하면 데이터 처리가 시작되기 전에 보안 계층을 도입합니다. 유명한 속담을 바꿔 말하면, 수신 데이터를 테스트하지 않으면 결국 클라이언트가 테스트하게 될 것입니다!\n\n둘째로, 이는 또한 생산 중에 발생할 수 있는 버그의 수를 줄이며, 실행 시 오류를 컴파일 타입 오류로 대체합니다. 컴파일 할 수 없는 프로젝트를 배포해서는 안 됩니다!\n\n세 번째로, 적절한 애플리케이션 모니터링을 통해 구문 분석 오류(PPI를 고려함)를 오류 수집기로 보낼 수 있습니다. 문제가 발생한 위치를 이해하면 피드백 루프를 단축시킬 수 있습니다. 클라이언트가 문제를 알기 전에 문제에 대해 알고 싶습니다.\n\n마지막으로, LLM을 사용하여 스키마를 더 빨리 작성할 수 있습니다. 다시 말해, 인공지능을 습득한 사람들은 아마도 그렇지 않은 사람들의 직업을 대체할 것입니다. 이야기 끝에 별도의 섹션에서 LLM 사용에 대해 논의하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이야기를 써서 생산성을 향상시키는 발견을 설명했어요. 제 경험에서 배우고, 현재와 미래 프로젝트에 적용해 보세요!\n\n이야기에서 제시된 모든 코드 조각은 Bun 1.1.12에서 코딩하고 테스트했어요.\n\n# 스키마 라이브러리 선택\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택은 어려운 결정이죠.\n\n최근 몇 년 동안 다양한 스키마 라이브러리를 사용해봤는데, 특히 Zod, @effect/schema, 그리고 Yup을 주로 사용했어요. 이들은 일반적인 유효성 검증과 파싱에 사용할 때 거의 구별하기 어렵지만, 브랜드 타입이나 숫자 범위를 정의할 때 차이가 나타날 수 있어요.\n\n소프트웨어 엔지니어는 작업에 적합한 도구를 선택해야 해요. 함수형 프로그래밍에 대한 좋은 지원이 필요하다면, 불변성을 보장하고 모나드 구조를 지원하는 @effect/schema가 가장 적합할 거예요.\n\n최소한의 종속성을 유지하고 싶다면, 아무 종속성도 없는 Zod을 선호할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 언급된 라이브러리에 대한 동등한 코드를 제시하겠습니다.\n\n다음 명령어를 사용하여 이들을 설치할 수 있습니다:\n\n```js\nbun install @effect/schema yup zod\n```\n\n## 구문 분석이 검증을 이기는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제대로 시작하기 전에 TypeScript의 구조적 타이핑과 유효성 검사 및 구문 분석에 미치는 영향을 언급해야 합니다.\n\n두 타입을 비교할 때 컴파일러는 이름을 무시하고 속성 타입만 확인합니다. 예를 들어 다음 타입은 동일하다고 간주됩니다:\n\n```js\ntype User = { id: string };\ntype Company = { id: string };\n```\n\nTypeScript를 사용하기 시작할 때는 명백하지 않을 수 있지만, 더 많은 경험을 쌓으면 감이 올 것입니다. 그러나 객체 리터럴 주변에 더 많은 유의해야 할 점이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n타입 변수를 초기화할 때 컴파일러는 초과 속성에 대한 검사를 실행합니다. 우리는 이 할당의 오른쪽을 오브젝트 리터럴이라고 공식적으로 부릅니다. 다음 스니펫은 컴파일되지 않습니다:\n\n```js\nconst user: User = {\n  id: '1',\n  name: 'test username',\n};\n```\n\n저는 이 언어 기능의 이유에 동의합니다. 선택한 타입을 준수하지 않는다면 타입 변수를 지정하지 않는 것이 좋습니다. 이게 합리적으로 느껴지시나요?\n\n다음 스니펫에서 확인할 수 있듯이 함수에 오브젝트 인자를 전달할 때 초과 속성 검사는 작동하지 않습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  test: 1,\n};\n\nconst canAccessDashboard = (user: User) =\u003e (user.claims \u0026 0x01) !== 0;\n\ncanAccessDashboard(userWithExcessProperties);\n```\n\n프로그램은 함수를 통해 데이터가 흐르는 단순한 흐름입니다. 데이터를 구문 분석하면 반복적으로 함수에 전달됩니다. 이제 데이터를 구문 분석해야 하는 이유에 대해 설명하겠습니다.\n\n구조를 검증할 때는 해당 스키마에 적합한지만 확인합니다. 유효성 검사는 새 객체를 생성하지 않습니다. TypeScript에서 원본 구조를 함수에 전달할 때 초과된 속성도 함께 전달될 수 있습니다.\n\n로그에 사용자 데이터를 기록하면 개인 식별 정보를 저장할 수 있습니다! 그래서 그것을 피하기 위해 원하는 속성을 갖는 새 객체를 만들어 데이터를 구문 분석해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_2.png\" /\u003e\n\n# 추론\n\n스키마 라이브러리를 사용하여 한 방에 두 마리의 새를 잡고 싶어요. 어떤 API에든 딱 붙어보이지만 그 대신에 어떤 데이터든 수월하게 파싱하고 컴파일러에 대한 형식을 얻고 싶어요.\n\nZod를 사용하여 사용자 스키마를 작성하려면 아래 코드를 작성할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport z, { ZodType } from 'zod';\n\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  claims: z.number(),\n}).readonly();\r\n```\n\n이제 사용자 유형을 추론하겠습니다:\n\n```js\r\ntype User = z.infer\u003ctypeof userSchema\u003e;\r\n```\n\n이 문장은 다음 코드의 달신이 되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n유저 타입을 호출할 때 다음 메소드를 이용하여 구문 분석할 거에요:\n\nconst user: User = userSchema.parse(userWithExcessProperties);\n\n사용자들을 그룹화하고 싶다고 상상해 보세요. 그룹 스키마와 해당 유형을 비슷하게 작성할 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high')\n    ]),\n  })).readonly(),\n}).readonly();\n\ntype Group = z.infer\u003ctypeof groupSchema\u003e;\r\n\n## 추이추론\n\n별도의 변수로 스키마를 추출하지 않고 관심 수준 유형을 추출하는 방법은 무엇인가요?\n\nTypeScript 유형 메커니즘을 활용하여 다음과 같이 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntype InterestLevel = Group['interests'][number]['level'];\n\n만약 제가 스키마를 별도로 사용하지 않는다면, 제 다른 비즈니스 구조의 일부로 유지합니다.\n\n덧붙여, 최소 추론 규칙을 만들었습니다. 이미 추론한 타입이 있는 경우, 그 하위 타입을 추출하기 위해 다시 추론해서는 안 된다는 것입니다!\n\n## 일반 추론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 좀 더 고급 추론 패턴을 보여드릴게요. 이를 \"일반 추론\"이라고 부르겠어요.\n\n임의의 데이터와 그들의 체크섬을 포함하는 구조를 구문 분석해야 한다고 상상해봅시다. 우리는 이러한 구조를 보통 봉투(envelope)라고 부릅니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_3.png)\n\n그래서 우리는 일반 빌더 함수를 작성할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: ZodType\u003cT\u003e\n) =\u003e z.object({\n  datum: datumSchema,\n  checksum: z.string(),\n}).readonly();\n\n위의 코드 조각에서 `ZodType\u003cT\u003e`는 일반 타입 T로 구문 분석되는 스키마입니다.\n\n만약 사용자 및 그룹 스키마와 타입을 필요로 한다면, 다음과 같이 타입을 지정할 수 있습니다:\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = z.infer\u003ctypeof userEnvelopeSchema\u003e;\ntype GroupChecksumEnvelope = z.infer\u003ctypeof groupEnvelopeSchema\u003e;\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 우리가 일반적인 envelope 타입을 유지하고 싶다면 어떻게 할까요? 우리는 이를 사용하여 내용을 정확히 모르는 임의의 envelopes에 작업을 수행할 수 있습니다. 예를 들어, 체크섬을 계산하는 것과 같이요.\n\ntype ChecksumEnvelope\u003cT\u003e = z.infer\u003c\n  ReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n\n## 단수 schema\n\n스키마를 사용할 때, 저는 단수 구조만을 정의하는 것을 선호합니다. 예를 들어, 다음과 같이 작성하지 않겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst usersSchema = z.array(userSchema);\ntype Users = z.infer\u003ctypeof usersSchema\u003e;\n\n가능하다면 복수형 타입을 정의하지 않겠어요. 배열에는 `ReadonlyArray\u003cUser\u003e`나 `User[]`를 사용할 거에요. 혼란을 피하고 다른 명명 규칙을 만들지 않기 위해 가능한 한 타입 별칭을 적게 사용하려고 해요.\n\n## 내보내기\n\n일반적으로 schema와 비즈니스 구조체의 유추된 타입을 내보내요. 다른 개발자들이 혼란스럽지 않도록 helper schema를 절대 내보내지 않아요. 가져올 수 있는 문장을 줄이기 위해 노력해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 불변성\n\n저는 불변성의 충실한 지지자입니다.\n\n새로운 변수를 생성할 때만 데이터가 변경되므로 코드를 분석하기가 더 쉽다고 생각합니다. 제 스키마는 불변성을 일등 시민 개념으로 취급하길 원합니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불변성을 사용하는 것은 프로그래밍 언어의 규칙을 제한하기 위해 사슬을 사용하는 것과 같습니다. 깨지기 쉬운 링크만 깨뜨리면 됩니다. 저희 경우에는 스키마가 그런 링크일 수 있습니다.\n\nZod 스키마를 불변하게 만들기 위해 readonly 메서드를 호출합니다. Zod는 자동으로 불변의 추론된 유형을 생성합니다.\n\n예를 들어, 아래에 명시된 것처럼 그룹 스키마는 이미 불변성 원칙을 준수합니다:\n\nconst groupSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  userIds: z.array(z.string()).readonly(),\n  interests: z.array(z.object({\n    id: z.string(),\n    level: z.union([\n      z.literal('low'),\n      z.literal('medium'),\n      z.literal('high'),\n    ]),\n  })).readonly(),\n}).readonly();\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 추론된 타입을 준수하는 인스턴스를 생성할 때 불변성에서 일시적으로 벗어나고 싶다면 어떻게 해야 할까요?\n\n해당 readonly 수정자를 무효화하는 타입을 사용해야 합니다. 일부 스키마에는 충분하지 않을 수도 있습니다. ReadonlyArray 타입을 가변으로 만들려면 어떻게 해야 할까요? 그리고 ReadonlySet은 어떻게 해야 할까요? ReadonlyMap은요?\n\n우리는 많은 실수를 저지르지 말고 전용 라이브러리를 사용해야 합니다. 예를 들어, ts-essentials 라이브러리와 많은 다른 라이브러리가 관련된 타입을 포함하고 있습니다.\n\n다음 명령어를 입력하여 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nbun install ts-essentials\n\n이제 아래의 코드를 작성할 수 있습니다:\n\nimport type { DeepWritable } from ‘ts-essentials’;\n\ntype WritableGroup = DeepWritable\u003cGroup\u003e;\n\n# Enumerations\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZod에서 열거형을 정의하는 세 가지 방법이 있습니다:\n\n- 네이티브 열거형 사용\n- Zod의 리터럴 유니언 사용\n- Zod의 열거형 사용\n\n각 방법은 적절한 구문 분석과 유추된 유형을 제공합니다. 차이점은 열거된 모든 값을 액세스하는 데 있습니다.\n\n예를 들어, 언어 목록이 있다면 사용자의 선택을 유효성 검사하고 목록을 프론트 엔드에 전송하여 드롭다운에서 표시해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_5.png\" /\u003e\n\n## 네이티브 열거\n\nTypeScript를 사용하면 컴파일 시에 존재하고 런타임에도 존재하는 열거형(enum) 타입을 선언할 수 있습니다. 예를 들어, 다음과 같이 관심 수준을 나타내는 enum을 정의할 수 있습니다:\n\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n};\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZod는 열거 유형에서 스키마를 작성하는 방법을 제공합니다. 아래 코드 스니펫에서와 같이:\n\nconst interestLevelSchema = z.nativeEnum(InterestLevel);\n\n만약 const 키워드로 InterestLevel 열거 유형을 선언했다면, 이전에는 컴파일 시간에만 존재했기 때문에 Zod 도우미를 사용할 수 없었습니다.\n\n열거된 모든 값을 추출하려면 다음 코드를 작성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevels = Object.values(InterestLevel);\n\n## Zod의 리터럴 유니언\n\n다른 패턴을 사용하여 열거 스키마를 정의할 수 있습니다. 결국, 열거는 문자열 또는 숫자 리터럴의 유니언입니다.\n\n각 관심 수준 리터럴에 대한 스키마를 작성해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevelLiteralSchemata = [\n  z.literal('low'),\n  z.literal('medium'),\n  z.literal('high'),\n] as const;\n\n자 이제 적절한 스키마와 타입을 정의할 시간입니다:\n\nconst interestLevelSchema = z.union(interestLevelLiteralSchemata);\ntype InterestLevel = z.infer\u003ctypeof interestLevelSchema\u003e;\n\n마지막으로, 모든 열거된 값을 추출할 수 있습니다:  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevels = interestLevelLiteralSchemata\n  .map((literal) =\u003e literal.value);\n\n## 조드의 열거\n\n열거 스키마를 정의하는 내가 가장 좋아하는 방법은 조드의 열거 도우미를 사용하는 것입니다.\n\n다음과 같은 방법으로 스키마를 작성하고 타입을 추론할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconst interestLevelSchema = z.enum(['low', 'medium', 'high']);\ntype InterestLevel = z.infer\u003ctypeof interestLevelSchema\u003e;\n\n모든 열거된 값 추출을 한 줄로 처리할 수 있습니다:\n\nconst interestLevels = interestLevelSchema.options;\n\n# 구분된 연합(Unions)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 유니언 타입에서는 컴파일러가 많은 서로 다른 타입을 구분합니다. 디스크리미네이트 유니언에서는 컴파일러가 공유 프로퍼티를 기준으로 구분합니다. 예를 들어, 애플리케이션의 작업을 특정 액터인 사용자 또는 그룹에 할당할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_6.png)\n\n제가 액터 스키마를 구현하고 다음과 같이 타입을 추론할 것입니다:\n\n```js\nconst userActorSchema = z.object({\n  type: z.literal('user'),\n  id: z.string(),\n});\n\nconst groupActorSchema = z.object({\n  type: z.literal('group'),\n  id: z.string(),\n});\n\nconst actorSchema = z.discriminatedUnion(\n  \"type\",\n  [userActorSchema, groupActorSchema],\n).readonly();\n\ntype Actor = z.infer\u003ctypeof actorSchema\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 선택에는 설명이 필요해요!\n\n먼저, 사용자와 그룹 액터의 스키마를 명시적으로 정의했어요. 이 방법은 구분된 연합의 각 구성 요소를 명명하고 들여쓰기 수준을 낮게 유지하죠.\n\n누군가 액터 스키마를 읽으면, 여러 줄로 이루어진 스키마를 읽지 않아도 내 의도를 즉시 추측할 거에요!\n\n둘째, 액터 유형을 스키마에서 추론했어요. 코드 베이스에서 연합 유형의 연산이 멤버 대신 발생하기를 기대하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째로, 나는 사용자의 종류와 그룹 활동자의 유형을 추론하지 않았어. 나중에 그들을 정의해야 한다면, 다음 패턴을 사용하여 그렇게 할 수 있을 것 같아:\n\n```js\ntype UserActor1 = z.infer\u003ctypeof userActorSchema\u003e;\ntype UserActor2 = Extract\u003cActor, { type: 'user' }\u003e;\ntype UserActor3 = Actor \u0026 { type: 'user' };\n```\n\n각각이 동일한 결과를 가져오는 것에도 불구하고, 나는 첫 번째 것을 사용하지 않을 거야. 왜냐하면 그것은 최소한 추론 규칙에 어긋나기 때문이야. 이미 활동자 유형을 추론을 통해 얻었다면 TypeScript 유형 도우미를 사용하여 더 정확한 유형을 추출할 수 있어.\n\n그리고 discriminatedUnion 메서드를 사용하여 식별 속성의 이름을 명시해야 하는 이유를 궁금해할 수도 있어. 일치시켜야 할 내용을 알면 Zod가 적합한 스키마를 빠르게 찾을 수 있어. 이러한 최적화를 피하고 싶다면 union 도우미를 사용할 수도 있었겠지.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기존 유형 변환\n\n기존 TypeScript 프로젝트에는 많은 유형이 포함되어 있을 것입니다. 이를 수동으로 작성하는 것은 여러분의 시간을 낭비하는 일입니다. 대신 LLM 또는 코드 완성 도구를 사용할 수 있습니다. 정확한 법적 조언은 제공하지 않겠지만, 소유 코드베이스에서 이러한 기술을 사용할 수 있는지 항상 확인합니다.\n\n각 LLM 제공업체는 모델에 제공하는 데이터에 대해 무엇이 발생하는지 알려줄 것입니다!\n\n특정 LLM을 추천하지는 않겠지만, 주요 모델들이 이 문제를 상당히 잘 처리합니다. 유형을 정의하고 스키마 정의를 시작해보세요. 몇 번 시도한 후에는 고품질 자동완성 스키마가 나올 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM을 완전히 믿지 마세요. 항상 결과를 검증해야 합니다!\n\n다양한 유형이 있다면, 먼저 그들의 정규 표현을 얻는 것을 추천합니다. AST 추출기를 작성하거나 TypeScript Language Server에 요청하여 이를 수행하거나, LLM이 작업을 처리하도록 할 수 있습니다. 처음 두 가지 가능성에 대해 LLM을 사용할 수 있습니다!\n\n정규 표현을 구문 분석하여 스키마를 생성하는 스크립트를 작성할 수 있습니다. 가장 큰 어려움은 스키마를 생성하는 것이 아니라 구문 분석에 사용하는 것입니다. 프로젝트 아키텍처의 완전한 변경이 필요할 수도 있습니다!\n\n![이미지](/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n나는 스키마와 유형 추론을 사용하는 것에 대한 설득력있는 주장을 펼쳤기를 희망합니다, 특히 LLMs와 함께. 아니라면, 의견을 남겨주세요! 다양한 기술적 주제에 대해 토론하는 것을 좋아합니다.\n\n가장 중요한 포인트를 되풀이하자면, 데이터를 단순히 유효성 검사하는 것이 아니라 파싱해야 한다고 생각합니다. 우리는 스키마를 작성하고 그로부터 유형을 추론해야 합니다. 나는 불변성을 지지하며 이 패러다임을 준수하는 스키마를 선호합니다. 또한 열거 유형 대신 스키마 리터럴을 사용하는 것을 좋아합니다.\n\n나는 내 코드가 파싱되지 않은 데이터에서 실행되지 않기 때문에 보다 빠르게 배포할 수 있습니다. 컴파일 시간 오류만 만날 것이라고 믿습니다. 애플리케이션 모니터링 덕분에 파싱이 실패할 때를 알 수 있습니다. 나는 LLM을 사용하여 스키마를 작성하고 유형을 더 빨리 추론할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이야기의 개념을 설명하는 부록을 작성했습니다. 이번에는 다른 스키마 라이브러리를 사용하여 @effect/schema와 yup을 설명합니다.\n\n# 부록 A: @effect/schema\n\n사용자 스키마를 정의하기 위해 다음과 같이 작성해야 합니다:\n\n```js\nimport { Schema } from \"@effect/schema\"\n\nconst userSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  claims: Schema.Number,\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 스키마는 이미 불변성을 준수합니다. 아래 스니펫을 사용하여 사용자 유형을 추론할 수 있습니다:\n\n```js\ntype User = Schema.Schema.Type\u003ctypeof userSchema\u003e;\n```\n\n위의 type helper는 다음 코드와 동일합니다:\n\n```js\ntype User = typeof userSchema.Type;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이브러리는 객체를 구문 분석하고 초과 속성을 허용하지 않습니다. 아래 내용을 확인해주세요:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = Schema.decodeSync(userSchema)(userWithExcessProperties);\n```\n\n그룹 스키마와 해당 유형은 사용자 스키마와 유사하게 정의할 수 있습니다:\n\n```js\nconst groupSchema = Schema.Struct({\n  id: Schema.String,\n  name: Schema.String,\n  userIds: Schema.Array(Schema.String),\n  interests: Schema.Array(\n    Schema.Struct({\n      id: Schema.String,\n      level: Schema.Union(\n        Schema.Literal('low'),\n        Schema.Literal('medium'),\n        Schema.Literal('high'),\n      ),\n    })\n  ),\n});\n\ntype Group = Schema.Schema.Type\u003ctypeof groupSchema\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 추론을 달성하기 위해 다음 코드를 작성합니다:\n\n```js\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: Schema.Schema\u003cT\u003e\n) =\u003e Schema.Struct({\n  datum: datumSchema,\n  checksum: Schema.String,\n});\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype ChecksumEnvelope\u003cT\u003e = Schema.Schema.Type\u003c\n  ReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n```\n\n@effect/schema를 사용하여 열거 스키마를 정의하는 세 가지 방법을 찾았습니다.\n\n첫 번째 방법은 리터럴의 합집합을 사용하는 것입니다. 아래 예제를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst interestLevelSchema = Schema.Union(\n  Schema.Literal('low'),\n  Schema.Literal('medium'),\n  Schema.Literal('high'),\n);\n\ntype InterestLevel = Schema.Schema.Type\u003ctypeof interestLevelSchema\u003e;\n```\n\n스키마 속성에 액세스하여 관심 수준 목록을 추출할 수 있습니다. 아래에 나와있는 것처럼:\n\n```js\nconst interestLevels = interestLevelSchema\n  .members\n  .flatMap((member) =\u003e member.literals);\n```\n\n두 번째 접근 방법은 스키마 리터럴 도우미를 사용하는 것입니다. 한 줄로 스키마를 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst interestLevelSchema = Schema.Literal(‘low’, ‘medium’, ‘high’);\n```\n\n우리는 모든 값을 가져 오기위한 한 줄짜리도 사용할 것입니다:\n\n```js\nconst interestLevels = interestLevelSchema.literals;\n```\n\n이 라이브러리를 사용하면 네이티브 열거 유형을 사용할 수 있습니다! 다음 조각을 살펴보세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst interestLevelSchema = Schema.Enums(InterestLevel)\nconst interestLevels = Object.values(InterestLevel);\n```\n\n차별화 된 연합을 정의하는 것이 더 간단하지 않았을 것입니다. 아래 코드 조각을 읽어보세요.\n\n```js\nconst userActorSchema = Schema.Struct({\n  type: Schema.Literal('user'),\n  id: Schema.String,\n});\n\nconst groupActorSchema = Schema.Struct({\n  type: Schema.Literal('group'),\n  id: Schema.String,\n});\n\nconst actorSchema = Schema.Union(userActorSchema, groupActorSchema);\ntype Actor = Schema.Schema.Type\u003ctypeof actorSchema\u003e;\n```\n\n# 부록 B : Yup\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYup을 사용한 사용자 스키마는 다음과 같습니다:\n\n```js\nimport Yup from ‘yup’;\n\nconst userSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  claims: Yup.number().required(),\n}).noUnknown();\n```\n\n이 라이브러리에는 두 가지 주의 사항이 있습니다. 먼저, 필수 도우미를 사용하여 비널 값 받아들이기, 두 번째로 초과 속성을 제외하려면 noUnknown 도우미를 사용해야 합니다.\n\n하지만, 여기에 더 많은 내용이 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추론된 유형에서 스키마를 불변성을 보장하도록 강제하는 방법을 찾지 못했습니다. 다음과 같이 ts-essentials 라이브러리의 DeepReadonly 유형 도우미를 사용해야 했습니다:\n\n```js\ntype User = DeepReadonly\u003cYup.InferType\u003ctypeof userSchema\u003e\u003e;\n```\n\n위의 유형은 다음과 같습니다:\n\n```js\ntype User = DeepReadonly\u003ctypeof userSchema['__outputType']\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도서관은 내가 정의한 구문 분석을 수행하는 validateSync라는 메서드를 제공합니다:\n\n```js\nconst userWithExcessProperties = {\n  id: '1',\n  name: 'Alice',\n  claims: 0x02,\n  excessProperty: 1,\n};\n\nconst user = userSchema.validateSync(userWithExcessProperties);\n```\n\n그룹 스키마를 다음 형식으로 정의하기를 제안합니다:\n\n```js\nenum InterestLevel {\n  Low = 'low',\n  Medium = 'medium',\n  High = 'high',\n}\n\nconst groupSchema = Yup.object({\n  id: Yup.string().required(),\n  name: Yup.string().required(),\n  userIds: Yup.array(\n    Yup.string().required()\n  ).required(),\n  interests: Yup.array(\n    Yup.object({\n      id: Yup.string().required(),\n      level: Yup.mixed\u003cInterestLevel\u003e()\n        .oneOf(Object.values(InterestLevel))\n        .required(),\n    })\n  ).required(),\n}).noUnknown();\n\ntype Group = DeepReadonly\u003cYup.InferType\u003ctypeof groupSchema\u003e\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 주의깊게 살펴봤다면, 관심 수준을 위한 enum 형식을 볼 수 있었을 것입니다. 곧 enum을 사용하는 이유에 대해 설명할 것입니다.\n\n아래 예제에서 제시된대로 제네릭 추론을 달성할 수 있습니다:\n\n```js\nconst buildChecksumEnvelopeSchema = \u003cT\u003e(\n  datumSchema: Yup.Schema\u003cT\u003e\n) =\u003e Yup.object({\n  datum: datumSchema,\n  checksum: Yup.string().required(),\n}).noUnknown();\n\nconst userEnvelopeSchema = buildChecksumEnvelopeSchema(userSchema);\nconst groupEnvelopeSchema = buildChecksumEnvelopeSchema(groupSchema);\n\ntype UserChecksumEnvelope = DeepReadonly\u003c\n  Yup.InferType\u003ctypeof userEnvelopeSchema\u003e\n\u003e;\n\ntype GroupChecksumEnvelope = DeepReadonly\u003c\n  Yup.InferType\u003ctypeof groupEnvelopeSchema\u003e\n\u003e;\n\ntype ChecksumEnvelope\u003cT\u003e = DeepReadonly\u003c\n  Yup.InferType\u003cReturnType\u003ctypeof buildChecksumEnvelopeSchema\u003cT\u003e\u003e\u003e\n\u003e;\n\ntype UserChecksumEnvelope = ChecksumEnvelope\u003cUser\u003e;\ntype GroupChecksumEnvelope = ChecksumEnvelope\u003cGroup\u003e;\n```\n\n약속한 대로, Yup에서 enum 유형을 사용하는 것이 가장 합리적인 이유를 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 열거형 유형의 스키마를 손쉽게 만들 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed\u003cInterestLevel\u003e()\n  .oneOf(Object.values(InterestLevel))\n  .required();\n```\n\n모든 값을 배열로 먼저 정의해야하는 두 번째 방법도 있습니다:\n\n```js\nconst interestLevels = [\n  'low',\n  'medium',\n  'high',\n] as const;\n\ntype InterestLevel = typeof interestLevels[number];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 한 줄로 스키마를 작성할 수 있습니다:\n\n```js\nconst interestLevelSchema = Yup.mixed\u003cInterestLevel\u003e()\n  .oneOf(interestLevels)\n  .required();\n```\n\n여기에는 공용 체계에 대한 스키마를 작성하는 상세한 지침이 있어야 합니다. 유감스럽게도 Yup을 사용하여 지원하는 것을 찾지 못했습니다. 그러나 해결책을 찾았습니다.\n\n스키마 시퀀스가 있는 경우, 각 스키마를 사용하여 객체를 구문 분석하는 함수를 작성하여 일치하는 것을 찾을 때까지 시도할 수 있습니다. 빠르게 작성하는 데 도움이 되는 LLM을 사용할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정된 제한 시간이 초과되어 서비스에 영향을 줄 수 있습니다. 해당 작업에 대한 피드백이 필요하신 경우 언제든지 알려주세요!","ogImage":{"url":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png"},"coverImage":"/assets/img/2024-06-20-HowIShipFasterwithTypeScriptSchemataandInference_0.png","tag":["Tech"],"readingTime":19},{"title":"앵귤러 디렉티브 쉽게 사용자 인터페이스 향상하기","description":"","date":"2024-06-20 02:46","slug":"2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png\" /\u003e\n\n앵귤러, 인기 있는 자바스크립트 프레임워크로, 개발자에게 강력한 도구를 제공하여 동적이고 대화식 웹 애플리케이션을 만들 수 있게 합니다. 이 중요한 도구 중 하나는 디렉티브입니다. 이 블로그 게시물에서는 앵귤러의 디렉티브에 대해 깊이 있는 내용을 다루고, 그 종류를 탐색하며 사용법을 보여주는 코드 예제를 제공할 것입니다.\n\n# 디렉티브란 무엇인가요?\n\n디렉티브는 HTML을 확장하여 DOM 요소에 사용자 지정 동작을 부여하거나 새 HTML 요소를 생성하는 방법입니다. 이는 앵귤러의 선언적 사용자 인터페이스 구축 방식의 중요한 부분입니다. 디렉티브를 사용하면 DOM을 조작하거나 CSS 스타일을 적용하고 사용자 입력을 처리하는 등 다양한 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지시문의 종류\n\nAngular는 네 가지 종류의 지시문을 제공합니다.\n\n- 컴포넌트 지시문: Angular에서 가장 일반적인 지시문 유형입니다. 컴포넌트는 템플릿이 있는 지시문입니다. 사용자 인터페이스의 일부를 캡슐화하며 종종 연관된 로직을 갖습니다. 재사용 가능한 UI 구성 요소를 만드는 데 사용됩니다.\n- 속성 지시문: 속성 지시문은 요소, 컴포넌트 또는 다른 지시문의 외관 또는 동작을 변경합니다. 일반적으로 HTML 요소의 속성으로 적용됩니다. 예시로는 ngClass, ngStyle 및 ngModel이 있습니다.\n- 구조 지시문: 구조 지시문은 요소를 추가하거나 제거함으로써 DOM 구조를 수정합니다. 가장 잘 알려진 구조 지시문은 ngIf, ngFor 및 ngSwitch입니다.\n- 사용자 정의 지시문: 개발자는 Angular의 기능을 확장하기 위해 사용자 정의 지시문을 생성할 수 있습니다. 사용자 정의 지시문은 속성 지시문, 구조 지시문 또는 둘 다가 될 수 있습니다. 복잡한 동작을 캡슐화하고 코드를 더 모듈화하는 데 유용합니다.\n\n이제 Angular에서 지시문을 사용하는 방법을 이해하기 위한 일부 실용적인 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제 1: ngIf 구조 지시문 사용하기\n\nngIf 지시문은 주어진 표현식에 기반하여 요소를 조건부로 렌더링하는 데 사용됩니다.\n\n```js\n\u003c!-- app.component.html --\u003e\n\n\u003cdiv *ngIf=\"isLoggedIn\"\u003e\n  \u003cp\u003eWelcome, { username }!\u003c/p\u003e\n\u003c/div\u003e\n```\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  isLoggedIn = true;\n  username = 'John';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 isLoggedIn이 true인 경우에만 문단 요소가 렌더링됩니다.\n\n# 예제 2: 최소 글자 수를 위한 커스텀 디렉티브 생성\n\n텍스트 필드에 사용자 입력이 최소 글자 요구 사항을 충족하는지 확인하고 싶다고 상상해보세요. Angular의 커스텀 디렉티브를 사용하여 이를 달성할 수 있습니다. 이를 위해 appMinLength이라는 커스텀 디렉티브를 생성해 봅시다.\n\n## 디렉티브 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에있는 텍스트를 친절한 톤으로 한국어로 번역해 드리겠습니다.\n\n여기 AppMinLength 지시문을 만드는 방법이 있습니다:\n\n```js\n// min-length.directive.ts\nimport { Directive, Input, ElementRef, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[appMinLength]',\n})\nexport class MinLengthDirective {\n  @Input('appMinLength') minLength: number;\n  constructor(private el: ElementRef) {}\n  @HostListener('input') onInput() {\n    const inputValue: string = this.el.nativeElement.value;\n    if (inputValue.length \u003c this.minLength) {\n      this.el.nativeElement.setCustomValidity(`최소 길이는 ${this.minLength}자여야 합니다.`);\n    } else {\n      this.el.nativeElement.setCustomValidity('');\n    }\n  }\n}\n```\n\n이 지시문을 단계별로 이해해 봅시다:\n\n- 우리는 [appMinLength] 선택자를 사용하여 HTML 요소의 속성으로 사용될 것임을 나타내는 MinLengthDirective 라는 사용자 정의 지시문을 정의합니다.\n- @Input('appMinLength') minLength: number; 데코레이터를 사용하여 지시문에 최소 길이를 입력으로 전달할 수 있습니다. 이 길이는 템플릿에서 지시문을 사용할 때 지정됩니다.\n- 생성자에서 ElementRef를 주입하여 지시문이 적용된 DOM 요소에 액세스할 수 있습니다.\n- @HostListener('input') 데코레이터를 사용하여 요소에서 입력 이벤트를 청취합니다. 이 이벤트는 사용자가 입력 필드에 문자를 입력하거나 삭제할 때 트리거됩니다.\n- onInput 메서드 내에서 요소로부터 현재 입력 값을 검색합니다.\n- 입력 값의 길이를 지정된 minLength과 비교합니다. 입력 길이가 필요한 최소값보다 작으면 setCustomValidity를 사용하여 사용자에게 최소 문자 요구 사항을 보여주는 사용자 지정 유효성 메시지를 설정합니다.\n- 입력 길이가 최소 요구 사항을 충족하는 경우 사용자 정의 유효성 메시지를 지웁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 정의 지시문 적용\n\nAngular 컴포넌트 템플릿에서 이 사용자 정의 지시문을 사용하려면 다음과 같이 입력 필드에 속성처럼 적용할 수 있습니다:\n\n```js\n\u003c!-- app.component.html --\u003e\n\n\u003cinput type=\"text\" placeholder=\"텍스트 입력\" [appMinLength]=\"5\" required\u003e\n```\n\n이 예시에서는 입력 필드의 최소 길이를 5글자로 지정했습니다. 사용자가 다섯 글자 미만으로 양식을 제출하려고 시도하면 유효성 검사 오류가 발생하여 입력이 필요한 최소 길이를 충족시키도록 보장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이런 맞춤 지시문을 사용하면 Angular 애플리케이션에서 특정 동작이나 제약 조건을 강제할 수 있어요. 이렇게 하면 요소들 사이의 일관성과 사용성이 향상됩니다.\n\n# 예시 3: ngFor 구조 지시문 사용\n\nngFor 지시문은 컬렉션을 반복하고 각 항목에 대해 요소를 렌더링하는 데 사용됩니다.\n\n```js\n\u003c!-- app.component.html --\u003e\n\u003cul\u003e\n  \u003cli *ngFor=\"let item of items\"\u003e{ item }\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  items = ['Item 1', 'Item 2', 'Item 3'];\n}\n```\n\n이 예제에서는 items 배열의 각 요소마다 목록 항목이 생성됩니다.\n\n# 결론\n\nAngular 디렉티브는 동적이고 상호작용적인 웹 애플리케이션을 만드는 강력한 도구입니다. 이를 사용하여 DOM을 조작하고 요소 렌더링을 제어하고 재사용 가능한 동작을 캡슐화할 수 있습니다. 디렉티브를 이해하고 효과적으로 사용함으로써 유지보수 가능하고 유연한 Angular 애플리케이션을 만들 수 있습니다. 프로젝트에서 디렉티브를 실험해보고 진정한 잠재력을 발견할 수 있을 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDirectivesEnhancingUserInterfaceswithEase_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 공부 순수하고 불량한","description":"","date":"2024-06-20 02:44","slug":"2024-06-20-JavascriptattheNunneryPureUndefiled","content":"\n\n가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png)\n\n## TLDR;\n\n자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# JavaScript의 문제\n\nJavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.\n\nJavaScript는 그 규칙의 예외입니다.\n\nJavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.\n\n# 커뮤니티의 문제\n\n진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.\n\n거짓말이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.\n\n# 해결책\n\n저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.\n\n## 클래스를 사용하지 않아요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!\n\n다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.\n\n![image](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png)\n\n그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png)\n\n클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.\n\n## 데코레이터는 사용하지 않아요\n\n사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.\n\n이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png)\n\n이 예제에서는 `speak` 함수를 우리의 `uppercase` 및 `emphasize` 데코레이터로 장식하여 `scream` 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 그런데 왜요?\n\n내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.\n\n## 클래스는 상태를 쌓는 경향이 있습니다\n\n이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png)\n\n객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.\n\n이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클래스 테스트하기 어렵습니다\n\n이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.\n\n저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.\n\n테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.\n\n함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 객체는 인지 부담을 줄입니다\n\n사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.\n\n결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.\n\n## 데코레이터는 영원히 함수에 데코레이터를 바인딩합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.\n\nspeak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png)\n\n나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장식자는 난해한 형식에 대한 지식이 필요합니다\n\n다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png\" /\u003e\n\n장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데코레이터들은 이를 필요로 합니다\n\n우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.\n\n저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.\n\n그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 \"잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요\" 입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png","tag":["Tech"],"readingTime":6}],"page":"39","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"39"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>