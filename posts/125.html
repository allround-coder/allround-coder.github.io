<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/125" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/125" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Gulp v5를 발표 내용 정리" href="/post/2024-05-12-AnnouncingGulpv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AnnouncingGulpv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Gulp v5를 발표 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" href="/post/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 스크레이퍼의 도구 상자 필수 도구와 전략</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" href="/post/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 5 게임 만들기  타일 게임 튜토리얼" href="/post/2024-05-12-MakeHTML5GamesTileGameTutorial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 5 게임 만들기  타일 게임 튜토리얼</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현대 웹을 위해 새롭게 탄생한 자동완성 상자" href="/post/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">현대 웹을 위해 새롭게 탄생한 자동완성 상자</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 18의 새로운 기능 정리 비교" href="/post/2024-05-12-Angular18NewFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Angular18NewFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 18의 새로운 기능 정리 비교</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" href="/post/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DOM 기반 XSS에 대해서 알아보자" href="/post/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DOM 기반 XSS에 대해서 알아보자" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DOM 기반 XSS에 대해서 알아보자" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">DOM 기반 XSS에 대해서 알아보자</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" href="/post/2024-05-12-MockingDatainreactjsorjavascript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" href="/post/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link posts_-active__YVJEi" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Gulp v5를 발표 내용 정리","description":"","date":"2024-05-12 23:43","slug":"2024-05-12-AnnouncingGulpv5","content":"\n![Announcing Gulp v5.0](/assets/img/2024-05-12-AnnouncingGulpv5_0.png)\n\ngulp 5로 가는 길은 길었지만, 우리가 여기까지 왔어요! 이 릴리스에는 60개 이상의 프로젝트에 대한 4년치 작업이 포함되어 있습니다. 함께하여 팀은 200개 이상의 이슈와 풀 리퀘스트를 마무리했어요. 🤯\n\n# Streamx\n\n처음부터 gulp는 스트림을 중심으로 만들어졌어요. gulp 5에서는 mafintosh의 우수한 streamx 라이브러리로 전환했어요. Streamx에는 Node.js 코어 스트림 대비 여러 이점이 있습니다. `pipe()` 함수에서 객체 및 버퍼 모드를 투명하게 처리하며 에러 처리가 가능해요.\n\n저희는 이 훌륭한 스트림 구현에 대해 더 많은 글을 쓸 시간을 갖고 싶어합니다. 그러나 대부분의 사용자들은 Node.js 코어 스트림과의 호환성을 유지하려는 노력 덕분에 차이를 느끼지 못할 것입니다. gulp 5 개발 과정에서 Mathias님의 도움과 버그 수정에 감사드립니다! 그의 작업을 후원해주시기를 고려해 주세요.\n\n# 종속성\n\n이번 릴리스의 주요 초점은 의존성 트리를 줄이고 대부분 유지하는 것으로 통합하는 데 있습니다. gulp 4가 발표된 이후 사용하던 많은 종속성이 유지되지 않았고, 따라서 이를 제거하거나 유지 책임을 갖기로 결정했습니다.\n\ngulpjs GitHub 조직은 70개 이상의 저장소로 성장했습니다. 이 세분화된 분리는 우리가 빠르게 작은 수정을 할 수 있게 하며, 다른 프로젝트들이 우리 패키지의 일부에 의존할 수 있게 합니다. 그러나 이에 대한 희생은 프로젝트 전체에 대한 대규모 변화를 만들기까지 시간이 걸린다는 것입니다.\n\n# 주요 변경 사항\n\n\"breaking changes\"가 없는 SemVer 주요 릴리스는 없겠죠. 유저들이 업그레이드할 때 문제가 없거나 거의 없기를 바라지만, 변경된 사항을 꼭 숙지하셔야 합니다.\n\n이번 대규모 릴리스에서 여기서 다루는 변경 사항은 일부분에 불과하기 때문에, 무언가가 다르게 느껴지는 것이 있다면 저희의 종합 변경 로그와 개별 프로젝트 변경 로그를 확인해주세요.\n\n## 스트림 인코딩\n\n저희 스트림은 이제 UTF-8 인코딩이 기본 설정으로 적용됩니다. 이전에는 스트림이 발생한 데이터를 인코딩을 고려하지 않고 그대로 가져왔었는데, 이번 릴리스에서는 10년 된 문제를 해결하여 사용자 정의 인코딩을 지원하고 이를 기본값으로 UTF-8로 설정했습니다. 대부분의 사용 방법은 gulp을 변경할 필요가 없을 것이지만, 일부 플러그인은 UTF-8이 아닌 출력물을 생성할 수 있으며 gulp 스트림에서 `' encoding: false '`로 설정해야 할 수 있습니다.\n\n## 글롭(Globs)\n\n또한 모든 API에서 글로빙 라이브러리를 통일했습니다. 이전에는 `src()`가 node-glob 라이브러리를 사용하고 `watch()`가 anymatch 라이브러리를 chokidar를 통해 사용했었습니다. 몇 년 동안 특정 글로브들이 이러한 함수 간에 동일하게 작동하지 않는 문제가 여러 개 개설되었었습니다. gulp 5부터는 글로브 지원으로 일관되게 anymatch를 사용합니다.\n\n게다가 “순서가 있는 글로브(ordered globs)\"를 더 이상 지원하지 않습니다. “순서가 있는 글로브\"는 음수 글로브가 배열에서 뒤에 나오는 양수 글로브에 의해 무시될 수 있는 기능이었습니다. 다른 글로빙 라이브러리에서는 이것이 흔하지 않기 때문에 모든 음수 글로브는 생태계에 일관성을 주기 위해 모든 양수 글로브에서 경로를 필터링합니다. 순서가 있는 스트림이 필요하면, ordered-read-streams 라이브러리를 제공합니다.\n\n## CLI\n\n우리는 `swc`, `esbuild`, 그리고 `sucrase`의 로더를 추가했어요. 많은 사용자들이 `.mjs`와 `.cjs` 확장자를 지원해줄 것을 요청했기 때문에, 이제 이 둘을 사용할 수 있어요. 의존성 트리를 간소화하는 과정에서 많은 구식이며 폐기된 로더들을 제거했어요. 만약 우리가 지원했던 더 색다른 로더들을 사용 중이셨다면, 더 현대적인 것으로 변경해야 할지도 모르겠어요.\n\n우리는 `—verify` 플래그를 마침내 제거했어요. 왜냐하면 오랫동안 플러그인 금지 목록을 유지하지 않고 있어서 그랬거든요. 그리고 `—require`를 `—preload`로 이름을 변경해야 했어요. 그렇게 함으로써 Node.js 플래그와 충돌을 피할 수 있어요.\n\n## Logging\n\n`gulplog`을 사용하는 모든 플러그인은 v1에서 v2로 업그레이드해야 하며, 만약 v1을 사용 중이면 사용자에게 사용 중단 경고가 표시됩니다.\n\n# 노드 지원\n\n우리는 오랫동안 gulp가 안정적인 소프트웨어임을 말해 왔으며, 가능한 많은 사용자를 지원하는 것에 관심이 있습니다. Gulp 4는 릴리스 시점에 널리 사용되었던 Node.js v0.10 사용자를 목표로 지원하는 것을 명시적으로 설정하였습니다. 10년이 지난 지금, 플랫폼이 성장하고 JavaScript가 발전함에 따라 Node.js는 이제 6개월마다 새로운 안정 버전을 출시하며, LTS 지원 기간은 30개월입니다. 이러한 새로운 버전에는 gulp를 더 나아지고 더 안정적으로 만들기 위해 활용하길 원하는 기능이 포함되어 있어서, 우리는 Node.js v10.13.0 미만의 모든 버전을 지원 중단했습니다.\n\n지원하는 Node.js 버전을 제한함으로써 의존성 트리에서 많은 플랫폼 및 JavaScript 쉼들을 제거할 수 있었습니다. 이 중 많은 부분은 유지보수되지 않았거나 스캐너에 의해 문제가 발견된 것입니다. 2018년에 발표된 Node.js 버전(그리고 LTS 지원 기간 외부)을 계속 지원함으로써 희망을 갖고 있습니다. 모든 사용자가 gulp 5로 원활하게 업그레이드할 수 있기를 바랍니다.\n\n마침내, 우리는 Windows, Mac 및 Linux을 우선 플랫폼으로 고려해 왔기 때문에 v3, v4 및 v5 사이의 인프라에 상당한 변동이 있었습니다. 이 세 가지 운영 체제를 일관되게 지원하고 사용하기 쉬운 지속적 통합 서비스를 찾는 데 많은 시간이 소요되었습니다. 우리는 우리 주요 대상을 지원하고 release-please와 같은 도구를 활용할 수 있는 GitHub Actions을 중심으로 인프라를 안정화하는 데 상당한 시간을 투자했습니다.\n\n# 앞으로\n\n할 일은 언제나 더 많이 남아 있습니다. 다가오는 몇 주 동안, 나는 우리 v5 이후 프로젝트 보드를 검토하고 중단되지 않는 후속 작업을 위한 토의를 만들 계획입니다. 우리는 gulp 5를 일정 기간 안정화한 후 다음 주요 버전을 계획하기 전에 문제가 발생하면 수정할 수 있도록 할 것입니다.\n\n우리는 더 넓은 커뮤니티로부터 피드백을 받기 위해 설문 조사를 작성 중입니다. 5월 경에 발표될 예정이니 주목해주시기 바랍니다.\n\n지금은 새 릴리스를 즐기시길 바라며, 프로젝트에 기여하거나 저희의 작업을 후원해주시면 감사하겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png"},"coverImage":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터 스크레이퍼의 도구 상자 필수 도구와 전략","description":"","date":"2024-05-12 23:39","slug":"2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies","content":"\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png)\n\n# 1. 웹 스크래핑이란?\n\n웹 스크래핑은 웹사이트에서 데이터를 추출하는 기술입니다. 이 과정은 자동화된 도구를 사용하여 가격 목록, 제품 세부정보, 이메일 주소 및 심지어 이미지와 같은 특정 정보를 수집하는 것을 포함합니다. 수집된 데이터는 시장 조사, 경쟁 분석 또는 온라인 데이터베이스 업데이트와 같은 다양한 목적으로 사용될 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/0*MwktrV5bs-basgRX.gif)\n\n\n\n일반적으로 시작하는 과정은 스크레이퍼 프로그램이 웹 페이지에 요청을 보내는 것으로 시작합니다. 그런 다음 페이지의 HTML 콘텐츠를 구문 분석하여 특정 데이터 요소를 검색합니다. 웹 스크래핑의 유연성 덕분에 웹 사이트에서 보이는 거의 모든 유형의 정보를 캡쳐할 수 있어 데이터 기반 의사 결정에 귀중한 도구가 됩니다.\n\n## 2. 웹 스크래핑의 이점\n\n가격 모니터링:\n\n웹 스크래핑의 첫 번째 이점은 시장에서 제품 가격을 모니터링하는 것입니다. 예를 들어, 특정 유형의 식품을 판매하는 비즈니스를 소유하고 있다면, 유사한 항목이 판매되는 가격 범위를 항상 알고 있어야 합니다. 웹 스크래핑을 통해 가격을 쉽게 추적할 수 있습니다. 경쟁 업체가 얼마를 청구하는지 알면 자신의 제품 가격을 설정하는 것이 훨씬 간단해집니다.\n\n\n\n다른 회사로부터 정보 수집:\n\n다른 회사와 파트너십을 맺으려고 할 때 그들에 대해 더 많이 알아야 합니다. 웹 스크레이핑을 사용하면 잠재적인 파트너들에 대한 방대한 데이터를 수집할 수 있습니다. 이 정보를 통해 회사가 신뢰할 만하고 협력에 적합한지를 판단할 수 있습니다. 따라서 이 과정은 탄탄한 비즈니스 결정에 중요한 역할을 합니다.\n\n시장 조사:\n\n시장 조사는 모든 비즈니스에 있어 중요합니다. 사용자들이 원하는 것을 밝혀내고 효과적인 마케팅 전략을 구축하기 위한 기초 역할을 합니다. 시장 조사에는 가장 정확한 정보가 필수이며, 웹 스크레이핑은 이를 달성하는 데 도움을 줄 수 있습니다. 웹 스크레이핑을 통해 소비자들이 선호하는 최신 트렌드를 발견할 수 있습니다. 이 데이터를 분석하여 당신의 타겟 시장을 겨냥한 제품 개발을 안내하는 데 활용할 수 있습니다.\n\n\n\n뉴스 및 콘텐츠 모니터링:\n\n브랜드를 구축하는 가장 쉬운 방법 중 하나는 미디어를 새 제품 출시 행사로 초대하는 것입니다. 미디어는 행사를 취재하고 제품을 검토하여 귀중한 홍보를 만들어내어 비즈니스에 큰 도움이 됩니다. 미디어 보도를 모니터링하는 것은 웹 스크레이핑을 통해 손쉽게 할 수 있어 여러분의 제품 및 비즈니스에 대한 보도 내용을 확인할 수 있습니다.\n\n리드 생성:\n\n새로운 리드를 확보하기 위한 중요한 전략은 잠재고객으로부터 가능한 많은 연락처 정보를 수집하는 것입니다. 웹 스크레이핑은 잠재고객의 연락처 정보를 획득하는 데 매우 효과적인 방법으로, 새로운 고객을 대상으로 하는 데 도움이 됩니다.\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:960/0*LjUSDEg8no_fYQ64.gif)\n\n# 3. 웹 스크래핑 기술\n\n![image](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_1.png)\n\n일반적으로 웹 스크래핑에는 두 가지 방법이 있습니다:\n\n\n\n수동: 이 방법은 웹 페이지에서 데이터를 직접 복사하여 붙여넣기해야 합니다. 직관적이지만 대규모 데이터셋과 작업할 때 극도로 시간이 많이 걸리고 지루할 수 있습니다.\n\n자동: 이 방법은 코딩, 소프트웨어 응용 프로그램 또는 브라우저 확장 프로그램을 활용합니다. 자동화는 데이터를 신속하게 스크래핑할 수 있는 능력으로 인해 인기를 얻고 있습니다. 사용 중인 구체적인 도구 또는 소프트웨어에 따라 방법이 다르지만, 모든 웹 스크래핑 봇은 세 가지 기본 원칙을 따릅니다:\n\n- 요청:\n이 과정은 GET 방법을 사용하여 대상 웹 사이트에 HTTP 요청을 보내는 것으로 시작됩니다. 프로그램은 원하는 웹 페이지에 액세스하여 정보를 가져옵니다. 이 단계를 통해 봇이 연결을 설정하고 데이터 추출을 위해 웹 페이지를 식별할 수 있도록 합니다.\n- 파싱:\n웹사이트로부터 응답을 받은 후, 프로그램은 파싱 프로세스를 시작합니다. 파싱은 데이터 스크래핑 기술을 활용하여 웹 페이지에서 특정 데이터 포인트를 추출하는 것을 의미합니다. 프로그램은 HTML 마크업 또는 다른 구조적 형식을 기반으로 관련 정보를 식별하고 분리합니다.\n- 표시:\n파싱을 통해 원하는 데이터를 수집하고 식별한 후, 읽기 쉬운 보고서나 표시로 변환됩니다. 데이터는 테이블, 그래프 또는 이전에 정의된 사양이나 필요에 맞는 구조와 일치하는 다양한 형식으로 제시될 수 있습니다. 최종 목표는 정보를 쉽게 이해할 수 있는 형식으로 제공하여 추가 분석이나 전략적 의사 결정에 활용할 수 있도록 하는 것입니다.\n\n# 4. 웹 스크래핑 방법\n\n\n\n- 대상 웹사이트 선택\n스크래이핑할 웹사이트를 식별하여 시작하세요. 예를 들어, 고객 서평을 분석하려면 Amazon, Goodreads 또는 LibraryThing과 같은 웹사이트를 고려할 수 있습니다.\n- 페이지 검사\n코드에 뛰어들기 전에 스크래이핑할 데이터를 식별하는 것이 중요합니다. 페이지를 마우스 오른쪽 버튼으로 클릭하고 \"요소 검사\" 또는 \"페이지 소스 보기\"를 선택하여 웹사이트의 기본 HTML 코드를 확인합니다. 이를 통해 데이터의 구조를 파악할 수 있습니다.\n- 원하는 데이터 식별\nAmazon의 책 평가에 집중한다면, 페이지의 HTML 코드에서 평가가 있는 위치를 찾으세요. 대부분의 브라우저는 선택된 프런트엔드 콘텐츠와 해당 백엔드 코드를 강조합니다. 여기서 목표는 관련 데이터를 격리하는 데 도움이 되는 고유한 태그를 식별하는 것입니다.\n- 코드 작성\n관련 태그를 정확하게 찾았다면, 해당 태그를 스크래이핑 소프트웨어에 통합하세요. 이를 위해 파이썬이 주로 사용되며, 스크래이핑 프로세스를 단순화하는 강력한 라이브러리를 갖추고 있습니다. 분석하고 저장할 정확한 데이터를 책 제목, 작가 이름, 평점 등으로 지정하는 것을 잊지 마세요.\n- 코드 실행\n코드를 작성한 후에는 다음 단계인 실행 단계로 넘어가세요. 스크레이퍼는 사이트 접근을 요청하고 데이터를 추출하여 분석할 것입니다.\n- 데이터 저장\n추출, 분석 및 관련 데이터 수집을 마치면, 그것을 저장해야 합니다. 코드에 추가 라인을 넣어 알고리즘에 그 기능을 수행하도록 지시할 수 있습니다. 선택한 형식은 중요하지 않지만 가장 일반적인 Excel 형식에 준수해야 합니다. Python 정규식 모듈을 통해 코드를 실행하여 데이터셋을 더 깔끔하게 추출하는 것도 가능합니다.\n\n# 5. 웹 스크래이핑 도구\n\n웹 스크래이핑 도구는 웹사이트로부터 데이터를 자동으로 추출하기 위해 설계된 필수 소프트웨어 응용프로그램입니다. 이 도구들은 인터넷에서 대량의 정보를 수집하여 시장 조사, 감정 분석, 경쟁 분석 및 학술 연구와 같은 다양한 목적으로 정보를 접근 가능하고 사용 가능하게 만듭니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_2.png)\n\n\n\n서버 측 스크래핑을 위해 개발자들은 효율성과 속도 때문에 Node.js를 자주 사용합니다. Playwright와 같은 라이브러리는 무해한 브라우저를 제어할 수 있어 실제 사용자가 웹 페이지를 탐색하는 것처럼 상호 작용을 자동화할 수 있습니다. 이는 웹 사이트에 로그인하거나 사용자 상호 작용 시에만로드되는 동적 AJAX 콘텐츠를 캡처하는 것을 포함할 수 있습니다. 인기 있는 라이브러리 Cheerio는 HTML 분석을 간단하게 제공하여 jQuery와 유사하게 데이터를 선택하고 조작하기 쉽게합니다. 또한 서버 작업에 적합한 속도와 효율성이 추가되어 있습니다.\n\nPlaywright의 주요 기능 중 하나는 브라우저 콘텍스트의 사용으로, 별도 및 독립적인 브라우저 세션을 모의합니다. 이는 여러 페이지 또는 시나리오를 동시에 처리할 수 있기 때문에 대용량 데이터 집합을 스크래핑하거나 여러 웹 페이지를 동시에 모니터링하는 데 적합합니다. 이러한 브라우저 콘텍스트를 다양한 네트워크 조건이나 장치와 일치하도록 사용자 정의함으로써, 안티 봇 조치를 우회하고 정확한 데이터를 수집할 수 있습니다.\n\nPlaywright는 현대 웹 기술의 복잡성을 탐색하는 데 특히 뛰어납니다. 이러한 기술들은 클라이언트 측 렌더링을 위해 JavaScript에 매우 의존하기 때문입니다. Playwright는 실제 사용자가 콘텐츠와 상호 작용하는 방식을 복제하기 위해 전체 브라우저 세션을 시작하여 데이터가 완전히로드 될 때까지 스크래핑 작업을 수행합니다. 이 기능은 전통적인 스크래핑 방법으로 종종 놓치는 동적 콘텐츠를 정확하게 캡처하기 위한 필수적인 요소입니다.\n\n뿐만 아니라, JavaScript 웹 스크래핑 도구는 일정 간격으로 데이터 수집을 자동화하거나 특정 트리거에 응답하여 대량의 데이터를 효율적으로 처리할 수 있습니다. 캡처된 데이터는 JSON 또는 CSV와 같은 다양한 형식으로 내보낼 수 있으며, 데이터베이스 및 분석 파이프라인에 직접 공급하여 데이터 주도 애플리케이션과 프로세스에 쉽게 통합할 수 있습니다.\n\n\n\n자동화는 Playwright가 빛나는 또 다른 영역입니다. Node.js를 기반으로 한 이 프레임워크는 자동화된 스크레이핑 작업을 정기적으로 예약하거나 특정 이벤트에 의해 트리거할 수 있도록 가능하게 합니다. 이 수준의 자동화는 데이터셋을 최신 상태로 유지하고 수동 개입을 줄여 비즈니스 및 연구자들 모두에게 데이터 수집을 간소화합니다.\n\n# 6. HTML — HTML이란 무엇인가요?\n\n웹 스크레이핑에서 HTML은 중요합니다. 데이터가 추출되는 웹 페이지의 구조를 형성하기 때문입니다. 각 웹 페이지의 HTML 코드는 콘텐츠의 구조와 조직을 나타내며, 스크레이퍼가 특정 데이터 포인트를 탐색하고 찾는 데 도움을 줍니다. HTML 프레임워크에는 `div`, `a`, `table`과 같이 다양한 태그가 있으며, 각각이 단락, 링크, 이미지 및 테이블과 같은 다른 구성 요소를 나타냅니다.\n\nHTML의 계층 구조는 스크레이퍼가 콘텐츠가 어떻게 구성되어 있는지 이해하는 데 도움을 줍니다. 태그에는 id 및 class와 같은 속성이 포함되어 있으며, 이는 요소에 대한 고유한 식별자로 작용하여 스크레이퍼가 특정 정보를 빨리 찾을 수 있게 합니다. 예를 들어, 스크레이퍼가 특정 클래스 속성이 있는 'table'을 찾아 테이블 데이터를 추출하거나 고유한 id를 가진 'div' 내의 링크를 대상으로 할 수 있습니다.\n\n\n\n특별한 스크레이핑 도구와 라이브러리를 사용하여 HTML을 파싱하면 개발자는 스크레이퍼가 필요로 하는 정확한 태그 또는 패턴을 찾도록 지시할 수 있습니다. 예를 들어, 전자 상거래 사이트에서 제품 리뷰를 수집한다면, 스크레이퍼는 각 리뷰를 둘러싼 HTML 태그와 속성을 식별하며 사용자 평가, 댓글 및 제품 이름을 추출할 것입니다.\n\nJavaScript를 사용하여 콘텐츠를 비동기적으로 로드하는 동적 웹 페이지는 도전을 제기할 수 있습니다. 그러나 브라우저 자동화 도구를 갖춘 스크레이퍼는 실제 브라우징 세션을 시뮬레이트하여 원하는 데이터를 추출하기 전에 페이지가 완전히 렌더링되도록 할 수 있습니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003e간단한 HTML 예제\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ch1\u003e안녕, 세상아!\u003c/h1\u003e\n    \u003cp\u003e기본 HTML 페이지에 오신 것을 환영합니다.\u003c/p\u003e\n    \u003ca href=\"https://www.example.com\"\u003e예제 방문하기\u003c/a\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n# 설명:\n\n\n\n- `!DOCTYPE html`: 이 선언은 직접적으로 웹 스크래핑에 사용되지는 않지만 HTML5 표준을 기대한다는 것을 파서에 알려줍니다.\n- `html lang=\"en\"`: 페이지의 루트 요소로, 언어를 영어로 지정합니다. 언어 속성(lang)은 직접적으로 대상이 되지 않을 수 있지만, 언어 특정 사항에 기반한 조건부 스크래핑에 유용할 수 있습니다.\n- `head`:\n\n- `meta charset=\"UTF-8\"`: 이 태그는 문자 인코딩을 UTF-8로 설정합니다. 텍스트를 올바르게 해석하는 데 중요하며, 특히 영어가 아닌 콘텐츠를 스크래핑할 때 인코딩 문제를 피하기 위해 중요합니다.\n- `title`Simple HTML Example`/title`: 문서의 제목은 웹 스크래핑의 흔한 대상입니다. 페이지의 내용을 빨리 이해하거나 검색 결과 사이에서 페이지를 분류하는 데 자주 사용됩니다.\n\n4. `body`:\n\n- `h1`Hello, World!`/h1`: 제목은 스크래핑의 주요 대상이며, 주로 중요 정보나 요약을 포함합니다. 이 h1은 주제를 식별하는 데 사용되거나 웹 사이트를 통해 페이지 구조를 이해하는 데이터 세트의 일부로 사용될 수 있습니다.\n- `p`Welcome to a basic HTML page.`/p`: 단락 태그는 페이지의 본문 텍스트를 주로 담고 있습니다. 이 데이터를 스크래핑하여 설명, 세부 사항 또는 관련 텍스트 콘텐츠를 추출하는 데 유용할 수 있습니다.\n- `a href=\"https://www.example.com\"`Visit Example`/a`: 하이퍼링크는 스크래핑 중에 웹 탐색에 중요합니다. href 속성은 URL을 제공하여 링크를 따르거나 리소스를 수집하거나 연결된 페이지를 스크래핑하는 데 사용할 수 있습니다. 이는 재귀적 기술을 사용하여 연결된 페이지 전체에서 데이터를 검색하는 깊은 웹 스크래핑에 필수적입니다.\n\n\n\n# 7. HTTP - HTTP 개념\n\nHTTP 또는 HyperText 전송 프로토콜은 월드 와이드 웹에서 데이터 통신의 기본 프로토콜로, 웹 브라우저를 서버와 연결합니다. 웹 스크래핑에 있어서 HTTP의 복잡성을 이해하는 것은 웹 사이트에서 데이터에 효과적으로 접근하고 검색하는 데 중요합니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_3.png)\n\n웹 스크래핑과 관련된 HTTP의 기본적인 측면:\n\n\n\n요청 및 응답: HTTP의 핵심은 요청과 응답 프로세스에 있습니다. 웹 스크래퍼는 브라우저 요청을 시뮬레이트하여 웹 페이지를 검색합니다. 각 요청은 GET과 같은 다양한 방법을 활용할 수 있습니다. 페이지 내용을 가져 오는 데 일반적으로 사용되는 방법과 POST, 종종 폼 데이터를 제출하거나 사이트에 로그인하는 데 사용되는 방법을 사용할 수 있습니다.\n\n헤더: HTTP 요청 및 응답의 헤더는 중요한 메타 데이터를 전달합니다. 웹 스크래핑을 위해 User-Agent와 같은 헤더는 스크래퍼를 합법적인 브라우저로 위장시켜 기본적인 안티-스크래핑 검사를 우회하는 데 도움이 됩니다. 헤더 내의 쿠키는 세션 상태를 관리하여 스크래퍼가 여러 페이지를 걸쳐 로그인 상태를 유지할 수 있도록합니다.\n\n상태 코드: 이 코드는 클라이언트에게 요청 상태에 대해 알려줍니다. 예를 들어, 200 상태 코드는 성공을 나타내고 404는 요청한 리소스가 없음을 나타냅니다. 이러한 코드를 이해하면 스크래퍼가 오류와 리디렉션을 효과적으로 처리 할 수 있습니다.\n\n요청 제한: 많은 웹 사이트는 액세스 빈도를 제어하기 위해 요청 제한을 시행합니다. 웹 스크래퍼는 이러한 제한을 트리거하지 않도록 요청 속도를 관리해야하며, 그렇지 않으면 차단된 액세스 또는 법적 문제가 발생할 수 있습니다.\n\n\n\n안녕하세요! 아래는 Markdown 형식으로 새롭게 구성된 내용입니다:\n\n**보안 통신:** HTTP 요청은 HTTPS로 보안될 수 있습니다. 이를 통해 브라우저와 서버 간에 교환되는 데이터가 암호화됩니다. 이는 민감한 데이터를 수집할 때 개인 정보 보호와 보안을 유지하는 데 매우 중요합니다.\n\n**APIs:** API를 통해 데이터를 제공하는 웹사이트는 HTML 파싱보다 데이터에 접근하는 구조화된 방법을 제공하며 종종 더 신뢰할 수 있습니다. API는 일반적으로 JSON 또는 XML과 같은 형식으로 데이터를 응답하며, 이는 스크래퍼가 처리하기에 편리합니다.\n\n**8. PlayWright Javascript를 사용하여 가격 및 제품 정보 스크랩 합니다**\n\nJavaScript에서 Playwright를 사용하여 웹 스크래핑 스크립트를 생성하기 전에 필요한 개발 환경을 설정하는 것이 중요합니다. 이 준비 단계를 통해 효율적이고 효과적인 웹 스크래핑에 필요한 모든 도구와 라이브러리가 마련됩니다.\n\n\n\n개발 환경 설정하기\n\n1. Visual Studio Code (VS Code) 설치:\n\n- Visual Studio Code은 Microsoft에서 제공하는 가벼우면서도 강력한 소스 코드 편집기입니다. JavaScript와 Node.js를 기본으로 지원하며, 디버깅, 지능형 코드 완성 (IntelliSense), 쉬운 탐색을 포함한 다양한 확장 기능을 제공합니다.\n- 먼저, 공식 Visual Studio Code 웹사이트에서 Visual Studio Code를 다운로드하고 설치하세요. 운영 체제 (Windows, macOS 또는 Linux)에 맞는 설치 지침을 따릅니다.\n\n2. Node.js와 npm 설치:\n\n\n\n- Node.js는 서버 측에서 JavaScript를 실행할 수 있게 해주는 런타임 환경이에요. Node.js에는 npm(node package manager)이 포함되어 있어서 Node.js 애플리케이션에 대한 의존성을 관리하는 데 도움을 줘.\n- 공식 Node.js 웹사이트에서 Node.js를 다운로드하세요. 기본 옵션으로 Node.js를 설치하면 npm도 함께 설치되어 Playwright를 포함한 다양한 라이브러리를 다룰 준비가 돼.\n- 설치 후에는 터미널이나 명령 프롬프트를 열어 node -v와 npm -v를 입력하면 시스템에 설치된 Node.js와 npm의 현재 버전을 확인할 수 있어.\n\n3. Node.js 프로젝트 설정하기:\n\n- Visual Studio Code를 열고 새 프로젝트 폴더를 만들거나 기존 폴더로 이동해.\n- VS Code에서 터미널을 열고(또는 운영 체제 터미널을 사용해) 프로젝트 디렉토리로 이동한 후 npm init을 실행하여 새 Node.js 프로젝트를 초기화해. 이 명령은 프로젝트 디렉토리에 package.json 파일을 생성하며 모든 의존성과 프로젝트 메타데이터를 추적할 거야.\n\n4. Playwright 설치하기:\n\n\n\n- Node.js 환경이 준비되었습니다. npm install playwright 명령어를 실행하여 Playwright를 설치해보세요. 이 명령어는 Playwright와 의존성을 다운로드하고 이를 프로젝트의 node_modules 디렉토리에 추가합니다. 또한 package.json을 업데이트하여 Playwright를 의존성으로 포함시킵니다.\n- Playwright 설치에는 Chromium, Firefox 및 WebKit용 브라우저 이진 파일이 포함되어 있어 스크립트가 다양한 브라우징 환경을 시뮬레이트할 수 있습니다.\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n```\n\n- const playwright = require(`playwright`);:\n\n- 이 코드는 Playwright 라이브러리를 현재 파일로 가져옵니다. Playwright는 웹 스크레이핑 및 테스팅을 포함한 브라우저 자동화를 가능하게 하는 인기 있는 도구입니다.\n- 이 import를 통해 다양한 브라우저(Chromium, Firefox, WebKit)에서 프로그래밍 방식으로 웹 페이지와 상호 작용하는 Playwright API를 사용할 수 있습니다.\n\n\n\n2. const fs = require(`fs`);:\n\n- 이는 Node.js의 fs (파일 시스템) 모듈을 가져와요. 이 모듈은 로컬 파일 시스템과 상호작용하기 위한 함수들을 제공해요.\n- 이를 통해 스크립트는 파일을 읽고 쓸 수 있어요. 이는 로깅, 데이터 저장, 또는 기존 파일 작업에 유용해요.\n\n3. const path = require(`path`);:\n\n- 이는 Node.js의 path 모듈을 가져와요. 이 모듈은 파일 경로를 일관적이고 크로스 플랫폼으로 다루는 데 도움이 돼요.\n- 파일 및 디렉토리 경로를 처리하는 유틸리티를 제공하며, 운영 체제에 관계없이 올바른 구문을 사용하도록 해줘요.\n\n\n\n함께 해보기:\n\n- 이러한 import를 사용하면 스크립트가 Playwright를 기반으로 한 웹 스크래핑이나 브라우저 자동화 프로젝트를 위한 기반을 설정합니다.\n- playwright는 브라우저를 제어하여 URL로 이동하거나 요소를 클릭하고 데이터를 캡처하는 등의 상호작용을 가능하게 합니다.\n- fs는 스크래핑 프로세스 중에 수집된 데이터를 저장하는 데 도움을 주며, JSON이나 CSV 파일로 저장하는 것도 가능합니다.\n- path는 파일 경로를 적절하게 관리하여 어떤 운영 체제에서도 효율적으로 데이터를 저장하거나 읽을 수 있도록 도와줍니다.\n\n예시 사용 사례:\n\n- Playwright를 사용하여 웹페이지에 이동하고 정보를 스크래핑합니다.\n- fs를 사용하여 수집한 데이터를 구조화된 형식으로 저장합니다.\n- path를 사용하여 출력 파일을 효과적으로 정리합니다.\n\n\n\n```js\n(async () =\u003e {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n```\n\n- (async () =` '...')():\n\n- 이 구조는 즉시 호출되는 함수 표현식 (IIFE)으로, 코드가 정의된 즉시 실행되도록합니다.\n- async 키워드는 함수에 비동기 작업이 포함되어 있음을 나타내며, 함수 내부에서 await을 사용할 수 있도록 합니다.\n- 이 함수를 즉시 실행함으로써 비동기 작업을 깔끔하게 처리하고 전역 범위를 깔끔하게 유지할 수 있습니다\n\n2. const browser = await playwright.chromium.launch();:\n\n\n\n- 이 코드는 Playwright의 크로미움 엔진을 사용하여 브라우저 인스턴스를 초기화합니다.\n- playwright.chromium은 Playwright의 크로미움 브라우저 자동화 엔진을 가리킵니다. 비슷한 옵션으로는 firefox와 webkit이 있습니다.\n- launch()는 새로운 헤드리스(기본값) 브라우저 세션을 시작하는 비동기 메서드입니다.\n- await 키워드는 함수가 브라우저가 완전히 로드될 때까지 실행을 일시 중지하고, 그 후에 로드된 브라우저 인스턴스를 browser 변수에 할당합니다.\n\n3. const page = await browser.newPage();:\n\n- 이 코드는 시작된 브라우저 인스턴스 내에서 새 페이지(또는 탭)를 생성합니다.\n- 새 페이지는 독립적으로 작동하며, 한 페이지에서의 동작은 동일한 브라우저에서 열린 다른 페이지에 영향을 주지 않습니다.\n- await 키워드는 다시 한 번 새 페이지가 준비될 때까지 실행을 일시 중지하고, 이를 page 변수에 할당합니다.\n\n```js\n\n  await page.goto('https://www.unitedbike.com/bikes');\n```\n\n\n\n- await: 이 키워드는 프로미스가 해결될 때까지 함수 실행을 일시 중지합니다. 이 경우에는 페이지가 완전히로드될 때까지 기다린 후 다음 라인으로 진행합니다.\n- page.goto(url):\n- 'goto'는 Playwright가 제공하는 메소드로, 브라우저 페이지를 지정된 URL로 이동하도록 지시합니다.\n- 여기서 'url'은 방문할 웹 주소로, `https://www.unitedbike.com/bikes`로 지정되어 있습니다.\n- 이 라인이 실행되면 Playwright 페이지 인스턴스는 주어진 URL로 이동하여 실제 브라우저처럼 페이지를 완전히 렌더링하고 JavaScript 기반 동적 콘텐츠를 포함합니다.\n\n```js\n  const productInfoElements = await page.$$eval('.product-information', elements =\u003e elements.map(el =\u003e {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n```\n\n이 코드 스니펫은 Playwright 페이지 객체를 사용하여 특정 제품 정보를 추출하는 더 큰 웹 스크래핑 스크립트의 일부입니다. 각 부분의 설명을 보여드릴게요:\n\n- const productInfoElements = await page.$$eval(...):\n\n\n\n- const: 이 키워드는 페이지에서 추출된 데이터를 저장할 변수 productInfoElements를 선언합니다.\n- await: 이 함수는 작업이 완료될 때까지 실행을 일시 중지하여 데이터가 준비되면 변수에 할당됩니다.\n- page.$$eval:\n- $$eval은 페이지의 모든 일치하는 요소에 대해 함수를 평가하는 Playwright 메서드입니다.\n- 첫 번째 인수인 `.product-information`은 클래스가 .product-information인 모든 HTML 요소를 대상으로 하는 CSS 셀렉터입니다.\n- 두 번째 인수는 선택된 요소에 대해 실행할 함수이며, 이 함수는 해당 요소들을 매개변수 elements로 받습니다.\n\n2. elements.map(el =\u003e ` '...'):\n\n- 이 map 함수는 elements 배열의 각 HTML 요소를 반복하며 각각의 요소를 처리하여 필요한 정보를 추출합니다.\n\n3. const caption = el.querySelector(`.caption`).textContent.trim();:\n\n\n\n- 코드는 각 .product-information 요소 내에서 클래스가 .caption인 자식 요소를 검색합니다.\n- textContent는 해당 요소의 텍스트 콘텐츠를 가져오고, trim()은 앞뒤 공백을 제거합니다.\n- 결과는 caption 변수에 저장됩니다.\n\n4. const price = el.querySelector(`.price`).textContent.trim();:\n\n- 캡션과 유사하게, 이 줄은 클래스가 .price인 자식 요소를 검색합니다.\n- textContent는 .price 요소의 내부 텍스트를 추출하는데, 일반적으로 제품의 가격을 나타냅니다.\n- trim()은 추가로 공백이 포함되지 않도록 합니다.\n\n5. return $'caption',$'price';:\n\n\n\n- 각 반복은 캡션과 가격 값을 쉼표로 구분된 형식으로 반환하는 문자열을 생성합니다.\n\n```js\nconst outputFilePath = path.join(__dirname, 'product_information.csv');\n\nfs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\nconsole.log(`Data telah diekspor ke file: ${outputFilePath}`);\nawait browser.close();\n```\n\n- const outputFilePath=path.join(__dirname,`product_information.csv`);:\n\n- path.join:\n- join은 여러 경로 세그먼트를 하나의 일관된 경로 문자열로 결합하는 path 모듈의 메서드입니다.\n- 올바른 경로 구분자를 자동으로 적용하여 경로를 크로스 플랫폼으로 만듭니다(예: Windows의 백슬래시, Linux/macOS의 슬래시).\n- __dirname:\n- 이 특별한 변수는 현재 실행 중인 스크립트가 위치한 디렉토리의 절대 경로를 보유합니다.\n- `product_information.csv`:\n- 이것은 데이터가 저장될 CSV 파일의 이름입니다.\n- path.join을 사용하면 실행 중인 스크립트의 디렉토리 내에 product_information.csv라는 이름의 파일의 전체 경로가 생성됩니다.\n\n\n\n2. fs.writeFileSync(outputFilePath, productInfoElements.join(`\\n`), `utf8`);:\n\nfs.writeFileSync:\n\n- fs 모듈의 이 동기 방식 메서드는 지정된 파일에 데이터를 직접 작성합니다.\n- 세 가지 주요 인수를 취합니다.\n\n- productInfoElements는 문자열의 배열(아마 제품 데이터를 포함한 것으로 예상)이어야 합니다.\n- join(`\\n`)은 이러한 문자열을 새 줄 문자(\\n)로 구분하여 하나의 문자열로 연결하므로 CSV 데이터로 작성하기에 적합합니다.\n\n\n\n- UTF-8로 지정된 인코딩 형식을 사용하여 파일에 올바른 텍스트 표현을 보장합니다.\n\n3. console.log('데이터가 파일로 내보내졌습니다: $'outputFilePath');:\n\n- 생성된 파일의 경로를 제공하고 데이터가 내보내졌음을 확인하는 콘솔 메시지를 출력합니다.\n\n4. await browser.close();:\n\n\n\n- 이전에 스크립트를 시작할 때 열었던 Playwright 브라우저 인스턴스를 종료합니다.\n- 시스템 자원을 해제하고 모든 웹 스크래핑 작업이 완료된 후 깔끔하게 종료됩니다.\n\n이제 터미널에서 다음 코드를 실행하세요:\n\n```js\n$ node scrap.js\n```\n\n출력 결과는 다음과 같을 것입니다.\n\n\n| 모델명          | 가격                              |\n|----------------|-------------------------------|\n| VITESSA 2.00   | Rp 9,820,000, Rp 9,820,000   |\n| VITESSA 1.00   | Rp 7,960,000, Rp 7,960,000   |\n| STYGMA LITE   | Rp 14,060,000, Rp 14,060,000 |\n| STYGMA        | Rp 18,640,000, Rp 18,640,000 |\n| STERLING R2 DISC | Rp 33,260,000, Rp 33,260,000 |\n| STERLING R1 DISC | Rp 26,200,000, Rp 26,200,000 |\n| STERLING PRO DISC | Rp 75,000,000, Rp 75,000,000 |\n| OXYDE PRO     | Rp 67,725,000, Rp 67,725,000 |\n| OXYDE ONE     | Rp 20,370,000, Rp 20,370,000 |\n| KYROSS 2.1    | Rp 18,140,000, Rp 18,140,000 |\n| KYROSS 2.00+  | Rp 17,630,000, Rp 17,630,000 |\n| KYROSS 1.1    | Rp 12,850,000, Rp 12,850,000 |\n| KYROSS 1.00   | Rp 12,850,000, Rp 12,850,000 |\n| GAVRIIL       | Rp 16,620,000, Rp 16,620,000 |\n| E-GAVRIIL     | Rp 48,280,000, Rp 48,280,000 |\n| EPSILON T6    | Rp 45,350,000, Rp 45,350,000 |\n\n여기에 전체 코드가 있습니다:\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n\n(async () =\u003e {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n\n  await page.goto('https://www.unitedbike.com/bikes');\n\n  const productInfoElements = await page.$$eval('.product-information', elements =\u003e elements.map(el =\u003e {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n  }));\n\n  const outputFilePath = path.join(__dirname, 'product_information.csv');\n\n  fs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\n  console.log(`데이터가 파일로 내보내졌습니다: ${outputFilePath}`);\n  await browser.close();\n})();\n```\n\n아마도 여기까지 JavaScript 플레이 라이팅 소개의 끝입니다. 웹 스크래핑과 playwright에 대해 더 깊이 파고들고 싶다면 이 웹 사이트를 방문해보세요.\n\n\n\n\n감사합니다! :3","ogImage":{"url":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png","tag":["Tech"],"readingTime":17},{"title":"Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기","description":"","date":"2024-05-12 23:37","slug":"2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia","content":"\n\n![이미지](/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png)\n\nVue 2에서 Vue 3로 이주하면서 Pinia가 이제 Vue 3를 위한 권장 스토어 플러그인이 되었고 Vuex가 아니게 되어 전환이 필요했습니다. 우리 아키텍처와 팀 전체가 Vuex와 작업하는 데 익숙했기 때문에 모든 스토어를 하나의 전역 변수 $store로 액세스하고 모든 곳에서 손쉽게 액세스할 수 있을 때를 좋아합니다!\n\n그래서 우리는 Pinia에서 부족해 보이는 3가지 핵심 기능을 지원하기 위해 일부 사항을 수정했습니다.\n\n- 우리 아직까지 사용 중인 this.$store를 통해 스토어에 액세스하기\n- 중첩 구조의 스토어 보유\n- 액션 내에서 Vue Router에 액세스하기\n\n\n\n# 기본 설정\n\n우리는 src/stores 안에 비슷한 디렉토리 구조를 가진 모든 스토어를 생성했습니다.\n\n```javascript\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n```\n\n주요 index.js는 중첩과 모든 것을 포함한 완전한 스토어의 진입점 역할을 하며, 중첩이 어떻게 작동하는지 등에 대한 설명은 다음 단계에서 설명하겠습니다.\n\n\n\n```js\n// src/store/index.js\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\nexport default {\n  token: null\n}\n```\n\n\n\n```js\n// src/store/auth/getters.js\n\nexport default {}\n```\n\n# 1. Pinia에서 스토어 중첩하기\n\n기본적으로 Pinia는 필요할 때 스토어를 직접 가져와서 사용하는 것이지만, 우리가 원하는 것은 그게 아닙니다. Vuex에서 했던 것처럼 쉽게 접근하고 싶습니다. 그래서 다음과 같이 했습니다.\n\n메인 스토어에 스토어 이름(예: auth)으로 새로운 상태 변수를 만듭니다.\n\n\n\n```js\n// src/store/state.js\nexport default {\n  auth: null\n}\n```\n\n이 변수를 사용하려는 Pinia 스토어에 초기화하고 설정하세요. 예를 들어, authStore 를 사용하시려면 주요 스토어의 액션에 추가하여 필요한 모든 스토어를 초기화할 수 있습니다. 예를 들어, setStores()에 다음을 추가하세요.\n\n```js\n// src/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore() // 액션 내에서 스토어를 초기화합니다.\n    },\n    ... // 다른 메서드\n  }\n})\n```\n\n주요 스토어를 초기화한 후에 이 액션을 호출하세요.\n\n\n\n```js\n// main.js\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\nexport const $store = store() // 메인 스토어 초기화\n$store.setStores() // 모든 중첩 스토어 초기화하는 액션 호출\n```\n\n그게 다야! 이제 모든 스토어에 메인 스토어에서 직접 액세스할 수 있습니다. 다음은 예시입니다 (Options API),\n\n```js\n\u003cscript\u003e\nimport { $store } from \"@/main.js\"\n\nexport default {\n    mounted() {\n       console.log($store.auth.token) // auth 상태에 액세스\n       console.log($store.auth.setToken(\"12345\")) // auth 액션 호출\n       console.log($store.someState) // 메인 스토어 상태에 액세스\n    }\n}\n\n\u003c/script\u003e\n```\n\n# 2. 핀니아 스토어를 전역적으로 접근 가능하게 만들기\n\n\n\n이제 한 변수를 통해 중첩된 상점에 접근할 수 있게 되었으니, 이제 그것을 컴포넌트 내에서 직접 액세스할 수 있도록 만들어보겠습니다. 그렇게 하려면 vue의 Global Properties를 사용하여 매핑해야 합니다. 다음과 같이 해보세요.\n\n- main.js에서 메인 상점을 초기화하십시오.\n- $store라는 전역 속성을 설정하고 해당 상점을 할당하십시오.\n- 즐기세요!\n\n```js\n// main.js\n\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\n\nexport const $store = store() // 주 상점 초기화\napp.config.globalProperties.$store = $store // 상점을 전역적으로 액세스 가능하게 만듦\napp.config.globalProperties.$store.setStores() // 모든 중첩된 상점을 초기화하는 작업 호출\n```\n\n이것으로 끝났습니다! 이제 옵션 API를 사용하는 컴포넌트 내에서 다음과 같이 액세스할 수 있습니다:\n\n\n\n```js\n\u003cscript\u003e\nexport default {\n    mounted() {\n       console.log(this.$store.auth.token) // \"auth\" 상태에 접근하기\n       console.log(this.$store.auth.setToken(\"12345\")) // \"auth\" 액션 호출하기\n       console.log(this.$store.someState) // 메인 상점의 상태에 접근하기\n    },\n    watch: {\n        '$store.auth.token'() { console.log(\"변경 발생\") } // 워치하여 변경 감지하기\n    } \n}\n\n\u003c/script\u003e\n```\n\n# 3. 핀이아 액션 내부에서 Vue Router에 액세스하기\n\n우리는 상점에서 라우터 인스턴스를 직접 가져오고 사용하려고 시도했지만, 올바르지 않은 것처럼 보였습니다. 그때 우리는 특정 속성을 설정할 수 있는 방법을 찾았고 이렇게 설정할 수 있습니다.\n\n```js\n// main.js\n\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기서 라우터를 설정하여 상점 내에서 접근할 수 있도록 하기\napp.use(pinia)\n\n...\n```\n\n\n\n이렇게 하면 우리는 스토어 내에서 언제든지 라우터 인스턴스에 액세스할 수 있어요.\n\n```js\n// srcs/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    logRoute() {\n       console.log(this.router) // Router Instance\n       console.log(this.router.currentRoute) // 현재 라우트 가져오기 (this.$route)\n    }\n    ... // 다른 메서드\n  }\n})\n```\n\n그리고 이렇게 함으로써 우리는 세 가지 고통을 해결했어요! 세 가지가 모두 구현된 완전한 스크립트는 다음과 같아요.\n\n```js\n디렉토리 구조\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n  -\u003e main.js\n  -\u003e router\n     -\u003e index.js\n```\n\n\n\n```js\n// src/store/index.js\n\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\n\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\n\nexport default {\n  token: null\n}\n```\n\n\n\n```js \n// src/store/auth/getters.js\n\nexport default {}\n```\n\n```js\n// main.js\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기에 router를 설정하여 store 내부에서 접근할 수 있게 함\napp.use(pinia)\n...\n\nexport const $store = store() // 주요 Store 초기화\napp.config.globalProperties.$store = $store // Store를 전역적으로 접근 가능하게 함\napp.config.globalProperties.$store.setStores() // 모든 중첩 Store를 초기화하는 작업 호출\n```\n\n여기까지입니다! 같은 결과를 달성할 수 있는 다른 방법을 발견하면 알려주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"},"coverImage":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML 5 게임 만들기  타일 게임 튜토리얼","description":"","date":"2024-05-12 23:33","slug":"2024-05-12-MakeHTML5GamesTileGameTutorial","content":"\n\n## 모든 필요한 것\n\n이 튜토리얼과 매칭 비디오 튜토리얼에서는 HTML 5 Canvas와 JavaScript를 사용하여 타일 게임을 코딩하는 단계를 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png)\n\n타일 게임은 기본적으로 그리드로 배열된 게임이거나 타일을 드래그하는 게임입니다. 이 경우, 우리는 객체의 나머지가 변화하는 것과 달리 어떤 객체가 변하지 않는지 알아내는 그리드 기반 게임을 가지고 있습니다. 이 게임은 또한 패턴 게임이라고도 불릴 수 있습니다.\n\n\n\n화면 하단에는 찾아야 할 \"영원한\" 물체의 수와 소요된 시간이 표시됩니다. 다섯 개의 레벨이 있으며, 각 레벨마다 더 많은 물체와 찾아야 할 더 많은 물체가 있습니다. 리더보드를 사용하여 가장 낮은 시간을 추적합니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_1.png)\n\n간단한 Tile 게임과 완전한 Tile 게임 두 가지 예제가 있습니다. 먼저 간단한 것을 살펴보셔도 좋지만, 튜토리얼에서는 완전한 게임을 만드는 단계를 안내해드립니다.\n\n## 준비하기\n\n\n\n아무도 따라 할 수 있어야 하지만, 이러한 종류의 게임을 직접 만드는 데 사용되는 많은 기술과 기술이 있습니다. 이 마법의 세계를 소개하는 ◎ 캔버스에서 코딩 창의성 가이드를 확인해보세요.\n\n![게임 만들기](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_2.png)\n\n우리는 코딩 창의성을 위한 ZIM JavaScript 캔버스 프레임워크로 게임을 만들 것입니다! ZIM으로 만들 수 있는 다양한 것들을 확인해보기를 원할 수도 있습니다. ZIM으로 만들 수 있는 많은 것들이 있는 사이트도 확인해보세요. Zapp이 많이 있는 온라인 편집기도 있습니다!\n\n## 편집기\n\n\n\n일반적으로 Microsoft의 무료이고 빠르게 설치할 수 있는 VS Code와 같은 데스크탑 편집기에서 게임을 만듭니다. 여러분이 VS Code를 사용 중이라고 가정하고 튜토리얼을 진행할 것입니다. 하지만 원한다면 온라인에서 모두 코딩할 수 있는 ZIM 편집기에서도 작업할 수 있어요.\n\n## 템플릿\n\nVS Code에서 시작하려면 tile.html이라는 새 파일을 만들고 https://zimjs.com/code에서 ZIM 템플릿을 가져오세요. \"COPY\" 버튼을 눌러 페이지에 붙여넣기하세요. ZIM 편집기에서 작업 중이라면 이 과정이 필요하지 않아요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_3.png\" /\u003e\n\n\n\n저장 후 브라우저에서 페이지를 확인해보세요. 파일 시스템에서 페이지를 찾아 브라우저에 끌어다 놓거나 마우스 오른쪽 버튼을 클릭하여 Chrome 등으로 열 수 있습니다. 또한 VS Code에 Open In Browser 또는 Live Server 확장 프로그램을 설치하여 핫키로 또는 마우스 오른쪽 버튼으로 바로 VS Code에서 파일을 열 수 있습니다.\n\n![MakeHTML5GamesTileGameTutorial_4](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_4.png)\n\n브라우저에서 보면 창에 맞는 회색 상자 안에 끌어올릴 수 있는 보라색 원이 있을 것입니다. 이 원, 가운데 정렬 및 드래그 코드를 삭제하세요. 테스트해보면 회색 상자가 표시될 것입니다.\n\n![MakeHTML5GamesTileGameTutorial_5](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_5.png)\n\n\n\n## 템플릿 코드 대 ZIM 편집기\n\n# 게임 만들기\n\n이 게임에서는 타이머와 소리 아이콘에 대한 ZIM 게임 및 Pizzazz 모듈을 사용할 것입니다. 프레임 내의 크기와 색상을 조정하려면 아래와 같이 코드를 조정해봅시다:\n\n```js\nimport zim from \"https://zimjs.org/cdn/016/zim_game\";\nimport zim2 from \"https://zimjs.org/cdn/016/zim_pizzazz\";\n\n// FIT, FILL, FULL 및 TAG에 대한 Frame의 Docs 참조\nnew Frame(FIT, 720, 1280, black, darker, ready);\n```\n\n\n\n만약 ZIM 편집기를 사용 중이라면, 상단의 Phone에서 P를 눌러서 portrait 모드로 설정하고, Game과 Pizzazz 상자를 위로 올려놓으세요. 또한 F.color를 black으로 설정하세요.\n\n![image](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_6.png)\n\n## 타일 살펴보기\n\n간단한 ZIM Tile()을 살펴봅시다. 이는 항목의 그리드입니다.\n\n\n\n```js\n// Tile(obj, cols, rows, spacingH, spacingV, ... lots more)\nconst pods = new Tile(new Circle(50, [pink, blue, yellow]), 6, 10, 10, 10)\n  .center();\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_7.png)\n\nCircle에 전달된 색상 배열은 ZIM VEE 값이라고 불리며, ZIM VEE의 버전 5에서 동적 매개변수를 위해 고안된 것입니다. 이를 통해 Tile은 배열에서 무작위로 항목을 선택하여 생성할 수 있습니다. Pick 문서를 참조하세요. 다른 ZIM VEE 값은 시리즈입니다. Circle 코드를 아래와 같이 수정하세요:\n\n```js\nnew Circle(50, series(pink, blue, yellow))\n```\n\n\n\n\n![Tutorial Step 8](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_8.png)\n\n각 항목을 누를 때마다 빨간색으로 변경해 봅시다. ZIM이 구축된 CreateJS는 JavaScript의 addEventListener()와 비슷한 on() 메소드를 제공하는데, 짧고 간결하며 mousedown 이벤트를 캡처할 수 있습니다. 'e'는 이벤트 객체로서 우리에게 목표물인 이벤트를 일으킨 객체와 같은 추가 정보를 제공합니다. 변화가 갱신되도록 stage update()를 사용합니다. 자동으로 업데이트하지 않아 배터리 소모를 줄입니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n e.target.color = red;\n S.update();\n});\n```\n\n![Tutorial Step 9](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_9.png)\n\n\n\n만약 선택된 색상이 분홍색인 경우에만 색상을 빨간색으로 변경할 수도 있어요:\n\n```js\npods.on(\"mousedown\", e=\u003e{\n if (e.target.color == pink) {\n  e.target.color = red;\n  S.update();\n } \n});\n```\n일정 시간마다 발생하는 ZIM interval로 색상을 변경할 수도 있어요:\n\n```js\ninterval(.2, ()=\u003e{ // 초 단위로 지정하며 호출할 함수\n // pluck은 임의의 항목을 가져오고 true는 해당 항목을 제거합니다\n pluck(pods.items, true).color = purple;\n S.update();\n}, pods.items.length); // interval을 실행할 횟수\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_10.png\" /\u003e\n\n## 포드\n\n우리 타일은 플라즈마 포드들이에요! 백 개의 포드를 담고 있는 그림을 만들었어요.\n\n우리는 Frame()의 자산 및 경로 매개변수를 사용해서 자산을 로드합니다. 혹시 ZIM 에디터를 사용 중이라면, Frame의 loadAssets() 메서드를 사용하여 완료 이벤트를 추가하세요. VS 코드에서 작업 중이라면, Tile 코드를 삭제하거나 주석 처리하고 다음 코드를 추가하세요. 기억하세요, Frame과 ready의 끝 부분을 교체하고 있습니다.\n\n\n\n```js\n// FIT, FILL, FULL 및 TAG에 대한 프레임을 참조하세요\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.org/assets/\";\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path);\nfunction ready() {\n    \n // 주어진 F (Frame), S (Stage), W (너비), H (높이)\n // 여기에 코드를 넣으세요\n\n new Pic(\"plasmapods.jpg\").center().drag();\n\n} // 준비 끝\n```\n\n만약 ZIM 편집기를 사용 중이라면, 이 코드를 사용하세요:\n\n```js\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.com/assets/\";\nF.loadAssets(assets, path);\nF.on(\"complete\", () =\u003e {\n\n new Pic(\"plasmapods.jpg\").center().drag();\n // 이제부터 여기에 코드를 작성하세요\n\n S.update();\n}) // loadAssets 끝\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_11.png\" /\u003e\n\n\n\n\n## 스프라이트\n\n우리는 플라즈마 팟 사진을 스프라이트 시트로 사용하여 ZIM Sprite()를 만들 것입니다. 이것에 대한 다른 용어로는 텍스처 아틀라스가 있습니다. 새로운 Pic()을 100개의 팟을 50초 동안 표시하는 새로운 Sprite()로 교체합니다. 우리는 선택 링을 쉽게 찾을 수 있도록 등록 지점을 중앙에 맞추기도 합니다.\n\n```js\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).centerReg().run(50);\n```  \n\n## 타일\n\n\n\n모든 pod를 가로와 세로 갯수를 정하는 ZIM Tile()로 타일링해보세요. 이 함수는 obj, cols, rows, spacingH, spacingV를 받습니다. 여러분의 코드를 다음과 같이 변경해보세요:\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \nlet cols = 4;\nlet rows = 5;\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n// 모든 pod를 반복하며 처리합니다\npods.loop(pod=\u003e{  \n pod.frame = rand(99); \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_12.png\" /\u003e\n\n## 고유한 Pods\n\n\n\n일부 팟들이 반복되는 것을 주목해주세요. 그것은 우리가 원치 않습니다. 그래서 0부터 99까지의 100개 인덱스를 ZIM shuffle()을 사용해서 무작위로 섞고 싶습니다.\n\n```js\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100개\nshuffle(options);\n\n// 모든 팟들을 순회합니다\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_13.png\" /\u003e\n\n## Eternals\n\n\n\n특별한 오브를 \"영원한 것\"이라고 부를 거에요. 이건 배열 조작이 조금 복잡해질 거에요.\n\n첫 번째 레벨에서는 무작위 목록에서 두 개를 빼야 해요. JavaScript의 splice()를 사용해 첫 번째 두 개를 제거하고 저장할 거에요. 우리는 타일의 랜덤하게 선택된 두 곳의 프레임 넘버를 우리의 영원한 프레임 넘버로 변경할 거에요. 여기에 전체 코드가 있어요. 위에 있는 변경 사항을 주목해 주세요.\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \n\n// LEVELS\nlet level = 0;\n\n// TILE\nlet cols = 4;\nlet rows = 5;\nlet stable = level+2; // 변하지 않는 것의 수\n\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n\n// 프레임 설정\n\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100\nshuffle(options); // 섞음\n\nconst eternals = options.splice(0,stable); // 100개 중 두 개의 프레임\n\n// 영원한 프레임의 위치 찾기\n// 가능한 모든 타일 인덱스 생성\nconst allSpots = [];\nloop(cols*rows, i=\u003e{allSpots.push(i)});\n// 영원한 프레임을 위해 두 개의 랜덤 지점 가져오기\nconst spots = shuffle(allSpots).splice(0,stable);\n\n// 모든 파드 반복\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n let index = spots.indexOf(i); // i의 인덱스 찾기, 없으면 -1\n if (index \u003e= 0) pod.frame = eternals[index]; // 영원한 것으로 덮어씀 \n});\n\n// 영원한 것 테스트:\nSTYLE = {dashed:true}\nloop(spots, index=\u003e{\n // 팟의 너비는 크기 조정된 타일 안에 있음\n // 하지만 원형 링은 밖에 있으므로 크기에 맞게 조정\n new Circle(pod.width/2*pods.scale, clear, white, 10)\n  .loc(pods.items[index]);\n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_14.png\" /\u003e\n\n\n\n## 간격\n\n다른 팟들을 변경할 수 있게끔 ZIM interval()을 사용해봐요. 먼저 초 단위로 설정하고, 호출할 함수, 실행횟수, 그리고 바로 시작할지 여부를 넣어야 해요. 우리는 기존 팟들 사이를 반복하는 함수 주변에 간격 함수를 설정할 거예요. 그리고 이를 즉시 실행할 거예요. 각 번마다 옵션을 섞어주는 것도 잊지 않도록 하죠. 스테이지 업데이트도 필요해요.\n\n```js\nlet inter = interval(1, ()=\u003e{\n shuffle(options);\n // 모든 팟들을 반복\n pods.loop((pod,i)=\u003e{  \n  pod.frame = options[i]; \n  let index = spots.indexOf(i); // i의 spots 내 인덱스, 없으면 -1\n  if (index \u003e= 0) pod.frame = spots[index]; // 영구 프레임으로 덮어쓰기\n });\n S.update()\n}, null, true); // 바로 실행하려면 true로 설정\n```\n\n우리의 영구들은 변하지 않아요! 우리는 그들 주위에 링을 둘러보았어요... 게임을 플레이할 수 있도록 링들을 주석처리해볼까요 (선택 후 CTRL 또는 ⌘ / 를 눌러주세요)?\n\n\n\n```js\n// // test eternals:\n// STYLE = {dashed:true}\n// loop(spots, index=\u003e{\n//  // the width of the pod is inside a scaled Tile \n//  // but circle ring is outside, so adjust for scale\n//  new Circle(pod.width/2*pods.scale, clear, white, 10)\n//   .loc(pods.items[index]);\n// });\n```\n\n## 상호작용\n\n이제, pods를 눌러서 정답을 맞는지 확인하고 싶습니다. .cur()를 사용하여 타일의 커서를 활성화할 수 있습니다. 그래서 타일에 그것을 추가해 보겠습니다. 또한 타일에 mousedown 이벤트를 추가할 것입니다. 일단은... 우리가 누른 팟을 제거하는 것으로만 테스트해 보겠습니다. 다음과 같이 팟 코드를 조정하세요:\n\n```js\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n const pod = e.target;\n pod.removeFrom();\n S.update();\n});\n```\n\n\n\n## 틀린 방법과 올바른 방법\n\n타일(좇) 안의 각 아이템은 해당 인덱스와 일치하는 tileNum을 가지고 있습니다. 우리는 해당 tileNum이 eternals의 인덱스를 보유하는 spots 배열 안에 있는지 확인할 수 있습니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 스팟의 인덱스 중 하나를 눌렀는지 알아냅니다\n // 타일의 각 요소는 tileNum을 가지고 있습니다\n // spots 배열은 영구 요소의 타일 내 인덱스를 보유합니다\n // 따라서 우리가 누른 요소의 tileNum이 spots 안에 있는지 확인합니다\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0) {  // 올바른 방법\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역이며, 크기가 조정된 타일 내부가 아닙니다\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n } else { // 틀린 방법\n  e.target.sca(.5); // 일단은 무언가를 수행합니다...\n }\n S.update();\n});\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_16.png\" /\u003e\n\n## 레벨 완료\n\n우리가 추측을 끝냈는지 어떻게 알 수 있을까요? 만약 우리가 같은 것을 두 번 이상 추측하면 어떻게 해야 할까요? 이 문제를 해결하기 위해 우리는 올바른 추측을 추적하기 위해 배열을 사용하고, 이미 배열에 있는 경우 올바른 추측으로 계산하지 않습니다. 배열의 길이가 레벨에 대한 stable 변수와 같아지면 레벨을 완료한 것입니다.\n\n```js\nconst correct = [];\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 위치의 색인을 눌렀는지 확인합니다.\n // 타일의 각 요소는 타일번호를 가지고 있습니다.\n // spots 배열은 영구적인 위치의 타일 인덱스를 보유합니다.\n // 따라서 누른 것의 타일번호가 spots에 있는지 확인해 봅니다.\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정확하고 이미 찾은 것이 아닌 경우\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역 변수이며, 스케일 조정된 타일 내에 있지 않습니다.\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n  correct.push(ind);\n  if (correct.length == stable) nextLevel();\n } else { // 틀린 경우\n  e.target.sca(.5); // 지금은 그냥 무언가를 해 봅니다...\n }\n S.update();\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 위해 F12를 사용하세요 (또는 노트북의 기능 키 F12)\n}\n```\n\n\n\n# 레벨\n\n코드의 레벨 부분을 찾아 아래와 같이 조정하세요. 패턴을 따르지 않는 레벨 열과 행을 보유한 배열을 만들 것입니다. 또한 다가오는 makeLevel() 함수 외부에서 필요한 몇 가지 변수를 준비합니다. 기존 코드에서 inter의 let을 제거해야 합니다.\n\n```js\n// 레벨\nlet level = 0;\n\n// 각 레벨의 열과 행을 나타내는 배열을 만듭니다.\n// 이를 사용해서 더 짧은 테스트를 실행하세요\n// const levels = [[4,5],[5,7]];\nconst levels = [[4,5],[5,7],[6,8],[7,10],[8,11]];\n\nlet lastPods;\nlet inter;\n\n// 정확한 추측 링을 보유합니다.\nconst rings = new Container(W,H).addTo();\n```\n\n```js\n// 기존 간격 코드에서 let을 제거하세요:\ninter = interval(1, ()=\u003e{\n```\n\n\n\n위의 코드를 makeLevel() 함수로 감싸세요. TILE 섹션 위에서부터 시작하는 코드를 makeLevel() 함수로 감싸세요. 또한 cols와 rows를 levels 배열을 사용하도록 조정하세요. makeLevel() 함수의 맨 위 코드는 다음과 같습니다.\n\n```js\nfunction makeLevel() {\n            \n // TILE\n const cols = levels[level][0];\n const rows = levels[level][1];\n const stable = level+2; // 원하는 만큼 고정될 타일 수\n```\n\n가장 아래 부분까지 이동해서 VS Code에서 end ready if 내에 남은 makeLevel() 함수의 끝 부분을 추가하세요. 그리고 함수를 호출하세요.\n```js\n} // makeLevel 함수의 끝\n\nmakeLevel();\n```\n\n\n\n## 단계 진행하기\n\n새 단계를 위한 새로운 타일을 만들기 전에 이전 타일과 링을 제거해야 합니다. 이미 rings Container를 만들었습니다. 이것을 사용하여 링을 보관할 것입니다. 그러므로 링 코드를 조정하세요. 우리는 링을 loc()에 추가했다는 것을 주목하세요. 나중에 rings의 모든 하위 항목을 제거할 수 있게 될 것입니다.\n\n```js\nnew Circle(pod.width/2*pods.scale, clear, white, 18)\n .loc(e.target, null, rings);\n```\n\n\n\n이제 nextLevel() 함수 위에 이 코드를 추가하세요. 이것은 NEXT 레벨이며 makeLevel이 아닌 것입니다. 여기서는 pods을 alpha 0에서 animate하여 불투명도를 조절합니다. 이렇게 하면 레벨 간에 서서히 사라집니다. 현재 pods을 lastPods에 저장하여 다음 레벨로 이동할 때 기억합니다. 반지를 퇴장시키고 완료되면 제거합니다.\n\n```js\n// LEVEL 처리\n\npods.alp(0).animate({\n wait:lastPods?1:0,\n props:{alpha:1},\n time:.5\n});\nlastPods = pods;\n\n// 반지를 숨기고 지우고 표시합니다.\nrings.top().animate({\n rewind:true,\n time:.5,\n props:{alpha:0},\n rewindCall:()=\u003e{\n  rings.removeAllChildren();\n }\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 열려면 F12 키(혹은 노트북의 Function F12 키)를 사용하세요\n}\n```\n\nnextLevel() 함수 안에 이 코드를 추가하세요. 마지막 pods를 animate하여 사라지게 하고, 마지막 간격을 지우고, 레벨을 늘리고, 게임의 끝인지 확인한 후 makeLevel()을 호출하세요.\n\n```js\nfunction nextLevel() {\n\n // 마지막 pods를 animate하여 사라지게 함\n // 캐싱은 모바일에서의 부드러운 애니메이션에 도움이 됨\n lastPods.cache().animate({\n  props:{alpha:0},\n  time:.5,\n  call:target=\u003e{target.dispose();}\n });   \n\n inter.clear(); // 현재 간격을 지움\n\n level++;\n if (level \u003c levels.length) { // 더 많은 레벨\n  makeLevel();\n } else { // 게임 종료\n\n  zogr(\"게임 끝\");   \n  \n } // 게임 종료\n\n} // nextLevel의 끝\n```  \n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_17.png\" /\u003e\n\n## 발신자\n\n선택 사항을 ZIM Emitter()로 향상시킬 수 있습니다. 이는 입자를 방출합니다. 발신자를 링 컨테이너 아래에 만들어보세요:\n\n```js\n// 정확한 추측 링을 보관합니다\nconst rings = new Container(W, H).addTo();\n\nSTYLE = {dashed: true};\nconst emitter = new Emitter({\n obj: new Circle(90, clear, series(pink, purple), 18),\n interval: .3,\n gravity: 0,\n force: 0,\n animation: {props: {scale: 5},\n startPaused: true\n});\nSTYLE = {}\n```\n\n\n\nemitter에서 pod의 mousedown 이벤트가 발생했을 때 spurt() 함수를 호출하세요. 기존의 nextLevel() 함수 호출 아래에 추가하세요.\n\n```js\ncorrect.push(ind);\nif (correct.length === stable) nextLevel();\n\nemitter.loc(e.target).spurt(2);\nemitter.particles.top(); // 입자들이 emitter와 별개로 존재하기 때문에 tricky 함\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_18.png)\n\n흰색 링은 emitter 작업이 대부분 완료될 때까지 표시되지 않아야 하므로 기존 링 Circle에 페이드 인 애니메이션을 추가하세요. 세미콜론(;)을 확인해주세요.\n\n\n\n```js\n새 Circle(pod.width / 2 * pods.scale, clear, white, 18)\n .loc(e.target, null, rings)\n .alp(0)\n .animate({\n  wait: .5,\n  alpha: .9\n });\n```\n\n## 보상 화면\n\n우리는 한 수준에서 다른 수준으로 애니메이션화되는 것에 만족하지 않습니다. 어떤 보상이 필요합니다. 소리는 도움이 될 것입니다... 하지만 이쁜 구체들이 있습니다. 플레이어에게 수집한 영구 구체들을 보여주는 약간 더 많은 시간을 쓰도록 합시다. 기존의 lastPods animate 코드 하단에 기다림을 조절하고 한 번 보여주세요!\n\n```js\nlastPods.cache().animate({\n wait:1, // 기다리기 추가\n props: {alpha: 0},\n time: .5,\n call: target =\u003e {target.dispose();}\n});\n\n// 영구 보여주기 – 플레이어에게 잠시 휴식 시간을 줌과 더 큰 플라즈마를 보여줍니다\nconst showcase = new Tile({\n obj: pod.clone().sca(1.5),\n cols: 2,\n rows: 3,\n spacingH: 20,\n spacingV: 20,\n count: stable\n})\n .center();\nshowcase.loop((pod, i) =\u003e {\n // eternals는 영구 구체들의 인덱스를 저장합니다\n pod.run({startFrame: eternals[i], endFrame: eternals[i]});\n});\nshowcase\n .alp(0)\n .animate({\n  props: {alpha: 1},\n  wait: 1.5,\n  time: .5,\n  rewindWait: 1,\n  rewind: true,\n  call: target =\u003e {target.dispose();}\n });\n\ninter.clear(); // 현재 간격을 지웁니다\n```\n\n\n\n이제 우리는 팟 애니메이트 대기 시간을 조정해야 합니다:\n\n```js\npods.alp(0).animate({\n wait:lastPods?3.5:0, // 3.5로 변경\n props:{alpha:1},\n time:.5\n});\n```\n\n# 마무리\n\n이제 기본 게임 구성은 완료되었습니다. 실제 게임을 먼저 코딩하고 이를 수행할 수 있고 마음에 드는지 확인해야 합니다. 그런 다음 소리, 점수, 패널, 인터페이스 등과 같은 최종 터치를 추가하십시오. 종종 이미지는 마지막에 남겨두지만 스프라이트와 함께 작업하는 것도 좋았습니다.\n\n\n\n## 더 많은 에셋\n\n로고를 위한 폰트와 몇 가지 사운드를 로드할 예정입니다. Frame() 영역에 이를 추가하세요. 기존 Frame() 함수에는 추가된 progress 매개변수가 있음을 주의하세요.\n\n```js\nconst audioSpriteData = {\n  src: \"audiosprite.mp3\",\n  audioSprite: [\n    // [id, 시작시간(초), 끝시간(초)] \n    // 프리미어에서 확인 - 다른 형식들도 존재함\n    ['blackball', 1.041, 2.475],\n    ['bounce', 3.567, 4.232],\n    ['end', 5.396, 9.315],\n    ['help', 10.373, 10.499],\n    ['powerdown', 11.607, 14.254],\n    ['powerup', 15.672, 17.081],\n    ['slow', 18.354, 19.163],\n    ['start', 20.151, 23.594],\n    ['submit', 24.931, 27.673],\n    ['wallend', 28.632, 29.351],\n    ['wallstart', 30.640, 32.323]\n  ]\n};\n\nconst assets = [\"gf_Honk\", \"plasmapods.jpg\", \"intro.mp3\", audioSpriteData];\nconst path = \"https://zimjs.com/assets/\";\nconst progress = new Waiter();\n\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path, progress);\nfunction ready() {\n```\n\n만약 ZIM Editor를 사용 중이라면, 아래와 같이 사용하세요:\n\n\n\n```js\nF.loadAssets(assets, path, progress);\n```\n\n## 로고\n\n로고를 맨 위에 추가하세요. 로고에 사용자 지정 글꼴이 얼마나 더 좋은지 확인해보세요! Google Fonts로 가는 바로 가기를 사용하면 assets에 있는 gf_… 를 사용하는 것이 정말 쉬워집니다. ready 함수 내부의 맨 위에 다음을 추가하세요:\n\n```js\nnew Label(\"ETERNAL ORBS\", 110, \"Honk\").pos(0, 50, CENTER);\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_19.png\" /\u003e\n\n## 컨트롤\n\n우리는 밑부분에 인터페이스를 추가할 것입니다. 이 인터페이스에는 음소거 버튼, 찾아야 할 무한루프 수를 보여주는 라벨, 그리고 타이머가 있을 것입니다. 이를 위해 타일을 사용하여 이쁘게 정렬할 것입니다. 이 코드를 로고 아래에 추가해주세요.\n\n```js\n// 밑에 있는 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n})\n\nconst find = new Label(\"찾기 2\", 85, \"Honk\");\n\nconst timer = new Timer({\n backgroundColor: new GradientColor([yellow, red], 90),\n down: false,\n time: 0\n});\n\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM);\n```\n\n\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_20.png)\n\n각 레벨을 찾기 위한 'eternals'의 수를 업데이트해야 합니다. HANDLE LEVELS 섹션에 다음 라인을 추가해주세요:\n\n```js\n// HANDLE LEVELS\n\nfind.text = \"FIND \" + stable;\n```\n\n## Sound\n\n\n\n위에, 로고 아래에 우리의 모든 소리를 준비해봅시다. 우리는 새로운 Aud()를 사용해서 소리 객체를 만들어요. 그리고 우리가 그 소리를 듣고 싶을 때에는 play() 메소드를 사용해요. 상호작용을 할 때 까지 소리를 재생할 수 없지만, 그 부분은 맨 처음에 LeaderBoard를 추가하여 처리할 거에요.\n\n```js\n// SOUND\n// 파일, 볼륨, 루프, 등 여러 가지가 있어요\nconst introSound = new Aud(\"intro.mp3\", .1, true); \nconst startSound = new Aud(\"wallstart\", .3);\nconst rightSound = new Aud(\"powerup\", .3);\nconst wrongSound = new Aud(\"wallend\", .3);\nconst endSound = new Aud(\"submit\", .3);\nlet intro; // 이 변수는 mute fading을 위해 introSound SoundInstance를 보관할 거에요\n```\n\n코드 전체에 소리를 뿌리뿌리 흩뿌려봅시다. LeaderBoard를 소개할 때 intro 소리를 들려줄 거에요. play() 코드가 들어간 줄을 추가하고 있어요.\n\n```js\npods.alp(0).animate({\n wait: lastPods ? 3.5 : 0,\n waitedCall: () =\u003e {if (!mute.toggled) startSound.play();},\n props: {alpha: 1},     \n time: .5\n});\n```\n\n\n\n그리고 파드의 마우스 다운시에 play() 코드를 추가하고 있습니다.\n\n```js\nif (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정답이고 이미 찾은 것이 아니라면\n if (!mute.toggled) rightSound.play();\n```\n\n틀린 추측에서는 play() 코드를 추가하고 있습니다.\n\n```js\n} else { // 틀렸을 때\n if (!mute.toggled) wrongSound.play();\n e.target.sca(.5); // 일단은 무언가를 해보세요...      \n}\n```\n\n\n\n## 리더 보드\n\n기존 BOTTOM INTERFACE 코드 아래에 다음 코드를 추가하세요. bottom을 removeFrom()하여 Play 버튼을 누를 때까지 표시되지 않도록 하고 bottom을 addTo() 하세요. 코드 맨 아래에는 이미 가지고 있는 SPRITE 코드가 있으므로 중복해서 작성하지 말아주세요. 그리고 startGame() 함수의 괄호를 닫아주세요. 그 다음 작업을 해보겠습니다.\n\n```js\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM)\n .removeFrom();\n\n// 리더 보드\nconst lb = new LeaderBoard({\n data: \"Y9HC384\",\n corner: 0,\n backgroundColor: dark,\n titleColor: light,\n title: \"Lowest Finish Times\",\n reverse: true\n}).scaleTo(S, 90, 90).center().mov(0, 20);\nlb.on(\"close\", startGame);\n\nconst play = new Button({\n label: \"PLAY\",\n backgroundColor: new GradientColor([orange, purple], 90)\n})\n .pos(0, 40, CENTER, BOTTOM).tap(() =\u003e {\n  lb.removeFrom();\n  startGame();\n });\n\n\n// 시작 게임\n\nfunction startGame() {\n\n bottom.addTo();\n timer.time = 0;\n\n // 나중에 음소거하려면 play SoundInstance를 저장하세요\n if (!mute.toggled \u0026\u0026 !intro) intro = introSound.play(); \n if (!mute.toggled) startSound.play();\n\n play.removeFrom();\n\n // SPRITE\n const pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER);\n}\n\nstartGame 함수를 호출한 후 makeLevel()을 호출하여 startGame() 함수를 종료하세요. 문서를 올바르게 들여쓰기하여 형식을 유지해주세요. VS Code에서 오른쪽 클릭하여 \"Format Document\"를 실행해주세요.\n\n\n\n } // makeLevel 함수 끝\n\n makeLevel();\n\n} // startGame 함수 끝\n\n![MakeHTML5GamesTileGameTutorial 이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_21.png)\n\n## 음소거 버튼\n\n음소거 기능을 추가하세요. 기존 버튼에 expand()와 tap()을 추가하세요. expand는 모바일에서 쉽게 누를 수 있게 만듭니다.\n\n\n\n// 하단 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n}).expand().tap(() =\u003e {\n if (mute.toggled \u0026\u0026 intro) intro.fade(0);\n else if (!mute.toggled \u0026\u0026 intro) intro.fade(.1);\n});\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_22.png\" /\u003e\n\n## 게임 종료\n\n여기까지 오지 못할 것 같았나요? 오답을 수정해봅시다. 틀린 답을 맞출 때마다 타이머를 늘릴 겁니다.\n```\n\n\n\n```js\n} else { // 잘못됨\n if (!mute.toggled) wrongSound.play();\n timer.time += 10;   \n}\n```\n\n게임의 조건이 끝날 때, 시간을 리더보드에 추가하고 모든 것을 멈추기 위해 끝 코드를 추가합니다.\n\n```js\n} else { // 게임 종료\n\n // 게임 끝났습니다\n\n inter.clear();\n rings.animate({\n  time: .2,\n  props: {alpha: 0}\n });\n // 점수를 리더보드로 전송\n // 상위 열 개 안에 들지 않으면 무시됩니다\n lb.score(timer.time);\n // 최종 쇼케이스를 보기 위해 시간을 제공합니다\n timeout(3.5, () =\u003e {\n  bottom.removeFrom();\n  pods.dispose();\n  rings.dispose();\n  lb.addTo();\n  play.addTo();\n  if (!mute.toggled) endSound.play();\n });\n\n} // 게임 종료의 끝\n```\n\n이를 쉽게 테스트하기 위해 레벨을 줄일 수 있습니다. LEVELS 코드에서 찾아서 게임을 두 레벨(또는 한 레벨) 후에 종료되도록 변경하세요. 도전적인 레벨을 다시 시도하려면 다시 변경해야 합니다!\n\n\n\n```js\n// 이것은 각 레벨마다 열과 행이 얼마나 있는지 나타냅니다\n// 간단한 테스트 실행에 사용하세요\nconst levels = [[4,5],[5,7]];\n// const levels = [[4, 5], [5, 7], [6, 8], [7, 10], [8, 11]];\n```\n\n# 결론\n\n이 튜토리얼에서는 로고와 커스텀 폰트, 리더보드, 오디오 스프라이트와 음소거 버튼을 포함한 완전한 타일/패턴 게임을 만들기 위해 시간을 들였습니다. 또한, 레벨, 리워드 이밋터 및 스프라이트 텍스처 애트라스를 포함하였습니다.\n\n우리는 ZIM을 사용하여 여러 가지 타일형 게임을 만들었습니다. 게임 및 ZIM 예제에 대해 ZIM 배너 페이지를 살펴보세요.\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_23.png)\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_24.png)\n\nZIM의 Learn Apps 섹션에는 많은 종류의 타일 게임을 사용하는 e러닝 게임이 있습니다. 메모리 게임과 스크램블 퍼즐과 같은 게임들이 있습니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_25.png)\n\n\n\n**HTML 5 Games 튜토리얼 및 자료**\n\n- HTML 5 게임 만들기 - 이소메트릭 보드 게임 튜토리얼\n- HTML 5 게임 만들기 - 사이드 스크롤러 게임 튜토리얼\n\n더 많은 ZIM 기능과 ZIM 예제가 있습니다. ZIM 포럼이나 디스코드에 참여하시면 즐거운 도움을 받을 수 있습니다!\n\nDr Abstract\n\n\n\n![MakeHTML5GamesTileGameTutorial](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_26.png)","ogImage":{"url":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"},"coverImage":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png","tag":["Tech"],"readingTime":22},{"title":"현대 웹을 위해 새롭게 탄생한 자동완성 상자","description":"","date":"2024-05-12 23:31","slug":"2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb","content":"\n\n## 모든 곳에서 작동하며 의존성이 전혀 없는 다재다능한 접근 가능한 자동완성 웹 구성 요소.\n\n![이미지](/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png)\n\n생각해 보면, 텍스트 상자에서의 자동완성은 일종의 상용품이 되어가고 있고, 수많은 UI 프레임워크가 자체적인 구현을 제공하고 있습니다.\n\n큰 프레임워크를 사용하지 않거나 자동완성 UI 구성 요소를 포함한 기존 디자인 시스템을 사용하지 않고 현대적인 웹 앱을 구축할 때, 우리는 혼자서 해결해야 합니다.\n\n\n\n지금까지.\n제가 AutoComplete ECMAScript 클래스를 작성했고 해당 클래스를 구현하는 `omni-box`라는 표준 기반 웹 컴포넌트를 만들었습니다.\n\n# OmniBox\n\nAutoComplete 클래스는 모든 기본 로직을 호스팅하며, 텍스트 기반 HTML 입력 요소에 자동 완성 로직을 연결하는 데 사용할 수 있습니다.\n\n\n\nOmniBox 웹 컴포넌트는 검색 입력을 생성하고 AutoComplete 컴포넌트를 연결합니다.\n\n## 왜 OmniBox를 사용해야 하는가?\n\n이는 의존성이 전혀 없는 매우 다재다능한 자동완성 컴포넌트로, 모든 브라우저에서 실행되며 웹 컴포넌트로 구현되었습니다. OmniBox라는 이름은 이 컴포넌트로 간단한 자동완성 시나리오를 용이하게 할 수 있을 뿐만 아니라 LinkedIn, Facebook 또는 Office.com에서 보는 것처럼 복잡한 다중 소스 시스템도 구현할 수 있다는 사실을 나타냅니다.\n\n자동완성 결과는 고정(Array) 데이터에서 가져올 수 있지만, REST API와 같은 여러 소스와 연동해야 하는 더 복잡한 상황에서도 작업할 수 있습니다. 여러 호출 결과를 집계해야 하는 상황도 다룰 수 있습니다.\n\n\n\n또한 자동 완성 결과 항목을 선택할 때 단순히 입력란을 채우는 대신 사용자 정의 작업을 호출하도록 구성할 수도 있습니다.\n\n# 기능\n\n- 표준 기반의 웹 컴포넌트.\n- 의존성 없음.\n- 타입하는 대로 자동 완성 결과가 집계되는 구성 가능한 자동 완성 카테고리.\n- 각 카테고리에는 Array, Function 또는 Promise를 반환할 수 있는 'getItems' 속성이 있습니다.\n- 각 카테고리에는 정렬 색인이 있습니다.\n- 각 카테고리에는 'getItems'가 호출되는 시점을 결정하는 트리거 함수가 있습니다.\n- 각 카테고리에는 항목 선택을 위해 정의된 사용자 정의 작업을 가질 수 있습니다.\n\n# CodePen\n\n\n\n아래 Markdown 형식을 사용하여 CodePen에서 컴포넌트를 살펴보세요:\n\n# 더 많은 표준 기반의 유용한 것들\n\n다음의 탭 스트립도 확인해보세요. Marc van Neerven 저, CTO-as-a-Service 블로그의 The TabStrip, reinvented for the Modern Web 기사에서도 볼 수 있습니다.\n\n## PurePWA\n\n\n\n저는 PurePWA를 소개하는 \"웹 개발의 급격한 전환\"의 저자입니다. 이 책에서는 시맨틱 HTML과 ECMAScript를 사용하여 현대적인 PWA를 구축할 때 프레임워크, 빌드 시스템 또는 기타 종속성 없이 어떤 가능성이 있는지 탐구하고 있어요.\n\n🔗 LinkedIn에서 제 소식을 받아보세요","ogImage":{"url":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"},"coverImage":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular 18의 새로운 기능 정리 비교","description":"","date":"2024-05-12 23:30","slug":"2024-05-12-Angular18NewFeatures","content":"\n\u003cimg src=\"/assets/img/2024-05-12-Angular18NewFeatures_0.png\" /\u003e\n\n웹 어플리케이션을 구축하기 위한 주요 프레임워크 중 하나인 Angular은 현대 웹 개발 요구 사항을 충족하기 위해 지속적으로 발전해 왔습니다. 각 버전마다 새로운 기능, 최적화, 개선 사항을 가져왔습니다. 커뮤니티는 Angular 18의 릴리즈를 열심히 기다리며, 다음 주요 버전에서 기대할 수 있는 것을 살펴보겠습니다.\n\nAngular 18은 2024년 5월에 발매 예정이며, 이미 다가오는 버전에 포함될 확정된 여러 기능이 있어서 이번 버전에서 논의할 수 있습니다.\n\n# 함수를 이용한 경로 리디렉션\n\nAngular 18에서는 리디렉트를 관리하는 새로운 기능이 도입되었습니다. 이제 라우트 객체의 redirectTo 속성 내에서 리디렉트 URL을 지정하기 위해 문자열 대신 함수를 사용할 수 있습니다. 이 향상된 기능은 라우팅에서 더 많은 유연성을 제공하며 새로운 가능성을 열어줍니다.\n\n해당 함수 내에서는 URL 정보를 포함하는 객체에 액세스가 허용됩니다.\n\n```js\n//\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: \"/page2\",\n    pathMatch: \"full\",\n  },\n];\n\n//redirectTo function\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: (url) =\u003e {\n      return \"/page2\";\n    },\n    pathMatch: \"full\",\n  },\n];\n```\n\n함수는 문자열 또는 UrlTree를 반환해야 합니다. Angular에서 UrlTree는 URL을 나타내는 데이터 구조입니다. 이는 Angular 라우터가 응용 프로그램 내에서 탐색하는 데 사용하는 URL의 구문 분석된 표현입니다. UrlTree에는 URL 세그먼트, 쿼리 매개변수 및 조각과 같은 정보가 캡슐화되어 있습니다. 이는 Angular의 라우팅 시스템에서 URL 조작, 탐색 및 라우팅 가드와 같은 작업에 일반적으로 사용됩니다. UrlTree를 사용함으로써 Angular은 응용 프로그램 내에서 일관된 신뢰할 수 있는 탐색 동작을 보장합니다.\n\n“url\" 객체에는 라우트에 관한 모든 정보가 포함되어 있습니다. 이 정보에는 데이터, 제목, 쿼리 매개변수, 라우팅 세그먼트 등이 포함됩니다.\n\n# 새로운 RedirectCommand\n\nAngular 버전 18에서는 NavigationExtras를 처리하기 위해 설계된 새 RedirectCommand 클래스가 소개되었습니다. 이 추가로 Guards 및 Resolvers 내에서 향상된 리디렉션 기능을 구현할 수 있습니다. RedirectCommand 클래스의 통합은 유지보수성과 유연성을 크게 향상시키며, Angular 애플리케이션에서 복잡한 네비게이션 패턴을 보다 쉽게 관리할 수 있습니다.\n\n```js\nconst route: Route = {\n  path: \"page1\",\n  component: PageComponent,\n  canActivate: [\n    () =\u003e {\n      const router: Router = inject(Router);\n      const urlTree: UrlTree = router.parseUrl(\"./page2\");\n      return new RedirectCommand(urlTree, { skipLocationChange: true });\n    },\n  ],\n};\n```\n\n# ng-content 기본 콘텐츠\n\n이제는 ng-content 태그에 기본 콘텐츠를 넣을 수 있습니다. 이 기능은 ng-content 요소의 논리적 확장입니다. 콘텐츠를 위한 태그가 있는 경우, 기본 콘텐츠도 해당 태그 자체에 포함되어야 합니다.\n\n예를 들어, 템플릿에서 ng-content가 포함된 컴포넌트가 있다면 제공된 콘텐츠가 없을 경우 렌더링될 기본 콘텐츠도 포함할 수 있습니다.\n\n```js\n\u003cdiv\u003e\n  \u003ch1\u003e헤더\u003c/h1\u003e\n  \u003cng-content\u003e기본\u003c/ng-content\u003e\n\u003c/div\u003e\n```\n\n# Zoneless applications\n\nSignals의 주요 목표 중 하나는 zone.js 없이 응용 프로그램이 작동할 수 있도록 하는 것입니다. 초기에는 이 것이 Signal Components를 통해서만 가능했을 것입니다. 그러나 그 이후에 상황이 변화했습니다. 이제 Angular 18부터는 Signal Components를 사용하지 않고도 이것을 달성할 수 있을 것입니다. Angular 18은 다음 달에 발표될 예정입니다.\n\nMatthieu Riegler와 Enea Jahollari는 이 주제에 집중한 각각의 기사를 게시했습니다.\n\nMatthieu의 기사는 새로운 하이브리드 변경 감지 시스템을 탐구하며, 어느 Signal 변경, 비동기 파이프 또는 markForCheck를 호출하는 다른 작업이 zone.js 외부에서 발생하더라도(예외적인 상황) 이제 자동으로 변경 감지가 트리거될 것이라고 합니다.\n\nEnea의 글은 zone.js를 완전히 비활성화하고 응용 프로그램 상태 변경을 관리하는 데 이러한 새로운 트리거 메커니즘에만 의존하는 과정을 논의합니다.\n\n# 읽어 주셔서 감사합니다!\n\n여러분의 생각을 듣고 싶어요. 그러니 자유롭게 댓글을 남겨주시거나 박수를 보내거나 팔로우해 주세요. 👏\n\n이 글이 마음에 들었다면, 여러분의 커뮤니티, 기술 친구 및 흥미를 가질 것으로 생각되는 다른 사람들과 공유하는 것도 생각해보세요. LinkedIn에서도 제 소식을 더 받아보기 위해 팔로우를 잊지 말아주세요!\n","ogImage":{"url":"/assets/img/2024-05-12-Angular18NewFeatures_0.png"},"coverImage":"/assets/img/2024-05-12-Angular18NewFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"크롬 성능 패널 101 자바스크립트 메인 스레드에서 무슨 일이 벌어지고 있을까","description":"","date":"2024-05-12 23:28","slug":"2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png\" /\u003e\n\n# 목차\n\nChrome의 성능 패널에 익숙해지기\n\n- 프로파일러의 사용자 인터페이스 이해\n- 사전 설정 단계\n\n\n\n프로파일링을 시작해봐요!\n\n- CPU 활용률\n- 네트워크 요청 타임라인\n- 프레임 및 이벤트 타이밍\n- JavaScript 주 스레드\n\n팁: 프로파일러를 효과적으로 사용하는 방법\n\n- 예시 1: LCP 성능 저하 조사하기\n- 예시 2: 클릭 동작 시 어플리케이션이 멈추는 현상 조사하기\n\n\n\n프론트엔드 개발자로서, 크롬의 성능 패널에 있는 자바스크립트 프로파일러를 들어본 적이 있거나 마주쳐 본 적이 있을지도 모릅니다. 초안에서는 차트와 그래프가 압도적으로 보일 수 있습니다.\n\n![Chrome Performance Panel](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_1.png)\n\n처음에는 다소 복잡해 보일 수 있지만, 자바스크립트 프로파일러는 디버깅에 매우 유용합니다. 이 도구를 사용하면 애플리케이션을 실행할 때 자바스크립트 메인 스레드에서 발생하는 모든 일들을 살펴볼 수 있습니다. 이 글에서는 크롬의 성능 패널을 사용한 프로파일링에 관한 제 경험을 공유하겠습니다.\n\n# 크롬의 성능 패널에 친숙해지기\n\n\n\n## 프로파일러의 사용자 인터페이스 이해하기\n\n프로파일러의 모든 설정을 다루지는 않겠습니다. 오직 몇 가지 중요한 기능만이 필수이며 앱 프로파일링을 위해 구성될 것입니다.\n\n![프로파일러](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_2.png)\n\n- 녹화 및 프로파일링 시작 및 페이지 다시로드하는 작업 버튼과 Clear 버튼이 있습니다.\n- 프로파일링 레코드의 이력.\n- 스크린샷 및 JavaScript 힙 메모리 사용량을 프로파일링과 함께 보여주는 옵션.\n- CPU 및 네트워크 쓰로틀링.\n\n\n\n기능에 대한 포괄적인 문서를 원하시면 Chrome DevTools 성능 문서를 참고해보세요.\n\n## 사전 구성 단계\n\n정확한 결과를 보장하고 디버깅 프로세스를 쉽게 해 하기 위해 다음 설정을 고려해보세요:\n\n- 시크릿 모드: 시크릿 모드에서 Chrome을 실행하면 브라우저에 영향을 미치지 않도록 확장 프로그램을 비활성화하고 캐시를 지움으로써 성능 측정에 영향을 주지 않도록합니다.\n- Localhost 대 Production: 저는 TypeScript, React 또는 Webpack과 같은 번들러를 사용하는 프로젝트에서 트랜스 파일 된 또는 최소화된 코드에 문제가 발생하는 것을 피하기 위해 localhost에서 프로필링을 선호합니다. 소스 코드 추적을 쉽게 하기 위해 Chrome DevTools에 소스 맵을 업로드하여 제품 프로필링을 위해 정확한 소스 코드를 파일에 매핑하세요.\n- CPU 쓸개 (4배 느리게): 주요 사용자 그룹이 모바일 기기를 사용하는 경우 CPU 쓸개를 활성화하는 것을 고려해보세요. 주의할 점은 쓸개 속도가 귀하의 기기의 CPU 성능을 기준으로 하며 결과가 다른 기기에서 달라질 수 있다는 점입니다.\n- 네트워크 쓸개 (느린 3G): 네트워크를 Fast 3G 또는 Slow 3G로 설정하는 것을 추천합니다. 이 접근 방식은 네트워크 병목 현상을 더 명확하게 드러낼 수 있습니다.\n\n\n\n# 프로파일링을 시작해봐요\n\n만약 우리가 index.html 파일에 다음과 같은 코드 조각이 있다고 가정해봅시다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003cbody\u003e\n    \u003ch1\u003eAPI에서 데이터 가져오기:\u003c/h1\u003e\n    \u003cdiv id=\"api-data\"\u003e로딩 중...\u003c/div\u003e\n    \u003cscript\u003e\n      const getData = async () =\u003e {\n        const apiUrl = \"https://jsonplaceholder.typicode.com/todos/1\";\n        try {\n          const response = await fetch(apiUrl);\n          if (!response.ok) {\n            throw new Error(\"네트워크 응답이 올바르지 않습니다.\");\n          }\n          const data = await response.json();\n          document.getElementById(\"api-data\").innerHTML = `\n                    \u003cp\u003e제목: ${data.title}\u003c/p\u003e\n                `;\n        } catch (error) {\n          document.getElementById(\"api-data\").innerText =\n            \"데이터를 불러오는 데 실패했습니다.\";\n        }\n      };\n      document.addEventListener(\"DOMContentLoaded\", getData);\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n이 코드는 로딩한텍스트를 출력한 후 더미 데이터를 가져 오기 위해 HTTP 요청을 보내고 그것으로 로딩 텍스트를 바꾸는 역할을 합니다. 이렇게 간단해요.\n\n\n\n인크ognito Chrome 창에서 index.html을 열고 \"프로파일링 시작 및 페이지 다시로드\" 버튼을 클릭해 보세요.\n\n다음은 결과입니다.\n\n## CPU 활용률\n\n![Image](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_3.png)\n\n\n\n상단 섹션(빨간 상자)은 CPU 활용을 나타내며, 다양한 브라우저 활동을 나타내는 다양한 색상이 있습니다. 예를 들어 스크립팅, 렌더링, 페인팅 또는 아이들 활동이 있습니다. 이러한 것들은 보통 JavaScript 주 스레드 활동에 상응합니다.\n\n이 특정 시간대에 CPU는 대부분 유휴 상태입니다. HTML 구문 분석, DOMContentLoaded의 이벤트 핸들러 실행 및 레이아웃 단계에 사용되는 것들이 필요합니다. 레이아웃 단계는 브라우저 렌더링 단계 중 하나이며, 모든 노드의 차원과 위치를 계산하고 페이지의 각 객체의 크기와 위치를 결정합니다. 브라우저 렌더링 프로세스에 대해 더 자세히 알아보려면 여기를 읽어보세요: 브라우저 작동 방식 - 렌더링.\n\n## 네트워크 요청 타임라인\n\n![Network Request Timeline](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_4.png)\n\n\n\n네트워크 요청 타임라인에서는 API 엔드포인트인 https://jsonplaceholder.typicode.com/todos/1이 호출되고 응답이 약 2초 후에 반환되는 것을 볼 수 있습니다.\n\n## 프레임 및 이벤트 타이밍\n\n![Frames and Event Timings](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_5.png)\n\n프레임 타임라인은 API 응답이 반환될 때 텍스트 로드부터 결과를 렌더링하는 과정을 알려줍니다. 이벤트 타이밍 타임라인에서는 DCL (DOM 내용 로드됨), FCP (첫 번째 콘텐츠 페인트), L (로드됨), LCP (가장 큰 콘텐츠 페인트)와 같은 다양한 이벤트를 보여줍니다.\n\n\n\n## 자바스크립트 메인 스레드\n\n![자바스크립트 메인 스레드](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_6.png)\n\n자바스크립트 메인 스레드의 모든 활동과 각 활동을 완료하는 데 소요된 시간을 보여줍니다. 호출 스택을 시각화하며 각 레이어가 작업을 나타냅니다. 각 작업을 완료하는 데 소요된 자체 시간과 총 시간을 제공합니다.\n\n![작업 시간 시각화](/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_7.png)\n\n\n\n자기 시간은 해당 메서드가 그 안에서 호출된 다른 메서드로 인해 발생한 시간을 제외하고 코드 라인 전체를 실행하는 데 걸리는 시간을 의미합니다. 총 시간은 해당 메서드 자체와 내부에서 호출된 다른 메서드에 의해 소요된 시간을 포함합니다.\n\n화염 차트에서는 위에서 아래로 쌓인 함수들을 볼 수 있습니다. JavaScript 이벤트 루프는 호출 스택을 확인하고 다음 호출 스택을 시작하기 전에 비어 있는 상태에서 LIFO (Last In, First Out) 순서로 쌓인 모든 작업을 실행합니다. 이는 JavaScript가 단일 스레드 언어임을 나타내며, 즉 한 번에 하나의 작업을 수행할 수 있다는 것을 보여줍니다.\n\n위의 화염 차트에서 JavaScript 메인 스레드에서 어떤 작업이 발생하는지 설명하기 위해 몇 가지 중요한 부분에 대해 강조해 보겠습니다.\n\n\n\n초록 상자 안에는 최상위 함수가 DOMContentLoaded에 대한 이벤트 핸들러이고, 콜백 함수는 getData() 함수입니다. 이 함수는 Fetch API를 호출하여 HTTP 요청을 보내는 것을 담당합니다. 이 시점에서 fetch 작업은 브라우저의 Web API로 전달됩니다.\n\n자바스크립트 이벤트 루프에서 자바스크립트 엔진은 다음 매크로태스크를 시작하기 전에 실행할 마이크로태스크가 있는지 확인합니다. API 호출이 메인 자바스크립트 스레드 외부에서 처리되므로, 데이터가 도착하기 전에 브라우저 렌더링 단계(빨간 상자에 표시됨)나 기타 동기 코드와 같은 다른 매크로태스크를 계속 실행합니다.\n\n데이터가 도착하면 프로미스의 해결(resolve) 부분(try-catch 블록 내 await 뒤에 배치된 코드)이 마이크로태스크로 예약됩니다. 현재 매크로태스크가 완료되면, 이벤트 루프는 다음 매크로태스크로 넘어가기 전에 모든 누적된 마이크로태스크를 처리합니다.\n\n\n\n이 문서는 단일 스레드 JavaScript가 매크로태스크와 마이크로태스크 개념을 사용하여 I/O 작업을 비차단으로 수행하는 방법을 완벽하게 보여줍니다. 이를 통해 UI가 상호작용하고 응답성을 유지할 수 있습니다.\n\n# 팁: 프로파일러를 효율적으로 활용하는 방법\n\nJavaScript 메인 스레드 타임라인에서 특정 함수를 검색하려면 키보드 단축키 Command + F를 사용할 수 있습니다. 일반적으로, 조사하려는 이벤트나 네트워크 요청을 먼저 찾고, 그런 다음 JavaScript 메인 스레드의 작업들을 살펴보곤 합니다.\n\n## 예시 1: LCP 성능 저하 조사하기\n\n\n\n앱이 콘텐츠를 로드하는 데 오랜 시간이 걸리거나 LCP 점수가 낮은 이유를 알아보고 싶다면 DOMContentLoaded 이벤트를 검색하여 콜 스택에서 발생하는 작업을 확인할 수 있습니다. 프리즈는 일반적으로 오랜 작업으로 인해 발생하며, 이는 콜 스택이 50ms 이상 소요되는 것을 의미합니다.\n\n## 예시 2: 클릭 작업에서 앱 프리징 조사하기\n\n버튼을 클릭할 때 앱이 왜 멈추는지 조사하고 싶다면 녹화를 시작하고 해당 작업을 수행하세요. 그런 다음 마우스 이벤트인 Event: pointerdown 또는 Event: mousedown을 검색하고 콜 스택의 기능을 검토하세요.\n\n또한 스크린샷을 사용하여 조사하고자 하는 특정 시간대를 파악할 수도 있습니다.\n\n\n\n프로파일러는 디버깅 및 브라우저, JavaScript, 심지어 프레임워크 작동 이해에 매우 유용한 도구입니다! 여기서 무언가를 배웠으면 좋겠네요. 프로파일링을 즐기세요!","ogImage":{"url":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png"},"coverImage":"/assets/img/2024-05-12-ChromesPerformancePanel101WhatsGoingoninYourJavaScriptMainThread_0.png","tag":["Tech"],"readingTime":6},{"title":"DOM 기반 XSS에 대해서 알아보자","description":"","date":"2024-05-12 23:27","slug":"2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration","content":"\n안녕하세요 여러분, 모두 잘 지내시길 바랍니다.\n이 글은 DOM XSS에 관한 것이며, 클라이언트 측 JavaScript의 소스 코드 분석만으로도 DOM XSS를 찾아낼 수 있는 방법에 대해 다룹니다.\n\n웹 애플리케이션의 클라이언트 측 코드를 분석하는 중에 보안 취약점이 발견되었습니다. 이 취약점은 DOM 기반 크로스사이트 스크립팅(XSS) 공격을 허용합니다.\n\n![DOM XSS](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png)\n\n이 취약점은 URL 매개변수에서 가져온 사용자 입력을 잘못 처리한 것에서 비롯됩니다. 애플리케이션은 window.location.search 함수를 사용하여 utm_source 및 utm_campaign 두 매개변수를 가져옵니다. 이 매개변수는 그런 다음 getUrlParameter() 함수로 전달됩니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_1.png)\n\n이 함수는 URL 쿼리 문자열에서 특정 매개변수의 값을 추출하고 디코딩한 후 해당 값을 반환하는 데 목적을 둡니다. 예를 들어, URL이 다음과 같은 경우 https://exapmle.com/redact?utm_source=hello Figure 1의 아래 코드가 실행됩니다.\n\ngetUrlParamter(`utm_source`, queryString) 함수는 utm_source 매개변수인 hello의 값을 반환하여 utm_source 변수에 저장할 것이며, utm_campaign 매개변수에 대해서도 동일합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_2.png)\n\n그림 3에서 utm_campaign 매개변수 값이 \"closedDomains\"로 설정되면, 애플리케이션은 utm_source의 값에 따라 switch case 문을 실행합니다. 일치하는 case가 없는 경우, 애플리케이션은 utm_source의 값으로 brandName() 함수를 호출합니다.\n\n![이미지](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_3.png)\n\n그림 4에서 brandName 함수는 매개변수 값에 따라 .js-brandname-container 클래스를 가진 요소를 숨기거나 .js-brandname 클래스를 가진 요소의 inner HTML을 설정하는 방식으로 설계되었습니다. brandName 값이 false로 설정되면 지정된 요소를 숨기고, 그렇지 않으면 요소의 inner HTML을 제공된 brandName 값으로 설정합니다.\n\n그림 3에서 이미 알 수 있듯이, 우리는 URL 매개변수 utm_source를 통해 함수brandName(utm_source)에 전달되는 매개변수 값을 제어할 수 있으므로 이제 HTML 태그를 삽입하고 임의의 JavaScript 코드를 실행할 수 있습니다.\n\n프론트 엔드 개발자입니다. 위의 텍스트를 친절한 어조로 한국어로 번역해 주세요.\n\n아카마이 방화벽이 구출 작업을 수행했습니다. 이제 (WAF)가 잠재적으로 존재할지라도 XSS 공격을 실행하기 위해 성공적으로 우회했습니다. 다음 payload를 자유롭게 사용하세요.\n\nhttps://your-server/x.js를 자신의 서버로 바꿔주세요. 자바스크립트 파일을 업로드한 서버에 대체하세요. 해당 파일은 payload를 실행할 것입니다.\n\n\"Click Me\" 버튼을 클릭하면 됩니다.\n\n![DOM-based XSS Attack](/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_6.png)\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png"},"coverImage":"/assets/img/2024-05-12-BreakingDownDOM-basedXSSAPracticalExploration_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 JS 또는 자바스크립트에서 데이터 가짜로 만들어 사용하기","description":"","date":"2024-05-12 23:23","slug":"2024-05-12-MockingDatainreactjsorjavascript","content":"\n\n- React.js나 JavaScript에서 모킹 데이터는 개발이나 테스트 중에 API나 백엔드 서비스로부터의 응답을 시뮬레이션하기 위해 가짜 데이터를 생성하는 것을 의미합니다.\n- 이를 통해 백엔드에 독립적으로 프론트 엔드 애플리케이션을 개발하고 테스트할 수 있습니다. 서버가 실제로 반환한 데이터와 상관없이 UI 컴포넌트가 예상대로 작동하는지 확인할 수 있습니다.\n\n다음은 React.js나 JavaScript에서 모킹 데이터를 하는 일반적인 방법 몇 가지입니다:\n\n- 하드코딩된 데이터: 코드 내에서 모의 데이터를 직접 정의합니다. 작은 데이터 세트나 정적 콘텐츠의 경우 특히 간단한 방법입니다.\n\n```js\nconst mockData = [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 },\n  // 기타 모킹 데이터...\n];\n```\n\n\n\n2. JSON 파일: 모의 데이터를 JSON 파일에 저장하고 필요할 때 코드로 가져옵니다. 이렇게 하면 모의 데이터를 코드베이스와 별도로 구성하고 관리할 수 있습니다.\n\n```js\n// mockData.json\n[\n  { \"id\": 1, \"name\": \"John Doe\", \"age\": 30 },\n  { \"id\": 2, \"name\": \"Jane Smith\", \"age\": 25 }\n  // 더 많은 모의 데이터...\n]\n```\n\n- `./mockData.json`에서 mockData를 가져옵니다;\n\n모의 라이브러리: faker.js 또는 mockjs와 같이 데이터를 모의하는 데 특별히 설계된 라이브러리를 사용하십시오. 이러한 라이브러리는 미리 정의된 스키마나 템플릿에 따라 랜덤하거나 현실적으로 보이는 모의 데이터를 생성합니다.\n\n\n\n```js\n// Using faker.js\nimport faker from 'faker';\n\nconst mockData = Array.from({ length: 10 }, () =\u003e ({\n  id: faker.datatype.uuid(),\n  name: faker.name.findName(),\n  age: faker.datatype.number({ min: 18, max: 100 })\n}));\n```\n\n4. API 모킹: 만일 당신의 애플리케이션이 API와 통신한다면, axios-mock-adapter나 msw (Mock Service Worker)와 같은 도구를 사용하여 API 응답을 모킹할 수 있습니다. 이러한 도구들은 HTTP 요청을 가로채 미리 정의된 응답을 반환함으로써 다양한 시나리오와 예외 상황을 시뮬레이션할 수 있게 합니다.\n\n```js\nimport axios from 'axios';\nimport MockAdapter from 'axios-mock-adapter';\n\nconst mock = new MockAdapter(axios);\n\nmock.onGet('/users').reply(200, [\n  { id: 1, name: 'John Doe', age: 30 },\n  { id: 2, name: 'Jane Smith', age: 25 }\n  // 더 많은 모킹 데이터...\n]);\n```\n\n이것들은 React.js나 JavaScript에서 데이터를 모킹하는 방법의 일부 예시일 뿐입니다. 선택하는 접근 방식은 특정 사용 사례, 기호 및 애플리케이션의 복잡성에 따라 다릅니다. 데이터 모킹은 효과적인 개발과 테스트를 위해 필수적이며, 애플리케이션의 각 부분을 독립적으로 분리하고 유효성을 검사할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png"},"coverImage":"/assets/img/2024-05-12-MockingDatainreactjsorjavascript_0.png","tag":["Tech"],"readingTime":2},{"title":"단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포","description":"","date":"2024-05-12 23:21","slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker","content":"\n\n모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\n\n저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\n\n![이미지](/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png)\n\n시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\n\n\n\n- 표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\n- 이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\n- 여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\n- 한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\n\n이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\n\n- pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\n- 클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\n- 서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\n\n전제 조건:\n\n\n\n- NodeJS: Node.js 설치 방법\n- pnpm: pnpm 설치 방법\n\n## pnpm 워크스페이스\n\n- 루트 폴더에 pnpm 워크스페이스 생성하기\n\n```js\npnpm init\n```\n\n\n\n- 패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\n\n```js\nmkdir packages\n```\n\n- pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\n\n```js\ntouch pnpm-workspace.yaml\n```\n\n\n\n- 우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\n\n```js\n//pnpm-workspace.yaml\npackages:\n  - 'packages/*'\n```\n\n- 루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\n\n```js\ntouch docker-compose.yml\n```\n\n\n\n## 클라이언트\n\n- 우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\n\n```js\n pnpm create vite\n```\n\n- 클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\n\n\n\n```js\ncd client\npnpm install\npnpm run dev\n```\n\n- 클라이언트용 도커 파일\n\n```js\ntouch Dockerfile\n```\n\n## 서버\n\n\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n```\n\n- 서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\n\n```js\nnpm init\n```\n\n\n\n- 그리고 Express 프레임워크를 설치하세요.\n\n```js\nnpm install express\n```\n\n- 서버용 도커 파일도 만들어주세요.\n\n```js\ntouch Dockerfile\n```\n\n\n\n- 멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\n\n연결이 얼마나 잘 되었는지 확인해봐요!\n\n## 서버 + 클라이언트\n\n- 서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 http://localhost:3000에서 제공할 목록이 있어요\n\n\n\n```js\ntouch index.js\n```\n\n```js\n// server/index.js\nconst express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) =\u003e {\n  res.json([\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Bob\", age: 35 },\n  ]);\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`I am doing great and serving at ${PORT}`);\n});\n```\n\n- 패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\n\n```js\n\"scripts\": {\n    \"dev\": \"node index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n},\n```\n\n\n\n- 그리고 물론 실행해 주세요\n\n```js\npnpm run dev\n```\n\n- 이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 http://localhost:3000을 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n\n\n- vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 http://localhost:3000을 /api를 호출하여 프록시합니다.\n- 이제 App.ts 파일에서는 /api를 호출하여 http://localhost:3000에서 데이터를 가져옵니다.\n\n```js\nimport { useEffect, useState } from \"react\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [data, setData] = useState\u003cany\u003e(null);\n  useEffect(() =\u003e {\n    const fetchData = async () =\u003e {\n      const response = await fetch(\"/api\");\n      const data = await response.json();\n      console.log(data);\n      setData(data);\n    };\n    fetchData();\n  }, []);\n\n  return \u003c\u003e{data \u0026\u0026 \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e}\u003c/\u003e;\n}\n\nexport default App;\n```\n\n- 목록을 보려면 프론트앱을 시작해주세요.\n\n```js\npnpm run dev\n```\n\n\n\n이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\n\n개선 사항\n\n- 이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\n\n```js\n\"scripts\": {\n    \"client\": \"pnpm --filter \\\"client\\\" run dev\",\n    \"server\": \"pnpm --filter \\\"server\\\" run dev\",\n    \"app\": \"pnpm run client \u0026 pnpm run server\"\n},\n```\n\n\n\n- 클라이언트용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/client\n\n# 클라이언트 package.json 복사\nCOPY package.json .\n\n# 의존성 설치 \nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 8080\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n- 서버용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/server\n\n# 서버 package.json 복사\nCOPY package.json .\n\n# 의존성 설치\nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 3000\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n\n\n- 도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\n\n```js\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target:\n          process.env.NODE_ENV === \"docker\"\n            ? \"http://server_c:3000\"\n            : \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n- 루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\n\n```yaml\nservices:\n  client:\n    build: ./packages/client\n    container_name: client_c\n    ports:\n      - \"8080:8080\"\n    environment:\n      - NODE_ENV=docker\n\n  server:\n    build: ./packages/server\n    container_name: server_c\n    ports:\n      - \"3000:3000\"\n```\n\n\n\n여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\n\n```js\ndocker-compose up\n```\n\n더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\n- 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png","tag":["Tech"],"readingTime":7}],"page":"125","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"125"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>