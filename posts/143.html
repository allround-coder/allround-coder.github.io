<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/143" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/143" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Expo Dev Client 설치 방법 완벽한 가이드 2024" href="/post/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Expo Dev Client 설치 방법 완벽한 가이드 2024" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Expo Dev Client 설치 방법 완벽한 가이드 2024" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Expo Dev Client 설치 방법 완벽한 가이드 2024</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송" href="/post/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 내 상태가 비용이 드는 걸까요" href="/post/2024-05-12-Ismystateinreactgoingtocostme"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 내 상태가 비용이 드는 걸까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Ismystateinreactgoingtocostme_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 내 상태가 비용이 드는 걸까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 내 상태가 비용이 드는 걸까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기" href="/post/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개" href="/post/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 성능 최적화 Tree Shaking 설명" href="/post/2024-05-12-OptimizingWebPerformanceTreeShakingExplained"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 성능 최적화 Tree Shaking 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-OptimizingWebPerformanceTreeShakingExplained_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 성능 최적화 Tree Shaking 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 성능 최적화 Tree Shaking 설명</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실제 사용자 모니터링RUM" href="/post/2024-05-12-RealUserMonitoringRUM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실제 사용자 모니터링RUM" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-RealUserMonitoringRUM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실제 사용자 모니터링RUM" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">실제 사용자 모니터링RUM</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 컴포넌트 라이프사이클 이해하기 React 컴포넌트의 생애 과정을 깊숙히 파헤쳐보기" href="/post/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 컴포넌트 라이프사이클 이해하기 React 컴포넌트의 생애 과정을 깊숙히 파헤쳐보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 컴포넌트 라이프사이클 이해하기 React 컴포넌트의 생애 과정을 깊숙히 파헤쳐보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 컴포넌트 라이프사이클 이해하기 React 컴포넌트의 생애 과정을 깊숙히 파헤쳐보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="매터리얼 UI 컴포넌트와 테마를 사용자 정의하는 현대적인 방법" href="/post/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="매터리얼 UI 컴포넌트와 테마를 사용자 정의하는 현대적인 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="매터리얼 UI 컴포넌트와 테마를 사용자 정의하는 현대적인 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">매터리얼 UI 컴포넌트와 테마를 사용자 정의하는 현대적인 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 애플리케이션 성능 향상을 위한 클라이언트 측 타임아웃 처리 방법" href="/post/2024-05-12-EnhancingReactApplicationPerformancewithClient-SideTimeoutHandling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 애플리케이션 성능 향상을 위한 클라이언트 측 타임아웃 처리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-EnhancingReactApplicationPerformancewithClient-SideTimeoutHandling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 애플리케이션 성능 향상을 위한 클라이언트 측 타임아웃 처리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 애플리케이션 성능 향상을 위한 클라이언트 측 타임아웃 처리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link posts_-active__YVJEi" href="/posts/143">143</a><a class="link" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a><a class="link" href="/posts/152">152</a><a class="link" href="/posts/153">153</a><a class="link" href="/posts/154">154</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Expo Dev Client 설치 방법 완벽한 가이드 2024","description":"","date":"2024-05-12 19:08","slug":"2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png\" /\u003e\n\n# 그럼, 시작해봅시다!\n\n다음 튜토리얼은 Windows 기기용으로 제작되었으며, 특히 Windows 10 (64비트)에 맞춰져 있습니다. 만약 맥이나 리눅스를 사용하고 계신다면, 전반적인 과정을 이해하기 위해 읽어보세요.\n\n## 목차 —\n\n\n\n- Java Development Kit (JDK)을 설치하세요.\n- 환경 변수 설정: JAVA_HOME 및 JAVA 경로\n- Android Studio 다운로드\n- SDK 및 빌드 도구 구성\n- Android 에뮬레이터 구성\n- Android 환경 변수 설정: ANDROID_HOME 및 경로\n- NodeJS 설치\n- Expo 프로젝트 설정\n- Expo 개발 클라이언트 설정 및 Expo 프로젝트 로컬에서 컴파일\n- 첫 번째 디버그-개발 빌드 생성\n\n## Expo Dev Client는 무엇인가요?\n\n공식 Expo 문서에 따르면, Expo Go 대신 개발 빌드를 선택하면 원시 런타임을 완전히 제어할 수 있습니다. 이를 통해 원시 라이브러리를 설치하거나 프로젝트 구성을 조정하거나 심지어 고유의 원시 코드를 작성할 수 있습니다.\n\n더 간단하게 말하면, 기본 Expo 구성은 프로젝트를 Expo 클라우드에 업로드한 다음 빌드를 받는 과정으로 진행됩니다. 그러나 이 프로세스는 Expo 라이브러리만 원활하게 지원합니다. @react-native-google-signin/google-signin과 같은 원시 라이브러리를 사용할 경우 이와 같은 방식으로 작동하지 않습니다.\n\n\n\n## Expo Dev Client 설정하기: 단계별 안내\n\n이 튜토리얼에서는 JAVA Development Kit (JDK), 안드로이드 스튜디오 및 Node가 필요합니다.\n\nOracle 또는 OpenJDK 플랫폼을 방문하여 JDK를 다운로드하고 Gradle 버전과 호환되는지 확인하십시오. 2024년 기준으로 React Native는 Gradle 8.3을 사용하고 있으며 이는 JDK 17과 호환됩니다.\n\n설치 가이드를 따르고 JAVA를 설치하는 경로를 메모해두세요. 기본적으로 C:\\Program Files\\Java\\jdk-17 경로에 설치됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_1.png\" /\u003e\n\n시스템 속성에서 ‘환경 변수’를 검색하세요. 이 섹션에서 사용자 계정과 시스템 변수가 있습니다. 둘 다 변수를 설정하는 것이 좋습니다.\n\n다음 단계를 따르세요:\n\n- ‘JAVA_HOME’이라는 이름의 새 변수를 시스템 및 사용자 변수에 생성하고 JDK를 설치한 경로를 입력하세요\n(예: C:\\Program Files\\Java\\jdk-17).\n- 시스템 변수 아래에 ‘Path’ 변수를 찾으세요. ‘jdk/bin’ 폴더의 경로를 추가하세요 (예: C:\\Program Files\\Java\\jdk-17\\bin).\n\n\n\n드디어 설치를 확인하려면 명령 프롬프트(cmd)에서 'java -version'을 실행해주세요. 제대로 설정했다면 자바 버전 정보가 표시될 것입니다.\n\n에뮬레이터, SDK 및 플랫폼 도구를 설치하려면 안드로이드 스튜디오가 필요합니다. 또한 IDE를 통해 로컬 빌드를 실행할 수도 있습니다.\n\n공식 안드로이드 웹사이트에 방문하여 최신 IDE를 다운로드하세요. 기본 설치 가이드를 따라 설치 경로를 기억해주세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_2.png)\n\n\n\n설치를 완료한 후 안드로이드 스튜디오를 열고 SDK 관리자를 엽니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_3.png)\n\n호환성을 위해 가장 최신 SDK 버전과 바로 전 버전을 함께 설치해주세요. 예를 들어, 현재 가장 최신 SDK 버전은 34이므로 33 버전도 설치하시면 됩니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_4.png)\n\n\n\nSDK와 함께 필요한 도구들이 있습니다. 기본적으로 설치되는 일부 도구들 외에 추가로 필요한 것들이 있습니다:\n\n- 안드로이드 SDK 명령줄 도구\n- 안드로이드 SDK 플랫폼 도구\n- 안드로이드 SDK 빌드 도구\n- 안드로이드 에뮬레이터\n- Google Play 라이센스 라이브러리 (선택 사항)\n\n체크박스를 선택하고 적용을 클릭하면 설치됩니다.\n\n![Android SDK](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_5.png)\n\n\n\n당신의 어플리케이션을 실행하기 위한 기본 에뮬레이터를 설정해야 합니다. 장치에서 어플리케이션을 실행할 수도 있지만, 적어도 하나의 에뮬레이터가 있어야 합니다.\n\n가상 장치 관리자로 이동해주세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_6.png)\n\n처음에는 새로운 장치가 보이지 않을 수 있습니다. + 아이콘 '새 가상 장치 생성'을 클릭하고, 장치를 선택한 후 '다음'을 클릭하여 OS 버전과 세로 방향을 선택해주세요.\n\n\n\n새 장치를 설정하는 동안 Intel HAXM 설치 실패와 관련된 오류가 발생할 수 있습니다. 이를 해결하기 위해 Stack Overflow 답변 가이드를 따르세요.\n\n설치가 완료되면 가상 장치를 실행할 수 있어야 합니다. 로딩에 몇 분이 소요될 수 있으니 조급해하지 마세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_7.png)\n\nExpo 및 React Native가 SDK 도구에 올바르게 액세스할 수 있도록 환경 변수 섹션에서 해당 경로를 선언해야 합니다. 2단계와 유사하게 진행하세요.\n\n\n\nSDK 도구가 설치된 위치는 기본적으로 SDK 관리자에서 제공됩니다. 사용자/AppData 디렉토리에 있습니다.\n\n파일 탐색기에서 해당 경로로 이동해주세요. 사용자 계정 내의 'AppData' 폴더는 기본적으로 숨겨져 있습니다. '숨겨진 파일 표시'를 활성화해야 'AppData' 폴더에 액세스할 수 있습니다.\n\n이제 환경 변수를 다시 엽니다.\n\n- 시스템 및 사용자 변수에서 'ANDROID_HOME'이라는 정확한 이름의 새 변수를 만들고 SDK를 설치한 경로(C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk)를 포함시킵니다.\n- 이제 시스템 및 사용자 변수에 위치한 'Path' 변수에 다음 경로를 추가하세요. '사용자명'을 실제 계정명으로 교체해주세요:\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\platform-tools\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\emulator\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\tools\n- C:\\Users\\사용자명\\AppData\\Local\\Android\\Sdk\\tools\\bin\n\n\n\n마침내 CMD 내에서 ADB 쉘을 실행할 수 있어야 합니다. 설정을 확인하려면 'adb --version'을 실행하세요.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_8.png)\n\nNode의 안정 버전을 다운로드하세요. 저는 현재 18.18.0을 사용 중이며 기본 설치 가이드를 따르면 됩니다.\n\nCMD 내에서 'node --version' 명령으로 설치를 확인하세요.\n\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_9.png)\n\n마침내, 우리는 Expo 애플리케이션을 시작할 수 있습니다. 저는 NativeWind-Tailwind 지원, 최신 Expo SDK 50, Expo 파일 기반 라우팅, React Reanimated 라이브러리 및 TypeScript 통합을 포함한 애플리케이션을 설정하는 데 다음 예제를 사용합니다.\n\n```js\nnpx create-expo-app -e with-router-tailwind\n```\n\n프로젝트가 작동하고 오류가 없는지 확인하세요. Play Store 또는 App Store에서 실제 기기에 Expo Go Client를 다운로드하세요. 그런 다음 아래 명령을 실행하여 QR 코드를 스캔하여 기기에서 Expo 애플리케이션을 실행하세요. 이제 Expo Go Client로 애플리케이션을 실행 중임을 주의하세요.\n\n\n\n\n```js\r\nnpm run start\r\n```\n\n만약 모든 것이 올바르게 작동하고 있다면 Expo 대시보드에 로그인하기 위해 EAS CLI를 다운로드하십시오.\n\n```js\r\nnpm install --global eas-cli\r\n```\n\n작업을 완료한 후에는 다음 명령어를 사용하여 대시보드에 로그인하십시오. Expo 계정이 없다면 여기에서 생성하십시오.\n\n\n\n```js\neas login  // 사용자 이름과 비밀번호를 입력하라는 프롬프트가 나타납니다.\neas whoami // 사용자 이름을 반환합니다.\n```\n\neas.json 파일을 만들어서 빌드 구성 파일로 사용하세요. 이 파일에는 세 가지 프로필이 있습니다. 여기에서 자세히 알아보세요. eas.json 파일을 만들려면 프로젝트 터미널에서 다음 명령을 실행하세요.\n\n```js\neas:configure\n```\n\neas.json 파일을 업데이트하여 빌드 유형을 APK로 지정하여 기기에 직접 설치할 수 있도록 했습니다.\n\n\n\n```js\n{\n  \"cli\": {\n    \"version\": \"\u003e= 7.2.0\"\n  },\n  \"build\": {\n    \"development\": {\n      \"developmentClient\": true,\n      \"distribution\": \"internal\",\n      \"android\": {\n        \"buildType\": \"apk\"\n      }\n    },\n    \"preview\": {\n      \"distribution\": \"internal\",\n      \"android\": {\n        \"buildType\": \"apk\"\n      }\n    },\n    \"production\": {}\n  },\n  \"submit\": {\n    \"production\": {}\n  }\n}\n```\n\n검증을 위해, 다음 명령을 사용하여 Expo 대시보드 내에서 미리보기 프로필로 Expo 애플리케이션을 빌드할 수 있습니다. 그러나 주의해야 할 점은 developmentClient가 true로 설정되어 있기 때문에 개발용 빌드는 불가능합니다.\n\n```js\neas build -p android --profile preview\n```\n\n개발 환경을 설정하는 필수 헤더를 애플리케이션에 추가하는 Expo Dev Client 라이브러리를 설치해야 합니다. 프로젝트 터미널에서 아래 명령을 실행하세요.\n\n\n\n```js\nnpx expo install expo-dev-client\n```\n\n참고: 이 라이브러리를 설치하면 Expo 프로젝트를 실행하는 기본 구성(npm run start 사용)이 개발 빌드로 전환됩니다. 따라서 Expo Go Client 모바일 애플리케이션이 작동하지 않습니다. Expo Client 내에서 실행하려면 터미널을 사용하여 Expo Go로 전환해야 합니다. 또한, 네이티브 라이브러리를 사용하고 있지 않은지 확인하세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_10.png\" /\u003e\n\n다음 명령을 사용하여 프로젝트를 로컬에서 컴파일하세요.\n\n\n\n```js\nnpx expo run:android \n```\n\n이 명령은 이전에 설치한 JDK 및 SDK 도구를 사용하여 Gradle 파일을 생성합니다. 먼저 프로젝트 내에 .android 폴더를 만들고 응용 프로그램을 실행하기 위해 에뮬레이터를 시작합니다. 컴파일 프로세스는 약 15분 이상 소요되므로 조금만 기다려주십시오.\n\n첫 번째 개발 빌드를 생성하려면 다음 명령을 사용하십시오:\n\n```js\neas build --profile development --platform android\n```  \n\n\n\n이 작업은 EAS 서버로 애플리케이션을 컴파일하는 것입니다. 로그인한 후 대시보드에서 진행 상황을 확인할 수 있어요.\n\n작업이 완료되면 \"설치\" 버튼을 클릭하여 애플리케이션 (APK)을 다운로드할 수 있어요. 추가로 터미널에서는 애플리케이션을 에뮬레이터 내에서 실행할 것인지 선택하라고 안내할 거에요. 저는 애플리케이션을 실제 장치에서 실행하는 것을 선호하니, 같은 취향을 가진다면 모바일 브라우저에서 링크를 열고 애플리케이션을 다운로드하세요.\n\n참고: 애플리케이션 크기에 대해 걱정하지 마세요; 최적화되지 않은 APK 빌드입니다.\n\n![이미지](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_11.png)\n\n\n\n앱을 다운로드하고 설치한 후, 맨 위에 앱 이름과 함께 다음과 같은 인터페이스가 표시됩니다.\n\n![앱 인터페이스](/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_12.png)\n\n이제 프로젝트 터미널로 돌아가서 다음 명령을 실행해보세요:\n\n```js\nnpx expo start --dev-client\n```\n\n\n\n처음에 애플리케이션은 개발 서버를 자동으로 감지하지 못할 수 있습니다. 따라서 수동으로 URL을 입력해야 합니다. 위 명령으로 코드를 컴파일한 후에는 localhost URL을 제공할 것입니다. 예를 들어, http://localhost:8081과 같이 나올 겁니다.\n\n애플리케이션에서 \"localhost\" 부분을 자신의 IP 주소로 바꾸세요. 핸드폰이 동일한 Wi-Fi 네트워크에 연결되어 있는지 확인한 후, 애플리케이션에서 http://192.168.0.100:8081과 같이 수동으로 URL을 입력하세요. 그러면 애플리케이션이 로드되고, Expo Go Client와 유사한 핫 리프레시 기능을 지원할 겁니다.\n\n참고: 새 라이브러리를 설치할 때마다 위 명령을 사용하여 애플리케이션을 다시 빌드하고, 기기에 최신 빌드를 다운로드/설치해야 합니다.\n\n그러니까, 한숨을 내쉬세요. Expo 개발 클라이언트 설정이 완료되었습니다. 건배! 🥂\n\n\n\n어려움이 있으면 언제든지 연락해주세요.\nLinkedIn | Twitter (X)","ogImage":{"url":"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoSetUpExpoDevClientACompleteGuide2024_0.png","tag":["Tech"],"readingTime":8},{"title":"NET Core에서 웹 소켓과 SignalR을 활용한 실시간 데이터 전송","description":"","date":"2024-05-12 19:05","slug":"2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore","content":"\n\n실시간 데이터 전송은 즉각적인 업데이트와 알림이 필요한 애플리케이션에 꼭 필요합니다. .NET Core에서 WebSockets 및 SignalR은 클라이언트와 서버 간의 실시간 통신을 구현하는 강력한 도구를 제공합니다. 이 안내서에서는 WebSockets 및 SignalR을 사용하여 .NET Core 애플리케이션에서 실시간 데이터 전송을 어떻게 구현하는지 살펴볼 것입니다.\n\nDotNet-FullStack-Dev와 함께 계속해서 학습과 탐험의 여정을 떠나보세요. 더 많은 정보 확인은 https://dotnet-fullstack-dev.blogspot.com을 방문하거나 추가 정보를 얻으려면 연락해주세요.\n\n# WebSockets 및 SignalR이란?\n\n# WebSockets:\n\n\n\nWebSockets는 단일 TCP 연결을 통해 전 이중 통신 채널을 제공하는 프로토콜입니다. 이를 통해 클라이언트와 서버 간에 양방향 통신이 가능하며 HTTP 폴링의 오버헤드 없이 비동기적으로 데이터를 송수신할 수 있습니다.\n\n# WebSockets를 사용해야 하는 이유\n\n- 실시간 통신: WebSockets를 이용하면 실시간 데이터 전송이 가능해지며, 채팅 애플리케이션, 실시간 대시보드, 온라인 게임 플랫폼과 같은 즉각적인 업데이트가 필요한 애플리케이션에 이상적입니다.\n- 효율성: 전통적인 HTTP 폴링이나 롱 폴링 기술과 달리 WebSockets는 지속적인 연결을 유지하여 오버헤드를 줄이고 지연 시간을 최소화하며 네트워크 트래픽을 감소시킵니다.\n- 전 이중 통신: WebSockets는 양쪽으로 동시에 데이터 전송을 지원하여 클라이언트와 서버가 독립적으로 메시지를 송수신할 수 있습니다.\n- 확장성: WebSockets는 대규모 동시 연결을 효율적으로 처리할 수 있어 확장 가능하고 고성능 애플리케이션에 적합합니다.\n\n# WebSockets 대안:\n\n| **대안**                  | **설명**                                                                                                    |\n|-----------------------|---------------------------------------------------------------------------------------------------------|\n| Server-Sent Events    | 서버에서 클라이언트로 단 방향 메시지 스트림을 전송하는 기술로, WebSockets와 유사하지만 단방향 통신만 지원합니다.   |\n| Long Polling           | 클라이언트가 서버에게 요청을 보내고, 서버는 데이터를 준비할 때까지 응답을 지연시키는 방법입니다.                  |\n\n\n\n웹소켓은 실시간 통신에 널리 사용되지만, 유사한 기능을 제공하는 몇 가지 대안이 있습니다:\n\n- Server-Sent Events (SSE): SSE은 서버가 HTTP 연결을 통해 클라이언트로 업데이트를 푸시할 수 있는 단방향 통신 프로토콜입니다. 웹소켓과 달리 SSE는 서버에서 클라이언트로의 통신에만 제한되며 양방향 통신을 지원하지 않습니다.\n- Long Polling: Long Polling은 클라이언트가 서버에 요청을 보내고, 서버가 새로운 데이터가 나타날 때까지 연결을 유지하거나 타임아웃이 발생할 때까지 연결을 열어두는 기술입니다. Long Polling은 실시간 업데이트를 달성할 수 있지만, 연결을 자주 열고 닫기 때문에 웹소켓보다 효율성이 떨어집니다.\n\n# 웹소켓의 장단점:\n\n## 장점:\n\n\n\n- 실시간 업데이트: 웹 소켓을 통해 실시간 통신이 가능하며 클라이언트에 즉시 업데이트를 제공합니다.\n- 효율성: 웹 소켓은 폴링 기술과 비교하여 대기 시간과 네트워크 오버헤드를 줄입니다.\n- 전이중 통신: 양방향 데이터 전송을 지원하여 클라이언트와 서버가 동시에 메시지를 보내고 받을 수 있습니다.\n- 확장성: 웹 소켓은 많은 동시 연결을 효율적으로 처리할 수 있어 확장 가능한 애플리케이션에 적합합니다.\n\n## 단점:\n\n- 복잡성: 웹 소켓 연결을 구현하고 관리하는 것은 전통적인 HTTP 통신보다 더 복잡할 수 있습니다.\n- 브라우저 지원: 최신 브라우저는 웹 소켓을 지원하지만 오래된 브라우저는 지원하지 않을 수 있어 대체 메커니즘이 필요할 수 있습니다.\n- 방화벽 문제: 웹 소켓은 제한적인 방화벽이나 프록시 서버에서 웹 소켓 트래픽을 차단할 수 있는 문제가 있을 수 있습니다.\n\n# SignalR:\n\n\n\nSignalR은 .NET 애플리케이션에서 실시간 웹 기능을 간단하게 만드는 데 사용되는 웹소켓과 기타 전송 매커니즘 위에 구축된 고수준 라이브러리입니다. 이는 연결 관리를 추상화하고 클라이언트에게 메시지를 브로드캐스트하고 클라이언트-서버 통신을 다루기 위한 간단한 API를 제공합니다.\n\n# SignalR을 사용해야 하는 이유:\n\n- 간단한 개발: SignalR은 웹소켓 연결 관리의 복잡성을 감추고 .NET 애플리케이션에서 실시간 기능을 구현하기 위한 간단한 API를 제공합니다. 연결 관리, 메시지 라우팅 및 오류 처리를 처리하여 개발자가 응용프로그램 논리에 집중할 수 있습니다.\n- 크로스 플랫폼 지원: SignalR은 서버 측 .NET 애플리케이션 및 클라이언트 측 JavaScript 프레임워크를 모두 지원하여 웹 애플리케이션, 데스크톱 애플리케이션 및 모바일 앱에서 실시간 기능을 구축하기에 적합합니다.\n- 확장성: SignalR은 애플리케이션과 함께 확장되도록 설계되어 많은 동시 연결을 지원하며 다중 서버로 확장하거나 Azure SignalR 서비스와 같은 클라우드 기반 솔루션을 사용할 수 있는 옵션을 제공합니다.\n- 후행 메커니즘: SignalR은 웹소켓을 지원하지 않는 클라이언트를 위해 Server-Sent Events (SSE) 또는 롱 폴링과 같은 대체 전송 메커니즘으로 자동으로 후행하므로 브라우저 및 기기에 걸쳐 넓은 호환성을 보장합니다.\n\n\n\n신호R이 .NET 애플리케이션에서 실시간 웹 기능을 구현하는 데 인기 있는 선택지라는 것을 알고 계실 겁니다. 그러나 여러 대안들도 비슷한 기능을 제공합니다:\n\n- Raw WebSocket APIs: 개발자들은 .NET이나 다른 프로그래밍 언어에서 제공하는 Raw WebSocket APIs를 활용하여, SignalR이 제공하는 추상화 없이 실시간 통신을 구현할 수 있습니다. 그러나 이 방식은 더 많은 수동 구성을 요구하며, 개발자들에게는 불편할 수도 있습니다.\n- Third-Party Libraries: .NET 애플리케이션에서 실시간 통신을 구현하는 데 사용할 수 있는 외부 라이브러리들이 있습니다. Socket.IO for .NET이나 Fleck과 같은 라이브러리들은 추가 기능과 유연성을 제공하지만, 통합 및 유지보수에 더 많은 노력이 필요할 수 있습니다.\n\n# SignalR의 장단점:\n\n## 장점:\n\n\n\n- 간편한 개발: SignalR은 실시간 기능을 구현하는 데 사용하기 위한 고수준 API를 제공하여 개발 시간과 복잡성을 줄여줍니다.\n- 크로스 플랫폼 지원: SignalR은 웹 브라우저, 데스크톱 애플리케이션 및 모바일 기기를 포함한 다양한 클라이언트를 지원합니다.\n- 확장성: SignalR은 애플리케이션과 함께 확장되도록 설계되어 많은 동시 연결을 지원하고 여러 서버로 확장할 수 있는 옵션을 제공합니다.\n- 후행 메커니즘: SignalR은 웹소켓을 지원하지 않는 클라이언트를 위해 대체 전송 메커니즘으로 자동으로 후행하므로 넓은 호환성을 보장합니다.\n\n## 단점:\n\n- .NET 프레임워크/Core에 대한 의존성: SignalR은 .NET 생태계와 긴밀하게 결합되어 있어 다른 기술로 개발된 애플리케이션에는 적합하지 않을 수 있습니다.\n- 성능 부하: SignalR은 개발을 단순화하지만 원시 웹소켓 구현과 비교해 일부 성능 부하를 도입할 수 있습니다.\n- 복잡성: SignalR은 실시간 통신의 일부 복잡성을 추상화하지만 복잡한 시나리오에서는 추가 구성 및 문제 해결이 필요할 수 있습니다.\n\n# 왜 실시간 데이터 전송을 사용해야 할까요?\n\n\n\n실시간 데이터 전송은 채팅 애플리케이션, 실시간 대시보드 및 모니터링 시스템, 협업 문서 편집 도구, 온라인 게임 플랫폼, 주식 시장 추적 애플리케이션, 라이브 스포츠 점수판과 같이 실시간 업데이트가 필요한 애플리케이션에 필수적입니다.\n\n# SignalR을 사용한 .NET Core 구현\n\n## 단계 1: SignalR 설치\n\n\n\nNuGet Package Manager를 사용하여 SignalR 패키지를 설치하세요:\n\n```js\ndotnet add package Microsoft.AspNetCore.SignalR\n```\n\n## 단계 2: SignalR 허브 만들기\n\n클라이언트 연결을 관리하고 메시지 브로드캐스팅을 처리하는 SignalR 허브를 만드세요.\n\n\n\n```js\nMicrosoft.AspNetCore.SignalR를 사용하여 SignalR을 구성하고 있어요. WebSocket 지원을 활성화하고 허브 엔드포인트를 매핑하려면 Startup 클래스에서 SignalR을 구성하세요.\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSignalR();\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =\u003e\n    {\n        endpoints.MapHub\u003cChatHub\u003e(\"/chatHub\");\n    });\n}\n\n\n\n## 단계 4: 클라이언트 측 통합\n\n클라이언트 측에 SignalR을 통합하여 연결을 설정하고 실시간 업데이트를 받으세요.\n\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003eSignalR 채팅\u003c/title\u003e\n    \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/signalr/5.0.0/signalr.min.js\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv id=\"messages\"\u003e\u003c/div\u003e\n    \u003cinput type=\"text\" id=\"messageInput\" /\u003e\n    \u003cbutton onclick=\"sendMessage()\"\u003e전송\u003c/button\u003e\n\n    \u003cscript\u003e\n        const connection = new signalR.HubConnectionBuilder()\n            .withUrl(\"/chatHub\")\n            .build();\n\n        connection.on(\"ReceiveMessage\", (user, message) =\u003e {\n            document.getElementById(\"messages\").innerHTML += `\u003cp\u003e\u003cstrong\u003e${user}\u003c/strong\u003e: ${message}\u003c/p\u003e`;\n        });\n\n        connection.start().then(() =\u003e {\n            console.log(\"SignalR 허브에 연결되었습니다\");\n        }).catch((err) =\u003e {\n            console.error(\"SignalR 허브에 연결하는 중 오류가 발생했습니다:\", err);\n        });\n\n        function sendMessage() {\n            const user = \"사용자\"; // 입력값으로부터 사용자 정보 가져오기\n            const message = document.getElementById(\"messageInput\").value;\n            connection.invoke(\"SendMessage\", user, message);\n        }\n    \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\n이 예제를 확장하여 클라이언트로부터 메시지를 받고 백엔드와 프론트엔드 코드를 사용한 엔드 투 엔드 솔루션을 제공해보죠.\n\n\n\n# Backend: ASP.NET Core Web API with SignalR\n\n## Step 1: SignalR 허브 생성\n\n클라이언트 연결을 관리하고 메시지 브로드캐스팅을 처리하는 SignalR 허브를 생성하세요.\n\nusing Microsoft.AspNetCore.SignalR;\nusing System.Threading.Tasks;\n\npublic class ChatHub : Hub\n{\n    public async Task SendMessage(string user, string message)\n    {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n\n    public void ReceiveMessage(string user, string message)\n    {\n        // 받은 메시지 처리(예: 데이터베이스 저장, 처리 등)\n    }\n}\n\n\n\n## 단계 2: Startup에서 SignalR 구성\n\nStartup 클래스에서 SignalR을 구성하여 WebSocket 지원을 활성화하고 허브 엔드포인트를 매핑합니다.\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddSignalR();\n}\n\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =\u003e\n    {\n        endpoints.MapHub\u003cChatHub\u003e(\"/chatHub\");\n    });\n}\n\n## 단계 3: 메시지 수신을 위한 컨트롤러 생성\n\n\n\n클라이언트로부터 수신된 메시지를 처리하는 컨트롤러를 만들어보세요.\n\nusing Microsoft.AspNetCore.Mvc;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class ChatController : ControllerBase\n{\n    private readonly IHubContext\u003cChatHub\u003e _hubContext;\n\n    public ChatController(IHubContext\u003cChatHub\u003e hubContext)\n    {\n        _hubContext = hubContext;\n    }\n\n    [HttpPost(\"ReceiveMessage\")]\n    public async Task\u003cIActionResult\u003e ReceiveMessage(string user, string message)\n    {\n        await _hubContext.Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n        return Ok();\n    }\n}\n\n# Frontend: React UI with SignalR\n\n## Step 1: SignalR 클라이언트 라이브러리 설치\n\n\n\nJavaScript SignalR 클라이언트 라이브러리를 npm을 사용해서 설치해주세요.\n\nnpm install @microsoft/signalr\n\n## 단계 2: WebSocket 연결 생성\n\nSignalR 허브에 대한 WebSocket 연결을 생성하고 들어오는 메시지를 처리하세요.\n\n\n\nimport React, { useState, useEffect } from 'react';\nimport * as signalR from '@microsoft/signalr';\n\nconst Chat = () =\u003e {\n    const [messages, setMessages] = useState([]);\n    const [connection, setConnection] = useState(null);\n\n    useEffect(() =\u003e {\n        const newConnection = new signalR.HubConnectionBuilder()\n            .withUrl(\"/chatHub\")\n            .build();\n\n        newConnection.on(\"ReceiveMessage\", (user, message) =\u003e {\n            setMessages([...messages, { user, message }]);\n        });\n\n        newConnection.start()\n            .then(() =\u003e console.log(\"SignalR 허브에 연결되었습니다.\"))\n            .catch(error =\u003e console.error(\"SignalR 허브에 연결 중 오류 발생:\", error));\n\n        setConnection(newConnection);\n    }, []);\n\n    const sendMessage = () =\u003e {\n        const user = \"User\"; // 입력에서 사용자 가져오기\n        const message = \"안녕, SignalR!\"; // 입력에서 메시지 가져오기\n        connection.invoke(\"SendMessage\", user, message)\n            .catch(error =\u003e console.error(\"메시지 전송 중 오류 발생:\", error));\n    };\n\n    return (\n        \u003cdiv\u003e\n            \u003cdiv\u003e\n                {messages.map((message, index) =\u003e (\n                    \u003cdiv key={index}\u003e\n                        \u003cstrong\u003e{message.user}\u003c/strong\u003e: {message.message}\n                    \u003c/div\u003e\n                ))}\n            \u003c/div\u003e\n            \u003cinput type=\"text\" /\u003e\n            \u003cbutton onClick={sendMessage}\u003e전송\u003c/button\u003e\n        \u003c/div\u003e\n    );\n};\n\nexport default Chat;\n\n# 결론\n\n이 가이드에서는 .NET Core 애플리케이션에서 웹소켓과 SignalR을 사용하여 실시간 데이터 전송을 구현하는 방법을 살펴보았습니다. SignalR을 활용하면 클라이언트와 서버 간의 실시간 통신을 쉽게 구현할 수 있어서 상호작용적이고 협업이 가능한 웹 애플리케이션을 구축하기에 이상적입니다. 채팅 애플리케이션, 실시간 대시보드, 멀티플레이어 게임을 구축할 때, 사용자에게 실시간 업데이트를 제공하는 데 필요한 도구를 제공하는 SignalR을 사용할 수 있습니다.\n\n이 가이드에서는 .NET Core 백엔드와 React 프런트엔드를 사용하여 SignalR을 통한 실시간 메시징을 구현하는 방법을 안내했습니다. 사용자는 프런트엔드에서 메시지를 보내고, 백엔드 SignalR 허브에서 모든 연결된 클라이언트에게 메시지를 수신 및 브로드캐스트합니다. 이 최종 솔루션은 웹 애플리케이션에 대한 실시간 메시징 경험을 원활하게 제공합니다.\n```\n\n\n\n표 태그를 Markdown 형식으로 변경해주실래요.","ogImage":{"url":"/assets/img/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore_0.png"},"coverImage":"/assets/img/2024-05-12-Real-TimeDataTransferwithWebSocketsandSignalRinNETCore_0.png","tag":["Tech"],"readingTime":10},{"title":"리액트에서 내 상태가 비용이 드는 걸까요","description":"","date":"2024-05-12 19:04","slug":"2024-05-12-Ismystateinreactgoingtocostme","content":"\n\n경고: 테이블을 있는 그대로 사용하면 약간 어색해보일 수 있어요. 대신 Markdown 형식을 사용하면 보기가 편할 거예요.\n\n\n\n각 사용 사례에 맞는 다양한 상태 솔루션이 있어요.\n\n성능을 균형 있게 유지하면서 React를 다시 렌더링해야 할 때는 신중히 생각해야 해요.\n\n캔버스 기반 인터페이스를 구축하기 위해 설계된 상태 라이브러리를 사용하려고 하면 가져다쓰는 데 비용이 들 거예요.\n\n그렇다고 해서 사용 중인 것보다 훨씬 나을지도 몰라요.\n\n\n\n하지만 현실에서는 단순히 보스턴에서 뉴욕으로 돌아오는 길에 걷는 것에서 자전거로 전환하지 않을 것입니다. 대신 버스를 타거나 택시를 잡을 것입니다.\n\n상태 라이브러리를 의도하지 않은 용도로 사용하면 예상치 못한 문제들이 쏟아질 수 있습니다.\n\n머릿속에서 처음부터 다시 작성할 지식 없이 상태 라이브러리를 건드린다면, 의도하지 않은 용도로 사용하기에 적격하지 않을 가능성이 높습니다.\n\n시간을 절약하고 사용 사례에 완벽하거나 거의 완벽하게 맞는 것을 찾아보세요.\n\n\n\n정밀도가 중요합니다. X가 Y보다 나은 것이 절대 아닙니다. 0.1235 해결책을 원하는 이유는 3.01234 문제를 완벽하게 해결하기 위해서입니다.\n\n문자열이나 부울 플래그 이상을 제어하는 데 단순한 useState를 사용하고 있나요? 한 발 물러나서서 해결하려는 상태 문제에 대해 실제로 무엇이 있는지 살펴보세요.\n\nGithub에서 날짜가 지나지 않은 몇 가지 실제 예제를 찾아보세요. 다른 사람이 어떻게 해당 문제를 해결했는지 확인해보세요. 어떤 문제를 해결하려고 하는 건가요? 트위터에서 누군가에게 질문해보세요.\n\n\n\nReact에서 상태(State)는 가장 중요한 요소 중 하나이며 그에 맞게 다뤄져야 합니다.\n\n상태(State)는 응용 프로그램을 더 확장하려는 시도에서 빠르게 병목 현상이 발생할 수 있기 때문에 중요합니다. 비즈니스 요구 사항이 변경될 때 새로운 기능을 추가하거나 상태를 리팩토링하는 것이 지루하게 느려질 수 있습니다.\n\n폼 데이터를 처리하기 위한 상태(State) 솔루션이 있습니다.\n\n이 솔루션은 각 층을 추가하거나 제거할 때마다 고난을 겪지 않도록 해줍니다. 화면을 다시 렌더링하고 대부분의 유효성 검사 코드를 직접 작성하지 않아도 되도록 캡슐화되어 있습니다.\n\n\n\n작은 상태를 공유할 수 있는 상태 솔루션이 있습니다.\n\n귀하의 사용 사례가 독특한 점은 무엇이며, 어떤 점을 연결하려고 하고 계십니까? 애니메이션 조율이 포함되어 있습니까? 그 중 어떤 솔루션이 귀하의 사용 사례에 완벽하거나 거의 완벽하게 맞나요?\n\n데이터를 처리할 수 있는 가벼운 상태 솔루션이 있습니다.\n\n또한 기본으로 캐싱을 지원하며 통합하는 데 1분만 걸립니다. 최대한 빨리 목표를 달성하기 위해 최소한으로 노력할 수 있는 것은 무엇일까요. 이는 성의 없는 일을 하도록 장려하는 것이 아닙니다.\n\n\n\n리액트의 가장 역동적인 측면 중 하나입니다.\n\n다른 사람들도 같은 문제에 부딪혔고 그 후 오픈 소스 라이브러리를 만들었으며, 다른 사람들이 차후에 기여함으로써 궁극적으로 당신이 가장 많은 혜택을 누릴 수 있게 되었습니다.\n\n정말 놀랍다는 것에 대해 잠시 생각해 보세요.\n\n리액트는 10년이 넘는 시간 동안 존재해 왔으며 아직도 브라우저를 위한 최고의 인터페이스 도구로 남아 있습니다. 당신의 문제에 도전한 사람이 있고 그의 해결책이 npm 라이브러리로 확장되었을 가능성이 아주 높습니다.\n\n\n\n\n네, 라이브러리를 설계할 때 사용 사례가 심각하게 고려되었는지 알아야 합니다.\n\n네, 라이브러리가 여전히 유지보수되고 프로젝트 기간 동안 계속 사용될지 평가해야 합니다.\n\n네, 라이브러리 패턴이 코드베이스 전반에 퍼지는 과정을 평가해야 합니다.\n\n수 시간의 연구와 평가는 귀하에게 주간의 머리 아픔을 덜어줄 것입니다. 도움이 되었나요?\n\n\n\n이 문제를 해결하려고 하는 건 무엇인가요?\n잘 모르겠더라도 걱정하지 마세요. 이 질문이 당신이 처음부터 잘못된 상태 라이브러리를 선택하고 그에 따라 큰 규모로 이어지는 엄청난 비용을 피할 수 있게 해줄 거예요. 실제로 쉽게 되돌아설 수 없게 되서 자신의 하우스 오브 카드를 그 기반 위에 쌓으신 후에 그게 어려운 상황으로 변해버리는 걸 방지할 거예요.\n\n자신의 사용 사례를 정의하고\n해결 방법을 찾기 전에\n\n\n\n코딩하기 전에 조심해! \n\n멍청한 실수는 피해야 해. 준비가 되어 있고 빨리 움직일 수 있는 자세가 필요해.\n\n그렇지 않으면 비용이 발생할 거야.","ogImage":{"url":"/assets/img/2024-05-12-Ismystateinreactgoingtocostme_0.png"},"coverImage":"/assets/img/2024-05-12-Ismystateinreactgoingtocostme_0.png","tag":["Tech"],"readingTime":3},{"title":"풀 스택 튜토리얼 React와 NodejsAWS S3에서 사전 서명된 URL로 안전한 파일 업로드하기","description":"","date":"2024-05-12 19:03","slug":"2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3","content":"\n\n안녕하세요! 안전한 파일 업로드 시스템을 구축하는 방법에 대한 포괄적인 자습서에 오신 것을 환영합니다. 이 가이드에서는 React 프런트엔드 설정부터 Node.js 백엔드(Express 사용) 생성 및 안전한 저장소로 AWS S3를 활용하는 전체 프로세스를 안내해 드릴 것입니다.\n\n![이미지](/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png)\n\n## 왜 Presigned URLs를 사용해야 하는가?\n\n기존 파일 업로드 시스템에서는 클라이언트가 서버를 통해 파일을 전달하고, 서버가 해당 파일을 저장소에 업로드하는 방식으로 작동합니다. 이 방법은 작동은 하지만 대용량 파일 처리 시 효율적이거나 안전하지 않을 수 있습니다. 여기서 Presigned URLs가 등장합니다.\n\n\n\n**사전 서명된 URL**을 사용하면 클라이언트가 스토리지 제공 업체, 이 경우 AWS S3와 직접 상호 작용할 수 있습니다. 백엔드는 클라이언트에게 시간 제한이 있는 안전한 링크인 사전 서명된 URL을 생성하여 전달합니다. 클라이언트는 서버가 파일 데이터를 처리하지 않고도 파일을 S3에 직접 업로드할 수 있습니다. 이는 서버 부하를 줄이는 것뿐만 아니라 스토리지 자격 증명의 노출을 제한하여 보안을 강화하는 데 도움이 됩니다.\n\n## 사용된 기술\n\n프론트엔드: React, 백엔드: Node.js와 Express, 스토리지: AWS S3.\n\n## 앞으로의 여정\n\n\n\n이 강좌에는 프론트엔드, 백엔드 및 AWS S3 세 가지 주요 섹션이 있습니다.\n먼저 프론트엔드 설정부터 시작하여 React 및 AWS S3의 사전 서명 된 URL을 사용하여 강력한 파일 업로드 솔루션을 구축해 보겠습니다!\n\n# 프론트엔드 설정-( 파트 1 )\n\n## 단계 1: React 앱 설정\n\n먼저 Create React App을 사용하여 새 React 앱을 만들어 보겠습니다:\n\n\n\n```js\nnpx create-react-app presigned-url-upload\ncd presigned-url-upload\n```\n\n## 단계 2: 종속 항목 설치\n\n파일 업로드 처리를 위해 필요한 패키지를 설치하세요:\n\n```js\nnpm install aws-amplify aws-amplify-react axios react-dropzone\n```\n\n\n\n## 단계 3: AWS Amplify 구성\n\n프로젝트에 AWS Amplify를 초기화합니다:\n\n```js\namplify init\n```\n\n## 단계 4: FileUpload 컴포넌트 생성\n\n\n\n새로운 FileUpload.js 컴포넌트를 생성하여 파일 업로드를 처리하세요. 파일 선택을 간단하게 하기 위해 react-dropzone 라이브러리를 사용할 거에요:\n\n```js\n// FileUpload.js\nimport React, { useCallback } from 'react';\nimport { useDropzone } from 'react-dropzone';\n\nconst FileUpload = ({ onFileSelected }) =\u003e {\n  const onDrop = useCallback((acceptedFiles) =\u003e {\n    onFileSelected(acceptedFiles[0]);\n  }, [onFileSelected]);\n\n  const { getRootProps, getInputProps } = useDropzone({ onDrop });\n\n  return (\n    \u003cdiv {...getRootProps()} className=\"dropzone\"\u003e\n      \u003cinput {...getInputProps()} /\u003e\n      \u003cp\u003e여기로 파일을 드래그하거나 클릭하여 파일을 선택하세요\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default FileUpload;\n```\n\n## 단계 5: 사전 서명 URL 로직 구현\n\n백앤드로부터 사전 서명 URL을 가져오는 서비스를 생성하세요. api.js 파일을 업데이트하세요:\n\n\n\n```js\n// api.js\nimport axios from 'axios';\n\nconst API_BASE_URL = 'http://localhost:3001'; // 귀하의 백엔드 서버 URL로 변경해주세요\n\nexport const getPresignedUrl = async (fileName) =\u003e {\n  try {\n    const response = await axios.post(`${API_BASE_URL}/getPresignedUrl`, {\n      fileName,\n    });\n    return response.data.url;\n  } catch (error) {\n    console.error('사전 서명된 URL을 가져오는 중 오류 발생:', error);\n    throw error;\n  }\n};\n```\n\n## 단계 6: 파일 업로드 및 사전 서명된 URL 로직 통합\n\n메인 컴포넌트(App.js)를 업데이트하여 파일 업로드 컴포넌트와 사전 서명된 URL 로직을 통합하세요:\n\n```js\n// App.js\nimport React from 'react';\nimport FileUpload from './FileUpload';\nimport { Storage } from 'aws-amplify';\nimport { getPresignedUrl } from './api';\n\nconst App = () =\u003e {\n  const handleFileUpload = async (file) =\u003e {\n    try {\n      const presignedUrl = await getPresignedUrl(file.name);\n\n      // 사전 서명된 URL을 사용하여 파일을 S3에 업로드\n      await Storage.put(file.name, file, {\n        contentType: file.type,\n        customPrefix: { public: 'public/' },\n        level: 'public',\n      });\n\n      console.log('파일이 성공적으로 업로드되었습니다!');\n    } catch (error) {\n      console.error('파일 업로드 처리 중 오류 발생:', error);\n    }\n  };\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003ch1\u003eAWS S3와 함께 사전 서명된 URL 파일 업로드\u003c/h1\u003e\n      \u003cFileUpload onFileSelected={handleFileUpload} /\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n\n\n# 백엔드 설정 - (파트 2)\n\n## 단계 1: Node.js 프로젝트 설정\n\n이제 백엔드 설정으로 전환해 볼까요? 백엔드를 위한 새 디렉토리를 만들어보세요:\n\n```js\nmkdir backend\ncd backend\nnpm init -y\nnpm install express aws-sdk\n```\n\n\n\n## 단계 2: AWS SDK 구성하기\n\nAWS SDK를 구성하기 위해 awsConfig.js라는 새 파일을 생성하세요. `YOUR_ACCESS_KEY`와 `YOUR_SECRET_KEY`를 여러분의 AWS 액세스 키와 시크릿 키로 교체하세요. `YOUR_ACCESS_KEY`와 `YOUR_SECRET_KEY`를 어떻게 생성하는 지는 이후 Part -3에서 다룰 예정입니다.\n\n```js\n// awsConfig.js\nconst AWS = require('aws-sdk');\n\nAWS.config.update({\n  accessKeyId: 'YOUR_ACCESS_KEY',\n  secretAccessKey: 'YOUR_SECRET_KEY',\n  region: 'us-east-1', // 원하는 지역으로 교체하세요\n});\n\nmodule.exports = AWS;\n```\n\n## 단계 3: Express 서버 생성하기\n\n\n\n새 파일을 만들어서 server.js라고 이름 짓고 Express 서버를 설정하고 사전 서명된 URL 요청을 처리하세요.\n\n```js\n// server.js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst { S3 } = require('./awsConfig');\n\nconst app = express();\nconst PORT = 3001;\n\napp.use(bodyParser.json());\n\n// 실제 S3 버킷 이름으로 'your-bucket-name'을(를) 바꿔주세요.\nconst BUCKET_NAME = 'your-bucket-name';\n\napp.post('/getPresignedUrl', (req, res) =\u003e {\n  const { fileName } = req.body;\n\n  const s3 = new S3();\n  const params = {\n    Bucket: BUCKET_NAME,\n    Key: fileName,\n    ContentType: 'application/octet-stream', // 파일 유형에 따라 콘텐츠 유형을 조정하세요\n    Expires: 60, // 사전 서명 URL 만료 시간(초) 설정\n  };\n\n  s3.getSignedUrl('putObject', params, (err, url) =\u003e {\n    if (err) {\n      console.error('사전 서명된 URL 생성 중 오류 발생:', err);\n      return res.status(500).json({ error: '사전 서명된 URL 생성 실패' });\n    }\n\n    res.json({ url });\n  });\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n});\n```\n\n## 단계 4: 백엔드 서버 시작하기\n\n다음 명령을 사용하여 백엔드 서버를 실행하세요.\n\n\n\n```js\nnode server.js\n```\n\n서버가 http://localhost:3001에서 실행 중이에요. 서버 파일에서 `your-bucket-name`을 실제 S3 버킷 이름으로 교체해주세요.\n\n# AWS S3 설정 - 3부\n\n## 단계 1: AWS 계정 생성하기\n\n\n\nAWS 계정이 없으신 경우, 새로 만드셔야 해요. AWS 가입 페이지로 이동하여 계정을 생성해보세요.\n\n## 단계 2: AWS 관리 콘솔에 액세스하기\n\nAWS 관리 콘솔에 로그인해주세요.\n\n## 단계 3: S3으로 이동하기\n\n\n\nAWS 관리 콘솔에서 \"서비스\" 드롭다운을 찾아 클릭해주세요. \"저장소\" 아래에서 \"S3\"를 클릭하여 간편 저장소 서비스에 액세스할 수 있어요.\n\n## 단계 4: 새 버킷 만들기\n\n- S3 대시보드에서 \"버킷 생성\" 버튼을 클릭해주세요.\n\n2. 버킷 구성:\n- 이름과 지역: 버킷에 전 세계적으로 고유한 이름을 선택해주세요. 이름은 DNS 호환성이 있어야하며 선택한 이름이 이미 사용 중이면 AWS가 알려줄 거예요. 사용자에게 더 나은 대기 시간을 제공하기 위해 지리적으로 가장 가까운 지역을 선택해주세요.\n- 저장 클래스: 요구 사항에 따라 저장 클래스를 선택해주세요. 일반 목적 저장소에 대한 기본 설정이 일반적으로 적합합니다.\n\n\n\n3. 설정 옵션 구성하기 (선택사항):\n- 사용자의 선호 및 프로젝트 요구에 맞게 버전 관리, 로깅 및 태그 설정을 구성합니다.\n\n4. 권한 설정:\n- 버킷에 액세스할 수 있는 사용자를 정의합니다. 간단히 하려면 현재 기본 설정을 유지할 수 있습니다.\n\n5. 검토:\n- 설정을 검토하고 \"버킷 생성\" 버튼을 클릭합니다.\n\n## 단계 5: 버킷 정책 (선택사항)\n\n\n\n만약 테스트 목적으로 버킷을 공개하려면 공개 액세스를 허용하는 버킷 정책을 추가할 수 있습니다. 그러나 프로덕션 환경에서는 권장되지 않으므로 데이터 노출의 위험이 있습니다.\n\n- 버킷의 \"Permissions\" 탭으로 이동합니다.\n- \"Bucket Policy\"를 클릭하고 아래와 유사한 정책을 추가합니다. your-bucket-name을 실제 버킷 이름으로 바꿔주세요.\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::your-bucket-name/*\"\n    }\n  ]\n}\n```\n\n필요에 따라 권한을 조정하여 사용 사례에 맞게 설정하세요.\n\n\n\n## 6단계: 액세스 자격 증명\n\nS3 버킷과 프로그래밍적으로 상호 작용하려면 AWS 액세스 키와 비밀 키 자격 증명이 필요합니다.\n\n- AWS 관리 콘솔에서 “Services\"를 선택한 후 “IAM\"(Identity and Access Management)을 클릭합니다.\n- IAM 대시 보드에서 왼쪽 탐색 창에서 “Users\"를 클릭합니다.\n- 새 사용자를 만들려면 “Add user\"를 클릭합니다. 사용자 이름을 제공하고 “Programmatic access\"를 선택합니다.\n- 사용자에게 “AmazonS3FullAccess\" 정책을 부여합니다 (또는 필요에 따라 더 제한적인 정책을 선택할 수 있습니다).\n- 사용자를 검토하고 만듭니다. 제공된 액세스 키 ID와 비밀 액세스 키를 저장하세요. 이러한 자격 증명을 안전하게 보관하세요.\n\n이제 AWS에서 S3 버킷을 성공적으로 설정했으며 애플리케이션과 통합하거나 S3 저장소를 활용한 자습서를 따라 진행할 준비가 되었습니다.\n\n\n\n# 결론\n\n축하합니다! 안전하게 파일을 AWS S3에 업로드하기 위한 프로젝트의 전체적인 솔루션을 성공적으로 구현했습니다. 이 튜토리얼에서는 React 프론트엔드와 Node.js 백엔드를 AWS S3와 함께 설정하는 방법을 다뤘습니다. 코드를 프로젝트 요구에 맞게 사용자 정의하고, 안전한 파일 업로드 시스템을 배포할 준비가 된 것입니다. 즐거운 코딩하세요.....","ogImage":{"url":"/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png"},"coverImage":"/assets/img/2024-05-12-FullStackTutorialSecureFileUploadwithPresignedURLsinReactandNodejsAWSS3_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개","description":"","date":"2024-05-12 19:02","slug":"2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache","content":"\n\n# TL;DR\n\nuseFetchCache 훅은 React 애플리케이션의 데이터 가져오기, 캐싱 및 업데이트를 간단하게 만들기 위해 설계된 사용자 정의 훅입니다. 네트워크 요청을 로컬 캐싱과 원활하게 통합함으로써, 빈번한 액세스가 필요하지만 자주 변경되지 않는 데이터를 처리하는 효율적인 방법을 제공합니다.\n\n## React 컴포넌트에서 같은 데이터를 계속해서 가져오는 것에 지쳤습니까?\n\nuseFetchCache를 만나보세요! 데이터 가져오기와 캐싱의 슈퍼히어로! 🦸‍♂️\n\n\n\nuseFetchCache는 데이터 가져오기를 간편하게 만들어 주는 커스텀 React 훅이에요. 개인 비서처럼 작동하여 필요한 모든 것을 기억해 주어서 매번 요청할 필요가 없어요. 반복적인 데이터 가져오기 로직 작성이나 여러 개의 로딩 및 오류 상태를 처리하는 번거로움도 없어요. 😌\n\nuseFetchCache를 사용하면 API URL과 필요한 매개변수를 제공하고, 후는 모두 맡기면 돼요. 데이터를 가져오고 로딩 상태를 처리하며, AsyncStorage를 사용하여 결과를 로컬로 캐싱해요. 이렇게 하면 같은 데이터에 대한 후속 요청은 캐시에서 제공되어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있어요. ⚡\n\n하지만 여기서 끝이 아니에요! useFetchCache에는 다시 불러오는 함수가 제공되어 데이터를 필요할 때마다 새롭게 불러올 수 있어요. 사용자 상호작용이나 주기적인 업데이트 때문이더라도 useFetchCache가 항상 도와줄 거예요. 🔄\n\n그러니 React 컴포넌트를 강화하고 데이터 가져오기 프로세스를 간소화하려면 useFetchCache가 여러분의 새로운 친구가 될 거에요. 이 슈퍼히어로 훅으로 무거운 작업을 처리하고 사용자들을 위한 놀라운 경험을 만드는 데 집중할 수 있도록 해 주세요. 💯\n\n\n\nuseFetchCache를 통해 매끄러운 데이터 가져오기와 캐싱의 마법을 경험할 준비가 되셨나요? 🚀✨\n\n## useFetchCache란?\n\nuseFetchCache는 API에서 데이터를 가져오는 과정을 자동화하고, 그 데이터를 로컬 저장소(AsyncStorage 사용)에 저장하며, 이후 요청에서 해당 데이터를 불러오는 React의 커스텀 훅입니다. 이 훅은 데이터 가져오기, 캐싱, 오류 관리를 처리하고, 강제 데이터 새로고침을 허용합니다.\n\n## useFetchCache 사용의 장점\n\n\n\n- 네트워크 호출 감소: 데이터를 로컬로 캐싱함으로써 애플리케이션에서 만드는 API 요청 수가 줄어들어 모바일 데이터 사용 및 제한적이거나 고비용의 연결 환경에서 특히 유용합니다.\n- 성능 향상: 데이터를 로컬로 캐싱하면 데이터 검색 시간이 빨라지며, 데이터가 대부분 로컬 저장소에서 즉시 사용 가능하기 때문에 서버로의 왕복을 필요로하지 않습니다.\n- 사용자 경험 향상: 사용자들은 빠른 로드 시간과 더 빠른 반응이 가능한 인터페이스를 경험할 수 있으며, 데이터가 빠른 액세스 로컬 캐시에서 로드되기 때문입니다.\n- 간편화된 데이터 관리: 훅은 데이터 가져오기, 캐싱 및 오류 처리를 캡슐화하여 구성 요소 코드를 단순화합니다.\n\n# useFetchCache 사용 방법\n\n- 훅 가져오기: React 컴포넌트 파일에 useFetchCache를 가져와서 시작합니다.\n- 훅 초기화: 필요한 매개변수(API URL 및 선택적으로 기본 캐시 키 및 만료 시간)를 사용하여 useFetchCache를 호출합니다. 특정 키가 제공되지 않으면 URL도 캐시 키로 사용할 수 있습니다.\n- 데이터 표시: 훅이 반환하는 데이터 상태를 사용하여 컴포넌트에서 데이터를 표시합니다. 사용자에게 피드백을 제공하기 위해 필요한대로 로딩 상태 및 오류를 처리하세요.\n- 새로 고침 및 페이지네이션 구현: 필요한 경우 신선한 데이터가 필요한 시나리오에 대비해 훅이 제공하는 refetch 메서드를 사용하고, API에서 지원하는 경우 API URL 또는 내부 상태를 조정하여 페이지네이션을 관리하세요.\n- 코드 배치: 훅은 컴포넌트 함수 상단에 배치되어야 하며, 조건문이나 반복문 외부에 위치하여 훅의 규칙을 준수해야 합니다.\n\n## 이것이 바로 훅입니다…\n\n\n\n```js\n// useFetchCache.js\n\nimport { useState, useEffect, useCallback } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport axios from 'axios';\n\n/**\n * AsyncStorage를 사용하여 데이터를 가져와 캐싱하는 커스텀 훅입니다. 옵션으로 강제 새로고침이 가능합니다.\n * \n * @param {string} url - 데이터를 가져올 API URL입니다.\n * @param {string} [baseCacheKey=null] - 데이터를 저장하는 기본 캐시 키입니다. 제공되지 않으면 URL이 기본값으로 사용됩니다.\n * @param {number} [expirationTime=3600000] - 캐시 만료까지의 밀리초 단위 시간입니다 (기본값은 1시간).\n * @return {Object} 데이터, 로딩 상태, 오류 및 리페치 함수를 포함한 객체입니다.\n */\nconst useFetchCache = (url, baseCacheKey = null, expirationTime = 1000 * 60 * 60) =\u003e {\n  // 제공된 baseCacheKey 또는 URL을 사용하여 캐시 키를 구성합니다.\n  const cacheKey = `${baseCacheKey ? baseCacheKey : encodeURIComponent(url)}`;\n\n  // 데이터, 로딩 상태, 오류를 관리하는 상태 훅입니다.\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // 데이터를 가져오는 함수로, 옵션으로 캐시를 무시할 수 있습니다.\n  const fetchData = async (forceFetch = false) =\u003e {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const storedDataString = await AsyncStorage.getItem(cacheKey);\n\n      // 강제 새로고침하지 않고 캐시가 있고 유효한 경우 캐시된 데이터를 사용합니다.\n      if (!forceFetch \u0026\u0026 storedDataString) {\n        const storedData = JSON.parse(storedDataString);\n        const now = Date.now();\n        if (now - storedData.timestamp \u003c expirationTime) {\n          console.log(\"캐시로부터 데이터를 제공합니다 for key:\", cacheKey);\n          setData(storedData.data);\n          return;\n        }\n      }\n\n      // 강제 새로고침이거나 캐시가 만료된 경우 또는 캐시가 없는 경우 API에서 데이터를 가져옵니다.\n      console.log(\"API로부터 데이터를 가져옵니다 for URL:\", url);\n      const response = await axios.get(url);\n      const newData = response.data;\n      setData(newData);\n      await AsyncStorage.setItem(cacheKey, JSON.stringify({\n        data: newData,\n        timestamp: Date.now(),\n      }));\n    } catch (err) {\n      console.error(\"데이터를 가져오는 중 오류가 발생했습니다:\", err);\n      setError(err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // 캐시를 무시하여 데이터를 강제로 다시 가져오는 함수입니다.\n  const refetch = useCallback(() =\u003e {\n    console.log(\"캐시를 무시하고 데이터를 다시 가져옵니다...\");\n    fetchData(true);\n  }, [url, cacheKey]);\n\n  // URL이나 cacheKey가 변경될 때 데이터를 가져오는 효과입니다.\n  useEffect(() =\u003e {\n    fetchData();\n  }, [url, cacheKey]);\n\n  return { data, isLoading, error, refetch };\n};\n\nexport default useFetchCache;\n```\n\n## 그리고 여기에 샘플 사용법이 있습니다...\n\n```js\n// DataFetchingComponent.js \n\nimport React from 'react';\nimport { View, Text, ActivityIndicator, Button } from 'react-native';\nimport useFetchCache from './useFetchCache'; // useFetchCache가 정의된 파일로 올바르게 지정하세요.\n\nconst DataFetchingComponent = () =\u003e {\n  // 데이터를 가져올 URL입니다.\n  const url = \"https://api.example.com/data\";\n\n  // URL을 사용하여 훅을 초기화합니다. baseCacheKey를 제공하지 않으면 URL이 자동으로 캐시 키로 사용됩니다.\n  const { data, isLoading, error, refetch } = useFetchCache(url);\n\n  // 사용자가 \"새로고침\" 버튼을 누를 때 새로 고침 동작을 처리합니다.\n  const handleRefresh = () =\u003e {\n    refetch(); // 훅에서 제공하는 refetch 함수를 호출하여 데이터를 강제로 다시 가져옵니다.\n  };\n\n  // 데이터를 가져오는 동안 로딩 표시줄을 렌더링합니다.\n  if (isLoading) return \u003cActivityIndicator size=\"large\" color=\"#0000ff\" /\u003e;\n\n  // 데이터를 가져오는 동안 오류가 발생하면 오류 메시지를 렌더링합니다.\n  if (error) return \u003cText\u003eError: {error.toString()}\u003c/Text\u003e;\n\n  // 가져온 데이터 또는 가져온 데이터가 없을 경우 메시지를 렌더링합니다.\n  return (\n    \u003cView style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}\u003e\n      \u003cText\u003eData: {data ? JSON.stringify(data) : '데이터 없음'}\u003c/Text\u003e\n      \u003cButton title=\"데이터 새로고침\" onPress={handleRefresh} color=\"#0000ff\" /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default DataFetchingComponent;\n```\n\n# 주요 내용\n\n\n\n- 일관성이 중요합니다: 항상 동일한 데이터 집합에 대해 동일한 캐시 키를 사용하여 응용 프로그램 전체의 일관성을 보장하세요.\n- 오류 처리를 세련되게: 데이터 가져오기에서 발생하는 오류를 세련되게 처리하여 사용자 경험을 개선하세요.\n- 캐시 정기적으로 업데이트: 캐시된 데이터에 적절한 만료 시간을 설정하고 주기적으로 또는 사용자 요구에 따라 캐시를 업데이트하는 refetch 함수를 사용하세요.\n\n# 결론\n\nReact 애플리케이션에서 useFetchCache 훅을 사용하면 데이터 처리를 최적화할 수 있습니다. 반복적이고 비용 소모적인 네트워크 요청이 줄어들며 데이터 로드 시간을 단축하고 구성 요소에서의 데이터 관리를 간단하게 할 수 있습니다. 이 훅을 통합함으로써 개발자들은 좋은 기능을 개발하는 데 더 집중할 수 있고 데이터 가져오기와 상태 관리의 복잡성에 대해 덜 걱정해도 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png","tag":["Tech"],"readingTime":7},{"title":"웹 성능 최적화 Tree Shaking 설명","description":"","date":"2024-05-12 19:01","slug":"2024-05-12-OptimizingWebPerformanceTreeShakingExplained","content":"\n\n📝 이 블로그에서는 웹 개발에서 중요한 프로세스인 Tree Shaking의 개념을 자세히 살펴볼 것입니다. Tree shaking을 이해하는 것은 코드의 성능을 최적화하고 최종 제품에 필요한 부분만 포함되도록 보장하는 데 중요합니다. 🕵️‍♀️ 이 기술이 무엇이며, 효율적이고 간소화된 애플리케이션을 만드는 데 왜 중요한지 알아보겠습니다.\n\n🤔 먼저 Tree Shaking이 무엇인지 정의해 보겠습니다.\n\n💡 TREE SHAKING은 JavaScript에서 사용되는 기술로, 번들링 프로세스 중에 번들에서 사용되지 않는 코드나 모듈을 제거하는 데 사용됩니다. Tree shaking은 일반적으로 JavaScript 기반 개발의 번들링 프로세스의 일부입니다. JavaScript 코드를 번들링할 때 여러 파일을 최적화된 상태로 묶어 브라우저로 전달하는 것입니다.\n\n📚 여기서 읽기: 번들링: 웹 성능 최적화\n\n\n\n🤯 이 예제를 통해 이해해 봅시다.\n\n😀 코드의 큰 트리와 (사용되지 않는 코드인) 가지들이 그것을 무겁게 만든다고 상상해보세요. (즉, 웹 앱 성능을 낮춥니다). Tree shaking은 그 가지를 흔들어서 불필요한 가지들을 놓아버리는 것과 같습니다. 이를 통해 코드를 가볍고 빠르게 만들어줍니다. 🫡\n\n지금 코드로 더 잘 이해해 봅시다 🤩\n\n```js\nexport function add(num1, num2){\n  return num1 + num2;\n}\n\nexport function sub(num1, num2){\n  return num1 - num2;\n}\n\nexport function mul(num1, num2){\n  return num1 * num2;\n}\n\nexport function div(num1, num2){\n  return num1 / num2;\n}\n```\n\nMain.js\n\n```js\nimport { mul, add } from './Operators';\n\nconsole.log(mul(3, 8));\n\nconsole.log(add(55, 23));\n```\n\n🔥 When all these files are bundled together, Here is the final bundled code\n\n\n\n\n```js\n// 번들된 연산자\n\nexport function add(num1, num2) {\n  return num1 + num2;\n}\n\nexport function mul(num1, num2) {\n  return num1 * num2;\n}\n\nconsole.log(mul(3, 8));\nconsole.log(add(55, 23));\n```\n\n여기서 sub, div 함수는 우리 애플리케이션에서 사용되지 않으므로 최종 번들에서 제외됩니다. 이는 번들링 프로세스 중에 수행되는 트리 쉐이킹 기술에 의해 수행됩니다.\n\n🤨 알겠어! 하지만 함수가 사용자 입력 [즉, 동적 사용자 입력]에 의존하는 경우 어떻게 되나요? 트리 쉐이킹 기술은 여전히 사용되지 않는 함수의 사용을 제거할까요?\n\n👉 여러 함수가 사용자 입력에 종속되는 시나리오에서는 트리 쉐이킹이 도전을 겪을 수 있으며 효과가 덜 할 수 있습니다. 사용자 입력은 실행 시간까지 알 수 없기 때문에 빌드 도구는 번들에 모든 잠재적으로 관련 있는 함수를 포함할 수 있습니다. 이러한 동적 사용자 의존성의 특성은 트리 쉐이킹이 효과적으로 최적화하는 것을 어렵게 만들며, 개발자들은 이러한 경우에 코드 분할 또는 지연 로딩과 같은 대체 전략을 고려해야 할 수 있습니다.\n\n\n\n\n```js\n// Module A\nexport function add(num1, num2) {\n  return num1 + num2;\n}\n\n// Module B\nexport function multiply(num1, num2) {\n  return num1 * num2;\n}\n\n// Main application file\nimport { add, multiply } from './modules';\n\n// User input\nconst userInput = prompt('더하기는 1을 입력하고, 곱하기는 2를 입력하세요:');\n\nlet result;\n\nif (userInput === '1') {\n  result = add(3, 4);\n} else if (userInput === '2') {\n  result = multiply(3, 4);\n}\n\nconsole.log(result);\n```\n\n이 시나리오에서 사용자의 입력에 따라 'add' 또는 'multiply' 함수가 동적으로 호출되므로 빌드 과정 중 tree shaking이 도전적입니다. Tree shaking을 적용해도 사용자 입력의 동적 성향으로 인해 두 함수 모두 최종 번들에 포함될 수 있으므로 최적의 성능을 위해 개발자가 코드 분할 또는 지연 로딩과 같은 대안을 고려해야 합니다.\n\n😀 장점\n1. 번들 크기 축소: 작은 번들은 사용자에게 빠른 다운로드를 제공하여 페이지 로드 시간을 개선합니다.\n2. 대역폭 절약: 작은 번들은 네트워크를 통해 전송하는 데 더 적은 대역폭이 필요해 호스팅 비용을 절감하고 웹 응용 프로그램의 전반적인 효율성을 향상시킵니다.\n\n🫣 단점\n1. 동적 사용자 입력, 조건부 로딩 등에서 효과적이지 않을 수 있음.\n2. 응용 프로그램이 동적 가져오기와 라이브러리 또는 프레임워크가 완전히 호환되지 않을 때 예기치 않은 동작이 발생할 수 있습니다.\n\n\n\n💡 결론: 트리 쉐이킹은 자바스크립트에서 사용되지 않는 코드를 번들링 프로세스 중에 제거하는 가치 있는 기술로, 더 작은 번들과 향상된 응용프로그램 성능을 이끌어냅니다. 그러나 동적 사용자 입력, 조건부 로딩 및 특정 라이브러리 또는 프레임워크와의 호환성 문제와 관련하여 그 효과는 손상될 수 있으며, 개발자들이 대체 최적화 전략을 주의 깊게 고려해야 합니다.\n\n📚 이전 포스트:\n\n👉 NPM이 무엇인가요?\n👉 의미 있는 버전 관리 해부\n👉 Dependencies, DevDependencies 및 PeerDependencies\n👉 로컬 대 글로벌 패키지\n👉 번들링: 웹 성능 최적화 방법\n\n🔍 다음은:\n\n\n\n👉 최소화, 검사\n👉 코드 분할, 지연 로딩\n\n더 많은 ReactJs 개발에 대한 통찰력을 기대해주세요! 🚀📦","ogImage":{"url":"/assets/img/2024-05-12-OptimizingWebPerformanceTreeShakingExplained_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingWebPerformanceTreeShakingExplained_0.png","tag":["Tech"],"readingTime":4},{"title":"실제 사용자 모니터링RUM","description":"","date":"2024-05-12 19:00","slug":"2024-05-12-RealUserMonitoringRUM","content":"\n\n애플리케이션의 최종 사용자 경험을 추적하고 측정합니다. 앱 성능 및 API 호출에 소요된 시간을 파악합니다. 웹사이트의 최종 사용자 경험을 향상시키는 데 도움이 되는 실행 가능한 데이터 중심 세부 정보를 제공합니다.\n\n![이미지](/assets/img/2024-05-12-RealUserMonitoringRUM_0.png)\n\n![이미지](/assets/img/2024-05-12-RealUserMonitoringRUM_1.png)\n\n## APM (Application Performance Monitoring/ Real user monitoring tool)—\n\n\n\n웹 애플리케이션 성능에 대한 통찰력을 얻는 데 도움이 되며 다양한 모니터링 기능을 활용합니다.\n\n- 실시간 가시성 - 응답 시간, 페이지 로드 시간, 페이지 조회수, 처리량 등 주요 지표를 추적하여 웹 사이트의 실시간 성능을 간단히 확인할 수 있습니다.\n- 지리별 사용자 경험 - 세계지도상에서 각 나라별로 웹 사이트의 성능을 시각화하여 웹 사이트 성능에 영향을 받고 있는 위치를 빠르게 파악할 수 있습니다. 응답 시간, 오류 횟수, 처리량을 분석하여 사용자가 영향을 받고 있는 지역 확인 가능합니다.\n\n![웹사이트 성능 모니터링](/assets/img/2024-05-12-RealUserMonitoringRUM_2.png)\n\n- 지연 거래 감지 - 웹 사이트의 페이지 조회수와 개별 거래에 대한 오류를 주의 깊게 살펴 잠재적인 문제를 식별할 수 있습니다.\n- 사용자 세션 추적 - 웹 사이트에 연결된 사용자 세션 수를 파악할 수 있습니다. 또한 각 세션의 상태를 파악하여 사용자 세션의 기간과 품질을 결정할 수 있습니다.\n- 스크립트 오류 감지 - 실시간으로 웹 사이트의 성능에 영향을 주는 JS 오류를 식별할 수 있습니다.\n\n\n\n\n![Monitoring solutions such as New Relic come with built-in dashboards. We can also build our own custom dashboards based on the metrics that matters most to us.\nother tools — AppDynamics Browser RUM, Retrace, Datadog](/assets/img/2024-05-12-RealUserMonitoringRUM_3.png)\n\n## How real user monitoring works\n\nReal user monitoring works by injecting code into an application to capture metrics while the application is in use. Client side applications are monitored by injecting Javascript code.\n\n\n\n네이티브 모바일 애플리케이션은 모니터링 라이브러리를 모바일 애플리케이션 패키지에 직접 추가하여 모니터링됩니다.","ogImage":{"url":"/assets/img/2024-05-12-RealUserMonitoringRUM_0.png"},"coverImage":"/assets/img/2024-05-12-RealUserMonitoringRUM_0.png","tag":["Tech"],"readingTime":2},{"title":"React 컴포넌트 라이프사이클 이해하기 React 컴포넌트의 생애 과정을 깊숙히 파헤쳐보기","description":"","date":"2024-05-12 18:58","slug":"2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent","content":"\n\n![image](/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_0.png)\n\n세상에 있는 모든 것은 주기를 따릅니다. 식물이나 동물, 인간 모두가 그렇습니다. 그들은 태어나 성장하고 죽는 과정을 거침으로써 주기를 따르고 있습니다. React 컴포넌트 또한 주기를 따릅니다. 그들은 생성(마운트), 성장(업데이트), 그리고 소멸(언마운트)합니다. 이를 컴포넌트의 생명주기라고 부릅니다.\n\nReact 컴포넌트는 마운트, 업데이트, 언마운트의 세 가지 다른 단계를 가지고 있습니다. 각 단계마다 해당 컴포넌트의 생명주기에서 역할을 하는 특정 메서드가 있습니다. 이 메서드들은 클래스 기반 컴포넌트를 위한 것이며, 함수형 컴포넌트는 자체 생명주기 메서드를 가지고 있습니다.\n\n이 글에서는 React 컴포넌트 생명주기와 각 단계별 다른 메서드에 대해 자세히 알아보게 될 것입니다.\n\n\n\n위의 세 가지 단계를 이루는 메서드에 대해 자세히 알아봅시다.\n\n![이미지](/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_1.png)\n\n# 마운팅 단계\n\n마운팅 단계는 새 컴포넌트가 생성되어 DOM에 삽입되는 시점을 의미하며, 간단히 말해 리액트 컴포넌트의 실제 생애가 시작되는 시점입니다. 이 단계는 한 번만 발생하며, 종종 \"초기 렌더링\"이라고도 불립니다. 이 단계를 통과하기 위해 네 가지 라이프사이클 메서드가 호출됩니다: constructor, static getDerivedStateFromProps, render, 그리고 componentDidMount.\n\n\n\n![React Component Lifecycle](/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_2.png)\n\n생성자 메서드는 마운팅 단계 중에 가장 먼저 호출되는 메서드입니다. 이 메서드는 주로 컴포넌트의 상태를 초기화하고 컴포넌트 내에서 사용할 이벤트 처리기 메서드를 바인딩하는 데 사용됩니다. 생성자 메서드는 컴포넌트가 초기화될 때 호출되지만 렌더링되기 전에 호출됩니다. 컴포넌트에서 상태를 사용하려면 생성자에서 props를 인수로 사용하여 super(props) 함수를 호출하는 것이 중요합니다.\n\n초기화를 마친 후 호출되는 다음 함수는 static getDerivedStateFromProps()입니다. 이 메서드를 사용하면 컴포넌트가 속성 변경에 따라 상태를 업데이트할 수 있습니다. 이 메서드는 매우 드물게 사용되며 많은 오류를 일으킬 수 있으므로 주의해서 사용해야 합니다. 초보자로서는 필요 없고 사용을 피하는 것이 일반적인 규칙입니다.\n\n이 메서드는 상태 값을 속성 값으로 수정하는 데 사용됩니다. static getDerivedStateFromProps() 메서드는 두 개의 인수(props 및 state)를 허용하고 객체를 반환하거나 변경이 필요하지 않은 경우 null을 반환합니다. 이러한 값은 메서드에 직접 전달되므로 클래스의 인스턴스(또는 클래스의 다른 부분)에 액세스할 필요가 없으므로 정적 메서드로 간주됩니다.\n\n\n\n렌더 메소드는 클래스 기반 React 컴포넌트에서 유일하게 필요한 메소드입니다. getDerivedStateFromProps() 메소드 이후에 호출되며 실제로 모든 HTML을 렌더링하거나 삽입합니다.\n\n일반적으로 렌더 메소드는 최종적으로 렌더링될 JSX를 반환하지만, 다른 값을 반환할 수도 있습니다. 렌더 메소드에서는 상태를 수정하거나 브라우저와 직접적인 상호작용을 할 수 없으며 렌더 메소드에서 HTTP 요청을 보내는 것과 같은 부수 효과도 일어낼 수 없습니다. HTML을 작성하는 것으로 생각해보세요. 물론 JSX 형태로요.\n\ncomponentDidMount() 메소드는 컴포넌트가 처음으로 렌더링된 후 즉, 첫 번째 render() 사이클 이후 즉시 실행됩니다. 이 메소드는 API 호출과 같은 모든 네트워크 요청 처리 또는 응용 프로그램의 주요 구독을 설정하는 데 주로 사용됩니다. 일반적으로 componentDidMount()는 DOM 없이 수행 할 수없는 모든 설정을 수행하는 좋은 장소입니다.\n\n저는 버튼을 클릭할 때 카운트를 업데이트하는 간단한 카운터 앱이 있습니다.\n\n\n\n```js\nimport React from \"react\";\n\nclass ComponentDidMount extends React.Component {\n    constructor(props) {\n      super(props);\n      console.log('Constructor called');\n      this.state = {\n        count: 0\n      };\n    }\n  \n    static getDerivedStateFromProps(props, state) {\n      console.log('getDerivedStateFromProps called');\n      return null;\n    }\n  \n    componentDidMount() {\n      console.log('componentDidMount called');\n    }\n  \n    incrementCount = () =\u003e {\n      this.setState(prevState =\u003e ({\n        count: prevState.count + 1\n      }));\n    };\n  \n    render() {\n      console.log('render called');\n      return (\n        \u003cdiv\u003e\n          \u003ch1\u003eCounter App\u003c/h1\u003e\n          \u003cp\u003eCount: {this.state.count}\u003c/p\u003e\n          \u003cbutton onClick={this.incrementCount}\u003eIncrement\u003c/button\u003e\n        \u003c/div\u003e\n      );\n    }\n  }\n  \n  export default ComponentDidMount\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*q1GIAIm6PDfoe5F68vHrvA.gif)\n\n이 예시에서, 내 콘솔은 비어있지만 페이지를 새로고침하면 앱이 다시 렌더링되어 몇 가지 콘솔 메시지가 표시됩니다. 다음은 설명입니다.\n\n- 생성자가 호출되었음을 나타내는 콘솔 메시지가 처음으로 나타납니다. 또한 구성 요소의 상태를 0으로 설정된 count 속성으로 초기화합니다.\n- getDerivedStateFromProps가 호출되었음을 나타내는 두 번째 콘솔 메시지입니다. 그러나 이 특정 예시에서는 null을 반환하므로 프롬프트에 기반한 상태 업데이트가 없음을 나타냅니다.\n- 세 번째로 렌더 함수가 호출되었음을 나타내는 콘솔 메시지입니다. 모든 HTML을 렌더링하고 구성 요소의 상태에서 현재 카운트를 표시하며 incrementCount 메서드를 호출하는 onClick 이벤트 핸들러가 있는 버튼을 표시합니다.\n- componentDidMount가 호출되었음을 나타내는 네 번째 콘솔 메시지입니다.\n- \"Increment\" 버튼을 클릭하면 incrementCount 메서드가 상태를 업데이트하고 React 구성 요소 라이프사이클의 업데이팅 단계를 트리거합니다. 이 단계는 마운팅 단계와 분리된 단계이며 렌더 및 getDerivedStateFromProps와 같은 메서드를 포함합니다.\n\n\n\n# 업데이트 단계\n\n![이미지](/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_3.png)\n\n업데이트 단계는 컴포넌트에 업데이트가 발생하거나 다시 렌더링될 때입니다. 이 단계는 프롭스나 상태가 업데이트될 때 트리거됩니다.\n\n또한 다음 메서드를 포함하는 컴포넌트일 때도 트리거될 수 있습니다:\n\n\n\ngetDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate(), 그리고 componentDidUpdate().\n\ngetDerivedStateFromProps()와 render()는 이전에 다루어졌으므로, 이 섹션에서는 다른 세 가지 메서드에 초점을 맞춥니다.\n\n이것도 또 다른 거의 사용되지 않는 라이프사이클 메서드입니다. 성능 최적화를 위해 특별히 사용됩니다. 이 메서드를 사용하면 컴포넌트가 프롭스나 상태의 변경으로 인해 업데이트 되어야 하는지 여부를 제어할 수 있습니다. 기본적으로 컴포넌트는 상태나 프롭이 업데이트되면 항상 다시 렌더링됩니다. 이 메서드는 컴포넌트가 업데이트되어야 하는지 여부를 결정하기 위해 true 또는 false를 반환할 수 있습니다. 또한 이 메서드는 nextProps와 nextState를 인수로 받기 때문에 항상 컴포넌트의 현재 프롭 및 상태 값을 비교할 수 있습니다.\n\ngetSnapshotBeforeUpdate() 메서드는 현재 업데이트의 변경 사항이 DOM에 적용되기 직전에 호출됩니다. 이 메서드에서 반환하는 값은 componentDidUpdate() 메서드의 세 번째 매개변수로 전달됩니다. 이 메서드는 render 메서드 이후에 호출되고 componentDidUpdate 이전에 호출됩니다. 또한 이것도 거의 사용되지 않는 메서드 중 하나입니다.\n\n\n\n이 방법은 이 단계에서 마지막으로 호출되는 메서드입니다. 이전 방법과 마찬가지로 이전 props 및 state 값을 인수로받지만 반환값 getSnapshotBeforeUpdate()도 세 번째 인수로 받습니다(있는 경우).\n\n일반적으로 이전 및 현재 props 및 state 값을 비교하는 조건에 따라 더 많은 fetch 요청을 만들기 위해 사용됩니다. 따라서 setState를 호출할 수 있지만 조건문 내에 있어야 합니다.\n\n```js\nimport React from \"react\";\n\nclass UpdatingExample extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        name: 'John',\n        changed: false\n      };\n      console.log('Constructor called');\n    }\n  \n    static getDerivedStateFromProps(props, state) {\n      console.log('getDerivedStateFromProps called');\n      return null;\n    }\n  \n    shouldComponentUpdate(nextProps, nextState) {\n      console.log('shouldComponentUpdate called');\n      return true;\n    }\n\n    getSnapshotBeforeUpdate(nextProps, nextState) {\n        console.log('getSnapshotBeforeUpdate called');\n        return null;\n    }\n  \n    componentDidUpdate(prevProps, prevState) {\n      console.log('componentDidUpdate called');\n    }\n  \n    changeName = () =\u003e {\n      this.setState({\n        name: 'Jane',\n        changed:true\n      });\n    };\n  \n    render() {\n      console.log('render called');\n      return (\n        \u003cdiv\u003e\n          \u003ch1\u003eUpdating Example\u003c/h1\u003e\n          \u003cdiv\u003eName {this.state.changed ? \u003ch3\u003e{this.state.name}\u003c/h3\u003e: \u003cp\u003e{this.state.name}\u003c/p\u003e}\u003c/div\u003e\n          \u003cbutton onClick={this.changeName}\u003eChange Name\u003c/button\u003e\n        \u003c/div\u003e\n      );\n    }\n  }\n\n  export default UpdatingExample\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*AkNuxR9njfksseB11gOdvA.gif\" /\u003e\n\n\n\n초기에 RenderingExample 컴포넌트가 렌더링되고 나중에 업데이트될 때, 다음과 같은 메서드 호출 순서가 발생하며 해당 메서드의 메시지가 콘솔에 출력됩니다:\n\n1. 초기 렌더링:\n\n   - constructor가 호출됩니다.\n   \n   - getDerivedStateFromProps가 호출됩니다.\n\n\n\n- shouldComponentUpdate 가 호출됩니다.\n- render 가 호출됩니다.\n\n2. 업데이트:\n\n- \"이름 변경\" 버튼이 클릭되면 changeName 이 호출되어 새 이름으로 상태가 업데이트됩니다.\n\n\n\n- 변경 사항이 있을 경우 getDerivedStateFromProps가 다시 호출됩니다.\n\n- shouldComponentUpdate가 다시 호출됩니다.\n\n- 업데이트된 UI를 다시 렌더링하기 위해 render가 다시 호출됩니다.\n\n- 구성 요소가 업데이트되었으므로 componentDidUpdate가 호출됩니다.\n\n\n\n# 언마운팅 단계\n\n언마운팅 단계는 React 컴포넌트의 라이프사이클에서 마지막 단계입니다. 이 단계는 컴포넌트가 DOM에서 제거되어 더 이상 렌더링되지 않거나 접근할 수 없는 상태를 가리킵니다. 이 단계에서 React는 컴포넌트 및 연결된 리소스가 DOM 트리에서 제대로 제거되도록 하기 위해 정리 작업을 수행합니다.\n\n이는 컴포넌트가 더 이상 필요하지 않을 때, 부모 컴포넌트가 자식 컴포넌트를 포함하지 않고 다시 렌더링될 때 또는 애플리케이션이 다른 페이지나 뷰로 이동할 때와 같은 다양한 이유로 발생할 수 있습니다. 이 단계에는 하나의 메서드만 있습니다.\n\ncomponentWillUnmount() 메서드는 컴포넌트가 DOM에서 제거되기 직전에 호출됩니다. 이 메서드를 사용하여 타이머를 취소하거나 이벤트 리스너를 제거하거나 마운팅 단계에서 설정한 데이터 구조를 제거하는 등 필요한 정리 작업을 수행할 수 있습니다. 모든 컴포넌트의 상태와 props이 파괴됩니다.\n\n\n\n```js\nimport React from \"react\";\n\nclass Child extends React.Component {\n    componentDidMount() {\n      console.log('Component mounted');\n    }\n  \n    componentWillUnmount() {\n      console.log('Component unmounted');\n    }\n  \n    render() {\n      return (\n        \u003cdiv\u003e\n          \u003cp\u003e자식 컴포넌트 내용\u003c/p\u003e\n        \u003c/div\u003e\n      );\n    }\n  }\n\nexport default class UnmountingExample extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        showComponent: true\n      };\n    }\n    \n    toggleComponent = () =\u003e {\n      this.setState(prevState =\u003e ({\n        showComponent: !prevState.showComponent\n      }));\n    };\n\n    render() {\n      return (\n        \u003cdiv\u003e\n          \u003ch1\u003e메인 컴포넌트\u003c/h1\u003e\n          {this.state.showComponent \u0026\u0026 \u003cChild /\u003e}\n          \u003cbutton onClick={this.toggleComponent}\u003e\n            {this.state.showComponent ? '언마운트' : '마운트'}\n          \u003c/button\u003e\n        \u003c/div\u003e\n      );\n    }\n}\n```\n\n아래는 출력 내용입니다,\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*KkomvSyjYradmjZ1G7f_wQ.gif\" /\u003e\n\n자식 컴포넌트는 언마운트될 컴포넌트를 나타냅니다. componentDidMount와 componentWillUnmount 라이프사이클 메소드를 포함하고 있습니다. 두 메소드에는 콘솔에 로그를 남기는 메시지가 포함되어 있습니다.\n\n\n\n`UnmountingExample` 컴포넌트는 `showComponent` 상태에 따라 조건부로 `Child` 컴포넌트를 렌더링하는 부모 컴포넌트입니다. \"Mount\" 버튼을 클릭하면 `showComponent` 상태가 변경되어 `Child` 컴포넌트가 렌더링되거나 마운트해제됩니다.\n\n위의 코드를 실행하면 다음과 같은 동작을 볼 수 있습니다:\n\n1. 초기에는 `Child` 컴포넌트가 렌더링되고 콘솔에 \"Component mounted\" 메시지가 기록됩니다.\n\n2. \"Unmount\" 버튼을 클릭하면 `Child` 컴포넌트가 마운트 해제되고 콘솔에 \"Component unmounted\" 메시지가 기록됩니다.\n\n\n\n3. \"Mount\" 버튼을 다시 클릭하면 자식 컴포넌트가 다시 렌더링되고 \"컴포넌트가 마운트됨\" 메시지가 콘솔에 로깅됩니다.\n\n# 결론\n\nReact에서 컴포넌트는 라이프사이클을 구성하는 세 가지 다른 단계에 진입할 수 있습니다. 이 단계는 마운트, 업데이트 및 언마운트입니다. 각 단계에는 라이프사이클 메서드가 호출되며, 이 메서드를 통해 컴포넌트의 프롭과 상태와 같은 다양한 내용에 대해 작업하거나 실제로 컴포넌트를 DOM에 마운트하는 것(render 메서드)이 가능합니다. 그러나 이러한 메서드는 클래스 기반 컴포넌트에만 해당됩니다.\n\n읽어 주셔서 감사합니다!\n\n\n\n만나서 반가워요 😊\n\n# 참고 자료\n\n참고 자료 1\n\n참고 자료 2 \n\n\n\n참고 3\n\n표지","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingtheReactComponentLifecycleADeepDiveintotheLifeofaReactComponent_0.png","tag":["Tech"],"readingTime":10},{"title":"매터리얼 UI 컴포넌트와 테마를 사용자 정의하는 현대적인 방법","description":"","date":"2024-05-12 18:56","slug":"2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach","content":"\n\n## Bit와 Material UI를 사용하여 초모듈화된 컴포넌트 라이브러리 구축하기\n\n![이미지](/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_0.png)\n\n초모듈화된 라이브러리는 전통적인 의미의 라이브러리가 아니라 독립적인 컴포넌트의 모음입니다. 이러한 구조는 다양한 이점을 제공합니다.\n\n## \"라이브러리\"에는 다음이 포함됩니다:\n\n\n\n- 완전한 유형 지원\n- 각 구성요소에 대한 미리보기 (SB 스토리와 유사) 및 자동 문서화\n- 추가적인 타이포그래피 변형을 포함한 사용자 정의 '테마 만들기'\n- 사용자 정의 '기본' 테마, '다크 테마', '테마 공급자' 및 '다크 모드 토글'\n- '버튼' 구성요소, '타이포그래피' 구성요소 등\n- 사용자 정의 재사용 가능한 '리액트 개발 환경'\n\n![이미지](/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_1.png)\n\n\"독립 구성 요소\"라는 것은 보통 비트 구성 요소를 의미합니다. 이 블로그에서도 마찬가지이므로 Bit가 설치되어 있고 Bit 작업 공간이 초기화되어 있는지 확인해 주세요.\n\n```js\nnpx @teambit/bvm install\n```  \n\n\n\n\n비트 새 basic my-workspace\n\n\n## Bit 워크스페이스로 완전한 솔루션 복제하기\n\n빠르게 시작하려면이 범위의 구성 요소를 자체 Bit 워크스페이스로 복제합니다 (비트 워크스페이스를 만들고 해당 위치로 cd해야합니다).\n\nMY_BIT_PLATFORM_ACCOUNT를 비트 플랫폼에서의 사용자 이름 또는 비트 조직 이름으로 바꿉니다. MY_SCOPE를 범위 이름으로 바꿉니다. 이미 설정된 것이 없다면 새로운 범위를 만듭니다.\n\n\n\n```js\ncd my-workspace\n```\n\n```js\nbit scope fork learnbit-react.custom-mui-lib MY_BIT_PLATFORM_ACCOUNT.MY_SCOPE\n```\n\n다음을 실행하여 Workspace UI에서 구성 요소를 탐색하십시오:\n\n```js\nbit start\n```\n\n\n\n이제 작업 공간에는 모든 구성 요소를 수정하고 내 스코프에 내보낼(push) 수 있는 컴포넌트가 모두 준비되어 있습니다.\n\n```js\nbit tag -m \"첫 번째 버전\"\nbit export\n```\n\n다양한 구성 요소를 검토하고 해당 구현 방식에 대한 이유를 이해해 보겠습니다.\n\n# 버튼\n\n\n\n어떤 타사 라이브러리를 사용자 정의할 때를 인도하는 하나의 원칙은 당신, 라이브러리의 유지 보수자,가 그 인터페이스와 구현에 대한 완전한 통제권을 가져야 한다는 것입니다.\n\n사용자가 무엇을 사용자 정의할 수 있는지와 무엇을 사용자가 사용자 정의할 수 없는지 선택할 수 있어야 합니다. 또한 컴포넌트의 구현을 변경하면서 그 인터페이스에 파괴적인 변화를 일으키지 않도록 할 수 있어야 합니다.\n\n```js\n/**\n * @componentId: learnbit-react.custom-mui-lib/actions/button\n * @filename: button.tsx\n */\n\nimport {\n  Button as BaseButton,\n  type ButtonProps as BaseButtonProps,\n} from '@mui/material';\n\nexport type ButtonProps = {} \u0026 BaseButtonProps;\n\nexport function Button({ children, ...rest }: ButtonProps) {\n  return \u003cBaseButton {...rest}\u003e{children}\u003c/BaseButton\u003e;\n}\n```\n\n## 컴포넌트 미리보기\n\n\n\n버튼 구성 요소 미리보기는 몇 가지 변형을 제시합니다:\n\n```js\n/**\n * @componentId: learnbit-react.custom-mui-lib/actions/button\n * @filename: button.compositions.tsx\n */\n\nimport { Button } from './button.js';\n\nexport const DefaultButton = () =\u003e {\n  return \u003cButton\u003eClick me\u003c/Button\u003e;\n};\n\nexport const ContainedButton = () =\u003e {\n  return \u003cButton variant=\"contained\"\u003eClick me\u003c/Button\u003e;\n};\n\nexport const OutlineddButton = () =\u003e {\n  return \u003cButton variant=\"outlined\"\u003eClick me\u003c/Button\u003e;\n};\n```\n\n![버튼 구성요소 이미지](/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_2.png)\n\n## 구성 요소 설명\n\n\n\nBit은 컴포넌트의 API 참조를 자동으로 생성합니다 (로컬에서 컴포넌트 페이지의 'API 참조' 탭 또는 Bit 플랫폼에서 확인 가능합니다). 자동 생성된 문서는 수동으로 작성된 문서로 확장할 수 있습니다. 이 문서는 라이브 플레이그라운드를 사용하여 다양한 버튼 사용 방법을 제공합니다.\n\n```js\n/**\n * @componentId: learnbit-react.custom-mui-lib/actions/button\n * @filename: button.docs.mdx\n */\n\n---\ndescription: MUI 버튼\n---\n\nimport { Button } from './button.js';\n\n버튼 컴포넌트 내에서 표시하려는 텍스트를 제공하세요:\n\n() =\u003e \u003cButton\u003eClick me\u003c/Button\u003e;\n``\n\n## 독립적인 버전 관리\n\n우리 라이브러리는 독립적인 Bit 컴포넌트 모음이기 때문에 각 컴포넌트의 변경 사항은 컴포넌트의 히스토리 로그와 의미적 버전 관리 (주요.부.패치)에 반영됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_3.png\" /\u003e\n\nbit tag actions/button -m \"add custom docs\" --patch\nbit export\n\n# Typography\n\n\u003cimg src=\"/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_4.png\" /\u003e\n\n\n\n우리의 타이포그래피 컴포넌트는 MUI의 기본 타이포그래피 변형을 확장하여 손글씨 변형이 추가되었습니다.\n\n이 \"라이브러리\"는 모듈식이고 조립이 가능하도록 구축되었기 때문에 해당 확장을 지원하는 타입 선언 (d.ts)을 프로젝트 루트에 배치하지 않고, 이 기능을 담당하는 컴포넌트가 기본 타입을 확장하도록 할 것입니다. 이렇게 하면 이 컴포넌트를 사용하는 구체적인 프로젝트에 관계없이 모든 것이 문제없이 작동됩니다.\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/typography/typography\n * @filename: create-theme.ts\n */\n\nimport type { CSSProperties } from 'react';\nimport {\n  Typography as BaseTypography,\n  type TypographyProps as TypographyPropsMUI,\n  type TypographyVariant as BaseTypographyVariant,\n  type TypographyVariantsOptions as BaseTypographyVariantsOptions,\n} from '@mui/material';\n\n/**\n * Typography 컴포넌트는 'handwriting' 변형으로 확장되었습니다.\n */\n\nexport type TypographyVariant = 'handwriting' | BaseTypographyVariant;\n\ndeclare module '@mui/material/Typography' {\n  interface TypographyPropsVariantOverrides {\n    handwriting: true;\n  }\n}\n\nexport interface TypographyProps extends TypographyPropsMUI {\n  variant?: TypographyVariant;\n}\n\nexport function Typography({ children, ...rest }: TypographyProps) {\n  return \u003cBaseTypography {...rest}\u003e{children}\u003c/BaseTypography\u003e;\n}\n\n/**\n * 이 인터페이스는 테마에서 타이포그래피 변형을 정의하는 데 사용될 수 있습니다.\n */\nexport interface TypographyVariantsOptions\n  extends BaseTypographyVariantsOptions {\n  handwriting?: CSSProperties;\n}\n\n# 테마 생성\n\n\n\n저희 맞춤형 '테마 생성' 컴포넌트는 MUI를 확장하여 추가 테마 옵션을 제공합니다. 이 경우에는 새로운 타이포그래피 변형이 포함됩니다. 이를 통해 저희는 확장된 스키마에 따라 새로운 테마를 생성할 수 있습니다.\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/theme/create-theme\n * @filename: create-theme.ts\n */\n\nimport type { Theme } from \"@mui/material\";\nimport { createTheme as createThemeBase } from \"@mui/material/styles\";\nimport type { ThemeOptions } from \"./theme-options.js\";\n\nexport function createTheme(options: ThemeOptions, ...args: object[]): Theme {\n  return createThemeBase(options, ...args);\n}\n\n저희 테마 옵션은 저희 맞춤 타이포그래피 컴포넌트가 제공하는 타이포그래피 변형으로 확장됩니다.\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/theme/create-theme\n * @filename: theme-options.ts\n */\n\nimport type { ThemeOptions as BaseThemeOptions } from \"@mui/material\";\nimport type { TypographyVariantsOptions } from \"@learnbit-react/custom-mui-lib.typography.typography\";\n\n/**\n * 테마 옵션을 추가로 확장하여 타이포그래피 변형을 제공합니다.\n */\nexport interface ThemeOptions extends BaseThemeOptions {\n  typography?: TypographyVariantsOptions;\n}\n\n\n\n# 사용자 정의 ‘default’ 테마\n\n우리의 사용자 정의 테마는 추가 속성(새로운 타이포그래피 유형)이 있는 테마를 생성하기 위해 사용자 정의 ‘create-theme’ 컴포넌트를 사용합니다:\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/theme/default-theme\n * @filename: default-theme.ts\n */\n\nimport {\n  createTheme,\n  type ThemeOptions,\n} from \"@learnbit-react/custom-mui-lib.theme.create-theme\";\n/** 우리 글꼴을 불러오는 `@import` 문을 반환합니다 */\nimport { getDefaultFonts } from \"@learnbit-react/custom-mui-lib.typography.get-default-fonts\";\n\nexport function defaultTheme(): ThemeOptions {\n  return createTheme({\n    components: {\n      MuiCssBaseline: {\n        /**\n         * 전역 CSS 오버라이드\n         * 기본 글꼴을 즉시 불러옵니다\n         */\n        styleOverrides: getDefaultFonts(),\n      },\n    },\n    palette: {\n      mode: \"light\",\n      primary: {\n        main: \"#4d64a8\",\n     // ...\n    },\n    typography: {\n      fontFamily: \"Outfit, sans-serif\",\n      /* 이것은 우리의 사용자 정의 타이포그래피 변형입니다 */\n      handwriting: {\n        fontFamily: \"Handlee, cursive\",\n      },\n    },\n  });\n}\n\n# 사용자 정의 ‘dark’ 테마\n\n\n\n‘다크’ 테마는 해당 테마를 확장하고 사용자 정의하는 값을/디자인 토큰으로 구성됩니다. 이 경우 ‘기본’ 테마가 ‘다크’ 테마에 의해 확장되지만 동일한 패턴을 사용하여 어떤 테마든 어떤 테마 플레이버로 확장(또는 추가 확장)할 수 있습니다.\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/theme/dark-theme\n * @filename: dark-theme.ts\n */\n\n/* 사용자 정의 및 확장할 테마를 가져옵니다 */\nimport { defaultTheme } from \"@learnbit-react/custom-mui-lib.theme.default-theme\";\nimport {\n  createTheme,\n  type ThemeOptions,\n} from \"@learnbit-react/custom-mui-lib.theme.create-theme\";\n\nexport function darkTheme(): ThemeOptions {\n  return createTheme(\n  /* 확장할 테마 */\n  defaultTheme(), \n  /* 이 테마를 위한 사용자 정의 값 */\n  {\n    palette: {\n      type: \"dark\",\n      primary: {\n        main: \"#6580f9\",\n      },\n      // ...\n    },\n  });\n}\n\n# 재사용 가능한 리액트 개발 환경\n\nBit 컴포넌트는 컴파일러, 린터, 테스터 등을 지원하는 재사용 가능한 개발 환경(‘env’)을 사용하여 개발됩니다. 이 특정 컴포넌트 개발 환경은 Bit의 기본 리액트 개발 환경을 확장합니다.\n\n\n\n우리 사용 사례에는 기본 구성을 변경할 필요가 없습니다. 그러나 우리는 매번 테마 공급자를 수동으로 설정하는 시간을 절약하고 또한 표준화된 미리보기 컨텍스트를 보장하기 위해 우리의 모든 컴포넌트 미리보기를 테마로 래핑하는 재사용 가능한 env가 필요합니다.\n\n/**\n * @componentId: learnbit-react.custom-mui-lib/dev/react-mui\n * @filename: preview/mounter.ts\n */\n\nimport React from 'react';\nimport { createMounter } from '@teambit/react.mounter';\n/* 우리의 사용자 정의 테마 공급자를 가져옵니다 */\nimport { ThemeProvider } from '@learnbit-react/custom-mui-lib.theme.theme-provider';\n\n/**\n * 컴포넌트 미리보기에 필요한 컨텍스트를 제공합니다.\n * 이 경우, 사용자 정의 MUI 테마입니다.\n */\nexport function MyReactProvider({ children }: { children: React.ReactNode }) {\n  return \u003cThemeProvider\u003e{children}\u003c/ThemeProvider\u003e;\n}\n\n우리는 이 env를 workspace.jsonc 구성 파일에 설정하여 새로운 컴포넌트가 이 env에서 제공하는 템플릿을 사용하여 생성되도록하고(그리고 자동으로 이 env를 env로 설정)하는 것을 보장할 수 있습니다:\n\n/**\n * @filename: {workspace-root}/workspace.jsonc\n */\n\n{\n  // ...\n    \"teambit.generator/generator\": {\n    \"envs\": [\n      /**\n       * `learnbit-react.custom-mui-lib`를 \n       * 자체 `BIT_CLOUD_ACCOUNT.SCOPE_NAME`으로 교체해야 합니다.\n      \"learnbit-react.custom-mui-lib/dev/react-mui\"\n    ]\n  },\n}\n\n\n\n예를 들어, 이 'slider' 컴포넌트는 다음과 같은 개발 환경을 사용하여 생성됩니다:\n\n$ bit create react actions/slider\n\n생성된 컴포넌트가 올바른 환경을 사용하여 생성되었음을 확인하는 출력:\n\n1 개의 컴포넌트가 생성되었습니다\n\nlearnbit-react.custom-mui-lib/actions/slider\n    위치: custom-mui-lib/actions/slider\n    환경: learnbit-react.custom-mui-lib/dev/react-mui@0.0.4 (템플릿에서 설정됨)\n    패키지: @learnbit-react/custom-mui-lib.actions.slider\n\n\n\n![Customize Material UI Components and Theme: A Modern Approach](/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_5.png)","ogImage":{"url":"/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_0.png"},"coverImage":"/assets/img/2024-05-12-CustomizeMaterialUIComponentsandThemeAModernApproach_0.png","tag":["Tech"],"readingTime":9},{"title":"React 애플리케이션 성능 향상을 위한 클라이언트 측 타임아웃 처리 방법","description":"","date":"2024-05-12 18:55","slug":"2024-05-12-EnhancingReactApplicationPerformancewithClient-SideTimeoutHandling","content":"\n\n웹 개발의 동적인 세계에서 성능 최적화와 사용자 경험의 원할한 유지가 최우선 과제입니다. 비동기 요청을 처리할 때 성능에 상당한 영향을 미치는 과감실 처리에 대해 종종 간과되는 측면 중 하나입니다. 이 블로그 포스트에서는 JavaScript에서 Axios를 사용하여 클라이언트 측 타임아웃 처리를 통해 웹 애플리케이션의 성능과 신뢰성을 향상시키는 방법에 대해 살펴보겠습니다.\n\n# 클라이언트 측 타임아웃 처리를 왜 해야 하는가요?\n\n- 블로킹 방지: 기대 시간을 초과하는 동기식 요청은 다른 작업을 차단하여 응답성이 감소하고 성능이 저하될 수 있습니다.\n- 빠른 오류 복구: 응답이 없는 서버로부터 무기한 대기하는 것은 나쁜 사용자 경험으로 이어질 수 있습니다. 클라이언트 측 타임아웃은 기대 응답 시간을 초과하는 요청을 빠르게 취소함으로써 빠른 오류 복구를 제공합니다.\n- 리소스 소비 감소: 오랜 시간 동안 실행되는 요청은 네트워크 대역폭, 서버 리소스 및 클라이언트 측 메모리를 소비합니다. 지정된 시간 초과하는 요청을 취소함으로써 리소스를 절약하여 성능과 확장성을 향상시킬 수 있습니다.\n- 사용자 경험 향상: 성능은 사용자 경험에 직접적으로 영향을 미칩니다. 클라이언트 측 타임아웃을 통해 사용자는 지연이 줄어들고 더 빠른 응용 프로그램을 경험할 수 있어 만족도와 참여도가 높아집니다.\n- 오류 허용성 개선: 클라이언트 측 타임아웃은 네트워크 오류나 서버 타임아웃과 같은 예기치 않은 상황을 고품질로 처리하여 전체 응용 프로그램의 탄력성을 향상시킵니다.\n\n# Axios를 사용한 클라이언트 측 타임아웃이 성능을 향상시키는 방법\n\n\n\n이제, Axios를 사용하여 클라이언트 측 타임아웃 처리를 구현하는 방법을 살펴보겠습니다. Axios는 JavaScript를 위한 인기있는 HTTP 클라이언트입니다.\n\n```js\nimport axios from \"axios\";\n\nconst API_BASE_URL = \"https://jsonplaceholder.typicode.com/\";\n\nconst loginClient = axios.create({\n    baseURL: API_BASE_URL\n});\n\nloginClient.interceptors.request.use(request =\u003e {\n    request.headers[\"Accept\"] = \"application/json\";\n    return {\n        ...request,\n        signal: newAbortSignal(2000)\n    };\n}, error =\u003e {\n    console.log(\"오류 발생\", error);\n});\n\nfunction newAbortSignal(timeoutMs) {\n    const abortController = new AbortController();\n    setTimeout(() =\u003e abortController.abort(), timeoutMs || 0);\n    return abortController.signal;\n}\n\nasync function fetchPosts(req) {\n    try {\n        const posts = await loginClient({ url: \"posts\" });\n        return posts;\n    } catch (error) {\n        console.log(\"오류\", error);\n        return { \"data\": { \"error\": true, \"message\": \"서버가 응답하지 않습니다.\" } };\n    }\n}\n\nconst postService = {\n    fetchPost: fetchPosts\n};\n\nexport { postService };\n```\n\n이 코드에서:\n\n- API를 가리키는 기본 URL이 있는 Axios 인스턴스 loginClient를 생성합니다.\n- Interceptor가 설정되어 요청에 타임아웃 시그널이 부착되어서, 서버가 2000밀리초 이내에 응답하지 않으면 취소됩니다.\n- newAbortSignal 함수는 지정된 기간 후 요청이 취소되도록 타임아웃이 있는 새로운 AbortController 인스턴스를 생성합니다.\n- fetchPosts 함수는 API에서 게시물을 비동기적으로 가져옵니다. 요청이 성공하면 가져온 게시물을 반환하고, 타임아웃 또는 네트워크 실패와 같은 오류가 발생하면 해당 오류를 잡아서 사용자 정의 오류 응답을 반환합니다.\n\n\n\n클라이언트 측에서의 타임아웃은 요청을 다시 시도하면 성공할 수 있는 경우에 도움이 됩니다. 예를 들어, 백엔드가 3개의 서버에서 호스팅되고 있고 1개의 서버가 응답하지 않는 경우, 요청을 취소하고 다시 시도하는 것이 더 나은 선택입니다.","ogImage":{"url":"/assets/img/2024-05-12-EnhancingReactApplicationPerformancewithClient-SideTimeoutHandling_0.png"},"coverImage":"/assets/img/2024-05-12-EnhancingReactApplicationPerformancewithClient-SideTimeoutHandling_0.png","tag":["Tech"],"readingTime":3}],"page":"143","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"143"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>