<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/68" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/68" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Cars24 SDE-2 Frontend 면접 경험" href="/post/2024-05-18-Cars24SDE-2FrontendInterviewExperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Cars24 SDE-2 Frontend 면접 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Cars24 SDE-2 Frontend 면접 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Cars24 SDE-2 Frontend 면접 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " href="/post/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 </strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" href="/post/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 웹사이트 성능 향상 시키는 방법" href="/post/2024-05-18-performanceinreact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-performanceinreact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 웹사이트 성능 향상 시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Axios, Fetch, Express 깊이 알아보기" href="/post/2024-05-18-ADeepDiveintoAxiosFetchandExpress"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Axios, Fetch, Express 깊이 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NinjaCart SDE 2 프론트엔드 인터뷰 경험" href="/post/2024-05-18-NinjaCartSDE2frontendInterviewExp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NinjaCart SDE 2 프론트엔드 인터뷰 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬과 언더스코어 (_)" href="/post/2024-05-18-Pythonandtheunderscore_"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬과 언더스코어 (_)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Pythonandtheunderscore__0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬과 언더스코어 (_)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬과 언더스코어 (_)</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인공지능으로 감정 분석 성능 높이기" href="/post/2024-05-18-ElevatingSentimentAnalysis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인공지능으로 감정 분석 성능 높이기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인공지능으로 감정 분석 성능 높이기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">인공지능으로 감정 분석 성능 높이기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" href="/post/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" href="/post/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link posts_-active__YVJEi" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Cars24 SDE-2 Frontend 면접 경험","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-Cars24SDE-2FrontendInterviewExperience","content":"\n\n나는 링크드인에서 리쿠루터에게 연락했다.\n\n# 1차 면접 — JS\n\n질문 1 — 클로저란 무엇이며 예시와 함께 설명해보세요.\n\n```js\nfunction closure() {\n    let count = 0;\n    return function test() {\n        count++;\n        return count;\n    }\n}\n\nconst closuredTest = closure();\n\nconsole.log(closuredTest());\nconsole.log(closuredTest());\nconsole.log(closuredTest());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2번 문제 - 커리(curry)란 무엇이며 주어진 함수의 커리 고차 함수를 만드세요.\n\n```js\nfunction sum(a, b, c){\n  return a + b + c; \n}\n```\n\n```js\nfunction curry(fn){\n  return function curriedFn(...params){\n    if(params.length \u003e= fn.length){\n      return fn(...params);\n    }\n    else{\n      return function(...next){\n        return curriedFn(...params,...next);\n      }\n    }\n  }\n}\n\nlet curriedSum = curry(sum);\n\nconsole.log(curriedSum(1, 2, 3));   // 6, 일반적으로 호출 가능\nconsole.log(curriedSum(1)(2,3));    // 6, 첫 번째 인수 커리\nconsole.log(curriedSum(1)(2)(3));   // 6, 완전한 커리\n```\n\n3번 문제 - Task Queue(작업 큐) 및 이벤트 루프에 대해 설명해보세요.\n먼저 구두로 설명한 후 코드 스니펫을 작성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## question4 — output based question\n\n```js\nasync function async1() {\n    console.log(\"async1 start\");\n    const data = await async2();\n    console.log(data);\n    console.log(\"async1 end\");\n}\n\nasync function async2() {\n    console.log(\"async2\");\n    return \"async2 completed\";\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function () {\n    console.log(\"setTimeout\");\n}, 0);\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log(\"promise1\");\n    resolve();\n}).then(function () {\n    console.log(\"promise2\");\n});\n\nconsole.log(\"script end\");\n```\n\nquestion 5 — explain this keyword and how can we change it forcefully\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nlet obj = {\n    name: 'prikshit',\n    myName(city, birthPlace) {\n        console.log(this.name + ' i live in ' + city + ' my birthplace is ' + birthPlace);\n    }\n}\n\nlet obj2 = {\n    name: 'sohail',\n}\n\n// obj.myName.call(obj2,'blr');\n// obj.myName.apply(obj2,['blr']);\n\nconst bindedFn = obj.myName.bind(obj2);\n\nbindedFn('blr', 'delhi');\n\nobj.myName(); // this keyword here is obj\n```\n\n## 2nd Round — Machine Coding\n\n1. **1st question** - 온라인/오프라인 상태를 보여주는 사용자 정의 훅을 만들어 보세요. (해결 사항)\n\n2. **2nd question** - 그리드 라이트를 만들어 보세요. (Uber 인터뷰어들의 즐겨하는 문제)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3차 라운드 — 기술 관리 라운드\n\n이번 라운드에서 면접관은 전자 상거래 필터 구성 요소를 만들어 달라고 했어요.","ogImage":{"url":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-18-Cars24SDE-2FrontendInterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 네이티브에서 TypeScript를 활용한 자원 관리 마스터하기 ","description":"","date":"2024-05-18 21:46","slug":"2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration","content":"\n\n\n\n![RAII Reimagined: Embracing Lifecycle Hooks](/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png)\n\n# RAII Reimagined: Embracing Lifecycle Hooks\n\nRAII은 객체 초기화 중에 리소스를 획득하고 파괴 시에 해제하는 것을 강조합니다. React Native에서는 컴포넌트 라이프사이클 훅이 RAII를 가능하게 합니다:\n\n```js\nimport React, { useEffect } from 'react';\nimport Geolocation from '@react-native-community/geolocation'; // 예시 리소스\n\nfunction LocationTracker() {\n  useEffect(() =\u003e {\n    const watchId = Geolocation.watchPosition(location =\u003e {\n      // ... 위치 데이터 처리\n    });\n\n    return () =\u003e {\n      Geolocation.clearWatch(watchId); // 언마운팅시 워치 해제\n    };\n  }, []); \n\n  // ... 컴포넌트 로직\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드 조각에서:\n\n- useEffect는 컴포넌트가 마운트될 때 지리적 위치 감시를 설정합니다.\n- useEffect에서 반환된 정리 함수는 소멸자와 유사하게 동작하여 컴포넌트가 마운트 해제될 때 감시를 지워 리소스 누출을 방지합니다.\n\n# 스마트 포인터: TypeScript에서의 색다른 접근\n\nTypeScript에는 진정한 스마트 포인터가 없지만 클래스를 사용하여 그 본질을 모방할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass AudioPlayer {\n  private sound: Sound | null; \n\n  constructor(filePath: string) {\n    this.sound = new Sound(filePath, error =\u003e {\n      // ... handle potential errors\n    });\n  }\n\n  play() {\n    if (this.sound) this.sound.play();\n  }\n\n  release() { \n    if (this.sound) {\n      this.sound.release(); \n      this.sound = null;\n    }\n  }\n}\n```\n\n구성요소에서:\n\n```js\nuseEffect(() =\u003e {\n  const player = new AudioPlayer('path/to/sound.mp3');\n  // ...\n\n  return () =\u003e {\n    player.release(); // 청소스럽게 오디오 자원을 해제합니다\n  };\n}, []);\n```\n\nAudioPlayer 클래스는 Sound 객체를 캡슐화하고 제어된 접근을 제공합니다. release 메서드는 스마트 포인터의 소멸자를 흉내내어 적절한 정리를 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 신중한 참조: 원시 포인터 함정 피하기\n\n객체 참조를 부드러운 포인터처럼 취급하세요:\n\n- 구독 취소: 컴포넌트가 언마운트될 때 항상 이벤트 이밋터나 옵저버블 구독을 해제하세요.\n- 인터벌 비우기: clearInterval 및 clearTimeout를 꼼꼼히 사용하세요.\n- 순환 참조 해제: 가비지 컬렉션을 방해할 수 있는 순환 참조에 주의하세요.\n\n기본 이상으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라이브러리: RxJS (Observables)나 React Native AppState API와 같은 라이브러리를 고려하여 자원 관리를 효율적으로 처리합니다.\n- 커스텀 훅: 복잡한 자원 상호작용을 캡슐화하기 위해 커스텀 훅을 작성합니다.\n- 에러 처리: 자원 관리 전략에 정교한 에러 처리를 통합합니다.\n\nRAII 원칙을 적용하고 스마트 포인터에서 영감을 받아 React Native TypeScript 개발을 높여나갈 수 있습니다. 자원을 자신있게 관리하고 메모리 누수를 방지하며 시간이 지날수록 늘 튼튼한 애플리케이션을 구축하세요.","ogImage":{"url":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringResourceManagementinReactNativewithTypeScriptRAIISmartPointerInspiration_0.png","tag":["Tech"],"readingTime":3},{"title":"우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법","description":"","date":"2024-05-18 21:44","slug":"2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu","content":"\n\n웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.\n\n# 필수 사항\n\n시작하기 전에 다음 사항을 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Apache가 설치된 Ubuntu 서버\n- openssl 도구가 설치되어 있습니다.\n\n우선, 프론트엔드 폴더로 이동해주세요.\n\n### 단계 1: 디렉토리 생성\n\n인증서를 위한 디렉토리를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir certificates\ncd certificates\n```\n\n# 단계 2: 개인 키 생성\n\n```js\nopenssl genpkey -algorithm RSA -out private.key\n```\n\n- genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.\n- -algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.\n- -out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -\n\n```js\nopenssl genpkey -algorithm RSA -aes256 -out private.key\n```\n\n-aes256:\n\n- 이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.\n\n\nYou’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(당신의 IP를 Ip 자리에 넣으세요)\n\n- [req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.\n- distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.\n- req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.\n- prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.\n- [req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.\n- CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.\n- C = BD: 국가 속성으로 방글라데시를 나타냅니다.\n- ST = Dhaka: 주 속성으로 다카를 지정합니다.\n- L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.\n- O = Robist: 조직 속성으로 로비스트를 나타냅니다.\n- OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.\n- emailAddress = smazoomder@gmail.com: 인증서와 관련된 이메일 주소입니다.\n- [req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.\n- subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.\n\n## Subject Alternative Name (SAN)의 내용 :\n\n- Subject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.\n- Alternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SAN 사용 이유:\n\n- 다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.\n- 다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.\n- IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.\n- 와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.\n- 인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.\n\n요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.\n\n# 단계 4: 인증서 서명 요청(CSR) 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl req -new -key private.key -out certificate.csr -config san.conf\n```\n\nopenssl req:\n\n- 이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.\n\n-new:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.\n\n- -key private.key:\n\n- CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.\n\n- -out certificate.csr:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.\n\n- `config san.conf`:\n\n- 인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.\n\n# 단계 5: 자체 서명 인증서 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\nopenssl x509 -req -in certificate.csr -signkey private.key -out server.cert -days 365\n```\n\nopenssl x509:\n\n- X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.\n\n-req:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.\n\n- certificate.csr 파일 안에:\n\n- 서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.\n\n- signkey private.key:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.\n\n- server.cert에 저장됩니다:\n\n- 서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.\n\n- 365일 동안 유효합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.\n\n## X.509 인증서 소개\n\nX.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)\n- 일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.\n- 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.\n- 발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.\n- 유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.\n- 주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.\n- 주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.\n- 확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.\n- 인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.\n- 인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.\n\n# X.509 인증서의 목적:\n\n- 인증: 인증서 소지자의 신원을 확인합니다.\n- 암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.\n- 디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.\n- 키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.\n\n# SSL/TLS에서의 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.\n- X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.\n\n웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.\n\n# 단계 6: Apache 구성 업데이트\n\nApache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 가상 호스트 설정:\n\n- **`VirtualHost *:443`**: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.\n\n- **`ServerName localhost`**: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.\n\nDocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.\n\nSSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.\n\nSSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.\n\nSSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.\n\nServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.\n\n`Directory \"/var/www/html/your-project/backend/public\"`: 지정된 디렉토리에 대한 구성 블록을 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOptions All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.\n\nAllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.\n\nRequire all granted: 모든 사용자에게 액세스를 부여합니다.\n\n`/Directory`: 지정된 디렉토리에 대한 구성 블록을 종료합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`/VirtualHost` : VirtualHost 블록을 종료합니다.\n\n# 설정 목적:\n\n- 이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.\n- \"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.\n\n그런 다음 활성화하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo a2ensite your-site.conf\n```\n\n# 단계 7: 아파치 재시작\n\n```js\nsudo systemctl restart apache2\n```\n\nSSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: Apache 오류 로그 확인\n\n```bash\nsudo tail -f /var/log/apache2/error.log\n```\n\nSSL과 관련된 오류 메시지를 확인해 보세요.\n\n# 단계 9: 라라벨 저장소 권한 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n이제 https://192.168.0.88 (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.\n\n# 단계 10: React/Laravel 애플리케이션을 실행 중이라면\n\n프론트엔드 환경에서:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nREACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false\n\nREACT_APP_API_BASE_URL='https://192.168.0.88/api'\nREACT_APP_ASSET_BASE_URL='https://192.168.0.88/storage'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='https://192.168.0.88'\nREACT_APP_BACK_DOMAIN = 'https://192.168.0.88'\n\nREACT_APP_SITE_KEY = 'your-key'\n\n\nin backend env :\n\n\nAPP_URL=https://192.168.0.88\nAPP_SITE_URL=\"https://192.168.0.88:3000\"\n\n\n축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제가 있으면 다음을 실행해 보세요\n\n```js\nsudo systemctl restart apache2\n```\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n# (선택 사항) /etc/hosts 파일 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.\n\n# (선택 사항) Chrome에서 인증서를 가져오는 방법:\n\n- 권한 생성 및 인증서를 CRT 형식으로 변환:\n\n```js\nopenssl x509 -in server.cert -out server.crt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- PKCS#12 형식으로 인증서 및 키 변환하기:\n\n```js\nopenssl pkcs12 -export -out certificate.pfx -inkey private.key -in server.cert\n```\n\n개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n3. Chrome에 인증서 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크롬을 열고 설정으로 이동합니다.\n- 아래로 스크롤하여 고급을 클릭합니다.\n- 개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.\n- 인증서 창에서 개인 탭으로 이동합니다.\n- 가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.\n- 가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.\n\n4. 신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:\n\n```js\nsudo cp server.crt /usr/local/share/ca-certificates/server.crt\nsudo update-ca-certificates\n```\n\n다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nawk -v cmd='openssl x509 -noout -subject' ' /BEGIN/{close(cmd)};{print | cmd}' \u003c /etc/ssl/certs/ca-certificates.crt | grep -i localhost\n```\n\n인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.\n\n```js\nopenssl x509 -in server.cert -text -noout\n```\n\n만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl x509 -enddate -noout -in server.cert\n```\n\n인증서 내용 확인:\n\nOpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:\n\n```js\nopenssl x509 -in server.cert -text -noout\nopenssl rsa -in private.key -text -noout\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.\n\n```js\nopenssl rsa -in private.key -out private.key\n```\n\n인증서를 확인하려면\n\n```js\nopenssl verify server.crt\n```","ogImage":{"url":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png","tag":["Tech"],"readingTime":11},{"title":"리액트 웹사이트 성능 향상 시키는 방법","description":"","date":"2024-05-18 21:42","slug":"2024-05-18-performanceinreact","content":"\n\n현대 웹 애플리케이션을 개발할 때 최적의 성능을 달성하는 것이 중요합니다. ReactJS는 개발자가 빠르고 반응이 뛰어나며 효율적인 애플리케이션을 만들 수 있도록 도와주는 강력한 도구와 기술을 제공하지만, 이들을 어떻게 사용해야 하는지 알아야 합니다! 이 글에서는 ReactJS에서 성능을 극대화하기 위한 주요 원칙을 탐구하며, 재렌더링을 최소화하고 DOM과 가상 DOM 간의 차이를 이해하며 불변성을 활용하고 메모이제이션을 구현하는 것에 초점을 맞출 것입니다.\n\n![Image](/assets/img/2024-05-18-performanceinreact_0.png)\n\nReact의 성능 최적화의 핵심은 재렌더링을 최소화하는 원칙에 있습니다. 컴포넌트가 재렌더링될 때마다 React는 변경 사항을 조화하고 DOM을 적절히 업데이트해야 합니다. 불필요한 재렌더링을 줄이면 애플리케이션 속도가 향상되는 것뿐만 아니라, 사용자 경험도 부드럽고 반응성 있게 유지할 수 있습니다. 그러나 이를 실현하기 위해서는 상태 관리, 컴포넌트 디자인 및 라이프사이클 메서드에서 모베스트 프랙티스를 이해하고 적용해야 합니다.\n\n# DOM vs. 가상 DOM 🌐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDOM 및 가상 DOM과 같은 개념이 성능과 연관이 있는 이유는 React와 같은 프레임워크가 사용자 인터페이스 업데이트를 다루는 방식 때문입니다. 문서 객체 모델(DOM)은 웹 문서를 프로그래밍적으로 다루는 인터페이스로, 웹페이지의 구조를 객체 트리로 표현합니다. 이 트리의 각 노드는 요소, 속성, 텍스트 컨텐츠와 같은 문서의 부분을 나타냅니다. 이것은 기본적으로 브라우저가 HTML 코드를 이해하는 방식입니다:\n\n![Performance in React](/assets/img/2024-05-18-performanceinreact_1.png)\n\n각 재렌더링은 React가 변경 사항을 조율하고 DOM을 업데이트해야 하므로 연산 부하가 발생할 수 있습니다. DOM의 변경마다 브라우저가 스타일을 다시 계산하고 레이아웃을 재구성하며 페이지를 다시 그리게 됩니다. 이는 퍼포먼스에 상당한 영향을 미칠 수 있으며 특히 업데이트가 빈번하고 DOM 트리의 큰 부분을 포함할 때 그 영향이 커집니다.\n\n하지만 React는 어떻게 이를 효율적으로 처리할까요?\nReact는 실제 DOM의 추상화인 가상 DOM을 생성합니다. 이는 React가 메모리에 유지하는 DOM의 가벼운 사본입니다. React 컴포넌트의 상태가 변경되면 React는 먼저 가상 DOM을 업데이트합니다. 그런 다음에 실제 DOM을 새로운 가상 DOM 상태와 일치하도록 업데이트해야 하는 최소한의 변경 세트를 효율적으로 결정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 말은 React가 모든 상태 변경에 대해 즉시 DOM을 업데이트하는 대신 변경 사항을 수집하고 한 번에 DOM을 업데이트한다는 것을 의미합니다. 이로써 DOM에 액세스하고 수정하는 횟수가 감소하여 성능이 향상됩니다. 이 프로세스를 reconciliation이라고 합니다.\n\n# 성능 최적화 📈\n\n성능에 대해 논의할수록, 프레임워크의 핵심 원칙에 대해 깊게 이야기하며 데이터와 계산을 효율적으로 처리하는 방식에 영향을 미치는 것에 대해 말하게 됩니다. React에서 두 가지 원칙인 불변성과 메모이제이션은 모두 성능을 향상시키는 데 중요한 역할을 합니다.\n\n## 불변성🔒\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불변성은 데이터 구조를 생성한 후에 수정하지 않는 실천 방식을 의미합니다. 대신, 모든 수정은 새로운 데이터 구조를 생성합니다. 이 개념은 React에서 아래와 같은 이유로 중요합니다:\n\n- 예측 가능한 상태 변경: 상태가 불변성을 갖추면 변경 사항이 예측 가능하고 추적 가능해져서 코드의 디버깅과 이해가 간소화됩니다.\n- 효율적인 다시 렌더링: React는 이전 상태나 프롭을 현재 상태나 프롭과 비교하여 컴포넌트를 다시 렌더링해야 하는지 빠르게 판단할 수 있습니다. 참조가 다를 경우 React는 변경이 발생했음을 알 수 있습니다. 이 비교는 불변성 데이터 구조를 사용하여 빠르고 효율적입니다.\n- 부작용 회피: 불변성은 공유된 가변 상태로 인한 의도하지 않은 부작용을 방지하여 더 신뢰성이 있고 유지보수가 용이한 코드를 만들어냅니다.\n\n하지만 React와 JavaScript는 어떻게 불변성을 활용하여 더 빠르게 렌더링할 수 있을까요?\n\n앞에서 언급했듯이 불변 데이터를 사용하면 React의 diffing 알고리즘이 애플리케이션의 상태 변화를 더 효율적으로 추적할 수 있습니다. 왜냐하면 객체 참조를 간단히 비교함으로써 각 객체의 속성을 깊게 비교할 필요가 없기 때문입니다. JavaScript는 객체 포인터가 다른 메모리 위치에 있는지 확인함으로써 모든 키를 확인하지 않고도 차이점을 확인할 수 있습니다. 이렇게 하면 훨씬 빨라집니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션 🧠\n\n한편, 메모이제이션은 결과를 캐싱하고 같은 입력이 다시 발생할 때 재사용하여 비싼 계산을 최적화하는 데 도움이 됩니다. React에서 memoization은 useMemo 및 useCallback과 같은 훅을 통해 구현될 수 있습니다. 이러한 훅은 값과 함수를 메모이즈하여 불필요한 다시 랜더링과 계산을 막아주는데 도움을 줍니다. 만약 ReactJS 코드를 작성한 적이 있다면 아마 이에 대해 알고 있어야 할 것입니다.\n\n하지만 중요한 것은 메모이제이션과 불변성을 따로 생각하지 않는 것입니다. 이 둘은 밀접한 관련이 있으며 종종 함께 사용하여 성능을 최적화합니다. 이들의 관계를 이해하면 개발자가 더 효율적이고 유지보수가 쉬운 코드를 작성하는 데 도움이 됩니다.\n\n![React 성능 개선 이미지](/assets/img/2024-05-18-performanceinreact_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션과 불변성의 관계 🔗\n\n리액트에서 성능 최적화의 맥락에서 메모이제이션과 불변성은 밀접한 관련이 있습니다. 불변성은 안정적인 기반을 제공하여 메모이제이션을 더 효율적이고 신뢰할 수 있도록 만드는데 기여합니다. 다음과 같은 이유로 상태 변화가 예측 가능하고 의존성 추적을 단순화시킵니다:\n\n- 캐시 로직 단순화: 불변 데이터로 인해 메모이제이션 함수의 캐싱 로직이 더 간단해집니다. 데이터가 변할 수 없기 때문에 캐시는 데이터 변화로 인한 무효화를 처리할 필요가 없어져 더 직접적이고 신뢰할 수 있는 메모이제이션이 가능해집니다.\n- 부작용 회피: 불변 데이터 구조는 공유된 가변 상태에 의한 부작용을 피하는 데 도움이 됩니다. 이는 메모이제이션 함수가 더 안전하고 예측 가능하게 만들어줍니다. 예상치 못한 변경이 없는 입력값에 의존하기 때문입니다.\n- 참조 동등성: 불변성은 데이터 구조들을 참조 동등성을 통해 간단하고 효율적으로 비교할 수 있게 해줍니다 (즉, 두 참조가 동일한 객체를 가리키는지 확인). 이는 메모이제이션에 핵심적인데, 빠르고 효율적인 캐시 조회를 가능하게 합니다. 메모이제이션 함수의 입력이 불변성을 가진다면 함수는 입력값이 변경되었는지 쉽게 참조를 비교함으로써 판단할 수 있습니다.\n\n데이터가 불변하면 메모이제이션 함수나 컴포넌트의 의존성이 안정적으로 유지됩니다. 이 안정성은 메모이제이션 값을 또는 콜백을 필요한 경우에만 다시 계산함으로써 불필요한 계산과 새로고침을 피할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-performanceinreact_3.png) \n\n# 결론 📢\n\n이전에 이야기한 대로, 성능에 대해 더 깊이 이야기할수록, 프레임워크의 핵심 원칙에 대해 더 많이 이야기하게 됩니다. React 애플리케이션은 Virtual DOM의 효율적인 차이점 및 업데이팅 기능을 활용하고, 불변 데이터 구조 및 메모이제이션된 계산을 보완하여 번개처럼 빠른 렌더링 및 부드러운 사용자 경험을 달성할 수 있습니다.\n\nReact 핵심 개념을 조화롭게 통합함으로써, 개발자들은 응답성이 뛰어나고 성능이 우수한 사용자 경험을 제공하여 응용 프로그램의 최대 잠재력을 발휘할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음… 그것이 다야!\n내 LinkedIn에 연락해 보고 메시지를 보내주세요. 멋진 경험이 될 거에요!\n\n고마워요!! 👋👋","ogImage":{"url":"/assets/img/2024-05-18-performanceinreact_0.png"},"coverImage":"/assets/img/2024-05-18-performanceinreact_0.png","tag":["Tech"],"readingTime":5},{"title":"Axios, Fetch, Express 깊이 알아보기","description":"","date":"2024-05-18 21:41","slug":"2024-05-18-ADeepDiveintoAxiosFetchandExpress","content":"\n\n웹 개발 분야에서, 작업에 적합한 도구를 선택하는 것이 생산성과 애플리케이션의 효율에 상당한 영향을 미칠 수 있습니다. 오늘은 Axios, Fetch 및 Express라는 세 가지 중요한 기술에 대해 자세히 살펴볼 것입니다. 프론트 엔드, 백 엔드 또는 둘 다를 개발 중이더라도 이러한 도구를 이해하는 것은 개발 기술을 향상시킬 수 있습니다. 함께 알아보겠습니다!\n\n# Axios vs. Fetch vs. Express: 어떤 것을 사용해야 할까요?\n\n# 소개\n\n웹 개발자로서, HTTP 요청을 보내고 강력한 서버 측 애플리케이션을 구축하는 작업에 자주 직면하게 됩니다. Axios, Fetch 및 Express는 이러한 목표를 달성하는 데 도움이 되는 세 가지 주요 기술입니다. 그러나 이들은 각각 다른 목적을 가지고 있습니다. 이 포괄적인 안내서에서 각 도구의 특징, 작동 방식 및 사용 시기에 대해 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Axios란 무엇인가요?\n\nAxios는 브라우저와 Node.js 환경에서 HTTP 요청을 보내는 데 사용되는 인기 있는 JavaScript 라이브러리입니다. Promise를 기반으로 하고 있어 비동기 작업을 간편하게 처리할 수 있습니다. Axios는 간단함과 강력한 기능으로 개발자 커뮤니티에서 사랑받고 있습니다.\n\n# Axios의 주요 기능:\n\n- Promise 기반 API: 비동기 요청 처리를 간편하게 합니다.\n- Interceptors: 요청이나 응답을 처리하기 전에 수정할 수 있습니다.\n- 자동 JSON 파싱: JSON 데이터를 자동으로 처리합니다.\n- 넓은 호환성: 오래된 브라우저와 Node.js에서 작동합니다.\n- 편리한 메소드: HTTP 요청을 위한 간소화된 메소드를 제공합니다 (예: axios.get, axios.post).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법:\n\nAxios를 사용하여 API에서 데이터를 가져오는 간단한 예제가 여기 있어요.\n\n```js\naxios.get('https://api.example.com/data')\n  .then(response =\u003e {\n    console.log(response.data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  });\n```\n\n# 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Fetch가 무엇인가요?\n\nFetch는 XMLHttpRequest에 대한 더 현대적이고 유연한 대안을 제공하는 내장 JavaScript API입니다. 대부분의 최신 브라우저에서 사용할 수 있으며 promise를 반환하여 네이티브 솔루션을 선호하는 많은 개발자들에게 인기가 있습니다.\n\n# Fetch의 주요 기능:\n\n- 네이티브 API: 추가 라이브러리가 필요하지 않습니다.\n- Promise 기반: 현대적인 JavaScript와 매끄럽게 통합됩니다.\n- 간소화된 구문: XMLHttpRequest보다 더 간결하고 가독성이 좋습니다.\n- 수동 JSON 처리: JSON 응답을 수동으로 구문 분석해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법\n\nFetch를 사용하여 API 요청을 하는 방법을 보여드리겠습니다:\n\n```js\nfetch('https://api.example.com/data')\n  .then(response =\u003e response.json())\n  .then(data =\u003e {\n    console.log(data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류가 발생했습니다:', error);\n  });\n```\n\n# 익스프레스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Express란 무엇인가요?\n\nExpress는 웹 및 모바일 애플리케이션을 개발하기 위한 강력한 기능 세트를 제공하는 최소한의 유연성을 갖춘 Node.js 웹 애플리케이션 프레임워크입니다. 그 간결함과 확장성으로 인해 API 및 서버 측 응용 프로그램을 만드는 데 널리 사용됩니다.\n\n# Express의 주요 기능:\n\n- 미들웨어 지원: 요청을 처리하는 함수를 쉽게 추가할 수 있습니다.\n- 라우팅: 다양한 HTTP 메소드와 URL 패턴을 처리하기 위한 강력한 라우팅 기능.\n- 확장성: 다양한 플러그인 및 모듈의 큰 생태계.\n- 확장성: 확장 가능한 어플리케이션을 구축하는 데 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제 사용법:\n\n다음은 Express 서버를 설정하는 기본적인 예제입니다:\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/data', (req, res) =\u003e {\n  res.json({ message: '안녕, 세상아!' });\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n# 이 비교가 중요한 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAxios, Fetch 및 Express 간의 차이를 이해하는 것은 여러 가지 이유로 중요합니다:\n\n- 정보 있는 결정: 특정 시나리오에서 어떤 도구를 사용해야 하는지를 알면 효율성과 효과성이 향상됩니다.\n- 코드 품질 향상: 작업에 적합한 적절한 도구를 사용하면 보다 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 더 나은 디버깅: 이러한 도구에 익숙해지면 문제 해결과 디버깅을 더 효과적으로 수행할 수 있습니다.\n- 생산성 향상: 적절한 도구로 개발 프로세스를 최적화하면 시간을 절약하고 복잡성을 줄일 수 있습니다.\n\n# Axios vs. Fetch: 언제 사용해야 할까요?\n\nAxios를 사용하세요 만약:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 요청/응답 인터셉터와 같은 기능이 필요합니다.\n- 자동 JSON 파싱을 선호합니다.\n- Node.js 및 오래된 브라우저와 같은 다른 환경에서 보다 넓은 호환성이 필요합니다.\n\nFetch를 사용하실 때:\n\n- 추가 라이브러리 없이 네이티브 솔루션을 선호합니다.\n- 모던 브라우저에서 작업 중이십니다.\n- 요청 및 응답 처리에 대한 더 많은 제어를 원합니다.\n\n# Express를 사용해야 하는 경우?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Express를 사용하면:\n  - 서버 측 애플리케이션이나 API를 구축 중일 때.\n  - 견고한 라우팅 및 미들웨어 지원이 필요할 때.\n  - Node.js 생태계 내에서 작업하며 유연하고 확장 가능한 프레임워크가 필요할 때.\n\n# 결론\n\n웹 개발 작업에 적합한 도구를 선택하는 것은 효율적이고 확장 가능하며 유지보수가 쉬운 애플리케이션을 만드는 데 중요합니다. Axios와 Fetch는 각자의 장점을 가지고 있어 클라이언트 측에서 HTTP 요청을 처리하는 데 탁월한 선택지입니다. 반면 Express는 서버 측 애플리케이션과 API를 구축하는 데 강력한 프레임워크입니다.\n\n이 상세한 비교가 여러분이 이 도구들을 언제, 어떻게 효과적으로 사용해야 하는지 이해하게 도와드리기를 바랍니다. Axios, Fetch, 그리고 Express를 숙달함으로써 여러분은 다양한 웹 개발 과제에 대처할 수 있는 역량을 갖추게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 댓글에 생각을 공유하거나 궁금한 점을 질문해 주세요.\n\n만약 이 글이 도움이 되었다면 박수를 보내고 동료 개발자들과 공유해주세요. 앞으로 더 많은 웹 개발 통찰과 튜토리얼이 기대되니 기대해 주세요!\n\nAditya Singh.","ogImage":{"url":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"},"coverImage":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png","tag":["Tech"],"readingTime":4},{"title":"NinjaCart SDE 2 프론트엔드 인터뷰 경험","description":"","date":"2024-05-18 21:40","slug":"2024-05-18-NinjaCartSDE2frontendInterviewExp","content":"\n\n친구로부터 닌자카트 인재영입 담당자의 전화번호를 받았어요\n\n# 면접 1 — 기본 JS 이해\n\n1번 질문 — 디바운싱과 쓰로틀링에 관련된 질문입니다. 이 두 기술의 차이 및 실제 적용법을 말해주세요.\n\n2번 질문 — 프로미스와 setTimeout을 활용한 출력 관련 질문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(1);\n\nsetTimeout(function () {\n    console.log(2);\n}, 0);\n\nPromise.resolve()\n    .then(function () {\n        console.log(3);\n    })\n    .then(function () {\n        console.log(4);\n    });\n```\n\n3번 문제 — 클로저 및 setTimeout을 기반으로 한 출력 문제\n\n```js\nfor (var index = 1; index \u003c= 3; index++) {\n    setTimeout(function () {\n        console.log('after ' + index + ' second(s):' + index);\n    }, index * 1000);\n}\n```\n\n4번 문제 — 중첩된 배열을 평평하게 만드는 함수를 작성하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5번 질문 — useEffect와 useMemo를 기반으로 함\n\n# 2차 인터뷰 — 머신 코딩 및 문제 해결\n\n1번 질문 — 사용자 정의 React 탭 컴포넌트 만들기\n해결책\n\n2번 질문 — 실패하면 프라미스를 다시 시도하는 함수 만들기 (질문 링크)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3차 면접 — 매니저 면접\n\n매니저는 하르야나 출신이셔서 저희는 그냥 평범한 대화를 나눴어요 (아버지의 친구와 얘기하는 느낌이었어요 😂)","ogImage":{"url":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"},"coverImage":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png","tag":["Tech"],"readingTime":1},{"title":"파이썬과 언더스코어 (_)","description":"","date":"2024-05-18 21:38","slug":"2024-05-18-Pythonandtheunderscore_","content":"\n\n## 파이썬 프로그래밍\n\n![Python Programming](/assets/img/2024-05-18-Pythonandtheunderscore__0.png)\n\n밑줄 문자인 _는 파이썬 프로그래밍에서 중요한 역할을 하는 경우가 많습니다. 모든 파이썬 개발자는 이 다재다능한 특성을 이해하고 코딩에서 어떻게 효과적으로 밑줄을 활용할지 알아야 합니다. 가독성을 향상시키고 비공개 속성을 관리하는데부터 데이터 처리와 국제화에서 특정 기능을 활용하는 데까지, 밑줄은 단순한 문자가 아니라 파이썬 구문에서 가장 중요한 문자 중 하나로, 파이썬 언어에서 근본적인 도구입니다.\n\n이 기사에서는 파이썬에서 밑줄의 다양한 역할을 분석하며, _이 파이썬 언어에서 필수적인 문자가 되도록 하는 일반적이고 특수한 사용 사례를 살펴보겠습니다. 초보자든 숙련된 프로그래머든 밑줄의 용도를 이해하면 코딩 기술을 획기적으로 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 밑줄 사용 사례\n\n## 명명\n\n밑줄의 가장 일반적이고 중요한 사용 사례는 아마도 명명일 것입니다. PEP 8에 따르면,\n\n따라서 밑줄은 함수와 변수 이름에서 단어를 구분하는 데 사용됩니다. 동일한 관례는 메서드 이름과 클래스 인스턴스 변수에도 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 관용적인 네이밍 규칙이야. 다양한 프로그래밍 언어에서 사용되는 가장 중요한 네이밍 규칙은 다음과 같아:\n\n- 카멜 케이스 (myVariableName): 첫 번째 단어는 소문자로, 다음 단어의 첫 글자는 대문자로 쓰는 방식. 사용되는 언어: JavaScript, Java, C#, Swift.\n- 파스칼 케이스 (MyVariableName): 각 단어의 첫 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(클래스 이름으로), C#, Pascal, Java, C++.\n- 스네이크 케이스 (my_variable_name): 단어는 소문자로 쓰고 밑줄로 구분하는 방식. 사용되는 언어: Python(변수와 함수 이름으로), Ruby.\n- 대문자 스네이크 케이스 (MY_VARIABLE_NAME): 단어들을 밑줄로 구분하고 모든 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(상수로), C, C++, Java.\n- 케밥 케이스 (my-variable-name): 단어는 소문자로 쓰고 하이픈으로 구분하는 방식. 사용되는 곳: URL 및 CSS 클래스 이름.\n- 헝가리안 표기법 (iCount, strName): 변수 이름에 타입이나 범위를 나타내는 접두사를 사용하는 방식. 사용되는 곳: 오래된 C 및 C++ 코드.\n\n밑줄을 사용하는 파이썬 변수명의 예시는 다음과 같아:\n\n```python\nwrite_to_database()\nread_data()\n\ndf_history\ndf_actual\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서 밑줄은 또다른 역할을 해요. PEP 8에 따르면, 예약된 이름과 충돌하는 이름(예: 인수 이름)을 만들어야 한다면, 이름 끝에 밑줄을 추가할 수 있어요.\n\n흔한 사용 예로는 class_와 type_이 있어요.\n\n밑줄은 상수의 이름에도 사용돼요. 다시 한 번 PEP 8에 따르면:\n\n아래는 상수 이름의 예시 세 가지예요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nNO_OF_DAYS\nSIGNIF_LEVEL\nRUN_DEBUGGER\n```\n\n알다시피 밑줄은 Python에서 사용되는 다양한 역할을 합니다. 몇 가지는 다른 것보다 더 중요하지만 — 중요한 점은 Python에서 사용되는 몇 가지 명명 규칙이 밑줄에 매우 의존한다는 것입니다.\n\n그러나 Python 클래스는 일반적으로 밑줄을 사용하지 않습니다. 따라서 book_publisher처럼 클래스를 이름 짓지 않을 것입니다. BookPublisher로 짓겠죠. list나 dict와 같이 잘 알려진 예외가 있긴 하지만, 여러분이 직접 이러한 예외를 만들어서는 안 된다는 뜻입니다.\n\n## Dunder (double underscore, or magic) methods\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 역할은 명명과 관련이 있지만, 여기서는 파이썬 언어의 내부 이름에 대해 이야기합니다. 말하는 것은 이른바 매직 메서드의 이름에 많은 언더스코어가 있는 것을 볼 수 있습니다. 이들은 더블 언더스코어(__)로 시작하고 끝나는 특수 메서드들입니다. 더블 언더스코어를 사용하기 때문에 이러한 메서드들은 때로 \"던더\" 메서드라고도 불립니다 — 던더란 더블 언더스코어의 줄임말입니다.\n\n던더 메서드들은 다양한 파이썬 언어 기능과 구문에서 사용됩니다. 이들의 이름에 있는 더블 언더스코어는 이 메서드들이 특별하다는 것을 나타내는 것이 중요합니다. 이 명명 규칙은 사용자 정의 메서드가 내장 (매직) 메서드를 덮어쓰는 것을 방지합니다.\n\n다음은 파이썬에서 던더 메서드의 몇 가지 예시입니다:\n\n- __init__: 클래스 인스턴스를 생성하는 역할을 합니다.\n- __str__: 객체에 사용되는 str() 및 print() 함수의 동작을 정의합니다; 더 자세한 내용은 이 기사를 참조하세요.\n- __len__: 컨테이너의 길이를 반환합니다.\n- __getitem__: 인덱싱을 허용하고 정의합니다.\n- __add__, __mul__ 등: 객체가 산술 연산을 지원하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의해야 할 점은 던더 메소드를 직접 사용해서는 안 되며, 대신 파이썬 인터프리터가 다양한 작업을 실행하는 중에 호출됩니다. 예를 들어, len(x)를 호출하면 파이썬 내부적으로 x.__len__()을 호출합니다. 후자를 사용해서는 안 되지만, 정상적으로 작동합니다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 3]\n\u003e\u003e\u003e len(x)\n3\n\u003e\u003e\u003e x.__len__()\n3\n```\n\n새로운 사용자 정의 던더 메서드를 정의하지 않는 것이 좋은 습관입니다. 기존 마법 메서드를 덮어쓰거나 사용자 정의 클래스에서 정의하는 것은 괜찮습니다.\n\n## 특수 속성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더블 언더스코어로 시작하고 끝나는 메서드를 매직 또는 던더라고 부르지만, 이 네이밍 규칙을 따르는 속성은 일반적으로 특별 속성이라고 불립니다. 파이썬에 의해 자동으로 생성되고 관리되는 이러한 속성들은 객체에 관한 정보를 제공합니다. 몇 가지 예시를 확인해봅시다:\n\n- __name__: 모듈, 클래스, 클래스 메서드 및 함수에서 사용됩니다. (재미있게도, functools.partial을 사용하여 작성된 부분 함수는 이 속성이 없습니다) 객체의 이름을 유지하는 데 사용됩니다.\n- __doc__: 모듈, 클래스, 메서드 또는 함수의 독스트링을 보존합니다.\n- __file__: 모듈이 로드된 파일의 경로를 저장하는 데 사용됩니다.\n\n## 더미 변수\n\n밑줄은 더미 변수로 사용되는 빈번한 용도로 사용됩니다. 이것은 현재 코드에서 사용되지 않는 변수를 나타내는 이름으로 밑줄을 사용한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이런 것은 종종 루프에서 사용되는데, 루핑 변수를 사용하지 않을 때입니다. 다음 상황을 비교해보세요:\n\n루핑 변수를 사용하는 경우:\n\n```js\n\u003e\u003e\u003e for i in range(1, 4):\n...     print(f\"number {i}\")\n1\n2\n3\n```\n\n루핑 변수를 사용하지 않는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e for _ in range(3):\n...     print(\"주마 주마\")\n주마 주마\n주마 주마\n주마 주마\n```\n\n또한, 객체를 반환하는 함수나 메서드에서 해당 객체를 사용하지 않을 때 밑줄을 사용하는 것이 좋은 습관입니다. 예를 들어 여기서처럼:\n\n```js\ndef save(obj: Any, path: pathlib.Path) -\u003e bool:\n    # 객체가 성공 여부에 관계없이 저장됩니다.\n    if not success:\n        return False\n    return True\n\n_ = save(obj, pathlib.Path(\"file.csv\")\n```\n\n여기서는 save()의 출력을 _에 할당했는데, 이는 코드에서 이 출력을 사용할 필요가 없기 때문입니다. 만약 사용해야 한다면, 다음과 같이 하게 됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n저장된 = save(obj, pathlib.Path(\"file.csv\")\n```\n\n자주 볼 수 있는 대안은 – 내 생각에는 나쁜 – 사용법이 있습니다. 여기서는 출력이 무시됩니다:\n\n```js\nsave(obj, pathlib.Path(\"file.csv\")\n```\n\n이 접근 방식이 마음에 들지 않는 이유는 save() 함수가 아무것도 반환하지 않는 것처럼 보이기 때문입니다. 함수의 출력을 무시하는 경우는 항상 None을 반환할 때뿐이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프라이빗 메소드 및 속성 표시\n\nPython에는 OOP에서 진정한 은행 메소드나 속성이 없습니다. 이에 대해 여기에서 읽을 수 있습니다:\n\n그럼에도 불구하고 사용자에게 클래스 메소드나 속성 중 어떤 것을 프라이빗으로 유지하길 원하는지를 알리는 데 언더바(_)를 단일(_) 또는 이중(__)으로 이름 앞에 두고 표시할 수 있습니다. 차이점을 배우려면 위의 기사를 읽어보세요. 이렇게 하면 사용자에게 클래스 외부에서 이러한 메소드나 속성을 사용하지 말아야 한다고 알리는 것과 같습니다. 사용자는 어쨌든 할 수 있지만, 그들에게는 이를 하지 말아야 한다고 알려졌습니다.\n\n다음과 같은 클래스를 고려해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nclass Me:\n    def __init__(self, name, smile=\":-D\"):\n        self.name = name\n        self.smile = smile\n        self._thoughts = []\n\n    def say(self, what):\n        return str(what)\n\n    def _think(self, what):\n        self._thoughts += what\n```\n\n우리에게는 나를 나타내는 Me 클래스가 있어요. 다음과 같이 나 자신을 만들 수 있어요:\n\n- .name, public 속성 → 당신의 이름은 분명히 공개적이에요\n- .smile, public 속성 → 당신의 미소는 외부에서 보여지기 때문에 분명히 공개적이에요\n- ._thoughts, private 속성 → 당신의 생각은 확실하게 비공개적이죠?\n\n두 개의 public 속성은 언더스코어 없이 이름이 지어지고, 유일한 private 속성은 이름이 언더스코어로 시작해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 메서드들을 살펴보겠습니다:\n\n- .say(), 공개 메서드 → 무언가를 말할 때, 사람들이 듣을 수 있습니다.\n- ._think(), 비공개 메서드 → 무언가를 생각할 때, 그것은 개인적인 생각입니다. 만약 크게 말하고 싶다면 공개 .say() 메서드를 사용해야 하지만, 생각을 자신에게 간직하고 싶다면 비공개 _think() 메서드를 사용해야 합니다.\n\n비밀 생각을 대대로 말할 수 있는 공개 메서드를 만들 수 있습니다:\n\n```js\ndef say_thought(self, which):\n    return self._thoughts[which]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 대화형 세션에서의 마지막 작업\n\nPython 3에서 밑줄은 대화형 세션에서의 마지막 작업 결과를 저장하는데 사용됩니다. 이것은 이전 계산이 이름에 할당되지 않았을 때 새로운 작업에서 이전 작업의 결과를 빠르게 사용하는 데 유용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e 1 + 2\n3\n\u003e\u003e\u003e _ * 3\n9\n\u003e\u003e\u003e y = 10\n\u003e\u003e\u003e _\n9\n\u003e\u003e\u003e 100\n\u003e\u003e\u003e _\n100\n```\n\n보시다시피 밑줄은 이름에 할당되지 않은 마지막 작업의 결과만 유지하며, 그것이 계산이 아닌 객체일 경우에도(위 코드 블록의 100처럼) 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 숫자 값 형식 지정\n\nPython 3.6에서는 밑줄을 사용하여 대형 숫자 값을 더 쉽게 읽을 수 있게 하는 기능이 추가되었습니다. 이 기능은 대형 정수에 특히 유용하지만 부동 소수점 수에도 적용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e x = 1_000_000\n\u003e\u003e\u003e x\n1000000\n\u003e\u003e\u003e 1.009_232_112\n1.009232112\n\u003e\u003e\u003e 1_021_232.198_231_111  \n1021232.198231111\n```\n\n보통 대형 정수에 많이 사용되지만 밑줄은 소수값의 가독성을 향상시키는 데도 도움이 됩니다. 이러한 방식은 덜 사용되지만 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## functools.singledispatch 사용 사례\n\nfunctools.singledispatch에서 밑줄(_)은 특정 타입을 처리하기 위한 익명 구현을 나타내기 위해 함수 이름으로 흔히 사용됩니다. 이 스타일 선택은 함수의 이름이 중요하지 않으며, 오히려 함수가 처리하는 타입이 중요하다는 것을 시사합니다. 이 사용법은 네임스페이스를 깨끗하게 유지하는 데 도움이 되며, 로직이 직접 호출을 위한 것이 아니라 singledispatch 메커니즘에 직접 연결되어 있음을 강조합니다. 다음은 PEP 443에서의 예시입니다:\n\n```js\n\u003e\u003e\u003e from functools import singledispatch\n\u003e\u003e\u003e @singledispatch\n... def fun(arg, verbose=False):\n...     if verbose:\n...         print(\"Let me just say,\", end=\" \")\n...     print(arg)\n\u003e\u003e\u003e @fun.register(int)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Strength in numbers, eh?\", end=\" \")\n...     print(arg)\n...\n\u003e\u003e\u003e @fun.register(list)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Enumerate this:\")\n...     for i, elem in enumerate(arg):\n...         print(i, elem)\n```\n\n이 설정에서 _는 해당 타입에 대한 동작을 구현하여 사용되지 않는 함수 이름으로 네임스페이스를 혼란스럽게 만들지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에 MyPy와 같은 정적 체커를 사용하려면, _를 여러 번 정의하고 있다는 오류가 발생할 수 있다는 점을 알아두세요. 이 문제의 가장 간단한 해결책은 _가 정의된 줄 끝에 # type: ignore 주석을 추가하는 것입니다. 또 다른 방법으로는 현재 _로 호출되는 이러한 함수들을 _로 명명하는 것이 있습니다. 이는 functools.singledispatch에 대한 일반적이지 않은 접근법일 수 있습니다.\n\n## 국제화와 지역화\n\n국제화(일반적으로 i18n으로 약어)와 지역화(약어로 l10n)는 응용프로그램을 다른 언어와 지역에 적응 가능하게 만들어줍니다. 국제화를 통해 응용프로그램은 코드를 수정하지 않고도 다양한 언어와 지역에 적응할 수 있습니다. 반면에 지역화는 국제화된 소프트웨어를 특정 지역이나 언어에 맞게 적응시키는 데 도움을 줍니다. 이는 로케일별 구성 요소 추가 및 텍스트 번역을 통해 이루어집니다.\n\nPython에서는 gettext 모듈을 사용하여 이러한 두 가지 프로세스를 수행할 수 있습니다. 이를 통해 응용프로그램이 여러 언어를 지원할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngettext에서는 번역할 문자열을 표시하는 gettext 함수에 대한 별명으로 밑줄(_)을 사용하는 것이 일반적입니다:\n\n```js\n\u003e\u003e\u003e import gettext\n\u003e\u003e\u003e import locale\n\n로캘을 폴란드어로 설정:\n\u003e\u003e\u003e locale.setlocale(locale.LC_ALL, \"pl_PL\")\n\n.mo 번역 파일의 경로를 설정하고 텍스트 도메인을 선택:\n\u003e\u003e\u003e gettext.bindtextdomain(\n...     \"myapp\",\n...     \"/path/to/my/locale/directory\"\n... )\n\u003e\u003e\u003e gettext.textdomain(\"myapp\")\n\n밑줄은 일반적으로 gettext.gettext의 별명으로 사용됩니다:\n\u003e\u003e\u003e _ = gettext.gettext\n\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n여기서 _()은 번역할 텍스트를 감싸 줍니다. 번역이 있는 로캘에서 실행되면 gettext.gettext() 및 따라서 _()가 번역된 문자열을 가져옵니다. 밑줄을 사용하는 것은 단순히 더 간단합니다; 비교해 보세요:\n\n```js\n\u003e\u003e\u003e gettext.gettext(\"Hello, World!\")\nWitaj, świecie!\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특히 앱이 gettext.gettext 또는 _을 광범위하게 사용하는 경우에 유용합니다.\n\n## 언패킹 시 값을 무시하는 방법\n\n파이썬에서는 시퀀스를 언패킹할 때 불필요한 값을 무시하기 위해 언더스코어(_)를 사용할 수 있습니다. 이렇게 하면 코드가 더 깔끔하고 가독성이 높아지며, 코드에서 전혀 사용되지 않는 변수를 정의하지 않아도 됩니다.\n\n따라서 이해할 필요가 없는 값들을 언더스코어(_)에 할당하여 일회용 변수로 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e a, _, b = (1, 2, 3)\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n3\n```\n\n여기서는 _ 가 중간 값을 무시하는 데 사용되었습니다 (2).\n\n여러 값이 무시해야 하는 경우, 특히 더 긴 시퀀스의 경우에는 *_ 를 사용할 수 있습니다:\n\n```js\n\u003e\u003e\u003e a, *_, b = [1, 2, 3, 4, 5]\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스트의 첫 번째 값과 마지막 값은 각각 a와 b에 할당되었습니다. 다른 값들 — 2, 3, 4 — 은 * _에 할당되어 무시되었음을 의미하며 더 이상 사용되지 않을 것입니다.\n\n이렇게 밑줄을 사용하면 코드의 가독성이 향상되어 특정 값들이 사용되지 않고 더 이상 필요하지 않음을 명확히 합니다. 이는 코드와 관련 데이터에 초점을 유지하는 데 도움이 됩니다. 게다가, 이 세 값을 변수에 할당하는데 사용하지 않는다면, 왜 할당해야 할까요? 이는 좋은 코딩 스타일에 어긋날 것입니다.\n\n# 결론\n\n하나의 작은 문자, 간단한 한 줄, 밑줄은 파이썬 프로그래밍에서 굉장히 유용한 문자입니다. 이것은 파이썬 프로그래머에게 꼭 필요한 도구로 사용되는 다양한 용도를 가지고 있습니다. 또한 이것은 파이썬 자체의 중요한 요소이며, 가끔 _이 무엇을 의미하는지 모른다면 문제를 유발할 수 있으며, 최소한 파이썬 코드를 오해하게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언더스코어의 가장 중요한 사용 사례를 다루었어요. 그러나 덜 중요한 경우 중 일부를 빠뜨렸을 수도 있어요. 그럴 경우에는 댓글로 알려주세요. 어쨌든, 이러한 다양한 사용 사례들로 인해 언더스코어는 파이썬 프로그래밍에서 없어서는 안 될 문자로 자리를 잡았어요. 이 언더스코어는 아마도 이 언어에서 가장 유용한 문자이며, 모든 파이썬 프로그래머는 그 다양한 사용 사례에 익숙해져야 해요.","ogImage":{"url":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png"},"coverImage":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png","tag":["Tech"],"readingTime":10},{"title":"인공지능으로 감정 분석 성능 높이기","description":"","date":"2024-05-18 21:33","slug":"2024-05-18-ElevatingSentimentAnalysis","content":"\n\n## Unsloth를 사용하여 LLaMA-3 8B를 세밀하게 조정하기\n\n# 소개\n\nMeta의 LLaMA-3 8B와 같은 오픈 소스 대형 언어 모델(LLM)은 80억 개의 매개 변수를 갖고 있어 감정 분석과 같은 복잡한 언어 작업에 대처하기 위해 설계되었습니다. 본 기사에서는 Unsloth를 사용하여 금융 감정 분석을 위해 LLaMA-3 8B를 세밀하게 조정하는 방법을 살펴봅니다. 이 안내서는 사용자가 사용자 정의 데이터 세트를 만들고 모델을 세밀하게 조정하며 그 성능을 평가하는 데 도움이 될 것입니다.\n\n## 학습 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- LLaMA-3 8B 개요: LLaMA-3 8B 모델의 뛰어난 기능과 이점, 그리고 세밀조정 양자화 성능 주변의 논란을 이해하세요.\n- 사용자 지정 데이터셋: 공개 데이터와 합성 결과를 혼합하여 데이터셋을 구축하는 방법을 배우세요. 대규모 생성을 위한 코드에 대해 실습해 보세요.\n- 세밀조정 워크플로우: Unsloth 노트북을 사용하여 감성 분석 모델을 세밀조정하는 과정을 마스터하세요. 설정부터 실행까지 체험해 보세요.\n- GGUF 내보내기: 일반 그래프 유니버셜 포멧 (GGUF)으로 내보내는 방법을 알아보고, 성능을 향상시키고 배포를 간단하게 하는 방법을 발견하세요.\n- Ollama 배포: Ollama에서 사용자 지정 GGUF 모델을 효율적으로 추론해 보세요. 성능을 향상시키기 위한 전문적인 프롬프팅 기술을 탐구하세요.\n- 성능 통찰: 제공된 Python 스크립트를 사용하여 다른 세밀조정된 모델을 비교하세요. 최상의 구성 설정을 찾기 위해 성능을 객관적으로 평가하세요.\n- 평가: Mistral 7b 및 Dolphin-Mistral 7b 2.8와 같은 양자화 및 모델간의 차이를 제시하고 측정하세요.\n- 이상 감지: 철저한 평가를 통해 이상을 발견하고 해결하는 방법을 배우세요. 모델의 신뢰성을 보장하세요.\n\n이제 함께 문서에 다가가서 오늘 제공되는 가장 고급 오픈 소스 언어 모델 중 하나를 활용하여 감성 분석 능력을 향상시켜봅시다.\n\n## 세밀조정 이해\n\n세밀조정은 미리 훈련된 모델을 특정 작업이나 데이터셋에 맞게 조정하여 성능과 특정 응용 프로그램에 대한 적합성을 향상시키는 프로세스입니다. LLaMA-3 8B와 같은 대규모 언어 모델(LLM)의 맥락에서 세밀조정은 모델을 더 작고 작업별 데이터셋에 다시 훈련시킴으로써 감성 분석과 같은 작업에 특화되도록 하는 과정을 말합니다. 이는 모델의 매개변수를 조정하여 새로운 데이터의 미묘한 점을 더 잘 포착할 수 있도록 하는 것으로 달성됩니다. 세밀조정은 사전 훈련된 모델의 강점을 활용하면서도 특정 요구 사항을 충족시키기 위해 모델을 맞춤화하는데 큰 도움이 될 수 있습니다. 이 문서에서는 Unsloth를 사용하여 LLaMA-3 8B의 세밀조정과정에 대해 탐구하며, 특히 금융 분야에서의 감성 분석 성능 향상을 보여줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 금융 분야에서 감성 분석 적용하기\n\n금융 분야에서의 감성 분석은 뉴스 기사, 소셜 미디어 게시물 및 기타 텍스트를 분석하여 특정 주식이나 시장 전반에 대한 시장 감정을 파악하는 것을 의미합니다. 긍정적, 부정적 또는 중립적 톤을 식별함으로써 투자자들은 대중의 인식과 시장 트렌드에 대한 통찰력을 얻을 수 있습니다. 예를 들어, 특정 회사의 수익과 혁신에 대한 지속적인 긍정적인 뉴스는 해당 주식 가격의 상승을 시사할 수 있으며, 부정적인 감정은 하락을 나타낼 수 있습니다. 이 기술은 자연어 처리를 사용하여 질적 데이터를 양적 신호로 변환하여 결정력 있는 의사결정 및 전략적 투자 계획을 돕습니다.\n\n## Meta의 LLaMA-3 8B: 개요\n\nMeta LLaMA 3 8B는 Meta AI가 개발한 80억 개의 파라미터를 갖춘 최첨단 언어 모델입니다. LLaMA 3 가족의 일부로, 다양한 자연어 처리 작업을 위한 사전 훈련 및 명령 조정된 버전을 포함하고 있습니다. 이 모델은 최적화된 트랜스포머 아키텍처, 그룹화 쿼리 어텐션(GQA) 및 더 큰 어휘를 갖춘 새로운 토크나이저를 특징으로 하여 효율성과 멀티언어 기능을 향상시켰습니다. 상업 및 연구용으로 설계된 LLaMA 3 8B는 대화 생성, 추론 및 코드 생성에 뛰어나며, 소비자용 하드웨어에 배포할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png\" /\u003e\n\n# 개요\n\n본 문서는 세 가지 주요 섹션으로 나누어져 있습니다. 각 섹션은 섬세 조정 과정에서 중요한 단계를 대표합니다:\n\n- 데이터셋 구축: 먼저 공개 소스에서 데이터를 수집하고 표준화된 형식으로 변환합니다. 이는 데이터를 정리, 정규화 및 구조화하여 일관성과 신뢰성을 보장하기 위한 것입니다. 이외에 우리는 큰 언어 모델 (LLaMA 3 70b와 GPT-4 Turbo)을 활용하여 합성 데이터셋을 생성하여 교육 데이터의 다양성과 양을 향상시킵니다.\n- 세밀 조정: Unsloth 라이브러리를 사용하여 준비된 데이터셋으로 선택한 기본 모델을 섬세 조정합니다. Unsloth는 훈련 과정을 최적화하여 높은 정확도를 유지하면서 메모리 사용량과 훈련 시간을 크게 줄입니다.\n- 테스트: 포괄적인 테스트 단계에서 성능을 측정하고 이상 현상을 식별하기 위해 여러 번 반복합니다. 결과를 평가하기 위해 통계 분석을 사용하여 fine-tuned 모델이 성능 기준을 충족하는지 확인합니다. 이 단계는 모델의 강점과 개선 영역을 이해하고 행동과 정확도에 대한 가치 있는 통찰을 제공함으로써 모델을 이해하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터셋 만들기\n\n이 섹션에서는 다양한 스크립트를 사용하여 포괄적인 감성 분석 데이터셋을 구축하는 과정을 안내해 드리겠습니다. 각 단계에서는 다른 유형의 데이터를 처리하고 결합하여 기계 학습 모델에서 사용할 수 있도록 준비합니다. 각 스크립트의 개요와 중요한 기능을 강조하여 제공할 것입니다.\n\n우리는 데이터셋을 준비하기 위해 단계별로 분할된 다양한 도구가 있는 코드 리포를 소유하고 있습니다. 해당 코드는 GitHub에서 찾을 수 있습니다.\n\n완성된 데이터셋은 41.4k개의 레코드가 포함되어 있으며 HuggingFace에서 다운로드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 세 가지 다른 공개 데이터 세트에서 데이터를 수집합니다. 단계 1은 항공사 심정 데이터 세트에서 트윗을 처리하고, 단계 2는 금융 문구 은행에서 감정 분석을 처리하며, 단계 3은 newsdata.io에서 기사를 처리합니다. 각 단계는 데이터를 원하는 형식으로 변환하기 위해 고유한 전략이 필요합니다. 예를 들어 자신감 수준에 대한 가정을 만들고, 더 큰 언어 모델을 사용하여 뉴스 기사의 감정 레코드를 종합합니다. 이 접근법을 통해 더 많은 데이터를 수집하고, 더 큰 모델의 일반화 능력을 활용하여 효과적으로 감정 분석을 수행할 수 있습니다.\n\n## 단계 1: 트윗 처리\n\n파일: step-01-process_tweets.py\n\n이 스크립트는 항공사 심정 관련 트윗 데이터 세트를 처리하고, 결과를 새로운 CSV 파일에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 감정 매핑: 감정 레이블 (positive, neutral, negative)을 숫자 값 (1.0, 0.0, -1.0)으로 매핑합니다.\n- 데이터 처리: 입력 CSV를 읽어 각 트윗을 처리하여 감정을 추출하고, 감정, 확신 및 이유를 포함한 JSON 객체를 구성합니다.\n- 출력: 처리된 데이터를 문장 및 JSON 객체가 있는 새 CSV 파일에 저장합니다.\n- 데이터셋 출처\n\n## 단계 2: 금융 PhraseBank 처리\n\n파일: step-02-process_financial_phrase_bank.py\n\n이 스크립트는 금융 PhraseBank 데이터셋을 처리하고, 금융 뉴스 구절을 포함하며 출력을 CSV 파일에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 신뢰 점수: 감정 주석의 합의 수준에 따라 다른 신뢰 점수를 할당합니다.\n- 감정 매핑: 트윗 스크립트와 유사하게, 감정 레이블을 숫자 값에 매핑합니다.\n- 데이터 처리: 데이터셋을 읽고 각 구문을 처리하여 JSON 객체를 구성합니다.\n- 출력: 다양한 합의 수준에서 처리된 데이터를 단일 CSV 파일로 결합합니다.\n- 데이터셋 소스\n\n## 단계 3: 기사 처리\n\n파일: step-03-process_articles.py\n\n이 스크립트는 뉴스 기사 데이터셋을 처리하고 다양한 언어 모델을 사용하여 합성 출력을 생성하며 출력을 CSV 파일로 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- API 통합: 여러 AI 모델 (예: LLaMA 3 70b, OpenAI GPT-3.5, GPT-4 등)을 사용하여 감성 분석을 생성합니다. Perplexity.ai와 Groq는 LLaMA 3 70b에 대해 빠른 추론을 제공하지만 가장 강력한 모델은 아닙니다. 여러 실험을 거친 후, 총 비용이 $20 미만으로 들어갑니다. 전체 실행은 아마도 $10 미만으로 완료할 수 있습니다. 정말 높은 정확도를 원한다면 최상의 모델에 대해 비용을 지불해야 합니다.\n- 특수화된 프롬프팅: 시스템 메시지와 5번의 예시를 사용하여 안정적인 결과를 얻고, 결과를 pydantic 검증기를 통해 실행합니다. 이는 중요하며 추후 추론 테스트에도 같은 특수화된 프롬프팅을 사용할 것입니다. 신뢰할만한 결과를 얻기 위해 일부 조정이 필요할 수 있습니다.\n- 재시도 메커니즘: API 호출 실패를 처리하기 위한 재시도 메커니즘을 구현합니다. 처리된 레코드를 추적하여, 이 프로세스는 온 밤을 다 할 수 있습니다. 어떤 이유로든 실패한다면 다시 실행할 수 있습니다.\n- 데이터 유효성 검사: 생성된 JSON 응답이 유효한지를 Pydantic 모델을 사용하여 보장합니다.\n- 출력: 처리된 기사와 그들의 감성 분석을 CSV 파일에 저장합니다.\n- 데이터셋 출처\n\n## 단계 4: 출력 합치기\n\n파일: step-04-join_outputs.py\n\n이 스크립트는 트윗, 금융 구문, 그리고 기사 데이터셋의 결과를 하나의 CSV 파일로 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 살펴보기: 모든 데이터가 일관된 형식으로 되어 있고 인코딩 문제가 없도록 보장합니다.\n- JSON 유효성 검사: JSON 문자열을 유효한 형식으로 만족시키는지 확인합니다.\n- 결과물: 처리된 데이터셋에서 유효한 레코드를 결합하여 하나의 CSV 파일로 출력합니다.\n\n## 단계 5: HuggingFace 데이터셋 구축\n\n파일: step-05-build_hf_dataset_sharegpt.py\n\n이 스크립트는 결합된 데이터셋을 HuggingFace에 업로드할 수 있는 형식으로 변환하여 모델 공유와 훈련을 위한 형식으로 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 변환: 합쳐진 CSV 파일을 읽어 데이터를 정제하고 JSON 형식으로 변환합니다.\n- 데이터셋 구조: HuggingFace에서 모델 학습에 적합한 대화 형식으로 데이터를 구성합니다.\n- 출력: 변환된 데이터를 업로드할 준비가 된 JSON 파일로 저장합니다.\n- HuggingFace에서 데이터셋을 생성하고 해당 리포지토리에 JSON을 업로드할 수 있습니다.\n\n## 유틸리티 스크립트\n\n파일: utils/sentiment_response.py, utils/utils.py\n\n이 유틸리티 스크립트는 주요 스크립트 전반에 걸쳐 사용되는 도우미 함수와 클래스를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SentimentResponse: JSON 응답을 유효성 검사하기 위한 Pydantic 모델.\n- File Utilities: 메시지 읽기, 레코드 ID 생성, 처리된 레코드 로딩 및 저장을 위한 함수들이 포함되어 있습니다.\n\n이 안내서를 따라서 이 스크립트들을 조정하여 여러분만의 데이터셋을 처리하고 분석할 수 있습니다. 다양한 애플리케이션을 위한 포괄적인 감성 분석 데이터셋을 구축할 수 있습니다.\n\n![Elevating Sentiment Analysis](/assets/img/2024-05-18-ElevatingSentimentAnalysis_1.png)\n\n# 세밀한 조정 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 소개\n\n우리는 우리의 파인튜닝을 위해 Unsloth의 구글 콜랩 노트북을 사용했습니다. Unsloth는 효율적이고 매우 적은 리소스를 사용하며, 특히 메모리 소비가 낮습니다. 사용자용 하드웨어에서 로컬로 실행할 수 있으며, 구글 콜랩 서비스에서 실행하는 데 저렴합니다. T4 티어는 잘 작동하지만 느립니다. 우리는 41.4k 개의 레코드(1 에폭)에서 훈련을 진행하고, T4에서 약 9시간이 걸렸습니다. 실험을 기대할 수 있으므로, 테스트하기 위해서는 전체 에폭보다는 낮은 단계의 숫자를 사용하도록 해야 합니다. 변화는 항상 일어나기 때문에 때때로 의존성이 업데이트되어 무언가가 망가질 수 있습니다. Unsloth는 사용자가 토론하고 질문하는 매우 유용한 디스코드를 가지고 있습니다.\n\n우리가 사용한 노트북의 사본은 다음과 같습니다. 공식 노트북과 일부 변경 사항이 있으며, 포맷팅 및 템플릿에 ShareGPT 스타일을 사용합니다.\n\n[노트북 링크](https://colab.research.google.com/drive/1H40hAFkh8FnOivEEyEsMn6REN8HfKPwB?usp=drive_link)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUnsloth 라이브러리는 대규모 언어 모델의 세밀 조정을 가속화하고 메모리 사용량을 줄이기 위해 설계된 강력한 라이브러리입니다. Daniel과 Michael Han에 의해 만들어진 Unsloth는 역전파 최적화 및 PyTorch 모듈을 Triton 커널로 재작성하여 30배 빠른 훈련 속도와 60-80% 낮은 메모리 소비를 달성합니다. 다양한 NVIDIA GPU를 지원하는 Unsloth는 Hugging Face 생태계와 완벽하게 통합되어 LLAMA 및 Mistral과 같은 다양한 LLM 아키텍처와 호환됩니다. 놀랍게도, 기존 방법과 비교했을 때 0% 정확도 하락을 유지하며 LLM의 세밀 조정에 효율적인 솔루션을 제공합니다. HuggingFace에서 자세히 알아보세요.\n\n## Unsloth를 사용한 세밀 조정 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언슬로스 스크립트는 큰 언어 모델 (LLM)인 LLaMA-3 8B와 같은 모델의 미세 조정 과정을 간소화하고 가속화하는 데 도움이 됩니다. 이 노트북/스크립트가 하는 작업에 대해 간단히 설명해드릴게요:\n\n- 설치 및 설정: 스크립트는 Unsloth를 비롯한 필요한 라이브러리를 설치하는 작업으로 시작합니다. Unsloth는 교육 과정을 최적화하는 데 도움을 줍니다. 이 스크립트는 LLaMA, Mistral 및 기타 여러 모델을 지원하며 메모리 사용량을 줄이고 교육 속도를 높이기 위해 4비트 양자화를 사용합니다.\n- 모델 준비: Unsloth의 FastLanguageModel 클래스를 사용하여 사전 훈련된 모델을 불러옵니다. 최대 시퀀스 길이나 dtype와 같은 매개변수를 지정하여 하드웨어 (예: Tesla T4 GPU)에 맞는 성능 최적화를 수행합니다. 이 스크립트는 LoRA (Low-Rank Adaptation) 어댑터를 지원하며, 이를 통해 모델의 매개변수 중 작은 비율만 업데이트하여 메모리 사용량을 더욱 줄일 수 있습니다.\n- 데이터 준비: 논문의 스크립트는 Alpaca 데이터셋을 예시로 사용하며, 우리는 감정 분석 버전의 데이터셋을 사용합니다. 두 데이터셋은 표준화된 프롬프트 구조로 데이터를 포맷하며, 각 프롬프트에 무한 텍스트 생성을 방지하기 위한 종료 시퀀스 (EOS) 토큰이 포함되도록 합니다.\n- 모델 교육: Hugging Face의 SFTTrainer를 사용하여 스크립트는 준비된 데이터셋에서 모델을 미세 조정합니다. 배치 크기, 학습률, 단계 수와 같은 주요 교육 매개변수를 설정하여 교육 프로세스를 최적화합니다. 스크립트는 GPU 메모리 사용량을 모니터링하여 효율적인 자원 관리를 보장합니다.\n- 추론: 교육 후, 스크립트는 모델을 추론하기 위한 방법을 보여줍니다. 입력을 설정하고 출력을 생성하며 텍스트로 디코딩합니다. 또한 사용자가 생성된 텍스트를 토큰별로 확인할 수 있는 지속적 추론 옵션을 포함하고 있습니다.\n- 모델 저장: 스크립트는 미세 조정된 모델을 로컬에 저장하거나 Hugging Face의 허브에 푸시하는 방법을 제공합니다. 다양한 배포 시나리오에 유연하게 대응하기 위해 16비트, 4비트, 그리고 GGUF (일반 그래프 유니버설 형식)에 모델을 저장할 수 있는 기능도 제공됩니다.\n\n특히 GGUF 출력에 관심이 많은 이유는 대부분의 로컬 기기를 포함한 다양한 배포를 쉽게 할 수 있기 때문입니다.\n\n## GGUF\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGGUF, 또는 General Graph Universal Format은 LLaMA-3 8B와 같은 LLM(Large Language Model)의 배포 효율성과 유연성을 향상시키기 위해 설계된 파일 형식입니다. Llama.cpp 팀이 소개한 GGUF는 이전 버전인 GGML보다 개선된 단일 파일 배포, 확장성 및 빠른 모델 로딩을 위한 메모리 매핑을 제공합니다. 이 형식은 양자화된 모델에 특히 적합하여 성능을 저해하지 않으면서도 계산 리소스 수요를 줄일 수 있습니다. GGUF는 CPU 및 Apple 장치를 포함한 다양한 플랫폼에서 LLM의 배포 및 추론을 간소화하고자 하는 개발자에게 이상적인 선택입니다. 더 많은 정보는 HuggingFace에서 확인하세요.\n\n![image](/assets/img/2024-05-18-ElevatingSentimentAnalysis_2.png)\n\n# 테스트 및 추론\n\nAndreas Traczyk과 함께 공동 저술한 이 저장소는 다양한 모델에 대한 테스트 및 추론을 목적으로 설계되었습니다. GitHub에서 코드에 액세스할 수 있습니다. 이 저장소를 사용하여 다른 모델을 효과적으로 비교하고 성능을 분석하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/seandearnaley/llama_3_8b_sentiment_analysis_tests\n\n해당 저장소에는 감성 분석 작업에서 다양한 모델의 성능을 테스트하고 비교하는 파이썬 프로젝트가 포함되어 있습니다. 이 프로젝트는 로컬 모델 추론을 위해 Ollama 라이브러리를 활용하며, 감성 테스트 실행 스크립트, 비교 보고서 생성 및 결과 시각화를 위한 스크립트가 포함되어 있습니다.\n\n설치 지침은 README.md를 참고해주세요.\n\n## Specialized Prompting\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 중요한 단계는 데이터셋이 이러한 프롬프팅 기술(합성 데이터)을 사용하여 부분적으로 작성되었으며, 종종 미세 조정 대신에 이를 사용할 수 있습니다. 우리는 정말로 우리의 미세 조정에서 실제로 더 나은 성능을 얻고 있는지, 그리고 그것을 할 가치가 있는지를 평가하고 싶습니다. 신뢰할 수 있는 JSON 결과를 돌려받아 pydantic 검증을 통과하는 것이 목표입니다. 우리는 JSON을 원합니다. 파이썬 함수(예: 함수 호출)로 쉽게 전달할 수 있기 때문입니다.\n\n다음은 특별한 시스템 프롬프트입니다:\n\n```js\n금융 뉴스 기사에 대한 감성 분석을 수행하는 고급 AI 어시스턴트입니다. 받은 각 기사를 분류하고 아래의 JSON 스키마를 사용하여 분석 결과를 제공해주셔야 합니다:\n{\n    \"reasoning\": {\n      \"type\": \"string\",\n      \"description\": \"숫자 감성 값 결정에 사용된 논리를 설명하는 간단한 설명\",\n      \"required\": true\n    },\n    \"sentiment\": {\n      \"type\": \"number\",\n      \"description\": \"기사의 감성을 나타내는 부동 소수점 표현, 소수점 두 자리로 반올림됨. -1.0(부정적)부터 1.0(긍정적)까지의 범위로, 0.0은 중립적인 감성을 나타냄\",\n      \"required\": true\n    },\n    \"confidence\": {\n      \"type\": \"number\",\n      \"description\": \"분석이 얼마나 자신 있는지를 나타내는 부동 소수점 표현, 소수점 두 자리로 반올림됨. 0.0(자신 없음)부터 1.0(아주 자신 있음)까지의 범위\",\n      \"required\": true\n    }\n}\n\n이 스키마를 준수하는 유효한 JSON 객체로 항상 응답하세요. 응답에 다른 텍스트나 메시지를 포함시키지 마세요. Markdown을 제외하고 응답하세요.\n```\n\n그리고 우리는 5개의 예제로 스레드를 초기화합니다(5-shot 프롬프팅, 미세 조정은 0-shot을 제공하지만 이 작업에 특화되어 있습니다):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n금융 뉴스 기사가 다음과 같은 XML 태그로 둘러싸여 제공될 것입니다:\n\n\u003carticle\u003e{$ARTICLE}\u003c/article\u003e\n\n기사를 주의 깊게 읽고 언급된 회사의 잠재적인 주가에 대한 표현에 대해 분석해야 합니다.\n\n먼저, \"reasoning\" 속성 안에 기사의 감정을 분석하는 이유와 근거를 작성하세요. 감정을 평가하는 데 영향을 미치는 기사 내에서 중요한 포인트를 설명하고 주식 가격에 어떤 영향을 미칠 것으로 예상되는지 설명하세요.\n\n그런 다음 -1.0부터 1.0 사이의 숫자 점수를 출력하되, -1.0이 가장 부정적이고 0은 중립적이며 1.0은 가장 긍정적인 것으로 표현되도록 합니다. 이 점수를 \"sentiment\" 속성 안에 넣어주세요.\n\n감정 값은 감정이 얼마나 긍정적 또는 부정적인지에 따라 나타내십시오. 결론을 도출할 수 없는 경우 0.0의 감정 값을 제공해주세요.\n\n감정 값에 대한 확신 값은 감정 값을 얼마나 확신하는지에 따라 표시하십시오. 매우 확신하는 경우 1.0의 확신 값을 제공하십시오. 의심스러운 경우 0.0의 확신 값을 제공하십시오.\n\n스키마에는 아무런 변경도 가하지 마십시오. 저희 회사에게 중요합니다.\n\n예시:\n\n1. \u003carticle\u003eNVDA 주가가 수익을 능가하여 5% 상승합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"뉴스 기사는 긍정적인 수익을 보고하고 있으며, 이는 투자자 신뢰를 증가시키고 따라서 NVDA의 주가를 높일 가능성이 높습니다.\",\n  \"sentiment\": 0.75,\n  \"confidence\": 0.9\n}\n\n\n2. \u003carticle\u003eNVDA 주가는 석유 가격하락의 영향을 받을 수 있습니다. 분석가들은 NVDA의 에너지 부문 노출로 인해 주가 5% 하락을 예상합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"기사는 석유 가격 하락으로 인해 NVDA 주가에 부정적인 영향을 줄 수 있는 가능성을 시사하며, 이는 투자자 신뢰 감소로 이어질 수 있습니다.\",\n  \"sentiment\": -0.25,\n  \"confidence\": 0.8\n}\n\n3. \u003carticle\u003eApple의 혁신적인 AR 안경 최근 출시는 예상된 판매 목표를 달성하지 못했습니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"혁신적인 제품 출시에도 불구하고 판매 목표 미달은 부정적인 시장 반응을 야기할 수 있으며, Apple 주식 가치의 하락 가능성이 있습니다.\",\n  \"sentiment\": -0.5,\n  \"confidence\": 0.6\n}\n\n4. \u003carticle\u003eBoeing은 Emirates로부터 새 비행기에 대한 50억 달러 계약을 체결했으며, 강력한 미래 수입을 시사합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"대규모 계약 체결은 Boeing의 긍정적인 미래 수입 전망을 시사하며, 투자자 심리와 주식 가치를 높일 가능성이 높습니다.\",\n  \"sentiment\": 0.85,\n  \"confidence\": 0.9\n}\n\n5. Tesla 주식 값에 대한 감정을 판단하는 아래 기사에서 Tesla로의 감정을 결정하십시오:\n   \u003carticle\u003eTesla는 안전 문제로 10만 대의 차량을 회수합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"안전문제로 인한 대규모 회수는 Tesla의 브랜드 평판에 해를 끼칠 수 있으며 투자자 신뢰에 부정적인 영향을 줄 것으로 예상되어 주식 가치가 감소할 가능성이 있습니다.\",\n  \"sentiment\": -0.65,\n  \"confidence\": 0.7\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`generate_model_sentiments.py` 스크립트는 설정 가능한 횟수의 반복을 수행하며, 분산 등에 대한 평균값에 대한 테스트를 실행할 것입니다. 각 반복마다 JSON 파일은 다음과 같이 보입니다. 각 sentiment는 사전 캐싱된 기사에서 해싱되어 동일한 내용을 각 반복에 대해 평가하고 있습니다:\n\n```js\n{\n  \"average_sentiment\": 0.57,\n  \"time_taken\": 53.91,\n  \"sentiments\": {\n    ...\n    \"91ba90ac\": {\n      \"reasoning\": \"기사에 따르면 시장은 역대 최고치에 근접하며, BYD, Nvidia, Walmart 등 여러 기업들이 매수 신호를 보이고 있는 상태이며, 이는 이러한 주식에 대해 긍정적인 감정을 나타낸다.\",\n      \"sentiment\": 0.6,\n      \"confidence\": 0.8,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/m/ae28caa6-3ead-3745-aece-9ddb64e2ea1d/dow-jones-futures%3A-walmart%2C.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 23:52:02 +0000\",\n      \"time_taken\": 3.17\n    },\n    \"bf372e87\": {\n      \"reasoning\": \"기사에 따르면, Nvidia 주식은 목요일에 하락을 마쳤지만, 다음 주의 실적 보고 전에 칩 메이커를 둘러싼 긍정적인 전망으로 역대 최고치를 경신할 것으로 예상됩니다. 4월의 인플레이션 데이터로 인한 전체 시장의 긍정적인 움직임과 긍정적인 분석가 평가에 따른 기대감이 Nvidia 주식을 끌어올렸지만, 결국 0.3% 하락했습니다.\",\n      \"sentiment\": -0.15,\n      \"confidence\": 0.8,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/m/6ab7d488-38e1-3ef1-beef-bf75a726d6c2/nvidia-stock-couldn%E2%80%99t-close.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 20:30:00 +0000\",\n      \"time_taken\": 5.12\n    },\n    \"d4c4ccc1\": {\n      \"reasoning\": \"기사에서 Wolfe Research가 Nvidia(NVDA)와 Advanced Micro Devices(AMD)에 대한 긍정적인 전망과 Nvidia에 대한 1,200달러의 가격목표 인상을 논의하고 있으며, AMD의 Wolfe Alpha List 추가는 강력한 AI 제품 라인업을 강조하며 잠재적인 성장 기회를 시사합니다. 분석가의 AMD에 대한 우선순위 전략적 변경은 두 주식의 성과를 고려해 더 균형 잡힌 접근을 제안합니다.\",\n      \"sentiment\": 0.75,\n      \"confidence\": 0.85,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/video/chip-stocks-wolfe-research-bullish-201319388.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 20:13:19 +0000\",\n      \"time_taken\": 6.24\n    },\n    ...\n  }\n}\n```\n\n## 방법론\n\n저희는 Mac Pro M2 with 32gb을 사용 중이며, Ollama 0.1.38 버전을 사용하고 있습니다. Yahoo Finance의 동일한 뉴스 기사 세트에 대해 15회 반복 실행하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndefault_temperature: 0.2\ncontext_window_size: 8192\nnum_tokens_to_predict: 1024\n```\n\n## Ollama\n\nOllama은 클라우드 서비스가 필요 없이 사용자가 자신의 기기에서 오픈 LLMs를 로컬에서 실행할 수 있는 도구입니다. llama.cpp의 프론트 엔드로, GGUF 모델을 로드할 수 있습니다. 사용 편의성을 고려하여 설계되었으며 간단한 API, OpenAI 엔드포인트 호환성(즉, OpenAI를 지원하는 모든 것과 작동할 수 있음) 및 사전 빌드된 모델 라이브러리를 제공합니다. Ollama는 macOS, Linux 및 Windows에서 실행되며 CPU와 GPU를 사용할 수 있습니다. LangChain, LiteLLM 등 인기있는 프레임워크와 원활하게 통합됩니다. 로컬 실행을 통해 데이터 개인 정보 보호 및 지연 시간을 줄이므로 고급 NLP 기능을 효율적으로 활용하려는 개발자 및 연구자에게 이상적인 선택지입니다.\n\nHuggingFace에서 GGUF 파인 튜닝된 모델을 다운로드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGGUFs를 Ollama에 로드하려면 시스템 메시지와 템플릿이 포함된 사용자 정의 모델 파일이 필요합니다. 여기에서 사용 중인 양자화 수준에 해당하는 GGUF 파일로 교체하고 있습니다. llama3-8b-sentiment-may-3-2024-unsloth.Q4_K_M.gguf를 사용하고 Ollama로 가져올 때 원하는 이름을 지을 수 있습니다:\n\n```js\nollama create llama3:8b-instruct-sentiment_analysis-q4_K_M -f Modelfile\n```\n\n# 결과 및 평가\n\n이 섹션에서는 다양한 감성 분석 모델의 평가 결과를 제시하며, 주요 성능 메트릭 및 통계적 비교에 초점을 맞춥니다. 우리는 화학적인 성능 메트릭을 중시하여 세밀하게 조정된 감정 모델을 기본 모델과 비교하여 금융 감성 데이터 처리의 효율성과 정확도를 결정했습니다. 이러한 메트릭은 각 모델의 성능을 종합적으로 보여주며, 감성 분석 작업에 특화된 세밀하게 조정된 모델을 사용하는 장점을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기를 클릭하시면 인터랙티브 3D 시각화를 확인할 수 있어요\n\n# 감성 분석 모델 비교 결과 해석\n\n감성 분석 모델을 다룰 때는 성능을 이해하고 다양한 모델을 비교하는 것이 중요합니다. 저희 분석 결과를 해석하는 데 도움이 될 수 있는 간단한 안내서를 제공합니다. 모델 세부 정보, 성능 지표 및 통계적 비교가 포함되어 있어요.\n\n## 모델 세부 정보\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모델 이름: 사용된 특정 모델을 나타냅니다 (예: llama3_8b-instruct-fp16).\n- 양자화 수준: 모델에서 사용된 정밀도 수준을 나타냅니다 (예: q4, q5, fp16). q4 및 q5와 같은 낮은 수준은 더 적은 메모리를 사용하고 더 빨라질 수 있지만 정확성이 떨어질 수 있습니다.\n\n## 성능 지표\n\n- 속도 (초/샘플): 모델이 각 샘플을 처리하는 속도를 측정합니다. 낮은 숫자는 더 빠른 성능을 나타냅니다.\n- 유효한 JSON 응답률: 모델이 성공적으로 유효한 결과를 반환한 비율입니다. 높은 백분율은 더 나은 신뢰성을 나타냅니다.\n- 분산: 감정 점수가 얼마나 퍼져 있는지를 보여줍니다. 높은 분산은 점수가 넓게 퍼져 있음을 의미하며, 낮은 분산은 더 일관적임을 의미합니다.\n- 평균 감정 점수: 모든 샘플에 대한 평균 감정 점수로, 감지된 일반적인 감정(긍정적, 부정적 또는 중립적)을 나타냅니다.\n- 평균 신뢰도: 감정 예측의 평균 신뢰 수준입니다. 높은 값은 모델이 예측에 대해 더 확신한다는 것을 나타냅니다.\n- 추론: 모델로부터 샘플 설명을 제공하여 특정 감정을 예측한 이유를 보여줍니다. 모델의 결정 과정을 이해하는 데 도움이 됩니다.\n\n## 통계적 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세부 조정된 모델(감성 분석을 목적으로 디자인된)을 일반 용도 모델과 비교하기 위해 통계 검정을 사용합니다.\n\n- F-통계량과 P-값(분산): 이러한 값은 두 모델 사이의 감성 점수 변동을 비교하는 F-검정에서 나옵니다. 유의미한 p-값(일반적으로 0.05 미만)은 모델이 얼마나 일관성 있는지에 의미 있는 차이가 있다는 것을 의미합니다.\n- T-통계량과 P-값(평균): 이러한 값은 두 모델 사이의 평균 감성 점수를 비교하는 t-검정에서 나옵니다. 유의미한 p-값(일반적으로 0.05 미만)은 모델이 감지한 평균 감성에 의미 있는 차이가 있다는 것을 나타냅니다.\n\n## 결과 해석 방법\n\n- 추론 속도: 빠른 모델(낮은 속도)이 일반적으로 바람직합니다, 특히 실시간 애플리케이션에.\n- 신뢰성: 높은 유효 JSON 응답률을 가진 모델이 더 신뢰할 수 있습니다.\n- 일관성: 낮은 분산은 종종 더 나은 결과를 나타냅니다, 모델의 예측이 안정적이라는 것을 나타냅니다.\n- 감성과 확신: 높은 평균 감성 점수와 평균 확신 점수가 바람직합니다, 모델이 명확한 감성을 감지하고 예측에 대해 확신을 가지고 있음을 보여줍니다.\n- 통계적 유의성: 분산과 평균 비교를 위한 p-값이 0.05 미만인 경우, 모델 간에 유의미한 차이가 있다는 것을 제시합니다. 이는 특수화된(세부 조정된) 모델이 일반 용도 모델보다 실질적인 혜택을 제공하는지 결정하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시\n\nllama3_8b-instruct-fp16와 llama3_8b-instruct-sentiment_analysis-fp16을 비교해보세요:\n\n- Rate: 감성 분석 모델이 더 빠르다면, 실시간 요구에 더 적합합니다.\n- 유효한 JSON 응답 비율: 높을수록 에러가 적습니다.\n- 분산: 낮을수록 모델의 예측이 더 일관적합니다.\n- 평균 감성 점수: 높은 점수는 더 강한 전반적인 감성 탐지를 나타냅니다.\n- 평균 신뢰도: 높은 값은 모델이 예측에 대해 더 확신한다는 것을 의미합니다.\n- 통계적 테스트: p-값이 유의하다면, 성능 지표 간의 차이는 의미가 있습니다.\n\n이러한 지표와 비교를 이해함으로써, 초보자도 특정한 요구 사항과 맥락에 기반하여 사용할 감성 분석 모델에 대한 정보를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Financial Sentiment Analysis Model Comparison](/assets/img/2024-05-18-ElevatingSentimentAnalysis_3.png)\n\n# 금융 감성 분석 모델 비교\n\n## 소개\n\n이 분석의 목표는 금융 감성 분석을 위한 최적 모델을 식별하기 위해 세부 조정된 감성 분석 모델을 해당 원본 모델과 비교하는 것입니다. 감성 점수에 대한 분산, 평균 감성 점수, 평균 확신 점수 등 메트릭을 살펴보고 F-통계 및 T-통계를 사용하여 통계적 비교를 수행했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주요 지표 및 비교\n\n- 추론 속도(속도): 세밀하게 조정된 모델은 일반적으로 베이스 모델과 비교하여 처리 시간이 유사하거나 약간 향상됩니다. 예를 들어, llama3_8b-instruct-sentiment_analysis-q5_K_M은 샘플 당 4.16초의 속도를 보여주며, llama3_8b-instruct-q5_K_M은 샘플 당 4.28초의 속도로 처리됩니다.\n- 유효한 JSON 응답률: 세밀하게 조정된 모델과 베이스 모델 모두 대부분의 경우 100%의 유효한 JSON 응답률을 유지합니다. 이는 모델들 전반에서 높은 신뢰성을 나타냅니다. Mistral 7b는 모든 양자화 수준에서 오류가 있어 가장 신뢰할 수 없는 모델이 됩니다.\n- 감정 점수의 분산: 세밀하게 조정된 모델은 감정 점수의 분산이 더 낮습니다. 예를 들어, llama3_8b-instruct-sentiment_analysis-q5_K_M의 분산이 0.12인 반면, llama3_8b-instruct-q5_K_M은 0.36입니다. 낮은 분산은 더 일관된 예측을 시사합니다.\n- 평균 감정 점수: 세밀하게 조정된 모델은 일반적으로 더 높은 평균 감정 점수를 갖습니다. llama3_8b-instruct-sentiment_analysis-q5_K_M은 0.59의 평균 감정을 보여주며, 베이스 모델은 0.31입니다. 높은 평균 감정 점수는 보다 강력한 전체적인 감정 감지를 나타냅니다.\n- 평균 확신 점수: 세밀하게 조정된 모델은 일반적으로 베이스 모델에 비해 약간 낮은 평균 확신 점수를 보여줍니다. 이는 세밀한 교육이 감정 감지의 정확성에 더 초점을 맞추었기 때문일 수 있습니다.\n\n## 통계적 비교\n\n- F-통계량 및 P-값(분산): 세밀하게 조정된 모델과 베이스 모델 간에 분산에서 유의한 차이가 나타납니다. 예를 들어, llama3_8b-instruct-q5_K_M 대 llama3_8b-instruct-sentiment_analysis-q5_K_M은 F-통계량이 18.75 (p-value ` 0.01)입니다.\n- T-통계량 및 P-값(평균): 평균 감정 점수도 유의하게 다릅니다. 같은 비교에서 T-통계량은 -4.33 (p-value ` 0.01)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 신뢰도 점수 변동에 대한 설명\n\n세심한 모델 향상치 감소는 특정 훈련에 기인할 수 있습니다. 세심한 모델들은 특정 작업을 최적화하여, 기본 모델들이 처리하지 못하는 감성의 세심한 차이를 만들어내야 할 수 있습니다. 이 증가된 섬세함은 모델이 감정의 섬세한 변화를 잡아내도록 설계되어 있기 때문에 보다 신중한(낮은 신뢰도) 예측 방식으로 이어질 수 있습니다.\n\n## LLaMA 3 8B 양자화 주변의 논란\n\n인공지능 커뮤니티의 최근 토론은 LLaMA 3 8B 모델을 특히 Q4와 같은 낮은 비트폭으로 양자화하는 것에 중대한 문제점을 강조했습니다. 보고서에 따르면, 임의의 날짜 삽입, 단어 반복, 일관성 감소와 같은 문제를 포함한 출력 품질의 상당한 저하가 나타났다고 합니다. 이러한 성능 하락은 Mistral이나 이전 LLaMA 버전과 같은 다른 모델들과 비교했을 때 더욱 두드러지게 나타났습니다. LLaMA 3 모델의 방대한 사전 훈련과 높은 토큰 수는 양자화에 내재된 정밀도 손실에 민감해져, 이러한 고급 모델에 대한 양자화 기술을 최적화하기 위한 추가 연구가 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 감성 분석 모델에 대한 함의\n\n낮은 정밀도 문제: LLaMA 3 8B 모델을 Q4로 양자화할 때 정밀도가 낮아질 수 있어 감성 감지의 부정확성을 초래할 수 있습니다. 이로 인해 신뢰할 수 있는 감성 점수와 신뢰 수준에 영향을 줄 수 있습니다.\n\n## 클램핑과 반올림 효과:\n\n- 클램핑: 값이 특정 범위 내로 제한될 때 발생합니다. 감성 분석에서는 극단적인 감성 값(매우 긍정적 또는 매우 부정적)이 정확하게 표현되지 않을 수 있어 중립적인 출력이 더 많이 나올 수 있습니다.\n- 반올림: 숫자를 낮은 정밀도 형식에서 가장 가까운 표현 가능한 값으로 근사화하는 것을 의미합니다. 반올림 오차가 누적되어 감성 분석 출력의 품질이 저하될 수 있습니다.\n- 분산 관찰: 흥미로운 점은 Q4에서의 감성 점수에서 고정밀도 수준인 Q5, Q8 및 FP16과 비교하여 낮은 분산을 관측한 사용자들이 있었다는 것입니다. 일반적으로 고정밀도는 더 안정된 결과를 제공하나, 이상적인 결과는 고정밀도 손실에 민감해져 LLaMA 3 모델의 안정성에 영향을 미칠 수 있다는 것을 시사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실용적인 결과\n\n귀하의 감성 분석 모델에 대한 영향:\n\n- 출력 품질 감소: 4분기에서 양자화된 LLaMA 3 8B 모델을 사용할 때 감성 분석의 전반적인 품질과 일관성이 감소할 수 있습니다.\n- 일관성 없는 성능: 더 많은 불일치를 발견할 수 있으며, 예상치 못한 중립적 감성 점수 또는 감성 분석 결과에서의 이상한 패턴이 나타날 수 있습니다.\n- 권고 사항: 이러한 관측을 바탕으로 LLaMA 3 8B 모델에 대해 더 높은 정밀도 수준(Q8 또는 FP16)을 사용하거나, 양자화 처리를 더 잘 다루는 Mistral 또는 Dolphin-Mistral과 같은 다른 모델을 고려하는 것이 좋을 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 금융 감성 분석을 위해서는 llama3_8b-instruct-sentiment_analysis-q5_K_M과 같은 세밀하게 조정된 모델을 사용하는 것이 좋습니다. 이러한 모델들은 일관되고 강력한 감성 탐지를 제공하는 우수한 성능으로 인해 권장됩니다. 이러한 모델들은 기본 모델에 비해 의미 있는 개선을 제공하여 더 신뢰할 수 있고 정확한 감성 분석을 보장합니다. 하지만 특히 Q4에서 LLaMA 3 8B 양자화에 대한 논란이 있어 조심이 필요하며 양자화 기술에 대한 추가 연구와 최적화가 필요합니다.\n- Unsloth 노트북을 사용한 세밀한 조정은 LLaMA 3 8b 및 Mistral 7b와 같은 오픈 언어 모델에서 자신의 데이터를 세밀하게 조정할 수 있는 비교적 저렴한 경로를 제공합니다.\n- 함수 호출에 사용할 수 있는 신뢰할 수 있는 JSON 결과를 얻을 수 있습니다. 조정되지 않은 경우에는 특별한 프롬프트가 필요하지만 할 수 있습니다.\n- 감성 분석을 위해 세밀하게 조정된 LLaMA 3 8B는 몇 가지 장점을 제공합니다. 전문 프롬프트 트릭이 필요하지 않으며 모든 양은 낮은 분산과 적절한 신뢰도를 가지며 속도가 약간 향상되었습니다(프롬프트에 필요한 토큰 수가 줄어듦).\n- 데이터셋 및 훈련 시간에 개선할 여지가 있습니다. 합성 데이터 프롬프트를 조정해야 하며 1 epoch보다 길게 실행하면 손실이 감소하는 것으로 보입니다.\n- 웹 스크래핑은 복잡할 수 있으며, Yahoo Finance에서 스크래핑할 때 동일한 기사에 여러 회사가 언급되거나 유료 구독이 필요한 기사가 발생할 수 있습니다.\n- 특별한 시스템 프롬프트와 5번 예제를 사용하면 Llama 3 8B 모델이 모든 단계의 양자화 수준에서 올바른 JSON을 생성할 때 100%의 성공률을 달성합니다. 그러나 감성 점수의 변동성이 더 높으며 높은 신뢰도를 유지하면서 잠재적인 과신을 나타냅니다.\n- 동일한 시스템 프롬프트와 5번 예제를 사용하는 Mistral 7b Instruct는 FP16 양자화 수준까지도 올바른 JSON을 제대로 출력하지 못하는 경우가 종종 있습니다.\n- Dolphin-Mistral 7b-v2.8은 베이스 Mistral 7b보다 감성 분석에서 훨씬 우수한 성능을 보입니다. 특별한 프롬프트를 사용하면 100%의 성공률을 달성할 수 있습니다. 이는 Mistral 7b 베이스가 효과적으로 세밀하게 조정될 수 있다는 것을 시사합니다.\n\n## 다음 단계\n\n- 세밀한 조정을 위해서는 더 많은 시간과 노력이 필요합니다.\n- 다른 모델들에 대해 세밀하게 조정해 보세요. LLaMA 3는 특히 하위 양자화에서는 최고가 아닐 수 있습니다. Mistral-7b나 심지어 Phi-3을 시도하고 테스트 리포를 사용하여 결과를 비교해보세요.\n- 데이터셋을 향상시키세요. 이는 주로 개념 증명이었으므로 사용 가능한 데이터가 훨씬 많이 있습니다.\n- 숫자를 변경할 수 있는 산업 데이터 프롬프트와 특별한 프롬프트를 함께 조정해 보세요.\n- 합성 훈련에 더 많은 비용을 지불하세요. 이 세트가 구축된 후 GPT-o가 출시되었는데, 이는 50% 저렴하며 Batch API를 사용하고 24시간 이내에 작업을 완료할 경우 더 큰 할인을 받을 수 있습니다.\n- 우리가 한 세밀한 조정은 1 epoch(데이터 세트를 완전히 통과하는 것)만 포함했습니다. 더 오랜 시간 훈련하면 손실이 더욱 감소할 수 있습니다.\n\n## 마무리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서 다룬 기술들로 사용자 지정 데이터를 사용하여 세밀하게 조정된 모델을 자신있게 만들 수 있습니다. 우리의 연구 결과는 세밀하게 조정된 변형이 특별한 프롬프트가 필요하지 않고, 빠르고 효율적인 결과물을 얻기 위한 주목할만한 성능 향상을 제공한다는 것을 보여줍니다.\n\n낮은 양자화 수준에서 세밀하게 조정된 모델을 평가하는 것은 높은 변동성과 자신감으로 인해 도전적일 수 있으며, 신중한 분석이 필요합니다. 향후 글에서는 더 많은 통찰을 위해 다른 기본 모델을 세밀하게 조정하는 것을 탐구할 것입니다.\n\n도움이나 질문이 있으면 언제든지 연락해 주세요. 계약에 대해서도 가능하니 문의해 주세요. 프로젝트에 행운을 빕니다~ 세밀한 조정 재밌게 하시길 바랍니다!","ogImage":{"url":"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png"},"coverImage":"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png","tag":["Tech"],"readingTime":23},{"title":"아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요","description":"","date":"2024-05-18 21:32","slug":"2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay","content":"\n\n## 전문 기술로 번개처럼 빠른 데이터 처리 능력을 발휘하세요\n\n![이미지](/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png)\n\n파이썬 사용자로써 비즈니스 전문가들이 종종 정보를 Excel 또는 CSV 형식으로 공유하기 때문에 엑셀 파일을 처리하는 데 자주 사용됩니다. 그러나 파이썬은 엑셀 파일을 다룰 때 속도가 느릴 수 있다는 점에 유의해야 합니다.\n\n본 글에서는 Python에서 데이터를 로드하는 다섯 가지 방법을 소개하겠습니다. 이 토론이 끝나면 속도가 세 개의 자릿수가 높아져, 프로세스가 엄청나게 빨라질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실험 설정\n\n10개의 엑셀 파일을 로드해야 한다고 가정해 봅시다. 각 파일은 20,000개의 행과 25개의 열을 포함하며, 총 약 70MB의 데이터가 있습니다. 이 시나리오는 SAP와 같은 ERP 시스템에서 트랜잭션 데이터를 Python으로 분석하기 위해 전송할 때 일반적으로 발생하는 상황입니다.\n\n먼저, 이 더미 데이터를 생성하고 필요한 라이브러리를 가져와 환경을 설정할 것입니다 (이후 피클 및 joblib와 같은 라이브러리 사용의 구체적인 내용에 대해 나중에 논의할 것입니다).\n\n```js\nimport pandas as pd\nimport numpy as np\nfrom joblib import Parallel, delayed\nimport time\n\nfor file_number in range(10):\n    values = np.random.uniform(size=(20000, 25))\n    pd.DataFrame(values).to_csv(f\"더미 {file_number}.csv\")\n    pd.DataFrame(values).to_excel(f\"더미 {file_number}.xlsx\")\n    pd.DataFrame(values).to_pickle(f\"더미 {file_number}.pickle\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Python에서 데이터를로드하는 5 가지 방법\n\n# 1: Pandas를 사용하여 Excel 파일로드\n\n가장 간단한 방법으로 Excel 파일을로드하는 방법부터 시작하겠습니다. Pandas DataFrame을 초기화하고 각 Excel 파일을 순차적으로 추가합니다. 이 접근 방식은 여러 소스에서 데이터를 컴파일하여 분석을 위한 단일 구조로 제공합니다.\n\n```python\nstart = time.time()\ndf = pd.read_excel(\"Dummy 0.xlsx\")\nfor file_number in range(1,10):\n    df.append(pd.read_excel(f\"Dummy {file_number}.xlsx\"))\nend = time.time()\nprint(\"Excel:\", end - start)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약 50초 정도 소요됩니다. 상당히 느린 속도네요.\n\n저희 Excel 파일을 CSV 형식으로 변환한 후, 로딩 시간이 크게 개선되어 0.63초로 단축되었습니다. 이는 이전보다 거의 10배 빠른 속도입니다. Python은 일반적으로 CSV 파일을 Excel 파일보다 빠르게 처리하며, 종종 100배까지 빠를 수 있습니다. 따라서 CSV 파일을 사용하면 대규모 데이터셋을 처리하는 데 매우 효율적인 전략일 수 있습니다.\n\n그러나 주목할 만한 단점은 CSV 파일이 일반적으로 .xlsx 파일보다 큰 파일 크기를 갖는다는 것입니다. 예를 들어, 우리의 예제에서 CSV 파일은 각각 9.5MB이지만, .xlsx 파일은 단 6.4MB밖에 되지 않습니다.\n\n# 3: Pandas 데이터프레임의 더 똑똑한 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 데이터 로딩 프로세스를 더 향상시키기 위해, Pandas DataFrames를 만드는 방식을 최적화할 수 있습니다. 기존 DataFrame에 각 파일을 직접 추가하는 대신에, 시간이 많이 소요될 수 있으므로:\n\n1. 각 Excel 또는 CSV 파일을 별도의 DataFrame으로 로드합니다.\n2. 이러한 DataFrames를 리스트에 저장합니다.\n3. 마지막으로, 리스트의 모든 DataFrames를 단일 DataFrame으로 연결(concatenate)합니다.\n\n이 방법은 DataFrame을 반복적으로 확장하는 데 따른 오버헤드를 줄이기 때문에 일반적으로 파일마다 점진적으로 추가하는 것보다 빠릅니다.\n\n```python\nstart = time.time()\ndf = []\nfor file_number in range(10):\n    temp = pd.read_csv(f\"Dummy {file_number}.csv\")\n    df.append(temp)\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"CSV2:\", end - start)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업 테이블을 Markdown 형식으로 변경하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nstart = time.time()\ndef loop(file_number):\n    return pd.read_csv(f\"Dummy {file_number}.csv\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"CSV//:\", end - start)\n```\n\n한 개의 코어 버전과 비교했을 때 속도가 두 배로 증가했습니다. 그러나 코어 수를 늘릴수록 성능이 선형적으로 증가하지는 않는다는 점을 명심해야 합니다. 예를 들어, M1 칩을 장착한 Mac Air에서 8개의 코어를 사용하는 경우, 속도가 2배 증가하는 것을 확인했습니다. 8배가 아닙니다.\n\n## Joblib을 사용한 간단한 병렬화\n\nJoblib은 병렬 처리를 위해 설계된 간단한 Python 라이브러리입니다. 리스트 내포와 유사하게 작동하지만 한 가지 중요한 차이가 있습니다. 각 반복이 별도의 스레드에서 실행된다는 것입니다. 이 접근 방식을 통해 작업을 동시에 처리할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef loop(file_number):\n    return pd.read_csv(f\"Dummy {file_number}.csv\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\n\n#위 코드와 동일한 기능\ndf = [loop(file_number) for file_number in range(10)]\n```\n\n## 5: Pickle 파일 활용하기\n\n데이터 저장 및 검색 프로세스를 더 빠르게 하려면 pickle 파일을 사용하는 것을 고려해보세요. Pickle은 Python 전용 형식으로, 객체를 직렬화하고 역직렬화하는 데 사용되며, .csv 파일보다 빠른 데이터 로드를 가능하게 합니다.\n\n그러나 pickle 파일의 중요한 단점은 사람이 읽을 수 없다는 것입니다. .csv 파일과 달리 pickle 파일을 텍스트 편집기나 스프레드시트 프로그램으로 열어 직접 내용을 볼거나 수정할 수 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nstart = time.time()\ndef loop(file_number):\n    return pd.read_pickle(f\"Dummy {file_number}.pickle\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"Pickle//:\", end - start)\n```\n\n우리는 처리 시간을 성공적으로 80% 줄였어요!\n\n전반적으로, 피클 파일로 작업하는 것이 `.csv` 파일을 사용하는 것보다 훨씬 빠릅니다. 하지만 이 특정 예제에서는 그렇게 많은 저장 공간을 차지하지 않습니다.\n\n실제로 시스템은 일반적으로 데이터를 피클 형식으로 직접 내보내지 않아요. 다음 상황에서 피클 파일을 사용하는 것을 권장합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 내부 파이썬 사용을 위한 정보: 파이썬 프로세스에서 데이터를 저장하고 해당 데이터를 엑셀이나 다른 파이썬이 아닌 환경에서 열 필요가 없는 경우, 데이터프레임을 피클 파일로 저장하세요. 이는 파이썬 스크립트나 응용 프로그램 내에서 재사용할 데이터에 이상적입니다.\n\n2. 빈번한 파일 액세스를 위한 정보: 동일한 파일을 반복적으로 로드하는 경우, 초기 로드 후에 해당 파일을 피클로 저장하는 것이 효율적입니다. 향후 프로세스에서는 .csv 파일을 로드하는 느린 과정을 건너뛰고 피클 파일로 직접 로드할 수 있습니다.\n\n예시: 매달 업데이트되는 거래 데이터를 관리할 때, 첫 번째 로드 이후 각 달의 데이터를 .csv에서 .pickle로 변환할 수 있습니다. 이를 통해 매달 새로운 데이터가 도착할 때마다 피클 형식의 기존 데이터에 빠르게 액세스할 수 있어서 워크플로우를 간소화할 수 있습니다.\n\n# 추가 정보: 병렬로 엑셀 파일 로드하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExcel 파일을 받은 상황에서 직접 작업해야 할 때, 병렬 처리를 사용하여 효율성을 높일 수 있습니다. 다른 형식과 마찬가지로 `joblib` 라이브러리를 사용하여 이러한 파일을 병렬로 로드할 수 있습니다.\n\n이를 구현하려면 루프 내에 있는 함수를 Excel 파일을 처리할 수 있도록 조정해야 합니다. 이 수정은 Excel 파일을 로드하는 함수를 사용하고, 그런 다음 이러한 작업을 `joblib`을 사용하여 여러 프로세서에 분산하는 것을 포함합니다. 이 방식을 사용하면 여러 Excel 파일을 동시에로드하는 데 걸리는 시간을 크게 줄일 수 있습니다.\n\n```js\nstart = time.time()\ndef loop(file_number):\n    return pd.read_excel(f\"Dummy {file_number}.xlsx\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"Excel//:\", end - start)\n```\n\n로딩 시간을 70% 줄여 50초에서 13초로 단축했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아울러 병렬 로딩 프로세스를 활용하여 필요할 때마다 pickle 파일을 실시간으로 생성할 수도 있습니다. 이렇게 함으로써 파일을 다시 로드해야 하는 경우에 pickle 파일이 제공하는 크게 빠른 로딩 시간을 활용하여 데이터에 거의 즉각적으로 액세스할 수 있습니다. 이 방법은 초기 로딩 프로세스를 최적화하는 데 그치지 않고 동일한 데이터셋과의 미래 상호작용을 간소화합니다.\n\n# 요약\n\n다양한 데이터 로딩 방법을 통해 대규모 데이터셋을 처리하는 데 걸리는 시간을 크게 단축했습니다:\n\n- Excel 파일: 초기 로딩에는 50초가 걸렸습니다.\n- CSV 파일: 0.63초로 개선되었습니다.\n- 더 스마트한 CSV 로딩: 0.62초로 더욱 개선되었습니다.\n- 병렬 CSV 로딩: 0.34초로 줄었습니다.\n- 병렬 Pickle 로딩: 0.07초로 급격하게 줄었습니다, 1초의 1/10 이하입니다.\n- 병렬 Excel 로딩: 13.5초로 줄었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 결과들은 Python에서 데이터 로딩 작업의 성능을 향상시키기 위해 파일 형식을 최적화하고 병렬 처리를 활용하는 이점을 강조합니다.\n\n# 쉽게 이해할 수 있는 용어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 필자를 박수 치고 팔로우하기 꼭 잊지마세요! ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요.\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png"},"coverImage":"/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png","tag":["Tech"],"readingTime":7},{"title":"주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안","description":"","date":"2024-05-18 21:30","slug":"2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures","content":"\n\n시계열을 위한 머신러닝 모델을 훈련할 때는 대개 다음과 같은 시간 특성들을 사용하게 됩니다:\n\n- 시간\n- 요일\n- 월\n- 주 또는 연도의 일\n- 기타\n\n타임스탬프 열을 이러한 종류의 특성으로 변환하는 것은 꽤 쉽습니다. 시간 열을 datetime 객체로 변환한 후 (pd.to_datetime을 사용하여), .dt를 사용하여 여러 시계열 특성을 추출할 수 있습니다.\n\n```js\ndf['Hour']=df['Datetime'].dt.hour\ndf['Month']=df['Datetime'].dt.month\ndf['Dayofweek']=df['Datetime'].dt.dayofweek\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고로, 이 예제에서 사용할 데이터셋은 CC0 공개 도메인 라이선스이며 시간당 전기 사용량 데이터셋입니다. 에너지 소비 데이터셋은 일반적으로 시계열 데이터이며, 최종 목표는 과거 데이터를 사용하여 미래의 소비를 예측하는 것이므로 이것은 좋은 사용 사례입니다. 온도, 습도 및 바람 세기와 같은 기타 외부 기능도 에너지 소비에 영향을 미칠 수 있지만, 여기서는 시계열 기능을 추출하고 변환하는 데 초점을 맞출 것입니다.\n\n![Image](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png)\n\n멋지죠! 이제 사용 가능한 기능이 0에서 3개로 늘었습니다.\n\n하지만 너무 빨리 생각하지 마세요! ML에서는 이러한 기능을 그대로 모델에 전달할 수 없다는 것을 알고 있습니다. 대부분의 모델은 이러한 입력을 숫자 기능으로 해석할 것이며, 시계열 기능은 숫자가 아니라 범주형이라는 사실입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에너지 소비에 관한 경우, 하루 중 특정 피크 시간에는 더 높은 소비가 발생할 가능성이 높습니다. 또한 소비가 낮은 특정 시간대도 있습니다. 각 시간은 어떤 의미에서 자체적인 카테고리입니다.\n\n이 데이터셋의 특정 부분을 자세히 살펴보면 이를 확인할 수 있습니다. 하루 내내 소비 패턴이 명확히 나타납니다 — 사용량은 동일한 시간대(오후 5-6시)에 피크를 찍고, 새벽 5-7시에 가장 낮습니다.\n\n![image](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_1.png)\n\n물론, 이러한 패턴은 다른 요소들과의 복잡한 상호작용이 있습니다. 예를 들어, 연도별/월별 시간 및 요일 등의 특징을 모델에 최대한 많이 포함하려고 노력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 일반적인 방법처럼 표를 Markdown 형식으로 변경할 수 있어요. \n\n\n| Column 1 | Column 2 | Column 3 |\n|----------|----------|----------|\n| Apple    | Orange   | Banana   |\n| Car      | Book     | Tree     |\n| Sun      | Moon     | Star     |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncolumns_to_encode = ['Hour', 'Month', 'Dayofweek']\n\ndf = pd.get_dummies(df, columns=columns_to_encode)\n```\n\n새로운 특성 집합이 생성됩니다.\n\n![이미지](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_2.png)\n\n볼 수 있듯이, 많은 특성들이 생성되었습니다. 우리는 3개의 열 (시간, 월, 요일)에서 40개가 넘게 되었습니다. 시간 시리즈 특성을 인코딩해야 하는 경우 더 많은 특성을 추가하면서 점점 더 복잡해질 수 있습니다. 이러한 많은 특성을 추적하기 어려워질 수 있으며, 특히 데이터베이스에 특성을 저장하거나 특성 중요도를 시각화하려는 경우 (매우 난잡한 그래프를 원치 않는 경우)에 더 어려워질 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 대안: 순환 인코딩\n\n시계열 피처는 본질적으로 주기적입니다. 시계가 24:00(자정)을 가르킬 때 새로운 날이 시작되고 다음 시간은 1:00(오전 1시)입니다. 숫자 1과 24는 사실적으로 숫자 차이가 가장 큽니다만, 1은 24에 가까운 것처럼 23과 같은 사이입니다. 왜냐하면 이들은 주기적인 관계에 있기 때문입니다.\n\n그래서 시계열 피처를 수치적으로 표현하는 또 다른 방법은 타임스탬프를 사인과 코사인 변환으로 변환하는 것입니다. 이를 통해 결과적으로 하루 중 시간, 한 주 중 시간 또는 연도 중 시간을 알 수 있습니다.\n\n우리가 one-hot 인코딩으로 하는 것처럼 날짜 및 시간 값을 범주형 피처로 변환하는 대신, 일부 값은 가깝게 유지되고(예: 자정과 새벽 1시), 다른 값은 멀어집니다(예: 자정과 정오). 이러한 유형의 정보는 one-hot 인코딩을 할 때 손실됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사인과 코사인은 단위 원에서 나온 것이며, 아이디어는 타임스탬프가 사인 및 코사인 좌표로 표현되는 이 원 위에 어디에 있는지 매핑하는 것입니다. 원의 오른쪽 부분을 참조로 생각해봅시다 (아래 차트에서 0으로 표시됩니다) 또는 실제 24시간 시간대의 00:00(자정)을 나타내는 것, 이를 4개의 6시간 기준점으로 나누어 원에 시간을 매핑할 수 있도록 합니다.\n\n단위 원을 반시계 방향으로 이동할수록 값이 증가되고 pi/2(또는 90도)인 지점은 6:00 오전과 같고, pi(180도) 또는 12:00 오후 및 3pi/2 또는 6:00 오후 및 마지막으로 다시 자정의 0으로 돌아갑니다. 이러한 각각의 기준점 사이의 각 시점에는 고유한 좌표가 있습니다. 이렇게 하면 24시간의 일일 주기를 사인과 코사인을 사용하여 표현할 수 있습니다.\n\n다른 주기, 예를 들어 주간이나 연간 시간에도 똑같이 적용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPython에서 이 작업을 수행하려면 먼저 datetime을(제 경우에는 시간별 타임스탬프) 숫자 변수로 변환해야 합니다. 이 열을 pd.Timestamp.timestamp 객체로 변환하여 각 타임스탬프를 유닉스 시간(1970년 1월 1일 이후 경과한 초 수)으로 변환합니다.\n\n이제 이 숫자 열을 사인 및 코사인 기능으로 변환할 수 있습니다.\n\n```python\n# Convert datetime into a numerical seconds timestamp object \n# (tells you the date/time in seconds)\ntimestamp_s = df['Datetime'].map(pd.Timestamp.timestamp)\n\n# Get the number of seconds for each time period\nday = 24*60*60\nweek = day*7\nyear = day*(365.2425)\n\n# Transform using sin and cos\n# Time of day\ndf['Day_sin'] = np.sin(timestamp_s * (2 * np.pi / day))\ndf['Day_cos'] = np.cos(timestamp_s * (2 * np.pi / day))\n\n# Time of week\ndf['Week_sin'] = np.sin(timestamp_s * (2 * np.pi / week))\ndf['Week_cos'] = np.cos(timestamp_s * (2 * np.pi / week))\n\n# Time of year\ndf['Year_sin'] = np.sin(timestamp_s * (2 * np.pi / year))\ndf['Year_cos'] = np.cos(timestamp_s * (2 * np.pi / year))\n```\n\n넓게 볼 때 이런 과정이 진행됩니다: 우선, 타임스탬프를 초에서 라디안으로 변환합니다. 2 * np.pi 부분은 전체 원/주기에 2 * pi 라디안이 있다는 이유입니다. 이 변환 후에 나누는 주기는 초 단위의 사이클 기간(하루, 일주일 또는 연도)입니다. 다음으로, 이 변환된 값과 사인 및 코사인을 사용하여 각 타임스탬프를 주기 내에서의 위치를 나타내는 고유한 각도로 매핑합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 기간이 하루인 경우, 하루의 시작에 대한 타임스탬프는 0 라디안으로 매핑되고, 하루의 중간에 있는 타임스탬프는 np.pi 라디안으로 매핑되며, 하루의 끝에 있는 타임스탬프는 2 * np.pi 라디안으로 매핑됩니다.\n\n마지막으로, 결과적인 계산에 대해 사인과 코사인을 취하여 단위 원 위의 실제 x 및 y 좌표 값을 얻습니다. 이 값들은 항상 -1과 1 사이에 있을 것입니다.\n\n이 접근 방식을 통해 각 원래 시계열 특성(예: 하루의 시간, 요일, 연의 월)이 이제 해당 원래 특성의 삼각함수값 (사인 및 코사인)으로만 매핑되어, 24개, 7개, 12개 등이 아니라 오직 2개의 새로운 특성으로만 매핑됩니다.\n\n## 이 접근 방식의 단점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 사용할 때 주의해야 합니다. 매우 편리하고 효율적이지만, 몇 가지 단점과 주의사항이 있습니다:\n\n- 시간, 월 등 특정 시간대 값이 일관되게 다른 데이터셋에 대해 원-핫 인코딩이 더 잘 작동할 수 있습니다. 예를 들어, 사용량이 지나치게 높아지는 12PM이나 특정 달에 높은 물량이 발생하는 데이터셋이 있습니다. 12PM-2PM과 같이 범위가 있는 데이터셋에서는 순환 인코딩과 같은 유연한 방법이 더 정확할 수 있습니다.\n- 이러한 유형의 인코딩은 딥 러닝/신경망에는 잘 작동하지만, 랜덤 포레스트와 같은 트리 분할 알고리즘에는 적합하지 않을 수 있습니다. 그 이유는 보통 1개의 특성을 나타내는 단일 타임스탬프가 2개의 특성으로 분할되고, 트리 기반 알고리즘은 한 번에 한 특성씩 분할 결정을 내립니다. 따라서 모델은 실제로 1개의 원래 특성에 대응하는 좌표 쌍인데도 불구하고 2개의 특성을 별도로 처리할 것입니다.\n\n그러나 이는 결코 트리 기반 알고리즘에 순환 인코딩을 사용하지 말아야한다는 뜻은 아닙니다. 실제로 저는 랜덤 포레스트 모델에서 이 유형의 인코딩을 사용하고 좋은 결과를 얻었습니다. 데이터셋에 따라 다를 것이기 때문에 여전히 교차 검증 및 최종 홀드아웃 테스트 세트에서 메트릭을 실행하여 확신할 필요가 있습니다.\n\n게다가, 사용하기 전에 원-핫 인코딩 결과를 순환 인코딩 결과와 비교하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- P. Bescond, 주기적인 특성 인코딩, 시간 문제입니다! (2020), Towards Data Science\n- R. Mulla, 시간당 에너지 소비 (2022년 8월), Kaggle에서 2024년 5월에 조회\n- TensorFlow, 시계열 예측 (2024), TensorFlow Core","ogImage":{"url":"/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png"},"coverImage":"/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png","tag":["Tech"],"readingTime":6}],"page":"68","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"68"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>