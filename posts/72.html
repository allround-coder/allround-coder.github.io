<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/72" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/72" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 개발자를 위한 CSS 팁" href="/post/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 개발자를 위한 CSS 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 개발자를 위한 CSS 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 개발자를 위한 CSS 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 로컬 변경되었을 때 감지하는 방법" href="/post/2024-05-17-LocalChangeDetectioninAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 로컬 변경되었을 때 감지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 로컬 변경되었을 때 감지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 로컬 변경되었을 때 감지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기" href="/post/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 " href="/post/2024-05-17-5AngularLibrariesToUseInYourProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 </strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 성능을 향상시키는 Angular FormArray 팁" href="/post/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 성능을 향상시키는 Angular FormArray 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 성능을 향상시키는 Angular FormArray 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 성능을 향상시키는 Angular FormArray 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 17의 새로운 제어 흐름 구문 내용 정리" href="/post/2024-05-17-MustKnowAngular17NewControlFlowSyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 17의 새로운 제어 흐름 구문 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 17의 새로운 제어 흐름 구문 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 17의 새로운 제어 흐름 구문 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="완벽한 TS monorepo를 만드는 방법" href="/post/2024-05-17-MyquestfortheperfectTSmonorepo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="완벽한 TS monorepo를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="완벽한 TS monorepo를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">완벽한 TS monorepo를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React jsx를 이해하는 방법" href="/post/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React jsx를 이해하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React jsx를 이해하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React jsx를 이해하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기" href="/post/2024-05-17-ReactNativeCreateeasytouseModalManager"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 개발자를 위한 TypeScript 마스터하기" href="/post/2024-05-17-MasteringTypeScriptinEverydayProgramming"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 개발자를 위한 TypeScript 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 개발자를 위한 TypeScript 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 개발자를 위한 TypeScript 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link posts_-active__YVJEi" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"프론트엔드 개발자를 위한 CSS 팁","description":"","date":"2024-05-17 21:18","slug":"2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro","content":"\n\n## 개발자가 알아야 할 100가지 CSS 속성\n\n![CSS Cheat Sheet](/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png)\n\n웹 애플리케이션을 만들고 스타일링하는 것을 좋아하며 CSS가 제가 생각하고 이야기하는 가장 좋아하는 것입니다.\n\n4년의 경험을 통해 많은 것을 배웠고, 이 기사에서 그 지식을 여러분과 공유하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 모든 사람을 위한 궁극적인 CSS 치트 시트를 제공하기 위해 모든 것을 다 할 거에요 - 절대 초보자부터 궁극의 전문가까지.\n\n마지막으로, 아무도 모르는 최고의 CSS 한 줄 코드 몇 가지를 보여드릴 테니, 이를 통해 많은 작업을 절약할 수 있을 거에요.\n\n편안히 앉아서 즐기고 나중을 위해 저장하세요!\n\n# 초보자 레벨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n셀렉터: `element`\n지정된 타입의 모든 요소를 선택합니다.\n\n셀렉터: `#id`\n지정된 id를 가진 요소를 선택합니다.\n\n셀렉터: `.class`\n지정된 클래스를 가진 모든 요소를 선택합니다.\n\n속성: color\n텍스트의 색상을 설정합니다.\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```css\np {\n color: blue;\n }\n```\n\n속성: font-size\n글꼴 크기를 설정합니다.\n예시:\n\n```css\nh1 {\n font-size: 24px;\n }\n```\n\n속성: background-color\n배경 색상을 설정합니다.\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```css\nbody {\n background-color: #f0f0f0;\n }\n```\n\n\nProperty: margin\nSets the margin properties.\nExample:\n\n```css\n.container {\n margin: 10px;\n }\n```\n\nProperty: padding\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패딩 속성을 설정합니다.\n예시:\n\n```js\n.box {\n  padding: 20px;\n}\n```\n\n속성: display\n요소의 표시 방법을 설정합니다.\n예시:\n\n```js\n.block {\n  display: block;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\nProperty: position\nSets the positioning method.\nExample:\n\n```js\n.absolute {\n position: absolute;\n top: 0;\n left: 0;\n }\n```\n\nProperty: width\nSets the width of an element.\nExample:\n\n```js\nimg {\n width: 100px;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티: 높이\n요소의 높이를 설정합니다.\n예시:\n\n```js\n.header {\n height: 80px;\n }\n```\n\n# 중급 레벨\n\n프로퍼티: 글꼴 패밀리\n글꼴 패밀리를 설정합니다.\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\nbody {\n font-family: Arial, sans-serif;\n }\n```\n\n속성: font-weight\n글꼴의 굵기를 설정합니다.\n예시:\n\n```json\n.bold-text {\n font-weight: bold;\n }\n```\n\n속성: text-transform\n텍스트 대문자화를 제어합니다.\n예시:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbutton {\n  cursor: pointer;\n}\n```\n\n속성: 배경 이미지\n요소에 하나 이상의 배경 이미지를 설정합니다.\n예시:\n\n```js\n.hero-section {\n  background-image: url('hero.jpg');\n}\n```\n\n속성: 배경 위치\n배경 이미지의 시작 위치를 설정합니다.\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.header {\n background-position: center;\n }\n```\n\n속성: background-repeat\n배경 이미지가 반복되는 방식을 설정합니다.\n예시:\n\n```js\n.pattern {\n background-repeat: repeat-x;\n }\n```\n\n속성: background-size\n배경 이미지의 크기를 설정합니다.\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```css\n.cover-image {\n background-size: cover;\n }\n```\n\n속성: 투명도\n투명도 수준을 설정합니다.\n예시:\n\n```css\n.overlay {\n opacity: 0.5;\n }\n```\n\n# 고급 레벨\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n속성: flex\n유연한 요소의 유연한 길이를 설정합니다.\n예시:\n\n```js\n.container {\n display: flex;\n }\n```\n\n속성: flex-direction\n유연한 컨테이너의 주 축 방향을 지정합니다.\n예시:\n\n```js\n.container {\n flex-direction: row;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProperty: flex-wrap\n플렉스 항목이 줄 바꿈해야 하는지를 지정합니다.\n예시:\n\n```js\n.container {\n flex-wrap: wrap;\n }\n```\n\nProperty: flex-grow\n플렉스 항목이 서로에 비해 어떻게 성장하는지를 지정합니다.\n예시:\n\n```js\n.item {\n flex-grow: 1;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n속성: flex-shrink\n서로에 비해 얼마나 flex 항목이 줄어드는지를 지정합니다.\n예시:\n\n```js\n.item {\n  flex-shrink: 0;\n}\n```\n\n속성: flex-basis\nflex 항목의 초기 길이를 지정합니다.\n예시:\n\n```js\n.item {\n  flex-basis: 100px;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티: align-items\n플렉스 컨테이너의 교차 축을 따라 플렉스 아이템을 정렬합니다.\n예시:\n\n```js\n.container {\n align-items: center;\n }\n```\n\n프로퍼티: align-self\n개별 플렉스 아이템의 기본 정렬을 재정의할 수 있습니다.\n예시:\n\n```js\n.item {\n align-self: flex-end;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티: justify-content\n플렉스 컨테이너의 주축을 따라 플렉스 아이템을 정렬합니다.\n예시:\n\n```js\n.container {\n justify-content: space-between;\n }\n```\n\n프로퍼티: grid-template-columns\n그리드 레이아웃에서 열의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-template-columns: 1fr 2fr;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n속성: grid-template-rows\n그리드 레이아웃에서 행의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-template-rows: 100px auto;\n }\n```\n\n속성: grid-gap\n그리드 레이아웃에서 열과 행 사이의 간격을 설정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-gap: 10px;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n속성: grid-auto-columns\n암시적 그리드 열의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-columns: 100px;\n}\n```\n\n속성: grid-auto-rows\n암시적 그리드 행의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-rows: 100px;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProperty: grid-auto-flow\n그리드 레이아웃에서 자동 배치 알고리즘이 작동하는 방식을 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-flow: dense;\n }\n```\n\nProperty: grid-column\n그리드 열 내에서 그리드 항목의 크기와 위치를 지정합니다.\n예시:\n\n```js\n.item {\n grid-column: 2 / span 2;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProperty: grid-row\n그리드 항목의 크기 및 그리드 행 내 위치를 지정합니다.\n예시:\n\n```js\n.item {\n grid-row: 1 / span 2;\n }\n```\n\nProperty: grid-area\n요소의 크기 및 그리드 레이아웃 내 위치를 설정합니다.\n예시:\n\n```js\n.item {\n grid-area: 1 / 1 / span 2 / span 2;\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 상세한 CSS 치트 시트는 초보부터 고급 수준까지 다양한 속성 및 선택자를 다루며, 사용 예시를 통해 설명합니다. 특정 속성에 대한 질문이 있거나 추가 설명이 필요하다면 댓글로 자유롭게 질문해 주세요!\n\n이 기사가 도움이 되었기를 바랍니다. 여러분의 문제를 해결하는 데 도움이 되었기를 희망합니다! (새로운 문제가 발생하지 않길 바랍니다 ;-))\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png"},"coverImage":"/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png","tag":["Tech"],"readingTime":5},{"title":"앵귤러에서의 로컬 변경되었을 때 감지하는 방법","description":"","date":"2024-05-17 21:16","slug":"2024-05-17-LocalChangeDetectioninAngular","content":"\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png)\n\nAngular 16 introduced Signals as a pivotal feature, setting the stage for future applications and laying the foundation for a zoneless environment. Signals operate reactively, enabling the generation of derived values or side effects through functions like signal(), computed(), and effect().\n\nThese Signals are instrumental in Angular’s shift from a component-centric rendering approach to one centered around Signals. The dependency graph created by Signals represents the application state. When this graph changes, Angular triggers a DOM update via Change Detection.\n\nFrom a framework’s perspective, the render process is just a side effect of a Signal change. By reacting to the Signals, Angular knows exactly when and what to update.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것을 달성하기 위해서, 새로운 유형의 컴포넌트가 필요합니다. 새로운 Signal Component를 사용하면 Change Detection을 일으키는 것이 zone.js가 아니라 신호 자체가 됩니다.\n\n불행히도, Signal Components는 17버전에서 사용할 수 없습니다. 그래서 우리는 조금 더 기다려야 합니다.\n\n당연한 질문은: \"Signals로부터 어떤 혜택을 받을 수 있나요?\" 17에서는 대답이 있습니다: 지역 Change Detection입니다.\n\n글을 읽는 것보다 비디오를 선호하신다면, 여기에 하나가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 성능이 떨어지는 변경 감지\n\n현재 Angular는 변경이 발생했는지 실질적으로 인식하지 못합니다. 그래서 zone.js와 변경 감지에 의존합니다.\n\nzone.js는 DOM 이벤트가 발생하거나 비동기 작업이 완료될 때 변경 감지를 트리거합니다.\n\n변경 감지는 전체 컴포넌트 트리를 통과하고 변경 사항을 검색해야 합니다. 변경 사항을 감지하면 해당 DOM 노드를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 전혀 변화가 없을 때도 변경 감지가 실행되므로 성능이 그리 좋지 않습니다.\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_1.png)\n\n부모 및 자식 컴포넌트가 있는 시나리오를 고려해보겠습니다. 부모 컴포넌트는 데이터 그리드를 표시하고, 자식 컴포넌트에는 마지막 업데이트 이후 경과된 시간을 보여주는 타이머가 있습니다:\n\n```typescript\n@Component({\n  selector: 'app-list',\n  template: `\n      \u003cdiv\u003e\n          \u003cmat-table [dataSource]=\"dataSource\"\u003e\n              \u003cng-container matColumnDef=\"title\"\u003e\n                  \u003cmat-header-cell *matHeaderCellDef\u003e Title\u003c/mat-header-cell\u003e\n                  \u003cmat-cell *matCellDef=\"let element\"\u003e{ element.title }\u003c/mat-cell\u003e\n              \u003c/ng-container\u003e\n              \u003cng-container matColumnDef=\"description\"\u003e\n                  \u003cmat-header-cell *matHeaderCellDef\u003e Country\u003c/mat-header-cell\u003e\n                  \u003cmat-cell *matCellDef=\"let element\"\u003e{ element.description }\u003c/mat-cell\u003e\n              \u003c/ng-container\u003e\n              \u003cmat-header-row *matHeaderRowDef=\"displayedColumns\"/\u003e\n              \u003cmat-row *matRowDef=\"let row; columns: displayedColumns;\"/\u003e\n          \u003c/mat-table\u003e\n          \u003cdiv\u003e\n              @if (lastUpdate) {\n                  \u003capp-timer [lastUpdate]=\"lastUpdate\"\u003e\u003c/app-timer\u003e\n              }\n              \u003cbutton mat-raised-button color=\"primary\" (click)=\"refresh()\"\u003eRefresh\u003c/button\u003e\n          \u003c/div\u003e\n      \u003c/div\u003e\n      {logCd()}\n  `,\n  standalone: true,\n  imports: [MatTableModule, MatButtonModule, TimerComponent]\n})\nexport class ListComponent implements OnInit {\n  lastUpdate: Date | undefined\n  dataSource = new MatTableDataSource\u003cHoliday[]\u003e([]);\n  displayedColumns = ['title', 'description'];\n  ngOnInit() {\n    this.refresh()\n  }\n  refresh() {\n    fetch('https://api.eternal-holidays.net/holiday').then(res =\u003e res.json()).then(value =\u003e {\n      this.lastUpdate = new Date();\n      this.dataSource.data = value;\n    });\n  }\n  logCd() {\n    console.log('cd from list');\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Component({\n  selector: 'app-timer',\n  template: `\u003cspan\u003eLast Updated: { lastUpdateInSeconds | number:'1.0-0' } Seconds\u003c/span\u003e { logCd() }`,\n  standalone: true,\n  imports: [DatePipe, DecimalPipe]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n  lastUpdateInSeconds = 0\n  constructor() {\n    setInterval(() =\u003e {\n      this.lastUpdateInSeconds = (new Date().getTime() - this.lastUpdate.getTime()) / 1_000;\n    }, 1000);\n  }\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\nTimerComponent은 매 초 간격으로 lastUpdateInSeconds를 업데이트합니다. 이 간격은 zone.js가 매 초마다 변경 감지를 트리거할 수 있도록 합니다.\n\n따라서 변경 감지가 시작되면 부모 구성 요소를 통해 데이터가 변경되었는지 확인합니다. 변경이 있으면 필요한 DOM 요소를 업데이트하고 TimerComponent로 이동합니다.\n\n즉, Angular는 매 초 ListComponent를 불필요하게 확인합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 컴포넌트의 logCd()은 체크가 실행될 때 마다 로그를 남깁니다. 현재로서는 매우 빈번하게 로그를 남깁니다.\n\n# OnPush\n\nComponent 데코레이터의 인기 있는 설정 중 하나는 ChangeDetectionStrategy:OnPush입니다. Angular가 변경 감지를 실행할 때 그 설정이 있는 컴포넌트를 만나면 중단합니다. 또한 해당 컴포넌트가 \"더러운\" 것으로 표시하는 플래그가 없는 한 그 하위 항목을 통과하지 않습니다.\n\n컴포넌트가 \"더러워\"지는 일반적인 기준은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력값이 객체 참조를 변경합니다.\n- 컴포넌트가 이벤트 핸들러를 실행합니다. 이벤트 핸들러가 없는 요소를 클릭하는 것만으로는 충분하지 않습니다.\n- 비동기 파이프가 적용되어 기본 Observable이 새 값을 방출합니다.\n- 시그널이 변경됩니다.\n\n\"더티 마킹\"이 변경 감지를 트리거하지 않는다는 점을 중요하게 알아두어야 합니다. 이 동작은 여전히 zone.js의 작업으로, 실행된 이벤트 핸들러가 있거나 비동기 작업이 종료될 때 비동기적으로 스케줄링됩니다.\n\nAngular가 컴포넌트를 \"더티\" 상태로 표시하면 해당 부모 컴포넌트에도 적용됩니다. 왜 이게 필요한 걸까요? 부모도 OnPush로 설정되어 있는 경우 CD가 자식 컴포넌트로 전파되지 않을 것입니다.\n\n다음 그림은 OnPush와 기본 전략을 사용한 변경 감지의 차이를 보여 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_2.png)\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_3.png)\n\n이 그림에서는 \"Dirty Marking\"이라는 별도의 프로세스가 변경 감지 전에 실행되는 것을 보여줍니다. 이는 속성 바인딩이 포함되지 않은 경우에만 해당됩니다. \"Dirty Checking\"도 변경 감지 중에 발생할 것입니다.\n\n따라서 TimerComponent가 ListComponent의 자식 요소인 한, 변경 감지는 ListComponent를 통과하여 해당 요소도 확인해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함께 해요\n\nTimerComponent에만 OnPush를 설정해보세요. 그러면 로그가 ListComponent에서만 발생하는 것을 볼 수 있을 거예요. 그 이유는 OnPush가 구성 요소에 대해 zone.js를 비활성화하지 않기 때문이에요. 여전히 간격을 인식하고 변경 감지를 트리거하여 매 초마다 실행해요.\n\nTimerComponent는 어떤 기준(위의 목록 참조)도 해당되지 않아 '더티'로 표시되지 않습니다. 따라서 DOM이 업데이트되지 않아요. 비동기 작업은 변경 감지만 트리거하고 구성 요소를 '더티'로 표시하지는 않아요.\n\n새로 고침을 클릭하면 TimerComponent에서도 변경 감지가 트리거되는 것을 볼 수 있어요. 이는 @Input이 새 참조로 업데이트되었기 때문이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 \"Updated\" 텍스트를 클릭하면 아무 변화가 없다는 것을 알 수 있어요. DOM 이벤트를 발생시켰지만 내부적으로 해당 이벤트를 처리할 이벤트 핸들러가 없어요.\n\n텍스트에 이벤트 리스너를 추가해봐요. 아무 동작을 하지 않아도 괜찮아요. 그냥 존재하는 것만으로도 충분해요. 클릭하면 Change Detection이 실행되는 것을 확인할 수 있을 거예요.\n\n이미 목록을 확인하고 있는데, async 파이프도 추가해보도록 해요:\n\n```js\n@Component({\n  selector: 'app-timer',\n  template: `\u003cspan class=\"px-2\"\u003eLast Updated: { lastUpdateInSeconds$ | async | number:'1.0-0' }\n      Seconds\u003c/span\u003e { logCd() }`,\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    DatePipe,\n    DecimalPipe,\n    AsyncPipe\n  ]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n\n  lastUpdateInSeconds$ = interval(1000).pipe(map(() =\u003e this.lastUpdateInSeconds = (new Date().getTime() - this.lastUpdate.getTime()) / 1_000))\n\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금부터 타이머가 매 초 업데이트되어야 합니다. 만약 동기부여를 받았다면 컴포넌트에서 구독을 시도해 보세요. 그러면 변경 감지가 더 이상 컴포넌트를 확인하지 않음을 알 수 있을 것입니다.\n\n이미 OnPush를 사용하고 있지만 변경 감지는 여전히 ListComponent를 매 초 확인합니다. 그것은 그다지 효율적이지 않습니다.\n\n# 로컬 변경 감지\n\nAngular 17와 신호를 발견하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 팀이 17번 버전을 릴리스하기 일주일 전에, 로컬 변경 감지를 추가했습니다. 이 기능은 우리의 사용 사례에 완벽하게 어울립니다.\n\n이를 통해 컴포넌트 트리에서 단일 컴포넌트를 더러운 상태로 표시할 수 있습니다. 따라서 변경 감지는 부모를 확인하지 않을 것입니다. 만약 그 자식 컴포넌트들이 OnPush로 표시되어 있다면, 그것들 또한 제외될 것입니다.\n\n이 기능을 작동시키기 위해 우리는 두 가지 요소가 필요합니다: 신호(Signals)와 OnPush입니다. 그래서 필요한 것은 이 두 가지뿐입니다.\n\n아래 그림은 이 새로운 기능을 보여줍니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_4.png)\n\nOnPush를 추가하고 TimerComponent를 Signals로 리팩토링한 코드입니다:\n\n```javascript\n@Component({\n  selector: 'app-timer',\n  template: `\u003cspan\u003eLast Updated: {{ lastUpdateInSeconds() | number:'1.0-0' }} Seconds\u003c/span\u003e {{ logCd() }}`,\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [DatePipe, DecimalPipe, AsyncPipe]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n  lastUpdateInSeconds = signal(0)\n  constructor() {\n    setInterval(() =\u003e {\n      this.lastUpdateInSeconds.set((new Date().getTime() - this.lastUpdate.getTime()) / 1_000);\n    }, 1000);\n  }\n\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\nListComponent도 OnPush여야 합니다. 그렇지 않으면 Change Detection이 항상 확인합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 지금 페이지를 새로고침하면, 타이머가 작동 중이지만 목록은 한 번만 확인되었습니다. 이제 \"새로고침\" 버튼을 클릭하면 ListComponent에서 처리되는 DOM 이벤트를 트리거합니다. 따라서 변경 감지는 해당 컴포넌트에 대해... 두 번 실행됩니다.\n\n한 번이 아니라 두 번 왜 그럴까요? 여기에는 두 가지 트리거가 있습니다. 첫 번째는 DOM 이벤트이고, 두 번째는 나중에 약간 끝나는 fetch에서 비동기 작업입니다.\n\n이것이 바로 로컬 변경 감지입니다. 시그널 컴포넌트에 대해 기대할 수 있는 일부를 간단히 살펴보았습니다.\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 변경 감지는 강력한 기능입니다. 변경 감지에서 어떤 구성 요소가 검사를 거쳐야 하는지 정확히 정의할 수 있습니다.\n\nAngular 17에서만 사용 가능하며 OnPush 및 신호를 모두 사용해야 합니다.\n\n이는 미래 신호 구성 요소의 일부로, 더욱 미세한 변경 감지가 가능해질 것입니다.\n\n데모 저장소는 다음에서 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 감사의 말씀\n\n이 글을 철저히 검토하고 그림을 개선하도록 강력히 요구한\nThomas Laforge님에게 감사의 말씀을 전하고 싶습니다.\n\n또한, Change Detection의 내부 작업에 대한 통찰을 제공해 준\nAndrew Scott님과\nSander Elias님께도 감사의 말씀을 전합니다.\n\n# 추가로 읽을 거리","ogImage":{"url":"/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png"},"coverImage":"/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png","tag":["Tech"],"readingTime":9},{"title":"Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기","description":"","date":"2024-05-17 21:15","slug":"2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png\" /\u003e\n\nAngular 애플리케이션에서는 종종 네이티브 브라우저 API 또는 window나 document와 같은 전역 객체와 상호 작용해야 할 때가 있습니다. 이러한 객체들을 직접 참조할 수는 있지만, 권장되지 않습니다. 왜냐하면 이는 더 강한 결합을 유발하고, 테스트하기 어렵게 만들며, 코드를 특정 플랫폼(즉, 브라우저)에 종속시키기 때문입니다.\n\n이것이 의존성 주입 (DI)가 구원해주는 곳입니다...\n\n# Angular의 Document 토큰\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서는 브라우저의 문서 객체를 주입할 수 있는 DOCUMENT 토큰이 있습니다. 이 토큰은 Angular의 platform-browser 패키지의 일부이며, 앱이 서버 또는 브라우저에서 실행 중인지에 관계없이 적절한 객체를 제공할 것입니다.\n\n다음 예제는 COMPONENT에서 DOCUMENT 토큰을 주입하고 해당 함수 중 하나에 접근하는 방법을 보여줍니다:\n\n```js\nimport { DOCUMENT } from '@angular/common';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly document = inject(DOCUMENT);\n\n  reloadPage(): void {\n    this.document?.location?.reload();\n  }\n}\n```\n\n이 전 예제는 매우 간단합니다: Angular의 DOCUMENT 토큰을 가져와 주입하고, 브라우저의 위치 속성에 접근하며 다시로드하는 방법을 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 창 속성 접근\n\n창 속성에 접근해야 할 경우, 동일한 DOCUMENT 토큰을 사용해야 합니다:\n\n```js\nimport { DOCUMENT } from '@angular/common';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly document = inject(DOCUMENT);\n  private readonly window = this.document?.defaultView\n\n  getLanguage(): string {\n    return this.window?.navigator?.language\n  }\n}\n```\n\n주입된 DOCUMENT를 활용하여, defaultView 속성을 통해 창 객체에 접근할 수 있습니다. 이를 통해 모든 기능과 객체에 접근할 수 있습니다. 이 구체적인 예제에서는 브라우저 사용자 인터페이스의 언어를 나타내는 문자열을 제공하는 navigator 객체를 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 이제 브라우저별 API와 작업하는 것이 훨씬 쉽고 안전해졌어요. 그러나 window 객체를 자주 사용해야 하는 상황이 생기면 사용자 정의 토큰을 만들 수도 있어요.\n\n# 사용자 정의 Window 토큰\n\n다음 예에서는 Angular의 DOCUMENT와 비슷한 커스텀 WINDOW 토큰을 생성하고 프로젝트 전반에 걸쳐 사용하는 방법을 보여줍니다:\n\n```js\n// browser-global-tokens.ts\nimport { DOCUMENT } from '@angular/common';\nimport { InjectionToken, inject } from '@angular/core';\n\n/**\n * 전역 window 객체를 위한 인젝션 토큰.\n */\nexport const WINDOW = new InjectionToken\u003cWindow\u003e('Global window object', {\n  factory: (): Window =\u003e inject(DOCUMENT)?.defaultView\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드 스니펫은 팩토리 함수를 사용하여 생성된 WINDOW이라는 인젝션 토큰을 정의합니다. 이 함수는 inject(DOCUMENT).defaultView를 사용하여 DOCUMENT 객체의 defaultView 속성을 검색하며, Angular 애플리케이션 내에서 의존성 주입(DI)을 통해 윈도우 객체에 접근할 수 있도록 합니다.\n\n새로운 WINDOW 토큰을 사용하여 TestComponent 예제를 업데이트해 보겠습니다:\n\n```js\nimport { WINDOW } from './browser-global-tokens.ts';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly window = inject(WINDOW);\n\n  getLanguage(): string {\n    return this.window?.navigator?.language\n  }\n}\n```\n\n우리의 WINDOW 토큰을 직접 사용하여 브라우저의 언어에 액세스하는 코드를 약간 단순화할 수 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAngular의 의존성 주입 메커니즘을 활용하여 window와 같은 전역 객체를 안전하고 유지보수가 용이하게 애플리케이션에 주입하는 방법을 살펴보았습니다. 주입 토큰과 팩토리 함수를 사용하여 이러한 전역 객체를 우리의 코드에 매끄럽게 통합할 수 있으며 Angular의 최상의 관행을 준수할 수 있습니다.\n\nAngular 애플리케이션에서 전역 객체에 직접 접근을 피하는 것은 좋은 코드 구성 및 테스트 가능성을 촉진할 뿐만 아니라 유형 안정성 및 크로스 플랫폼 호환성을 향상시킵니다.","ogImage":{"url":"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png"},"coverImage":"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png","tag":["Tech"],"readingTime":3},{"title":"현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 ","description":"","date":"2024-05-17 21:14","slug":"2024-05-17-5AngularLibrariesToUseInYourProjects","content":"\n\n\n![Angular Code Input](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png)\n\n안녕하세요, 여러분! 오늘은 여러분과 함께 유용한 5가지 Angular 라이브러리를 소개할 거에요. 이 라이브러리들을 제가 제 프로젝트에서 사용해서, 개발 속도를 높였어요. 확실히 이 라이브러리들이 여러분들의 삶을 훨씬 편하게 만들 거예요. 그럼, 어떤 것들이 있는지 한번 알아볼까요?\n\n## Angular Code Input\n\n![Angular Code Input](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 프로젝트에서는 사용자 인증 프로세스에 OTP와 같은 확인 코드를 사용하기도 합니다. 일반 텍스트 상자를 사용하면 입력 확인을 수동으로 처리해야 합니다. 그러나 이 라이브러리를 사용하면 입력 확인을 쉽게 할 수 있습니다. 또한 이 라이브러리는 UI에 멋진 룩을 더하는 좋은 컴포넌트를 제공합니다. 클립보드 이벤트도 지원됩니다. 따라서 별도의 컴포넌트를 생성할 필요가 없습니다. 이 라이브러리는 Angular 7 이상 버전만 지원합니다.\n\n## Angular Gridster 2\n\n![image](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_2.png)\n\n대시보드를 만들 때 서로 다른 카드를 표시합니다. 때로는 드래그 앤 드롭, 크기 조절 기능을 추가하고 싶을 때도 있습니다. 또한 반응형이어야 합니다. 이러한 것들을 수동으로 처리하는 것은 매우 번거로운 작업입니다. 이런 경우에 이 라이브러리가 도움이 됩니다. Angular Gridster에는 이러한 기능이 모두 갖춰져 있습니다. 이 라이브러리를 사용하여 멋진 대시보드를 만들 수 있습니다. 다양한 옵션이 있습니다. 이 링크를 통해 이 라이브러리의 데모를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Ngx 마크다운\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_3.png)\n\n만약 Angular 프로젝트를 위한 마크다운 에디터를 찾고 있다면, 여기 있어요. 이 라이브러리는 구문 강조, 수학식 지원, 이모지 지원, 차트 및 다이어그램 시각화와 같은 기능을 갖춘 마크다운 에디터를 제공합니다. 이 라이브러리는 행동을 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 또한 이 라이브러리와 놀 수 있는 데모 프로젝트도 제공됩니다.\n\n## Ng2 차트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_4.png)\n\nAngular에서 데이터 시각화를 위한 훌륭한 라이브러리입니다. 이 라이브러리는 막대 차트, 파이 차트, 산점도, 선 그래프 등 다양한 차트를 제공합니다. 이 라이브러리는 chart.js를 기반으로 하고 있습니다. 따라서 Angular 프로젝트에서 chart.js 라이브러리의 모든 차트를 사용할 수 있습니다. 이 링크에서 라이브러리 데모를 확인할 수 있습니다.\n\n## Ngx Cookie Service\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 라이브러리는 Angular에서 쿠키를 쉽게 처리할 수 있는 서비스를 제공합니다. 이 라이브러리는 Angular 서비스로 작동합니다. 이 라이브러리를 사용하여 쿠키의 읽기, 설정 및 삭제 작업을 수행할 수 있습니다. 또한 이 라이브러리는 서버 측 렌더링을 지원합니다. 라이브러리를 설치한 다음 컴포넌트에 주입하면 됩니다. 이제 이것을 일반 Angular 서비스로 사용할 수 있습니다.\n\n지금까지입니다. 프로젝트에서 이 라이브러리를 사용해보세요. 또 다른 블로그에서 만나요. 즐거운 코딩하세요! 이 블로그가 도움이 되었다면 좋아요를 부탁드립니다.\n\n![Angular Libraries](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_6.png)\n\n저의 웹사이트 https://hirushafernando.com/ 에서 연락을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 저자를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png"},"coverImage":"/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 성능을 향상시키는 Angular FormArray 팁","description":"","date":"2024-05-17 21:12","slug":"2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners","content":"\n\n## 웹 개발\n\n![이미지](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png)\n\n비디오 버전은 여기에서 확인할 수 있습니다.\n\nFormArrays의 한 가지 큰 도전 과제는 최적의 웹 성능과 원활한 사용자 상호 작용을 보장하기 위해 이벤트 리스너를 효율적으로 관리하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 사례 연구에서는 FormArray의 항목이 변경될 때 API에서 데이터를 가져 오는 두 가지 전략을 밝힐 것입니다. 실제 예제와 함께 이를 살아있게 만들 것입니다. 각 접근 방법을 안내하고 코드 디자인 및 웹 성능에 어떤 것이 도움이 될지 살펴볼 것입니다. 그러니 코딩 모자를 준비하고 시작해 보세요.\n\n기술적인 면으로 들어가기 위해 실제 시나리오로 들어가겠습니다. \"사용자 지정 필드 집합 만들기\" 양식을 보여드리겠습니다:\n\n![이미지](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_1.png)\n\n여기서 \"필드 클래스 추가\" 버튼을 클릭하고 필드 클래스를 선택한 후, 필드 클래스를 선택하면 Get 요청이 트리거되어 API로 전송되는 것을 관찰하십시오. 두 번째 필드 클래스를 선택하면 추가 요청이 전송됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_2.png)\n\n이제 재미있는 부분으로 들어가서 두 가지 다른 방법으로 이러한 요청을 API로 보내는 방법을 살펴보겠습니다. 각 방법이 응용 프로그램의 성능에 어떤 영향을 미치는지 주의 깊게 살펴보세요.\n\n그래서 먼저 소스 코드를 확인하고 현재 요청이 UI에서 API로 전송되는 방법을 살펴보겠습니다.\n\n\"사용자 지정 필드 세트 작성\" 양식의 템플릿에서 fieldclasses 섹션에서 다음 FormArray가 있는 것을 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n20번 라인에는 `mat-autocomplete` 목록이 포함되어 있습니다. 사용자가 \"Add Fieldclass\" 버튼을 클릭할 때마다 새로운 `mat-autocomplete`가 FormArray에 추가됩니다. 이는 가능한 fieldclass 값에 대한 제안이 포함된 드롭다운을 표시합니다.\n\nngOnInit() 라이프사이클 훅에서 다음 이벤트 리스너가 있습니다:\n\n`.valueChanges()`에 대한 구독은 fielclasses FormArray에 연결되어 있어, FormArray에서 변경이 발생할 때마다 부모 컴포넌트로 이벤트 getOutputKeysForFieldClasses를 발행합니다.\n\n부모 컴포넌트는 이를 표현식으로 캐치합니다: (getOutputKeysForFieldClasses)=\"getOutputKeys($event)\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 Store Service에서 getOutputKeysForFieldClasses(fieldClasses)을 호출할 거에요:\n\n요즘 구현 상태를 확인하려면 브라우저에서 애플리케이션의 동작을 확인해봐요.\n\n\"사용자 정의 필드 집합 만들기\" 양식을 다시 열고 보내질 API 요청의 숫자를 세볼 거에요.\n\n- 먼저, \"필드클래스 추가\"를 클릭할 거에요,\n- 항목을 선택하면 하나의 요청이 보내져요,\n- \"필드클래스 추가\"를 다시 클릭합니다. 두 번째 클릭 후에는 FormArray에 두 번째 폼 필드만 있지만, 아직 필드클래스를 선택하지 않았어요. 그런데 또 다른 요청이 API로 전송돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_3.png\" /\u003e\n\n사용자가 \"Add Field class\" 버튼을 클릭할 때마다 새로운 요청이 API로 전송됩니다. 심지어 새로 추가된 폼 필드가 아직 비어 있더라도 그렇습니다.\n\n그 이유는 FormArray에 변경 사항이 있기 때문에 .valueChanges() 이벤트 리스너의 내용이 실행됩니다. 그러나 예상한 동작은 Fieldclass를 선택한 후에만 API로 Get 요청을 보내야 한다는 것입니다.\n\n# 문제 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 문제를 어떻게 해결할 수 있는지 살펴봅시다.\n\n전체 FormArray의 변경 사항 구독을 제거할 것입니다. 대신 새로운 이벤트 리스너를 추가하고 `mat-autocomplete`에 연결할 것입니다.\n\n따라서 옵션을 선택한 후 onSelectFieldclass() 메서드를 호출할 것이며, 이 메서드는 FormArray에서 Fieldclasses 목록을 검색하여 전달된 이벤트의 매개변수로 제공할 것입니다.\n\n이전에는 Fieldclasses 목록도 FormArray에서 검색되었지만, getOutputKeysForFieldClasses 이벤트를 트리거해야 하는 시점이 다소 정확하지 않았습니다. 이제 옵션이 선택된 경우에만 이 이벤트가 발생됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 브라우저에서 동작을 확인해 볼게요:\n  \n- \"Add Fieldclass\"를 클릭하면 요청이 전송되지 않아요.\n- 2번 클릭해 봐도 요청이 전송되지 않아요.\n- 그런데 Fieldclass를 선택하면 요청이 한 번만 전송돼요.\n\n\u003cimg src=\"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_4.png\" /\u003e\n\n이제 요청이 예상대로 올바르게 전송돼요! 이를 통해 문제를 해결했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그냥 명심해야 할 점은 API로 보내는 요청의 수가 늘어나거나 예상된 것보다 훨씬 많은 이벤트 리스너의 문제로 인해 성능 문제가 발생하지 않도록 하려면 예제처럼 로직을 올바른 위치에 추가해야 한다는 것이에요.\n\n# 두 가지 접근 방식 비교\n\n여기서 FormArray의 .valueChanges observable을 구독한 것과 `mat-autocomplete` 태그의 (optionSelected) 이벤트에 의해 트리거된 onSelectItem() 메소드를 사용한 새로운 접근 방식 사이의 차이를 요약해 봤어.\n\n디자인과 성능 측면에서 그 차이는 상당히 중요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원래 접근 방식: valueChanges 이벤트에 대해\n\n- 이벤트 트리거: FormArray의 valueChanges 이벤트 리스너는 배열 내의 양식 컨트롤의 값이 변경될 때마다 또는 FormArray에 새 양식 컨트롤이 추가될 때마다 트리거됩니다. 이는 옵션 자동완성에서 옵션을 선택하는 것뿐만 아니라 모든 변경에 반응한다는 것을 의미합니다.\n- 반응 범위가 넓음: 이벤트 리스너는 변경 유형을 구분하지 않습니다. 관련없는 변경에 반응할 수 있으며, 이는 내부 논리의 불필요한 실행으로 이어질 수 있습니다.\n- 성능: 다른 유형의 FormArray 업데이트가 발생하는 경우에도 데이터를 가져오지 않아도 되는 경우를 고려하면 효율적이지 않습니다.\n\n## 새로운 접근 방식: optionSelected 이벤트에 대해\n\n- 특정 이벤트 트리거: onSelectItem() 메서드는 `mat-autocomplete`의 (optionSelected) 이벤트에 의해 특별히 트리거됩니다. 이렇게하면 메서드가 옵션을 활성적으로 선택했을 때만 실행되도록 보장하여 좀 더 명확해집니다.\n- 단순화된 논리: 메서드는 선택한 옵션 처리에 직접 초점을 맞춥니다. 이로 인해 코드가 쉽고 유지보수가 쉬워지게 됩니다.\n- 성능 향상: 선택 이벤트에만 반응함으로써 FormArray의 모든 미세한 변경에 반응하는 성능 부담을 피할 수 있습니다. 변경 빈도가 높은 양식에서 특히 유익할 수 있습니다.\n- 부수 효과 감소: 옵션 선택에 대한 응답을 단지 옵션 선택으로 제한함으로써 관련 없는 양식 컨트롤 변경으로 인한 불필요한 프로세스 또는 부수 효과를 트리거할 위험이 줄어듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, `mat-autocomplete`의 (optionSelected) 이벤트에 관련된 새로운 접근 방식은 이벤트 중심 프로그래밍에서 더 나은 방법으로, 특히 복잡한 양식에서 효과적입니다.\n\n그리고 이로써 우리는 Angular에서 양식 이벤트 처리를 최적화하는 방법에 대해 알아보았습니다! 기억해 주세요, 올바른 접근 방식은 좋은 코드를 훌륭한 코드로 만들 수 있으며, 성능을 향상시키고 개발 프로세스를 간소화할 수 있습니다.\n\n# 최종 생각\n\n오늘 탐구한 것은 빙산의 일각에 불과합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n흥미로운가요?\n\n여기에는 \"웹 성능 101\" 비디오 코스에 포함된 내용 일부만 입니다. 웹 개발 스킬을 더 향상시키고 싶다면, 이 기회를 놓치지 마세요!\n\n이 여정을 시작한 이미 약 3만 명의 학생들과 함께 웹 성능의 예술과 과학을 마스터하는 여정에 참여하세요 🚀. 아래 링크를 확인하고 무엇이 이렇게 핫한지 직접 확인해보세요!\n\n만약 이 포스트가 도움이 되었다면, 친구들과 공유해보세요. 호기심을 갖고 코딩을 계속해 나가다 보면, 다음 글에서 다시 만나요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알고 싶으세요?\n\n내가 똑똑하고 호기심 많은 사람들을 위해 엔지니어링, 기술, 리더십에 대해 쓰고 있어요 🧠💡. 독점 액세스를 위한 무료 이메일 뉴스레터에 가입해보세요.","ogImage":{"url":"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png"},"coverImage":"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 17의 새로운 제어 흐름 구문 내용 정리","description":"","date":"2024-05-17 21:10","slug":"2024-05-17-MustKnowAngular17NewControlFlowSyntax","content":"\n\n\n![New Control Flow Syntax in Angular](/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png)\n\n앵귤러 17과 18에서 소개된 새로운 제어 흐름 구문에 대한 포괄적인 설명을 제공해 드릴게요. 예제를 통해 자세히 설명해 드리겠습니다:\n\n# 앵귤러에서의 새로운 제어 흐름 구문\n\n앵귤러 17과 18은 내장 구문을 사용하여 템플릿 내에서 제어 흐름을 더 직관적이고 선언적으로 다룰 수 있도록 제공합니다. 이를 통해 *ngIf, *ngFor, ngSwitch와 같은 디렉티브를 사용할 필요가 없어져 가독성과 유지보수성이 향상되었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 개념:\n\n- @if...else: 불리언 표현식에 기반하여 조건부 렌더링을 구현합니다. 프로그래밍 언어의 전통적인 if...else 문과 유사합니다.\n- @for...of: 배열이나 iterable을 반복하며 각 항목과 루프 내의 컨텍스트 변수에 액세스를 제공합니다.\n- @switch...case...default: 조건에 기반하여 다중 분기를 제공하며 JavaScript의 switch 문과 일치합니다.\n\n예시\n\n```js\n\u003cdiv\u003e\n  @if (isLoggedIn) {\n    \u003cp\u003e환영합니다, { username }님!\u003c/p\u003e\n    \u003cbutton (click)=\"logout()\"\u003e로그아웃\u003c/button\u003e\n  } else {\n    \u003cp\u003e계속하려면 로그인하세요.\u003c/p\u003e\n    \u003cbutton (click)=\"login()\"\u003e로그인\u003c/button\u003e\n  }\n\u003c/div\u003e\n\n\u003cul\u003e\n  @for (let item of items; track item.id) {\n    \u003cli\u003e{ item.name }\u003c/li\u003e\n  }\n  @empty {\n    \u003cli\u003e표시할 항목이 없습니다.\u003c/li\u003e\n  }\n\u003c/ul\u003e\n\n\u003cdiv\u003e\n  @switch (status) {\n    @case ('pending') {\n      \u003cp\u003e주문 처리 중입니다.\u003c/p\u003e\n    }\n    @case ('shipped') {\n      \u003cp\u003e주문이 발송되었습니다! \u003ca href=\"#\"\u003e여기\u003c/a\u003e에서 추적하세요.\u003c/p\u003e\n    }\n    @default {\n      \u003cp\u003e주문 상태를 확인할 수 없습니다.\u003c/p\u003e\n    }\n  }\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설명:\n\n## 조건부 렌더링:\n\n- @if 블록은 isLoggedIn 변수에 따라 조건부로 콘텐츠를 렌더링합니다.\n- else 블록은 isLoggedIn이 false인 경우 대체 뷰를 제공합니다.\n\n## 반복문:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- @for (let item of items; track item.id)은 items 배열을 반복합니다.\n- let item은 루프 내 각 항목에 대한 지역 변수 item을 생성합니다.\n- track item.id는 효율적인 DOM 업데이트에 사용되는 trackBy 표현식입니다.\n- 루프 몸체는 각 항목에 대해 목록 항목 'li'를 렌더링하고 해당 name 속성을 표시합니다.\n- @empty 블록은 배열에 항목이 없는 경우 메시지를 표시합니다.\n\n# 다중 분기:\n\n- @switch (status)는 status 변수를 평가합니다.\n- @case 블록은 특정 값(‘pending’, ‘shipped’)과 일치합니다.\n- 일치하는 case 블록은 상태에 기반하여 해당 내용을 렌더링합니다.\n- @default 블록은 일치하지 않는 경우를 처리합니다.\n\n# 이점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 개선된 가독성: 새로운 구문은 표준 프로그래밍 구조와 더 밀접하게 일치하여 템플릿을 이해하기 쉽게 만듭니다.\n- 불필요한 길이를 줄인: 긴 지시어 구문(*ngIf, *ngFor 등)을 제거하여 코드를 더 깨끗하게 만듭니다.\n- 향상된 유지보수성: 선언적 접근 방식은 로직을 단순화하고 유지보수성을 향상시킵니다.\n\n# 추가 사항:\n\n- 새로운 제어 흐름 구문은 선택 사항입니다. 선호하는 경우 기존 지시어를 계속 사용할 수 있습니다.\n- 데이터가 없는 경우 정보 전달 메시지를 제공하려면 컬렉션을 반복할 때 @empty 블록을 사용하는 것을 고려해보세요.\n\nAngular 17 및 18의 새로운 제어 흐름 구문에 대한 더 많은 예제를 확인할 수 있습니다. 그것의 다재다능성을 보여줍니다.  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 중첩된 제어 흐름:\n\n```js\n- 카테고리:\n- 제품:\n```\n이 예제는 @for를 사용하여 중첩된 루프를 보여줍니다. 외부 루프는 카테고리를 반복하고, 내부 루프는 각 카테고리 내의 제품을 반복합니다. 내부 루프 내의 @empty 블록은 카테고리에 제품이 없는 경우 메시지를 제공합니다.\n\n# 2. bind를 사용한 조건부 속성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cinput type=\"text\"\n       @bind-disabled=\"!isEditEnabled\"\n       placeholder=\"이름을 입력하세요\"\u003e\n```\n\n@bind 지시문을 사용하면 속성에 바인딩을 조건부로 적용할 수 있습니다. 여기서 disabled 속성은 !isEditEnabled에 바인딩됩니다. isEditEnabled가 false인 경우 입력 필드가 비활성화됩니다.\n\n# 3. 색인($index) 및 다른 문맥 변수를 사용한 루핑:\n\n```js\n\u003cul\u003e\n  @for (let item of items; track item.id) {\n    \u003cli\u003e아이템 #{ $index + 1 }: { item.name }\u003c/li\u003e\n  }\n\u003c/ul\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시는 $index를 활용하여 각 항목의 인덱스(1부터 시작)를 표시합니다. @count (총 항목 수), @first (첫 번째 항목 여부), @last (마지막 항목 여부), @even 및 @odd와 같은 다른 문맥 변수를 사용하여 더 복잡한 형식을 지정할 수도 있습니다.\n\n### 4. 논리 연산자와 함께 @if 조합하기:\n\n```js\n\u003cdiv\u003e\n  @if (isLoggedIn \u0026\u0026 hasPermission('edit')) {\n    \u003cbutton (click)=\"editUser()\"\u003eEdit User\u003c/button\u003e\n  }\n\u003c/div\u003e\n```\n\n@if를 사용하면 논리 연산자(\u0026\u0026, ||, !)를 사용하여 조건을 결합할 수 있습니다. 여기서 사용자가 로그인되어 있고 \"편집\" 권한을 가지고 있을 때에만 버튼이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 복잡한 조건과 함께 @switch 사용하기:\n\n```js\n\u003cdiv\u003e\n  @switch (userRole) {\n    @case ('admin') {\n      \u003cp\u003e환영합니다, 관리자님!\u003c/p\u003e\n    }\n    @case ('editor', 'moderator') {\n      \u003cp\u003e환영합니다, 콘텐츠 편집자/모더레이터님!\u003c/p\u003e\n    }\n    @default {\n      \u003cp\u003e환영합니다, 사용자님!\u003c/p\u003e\n    }\n  }\n\u003c/div\u003e\n```\n\n@switch는 복잡한 조건을 가진 여러 경우를 처리할 수 있습니다. 여기서는 쉼표로 구분된 값들('admin', 'editor', 또는 'moderator')에 대해 확인합니다.\n\n이것들은 단지 몇 가지 예시일 뿐입니다. 새로운 제어 흐름 구문은 Angular 템플릿에서 조건부 렌더링과 루프 로직을 유연하고 강력하게 다룰 수 있는 방법을 제공합니다. 자유롭게 실험하고 더 많은 기능을 탐구해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수고하셨습니다,\n\n찬단","ogImage":{"url":"/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png"},"coverImage":"/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png","tag":["Tech"],"readingTime":4},{"title":"완벽한 TS monorepo를 만드는 방법","description":"","date":"2024-05-17 21:06","slug":"2024-05-17-MyquestfortheperfectTSmonorepo","content":"\n\n\n![이미지](/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png)\n\n올해에 도구 및 모노 레포와 관련된 이해력을 개선하기 위해 부단히 시간을 보냈습니다. 제가 한 일 중 일부를 공유해볼 테니, 혹시 필요하신 분들께 도움이 되길 바라겠습니다.\n\n도구와 모노 레포에 대한 향상된 지원이 지난 몇 년 동안 JavaScript/TypeScript 생태계를 엄청나게 성장시켰지만, 모든 것이 어떻게 연결되는지 완전히 이해하지 않으면 여전히 많은 문제를 겪을 수 있다는 사실에 놀라실 지도 모릅니다.\n\n도구와 모노 레포는 모두 매우 지루한 주제이기 때문에 내용을 간결하게 유지하려 노력하겠습니다. 가능한 한 외부 소스에 링크를 걸겠지만, 글이 짧지는 않을 것입니다. 다루어야 할 것들이 많거든요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실제 예시\n\n바로 시작하고 싶다면 여기가 좋아요. PNPM (메인), NPM 및 Yarn의 클래식 및 모던 버전에 대한 병렬 브랜치가 있습니다.\n\n저는 훌륭한 Turborepo 스타터 및 그들의 \"주방 싱크\" 예제 코드로 많은 것을 배웠으므로 그들을 확인하고 모노레포에 대해 처음이라면 그들의 모노레포 핸드북도 읽어보시는 것을 추천합니다.\n\n이 기사는 좀 더 심층적으로 다가가며 정보 조각들을 결합하여 모든 고려 사항과 일반적인 함정을 명확하게 개요하고자 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배경 이야기\n\n지난 6년 동안 나는 두 개의 중간 규모 프로젝트에 대부분의 전문적 시간을 할애했어요. 그 두 프로젝트는 서로 다른 회사들을 위해 만들어졌지만, 둘 다 동일한 플랫폼 위에 구축되어 있어요.\n\n스택 자체는 이 글에서 논의하는 문제와 해결책과는 크게 관련이 없지만, 참고로 다음과 같아요:\n\n- Firebase와 Google Cloud Platform을 기반으로 한 Node.js 백엔드\n- Vercel에서 호스팅되는 Next.js를 기반으로 한 React.js 클라이언트\n- 데이터를 위해 Firestore와 Redis 사용\n- TypeScript\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트 중 첫 번째는 2017년 9월에 시작되었습니다. 그 때는 모노레포에 대한 경험이 부족하고 사용 가능한 도구가 납득할 만하지 않았기 때문에 저는 추가 복잡성을 피하기로 하고 모든 것을 함께 묶기로 선택했습니다.\n\n두 번째 프로젝트는 2019년 6월에 시작되었습니다. 그 때에는 모노레포가 여러 플랫폼에 배포할 때 매우 중요하다는 것을 알 수 있었지만, 여전히 모든 것을 간단하게 유지하고 싶어서 Yarn 워크스페이스를 적용했습니다.\n\n## 답답함\n\n두 번째 설정은 얼마 동안 만족스러웠지만, 일부 측면은 분명히 최적이 아니거나 심지어 답답했습니다. 저는 패키지의 빌드 순서를 수동으로 관리하고 있었고, 그러다가 가끔 사소한 것들을 잊거나 중복 빌드를 일으키기도 했는데, 모든 것이 최신 상태임을 확인하려고 했기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에 다른 프로젝트의 팀 환경에서 비슷한 설정을 사용하게 되면, 구성원들이 패키지 중 하나를 (다시) 빌드하는 것을 잊어서 문제에 부딪히게 될 때가 많아졌습니다.\n\n시간이 지나며 커뮤니티에서 ESM 채택이 증가함에 따라 순수 ESM인 종속성 업데이트를 겪게 되었습니다. 우리의 코드베이스와 잘 어울리도록 하려고 여러 차례 시도했지만 성공하지 못했으며, 결과적으로 일부를 이전 버전으로 고정시켰는데 이는 지속 가능한 해결책이 아닙니다.\n\n첫 번째 프로젝트의 설정은 여러 플랫폼의 모든 종속성을 단일 패키지 매니페스트에 모아놓은 것으로 ESM 채택을 더 어렵게 만들고 있었습니다. 게다가 더 느린 서버 배포 및 시작 시간과 같은 다른 문제를 초래하기 시작했습니다.\n\n두 프로젝트를 동시에 진행하는 것만으로도 어렵기 때문에 도구 및 작업에 에너지와 시간을 낭비할 필요가 없습니다. 정신을 차리기 위해, 이러한 문제들을 한 번에 처리하고 모든 것이 어떻게 작동하며 어떻게 연결되는지 확신할 필요가 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 프로젝트에 필수적인 모든 측면을 다루기 위해 mono-ts 보일러플레이트를 개발하기 시작했습니다. 이 보일러플레이트는 이 글에서 다루는 모든 개념의 작동 예제를 제공하므로, 이해하기 어려운 부분이 있을 때 참고해 주세요.\n\n# 주요 주제\n\n좋은 모노레포 설정의 중추는 다음과 같습니다:\n\n- 빠르고 결정적인 빌드 및 작업 조작\n- 원하는 곳에서 ESM을 사용하고 생성\n- 패키지를 독립적으로 배포할 수 있는 능력\n- 코드 및 유형에 대한 IDE 정의로 이동\n- 개발 중에 라이브 코드 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배포에 관한 도전은 대부분의 개발자가 마주치는 문제는 아니며, 이는 주로 사용하는 플랫폼에 따라 다릅니다. 우리의 경우에는 Firebase와 관련이 있으며, 현재 해당 도구가 모노 리포를 원산지로 지원하지 않는다는 점이 문제입니다.\n\n# 빌드 및 작업 조정\n\nTurborepo가 출시되자마자, 저는 그것이 내가 오랫동안 염원했던 것임을 즉시 알았지만, 그것은 그 종류의 첫 번째 해결책은 아니었습니다. Nx와 Rush는 이미 오랜 시간 동안 존재했기 때문에, 그것들을 여기서 언급하는 것은 공정한 일일 뿐이며, 다른 노력들도 있을 것으로 추측됩니다. Turborepo와 Nx는 여러 측면에서 유사해 보이지만, Nx에 대한 실제 경험이 없기 때문에 자세히 다루지는 않겠습니다.\n\n간단히 말하면, Turborepo는 빌드, 린팅, 개발 서버 시작과 같은 개별 작업 단위로 각 패키지가 서로에게 어떻게 의존하는지 구성하는 방식으로 작동합니다. 각 작업에 대해 필요한 입력 및 출력을 정의하여 중간 결과를 캐시하고 입력 매개변수가 변경된 경우에만 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 Vercel은 프로젝트를 위해 Turborepo를 위한 공유 클라우드 캐시를 선택적으로 제공합니다. 따라서 여러분이 자신의 기기에서 실행한 작업은 곧 동료의 기기나 CI 파이프라인에서 실행하는 작업의 속도를 높일 수 있습니다. 이것이 대규모 프로젝트에 매우 강력할 수 있다는 것을 상상하기 어렵지 않습니다.\n\n# 내부 패키지; 빌드할까 말까\n\n모노 리포 설정을 선택하는 가장 흔한 이유는 공유 코드를 분리하고 여러 앱 및 서버 배포에서 재사용할 수 있게 하려는 것입니다. 이는 의존성을 명확히 유지하고 역할의 분리를 촉진합니다.\n\n예를 들어, 여러분은 동일한 UI 구성 요소 세트를 사용하는 여러 웹 애플리케이션이 있거나, 서버 및 클라이언트 코드가 일부 동일한 유형 및 비즈니스 로직을 사용하는 경우가 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 내부 패키지들은 소스 코드가 비공개이기 때문에 NPM에 이러한 내부 패키지를 게시하려는 의도가 없습니다. 또한 이러한 패키지는 이 저장소의 컨텍스트에서만 사용하게될 가능성이 높습니다.\n\nTypeScript로 작업할 때는 이러한 공유 내부 패키지를 연결하는 두 가지 다른 패턴 중에서 선택할 수 있습니다.\n\n## 1. 기존 빌드 패키지 접근 방식\n\n이 패턴에서는 TS 코드를 JavaScript로 빌드하고 선택적으로 번들할 수 있습니다. 패키지 매니페스트를 정의하여 컴파일된 JS 출력을 가리키도록 설정합니다. 이 방식은 NPM에 패키지를 게시하려는 경우와 정확히 동일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식의 몇 가지 이점은 다음과 같습니다:\n\n- 각 패키지는 개별적으로 빌드되며, Turborepo와 같은 도구를 사용하면 효율적으로 캐시할 수 있습니다.\n- TypeScript 경로 별칭을 사용하기 쉽습니다. (기본적으로) 번들러가 결과물에서 이를 제거하기 때문입니다. 결과물은 노드 모듈에서만 가져오며 코드는 하나 이상의 독립된 파일로 결합됩니다.\n- .js 및 /index.js 접미사와 같은 형식에서 필요한 엄격한 가져오기 규칙을 사용하지 않고도 ESM 모듈을 생성할 수 있습니다. 기존의 큰 CJS 코드베이스가 ESM 출력을 생성해야 하는 경우에 유용할 수 있습니다. 경로 별칭과 유사한 이유로 번들된 출력 파일에 상대적인 가져오기가 포함되지 않습니다.\n- ESM 및 CJS와 같은 다양한 형식을 동시에 출력할 수 있습니다. 요즘은 ESM을 지원하지 않는 도구를 사용하는 경우에 주로 유용할 것입니다.\n\n이 접근 방식의 몇 가지 단점은 다음과 같습니다:\n\n- 더 많은 구성과 필요에 따라 도구를 사용해야 합니다.\n- 번들러를 사용하는 경우 결과물을 소스 코드 및 IDE의 정의로 맵핑하는 데 약간의 과정을 거쳐야 할 수 있습니다.\n- 개발 환경에서 실시간 코드 업데이트를 생성하는 감시 작업을 진행하기 위해 더 많은 구성이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nESM, 번들링 및 감시 작업에 대한 이러한 포인트들에 대해 돌아올 거에요, 그러니 조금만 기다려 주세요.\n\n## 2. \"내부 패키지\" 접근 방식\n\n이 용어는 Turborepo의 Jared Palmer에 의해 만들어졌어요. 이 경우 빌드 단계를 생략하고, 패키지 매니페스트를 구성하여 Typescript 소스 파일을 직접 가리키게 해요.\n\n이 접근 방식의 몇 가지 이점은 다음과 같아요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성이 거의 없어 따르기 쉽습니다.\n- Next.js 같은 개발 서버를 사용하는 환경에 대한 기본적인 실시간 코드 업데이트\n- 소스 파일 및 유형에 대한 기본 IDE 이동 정의\n\n이 방법의 일부 단점은:\n\n- 대규모 저장소에 대해 효율적이지 않습니다. 컴파일 및 번들링을 소비 환경에 남겨 두면 일부 패키지가 변경될 때 모든 것이 다시 빌드되어야 합니다. Turborepo는 중간 결과를 캐시할 수 없기 때문에 빌드 시간이 증가할 것입니다.\n- TypeScript 경로 별명을 사용하려면 각 패키지에 대해 고유한 별칭을 구성해야 합니다. 그렇지 않으면 컴파일러가 혼란스러워집니다. 저는 별칭을 사용하는 것을 좋아하지만 내부 패키지에는 깊게 중첩된 파일 구조가 아니기 때문에 필수적이지 않다고 생각합니다.\n- 패키지를 NPM에 발행할 수 없습니다. 왜냐하면 매니페스트가 TypeScript와 번들러를 가정하기 때문입니다.\n\n이러한 일부 단점에 대해 Turborepo 블로그 게시물에서 논의되기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 내 선호도\n\n현재 내부 패키지를 모두 빌드하는 것을 선호합니다. 이렇게 하면 확장 문제 없이 확장이 가능하기 때문에 좋아합니다. 그러나 복잡성을 줄일 수있는 경우에는 좋아합니다. 그래서 이 부분은 변할 수 있습니다. 보일러플레이트에는 두 가지 접근 방식이 모두 테스트에 포함되어 있습니다.\n\n하나의 프로젝트에서 내부 패키지를 빌드 패키지로 사용하여 비공개로 NPM에 발행하여 동일한 회사 내의 다른 저장소와 공유합니다.\n\n# ES Modules\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 생태계의 많은 사람들이 CommonJS 모듈에서 현대 ES 모듈 형식으로 전환하려는 노력에서 고통과 좌절을 경험했습니다. CommonJS 모듈은 Node.js를 위해 고안되었지만 이제는 자바스크립트 표준의 일부인 현대적인 ES 모듈 형식으로의 전환이 필요해 보입니다.\n\nESM 및 전환에 대한 여러분의 의견이 무엇이든, 이 형식이 CJS보다 우수하다는 데에는 동의할 수 있을 것이며, 가능하면 빨리 이를 채용해보아야 할 것이라 생각합니다.\n\n저의 개인적인 좌절은 대부분 이해 부족에서 왔다고 생각하며, 결국에는 몇 가지 기본 원칙을 이해하면 현대적인 도구들과의 통합이 복잡하지 않다는 것을 느꼈습니다.\n\n몇 년 전에 비슷한 글을 읽었더라면, 훨씬 많은 시간과 좌절을 절약할 수 있었을 텐데요. 거의 모든 걸 이해하기 까지 시간이 많이 걸린 것 같은데, 부적합한 리소스를 찾은 거나 마찬가지였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 당신의 TypeScript 코드가 CJS를 출력할 수 있습니다\n\n약간은 당연해 보이지만, 모두가 이를 인식하고 있는 것은 아닙니다. TypeScript 빌드 과정의 출력에 require 문이 포함되어 있다면, 출력 대상이 ESM이 아님을 의미합니다.\n\nTypeScript 소스에서 import/export 문을 사용한다고 해서 ESM 호환 코드를 작성 중이라고 가정하는 것은 잘못된 판단일 수 있습니다.\n\n에디터와 컴파일러는 경고 없이 ESM 모듈을 가져올 수 있게 허용하지만, CJS 출력에서는 런타임 오류를 발생시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## CJS는 상위 레벨에서 ESM을 가져올 수 없습니다\n\nCJS 모듈은 동기적이고, ESM 모듈은 비동기적이기 때문에 CJS에서 상위 레벨에서 ESM 모듈을 직접 가져올 수 없습니다.\n\nCJS 코드에서 ESM 모듈을 가져와야 하는 경우 다음과 같이 동적 임포트를 사용해야 합니다:\n\n```js\nconst someEsModule = await import from “some-es-module”\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 CJS 모듈은 최상위 await 문을 가질 수 없기 때문에 다음과 같이 다른 async 함수 내부에서만 실행할 수 있습니다:\n\n```js\nasync function useSomeModule() {\n  const someEsModule = await import from \"some-es-module\";\n  someEsModule.someFun()\n}\n```\n\n이전에 언급한 대로, 번들러와 TypeScript 컴파일러는 이러한 호환성 문제에 대해 경고하지 않으며 런타임에서만 오류가 발생할 수 있습니다.\n\n참고로 Next.js에는 ESM을 변환해주는 transpilePackages 설정이 있습니다. 다른 현대적인 프론트엔드 프레임워크에도 비슷한 기능이 있을 것으로 예상되지만 이 편의성을 제공하는 서버 프레임워크에 대해서는 알려진 바가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ESM는 CJS에서 가져올 수 있습니다\n\n이것은 문제가 될 것이 없습니다. 왜냐하면 동기적 모듈을 비동기적 컨텍스트에서 가져오는 것이기 때문입니다. 이는 비동기 함수를 사용하는 방법과 유사한 메타모델입니다.\n\n가끔 가져온 CJS 모듈이 기본 내보내기를 얻지 못하고 .default를 사용해야 하는 상황에 직면하는 경우가 있었습니다. 그러나 이는 흔한 일은 아니며 그 원인을 규명하지 못해서 일단 주의해두겠습니다.\n\n## 동적 가져오기는 빌드 도구에 의해 대체될 수 있습니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 설명한대로 동적 가져오기를 사용하고 CJS 대상으로 컴파일하는 경우 도구 체인이 이러한 가져오기를 일반적인 require 문으로 변환할 수 있으므로 여전히 ERR_REQUIRE_ESM런타임 오류와 같은 결과를 얻을 수 있습니다.\n\nfirebase-tools 저장소에서 Webpack에 대한 해결책을 찾을 수 있으니 필요하면 다른 번들러에 대해 비슷한 작업을 할 수 있을지도 모릅니다.\n\n## 상대적인 가져오기 경로에서 JS 확장자\n\nESM은 CJS보다 엄격합니다. 가져올 파일을 추측하려 하지 않으며 이러한 이유로 모든 상대적인 가져오기에 파일 확장자를 추가해야 합니다. 또한 디렉토리를 해당 색인 파일로 해석하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번들러를 사용하면 TS 코드에 확장자가 생략되어 있어도 ESM을 출력하도록 지시할 수 있지만 저는 개인적으로 지금은 코드를 ESM으로 작성하는 것을 선호합니다.\n\nVSCode에서는 아래 설정을 사용하여 수입문에 확장자를 추가하고 있습니다. 대부분의 수입문이 자동으로 이뤄지기 때문에 보통 제가 확장자를 직접 추가하지는 않습니다.\n\n```js\n\"typescript.preferences.importModuleSpecifier\": \"shortest\",\n\"javascript.preferences.importModuleSpecifierEnding\": \"js\",\n```\n\n## .ts 접미사 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신이 편집기에서 타입스크립트 코드를 가리키는 import 경로에 .js 확장자를 사용하는 것이 조금 이상하다고 생각한다면, 해결책이 있다는 것을 알아두세요. moduleResolution을 bundler로 설정하면 .ts 확장자를 사용할 수 있게 됩니다.\n\n이 아이디어는 현대적인 번들러들이 정확하게 해석하고 유효한 ESM 코드를 출력하는 방법을 알고 있다는 것입니다. 미래에는 타입스크립트가 자바스크립트의 다음 세대가 될 수도 있기 때문에, 코드를 가져오는 정상적인 방법이 될 수도 있습니다.\n\n하지만 설정 값이 시사하는 대로 번들러를 사용해야 한다는 것에 주의해야 합니다. 타입스크립트 컴파일러는 자신의 출력물을 작성할 때 import 경로를 변경하지 않으며, 경로 별칭을 해결해주지도 않는다는 것과 같은 이유로 그렇습니다.\n\n더 많은 정보를 원하시면 여기를 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ESM 모든 것\n\nESM은 미래이며 CJS와 쉽게 호환되지만 그 반대는 성립되지 않기 때문에 mono-ts의 모든 패키지는 ES 모듈로 되어 있습니다. 필요에 의해 CJS에 명시적으로 고정된 몇 개의 개별 파일만 있습니다.\n\n# 패키지를 격리하여 배포\n\n## Docker\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 이미지에 대한 Turborepo의 멋진 솔루션이 있습니다. 해당 솔루션은 패키지와 내부 종속성을 복사하고 정리하여 Docker 및 캐싱 레이어를 사용하기에 더 적합하게 만듭니다.\n\n## Firebase\n\n내 프로젝트는 현재 모노 레포를 지원하지 않는 플랫폼에 코드를 배포합니다. Firebase Functions 배포 명령은 NPM 패키지와 유사한 자체 포함 디렉토리를 업로드하고, 그 후에 패키지 설치를 실행하고 매니페스트에 선언된 엔트리 포인트를 실행하는 것을 원합니다.\n\n만약 당신의 코드가 모노 레포에 존재하고 내부 공유 패키지를 사용한다면, 이 작업은 쉽지 않습니다. 사람들은 이 문제를 해결하기 위해 다양한 해킹과 스크립트를 활용해왔지만, 우아한 해결책은 존재하지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 프로젝트가 크기 때문에 Firebase 배포를 개별 서비스로 나누는 것을 선호합니다. 이렇게 하면 코드 조직화와 배포, 콜드 스타트 시간을 더 개선할 수 있습니다.\n\nFirebase에 대한 도전 과제와 나중에 만든 일반적인 솔루션에 대해 설명한 별도의 기사를 작성했습니다.\n\n분리 프로세스는 대상 패키지를 새로운 격리된 패키지로 변환하고 해당 루트를 갖습니다. 그런 다음 내부 종속성을 복사하고 전용 락 파일을 생성합니다. 이것은 Turborepo 방법보다 더 격렬한 가지치기 형태이며, NPM에 발행되었다면 패키지의 일부가 되었을 파일과 구조만을 출력합니다.\n\n또한 여러 패키지에서 Firebase로 배포할 수 있게 합니다! 💅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IDE Go-To-Definition\n\n모노레포 설정에서 IDE에서 원하는 두 가지 중요한 점이 있습니다:\n\n- 공유 패키지에서 가져온 코드(함수 또는 클래스와 같은)를 클릭할 때, 편집기가 빌드나 번들 출력이 아니라 원본 Typescript 파일로 이동하길 원합니다.\n- 공유 패키지에서 가져온 타입을 클릭할 때, 편집기가 생성된 d.ts 출력 파일이 아닌 원본 타입 정의로 이동하길 원합니다.\n\n이전에 설명한 \"내부 패키지\" 전략을 사용한다면, 이러한 사항들은 기본적으로 작동합니다. 왜냐하면 패키지 매니페스트가 소스 파일로 직접 링크되기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 여러분의 패키지를 빌드하거나 번들링한다면, 소스 맵 파일 .js.map 및 유형 정의 맵 파일 .d.ts.map을 통해 이를 니기능을 달성할 수 있습니다.\n\n이를 달성하기 위해서는 여러분이 사용하는 번들러에 따라 추가적인 작업이 필요할 수도 있습니다.\n\n저는 현재 tsup을 사용하고 있습니다. 제가 필요한 것에 가장 적합한 것으로 보이지만, 작성 시점에서는 자체적으로 모든 것을 생성할 수 없다는 것 같습니다.\n\n## 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"tsup\"에 .d.ts 파일을 생성하라고 지시할 수는 있으나, 이러한 파일들은 번들 된 출력을 기반으로 하게 될 것이며, 그런 이유 때문에 \"tsup\"에서 .d.ts.map 파일을 생성할 수 있는 옵션을 제공하지 않는 것이라고 가정합니다.\n\n## 해결책\n\n우리가 원하는 출력물을 얻기 위해서는, \"tsup\"에 소스 맵 파일만 출력하도록 지시하고, 번들된 소스 외에 다른 건 무시하도록 할 수 있습니다. 그런 다음 tsc를 사용하여 타입 정의 파일과 그 맵 파일을 동일한 출력 디렉토리에 출력하도록 할 수 있습니다.\n\n명령어는 다음과 같이 보일 것입니다: tsup \u0026\u0026 tsc --emitDeclarationOnly\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`--declaration` 플래그를 사용하여 tsc가 타입 선언만을 생성하고 Javascript 코드를 생성하지 않도록 지시할 수 있습니다. 그리고 `tsconfig`에서 `declaration` 및 `declarationMap`을 true로 설정하거나 이를 추가 플래그로 전달하면 원하는 출력물을 얻을 수 있습니다.\n\n타입 파일은 번들된 파일 구조와 일치하지 않지만 여전히 원본 소스 구조를 반영합니다. 다행히도 이는 편집기에는 문제가 되지 않습니다. 편집기는 모든 타입 파일을 찾을 수 있고 각 파일에는 해당 맵이 있어 소스 코드에서 원래 타입 정의로 쉽게 돌아갈 수 있습니다.\n\n# 실시간 코드 업데이트\n\n이전에 언급했듯이 \"내부 패키지\" 접근 방식을 사용하면 개발 서버를 기본으로 실행하는 환경에서는 실시간 코드 업데이트를 얻을 가능성이 높지만 Javascript로 빌드하거나 번들로 묶은 패키지의 경우 일종의 감시 작업을 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타깝지만 현재 Turborepo에는 파일 변경을 감지하는 메커니즘이 포함되어 있지 않습니다. 그러나 이 문제에 접근하는 두 가지 방법에 대해 이야기해 보겠습니다.\n\n## 번들된 패키지에 대한 병렬 감시 작업 사용\n\n이전 섹션에서 설명한 대로 번들화된 내부 패키지는 자바스크립트 및 유형 선언과 맵 파일을 생성하는 두 개의 별도 명령이 필요할 수 있습니다.\n\n이러한 명령을 순차적으로 실행할 수는 없습니다. 왜냐하면 첫 번째 명령에 감시 작업을 추가하면 해당 명령은 실행을 완료하지 않기 때문입니다. 따라서 두 명령을 병렬로 실행해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 아는 가장 간단한 해결책은 npm-run-all을 사용하는 것이고, 당신의 패키지 매니페스트 스크립트는 다음과 같이 보일 수 있어요:\n\n```js\n\"scripts\": {\n    \"bundle\": \"tsup-node\",\n    \"bundle:watch\": \"tsup-node --watch\",\n    \"type:gen\": \"tsc --emitDeclarationOnly\",\n    \"type:gen:watch\": \"tsc --emitDeclarationOnly --watch\",\n    \"type:check\": \"tsc --noEmit\",\n    \"build\": \"run-p bundle type:gen\",\n    \"dev\": \"run-p bundle:watch type:gen:watch\",\n    \"clean\": \"del dist tsconfig.tsbuildinfo\",\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage \",\n    \"lint\": \"eslint \\\"**/*.ts*\\\"\"\n  },\n```\n\nrun-p 명령은 npm-run-all --parallel의 별칭이에요.\n\n위 전략은 개발 작업들을 직접 시작하는 데 의지할 수 있다면 신뢰성 있게 작동할 수 있다고 생각해요. 각 패키지 개발 작업은 계속 되기 때문에 (종료되지 않으므로), turbo.json 파일에서 한 패키지의 개발 작업이 다른 작업에 의존한다고 정의할 수 없어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최상위 dev 작업을 트리거하면 모든 dev 작업이 동시에 시작됩니다. 그래서 여러분의 패키지의 현재 빌드 상태에 따라 문제가 발생할 수도 있고, 발생하지 않을 수도 있다고 가정합니다. 저에게는 확실한 것 같지 않아요.\n\n지금은 제 프로젝트에는 충분해 보입니다.\n\n## Turbowatch\n\nnpm-run-all 방식은 분명 임시 방편일 뿐 실질적인 해결책은 아닙니다. 따라서 복잡한 monorepo에는 충분하지 않을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTurbowatch는 Turborepo의 누락된 시계 모드를 채우기 위해 설계되었습니다. 아직 직접 시도해보지 않아서 정확히 언행할 수는 없지만, 여러분이 한번 확인해보시길 권장합니다. Turborepo와 함께 사용할 수 있으며 독립적으로도 사용할 수 있습니다.\n\n## Firebase Emulators\n\n파이어베이스 에뮬레이터를 사용하면 Functions 및 Firestore 등의 코드를 배포하지 않고 실행하여 테스트할 수 있습니다. 분리 패키지 솔루션을 사용하는 경우에는 firebase.json의 source 필드를 분리된 출력에 지정하지만, 에뮬레이터는 동일한 진입점을 사용하므로 일반적으로 얻을 라이브 코드 업데이트가 손상되어 이는 주요 사항입니다.\n\n이 문제를 해결하기 위해 firebase-tools 패키지를 포크하여 배포 시 함수로 실행되도록 분리된 것을 통합해야 했습니다. 이렇게 하면 일반적으로 소스 코드에 에뮬레이터를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이어베이스 툴의 기능에 큰 변화를 주지 않고, 사전 배포 단계를 추가하는 것 외에는 fork의 기능을 거의 사용하지 않아서 모든 프로젝트에서 안전하게 사용할 수 있다고 생각합니다. 제가 상위 저장소에서 정기적으로 변경 사항을 가져와 동일한 버전으로 업데이트를 게시하여 동기화를 유지할 것입니다.\n\n파이어베이스 팀이 제 솔루션을 채택하기를 기대하거나 모노 리포를 지원할 수 있는 더 나은 방법을 찾기를 바라겠습니다.\n\n# 결론\n\n이렇게 매우 지루한 주제에 대해 이처럼 멋지게 계속 읽어주셔서 영광으로 생각하며, 웃음이나 유머가 전혀 없었던 점에도 이렇게 멀리까지 이어주셨다니 감사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 이런 것을 스스로 파악해야 하는 것보다 더 편리하다고 생각해요, 그래서 가치 있는 것을 배웠으면 좋겠어요.\n\n저는 시간이 흘러 이 기사를 업데이트하려고 노력할 거예요, 보일러플레이트 코드에 대해서도 그렇게 할 계획이에요. 만약 중요한 개선 제안이 있다면, 의견을 남기거나 GitHub 이슈를 만들어 주세요.","ogImage":{"url":"/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png"},"coverImage":"/assets/img/2024-05-17-MyquestfortheperfectTSmonorepo_0.png","tag":["Tech"],"readingTime":14},{"title":"React jsx를 이해하는 방법","description":"","date":"2024-05-17 21:05","slug":"2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png\" /\u003e\n\n## 소개\n\n리액트를 배우기 시작했다면 아마도 JSX라는 것에 대해 들어보았을 것입니다. JSX는 자바스크립트 내에서 HTML과 유사한 코드를 작성할 수 있게 해주는 구문 확장입니다. 이 독특한 기능은 리액트의 핵심 요소 중 하나로, 상호 작용하는 UI를 만들기 쉽게 해줍니다. 이 글에서는 JSX가 무엇인지, JavaScript와 HTML을 어떻게 통합하는지, 그리고 왜 유용한지 살펴보겠습니다. 또한 몇 가지 예제를 살펴보면서 JSX가 어떻게 동작하는지 알아볼 것입니다.\n\n## JSX란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX는 JavaScript XML의 약자입니다. JavaScript의 구문 확장으로, JavaScript 코드 내에서 직접적으로 HTML 태그를 작성할 수 있게 해줍니다. HTML과 비슷해 보이지만, JavaScript의 모든 기능을 갖고 있습니다. JSX를 작성하면 일반적인 JavaScript 함수 호출로 변환되어 React 요소를 생성합니다.\n\n## JSX가 JavaScript와 HTML을 통합하는 방법\n\nJSX를 사용하면 JavaScript 로직을 HTML 구조와 원활하게 통합할 수 있습니다. 이 통합은 더 직관적으로 동적 웹 애플리케이션을 구축하는 데 도움이 됩니다. 다음은 JSX의 간단한 예시입니다:\n\n```js\nconst element = \u003ch1\u003eHello, world!\u003c/h1\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 JSX 코드가 다음으로 변환됩니다:\n\n```js\nconst element = React.createElement('h1', null, 'Hello, world!');\n```\n\n## JSX 사용의 장점\n\n1. 가독성과 유지보수성: JSX를 사용하면 마크업과 로직을 한 곳에 모아 코드를 더 읽기 쉽게 만들 수 있습니다. 이는 UI 구조와 관련 로직을 함께 볼 수 있어 이해와 유지보수가 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 개발자 경험: JSX는 UI 구성 요소를 작성하는 더 직관적인 방법을 제공합니다. JSX 내에서 JavaScript의 모든 기능을 활용할 수 있으며, 반복문, 조건문 및 변수 선언을 포함할 수 있습니다.\n\n3. 강력한 추상화: JSX는 React.createElement() 호출을 추상화하여 코드를 덜 장황하고 더 선언적으로 만듭니다. 이 추상화는 더 깔끔하고 표현력이 높은 코드를 작성할 수 있도록 돕습니다.\n\n4. 도구 및 생태계: JSX는 다양한 도구와 편집기에서 지원되며, 구문 강조, 오류 확인 및 자동 완성 기능을 제공하여 개발자 경험을 향상시킵니다.\n\n## JSX 동작 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. JSX에서 표현식 삽입하기\n\nJSX 내에서는 중괄호 `''`로 둘러싸면 어떤 JavaScript 표현식이든 포함할 수 있습니다. 변수, 함수 호출 등을 포함합니다.\n\n```js\nconst name = 'John';\nconst element = \u003ch1\u003eHello, {name}!\u003c/h1\u003e;\n```\n\n이 예시에서는 `name` 변수의 값이 JSX에 동적으로 삽입됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 2. JavaScript 함수와 함께 JSX 사용하기\n\nJSX를 사용하면 JavaScript 함수를 사용하여 요소를 생성할 수 있습니다.\n\n```js\nfunction formatName(user) {\n return user.firstName + ‘ ‘ + user.lastName;\n}\n\nconst user = {\n firstName: 'John',\n lastName: 'Doe'\n};\n\nconst element = \u003ch1\u003eHello, {formatName(user)}!\u003c/h1\u003e;\n```\n\n여기서 `formatName` 함수는 JSX 내에서 호출되어 개인화된 인사말을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 3. JSX를 사용한 조건부 렌더링\n\nJSX 내에서 JavaScript의 조건부 연산자를 사용하여 요소를 조건부로 렌더링할 수 있습니다.\n\n```js\nconst isLoggedIn = true;\nconst element = (\n  \u003cdiv\u003e\n    {isLoggedIn ? \u003ch1\u003e어서 오세요!\u003c/h1\u003e : \u003ch1\u003e로그인해주세요.\u003c/h1\u003e}\n  \u003c/div\u003e\n);\n```\n\n이 예제는 `isLoggedIn` 상태에 따라 다른 요소를 렌더링하는 삼항 연산자를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 4. JSX에서 반복문\n\n`map()`과 같은 JavaScript 배열 메소드를 사용하여 요소 목록을 렌더링할 수 있습니다.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =\u003e\n \u003cli key={number}\u003e{number}\u003c/li\u003e\n);\nconst element = (\n \u003cul\u003e\n {listItems}\n \u003c/ul\u003e\n);\n```\n\n이 경우 `map()` 함수는 숫자 배열에서 `li` 요소 목록을 생성하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 5. JSX를 사용하여 컴포넌트 생성하기\n\nJSX는 일반적으로 React 컴포넌트 내에서 사용됩니다. 다음은 간단한 컴포넌트 예제입니다:\n\n```js\nfunction Welcome(props) {\n return \u003ch1\u003eHello, {props.name}\u003c/h1\u003e;\n}\nconst element = \u003cWelcome name=\"Sara\" /\u003e;\n```\n\n이 예제는 `name` prop을 받아 인사 메시지를 렌더링하는 `Welcome` 컴포넌트를 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nJSX는 JavaScript와 HTML의 장점을 결합하여 UI 구성 요소를 구축하는 직관적이고 효율적인 방법을 제공하는 React의 강력한 기능입니다. 읽기 쉬움, 사용하기 쉬움, 그리고 JavaScript와의 원활한 통합성은 개발자들 사이에서 인기를 얻고 있습니다. JSX를 활용함으로써 유지보수가 쉽고 표현력이 풍부한 코드를 작성할 수 있어 최종적으로 개발 워크플로우와 응용프로그램 품질을 향상시킬 수 있습니다.\n\n초보자든 경험 많은 개발자이든 JSX를 이해하고 활용함으로써 React 개발 환경을 크게 향상시킬 수 있습니다. 그러니 다음 React 프로젝트에서 JSX의 가능성을 탐험하고 시작해보세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingJSXTheSyntaxExtensionforReact_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 네이티브로 모달을 윕게 사용할 수 있는 Modal Manager 만들기","description":"","date":"2024-05-17 21:03","slug":"2024-05-17-ReactNativeCreateeasytouseModalManager","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png\" /\u003e\n\n안녕하세요, 개발자 여러분!\n\n오늘은 React Native에서 모달을 가장 간편하고 편리하게 사용하는 방법에 대해 알아보겠습니다! React Native에서 모달을 사용하는 전통적인 방법은 각 화면이나 컴포넌트마다 \"Modal\" 컴포넌트와 해당 props를 정의하는 것이 일반적입니다. 이는 종종 모달이 사용되는 문맥에 높은 결합도를 가지는 문제로 이어질 수 있습니다.\n\n보통 확인 또는 다른 복잡한 동작에 모달을 사용하는 각 화면에서는 useState를 사용하여 가시성 상태를 정의합니다 (전통적인 [visible, setVisible] = useState(false) 방식), 이를 통해 모달이 화면에 표시되는지 여부를 컨트롤합니다. 이 방법은 개발 속도를 크게 늦추고 유연성과 재사용성을 저하시키는 요소로 인식됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제를 해결하기 위해 간단하고 효율적인 방법으로 모달 가시성을 관리하는 방법을 고안했습니다.\n\n화면 중앙에 표시되는 모달과 화면 하단에 고정된 모달을 위한 두 가지 다른 구성을 채택했습니다.\n\n그러니, 프로젝트 구조를 설정해 보겠습니다. 먼저 프로젝트의 src 디렉토리 내에 \"modal-manager\" 폴더를 추가하는 것으로 시작하겠습니다.\n\n![모달 매니저](/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보시다시피, 프로젝트를 최적으로 관리할 수 있는 간단하고 조직적인 구조를 만드는 것이 매우 중요합니다.\n\n최종 결과물로서, 모달을 메인 파일(예: App.tsx)에 삽입한 다음 간단한 방법으로 어디서든 사용할 수 있습니다.\n\n필요한 종속성은 \"react-native-modal\"뿐입니다. 따라서 모든 것이 올바르게 작동하도록 하려면 선호하는 패키지 관리자에 따라 npm 또는 yarn을 사용하여 라이브러리를 설치해야 합니다(저는 yarn을 선호합니다).\n\n여기에서는 나중에 사용할 모달을 어디에 어떻게 정의하는지에 대한 예제가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\n  import { NavigationContainer } from '@react-navigation/native';\n  import Modal, { BaseCenterModalContainer, BaseBottomModalContainer } from \"./src/modal-manager\";\n\n  export const App = () =\u003e {\n   \n   const showCenteredModal = () =\u003e {\n     Modal.show({\n       children: (\n         \u003cBaseCenterModalContainer style={ height: 400, backgroundColor: 'white' }\u003e\n           \u003cText\u003eCenter modal\u003c/Text\u003e\n         \u003c/BaseCenterModalContainer\u003e\n       ),\n       dismissable: true,\n       position: 'center',\n     });\n   };\n  \n  \n   return (\n     \u003cNavigationContainer\u003e\n       \u003cModal /\u003e\n       {children}\n     \u003c/NavigationContainer\u003e\n   )\n  }\n```\n\n위에서 볼 수 있듯이, 모달을 사용하는 두 가지 예제가 있습니다. 간단하게 사용하기 위해 App.tsx 파일에 배치되었지만, 프로젝트의 어디에서든 \"Modal.show\" 및 \"Modal.hide\" 메소드를 사용할 수 있습니다.\n\n더불어, 모든 코드를 TypeScript로 작성하여 더 깨끗하고 재사용 가능한 코드를 구현하였습니다.\n\n두 가지 방법으로 모달을 표시할 수 있는 옵션이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1 — 화면 하단에\n\n```js\nModal.show({\n children: (\n   \u003cBaseBottomModalContainer style={ height: 400, backgroundColor: 'white' }\u003e\n     \u003cText\u003eCenter modal\u003c/Text\u003e\n    \u003c/BaseBottomModalContainer\u003e\n  ),\n  dismissable: true,\n  position: 'bottom',\n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_2.png\" /\u003e\n\n2 — 화면 중앙에 위치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nModal.show({\n    children: (\n      \u003cBaseCenterModalContainer style={ height: 400, backgroundColor: 'white' }\u003e\n        \u003cText\u003eCenter modal\u003c/Text\u003e\n      \u003c/BaseCenterModalContainer\u003e\n    ),\n    dismissable: true,\n    position: 'center',\n  });\n```\n\n![Modal Manager](/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_3.png)\n\n두 경우 모두 세 가지 주요 속성이 있습니다:\n\n- children ⇒ 모달의 콘텐츠를 나타냅니다. 예를 들어, 간단한 텍스트를 삽입했습니다.\n- dismissable ⇒ 배경을 탭하여 모달을 닫을 수 있는지 여부를 나타냅니다.\n- position ⇒ 모달의 위치를 지정합니다. 이는 중앙 또는 하단일 수 있습니다. 이 두 값 중 하나를 사용할 때는 기본적인 스타일을 쉽게 오버라이드할 수 있는 BaseCenterModalContainer 또는 BaseBottomModalContainer 컴포넌트를 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 이전 구성 요소를 사용하지 않고도 모달에 표시해야 하는 구성 요소를 간단히 전달할 수도 있습니다.\n\n자 이제 다양한 부분들을 자세히 살펴보겠습니다.\n\ntypes/index.tsx\n\n모달에 대한 모든 유용한 유형은 이 파일 내에서 정의되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { ReactNode } from 'react';\nimport { StyleProp } from 'react-native';\n\nexport type ReactChildren = ReactNode;\n\nexport type ModalData = {\n  children: ReactChildren;\n};\n\nexport type ModalOptions = {\n  dismissable: boolean;\n  animated?: boolean;\n  position: 'center' | 'bottom';\n};\n\nexport type ModalShowParams = ModalData \u0026 ModalOptions;\n\nexport type ModalHideParams = {};\n\nexport type ModalRef = {\n  show: (params: ModalShowParams) =\u003e void;\n  hide: (params?: ModalHideParams) =\u003e void;\n};\n\nexport type ModalConfig = {\n  style?: StyleProp\u003cany\u003e;\n};\n\nexport type ModalProps = {\n  config?: ModalConfig;\n};\n```\n\n컴포넌트 관련해서는 세 가지가 있습니다.\n\n이 중에서 가장 중요한 것은 모달의 기본 시각적 디자인을 캡슐화하고 있습니다. 특히 화면의 중앙이나 하단에 모달이 표시될지를 결정합니다.\n\nModalUI.tsx\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Dimensions, StyleSheet } from \"react-native\";\nimport { ModalConfig, ModalData, ModalHideParams, ModalOptions, ModalShowParams } from \"../types\";\nimport RNModal from \"react-native-modal\";\nimport { useCallback } from \"react\";\n\nexport type ModalUIProps = {\n  isVisible: boolean;\n  options: ModalOptions;\n  data: ModalData;\n  show: (params: ModalShowParams) =\u003e void;\n  hide: (params: ModalHideParams) =\u003e void;\n  config?: ModalConfig;\n  onHide: () =\u003e void;\n};\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('screen');\n\nexport const ModalUI = ({\n  isVisible,\n  data,\n  options,\n  hide,\n  onHide,\n  config,\n}: ModalUIProps) =\u003e {\n  const { children } = data;\n  const { style } = config || {};\n  const { dismissable, position, animated } = options;\n\n  const onBackdropPress = useCallback(() =\u003e {\n    if (dismissable) {\n      hide({});\n    }\n  }, []);\n\n  if (!children) {\n    return null;\n  }\n\n  return (\n    \u003cRNModal\n      {...RNModal.defaultProps}\n      isVisible={isVisible}\n      useNativeDriver\n      deviceHeight={SCREEN_HEIGHT}\n      deviceWidth={SCREEN_WIDTH}\n      style={[modalPositionStyles[position], styles.modal, style]}\n      onBackdropPress={onBackdropPress}\n      avoidKeyboard={false}\n      onModalHide={onHide}\n      backdropOpacity={0.4}\n    \u003e\n      {children}\n    \u003c/RNModal\u003e\n  );\n};\n\nconst modalPositionStyles = StyleSheet.create({\n  center: {\n    justifyContent: 'center',\n    margin: 20,\n  },\n  bottom: {\n    justifyContent: 'flex-end',\n    margin: 0,\n  },\n});\n\nconst styles = StyleSheet.create({\n  modal: {},\n});\n```\n\n이 컴포넌트는 React Native에서 모달의 시각적 측면을 관리합니다. 다음은 이 컴포넌트의 역할입니다:\n\n2. 초기 설정:\n\n- 모달의 표시 상태, 표시할 데이터, 모달 구성 옵션, 모달을 숨기는 함수 및 모달 닫기 이벤트를 처리하는 콜백 함수와 같은 props를 받습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 이벤트 처리:\n\n- 모달이 닫힐 수 있도록 설정되어 있으면 (dismissable), 모달 바깥 영역을 탭하면 모달을 숨기는 함수가 정의됩니다 (onBackdropPress).\n\n3. 모달 렌더링:\n\n- 모달의 내용은 존재하는 경우에만 조건부로 렌더링됩니다 (children). 표시할 데이터가 없는 경우에는 컴포넌트가 null을 반환합니다.\n- 모달을 생성하기 위해 react-native-modal 컴포넌트를 사용합니다.\n- 모달의 위치 (가운데 또는 아래)에 기본 스타일을 적용하고, config prop을 통해 제공된 스타일을 통해 사용자 정의를 허용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 미리 정의된 스타일:\n\n- 화면 중앙 또는 하단에 모달을 위치시키기 위해 두 세트의 스타일을 정의합니다.\n\n5. 모달 상태 관리:\n\n- 모달은 화면 크기를 상태의 일부로 수신하여 다양한 기기 크기에 적절하게 적응합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 이 컴포넌트는 리액트 네이티브에서 모달을 유연하고 구성 가능하게 표시하는 인프라를 제공하며, 애플리케이션 요구에 맞는 외관 및 동작을 사용자화할 수 있습니다.\n\nBaseBottomModalContainer.tsx\n\n이 간단한 컴포넌트는 하단 모달에서 일반적으로 사용되는 기본 스타일을 정의하는 곳입니다. 예를 들어, 둥근 테두리 등이 있습니다.\n\n```js\nimport { StyleSheet, ViewProps } from \"react-native\";\n\nexport const BaseBottomModalContainer = ({ children, style, ...props }: ViewProps) =\u003e {\n  return (\n    \u003cView style={[styles.container, style]} {...props}\u003e\n      {children}\n    \u003c/View\u003e\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    borderTopRightRadius: 20,\n    borderTopLeftRadius: 20,\n    padding: 20\n  }\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\nBaseCenterModalContainer.tsx\n\n```js\nimport { StyleSheet, View, ViewProps } from \"react-native\";\n\nexport const BaseCenterModalContainer = ({ children, style, ...props }: ViewProps) =\u003e {\n  return (\n    \u003cView style={StyleSheet.compose(styles.container, style)} {...props}\u003e\n      {children}\n    \u003c/View\u003e\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    borderRadius: 20,\n    padding: 20\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { useCallback, useState } from 'react';\nimport { ModalData, ModalOptions, ModalProps, ModalShowParams } from '../types';\nimport { mergeIfDefined } from '../utils/obj.ts';\n\nexport type UseModalParams = {\n  defaultOptions: Omit\u003cModalProps, 'config'\u003e;\n};\n\nconst DEFAULT_OPTIONS: ModalOptions = {\n  dismissable: true,\n  position: 'center',\n  animated: false\n};\n\nexport const useModal = ({ defaultOptions }: UseModalParams) =\u003e {\n  const [isVisible, setIsVisible] = useState(false);\n  const [data, setData] = useState\u003cModalData\u003e({\n    children: null,\n  });\n\n  const initialOptions = mergeIfDefined(\n    DEFAULT_OPTIONS,\n    defaultOptions,\n  ) as Required\u003cModalOptions\u003e;\n\n  const [options, setOptions] = useState\u003cModalOptions\u003e(initialOptions);\n\n  const show = useCallback(\n    (params: ModalShowParams) =\u003e {\n      setData({\n        children: params.children ?? null,\n      });\n      setOptions({\n        dismissable: params.dismissable ?? initialOptions.dismissable,\n        position: params.position ?? initialOptions.position,\n        animated: params.animated,\n      });\n      setIsVisible(true);\n    },\n    [initialOptions],\n  );\n\n  const hide = useCallback(() =\u003e {\n    setIsVisible(false);\n  }, [initialOptions]);\n\n  const onHide = useCallback(() =\u003e {\n    setData({\n      children: null,\n    });\n    setOptions(initialOptions);\n  }, [initialOptions]);\n\n  return {\n    isVisible,\n    show,\n    hide,\n    data,\n    options,\n    onHide,\n  };\n};\n```\n\n이 useModal이라는 훅은 모달을 관리하기 위해 설계되었습니다. 다음은 이 훅이 하는 일입니다:\n\n- 상태 관리: 현재 모달이 표시 중인지 여부를 나타내는 상태(isVisible) 및 모달 내부에 표시할 데이터(data)를 유지합니다.\n- 기본 옵션: 모달의 기본 옵션을 지정할 수 있으며, 모달이 닫힐 수 있는지(dismissable), 위치(position), 애니메이션 여부(animated) 등을 설정할 수 있습니다.\n- 모달 표시: show 함수를 사용하여 제공된 매개변수로 모달을 표시합니다. 제공된 매개변수에 기반하여 모달 데이터와 옵션을 업데이트하고 isVisible을 true로 설정합니다.\n- 모달 숨기기: hide 함수는 현재 표시 중인 모달을 숨기는 데 사용됩니다. isVisible를 false로 설정합니다.\n- 숨김 콜백: onHide 함수는 모달이 숨겨질 때 트리거되는 콜백입니다. 모달 데이터와 옵션을 초기 값으로 재설정합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nModal.tsx\n\n```js\nimport { forwardRef, useCallback, useImperativeHandle, useRef } from 'react';\nimport {\n  ModalHideParams,\n  ModalProps,\n  ModalRef,\n  ModalShowParams,\n} from './types';\nimport { useModal } from './hook/useModal.ts';\nimport { ModalUI } from \"./components\";\n\nconst ModalRoot = forwardRef((props: ModalProps, ref) =\u003e {\n  const { config, ...defaultOptions } = props;\n  const { show, hide, isVisible, options, onHide, data } = useModal({\n    defaultOptions,\n  });\n\n  // This must use useCallback to ensure the ref doesn't get set to null and then a new ref every render.\n  useImperativeHandle(\n    ref,\n    useCallback(\n      () =\u003e ({\n        show,\n        hide,\n      }),\n      [hide, show],\n    ),\n  );\n\n  return (\n    \u003cModalUI\n      isVisible={isVisible}\n      options={options}\n      data={data}\n      hide={hide}\n      onHide={onHide}\n      show={show}\n      config={config}\n    /\u003e\n  );\n});\n\ntype ModalRefObj = {\n  current: ModalRef | null;\n};\n\nlet refs: ModalRefObj[] = [];\n\n/**\n * Adds a ref to the end of the array, which will be used to show the toasts until its ref becomes null.\n *\n * @param newRef the new ref, which must be stable for the life of the Toast instance.\n */\nfunction addNewRef(newRef: ModalRef) {\n  refs.push({\n    current: newRef,\n  });\n}\n\n/**\n * Removes the passed-in ref from the file-level refs array using a strict equality check.\n *\n * @param oldRef the exact ref object to remove from the refs array.\n */\nfunction removeOldRef(oldRef: ModalRef | null) {\n  refs = refs.filter(r =\u003e r.current !== oldRef);\n}\n\nexport function Modal(props: ModalProps) {\n  const ModalRef = useRef\u003cModalRef | null\u003e(null);\n\n  /*\n    This must use `useCallback` to ensure the ref doesn't get set to null and then a new ref every render.\n    Failure to do so will cause whichever Toast *renders or re-renders* last to be the instance that is used,\n    rather than being the Toast that was *mounted* last.\n  */\n  const setRef = useCallback((ref: ModalRef | null) =\u003e {\n    // Since we know there's a ref, we'll update `refs` to use it.\n    if (ref) {\n      // store the ref in this toast instance to be able to remove it from the array later when the ref becomes null.\n      ModalRef.current = ref;\n      addNewRef(ref);\n    } else {\n      // remove this toast's ref, wherever it is in the array.\n      removeOldRef(ModalRef.current);\n    }\n  }, []);\n\n  return \u003cModalRoot ref={setRef} {...props} /\u003e;\n}\n\nfunction getRef() {\n  const reversePriority = [...refs].reverse();\n  const activeRef = reversePriority.find(ref =\u003e ref?.current !== null);\n  if (!activeRef) {\n    return null;\n  }\n  return activeRef.current;\n}\n\nModal.show = (params: ModalShowParams) =\u003e {\n  getRef()?.show(params);\n};\n\nModal.hide = (params?: ModalHideParams) =\u003e {\n  getRef()?.hide(params);\n};\n```\n\n이 파일은 모달 컴포넌트를 설정하여 `Modal/`을 선언한 후 필요에 따라 표시하거나 숨길 수 있게 합니다. 기능을 자세히 살펴보겠습니다:\n\n- ModalRoot 컴포넌트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 컴포넌트는 ref를 전달받을 수 있도록 forwardRef를 사용하여 정의되었습니다.\n- Modal의 상태를 관리하는 useModal 훅을 활용하여 시각적 효과, 옵션 및 데이터를 포함합니다.\n- useImperativeHandle을 사용하여 ref가 모달을 조작하는 show 및 hide와 같은 필수 기능만 노출되도록 합니다.\n\n2. 모달 컴포넌트:\n\n- 사용자가 상호작용하는 컴포넌트입니다. ModalRoot 컴포넌트를 감싸고 ref를 관리합니다.\n- setRef 함수를 사용하여 ref가 올바르게 업데이트되고 나중에 사용하기 위해 저장됩니다.\n\n3. Ref 관리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `addNewRef`은 새 모달이 생성될 때 refs 배열에 새 ref를 추가합니다.\n- `removeOldRef`는 모달이 파괴될 때 배열에서 ref를 제거합니다.\n\n4. 정적 메서드:\n\n- `Modal.show`과 `Modal.hide`는 Modal 컴포넌트에 연결된 정적 메서드입니다.\n- 이들은 활성 모달 인스턴스를 찾기 위해 refs 배열을 활용하고 해당하는 show 또는 hide 메서드를 호출합니다.\n\n이 파일은 React Native 애플리케이션에서 모달을 관리하는 논리를 캡슐화합니다. 사용자는 `Modal/` 컴포넌트 하나로 모달을 쉽게 생성하고 제어할 수 있으며, 모달을 표시하고 숨기는 정적 메서드가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기까지 왔네요! 이 모달 관리 시스템을 구현함으로써 프로세스를 보다 효율적이고 직관적으로 만들었습니다. 이 방식의 모듈성을 통해 표시 및 상호 작용 방식을 우리의 특정 요구에 쉽게 적응시킬 수 있습니다. 더 많은 통찰력과 코딩을 더 부드럽고 빠르게 만들어줄 새로운 도구를 업데이트하는 방법을 계속 따라와 주세요. 이 여정에 함께해줘서 감사합니다!\n\n즐거운 코딩하세요!\n\n소스 코드: https://github.com/davidecarizzoni/react-native-modal-manager\n\nLinkedin 프로필: https://www.linkedin.com/in/davide-carizzoni/","ogImage":{"url":"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png"},"coverImage":"/assets/img/2024-05-17-ReactNativeCreateeasytouseModalManager_0.png","tag":["Tech"],"readingTime":14},{"title":"프론트엔드 개발자를 위한 TypeScript 마스터하기","description":"","date":"2024-05-17 21:00","slug":"2024-05-17-MasteringTypeScriptinEverydayProgramming","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png\" /\u003e\n\n# 프론트엔드 개발에서의 TypeScript 🚀\n\nMicrosoft에서 개발된 TypeScript는 2012년 10월 오픈 소스로 등장한 이후로 프론트엔드 개발자들에게 필수적인 도구가 되었습니다.\n\n🌐 널리 인정받아 현재는 대규모 프로젝트에서 표준으로 사용되며, 정적 타입 시스템을 통해 코드 가독성과 유지보수성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n💪 최신 JavaScript 기능을 제공하는 TypeScript은 강력한 컴포넌트를 만들 수 있게 해주어 매 반복 업데이트마다 프론트엔드 코딩을 더욱 편안하게 만듭니다.\n\n🔄 TypeScript는 계속해서 프론트엔드 개발 환경을 향상시키며 진화를 받아들이세요.\n\n![Mastering TypeScript in Everyday Programming](/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_1.png)\n\n# TypeScript를 선택해야 하는 이유? ✨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마이크로소프트는 TypeScript를 소개할 때 두 가지 주요 목표를 가졌습니다: JavaScript를 위한 선택적 유형 시스템 제공 및 현재 및 미래의 JavaScript 기능과의 호환성 보장.\n\n🛠️ 코드 품질과 유지 관리:\n- 유형은 코드 리팩터링을 돕고 런타임이 아니고 컴파일 시간에 오류를 잡아낸다.\n- 유형은 탁월한 문서화 역할을 하며 명확한 함수 선언을 통해 코드 이해를 높인다.\n\n🔄 TypeScript의 접근 방식:\n- TypeScript는 선택적 유형을 제공하여 JavaScript를 너무 복잡하지 않게 개선하는 균형을 유지한다.\n- 이는 \"JavaScript 슈퍼셋\" 역할을 하며 컴파일 시간 유형 안전성을 제공하면서 JavaScript와 완전히 호환된다.\n\n👀 유형 추론 및 주석:\n- TypeScript는 개발 중 비용 효율적인 유형 안전성을 위해 유형을 추론한다.\n- 명시적 유형 주석은 코드 이해와 가독성을 돕는 미래 개발자를 지원할 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🚀 원활한 통합 및 이전:\n- TypeScript는 JavaScript에서 원활한 이전을 보장하며, 오류가 있더라도 호환 가능한 JavaScript로 컴파일됩니다.\n- 타입 오류는 일반적인 JavaScript 런타임을 방해하지 않습니다.\n\n🌐 TypeScript의 주요 기능:\n- 아파치 라이선스 하에 무료 및 오픈 소스입니다.\n- ECMAScript 표준을 기반으로 구축되었으며, JavaScript를 확장합니다.\n- 선택적인 정적 타입, 클래스 및 모듈을 추가합니다.\n- ECMAScript 사양을 준수하는 읽기 쉬운 JavaScript로 컴파일됩니다.\n- 모든 브라우저, 호스트 및 운영 체제에서 교차 플랫폼 지원을 제공합니다.\n- 기존 JavaScript 코드와의 완전한 통합 (ts/tsx 파일 확장자).\n- 런타임 오염 없는 컴파일 시간 검사.\n\n# TypeScript 개발 시작하기 🚀\n\n## TypeScript 종속성 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript 개발 환경을 설정하는 것은 매우 쉬운 일이에요. 특히 대부분의 프론트엔드 프로젝트에서 TypeScript를 손쉽게 통합할 수 있죠. 아래 간단한 단계를 따라 시작해보세요:\n\n1. 프론트엔드 프로젝트에 꼭 필요한 NodeJS와 npm 도구가 설치되어 있는지 확인해주세요.\n\n2. TypeScript를 설치하려면 npm 명령어를 사용하세요. 아래 명령어로 간단하게 설치할 수 있어요:\n\n```js\nnpm install --save-dev typescript ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✨ TypeScript 및 필수 런타임 ts-node를 함께 설치합니다.\n\n이러한 종속성이 설치되면 TypeScript 개발 세계로 뛰어들 준비가 됩니다! 🌐\n\nBabel 통합 설치\n\n프론트엔드 프로젝트의 동적한 세계에서 Babel은 중요한 동료입니다. TypeScript와 Babel을 결합하면 강력한 개발 환경이 구성됩니다. TypeScript 컴파일러는 정적 타입 확인을 처리하고, Babel은 TypeScript 코드를 실행 가능한 JavaScript로 변환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBabel을 TypeScript와 원활하게 통합하기 위해서는 주요 의존성 패키지 '@babel/preset-typescript'이 필요합니다. 아래 npm 명령어를 실행해주세요:\n\n```js\nnpm install -D @babel/preset-typescript\n```\n\n'Babel' 환경 설정 파일 (babel.config.js)에 '@babel/preset-typescript'를 추가해주세요. 이 프리셋은 TypeScript에서 유형과 관련된 코드 (예: 유형 주석, 인터페이스)를 제거하고 필요한 옵션을 추가하는 데 도움이 됩니다.\n\n```js\n// babel.config.js\n{\n \"presets\": [\n // …\n \"@babel/preset-typescript\"\n ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 통합을 통해 TypeScript와 Babel이 손을 맞잡고 프론트엔드 개발 경험을 높여줍니다! 🚀🔧\n\nESLint 통합 설치 방법\n\n어떤 프로젝트에서든 코드 검토는 중요한 측면입니다. TypeScript는 기본 오류 감지를 제공하지만 프로젝트와 개발팀이 성장함에 따라 일관된 코드 스타일 유지가 필수적입니다. ESLint가 등장합니다. 이는 코드 스타일을 강제하는 강력한 도구입니다.\n\nESLint를 사용하여 TypeScript 코드를 구문 분석하려면 필요한 구문 분석기와 플러그인을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin\n```\n\n참고: `@typescript-eslint/parser` 및 `@typescript-eslint/eslint-plugin` 모두 동일한 버전이어야 합니다.\n\nESLint 구성 파일 (`.eslintrc.js`)에 다음 옵션을 추가해주세요:\n\n```js\n// .eslintrc.js\n{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"plugins\": [\"@typescript-eslint\"],\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\"\n  ],\n  \"rules\": {\n    \"@typescript-eslint/no-use-before-define\": \"error\",\n    // …\n  }\n}\n```\n\n이 구성을 통해 ESLint가 TypeScript 코드를 구문 분석하도록 설정되며, 권장 규칙을 적용하거나 필요에 따라 규칙을 사용자 정의할 수 있습니다. 🧐🔍✨\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 컴파일 구성\n\nTypeScript는 명령줄 매개변수를 사용하여 파일을 컴파일할 수 있는 기능을 제공하지만, 일반적으로 `tsconfig.json`을 사용하여 프로젝트를 개발합니다. 이 파일이 프로젝트에 없다면 수동으로 만들거나 `tsc — init` 명령을 사용하여 생성할 수 있습니다. TypeScript를 처음 사용할 때는 기본 `tsconfig.json` 파일이 충분하며, 필수적인 컴파일 관련 정보가 포함되어 있습니다. 프로젝트가 성숙해질수록 각 옵션을 이해하고 사용자 정의하는 것이 필요해집니다.\n\n기본 옵션\n\n초기 단계에서는 기본 `tsconfig.json` 파일이 적절하며, 일반적으로 다음과 같은 기본 컴파일 옵션이 포함됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n \"compilerOptions\": {\n \"target\": \"es5\",\n \"module\": \"commonjs\",\n \"strict\": true,\n // …\n }\n}\n```\n\n개인 설정이 필요한 경우, `tsconfig.json` 파일의 각 항목에 대한 구체적인 이해가 중요합니다. 이러한 컴파일 옵션은 다음과 같이 해석됩니다:\n\n- target: ECMAScript 대상 버전을 지정합니다.\n- module: 코드 생성을 위한 모듈 시스템을 정의합니다.\n- strict: 엄격한 유형 검사 옵션을 강제합니다.\n\n엄격한 유형 검사 옵션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript을 구성할 때는 프로젝트의 동작을 맞춤화하기 위한 다양한 엄격한 타입 확인 옵션이 있습니다. 여기에 몇 가지 주요 옵션을 안내해드리겠습니다:\n\n- strict: 엄격한 타입 확인을 활성화합니다 (true/false).\n- allowUnreachableCode: 도달할 수 없는 코드를 허용하거나 금지합니다 (true/false).\n- allowUnusedLabels: 사용되지 않는 레이블 오류의 보고를 제어합니다 (true/false).\n- noImplicitAny: 표현식과 선언에서 암시적 'any'에 대한 오류 플래그를 설정합니다 (true/false).\n- strictNullChecks: 엄격한 null 확인을 활성화합니다 (true/false).\n- noImplicitThis: 'this' 표현식의 'any' 값을 오류로 생성합니다 (true/false).\n- alwaysStrict: 각 모듈을 엄격 모드로 확인하여 각 파일에 'use strict'를 추가합니다 (true/false).\n- noImplicitReturns: 일부 함수 분기가 값 반환을 하지 않을 때 오류를 보고합니다 (true/false).\n- noFallthroughCasesInSwitch: switch 문에서 fallthrough 오류를 보고할 지 여부를 나타냅니다.\n\n모듈 구문 구성 옵션\n\nTypeScript가 모듈을 구문 분석하는 방법을 구성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- moduleResolution: 모듈 해결 전략을 설정합니다 (기본값: 'node' 또는 'classic').\n- baseUrl: 상대적이지 않은 모듈 이름을 해결하기 위한 루트 디렉터리를 지정합니다.\n- paths: `baseUrl`에 기반하여 모듈 이름을 경로에 매핑합니다 (형식: '').\n- rootDirs: 프로젝트의 런타임 콘텐츠를 나타내는 루트 폴더를 나열합니다 (형식: []).\n- typeRoots: 유형 선언을 포함하는 파일을 지정합니다 (형식: [“./types”]).\n\n소스 맵 옵션\n\n소스 맵 설정을 세밀하게 조정하세요:\n- sourceRoot: 디버거가 소스 파일 대신 TypeScript 파일을 찾을 위치를 지정합니다.\n- mapRoot: 디버거가 생성된 파일 대신 맵 파일을 찾을 위치를 지정합니다.\n- inlineSourceMap: 단일 소스 맵 파일을 생성할지 여부를 결정합니다.\n- inlineSources: 코드 및 소스 맵을 단일 파일로 생성합니다 (`inlineSourceMap` 및 `sourceMap` 속성이 필요함).\n\n기타 옵션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가 구성 옵션을 살펴보세요:\n- experimentalDecorators: 데코레이터를 활성화하거나 비활성화합니다.\n- emitDecoratorMetadata: 데코레이터를 위한 메타데이터 지원을 제어합니다.\n\n포함 및 제외 옵션\n컴파일을 위해 파일을 지정하여 성능을 향상시키는 `include`와 `exclude`를 사용하세요:\n\n```js\n\"exclude\": [\n \"node_modules\",\n \"dist\"\n // …\n]\n```\n\n이러한 구성 옵션을 사용하여 TypeScript를 프로젝트의 요구 사항에 맞게 정교하게 조정할 수 있어요! 🔧🎛️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 유형 주석\n\n이제 TypeScript 구성을 알게 되었으니, TypeScript에서 제공하는 기본 유형을 살펴보겠습니다. 다음 비교 표는 TypeScript 유형과 그 ES6 상당품을 함께 보여줍니다:\n\n이제 TypeScript 관련 구성에 익숙해졌으니, TypeScript에서 제공하는 기본 유형에 대해 알아봅시다. 다음 비교는 TypeScript 유형과 그 ES6 상당품과의 차이점을 요약합니다:\n\n1. Numeric Type:\n— TypeScript: `number` | ES6: `number`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 텍스트 유형:\n- TypeScript: `string` | ES6: `string`\n\n3. 논리 유형:\n- TypeScript: `boolean` | ES6: `boolean`\n\n4. 순차적인 유형:\n- TypeScript: `array` | ES6: `array`\n\n5. 정렬된 유형 (튜플):\n- TypeScript: ✅ | ES6: ❌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. Enumerated Type (Enum):\n- TypeScript: ✅ | ES6: ❌\n\n7. Dynamic Type:\n- TypeScript: `any` | ES6: `any`\n\n8. Void Type:\n- TypeScript: `void` | ES6: `void`\n\n9. Null Type:\n- TypeScript: ✅ | ES6: ❌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10. 정의되지 않은 유형:\n- TypeScript: ✅ | ES6: ❌\n\n11. Never 유형:\n- TypeScript: ✅ | ES6: ❌\n\n이 간단한 형식은 TypeScript와 ES6 모두에 해당 유형이 존재하는지 (✅) 존재하지 않는지 (❌)를 나타냅니다.\n\nTypeScript의 유형 주석은 다른 언어의 유형 선언과 일치합니다. 변수 선언에는 `let`과 `const`를 사용할 수 있으며, 다음 구문을 따릅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 구문: let 또는 const 변수이름: 데이터타입 = 초기값;\n// 예시:\nlet varName: string = '안녕 타입스크립트';\n```\n\n함수 선언에 대해서는 함수 표현식을 사용하는 것이 좋습니다. 또는 화살표 함수를 사용하여 간결함을 높일 수 있습니다:\n\n```js\n// 구문: let 또는 const 함수표현식이름 = function(매개변수1: 타입, 매개변수2: 타입): 반환타입 {\n// // 코드 실행\n// // return xx;\n// }\n// 예시:\nlet sum = function(num1: number, num2: number): number {\n return num1 + num2;\n}\n```\n\n이 구조는 TypeScript의 타입 주석, 변수 선언 및 함수 표현식에 대한 논리적 개요를 제공하며, 명확성을 위해 이모지로 장식되어 있습니다. 🌟\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 특수 타입\n\nTypeScript의 기본 타입 사용은 다른 백엔드 언어와 일치합니다. 이 섹션에서는 TypeScript에만 존재하는 특수 타입을 소개하여 타입 선언을 복잡하게 만들고 세부 사항을 더합니다.\n\n`any` — \"백도어\" 🎨\n\n`any`는 TypeScript에서 독특한 위치를 차지하며 타입 시스템에서 \"백도어\" 역할을 합니다. 이것은 타입 확인을 비활성화하여 모든 타입과의 호환성을 가능케 합니다. 그러나 타입 안전성을 유지하기 위해 `any`에 대한 의존을 최소화해야 하며, 특정 문제를 해결하는 경우를 제외하고 사용해야 합니다. `any`를 사용하면 TypeScript 컴파일러에 타입 확인을 건너뛰도록 지시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n임의의 값 유형은 `Object`과 유사하지만 `Object` 유형의 변수가 다양한 값 할당을 허용하는 반면에 해당 메서드는 호출할 수 없습니다.\n\n- `void`: 함수 선언에서 반환 값이 없음을 나타냅니다.\n- `null`: 존재하지 않는 객체 값을 나타내며 일반적으로 값으로만 사용됩니다.\n- `undefined`: 선언되었지만 초기화되지 않은 변수의 값을 나타냅니다.\n\n`null`과 `undefined`는 모든 유형의 하위 유형으로, 모든 유형의 변수에 할당할 수 있습니다. `strictNullChecks` 구성을 활성화하면 `void` 및 스스로에 대한 할당이 제한됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열거형 🌌\n\nTypeScript는 열거형 유형을 지원하여 JavaScript의 표준 데이터 유형을 향상시킵니다. 열거형은 제한된 데이터 집합에 친숙한 이름을 제공하여 코드 가독성을 향상시킵니다. 선언에 `enum` 키워드를 사용하세요.\n\n```js\nenum SendType {\n SEND_NORMAL,\n SEND_BATCH,\n SEND_FRESH,\n // …\n}\n```\n\n`never` 유형 🎭\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`never` 타입은 복잡한 상황에서 사용됩니다. 예외가 발생하거나 정상적으로 종료되지 않을 수 있는 함수에서 나타납니다.\n\n🌌 튜플 타입\n\n배열과 유사하게, 튜플 유형은 서로 다른 유형의 요소를 허용합니다.\n\n```js\nlet row: [number, string, number] = [1, 'hello', 88];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터페이스 🎨\n\nTypeScript의 인터페이스는 읽기 전용 속성, 선택적 속성 및 상속과 같은 다양한 기능을 지원하는 여러 타입 선언을 결합합니다.\n\n타입 별칭 📝\n\n타입 별칭은 유니언 타입, 튜플 타입, 함수 타입, 객체 타입 및 교차 타입을 지원하는 타입 주석을 위한 별칭을 설정하는 편리한 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네임스페이스 🌐\n\n네임스페이스는 코드를 구성하여 이름 충돌을 피하는 데 도움이 됩니다. `namespace` 키워드를 사용하여 정의되며, 코드 분리와 전역 네임스페이스 혼잡을 방지합니다.\n\n```js\n// 다중 파일 네임스페이스\n// Validation.ts\nnamespace Validation {\n export interface StringValidator {\n isAcceptable(s: string): boolean;\n }\n}\n// NumberValidator.ts\nnamespace Validation { // 같은 네임스페이스\n export interface NumberValidator {\n isAcceptable(num: number): boolean;\n }\n}\n```\n\n제네릭 🧬\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 사용되는 이몽다는 서로 다른 유형과 함께 작업하는 코드를 작성할 수 있게 합니다. 클래스 멤버, 메소드 매개변수 및 함수 반환값에 유용합니다.\n\n```js\n// 일반적인 예시\nclass Queue\u003cT\u003e {\n private data: T[] = [];\n push = (item: T) =\u003e this.data.push(item);\n pop = (): T | undefined =\u003e this.data.shift();\n}\n// 숫자 유형으로 사용\nconst queue = new Queue\u003cnumber\u003e();\nqueue.push(0);\nqueue.push(1);\n// 문자열 유형으로 사용\nconst strQueue = new Queue\u003cstring\u003e();\nstrQueue.push('0');\nstrQueue.push('1');\n```\n\n타입 단언 🛡️\n\n타입 단언은 개발자가 값을 수동으로 유형으로 지정할 수 있게 해주며 컴파일러에게 어떤 유형이어야 하는지 전달하는 방법을 제공합니다. `대상 유형`, `as T`, `!` (null이 아님 타입 단언)과 같은 다양한 구문 형식은 다양한 시나리오에 맞게 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Type assertions\nlet value: any = 'hello';\nlet length: number = (value as string).length; // 'as' 문법 사용\n// 대체 문법\nlet alternativeLength: number = (\u003cstring\u003evalue).length;\n// 'as const' 또는 '!' coercion\nlet immutableValue = 'hello' as const;\n```\n\n# 📘결론\n\n👉 주요 포인트:\n\n- 🌱 적합 대상: TypeScript에 입문하는 사람들 및 준비 중인 사람들.\n- 🏗️ 범위: 실무에 기반한 기본 사용법과 기본 지식.\n- 🧠 한계: 아키텍처 설계에 대한 심화 분석은 이루어지지 않으며, 열성적인 사람들을 위한 오프라인 소통을 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n💡 TypeScript 능숙도의 장점:\n\n- 🖊️ 코드를 작성할 때 더 나은 결과물이 되는 것뿐만 아니라 더 안전한 코드를 작성할 수 있습니다.\n- 🚀 코딩 스킬을 새로운 높이로 끌어올릴 수 있습니다.\n\n👋 마지막으로: 읽어 주셔서 진심으로 감사드립니다! 더 알고 싶고 깊이 파고들고 싶다면 오프라인에서 연락해요. 이 기사가 여러분에게 풍요로운 TypeScript 여행의 시작이 되기를 기대합니다. 즐거운 코딩 되세요! 🚀👩‍💻","ogImage":{"url":"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png"},"coverImage":"/assets/img/2024-05-17-MasteringTypeScriptinEverydayProgramming_0.png","tag":["Tech"],"readingTime":11}],"page":"72","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"72"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>