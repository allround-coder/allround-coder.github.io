<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/49" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/49" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" href="/post/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS에서 PWA 우리가 지금 어디에 있는지" href="/post/2024-05-13-PWAsOniOSWhereWeAreNow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 PWA 우리가 지금 어디에 있는지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 PWA 우리가 지금 어디에 있는지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">iOS에서 PWA 우리가 지금 어디에 있는지</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" href="/post/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" href="/post/2024-05-13-Angularisnotforeveryoneandprobablynotforyou"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" href="/post/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="MERN 스택을 위한 업계 모범 사례" href="/post/2024-05-13-IndustryBestPracticesfortheMERNStack"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="MERN 스택을 위한 업계 모범 사례" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="MERN 스택을 위한 업계 모범 사례" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">MERN 스택을 위한 업계 모범 사례</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 18에서 SSRServer Side Rendering을 구현하는 방법" href="/post/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 18에서 SSRServer Side Rendering을 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 18에서 SSRServer Side Rendering을 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 18에서 SSRServer Side Rendering을 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개발자들이 가져야 할 미덕 게으름, 성급함, 오만함" href="/post/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발자들이 가져야 할 미덕 게으름, 성급함, 오만함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발자들이 가져야 할 미덕 게으름, 성급함, 오만함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">개발자들이 가져야 할 미덕 게으름, 성급함, 오만함</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기" href="/post/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai" href="/post/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai</strong><div class="PostList_meta__VCFLX"><span class="date">May 13, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"TypeScript 문제 하나로 똑똑해지는 시간을 가져보세요","description":"","date":"2024-05-13 00:18","slug":"2024-05-13-ThisTypeScriptProblemwillSharpenyourMind","content":"\n\n\n![이미지](/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png)\n\nTypeScript는 데이터를 강화하고 깨끗한 코드를 개발할 수 있게 해 주는 환상적인 도구입니다.\n\n오늘은 Mapped Types의 사용을 통해 현실적인 문제를 해결해 보겠습니다.\n\n그럼, 더 이상 미루지 말고 지금 바로 시작해 보겠습니다!\n\n\n\n## 문제\n\n여기서는 국가 코드와 통화 간의 매핑을 나타내기 위해 country-to-currency 패키지를 사용하고 있습니다. 다음과 같이 국가 코드와 통화 간의 매핑을 표현합니다:\n\n```js\nimport countryToCurrency, {\n  Currencies,\n  // 이것은 이해하기 쉬워 보이기 때문에\n  // `CountryCodes`로 이름 변경되었습니다.\n  Countries as CountryCodes,\n} from \"country-to-currency\"\n\n// 가독성을 위해 정의됨\ntype CountryToCurrency = typeof countryToCurrency\n\n// type Currencies = \"GBP\" | \"USD\" ...\n// type CountryCodes = \"GB\" | \"US\" ...\n// type CountryToCurrency = { GB: \"GBP\", US: \"USD\" ... }\n```\n\n입력 통화에 따라 특정 국가 코드를 반환하고, 동시에 유형 안전성을 유지할 수 있으면 좋을 것 같습니다.\n\n\n\n내가 무슨 말을 하는지 아래 코드를 통해 설명해보겠어:\n\n```js\ntype Result = CountryCodesFromCurrency\u003c\"GBP\"\u003e\n\n// 결과 타입: \"GB\" | \"GG\" | \"IM\" | \"JE\"\n```\n\n더 잘 이해할 수 있도록 문제를 다이어그램을 이용해 시각화해볼게:\n\n![이 타입스크립트 문제가 당신의 머리를 더 날카롭게 만들 것입니다](/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_1.png)\n\n\n\n우리는 기본적으로 통화를 해당 국가 코드로 역지도하는 작업을 하고 있어요.\n\n## 해결책\n\n이 작업을 Mapped Types를 사용하여 우아하게 처리할 수 있는 해결책이 있다는 것을 알게 되었어요.\n\n```js\n// 여기에 `Mapped Type`의 기본 예제가 있어요\n// 이것은 타입을 가져와서 모든 값을 부울 값으로 변경할 거에요.\n// 키는 그대로 유지한 채로요.\n\ntype OptionsFlags\u003cType\u003e = {\n  [Property in keyof Type]: boolean;\n};\n```\n\n\n\n화폐에서 국가 코드로의 역매핑을 달성하려면 다음과 같은 논리를 따라야 합니다:\n\n- Mapped 형식을 정의합니다.\n- CountryToCurrency 매핑에서 각 키 (국가 코드)에 대해 값을 우리의 입력 ThisCurrency와 일치하는지 확인합니다.\n- 일치하는 경우 해당 속성을 유지합니다.\n- 일치하지 않는 경우 키 유형을 never로 설정하여 이 속성을 제거합니다.\n\n그리고 이 작업을 수행하기 위한 코드는 다음과 같습니다:\n\n```js\n// 이해하지 못하면 아래에서 설명하는 코드 블록을 참조하세요.\ntype FilterMappingsFor\u003cThisCurrency extends Currencies\u003e = {\n  [CountryCode in keyof CountryToCurrency \n    as CountryToCurrency[CountryCode] extends ThisCurrency \n    ? CountryCode : never]: CountryToCurrency[CountryCode]\n}\n```\n\n\n\n- 이통화에 대한 국가 코드를 원하는 필터 매핑을 정의하였습니다.\n- 각 CountryCode 키를 반복합니다.\n- 각 CountryCode에 대해 해당하는 통화(CountryToCurrency[CountryCode])와 입력값 ThisCurrency를 비교합니다.\n- 통화가 일치하는 경우 현재 속성을 유지합니다.\n- 일치하지 않는 경우 해당 키를 never로 설정하여 현재 속성을 효과적으로 제거합니다.\n\n거의 다 왔어요!\n\n현재 FilterMappingsFor`ThisCurrency` 유형은 올바른 매핑을 반환하지만 우리는 국가 코드만 필요합니다.\n\n이제 새로운 유형 CountryCodesFromCurrency를 정의하여 필터된 매핑에서 모든 키를 추출합시다:\n\n\n\n```js\n// FilterMappingsFor 함수는 나라 코드와 통화에 대한 올바른 키-값 쌍을 반환하기 때문에,\n// 이 새로운 타입은 우리가 원하는 것만 추출할 것입니다; 나라 코드입니다.\ntype CountryCodesFromCurrency\u003cThisCurrency extends Currencies\u003e =\n  keyof FilterMappingsFor\u003cThisCurrency\u003e\n```\n\n마지막으로, 다음과 같이 새로운 타입 Result1과 Result2를 정의하여 이를 테스트할 수 있습니다:\n\n```js\ntype Result1 = CountryCodesFromCurrency\u003c\"GBP\"\u003e\ntype Result2 = CountryCodesFromCurrency\u003c\"NIO\"\u003e\n\n// 결과1: \"GB\" | \"GG\" | \"IM\" | \"JE\"\n// 결과2: \"NI\"\n```\n\n# 추천 기사\n\n\n\n\n# 제휴사\n\n- Figma 홈: 제 모든 프로젝트에서 사용하는 UI 디자인 도구입니다.\n- Figma 프로페셔널: 필요한 모든 UI 디자인 도구가 모두 이곳에 있습니다.\n- FigJam: 직관적인 다이어그램 및 브레인스토밍으로 마음을 자유롭게 펼쳐보세요.\n\n- Notion: 제 인생 전체를 조직하는 데 사용하는 도구입니다.\n- Notion AI: ChatGPT를 능가하는 AI 도구로 Notion 작업을 최적화해줍니다.\n\n# 참고문헌\n\n\n\n- TypeScript Mapped Types 문서\n- country-to-currency package","ogImage":{"url":"/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png"},"coverImage":"/assets/img/2024-05-13-ThisTypeScriptProblemwillSharpenyourMind_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 PWA 우리가 지금 어디에 있는지","description":"","date":"2024-05-13 00:17","slug":"2024-05-13-PWAsOniOSWhereWeAreNow","content":"\n\n애플이 단 하나의 앱 스토어 대안을 없애려는 노력의 혼란스러운 세부 내용\n\n![이미지](/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png)\n\niOS 17.4에서 완전히 막아버리면서 Progressive Web Apps (PWA)에 초토화를 일으킨 애플은 전 세계 개발자들을 좌절시키고 혼란스럽게 만들었습니다. 최근 PWA 지원을 개선한 후에도 그들의 이상한 방향전환 때문뿐만 아니라 애플이 우리에게 남긴 상황이 더욱 놀랍기 때문입니다.\n\n이 기사에서 그 혼란을 해소하기 위해 노력하겠습니다.\n\n\n\n## 유럽 연합에서만 해당\n\n애플이 iOS 17.4 베타 1에서 PWA를 망가뜨렸다는 소문이 퍼지자, 혼란스러운 개발자들은 문제가 있는 버전을 실행하는 iPhone 시뮬레이터의 화면 녹화를 공유하기 시작했어요. 거기에서는 여전히 PWAs가 설치되고 문제없이 돌아가고 있었죠.\n\n하지만 EU에서 실제 iPhone을 실행시키면 이러한 상황이 아니었어요.\n\n애플은 DMA 규정을 준수하기 위해 이 변경을 EU에만 제한시켰으며, 지오펜싱을 통해 이를 이룩했어요. SIM 카드를 사용자의 위치를 결정하는 데 사용하며, 소프트웨어 기반 시뮬레이터에는 SIM 카드가 없기 때문에 이 문제가 나타나지 않을 거예요. EU에서 새 iPhone을 SIM 카드 없이 실행하면 PWAs는 여전히 잘 작동하며, 오래된 iPhone의 SIM 카드를 빼서 24시간 동안 비행 모드로 둔 채로도 문제 없이 돌아갈 거라고 보고됐어요.\n\n\n\n어쨌든, 문제를 경험하려면 유럽 연합(EU) 국가에 위치한 SIM 카드가 장착된 진짜 아이폰이 필요합니다.\n\n## 설치된 PWA는 이제 책갈피와 같습니다\n\n또 다른 혼란의 요소는 iOS 17.4에서 여전히 웹 앱을 \"설치\"할 수 있다는 것입니다. 즉, 사용자의 홈 화면에 아이콘이 배치되지만 여기서 끝납니다.\n\n아이콘을 클릭하면 앱이 브라우저 크롬 없이 독립적인 PWA로 열리지 않고 일반 웹사이트처럼 열립니다. 사실, 홈 화면에 추가할 때 PWA가 아닌 웹 사이트는 어떻게 열리는지를 보여줍니다. 즉, \"설치된\" 웹 앱이 실제로 설치된 것이 아니라 홈 화면에 책갈피로 추가된 것임을 의미합니다.\n\n\n\n현재 iOS에서 PWA를 설치할 수 있는 브라우저는 모두 뒷단에서 Webkit 브라우저이므로 이것이 사실입니다.\n\nPWA가 전체 화면 독립형 앱처럼 표시되게 하는 것은 `manifest.json` 파일의 `\"display\": \"standalone\"` 속성입니다. `manifest.json` 파일이 없는 웹사이트는 홈 화면에 추가되어 아이콘을 클릭하면 다른 웹사이트처럼 브라우저에서 열립니다. 만약 `manifest.json` 파일에 `\"display\": \"standalone\"`이라는 속성이 있다면, iOS 17.4에서는 이것이 간단히 무시되고 PWA가 책갈피로 줄어듭니다.\n\nUI가 완전히 망가지는 것 외에도 중요한 기능이 비활성화됩니다.\n\n## 더 이상 푸시 알림이 없음\n\n\n\n애플은 iOS 16.4에서 약 1년 전에 푸시 알림 지원을 추가했어요. 그들의 구현 방식이 최적이 아닌 채로, 푸시 알림은 설치된 PWA에 대해서만 지원되죠.\n\n즉, 스탠드얼론 앱처럼 실행되는 설치된 PWA입니다.\n\n이제 iOS에서 \"설치된\" 웹 앱은 더 이상 스탠드얼론 앱이 아닌 웹 사이트의 즐겨찾기일 뿐이라 푸시 알림과 배지가 더 이상 지원되지 않아요.\n\n미안해요, 친구야.\n\n\n\n## 더 이상 지속적인 저장 공간이 없어요\n\n최근에 Safari에서 iOS에 지속적인 저장 공간이 추가되었지만, 그것은 독립 실행 모드로 실행되는 설치된 PWA에만 해당되므로 해당 기능은 이제 안녕히 려드렸다고 말할 수 있어요.\n\nPWA는 예전에는 7일간 상호 작용되지 않은 웹 앱에 의해 저장된 데이터가 제거된다는 Apple의 제재 정책에서 제외되었지만, 이제 iOS 17.4에서 PWA가 웹사이트 북마크로 변환됨에 따라 더이상 해당되지 않게 되었어요.\n\n이것으로 인해 PWA는 완전히 쓸모없게 되었고, 아마도 Apple이 신중히 PWA를 위해 준비한 가장 큰 낙인일 것입니다.\n\n\n\n## 보안 문제?\n\n애플은 비-Webkit 브라우저를 통해 설치된 PWA가 보안 위험이라고 주장합니다. 왜냐하면 iOS는 Webkit 보안 아키텍처를 직접 구축하여 PWA를 지원하며, 이 보안 통합은 카메라에 액세스하려는 앱이 권한 프롬프트를 표시하고 격리된 저장 공간을 제공하는 것을 처리합니다.\n\niOS에서 비-Webkit 브라우저는 이러한 보안 통합이 없기 때문에 해당 브라우저를 통해 PWA를 설치하는 것은 안전하지 않으며, 사용자의 허락 없이 PWA가 설치되는 결과를 초래할 수 있습니다.\n\n물론 이것은 엉터리입니다. 왜냐하면 애플은 (맥OS에서 수년간 보여온 것처럼) 이러한 통합을 구축할 수 있지만 하고 싶지 않기 때문에 그렇습니다. 이러한 통합을 구축하도록 강제당하지 않기 위해 기술적 연기벽을 세우고 빠져나가려고 노력하지만 (하지만 그렇게 보이지 않습니다).\n\n\n\n모든 브라우저의 중요한 핵심 기능 중 하나는 권한과 데이터를 출처별로 분리하는 것이며, 애플이 자사 앱 스토어 독점을 보호하기 위해 만들어낸 것 외에는 보안 문제가 없습니다.\n\n애플은 자사 앱 스토어에 대한 합리적이지 않게 높은 수수료와 임의의 입장 기준에서 자유로운 유일한 대안을 없애려고 하고 있습니다.\n\n그들이 그렇지 않다고 생각하게 속지 마세요.\n\n현대 웹 플랫폼의 새로운 기능, 진행형 웹 앱(PWA), 웹 컴포넌트, 그리고 평이한 영어로 설명된 컨텐츠를 주간으로 업데이트하는 제 이메일 목록 '현대 웹 주간(Morden Web Weekly)'에 가입해주세요!","ogImage":{"url":"/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png"},"coverImage":"/assets/img/2024-05-13-PWAsOniOSWhereWeAreNow_0.png","tag":["Tech"],"readingTime":3},{"title":"문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다","description":"","date":"2024-05-13 00:16","slug":"2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF","content":"\n\n만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:\n\n만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.\n\n# JavaScript는 duck-typed입니다\n\n![error](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png)\n\n\n\n자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.\n\nTypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.\n\n# TypeScript 구조적 유형 모델\n\n다음 인터페이스와 함수를 고려해보세요:\n\n\n\n```js\n인터페이스 Person {\n  firstName: string;\n  lastName: string;\n}\n\nfunction getFullName(person: Person): string {\n  return `${person.firstName} ${person.lastName}`;\n}\n```\n\n이제 다른 인터페이스를 만들어 봅시다:\n\n```js\n인터페이스 계정 {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n```\n\n만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?\n\n\n\n```js\nconst francesco: 계정 = { id: 123, email: 'borzifrancesco@gmail.com', firstName: 'Francesco', lastName: 'Borzì' };\n\nconst result = getFullName(francesco);\n```\n\n놀랍게도… 이건 오류가 발생하지 않아요!\n\ngetFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.\n\n다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).\n\n\n\n하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.\n\n## 구조적 타이핑의 결과\n\n함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 \"봉인된\" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.\n\n이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:\n\n\n\n```js\n인터페이스 GemCollection {\n  blueCount: number;\n  greenCount: number;\n  redCount: number;\n  yellowCount: number;\n  // purpleCount: number; // 나중에 구현 예정\n}\n```\n\n이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  let totalGemsCount = 0;\n\n  for (const key of Object.keys(gemCollection)) {\n    totalGemsCount += gemCollection[key];\n  }\n\n  return totalGemsCount;\n}\n```\n\n논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:```\n\n\n\n\n![Issue Screenshot](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png)\n\n이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.\n\n우리의 함수는 다음과 같이 다시 작성되어야 합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  return gemCollection.blueCount\n    + gemCollection.greenCount\n    + gemCollection.redCount\n    + gemCollection.yellowCount;\n}\n```\n\n\n\n그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.\n\n# 구조적 타이핑의 장점\n\n구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.\n\n![이미지](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png)\n\n\n\n이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.\n\n또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:\n\n```js\nimport { SuperHttpClient } from '@some-library/http-client';\n\nfunction getGemsCollection(httpClient: SuperHttpClient, userId: number): GemCollection {\n  const gemsCollection = httpClient.get(`https://game.gems.org/users/${userId}/gems`) as GemCollection | undefined;\n\n  if (gemsCollection) {\n    return gemsCollection;\n  }\n\n  return {\n    blueCount: 0,\n    greenCount: 0,\n    redCount: 0,\n    yellowCount: 0,\n  };\n}\n```\n\n예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:\n\n\n\n```js\n인터페이스 HttpClient {\n  get: (query: string) =\u003e unknown;\n}\n\nfunction getGemsCollection(httpClient: HttpClient, userId: number): GemCollection {\n  // 구현 내용은 이전과 동일합니다\n}\n```\n\n저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.\n\n또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:\n\n```js\ndescribe('getGemsCollection', () =\u003e {\n  it('지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 스텁 보석 컬렉션을 준비합니다\n    const testCollection: GemCollection = {\n      blueCount: 2,\n      greenCount: 4,\n      redCount: 1,\n      yellowCount: 7,\n    };\n    // 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다\n    const testHttpClientWithGems = {\n      get: (_url: string) =\u003e testCollection,\n    };\n\n    // getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithGems, 10)).toEqual(testCollection);\n  });\n\n  it('지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다\n    const testHttpClientWithoutGems = {\n      get: (_url: string) =\u003e undefined,\n    };\n\n    // getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithoutGems, 10)).toEqual({\n      blueCount: 0,\n      greenCount: 0,\n      redCount: 0,\n      yellowCount: 0,\n    });\n  });\n});\n```\n\n\n\n새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.\n\n팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.\n\n# 결론\n\n- 자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;\n- 이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;\n- Structural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;\n- Structural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.\n\n\n\n## 참고 사항\n\nDan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.","ogImage":{"url":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"},"coverImage":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png","tag":["Tech"],"readingTime":6},{"title":"앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다","description":"","date":"2024-05-13 00:13","slug":"2024-05-13-Angularisnotforeveryoneandprobablynotforyou","content":"\n\n![이미지](/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png)\n\n2023년, Angular 팀은 커뮤니티에서 요청한 중요한 변경 사항들을 많이 반영했고, 정말 멋진 일이죠. 하지만 항상 그랬던 것은 아니었습니다.\n\n이 이야기에서 나는 4년 동안 Angular을 사용하면서 얻은 경험에 대해 이야기하고 싶습니다.\n\n우선, Angular은 애플리케이션을 개발하는 데 처음으로 선택할 기술이 되지 않아야 한다고 생각합니다.\n\n\n\n앵귤러가 발생시키는 문제와 개발자 및 팀 빌딩에 미치는 영향을 강조하고 싶어요. 이를 식별한 문제들에 대한 해결책도 제시하려고 해요. 이미 앵귤러를 사용하거나 사용하고 싶다면 도움이 될 거예요.\n\n아쉽게도 어떤 이유로 인해 일부 팀이나 회사들은 업그레이드를 미루는 경우가 있어요. 따라서 여기서 설명한 일부 문제는 여전히 관련이 있을 수 있어요.\n\n신입 개발자라면 이 글이 유용할 것이며 여러분이 첫 개발 스택을 선택하는 데 도움이 될 걸 거예요.\n\n# 편리함의 함정\n\n\n\n앵귤러는 라이브러리가 아닌 UI 프레임워크로 알려져 있어요. 앵귤러는 프론트엔드 애플리케이션 개발에 대한 자체 포괄적인 솔루션으로 위치하고 있어요. 앱마다 \"기술의 동물원\"같은 것은 없고, 모든 것이 일관되고 단조로운데, 이에는 단점도 있어요. 앵귤러가 제공하는 편의성에 익숙해지면, 나중에 그것들을 포기하기가 더 어려워질 수 있어요.\n\n## ReactiveForms\n\n한 때, 앵귤러 팀이 제안한 접근 방식, 폼과 해당 컨트롤을 HTML 템플릿과 JS 컨트롤러로 분리하는 것은 정말 폼 개발에 편리했던 것이 증명되었어요.\n\n그 문제는 다르네요. ReactiveForms에서 제공하는 유효성 검사에 의지하는 것에 너무 익숙해져서, HTML이 입력 필드를 유효성 검사하는 데 필요한 모든 속성을 제공한다는 것을 잊어버리곤 해요 — min, max, pattern, required, read-only 등.\n\n\n\n이 문제는 무엇인가요? — Angular을 넘어서면 ReactiveForms이 독립 라이브러리로 존재하지 않는다는 것을 알게 됩니다. 폼 개발 방법을 다시 배워야 할 것입니다 — 이벤트 (제출, 변경) 및 입력 필드 속성.\n\n## 애플리케이션 빌드\n\n애플리케이션 빌드를 사용자 정의할 필요가 없습니다. 그냥 \"build\" 또는 \"serve\" 명령을 실행하여 시작하면 됩니다. 빌더의 webpack.config.js 또는 vite.config.js 구성 파일을 보지 못할 것입니다.\n\n네 말씀하세요:\n\n\n\n- 어떻게 귀하의 애플리케이션이 구성되었나요?\n- 어떤 파일이 진입 지점인가요?\n- 어떤 도구가 귀하의 애플리케이션을 빌드하나요?\n- SCSS 파일이 CSS로 변환되는 방법은 무엇인가요?\n- HRM은 어떻게 작동하나요?\n\nAngular만 사용하면 애플리케이션을 빌드하는 기술을 키우는 성장 단계를 놓치게 될 거예요. Webpack, Gulp, Rollup, Vite, Esbuild 등에 대해 알지 못할 거예요. 만약 Angular 없이 HTML과 SCSS로 간단한 웹 페이지를 만들라고 하면, 아마 할 수 없을 거예요.\n\n## HTTP 클라이언트\n\n이것은 최근 XHR2 기능을 활용하여 Observable 패턴을 사용하는 XHR을 감싸주는 편리한 래퍼입니다. 이것을 통해 다중 매개변수로 쿼리를 생성하고, 쿼리의 진행 상황을 추적하며, 단 하나의 매개변수로 응답을 원하는 데이터 유형으로 변환할 수 있습니다.\n\n\n\n하지만 앵귤러 개발자로서 다음을 말할 수 있나요?\n\n- 네이티브 메서드(fetch 또는 XHR)를 사용하여 최근 HTTP를 처리한 적이 있나요?\n- 인터셉터를 사용하지 않고 전역적으로 요청과 오류를 처리할 수 있나요?\n- switchMap을 사용하지 않고 HTTP 요청을 되돌릴 수 있는 방법을 말할 수 있나요?\n- axios나 node-fetch 라이브러리를 알고 있나요?\n\n편의성은 좋지만, 앵귤러 없이 쿼리를 작성하는 방법을 알아야 합니다. 심지어 시니어 개발자도 부트스트랩 애플리케이션을 시작하기 전에 요청을 보내는 방법을 모르거나 RxJS.Ajax의 존재를 모르는 것에 놀라곤 합니다.\n\n요청과 응답의 본질에 대한 이해가 있어야 다음과 같은 작업을 수행할 수 있습니다:\n\n\n\n## 테이블을 마크다운 형식으로 변경\n\n- 에러 처리\n- 응답 분석\n- 요청 진행 상황 추적\n- FormData와 함께 작업\n\n# Zone.js\n\nAngular의 신기함과 골칫거리. Zone.js는 모든 브라우저 이벤트를 위임하고 그 후 Angular에게 알릴 도구로 소개되었습니다. 그 목적은? — 업데이트의 \"마법\"을 제공하기 위해서:\n\n- 마우스 클릭? — 업데이트\n- 요청 종료? — 업데이트\n- setTimeout 종료? — 업데이트\n\n\n\n전체 애플리케이션이 어떻게 업데이트되는지에 대해 생각해 본 적이 없죠. 그러나 이 프로세스를 이해하지 못하면 미래의 최적화에 큰 문제가 될 수 있습니다.\n\n루트 및 자식 존, 기본 및 OnPush, runOutsideAngular, ComponentsTree, ViewTree, Async-pipe 등 다양한 생각할 수 없는 주제와 라이브러리 변경 감지에 대한 글들이 많이 쓰였습니다.\n\n이 글들은 \"용기를 잡는 법\"을 이해하기 위해 필요한 것뿐입니다. 네, ChangeDetectorRef나 NoopZone를 통해 컴포넌트 및 애플리케이션 업데이트를 간접적으로 관리할 수 있지만, 이것은 편리함이 아니라 유지 관리 과제입니다.\n\n\n\n# 앵귤러는 RxJS를 제공했지만 어떻게 사용해야 하는지 알려주진 않았어요\n\n앵귤러에서 RxJS에 관한 가장 빈발한 주제는 무엇일까요? - 구독 관리와 메모리 누수입니다. 그리고 이게 아무 이유 없는 얘기가 아니에요.\n\n앵귤러에서 개발을 시작하는 개발자들은 Observable을 Promise처럼 then()으로 처리하려고 해요. 많은 멋진 코드와 좋지 않은 구현을 봤어요. RxJS에 대한 지식이 없으면 앵귤러에서 효과적으로 작업할 수 없기 때문에 강좌와 자료를 만드는 이유를 이해해요.\n\n일반적으로 알려진 앵귤러는 반응적인 접근이 아니라 스트림 접근에 관한 것이에요. 모든 값들은 '스트림'이에요. 스트림으로 생각하고 스트림과 어떻게 작업할지 알지 못한다면 어려움을 겪을 거에요.\n\n\n\n2024년에도 이런 주제들이 면접에서 확인됩니다:\n\n- 고차 연산자 — concatMap, mergeMap, switchMap, exhaustMap\n- 결합 연산자 — zip, forkJoin, combineLatest\n- 메모리 누수 모니터링\n- \"Hot\"과 \"cold\" Observables\n- takeUntil, takeWhile, takeUntilDestroyed(new)\n\n## RxJS의 사로잡힌 자\n\nAngular에서 스트림과 함수형 프로그래밍으로 마음가짐을 전환했다 하더라도, 모든 값이 스트림이 될 수 있는 것은 아니라는 점을 주의하세요.\n\n\n\n문제가 무엇인가요? — 기본형과 객체를 다루는 법을 까먹었나요? 이제는 필요하지 않은 값이 스트림에 있습니다. BehaviorSubject를 통해 모든 클래스 필드를 생성하려는 충동이 생길 것입니다. 이것은 큰 문제입니다. 이로 인해 여러 조합과 내부 구독을 가진 각 필드에 대해 10개 이상의 BehaviorSubject가 있는 상태 서비스의 많은 구현을 볼 수도 있습니다.\n\n# DI\n\n많은 개발자가 Angular를 선택하게 만드는 기능입니다. 하지만 스스로 발목을 쏘지 않는 방법을 알아야 합니다.\n\n## ProvidedIn과 사용하지 않는 코드\n\n\n\n@Injectable 데코레이터에서의 ProvidedIn 함수는 Angular에 서비스를 등록해야 하는 위치를 알려주는 용도로 만들어졌어요. 이를 통해 초기 스크립트의 크기를 최적화할 수 있었고, 필요하다면 사용되지 않는 서비스를 빌드에서 제거할 수도 있었죠. 이 접근 방식은 라이브러리 개발에 사용할 수 있어요. 여러분이 만든 라이브러리에서 다른 개발자가 얼마나 많은 서비스를 사용할지 모르는 경우에 유용해요.\n\n하지만 이 방식은 단일 앱을 갖는 통합형 저장소에는 적합하지 않아요. Angular가 불필요한 코드를 제거해주는 것은 좋지만, 코드베이스를 최신 상태로 유지하는 책임을 Angular에게 넘기게 된다는 문제가 있어요.\n\n## 제공의 마법\n\nProvidedIn은 모든 서비스를 자동으로 등록해주는데, 이 부분은 편리한 면이 있어요. 하지만 providedIn: root를 사용할 때 문제가 발생하기 시작해요.\n\n\n\n개발자들은 트리 쉐이킹 메커니즘에 매우 의지하고 있습니다. 이에 따라 응용 프로그램의 일부분에서만 사용되는 서비스도 리포지토리의 가장 깊은 곳에서 전역으로 등록합니다. 이렇게 하면 전역적인 요소를 만들어 리포지토리 구조를 파괴하게 된다는 점을 명심해주세요.\n\n## 서비스의 트리 쉐이킹은 코드의 트리 쉐이킹과 같습니다\n\n많은 사람들이 서비스의 트리 쉐이킹이 코드 전체에 적용되는 것으로 잘못 알고 있지만, 실상은 그렇지 않습니다.\n\nProvidedIn은 프로바이더 트리의 생성 및 그 안에 포함될 서비스의 수에만 영향을 줍니다. 최대로 절약할 수 있는 용량은 전체 빌드 중 10-15 kb로 매우 작은 값입니다.\n\n\n\n# 항상 현재 프론트엔드 기능의 뒤쳐지게 될 거에요\n\nAngular은 '프론트엔드 세계'에서 애플 제품으로 생각해야 합니다. 다른 브랜드들이 몇 달에 한 번씩 새로운 기능을 결합하고 개발하는 동안, 애플은 새로운 기능을 서둘러 추가하지 않고 제품을 연마다 조금씩 개선하는 것을 선호해요.\n\nAngular의 종속성이 닫힌 생태계를 가지고 있어, 어떤 종속성을 새로운 것으로 교체하는 것이 어려울 수 있어요. 중요한 것은 Angular 버전을 최신으로 유지해야 한다는 점이에요. 예를 들어, Angular 9에서 Typescript 5나 Webpack 5를 사용할 수 없어요 — 올바른 버전으로 업그레이드해 주세요. 업그레이드를 실패하거나 미룰 경우, 모든 기능이 그대로 지나가게 될 거에요.\n\nAngular 팀이 기대하는 기능이나 도구 지원을 추가하지 않기로 결정하면, 그대로 사용해야 할 수 있습니다. 영원히 무엇을 가지고 작업해야 할지도 모를 거에요.\n\n\n\n# 더 많은 사람 — 더 많은 아이디어 — 더 많은 해결책\n\nAngular는 현재 앱 개발을 위한 세 가지 가장 인기 있는 기술 중 하나입니다.\n\n만약 React나 Vue로 어플리케이션의 복제본을 구현하려고 한다면, 이 어플리케이션의 모든 종속성이 Angular에서는 대응하는 것이 없다는 것이 드러날 것입니다. 그것들은 존재하지 않거나 js 라이브러리에 대한 Ng-wrapper가 없거나 그런 래퍼가 있더라도 다른 기능을 가지고 있을 수 있습니다.\n\nReact나 Vue보다 커뮤니티가 작아서 이러한 도구들을 만들지 않았기 때문에 자체 솔루션을 구현하는 데 시간이 걸릴 것입니다.\n\n\n\n# 개발자 편의가 비즈니스보다 앞섭니다.\n\n인기 있는 도구와 Angular을 비교하는 모든 글과 토론은 내부 구현에 대해 이야기하지만 한 가지를 잊고 있습니다 — 성능, SEO, 빌드 크기 및 그 결과를 달성하는 데 소요된 시간이 동일할 때만 도구를 비교해야 한다는 것을 잊습니다.\n\n우선, 당신은 제품을 개발하는 대신 돈을 지급하는 비즈니스를 위해 일하고 있습니다. 최종 사용자는 제품을 누가 만들었는지, 몇 명이 만들었는지, 어떤 기술로 만들어졌는지는 모릅니다. 그가 중요하게 생각하는 것은 응답성이 뛰어나고 예상대로 작동하는 빠른 사이트입니다.\n\n\"모든 것을 갖췄다\"는 마인드셋으로 Angular을 선택하면 초기 개발 단계에 빠르게 진입할 수 있을 뿐입니다. 당신은 의도적으로 개발 옵션을 좁혀 선택해야 할 것이며 이제 Angular이 제공할 수 있는 것에 의존해야 합니다. 2018년이 아니라는 것을 명심하세요. 숙련된 개발자는 1~2시간 만에 프로젝트를 처음부터 만들 수 있고 미래 제품의 요구사항을 반영하는 도구 스택을 선택할 수 있습니다. 무언가 변경되면 어떤 부분이든 더 나은 것으로 대체할 수 있습니다.\n\n\n\n프론트엔드 개발자이시군요! 먼저 표 태그를 마크다운 형식으로 변경해주세요.\n\n그리고 Angular를 선택한다면, 도구의 인기와 개발자 수는 직접적으로 연관되어 있기 때문에 새로운 인재를 찾는 것이 더 어려워질 수 있다는 것을 염두에 두는 것이 좋습니다. 비즈니스 전략이 신속한 성장을 포함한다면, 후보자를 찾을 가능성을 높일 수 있는 보다 인기있는 도구를 살펴보세요.\n\n# Angular는 필요 없는 것을 사용하라고 제안합니다\n\n## Protractor\n\n이게 무엇인지 모른다면 괜찮아요. 이것은 최근까지 Angular 작업 공간을 생성할 때 설치되었던 e2e 테스트 도구입니다.\n\n\n\n이 솔루션을 사용한 개발자가 매우 적다는 것을 쉽게 짐작할 수 있습니다. 또한, 이 도구에 대한 문서, 안내서, 지침도 거의 찾아볼 수 없을 것입니다.\n\n일반적으로 저장소에 e2e 테스트가 필요하면 익숙한 Cypress나 Puppeteer 도구로 마이그레이션하는 방법을 찾았습니다.\n\n## Karma + jasmine\n\nAngular 패키지에서 기본적으로 제공되는 또 다른 도구입니다. Protractor와 달리 사용이 중단되지 않았으며 개발자들 사이에서 인기가 있습니다.\n\n\n\nJest는 종종 이 조합과 대조됩니다. 테스트 작성에는 특별한 차이가 없지만 구성 방식과 일반적인 작업 방식이 다를 수 있습니다.\n\nKarma + Jasmine을 사용하기 전에 몇 가지 질문에 답해 보세요:\n\n- Jest를 알고 대체 도구로 전환할 준비가 되었나요?\n- 테스트를 실행하기 위해 브라우저 기반 환경이 실제로 필요한가요?\n- Karma와 생태계를 사용자 정의할 준비가 되었나요?\n- CI/CD에서는 에이전트에 브라우저를 설치하여 Karma에서 테스트를 실행해야 한다는 것을 알고 계셨나요?\n\n## Angular Material\n\n\n\n기본적으로 내장된 종속성은 아니지만, 이 라이브러리를 우회할 수 없는 것은 정말 어렵습니다.\n\n개발자들과 팀들이 다른 UI 라이브러리 대신 Angular Material을 선택하는 주된 이유 중 하나는 공식 Angular 팀의 지원입니다. 다른 UI 라이브러리는 새로운 Angular 버전이 출시되길 기다리고 업데이트를 기다리지만, Angular Material은 거의 Angular과 동시에 출시됩니다. 이 시점에서는 Angular Material을 지지하는 어떤 주장도 없어지죠.\n\n익숙해지기까지 다소 복잡한 개발용 도구입니다:\n- 스타일링. 컴포넌트 스타일링을 추천하는 방식을 따르지 않으면 이 라이브러리와 별개의 문제가 됩니다. Angular Material은 css 선택자를 변경하거나 요소의 중첩 순서를 일방적으로 변경할 수 있으므로 이에 대비해야 합니다.\n- Angular 업그레이드. Angular Material 번들의 경우, Angular의 새 버전으로 처음 업그레이드하는 것은 불가능할 수 있습니다. 빌드를 가지고 있더라도 인터페이스가 원래 렌더링을 유지할 것이라는 보장은 없습니다. 그에 따라 회귀 또는 QA가 필요합니다. 이에 대한 리소스가 없는 경우, 모든 것을 개인적으로 직접 확인해야 할 준비가 필요합니다.\n- 컴포넌트의 사용자 정의 감소. Taiga-UI와 같은 다른 라이브러리는 각 엔티티를 사용자 정의할 수 있는 도구와 방법의 많은 목록을 제공하는 반면, 여기서는 컴포넌트를 처음부터 구현하거나 ViewChild를 사용하여 컴포넌트를 필요에 맞게 관리해야 할 것입니다.\n\n\n\n# Angular Universal\n\n저에게 있어서 Angular의 SSR을 사용하는 것은 컴포넌트 렌더링 버그를 고치는 게으른 방법입니다 (잊혀진 trackBy, ChangeDetection.Default, Critical CSS 등) 그리고 초기 빌드 크기도 통제하는 방법이에요.\n\nAngular Hydration이 추가되기 전인 16 버전 이전에는 Angular의 SSR 사용을 무의미하게 생각할 수 있어요.\n\n먼저 Angular은 대규모 기업 애플리케이션을 위한 도구에요. 랜딩 페이지, 포트폴리오 페이지 또는 다른 \"가벼운\" 앱을 만들 때 선택하는 것이 아니에요. Angular를 선택했다면, 최적의 SEO나 FCP를 가진 애플리케이션을 만드는 관점에서 출발하기 어렵겠네요. 이미 알고 있듯이 최종 Angular 빌드는 다른 라이브러리보다 크게 될 거라고 가정하고 시작하는 거죠.\n\n\n\n## SSR이 필요해질 때 언제든지 라인\n\n의외로도 당신의 Angular 애플리케이션이 SSR을 가지고 있지 않더라도 SSR을 위해 개발해야 합니다. 전역 API인 window를 포함하여 서버 환경에는 존재하지 않는 것들을 토큰화해야 합니다. 이 접근 방법에는 문제가 없지만, 이 사실을 알고 서로 지키는 Angular 개발자가 얼마나 되겠습니까?\n\n브라우저에서만 작동하는 기능이나 도구를 사용하는 경우, SSR을 추가하여 즉시 애플리케이션을 실행할 수 없게 됩니다. 현재 애플리케이션을 위해 SSR을 지원하는 과정에서 시간과 리소스를 낭비하게 되며, 여러 버그를 만들 수도 있습니다.\n\n## 유연성 제로\n\n\n\n이제 가장 최근에 소개된 Angular Hydration을 가지고 있지만, Qwik와 Resumability에 대해 배웠습니다. 이 지식을 활용하여 Angular 내에서 재현할 수 있을까요? — 아닙니다. 여러분의 경험을 모두 갖고 있더라도, Angular 팀이 Angular Universal에 대한 지원을 추가하기를 결정할 때까지 사용할 수 없습니다.\n\n# 결론\n\n각 개발자는 다른 개발자가 만든 다른 기술을 사용하는 소비자입니다. 가장 중요한 것은 자신이 편안한 느낌을 가질 수 있는 장소를 찾는 것입니다.\n\n첫 번째 스택을 형성할 수 있는 방향을 찾는 초보 프론트엔드 개발자라면, Angular를 포기하는 것이 더 나을 수 있습니다. 네이티브 JS 및 HTML 기능에 기반을 둔 React, Vue, Svelte 또는 기타 가벼운 UI 라이브러리를 선택하는 것이 더 낫습니다. 엄격히 규제된 종속성이 없기 때문에 특정 작업에 어떤 도구를 적용할지 스스로 결정할 수 있습니다. 이를 통해 할당된 작업의 범위 내에서 \"도구 평가\" 및 \"도구에 대한 요구 사항 형성\" 기술을 발전시킬 수 있습니다.\n\n\n\n\"React를 \"기술의 동물원\"이라고 말하기는 어렵습니다. 이미 React 주변에는 각각의 작업 유형에 대해 2~3개의 추천 도구가 형성되어 있습니다. 프로젝트마다 그들의 조합을 변경할 수 있지만, 응용 프로그램을 구축하는 아주 기본적인 방식은 변하지 않습니다. 또한 Angular와 마찬가지로 프로젝트 구조에 빨리 익숙해질 것입니다.\n\n합리적인 질문. \"Angular가 필요한가요\"? — 놀랍게도, 네요.\n\nSPA를 위해 과거에 Angular가 제공할 수 있던 것은 아직까지 아무도 반복할 수 없었습니다.\n\n다른 도구들보다 뒤처지고 여러 해 동안 문제를 겪음에도 불구하고, 개발자들은 강력한 솔루션을 즉시 가져오기 위해 Angular를 선택했습니다. 언제나 프로젝트에서 알고 있는 기술과 함께 작업을 해왔고, 이는 학습에 리소스를 낭비하지 않고 교차 기능 팀을 구축하는 데 도움이 되었습니다.\"\n\n\n\n만약 Angular 이전에 RxJS를 사용해 보았다면, 이것은 좋은 전이 보너스가 될 것입니다. 만든 모든 애플리케이션에 RxJS를 추가할 수 없었던 이유는 팀의 승인과 사용 사유를 정당화해야 했기 때문입니다. Angular는 RxJS의 사용을 권장하며 개발을 쉽게 만들기 위한 자체 연산자를 제공합니다.\n\nAngular로 전환하기 전에 재사용 가능한 솔루션을 개발하면서 오류 및 기술을 경험해보는 것이 좋습니다. 사용성을 느끼기 위해 Angular로 이주하기 전에 몇 가지 경험이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"},"coverImage":"/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png","tag":["Tech"],"readingTime":10},{"title":"TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험","description":"","date":"2024-05-13 00:10","slug":"2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper","content":"\n\n![My experience learning Rust as a TypeScript developer](/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png)\n\n많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.\n\n저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.\n\n저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...\n\n\n\n# 왜 Rust를 선택해야 할까요?\n\n저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.\n\nRust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.\n\nRust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.\n\n\n\n# 러스트 배우는 방법\n\n다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.\n\n다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.\n\n러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.\n\n\n\n유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.\n\n본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.\n\n# 컴파일러\n\nRust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!\n\n\n\nTypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.\n\n이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).\n\n그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.\n\n오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!\n\n\n\n# 유형 시스템\n\n모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.\n\n그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.\n\n그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 \u0026str과 String으로 충분히 커버돼 있어요!)\n\n\n\n물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.\n\n## 메모리 할당\n\nTypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.\n\nRust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.\n\n\n\n예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.\n\n```rust\nlet small_int = \"127\".parse::\u003ci8\u003e().unwrap();\n```\n\nparse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:\n\n```rust\nlet small_int: i8 = \"127\".parse().unwrap();\n```\n\n\n\n이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 \"128\"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.\n\n타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.\n\n```js\nconst x = 10 as unknown as string;\n```\n\n이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!\n\n\n\n그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.\n\n# 오류 처리\n\n다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.\n\n```js\nlet parsed_int = submitted_str.parse::\u003ci32\u003e().unwrap();\n```\n\n\n\n여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.\n\n우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e panic!(\n        \"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}\",\n        error\n    ),\n};\n```\n\n또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:\n\n\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e 0,\n};\n```\n\n이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .\n\n물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.\n\n또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.\n\n\n\n# 선택적 값\n\nRust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.\n\n```js\ninterface User {\n  _id: string;\n  name?: string;\n}\n\nfunction sayHello(user: User) {\n  return `Hello ${user.name}!`;\n}\n```\n\n이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!\n\n\n\n하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n    let name = user.name;\n    format!(\"Hello {name}!\")\n}\n```\n\n위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n  let name: String = match user.name {\n    Some(name) =\u003e name,\n    None =\u003e \"world\".to_string(),\n  };\n\n  format!(\"Hello {name}!\")\n}\n```\n\n\n\n한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 \"Hello undefined\"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.\n\n이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.\n\n# 소유권과 대여\n\n마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.\n\n\n\nTypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.\n\n```js\nconst arrayToBeMutated: string[] = [\"d\", \"c\", \"b\", \"a\"];\nconst arrayToBeCloned: string[] = [\"d\", \"c\", \"b\", \"a\"];\n\narrayToBeMutated.sort();\narrayToBeCloned.toSorted();\n\nconsole.log(arrayToBeMutated);  // [\"a\", \"b\", \"c\", \"d\"]\nconsole.log(arrayToBeCloned);   // [\"d\", \"c\", \"b\", \"a\"]\n```\n\n위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.\n\n일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.\n\n\n\n하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.\n\n먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.\n\n다음 코드는 오류를 발생시킵니다:\n\n```js\nlet foo = 10;\nfoo += 10;\n```\n\n\n\n이 코드는 다음을 수행하지 않습니다:\n\n```js\nlet mut foo = 10;\nfoo += 10;\n```\n\n이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.\n\n예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:\n\n\n\n```js\nlet mut nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nnums.push(6);\n```\n\n러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:\n\n```js\nlet nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nlet doubles: Vec\u003ci32\u003e = nums.into_iter().map(|n| n * 2).collect();\n\ndbg!(nums);     // 이 코드는 오류를 발생시킵니다.\ndbg!(doubles);\n```\n\n위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 \"소비형 반복자(consuming iterator)\"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.```\n\n\n\nnums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.\n간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.\n\n```js\nfn main() {\n    let str = String::from(\"Hello world!\");\n    let len = calculate_length(str);\n    dbg!(str); // 오류 발생\n}\n\nfn calculate_length(s: String) -\u003e usize {\n    s.len()\n}\n```\n\n여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 \u0026를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:\n\n\n\n```rust\nfn main() {\n    let str = String::from(\"hello\");\n    let len = calculate_length(\u0026str);\n    dbg!(str, len);\n}\n\nfn calculate_length(s: \u0026String) -\u003e usize {\n    s.len()\n}\n```\n\n또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!\n\n내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.\n\nRust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!\n","ogImage":{"url":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"},"coverImage":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png","tag":["Tech"],"readingTime":11},{"title":"MERN 스택을 위한 업계 모범 사례","description":"","date":"2024-05-13 00:09","slug":"2024-05-13-IndustryBestPracticesfortheMERNStack","content":"\n\n## MERN 스택(MongoDB, Express.js, React, 그리고 Node.js)은 강력한 웹 앱을 구축하는 데 인기 있는 도구입니다! 웹 개발 세계는 계속 변화하지만, 이 스택은 여전히 많은 사람들에게 사랑받고 있어요.\n\n전문가들의 통찰력을 얻기 위해, 설명서만 의지하는 것보다는 MERN 스택 작업에 직접 경험이 있는 분과 이야기를 해보는 게 어떨까 생각했어요. 그래서 이런 생각을 했더니, Diliru Nagahawaththa씨와의 인터뷰 기회가 찾아왔답니다. 그는 경험 많은 소프트웨어 엔지니어로서 MERN 스택에 대한 업계 Best Practices에 대해 이야기 나누어 주셨습니다. 함께 알아보도록 할까요?\n\n\n\n# 전문가 소개: 딜리루 나가하와타\n\n나가하와타 씨는 스리랑카 정보기술 연구소 출신으로, 현재 클라우드 솔루션 인터내셔널에서 소프트웨어 엔지니어로 일하고 있습니다. \n\n딜리루 씨는 대학 시절과 프리랜서 활동을 통해 MERN 스택을 다루는 데 풍부한 경험을 가지고 있습니다. \n\n# 저와 딜리루가 가진 대화 중 중요한 부분들을 살펴보겠습니다.\n\n\n\n## 1. MERN 스택을 선택한 이유는?\n\n기술적인 측면과 최선의 방법에 접근하기 전에 Diliru에게 MERN 스택을 사용하는 이유 및 개발자들에게 널리 받아들여지는 이유를 물었습니다.\n\n## 2. 아키텍쳐\n\nMERN 아키텍처는 JavaScript와 JSON을 사용하여 프론트 엔드, 백 엔드, 데이터베이스의 세 가지 레벨 구조를 간단하게 만들 수 있습니다.\n\n\n\n![MERN](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png)\n\n## 3. MERN과 함께 작업하기\n\nReact의 구성 요소 기반 아키텍처는 모듈식이고 재사용 가능한 코드를 가능하게 하여 효율성과 유지 보수성을 향상시킵니다. 백엔드에서 Express.js는 서버 측 로직을 단순화하여 경로와 미들웨어를 처리하기 쉽게 만듭니다.\n\nMERN의 주목할 만한 장점 중 하나는 클라이언트 및 서버 측에서 JavaScript를 통합적으로 사용한다는 것입니다. 이는 학습 곡선을 줄일뿐만 아니라 응용 프로그램의 다른 계층 간에보다 원활한 흐름을 용이하게 합니다. 데이터 처리에서 JSON의 강점은 이러한 일관성을 더욱 향상시킵니다.\n\n\n\n게다가, MongoDB의 유연성은 NoSQL 데이터베이스로서 스택에 매끄럽게 적응되며, 동적이고 발전하는 데이터 구조를 수용합니다. 이는 확장 가능한 애플리케이션을 위한 견고한 기반을 제공합니다.\n\n## 4. 도구 및 기술\n\n여러분도 알다시피, VS Code는 JavaScript 기반 개발에 널리 사용되는 인기 있는 IDE로, 코딩 경험을 향상시키기 위한 다양한 플러그인과 확장 기능을 제공합니다. Diliru와의 대화 중 그는 자신의 관점을 공유했어요\n\n![이미지](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_1.png)\n\n\n\n- 버전 관리: Diliru는 Git을 사용한 버전 관리가 중요하다고 말합니다. 변경 사항을 추적하는 것이 매우 중요합니다. 새로운 기능을 위한 별도의 브랜치를 만들어 깔끔하고 조직적으로 유지하는 것을 권장합니다.\n\n![MERN 스택을 위한 업계 모베스트 프랙티스](/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_2.png)\n\n- 코드 품질: 그는 깨끗한 코드 작성이 중요하다고 생각합니다. ESLint 및 Prettier와 같은 도구를 사용하면 코드를 일관성 있게 작성하고 이해하기 쉽게 만들 수 있습니다. 모두가 동의하는 같은 스타일 가이드를 따르는 것과 같습니다.\n\n## 5. 모베스트 프랙티스\n\n\n\n- 데이터베이스 디자인: Nagahawaththa씨는 신중한 데이터베이스 디자인의 중요성을 강조합니다. MongoDB의 유연성을 활용하여, 응용 프로그램의 데이터 액세스 패턴과 스키마를 조율하는 것을 제안합니다.\n- 오류 처리: 견고한 오류 처리 메커니즘은 필수적입니다. Diliru는 서버 측과 클라이언트 측 오류 처리를 모두 구현하여 사용자 경험을 향상시키고 디버깅을 간소화할 것을 권장합니다.\n- 코드 모듈화: 모듈식 코드 구조를 유지하는 것은 확장성과 유지 관리성에 매우 중요합니다. Nagahawaththa씨는 코드를 작은 재사용 가능한 구성 요소로 분해하는 중요성을 강조합니다. 이 접근 방식은 개발자들 간의 협력을 강화하고 코드 테스트를 용이하게하며 미래의 업데이트나 수정을 간소화합니다.\n- 성능 최적화: 효율적인 성능은 모든 웹 응용 프로그램의 핵심 요소입니다. Diliru는 개발 프로세스 초기에 성능 최적화 전략을 통합하는 것을 권장합니다. 이는 데이터베이스 쿼리의 최적화, 서버 측 캐싱을 활용하고 클라이언트 측 렌더링 최적화를 위한 React 최상의 실천 방법을 채택하는 것을 포함합니다. 성능에 대한 선제적인 조치는 더 부드럽고 반응성 있는 애플리케이션으로 이어질 수 있습니다.\n- 보안 조치: 보안은 웹 개발에서 매우 중요합니다. Nagahawaththa씨는 잠재적인 취약점에 대비하기 위해 강력한 보안 조치를 시행하는 것을 강조합니다. 이는 사용자 입력을 유효성 검사하고 API 엔드포인트를 보안하며 최신 보안 관행에 대해 알아가는 것을 포함합니다. Diliru는 HTTPS와 같은 산업 표준 보안 프로토콜을 채택하여 데이터 무결성과 사용자 개인 정보 보호를 보장하는 것을 제안합니다.\n\n잘, 친구들, 이 훌륭한 엔지니어 Diliru Nagahawaththa와 함께 한 이 흥미로운 여정이 여기서 마무리됩니다. 그와 나눈 대화에서 많은 것을 배웠고, 그것을 여러분과 나누고 싶었기 때문에 여기 공유하게 되었습니다. 여러분도 가치 있는 인사이트를 얻으셨으면 좋겠어요. ☕💻\n\n제 SNS 계정:\n\n- GitHub\n- LinkedIn\n- Twitter","ogImage":{"url":"/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png"},"coverImage":"/assets/img/2024-05-13-IndustryBestPracticesfortheMERNStack_0.png","tag":["Tech"],"readingTime":3},{"title":"React 18에서 SSRServer Side Rendering을 구현하는 방법","description":"","date":"2024-05-13 00:08","slug":"2024-05-13-HowtoImplementSSRServerSideRenderinginReact18","content":"\n\n\"renderToPipeableStream\" 서버 API를 구현하는 방법을 배우세요. 이 API를 사용하면 React 트리를 HTML로 Node.js 스트림에 렌더링할 수 있습니다.\n\n![이미지](/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png)\n\nReact 18은 상호작용적 사용자 인터페이스를 구축하기 위한 인기있는 JavaScript 라이브러리의 최신 버전이며, 많은 새로운 기능과 개선 사항을 제공합니다. 특히 서버 측 렌더링(SSR)의 향상된 성능은 주목할 만한 기능입니다.\n\n이 글에서는 React의 SSR 기능을 유용한 코드 샘플과 예시와 함께 살펴보겠습니다. 하지만 먼저 클라이언트 측 렌더링과 서버 측 렌더링의 차이를 알아보겠습니다.\n\n\n\n클라이언트 측 렌더링 (CSR)은 웹 페이지를 클라이언트 측에서 렌더링하는 프로세스를 말합니다 (즉, 사용자의 웹 브라우저에서). 서버는 단순히 원시 데이터나 콘텐츠를 제공하며, 클라이언트 측 JavaScript가 이를 활용하여 최종 렌더링된 페이지를 동적으로 구성합니다.\n\n서버 측 렌더링 (SSR)은 서버에서 웹 페이지를 렌더링한 후 해당 페이지를 클라이언트의 웹 브라우저로 보내는 프로세스를 의미합니다. 클라이언트 측에 의존하는 대신 서버가 웹 페이지의 최종 HTML 마크업을 생성하고 이를 클라이언트로 보내는 방식을 사용합니다.\n\n# \"renderToPipeableStream\" 서버 API 구현하기\n\n단계 1: create-react-app 명령줄 도구를 사용하여 새로운 React 애플리케이션을 만듭니다. 즐겨 사용하는 터미널을 열고 아래 명령어를 입력하세요.\n\n\n\n```js\nnpx create-react-app server-api-demo-app\n```\n\n단계 2: 새로 생성된 React 앱으로 이동합니다.\n\n```js\ncd server-api-demo-app\n```\n\n단계 3: 이제 프로젝트에 라우팅을 처리하기 위해 react-router-dom을 추가해주세요.\n\n\n\n```js\nnpm install react-router-dom\n```\n\n4단계: 애플리케이션에 몇 개의 페이지를 추가해 봅시다. app.js에 아래와 같이 추가할 수 있는 샘플 라우트를 추가해보세요:\n(i) 홈\n(ii) 소개\n\n```js\nconst App = () =\u003e (\n  \u003cdiv\u003e\n    \u003cRoutes\u003e\n      \u003cRoute path=\"/\" element={\u003cHome /\u003e}\u003e\u003c/Route\u003e\n      \u003cRoute path=\"/about\" element={\u003cAbout /\u003e}\u003e\u003c/Route\u003e\n    \u003c/Routes\u003e\n  \u003c/div\u003e\n);\n```\n\n5단계: 두 페이지에 내용을 추가해보세요. 참고를 원하시면, 여기를 클릭하세요.\n\n\n\n6단계: 루트 수준에 \"server\"라는 새 폴더를 만들고, 그 안에 index.js와 server.js라는 새 파일을 만듭니다. 아래 코드를 해당 파일에 복사하여 붙여넣기하세요.\n\n```js\n// server/index.js\nrequire(\"ignore-styles\");\n\nrequire(\"@babel/register\")({\n  ignore: [/(node_modules)/],\n  presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n});\n\nrequire(\"./server\");\n```\n\n이 코드 조각은 Babel을 코드 번역을 위해 설정하고, \"node_modules\"와 같은 특정 파일을 필터링하며, \"server\" 모듈을 가져와 서버를 실행합니다. 이 설정은 React 서버 측 렌더링에서 일반적으로 사용되며, 서버가 React 구성 요소를 처리하고 클라이언트에 제공할 수 있도록 합니다.\n\n```js\n// server/server.js\nimport express from \"express\";\nimport React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\nimport { StaticRouter } from \"react-router-dom/server\";\nimport App from \"../src/App\";\n\nconst app = express();\n\napp.get(\"/*\", (req, res) =\u003e {\n  const entryPoint = [\"/main.js\"];\n\n  const { pipe, abort: _abort } = ReactDOMServer.renderToPipeableStream(\n    \u003cStaticRouter location={req.url}\u003e\n      \u003cApp /\u003e\n    \u003c/StaticRouter\u003e,\n    {\n      bootstrapScripts: entryPoint,\n      onShellReady() {\n        res.statusCode = 200;\n        res.setHeader(\"Content-type\", \"text/html\");\n        pipe(res);\n      },\n      onShellError() {\n        res.statusCode = 500;\n        res.send(\"\u003c!doctype html\u003e\u003cp\u003eLoading...\u003c/p\u003e\");\n      },\n    }\n  );\n});\n\napp.listen(3002, () =\u003e {\n  console.log(\"App is running on http://localhost:3002\");\n});\n```\n\n\n\n위 코드는 app.get(\"/*\", ...)을 사용하여 모든 경로에 대한 라우트 핸들러를 정의합니다. 이는 서버로 들어오는 모든 요청을 처리하는 라우트 핸들러를 의미합니다. 라우트 핸들러 내부에서:\n\n- entryPoint 배열은 main.js 값을 가지고 정의됩니다. 이는 클라이언트 측 코드를 부트스트랩하는 데 사용되는 JavaScript 파일을 가리킵니다.\n- ReactDOMServer.renderToPipeableStream()은 HTML 렌더링을 위한 React 노드와 스트리밍 옵션을 포함하는 선택적 옵션 객체 두 가지 인수를 받습니다. 이는 두 가지 메소드를 반환하는데, pipe와 abort입니다. pipe 메소드는 HTML을 지정된 Node.js 스트림으로 출력합니다. 우리는 onShellReady에서 스트리밍을 가능하게 하기 위해 pipe를 사용합니다. 정적 생성 및 크롤러를 위해 onAllReady도 사용할 수 있습니다.\n- onShellReady()는 렌더링 프로세스가 완료되고 HTML이 클라이언트 전송을 위해 준비된 경우 트리거됩니다. 이는 응답 상태 코드를 200으로 설정하고, 내용 유형 헤더를 text/html로 정의하며, 렌더링된 HTML을 응답에 pipe 메소드를 사용하여 보냅니다.\n- onShellError() 콜백은 렌더링 중 오류가 발생할 때 트리거됩니다. 이는 응답 상태 코드를 500으로 설정하고, HTML `p` 태그로 감싼 기본 오류 메시지를 전송합니다.\n\n7. 클라이언트 측에서는 index.js 파일에서 ReactDOM.createRoot를 ReactDOM.hydrateRoot로 업데이트해야 서버에서 생성된 HTML을 인터랙티브하게 만들 수 있습니다.\n\n```js\n// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport App from \"./App\";\n\nReactDOM.hydrateRoot(\n  document,\n  \u003cReact.StrictMode\u003e\n    \u003cBrowserRouter\u003e\n      \u003cApp /\u003e\n    \u003c/BrowserRouter\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\n\n\n8. 서버 측에서 코드를 실행하려면 package.json 파일에 아래 스크립트를 추가하세요.\n\n```js\n\"ssr\": \"npm run build \u0026\u0026 node server/index.js\"  \n```\n\n이 명령은 프로젝트를 빌드하고 서버 측에서 코드를 실행하여 localhost:3002에 출력물을 생성합니다.\n\n9. 이제 npm run ssr 명령을 실행하여 출력물을 확인하세요.\n\n\n\n![이미지](/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_1.png)\n\n여기에서는 \"renderToPipeableStream\" API만 소개했습니다. React는 \"renderToNodeStream\", \"renderToReadableStream\", \"renderToStaticMarkup\", \"renderToStaticNodeStream\" 및 \"renderToStream\"과 같은 다른 API도 제공하여 요구사항에 맞는 서버 측 렌더링을 지원합니다.\n\n이러한 API에 대한 자세한 정보는 공식 문서를 참조해주시기 바랍니다.\n\n# 결론\n\n\n\n새로운 서버 API로 React 컴포넌트를 서버 렌더링된 HTML로 렌더링할 수 있습니다. Node.js 스트림이나 웹 스트림으로 가능합니다.\n\n대부분의 경우에는 Next.js, Remix, Gatsby와 같은 프레임워크가 이 프로세스를 자동으로 처리합니다. 이 API는 앱의 최상위 수준에서 서버 렌더링된 HTML을 빌드하는 데만 사용됩니다. 초기 로드 시간, SEO, 사용자 경험 및 크로스사이트 스크립팅(XSS) 공격에 대한 취약성을 감소시킬 것입니다.\n\n그러나 SSR은 이점을 제공하면서도 복잡한 구현, 증가한 서버 부하로 인한 상당량의 처리 및 메모리 소비와 같은 단점도 가지고 있습니다. 또한 채팅 앱 및 멀티플레이어 게임과 같은 실시간 애플리케이션에는 적합하지 않을 수 있습니다.\n\n따라서 요구 사항을 고려하고 SSR 구현이 해당 요구 사항과 일치하는지 확인해 주세요.","ogImage":{"url":"/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png"},"coverImage":"/assets/img/2024-05-13-HowtoImplementSSRServerSideRenderinginReact18_0.png","tag":["Tech"],"readingTime":5},{"title":"개발자들이 가져야 할 미덕 게으름, 성급함, 오만함","description":"","date":"2024-05-13 00:06","slug":"2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue","content":"\n\n## 프로그래밍 이야기\n\n\u003cimg src=\"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png\" /\u003e\n\n저는 회사에 처음 입사했을 때, 매일 통신 시스템의 테스트 결과 로그를 분석하는 작업을 맡았습니다. 그 당시는 90년대였고, UNIX 워크스테이션이 사용되고 있어서 핵심 작업은 텍스트를 시각적으로 따라가는 것이었습니다.\n\n각 경우마다 작업에 약 2시간이 걸렸습니다. 각 테스트마다 로그에는 200만에서 300만 줄이 들어있었는데, 물론 모든 것을 시각적으로 확인하는 것은 불가능했기 때문에 로그 분석 도구가 준비되었습니다. 그러나 여전히 많은 부분을 시각적으로 검사해야 했기 때문에 체크하기 쉽지 않았습니다. 시간이 많이 소요되는 작업이었습니다.\n\n\n\n그 일을 하루 이틀 해 본 후, 내 불만이 절정에 달했어(성급하게), 그래서 내 눈으로 탐색할 필요 없이 로그 분석 도구의 결과물을 자동으로 더 분석하기로 결정했어. 내가 했었던 것(1. 태만함).\n\n물론, 이 사실을 상사에게 이야기하면, 그들은 즉시 부인할 거야. 그래서 나는 혼자 시작하기로 결정했어(3. 오만함 → 그러나, 이게 맞는지는 모르겠어. 아마 아니야).\n\n첫 번째 버전을 만드는 데 10시간 이상이 걸렸어. 물론, 그동안 내 분석 작업은 전혀 진전되지 않았어. 그래서 실행해 보니 버그가 가득했어. 그런 걸 만드는 게 익숙하지 않아서, 이건 정상적인 일이야.\n\n그러나 나는 포기하지 않고 계속 수정작업을 반복했어. 복잡한 정규 표현식 패턴, 유한 오토마타 개념, 및 lexer와 parser를 만드는 방법을 배우며. 프로그램이 자동으로 분석할 수 있는 것을 시각적으로 확인할 필요가 없는 바보 같은 일을 하고 싶지 않았어.\n\n\n\n약 일주일 만에 우리는 간단한 언어로 확인하려는 테스트 순서를 정의할 수 있는 매우 기능적인 확인 도구를 만들었어요. 여러 차례 테스트해보았고, 완벽하게 작동함을 확인했어요.\n\n테스트 순서가 정의되면, 이 도구는 테스트 결과가 올바른지 약 10초 안에 확인할 수 있어요. 그래서 일주일 이상 방치되어 있던 분석 작업이 반나절 이내에 완료되었답니다.\n\n그래서 같은 작업을 하는 다른 팀원들에게도 사용해보라고 제안했어요. 당연히 팀의 작업 부담은 급격하게 줄었답니다.\n\n그 이후로, 몇 분 안에 수행할 수 있는 작업이라도 반복이 필요하다면 몇 시간이 걸리더라도 도구를 만들어 자동화하는 내 스타일을 고수해왔어요. 특히 업무 코딩할 때 많이 활용했답니다.\n\n\n\n가능한 한, 저는 입력 완성 기능이 없는 편집기가 없던 시절에 직접 입력하는 대신 프로그램을 자동으로 생성했어요.\n\n물론 처음에는 작업 효율이 비교적 낮았어요 (예를 들어, 2시간이 걸리는 작업을 10초로 자동화하여 10분이 걸리는 것으로 대체하는 것). 그래도 익숙해지면 약 10분 정도만에 빠르게 도구를 만들 수 있었어요.\n\n그 시기에 다른 사람들이 며칠이 걸리는 작업을 몇 시간 만에 프로그램을 만들 수 있는 사람이 되었고, 팀 내에서의 평판이 상당히 좋아졌어요.\n\n결과적으로, 내 이름은 다른 부서에도 알려지게 되었고, 회사의 운명에 따라 의존해야 하는 필수 프로젝트의 일원으로 채용되었어요. 그 중에서도 산업 최초의 Java 기반 프로젝트와 같은 중요한 프로젝트에 참여하게 되었죠.\n\n\n\n이야기가 회사에서의 네 번째 해까지의 이야기입니다. 나머지 이야기는 너무 길어서 생략하겠습니다.\n\n모든 사람들은 서로 다른 특성을 가지고 있고, 래리 월(Larry Wall)이 말하고자 하는 바와 얼마나 일치하는지 모르겠지만, 매우 일반적인 관점에서 보면 그렇게 멀지 않다고 생각해요. 그렇다고 무조건 그런 것은 아니라고 생각해요.\n\n하지만 당시에는 주변 사람들이 각자 자신만의 언어를 개발하고 그것을 전적으로 프로젝트에 활용했기 때문에, 나는 특별히 재능 있는 것은 아니었어요. 이에 대해 다른 사람이 이야기해야 한다고 생각해요. 또한 제 이야기가 그냥 '90년대 예시'에 불과하다는 점을 강조하고 싶어요.\n\n오늘날 IT 산업은 90년대보다 훨씬 밝은 발전 양식을 보여주고 있어요. 제 당시 스타일은 독이 되는 편일 것입니다. 현재의 나의 관점에서도 \"그게 무슨 문제가 있지?\"라고 생각하지만, 당시에는 그것이 통했어요. 위에 쓴 것은 참고용 예시가 아니라 설명을 위한 샘플일 뿐이에요.\n\n\n\n나에게 프로그래밍은 지루하지만 재미있고, 어려움을 겪어본 적이 없다. 처음에는 성별에 맞았던 것 같다. 사람마다 장단점이 있지요.\n\n한편, 친구는 프로그램을 몇 개 만들어도 재미있는 게 뭔지 모른다고 했다. 그런 사람들에게는 프로그래밍이 빈소 같은 건 아닐까 싶어요. \"특성\"이 이런 면을 포함한다고 말할 수 있습니다.\n\n가장 재능 없는 사람은 프로그래밍이 재밌다고 완전히 집착하고 있어요! 프로그래밍이 짐으로 여기지 않고 \"쓰는 걸 즐기는\" 사람들은 잘못된 프로그램을 만들더라도 계속해서 프로그램을 작성하는 경향이 있어요.\n\n프로그래밍 자체가 목적인 만큼, 이해가 돼요. \"유용한 도구\"를 만드는 걸 즐기고, 프로그래밍을 싫어해요. 그 차이가 클 것이라고 생각돼요.\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클로밍하고 팔로우해 주세요️ 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png"},"coverImage":"/assets/img/2024-05-13-WhyLazinessImpatienceandHubrisAreProgrammersGoldenVirtue_0.png","tag":["Tech"],"readingTime":3},{"title":"JavaScript 이벤트 루프와 비동기 프로그래밍 이해하기","description":"","date":"2024-05-13 00:05","slug":"2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming","content":"\n\n\u003cimg src=\"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png\" /\u003e\n\n자바스크립트는 한 번에 하나의 작업을 이벤트 큐에서 처리하기 때문에 싱글 스레드 언어라는 점을 알고 계실 것입니다. 현재 작업이 완료되기 전까지는 다른 작업을 수행할 수 없습니다. 비동기 작업을 처리하는 방식을 이해하는 데 이 특징은 중요합니다.\n\n매우 명확해 보이죠? 그런데 비동기적으로 작업을 수행해야 한다면 어떻게 해야 할까요? 시간이 필요한 단계를 수행해야 하지만 사용자 인터페이스가 멈춰있는 것을 원치 않을 때는 어떻게 해야 할까요?\n\n예를 들어, setTimeout을 사용하여 타이머를 설정하거나 API에서 데이터를 가져올 때, 이와 같이 반만 로드된 웹 사이트를 사용자에게 보여주고 싶지는 않을 것입니다.\n\n\n\n![JavaScript Event Loop and Asynchronous Programming](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_1.png)\n\n요약해보겠습니다. JavaScript를 단일 스레드 언어로 생각할 때, 위 스니펫은 \"Apple\" → \"Elephant\" → \"Orange\" 순서로 로그를 남길 것으로 생각할 수 있습니다.\n\n하지만 실제 결과는 \"Apple\" → \"Orange\" → \"Elephant\" 순서로 나타납니다.\n\n- console.log(‘Apple’) : 이 부분은 콘솔에 \"Apple\"을 동기적으로 기록합니다.\n- setTimeout(() =\u003e console.log('Elephant'), 0): 이 부분은 \"Elephant\"를 0밀리초의 지연 후 콘솔에 기록하기로 예약합니다. 그러나 지연이 0밀리초로 지정되어 있더라도, Node.js와 같은 JavaScript 엔진은 이 작업을 콜백 큐로 밀어 넣어 모든 동기적 작업이 완료된 후에 실행되도록 합니다.\n- console.log('Orange'): 이 부분은 첫 console.log('Apple') 문 이후에 콘솔에 \"Orange\"을 동기적으로 기록합니다.\n- 결국, 모든 동기적 작업이 완료된 후 이벤트 루프가 타임아웃 작업을 가져와 \"Elephant\"를 콘솔에 기록합니다.\n\n\n\n# 이벤트 루프\n\n이전에 언급한 대로 JavaScript는 한 번에 한 가지 일만 할 수 있기 때문에 비동기 작업을 관리하고 이러한 블로킹 함수가 다른 이벤트의 실행을 방해하는 것을 방지하는 메커니즘이 필요합니다.\n\n이 메커니즘을 \"이벤트 루프\"라고 합니다. 기본적으로 비동기 함수가 발견되면 이후에 실행할 콜백 대기열에 추가되어 런타임이 동기 코드를 계속 실행하도록 허용합니다.\n\n여기 JavaScript 이벤트 루프 모델이 있습니다:\n\n\n\n![이미지1](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_2.png)\n\n![이미지2](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_3.png)\n\n1. 호출 스택:\nJavaScript는 호출 스택을 사용하여 프로그램 내의 함수를 추적하고 동기 방식으로 함수 호출을 관리합니다. 함수가 호출되면 호출 스택의 맨 위에 추가되며, 함수가 반환되면 스택에서 제거됩니다. 이 프로세스는 나중에 추가된 것이 먼저 제거되는 (Last In, First Out, LIFO) 원칙을 따릅니다.\n\n2. 메모리 힙:\nJavaScript 런타임에서 메모리 힙은 동적으로 할당된 객체와 변수가 위치하는 메모리 영역입니다.\n\n\n\n3. Callback Queue:\n비동기 함수의 콜백이 대기열에 저장되어 있고, 호출 스택이 비어 있을 때 실행을 위해 대기하는 곳입니다. 이벤트 루프가 이를 처리하기 위해 가져와서 처리합니다.\n\n4. 이벤트 루프:\n이벤트 루프는 콜백 대기열과 호출 스택을 모니터링하는 계속적으로 실행되는 프로세스입니다. 호출 스택이 비어 있지 않으면, 이벤트 루프는 호출 스택이 비어질 때까지 기다렸다가 다음 함수를 콜백 대기열에서 호출 스택으로 이동시킵니다.\n\nJavaScript 자체는 본질적으로 동기적이지만, Web API 및 이벤트 루프와 같은 메커니즘을 통해 비동기 작업을 효과적으로 처리할 수 있습니다.\n\n# 작업 및 마이크로작업\n\n\n\n더 자세히 살펴보면, 실행 문맥에는 두 가지 다른 유형이 있습니다: 작업과 마이크로태스크가 있습니다. JavaScript의 이벤트 루프에서 언제 실행되는지에 따라 다른 우선순위를 갖습니다.\n\n호출 스택이 비어있을 때, 먼저 마이크로태스크 큐를 확인합니다. 마이크로태스크 큐도 비어있으면 태스크 큐에 있는 함수를 실행하기 시작합니다.\n\n태스크\n\n태스크는 이벤트 루프에서 더 높은 수준의 작업 단위입니다. 일반적으로 I/O 작업, 렌더링 및 사용자 입력 이벤트와 같은 다른 비동기 이벤트가 포함됩니다.\n\n\n\n일반적인 작업 예시로는 setTimeout, setInterval, DOM 조작, 그리고 사용자 상호작용을 위한 이벤트 리스너 등이 있습니다.\n\n마이크로태스크\n\n마이크로태스크는 이벤트 루프에서 작업보다 우선순위가 높은 하위 수준의 작업 단위입니다. 일반적으로 브라우저가 렌더링을 수행하거나 다른 상위 수준의 작업을 수행하기 전에 실행되어야 하는 비동기 작업에 사용됩니다.\n\n예시로는 프로미스(해결됨 또는 거부됨)과 변이 관찰자가 있습니다.\n\n\n\n![JavaScript Event Loop](/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_4.png)\n\n요약하자면, JavaScript의 이벤트 루프는 웹 API에 작업을 전달하고, 그 작업을 태스크 큐에서 가져와 콜 스택에서 실행하는 주기적인 프로세스를 포함합니다. 작업을 지속적으로 관리하는 이 프로세스는 JavaScript에서 실행 흐름을 주도합니다.\n\n# 참고 자료\n\n[Philip Roberts: 이벤트 루프가 도대체 뭐길래]\n(https://youtu.be/8aGhZQkoFbQ)\n\n\n\n[JavaScript의 콜 스택이란 무엇인가요?]\nhttps://www.linkedin.com/pulse/what-call-stack-javascript-jay-tillu-252vf/\n\n[이벤트 루프 - 친숙하면서도 낯선 것들]\nhttps://medium.com/@Hsu.Yang-Min/event-loop-a61631e0048b","ogImage":{"url":"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png"},"coverImage":"/assets/img/2024-05-13-JavaScriptUnderstandingEventLoopAsynchronousProgramming_0.png","tag":["Tech"],"readingTime":4},{"title":"네이드 포 스피드 C, NET 8 SSE  채널을 활용한 LLMs Beyond OpenAI, Llama3 및 Fireworksai","description":"","date":"2024-05-13 00:03","slug":"2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai","content":"\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*YtK6hvB_PrUvd7uwqrk0-w.gif\" /\u003e\n\n# 요약\n\n- OpenAI의 GTP-4는 일반적인 목적의 작업에 있어 압도적인 성능을 보여주지만, 전체적인 처리량(또는 오히려 그 부족함)이 많이 부족하다는 점이 매우 아쉽습니다. 이는 \"오프라인\" 작업에는 훌륭하지만, 사용자들이 더 많은 응답성을 기대하는 응용 프로그램에서는 적합하지 않을 수 있으며, 몇몇 사용 사례들은 하위 UX로 인해 배제될 수도 있습니다.\n- TheFastest.ai 팀의 최근 Hackernews 게시물은 모델과 플랫폼 모두에 대해 이런 차이가 얼마나 클 수 있는지를 강조하고 있습니다. 특히, Groq.com(Musk의 Grok와 혼동하지 말아야 합니다)와 Meta의 Llama 3 70B를 사용한 Fireworks.ai는 일부 작업에서 GPT-4와 비교했을 때 출력에 거의 희생 없이 빠른 처리량을 제공합니다.\n- C#/.NET 8 System.Threading.Channels와 서버 전송 이벤트(SSE)를 결합하면, OpenAI의 처리량과 높은 지연 시간으로 잘 동작하지 않은 작업을 구성할 수 있습니다.\n\n# 소개\n\n\n\nGPT-5를 기다리는 동안, 2024년 5월 OpenAI의 GPT-4가 여전히 LLM으로서 전반적인 성능 면에서 우수하다는 것에 대해 논쟁하는 사람은 거의 없을 것입니다. 그러나 해당 모델은 비교적 낮은 처리량과 높은 대기 시간으로 인해 UX가 더 상호 작용적인 경험을 요구하는 경우에는 최적이 아닐 수 있습니다.\n\n가장 빠른 LLM과 현재 사용 가능한 플랫폼과 OpenAI 간의 대기 시간 차이의 규모가 얼마나 큰지는 명백하지 않을 수 있습니다.\n\n최근 Hackernews 스레드를 통해 TheFastest.ai로 이동하게 되었고, Meta의 Llama 3의 높은 처리량과 Groq.com 및 Fireworks.ai라는 두 플랫폼에 흥미로웠습니다.\n\n(전자는 종종 머스크의 Grok AI와 혼동되기 때문에 불행합니다).\n\n\n\n이 기사에서는 Fireworks.ai, Meta Llama 3 8B/70B, .NET 8, System.Threading.Channels 및 Server Sent Events (SSE)를 사용하여 앱을 만드는 방법을 살펴볼 것입니다.\n\n# 차이를 측정하기\n\n스택의 상단은 Llama-3과 Groq가 지배하고 Fireworks.ai가 상위 5위를 차지하고 있습니다(각 팀이 Fireworks를 선택해야 할 이유에 대해 조금 뒤에 설명하겠습니다).\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png)\n\n\n\n대조적으로, OpenAI의 GPT-4는 거의 맨 아래쪽에 위치합니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_1.png)\n\nOpenAI의 GPT-4를 사용해본 사람이라면 이미 처리량이 얼마나 낮은지를 알고 있을 것입니다. 하지만 이렇게 측정된 값을 보면 그 간격이 얼마나 큰지 더욱 부각됩니다. Groq의 Llama-3 70B는 GPT-4보다 거의 10배 더 높은 처리량을 가지고 있습니다!\n\n이에 따라, GPT-4는 상호 작용이 필요하지 않은 경우에, 작업이 큰 문맥 창을 요구하는 경우에, 또는 복잡한 프롬프트와 문맥을 사용하여 \"벤치마크 품질\"의 결과가 필요한 경우에 실제로 매우 좋다고 생각했습니다.\n\n\n\n하지만 사용 사례에 다른 요구 사항이 있는 경우는 어떨까요? 속도가 필요한 경우는 어떨까요?\n\n# Groq와 Fireworks를 이용해 시동 걸기\n\nOpenAI의 처리량이 떨어져 사용자 경험을 나빠지게 만들 수 있는 문제 중 하나는, 최종적으로 콘텐츠가 가치를 추가한다 해도 주관적으로 사용자 경험을 나빠지게 할 수 있다는 것입니다.\n\nOpenAI의 ChatGPT를 사용할 때, 채팅 응답에 몇 초가 걸릴 수도 있다는 사실을 SSE가 가려버리기 때문에 명확하게 드러나지 않을 수 있습니다. GPT-4의 처리량이 낮다는 것은 다른 대안을 시도해보기 전까지는 쉽게 알아챌 수 없습니다.\n\n\n\n# Groq.com\n\nGroq는 LLM에 특별히 설계된 사용자 정의 하드웨어로 알려진 \"LPU\" 또는 \"언어 처리 유닛\"을 갖춘 흥미로운 플랫폼입니다:\n\n적어도 문서로 보면, 이것은 마케팅 허세 이상으로 보이며 플랫폼은 객관적으로 고 처리량을 자랑합니다.\n\n하지만 주요 문제는 현재의 SaaS 제공으로 이어집니다:\n\n\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_2.png)\n\n무료 티어는 실험 용도로만 사용 가능하며, 그것도 겨우 가능할 뿐입니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_3.png)\n\n그래서 Groq은 꽤 빠르지만, 샌드박싱 용도 외에는 사용할 수 없으며, 가능하다면 엔터프라이즈 과금을 통해 사용할 수 있습니다.\n\n\n\n# Fireworks.ai\n\n현재 시점에서 Fireworks의 Llama-3 70B는 전체적으로 9위에 랭크되어 있으며 두 번째로 빠른 Llama-3 70B입니다:\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_4.png)\n\n마지막 토큰까지 260ms가 소요되며, 여전히 매우 빠르며 GPT-3.5와 GPT-4 사이의 성능을 제공하여 내 사용 사례에 대한 LLM 성능이 매우 좋습니다.\n\n\n\nFireworks.ai에는 중간 유료 티어가 없지만, 600 RPM은 작은 앱에 사용하기 적합하며 하드 토큰 제한이 없습니다.\n\n![이미지](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_5.png)\n\n오늘 빠르게 무언가를 구축하려는 팀들에게는 Fireworks.ai가 아마도 최선의 선택일 것입니다. (아니, 나는 그들로부터 돈을 받고 있지 않아요)\n\n# .NET 8, System.Threading.Channels 및 Server Sent Events (SSE)와 함께 실용적인 예제\n\n\n\n이 놀라운 처리량을 활용하기 위해서는 한 번에 여러 개의 스트림을 통해 생성한 다음 하나의 최종 출력 스트림으로 병합하는 동시 처리 전략이 필요합니다.\n\n이는 .NET의 System.Threading.Channels를 Server Sent Events (SSE)와 결합하여 이 처리량을 완전히 활용하고 높은 반응성을 갖는 생성 AI 경험을 구축하는 완벽한 사용 사례입니다.\n\n이전에 이 두 주제에 대해 별도로 다뤘었습니다:\n\n- .NET Task Parallel Library vs System.Threading.Channels\n- .NET 6의 System.Threading.Channels를 이용한 동시 처리 (보너스: 간격 트리)\n- .NET 7과 함께하는 Server Sent Events\n\n\n\n오늘은 .NET 8 채널, Semantic Kernel 및 gen AI와 함께 어떤 대화형 경험을 만들 수 있는지 함께 살펴보겠습니다!\n\n![image](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_6.png)\n\n저희 샘플 응용 프로그램은 준비된 재료 목록과 목표 조리 시간을 받아들여서 다음을 할 것입니다:\n\n- 해당 재료로 만들 수 있는 레시피 목록 생성\n- 레시피 중 하나를 무작위로 선택\n- 레시피를 위해 필요한 모든 재료 목록 생성\n- 레시피를 위한 소개 단락 생성\n- 준비된 각 재료에 대한 영양 정보에 대한 간략한 설명 생성\n- 제안된 사이드 디시 목록 생성\n- 순서 목록 생성\n\n\n\n단계 3~6은 병렬로 실행될 수 있지만, 레시피를 먼저 선택해야 하기 때문에 단계 1~2가 먼저 실행됩니다. 그리고 단계를 생성하기 전에 재료 전체 목록을 기다려야 합니다.\n\n# .NET 채널을 이용한 병행 실행\n\nAPI 호출의 진입점은 요청을 받을 단일 POST 엔드포인트입니다:\n\n```js\n// 👇 메인 진입점.\napp.MapPost(\"/generate\", async (\n  HttpContext context,          // 의존성 주입에서 가져옴\n  RecipeGenerator generator,    // 의존성 주입에서 가져옴\n  RecipeRequest request,        // 바디에서 가져옴\n  CancellationToken cancellation = default\n) =\u003e\n{\n  context.Response.Headers.ContentType = \"text/event-stream\";\n\n  await generator.GenerateAsync(\n    request,\n    // 각 단편에 대한 스트리밍 응답을 작성하는 핸들러\n    async (Fragment f) =\u003e {\n      await context.Response.WriteAsync(\n        $\"data: {f.Part}|{f.Content}{Environment.NewLine}{Environment.NewLine}\",\n        cancellation\n      );\n      await context.Response.Body.FlushAsync(cancellation);\n    }\n  );\n});\n```\n\n\n\nRecipeGenerator.GenerateAsync 메서드에는 메인 플로우가 포함되어 있어요:\n\n```js\n/// \u003csummary\u003e\n/// 주요 시작점\n/// \u003c/summary\u003e\npublic async Task GenerateAsync(\n  RecipeRequest request,\n  Func\u003cFragment, Task\u003e handler, // 👈 이것은 HTTP 응답 스트림에 연결된 후크에요\n  CancellationToken cancellation = default\n) {\n\n  var (ingredientsOnHand, prepTime) = request;\n\n  // 👇 (1) 3개의 레시피 목록을 생성하고 무작위로 하나를 선택\n  var recipes = await GenerateRecipesAsync(ingredientsOnHand, prepTime, cancellation);\n\n  Console.WriteLine($\"생성된 레시피 수: {recipes.Length}.\");\n\n  var recipe = recipes[Random.Shared.Next(0, 2)];\n\n  // 👇 (2) 모든 레시피를 보유하여 HTML 문자열로 집계\n  var alternates = recipes\n    .Where(r =\u003e r.Name != recipe.Name)\n    .Aggregate(new StringBuilder(), (html, r) =\u003e {\n      html.Append($\"\u003cli\u003e\u003cb\u003e{r.Name}\u003c/b\u003e \u0026nbsp;\");\n      html.Append($\"\u003ci\u003e{r.Intro}\u003c/i\u003e\u003c/li\u003e\");\n\n      return html;\n    }).ToString();\n\n  // 👇 (3) 읽기 채널의 리더 측에 대한 반복 작업입니다; 먼저 시작해야 해요\n  var fragmentHandler = async () =\u003e {\n    while (await _channel.Reader.WaitToReadAsync()) {\n      if (_channel.Reader.TryRead(out var fragment)) {\n        await handler(fragment);\n      }\n    }\n  };\n\n  var completion = fragmentHandler();\n\n  // 👇 (4) 이제 세대 프롬프트를 동시에 실행해요\n  Task.WaitAll([\n    handler(new (\"alt\", alternates)),\n    GenerateIngredientsAsync(recipe, ingredientsOnHand, request.PrepTime, cancellation),\n    GenerateIntroAsync(recipe, cancellation),\n    GenerateIngredientIntroAsync(ingredientsOnHand, cancellation),\n    GenerateSidesAsync(recipe, cancellation)\n  ]);\n\n  // 👇 (5) 그리고 모든 작업이 완료될 때까지 기다려요.\n  _channel.Writer.Complete();\n\n  await completion;\n}\n```\n\n여기서 Task.WaitAll의 중요한 차이점은 JavaScript의 Promise.all과 개념적으로 비슷하지만, .NET에서는 멀티 스레드인 .NET 런타임 때문에 동시성과 병렬로 실행될 수 있어요. 이 경우 스레드 풀 스케줄러가 각 작업이 다른 스레드에서 실행될지 여부를 결정할 거에요. 채널을 사용하면 출력을 하나의 스레드에 바인딩된 리더에 병합하여 동기화된 액세스가 필요 없어졌어요.\n\n각 세대 작업은 비슷한 패턴을 따라가요:\n\n\n\n```js\nprivate async Task GenerateIntroAsync(\n  RecipeSummary recipe,\n  CancellationToken cancellation = default\n) {\n  var prompt = \"...\";\n\n  await ExecutePromptAsync(\n    \"int\", // 👈 이것은 프론트엔드 출력 대상의 ID와 일치합니다\n    prompt,\n    new () {\n      MaxTokens = 250,\n      Temperature = 0.55,\n      TopP = 0\n    },\n    cancellation: cancellation\n  );\n}\n```\n\n그리고 프롬프트를 실행하는 메서드:\n\n```js\n/// \u003csummary\u003e\n/// 프롬프트를 실행하고 결과를 채널에 작성합니다.\n/// \u003c/summary\u003e\nprivate async Task ExecutePromptAsync(\n  string part,\n  string prompt,\n  OpenAIPromptExecutionSettings settings,\n  Action\u003cstring\u003e? resultHandler = null,\n  string? modelOverride = null,\n  CancellationToken cancellation = default\n) {\n  // 👇 대화를 초기화합니다\n  var chat = _kernel.GetRequiredService\u003cIChatCompletionService\u003e(\n    modelOverride ?? \"70b\" // 명시된 오버라이드가 없으면 70b를 사용합니다.\n  );\n\n  var history = new ChatHistory();\n  var buffer = new StringBuilder();\n\n  history.AddUserMessage(prompt);\n\n  // 👇 응답을 스트리밍하고 각 부분을 채널에 작성합니다\n  await foreach (var message in chat.GetStreamingChatMessageContentsAsync(\n      history, settings, _kernel, cancellation\n    )\n  ) {\n      await _channel.Writer.WriteAsync( // 👈 채널의 라이터 엔드\n        new(part, message.Content ?? \"\"),\n        cancellation\n      );\n\n      buffer.Append(message.Content); // 👈 전체 출력을 보유하는 버퍼\n  }\n\n  var output = buffer.ToString();\n\n  // 👇 호출자가 전체 결과를 원하는 경우 여기에서 사용할 수 있습니다\n  resultHandler?.Invoke(output);\n}\n```\n\n애플리케이션 실행 중 의존성 주입을 통해 커널 인스턴스가 구성됩니다:```\n\n\n\n```js\r\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\nvar fireworksEndpoint = new Uri(\"https://api.fireworks.ai/inference/v1/chat/completions\");\nvar groqEndpoint = new Uri(\"https://api.groq.com/openai/v1/chat/completions\");\n\nvar config = builder.Configuration\n  .GetSection(nameof(RecipesConfig))\n  .Get\u003cRecipesConfig\u003e();\n\n// Semantic Kernel을 설정하여 필요한만큼의 LLM을 등록합니다.\nvar kernelBuilder = Kernel.CreateBuilder();\nvar kernel = kernelBuilder\n  .AddOpenAIChatCompletion(\n    modelId: \"accounts/fireworks/models/llama-v3-70b-instruct\",\n    apiKey: config!.FireworksKey,\n    endpoint: fireworksEndpoint,\n    serviceId: \"70b\" // 👈 더 나은 결과를 위해 기본적으로 이 serviceId를 사용합니다\n  )\n  .AddOpenAIChatCompletion(\n    modelId: \"accounts/fireworks/models/llama-v3-8b-instruct\",\n    apiKey: config!.FireworksKey,\n    endpoint: fireworksEndpoint,\n    serviceId: \"8b\" // 👈 더 빠른 속도가 필요한 경우 이 serviceId를 사용합니다\n  )\n  .AddOpenAIChatCompletion(\n    modelId: \"llama3-8b-8192\",\n    apiKey: config!.GroqKey,\n    endpoint: groqEndpoint,\n    serviceId: \"groq-8b\" // 👈 최대 처리량을 위해 이 serviceId를 사용합니다\n  )\n  // 다른 LLM을 여기에 등록합니다.\n  .Build();\n\nbuilder.Services\n  .Configure\u003cRecipesConfig\u003e(\n    builder.Configuration.GetSection(nameof(RecipesConfig))\n  )\n  .AddCors()\n  .AddSingleton(kernel)  // 👈 설정된 kernel을 싱글톤으로 추가합니다\n  .AddScoped\u003cRecipeGenerator\u003e();\r\n```\n\nSemantic Kernel을 통해 여러 LLM 엔드포인트를 구성할 수 있습니다. 이를 사용하여 작은 빠른 LLM이 프로세스를 가속화할 수 있는 플로 구현을 단순화할 수 있습니다.\n\n# SSE를 활용한 동시 스트림\n\n컨텐츠가 생성되면 백엔드는 즉시 프론트엔드로 스트리밍하여 매우 반응이 뛰어난 사용자 경험을 제공합니다. 이 과정은 동시에(그리고 스레드 풀 스케줄러에 따라 확장하여 병렬로) 발생하며, 채널에 수집되어 클라이언트에서 소비될 응답 스트림으로 작성됩니다.```\n\n\n\n이 흐름을 시각화하기 위해 아래 다이어그램을 확인해보세요:\n\n![다이어그램](/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_7.png)\n\nTask.WaitAll 코드 블록은 채널의 공유 가능하고 스레드 안전한 writer 엔드를 전달받은 상태이며, reader 엔드는 HTTP 응답 스트림과 콜백을 통해 연결됩니다.\n\n해당 콜백은 간단히 EventSource의 필요한 형식 명세에 따라 Fragment를 서식화합니다.\n\n\n\n이 경우:\n\n```js\ndata: ing|tomatoes\n\ndata: ing|basil\n\ndata: ste|3. Chop the\n```\n\n프론트엔드는 이러한 메시지 스트림을 받아 UI의 서로 다른 섹션에 누적합니다.\n\n- 첫 번째 부분인 ing은 이 내용이 속하는 프론트엔드 부분을 식별합니다 (이 경우에는 \"재료\")\n- | 이후의 텍스트는 LLM에 의해 작성된 출력 토큰 세트를 의미합니다.\n\n\n\n프론트엔드에서 @microsoft/fetch-event-source는 기본 EventSource를 대체하여 POST 사용을 가능하게 하는 폴리필(polyfill)로 사용됩니다.\n\n수신자는 각 메시지를 가져와 디코드합니다:\n\n```js\nonmessage: (msg) =\u003e {\n  var payload = msg.data\n\n  var [part, content] = payload.split('|')\n\n  if (!part || !$el(`#${part}`)) {\n    return // 이 메시지는 버립니다\n  }\n\n  // 👇 이 부분은 새 줄을 인코딩하고 여기서 대체하는 해킹입니다.\n  content = content.replace(/⮑/gi, \"\\n\")\n\n  $el(`#${part}`).innerHTML += content\n},\n```\n\ntext/event-stream의 특이점은 이중 줄바꿈이 메시지 블록의 끝을 나타낸다는 것입니다. 그래서 줄바꿈은 어떤 방식으로든 인코딩되어야 합니다 (다양한 방법이 있습니다). 이 경우, 단일 문자 ⮑을 사용하여 해당 문자를 찾아 \\n으로 대체하는 것이 간답습니다.\n\n\n\nCSS는 그냥 이 부분을 고려하면 됩니다:\n\n```js\n#add, #ing, #ste {\n  white-space: pre-line;\n}\n```\n\nHTML 자체는 간단합니다:\n\n```js\n\u003c!-- 이 블록은 추가 재료를 보관합니다 --\u003e\n\u003cdiv class=\"additional\"\u003e\n  \u003ch2\u003e필요한 재료\u003c/h2\u003e\n  \u003c!-- 👇 이 ID는 Fragment.Part와 일치합니다 --\u003e\n  \u003cdiv id=\"add\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003c!-- 이 블록은 단계를 보관합니다 --\u003e\n\u003cdiv class=\"recipe\"\u003e\n  \u003ch2\u003e조리 단계\u003c/h2\u003e\n  \u003c!-- 👇 이 ID는 Fragment.Part와 일치합니다 --\u003e\n  \u003cdiv id=\"ste\"\u003e\u003c/div\u003e\n\u003c/div\u003e\n```\n\n\n\n# 모두가 준비되었으니 이제 앱을 실행하면 다음과 같은 경험을 할 수 있습니다:\n\n![recipe app](https://miro.medium.com/v2/resize:fit:1400/0*uCMJGy8UoyaC4rFX.gif)\n\n레시피 목록을 생성하는 호출이 차단되므로 약간의 초기 지연이 있습니다.\n\n\n\n그러나 한 번 목록이 생성되고 무작위로 선택된 후, 추가적인 생성은 전체 재료 목록에 의해 차단되는 단계만 동시에 발생합니다. (전체 재료 목록을 사용하여 정확한 단계를 생성해야 하기 때문입니다).\n\n# 결론\n\n사용자 경험(UX)이 높은 처리량을 필요로 하며 작은 컨텍스트 창을 통해 작동할 수 있는 애플리케이션의 경우, Fireworks.ai와 Llama-3 8B/70B는 절대적으로 게임 체인저입니다. 그것은 팀이 OpenAI의 GPT 모델의 높은 지연 때문에 전반적인 UX를 희생시키지 않고 사용 사례에 대해 빌드할 수 있도록 해줍니다.\n\nSystem.Threading.Channels를 사용한 .NET 8 웹 API에 그것을 플러그인하고 SSE와 결합하면, 여러 콘텐츠 청크를 동시에 생성하고, 상호작용적인 생성 AI 경험을 더 많이 구축하거나 생성적인 워크플로우를 간단히 가속화하는 새로운 가능성을 열 수 있습니다.\n\n\n\n동일한 기술을 사용하면 (SSE를 제외하고) 낮은 지연 시간 + 높은 처리량 모델 및 플랫폼을 사용하여 여러 프롬프트를 병렬로 처리하여 서버 생성 워크로드의 처리량을 늘릴 수 있습니다.\n\n전체 repository:","ogImage":{"url":"/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png"},"coverImage":"/assets/img/2024-05-13-NeedforSpeedLLMsBeyondOpenAIwithCNET8SSEChannelsLlama3andFireworksai_0.png","tag":["Tech"],"readingTime":13}],"page":"49","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"49"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>