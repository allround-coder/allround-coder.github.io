<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="React Virtualized로 Masonry 레이아웃 구현하는 방법" href="/post/2024-06-22-ReactVirtualizedMasonry"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Virtualized로 Masonry 레이아웃 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Virtualized로 Masonry 레이아웃 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Virtualized로 Masonry 레이아웃 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법" href="/post/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트로 설명하는 결합도와 응집도 이해하기" href="/post/2024-06-22-CouplingandCohesionexplainedwithtypescript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트로 설명하는 결합도와 응집도 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트로 설명하는 결합도와 응집도 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트로 설명하는 결합도와 응집도 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법" href="/post/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제" href="/post/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS에서 DTO 쉽게 이해하기" href="/post/2024-06-22-DTOexplainedinNestJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS에서 DTO 쉽게 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DTOexplainedinNestJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS에서 DTO 쉽게 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS에서 DTO 쉽게 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript NPM 패키지 배포 초보자 가이드" href="/post/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript NPM 패키지 배포 초보자 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript NPM 패키지 배포 초보자 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript NPM 패키지 배포 초보자 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 존리스zoneless 미래에 대비하는 방법" href="/post/2024-06-22-HowtogetreadyforzonelessfutureinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 존리스zoneless 미래에 대비하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 존리스zoneless 미래에 대비하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 존리스zoneless 미래에 대비하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Query v5로 데이터 가져오기 및 변경하기 변화를 쉽게 처리하는 방법" href="/post/2024-06-22-FecthingandMutationwithReactQueryv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Query v5로 데이터 가져오기 및 변경하기 변화를 쉽게 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-FecthingandMutationwithReactQueryv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Query v5로 데이터 가져오기 및 변경하기 변화를 쉽게 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Query v5로 데이터 가져오기 및 변경하기 변화를 쉽게 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript로 NextJS 아키텍처 마스터하기  2024 디자인 추상화 방법" href="/post/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript로 NextJS 아키텍처 마스터하기  2024 디자인 추상화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript로 NextJS 아키텍처 마스터하기  2024 디자인 추상화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript로 NextJS 아키텍처 마스터하기  2024 디자인 추상화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link posts_-active__YVJEi" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"React Virtualized로 Masonry 레이아웃 구현하는 방법","description":"","date":"2024-06-22 14:51","slug":"2024-06-22-ReactVirtualizedMasonry","content":"\n\n\n![React Virtualized Masonry](/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png)\n\n웹 개발 분야에서 특히 대규모 데이터셋과 복잡한 레이아웃을 다룰 때는 성능을 유지하면서 부드러운 사용자 경험을 제공하는 것이 중요합니다. 이 균형을 달성하는 강력한 방법 중 하나는 React Virtualized와 Masonry를 함께 사용하는 것입니다. 이 다이내믹한 콤보는 다양한 높이의 항목 그리드를 렌더링하고 관리하는 효율적인 솔루션을 제공하여 가시적인 항목만 렌더링함으로써 최적의 성능을 보장합니다.\n\n# Masonry 사용 이유\n\nMasonry 컴포넌트 소개\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMasonry 구성 요소는 윈도잉 기술을 사용하여 동적으로 크기가 조정되고 사용자가 위치를 지정한 셀을 효율적으로 표시합니다. 셀의 위치는 삽입된 cellPositioner 속성으로 제어됩니다. 윈도잉은 수직 방향이며, 이 구성 요소는 수평 스크롤을 지원하지 않습니다.\n\n향상된 사용자 경험\n\n인터페이스를 직관적으로 만들어 Masonry는 사용자들의 학습 곡선을 줄입니다. 사용자들이 자연스럽게 요소와 상호 작용할 수 있게 하여 참여도와 만족도를 높입니다.\n\n생산성 향상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자들은 요소를 빠르게 재배열할 수 있어서 더 효율적인 작업 흐름을 이끌어냅니다. 특히 프로젝트 관리 도구나 디자인 소프트웨어와 같이 구성 요소를 자주 재조직해야 하는 애플리케이션에서 특히 유용합니다.\n\n유연성\n\n매소네리는 파일 관리 시스템부터 복잡한 웹 애플리케이션까지 다양한 용례에 적응할 수 있습니다. 다양한 플랫폼에서 일관된 상호작용 모델을 제공합니다.\n\n미적 매력\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대적이고 세련된 외관으로, Masonry는 응용 프로그램을 시각적으로 매력적으로 만듭니다. 부드러운 전환과 애니메이션은 정교한 사용자 인터페이스를 형성하며 전반적인 사용자 경험을 향상시킵니다.\n\n# Masonry의 주요 기능\n\n측정 및 레이아웃\n\n- 측정: 처음에 Masonry는 셀MeasurerCache 속성에서 제공된 추정된 셀 크기를 사용하여 배치에서 얼마나 많은 셀을 측정할지 결정합니다.\n- 레이아웃 알고리즘: 빠르고 단순한 레이아웃 알고리즘은 이미지를 순서대로 쌓아 뷰포트가 채워질 때까지 진행됩니다.\n- 캐싱: 모든 측정값은 성능을 위해 캐시되며, keyMapper에서 제공된 키를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위치 지정 및 캐싱\n\n- 위치 지정: 외부 cellPositioner는 캐싸이즈 측정을 사용하여 셀을 위치시킵니다.\n- 캐싱: 위치 지정기가 반환하는 위치는 Masonry에 의해 빠르게 액세스할 수 있도록 캐시됩니다.\n- 재계산: 사용자가 현재 레이아웃 경계를 벗어나거나 레이아웃이 무효화된 경우, 캐시된 위치를 지우고 recomputeCellPositions() 또는 clearCellPositions()를 사용하여 다시 계산할 수 있습니다.\n\n애니메이션 및 레이아웃 제약 조건\n\n- 간단한 애니메이션: 기본 애니메이션으로 사용자 경험을 향상시킵니다.\n- 복잡한 애니메이션: 더 복잡한 애니메이션은 지원되지 않으며, 성능과 간단함에 중점을 두고 있습니다.\n- 다중 열 레이아웃: 각 항목이 고유한 게으르게 측정된 높이를 가질 수 있도록 지원하는 다중 열을 지원합니다.\n- 폭 동일: 열의 모든 항목은 동일한 너비를 가져야 합니다. 항목은 여러 열에 걸칠 수 없습니다.\n- 동기식 측정: 빈번한 레이아웃 무효화를 피하기 위해 셀 측정은 동기적이어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공용 메소드\n\n- clearCellPositions: 내부 위치 캐시를 지우고 강제 업데이트를 수행하여 레이아웃을 무효화하는 데 유용합니다.\n- recomputeCellPositions: 내부 위치 캐시를 재설정하고 위치를 다시 계산하여 업데이트를 강제하여 레이아웃이 정확하도록합니다.\n- cellRenderer: 셀의 인덱스를 제공하여 단일 셀을 렌더링하는 데 책임이 있으며 셀이 표시되는 방식에 유연성을 제공합니다.\n- createMasonryCellPositioner: 간단한 레이아웃을 위한 내장 위치지정자를 제공하여 설정 프로세스를 간소화합니다.\n\n![이미지](/assets/img/2024-06-22-ReactVirtualizedMasonry_1.png)\n\n# 속성 유형\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Virtualized Masonry에서 Prop Types는 컴포넌트에서 사용되는 다양한 속성(prop)의 예상 데이터 유형을 정의하고 강제하는 방법입니다. 이들은 올바른 데이터가 컴포넌트로 전달되도록 보장하여 잠재적인 오류를 줄이고 코드 신뢰성을 향상시키는 데 도움이 됩니다.\n\nProp types에 대한 자세한 정보는 👉 여기에서 찾을 수 있습니다.\n\n# React Virtualized Masonry 구현\n\n다음은 React Virtualized를 사용하여 Masonry 레이아웃을 만드는 방법을 실제 예제로 보여줍니다. 이 예제는 항목 목록을 만들고 CellMeasurerCache를 사용하여 항목의 크기를 캐시합니다. cellPositioner는 셀을 세 개의 열이 있는 그리드에 배치하는 데 도움을 줍니다. 각 셀은 항목의 이미지와 캡션을 포함하는 CellMeasurer 컴포넌트를 반환하는 cellRenderer 함수를 사용하여 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst cellPositioner = createMasonry(cellPositionerConfig);\n\nconst MasonryComponent = ({ itemsWithSizes, setRef }) =\u003e {\n  const cellRenderer = ({ index, key, parent, style }) =\u003e {\n    const { item, size } = itemsWithSizes[index];\n    const height = columnWidth * (size.height / size.width) || defaultHeight;\n\n    return (\n      \u003cCellMeasurer cache={cache} index={index} key={key} parent={parent}\u003e\n        \u003cdiv style={style}\u003e\n          \u003cdiv\u003e{item.title}\u003c/div\u003e\n          {item.image \u0026\u0026 (\n            \u003cimg\n              src={item.image}\n              alt={item.title}\n              style={{\n                height: height,\n                width: columnWidth,\n                display: \"block\",\n              }}\n            /\u003e\n          )}\n        \u003c/div\u003e\n      \u003c/CellMeasurer\u003e\n    );\n  };\n\n  return (\n    \u003cMasonry\n      cellCount={itemsWithSizes.length}\n      cellMeasurerCache={cache}\n      cellPositioner={cellPositioner}\n      cellRenderer={cellRenderer}\n      height={600}\n      width={800}\n      keyMapper={keyMapper}\n      ref={setRef}\n    /\u003e\n  );\n};\n```\n\n전체 코드 예제는 👉 codesandbox에서 확인할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*Tb6VpBuPf_6Oav1kin8-Og.gif\" /\u003e\n\n# 마무리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Virtualized과 Masonry를 결합하면 그리드 내에서 동적 크기의 사용자 위치 지정 셀을 처리하는 효율적인 방법을 제공합니다. 예제 코드는 측정 및 레이아웃 단계가 최적의 성능을 위해 중요함을 강조하며 통합을 보여줍니다. 이 조합은 대규모 데이터셋을 다루는 복잡한 레이아웃을 React 애플리케이션에서 효과적으로 관리하는 견고한 해결책이며 반응성과 부드러운 사용자 경험을 보장합니다.\n\n텔레그램 / 인스타그램 / 페이스북 / 스레드 / 깃허브","ogImage":{"url":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png"},"coverImage":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트로 모바일 vs 데스크탑 브라우저 감지하는 방법","description":"","date":"2024-06-22 14:50","slug":"2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png\" /\u003e\n\n사용자가 어떤 기기에서 브라우징하는지 탐지하는 것은 모바일 또는 데스크톱 장치에 콘텐츠를 최적화하거나 장치별 기능과 호환성을 보장하며 전체 사용자 경험을 향상시키는 다양한 이유로 매우 중요합니다. 이 기사에서는 JavaScript를 사용하여 모바일과 데스크톱 브라우저를 감지하는 다양한 기술에 대해 논의하고 장단점을 살펴보겠습니다.\n\n# 사용자 에이전트 문자열 감지\n\n사용자 에이전트 문자열은 브라우저가 서버로 보내는 정보 조각으로, 브라우저, 버전 및 운영 체제에 대한 세부 정보를 제공합니다. JavaScript에서 navigator.userAgent 속성을 사용하여 사용자 에이전트 문자열에 액세스할 수 있습니다. 사용자 에이전트 문자열을 구문 분석하여 사용자가 모바일 장치인지 데스크톱 장치인지 결정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모바일 기기를 감지하는 일반적인 방법 중 하나는 사용자 에이전트 문자열에서 특정 키워드를 찾기 위해 정규 표현식(regex)을 사용하는 것입니다. 간단한 예제를 살펴봅시다:\n\n```js\nfunction isMobile() {\n  const regex = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;\n  return regex.test(navigator.userAgent);\n}\n\nif (isMobile()) {\n  console.log(\"모바일 기기를 감지했습니다\");\n} else {\n  console.log(\"데스크톱 기기를 감지했습니다\");\n}\n```\n\n사용자 에이전트 문자열 감지는 비교적 간단하게 구현할 수 있지만, 여러 제한 사항이 있습니다:\n\n- 사용자 에이전트 문자열에 특정 키워드가 의존되므로 시간이 지남에 따라 변경되거나 특정 기기에 누락될 수 있습니다.\n- 일부 브라우저에서 사용자가 사용자 에이전트 문자열을 변경할 수 있어 정확한 감지를 방해할 수 있습니다.\n- 사용자 에이전트 문자열 감지는 새로운 기기와 브라우저가 정기적으로 출시되므로 미래지향적이지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기능 감지\n\n사용자 에이전트 문자열 감지의 대안은 모바일 또는 데스크톱 장치에 고유한 장치 기능을 확인하는 것입니다. 터치 기능이 그 중 하나입니다. JavaScript를 사용하여 다음 코드로 터치 지원을 감지할 수 있습니다.\n\n```js\nfunction hasTouchSupport() {\n  return 'ontouchstart' in window || navigator.maxTouchPoints \u003e 0;\n}\n\nif (hasTouchSupport()) {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\n이 방법은 사용자 에이전트 문자열 감지보다 더 신뢰할 수 있지만 완벽하지는 않습니다. 일부 데스크톱 장치인 터치스크린 노트북과 같은 장치가 오류로 모바일 장치로 잘못 식별될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 기능 기반 접근 방법은 기기의 화면 크기와 해상도를 감지하는 것입니다. 모바일 기기는 일반적으로 데스크톱 기기와 비교해 화면이 작고 해상도가 낮습니다. 윈도우 크기와 해상도를 확인할 수 있습니다. 이를 위해서 window.innerWidth, window.innerHeight, window.devicePixelRatio 및 screen.width 속성을 사용할 수 있습니다. 여기에 예시가 있습니다:\n\n```js\nfunction isMobile() {\n  const minWidth = 768; // 데스크톱 기기의 최소 너비\n  return window.innerWidth \u003c minWidth || screen.width \u003c minWidth;\n}\n\nif (isMobile()) {\n  console.log(\"모바일 기기 감지\");\n} else {\n  console.log(\"데스크톱 기기 감지\");\n}\n```\n\n이 방법에도 일부 제한이 있습니다. 예를 들어, 데스크톱 기기에서 브라우저 창의 크기를 조정하는 경우 false positive(잘못된 양성)로 이어질 수 있습니다. 게다가, 모바일 기기의 화면 크기와 해상도가 계속 증가함에 따라 이 방법은 더 이상 정확하지 않을 수 있습니다.\n\n# 검출을 위한 라이브러리 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모바일 감지(Mobile Detect)는 사용자 에이전트 문자열을 구문 분석하여 모바일 장치를 식별하기 위한 깨끗한 API를 제공하여 장치 감지를 간단하게 하는 인기 있는 JavaScript 라이브러리입니다. 다음과 같이 사용할 수 있습니다:\n\n```js\nimport MobileDetect from 'mobile-detect';\n\nconst md = new MobileDetect(navigator.userAgent);\nif (md.mobile()) {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\nBowser는 사용자 에이전트 문자열을 구문 분석하고 장치 감지를 제공하는 다른 라이브러리입니다. 브라우저, 운영 체제 및 장치 유형에 대한 추가 정보도 제공합니다. 다음은 예시입니다:\n\n```js\nimport Bowser from 'bowser';\n\nconst parser = Bowser.getParser(navigator.userAgent);\nif (parser.getPlatformType() === 'mobile') {\n  console.log(\"모바일 장치 감지됨\");\n} else {\n  console.log(\"데스크톱 장치 감지됨\");\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPlatform.js는 사용자 에이전트 문자열을 파싱하여 브라우저, 운영 체제 및 기기 유형에 대한 정보를 제공하는 가벼운 라이브러리입니다. 다음과 같이 사용할 수 있습니다:\n\n```js\nimport platform from 'platform';\n\nif (platform.isMobile) {\n  console.log(\"모바일 기기가 감지되었습니다\");\n} else {\n  console.log(\"데스크톱 기기가 감지되었습니다\");\n}\n```\n\n# 최선의 실천 방법\n\n- 가능한 경우 사용자 에이전트 문자열 감지보다 기능 감지를 선호하세요. 이는 더 신뢰할 수 있고 미래에 대비할 수 있습니다.\n- 감지를 간단히하고 정확도를 향상시키기 위해 라이브러리를 사용하세요.\n- 보다 견고한 감지를 위해 여러 기술을 결합하세요.\n- 새로운 기기 및 브라우저와의 호환성을 보장하기 위해 감지 코드를 지속적으로 테스트하고 업데이트하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 글에서는 JavaScript를 사용하여 모바일과 데스크톱 브라우저를 감지하는 다양한 기술에 대해 논의했습니다. 사용자 에이전트 문자열 감지, 기능 감지 및 라이브러리 기반 감지를 포함합니다. 각 기술에는 장단점이 있으며 완벽한 방법은 없습니다. 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다. 다음 글에서 만나기를 기대합니다.\n\nMedium 회원이 아니세요? 여기에서 지원해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png"},"coverImage":"/assets/img/2024-06-22-DetectingMobilevsDesktopBrowsersinJavaScript_0.png","tag":["Tech"],"readingTime":4},{"title":"타입스크립트로 설명하는 결합도와 응집도 이해하기","description":"","date":"2024-06-22 14:48","slug":"2024-06-22-CouplingandCohesionexplainedwithtypescript","content":"\n\n![image](/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png)\n\n소프트웨어 개발에서 낮은 결합을 추구하는 것은 유연하고 쉽게 유지보수할 수 있는 시스템을 만드는 데 중요하며, 이는 소프트웨어 품질의 측정 항목입니다.\n\n결합은 시스템의 서로 다른 모듈이나 구성 요소 간의 의존성을 나타내며, 적절하게 관리되지 않으면 코드를 복잡하게 만들어 수정하기 어렵게 만들 수 있습니다.\n\n따라서 다양한 종류의 결합과 그 영향을 이해하는 것은 견고하고 확장 가능한 시스템을 만들려는 개발자들에게 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 커플링이란 무엇인가요?\n\n커플링은 소프트웨어 엔지니어링에서 시스템의 다른 부분 간의 의존도를 나타내는 것을 말합니다. 구성 요소 간에 높은 커플링이 있다면 더 강한 상호의존성을 의미합니다.\n\n높은 커플링은 모듈이 긴밀하게 연결되어 있어 하나의 모듈에서의 변경이 다른 모듈들에 영향을 미칠 수 있다는 것을 의미합니다. 낮은 커플링은 모듈이 독립적이므로 하나의 모듈에서의 변경이 다른 모듈에 미치는 영향이 최소화됩니다.\n\n소프트웨어 시스템의 구조와 유지관리에 영향을 미치는 여러 유형의 커플링이 존재합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 결합 유형:\n\n1 — 데이터 결합:\n\n다른 모듈에 특정 데이터 구조에만 의존하는 경우 발생합니다. 모듈은 독립적이며, 서로 전달되는 데이터 유형에 한정된 종속성을 갖습니다.\n\n```js\n// 예시 A\nclass User {\n  constructor(private name: string) {}\n\n  getName(): string {\n    return this.name;\n  }\n}\n\n// 예시 B\nclass UserManager {\n  constructor(private user: User) {}\n\n  showUserName(): void {\n    console.log(this.user.getName());\n  }\n}\n\n// 모듈 A와 B 사용\nconst user = new User(\"Ana\");\nconst userManager = new UserManager(user);\nuserManager.showUserName();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 UserManager은 User에 직접적으로 의존하므로 User 클래스 구조나 동작에 대한 변경사항이 UserManager에 직접적인 영향을 미칠 수 있습니다.\n\n2 - 스탬프 결합:\n\n복잡한 데이터 구조에서 모듈이 많은 필드를 공유하지만 각 모듈은 이 필드의 일부분만 사용하는 데이터 결합 형태를 가리킵니다.\n\n```js\n// 예제 A\nclass Order {\n  constructor(private id: number, private description: string, private amount: number) {}\n\n  getId(): number {\n    return this.id;\n  }\n}\n\n// 예제 B\nclass OrderManager {\n  constructor(private order: Order) {}\n\n  showOrderId(): void {\n    console.log(this.order.getId());\n  }\n}\n\n// 모듈 A와 B 사용법\nconst order = new Order(1, \"Product A\", 100);\nconst orderManager = new OrderManager(order);\norderManager.showOrderId();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 OrderManager는 복잡한 데이터 구조를 가진 Order 객체에 종속되지만 특정 하위 집합 필드만 사용합니다(이 경우 id). 이는 스탬프 결합을 보여줍니다.\n\n3 — 제어 결합:\n\n프로그램 실행 흐름에 영향을 미치는 플래그 값 또는 표시기와 같은 공유 제어 정보로 인해 모듈간의 의존성이 발생합니다.\n\n```js\n// 예시 A\nclass PaymentProcessor {\n  processPayment(status: boolean): void {\n    if (status) {\n      console.log(\"결제가 성공적으로 처리되었습니다.\");\n    } else {\n      console.log(\"결제 처리에 실패했습니다.\");\n    }\n  }\n}\n\n// 예시 B\nclass ShoppingCart {\n  constructor(private processor: PaymentProcessor) {}\n\n  completePurchase(status: boolean): void {\n    this.processor.processPayment(status);\n  }\n}\n\n// 모듈 A와 B 사용법\nconst processor = new PaymentProcessor();\nconst cart = new ShoppingCart(processor);\ncart.completePurchase(true);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 ShoppingCart은 PaymentProcessor에 의존하여 결제 상태에 따라 구매가 성공적으로 완료되었는지를 결정합니다. 이것은 제어 결합을 보여줍니다.\n\n4 - 공통 결합:\n\n두 개 이상의 모듈이 자신의 기능을 수행하기 위해 공통의 세 번째 모듈에 의존하는 경우 발생합니다. 이렇게 되면 모듈 간에 강한 상호의존성이 생기며, 시스템을 모듈화하고 유지하기가 더 어려워집니다.\n\n```js\n// 예제 A\nclass Logger {\n  logMessage(message: string): void {\n    console.log(`[LOG] ${message}`);\n  }\n}\n\n// 예제 B\nclass AuthenticationService {\n  constructor(private logger: Logger) {}\n\n  authenticateUser(): void {\n    // 인증 로직\n    this.logger.logMessage(\"사용자가 성공적으로 인증되었습니다.\");\n  }\n}\n\n// Module A와 B 사용법\nconst logger = new Logger();\nconst authService = new AuthenticationService(logger);\nauthService.authenticateUser();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 AuthenticationService는 인증 프로세스 중 로그 메시지를 기록하기 위해 Logger에 의존합니다. 두 모듈 모두 Logger에 의존하므로 공통적으로 결합되어 있음을 나타냅니다.\n\n5 — 콘텐츠 결합:\n\n모듈이 다른 모듈의 내부 구현에 직접적으로 의존하며 내부 변수에 액세스하고 조작하는 가장 강력한 결합 형태입니다.\n\n```js\n// 예제 A\nclass Calculator {\n  private result: number = 0;\n\n  add(a: number, b: number): void {\n    this.result = a + b;\n  }\n\n  getResult(): number {\n    return this.result;\n  }\n}\n\n// 예제 B\nclass CalculatorLogger {\n  private calculator: Calculator;\n\n  constructor(calculator: Calculator) {\n    this.calculator = calculator;\n  }\n\n  logResult(): void {\n    console.log(`Operation result: ${this.calculator.getResult()}`);\n  }\n}\n\n// 모듈 A와 B 사용법\nconst calculator = new Calculator();\ncalculator.add(2, 3);\nconst logger = new CalculatorLogger(calculator);\nlogger.logResult();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 CalculatorLogger는 Calculator의 내부 구현에 직접 의존하며 결과 변수에 액세스하고 조작합니다. 이는 content coupling을 나타내며 가장 강한 유형으로 간주됩니다.\n\n# 낮은 결합도의 장점:\n\n- 더 쉬운 유지 보수: 낮은 결합도는 하나의 모듈 내 변경이 다른 모듈에 미치는 영향을 줄이며, 개별 구성 요소의 수정 또는 교체을 용이하게 합니다.\n- 향상된 모듈화: 낮은 결합도는 모듈이 독립적으로 개발되고 테스트될 수 있도록 해 코드의 모듈화와 재사용성을 향상시킵니다.\n- 더 나은 확장성: 낮은 결합도는 새로운 모듈 추가와 기존 모듈 제거를 용이하게 하여 필요에 따라 시스템의 확장성을 증진시킵니다.\n\n# 높은 결합도의 단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 증가된 복잡성: 높은 결합은 모듈간의 상호 의존성을 증가시켜 시스템이 더 복잡하고 이해하기 어렵게 만듭니다.\n- 유연성 감소: 높은 결합은 개별 구성 요소를 수정하거나 교체하기가 전체 시스템에 영향을 미치게 만들어 어렵게 합니다.\n- 모듈성 저하: 높은 결합은 독립적으로 모듈을 개발하고 테스트하는 것을 복잡하게 만들어 코드 모듈성과 재사용성을 줄입니다.\n\n# 응집도\n\n소프트웨어 개발에서 응집력이란 시스템 내의 다른 구성 요소에 어떻게 책임이 할당되는지와 관련된 개념입니다.\n\n높은 응집력은 시스템의 구성 요소가 서로 관련이 깊고 명확한 목적을 수행하는 것을 의미하며, 낮은 응집력은 구성 요소가 구별되고 느슨하게 관련된 책임을 가지고 있는 것을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커플링과 유사하게, 응집도는 소프트웨어의 품질과 유지 보수성에 중요한 역할을 합니다. 시스템의 모듈화 및 확장 가능성에 직접적인 영향을 미칩니다.\n\n# 응집도의 주요 유형:\n\n1 — 기능 응집도:\n\n기능 응집도는 모듈 내 요소가 관련되어 단일 특정 기능이나 작업을 수행할 때 발생합니다. 이는 모듈 내 각 구성 요소가 해당 주요 기능과 직접적으로 관련되어 동일한 목표를 달성하는 데 기여한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 기능 응집의 예\nclass Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  divide(a: number, b: number): number {\n    return a / b;\n  }\n}\n```\n\n이 예제에서 Calculator 클래스는 서로 다른 수학 연산을 수행하는 메서드를 가지고 있어서, 각 메서드가 계산기의 주요 기능에 기여함으로써 기능 응집성을 유지합니다.\n\n2 - 순차 응집:\n\n순차 응집은 모듈 내의 작업이 특정 순서로 구성되어 있고, 한 작업의 출력이 다음 작업의 입력으로 작동할 때 발생합니다. 즉, 모듈 요소들이 순차적으로 관련되어 있고 서로 의존하여 일련의 단계를 순서대로 실행하기 위해 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 순차 응집의 예\nclass OrderProcessor {\n  processOrder(order: Order): void {\n    this.validateOrder(order);\n    this.updateInventory(order);\n    this.sendConfirmation(order);\n  }\n\n  validateOrder(order: Order): void {\n    // 주문 유효성 검사 로직\n  }\n\n  updateInventory(order: Order): void {\n    // 재고 업데이트 로직\n  }\n\n  sendConfirmation(order: Order): void {\n    // 확인 메일 보내기 로직\n  }\n}\n```\n\n이 예제에서 OrderProcessor 클래스는 주문 처리를 위한 순차적 단계를 실행하는 메서드를 갖고 있습니다. 각 메서드는 이전 메서드의 결과에 종속되어 높은 순차 응집을 유지합니다.\n\n3 — 시간적 응집:\n\n시간적 응집은 모듈 내의 작업이 시간적으로 관련이 있고 시간적 종속성으로 인해 함께 실행되어야 하는 경우 발생합니다. 이는 모듈 요소가 특정 기능이 아닌 실행해야 할 시간에 따라 그룹화되는 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 시간적 응집력의 예제\nclass TaskScheduler {\n  scheduleTask(task: Task, time: string): void {\n    // 작업 예약 논리\n  }\n\n  cancelTask(task: Task): void {\n    // 작업 취소 논리\n  }\n\n  executeTask(task: Task): void {\n    // 작업 실행 논리\n  }\n}\n```\n\n이 예제에서 TaskScheduler 클래스는 작업을 예약, 취소, 실행하는 메서드를 가지고 있으며, 각 메서드가 시간적으로 관련되어 특정 시점에 실행되어야 하므로 높은 시간적 응집력을 유지합니다.\n\n4 — 논리적 응집력:\n\n논리적 응집력은 모듈 내의 요소가 특정 로직에 의해 관련되거나 동일한 데이터 집합을 처리할 때 발생합니다. 이는 모듈 요소가 공유된 논리나 동일한 데이터 조작을 기준으로 그룹화되어 있는 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// 논리 응집의 예\r\nclass FormValidator {\r\n  validateRequiredField(value: string): boolean {\r\n    // 필수 필드 유효성 검사 로직\r\n    return value.trim() !== '';\r\n  }\r\n\r\n  validateEmailField(value: string): boolean {\r\n    // 이메일 필드 유효성 검사 로직\r\n    return /\\S+@\\S+\\.\\S+/.test(value);\r\n  }\r\n\r\n  validateForm(form: Form): boolean {\r\n    // 폼 유효성 검사 로직\r\n    return this.validateRequiredField(form.name) \u0026\u0026 this.validateEmailField(form.email);\r\n  }\r\n}\r\n```\r\n\r\n이 예제에서 FormValidator 클래스는 각 메서드가 특정 유효성 검사 로직에 의해 관련되어 있어 높은 논리 응집을 유지하고 있습니다.\r\n\r\n5 — 우연한 응집:\r\n\r\n우연한 응집은 모듈 내 요소들이 중요한 관련성 없이 임의로 그룹화된 경우입니다. 이는 모듈 요소들이 편리함이나 우연한 이유로 함께 그룹화된 것을 의미하며, 공통 목적이나 논리를 위해 그룹화된 것이 아닙니다.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Coincidental Cohesion의 예제\nclass Utility {\n  generateReport(data: any): void {\n    // 보고서 생성 로직\n  }\n\n  sendEmail(recipient: string, message: string): void {\n    // 이메일 발송 로직\n  }\n\n  calculateTaxes(data: any): void {\n    // 세금 계산 로직\n  }\n}\n```\n\n이 예제에서 Utility 클래스는 중요한 관계 없이 다양한 작업을 수행하는 메서드를 가지고 있어서 우연한 응집력이 낮습니다.\n\n다양한 응집력 유형을 이해하는 것은 모듈식, 유연하며 유지보수 가능한 소프트웨어 시스템을 설계하는 데 중요합니다. 각 구성 요소에 적합한 응집력 유형을 선택함으로써, SOLID 및 다른 소프트웨어 설계 원칙을 따르며 더 견고하고 확장 가능한 시스템을 만들 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 주변을 따라오세요!😜\n\n- 포트폴리오: gustavobruno.dev\n- GitHub: @gustavobrunodev\n- LinkedIn: @gustavobrunodev","ogImage":{"url":"/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png"},"coverImage":"/assets/img/2024-06-22-CouplingandCohesionexplainedwithtypescript_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법","description":"","date":"2024-06-22 14:46","slug":"2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators","content":"\n\n`\u003cimg src=\"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png\" /\u003e`\n\n데코레이터는 클래스 선언, 메소드, 접근자, 속성 또는 매개변수에 첨부할 수 있는 특별한 선언 유형입니다. 데코레이터는 @expression 형식으로 사용되며, expression은 데코레이트된 선언에 대한 정보를 런타임에 호출할 함수로 평가되어야 합니다.\n\nTypescript 5.0부터 Stage 3 데코레이터 지원이 가능합니다.\n\n## 데코레이터 사용 방법:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데코레이터에 대한 실험적인 지원을 활성화하려면 명령줄에서 tsc --target ES5 --experimentalDecorators를 사용하거나 tsconfig.json에서 experimentalDecorators 컴파일러 옵션을 활성화해야 합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n사용자 클래스에 greet 메서드가 있는 경우를 고려해보세요.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n출력:\nHello, my name is Ron.\nI am 25 years old\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 각 함수 실행이 시작하고 끝나는 시점을 기록하고 싶어요:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log('start: greet')\n    console.log(`Hello, my name is ${this.name}.`);\n    console.log('end: greet')\n  }\n\n  printAge() {\n    console.log('start: printAge')\n    console.log(`I am ${this.age} years old`);\n    console.log('end: printAge')\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n데코레이터를 만드는 것은 정말 쉬워요: logger라는 함수를 만들기만 하면 돼요:\n\n```js\nfunction logger(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"start:\", originalMethod.name);\n    const result = originalMethod.call(this, ...args);\n    console.log(\"end:\", originalMethod.name);\n    return result;\n  }\n\n  return replacementMethod;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 메소드를 꾸밈을 준비했어요. 위의 예시에서 데코레이터를 사용해봅시다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n쉽죠? TypeScript는 여러 데코레이터를 지원합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  @logger\n  @xyz\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n```\n\n여러 개의 데코레이터가 적용될 때 실행 순서를 살펴봅시다.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger2\n  @logger1\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\n\n\nfunction logger1(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log1\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\nfunction logger2(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log2\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\n\n\n\n\nOutput: \nlog2\nlog1\nHello, my name is Ron.\n```\n\n하나의 선언에 여러 데코레이터가 적용되면, 그 평가는 수학의 함수 합성과 유사합니다. 이 모델에서 함수 f와 g를 합성할 때, 결과 컴포지트(f ∘ g)(x)는 f(g(x))와 동등합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n올바른 형식의 데코레이터 예제:\n\n```js\nfunction loggedMethod\u003cThis, Args extends any[], Return\u003e(\n    target: (this: This, ...args: Args) =\u003e Return,\n    context: ClassMethodDecoratorContext\u003cThis, (this: This, ...args: Args) =\u003e Return\u003e\n) {\n    const methodName = String(context.name);\n\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`)\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`)\n        return result;\n    }\n\n    return replacementMethod;\n}\n```\n\n## 데코레이터 유형:\n\n## 1. 클래스 데코레이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스의 생성자에 적용되며, 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: 선언 클래스에 대해)에서 사용할 수 없습니다.\n\n클래스 데코레이터의 표현식은 실행 시에 생성된 클래스의 생성자를 유일한 인수로하여 함수로 호출됩니다.\n\n클래스 데코레이터가 값을 반환하면 제공된 생성자 함수로 클래스 선언이 대체됩니다. \"새로운 생성자 함수를 반환하려면 원본 프로토 타입을 유지해야 합니다. 런타임에서 데코레이터를 적용하는 로직이 자동으로 처리해주지 않습니다.\"\n\n여기에는 클래스 데코레이터를 사용하여 created 속성을 설정하려는 예제가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n\n// 출력:\nJohn undefined\n```\n\n클래스 데코레이터를 사용한 예시\n\n```js\n@BaseEntity\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nfunction BaseEntity(ctr: Function) {\n  ctr.prototype.created = new Date().toISOString();\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n```\n\n## 2. 메소드 데코레이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메소드 데코레이터는 메소드 선언 바로 전에 선언됩니다. 데코레이터는 해당 메소드의 속성 설명자에 적용되며, 메소드 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일에서, 오버로드에서, 또는 기타 환경에서 (예: 선언 클래스 내) 사용할 수 없습니다. 이미 메소드 데코레이터 예제를 보았으므로 추가적인 자세한 내용은 다루지 않겠습니다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n여러분의 프로젝트 블랙핑크에 오신 것을 환영합니다!\n\n출력:\nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n## 3. 접근자 데코레이터\n\n접근자 데코레이터는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 해당 접근자의 속성 설명자에 적용되며, 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 기타 환경 (예: 선언 클래스 내)에서 사용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n액세서 데코레이터의 표현은 런타임에서 다음 세 가지 인수와 함께 함수로 호출될 것입니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 멤버의 속성 설명자(Property Descriptor).\n\n액세서 데코레이터가 값을 반환하면 해당 값은 멤버의 속성 설명자로 사용됩니다.\n\n다음은 Point 클래스의 멤버에 적용된 액세서 데코레이터 예시(@configurable)입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nclass Point {\n  private _x: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n}\n\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## 4. Property Decorators\n\n프로퍼티 데코레이터는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 환경(context)에서 사용할 수 없습니다(예: declare class 내에서).\n\n프로퍼티 데코레이터의 표현식은 런타임 시 함수로 호출되며 아래 두 인수를 전달받습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정적 멤버의 클래스 생성자 함수이거나 인스턴스 멤버의 클래스 프로토타입입니다.\n- 멤버의 이름입니다.\n\nTypeScript에서 속성 데코레이터의 예시를 제공합니다. 이 데코레이터는 속성의 값이 유효한 이메일 주소인지를 확인합니다:\n\n```js\n// 이메일 유효성 검사를 위한 속성 데코레이터\nfunction ValidateEmail(target: any, propertyKey: string) {\n  const privateFieldName = `_${propertyKey}`;\n\n  // 원래의 setter 메서드를 저장합니다.\n  const originalSetter = Object.getOwnPropertyDescriptor(target, propertyKey)?.set;\n\n  // 속성을 위한 새로운 setter를 정의합니다.\n  const newSetter = function (value: any) {\n    if (!isValidEmail(value)) {\n      throw new Error(`\"${propertyKey}\" 속성에 대한 유효하지 않은 이메일 주소입니다.`);\n    }\n    this[privateFieldName] = value;\n  };\n\n  // 속성의 setter 메서드를 대체합니다.\n  Object.defineProperty(target, propertyKey, {\n    set: newSetter,\n    get() {\n      return this[privateFieldName];\n    },\n    enumerable: true,\n    configurable: true,\n  });\n}\n\n// 이메일 주소 유효성을 검사하는 도우미 함수\nfunction isValidEmail(email: string): boolean {\n  // 간단한 이메일 유효성을 위한 정규 표현식\n  const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailPattern.test(email);\n}\n\nclass User {\n  @ValidateEmail\n  email: string = 'test@example.com';\n\n  constructor(email: string) {\n    this.email = email;\n  }\n}\n\nconst user = new User('john@example.com');\n\nconsole.log(user.email); // john@example.com\n\ntry {\n  user.email = 'invalid-email'; // 오류가 발생합니다.\n} catch (error) {\n  console.error(error.message); // \"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n}\n\n// 출력:\njohn@example.com\n\"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n```\n\n- 우리는 속성 데코레이터 ValidateEmail을 정의하여 할당된 값이 유효한 이메일 주소인지 확인합니다.\n- newSetter 함수는 제공된 값이 유효한 이메일 주소인지 확인합니다. 그렇지 않으면 오류를 발생합니다.\n- User 클래스의 email 속성에 @ValidateEmail 데코레이터를 적용합니다.\n- User의 인스턴스를 만들 때 email 속성을 유효한 이메일 주소로 설정하면 예상대로 작동합니다.\n- email 속성을 유효하지 않은 이메일 주소(예: `invalid-email`)로 설정하려고 하면 데코레이터가 유효하지 않은 이메일 주소임을 나타내는 오류를 throw합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 매개변수 데코레이터\n\n매개변수 데코레이터는 매개변수 선언 바로 전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자나 메서드 선언에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 ambient context(declare class 내에도)에서 사용할 수 없습니다.\n\n매개변수 데코레이터의 표현식은 런타임에 함수로 호출되며 다음 세 가지 인수와 함께 호출됩니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 함수의 매개변수 목록에서 매개변수의 순서 인덱스.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파라미터 데코레이터의 반환 값은 무시됩니다.\n\n다음은 간단한 정규 표현식을 사용하여 메서드 파라미터가 유효한 이메일 주소인지를 확인하는 파라미터 데코레이터의 예시입니다:\n\n```js\n// 이메일 유효성 검사를 위한 파라미터 데코레이터\nfunction ValidateEmail(target: any, methodName: string, parameterIndex: number) {\n  const originalMethod = target[methodName];\n\n  target[methodName] = function (...args: any[]) {\n    const paramValue = args[parameterIndex];\n\n    // 간단한 이메일 유효성을 위한 정규 표현식\n    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n    if (!emailPattern.test(paramValue)) {\n      throw new Error(`파라미터 인덱스 ${parameterIndex}의 유효하지 않은 이메일 주소가 제공되었습니다`);\n    }\n\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass ExampleClass {\n  // 이메일 파라미터를 검증하기 위해 파라미터 데코레이터를 적용\n  sendEmail(@ValidateEmail email: string) {\n    console.log(`${email}로 이메일을 보냅니다`);\n  }\n}\n\nconst exampleInstance = new ExampleClass();\n\n// 작동합니다\nexampleInstance.sendEmail(\"example@email.com\");\n\n// 이메일 유효성 검사로 오류가 발생합니다\ntry {\n  exampleInstance.sendEmail(\"invalid-email\");\n} catch (error) {\n  console.error(error.message); // 파라미터 인덱스 0에 유효하지 않은 이메일 주소가 제공되었습니다\n}\n```\n\n- ValidateEmail이라는 이름의 파라미터 데코레이터를 정의하고, 정규 표현식을 사용하여 제공된 파라미터가 유효한 이메일 주소인지 확인합니다.\n- sendEmail 메서드를 가진 ExampleClass 클래스를 만들고, email 파라미터를 검증하기 위해 @ValidateEmail 데코레이터를 적용합니다.\n- sendEmail 메서드를 호출할 때, 제공된 이메일 파라미터가 이메일 유효성 정규 표현식과 일치하는지 확인합니다. 일치하지 않으면 오류를 throw합니다.\n- 유효한 이메일로 한 번, 그리고 유효하지 않은 이메일을 주면 이메일 유효성 오류가 발생하는 두 가지 sendEmail 메서드 호출을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제는 메서드 매개변수의 간단한 이메일 유효성 검사를 수행하기 위해 매개변수 데코레이터를 사용하는 방법을 보여줍니다. 특정 요구 사항에 따라 정규 표현식을 조정하거나 필요에 따라 더 복잡한 이메일 유효성 검사 로직을 추가할 수 있습니다.\n\n## TypeScript의 데코레이터는 코드의 여러 부분을 수정하거나 동작을 추가하는 강력한 메커니즘을 제공합니다. 데코레이터의 일반적인 사용 사례는 다음과 같습니다:\n\n- 로깅 및 디버깅: 메서드 호출, 함수 매개변수 또는 속성 액세스를 기록하여 디버깅에 도움을 줄 수 있습니다.\n- 유효성 검사: 데코레이터는 입력 유효성 검사에 사용될 수 있으며, 함수 매개변수나 속성 값이 특정 기준이나 제약 조건을 충족하는지 확인할 수 있습니다.\n- 메모이제이션: 데코레이터를 사용하여 함수 결과를 캐시함으로써 입력 매개변수에 따라 함수를 캐싱하여 비용이 많이 드는 계산의 성능을 향상시킬 수 있습니다.\n- 인증 및 권한 부여: 데코레이터를 사용하여 웹 애플리케이션의 특정 메서드나 라우트에 액세스할 수 있는 전에 사용자 인증 또는 권한을 확인할 수 있습니다.\n- 의존성 주입: Angular과 같은 프레임워크에서 데코레이터를 사용하여 클래스나 컴포넌트에 주입할 서비스를 지정할 수 있습니다.\n- 라우트 처리 (웹 애플리케이션): Express.js 또는 Nest.js와 같은 웹 프레임워크에서 데코레이터를 사용하여 HTTP 엔드포인트의 라우트와 요청 핸들러를 정의할 수 있습니다.\n- 데이터 변환: 처리되기 전에 데이터를 변환하기 위해 데코레이터를 사용할 수 있습니다.\n- 캐싱: 데코레이터를 사용하여 데이터 검색 메서드를 캐싱함으로써 외부 데이터 소스에 부하를 줄일 수 있습니다.\n- 시간 측정 및 프로파일링: 함수의 실행 시간을 측정할 수 있습니다.\n- 로깅 프레임워크: 사용 사례에서 데코레이터는 특정 이벤트나 작업을 로깅하기 위해 메서드에 적용될 수 있습니다.\n- 유효성 검사 프레임워크: 데이터가 특정 규칙이나 제약 조건을 준수하는지 확인하기 위해 사용자 정의 유효성 검사 데코레이터를 생성할 수 있습니다.\n- 데이터베이스 매핑: Object-Relational Mapping (ORM) 라이브러리에서 데코레이터는 클래스 프로퍼티와 데이터베이스 열을 매핑하는 데 사용됩니다.\n- 속성 액세스 제어: 데코레이터를 사용하여 클래스 속성에 액세스 제어 정책을 강제할 수 있습니다.\n- 싱글톤 패턴: 데코레이터를 사용하여 싱글톤 디자인 패턴을 구현할 수 있습니다.\n- 사용자 지정 미들웨어: 웹 프레임워크에서 데코레이터는 메인 요청 핸들러 앞이나 뒤에서 실행될 사용자 정의 미들웨어 함수를 생성하는 데 사용될 수 있습니다.\n- 국제화와 지역화: 텍스트 속성이나 메서드에 데코레이터를 적용하여 언어 번역 및 지역화를 처리할 수 있습니다.\n- 오류 처리: 예외를 일관되게 처리하기 쉽게 하기 위해 중앙 집중식 오류 처리 논리를 데코레이터로 사용할 수 있습니다.\n- 이벤트 처리: 특정 이벤트에 대한 이벤트 리스너와 핸들러를 등록하는 데 사용될 수 있습니다.\n- 유형 확인 및 변환: 데이터가 예상된 유형과 형식에 맞는지 확인하기 위해 유형 확인 및 데이터 변환을 수행할 수 있습니다.\n- 사용자 정의 어노테이션: 클래스, 메서드 또는 속성에 대한 추가 정보를 제공하기 위한 사용자 지정 어노테이션 또는 메타데이터를 만들 수 있습니다.\n\n이것들은 TypeScript에서 데코레이터의 많은 사용 사례 중 일부에 불과합니다. 데코레이터는 클래스, 메서드 및 속성의 기능을 향상시키는 유연하고 확장 가능한 방법을 제공하여 코드를 더 모듈화되고 유지보수 가능하게 만듭니다.","ogImage":{"url":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png"},"coverImage":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png","tag":["Tech"],"readingTime":13},{"title":"TypeScript의 매핑된 타입 알아보기 기초부터 고급까지 8가지 예제","description":"","date":"2024-06-22 14:45","slug":"2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced","content":"\n\n**Mapped types**는 TypeScript에서 한 타입의 속성을 다른 타입으로 변환하는 강력한 도구입니다. 이것들은 `map` 및 `filter`와 같은 배열 메서드와 유사하지만, 이러한 작업은 타입에 대해 수행됩니다. 실용적인 예제를 통해 그 사용법을 이해할 것이고, 이어서 기초부터 고급까지 점진적으로 8가지 Mapped type 예제를 보여드릴 것입니다. 이를 통해 이 강력한 타입 변환 도구를 손쉽게 마스터할 수 있을 거예요.\n\n# I. 기초적인 타입 변환\n\nTypeScript에서 때로는 한 타입의 속성을 다른 타입으로 변환해야할 때가 있습니다. 이것은 Mapped types을 사용하여 쉽게 달성할 수 있습니다. 아래에서 한 Product 타입의 속성을 문자열 타입으로 변환하는 방법을 구체적인 예제를 통해 보여드겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 제품 유형 정의\n\n먼저, 세 가지 속성인 name(문자열 유형), price(숫자 유형), inStock(부울 유형)을 포함하는 Product 유형을 정의합니다.\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. ProductToString 유형 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 우리는 모든 Product 형식의 속성을 문자열 형식으로 변환하는 새로운 형식 ProductToString을 정의합니다.\n\n```js\ntype ProductToString = {\n    [Key in keyof Product]: string;\n};\n```\n\n## 3. 결과 형식\n\n마지막으로, 결과 ProductToString 형식은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\ntype ProductToString = {\n    name: string;\n    price: string;\n    inStock: string;\n};\n```\n\n## II. Making Type Properties Optional\n\nTypeScript에서 종종 유형의 모든 속성을 선택적으로 만들어야 합니다. 일반적으로는 내장된 Partial 유틸리티 유형을 사용하여 이것을 달성하지만, 매핑된 유형을 사용하여 동일한 효과를 얻을 수도 있습니다.\n\n### 1. 제품 유형 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. Use Mapped Types to Make Properties Optional\n\n```js\ntype ProductToOptional = {\n    [Key in keyof Product]?: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype ProductToOptional = {\n    name?: string;\n    price?: number;\n    inStock?: boolean;\n};\n```\n\n# III. Making Optional Properties Required\n\nIn TypeScript, sometimes we need to convert all optional properties of a type into required properties. This can be easily achieved using mapped types.\n\n## 1. Define Product Type\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n종류 Product = {\n    name?: string;\n    price?: number;\n    inStock?: boolean;\n};\n```\n\n## 2. ProductToRequired 유형 정의\n\n```js\n유형 ProductToRequired = {\n    [Key in keyof Product]-?: Product[Key];\n};\n```\n\n## 3. 결과 유형\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype ProductToRequired = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n# IV. Making Properties Read-Only\n\nIn TypeScript, sometimes we need to make all properties of a type read-only. This can be easily achieved using mapped types.\n\n## 1. Define Product Type\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## 2. Define ProductToReadonly Type\n\n```js\ntype ProductToReadonly = {\n    readonly [Key in keyof Product]: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype ProductToReadonly = {\n    readonly name: string;\n    readonly price: number;\n    readonly inStock: boolean;\n};\n```\n\n## V. Removing Certain Properties\n\nTypeScript에서 때로는 유형에서 특정 속성을 제거해야 하는 경우가 있습니다. 일반적으로 내장된 Omit 유틸리티 유형을 사용하여 이를 달성하지만, 매핑된 유형을 사용하여 동일한 효과를 얻을 수도 있습니다.\n\n### 1. Product 유형 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. Use Mapped Types to Remove Properties\n\n```js\ntype ProductWithoutPrice = {\n    [Key in keyof Product as Key extends 'price' ? never : Key]: Product[Key];\n};\n```\n\n## 3. Resulting Type\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n타입 ProductWithoutPrice = {\n    name: string;\n    inStock: boolean;\n};\n```\n\n# VI. 특정 속성 유형만 있는 유형 생성\n\nTypeScript에서 조건부 타입을 사용하여 특정 유형의 속성만 포함된 새로운 타입을 생성할 수 있습니다.\n\n## 1. 제품 유형 정의하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n    tags: string[];\n};\n```\n\n## 2. Define OnlyStringProperties Type\n\n```typescript\ntype OnlyStringProperties\u003cType\u003e = {\n    [Key in keyof Type as Type[Key] extends string ? Key : never]: Type[Key];\n};\n```\n\n## 3. Use OnlyStringProperties\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n유형 ProductOnlyStringProperties = OnlyStringProperties\u003cProduct\u003e;\n```\n\n## 4. 결과 유형\n\n```js\n유형 ProductOnlyStringProperties = {\n    이름: 문자열;\n};\n```\n\n# VII. 템플릿 리터럴 유형을 사용하여 새로운 속성 이름 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript에서는 템플릿 리터럴 타입을 사용하여 특정 접두사와 대문자로 시작하는 속성 이름을 가진 새로운 타입을 생성할 수 있습니다.\n\n## 1. 제품 타입 정의\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. 접두사가 포함된 속성을 가진 타입 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript에서는 템플릿 리터럴 타입을 사용하여 get로 접두사가 붙은 속성 이름을 가진 새로운 타입을 생성할 수 있어요.\n\n```js\ntype Getters\u003cType\u003e = {\n    [Key in keyof Type as `get${Capitalize\u003cstring \u0026 Key\u003e}`]: () =\u003e Type[Key];\n};\n```\n\n## 3. Getters 사용하기\n\n```js\ntype ProductGetters = Getters\u003cProduct\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4. 결과 타입\n\n```js\ntype ProductGetters = {\n    getName: () =\u003e string;\n    getPrice: () =\u003e number;\n    getInStock: () =\u003e boolean;\n};\n```\n\n# VIII. 조건에 따른 중첩 Mapped 타입\n\nTypeScript에서 Mapped 타입과 조건부 타입을 결합하여 더 복잡한 타입 변환 로직을 만들 수 있습니다. 예를 들어, 속성의 타입에 따라 다른 중첩 타입 구조를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 중첩된 객체 유형 정의\n\n먼저, 중첩된 객체를 포함한 다양한 유형의 속성을 포함하는 `NestedObject` 유형을 정의합니다.\n\n```js\ntype NestedObject = {\n    id: number;\n    name: string;\n    metadata: {\n        createdAt: Date;\n        updatedAt: Date;\n    };\n    tags: string[];\n};\n```\n\n## 2. DeepReadonly 유형 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 모든 속성을 읽기 전용으로 변환하는 DeepReadonly 타입을 정의합니다. 이는 중첩된 객체의 속성도 포함됩니다.\n\n```js\ntype DeepReadonly\u003cT\u003e = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly\u003cT[P]\u003e : T[P];\n};\n```\n\n이 정의에서 T[P] extends object은 속성 타입이 객체인지 확인하기 위해 사용됩니다. 만약 객체인 경우, DeepReadonly가 재귀적으로 적용되며, 그렇지 않은 경우 속성이 읽기 전용으로 설정됩니다. \n\n## 3. DeepReadonly 타입 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n딥 읽기 전용을 사용하여 NestedObject의 심층적으로 읽기 전용 버전인 ReadonlyNestedObject를 정의할 수 있습니다.\n\n```js\ntype ReadonlyNestedObject = DeepReadonly\u003cNestedObject\u003e;\n```\n\n## 4. 결과 타입\n\n마지막으로, 결과로 나오는 ReadonlyNestedObject 타입은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n유형 ReadonlyNestedObject = {\n    readonly id: number;\n    readonly name: string;\n    readonly metadata: {\n        readonly createdAt: Date;\n        readonly updatedAt: Date;\n    };\n    readonly tags: readonly string[];\n};\n```\n\n## 5. 사용 예시\n\n```js\nconst readonlyNestedObject: ReadonlyNestedObject = {\n    id: 1,\n    name: \"예시\",\n    metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date()\n    },\n    tags: [\"타입스크립트\", \"프로그래밍\"]\n};\n\n// readonlyNestedObject.id = 2; // 오류: 'id'는 읽기 전용 속성이기 때문에 할당할 수 없습니다.\n// readonlyNestedObject.metadata.createdAt = new Date(); // 오류: 'createdAt'는 읽기 전용 속성이기 때문에 할당할 수 없습니다.\n```\n\nTypeScript의 매핑된 유형은 다양한 복잡한 유형 변환을 달성할 수 있는 매우 강력한 기능입니다. 이를 사용하여 다음을 수행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 속성 변환: 타입 내 기존 속성의 유형을 변경합니다.\n- 속성 추가 또는 제거: 새로운 속성을 추가하거나 기존 속성을 제거합니다.\n- 옵션 및 읽기 전용 상태 제어: 속성을 옵션으로 만들거나 읽기 전용으로 설정합니다.\n- 동적 타입 생성: 조건형 타입과 템플릿 리터럴 타입을 사용하여 새로운 타입을 구성합니다. (예: 게터와 세터 생성과 같은 고급 시나리오에 적합)\n\nPartial, Readonly, Omit과 같은 내장 유틸리티 타입은 편리한 단축키를 제공하지만, 매핑된 타입은 타입에 대한 깊은 이해와 정밀한 제어를 제공합니다.\n\n이 기술을 더 잘 이해하고 코드를 더 깔끔하고 예측 가능하며 유지 보수가 쉬운 상태로 만들기를 바라며, 이 글이 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png","tag":["Tech"],"readingTime":7},{"title":"NestJS에서 DTO 쉽게 이해하기","description":"","date":"2024-06-22 14:44","slug":"2024-06-22-DTOexplainedinNestJS","content":"\n\nDTO(Data Transfer Object) 패턴은 어플리케이션의 서로 다른 레이어 간에 데이터를 전송하는 데 일반적으로 사용되는 설계 패턴입니다. DTO 패턴의 주요 아이디어는 데이터를 캡슐화하고 어플리케이션의 서로 다른 부분 간에 데이터를 전송하는 표준화된 방법을 제공하는 것입니다.\n\n실무에서 DTO는 데이터를 포함하고 일부 유효성 검사 로직을 갖는 간단한 객체입니다. Domain 객체의 일부 또는 전체 데이터를 정의하지만 비즈니스 로직은 포함하지 않습니다. 주로 클라이언트와 서버 간 또는 서버 측 어플리케이션의 서로 다른 레이어 간에 데이터를 전송하는 데 사용됩니다. DTO 객체는 일반적으로 서버 측 코드에서 생성되며 데이터베이스 또는 기타 소스에서 데이터로 채워진 후 클라이언트로 전송됩니다. 클라이언트 측 코드는 그 후 DTO 객체를 사용하여 데이터를 사용자에게 표시하거나 처리를 위해 서버로 보낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 사용법\n\nNestJS 애플리케이션에서 DTO를 사용하는 예제를 살펴보겠습니다:\n\n- DTO 클래스를 정의하세요:\n\n```js\nexport class CreateUserDto {\n  readonly name: string;\n  readonly email: string;\n  readonly password: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 당신의 DTO 클래스를 컨트롤러에서 사용하세요:\n\n```js\nimport { Controller, Post, Body } from ‘@nestjs/common’;\nimport { CreateUserDto } from ‘./create-user.dto’;\n@Controller('users')\nexport class UsersController {\n @Post()\n async create(@Body() createUserDto: CreateUserDto) {\n // 여기에 사용자 생성 로직을 작성하세요\n }\n}\n```\n\n# 적절한 사용법\n\nDTO는 서로 다른 도메인 객체에서 데이터를 구성하거나 도메인 객체의 일부 데이터만 가져오는 데 도움을 주도록 설계되었습니다. 또한 데이터 유효성 검사를 지원하거나 직렬화 논리의 캡슐화를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 DTO를 사용하여 데이터 일부만 사용하는 예시입니다:\n\n예를 들어, User 엔티티가 있다고 가정해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nclass User {\n id: number;\n name: string;\n email: string;\n password: string;\n}\r\n```\n\n저희는 사용자 작업을 처리할 수 있는 서비스를 가지고 있어요:\n\n```js\r\nclass UserService {\n // 데이터베이스에서 사용자 객체 가져오기\n getUserById(userId: number): User {\n // 데이터베이스에서 사용자 데이터 가져오기\n // …\n return user;\n }\n}\r\n```\n\n이제 이름과 이메일 필드만을 가진 사용자 프로필을 만들고 싶다면 DTO를 정의할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 사용자 데이터의 하위 집합을 나타내는 DTO 클래스를 정의합니다\nclass UserProfileDto {\n  name: string;\n  email: string;\n}\n```\n\n그런 다음 API 요청을 처리하는 컨트롤러를 정의합니다. 이 컨트롤러에서는 서비스를 사용하여 사용자 엔티티를 가져오고 사용자 프로필의 데이터 하위 집합을 나타내는 DTO(UserProfileDto)를 사용합니다:\n\n```js\n@Controller('users')\nclass UsersController {\n  constructor(private userService: UserService) {}\n\n  // 사용자 데이터의 하위 집합을 반환하는 API 엔드포인트를 정의합니다\n  @Get(':id/profile')\n  getUserProfile(@Param('id') userId: number): UserProfileDto {\n    const user = this.userService.getUserById(userId);\n\n    // 이름과 이메일 속성만 포함하는 DTO 객체를 생성합니다\n    const userProfileDto = new UserProfileDto();\n    userProfileDto.name = user.name;\n    userProfileDto.email = user.email;\n\n    // API 응답으로 DTO 객체를 반환합니다\n    return userProfileDto;\n  }\n}\n```\n\n또 다른 예시로 하나의 DTO를 통해 여러 도메인 객체를 구성하는 데도 DTO를 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 고객이 사용자의 최신 블로그 게시물을 요청한다면, 그리고 여러분은 다른 게시물 엔티티를 가지고 있다면:\n\n```js\nclass Post {\n  id: number;\n  title: string;\n  content: string;\n  userId: number;\n}\n```\n\n서비스가 필요합니다:\n\n```js\n// 사용자 및 게시물 작업을 처리하는 서비스 정의\nclass UserService {\n  // 데이터베이스에서 사용자 객체 및 최신 게시물을 가져오는 메서드\n  getUserWithLatestPost(userId: number): { user: User, latestPost: Post } {\n    // 데이터베이스에서 사용자 데이터 가져오기\n    // ...\n    \n    // 데이터베이스에서 사용자의 최신 게시물 데이터 가져오기\n    // ...\n\n    return { user, latestPost };\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 UserWithLatestPostDto를 만들 수 있습니다:\n\n```js\nclass UserWithLatestPostDto {\n  name: string;\n  email: string;\n  latestPostTitle: string;\n  latestPostContent: string;\n}\n```\n\n컨트롤러에서는 다음과 같을 것입니다:\n\n```js\n// API 요청을 처리하는 컨트롤러 정의\n@Controller('users')\nclass UsersController {\n  constructor(private userService: UserService) {}\n\n  // 사용자 데이터와 최신 포스트를 반환하는 API 엔드포인트 정의\n  @Get(':id/with-latest-post')\n  getUserWithLatestPost(@Param('id') userId: number): UserWithLatestPostDto {\n    const { user, latestPost } = this.userService.getUserWithLatestPost(userId);\n\n    // 사용자 데이터와 최신 포스트를 포함하는 DTO 객체 생성\n    const userWithLatestPostDto = new UserWithLatestPostDto();\n    userWithLatestPostDto.name = user.name;\n    userWithLatestPostDto.email = user.email;\n    userWithLatestPostDto.latestPostTitle = latestPost.title;\n    userWithLatestPostDto.latestPostContent = latestPost.content;\n\n    // API 응답으로 DTO 객체 반환\n    return userWithLatestPostDto;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 DTO는 API 호출 횟수를 줄이고, 클라이언트가 필요로 하는 데이터만 전송할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-22-DTOexplainedinNestJS_0.png"},"coverImage":"/assets/img/2024-06-22-DTOexplainedinNestJS_0.png","tag":["Tech"],"readingTime":5},{"title":"TypeScript NPM 패키지 배포 초보자 가이드","description":"","date":"2024-06-22 14:43","slug":"2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide","content":"\n\n![image](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_0.png)\n\n# NPM이란 무엇인가요?\n\nNPM (Node Package Manager)은 JavaScript 프로그래밍 언어의 기본 패키지 관리자입니다. NPM 레지스트리는 JavaScript 패키지를 저장하고 배포하는 중앙 허브로 작동하는 공개 저장소입니다. 이를 통해 개발자는 재사용 가능한 JavaScript 코드 패키지인 모듈 또는 패키지를 쉽게 설치, 관리 및 공유할 수 있습니다.\n\n## TypeScript은 무엇이며 왜 사용해야 하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript은 Microsoft에서 개발한 프로그래밍 언어입니다. 이는 JavaScript의 상위 집합으로, 모든 유효한 JavaScript 코드가 TypeScript 코드로도 유효하다는 것을 의미합니다. 이는 다음을 제공하여 일반 JavaScript에 비해 이점을 제공합니다:\n\n- 정적 유형\n- 향상된 IDE 지원\n- 향상된 코드 품질\n- 고급 언어 기능 액세스\n- 더 나은 툴링\n- 향상된 협업\n\n이러한 이점은 NPM 패키지의 개발 경험을 향상시키며, 패키지 사용자들이 프로젝트에 이를 소비하고 통합하기 쉽게 만들어보다 신뢰할 수 있고 확장 가능하며 유지 관리하기 쉬운 JavaScript 응용 프로그램을 만듭니다.\n\n이 기사에서는 TypeScript로 자신의 NPM 패키지를 생성하고 NPM 레지스트리에 게시하는 방법을 배울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Typescript 프로젝트 설정하기\n\n- 로컬 머신에 새 프로젝트 디렉토리를 만듭니다.\n- 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동합니다.\n- 다음 명령을 실행하여 새 Node.js 프로젝트를 초기화합니다. `npm init`을 입력하고 화면 안내에 따릅니다.\n\n![이미지](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_1.png)\n\n- 첫 번째 필드는 패키지 이름이며, 이는 패키지를 위한 고유한 이름이어야 합니다. NPM 레지스트리를 확인하여 이름이 사용 가능한지 확인할 수 있습니다. 이름을 사용할 수 있다면 Enter를 눌러 다음으로 넘어갈 수 있습니다. 이 경우 `npm-demo-ts`이(가) 사용 가능했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```html\n![image](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_2.png)\n\n- The next field is the version, and the default value is 1.0.0. Package versions generally use Semantic Versioning.\n\n## What is Semantic Versioning?\n\nIt provides a standard way to convey the compatibility and changes in a package across different releases. It consists of three numerical components: Major version, Minor version, and Patch version, represented as MAJOR.MINOR.PATCH, for example, 1.0.7\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 주 버전 증가: 호환되지 않는 변경 사항을 도입합니다.\n- 부 버전 증가: 역호환성을 유지하면서 새로운 기능을 추가합니다.\n- 패치 버전 증가: 역호환성 버그 수정 또는 소량 업데이트를 수행합니다.\n\n의미 있는 버전 관리 방침을 준수하고 버전 제약 조건을 사용하여 개발자는 종속성을 효과적으로 관리하고 호환성을 보장하며 NPM 패키지의 업데이트 영향을 사용자와 사용자에게 전달할 수 있습니다.\n\n- 다음 필드는 description입니다. 여기에는 NPM 패키지의 기능에 대한 간단한 설명을 포함해야 합니다.\n- 다음 필드는 entry point입니다. 이는 다른 모듈에 의해 가져올 때 실행되는 주 Javascript 파일을 가리킵니다. 현재는 기본 설정을 유지하실 수 있습니다.\n- 다음 필드는 test command입니다. 패키지의 테스트를 실행하는 데 사용되는 명령어나 스크립트입니다. 현재는 기본 설정을 유지하실 수 있습니다.\n- 다음 필드는 git repository입니다. 이는 원격 Git 리포지토리로의 링크를 포함해야 합니다.\n- 다음 필드는 keywords입니다. 패키지와 관련된 단어를 포함하여 NPM 레지스트리에서 색인에 도움이 되는 내용이어야 합니다.\n- 다음 필드는 author입니다. 패키지 저자의 이름입니다.\n- 마지막으로 license 필드에는 오픈 소스 라이센스를 포함해야 합니다. 자세한 내용은 여기를 읽어보시거나 현재는 기본 설정을 유지하실 수 있습니다.\n- 이후 모든 답변에 대한 요약이 생성됩니다. 아래 이미지와 유사하게 보여야 하며, 여러분의 답변으로 채워져 있어야 합니다. 엔터를 눌러 진행하세요.\n\n![image](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 패키지 종속성을 설치하려면 다음 명령어를 실행하세요: npm install --save-dev typescript ts-node (npm 사용자) 또는 yarn add -D typescript ts-node (yarn 사용자)\n- tsconfig.json을 설정하려면 다음 명령어를 실행하세요: npx tsc --init, 프로젝트의 기본 디렉터리에 tsconfig 파일이 생성됩니다. outDir 필드를 \"dist\"로 업데이트하세요.\n- src 폴더를 생성하고 index.ts 파일을 만들어 아래 코드를 붙여넣으세요. 이 코드는 두 숫자를 더하는 간단한 함수입니다.\n\n```js\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nconsole.log(add(3, 5)); //결과: 8\n```\n\n- 다음 명령어로 코드를 실행하세요: npx ts-node src/index, 콘솔에서 결과값인 8을 볼 수 있어야 합니다. 그 후 코드에서 console.log 줄을 삭제하세요.\n- git init으로 깃 레포를 초기화하세요.\n- .gitignore 파일을 생성하고 다음을 파일에 붙여넣으세요.\n\n```js\n/node_modules\n\n# 테스트 관련 파일 무시\n/coverage.data\n/coverage/\n\n# 빌드 파일\n/dist\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- README.md 파일을 만들어 프로젝트에 대한 설명과 사용 방법을 포함하는 것도 좋은 아이디어입니다.\n\n# TypeScript 패키지 빌드\n\n이제 패키지 코드 작성을 완료했으니, 사용자가 여러 JavaScript 또는 TypeScript 프로젝트에서 소비할 수 있게 패키지를 빌드하는 방법을 살펴보겠습니다.\n\ntsup, babel, webpack, rollup 등 다양한 전용 빌드 도구가 있어 이 프로세스를 돕는데 도움이 됩니다. 이 글에서는 tsup에 초점을 맞출 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Tsup 설정하기\n\n- 다음 명령어를 실행하여 프로젝트에 tsup을 추가하세요.\n  \n  npm install tsup -D\n  \n  또는\n  \n  yarn add tsup --dev\n  \n\n- 아래 코드를 붙여넣어서 `yourtsup.config.ts` 파일을 생성하세요.\n\n```js\nimport { defineConfig } from \"tsup\";\n\nexport default defineConfig({\n  entry: [\"src/index.ts\"],\n  format: [\"cjs\", \"esm\"], // commonJS 및 ESmodules용으로 빌드합니다\n  dts: true, // 선언 파일 (.d.ts) 생성\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n});\n```\n\n- package.json 에서 스크립트를 업데이트하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n  },\r\n```\n\n- npm run build 또는 yarn build로 프로젝트를 빌드할 수 있습니다.\n- package.json의 main을 업데이트하고 다음을 추가하세요:\n\n```js\r\n...\n\"main\": \"./dist/index.js\",\n\"module\": \"./dist/index.mjs\",\n\"types\": \"./dist/index.d.ts\",\n\"files\": [\n    \"dist\"\n ],\n...\r\n```\n\n- 이제 패키지를 출판할 준비가 모두 끝났지만, 그 전에 계획대로 모든 것이 작동하는지 확인하기 위해 패키지를 테스트해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 당신의 NPM 패키지를 테스트해 봅니다\n\n테스트를 통해 사용자에게 도달하기 전에 어떤 문제나 버그가 있는지 확인하고 해결할 수 있습니다. 당신의 npm 패키지를 테스트하기 위해 Jest를 설정해야 합니다.\n\n## Jest 설정하기\n\n- 다음 명령어를 실행하여 프로젝트에 jest를 추가합니다\nnpm install -D jest ts-jest @types/jest or yarn add -D jest ts-jest @types/jest\n- 프로젝트에 jest.config.js 파일을 추가하고 다음 코드를 복사하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodule.exports = {\n  preset: \"ts-jest\",\n  testEnvironment: \"node\",\n};\n```\n\n- 프로젝트 내에 tests 폴더를 생성하고 add.test.ts 파일을 생성하여 다음 테스트를 추가해주세요.\n\n```js\nimport { add } from '../src';\n\ntest('두 숫자를 정확히 더합니다', () =\u003e {\n  const result = add(2, 3);\n  expect(result).toBe(5);\n});\n```\n\n- 다음 스크립트를 포함하여 package.json 파일을 업데이트해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n\"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"jest\"\n },\n```\n\n- 테스트 스크립트를 다음 명령어로 실행하세요: npm run test 또는 yarn test . 결과는 아래 이미지와 같아야 합니다.\n\n![image](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_4.png)\n\n이제 당신은 npm 패키지를 성공적으로 작성하고 테스트했습니다. 이제 NPM 패키지를 게시하는 방법으로 넘어가 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# NPM 패키지를 게시하는 방법\n\n마지막으로, NPM 레지스트리에 패키지를 게시하기 전에 로컬 머신에서 패키지를 게시하고 테스트하는 것이 중요합니다. 이는 패키지의 정확성, 기능 및 다른 모듈 또는 종속성과의 호환성을 확인하기 위한 것입니다. 로컬 테스트를 통해 어떤 문제나 버그도 조기에 발견하여 필요한 개선을 하고 패키지를 공개하기 전에 준비할 수 있습니다.\n\n## 로컬로 NPM 패키지를 게시하는 방법\n\n- 패키지의 루트 디렉터리에서 다음 명령어를 실행하세요\nnpm link\n- 다른 테스트 프로젝트를 만들고 npm 패키지를 로컬로 연결하세요\n이 경우 npm link npm-demo-ts처럼 npm link name-of-package명령어를 사용하세요\n- 테스트 프로젝트에 main.ts 파일을 만들고 패키지를 가져와서 테스트하세요. 또한 TypeScript의 많은 혜택 중 하나인 프로젝트에 타입 정보를 입력하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_5.png\" /\u003e\n\n- 이제 로컬에서 테스트를 완료했으니, 레지스트리에 발행해 봅시다.\n\n## NPM 패키지를 NPM 레지스트리에 발행하기\n\n- 이미 없는 경우 NPM에서 계정을 만듭니다.\n- 터미널에서 NPM 계정에 로그인합니다.\nnpm login\n- 사용자 이름, 암호, 이메일 및 OTP를 입력합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Screenshot 6](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_6.png)\n\n- npm publish 명령어로 패키지를 배포하세요\n\n![Screenshot 7](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_7.png)\n\n![Screenshot 8](/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nTypeScript을 사용하여 패키지를 개발하고 사용하면 다양한 이점을 누릴 수 있습니다. 정적 타이핑은 개발자에게 코드 품질 향상, 초기 오류 감지, 향상된 편집기 지원을 제공합니다. TypeScript의 타입 정의는 더 나은 문서화와 패키지 API의 이해도 향상을 가능하게 하며, 연동을 원활하게 하고 소비자의 잠재적인 버그를 줄이는 데 도움이 됩니다. 또한 TypeScript의 생태계는 다양한 라이브러리, 도구 및 리소스를 자랑하여 협업 및 커뮤니티 지원을 촉진합니다.\n\n첫 번째 TypeScript NPM 패키지를 발행함으로써 이러한 장점을 누르는 뿐만 아니라 TypeScript 생태계의 성장과 풍요로워짐에 기여할 수 있습니다. 활기찬 커뮤니티에 참여하여 지식과 전문성을 공유하고 JavaScript 개발 세계에 오랜 영향을 끼치세요.\n\n읽어주셔서 감사합니다! 더 많은 튜토리얼을 위해 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-22-TypeScriptNPMPackagePublishingABeginnersGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"Angular에서 존리스zoneless 미래에 대비하는 방법","description":"","date":"2024-06-22 14:41","slug":"2024-06-22-HowtogetreadyforzonelessfutureinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png\" /\u003e\n\nAngular 18은 zone.js를 기반으로 한 기존 버전보다 더 효율적인 zoneless change detection을 실험적으로 지원합니다.\n\n이 기능에 대한 자세한 내용은 아래 링크를 참조하세요 👇\n\n새 프로젝트를 시작하면 zoneless 옵션을 쉽게 선택할 수 있습니다. 하지만 기존 애플리케이션에 이 기능을 통합하는 것은 간단하지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그 포스트에서는 Angular의 무존재(zonless) 미래에 대비할 수 있는 두 가지 간단한 단계에 대해 이야기하겠습니다.\n\n무존재 변경 감지(zoneless change detection)를 수용하는 새로운 기능을 생성하는 프로세스를 수립하는 것이 바람직합니다. 상세한 설명이 필요한 경우가 있겠지만, 코드가 OnPush 변경 감지 전략과 함께 작동한다면 무존재 변경 감지와 호환될 것으로 가정할 수 있습니다.\n\n자세한 내용은 여기에서 확인하실 수 있습니다 👇\n\n이 패턴을 구현하려면 두 가지 조치를 취할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- angular.json (nx.json) 파일에서 기본 변경 감지 전략을 수정하십시오:\n\n```js\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"ng-18-playground\": {\n      \"projectType\": \"application\",\n      \"schematics\": {\n        \"@schematics/angular:component\": {\n          \"changeDetection\": \"OnPush\"\n        }\n      }\n      \n      ...\n    }\n  }\n}\n```\n\n2. OnPush 변경 감지를 강제하는 ESLint 규칙을 추가하십시오:\n\n```js\n// @ts-check\nconst eslint = require(\"@eslint/js\");\nconst tseslint = require(\"typescript-eslint\");\nconst angular = require(\"angular-eslint\");\n\nmodule.exports = tseslint.config(\n  {\n    files: [\"**/*.ts\"],\n    extends: [\n      eslint.configs.recommended,\n      ...tseslint.configs.recommended,\n      ...tseslint.configs.stylistic,\n      ...angular.configs.tsRecommended,\n    ],\n    processor: angular.processInlineTemplates,\n    rules: {\n      \"@angular-eslint/prefer-on-push-component-change-detection\": [\"warn|error\"],\n    },\n  }\n  ...\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx를 사용하면 특정 프로젝트에 대해 규칙을 설정할 수 있습니다. 이 기능을 사용하면 새 프로젝트에 대해 오류로 심각도 수준을 지정할 수 있습니다. 기존 프로젝트는 리팩터링을 통해 존이 없는 변경 감지로 준수할 때까지 경고를 유지할 수 있습니다.\n\n존이 없는 변경 감지는 실험적인 기능이지만, 새 기능을 개발할 때 고려해 두는 것이 좋습니다. 이렇게 하면 나중에 존.js 없이 쉽게 theworld로 전환할 수 있습니다.\n\n제 블로그 글이 마음에 들었으면 좋겠어요. 읽어 주셔서 감사합니다! 🙂","ogImage":{"url":"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png","tag":["Tech"],"readingTime":2},{"title":"React Query v5로 데이터 가져오기 및 변경하기 변화를 쉽게 처리하는 방법","description":"","date":"2024-06-22 14:40","slug":"2024-06-22-FecthingandMutationwithReactQueryv5","content":"\n\n# React-Query이란 무엇인가요?\n\nReact-Query는 React 애플리케이션에서 데이터 가져오기와 상태 관리를 간편하게 해주는 강력한 라이브러리입니다.\n\n- React Query는 React 애플리케이션에서 원격 데이터를 관리하기 위한 포괄적인 솔루션입니다. 기존의 데이터 가져오기와 상태 관리 방법의 복잡성을 추상화한 일련의 훅과 API를 제공합니다.\n- React Query를 사용하면 개발자들은 일반적으로 로딩 상태, 오류 처리 및 데이터 캐싱을 관리하기 위해 필요한 번거로운 코드를 처리하지 않고 API에서 데이터를 쉽게 가져오고 캐시하며 업데이트할 수 있습니다.\n\n# 왜 좋은 선택인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 소개에서 React Query가 많은 복잡성을 간소화하는 데 도움이 되는 유용한 훅과 방법을 제공한다는 것을 알 수 있었습니다. 또한 데이터 캐싱을 관리합니다.\n\n- React Query의 지능적인 캐싱 시스템은 데이터의 수명주기를 자동으로 관리하여 관련 정보가 컴포넌트에서 쉽게 사용할 수 있도록 합니다.\n- 이 라이브러리는 로딩 상태와 오류 처리를 처리하는 내장 지원을 제공하여 로딩 스피너, 오류 메시지 및 재시도 메커니즘과 같은 적절한 UI 요소를 사용자에게 쉽게 표시할 수 있도록 합니다.\n- 이러한 하위 수준의 문제를 추상화함으로써 React Query는 개발자가 반복적인 데이터 관리 작업에 갇히지 않고 응용 프로그램의 핵심 기능을 구축하는 데 초점을 맞추도록 돕습니다.\n\nReact query 설치\n\n```js\nnpm i @tanstack/react-query\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 쿼리를 사용하는 데 중요한 3가지 핵심 개념이 있습니다:\n\n1- 쿼리.\n2- 뮤테이션.\n3- 쿼리 무효화.\n\n쿼리\n\n- React Query의 쿼리는 API 엔드포인트와 같은 원격 소스에서 데이터를 가져오는 과정을 의미합니다.\n- 개발자는 React Query에서 제공하는 useQuery 훅을 사용하여 이러한 데이터 가져오기 작업을 정의하고 관리합니다.\n- useQuery 훅은 고유한 쿼리 키와 데이터 가져오기 함수를 인수로 사용합니다.\n- 훅은 가져온 데이터, 로딩 상태, 오류 상태 및 데이터 가져오기 라이프사이클을 관리하는 데 사용할 수 있는 다양한 속성이 포함된 객체를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 클라이언트 생성\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // 앱에 클라이언트 제공\n    \u003cQueryClientProvider client={queryClient}\u003e\n      \u003cTodos /\u003e\n    \u003c/QueryClientProvider\u003e\n  )\n}\n```\n\n```js\nfunction Todos() {\n  // 클라이언트에 접근\n  const queryClient = useQueryClient()\n\n  // 쿼리\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n  // 뮤테이션\n  const mutation = useMutation({\n    mutationFn: postTodo,\n    onSuccess: () =\u003e {\n      // 갱신 및 새로고침\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n}\n```\n\n위의 코드에서 먼저 App 구성 요소에서 queryClient를 생성한 후 useQueryClient 훅을 사용하여 클라이언트에 액세스합니다. 그런 다음 useQuery를 사용하여 쿼리를 정의합니다. 앞에서 말했듯이 query key는 쿼리에 다른 구성 요소에서 사용할 수 있는 식별자를 제공하고 query function queryFn은 데이터를 가져오는데 책임이 있는 함수입니다.\n\n변이와 쿼리 무효화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- React Query에서 변이(Mutations)는 서버에서 데이터를 업데이트, 생성 또는 삭제하는 과정을 의미합니다.\n- 개발자들은 React Query에서 제공하는 useMutation 훅을 사용하여 이러한 데이터 업데이트 작업을 정의하고 관리합니다.\n- useQuery와 유사하게, useMutation은 데이터 업데이트와 관련된 로딩 및 오류 상태를 관리하는 복잡성을 다룹니다.\n\n변이와 함께 사용되는 Query 무효화(Invalidation)는 서버 측에서 업데이트한 최신 데이터로 캐시를 업데이트하는 것을 의미합니다.\n\n```js\nfunction Todos() {\n  // 클라이언트에 액세스\n  const queryClient = useQueryClient()\n\n  // 쿼리\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n  // 변이\n  const mutation = useMutation({\n    mutationFn: postTodo,\n    onSuccess: () =\u003e {\n      // 무효화하고 다시 가져오기\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\n  return (\n    \u003cdiv\u003e\n      \u003cul\u003e{query.data?.map((todo) =\u003e \u003cli key={todo.id}\u003e{todo.title}\u003c/li\u003e)}\u003c/ul\u003e\n\n      \u003cbutton\n        onClick={() =\u003e {\n          mutation.mutate({\n            id: Date.now(),\n            title: 'Do Laundry',\n          })\n        }\n      \u003e\n        할 일 추가\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\nuseMutation 훅은 객체를 전달하여 정의되며, 주요 키인 mutationFn으로는 서버 측에서 업데이트 또는 삭제를 처리하는 함수가 포함되어 있으며, 성공 처리기인 onSuccess로는 함수에서 받은 데이터를 수락하고 invalidateQueries를 사용하여 캐시를 업데이트할 수 있습니다. 이때, 이전 캐시에 액세스하고 원하는 데이터를 적용할 수 있는 쿼리 이름을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, react-query 메인 문서를 이곳에서 더 자세히 살펴볼 수 있습니다. 유용했기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-22-FecthingandMutationwithReactQueryv5_0.png"},"coverImage":"/assets/img/2024-06-22-FecthingandMutationwithReactQueryv5_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript로 NextJS 아키텍처 마스터하기  2024 디자인 추상화 방법","description":"","date":"2024-06-22 14:39","slug":"2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_0.png\" /\u003e\n\nNext.js는 React 애플리케이션을 구축하기 위한 강력한 프레임워크이며 TypeScript와 결합하면 견고한 타입 체크 및 도구가 제공되어 개발 경험을 크게 향상시킬 수 있습니다.\n\n저는 몇 년 동안 Next.js를 사용해왔는데, 대규모 웹 앱을 개발할 때 Create React App과 비교해도 우수한 도구라고 생각합니다.\n\n이 글을 읽으시면서 GitHub 프로젝트 링크를 남겨두었으니 걱정 말고 이 링크로 들어가서 포크하고 놀아보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/BiosBoy/my-social-app\n\n지난 몇 년 동안 NextJS는 내부에서 추상화를 확장하는 정도만큼 진화해 왔어요. 여러 앱을 만드는 동안 가장 가치 있는 점은 코드를 적절히 추상화하는 방법이었습니다.\n\n\"Hello World\" 앱을 만드는 방법에 대한 설명서를 찾는 것은 그리 어렵지 않죠. 설명이 잘 되어 있을지라도 이러한 종류의 이야기에서 가장 큰 병목 현상은 실제로 작업을 시작해야 할 때 발생할 수 있어요.\n\nNextJS 앱을 빌드하도록 요청 받으면 인증, 다양한 API, 서비스, 데이터 구조를 포함한 실제 세계의 작업과는 \"Hello World\"에서와는 아예 다른 일이라는 것을 깨달을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 TypeScript와 함께 Next.js 프로젝트를 설정하고, 내비게이션 처리, 회원가입/로그인/로그아웃 관리, 그리고 SVG 자산을 효과적으로 다루는 방법에 대해 안내할 것입니다. 이 모든 것은 실제로 제품에 사용할 수 있는 방식으로 설명될 것이에요.\n\n# 준비물\n\n그래서 이 이야기에서는 풀스택 소셜 읽기 클럽 앱을 복제하려고 할 것입니다. 백엔드 부분에는 다루지 않을 것이지만, 브라우저의 LocalStorage와 SessionStorage를 사용하여 마치 백엔드를 사용하는 것처럼 속이도록 할 것입니다.\n\n그래서 백엔드를 따로 준비해야 할 때에는 Rails를 나중에 nodeJS + MongoDB/PostgresDB로 쉽게 전환할 수 있을 것입니다. 어쨌든, 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 경우를 상상해보면 요청된대로 다음을 수행해야 합니다:\n- 필요한 페이지 생성: /, /feed, /signup, /signin, /signout, /:username, /friends.\n- 반응형 디자인을 염두에 두고 내비게이션 메뉴 생성.\n- 사용자 인증/로그아웃 흐름 통합하여 내부 소셜 데이터를 노출하지 않도록 함.\n- 사용자 게시물 및 친구 목록 관리를 위한 CRUD 작업 추가.\n- 앱을 기본 색 테마와 전체적인 스타일링으로 꾸미기.\n\n상당히 간단하게 보이나요? 실제로도 그런 것 같네요. 아주 복잡한 예제에 집중할 필요는 없으니까 아키텍처 설계에 실제적인 접근을 해보죠. 위 요구 사항 집합이 실제 앱에서 다뤄야 할 것들입니다, 그래서 마스터하기 위해 노력해봅시다.\n\n# TypeScript으로 Next.js 프로젝트 설정하기\n\n먼저, TypeScript와 함께 새 Next.js 프로젝트를 초기화해보죠. 터미널을 열고 다음 명령어를 실행하여 새 Next.js 프로젝트를 생성하고 프로젝트 디렉토리로 이동하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx create-next-app@latest my-nextjs-app --typescript\ncd my-nextjs-app\n```\n\n여기에 따라, NextJS 프레임워크를 초기화하고 그 안에 TypeScript를 추가하게 될 거야. 이것은 우리의 향후 애플리케이션을 개발하기 위한 스타터 킷 환경을 만들어 줄 거야.\n\npackage.json이나 tsconfig.json 파일들은 기본적으로 제공되기 때문에 이 파일들에 대한 정보는 인터넷을 통해 쉽게 찾을 수 있어요. 따라서 이미 이 파일들이 어떻게 작동하는지 알고 있다고 가정해볼게요.\n\n이제 아키텍처로 들어가 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱 아키텍처 디자인\n\n그래서, 이 이야기의 맨 처음 단계는 올바른 폴더 구조를 선택하는 것입니다.\n\n일부 폴더(예: /pages)는 기본적으로 정의되어 있지만, 우리는 나머지 필요한 항목을 직접 설계해야 합니다. 그러나 지금은 먼저 페이지에 대해 논의해 봅시다.\n\n## 📁 ./app\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNextJS의 핵심 폴더입니다. 대부분의 경우 가능한 한 간단하게 유지할 수 있습니다. 대부분의 시간에는 핵심 로직을 설정하고 싶어하는 곳입니다.\n\n![image](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_1.png)\n\nfavicon.ico — 브라우저 탭의 시각적 디자인을 위한 .ico 기반 파일입니다.\n\nlayout.tsx — 내부 NextJS 애플리케이션으로, SSR 또는 SSG 렌더링을 위한 진입점으로 사용됩니다. 하지만, 우리의 경우는 현재 CSR에 초점을 맞추고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 📁 ./pages\n\n기본적으로 NextJS는 페이지 개발을 위한 멋진 추상화를 제공합니다. 필요한 페이지만 해당 폴더에 채우면 됩니다.\n\n따라서 우리의 디자인은 다음과 같습니다:\n\n![NextJS Architecture](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n_app.tsx은 NextJS 프로젝트의 주요 진입점입니다. 전체 애플리케이션을 포함하여 실행 중에 서버에서 사용될 것입니다.\n\nfeed/friends/home/signin/signout/signup.tsx은 동적 동작 없이 화면에 표시해야 하는 페이지를 나타내는 정적 페이지입니다.\n\n[username].tsx은 “동적 동작”이라고 부르는 것입니다. 좀 더 복잡한 앱 로직이 있는 경우, 사용자 ID나 다른 동적 값이 있는 정적 페이지에서 동적 콘텐츠를 표시하고 싶어할 것입니다.\n\n## 📁 ./components\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서는 앱의 재사용 가능한 각 구성 요소를 저장할 수 있습니다. 여러 영역/페이지에서 사용할 수 있는 것들에게 가장 적합한 장소입니다.\n\n![마스터링 Next.js 아키텍처와 TypeScript를 떠올리며 디자인 추상화 2024_3](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_3.png)\n\nAddPostModal.tsx — 나중에 우리 앱에서 사용할 것으로, 사용자가 요청에 따라 새 게시물을 추가할 수 있는 기능을 제공합니다.\n\nHeader.tsx — 웹 앱 디자인에서 핵심적인 역할을 할 재사용 가능한 헤더입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavBar.tsx는 앱 내에서 탐색을 표현할 수 있는 또 다른 재사용 가능한 컴포넌트입니다.\n\n## 📁 ./auth\n\n이 폴더는 앱의 핵심 로직을 포함하며 사용자가 로그인했는지 여부를 확인하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`AuthContext.tsx` 파일에는 사용자의 인증 정보가 저장됩니다. 사용자가 시스템에 로그인한 후에 사용자의 정적 데이터를 관리하기 위해 React Context를 사용할 것입니다.\n\n`withAuth.tsx` 파일은 앱 전체에 사용자 데이터를 공유하는 데 도움이 되는 HOC 함수입니다.\n\n## 📁 ./api\n\n앱의 다른 레이어(표현/비즈니스 등)와 작업할 때 서로를 혼동하지 않는 것이 항상 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 API 관련 코드를 별도의 폴더로 이동하는 것이 좋은 실천 방법입니다.\n\n![마스터링 Next.js 아키텍처와 TypeScript로 설계 추상화](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_5.png)\n\ngetCurrentUser.ts — SessionStorage에서 로그인한 사용자 데이터를 검색하는 GET 요청입니다.\n\ngetPosts.ts — 사용자가 게시한 사용 가능한 게시물을 검색하는 GET 요청입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngetUsers.ts - 시스템에 등록된 모든 사용자를 검색하기 위한 GET 요청입니다.\n\nsetCurrentUser.ts - 사용자가 성공적으로 로그인/가입한 후 사용자 데이터를 설정하기 위한 POST 요청입니다.\n\nsetUsers/setPosts.ts - 앱 초기화를 위해 LocalStorage에 데이터를 채우기 위한 POST 요청입니다.\n\n## 📁 ./hooks\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact의 세계에서 (특히 훅에 대해 말할 때) UI 로직과 비즈니스 로직을 섞지 않는 것이 항상 가장 좋은 실천법입니다. 구성 요소를 설계할 때 항상 UI 레이어를 가능한 한 단순하게 유지하는 방법을 생각해 보세요.\n\n이 경우에는 비동기 요청 중 하나를 분할하여 자체 캡슐화된 범위에 넣어 UI 구성 요소를 작고 깨끗하게 유지할 수 있습니다.\n\n![image](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_6.png)\n\nuseDataInitialize.ts — 앱 실행을 위해 목 데이터 세트를 초기화하는 주요 파일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nusePosts/useFriends.ts — 이 훅들을 사용하면 우리는 친구/게시물 API 응답을 캡슐화된 방식으로 검색할 수 있게 될 거에요.\n\nuseSignup/useSignin/useSignout.ts — 이 훅들은 사용자 인증 플로우를 기능적으로 관리하는 데 도움이 될 거에요.\n\n## 📁 ./helpers\n\n여기 우리 사용자 정의 작업에 대해 도와줄 귀여운 녀석이 있어요. 이 폴더에는 데이터 무작위화와 같은 특정 사용 사례에만 사용되는 몇 가지 항목을 넣는 것이 항상 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_7.png\" /\u003e\n\ndataRandomizer.ts — 이 파일은 앱을 랜덤한 게시물/사용자 데이터로 채우는 주요 도우미입니다.\n\n## 📁 ./utils\n\n이 폴더는 앱 전체에서 여러 차례 유용하고 재사용 가능한 것들을 결합하여 앱의 재사용성을 높이는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_8.png\" /\u003e\n\nsortByDate.ts - 특정 타임스탬프별로 데이터 배열을 정렬하는 데 도움을 주는 파일입니다.\n\n## 📁 ./interfaces\n\nTypeScript를 언급할 때는 종종 타입과 인터페이스를 다루어야 합니다. 일반적인 Hello World 앱의 경우, 이들은 코드 안에 자연스럽게 위치해야 하는 아주 작은 부분이어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 실제 앱에서는 이것들을 분리하므로 라인 수는 그렇지 않으면 많아질 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_9.png)\n\ndata.ts — 데이터 구조를 위한 인터페이스들입니다. 현재 하나만 있지만 미래에는 더 많아질 것입니다.\n\n## 📁 ./static\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작은 폴더는 앱 안에 포함하고 싶은 아이콘/이미지/gif/비디오 등과 같은 정적 데이터를 나타냅니다.\n\n`\u003cimg src=\"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_10.png\" /\u003e`\n\nlogo.svg — 메인 앱 로고.\n\n## 📁 ./styles\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 유명한 스타일 폴더입니다. CSS 모듈을 사용하여 코드를 격리하고 반복하지 않도록 권장합니다. 그럼에도 불구하고 일부 코드는 중앙에 유지되어 전체 사이트에서 초기화해야 합니다. 이러한 것들을 저장하는 장소가 이곳이며 globals/등이 있습니다.\n\n![MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_11](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_11.png)\n\nglobal.css — 앱의 핵심 공유 스타일.\n\n# 핵심 아키텍처 원칙\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아, 이제 앱 아키텍처를 설계하는 데 문제가 없네요. 이제 우리는 코드 재사용성과 유지 관리에 대해 더 많이 집중할 수 있어요.\n\n## 느슨한 결합, 높은 응집도\n\n![마스터링 Next.js 아키텍처 및 TypeScript로 디자인하는 추상화(2024년 06월 22일)](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_12.png)\n\n응집도(cohesion)는 모듈/클래스 요소들이 얼마나 잘 어울리는지를 가리키며, 관련된 코드는 서로 가까이 위치하는 것이 좋다는 것을 의미합니다. 높은 응집도를 추구하고 관련 코드를 가능한 한 긴밀히 묶어야 합니다. 이는 모듈/클래스 내부 요소와 관련이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결합성은 서로 다른 모듈/클래스가 서로 얼마나 의존하는지를 나타내는 정도를 의미합니다. 가능한 한 모든 모듈이 독립적이어야 한다는 것이 권장되며, 이것이 낮은 결합성을 유지해야 하는 이유입니다. 서로 다른 모듈/클래스 간의 요소와 관련이 있습니다.\n\n## 비즈니스 로직은 대표자 밖으로 유지하세요\n\n많은 경우 UI 구성 요소의 범위 내에서 모든 것을 섞으려는 경우를 종종 보았습니다. 한 개 또는 몇 개만 떼어내도, 여전히 병목현상은 UI 또는 비즈니스 로직을 업데이트하려면 둘 다 처리해야 한다는 문제입니다.\n\n리액트에서 우리에게 제시된 코드 유지보수를 간단하게 하기 위한 훅(Hooks)이라는 훨씬 더 나은 접근 방식이 있습니다. 구성 요소 대신에 자신을 대신해서 API 요청을 호출할 때, 이 코드를 따로 폴더/범위로 가져가고 격리된 상태로 관리하는 것이 더 나은 방법이 아닌가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 UI 레이어를 훨씬 멋지게 만들 수 있게 될 거예요:\n\n`![UI 레이어](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_13.png)`\n\n...그리고 비즈니스 레이어는 아래와 같이:\n\n`![비즈니스 레이어](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_14.png)`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 API 호출을 다룬다는 것을 명심해주세요 — getUsers(). 여기에 그 로직을 넣게 될 거라고 상상해봐요... 음, 이걸 모두 한 곳에서 유지하는 것은 약간 복잡할 것 같아요.\n\n그래서 이전에 우리는 핵심 API 로직을 보관할 전용 API 폴더를 설계했어요:\n\n![API Folder](/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_15.png)\n\n그리고 마지막으로 인터페이스... 여기서는 코드에서 그들을 가져와서 공유 가능한 ./interfaces 폴더에 넣어요. 이렇게 하면 API 코드를 훨씬 깔끔하고 이해하기 쉽도록 유지하고 확장할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 NextJS 프로젝트를 위해 잘 설계된 추상화를 작성한 후에 코드를 깔끔하고 효율적으로 작성하는 4단계 Best Practice 입니다. 이전에 논의한 아키텍처로 계속 진행해야 하는 이유가 이제 더 명확해졌기를 바랍니다.\n\n# 마무리\n\n앱을 설계하는 것은 하루 만에 끝나는 작업이 아니기 때문에 아직 다룰 것이 많습니다. 어떤 회사들은 아키텍처 방법을 논의하기 위해 몇 달을 소비한 후에야 앱 아키텍처 작업을 시작합니다.\n\n하지만, 이 작은 실제 예제가 어떻게 미래 앱을 더 잘 설계하고 웹 애플리케이션을 개발할 때 따라야 하는 올바른 추상화에 대한 감각을 제공해 줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급한 앱의 출처입니다. 원하신다면 여기에서 함께 놀아보세요: https://github.com/BiosBoy/my-social-app.\n\n건배 🍻","ogImage":{"url":"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringNextJSArchitecturewithTypeScriptinMindDesignAbstractions2024_0.png","tag":["Tech"],"readingTime":10}],"page":"15","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>