<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/101" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/101" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="12가지 유용한 JavaScript 면접 팁" href="/post/2024-05-14-12UsefulJavaScriptInterviewTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="12가지 유용한 JavaScript 면접 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="12가지 유용한 JavaScript 면접 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">12가지 유용한 JavaScript 면접 팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="노드js 클러스터 구현으로 성능 개선하기" href="/post/2024-05-14-ImplementingNodejsClusterforImprovedPerformance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="노드js 클러스터 구현으로 성능 개선하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="노드js 클러스터 구현으로 성능 개선하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">노드js 클러스터 구현으로 성능 개선하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" href="/post/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jupyter 노트북에 현대적 JavaScript 가져오기" href="/post/2024-05-14-BringingModernJavaScripttotheJupyterNotebook"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jupyter 노트북에 현대적 JavaScript 가져오기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jupyter 노트북에 현대적 JavaScript 가져오기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Jupyter 노트북에 현대적 JavaScript 가져오기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" href="/post/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아스트로 JS 프로젝트용 Neovim 설정" href="/post/2024-05-14-NeovimSetupforAstroJsProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아스트로 JS 프로젝트용 Neovim 설정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아스트로 JS 프로젝트용 Neovim 설정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아스트로 JS 프로젝트용 Neovim 설정</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" href="/post/2024-05-14-IHateJavaScriptThankYouBlazor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="점진적 향상과 JavaScript 프레임워크  복잡한 관계" href="/post/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="점진적 향상과 JavaScript 프레임워크  복잡한 관계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="점진적 향상과 JavaScript 프레임워크  복잡한 관계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">점진적 향상과 JavaScript 프레임워크  복잡한 관계</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책" href="/post/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="애플리케이션 성능을 향상시키세요 Nodejs와 Redis" href="/post/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="애플리케이션 성능을 향상시키세요 Nodejs와 Redis" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="애플리케이션 성능을 향상시키세요 Nodejs와 Redis" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">애플리케이션 성능을 향상시키세요 Nodejs와 Redis</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link posts_-active__YVJEi" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"12가지 유용한 JavaScript 면접 팁","description":"","date":"2024-05-14 16:06","slug":"2024-05-14-12UsefulJavaScriptInterviewTips","content":"\n\n제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록\n\n![자바스크립트에 대해 알아야 할 것들](/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png)\n\n이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.\n\n이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.\n\n\n\n# 1. 'Set' 객체는 무엇이며 어떻게 작동하나요?\n\nSet 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.\n\nSet 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.\n\n```js\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n```\n\n\n\nSet 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.\n\n```js\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n```\n\n특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.\n\n```js\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n```\n\n\n\nSet 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.\n\n```js\nset2.size // 10을 반환합니다\n```\n\n모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.\n\n```js\nset2.clear();\n```\n\n\n\n배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n```\n\n## 2. 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.\n\n\n\n자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.\n\n```js\nconst btnAdd = document.getElementById('btnAdd');\n\nbtnAdd.addEventListener('click', function clickCallback(e) {\n    // 아무 일도 하지 않음\n});\n```\n\n이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.\n\n배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.\n\n\n\n# 3. ES6 모듈이란 무엇인가요?\n\n모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.\n\n- CommonJS-Node.js\n- AMD (비동기 모듈 정의) - 브라우저\n\n기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.\n\n\n\n## 내보내기\n\nES5(CommonJS) 사용\n\n```js\n// ES5(CommonJS)를 사용하여 - helpers.js\nexports.isNull = function(val) {\n  return val === null;\n}\n\nexports.isUndefined = function(val) {\n  return val === undefined;\n}\n\nexports.isNullOrUndefined = function(val) {\n  return exports.isNull(val) || exports.isUndefined(val);\n}\n```\n\nES6 모듈 사용\n\n\n\n```js\n// Using ES6 Modules - helpers.js\nexport function isNull(val){\n  return val === null;\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\nexport function isNullOrUndefined(val) {\n  return isNull(val) || isUndefined(val);\n}\n```\n\n다른 파일에서 함수 가져오기\n\n```js\n//ES5 (CommonJS) - index.js\nconst helpers = require('./helpers.js'); // helpers는 객체임\nconst isNull = helpers.isNull;\nconst isUndefined = helpers.isUndefined;\nconst isNullOrUndefined = helpers.isNullOrUndefined;\n// 또는 환경이 구조 분해를 지원하는 경우\nconst { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js');\n-------------------------------------------------------\n// ES6 Modules - index.js\nimport * as helpers from './helpers.js'; // helpers는 객체임\n// 또는 \nimport { isNull, isUndefined, isNullOrUndefined as isValid } from './helpers.js';\n// \"as\"를 사용하여 명명된 내보내기 이름 변경\n```\n\n파일에서 단일 함수 또는 기본 내보내기 내보내기\n\n\n\nES5 (CommonJS)\n\n```js\n// ES5 (CommonJS) - index.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nmodule.exports = Helpers;\n```\n\nES6 Modules을 사용하는 예시\n\n```js\n// using ES6 Modules - helpers.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nexport default Helpers;\n```\n\n\n\n다른 파일에서 함수를 한 개 가져오기\n\nES5(CommonJS)를 사용하는 방법\n\n```js\n// ES5(CommonJS) - index.js\nconst Helpers = require('./helpers.js');\nconsole.log(Helpers.isNull(null));\n```\n\nES6 모듈 사용법\n\n\n\n```js\nimport Helpers from '.helpers.js'\nconsole.log(Helpers.isNull(null));\n```\n\n## 4. Promise이 무엇인가요?\n\nPromise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.\n\n```js\nfs.readFile('somefile.txt', function (e, data) {\n  if (e) {\n    console.log(e);\n  }\n  console.log(data);\n});\n```\n\n\n\n만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.\n\n```js\n// 콜백 지옥\nfs.readFile('somefile.txt', function (e, data) {\n  //여기에 코드 작성\n  fs.readdir('directory', function (e, files) {\n    //여기에 코드 작성\n    fs.mkdir('directory', function (e) {\n      //여기에 코드 작성\n    })\n  })\n})\n```\n\n이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.\n\n```js\npromReadFile('file/path')\n  .then(data =\u003e {\n    return promReaddir('directory');\n  })\n  .then(data =\u003e {\n    return promMkdir('directory');\n  })\n  .catch(e =\u003e {\n    console.log(e);\n  })\n```  \n\n\n\n약속은 세 가지 다른 상태를 가집니다:\n\n- 대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.\n- 충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.\n- 거부됨(rejected): 작업이 실패한 상태입니다.\n\n대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:\n\n```js\nconst myFirstPromise = new Promise((resolve, reject) =\u003e {\n    setTimeout(function(){\n        resolve(\"Success!\"); \n    }, 250);\n});\n\nmyFirstPromise.then((data) =\u003e {\n    console.log(\"Yay! \" + data);\n}).catch((e) =\u003e {...});\n```\n\n\n\n# 5. async/await이란 무엇이며 어떻게 동작합니까?\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.\n\n\n\n```js\n기능 callApi() {\n  return fetch(\"url/to/api/endpoint\")\n    .then(resp =\u003e resp.json())\n    .then(data =\u003e {\n      // \"data\"와 무언가를 처리합니다\n    }).catch(err =\u003e {\n      // \"err\"과 무언가를 처리합니다\n    });\n}\n```\n\nasync/await\n\nasync/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.\n\n```js\nasync function callApi() {\n  try {\n    const resp = await fetch(\"url/to/api/endpoint\");\n    const data = await resp.json();\n    // \"data\"와 무언가를 처리합니다\n  } catch (e) {\n    // \"err\"과 무언가를 처리합니다\n  }\n}\n```\n\n\n\n참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\ngiveMeOne()\n  .then((num) =\u003e {\n    console.log(num); // 1을 출력합니다\n  });\n```\n\n참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\nfunction getOne() {\n  try {\n    const num = await giveMeOne();\n    console.log(num);\n  } catch (e) {\n    console.log(e);\n  }\n}\n// Uncaught SyntaxError: await is only valid in async function\nasync function getTwo() {\n  try {\n    const num1 = await giveMeOne(); \n    const num2 = await giveMeOne(); \n    return num1 + num2;\n  } catch (e) {\n    console.log(e);\n  }\n}\nawait getTwo(); // 2\n```\n\n\n\n# 6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?\n\n스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.\n\n나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.\n\n```js\nfunction add(a, b) {\n  return a + b;\n};\n\nconst nums = [5, 6];\nconst sum = add(...nums);\nconsole.log(sum);\n```\n\n\n\n이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.\n\n```js\nfunction add(...rest) {\n  return rest.reduce((total, current) =\u003e total + current);\n};\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add(1, 2, 3, 4, 5)); // 15\n```\n\n이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.\n\n```js\nconst [first, ...others] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(others); // [2, 3, 4, 5]\n```\n\n\n\n여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.\n\n# 7. 기본 매개변수란?\n\n기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.\n\n```js\n//ES5 버전\nfunction add(a, b) {\n  a = a || 0;\n  b = b || 0;\n  return a + b;\n}\n\n//ES6 버전\nfunction add(a = 0, b = 0) {\n  return a + b;\n}\nadd(1); // 1을 반환\n```\n\n\n\n기본 매개변수에서 해체 할당을 사용할 수도 있어요.\n\n```js\nfunction getFirst([first, ...rest] = [0, 1]) {\n  return first;\n}\n\ngetFirst();  // 0\ngetFirst([10,20,30]);  // 10\nfunction getArr({ nums } = { nums: [1, 2, 3, 4] }){\n    return nums;\n}\ngetArr(); // [1, 2, 3, 4]\ngetArr({nums:[5,4,3,2,1]}); // [5,4,3,2,1]\n```\n\n이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.\n\n```js\nfunction doSomethingWithValue(value = \"Hello World\", callback = () =\u003e { console.log(value) }) {\n  callback();\n}\ndoSomethingWithValue(); //\"Hello World\"\n```\n\n\n\n# 8. 래퍼 객체란 무엇인가요?\n\n이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.\n\n기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt\n\n참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.\n\n\n\n참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:\n\n```js\nlet name = \"maxwell\";\n\nconsole.log(typeof name); // \"string\"\nconsole.log(name.toUpperCase()); // \"MAXWELL\"\n```\n\n이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.\n\n그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:\n\n\n\n```js\nconsole.log(new String(name).toUpperCase()); // \"MAXWELL\"\n```\n\n속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.\n\n## 9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?\n\n암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.\n\n\n\n아래의 예시를 가정해 봅시다.\n\n```js\nconsole.log(1 + '6'); // 16\nconsole.log(false + true); // 1\nconsole.log(6 * '2'); // 12\n```\n\n첫 번째 `console.log` 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.\n\n두 번째 `console.log` 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.\n\n\n\n세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.\n\n반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.\n\n```js\nconsole.log(1 + parseInt('6'));\n```\n\n이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.\n\n\n\n# 10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?\n\nNaN은 \"숫자가 아님(Not a Number)\"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.\n\n```js\nlet a;\n\nconsole.log(parseInt('abc')); // NaN\nconsole.log(parseInt(null)); // NaN\nconsole.log(parseInt(undefined)); // NaN\nconsole.log(parseInt(++a)); // NaN\nconsole.log(parseInt({} * 10)); // NaN\nconsole.log(parseInt('abc' - 2)); // NaN\nconsole.log(parseInt(0 / 0)); // NaN\nconsole.log(parseInt('10a' * 10)); // NaN\n```\n\nJavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.\n\n\n\n```js\nconsole.log(isNaN()); // true\nconsole.log(isNaN(undefined)); // true\nconsole.log(isNaN({})); // true\nconsole.log(isNaN(String('a'))); // true\nconsole.log(isNaN(() =\u003e { })); // true\n```\n\n모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.\n\nES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.\n\n```js\nfunction checkIfNaN(value) {\n  return value !== value;\n}\n```\n\n\n\n# 11. 값이 배열인지 어떻게 판단할 수 있을까요?\n\nArray.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n```js\nconsole.log(Array.isArray(5));  // false\nconsole.log(Array.isArray(\"\")); // false\nconsole.log(Array.isArray()); // false\nconsole.log(Array.isArray(null)); // false\nconsole.log(Array.isArray({ length: 5 })); // false\n\nconsole.log(Array.isArray([])); // true\n```\n\n이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.\n\n\n\n```js\nfunction isArray(value){\n return Object.prototype.toString.call(value) === \"[object Array]\"\n}\n```\n\n물론 전통적인 방법도 사용할 수 있어요:\n\n```js\nlet a = []\nif (a instanceof Array) {\n  console.log('is an array')\n} else {\n  console.log('Non-Arrays')\n}\n```\n\n# 12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?\n\n\n\n객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.\n\n첫 번째 방법은 in 연산자를 사용하는 것이에요:\n\n```js\nconst o = { \n  \"prop\" : \"rabbit\",\n  \"prop2\" : \"tiger\"\n};\n\nconsole.log(\"prop\" in o); // true\nconsole.log(\"prop1\" in o); // false\n```\n\n두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.\n\n\n\n```js\r\nconsole.log(o.hasOwnProperty(\"prop2\")); // true\nconsole.log(o.hasOwnProperty(\"prop1\")); // false\r\n```\n\n세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.\n\n```js\r\nconsole.log(o[\"prop\"]); // \"rabbit\"\nconsole.log(o[\"prop1\"]); // undefined\r\n```\n\n더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.\n\n\n\n우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.","ogImage":{"url":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"},"coverImage":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png","tag":["Tech"],"readingTime":14},{"title":"노드js 클러스터 구현으로 성능 개선하기","description":"","date":"2024-05-14 16:05","slug":"2024-05-14-ImplementingNodejsClusterforImprovedPerformance","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png\" /\u003e\n\nNode.js는 확장 가능하고 효율적인 서버 측 애플리케이션을 만들기 위한 인기있는 런타임 환경입니다. 멀티 코어 시스템의 잠재력을 최대한 활용하고 Node.js 애플리케이션의 성능을 향상시키기 위해 내장된 클러스터 모듈을 사용하여 클러스터링을 구현할 수 있습니다. 클러스터링은 여러 워커 프로세스를 생성하여 들어오는 요청을 처리하므로 성능이 향상되고 시스템 자원을 더 효율적으로 활용할 수 있습니다.\n\n이 글에서는 Node.js에서 클러스터링의 개념을 탐구하고, 이점을 이해하며, 클러스터링 있는 경우와 없는 경우의 워크스루를 설명하고, 성능 평가를 위해 loadtest 패키지를 사용한 로드 테스트를 소개합니다.\n\n## 클러스터링 이해하기\n\n\n\nNode.js에서의 클러스터링은 여러 워커 프로세스를 만들어들어오는 작업 부하를 공유하는 것을 포함합니다. 각 워커 프로세스는 자체 이벤트 루프에서 실행되며 사용 가능한 CPU 코어를 활용합니다. 마스터 프로세스는 워커 프로세스를 관리하고 들어오는 요청을 분배하며 프로세스 실패를 처리합니다.\n\n## 클러스터링의 장점:\n\n- 성능 향상: 클러스터링을 통해 여러 코어에 걸쳐 요청을 병렬로 처리함으로써 응용 프로그램의 성능과 응답성이 향상됩니다. 이는 특히 여러 CPU 코어를 가진 기기에서 사용 가능한 시스템 자원을 더 잘 활용할 수 있게 합니다.\n- 확장성: 클러스터링은 동시에 발생하는 요청들을 병렬로 처리하여 Node.js 애플리케이션의 확장성을 향상시킵니다. 작업 부하가 증가하면 추가 워커 프로세스가 동적으로 생성되어 부하를 효과적으로 분산시킬 수 있습니다.\n- 내결함성: 워커 프로세스가 충돌하거나 응답이 없어지면 마스터 프로세스가 해당 실패를 감지하고 자동으로 워커 프로세스를 다시 시작할 수 있습니다. 이 내결함성은 프로세스 실패가 발생해도 응용 프로그램이 계속 사용 가능하도록 보장합니다.\n\n## 예시 구현- 클러스터링과 함께:\n\n\n\nNode.js Express 애플리케이션에서 클러스터링을 구현하는 예제를 살펴보겠습니다:\n\n```js\nconst cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);\n\n  for (let i = 0; i \u003c numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) =\u003e {\n    console.log(`워커 프로세스 ${worker.process.pid}가 종료되었습니다. 다시 시작 중...`);\n    cluster.fork();\n  });\n} else {\n  const app = express();\n\n  // Express 앱을 구성합니다\n  // ...\n\n  const server = app.listen(3000, () =\u003e {\n    console.log(`워커 프로세스 ${process.pid}가 3000 포트에서 수신 대기 중입니다`);\n  });\n}\n```\n\n이 예제에서는 마스터 프로세스가 사용 가능한 CPU 코어 수에 기반하여 워커 프로세스를 생성합니다. 각 워커 프로세스는 Express 앱의 인스턴스를 실행하여 병렬 요청 처리를 활성화합니다.\n\n## 클러스터링 없이 구현한 예시:\n\n\n\n비교를 위해 클러스터링 없이 구현한 예제를 보여드립니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\n// Express 앱 구성\n// ...\n\nconst server = app.listen(3000, () =\u003e {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n이 단순화된 예제에서는 클러스터링이 없고, 응용 프로그램은 단일 프로세스에서 실행됩니다.\n\n## 클러스터링과 부하 테스트 비교:\n\n\n\n클러스터링은 병렬 처리를 통해 성능을 향상시키지만, 로드 테스팅은 다양한 작업 부하 아래 응용 프로그램의 성능을 평가합니다. 우리는 로드테스트 패키지를 사용하여 부하를 시뮬레이션하고 성능을 평가하여 이러한 방법을 비교할 수 있습니다.\n\n## 로드 테스팅 구현:\n\n응용 프로그램을 로드 테스트하려면 다음 단계를 따르세요:\n\n단계 1: 프로젝트 디렉토리에서 다음 명령을 실행하여 loadtest 패키지를 설치합니다.\n\n\n\n```js\nnpm install -g loadtest\n```\n\n단계 2: 터미널에서 node app.js를 실행하여 Express 애플리케이션을 시작합니다.\n\n단계 3: 새로운 터미널 창을 열고 다음 명령을 실행하여 애플리케이션을 로드 테스트합니다:\n\n```js\nloadtest -c 10 --rps 100 -n 100 http://localhost:3000\n```\n\n\n\n이 예시에서는 특정 URL에 초당 100개의 요청률을 가진 10개의 동시 사용자를 모의하는 것입니다.\n\n## 관찰 사항\n\n클러스터링 없음: 100개의 요청 중 100개의 오류 발생\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_1.png)\n\n\n\n캐슁터링을 이용한: 0개의 오류/100개의 요청\n\n![이미지](/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_2.png)\n\n응답 시간, 처리량, 그리고 오류와 같은 메트릭을 포함한 부하 테스트 결과를 살펴보세요. 이러한 메트릭은 지정된 부하 하에서 애플리케이션의 성능에 대한 통찰을 제공합니다.\n\n## 결론:\n\n\n\n이 글에서는 Node.js 애플리케이션에서 클러스터링의 이점을 탐색했습니다. 병렬 요청 처리를 통한 성능 향상, 확장성 및 오류 허용성을 통해 성능을 향상시킬 수 있다고 설명했습니다. 별도의 클러스터링을 사용한 예제와 그렇지 않은 예제를 제공하며, 여러 워커 프로세스를 활용하는 장점을 강조했습니다.\n\n게다가, loadtest 패키지를 사용하여 시뮬레이션된 워크로드에서 응용 프로그램의 성능을 평가하는 수단으로서 부하 테스트에 대해 논의했습니다. 부하 테스트는 응답 시간, 처리량 및 오류율을 평가하여 성능 최적화에 도움을 줍니다.\n\nNode.js 애플리케이션에서 클러스터링 및 부하 테스트를 활용함으로써 높은 성능, 확장성 및 고품질 트래픽 상황을 효과적으로 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingNodejsClusterforImprovedPerformance_0.png","tag":["Tech"],"readingTime":4},{"title":"JavaScript로 간단히 3단계로 텍스트 음성 변환 애플리케이션 만들기","description":"","date":"2024-05-14 16:04","slug":"2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps","content":"\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png)\n\n## 프론트엔드 개발\n\n# 텍스트를 음성으로 변환하기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_1.png)\n\n\n\n## 자바스크립트로 텍스트 음성 변환 앱 만드는 간단한 안내서\n\n안녕하세요! 코딩과 기술을 좋아하는 미디엄 친구 여러분!\n\n미디엄에서 텍스트 음성 변환 기능을 시도해 보신 적이 있나요? 정말 멋진 기능이죠, 그렇죠? 버튼을 누르기만 하면 글을 읽는 대신에 들을 수 있어요. 그렇게 하면 내용을 즐기면서 다른 일을 할 수도 있어요.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_2.png)\n\n\n\n이 기능 덕분에 새로운 기사 아이디어가 떠올랐어요. 그래서 이 기능이 어떻게 작동하는지 보여주고 여러분께 자신만의 기능을 만드는 방법을 가르쳐주기로 결심했어요.\n\n이 기사에서는 JavaScript와 Web Speech API만을 사용하여 어떻게 재미있는 텍스트 음성 변환 앱을 만들 수 있는지 단계별로 보여드릴 거에요. 끝나면 브라우저에서 어떤 텍스트든 음성으로 변환할 수 있게 되며 음성과 속도를 선택할 수도 있을 거예요.\n\n준비됐나요? 시작해볼까요?\n\n# JavaScript로 텍스트 음성 변환 애플리케이션 만들기\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_3.png\" /\u003e\n\n텍스트 음성 변환 (TTS) 시스템은 일반 언어 텍스트를 음성으로 변환합니다.\n\n이제 JavaScript를 사용하여 간단한 텍스트 음성 변환 애플리케이션을 만들어 보겠습니다. 구체적으로는 Web Speech API의 Speech Synthesis 인터페이스를 사용할 것입니다. 이 인터페이스는 거의 모든 최신 브라우저에서 지원되며 우리의 애플리케이션에 완벽합니다.\n\n시작하기 전에 JavaScript와 HTML의 기본적인 이해와 ES6 기능에 대한 친숙함이 있으면 더 좋을 것입니다.\n\n\n\n## 단계 1: HTML 구조 설정\n\n새 HTML 파일을 만들고 index.html로 저장하세요.\n\n먼저 텍스트를 입력하고 음성 기능을 실행할 수 있는 간단한 사용자 인터페이스를 설정해보겠습니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eJavaScript 텍스트 음성 변환\u003c/title\u003e\n    \u003cstyle\u003e\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            font-family: Arial, sans-serif;\n        }\n\n        .container {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n        }\n    \u003c/style\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ctextarea id=\"text\" rows=\"5\" cols=\"30\"\u003e\u003c/textarea\u003e\n        \u003cbutton id=\"speak\"\u003e음성 변환\u003c/button\u003e\n    \u003c/div\u003e\n\n    \u003cscript src=\"app.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\n\nHTML 코드에서 사용자 입력을 받을 수 있는 텍스트 영역과 텍스트를 음성으로 변환하는 버튼을 추가했고, 다음 단계에서 생성할 'app.js'라는 JavaScript 파일을 링크했습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_4.png)\n\n## 단계 2: JavaScript 구현하기\n\n이제 기능을 추가해봅시다. HTML 파일과 동일한 디렉토리에 새 JavaScript 파일을 만들어 'app.js'로 이름짓어주세요.\n\n\n\n스피치 합성 API는 window.speechSynthesis 객체를 통해 노출됩니다. 다음은 기본 구현입니다:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\n\nspeakButton.addEventListener('click', () =\u003e {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n이 스크립트는 다음을 수행합니다:\n\n- DOM에서 textarea와 버튼 엘리먼트를 선택합니다.\n- 버튼에 클릭 이벤트 리스너를 추가합니다. 버튼을 클릭하면 이벤트 리스너가:\n- 텍스트 영역의 현재 값 가져옵니다.\n- 텍스트 영역의 값으로 새로운 SpeechSynthesisUtterance 객체를 생성합니다.\n- 이 SpeechSynthesisUtterance를 speechSynthesis.speak 메서드에 전달하여 음성 합성을 시작합니다.\n\n\n\n## 단계 3: 음성 및 발화 속도 사용자화\n\nSpeechSynthesisUtterance 객체를 통해 음성, 음조, 발화 속도 등의 속성을 변경할 수 있습니다. 그러나 이를 구현하는 방법을 살펴보겠습니다.\n\n먼저, 음성 선택 및 발화 속도 제어를 위한 새로운 요소를 추가하기 위해 HTML을 수정해주세요:\n\n```js\n\u003c!-- ...기존 HTML... --\u003e\n\u003cdiv class=\"container\"\u003e\n    \u003ctextarea id=\"text\" rows=\"5\" cols=\"30\"\u003e\u003c/textarea\u003e\n    \u003cselect id=\"voices\"\u003e\u003c/select\u003e\n    \u003cinput id=\"rate\" type=\"range\" min=\"0.5\" max=\"2\" value=\"1\" step=\"0.1\" /\u003e\n    \u003cbutton id=\"speak\"\u003e말하기\u003c/button\u003e\n\u003c/div\u003e\n\u003c!-- ...기존 HTML... --\u003e\n```\n\n\n\n그럼 app.js를 다음과 같이 업데이트하세요:\n\n```js\nconst textarea = document.getElementById('text');\nconst speakButton = document.getElementById('speak');\nconst voicesSelect = document.getElementById('voices');\nconst rateInput = document.getElementById('rate');\n\nlet voices = [];\n\nfunction populateVoices() {\n    voices = speechSynthesis.getVoices();\n    voices.forEach((voice, i) =\u003e {\n        let option = document.createElement('option');\n        option.value = i;\n        option.textContent = `${voice.name} (${voice.lang})`;\n        voicesSelect.appendChild(option);\n    });\n}\n\nspeechSynthesis.addEventListener('voiceschanged', populateVoices);\n\nspeakButton.addEventListener('click', () =\u003e {\n    let text = textarea.value;\n    let utterance = new SpeechSynthesisUtterance(text);\n\n    // 선택한 음성 가져오기\n    let selectedVoiceIndex = voicesSelect.value;\n    utterance.voice = voices[selectedVoiceIndex];\n\n    // 속도 가져오기\n    utterance.rate = rateInput.value;\n\n    speechSynthesis.speak(utterance);\n});\n```\n\n여기서는 모든 사용 가능한 음성으로 select 요소를 채우는 populateVoices 함수를 추가했으며, 'voiceschanged' 이벤트가 트리거될 때 이 함수를 호출합니다. 'voiceschanged' 이벤트는 speechSynthesis.getVoices() 메소드가 반환할 SpeechSynthesisVoice 객체 목록이 변경되었을 때 발생합니다.\n\n음성 합성을 트리거할 때 우리는 선택한 음성과 속도를 DOM에서 가져와서 SpeechSynthesisUtterance 객체에 설정합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_5.png)\n\n이제 위의 사진에 나와 있는 대로 작동하는 텍스트 음성 변환 애플리케이션이 준비되었어요: 텍스트 영역에 원하는 텍스트를 입력하고, 음성을 선택하고 말 속도를 조절한 다음 \"음성 출력\"을 클릭하면 말이 들릴 거예요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:732/1*EImZrlDQ1zrxaKe9FBPPmA.gif)\n\n## 더 알아보기:\n\n\n\n# 마무리\n\n![text-to-speech-app](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_6.png)\n\n그러면 JavaScript와 Web Speech API를 사용하여 몇 분 안에 만든 간단하고 재미있는 텍스트 음성 변환 앱이 준비됐어요!\n\n이것은 사용자들이 콘텐츠를 독특하고 접근성 있게 소비하는 것과 같이 Medium이 하는 대로 당신의 웹 애플리케이션의 사용자 경험을 향상시키는 멋진 방법이 될 수 있어요.\n\n\n\n만약 JavaScript와 웹 개발의 다른 측면을 더 탐구하고 싶다면, 내 다른 기사들을 꼭 확인해보시길 권해드립니다.\n\n텍스트 음성 변환에 대해 이야기할 때, 이제 텍스트 강조 기능을 구현해보는 것이 좋겠네요. \"AWS Polly를 활용한 클라우드 기반 텍스트 음성 변환 및 텍스트 강조 생성 애플리케이션 구축\"에 해당하는 제 기사를 참고해보세요. 이 기사는 클라우드 기술을 통해 진보된, 확장 가능하고 이용하기 쉬운 텍스트 음성 변환 솔루션을 만드는 방법을 안내합니다. 그리고 AWS Polly는 친근하고 쉬운 도구입니다.\n\n반면에 UI 게임을 업그레이드하고 싶다면, “UI 디자인 마스터하기: 최고의 실천 지침 완전 가이드\"를 놓치지 마세요. 이 포괄적인 안내서는 UI 디자인의 힘을 발휘하며, 웹 및 모바일 플랫폼을 위한 직관적이고 사용자 친화적, 매력적인 인터페이스를 만드는 통찰을 제공합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_7.png\" /\u003e\n\n\n\n# 리고처럼 재사용 가능한 구성 요소로 애플리케이션 만들기\n\n![이미지](/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_8.png)\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소로 애플리케이션을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 구성 요소로 변환하고 애플리케이션 간에 공유하세요. 협업이 더 쉬워지고 더 빠르게 개발할 수 있습니다.\n\n\n\n→ 더 많은 정보 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 워크플로에 대해 최상의 경험을 누려보세요:\n\n# → 미크로 프론트엔드\n\n# → 디자인 시스템\n\n\n\n# → 코드 공유 및 재사용\n\n# → 단일 저장소\n\n# Learn more:","ogImage":{"url":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaText-To-SpeechApplicationwithJavaScriptin3EasySteps_0.png","tag":["Tech"],"readingTime":7},{"title":"Jupyter 노트북에 현대적 JavaScript 가져오기","description":"","date":"2024-05-14 16:02","slug":"2024-05-14-BringingModernJavaScripttotheJupyterNotebook","content":"\n\n## Deno 커널은 주피터를 위한 가장 최신 런타임이에요\n\n정말 예상치 못한 소식이죠.\n\nDeno는 TypeScript, JavaScript, npm 및 ES 모듈을 갖추고 있어 주피터에 쉽게 설치할 수 있는 커널을 제공해요.\n\n지금 Deno를 시작하는 더 좋은 때는 없어요. Deno를 설치한 후, deno 주피터 커널 설치를 실행하세요:  \n\n\n\n```js\ndeno jupyter --unstable --install\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*_KUkFmq1lO3H-tx4XJPNew.gif)\n\nDeno는 fetch와 같은 웹 표준을 기본적으로 지원하므로 데이터 로딩이 간단하고 쉽습니다.\n\n![image](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png)\n\n\n\n\n이것은 빠르고 안전한 런타임일뿐만 아니라 즐거운 시간을 보낼 수 있습니다. 타이밍도 훌륭합니다 — 데이터프레임은 줄리아, 파이썬, R 및 러스트만의 전유물이 아닙니다. Polars는 JavaScript용 데이터프레임을 제공합니다.\n\n![이미지1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_1.png)\n\n놀라운 점은 얼마나 쉽게 D3를 데이터프레임과 함께 사용할 수 있는지입니다.\n\n![이미지2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_2.png)\n\n\n\n우리는 캔버스에 직접 플롯을 그릴 수 있어요.\n\n![plot1](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_3.png)\n\n또한 SVG를 출력하는 어떤 라이브러리도 사용할 수 있지요.\n\n![plot2](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_4.png)\n\n\n\n이것은 다양한 JavaScript 개발자와 데이터 전문가들이 노트북에서 문서 작성을 할 수 있도록 함을 의미합니다.\n\nJavaScript/TypeScript로 데이터를 탐색하고 시각화하려면 Deno를 확인하고 Jupyter 시작 가이드 문서를 살펴보세요.\n\nRust를 알고 있다면 Deno에서 해킹해보세요. Rust를 몰라도, 나와 같은 경우라도 Deno에서 해킹해보세요. 배울 수 있습니다. Deno 팀은 TypeScript, Jupyter 및 표준의 힘을 깊이 믿는 친절한 사람들로 구성되어 있습니다.\n\n또한 버그를 보고하고, 노트북을 작성하고, Deno 커널을 다른 사람들과 공유함으로써 기여할 수도 있습니다.\n\n\n\n\n![Bringing Modern JavaScript to the Jupyter Notebook](/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_5.png)\n\n해피 노트북!\n","ogImage":{"url":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png"},"coverImage":"/assets/img/2024-05-14-BringingModernJavaScripttotheJupyterNotebook_0.png","tag":["Tech"],"readingTime":2},{"title":"디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내","description":"","date":"2024-05-14 15:59","slug":"2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode","content":"\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png)\n\n## 소프트웨어 개발 원칙\n\n# 소개 — JavaScript 디자인 패턴\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png)\n\n\n\n## 디자인 패턴의 본질\n\n안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.\n\n## 디자인 패턴 — 무엇인가요?\n\n디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.\n\n\n\n## 자바스크립트 디자인 패턴의 힘\n\n자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.\n\n다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.\n\n# 자바스크립트 디자인 패턴 유형 탐색\n\n\n\n![image](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png)\n\n## 생성 디자인 패턴: 객체 생성\n\nJavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.\n\n생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.\n\n\n\n공장 패턴\n\n공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.\n\n```js\nfunction CarFactory() {\n  this.createCar = function(model) {\n    let car;\n    if (model === '세단') {\n      car = new Sedan();\n    } else if (model === 'SUV') {\n      car = new SUV();\n    }\n    return car;\n  };\n}\n```\n\n싱글톤 패턴\n\n\n\n싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.\n\n```js\nlet Singleton = (function () {\n  let instance;\n \n  function createInstance() {\n    return new Object(\"I am the instance\");\n  }\n \n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n```\n\n빌더 패턴\n\n빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.\n\n\n\n```js\nfunction CarBuilder() {\n  this.car = null;\n\n  this.step1 = function () {\n    this.car = new Car();\n  };\n\n  this.step2 = function () {\n    this.car.addParts();\n  };\n\n  this.get = function () {\n    return this.car;\n  };\n}\n```\n\n## 구조적 디자인 패턴: 코드 모양을 만드는 방법\n\n구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.\n\n어댑터 패턴\n\n\n\n어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.\n\n```js\nclass OldCalculator {\n  constructor() {\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return term1 + term2;\n        case 'sub':\n          return term1 - term2;\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\nclass NewCalculator {\n  constructor() {\n    this.add = function(term1, term2) {\n      return term1 + term2;\n    };\n    this.sub = function(term1, term2) {\n      return term1 - term2;\n    };\n  }\n}\n\nclass CalculatorAdapter {\n  constructor() {\n    const newCalc = new NewCalculator();\n    \n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return newCalc.add(term1, term2);\n        case 'sub':\n          return newCalc.sub(term1, term2);\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n```\n\n데코레이터 패턴\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.\n\n\n\n```js\nfunction Car(name) {\n  this.name = name;\n}\n\nCar.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedCar(car, color, price) {\n  this.car = car;\n  this.color = color;\n  this.price = price;\n}\n\nDecoratedCar.prototype.getName = function () {\n  return this.car.getName() + ' has color ' + this.color + ' and price ' + this.price;\n};\n```\n\n프록시 패턴\n\n프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.\n\n```js\nfunction NetworkAccess() {\n  this.connect = function () {\n    console.log('네트워크에 연결되었습니다.');\n  };\n}\n\nfunction NetworkProxy() {\n  this.network = new NetworkAccess();\n  this.connect = function () {\n    console.log('네트워크 프록시를 사용합니다.');\n    this.network.connect();\n  };\n}\n```\n\n\n\n## 행동 디자인 패턴: 객체 협업 관리\n\n행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.\n\n옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.\n\n\n\n```js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index \u003e -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notifyAll(data) {\n        for (let i = 0; i \u003c this.observers.length; i++) {\n            this.observers[i].notify(data);\n        }\n    }\n}\n\nclass Observer {\n    notify(data) {\n        console.log(`Observer received: ${data}`);\n    }\n}\n```\n\n전략 패턴\n\n전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.\n\n```js\nclass Shipping {\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    calculate(parcel) {\n        return this.strategy.calculate(parcel);\n    }\n}\n\nclass UPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.75}`;\n    }\n}\n\nclass FedEx {\n    calculate(parcel) {\n        return `$${parcel.weight * 2.45}`;\n    }\n}\n\nclass USPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.25}`;\n    }\n}\n```\n\n\n\n## 커맨드 패턴\n\n커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.\n\n```js\nclass Switch {\n  execute(command) {\n    command.execute();\n  }\n}\n\nclass TurnOnCommand {\n  constructor(light) {\n    this.light = light;\n  }\n\n  execute() {\n    this.light.turnOn();\n  }\n}\n\nclass Light {\n  turnOn() {\n    console.log('불이 켜졌습니다');\n  }\n\n  turnOff() {\n    console.log('불이 꺼졌습니다');\n  }\n}\n```\n\n다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.\n\n\n\n# JavaScript 디자인 패턴의 실제 응용\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png)\n\n디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.\n\n## 사용자 프로필 생성\n\n\n\n사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.\n\n```js\nfunction UserFactory() {\n  this.createUser = function(type) {\n    let user;\n\n    if (type === '개인') {\n      user = new PersonalUser();\n    } else if (type === '비즈니스') {\n      user = new BusinessUser();\n    }\n\n    user.type = type;\n    user.say = function() {\n      console.log(this.type + \": 프로필이 생성되었습니다\");\n    }\n    return user;\n  }\n}\n```\n\n## 제3자 API와의 통합\n\n다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.\n\n\n\n\n```js\nclass ThirdPartyAPI {\n  constructor() {\n    this.specificRequest = function() {\n      return \"Third-party API response\";\n    };\n  }\n}\n\nclass Adapter {\n  constructor(thirdPartyAPI) {\n    this.request = function() {\n      return thirdPartyAPI.specificRequest();\n    };\n  }\n}\n\n// Using the Adapter\nconst thirdPartyAPI = new ThirdPartyAPI();\nconst adapter = new Adapter(thirdPartyAPI);\nadapter.request();\n```\n\n## 사용자 프로필에 기능 추가하기\n\nDecorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedUser(user, badge, theme) {\n  this.user = user;\n  this.badge = badge;\n  this.theme = theme;\n}\n\nDecoratedUser.prototype.getName = function () {\n  return `${this.user.getName()}, Badge: ${this.badge}, Theme: ${this.theme}`;\n};\n```\n\n\n\n## 게시물과 사용자 상호작용\n\n옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.\n\n```js\nclass Post {\n  constructor() {\n    this.observers = [];\n  }\n\n  like(user) {\n    this.notifyAll(`게시물이 ${user}님에 의해 좋아요!`);\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll(message) {\n    for (let observer of this.observers) {\n      observer.notify(message);\n    }\n  }\n}\n\nclass User {\n  notify(message) {\n    console.log(`사용자에게 알림: ${message}`);\n  }\n}\n```\n\n## 다양한 배송 방법\n\n\n\n이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.\n\n```js\nclass Shipping {\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(parcel) {\n    return this.strategy.calculate(parcel);\n  }\n}\n\nclass UPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.75}`;\n  }\n}\n\nclass FedEx {\n  calculate(parcel) {\n    return `$${parcel.weight * 2.45}`;\n  }\n}\n\nclass USPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.25}`;\n  }\n}\n```\n\n## 웹사이트 테마 사용자 정의\n\n사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.\n\n\n\n```js\n// 팩토리 패턴\nfunction ThemeFactory() {\n  this.createTheme = function(type) {\n    let theme;\n\n    if (type === 'Dark') {\n      theme = new DarkTheme();\n    } else if (type === 'Light') {\n      theme = new LightTheme();\n    }\n\n    theme.type = type;\n    return theme;\n  }\n}\n\n// 데코레이터 패턴\nfunction DecoratedTheme(theme, color) {\n  this.theme = theme;\n  this.color = color;\n}\n\nDecoratedTheme.prototype.getName = function () {\n  return this.theme.getName() + ' in ' + this.color + ' color';\n};\n```\n\n## 할인 이벤트가 적용된 전자 상거래 사이트\n\n전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.\n\n```js\n// 전략 패턴\nclass SpecialOffer {\n  apply(product) {\n    // abstract method\n  }\n}\n\nclass BlackFridayOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.8;  // 20% 할인\n  }\n}\n\nclass ChristmasOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.85;  // 15% 할인\n  }\n}\n\n// 옵서버 패턴\nclass Product {\n  constructor(price) {\n    this.price = price;\n    this.observers = [];\n  }\n\n  setPrice(price) {\n    this.price = price;\n    this.notifyAll();\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll() {\n    for (let observer of this.observers) {\n      observer.notify(this);\n    }\n  }\n}\n\nclass Customer {\n  notify(product) {\n    console.log(`제품 가격이 $${product.price}로 업데이트되었습니다.`);\n  }\n}\n```\n\n\n\n## 성능 모니터링 시스템\n\n알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.\n\n```js\n// Factory Pattern\nfunction ModuleFactory() {\n  this.createModule = function(type) {\n    let module;\n\n    if (type === 'Database') {\n      module = new DatabaseModule();\n    } else if (type === 'Network') {\n      module = new NetworkModule();\n    }\n\n    module.type = type;\n    return module;\n  }\n}\n\n// Proxy Pattern\nclass PerformanceProxy {\n  constructor(module) {\n    this.module = module;\n  }\n\n  monitor() {\n    console.log('성능 모니터링 중...');\n    // 호출을 원래 객체로 위임합니다.\n    this.module.monitor();\n  }\n}\n```\n\n## 채팅 애플리케이션\n\n\n\n매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.\n\n```js\n// 싱글톤 패턴\nlet ChatRoom = (function() {\n  let instance;\n\n  function createInstance() {\n    let object = new Object(\"ChatRoom\");\n    return object;\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// 옵서버 패턴\nclass User {\n  notify(message) {\n    console.log(`Received message: ${message}`);\n  }\n}\n```\n\n## 온라인 게임 시스템\n\n온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.\n\n\n\n```js\n// Factory Pattern\nfunction CharacterFactory() {\n  this.createCharacter = function(type) {\n    let character;\n\n    if (type === 'Warrior') {\n      character = new Warrior();\n    } else if (type === 'Mage') {\n      character = new Mage();\n    }\n\n    character.type = type;\n    return character;\n  }\n}\n\n// Observer Pattern\nclass Character {\n  hit() {\n    // Notify all observers\n  }\n}\n\n// Decorator Pattern\nfunction EnhancedCharacter(character, ability) {\n  this.character = character;\n  this.ability = ability;\n}\n\nEnhancedCharacter.prototype.useAbility = function() {\n  console.log(`Using ability: ${this.ability}`);\n}\n```\n\nThese examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.\n\n# Design Patterns를 사용할 때 피해야 할 함정\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png)\n\n\n\n\n디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.\n\n다음은 피해야 할 몇 가지 일반적인 함정입니다:\n\n## 디자인 패턴 과용\n\n디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.\n\n\n\n## 디자인 패턴 오용\n\n각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.\n\n## 패턴을 완전히 이해하지 못한 경우\n\n디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.\n\n\n\n## 간단함의 원칙을 무시하다\n\nKISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.\n\n# 요약 및 권장 사항\n\n![](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png)\n\n\n\n본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.\n\n## 추가 학습\n\n지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.\n\n자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: \"JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice\" 그리고 \"JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구\"\n\n\n\n두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.\n\n항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png)\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\n\n\n\n우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png","tag":["Tech"],"readingTime":15},{"title":"아스트로 JS 프로젝트용 Neovim 설정","description":"","date":"2024-05-14 15:58","slug":"2024-05-14-NeovimSetupforAstroJsProjects","content":"\n\n![AstroJS](/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png)\n\n최근 JavaScript 커뮤니티에서 AstroJS가 많은 사랑을 받고 있어요. Astro를 들어보지 못했다면, 콘텐츠 중심 웹 프레임워크입니다. '아일랜드'와 같은 개념을 사용하여 모든 비필수적인 자바스크립트를 제거하여 사이트 속도를 높일 수 있어요.\n\n저는 이것을 시도해보고 있으며, 편집기로 Neovim을 사용하고 있어요. 모든 것을 설정하는 방법이 100% 명확하지 않아서 이 기사에서 제가 한 설정 방법을 공유하려고 해요. AstroJS 프로젝트에서 Neovim을 잘 작동하도록 설정하는 방법은 다음과 같아요.\n\n## LSP 구성\n\n\n\n이 부분이 조금 헷갈렸네요.\n\n- 먼저 Mason을 통해 astro-language-server를 설치해야 합니다:\n\n![astro-language-server 설치](/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_1.png)\n\n2. mason_lspconfig.setup에서 astro가 ensure_installed 객체에 있는지 확인하세요:\n\n\n\n```js\n mason_lspconfig.setup({\n   -- mason 설치할 서버 목록\n   ensure_installed = {\n    \"astro\",\n    \"tsserver\",\n    \"html\",\n    \"cssls\",\n    \"tailwindcss\",\n   },\n   -- lspconfig로 자동 설치 (ensure_installed랑 다름)\n   automatic_installation = true,\n  })\n```\n\n3. lspconfig를 설정하는 곳에 다음 코드를 넣으세요:\n\n```js\n  -- astro --\n  lspconfig[\"astro\"].setup({\n   capabilities = capabilities,\n   on_attach = on_attach,\n   filetypes = { \"astro\" },\n  })\n```\n\n저는 이 부분이 헷갈렸어요. astro-language-server를 설치했는데 lspconfig에서는 astro만 사용한다고 하더라구요. 나중에 돌아봤을 때 Mason에서 LSP 이름 뒤에 astro를 제공하는 걸 볼 수 있었지만, 처음에는 이게 명확하지 않았어요.\n\n\n\n이것이 .astro 파일에 대한 LSP를 활성화해야 합니다.\n\n## 구문 강조\n\n그를 위해 저는 내 treesitter 구성에서 ensure_installed object에 astro를 추가했어요.\n\n```js\n require(\"nvim-treesitter.configs\").setup({\n    ensure_installed = {\n     \"astro\",\n    },\n })\n```\n\n\n\n## 형식 지정\n\n이를 위해 나는 prettier와 prettier-plugin-astro라는 플러그인의 조합을 사용하고 있습니다. 우선 none-ls.lua 파일에 있는 파일 목록에 astro 파일 유형을 prettier로 서식을 지정할 파일 목록에 추가했습니다 (저는 Mason을 통해 포매터로 prettier를 설치했습니다).\n\n```js\n formatting.prettier.with({\n     extra_filetypes = { \"svelte\", \"typescriptreact\", \"astro\" },\n    }), \n```\n\n그런 다음 로컬 astro 프로젝트에서 이 prettier-plugin-astro를 로컬 개발 종속성으로 설치했습니다.\n\n\n\n```js\npnpm add -D prettier-plugin-astro\n```\n\n그리고 Neovim을 다시 시작한 후 .astro 파일을 저장하면 저장될 때 자동으로 서식이 지정됩니다.\n\n# 결론\n\n이 모든 것을 설정하는 방법이 100% 명확하지는 않았고, 꽤 오랜 시간이 걸렸습니다. 여러 가지를 찾아보고 시행착오를 격은 결과였죠. 이 기사가 Neovim에서 AstroJs 프로젝트를 작업하기를 희망하는 사람들이 자신의 설정을 Neovim에서 잘 작동하도록 도와줄 수 있기를 바랍니다.\n\n\n\n# 구독하기\n\n만약 이 블로그 글을 좋아한다면, 매번 새로운 글이 올라올 때마다 알림을 받을 수 있습니다. 저는 매주 월요일 아침 8:30에 중앙 유럽 시간에 글을 올립니다.\n\n# 나에 대해\n\n저는 주로 React와 Typescript를 사용하는 프론트엔드 개발자입니다. 새로운 도구와 라이브러리를 탐구하는 것을 좋아하며, JavaScript 생태계를 사랑합니다.\n\n\n\n저는 발견한 새로운 흥미로운 도구, 사용 설명서 논문 및 가끔 의견 조각을 나누는 블로그 글을 쓰는 것을 좋아해요.\n\n저는 체코 공화국 프라하에 제 가족과 함께 살고 있어요.\n\n제 블로그에서 원본 블로그 글을 확인해보세요.\n\n관심이 있다면 제 LinkedIn과 Github도 확인해보세요.","ogImage":{"url":"/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png"},"coverImage":"/assets/img/2024-05-14-NeovimSetupforAstroJsProjects_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트를 싫어해봤는데, 블레이저 덕분에 고마워요","description":"","date":"2024-05-14 15:56","slug":"2024-05-14-IHateJavaScriptThankYouBlazor","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png\" /\u003e\n\n여러 해 동안 JavaScript는 웹 개발의 주인공으로 선전을 하면서 클라이언트 측 프로그래밍을 지배했습니다. 다양한 브라우저에서의 보급성과 웹 페이지 상호 작용에서 중요한 역할을 하는 기능으로 인해 사람들은 JavaScript를 떠날 수 없었습니다. 그러나 저와 JavaScript의 관계는 지금까지 괴로움으로 가득 찼습니다. 동적 타입의 특성부터 다양한 브라우저 간의 예측할 수 없는 동작까지, JavaScript와 함께한 여행은 디버깅과 해결책 찾기의 롤러코스터였습니다. 그런데 그 모든 것이 Blazor를 만나면서 달라졌습니다.\n\n# JavaScript의 문제점\n\n저와 같은 많은 개발자들이 겪은 것처럼 JavaScript에 대한 불평은 그 언어의 독특한 점과 일관성 부족에서 비롯됩니다. 여기에는 JavaScript의 특정 문제점을 자세히 살펴보며 이 언어의 풍경에 익숙한 많은 사람들에게 공감할 수 있는 예제가 포함되어 있습니다.\n\n\n\n\n## 동적 타이핑의 문제점\n\n자바스크립트의 동적 타이핑은 종종 그 유연성으로 인해 칭찬받지만, 변수가 언제든지 어떤 유형의 값을 보유할 수 있다는 것을 의미합니다. 그러나, 이 기능은 예상치 못한 동작과 디버깅하기 어려운 런타임 에러를 초래할 수 있습니다. 다음 예시를 살펴보세요:\n\n```js\nlet value = \"5\";\nconsole.log(value + 5); // 결과: \"55\"\n```\n\n이 스니펫에서, 자바스크립트는 두 숫자를 더하는 대신, 문자열과 숫자를 연결하여 \"55\"를 출력합니다. 이러한 타입 강제 변환이 컴파일 시점에 변수의 유형이 알려진 정적으로 타입화된 언어에서 왔던 사람들에게는 예상치 못할 수도 있습니다.\n\n\n\n## 변수 스코핑과 `this` 키워드\n\n자바스크립트의 변수 스코프 처리와 `this` 키워드는 혼란스러울 수 있습니다. var을 사용할 때 특히 변수의 스코프는 예측할 수 없는 동작으로 이어질 수 있습니다:\n\n```js\nfor (var i = 0; i \u003c 5; i++) {\n  setTimeout(function() { console.log(i); }, 1000);\n}\n// 출력: 5, 5, 5, 5, 5\n```\n\nvar의 함수 스코프 성질 때문에 루프가 어떤 것을 예상하는 대로 동작하지 않는데, setTimeout 함수가 실행될 때 i의 값이 이미 5에 도달했기 때문에 0부터 4가 아닌 5를 다섯 번 출력합니다.\n\n\n\n안녕하세요! \n\n위의 표는 마크다운 형식으로 변경할 수 있습니다. \n\n이 키워드는 상황에 따라 다르게 동작하기 때문에 혼란스러울 수 있습니다:\n\n```js\nconst object = {\n  property: \"Value\",\n  method: function() {\n    console.log(this.property);\n  }\n};\n\nobject.method(); // 출력: \"Value\"\nconst detachedMethod = object.method;\ndetachedMethod(); // 출력: undefined\n```\n\n두 번째 호출에서는 this가 더 이상 객체를 가리키지 않기 때문에 결과가 정의되지 않았습니다.\n\n## 콜백 지옥\n\n\n\n자바스크립트의 비동기 특성은 종종 \"콜백 지옥\"으로 이어질 수 있습니다. 이는 콜백이 중첩되어 코드를 읽고 유지하기 어렵게 만듭니다:\n\n```js\ngetData(function(a){\n    getMoreData(a, function(b){\n        getEvenMoreData(b, function(c){\n            console.log('Got data:', c);\n        });\n    });\n});\n```\n\n특히 복잡한 애플리케이션에서 이러한 중첩은 빠르게 관리하기 어려워질 수 있습니다.\n\n# 블레이저가 등장합니다\n\n\n\nBlazor의 강력한 프레임워크로서의 부상은 웹 개발 방법을 본질적으로 변화시켰습니다. 혁신적인 기능과 .NET 생태계와의 원활한 통합으로, JavaScript로 가지고 있던 불평을 해결할 뿐만 아니라 개발 워크플로우를 혁신적으로 바꿀 수 있었습니다. 여기에서는 Blazor가 웹 개발 환경을 변화시킨 내용에 대해 더 자세한 예제와 통찰을 공유하겠습니다. 특히 구성 요소 중심 아키텍처, 코드 공유의 원활함, 그리고 C#의 장점을 강조할 것입니다.\n\n## 예제로 살펴보는 구성 요소 중심 아키텍처\n\nBlazor의 가장 매력적인 특징 중 하나는 구성 요소 중심 아키텍처입니다. 이 접근 방식을 통해 개발자는 각 구성 요소가 자체 기능과 디자인을 관리하는 모듈식 방식으로 웹 UI를 구축할 수 있습니다. Blazor 구성 요소의 예제를 살펴보겠습니다:\n\n```js\n@page \"/counter\"\n\n\u003ch1\u003eCounter\u003c/h1\u003e\n\n\u003cp\u003eCurrent count: @count\u003c/p\u003e\n\n\u003cbutton class=\"btn btn-primary\" @onclick=\"IncrementCount\"\u003eClick me\u003c/button\u003e\n\n@code {\n    private int count = 0;\n\n    private void IncrementCount()\n    {\n        count++;\n    }\n}\n```\n\n\n\n이 간단한 Counter 구성 요소는 Blazor의 접근 방식을 보여줍니다. 렌더링을 위한 HTML과 동작을 위한 C# 코드가 한 파일에 캡슐화되어 있습니다. 버튼을 클릭하면 IncrementCount 메서드가 count 변수를 업데이트하고 UI가 이 변경을 자동으로 반영합니다. 이 캡슐화와 마크업과 로직의 통합이 Blazor 컴포넌트를 재사용 가능하고 쉽게 관리할 수 있게 만듭니다.\n\n## 서버와 클라이언트 간의 코드 공유의 원활함\n\nBlazor의 서버 및 클라이언트 간 코드를 원활하게 공유할 수 있는 능력은 특히 둘 다에 공유되어야 하는 많은 로직이 필요한 프로젝트에게 혁명을 일으켰습니다. 이 능력은 중복을 줄이고 비즈니스 로직의 유지 보수를 간단하게 만듭니다. 다음은 클라이언트 (Blazor WebAssembly 앱 내) 및 서버 양쪽에서 사용되는 모델을 정의하는 방법의 예시입니다:\n\n```js\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n}\n```\n\n\n\n이 Product 클래스는 공유 라이브러리에 정의될 수 있으며 API 응답을 위한 서버와 렌더링 및 조작을 위한 클라이언트 모두에서 사용할 수 있습니다. 이는 클라이언트 및 서버 코드가 동기화되어 있음을 보장할 뿐만 아니라 C#의 강력한 타이핑을 활용하여 버그를 줄이는 데 도움이 됩니다.\n\n## C# 및 컴파일 시간 오류 검사의 장점\n\nUI 로직을 정적으로 타입된 언어인 C#로 작성으로 전환함으로써 런타임 오류를 줄이고 컴파일 시간 오류 검사를 통해 코드 품질을 향상시켰습니다. 다음은 비교적인 예시를 통해 설명합니다:\n\nJavaScript에서 변수 이름에 오타가 있을 경우 런타임에서만 오류가 발견될 수 있다:\n\n\n\n```js\nlet userName = \"Mabrouk\"; // 오타가 있는 변수 이름\nconsole.log(userName); // ReferenceError: userName is not defined\n```\n\n한편, Blazor에서 비슷한 실수는 컴파일 시간에 잡힐 것입니다:\n\n```js\nstring userName = \"Mabrouk\"; // 오타가 있는 변수 이름\nConsole.WriteLine(userName); // Compile-time error: The name 'userName' does not exist in the current context\n```\n\n이 즉각적인 피드백 루프는 디버깅 시간을 크게 줄이고 전체적인 생산성을 향상시킵니다.\n\n\n\n# Blazor의 영향\n\nBlazor는 내 생산성뿐만 아니라 웹 개발에 대한 태도도 개선시켰어요. JavaScript의 특이한 점에 대한 답답함은 신뢰할 수 있는 언어와 생태계에서 개발하는 만족을 주도록 바뀌었어요. Blazor가 기존 .NET 라이브러리와 도구와 통합되어 있어 새로운 프레임워크나 라이브러리를 계속 배우는 필요 없이 넓은 생태계를 활용할 수 있습니다.\n\nBlazor Server의 서버 측 렌더링 기능과 Blazor WebAssembly의 클라이언트 측 기능은 응용 프로그램을 배포하고 실행하는 방법에 유연성을 제공하여 다양한 프로젝트 요구 사항에 맞춰줍니다. 이러한 다재다능함은 .NET 플랫폼에서 실행하는 성능 및 보안 이점과 결합되어 Blazor를 새로운 프로젝트나 기존 프로젝트에 모두 유용한 선택지로 만들어줍니다.\n\n# 요약\n\n\n\n자바스크립트는 여전히 웹 개발의 중심이 되어 있지만, 제 개인적인 여정은 웹 애플리케이션을 구축하기 위한 주요 프레임워크로 Blazor를 포용하게 되었습니다. 생산성 증가, C#로 코딩하는 즐거움, 그리고 Blazor로 개발된 애플리케이션의 견고함이 바로 제가 \"자바스크립트를 싫어하지만 Blazor에게 고마워\"라고 말하는 이유입니다.\n\n자바스크립트에 대해 같은 답답함을 느끼는 분들에게는 Blazor를 탐험해 보라고 권유합니다. 당신에게도 저와 같이 웹 개발에 대한 시각을 바꿔줄 수 있을지도 모릅니다. 기술 선택이 프로젝트의 성패를 좌우할 수 있는 세상에서, Blazor는 .NET의 견고함을 현대적 웹 애플리케이션의 역동성과 결합하여 매력적인 대안을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png"},"coverImage":"/assets/img/2024-05-14-IHateJavaScriptThankYouBlazor_0.png","tag":["Tech"],"readingTime":5},{"title":"점진적 향상과 JavaScript 프레임워크  복잡한 관계","description":"","date":"2024-05-14 15:54","slug":"2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png\" /\u003e\n\n진보적 개선(PE)과 프론트엔드 JavaScript 프레임워크 간의 호환성 문제가 오랫동약 해결되지 못해, 모든 사용 사례를 만족시킬 수 있는 현대 웹 애플리케이션을 구축하는 것이 실제로 어려워졌습니다. 그러나 프론트엔드 기술의 큰 변화로 우리에게 더 많은 옵션이 제공되고 있습니다. 이 기사에서 현대화된 디자인 패턴과 사용 사례를 평가하면서 비즈니스에 미치는 영향을 고려해, 프로젝트에 가장 적합한 방향을 선택할 수 있습니다.\n\n## 진보적 개선이 해결하는 문제는 무엇인가요?\n\n진보적 개선(PE)의 일반적인 정의는 HTML만으로도 응용 프로그램을 사용할 수 있게 보장하여 사용자에게 높은 신뢰 수준을 제공할 수 있다는 것입니다. 다른 '층', 예를 들어 글꼴, 스타일 및 JavaScript와 같은 것들을 개선으로 간주합니다. 이 정의에는 주목할 만한 도전 과제가 있지만, 이 기사에서는 해당 정의를 사용하겠습니다.\n\n\n\nGov.uk은 \"모든 사용자에게 최대한의 성공 기회를 제공하려고 노력합니다\"라고 설명하고 있어요. 자바스크립트를 제대로 불러오거나 실행하지 못하는 방문자 수가 적더라도 무시할 수 없는 문제입니다. Gov.uk은 견고한 테스트를 실시하여 방문자 중 1.1%가 'JavaScript 향상 기능'을 이용할 수 없는 것으로 밝혀졌어요. 그러므로 점진적 향상 방식으로 제작한 웹사이트는 거의 100%의 사용자에게 사용 가능해야 합니다.\n\n## UI 프레임워크가 해결하는 문제는 무엇인가요?\n\nUI 프레임워크는 다양한 아키텍처 및 응용프로그램 설계 문제를 해결해 왔습니다. 이를 통해 UI, 비즈니스 논리 및 데이터 간 분명한 역할 분리가 가능해지며, 복잡한 상호 작용을 확장 가능한 방식으로 처리합니다. 이는 CDD(Component-Driven Development)를 가능하게 하며, 기관이 UI 자산을 설계, 개발 및 관리하는 방식을 혁신시켰습니다. Handlebars와 같은 템플릿 언어는 이 문제를 해결하려 애썼지만, UI 프레임워크만큼의 강력함, 구조 및 유연성을 제공하지 못했어요.\n\n# 일반적인 아키텍처들\n\n\n\n우리가 사용할 수 있는 주요 패턴을 살펴보겠습니다:\n\n## SPA(Single Page Apps)\n\nUI는 클라이언트 측 스크립팅(Javascript)과 종종 React 또는 Angular 같은 도구를 사용하여 제시되고 관리됩니다.\n\nSPA가 인기 있는 이유는:\n\n\n\n- 페이지의 일부만 업데이트되는 매끄러운 사용자 경험\n- 웹 UI는 사용자의 동작에 매우 민첩하게 반응합니다\n- UI 개발자에게 GUI를 구축하는 통일된 모듈식 방법이 하나 있습니다\n\n이들이 점진적 향상 요구 사항을 충족하나요?\n\nHTML이 서버에서 렌더링되지 않아 사용자가 JavaScript가 로드되고 구문 분석되고 실행되기 전에 상호 작용할 UI가 없습니다. 이는 그들이 PE 요구 사항을 충족하지 못한다는 것을 의미합니다.\n\n## PWA(점진적 웹 앱)\n\n\n\nPWAs(Progressive Web Apps)는 웹 기술을 사용하여 사용자에게 네이티브 앱과 유사한 경험을 제공합니다. 그들의 이름이 진화적 개선을 사용하여 구축된 것으로 보이지만 항상 그렇지는 않을 수 있습니다. 그러나, PWA는 네트워크를 개선으로 취급하는 로컬 캐싱을 사용하기 때문에 다른 형태의 웹 앱보다 진화적일 가능성이 높습니다.\n\nPWAs가 인기 있는 이유는 무엇인가요?\n\n- 네이티브 앱과 유사한 경험 (설치 가능, 오프라인 우선, 하드웨어 기능 접근)\n- 크로스 플랫폼 (한 번 빌드하면 어디서든 배포 가능)\n\nPWA는 진화적 개선 요구 사항을 충족시키나요?\n\n\n\nPWAs는 Service Worker라는 JavaScript 기능에 의존하지만, 개발자들에게 여러 캐싱 전략을 제공하여 HTML 중심의 응용 프로그램을 만들고 설치 가능하며 오프라인으로 작동하는 것이 가능합니다. 그러나 HTML이 렌더링되는 방법은 여전히 고려되어야 합니다. 일부 PWAs는 콘텐츠가 JavaScript에 의해 렌더링되는 SPA로, 이러한 경우 준수하지 않을 수 있습니다.\n\n## JAMStack\n\nJAMStack을 사용하여 구축된 응용 프로그램은 빌드 서버를 통해 페이지를 렌더링하고, 다른 소프트웨어 구성 요소(CMS, PIM 또는 UI 코드 베이스 등)에서 감지된 변경에 기반하여 HTML을 생성합니다.\n\nJAMStack이 인기있는 이유는 무엇인가요?\n\n\n\n- 관심사 분리가 잘 되어 있습니다.\n- 안전합니다 — 공격 표면이 작습니다.\n- 페이지가 미리 렌더링되어 빠릅니다.\n\n이것들은 점진적 향상 요구 사항을 충족합니까?\n\nJAMStack 웹사이트는 PE 요구 사항을 충족할 수 있지만, MPA(아래 참조)와 마찬가지로 풍부하고 동적이며 매우 개인화된 UI를 구축하기 위해 다른 패턴을 사용해야 할 수 있으며, 이로 인해 복잡성과 비용이 증가할 수 있습니다.\n\n## Multi-page apps (MPA)\n\n\n\nMPAs는 각 '페이지'가 사용자가 새 문서로 이동할 때 서버에서 로드되는 초기 웹 사이트 패턴입니다.\n\nMPAs가 인기 있는 이유는 무엇인가요?\n\n- 개발 및 유지 관리가 간단합니다 (UI 복잡성이 낮은 경우)\n- CMS, 전자 상거래 및 CRM 시스템과 같은 다양한 경험 플랫폼에서 지원됩니다.\n\n점진적 향상 요구 사항을 충족시킬까요?\n\n\n\n네, MPAs는 서버 사이드 렌더링 또는 정적 사이트 생성을 통해 사전 렌더링에 의존합니다. 두 경우 모두 각 제공된 페이지가 콘텐츠와 네이티브 상호 작용 요소로 가득 차 있어 JavaScript 없이도 사용자가 탐색할 수 있는 UI를 제공합니다.\n\n## 하위 패턴\n\n사용 중인 몇 가지 하위 패턴을 간단히 언급하는 것이 좋습니다:\n\n- Islands: 페이지 일부가 클라이언트 측 스크립팅에 의해 사용될 수 있는 형태\n- Streaming: UI 구성 요소를 점진적으로 클라이언트로 렌더링할 수 있는 방법\n\n\n\n양쪽 경우 모두 점진적 향상이 가능하지만 서버에 대체 콘텐츠를 생성해야하는 추가적인 노력이 필요합니다.\n\n# 사용 사례에 맞는 아키텍처 선택\n\n로리 보스는 두 가지 명확한 사용 사례를 위해 빌드해야 한다고 주장했습니다: 다중 페이지 앱 또는 \"사이트\" (블로그 등 각기 다른 페이지에서 사용되는 정적 텍스트 및 이미지)와 단일 페이지 웹 앱 또는 \"앱\" (은행 포털과 같이 작업 완료 또는 풍부한 미디어 소비를 가능하게 하는 대화형 도구). 그러나 이러한 사용 사례의 조합을 고려해야 하는 웹 애플리케이션이 많습니다. Jeremy Keith가 말한대로 \"그것은 스펙트럼(spectrum)이다\". 이는 많은 대규모 온라인 경험이 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 및 클라이언트 측 렌더링(CSR)의 다양한 아키텍처 패턴의 조합을 사용한다는 것을 의미합니다. 제가 최근 이끈 프로젝트 중 하나에서는 공개 사이트를 SEO 요구 사항을 충족시키기 위해 정적 사이트로 제공하고, 비공개 회원 사이트는 단일 페이지 앱으로 제공했습니다.\n\n# 규정 준수하기\n\n\n\n많은 기관들에게 PE는 솔루션 디자인 선택지입니다. 하지만 영국의 CDDO 같은 가이드라인을 따라야 하는 경우, ‘필수 내용’ 제공과 JS가 대신 처리하는 부분을 어디에서 구분해야 하는지 알기 어려울 수 있습니다.\n\nGov.uk은 순수 PE 접근 방식을 예외로 처리하는 흥미로운 예제를 제공합니다: “최근 React를 사용하여 웹 채팅 시스템을 프로토타입으로 만들었습니다. JavaScript를 요구하지 않는 필수 웹 채팅의 기본 수준을 상상하기 어렵지만, 우리는 개발하는 모든 웹 채팅 시스템이 최소한의 표준 연락처 양식을 함께 갖도록 할 것입니다\".\n\n포괄성 측면에서 이러한 접근 방식을 완전히 지지하지만, 비즈니스적인 관점에서 이는 한 가지 문제를 해결하기 위해 두 가지 솔루션을 구축하는 것이라는 점을 인지해야 합니다. 자주 그 비용이 투자할 가치가 있는지를 주장할 수 있습니다. 모든 사용자의 요구를 충족시키면서 투자 비용이 금방 회수될 수 있습니다. 예를 들어, 바쁜 전자 상거래 사업체의 경우, 해당 투자는 출시 몇 주 내에 자체 회수될 수 있습니다.\n\n서비스를 완전히 앱과 같은 것으로 구축해야 하지만 PE를 지원해야 하는 상황에 놓인다면 다음과 같은 선택지가 있을 것입니다:\n\n\n\n- 네이티브 모바일 앱을 개발하여 PE 요건을 면제받을 수는 있지만, 모바일 앱의 배포 제한으로 인해 사용자 접속에 제약이 생길 수도 있습니다 (웹과는 달리)\n- 가능하다면 웹 기반 앱과 HTML을 우선으로 하는 대체 방안을 개발하세요.\n- 웹 기반 앱을 개발하고 사용자가 서비스를 이용할 수 있는 다른 수단 (예: 콜센터)을 제공하세요.\n- 두 가지 솔루션을 구축하는 데 필요한 복잡한 기능과 관련 비용을 고려하여 규제 기관에 면제 사례를 제출하세요.\n\n# 청와대에 가서 케이크도 먹고 싶다면?\n\n위 사항을 고려할 때, 우리가 대중들의 기대에 부응하면서 포괄적이고 매력적인 애플리케이션을 구축하는 데 도움이 되는 패턴과 도구는 무엇이 있는지 살펴보겠습니다.\n\n최근 몇 년간 렌더링이나 메타 프레임워크로 불리는 새로운 클래스의 프레임워크가 등장했습니다. 이들은 거대한 UI 프레임워크 커뮤니티를 중심으로 구축되었으며, 여러 방식으로 렌더링될 수 있는 동시에 컴포넌트 중심 개발을 지원하는 디커플드 프런트엔드를 조직이 구축해야 한다는 요구에 대응했습니다.\n\n\n\n가장 잘 알려진 메타 프레임워크는 Next.JS와 Gatsby로 한동안 치열하게 경쟁해 왔습니다. Next.js는 개발자들의 지지를 얻고 Vercel(이전의 Zeit)로부터 상당한 투자를 받아 시장을 선도하는 지도를 차지했습니다.\n\n![이미지](/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_1.png)\n\nNext.js는 비교적 성숙하고 인기가 많지만 Marko, Astro, Fresh, Rocket, Enhance와 같은 새로운 도전자들이 있습니다. 각각은 약간 다른 것을 제공하지만 대부분 성능과 개발자 경험(DX)에 초점을 맞추고 있습니다.\n\n이러한 메타 프레임워크의 성공은 지원하는 기본 UI 프레임워크의 성공에 의존한다는 것을 명심해야 합니다. 대부분은 특정 도구 하나만 지원하며, Next.js(React), Nuxt(Vue), Sveltekit(Svelte) 등의 경우입니다. 일부는 UI 도구의 종속성이 없는데, 그중 Astro가 있습니다.\n\n\n\n대규모 UI 개발을 지원하면서 점진적 개선을 지원하는 프래임워크를 제공하는 주목할 만한 경쟁자가 Remix입니다. 마이클 잭슨의 작품으로, 많은 개발자들에게 공감되는 점진적 개선 철학을 갖고 있습니다. 최근 Shopify에 인수되었으며, 시장 선도적인 위치로 떠오를 가능성이 높습니다.\n\n# 결론\n\n이 기사에서는 웹 애플리케이션을 위한 (분리된) 사용자 인터페이스를 구축할 때 중요한 패턴과 도구를 살펴보고 사용 사례 및 비즈니스 제약 사항을 고려했습니다.\n\n이 분야는 수요로 인해 중요한 성장과 변화 기간을 겪고 있으며, 자금을 낭비하지 않고 올바른 접근 방식을 선택하는 것이 어려울 수 있습니다. 많은 선택지가 있어서 좋지만, 여전히 우리가 직면해야 하는 심오한 도전이 있습니다: 많은 사람들이 웹 기술을 사용해 네이티브 모바일/데스크톱 앱을 만들고자 하지만, 이는 목적에 맞지 않습니다. 이 블로그 글에 대한 돔의 댓글이 잘 설명하고 있습니다:\n\n\n\n아직 웹 UI를 배달하는 데 사용할 수 있는 단일한 배포 가능한 이진 파일이 없습니다. 그러나 웹 어셈블리 (WASM)가 잠재적인 해결책으로 등장했습니다. 이는 우리가 아마도 풍부한 웹 애플리케이션을 구축하는 데 잘못된 기술을 사용하고 있다는 기본적인 문제를 해결할 수 있을 것입니다. WebAssembly가 꾸준히 발전하고 전통적인 HTML 기반 애플리케이션에 도전하고 있지만, 현재로서는 JavaScript를 통해 로드해야 하며, 따라서 PE 요구 사항을 충족하지 못합니다.\n\n그동안, 우리는 우리가 가진 옵션을 받아들이고 경우에 따라 비용 대 수익을 따져야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png"},"coverImage":"/assets/img/2024-05-14-ProgressiveenhancementandJavaScriptframeworksacomplicatedrelationship_0.png","tag":["Tech"],"readingTime":7},{"title":"자바스크립트 인터뷰 마스터하기 재미있는 20가지 질문과 상세한 해결책","description":"","date":"2024-05-14 15:53","slug":"2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png)\n\n자바스크립트 인터뷰는 무서울 수 있지만, 준비와 연습을 통해 심지어 가장 어려운 질문에도 대처할 수 있습니다. 이 블로그에서는 다음과 같은 20가지 흥미로운 자바스크립트 인터뷰 질문을 자세한 해설과 예시와 함께 살펴보며, 다음 인터뷰에서 뛰어난 성과를 낼 수 있도록 돕겠습니다.\n\n## 1. 자바스크립트 호이스팅이란 무엇인가요? 예를 들어 설명해주세요.\n\n- 호이스팅은 자바스크립트의 기본 동작으로서 선언을 현재 스코프의 맨 위로 이동하는 것을 말합니다.\n\n\n\n예를 들어:\n\n```js\nconsole.log(x); // undefined\nvar x = 5\n```\n\n## 2. 자바스크립트에서 클로저란 무엇인가요? 예시를 제공해주세요.\n\n- 클로저는 외부 함수의 실행이 완료된 후에도 렉시컬 스코프에서 변수에 대한 접근 권한을 유지하는 함수입니다.\n\n\n\n예시:\n\n```js\nfunction outer() {\nvar x = 10;\nreturn function inner() {\nconsole.log(x);\n}\n}\nvar closureFunc = outer();\nclosureFunc(); // logs 10\n```\n\n## 3. 자바스크립트의 이벤트 버블링과 캡처에 대해 설명해 주세요.\n\n- 이벤트 버블링은 내부 요소에서 발생한 이벤트가 외부 조상 요소로 전파되는 것을 말합니다. 이벤트 캡처는 그 반대로, 이벤트가 먼저 바깥 요소에 의해 캡처되는 것을 의미합니다.\n\n\n\n예시:\n\n```js\ndocument.getElementById(\"inner\").addEventListener(\"click\", function() {\nconsole.log(\"Inner clicked\");\n}, true); // useCapture를 true로 설정하여 캡처 단계에서 이벤트를 처리합니다.\n```\n\n## 4. 자바스크립트에서 `==`와 `===` 연산자의 차이점은 무엇인가요?\n\n`==` 연산자는 형 변환을 수행한 후에 등가성을 확인하며, 즉 비교 전에 피연산자를 동일한 유형으로 변환합니다. 반면에 `===` 연산자(엄격한 동등 연산자)는 형 변환을 수행하지 않고 등가성을 확인합니다. 이 연산자는 피연산자의 값과 유형을 직접 비교합니다.\n\n\n\n예시:\n\n```js\n1 == '1'; // true\n1 === '1'; // false\n```\n\n## 5. 자바스크립트에서 프로토타입을 예를 들어 설명해보세요.\n\n- 자바스크립트에서, 객체는 속성을 상속하는 프로토타입을 가지고 있습니다.\n\n\n\n예시:\n\n```js\nvar person = {\nname: \"John\",\nage: 30\n};\nconsole.log(person.hasOwnProperty('name')); // true\nconsole.log(person.hasOwnProperty('toString')); // false\n```\n\n## 6. 자바스크립트에서 이벤트 위임(Event Delegation)이란 무엇인가요? 예시를 제공해주세요.\n\n- 이벤트 위임은 개별 자식 요소에 여러 개의 리스너를 추가하는 대신 부모 요소에 하나의 이벤트 리스너를 연결하는 기술입니다.\n\n\n\n예시:\n\n```js\ndocument.getElementById('parent').addEventListener('click', function(event) {\nif (event.target.tagName === 'LI') {\nconsole.log('List item clicked');\n}\n});\n```\n\n## 7. 자바스크립트의 Promise 개념을 설명해보세요.\n\n- Promise는 현재 사용 가능할 수도 있고, 미래에 사용 가능할 수도 있으며, 아예 사용 불가능할 수도 있는 값을 나타냅니다. 이들은 비동기 프로그래밍에 사용됩니다.\n\n\n\n예시:\n\n```js\nconst promise = new Promise((resolve, reject) =\u003e {\nsetTimeout(() =\u003e {\nresolve('해결됨!');\n}, 2000);\n});\npromise.then((result) =\u003e {\nconsole.log(result); // 해결됨!\n});\n```\n\n## 8. 자바스크립트의 이벤트 루프는 무엇인가요? 그 작동 방식을 설명해주세요.\n\n- 이벤트 루프는 비동기 작업을 처리하는 프로세스입니다. 이는 계속해서 호출 스택과 작업 큐를 확인하며, 스택이 비어 있을 때 큐에서 작업을 스택으로 밀어넣습니다. 이를 통해 자바스크립트가 비동기 작업을 효율적으로 처리할 수 있게 됩니다.\n\n\n\n## 9. 자바스크립트의 Arrow Functions 개념을 설명해주세요. 예시를 제공해주세요.\n\n- Arrow Functions은 자바스크립트에서 함수를 더 간결하게 작성하는 방법입니다. 전통적인 함수 표현식에 비해 더 짧은 구문을 가지고 있으며 자체 `this`를 바인딩하지 않습니다.\n\n예시:\n\n```js\nconst add = (a, b) =\u003e a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n\n\n## 10. 자바스크립트에서 `this` 키워드란 무엇인가요? 동작 방식을 설명해주세요.\n\n- `this` 키워드는 자기 자신이 속한 객체를 가리킵니다. 그 값은 함수가 호출된 방식에 따라 결정됩니다.\n\n예시:\n\n```js\nconst obj = {\n  name: 'John',\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\nobj.greet(); // Hello, John!\n```\n\n\n\n## 11. 자바스크립트에서 프로토타입 상속 개념을 설명해보겠습니다. 예시를 함께 제공하겠습니다.\n\n- 프로토타입 상속은 기존 객체를 기반으로 객체를 생성하는 방법입니다. 자바스크립트에서 객체는 프로토타입으로부터 속성과 메서드를 상속받습니다.\n\n예시:\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`안녕, 내 이름은 ${this.name}이야`);\n};\nconst john = new Person('John');\njohn.greet(); // 안녕, 내 이름은 John이야\n```\n\n\n\n## 12. 자바스크립트에서 객체를 생성하는 다양한 방법은 무엇인가요? 예제를 제시해주세요.\n\n- 자바스크립트에서는 객체 리터럴, 생성자 함수, `Object.create()` 메소드를 사용하여 객체를 생성할 수 있습니다.\n\n예시:\n\n```js\n// 객체 리터럴\nconst obj = { name: 'John' };\n// 생성자 함수\nfunction Person(name) {\nthis.name = name;\n}\nconst john = new Person('John');\n// Object.create()\nconst newObj = Object.create(null);\nnewObj.name = 'John';\n```\n\n\n\n## 13. 자바스크립트에서 Callback 함수의 개념을 설명해 주세요. 예시를 제공해 주세요.\n\n- Callback 함수란 다른 함수의 인수로 전달된 함수로, 그 후 바깥 함수 내에서 호출되어 어떤 동작을 완료하는 데 사용됩니다.\n\n예시:\n\n```js\nfunction fetchData(callback) {\n// 비동기 작업\nsetTimeout(() =\u003e {\nconst data = '일부 데이터';\ncallback(data);\n}, 2000);\n}\nfetchData((data) =\u003e {\nconsole.log(data); // 일부 데이터\n});\n```\n\n\n\n## 14. JavaScript에서 `let`, `const`, 그리고 `var`의 차이점은 무엇인가요?\n\n- `var`은 함수 스코프를 가지고 있고, `let`과 `const`는 블록 스코프를 가집니다. `let`은 재할당이 가능하고, `const`는 불가능합니다.\n\n예시:\n\n```js\nlet x = 5;\nconst y = 10;\nvar z = 15;\n```\n\n\n\n## 15. JavaScript에서 Async/Await 개념을 설명해주세요. 예시를 제공해주세요.\n\n- Async/Await은 Promises와 함께 작업하는 데 사용되는 구문 설탕입니다. 이를 사용하면 비동기 코드를 동기적으로 작성할 수 있습니다.\n\n예시:\n\n```js\nasync function fetchData() {\nconst response = await fetch('https://api.example.com/data');\nconst data = await response.json();\nreturn data;\n}\n```\n\n\n\n## 16. 자바스크립트에는 서로 다른 데이터 유형이 무엇이 있나요?\n\n- 자바스크립트에는 `string`, `number`, `boolean`, `null`, `undefined`, `symbol`과 함께 `object`라는 여섯 가지 기본 데이터 유형이 있습니다.\n\n## 17. CORS(Cross-Origin Resource Sharing)의 개념을 설명해주세요.\n\n- CORS는 브라우저에 의해 구현된 보안 기능으로, 웹 페이지가 원래 페이지를 제공한 도메인과 다른 도메인으로 요청을 보내는 것을 제한합니다.\n\n\n\n## 18. 자바스크립트에서 즉시 실행 함수 표현식(IIFE)이란 무엇인가요? 예시를 제공해주세요.\n\n- IIFE는 정의된 즉시 실행되는 함수입니다.\n\n예시:\n\n```js\n(function() {\nconsole.log('IIFE 실행됨');\n})();\n```\n\n\n\n## 19. 자바스크립트에서 `splice()`와 `slice()` 메서드에 대해 설명해주세요. 예제를 제공해주세요.\n\n- `splice()` 메서드는 기존 요소를 제거하거나 대체하여 배열의 내용을 변경합니다. `slice()`는 배열의 일부를 새 배열 객체로 얕은 복사하여 반환합니다.\n\n예제:\n\n```js\nconst arr = [1, 2, 3, 4, 5];\narr.splice(2, 1); // 인덱스 2의 요소를 제거\nconst newArr = arr.slice(1, 3); // [2, 3] 반환\n```\n\n\n\n## 20. 자바스크립트에서 'use strict' 지시어의 목적은 무엇인가요?\n\n- 'use strict' 지시어는 자바스크립트 코드에서 더 엄격한 구문 분석과 오류 처리를 강제합니다. 이는 일반적인 코딩 오류를 잡고 잠재적으로 위험한 코드 구조물을 방지하는 데 도움이 됩니다.\n\n결론:","ogImage":{"url":"/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringJavaScriptInterviews20InterestingQuestionsandDetailedSolutions_0.png","tag":["Tech"],"readingTime":6},{"title":"애플리케이션 성능을 향상시키세요 Nodejs와 Redis","description":"","date":"2024-05-14 15:52","slug":"2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis","content":"\n\n\n![사진](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png)\n\n데이터베이스에서 데이터를 가져올 때마다 서버에 요청이 들어올 때마다 대기하는 것에 지쳤나요? 연결을 열고 쿼리를 실행하는 것은 애플리케이션의 속도를 늦출 수 있습니다. 그러나 만약 그 모든 것을 우회할 수 있는 방법이 있다면 어떨까요?\n\n캐싱이 바로 그 방법입니다.\n\n캐싱을 사용하면 자주 액세스하는 데이터를 임시 저장소에 저장하여 가져오는 데 걸리는 시간을 현저히 줄일 수 있습니다. 그리고 Redis는 Node.js 애플리케이션의 완벽한 동반자인 고속인 메모리 데이터 저장소입니다.\n\n\n\n\n하루, 한 시간 또는 심지어 일 분 동안 데이터를 캐싱해두고 Redis가 데이터베이스를 쿼리하는 데 걸리는 시간의 한 부분으로 데이터를 제공한다고 상상해보세요. 마치 마법처럼 — 여러분의 사용자는 데이터를 더 빨리 받을 수 있고, 서버는 땀 한 방울 흘리지 않고 더 많은 요청을 처리할 수 있습니다.\n\n그럼 왜 기다릴까요? Redis가 여러분의 Node.js 애플리케이션에서 데이터를 처리하는 방식을 혁신시키게 두세요. 데이터베이스 병목 현상에 작별을 고하고 번쩍번쩍 속도를 내는 것을 환영하세요. Redis의 속도에 놀라시는 것이 바로 지금입니다.\n\n# 요구 사항\n\n본 문서에서는 ExpressJs, Redis 그리고 NodeJs를 사용하여 데이터를 캐싱하고 HTTP 요청을 처리할 것입니다. 그러므로 NodeJs, NPM, Docker를 준비하는 것이 좋습니다.\nRedis 서버를 생성하여 저장 및 데이터 검색을 다루기 위해 Docker를 사용할 것입니다.\n\n\n\n# 애플리케이션 설정 및 실행\n\n작업할 디렉토리를 만들고, 해당 디렉토리 내에 애플리케이션 소스 코드를 포함하는 src라는 또 다른 디렉토리와 docker-compose.yml이라는 다른 파일을 생성하세요.\n최종 구조는 다음과 같아야 합니다:\n\n![애플리케이션 구조](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_1.png)\n\nsrc 폴더 내부에서 다음 명령을 실행하세요:\n\n\n\n```js\nnpm i express redis\nnpm i -D nodemon\n```\n\n그런 다음 package.json을 업데이트하여 일부 새로운 명령어 별명을 포함시킬 수 있습니다. 아래 예시를 복사하세요.\n\n```js\n{\n  \"name\": \"src\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\",\n    \"dev\": \"nodemon app.js\",\n    \"start\": \"node app.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.19.2\",\n    \"redis\": \"^4.6.13\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.1.0\"\n  }\n}\n```\n\n그런 다음 src 폴더에 app.js 파일을 만들고 다음 라인을 포함시킵니다:\n\n\n\n```js\nimport express from \"express\";\nconst PORT = 4000;\nconst app = express();\n\napp.get(\"/\", async (req, res) =\u003e {\n  return res.json(\"Hello World!!\");\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\n위의 코드를 실행하려면 다음 명령을 사용하십시오:\n\n```js\nnpm run dev\n```\n\n그리고 http://localhost:4000/을 방문하여 \"Hello World!!\"를 볼 수 있습니다.\n\n\n\n이제 터미널을 종료하여 서버를 중지하고 Redis에 연결을 시도해보겠습니다.\n아래의 코드를 app.js에 추가해주세요.\n\n```js\nimport { createClient } from \"redis\";\nconst client = createClient();\nclient.on(\"error\", (err) =\u003e console.error(\"Redis Client Error\", err));\nclient\n  .connect()\n  .then((suc) =\u003e console.info(`Redis connected`))\n  .catch((err) =\u003e console.error(`Error occured while redis is connecting, ${err}`));\n```\n\n이를 통해 애플리케이션과 Redis 서버 간에 연결이 생성됩니다.\n\n지금 애플리케이션을 실행해보면 충돌이 발생할 것입니다. 그 이유는 아직 Redis 서버를 설정하지 않았기 때문입니다. 따라서 지금 설정을 해보겠습니다.\ndocker-compose.yml 파일에 다음 라인을 복사해주세요.\n\n\n\n```yaml\n버전: \"3.8\"\n서비스:\n  캐시:\n    이미지: redis:6.2-alpine\n    재시작: 항상\n    포트:\n      - \"6379:6379\"\n    볼륨:\n      - cache:/data\n볼륨:\n  캐시:\n    드라이버: 로컬\n```\n\n메인 디렉토리에서 다음 명령어를 실행하세요:\n\n```js\ndocker-compose build\ndocker-compose up -d\n```\n\n참고: 명령어를 실행하려면 컴퓨터에 Docker가 설치되어 있어야 합니다.\n\n\n\n어제 후면을 다시 실행하면 다음이 출력됩니다:\n서버가 http://localhost:4000에서 실행 중입니다\n레디스 연결됨\n\n좋아요!! 계속 진행합시다\n\n이제 app.js 파일을 다음 라인을 포함하도록 조정해보세요:\n\n```js\nconst getData = async () =\u003e {\n  //이 부분은 데이터베이스에 쿼리하여 데이터를 가져 오는 것으로 가정합시다\n  return new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e {\n      resolve([\"bar\", \"baz\", \"qux\"]);\n    }, 1_000);\n  });\n};\n\napp.get(\"/\", async (req, res) =\u003e {\n  let data;\n  let from = \"DB\";\n  data = await client.get(\"foo\");\n  if (!data) {\n    data = await getData();\n    await client.set(\"foo\", JSON.stringify(data), {\n      EX: 60,\n    });\n  } else {\n    from = \"Cache\";\n    data = JSON.parse(data);\n  }\n  return res.json({ data, from });\n});\n```\n\n\n\n여기서는 데이터 배열을 검색하고 60초 동안 캐시에 저장하는 가짜 프로미스를 만들어 보았습니다. 데이터가 얼마나 자주 변경되는지에 따라 변경할 수 있습니다.\n\n이제 다시 http://localhost:4000 으로 이동하세요.\n데이터를 수신했다는 배열이 포함된 데이터가 표시됩니다. \"from\" 값이 \"DB\"인 것을 확인할 수 있을 겁니다. 페이지를 새로 고치면 \"from\"이 \"Cache\"인 같은 빠른 응답을 확인할 수 있을 겁니다.\n\n캐시 이전:\n\n![이미지](/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_2.png)\n\n\n\n캐싱 후:\n\n\u003cimg src=\"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_3.png\" /\u003e\n\n캐싱하기 전에 시간 차이를 볼 수 있습니다. 캐싱하기 전에는 1초가 걸렸는데, 이는 우리가 약속을 1초 동안 기다리도록 설정했기 때문입니다. 하지만 실제로는 데이터 크기와 작업하고 있는 데이터베이스에 따라 더 짧거나 더 오래 걸릴 수 있습니다. 그러나 캐싱을 사용하면 데이터를 매번 데이터베이스에서 가져오는 것보다 더 빠르게 검색할 수 있습니다.\n\n# 결론\n\n\n\n이것은 일반적인 개요예요. 자주 요청되는 데이터를 저장하는 캐싱 메커니즘을 포함하는 중요성을 설명하려고 노력했어요. 이것은 애플리케이션 성능을 향상시키고 클라이언트가 요청 처리를 기다리는 시간을 줄일 거예요. 제 첫 번째 글이에요. 읽어주셔서 감사해요. 누군가에게 도움이 되길 바라요!","ogImage":{"url":"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png"},"coverImage":"/assets/img/2024-05-14-ImproveyourapplicationperformanceNodeJsandRedis_0.png","tag":["Tech"],"readingTime":5}],"page":"101","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"101"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>