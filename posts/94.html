<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다" href="/post/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Pew의 Fiscal 50을 역동적 시각화로 개편하기" href="/post/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Pew의 Fiscal 50을 역동적 시각화로 개편하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Pew의 Fiscal 50을 역동적 시각화로 개편하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Pew의 Fiscal 50을 역동적 시각화로 개편하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요" href="/post/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="컨테이너 내부 시리즈 파트 3 마운트 네임스페이스" href="/post/2024-05-15-ContainerInternalsSeriesPart3MountNamespace"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="컨테이너 내부 시리즈 파트 3 마운트 네임스페이스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ContainerInternalsSeriesPart3MountNamespace_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="컨테이너 내부 시리즈 파트 3 마운트 네임스페이스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">컨테이너 내부 시리즈 파트 3 마운트 네임스페이스</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="타입스크립트에서 레이블 문의 마법을 공개합니다" href="/post/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입스크립트에서 레이블 문의 마법을 공개합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입스크립트에서 레이블 문의 마법을 공개합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입스크립트에서 레이블 문의 마법을 공개합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS에서 이력서를 Terraform으로 만들어보세요 I" href="/post/2024-05-15-GetyourResumeTerraformedinAWSI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에서 이력서를 Terraform으로 만들어보세요 I" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에서 이력서를 Terraform으로 만들어보세요 I" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">AWS에서 이력서를 Terraform으로 만들어보세요 I</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Harbor 시작하기 단계별 안내" href="/post/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Harbor 시작하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Harbor 시작하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Harbor 시작하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" href="/post/2024-05-15-NavigatingExposeandPublishinDockerContainers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커 컨테이너에서 노출Expose과 공개Publish 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">도커 컨테이너에서 노출Expose과 공개Publish 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" href="/post/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Terraform을 사용하여 VPC 피어링 자동화하기" href="/post/2024-05-15-AutomateVPCPeeringwithTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Terraform을 사용하여 VPC 피어링 자동화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Terraform을 사용하여 VPC 피어링 자동화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Terraform을 사용하여 VPC 피어링 자동화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link posts_-active__YVJEi" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"별호수 OSS 데이터 엔지니어링과 데이터 분석에 선언적 프로그래밍을 제공하다","description":"","date":"2024-05-15 11:17","slug":"2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics","content":"\n\n# 소개\n\nAnsible 및 Terraform과 같은 도구를 통해 선언적 프로그래밍이 등장한 것은 개발자들이 코드 실행 순서를 지정하지 않고 의도한 목표를 달성할 수 있게 해서 인프라 배포를 혁신적으로 변경했습니다.\n\n이러한 패러다임 변화는 오류율 감소, 개발 주기 단축, 코드 가독성 향상 및 모든 수준의 개발자들을 위한 접근성 향상과 같은 혜택을 가져오게 됩니다.\n\n이것은 작은 개발팀이 선언적 접근 방식을 적용하여 데이터 추출, 로딩, 변환, 조정에 대한 기존의 데이터 엔지니어링 경계를 넘어선 플랫폼을 만들어낸 이야기입니다.\n\n\n\n![2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0](/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png)\n\n# 시작\n\n2015년, ebiznext의 세심한 데이터 엔지니어링 회사에서 한 가지 어려운 과제를 직면했습니다. 강력한 빅데이터 솔루션을 필요로 하는 유명한 고객이 하둡과 스파크의 힘을 이용하려 했습니다. 우리는 20명의 작은 규모에도 불구하고 (100,000명 이상의 인원수를 가진) 산업 거물과 경쟁하기로 결심했습니다.\n\n성공하기 위한 유일한 기회는 혁신이었습니다: 산업 거물들이 밀어올리는 전통적인 ETL 솔루션을 지수적으로 능가할 수 있는 데이터 플랫폼이 필요했습니다. 이 GUI 기반 ETL을 사용해 데이터 파이프라인을 구축하려면 원본의 수와 복잡성에 비례하는 노력이 필요합니다.\n\n\n\n일반적으로 따르는 규칙을 깨기 위해, 우리는 DevOps 친화적인 플랫폼을 개발하기 위한 여정에 나섰습니다. 이 플랫폼은 모든 소스로부터 빠르게 데이터를 수집할 수 있는 기능을 갖추고 있습니다. 또한 ETL 또는 전문 엔지니어링 기술의 단점은 없습니다.\n\n입찰 날, 몇 달이 아닌 몇 주 안에 데이터를 로드할 수 있는 솔루션을 제공할 수 있는 능력 덕분에 경쟁사와 차별화되어 프로젝트를 수주할 수 있었습니다.\n\n# 에피소드 1: 스마트레이크의 등장\n\n\"스마트레이크를 만들 때의 기본 아이디어는 데이터 품질이 데이터를 로드한 후에 확인되면 데이터 웨어하우스가 깔끔한 상태로 유지될 수 없으며, 이러한 데이터 로드 전 품질 검사는 데이터 소유자가 처리해야 한다는 것이었습니다.\"\n\n\n\n왼쪽으로 기울어진 선언적 접근을 받아들일 수밖에 없는 이유가 되었습니다. 비즈니스 사용자들을 강화시키면서, 데이터 형식과 변환을 간단한 JSON 파일로 설명할 수 있는 시스템을 고안했습니다. Smartlake는 단순한 코드 생성기가 아니었으며, 다양한 데이터 형식을 원활하게 수용하고, 변환을 실행하며, 비교할 수 없는 효율로 작업을 조율하는 다재다능한 엔진이었습니다.\n\n사용자 상호작용을 간소화하기 위해 직관적인 Excel-to-JSON 변환기를 고안해 입력 형식을 쉽게 지정할 수 있도록 했습니다. Smartlake와 그 선언적 접근 덕분에 비즈니스 사용자들은 몇 분 안에 로드와 변환 작업을 정의할 수 있었습니다.\n\nSmartlake의 특징\n\n- 거의 모든 파일 형식(CSV, JSON, XML, FIXED WITH, 다중 레코드 유형, kafka 토픽 등) 로드\n- 사용자 정의 스키마 및 의미론적 유형을 사용하여 필드 유효성 검사\n- 로드되는 데이터에 대해 변환을 즉석으로 적용( GDPR, 정규화, 계산 필드 추가) 및 스키마 진화 여부와 상관없이\n- Spark, Kafka, Elasticsearch 등 대부분의 대상에 싱크\n\n\n\n# 에피소드 2: 스타레이크로의 진화\n\n\"스타레이크의 기본 아이디어는 서버리스 서비스와 클라우드 데이터웨어하우스 기능을 활용하여 Smartlake의 모든 이점을 클라우드로 가져오면서 개발 및 실행 비용을 최소화하는 것이었습니다.\"\n\n데이터 환경이 발전함에 따라 우리의 비전도 발전했습니다. 클라우드 데이터 웨어하우스가 Spark에 대한 쿼리 실행에 대한 강력한 경쟁자로 등장했습니다. 이러한 변화를 인식하고 Smartlake를 Starlake로 발전시켰습니다. Starlake는 YAML을 통해 가독성을 향상시키면서 선언적인 본질을 보존했습니다. 우리는 Spark의 뛰어난 기능을 유지하여 데이터 수집을 위해 단일 또는 여러 컨테이너 내에서 실행하고 쿼리 실행을 위해 클라우드 데이터 웨어하우스를 활용했습니다.\n\n이 전략적인 조합을 통해 특정 워크로드 요구에 기반한 성능 및 비용 효율성을 최적화할 수 있었습니다. 결과적으로 클라우드 시대에 맞춘 재구상된 플랫폼이 탄생했으며, 그 본질은 효율과 간결함에 기반을 둔 것으로 정의되었습니다.\n\n\n\n별호 발표 결과물은 Github에서 찾을 수 있는 Starlake OSS 프로젝트입니다.\n\nStarlake의 기능은 여기 자세히 설명되어 있습니다.\n\n# Starlake 뒤에 숨은 사람들\n\nStarlake의 전신인 Smartlake는 다수의 개인들의 노력에 의해 생겼지만, 특별한 기여를 한 몇몇 사람들이 두드러지게 돋보입니다:\n\n\n\n- 샘 베살라: 샘의 참여로 다른 사람들을 동원하는 것이 쉬워졌습니다. 그의 선도적인 전망과 복잡성을 단순하게 만들어내는 재능은 혁신적이었으며, 구현에 새로운 표준을 정했습니다.\n- 올리비에 지라루: 모든 팀에는 코딩 마법사가 있고, 올리비에는 그 역할을 완벽하게 수행했습니다. Spark 코드 생성(CodeGen)을 활용하여 마트료시카와 같은 수학적 프레임워크를 탐험함으로써 팀을 멘토링하는 것을 넘어서 경계를 넓혔습니다. 그의 전문 지식은 Docker, Ansible, Python, Scala 및 Spark 내부까지 이어졌습니다.\n- 발란탱 카사스: 발란탱은 Scala에서 함수형 프로그래밍을 주창했습니다. 재귀 구조와 같은 개념을 소개함으로써 팀이 기능적이면서도 우아하고 유지보수 가능한 코드를 작성할 수 있도록 자유롭게 했습니다.\n\n구름을 향한 여정이 진행됨에 따라 오랜 기간 데이터 전문가들이 합류하여 스타레이크를 오늘날의 모습으로 만들었습니다:\n\n- 스테판 만시오: 에어플로우와 다그스터 위에 스타레이크의 선언적 워크플로우를 개발한 개발자로, 이를 통해 운영의 중추를 형성하는 데 결정적 역할을 했습니다.\n- 붕콩 캄푸손: 스타레이크의 추출 및 로드 엔진의 속도와 효율성은 그의 기여에 많이 의존합니다.\n- 시릴 셰퍼로: 코드베이스 최적화의 달인으로, 시릴의 코드 재작업 노력은 스타레이크 API의 재진입성을 확보하는 데 중요했습니다.\n- 압델하미드 이라리브: 로드 엔진에 조기 기여를 한 인물로, 이처럼 선견지명과 실행 능력은 플랫폼의 현재 능력에 중요한 영향을 미쳤습니다.\n- 모하마드 카시르: 고객 프로젝트에 직접 참여하고 클라우드 플랫폼 및 비즈니스 요구 사항에 대한 심도 있는 지식을 확보한 그의 능력은 스타레이크의 진화에 큰 장점이 됐습니다.\n\n오늘날 매일 수천 개의 테이블로 변환되어 수천 개의 데이터 웨어하우스에 매일 수백 기가바이트의 데이터가로드되는 것을 자신 있게 스타레이크는 가장 까다로운 데이터 엔지니어링 및 분석 도전에 대비할 준비가 되어 있다고 말할 수 있습니다.\n\n\n\n스타레이크는 지금 그리고 항상 오픈 소스입니다. 지원하는 커뮤니티 구축에 참여해 주세요. 여러분의 의견과 기능 요청은 환영받을 뿐만 아니라 우리 로드맵을 이끕니다.\n\n스타레이크를 시작해보세요:\n\n- 다른 기능을 살펴보세요.\n- 문서를 살펴보세요.\n\nGitHub에서 저희 커뮤니티에 참여해 주세요.\n\n\n\n제발 이 저장소에 별을 주세요: https://github.com/starlake-ai/starlake. Starlake 관련 문제나 개선사항이 있으면 언제든지 알려주세요. 물론 친절한 관리 대상이 될 겁니다.","ogImage":{"url":"/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png"},"coverImage":"/assets/img/2024-05-15-StarlakeOSSBringingDeclarativeProgrammingtoDataEngineeringandDataAnalytics_0.png","tag":["Tech"],"readingTime":4},{"title":"Pew의 Fiscal 50을 역동적 시각화로 개편하기","description":"","date":"2024-05-15 11:16","slug":"2024-05-15-RevampingPewsFiscal50withDynamicVisualizations","content":"\n\n## Pew은 Graphicacy와 협력하여 2013년에 사이트를 발표한 후, Fiscal 50 웹사이트를 새롭게 할 필요를 느꼈습니다. 이 때문에 새로운 모바일 친화적이고 현대적인 디자인으로 업그레이드되었으며 새로운 주별 페이지가 추가되었습니다.\n\n2013년, Pew은 Fiscal 50을 론칭했는데, 이는 주요 정책 결정자, 언론 및 대중이 장기간 예산 트렌드를 이해하는 데 도움을 주기 위한 것이었습니다. 이 사이트에는 주별 장기적인 재정 건강을 측정하는 재정 및 경제 지표에 대한 상호작용 그래픽이 특징이었습니다.\n\n론칭 당시 혁신적인 Fiscal 50은 곧 존경받는 자원이 되었습니다. 그러나 10주년을 기념하는 이 시점에 사이트가 낡아 보이기 시작했습니다.\n\nFiscal 50 사이트를 새롭게 소생시키고 현대적으로 만들기 위해 Pew은 Graphicacy와 협력하여 새로운 차트를 포함한 응답형 그래픽을 재디자인 및 개발하였으며, 주 수준의 집중도를 높이고 새로운 데이터가 업데이트될 때 텍스트와 숫자를 정기적으로 업데이트할 수 있는 창의적인 프로세스를 발전시켰습니다.\n\n\n\n![그림](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png)\n\n## 신뢰할 수 있는 자료를 기반으로\n\n\"Fiscal 50 프로젝트 디렉터인 멜리사 메이너드는 '10년이 지난 후에는 이 작업을 재구상할 필요가 있었습니다.'라고 말했습니다. '사용자들이 플랫폼에서 무엇을 얻고 있기를 원했는지, 그리고 기대하고 있던 것들 뿐만 아니라, 새로운 접근 방식을 도입하고 실험을 해야 할 필요성도 명확히 보았습니다.'\"\n\nPew의 창의적인 팀원 중 한 명이 멜리사가 Graphicacy에 연락을 취해보라고 권유했는데, 두 기관의 방식과 미학이 일치했습니다. 경쟁 입찰 과정을 통해 Pew 팀은 Graphicacy가 프로젝트의 비전과 목표를 완전히 받아들였고 혁신적인 아이디어를 제시할 것이라는 것을 명확히 알게 되었습니다. 멜리사는 \"Graphicacy와 협업하는 것은 우리를 안락지대에서 빼내 줄 것\"이라고 지적했습니다.\n\n\n\nGraphicacy의 추가로 Fiscal 50, Pew 창조 및 디지턈, Graphicacy 팀 간에 \"엄청난 강력한 3단 창조적 협업\"이 만들어졌다고 덧붙였다. 매 팀원이 그들의 강점과 직관을 가지고 전반적인 프로젝트를 더 도전적인 방향으로 이끌었다.\n\n## 서로의 언어를 말하기\n\nGraphicacy는 Fiscal 50 사이트의 상하구조를 완전히 재구성하는 도전을 환영했다. \"우리는 즉시 더 반응성이 있고 유연한 플랫폼이 필요하다는 것을 알았습니다,\"라고 말한 Carni Klirs, Graphicacy의 창조적 이사, 데이터 시각화. \"Pew와 협력하여 어떤 장치에서도 작동하고 최신 브라우저에서 실행되는 새 모바일 중심 사이트를 구축하고자 했습니다.\"\n\nPew도 시간이 지남에 따라 더 많은 차트 뷰를 추가하고 자신들의 데이터를 쉽게 업데이트할 수 있는 플랫폼이 필요했다. \"사이트는 몇 주마다 콘텐츠를 새롭게 업데이트할 것이며,\" Melissa가 말했다. \"그리고 Fiscal 50의 여덟 가지 주요 지표는 신선한 데이터가 사용 가능해질 때마다 매년 한 두 차례 업데이트될 것이다.\"\n\n\n\n빈번한 사이트 변경을 위해 Graphicacy는 Fiscal 50 팀을 위한 툴킷을 구축했습니다. \"우리는 Pew의 창의적 및 디지털 팀과 협력하여 툴킷을 활용하고, Graphicacy와 계속 협력하여 향상시키는 데 도움을 줄 것입니다,\" 멜리사가 설명했습니다.\n\n\"사이트를 업데이트하는 방법을 알아내면서 서로의 언어를 배워야 했습니다,\" 그녀는 덧붙였습니다. \"Carni와 Graphicacy 팀은 훌륭한 커뮤니케이터였습니다. 그들은 우리를 들어주고, 우리 방식을 배우고, 학습 곡선을 통해 도와주기 위해 시간을 내주었습니다.\"\n\n## 주 State Level에서 동적 데이터\n\nFiscal 50 사이트를 현대적이고 모바일 중심의 시대로 가져올 뿐만 아니라, Graphicacy는 Pew가 처음으로 각 주별 페이지를 작성해야 하는 필요를 처리했습니다.\n\n\n\n\"우리의 청중 중 일부는 국가적 관점에서 주요 예산 동향을 따라가지만 대부분의 사람들은 주변 주의 관점에서 우리의 데이터와 연구가 무슨 뜻을 갖는지에 주로 관심이 있습니다,\" Melissa는 말했습니다.\n\n\"이 전면 개편으로 Graphicacy는 각 주를 위한 데이터와 우리의 통찰을 다시 구성하는 데 도움을 주었는데, 동시에 국가적 및 지역적 맥락을 제공하는 방식으로도했어요.\"\n\n이에 Graphicacy는 Pew의 재정 팀의 데이터와 연구 통찰을 결합한 동적 주별 페이지를 만들었습니다. 이 페이지들은 각 주의 여덟 가지 주요 지표의 성과를 보여주며, 모든 지표에는 더 자세한 정보를 보여주는 확장 가능한 대화식 도트 플롯이 있습니다.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_1.png)\n\n\n\n국가 페이지는 이제 completely redesigned되어 상단부터 완전히 다시 만들어진 Indicator 페이지와 함께 존재합니다. Pew와 Graphicacy는 페이지의 구조와 흐름에 협력하여 차트 뷰 사이에 설명 텍스트를 엮어 독자들의 이해를 돕는데 협력했습니다.\n\n\"Carni는 '우리는 지도, 선 그래프, 영역 차트, 몇 가지 다른 종류의 타일 지도 및 막대 차트를 포함한 포괄적인 차트 시스템을 설계하고 구축했습니다. 각 차트는 다른 지표 간에 재사용될 수 있도록 유연하게 설계되었으며, 고도의 사용자 정의가 가능했습니다'\"라고 말했습니다.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_2.png)\n\n## 데이터 중심 텍스트\n\n\n\n이러한 새로운 기능을 지원하고 자주 업데이트를 가능하게 하기 위해 Graphicacy는 개편된 Fiscal 50을 위한 혁신적인 기능을 개발했습니다: 데이터 기반 텍스트.\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_3.png)\n\n![이미지](/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_4.png)\n\n\"우리는 Pew가 데이터 값으로 대체될 수 있는 토큰을 사용하여 서술 텍스트를 작성할 수 있는 동적 텍스트 엔진을 개발했습니다. 이러한 값들은 차트에 표시된 현재 데이터를 보여주기 위해 실시간으로 업데이트됩니다. 이 엔진은 '크다' 또는 '작다'와 같은 함수 및 조건문을 처리할 수도 있습니다. 예를 들어 숫자가 다른 숫자보다 높거나 낮다면 해당 내용을 표시할 수 있습니다,\" Carni이 설명했습니다. \"동적 텍스트를 사용하여 복사본을 작성하는 것이 처음에는 약간 어려울 수 있지만, 우리는 그들이 자신감을 갖고 사용할 수 있도록 훈련시켰습니다.\"\n\n\n\n\"데이터 기반 캡션은 각 주에 특화된 추가적인 세분화 및 통찰을 제공합니다,\" Melissa가 말했습니다. \"정기적인 데이터 업데이트가 있기 때문에, 이들은 많은 작업을 대신하고 새 플랫폼을 위해 추가 콘텐츠를 생산하는 데 직원의 시간을 절약할 것입니다.\"\n\n동적 캡션을 활용하면 Pew의 팀이 일하는 부담이 줄어들지만, 이는 해당 기관으로 유명한 깊이 있는 분석을 유지합니다. \"우리는 아직도 데이터를 통해 독자를 안내하고 '전체 의미는 무엇인가?'라는 질문에 답하는 자세한 분석을 제공하고 있습니다.\"\n\n## 계속되는 협업\n\n새 Fiscal 50 웹사이트가 론칭되면, Melissa는 Graphicacy와 계속해서 사이트를 개선하고 툴킷을 강화하는 과정에서 지속적인 협업에 기대하고 있습니다.\n\n\n\n“Graphicacy와 Pew의 파트너십은 모두의 강점을 살렸다고 해요,\" 그녀가 말했습니다. “우리는 Graphicacy가 항상 우리의 의견을 경청해주고, Fiscal 50가 잘 작동하는 비결을 배우려는 의지에 감동받았습니다. 우리가 상상한 것 이상을 이룰 수 있도록 이끄는 모습도 인상적이었죠.\"\n\nGraphicacy는 귀하와 같은 기관들이 자료, 숫자, 트렌드를 활용하여 권위 있는, 도발적이고, 영감을 주는 이야기를 전달하는 데 도움을 줍니다. 이를 통해 귀하의 사명이 중요한 이유와 관중이 그 문제와 귀하의 작업에 어떤 역할을 해야 하는지를 안내합니다.\n\n이것이 시각적 이야기의 힘입니다. 이는 사람들을 끌어들이고 그들을 문제와 여러분의 작업에 감정적으로 이어줍니다. 이는 그들이 눈을 뗄 수 없는 경험을 만들어주며, 문제에 대해 무언가를 하도록 초대합니다.\n\nGraphicacy는 빌 앤 멜린다 게이츠 재단, 세계자원 연구소, Everytown for Gun Safety, 세계은행, 존스 홉킨스 대학 보름버그 보건학교 등 국내외의 최고 기관 및 기업을 위해 데이터 시각화 및 인포그래픽을 제작해왔습니다.","ogImage":{"url":"/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png"},"coverImage":"/assets/img/2024-05-15-RevampingPewsFiscal50withDynamicVisualizations_0.png","tag":["Tech"],"readingTime":5},{"title":"Windows 키 조합 단축키의 숨겨진 잠재력을 발견하세요","description":"","date":"2024-05-15 11:14","slug":"2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts","content":"\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png)\n\n# 윈도우 키, 시작 메뉴로만 사용되는 것이 아닙니다!!\n\n많은 사람들이 키보드의 윈도우 키(윈도우 로고 키)가 시작 메뉴를 열 뿐이라고 생각합니다(Ctrl+Esc로도 동일한 기능이 수행됩니다). 하지만 다른 키들과 함께 누르면 강력한 바로 가기가 트리거되어 업무 흐름을 변화시키며, 결국에는 마우스를 사용하지 않고 키보드로만 탐색할 수 있게 됩니다.\n\n마우스로 클릭하는 것도 작업을 완료할 수 있지만, 키보드 바로 가기는 속도 면에서 이점을 제공하며 키보드에 손을 유지하는 것이 장점입니다. 키보드 바로 가기는 마우스 클릭보다 더 빠르게 작동할 수 있습니다. 이 글에서는 윈도우 10/11에서 시작하는 데 유용한 일부 바로 가기 키에 초점을 맞춰 설명하겠습니다. 이러한 바로 가기는 특정 작업을 더 쉽고 빠르게 시작하고 수행할 수 있습니다.\n\n\n\n와~ 키보드 단축키를 숙달하고 단디 타이핑을 하려면 전체 단축키를 한 번에 외운 것이 힘듭니다. 시작해보시면 어느샐 것에요. 꾸준한 사용이 중요하니까, 키보드 단축키 프로가 되고 싶다면 꾸준한 사용이 필수에요!!\n\n그래서, 그걸 한 번 살펴봅시다!\n\n- `Windows 키 + Q 또는 S`: Cortana 검색창을 연 상태로 타입 인풋을 사용할 수 있어요.\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_1.png)\n\n\n\n- `Windows 키 + W`: 위젯 메뉴 열기\n\n- `Windows 키 + E`: 파일 탐색기 열기\n\n- `Windows 키 + R`: 실행 명령 열기\n\n![Windows Key Combination Shortcuts](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_2.png)\n\n\n\n- `Windows 키 + T: 작업 표시줄에 고정된/열린 아이콘에 초점\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_3.png)\n\n- `Windows 키 + Y: 데스크탑과 Windows Mixed Reality 간의 입력 전환\n\nWindows Mixed Reality와 데스크탑 간의 입력을 전환하는 바로 가기로 사용됩니다. Windows Mixed Reality 장치를 사용 중이라면 이 키 조합이 매우 편리할 수 있습니다!\n\n\n\n- `Windows 키 + U`: 접근성 설정 화면 열기\n\n![](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_4.png)\n\n- `Windows 키 + I`: 시스템 설정 화면 열기\n\n- `Windows 키 + O`: 기기 방향 잠금\n\n\n\n- `Windows 키 + P` : 프레젠테이션 또는 프로젝션 사이드바 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_5.png)\n\n- `Windows 키 + A` : 빠른 설정 패널 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_6.png)\n\n\n\n- `Windows 키 + D`: 열린 응용 프로그램 최소화 및 최대화하기\n\n- `Windows 키 + F`: 피드백 허브 열기\n\n- `Windows 키 + G`: Xbox 게임 바 열기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_7.png)\n\n\n\n이 기능을 사용하면 게임을하는 동안 비디오를 녹화하고 스크린 샷을 찍거나 서드파티 응용 프로그램없이 원하는 작업을 할 수 있습니다.\n\n- ` Windows 키 + H : 음성 입력 팝업\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_8.png)\n\n- ` Windows 키 + J : Windows 팁에 포커스 설정시 옵션이 사용 가능합니다.\n\n\n\n- ` Windows 키 + K: 캐스트 패널 열림\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_9.png)\n\n- ` Windows 키 + L: PC 잠금 또는 계정 전환\n\n- ` Windows 키 + Z: Snap Layout 메뉴\n\n\n\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_10.png)\n\nThis feature makes it easier to arrange multiple apps side by side on your screen.\n\n- Windows key + X: Opens the Quick Link menu\n- Windows key + C: It will open Microsoft’s Copilot\n\n\n\n\n- `Windows 키 + V: 클립보드 팝업\n\n- `Windows 키 + B: 숨겨진 아이콘 보기\n\n![이미지](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_11.png)\n\n- `Windows 키 + N: 알림 센터 및 캘린더 열기\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_12.png\" /\u003e\n\n- `Windows key + M`: 모든 열려 있는 애플리케이션을 최소화합니다.\n\n최소화한 모든 창을 복원하려면 'Windows 키 + Shift + M'을 누르세요.\n\n- `Windows key + Comma (,)`: 일시적으로 앱을 숨겨서 데스크톱을 보여줍니다.\n\n\n\n- `Windows 키 + 마침표 (.) 또는 세미콜론 (;)`: 이모지 패널을 팝업합니다.\n\n- `Windows 키 + 1-9 숫자`: 작업 표시줄의 고정된 애플리케이션을 번호순으로 액세스합니다.\n\n![image](/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_13.png)\n\n이 목록은 Windows 키의 가능성을 약간 소개한 것에 불과합니다. 특정 애플리케이션에 대한 바로 가기키를 탐색하고 사용 환경을 맞춤 설정해보세요. 조금의 연습을 통해 Windows를 전문가처럼 탐색하고 소중한 시간을 절약할 수 있을 겁니다!\n\n\n\n그럼에도 불구하고 때때로 필요한 유용한 단축키들이 많이 있습니다. 이들은 윈도우 키를 다른 키/키와 결합하여 더 효율적으로 작업을 수행하는 것을 포함합니다. 모든 것을 기억하는 것은 불가능하지만, 미래 참조를 위해 이 페이지를 즐겨찾기하는 것이 좋은 생각일 수 있습니다. 그리고 더 많은 콘텐츠를 보려면 팔로우해주세요.\n\n업데이트를 받기 위해 다른 플랫폼에서도 저를 팔로우해 주시기 바랍니다.\n\nGitHub | LinkedIn | Twitter(X)","ogImage":{"url":"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png"},"coverImage":"/assets/img/2024-05-15-UnveilingtheHiddenPotentialofWindowsKeyCombinationShortcuts_0.png","tag":["Tech"],"readingTime":4},{"title":"컨테이너 내부 시리즈 파트 3 마운트 네임스페이스","description":"","date":"2024-05-15 11:11","slug":"2024-05-15-ContainerInternalsSeriesPart3MountNamespace","content":"\n\n## Golang을 사용하여 Linux 마운트 네임스페이스 만들기\n\n안녕하세요! 이번 글은 시리즈 중 세 번째로, Golang을 사용하여 마운트 네임스페이스를 만드는 방법을 보여드리겠습니다. 마운트 네임스페이스에서 사용되는 명령어와 기본 구성 요소에 대해 알아보고, 이것들이 컨테이너와 어떻게 연관되는지 살펴보겠습니다. 이 시리즈는 컨테이너에 중점을 두지만, 실제로는 프로세스를 실험함으로써 간단하게 설명하고 있습니다. 컨테이너는 본질적으로 프로세스 + 어떤 기본적인 요소로 구성되기 때문입니다. 그럼에도 불구하고, 이곳에서 논의하는 원칙들은 동일하게 적용됩니다.\n\n많은 경우에 리눅스 네임스페이스의 이론은 간단할 수 있지만, 실제로는 처음 보는 것보다 다소 복잡할 수 있습니다. 마운트 네임스페이스에 대한 일반적인 개념을 제공하는 많은 자료가 있으므로, 우리는 핵심적인 부분에 초점을 맞출 것입니다. 우리가 살펴볼 중요한 두 가지 요소는 `mount`와 `pivot_root` 명령어입니다. 이를 통해 우리는 모든 것이 어떻게 컨테이너와 마운트 네임스페이스의 개념에 잘 들어맞는지 이해할 수 있을 것입니다.\n\n\n\n# mount()\n\n리눅스 문서에 따르면:\n\n내 설명을 조금 더 자세히 하자면:\n\nmount 명령은 시스템에 있는 장치나 가상 파일 시스템의 파일 시스템을 연결할 수 있는 도구입니다. 이를 통해 해당 파일 시스템을 탐색할 수 있습니다. 어떤 일이 벌어지는지 예를 들어 설명하자면, 컴퓨터에 USB를 연결하면 USB에 있는 이미지와 같은 파일을 검색하고 스크롤할 수 있습니다. 하지만 사용자가 직접 작업하지 않았다면, mount 명령이 백그라운드에서 발생하고 있음을 알 수 없습니다. 그렇지 않다면 이미지를 검색할 수 없습니다. USB를 분리하고자 할 때 컴퓨터가 손상을 방지하기 위해 제대로 분리하라는 메시지를 표시하는 경우도 있을텐데, 이는 umount (즉, \"unmount\"라고도 함) 명령을 사용하여 이루어집니다.\n\n\n\n당신이 놀라실지 모르겠지만, 컴퓨터에 꽂는 USB 드라이브뿐만 아니라 프로시 파일 시스템이나 tmpfs와 같은 가상 파일 시스템에도 해당됩니다. Linux에서 부팅 시 자동으로 마운트되는 모든 가상 파일 시스템 및 장치를 확인할 수 있습니다:\n\n```shell\ncat /etc/fstab\n```\n\n또는 현재 마운트된 장치를 확인하려면:\n\n```shell\ncat /etc/mtab\n```\n\n\n\n부팅 시 마운트된 루트 폴더도 동일하게 적용됩니다. 몇 가지 콘텍스트를 제공하겠습니다 — 컨테이너 관점에서, 컨테이너 이미지에는 파일 시스템이 포함되어 있고 이를 동일한 컨테이너 프로세스가 루트 파일 시스템으로 보기를 원합니다. 내부적으로는 pivot_root를 사용하여 이를 달성합니다. 일반적인 관점에서 이를 살펴보겠습니다.\n\n\n\n현재 프로세스의 마운트 포인트를 확인하려면 다음을 사용하세요:\n\n```js\ngrep -iP '/ /\\s' /proc/$$/mountinfo\n```\n\n현재 루트가 /dev/sda*와 같은 디스크를 통해 또는 네트워크를 통해 마운트된 것을 볼 수 있을 겁니다. pivot_root 명령어를 사용하면 현재 루트를 예를 들어 하위 디렉토리로 변경할 수 있습니다. 그러나 이를 수행하기 위한 몇 가지 요구 사항이 있습니다:\n\n- new_root와 put_old는 디렉토리여야 합니다.\n- new_root와 put_old는 현재 루트와 동일한 마운트 지점에 있어서는 안 됩니다.\n- put_old는 new_root의 하위에 있거나 동일해야 합니다; 다시 말해, put_old가 가리키는 경로에 ../접미사의 양의 정수를 추가하면 new_root와 동일한 디렉토리가 나와야 합니다.\n- new_root는 마운트 지점의 경로여야 하지만 /일 수 없습니다. 마운트 지점이 아닌 경로는 스스로에 바인드 마운트하여 마운트 지점으로 변환할 수 있습니다.\n- new_root의 상위 마운트의 전파 유형과 현재 루트 디렉토리의 상위 마운트의 전파 유형이 MS_SHARED여서는 안 되며, 비슷하게, put_old가 기존의 마운트 지점인 경우 해당 전파 유형도 MS_SHARED일 수 없습니다. 이러한 제한 사항은 pivot_root()가 다른 마운트 네임스페이스로 변경 사항을 전파하지 않도록 합니다.\n- 현재 루트 디렉토리는 마운트 지점이어야 합니다.\n\n\n\n저희 코드는 이러한 요구 사항을 충족할 것이지만, 저희가 논의한 두 명령어로부터 중요한 점은 마운트 네임스페이스가 필요하다는 것입니다. 이는 pivot_root가 호스트의 루트 마운트가 아닌 \"자식/컨테이너\" 네임스페이스 내의 루트 마운트에 영향을 미치도록 해야 한다는 것입니다. 이것이 바로 VM과 컨테이너와 같은 단위가 우리가 정의한 경계를 벗어나 호스트에 영향을 미치지 못하도록 하는 격리의 목표입니다.\n\n# 코드 예시\n\n지난 글에서처럼, 코드 코멘트를 사용하여 기술적인 세부 사항을 안내해 드리겠습니다. 이 방법이 저희가 사용하는 기능을 이해하는 데 훨씬 더 간단하게 만들어준다고 믿습니다.\n\n이 코드는 다음을 수행합니다:\n\n\n\n- 새로운 루트를 마운트 포인트로 만들기 위해 mount bind를 생성합니다\n- 새로운 마운트 네임스페이스를 생성합니다\n- 새로운 마운트 네임스페이스 내에서 Pivot Root를 수행합니다\n- 증명 목적으로 /proc 및 /dev를 마운트합니다\n- 이전 루트를 언마운트합니다\n- 새로운 루트 내에서 /bin/sh를 엽니다\n\n```js\npackage main\n\nimport (\n \"os\"\n \"os/exec\"\n \"log\"\n \"syscall\"\n)\n\nfunc setupNewMountNamespace(newRoot string, putOld string) {\n // 새로운 루트를 자신에 묶음 - 약간의 해킹\n // PIVOT_ROOT 요구 사항 - \"new_root는 마운트 포인트의 경로여야 합니다\"\n // MS_BIND - 바인드 마운트 생성\n // MS_REC - 소스의 모든 하위 마운트에 재귀적으로 마운트 (동작) 적용\n if err := syscall.Mount(newRoot, newRoot, \"\", syscall.MS_BIND|syscall.MS_REC, \"\"); err != nil {\n  log.Fatalln(\"새 루트 파일 시스템을 마운트하지 못했습니다: \", err)\n }\n\n // 이전 루트를위한 디렉토리 생성\n // PIVOT_ROOT 요구 사항 - put_old는 new_root의 하위 위치에 있어야 함\n if err := syscall.Mkdir(newRoot+putOld, 0700); err != nil {\n  log.Fatalln(\"mkdir를 실패했습니다: \", err)\n }\n\n // 현재 프로세스를 소속되어 있는 마운트 네임스페이스와 분리하며, 새로운 마운트 네임스페이스를 생성합니다\n  if err := syscall.Unshare(syscall.CLONE_NEWNS); err != nil {\n    log.Fatalf(\"Unshare 시스템 호출에 실패했습니다: %v\\n\", err)\n  }\n\n // 새로운 루트 파일 시스템으로 pivot_root\n // 참고: 작동하지 않으면 위에 나열된 요구 사항을 다시 확인하세요\n if err := syscall.PivotRoot(newRoot, newRoot+putOld); err != nil {\n  log.Fatalln(\"pivot root를 실패했습니다: \", err)\n }\n\n // 현재 작업 디렉토리를 새 마운트 네임스페이스에서 \"/\"\"로 변경합니다\n if err := syscall.Chdir(\"/\"); err != nil {\n  log.Fatalln(\"/로 chdir를 변경하지 못했습니다: \", err)\n }\n\n // /proc를 마운트합니다\n if err := syscall.Mount(\"/proc\", \"/proc\", \"proc\", 0, \"\"); err != nil {\n  log.Fatalln(\"/proc를 마운트하지 못했습니다: \", err)\n }\n\n // 아래와 같이 'mount' 및 'readlink'와 같은 명령을 호출할 수 있어야 합니다\n if err := syscall.Mount(\"/dev\", \"/dev\", \"tmpfs\", 0, \"\"); err != nil {\n  log.Fatalln(\"/dev를 마운트하지 못했습니다: \", err)\n }\n file, err := os.Create(\"/dev/null\"); if err != nil {\n   log.Fatal(err)\n }\n defer file.Close()\n\n // 이전 루트 파일 시스템을 언마운트합니다\n if err := syscall.Unmount(putOld, syscall.MNT_DETACH); err != nil {\n  log.Fatalln(\"이전 루트 파일 시스템을 언마운트하지 못했습니다: \", err)\n }\n}\n\nfunc main() {\n processID := os.Getpid()\n log.Printf(\"프로세스 ID: %d\\n\", processID)\n\n // 현재 마운트 네임스페이스를 확인합니다\n out, err := exec.Command(\"readlink\", \"/proc/self/ns/mnt\").Output(); if err != nil {\n  log.Fatalf(\"네임스페이스 파일을 읽는 중 오류 발생: %v\\n\", err)\n }\n log.Printf(\"프로세스는 현재 이전 마운트 네임스페이스에 있습니다: %s\", string(out))\n\n newRoot := \"new_root\"\n putOld := \"/old_root\"\n setupNewMountNamespace(newRoot, putOld)\n\n // 현재 마운트 네임스페이스를 확인합니다\n out1, err := exec.Command(\"readlink\", \"/proc/self/ns/mnt\").Output(); if err != nil {\n  log.Fatalf(\"네임스페이스 파일을 읽는 중 오류 발생: %v\\n\", err)\n }\n log.Printf(\"프로세스는 이제 새 마운트 네임스페이스에 있습니다: %s\", string(out1))\n\n log.Println(\"새 마운트 네임스페이스에서 셸 (bin/sh)을 열고 'mount', 'lsns' 등 명령을 실행합니다.\")\n cmd := exec.Command(\"/bin/sh\")\n cmd.Stdin = os.Stdin\n cmd.Stdout = os.Stdout\n cmd.Stderr = os.Stderr\n if err := cmd.Run(); err != nil {\n  log.Println(\"명령 실행에 실패했습니다: \", err)\n  os.Exit(1)\n }\n}\n```\n\n# 결론\n\n요약하자면, 이 기사에서는 Golang을 사용하여 마운트 네임스페이스를 생성하고, mount 및 pivot_root와 같은 주요 명령을 강조했습니다. 코드 예제를 통해 컨테이너 격리에서 마운트 네임스페이스의 역할을 명료하게 했기를 바랍니다.","ogImage":{"url":"/assets/img/2024-05-15-ContainerInternalsSeriesPart3MountNamespace_0.png"},"coverImage":"/assets/img/2024-05-15-ContainerInternalsSeriesPart3MountNamespace_0.png","tag":["Tech"],"readingTime":6},{"title":"타입스크립트에서 레이블 문의 마법을 공개합니다","description":"","date":"2024-05-15 11:10","slug":"2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift","content":"\n\n라벨 지정문은 다른 Swift 기능들만큼 화려하지는 않지만, 코드 가독성과 흐름 제어를 크게 향상시킬 수 있는 독특한 유연성을 지니고 있어요.\n\n라벨 지정문을 사용하면 if, switch 또는 do 문과 같이 코드의 특정 부분에 이름을 지정할 수 있어요. 이는 중첩된 루프를 벗어나는 데 도움을 줄 수 있어요.\n\n아래에는 라벨이 지정된 루프의 기본 예제가 있어요.\n\n아래 코드에서는 제곱했을 때 4가 되는 첫 번째 숫자를 찾으려고 해요.\n\n\n\n```js\nlet numbers = 1...50\n\nfor number1 in numbers {\n    for number2 in numbers {\n        if number1 == number2 \u0026\u0026 number1 * number2 == 4  {\n            print(number1)\n            break // 외부 루프를 종료시키지 않습니다\n        }\n    }\n}\n```\n\n라벨을 사용하면 많은 도움을 받을 수 있습니다.\n\n```js\nlet numbers = 1...50\n\nouterLoop: for number1 in numbers {\n    for number2 in numbers {\n        if number1 == number2 \u0026\u0026 number1 * number2 == 4  {\n            print(number1)\n            break outerLoop // 외부 루프를 종료시킵니다\n        }\n    }\n}\n```","ogImage":{"url":"/assets/img/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift_0.png"},"coverImage":"/assets/img/2024-05-15-UnveilingtheMagicofLabelledStatementsinSwift_0.png","tag":["Tech"],"readingTime":1},{"title":"AWS에서 이력서를 Terraform으로 만들어보세요 I","description":"","date":"2024-05-15 11:08","slug":"2024-05-15-GetyourResumeTerraformedinAWSI","content":"\n\n안녕하세요! 👋 여러분! 오랜만이죠. 여기에 유용한(아니면 흥미로운?) 기사 몇 개를 올리고 싶다고 생각한 지 오래되었습니다. 그런데 좋거나 유용한 아이디어가 생각나지 않았어요. 몇 주 전 나를 위해 한 작업을 문서화하는 아이디어를 만났는데요: 이력서의 HTML 버전을 AWS에 Terraform과 GitHub Actions을 통해 배포(자동화)하는 것입니다. 요즘에는 이런 기술을 이력서에 넣는 것이 흥미로울 것 같아요. 근데 이력서 안에 그런 기술을 보여주면 어때요? 😜\n\n이런 작업을 어떻게 하는지 보여주는 많은 비디오/튜토리얼은 AWS 콘솔에서 \"클릭 단계별\"로 진행하는 것을 보여줍니다. 그러나 저는 Terraform + GithubActions 방법을 소개할 거에요, 더 흥미로울 것 같다고 봅니다.\n\n이 글은 두 편 중 첫 번째 입니다. 여러분이 지역 (HTML 형식)으로 배포된 이력서를 AWS(S3)에 보관하고 https://antonirs.com 같은 URL을 통해 접근 가능하게 하는 방법을 단계별로 안내할 거에요. 그리고 또한 매 푸시마다 새 버전을 자동으로 배포하는 ⚙️GitHub Actions 파이프라인⚙️ 도 설정할 거에요. 이 자동화 부분은 이 첫 번째 글에서 다루지 않고 두 번째 글에서 다뤄요.\n\n이 글을 따라가는 동안 제 개인 이력서 저장소에서 모든 소스 코드를 확인할 수 있어요. 즐겨보세요!\n\n\n\n# 인프라 구조 이해하기\n\n![이미지](/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png)\n\n우리가 구축할 내용을 크게 보여드립니다. 첫 번째 기사에서 Terraform을 사용하여 컴포넌트를 구축하고 연결하며 함께 작동시키는 방법을 안내해 드리겠습니다. 아키텍처는 전혀 복잡하지 않으므로, 모두 구축하기 위해 AWS의 \"단지\" 4가지 서비스를 사용할 예정입니다.\n\n# 이전 요구 사항\n\n\n\n일할 때 필요한 몇 가지가 있습니다:\n1. AWS 계정. 꽤 명백한 🤷🏼‍♂️ 당연하지만 필수입니다. AWS는 이 문서에서 한 단계씩 안내하여 계정을 설정하는 방법을 제공합니다.\n2. Terraform CLI 설치. 터미널에 terraform CLI가 설치되어 있어야 합니다. Hashicorp에서 설치 방법을 안내합니다.\n3. 등록된 도메인. 이 문서에서는 구매 및 AWS에서 처리된 도메인을 가지고 있다고 가정하지만, 반드시 그렇게 할 필요는 없습니다.\n4. 이력서의 HTML 버전. S3 버킷에 저장되고 CloudFront를 통해 제공될 것입니다.\n\n# 일하러 가볼까요 💪🏻\n\n저의 저장소에서 완전한 작동 솔루션을 제공받을 수 있기 때문에 👀, 단계별로 자세히 설명하지는 않겠지만 각 부분의 가장 중요한 요소에 대해 주석을 달겠습니다.\n\n## 단계 0: 도메인 구매 및 호스팅 존 생성\n\n\n\n도메인 (나의 경우에는 antonirs.com)의 구매와 호스팅 영역 생성은 Terraform으로 만들지 못하는 유일한 부분이며, 대신 AWS 콘솔에서 수동으로 처리해야 합니다.\n\n다른 제공업체에 도메인을 호스팅할 수도 있습니다. 이 경우 추가 구성이 필요할 수 있지만 (그 외에는 문제가 없습니다), 이 경우에는 AWS에서 호스팅되는 경우를 다루겠습니다.\n\n## 단계 1: Terraform으로 시작하기. AWS 제공자 설정\n\nTerraform 프로젝트의 시작점은 일반적으로 AWS 제공자 및 사용할 백엔드 구성을 설정하는 것입니다. 이를 통해 Terraform에게 AWS와의 인증 방법, 리소스를 배포할 지역 및 인프라의 tfstate를 저장할 위치를 알려줍니다. 이 구성을 provider.tf 파일에 넣어주세요.\n\n\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n  access_key = \"내 액세스 키\"\n  secret_key = \"내 시크릿 액세스 키\"\n}\n```\n\n액세스 키와 시크릿 키는 절대로 리포지토리에 푸시해서는 안 되는 것을 염두에 두세요. 여기서 보여주고 있지만, 다음 글에서 깃허브 리포지토리의 시크릿 구성으로 이동하는 방법을 보여줄 것입니다.\n\n백엔드.tf에 대해 다음과 같이 보이도록 해야 합니다. 우리는 인프라의 상태를 저장하기 위해 S3를 사용할 것입니다:\n\n```js\nterraform {\n  backend \"s3\" {\n    bucket         = \"antoni-tf-state\"\n    key            = \"personal-portfolio/terraform.tfstate\"\n    region         = \"us-east-1\"\n    encrypt        = true\n  }\n}\n```\n\n\n\n## Step 2: S3 및 액세스 정책 생성\n\n여기서는 antoni-html-cv라는 S3 버킷을 생성하고, 여기서 중요한 부분은 우리가 정의하는 정책인 s3_policy입니다. Cloudfront에서 오는 요청을 제외하고 모든 수신 트래픽을 차단할 것입니다 ⛔.\n\n```js\nresource \"aws_s3_bucket\" \"personal_portfolio_bucket\" {\n  bucket = \"antoni-html-cv\"\n}\n\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_iam_policy_document\" \"s3_policy\" {\n  statement {\n    sid       = \"AllowCloudFrontServicePrincipal\"\n    effect    = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"cloudfront.amazonaws.com\"]\n    }\n    actions   = [\"s3:GetObject\"]\n    resources = [\"${aws_s3_bucket.personal_portfolio_bucket.arn}/*\"]\n    condition {\n      test     = \"StringEquals\"\n      variable = \"AWS:SourceArn\"\n      values   = [\"arn:aws:cloudfront::${data.aws_caller_identity.current.account_id}:distribution/${aws_cloudfront_distribution.portfolio_distribution.id}\"]\n    }\n  }\n}\n\nresource \"aws_s3_bucket_policy\" \"s3_policy\" {\n  bucket = aws_s3_bucket.personal_portfolio_bucket.id\n  policy = data.aws_iam_policy_document.s3_policy.json\n}\n```\n\n여기서 중요한 점은 정책을 통해 S3에 직접 액세스하는 것을 방지하고 Cloudfront가 내용을 가져오는 것을 허용한다는 것입니다 (고객에게 서비스하기 위해). 이를 수행하는 다른 방법도 있지만, 저는 현재 AWS가 가장 권장하는 Origin Access Control 접근 방식을 사용하기로 결정했습니다. OAC에 대한 자세한 정보는 [여기](링크)에서 확인할 수 있습니다.\n\n\n\n## 단계 3: SSL 인증서로 CloudFront 배포 설정하기\n\nCloudFront는 S3에서 정적 콘텐츠를 제공하는 데 사용할 AWS 서비스입니다. CloudFront는 CDN으로 작동하여 전 세계의 여러 위치(엣지 위치)에 콘텐츠를 캐시하여 더 빠르게 액세스할 수 있게 합니다. 또한, CloudFront를 사용하면 배포에 SSL/TLS 인증서를 첨부하여 웹 사이트 연결을 HTTPS로 강제할 수 있습니다.\n\n```js\nresource \"aws_cloudfront_origin_access_control\" \"portfolio_oac\" {\n  name        = \"OAC for Portfolio Website\"\n  description = \"OAC for antonirs portfolio website\"\n  origin_access_control_origin_type = \"s3\"\n\n  signing_behavior = \"always\"\n  signing_protocol = \"sigv4\"\n}\n\nresource \"aws_cloudfront_distribution\" \"portfolio_distribution\" {\n  origin {\n    domain_name = aws_s3_bucket.personal_portfolio_bucket.bucket_regional_domain_name\n    origin_id   = \"S3-antonirs-portfolio\"\n    origin_access_control_id = aws_cloudfront_origin_access_control.portfolio_oac.id\n  }\n\n  enabled = true\n  comment = \"Distribution for the antonirs.com static website\"\n  aliases = [\"antonirs.com\"]\n  default_root_object = \"index.html\"\n\n  default_cache_behavior {\n    allowed_methods  = [\"GET\", \"HEAD\", \"OPTIONS\"]\n    cached_methods   = [\"GET\", \"HEAD\"]\n\n    target_origin_id = \"S3-antonirs-portfolio\"\n\n    forwarded_values {\n      query_string = false\n      cookies {\n        forward = \"none\"\n      }\n    }\n\n    viewer_protocol_policy = \"redirect-to-https\"\n    min_ttl                = 0\n    default_ttl            = 86400\n    max_ttl                = 31536000\n  }\n\n  viewer_certificate {\n    acm_certificate_arn = aws_acm_certificate.personal_web_portfolio_cert.arn\n    ssl_support_method  = \"sni-only\"\n    minimum_protocol_version = \"TLSv1.2_2021\"\n  }\n\n  restrictions {\n    geo_restriction {\n      restriction_type = \"none\"\n    }\n  }\n\n  tags = {\n    Environment = \"production\"\n  }\n}\n```\n\n여기에는 많은 구성이 포함되어 있지만 주요 부분은 다음과 같습니다:\n-` 우리는 origin을 정의하여 CloudFront에게 데이터를 어디서 가져와야 하는지 알려줍니다(S3에서 가져옵니다).\n-` viewer_certificate 섹션을 사용하여 사용자 브라우저와 CloudFront 간의 안전한 연결(HTTPS)을 설정하는 SSL 인증서를 설정합니다.\n인증서를 생성하는 관련 명령에 대한 자세한 내용은 acm.tf에서 구성을 확인할 수 있습니다.\n\n\n\n```js\nresource \"aws_acm_certificate\" \"personal_web_portfolio_cert\" {\n  domain_name       = \"antonirs.com\"\n  validation_method = \"DNS\"\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_route53_record\" \"cert_validation\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.zone_id\n  name    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_name\n  type    = tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_type\n  records = [tolist(aws_acm_certificate.personal_web_portfolio_cert.domain_validation_options)[0].resource_record_value]\n  ttl     = 60\n}\n\nresource \"aws_acm_certificate_validation\" \"cert_validation\" {\n  certificate_arn         = aws_acm_certificate.personal_web_portfolio_cert.arn\n  validation_record_fqdns = [aws_route53_record.cert_validation.fqdn]\n}\n```\n\n인증서 구성 중 중요한 부분은 aws_acm_certificate_validation 섹션입니다. 이 인증서를 antonirs.com에 접속할 수 있게 하기 위해 Route53에 대해 이 인증서를 검증해야 합니다.\n\n## 단계 4: Route 53 설정\n\n인프라스트럭처에서말했던 것처럼 DNS 관리를 위해 Route 53을 사용할 것입니다. 글의 시작에서 말했듯이 이미 도메인(나의 경우엔 antonirs.com)과 AWS에 생성된 호스팅존이 있습니다. 다음 구성(route53.tf)을 따라 호스팅존 내에 A 레코드를 작성하고, CloudFront 배포로 가리키는 별칭으로 설정합니다.\n \n\n\n\n```js\ndata \"aws_route53_zone\" \"my_personal_zone\" {\n  name = \"antonirs.com.\"\n}\n\nresource \"aws_route53_record\" \"www\" {\n  zone_id = data.aws_route53_zone.my_personal_zone.id\n  name    = \"antonirs.com\"\n  type    = \"A\"\n\n  alias {\n    name                   = aws_cloudfront_distribution.portfolio_distribution.domain_name\n    zone_id                = aws_cloudfront_distribution.portfolio_distribution.hosted_zone_id\n    evaluate_target_health = false\n  }\n}\n```\n\n## 단계 5: 모든 것이 작동하는 것을 확인\n\n지금까지 본 것으로 충분히 준비되었습니다. 이제 \"한 번의 클릭\"으로 모든 인프라를 구축하여 https://antonirs.com (제 경우)을 방문하여 이력서를 확인할 수 있습니다.\n\n좋아요, 이중 따옴표를 조금 풀어볼게요. 모든 테라폼 파일이 준비된 상태에서 이제 해야 할 일은 터미널을 열고 다음을 실행하는 것입니다:\n1. terraform init 이 명령어를 실행하면 의존성을 다운로드하고 간단히 말해서 AWS와 상호 작용할 수 있는 디렉토리를 초기화합니다.\n2. terraform plan 이 명령어를 실행하면 실제 인프라에 반영되지 않은 tf 파일에 있는 모든 변경 사항을 출력합니다.\n3. terraform apply 이 명령어를 실행하면 인프라에서 실제 변경 사항을 만듭니다. Terraform 파일에 구성된 모든 리소스를 생성합니다.\n4. 이력서의 HTML 버전을 생성한 버킷에 업로드합니다.\n5. 방문(제 경우) https://antonirs.com 그리고... 즐기세요 😜 🚀\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_1.png\" /\u003e\n\n# 마무리 및 다음 단계\n\n와우! 여기까지 모두 읽은 것을 보니 매우 기뻐요🎊! 하하. 하지만 기쁨은 여기까지가 아닙니다. 다음 기사에서 더 흥미로워집니다. 조금 스포하겠습니다:\n\n이전의 \"단계 5\"를 보면 인프라를 배포하기 위해 \"상당히 많은\" 명령을 실행해야 한다는 것 같죠? 그런데 만약 웹사이트에 이력서의 새 버전을 업로드하려면 어떨까요? 새 버전을 업로드하려면 AWS 콘솔에 로그인해야 합니다 (또는 aws-cli를 사용해야 합니다)... 어찌 보면 그렇게 편리하지 않을 거예요.\n\n\n\n다음 기사에서는 GitHub Actions에서 모든 이러한 단계를 자동화하는 방법을 보여 드릴 것이기 때문에 기대해 주세요. 다음 기사에서는 또한 파이프라인에 우리의 비용을 제어하기 위한 💰infracost💰 통합에 관한 '보너스' 섹션을 공유할 예정이에요. 자세한 내용을 더 다루겠지만, 이는 우리 인프라 비용을 관리하는 데 매우 유용한 도구입니다. 계속 지켜보세요! 😉","ogImage":{"url":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png"},"coverImage":"/assets/img/2024-05-15-GetyourResumeTerraformedinAWSI_0.png","tag":["Tech"],"readingTime":9},{"title":"Harbor 시작하기 단계별 안내","description":"","date":"2024-05-15 11:06","slug":"2024-05-15-GettingStartedwithHarborAStep-by-StepGuide","content":"\n\nHarbor는 DockerHub, ECR 또는 ACR에 의존하지 않고 컨테이너 이미지를 안전하게 저장하고 관리하는 데 도움이 되는 오픈 소스 레지스트리입니다. Docker의 오픈 소스 레지스트리 위에 보안, 식별 및 관리 기능을 추가합니다. Harbor를 사용하면 이미지에 대한 정책을 설정하고 취약점을 검사하여 역할 기반 제어를 통해 액세스를 관리할 수 있습니다. 이는 컨테이너 이미지를 안전하고 잘 관리된 상태로 유지하려는 개발자들에게 필수적인 도구입니다.\n\n![Harbor 시작하기: 진행하기 전에](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png)\n\n## 전제 조건\n\n- Chocolatey 설치하기:\n\n\n\n- 관리자 권한으로 PowerShell 터미널을 열고 다음을 실행해주세요:\n\n```js\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n2. Chocolatey를 통해 Rancher Desktop을 설치하려면 다음 명령을 실행하세요:\n\n\n\n```js\nchoco install rancher-desktop\n```\n\n# 설정\n\n- 프로젝트 디렉토리를 생성하고 이동하세요:\n\n```js\nmkdir LearningHarbor cd LearningHarbor\n```\n\n\n\n2. Harbor Helm 저장소를 추가하고 Harbor 차트를 가져옵니다:\n\n```js\nhelm repo add harbor https://helm.goharbor.io\nhelm fetch harbor/harbor --untar cd harbor\n```\n\n3. values.yaml 파일을 편집합니다:\n\n- externalUrl 설정\n\n\n\n```js\nexternalURL: https://core.harbor.localhost\n```\n\n![Getting Started with Harbor: A Step-by-Step Guide](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_1.png)\n\n3. 윈도우 호스트 파일 수정:\n\n- 관리자 권한으로 텍스트 편집기에서 c:\\Windows\\System32\\Drivers\\etc\\hosts 파일을 엽니다.\n- 다음 줄을 추가하세요:\n\n\n\n```js\n127.0.0.1 core.harbor.localhost\n```\n\n![Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_2.png)\n\n# Harbor 배포\n\n- Harbor Helm 차트 설치:\n\n\n\n```js\nhelm upgrade harbor-release . --namespace harbor-helm --create-namespace --wait --install\n```\n\n2. 배포가 완료될 때까지 기다린 후 다음으로 이동하세요:\n\n- https://core.harbor.localhost\n\n![Getting Started with Harbor](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_3.png)\n\n\n\n3. 기본 자격 증명을 사용하여 로그인하세요:\n\n- 사용자명: admin\n- 비밀번호: Harbor12345\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_4.png)\n\n# 추가 구성\n\n\n\n- Docker를 사용하여 Harbor 레지스트리에 로그인하세요:\n\n```js\ndocker login https://core.harbor.localhost\n```\n\n동일한 자격 증명을 사용하세요:\n\n- 사용자 이름: admin\n- 비밀번호: Harbor12345\n\n\n\n# Harbor로 이미지 푸시하기\n\n참고: 사용할 로케이션 이미지인 aspiresample/api 및 aspiresample/web이 있습니다. 제 이미지 이름을 교체해도 괜찮습니다.\n\n- 이미지에 태그 붙이기\n\n```js\ndocker tag aspiresample/apiservice core.harbor.localhost/library/apiservice:latest\n```\n\n\n\n2. 이미지를 푸시하세요\n\n```js\ndocker push core.harbor.localhost/library/apiservice:latest\n```\n\n이제 Harbor UI에서 다음을 볼 수 있습니다\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_5.png)\n\n\n\n\n![이미지](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_6.png)\n\n# 고급 기능\n\nHarbor에는 기능을 향상시키는 몇 가지 고급 기능이 있습니다. 저는 이에 대해 자세히 다루지 않을 것입니다:\n\n- 외부 저장소 연결:\n\n\n\n\n- Harbor에 외부 저장소를 링크하고 정기적으로 해당 저장소에서 이미지를 복제하여 Harbor 레지스트리를 항상 최신 상태로 유지할 수 있습니다.\n\n![Step 7](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_7.png)\n\n![Step 8](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_8.png)\n\n2. 외부 인증:\n\n\n\n- Harbor은 Keycloak와 같은 외부 OIDC 서버와의 통합을 지원하여 사용자 관리와 싱글 사인온 기능을 제공합니다.\n\n![사진](/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_9.png)\n\n3. 할당량 설정:\n\n- 관리자는 프로젝트 및 저장소에 할당량을 설정하여 저장 공간 소비를 관리하고 조직 전체에서 적절하게 자원을 할당할 수 있습니다.\n\n\n\n# 마무리\n\n해법은 컨테이너 이미지를 관리하고 보호하는 강력한 솔루션을 제공합니다. 본 안내서에 나와 있는 단계에 따라 진행하면 신속하게 Harbor를 배포하여 이미지를 안전한 관리 환경에 저장할 수 있습니다. Harbor의 고급 기능인 외부 저장소 연결, 인증을 위해 Keycloak과 같은 OIDC 서버와 통합, 스토리지 할당량 설정 등은 그 유틸리티를 더욱 향상시킵니다. 이러한 기능들은 Harbor를 보안이며 효율적인 컨테이너 이미지 레지스트리를 유지하려는 개발자와 조직에 꼭 필요한 도구로 만듭니다.","ogImage":{"url":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-15-GettingStartedwithHarborAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"도커 컨테이너에서 노출Expose과 공개Publish 이해하기","description":"","date":"2024-05-15 11:05","slug":"2024-05-15-NavigatingExposeandPublishinDockerContainers","content":"\n\n\n![2024-05-15-NavigatingExposeandPublishinDockerContainers_0](/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png)\n\n도커는 응용 프로그램을 배포하는 방법을 혁신적으로 바꿨습니다. 소프트웨어를 컨테이너화하는 데 가벼우면서도 효율적이며 휴대 가능한 솔루션을 제공합니다. Docker 컨테이너에서 노출(expose)하고 게시(publish)하는 내용을 이해하는 것은 컨테이너와 호스트 시스템 간의 네트워크 통신을 효과적으로 관리하는 데 중요합니다.\n\nDocker Expose이란 무엇인가요?\n\nDockerfile에서 EXPOSE 지시문은 컨테이너가 실행 중에 어떤 네트워크 포트에서 수신 대기하는지 Docker에 알려줍니다.\n\n\n\n\n하지만 Docker 호스트 외부에서 컨테이너에 직접 액세스하거나 해당 포트를 호스트 시스템에 공개하지는 않습니다. 대신, 들어오는 연결을 수신하기 위해 컨테이너가 설정된 포트를 나열하는 메모 역할을 합니다.\n\n예를 들어, Dockefile에 EXPOSE 80를 포함하면, 컨테이너화된 응용프로그램이 80포트에서 들어오는 연결을 기다리는 것을 나타냅니다.\n\n이 정보는 컨테이너화된 응용프로그램의 네트워킹 요구사항을 이해하려는 개발자나 관리자에게 유용합니다.\n\n도커 Publish가 무엇인가요?\n\n\n\n한편, docker run 명령에 -p 또는 — publish 플래그를 사용하면 컨테이너에서 호스트 시스템으로 포트를 공개하여 외부 세계에서 액세스할 수 있습니다.\n\n-p 플래그를 사용하여 포트를 공개하면, Docker는 호스트 시스템의 포트와 컨테이너의 포트 사이에 매핑을 작성합니다.\n\n예를 들어, docker run -p 8080:80 `이미지 이름`을 실행하면 컨테이너에서 호스트 시스템의 포트 80을 포트 8080에 공개합니다. 따라서 호스트의 포트 8080으로 전달된 모든 트래픽은 컨테이너의 포트 80으로 라우팅됩니다.\n\n예시 및 사용 사례:\n\n\n\n웹 응용 프로그램이 도커 컨테이너에서 실행되고 포트 80에서 수신하는 시나리오를 생각해보세요. Dockerfile에 EXPOSE 지시문을 사용하여이 포트를 노출하려면 다음 줄을 추가하면 됩니다:\n\n```js\nEXPOSE 80\n```\n\n이를 통해 Docker에게 컨테이너화된 웹 응용 프로그램이 포트 80에서 수신한다는 것을 알립니다.\n\n이제 docker run 명령을 사용하여 컨테이너를 실행할 때 호스트 시스템의 포트 80에 해당하는 포트에 80포트를 게시할 수 있습니다. -p 플래그를 사용하면 됩니다:\n\n\n\n```js\n# 도커 실행 -p 8080:80 \u003c이미지 이름\u003e\n```\n\n이 명령은 컨테이너 내의 80포트를 호스트 시스템의 8080포트로 매핑하여 웹 애플리케이션에 외부 액세스할 수 있게 합니다.\n\n아래 명령은 지정된 이미지를 기반으로 컨테이너를 백그라운드 모드에서 시작하고 -- publish-all 옵션을 사용하여 모든 노출된 포트를 호스트 시스템의 랜덤 포트로 게시합니다.\n\n예를 들어, Dockerfile에 80포트와 443포트에 대한 EXPOSE 지시가 포함되어 있다면, 아래 명령을 실행하면 자동으로 컨테이너의 80포트와 443포트가 호스트 시스템의 랜덤 포트에 매핑됩니다.\n\n\n\n```js\n# 도커 실행 -d — 모두 공개 \u003c이미지 이름\u003e\n```\n\n주요 차이점 :\n\n노출 :\n\n공개 :\n  \n\n\n\nBest Practices:\n\n- Dockerfile에서 EXPOSE를 사용하여 컨테이너가 수신 대기 중인 포트를 문서화하세요.\n- 필요할 때 컨테이너 포트를 호스트 시스템에 공개하기 위해 docker run -p를 사용하세요.\n- 보안 상의 영향을 염두에 두고 외부 액세스에 필요한 포트만 노출하세요.\n- 컨테이너 간 통신을 위해 네트워크 및 서비스 검색과 같은 Docker 네트워킹 기능을 탐색하세요.\n\n결론:\n요약하자면, \"노출\"과 \"공개\"는 Docker 컨테이너 네트워킹에서 중요한 개념입니다.\nEXPOSE를 통해 컨테이너 포트를 문서화하고, docker run -p를 통해 컨테이너 포트를 호스트 시스템에 노출하여 외부 액세스를 가능하게 합니다.\n\n이러한 개념을 효과적으로 이해하고 적용함으로써, 개발자와 시스템 관리자는 Docker 컨테이너에서 네트워크 통신을 능숙하게 관리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png"},"coverImage":"/assets/img/2024-05-15-NavigatingExposeandPublishinDockerContainers_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터브릭스 SQL 관리 경고 패턴 - 데이터 웨어하우징 확장  데이터 액세스 감사","description":"","date":"2024-05-15 11:02","slug":"2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing","content":"\n\n아래와 같이 Markdown 형식으로 표 태그를 변경해주세요.\n\n\n| Tag | Description |\n| --- | ----------- |\n| `\u003chtml\u003e` | Defines an HTML document |\n| `\u003cbody\u003e` | Defines the body of the HTML document |\n| `\u003ch1\u003e` | Defines a large heading |\n\n\n\n\n워크스페이스 관리자로서, 사용자들에게 원활하고 성능이 우수한 데이터브릭 경험을 제공하는 것이 중요합니다. 동시에 데이터 접근 권한에서 최소 권한 원칙을 따르지 않는 위험한 행동을 방지해야 합니다. 데이터브릭 API, 시스템 테이블 및 데이터브릭 SQL (DBSQL)의 강력함으로 워크스페이스 관리자와 데이터 관리자는 데이터브릭 플랫폼에서의 사용 사항 거의 모든 측면을 추적할 수 있습니다. 이 블로그에서는 워크스페이스 관리자가 데이터 창고 성능을 모니터링하고 데이터 접근 권한이 높고 과도하게 허용되는 것을 모니터링하기 위한 알람을 설정하는 방법을 살펴보겠습니다.\n\n# 사례 1 — 컴퓨팅 성능 모니터링\n\n데이터브릭 SQL 웨어하우스에서는 시스템을 가로 및 세로로 확장할 수 있습니다. 우리는 티셔츠 사이즈(x-small, small, medium 등)를 통해 세로로 확장하여 주어진 쿼리에 대해 CPU 및 메모리를 추가할 수 있습니다. 또한 웨어하우스는 웨어하우스에 더 많은 클러스터를 추가함으로써 가로로 확장됩니다. 이는 웨어하우스 생성자가 오토스케일링을 활성화한 경우 자동으로 발생합니다. 그러나 웨어하우스 구성의 티셔츠 사이즈와 오토스케일링 범위(웨어하우스의 최소 및 최대 클러스터 수)를 이해하는 것은 종종 시범 및 오류 연습일 수 있습니다. 특히 웨어하우스의 사용이 쿼리 복잡성, 쿼리된 테이블 크기 또는 동시 사용자 수의 변화로 인해 시간이 지남에 따라 변하는 경우, 성능 메트릭에 대한 경고는 웨어하우스 생성자가 구성을 조정해 사용자에게 더 나은 쿼리 성능을 제공할 시기를 이해하도록 도와줄 수 있습니다.\n\n이 첫 번째 연습에서는 쿼리 기록 API(공식 시스템 테이블 —  비공개 미리보기 예정)을 활용하여 큰 수의 쿼리가 대기 중인 경우나 쿼리가 디스크로 데이터를 쓰는 경우에 웨어하우스 관리자에게 알림을 보낼 수 있는 테이블을 만들 것입니다.\n\n\n\n쿼리 기록 데이터를 수집하는 파이프라인 설정하기\n\n저희의 웨어하우스 사용량 및 크기에 기반한 알림을 설정하기 위해 먼저 쿼리 기록 API를 수집할 파이프라인을 생성해야 합니다 (참고: 이 플랫폼에 곧 도입될 쿼리 기록 시스템 테이블이 있습니다. 이 테이블을 통해 API를 사용하지 않고도 이 정보를 얻을 수 있을 것입니다. 현재 개인 미리보기 상태입니다). 이 API에는 워크스페이스 내에서 실행된 모든 쿼리에 대한 데이터가 포함되어 있습니다. 웨어하우스 ID나 사용자 ID와 같은 기본 정보부터 쿼리 프로파일러 UI에서 찾을 수 있는 성능 지표까지 포함됩니다(API를 호출할 때 \"include_metrics\" 플래그를 True로 설정하여 이러한 메트릭이 반환되도록 해야 합니다). Databricks Python SDK를 사용하여 작성된 노트북을 통해 지난 1시간 동안 실행된 모든 쿼리를 추출할 수 있습니다.\n\n```js\n#import and setup the SDK\nfrom databricks.sdk import WorkspaceClient\nfrom databricks.sdk.service import sql\n\nw = WorkspaceClient()\n\n\n#현재 시간과 관심 시간 창의 시작점을 반환하는 함수\n#(이 경우 지난 1시간 동안 실행된 모든 쿼리를 가져올 것입니다)\nimport datetime\nimport time\n\ndef get_current_time_and_minus_one_hour():\n  current_time = datetime.datetime.now()\n  current_time_sub_hour = current_time - datetime.timedelta(hours=1)\n\n  current_time_ms = int(time.mktime(current_time.timetuple()))*1000\n  current_time_sub_hour_ms = int(time.mktime(current_time_sub_hour.timetuple()))*1000\n\n  return current_time_ms, current_time_sub_hour_ms\n\n\n#API를 호출하여 지난 1시간 동안 실행된 모든 쿼리 기록을 가져옴\nimport json\nimport pandas as pd\nfrom pyspark.sql.functions import lit\n\ncurrent_time_ms, current_time_sub_hour_ms = get_current_time_and_minus_one_hour()\n\n#SDK를 사용하여 API를 호출\nqueries = w.query_history.list(\n    filter_by=sql.QueryFilter(\n        query_start_time_range=sql.TimeRange(\n            start_time_ms=current_time_sub_hour_ms, end_time_ms=current_time_ms\n        ) #지난 1시간의 시간 범위로 필터링\n    ),\n    include_metrics=True  #쿼리의 메트릭을 포함\n)\n\n#반환된 쿼리 기록을 사전으로 변환\nqueries_as_dicts = [query.as_dict() for query in queries]\n\n#pandas 데이터프레임을 생성한 다음 pySpark 데이터프레임으로 변환\nqueries_pandas = pd.DataFrame(queries_as_dicts)\nqueries_df = spark.createDataFrame(queries_pandas)\n\n#향후 분석을 위해 쿼리가 속한 시간 창을 추가\nqueries_df_with_window = queries_df.withColumn(\"start_window\", lit(current_time_sub_hour_ms)).withColumn(\"end_window\", lit(current_time_ms))\n\n#알림 및 분석에 사용할 테이블에 데이터프레임 추가\nqueries_df_with_window.write.mode(\"append\").saveAsTable(\"shared.tomasz_alerts.query_history\")\n```\n\n이 노트북을 통해 워크스페이스에서 지난 1시간 동안 실행된 모든 쿼리 기록을 수집하고 Delta 테이블에 추가하는 수집 프로세스를 설정했습니다. 이제 이 테이블은 모니터링을 위해 쿼리할 수 있으며 더 중요한 것은 사용자가 쿼리 실행 시 성능이 저하될 때 경고를 설정할 수 있습니다. 이제 이 테이블을 사용하여 웨어하우스를 변경하는 시기를 결정하는 방법을 살펴보겠습니다.\n\n\n\n## 대기열에서 막힌 쿼리를 찾는 방법\n\n웨어하우스가 많은 사용자 사이에서 공유되기 때문에 너무 많은 동시 쿼리가 발생하면 웨어하우스가 처리할 수 있는 리소스가 이용 가능할 때까지 대기열이 발생할 수 있습니다. 이러한 병목 현상은 대부분 자동으로 오토스케일링을 통해 해결될 수 있지만, 관리자는 주어진 SLA에 맞는 허용 가능한 최대 클러스터 개수의 건장한 상한선을 찾아야 합니다. 따라서, 관리자는 웨어하우스의 적절한 크기를 결정하기 위해 최소 클러스터 설정을 늘리고 자주 발생하는 스케일 업을 줄이며 최대 클러스터 설정을 늘려 대기열 병목 현상을 제거해야 합니다.\n\n아래 쿼리는 이전 단계에서 생성한 테이블을 호출할 것입니다. 가장 최근의 시간대 창을 사용하며, 1초 이상 대기열 단계에 갇힌 쿼리를 필터링합니다.\n\n```js\nselect\n  sum(\n    metrics.query_compilation_start_timestamp - metrics.overloading_queue_start_timestamp\n  ) as waiting_for_compute_duration_ms,\n  count(*) as count_queries_waiting_for_compute,\n  warehouse_id\nfrom\n  query_history\nwhere\n  end_window = (\n    select\n      max(end_window)\n    from\n      query_history\n  )\n  and metrics.query_compilation_start_timestamp - metrics.overloading_queue_start_timestamp \u003e 1000\ngroup by\n  warehouse_id\norder by\n  waiting_for_compute_duration_ms desc\n```\n\n\n\n위 쿼리 결과를 기반으로 하여 창고 관리자는 SQL 창고 모니터링 페이지를 검토하여 대기 시간이 매우 긴 경우를 확인할 수 있습니다. 창고가 최대 클러스터 수로 확장되었을 때 많은 쿼리 대기가 발생했다면, 관리자는 이 최대 제한을 늘려야 합니다. 반면에, 창고가 설정된 최대 클러스터 수에 도달하지 않았을 경우, 대기열의 원인은 아마도 빈번한 오토스케일링 때문일 것입니다. 이 경우, 관리자는 창고의 최소 클러스터 설정값을 더 높은 값으로 조정해야 합니다.\n\n디스크 스피룰링이 발생하는 창고 식별\n\n좋지 않은 쿼리 성능의 일반적인 원인 중 하나는 사용 중인 창고가 수평 스케일링(티셔츠 사이징) 면에서 적절하게 크기가 조정되지 않은 경우입니다. 이는 쿼리 실행 시간을 원하는 SLA와 비교하여 측정할 수 있습니다. 그러나 먼저, 이 문제가 있는지 여부를 결정하는 일반적인 전략은 쿼리가 자주 디스크로 스피릴하는 경우 트리거되는 경고를 설정하는 것입니다. 이는 클러스터가 단순히 메모리에 데이터를 처리하기에 너무 작거나 데이터에 중요한 스키가 있는 경우일 수 있음을 의미합니다.\n\n다음 쿼리는 우리의 쿼리 히스토리 테이블을 사용하여 디스크로 스피릴하는 쿼리의 수와 평균 및 최대 값에 대한 카운트를 반환합니다.\n\n\n\n```sql\nselect\n  avg(metrics.spill_to_disk_bytes) as avg_spill_to_disk_bytes,\n  max(metrics.spill_to_disk_bytes) as max_spill_to_disk_bytes,\n  count(*) as count_queries_spilled,\n  warehouse_id\nfrom\n  query_history\nwhere\n  end_window = (\n    select\n      max(end_window)\n    from\n      query_history\n  )\ngroup by\n  warehouse_id\nhaving\n  avg_spill_to_disk_bytes \u003e 0\norder by\n  avg_spill_to_disk_bytes desc\n```\n\n해당 쿼리 결과를 통해 데이터 웨어하우스 관리자는 많은 양의 디스크 스파일이 발생하는 웨어하우스를 확인할 수 있습니다. 이를 기반으로 해당 웨어하우스 클러스터를 더 큰 크기로 구성하여 더 많은 메모리 용량을 추가하고, 디스크 스파일을 줄이거나 제거할 수 있습니다.\n\n## 데이터 적재 및 경보 파이프라인 설정\n\n데이터를 적재하고 웨어하우스 관리자에게 사이즈를 재구성해야 할 때를 알려주는 경보를 활성화하는 Databricks 워크플로우를 설정할 수 있습니다. 이를 위해 먼저 위의 쿼리들 각각에 대한 두 개의 경보를 설정할 수 있습니다. 여기 예시에서는 임계값을 0보다 큰 고유한 웨어하우스로 설정하여, 디스크 스파일이나 대기 시간 초과가 발생할 때마다 경보가 트리거됩니다.\n\n\n\n\n\n![Databricks SQL Governance Alerting Patterns Warehousing Scaling Data Access Auditing 1](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_1.png)\n\n![Databricks SQL Governance Alerting Patterns Warehousing Scaling Data Access Auditing 2](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_2.png)\n\n쿼리 임계값(디스크로 스파일되는 크기 및 대기 시간)과 경고 임계값은 성능이 느린 쿼리에 대한 허용 수준에 따라 조정할 수 있습니다. 또한 쿼리 스파일 비율이나 쿼리 스파일 빈도에 따라 경고도 트리거할 수 있으며, 이는 데이터 웨어하우스를 확장하거나 쿼리 자체의 문제를 식별할 필요가 있음을 더 잘 나타낼 수 있습니다. 이러한 경고가 설정되면 먼저 쿼리 이력 API 데이터 처리 노트북을 실행하고 이러한 경고를 새로 고침하는 워크플로우를 생성할 수 있습니다. 워크플로에 경고를 추가하려면 \"작업 추가\" 버튼을 클릭한 후 SQL - 경고 옵션을 선택합니다. 이전 단계에서 생성한 경고를 선택하여 최종 워크플로 작업 다이어그램을 얻을 수 있습니다.\n\n이 워크플로는 데이터 웨어하우스의 성능 허용 수준에 따라 매 시간 또는 매일 실행되도록 예약할 수 있습니다. 쿼리 이력 시스템 테이블이 공개 미리보기로 제공되면 데이터 처리를 제거하고 이러한 경고를 DBSQL에서 직접 실행하도록 트리거할 수 있습니다!\n\n\n\n\n디스크 스피릴과 대기열 간의 관계\n\n수직으로 확장된 창고는 수평으로 확장할 필요성을 제거할 수 있다는 점을 강조해야 합니다. 예를 들어, 창고에서 쿼리가 완료되기까지 매우 오랜 시간이 걸릴 수 있으며, 위의 디스크로 스피릴이라는 경보로 나타날 수 있습니다. 이러한 상황에서 초기 실행 중인 쿼리가 완료될 때까지 신규 쿼리가 대기열에 들어가 있을 수 있습니다. 따라서 예를 들어 중간 규모에서 대형 클러스터로 수직으로 확장되면, 초기 실행 중인 쿼리가 더 빨리 완료되는 것 뿐만 아니라 대기 중인 쿼리 수도 줄어들 확률이 높습니다.\n\n동일한 맥락에서 창고를 가로로 확장하여 클러스터를 더 추가함으로써 복잡한 쿼리에 더 많은 전용 자원을 할당할 수 있으며, 작은 쿼리는 다른 클러스터로 리디렉션할 수 있습니다. 따라서 창고에 더 많은 클러스터를 추가하여 수평으로 확장함으로써 동적 쿼리 실행 중 발생하는 디스크 스피릴 양도 줄일 수 있습니다.\n\n# Use Case 2 — 모니터링 액세스 제어\n\n\n\nDatabricks 웨어하우스를 사용할 때 설정할 수 있는 또 다른 유용한 경고는 액세스 제어와 관련된 것입니다. 데이터 관리자 및 지배 관리자의 주요 관심사 중 하나는 사용자가 너무 허용적인 액세스를 허용받은 경우에 대해 이해하는 것입니다. 모베스트 프랙티스에서 벗어나는 권한 부여에 대한 경고를 설정하기 위한 기본 작업을 수행하려면 조직은 사용자가 일반적인 액세스 영역을 벗어나 데이터에 액세스해야 하는 방법을 정의하는 프로토콜 집합을 미리 정의해야 합니다. 이러한 관행이 정의된 상태에서 경고를 사용하여 표준 운영 절차에서 벗어나는 경우를 이해할 수 있습니다. 아래 예에서는 시스템 테이블에 대한 경고를 사용하여 관리자가 사용자가 민감한 PII 데이터에 액세스를 허용했을 때와 사용자에게 읽기 권한 대신 쓰기 액세스를 부여받았을 때 모니터링할 수 있습니다.\n\n## 개별 사용자에 대한 편집 권한\n\nUnity Catalog를 활용할 때 일반적인 모베스트 프랙티스는 개별 사용자에 직접 권한을 부여하는 대신 사용자 그룹을 통해 데이터 액세스를 관리하는 것입니다. 카탈로그는 팀 또는 프로젝트를 위해 생성되어야 하고 해당 카탈로그에 대한 소유자, 편집자 및 판독자 사용자 그룹이 데이터 액세스에 사용되어야 합니다. 그러나 다른 팀의 동료가 해당 카탈로그에 ad-hoc 액세스가 필요한 경우, 지배 관리자는 임시적인 권한 부여를 위해 그들을 기존 그룹 중 하나로 추가하길 원하지 않을 수 있습니다. 이 경우에는 이러한 사용자를 위해 사전에 생성된 게스트 사용자 그룹을 만들어 임시 액세스를 부여할 수 있습니다. 이를 통해 액세스를 사용자 계정을 통해 직접 제공하는 것과 비교할 때 지배를 더 쉽게 할 수 있습니다.\n\n지배 모베스트 프랙티스가 정립된 후에는 표준을 벗어나는 권한 부여 행동을 감시하기 위해 경고를 설정할 수 있습니다. 따라서 ad hoc 사용자 권한을 위해 게스트 그룹을 사용하는 모베스트 프랙티스에 따라 사용자 계정(사용자 그룹이 아닌 사용자 계정)이 카탈로그, 스키마 또는 테이블에 직접 액세스를 제공받았을 때 식별하기 위한 쿼리를 설정할 수 있습니다. 이 예에서는 권한을 MODIFY 또는 ALL_PRIVILEGES만 필터링하지만 구성 규칙이 조직 내에서 얼마나 엄격한지에 따라 READ 권한을 포함할 수 있습니다.\n\n\n\n```js\n-- 테이블, 스키마 또는 카탈로그 수준에서 직접 사용자 계정에 부여된 모든 쓰기 권한 (MODIFY 또는 ALL_PRIVILEGES)를 가져오십시오.\nSELECT\n  event_time,\n  user_identity.email as granter,\n  request_params.changes as perm_changes,\n  audit.request_params.securable_type as securable_type,\n  request_params.securable_full_name as securable_full_name\nFROM\n  system.access.audit\nWHERE\n  audit.service_name = \"unityCatalog\"\n  AND audit.action_name = \"updatePermissions\"\n  AND audit.request_params.securable_type in (\"catalog\", \"schema\", \"table\")\n  AND audit.event_time \u003e (current_timestamp() - INTERVAL 70 MINUTES)\n  AND audit.response.status_code = 200\n  AND request_params.changes:[*].principal like \"%@databricks.com%\" -- 조직 이메일 도메인\n  AND (\n    array_contains(\n      flatten(\n        from_json(\n          request_params.changes:[*].add,\n          'array\u003carray\u003cstring\u003e\u003e'\n        )\n      ),\n      \"MODIFY\"\n    )\n    OR array_contains(\n      flatten(\n        from_json(\n          request_params.changes:[*].add,\n          'array\u003carray\u003cstring\u003e\u003e'\n        )\n      ),\n      \"ALL_PRIVILEGES\"\n    )\n  )\n```\n\n이 문서에서는 조직의 도메인(\"databricks.com\")을 사용하여 사용자 계정이 데이터 자산에 직접 쓰기 액세스 권한이 부여된 것을 식별합니다. 이 예시에서는 매 시간마다 스케줄을 설정했으므로, 70분 전까지의 감사 테이블을 확인하는 필터가 있습니다(감사 테이블 업데이트에 지연이 있기 때문입니다).\n\n이 쿼리를 매 시간 실행하고 결과 레코드가 반환되면 데이터의 행 수를 선택하여 반환된 값이 0보다 크면 경고를 설정할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_3.png\" /\u003e\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_4.png\" /\u003e\n\n## 민감한 개인 식별 정보(PII) 테이블에 대한 권한\n\n다른 일반적인 Unity 카탈로그 패턴은 데이터에 민감한 PII(개인 식별 정보)가 포함되어 있음을 나타내는 테이블이나 열에 태그를 붙이는 것입니다. 따라서 이러한 데이터는 특정 사용자 집합에만 제한되어야 합니다. \"pii\" 태그가 있는 모든 테이블과 열을 찾아서 해당 테이블 및 스키마, 카탈로그 목록을 가져올 수 있는 정보 스키마 시스템 테이블을 사용할 수 있습니다. 그런 다음 이 목록을 권한 부여를 통해 교차 참조할 수 있습니다. 이 쿼리에 대한 알림을 설정하면 관리자는 이러한 민감한 자산에 추가된 모든 권한을 알 수 있어 잘못된 권한이 설정되지 않았는지 확인할 수 있습니다.\n\n```js\n-- \"pii\"를 포함하는 열 태그 또는 테이블 태그가 있는 모든 테이블(및 해당 카탈로그와 스키마) 찾기\nWITH table_tags_union AS (\n  SELECT\n    explode(\n      array(\n        catalog_name,\n        CONCAT(catalog_name, \".\", schema_name),\n        CONCAT(catalog_name, \".\", schema_name, \".\", table_name)\n      )\n    ) as securable_full_name\n  FROM\n    system.information_schema.column_tags\n  WHERE\n    tag_name LIKE \"%pii%\"\n    OR tag_value LIKE \"%pii%\"\n  GROUP BY\n    all\n  UNION\n    DISTINCT\n  SELECT\n    explode(\n      array(\n        catalog_name,\n        CONCAT(catalog_name, \".\", schema_name),\n        CONCAT(catalog_name, \".\", schema_name, \".\", table_name)\n      )\n    ) as securable_full_name\n  FROM\n    system.information_schema.table_tags\n  WHERE\n    tag_name LIKE \"%pii%\"\n    OR tag_value LIKE \"%pii%\"\n  GROUP BY\n    all\n) \n-- \"pii\" 태그가 있는 시큐러블과 권한 추가가 있었던 감사 로그를 조인\nSELECT\n  event_time,\n  user_identity.email,\n  request_params.changes,\n  request_params.securable_type,\n  request_params.securable_full_name\nFROM\n  system.access.audit\n  INNER JOIN table_tags_union ON audit.request_params.securable_full_name = table_tags_union.securable_full_name\nWHERE\n  audit.service_name = 'unityCatalog'\n  AND audit.action_name = 'updatePermissions'\n  AND audit.event_time \u003e (current_timestamp() - INTERVAL 70 MINUTES)\n  AND audit.response.status_code = 200\n  AND audit.request_params.changes:[*].add is not null\n```\n\n\n\n\n이전 설정에서와 마찬가지로, PII 데이터에 액세스가 허용된 경우 트리거되는이 쿼리에 대한 경고를 생성할 수 있습니다.\n\n![Alert Image 5](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_5.png)\n\n![Alert Image 6](/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_6.png)\n\n# 결론\n\n\n\n쿼리 히스토리 API, 시스템 테이블, DBSQL 및 Databricks Workflows 등을 통해 관리자가 워크스페이스를 모니터링하여 플랫폼의 최종 사용자들에게 원활하고 안전한 경험을 제공하는 데 활용할 수 있는 다양한 방법의 몇 가지 예시에요. 이러한 쿼리와 알림은 조직의 요구 사항에 따라 성능 및 거버넌스에 관한 부분을 수정할 수 있어요. 원하는 거버넌스 및 모니터링 주제가 있으시면 직접 연락해 주세요!","ogImage":{"url":"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png"},"coverImage":"/assets/img/2024-05-15-DatabricksSQLGovernanceAlertingPatternsWarehousingScalingDataAccessAuditing_0.png","tag":["Tech"],"readingTime":13},{"title":"Terraform을 사용하여 VPC 피어링 자동화하기","description":"","date":"2024-05-15 11:00","slug":"2024-05-15-AutomateVPCPeeringwithTerraform","content":"\n\n\n![image](/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png)\n\nAWS의 VPC 피어링은 두 개의 VPC 간에 사설 IPv4 또는 IPv6 주소를 사용하여 트래픽을 경로 설정할 수 있는 네트워킹 연결입니다.\n\nVPC 피어링은 AWS의 네트워킹 서비스 스위트의 일부로, 클라우드에서 확장 가능하고 안전하며 고가용성 네트워크 아키텍처를 생성할 수 있는 강력한 옵션을 제공합니다.\n\n이 기사에서는 Terraform을 사용하여 VPC 피어링 연결을 생성하는 방법을 살펴보겠습니다.\n\n\n\n\n## 준비 사항:\n\n- Terraform이 설치된 서버\n\n## 단계 1: VPC용 코드 생성\n\n- main.tf 파일을 생성하고 아래 코드를 추가하세요.\n\n\n\n```json\n# Demo VPC A\nresource \"aws_vpc\" \"demo-vpc-a\" {\n  cidr_block = var.demo-vpc-a-cidr\n\n  tags = {\n    Name = \"demo-vpc-a\"\n  }\n}\n\n# Demo VPC B\nresource \"aws_vpc\" \"demo-vpc-b\" {\n  cidr_block = var.demo-vpc-b-cidr\n\n  tags = {\n    Name = \"demo-vpc-b\"\n  }\n}\n```\n\n- 위의 코드는 2개의 VPC를 생성합니다.\n\n## 단계 2: 서브넷용 코드 작성\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n```js\n# 데모 VPC A의 서브넷\nresource \"aws_subnet\" \"demo-subnet-a\" {\n  vpc_id            = aws_vpc.demo-vpc-a.id\n  cidr_block        = var.demo-subnet-a-cidr\n  availability_zone = data.aws_availability_zones.available_zones.names[0]\n\n  tags = {\n    Name = \"Public Subnet A\"\n  }\n}\n\n# 데모 VPC B의 서브넷\nresource \"aws_subnet\" \"demo-subnet-b\" {\n  vpc_id            = aws_vpc.demo-vpc-b.id\n  cidr_block        = var.demo-subnet-b-cidr\n  availability_zone = data.aws_availability_zones.available_zones.names[1]\n\n  tags = {\n    Name = \"Public Subnet B\"\n  }\n}\n```\n\n- 위 코드는 각 VPC에 서브넷을 생성합니다.\n\n## 단계 3: 피어링 연결을 위한 코드 생성\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n  \n\n\n\n```js\n# Peering connection\nresource \"aws_vpc_peering_connection\" \"vpc_peering\" {\n  vpc_id      = aws_vpc.demo-vpc-a.id\n  peer_vpc_id = aws_vpc.demo-vpc-b.id\n}\n\n# Peering connection acceptor\nresource \"aws_vpc_peering_connection_accepter\" \"vpc_peering_accepter\" {\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n  auto_accept               = true\n}\n```\n\n- 위의 코드는 VPC 피어링 연결을 생성하고 자동으로 수락합니다.\n\n## 단계 4: 라우트 테이블 및 R을 위한 코드 만들기\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n\n```js\n# 라우트 테이블\n리소스 \"aws_route_table\" \"demo-route-table-a\" {\n  vpc_id = aws_vpc.demo-vpc-a.id\n}\n\n리소스 \"aws_route_table\" \"demo-route-table-b\" {\n  vpc_id = aws_vpc.demo-vpc-b.id\n}\n```\n\n- 위의 코드는 각 VPC에 두 개의 라우트 테이블을 생성합니다.\n\n## 단계 5: 라우트 코드 생성\n\n- 아래 코드를 main.tf 파일에 추가합니다.\n  \n\n\n\n```js\n# VPC 피어링을 위한 라우트 테이블에 라우트 생성하기\nresource \"aws_route\" \"demo-route-a\" {\n  route_table_id            = aws_route_table.demo-route-table-a.id\n  destination_cidr_block    = aws_vpc.demo-vpc-b.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n}\n\nresource \"aws_route\" \"route2\" {\n  route_table_id            = aws_route_table.demo-route-table-b.id\n  destination_cidr_block    = aws_vpc.demo-vpc-a.cidr_block\n  vpc_peering_connection_id = aws_vpc_peering_connection.vpc_peering.id\n}\n```\n\n- 위 코드는 라우트 테이블을 수정하여 VPC A에서 VPC B로의 라우트 및 VPC B에서 VPC A로의 라우트를 허용합니다.\n\n## 단계 6: 인터넷 게이트웨이용 코드 작성하기\n\n- 아래 코드를 main.tf 파일에 추가하세요.\n\n\n\n\n```js\n# 인터넷 게이트웨이 생성\nresource \"aws_internet_gateway\" \"demo-igw\" {\n  vpc_id = aws_vpc.demo-vpc-a.id\n}\n\n# VPC 라우트 테이블과 인터넷 게이트웨이 연결\nresource \"aws_route\" \"route_to_internet\" {\n  route_table_id         = aws_route_table.demo-route-table-a.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  gateway_id             = aws_internet_gateway.demo-igw.id\n}\n```\n\n## 단계 7: 변수 파일 생성하기\n\n- variables.tf 파일을 생성하고 아래 코드를 추가합니다.\n\n```js\n# VPC A CIDR\nvariable \"demo-vpc-a-cidr\" {\n  type        = string\n  description = \"VPC A의 CIDR\"\n}\n\n# VPC B CIDR\nvariable \"demo-vpc-b-cidr\" {\n  type        = string\n  description = \"VPC B의 CIDR\"\n}\n\n# 서브넷 A CIDR\nvariable \"demo-subnet-a-cidr\" {\n  type        = string\n  description = \"데모 서브넷 A의 CIDR\"\n}\n\n# 서브넷 B CIDR\nvariable \"demo-subnet-b-cidr\" {\n  type        = string\n  description = \"데모 서브넷 B의 CIDR\"\n}\n\n# 지역\nvariable \"region\" {\n  type        = string\n  description = \"지역\"\n}\n```\n\n\n\n## 단계 8: 제공자 파일 만들기\n\n- provider.tf 파일을 만들고 아래 코드를 추가하세요.\n\n```js\n# AWS 제공자 구성\nprovider \"aws\" {\n  region = var.region\n}\n\n# 백엔드 구성\nterraform {\n  backend \"s3\" {\n    bucket         = \"dhsoni-terraform\"\n    key            = \"peering.terraform.tfstate\"\n    region         = \"us-east-2\"\n    dynamodb_table = \"terraform-state-lock-dynamodb\"\n  }\n}\n```\n\n## 단계 9: terraform.tfvars 파일 만들기\n\n\n\n- terraform.tfvars 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\nregion             = \"us-east-2\"\ndemo-vpc-a-cidr    = \"10.0.0.0/16\"\ndemo-vpc-b-cidr    = \"10.1.0.0/16\"\ndemo-subnet-a-cidr = \"10.0.1.0/24\"\ndemo-subnet-b-cidr = \"10.1.1.0/24\"\n```\n\n## 단계 10: 작업 디렉토리 초기화\n\n- 작업 디렉토리에서 terraform init 명령어를 실행해주세요. 이 명령어는 필요한 모든 공급자 및 모듈을 다운로드하고, 백엔드를 초기화합니다.\n\n\n\n## 단계 11: 테라폼 실행 계획 작성\n\n- 작업 디렉토리에서 `terraform plan` 명령을 실행하세요. 실행 계획을 확인할 수 있습니다.\n\n## 단계 12: 테라폼 적용 실행\n\n- 작업 디렉토리에서 `terraform apply` 명령을 실행하면 AWS에 필요한 모든 리소스가 생성됩니다.\n\n\n\n## 단계 13: 연결 확인하기\n\n- AWS 콘솔로 이동하여 VPC 피어링 연결을 확인하세요.\n\n![이미지](/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_1.png)\n\n이제 AWS VPC 피어링 연결을 Terraform을 사용하여 만드는 방법을 배웠습니다. 이제 원하는 대로 재생하고 필요에 맞게 수정할 수 있습니다.\n\n\n\n여기서 전체 코드를 찾을 수 있어요.\n\n다른 저장소들도 살펴보세요.\n\n이 안내서가 도움이 되었다면 👏 버튼을 클릭해 주시고, 자유롭게 댓글을 남겨 주세요.\n\n더 이런 이야기를 보고 싶다면 팔로우해 주세요 😊\n\n\n\n# 스택더믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 가기 전에:\n\n- 저희 작가를 clapping하고 팔로우해주시기 바랍니다! 👏\n- 저희를 팔로우하고 Youtube, Discord에서 만나보세요\n- 다른 플랫폼에서도 만나보세요: In Plain English, CoFeed, Venture, Cubed\n- 알고리즘 콘텐츠를 강제로 다루게 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 스택더믹 닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-15-AutomateVPCPeeringwithTerraform_0.png","tag":["Tech"],"readingTime":6}],"page":"94","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"94"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>