<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/94" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" href="/post/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19 Beta 릴리스, 새로운 기능 소개 및 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19 Beta 릴리스, 새로운 기능 소개 및 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node.js 애플리케이션을 디버깅하는 방법" href="/post/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node.js 애플리케이션을 디버깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node.js 애플리케이션을 디버깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Node.js 애플리케이션을 디버깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" href="/post/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" href="/post/2024-05-01-HowtoSkipReactuseEffectonInitialRender"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리덕스 사가 사용하는 방법(기초)" href="/post/2024-05-01-GettingStartedwithReduxSagaTutorial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리덕스 사가 사용하는 방법(기초)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리덕스 사가 사용하는 방법(기초)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리덕스 사가 사용하는 방법(기초)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">43<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" href="/post/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" href="/post/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link posts_-active__YVJEi" href="/posts/94">94</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"React 19 Beta 릴리스, 새로운 기능 소개 및 정리","description":"","date":"2024-05-01 17:45","slug":"2024-05-01-React19BetaReleasedWhatYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png)\n\n지난 2022년 6월 React의 마지막 안정 버전 이후, 두 년 가까이 새 버전이 나오지 않았는데, 이제 npm에서 React 19 베타판이 안정 버전인 React 18.3.0과 함께 공개되었습니다. React 19 베타판에서 개발자들이 알아야 할 새로운 기능을 살펴보겠습니다.\n\n## 액션\n\n![이미지](/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 앱에서 흔히 발생하는 사용 사례는 데이터 변이를 수행한 다음 응답에 따라 상태를 업데이트하는 것입니다. 예를 들어, 사용자가 이름을 변경하기 위해 양식을 제출하면 API 요청을 만들고 그 다음 응답을 처리해야 합니다. 과거에는 보류 중인 상태, 오류, 낙관적 업데이트 및 순차 요청을 수동으로 처리해야 했습니다.\n\n예를 들어, useState로 대기 및 오류 상태를 처리할 수 있었습니다:\n\n```js\n// 액션 이전\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, setIsPending] = useState(false);\n\n  const handleSubmit = async () =\u003e {\n    setIsPending(true);\n    const error = await updateName(name);\n    setIsPending(false);\n    if (error) {\n      setError(error);\n      return;\n    } \n    redirect(\"/경로\");\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        업데이트\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n리액트 19에서는 전이에 비동기 함수를 사용하여 대기 중인 상태, 오류, 양식 및 낙관적 업데이트를 자동으로 처리할 수 있는 지원이 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, useTransition을 사용하여 대기 상태를 처리할 수 있습니다:\n\n```js\n// Actions에서 대기 상태 사용하기\nfunction UpdateName({}) {\n  const [name, setName] = useState(\"\");\n  const [error, setError] = useState(null);\n  const [isPending, startTransition] = useTransition();\n\n  const handleSubmit = async () =\u003e {\n    startTransition(async () =\u003e {\n      const error = await updateName(name);\n      if (error) {\n        setError(error);\n        return;\n      } \n      redirect(\"/path\");\n    })\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput value={name} onChange={(event) =\u003e setName(event.target.value)} /\u003e\n      \u003cbutton onClick={handleSubmit} disabled={isPending}\u003e\n        Update\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n}\n```\n\n비동기 전환은 즉시 isPending 상태를 true로 설정하고 비동기 요청을 수행한 다음 이전 전환 후에 isPending를 false로 전환합니다. 이렇게 하면 데이터가 변경되는 동안에도 현재 UI를 반응적이고 상호작용할 수 있게 유지할 수 있습니다.\n\n관례적으로, 비동기 전환을 사용하는 함수는 \"Actions\"라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동작은 데이터 제출을 자동으로 처리해줍니다:\n\n- 보류 상태: 동작은 요청의 시작부터 시작되는 보류 상태를 제공하며, 최종 상태 업데이트가 완료될 때 자동으로 재설정됩니다.\n- 낙관적 업데이트: 동작은 새로운 useOptimistic 훅을 지원하여 요청이 제출되는 동안 사용자에게 즉시 피드백을 제공할 수 있습니다.\n- 오류 처리: 동작은 오류 처리를 제공하여 요청이 실패했을 때 오류 경계를 표시하고, 낙관적 업데이트를 자동으로 원래 값으로 되돌립니다.\n- 폼: 이제 `form` 요소는 동작과 formAction props에 함수를 전달할 수 있습니다. action props에 함수를 전달하면 기본적으로 동작을 사용하고 제출 후 자동으로 폼을 재설정합니다.\n\nReact 19에서 동작을 기반으로하면 낙관적 업데이트를 관리하는 useOptimistic 및 동작의 공통 사례를 처리하는 새로운 hook인 React.useActionState를 도입했습니다. react-dom에서는 `form` 동작을 사용하여 폼을 자동으로 처리하고, 동작의 공통 사례를 지원하는 useFormStatus를 추가했습니다.\n\nReact 19에서 위 예제는 간단하게 변경될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// \u003cform\u003e 작업 및 useActionState 사용하기\nfunction ChangeName({ name, setName }) {\n  const [error, submitAction, isPending] = useActionState(\n    async (previousState, formData) =\u003e {\n      const error = await updateName(formData.get(\"name\"));\n      if (error) {\n        return error;\n      }\n      redirect(\"/path\");\n    }\n  );\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cinput type=\"text\" name=\"name\" /\u003e\n      \u003cbutton type=\"submit\" disabled={isPending}\u003e업데이트\u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error}\u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n# 새로운 훅: useActionState\n\nReact 19에서 일반적인 케이스를 보다 쉽게 만들기 위해 useActionState라는 새로운 훅이 추가되었습니다:\n\n```js\nconst [error, submitAction, isPending] = useActionState(async (previousState, newName) =\u003e {\n  const error = await updateName(newName);\n  if (error) {\n    // 작업의 결과로 어떤 것이든 반환할 수 있습니다.\n    // 여기서는 오직 에러만 반환합니다.\n    return error;\n  }\n  \n  // 성공 처리\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useActionState` 함수는 함수(액션)를 인수로 받아 감싼 액션을 호출합니다. 이는 액션이 조합되기 때문에 작동합니다. 감싼 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 데이터로 반환하고 액션의 보류 상태를 보류로 반환합니다.\n\n# React DOM: form 액션\n\nReact 19의 새로운 `form` 기능에 액션도 통합되어 있습니다. `form`, `input`, 그리고 `button` 엘리먼트의 액션과 formAction 프롭으로 함수를 전달하여 액션과 함께 자동으로 폼을 제출할 수 있습니다:\n\n```js\n\u003cform action={actionFunction}\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`form`이 성공하면 React는 제어되지 않는 컴포넌트를 위해 자동으로 `form`을 재설정합니다. `form`을 수동으로 재설정해야 하는 경우, 새 요청 `form` 재설정 React DOM API를 호출할 수 있습니다.\n\n# React DOM: 새로운 훅: useFormStatus\n\n디자인 시스템에서 `form`에 대한 정보에 액세스해야 하는 디자인 컴포넌트를 작성하는 것이 일반적입니다. 그러나 컴포넌트로 속성을 전달 받지 않아도 되도록 하는 경우가 있습니다. 이 작업은 Context를 통해 수행할 수 있지만, 일반적인 경우를 쉽게 만들기 위해 React 19에 새로운 훅인 useFormStatus가 추가되었습니다:\n\n```js\nimport {useFormStatus} from 'react-dom';\n\nfunction DesignButton() {\n  const {pending} = useFormStatus();\n  return \u003cbutton type=\"submit\" disabled={pending} /\u003e\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useFormStatus`는 부모 `form`의 상태를 읽어오는 것처럼 동작하여, 마치 form이 Context 제공자인 것처럼 사용할 수 있습니다.\n\n# 새로운 훅: useOptimistic\n\n데이터 변경 작업을 수행할 때 또 다른 일반적인 UI 패턴은 비동기 요청 진행 중에 최종 상태를 낙관적으로 표시하는 것입니다. React 19에서는 이를 쉽게 처리할 수 있도록 `useOptimistic`라는 새로운 훅이 추가되었습니다:\n\n```js\nfunction ChangeName({currentName, onUpdateName}) {\n  const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n\n  const submitAction = async formData =\u003e {\n    const newName = formData.get(\"name\");\n    setOptimisticName(newName);\n    const updatedName = await updateName(newName);\n    onUpdateName(updatedName);\n  };\n\n  return (\n    \u003cform action={submitAction}\u003e\n      \u003cp\u003eYour name is: {optimisticName}\u003c/p\u003e\n      \u003cp\u003e\n        \u003clabel\u003eChange Name:\u003c/label\u003e\n        \u003cinput\n          type=\"text\"\n          name=\"name\"\n          disabled={currentName !== optimisticName}\n        /\u003e\n      \u003c/p\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useOptimistic` 훅은 `updateName` 요청이 진행 중일 때 즉시 `optimisticName`을 렌더링합니다. 업데이트가 완료되거나 에러가 발생하면 React가 자동으로 `currentName` 값으로 전환됩니다.\n\n# 새 API: use\n\nReact 19에서 렌더링하는 동안 리소스를 읽기 위한 새로운 API가 추가되었습니다: `use`.\n\n예를 들어, `use`로 프로미스를 읽을 수 있으며, React가 프로미스가 해결될 때까지 일시 중단됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {use} from 'react';\n\nfunction Comments({commentsPromise}) {\n  // `use`가 프로미스가 해결될 때까지 일시 중단됩니다.\n  const comments = use(commentsPromise);\n  return comments.map(comment =\u003e \u003cp key={comment.id}\u003e{comment}\u003c/p\u003e);\n}\n\nfunction Page({commentsPromise}) {\n  // Comments에서 `use`가 일시 중단되면\n  // 이 Suspense 경계가 표시됩니다.\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cComments commentsPromise={commentsPromise} /\u003e\n    \u003c/Suspense\u003e\n  )\n}\n```\n\n렌더링되는 동안 생성된 프로미스를 지원하지 않습니다.\n\n렌더링에서 만든 프로미스를 use에 전달하려고 하면 React에서 경고합니다:\n\n수정하려면, 프로미스 캐싱을 지원하는 suspense 기반 라이브러리나 프레임워크에서 프로미스를 전달해야 합니다. 미래에는 렌더링 중에 프로미스를 캐싱하기 쉽게 만드는 기능을 제공할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 일찍 반환한 후와 같이 조건부로 Context를 읽을 수도 있습니다:\n\n```js\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\n\nfunction Heading({children}) {\n  if (children == null) {\n    return null;\n  }\n  \n  // 일찍 반환으로 인해 useContext로 동작하지 않습니다.\n  const theme = use(ThemeContext);\n  return (\n    \u003ch1 style={{color: theme.color}}\u003e\n      {children}\n    \u003c/h1\u003e\n  );\n}\n```\n\nuse API는 후크와 유사하게 렌더링 중에만 호출될 수 있습니다. 후크와는 다르게 use는 조건부로 호출할 수 있습니다.\n\n자세한 정보는 use에 대한 문서를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref을 속성으로 사용하기\n\nReact 19부터 함수 컴포넌트에서 ref를 속성으로 접근할 수 있습니다:\n\n```js\nfunction MyInput({placeholder, ref}) {\n  return \u003cinput placeholder={placeholder} ref={ref} /\u003e\n}\n\n//...\n\u003cMyInput ref={ref} /\u003e\n```\n\n새로운 함수 컴포넌트는 더 이상 forwardRef가 필요하지 않습니다. 향후 버전에서 React는 forwardRef를 사용하지 않도록 하고 제거할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 'Context'를 제공자로 렌더링하기\n\nReact 19에서 'Context.Provider' 대신 'Context'를 제공자로 렌더링할 수 있습니다:\n\n```js\nconst ThemeContext = createContext('');\n\nfunction App({children}) {\n  return (\n    \u003cThemeContext value=\"dark\"\u003e\n      {children}\n    \u003c/ThemeContext\u003e\n  );  \n}\n```\n\n나중에 React 버전에서는 'Context.Provider'를 사용하지 않도록 지원 중단될 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ref에 대한 정리 함수\n\n이제 React는 ref 콜백에서 정리 함수를 반환하는 것을 지원합니다:\n\n```js\n\u003cinput\n  ref={(ref) =\u003e {\n    // ref 생성\n\n    // 새로운 기능: 요소가 DOM에서 제거될 때 ref를 재설정하는 정리 함수를 반환합니다.\n    return () =\u003e {\n      // ref 정리\n    };\n  }\n/\u003e\n```\n\n컴포넌트가 언마운트될 때, React는 ref 콜백에서 반환된 정리 함수를 호출합니다. 이는 DOM ref, 클래스 컴포넌트에 대한 ref 및 useImperativeHandle에 대해 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리팩토링된 ref 정리 함수의 도입으로 인해 TypeScript에서 ref 콜백에서 다른 값을 반환하면 거부됩니다. 이 문제를 해결하는 방법은 일반적으로 암시적 반환을 사용하지 않도록 하는 것입니다. 예를 들어:\n\n```js\n- \u003cdiv ref={current =\u003e (instance = current)} /\u003e\n+ \u003cdiv ref={current =\u003e {instance = current} /\u003e\n```\n\n원본 코드는 HTMLDivElement의 인스턴스를 반환했으며 TypeScript는 이것이 정리 함수인지 아니면 정리 함수를 반환하고 싶지 않은 것인지를 알 수 없습니다.\n\n# useDeferredValue 초기 값\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 useDeferredValue에 initialValue 옵션을 추가했습니다:\n\n```js\nfunction Search({deferredValue}) {\n  // 초기 렌더링 시 값은 ''입니다.\n  // 그런 다음 다시 렌더링이 예약되고 deferredValue로 업데이트됩니다.\n  const value = useDeferredValue(deferredValue, '');\n  \n  return (\n    \u003cResults query={value} /\u003e\n  );\n}\n```\n\ninitialValue가 제공되면 useDeferredValue는 해당 값을 컴포넌트의 초기 렌더링에 반환하고, deferredValue를 사용하여 백그라운드에서 다시 렌더링을 예약합니다.\n\n# 문서 메타데이터 지원\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML에서는 `title`, `link`, `meta`와 같은 문서 메타데이터 태그를 문서의 `head` 섹션에 배치하기 위해 예약되어 있어요. React에서는 앱에 적합한 메타데이터를 결정하는 컴포넌트가 `head`를 렌더링하는 곳과 매우 먼 곳에 있을 수 있거나 React가 `head`를 전혀 렌더링하지 않을 수도 있어요. 과거에는 이러한 요소들을 수동으로 삽입해야 했거나 react-helmet과 같은 라이브러리를 사용하여 효과적으로 처리해야 했던 것을 기억하시죠.\n\nReact 19는 컴포넌트에서 문서 메타데이터 태그를 네이티브로 렌더링하는 지원을 제공해요:\n\n```js\nfunction BlogPost({post}) {\n  return (\n    \u003carticle\u003e\n      \u003ch1\u003e{post.title}\u003c/h1\u003e\n      \u003ctitle\u003e{post.title}\u003c/title\u003e\n      \u003cmeta name=\"author\" content=\"Josh\" /\u003e\n      \u003clink rel=\"author\" href=\"https://twitter.com/joshcstory/\" /\u003e\n      \u003cmeta name=\"keywords\" content={post.keywords} /\u003e\n      \u003cp\u003e\n        Eee equals em-see-squared...\n      \u003c/p\u003e\n    \u003c/article\u003e\n  );\n}\n```\n\nReact가 이 컴포넌트를 렌더링할 때 `title`, `link`, `meta` 태그를 찾아서 자동으로 문서의 `head` 섹션으로 끌어올려 줘요. 이러한 메타데이터 태그를 네이티브로 지원함으로써 클라이언트 전용 앱, 스트리밍 SSR 및 서버 컴포넌트와 함께 작동하도록 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 19 업데이트 내용에 대한 의견이 궁금하신가요? React 19의 개선된 기능에 대한 자세한 내용은 React 공식 블로그의 원문을 참조해주세요.\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-05-01-React19BetaReleasedWhatYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":11},{"title":"Node.js 애플리케이션을 디버깅하는 방법","description":"","date":"2024-05-01 17:44","slug":"2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png\" /\u003e\n\n이 튜토리얼에서는 Node.js 애플리케이션 코드를 디버깅하는 가장 쉽고 효율적인 방법을 배웁니다.\n\n그럼 시작해봅시다.\n\n이 튜토리얼의 비디오 버전을 보고 싶나요? 아래 비디오를 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적으로 우리가 Node.js 애플리케이션을 디버깅하는 방법\n\n만약 우리가 어떤 Node.js 애플리케이션을 디버깅하고 싶다면, 보통 디버깅하려는 코드에 console.log 문을 추가하여 어떤 변수의 값을 찾아내려고 합니다.\n\n이 방법은 작동하지만 출력한 값을 보려면 계속 콘솔 로그를 확인해야 합니다.\n\n하지만 콘솔에 출력된 데이터가 중첩 객체를 포함하거나 많은 데이터인 경우 console.log를 사용하는 것은 실용적이지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 좋은 방법이 있어요.\n\n# 코드 디버깅을 위해 Debugger 추가하기\n\n대신에 우리는 디버그하고 싶은 코드에 debugger; 문을 추가할 수 있어요.\n\n아래 코드에서 보듯이 Express.js API 라우트를 가지고 사용자를 등록하는 경우를 가정해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// controllers/auth.js\n\nconst register = async (req, res) =\u003e {\n  try {\n    const { email, password } = req.body;\n    const existingUser = await User.findOne({\n      email,\n    });\n    if (existingUser) {\n      return res.status(400).send('이미 등록된 사용자가 해당 이메일로 존재합니다');\n    }\n    // 추가 코드\n    return res.status(201).send();\n  } catch (error) {\n    console.log(error);\n    return res\n      .status(500)\n      .send('새 사용자 등록 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n  }\n};\n\nmodule.exports = { register };\n\n// routes/auth.js\nconst { register } = require('../controllers/auth');\n\nconst Router = express.Router();\n\nRouter.post('/api/register', register);\n```\n\n그리고 사용자 등록시 문제가 발생하여 register 함수 코드를 디버그하려고 합니다.\n\n이 경우, 다음과 같이 register 함수 코드 내에 debugger; 문을 추가하면됩니다:\n\n```js\nconst register = async (req, res) =\u003e {\n  try {\n    const { email, password } = req.body;\n    debugger;\n    const existingUser = await User.findOne({\n      email,\n    });\n    if (existingUser) {\n      return res.status(400).send('이미 등록된 사용자가 해당 이메일로 존재합니다');\n    }\n    // 추가 코드\n    return res.status(201).send();\n  } catch (error) {\n    console.log(error);\n    return res\n      .status(500)\n      .send('새 사용자 등록 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 디버깅을 위한 애플리케이션 실행 방법\n\n일반적으로, Node.js 애플리케이션을 실행하려면 다음 명령을 실행합니다:\n\n```js\nnode index.js\n```\n\n하지만 대신에, 다음 명령을 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n노드를 검사하려면 index.js를 입력하세요.\n```\n\n여기에서는 단순히 inspect 키워드를 추가했습니다.\n\n위 명령을 실행하면 다음과 같이 출력이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_1.png\" /\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 출력에서 디버거가 연결된 것을 확인할 수 있어요, 이제 코드 디버깅을 시작할 수 있어요.\n\n크롬 브라우저를 열고 브라우저 URL에 chrome://inspect를 입력하세요.\n\n아래와 같은 출력이 나타날 거에요:\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 `node inspect index.js` 명령을 실행하여 inspecting을 시작했으니, 원격 대상 섹션 아래에 새로운 대상 항목이 표시된 것을 볼 수 있어요.\n\n그럼, 표시된 파란색 inspect 링크를 클릭하면 아래 이미지처럼 새로운 브라우저 개발 도구가 열릴 거에요:\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_3.png)\n\n위 이미지의 오른쪽 패널에서 볼 수 있듯이, 디버거 일시 중지 메시지가 표시되고 디버깅 제어가 코드의 첫 줄에 있는 것을 확인할 수 있어요 (하이라이트된 노란색 줄로 확인 가능합니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 코드의 첫 번째 줄부터 디버깅을 시작하려는 것은 원하지 않습니다. 대신, 등록 코드만 디버깅하려고 합니다. 아래 디버거 일시 중지 메시지 위에 표시된 파란 삼각형 아이콘을 클릭해주세요:\n\n![Debug icon](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_4.png)\n\n지금이 창을 닫지 마세요. 대신에 Postman을 사용하여 응용 프로그램에서 사용자를 등록하거나 API 호출을 해보세요. 그렇게 하면 이전에 추가한 /register route 핸들러 코드가 실행될 것입니다.\n\n![API call](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 새 계정 만들기 버튼을 클릭하면 자동으로 debugger; 문이 추가된 코드로 리디렉션됩니다.\n\n이제 코드를 줄 단위로 디버깅하고 각 변수의 값을 볼 수 있으며 디버깅 중에 문제를 찾아 수정할 수 있습니다.\n\n# 디버깅 중 변수 액세스하기\n\n때로는 디버깅 중에 마우스를 가리키면 실제 값이 표시되는 변수가 너무 길어서 많은 속성을 가진 객체일 수 있습니다. 그래서 간단하게 마우스 오버로는 쉽게 볼 수 없을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 디버거가 계속 활성화된 채로 콘솔 탭을 열고 우리가 보고 싶은 변수의 이름을 입력할 수 있어요. 이 과정은 아래 GIF에서 확인할 수 있어요:\n\n![예시 이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_6.png)\n\n이렇게 우리는 Node.js 어플리케이션 코드를 쉽게 디버깅할 수 있어요.\n\n# 디버깅을 위한 스크립트 작성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널에서 매번 node inspect index.js 명령어를 수동으로 입력하기 싫다면, package.json 파일 안에 아래와 같이 새로운 디버그 스크립트를 생성할 수 있어요:\n\n```js\n\"scripts\": {\n    \"start\": \"node index.js\",\n    \"debug\": \"node inspect index.js\",\n    \"dev\": \"nodemon index.js\"\n},\n```\n\n그래서 이제 npm run debug 명령어를 실행하여 애플리케이션을 디버그 모드로 시작할 수 있어요.\n\n# 간단한 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js 애플리케이션을 디버깅하려면 다음 단계를 따라야합니다:\n\n- 디버깅하려는 코드 내에 디버거 문을 추가합니다.\n- node inspect index.js 또는 node inspect server.js 명령을 실행하여 디버그 모드로 애플리케이션을 시작합니다.\n- Chrome 브라우저에서 URL chrome://inspect에 액세스합니다.\n- 원격 대상 섹션 아래의 inspect 링크를 클릭합니다.\n- index.js 또는 server.js 파일의 첫 줄부터 디버깅을 시작하고 싶지 않다면 파란 삼각형 아이콘을 클릭합니다.\n- debugger; 문이 추가된 곳에서 코드를 트리거하는 API 호출 또는 작업을 수행합니다.\n- 이렇게하면 코드를 줄 단위로 디버깅하여 문제를 찾을 수 있습니다.\n\n# 읽어 주셔서 감사합니다\n\n이 튜토리얼은 여기까지입니다. 새로운 것을 배우셨기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 튜토리얼의 비디오 버전을 시청하고 싶으신가요? 이 비디오를 확인해보세요.\n\n만일 자바스크립트, ES6+, 리액트, 그리고 노드.js를 쉽게 이해할 수 있는 내용으로 습득하고 싶다면, 제 유튜브 채널을 확인해보세요. 구독하기를 잊지 마세요.\n\n정기적인 자바스크립트, 리액트, 그리고 노드.js 콘텐츠로 계속해서 최신 소식을 받고 싶다면, 링크드인에서 저를 팔로우하세요.\n\n![이미지](/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_7.png)","ogImage":{"url":"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoDebugNodejsApplicationsUsingthedebuggerStatementEasiestWay_0.png","tag":["Tech"],"readingTime":6},{"title":"거대Nx의 관례를 따르는 재현 가능한 Nx 워크스페이스","description":"","date":"2024-05-01 17:41","slug":"2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions","content":"\n\n## 거대한 Nx 모노 레포 유지 및 확장에 대한 주관적인 접근\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png)\n\n- 거대한 Nx의 규칙\n  - 프로젝트 유형\n  - 재현 가능한 생성\n  - 일관된 모노 레포\n- 당신의 워크스페이스 생성해봐요\n  - 1. 규칙 정의하기\n  - 2. create-huge-nx CLI 사용하기\n- 더 많은 프리셋\n- 마지막으로 생각할 것들\n\n여러 조직을 Nx 모노 레포로 이전하고 유지 관리한 후, 각 주요 Nx 버전마다 새로운 리포지토리를 만들어 기존 리포를 모방하여 구성 파일을 비교하고 최신 Nx 버전과 일치하는지 확인했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 원본을 반영하는 완전한 리포를 다시 만드는 것은 많은 노동이 필요했습니다. 처음에는 Bash 스크립트를 사용했고, 그 다음으로는 Node.js 스크립트를 사용했습니다. 최종적으로는 HugeNx를 개발했습니다. 이는 구성 파일에서 워크스페이스를 생성하는 사용자 지정 Nx 프리셋입니다.\n\n더 깊게 생각해 본 결과, 저는 단순히 워크스페이스를 생성하기 위한 파일을 만드는 것이 아니라, 워크스페이스 규칙을 설명하고 다른 목적에도 활용할 수 있는 파일을 만들고 있음을 깨달았습니다.\n\n# HugeNx의 규칙\n\n이 라이브러리의 주요 개념은 HugeNx의 규칙 파일입니다. 이 파일은 Nx 워크스페이스에 대해 내린 모든 관례적인 결정을 그룹화한 구성 파일입니다. 이 파일은 작업 공간이 어떻게 보이는지 설명할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_1.png](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_1.png)\n\nHugeNx의 Conventions 파일에 대상 워크스페이스에 관한 모든 정보가 들어 있다면, 새로운 워크스페이스를 처음부터 생성하거나 기존 워크스페이스를 유지할 수 있습니다.\n\n## 프로젝트 유형\n\n저는 통합하고자 하는 첫 번째 주요 규칙은 Nx 프로젝트 유형 개념입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx 워크스페이스를 구성하는 여러 가지 자료들을 탐색하면, 라이브러리를 범위 또는 유형별로 분류하고 경계를 정의하는 태그를 만드는 방법에 대한 상세한 설명을 만나게 될 거에요:\n\n- 코드 구조화 및 명명 규칙\n- 라이브러리 유형\n- 도메인 주도 설계\n\n하지만 저는 항상 이 ProjectTypes 목록을 구체적으로 지정하는 중심화된 방법이 부족했어요. 프로젝트를 생성할 때 소스 생성기 및 관련 기술과의 링크를 잃게 돼버리거든.\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 그 정보를 유지하고 싶었던 이유입니다. HugeNx의 컨벤션을 활용하면 프로젝트를 인식할 수 있습니다. 왜냐하면 그 프로젝트들은 당신이 지정한 규칙을 따를 것이기 때문이죠.\n\n## 재현 가능한 생성\n\nNx로 프로젝트를 시작하면 모든 것이 깨끗하고 일관되게 정렬됩니다. 그러나 시간이 지나면서 우리는 마이그레이션을 적용하고 사용자 정의 생성기를 만들며, 설정을 수동으로 수정하게 됩니다. 모든 이것이 개발자의 교체와 함께 누적되면 최종적으로는 좋지 않은 상황이 발생할 수 있습니다.\n\n이것은 특히 인프라 수준에서 인프라 구성 요소로 코드를 사용하는 개념과 함께 IT에서 해결하려는 일반적인 도전 과제입니다. Ansible과 같은 도구를 사용하면 스크립트와 구성 파일에서 전체 인프라를 초기화하고 다시 구성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx를 사용하면 프리셋 목록을 사용할 수 있지만 하드코딩되어 있습니다. 각각에는 몇 가지 옵션이 있지만 더 고급 워크스페이스를 생성하는 데 충분하지 않습니다.\n\n더 고급 워크스페이스를 만들고 싶다면 사용자 정의 프리셋을 만들어야 합니다. 이것은 씨앗을 생성하는 데 유용하지만 비교, 데모, 또는 워크샵을 위해 빠르게 워크스페이스를 생성하는 데는 번거로울 수 있습니다.\n\n그래서 저는 HugeNx의 컨벤션을 사용하여 Nx 워크스페이스를 생성할 수 있는 사용자 정의 Nx 프리셋을 만들기로 결정했습니다. 여러분은 자체 프리셋을 만들거나 유지할 필요가 없습니다!\n\n![Reproducible Nx Workspace](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx 버전에 맞게 전체 리포지토리를 다시 생성할 수 있습니다. 변경된 내용을 비교하거나 현재 Nx 프리셋을 생성하는 방식을 단순화하는 데 도움이 됩니다.\n\nHugeNx는 모든 Nx 플러그인을 지원하므로 모든 Nx 프리셋을 쉽게 재현하고 사용자 정의 프리셋을 만들 수 있습니다.\n\n## 일관성 있는 Monorepo\n\n처음부터 리포지토리를 생성하는 것은 좋지만 오랜 기간 유지하는 것이 더 좋지 않나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHugeNx의 규칙을 통한 주요 목표는 귀하의 작업 공간이 어떻게 보이고 작동해야 하는지 설명하는 가디언, 관리인이 되는 것입니다.\n\n![이미지](/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_4.png)\n\nEslint 규칙:\nEslint와 같은 도구를 활용하여 해당 파일을 읽고 규칙을 생성하여 다음을 시행할 수 있습니다:\n\n- 각 프로젝트가 명명 규칙을 따르는지 확인\n- 작업 공간 구조를 확인\n- 각 프로젝트가 올바르게 하나의 ProjectType과 관련되어 있는지 확인\n- nx.json 생성기의 옵션을 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 발견하기:\nNx Project Crystal에서 제공하는 프로젝트 추론 기능을 통해 네이밍 규칙에 따라 손쉽게 Nx 프로젝트를 발견할 수 있습니다.\n\n또한 프로젝트 유형 네이밍 규칙과 일치하는 하나의 Nx 플러그인을 생성하고 프로젝트 구성을 자동으로 연결할 수도 있습니다!\n\n마이그레이션:\n특정 Nx 버전을 위해 새로운 작업 공간을 처음부터 다시 생성할 수 있다는 사실과 관련하여, 이제 최신 Nx로 작업 공간을 손쉽게 생성하고 기존 작업 공간과 비교할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 타입 무한히 변경하고 싶다면 Betterer와 같은 도구를 사용할 수도 있어요. 이를 통해 당신의 저장소를 HugeNx의 규칙에 맞게 단계적으로 이동할 수 있어요.\n\n프로젝트 타입 생성기:\n복잡하고 특수한 생성기를 만들 필요가 없어요. 프로젝트 타입을 읽고 해당 내용으로 프로젝트를 생성해주는 생성기를 만들 수 있어요.\n\n# 워크스페이스 생성해볼까요?\n\n새 TypeScript 파일을 생성해보면서 구체적인 예시로 시작해봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 규칙 정의하기\n\n호텔을 관리하는 풀스택 애플리케이션을 만들기 위한 작업 공간을 포함하는 huge-angular-full-stack.conventions.ts 파일을 만들 수 있습니다:\n\n```js\nexport default {\n  version: '1.0',\n  generators: {\n    '@nx/angular:application': { //\u003c-- 생성기 식별자\n      linter: 'eslint', //\u003c-- 옵션 목록\n      style: 'css',\n      unitTestRunner: 'jest',\n      bundler: 'esbuild',\n      e2eTestRunner: 'playwright',\n      inlineStyle: true,\n      inlineTemplate: true,\n    },\n    '@nx/angular:library': {\n      linter: 'eslint',\n      unitTestRunner: 'jest',\n    },\n    '@nx/angular:component': {\n      style: 'css',\n    },\n    '@nx/js:lib': {\n      bundler: 'swc',\n    },\n  },\n  projectTypes: {\n    'global:angular:app': { //\u003c-- 프로젝트 유형 식별자\n      projectPattern: '*-app', //\u003c-- 규칙과 일치하는 프로젝트 명칭\n      generators: [{ generator: '@nx/angular:application' }], //\u003c-- 해당 유형의 프로젝트를 생성하는 데 사용되는 생성기 목록\n    },\n    'backend:api': {\n      projectPattern: '*-api',\n      generators: [{ generator: '@nx/nest:application' }],\n    },\n    'global:angular:lib:data-access': {\n      projectPattern: '*-data-access',\n      generators: [{ generator: '@nx/angular:library' }],\n    },\n    'global:angular:lib:feature': {\n      projectPattern: '*-feature',\n      generators: [{ generator: '@nx/angular:library' }],\n    },\n    'global:angular:lib:ui:storybook': { //\u003c-- 이 프로젝트 유형은 라이브러리를 생성한 다음 storybook 구성을 생성함\n      projectPattern: '*-ui',\n      generators: [{ generator: '@nx/angular:library' }, { generator: '@nx/storybook:configuration', options: { uiFramework: '@storybook/angular' } }],\n    },\n    'global:ts:lib:utils': {\n      projectPattern: '*-utils',\n      generators: [{ generator: '@nx/js:lib', options: { bundler: 'swc' } }],\n    },\n  },\n  workspace: { //\u003c-- 작업 공간은 폴더와 프로젝트로 구성됨\n    apps: {\n      //\u003c-- apps 폴더 생성\n      'hotel-app': 'global:angular:app', //\u003c-- global:angular:app 프로젝트 유형을 이용하여 hotel-app 프로젝트 생성\n      'hotel-api': { //\u003c-- backend:api 프로젝트 유형을 이용하여 hotel-api 프로젝트를 생성하고 추가 옵션을 사용\n        projectType: 'backend:api',\n        options: {\n          '@nx/angular:remote': { frontendProject: 'hotel-app' },\n        },\n      },\n    },\n    libs: { //\u003c-- libs 폴더 생성\n      guest: { //\u003c-- guest 폴더 생성\n        'data-access': 'global:angular:lib:data-access', //\u003c-- global:angular:lib:data-access 프로젝트 유형을 이용하여 guest-data-access 프로젝트 생성\n        'booking-feature': 'global:angular:lib:feature', //\u003c-- global:angular:lib:feature 프로젝트 유형을 이용하여 guest-booking-feature 프로젝트 생성\n        'feedback-feature': 'global:angular:lib:feature', //\u003c-- global:angular:lib:feature 프로젝트 유형을 이용하여 guest-feedback-feature 프로젝트 생성\n      },\n      room: { //\u003c-- room 폴더 생성\n        'data-access': 'global:angular:lib:data-access',\n        'list-feature': 'global:angular:lib:feature',\n        'request-feature': 'global:angular:lib:feature',\n      },\n      shared: { //\u003c-- shared 폴더 생성\n        ui: { //\u003c-- global:angular:lib:ui:storybook 프로젝트 유형을 이용하여 shared-ui 프로젝트를 생성하고 추가 옵션을 사용\n          projectType: 'global:angular:lib:ui:storybook',\n          options: {\n            '@nx/storybook:configuration': { project: 'shared-ui' },\n          },\n        },\n        utils: 'global:ts:lib:utils',\n      },\n    },\n  }\n};\n```\n\n기본 생성기 옵션\nNx에서 이미 사용 가능한 것이며, 워크스페이스에서 사용 중인 각 생성기의 기본 옵션을 정의할 수 있는 nx.json 파일을 구성함으로써 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx API 문서에서 모든 Nx 옵션을 찾을 수 있어요.\n\n프로젝트 유형 목록\n여기서는 기술, 도메인, 라이브러리 유형, 팀 등을 기반으로 하는 ProjectType 목록을 정의할 거에요.\n\n각 ProjectType에 대해 사용해야 하는 생성기와 주변 규칙을 모두 지정할 거예요. 기본 생성기 옵션을 사용하며 필요하면 추가 옵션을 추가할 수 있어요.\n\n작업 영역 구조\n마지막으로 작업 영역 레이아웃 내에서 프로젝트 목록을 정의할 거에요. 각 프로젝트는 특정 ProjectType에 의해 연결되고 설명될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 섹션은 생성에는 필요하지만 유지에는 필요하지 않습니다.\n\n## 2. create-huge-nx CLI 사용하기\n\n작업 영역을 생성하려면 이제 다음과 같이 HugeNx CLI를 사용할 수 있습니다:\n\n```js\nnpx create-huge-nx@latest my-workspace --hugeNxConventions=./huge-angular-full-stack.conventions.ts --nxCloud skip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 작업 공간을 생성할 것입니다:\n\n```js\nmy-workspace/\n├─ apps/\n│   ├─ hotel-api/\n│   ├─ hotel-api-e2e/\n│   ├─ hotel-app/\n│   └─ hotal-app-e2e/\n├── libs/\n│   ├─ guest/\n│   │   ├─ data-access\n│   │   ├─ booking-feature\n│   │   └─ feedback-feature\n│   ├─ room/\n│   │   ├─ data-access\n│   │   ├─ list-feature\n│   │   └─ request-feature\n│   └─ shared/\n│       ├─ ui\n│       └─ utils\n├─ nx.json\n├─ package.json\n├─ jest.config.json\n└─ huge-nx.conventions.ts\n```\n\n기본적으로는 최신 버전의 Nx가 사용될 것이지만, --nxVersion으로 특정 Nx 버전으로 작업 공간을 생성할 수 있습니다:\n\n```js\nnpx create-huge-nx@latest my-workspace --nxVersion 17 --hugeNxConventions=./huge-angular-full-stack.conventions.ts --nxCloud skip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 많은 프리셋\n\n이제는 새로운 huge-nx.conventions.ts 파일을 소개함으로써 다양한 유형의 저장소를 간단히 만들 수 있습니다. 이 방식은 Nx의 모든 프리셋을 포괄하는 뿐만 아니라 Nx 문서의 라이브러리 유형 섹션에 설명된 대로 각 프로젝트 유형을 자세하게 설명할 수 있도록 합니다.\n\n예를 들어, @angular-architects/ddd 패키지의 유형을 정의하고 이 정의를 사용하여 워크스페이스를 생성할 수 있습니다. 이 유연성을 통해 Nx의 강력하고 확장 가능한 도구 생태계를 활용하여 프로젝트의 특정 요구 사항에 맞는 매우 사용자 정의된 설정을 제공할 수 있습니다.\n\n저는 ChatGPT를 사용하여 컨벤션 파일을 생성했습니다. 파일의 예시를 제공하고 특정한 목적을 설명했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Nx 워크스페이스를 나타냅니다.\n- Angular 생성기를 사용해야 합니다.\n- 호텔 비즈니스를 나타냅니다.\n- 풀 스택 앱이어야 합니다.\n\n# 마지막으로\n\nHugeNx의 규칙은 특히 대규모 및 계속 발전 중인 단일 레포지토리를 관리하는 사람들을 위해 Nx 환경에서 유용한 도구를 제공하기 위해 만들어졌습니다.\n\n워크스페이스 설정을 자동화하고 표준화함으로써 프로젝트 생성 및 유지보수와 관련된 복잡성을 줄이는 데 도움이 됩니다. 이 접근 방식은 이주 과정에서 시간과 노력을 절약하는 데 도움이 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 여러분의 피드백을 기다리며 HugeNx를 개선하고자 합니다. 개발 툴킷에 귀한 추가가 될 수 있기를 희망합니다. 여러분의 아이디어와 경험이 이 도구를 완성하는 데 중요합니다. 그러니 의견을 공유해주세요.\n\n곧 다시 만나요! 🚀\n\n# 관련 정보\n\n# 간단하게 이해하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제발 공개 커뮤니티인 In Plain English의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 글쓴이를 박수로 응원하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png"},"coverImage":"/assets/img/2024-05-01-ReproducibleNxWorkspacewithHugeNxsConventions_0.png","tag":["Tech"],"readingTime":10},{"title":"React의 useEffect를 초기 렌더링 단계에서 건너뛸 수 있는 방법","description":"","date":"2024-05-01 17:40","slug":"2024-05-01-HowtoSkipReactuseEffectonInitialRender","content":"\n\n```\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png)\n\n많은 React 개발자들이 클래스 컴포넌트보다 함수 컴포넌트를 선호합니다. 함수 컴포넌트는 더 작고, 자체 상태를 관리하는 자식 UI 요소를 구성하는 기능을 제공합니다. 그러나 몇 가지 단점이 있습니다. 최근 버그 찾기 세션에서 한 가지 문제점은 함수 컴포넌트의 초기 렌더 기능을 제어할 수 없다는 것이었습니다. 폼 페이지의 첫 번째 렌더에서 useEffect 호출을 우회하지 않아 발생한 오류를 발견했을 때 이것이 분명해졌습니다.\n\n## useEffect와 어떤 문제가 있었나요?\n\nuseEffect 훅은 React 개발자들이 컴포넌트 상태에 기반한 작업을 대기열에 넣을 수 있게 합니다. React는 JQuery와 같은 선행자들과 다르게 상태 유지(stateful) 또는 상태 없음(stateless) 컴포넌트를 구축할 수 있도록 허용합니다. 이러한 컴포넌트는 내부 상태 변수를 통해 사용자 상호작용과 데이터를 추적할 수 있습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseEffect 훅은 상태를 가지고 있는 컴포넌트의 기능을 더 발전시킵니다. useEffect의 주요 부분은 작업을 수행하는 콜백 함수와 변경 사항을 감시할 상태 변수의 배열입니다. 상태 변수 중 하나라도 변경되면 콜백이 실행됩니다:\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_1.png)\n\n이 훅을 사용하면 상태 변경으로부터 작업을 트리거할 수 있지만 일부 제한 사항이 있습니다. 우리가 주로 다루는 주요 제한 사항은 useEffect 콜백이 초기 렌더링 중에 호출되어 앱에 의도치 않은 부작용을 일으킬 수 있다는 것입니다.\n\n## 멀티 셀렉트에서 제품 데이터 로드하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제와 해결책을 살펴보려면 사용자가 목록에서 항목을 선택하고 모든 항목의 정보를 볼 수 있는 페이지를 만드는 티켓을 받았다고 상상해보세요. 사용자는 초기 페이지 로드에 검색 창을 사용하여 임의의 쿼리 용어를 입력할 수 있습니다. 이 쿼리는 API 호출을 트리거하여 서버에서 연속되는 검색 용어 항목 컬렉션을 반환합니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_2.png\" /\u003e\n\n이 페이지의 상태를 설정하는 일반적인 방법은 검색 창을 제어 컴포넌트로 만드는 것입니다 (즉, 부모 페이지 컴포넌트가 이 입력 상태를 유지하고 쿼리 값을 다시 입력으로 보내 표시합니다) 그리고 입력에 대한 onChange 이벤트 핸들러를 갖는 것입니다. 불필요한 API 호출을 피하기 위해 입력에 debounce를 추가하여 키가 눌릴 때마다 API 호출을 방지할 수 있습니다. 쿼리는 제품에 대한 API 호출을 트리거할 useEffect 훅에 추가됩니다.\n\n이 프로세스의 요약은 다음과 같습니다: 사용자가 텍스트 입력란에 용어를 입력하면 입력이 쿼리 상태를 업데이트하고 쿼리 상태가 useEffect를 트리거하여 데이터를 얻기 위해 API에 요청을 보냅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_3.png)\n\n이론적으로는 텍스트 입력란에 사용자가 입력할 때마다 API 호출을 하는 좋은 설정이 있습니다. 실제로 콘솔을 열면 페이지가 처음로드될 때 useState의 쿼리에 대한 기본값이 무엇이냐에 따라 쿼리 용어로 '정의되지 않음' 또는 빈 문자열과 함께 API 호출이 트리거됨을 볼 수 있습니다. useEffect가 일찍 호출되어 불필요하게 호출됩니다.\n\n## useRef를 사용하여 초기 렌더링 useEffect 호출 우회 방법\n\n문서에서 명확하지 않지만, 컴포넌트가 로드될 때 상태 변수들이 초기로 설정되면 useEffect 훅이 값이 변경되거나 정의될 때 트리거되어 부작용을 일으킬 수 있습니다. 초기 렌더링에 대한 useEffect 동작을 우회해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떻게 해야 할까요? 제가 찾은 가장 좋은 방법은 useRef 훅을 사용하는 것입니다. 이 훅을 사용하면 상태와는 관련이 없는 값을 설정하고 참조할 수 있습니다. 그 문장의 마지막 부분이 중요한데요, 상태 변경은 다른 훅 및 컴포넌트가 어떻게 그리고 언제 다시 렌더링되는지에 영향을 미치게 됩니다.\n\n페이지가 초기 렌더링되었는지 여부를 확인하여 useEffect가 사용자 상호작용에서 호출되었는지 알아내고 싶습니다. 이를 위해 hasPageBeenRendered용 useRef 변수를 만들 수 있습니다. 그 후에 useRef 변수를 참조하는 조건부 래퍼로 useEffect 콜백을 감쌀 수 있습니다. 간단한 예는 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_4.png)\n\nReact 변수를 가져와서 useRef 변수를 초기화하고, useState로 쿼리 값을 초기화하고, API 호출 로직을 설정합니다. useRef의 초기 상태는 false이므로 useRef를 true로 설정하기 전에 API 호출을 우회합니다. 이후 API 호출 로직으로 들어가서 데이터베이스를 쿼리하여 다음 호출에 대한 정보를 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이 방식의 문제점\n\n이제 브라우저와 서버 콘솔에서 불필요한 호출과 오류가 사라져 좋은 결과를 거뒀네요. 그러나, 이것은 간단한 예제일 뿐입니다. 만약 우리가 초반 트리거를 방지하고 싶은 여러 useEffect 메소드가 있다면 어떻게 될까요?\n\n각각의 useEffect에 대해 별도의 useRef 변수를 생성할 수 있습니다. 각각의 useEffect가 초기 렌더링 시 호출되는 것을 막고 싶다면 우리는 각 useEffect에 대해 하나의 useRef를 생성할 수 있습니다. 이 방법도 가능하지만, 더 복잡한 로직이 들어갈수록 컴포넌트 헤더가 엉망이 될 것입니다.\n\n각 useEffect에 새로운 useRef를 추가하는 대신에, useRef 값을 다차원으로 만들어서는 어떨까요? 현재 useRef는 부울 값을 설정 및 업데이트하고 있습니다. 코드를 정리하기 위해 useRef 값을 해시로 설정하여 각 키가 다른 useEffect를 가리키도록 할 수 있습니다. 이렇게 보일 것입니다: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표현한 내용입니다.\n\n\n![How to Skip React useEffect on Initial Render](/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_5.png)\n\n이러한 방법으로 중앙 useRef 변수로 모든 로직을 관리할 수 있어요. 이 작은 수정으로 함수 컴포넌트를 지저분하게 만들지 않으면서도 많은 useEffect를 관리할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoSkipReactuseEffectonInitialRender_0.png","tag":["Tech"],"readingTime":4},{"title":"리덕스 사가 사용하는 방법(기초)","description":"","date":"2024-05-01 17:33","slug":"2024-05-01-GettingStartedwithReduxSagaTutorial","content":"\n## 리덕스 기초를 제공하는 새가 튜토리얼입니다. 기초부터 고급 수준까지의 예제를 통해 리덕스 사가를 배워보세요. 리덕스 사가 개념을 활용하여 블로그 앱을 만들어보세요.\n\n![](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png)\n\n## 배경:\n\n약 2개월 전에 리덕스 사가를 배우기 시작했고, 리덕스에 대한 이해도가 조금밖에 없었습니다. 처음에는 혼란스러울 수 있지만, 한번 감을 잡게 되면 코드가 더 깔끔해지고 앱도 더 나아질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 일반적으로 하는 것과는 다른 방식으로 정보를 공유해보려고 노력했습니다. 여러 작은 앱을 만들어 한 가지 또는 여러 개념을 이해하는 데 중점을 두었습니다. 이 기사가 여러분이 실용적인 방식으로 개념을 이해하는 데 도움이 되기를 바랍니다.\n\n## 어떻게 진행할 것인가요?\n\n리덕스에 대해 간단히 다시 설명한 후 리덕스 사가의 다양한 개념을 예제와 함께 이해하는 데 도움이 될 것입니다.\n\n## 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n필요한 라이브러리는 다음과 같습니다:\n\n```js\nyarn add @reduxjs/toolkit@1.8.3\nyarn add react-redux@8.0.2\nyarn add redux-saga@1.1.3\n//선택 사항\nyarn add axios@0.27.2\n```\n\n연습용으로 새 리액트 또는 리액트 네이티브(원하는 대로 선택) 프로젝트를 만들고 위의 패키지를 설치하세요. 저는 'redux-saga-tutorial'이라는 프로젝트를 만들었습니다:\n\n```js\nnpx create-react-app redux-saga-tutorial\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_1.png)\n\n# Redux 간단 안내:\n\n리덕스의 몇 가지 개념을 빠르게 되새겨 보겠습니다. 이 섹션 끝에는 기본적인 리덕스 예제가 풀코드로 제공됩니다.\n\n초기 상태 / 전역 상태:\n초기 상태는 앱의 모든 초기 값이 있는 일반 JS 객체입니다. 모든 최신 값이 포함된 전역 상태라고도 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 앱 전체가 숫자를 증가 및 감소하는 데 관한 것이라면 초기 상태는 `value: 0, name: ''`와 같은 객체여야 합니다. API에서 아직 로드되지 않은 데이터와 같은 추가적인 사항이 있다면 초기 상태는 `allUserChats: [], allUsers: [], isLoggedIn: false...`와 같이 정의할 수 있습니다. 앱에서 필요한 모든 것들의 기본값을 가진 초기 상태를 사용할 수 있습니다.\n\n최신 업데이트된 초기 상태의 값은 저장소에 유지될 것입니다. 저장소를 진실의 단일 출처로 생각하고 redux가 제공하는 저장소에서 값을 읽고 업데이트할 것입니다.\n\n액션:\n액션은 일반적인 JS 문자열입니다. 일반적으로 `domain/eventName`와 같은 형태로 선언합니다. 이러한 상수는 `profile/updateName`과 같은 고유한 액션의 이름입니다. 모든 것에는 액션 변수가 있어야 합니다.\n\n액션은 앱에서 일어날 수 있는 모든 것으로 생각할 수 있습니다. 예를 들어, 앱에서 특정 API를 호출한다면 해당 API를 호출하는 액션이 있어야하며, 성공한 경우의 다른 액션 및 데이터를 검색하는 데 실패한 경우의 다른 액션이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n액션 크리에이터:\n우리는 const SOME_ACTION_NAME = `domain/eventName`과 같이 액션 문자열을 만들고, 데이터를 전달할 수 있는 함수인 액션 크리에이터를 생성합니다. 보통, 액션 크리에이터에는 두 가지가 있습니다. 첫 번째는 우리가 만든 변수를 전달할 수 있는 액션의 이름인 type이고, 두 번째는 데이터를 보내는 payload입니다. payload라는 이름은 아무것이나 될 수 있습니다.\n\n```js\nfunction someActionCreator(text) {\n  return { type: SOME_ACTION_NAME, payload: text };\n}\n```\n\n만약 const NAME_UPDATED = `profile/updateName`와 같은 이름의 액션이 있다면, 해당 액션 크리에이터는 다음과 같을 것입니다:\n\n```js\nfunction updateProfile(text) {\n  return { type: NAME_UPDATED, payload: text };\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npayload과 type은 원하는 대로 이름을 지을 수 있어요. 대부분의 개발자들이 사용하는 규칙이죠.\n\nReducer:\nReducer는 두 가지를 받는 함수에요:\n\n- 초기 상태의 현재 상태\n- 액션 객체 (기본적으로 액션 생성자)\n\n```js\nconst initialState = { name: \"\" };\nfunction myReducer(state = initialState, action) {\n  switch (action.type) {\n    case NAME_UPDATED:\n      return { ...state, name: action.payload };\n    default:\n      return state;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nswitch 문이 있다. 이 switch 문은 NAME_UPDATED 액션을 찾는데, 보통 상수로 선언된 별도의 파일에 있을 것입니다. 예를 들어, const NAME_UPDATED = `profile/updateName` 같은 식으로 선언될 것입니다.\n\n어떤 액션이 취해지면 해당 리듀서를 호출하고, 리듀서는 취해진 액션을 확인하고 초기 상태를 업데이트할 겁니다. 이러한 요소를 아직 연결하지는 않았지만요.\n\n이제 받게 될 액션은 state와 action 두 가지를 가질 겁니다. action은 우리가 위에서 액션 생성기 섹션에서 본 것처럼 객체일 겁니다. 그리고 우리는 보내는 type과 payload를 사용할 겁니다.\n\nProvider / Redux를 주요 애플리케이션에 연결하기:\nRedux 레이어 안에 우리 앱을 래핑하는 방법을 빠르게 살펴볼게요. 이를 통해 store 객체를 앱 전반에 걸쳐 접근 가능하게 만들 수 있습니다. index.js 같은 주 파일에서, 우리는 Provider를 가져와서 앱을 감싸는데, 이것은 접근이 필요한 모든 중첩된 컴포넌트에 store를 사용할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Provider } from \"react-redux\";\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { myReducer } from \"../reducers\";\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\n// const rootReducer = combineReducers({myFirstReducer}); //in case you have more than one reducer. Don't forget to import it from @reduxjs/toolkit\nconst store = configureStore({ reducer: myReducer });\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cProvider store={store}\u003e\n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\n위의 코드에서는 하나의 reducer와 하나의 액션을 갖는 스토어 내에 전체 `App /`을 감쌌습니다. 이제 앱에서 디스패치가 발생하면 Provider가 해당 디스패치를 캐치하고 스토어에 전달합니다. 그런 다음 스토어는 리듀서로 이동하여 함수를 실행합니다.\n\n디스패치:\n어떻게 액션을 트리거할까요? 현재 액션은 한 파일에 있고 리듀서는 다른 파일에 있습니다. Redux가 리듀서로 이동하고 올바른 작업을 수행하도록 액션이 트리거되어야 합니다. 이때 디스패치(dispatch)가 필요합니다. `react-redux`에서 import useDispatch를 사용하여 가져올 수 있고, 다음과 같이 변수를 만들어서 액션의 디스패처로 사용할 수 있습니다: const dispatch = useDispatch();. 버튼이 있고 그 버튼의 onPress에서 dispatch(type: NAME_UPDATED, payload: input.text); 같은 작업을 할 수 있지만, 앞서 updateProfile와 같은 액션 생성자를 만든 경우 다음과 같이 호출할 수 있습니다:\n\n```js\nimport { useDispatch } from 'react-redux';\nfunction example() {\n    const myDispatch = useDispatch();\n    return (\n        \u003cButton title='Update Name' onPress={() =\u003e {\n            myDispatch(updateProfile('input.text'))\n        } /\u003e\n    )\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 버튼을 눌렀거나 앱을 통해서도 동작을 수행할 수 있습니다. API 응답을 통해 작업을 트리거할 수 있습니다.\n\n선택기:\n선택기를 사용하면 리덕스 스토어에서 데이터를 추출할 수 있습니다. useDispatch와 마찬가지로 선택기에도 useSelector라는 훅이 있습니다.\n\n```js\nimport { useSelector } from \"react-redux\";\nfunction example() {\n  const mySelector = useSelector((store) =\u003e store);\n  return \u003cText\u003e{mySelector.name}\u003c/Text\u003e;\n}\n```\n\nuseSelector()는 뷰를 다시 렌더링하도록 강제하지만, 선택기 결과가 마지막 결과와 다른 것처럼 보일 때에만 다시 렌더링을 수행합니다. 전체 스토어를 반환하며, 초기 상태에 있는 것들에 접근할 수 있지만 업데이트된 값을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것을 함께 해보자!\n위의 예제를 다음 보일러플레이트 코드에 결합한 것을 살펴봅시다:\n\n위의 코드 예제에서는 App.js에서 액션을 디스패치했으며(useDispatch), App.js에서 이를 소비하고 있습니다(useSelector). 앱은 단순히 값을 업데이트하여 보이는 것을 빠르게 확인할 수 있습니다.\n\n이것은 리덕스가 어떻게 작동하는지에 대한 매우 간단한 예시입니다. 동일한 개념을 사용하여 다른 작업들을 구축할 수 있습니다. 예를 들어, API 데이터를 상태로 로드하는 경우에는 name 대신에 다른 이름을 사용할 수 있습니다. 예를 들어 allProductsData 또는 allUser 등이 될 것입니다. 그리고 이것은 문자열(string) 유형이 아니라 객체 또는 배열 [] 또는 객체들의 배열 또는 그 외의 것들이 될 것입니다. 따라서 다음과 같은 경우에는 액션을 생성하고 리듀서에서 처리할 수 있습니다. API 호출의 경우, 이 튜토리얼에서 이전에 작성한 파이어베이스 예시를 참조할 수 있습니다.\n\n이 내용이 유익하게 느끼는 분들을 위해, 새 페이지를 추가해보고 해당 페이지로 이동하여 선택기(selector)만 호출해보세요. 그러면 값이 업데이트된 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Redux Saga](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_2.png)\n\n# Redux Saga:\n\n가장 쉽게 설명하는 방법은 redux-saga는 비즈니스 로직을 프론트엔드로부터 분리한다는 것입니다. Saga는 이벤트 기반 솔루션이라고 언급할 수 있으며, 이벤트를 발생시키고 해당 이벤트에 대해 실행되어야 하는 로직을 처리합니다.\n\nRedux-saga가 어떻게 작동하는지 이해하려면 redux-saga의 개념을 이해한 후에 명확해질 수 있는 다양한 플로우 다이어그램을 찾을 수 있습니다. 여기에 하나의 다이어그램이 있습니다. 전반적인 아이디어를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Getting Started with Redux Saga Tutorial](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_3.png)\n\n위 다이어그램에서 사용자가 'Get Users' 버튼을 누르면 액션이 발생합니다. 이 액션은 사가로 전송되고, 사가 파일에서는 특정 액션이 취해졌을 때 어떻게 할지를 정의합니다. 특정 액션이 발생했을 때 우리 앱이 수행하길 원하는 API 또는 다른 유형의 기능을 의미합니다. 따라서 API 호출 / 결과 대기 단계는 사용자 액션이 발생했을 때 수행할 기능의 일부입니다. 이 단계가 점선으로 표시되는 이유는, 이것이 필수 단계가 아니며 사가가 직접적으로 리듀서로 이동할 수 있지만, 리듀서 확인은 과정에서 필수적인 단계이고, 리듀서는 필요에 따라 상태를 업데이트하거나 동일한 상태를 반환할 것입니다. 아래 GIF 이미지는 인터넷에서 발견한 것입니다. developpaper 웹사이트에서 찾았던 것 같은데, 리덕스 사가 환경에서 $10을 입금하는 액션이 어떻게 발생하는지 보여줍니다. GIF 아래의 미들웨어를 사가로 생각해보세요.\n\n![Redux Saga Tutorial GIF](https://miro.medium.com/v2/resize:fit:1400/1*AyYYoeDMTTK_7J7aCeaIUA.gif)\n\n위의 플로우를 기억하며, 사가 학습을 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스-사가의 개념을 이해하려면 API를 호출하는 간단한 예제를 살펴보는 것이 도움이 됩니다. 따라서 사가를 사용하여 이를 수행하는 프로그램을 작성해 보겠습니다. 그러나 그 전에 리덕스-사가를 이해하는 데 도움이 될 두 가지 JavaScript 관련 사항이 있습니다:\n\n- 제너레이터 함수\n- 제너레이터 함수에서의 yield 키워드\n\n제너레이터 함수에 대한 간단한 개관을 작성했는데 여기에는 yield 부분도 포함되어 있습니다.\n\n그래서 이 튜토리얼에서는 제너레이터 함수 및 yield에 대해 자세히 다루지는 않겠지만 사가를 배우려면 위의 JavaScript 개념을 알고 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 첫 번째로 우리 이야기를 시작하는 데 필요한 고수준의 설정을 해 봅시다. 우리가 store를 설정할 때 index.js 파일에서 한 것과 같이요.\n\n```js\n// ... 다른 imports\nimport { Provider } from \"react-redux\";\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport createSagaMiddleware from \"@redux-saga/core\";\nimport { myReducer } from \"./reducers\";\nimport App from \"./App\";\nconst rootElement = document.getElementById(\"root\");\nconst root = createRoot(rootElement);\nconst sagaMiddleware = createSagaMiddleware();\nconst store = configureStore({ reducer: myReducer, middleware: [sagaMiddleware] });\n// TODO: 곧 여기서 saga를 실행해야 합니다\nroot.render(\n  \u003cStrictMode\u003e\n    \u003cProvider store={store}\u003e\n      \u003cApp /\u003e\n    \u003c/Provider\u003e\n  \u003c/StrictMode\u003e\n);\n```\n\n위 코드에서 세 가지를 했어요:\n\n- 이름에 명시된대로 우리 앱에서 saga를 생성하는 데 도움이 될 createSagaMiddleware를 가져왔어요.\n- 우리가 모든 saga의 기능에 액세스할 수 있게 해주는 변수 sagaMiddleware를 생성했어요.\n- 변수 sagaMiddleware을 store에 포함시켜 reducer를 다룬 것과 같이 앱 전체에서 액세스할 수 있도록 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니까 세 가지 작업을 수행해서 saga가 앱 전반에 걸쳐 사용할 수 있도록 준비할 거에요. 저는 saga를 메시지를 지속적으로 수신 대기하면서 실행되는 서비스로 생각해요. 메시지가 시작되면 그 다음에 뭘 해야 하는지 알고 있어요.\n\n이 세 가지 작업을 actions.js에 추가해볼까요?\n\n```js\nexport const GET_USERS_FETCH = \"GET_USERS_FETCH\";\nexport const GET_USERS_SUCCESS = \"GET_USERS_SUCCESS\"; // API 호출을 성공적으로 완료할 때 호출될 거에요\nexport const GET_USERS_FAILURE = \"GET_USERS_FAILURE\"; // API 호출을 실패로 완료할 때 호출될 거에요\n```\n\n액션을 생성할 때 대부분의 경우 액션 크리에이터도 함께 만듭니다. 여기서는 GET_USERS_FETCH에 대한 액션 크리에이터만 필요할 거에요. dispatch와 함께 호출될 것이기 때문에 useDispatch가 인자로 객체를 가져야 하며, saga 이펙트를 사용할 때 문자열을 전달할 수 있어서 그에 대한 액션 크리에이터가 필요하지 않을 거에요. 그러니까 actionCreators.js에 해당 액션 크리에이터를 만들어봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { GET_USERS_FETCH } from \"./actions\";\nexport function takeGetUserFetchAction() {\n  return { type: GET_USERS_FETCH };\n}\n```\n\n매개변수가 필요하지 않기 때문에 단순히 타입만 반환하는 간단한 자바스크립트 객체입니다. 그러나 필요한 경우 매개변수를 전달해야 할 때는 redux 리프레셔 섹션에서 updateProfile(text)를 참조하십시오.\n\n이제 sagas.js라는 새 파일을 만들고 세 부분으로 이 파일을 만들어 보겠습니다:\n\nPART 1 — sagas를 사용하여 API를 호출하는 것이 목표이므로 먼저 API를 호출하고 응답을 반환하는 일반 함수를 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport axios from \"axios\";\nfunction userFetch() {\n  // 만약에 axios를 사용하고 싶지 않은 경우\n  //return.fetch('https://jsonplaceholder.typicode.com/users').then(response =\u003e response.json());\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n위의 부분에서는 간단히 res.data;를 반환하는 함수를 만들었으며, 성공적으로 검색하고 오류가 발생할 경우 err을 throw합니다.\n\n파트 2 — 이제 사용자가 호출되고 응답에 따라 작업을 트리거하는 제너레이터 함수를 작성할 것입니다.\n\n```js\nimport { call, put } from \"redux-saga/effects\";\nimport { GET_USERS_SUCCESS, GET_USERS_FAILURE } from \"./actions\";\n// ... axios와 같은 다른 import\n// ... userFetch 함수와 같은 다른 코드\nfunction* getUsersFetch() {\n  try {\n    const users = yield call(userFetch);\n    //yield는 다음 줄로 넘어가기 전에 이 호출이 완료되기를 기다릴 것입니다.\n    yield put({ type: GET_USERS_SUCCESS, users });\n  } catch (error) {\n    yield put({ type: GET_USERS_FAILURE, error });\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 호출(fetch)을 하는 매우 직관적인 제너레이터 함수가 있습니다. 사용자 호출(fetch)로부터 응답이나 오류가 반환될 때까지 기다리도록 yield를 사용하였습니다. redux-saga/effects에서 call은 함수를 호출하는 데 사용되며 결과를 users 변수에 저장합니다. 다음으로, put은 미들웨어에 action을 스토어에 디스패치(dispatch)할 것을 예약하는 효과 설명을 생성합니다. 이 디스패치는 즉시 이루어지지 않을 수 있으며, Saga 작업 큐에서 다른 작업이나 진행 중인 작업이 있을 수 있습니다. 그래서 디스패치가 완료되면 결과를 성공 또는 실패로 전달할 것입니다.\n\n제 3부 — Redux 프레임워크에서는 액션이 중요한 역할을 합니다. 각각이 다른 목적을 가진 앱에서 실행되는 고유한 프로세스입니다. 따라서 채워야 할 액션이 하나 남았는데, 바로 GET_USERS_FETCH입니다. 이 액션을 디스패치할 때마다 getUsersFetch를 호출할 것입니다.\n\n```js\nimport { call, put, take } from \"redux-saga/effects\";\nimport { GET_USERS_FETCH } from \"./actions\";\n// ... axios, actions 등의 다른 import들\n// ... userFetch, getUsersFetch 함수 등의 다른 코드\nfunction* mySaga() {\n  while (true) {\n    yield take(GET_USERS_FETCH);\n    yield call(getUsersFetch);\n  }\n}\nexport default mySaga;\n```\n\n위의 코드에서 GET_USERS_FETCH 액션이 발생할 때마다, saga는 getUsersFetch 제너레이터 함수를 호출하여 API에 대한 호출을 수행하고 성공 또는 실패 시 액션을 트리거하는 동작을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`take`는 미들웨어에게 Store에서 특정 액션을 기다리라는 Effect 설명을 만듭니다. 즉, 버튼을 누를 때 이를 듣고 있을 것이며, 우리가 액션을 디스패치할 때 take(GET_USERS_FETCH)가 이 액션을 알거나 이를 듣고 있는 상태이며, 이 액션이 발생하면 getUsersFetch 제너레이터 함수를 호출합니다. 따라서 yield는 매우 중요한 개념으로, 이것은 일시중지/재개를 담당하는 문 앞의 가드와 같습니다. 즉, yield take(GET_USERS_FETCH)는 GET_USERS_FETCH 액션이 발생할 때까지 대기 상태에 있을 것입니다. 해당 액션이 발생하면 그 yield는 완료되고, 그런 다음 yield call이 작동하며 getUsersFetch로부터 응답이 올 때까지 더 이상 실행되지 않게 됩니다.\n\n이 제너레이터 함수의 이름은 mySaga이며 이것은 루트 또는 메인 리듀서에서 본 것과 같이 우리의 주요 사가가 될 것입니다. 우리는 모두를 사용하여 사가를 결합할 수 있지만, 이 특정 예제에서는 하나만 있을 것입니다.\n\n이게 sagas.js 파일에 있는 모든 내용입니다.\n\n다음으로 우리는 액션을 수행할 reducer.js 파일을 준비할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { GET_USERS_FAILURE, GET_USERS_SUCCESS } from \"./actions\";\nconst initialState = {};\nconst myReducer = (state = initialState, action) =\u003e {\nswitch (action.type) {\ncase GET_USERS_SUCCESS: return { ...state, payload: action.users };\ncase GET_USERS_FAILURE: return { ...state, payload: action.error };\ndefault: return state;\n};\nexport default myReducer;\n```\n\n이 리듀서는 성공 또는 실패 이벤트가 발생했을 때 호출됩니다. 이제 할 일이 두 가지만 남았어요. 하나는 API가 반환할 데이터를 표시할 수 있도록 App.js를 변경하는 것이고, 두 번째는 우리가 index.js에 // TODO:를 추가한 sage를 실행하는 것입니다. 먼저 sage를 실행한다는 것이 무엇을 의미하는지 살펴보겠습니다.\n\nsage를 백그라운드에서 계속 실행되는 서비스로 생각해보세요. 사용자가 취한 동작의 수를 넣으면 적절히 처리하여 성공 또는 실패를 반환합니다. 기다렸다가 현재 것을 해결한 다음 다음 동작을 수행합니다. 그러므로 루트 파일에서 실행할 필요가 있습니다. index.js를 열고 다음 한 줄의 코드(사실상 2줄)를 추가하세요:\n\n```js\nimport mySaga from \"./sagas\";\n// ... 모든 다른 import 및 코드 위에\nsagaMiddleware.run(mySaga);\n// ... 루트에 render(...와 같은 다른 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n런은 앱이 실행 중이라면 작업이 발행될 때마다 우리의 사가를 시작합니다. 그 다음으로, 정확히 그것을 할 거에요. App.js를 열고 버튼을 누르면 fetch 작업이 트리거되는 UI를 만들어볼 거에요.\n\n```js\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { takeGetUserFetchAction } from \"./actionCreators\";\n\nfunction App() {\n  const myDispatch = useDispatch();\n  const retrivedData = useSelector((state) =\u003e {\n    return state.myReducer;\n  });\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003ch1\u003eUsers\u003c/h1\u003e\n      \u003cbutton onClick={() =\u003e myDispatch(takeGetUserFetchAction())}\u003eCall API\u003c/button\u003e\n      \u003chr /\u003e\n      \u003cdiv\u003e\n        {retrivedData?.users \u0026\u0026 retrivedData.users.map((user) =\u003e \u003cdiv key={user.id}\u003e{user.name}\u003c/div\u003e)}\n        {retrivedData?.error \u0026\u0026 \u003cp\u003e{retrivedData.error.message}\u003c/p\u003e}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\nuseSelector에서 전체 상태를 반환할 수도 있었지만, 관심 있는 reducer만 선택했어요. 사용자 또는 오류가 발생할 것이므로 데이터를 그에 맞게 렌더링하고 있습니다. 지금 실행하고 버튼을 클릭하면 데이터가 표시될 거에요. 그러나 사가 파일의 URL을 https://jsonplaceholder.typicode.com/user로 변경하면 오류가 출력될 거에요.\n\n따라서 사가를 사용하여 간단한 API 요청을 만들었습니다. 여기 모든 주제에 대한 실행 예시를 보여주는 코드가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 위 예제를 더 간단하게 만드는 방법\n\n위 예제에서 우리는 목표를 달성했습니다. 그러나 여러분이 redux 훅들을 사용하여 매우 쉽게 작업할 수 있음을 알 수 있기 때문에 더 간단하게 만들 수 있습니다. createAction, createReducer 등의 많은 훅들이 있으며 우리가 살펴볼 것입니다.\n\n가능한 한 더 많은 부분을 순수 JS로 유지하여 뒷단을 이해할 수 있도록 기본적인 접근 방식을 취했습니다. 그래서 이제 우리가 할 일은 몇 가지 더 많은 훅과 효과를 사용하여 위 예제를 간소화하고 그것이 어떻게 간단해지는지 확인하는 것입니다.\n\n지금쯤에 혹시 saga가 어떻게 작동하는지 주목하지 못했다면, saga를 백그라운드에서 실행되는 서비스로 생각할 수 있습니다. 지속적으로 액션을 수신하며 해당 액션이 트리거되면 즉시 작동하여 액션을 수행하고 다른 쓰레드에서 다른 함수를 실행하고 다양한 작업을 완전 비동기적으로 수행 할 수 있는 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 해야 할 첫 번째 일은 actions.js 파일과 actionCreators.js 파일 두 개 대신에 actions.js 파일 하나만 필요할 것이라는 것이에요. 그리고 아래 코드를 추가할 거에요:\n\n```js\nimport { createAction } from \"@reduxjs/toolkit\";\nexport const GET_USERS_FETCH = createAction(\"GET_USERS_FETCH\");\nexport const GET_USERS_SUCCESS = createAction(\"GET_USERS_SUCCESS\");\nexport const GET_USERS_FAILURE = createAction(\"GET_USERS_FAILURE\");\n```\n\n이것은 각각에 대한 action과 action 생성자를 만들었기 때문에, 많은 시간을 절약할 수 있고 actions를 생성하고 사용하는 복잡성을 줄일 수 있어요. 또한, 디스패치(dispatch), 선택자(selector), 또는 리듀서(reducer)에 전달할 때 문자열(action) 또는 객체(action 생성자)가 어디로 갈지 걱정할 필요가 없어요. 이를 전달하면 createAction이 대신 책임지고 필요한 대로 사용되고 자동으로 반환할 거라는 거죠.\n\ncreateAction을 사용해 매개변수를 전달하고 다양한 작업을 할 수도 있고, 간단하게 action을 생성하는 법도 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 createReducer에 대해 살펴보겠습니다. 이름에서 알 수 있듯, 여러 귀찮은 일을 덜어주는 reducer를 만들어줄 겁니다. createReducer(INITIAL_STATE, 빌더 콜백 함수)라는 두 가지 매개변수를 사용합니다. (빌더 함수는 .을 사용하여 조인 가능한 체인 구조를 계속하여 만들 수 있는 함수입니다.)\n\n그래서 우리는 reducer.js 파일을 다시 작성할 거에요:\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_USERS_FAILURE, GET_USERS_SUCCESS } from \"./actions\";\nconst initialState = {};\nconst myReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_USERS_SUCCESS, (state, action) =\u003e {\n      state.users = action.users;\n    })\n    .addCase(GET_USERS_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myReducer;\n```\n\n위의 코드에서, switch 문에서 했던 것과 유사한 작업을 했지만 여기서는 빌더 함수 접근 방식을 사용했습니다. 우리는 .addCase를 원하는 만큼 사용할 수 있고, 그 후 .addDefaultCase(선택사항)를 사용하여 기본 문을 처리할 수 있어서 builder.addCase(...).addCase(...).addCase(...)….addDefaultCase(...)과 같은 체인 빌더를 생성할 수 있습니다. 모든 case는 상태와 액션을 가지며, 상태/초기 상태를 업데이트할 수 있도록 지정할 수 있습니다. 이것을 스위치 문 형식으로 생각한다면 매우 간단합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 \"createAction\"과 \"createReducer\"을 사용하면 코드의 복잡성을 줄일 수 있다는 것을 보았어요. 위의 변경 사항을 적용하려면 'App.js'에서 액션을 디스패치하는 부분에 작은 변경 한 가지를 해야 해요. 다음과 같이 바꿔 주세요:\n\n```js\n// ... 다른 import들\nimport { GET_USERS_FETCH } from \"./actions\";\n// ... 다른 코드\n\u003cbutton onClick={() =\u003e dispatch(GET_USERS_FETCH())}\u003eAPI 호출\u003c/button\u003e;\n```\n\nGET_USERS_FETCH는 createAction을 사용하여 생성되었기 때문에 액션 생성자가 자동으로 생성되어 있으므로 GET_USERS_FETCH()와 같이 호출할 수 있고, 이렇게 하면 액션이 트리거되어요. 사가에 변경 사항이 없었기 때문에 액션이 캐치될 것이며, 나머지 플로우도 그에 따라 작동할 거에요. 우리의 리듀서도 예상대로 작동할 거에요.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 예전 예제를 확장해서 일을 더 쉽게 만들기로 했으니, 사가를 사용하는 앱에서 널리 사용되는 또 다른 것을 다루는 것이 좋겠죠. 아래에는 이 세 가지에 대한 간단한 설명이 있고, 그 후에 우리가 만드는 앱에서 이들을 사용하는 방법을 살펴볼 거에요.\n\n- take\n  yield take(pattern)의 결과는 디스패치된 액션 객체입니다. 이는 미들웨어 (saga)에게 특정 액션이 저장소에서 취해질 때까지 기다리라고 알려줍니다. take는 한 번만 액션을 취하기 때문에 버튼을 클릭할 때마다 작업을 하려면 while(true) ... 안에 넣어야 합니다. 또는 use case에 따라 takeEvery나 takeLatest를 사용할 수도 있어요.\n- takeEvery\n  GET_USERS_FETCH 액션을 동시에 호출하도록 가능하게 합니다. 주어진 순간에 우리는 아직 종료되지 않은 하나 이상의 이전 GET_USERS_FETCH 작업이 있을 때, 새로운 GET_USERS_FETCH 작업을 시작할 수 있습니다. GET_USERS_FETCH 액션을 실행하면 이를 버튼에서 디스패치합니다. takeEvery는 동시 작업을 처리할 수 있게 해줍니다. 위의 예에서 GET_USERS_FETCH 액션이 디스패치되면, 이전 GET_USERS_FETCH가 아직 종료되지 않은 상태여도(예를 들어, 사용자가 빠르게 두 번 연속 'API 호출' 버튼을 클릭한다면, 두 번째 클릭에서는 fetchUser가 아직 종료되지 않았더라도 GET_USERS_FETCH 액션이 디스패치됩니다)\n- takeLatest\n  한 번에 하나의 GET_USERS_FETCH 작업만 활성화될 수 있습니다. 또한, 가장 최근에 시작된 작업이 될 것입니다. 이전 작업이 계속 진행 중일 때 새로운 GET_USERS_FETCH 작업이 시작된다면, 이전 작업은 즉시 중단됩니다. takeEvery와는 반대로, takeLatest는 동일하게 실행 중인 작업을 중지하고 새 작업을 시작합니다. 각 액션이 저장소에 디스패치될 때마다. 액션이 패턴과 일치하면 takeLatest가 백그라운드에서 새로운 saga 작업을 시작합니다. 이전에 시작된 saga 작업이 있었다면(실제 액션이 디스패치되기 전의 마지막 액션에서 시작된 경우), 그 작업이 계속 실행 중이었다면, 해당 작업은 취소될 것입니다.\n\ntake, takeEvery, takeLatest의 실제 예제를 보려면 이를 시도해 보세요:\n\n그러니 sagas.js 파일을 열어서 take와 call 라인을 다음과 같이 바꿔주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { call, put, takeEvery } from \"redux-saga/effects\";\nfunction* mySaga() {\n  yield takeEvery(GET_USERS_FETCH, getUsers);\n}\n```\n\n매우 간단한 방법으로, GET_USERS_FETCH가 실행될 때마다 getUsers 함수를 실행하라는 것을 나타내는 것이다. 이전과 똑같이 작동하는 것을 확인할 수 있을 것이다. 이제 takeEvery를 사용하는 이유와 takeLatest 또는 take를 사용하지 않는 이유는 사용 사례에 따라 달라진다.\n\n따라서 기본적으로 이전에 작성한 앱을 변환한 것입니다. 이번에는 간단하게 만드는 데 집중했습니다. createAction, createReducer, takeEvery 등의 사용법을 배웠습니다.\n\n지금까지 한 모든 변경 내용이 반영된 코드는 다음과 같습니다:\n\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 고급 개념을 간단하게\n\n여기서는 고급으로 간주되는 몇 가지 개념을 다룰 것입니다. 그러나 그 본질을 이해한다면 실은 간단한 경우도 있습니다. 이전 섹션에서 본 것처럼, 여기서도 상황은 비슷할 것입니다. 모든 것을 다 다룰 수는 없겠지만, 가능한 많은 개념을 사용하는 예시를 살펴볼 것입니다. fork, cancel, createSelector 등 몇 가지 주제를 다룰 예정입니다.\n\n플로우를 차단할 것인지 말 것인지, 그리고 기대만들 것인지 여부를 이해하는 것이 중요한 포인트가 될 것입니다. 이는 yield가 다음 코드 줄을 실행하기 전에 기다릴 것인지 여부가 우리가 사용하는 효과에 따라 다르다는 것을 의미합니다. 그래서, 간단하고 명확한 설명은 다음과 같습니다:\n\n## 차단/비차단 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 테이크(take), 콜(call), 푸트(put) 등 사가의 다양한 효과를 보았어요. 이를 두 가지 범주로 분류할 수 있어요:\n\n- 블로킹(Blocking)\n- 논블로킹(Non-Blocking)\n\n블로킹 호출은 사가가 효과를 생성하고, 해당 실행 결과를 기다린 다음에야 생성기 안에서 다음 명령을 재개할 것을 의미해요.\n\n논블로킹 호출은 사가가 효과를 생성한 후 즉시 재개될 것을 의미해요. 즉, 호출자는 작업을 시작하고 완료를 기다리지 않고 실행을 계속할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTLDR; Blocking은 흐름을 차단하고 non-blocking은 길을 막지 않습니다. 우리가 배운 대로, yield는 응답/에러가 제공되거나 현재 작업에서 해결/거부될 때까지 실행을 일시 중단하지만 어떤 사가 효과는 과정을 일시 중단시키지 않는 non-blocking이며 실행 중인 작업 기능을 백그라운드에서 실행하면서 코드가 다음 줄을 실행할 수 있게 합니다. 예시가 있습니다:\n\n다른 많은 것들이 있고 앱에서 모두 사용하지 않을 수 있지만 어떤 것이 차단 또는 비차단 호출인지 알아두는 것이 좋습니다. 다음은 효과 목록이며 차단/비차단 여부입니다:\n\n차단/비차단 설명에서 알 수 있듯이, 사가를 사용함으로써 우리는 시스템을 통해 논리가 어떻게 흐를지를 많이 제어하고 데이터 흐름과 각 효과가 다양한 사용 사례에서 유용한 기능을 갖습니다.\n\n# Fork \u0026 Cancel\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nfork()은 (일종의 takeEvery와 비슷하게) 병렬로 작업을 실행하는 데 사용되지만 흐름을 차단하지 않습니다. 비차단 작업을 시작해야 할 때 사가가 유용합니다.\n\nfork()을 프로세스를 가져와서 별도의 스레드에서 별도로 실행하는 것으로 생각할 수 있습니다. 작업을 완료하거나 거부할 때 해당 작업을 실행하던 함수가 알림을 받아서 컴파일러는 해당 함수를 종료합니다. 이 개념은 많은 개념과 비슷할 수 있지만, 핵심적인 차이점은 fork가 다음 코드 줄을 실행하는 것을 막지 않지만, 현재 있던 함수를 종료하지 않는다는 점입니다. 즉, 컴파일러는 fork가 모두 완료되거나 응답하면 해당 함수를 종료합니다. 이 개념을 실제로 이해하려면 아래 예제를 살펴보세요.\n\n## 예제\n\n앱에서 사용자가 다음 작업을 수행할 수 있는 화면에 있다고 가정해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자 목록을 가져오는 API를 호출합니다.\n- 게시물을 가져오는 API를 호출합니다.\n- 댓글을 가져오는 API를 호출합니다.\n- 앱을 종료하는 것은 이전 화면으로 돌아가는 것을 의미합니다.\n\n먼저 사가의 fork를 사용하여 게시물을 가져오는 API를 호출할 것입니다.\n\n모든 작업은 서로 의존하지 않습니다. 이들은 사용자가 언제든지 화면에서 수행할 수있는 네 개의 독립적인 예상 작업입니다.\n\nactions.js에 다음과 같은 작업이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const GET_POSTS_FETCH = createAction(\"GET_POSTS_FETCH\");\nexport const GET_POSTS_SUCCESS = createAction(\"GET_POSTS_SUCCESS\");\nexport const GENERAL_FAILURE = createAction(\"GENERAL_FAILURE\");\nexport const EXIT_APP = createAction(\"EXIT_APP\");\n```\n\n대부분의 생성된 액션은 어떤 작용을 하는지 명확하지만, EXIT_APP은 사용할 효과를 보여주기 위해 추가한 액션입니다. 사용자가 화면을 떠날 때 또는 뒤로 돌아갈 때를 생각해보면, 사가를 깨끗하게 정리하기 위해 exit 함수를 호출합니다. API를 호출하고 결과를 가져오고자 할 때는 Post fetch를 사용합니다. API 호출 시 오류가 발생한 경우 General failure을 사용하고, 데이터를 성공적으로 가져온 경우에는 success가 트리거됩니다.\n\n이제 sagas.js를 세 부분으로 나누어 만들어봅시다:\n\n```js\n// PART 1\nfunction getPosts() {\n  console.log(\"Now calling getPosts API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/posts\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드는 간단한 JS 함수를 호출하여 결과를 반환하는 것뿐입니다. 다음으로, 우리는 아래에 있는 사가를 추가할 것입니다.\n\n- getPosts API 호출하기\n- 응답이나 오류 가져 오기\n\n```js\nimport { call, put, take } from 'redux-saga/effects';\n// PART 2\nfunction* getPostsSaga() {\nwhile (true) {\ntry {\nconsole.log(\"getPosts action ready...\");\nyield take(GET_POSTS_FETCH);\nconsole.log(\"getPosts action started...\");\nconst posts = yield call(getPosts);\nconsole.log(\"getPosts action fetched...\");\nyield put({type: GET_POSTS_SUCCESS, posts: posts});\nconsole.log(\"getPosts action finished...\");\n} catch (error) {\nconsole.log(\"getPosts action failed...\");\nyield put({type: GENERAL_FAILURE, error: error});\nconsole.log(\"getPosts action error finished...\");\n}}\n```\n\n위 코드에 콘솔 로그를 추가하여 코드가 멈추는 지점과 대기하는 지점을 효율적으로 확인할 수 있도록 했습니다. 위 코드는 GET_POSTS_FETCH 액션을 받고 API를 호출하고 응답이나 오류를 받은 후에 작업을 수행하도록 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 우리는 방금 생성한 getPostsSaga를 호출할 메인 Saga가 필요합니다. 그러니 이렇게 만들어 봅시다:\n\n```js\nimport { call, put, take, fork, cancel } from \"redux-saga/effects\";\n// PART 3\nexport default function* mySaga() {\n  const posts = yield fork(getPostsSaga);\n  console.log(\"이제 사용자의 작업을 기다리고 있습니다...\");\n  yield take(EXIT_APP);\n  console.log(\"앱을 종료 중입니다...\");\n  yield cancel(posts);\n  console.log(\"종료가 완료되었습니다...\");\n}\n```\n\nfork가 블로킹되지 않는 호출이기 때문에 call(...)과 같은 기대값이나 take와 같은 기다림이 필요하지 않습니다. 위의 코드에서는 실제로 이야기를 전달하고 있는데, 즉시 Saga가 시작되면 getPostsSaga를 fork했음을 의미합니다. 즉, getPostsSaga 함수를 완료할 때까지 기다리지 않고 별도의 스레드에서 실행합니다.\n\ngetPostsSaga의 첫 줄이 take 이펙트인데, 이는 GET_POSTS_FETCH 액션을 '청취'하거나 '감시'하기 시작하게 됩니다. 이 액션이 실행될 때가지 즉시 take를 수행합니다. getPostsSaga에서 take와 같은 블로킹 호출이 없으면 전체 함수를 실행하게 되므로, 사용자가 이 작업을 취할 때마다 Saga는 별도의 스레드에서 이를 실행하기 위해 기다리게 됩니다(즉, 앱의 현재 흐름을 방해하지 않는 상태).```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 mySaga로 돌아가서 사용자의 동작을 기다리는 중일 것이에요... 지금 파일에서는 여기까지에요. 이제 yield take(EXIT_APP) 부분에 대해 곧 설명할게요. (console.log로 실행하면 훨씬 더 명확해질 거예요.)\n\n따라서 우리는 sagas.js에서 API에서 게시물을 가져오는 기능을 달성하기 위해 세 가지를 했어요.\n\n- 최신 게시물을 API에서 가져오기 위한 getPosts 함수를 생성함\n- 응답, 오류 및 API 호출을 처리하는 getPosts를 위한 generator 함수를 작성함\n- sagas에 대한 주 generator 함수를 생성해서 getPostsSaga를 분기함\n\n지금은 이게 sagas 파일에서 우리가 할 일 전부에요. 다음으로 reducers.js를 설정할 건데요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_POSTS_SUCCESS, GENERAL_FAILURE } from \"./actions\";\nconst initialState = {};\nconst myFirstReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_POSTS_SUCCESS, (state, action) =\u003e {\n      state.posts = action.posts;\n    })\n    .addCase(GENERAL_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myFirstReducer;\n```\n\n우리는 앱이 특정 동작을 취하기 위해 사용되지 않을 작업만 처리하려고 합니다. 사용자가 실제로 보고 싶어하는 데이터를 검색하지 않을 것이므로 그래서 이 두 작업만 추가되었습니다.\n\n마지막으로, 이 작업을 시험할 화면인 App.js에서 열어서 다음을 추가하세요:\n\n```js\n{\n  /* ...다른 코드... */\n}\n\u003cbutton onClick={() =\u003e myDispatch(GET_POSTS_FETCH())}\u003e 포스트 API \u003c/button\u003e;\n{\n  /* ...다른 코드... */\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n버튼을 누르면 우리는 지켜보고 있는 SAGA에서 작업을 수행하도록 GET_POST_FETCH 액션을 취하고 싶습니다. 따라서 이 작업을 수행하자마자 getPosts 함수가 정상적으로 실행될 것입니다. 먼저 실행한 후 결과를 확인하고 무슨 일이 일어나는지 살펴보겠습니다:\n\n![image](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_5.png)\n\n앱이 로드되자마자 fork 때문에 getPostsSaga로 이동되었음을 볼 수 있습니다. 이는 이미 준비되어 있다는 것을 알기 때문에 GET_POST_FETCH 액션이 발생할 때마다 getPostsSaga의 나머지 부분을 실행하도록 준비되어 있을 것입니다. 다시 돌아와서 앱이 메서드를 fork했고 사용자가 필요한 작업을 언제든지 수행할 수 있도록 기다리고 있다고 출력합니다. 지금까지 사용자가 수행할 수 있는 작업은 두 가지 뿐입니다:\n\n- API에서 게시물 가져오기\n- 앱 종료하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 '게시물 API' 버튼을 클릭해 봅시다:\n\n![게시물 API](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_6.png)\n\n행동을 취하자마자 API를 호출하기 시작할 것이며, 데이터를 가져오면 완료됩니다. 계속해서 while(true)를 사용하므로 다시 준비됩니다. '게시물 API' 버튼을 다시 누르면 API가 다시 호출됩니다:\n\n![게시물 API](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 \"exit\" 버튼을 누르면 어떻게 될까요? 우리가 \"이제 사용자의 조치를 기다리고 있습니다…\"를 출력했던 것을 기억하십니까? 바로 이후에는 yield take(EXIT_APP)를 수신하고 있음을 의미합니다. 총으로 보면, 포스트 API를 호출하는 블로킹 콜과 exit를 수신하고 있습니다. Saga는 두 가지를 동시에 수신하고 있는데, 이 둘 중 하나의 작업이 수행될 때마다 saga는 해당 지점에서 흐름을 계속합니다.\n\n그래서 지금 \"exit\" 버튼을 클릭하면 콘솔에 우리가 가진 console.log가 인쇄됩니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_8.png)\n\n\"exit\"가 호출되면 cancel(posts)가 실행되는데, 이는 saga에게 GET_POST_FETCH 액션을 듣는 것을 중단하라는 것입니다. 그래서 지금 \"포스트 API\" 버튼을 누르면 아무 일도 일어나지 않을 것입니다. 이것이 앱에서 흐름을 제어하는 방법이며, 필요한 것에만 집중할 수 있습니다. 해당 작업을 다시 열려면 사용자가 화면에 다시 입력하거나 재시작해야 합니다. 따라서 fork 사용을 신중하게 계획해야 하며, 이를 올바르게 활용하면 매우 유용하고 삶을 더 쉽게 만들어줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 현재 예제 확장하기 (블로그 앱)\n\ncreateSelector, fork 및 기타 개념들을 학습하기 위해 위 예제를 확장해보겠습니다. 두 개의 새 버튼, 즉 Comments API 및 UsersAPI를 추가하여 동일하게 API를 호출하고 결과를 검색할 것입니다. 포스트와 동일한 방법으로 수행됩니다.\n\n그러므로, 해당 액션들을 추가해 시작해봅시다:\n\n```js\nimport { createAction } from \"@reduxjs/toolkit\";\nexport const GET_POSTS_FETCH = createAction(\"GET_POSTS_FETCH\");\nexport const GET_COMMENTS_FETCH = createAction(\"GET_COMMENTS_FETCH\");\nexport const GET_USERS_FETCH = createAction(\"GET_USERS_FETCH\");\nexport const GET_POSTS_SUCCESS = createAction(\"GET_POSTS_SUCCESS\");\nexport const GET_COMMENTS_SUCCESS = createAction(\"GET_COMMENTS_SUCCESS\");\nexport const GET_USERS_SUCCESS = createAction(\"GET_USERS_SUCCESS\");\nexport const EXIT_APP = createAction(\"EXIT_APP\");\nexport const GENERAL_FAILURE = createAction(\"GENERAL_FAILURE\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 예제에 필요한 모든 작업이 준비되었습니다. 이제 우리의 리듀서를 업데이트하여 GET_USERS_SUCCESS, GET_POSTS_SUCCESS 두 가지 새로운 성공 경우를 처리해봅시다.\n\n```js\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { GET_USERS_SUCCESS, GET_POSTS_SUCCESS, GET_COMMENTS_SUCCESS, GENERAL_FAILURE } from \"./actions\";\nconst initialState = {};\nconst myReducer = createReducer(initialState, (builder) =\u003e {\n  builder\n    .addCase(GET_POSTS_SUCCESS, (state, action) =\u003e {\n      state.posts = action.posts;\n    })\n    .addCase(GET_COMMENTS_SUCCESS, (state, action) =\u003e {\n      state.comments = action.comments;\n    })\n    .addCase(GET_USERS_SUCCESS, (state, action) =\u003e {\n      state.users = action.users;\n    })\n    .addCase(GENERAL_FAILURE, (state, action) =\u003e {\n      state.error = action.error;\n    })\n    .addDefaultCase(() =\u003e {});\n});\nexport default myReducer;\n```\n\n그다음, 사용자가 코멘트나 사용자 데이터를 가져오고 싶을 때 어떻게 처리할지 정의해야 합니다. 따라서 우리는 sagas.js 파일에 API 호출 함수를 작성할 것입니다. 비즈니스 로직을 처리하는 곳입니다.\n\n```js\nfunction getComments() {\n  console.log(\"Now calling getComments API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/comments\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\nfunction getUsers() {\n  console.log(\"Now calling getUsers API\");\n  return axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngetPosts 함수처럼 우리는 두 개의 새로운 API 호출 함수를 추가했습니다. 이제 두 함수에 대한 사가를 추가해야 하는데, 이는 특정 액션이 발생할 때 대기하고 실행하고 결과를 반환하는 것을 의미합니다. getPostsSaga와 유사하게 getCommentsSaga와 getUsersSaga를 추가할 것입니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_9.png)\n\nconsole.log 함수를 제거하면 매우 간단합니다. take 때문에 이 액션을 청취하기 시작합니다. 해당 액션이 발생하자마자 사가가 API 함수를 호출하고 성공하면 성공 액션을 호출하여 데이터를 리듀서에 넣습니다. 리듀서는 이를 초기 상태나 초기화된 상태에 추가할 것입니다.\n\n새롭게 추가된 두 사가를 루트 수준에서 실행 중인 주 사가인 mySaga에 바인딩해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { call, cancel, fork, put, take, all } from \"redux-saga/effects\";\n//... other code\nexport default function* mySaga() {\n  const posts = yield fork(getPostsSaga);\n  const comments = yield fork(getCommentsSaga);\n  const users = yield fork(getUsersSaga);\n  console.log(\"이제 사용자의 조치를 기다리고 있습니다...\");\n  yield take(EXIT_APP); // 조치가 취해질 때까지 대기\n  console.log(\"앱을 종료합니다...\");\n  yield all([cancel(posts), cancel(comments), cancel(users)]);\n  console.log(\"종료가 완료되었습니다...\");\n}\n```\n\n우리는 fork를 사용하여 세 가지 모두에 대해 saga에게 듣도록 지시했습니다. fork는 비차단적이므로 세 가지 모두와 EXIT_APP까지 등록한 다음에 네 가지 조치 중 어느 것이든 취해질 때까지 기다립니다. fork는 기본적으로 getCommentsSaga 및 getUsersSaga 생성기 함수 내부로 들어가며 그 안에 차단 take가 있으므로 해당 saga가 GET_POSTS_FETCH, GET_COMMENTS_FETCH, GET_USERS_FETCH 및 EXIT_APP(종료 앱)를 대기하도록 등록한 방법입니다. 성공한 조치(GET_COMMENTS_SUCCESS 등)는 아직 등록되지 않았으며, 그런 경우 해당 동작이 취해지면 아무 일도 일어나지 않습니다. EXIT_APP이 취해질 때 댓글 및 사용자 리스너도 취소합니다.\n\n이제 버튼 클릭으로 fetch 동작을 호출해야 하므로 App.js 또는 index.js를 업데이트하세요:\n\n```js\n//... other imports\nimport {\nGET_POSTS_FETCH,\nGET_COMMENTS_FETCH,\nGET_USERS_FETCH,\nEXIT_APP\n} from \"./actions\";\n//... other UI\n\u003cbutton onClick={() =\u003e myDispatch(GET_POSTS_FETCH())}\u003e\n게시물 API\n\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(GET_COMMENTS_FETCH())}\u003e\n댓글 API\n\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(GET_USERS_FETCH())}\u003e사용자 API\u003c/button\u003e{\" \"}\n\u003cbutton onClick={() =\u003e myDispatch(EXIT_APP())}\u003e앱 종료\u003c/button\u003e\n\u003chr /\u003e\n//... other UI after rendering posts\n        {retrivedData?.comments \u0026\u0026\n{retrivedData?.comments \u0026\u0026\nretrivedData.comments.map((comment) =\u003e (\n\u003cdiv key={comment.id}\u003e\n   \u003cp style={ fontWeight: \"bold\" }\u003e{comment.name}\u003c/p\u003e\n   \u003cp style={ fontSize: 12, marginTop: -16, marginBottom: -10 }\u003e\n      {comment.email}\n   \u003c/p\u003e\n   \u003cp\u003e{comment.body}\u003c/p\u003e\n\u003c/div\u003e\n))}\n{retrivedData?.users \u0026\u0026\nretrivedData.users.map((user) =\u003e (\n\u003cdiv key={user.id}\u003e\n\u003cp style={ fontWeight: \"bold\" }\u003e\n   {user.name} ({user.company.name})\n\u003c/p\u003e\n\u003cp style={ fontSize: 12, marginTop: -16, marginBottom: -10 }\u003e\n   {user.email} | {user.phone}\n\u003c/p\u003e\n\u003cp\u003e\n   {user.address.suite} {user.address.street}, {user.address.city}, {user.address.zipcode}\n\u003c/p\u003e\n\u003c/div\u003e\n))}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드는 검색한 데이터를 출력할 것입니다. 이를 확인하는 가장 좋은 방법은 앱을 실행하는 것입니다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_10.png)\n\n한 번 실행하면, 우리 프로그램이 모든 세 가지 액션을 계속 지켜보고 있음을 볼 수 있고 사용자가 세 가지 액션 중 아무 것이라도 취할 수 있습니다. 먼저 Users API 액션을 취해 봅시다.\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 API에서 데이터를 가져와서 멋진 형식으로 렌더링되는 것을 볼 수 있습니다. 이제 다른 작업을 수행해 봅시다. 한 번의 포스트, 게시물 가져오기 또는 사용자들을 다시 가져올 수 있습니다. 계속해서 while(true) 문을 사용했기 때문에 다시 준비된 것을 볼 수 있습니다. 다음으로 댓글 API를 살펴보겠습니다:\n\n![이미지](/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_12.png)\n\n댓글이 가져와지고 맨 아래로 스크롤하면 사용자 데이터도 확인할 수 있습니다. UI에서는 댓글 후에 사용자 데이터가 렌더링됩니다.\n\n지금까지 우리는 이전 섹션에서 한 것과 똑같은 방식으로 두 개의 사가 함수를 더 만들었습니다. 그 코드는 아래에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 좀 더 많은 훅을 살펴보도록 합시다. 기본적으로 블로그 앱의 형태 예시를 시작할 준비가 되었습니다.\n\n## createSelector\n\n이제, createSelector라는 편리한 훅을 어떻게 사용할 수 있는지 살펴보겠습니다. 아래 패키지를 설치하여 사용해 보세요:\n\n```js\nyarn add reselect *OR* npm i reselect\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스 복습 섹션에서 살펴본 대로 셀렉터(selector)는 객체에서 값을 선택하는 데 사용됩니다. 셀렉터는 단순히 더 큰 데이터 컬렉션에서 데이터 하위 집합을 선택하는 데 사용되는 함수입니다.\n\n이 예시에서는 댓글, 사용자 및 포스트와 같은 데이터가 있고, 셀렉터를 사용하여 데이터를 슬라이스해서 사용자 id가 1인 사용자의 댓글을 선택하거나 id가 5인 사용자의 포스트를 선택할 수 있습니다. 기본적으로 데이터를 모두 페치한 블로그를 가정하고 이를 표시합니다. 이상적인 시나리오에서는 사용자를 위한 특정 포스트를 얻을 수 있는 API가 있을 것이며, 거기서부터 사용자의 상위 5개 포스트를 표시하는 셀렉터를 생성할 수 있습니다. 시나리오에 따라 셀렉터를 사용하고, 이 예시를 위해 모든 댓글, 사용자 및 포스트를 가져왔으므로 블로그 응용 프로그램에서 데이터를 필요에 맞게 구성할 수 있도록 필요한 만큼 많은 셀렉터를 만들어갈 것입니다.\n\n우리의 블로그 앱에서는 다음과 같이 진행합니다:\n\n- 앱을 시작할 때 모든 데이터를 가져오도록 3개의 fetch API 액션을 모두 트리거합니다. (실제 세계에서는 좋은 방법이 아니지만 이 튜토리얼을 위해서만 수행합니다.)\n- 그런 다음 사용자에게 포스트 목록만 표시합니다. 이 목록은 클릭할 수 있습니다.\n- 사용자는 어떤 포스트도 선택할 수 있습니다. 포스트를 선택하면 해당 사용자에 대한 댓글 및 사용자 정보를 가져오는 다른 액션을 트리거합니다. (여기서 createSelector를 사용할 것입니다)\n- 다시 모든 포스트로 돌아갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 블로그 게시물 목록 표시:\n\n첫 번째로 할 일은 필요한 모든 데이터를 가져오는 것입니다. \"Posts API\", \"Comments API\" 등의 버튼을 제거하겠습니다. 앱을 시작하면 이러한 작업이 트리거될 것이기 때문입니다. 그래서 App.js에 다음을 추가하세요:\n\n```js\nimport { useEffect } from \"react\";\n//... 기타 imports\nfunction App() {\n  const myDispatch = useDispatch();\n  useEffect(() =\u003e {\n    // 시작 시 모든 데이터 가져오기. 데이터를 슬라이스하고 표시하기 위해 selector를 사용할 것입니다.\n    myDispatch(GET_POSTS_FETCH());\n    myDispatch(GET_COMMENTS_FETCH());\n    myDispatch(GET_USERS_FETCH());\n  }, [myDispatch]);\n  //... 기타 코드\n}\n```\n\n위 코드에서 세 가지 액션을 디스패치하여 모든 데이터를 가져왔습니다. 리듀서와 사가는 그대로이며, 이전 예제에서 만든 selector로 확인한 데이터가 있다는 것을 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약간 정리를 해보려고 합니다. sagas.js 파일에서 getPosts, getComments, 그리고 getUsers 함수를 apis.js라는 새 파일로 이동하고 거기에 붙혀보세요. 기본적으로, 제너레이터 함수만을 사가 파일에 유지하는 것으로 합니다.\n\n```js\n// apis.js\nimport axios from \"axios\";\n\nexport async function getPosts() {\n  console.log(\"getPosts API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/posts\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      return err;\n    });\n}\n\nexport async function getComments() {\n  console.log(\"getComments API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/comments\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      return err;\n    });\n}\n\nexport async function getUsers() {\n  console.log(\"getUsers API를 호출 중입니다.\");\n  return await axios\n    .get(\"https://jsonplaceholder.typicode.com/users\")\n    .then((res) =\u003e {\n      return res.data;\n    })\n    .catch((err) =\u003e {\n      throw err;\n    });\n}\n```\n\n위의 apis.js 파일에는 세 가지 API 함수를 추가하고, sagas.js 파일에서 이들을 제거했습니다.\n\n이제 UI (App.js)를 수정해봅시다. 메인 return(...) 안의 모든 내용을 제거하고 다음 코드를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nreturn (\n\u003cdiv className=\"App\"\u003e\n   \u003ch3\u003e블로그 앱\u003c/h3\u003e\n   \u003cdiv\u003e\n     \u003cp\u003e\n      \u003cb\u003e더 많은 내용을 보려면 아래에서 블로그 글을 선택하세요:\u003c/b\u003e\n     \u003c/p\u003e\n     \u003chr /\u003e\n     {retrivedData?.posts \u0026\u0026 retrivedData.posts.map((post) =\u003e (\n           \u003ca href={`/#${post.id}`} onClick={() =\u003e {\n                 console.log(post);\n              } key={post.id}\u003e\n              {post.id}: {post.title}\n           \u003c/a\u003e\n           \u003cbr /\u003e\n     ))}\n   \u003c/div\u003e\n\u003c/div\u003e\n)\n```\n\n이 UI에는 링크 `a`만 있습니다. href는 링크처럼 느껴지게하는데 추가되었습니다. 앱을 실행하고 포스트를 선택하십시오. 콘솔에 출력되는 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_13.png\" /\u003e\n\n그래서, 우리의 로직이 작동합니다. 이러한 변경만으로 우리가 위에서 논의한 총 4가지 중 처음 두 가지를 완료했습니다.\n\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번호 3은 사용자가 이 게시물 중 하나를 선택할 때 해당 게시물, 댓글 및 작성자를 표시해야 하는 곳입니다. 이미 모든 데이터를 가지고 있기 때문에 우리가 해야 하는 것은 적절한 것을 필터링하고 표시하는 것 뿐입니다. 예를 들어, 사용자가 게시물 번호 31을 선택하면 31번 id를 가진 게시물에 대한 댓글과 해당 게시물을 작성한 사용자 이름을 가져와야 합니다. 그것이 바로 우리가 선택자를 생성할 곳입니다. 'Selectors'는 그 이름 그대로 데이터를 선택합니다. 그러니 새 파일을 만들어 selectors.js로 이름을 붙이고 첫 번째 선택자를 추가해 봅시다.\n\n```js\nexport const allPosts = (state) =\u003e state.myReducer.posts;\nconst allComments = (state) =\u003e state.myReducer.comments;\nconst allUsers = (state) =\u003e state.myReducer.users;\n```\n\n위 코드에서는 가져온 전역 상태에서 allPosts를 간단히 내보냈습니다. 그것이 목록에 모든 게시물을 표시하는 데 필요한 유일한 것이기 때문에 내보내야 하는 것입니다. 다른 두 allComments 및 allUsers는 단순히 모든 데이터를 가져오기 위해 존재하며 다음으로 필요한 선택자를 만들 것입니다.\n\ncreateSelector의 문서를 보면 3개의 매개변수를 받는다는 것을 알 수 있지만 아래에서보면 필요한 것은 첫 두 가지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_14.png\" /\u003e\n\n우리가 한 코드에는 입력 셀렉터로 사용할 수 있는 세 개의 데이터 객체가 있습니다. 입력 셀렉터란 선택하려는 데이터를 의미합니다. resultFunc는 원하는 방식으로 데이터를 잘라내고 반환할 수 있는 함수입니다. 여러 입력 셀렉터가 있을 수 있다는 점에 유의하세요 (곧 보게 될 것입니다). 이는 해당 데이터의 선택기를 만들어 데이터를 혼합하고 일치시킬 수 있다는 것을 의미합니다.\n\n우리의 목표는 사용자가 게시물을 선택할 때 선택한 게시물, 해당 댓글 및 저자 정보를 가져와야 한다는 것입니다. 이를 위해 사용자가 선택해야 하는데, 이는 사용자가 ACTION을 취해야 한다는 의미입니다.\n\n그래서 actions.js에 다음 액션을 추가해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n//... 다른 작업들\n// post를 매개변수로 받는 액션\nexport const SELECTED_POST = createAction(\"SELECTED_POST\", (post) =\u003e {\n  return {\n    payload: {\n      selectedPost: post,\n    },\n  };\n});\n```\n\n우리는 이번에 createAction을 사용하여 매개변수를 받는 액션을 처음 만들었습니다. 이것은 이 액션을 전달할 때 우리가 post 객체를 전달할 것을 의미합니다. 그리고 저는 payload: selectedPost: post; (원하는 대로 구조화할 수 있습니다).\n\n이 post 객체를 전역 상태에 저장해서 selector 및 다른 곳에서 액세스할 수 있도록 하려고 합니다. 따라서 reducers.js 파일로 이동하여 createReducer에 이 케이스를 추가해 보겠습니다.\n\n```js\n//... 다른 임포트들\nimport {\nGET_USERS_SUCCESS,\nGET_POSTS_SUCCESS,\nGET_COMMENTS_SUCCESS,\nGENERAL_FAILURE,\nSELECTED_POST\n} from \"./actions\";\n//... 다른 코드\n.addCase(SELECTED_POST, (state, action) =\u003e {\nstate.selectedPost = action.payload.selectedPost;\n})\n//... 다른 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 전역 상태에서 selectedPost로 저장하고 있어요. 이제 selectors로 돌아가볼게요. 선택된 게시물의 댓글을 선택하는 selector를 만들 준비가 되었어요. selectors.js 파일을 열어서 다음 코드를 추가해주세요:\n\n```js\nimport { createSelector } from \"reselect\";\n//...other code\nexport const selectedPost = (state) =\u003e state.myReducer.selectedPost;\nexport const getCommentsForPost = createSelector(allComments, selectedPost, (c, p) =\u003e {\n  if (c \u0026\u0026 p) {\n    const filteredComments = c.filter((comment) =\u003e {\n      return comment.postId === p.id;\n    });\n    return filteredComments;\n  }\n});\n```\n\n위 코드에서는 createSelector을 import하고, allPosts 등과 마찬가지로 전역 상태에서 selectedPost를 가져왔어요. 그리고 getCommentsForPost에서는 allComments와 selectedPost를 입력 selector로 제공했어요. (여러 입력 selector를 제공하는 방법이에요.) 그런 다음에 c와 p를 사용하여 모든 댓글(allComments)에서의 객체와 선택된 게시물 데이터 객체를 나타내는 필터링된 댓글을 반환하는 resultFunc 함수를 추가했어요.\n\n또 다른 selector가 필요한데, 그것은 선택된 게시물의 작성자로 표시할 사용자 이름을 가져오는 것이에요. 선택된 블로그 게시물의 작성자를 선택할 selector를 만들어봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const getAuthorForPost = createSelector(\nallUsers, selectedPost,\n(u, p) =\u003e {\nif (u \u0026\u0026 p) {\nconst author = u.find((user) =\u003e {\n   return p.userId === user.id;\n});\n   return author;\n});\n```\n\n이전과 마찬가지로 두 개의 입력 선택기를 추가했고 결과 함수를 사용하여 allUsers에서 p.userId와 일치하는 객체를 찾고 있습니다.\n\n이제 선택기를 설정했으니, 이를 어떻게 사용하는지 확인해보는 시간입니다. 이제 남은 일은 UI를 그려서 모든 이벤트 변경을 표시하는 것뿐입니다. 그러니 App.js를 열어서 다음 수정 사항을 적용하세요:\n\n```js\nimport { useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { GET_POSTS_FETCH, GET_COMMENTS_FETCH, GET_USERS_FETCH, SELECTED_POST, EXIT_APP } from \"./actions\";\nimport { allPosts, selectedPost, getCommentsForPost, getAuthorForPost } from \"./selectors\";\n//... other code function App() {...\nconst retrivedPosts = useSelector(allPosts);\nconst selPost = useSelector(selectedPost);\nconst selPostComments = useSelector(getCommentsForPost);\nconst selPostAuthor = useSelector(getAuthorForPost);\n// 이 useState는 게시물 선택에 따라 UI를 숨기거나 보여주기 위한 것입니다.\nconst [selectedPostModeOn, setSelectedPostModeOn] = useState(false);\nfunction postSelected(selectedPost) {\n  myDispatch(SELECTED_POST(selectedPost));\n}\n//... More code\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 UI에 대한 첫 번째 변경 사항에서, 필요한 모든 작업과 필요한 모든 셀렉터를 먼저 import 했습니다. 저희는 하나의 view만 있기 때문에 선택된 모드에 따라 UI 요소를 숨기거나 표시할 것입니다. 즉, 게시물이 선택되었을 때와 그렇지 않을 때를 나타내는 상태를 컨트롤하기 위해 useState를 추가했습니다. 선택된 게시물이 있을 때 호출되는 postSelected 함수가 있으며, 게시물이 선택되었을 때 선택된 게시물 객체와 함께 SELECTED_POST 액션을 dispatch하고 나머지는 이미 처리되었습니다.\n\n그 다음, App.js의 return(...)에서 두 개의 div가 있을 것입니다:\n\n- 첫 번째 div에는 이미 표시된 모든 게시물이 표시됩니다.\n- 두 번째 div에는 선택한 게시물, 해당 댓글 및 작성자의 이름이 표시됩니다.\n\n언제든지 위의 div 중 하나만 표시되며, 선택된 게시물 모드를 사용하여 컨트롤할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인 div 안에 있는 `div className=\"App\"` 안에 다음 코드를 추가해주세요:\n\n```js\n{selectedPostModeOn \u0026\u0026 (\n\u003cdiv\u003e\n{/* 뒤로 가기 버튼 */}\n\u003cbutton\nonClick={() =\u003e {\n   myDispatch(EXIT_APP());\n   setSelectedPostModeOn(false);\n}\u003e 뒤로 \u003c/button\u003e\n\u003cbr /\u003e \u003chr /\u003e\n{/* 글 */}\n\u003cdiv\u003e\n  \u003ccode\u003e글 ID: {selPost ? selPost.id : \"선택된 글 없음\"}\u003c/code\u003e\n  \u003ch1\u003e{selPost.title}\u003c/h1\u003e\n  \u003cp\u003e{selPost.body}\u003c/p\u003e\n  \u003cp\u003e\n    \u003ci\u003e작성자: {selPostAuthor.name}\u003c/i\u003e\n  \u003c/p\u003e\n\u003c/div\u003e \u003chr /\u003e\n{/* 댓글 */}\n\u003cp style={{ fontSize: 12, fontWeight: \"bold\" }}\u003e 댓글 ({selPostComments.length}):\u003c/p\u003e\n{selPostComments \u0026\u0026 selPostComments.map((comment) =\u003e (\n\u003cdiv key={comment.id} style={{\n     backgroundColor: \"#e8e8e8\",\n     padding: 8,\n     marginBottom: 8,\n     borderRadius: 8\n}}\u003e\n\u003cp style={{ fontSize: 12, color: \"#7d7d7d\" }}\u003e\n   {comment.name} \u003cbr /\u003e {comment.email}\n\u003c/p\u003e\n\u003cp style={{ fontSize: 12, fontWeight: \"bold\" }}\u003e\n   {comment.body}\n\u003c/p\u003e\n\u003c/div\u003e))}\n\u003c/div\u003e\n)}\n```\n\n위 컴포넌트는 글 내용과 저자의 이름 그리고 마지막으로 모든 댓글을 표시하는 div입니다.\n\n나머지 return 부분은 동일하지만 모든 글을 표시하는 div를 `selectedPostModeOn`으로 묶어주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{!selectedPostModeOn \u0026\u0026 (\n\u003cdiv\u003e\n\u003cp\u003e\n  \u003cb\u003e블로그 게시물을 선택하여 더 많은 내용을 읽어보세요:\u003c/b\u003e\n\u003c/p\u003e\n\u003chr /\u003e\n{retrivedPosts \u0026\u0026 retrivedPosts.map((post) =\u003e (\n\u003ca href={`/#${post.id}`} onClick={() =\u003e {\n   postSelected(post);\n   setSelectedPostModeOn(true);\n  }\n  key={post.id}\u003e\n{post.id}: {post.title}\n\u003cbr /\u003e\n\u003c/a\u003e))}\n\u003c/div\u003e\n)}\n```\n\n동일한 내용이지만 두 가지 미세한 변경 사항이 있습니다. 첫째, 더 이상 필요하지 않아 retrivedData를 제거하고 retrivedPosts를 사용하여 렌더링합니다.\n\n앱을 실행하면 이렇게 작동해야 합니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Ve1TEwbgQTZwb_e6JFcVTg.gif\" /\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블로그 앱의 완전한 작동 코드가 준비되어 있습니다:\n\n# 결론:\n\n이 튜토리얼에서 진행한 샘플 프로젝트와 마찬가지로, 프로젝트에 따라 redux-saga를 활용하여 더 이벤트 중심의 아키텍처로 프로젝트를 구성할 수 있습니다. 필요한 모든 작업과 사가가 처리할 모든 기능을 계획할 수 있습니다. 전역 상태에 데이터를 저장해야 할 경우에는 리듀서에서 처리해야 하며, createReducer, createSelector와 같은 내장 훅, 그리고 saga의 call, put, take, fork 등의 효과를 사용함으로써 redux-saga를 간소화하는 방법을 살펴보았습니다. useSelector 대신 sagas에서 사용하는 select(SELECTOR_NAME)와 같은 방법도 있습니다. 이 예시에서는 사용하지 않았지만, race, spawn 등 많은 다른 효과들도 있습니다. 이제 이러한 훅 중 어떤 것을 사용하여 사가를 더 효율적으로 만들 수 있는지 알아보고 탐험해보세요.\n\n언제나 새롭게 배운 지식을 테스트해볼 만한 것들에 대해 안내해 드리겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 블로그 앱을 확장해 보세요 (해당 코드 샌드박스에 가서 포크하세요) 그리고 작성자: ...를 클릭하면 사용자 프로필 (모든 사용자 데이터)과 해당 사용자가 작성한 게시물이 표시되도록 확장하세요. UI를 사용자의 소셜 미디어 프로필처럼 보이도록 만들어보세요.\n- 이 글은 읽어보세요. https://redux-saga.js.org/docs/advanced/RacingEffects/ 그리고 기사에 제시된 일부 효과를 사용하여 블로그를 확장할 수 있는지 확인해보세요.\n\n이게 도움이 되었다면 공유하고 👏🏻 버튼을 눌러서 다른 사람들도 찾을 수 있게 도와주세요. 오타를 발견하거나 잘못된 점이 있다면 강조하여 알려주시고, 크레딧과 함께 업데이트하겠습니다. 난감하거나 도움이 필요하다면 댓글 남겨주세요. 최선을 다해 도와드리겠습니다.\n\n\u003cimg src=\"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_15.png\" /\u003e\n\n내 모든 자습서는 무료입니다. 지원하고 싶다면 buymeacoffee.com/chaudhrytalha에서 커피를 사줄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 코딩 👨🏻‍💻\n\n![Image](https://miro.medium.com/v2/resize:fit:292/1*V30UUCfEIck3Fjt3EJdfLg.gif)\n","ogImage":{"url":"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png"},"coverImage":"/assets/img/2024-05-01-GettingStartedwithReduxSagaTutorial_0.png","tag":["Tech"],"readingTime":43},{"title":"리액트에서 API를 이용하여 PDF 다운로드하기 (Axios, blobs)","description":"","date":"2024-05-01 17:30","slug":"2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png\" /\u003e\n\n리액트를 시작한 초보자이든 전문가이든 새로운 기능을 추가하려는 경우, 이 문서는 \"Axios를 사용하여 ReactJS에서 API에서 PDF를 다운로드 하는 방법\"을 배우는 데 도움이 될 것입니다. 5 단계로 진행하여 진행하도록 하겠습니다!\n\n추신 : 전체 코드를 보려면 끝 부분으로 건너뛸 수 있습니다. 도움이 되었다면 박수를 눌러주세요 💙\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대 웹 애플리케이션에서는 API에서 PDF를 다운로드해야 하는 경우가 많습니다. 사실, 이것은 많은 일상 애플리케이션의 핵심 기능입니다.\n\nUber를 통해 최근 여행의 청구서를 다운로드하거나 온라인 이력서 템플릿, 이메일에서 노트를 받는 것과 같이 가능합니다.\n\nPayPal은 청구서를 다운로드할 수 있게 해주고, Dropbox은 클라우드 저장소에서 파일을 다운로드할 수 있게 해줍니다. 대학 노트에 대해 이미 알고 계시죠!\n\n![PDF 다운로드하기](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReactJS는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리로써 이 프로세스를 용이하게 할 수 있는 다양한 도구와 라이브러리를 제공합니다. HTTP 요청을 보다 간단히 만들어주는 \"axios\" 라이브러리를 사용하는 것이 일반적입니다.\n\n파일 다운로드에 관한 ReactJS의 강력한 기능 중 하나는 blobs(Binary Large Objects)입니다. Blobs를 사용하면 파일과 같은 이진 데이터를 더 효율적으로 처리할 수 있습니다. Blobs를 활용함으로써 API에서 파일을 쉽게 다운로드하고 원활한 사용자 경험을 제공할 수 있습니다.\n\n이 글에서는 axios와 blobs를 사용하여 ReactJS에서 API로부터 파일을 다운로드하는 단계별 방법을 살펴보겠습니다. 다룰 내용은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 설정,\n- API 요청 만들기,\n- 응답 처리,\n- 파일 다운로드 트리거 및\n- 다운로드 후 정리\n\n이 자습서를 마치면 ReactJS 애플리케이션에서 파일 다운로드 기능을 구현하는 방법에 대해 확실하게 이해하게 될 것입니다. 사용자에게 원활하고 효율적인 파일 다운로드 경험을 제공할 수 있도록 도와줄 것입니다.\n\n# 필요한 설정\n\n프로젝트를 설정하는 것은 axios와 blobs를 사용하여 ReactJS에서 API에서 파일을 다운로드하는 첫 번째 단계입니다. 시작하려면 아래를 따라해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새로운 ReactJS 프로젝트를 만들거나 기존 프로젝트 디렉토리로 이동하세요.\n- 터미널을 열고 다음 명령을 실행하여 axios를 설치하세요:\n\n```js\nnpm install axios\n```\n\n3. axios가 설치되면 React 컴포넌트 파일에서 다음과 같이 import할 수 있습니다:\n\n```js\nimport axios from 'axios';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 다음으로 프로젝트를 위한 기본 파일 구조를 만들어 보겠습니다. 여러분의 요구에 맞게 파일을 조직화할 수 있지만, 간단한 예제를 확인해보세요:\n\n```js\n   src/\n   ├── components/\n   │   └── PDFDownloader.js\n   └── App.js\n```\n\n이 예에서는 PDF 다운로드 기능을 처리할 FileDownloader 컴포넌트가 있습니다.\n\n5. FileDownloader.js 파일을 열고 컴포넌트를 만들어봅시다. 함수형 컴포넌트를 사용한 예제가 여기 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_4.png\" /\u003e\n\n원하는 대로 컴포넌트를 사용자 정의해보세요.\n\n이러한 단계를 통해 ReactJS 프로젝트의 기본 구조를 설정하고 axios 라이브러리를 가져왔습니다. 이제 axios와 블롭을 사용하여 API 요청을 보내고 파일을 다운로드할 준비가 되었습니다.\n\n# API 요청 보내기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 요청을 하려면 axios.get() 메서드를 사용할 수 있어요. 파일을 blob 객체로 받기 위해 responseType 옵션을 ‘blob’으로 설정해주세요. 예시를 보여드릴게요:\n\n![Download PDF](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_5.png)\n\n위의 코드 스니펫에서는 downloadPDF라는 비동기 함수를 만들어 GET 요청을 ‘https://ExampleAPI.com/getFile`로 보내고 responseType을 ‘blob’로 지정해요. 응답은 then 블록에서 접근할 수 있고, 파일 데이터를 적절히 처리할 수 있어요. 오류가 발생하면 catch 블록에서 잡을 수 있어요.\n\n이제 파일 데이터가 준비되었으니 API 응답을 처리하고 파일을 다운로드할 준비를 마치면 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# API 응답 처리\n\nReactJS에서 파일 다운로드를 위한 API 응답을 처리할 때, 파일 데이터에 액세스하고 해당 데이터로 blob URL을 생성해야 합니다. 다음은 이를 수행하는 방법입니다:\n\n- 먼저 axios를 사용하여 API 요청을 만들 때 responseType을 'blob'으로 설정한 후, \"response.data\"를 사용하여 응답의 파일 데이터에 액세스할 수 있습니다. 이를 통해 파일을 나타내는 blob 객체를 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다음으로, URL.createObjectURL() 메서드를 사용하여 파일 데이터에서 blob URL을 생성할 수 있습니다. 이 URL은 React 구성 요소에서 다운로드 링크나 버튼을 생성하는 데 사용할 수 있습니다.\n\n![image](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_7.png)\n\n- 이러한 단계를 따르면 API 응답을 효과적으로 처리하고 ReactJS에서 파일 데이터에 액세스할 수 있습니다. 따라서 우리의 함수는 이제 다음과 같습니다:\n\n![image](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파일 다운로드 트리거\n\n- 파일을 다운로드하기 위해 버튼을 만들겠습니다. 사용자가 클릭하면 pdf가 사용자의 시스템으로 다운로드됩니다. 다음과 같이 할 수 있습니다:\n\n```js\n\u003cbutton onClick={downloadPDF}\u003eDownload PDF\u003c/button\u003e\n```\n\n- 이제 임시 URL을 만들고 다운로드를 트리거할 `a` 태그를 만들어봅시다. 여기서 파일에 동적 이름이나 제네릭 파일 이름을 줄 수도 있습니다. 그런 다음 `a` 태그를 버튼에 추가하고 클릭을 활성화해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![그림 1](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_9.png)\n\n- 메모리가 해제되도록 링크와 URL을 제거하세요. 그렇지 않으면 더 많은 파일을 추가할수록 웹사이트가 느려질 수 있습니다.\n\n![그림 2](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_10.png)\n\n# 보너스: 전체 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기사를 건너뛰지 않고 여기로 바로 넘어오지는 않았겠죠? 그렇다면 왜 이렇게 했는지 이해할 수 없으실 거에요 😂\n\n만약 건너뛰셨다면 괜찮아요, 중요한 건 이해하시는 거니까요. 그럼, 여기 있어요:\n\n![이미지](/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_11.png)\n\n```js\nimport react from 'react';\nimport axios from 'axios';\n\nconst FileDownloader = () =\u003e {\n\n  const downloadPdf = async () =\u003e {\n      try {\n        const response = await axios.get(\n          \"https://ExampleAPI.com/getFile\",\n          {\n            responseType: \"blob\", \n          }\n        );\n\n        const pdfBlob = new Blob([response.data], { type: \"application/pdf\" });\n\n        const url = window.URL.createObjectURL(pdfBlob);\n\n        const tempLink = document.createElement(\"a\");\n        tempLink.href = url;\n        tempLink.setAttribute(\n          \"download\",\n          `bill_${User_Id}_${date}.pdf`\n        );\n\n        document.body.appendChild(tempLink);\n        tempLink.click();\n\n        document.body.removeChild(tempLink);\n        window.URL.revokeObjectURL(url);\n      } catch (error) {\n        console.error(\"Error downloading PDF:\", error);\n      }\n    };\n\n  return (\n      \u003cbutton onClick={downloadPDF}\u003ePDF 다운로드\u003c/button\u003e\n  );\n}\n\nexport default FileDownloader;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 컴포넌트를 원하는 곳에 렌더링할 수 있습니다. 앞서 언급한 파일 구조에 따라 App.js에서 렌더링하면 잘 작동할 것입니다!\n\n# 결론\n\n본 문서에서는 ReactJS에서 axios와 블롭을 사용하여 API에서 PDF를 다운로드하는 방법에 대한 포괄적인 안내를 제공했습니다.\n\n프로젝트 설정, API 요청 만들기, 응답 처리, 파일 다운로드 트리거, 그리고 다운로드 후 정리하는 단계별 프로세스를 다루었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 제공된 코드 조각과 설명을 따라하면 ReactJS 애플리케이션에서 파일 다운로드 기능을 구현하는 방법에 대해 확실한 이해를 얻을 수 있을 것입니다. axios와 blobs의 조합을 사용하면 사용자에게 원활하고 효율적인 파일 다운로드 경험을 제공할 수 있습니다.\n\n더 탐구하고 파일 다운로드 프로세스를 향상시키기 위한 다양한 방법을 실험해 보기를 권장합니다. 오류 처리 구현, 최선의 방법 적용, 스트리밍 또는 청크 다운로드를 탐색하여 응용 프로그램의 성능을 최적화하는 등을 고려해 보세요.\n\n질문이 있거나 다른 기능에 대한 안내를 요청하고 싶으시면 아래에 댓글을 남겨주세요. 여러분의 피드백은 귀중하며, 여러분의 요구를 충족하는 콘텐츠를 제공하기 위해 항상 열려 있습니다.\n\n읽어 주셔서 감사합니다. 즐거운 코딩되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환호 🥂\n\n# 쉽게 이해하는 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 저자를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png"},"coverImage":"/assets/img/2024-05-01-DownloadPDFfromAPIinReactUsingAxiosandblobs_0.png","tag":["Tech"],"readingTime":7},{"title":"Laravel Breeze API 스캐폴딩을 리액트 애플리케이션과 통합하기","description":"","date":"2024-05-01 17:28","slug":"2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png\" /\u003e\n\n## 소개\n\n웹 개발의 끊임없이 발전하는 환경에서, 견고한 인증 메커니즘은 안전하고 확장 가능한 애플리케이션을 구축하는 데 중요합니다. Laravel Breeze는 웹 및 API용 강력한 인증 프레임워크 솔루션으로, 이 영역에서 등대 같은 역할을 합니다. 강력한 Laravel Sanctum 인증 시스템을 활용하여, Breeze는 기본적으로 매끄럽고 안전한 경험을 제공합니다.\n\n본 문서에서는 Laravel Breeze API 프레임워크를 React 애플리케이션과 통합하는 복잡성에 대해 살펴보고, 두 강력한 프레임워크의 장점을 결합하는 방법을 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 라라벨 백엔드 설정\n\n저희의 여정은 라라벨 백엔드를 설정하는 것으로 시작됩니다. 새로운 라라벨 애플리케이션을 생성하고 다음 명령어를 사용하여 Breeze API 스캐폴딩을 설치합니다:\n\n```js\n# 라라벨 애플리케이션 생성\ncomposer create-project laravel/laravel react-backend\ncd react-backend\n\n# Breeze 설치\ncomposer require laravel/breeze\nphp artisan breeze:install api\n```\n\n이 명령어를 통해 백엔드를 위한 기반을 설정하고 필수적인 인증 스캐폴딩을 통합합니다. 설치 후에는 환경 파일의 FRONTEND_URL을 localhost:3000으로 업데이트하는 것이 필요합니다. 라라벨 세일이나 php artisan serve 명령어를 사용하여 애플리케이션을 실행할 수 있습니다. 브라우저에서 localhost:8000을 방문하여 간단한 테스트를 수행하면 응답의 일부로 앱 버전이 표시될 것이며, 이는 라라벨 백엔드가 리액트 앱의 요청을 처리할 준비가 되었음을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## React 앱 설정\n\n프론트 엔드로 전환하며, React 애플리케이션을 설정하기 위해 Create React App을 선택합니다. 아래 명령을 실행하여 React 앱을 초기화하세요.\n\n```js\nnpx create-react-app breeze-react\ncd breeze-react\nyarn start\n```\n\n이를 통해 React 애플리케이션을 위한 기초를 설정하고, 더 많은 개발을 위한 견고한 기반을 마련합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Axios 구성하기\n\nReact 애플리케이션에서 API 요청을 처리하기 위해 Axios를 활용합니다. 전역 Axios 클라이언트를 아래와 같이 추가해보세요:\n\n```js\nimport Axios from 'axios'\n\nconst axios = Axios.create({\n  baseURL: process.env.REACT_APP_BACKEND_URL,\n  headers: {\n    'X-Requested-With': 'XMLHttpRequest'\n  },\n  withCredentials: true\n})\n\nexport default axios\n```\n\n`withCredentials`를 `true`로 설정하여 교차 사이트 쿠키 액세스를 활성화할 수 있습니다. `.env` 파일에 `REACT_APP_BACKEND_URL=localhost:8000`을 추가하고, 이는 이전에 생성한 Laravel 백엔드 애플리케이션에 해당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nREACT_APP_BACKEND_URL=http://localhost:8000\n```\n\n우리의 React 앱과 라라벨 백엔드 사이의 통신 링크를 설정합니다.\n\n## CSRF 요청\n\n라라벨 Breeze가 인증에 Sanctum을 활용하기 때문에 React 앱은 먼저 /sanctum/csrf-cookie 엔드포인트로 초기 요청을 보내야 합니다. 이는 인증에 중요하며, 로그인, 등록 및 비밀번호 잊어버리기와 같은 모든 비인증된 경로에서 수행되어야 합니다. 이 프로세스를 간소화하기 위해 hooks/auth.js 파일에 사용자 정의 후크를 만들어 CSRF 요청을 처리합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// auth.js\nimport axios from ‘axios’;\n\nexport const useAuth = () =\u003e {\n const getCsrfToken = async () =\u003e {\n await axios.get(`${process.env.REACT_APP_BACKEND_URL}/sanctum/csrf-cookie`);\n }\n\n// 기타 인증 관련 함수들\n\nreturn {\n getCsrfToken,\n // 기타 인증 관련 함수들\n };\n};\n```\n\n## 로그인 API 통합\n\nCSRF 처리를 위한 기본 작업이 완료되었으므로 이제 로그인 API를 통합해보겠습니다. 이에는 useAuth 훅에 함수를 추가하는 작업이 필요합니다:\n\n```js\n// auth.js\nimport axios from ‘axios’;\n\nexport const useAuth = () =\u003e {\n\n // 이전 코드\nconst login = async (credentials) =\u003e {\n await getCsrfToken();\n await axios.post(`${process.env.REACT_APP_BACKEND_URL}/login`, credentials);\n // 로그인 성공 또는 실패 처리\n };\n\n// 기타 인증 관련 함수들\n\nreturn {\n getCsrfToken,\n login,\n // 기타 인증 관련 함수들\n };\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 로그인 API 호출을 시작하기 전 CSRF 토큰을 요청하는 프로세스를 캡슐화하여 안전하고 인증된 로그인 경험을 보장합니다.\n\n## Laravel Breeze React\n\nLaravel Breeze를 위해 맞춤화된 사전 구성된 React 애플리케이션 템플릿을 찾는 개발자들에게 Laravel Breeze React가 이상적인 솔루션으로 떠오릅니다. GitHub에서 제공되는 이 템플릿은 Laravel Breeze의 장점을 Vite의 효율성과 결합한 것입니다. 이 기능들과 스스로 쉽게 시작할 수 있는 빠른 시작 가이드를 살펴보겠습니다.\n\n## 기능들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 미리 구축된 UI 구성 요소: 라라벨 Breeze React는 Tailwind CSS를 사용하여 스타일이 적용된 로그인, 등록, 비밀번호 재설정, 대시보드 등의 미리 구축된 UI 구성 요소를 갖추고 있습니다. 이를 통해 공통 인증 관련 페이지에 대한 기반을 제공하여 개발을 가속화합니다.\n\n2. Vite 4로 구축: Vite 4의 최신 기능과 성능 향상을 활용하여, 라라벨 Breeze React는 더 빠르고 효율적인 개발 경험을 보장합니다.\n\n3. React Router 6: 이 템플릿은 효율적이고 동적인 클라이언트 사이드 라우팅을 위해 React Router 6을 채택하여 부드럽고 원활한 탐색 경험을 제공합니다.\n\n4. 데이터 재확인을 위한 SWR: 사용자 데이터의 재확인을 용이하게 하기 위해 SWR (Stale-While-Revalidate)이 통합되어 있어, 애플리케이션이 서버 상태와 동기화되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. ESLint: 코드 품질을 유지하고 최고의 실천 방법을 준수하기 위해, Laravel Breeze React는 정적 코드 분석을 위해 ESLint를 통합하고 있습니다.\n\n## 빠른 시작 가이드\n\n1. 저장소 복제: GitHub에서 Laravel Breeze React 저장소를 복제하여 시작해보세요.\n\n```js\ngit clone https://github.com/nilanth/laravel-breeze-react\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 의존성 설치: 복제된 디렉토리로 이동하여 Yarn을 사용하여 프로젝트 의존성을 설치하세요.\n\n```js\ncd laravel-breeze-react\nyarn install\n```\n\n3. 환경 설정: .env.example 파일을 .env로 복사하고 Laravel 백엔드의 URL을 지정하세요.\n\n```js\nVITE_APP_BACKEND_URL=http://localhost:8000\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 애플리케이션 실행: 개발 서버를 시작하려면 `yarn start` 명령을 실행하세요.\n\n```js\nyarn start\n```\n\n위 단계를 따라하면, 깨끗하고 기능적인 사용자 인터페이스를 갖춘 Laravel Breeze React 템플릿이 작동하는 것을 확인할 수 있을 거에요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, Laravel Breeze API 뼈대와 React 애플리케이션의 원활한 통합은 개발자들이 견고하고 안전하며 확장 가능한 웹 애플리케이션을 만들 수 있도록 돕습니다. 제시된 단계를 따라가면, 개발자들은 Laravel Breeze와 React의 강점을 결합한 안전한 인증 레이어를 구축할 수 있습니다. 수동 통합을 선택하든지, Laravel Breeze React와 같은 템플릿을 활용하든지, 결과물은 백엔드 인증 메커니즘과 프론트엔드 사용자 경험이 조화롭게 어우러진 것입니다. 이 통합은 개발을 효율적으로 만들 뿐만 아니라 현대적인 웹 애플리케이션을 구축하기 위한 견고한 기반을 보장합니다.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 박수를 치고 작성자를 팔로우해 주세요 👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png"},"coverImage":"/assets/img/2024-05-01-SeamlessIntegrationofLaravelBreezeAPIScaffoldingwithReactApplications_0.png","tag":["Tech"],"readingTime":6}],"page":"94","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":14,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"94"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>