<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/54" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/54" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트의 비밀 병기를 발휘하라 StrictMode" href="/post/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트의 비밀 병기를 발휘하라 StrictMode</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴포넌트 라이프사이클 메서드" href="/post/2024-05-14-ReactComponentLifecycleMethods"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴포넌트 라이프사이클 메서드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="갇혀 있는 극악무도한 보안의 심연으로부터" href="/post/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">갇혀 있는 극악무도한 보안의 심연으로부터</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Js 설치 방법 완전 초보자용" href="/post/2024-05-14-HowToInstallReactJsForcompletebeginners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Js 설치 방법 완전 초보자용</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 언제 useRef 대신에 useState를 사용해야 할까요" href="/post/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 언제 useRef 대신에 useState를 사용해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 언제 useRef 대신에 useState를 사용해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 언제 useRef 대신에 useState를 사용해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컨텍스트를 올바르게 활용하기" href="/post/2024-05-14-UsingReactcontextstherightway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컨텍스트를 올바르게 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컨텍스트를 올바르게 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컨텍스트를 올바르게 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" href="/post/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="한국어 Axios 인터셉터란 무엇인가요" href="/post/2024-05-14-ENWhatareAxiosInterceptors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="한국어 Axios 인터셉터란 무엇인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="한국어 Axios 인터셉터란 무엇인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">한국어 Axios 인터셉터란 무엇인가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="BEM에 익숙해지기" href="/post/2024-05-14-GettingComfortablewithBEM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="BEM에 익숙해지기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingComfortablewithBEM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="BEM에 익숙해지기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">BEM에 익숙해지기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GraphQL 및 MongoDB와 React" href="/post/2024-05-14-GraphQLandMongoDBwithReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GraphQL 및 MongoDB와 React" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GraphQL 및 MongoDB와 React" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GraphQL 및 MongoDB와 React</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link posts_-active__YVJEi" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트의 비밀 병기를 발휘하라 StrictMode","description":"","date":"2024-05-14 12:17","slug":"2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode","content":"\n\n![StrictMode image](/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png)\n\nStrictMode는 당신이 그녀/그를 듣고 싶지 않더라도 진실을 말해주는 진짜 친구입니다. React 개발자들이 더 나은 방식으로 앱을 작성할 수 있도록 도와주는 도구로, 앱을 개발하는 과정에서 가능한 버그를 알려줍니다. 이는 개인용 들여쓰기 보조견과 같아요!\n\n# StrictMode에 관심을 가져야 하는 이유\n\nReact 개발자에게 StrictMode가 중요한 이유는 여러 가지가 있습니다:\n\n\n\n- 위험한 코드 식별: StrictMode를 사용하면 Android 문자열 ref API 사용이나 원치 않는 부작용과 같은 실행중 오류로 나타날 수 있는 문제를 잡을 수 있습니다.\n- 미래를 준비: StrictMode는 컴포넌트가 최신 React 버전 (그리고 동시 렌더링 같은 특징을 포함하는)과 완벽하게 작동하는 것을 보장합니다.\n- 성능 향상: StrictMode가 비효율적인 코드에 주목할 때, 응용 프로그램의 성능을 향상시키는 방법을 도와줍니다.\n\n# StrictMode의 주요 기능\n\nStrictMode는 더 깨끗하고 효율적인 React 코드를 작성하는 데 도움이 되는 여러 가지 확인 사항을 제공합니다:\n\n- 안전하지 않은 라이프사이클 식별: StrictMode는 componentWillMount, componentWillReceiveProps, componentWillUpdate 같은 고전 라이프사이클 방법을 사용하는 경우 동시 렌더링에서 불규칙성을 가져올 수 있는 경고를 표시합니다.\n- 레거시 문자열 ref API 사용에 대한 경고: 문자열 ref는 사용이 불필요하며 컴포넌트가 내부로 누출될 수 있습니다. StrictMode는 여전히 사용 중인 경우에 경고를 표시하여 콜백 기반 ref API로 전환하도록 장려합니다.\n- 예상치 못한 부작용 감지: StrictMode는 부작용을 나타내는 함수를 공개하고, 이는 불안정성, 성능 문제 및 더 어려운 추론을 초래할 수 있습니다.\n- 컨텍스트 API 호환성 보장: StrictMode는 응용 프로그램이 동시 렌더링을 허용하는 방식으로 컨텍스트 API를 사용하는지를 검증합니다.\n\n\n\n# 애플리케이션에 StrictMode 사용하기\n\nReact 애플리케이션에 StrictMode를 추가하는 것은 매우 쉽습니다. 확인하려는 컴포넌트를 `StrictMode` 컴포넌트로 감싸기만 하면 됩니다:\n\n```js\nimport React from 'react';\n\nfunction MyComponent() {\n  // ... 여러분의 컴포넌트 코드 ...\n}\n\nfunction App() {\n  return (\n    \u003cStrictMode\u003e\n      \u003cMyComponent /\u003e\n    \u003c/StrictMode\u003e\n  );\n}\n```\n\nStrictMode는 개발 도구일 뿐입니다. 프로덕션 빌드에 영향을 미치지 않습니다. 프로세스 초기에 문제가 있는 부분을 미리 발견하고 사용자에게 영향을 주지 않고 변경할 수 있도록 도와줍니다.\n\n\n\n# StrictMode의 현실 세계에서 얻는 이점\n\n저는 거대한 React 애플리케이션을 작업하는 세 명의 팀 중 한 명이었을 때 이상한 렌더링 버그로 골머리를 앓고 있었습니다. 마음이 놓여지지 않아 제 남은 머리카락을 뽑았지만, 우리 모듈을 StrictMode 명령어로 감싸보기로 결정했습니다. 놀라운 일에, 많은 결함을 즉시 가리켰는데, 그 중에는 위험한 라이프사이클 메소드를 사용하는 문제와 부작용이 있었습니다.\n\n우리는 이러한 문제에 신속히 대응할 수 있었고, 이로써 우리의 애플리케이션을 더 안정적이고 효율적으로 만들었습니다. 의심의 여지 없이, Android StrictMode는 우리 코드에 건강 진단을 해준 것이었습니다!\n\n# 결론: StrictMode 이점을 온전히 받아들이세요\n\n\n\nStrictMode는 모든 리액트 개발자가 코드 품질을 향상시키면서 더 능숙해지도록 도와주는 도구입니다. 어쩌면 조금 엄격한 친구처럼 느껴질 수 있지만 제공되는 사실들은 최상이며 가장 소중합니다. 그러므로 StrictMode에 대해 더 깊이 배우고, 리액트 코딩 경험을 한 단계 높여줄 가능성을 지켜보는 것을 꺼리지 마세요!\n\n# 콜 투 액션: 오늘부터 StrictMode 사용하기!\n\nStrictMode 도구를 귀하의 리액트 애플리케이션에 추가해 주시기 바랍니다. 게다가, 이와 같은 도구는 해당 문제와 코드에 미칠 긍정적인 영향에 대해 귀하를 놀라게 할 수도 있습니다. 약간의 엄격함은 리액트 개발 현상에서 중요하다는 말을 기억하세요.","ogImage":{"url":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"},"coverImage":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컴포넌트 라이프사이클 메서드","description":"","date":"2024-05-14 12:16","slug":"2024-05-14-ReactComponentLifecycleMethods","content":"\n\n![React Component Lifecycle Methods](/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png)\n\n프론트엔드 개발에서 React는 사용자 인터페이스를 구축하기 위한 가장 인기 있는 JavaScript 라이브러리 중 하나입니다. React가 강력한 이유 중 하나는 구성 요소 기반 아키텍처입니다. React 구성 요소가 라이프사이클 동안 어떻게 작동하는지 이해하는 것은 효율적인 애플리케이션을 구축하는 데 중요합니다.\n\n# React 구성 요소 라이프사이클 메서드란?\n\nReact 구성 요소는 초기화부터 파괴까지 라이프사이클 동안 다양한 단계를 거칩니다. React는 마운팅, 업데이팅 및 언마운팅 세 가지 단계로 분류할 수 있는 빌트인 메서드 집합인 라이프사이클 메서드를 제공합니다. 이 메서드를 사용하면 개발자는 이러한 단계에 훅을 걸어 작업을 수행할 수 있습니다.\n\n\n\n# 마운팅 단계:\n\n— constructor(): 이 메서드는 컴포넌트가 초기화될 때 호출됩니다. 상태를 초기화하고 이벤트 핸들러를 바인딩하는 데 사용됩니다.\n— render(): 이는 컴포넌트 UI의 JSX 표현을 반환하는 필수적인 메서드입니다. 컴포넌트가 다시 렌더링되어야 할 때마다 호출됩니다.\n— componentDidMount(): 컴포넌트가 마운트된 직후에 즉시 호출됩니다. 데이터 가져오기, 구독, 또는 제3자 라이브러리 초기화와 같은 부작용을 수행하는 데 자주 사용됩니다.\n\n# 업데이트 단계:\n\n— static getDerivedStateFromProps(): 이 메서드는 새로운 속성이 수신될 때 렌더링하기 바로 전에 호출됩니다. 속성 변경에 따라 상태를 업데이트할 수 있도록 합니다.\n— shouldComponentUpdate(): 이 메서드는 컴포넌트가 다시 렌더링해야 할지 여부를 결정합니다. 불필요한 다시 렌더링을 방지하여 성능을 최적화하는 데 사용됩니다.\n— render(): 업데이트된 상태나 속성으로 컴포넌트를 다시 렌더링합니다.\n— getSnapshotBeforeUpdate(): 가상 DOM의 변경이 실제 DOM에 반영되기 전 바로 호출됩니다. 업데이트 전에 일부 정보(예: 스크롤 위치)를 캡처할 수 있습니다.\n— componentDidUpdate(): 컴포넌트의 업데이트가 DOM으로 플러시된 후에 호출됩니다. 업데이트 이후에 업데이트된 데이터 가져오기 또는 업데이트 후 DOM과 상호 작용하는 등 부작용 수행에 자주 사용됩니다.\n\n\n\n# Unmounting Phase:\n\n— `componentWillUnmount()`: 컴포넌트가 언마운트되고 파괴되기 직전에 즉시 호출됩니다. 이는 이벤트 리스너 제거 또는 네트워크 요청 취소와 같은 정리 작업에 사용됩니다.\n\n라이프사이클 메소드 이해하기: \n각 라이프사이클 메소드는 특정 목적을 위해 제공되며, 개발자가 컴포넌트의 라이프사이클의 다른 단계에 훅을 걸고 그에 따라 작업을 수행할 수 있게 합니다.\n\n# 최상의 실천 방법:\n\n\n\n- 라이프사이클 메서드를 적게 사용하세요: React Hooks가 소개되면서 라이프사이클 메서드 대부분은 레거시로 간주되어 `useEffect`와 같은 Hooks를 선호하는 방식으로 대체되고 있습니다.\n- `render()`에서 부작용을 피하세요: `render()` 메서드는 순수해야 하며 부작용을 발생시키지 말아야 합니다. 부작용은 `componentDidMount()`나 함수형 컴포넌트의 `useEffect()`에서 수행되어야 합니다.\n- 성능에 유의하세요: `shouldComponentUpdate()`나 `React.memo()`를 사용하여 불필요한 다시 렌더링을 방지하여 컴포넌트 성능을 최적화하세요.\n- 자원 정리: 항상 `componentWillUnmount()`나 `useEffect()` 정리 함수에서 이벤트 리스너 제거 또는 구독 취소와 같은 정리 작업을 수행하세요.\n\n# 결론:\n\nReact 컴포넌트 라이프사이클 메서드를 이해하는 것은 확장 가능하고 효율적인 애플리케이션을 구축하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png","tag":["Tech"],"readingTime":3},{"title":"갇혀 있는 극악무도한 보안의 심연으로부터","description":"","date":"2024-05-14 12:15","slug":"2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity","content":"\n\nChapter three\n\n![Locked away from the depths of maximum security](/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png)\n\n금속 잠금장치가 동기화되어 열리는 소리가 복도를 통과하던 중, 트로이는 셀의 구금에서 벗어난다. 낮 시간이라 불리는 이 방 안에는 각각 여덟 개의 의자가 놓인 네 개의 탁자와 그 위에 위험하게 걸린 작은 32인치 TV가 있었다. 이것은 그들의 수감 상황을 뚜렷하게 상기시키는 것이었다. 수감자들이 셀에서 나와 공동 샤워, 카드 게임, 체스 대결 및 혼자만의 독서를 위한 필수품을 가지고 나왔다.\n\n그에게 다가온 것은 트로이가 그 유닛의 권위자로 가정했던 수감자였다. 5피트 9인치의 자신과 비슷한 키에 밝은 피부와 풍만한 체격을 가진 그 남자는 자신의 총명한 눈이 트로이의 눈을 뚫어봤다. 그는 “절차 알지? 정원에 있거나 짐 싸\"라고 권위적으로 말했다. 트로이는 ‘정원’이라는 말이 가지고 있는 함의를 이해했고, 이는 동맹원들이 구성원들에 대한 기록을 유지하는 시스템으로, 충돌 발생 시 중요하다. “자가 통치 선택권이 있어,\" 트로이가 반박했다.\n\n\n\n사람은 트로이의 억양을 무시하며, 최대한의 단위에서는 그와 같은 선택지가 없다고 설명했습니다. 트로이는 잠시 고민한 뒤 결과를 따져 보았습니다. '물러나다'는 자신을 드러내어 보호자가 되었지만 보복에 취약하게 남게 될 것이었습니다. 보호 관찰은 선택지가 아니었습니다. 그래서 마침내, 그는 설립된 기관들과 조인하기로 선택했습니다. 사람은 자신을 프리모로 소개했습니다. 트로이는 자신의 혐의를 폄하했습니다. 폭력사건 중에서도 어울리지 않는 약물 범행의 나열이었습니다. 프리모는 안심시켜 주며, 다른 구금구역으로의 이송을 약속했고, 그것은 트로이의 불안을 일시적으로 완화시켰습니다.\n\n그러나 폭력적인 범죄자들과 함께 한 유닛을 공유해야 한다는 현실은 트로이에게 큰 부담이었습니다. 다른 수감자들에게 다가올 때, 그는 조심스럽게 경계를 지키며 잠재적인 위협에 대해 예민하게 인식했습니다. TV의 깜박이는 빛 앞에 서있을 때, 트로이는 가족 - 어머니, 일곱 형제자매, 당시의 여자친구에 대한 생각으로 빛난 것에 주목했습니다. 외부 세계와의 연결 통로인 전화는 절망적인 전화를 위한 자금이 부족하여 조용했습니다.\n\n빅 에이가 제공한 수건, 비누, 식사화로 트로이는 지친 신체를 풀며 수영장으로 향했습니다. 재순환된 공기와 머무른 땀의 쇠약한 향기에 감싸여. 하루의 노엽을 씻어내는 고독 속에서, 트로이의 마음은 대립하는 생각과 달려 있는 것으로 뒹굴었습니다. 그를 둘러쌓은 피부에 남아 있는 늙은 먼지의 익숙한 냄새는, 그의 처지 - 사생활의 부재, 결정의 무게, 그리고 반복되는 감금에 대한 가족의 감정의 불확실함을 생생히 상기시켰습니다.\n\n트로이가 지친 몸에 쏟아지는 뜨거운 물과 함께, 그의 생각은 더욱 조각난 것처럼 더 혼란스러워졌습니다. 각각의 물방울은 그의 의심과 두려움을 메아리하며, 옥상을 흐르는 목소리와 금속의 딩동 소리와 섞였습니다. 트로이는 침착을 유지하려고 애썼지만, 그를 꺾어버릴 듯한 불안감의 끈 같은 감정이 그를 잡아채는 것을 흔들릴 수 없었습니다.\n\n\n\n한 시간 반이 지났지만, 갇힌 삶의 답답한 반복 속에서는 영원히 느껴졌다. 시간은 흘러가고, 트로이는 방향감소와 외부 세계에 대한 그리움을 느끼게 되었다. 다른 죄수들이 다시 감방으로 후퇴하는 것을 지켜보면서, 그는 지역 감옥 벽 안에서 시간이 무자비하게 흘러가는 것에 절망적인 감정을 억누를 수 없었다.","ogImage":{"url":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"},"coverImage":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png","tag":["Tech"],"readingTime":2},{"title":"React Js 설치 방법 완전 초보자용","description":"","date":"2024-05-14 12:14","slug":"2024-05-14-HowToInstallReactJsForcompletebeginners","content":"\n\n\n![React installation](/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png)\n\n요즘 리액트를 배우는 데 흥미를 느끼고 있고 리액트를 시작했습니다. 이 강력한 JavaScript 프레임워크를 사용하는 첫 번째 단계는 무엇일까요? React를 설치하기 전에 먼저 Node를 설치해야 합니다. 프로세스는 node 웹 사이트를 방문하고 최신 지원 버전을 다운로드하는 것만큼 간단합니다. Node가 필요한 이유가 궁금하다면, Node.js는 서버 측에서 JavaScript를 실행할 수 있는 JavaScript 런타임 환경입니다 (나중에 이에 대한 자세한 기사를 쓸 것입니다). 그 후 명령줄로 이동하여 명령줄이 익숙하지 않은 경우를 대비해 검색할 수 있습니다. React를 설치하는 방법에는 여러 가지가 있습니다:\n\na) CDN 사용 (가장 쉬운 방법)\n\n이 코드 조각을 html 코드의 head 부분에 포함하세요.\n\n\n\n\n```js\n\u003cscript crossorigin src=\"https://unpkg.com/react@18/umd/react.development.js\"\u003e\u003c/script\u003e\n\u003cscript crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"\u003e\u003c/script\u003e\n```\n\n이것은 쉽지만 제품 환경보다는 개발 환경에 권장됩니다. 학습을 시작할 때만 사용하는 것이 좋습니다.\n\na) Vite를 사용하는 방법\n\n명령줄에 다음과 같이 입력하세요: npm create vite@latest app_name — — template react. 그리고 npm install을 실행하고 코드를 행복하게 작성하세요. 이 방법의 장점은 vite가 다양한 기능을 갖추고 빠르며 서버를 빠르게 실행한다는 것입니다.```\n\n\n\nb) 이전 React 방식을 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-react-app 앱-이름. 그리고 나서 코딩을 즐기세요. 이 방법은 vite와 같은 다른 방법보다 서버를 빨리 구동하는 것에 비해 느릴 수 있습니다.\n\nc) Next.js 프레임워크를 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-next-app@latest 질문에 답하고 설치하세요. 다만, TypeScript/JavaScript, React, 그리고 tailwind CSS에 대한 선행 지식이 필요합니다.\n\n\n\n기존 프로젝트에서는 npm install react react-dom을 사용하여 프로젝트에 React를 추가할 수 있어요. Gatsby, remix와 같은 다양한 프레임워크도 설치할 수 있어요. 더 많은 정보를 원하시면 직접 찾아보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"},"coverImage":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 언제 useRef 대신에 useState를 사용해야 할까요","description":"","date":"2024-05-14 12:13","slug":"2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState","content":"\n\nReact에서 useRef는 함수형 컴포넌트 내에서 DOM 요소나 다른 React 요소를 참조하는 데 사용되는 훅입니다. (이 훅을 사용하면 함수형 컴포넌트가 클래스 컴포넌트의 this.refs와 유사한 기능을 활용할 수 있습니다.)\n\nuseRef를 사용하면 컴포넌트의 렌더링 여부에 관계없이 동일한 참조를 유지할 수 있습니다. 컴포넌트가 다시 렌더링되더라도 참조가 변경되지 않도록 보장할 수 있어 유용합니다.\n\n예를 들어 useRef를 사용하여 특정 DOM 요소에 대한 참조를 얻어 해당 요소를 프로그래박적으로 조작할 수 있습니다.\n\n\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst MyComponent = () =\u003e {\n  const myRef = useRef(null);\n\n  useEffect(() =\u003e {\n    // 컴포넌트가 마운트될 때 DOM 요소에 포커스를 설정합니다.\n    myRef.current.focus();\n  }, []);\n\n  return \u003cinput ref={myRef} /\u003e;\n};\n\nexport default MyComponent;\n```\n\n이 예제에서 useRef를 사용하여 myRef 변수를 만들고 그것을 입력 요소에 할당합니다. useEffect 훅을 사용하여 컴포넌트가 마운트될 때 해당 요소에 포커스를 설정합니다. myRef.current 프로퍼티를 사용하여 기본 DOM 요소에 액세스합니다.\n\n그럼 언제 useState 대신 useRef를 사용해야 할까요?\n\nuseState와 useRef는 React Hooks에서 서로 다른 목적을 제공합니다.```\n\n\n\nuseState: 컴포넌트의 상태를 관리하는 데 사용됩니다. 주로 컴포넌트의 상태가 변경될 때 다시 렌더링되기를 원할 때 사용됩니다. 상태가 변경되면 컴포넌트가 다시 렌더링됩니다. useRef: 렌더링과 직접적으로 관련이 없는 값을 유지해야 할 때 사용됩니다. 주로 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 직접적으로 관련이 없는 값들을 저장하는 데 사용됩니다. 따라서 useState와 useRef는 각각의 사용 사례에 따라 선택되어져야 합니다.\n\nuseRef를 사용하는 일반적인 시나리오는 다음과 같습니다:\n\n렌더링과 관련이 없는 값들 저장하기 DOM 요소에 대한 참조 저장하기 값이 변경되더라도 다시 렌더링이 필요하지 않은 경우 더 잘 이해하기 위해 예시와 설명을 살펴보겠습니다.\n\nuseState의 예제\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst Counter = () =\u003e {\n  const [count, setCount] = useState(0);\n\n  const increment = () =\u003e {\n    setCount(count + 1);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e카운트: {count}\u003c/p\u003e\n      \u003cbutton onClick={increment}\u003e증가\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Counter;\n```\n\n이 예제에서는 useState 훅을 사용하여 count 상태를 정의하고 업데이트하는 함수인 setCount를 정의합니다. count 상태가 컴포넌트의 렌더링에 직접적으로 영향을 주기 때문에 상태가 변경될 때마다 컴포넌트가 다시 렌더링됩니다.\n\nuseRef 예시\n\n```js\nimport React, { useRef, useEffect } from 'react';\n\nconst Timer = () =\u003e {\n  const intervalRef = useRef(null);\n  const secondsRef = useRef(0);\n\n  useEffect(() =\u003e {\n    intervalRef.current = setInterval(() =\u003e {\n      secondsRef.current += 1;\n      console.log('초:', secondsRef.current);\n    }, 1000);\n\n    return () =\u003e {\n      clearInterval(intervalRef.current);\n    };\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e타이머: {secondsRef.current} 초\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e clearInterval(intervalRef.current)}\u003e정지\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default Timer;\n```\n\n\n\n이 예에서 useRef 훅을 사용하여 두 개의 레퍼런스를 생성합니다: intervalRef와 secondsRef입니다. intervalRef는 setInterval의 반환 값을 저장하며, secondsRef는 시간을 추적하는 데 사용됩니다. useEffect 훅은 컴포넌트가 마운트될 때 setInterval을 시작하고 언마운트될 때 정리합니다. secondsRef는 컴포넌트의 렌더링과는 관계없이 값을 유지하며, secondsRef.current는 현재 시간을 추적하고 표시하는 데 사용됩니다.\n\n이 두 예제는 useState가 컴포넌트의 상태를 관리하고 렌더링을 트리거하는 데 사용되는 반면, useRef는 렌더링과 직접적으로 관련되지 않는 값을 저장하거나 DOM 요소에 액세스하는 데 사용됨을 보여줍니다.\n\n데이터가 많을수록 useRef를 사용해야 하는 경우가 더 많아지며, 이번에는 동일한 프로그램의 예제를 통해 이를 확인해볼 것입니다.\n\nuseState를 이용한 예제:\n\n\n\n```js\nimport React, { useState } from 'react';\n\nconst BigDataComponent = () =\u003e {\n  const [data, setData] = useState('');\n\n  const fetchData = () =\u003e {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // 데이터가 증가함에 따라 렌더링이 지연될 수 있습니다\n    const newData = '아주 많은 데이터...';\n    setData(newData);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e\n      \u003cp\u003e데이터 길이: {data.length}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default BigDataComponent;\n```\n\n이 예제에서는 useState를 사용하여 데이터를 관리하고, 버튼을 클릭할 때마다 fetchData 함수를 호출하여 많은 양의 데이터를 가져옵니다. 그러나 데이터 양이 증가함에 따라 렌더링이 느려질 수 있습니다.\n\nuseRef를 사용한 예제\n\n```js\nimport React, { useRef } from 'react';\n\nconst BigDataComponent = () =\u003e {\n  const dataRef = useRef('');\n\n  const fetchData = () =\u003e {\n    // 많은 양의 데이터를 가져오는 것을 가정\n    // useRef를 사용하여 컴포넌트의 렌더링에 영향을 미치지 않고 데이터를 설정합니다\n    const newData = '아주 많은 데이터...';\n    dataRef.current = newData;\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e\n      \u003cp\u003e데이터 길이: {dataRef.current.length}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default BigDataComponent;\n```\n\n\n\n이 예에서는 useRef를 사용하여 데이터를 관리합니다. 데이터 양이 증가해도 useRef를 사용하면 데이터를 설정할 때 컴포넌트의 렌더링 속도에 영향을 미치지 않습니다.\n\n이 두 예시를 통해 데이터 양이 증가할수록 useState는 느려질 수 있지만 useRef를 사용하면 데이터가 늘어나도 렌더링에 영향을 미치지 않고 데이터를 관리할 수 있다는 것을 알 수 있습니다.\n\n다시 말해, useRef의 중요한 특징 중 하나는 렌더링과 관련이 없는 값의 보존입니다.\n\n- 렌더링과 관련이 없는 값의 보존: useRef로 생성된 ref 객체의 current 프로퍼티에 할당된 값은 컴포넌트를 다시 렌더링해도 변경되지 않습니다. 이를 통해 useRef는 컴포넌트의 렌더링과는 독립적인 값을 유지할 수 있으며, 컴포넌트 상태와 관련이 없는 값을 보존하는 데 유용합니다.\n- 렌더링 주기 중 값이 변경되어도 다시 렌더링을 트리거하지 않음: useRef로 생성된 객체의 current 프로퍼티에 값이 렌더링 주기 중에 할당되더라도 컴포넌트는 다시 렌더링되지 않습니다. 따라서 useState와 달리 상태 업데이트가 렌더링을 트리거하지 않으므로 다시 렌더링 없이 값의 변화를 허용합니다. useRef를 사용하여 렌더링과 관련이 없는 값을 관리하거나 DOM 요소에 대한 참조나 외부 라이브러리의 인스턴스와 같이 렌더링과 관련이 없는 값들을 다루는데 유용합니다. 이러한 특징들은 useRef를 사용하여 컴포넌트 렌더링과는 독립적인 데이터를 관리하거나 DOM 요소에 접근할 때 매우 유용합니다.\n\n\n\n이를 효과적으로 활용하려면 React 렌더링에 대한 포괄적인 이해가 필수적입니다. 아래에는 React에서 렌더링이 작동하는 방식에 대한 기본 개념부터 최적화까지 간략한 개요가 있습니다.\n\n- 가상 DOM: 가상 DOM은 React에 의해 추상화된 실제 DOM의 가상 표현입니다. 상태 변경과 같은 이벤트가 발생하면 React는 가상 DOM을 업데이트하고 이를 실제 DOM과 비교하여 최소한의 작업을 적용하여 실제 DOM을 업데이트합니다. 이 과정은 성능을 향상시키고 불필요한 렌더링을 방지합니다.\n\n- 컴포넌트 렌더링 프로세스:\n\n  - 초기 렌더링: React 애플리케이션이 시작되면 컴포넌트 트리가 렌더링되어 초기 UI가 생성됩니다.\n  - 상태 또는 속성 변경: 사용자 상호작용과 같은 이벤트로 상태 또는 속성이 변경될 수 있습니다.\n  - 가상 DOM 업데이트: 상태 또는 속성이 변경되면 React는 해당 컴포넌트의 가상 DOM을 업데이트합니다. 필요없는 렌더링이나 DOM 조작을 최소화하기 위해 가상 DOM의 변경사항을 효율적으로 계산합니다.\n  - 실제 DOM 업데이트: 가상 DOM의 변경사항을 계산한 후 React는 실제 DOM과 비교하여 차이점을 식별하고 실제 DOM의 필요한 부분만 업데이트합니다. 이 최적화는 브라우저에서 불필요한 렌더링을 최소화합니다.\n\n- 렌더링 최적화: React는 성능을 최적화하기 위한 다양한 기술을 제공합니다:\n\n\n\n- PureComponent와 React.memo: 이들은 컴포넌트의 불필요한 다시 그리기를 방지하는 데 사용됩니다. PureComponent는 클래스 컴포넌트에 사용되며, React.memo는 함수형 컴포넌트에 사용됩니다.\n- shouldComponentUpdate 또는 React.memo를 사용한 컴포넌트 최적화: 이러한 방법을 사용하면 컴포넌트가 업데이트해야 하는 조건을 정의하여 다시 그리기를 제어하고 최적화할 수 있습니다.\n- 불변성 유지: 불변성을 유지함으로써 React는 상태가 변경될 때 새로운 객체를 생성하여 불필요한 다시 그리기를 방지합니다.\n\n이러한 렌더링 프로세스와 최적화 기술을 이해하면 효율적인 React 애플리케이션을 개발할 수 있습니다.\n\n다음 섹션에서는 더 나은 최적화를 위해 메모이제이션을 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png"},"coverImage":"/assets/img/2024-05-14-ReactWhenshouldweuseuseRefinsteadofuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 컨텍스트를 올바르게 활용하기","description":"","date":"2024-05-14 12:12","slug":"2024-05-14-UsingReactcontextstherightway","content":"\n\n리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.\n\n적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.\n\n![이미지](/assets/img/2024-05-14-UsingReactcontextstherightway_0.png)\n\n# 컨텍스트를 작성하는 방식의 관용적인 방법\n\n\n\n제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.\n\n이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.\n\n상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.\n\n그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.\n\n\n\n저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.\n\n저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.\n\n이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:\n\n그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:\n\n\n\n훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.\n\n한 가지씩 몇 가지 예시를 살펴보겠습니다.\n\n## URL에 상태 저장하기\n\n두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.\n\n\n\n## 로컬 스토리지에 상태 저장하기\n\n마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.\n\n마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:\n\n이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.\n\n\n\n## 파생 상태 노출 및 사용자 정의 작업 노출하기\n\nProvider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.\n\n다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.\n\n이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.\n\n\n\n# 컨텍스트 생성을 덜 번거롭게 만들기\n\n일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.\n\n그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.\n\n앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.\n\n\n\n다음과 같이 전역 범위에서 사용할 수 있습니다:\n\n이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 \"의사 전역\" 상태를 매우 쉽게 생성할 수 있습니다.\n\n여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.\n\n## 기타 장점\n\n\n\n요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:\n\n- 다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)\n- 중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.\n- 내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.\n- 데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.\n\n# 결론\n\n캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.\n\n\n\n내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"},"coverImage":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png","tag":["Tech"],"readingTime":4},{"title":"스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기","description":"","date":"2024-05-14 12:09","slug":"2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs","content":"\n\n다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png)\n\n언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.\n\nNext.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.\n\n\n\n# 데모\n\n기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻\n\n# 준비물\n\n구현을 시작하기 위해 다음이 필요합니다:\n\n\n\n- Node.js 18 또는 그 이후 버전\n- Stream 계정\n- Vercel 계정\n\n# 새 Stream 애플리케이션 설정하기\n\n이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.\n\nStream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_1.png\" /\u003e\n\n어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_2.png\" /\u003e\n\n설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.\n\n\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png)\n\n권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 \"인증 확인 비활성화\" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png)\n\n방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.\n\n\n\n사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png)\n\n방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 \"메시지 생성\" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png)\n\n\n\n방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png)\n\n마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png)\n\n\n\n이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.\n\n# 새 Next.js 애플리케이션 설정\n\n이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.\n\n새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:\n\n\n\n```js\r\nnpx create-next-app@latest my-chat-app\r\n```\r\n\r\n진행할 때, 다음을 선택하세요:\r\n\r\n- TypeScript를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- ESLint를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- Tailwind CSS를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- src/ 디렉토리를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- App Router를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- 기본 import alias를 맞춤 설정할 것인지 물으면 \"No\"를 선택하세요.\r\n\r\n위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:```\n\n\n\n```js\ncd my-chat-app\nnpm run dev\n```\n\n앱은 localhost:3000에서 실행 중이어야 합니다.\n\n이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.\n\n다음과 같이 보여야 합니다:```\n\n\n\n```js\n# .env\n\n# 스트림 환경 변수\nNEXT_PUBLIC_STREAM_API_KEY=\"...\"\n\n```\n\n## shadcn/ui 컴포넌트 통합\n\n채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n\n\n구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:\n\n- TypeScript를 사용하것이라고 하면 \"예\"를 선택하세요.\n- 사용할 스타일을 선택하라는 프롬프트가 나오면 \"기본\"을 선택하세요.\n- 기본 색상으로 선택하라는 프롬프트가 나오면 \"Slate\"를 선택하세요.\n- 색상에 CSS 변수를 사용하냐고 묻힐 경우 \"예\"를 선택하세요.\n\n위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.\n\n```js\nnpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add textarea\n```\n\n\n\n그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.\n\n## Chatscope 및 Stream UI Kit를 React에 설치하기\n\n구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.\n\n먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.\n\n\n\n위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n```js\nnpm install @chatscope/chat-ui-kit-react\nnpm install stream-chat stream-chat-react\nnpm install unique-username-generator\n```\n\n다음 라이브러리가 설치됩니다:\n\n- unique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.\n- stream-chat: Stream의 JavaScript API 클라이언트입니다.\n- stream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.\n- @chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.\n\n\n\n자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.\n\n# ChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기\n\n이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.\n\n먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.\n\n\n\n앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:\n\n```js\nimport { cn } from \"@/lib/utils\";\nimport { useChannelStateContext } from \"stream-chat-react\";\nimport { Message, MessageList } from \"@chatscope/chat-ui-kit-react\";\n\nexport default function () {\n  const { messages } = useChannelStateContext();\n  return (\n    \u003cMessageList\u003e\n      {messages?.map((i, index: number) =\u003e (\n        \u003cMessage\n          key={i.id}\n          model={{\n            position: \"normal\",\n            sender: i.user?.id,\n            direction: \"incoming\",\n            message: `${i.user?.id}: ${i.text}`,\n            sentTime: i.created_at?.toString(),\n          }}\n          className={cn(\n            \"bg-white rounded text-black py-2 text-xs\",\n            index !== messages.length - 1 \u0026\u0026 \"border-b\"\n          )}\n        /\u003e\n      ))}\n    \u003c/MessageList\u003e\n  );\n}\n```\n\n`useChannelStateContext` 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. `MessageList` 및 `Message` Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.\n\n이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:\n\n\n\n```js\n\"use client\";\n\nimport { useState } from \"react\";\nimport Messages from \"./Messages\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\nimport { Textarea } from \"@/components/ui/textarea\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        \u003cspan className=\"border-b border-gray-100 font-semibold\"\u003e채팅\u003c/span\u003e\n        {channel \u0026\u0026 (\n          \u003cChat client={chatClient}\u003e\n            \u003cChannel channel={channel}\u003e\n              \u003cMessages /\u003e\n            \u003c/Channel\u003e\n          \u003c/Chat\u003e\n        )}\n        \u003cTextarea\n          id=\"message_text\"\n          name=\"message_text\"\n          placeholder=\"메시지...\"\n          className=\"min-h-[100px] w-full\"\n        /\u003e\n        \u003cButton className=\"max-w-max\"\u003e\n          메시지 보내기 \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:\n\n```js\n\"use client\";\n\nimport Messages from \"./Messages\";\n+ import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\n+ import { DevToken, StreamChat } from \"stream-chat\";\nimport { Textarea } from \"@/components/ui/textarea\";\n+ import { generateUsername } from \"unique-username-generator\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+ const loadChatClient = async () =\u003e {\n+   const newChatClient = new StreamChat(\n+     process.env.NEXT_PUBLIC_STREAM_API_KEY,\n+     {\n+       enableWSFallback: true,\n+     }\n+   );\n+    if (newChatClient.user) await newChatClient.disconnectUser();\n+   const localUser = localStorage.getItem(\"local_user\");\n+   if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n+   const id = localStorage.getItem(\"local_user\");\n+   const userToConnect = { id };\n+   await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n+   setChatClient(newChatClient);\n+ };\n+ useEffect(() =\u003e {\n+   loadChatClient();\n+ }, []);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 그대로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.```\n\n\n\n특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:\n\n```js\n\"use client\";\n\n// Imports as is\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+  const watchChannel = () =\u003e {\n+    const channel = chatClient.channel(\"messaging\", \"livestreaming_chat\", {\n+      name: \"실시간 스트리밍 채팅\",\n+    });\n+    channel.watch().then(() =\u003e setChannel(channel));\n+  };\n  const loadChatClient = async () =\u003e {\n    const newChatClient = new StreamChat(\n      process.env.NEXT_PUBLIC_STREAM_API_KEY,\n      {\n        enableWSFallback: true,\n      }\n    );\n    if (newChatClient.user) await newChatClient.disconnectUser();\n    const localUser = localStorage.getItem(\"local_user\");\n    if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n    const id = localStorage.getItem(\"local_user\");\n    const userToConnect = { id };\n    await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n    setChatClient(newChatClient);\n  };\n  useEffect(() =\u003e {\n    loadChatClient();\n  }, []);\n+  useEffect(() =\u003e {\n+    if (chatClient) watchChannel();\n+  }, [chatClient]);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.\n\n채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\n\"use client\";\n\n// 그대로 가져오기\n\nexport default function () {\n  // 변수, 훅 그대로\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        {/* 컴포넌트 나머지 */}\n        \u003cButton\n          className=\"max-w-max\"\n          onClick={() =\u003e {\n            if (channel) {\n              channel.sendMessage({\n                text: document.getElementById(\"message_text\").value,\n              });\n              document.getElementById(\"message_text\").value = \"\";\n            }\n          }\n        \u003e\n          Send Message \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nonClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!\n\n이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.\n\n# Vercel에 배포하기\n\n\n\n이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:\n\n- 먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.\n- 그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.\n- 새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.\n- 설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.\n- 배포를 클릭합니다.\n\n# 마치며\n\n요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.\n\n\n\n# 더 많은 정보\n\n더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.\n\n- GitHub 저장소\n- 챗스코프 UI 킷\n- 인증되지 않은 사용자 - 스트림\n- 채널 시청 - 스트림","ogImage":{"url":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"},"coverImage":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png","tag":["Tech"],"readingTime":12},{"title":"한국어 Axios 인터셉터란 무엇인가요","description":"","date":"2024-05-14 12:08","slug":"2024-05-14-ENWhatareAxiosInterceptors","content":"\n\n![Axios Interceptors](/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png)\n\n인터셉터란 무엇인가요?\n인터셉터는 프로그램의 기능을 확장하거나 수정하는 데 사용되는 디자인 패턴입니다. Axios에서 인터셉터는 HTTP 요청과 응답을 처리하는 데 사용되는 특별한 함수입니다. 요청 인터셉터를 사용하면 요청을 보내기 전에 작업을 수행할 수 있고, 응답 인터셉터는 서버에서 반환된 응답에 작업을 수행할 수 있습니다.\n\nAxios 인터셉터를 사용해야 하는 이유는 무엇인가요?\n\n- 재사용성과 모듈성.\n- 오류 처리 용이성.\n- 보안 제어 및 인가 유효성 검사 프로세스 용이성.\n- 네트워크 문제 처리.\n- 사용 편의성과 유연성.\n- 성능 및 최적화.\n\n\n\nAxios Interceptors의 사용법\n간단한 사용법을 가지고 있고 Axios 내에서 추가 설정이 필요하지 않아 장점을 제공합니다.\n\n```js\nconst axiosInstance = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': null\n  }\n});\n\naxiosInstance.interceptors.request.use(\n  function (config) {\n    // 요청을 보내기 전 수행할 작업\n    console.log('요청을 보냅니다:', config);\n    \n    // 예를 들어, 각 요청에 세션 식별자를 추가할 수 있습니다.\n    const accessToken = localStorage.getItem('accessToken');\n    if (accessToken) {\n      config.headers.Authorization = `Bearer ${accessToken}`;\n    }\n\n    return config;\n  }, \n  function (error) {\n    // 요청 오류 발생 시 수행할 작업\n    console.error('요청 오류:', error);\n    return Promise.reject(error);\n  }\n);\n\naxiosInstance.interceptors.response.use(\n  function (response) {\n    // 응답이 성공했을 때 수행할 작업\n    console.log('응답:', response.data);\n    return response;\n  },\n  function (error) {\n    // 응답 오류 발생 시 수행할 작업\n    console.error('응답 오류:', error);\n    \n    // 예를 들어, 401 (Unauthorized) 오류 발생 시 세션이 만료된 것으로 가정할 수 있습니다.\n    if (error.response.status === 401) {\n      // 세션 새로 고침이나 로그인 페이지로 리다이렉트하는 등의 작업 수행 가능\n      console.log('세션이 만료되었습니다. 리다이렉트 중...');\n      // 예를 들어, 사용자를 로그인 페이지로 리다이렉트:\n    }\n    return Promise.reject(error);\n  }\n);\n\n// 예시 요청\n\naxiosInstance.get('/data')\n  .then(response =\u003e {\n    console.log('응답:', response.data);\n  })\n  .catch(error =\u003e {\n    console.error('오류:', error);\n  });\n\naxiosInstance.post('/post-data', {\n  // 전송할 데이터\n  firstName: 'John',\n  lastName: 'Doe'\n})\n.then(response =\u003e {\n  console.log('응답:', response.data);\n})\n.catch(error =\u003e {\n  console.error('오류:', error);\n});\n```\n\n🚀🚀 이 예시처럼 들어오는 오류를 잡아 사용자에게 반환하거나 페이지 간에 리다이렉트할 수 있습니다.\n콘솔에서 각 요청의 오류와 본문을 쉽게 보고 조치할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_1.png\" /\u003e\n\n\n\n### 이전 게시물","ogImage":{"url":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png"},"coverImage":"/assets/img/2024-05-14-ENWhatareAxiosInterceptors_0.png","tag":["Tech"],"readingTime":3},{"title":"BEM에 익숙해지기","description":"","date":"2024-05-14 12:07","slug":"2024-05-14-GettingComfortablewithBEM","content":"\n\n이번 서킷에서 첫 번째 토픽은…. BEM! BEM이 뭐냐고 물을 수도 있겠죠? BEM은 HTML을 위한 클래스를 만드는 데 사용되는 방법론으로, 보다 깔끔하고 명확한 CSS 구조로 이어집니다. 이것은 제가 직전 프로젝트를 제 강사들에게 제출했을 때 생긴 굉장한 문제 때문에 저의 집착의 대상이 되었어요... 그것은 엉망이었고, 그런 일은 더 이상 허용되지 않아야 했죠.\n\n제 클래스 이름과 CSS가 의미가 있었죠… 버튼을 만들어야 했을 때, 기본 버튼을 만들고 약간 바꾼 버튼을 위한 다른 클래스를 만들었어요. 주로 내 메인 `a`는 특정한 방식으로 보이도록 설정을 하지만, 다른 hover 효과를 주고 싶은 앵커를 위해 a.purple-hover를 만들었어요. 결국, 제가 개별 요소를 위한 많은 클래스를 만들어 CSS 파일을 수백 줄짜리 HTML 파일에 수천 줄의 코드를 작성하고 있었어요.\n\n클래스 스타일을 조직하는 더 나은 방법을 찾아야 했고, 다른 개발자가 살펴보더라도 보다 빨리 이해할 수 있도록 페이지를 더 이해하기 쉽게 만들어야 했어요. 몇 분 동안 기사를 찾아보고 유튜브를 뒤지던 중, BEM을 발견했어요. Block-Element-Modifier는 기본 값, 해당 값의 변경 및 위치를 명확하게 정의하는 방법입니다. BEM을 해석하고 사용 사례 및 구현 방법을 설명하는 가장 좋은 설명은 https://en.bem.info/methodology/css/에서 찾았어요. 꼭 한 번 읽어보시고 이미 사용하고 있지 않다면 직접 구현해보는 것을 강력히 추천드립니다.\n\n기사를 그대로 소화할 생각은 없으니, 다시 한 번 읽는 것을 강력히 추천합니다. 제가 다룰 내용은 어떻게 BEM을 처음부터 적용할 것인지입니다. 작업하고 싶은 개인 프로젝트가 있어요, 개인 블로그 페이지(얼마나 진부한지 알죠)를 만들어서 게시하고, 게시한 내용을 모든 주요 블로그 사이트에 자동으로 업데이트할 수 있는 시스템을 구축할 거에요. 참고할 예시를 북마크하고 위의 링크를 저장해서 방법론을 준수하며 진행할 것이에요. 진행 상황은 여기에 업데이트할 거예요.\n\n\n\n제가 예시를 제대로 제공하지 않고 코드 조각을 포함하지 않은 것을 알고 있어요. 그러나 이번 주에 다른 주에서 12시간씩 일하고 호텔로 출퇴근해야 하는 일을 시작해서 조정 중입니다. 제가 계속 학습하고 블로깅을 진행할 수 있게 하는 것에 감사하게 생각해요. 개인 프로젝트에 착수할 때 BEM을 어떻게 사용하는지 보여줄 거예요. 그러나 반복해서 말씀드렸듯이, 위에 언급한 기사를 읽어보세요. 정말 흥미로워요.\n\n다음에 만나요, 여러분의 하드해트를 쓴 블루 칼라 코더 세르지오 파렐 / 페럴 코드예요. 좋은 밤 되세요, 그리고 계속 코딩하세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png"},"coverImage":"/assets/img/2024-05-14-GettingComfortablewithBEM_0.png","tag":["Tech"],"readingTime":2},{"title":"GraphQL 및 MongoDB와 React","description":"","date":"2024-05-14 12:05","slug":"2024-05-14-GraphQLandMongoDBwithReact","content":"\n\n![그림](/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png)\n\n웹 개발자들의 세계에서는 계속해서 최고의 개발 및 웹 응용 프로그램의 기능을 보여줄 수 있는 것을 찾기 위한 노력이 계속되고 있습니다. 오래된 REST API의 대안으로 최근에 인정받게 된 새롭고 흥미로운 기술이 GraphQL입니다. REST가 한 요청에 대해 자주 단일 데이터 세트를 반환하는데 반해, GraphQL은 클라이언트가 원하는 특정 데이터를 요청할 수 있습니다. 따라서 데이터 전송을 줄이는 것뿐만 아니라 서버 측 응답을 빠르고 간단하게 만드는 두 가지 과정으로 이루어집니다. GraphQL과 MongoDB의 조합은 데이터 처리에 있어 유연하고 효율적인 조합을 제공합니다. 이 멋진 GraphQL과 MongoDB의 조합은 개발자들이 동적 웹 응용 프로그램을 디자인하고 관리하는 방식에 혁명을 일으키고 있습니다.\n\n# GraphQL의 힘\n\nGraphQL의 가장 큰 장점은 그 유연성입니다. 개발자들은 쿼리를 최적화하여 필요한 모든 데이터를 한 군데서 얻을 수 있습니다. 이로 인해 REST API에 대해 여러 차례의 연이은 요청이 필요하지 않아집니다. 현재 장치의 다양성 및 네트워크 조건의 변동성에 매우 중요합니다.\n\n\n\nGraphQL, MongoDB 및 React가 웹 개발의 주요 도구로 사용될 때, 이러한 도구들은 개발 프로세스를 자동화할 수 있게 되었습니다. 이것은 완전히 다르게 만듭니다. 문서 중심의 NoSQL 데이터베이스 시스템인 MongoDB는 대량의 비구조화 정보를 처리하는 우수한 옵션을 제공하며, 동적이고 구조화되지 않은 GraphQL 요청을 쿼리하는 데 매우 빠르고 유연합니다. React의 선언 기반 특성을 활용하여 사용자 인터페이스를 구축하고 응용 프로그램의 상태를 처리하는 것은 매우 적합합니다. React는 데이터베이스에서 사용자 인터페이스로 실시간 데이터를 제공하여 GraphQL의 동적이고 견고한 특성을 보완합니다.\n\n본 글에서는 GraphQL을 통해 MongoDB와 통신하고 React 애플리케이션을 통합하는 과정, GraphQL 서버 설정 방법 및 데이터베이스 상호작용을 최적화하기 위한 최선의 방법에 대해 살펴보겠습니다. 이러한 기술의 결합을 통해 프로그래밍 시간을 최소화하고 애플리케이션의 유지 보수를 간소화할 뿐만 아니라, 고성능 및 확장 가능한 웹 애플리케이션을 구축할 수 있는 기회를 제공합니다.\n\n# GraphQL 기초\n\n2015년 Facebook 팀이 설계한 GraphQL은 API용 쿼리 언어로 볼 수 있으며, 동시에 제공된 데이터를 기반으로한 쿼리 실행 메커니즘을 제공합니다. 이를 통해 기업은 API 데이터를 완전하고 의미 있게 설명하여 고객이 정확히 필요한 것만 요청할 수 있도록 합니다. 결과적으로 네트워크 개선으로 이어지고, 네트워크 부하가 줄어듭니다.\n\n\n\n# 스키마와 타입\n\nGraphQL 스키마는 API의 중심 요소입니다. GraphQL 스키마는 데이터 유형과 그들 사이의 관계를 정의하며, 따라서 쿼리는 클라이언트가 원하는 것과 정확히 일치하도록 구성됩니다. 설명은 목록처럼 보이며 위치에는 유형이 있을 수 있습니다. 그들은 더 유연하고 복잡한 데이터 구조를 만들 수 있도록 유형의 유형일 수도 있습니다.\n\n# 쿼리\n\nGraphQL의 쿼리는 정적 특성 모음과 달리, GraphQL에서는 일치하는 스키마에서 제공된 유형에 해당하는 모든 데이터를 포함할 수 있습니다. GraphQL의 경우 클라이언트는 자주 REST API에서 발생하는 불필요한 정보 전달 없이 정확히 필요에 맞는 방식으로 데이터를 검색할 수 있습니다.\n\n\n\nGraphQL에서의 예시 쿼리는 다음과 같을 수 있어요:\n\n```js\n{\n  user(id: \"1\") {\n    name\n    email\n    friends {\n      name\n    }\n  }\n}\n```\n\n이 쿼리는 사용자의 이름, 이메일, 그리고 친구들의 이름에 대한 정보만 요청하고, 사용자와 친구들에 대한 다른 모든 정보는 제외합니다.\n\n# 뮤테이션(mutations)\n\n\n\nGraphQL에서 돌연변이는 데이터를 수정하는 데 사용됩니다. 쿼리와 마찬가지로 돌연변이는 스키마에 의해 정의되며 클라이언트가 데이터를 정확하고 제어된 방식으로 변경할 수 있도록 합니다. 돌연변이는 다음과 같이 보일 수 있습니다:\n\n```js\nmutation {\n  addUser(name: \"John Doe\", email: \"john@example.com\") {\n    id\n    name\n    email\n  }\n}\n```\n\n이 예제에서 addUser 돌려변이는 지정된 이름과 이메일 주소를 가진 새로운 사용자를 추가하고 새로 생성된 사용자에 대한 정보를 반환합니다.\n\n# Subscriptions\n\n\n\n서브스크립션은 GraphQL의 중요한 부분으로, 클라이언트가 원하는 데이터에 대한 실시간 알림을 받을 수 있는 기능을 제공합니다. 이는 대화방이나 게임과 같이 데이터의 지속적인 업데이트가 필요한 애플리케이션에서 특히 유용합니다. GraphQL의 서브스크립션은 다음과 같이 구현할 수 있습니다:\n\n```js\nsubscription {\n  messageAdded(channelId: \"1\") {\n    id\n    content\n    sender {\n      name\n    }\n  }\n}\n```\n\n채널에 새로운 게시물이 추가될 때, 모든 구독자는 즉시 게시물의 세부 정보를 포함한 알림을 받습니다.\n\n# REST와의 비교\n\n\n\nREST에서 볼 수 있는 데이터의 형태와 볼륨을 결정하는 데 서버가 가지는 고민과는 달리, GraphQL에서는 실제로 데이터를 요청하는 것이 클라이언트에 달려 있습니다. 이는 검색된 데이터를 필요한 것만으로 줄이고 데이터 상호작용이 어떻게 일어나는지에 대한 클라이언트의 제어를 더 많이 제공합니다. 이 GraphQL의 기능은 오늘날 고성능과 속도를 요구하는 웹 애플리케이션에 이상적입니다.\n\n# GraphQL 서버 구성\n\nMongoDB 및 React와 결합하여 GraphQL의 모든 잠재력을 실현하는 첫 번째 단계는 GraphQL 서버를 생성하는 것입니다. 이 섹션에서는 이 접근 방식을 사용하여 서버를 생성하고 실행하는 방법을 배우게 됩니다. 이 스택은 React 및 Apollo Client를 사용하여 프런트엔드 애플리케이션, Express 및 Apollo Server를 사용하는 백엔드, 그리고 Mongoose 라이브러리를 통해 서버리스 Mongo DB로 구성됩니다.\n\n# 단계 1: 몇 가지 설치 의존성을 추가하여 프로젝트를 개인화하세요.\n\n\n\n첫 번째로, 새로운 노드를 생성하세요. 먼저 새 브라우저 인스턴스를 열고 JS 프로젝트를 수행해야 하는 설치 페이지로 이동한 다음 필요한 패키지를 설치해주세요. 터미널을 열고 다음 명령을 실행하세요:\n\n```js\nmkdir graphql-mongo-server\ncd graphql-mongo-server\nnpm init -y\nnpm install apollo-server-express express graphql mongoose\n```\n\n이러한 명령은 프로젝트를 위한 새 디렉토리를 생성하고, 새로운 Node.js 프로젝트를 초기화하며 필요한 종속성을 설치합니다.\n\n# 단계 2: Express 및 Apollo Server 구성\n\n\n\n`index.js` 파일을 만들고 Express 서버 구성 및 GraphQL 쿼리를 처리하기 위해 Apollo Server를 통합하세요.\n\n```js\n// index.js\n\nconst express = require('express');\nconst { ApolloServer, gql } = require('apollo-server-express');\n\nconst app = express();\n\n// GraphQL 스키마 정의\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`;\n\n// 리졸버 구현\nconst resolvers = {\n  Query: {\n    hello: () =\u003e '안녕, 세상아!'\n  }\n};\n\n// Apollo 서버 생성\nconst server = new ApolloServer({ typeDefs, resolvers });\n\n// Express 미들웨어에 Apollo 적용\nserver.applyMiddleware({ app });\n\nconst PORT = 4000;\napp.listen(PORT, () =\u003e\n  console.log(`서버가 http://localhost:${PORT}${server.graphqlPath} 에서 실행 중입니다.`)\n);\n```\n\n# Step 3: MongoDB 연결\n\nMongoose를 사용하여 프로젝트에 MongoDB를 추가하세요. 이를 위해 `index.js` 파일을 업데이트하여 데이터베이스에 연결하는 코드를 추가하세요.\n\n\n\n```js\nconst mongoose = require('mongoose');\n\n// MongoDB에 연결\nmongoose.connect('mongodb://localhost:27017/mygraphqlapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n});\nmongoose.connection.once('open', () =\u003e {\n  console.log('MongoDB 데이터베이스에 연결되었습니다');\n});\n```\n\n로컬호스트:27017/mygraphqlapp를 귀하의 데이터베이스 연결 문자열로 교체해 주세요.\n\n# 단계 4: GraphQL 모델 및 스키마 정의\n\nMongoose 데이터 모델의 정의를 형식화하고 이러한 모델을 사용하여 GraphQL 스키마를 설정합니다. 예를 들어, 사용자 모델을 생성하고 이를 GraphQL 스키마에 추가합니다.\n\n\n\n\n```js\n// Mongoose 사용자 모델 정의\nconst User = mongoose.model('User', new mongoose.Schema({\n  name: String,\n  email: String,\n  age: Number\n}));\n\n// GraphQL 스키마 확장\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String\n    email: String\n    age: Int\n  }\n  type Query {\n    users: [User]\n  }\n  type Mutation {\n    addUser(name: String!, email: String!, age: Int): User\n  }\n`;\nconst resolvers = {\n  Query: {\n    users: () =\u003e User.find({})\n  },\n  Mutation: {\n    addUser: async (_, { name, email, age }) =\u003e {\n      const user = new User({ name, email, age });\n      await user.save();\n      return user;\n    }\n  }\n};\n```\n\n이러한 단계를 통해 MongoDB 연결이 준비된 기본 GraphQL 서버를 생성할 수 있습니다. React 애플리케이션과 효율적으로 상호작용하는 쿼리 및 뮤테이션을 처리하기 위해 이 서버를 사용할 수 있습니다.\n\n# React에서의 GraphQL 통합\n\nGraphQL 서버를 설정하면 다음으로 할 일은 해당 서버를 React 앱과 통합하는 것입니다. Apollo Client를 통해 GraphQL 서버에 쉽게 쿼리 및 뮤테이션을 수행할 수 있어 MongoDB 데이터와 동적 상호작용을 가능하게 할 수 있습니다. 이 경우에는 React에 Apollo Client를 추가하고 이 섹션에서 몇 가지 작업을 찾아보는 방법을 살펴볼 것입니다.\n\n\n\n\n# 단계 1: Apollo Client 설치하기\n\n먼저 React 프로젝트에 필요한 Apollo Client 패키지를 설치해보세요:\n\n```js\nnpm install @apollo/client graphql\n```\n\n# 단계 2: Apollo Client 사용자 정의하기\n\n\n\nApollo Client의 인스턴스를 생성하고 React 애플리케이션에 연결해보세요. 이를 위해 다음 코드를 ApolloClient.js와 같은 파일에 추가해주세요:\n\n```js\nimport { ApolloClient, InMemoryCache, HttpLink, from } from '@apollo/client';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql' // 여러분의 GraphQL 서버 URL로 교체해주세요\n});\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: from([httpLink])\n});\nexport default client;\n```\n\n# 단계 3: Apollo Provider 통합\n\nReact 앱을 ApolloProvider로 감싸서 쿼리와 뮤테이션을 앱의 모든 컴포넌트에서 사용할 수 있게 만들어보세요. App.js에서:\n\n\n\n```js\nimport React from 'react';\nimport { ApolloProvider } from '@apollo/client';\nimport client from './ApolloClient';\nimport Users from './components/Users';\n\nfunction App() {\n  return (\n    \u003cApolloProvider client={client}\u003e\n      \u003cdiv className=\"App\"\u003e\n        \u003ch1\u003eGraphQL and React\u003c/h1\u003e\n        \u003cUsers /\u003e\n      \u003c/div\u003e\n    \u003c/ApolloProvider\u003e\n  );\n}\nexport default App;\n```\n\n# 단계 4: 쿼리와 뮤테이션 만들고 사용하기\n\nGraphQL과 상호 작용하기 위해 useQuery와 useMutation 훅을 사용하는 React 컴포넌트를 만듭니다. 사용자를 표시하고 새 사용자를 추가하는 컴포넌트 예제:\n\n```js\nimport React, { useState } from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_USERS = gql`\n  query {\n    users {\n      id\n      name\n      email\n    }\n  }\n`;\n\nconst ADD_USER = gql`\n  mutation AddUser($name: String!, $email: String!) {\n    addUser(name: $name, email: $email) {\n      id\n      name\n      email\n    }\n  }\n`;\n\nfunction Users() {\n  const { data, loading, error } = useQuery(GET_USERS);\n  const [addUser] = useMutation(ADD_USER);\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  if (loading) return \u003cp\u003eLoading...\u003c/p\u003e;\n  if (error) return \u003cp\u003eError :(\u003c/p\u003e;\n  const handleSubmit = async (event) =\u003e {\n    event.preventDefault();\n    if (name \u0026\u0026 email) {\n      await addUser({ variables: { name, email } });\n      window.location.reload(); // 추가 후 간단히 페이지 새로고침\n    }\n  };\n  return (\n    \u003cdiv\u003e\n      \u003cform onSubmit={handleSubmit}\u003e\n        \u003cinput\n          type=\"text\"\n          placeholder=\"이름\"\n          value={name}\n          onChange={e =\u003e setName(e.target.value)}\n        /\u003e\n        \u003cinput\n          type=\"email\"\n          placeholder=\"이메일\"\n          value={email}\n          onChange={e =\u003e setEmail(e.target.value)}\n        /\u003e\n        \u003cbutton type=\"submit\"\u003e사용자 추가\u003c/button\u003e\n      \u003c/form\u003e\n      \u003cul\u003e\n        {data \u0026\u0026 data.users.map(user =\u003e (\n          \u003cli key={user.id}\u003e{user.name} - {user.email}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\nexport default Users;\n```\n\n\n\n본 코드는 React 애플리케이션에서 GraphQL을 사용하여 데이터를 가져와 서버로 전송하는 예시입니다. 주어진 예시는 당신의 애플리케이션의 더 정교한 요구사항과 기능에 맞게 개선하고 일반화할 수 있습니다.\n\n# 실제 예시: 할 일 앱\n\n이어서, 웹 개발 기초를 학습하는 초보자들에게 표준 연습으로 사용되는 To-Do 애플리케이션을 만들어 봅시다. 이 특정 섹션에서는 우리의 프론트엔드로 React를 구현하고 데이터 관리를 위해 GraphQL을 사용하며, 데이터 저장소로 MongoDB를 사용할 간단한 Todo 애플리케이션을 만들어 보겠습니다. 이 프로젝트는 작업 생성, 편집 및 삭제와 같은 항목을 다룰 것입니다.\n\n# 단계 1: MongoDB 데이터베이스 구성하기\n\n\n\nMongoDB를 설치하여 작업 데이터를 저장하는 것이 첫 번째 단계입니다. Mongoose를 사용하여 MongoDB에 Todo 항목을 위한 스키마를 만듭니다:\n\n```js\nconst mongoose = require('mongoose');\n\nconst { Schema } = mongoose;\n\nconst todoSchema = new Schema({\n  text: String,\n  completed: Boolean\n});\n\nconst Todo = mongoose.model('Todo', todoSchema);\n```\n\n# 단계 2: GraphQL 스키마 만들기\n\nTodo 요소를 관리하는 데이터 유형, 쿼리 및 뮤테이션을 포함하는 GraphQL 스키마를 정의합니다.\n\n\n\n```js\n상수 { gql } = require ('apollo-server-express')를 가져와주세요.\n\nconst typeDefs = gql`\n  type Todo {\n    id: ID!\n    text: String!\n    completed: Boolean!\n  }\n  type Query {\n    todos: [Todo]\n  }\n  type Mutation {\n    addTodo(text: String!): Todo\n    updateTodo(id: ID!, completed: Boolean!): Todo\n    deleteTodo(id: ID!): Todo\n  }\n`;\n\n# 단계 3: 리졸버 구현하기\n\n다음 단계는 GraphQL을 위한 리졸버를 구현하는 것인데, 이는 데이터베이스와 상호작용하는 논리를 제공합니다.\n\nconst resolvers = {\n  Query: {\n    todos: () =\u003e Todo.find({})\n  },\n  Mutation: {\n    addTodo: async (_, { text }) =\u003e {\n      const todo = new Todo({ text, completed: false });\n      await todo.save();\n      return todo;\n    },\n    updateTodo: async (_, { id, completed }) =\u003e {\n      return Todo.findByIdAndUpdate(id, { completed }, { new: true });\n    },\n    deleteTodo: async (_, { id }) =\u003e {\n      return Todo.findByIdAndRemove(id);\n    }\n  }\n};\n```\n\n\n\n# 단계 4: Apollo Client를 통합하여 React와 통합\n\nReact 애플리케이션에 Apollo Client를 통합하고 작업을 표시 및 관리하는 컴포넌트를 만듭니다:\n\n```js\nimport React from 'react';\nimport { useQuery, useMutation, gql } from '@apollo/client';\n\nconst GET_TODOS = gql`\n  query {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nconst ADD_TODO = gql`\n  mutation AddTodo($text: String!) {\n    addTodo(text: $text) {\n      id\n      text\n      completed\n    }\n  }\n`;\n\nfunction Todos() {\n  const { data, loading, error } = useQuery(GET_TODOS);\n  const [addTodo] = useMutation(ADD_TODO);\n\n  if (loading) return \u003cp\u003eLoading...\u003c/p\u003e;\n  if (error) return \u003cp\u003eError :(\u003c/p\u003e;\n\n  const handleAddTodo = async text =\u003e {\n    if (text) {\n      await addTodo({ variables: { text } });\n    }\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cul\u003e\n        {data.todos.map(todo =\u003e (\n          \u003cli key={todo.id}\u003e\n            {todo.text}\n          \u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n      \u003cbutton onClick={() =\u003e handleAddTodo('새 작업 추가')}\u003e작업 추가\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default Todos;\n```\n\n# 단계 5: 사용자 인터페이스 구현\n\n\n\n간단한 사용자 인터페이스를 React로 개발해보세요. 사용자들이 작업을 추가하고 완료된 것으로 표시하거나 작업을 삭제할 수 있게 만들어보세요. 복잡한 양식이나 버튼을 사용하여 작업을 구성할 필요는 없습니다.\n\n위에서 언급된 조치들은 React 애플리케이션과 GraphQL 서버 간에 완전한 통신을 제공하며 데이터베이스로 MongoDB를 사용합니다. 이를 통해 빠르고 효율적으로 작동하는 애플리케이션이 생성됩니다.\n\n# 결론\n\n따라서, 우리는 GraphQL, MongoDB 및 React를 결합하는 방법을 찾았습니다. 이 두 기술의 결합은 웹 애플리케이션의 성능을 실제로 향상시키며 개발 복잡성을 크게 줄일 수 있습니다. 이 기술 스택을 중요시하는 몇 가지 주요 포인트를 살펴봅시다.\n\n\n\n# GraphQL을 사용해야 하는 이유\n\n- 요청한 대로: GraphQL을 사용하면 필요한 데이터만 요청할 수 있어서 불필요한 데이터 없이 작업할 수 있습니다. 이는 더 적은 데이터 전송 및 빠른 페이지 로딩으로 이어집니다.\n- 한 곳을 통해 모두 처리: REST API의 여러 엔드포인트에 작별을 고한다면, GraphQL은 하나의 통합된 지점을 통해 통신하여 코드를 추적 가능하고 아키텍처를 더욱 명료하게 만듭니다.\n- 실시간 업데이트: GraphQL을 사용하면 채팅이나 협업과 같이 데이터가 지속적으로 업데이트되는 기능을 쉽게 구현할 수 있습니다.\n\n\n# GraphQL을 강력하게 만드는 것은 무엇인가요?\n\n- 유연성과 강력함: MongoDB는 데이터 저장을 유연하게 제공하며, 반면에 React는 사용자 인터페이스를 유연하게 구축하는 데 도움을 줍니다. 이 두 가지를 팀으로 사용하면 모든 요구 사항에 손쉽게 조정될 수 있는 좋은 조합이 될 수 있습니다.\n- 개발이 쉬워짐: 이 스택은 GraphQL API의 명확한 규칙 덕분에 코드를 줄이고 개발 단계마다 확신을 키울 수 있도록 도와줍니다.\n\n\n\n# GraphQL과 MongoDB의 성능 영향\n\nGraphQL, React, 그리고 MongoDB가 함께 작동하면 여러분의 일상이 간소화되고 응용 프로그램은 더 빠르게 반응합니다. 쿼리 최적화는 서버 및 네트워크 부하를 줄이고 데이터 처리 속도를 높여 인터페이스를 더 반응적으로 만듭니다. 따라서 사용자들의 눈에 띄게 제품 품질을 향상하는 중요한 요소입니다.\n\n요약하면, 더 강력한 웹 응용 프로그램을 만들고 싶다면 더 빠르고 개발하기 쉬운 웹 응용 프로그램을 만들어야 한다면 GraphQL, MongoDB 및 React의 세트가 반드시 필요합니다. 이것은 분명히 수익성이 입증된 프로젝트의 미래에 대한 장기적인 투자입니다!","ogImage":{"url":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png"},"coverImage":"/assets/img/2024-05-14-GraphQLandMongoDBwithReact_0.png","tag":["Tech"],"readingTime":13}],"page":"54","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"54"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>