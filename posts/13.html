<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/13" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/13" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 웹사이트 성능 향상 시키는 방법" href="/post/2024-05-18-performanceinreact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-performanceinreact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 웹사이트 성능 향상 시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 웹사이트 성능 향상 시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Axios, Fetch, Express 깊이 알아보기" href="/post/2024-05-18-ADeepDiveintoAxiosFetchandExpress"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Axios, Fetch, Express 깊이 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Axios, Fetch, Express 깊이 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NinjaCart SDE 2 프론트엔드 인터뷰 경험" href="/post/2024-05-18-NinjaCartSDE2frontendInterviewExp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NinjaCart SDE 2 프론트엔드 인터뷰 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NinjaCart SDE 2 프론트엔드 인터뷰 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬과 언더스코어 (_)" href="/post/2024-05-18-Pythonandtheunderscore_"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬과 언더스코어 (_)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Pythonandtheunderscore__0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬과 언더스코어 (_)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬과 언더스코어 (_)</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인공지능으로 감정 분석 성능 높이기" href="/post/2024-05-18-ElevatingSentimentAnalysis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인공지능으로 감정 분석 성능 높이기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인공지능으로 감정 분석 성능 높이기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">인공지능으로 감정 분석 성능 높이기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" href="/post/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" href="/post/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RaspirriV1로 라즈베리 파이 기반의 자동 급수기 만들기" href="/post/2024-05-18-RaspirriV1ARaspberryPibasedirrigator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RaspirriV1로 라즈베리 파이 기반의 자동 급수기 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RaspirriV1로 라즈베리 파이 기반의 자동 급수기 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">RaspirriV1로 라즈베리 파이 기반의 자동 급수기 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="REST 엔드포인트를 데이터 소스로 사용하는 GraphQL 쿼리 작성하기" href="/post/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="REST 엔드포인트를 데이터 소스로 사용하는 GraphQL 쿼리 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="REST 엔드포인트를 데이터 소스로 사용하는 GraphQL 쿼리 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">REST 엔드포인트를 데이터 소스로 사용하는 GraphQL 쿼리 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 제대로 알고 사용하는 방법" href="/post/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 제대로 알고 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 제대로 알고 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 제대로 알고 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link posts_-active__YVJEi" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 웹사이트 성능 향상 시키는 방법","description":"","date":"2024-05-18 21:42","slug":"2024-05-18-performanceinreact","content":"\n\n현대 웹 애플리케이션을 개발할 때 최적의 성능을 달성하는 것이 중요합니다. ReactJS는 개발자가 빠르고 반응이 뛰어나며 효율적인 애플리케이션을 만들 수 있도록 도와주는 강력한 도구와 기술을 제공하지만, 이들을 어떻게 사용해야 하는지 알아야 합니다! 이 글에서는 ReactJS에서 성능을 극대화하기 위한 주요 원칙을 탐구하며, 재렌더링을 최소화하고 DOM과 가상 DOM 간의 차이를 이해하며 불변성을 활용하고 메모이제이션을 구현하는 것에 초점을 맞출 것입니다.\n\n![Image](/assets/img/2024-05-18-performanceinreact_0.png)\n\nReact의 성능 최적화의 핵심은 재렌더링을 최소화하는 원칙에 있습니다. 컴포넌트가 재렌더링될 때마다 React는 변경 사항을 조화하고 DOM을 적절히 업데이트해야 합니다. 불필요한 재렌더링을 줄이면 애플리케이션 속도가 향상되는 것뿐만 아니라, 사용자 경험도 부드럽고 반응성 있게 유지할 수 있습니다. 그러나 이를 실현하기 위해서는 상태 관리, 컴포넌트 디자인 및 라이프사이클 메서드에서 모베스트 프랙티스를 이해하고 적용해야 합니다.\n\n# DOM vs. 가상 DOM 🌐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDOM 및 가상 DOM과 같은 개념이 성능과 연관이 있는 이유는 React와 같은 프레임워크가 사용자 인터페이스 업데이트를 다루는 방식 때문입니다. 문서 객체 모델(DOM)은 웹 문서를 프로그래밍적으로 다루는 인터페이스로, 웹페이지의 구조를 객체 트리로 표현합니다. 이 트리의 각 노드는 요소, 속성, 텍스트 컨텐츠와 같은 문서의 부분을 나타냅니다. 이것은 기본적으로 브라우저가 HTML 코드를 이해하는 방식입니다:\n\n![Performance in React](/assets/img/2024-05-18-performanceinreact_1.png)\n\n각 재렌더링은 React가 변경 사항을 조율하고 DOM을 업데이트해야 하므로 연산 부하가 발생할 수 있습니다. DOM의 변경마다 브라우저가 스타일을 다시 계산하고 레이아웃을 재구성하며 페이지를 다시 그리게 됩니다. 이는 퍼포먼스에 상당한 영향을 미칠 수 있으며 특히 업데이트가 빈번하고 DOM 트리의 큰 부분을 포함할 때 그 영향이 커집니다.\n\n하지만 React는 어떻게 이를 효율적으로 처리할까요?\nReact는 실제 DOM의 추상화인 가상 DOM을 생성합니다. 이는 React가 메모리에 유지하는 DOM의 가벼운 사본입니다. React 컴포넌트의 상태가 변경되면 React는 먼저 가상 DOM을 업데이트합니다. 그런 다음에 실제 DOM을 새로운 가상 DOM 상태와 일치하도록 업데이트해야 하는 최소한의 변경 세트를 효율적으로 결정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 말은 React가 모든 상태 변경에 대해 즉시 DOM을 업데이트하는 대신 변경 사항을 수집하고 한 번에 DOM을 업데이트한다는 것을 의미합니다. 이로써 DOM에 액세스하고 수정하는 횟수가 감소하여 성능이 향상됩니다. 이 프로세스를 reconciliation이라고 합니다.\n\n# 성능 최적화 📈\n\n성능에 대해 논의할수록, 프레임워크의 핵심 원칙에 대해 깊게 이야기하며 데이터와 계산을 효율적으로 처리하는 방식에 영향을 미치는 것에 대해 말하게 됩니다. React에서 두 가지 원칙인 불변성과 메모이제이션은 모두 성능을 향상시키는 데 중요한 역할을 합니다.\n\n## 불변성🔒\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불변성은 데이터 구조를 생성한 후에 수정하지 않는 실천 방식을 의미합니다. 대신, 모든 수정은 새로운 데이터 구조를 생성합니다. 이 개념은 React에서 아래와 같은 이유로 중요합니다:\n\n- 예측 가능한 상태 변경: 상태가 불변성을 갖추면 변경 사항이 예측 가능하고 추적 가능해져서 코드의 디버깅과 이해가 간소화됩니다.\n- 효율적인 다시 렌더링: React는 이전 상태나 프롭을 현재 상태나 프롭과 비교하여 컴포넌트를 다시 렌더링해야 하는지 빠르게 판단할 수 있습니다. 참조가 다를 경우 React는 변경이 발생했음을 알 수 있습니다. 이 비교는 불변성 데이터 구조를 사용하여 빠르고 효율적입니다.\n- 부작용 회피: 불변성은 공유된 가변 상태로 인한 의도하지 않은 부작용을 방지하여 더 신뢰성이 있고 유지보수가 용이한 코드를 만들어냅니다.\n\n하지만 React와 JavaScript는 어떻게 불변성을 활용하여 더 빠르게 렌더링할 수 있을까요?\n\n앞에서 언급했듯이 불변 데이터를 사용하면 React의 diffing 알고리즘이 애플리케이션의 상태 변화를 더 효율적으로 추적할 수 있습니다. 왜냐하면 객체 참조를 간단히 비교함으로써 각 객체의 속성을 깊게 비교할 필요가 없기 때문입니다. JavaScript는 객체 포인터가 다른 메모리 위치에 있는지 확인함으로써 모든 키를 확인하지 않고도 차이점을 확인할 수 있습니다. 이렇게 하면 훨씬 빨라집니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션 🧠\n\n한편, 메모이제이션은 결과를 캐싱하고 같은 입력이 다시 발생할 때 재사용하여 비싼 계산을 최적화하는 데 도움이 됩니다. React에서 memoization은 useMemo 및 useCallback과 같은 훅을 통해 구현될 수 있습니다. 이러한 훅은 값과 함수를 메모이즈하여 불필요한 다시 랜더링과 계산을 막아주는데 도움을 줍니다. 만약 ReactJS 코드를 작성한 적이 있다면 아마 이에 대해 알고 있어야 할 것입니다.\n\n하지만 중요한 것은 메모이제이션과 불변성을 따로 생각하지 않는 것입니다. 이 둘은 밀접한 관련이 있으며 종종 함께 사용하여 성능을 최적화합니다. 이들의 관계를 이해하면 개발자가 더 효율적이고 유지보수가 쉬운 코드를 작성하는 데 도움이 됩니다.\n\n![React 성능 개선 이미지](/assets/img/2024-05-18-performanceinreact_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메모이제이션과 불변성의 관계 🔗\n\n리액트에서 성능 최적화의 맥락에서 메모이제이션과 불변성은 밀접한 관련이 있습니다. 불변성은 안정적인 기반을 제공하여 메모이제이션을 더 효율적이고 신뢰할 수 있도록 만드는데 기여합니다. 다음과 같은 이유로 상태 변화가 예측 가능하고 의존성 추적을 단순화시킵니다:\n\n- 캐시 로직 단순화: 불변 데이터로 인해 메모이제이션 함수의 캐싱 로직이 더 간단해집니다. 데이터가 변할 수 없기 때문에 캐시는 데이터 변화로 인한 무효화를 처리할 필요가 없어져 더 직접적이고 신뢰할 수 있는 메모이제이션이 가능해집니다.\n- 부작용 회피: 불변 데이터 구조는 공유된 가변 상태에 의한 부작용을 피하는 데 도움이 됩니다. 이는 메모이제이션 함수가 더 안전하고 예측 가능하게 만들어줍니다. 예상치 못한 변경이 없는 입력값에 의존하기 때문입니다.\n- 참조 동등성: 불변성은 데이터 구조들을 참조 동등성을 통해 간단하고 효율적으로 비교할 수 있게 해줍니다 (즉, 두 참조가 동일한 객체를 가리키는지 확인). 이는 메모이제이션에 핵심적인데, 빠르고 효율적인 캐시 조회를 가능하게 합니다. 메모이제이션 함수의 입력이 불변성을 가진다면 함수는 입력값이 변경되었는지 쉽게 참조를 비교함으로써 판단할 수 있습니다.\n\n데이터가 불변하면 메모이제이션 함수나 컴포넌트의 의존성이 안정적으로 유지됩니다. 이 안정성은 메모이제이션 값을 또는 콜백을 필요한 경우에만 다시 계산함으로써 불필요한 계산과 새로고침을 피할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-performanceinreact_3.png) \n\n# 결론 📢\n\n이전에 이야기한 대로, 성능에 대해 더 깊이 이야기할수록, 프레임워크의 핵심 원칙에 대해 더 많이 이야기하게 됩니다. React 애플리케이션은 Virtual DOM의 효율적인 차이점 및 업데이팅 기능을 활용하고, 불변 데이터 구조 및 메모이제이션된 계산을 보완하여 번개처럼 빠른 렌더링 및 부드러운 사용자 경험을 달성할 수 있습니다.\n\nReact 핵심 개념을 조화롭게 통합함으로써, 개발자들은 응답성이 뛰어나고 성능이 우수한 사용자 경험을 제공하여 응용 프로그램의 최대 잠재력을 발휘할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음… 그것이 다야!\n내 LinkedIn에 연락해 보고 메시지를 보내주세요. 멋진 경험이 될 거에요!\n\n고마워요!! 👋👋","ogImage":{"url":"/assets/img/2024-05-18-performanceinreact_0.png"},"coverImage":"/assets/img/2024-05-18-performanceinreact_0.png","tag":["Tech"],"readingTime":5},{"title":"Axios, Fetch, Express 깊이 알아보기","description":"","date":"2024-05-18 21:41","slug":"2024-05-18-ADeepDiveintoAxiosFetchandExpress","content":"\n\n웹 개발 분야에서, 작업에 적합한 도구를 선택하는 것이 생산성과 애플리케이션의 효율에 상당한 영향을 미칠 수 있습니다. 오늘은 Axios, Fetch 및 Express라는 세 가지 중요한 기술에 대해 자세히 살펴볼 것입니다. 프론트 엔드, 백 엔드 또는 둘 다를 개발 중이더라도 이러한 도구를 이해하는 것은 개발 기술을 향상시킬 수 있습니다. 함께 알아보겠습니다!\n\n# Axios vs. Fetch vs. Express: 어떤 것을 사용해야 할까요?\n\n# 소개\n\n웹 개발자로서, HTTP 요청을 보내고 강력한 서버 측 애플리케이션을 구축하는 작업에 자주 직면하게 됩니다. Axios, Fetch 및 Express는 이러한 목표를 달성하는 데 도움이 되는 세 가지 주요 기술입니다. 그러나 이들은 각각 다른 목적을 가지고 있습니다. 이 포괄적인 안내서에서 각 도구의 특징, 작동 방식 및 사용 시기에 대해 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Axios란 무엇인가요?\n\nAxios는 브라우저와 Node.js 환경에서 HTTP 요청을 보내는 데 사용되는 인기 있는 JavaScript 라이브러리입니다. Promise를 기반으로 하고 있어 비동기 작업을 간편하게 처리할 수 있습니다. Axios는 간단함과 강력한 기능으로 개발자 커뮤니티에서 사랑받고 있습니다.\n\n# Axios의 주요 기능:\n\n- Promise 기반 API: 비동기 요청 처리를 간편하게 합니다.\n- Interceptors: 요청이나 응답을 처리하기 전에 수정할 수 있습니다.\n- 자동 JSON 파싱: JSON 데이터를 자동으로 처리합니다.\n- 넓은 호환성: 오래된 브라우저와 Node.js에서 작동합니다.\n- 편리한 메소드: HTTP 요청을 위한 간소화된 메소드를 제공합니다 (예: axios.get, axios.post).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법:\n\nAxios를 사용하여 API에서 데이터를 가져오는 간단한 예제가 여기 있어요.\n\n```js\naxios.get('https://api.example.com/data')\n  .then(response =\u003e {\n    console.log(response.data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  });\n```\n\n# 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Fetch가 무엇인가요?\n\nFetch는 XMLHttpRequest에 대한 더 현대적이고 유연한 대안을 제공하는 내장 JavaScript API입니다. 대부분의 최신 브라우저에서 사용할 수 있으며 promise를 반환하여 네이티브 솔루션을 선호하는 많은 개발자들에게 인기가 있습니다.\n\n# Fetch의 주요 기능:\n\n- 네이티브 API: 추가 라이브러리가 필요하지 않습니다.\n- Promise 기반: 현대적인 JavaScript와 매끄럽게 통합됩니다.\n- 간소화된 구문: XMLHttpRequest보다 더 간결하고 가독성이 좋습니다.\n- 수동 JSON 처리: JSON 응답을 수동으로 구문 분석해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 사용법\n\nFetch를 사용하여 API 요청을 하는 방법을 보여드리겠습니다:\n\n```js\nfetch('https://api.example.com/data')\n  .then(response =\u003e response.json())\n  .then(data =\u003e {\n    console.log(data);\n  })\n  .catch(error =\u003e {\n    console.error('데이터를 가져오는 중 오류가 발생했습니다:', error);\n  });\n```\n\n# 익스프레스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Express란 무엇인가요?\n\nExpress는 웹 및 모바일 애플리케이션을 개발하기 위한 강력한 기능 세트를 제공하는 최소한의 유연성을 갖춘 Node.js 웹 애플리케이션 프레임워크입니다. 그 간결함과 확장성으로 인해 API 및 서버 측 응용 프로그램을 만드는 데 널리 사용됩니다.\n\n# Express의 주요 기능:\n\n- 미들웨어 지원: 요청을 처리하는 함수를 쉽게 추가할 수 있습니다.\n- 라우팅: 다양한 HTTP 메소드와 URL 패턴을 처리하기 위한 강력한 라우팅 기능.\n- 확장성: 다양한 플러그인 및 모듈의 큰 생태계.\n- 확장성: 확장 가능한 어플리케이션을 구축하는 데 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제 사용법:\n\n다음은 Express 서버를 설정하는 기본적인 예제입니다:\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/data', (req, res) =\u003e {\n  res.json({ message: '안녕, 세상아!' });\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000 포트에서 실행 중입니다');\n});\n```\n\n# 이 비교가 중요한 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAxios, Fetch 및 Express 간의 차이를 이해하는 것은 여러 가지 이유로 중요합니다:\n\n- 정보 있는 결정: 특정 시나리오에서 어떤 도구를 사용해야 하는지를 알면 효율성과 효과성이 향상됩니다.\n- 코드 품질 향상: 작업에 적합한 적절한 도구를 사용하면 보다 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 더 나은 디버깅: 이러한 도구에 익숙해지면 문제 해결과 디버깅을 더 효과적으로 수행할 수 있습니다.\n- 생산성 향상: 적절한 도구로 개발 프로세스를 최적화하면 시간을 절약하고 복잡성을 줄일 수 있습니다.\n\n# Axios vs. Fetch: 언제 사용해야 할까요?\n\nAxios를 사용하세요 만약:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 요청/응답 인터셉터와 같은 기능이 필요합니다.\n- 자동 JSON 파싱을 선호합니다.\n- Node.js 및 오래된 브라우저와 같은 다른 환경에서 보다 넓은 호환성이 필요합니다.\n\nFetch를 사용하실 때:\n\n- 추가 라이브러리 없이 네이티브 솔루션을 선호합니다.\n- 모던 브라우저에서 작업 중이십니다.\n- 요청 및 응답 처리에 대한 더 많은 제어를 원합니다.\n\n# Express를 사용해야 하는 경우?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Express를 사용하면:\n  - 서버 측 애플리케이션이나 API를 구축 중일 때.\n  - 견고한 라우팅 및 미들웨어 지원이 필요할 때.\n  - Node.js 생태계 내에서 작업하며 유연하고 확장 가능한 프레임워크가 필요할 때.\n\n# 결론\n\n웹 개발 작업에 적합한 도구를 선택하는 것은 효율적이고 확장 가능하며 유지보수가 쉬운 애플리케이션을 만드는 데 중요합니다. Axios와 Fetch는 각자의 장점을 가지고 있어 클라이언트 측에서 HTTP 요청을 처리하는 데 탁월한 선택지입니다. 반면 Express는 서버 측 애플리케이션과 API를 구축하는 데 강력한 프레임워크입니다.\n\n이 상세한 비교가 여러분이 이 도구들을 언제, 어떻게 효과적으로 사용해야 하는지 이해하게 도와드리기를 바랍니다. Axios, Fetch, 그리고 Express를 숙달함으로써 여러분은 다양한 웹 개발 과제에 대처할 수 있는 역량을 갖추게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 댓글에 생각을 공유하거나 궁금한 점을 질문해 주세요.\n\n만약 이 글이 도움이 되었다면 박수를 보내고 동료 개발자들과 공유해주세요. 앞으로 더 많은 웹 개발 통찰과 튜토리얼이 기대되니 기대해 주세요!\n\nAditya Singh.","ogImage":{"url":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png"},"coverImage":"/assets/img/2024-05-18-ADeepDiveintoAxiosFetchandExpress_0.png","tag":["Tech"],"readingTime":4},{"title":"NinjaCart SDE 2 프론트엔드 인터뷰 경험","description":"","date":"2024-05-18 21:40","slug":"2024-05-18-NinjaCartSDE2frontendInterviewExp","content":"\n\n친구로부터 닌자카트 인재영입 담당자의 전화번호를 받았어요\n\n# 면접 1 — 기본 JS 이해\n\n1번 질문 — 디바운싱과 쓰로틀링에 관련된 질문입니다. 이 두 기술의 차이 및 실제 적용법을 말해주세요.\n\n2번 질문 — 프로미스와 setTimeout을 활용한 출력 관련 질문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(1);\n\nsetTimeout(function () {\n    console.log(2);\n}, 0);\n\nPromise.resolve()\n    .then(function () {\n        console.log(3);\n    })\n    .then(function () {\n        console.log(4);\n    });\n```\n\n3번 문제 — 클로저 및 setTimeout을 기반으로 한 출력 문제\n\n```js\nfor (var index = 1; index \u003c= 3; index++) {\n    setTimeout(function () {\n        console.log('after ' + index + ' second(s):' + index);\n    }, index * 1000);\n}\n```\n\n4번 문제 — 중첩된 배열을 평평하게 만드는 함수를 작성하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5번 질문 — useEffect와 useMemo를 기반으로 함\n\n# 2차 인터뷰 — 머신 코딩 및 문제 해결\n\n1번 질문 — 사용자 정의 React 탭 컴포넌트 만들기\n해결책\n\n2번 질문 — 실패하면 프라미스를 다시 시도하는 함수 만들기 (질문 링크)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3차 면접 — 매니저 면접\n\n매니저는 하르야나 출신이셔서 저희는 그냥 평범한 대화를 나눴어요 (아버지의 친구와 얘기하는 느낌이었어요 😂)","ogImage":{"url":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png"},"coverImage":"/assets/img/2024-05-18-NinjaCartSDE2frontendInterviewExp_0.png","tag":["Tech"],"readingTime":1},{"title":"파이썬과 언더스코어 (_)","description":"","date":"2024-05-18 21:38","slug":"2024-05-18-Pythonandtheunderscore_","content":"\n\n## 파이썬 프로그래밍\n\n![Python Programming](/assets/img/2024-05-18-Pythonandtheunderscore__0.png)\n\n밑줄 문자인 _는 파이썬 프로그래밍에서 중요한 역할을 하는 경우가 많습니다. 모든 파이썬 개발자는 이 다재다능한 특성을 이해하고 코딩에서 어떻게 효과적으로 밑줄을 활용할지 알아야 합니다. 가독성을 향상시키고 비공개 속성을 관리하는데부터 데이터 처리와 국제화에서 특정 기능을 활용하는 데까지, 밑줄은 단순한 문자가 아니라 파이썬 구문에서 가장 중요한 문자 중 하나로, 파이썬 언어에서 근본적인 도구입니다.\n\n이 기사에서는 파이썬에서 밑줄의 다양한 역할을 분석하며, _이 파이썬 언어에서 필수적인 문자가 되도록 하는 일반적이고 특수한 사용 사례를 살펴보겠습니다. 초보자든 숙련된 프로그래머든 밑줄의 용도를 이해하면 코딩 기술을 획기적으로 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 밑줄 사용 사례\n\n## 명명\n\n밑줄의 가장 일반적이고 중요한 사용 사례는 아마도 명명일 것입니다. PEP 8에 따르면,\n\n따라서 밑줄은 함수와 변수 이름에서 단어를 구분하는 데 사용됩니다. 동일한 관례는 메서드 이름과 클래스 인스턴스 변수에도 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 관용적인 네이밍 규칙이야. 다양한 프로그래밍 언어에서 사용되는 가장 중요한 네이밍 규칙은 다음과 같아:\n\n- 카멜 케이스 (myVariableName): 첫 번째 단어는 소문자로, 다음 단어의 첫 글자는 대문자로 쓰는 방식. 사용되는 언어: JavaScript, Java, C#, Swift.\n- 파스칼 케이스 (MyVariableName): 각 단어의 첫 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(클래스 이름으로), C#, Pascal, Java, C++.\n- 스네이크 케이스 (my_variable_name): 단어는 소문자로 쓰고 밑줄로 구분하는 방식. 사용되는 언어: Python(변수와 함수 이름으로), Ruby.\n- 대문자 스네이크 케이스 (MY_VARIABLE_NAME): 단어들을 밑줄로 구분하고 모든 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(상수로), C, C++, Java.\n- 케밥 케이스 (my-variable-name): 단어는 소문자로 쓰고 하이픈으로 구분하는 방식. 사용되는 곳: URL 및 CSS 클래스 이름.\n- 헝가리안 표기법 (iCount, strName): 변수 이름에 타입이나 범위를 나타내는 접두사를 사용하는 방식. 사용되는 곳: 오래된 C 및 C++ 코드.\n\n밑줄을 사용하는 파이썬 변수명의 예시는 다음과 같아:\n\n```python\nwrite_to_database()\nread_data()\n\ndf_history\ndf_actual\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서 밑줄은 또다른 역할을 해요. PEP 8에 따르면, 예약된 이름과 충돌하는 이름(예: 인수 이름)을 만들어야 한다면, 이름 끝에 밑줄을 추가할 수 있어요.\n\n흔한 사용 예로는 class_와 type_이 있어요.\n\n밑줄은 상수의 이름에도 사용돼요. 다시 한 번 PEP 8에 따르면:\n\n아래는 상수 이름의 예시 세 가지예요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nNO_OF_DAYS\nSIGNIF_LEVEL\nRUN_DEBUGGER\n```\n\n알다시피 밑줄은 Python에서 사용되는 다양한 역할을 합니다. 몇 가지는 다른 것보다 더 중요하지만 — 중요한 점은 Python에서 사용되는 몇 가지 명명 규칙이 밑줄에 매우 의존한다는 것입니다.\n\n그러나 Python 클래스는 일반적으로 밑줄을 사용하지 않습니다. 따라서 book_publisher처럼 클래스를 이름 짓지 않을 것입니다. BookPublisher로 짓겠죠. list나 dict와 같이 잘 알려진 예외가 있긴 하지만, 여러분이 직접 이러한 예외를 만들어서는 안 된다는 뜻입니다.\n\n## Dunder (double underscore, or magic) methods\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 역할은 명명과 관련이 있지만, 여기서는 파이썬 언어의 내부 이름에 대해 이야기합니다. 말하는 것은 이른바 매직 메서드의 이름에 많은 언더스코어가 있는 것을 볼 수 있습니다. 이들은 더블 언더스코어(__)로 시작하고 끝나는 특수 메서드들입니다. 더블 언더스코어를 사용하기 때문에 이러한 메서드들은 때로 \"던더\" 메서드라고도 불립니다 — 던더란 더블 언더스코어의 줄임말입니다.\n\n던더 메서드들은 다양한 파이썬 언어 기능과 구문에서 사용됩니다. 이들의 이름에 있는 더블 언더스코어는 이 메서드들이 특별하다는 것을 나타내는 것이 중요합니다. 이 명명 규칙은 사용자 정의 메서드가 내장 (매직) 메서드를 덮어쓰는 것을 방지합니다.\n\n다음은 파이썬에서 던더 메서드의 몇 가지 예시입니다:\n\n- __init__: 클래스 인스턴스를 생성하는 역할을 합니다.\n- __str__: 객체에 사용되는 str() 및 print() 함수의 동작을 정의합니다; 더 자세한 내용은 이 기사를 참조하세요.\n- __len__: 컨테이너의 길이를 반환합니다.\n- __getitem__: 인덱싱을 허용하고 정의합니다.\n- __add__, __mul__ 등: 객체가 산술 연산을 지원하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의해야 할 점은 던더 메소드를 직접 사용해서는 안 되며, 대신 파이썬 인터프리터가 다양한 작업을 실행하는 중에 호출됩니다. 예를 들어, len(x)를 호출하면 파이썬 내부적으로 x.__len__()을 호출합니다. 후자를 사용해서는 안 되지만, 정상적으로 작동합니다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 3]\n\u003e\u003e\u003e len(x)\n3\n\u003e\u003e\u003e x.__len__()\n3\n```\n\n새로운 사용자 정의 던더 메서드를 정의하지 않는 것이 좋은 습관입니다. 기존 마법 메서드를 덮어쓰거나 사용자 정의 클래스에서 정의하는 것은 괜찮습니다.\n\n## 특수 속성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더블 언더스코어로 시작하고 끝나는 메서드를 매직 또는 던더라고 부르지만, 이 네이밍 규칙을 따르는 속성은 일반적으로 특별 속성이라고 불립니다. 파이썬에 의해 자동으로 생성되고 관리되는 이러한 속성들은 객체에 관한 정보를 제공합니다. 몇 가지 예시를 확인해봅시다:\n\n- __name__: 모듈, 클래스, 클래스 메서드 및 함수에서 사용됩니다. (재미있게도, functools.partial을 사용하여 작성된 부분 함수는 이 속성이 없습니다) 객체의 이름을 유지하는 데 사용됩니다.\n- __doc__: 모듈, 클래스, 메서드 또는 함수의 독스트링을 보존합니다.\n- __file__: 모듈이 로드된 파일의 경로를 저장하는 데 사용됩니다.\n\n## 더미 변수\n\n밑줄은 더미 변수로 사용되는 빈번한 용도로 사용됩니다. 이것은 현재 코드에서 사용되지 않는 변수를 나타내는 이름으로 밑줄을 사용한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이런 것은 종종 루프에서 사용되는데, 루핑 변수를 사용하지 않을 때입니다. 다음 상황을 비교해보세요:\n\n루핑 변수를 사용하는 경우:\n\n```js\n\u003e\u003e\u003e for i in range(1, 4):\n...     print(f\"number {i}\")\n1\n2\n3\n```\n\n루핑 변수를 사용하지 않는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e for _ in range(3):\n...     print(\"주마 주마\")\n주마 주마\n주마 주마\n주마 주마\n```\n\n또한, 객체를 반환하는 함수나 메서드에서 해당 객체를 사용하지 않을 때 밑줄을 사용하는 것이 좋은 습관입니다. 예를 들어 여기서처럼:\n\n```js\ndef save(obj: Any, path: pathlib.Path) -\u003e bool:\n    # 객체가 성공 여부에 관계없이 저장됩니다.\n    if not success:\n        return False\n    return True\n\n_ = save(obj, pathlib.Path(\"file.csv\")\n```\n\n여기서는 save()의 출력을 _에 할당했는데, 이는 코드에서 이 출력을 사용할 필요가 없기 때문입니다. 만약 사용해야 한다면, 다음과 같이 하게 됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n저장된 = save(obj, pathlib.Path(\"file.csv\")\n```\n\n자주 볼 수 있는 대안은 – 내 생각에는 나쁜 – 사용법이 있습니다. 여기서는 출력이 무시됩니다:\n\n```js\nsave(obj, pathlib.Path(\"file.csv\")\n```\n\n이 접근 방식이 마음에 들지 않는 이유는 save() 함수가 아무것도 반환하지 않는 것처럼 보이기 때문입니다. 함수의 출력을 무시하는 경우는 항상 None을 반환할 때뿐이라고 생각합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프라이빗 메소드 및 속성 표시\n\nPython에는 OOP에서 진정한 은행 메소드나 속성이 없습니다. 이에 대해 여기에서 읽을 수 있습니다:\n\n그럼에도 불구하고 사용자에게 클래스 메소드나 속성 중 어떤 것을 프라이빗으로 유지하길 원하는지를 알리는 데 언더바(_)를 단일(_) 또는 이중(__)으로 이름 앞에 두고 표시할 수 있습니다. 차이점을 배우려면 위의 기사를 읽어보세요. 이렇게 하면 사용자에게 클래스 외부에서 이러한 메소드나 속성을 사용하지 말아야 한다고 알리는 것과 같습니다. 사용자는 어쨌든 할 수 있지만, 그들에게는 이를 하지 말아야 한다고 알려졌습니다.\n\n다음과 같은 클래스를 고려해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nclass Me:\n    def __init__(self, name, smile=\":-D\"):\n        self.name = name\n        self.smile = smile\n        self._thoughts = []\n\n    def say(self, what):\n        return str(what)\n\n    def _think(self, what):\n        self._thoughts += what\n```\n\n우리에게는 나를 나타내는 Me 클래스가 있어요. 다음과 같이 나 자신을 만들 수 있어요:\n\n- .name, public 속성 → 당신의 이름은 분명히 공개적이에요\n- .smile, public 속성 → 당신의 미소는 외부에서 보여지기 때문에 분명히 공개적이에요\n- ._thoughts, private 속성 → 당신의 생각은 확실하게 비공개적이죠?\n\n두 개의 public 속성은 언더스코어 없이 이름이 지어지고, 유일한 private 속성은 이름이 언더스코어로 시작해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 메서드들을 살펴보겠습니다:\n\n- .say(), 공개 메서드 → 무언가를 말할 때, 사람들이 듣을 수 있습니다.\n- ._think(), 비공개 메서드 → 무언가를 생각할 때, 그것은 개인적인 생각입니다. 만약 크게 말하고 싶다면 공개 .say() 메서드를 사용해야 하지만, 생각을 자신에게 간직하고 싶다면 비공개 _think() 메서드를 사용해야 합니다.\n\n비밀 생각을 대대로 말할 수 있는 공개 메서드를 만들 수 있습니다:\n\n```js\ndef say_thought(self, which):\n    return self._thoughts[which]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 대화형 세션에서의 마지막 작업\n\nPython 3에서 밑줄은 대화형 세션에서의 마지막 작업 결과를 저장하는데 사용됩니다. 이것은 이전 계산이 이름에 할당되지 않았을 때 새로운 작업에서 이전 작업의 결과를 빠르게 사용하는 데 유용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e 1 + 2\n3\n\u003e\u003e\u003e _ * 3\n9\n\u003e\u003e\u003e y = 10\n\u003e\u003e\u003e _\n9\n\u003e\u003e\u003e 100\n\u003e\u003e\u003e _\n100\n```\n\n보시다시피 밑줄은 이름에 할당되지 않은 마지막 작업의 결과만 유지하며, 그것이 계산이 아닌 객체일 경우에도(위 코드 블록의 100처럼) 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 숫자 값 형식 지정\n\nPython 3.6에서는 밑줄을 사용하여 대형 숫자 값을 더 쉽게 읽을 수 있게 하는 기능이 추가되었습니다. 이 기능은 대형 정수에 특히 유용하지만 부동 소수점 수에도 적용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e x = 1_000_000\n\u003e\u003e\u003e x\n1000000\n\u003e\u003e\u003e 1.009_232_112\n1.009232112\n\u003e\u003e\u003e 1_021_232.198_231_111  \n1021232.198231111\n```\n\n보통 대형 정수에 많이 사용되지만 밑줄은 소수값의 가독성을 향상시키는 데도 도움이 됩니다. 이러한 방식은 덜 사용되지만 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## functools.singledispatch 사용 사례\n\nfunctools.singledispatch에서 밑줄(_)은 특정 타입을 처리하기 위한 익명 구현을 나타내기 위해 함수 이름으로 흔히 사용됩니다. 이 스타일 선택은 함수의 이름이 중요하지 않으며, 오히려 함수가 처리하는 타입이 중요하다는 것을 시사합니다. 이 사용법은 네임스페이스를 깨끗하게 유지하는 데 도움이 되며, 로직이 직접 호출을 위한 것이 아니라 singledispatch 메커니즘에 직접 연결되어 있음을 강조합니다. 다음은 PEP 443에서의 예시입니다:\n\n```js\n\u003e\u003e\u003e from functools import singledispatch\n\u003e\u003e\u003e @singledispatch\n... def fun(arg, verbose=False):\n...     if verbose:\n...         print(\"Let me just say,\", end=\" \")\n...     print(arg)\n\u003e\u003e\u003e @fun.register(int)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Strength in numbers, eh?\", end=\" \")\n...     print(arg)\n...\n\u003e\u003e\u003e @fun.register(list)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Enumerate this:\")\n...     for i, elem in enumerate(arg):\n...         print(i, elem)\n```\n\n이 설정에서 _는 해당 타입에 대한 동작을 구현하여 사용되지 않는 함수 이름으로 네임스페이스를 혼란스럽게 만들지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에 MyPy와 같은 정적 체커를 사용하려면, _를 여러 번 정의하고 있다는 오류가 발생할 수 있다는 점을 알아두세요. 이 문제의 가장 간단한 해결책은 _가 정의된 줄 끝에 # type: ignore 주석을 추가하는 것입니다. 또 다른 방법으로는 현재 _로 호출되는 이러한 함수들을 _로 명명하는 것이 있습니다. 이는 functools.singledispatch에 대한 일반적이지 않은 접근법일 수 있습니다.\n\n## 국제화와 지역화\n\n국제화(일반적으로 i18n으로 약어)와 지역화(약어로 l10n)는 응용프로그램을 다른 언어와 지역에 적응 가능하게 만들어줍니다. 국제화를 통해 응용프로그램은 코드를 수정하지 않고도 다양한 언어와 지역에 적응할 수 있습니다. 반면에 지역화는 국제화된 소프트웨어를 특정 지역이나 언어에 맞게 적응시키는 데 도움을 줍니다. 이는 로케일별 구성 요소 추가 및 텍스트 번역을 통해 이루어집니다.\n\nPython에서는 gettext 모듈을 사용하여 이러한 두 가지 프로세스를 수행할 수 있습니다. 이를 통해 응용프로그램이 여러 언어를 지원할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngettext에서는 번역할 문자열을 표시하는 gettext 함수에 대한 별명으로 밑줄(_)을 사용하는 것이 일반적입니다:\n\n```js\n\u003e\u003e\u003e import gettext\n\u003e\u003e\u003e import locale\n\n로캘을 폴란드어로 설정:\n\u003e\u003e\u003e locale.setlocale(locale.LC_ALL, \"pl_PL\")\n\n.mo 번역 파일의 경로를 설정하고 텍스트 도메인을 선택:\n\u003e\u003e\u003e gettext.bindtextdomain(\n...     \"myapp\",\n...     \"/path/to/my/locale/directory\"\n... )\n\u003e\u003e\u003e gettext.textdomain(\"myapp\")\n\n밑줄은 일반적으로 gettext.gettext의 별명으로 사용됩니다:\n\u003e\u003e\u003e _ = gettext.gettext\n\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n여기서 _()은 번역할 텍스트를 감싸 줍니다. 번역이 있는 로캘에서 실행되면 gettext.gettext() 및 따라서 _()가 번역된 문자열을 가져옵니다. 밑줄을 사용하는 것은 단순히 더 간단합니다; 비교해 보세요:\n\n```js\n\u003e\u003e\u003e gettext.gettext(\"Hello, World!\")\nWitaj, świecie!\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특히 앱이 gettext.gettext 또는 _을 광범위하게 사용하는 경우에 유용합니다.\n\n## 언패킹 시 값을 무시하는 방법\n\n파이썬에서는 시퀀스를 언패킹할 때 불필요한 값을 무시하기 위해 언더스코어(_)를 사용할 수 있습니다. 이렇게 하면 코드가 더 깔끔하고 가독성이 높아지며, 코드에서 전혀 사용되지 않는 변수를 정의하지 않아도 됩니다.\n\n따라서 이해할 필요가 없는 값들을 언더스코어(_)에 할당하여 일회용 변수로 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e a, _, b = (1, 2, 3)\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n3\n```\n\n여기서는 _ 가 중간 값을 무시하는 데 사용되었습니다 (2).\n\n여러 값이 무시해야 하는 경우, 특히 더 긴 시퀀스의 경우에는 *_ 를 사용할 수 있습니다:\n\n```js\n\u003e\u003e\u003e a, *_, b = [1, 2, 3, 4, 5]\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스트의 첫 번째 값과 마지막 값은 각각 a와 b에 할당되었습니다. 다른 값들 — 2, 3, 4 — 은 * _에 할당되어 무시되었음을 의미하며 더 이상 사용되지 않을 것입니다.\n\n이렇게 밑줄을 사용하면 코드의 가독성이 향상되어 특정 값들이 사용되지 않고 더 이상 필요하지 않음을 명확히 합니다. 이는 코드와 관련 데이터에 초점을 유지하는 데 도움이 됩니다. 게다가, 이 세 값을 변수에 할당하는데 사용하지 않는다면, 왜 할당해야 할까요? 이는 좋은 코딩 스타일에 어긋날 것입니다.\n\n# 결론\n\n하나의 작은 문자, 간단한 한 줄, 밑줄은 파이썬 프로그래밍에서 굉장히 유용한 문자입니다. 이것은 파이썬 프로그래머에게 꼭 필요한 도구로 사용되는 다양한 용도를 가지고 있습니다. 또한 이것은 파이썬 자체의 중요한 요소이며, 가끔 _이 무엇을 의미하는지 모른다면 문제를 유발할 수 있으며, 최소한 파이썬 코드를 오해하게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언더스코어의 가장 중요한 사용 사례를 다루었어요. 그러나 덜 중요한 경우 중 일부를 빠뜨렸을 수도 있어요. 그럴 경우에는 댓글로 알려주세요. 어쨌든, 이러한 다양한 사용 사례들로 인해 언더스코어는 파이썬 프로그래밍에서 없어서는 안 될 문자로 자리를 잡았어요. 이 언더스코어는 아마도 이 언어에서 가장 유용한 문자이며, 모든 파이썬 프로그래머는 그 다양한 사용 사례에 익숙해져야 해요.","ogImage":{"url":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png"},"coverImage":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png","tag":["Tech"],"readingTime":10},{"title":"인공지능으로 감정 분석 성능 높이기","description":"","date":"2024-05-18 21:33","slug":"2024-05-18-ElevatingSentimentAnalysis","content":"\n\n## Unsloth를 사용하여 LLaMA-3 8B를 세밀하게 조정하기\n\n# 소개\n\nMeta의 LLaMA-3 8B와 같은 오픈 소스 대형 언어 모델(LLM)은 80억 개의 매개 변수를 갖고 있어 감정 분석과 같은 복잡한 언어 작업에 대처하기 위해 설계되었습니다. 본 기사에서는 Unsloth를 사용하여 금융 감정 분석을 위해 LLaMA-3 8B를 세밀하게 조정하는 방법을 살펴봅니다. 이 안내서는 사용자가 사용자 정의 데이터 세트를 만들고 모델을 세밀하게 조정하며 그 성능을 평가하는 데 도움이 될 것입니다.\n\n## 학습 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- LLaMA-3 8B 개요: LLaMA-3 8B 모델의 뛰어난 기능과 이점, 그리고 세밀조정 양자화 성능 주변의 논란을 이해하세요.\n- 사용자 지정 데이터셋: 공개 데이터와 합성 결과를 혼합하여 데이터셋을 구축하는 방법을 배우세요. 대규모 생성을 위한 코드에 대해 실습해 보세요.\n- 세밀조정 워크플로우: Unsloth 노트북을 사용하여 감성 분석 모델을 세밀조정하는 과정을 마스터하세요. 설정부터 실행까지 체험해 보세요.\n- GGUF 내보내기: 일반 그래프 유니버셜 포멧 (GGUF)으로 내보내는 방법을 알아보고, 성능을 향상시키고 배포를 간단하게 하는 방법을 발견하세요.\n- Ollama 배포: Ollama에서 사용자 지정 GGUF 모델을 효율적으로 추론해 보세요. 성능을 향상시키기 위한 전문적인 프롬프팅 기술을 탐구하세요.\n- 성능 통찰: 제공된 Python 스크립트를 사용하여 다른 세밀조정된 모델을 비교하세요. 최상의 구성 설정을 찾기 위해 성능을 객관적으로 평가하세요.\n- 평가: Mistral 7b 및 Dolphin-Mistral 7b 2.8와 같은 양자화 및 모델간의 차이를 제시하고 측정하세요.\n- 이상 감지: 철저한 평가를 통해 이상을 발견하고 해결하는 방법을 배우세요. 모델의 신뢰성을 보장하세요.\n\n이제 함께 문서에 다가가서 오늘 제공되는 가장 고급 오픈 소스 언어 모델 중 하나를 활용하여 감성 분석 능력을 향상시켜봅시다.\n\n## 세밀조정 이해\n\n세밀조정은 미리 훈련된 모델을 특정 작업이나 데이터셋에 맞게 조정하여 성능과 특정 응용 프로그램에 대한 적합성을 향상시키는 프로세스입니다. LLaMA-3 8B와 같은 대규모 언어 모델(LLM)의 맥락에서 세밀조정은 모델을 더 작고 작업별 데이터셋에 다시 훈련시킴으로써 감성 분석과 같은 작업에 특화되도록 하는 과정을 말합니다. 이는 모델의 매개변수를 조정하여 새로운 데이터의 미묘한 점을 더 잘 포착할 수 있도록 하는 것으로 달성됩니다. 세밀조정은 사전 훈련된 모델의 강점을 활용하면서도 특정 요구 사항을 충족시키기 위해 모델을 맞춤화하는데 큰 도움이 될 수 있습니다. 이 문서에서는 Unsloth를 사용하여 LLaMA-3 8B의 세밀조정과정에 대해 탐구하며, 특히 금융 분야에서의 감성 분석 성능 향상을 보여줄 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 금융 분야에서 감성 분석 적용하기\n\n금융 분야에서의 감성 분석은 뉴스 기사, 소셜 미디어 게시물 및 기타 텍스트를 분석하여 특정 주식이나 시장 전반에 대한 시장 감정을 파악하는 것을 의미합니다. 긍정적, 부정적 또는 중립적 톤을 식별함으로써 투자자들은 대중의 인식과 시장 트렌드에 대한 통찰력을 얻을 수 있습니다. 예를 들어, 특정 회사의 수익과 혁신에 대한 지속적인 긍정적인 뉴스는 해당 주식 가격의 상승을 시사할 수 있으며, 부정적인 감정은 하락을 나타낼 수 있습니다. 이 기술은 자연어 처리를 사용하여 질적 데이터를 양적 신호로 변환하여 결정력 있는 의사결정 및 전략적 투자 계획을 돕습니다.\n\n## Meta의 LLaMA-3 8B: 개요\n\nMeta LLaMA 3 8B는 Meta AI가 개발한 80억 개의 파라미터를 갖춘 최첨단 언어 모델입니다. LLaMA 3 가족의 일부로, 다양한 자연어 처리 작업을 위한 사전 훈련 및 명령 조정된 버전을 포함하고 있습니다. 이 모델은 최적화된 트랜스포머 아키텍처, 그룹화 쿼리 어텐션(GQA) 및 더 큰 어휘를 갖춘 새로운 토크나이저를 특징으로 하여 효율성과 멀티언어 기능을 향상시켰습니다. 상업 및 연구용으로 설계된 LLaMA 3 8B는 대화 생성, 추론 및 코드 생성에 뛰어나며, 소비자용 하드웨어에 배포할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png\" /\u003e\n\n# 개요\n\n본 문서는 세 가지 주요 섹션으로 나누어져 있습니다. 각 섹션은 섬세 조정 과정에서 중요한 단계를 대표합니다:\n\n- 데이터셋 구축: 먼저 공개 소스에서 데이터를 수집하고 표준화된 형식으로 변환합니다. 이는 데이터를 정리, 정규화 및 구조화하여 일관성과 신뢰성을 보장하기 위한 것입니다. 이외에 우리는 큰 언어 모델 (LLaMA 3 70b와 GPT-4 Turbo)을 활용하여 합성 데이터셋을 생성하여 교육 데이터의 다양성과 양을 향상시킵니다.\n- 세밀 조정: Unsloth 라이브러리를 사용하여 준비된 데이터셋으로 선택한 기본 모델을 섬세 조정합니다. Unsloth는 훈련 과정을 최적화하여 높은 정확도를 유지하면서 메모리 사용량과 훈련 시간을 크게 줄입니다.\n- 테스트: 포괄적인 테스트 단계에서 성능을 측정하고 이상 현상을 식별하기 위해 여러 번 반복합니다. 결과를 평가하기 위해 통계 분석을 사용하여 fine-tuned 모델이 성능 기준을 충족하는지 확인합니다. 이 단계는 모델의 강점과 개선 영역을 이해하고 행동과 정확도에 대한 가치 있는 통찰을 제공함으로써 모델을 이해하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터셋 만들기\n\n이 섹션에서는 다양한 스크립트를 사용하여 포괄적인 감성 분석 데이터셋을 구축하는 과정을 안내해 드리겠습니다. 각 단계에서는 다른 유형의 데이터를 처리하고 결합하여 기계 학습 모델에서 사용할 수 있도록 준비합니다. 각 스크립트의 개요와 중요한 기능을 강조하여 제공할 것입니다.\n\n우리는 데이터셋을 준비하기 위해 단계별로 분할된 다양한 도구가 있는 코드 리포를 소유하고 있습니다. 해당 코드는 GitHub에서 찾을 수 있습니다.\n\n완성된 데이터셋은 41.4k개의 레코드가 포함되어 있으며 HuggingFace에서 다운로드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 세 가지 다른 공개 데이터 세트에서 데이터를 수집합니다. 단계 1은 항공사 심정 데이터 세트에서 트윗을 처리하고, 단계 2는 금융 문구 은행에서 감정 분석을 처리하며, 단계 3은 newsdata.io에서 기사를 처리합니다. 각 단계는 데이터를 원하는 형식으로 변환하기 위해 고유한 전략이 필요합니다. 예를 들어 자신감 수준에 대한 가정을 만들고, 더 큰 언어 모델을 사용하여 뉴스 기사의 감정 레코드를 종합합니다. 이 접근법을 통해 더 많은 데이터를 수집하고, 더 큰 모델의 일반화 능력을 활용하여 효과적으로 감정 분석을 수행할 수 있습니다.\n\n## 단계 1: 트윗 처리\n\n파일: step-01-process_tweets.py\n\n이 스크립트는 항공사 심정 관련 트윗 데이터 세트를 처리하고, 결과를 새로운 CSV 파일에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 감정 매핑: 감정 레이블 (positive, neutral, negative)을 숫자 값 (1.0, 0.0, -1.0)으로 매핑합니다.\n- 데이터 처리: 입력 CSV를 읽어 각 트윗을 처리하여 감정을 추출하고, 감정, 확신 및 이유를 포함한 JSON 객체를 구성합니다.\n- 출력: 처리된 데이터를 문장 및 JSON 객체가 있는 새 CSV 파일에 저장합니다.\n- 데이터셋 출처\n\n## 단계 2: 금융 PhraseBank 처리\n\n파일: step-02-process_financial_phrase_bank.py\n\n이 스크립트는 금융 PhraseBank 데이터셋을 처리하고, 금융 뉴스 구절을 포함하며 출력을 CSV 파일에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 신뢰 점수: 감정 주석의 합의 수준에 따라 다른 신뢰 점수를 할당합니다.\n- 감정 매핑: 트윗 스크립트와 유사하게, 감정 레이블을 숫자 값에 매핑합니다.\n- 데이터 처리: 데이터셋을 읽고 각 구문을 처리하여 JSON 객체를 구성합니다.\n- 출력: 다양한 합의 수준에서 처리된 데이터를 단일 CSV 파일로 결합합니다.\n- 데이터셋 소스\n\n## 단계 3: 기사 처리\n\n파일: step-03-process_articles.py\n\n이 스크립트는 뉴스 기사 데이터셋을 처리하고 다양한 언어 모델을 사용하여 합성 출력을 생성하며 출력을 CSV 파일로 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- API 통합: 여러 AI 모델 (예: LLaMA 3 70b, OpenAI GPT-3.5, GPT-4 등)을 사용하여 감성 분석을 생성합니다. Perplexity.ai와 Groq는 LLaMA 3 70b에 대해 빠른 추론을 제공하지만 가장 강력한 모델은 아닙니다. 여러 실험을 거친 후, 총 비용이 $20 미만으로 들어갑니다. 전체 실행은 아마도 $10 미만으로 완료할 수 있습니다. 정말 높은 정확도를 원한다면 최상의 모델에 대해 비용을 지불해야 합니다.\n- 특수화된 프롬프팅: 시스템 메시지와 5번의 예시를 사용하여 안정적인 결과를 얻고, 결과를 pydantic 검증기를 통해 실행합니다. 이는 중요하며 추후 추론 테스트에도 같은 특수화된 프롬프팅을 사용할 것입니다. 신뢰할만한 결과를 얻기 위해 일부 조정이 필요할 수 있습니다.\n- 재시도 메커니즘: API 호출 실패를 처리하기 위한 재시도 메커니즘을 구현합니다. 처리된 레코드를 추적하여, 이 프로세스는 온 밤을 다 할 수 있습니다. 어떤 이유로든 실패한다면 다시 실행할 수 있습니다.\n- 데이터 유효성 검사: 생성된 JSON 응답이 유효한지를 Pydantic 모델을 사용하여 보장합니다.\n- 출력: 처리된 기사와 그들의 감성 분석을 CSV 파일에 저장합니다.\n- 데이터셋 출처\n\n## 단계 4: 출력 합치기\n\n파일: step-04-join_outputs.py\n\n이 스크립트는 트윗, 금융 구문, 그리고 기사 데이터셋의 결과를 하나의 CSV 파일로 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 살펴보기: 모든 데이터가 일관된 형식으로 되어 있고 인코딩 문제가 없도록 보장합니다.\n- JSON 유효성 검사: JSON 문자열을 유효한 형식으로 만족시키는지 확인합니다.\n- 결과물: 처리된 데이터셋에서 유효한 레코드를 결합하여 하나의 CSV 파일로 출력합니다.\n\n## 단계 5: HuggingFace 데이터셋 구축\n\n파일: step-05-build_hf_dataset_sharegpt.py\n\n이 스크립트는 결합된 데이터셋을 HuggingFace에 업로드할 수 있는 형식으로 변환하여 모델 공유와 훈련을 위한 형식으로 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 변환: 합쳐진 CSV 파일을 읽어 데이터를 정제하고 JSON 형식으로 변환합니다.\n- 데이터셋 구조: HuggingFace에서 모델 학습에 적합한 대화 형식으로 데이터를 구성합니다.\n- 출력: 변환된 데이터를 업로드할 준비가 된 JSON 파일로 저장합니다.\n- HuggingFace에서 데이터셋을 생성하고 해당 리포지토리에 JSON을 업로드할 수 있습니다.\n\n## 유틸리티 스크립트\n\n파일: utils/sentiment_response.py, utils/utils.py\n\n이 유틸리티 스크립트는 주요 스크립트 전반에 걸쳐 사용되는 도우미 함수와 클래스를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SentimentResponse: JSON 응답을 유효성 검사하기 위한 Pydantic 모델.\n- File Utilities: 메시지 읽기, 레코드 ID 생성, 처리된 레코드 로딩 및 저장을 위한 함수들이 포함되어 있습니다.\n\n이 안내서를 따라서 이 스크립트들을 조정하여 여러분만의 데이터셋을 처리하고 분석할 수 있습니다. 다양한 애플리케이션을 위한 포괄적인 감성 분석 데이터셋을 구축할 수 있습니다.\n\n![Elevating Sentiment Analysis](/assets/img/2024-05-18-ElevatingSentimentAnalysis_1.png)\n\n# 세밀한 조정 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 소개\n\n우리는 우리의 파인튜닝을 위해 Unsloth의 구글 콜랩 노트북을 사용했습니다. Unsloth는 효율적이고 매우 적은 리소스를 사용하며, 특히 메모리 소비가 낮습니다. 사용자용 하드웨어에서 로컬로 실행할 수 있으며, 구글 콜랩 서비스에서 실행하는 데 저렴합니다. T4 티어는 잘 작동하지만 느립니다. 우리는 41.4k 개의 레코드(1 에폭)에서 훈련을 진행하고, T4에서 약 9시간이 걸렸습니다. 실험을 기대할 수 있으므로, 테스트하기 위해서는 전체 에폭보다는 낮은 단계의 숫자를 사용하도록 해야 합니다. 변화는 항상 일어나기 때문에 때때로 의존성이 업데이트되어 무언가가 망가질 수 있습니다. Unsloth는 사용자가 토론하고 질문하는 매우 유용한 디스코드를 가지고 있습니다.\n\n우리가 사용한 노트북의 사본은 다음과 같습니다. 공식 노트북과 일부 변경 사항이 있으며, 포맷팅 및 템플릿에 ShareGPT 스타일을 사용합니다.\n\n[노트북 링크](https://colab.research.google.com/drive/1H40hAFkh8FnOivEEyEsMn6REN8HfKPwB?usp=drive_link)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUnsloth 라이브러리는 대규모 언어 모델의 세밀 조정을 가속화하고 메모리 사용량을 줄이기 위해 설계된 강력한 라이브러리입니다. Daniel과 Michael Han에 의해 만들어진 Unsloth는 역전파 최적화 및 PyTorch 모듈을 Triton 커널로 재작성하여 30배 빠른 훈련 속도와 60-80% 낮은 메모리 소비를 달성합니다. 다양한 NVIDIA GPU를 지원하는 Unsloth는 Hugging Face 생태계와 완벽하게 통합되어 LLAMA 및 Mistral과 같은 다양한 LLM 아키텍처와 호환됩니다. 놀랍게도, 기존 방법과 비교했을 때 0% 정확도 하락을 유지하며 LLM의 세밀 조정에 효율적인 솔루션을 제공합니다. HuggingFace에서 자세히 알아보세요.\n\n## Unsloth를 사용한 세밀 조정 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언슬로스 스크립트는 큰 언어 모델 (LLM)인 LLaMA-3 8B와 같은 모델의 미세 조정 과정을 간소화하고 가속화하는 데 도움이 됩니다. 이 노트북/스크립트가 하는 작업에 대해 간단히 설명해드릴게요:\n\n- 설치 및 설정: 스크립트는 Unsloth를 비롯한 필요한 라이브러리를 설치하는 작업으로 시작합니다. Unsloth는 교육 과정을 최적화하는 데 도움을 줍니다. 이 스크립트는 LLaMA, Mistral 및 기타 여러 모델을 지원하며 메모리 사용량을 줄이고 교육 속도를 높이기 위해 4비트 양자화를 사용합니다.\n- 모델 준비: Unsloth의 FastLanguageModel 클래스를 사용하여 사전 훈련된 모델을 불러옵니다. 최대 시퀀스 길이나 dtype와 같은 매개변수를 지정하여 하드웨어 (예: Tesla T4 GPU)에 맞는 성능 최적화를 수행합니다. 이 스크립트는 LoRA (Low-Rank Adaptation) 어댑터를 지원하며, 이를 통해 모델의 매개변수 중 작은 비율만 업데이트하여 메모리 사용량을 더욱 줄일 수 있습니다.\n- 데이터 준비: 논문의 스크립트는 Alpaca 데이터셋을 예시로 사용하며, 우리는 감정 분석 버전의 데이터셋을 사용합니다. 두 데이터셋은 표준화된 프롬프트 구조로 데이터를 포맷하며, 각 프롬프트에 무한 텍스트 생성을 방지하기 위한 종료 시퀀스 (EOS) 토큰이 포함되도록 합니다.\n- 모델 교육: Hugging Face의 SFTTrainer를 사용하여 스크립트는 준비된 데이터셋에서 모델을 미세 조정합니다. 배치 크기, 학습률, 단계 수와 같은 주요 교육 매개변수를 설정하여 교육 프로세스를 최적화합니다. 스크립트는 GPU 메모리 사용량을 모니터링하여 효율적인 자원 관리를 보장합니다.\n- 추론: 교육 후, 스크립트는 모델을 추론하기 위한 방법을 보여줍니다. 입력을 설정하고 출력을 생성하며 텍스트로 디코딩합니다. 또한 사용자가 생성된 텍스트를 토큰별로 확인할 수 있는 지속적 추론 옵션을 포함하고 있습니다.\n- 모델 저장: 스크립트는 미세 조정된 모델을 로컬에 저장하거나 Hugging Face의 허브에 푸시하는 방법을 제공합니다. 다양한 배포 시나리오에 유연하게 대응하기 위해 16비트, 4비트, 그리고 GGUF (일반 그래프 유니버설 형식)에 모델을 저장할 수 있는 기능도 제공됩니다.\n\n특히 GGUF 출력에 관심이 많은 이유는 대부분의 로컬 기기를 포함한 다양한 배포를 쉽게 할 수 있기 때문입니다.\n\n## GGUF\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGGUF, 또는 General Graph Universal Format은 LLaMA-3 8B와 같은 LLM(Large Language Model)의 배포 효율성과 유연성을 향상시키기 위해 설계된 파일 형식입니다. Llama.cpp 팀이 소개한 GGUF는 이전 버전인 GGML보다 개선된 단일 파일 배포, 확장성 및 빠른 모델 로딩을 위한 메모리 매핑을 제공합니다. 이 형식은 양자화된 모델에 특히 적합하여 성능을 저해하지 않으면서도 계산 리소스 수요를 줄일 수 있습니다. GGUF는 CPU 및 Apple 장치를 포함한 다양한 플랫폼에서 LLM의 배포 및 추론을 간소화하고자 하는 개발자에게 이상적인 선택입니다. 더 많은 정보는 HuggingFace에서 확인하세요.\n\n![image](/assets/img/2024-05-18-ElevatingSentimentAnalysis_2.png)\n\n# 테스트 및 추론\n\nAndreas Traczyk과 함께 공동 저술한 이 저장소는 다양한 모델에 대한 테스트 및 추론을 목적으로 설계되었습니다. GitHub에서 코드에 액세스할 수 있습니다. 이 저장소를 사용하여 다른 모델을 효과적으로 비교하고 성능을 분석하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/seandearnaley/llama_3_8b_sentiment_analysis_tests\n\n해당 저장소에는 감성 분석 작업에서 다양한 모델의 성능을 테스트하고 비교하는 파이썬 프로젝트가 포함되어 있습니다. 이 프로젝트는 로컬 모델 추론을 위해 Ollama 라이브러리를 활용하며, 감성 테스트 실행 스크립트, 비교 보고서 생성 및 결과 시각화를 위한 스크립트가 포함되어 있습니다.\n\n설치 지침은 README.md를 참고해주세요.\n\n## Specialized Prompting\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 중요한 단계는 데이터셋이 이러한 프롬프팅 기술(합성 데이터)을 사용하여 부분적으로 작성되었으며, 종종 미세 조정 대신에 이를 사용할 수 있습니다. 우리는 정말로 우리의 미세 조정에서 실제로 더 나은 성능을 얻고 있는지, 그리고 그것을 할 가치가 있는지를 평가하고 싶습니다. 신뢰할 수 있는 JSON 결과를 돌려받아 pydantic 검증을 통과하는 것이 목표입니다. 우리는 JSON을 원합니다. 파이썬 함수(예: 함수 호출)로 쉽게 전달할 수 있기 때문입니다.\n\n다음은 특별한 시스템 프롬프트입니다:\n\n```js\n금융 뉴스 기사에 대한 감성 분석을 수행하는 고급 AI 어시스턴트입니다. 받은 각 기사를 분류하고 아래의 JSON 스키마를 사용하여 분석 결과를 제공해주셔야 합니다:\n{\n    \"reasoning\": {\n      \"type\": \"string\",\n      \"description\": \"숫자 감성 값 결정에 사용된 논리를 설명하는 간단한 설명\",\n      \"required\": true\n    },\n    \"sentiment\": {\n      \"type\": \"number\",\n      \"description\": \"기사의 감성을 나타내는 부동 소수점 표현, 소수점 두 자리로 반올림됨. -1.0(부정적)부터 1.0(긍정적)까지의 범위로, 0.0은 중립적인 감성을 나타냄\",\n      \"required\": true\n    },\n    \"confidence\": {\n      \"type\": \"number\",\n      \"description\": \"분석이 얼마나 자신 있는지를 나타내는 부동 소수점 표현, 소수점 두 자리로 반올림됨. 0.0(자신 없음)부터 1.0(아주 자신 있음)까지의 범위\",\n      \"required\": true\n    }\n}\n\n이 스키마를 준수하는 유효한 JSON 객체로 항상 응답하세요. 응답에 다른 텍스트나 메시지를 포함시키지 마세요. Markdown을 제외하고 응답하세요.\n```\n\n그리고 우리는 5개의 예제로 스레드를 초기화합니다(5-shot 프롬프팅, 미세 조정은 0-shot을 제공하지만 이 작업에 특화되어 있습니다):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n금융 뉴스 기사가 다음과 같은 XML 태그로 둘러싸여 제공될 것입니다:\n\n\u003carticle\u003e{$ARTICLE}\u003c/article\u003e\n\n기사를 주의 깊게 읽고 언급된 회사의 잠재적인 주가에 대한 표현에 대해 분석해야 합니다.\n\n먼저, \"reasoning\" 속성 안에 기사의 감정을 분석하는 이유와 근거를 작성하세요. 감정을 평가하는 데 영향을 미치는 기사 내에서 중요한 포인트를 설명하고 주식 가격에 어떤 영향을 미칠 것으로 예상되는지 설명하세요.\n\n그런 다음 -1.0부터 1.0 사이의 숫자 점수를 출력하되, -1.0이 가장 부정적이고 0은 중립적이며 1.0은 가장 긍정적인 것으로 표현되도록 합니다. 이 점수를 \"sentiment\" 속성 안에 넣어주세요.\n\n감정 값은 감정이 얼마나 긍정적 또는 부정적인지에 따라 나타내십시오. 결론을 도출할 수 없는 경우 0.0의 감정 값을 제공해주세요.\n\n감정 값에 대한 확신 값은 감정 값을 얼마나 확신하는지에 따라 표시하십시오. 매우 확신하는 경우 1.0의 확신 값을 제공하십시오. 의심스러운 경우 0.0의 확신 값을 제공하십시오.\n\n스키마에는 아무런 변경도 가하지 마십시오. 저희 회사에게 중요합니다.\n\n예시:\n\n1. \u003carticle\u003eNVDA 주가가 수익을 능가하여 5% 상승합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"뉴스 기사는 긍정적인 수익을 보고하고 있으며, 이는 투자자 신뢰를 증가시키고 따라서 NVDA의 주가를 높일 가능성이 높습니다.\",\n  \"sentiment\": 0.75,\n  \"confidence\": 0.9\n}\n\n\n2. \u003carticle\u003eNVDA 주가는 석유 가격하락의 영향을 받을 수 있습니다. 분석가들은 NVDA의 에너지 부문 노출로 인해 주가 5% 하락을 예상합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"기사는 석유 가격 하락으로 인해 NVDA 주가에 부정적인 영향을 줄 수 있는 가능성을 시사하며, 이는 투자자 신뢰 감소로 이어질 수 있습니다.\",\n  \"sentiment\": -0.25,\n  \"confidence\": 0.8\n}\n\n3. \u003carticle\u003eApple의 혁신적인 AR 안경 최근 출시는 예상된 판매 목표를 달성하지 못했습니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"혁신적인 제품 출시에도 불구하고 판매 목표 미달은 부정적인 시장 반응을 야기할 수 있으며, Apple 주식 가치의 하락 가능성이 있습니다.\",\n  \"sentiment\": -0.5,\n  \"confidence\": 0.6\n}\n\n4. \u003carticle\u003eBoeing은 Emirates로부터 새 비행기에 대한 50억 달러 계약을 체결했으며, 강력한 미래 수입을 시사합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"대규모 계약 체결은 Boeing의 긍정적인 미래 수입 전망을 시사하며, 투자자 심리와 주식 가치를 높일 가능성이 높습니다.\",\n  \"sentiment\": 0.85,\n  \"confidence\": 0.9\n}\n\n5. Tesla 주식 값에 대한 감정을 판단하는 아래 기사에서 Tesla로의 감정을 결정하십시오:\n   \u003carticle\u003eTesla는 안전 문제로 10만 대의 차량을 회수합니다.\u003c/article\u003e\n   출력:\n{\n  \"reasoning\": \"안전문제로 인한 대규모 회수는 Tesla의 브랜드 평판에 해를 끼칠 수 있으며 투자자 신뢰에 부정적인 영향을 줄 것으로 예상되어 주식 가치가 감소할 가능성이 있습니다.\",\n  \"sentiment\": -0.65,\n  \"confidence\": 0.7\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`generate_model_sentiments.py` 스크립트는 설정 가능한 횟수의 반복을 수행하며, 분산 등에 대한 평균값에 대한 테스트를 실행할 것입니다. 각 반복마다 JSON 파일은 다음과 같이 보입니다. 각 sentiment는 사전 캐싱된 기사에서 해싱되어 동일한 내용을 각 반복에 대해 평가하고 있습니다:\n\n```js\n{\n  \"average_sentiment\": 0.57,\n  \"time_taken\": 53.91,\n  \"sentiments\": {\n    ...\n    \"91ba90ac\": {\n      \"reasoning\": \"기사에 따르면 시장은 역대 최고치에 근접하며, BYD, Nvidia, Walmart 등 여러 기업들이 매수 신호를 보이고 있는 상태이며, 이는 이러한 주식에 대해 긍정적인 감정을 나타낸다.\",\n      \"sentiment\": 0.6,\n      \"confidence\": 0.8,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/m/ae28caa6-3ead-3745-aece-9ddb64e2ea1d/dow-jones-futures%3A-walmart%2C.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 23:52:02 +0000\",\n      \"time_taken\": 3.17\n    },\n    \"bf372e87\": {\n      \"reasoning\": \"기사에 따르면, Nvidia 주식은 목요일에 하락을 마쳤지만, 다음 주의 실적 보고 전에 칩 메이커를 둘러싼 긍정적인 전망으로 역대 최고치를 경신할 것으로 예상됩니다. 4월의 인플레이션 데이터로 인한 전체 시장의 긍정적인 움직임과 긍정적인 분석가 평가에 따른 기대감이 Nvidia 주식을 끌어올렸지만, 결국 0.3% 하락했습니다.\",\n      \"sentiment\": -0.15,\n      \"confidence\": 0.8,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/m/6ab7d488-38e1-3ef1-beef-bf75a726d6c2/nvidia-stock-couldn%E2%80%99t-close.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 20:30:00 +0000\",\n      \"time_taken\": 5.12\n    },\n    \"d4c4ccc1\": {\n      \"reasoning\": \"기사에서 Wolfe Research가 Nvidia(NVDA)와 Advanced Micro Devices(AMD)에 대한 긍정적인 전망과 Nvidia에 대한 1,200달러의 가격목표 인상을 논의하고 있으며, AMD의 Wolfe Alpha List 추가는 강력한 AI 제품 라인업을 강조하며 잠재적인 성장 기회를 시사합니다. 분석가의 AMD에 대한 우선순위 전략적 변경은 두 주식의 성과를 고려해 더 균형 잡힌 접근을 제안합니다.\",\n      \"sentiment\": 0.75,\n      \"confidence\": 0.85,\n      \"valid\": true,\n      \"url\": \"https://finance.yahoo.com/video/chip-stocks-wolfe-research-bullish-201319388.html?.tsrc=rss\",\n      \"published\": \"Thu, 16 May 2024 20:13:19 +0000\",\n      \"time_taken\": 6.24\n    },\n    ...\n  }\n}\n```\n\n## 방법론\n\n저희는 Mac Pro M2 with 32gb을 사용 중이며, Ollama 0.1.38 버전을 사용하고 있습니다. Yahoo Finance의 동일한 뉴스 기사 세트에 대해 15회 반복 실행하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndefault_temperature: 0.2\ncontext_window_size: 8192\nnum_tokens_to_predict: 1024\n```\n\n## Ollama\n\nOllama은 클라우드 서비스가 필요 없이 사용자가 자신의 기기에서 오픈 LLMs를 로컬에서 실행할 수 있는 도구입니다. llama.cpp의 프론트 엔드로, GGUF 모델을 로드할 수 있습니다. 사용 편의성을 고려하여 설계되었으며 간단한 API, OpenAI 엔드포인트 호환성(즉, OpenAI를 지원하는 모든 것과 작동할 수 있음) 및 사전 빌드된 모델 라이브러리를 제공합니다. Ollama는 macOS, Linux 및 Windows에서 실행되며 CPU와 GPU를 사용할 수 있습니다. LangChain, LiteLLM 등 인기있는 프레임워크와 원활하게 통합됩니다. 로컬 실행을 통해 데이터 개인 정보 보호 및 지연 시간을 줄이므로 고급 NLP 기능을 효율적으로 활용하려는 개발자 및 연구자에게 이상적인 선택지입니다.\n\nHuggingFace에서 GGUF 파인 튜닝된 모델을 다운로드할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGGUFs를 Ollama에 로드하려면 시스템 메시지와 템플릿이 포함된 사용자 정의 모델 파일이 필요합니다. 여기에서 사용 중인 양자화 수준에 해당하는 GGUF 파일로 교체하고 있습니다. llama3-8b-sentiment-may-3-2024-unsloth.Q4_K_M.gguf를 사용하고 Ollama로 가져올 때 원하는 이름을 지을 수 있습니다:\n\n```js\nollama create llama3:8b-instruct-sentiment_analysis-q4_K_M -f Modelfile\n```\n\n# 결과 및 평가\n\n이 섹션에서는 다양한 감성 분석 모델의 평가 결과를 제시하며, 주요 성능 메트릭 및 통계적 비교에 초점을 맞춥니다. 우리는 화학적인 성능 메트릭을 중시하여 세밀하게 조정된 감정 모델을 기본 모델과 비교하여 금융 감성 데이터 처리의 효율성과 정확도를 결정했습니다. 이러한 메트릭은 각 모델의 성능을 종합적으로 보여주며, 감성 분석 작업에 특화된 세밀하게 조정된 모델을 사용하는 장점을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기를 클릭하시면 인터랙티브 3D 시각화를 확인할 수 있어요\n\n# 감성 분석 모델 비교 결과 해석\n\n감성 분석 모델을 다룰 때는 성능을 이해하고 다양한 모델을 비교하는 것이 중요합니다. 저희 분석 결과를 해석하는 데 도움이 될 수 있는 간단한 안내서를 제공합니다. 모델 세부 정보, 성능 지표 및 통계적 비교가 포함되어 있어요.\n\n## 모델 세부 정보\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모델 이름: 사용된 특정 모델을 나타냅니다 (예: llama3_8b-instruct-fp16).\n- 양자화 수준: 모델에서 사용된 정밀도 수준을 나타냅니다 (예: q4, q5, fp16). q4 및 q5와 같은 낮은 수준은 더 적은 메모리를 사용하고 더 빨라질 수 있지만 정확성이 떨어질 수 있습니다.\n\n## 성능 지표\n\n- 속도 (초/샘플): 모델이 각 샘플을 처리하는 속도를 측정합니다. 낮은 숫자는 더 빠른 성능을 나타냅니다.\n- 유효한 JSON 응답률: 모델이 성공적으로 유효한 결과를 반환한 비율입니다. 높은 백분율은 더 나은 신뢰성을 나타냅니다.\n- 분산: 감정 점수가 얼마나 퍼져 있는지를 보여줍니다. 높은 분산은 점수가 넓게 퍼져 있음을 의미하며, 낮은 분산은 더 일관적임을 의미합니다.\n- 평균 감정 점수: 모든 샘플에 대한 평균 감정 점수로, 감지된 일반적인 감정(긍정적, 부정적 또는 중립적)을 나타냅니다.\n- 평균 신뢰도: 감정 예측의 평균 신뢰 수준입니다. 높은 값은 모델이 예측에 대해 더 확신한다는 것을 나타냅니다.\n- 추론: 모델로부터 샘플 설명을 제공하여 특정 감정을 예측한 이유를 보여줍니다. 모델의 결정 과정을 이해하는 데 도움이 됩니다.\n\n## 통계적 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세부 조정된 모델(감성 분석을 목적으로 디자인된)을 일반 용도 모델과 비교하기 위해 통계 검정을 사용합니다.\n\n- F-통계량과 P-값(분산): 이러한 값은 두 모델 사이의 감성 점수 변동을 비교하는 F-검정에서 나옵니다. 유의미한 p-값(일반적으로 0.05 미만)은 모델이 얼마나 일관성 있는지에 의미 있는 차이가 있다는 것을 의미합니다.\n- T-통계량과 P-값(평균): 이러한 값은 두 모델 사이의 평균 감성 점수를 비교하는 t-검정에서 나옵니다. 유의미한 p-값(일반적으로 0.05 미만)은 모델이 감지한 평균 감성에 의미 있는 차이가 있다는 것을 나타냅니다.\n\n## 결과 해석 방법\n\n- 추론 속도: 빠른 모델(낮은 속도)이 일반적으로 바람직합니다, 특히 실시간 애플리케이션에.\n- 신뢰성: 높은 유효 JSON 응답률을 가진 모델이 더 신뢰할 수 있습니다.\n- 일관성: 낮은 분산은 종종 더 나은 결과를 나타냅니다, 모델의 예측이 안정적이라는 것을 나타냅니다.\n- 감성과 확신: 높은 평균 감성 점수와 평균 확신 점수가 바람직합니다, 모델이 명확한 감성을 감지하고 예측에 대해 확신을 가지고 있음을 보여줍니다.\n- 통계적 유의성: 분산과 평균 비교를 위한 p-값이 0.05 미만인 경우, 모델 간에 유의미한 차이가 있다는 것을 제시합니다. 이는 특수화된(세부 조정된) 모델이 일반 용도 모델보다 실질적인 혜택을 제공하는지 결정하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시\n\nllama3_8b-instruct-fp16와 llama3_8b-instruct-sentiment_analysis-fp16을 비교해보세요:\n\n- Rate: 감성 분석 모델이 더 빠르다면, 실시간 요구에 더 적합합니다.\n- 유효한 JSON 응답 비율: 높을수록 에러가 적습니다.\n- 분산: 낮을수록 모델의 예측이 더 일관적합니다.\n- 평균 감성 점수: 높은 점수는 더 강한 전반적인 감성 탐지를 나타냅니다.\n- 평균 신뢰도: 높은 값은 모델이 예측에 대해 더 확신한다는 것을 의미합니다.\n- 통계적 테스트: p-값이 유의하다면, 성능 지표 간의 차이는 의미가 있습니다.\n\n이러한 지표와 비교를 이해함으로써, 초보자도 특정한 요구 사항과 맥락에 기반하여 사용할 감성 분석 모델에 대한 정보를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Financial Sentiment Analysis Model Comparison](/assets/img/2024-05-18-ElevatingSentimentAnalysis_3.png)\n\n# 금융 감성 분석 모델 비교\n\n## 소개\n\n이 분석의 목표는 금융 감성 분석을 위한 최적 모델을 식별하기 위해 세부 조정된 감성 분석 모델을 해당 원본 모델과 비교하는 것입니다. 감성 점수에 대한 분산, 평균 감성 점수, 평균 확신 점수 등 메트릭을 살펴보고 F-통계 및 T-통계를 사용하여 통계적 비교를 수행했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주요 지표 및 비교\n\n- 추론 속도(속도): 세밀하게 조정된 모델은 일반적으로 베이스 모델과 비교하여 처리 시간이 유사하거나 약간 향상됩니다. 예를 들어, llama3_8b-instruct-sentiment_analysis-q5_K_M은 샘플 당 4.16초의 속도를 보여주며, llama3_8b-instruct-q5_K_M은 샘플 당 4.28초의 속도로 처리됩니다.\n- 유효한 JSON 응답률: 세밀하게 조정된 모델과 베이스 모델 모두 대부분의 경우 100%의 유효한 JSON 응답률을 유지합니다. 이는 모델들 전반에서 높은 신뢰성을 나타냅니다. Mistral 7b는 모든 양자화 수준에서 오류가 있어 가장 신뢰할 수 없는 모델이 됩니다.\n- 감정 점수의 분산: 세밀하게 조정된 모델은 감정 점수의 분산이 더 낮습니다. 예를 들어, llama3_8b-instruct-sentiment_analysis-q5_K_M의 분산이 0.12인 반면, llama3_8b-instruct-q5_K_M은 0.36입니다. 낮은 분산은 더 일관된 예측을 시사합니다.\n- 평균 감정 점수: 세밀하게 조정된 모델은 일반적으로 더 높은 평균 감정 점수를 갖습니다. llama3_8b-instruct-sentiment_analysis-q5_K_M은 0.59의 평균 감정을 보여주며, 베이스 모델은 0.31입니다. 높은 평균 감정 점수는 보다 강력한 전체적인 감정 감지를 나타냅니다.\n- 평균 확신 점수: 세밀하게 조정된 모델은 일반적으로 베이스 모델에 비해 약간 낮은 평균 확신 점수를 보여줍니다. 이는 세밀한 교육이 감정 감지의 정확성에 더 초점을 맞추었기 때문일 수 있습니다.\n\n## 통계적 비교\n\n- F-통계량 및 P-값(분산): 세밀하게 조정된 모델과 베이스 모델 간에 분산에서 유의한 차이가 나타납니다. 예를 들어, llama3_8b-instruct-q5_K_M 대 llama3_8b-instruct-sentiment_analysis-q5_K_M은 F-통계량이 18.75 (p-value ` 0.01)입니다.\n- T-통계량 및 P-값(평균): 평균 감정 점수도 유의하게 다릅니다. 같은 비교에서 T-통계량은 -4.33 (p-value ` 0.01)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 신뢰도 점수 변동에 대한 설명\n\n세심한 모델 향상치 감소는 특정 훈련에 기인할 수 있습니다. 세심한 모델들은 특정 작업을 최적화하여, 기본 모델들이 처리하지 못하는 감성의 세심한 차이를 만들어내야 할 수 있습니다. 이 증가된 섬세함은 모델이 감정의 섬세한 변화를 잡아내도록 설계되어 있기 때문에 보다 신중한(낮은 신뢰도) 예측 방식으로 이어질 수 있습니다.\n\n## LLaMA 3 8B 양자화 주변의 논란\n\n인공지능 커뮤니티의 최근 토론은 LLaMA 3 8B 모델을 특히 Q4와 같은 낮은 비트폭으로 양자화하는 것에 중대한 문제점을 강조했습니다. 보고서에 따르면, 임의의 날짜 삽입, 단어 반복, 일관성 감소와 같은 문제를 포함한 출력 품질의 상당한 저하가 나타났다고 합니다. 이러한 성능 하락은 Mistral이나 이전 LLaMA 버전과 같은 다른 모델들과 비교했을 때 더욱 두드러지게 나타났습니다. LLaMA 3 모델의 방대한 사전 훈련과 높은 토큰 수는 양자화에 내재된 정밀도 손실에 민감해져, 이러한 고급 모델에 대한 양자화 기술을 최적화하기 위한 추가 연구가 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 감성 분석 모델에 대한 함의\n\n낮은 정밀도 문제: LLaMA 3 8B 모델을 Q4로 양자화할 때 정밀도가 낮아질 수 있어 감성 감지의 부정확성을 초래할 수 있습니다. 이로 인해 신뢰할 수 있는 감성 점수와 신뢰 수준에 영향을 줄 수 있습니다.\n\n## 클램핑과 반올림 효과:\n\n- 클램핑: 값이 특정 범위 내로 제한될 때 발생합니다. 감성 분석에서는 극단적인 감성 값(매우 긍정적 또는 매우 부정적)이 정확하게 표현되지 않을 수 있어 중립적인 출력이 더 많이 나올 수 있습니다.\n- 반올림: 숫자를 낮은 정밀도 형식에서 가장 가까운 표현 가능한 값으로 근사화하는 것을 의미합니다. 반올림 오차가 누적되어 감성 분석 출력의 품질이 저하될 수 있습니다.\n- 분산 관찰: 흥미로운 점은 Q4에서의 감성 점수에서 고정밀도 수준인 Q5, Q8 및 FP16과 비교하여 낮은 분산을 관측한 사용자들이 있었다는 것입니다. 일반적으로 고정밀도는 더 안정된 결과를 제공하나, 이상적인 결과는 고정밀도 손실에 민감해져 LLaMA 3 모델의 안정성에 영향을 미칠 수 있다는 것을 시사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실용적인 결과\n\n귀하의 감성 분석 모델에 대한 영향:\n\n- 출력 품질 감소: 4분기에서 양자화된 LLaMA 3 8B 모델을 사용할 때 감성 분석의 전반적인 품질과 일관성이 감소할 수 있습니다.\n- 일관성 없는 성능: 더 많은 불일치를 발견할 수 있으며, 예상치 못한 중립적 감성 점수 또는 감성 분석 결과에서의 이상한 패턴이 나타날 수 있습니다.\n- 권고 사항: 이러한 관측을 바탕으로 LLaMA 3 8B 모델에 대해 더 높은 정밀도 수준(Q8 또는 FP16)을 사용하거나, 양자화 처리를 더 잘 다루는 Mistral 또는 Dolphin-Mistral과 같은 다른 모델을 고려하는 것이 좋을 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 금융 감성 분석을 위해서는 llama3_8b-instruct-sentiment_analysis-q5_K_M과 같은 세밀하게 조정된 모델을 사용하는 것이 좋습니다. 이러한 모델들은 일관되고 강력한 감성 탐지를 제공하는 우수한 성능으로 인해 권장됩니다. 이러한 모델들은 기본 모델에 비해 의미 있는 개선을 제공하여 더 신뢰할 수 있고 정확한 감성 분석을 보장합니다. 하지만 특히 Q4에서 LLaMA 3 8B 양자화에 대한 논란이 있어 조심이 필요하며 양자화 기술에 대한 추가 연구와 최적화가 필요합니다.\n- Unsloth 노트북을 사용한 세밀한 조정은 LLaMA 3 8b 및 Mistral 7b와 같은 오픈 언어 모델에서 자신의 데이터를 세밀하게 조정할 수 있는 비교적 저렴한 경로를 제공합니다.\n- 함수 호출에 사용할 수 있는 신뢰할 수 있는 JSON 결과를 얻을 수 있습니다. 조정되지 않은 경우에는 특별한 프롬프트가 필요하지만 할 수 있습니다.\n- 감성 분석을 위해 세밀하게 조정된 LLaMA 3 8B는 몇 가지 장점을 제공합니다. 전문 프롬프트 트릭이 필요하지 않으며 모든 양은 낮은 분산과 적절한 신뢰도를 가지며 속도가 약간 향상되었습니다(프롬프트에 필요한 토큰 수가 줄어듦).\n- 데이터셋 및 훈련 시간에 개선할 여지가 있습니다. 합성 데이터 프롬프트를 조정해야 하며 1 epoch보다 길게 실행하면 손실이 감소하는 것으로 보입니다.\n- 웹 스크래핑은 복잡할 수 있으며, Yahoo Finance에서 스크래핑할 때 동일한 기사에 여러 회사가 언급되거나 유료 구독이 필요한 기사가 발생할 수 있습니다.\n- 특별한 시스템 프롬프트와 5번 예제를 사용하면 Llama 3 8B 모델이 모든 단계의 양자화 수준에서 올바른 JSON을 생성할 때 100%의 성공률을 달성합니다. 그러나 감성 점수의 변동성이 더 높으며 높은 신뢰도를 유지하면서 잠재적인 과신을 나타냅니다.\n- 동일한 시스템 프롬프트와 5번 예제를 사용하는 Mistral 7b Instruct는 FP16 양자화 수준까지도 올바른 JSON을 제대로 출력하지 못하는 경우가 종종 있습니다.\n- Dolphin-Mistral 7b-v2.8은 베이스 Mistral 7b보다 감성 분석에서 훨씬 우수한 성능을 보입니다. 특별한 프롬프트를 사용하면 100%의 성공률을 달성할 수 있습니다. 이는 Mistral 7b 베이스가 효과적으로 세밀하게 조정될 수 있다는 것을 시사합니다.\n\n## 다음 단계\n\n- 세밀한 조정을 위해서는 더 많은 시간과 노력이 필요합니다.\n- 다른 모델들에 대해 세밀하게 조정해 보세요. LLaMA 3는 특히 하위 양자화에서는 최고가 아닐 수 있습니다. Mistral-7b나 심지어 Phi-3을 시도하고 테스트 리포를 사용하여 결과를 비교해보세요.\n- 데이터셋을 향상시키세요. 이는 주로 개념 증명이었으므로 사용 가능한 데이터가 훨씬 많이 있습니다.\n- 숫자를 변경할 수 있는 산업 데이터 프롬프트와 특별한 프롬프트를 함께 조정해 보세요.\n- 합성 훈련에 더 많은 비용을 지불하세요. 이 세트가 구축된 후 GPT-o가 출시되었는데, 이는 50% 저렴하며 Batch API를 사용하고 24시간 이내에 작업을 완료할 경우 더 큰 할인을 받을 수 있습니다.\n- 우리가 한 세밀한 조정은 1 epoch(데이터 세트를 완전히 통과하는 것)만 포함했습니다. 더 오랜 시간 훈련하면 손실이 더욱 감소할 수 있습니다.\n\n## 마무리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서 다룬 기술들로 사용자 지정 데이터를 사용하여 세밀하게 조정된 모델을 자신있게 만들 수 있습니다. 우리의 연구 결과는 세밀하게 조정된 변형이 특별한 프롬프트가 필요하지 않고, 빠르고 효율적인 결과물을 얻기 위한 주목할만한 성능 향상을 제공한다는 것을 보여줍니다.\n\n낮은 양자화 수준에서 세밀하게 조정된 모델을 평가하는 것은 높은 변동성과 자신감으로 인해 도전적일 수 있으며, 신중한 분석이 필요합니다. 향후 글에서는 더 많은 통찰을 위해 다른 기본 모델을 세밀하게 조정하는 것을 탐구할 것입니다.\n\n도움이나 질문이 있으면 언제든지 연락해 주세요. 계약에 대해서도 가능하니 문의해 주세요. 프로젝트에 행운을 빕니다~ 세밀한 조정 재밌게 하시길 바랍니다!","ogImage":{"url":"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png"},"coverImage":"/assets/img/2024-05-18-ElevatingSentimentAnalysis_0.png","tag":["Tech"],"readingTime":23},{"title":"아직도 파이썬으로 엑셀 파일을 읽으세요? 1000배 더 빠른 방법이 있어요","description":"","date":"2024-05-18 21:32","slug":"2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay","content":"\n\n## 전문 기술로 번개처럼 빠른 데이터 처리 능력을 발휘하세요\n\n![이미지](/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png)\n\n파이썬 사용자로써 비즈니스 전문가들이 종종 정보를 Excel 또는 CSV 형식으로 공유하기 때문에 엑셀 파일을 처리하는 데 자주 사용됩니다. 그러나 파이썬은 엑셀 파일을 다룰 때 속도가 느릴 수 있다는 점에 유의해야 합니다.\n\n본 글에서는 Python에서 데이터를 로드하는 다섯 가지 방법을 소개하겠습니다. 이 토론이 끝나면 속도가 세 개의 자릿수가 높아져, 프로세스가 엄청나게 빨라질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실험 설정\n\n10개의 엑셀 파일을 로드해야 한다고 가정해 봅시다. 각 파일은 20,000개의 행과 25개의 열을 포함하며, 총 약 70MB의 데이터가 있습니다. 이 시나리오는 SAP와 같은 ERP 시스템에서 트랜잭션 데이터를 Python으로 분석하기 위해 전송할 때 일반적으로 발생하는 상황입니다.\n\n먼저, 이 더미 데이터를 생성하고 필요한 라이브러리를 가져와 환경을 설정할 것입니다 (이후 피클 및 joblib와 같은 라이브러리 사용의 구체적인 내용에 대해 나중에 논의할 것입니다).\n\n```js\nimport pandas as pd\nimport numpy as np\nfrom joblib import Parallel, delayed\nimport time\n\nfor file_number in range(10):\n    values = np.random.uniform(size=(20000, 25))\n    pd.DataFrame(values).to_csv(f\"더미 {file_number}.csv\")\n    pd.DataFrame(values).to_excel(f\"더미 {file_number}.xlsx\")\n    pd.DataFrame(values).to_pickle(f\"더미 {file_number}.pickle\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Python에서 데이터를로드하는 5 가지 방법\n\n# 1: Pandas를 사용하여 Excel 파일로드\n\n가장 간단한 방법으로 Excel 파일을로드하는 방법부터 시작하겠습니다. Pandas DataFrame을 초기화하고 각 Excel 파일을 순차적으로 추가합니다. 이 접근 방식은 여러 소스에서 데이터를 컴파일하여 분석을 위한 단일 구조로 제공합니다.\n\n```python\nstart = time.time()\ndf = pd.read_excel(\"Dummy 0.xlsx\")\nfor file_number in range(1,10):\n    df.append(pd.read_excel(f\"Dummy {file_number}.xlsx\"))\nend = time.time()\nprint(\"Excel:\", end - start)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약 50초 정도 소요됩니다. 상당히 느린 속도네요.\n\n저희 Excel 파일을 CSV 형식으로 변환한 후, 로딩 시간이 크게 개선되어 0.63초로 단축되었습니다. 이는 이전보다 거의 10배 빠른 속도입니다. Python은 일반적으로 CSV 파일을 Excel 파일보다 빠르게 처리하며, 종종 100배까지 빠를 수 있습니다. 따라서 CSV 파일을 사용하면 대규모 데이터셋을 처리하는 데 매우 효율적인 전략일 수 있습니다.\n\n그러나 주목할 만한 단점은 CSV 파일이 일반적으로 .xlsx 파일보다 큰 파일 크기를 갖는다는 것입니다. 예를 들어, 우리의 예제에서 CSV 파일은 각각 9.5MB이지만, .xlsx 파일은 단 6.4MB밖에 되지 않습니다.\n\n# 3: Pandas 데이터프레임의 더 똑똑한 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 데이터 로딩 프로세스를 더 향상시키기 위해, Pandas DataFrames를 만드는 방식을 최적화할 수 있습니다. 기존 DataFrame에 각 파일을 직접 추가하는 대신에, 시간이 많이 소요될 수 있으므로:\n\n1. 각 Excel 또는 CSV 파일을 별도의 DataFrame으로 로드합니다.\n2. 이러한 DataFrames를 리스트에 저장합니다.\n3. 마지막으로, 리스트의 모든 DataFrames를 단일 DataFrame으로 연결(concatenate)합니다.\n\n이 방법은 DataFrame을 반복적으로 확장하는 데 따른 오버헤드를 줄이기 때문에 일반적으로 파일마다 점진적으로 추가하는 것보다 빠릅니다.\n\n```python\nstart = time.time()\ndf = []\nfor file_number in range(10):\n    temp = pd.read_csv(f\"Dummy {file_number}.csv\")\n    df.append(temp)\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"CSV2:\", end - start)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업 테이블을 Markdown 형식으로 변경하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nstart = time.time()\ndef loop(file_number):\n    return pd.read_csv(f\"Dummy {file_number}.csv\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"CSV//:\", end - start)\n```\n\n한 개의 코어 버전과 비교했을 때 속도가 두 배로 증가했습니다. 그러나 코어 수를 늘릴수록 성능이 선형적으로 증가하지는 않는다는 점을 명심해야 합니다. 예를 들어, M1 칩을 장착한 Mac Air에서 8개의 코어를 사용하는 경우, 속도가 2배 증가하는 것을 확인했습니다. 8배가 아닙니다.\n\n## Joblib을 사용한 간단한 병렬화\n\nJoblib은 병렬 처리를 위해 설계된 간단한 Python 라이브러리입니다. 리스트 내포와 유사하게 작동하지만 한 가지 중요한 차이가 있습니다. 각 반복이 별도의 스레드에서 실행된다는 것입니다. 이 접근 방식을 통해 작업을 동시에 처리할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef loop(file_number):\n    return pd.read_csv(f\"Dummy {file_number}.csv\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\n\n#위 코드와 동일한 기능\ndf = [loop(file_number) for file_number in range(10)]\n```\n\n## 5: Pickle 파일 활용하기\n\n데이터 저장 및 검색 프로세스를 더 빠르게 하려면 pickle 파일을 사용하는 것을 고려해보세요. Pickle은 Python 전용 형식으로, 객체를 직렬화하고 역직렬화하는 데 사용되며, .csv 파일보다 빠른 데이터 로드를 가능하게 합니다.\n\n그러나 pickle 파일의 중요한 단점은 사람이 읽을 수 없다는 것입니다. .csv 파일과 달리 pickle 파일을 텍스트 편집기나 스프레드시트 프로그램으로 열어 직접 내용을 볼거나 수정할 수 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nstart = time.time()\ndef loop(file_number):\n    return pd.read_pickle(f\"Dummy {file_number}.pickle\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"Pickle//:\", end - start)\n```\n\n우리는 처리 시간을 성공적으로 80% 줄였어요!\n\n전반적으로, 피클 파일로 작업하는 것이 `.csv` 파일을 사용하는 것보다 훨씬 빠릅니다. 하지만 이 특정 예제에서는 그렇게 많은 저장 공간을 차지하지 않습니다.\n\n실제로 시스템은 일반적으로 데이터를 피클 형식으로 직접 내보내지 않아요. 다음 상황에서 피클 파일을 사용하는 것을 권장합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 내부 파이썬 사용을 위한 정보: 파이썬 프로세스에서 데이터를 저장하고 해당 데이터를 엑셀이나 다른 파이썬이 아닌 환경에서 열 필요가 없는 경우, 데이터프레임을 피클 파일로 저장하세요. 이는 파이썬 스크립트나 응용 프로그램 내에서 재사용할 데이터에 이상적입니다.\n\n2. 빈번한 파일 액세스를 위한 정보: 동일한 파일을 반복적으로 로드하는 경우, 초기 로드 후에 해당 파일을 피클로 저장하는 것이 효율적입니다. 향후 프로세스에서는 .csv 파일을 로드하는 느린 과정을 건너뛰고 피클 파일로 직접 로드할 수 있습니다.\n\n예시: 매달 업데이트되는 거래 데이터를 관리할 때, 첫 번째 로드 이후 각 달의 데이터를 .csv에서 .pickle로 변환할 수 있습니다. 이를 통해 매달 새로운 데이터가 도착할 때마다 피클 형식의 기존 데이터에 빠르게 액세스할 수 있어서 워크플로우를 간소화할 수 있습니다.\n\n# 추가 정보: 병렬로 엑셀 파일 로드하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExcel 파일을 받은 상황에서 직접 작업해야 할 때, 병렬 처리를 사용하여 효율성을 높일 수 있습니다. 다른 형식과 마찬가지로 `joblib` 라이브러리를 사용하여 이러한 파일을 병렬로 로드할 수 있습니다.\n\n이를 구현하려면 루프 내에 있는 함수를 Excel 파일을 처리할 수 있도록 조정해야 합니다. 이 수정은 Excel 파일을 로드하는 함수를 사용하고, 그런 다음 이러한 작업을 `joblib`을 사용하여 여러 프로세서에 분산하는 것을 포함합니다. 이 방식을 사용하면 여러 Excel 파일을 동시에로드하는 데 걸리는 시간을 크게 줄일 수 있습니다.\n\n```js\nstart = time.time()\ndef loop(file_number):\n    return pd.read_excel(f\"Dummy {file_number}.xlsx\")\ndf = Parallel(n_jobs=-1, verbose=10)(delayed(loop)(file_number) for file_number in range(10))\ndf = pd.concat(df, ignore_index=True)\nend = time.time()\nprint(\"Excel//:\", end - start)\n```\n\n로딩 시간을 70% 줄여 50초에서 13초로 단축했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아울러 병렬 로딩 프로세스를 활용하여 필요할 때마다 pickle 파일을 실시간으로 생성할 수도 있습니다. 이렇게 함으로써 파일을 다시 로드해야 하는 경우에 pickle 파일이 제공하는 크게 빠른 로딩 시간을 활용하여 데이터에 거의 즉각적으로 액세스할 수 있습니다. 이 방법은 초기 로딩 프로세스를 최적화하는 데 그치지 않고 동일한 데이터셋과의 미래 상호작용을 간소화합니다.\n\n# 요약\n\n다양한 데이터 로딩 방법을 통해 대규모 데이터셋을 처리하는 데 걸리는 시간을 크게 단축했습니다:\n\n- Excel 파일: 초기 로딩에는 50초가 걸렸습니다.\n- CSV 파일: 0.63초로 개선되었습니다.\n- 더 스마트한 CSV 로딩: 0.62초로 더욱 개선되었습니다.\n- 병렬 CSV 로딩: 0.34초로 줄었습니다.\n- 병렬 Pickle 로딩: 0.07초로 급격하게 줄었습니다, 1초의 1/10 이하입니다.\n- 병렬 Excel 로딩: 13.5초로 줄었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 결과들은 Python에서 데이터 로딩 작업의 성능을 향상시키기 위해 파일 형식을 최적화하고 병렬 처리를 활용하는 이점을 강조합니다.\n\n# 쉽게 이해할 수 있는 용어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 필자를 박수 치고 팔로우하기 꼭 잊지마세요! ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요.\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png"},"coverImage":"/assets/img/2024-05-18-DoYouReadExcelFileswithPythonThereisa1000xFasterWay_0.png","tag":["Tech"],"readingTime":7},{"title":"주기 코딩 시계열 피처에 대한 원-핫 인코딩 대안","description":"","date":"2024-05-18 21:30","slug":"2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures","content":"\n\n시계열을 위한 머신러닝 모델을 훈련할 때는 대개 다음과 같은 시간 특성들을 사용하게 됩니다:\n\n- 시간\n- 요일\n- 월\n- 주 또는 연도의 일\n- 기타\n\n타임스탬프 열을 이러한 종류의 특성으로 변환하는 것은 꽤 쉽습니다. 시간 열을 datetime 객체로 변환한 후 (pd.to_datetime을 사용하여), .dt를 사용하여 여러 시계열 특성을 추출할 수 있습니다.\n\n```js\ndf['Hour']=df['Datetime'].dt.hour\ndf['Month']=df['Datetime'].dt.month\ndf['Dayofweek']=df['Datetime'].dt.dayofweek\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고로, 이 예제에서 사용할 데이터셋은 CC0 공개 도메인 라이선스이며 시간당 전기 사용량 데이터셋입니다. 에너지 소비 데이터셋은 일반적으로 시계열 데이터이며, 최종 목표는 과거 데이터를 사용하여 미래의 소비를 예측하는 것이므로 이것은 좋은 사용 사례입니다. 온도, 습도 및 바람 세기와 같은 기타 외부 기능도 에너지 소비에 영향을 미칠 수 있지만, 여기서는 시계열 기능을 추출하고 변환하는 데 초점을 맞출 것입니다.\n\n![Image](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png)\n\n멋지죠! 이제 사용 가능한 기능이 0에서 3개로 늘었습니다.\n\n하지만 너무 빨리 생각하지 마세요! ML에서는 이러한 기능을 그대로 모델에 전달할 수 없다는 것을 알고 있습니다. 대부분의 모델은 이러한 입력을 숫자 기능으로 해석할 것이며, 시계열 기능은 숫자가 아니라 범주형이라는 사실입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에너지 소비에 관한 경우, 하루 중 특정 피크 시간에는 더 높은 소비가 발생할 가능성이 높습니다. 또한 소비가 낮은 특정 시간대도 있습니다. 각 시간은 어떤 의미에서 자체적인 카테고리입니다.\n\n이 데이터셋의 특정 부분을 자세히 살펴보면 이를 확인할 수 있습니다. 하루 내내 소비 패턴이 명확히 나타납니다 — 사용량은 동일한 시간대(오후 5-6시)에 피크를 찍고, 새벽 5-7시에 가장 낮습니다.\n\n![image](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_1.png)\n\n물론, 이러한 패턴은 다른 요소들과의 복잡한 상호작용이 있습니다. 예를 들어, 연도별/월별 시간 및 요일 등의 특징을 모델에 최대한 많이 포함하려고 노력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 일반적인 방법처럼 표를 Markdown 형식으로 변경할 수 있어요. \n\n\n| Column 1 | Column 2 | Column 3 |\n|----------|----------|----------|\n| Apple    | Orange   | Banana   |\n| Car      | Book     | Tree     |\n| Sun      | Moon     | Star     |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncolumns_to_encode = ['Hour', 'Month', 'Dayofweek']\n\ndf = pd.get_dummies(df, columns=columns_to_encode)\n```\n\n새로운 특성 집합이 생성됩니다.\n\n![이미지](/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_2.png)\n\n볼 수 있듯이, 많은 특성들이 생성되었습니다. 우리는 3개의 열 (시간, 월, 요일)에서 40개가 넘게 되었습니다. 시간 시리즈 특성을 인코딩해야 하는 경우 더 많은 특성을 추가하면서 점점 더 복잡해질 수 있습니다. 이러한 많은 특성을 추적하기 어려워질 수 있으며, 특히 데이터베이스에 특성을 저장하거나 특성 중요도를 시각화하려는 경우 (매우 난잡한 그래프를 원치 않는 경우)에 더 어려워질 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 대안: 순환 인코딩\n\n시계열 피처는 본질적으로 주기적입니다. 시계가 24:00(자정)을 가르킬 때 새로운 날이 시작되고 다음 시간은 1:00(오전 1시)입니다. 숫자 1과 24는 사실적으로 숫자 차이가 가장 큽니다만, 1은 24에 가까운 것처럼 23과 같은 사이입니다. 왜냐하면 이들은 주기적인 관계에 있기 때문입니다.\n\n그래서 시계열 피처를 수치적으로 표현하는 또 다른 방법은 타임스탬프를 사인과 코사인 변환으로 변환하는 것입니다. 이를 통해 결과적으로 하루 중 시간, 한 주 중 시간 또는 연도 중 시간을 알 수 있습니다.\n\n우리가 one-hot 인코딩으로 하는 것처럼 날짜 및 시간 값을 범주형 피처로 변환하는 대신, 일부 값은 가깝게 유지되고(예: 자정과 새벽 1시), 다른 값은 멀어집니다(예: 자정과 정오). 이러한 유형의 정보는 one-hot 인코딩을 할 때 손실됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사인과 코사인은 단위 원에서 나온 것이며, 아이디어는 타임스탬프가 사인 및 코사인 좌표로 표현되는 이 원 위에 어디에 있는지 매핑하는 것입니다. 원의 오른쪽 부분을 참조로 생각해봅시다 (아래 차트에서 0으로 표시됩니다) 또는 실제 24시간 시간대의 00:00(자정)을 나타내는 것, 이를 4개의 6시간 기준점으로 나누어 원에 시간을 매핑할 수 있도록 합니다.\n\n단위 원을 반시계 방향으로 이동할수록 값이 증가되고 pi/2(또는 90도)인 지점은 6:00 오전과 같고, pi(180도) 또는 12:00 오후 및 3pi/2 또는 6:00 오후 및 마지막으로 다시 자정의 0으로 돌아갑니다. 이러한 각각의 기준점 사이의 각 시점에는 고유한 좌표가 있습니다. 이렇게 하면 24시간의 일일 주기를 사인과 코사인을 사용하여 표현할 수 있습니다.\n\n다른 주기, 예를 들어 주간이나 연간 시간에도 똑같이 적용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPython에서 이 작업을 수행하려면 먼저 datetime을(제 경우에는 시간별 타임스탬프) 숫자 변수로 변환해야 합니다. 이 열을 pd.Timestamp.timestamp 객체로 변환하여 각 타임스탬프를 유닉스 시간(1970년 1월 1일 이후 경과한 초 수)으로 변환합니다.\n\n이제 이 숫자 열을 사인 및 코사인 기능으로 변환할 수 있습니다.\n\n```python\n# Convert datetime into a numerical seconds timestamp object \n# (tells you the date/time in seconds)\ntimestamp_s = df['Datetime'].map(pd.Timestamp.timestamp)\n\n# Get the number of seconds for each time period\nday = 24*60*60\nweek = day*7\nyear = day*(365.2425)\n\n# Transform using sin and cos\n# Time of day\ndf['Day_sin'] = np.sin(timestamp_s * (2 * np.pi / day))\ndf['Day_cos'] = np.cos(timestamp_s * (2 * np.pi / day))\n\n# Time of week\ndf['Week_sin'] = np.sin(timestamp_s * (2 * np.pi / week))\ndf['Week_cos'] = np.cos(timestamp_s * (2 * np.pi / week))\n\n# Time of year\ndf['Year_sin'] = np.sin(timestamp_s * (2 * np.pi / year))\ndf['Year_cos'] = np.cos(timestamp_s * (2 * np.pi / year))\n```\n\n넓게 볼 때 이런 과정이 진행됩니다: 우선, 타임스탬프를 초에서 라디안으로 변환합니다. 2 * np.pi 부분은 전체 원/주기에 2 * pi 라디안이 있다는 이유입니다. 이 변환 후에 나누는 주기는 초 단위의 사이클 기간(하루, 일주일 또는 연도)입니다. 다음으로, 이 변환된 값과 사인 및 코사인을 사용하여 각 타임스탬프를 주기 내에서의 위치를 나타내는 고유한 각도로 매핑합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 기간이 하루인 경우, 하루의 시작에 대한 타임스탬프는 0 라디안으로 매핑되고, 하루의 중간에 있는 타임스탬프는 np.pi 라디안으로 매핑되며, 하루의 끝에 있는 타임스탬프는 2 * np.pi 라디안으로 매핑됩니다.\n\n마지막으로, 결과적인 계산에 대해 사인과 코사인을 취하여 단위 원 위의 실제 x 및 y 좌표 값을 얻습니다. 이 값들은 항상 -1과 1 사이에 있을 것입니다.\n\n이 접근 방식을 통해 각 원래 시계열 특성(예: 하루의 시간, 요일, 연의 월)이 이제 해당 원래 특성의 삼각함수값 (사인 및 코사인)으로만 매핑되어, 24개, 7개, 12개 등이 아니라 오직 2개의 새로운 특성으로만 매핑됩니다.\n\n## 이 접근 방식의 단점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 사용할 때 주의해야 합니다. 매우 편리하고 효율적이지만, 몇 가지 단점과 주의사항이 있습니다:\n\n- 시간, 월 등 특정 시간대 값이 일관되게 다른 데이터셋에 대해 원-핫 인코딩이 더 잘 작동할 수 있습니다. 예를 들어, 사용량이 지나치게 높아지는 12PM이나 특정 달에 높은 물량이 발생하는 데이터셋이 있습니다. 12PM-2PM과 같이 범위가 있는 데이터셋에서는 순환 인코딩과 같은 유연한 방법이 더 정확할 수 있습니다.\n- 이러한 유형의 인코딩은 딥 러닝/신경망에는 잘 작동하지만, 랜덤 포레스트와 같은 트리 분할 알고리즘에는 적합하지 않을 수 있습니다. 그 이유는 보통 1개의 특성을 나타내는 단일 타임스탬프가 2개의 특성으로 분할되고, 트리 기반 알고리즘은 한 번에 한 특성씩 분할 결정을 내립니다. 따라서 모델은 실제로 1개의 원래 특성에 대응하는 좌표 쌍인데도 불구하고 2개의 특성을 별도로 처리할 것입니다.\n\n그러나 이는 결코 트리 기반 알고리즘에 순환 인코딩을 사용하지 말아야한다는 뜻은 아닙니다. 실제로 저는 랜덤 포레스트 모델에서 이 유형의 인코딩을 사용하고 좋은 결과를 얻었습니다. 데이터셋에 따라 다를 것이기 때문에 여전히 교차 검증 및 최종 홀드아웃 테스트 세트에서 메트릭을 실행하여 확신할 필요가 있습니다.\n\n게다가, 사용하기 전에 원-핫 인코딩 결과를 순환 인코딩 결과와 비교하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- P. Bescond, 주기적인 특성 인코딩, 시간 문제입니다! (2020), Towards Data Science\n- R. Mulla, 시간당 에너지 소비 (2022년 8월), Kaggle에서 2024년 5월에 조회\n- TensorFlow, 시계열 예측 (2024), TensorFlow Core","ogImage":{"url":"/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png"},"coverImage":"/assets/img/2024-05-18-CyclicalEncodingAnAlternativetoOne-HotEncodingforTimeSeriesFeatures_0.png","tag":["Tech"],"readingTime":6},{"title":"RaspirriV1로 라즈베리 파이 기반의 자동 급수기 만들기","description":"","date":"2024-05-18 21:28","slug":"2024-05-18-RaspirriV1ARaspberryPibasedirrigator","content":"\n\n몇 년 전에 제가 작은 잔디 정원을 관리하기 위한 책임을 맡아 상업용 스크린 LCD를 갖춘 자동 급수 시스템을 사용했어요. 그러나 COVID-19 대유행으로 인한 봉쇄 기간에 LCD 화면이 고장나면서 프로그래머 메뉴에 접근할 수 없게 되었어요.\n\n해결책을 찾기 위해 고장 난 LCD 화면을 모바일 앱으로 교체하고, 급수 시스템을 Raspberry Pi Zero로 대체하기로 결정했어요. 이 대체 방안을 추구한 동기는 시장에서 다른 상업적인 솔루션에 비해 경제적인 측면과 나의 새로운 프로젝트에 도전하는 즐거움이었어요. 게다가, 이 노력은 그리스 테살로니키에서 열린 Voxxed Days Conference에서 만난 Flutter 개발자인 Tom Makrodimos와의 협력으로 이끌어졌어요!\n\n# 프로젝트 개요\n\n제 주요 목표 중 하나인 기존 급수 시스템을 Raspberry Pi로 대체하기 위해 프로젝트를 `RaspirriV1`로 적절하게 명명했어요. 이는 Raspberry Irrigator Version 1을 상징하는 이름이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 소프트웨어는 Python을 기반으로 하며, RaspirriV1 모바일 앱은 Flutter를 기반으로 합니다.\n\n# 개발 여정\n\n모바일 앱 및 서버 측 구성 요소의 아키텍처 설계와 구현을 시작하기 전에, 우리는 잠재적인 하드웨어적 과제에 대해 논의하였습니다. 그 시점에서, 라즈베리 파이가 24볼트 전원 공급이 필요한 전기 밸브를 제어할 수 있는 내재된 능력이 부족하다는 것을 알았습니다. 이 장애를 인식한 후, 전자 기술에 대한 전문 지식을 보유한 두 명의 친구인 Lambros Anastasopoulos와 Dimitris Iliopoulos에게 연락했습니다. 그들은 즉시 이 과제를 확인하고 해결책을 종이에 스케치하여 Proof-of-Concept를 스티로폼 보드에 만들었습니다:\n\n![사진](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전자 연결의 정확성을 확인하고 LED의 켜고 끄기 기능을 검증하기 위해 간단한 Python 구현을 빠르게 시작했습니다. Concept 증명은 성공적인 기능을 보여줌으로써 우리가 다음 단계로 진행할 확신을 더했습니다:\n\n구성품 비용은 선택한 특정 모델에 따라 다릅니다. 그러나 일반적인 추정 금액은 다음과 같습니다:\n\n- Raspberry Pi (Zero-4): $35–$55\n- Reley: $5–$10\n- 24V DC 전원 공급기: $10\n- LED: $1–$2\n- 전류 제한 저항기: $0.50–$1\n- Step-down 변환기: $5\n\n총액: $57–$83$\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 나와 있는 회로도는 라즈베리 파이를 사용하여 릴레이를 제어하는 간단한 회로를 보여줍니다. 릴레이는 LED나 모터와 같은 고출력 부하를 켜고 끄는 데 사용됩니다. 이 회로는 24V DC 전원 공급기로 구동됩니다.\n\n라즈베리 파이는 디지털 출력 핀을 사용하여 릴레이에 연결됩니다. 라즈베리 파이가 출력 핀을 HIGH로 설정하면 릴레이 코일이 활성화되고 릴레이 접점이 닫힙니다. 이로써 24V 전원 공급기에서 하중으로 전류가 흐를 수 있습니다. 라즈베리 파이가 출력 핀을 LOW로 설정하면 릴레이 코일이 비활성화되고 릴레이 접점이 열립니다. 이로써 하중으로 전류가 흐르지 않게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회로 내 LED는 부하가 켜졌을 때 표시하는 데 사용됩니다. LED는 24V 전원 공급원을 통해 전류 제한 저항을 통해 연결됩니다. 전류 제한 저항은 LED가 너무 많은 전류를 빨아들이고 소멸되는 것을 방지하기 위해 필요합니다.\n\n회로 내 Step-down 컨버터는 24V DC 전원 공급 전압을 5V DC로 변환하는 데 사용됩니다. 5V DC 전압은 Raspberry Pi를 구동하는 데 사용됩니다.\n\n# 소프트웨어 아키텍처\n\n![Image](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 UML 다이어그램에 따라 사용자가 모바일 앱을 라즈베리 파이 서버와 블루투스 통신을 통해 페어링하고 인터넷을 통해 제어하는 단계는 다음과 같습니다:\n\n단계 1: 사용자는 모바일 앱을 시작하고 설정-`연결 초기화'를 클릭하여 모바일 앱을 서버와 페어링합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_3.png\"/\u003e\n\n단계 2: 사용자는 계속을 클릭하고 RaspirriV1 서버에서 사용할 사용 가능한 WiFi 네트워크 중 하나를 선택합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_4.png)\n\n### 단계-3: 준비 완료!!! 이제 앱을 사용하여 인터넷을 통해 관정을 제어하고 일정을 설정하며 시스템 상태를 모니터링할 수 있습니다. 앱을 처음 실행할 때는 밸브가 활성화되어 있지 않습니다. 라즈베리 파이에서 밸브를 활성화하고 해당 포트를 앱에서 선택할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_5.png)\n\n### 단계-4: 그런 다음 토글 버튼으로 밸브를 켜거나 끄거나 각 밸브에 대한 일정 프로그램을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Program creation](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_6.png)\n\nSTEP-5: To create a program, select days, start time, and duration. You can change the valve name if desired and then click Save. A new schedule will be created and saved in the raspirri-server storage.\n\n![Schedule creation](/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_7.png)\n\n# Raspberry Pi Server\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라스피리V1을 위한 서버 소프트웨어는 세 가지 주요 모듈로 구성되어 있습니다:\n\n이 구성 요소는 클라우드 MQTT 브로커와의 통신을 설정하여 시스템 설정의 온라인 구성 및 유지 관리를 용이하게 합니다.\n\nBluetooth 특성을 등록하기 위해 설계된 이 모듈은 휴대 기기를 라스피리V1과 초기 페어링할 수 있게 합니다. 이 페어링 프로세스는 모바일 앱을 IoT 장치와 연결하기 위해 필요한 필수 최소 구성을 보장합니다.\n\nMQTT 모듈의 상태를 모니터링하고 필요한 경우 다시 시작하는 이 모듈이 구현되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 모듈은 Raspbian OS에서 서로 다른 systemd 서비스로 시작됩니다. 사용된 Python 라이브러리는 다음과 같습니다:\n\n```js\nAPScheduler==3.10.4\n\n# Linting/Tooling\nblack\u003e=23.3.0\nbuild\u003e=0.10.0\nbump2version==1.0.1\ncodecov\u003e=2.1.13\nconfigparser==6.0.0\ncoverage==7.3.2\nDeprecated==1.2.13\ndistro==1.7.0\n\n# Raspirri\nfastapi[all]==0.109.1\nfeedparser==6.0.11\nfuture==0.18.3\ngetmac==0.8.3\ninvoke==2.2.0\nisort\u003e=5.12.0\nlockfile==0.12.2\nloguru==0.7.2\n\n# Documentation\nmkdocs\u003e=1.4.3\nmkdocs-material\u003e=9.1.14\nmkdocstrings\u003e=0.21.2\nmkdocstrings[python]\u003e=0.9.0\nmypy\u003e=1.3.0\npaho-mqtt==1.6.1\npre-commit\u003e=3.3.2\nPygments\u003e=2.15.1\npyright\u003e=1.1.309\n\n# Testing\npytest\u003e=7.4.3\npytest-asyncio==0.21.1\npytest-benchmark\u003e=4.0.0\npytest-cov\u003e=4.1.0\npytest-mock==3.12.0\npytest-ordering==0.6\nrequests==2.31.0\nruff\u003e=0.0.270\n\n# Linting/Tooling\nsetuptools\u003e=67.8.0\nsubprocess.run==0.0.8\nuvicorn==0.27.0\n```\n\n# Flutter 모바일 앱\n\nRaspirriV1 모바일 앱은 RaspirriV1 서버 소프트웨어의 자동 급수 시스템 컨트롤러입니다. Flutter 프레임워크와 Dart 프로그래밍 언어로 작성되었으며 Android 5 (롤리팝, API 21) 이후 버전의 모바일폰과 태블릿을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핵심 구성 요소\n\nFlutter로 제작된 Android 앱은 시각적으로 직관적인 인터페이스를 제공합니다. 크로스 플랫폼 기능을 통해 일관된 경험을 제공하며 Flutter의 핫 리로드 기능을 추가하여 개발 및 테스트를 쉽게 할 수 있습니다.\n\n앱은 상태를 원활하고 효율적으로 관리하기 위해 Riverpod 패키지를 활용합니다.\n\nRiverpod는 반응형 캐싱 및 데이터 바인딩 프레임워크로, 애플리케이션의 상태를 쉽게 구성, 공유 및 업데이트할 수 있어 원활하고 유지보수 가능한 개발 경험을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 시스템의 핵심은 MQTT 프로토콜에 있습니다. 이 프로토콜을 통해 안드로이드 앱과 라즈베리 파이 서버 간에 실시간 통신이 가능해집니다. Mqtt_client 패키지는 메시지를 신속하고 효율적으로 교환하여 관개 시스템을 빠르고 반응적으로 제어할 수 있도록 도와줍니다.\n\n초기 설정 과정을 간단하게 하기 위해 초기화 단계에서 Bluetooth 통신을 위해 flutter_blue_plus 패키지를 사용합니다. 이를 통해 안드로이드 앱이 중요한 Wi-Fi 자격 증명을 신속하게 라즈베리 파이 서버에 전송하여 인터넷에 안전하고 안정적으로 연결할 수 있게 됩니다.\n\n기기 설정에 따라 자동으로 영어 및 그리스어를 지원합니다. 아래에서 설명된대로 언어를 추가하는 것이 용이합니다.\n\n사용한 Flutter 패키지는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nenvironment:\n  sdk: '\u003e=3.1.0 \u003c4.0.0'\n\ndependencies:\n  collection: ^1.18.0\n  duration_picker: ^1.1.1\n  flutter:\n    sdk: flutter\n  flutter_blue_plus: ^1.28.10\n  \n  flutter_localizations:\n    sdk: flutter\n  \n  flutter_riverpod: ^2.4.5\n  google_fonts: ^6.1.0\n  http: ^1.1.2\n  intl: ^0.18.1\n  mockingjay: ^0.5.0\n  mocktail: ^1.0.3\n  mqtt_client: ^10.0.0\n  package_info_plus: ^5.0.1\n  rename_app: ^1.3.1\n  shared_preferences: ^2.2.2\n  typed_data: ^1.3.2\n  url_launcher: ^6.2.3\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  integration_test:\n    sdk: flutter\n\n  flutter_lints: ^2.0.0\n  flutter_native_splash: ^2.3.9\n  flutter_launcher_icons: ^0.13.1\n```\n\n## 지속적 통합\n\n현대 소프트웨어 개발에서 품질 표준이 각 빌드마다 일정하게 유지되도록 보장하려면 현재의 DevOps 도구를 활용해야 한다는 것은 부인할 수 없습니다. 이에 따라, 저희는 서버 및 모바일 앱 프로젝트 모두 GitHub Actions를 활용해 GitHub에서 구축되었습니다. GitHub Actions는 빌드, 테스트 및 릴리스 프로세스를 자동화할 수 있도록 하는 지속적 통합 및 지속적 전달(CI/CD) 플랫폼으로, 우리에게 이와 같은 기능을 제공했습니다.\n\n따라서, 우리의 저장소에 대한 각 pull request에 대해, 우리는 사전 커밋 포매팅 도구, 린터, 단위 테스트를 실행합니다. 이러한 단계가 모두 성공적으로 통과되면 해당 pull request를 병합할 수 있습니다. 마찬가지로, 저장소 소유자가 새로운 Git 태그를 생성하여 새 릴리스를 작성하고자 할 때, 모든 CI 절차가 시작됩니다. 모든 검사가 통과되면:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새 릴리스가 생성되어 릴리스 섹션에 업로드되었습니다.\n- CHANGELOG.md 파일이 자동으로 업데이트되어 이전 릴리스 이후의 최신 커밋이 반영되었습니다.\n\n# 데모\n\n# 향후 계획\n\n각 프로젝트의 이슈 섹션에는 구현을 기다리고 있는 여러 잠재적인 향상 사항이 기술되어 있습니다. 이 프로젝트의 상용화는 산업용 케이스를 개발하고 유료 클라우드 기반 MQTT 브로커를 활용함으로써 원활하게 달성할 수 있습니다. 다른 모든 구성 요소는 단일 밸브에 주력하여 우리의 지역 정원에서 여러 날 동안 엄격한 테스트를 거쳤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 프로젝트의 미래를 함께 만들어 나가는 것에 여러분을 초대합니다. 여러분의 협력, 피드백, 그리고 통찰력은 혁신을 이끌어가는 데 귀중한 자산입니다. 열렬한 지지자, 개발자, 또는 우리의 노력에 흥미를 느끼는 분이던, 언제든지 저희와 소통할 것을 장려합니다. 함께 새로운 가능성을 탐색하고, 기존 기능을 개선하며, 의미 있는 영향을 미칠 수 있습니다. 만약 이 프로젝트가 여러분을 영감을 주는 사례라면, 주변 사람들과 공유를 망설이지 마세요. 함께 놀라운 것을 만들어봅시다.\n\n# 참고 자료\n\n- 서버 Github 저장소\n- Flutter Github 저장소\n- 라즈베리 파이와 MQTT 가이드\n- GPIO 핀 연결 가이드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**사용한 도구 및 자원:** VSCode, Raspberry Pi, CodiumAI\n\n아래는 연락처 정보입니다! 이 프로젝트에 관한 질문이 있으시면 언제든지 이메일 보내주세요.\n\n마리오스 카라기아나폴루스 `mariosk@gmail.com` 톰 마크로디모스 `tom.makrodi@gmail.com`","ogImage":{"url":"/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_0.png"},"coverImage":"/assets/img/2024-05-18-RaspirriV1ARaspberryPibasedirrigator_0.png","tag":["Tech"],"readingTime":8},{"title":"REST 엔드포인트를 데이터 소스로 사용하는 GraphQL 쿼리 작성하기","description":"","date":"2024-05-18 21:26","slug":"2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource","content":"\n\n![image](/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_0.png)\n\n이 짧은 기사에서는 RESTful 엔드포인트에서 데이터를 가져오는 간단한 GraphQL 쿼리를 어떻게 생성할 수 있는지 살펴보겠습니다. 이를 위해 Node.js와 Apollo Server를 사용할 것입니다.\n\n이 기사에서는 예시로 간단한 사용자 리소스인 Users를 살펴보겠습니다. 이 글의 목표는 apollo GraphQL 서버를 사용하여 기존 REST 엔드포인트를 데이터 소스로 활용하는 쿼리를 작성하는 데 필요한 단계와 구성을 간략히 개요로 설명하는 것뿐입니다.\n\n## PlainEnglish.io에서 더 많은 내용 확인 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 무료 주간 뉴스레터를 구독해보세요. Twitter, LinkedIn, YouTube, 그리고 Discord에서도 팔로우해주세요.\n\n## 당신의 기술 창업품을 알림과 채용을 확대하려고 하세요? Circuit을 확인해보세요.\n\n이것이 응담하는 클라이언트에게 응답에서 투영되는 필드를 더 많은 제어를 제공하고 싶을 때 유용할 수 있습니다.\n\n자, 더 이상 말이 필요없으니 시작해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# GraphQL 프로젝트 초기화:\n\n새 디렉토리를 gserver로 만들고 cd gserver라고 입력하여 디렉토리를 변경해 봅시다.\n\n이제 yarn init -y로 프로젝트를 초기화해 봅시다.\n\n## Dependencies 추가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 주요하게 사용하는 의존성은 graphQL과 apollo-server 패키지입니다. 그러니 이들을 프로젝트에 추가해봅시다:\n\n```js\nyarn add apollo-server graphql\n```\n\n개발 중에 서버가 변경 사항이 생길 때 자동으로 다시 시작되도록 하려면 nodemon을 개발 의존성으로 추가해봅시다:\n\n```js\nyarn add --dev nodemon\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 우리의 package.json 파일은 다음과 같이 보일 것입니다:\n\n```js\n{\n  \"name\": \"gserver\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"apollo-server\": \"^3.10.2\",\n    \"graphql\": \"^16.6.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.19\"\n  }\n}\n```\n\n참고: 저는 패키지 매니저로 Yarn을 사용하고 있지만, npm을 사용해도 괜찮습니다.\n\n## index 파일을 생성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 루트에 index.js라는 파일을 만들어주세요. 이 파일은 우리의 GraphQL 서버의 진입점이 될 것입니다.\n\n```js\n// index.js\nimport { ApolloServer } from \"apollo-server\";\nconst server = new ApolloServer();\nserver\n  .listen({port: process.env.PORT || 5000})\n  .then(({url})=\u003e console.log(`서버 실행 중 : ${url}`));\n```\n\n기본적인 GraphQL 서버가 설정되었으니, package.json에 nodemon을 사용하여 개발 모드에서 시작하는 스크립트를 추가해봅시다:\n\n```js\n{\n...기존의 package.json 내용\n\"scripts\": {\n    \"dev\": \"nodemon index.js\"\n  }\n ... 남은 내용\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 스키마 생성하기:\n\n스키마는 우리가 GraphQL에서 쿼리와 뮤테이션을 위한 유형과 그 하위 구조를 정의하는 방법입니다.\n\n프로젝트 루트에 schema라는 디렉토리를 빠르게 생성해봅시다.\n\n스키마를 정의하기 위해 gql이라는 특별한 태그를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 스키마는 다음과 같이 정의될 수 있습니다:\n\n```js\n// schema/user.js\nimport { gql } from \"apollo-server\";\nexport const User = gql`\n  type User {\n    id: ID!,\n    email: String,\n    name: String\n  }\n``` \n\nUUID를 위해 우리는 graphQL에서 ID라는 특별한 타입을 사용하며, '!' 표시는 값이 null일 수 없음을 의미합니다.\n\n따라서 User라는 타입을 정의하고 사용자 객체에 대한 스키마를 생성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 쿼리 정의:\n\nGraphQL에서는 데이터를 가져오는 쿼리(REST 용어로는 GET 요청과 동일하다고 볼 수 있음)를 정의할 때 잘 정의된 스키마가 필요합니다. 이 예시에서는 기본 사용자 서비스 엔드포인트에서 모든 사용자를 가져오고자 합니다. 그러므로 모든 사용자를 가져오기 위한 쿼리를 정의해봅시다:\n\n```js\n// schema/query.js\nimport { gql } from \"apollo-server\";\nexport const Query = gql`\n  type Query {\n    users: [User]\n}\n```\n\n사용자 쿼리로 여러 사용자를 검색할 것이기 때문에 그 유형을 이전에 스키마에서 정의한 User 유형의 배열로 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n편의를 위해 스키마 디렉토리 아래에 인덱스 파일을 만들고 정의된 스키마를 다음과 같이 노출해봅시다:\n\n```js\n// schema/index.js\nexport { User } from './user.js';\nexport { Query } from './query.js';\n```\n\n# 서버 실행:\n\n저희가 정의한 스키마를 포함하는 서버의 진입점인 index.js를 수정해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// index.js\nimport { ApolloServer } from \"apollo-server\";\nimport { Query, User } from \"./schema/index.js\";\nconst server = new ApolloServer({typeDefs:[Query,User]});\nserver\n  .listen({ port: process.env.PORT || 5000 })\n  .then(({ url }) =\u003e console.log(`gserver at : ${url}`));\n```\n\n이제 터미널에서 `yarn dev`라고 입력해보세요:\n\n\u003cimg src=\"/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_1.png\" /\u003e\n\n브라우저를 http://localhost:5000 에서 열어볼 때, 모든게 잘 되었다면 다음 화면을 보게 됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_2.png\" /\u003e\n\n\"Query Your Server\" 버튼을 클릭하면 아폴로 스튜디오로 이동하게 되는데, 여기서 정의된 스키마를 찾을 수 있어요:\n\n\u003cimg src=\"/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_3.png\" /\u003e\n\n아직 많이 할 수 있는 것은 없어요. 그래서 다음 섹션에서 사용자 정보를 가져오기 위한 리졸버를 추가해볼게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 RESTful 서비스:\n\n저희는 현재 포트 3000에서 실행 중인 사용자 서비스가 있습니다. 현재 localhost:3000/users 엔드포인트에 대한 다음 응답을 반환합니다 :\n\n![이미지](/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_4.png)\n\n이것은 express 서버에서 실행 중인 전형적인 RESTful 엔드포인트입니다. 이미 구현되어 있으므로 많은 걱정할 필요가 없습니다. 이 기사의 초점은 기존 REST 엔드포인트와 graphQL 쿼리를 인터페이싱하는 것뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 데이터 소스 및 리졸버:\n\n이제 우리는 그래프큐엘 사용자 쿼리를 위에서 언급된 RESTful 엔드포인트에서 데이터를 가져오도록 매핑해야 합니다. 이를 하기 위해 dataSource를 정의하고 resolver에 매핑하는 방법을 살펴볼 수 있습니다.\n\n이 섹션에서는 Rest 엔드포인트에서 모든 사용자를 가져오기 위해 그것을 하는 방법을 살펴보겠습니다.\n\n## 사용자 데이터 소스:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 데이터 소스로 REST 엔드포인트를 사용할 것이기 때문에, 아폴로 팀이 만든 apollo-datasource-rest 패키지를 설치해봅시다. 이 패키지는 캐싱과 같은 중요한 기능을 다루므로 우리가 걱정할 필요가 없습니다.\n\n프로젝트에 패키지를 추가해봅시다:\n\n```js\nyarn add apollo-datasource-rest\n```\n\n이제 프로젝트 루트에 datasource라는 디렉토리를 만들어 다음과 같이 정의해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// datasource/users.js\nimport { RESTDataSource } from \"apollo-datasource-rest\";\nexport class UsersAPI extends RESTDataSource {\n  constructor(){\n    super();\n    this.baseURL = \"http://localhost:3000/\"\n  }\n  async getAllUsers() {\n    return this.get('users')\n  }\n}\n```\n\n`baseURL`는 우리 usersservice를 위한 기본 URL이어야 합니다.\n\ndatasource 디렉토리의 인덱스 파일은 다음과 같이 될 것입니다:\n\n```js\n// datasource/index.js\nimport { UsersAPI } from \"./users.js\";\nexport const dataSources = () =\u003e ({\n  UsersAPI: new UsersAPI()\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 리졸버:\n\n모든 사용자를 가져오는 우리의 리졸버를 추가해보겠습니다. 프로젝트 루트에 resolvers라는 디렉토리를 만들고 다음을 추가합니다:\n\n```js\n// resolvers/users.js\nexport const userResolvers = {\n  users: (parent, args, {dataSources}, info) =\u003e dataSources.UsersAPI.getAllUsers()\n}\n```\n\n다음 세션에서 서버의 진입점과 연결할 때 이해할 수 있을 것입니다. 리졸버 인덱스에 다음을 추가합시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// resolvers/index.js\nimport { userResolvers } from \"./users.js\";\nexport const resolvers = {\n  Query: {\n    ...userResolvers\n  }\n}\n```\n\n## 서버와 연결하기:\n\n데이터 소스와 리졸버를 서버에 연결하려면 프로젝트 루트에 있는 index.js 파일을 다음과 같이 수정하십시오:\n\n```js\n// index.js\nimport { ApolloServer } from \"apollo-server\";\nimport { Query, User } from \"./schema/index.js\";\nimport { resolvers } from \"./resolver/index.js\";\nimport { dataSources } from \"./datasource/index.js\";\nconst server = new ApolloServer({ typeDefs:[Query,User ], resolvers, dataSources });\nserver\n  .listen({ port: process.env.PORT || 5000 })\n  .then(({ url }) =\u003e console.log(`서버가 실행 중: ${url}`));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 로컬호스트:5000에서 실행 중인 GraphQL 플레이그라운드로 이동하여 다음과 같이 모든 사용자를 검색하는 쿼리를 실행할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*X9A5GeYoCB8dxYsROmk6VQ.gif)\n\nREST 엔드포인트와 달리 GraphQL 쿼리에서는 사용자 스키마에서 필요한 필드만 선택적으로 가져올 수 있습니다.\n\n# 결론:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 기존 REST 엔드포인트에서 데이터를 가져오는 기능이 포함된 GraphQL 쿼리를 만들었습니다. 또한 필요한 다양한 구성 요소 및 구성 설정이 무엇이며, 이를 어떻게 연결하여 작동시키는지 살펴보았습니다.","ogImage":{"url":"/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_0.png"},"coverImage":"/assets/img/2024-05-18-CreateaGraphQLQueryWithaRESTEndpointAsaDataSource_0.png","tag":["Tech"],"readingTime":7},{"title":"Nodejs를 제대로 알고 사용하는 방법","description":"","date":"2024-05-18 21:25","slug":"2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_0.png\" /\u003e\n\n웹 개발의 끊임없는 세계에서 선도하려면 속도, 효율성 및 확장성을 제공하는 기술을 받아들이는 것이 중요합니다. 개발 커뮤니티를 열광시킨 기술 중 하나는 Node.js입니다. 경험 많은 개발자든 초보자든 프로그래밍의 끝없는 바다에 발을 담그고 있다면, Node.js는 반드시 보유해야 할 도구입니다. 이 블로그에서 Node.js가 무엇인지, 왜 그렇게 인기를 얻었는지, 그리고 어떻게 시작할 수 있는지 살펴보겠습니다.\n\n# Node.js란?\n\nNode.js는 브라우저 외부에서 JavaScript 코드를 실행할 수 있도록 하는 오픈 소스 크로스 플랫폼 런타임 환경입니다. 2009년 Ryan Dahl에 의해 개발되었으며, Node.js는 많은 현대 웹 애플리케이션의 기반이 되었습니다. Google Chrome을 구동하는 V8 JavaScript 엔진을 사용하여 매우 빠르다는 특징을 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Node.js의 주요 기능\n\n비동기 및 이벤트 기반: Node.js는 하나의 스레드에서 동작하며 논블로킹 이벤트 루프를 사용하여 효율적이고 확장 가능합니다. 이는 Node.js가 여러 작업을 기다리지 않고 동시에 처리할 수 있음을 의미하며 데이터베이스 쿼리와 API 요청과 같은 I/O 집중 작업에 적합합니다.\n\n빠른 실행: V8 엔진 덕분에 Node.js는 JavaScript를 네이티브 기계 코드로 직접 컴파일하여 성능을 크게 향상시킵니다.\n\nNPM (Node Package Manager): Node.js에는 NPM이라는 내장된 패키지 매니저가 함께 제공됩니다. 이는 개발자가 애플리케이션을 향상시키기 위한 다양한 도구와 모듈을 제공하는 오픈 소스 라이브러리의 최대 생태계입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크로스 플랫폼: Node.js는 Windows, macOS 및 Linux를 포함한 다양한 운영 체제에서 실행되므로 개발자에게 다재다능한 선택지가 됩니다.\n\n# Node.js를 선택해야 하는 이유\n\nNode.js는 개발자와 기업 사이에서 엄청난 인기를 얻고 있습니다. 여기에는 몇 가지 이유가 있습니다:\n\n# 뛰어난 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js의 비차단 I/O 작업 및 이벤트 기반 아키텍처는 많은 동시 연결을 높은 처리량으로 처리할 수 있는 능력을 제공합니다. 이는 채팅 애플리케이션, 온라인 게임 및 협업 도구와 같은 실시간 애플리케이션에 이상적입니다.\n\n## 확장성\n\nNode.js의 단일 스레드 모델과 이벤트 루핑은 요청을 처리하는 제한된 스레드를 생성하는 전통적인 서버와는 달리 높은 확장성을 가지고 있습니다. LinkedIn 및 Netflix와 같은 기업들은 확장성 때문에 Node.js를 사용하여 고트래픽 애플리케이션을 구동합니다.\n\n## 견고한 생태계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNPM에는 백만 개가 넘는 패키지가 있어 개발자들이 다양한 도구, 라이브러리 및 프레임워크에 액세스할 수 있습니다. 이 방대한 생태계는 개발 시간을 단축시키고 써드파티 서비스를 쉽게 통합할 수 있도록 합니다.\n\n# 개발자 생산성\n\nJavaScript는 클라이언트 측과 서버 측에서 모두 사용되며 Node.js로 작업할 수 있기 때문에 개발자들은 더 효율적으로 작업할 수 있고 스택 전체에서 일관성을 유지할 수 있습니다. 이 풀스택 JavaScript 접근 방식은 학습 곡선을 줄이고 생산성을 향상시킵니다.\n\n# Node.js 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js에 뛰어들 준비가 되셨나요? 시작하는 방법에 대한 빠른 안내서가 여기 있어요.\n\n## 설치\n\n먼저 Node.js를 설치해야 합니다. 공식 Node.js 웹 사이트에서 최신 버전을 다운로드할 수 있어요. 그리고 운영 체제에 맞는 설치 지침을 따르세요.\n\n## Hello World\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`app.js` 파일을 생성하고 아래 코드를 추가해주세요:\n\n\n![Unleashing the Power of Node.js: A Comprehensive Guide](/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_1.png)\n\n\n터미널에서 다음 명령어를 실행하여 해당 디렉토리로 이동한 후 애플리케이션을 실행하세요: \n\n\nnode app.js\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 브라우저를 열고 http://127.0.0.1:3000/ 주소로 이동하여 \"Hello World\" 메시지를 확인해보세요.\n\n# 간단한 REST API 구축하기\n\nNode.js와 인기 있는 웹 프레임워크 Express를 이용하여 간단한 REST API를 만들어봅시다.\n\n- 프로젝트 초기화\nmkdir myapp\ncd myapp\nnpm init -y\n- Express 설치\nnpm install express\n- index.js 파일을 생성하고 다음 코드를 추가하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_2.png\" /\u003e\n\n\"Hello World\" 메시지를 보려면 http://localhost:3000/을 방문하고, 간단한 API 응답을 보려면 http://localhost:3000/api를 방문해보세요.\n\n# 결론\n\nNode.js는 현대 웹 개발에 강력하고 유연한 도구입니다. 비차단, 이벤트 기반 아키텍처로 확장 가능하고 고성능 애플리케이션을 구축하기에 완벽합니다. Node.js는 다양한 라이브러리와 활기찬 커뮤니티로 구성되어 지금까지 계속해서 발전하고 있습니다. 그래서 간단한 웹사이트, 복잡한 API 또는 실시간 애플리케이션을 구축하든, Node.js가 모두 다룹니다. 다가가서 실험하고, 다음 프로젝트에서 Node.js의 힘을 펼쳐보세요!","ogImage":{"url":"/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-18-UnleashingthePowerofNodejsAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4}],"page":"13","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"13"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>