<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/47" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/47" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1" href="/post/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="응용 통계 확률 분포 - 이항분포" href="/post/2024-06-20-AppliedstatsprobabilitydistributionsBinomial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="응용 통계 확률 분포 - 이항분포" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="응용 통계 확률 분포 - 이항분포" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">응용 통계 확률 분포 - 이항분포</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 장고에서의 디자인 원칙" href="/post/2024-06-20-DesignPrinciplesinPythonDjango"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 장고에서의 디자인 원칙" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 장고에서의 디자인 원칙" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 장고에서의 디자인 원칙</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS" href="/post/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="의사결정을 이끄는 매직 놀라움을 발견하라, 추천 시스템을 위한 도서관" href="/post/2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="의사결정을 이끄는 매직 놀라움을 발견하라, 추천 시스템을 위한 도서관" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="의사결정을 이끄는 매직 놀라움을 발견하라, 추천 시스템을 위한 도서관" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">의사결정을 이끄는 매직 놀라움을 발견하라, 추천 시스템을 위한 도서관</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 오피스 마법 PDF 파일 처리에 대한 완벽한 가이드" href="/post/2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 오피스 마법 PDF 파일 처리에 대한 완벽한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 오피스 마법 PDF 파일 처리에 대한 완벽한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 오피스 마법 PDF 파일 처리에 대한 완벽한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LLM ABCs LLM으로 동력을 주는 애플리케이션 구축 - AI 미래를 여는 게이트웨이" href="/post/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LLM ABCs LLM으로 동력을 주는 애플리케이션 구축 - AI 미래를 여는 게이트웨이" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LLM ABCs LLM으로 동력을 주는 애플리케이션 구축 - AI 미래를 여는 게이트웨이" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LLM ABCs LLM으로 동력을 주는 애플리케이션 구축 - AI 미래를 여는 게이트웨이</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="전문가를 위한 고급 Python 20 단계" href="/post/2024-06-20-AdvancedPythonforExperts20Steps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="전문가를 위한 고급 Python 20 단계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AdvancedPythonforExperts20Steps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="전문가를 위한 고급 Python 20 단계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">전문가를 위한 고급 Python 20 단계</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내" href="/post/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">29<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬을 활용한 비즈니스 계획 - 재고 및 현금 흐름 관리" href="/post/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬을 활용한 비즈니스 계획 - 재고 및 현금 흐름 관리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬을 활용한 비즈니스 계획 - 재고 및 현금 흐름 관리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬을 활용한 비즈니스 계획 - 재고 및 현금 흐름 관리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link posts_-active__YVJEi" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"상태가 없는 인증 React 및 Django Rest Framework에서 Google API에 JWT 통합하기 파트  1","description":"","date":"2024-06-20 02:14","slug":"2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1","content":"\n\n# 개요\n\n이 블로그에서는 Google API를 사용하여 내 웹 앱에 JWT 인증을 통합하는 경험을 공유하고 자습서를 제공할 예정입니다. 이것은 총 세 부작으로 이루어질 것입니다. 먼저 주제의 이론적 측면을 다루고, 그 후에는 실습 자습서로 넘어갈 것입니다.\n\n주로 사용할 패키지들은 다음과 같습니다:\n\n- Google API\n- Django Rest Framework\n- Django Rest Framework SimpleJWT\n- Django CORS Headers\n- Django Dot Env\n- React\n- React OAuth Google\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적인 앱 설정 생성과 같은 몇 가지 기본 단계를 건너뛸 예정이니 참고해 주세요.\n\n# JWT의 의미와 이유\n\n다양한 인증 방법 중 JWT는 요청의 무결성을 인증하거나 승인하는 상대적으로 새로운 방법입니다. 내 의견으로 JWT의 개념에 끌린 주된 측면 중 하나는 무상태(Stateless) 특성입니다.\n\n무상태 특성이란 요청이 유효한지 확인하기 위해 데이터베이스를 쿼리할 필요가 없다는 것을 의미합니다. 이 특성은 JWT를 강력하게 만들며 꼭 무상태입니다. 한 번 토큰이 서명되고 생성되면, 웹 애플리케이션은 토큰의 서명을 기반으로 토큰을 확인할 수 있습니다. 데이터베이스를 쿼리하여 요청이 합법적인지 확인할 필요는 없습니다. 이는 대규모 애플리케이션에 특히 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 JWT의 단점을 이해하는 것도 중요합니다. 그 중 하나는 유효한 토큰을 무효화하거나 취소하는 것이 어렵다는 점입니다. 토큰 무효화를 달성하는 방법은 있지만, 다른 종류의 인증(예: 토큰 기반 인증)보다 간단하지는 않습니다.\n\nJWT에 대해 더 자세히 알아보려면 여기에서 공식 소개 페이지를 참조하세요.\n\n# Google API\n\nGoogle API는 구글이 개발한 응용 프로그램 프로그래밍 인터페이스(API) 집합으로, 구글 서비스 및 기타 애플리케이션과 통신할 수 있게 해줍니다. 이러한 API는 구글 지도, 구글 드라이브, 구글 캘린더 등 다양한 구글 서비스에 액세스할 수 있도록 해줍니다. 우리는 이러한 API를 사용하여 앱에서 사용자를 로그인할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 작업을 수행하겠습니다:\n\n- Google Cloud Console에 접속합니다.\n- 왼쪽 상단 로고 근처에서 프로젝트를 선택하거나 새로 만듭니다.\n\n\n![이미지1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png)\n\n![이미지2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_2.png)\n\n![Image 2](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_3.png)\n\n- 동의 화면에서는 app_name, user_support_email, developer_contact_email을 입력할 것입니다. 다른 필드는 로컬 환경에서 비워둘 겁니다. 나중에 필요한 경우 양식을 업데이트할 수도 있습니다. test_email을 위해 몇 개의 이메일을 추가할 수 있습니다. 그 외에는 '다음' 버튼만 눌러 진행하면 됩니다.\n- 이제 동일한 드롭다운에서 새로운 OAuth 클라이언트 ID를 생성할 수 있습니다. 모바일 앱이나 태블릿 애플리케이션을 개발 중이라면 다른 플랫폼을 사용할 수 있습니다.\n\n![Image 3](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 허가된 js origin은 구글 버튼이 렌더링될 URI를 의미합니다. 즉, 프론트엔드 URL(우리의 리액트 서버)을 의미합니다. 반면에, 허가된 리다이렉트 URI는 우리의 장고 서버를 위한 것입니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_5.png)\n\n- 그 다음으로 클라이언트 ID와 클라이언트 시크릿을 얻을 수 있어야 합니다. 그것들을 복사해서 환경 변수나 .env 파일에 설정할 수 있습니다. 혹은 다운로드 아이콘을 통해 json 파일을 다운로드할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 프로젝트를 시작할 기본 구조를 설정했습니다. 다음 섹션에서는 Django 백엔드로 시작할 것입니다. 질문이나 제안이 있으면 언제든지 코멘트해 주세요. 읽어주셔서 감사합니다!!!","ogImage":{"url":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png"},"coverImage":"/assets/img/2024-06-20-StatelessAuthenticationIntegratingJWTforGoogleAPIinReactandDjangoRestFrameworkPart1_0.png","tag":["Tech"],"readingTime":3},{"title":"응용 통계 확률 분포 - 이항분포","description":"","date":"2024-06-20 02:13","slug":"2024-06-20-AppliedstatsprobabilitydistributionsBinomial","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png\" /\u003e\n\n통계의 하나의 목표는 주어진 모집단의 어떤 변수의 분포에 대한 추론(또는 결론)을 샘플이라고 하는 그 일부분의 데이터를 바탕으로 내리는 것입니다.\n\n샘플 데이터와 모집단 간의 링크는 확률적 모델에 의존하는데, 즉, 모집단의 (알려지지 않은) 분포를 나타내는 모델에 의해 달려 있습니다.\n\n이 절차를 통계 추론이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 모집단에 대해 정의된 변수 X의 확률 분포가 특정 확률 모델에 의해 설명될 수 있다고 가정한다면, 우리의 문제는 해당 모델에 의해 표현된 특정 확률 분포의 매개변수를 추정하는 것으로 간소화됩니다. 이항 분포의 경우, 이러한 매개변수는 다음과 같습니다:\n\n- n = 시도의 횟수.\n- p = 각 시도의 성공 확률.\n\n이제 이항 분포를 소개했으니, 조금 더 깊이 파보겠나요? 이 이론적 소개 이후, 실제 응용 사례가 나오면 모든 것이 명확해지고 재미있어질 것입니다!\n\n# 이항 분포: 이론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이항 분포의 특정 수학 함수를 사용하면 두 가지 결과가 있는 어떤 실생활 이벤트의 결과를 예측할 수 있습니다.\n\n표기법: B(n, p) → n = 시도 횟수; p = 각 시도에서 성공할 확률.\n\n예: X ~ B(10, 0.6) → \"변수 X는 10번의 시도와 각각의 시도에서 성공 확률이 0.6인 이항 분포를 따릅니다.\"\n\n![이항분포 이미지](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 정확한 예측을 위해 기대값과 표준편차를 계산할 수 있습니다. 이 경우:\n\n- E(X) = n . p\n- σ² = E(X²) — E(X)² = n . p . (1 — p)\n\n변수 X가 이항 확률 변수가 되려면:\n\n- 각 시행이 독립되어야 합니다.\n- 각 시행은 \"성공\" 또는 \"실패\"로 표현할 수 있어야 합니다.\n- 고정된 횟수의 시행이 있어야 합니다.\n- 각 시행에서의 성공 확률이 일정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이항 분포: 실습\n\n## 예시 1\n\n가게에서 매주 주문의 10%가 반품된다고 가정해 봅시다. 매주 3개 이상의 반품이 발생할 확률이 높다면, 임시 보조 직원을 고용해야 합니다. 이번 주에 가게에서 50건의 매출이 있었다고 가정해 봅시다. 임시 보조 직원을 고용해야할 확률은 어떻게 되나요?\n\nX = 반품 수량.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nn = 50번의 구매.\n\np = 환불 확률 (성공) = 10%.\n\nq (1-p) = 환불하지 않을 확률 (실패) = 1-10% = 90%.\n\n```js\nfrom scipy.stats import binom\n\n# p = 성공 확률\n# n = 시도 횟수\n# k = 성공 횟수\n\nn = 50\np = 0.1\nk = 2\n\nprint('2개 이하의 환불 누적 확률:', \n  binom.cdf(k, n, p)) # P(X=0) + P(X=1) + P(X=2)\nprint('정확히 2개의 환불이 일어날 확률:', \n  binom.pmf(k, n, p)) # P(X=3)\nprint('3개 이상의 환불이 일어날 확률:', \n  1 - binom.cdf(k, n, p)) # k를 0, 1, 2로 포함\nprint('3개 이상의 환불이 일어날 확률:', \n  binom.sf(k, n, p)) # 1 - cdf\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_2.png)\n\n예시를 확장해서 X=1, X=2, X=3, …, X=50 성공 시 확률을 정확히 계산해보자. 이를 위해 단순히 확률질량함수를 사용하면 된다. 왜냐하면 이는 이산형 변수이기 때문이다.\n\n```js\nimport plotly.graph_objects as go\nfrom scipy.stats import binom\n\nn = 50\np = 0.1\nk = np.arange(0, n+1)\npmf = binom.pmf(k, n, p) # 확률 질량 함수\n\nfig = go.Figure(data=[go.Bar(x=k, y=pmf)])\nfig.update_layout(title=\"이항 분포 (n=50, p=0.1)\",\n                  xaxis_title=\"성공 횟수\",\n                  yaxis_title=\"확률\",\n                  font=dict(size=18),\n                  width=700,\n                  title_x=0.5,\n                  height=400,\n                  template=\"simple_white\")\nfig.show()\n```\n\n이 코드는 기사 초반에 보았던 그래프를 나타낼 것입니다. 빠르고 매우 유용하죠?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시 2\n\n은행 거래에서 사기 발생 확률.\n\n저는 캐글에서 데이터셋을 수집했는데, 이 데이터셋은 한 은행의 거래 내역을 포함하고 있습니다. 그 중 하나의 변수는 해당 거래가 사기인지 아닌지를 나타냅니다. 이 변수의 빈도 분포를 확인해보겠습니다.\n\n![transactions](/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거래에 대한 데이터를 모두 가정한다면, 사기 및 비 사기의 각각의 발생 확률은 다음과 같습니다:\n\n```js\n비 사기의 확률 = (value_counts[0] / len(df_fraud))\n사기의 확률 = (value_counts[1] / len(df_fraud))\n\nprint('사기가 아닐 확률은:', 비 사기의 확률)\nprint('사기 확률은:', 사기의 확률)\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_4.png\" /\u003e\n\n이는 각 거래에서 사기를 저지를 확률입니다. 불균형은 예상대로 발생하며, 우리는 훨씬 더 많은 합법적인 거래를 가지고 있습니다. 중요한 점은 은행에서 많은 일일 거래가 있고 분명 그 중 하나는 사기일 것이라는 것입니다. 이 은행의 평균 일일 거래를 확인해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_5.png\" /\u003e\n\n```js\nmean_transactions_per_day = transactions_per_day.mean()\nprint(\"평균 거래 횟수(하루):\", \n  round(mean_transactions_per_day, 0))\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_6.png\" /\u003e\n\n이제 가장 중요한 부분으로 들어가 봅시다. 이제 비즈니스 문제를 활용하여 궁금증에 답할 수 있습니다. 예를 들어, 50번의 시도에서 1, 2, 3, ... 50건의 사기 사례를 발견할 확률은 얼마인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n## 파이썬을 사용하여 확률 분포 그래프 그리기\r\n\r\nimport plotly.graph_objects as go\r\nfrom scipy.stats import binom\r\n\r\nn = 50\r\np = fraud_probability # 0.05\r\nk = np.arange(0, n + 1)\r\npmf = binom.pmf(k, n, p)\r\n\r\nfig = go.Figure(data=[go.Bar(x=k, y=pmf)])\r\nfig.update_layout(title=f\"이항 분포 (n={n}, p={fraud_probability})\",\r\n                  xaxis_title=\"성공 횟수\",\r\n                  yaxis_title=\"확률\",\r\n                  font=dict(size=18),\r\n                  width=700,\r\n                  title_x=0.5,\r\n                  height=400,\r\n                  template=\"simple_white\")\r\nfig.show()\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_7.png\" /\u003e\r\n\r\n그리고 한 가지 더 예시를 드리면:\r\n\r\n```python\r\nprint(f'3333번 시도 중 200번 이상 사기가 발생할 확률은:', \r\n              binom.sf(200, 3333, 0.05))\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_8.png\" /\u003e\n\n이곳에서 가능한 한 이론에서 벗어나서 이항 확률 분포의 이론을 실제로 어떻게 활용하는지 보여 주었습니다. 이제 당신이 일상생활에서 이를 식별하고 데이터가 전달하는 내용에 기초하여 올바르게 적용하여 문제를 해결하고 올바른 결정을 내릴 수 있도록 해야 합니다!\n\n# 크레딧\n\nWheelan, Charles. Naked Statistics: Stripping the Dread from the Data. W.W. Norton \u0026 Company, 2013.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpiegelhalter, David. The Art of Statistics: How to Learn from Data. Basic Books, 2019.","ogImage":{"url":"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png"},"coverImage":"/assets/img/2024-06-20-AppliedstatsprobabilitydistributionsBinomial_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬 장고에서의 디자인 원칙","description":"","date":"2024-06-20 02:11","slug":"2024-06-20-DesignPrinciplesinPythonDjango","content":"\n\n파이썬에서의 디자인 원칙은 다른 프로그래밍 언어와 마찬가지로 깔끔하고 유지보수가 용이하며 효율적인 코드를 만드는 데 도움이 됩니다. 다음은 몇 가지 주요 디자인 원칙과 예시입니다:\n\n![Design Principles in Python](/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png)\n\n## 1. DRY(Don’t Repeat Yourself)\n\n코드의 중복을 피하기 위해 반복되는 패턴을 함수나 클래스로 추상화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장고는 ORM, 폼 및 관리자 인터페이스를 통해 DRY 원칙을 자연스럽게 촉진합니다.\n\n## 예시: 시리얼라이저 사용하기\n\nDRF 시리얼라이저를 사용하면 유효성 검사 로직을 별도로 작성하는 대신, 해당 로직을 시리얼라이저 자체에 캡슐화할 수 있습니다.\n\n```js\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Expense, Category, Balance\n\nclass ExpenseSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Expense\n        fields = ['id', 'user', 'category', 'amount', 'description', 'date']\n\nclass CategorySerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Category\n        fields = ['id', 'name', 'description', 'user']\n\nclass BalanceSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Balance\n        fields = ['id', 'total_balance']\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. KISS (Keep It Simple, Stupid)\n\n코드를 가능한 한 간단하게 유지하세요. 불필요한 복잡성을 피하세요.\n\nDjango의 설계 철학은 간결성과 가독성을 강조합니다.\n\n## 예시: Django Rest Framework의 일반 뷰 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n복잡한 뷰 로직을 작성하는 대신, DRF의 일반적인 뷰를 사용하여 객체 생성, 검색 및 목록을 처리할 수 있어요.\n\n```js\n# views.py\nfrom rest_framework import generics\nfrom .models import Expense, Category, Balance\nfrom .serializers import ExpenseSerializer, CategorySerializer, BalanceSerializer\n\nclass ExpenseListView(generics.ListCreateAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass ExpenseDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass CategoryListView(generics.ListCreateAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass CategoryDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass BalanceListView(generics.ListCreateAPIView):\n    queryset = Balance.objects.all()\n    serializer_class = BalanceSerializer\n```\n\n# 3. YAGNI (You Ain’t Gonna Need It)\n\n필요할 때까지 기능을 추가하지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 요구 사항에 주안점을 두세요. 미래의 가능성에 집중하기보다는 현재의 요구 사항을 중심으로 작업하세요.\n\n## 예: 간단한 사용자 프로필\n\n간단한 사용자 모델로 시작하고 필요할 때만 복잡성을 추가하세요.\n\n```js\n# models.py\n\nclass User(AbstractUser):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n    email = models.EmailField(unique=True)\n\n    def __str__(self):\n        return self.username\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 역할의 분리\n\n여러분의 코드의 각 부분은 서로 다른 책임을 가져야 합니다.\n\n장고의 MVC (Model-View-Controller) 아키텍처는 데이터 처리를 분리한 모델(models), 사용자 인터페이스를 분리한 템플릿(templates), 그리고 응용 프로그램 로직을 분리한 뷰(views)로 구성됩니다.\n\n## 예시: 뷰에서 비즈니스 로직 분리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비즈니스 로직은 뷰가 아닌 모델이나 서비스에 유지하는 것이 좋습니다.\n\n```js\n# models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass DKModel(models.Model):\n    class Meta:\n        abstract = True\n\n    deleted = models.BooleanField(default=False)\n    date_created = models.DateTimeField('Date created', auto_now_add=True)\n    date_last_updated = models.DateTimeField('Data last updated', auto_now=True)\n\n    def __id__(self) -\u003e int:\n        return self.id\n\n    def delete(self, *args, **kwargs):\n        self.deleted = True\n        self.save()\n\n    def hard_delete(self, *args, **kwargs):\n        super().delete(*args, **kwargs)\n        \n                      ....\n\n# views.py\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import generics\nfrom django.shortcuts import get_object_or_404\nfrom .models import Expense, Category, Balance, User\nfrom .serializers import ExpenseSerializer, CategorySerializer, BalanceSerializer\n\nclass ExpenseListView(generics.ListCreateAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass ExpenseDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Expense.objects.all()\n    serializer_class = ExpenseSerializer\n\nclass CategoryListView(generics.ListCreateAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass CategoryDetailView(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Category.objects.all()\n    serializer_class = CategorySerializer\n\nclass BalanceListView(generics.ListCreateAPIView):\n    queryset = Balance.objects.all()\n    serializer_class = BalanceSerializer\n\nclass UserTotalExpensesView(APIView):\n    def get(self, request, user_id):\n        user = get_object_or_404(User, id=user_id)\n        total_expenses = user.get_total_expenses()\n        return Response({'total_expenses': total_expenses})\n\n# urls.py\nfrom django.urls import path\nfrom .views import ExpenseListView, ExpenseDetailView, CategoryListView, CategoryDetailView, BalanceListView, UserTotalExpensesView\n\nurlpatterns = [\n    path('expenses/', ExpenseListView.as_view(), name='expense-list'),\n    path('expenses/\u003cint:pk\u003e/', ExpenseDetailView.as_view(), name='expense-detail'),\n    path('categories/', CategoryListView.as_view(), name='category-list'),\n    path('categories/\u003cint:pk\u003e/', CategoryDetailView.as_view(), name='category-detail'),\n    path('balances/', BalanceListView.as_view(), name='balance-list'),\n    path('users/\u003cint:user_id\u003e/total-expenses/', UserTotalExpensesView.as_view(), name='user-total-expenses'),\n]\n```\n\n# 5. SOLID Principles\n\nSOLID은 소프트웨어 디자인을 더 이해하기 쉽고 유연하며 유지보수하기 쉽도록 하는 다섯 가지 디자인 원칙을 의미하는 머릿글자입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## S: 단일 책임 원칙 (SRP)\n\n각 클래스는 하나의 책임만을 가져야 합니다.\n\n```js\n# model/models.py\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass DKModel(models.Model):\n    class Meta:\n        abstract = True\n\n    deleted = models.BooleanField(default=False)\n    date_created = models.DateTimeField('생성 날짜', auto_now_add=True)\n    date_last_updated = models.DateTimeField('마지막으로 업데이트된 날짜', auto_now=True)\n\n    def __id__(self) -\u003e int:\n        return self.id\n\n    def delete(self, *args, **kwargs):\n        self.deleted = True\n        self.save()\n\n    def hard_delete(self, *args, **kwargs):\n        super().delete(*args, **kwargs)\n\n\nclass User(AbstractUser):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n    email = models.EmailField(unique=True)\n\n    def __str__(self):\n        return self.username\n\n\nclass Category(DKModel):\n    class Meta:\n        verbose_name = \"카테고리\"\n        verbose_name_plural = \"카테고리들\"\n        db_table = \"dk_category\"\n\n    name = models.CharField('이름', max_length=100, unique=True)\n    description = models.TextField()\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.name\n\n\nclass Expense(DKModel):\n    class Meta:\n        verbose_name = \"지출\"\n        verbose_name_plural = \"지출들\"\n        db_table = \"dk_expense\"\n\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    description = models.TextField()\n    date = models.DateField()\n\n\nclass Balance(models.Model):\n    class Meta:\n        verbose_name = \"잔고\"\n        verbose_name_plural = \"잔고들\"\n        db_table = \"dk_balance\"\n\n    total_balance = models.DecimalField(max_digits=10, decimal_places=2)\n```\n\n## O: 개방/폐쇄 원칙 (OCP)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소프트웨어 엔티티들은 확장에는 열려 있지만 수정에는 닫혀 있어야 합니다.\n\n```python\n# middleware.py\nfrom django.http import HttpResponse\n\nclass BaseMiddleware:\n    def process_request(self, request):\n        raise NotImplementedError\n\nclass AuthMiddleware(BaseMiddleware):\n    def process_request(self, request):\n        if not request.user.is_authenticated:\n            return HttpResponse('Unauthorized', status=401)\n```\n\n### L: 리스코프 치환 원칙 (LSP)\n\n슈퍼클래스의 객체는 서브클래스의 객체로 대체할 수 있어야 하며, 프로그램의 정확성에 영향을 주지 않아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# models.py\n\nclass Notification:\n    def send(self):\n        raise NotImplementedError\n\nclass EmailNotification(Notification):\n    def send(self):\n        print(\"이메일 보내는 중\")\n\nclass SMSNotification(Notification):\n    def send(self):\n        print(\"SMS 보내는 중\")\n\ndef notify(notification: Notification):\n    notification.send()\n\n# 사용 예시\nemail_notification = EmailNotification()\nsms_notification = SMSNotification()\n\nnotify(email_notification)  # 출력: 이메일 보내는 중\nnotify(sms_notification)    # 출력: SMS 보내는 중\n```\n\n## I: 인터페이스 분리 원칙 (ISP)\n\n클라이언트는 사용하지 않는 인터페이스에 종속되도록 강요되어서는 안됩니다.\n\n```js\n# 더 큰 뷰를 분리함으로써 인터페이스 분리\nfrom django.views import View\nfrom django.http import JsonResponse\n\nclass CreateMixin:\n    def create(self, request, *args, **kwargs):\n        return JsonResponse({'message': '생성 기능이 구현되지 않았습니다.'}, status=405)\n\nclass ReadMixin:\n    def read(self, request, *args, **kwargs):\n        return JsonResponse({'message': '조회 기능이 구현되지 않았습니다.'}, status=405)\n\nclass UpdateMixin:\n    def update(self, request, *args, **kwargs):\n        return JsonResponse({'message': '수정 기능이 구현되지 않았습니다.'}, status=405)\n\nclass DeleteMixin:\n    def delete(self, request, *args, **kwargs):\n        return JsonResponse({'message': '삭제 기능이 구현되지 않았습니다.'}, status=405)\n\nclass MyView(CreateMixin, ReadMixin, View):\n    def read(self, request, *args, **kwargs):\n        return JsonResponse({'message': '데이터 조회 중'})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## D: 의존 역전 원칙 (DIP)\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 모두 추상화에 의존해야 합니다.\n\n```js\nclass PaymentService:\n    def process_payment(self):\n        raise NotImplementedError\n\nclass StripePaymentService(PaymentService):\n    def process_payment(self):\n        print(\"Stripe로 결제 처리 중\")\n\nclass PayPalPaymentService(PaymentService):\n    def process_payment(self):\n        print(\"PayPal로 결제 처리 중\")\n\n# views.py\nfrom .services import PaymentService\n\nclass PaymentView(View):\n    def __init__(self, payment_service: PaymentService):\n        self.payment_service = payment_service\n\n    def post(self, request, *args, **kwargs):\n        self.payment_service.process_payment()\n        return JsonResponse({'message': '결제가 완료되었습니다'})\n\n# 사용법\nstripe_service = StripePaymentService()\npaypal_service = PayPalPaymentService()\n\nstripe_payment_view = PaymentView(stripe_service)\npaypal_payment_view = PaymentView(paypal_service)\n```","ogImage":{"url":"/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png"},"coverImage":"/assets/img/2024-06-20-DesignPrinciplesinPythonDjango_0.png","tag":["Tech"],"readingTime":11},{"title":"Bayesian Framework을 활용한 마케팅 믹스 모델링과 ROAS","description":"","date":"2024-06-20 02:06","slug":"2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS","content":"\n\n이 게시물은 Rafael Guedes와 함께 공동 저술되었습니다.\n\n# 소개\n\n확장 가능한 인터넷 비즈니스는 성장을 이끌기 위해 마케팅에 의존합니다. 물론 그것뿐만이 아니라 특정 규모에서는 매우 효율적으로 고객을 확보하지 않을 수 없는 회사가 매우 적습니다. 기업들이 마케팅에 인공지능(AI) 능력을 가져오기 위해 많이 투자하고 있는 두 가지 핫한 주제는 미디어 믹스 모델링(MMM)과 고객 평생 가치(LTV) 예측입니다. 이 두 가지는 기업들이 마케팅에 투자하는 비용 대비 이익을 증가시키는 데 초점을 맞추고 있습니다. 이 글은 MMM이 무엇인지와 적용하는 데 가장 효과적인 방법에 대해 다루고 있습니다.\n\nMMM은 마케팅 팀이 투자의 영향과 대화 유도에 어떻게 기여하는지를 측정할 수 있는 기술입니다. 이 일의 복잡성은 최근 몇 년 동안 급속히 증가했습니다. 왜냐하면 광고를 할 수 있는 플랫폼이 급증했기 때문입니다. 이 현상은 잠재 고객을 오프라인 또는 온라인 버킷으로 나눌 수 있는 다양한 미디어 채널에 분산시켰습니다. 전통적인 오프라인 채널은 디지털 지원이 없으며 신문, 라디오, 텔레비전 광고, 쿠폰, 박람회 부스 등을 포함할 수 있습니다. 온라인 채널은 급증했고 기업들은 이러한 채널을 함께 사용하고 있습니다. 이메일, 소셜 미디어, 유기적 검색, 유료 검색, 제휴 마케팅, 인플루언서 마케팅 등을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 점 중 하나는 좋은 MMM이 동일하게 정확한 데이터 기반 속성 모델이 필요하다는 것입니다. 즉, 어떤 채널이 특정 고객을 확보하는 데 기여했는지를 나타냅니다. 또한 속성은 사용자 수준에서 수행되지만, MMM은 일반적으로 확보 채널 수준에서 적용됩니다. 데이터 기반 속성은 이 글의 범위를 벗어납니다.\n\n이 글에서는 두 가지에 초점을 맞춥니다. 첫째, 각 미디어 채널의 성능에 대한 투명성을 높이기 위해 설계된 베이지안 모델을 개발합니다. 둘째, 이 경우 수익이라는 변수를 최대화하기 위해 예산 할당을 최적화합니다. 베이지안 접근 방식이 MMM에 어떻게 작용하는지에 대한 상세한 내용을 제공하는 동시에 공개 데이터셋을 활용하여 모델의 정확성을 테스트하고 각 채널의 광고비 투자 대비 수익률(ROAS)을 계산합니다. 마지막으로, 수익을 극대화하기 위해 세 가지 채널 간의 가상 예산을 최적화합니다.\n\n항상 코드는 우리의 GitHub에서 이용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미디어 믹스 모델링: 무엇인가요?\n\nMMM은 전 세계 기업들에게 광고 채널의 효과를 측정하고 미디어 비용이 매출에 미치는 영향에 대한 투명성을 제공하여 조직을 강화합니다. 이러한 모델은 매출, 광고 지출 대비 수익 (ROAS), 수익, 전환, LTV 등의 관심 대상 대상 변수를 최적화하여 채널 간 예산 할당 결정 프로세스를 지원하는 데 중요한 역할을 합니다.\n\n지난 몇 년 동안 많은 연구가 수행되었으며, 관심 대상 변수에 영향을 미치는 지출을 모델링하기 위해 여러 모델이 제안되었습니다. 이러한 모델은 지리적으로 집계된 주간 또는 월간 데이터에 기반합니다. 우리는 의존 변수(위에서 정의한 관심 대상 변수 중 하나 이상)와 독립 변수 간의 관계를 모델링하는 데 관심이 있습니다. 일부 독립 변수는 명백합니다. 예를 들어 광고 채널 별 광고 비용이 그렇습니다. 그러나 가격, 제품 유통, 인플레이션, 날씨, 계절성 및 시장 경쟁력과 같은 추가 관련 효과를 포함하여 접근 방식을 확장할 수 있습니다.\n\n전통적인 접근 방식은 회귀 방법을 활용하여 상관 관계에서 인과 관계를 추론합니다. 그러나 매출의 반응은 선형적이지 않습니다 - 고수준 지출에서 수익이 감소하는 포화 현상이 있습니다. 게다가 광고에는 선행 또는 잔류 효과가 있어 이전 주에 지출한 내용이 다음 주의 매출에 영향을 미칠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_1.png\" /\u003e\n\n# 미디어 믹스 모델의 베이지안 방법론\n\n베이지안 방법론은 포화/형태와 래그/캐리오버 효과를 고려하기 위해 정의될 수 있습니다.\n\n모델 세부사항에 대해 깊이 파고들기 전에, 모델이 어떤 변수를 고려하는지 더 잘 이해하기 위해 가상의 데이터 세트를 정의해보겠습니다. 국가 수준에서 매주 데이터가 있으며 각 행이 주차(t)를 나타내고 각 열이 미디어 채널(m) 또는 계절성 또는 제품 가격과 같은 제어 변수(c)를 나타내는 가정 데이터 세트를 정의해보겠습니다. 주차 t에서 채널 m의 미디어 비용은 Xt,m로 정의되며 동일한 주차에 대한 제어 변수는 Zt,c로 정의됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_2.png\" /\u003e\n\n# 랙 또는 캐리오버 효과\n\n캐리오버 효과는 adstock라는 함수에 의해 모델링됩니다 [1]. 이 함수는 특정 채널에서 지출의 누적 효과를 만듭니다. 이 함수는 현재 주와 이전 L-1 주의 미디어 비용을 가중 평균을 통해 변환합니다. L은 특정 미디어 채널의 캐리오버 효과의 최대 기간이며, 가중 평균 방정식에서 가중치 Wm를 추정하는 데 중요한 역할을 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미디어 채널마다 L을 다르게 설정할 수 있습니다. 이것은 전문가가 정의해야 하는 초매개변수입니다. 특정 채널에 대한 사전 정보가 없는 경우, 저자들은 잠재적으로 지연된 효과를 포착하기 위해 L을 13과 같은 큰 숫자로 설정하는 것이 좋다고 충고합니다.\n\n가중치를 정의하는 방정식은 두 가지 다른 형태를 가질 수 있습니다:\n\n- 즉각적인/Geometric Adstock [2]는 광고 효과 피크가 광고 노출과 동시에 발생할 때 사용됩니다. 즉, 우리가 특정 미디어 채널의 지출을 늘린 주에 매출이 최대치를 기록한 경우입니다. 방정식 2에서 αm은 광고 효과의 유지율입니다.\n\n![equation](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 광고 효과의 정점이 더 오랜 시간이 걸려 구축되고 판매에 즉시 영향을 주지 않는 경우를 지연된 Adstock [1]라고합니다. 식 3에서 θm은 정점 효과의 지연을 나타냅니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_5.png)\n\n이제 상상 속 데이터셋을 선택하고 Facebook 채널의 즉각적 및 지연 Adstock를 계산해 보겠습니다. 먼저 데이터셋에 5주를 추가했습니다. 보존율(αm)은 80%이며, 정점 지연(θm)은 5주입니다. 이후 즉각적인 효과에 대한 가중치와 지연된 효과에 대한 가중치를 계산하여 8주차에서 즉각 및 지연 Adstock의 최종값에 도달합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 3는 각 주별 지출이 8주차의 매출량에 얼마나 기여하는지를 보여줍니다.\n\n![Figure 3](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_7.png)\n\n# 포화 또는 모양 효과\n\n포화 또는 모양 효과는 미디어 비용을 로지스틱 포화 함수 [3]와 같은 곡률 함수를 통해 변환하여 모델링합니다. 다음과 같이 정의됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 중에서 x는 미디어 비용을 나타내고, λ는 포화 곡선의 가파르기를 제어한다. 즉, 미디어 비용 효과가 얼마나 빨리 포화되는지를 결정한다. 그러면 낮은 λ 값은 응답 함수의 증가가 점진적이라고 해석할 수 있으며, 미디어 비용이 넓은 범위의 값들에 대해 주목할 만한 효과를 갖는다는 것을 의미한다. 반대로, 높은 λ 값은 지출에 대한 감소된 수익을 가져올 것이다. Figure 4는 이러한 다른 행동들을 매우 명확히 보여줍니다.\n\n이 모델에 어떤 매개변수를 사용해야 하는지 알기가 어렵습니다. 왜냐하면 이는 각 채널의 행동에 매우 구체적이기 때문입니다. 그럼에도 불구하고, Bayesian 접근 방식에서 이러한 매개변수는 사전 분포를 사용하여 추정됩니다. 따라서, 모델은 주어진 데이터에 대해 가능한 가치 매개변수를 선택합니다. 따라서, 우리는 단일 값이 아닌 분포를 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 캐리오버와 형태 효과 결합\n\n이전 두 섹션에서 언급했듯이 캐리오버와 형태 효과를 모델링하려면 각 채널의 미디어 비용에 변환을 적용해야 합니다. 어떤 변환을 먼저 적용해야 하는지에 대한 질문이 제기됩니다. 저자들은 다음을 제안합니다:\n\n- 미디어 비용이 특정 기간에 집중적으로 소비된다면 형태 효과는 캐리오버에 따릅니다.\n- 미디어 비용이 여러 시간대에 고르게 분산된다면 캐리오버는 형태 효과에 따릅니다.\n\n기관들은 일반적으로 마케팅 활동을 집중하기 때문에 가장 흔한 접근 방식은 캐리오버 → 형태 효과의 결합입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이에 따라 t주차의 종속 변수인 매출 y는 미디어 비용 및 제어 변수의 선형 결합을 통해 모델링될 수 있습니다. 또한 회귀 계수 β를 사용하여 각 미디어 채널에 대한 다른 효과를 모델링합니다.\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_10.png)\n\n여기서 𝛂는 y절편입니다. 함수 f(xm,t)는 광고재고(지속성) 및 포화 효과를 고려한 대상 변수에 대한 미디어의 기여를 인코딩합니다. γc는 제어 변수 Zt,c의 효과이며, et는 백색 잡음입니다.\n\n# 베이지안 모델\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n베이지안 접근법은 모델 매개변수에 대한 사전 분포를 정의하는 것으로 시작하여, 데이터를 고려하기 전의 초기 신념을 반영합니다. 새로운 데이터가 도입되면 모수가 주어졌을 때 데이터를 관찰할 확률을 나타내는 우도 함수가 계산됩니다. 이 문맥에서 데이터에는 미디어 채널 X와 종속 변수 y를 설명하는 제어 변수 Z가 포함됩니다. 베이즈 정리를 사용하여 사후 분포는 사전 분포와 우도 함수를 결합하여 얻어집니다.\n\n저자들은 각 미디어 채널(X)과 제어 변수(Z)의 매개변수 값을 선택하는데 샘플링 효율성 때문에 Gibbs Sampling[4]에 의존합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_11.png)\n\n데이터가 강력한 정보를 함유하고 명확한 패턴을 가질 때 모델은 매개변수를 추정할 때 사전 분포에 더 적게 의존한다는 것을 기억해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 저자들은 각 매개변수에 대한 사전 분포를 정의하는 방법에 대한 일부 지침을 남겼습니다:\n\n- 유지율 (α)은 [0, 1[으로 제한되어 있으며, beta나 균일 분포와 같이 [0, 1[에 대해 정의된 사전을 가져야 합니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_12.png)\n\n- 지연 매개변수 (θ)는 일반적으로 [0, L-1]에 제한되어 있으며, 균일 분포나 스케일링된 베타 분포와 같은 사전을 가져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_13.png)\n\n- Gamma (γ) and Intercept are usually modeled by a normal distribution.\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_14.png)\n\n- Lambda (λ) is usually modeled by a gamma distribution.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_15.png\" /\u003e\n\n- 회귀 계수 (β)는 일반적으로 미디어 소비가 y에 부정적인 영향을 미치지 않기 때문에 정규 분포와 같은 양수 우선 순위로 모델링됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_16.png\" /\u003e\n\n# PyMC를 활용한 베이지안 미디어 믹스 모델링\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 섹션은 카글의 공개 데이터셋을 활용하여 CC0 라이선스로 Bayesian 모델을 구현했습니다. 이 데이터셋은 세 가지 다른 미디어 채널(TV, 라디오, 신문)에 대한 지출 및 동일 기간의 판매에 대한 정보를 포함하고 있습니다.\n\n데이터셋은 다음과 같이 구성되어 있습니다:\n\n- ID — 행을 식별합니다.\n- TV 광고 예산($) — TV에 대한 광고 지출;\n- 라디오 광고 예산($) — 라디오에 대한 광고 지출;\n- 신문 광고 예산($) — 신문에 대한 광고 지출;\n- 판매($) — 목표 변수입니다.\n\n적합된 Bayesian 모델은 각 채널별 ROAS, 유지율 및 포화 효과를 계산하는 데 도움이 될 것입니다. 또한 미래 주차를 위한 예산 할당을 최적화하는 데도 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모형의 신뢰성을 측정하기 위해 각 매체 채널의 지출과 제어 변수에 기반하여 보이지 않는 데이터에서 종속 변수를 얼마나 잘 모델링할 수 있는지를 평가할 것입니다. 우리는 평균 절대 오차 (MAE)와 같은 회귀 지표를 활용할 것입니다. 벤치마킹 측면에서, 항상 훈련 데이터의 평균 값으로 예측하는 단순 모형을 사용합니다. 그런데, MMM이 없을 때 기업들이 종종 이를 의존합니다.\n\n먼저 라이브러리를 가져오겠습니다:\n\n```js\n%matplotlib inline\n%load_ext autoreload\n%autoreload 2\nimport arviz as az\nimport datetime\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport utils\nfrom pymc_marketing.mmm.delayed_saturated_mmm import DelayedSaturatedMMM\nfrom sklearn.metrics import mean_absolute_error\n```\n\n그런 다음 데이터셋을 로드하고 일부 기본 전처리 작업을 수행합니다. 열 이름을 간소화하고 ID를 기반으로 새로운 날짜 열을 추가했습니다. 계절성 및 추세와 같은 제어 변수로 데이터셋을 보강하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n# 데이터 로드 및 열 이름 변경\ndf = pd.read_csv('data/data.csv')\ndf = df.rename(columns={'Unnamed: 0': 'id', 'TV Ad Budget ($)':'tv', 'Radio Ad Budget ($)': 'radio', 'Newspaper Ad Budget ($)': 'newspaper', 'Sales ($)': 'sales'})\n\n# 날짜 열 생성\ndf['ds'] = df['id'].apply(lambda x: pd.to_datetime(\"2024-02-26\")-datetime.timedelta(weeks=len(df)-x))\n```\n\n그 후에는 데이터 내 상관 관계를 이해하기 위한 탐색적 데이터 분석을 수행합니다:\n\n1. 종속 변수와 각 매체 채널 간의 상관 관계를 평가합니다.\n\n- TV는 판매와 가장 크게 관련된 특성이며, Newspaper는 가장 낮은 상관 관계를 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ncorr_matrix = df[['sales', 'tv', 'radio', 'newspaper']].corr()\nsns.heatmap(corr_matrix, annot=True, cmap='Blues')\nplt.show()\n```\n\n2. 판매량과 각 매체 채널 간의 상관 관계를 평가하기 위해 판매량 대 매체 채널을 그래픽으로 나타냅니다:\n\n- 판매량에는 명확한 추세나 계절성이 없습니다.\n- TV 광고의 영향은 판매에 즉각적인 영향을 미칩니다.\n- 라디오 광고의 영향도 판매에 즉각적인 영향을 미칩니다. 예를 들어, TV 광고가 낮은 값을 가졌던 2022년 1~3주에는 판매량이 급등하는데, 이는 라디오의 급등과 일치합니다.\n- 신문 광고의 영향은 1~2주의 지연이 있는 것으로 보이지만, TV와 라디오 광고가 동시에 진행되었기 때문에 정확히 파악하기 어렵습니다.\n\n```python\n# 판매량만\nutils.line_plot(df.copy(), ['sales'], '시간에 따른 판매')\n\n# 판매 대 TV 광고\nutils.line_plot(df.copy(), ['sales', 'tv'], '시간에 따른 판매 대 TV')\n\n# 판매 대 라디오 광고\nutils.line_plot(df.copy(), ['sales', 'radio'], '시간에 따른 판매 대 라디오')\n\n# 판매 대 신문 광고\nutils.line_plot(df.copy(), ['sales', 'newspaper'], '시간에 따른 판매 대 신문')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEDA를 마무리했으니 모델링 부분을 준비할 차례입니다:\n\n1. 데이터를 훈련 및 테스트 세트로 나누는 작업을 시작하겠습니다:\n\n```js\ntrain_df = df.sort_values(by='ds').iloc[:-5,:]\ntest_df = df.sort_values(by='ds').iloc[-5:,:]\n```\n\n2. 이전에 생성한 주간 데이터를 사용하여 추세와 계절성과 같은 통제 변수를 추출하려고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시계열 모델 Prophet을 사용하여 Meta에서 시계열을 추세 및 계절성으로 분해하고 이를 제어 변수로 사용합니다.\n\n```js\nseasonality, trend = utils.extract_trend_seasonality(train_df, 'sales', 5)\ntrain_df.loc[:, 'seasonality'] = seasonality[:-5]\ntest_df.loc[:,'seasonality'] = seasonality[-5:]\ntrain_df.loc[:,'trend'] = trend[:-5]\ntest_df.loc[:,'trend'] = trend[-5:]\n```\n\n![Image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_17.png)\n\n3. 모델을 위한 다른 하이퍼파라미터를 설정합니다. 이러한 매개변수는 전통적인 ML 하이퍼파라미터 검색을 통해 정의할 수 있습니다. dist, mu 및 sigma 값을 변경하여 일부 회귀 지표를 최적화합니다. 더 높은 표준 편차 값(sigma)은 모델에 더 많은 자유를 제공하여 최적의 매개변수를 탐색할 수 있음을 기억하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmy_model_config = {'intercept': {'dist': 'Normal', 'kwargs': {'mu': 0, 'sigma': 2},\n 'beta_channel': {'dist': 'HalfNormal', 'kwargs': {'sigma': 2},\n 'alpha': {'dist': 'Beta', 'kwargs': {'alpha': 1, 'beta': 3},\n 'lam': {'dist': 'Gamma', 'kwargs': {'alpha': 3, 'beta': 1},\n 'likelihood': {'dist': 'Normal',\n  'kwargs': {'sigma': {'dist': 'HalfNormal', 'kwargs': {'sigma': 2}},\n 'gamma_control': {'dist': 'Normal', 'kwargs': {'mu': 0, 'sigma': 2},\n 'gamma_fourier': {'dist': 'Laplace', 'kwargs': {'mu': 0, 'b': 1}}}\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_18.png\" /\u003e\n\nFigure 13에서 저희가 구현한 모델의 Kruschke 다이어그램을 제시합니다. 이는 이전에 정의한 내용에 대한 간결한 개요를 제공합니다. 이러한 다이어그램을 해석할 때 고려해야 할 몇 가지 측면이 있습니다. 각 노드 내에서 변수와 해당 분포를 찾을 수 있음을 유의하십시오. 예를 들어, α를 포함하는 원은 이전에 정의한 대로 베타 분포를 나타냅니다. 음영 처리된 노드는 관측된 변수를 나타냅니다. 둥근 모서리 상자는 반복을 나타냅니다. 예를 들어, 저희는 세 개의 확보 채널이 있으므로 각 채널에 대해 별도의 α, β 및 λ 매개변수 집합을 설정합니다. 화살표는 종속성을 보여줍니다. 저희 모델에서는 두 개의 화살표가 가능 함수를 가리키는데, 하나는 mu 매개변수에 종속성을 나타내고 다른 하나는 sigma 매개변수에 종속성을 나타냅니다. mu 매개변수 자체가 세 개의 추가 종속성을 가지고 있음을 상기해 주세요. 우리는 이동 효과, 모양 효과 및 제어 변수를 통합하여 매출을 모델링하기로 선택했음을 기억하세요.\n\n이제 우리는 교육 및 테스트 세트, 그리고 모델 구성을 정의했으므로 베이지안 모델을 초기화하고 교육 데이터에 맞출 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 미디어 채널 [\"tv\", \"radio\", \"newspaper\"]\n- 통제 변수 [\"seasonality\", \"trend\"]\n- EDA에서 광고주는 지연 매개변수로 최대 2까지 인 것으로 보입니다.\n\n```js\nmmm = DelayedSaturatedMMM(\n    model_config=my_model_config,\n    sampler_config={\"progressbar\": True},\n    date_column=\"ds\",\n    channel_columns=[\"tv\", \"radio\", \"newspaper\"],\n    control_columns=[\"seasonality\", \"trend\"],\n    adstock_max_lag=2,\n)\n\nmmm.fit(X=train_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], y=train_df['sales'], target_accept=0.95, chains=4, random_seed=42)\n```\n\n모델을 적합한 후에는 샘플링 예측값(파란색)과 실제 값(검은색)을 비교하여 학습 데이터에 얼마나 잘 맞는지 확인할 수 있습니다. 우리의 경우, 그들이 잘 일치하는 것을 확인할 수 있습니다.\n\n```js\nmmm.sample_posterior_predictive(train_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], extend_idata=True, combined=True)\nmmm.plot_posterior_predictive(original_scale=True);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 다양한 방법으로 모델 해석을 시작할 수 있습니다:\n\n1. 파라미터 추정 확인:\n\n- 라디오는 계수(베타)가 가장 높으므로 투자 대비 가장 높은 수익을 보이는 것으로 보입니다(1.185), 그 다음에 TV와 신문이 이어집니다.\n- 유지율 α는 TV에 대해 3.2%, 라디오에 대해 2.3%, 신문에 대해 23.9%입니다.\n\n```js\naz.summary(data=mmm.fit_result,\n    var_names=[\n        \"intercept\",\n        \"likelihood_sigma\",\n        \"beta_channel\",\n        \"alpha\",\n        \"lam\",\n        \"gamma_control\",\n    ],\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TV에서 포화율 λ가 더 높으며 (3.138), 전체 지출의 73%를 차지합니다. 그림 12에서 3개 채널의 포화율을 더 쉽게 비교할 수 있습니다.\n\n![Figure 12](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_19.png)\n\n2. 채널 기여 및 ROAS 확인:\n\n- ROAS는 매체 채널 중 하나의 지출을 제로로 설정하여 현재 매출 대비 예측 매출이 어떻게 변경되는지를 평가하여 계산됩니다. 예를 들어, 신문의 매체 지출을 제로로 설정하면 매출 큰 감소를 예상하지 않습니다. 따라서, 이에 대한 ROAS는 낮을 것입니다.\n- TV가 높은 지출을 했기 때문에 가장 큰 기여를 가지고 있지만, 모델은 라디오에 대해 더 높은 ROAS를 예측합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# 채널의 공헌도\nfig = mmm.plot_channel_contribution_share_hdi(figsize=(7, 5))\n\n# ROAS 계산\nutils.plot_ROAS(mmm, train_df, [\"tv\", \"radio\", \"newspaper\"])\r\n```\n\n3. 마지막으로, 각 채널별 광고비 지출을 50% 증가시킨다면 어떤 일이 일어날지도 평가할 수 있습니다. 이때는 캐리오버와 포화 효과를 고려합니다.\n\nX 축은 채널 데이터 백분율 수준입니다:\n\n- When =1 일 때, 모델 입력 지출 데이터가 됩니다.\n- When =1.5 일 때, 지출을 50% 증가시켰을 때의 공헌도가 어떨지 볼 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신문은 지출이 50% 증가해도 그다지 많은 기여를 못 할 것 같아요. \n\n라디오는 TV에 비해 훨씬 포화되지 않아 보여요. 두 선의 기울기를 비교해 봤을 때 그렇죠.\n\n```js\nplt.rcParams[\"figure.figsize\"] = (20,5)\nmmm.plot_channel_contributions_grid(start=0, stop=1.5, num=12);\n```\n\n우리의 결론이 올바른지 확인하기 위해 시험 집합을 사용하여 미디어 채널과 제어 변수를 기반으로 미래 매출을 예측하는 모델의 성능을 평가할 수 있어요. 이를 위해 MAE를 사용하고 소박한 모델과 비교할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 우리는 평균 목표가 13.8인 경우 MAE가 2.01이었습니다.\n- 우리는 베이스라인보다 오차가 58% 낮습니다.\n\n```js\ny_out_of_sample = mmm.sample_posterior_predictive(X_pred=test_df[['ds', 'tv', 'radio', \"newspaper\", \"seasonality\", \"trend\"]], extend_idata=False)\ny_pred = [np.median(x) for x in y_out_of_sample['y']]\n\nprint(f\"평균 절대 오차 (MAE): {mean_absolute_error(test_df['sales'], y_pred)} (평균 목표: {test_df['sales'].mean()})\")\nprint(f\"평균 절대 비율 오차 (MASE): {mean_absolute_error(test_df['sales'], y_pred)/mean_absolute_error(test_df['sales'], [train_df['sales'].mean()]*5)}\")\n```\n\n회귀 결과는 모델이 매체 채널과 제어 변수를 기반으로 매출을 모델링하기에 신뢰할만하고 잘 한다는 것을 보여줍니다.\n\n# 예산 할당\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n판매에 대한 지출 효과가 선형적이지 않을 것으로 가정하기 때문에 어느 시점에서 포화될 것으로 예상됩니다. 따라서, 우리는 어떤 포화 함수가 우리의 데이터와 더 잘 맞는지 결정해야 합니다. 포화 모델링을 위한 두 가지 함수 옵션이 있습니다:\n\n- α(alpha)가 포화 지점인 시그모이드 함수, 즉 지출 증가가 판매 증가로 이어지지 않고, λ(lambda)는 곡선의 기울기를 제어하는 요인입니다. 더 높은 값은 곡선을 더 가파르게 만듭니다.\n\n![이미지](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_20.png)\n\n- 알파(alpha)가 채널이 가질 수 있는 최대 기여도인 Michaelis-Menten 함수이며, 람다(lambda)는 곡선이 방향을 조정하는 순간, 즉 기울기입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_21.png)\n\n저희 데이터에 더 적합한 곡선을 결정하기 위해, 적합된 MMM을 사용하여 각 함수의 매개변수를 계산할 것입니다. 그 후 두 가지를 모두 플롯하고 시각적으로 어느 것이 더 적합한지 확인할 것입니다.\n\n- 특정 사용 사례에서, 시그모이드 함수가 더 나은 결과를 보였습니다.\n\n```js\n# 플롯 및 알파, 람다 추출\nsigmoid_response_curve_fig = mmm.plot_direct_contribution_curves(show_fit=True)\nsigmoid_params = mmm.compute_channel_curve_optimization_parameters_original_scale(method='sigmoid')\n\nmm_response_curve_fig = mmm.plot_direct_contribution_curves(show_fit=True, method='michaelis-menten')\nmm_params = mmm.compute_channel_curve_optimization_parameters_original_scale(method='michaelis-menten')\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 각 미디어 채널의 시그모이드 매개변수(α 및 λ)가 있으므로 각 채널의 포화점을 알 수 있습니다. 따라서 추가 지출은 수익을 증가시키지 않을 것이며, 다른 채널에 투자된 금액은 원하는 효과를 얻을 수 있습니다.\n\n채널 포화도를 기반으로 한 예산 할당을 최적화하기 위한 알고리즘을 사용할 수 있습니다. 이 때 고려해야 할 세 가지 변수는 채널 포화도, 사용 가능한 총 예산 및 각 채널의 예산 제약 사항입니다. PyMC에는 Sequential Least Squares Quadratic Programming (SLSQP)을 구현한 것이 있습니다. 이는 세 가지 변수를 고려하여 모든 채널에서 총 기여도를 최대화합니다:\n\n- 총 예산 제한;\n- 각 채널의 최소 및 최대 지출 한도;\n- 포화 곡선.\n\n```python\nresult_sigmoid = mmm.optimize_channel_budget_for_maximum_contribution(\n    method='sigmoid', # 포화 함수를 정의\n    total_budget=500, # 총 예산\n    parameters=sigmoid_params, # 이전에 추출한 시그모이드 매개변수\n    budget_bounds={'tv': [75, 296], 'radio': [10, 300], 'newspaper': [1, 25]} # 채널별 예산 제약 사항\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_22.png)\n\n표 4는 우리의 예산 배정 결과를 보여줍니다. 라디오는 추정 기여도가 가장 높은 채널이며, TV는 가장 높은 예산을 쓰도록 권장받은 채널입니다.\n\n# 시장 불확실성 하의 예산 배정\n\n현재 경제 상황에서 많은 불확실성을 겪고 있습니다. 따라서, 다양한 시나리오를 수용할 수 있는 예산 배정 전략을 설계해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 다른 시나리오를 고려해 봅시다:\n\n- 초기: 경제가 안정 상태를 유지하며, 예산 할당은 이전 섹션에서 계산된 것과 동일합니다.\n- 시나리오 2: 경제가 경기 침체를 겪고 예산이 40% 삭감됩니다.\n- 시나리오 3: 경제가 유리해지고 성장을 시작하며, 예산이 20% 증가합니다.\n\n이러한 다른 시나리오에서 예산 할당을 최적화하기 위해 동일한 적합된 MMM 모델과 모델의 시그모이드 매개변수를 사용할 것입니다. 같은 코드를 사용하지만 이번에는 사용 가능한 예산을 줄이거나 증가시키기 위해 다른 시나리오를 반복할 것입니다.\n\n```js\nscenarios_result = []\ntotal_budget = 500\nchannels = ['tv', 'radio', 'newspaper']\n\nfor scenario in np.array([0.6, 1.2]):\n    scenarios_result.append(\n        mmm.optimize_channel_budget_for_maximum_contribution(\n            method=\"sigmoid\",  # 포화 함수 정의\n            total_budget=total_budget * scenario,\n            parameters=sigmoid_params,\n            budget_bounds={\n                channel: [1, total_budget * scenario] for channel in channels\n            },\n        ).to_dict()\n    )\n_ = mmm.plot_budget_scenearios(\n    base_data=result_sigmoid, method=\"sigmoid\", scenarios_data=scenarios_result\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그림 19에서 보듯이, 경제 불황 시나리오에서 TV에 할당된 예산은 초기 시나리오와 비교했을 때 라디오보다 크게 감소합니다. 이는 라디오의 ROAS가 높기 때문에 예상되는 현상입니다. 반면, 성장 시나리오에서는 TV와 라디오에 할당된 예산이 유사하게 증가합니다.\n\n# 결론\n\n미디어믹스 모델링을 위한 AI는 투자에서 긍정적인 수익을 창출하고 가치 있는 충성고객을 확보하는 차이를 만들어줄 수 있습니다. 또는 잘못된 미디어 채널과 잘못된 고객에게 금전적 자원을 낭비하는 것 사이의 차이를 만들어줄 수도 있습니다.\n\n본 문서에서는 각 회사의 미디어 채널이 새로운 고객을 확보할 수 있는 잠재력을 더 자세히 평가하고 투명성을 제공할 수 있는 마케팅 믹스 모델링을 위한 베이지안 프레임워크를 개발했습니다. 우리의 접근 방식은 마케팅팀의 도메인 지식을 사전 분포를 설정함으로써 통합할 수 있습니다. 이는 모델의 능력을 향상시키고 미디어 채널과 관심 변수(예: 판매) 간의 관계를 이해하는데 도움이 됩니다. 마지막으로, 회사가 새로운 고객을 확보하기 위해 투자할 능력에 따라 예산 할당 전략을 최적화할 수 있습니다. 현재의 거시 경제 상황에서 기업은 수익성으로 돌아갈 수 있으며 성장에 투자할 예산을 줄일 수 있습니다. 우리는 영향을 최소화하면서 어디서 예산을 삭감할지에 대한 데이터 기반 의사결정 방법을 보여주었습니다. 반대로, 상황이 긍정적일 때 어디에 투자할지와 회사가 더 빨리 성장하기 위해 더 많은 자원을 투입하려는 경우 어디에 투자할지를 보여주었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 현재 기관들에 새로운 AI 애플리케이션을 개발하고 배포하고 있어요. 예를 들어, 우리는 생성 모델 AI로 고객 경험을 향상시키고 시계열 예측으로 계획 프로세스를 개선하고 있어요. 이 경우에는 AI가 마케팅 예산의 효율성을 향상시킬 수 있는 방법을 보여주고 있어요. 우리의 경험에 따르면, AI 채택 측면에서 선진적이고 성숙한 기관은 핵심 활동에 중점을 둔 특화된 AI 모델 스위트가 필요해요.\n\n# 나에 대해\n\nAI 분야의 시리얼 창업가이자 리더에요. 비즈니스를 위한 AI 제품을 개발하고 AI 중심의 스타트업에 투자하고 있어요.\n\nZAAI 설립자 | LinkedIn | X/Twitter\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고문헌\n\n[1] Yuxue Jin, Yueqing Wang, Yunting Sun, David Chan, Jim Koehler. (2017). Bayesian Methods for Media Mix Modeling with Carryover and Shape Effects.\n\n[2] Dominique M. Hanssens , Leonard J. Parsons , Randall L. Schultz. (2003). Market response models: econometric and time series analysis. Springer Science \u0026 Business Media.\n\n[3] Hill, A. V. (1910). 혈색소 분자의 집단화가 분리 곡선에 미치는 가능한 영향. Journal of Physiology, 40 (suppl), iv–vii. doi:10.1113/jphysiol.1910. sp001386.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[4] Gelfand, A. E. \u0026 Smith, A. F. (1990). Sampling-based approaches to calculating marginal densities. Journal of the American statistical association, 85 (410), 398–409\n\n---\n\n모든 이미지는 저자의 작품이며, 다르게 표기되지 않았습니다.","ogImage":{"url":"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_0.png"},"coverImage":"/assets/img/2024-06-20-MMMBayesianFrameworkforMarketingMixModelingandROAS_0.png","tag":["Tech"],"readingTime":20},{"title":"의사결정을 이끄는 매직 놀라움을 발견하라, 추천 시스템을 위한 도서관","description":"","date":"2024-06-20 02:04","slug":"2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems_0.png\" /\u003e\n\n정확히 무엇을 원하는지 모르지만 우리가 필요한 것의 일반적인 아이디어를 갖고 있을 때, 셔츠, 신발 또는 좋은 컴퓨터와 같은 것이더라도, 온라인 상점인 아마존, 알리익스프레스 또는 텀우 등을 방문하고 빠르게 결정을 내릴 수 있게 해주는 제안을 받습니다. 마치 마법처럼 우리에게 우리가 좋아하는 제품을 보여주는 것 같습니다, 디자인이나 색상 때문일 수도 있습니다. 넷플릭스, 애플 TV 또는 아마존 프라임 비디오 같은 스트리밍 플랫폼에서 우리가 좋아하는 쇼의 마지막 시즌을 마친 후 어떤 시리즈를 시청해야 할지 모를 때도 같은 일이 발생합니다. 이러한 사이트들은 우리가 선호하는 배우나 미래지향적인 시리즈 스타일 같은 정확한 추천을 도와줍니다. 이것이 바로 추천 시스템이 작동하는 방식입니다. 그러나 이러한 시스템이 어떻게 구축되는지 궁금했던 적이 있나요?\n\n오늘은 강력한 Python 라이브러리 Surprise를 사용하여 이러한 추천 시스템 중 하나가 어떻게 만들어지는지 이해하는 데 도움을 주기 위해 여행을 떠날 것입니다.\n\n여정의 시작: Surprise가 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 마법적인 도구가 있다고 상상해보세요. 이 도구는 추천 시스템을 쉽게 만들 수 있게 해줍니다. 이 도구는 'Surprise'라고 불리며, 이는 \"간단한 Python 추천 시스템 엔진\"을 의미합니다. Facebook의 영국에서 근무 중인 기계 학습 엔지니어이자 박사 후보인 닥터 니콜라스 휙(Nicolas Hug) 박사가 개발한 Surprise는 협업 필터링 기술을 중점으로 한 추천 시스템을 구축하고 분석하는 데 사용됩니다.\n\nSurprise는 추천 시스템(RS)을 생성하는 것뿐만 아니라 그러한 시스템을 평가하는 데 사용할 수 있는 다양한 알고리즘과 도구들을 제공합니다. SVD(특이값 분해)부터 KNN(K-최근접 이웃)까지, 이 라이브러리는 사용자 경험을 효과적으로 개인화하는 데 도움이 되는 다양한 방법을 제공합니다.\n\n우리의 선박: MovieLens 100k\n\n이러한 개념을 탐색하기 위해 우리는 유명한 MovieLens 100k 데이터 세트를 사용할 것입니다. 이 데이터 세트에는 100,000개의 사용자 평가 영화 순위가 포함되어 있으며, 이를 기반으로 추천 모델을 구축하고 평가할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n항해 시작: 데이터 로드 및 조작\n\n우리는 먼저 데이터셋을 로드하고 보다 쉽게 조작할 수 있는 형식으로 변환할 것입니다. Surprise를 사용하면 미리 정의된 또는 사용자 정의 데이터셋과 쉽게 작업할 수 있습니다. MovieLens 100k를 로드한 후에는 pandas DataFrame으로 변환하여 데이터를 보다 쉽게 조작하고 시각화할 수 있을 것입니다.\n\n바다 탐험: 데이터 이해와 시각화\n\n평점이 어떻게 분포되어 있는지를 보여주는 그래프를 생성할 것입니다. 이러한 그래프들은 데이터의 패턴과 트렌드를 명확하게 보여줄 것이며, 정확한 추천 모델을 구축하는 데 기본적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최적의 과정을 찾아가는 여정: 추천 모델\n\n우리는 Surprise가 제공하는 두 가지 강력한 알고리즘인 SVD와 KNN을 사용할 것입니다. SVD, 즉 특이값 분해는 등급에서 잠재적인 패턴을 식별하는 행렬 분해 기술입니다. 또한, 우리는 사용자 또는 항목 간 유사성에 기초한 KNN 또는 K-최근접 이웃 알고리즘을 사용하여 가장 가까운 이웃을 찾아주어 제공된 등급을 사용하여 추천을 할 수 있게 합니다.\n\n고도화된 과정: 모델 최적화\n\n우리는 모델의 하이퍼파라미터를 조정하여 정확도를 극대화할 것입니다. GridSearchCV를 통해 각 알고리즘에 대한 최상의 설정값을 찾을 때까지 다양한 매개변수 조합을 테스트할 것입니다. 이 연습의 끝에서는 RMSE(평균 제곱근 오차)와 MAE(평균 절대 오차) 메트릭을 사용하여 모델의 성능을 비교하여 이 특정한 경우에 가장 좋은 추천을 제공하는 모델을 명확히 이해할 수 있도록 결과를 시각적으로 확인할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n탐험의 여정\n\n이 여정 동안 Surprise 라이브러리가 추천 시스템의 생성과 평가를 어떻게 용이하게 도와주는지 안내해 드렸습니다. Surprise는 데이터 탐색부터 모델의 구축과 최적화에 이르기까지 정확하고 개인화된 추천 시스템(RS)을 구축하는 데 필요한 도구를 제공합니다.\n\nSurprise의 데이터 집합과 다양한 알고리즘 및 평가 도구를 활용할 수 있는 능력은 데이터 과학 분야의 초심자부터 전문가에 이르기까지 모두에게 이상적인 라이브러리로 만듭니다. 연구 프로젝트나 상용 응용프로그램 작업 중이던 상관없이 Surprise를 사용하면 추천 시스템을 간편하고 효과적으로 생성, 평가 및 최적화할 수 있습니다.\n\n다음 항해 때, 항해 차트 없이 하지 마세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 사용자의 경험을 정밀하고 관련성 높은 추천으로 개인화할 수 있는 가능성을 상상해 보세요. 다음으로 볼 영화를 제안하거나 완벽한 책을 추천하는 등, 추천 시스템은 사용자 상호작용을 개선하고 경험을 더 개인적으로 만드는 강력한 도구입니다.\n\nSurprise를 사용하면 강력하고 유연한 라이브러리를 활용하여 추천 시스템을 한 단계 더 발전시킬 수 있습니다. 다음으로 추천 시스템을 구축하고 싶을 때, 마법 같은 도구를 활용하기를 기억해 주세요. 이 흥미로운 AI 여행에 도전하고 Surprise가 제공할 수 있는 것을 발견해 보세요!\n\n```js\n# surprise 설치 및 import\n%pip install scikit-surprise\n```\n\n```js\n# 분석을 위한 필요한 라이브러리 import\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom surprise import Dataset, Reader, SVD, KNNBasic\nfrom surprise.model_selection import cross_validate, GridSearchCV\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# MovieLens 100k 데이터 세트 로드하기\ndata = Dataset.load_builtin('ml-100k')\n\n# 데이터 세트를 Pandas DataFrame으로 변환하여 탐색\nraw_ratings = data.raw_ratings\nratings_df = pd.DataFrame(raw_ratings, columns=['user_id', 'item_id', 'rating', 'timestamp'])\n```\n\n```js\n# 데이터 세트 탐색\nprint(\"DataFrame 상위 데이터:\")\nprint(ratings_df.head())\n\nprint(\"\\nDataFrame 설명:\")\nprint(ratings_df.describe())\n```\n\n```js\n# 데이터의 분포 그래프\nplt.figure(figsize=(12, 6))\n\n# 평점 분포\nplt.subplot(1, 2, 1)\nplt.hist(ratings_df['rating'], bins=np.arange(0.5, 6, 0.5), edgecolor='black')\nplt.title('평점 분포')\nplt.xlabel('평점')\nplt.ylabel('빈도')\n```\n\n```js\n# 사용자별 평가 수\nratings_per_user = ratings_df.groupby('user_id').size()\nplt.subplot(1, 2, 2)\nplt.hist(ratings_per_user, bins=50, edgecolor='black')\nplt.title('사용자별 평가 수')\nplt.xlabel('평가 수')\nplt.ylabel('빈도')\n\nplt.tight_layout()\nplt.show()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# 아이템별 평가 횟수\nratings_per_item = ratings_df.groupby('item_id').size()\nplt.figure(figsize=(12, 6))\nplt.hist(ratings_per_item, bins=50, edgecolor='black')\nplt.title('아이템별 평가 횟수')\nplt.xlabel('평가 횟수')\nplt.ylabel('빈도')\nplt.show()\r\n```\n\n```js\r\n# SVD를 사용한 추천 모델 생성\nalgo_svd = SVD()\n\n# 교차 검증을 통한 모델 평가\nresults_svd = cross_validate(algo_svd, data, measures=['RMSE', 'MAE'], cv=5, verbose=True)\n\nprint(\"\\nSVD 모델의 교차 검증 결과:\")\nprint(\"평균 RMSE: \", np.mean(results_svd['test_rmse']))\nprint(\"평균 MAE: \", np.mean(results_svd['test_mae']))\r\n```\n\n```js\r\n# KNN을 사용한 추천 모델 생성\nalgo_knn = KNNBasic()\n\n# 교차 검증을 통한 모델 평가\nresults_knn = cross_validate(algo_knn, data, measures=['RMSE', 'MAE'], cv=5, verbose=True)\n\nprint(\"\\nKNN 모델의 교차 검증 결과:\")\nprint(\"평균 RMSE: \", np.mean(results_knn['test_rmse']))\nprint(\"평균 MAE: \", np.mean(results_knn['test_mae']))\r\n```\n\n```js\r\n# SVD의 하이퍼파라미터 튜닝을 위한 GridSearchCV\nparam_grid = {\n    'n_epochs': [20, 30],\n    'lr_all': [0.002, 0.005],\n    'reg_all': [0.4, 0.6]\n}\ngs_svd = GridSearchCV(SVD, param_grid, measures=['rmse', 'mae'], cv=3)\ngs_svd.fit(data)\n\nprint(\"\\nSVD의 최적 하이퍼파라미터:\")\nprint(gs_svd.best_params['rmse'])\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# KNN을 위한 하이퍼파라미터 튜닝을 위한 GridSearchCV\r\nparam_grid = {\r\n    'k': [20, 30, 40],\r\n    'sim_options': {'name': ['msd', 'cosine', 'pearson'], 'user_based': [False]}\r\n}\r\ngs_knn = GridSearchCV(KNNBasic, param_grid, measures=['rmse', 'mae'], cv=3)\r\ngs_knn.fit(data)\r\n\r\nprint(\"\\nKNN을 위한 최적 하이퍼파라미터:\")\r\nprint(gs_knn.best_params['rmse'])\r\n```\r\n\r\n```js\r\n# SVD와 KNN의 결과 비교\r\nalgorithms = ['SVD', 'KNN']\r\nrmse_scores = [np.mean(results_svd['test_rmse']), np.mean(results_knn['test_rmse'])]\r\nmae_scores = [np.mean(results_svd['test_mae']), np.mean(results_knn['test_mae'])]\r\n```\r\n\r\n```js\r\n# 비교 그래프\r\nfig, ax = plt.subplots(1, 2, figsize=(14, 6))\r\n\r\n# RMSE 비교\r\nax[0].bar(algorithms, rmse_scores, color=['blue', 'green'])\r\nax[0].set_title('RMSE 비교')\r\nax[0].set_xlabel('알고리즘')\r\nax[0].set_ylabel('평균 RMSE')\r\n\r\n# MAE 비교\r\nax[1].bar(algorithms, mae_scores, color=['blue', 'green'])\r\nax[1].set_title('MAE 비교')\r\nax[1].set_xlabel('알고리즘')\r\nax[1].set_ylabel('평균 MAE')\r\n\r\nplt.tight_layout()\r\nplt.show()\r\n```\r\n\r\n참고 문헌 \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Hug, N. (2017). 놀라운 추천 시스템을 위한 Python 라이브러리. Journal of Open Source Software, 2(12), 1–4.\n- Hug, N. (2020). Surprise 문서. http://surpriselib.com 에서 확인\n- Ricci, F., Rokach, L., \u0026 Shapira, B. (2011). 추천 시스템 핸드북 소개. 추천 시스템 핸드북(pp. 1–35). Springer.\n- Koren, Y., Bell, R., \u0026 Volinsky, C. (2009). 추천 시스템을 위한 행렬 분해 기술. Computer, 42(8), 30–37.\n- Su, X., \u0026 Khoshgoftaar, T. M. (2009). 협업 필터링 기법 조사. 인공지능 발전, 2009, 4.\n- Bobadilla, J., Ortega, F., Hernando, A., \u0026 Gutiérrez, A. (2013). 추천 시스템 조사. 지식기반 시스템, 46, 109–132.","ogImage":{"url":"/assets/img/2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems_0.png"},"coverImage":"/assets/img/2024-06-20-TheMagicThatGuidesOurDecisionsDiscoveringSurprisetheLibraryforRecommendationSystems_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬 오피스 마법 PDF 파일 처리에 대한 완벽한 가이드","description":"","date":"2024-06-20 02:01","slug":"2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing","content":"\n\n![Python Office Magic](/assets/img/2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing_0.png)\n\n안녕하세요 여러분, 파이썬 오피스 매직 공유에 오신 것을 환영합니다! 오늘은 마법같은 기술 - 파이썬 PDF 자동화 처리를 탐험할 수 있도록 안내해 드리겠습니다. 오피스 워리어, 데이터 분석가 또는 열렬한 파이썬 애호가이든 여러분께 탁월한 편의성을 제공할 수 있다고 믿습니다.\n\n파이썬 PDF 자동화의 세계는 정말 흥미진진하고 다채롭습니다. 이러한 기술을 숙달하면 사무실에서 진정한 마법사가 되어 업무 효율을 향상시키고 더욱 흥미로운 일을 즐길 수 있습니다!\n\n# PDF 구문 분석 및 텍스트 추출\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째로 밝혀야 할 비밀은 PDF 구문 분석 및 텍스트 추출입니다. PDF에서 유용한 정보를 추출하는 방법이 궁금했던 적이 있나요? 걱정하지 마세요, Python이 도와줄 거예요. PyPDF2, FPDF, 그리고 reportlab과 같은 놀라운 라이브러리를 사용하여 PDF 파일을 구문 분석하고 거기서 텍스트 정보를 추출할 수 있어요.\n\n다음은 PyPDF2, FPDF, 그리고 reportlab 라이브러리에 대한 소개입니다:\n\n- PyPDF2 라이브러리: PyPDF2는 PDF 파일을 처리하기 위한 Python 라이브러리입니다. PDF 파일을 병합, 분할, 회전, 텍스트 추출, 페이지 추출, 워터마크 추가 등 다양한 기능을 제공해요. PyPDF2 라이브러리를 사용하여 PDF 파일의 내용을 읽고, 텍스트와 이미지를 추출할 수 있습니다. 또한 새로운 PDF 파일을 생성하거나 기존 파일을 수정하는 데 사용할 수 있어요. 다양한 PDF 작업에 적합한 기능이 풍부하고 사용하기 쉬운 라이브러리에요.\n- FPDF: FPDF는 PDF 파일을 생성하기 위한 Python 라이브러리입니다. Python 코드를 사용하여 텍스트, 이미지, 테이블, 그래픽 등의 요소를 포함한 표준 PDF 문서를 생성할 수 있어요. FPDF는 간단하고 사용하기 쉬워요. 기본적인 PDF 생성에 적합해요. 보고서, 문서, 인증서, 송장 등을 생성하는 데 FDPF를 사용할 수 있어요.\n- reportlab: reportlab은 복잡한 PDF 문서를 생성하기 위한 강력하고 유연한 Python 라이브러리에요. 텍스트, 이미지, 테이블, 그래픽, 글꼴 등을 처리할 수 있는 풍부한 기능을 제공하며, 고급 레이아웃과 스타일을 지원해요. 전문적인 PDF 보고서, 책, 데이터 시각화 등을 생성하는 데 적합한 널리 사용되는 라이브러리에요.\n\n먼저 모듈들을 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\npip install PyPDF2 FPDF reportlab\r\n```\n\n설치가 완료되면 PDF 파일을 다루는 재미를 즐길 수 있어요.\n\n특별 안내: 이 모듈의 API를 배울 때 주의해야 할 문제가 있어요. PdfFileReader, PdfFileWriter, PdfFileMerger 클래스는 3.0.0 버전에서 삭제될 예정이에요. PdfReader, PdfWriter 및 PdfMerger를 대신 사용하는 것이 좋습니다.\n\n저는 PyPDF2 (버전 3.0.1)를 설치했고, 다음 코드만이 정상적으로 실행되는 것을 확인했어요. 모두가 버전 호환성 문제에 주의해야 해요.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport PyPDF2\n\n# PDF 파일 열기\nwith open('example.pdf', 'rb') as file:\n  # PDF 리더 객체 생성\n  reader = PyPDF2.PdfReader(file)\n  \n  # PDF 파일의 페이지 수 가져오기\n  num_pages = len(reader.pages)\n  \n  # 페이지별로 텍스트 내용 추출하고 출력\n  for page_num in range(num_pages):\n    page = reader.pages[page_num]\n    text = page.extract_text()\n    print(text)\n```\n\n안녕하세요! 이제 PDF에서 텍스트를 추출할 수 있어요. 마치 암호를 해독하는 탐정 같죠! 한 번 시도해보세요.\n\n# PDF 병합 및 분할\n\n이제 두 번째로 PDF 병합 및 분할입니다. 손에 든 여러 PDF 파일을 쉽게 병합하거나 큰 파일을 여러 작은 파일로 분할할 수 있어요. 다음 유쾌한 코드를 시도해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom PyPDF2 import PdfMerger, PdfReader, PdfWriter\n\n# PDF 병합기 생성\nmerger = PdfMerger()\n\n# 여러 PDF 파일 병합\nmerger.append('example.pdf')\nmerger.append('file2.pdf')\n\n# 병합된 파일 저장\nmerger.write('merged.pdf')\nmerger.close()\n\n# PDF 파일 분할\nwith open('merged.pdf', 'rb') as file:\n    reader = PdfReader(file)\n    num_pages = len(reader.pages)\n  \n    # 10 페이지씩 분할\n    for start in range(0, num_pages, 10):\n        end = min(start + 9, num_pages - 1)\n        writer = PdfWriter()\n    \n        # 지정 범위의 페이지를 새 파일에 추가\n        for page_num in range(start, end + 1):\n            writer.add_page(reader.pages[page_num])\n    \n        # 분할된 파일 저장\n        with open(f'part_{start+1}-{end+1}.pdf', 'wb') as output_file:\n            writer.write(output_file)\n\nprint(\"짜잔! 병합 및 분할 마법이 완료되었어요!\")\n```\n\n# PDF 양식 처리\n\n세 번째 기술은 PDF 양식 처리입니다. 많은 양의 PDF 양식 작성은 매우 지루한 작업이라는 것을 알고 계시죠. 하지만 걱정 마세요! 파이썬의 마법 같은 도우미가 여기에 있습니다! PyPDF2, pdfw, FPDF 등의 흥미로운 라이브러리를 사용하여 자동으로 양식 필드를 작성하고, 작성된 데이터를 읽거나 새로운 PDF 양식을 생성할 수 있습니다. 한 번 시도해보세요!\n\n```python\nfrom PyPDF2 import PdfReader, PdfWriter\nfrom reportlab.pdfgen import canvas\n\n# 자동으로 양식 필드 작성\ndef fill_form(input_file, output_file, data):\n    c = canvas.Canvas(output_file)\n    c.setFont(\"Helvetica\", 12)\n    \n    # 입력 파일 읽고 페이지별로 처리\n    reader = PdfReader(input_file)\n    for page_num, page in enumerate(reader.pages, start=1):\n        # 페이지 크기 얻고 해당 크기로 캔버스 생성\n        page_width = float(page.mediabox.width)\n        page_height = float(page.mediabox.width)\n        c.setPageSize((page_width, page_height))\n        \n        # 페이지 내용 그리기\n        c.showPage()\n        \n        # 페이지에 양식 필드가 있는지 확인\n        if '/Annots' in page:\n            # 모든 양식 필드 탐색\n            for annot in page['/Annots']:\n                # 필드 유형이 텍스트 영역인지 확인\n                if '/T' in annot and '/V' in annot and annot['/Type'] == '/Annot':\n                    field_name = annot['/T'][1:-1]  # 필드 이름 가져오기\n                    # 필드 값을 수신 데이터로 교체\n                    if field_name in data:\n                        field_value = data[field_name]\n                        c.drawString(annot['/Rect'][0], annot['/Rect'][1], field_value)\n    \n    # 채워진 데이터가 포함된 PDF 저장\n    c.save()\n\n# 채워진 데이터 읽기\ndef read_form_data(input_file):\n    data = {}\n    reader = PdfReader(input_file)\n    \n    # 모든 페이지 탐색\n    for page in reader.pages:\n        # 양식 필드가 있는지 확인\n        if '/Annots' in page:\n            # 모든 양식 필드 탐색\n            for annot in page['/Annots']:\n                # 필드 유형이 텍스트 영역인지 확인\n                if '/T' in annot and '/V' in annot and annot['/Type'] == '/Annot':\n                    field_name = annot['/T'][1:-1]  # 필드 이름 가져오기\n                    field_value = annot['/V'][1:-1] if isinstance(annot['/V'], str) else ''\n                    data[field_name] = field_value\n    \n    return data\n\n# 새 PDF 양식 생성\ndef create_form(output_file, data):\n    c = canvas.Canvas(output_file)\n    c.setFont(\"Helvetica\", 12)\n    \n    # 데이터를 양식에 행별로 추가\n    y = 800\n    for field, value in data.items():\n        c.drawString(50, y, f\"{field}: {value}\")\n        y -= 20\n    \n    # 양식 저장\n    c.save()\n\n# 양식 필드 작성하고 저장\nfill_form('form_template.pdf', 'filled_form.pdf', {'name': 'joe', 'age': '18'})\n\n# 채워진 데이터 읽고 출력\nform_data = read_form_data('filled_form.pdf')\nprint(form_data)\n\n# 새 PDF 양식 생성\ncreate_form('my_form.pdf', {'name': 'joe', 'age': '18'})\n\nprint(\"마법 완료! 이제 PDF 양식을 쉽게 처리할 수 있어요!\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 이제 여러분은 폼 처리의 위대한 마법사가 되셨습니다! 파이썬에게 이 잡다한 폼 작업을 처리하도록 맡기세요!\n\n# PDF 문서 변환\n\n다음으로 소개할 것은 PDF 문서 변환입니다. 때로는 PDF의 형식이 매우 편리하지 않을 수 있으며, PDF를 이미지, HTML 또는 일반 텍스트와 같은 다른 형식으로 변환하고 싶을 수 있습니다. 함께 변환의 마법을 탐험해 봅시다!\n\nPDF 문서를 다른 형식으로 변환할 때, 이를 위해 다양한 라이브러리와 도구를 사용할 수 있습니다. 각 변환 유형에 대한 이론적 설명과 해당 샘플 코드가 다음에 나와 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## PDF를 이미지로 변환하기\n\nPDF를 이미지로 변환하려면 pdf2image 라이브러리를 사용할 수 있어요. 이 라이브러리는 PDF 페이지를 이미지 형식(JPEG, PNG 등)으로 변환할 수 있어요. PDF를 이미지로 변환하는 예제 코드를 확인해보세요:\n\n```python\nfrom pdf2image import convert_from_path\n\ndef pdf_to_image(input_file, output_file):\n    images = convert_from_path(input_file)\n    for i, image in enumerate(images):\n        image.save(f'{output_file}_{i}.jpg', 'JPEG')\n\npdf_to_image('input.pdf', 'output_image')\n```\n\npdf_to_image 함수를 호출하여 입력 PDF 파일을 이미지로 변환하고 JPEG 형식의 이미지 파일로 저장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: pdf2image.exceptions.PDFInfoNotInstalledError 오류 메시지가 발생한다면, 이 오류는 일반적으로 poppler-utils 종속성이 누락되었을 때 발생합니다. 이 문제를 해결하려면 다음과 같은 단계를 따르세요:\n\nWindows：\n\n- 다음 웹사이트를 방문하세요: github.com/oschwartz10…\n- \"Assets\" 섹션에서 귀하의 운영 체제에 적합한 poppler-x.x.x_x 버전을 다운로드하세요.\n- 다운로드한 파일을 해제하고 해당 경로를 시스템 환경 변수에 추가하세요.\n\nmacOS：\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHomebrew를 통해 Poppler를 설치해보세요. 아래 명령어를 실행해보세요:\n\n```bash\nbrew install poppler\n```\n\nUbuntu/Debian:\n\nPoppler를 설치해보세요. 아래 명령어를 실행해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo apt-get install poppler-utils\n```\n\n설치가 완료되면 Python 환경을 다시 시작하고 pdf_to_image 함수를 실행해보세요. 이렇게 하면 PDF를 이미지로 성공적으로 변환할 수 있습니다.\n\n## PDF를 HTML로 변환\n\nPDF 파일을 HTML 형식으로 변환하려면 PyPDF2와 같은 PDF 파싱을 지원하는 라이브러리를 사용할 수 있습니다. 다음은 PDF를 HTML로 변환하는 예제 코드입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom PyPDF2 import PdfReader\n\ndef pdf_to_html(input_file, output_file):\n    with open(input_file, 'rb') as file:\n        reader = PdfReader(file)\n        text = \"\"\n        \n        # Extract text content page by page\n        for page in reader.pages:\n            text += page.extract_text()\n        \n        # Save as HTML file\n        with open(output_file, 'w') as html_file:\n            html_file.write(f\"\u003chtml\u003e\u003cbody\u003e{text}\u003c/body\u003e\u003c/html\u003e\")\n\npdf_to_html('input.pdf', 'output.html')\n```\n\npdf_to_html 함수를 호출하여 입력 PDF 파일을 HTML 형식으로 변환하고 결과를 출력 파일에 저장할 수 있습니다.\n\n## PDF를 일반 텍스트로 변환하기\n\nPDF를 일반 텍스트 형식으로 변환하려면 pdfminer 라이브러리를 사용할 수 있습니다. PDF 문서에서 텍스트를 추출하는 강력한 도구입니다. PDF를 일반 텍스트로 변환하는 예시 코드는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npdfminer.six 라이브러리: 이것은 Python 3 전용으로 작성된 pdfminer 라이브러리의 새 버전입니다. PDF 구문 분석의 현대적인 구현이며 지속적인 유지 보수와 업데이트를 받습니다. pdfminer.six 라이브러리는 Python 2 및 Python 3 모두와 호환되므로 Python의 최신 버전에서 사용할 수도 있고 일부 이전 버전도 지원합니다.\n\n의존성 설치: pdfminer.six 라이브러리 사용\n\n```js\npip install pdfminer.six\n```\n\n샘플 코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom pdfminer.high_level import extract_text_to_fp\n\ndef pdf_to_text(input_file, output_file):\n    with open(output_file, 'w') as text_file:\n        with open(input_file, 'rb') as file:\n            extract_text_to_fp(file, text_file)\n\npdf_to_text('input.pdf', 'output.txt')\n```\n\npdf_to_text 함수를 호출하여 입력 PDF 파일을 일반 텍스트 형식으로 변환하고 결과를 출력 파일에 저장할 수 있습니다.\n\n## PDF를 워드 문서로 변환\n\nPDF를 워드 문서로 변환하려면 python-docx와 같은 서드파티 라이브러리를 사용할 수 있습니다. 이 라이브러리를 사용하여 워드 문서를 생성하고 편집할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬-docx 라이브러리에 대한 소개입니다:\n\n- 파이썬-docx 라이브러리: 파이썬-docx는 Microsoft Word 문서를 생성하고 수정하기 위한 파이썬 라이브러리입니다. 이는 간단하면서도 강력한 API를 제공하여 코드를 통해 Word 문서를 생성, 수정 및 조작할 수 있습니다. 파이썬-docx를 사용하면 문단, 글꼴 스타일, 표, 이미지 및 기타 내용을 추가할 수 있습니다. 또한 기존 문서의 스타일과 내용을 수정할 수 있습니다. Word 2007 및 그 이상 버전을 위한 docx 파일 형식을 지원합니다.\n\n의존성 설치:\n\n```js\npip install python-docx PyPDF2\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 PDF를 워드 문서로 변환하는 예제 코드입니다:\n\n```python\nfrom docx import Document\nfrom PyPDF2 import PdfReader\n\ndef pdf_to_word(input_file, output_file):\n    with open(input_file, 'rb') as file:\n        reader = PdfReader(file)\n        text = \"\"\n        \n        # 페이지별 텍스트 내용 추출\n        for page in reader.pages:\n            text += page.extract_text()\n        \n        # 워드 문서 생성\n        doc = Document()\n        doc.add_paragraph(text)\n        \n        # 워드 문서로 저장\n        doc.save(output_file)\n\npdf_to_word('input.pdf', 'output.docx')\n```\n\npdf_to_word 함수를 호출하여 입력 PDF 파일을 워드 문서로 변환하고 결과를 출력 파일에 저장할 수 있습니다.\n\n위의 예제 코드를 실행하기 전에 필요한 라이브러리와 종속성이 설치되어 있는지 확인해주세요. 누락된 라이브러리는 pip 명령을 사용하여 설치할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n샘플 코드를 통해 PDF 파일을 다른 형식으로 변환하는 데 도움이 될 수 있기를 바랍니다. 궁금한 점이 있으면 언제든지 질문해 주세요!\n\n# PDF 워터마크와 서명\n\n이제 PDF 워터마크와 디지털 서명의 마법을 소개합니다! PDF 파일에 워터마크나 디지털 서명을 추가하면 저작권 보호와 보안을 강화할 수 있다고 상상해 보세요. 이 마법 같은 판타지 세계로 함께 들어가 봅시다:\n\n```js\nfrom PyPDF2 import PdfReader, PdfWriter\nfrom reportlab.pdfgen import canvas\nimport io\n\n# PDF에 워터마크 추가\ndef add_watermark(input_file, output_file, watermark_text):\n    reader = PdfReader(input_file)\n    writer = PdfWriter()\n\n    watermark_buffer = io.BytesIO()\n\n    # 워터마크가 있는 PDF를 만듭니다.\n    c = canvas.Canvas(watermark_buffer)\n    c.setFont(\"Helvetica\", 48) # 폰트 선택에 유의하세요.\n    c.rotate(45)\n    c.translate(-500, -500)\n    c.setFillAlpha(0.3)\n    c.drawString(400, 400, watermark_text)\n    c.save()\n\n    watermark_buffer.seek(0)\n    watermark_pdf = PdfReader(watermark_buffer)\n\n    # 각 페이지를 탐색합니다.\n    for i, page in enumerate(reader.pages, start=1):\n        watermark_page = watermark_pdf.pages[0]\n\n        # 페이지에 워터마크 추가\n        page.merge_page(watermark_page)\n        writer.add_page(page)\n\n    # 워터마크가 있는 파일로 저장합니다.\n    with open(output_file, 'wb') as file:\n        writer.write(file)\n\n# PDF에 디지털 서명 추가\ndef add_signature(input_file, output_file, signature_image):\n    reader = PdfReader(input_file)\n    writer = PdfWriter()\n\n    # 각 페이지를 탐색합니다.\n    for i, page in enumerate(reader.pages, start=1):\n        # 페이지 우측 하단에 서명 이미지 추가\n        page.merge_page(signature_image)\n        writer.add_page(page)\n\n    # 서명이 있는 문서를 저장합니다.\n    with open(output_file, 'wb') as file:\n        writer.write(file)\n\n# add_watermark() 및 add_signature() 함수를 사용하여 워터마크와 서명을 추가합니다.\nwatermark_text = \"기밀 문서, 비밀 유지해주세요.\"\nsignature_image = PdfReader(\"signature.pdf\").pages[0]\n\nadd_watermark('part_21-30.pdf', 'document_with_watermark.pdf', watermark_text)\nadd_signature('document_with_watermark.pdf', 'document_with_watermark_and_signature.pdf', signature_image)\n\nprint(\"워터마크 및 서명 마법이 완료되었습니다! 이제 PDF 파일을 더 안전하고 전문적으로 만들 수 있습니다!\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕 안녕 안녕, 이제 PDF 워터마크와 서명의 초강력 마법사가 되었다구요! 문서들이 마법과 보호로 가득 차도록 해봅시다!\n\n# PDF 보고서 생성\n\n이제, 우리는 마지막 마법 조각을 탐험할 준비가 되었습니다! PDF 보고서 생성, 파이썬의 힘을 활용하여 차트, 테이블, 텍스트를 포함한 다양하고 아름다운 PDF 보고서를 생성해보세요. 함께 이 마법 같은 여정을 떠나봐요!\n\n의존성 설치:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npip install pytesseract\n```\n\n```js\nimport matplotlib.pyplot as plt\nfrom reportlab.lib.pagesizes import A4\nfrom reportlab.platypus import SimpleDocTemplate, Table, Image\nfrom reportlab.lib.styles import getSampleStyleSheet\nfrom reportlab.platypus import Paragraph, Spacer\n\n# 보고서 내용 생성\ndef create_report(output_file, data):\n    # PDF 문서 개체 생성\n    doc = SimpleDocTemplate(output_file, pagesize=A4)\n\n    # 스타일 시트 로드\n    styles = getSampleStyleSheet()\n\n    # 보고서 내용 요소 생성\n    elements = []\n\n    # 제목 추가\n    title = Paragraph(\"판매 보고서\", styles[\"Title\"])\n    elements.append(title)\n    elements.append(Spacer(1, 20))\n\n    # 테이블 추가\n    table_data = data\n    table = Table(table_data)\n    elements.append(table)\n    elements.append(Spacer(1, 20))\n\n    # 차트 생성 및 PNG 이미지로 저장\n    plt.plot(data[1][1:], marker='o')\n    plt.xlabel(\"날짜\")\n    plt.ylabel(\"매출액\")\n    plt.title(\"매출 트렌드 차트\")\n    plt.savefig(\"sales_plot.png\")\n    plt.close()\n\n    # 차트를 보고서 내용에 추가\n    image = Image(\"sales_plot.png\", width=400, height=300)\n    elements.append(image)\n\n    # 보고서 생성\n    doc.build(elements)\n\n# 보고서 데이터 생성\nreport_data = [\n    [\"날짜\", \"매출액\"],\n    [\"1/1\", 100],\n    [\"1/2\", 200],\n    [\"1/3\", 150],\n    [\"1/4\", 300],\n]\n\n# 보고서 생성\ncreate_report('sales_report.pdf', report_data)\n\nprint(\"테이블 생성이 완료되었습니다! 이제 생성된 보고서 파일을 확인할 수 있습니다.\")\n```\n\n# OCR (Optical Character Recognition)\n\n마지막으로 OCR (Optical Character Recognition)가 있습니다. 몇 장의 스캔된 PDF 문서가 있고 이를 검색 가능하고 편집 가능한 텍스트로 변환해야 한다고 상상해보세요. Python이 이를 가능하게 해줄 수 있다는 좋은 소식이 있습니다! 이 마법 같은 주문을 함께 체험해봅시다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport pdf2image\nimport pytesseract\n\n# PDF를 이미지로 변환\ndef pdf_to_image(input_file):\n    images = pdf2image.convert_from_path(input_file)\n    return images\n\n# OCR을 사용하여 이미지를 텍스트로 변환\ndef image_to_text(image):\n    text = pytesseract.image_to_string(image)\n    return text\n\n# 텍스트를 파일에 저장\ndef save_text_to_file(text, output_file):\n    with open(output_file, 'w', encoding='utf-8') as file:\n        file.write(text)\n\n# PDF에서 텍스트 추출\ndef extract_text_from_pdf(input_file, output_file):\n    # PDF를 이미지로 변환\n    images = pdf_to_image(input_file)\n    \n    extracted_text = \"\"\n    \n    # 각 이미지에서 텍스트 추출\n    for image in images:\n        text = image_to_text(image)\n        extracted_text += text + \"\\n\"\n    \n    # 추출된 텍스트를 파일에 저장\n    save_text_to_file(extracted_text, output_file)\n\n# 스캔된 PDF에서 텍스트 추출\nextract_text_from_pdf('scanned_document.pdf', 'extracted_text.txt')\n\nprint(\"OCR (광학 문자 인식) 매직이 완료되었습니다! 이제 스캔된 PDF 문서를 편집 가능한 텍스트로 변환할 수 있어요!\")\n```\n\n와우, 이제 이미 OCR 마술사가 되었네요! Python이 이 스캔된 PDF 파일을 해석해줄게요!\n\n# 끝에 작성됨\n\n대단해요! 우리는 방금 Python PDF 자동화 처리의 일곱 가지 마법 중 하나를 마스터했어요! PDF 구문 분석 및 텍스트 추출, PDF 병합 및 분할, PDF 양식 처리, PDF 문서 변환, PDF 워터마킹 및 서명, PDF 보고서 생성 및 OCR(광학 문자 인식)을 포함해요. 정말 진정한 오피스 마법사가 되셨네요! 파일 처리, 보고서 생성 또는 텍스트 추출, Python이 도와드릴 준비가 되어있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 흥미로운 지식 포인트들과 재미있는 설명으로 파이썬 PDF 자동화의 세계에 매료되셨군요. 파이썬 지식에 대해 더 알고 싶다면 제 팔로우를 해주세요! 함께 파이썬의 끝없는 가능성을 탐험해봐요!","ogImage":{"url":"/assets/img/2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing_0.png"},"coverImage":"/assets/img/2024-06-20-PythonOfficeMagicACompleteGuidetoPDFFileProcessing_0.png","tag":["Tech"],"readingTime":16},{"title":"LLM ABCs LLM으로 동력을 주는 애플리케이션 구축 - AI 미래를 여는 게이트웨이","description":"","date":"2024-06-20 01:58","slug":"2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture","content":"\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_0.png)\n\nAI는 방대한 주제입니다. 어디서부터 시작해야 할지 알기 어려운 주제입니다. 개발자, 연구자, 그리고 꿈꾸는 이들을 위해 길을 밝혀 주는 방법은 무엇일까요?\n\n하지만 매일 뉴스에서 자주 듣는 AI 열풍과 항상 반복되는 AI 거품에도 불구하고, AI에 대한 지식이 표면적으로만 알려져 있습니다. \n\nAI는 멋진 가전제품에 관한 것만이 아닙니다; 의료부터 교육까지 저희의 미래를 형성하는 중요한 요소이며, 우리는 수동적인 방관자가 아니라 정보를 알고 참여해야 합니다. 🌐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n분산된 뉴스, 바이럴 트윗 또는 재미난 유튜브 클립으로 수영을 배우려는 것은 끝없이 재밌겠지만 수심에서 생존할 수는 없는 것과 같아요! 🏊‍♂️\n\n지금, 여기, 이 순간이 바로 AI와 대형 언어 모델의 ABC를 해석해주는 포괄적인 책과 체계적인 코스에 뛰어들기에 더 좋을 때는 없어요. 이들은 AI 지식의 바다에서 우리의 지적 능력을 지켜주는 인생 보트 같은 역할을 해요.\n\nValentina Alto의 \"LLM-파워 어플리케이션 구축\"은 인공지능에 대한 올바른 안내서예요. 이 책은 단순한 매뉴얼 이상이에요: 이 책은 인간의 한계로 묶인 언어 모델이 존재하지 않는 세계로 데려다주는 여권 같아요. 여기서는 상상 이상의 신기한 것들을 어떻게 창조할지 배울 수 있어요.\n\n이 기사에서는 책에 대해 이야기하고, LangChain과 대형 언어 모델에 대한 이해를 통해 우리가 어떻게 배울 수 있고 할 수 있는지 몇 가지 예시를 제시할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_1.png)\n\n# LLM-Powered 애플리케이션 개발\n\n이른바 20개월 전부터 인공지능을 배우기 시작했어요. 처음에는 캐글 코스를 통해 머신러닝을 배웠는데, 아마도 내가 들어본 최고의 무료 강의였을 거에요.\n\nChatGPT 출시 후, 생성 모델 AI는 긴급한 문제가 되었어요. 새로운 시대의 징후인 걸 분명히 알았고, 나에게는 더 이상의 경고 같은 것이었어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChatGPT의 등장과 생성형 AI의 신속한 발전은 기술 발전의 중요한 새 단계를 의미합니다. 저에게 이는 최신 트렌드를 따라가는 것 이상을 의미합니다. 이는 교육부터 의료, 금융, 창의적 예술 등 모든 산업이 어떻게 혁신되는지를 이해하는 것입니다.\n\n\"학습하기\"는 이러한 시스템을 구동하는 기계 학습, 자연 언어 처리(NLP), 딥 러닝의 원리를 깊게 파고들어 흥미를 느껴보는 것을 의미합니다. 포함된 내용은 다음과 같습니다:\n\n- 기초 이해: 지도 및 비지도 학습, 강화 학습, 그리고 이를 지원하는 알고리즘을 포함한 AI 및 기계 학습의 기초를 학습으로 시작합니다.\n- 자연 언어 처리(NLP): 중요한 역할을 하는 NLP에 대해 더 깊게 이해해보세요. \n- 윤리와 영향: AI의 윤리적 고려사항, 개인정보 보호, 편향, 그리고 이러한 기술의 사회적 영향에 대해 공부합니다. 기술적 지식과 동등한 중요성을 가집니다.\n- 실용적인 실행: 생성형 모델을 사용해볼 수 있는 플랫폼 및 도구를 실험해보세요. OpenAI의 API, TensorFlow, PyTorch, Hugging Face를 시작점으로 활용할 수 있습니다.\n- 지속적인 학습: AI는 빠르게 진화하는 분야입니다. 연구 논문, 온라인 강의, 팟캐스트, 그리고 회의 등을 통해 최신 정보를 유지합니다.\n- 창의성과 응용: 생성형 AI가 특정 분야에서 혁신을 통해 어떻게 활용될 수 있는지 고민해보세요. 콘텐츠 생성, 고객 서비스 자동화, 복잡한 문제 해결에 도움을 줄 수 있습니다.\n\nValentina Alto의 \"Building LLM-Powered Applications\"는 최근 몇 주간 인공 지능에 대한 나의 안내서가 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작가는 LLM의 복잡한 메커니즘을 해소하여 건설자의 도구상자로 변환하는 능력이 있습니다. 우리가 사랑하는 레고 브릭으로 돌아간 것과 같습니다. 그녀는 \"인간과는 달리, LLM은 스스로 오류에서 회복할 수 없다\"는 현실을 회피하지 않습니다.\n\n하지만 그녀는 여러분이 이러한 분야를 능숙하게 탐험할 수 있도록 장비합니다! 각 장은 독립적으로 읽을 수 있지만, 순서는 무작위가 아닙니다. 장의 진행은 보다 견고한 AI 솔루션을 구축하는 방향으로 나아가는 연속성을 가지고 있습니다.\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_2.png)\n\n## ReAct와 웹 검색\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 한 예가 있어요: 프로젝트 중 하나를 골라서 오직 오픈 소스 LLMs와 함께 작동하도록 수정했어요. 4장의 지침을 따라 ReAct를 살펴봅시다. 이 프로젝트는 추론과 행동을 결합한 일반적인 패러다임인데요. ReAct는 언어 모델에게 작업을 위한 언어적 추론 트레이스와 행동을 생성하도록 유도하며, 또한 웹 검색이나 데이터베이스와 같은 외부 소스로부터 관측을받습니다.\n\n먼저, 몇 가지 종속성을 설치하고 HuggingFace Gradio API를 사용하여 Qwen-1.5-72b-chat 모델을 무료로 둘러싸봐요(여기서 자세히 읽을 수 있어요): Google Colab 노트북의 무료 런타임을 사용 중이에요.\n\n종속성 설치\n\n```js\n%pip install --upgrade --quiet gradio_tools huggingface_hub langchain langchain-community langgraph google-search-results faiss-cpu tiktoken duckduckgo-search\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM을 마무리해봅시다\n\n```js\nfrom langchain_core.language_models.llms import LLM\nclass GradioLLMChat(LLM):\n    \"\"\"\n    Gradio API 호출을 기반으로 한 사용자 정의 LLM 클래스입니다.\n    HF Spaces API의 Qwen 1.5-72b-chat을 사용합니다.\n    \"\"\"\n    from typing import Any, Dict, Iterator, List, Mapping, Optional\n    from langchain.callbacks.manager import CallbackManagerForLLMRun\n    from langchain_core.language_models.llms import LLM\n    from langchain_core.outputs import GenerationChunk\n    from langchain_core.output_parsers import StrOutputParser\n    from langchain_core.prompts import ChatPromptTemplate\n    from gradio_client import Client\n    chatbot: Any = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.chatbot = Client(\"https://qwen-qwen1-5-72b-chat.hf.space/--replicas/061qr/\")\n\n    @property\n    def _llm_type(self) -\u003e str:\n        return \"Gradio API client Qwen1.5-72b_Chat\"\n\n    def _call(\n            self,\n            prompt: str,\n            stop: Optional[List[str]] = None,\n            run_manager: Optional[CallbackManagerForLLMRun] = None,\n            chatbot=None,\n            request: float = 0.95, # 과거 정보를 의미합니다.\n            param: str = 'You are a helpful assistant', # 시스템 메시지입니다.\n    ) -\u003e str:\n        \"\"\"\n        지정된 프롬프트를 사용하여 Gradio API 클라이언트 Qwen1.5-72b_Chat에 API 호출을 수행하고 응답을 반환합니다.\n        \"\"\"\n        if chatbot is None:\n            chatbot = self.chatbot\n\n        # API로부터 응답 반환\n        result = chatbot.predict(   # '.submit'은 스트리밍 효과를 얻기 위해, '.predict'은 일반적인 출력을 얻기 위해 사용됩니다.\n                param, # 'Input' 텍스트 상자 구성 요소에 대한 문자열\n                [], # 'Qwen1.5-72B-Chat' 챗봇 구성 요소의 Tuple[str | Dict(file: filepath, alt_text: str | None) | None, str | Dict(file: filepath, alt_text: str | None) | None]\n                prompt, # 'parameter_9' 텍스트 상자 구성 요소에 대한 문자열\n                api_name=\"/model_chat\"\n        )\n        return result[1][0][1}\r\n```\n\n이제 DuckDuckGo 무료 API 검색 엔진(최신 정보만)을 만들어 LLM에 도구로 바인딩할 준비가 되었습니다. 첫 번째 무료 에이전트가 준비되었습니다!\n\n```js\nimport os\n#from https://python.langchain.com/v0.1/docs/integrations/tools/ddg/\nfrom langchain_community.utilities import DuckDuckGoSearchAPIWrapper\n#wrapper = DuckDuckGoSearchAPIWrapper(region=\"de-de\", time=\"d\", max_results=8)\nfrom langchain.agents import AgentType, initialize_agent\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.tools import BaseTool, StructuredTool, Tool, tool\nfrom langchain.schema import HumanMessage\nfrom gradio_client import Client\n\nmodel = GradioLLMChat()\nsearch = DuckDuckGoSearchAPIWrapper(max_results=5)\ntools = [\n    Tool.from_function(\n        func=search.run,\n        name=\"Search\",\n        description=\"useful for when you need to answer questions about current events, search online news\"\n    )\n    ]\n\nagent_executor = initialize_agent(tools, model, \n                                agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, \n                                verbose=True)\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 에이전트 템플릿을 출력하면 우리가 다루는 내용에 대한 감을 잡을 수 있어요…\n\n```js\nprint(agent_executor.agent.llm_chain.prompt.template)\n\n다음 질문에 최대한으로 답해보세요. 다음의 도구를 사용할 수 있어요:\n\nSearch(query: str) -\u003e str - 현재 사건에 대한 질문에 대답해야 할 때 온라인 뉴스를 검색하는 데 유용\n\n다음 형식을 사용하세요:\n\n질문: 답해야 하는 입력 질문\n생각: 언제나 무엇을 해야 하는지 생각해야 해요\n행동: 하나의 [Search] 중 하나여야 하는 행동\n행동 입력: 행동에 대한 입력\n관찰: 행동의 결과\n... (이 생각/행동/행동 입력/관찰은 N번 반복될 수 있어요)\n생각: 이제 최종 답을 알게 되었어요\n최종 답변: 처음 입력된 질문에 대한 최종 답변\n\n시작!\n\nQuestion: {input}\nThought:{agent_scratchpad}\n```\n\n이제 에이전트를 실행시켜봐서, 2024년 5월 프라임 미니스터 지오르자 멜로니가 총독 중 한 명을 만났을 때 무슨 일이 있었는지 알려줄 거예요\n\n```js\nagent_executor('온라인 뉴스에서 2024년 5월 지오르자 멜로니가 델루카 총독을 만난 사건을 알려줘')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이것을 실행하면 최종 답을 얻기 전에 에이전트가 하는 일에 대한 멋진 설명을 받을 수 있어요\n\n```js\n\u003e 새로운 AgentExecutor 체인에 진입 중...\n\n이 특정 이벤트에 대한 관련 정보를 찾기 위해 검색 기능을 사용해야 합니다.\n\n**작업: 검색(Search)** \n작업 입력: \"May 2024 Giorgia Meloni governor De Luca incident\"\n관찰: Leggi su Sky TG24 l'articolo De Luca risponde a Meloni dopo incontro Caivano: \"Ha comunicato sua vera identità\" ... 29 mag 2024 - 14:21 ... Dal presidente del Consiglio Giorgia Meloni, ha ... \"Presidente De Luca, la stronza della Meloni!''. La premier stringe la mano al governatore della Campania così, ricordandogli come il … Nel corso di Tagadà, su La7, viene mandato il passaggio delle comunicazioni social di De Luca che a mente fredda contrattacca ad alzo zero contro Meloni. Ecco i rosicon...zi contro Giorgia. Da De ... Caivano (Napoli), 28 maggio 2024 - È ancora lite tra la premier Giorgia Meloni e Vincenzo De Luca, presidente della Regione Campania. L'occasione, questa volta, la offre l'inaugurazione del ... Premier Giorgia Meloni introduced herself as \"that bitch\" to Campania Governor Vincenzo De Luca on Tuesday after he called her a 'stronza' (bitch) when talking to reporters in the Lower House in ...\n\n**생각:** 이제 최종 답을 알게 되었어요\n\n**최종 답:**  \n2024년 5월, 이탈리아 총리 조르자 멜로니(Giorgia Meloni)와 카만니아 주지사 빈첸조 데 루카(Vincenzo De Luca) 사이에 너프 공식 행사 중 사건이 발생했어요. 지난 주, 주지사 데 루카가 통신사에 대한 발언 중에서 멜로니를 \"stronza\"로 불렀고 이는 둘 사이에 긴장을 일으켰어요. 그들의 만남 동안 멜로니가 데 루카에게 \"그 짜증나는 여자\"라고 자신을 소개했다는 소문이 있어요. 이 교환은 추가적인 논란과 언론의 주목을 불러일으켰어요.\n```\n\n와우... 정말 멋지죠! 그리고 완전 무료로 할 수 있어요!\n\n이곳은 상기 코드를 사용한 GitHub 저장소 링크예요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_3.png)\n\n# 학습은 진행입니다\n\n책을 따라가는 중입니다. 제1장에서 이론과 실무의 교차로에 서 있는데요. 저자는 LLMs를 소개하고, 제5장에 와서는 실용적인 LangChain AI 애플리케이션을 직접 다뤘어요. 혁신적인 LLMs의 능력을 살려낸 실제 사용 사례가 섞인 놀라운 여정이에요.\n\n하지만 이 책을 돋보이게 하는 것은 그 포용적인 성격이죠. 파이썬 초보자부터 경험 많은 AI 전문가까지 누구나 환영받으며 지침을 제공합니다. 저자는 데이터 과학자, 스타트업 CTO, 초보자의 기대치에 부응할 수 있어요. 아무도 뒤쳐지지 않고 함께 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이것을 큰 소리로 말할 수 있어요! 전 인공 지능 전문가는 아니지만 배운 것으로 심지어 코드를 맞춤화해 제가 좋아하는 오픈 소스 접근 방식에 맞추어 만들었어요!\n\n그 다음은 프롬프트 엔지니어링인데, LLM 속삭임을 만들어내는 섬세한 예술로 여겨져요. 이것은 제4장에서 심포니로 묘사되어 있어요. 여기서는 작업을 분할하고 정당성을 요청하며, 심지어 LLM에게 여러 출력을 생성하도록 요청하는 법을 배워요. 불가피한 오류에 대한 똑똑한 해결책이에요. 혁신의 기회로 돌리는 믿음을 명확하게 보여주는 사례에요.\n\n# 우리는 책임이 있고, 우리는 책임을 져요\n\n\"LLM을 활용한 애플리케이션 개발\"은 단순히 매뉴얼이 아니에요; 책임 있는 인공 지능을 위한 선언문이에요. 12장은 AI의 윤리를 다루며, 위대한 권력이 따라오면 큰 책임이 따른다는 사실을 상기시켜 줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 새로운 스파이더맨은 아니지만, 확실히 에마파시와 선견지명으로 AI 파이오니어로서 만들어낸 결과물의 영향을 고려해야 합니다.\n\n마지막 페이지를 덮을 때, 단순히 지식뿐만 아니라 끝없는 가능성의 불꽃을 남깁니다. 이 책은 현실적이고 아름다운 프로젝트로 가득하며, 코드는 GitHub 저장소에서 설명되어 제공됩니다.\n\n만약 AI로의 여정을 떠날 준비가 되어 있다면, 입문 수준이든 지금이든 이 책이 여러분의 열쇠가 될 것입니다.\n\n기사를 즐겁게 읽어 주셨기를 바랍니다. 만약 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면, 아래 방법을 이용하실 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 이야기에 대해 많이 박수를 치다\n- 기억하기에 더 중요한 부분을 강조하세요 (나중에 찾기 쉽고 더 나은 기사를 쓸 수 있게 될 것입니다)\n- 자신만의 AI를 시작하는 방법 배우기, 무료 eBook 다운로드하다\n- 내 링크를 사용하여 Medium 멤버십 가입하기 — ($5/월로 무제한 Medium 이야기 읽기)\n- Medium에서 나를 따르다\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n더 흥미로운 글들을 소개합니다:\n\n추가 자료와 논문\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 이야기는 Generative AI에서 발행되었습니다. LinkedIn에서 저희와 연결하고 최신 AI 이야기를 놓치지 마세요.\n\n최신 뉴스 및 Generative AI의 업데이트를 받으려면 저희 뉴스레터를 구독하세요. 함께 AI의 미래를 함께 모양잡아요!\n\n![이미지](/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_5.png)","ogImage":{"url":"/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_0.png"},"coverImage":"/assets/img/2024-06-20-LLMABCsBuildingLLM-PoweredApplicationsAGatewaytoAIsFuture_0.png","tag":["Tech"],"readingTime":11},{"title":"전문가를 위한 고급 Python 20 단계","description":"","date":"2024-06-20 01:57","slug":"2024-06-20-AdvancedPythonforExperts20Steps","content":"\n\n\n![Image](/assets/img/2024-06-20-AdvancedPythonforExperts20Steps_0.png)\n\nYou will find the links to 20 tutorials on this story.\n\n- Links are inserted after the articles are published on Medium.\n- 1 or 2 articles are published every week.\n- Links are updated weekly.\n- The links are Friend Links, so you can read without being a Medium member.\n\n## Tutorials\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 파이썬의 고급 메모리 관리 및 최적화 기법 탐색\n2. 데이터 과학에서 파이썬의 파워 활용: 고급 라이브러리\n3. 효율적인 문제 해결을 위한 고급 파이썬 디버깅 기술\n4. 파이썬에서의 멀티스레딩과 멀티프로세싱: 심층 분석\n5. 안전한 파이썬 애플리케이션 구축: 최상의 실천 방법과 기술\n6. 파이썬에서의 고급 네트워크 프로그래밍: 기술과 프로토콜\n7. 머신 러닝을 위한 파이썬 활용: 최적화 및 스케일링\n8. 파이썬으로 하는 딥러닝: 고급 아키텍처 및 구현\n9. 파이썬에서의 고급 데이터 시각화: 기술과 라이브러리\n10. 파이썬 및 IoT: 고급 사물인터넷 어플리케이션 개발\n11. 금융 분석을 위한 파이썬: 고급 기술과 도구\n12. 대규모 응용 프로그램을 위한 파이썬 코드 최적화\n13. 웹 스크레이핑 및 데이터 마이닝을 위한 고급 파이썬 기술\n14. 고급 지리 공간 데이터 분석을 위한 파이썬 활용\n15. 파이썬의 고급 객체 지향 프로그래밍: 패턴과 관행\n16. 파이썬에서의 병행성: 고급 패턴과 기술\n17. 고급 파이썬 API: 설계, 개발 및 배포\n18. 파이썬과 블록체인: 고급 암호화 솔루션 기법\n19. 파이썬을 활용한 고급 통계 분석: 기술과 도구\n20. 양자 컴퓨팅에서의 파이썬: 고급 양자 알고리즘 개발\n\n다음은 다른 튜토리얼 시리즈입니다:\n\n코드 RP5JT1RL08로 파이썬, ML, DL 및 LLM E-book 50% 할인\n\n무료로 구독하여 42페이지 이북을 받아보세요: 데이터 과학 | 포괄적 핸드북\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무료 자습서와 정신 건강 스타트업을 지원해주세요.","ogImage":{"url":"/assets/img/2024-06-20-AdvancedPythonforExperts20Steps_0.png"},"coverImage":"/assets/img/2024-06-20-AdvancedPythonforExperts20Steps_0.png","tag":["Tech"],"readingTime":2},{"title":"파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내","description":"","date":"2024-06-20 01:54","slug":"2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide","content":"\n\n\n![image](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png)\n\n# 소개:\n\n최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.\n\n# 몰리딕 아키텍처란? \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.\n\n![단일체 아키텍처 다이어그램](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png)\n\n# 마이크로서비스 아키텍처란?\n\n반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_2.png\" /\u003e\n\n# Monolithic vs. Microservice의 차이\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_3.png\" /\u003e\n\n# RabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:\n\n- Decoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.\n- Load Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.\n- Fault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.\n- Scalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.\n- Message Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.\n- Message Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.\n- 전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.\n\n# 마이크로서비스 응용프로그램 코딩\n\n# 1. 프로젝트 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:\n\n- Gateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.\n- ML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.\n- Auth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.\n- Notification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.\n\n## 2. 준비 사항\n\n시작하기 전에 다음 사항을 확인해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시스템에 Docker가 설치되어 있습니다.\n- 시스템에 Python이 설치되어 있습니다.\n- Docker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.\n\n# 3. 요구 사항 설정\n\n## Docker를 사용하여 PostgreSQL 설치\n\nPostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n도커를 사용하여 RabbitMQ를 설치하기 위해서는 다음 명령어를 실행하세요:\n\n도커를 실행하여 RabbitMQ를 설치하려면 다음 명령어를 실행하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 프로젝트 설정하기\n\n## A. 프로젝트 폴더 설정하기\n\nmicroservices-demo/\n│\n├── gateway/\n│ ├── rpc_client.py\n│ ├── .env \n│ ├── requirements.txt\n│ └── main.py\n│\n├── ml_services/\n│ ├── requirements.txt\n│ ├── artifacts/\n│ ├── .env\n│ └── main.py\n│\n├── notification_service/\n│ ├── email_service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n├── auth/\n│ ├── database.py\n│ ├── models.py\n│ ├── schemas.py\n│ ├── service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n└── README.md\n\n## B. 게이트웨이 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.py 파일을 만들어 아래 코드를 추가해주세요:\n\nfrom fastapi import FastAPI, HTTPException, File, UploadFile\nimport fastapi as _fastapi\nfrom fastapi.security import OAuth2PasswordBearer\nfrom dotenv import load_dotenv\nfrom jwt.exceptions import DecodeError\nfrom pydantic import BaseModel\nimport requests\nimport base64\nimport pika\nimport logging\nimport os\nimport jwt\nimport rpc_client\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# 환경 변수 로드\nload_dotenv()\nlogging.basicConfig(level=logging.INFO)\n\n# 환경 변수 가져오기\nJWT_SECRET = os.environ.get(\"JWT_SECRET\")\nAUTH_BASE_URL = os.environ.get(\"AUTH_BASE_URL\")\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\nchannel = connection.channel()\nchannel.queue_declare(queue='gatewayservice')\nchannel.queue_declare(queue='ocr_service')\n\n# JWT 토큰 유효성 검사\nasync def jwt_validation(token: str = _fastapi.Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        return payload\n    except DecodeError:\n        raise HTTPException(status_code=401, detail=\"Invalid JWT token\")\n\n# 요청 바디를 위한 Pydantic 모델\nclass GenerateUserToken(BaseModel):\n    username: str\n    password: str\n\nclass UserCredentials(BaseModel):\n    username: str\n    password: str\n\nclass UserRegisteration(BaseModel):\n    name: str\n    email: str\n    password: str\n\nclass GenerateOtp(BaseModel):\n    email: str\n\nclass VerifyOtp(BaseModel):\n    email: str\n    otp: int\n\n# 인증 라우트\n@app.post(\"/auth/login\", tags=['Authentication Service'])\nasync def login(user_data: UserCredentials):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/token\", json={\"username\": user_data.username, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/register\", tags=['Authentication Service'])\nasync def registeration(user_data: UserRegisteration):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users\", json={\"name\": user_data.name, \"email\": user_data.email, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/generate_otp\", tags=['Authentication Service'])\nasync def generate_otp(user_data: GenerateOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/generate_otp\", json={\"email\": user_data.email})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/verify_otp\", tags=['Authentication Service'])\nasync def verify_otp(user_data: VerifyOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/verify_otp\", json={\"email\": user_data.email, \"otp\": user_data.otp})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n# 확장 서비스 OCR 라우트\n@app.post('/ocr', tags=['Machine learning Service'])\ndef ocr(file: UploadFile = File(...), payload: dict = _fastapi.Depends(jwt_validation)):\n    # 파일을 임시 위치에 저장\n    with open(file.filename, \"wb\") as buffer:\n        buffer.write(file.file.read())\n\n    ocr_rpc = rpc_client.OcrRpcClient()\n\n    with open(file.filename, \"rb\") as buffer:\n        file_data = buffer.read()\n        file_base64 = base64.b64encode(file_data).decode()\n\n    request_json = {\n        'user_name': payload['name'],\n        'user_email': payload['email'],\n        'user_id': payload['id'],\n        'file': file_base64\n    }\n\n    # OCR 마이크로서비스에 요청 JSON을 사용하여 호출\n    response = ocr_rpc.call(request_json)\n\n    # 임시 이미지 파일 삭제\n    os.remove(file.filename)\n    return response\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5001, reload=True)\n\n게이트웨이 환경을 설정하려면 gateway 폴더에 .env 파일을 만드세요.\n\nAUTH_BASE_URL=http://0.0.0.0:5000\nJWT_SECRET=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496\nRABBITMQ_URL=localhost\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 마이크로서비스와 통신하기 위해 RabbitMQ를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. RabbitMQ 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.py 파일을 생성할 것입니다.\n\nimport pika\nimport uuid\nimport json\nfrom dotenv import load_dotenv\nimport os\n\n# 환경 변수 로딩\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\nclass OcrRpcClient(object):\n\n    def __init__(self):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=RABBITMQ_URL))\n\n        self.channel = self.connection.channel()\n\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        self.callback_queue = result.method.queue\n\n        self.channel.basic_consume(\n            queue=self.callback_queue,\n            on_message_callback=self.on_response,\n            auto_ack=True)\n\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body\n\n    def call(self, message):\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n        self.channel.basic_publish(\n            exchange='',\n            routing_key='ocr_service',\n            properties=pika.BasicProperties(\n                reply_to=self.callback_queue,\n                correlation_id=self.corr_id,\n            ),\n            body=json.dumps(message))\n        while self.response is None:\n            self.connection.process_data_events()\n        response_json = json.loads(self.response)\n        return response_json\n\n이 코드는 RabbitMQ를 사용하여 OCR 마이크로서비스(ML 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 OcrRpcClient를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.\n\n- 초기화(__init__):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRabbitMQ에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.\n\n2. 요청 보내기 (호출):\n\nOCR 마이크로서비스(ML 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.\n\n이 클래스는 RabbitMQ를 사용하여 게이트웨이 서비스가 OCR 마이크로서비스와 효율적으로 통신할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## C. Auth 마이크로서비스 구현\n\n이 코드는 FastAPI를 사용하여 사용자 등록, 로그인, JWT 토큰 생성, OTP를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 SQLAlchemy를 사용하고 OTP 이메일을 보내기 위해 RabbitMQ를 사용합니다. 이 서비스에는 사용자 생성, JWT 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 OTP 확인에 대한 엔드포인트가 포함되어 있습니다.\n\nfrom typing import List\nfrom fastapi import HTTPException \nimport fastapi as _fastapi\nimport schemas as _schemas\nimport sqlalchemy.orm as _orm\nimport models as _models\nimport service as _services\nimport logging\nimport database as _database\nimport pika\n\n# rabbitmq connection\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=\"localhost\"))\nchannel = connection.channel()\nchannel.queue_declare(queue='email_notification')\n\ndef get_db():\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = _fastapi.FastAPI()\nlogging.basicConfig(level=logging.INFO)\n_models.Base.metadata.create_all(_models.engine)\n\n@app.post(\"/api/users\", tags=['사용자 인증'])\nasync def create_user(\n    user: _schemas.UserCreate, \n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    db_user = await _services.get_user_by_email(email=user.email, db=db)\n\n    if db_user:\n        logging.info('해당 이메일로 이미 가입된 사용자가 있습니다')\n        raise _fastapi.HTTPException(\n            status_code=200,\n            detail=\"해당 이메일로 이미 가입된 사용자가 있습니다\")\n\n    user = await _services.create_user(user=user, db=db)\n\n    return _fastapi.HTTPException(\n            status_code=201,\n            detail=\"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!\")\n\n# API 상태 확인 엔드포인트\n@app.get(\"/check_api\")\nasync def check_api():\n    return {\"status\": \"API와 연결되었습니다\"}\n\n@app.post(\"/api/token\", tags=['사용자 인증'])\nasync def generate_token(\n    user_data: _schemas.GenerateUserToken,\n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.authenticate_user(email=user_data.username, password=user_data.password, db=db)\n\n    if user == \"is_verified_false\":\n        logging.info('이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.')\n        raise _fastapi.HTTPException(\n            status_code=403, detail=\"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.\")\n\n    if not user:\n        logging.info('잘못된 자격 증명')\n        raise _fastapi.HTTPException(\n            status_code=401, detail=\"잘못된 자격 증명\")\n\n    logging.info('JWT 토큰이 생성되었습니다.')\n    return await _services.create_token(user=user)\n\n@app.get(\"/api/users/me\", response_model=_schemas.User, tags=['사용자 인증'])\nasync def get_user(user: _schemas.User = _fastapi.Depends(_services.get_current_user)):\n    return user\n\n@app.get(\"/api/users/profile\", tags=['사용자 인증'])\nasync def get_user(email: str, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    return db.query(_models.User and _models.Address).filter_by(id=1).first()\n\n@app.post(\"/api/users/generate_otp\", response_model=str, tags=[\"사용자 인증\"])\nasync def send_otp_mail(userdata: _schemas.GenerateOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db)\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if user.is_verified:\n        raise _fastapi.HTTPException(status_code=400, detail=\"이미 확인된 사용자입니다\")\n\n    # OTP 생성 및 전송\n    otp = _services.generate_otp()\n    print(otp)\n    _services.send_otp(userdata.email, otp, channel)\n\n    # OTP를 데이터베이스에 저장\n    user.otp = otp\n    db.add(user)\n    db.commit()\n\n    return \"이메일로 OTP가 전송되었습니다\"\n\n@app.post(\"/api/users/verify_otp\", tags=[\"사용자 인증\"])\nasync def verify_otp(userdata: _schemas.VerifyOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db )\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if not user.otp or user.otp != userdata.otp:\n        raise _fastapi.HTTPException(status_code=400, detail=\"잘못된 OTP\")\n\n    # 사용자의 is_verified 필드 업데이트\n    user.is_verified = True\n    user.otp = None  # OTP 초기화\n    db.add(user)\n    db.commit()\n\n    return \"이메일 확인이 성공적으로 완료되었습니다\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5000, reload=True)\n\n이 코드는 PostgreSQL 데이터베이스에 연결하기 위해 SQLAlchemy 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. DATABASE_URL은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 SessionLocal을 정의합니다. ORM 모델을 정의하는 Declarative Base로 사용하기 위해 Base 변수가 초기화됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nimport sqlalchemy as _sql\nimport sqlalchemy.ext.declarative as _declarative\nimport sqlalchemy.orm as _orm\nfrom dotenv import load_dotenv\nimport os\n\n# .env 파일에서 환경 변수를 불러옵니다\nload_dotenv()\n\n# 환경 변수를 가져옵니다\npostgres_host = os.environ.get(\"POSTGRES_HOST\")\npostgres_db = os.environ.get(\"POSTGRES_DB\")\npostgres_user = os.environ.get(\"POSTGRES_USER\")\npostgres_password = os.environ.get(\"POSTGRES_PASSWORD\")\n\n# PostgreSQL 서버가 로컬에서 실행 중이라고 가정하고 'mydatabase'라는 이름의 데이터베이스가 있다고 가정합니다\nDATABASE_URL = f\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}\"\n\nengine = _sql.create_engine(DATABASE_URL)\nSessionLocal = _orm.sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = _declarative.declarative_base()\r\n\n이 코드는 사용자 및 주소 테이블에 대한 SQLAlchemy 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.\n\nimport datetime as _dt\nimport sqlalchemy as _sql\nimport sqlalchemy.orm as _orm\nimport passlib.hash as _hash\nfrom database import Base, engine\nimport database as _database\n\nBase.metadata.create_all(engine)\n\nclass User(_database.Base):\n    __tablename__ = \"users\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    name = _sql.Column(_sql.String)\n    email = _sql.Column(_sql.String, unique=True, index=True)\n    is_verified = _sql.Column(_sql.Boolean, default=False)\n    otp = _sql.Column(_sql.Integer)\n    hashed_password = _sql.Column(_sql.String)\n    addresses = _orm.relationship(\"Address\", back_populates=\"user\")\n    date_created = _sql.Column(_sql.DateTime, default=_dt.datetime.utcnow)\n\n    def verify_password(self, password: str):\n        return _hash.bcrypt.verify(password, self.hashed_password)\n\nclass Address(_database.Base):\n    __tablename__ = \"addresses\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    street = _sql.Column(_sql.String)\n    landmark = _sql.Column(_sql.String)\n    city = _sql.Column(_sql.String)\n    country = _sql.Column(_sql.String)\n    pincode = _sql.Column(_sql.String)\n    user_id = _sql.Column(_sql.Integer, _sql.ForeignKey(\"users.id\"))\n    user = _orm.relationship(\"User\", back_populates=\"addresses\")\n    latitude = _sql.Column(_sql.Float)\n    longitude = _sql.Column(_sql.Float)\r\n\n이 코드는 사용자 관련 데이터 구조에 대한 Pydantic 모델을 정의하며, 사용자 생성, 인증 및 OTP 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 사용자 인증 및 OTP(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. HTTP 요청을 처리하기 위해 FastAPI를 사용하며, 데이터베이스 작업을 위해 SQLAlchemy를 사용하고 데이터 유효성 검사 및 직렬화를 위해 Pydantic을 사용하며, 인증을 위해 JWT를 사용하고, 이메일 알림을 보내기 위해 RabbitMQ를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, JWT 토큰 생성, JWT 토큰에서 현재 사용자 가져오기, 무작위 OTP 생성, RabbitMQ에 연결 및 OTP 이메일 알림 전송 등이 포함됩니다.\n\n환경 변수 로드\n\nJWT_SECRET = os.getenv(\"JWT_SECRET\")\nRABBITMQ_URL = os.getenv(\"RABBITMQ_URL\")\noauth2schema = _security.OAuth2PasswordBearer(\"/api/token\")\n\n데이터베이스 생성\n\ndef create_database():\n    # 데이터베이스 테이블 생성\n    return _database.Base.metadata.create_all(bind=_database.engine)\n\n데이터베이스 세션 가져오기\n\ndef get_db():\n    # 데이터베이스 세션을 얻는 의존성\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n이메일별 사용자 가져오기\n\nasync def get_user_by_email(email: str, db: _orm.Session):\n    # 데이터베이스에서 이메일별로 사용자 검색\n    return db.query(_models.User).filter(_models.User.email == email and _models.User.is_verified == True).first()\n\n새 사용자 생성\n\nasync def create_user(user: _schemas.UserCreate, db: _orm.Session):\n    # 데이터베이스에 새 사용자 생성\n    try:\n        valid = _email_check.validate_email(user.email)\n        name = user.name\n        email = valid.email\n    except _email_check.EmailNotValidError:\n        raise _fastapi.HTTPException(status_code=404, detail=\"정확한 이메일을 입력하세요\")\n\n    user_obj = _models.User(email=email, name=name, hashed_password=_hash.bcrypt.hash(user.password))\n    db.add(user_obj)\n    db.commit()\n    db.refresh(user_obj)\n    return user_obj\n\n사용자 인증\n\nasync def authenticate_user(email: str, password: str, db: _orm.Session):\n    # 사용자 인증\n    user = await get_user_by_email(email=email, db=db)\n\n    if not user:\n        return False\n    \n    if not user.is_verified:\n        return 'is_verified_false'\n    \n    if not user.verify_password(password):\n        return False\n\n    return user\n\nJWT 토큰 생성\n\nasync def create_token(user: _models.User):\n    # 인증을 위한 JWT 토큰 생성\n    user_obj = _schemas.User.from_orm(user)\n    user_dict = user_obj.model_dump()\n    del user_dict[\"date_created\"]\n    token = jwt.encode(user_dict, JWT_SECRET, algorithm=\"HS256\")\n    return dict(access_token=token, token_type=\"bearer\")\n\n현재 사용자 가져오기\n\nasync def get_current_user(db: _orm.Session = _fastapi.Depends(get_db), token: str = _fastapi.Depends(oauth2schema)):\n    # JWT 토큰에서 현재 인증된 사용자 가져오기\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        user = db.query(_models.User).get(payload[\"id\"])\n    except:\n        raise _fastapi.HTTPException(status_code=401, detail=\"유효하지 않은 이메일 또는 비밀번호\")\n    return _schemas.User.from_orm(user)\n\n랜덤 OTP 생성\n\ndef generate_otp():\n    # 랜덤 OTP 생성\n    return str(random.randint(100000, 999999))\n\nRabbitMQ에 연결\n\ndef connect_to_rabbitmq():\n    # RabbitMQ에 연결\n    while True:\n        try:\n            connection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\n            return connection\n        except pika.exceptions.AMQPConnectionError:\n            print(\"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중...\")\n            time.sleep(5)\n\nOTP 이메일 알림 전송\n\ndef send_otp(email, otp, channel):\n    # RabbitMQ를 사용하여 OTP 이메일 알림 전송\n    connection = connect_to_rabbitmq()\n    channel = connection.channel()\n    message = {'email': email,\n               'subject': '계정 확인 OTP 알림',\n               'other': 'null',\n               'body': f'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \\n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \\n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\\n 감사합니다 '\n               }\n\n    try:\n        queue_declare_ok = channel.queue_declare(queue='email_notification', passive=True)\n        current_durable = queue_declare_ok.method.queue\n\n        if current_durable:\n            if queue_declare_ok.method.queue != current_durable:\n                channel.queue_delete(queue='email_notification')\n                channel.queue_declare(queue='email_notification', durable=True)\n        else:\n            channel.queue_declare(queue='email_notification', durable=True)\n\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OTP 이메일 알림 전송 완료\")\n    except Exception as err:\n        print(f\"메시지 전송 실패: {err}\")\n    finally:\n        channel.close()\n        connection.close()\n\n## D. 머신 러닝 마이크로서비스 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 Python 스크립트는 RabbitMQ 서버에 연결하여 'ocr_service'라는 큐에서 메시지를 소비합니다. 메시지를받으면 OCRService 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 RabbitMQ에 메시지 전달을 인식합니다. 스크립트는 RabbitMQ가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count 1을 사용합니다.\n\nimport pika\nimport json\nfrom utils import OCRService\nfrom utils import send_email_notification\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='ocr_service')\n\n# OCR 요청을 처리하기 위한 콜백 함수\ndef on_request(ch, method, props, body):\n    # OCR 서비스 초기화\n    ocr_service = OCRService()\n    # OCR 요청 처리\n    response = ocr_service.process_request(body)\n\n    # 이메일 알림 전송\n    send_email_notification(response['user_email'], response['ocr_text'], channel)\n\n    # 응답을 응답 큐에 발행\n    ch.basic_publish(exchange='',\n                     routing_key=props.reply_to,\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=json.dumps(response))\n    # 메시지 전달을 인식\n    ch.basic_ack(delivery_tag=method.delivery_tag)\n# prefetch count를 1로 설정\nchannel.basic_qos(prefetch_count=1)\n# 'ocr_service' 큐에서 메시지 수신\nchannel.basic_consume(queue='ocr_service', on_message_callback=on_request)\n# 메시지 수신 시작\nprint(\" [x] RPC 요청 대기중\")\nchannel.start_consuming()\r\n\nimport json\nimport base64\nimport pandas as pd\n#keras ocr pipeline and imports\nimport keras_ocr\nimport pika\n\nclass OCRService:\n   \n    def __init__(self):\n        self.keras_pipeline = keras_ocr.pipeline.Pipeline()\n\n    def keras_ocr(self, image_path):\n        results = self.keras_pipeline.recognize([image_path])\n        df = pd.DataFrame(results[0], columns=['text', 'bbox'])\n        words = df['text'].tolist()\n        sentence = ' '.join(words)\n        return sentence\n\n    def process_request(self, message):\n        message_body = json.loads(message)\n        user_name = message_body['user_name']\n        user_email = message_body['user_email']\n        user_id = message_body['user_id']\n        file_base64 = message_body['file']\n        print(f\" [x]user_id: {user_id} request recieved from gateway..\")\n        print(f\" [x]processing request for {user_name}\")\n\n        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정\n        file_data = base64.b64decode(file_base64.encode())\n        # 디코드된 파일 데이터를 새 파일에 작성\n        with open('artifacts/decoded_file.png', 'wb') as f:\n            f.write(file_data)\n\n        image_path = \"artifacts/decoded_file.png\"\n        ocr_text = self.keras_ocr(image_path)\n        print(\" [^] OCR 처리 완료 !!!\")\n\n        response = {\n            \"user_id\": user_id,\n            \"user_name\": user_name,\n            \"user_email\": user_email,\n            \"ocr_text\": ocr_text\n        }\n\n        return response\n\ndef send_email_notification(email, ocr_text, channel):\n    # RabbitMQ를 사용하여 이메일 알림 전송\n    message = {\n        'email': email,\n        'subject':'OCR 처리 완료 !!',\n        'body':f'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\\n\\n  OCR 텍스트 : {ocr_text}',\n        'other': 'null',\n       }\n\n    try:\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OCR 처리 완료 이메일 알림 전송됨\")\n    except Exception as err:\n        print(f\"메시지 게시 실패: {err}\")\r\n\n## D. 알림 마이크로서비스 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 스크립트는 \"email_notification\" 큐에서 메시지를 수신하는 RabbitMQ 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.\n\nimport pika\nimport sys\nimport os\nimport time\nimport email_service\nfrom dotenv import load_dotenv\n\n# 환경 변수 로드\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\ndef main():\n    # rabbitmq 연결\n    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_URL))\n    channel = connection.channel()\n\n    def callback(ch, method, properties, body):\n        try:\n            err = email_service.notification(body)\n            if err:\n                ch.basic_nack(delivery_tag=method.delivery_tag)\n            else:\n                ch.basic_ack(delivery_tag=method.delivery_tag)\n        except Exception as e:\n            print(f\"메시지 처리 중 오류 발생: {e}\")\n            ch.basic_nack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(\n        queue=\"email_notification\", on_message_callback=callback\n    )\n\n    print(\"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요\")\n\n    channel.start_consuming()\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(\"중단됨\")\n        try:\n            sys.exit(0)\n        except SystemExit:\n            os._exit(0)\n\nimport smtplib, os, json\nfrom email.message import EmailMessage\nfrom dotenv import load_dotenv\nfrom email.mime.text import MIMEText\n\nload_dotenv()\n\ndef notification(message):\n    try:\n        message = json.loads(message)\n        receiver_address = message[\"email\"]\n        subject = message[\"subject\"]\n        body = message[\"body\"]\n        other = message[\"other\"]\n\n        sender_address = os.environ.get(\"GMAIL_ADDRESS\")\n        sender_password = os.environ.get(\"GMAIL_PASSWORD\")\n\n        # Gmail SMTP 서버 설정\n        smtp_server = 'smtp.gmail.com'\n        smtp_port = 587\n\n        server = smtplib.SMTP(smtp_server, smtp_port)\n        server.starttls()\n        server.login(sender_address, sender_password)\n\n        # 이메일 메시지 작성\n        msg = MIMEText(body)\n        msg['Subject'] = subject\n        msg['From'] = sender_address\n        msg['To'] = receiver_address\n\n        server.sendmail(sender_address, receiver_address, msg.as_string())\n        server.quit()\n\n        print(\"이메일 발송 완료\")\n    except Exception as e:\n        print(f\"이메일 발송 실패: {e}\")\n\n# 애플리케이션 데모\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n마지막으로, FastAPI와 RabbitMQ를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, OCR 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.\n\n이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.\n\n프로젝트를 실행하려면 GitHub 저장소의 README 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃허브: [https://github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)","ogImage":{"url":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":29},{"title":"파이썬을 활용한 비즈니스 계획 - 재고 및 현금 흐름 관리","description":"","date":"2024-06-20 01:50","slug":"2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement","content":"\n\n## 데이터 분석을 활용하여 소기업이 재고를 관리하고 유동성 요구를 예측하며 수익을 극대화하는 방법은 무엇인가요?\n\n![Business Planning with Python: Inventory and Cash Flow Management](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_0.png)\n\n현금 흐름 관리란 현금 수거액에서 현금 비용을 뺀 순액을 모니터링하고 최적화하는 프로세스로 정의될 수 있습니다.\n\n중소기업을 경영하는 친구와 대화한 후, 성장에 있어 현금이 가장 큰 병목 현상일 수 있다는 것을 알게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공급망 데이터 과학자로서, 나는 이 문제를 공급망, 재고 관리 및 유통 계획에 빠르게 연결했습니다.\n\n이 기사에서는 이 문제의 간단한 모델링을 구축하는 데 사용된 접근 방식과 도구를 공유하겠습니다.\n\n![Business Planning with Python Inventory and Cash Flow Management](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_1.png)\n\n우리는 제 친구의 소규모 사업을 예로 들 것입니다. 그들은 재생 가능한 재료로 만든 컵을 커피숍과 유통업체에 판매합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n💌 무료로 새로운 기사를 이메일로 받아보세요: 뉴스레터\n📘 공급망 분석에 대한 완벽한 가이드: 분석 요약 시트\n\n```js\n요약\n\nI. 문제 상황: 비즈니스 계획\n재생 에코 컵을 판매하는 회사를 돕기 위해 비즈니스 분석을 어떻게 사용할 수 있을까요?\n  1. 재고 관리 시뮬레이션\n고객 수요를 충족시키기 위한 재고 관리 규칙을 실행합니다.\n  2. 재무 분석: 비용 및 수익\n비용 및 수익을 포괄하는 모든 재무 흐름을 연도별로 매핑합니다.\n  3. 현금 흐름 시뮬레이션\n비즈니스를 운영하기 위해 매주 가지고 있을 현금은 얼마나 될까요?\nII. 비즈니스 계획 최적화\n유동성 및 수익성 문제를 해결하기 위해 무엇을 할 수 있을까요?\n  1. 시나리오 1: 주문 수량 최적화\n주문 수량을 8주에서 6주로 줄인다면 어떻게 될까요?\n  2. 시나리오 2: 인바운드 물류용 항공화물\n항공화물을 사용해 재생 재고의 리드타임을 단축한다면 어떨까요?\n  3. 시나리오 3: 판매 채널 최적화\n대리점에 판매함으로써 영업 대표를 뛰어넘을 수 있다면 어떨까요?\n  4. 최적 시나리오\n두 가지 최상의 옵션을 결합해 봅시다.\nIII. 결론\n진보된 분석 솔루션을 통해 지속가능성과 수익성을 향상시키세요\n```\n\n# 문제 상황: 비즈니스 계획\n\n이 부분은 내 친구의 비즈니스 모델을 이해하기 위해 수집한 요소들을 간단히 소개합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 포인트들이 포함되어 있습니다:\n\n- 재고 관리: 제품 주문, 수령, 보관 및 배송\n❓ 고객 수요를 충족시키려면 언제 주문해야 할까요?\n- 재무: 비용 및 수익 흐름\n💡 주간 손익 분석.\n- 상업: 판매 채널, 서비스 수준 협약 및 수수료\n❔ XXX에 판매하면 얼마의 이익을 올릴까요?\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_2.png)\n\n우리는 이러한 요소를 모델링하여 서로 어떻게 상호 작용하고 전체 가치 사슬을 최적화할 수 있는지 이해할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 재고 관리 시뮬레이션\n\n먼저, 우리는 고객의 요구를 가장 낮은 비용으로 충족시키기 위해 모델의 핵심에 재고 관리 규칙을 구현할 것입니다.\n\n![image](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_3.png)\n\n재고 관리 규칙은 기계 속의 한 부분입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 재고는 상업 성장을 막을 수 있어요.\n손에 없는 아이템은 발송할 수 없어요.\n- 충전 능력은 재무 상황으로 제한됩니다.\n주문 지불을 위해 손에 있는 현금이 필요해요.\n- 전략적 결정은 재고 관리 방식에 영향을 미칩니다.\n예를 들어, 화물(항공, 해상) 소요 시간이 재고의 안정성에 영향을 줍니다.\n\n이 모듈은 고객 수요, 자기 시간, 그리고 안전 재고 매개변수에 기반하여\n보충 주문을 생성합니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_4.png)\n\n이 연습에서는 2023년의 역사적 판매 데이터를 사용하여\n최적의 재고 관리가 무엇이었을 지 모사했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 이 요청에 대한 답변으로 지속적 검토 정책인 (s, Q)을 소개해보려고 해요.\n\n- 지속적 검토는 재고 팀이 매일 재고 수준을 확인하는 것을 의미해요.\n- (s, Q)는 만약 재고 수준이 특정 수준 s(Pallets) 아래로 내려가면, Q(Pallets)를 주문해야 한다는 것이에요.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_5.png)\n\n재주문 지점은 발주가 도착할 때까지 고객 요구를 충족하기 위해 필요한 재고 수준을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_6.png)\n\n재고 보충 소요시간, 목표 주기 서비스 레벨 및 고객 수요의 표준 편차를 사용하여 정의합니다.\n\n결과는 아래 차트와 같습니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_7.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n📈 전설\n\n- 파란색 산점도는 최적 주문 정책을 나타냅니다.\n- 녹색 플롯은 창고에 보관된 파레트 수인 재고 현황(ioh)을 의미합니다.\n- 세 번째 차트의 점선은 재주문 점 s를 나타냅니다.\n\n재고 현황이 점선을 넘어갈 때 보충 주문이 있는 것을 관찰할 수 있습니다.\n\n💡 관찰 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 정책이 최적인지 확실하지 않아요.\n우리는 내 친구의 표준 운영 모델을 알고리즘으로 번역할 뿐이에요.\n- 주문 수량과 보충 리드 타임을 최소화하기 위해 조정할 수 있다는 것을 염두에 두세요.\n\n재주문 시기를 알게 되었으니, 현금 보유액을 시각화하기 위해 재무 흐름을 포함할 수 있어요.\n\n## 재무 분석: 비용 및 수익\n\n이전 섹션은 재무 흐름을 고려하지 않고 물류 관점에서 비즈니스를 설명해 왔어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 내 친구의 주요 문제는 재고를 보충하기 위해 주문 가능한 유동성이 제한된 것입니다.\n\n![Business Planning with Python Inventory and Cash Flow Management](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_8.png)\n\n그래서 우리는 재무 흐름을 매핑하여 매주 보유 현금을 계산할 것입니다.\n\n수익\n역사적 판매액은 판매 채널 별로 분할됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 배급업체는 출하 후 4 주 후 지급합니다.\n각 판매 후 4 주 후, 송장 금액 (단가 x 수량)이 입금됩니다.\n- 커피숍은 주문 시 지불합니다.\n매주 끝날 때 마다, 송장 금액 (단가 x 수량)이 입금됩니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_9.png)\n\n💡 관찰 사항\n직전 연도의 판매 수치를 고려하지 않으므로, 배급 채널이 처음 4 주 동안 수익을 얻지 못하는 것은 정상입니다.\n\n고정 및 가변 비용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 조달 및 인바운드 물류 비용\n공급업체 및 화물 운송업자는 공장에서 선적이 이뤄지면 지불되어야 합니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_10.png)\n\n💡 관찰\n주문은 생성된 후 일주일 후에 선적 준비가 됩니다.\n\n- 보관 및 구조 비용\n이에는 팔레트 보관(팔레트당 단위 가격 사용) 및 인력 비용, 설비 비용 등과 같은 반복 비용이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_11.png)\n\n💡 관찰\n내 친구는 창고에 팔렛을 보관하는 데 최소 요금을 지불할 필요가 없었다고 운이 좋았어요.\n\n- 비반복 비용\n이 비용은 일시불로 지불되며, 마케팅 자료 구매, 특별 직원 보너스 또는 유통업체 벌금을 포함할 수 있습니다.\n- 수수료 비용\n내 친구는 커피숍에 대한 판매 시 독립적인 영업 대행사와 함께 일하며, 이들은 매출의 30%의 수수료를 받습니다.\n\n![](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_12.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 요약하자면, 다음과 같습니다:\n\n- 수익 흐름에는 두 채널에서의 매출이 포함됩니다.\n총 매출 = (유통업체 매출 + 커피 샵 매출)\n- 총 비용에는 고정비용, 가변비용 및 비반복 비용이 모두 포함됩니다.\n총 비용 = (가변 비용 + 고정 비용 + 비반복 비용)\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_13.png)\n\n💡 관찰 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 우리는 구조 비용이 매우 낮습니다. 고정 비용의 10% 미만입니다.\n- 수수료는 두 번째로 큰 비용 항목을 차지합니다.\n\n## 현금 흐름 시뮬레이션\n\n주간 현금 흐름을 계산하면 연말까지 이 활동을 유지하기 위해 얼마나 많은 현금이 필요한지 이해할 수 있습니다.\n\n- 현금 흐름 = 매출액 — 비용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_14.png)\n\n💡 관찰 사항\n\n- 현금 흐름은 공급 업체 및 화물 수송업자에게 지불할 때를 제외하고 항상 양수입니다.\n\n만약 우리가 현금이 없는 상태에서 연도를 시작한다고 가정해보자 (나쁜 아이디어),\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경된 내용입니다.\n\n![Business Planning with Python](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_15.png)\n\n- 현금 최소 잔고는 -124,733 달러입니다.\n- 현금 잔고가 3주차와 4주차에 음수입니다.\n\n💡 결론\n\n활동을 원활하게 운영하고 제 시간에 공급 업체에 지불하려면 적어도 연초에 125,000 달러 이상이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 섹션에서는 여러 성과 지표를 정의하고 시나리오를 시뮬레이션하여 데이터 기반 비즈니스 통찰력을 제공할 것입니다.\n\n# 비즈니스 기획 최적화\n\n모델이 마련되었으므로 매개변수를 조절하고 다양한 시나리오를 시뮬레이션할 수 있습니다.\n\n각 시나리오는 네 가지 지표를 사용하여 평가될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_16.png\" /\u003e\n\n- Initial cash on hand needed at the beginning of the year: coh_0 ($)\nInitial Scenario: coh_0 = 124,733 ($)\n- Average cost of goods sold (COGS): cogs ($/Pallet)\nInitial Scenario: cogs = 5,057 ($/Pallet)\n- Average logistics costs per pallet: log_cost ($/Pallet)\nInitial Scenario: log_cost= 417 ($/Pallet)\n- Average profitability per pallet: avg_profit ($/Year)\nInitial Scenario: avg_profit = 3,686 ($/Year)\n\nThe idea is to measure the business and operational performance along the value chain versus the initial scenario.\n\n## Scenario 1: Order Quantity Optimization\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공급망 엔지니어로서, 나는 물류 흐름과 재고 관리 규칙을 조사해보겠어요.\n\n친구가 유동성 문제를 설명할 때, 내 첫 반응은 주문 수량에 대해 의심해 보는 것이었어요.\n\n평균 8주 분량을 주문하는 것은 그가 재고 부족에 대해 걱정하지 않고 출고 취소(즉, 재고 부족으로 인한 주문 취소)를 피하기 위한 방법이에요.\n\n이제 우리가 안전 재고를 갖춘 최적의 재고 관리 규칙을 갖고 있으니, 주문 수량을 Q = 6주 용량으로 줄일 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![BusinessPlanningwithPythonInventoryandCashFlowManagement](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_17.png)\n\n예상 재고 손실을 방지하여 수익에 미치는 영향이 무시할 수 없습니다.\n\n- 연습 시작 시 손에 현금이 더 적게 필요합니다.\n시나리오 1: coh_0 = 74,733($) | -41%\n- 매출원가(COGS)가 크게 감소합니다.\n시나리오 1: cogs = 4,928($/파렛) | -2.6%\n- 각각의 판매 팔렛당 더 나은 이익을 창출합니다.\n시나리오 1: avg_profit = 3,815($/팔렛) | +3%\n\n💡 결론\n이 빠른 승리는 유동성 요구 사항에 대한 여유를 제공하고 추가 수익을 가져다줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 피드백으로 인해 이 비즈니스 가치 사슬의 전략적 비전에 대해 심층적으로 고찰하게 되었습니다.\n\n- 🙋‍♂️ 왜 인바운드 물류를 항공 운송으로 전환하지 않을까요?\n항공 운송은 매우 비싸지만 더 많은 유연성을 제공합니다. 즉, 평균 재고가 낮아집니다.\n- 🙋‍♀️ 유통 업체에만 판매해야 할까요?\n유통업체의 지불 조건은 더 길지만(4주), 영업 수수료를 지불할 필요가 없고, 아웃바운드 물류 비용이 낮아집니다.\n\n이런 의문점들은 합당하지만, 이에 답하기 위해서는 복잡한 계산이 필요하며, 우리 모델이 이를 완벽히 자동화할 수 있습니다.\n\n## 시나리오 2: 인바운드 물류용 항공 운송\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 경험상, 항공 화물 운송은 주로 빠른 배송이 필요한 고가 제품에 사용됩니다(주로 명품이나 자동차 부품).\n\n그러나 제 친구에게 운동하라고 제안했습니다\n\n- 화물 중개인이 제안한 항공 운송 요금은 3배 높음\n- 배송 리드타임은 4주에서 1주로 단축됨\n\n이제 주문 수량을 8주에서 3주로 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_18.png\" /\u003e\n\n💡 관찰 사항\n\n- 평균 재고 수준이 이전보다 낮아졌습니다. 이는 저장 비용을 줄일 수 있습니다.\n- 주문 빈도가 더 높고 수량이 적습니다.\n\n안타깝게도, 이는 고비용의 항공 운송 비용을 상쇄하지 못합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이로 인해 판매원가(COGS)가 증가합니다.\n시나리오 2: cogs = 5,511 ($/팔렛) | +8 %\n- 이로 인해 팔렛 당 수익성이 낮아집니다.\n시나리오 2: avg_profit = 3,232 ($/팔렛) | -12 %\n- 다행히도, 연초에 필요한 현금이 줄어듭니다.\n시나리오 2: coh_0 = 17,288 ($) | -86 %\n\n요약하면, 장기적으로 수익성이 감소하므로 이 아이디어는 좋은 아이디어가 아닙니다.\n\n## 시나리오 3: 판매 채널 최적화\n\n마지막 시나리오에서는 판매 채널 전략에 초점을 맞출 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 상황에서는 바로 커피숍에 직접 판매하는 것과 유통업체와의 협력이 혼합되어 있습니다.\n\n![2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_19.png](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_19.png)\n\n만약 우리가 유통업체만 사용한다면,\n\n- 출하 후 4주 후에 결제를 받게 됩니다.\n- 판매 수수료를 지불할 필요가 없습니다.\n    - 직접 판매의 경우 30%의 판매 수수료 vs. 0%의 판매 수수료\n- 결합 출하로 배송을 최적화할 수 있습니다.\n- 직접 판매와 비교했을 때 경비 운송 비용이 50% 절감됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 영향은 처음 지불을 받기까지 4주를 기다려야 한다는 것이며, 이는 유동성 요구에 영향을 미칩니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_20.png\" /\u003e\n\n- 연습 시작 시 더 많은 현금이 필요합니다.\n시나리오 3: coh_0 = 197,602 달러 | -58 %\n\n그러나 수수료 비용을 줄이고 수익성을 향상시키고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Cost of Goods Sales (COGS)에 큰 영향.\n새 시나리오: cogs = 3,172 ($/Pallet) | -38 %\n- 판매 당 더 나은 수익성.\n새 시나리오: avg_profit = 5,068 ($/Pallet) | +37 %\n\n## 최적 시나리오\n\n이 작은 연습은 비즈니스에 영향을 미치지 않고 수익을 극대화하는 데 더 나은 가시성과 통찰력을 제공합니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_21.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구가 비즈니스 수익을 극대화하고 싶다면\n\n- 유통 업체로부터 주문을 더 받아야 하며 직접 판매는 중지해야 합니다.\n- 공급 업체로부터 주문 시 6주분의 재고를 유지해야 합니다.\n\n이 계획을 따른다면 데이터에 따르면 수익을 33% 증가시킬 수 있을 것입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 애매한 운영 절차와 비즈니스 관행을 간단한 모델로 번역할 수 있게 해줍니다.\n\n이 모델을 통해 가치 사슬의 각 구성 요소가 서로 상호 작용하는 방식을 이해할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_22.png)\n\n한 번의 클릭으로 질문에 대한 답변을 제공하는 것이 목표였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 바다 화물에서 항공 화물로 바꾸면 어떨까요?\n- 최고의 판매 채널이 무엇인가요?\n- 물류 비용이 전체 수익에 미치는 영향은 무엇인가요?\n\n이 간단한 모형은 전략적인 통찰력을 제공하지만 제한 사항이 있습니다.\n\n- 구매 비용 구조에는 MOQ 및 감소 가격이 포함되어야 합니다.\n\n이러한 구조를 바탕으로 제품을 주문하고 수령하는 비용을 최소화하는 최적 주문 수량을 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에는 더 많은 세부 내용이 있습니다.\n\n- 화물운송업체와 운송회사는 용량과 서비스 수준 계약에 따라 청구서를 작성합니다.\n\n물류 서비스 제공업체들이 유연성을 제공한다면, 자신들의 경로를 최적화하고 가격을 줄일 수 있는 기회가 더 많아질 것입니다.\n\n저는 공급망 솔루션 매니저로 일하면서 이와 같은 연습을 자주 했습니다; 이 기사에 예시가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 고정 비용은 범주별로 구체적으로 나누어야 합니다: CAPEX, 인력, 공과금 등\n\n저는 제 YouTube 채널에서 창고 운영 비용 분석 예시를 공유했습니다.\n\n- 판매 가격에는 결제 기간이 짧은 경우의 할인이나 주문량에 따라 감소하는 금액이 포함될 수 있습니다.\n- 판매 대상을 다수의 품목으로 확장하고 비용과 수익을 최적화하기 위해 다양한 제품 조합을 고려할 수 있습니다.\n\n우리는 선형 프로그래밍과 Python을 사용하여 제 친구가 올바른 품목을 판매하면서 유동성, 저장 공간, 공급 업체 용량 제약을 고려하여 수익을 극대화하는 데 도움을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법론에 대해 더 자세히 알고 싶다면, 이 기사를 참고해보세요.\n\n- 우리는 수익성 또는 지속 가능성 제한을 기반으로 공급 업체 선정을 최적화할 수 있습니다.\n\n초기 모델은 커피잔을 위한 단일 공급 업체를 고려하고 있습니다. 그러나 제 친구는 세계 각지의 공급 업체를 자격을 부여하여 소싱을 다각화하는 작업을 하고 있습니다.\n\n이러한 다양한 공급 업체로부터 데이터를 수집한 후, 저희는 제가 개발한 간단한 웹 애플리케이션을 사용하여 최적의 공급망 네트워크를 설계하는 데 도움을 받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_23.png\" /\u003e\n\n특정 환경 메트릭 또는 비용 최소화를 목표로 하는 경우, 알고리즘은 자동으로 최적의 공급업체를 선택합니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_24.png\" /\u003e\n\n이는 귀하의 고객에게 제품을 생산하고 전달하기 위한 공급망 흐름을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 세부 정보를 보려면 이 기사를 확인해보세요.\n\n## 다음은 무엇인가요?\n\n이 아이디어는 수익을 극대화하고 환경 영향을 줄이며 유동성에 대한 압력을 피하기 위해 사용할 수 있는 모든 개선 도구들을 수집하는 것입니다.\n\n![이미지](/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_25.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 기사에서는 제 친구가 그의 비즈니스에 도입한 변화와 모델화에 대한 업데이트를 공유할 것입니다.\n\n# 나에 대해\n\nLinkedIn 및 Twitter에서 연락해요. 저는 데이터 분석을 사용하여 물류 영업을 개선하고 비용을 줄이는 공급망 엔지니어입니다.\n\n데이터 분석과 공급망에 관심이 있다면 제 웹사이트를 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_0.png"},"coverImage":"/assets/img/2024-06-20-BusinessPlanningwithPythonInventoryandCashFlowManagement_0.png","tag":["Tech"],"readingTime":13}],"page":"47","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"47"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>