<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/47" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/47" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" href="/post/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 클로저 마스터하기 심층 탐험 " href="/post/2024-06-20-MasteringJavaScriptClosuresADeepDive"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 클로저 마스터하기 심층 탐험 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 클로저 마스터하기 심층 탐험 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 클로저 마스터하기 심층 탐험 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" href="/post/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서 다중 모달 지원하기 새로운 방식</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nx 암시적 라이브러리 숨겨진 보물 " href="/post/2024-06-20-NxImplicitLibrariesTheHiddenGem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nx 암시적 라이브러리 숨겨진 보물 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nx 암시적 라이브러리 숨겨진 보물 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nx 암시적 라이브러리 숨겨진 보물 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GitHub Copilot의 탑 10 기능" href="/post/2024-06-20-Top10GitHubCopilotFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GitHub Copilot의 탑 10 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GitHub Copilot의 탑 10 기능</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고급 데이터 구조 및 알고리즘 더미용 신경망" href="/post/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고급 데이터 구조 및 알고리즘 더미용 신경망" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고급 데이터 구조 및 알고리즘 더미용 신경망</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 데이터 유형" href="/post/2024-06-20-JavaScriptDataTypes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 데이터 유형" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-JavaScriptDataTypes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 데이터 유형" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 데이터 유형</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" href="/post/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템 디자인 면접 아마존 플립카트" href="/post/2024-06-20-SystemDesignInterviewAmazonFlipkart"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템 디자인 면접 아마존 플립카트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템 디자인 면접 아마존 플립카트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시스템 디자인 면접 아마존 플립카트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" href="/post/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link posts_-active__YVJEi" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기","description":"","date":"2024-06-20 01:25","slug":"2024-06-20-JavaScriptParsingXMLDataFromOnlineSources","content":"\n\n\n![이미지](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png)\n\n웹에서 XML 데이터를 가져오고 추출하는 능력은 웹 개발자에게 중요한 기술입니다. XML은 구조화된 데이터를 교환하는 데 널리 사용되는 형식이며, 많은 온라인 서비스와 API가 이 형식으로 데이터를 제공합니다.\n\nJavaScript로 XML 데이터를 가져오는 현대적인 방법 중 하나는 fetch() API를 사용하는 것입니다. fetch() 함수를 사용하면 이전의 XMLHttpRequest 객체보다 더 간결하고 promise 기반으로 HTTP 요청을 보내고 XML 내용을 검색할 수 있습니다.\n\nfetch()를 사용하여 XML 데이터를 가져오면 JavaScript에서 DOMParser 객체와 같은 도구를 제공하여 XML을 DOM 구조로 구문 분석할 수 있으며, 이를 통해 필요한 정보를 추출할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# [1] JavaScript 프로젝트 생성하기\n\nReplit 플랫폼에서 만들어보세요\n\n![](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_1.png)\n\n# [2] HTML과 JavaScript 코드 편집하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 index.html:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e\n  \u003ctitle\u003ereplit\u003c/title\u003e\n  \u003clink href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv id=\"divOutput\"\u003e\u003c/div\u003e\n  \u003cscript src=\"script.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n위 HTML 코드는 웹 페이지의 기본 구조를 설정합니다. 이는 문자 인코딩, 뷰포트, 제목을 지정하는 `head` 섹션과 \"style.css\"라는 외부 CSS 파일에 대한 링크를 포함하고 있습니다. 또한, 동적 콘텐츠를 담을 컨테이너로 사용될 ID가 \"divOutput\"인 `div` 요소와 페이지 로드 시 실행될 \"script.js\"라는 외부 JavaScript 파일을 포함하는 `script` 요소를 포함한 `body` 섹션을 포함합니다. `!DOCTYPE html` 선언은 웹 브라우저에게 이 문서가 HTML5 문서임을 알려주며, 전체 코드는 클라이언트 측 스크립팅 및 JavaScript 파일을 사용한 동적 콘텐츠 조작을 포함한 웹 페이지의 기초를 설정합니다.\n\n파일 script.js:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar myUrl = 'https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml';\n// CORS 문제를 처리하기 위해 cors-anywhere 서비스를 사용함\nvar proxy = 'https://cors-anywhere.herokuapp.com/';\n\n// 요청 실행\nfetch(proxy + myUrl)\n  .then(response =\u003e response.text())\n  .then(xmlString =\u003e parseXML(xmlString))\n  .catch(error =\u003e console.error(error));\n\n// XML 데이터 파싱\nfunction parseXML(xmlString) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(xmlString, 'application/xml');\n\n  // 요소에 액세스\n  const posts = doc.getElementsByTagName('Post');\n  for (let i = 0; i \u003c posts.length; i++) {\n    const post = posts[i];\n    const postClass = post.getAttribute('class');\n    const postUser = post.getAttribute('user');\n    const postText = post.textContent.trim();\n\n    console.log('게시물 클래스:', postClass);\n    console.log('게시물 사용자:', postUser);\n    console.log('게시물 텍스트:', postText);\n\n    const terminals = post.getElementsByTagName('t');\n    for (let j = 0; j \u003c terminals.length; j++) {\n      const terminal = terminals[j];\n      const pos = terminal.getAttribute('pos');\n      const word = terminal.getAttribute('word');\n      console.log(`POS: ${pos}, 단어: ${word}`);\n      const divOutput = document.getElementById('divOutput');\n      if (divOutput) {\n        divOutput.innerHTML += `POS: ${pos}, 단어: ${word}\u003cbr\u003e`;\n      }\n    }\n    console.log();\n  }\n}\n```\n\n제공된 코드는 \"https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml\"에 위치한 XML 문서를 가져와 내용을 파싱하는 JavaScript 솔루션을 보여줍니다. 이 데이터는 NPS Internet Chatroom Corpus의 일부입니다.\n\n위의 JavaScript 코드는 fetch() API를 사용하여 HTTP 요청을 수행하고, 잠재적인 Cross-Origin Resource Sharing (CORS) 문제를 처리하기 위해 \"https://cors-anywhere.herokuapp.com/\"의 프록시 URL을 활용합니다. fetch 요청에서의 응답은 텍스트 형식으로 변환되며, XML 문자열이 가정적인 parseXML() 함수에 전달되어 추가 처리됩니다. 코드에는 또한 fetch나 파싱 작업 중 발생할 수 있는 문제를 기록하기 위한 오류 처리도 포함되어 있습니다.\n\nparseXML() 함수는 이전 코드 스니펫에서 가져온 XML 데이터를 파싱하는 역할을 합니다. 먼저 DOMParser 객체의 새 인스턴스를 생성하고, parseFromString() 메서드를 사용하여 XML 문자열을 Document 객체로 파싱합니다. 함수는 이후 파싱된 문서에서 모든 'Post' 요소를 검색하고, 각각의 'class', 'user' 및 텍스트 내용을 추출하여 콘솔에 기록합니다. 다음으로, 함수는 각 'Post' 요소 내부의 모든 't' (터미널) 요소를 가져와, 'pos' (품사) 및 'word' 속성을 추출하고, 이 정보를 콘솔에 기록하고 동시에 'divOutput' ID를 가진 HTML 요소에 추가합니다. 이 과정을 통해 함수는 XML 데이터를 파싱하고 관련 정보를 추출하여 이를 콘솔과 웹 페이지에 표시할 수 있게 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_2.png\" /\u003e\n\n# [3] Replit Code:\n\n코드를 사용하지 않는 방법을 선호하는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://jsonformatter.org/xml-parser\n- https://codebeautify.org/xml-parser-online\n\n# 🤓","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트 클로저 마스터하기 심층 탐험 ","description":"","date":"2024-06-20 01:23","slug":"2024-06-20-MasteringJavaScriptClosuresADeepDive","content":"\n\n자바스크립트 클로저는 이해하기 어려운 개념 중 하나입니다. 코드에서 클로저를 많이 사용할 수 있지만 그것을 사용하고 있다는 것을 깨닫지 못할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png)\n\n클로저에 대한 큰 영광은 Will Sentance와 Frontend master가 제공하는 JavaScript: The Hard Parts 강좌에 갑니다.\n\n클로저를 이해하기 위해 먼저 실행 컨텍스트를 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실행 컨텍스트란 무엇인가요?\n\n- 실행 컨텍스트: JavaScript에서 \"실행 컨텍스트\"란 코드가 실행되는 환경을 말합니다. 실행 컨텍스트에는 코드가 실행되는 동안 접근할 수 있는 변수, 함수, 객체 및 기타 데이터가 포함되어 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*9mMAag-MhCw8FKNtIP5WDA.gif)\n\n# 실행 컨텍스트의 종류:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전역 실행 컨텍스트: 이것은 기본 또는 가장 바깥에 있는 실행 컨텍스트입니다. 스크립트가 실행될 때 생성되며, 함수 내부에 없는 코드가 실행되는 곳입니다. 웹 브라우저에서는 전역 실행 컨텍스트가 윈도우 객체와 관련됩니다.\n- 함수 실행 컨텍스트: 함수가 호출될 때마다 해당 함수를 위한 새로운 실행 컨텍스트가 생성됩니다. 이 컨텍스트에는 함수 내에서 정의된 모든 변수, 객체 및 함수가 포함됩니다. 함수 실행이 완료되면 해당 실행 컨텍스트가 실행 스택(호출 스택)에서 제거됩니다.\n\n# 함수 실행 개요\n\n함수가 호출될 때, JavaScript는 함수가 올바르게 실행되도록 일련의 명확하게 정의된 단계를 수행합니다. 다음은 프로세스의 자세한 설명입니다:\n\n- 시작: 실행 컨텍스트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 실행 컨텍스트: 함수가 호출될 때 JavaScript는 해당 함수를 위해 새로운 실행 컨텍스트를 생성합니다. 이 컨텍스트에는 필요한 모든 매개변수, 변수 및 함수의 코드가 포함됩니다.\n- 호출 스택: 이 새로운 실행 컨텍스트는 호출 스택에 푸시됩니다. 이는 JavaScript가 함수 호출 순서를 관리하는 메커니즘입니다.\n\n- 실행: 라인별 처리\n\n- 라인별 실행: 함수의 실행 컨텍스트 내에서 JavaScript는 함수의 코드를 한 줄씩 처리합니다. 이는 변수 처리, 계산 수행 및 함수 내에서 정의된 다른 작업 실행을 포함합니다.\n- 스코프 체인과 클로저: 실행 중에 함수는 클로저 덕분에 자체 지역 변수, 전달된 매개변수 및 외부 범위의 변수에 액세스할 수 있습니다.\n\n- 종료: 정리 및 컨텍스트 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 함수 호출 스택에서 팝업: 함수가 실행을 완료하면 해당 실행 컨텍스트가 호출 스택에서 팝업됩니다. 이는 컨텍스트가 제거되어 JavaScript가 함수가 호출된 위치에서 코드를 계속 실행하게 됨을 의미합니다.\n- 지역 변수 정리: 함수의 실행 컨텍스트 내에서 정의된 지역 변수와 매개변수는 제거되어 메모리와 리소스를 해제합니다.\n\n# 명확성을 위한 예시:\n\n다음 함수의 실행을 자세히 살펴봅시다:\n\n```js\n1: const num = 3;\n2: function multiplyBy2(inputNumber) {\n3:   const result = inputNumber * 2;\n4:   return result;\n5: }\n6: const output = multiplyBy2(num);\n7: const newOutput = multiplyBy2(10);\n8: console.log(output);\n9: console.log(newOutput);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 1행: 전역 실행 컨텍스트에서 새로운 상수 변수 num을 선언하고 숫자 3을 할당합니다.\n- 2~5행: 여기서는 multiplyBy2라는 새로운 함수를 선언합니다. 전역 실행 컨텍스트에 multiplyBy2라는 새 변수를 생성하고 이에 함수 정의를 할당합니다. 이 함수는 inputNumber 매개변수를 받아들이고 그 값을 2배로 곱한 후 결과를 변수 result에 저장하고 반환합니다. 이 함수 내의 코드는 아직 평가되지 않았으며 나중 사용을 위해 저장됩니다.\n- 6행: 이 행은 간단해 보이지만 많은 일이 벌어집니다. 먼저, 전역 실행 컨텍스트에 새 변수를 선언하고 output이라고 이름 붙입니다. 이 변수는 처음에는 정의되지 않은 상태입니다.\n- 6행 (계속): 함수 multiplyBy2를 호출하여 output에 새 값을 할당할 것입니다. JavaScript 엔진은 전역 실행 컨텍스트에서 multiplyBy2를 찾아 함수 정의를 찾은 후 이를 실행할 준비를 합니다. 변수 num을 인자로 전달합니다. 엔진은 전역 실행 컨텍스트에서 값이 3인 num을 찾고 이 값을 함수에 전달합니다.\n- multiplyBy2를 위한 새 실행 컨텍스트: 새로운 로컬 실행 컨텍스트가 생성되어 여기에 multiplyBy2 실행 컨텍스트라고 부르겠습니다. 이 컨텍스트가 호출 스택에 푸시됩니다. 여기서 첫 번째 할 일은 함수 매개변수를 처리하는 것입니다. 이 로컬 실행 컨텍스트에서 새 변수 inputNumber가 선언되고 전달된 값인 3이 할당됩니다.\n- 3행: 로컬 실행 컨텍스트 내에서 새로운 상수 변수 result를 선언합니다. 처음에 result는 정의되지 않은 상태입니다. 그런 다음, 식 inputNumber * 2가 평가됩니다. 엔진은 inputNumber를 찾아 이 값을 3으로 가진 로컬 실행 컨텍스트에서 찾은 후 이를 2배로 곱하여 6을 얻습니다. 이 값은 result에 할당됩니다.\n- 4행: 결과 값인 6을 반환합니다. 로컬 실행 컨텍스트가 여기서 종료됩니다. 변수 inputNumber와 result는 파괴됩니다. 컨텍스트가 호출 스택에서 팝되고 반환 값 6이 호출 컨텍스트인 전역 실행 컨텍스트에 반환됩니다.\n- 6행 (계속): 반환된 값인 6이 output에 할당됩니다.\n- 7행: 비슷하게, 전역 실행 컨텍스트에서 다른 변수인 newOutput을 선언하고 인수 10을 사용하여 multiplyBy2를 호출한 결과를 할당합니다. 엔진은 다시 multiplyBy2를 찾고 호출하며 인수로 10을 전달합니다.\n- multiplyBy2를 위한 새 실행 컨텍스트 (두 번째 호출): 새로운 로컬 실행 컨텍스트가 생성되어 호출 스택에 푸시됩니다. 매개변수 inputNumber에 값 10이 할당됩니다.\n- 3행: 이 로컬 실행 컨텍스트에서 새로운 상수 변수 result를 선언하고 undefined로 초기화합니다. 식 inputNumber * 2가 평가됩니다. 엔진은 값이 10인 inputNumber를 찾아 2배로 곱한 후 20을 얻고 이 값을 result에 할당합니다.\n- 4행: 함수는 결과값인 20을 반환합니다. 로컬 실행 컨텍스트가 종료되고 변수 inputNumber와 result가 파괴됩니다. 컨텍스트가 호출 스택에서 팝되어 반환값 20이 호출 컨텍스트로 반환됩니다.\n- 7행 (계속): 반환된 값인 20이 newOutput에 할당됩니다.\n- 8행: output 값을 콘솔에 출력합니다. 콘솔에는 6이 표시됩니다.\n- 9행: newOutput 값을 콘솔에 출력합니다. 콘솔에는 20이 표시됩니다.\n\n이 자세한 설명은 JavaScript가 변수 선언, 함수 정의, 실행 컨텍스트의 생성 및 소멸을 처리하는 방식을 보여줍니다. 아직 클로저에 대해서 다루지는 않았지만, 함수와 스코프가 동작하는 기본적인 내용을 보여줌으로써 이해를 돕습니다.\n\n코드 실행을 확인하려면 JavaScript Visualizer (ui.dev)와 같은 도구를 사용할 수 있습니다.\n\n# 코드를 실행해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제에서 함수가 어떻게 실행되는지 배웠습니다. 이번 함수를 살펴보고 무슨 일이 일어날지 알아보겠습니다.\n\n```js\n1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n```\n\ncreateCounter 함수의 실행을 단계별로 자세히 살펴보겠습니다:\n\n- 1–8행: createCounter라는 함수를 정의합니다. 전역 실행 컨텍스트에서, createCounter라는 새 변수를 선언하고, 1부터 8까지의 함수 정의를 그에 할당합니다. 함수 내의 코드는 아직 실행되지 않고, 나중 사용을 위해 저장됩니다.\n- 9행: 전역 실행 컨텍스트에서 새 변수 increment를 선언합니다. 초기에는 이 변수가 정의되지 않습니다.\n- 9행(계속): createCounter 함수를 호출하고, 반환된 값을 increment에 할당합니다. JavaScript 엔진은 전역 실행 컨텍스트에서 createCounter를 찾아 함수 정의를 찾아 실행 준비를 합니다.\n- createCounter에 대한 새 실행 컨텍스트: createCounter 실행 컨텍스트라는 새로운 로컬 실행 컨텍스트가 생성됩니다. 이 컨텍스트는 호출 스택에 푸시됩니다.\n- 2행: 이 로컬 컨텍스트 안에서, 변수 counter를 선언하고 0으로 초기화합니다.\n- 3–6행: 새 constant 변수인 myFunction을 선언하고 함수 정의를 할당합니다. 이 함수는 counter 변수를 증가시키고 해당 값을 반환합니다.\n- 7행: myFunction 함수가 createCounter에 의해 반환됩니다. createCounter의 로컬 실행 컨텍스트가 종료되고, 컨텍스트는 호출 스택에서 팝됩니다. 변수 counter와 myFunction은 더 이상 이 컨텍스트에 존재하지 않습니다.\n- 9행(계속): 반환된 함수(myFunction과 해당 클로저)가 increment 변수에 할당됩니다. 이제 increment에는 myFunction에 저장된 함수 정의가 포함됩니다.\n- 10행: 전역 실행 컨텍스트에 새 변수 c1을 선언합니다.\n- 10행(계속): increment 함수를 호출하고, 반환 값을 c1에 할당합니다. JavaScript 엔진은 increment를 찾아 함수 정의를 찾아 실행 준비를 합니다.\n- increment에 대한 새 실행 컨텍스트: 이 함수 호출을 위한 새 로컬 실행 컨텍스트가 생성됩니다. 이 컨텍스트는 호출 스택에 푸시됩니다.\n- 4행: 이 로컬 컨텍스트 안에서, counter를 1만큼 증가시켜 업데이트합니다. 로컬 실행 컨텍스트에서 counter를 찾지만 찾을 수 없습니다. 따라서 전역 컨텍스트에서 찾지만 여전히 counter가 없습니다. JavaScript는 이를 undefined + 1로 해석하여 값이 1인 새로운 로컬 변수 counter를 만듭니다 (undefined가 여기서 0처럼 작동).\n- 5행: 함수는 counter의 값인 1을 반환합니다. 이로써 로컬 실행 컨텍스트가 종료되고 counter가 제거됩니다.\n- 10행(계속): 반환된 값인 1이 c1에 할당됩니다.\n- 11행: c2에 대해 9-14단계를 반복합니다. increment 함수가 다시 호출되고, 이번에도 1이 반환되어 c2에 할당됩니다.\n- 12행: c3에 대해 9-14단계를 반복합니다. increment 함수가 다시 호출되고, 이번에도 1이 반환되어 c3에 할당됩니다.\n- 13행: 마지막으로, c1, c2 및 c3의 값이 콘솔에 로깅됩니다. 콘솔에는 \"example increment 1 1 1\"이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 설명에 따르면 1, 1, 1을 기대할 수 있지만, 실제로는 1, 2, 3이 출력됩니다. 여기서 무슨 일이 벌어지고 있는 걸까요?\n\nincrement 함수가 어떻게 counter의 값을 기억한다는 거죠?\n\ncounter가 전역 실행 컨텍스트의 일부인가요? console.log(counter)를 해보면 undefined를 보게 될 것입니다. 그러니 그것도 아닙니다.\n\nincrement를 호출할 때, 어떻게 그것이 생성된 함수인 createCounter로 돌아가는 걸까요? 그런데 변수 increment는 함수 정의를 포함하고 있는데, 어떤 컨텍스트에서 왔는지는 포함하고 있지 않습니다. 그러니 그것도 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 다른 메카니즘이 작용하고 있을 수 있어요.\n그리고 있죠: \"클로저\"가 있습니다. 이것이 부재한 부분입니다.\n\n작동 방식은 다음과 같습니다. 새 함수를 선언하고 변수에 할당할 때, 함수 정의뿐만 아니라 클로저도 함께 저장됩니다. 클로저는 함수가 생성될 때 범위 내에 있는 모든 변수를 포함합니다. 가방처럼 생각해 보세요. 함수 정의는 모든 변수를 함께 저장하는 작은 가방을 가지고 있습니다. 함수를 호출할 때 increment를 호출하면 함수 정의뿐만 아니라 함수가 정의될 때 범위 내에 있던 변수도 사용됩니다. 따라서 counter는 increment를 호출할 때마다 값을 계속 유지합니다. 이는 전역 실행 컨텍스트의 일부가 아니지만 클로저 덕분에 기억되는 것입니다.\n\n따라서 우리가 위에서 설명한 것은 전혀 틀렸어요. 다시 시도해 보죠, 이번에는 올바르게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log('example increment', c1, c2, c3)\n```\n\n위 코드는 createCounter 함수의 실행을 자세히 살펴보겠습니다.\n\n- 1–8번 줄: createCounter라는 함수를 정의합니다. 전역 실행 컨텍스트에서 createCounter 변수를 선언하고 1부터 8까지의 함수 정의를 할당합니다. 함수 내부의 코드는 아직 실행되지 않고 나중에 사용할 준비만 되어 있습니다.\n- 9번 줄: 전역 실행 컨텍스트에서 increment 변수를 초기화합니다.\n- 9번 줄 (계속): createCounter 함수를 호출하고 반환된 값을 increment에 할당합니다. JavaScript 엔진은 전역 실행 컨텍스트에서 createCounter를 검색하여 함수 정의를 찾고 실행 준비를 합니다.\n- createCounter를 위한 새로운 실행 컨텍스트: createCounter 실행 컨텍스트라는 새로운 로컬 실행 컨텍스트가 생성되고 호출 스택에 푸시됩니다.\n- 2번 줄: 이 로컬 컨텍스트 내에서 counter 변수를 선언하고 0으로 초기화합니다.\n- 3–6번 줄: 새 상수 변수 myFunction을 선언하고 함수 정의를 할당합니다. 이 함수는 counter 변수를 증가시키고 해당 값을 반환합니다. 여기서 클로저가 생성됩니다. 클로저에는 함수 정의 내부의 counter 변수의 현재 값(0)이 포함됩니다.\n- 7번 줄: myFunction 함수(및 클로저)가 createCounter에 의해 반환됩니다. createCounter의 로컬 실행 컨텍스트가 종료되고 컨텍스트가 호출 스택에서 팝됩니다. 이 컨텍스트에는 더 이상 counter 및 myFunction 변수가 존재하지 않습니다. 그러나 myFunction은 클로저를 통해 counter에 대한 액세스 권한을 유지합니다.\n- 9번 줄 (계속): 반환된 함수(myFunction 및 클로저)가 increment 변수에 할당됩니다. 이제 increment에는 myFunction에 저장된 함수 정의가 포함되어 있습니다.\n- 10번 줄: 전역 실행 컨텍스트에서 새 변수 c1를 선언합니다.\n- 10번 줄 (계속): increment 함수를 호출하고 반환 값을 c1에 할당합니다. JavaScript 엔진은 increment를 검색하여 함수 정의를 찾고 실행 준비를 합니다.\n- increment를 위한 새로운 실행 컨텍스트: 이 함수 호출을 위한 새로운 로컬 실행 컨텍스트가 생성되어 increment 실행 컨텍스트로 명명됩니다. 이 컨텍스트가 호출 스택에 푸시됩니다. 이 로컬 컨텍스트에서 처음으로 할 일은 클로저를 사용하는 것입니다.\n- 4번 줄: 이 로컬 컨텍스트 내에서 counter를 1씩 증가시켜 업데이트합니다. 클로저 내에 counter가 있으므로 해당 값(0)이 검색되어 1로 증가되고 클로저에 업데이트됩니다.\n- 5번 줄: 함수는 업데이트된 counter의 값을 반환합니다(1). increment의 로컬 실행 컨텍스트가 종료되어 컨텍스트가 호출 스택에서 팝됩니다.\n- 10번 줄 (계속): 반환된 값(1)이 c1에 할당됩니다.\n- 11번 줄: c2에 대해 단계 9–14를 반복합니다. increment 함수가 다시 호출되고 클로저의 counter 값(1)이 2로 증가되어 2가 반환되고 c2에 할당됩니다.\n- 12번 줄: c3에 대해 단계 9–14를 반복합니다. increment 함수가 다시 호출되고 클로저의 counter 값(2)이 3으로 증가되어 3이 반환되고 c3에 할당됩니다.\n- 13번 줄: 마지막으로 c1, c2 및 c3의 값을 콘솔에 로깅합니다. 콘솔은 example increment 1 2 3를 표시합니다.\n\n이런 상황이 벌어지는 이유는 무엇일까요? 함수가 선언될 때 함수 정의뿐만 아니라 클로저도 함께 포함되기 때문입니다. 클로저는 함수가 생성된 시점의 모든 스코프에 있는 변수들의 집합입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n글로벌 범위에서 생성된 함수도 클로저를 가지고 있는지 궁금할 수 있습니다. 그 답은 네입니다. 글로벌 범위에서 생성된 함수도 클로저를 가지고 있지만, 글로벌 범위에서 정의되어 있기 때문에 모든 전역 변수에 접근할 수 있어 클로저 개념이 덜 중요해집니다.\n\n클로저는 함수가 다른 함수를 반환할 때 매우 중요해집니다. 반환된 함수는 글로벌 범위에 없지만 해당 클로저에 존재하는 변수에 접근할 수 있습니다.\n\n요약하면 인크리먼트 함수는 클로저를 통해 카운터의 값을 기억합니다. 인크리먼트를 호출할 때마다 카운터 값을 업데이트하고 반환하여 클로저를 통해 자신의 렉시컬 범위에 대한 액세스를 유지하는 방법을 보여줍니다. 이것이 JavaScript에서의 클로저의 본질입니다: 이들은 함수가 생성된 환경을 \"기억\"하도록 하여 함수가 그것들을 생성한 함수가 실행을 완료한 후에도 자신의 렉시컬 범위에 대한 액세스를 유지할 수 있도록합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 수업에서 윌 센튼스가 훌륭한 유사성을 제시했어요:\n\n이제 클로저에 대해 이해하셨으면 좋겠어요. 감사합니다🙌","ogImage":{"url":"/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringJavaScriptClosuresADeepDive_0.png","tag":["Tech"],"readingTime":10},{"title":"리액트 네이티브에서 다중 모달 지원하기 새로운 방식","description":"","date":"2024-06-20 01:20","slug":"2024-06-20-SupportingMultipleModalsinReactNativeANewApproach","content":"\n\n## 여러 모달을 관리하는 것은 React Native의 표준 모달 구현 및 인기있는 서드 파티 라이브러리에서 볼 수 있는 제한 사항입니다. 이 문제에 대한 우리만의 접근 방식 및 우리의 rn-modal-presenter 라이브러리 사용 방법을 알아보세요.\n\n바이 화이트 스펙트어 React Native 팀\n\n![이미지](/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png)\n\n이 기사는 화이트 스펙트어 React Native 팀 구성원인 Lucas Diez de Medina와 Rui Lu가 공동 저술했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어플 빌드를 위한 조사 중에, 현재 React Native 표준 모달 구현이 동시에 여러 모달을 관리하지 못한다는 사실을 발견했습니다. 인기 있는 서드 파티 라이브러리들도 비슷한 제한을 가지고 있어서 우리에겐 작동하지 않았습니다. 더욱 복잡한 React Native 앱일수록 더 많은 제약이 생길 것입니다. 더 나쁜 점은, 에러가 발생할 수 있지만 눈에 띄지 않을 수도 있습니다.\n\n그래서 우리는 우리만의 간단한 방법을 만들기로 결정했고, rn-modal-presenter 라이브러리를 출시했습니다. 우리가 발견한 사항과 여러분의 React Native 프로젝트에 우리 라이브러리를 사용하는 방법을 알아보려면 계속 읽어주세요.\n\n이 글에서 다루는 내용은 다음과 같습니다:\n\n- 서드 파티 모달 라이브러리의 제한 사항\n- 테스트한 대안\n- 우리의 해결책: rn-modal-presenter 라이브러리\n- rn-modal-presenter 라이브러리 구현 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nrn-modal-presenter 라이브러리의 전체 문서를 npm 및 GitHub에서 읽어보세요.\n\n# 서드파티 Modal 라이브러리의 제한 사항\n\n이제 위에서 언급한 대로, React Native에서 모달이 얼마나 중요한지는 알 수 있지만, 표준 구현은 몇 가지 중요한 제한 사항을 갖고 있습니다. 이는 사용자에게 다른 상황에서 여러 모달을 표시하려고 시도했을 때 우리가 발견한 것입니다.\n\n모달은 일반적으로 프롭을 기반으로 표시되거나 숨겨지는 컴포넌트이며, 이 프롭은 일반적으로 표시하는 컴포넌트의 상태에 의해 제어됩니다. 해당 컴포넌트는 컴포넌트 트리의 일부여야 하며 표시하고 싶은 모든 컴포넌트의 자식으로 나타나야 합니다. 이러한 이유로 하나의 컴포넌트로 표시되는 여러 모달을 표시하려는 경우나 모달이 표시되는 별도의 화면으로 이동해야 하는 경우에 기본적인 제한 사항과 복잡성이 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 번역하면 다음과 같습니다:\n\n- 모달을 제어하는 상태를 관리해야 합니다.\n- 상태를 업데이트함으로써 모달의 표시 및 숨김을 동시에 처리해야 합니다 (표시하는 컴포넌트 내에서).\n- 특정 컴포넌트에서 모달을 표시한 후에 뒤로 이동하려면, 표시하는 컴포넌트가 언마운트되므로 모달도 사라집니다.\n- iOS에서는 동시에 두 개 이상의 모달을 표시하거나 서로 겹치는 여러 모달을 스택으로 관리할 수 없습니다: https://github.com/react-native-modal/react-native-modal/issues/30\n\n마지막으로, 이 제한 사항은 iOS 네이티브 측면에 있습니다. UIViewController가 다른 뷰 컨트롤러를 표시한 후, 표시 중인 뷰 컨트롤러 (이제 숨겨진 상태)가 해당 뷰 컨트롤러 위에 다른 두 번째 뷰 컨트롤러를 표시할 수 없습니다. 따라서 이전에 표시된 뷰 컨트롤러에서 두 번째 뷰를 표시해야 합니다.\n\n# 간단한 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 예제로이 한계를 확인해 보겠습니다. 여기서는 전통적인 모달을 사용하여 앱 평가를 받으려고 시도하지만, 특정 상황에서만 만족한 사용자에게만 보여줍니다.\n\n사용자가 앱에서 관련 작업을 수행한 후에는 다음을 보여줍니다:\n\n- 작업이 완료되었음을 알리는 모달\n- 앱에 대해 얼마나 만족하는지 묻는 모달\n\n- 긍정적인 답변일 경우 AppStore에서 앱 평가를 요청하는 모달을 보여줍니다.\n- 부정적인 답변인 경우 피드백을 남겨 주시라는 모달을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 모든 이 modal들이 같은 메인 화면에서 제시되며 이 코드 스니펫에서 볼 수 있듯이 네 가지 다른 modal에 대한 모든 상태를 가지고 있으며 그 상태에 따라 각 modal을 표시합니다.\n\n```js\nconst App = () =\u003e {\n const [showRateAppModal, setShowRateAppModal] = useState(false);\n const [showAppRatedPositiveModal, setShowAppRatedPositiveModal] = useState(false);\n const [showAppRatedNegativeModal, setShowAppRatedNegativeModal] = useState(false);\n const [showActivateGadgetModal, setShowActivateGadgetModal] = useState(false);\n \n return (\n   \u003cSafeAreaView\u003e\n     {showActivateGadgetModal \u0026\u0026 (\n       \u003cActivateGadgetModal\n         onDismiss={() =\u003e {\n           setShowActivateGadgetModal(false);\n         }\n       /\u003e\n     )}\n     {showRateAppModal \u0026\u0026 (\n       \u003cRateAppModal\n         positiveFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedPositiveModal(true);\n         }\n         negativeFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedNegativeModal(true);\n         }\n       /\u003e\n     )}\n     {showAppRatedPositiveModal \u0026\u0026 (\n       \u003cPositiveFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedPositiveModal(false)}\n       /\u003e\n     )}\n     {showAppRatedNegativeModal \u0026\u0026 (\n       \u003cNegativeFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedNegativeModal(false)}\n       /\u003e\n     )}\n     \u003cButton\n       title=\"Activate Gadget\"\n       onPress={() =\u003e {\n         setShowActivateGadgetModal(true);\n         setShowRateAppModal(true);\n       }\n     /\u003e\n   \u003c/SafeAreaView\u003e\n );\n};\n```\n\n이 상호작용은 상태를 같은 컴포넌트에서 제어하기 때문에 매우 간단합니다. 또한 우리는 저장소(store)를 가지고 있지 않습니다. 이미 4개의 상태 변수를 가지고 있는 저장소를 관리하고 있는데, 이것은 계속해 추가할수록 더 복잡해집니다.\n\n이제 실수로 두 개의 modal을 동시에 표시하려고하면 어떻게 작동하는지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 첫 번째 모달이 iOS에서만 표시될 것이며, 이 문제의 가장 나쁜 부분은 React Native 콘솔에서는 오류가 발생하지 않았다는 것입니다.\n\n그러나 Xcode 콘솔을 확인하면 현재 다른 View Controller 위에 View Controller를 표시하려고 시도하고 있는 것이 iOS 시스템에서 올바르지 않은 동작임을 알 수 있습니다.\n\n보게 될 오류는 다음과 같습니다:\n\n```js\nWarning: Attempt to present \u003cUIViewController: 0x147d2c6b0\u003e on \u003cUIViewController: 0x147d614c0\u003e which is already presenting (null)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS에서 올바른 흐름은 첫 번째 모달을 표시한 후에, 첫 번째 모달이 해제되면(해당 상태 변수를 false로 설정함으로써) 다음 모달의 상태 변수를 true로 설정하여 표시하는 것입니다.\n\n상상할 수 있듯이, 이것은 매우 복잡해질 수 있습니다. 대부분의 경우 개발자들은 여러 모달의 해제와 표시를 관리하기 위해 지연 또는 시간 초과를 사용합니다. 이로 인해 예기치 못한 오류가 발생하며 실제로 모달 애니메이션 지속 시간은 앱이 실행되는 기기에 따라 다를 수 있습니다.\n\n요약하면, 여기서 직면한 문제는 표시 컴포넌트가 모든 로직 및 상태 관리를 처리해야 하고 표시하려는 각 모달마다 하나의 상태 변수가 필요하다는 것입니다.\n\n우리에게 가장 큰 문제는 한 가지 실수를 하게 되면, 두 개의 모달을 동시에 표시하려고 한다면 두 번째 모달이 나타나지 않고 오류/경고 메시지도 표시되지 않는다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시도한 대체품\n\n리액트 네이티브 프로젝트에서 여러 모달을 관리하는 데 직면할 수 있는 두 가지 일반적인 문제는 다음과 같습니다:\n\n- 동시에 하나 이상의 모달을 표시할 수 없음\n- 모달이 더 많이 추가될수록 코드 복잡성이 기하급수적으로 증가함\n\n이러한 두 가지 문제로 인해 표준 네이티브 모달 컴포넌트를 사용하면서 이를 해결하기 위해 다양한 옵션을 시도해 보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에는 여기서 가장 일반적으로 사용되는 2개의 라이브러리가 있으며, 이들을 사용한 이유와 우리가 고유한 방식으로 진행하기로 결정한 이유를 설명했습니다.\n\n# react-native-modal\n\n이는 표준 React Native Modal 컴포넌트의 확장입니다. 기존 기능에 추가적인 기능을 제공하여 들어오는/나가는 애니메이션 타이밍을 지정할 수 있거나 다른 콜백을 제공하여 API를 사용자 정의할 수 있습니다. 또한 기기 방향에 따라 스와이프할 수 있고 스크롤 가능하며 적응적인 콘텐츠를 제공합니다.\n\n하지만 이러한 기능이 얼마나 좋든, 이 라이브러리는 결국 React Native에서 모달이 작동하는 방식을 변경하지 않기 때문에 여전히 동시에 여러 모달을 표시하거나 코드 복잡성을 줄이는 등 위에서 언급한 같은 제한 사항을 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# react-native-modalfy\n\n이 라이브러리는 이전 것보다 훨씬 인기가 적지만, 우리가 달성하고자 하는 방향과 일치합니다.\n\n첫 번째 이점은 JavaScript로 구현되어 여러 모달을 지원한다는 것입니다. 코드의 어느 곳에서든 JavaScript 함수를 호출할 수 있으며, 컴포넌트 트리를 혼동시키지 않고 추가적인 상태를 관리할 필요가 없습니다.\n\n다른 중요한 점은 명령형 API를 기반으로 하고 있으며, 각 모달의 외형에 대한 애니메이션과 전환을 완전히 사용자 정의할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 장점들에도 불구하고, 이 라이브러리는 설정하기 위해 일부 뼈대 코드가 필요했습니다. 이런 면에서 React Navigation과 매우 유사합니다. 여러분은 프로젝트 내에서 사용할 각 모달을 미리 정의하고 각각에 대한 구성을 제공해야 합니다.\n\n또 다른 단점은 동일한 모달 유형의 여러 인스턴스를 표시하거나 숨기지 못한다는 것입니다. 같은 스타일을 공유하는 다양한 버튼과 복사본을 가진 다수의 모달이 있는 애플리케이션에서는, 다양한 모달 엔티티를 만드는 대신 서로 다른 복사본을 위한 특정 매개변수를 가진 하나의 모달만 가지는 것이 더 효율적입니다.\n\n# 우리의 해결책: rn-modal-presenter\n\n다양한 옵션을 분석한 후, 우리는 다음 기반으로 우리만의 라이브러리를 만들기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유연한 구성요소와 명령형 API\n\n유연하다는 의미는 어떤 구성요소든 모달로 표현할 수 있고, 상태를 수정하지 않고 코드의 어디서든(표시된 모달 내에서도) 표시/감춤을 관리할 수 있다는 것입니다.\n\n명령형 API를 사용하면 앱 전체 위에 모달이 표시되므로 어디서든 모달 표시를 트리거할 수 있습니다.\n\n# 콘텐츠는 부모 구성요소(보통 귀하의 구성요소) 위에 표시됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 부보 컴포넌트는 우리 라이브러리에서 노출되었고, 여러분은 해당 컴포넌트 트리 어딘가에 배치해야 합니다. 이것은 모달 창이 다른 일반 뷰와 화면에 비해 가장 높은 우선순위를 가지고 있기 때문에 멋집니다.\n\n# 다중 모달 지원\n\n100% 자바스크립트 라이브러리이기 때문에 여러 개의 모달을 쉽게 표시할 수 있습니다. 또한 동일한 모달 유형의 여러 인스턴스를 표시하는 것을 지원합니다.\n\n그러나 이에는 조금 제한이 있습니다. 자바스크립트 솔루션이기 때문에 프로젝트에 다른 네이티브 모달이 있는 경우, 해당 나중 모달은 여전히 우리 모달 위에 있을 수 있습니다. 왜냐하면 네이티브 컴포넌트가 가장 높은 우선순위를 가지기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리 통합 방법\n\n단계 1: 프로젝트에 라이브러리 추가하기:\n\n- yarn add @whitespectre/rn-modal-presenter\n- npm install @whitespectre/rn-modal-presenter\n\n단계 2: 모달을 표시하고 싶은 컴포넌트 위에 래핑하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { ModalPresenterParent, showModal } from '@whitespectre/rn-modal-presenter';\n…\n\u003cModalPresenterParent\u003e\n  \u003cApp /\u003e\n\u003c/ModalPresenterParent\u003e\n```\n\n제 3단계: showModal 메소드를 호출하세요. 이 메소드는 다음을 받습니다:\n\n- 보여질 컴포넌트\n- 해당 컴포넌트로 전달될 속성\n- 나중에 모달을 해제하는 데 사용할 ModalHandler를 반환합니다.\n\n```js\nexport declare const showModal: \u003cContentProps\u003e(\n  Content: (props: ContentProps \u0026 ModalContentProps) =\u003e JSX.Element,\n  contentProps: ContentProps,\n) =\u003e ModalHandler;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다야. 충분히 준비됐어요.\n\n## 더 복잡한 구현\n\n### 컴포넌트에 속성 전달하기\n\n모달 위에 표시하려는 컴포넌트에 속성을 추가하려면 컴포넌트에 도우미 함수를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 showModal 함수를 호출하는 helper 함수를 만들 수 있습니다. 이 함수는 사용자에게 보여줄 텍스트와 사용자가 닫기 버튼을 눌렀을 때 실행할 완료 핸들러를 받는데, 이것은 custom text modal이 받는 속성을 받게 됩니다.\n\n```js\nexport const showCustomAlert = (\n  title: string,\n  body: string,\n  buttons: CustomAlertButton[] = [defaultButton],\n) =\u003e {\n  return showModal(CustomAlert, { title, body, buttons });\n};\n```\n\n## 컴포넌트 속성에 ModalContentProps 추가하기\n\n이 기능은 컴포넌트를 설치할 때 라이브러리에 의해 제공되며, dismiss 함수를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst CustomAlert = ({\n  dismiss,\n  title,\n  body,\n  buttons\n}: CustomAlertProps \u0026 ModalContentProps) =\u003e {\n  return (\n    …\n```\n\n여기에는 모달 컴포넌트 속성으로 반환된 dismiss 함수를 전달하고 해당 dismiss를 모달 내에서 모달을 지우는 데 사용합니다.\n\n## 새 라이브러리를 사용한 원본 예제\n\nrn-modal-presenter 라이브러리를 사용하면 상태를 관리할 필요가 없고 어디에서든 모달 표시를 강제로 트리거할 수 있기 때문에 원본 예제는 다음과 같이 다시 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인 앱 컴포넌트는 Gadget Activation 모달을 표시할 것입니다:\n\n```js\nconst App = () =\u003e {\n  return (\n    \u003cModalPresenterParent\u003e\n      \u003cSafeAreaView\u003e\n        \u003cButton\n          title=\"Gadget 활성화\"\n          onPress={() =\u003e {\n            showModal(ActivateGadgetModal, {});\n          }\n        /\u003e\n      \u003c/SafeAreaView\u003e\n    \u003c/ModalPresenterParent\u003e\n  );\n};\n```\n\n그리고 각 모달은 자체적으로 dismiss하고, 흐름에서 다음 모달을 표시하는 책임이 있을 것입니다. 예를 들어, ActivateGadgetModal은 아래와 같이 보일 것입니다:\n\n```js\nconst ActivateGadgetModal = ({dismiss}: ModalContentProps) =\u003e {\n  return (\n    \u003cView style={styles.modalOverlay}\u003e\n      \u003cView style={styles.modal}\u003e\n        \u003cView style={styles.contentContainer}\u003e\n          \u003cText\u003e당신의 Gadget이 활성화되었습니다\u003c/Text\u003e\n          \u003cView style={styles.buttonsContainer}\u003e\n            \u003cButton\n              title=\"닫기\"\n              onPress={() =\u003e {\n                dismiss();\n                showModal(RateAppModal, {});\n              }\n            /\u003e\n          \u003c/View\u003e\n        \u003c/View\u003e\n      \u003c/View\u003e\n    \u003c/View\u003e\n  );\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미래 개선 사항\n\nrn-modal-presenter 라이브러리는 현재 진행 중인 프로젝트에 우리의 요구 사항에 맞게 만들어 졌지만, 사용하면서 다른 기능과 개선 사항들을 확인했습니다. 다른 사용 사례에 유용할 수 있는 것들입니다.\n\n여기 우리 라이브러리에 도입하고 싶은 주요 기능 및 개선 사항입니다:\n\n- 하나씩 보이도록 모달의 대기열 만들기\n- 현재 여러 개의 모달이 동시에 표시되려고 하면 서로 위에 겹쳐서 나타납니다.\n- 대기열은 우선순위 매커니즘을 포함하여 강제로 다음 모달을 표시할 수 있어야 합니다.\n- 뷰가 네이티브 뷰들 위에 나타날 수 있도록 만들기\n- 더불어 네이티브 모듈을 구축하여 내용을 네이티브 뷰 위에 표시할 수 있도록 하기\n- 각 효과에 대해 사용자 정의 가능한 애니메이션 및 지속 시간 허용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이러한 기능 중 어떤 것을 구현하고 싶거나 우리 라이브러리에 기여하고 싶다면, 언제든지 다음 링크에서 PR을 열어주세요: [https://github.com/whitespectre/rn-modal-presenter](https://github.com/whitespectre/rn-modal-presenter).","ogImage":{"url":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png"},"coverImage":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png","tag":["Tech"],"readingTime":11},{"title":"Nx 암시적 라이브러리 숨겨진 보물 ","description":"","date":"2024-06-20 01:19","slug":"2024-06-20-NxImplicitLibrariesTheHiddenGem","content":"\n\nNx가 제공하는 엄청난 기능을 활용하기 위해, 여러 라이브러리로 애플리케이션을 분할하는 것이 일반적입니다. 사실, 애플리케이션을 라이브러리로 분리하는 것은 관심사와 경계를 명확히 분리하고, Nx의 캐싱, 그래프 및 병렬화 덕분에 빠른 작업 실행을 제공한다는 장점 중 하나입니다.\n\n그러나 여러 라이브러리를 만들면 각 라이브러리 사이에 일부 중복된 구성이 있음을 알 수 있을 것입니다.\n\n이러한 파일들은 작업 공간을 혼란스럽게 만들고 더 많은 라이브러리를 생성하는 것을 꺼리게 할 수 있습니다.\n\n다음은 최근 생성된 웹 라이브러리의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlibs\n└── web\n    └── catalog\n        └── ui\n            ├── README.md\n            ├── src\n            │   ├── index.ts\n            │   └── lib\n            │       ├── catalog.spec.ts\n            │       └── catalog.ts\n            ├── eslint.config.js\n            ├── project.json\n            ├── tsconfig.json\n            ├── tsconfig.lib.json\n            ├── tsconfig.spec.json\n            ├── vite.config.ts\n            └── vitest.config.ts\n```\n\n# 💎 프로젝트 크리스탈\n\n버전 18부터 (사실 그 전부터 조금씩), Nx는 프로젝트 구조를 기반으로 작업을 추론할 수 있게 되었습니다. 이는 Nx 플러그인이 새로운 대상을 자동으로 추가할 수 있게 해줍니다(예: Vitest 구성 파일을 감지하면 적절한 구성으로 테스트 대상을 암시적으로 추가). 이것을 프로젝트 크리스탈이라고 합니다.\n\n이를 통해 project.json 파일에서의 중복이 줄어들고 더 중앙 집중화된 구성이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로젝트 크리스털 이전\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png)\n\n## 프로젝트 크리스털 이후\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🪄 암시적 라이브러리\n\n프로젝트 Crystal은 프로젝트.json 파일에서 중복 구성을 줄입니다. 그런데 만약 프로젝트.json 파일을 완전히 제거할 수 있다면 어떨까요?\n\nNx 추론을 사용하면 Nx 그래프에 노드를 추가하거나 기존 노드를 보강하는 플러그인을 만들 수 있습니다 (예: 라이브러리 선언 노드 추가) 또는 기존 노드를 보강할 수도 있습니다. 프로젝트.json 파일에 남아 있는 정보는 프로젝트 구조에서 쉽게 유도할 수 있기 때문에 (관례가 있다고 가정할 때), 프로젝트.json 파일에서 남은 정보를 추론하고 이 파일을 간단히 제거할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📂 공유 설정\n\n프로젝트의 json 파일을 라이브러리에서 제거하는 데 성공했지만, eslint.config.js, tsconfig.json, vite.config.ts, vitest.config.ts 등 다른 구성 파일은 어떨까요?\n\n이러한 파일들을 완전히 제거하는 것이 유혹적일 수 있지만, 다른 도구와 IDE(예: IDE lint 플러그인, WallabyJS와 같은 테스트 러너 등)에 여전히 유용하므로 그대로 두는 것이 좋습니다.\n\n그러나 특정 그룹 내의 대부분의 라이브러리가 유사한 구성을 공유하기 때문에 이러한 구성 파일을 상위 그룹 디렉토리로 이동시킬 수 있습니다. 이전 예에서는 libs/web 디렉토리가 해당됩니다. 이렇게 하면 IDE 및 다른 도구가 여전히 구성을 인식할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🎯 암시적 라이브러리의 대상\n\n프로젝트.json을 제거하고 구성 파일을 공유 구성으로 교체한 후, 대부분의 Nx 내장 플러그인은 대상 구성을 자동으로 추정할 수 없게 됩니다.\n\nImplicit Libraries 플러그인을 수정하여 라이브러리를 생성하는 것뿐만 아니라 필요한 대상을 추가해야합니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공유된 구성 및 대상을 제대로 설정하여 작업이 라이브러리 파일에서만 실행되도록 해야 합니다.\n\n언급할 가치가 있는 점은 일부 도구(Eslint 및 Vitest 등)가 라이브러리의 루트를 현재 작업 디렉토리로 실행해야 합니다:\n\n```js\n{\n  ...,\n  targets: {\n    lint: {\n      command: 'eslint',\n      options: {cwd: projectRoot},\n      ...\n    },\n    ...\n  }\n}\n```\n\n# 🏷️ 추론된 태그\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 Implicit Libraries 플러그인은 당신의 프로젝트 구조와 규칙을 인식합니다. 이는 경계를 강제하거나 작업을 실행할 때 필터링하기 쉽도록 태그를 추가할 수 있습니다.\n\n이는 라이브러리가 잘못 태그되는 것을 방지하고 프로젝트 구조가 라이브러리 카테고리를 반영하도록 보장합니다.\n\n![Implicit Libraries](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_4.png)\n\n# 🏗️ Implicit Libraries Generators\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성기가 Implicit Libraries에 대해 쓸모없어 보일 수 있지만, tsconfig.base.json의 경로를 업데이트하는 데 사용될 수 있어 유용합니다. 개발자에게 올바른 카테고리(예: 플랫폼, 범위, 유형)를 제공하여 유효한 라이브러리 경로를 생성할 수 있습니다.\n\n# 🧩 도전과 주의할 점\n\nImplicit Libraries는 워크스페이스의 구성 파일 수를 줄이고 개발자가 더 많은 라이브러리를 생성하도록 장려하는 좋은 방법이지만, 다음과 같은 관련 도전에 대해 인식해야 합니다:\n\n- 대부분의 Nx 내장 플러그인은 project.json 파일을 사용하여 대상 구성을 추론합니다. 이는 Implicit Libraries 플러그인을 수정하여 필요한 대상을 추가해야 한다는 것을 의미합니다.\n- 대상 옵션을 사용하여 도구의 모든 옵션을 항상 쉽게 제어할 수 있는 것은 아닙니다. 예를 들어, 현재 Vitest 옵션에는 캐시 디렉토리를 재정의할 수 있는 방법이 없습니다. 해결책은 현재 작업 디렉토리를 사용하여 계산하는 것이지만, 이는 Nx 일괄 처리 모드와 간섭할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📖 Marmicode Cookbook\n\n만약 Nx 및 다른 내용에 대해 더 알고 싶다면, Marmicode Cookbook을 확인해보세요!\n\n![image](/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_5.png)\n\n# 📚 추가 자료\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 💻 암시적 라이브러리 예제\n- 📝 Nx 암시적 라이브러리 | Marmicode Cookbook\n- 📝 Nx 프로젝트 크리스탈의 매력 발견하기 | 조나단 젤린\n- 📺 프로젝트 크리스탈 | Nx\n- 📺 Nx로 프로젝트 재정의: 새로운 추론 API 탐구 | 크레이거리 코폴라","ogImage":{"url":"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png"},"coverImage":"/assets/img/2024-06-20-NxImplicitLibrariesTheHiddenGem_0.png","tag":["Tech"],"readingTime":4},{"title":"GitHub Copilot의 탑 10 기능","description":"","date":"2024-06-20 01:18","slug":"2024-06-20-Top10GitHubCopilotFeatures","content":"\n\n## 더 행복하고 생산적인 개발자가 되어보세요\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png)\n\nGitHub Copilot은 인공 지능 기술을 활용한 페어 프로그래밍 도구로, 빠르게 코딩하고 생산성을 향상시킬 수 있습니다.\n\n이 글에서는 GitHub Copilot의 최고 10가지 기능에 대해 이야기해볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 워크스페이스 에이전트\n\nCopilot @workspace agent은 우리의 코드를 강화하여 워크스페이스의 전체 맥락을 분석하고 이해함으로써 프로젝트의 아키텍처와 의존성과 일치하는 권장 사항을 제공할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_1.png)\n\n# 2. 코딩 질문하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 확실하지 않거나 기억하지 못하는 경우, 문서를 찾아보거나 구글 검색하지 않고도 Copilot에게 문법이나 일반 프로그래밍 개념에 대해 물어보세요. Copilot은 자연어나 코드 스니펫 형식으로 답변을 제공합니다. 예를 들어, 배열의 합을 계산하는 방법에 대해 물어보는 등의 질문을 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_2.png)\n\n또한, 코드의 동작이나 작동 방식을 이해하고 싶은 경우, 설명을 요청할 수 있습니다.\n\n![다른 이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 코드 완성\n\n코딩을 시작하면 Copilot은 파일의 컨텍스트를 분석하고 편집기에서 제안을 제공합니다. 예를 들어, arraySum이라는 메서드 이름을 입력하면 Copilot이 코딩 스타일과 일치하는 구현을 제안합니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_4.png)\n\n# 4. 코드 리팩터링 및 개선\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCopilot에 선택한 코드를 리팩토링하거나 개선할 것을 요청할 수 있습니다. 이는 우리 코드베이스의 맥락을 활용하여 리팩터링이나 개선 사항을 분석하고 제안할 것입니다.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_5.png)\n\n## 5. 수정해주세요\n\n코드에 오류나 경고가 있는 경우, Copilot은 오류 메시지, 코드 구문 및 주변 코드를 기반으로 가능한 수정 사항을 제안할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_6.png)\n\n# 6. 유닛 테스트 케이스 생성\n\nCopilot은 우리의 테스트 프레임워크와 코딩 스타일을 식별하고 오류, 널 값 또는 예기치 않은 입력 데이터 유형을 다루기 위한 테스트 케이스를 제안합니다.\n\n이전 arraySum 함수에 대한 테스트 케이스를 생성해 보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_7.png\" /\u003e\n\n생성된 테스트 케이스:\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_8.png\" /\u003e\n\n# 7. 커밋 메시지 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 커밋 메시지를 작성하기 귀찮다면, Copilot이 우리를 위해 작성해줄 거예요. VS Code에서 커밋 메시지 텍스트 상자 옆의 화문 아이콘을 클릭해보세요.\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_9.png)\n\n# 8. 언어 번역\n\n이제 다른 프로그래밍 언어를 배울 필요가 없어졌어요. Copilot은 선택한 코드를 다른 언어로 번역할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 arraySum JavaScript 함수를 Python으로 번역해 보겠습니다:\n\n![image](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_10.png)\n\n## 9. 이름 바꾸기 제안\n\n코드에서 심볼의 이름을 변경할 때 Copilot은 해당 심볼의 문맥을 기반으로 새 이름을 제안합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전의 arraySum 함수의 이름을 바꾸어 봅시다:\n\n![이미지](/assets/img/2024-06-20-Top10GitHubCopilotFeatures_11.png)\n\n# 10. VSCode Agent\n\n만약 VS Code 기능을 수행하거나 상호 작용할 방법을 찾고 계시다면, Copilot @vscode 에이전트가 원하시는 기능에 대해 자세히 설명하거나 명확히 해주는 데 도움이 될 수 있습니다. 예를 들어, 우리가 기능을 설명하면, Copilot이 VS Code에서 해당하는 기능을 결정하는 데 도움을 줄 것입니다. 파일을 저장할 때 끝에 새로운 라인을 추가하도록 요청해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_12.png\" /\u003e\n\n# 결론\n\n이제 GitHub Copilot의 최고 10가지 기능을 알았으니, 더 행복하고 생산적인 개발자가 되실 수 있습니다.\n\n읽어주셔서 감사합니다. 유용한 정보였기를 바라며, 즐겁게 코딩하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원","ogImage":{"url":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png"},"coverImage":"/assets/img/2024-06-20-Top10GitHubCopilotFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"고급 데이터 구조 및 알고리즘 더미용 신경망","description":"","date":"2024-06-20 01:15","slug":"2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies","content":"\n\n## 자바스크립트에서 첫 번째 신경망 구현하기\n\n![image](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png)\n\n신경망은 매력적이고 흥미로운 것처럼 들립니다. 하지만 정확히 무엇이고, 어떻게 그런 마법을 달성하는 걸까요? 그리고 무엇보다 중요한 건, 전문적인 데이터 과학자가 아니어도 하나를 만들 수 있을까요?\n\n이 기사에서는 신경망의 기본 원리와 기존 도구를 사용하여 직접 구현하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 매우 실용적 일 것입니다. 마지막에 여러분께 자신만의 신경망을 만들어 터미널에서 기본 ASCII 그림을 그리는 방법을 안내해 드리겠습니다.\n\n시작해 봅시다!\n\n## 신경망 이해하기\n\n신경망은 \"뉴런(neurons)\"으로 알려진 개별 요소로 구성된 특수한 유형의 데이터 구조입니다. 뉴런은 레이어로 그룹화되어 있으며 다른 레이어의 다른 뉴런과 연결됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 기본적인 신경망 구조 중 하나는 피드포워드 신경망입니다. 이들은 입력 레이어, 하나 이상의 은닉 레이어 및 출력 레이어로 구성되어 있으며, 정보는 한 방향으로만 흐릅니다 (입력 레이어에서 출력 레이어로).\n\n이것이 무엇을 의미하는지 보여주는 기본 다이어그램이 있습니다:\n\n![다이어그램](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_1.png)\n\n기본적으로 입력 정보는 입력 레이어에 입력되고, 거기서 \"가중치\"라고 불리는 값과 특정 활성화 함수(값을 취하여 0과 1 사이의 값을 출력하는 함수)를 사용하여 데이터가 변환됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 뉴런 그룹을 결합하고 가중치를 적절하게 조정하면 (즉, 네트워크를 \"학습\"할 때 하는 것), 결합된 출력은 제공한 입력에 기초해 기대한 출력(또는 거의 동일한 값)이 됩니다.\n\n예를 들어, XOR 방정식을 해결하는 기본적인 예는 다음과 같습니다:\n\n\n[0,0] =\u003e 0\n[0,1] =\u003e 1\n[1,0] =\u003e 1\n[1,1] =\u003e 0\n\n\n하지만 2개의 입력과 1개의 출력 뉴런을 가진 피드포워드 네트워크를 만들면, 한 번 학습되면 0 또는 1의 모든 조합을 입력하고 실제로 XOR 동작을 프로그래밍하지 않고도 예상한 XOR 출력을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이 왜 신경망을 사용하고 싶어하는지의 주된 이유입니다. 실제로 모든 규칙을 코딩하지 않고도 일반화된 행동을 달성하기 위해서입니다.\n\n## 신경망의 종류\n\n다양한 종류의 신경망이 있으며, 각각의 특징과 용도가 있습니다. 여기에서 모든 종류를 나열하고 그들을 사용하고 구현하는 방법에 대해 깊게 설명하는 것은 이 글의 실용적인 접근을 방해할 수 있습니다.\n\n따라서 가장 흔한 신경망 유형의 목록을 여기에 제시합니다. (다른 유형도 있다는 것을 염두에 두세요):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 피드포워드 신경망: 앞에서 이미 다루었습니다. 이들은 가장 흔하고 간단한 신경망이지만 여전히 유효한 사용 사례가 있습니다.\n- 합성곱 신경망(CNNs): 이미지 인식 및 처리 작업용으로 설계된 신경망입니다. 이미지 데이터에서 특징을 학습하는 데 효과적이며 컴퓨터 비전 응용 프로그램에서 일반적으로 사용됩니다.\n- 순환 신경망(RNNs): 언어 번역이나 음성 인식과 같은 순차 데이터 처리 작업용으로 설계된 신경망입니다. 순차 데이터의 패턴을 학습하는 데 효과적이며 자연어 처리(NLP) 응용 프로그램에서 일반적으로 사용됩니다.\n- 오토인코더: 차원 축소 및 특성 학습 작업용으로 설계된 신경망입니다. 입력 레이어, 은닉 레이어 및 출력 레이어로 구성되어 입력 데이터를 출력 레이어에서 재구성하도록 훈련됩니다.\n- 생성적 적대 신경망(GANs): 가상 데이터 생성용으로 설계된 신경망입니다. 생성자 네트워크가 가상 데이터를 생성하고, 식별자 네트워크가 가상 데이터를 실제 데이터와 구분하려고 합니다.\n- 트랜스포머: NLP 및 텍스트 생성에 매우 효과적입니다. 많은 자연어 처리 작업에 대해 최첨단 결과를 크게 개선했으며 이 분야에서 널리 사용되고 있습니다. 예를 들어, ChatGPT는 훈련 과정에서 이러한 유형의 NN(신경망)을 사용했습니다.\n\n원하는 행동 유형에 따라 하나를 선택합니다. 이 기사에서는 간단하게 유지하고 첫 번째 신경망에 초점을 맞출 것입니다.\n\n읽어주셔서 감사합니다! 제 무료 뉴스레터를 구독해보시겠어요? IT 산업에서 20년 동안의 지혜를 모두가 공유하는 \"The Rambling of an old developer\"에 가입해보세요!\n\n# 첫 번째 신경망 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 우리의 첫 번째 시도이므로 실용적인 방법을 찾고 있기 때문에, 바퀴를 다시 발명할 필요가 없다고 생각해요. 우리가 원하는 것을 달성하는 데 도움이 되는 도구들이 많이 있으니, 우리가 지금 바로 선택하면 돼요.\n\n제 경우에는 저는 Synaptic을 선택했어요. 낮은 수준의 인터페이스를 제공하지만 기본적인 구성 요소는 이미 갖춰져 있어요. 그래서 심층 수학에 신경 쓸 필요없이 NN을 구축하는 데 필요한 요소를 잘 이해할 수 있어요.\n\n우리의 NN을 사용하여 XOR 방정식을 해결하는 대신, 그것을 사용하여 터미널에 ASCII 이미지를 \"그리고\" 싶었어요. 이미지는 상대적으로 작아서 교육 시간을 짧게 유지하려고 해요.\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 그려고 하는 행렬 또는 더 정확히 말하자면, NN에게 그리는 방법을 배우도록 요청하는 것입니다. 그래서 우리가 할 일은 이전과 동일한 3개의 레이어를 가진 NN을 생성할 것입니다:\n\n- X와 Y 좌표를 위한 2개의 뉴런이 있는 입력 레이어.\n- 15개의 뉴런이 있는 은닉 레이어.\n- 그리고 각 좌표 세트마다 1 또는 0을 출력해야 하는지 이해하기 위해 1개의 뉴런만 있는 출력 레이어.\n\n우리는 Synaptic을 사용하여 NN을 다음과 같이 설정할 것입니다.\n\n이제 훈련에 대해, 가중치 간의 학습률을 0.3으로 설정할 것입니다. 이는 뉴런 간의 가중치가 각 반복에서 0.3씩 값을 조정할 것을 의미합니다. 그런 다음 그 결과를 출력해야 하는 것과 비교하고, 다음 반복에서 이에 따라 조정할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상수 이미지에는 내가 원하는 출력이 포함되어 있어요. 이를 사용하여 네트워크를 훈련할 거에요. 0과 1로 이루어진 8x6 매트릭스에요.\n\n그런 다음 훈련을 위해 30,000회의 반복을 실행할 거에요. 매 \"픽셀\"마다 activate 메소드를 호출할 거에요. 이 메소드는 입력을 입력 레이어에 넣고 NN을 실행해요. 그런 다음 propagate 메소드를 사용하여 learningRate와 마지막 활성화값에 대한 예상 값을 사용해 네트워크가 자신을 조정하게 할 거에요.\n\n참고로, \"y * 8 + x\"라는 작은 공식은 직교 좌표를 사용하여 1차원 배열을 탐색하는 작은 속임수에요. 더 자세히 말하면 \"`y 좌표` * `폭` + `x 좌표`\"이고, 2차원 배열이 더 이상 필요하지 않아요.\n\n훈련이 끝나면 좌표를 다시 통과시키고 activate할 차례에요. 이번에는 결과를 출력할 거에요. 그를 위해 다음과 같은 함수를 만들었어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 Y 좌표에 대해 활성화 결과를 리스트에 저장하고, 한 행이 완료되면 (해당 Y에 대한 모든 X 좌표를 거쳤을 때) 출력합니다.\n\n여기서 Math.round를 사용하고 있는 이유는 NN의 출력이 0 또는 1이 아니라 둘 사이의 숫자일 것이기 때문입니다.\n\n결과를 보세요:\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 결과가 완벽하지 않음을 알 수 있어요. 그 이미지에는 2개의 오류가 있다는 걸 주목해주세요. 조금 더 훈련을 시키면 더 나은 결과를 얻을 수 있을지도 모르지만, 이것은 저가 얻은 최상의 결과 중 하나에요.\n\n정확한 알고리즘을 코딩하지 않고도 일반적인 행동을 달성하려고 노력하는 만큼, 항상 올바른 답을 얻을 수 있는 것은 아니며 그 유사한 정도에 그치게 될 거예요.\n\n그래서 Dall-e나 Midjourney로 이미지를 생성할 때 이상한 손이 나타나거나, ChatGPT가 가끔 사실이 아닌 문장을 작성하거나 버그가 있는 코드를 생성하는 이유에 대해 이해할 수 있어요. 그들의 훈련 결과에 기반하여 유사한 정도의 답변을 제시할 뿐이기 때문이에요.\n\n신경망은 입력값의 다양한 수를 적응시켜야 하는 행동을 달성하려는 경우나 특정하게 코딩하는 데 많은 노력이 필요할 때 매우 유용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 대신, 적절한 유형의 입력을 사용하여 훈련을 통해 충분히 가까운 결과를 얻을 수 있어요.\n\n이전에 NN을 사용해 보셨나요? 그것들을 어떤 목적으로 사용했나요?\n\n# 레고처럼 재사용 가능한 구성 요소로 앱을 만들어 보세요\n\n![이미지](/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트의 오픈 소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 만들 수 있게 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고 여러 응용 프로그램 간에 공유하세요. 협업하고 빠르게 개발하기가 더욱 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 간단하게 만들고 원하는 작업 흐름에 대해 최상의 경험을 누리세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png"},"coverImage":"/assets/img/2024-06-20-AdvancedDataStructuresandAlgorithmNeuralNetsforDummies_0.png","tag":["Tech"],"readingTime":6},{"title":"자바스크립트 데이터 유형","description":"","date":"2024-06-20 01:14","slug":"2024-06-20-JavaScriptDataTypes","content":"\n\n이해하기 쉬워요\n\n## JavaScript는 총 여덟 가지의 다른 데이터 유형을 지원합니다. 일곱 가지의 기본 유형과 하나의 비 기본 유형이 있어요.\n\n이러한 데이터 유형을 이해하는 것은 효율적이고 버그 없는 코드를 작성하는 데 중요해요. 이 블로그에서는 각 데이터 유형에 대해 자세히 살펴볼 거에요.\n\n데이터 유형에 대해 계속 진행하기 전에 JavaScript의 console.log() 메서드에 대해 이야기하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`console.log()`은 웹 콘솔에 메시지를 출력하는 JavaScript의 메서드입니다. 일반적으로는 변수의 값이나 표현식의 결과와 같은 정보를 인쇄하기 위해 디버깅 목적으로 사용되며, 이를 통해 개발자들은 코드의 동작을 검사할 수 있습니다.\n\n```js\nconsole.log(\"Hello, world!\"); // 출력: Hello, world!\nconsole.log(42);              // 출력: 42\n\n// 변수 출력\nlet greeting = \"Hello, world!\";\nconsole.log(greeting); // 출력: Hello, world!\n```\n\n- Number\n\nNumber 타입은 정수와 부동 소수점 숫자를 모두 나타냅니다. JavaScript는 두 유형을 구분하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 정수 값\nconst age = 21;\n\n// 부동 소수점 값\nconst temperature = 32.5;\n```\n\n2. 문자열\n\n문자열 유형은 텍스트를 형성하는 문자 시퀀스를 나타냅니다.\n\n```js\n// 문자열 예시\nconst name = \"제 이름은 요기이고 웹 개발자입니다\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 불리언\n\n불리언 유형에는 true 또는 false의 두 가지 값만 있습니다. 일반적으로 조건문에서 사용됩니다.\n\n```js\n// 불리언 예시\n\n// True 저장\nconst isAdmin = true;\n\n// False 저장\nconst isLoggedIn = false;\n```\n\n4. 널\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnull 타입은 의도적으로 어떤 객체 값도 없음을 나타냅니다. 기본적으로 변수를 정의하고 그 때 어떤 값을 추가하고 싶지 않을 때, 그리고 나중에도 해당 변수에 값을 추가하고 싶지 않을 때 사용합니다.\n\n```js\n// Null의 예시\nconst dummy = null;\n```\n\n5. Undefined\n\n값이 할당되지 않은 변수는 undefined 타입입니다. 기본적으로 변수를 선언했지만 아직 값이 할당되지 않은 상태를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Undefined 예제\nlet name;\n```\n\n6. BigInt\n\nBigInt을 사용하면 Number 타입이 처리할 수 있는 정수보다 큰 정수를 표현할 수 있습니다.\n\nNumber에서 BigInt로 변환하려면 값 뒤에 `n`을 추가하기만 하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// BigInt의 예시\nlet Money = 54215484215484212n;\n```\n\n7. Symbol\n\nSymbol은 고유하고 변경할 수 없는 데이터 유형으로서, 객체 속성의 식별자로 사용할 수 있습니다.\n\n여기서 '변경할 수 없는'이란 한 번 선언된 심볼의 값은 변경할 수 없다는 의미이고, '고유한'이란 동일한 값으로 여러 심볼 변수를 만들더라도 각각 메모리에서 고유하다는 의미입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Symbol 예제\nconst Variable_one = Symbol(\"abc\");\nconst Variable_two = Symbol(\"abc\");\n```\n\n위 예제를 보면 변수 one과 two가 심볼 데이터 유형의 동일한 값을 가지고 있는 것처럼 보이지만, 두 변수 간에는 어떤 유사성도 없습니다. 두 변수는 서로 다릅니다.\n\n8. 객체\n\n객체는 속성들의 모음이며, JavaScript에서 유일한 원시 데이터 윕입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서는 객체 키가 객체 내의 특정 속성에 대한 고유 식별자로 작용합니다. 이러한 키는 문자열 또는 숫자가 될 수 있습니다.\n\n일반적으로 문자열은 키로 직접 사용되지만, 숫자는 사용될 때 자동으로 문자열로 변환됩니다.\n\n이 유연성을 통해 객체는 자바스크립트 응용 프로그램 내에서 구조화된 데이터의 저장 및 검색을 용이하게 합니다.\n\n```js\n// 객체 예제\nlet obj = {\n  name: \"yogi parmar\",\n  age: 21,\n  isGood: true,\n  storingNull: null,\n  undefinedPropertu: undefined,\n  1: \"one\",\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 다음 블로그에서는 자바스크립트에서 변수의 기초를 탐구할 것이며, 데이터를 저장하는 용기로서의 역할에 중점을 둘 것입니다.\n게다가, 변수의 이름 짓는 데 대한 최상의 실천법과 관습에 대해 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptDataTypes_0.png","tag":["Tech"],"readingTime":3},{"title":"사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결","description":"","date":"2024-06-20 01:11","slug":"2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png\" /\u003e\n\n우리는 빠르게 움직이는 디지털 시대에 살고 있습니다. 사용자들은 내용에 즉시 접근하길 원하기 때문에 웹 사이트의 성능은 매우 중요합니다. 페이지가 느리게 로딩되면 사용자들은 답답함을 느끼고 잠재적인 고객을 놓칠 수 있습니다. 서버 측 렌더링(SSR)은 서버 측에서 HTML을 생성하여 사용자 경험에 부근을 가져다주는 축복처럼 나타났지만, 핵심적으로 최적화되어야 합니다.\n\n# 속도에 대한 필요성\n\n연구는 항상 느린 페이지가 사용자 참여와 전환율에 심각한 영향을 미친다는 것을 발견해왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 소비자들은 판단을 빨리 내립니다. 연구에 따르면, 88%의 사용자는 나쁜 경험 후 웹사이트로 다시 돌아오기를 더욱 꺼립니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_1.png)\n\n또 다른 연구에 따르면, 모바일 페이지 로드 시간을 0.1초 줄이면 소매 사이트의 전환율이 8.4% 상승하고 여행 사이트의 경우 10.1% 증가했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이거 엄청 커. 그렇기 때문에 웹 성능을 무시할 수 없어요.\n\n# Angelone SSR 아키텍처\n\n우리는 주요 UI 기술 스택으로 Sveltekit과 tailwind css를 선택했어요.\n\n사용자는 3가지 방법으로 웹 앱에 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angelone Android 네이티브 앱\n- Angelone iOS 네이티브 앱\n- 웹 브라우저\n\n네이티브 앱의 경우 웹 앱을 웹뷰 내에서 열고 있습니다.\n\n따라서 앱 내 다양한 부분을 이동할 때 사용자가 연결이 끊어졌다고 느끼지 않도록 성능이 더욱 중요합니다.\n\n# 병목 현상 식별 및 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기의 SSR 슈퍼차징 단계는 성능 제한 요인을 식별하는 것입니다. 이러한 제한 요인은 서버 측과 브라우저 측에서 발생할 수 있습니다.\n\n서버 측 제한 요인:\n\n- 비효율적인 코드 및 데이터 처리: 최적화되지 않은 코드와 비효율적인 알고리즘은 서버가 HTML을 생성하는 데 느릴 수 있습니다. 분석 및 코드 리팩토링을 통해 이러한 문제를 식별하고 해결할 수 있습니다.\n- 비효율적인 캐싱 전략: SSR에서 캐싱은 중요한 역할을 합니다. 올바르게 구성되지 않은 캐시는 불필요한 재랜더링과 지연을 초래할 수 있습니다. 효율적인 캐싱 메커니즘을 구현하면 성능을 크게 향상시킬 수 있습니다.\n- 네트워크 지연: 서버와 사용자 브라우저 간 데이터 전송에 소요되는 시간은 페이지 로드 시간에 큰 영향을 미칠 수 있습니다. 콘텐츠 전달 네트워크(CDN) 및 엣지 서버를 활용하여 콘텐츠를 사용자에게 더 근접하게 배포하고 지연을 줄일 수 있습니다.\n\n브라우저 측 제한 요인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 큰 JavaScript 번들: JavaScript는 상호 작용에 필수적이지만, 큰 번들은 페이지 렌더링을 지연시킬 수 있습니다. 코드 분할과 최소화를 통해 JavaScript 파일의 크기를 줄이고 로드 시간을 개선할 수 있습니다.\n- 최적화되지 않은 DOM 조작: 문서 객체 모델(DOM)의 과도하거나 비효율적인 조작은 성능 문제로 이어질 수 있습니다. DOM 업데이트를 신중히 최적화하면 렌더링 속도를 향상시킬 수 있습니다.\n- 최적화되지 않은 에셋: 큰 이미지, CSS 파일 및 폰트도 페이지 로드 시간을 늦출 수 있습니다. 이러한 에셋을 압축 및 최적화하면 상당한 차이를 만들 수 있습니다.\n\n# 웹 비탈스(Web Vitals)로 성능 모니터링하기\n\nGoogle의 웹 비탈스는 웹 페이지에서 사용자 경험을 측정하고 추적하기 위한 표준화된 메트릭을 제공합니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_4.png\" /\u003e\n\n여기서 페이지 로드 지표는 다음과 같습니다:\n\n- 가장 큰 콘텐츠 페인트 (LCP): 페이지에서 가장 큰 콘텐츠 요소가 보이기 시작하는 데 걸리는 시간을 측정합니다.\n- 첫 번째 콘텐츠 페인트 (FCP): 사용자가 페이지로 처음 이동한 시점부터 화면에 콘텐츠의 일부가 렌더링되기 시작하는 시간을 측정합니다.\n- 첫 번째 바이트까지의 시간 (TTFB): 리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시간을 측정하는 지표입니다.\n\n이러한 지표를 모니터링하면 최적화가 필요한 영역을 식별하고 노력의 영향을 추적할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전문가 도구\n\nSSR 최적화 여정을 돕기 위한 여러 도구들이 있습니다:\n\n- Lighthouse: 웹 사이트 성능, 접근성 등에 대한 포괄적인 통찰을 제공하는 구글의 오픈소스 도구입니다.\n- PageSpeed Insights: 페이지 속도 분석과 최적화 제안을 제공하는 또 다른 구글 도구입니다.\n- WebPageTest: 다양한 조건 하에서 웹 사이트 성능을 측정하는 강력한 도구입니다.\n- 실제 사용자 모니터링(RUM) 데이터: 실제 사용자들이 웹 사이트를 경험하는 방식에 대한 데이터를 수집하여 소중한 현실 세계의 통찰을 제공합니다.\n\n# 최적화 전략\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSR 페이지를 업그레이드하기 위한 주요 최적화 전략 몇 가지를 소개해 드릴게요:\n\n캐싱에 대해 언급할 때, 세 가지 방법으로 구현할 수 있어요\n\n- 단기 - 몇 분\n- 중기 - 몇 시간\n- 장기 - 몇 일\n\n우리는 초기 페이지 렌더링에 필요한 API 목록을 식별했고, 자주 변경되지 않는 데이터에 대한 단기 메모리 API 캐싱을 구현했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 마크다운 형식으로 변경한 내용입니다.\n\n\n![Image 1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_5.png)\n\n우리가 이 변경 사항을 배포한 후에는 Backend API에 대한 히트가 급격히 감소했습니다.\n\n![Image 2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_6.png)\n\n이는 이제 Backend 서버가 다른 중요 사항에 더 많은 시간을 할애하고 더 적은 부하로 인해 더 빠르고 지연 시간이 낮아질 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 프런트엔드 서버와 백엔드 서버는 같은 가상 사설 클라우드(VPC) 안에 있어요. 이 설정을 활용해서 백엔드 API의 내부 엔드포인트를 호출하기 시작했어요.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_7.png)\n\n장점:\n- 성능: 내부 API는 외부 엔드포인트를 통과하는 것보다 더 빠를 수 있어요.\n- 신뢰성: 내부 API는 덜 고장이 날 가능성이 높기 때문에 믿을 만해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 즉시 볼 수 있는 콘텐츠 렌더링을 우선시하세요.\n\n![image](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_8.png)\n\n혜택:\n\n- html, javascript 및 이미지를 포함한 데이터 양을 줄여 데이터 전송 양을 줄임\n- 즉 브라우저가 더 적은 작업을 해야 하므로 콘텐츠를 보다 빠르게 렌더링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로딩 프로세스 중에 필수 리소스를 미리 가져오세요.\n\n이렇게 하면 스타일이 적용되지 않은 텍스트(Flash of unstyled text, FOUT)가 방지됩니다.\n\n![image1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_9.png)\n\n![image2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPre-connect은 페이지 상단 콘텐츠가 제 3자 또는 CDN 네트워크에서 에셋이나 이미지를 필요로 하는 경우에 유용합니다.\n\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_11.png)\n\n\nPre-connect를 사용하지 않으면 브라우저는 우선 콘텐츠를 다운로드한 후, 다른 출처에 대한 에셋에 따라 특정 콘텐츠를 찾으면, 먼저 제 3자와 연결을 시도한 뒤 연결이 확립되면 콘텐츠를 다운로드하므로 중요한 시간이 소비됩니다.\n\nPre-connect를 사용하면 브라우저는 우선 콘텐츠를 다운로드하는 동안 제 3자와 연결을 설정하고 필요한 다운로드가 즉시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n폰트는 두 가지 방법으로 사용할 수 있어요.\n\n- 구글 폰트, 폰트 어썸 등과 같은 타사 서비스 사용\n- 폰트 자체 호스팅\n\n데이터에 따르면 웹 페이지의 20%만이 자체 호스팅된 폰트를 사용하는데, 나머지는 자체 호스팅 + 타사 혹은 단독으로 타사 폰트를 사용하고 있어요.\n\n이전에는 브라우저의 공유 캐시 때문에 타사 폰트를 사용하는 것에 성능상의 이점이 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 Chrome 버전 85부터 Chrome 팀이 캐시 파티션을 도입했는데, 이는 한 웹사이트의 캐시된 리소스를 다른 웹사이트가 사용할 수 없다는 뜻입니다. 따라서 성능 상의 이점이 없어졌습니다.\n\n이에 더해, 써드파티 원본과의 사전 연결(pre-connect)에 대한 추가적인 부담이 있습니다. 이는 고가 소요됩니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_12.png)\n\n하지만 자체 호스팅 폰트를 사용하면 도전이 발생합니다. 모든 자체 호스팅 폰트의 제 75 백분위수 크기는 75KB로 매우 큽니다. 이는 폰트가 많은 언어와 문자를 포함하기 때문인데, 대부분의 경우 사이트에서 실제로 필요하지 않은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 온라인으로 글꼴을 다운로드 받아서 (크기는 63kb였습니다) 모든 불필요한 문자를 제거하여 글꼴 크기를 7.2kb로 줄였어요. 이는 Yellow Lab 도구의 도움으로 88% 감소했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_13.png)\n\n# 최적화의 영향\n\n다행히도, SSR을 최대한 최적화하는 투자는 매우 좋은 수확을 낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔젤 원을 예로 들어보면, FCP 숫자를 1500ms 대신 1230ms로 개선했더니 전환율이 최대 30%까지 상승했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_14.png)\n\n작은 개선조치라도 비즈니스 결과로 이어질 수 있는 좋은 예시입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 서버 측 렌더링의 최적화는 현대 웹에서 모두에게 이상적인 경험을 제공하기 위해 반드시 해야 합니다.\n\n성능 병목 현상을 최적화하고 웹 핵심 지표를 모니터링하며 적절한 최적화 전략을 활용하면 SSR 페이지를 빠르게 만들어 사용자 참여도를 높이고 전환율을 높이는데 도움이 됩니다.\n\nhttps://www.youtube.com/watch?v=xUMgwaKkDg4\u0026ab_channel=DeveloperSummit","ogImage":{"url":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png"},"coverImage":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png","tag":["Tech"],"readingTime":7},{"title":"시스템 디자인 면접 아마존 플립카트","description":"","date":"2024-06-20 01:08","slug":"2024-06-20-SystemDesignInterviewAmazonFlipkart","content":"\n\n## 다루는 주제:\n\n- 아키텍처는 홈/검색 플로우, 추천 시스템, 주문 관리 및 재고 서비스와 같은 구성 요소를 포함합니다.\n- 비구조화된 데이터에는 MongoDB, 검색에는 Elasticsearch, 주문 트랜잭션에는 MySQL, 완료된 주문에는 카산드라와 같은 데이터베이스의 사용이 강조됩니다. Kafka와 Spark는 실시간 데이터 처리 및 분석에 사용됩니다.\n\n# 전자 상거래 시스템 아키텍처\n\n- 우버나 에어비앤비의 백엔드와 마찬가지로 아마존 및 기타 전자 상거래 플랫폼도 시스템에 대한 두 가지 면을 갖고 있습니다.\n- 아마존의 고객인 경우, 아마존의 자체 격리된 스토어를 통해 제품을 판매하거나 다른 판매자들이 제공하는 제품을 구매할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기능 요구 사항\n\n- 판매자 작업: 판매자는 제품을 추가, 삭제 및 수정할 수 있습니다.\n- 제품 카탈로그: 구매자가 제품을 이름, 키워드 또는 카테고리로 검색할 수 있는 포괄적인 카탈로그입니다.\n- 장바구니: 구매자는 장바구니에 제품을 추가, 삭제 또는 업데이트할 수 있습니다.\n- 주문 처리: 구매자는 제품을 구매하고 결제할 수 있습니다.\n- 주문 내역: 구매자는 이전 주문 내역을 확인할 수 있습니다.\n- 리뷰 및 평점: 구매자는 제품을 리뷰하고 평가할 수 있습니다.\n\n## 비기능 요구 사항\n\n- 높은 가용성: 시스템은 연중무휴로 운영되어야 합니다.\n- 높은 일관성: 시스템 전체의 정확한 데이터를 보장하며 특히 재고 및 거래에 대해 정확성을 유지해야 합니다.\n- 낮은 지연 시간: 원활한 사용자 경험을 위해 빠른 응답 시간이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 말한 것과 같이, Markdown 형식의 표로 변경해 보겣습니다:\n\n| Component              | Priority        | Description                                                                                  |\n|------------------------|-----------------|----------------------------------------------------------------------------------------------|\n| Payment service        | High            | Highly consistent                                                                            |\n| Inventory management   | High            | Highly consistent                                                                            |\n| Search service         | High            | Highly available and low latency, eventually consistent                                      |\n| Availability           | Low             | Low priority                                                                                 |\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자/구매자는 전자 상거래 웹 사이트를 방문하여 홈페이지에 도착할 것입니다.\n- 홈페이지는 추천 서비스에 의해 구동됩니다. 사용자가 무언가를 검색하면 시스템의 검색 서비스를 호출할 것입니다.\n- 고객이 검색을 완료하고 주문을 하려고 하면 주문 배치 아키텍처가 처리할 것입니다.\n- 시스템의 구매 단의 설계를 간단하게하기 위해 홈페이지/검색 아키텍처와 주문 배치 아키텍처를 따로 논의할 것입니다.\n\n## 홈 화면 및 검색 페이지\n\n우리가 제공할 두 가지 UI가 있을 것입니다.\n\n- 홈 화면에는 몇 가지 추천 사항이 있을 것입니다. 반환 사용자인지 새 사용자인지에 따라 개인화된 추천이거나 일반 추천일 수 있습니다.\n- 검색 페이지에서 사용자는 일부 검색 텍스트를 기반으로 결과를 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png)\n\n![이미지2](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_1.png)\n\n우리 시스템의 소비자 중 하나는 상품 서비스입니다\n\n## 상품 서비스\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Item 서비스는 Kafka를 청취하여 새 항목을 추가하고 업데이트하고 가져오는 API를 노출합니다.\n- 이 서비스는 해당 항목 관련 데이터가 비구조적이기 때문에 MongoDB에 위치합니다.\n- \"비구조적\"이라는 의미는 다양한 유형의 항목이 서로 다른 속성을 가질 것이라는 것입니다. 예를 들어, 셔츠에는 사이즈, 원단, 색상 속성이 있고, TV에는 화면 크기, 색상 기술, 무게, 해상도 등의 속성이 있을 수 있습니다.\n\n새 항목이 온보딩되자마자,\n\n- 검색 소비자는 해당 항목이 사용자에 의해 쿼리될 수 있도록 확인합니다. 새 항목을 읽고 처리하여 데이터베이스에 저장될 수 있도록 형식화하고 검색 시스템이 이해할 수 있도록합니다.\n- 형식화가 완료되면 검색 소비자는 이 데이터를 ElasticSearch 데이터베이스에 넣습니다.\n- 여기서 텍스트 기반 검색에 매우 효율적이고 원활한 사용자 경험을 위해 필요한 유사 검색을 지원하는 ElasticSearch를 사용합니다.\n\n이제 Search 서비스,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 ElasticSearch와 상호 작용하면 제품을 필터링, 정렬, 검색하는 API가 노출됩니다.\n- 기능 요구 사항에서 '배송 예상 시간으로 검색'을 언급했습니다. 이를 확장하여 사용자에게 전달할 수 없는 검색 결과를 표시하지 말아야 한다는 요구 사항으로 확장할 수 있습니다. 그렇지 않으면 사용자 경험이 좋지 않을 것입니다.\n- 이를 위해 검색 서비스는 Serviceability 및 TAT 서비스라는 것과 대화할 것입니다. Serviceability 및 TAT 서비스는 제품이 배송될 창고를 확인하고, 창고와 사용자의 우편번호 사이에 경로가 있는지, 그리고 그 경로를 통해 이 제품을 운반할 수 있는지를 확인합니다. 또한, 대략적인 배송 일정을 파악하고 이 모든 정보를 검색 서비스에 전달합니다. 검색 서비스는 이 정보를 사용자에게 추가로 전달할 것입니다.\n\n## 사용자 검색이 생성되는 방법\n\n- 이 검색 결과 또는 추천은 앞서 논의한 전자 상거래 애플리케이션의 다른 공급 업체, 상점 또는 판매자에 의해 생성됩니다.\n- 다이어그램의 가장 오른쪽에 상자로 표시된 판매 끝 부분을 찾을 수 있습니다.\n- 실제로, 판매 끝 부분 자체가 일련의 마이크로서비스로 완성된 아키텍처입니다.\n- 판매 끝 부분은 모든 상점에서 데이터를 가지고 있습니다.\n- 새로운 상점이 시스템에 합류하거나 기존 상점이 재고에 새 제품을 추가할 때마다 Kafka 대기열이 해당 이벤트를 가져올 것입니다.\n- Kafka 대기열에서 데이터를 읽는 일련의 Kafka 소비자가 이러한 데이터 변경 사항을 가져와서 Amazon 검색 페이지의 검색 결과를 제어하는 ElasticSearch에 통합할 것입니다.\n\n## 찜 목록 및 카트 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 검색 결과가 표시된 후 사용자는 서로 다른 제품의 속성을 확인하고 비교할 수 있습니다.\n- 다음으로, 사용자는 무언가를 선택하고 '위시리스트'나 '장바구니'에 추가할 수 있습니다. '위시리스트'에 추가하면 위시리스트 서비스가 호출되어 해당 항목을 위시리스트 MySQL 데이터베이스에 추가합니다.\n- 사용자가 항목을 장바구니에 추가하면 카트 서비스를 통해 카트 MySQL 데이터베이스에 저장됩니다.\n- 위시리스트와 장바구니에는 따로 데이터베이스를 사용하는 것이 타당합니다. 위시리스트는 장바구니에 있는 객체보다 훨씬 긴 기간 동안 저장될 수 있기 때문입니다.\n\n중요한 점을 다시 이해하세요,\n\n- 검색 화면에서 사용자는 제품을 위시리스트에 추가하거나 장바구니에 넣을 수 있어야 합니다. 이는 위시리스트 서비스와 카트 서비스를 통해 이루어집니다.\n- 위시리스트 서비스는 우리 시스템의 모든 위시리스트 저장소이고, 카트 서비스는 모든 장바구니 저장소입니다.\n- 이 두 서비스는 서로 완전히 동일한 방식으로 구축될 것이며, 각각 위시리스트나 장바구니에서 항목을 가져오고 업데이트하고 추가 또는 삭제할 API를 제공하며, 둘 다 MySQL DB에 저장될 것입니다.\n- 이들은 동일한 하드웨어 위에서 구축될 수 있지만, 특히 할인이 다가올 때 위시리스트가 매우 길어지는 경향이 있기 때문에 이 서비스들을 위한 별도의 하드웨어를 사용하는 것이 좋습니다. 이렇게 하면 각 서비스에 대한 하드웨어 확장이 훨씬 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자의 검색, 장바구니 및 위시리스트 항목은 추천 서비스를 지원하는 중요한 자원입니다.\n- 이러한 이벤트들은 사용자의 관심을 반영하며 해당 사용자에 맞는 추천을 만드는 데 활용될 수 있습니다.\n- 위 다이어그램에서 확인할 수 있듯이, 검색 서비스, 장바구니 서비스 및 위시리스트 서비스는 모두 발생하는 이벤트를 카프카 큐로 보내고 있습니다.\n- Spark Streaming 소비자는 실시간으로 카프카에서 읽어와 하둡 클러스터에 저장할 보고서를 생성하여 분석 목적으로 사용됩니다. 사용자가 가장 많이 검색하거나 위시리스트에 추가한 항목과 같은 특정 분석을 통해 이 사용자에게 추천을 생성할 수 있습니다.\n\n중요한 점을 다시 이해하면,\n\n- 우리의 카프카 서비스는 최근 시간 단위나 일별로 가장 인기 있는 제품, 가장 원하는 항목, 가장 많은 주문이 발생한 지역, 수익을 최대화하는 범주 등과 같은 실시간 보고서를 생성할 스파크 스트리밍 소비자에 연결될 것입니다.\n- 카프카에서 제공된 모든 이 데이터는 일반적인 추천을 제공할 수 있도록 ALS와 같은 표준 알고리즘을 실행할 수 있는 하둡 클러스터에 저장될 것입니다. 과거 구매 내역을 기반으로 사용자가 다음에 구매할 필요가 있는 제품을 식별하고 그에 따라 우리는 그들을 위해 개인 맞춤형 추천을 생성할 수 있습니다.\n- 또한 다른 비슷한 사용자가 검색한, 위시리스트에 추가한 또는 구매한 제품들에 대해 알려줄 것이며, 이를 특정 사용자에 대한 추천에 추가할 수 있습니다.\n- 이러한 추천이 생성되면 스파크 클러스터가 추천 서비스와 대화하는데, 이것은 시스템의 모든 추천을 포함하고 일반적인 추천 또는 제품 범주에 기반한 특정 사용자 ID에 대한 추천일 수 있습니다.\n- 이렇게 하면 사용자들은 홈페이지에서 일반적인 추천을 볼 수 있지만, 특정 제품 범주를 탐색 중인 경우 추천이 필터링될 것입니다.\n\n## 사용자 위치 데이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시스템은 사용자 데이터도 저장합니다.\n- 사용자 위치 정보를 통해 시스템이 특정 제품을 사용자에게 배달할 수 있는지 여부를 결정할 수 있습니다.\n- 예를 들어, 생활 필수품인 냉동식품의 배송이 원격 지역에서 제한될 수 있습니다.\n- 이러한 항목들은 추천 또는 검색 결과에 나타나지 않습니다.\n- 이는 추천 서비스와 검색 서비스가 사용자 데이터를 필요로 하여 사용자에게 특화된 결과를 생성해야 함을 의미합니다.\n- 이 서비스들은 초기에 REDIS와 통신합니다.\n- 사용자 데이터가 그곳에 저장되어 있으면, 이를 직접 서비스로 보냅니다. 캐시에 없다면 REDIS는 데이터베이스에서 정보를 불러와 서비스로 전달합니다.\n\n다시 한 번 중요한 점을 이해하세요,\n\n- 사용자 서비스는 모든 사용자의 저장소이며 시스템에서 사용자를 가져오거나 업데이트, 추가, 삭제하기 위한 API도 제공합니다.\n- 해당 서비스는 MySQL 데이터베이스에 위치하며 Redis 캐시를 유지합니다.\n- 따라서 검색 서비스가 서비스 가능성 서비스에 통신하기 위해 사용자의 우편번호를 가져오려면, 사용자 서비스는 먼저 Redis에서 확인하고, 정보가 없다면 MySQL 데이터베이스에서 조회하여 사용자 정보를 가져와 Redis에 저장하고, 그 정보를 검색 서비스에 반환합니다.\n\n## 창고 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 창고 서비스는 다양한 상점을 위해 창고에 있는 모든 제품에 대한 인덱스를 유지합니다.\n- 이 정보는 검색 서비스에 의해 가져와서 제품이 현재 사용 가능한지 여부를 표시하는 데 사용됩니다.\n\n# 구매 및 체크아웃 흐름\n\n![이미지](/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_2.png)\n\n- 사용자가 주문을 배치하려고 할 때, 요청은 대규모 주문 관리 시스템의 일부인 주문 수신 서비스로 이동합니다.\n- 주문 관리 시스템은 MySQL 데이터베이스에 있습니다. 우리는 고객 테이블, 제품 테이블, 주문 테이블 등 여러 테이블을 예상대로 가지고 있으며, 이러한 테이블을 통해 다양한 거래가 진행됩니다.\n- 이제 우리는 데이터베이스가 변화를 즉시 반영하지 못해 창고에서 최신 AirPods의 마지막 제품을 두 명의 사용자가 주문할 수 없도록 하고 싶습니다. 이것은 관계형 데이터베이스의 ACID 특성이 필요하므로 MySQL이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 수신 서비스가 호출되면,\n\n- Redis에 주문 ID, 주문이 만들어진 날짜 및 시간, 주문 ID의 만료 시간이 포함된 레코드가 생성됩니다.\n- 이러한 세부 정보와 함께 해당 주문 ID에 대한 상태도 있을 것입니다. 일단이 상태는 \"생성됨\"이라고 가정합니다.\n- 다음 단계는 재고 서비스를 호출하는 것입니다. 예를 들어, 주문이 생성되기 전에 5개의 소니 65인치 스마트 TV가 재고에 있었습니다.\n- 주문을 배치한 후, 제품의 재고 수는 4로 감소하며, 이후에 사용자가 결제 페이지로 리디렉션됩니다.\n- 그러나 왜 결제가 완료되기 전에 재고를 업데이트하는 걸까요? 만약 5대가 아닌 1대만 재고가 있고 3명이 구매를 시도한다면 어떨까요? 결제 흐름으로 이동하기 전에 재고 수를 줄이면, 3명 중 2명은 상품이 이미 품절되었음을 알게 되어 결제 페이지로 이동하기 전에 흐름이 종료될 것입니다.\n- 이 제약 조건을 유지하여 재고 수가 음수가되면 주문을 배치할 수 없도록 충분히 쉽게 구현할 수 있습니다.\n\n# 서로 다른 서비스가 사용하는 데이터베이스:\n\n전형적인 전자 상거래 아키텍처에서 각 서비스가 사용하는 데이터베이스를 분석하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 제품 카탈로그\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL) 또는 NoSQL 데이터베이스 (예: MongoDB)\n- 목적: 제품의 이름, 설명, 가격, 이미지 및 속성과 같은 상세 정보를 저장합니다.\n- 참조: 제품 세부 정보를 빠르게 검색하고 확장성을 다루기 위해 사용됩니다 (Java Challengers) (CodeKarle).\n\n## 2. 사용자 관리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL) 및 캐싱 레이어 (예: Redis)\n- 목적: 사용자 계정, 인증 및 권한을 관리합니다. 사용자 정보, 예를 들어 이름, 주소 및 결제 방법을 저장합니다.\n- 참조: 관계형 데이터베이스는 ACID 속성을 유지하기 위해 사용되고, Redis는 성능을 향상시키기 위해 캐싱에 사용됩니다 (CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 쇼핑 카트 및 위시리스트\n\n- 데이터베이스: 예를 들어 MySQL과 같은 관계형 데이터베이스(영속성을 위해); 캐싱을 위해 Redis 사용\n- 목적: 쇼핑 카트와 위시리스트에 추가된 항목을 관리합니다. 항목을 가져오거나 업데이트하고, 추가하거나 삭제하는 API를 제공합니다.\n- 참고: 관계형 데이터베이스는 카트와 위시리스트 데이터의 일관성과 신뢰성을 보장하며, Redis는 빠른 액세스와 확장성에 도움이 됩니다. (CodeKarle).\n\n## 4. 주문 처리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL)\n- 목적: 항목 가용성을 확인하고, 트랜잭션을 처리하며, 재고를 업데이트하고, 주문 세부 정보를 저장합니다.\n- 참고: 관계형 데이터베이스 사용은 트랜잭션을 처리하고 주문 프로세스 중 데이터 무결성을 유지하는 데 중요한 ACID 속성을 보장합니다 (CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 결제 게이트웨이\n\n- 데이터베이스: 외부 결제 제공업체에 의존하기 때문에 특정 데이터베이스 명시되지 않음.\n- 목적: 외부 결제 제공업체와 통신하여 안전한 결제 처리를 담당.\n- 참조: 데이터베이스 관리보다는 안전한 통신에 더 초점을 둠.\n\n## 6. 재고 관리\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL)\n- 목적: 제품 가용성을 추적하고 주문에 따라 재고를 업데이트.\n- 참조: 재고 수준을 정확하고 일관되게 추적함(CodeKarle).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 검색 기능\n\n- 데이터베이스: 검색 엔진 플랫폼 (예: Elasticsearch)\n- 목적: 빠르고 정확한 검색 결과 제공.\n- 참조: Elasticsearch는 효율적인 검색과 검색 결과를 제공하기 위해 설계되었으며, 이는 전자 상거래 플랫폼(Java Challengers)에 적합합니다.\n\n## 8. 리뷰 및 평점\n\n- 데이터베이스: 관계형 데이터베이스 (예: MySQL, PostgreSQL)\n- 목적: 제품에 대한 사용자 리뷰 및 평점을 저장합니다.\n- 참조: 리뷰와 평점이 일관되고 신뢰할 수 있게 저장 및 검색되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 9. 추천 시스템\n\n- 데이터베이스: NoSQL 데이터베이스 (예: Cassandra, HBase) 및 데이터 처리를 위한 Hadoop\n- 목적: 사용자의 행동 및 선호도에 기반한 맞춤형 추천 제공\n- 참고: NoSQL 데이터베이스와 Hadoop은 확장성 및 대규모 데이터셋을 효율적으로 처리할 수 있는 능력 때문에 사용됨 (CodeKarle).\n\n## 10. 분석 및 모니터링\n\n- 데이터베이스: 데이터 웨어하우스 (예: Amazon Redshift, Google BigQuery) 및 대규모 데이터 처리를 위한 Hadoop\n- 목적: 사용자 상호작용, 매출 및 시스템 성능에 대한 데이터 수집 및 분석\n- 참고: 데이터 웨어하우스와 Hadoop은 대용량 데이터를 처리하고 복잡한 분석 쿼리를 수행하기에 적합함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 11. 캐싱과 콘텐츠 전달\n\n- 데이터베이스: 콘텐츠 전달 네트워크(CDN) 및 캐싱 레이어 (예: Redis, Memcached)\n- 목적: 정적 콘텐츠를 캐싱하여 성능을 향상시키고 웹 서버 부하를 줄임.\n- 참고: CDN 및 캐싱 레이어는 자주 요청되는 데이터에 빠르게 접근하여 사용자 경험을 향상시킴.\n\n## 참고,\n\n- https://www.systemdesignnotes.com/amazon-ecommerce-design\n- https://www.codekarle.com/system-design/Amazon-system-design.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전자 상거래 응용프로그램의 판매자용 아키텍처\n\n- 자세한 내용은 [이 기사](https://medium.com/double-pointer/system-design-interview-amazon-flipkart-ebay-or-similar-e-commerce-applications-35a0bc764421)를 확인해주세요!","ogImage":{"url":"/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png"},"coverImage":"/assets/img/2024-06-20-SystemDesignInterviewAmazonFlipkart_0.png","tag":["Tech"],"readingTime":10},{"title":"HTML, CSS, 그리고 JavaScript로 날씨 예보 애플리케이션 만들기 단계별 안내","description":"","date":"2024-06-20 01:06","slug":"2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png)\n\n- 소개\n- 프로젝트 개요\n- 요구 사양\n- 날씨 예보 어플리케이션의 기능\n- 코드 구조\n  - 단계 1. HTML 구조:\n  - 단계 2. CSS 스타일링:\n  - 단계 3. JavaScript 로직:\n- 테스트와 디버깅\n- 배운 점\n- 배포\n- 어플리케이션 사용 방법 안내\n- 향후 개선 사항\n- 결론\n\n# 소개\n\n이 안내서는 HTML, CSS 및 JavaScript를 사용하여 상호작용하는 날씨 예보 어플리케이션을 만드는 과정을 안내합니다. 사용자는 전 세계 어느 곳이든 현재 날씨 상황 및 예보에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 개요\n\n날씨 예보 앱은 간단하고 사용자 친화적인 인터페이스를 갖추고 있습니다. 사용자는 검색 창에 위치를 입력할 수 있고, 앱은 해당 지역의 현재 날씨 상황을 보여줍니다. 저는 사용자의 위치 입력을 기반으로 날씨 정보를 가져오기 위해 OpenWeather API를 사용했습니다. 앱은 온도, 습도, 풍속, 현재 상황을 보여주는 날씨 아이콘 및 검색된 위치의 배경 이미지와 같은 추가 정보도 제공합니다.\n\n# 준비물\n\n이 날씨 예보 애플리케이션을 만들기 위해서는 HTML, CSS 및 JavaScript에 대한 기본적인 이해가 필요합니다. 애플리케이션을 구성하기 위해 HTML에 익숙해야하며, 스타일링을 위해 CSS를 사용하고 애플리케이션의 로직을 구현하기 위해 JavaScript를 사용할 수 있어야합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 작성하는 데는 텍스트 편집기 또는 IDE(예: Visual Studio Code)가 필요하며, 테스트를 위해 웹 브라우저가 필요합니다. 선택 사항으로는 애플리케이션을 호스팅하기 위한 GitHub 계정이 필요합니다.\n\n# Weather Forecast Application의 기능\n\n이 프로젝트에서는 다음과 같은 기능이 있는 날씨 예보 앱을 만듭니다:\n\n- 위치 기반 날씨: 사용자는 위치(도시)를 입력하여 해당 지역의 현재 날씨 상황 및 예보를 볼 수 있습니다.\n- 현재 날씨 표시: 애플리케이션은 현재 온도, 날씨 상황(예: 맑음, 비, 흐림), 습도, 풍속 및 가시성을 보여줍니다.\n- 날씨 아이콘: 날씨 조건을 시각적으로 이해하기 쉽게 나타내기 위해 날씨 아이콘(예: 태양, 구름, 비)을 사용합니다.\n- 반응형 디자인: 애플리케이션이 다양한 기기 및 화면 크기에서 잘 작동하고 반응형임을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 구조\n\n프로젝트용 새 폴더를 생성하고, 폴더의 이름을 원하는 대로 지은 다음, 그 안에 index.html, style.css, script.js 세 개의 파일을 만듭니다. 이 파일들은 프로젝트의 기반으로 사용될 것입니다. 이제 텍스트 편집기나 IDE (예: Visual Studio Code)에서 폴더를 열고 아래 단계를 따릅니다:\n\n## 단계 1. HTML 구조:\n\nindex.html 파일을 열고, 날씨 예보 애플리케이션을 위한 다음 HTML 코드를 붙여넣으세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 HTML 코드는 검색 바와 날씨 정보 표시를 갖춘 날씨 애플리케이션 인터페이스를 설정합니다. 입력, 버튼, 도시 이름, 온도, 날씨 아이콘, 설명, 습도 및 풍속을 위한 요소가 포함되어 있습니다.\n\n디자인은 특정 도시에 대한 검색 기능과 날씨 세부 정보가 있는 카드 레이아웃을 특징으로 합니다. 외부 CSS 파일 및 JavaScript 파일에 대한 링크도 포함되어 있습니다.\n\n## 단계 2. CSS 스타일링:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstyle.css 파일을 열어 날씨 예보 애플리케이션을 스타일링하는 다음 CSS 코드를 붙여넣어주세요:\n\n```css\nbody {\n display: flex;\n justify-content: center;\n align-items: center;\n height: 100vh;\n background: darkgrey;\n margin: 0;\n font-size: 120%;\n background-image: url(\"https://source.unsplash.com/1600x900/?nature,landscape\");\n font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;\n} \n\n.card {\n background-color: black;\n padding: 2em;\n color: white;\n border-radius: 30px;\n width: 100%;\n max-width: 420px;\n margin: 1em;\n box-shadow: 1px 3px 5px rgba(141, 138, 138, 0.1);\n}\n\n.search {\n display: flex;\n align-items: center;\n justify-content: center;\n}\n\ninput.search-bar {\n border: none;\n outline: none;\n padding: 0.4em 1em;\n border-radius: 30px;\n background-color: #534b4b;\n color: white;\n font-size: 120%;\n width: calc(100% - 100px);\n font-family: 'Roboto';\n letter-spacing: 2px;\n}\n\nbutton {\n margin: 0.5em;\n border-radius: 50%;\n border: none;\n height: 3em;\n width: 3em;\n outline: none;\n background-color: #534b4b;\n color: white;\n cursor: pointer;\n transition: 0.3s ease-in-out;\n}\n\nbutton:hover {\n background-color: #9b7979;\n}\n\n.weather {\n font-weight: bold;\n}\n\n.weather.loading {\n visibility: hidden;\n max-height: 20px;\n position: relative;\n}\n\n.weather.loading::after {\n position: absolute;\n top: 0;\n color: white;\n visibility: visible;\n content: \"Page Loading...\";\n font-weight: bold;\n left: 30px;\n}\n\nh1.city {\n letter-spacing: 2px;\n text-transform: uppercase;\n font-size: 1.3em;\n}\n\nh1.temp {\n margin: 0;\n margin-bottom: 0.5em;\n font-size: 1.3em;\n}\n\n.flex {\n display: flex;\n align-items: center;\n margin-left: -10px;\n margin-bottom: 0.5em;\n}\n\n.flex .description {\n text-transform: capitalize;\n margin-left: 8px;\n}\n\n.humidity {\n font-size: 1.2em;\n margin-bottom: 0.5em;\n}\n\n@media screen and (max-width: 420px) {\n .card {\n   border-radius: 35px;\n   max-width: 320px;\n  }\n\n input.search-bar {\n  padding: 0.3em 0.8em;\n  border-radius: 30px;\n  background-color: #534b4b;\n  color: white;\n  width: calc(100% - 100px);\n  letter-spacing: 1px;\n }\n}\n```\n\n상기 CSS 코드는 중앙 정렬 레이아웃, 어두운 회색 배경, Unsplash의 배경 이미지를 사용하는 스타일링된 날씨 애플리케이션을 정의합니다. 정렬을 위해 flexbox를 사용하고, 검은색 배경과 흰색 텍스트로 카드 스타일을 설정하며, 입력과 버튼 요소를 스타일링합니다. 로딩 애니메이션은 기본적으로 숨겨져 있으며 활성화될 때 메시지를 표시합니다. 미디어 쿼리는 작은 화면에 맞게 스타일을 조정합니다.\n\n## 단계 3. 자바스크립트 로직:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nthescript.js 파일을 열고 다음 JavaScript 코드를 사용하여 Weather forecast 어플리케이션에 기능을 추가하세요:\n\n```js\nlet cityEl = document.querySelector(\".city\");\n\nlet iconEl = document.querySelector(\".icon\");\n\nlet descriptionEl = document.querySelector(\".description\");\n\nlet temperatureEl = document.querySelector(\".temp\");\n\nlet humidityEl = document.querySelector(\".humidity\");\n\nlet windEl = document.querySelector(\".wind\");\n\nlet searchBar = document.querySelector(\".search-bar\");\n\nlet searchEl = document.querySelector(\".search button\");\n\nlet weatherEl = document.querySelector(\".weather\");\n\nlet weather = {\n \"apikey\": \"a6f6fef1470f473cb0694459230605\",\n\n fetchWeather: function (city) {\n  fetch(\"http://api.weatherapi.com/v1/current.json?key=a6f6fef1470f473cb0694459230605%20\u0026q=\" + city + \"\u0026aqi=no\").then((response) =\u003e response.json()).then((data) =\u003e this.displayWeather(data));\n },\n\n displayWeather: function (data) {\n  const { name } = data.location;\n\n  const { icon, text } = data.current.condition;\n\n  const { temp_c, humidity } = data.current;\n\n  const { wind_kph } = data.current;\n\n  cityEl.innerText = `Weather in ${name}`;\n\n  iconEl.src = icon;\n\n  descriptionEl.innerText = text;\n\n  temperatureEl.innerText = `Temperature: ${temp_c}°C`;\n\n  humidityEl.innerText = `Humidity: ${humidity}%`;\n\n  windEl.innerText = `Wind Speed: ${wind_kph} km/hr`;\n\n  weatherEl.classList.remove(\"loading\");\n\n  document.body.style.backgroundImage = \"url('https://source.unsplash.com/1600x900/?\" + name + \"')\";\n },\n\n search: function () {\n  this.fetchWeather(searchBar.value);\n }\n};\n\nsearchEl.addEventListener(\"click\", () =\u003e {\n console.log(\"Clicked!\");\n weather.search();\n});\n\nsearchBar.addEventListener(\"keyup\", (event) =\u003e {\n if (event.key === \"Enter\") {\n  weather.search();\n }\n});\n\nweather.fetchWeather(\"Lagos\");\n```\n\n위의 JavaScript 코드는 사용자의 입력된 도시에 기반한 날씨 데이터를 가져오고 표시하는 weather라는 객체를 정의합니다. fetch API를 사용하여 날씨 API(api.weatherapi.com)로 요청을 보내고 검색된 데이터로 DOM을 업데이트합니다.\n\n또한 사용자가 특정 도시의 날씨 데이터를 검색할 수 있도록 검색 버튼 및 검색 창에 대한 이벤트 리스너를 포함하고 있습니다. 추가로, 검색된 도시에 따라 배경 이미지를 변경합니다. 페이지가 로드될 때 Lagos의 기본 날씨 정보가 가져와집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트 및 디버깅\n\n웹 브라우저에서 애플리케이션을 테스트하려면 다음 단계를 따를 수 있어요:\n\n- HTML 파일 열기: 이전에 언급된 것처럼 모든 HTML, CSS, JavaScript 파일을 동일한 폴더에 저장한 후, 해당 폴더에서 HTML 파일을 더블 클릭하여 웹 브라우저에서 열어주세요. 이렇게 하면 기본 웹 브라우저에서 파일이 열릴 거에요.\n- 요소 검사: 앱이 브라우저에 로드된 후 페이지를 마우스 오른쪽 버튼으로 클릭하고 \"검사\"를 선택하거나 \"Ctrl+Shift+I\"를 눌러 개발자 도구를 열어주세요. 이렇게 하면 콘솔에서 오류를 볼 수 있고 페이지 요소를 검사할 수 있어요.\n- 기능 테스트: 앱과 상호 작용하여 기능을 테스트해주세요. 이를 통해 코드 내의 버그나 문제를 식별할 수 있어요.\n- 디버깅: 오류나 문제가 발생하면 개발자 도구의 콘솔을 사용하여 JavaScript 코드를 디버깅하세요. 오류 메시지와 줄 번호를 찾아 문제가 발생하는 위치를 확인하세요.\n- 변경 사항 적용: 코드를 변경해야 하는 경우 코드 편집기로 돌아가 필요한 조정을 하고 파일을 저장한 후 브라우저를 새로고침하여 앱에 변경 사항이 반영되는지 확인하세요.\n\n# 배운 교훈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 코딩 프로세스를 시작하기 전에 응용 프로그램의 계획 및 로직을 설계하는 중요성을 이해했습니다. 또한 상호작용 웹 애플리케이션을 만드는 데 중요한 CSS 스타일, JavaScript 이벤트 및 DOM 조작에 대한 지식을 향상시켰습니다.\n\n# 배포\n\n날씨 예보 애플리케이션 프로젝트는 GitHub Pages에서 이용 가능하며, 아래 링크를 클릭하여 온라인으로 액세스할 수 있습니다:\n\n애플리케이션 테스트: [https://wasiu-akindoyin.github.io/Weather-Forecast-Web-Application/](https://wasiu-akindoyin.github.io/Weather-Forecast-Web-Application/)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub 저장소에 액세스하여 소스 코드를 확인하거나 기여할 수 있습니다.\n\n# 애플리케이션 사용 방법 안내\n\n다음 단계를 따라 날씨 예보 애플리케이션을 사용해보세요:\n\n- 위의 날씨 예보 애플리케이션을 위한 GitHub Pages URL을 방문하여 웹 브라우저에서 애플리케이션을 엽니다.\n- 앱이 로드되면 상단에 검색 창이 표시됩니다. 원하는 도시의 날씨를 확인하려면 도시 이름을 입력하고 Enter 키를 누르거나 검색 버튼을 클릭합니다.\n- 앱은 WeatherAPI에서 지정된 도시의 현재 날씨 데이터를 가져와 화면에 표시합니다. 도시 이름, 현재 온도, 날씨 설명, 습도, 풍속 등을 확인할 수 있습니다.\n- 아래로 스크롤하면 도시와 관련된 배경 이미지도 확인할 수 있습니다. 검색하는 도시에 따라 배경 이미지가 변경됩니다.\n- 다른 도시의 날씨를 확인하려면 간단히 검색 창에 새로운 도시 이름을 입력하고 Enter를 누르거나 다시 검색 버튼을 클릭하세요.\n- 여러 도시의 현재 날씨 조건을 확인하는 즐거움을 누려보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미래 개선 사항\n\n앞으로, 더 많은 기능을 추가할 계획입니다:\n\n- 위치 감지: 사용자의 현재 위치를 자동으로 감지하고 날씨를 표시하는 기능을 구현합니다.\n- 로컬 저장소: 사용자가 선호하는 위치나 설정을 로컬 저장소에 저장하여 방문 사이에 선택 사항을 기억합니다.\n- 오류 처리: API 요청 실패나 잘못된 사용자 입력에 대한 오류 처리를 추가합니다.\n- 여러 위치: 여러 위치를 추가하고 전환하여 날씨 정보를 볼 수 있는 기능을 활성화합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML, CSS, 그리고 JavaScript를 사용하여 이 날씨 예보 애플리케이션을 개발하는 것은 저에게 큰 만족감을 줬어요. API를 통합하고 비동기 작업을 관리하며 반응형 웹 애플리케이션을 개발하는 방법에 대해 배웠습니다. 이 애플리케이션은 사용자에게 유용한 서비스를 제공하여 어디서나 쉽게 날씨 정보에 접근할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaWeatherForecastApplicationwithHTMLCSSandJavaScriptAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":9}],"page":"47","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"47"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>