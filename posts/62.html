<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/62" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/62" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Google IO, Flutter가 발표한 최신 내용들 정리" href="/post/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Google IO, Flutter가 발표한 최신 내용들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Google IO, Flutter가 발표한 최신 내용들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Google IO, Flutter가 발표한 최신 내용들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" href="/post/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" href="/post/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">34<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법" href="/post/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트로 계산기 프로젝트 만들기" href="/post/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트로 계산기 프로젝트 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트로 계산기 프로젝트 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트로 계산기 프로젝트 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 개발에 필요한 내용들 전반적으로 소개" href="/post/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 개발에 필요한 내용들 전반적으로 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 개발에 필요한 내용들 전반적으로 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 개발에 필요한 내용들 전반적으로 소개</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법" href="/post/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트 속도와 품질 테스트하기" href="/post/2024-05-20-TestingWebsiteSpeedAndQuality"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트 속도와 품질 테스트하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트 속도와 품질 테스트하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트 속도와 품질 테스트하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요" href="/post/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular로 컴포넌트 만드는 방법" href="/post/2024-05-20-AngularAdvancedComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular로 컴포넌트 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-AngularAdvancedComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular로 컴포넌트 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular로 컴포넌트 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link posts_-active__YVJEi" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Google IO, Flutter가 발표한 최신 내용들 정리","description":"","date":"2024-05-20 23:12","slug":"2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements","content":"\n\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png)\n\n위의 스냅샷이 모두의 본질을 잡아냈음에 기쁩니다. 올해 개인적으로 Google I/O에 참석할 수 있었던 것은 정말 특권이었고, 이 기사는 행사 중에 메모한 내용을 반영하고 있습니다.\n\nGoogle I/O에 처음 참석한 나로서는, 개발자에게는 놀라운 경험이었으며 온라인에서만 알고 있던 사람들을 직접 만날 기회가 생기는 것은 더욱 소중한 경험입니다. \"Flutter로 적응형 UI를 구축하는 방법\"에 대한 Reid와 Tyler의 강연 후의 스냅샷은 행사 전반에 걸쳐 나의 흥분을 완벽하게 담아 냈습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알았어요. 그럼, 구글 I/O 2024 및 그 이후의 Flutter에서 무엇이 새로운지에 대해 이야기해 봅시다. 케빈과 존이 진행한 'What's new in Flutter' 동안 주요 개선 사항이 다음과 같은 주제로 요약되었습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_2.png)\n\n## 주요 진전:\n\n- Google AI Dart SDK: 이 Flutter 프레임워크의 새로운 추가 사항은 또한 존과 케빈의 발표에서 강조되었습니다. 현재 Flutter 3.19가 라이브 중이며, 이로써 구글의 최신 생성적 AI(젬니) 기능이 Flutter 앱으로 제공되어 많은 창의적인 가능성과 쉬운 통합이 가능해졌습니다. 이제 개발자는 간단히 다음과 같이 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_3.png\" /\u003e\n\n- 캐주얼 게임 도구 키트: Flutter를 사용한 게임 개발 가속화를 위한 리소스로 발표되었습니다.\nhttps://docs.flutter.dev/resources/games-toolkit\n- 임펠러: Google I/O 2024에서 특정 발표는 없었지만, Vulkan 백엔드가 강조되어 Flutter 앱의 그래픽 렌더링에서 현저한 개선을 제공한다는 것이 언급되었습니다. 즉시 성능을 향상시키려는 개발자들에게 좋은 대안이 될 수 있습니다. 임펠러로 전환하려면 단순히 다음을 실행하십시오:\n\n\u003cimg src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_4.png\" /\u003e\n\n- 안정적인 WebAssembly 지원: 이는 Flutter 웹 개발을 위한 게임 체인저입니다. WebAssembly (Wasm)로 컴파일함으로써 기존 JavaScript 백엔드 대비 크게 빠른 렌더링 속도(2-3배)를 달성할 수 있습니다. 이는 Flutter를 사용한 고성능 웹 앱 개발을 위한 길을 열어줍니다.\n- Dart 3.4 통합: 이번 업데이트로 Flutter 개발자들을 위한 흥미로운 새로운 기능이 도입되었습니다. Experimental macros: Flutter 개발의 미래를 엿볼 수 있는 기능으로, macros는 편집기 내부에 내장된 기능으로 코드 생성을 가능하게 합니다. 이는 뼈대 코드를 크게 줄이고 유지보수성을 개선하며 반복되는 작업을 자동화할 수 있습니다. 초기 예시로, 새로운 내장 매크로가 JSON 데이터 직렬화 및 역직렬화를 간단하게 만들어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 주제와 관련된 보다 구체적인 정보를 찾으려면 다음 링크를 방문해보세요:\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_5.png)\n\n## 추가 개선 사항:\n\n- 향상된 웹 앱 성능: 웹어셈블리(WebAssembly) 이상, Flutter 3.22는 웹 앱을 위한 다른 최적화도 제공하여 사용자 경험을 더욱 원활하게 만듭니다.\n- 최신 업데이트를 통해 Flutter 앱은 안드로이드 예측 제스처와 완벽하게 통합되어 사용자가 백 스와이프를 시작하는 동안 이전 화면(홈 화면이나 다른 앱)을 간략히 볼 수 있습니다.\n- Flutter 앱에서 iOS 플랫폼 뷰가 속도 향상을 겪었습니다! CPU 사용량이 최대 50% 감소되어 더 원활한 사용자 경험을 제공합니다.\n- 부드러운 그래픽을 위한 Vulkan 백엔드: 이 업데이트로 안드로이드에서 Flutter 앱의 그래픽 렌더링이 현저히 향상되었습니다.\n- 더 나은 위젯 상태 관리: Flutter 3.22는 위젯이 상태를 처리하는 방법에 대한 향상을 제공하여 유지 및 효율적인 코드를 이끌어냅니다.\n- 폼 유효성 검사, 자산 번들링 및 Gradle 스크립트 편집: Flutter 3.22의 추가 기능 중 일부로 개발 워크플로우를 간소화하고 앱 품질을 향상시킵니다.\n- CameraX를 사용한 Flutter에서 일관되고 신뢰할 수 있는 카메라 경험 구축: (Building Consistent and Reliable Camera Experiences in Flutter with CameraX 비디오를 기반으로 함) Android에서의 Flutter 카메라 플러그인의 새로운 구현은 CameraX를 사용하여 구축되었습니다. CameraX는 카메라 개발을 더 쉽게 만들고 카메라 동작을 기기 간 일관되게 유지하는 목적으로 만들어진 Jetpack 라이브러리입니다. CameraX에는 자동 선택 및 기기별 문제 수정이라는 두 가지 주요 혜택이 있습니다. 자동 선택은 해상도나 종횡비를 명시하지 않거나 지정된 값이 사용 불가능한 경우 최상의 해상도나 종횡비를 결정하여 개발자를 돕습니다. CameraX는 또한 기기별 카메라 버그를 수정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 향상된 개발자 경험:\n\n- Material 3로 새롭게 업그레이드된 DevTools: 친숙한 DevTools 인터페이스가 현대적인 Material 3 디자인 언어로 새롭게 탄생하여 미적으로 매력적이고 접근성이 좋은 경험을 제공합니다.\n- 강력한 DevTools 기능 개선: DevTools는 고급 필터링과 타임라인에서 CPU 샘플 지원으로 더욱 강력해졌습니다. 이를 통해 Flutter 앱의 프로파일링과 최적화를 더욱 정밀하게 할 수 있습니다.\n- 딥 링크 디버깅 단순화: Flutter 앱과 웹 경험 사이의 딥 링크 문제 해결이 더욱 쉬워졌습니다. 새로운 딥링크 유효성 검사 도구를 통해 구성 오류를 신속하게 식별하고 수정할 수 있습니다.\n\n## 실제 적용사례:\n\n- Universal Studios Destinations \u0026 Experiences, LG, Brickit 등 주요 기업들이 Flutter를 점점 더 많이 도입하며 프레임워크의 성숙성과 기능을 전시하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 업데이트는 Flutter에 대한 중대한 발전을 의미하며, 아름답고 고성능이며 크로스 플랫폼 애플리케이션을 더욱 쉽게 구축할 수 있는 선택지로 만들어줍니다. 구글 I/O에서 발표된 사진은 Flutter가 전 세계에서 가장 인기 있는 크로스 플랫폼 프레임워크로 부상하는 모습을 보여줍니다.\n\n![Flutter Soars at Google I/O](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_6.png)\n\n## 게다가, 다음 자료들로 특정 측면에 대해 자세히 알아볼 수 있습니다:\n\n- John Ryan과 Kevin Moore에 의한 Flutter 최신 소식 토크\n- Reid Baker와 Tyler Holland에 의한 Flutter로 적응형 UI 구축하기 방법\n- Hangyu Jin과 Zoey Fan에 의한 Flutter에서 딥링킹 성공: 더 이상 깨진 링크가 없음\n- Camille Simon에 의한 Flutter에서 CameraX로 완벽한 카메라 경험 구축하기\n- Michael Thomsen의 최신 Flutter 3.22 및 Dart 3.4에 관한 기사\n- Vertex AI for Firebase SDK를 사용하여 Gemini API 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다.\n\n기사를 즐겼으면 좋겠고, 앞으로 더 많은 게시물을 기대해 주세요. 건배!!! \n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_7.png)","ogImage":{"url":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png"},"coverImage":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png","tag":["Tech"],"readingTime":5},{"title":"웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유","description":"","date":"2024-05-20 23:10","slug":"2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps","content":"\n\n\n![image](/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png)\n\n웹 개발에서 간단함과 효과적인 기능 사이의 균형을 찾는 것이 중요합니다.\n\n개발자로서, 우리는 프로세스를 최적화하고 우수한 결과를 제공하는 방법을 계속해서 찾고 있습니다.\n\nHTML을 우선으로 한 백엔드 개발은 웹 애플리케이션 분야에서 그 가치를 입증해온 실증된 접근 방식으로 부상했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# HTML-First로 간단하게 유지하는 것이 왜 중요한가요\n\n기본 웹 애플리케이션을 구축해야 한다고 상상해보세요. 간단한 필터 옵션으로 데이터를 표시하는 테이블과 같은 웹 애플리케이션입니다.\n\n일반적으로 개발자들은 React 또는 Vue와 같은 복잡한 프론트엔드 프레임워크를 사용하여 이러한 작업을 수행할 수 있습니다.\n\n하지만, 이러한 프레임워크는 사용자 입력 이벤트를 듣는다거나 일반적으로 JSON 형식의 데이터를 가져와서 이 데이터를 동적으로 HTML로 렌더링하는 등 복잡한 단계들이 많이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 잠시 멈추어서 스스로에게 물어보세요. 사용자에게 구조화된 HTML을 제시하는 것이 최종 목표인데, 왜 이 복잡한 JSON 중간 매개체를 통해 탐색해야 하는 걸까요?\n\nHTML 중심 접근 방식을 채택함으로써, 우리는 불필요한 복잡성을 우회하고 더 직접적인 경로를 택하게 됩니다.\n\n라라벨, 장고, 루비 온 레일스와 같이 널리 사용되는 백엔드 프레임워크들은 템플릿을 사용하여 구조화된 HTML을 생성하는 강력한 기능을 제공합니다. 이것은 개발 프로세스를 간단하게 만들뿐만 아니라 성능을 향상시킴으로써 큰 장점을 제공합니다.\n\n# 팬시한 프론트엔드 프레임워크 없이 간소화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 내에서 드롭다운 필터를 구현한다고 상상해보세요.\n\n프론트엔드 프레임워크의 복잡성에 의존하는 대신에 기본 HTML 폼 입력과 전통적인 폼 제출 메커니즘을 활용할 수 있습니다.\n\n아래는 작동 방식입니다:\n\n- 백엔드가 필요한 모든 데이터를 포함한 초기 뷰로 작동합니다.\n- 사용자가 필터와 상호 작용하면 폼이 데이터를 백엔드로 제출하고, 그러면 백엔드가 필터링된 데이터셋으로 페이지를 다시로드합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 전체 페이지 다시로드를 필요로 할 수 있지만, 상당한 이점을 제공합니다.\n\n특히, 현재 상태(적용된 필터와 같은)를 URL에 직접 인코딩함으로써, 응용 프로그램의 특정 뷰를 공유하고 재현하는 것을 간단하게 만든다는 점이 두드러집니다.\n\n또한 별도의 API 계층이 필요하지 않아 응용 프로그램 아키텍처를 간소화하고 전반적인 복잡성을 줄이는 효과가 있습니다.\n\n# 최신 JavaScript로 사용자 경험을 더 나은 방향으로 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 사용자 경험 문제를 다루어보겠습니다. 특히 전체 페이지 새로 고침 상황에서 말이죠. 전통적인 HTML 중심 접근 방식은 단숨함과 신뢰성을 제공하지만, 쾌적한 사용자 경험을 제공하는 데는 부족할 수 있습니다.\n\n이를 해소하기 위해 현대적인 JavaScript 기술을 도입하여 단순함을 희생하지 않고 상호 작용성을 향상시킬 수 있습니다:\n\n- JavaScript를 사용하여 양식 제출을 가로채서 기본 동작을 방지합니다.\n- 백엔드로부터 업데이트된 데이터를 비동기적으로 요청하기 위해 fetch API를 활용합니다.\n- 새로 가져온 데이터로 테이블과 같은 페이지의 해당 부분만 동적으로 교체합니다.\n\n이 방식은 현대적인 프론트엔드 관행을 통합하면서 HTML 중심 개발의 핵심 원칙을 보존합니다. URL을 동적으로 업데이트함으로써 응용 프로그램이 단순함을 희생하지 않고 사용자 친화적이고 효율적으로 유지되도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# HTMX를 사용하여 멋진 상호 작용\n\nHTML-중심 애플리케이션에서 더 많은 유연성과 동적 성을 찾는 개발자들을 위해, HTMX와 같은 도구는 매력적인 해결책을 제공합니다.\n\nHTMX를 사용하면 특별 속성을 HTML에 추가하여 동적 콘텐츠 업데이트를 용이하게 할 수 있습니다.\n\n다음 기능을 고려해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터를 가져오기 위해 GET 요청을 트리거하는 hx-get 활용하기.\n- 가져온 콘텐츠가 삽입될 위치를 정의하는 hx-target 사용하여 대상 요소 지정하기.\n- 상호 작용성을 향상시키기 위해 특정 이벤트에 따라 업데이트를 트리거하는 hx-trigger 활용하기.\n\nHTMX를 HTML을 우선으로 한 개발 워크플로에 통합함으로써, 개발자는 동적 상호 작용성의 힘을 활용하면서 백엔드에서 렌더링된 HTML의 간결함과 효율성을 유지할 수 있습니다.\n\n**실무에 적용하기: 다단계 폼**\n\nHTML을 우선으로 한 개발의 실용적인 적용을 설명하기 위해 다단계 폼을 구축하는 시나리오를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTMX의 도움을 받아 개발자들은 전체 페이지 새로 고침 없이 동적인 양식 제출 및 유효성 처리를 구현할 수 있습니다:\n\n- 각 양식 단계는 백엔드에서 별도의 HTML 엔드포인트로 제공됩니다.\n- 양식 제출은 후속 단계 로딩이나 동적 유효성 오류 표시를 트리거하며, 전체 페이지 새로 고침이 필요하지 않습니다.\n\n이 접근 방식은 HTML 중심 개발이 복잡한 상호 작용을 수용하면서도 간결함과 효율성을 유지하는 우아함을 보여줍니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 프레임워크는 의심의 여지없이 고급 기능과 기능을 제공하지만, 모든 웹 애플리케이션에 항상 최적의 선택은 아닙니다.\n\n많은 프로젝트가 HTML 기반 백엔드 접근 방식의 간결함과 효율성을 크게 누릴 수 있습니다.\n\n최신 JavaScript 기술을 통합하고 HTMX와 같은 도구를 선택적으로 통합함으로써, 개발자는 사용자 경험에 중점을 두면서 강인하고 유지보수 가능한 웹 애플리케이션을 만들 수 있습니다.\n\nHTML 기반 방식은 간결성, 효율성 및 효과적인 요소의 매력적인 혼합물을 제공하는 단단한 선택이 계속되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 스타일을 위해 AI 도움을 받아 작성되었고, 내용은 정보를 제공하기 위한 것으로 제시된 아이디어에 대해 비판적으로 참여할 것을 촉구합니다.\n\n이 글이 마음에 들었다면 👏 로 박수를 보내고 팔로우해 주세요! 가장 좋아하는 부분을 강조해도 좋습니다. 당신의 참여가 저를 영감을 주어요!","ogImage":{"url":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png"},"coverImage":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png","tag":["Tech"],"readingTime":4},{"title":"SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기","description":"","date":"2024-05-20 23:05","slug":"2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI","content":"\n\n이 문서는 WKWebView와 네이티브 측 간의 프로세스간 통신을 탐구합니다. 이는 로컬/임베디드 웹 페이지에 집중할 것입니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png)\n\n# WKWebView의 탄생\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플은 2003년 맥용 Safari 웹 브라우저의 첫 번째 버전을 출시할 때, 네이티브 애플리케이션에서 웹 콘텐츠를 표시하기 위한 최초 세대의 프로그래밍 인터페이스인 WebView 클래스를 개발했습니다.\n\n2007년, 스티브 잡스가 최초의 iPhone을 발표했습니다. 이후 해에는 iPhone 3G가 출시되었으며 WebKit 프레임워크도 함께 출시되었습니다. 이 프레임워크에는 iOS용 또 다른 프로그래밍 인터페이스인 UIWebView 클래스가 포함되어 있습니다.\n\n애플은 2010년에 WebKit의 두 번째 세대에 대한 작업을 시작했습니다. 4년 후, WebView (macOS) 및 UIWebView (iOS) 클래스를 대체하기 위해 WKWebView가 출시되었습니다. 두 클래스는 2018년에 폐기되었습니다.\n\n이것이 WKWebView의 간단한 역사입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# WKWebView이 뭔가요?\n\n답은 애플 문서에 있어요.\n\n중요한 점은 네이티브 애플리케이션이 동일한 뷰에서 HTML 및 SwiftUI/UIKit 구성 요소를 표시할 수 있다는 거예요.\n\n왜 HTML과 네이티브 구성 요소를 함께 사용해야 하죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 콘텐츠나 멋진 UI를 SwiftUI/UIKit로 서식 지정하는 것은 상당히 어려울 수 있습니다. HTML과 CSS는 검증된 기술입니다. 웹 개발자가 모바일 친화적 웹사이트를 제작할 수 있다면, 네이티브 애플리케이션용 UI를 쉽게 만들 수 있습니다!\n\n그로 인해 네이티브 애플리케이션 개발자들이 다른 작업을 처리할 수 있게 되죠...\n\n이 글에서는 좀 더 탐구해보겠습니다.\n\n웹 콘텐츠는 어디서 오는 걸까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히, 웹 브라우저는 웹 서버에서 웹 페이지를 로드합니다. WKWebView이 로컬 파일이나 심지어 HTML 스트링에서 웹 콘텐츠를 로드할 수 있다는 것을 알아내는 것은 흥미롭습니다.\n\n로컬 웹 콘텐츠!\n\n이것은 의미하는 바는 기기가 오프라인 상태일 때에도 네이티브 애플리케이션이 여전히 작동할 수 있다는 것입니다! 게다가, 네이티브 애플리케이션은 네트워크 지연을 피할 수도 있습니다.\n\nWKWebView에 대해 자세히 알아봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 뷰 생성하기\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    typealias UIViewType = WKWebView\n    \n    var vm: BaseWebViewVM\n\n    // 뷰 모델로 초기화\n    init(viewModel: BaseWebViewVM) {\n        self.vm = viewModel\n    }\n    \n    func makeUIView(context: Context) -\u003e WKWebView {\n        return vm.webView\n    }\n    \n    func updateUIView(_ uiView: WKWebView, context: Context) {\n    }\n    \n    func makeCoordinator() -\u003e Coordinator {\n        return Coordinator(viewModel: vm)\n    }\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject {\n        var viewModel: BaseWebViewVM \n        \n        init(viewModel: BaseWebViewVM) {\n            self.viewModel = viewModel\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    @Published var webResource: String?\n    var webView: WKWebView\n\n    init(webResource: String? = nil) {\n        self.webResource = webResource\n        \n        self.webView = WKWebView(frame: .zero,\n                                 configuration: WKWebViewConfiguration())\n    }\n\n    func loadWebPage() {\n        if let webResource = webResource {\n            guard let url = URL(string: webResource) else {\n                print(\"잘못된 URL\")\n                return\n            }\n\n            let request = URLRequest(url: url)\n            webView.load(request)\n        }\n    }\n}\n```\n\n이 코드만 있으면 WKWebView에서 웹 페이지를 보여줄 수 있어요.\n\n## SwiftUIWebView\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWKWebView은 UIView입니다. SwiftUIWebView는 UIViewRepresentable을 구현하는 구조체로 표현되어야 합니다.\n\nSwiftUIWebView는 BaseWebViewVM의 인스턴스로 초기화되어야 합니다.\n\nmakeUIView 메서드는 뷰 모델에서 WKWebView의 인스턴스를 반환합니다.\n\nmakeCoordinator 메서드는 Coordinator의 인스턴스를 반환합니다. Coordinator에는 WKWebView를 위한 델리게이트 함수들이 포함되어 있습니다. 현재로서는 특별한 작업을 수행하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## BaseWebViewVM\n\nBaseWebViewVM에는 공개된 속성 webResource가 있습니다. 이 속성은 클래스 생성자(init 메서드)를 통해 초기화될 수 있습니다. 또한 사용자 인터페이스를 통해 채워질 수도 있습니다.\n\n생성자는 대상 webResource를 로드하지 않은 WKWebView의 인스턴스를 만듭니다.\n\n일단 loadWebPage 메서드는 인터넷 웹 리소스를 로드할 것입니다. 나중에 로컬 웹 콘텐츠를 처리하는 방법도 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXCode Playground에서 시도해 보고 싶다면 다음을 추가해보세요:\n\n```js\nimport SwiftUI\nimport WebKit\nimport PlaygroundSupport\n\n// 위의 코드를 포함해주세요\n\nstruct ContentView: View {\n    let vm = BaseWebViewVM(webResource: \"http://www.google.com\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n\nPlaygroundPage.current.setLiveView(ContentView())\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_2.png\" /\u003e\n\n인터넷 웹 페이지를 표시하는 데 유용합니다. 로컬 웹 콘텐츠를 표시하는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 내장 웹 페이지 표시\n\n먼저 XCode 프로젝트 루트에 Web 폴더를 생성합니다. 모든 웹 페이지와 관련 자료가 포함되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_3.png\" /\u003e\n\n웹 콘텐츠 폴더는 원시 애플리케이션 프로젝트의 물리적인 일부일 수도 있고 그렇지 않을 수도 있습니다. 두 개가 별도의 개체이면 소스 코드 관리에 특히 주의해야 합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 특정 HTML 파일에 액세스하는 방법은 무엇인가요?\n\n애플리케이션이 Web 폴더에있는 다음 웹 페이지에 액세스해야 하는 경우: (위 스크린샷 참조)\n\n```js\nWeb/userGuide/section1/login.html\n```\n\n이것은 상대 경로입니다. 애플리케이션은 절대 경로로만 파일을 열 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 시뮬레이터에서\n\n/Users/\u003cyour user ID\u003e/Library/Developer/CoreSimulator/Devices/.../Web/userGuide/section1/login.html\n\n# XCode Playground 프로젝트에서\n\n/var/folders/.../Web/userGuide/section1/login.html\n```\n\n상대 경로를 절대 경로로 변환하는 코드는 다음과 같습니다:\n\n```js\nlet nswr = NSString(string: relativePath)\n\nlet pathName = nswr.deletingLastPathComponent\nlet fileExtension = nswr.pathExtension\nlet fileName = nswr.lastPathComponent.replacing(\".\\(fileExtension)\", with: \"\")\n\n// pathName: Web/userGuide/section1\n// fileName: login\n// fileExtension: html\n\nlet absolutePath = Bundle.main.path(forResource: fileName,\n                                    ofType: fileExtension,\n                                    inDirectory: inDirectory)\n```\n\n애플리케이션 메인 번들에서 path 메서드는 주어진 파일 정보를 절대 경로로 변환하려고 합니다. 만약 주어진 파일 정보가 잘못되었다면 nil을 반환합니다. \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 HTML 파일의 절대 경로를 획득하면, 웹 뷰에 해당 파일을 로드할 수 있습니다.\n\n```js\nlet url = URL(filePath: absolutePath)\nwebView.loadFileURL(url, allowingReadAccessTo: url)\n```\n\n로드 메서드 대신에 파일 경로를 사용할 때는 loadFileURL 메서드를 사용해야 합니다.\n\n위 샘플 코드를 기준으로 설명하자면, LocalWebViewVM이라는 새 클래스를 추가할 것입니다. 이 클래스는 BaseWebViewVM의 하위 클래스입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nclass LocalWebViewVM: BaseWebViewVM {\n    private func processWebResource(webResource: String) -\u003e (inDirectory: String,\n                                                             fileName: String,\n                                                             fileExtension: String) {\n        // 상대 경로명을 구성 요소로 분해하는 코드\n    }\n\n    override func loadWebPage() {\n        if let webResource = webResource {\n            let (inDirectory,\n                 fileName,\n                 fileExtension) = processWebResource(webResource: webResource)\n\n            guard let filePath = Bundle.main.path(forResource: fileName,\n                                                  ofType: fileExtension,\n                                                  inDirectory: inDirectory) else {\n                print(\"잘못된 경로\")\n                return\n            }\n\n            print(filePath)\n            let url = URL(filePath: filePath)\n\n            webView.loadFileURL(url, allowingReadAccessTo: url)\n        }\n    }\n}\n```\n\n해당 하위 클래스는 loadWebPage 메서드를 오버라이드합니다.\n\nContentView를 다른 뷰 모델로 업데이트합니다.\n\n```swift\nstruct ContentView: View {\n    let vm = LocalWebViewVM(webResource: \"Web/userGuide/section1/login.html\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 캔버스에서 표시되는 내용입니다. (XCode Playground에서 라이브 뷰로 확인)\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4.png)\n\n# 사용자 상호작용\n\n## 자바스크립트 경고\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지나 어플리케이션은 다음과 같은 Javascript 코드를 통해 사용자에게 알림 메시지를 표시할 수 있습니다:\n\n```js\nalert(\"이것은 알림입니다\");\n```\n\n이것이 발생할 때 WKWebView는 대화 상자를 표시하지 않습니다. 대신, 이 역할은 호스팅 애플리케이션에 위임됩니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -\u003e WKWebView {\n        // 알림 처리\n        vm.webView.uiDelegate = context.coordinator\n        \n        return vm.webView\n    }\n\n    ...\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 Javascipt 알림을 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptAlertPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping () -\u003e Void) {\n            viewModel.webPanel(message: message,\n                               alertCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // Javascript 알림, 확인, 프롬프트 대화 상자에 대한 프로퍼티\n    @Published var showPanel: Bool = false\n    var panelTitle: String = \"\"\n    var panelType: JSPanelType? = nil\n    \n    var panelMessage: String = \"\"\n        \n    // 알림 프로퍼티\n    var alertCompletionHandler: () -\u003e Void = {}\n\n    // 해당 알림 UI를 위한 프로퍼티 설정\n    func webPanel(message: String,\n                  alertCompletionHandler completionHandler: @escaping () -\u003e Void) {\n        self.panelTitle = JSPanelType.alert.description // \"알림\"\n        self.panelMessage = message\n        self.alertCompletionHandler = completionHandler\n        self.panelType = .alert\n        self.showPanel = true\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 응용 프로그램은 context.coordinator를 웹 뷰 uiDelegate 속성에 할당해야 합니다.\n\nCoordinator 클래스는 WKUIDelegate 프로토콜을 구현하고 여러 webView 함수 중 하나를 구현해야 합니다. 더 구체적으로는 Javascript alert용 함수입니다. 이 webView 함수는 UI 표시를 시작하지 않습니다. 대신, 알림 메시지와 콜백 함수를 뷰 모델로 전달합니다.\n\nJavascript alert는 모든 웹 페이지에 대해 일반적인 기능이므로 해당 기능을 하위 클래스가 아닌 BaseWebViewVM에 구현하는 것이 가장 좋습니다.\n\n다음은 몇 가지 새로운 속성입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nshowPanel - ContentView에서 UI 표시를 토글하는 발행된 속성입니다.\n\npanelTitle - 일반적인 UI 표시 제목입니다.\n\npanelMessage - 웹 페이지에서 나오는 메시지입니다.\n\npanelType - UI 표시의 유형을 나타냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nalertCompletionHandler — 특정 Javascript 경고 콜백 함수\n\nwebPanel 함수는 panelType을 JSPanelType.alert로 설정합니다. 또한 showPanel을 true로 설정하여 해당 UI 프레젠테이션을 트리거해야 합니다.\n\nJSPanelType은 열거 유형입니다. 현재는 alert 값만 포함하고 있습니다. 또한 선택한 값에 대한 제목 설명을 반환하는 description이라는 계산된 속성이 있습니다.\n\n다음은 업데이트된 ContentView입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                           switch vm.panelType {\n                           case .alert:\n                               Button(\"Close\") {\n                                   vm.alertCompletionHandler()\n                               }\n                           default:\n                               Button(\"Close\") {}\n                           }\n                       }, message: {\n                           Text(vm.panelMessage)\n                       })\n        }\n        .padding()\n    }\n}\n```\n\nSwiftUIWebView에는 alert modifier가 포함되어 있습니다. 해당 alert에는 Close 버튼이 있습니다. 이 버튼은 alertCompletionHandler 함수를 호출할 것입니다.\n\n다음은 웹 페이지입니다:\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cbutton onclick=\"alert('This is an alert!')\"\u003eAlert\u003c/button\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:508/1*crNpOlR8VlOFpZSVQXkF-Q.gif)\n\n이것은 표준 프레젠테이션입니다. 그러나 필요에 따라 시트, 팝오버 또는 응용 프로그램에 적합한 UI로 구현할 수 있습니다.\n\n## Javascript Confirm\n\nJavascript confirm 기능은 javascript alert와 유사합니다. 표준 프레젠테이션에서 모달에는 메시지, 확인 버튼 및 취소 버튼이 포함됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconfirm(\"Are you sure?\")\n```\n\n자바스크립트 confirm 함수는 OK 버튼을 클릭할 때 TRUE를 반환합니다. 그렇지 않으면 FALSE를 반환합니다.\n\nSwift에서 자바스크립트 confirm을 처리하려면 애플리케이션은 다른 WKUIDelegate webView 함수를 추가해야 합니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수가 자바스크립트 confirm을 처리합니다.\n        func webView(_ webView: WKWebView,\n                     runJavaScriptConfirmPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (Bool) -\u003e Void) {\n            viewModel.webPanel(message: message,\n                               confirmCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 확인 속성\n    var confirmCompletionHandler: (Bool) -\u003e Void = { _ in }\n\n    // 해당 확인 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  confirmCompletionHandler completionHandler: @escaping (Bool) -\u003e Void) {\n        self.panelTitle = JSPanelType.confirm.description\n        self.panelMessage = message\n        self.confirmCompletionHandler = completionHandler\n        self.panelType = .confirm\n        self.showPanel = true\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript의 confirm을 위한 webView 함수는 약간 다른 콜백 함수 서명을 가지고 있어요.\n\n```js\ncompletionHandler: @escaping (Bool) -\u003e Void\n```\n\nboolean 값을 인자로 받아요.\n\nJSPanelType에 confirm 값을 추가해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBaseWebViewVM에 confirmCompletionHandler 속성을 추가하십시오. Javascript confirm을 위한 다른 webPanel 함수를 추가하십시오. panelType 속성을 JSPanelType.confirm으로 설정하십시오. 다시 한번 showPanel을 true로 설정하여 UI 표시를 트리거합니다.\n\n다음은 업데이트된 ContentView입니다:\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                    switch vm.panelType {\n                    case .alert:\n                        Button(\"Close\") {\n                            vm.alertCompletionHandler()\n                        }\n                    case .confirm:\n                        Button(\"Ok\") {\n                            vm.confirmCompletionHandler(true)\n                        }\n                        Button(\"Cancel\") {\n                            vm.confirmCompletionHandler(false)\n                        }\n                    default:\n                        Button(\"Close\") {}\n                    }\n                }, message: {\n                    Text(vm.panelMessage)\n                })\n        }\n        .padding()\n    }\n}\n```\n\n다음은 업데이트된 웹 페이지입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003cscript\u003e\n    ...\n    function callConfirm() {\n      if (confirm(\"This is a confirm dialog\")) {\n        document.getElementById(\"confirmValue\").innerText = \"You hit ok\";\n      } else {\n        document.getElementById(\"confirmValue\").innerText = \"You hit cancel\";\n      }\n    }    \n  \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  ...\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"callConfirm()\"\u003eConfirm\u003c/button\u003e\n    \u003cdiv\u003eConfirmed? \u003cspan id=\"confirmValue\"\u003e\u003c/span\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n![Image](https://miro.medium.com/v2/resize:fit:504/1*DJyWQIktvhBdSEaqEIYJlw.gif)\n\n## Javascript Prompt\n\nThe last standard Javascript modal is prompt. The modal contains a text field for user input.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nvar response = prompt(\"이것은 프롬프트입니다! 어떻게 지내세요?\", \"좋음\");\n```\n\nprompt 함수의 두 번째 선택적 매개변수는 기본값입니다. 기본값은 webView 델리게이트 메서드를 통해 전달됩니다.\n\n다시 한 번, 응용 프로그램은 다른 WKUIDelegate webView 함수를 추가해야 하며, JSPanelType을 업데이트하고 BaseWebViewVM 클래스에 새 속성 및 webPanel 함수를 추가해야 합니다.\n\n```swift\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 자바스크립트 프롬프트를 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptTextInputPanelWithPrompt prompt: String,\n                     defaultText: String?,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (String?) -\u003e Void) {\n            viewModel.webPanel(message: prompt,\n                               promptCompletionHandler: completionHandler,\n                               defaultText: defaultText)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    case prompt\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        case .prompt:\n            return \"프롬프트\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 프롬프트 속성\n    var promptInput: String = \"\"\n    var promptCompletionHandler: (String?) -\u003e Void = { _ in }\n\n    // 해당 프롬프트 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  promptCompletionHandler completionHandler: @escaping (String?) -\u003e Void,\n                  defaultText: String? = nil) {\n        self.panelTitle = JSPanelType.prompt.description\n        self.panelMessage = message\n        self.promptInput = defaultText ?? \"\"\n        self.promptCompletionHandler = completionHandler\n        self.panelType = .prompt\n        self.showPanel = true\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백 함수는 promptInput 속성 값을 전달합니다. promptInput은 null이 아닌 문자열 속성임을 유의하세요. 따라서 콜백은 빈 문자열이거나 사용자 입력일 수 있습니다.\n\n다음은 업데이트된 웹 페이지입니다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003cscript\u003e\n    ...\n    function callPrompt() {\n      var response = prompt(\"프롬프트입니다! 어떻게 지내세요?\", \"좋아요\");\n      if (response) {\n        document.getElementById(\"promptResult\").innerText =\n          \"당신의 응답은: \" + response;\n      } else {\n        document.getElementById(\"promptResult\").innerText = \"취소됨\";\n      }\n    }  \n    \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  ...\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"callPrompt()\"\u003e프롬프트\u003c/button\u003e\n    \u003cdiv\u003e\u003cspan id=\"promptResult\"\u003e\u003c/span\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:508/1*rlolSsaDf_BRguFOB8td5Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML5에서는 다이얼로그 요소가 있습니다. 이 요소는 HTML에서 모달 및 비모달 대화 상자를 만드는 데 사용됩니다.\n\n다이얼로그 요소를 사용하면 사용자 정의 경고, 확인 대화 상자 및 프롬프트 모달 대화 상자를 만들 수 있습니다. 이 접근 방식을 사용하면 모달을 다른 웹 애플리케이션과 일치하도록 스타일링할 수 있습니다.\n\n다이얼로그 요소를 사용하면 Swift 코드를 작성하는 대신 모든 사용자 상호 작용을 처리하기 위해 Javascript 코드를 작성해야 합니다. 하지만 이것은 원격 대화 상자를 생성하는 방법을 호스트(기본)에게 전달할 수 없다는 것을 의미하지는 않습니다. 다음 섹션에서는 웹 페이지와 호스트(기본) 응용 프로그램 간의 메시지나 이벤트를 전송하는 방법에 대해 알아볼 것입니다.\n\n# 웹 페이지와 기본 응용프로그램 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹킷 프레임워크는 Objective-C 및 Swift를 위해 설계되었습니다. WebKit JS라고도 하는 자바스크립트 부분도 있습니다. 이는 Safari DOM 확장 기능입니다. (그것이 원래 이름일 수도 있습니다!) 기본적으로 이는 Safari 환경에 터치 제스처 이벤트, 스타일링 및 시각적 효과를 추가합니다. 실제로 그 기능 중 일부는 이미 W3C 표준의 일부로 채택되었습니다.\n\n웹 페이지에서 네이티브 애플리케이션으로 메시지/데이터를 보내려면 수신 측에 \"리스너\" 또는 WebKit 용어로는 메시지 핸들러가 필요하고, 보내는 쪽에는 메시지 전송 함수가 있어야 합니다.\n\n이 섹션에서는 웹 뷰에서 네이티브 애플리케이션으로 메시지를 보내거나 받고 응답하는 방법을 설명합니다.\n\n우선 웹 콘텐츠부터 시작해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n\u003c!-- index2.html --\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003ctitle\u003eIndex 2\u003c/title\u003e\n  \u003cscript\u003e\n    async function sendWebKitMessage(handler, message) {\n      if (\n        message != \"\" \u0026\u0026\n        handler != \"\" \u0026\u0026\n        window.webkit \u0026\u0026\n        window.webkit.messageHandlers \u0026\u0026\n        window.webkit.messageHandlers.hasOwnProperty(handler)\n      ) {\n        console.log(\"Going to send a message to\", handler)\n        var reply = await window.webkit.messageHandlers[handler].postMessage(message);\n        return reply\n      } else {\n        throw Error(\"뭔가 빠지는 게 있어요!\");\n      }\n    }\n\n    async function sendReceiveReply(handler, message, elementId) {\n      try {\n        var reply = await sendWebKitMessage(handler, message);\n\n        var sanitizedReply = reply.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\");\n        document.getElementById(elementId).innerHTML = sanitizedReply;\n      } catch (error) {\n        document.getElementById(elementId).innerHTML = \"에러: \" + error.message;\n      }\n    }\n  \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"sendWebKitMessage('fromWebPage', '웹 뷰에서 온 메시지')\"\u003e메시지 보내기\u003c/button\u003e\n  \u003c/div\u003e\n  \u003cdiv style=\"margin-top: 15px\"\u003e\n    \u003cbutton onclick=\"sendReceiveReply('getData', '보내줘야 할 데이터 있어?', 'reply')\"\u003e데이터 가져오기\u003c/button\u003e\n    \u003cdiv id=\"reply\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Send Message\" 버튼으로부터 발생한 처리되지 않은 예외의 스크린샷과 \"Get Data\" 버튼에서 처리된 예외의 스크린샷입니다.\n\n![예외 스크린샷](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_5.png)\n\n핸들러는 window.webkit.messageHandlers 네임스페이스에 있는 객체입니다. 모든 메시지 핸들러에는 postMessage라는 메소드가 있습니다. 이 메소드는 네이티브 애플리케이션으로 메시지/데이터를 보내는 데 사용됩니다.\n\nsendWebKitMessage 함수에는 console.log가 있습니다. 이 함수는 웹 인스펙터 콘솔 영역에 메시지를 표시할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네이티브 애플리케이션 UI와 웹 뷰를 Safari 웹 브라우저에서 검사할 수 있도록 몇 가지 변경을 가해봅시다.\n\n```js\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 웹 뷰로부터의 메시지\n    @Published var messageFromWV: String = \"\"\n\n    init(webResource: String? = nil) {\n        ...\n        \n#if DEBUG\n        // 검사 가능한 웹 뷰\n        self.webView.isInspectable = true\n#endif\n    }\n\n    ...\n}\n\nstruct ContentView: View {\n    // 이 VM은 메시지를 보내는 로컬 웹 페이지를 표시합니다.\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index2.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                ...\n            Text(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n        }\n    }\n}\n```\n\nBaseWebViewVM에서 messageFromWV라는 publish된 속성이 추가되었습니다. 이 속성은 웹 뷰에서 수신된 메시지를 저장할 것입니다. Text 요소가 이 변수에 바인딩됩니다.\n\n```js\n@Published var messageFromWV: String = \"\"\n\nText(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBaseWebViewVM 이니셜라이저에는 다음과 같은 코드 줄이 포함되어 있습니다.\n\n```js\n#if DEBUG\n    self.webView.isInspectable = true\n#endif\n```\n\n이를 통해 Safari가 웹 뷰 안에 있는 웹 페이지를 검사할 수 있습니다. 샘플 웹 페이지의 제목이 \"Index 2\"인 것에 유의하십시오. iOS 시뮬레이터에서 애플리케이션을 실행할 때 Develop \u003e Simulator 하위 메뉴 아래에서 웹 페이지 제목을 볼 수 있어야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML 버튼이 네이티브 애플리케이션과 상호 작용하도록 만들어 봅시다.\n\n먼저 \"fromWebPage\"와 \"getData\"에 대한 메시지 핸들러를 정의해야 합니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -\u003e WKWebView {\n        let userContentController = vm.webView\n            .configuration\n            .userContentController\n        \n        // 모든 메시지 핸들러를 제거합니다 (기존에 있으면)\n        userContentController.removeAllScriptMessageHandlers()\n\n        // 응답 없이 메시지 핸들러 추가\n        userContentController.add(context.coordinator,\n                                  name: \"fromWebPage\")\n\n        // 응답과 함께 메시지 핸들러 추가\n        userContentController.addScriptMessageHandler(context.coordinator,\n                                                      contentWorld: WKContentWorld.page,\n                                                      name: \"getData\")\n        ...\n    }\n}\n```\n\n사용자 콘텐츠 컨트롤러(WKUserContentController)는 \"앱의 네이티브 코드와 웹페이지의 스크립트 및 기타 콘텐츠 간의 상호 작용을 조정\"합니다. 이것은 웹 뷰 구성(WKWebViewConfiguration) 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메시지 송수신 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 add 메서드를 사용해야 합니다.\n\n메시지 송수신-응답 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 addScriptMessageHandler 메서드를 사용해야 합니다.\n\n두 메서드 모두 사용자 콘텐츠 컨트롤러 메서드를 구현한 객체와 메시지 핸들러의 이름을 전달해야 합니다. 메시지 송수신의 경우, 객체는 WKScriptMessageHandler 프로토콜을 구현해야 합니다. 메시지 송수신-응답의 경우, 객체는 WKScriptMessageHandlerWithReply를 구현해야 합니다.\n\naddScriptMessageHandler는 또한 메시지 핸들러를 설치할 위치를 알아야 합니다. 이 샘플 코드에서, 애플리케이션은 WKContentWorld.page를 contentWorld 인자에 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자연스럽게, 코디네이터가 메시지 통신을 처리할 것입니다. 여기 구현입니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: ..., WKScriptMessageHandler, WKScriptMessageHandlerWithReply {\n        ...\n\n        // MARK: - WKScriptMessageHandler delegate function\n\n        // 메시지 송수신을 위한\n        func userContentController(_ userContentController: WKUserContentController, \n                                   didReceive message: WKScriptMessage) {\n            self.viewModel.messageFrom(fromHandler: message.name,\n                                       message: message.body)\n        }\n\n        // MARK: - WKScriptMessageHandlerWithReply delegate function\n\n        // 메시지 송수신 및 응답을 위한\n        func userContentController(_ userContentController: WKUserContentController,\n                                   didReceive message: WKScriptMessage,\n                                   replyHandler: @escaping (Any?, String?) -\u003e Void) {\n            do {\n                let returnValue = try self.viewModel.messageFromWithReply(fromHandler: message.name,\n                                                                          message: message.body)\n                \n                replyHandler(returnValue, nil)\n            } catch WebViewErrors.GenericError {\n                replyHandler(nil, \"일반 오류\")\n            } catch WebViewErrors.ErrorWithValue(let value) {\n                replyHandler(nil, \"값 오류: \\(value)\")\n            } catch {\n                replyHandler(nil, error.localizedDescription)\n            }\n        }\n    }\n}\n```\n\nuserContentController 두 가지 구현은 사용자 컨텐츠 컨트롤러 및 수신 메시지에 대한 참조를 받습니다.\n\n메시지인 WKScriptMessage는 두 가지 중요한 매개변수, 메시지 핸들러의 이름(name)과 메시지 내용(body)을 포함합니다. 이 샘플 코드에서, 두 구현은 모두 이름과 내용을 사용하여 뷰 모델 메서드를 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보내기-수신-응답 버전을 위해 추가적인 replyHandler 클로저 인자가 있습니다. 클로저는 반환값과 오류 메시지 2개의 인자를 갖습니다. 클로저를 호출할 때 애플리케이션이 \"something\"을 한 인자로 전달하고 다른 하나는 nil입니다.\n\n마지막으로, 애플리케이션은 수신 메시지의 의도를 실행하기 위한 메서드를 구현해야 합니다.\n\n```swift\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // MARK: - 메시징을 위한 함수\n    func messageFrom(fromHandler: String, message: Any) {\n        self.panelTitle = JSPanelType.alert.description // \"Alert\"\n        self.panelMessage = String(describing: message)\n        self.alertCompletionHandler = {}\n        self.panelType = .alert\n        self.showPanel = true\n        self.messageFromWV = String(describing: message)\n    }\n\n    func messageFromWithReply(fromHandler: String, message: Any) throws -\u003e String {\n        self.messageFromWV = String(describing: message)\n\n        var returnValue: String = \"Good\"\n\n        /*\n         * 이 함수는 다음과 같은 예외를 던질 수 있습니다:\n         *\n         * - WebViewErrors.GenericError\n         * - WebViewErrors.ErrorWithValue(value: 99)\n         */\n        \n        if fromHandler == \"getData\" {\n            returnValue = \"{ data: \\\"It is good!\\\" }\"\n        }\n        \n        return returnValue\n    }\n}\n```\n\nmessageFrom 메서드는 send-receive 메시징을 처리합니다. 예외를 던지지는 않는다는 점에 유의하십시오. 던진다 해도 userContentController 메서드는 해당 오류를 웹 뷰로 다시 전달할 수 없을 것입니다. 오류를 웹 뷰로 다시 전달해야 하는 경우 send-receive-reply 메시징 전략을 사용해야 합니다 - messageFromWithReply 메서드를 사용하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmessageFromWithReply 메서드는 예외를 throw하고 문자열 값을 반환합니다. 샘플 코드에서는 JSON 문자열을 웹 뷰로 다시 반환합니다. 자바스크립트 세계에서는 JSON 문자열을 쉽게 자바스크립트 객체로 파싱할 수 있습니다.\n\n현재 샘플 코드는 예외를 throw하지 않습니다. 그러나 이 샘플 프로젝트에서 정의된 오류는 다음과 같습니다.\n\n```js\nenum WebViewErrors: Error {\n    case ErrorWithValue(value: Int)\n    case GenericError\n}\n```\n\n첫 번째 오류는 정수값을 받습니다. 하나 이상의 인수를 받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱의 enum을 앱에 맞게 사용자 정의하세요!\n\n마침내, 이것이 보이는 모습입니다:\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-PYrd32kdzvXGs27tgr8yQ.gif)\n\n네이티브 애플리케이션에서 웹 뷰로 메시지를 보내는 방법은 어떤가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네이티브 애플리케이션에서 메시지를 수신하려면 웹 페이지가 \"메시지\" 이벤트를 \"청취\"해야 합니다.\n\n다음은 샘플 웹 페이지입니다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003clabel for=\"\"\u003e호스트로부터의 메시지:\u003c/label\u003e\n    \u003cbr\u003e\n    \u003cdiv id=\"message\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\u003cscript\u003e\n  window.addEventListener(\"message\", (event) =\u003e {\n    // 수신 메시지 소독(Process of cleaning untrusted input)\n    var content = event.data.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\")\n    document.getElementById(\"message\").innerHTML = content\n  })\n\u003c/script\u003e\n\n\u003c/html\u003e\n```\n\n웹 페이지는 \"메시지\" 이벤트리스너를 추가합니다. event.data에는 메시지 콘텐츠가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지가 \"메시지\"를 수신하면 해당 내용을 웹 페이지에 단순히 표시합니다.\n\n웹 뷰에 메시지를 보낼 수 있는 UI를 만들어봅시다.\n\n```js\nstruct MessageToWebView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index3.html\")\n    @State var message: String = \"\"\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"메시지:\")\n                .font(.system(size: 26))\n            HStack(alignment: .center, spacing: 10) {\n                TextField(\"메시지를 입력하세요\", text: $message)\n                    .textFieldStyle(.roundedBorder)\n                    .border(.blue)\n                    .font(.system(size: 26))\n                Button(\"전송\") {\n                    vm.messageTo(message: message)\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            WebView(vm: vm)\n        }\n        .padding()\n    }\n}\n```\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"보내기\" 버튼은 뷰 모델에서 messageTo 메서드를 호출합니다.\n\n```js\nfunc messageTo(message: String) {\n    let escapedMessage = message.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    \n    let js = \"window.postMessage(\\\"\\(escapedMessage)\\\", \\\"*\\\")\"\n    self.webView.evaluateJavaScript(js) { (result, error) in\n        if let error = error {\n            print(\"Error: \\(error.localizedDescription)\")\n        }\n    }\n}\n```\n\n위의 다른 시나리오들과는 달리, 구현해야 할 프로토콜 메서드가 없습니다. 웹 뷰로 메시지를 보내기 위한 네이티브 메서드도 없습니다.\n\n대신 네이티브 애플리케이션은 Javascript postMessage 호출을 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nwindow.postMessage(...)\n```\n\npostMessage 메서드는 텍스트 인수를 받습니다. 결과적으로, 웹 뷰의 evaluateJavaScript 메서드에서 실행하기 전에 콘텐츠를 올바르게 이스케이프하고 인코딩해야 합니다.\n\n```js\nfunc evaluateJavaScript(\n    _ javaScriptString: String,\n    completionHandler: ((Any?, Error?) -\u003e Void)? = nil\n)\n```\n\nevaluateJavaScript에는 completionHandler가 있습니다. 이는 반환 값을 또는 에러를 네이티브 응용 프로그램으로 돌려 보내는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nevaluateJavaScript 메서드는 JavaScript 코드를 실행하거나 평가할 수 있습니다. 예시 코드에서 window.postMessage 호출은 값을 반환하거나 오류를 반환하지 않습니다. 다른 경우에는 실행되는 코드가 값이 반환되고 예외가 발생할 수 있습니다.\n\n마지막으로, 실제 동작을 확인할 수 있습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AZXEKStS4IuR49Ho-HwihA.gif)\n\n위 웹 페이지에는 이벤트 리스너 선언을 포함한 스크립트 요소가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 모든 웹 페이지에 동일한 Javascript 코드를 주입해야 할 때, 모든 웹 페이지에 수동으로 스크립트 요소를 추가하는 대신, 사용자 콘텐츠 컨트롤러의 addUserScript 메서드를 활용할 수 있습니다.\n\n다음은 간단한 구현입니다:\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n   func makeUIView(context: Context) -\u003e WKWebView {\n      ...\n\n      injectJS(userContentController)\n\n      ...\n    }\n\n    func injectJS(_ userContentController: WKUserContentController) {\n        // 메시지 이벤트 리스너 정의\n        //\n        // \u003cscript\u003e HTML 요소를 포함할 필요가 없다는 점에 유의하십시오.\n        let msgEventListener = \"\"\"\nwindow.addEventListener(\"message\", (event) =\u003e {\n    // 수신된 메시지 정제\n    var content = event.data.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\")\n    document.getElementById(\"message\").innerHTML = content\n})\n\"\"\"\n\n        // 이벤트 리스너 주입\n        userContentController.addUserScript(WKUserScript(source: msgEventListener,\n                                                         injectionTime: .atDocumentEnd,\n                                                         forMainFrameOnly: true))\n    }\n}\n```\n\ninjectJS 함수는 동일한 이벤트 리스너 코드를 가진 변수(msgEventListener)를 포함하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`addUserScript` 함수에는 `WKUserScript`의 인스턴스가 필요합니다.\n\n`injectionTime`은 `.atDocumentEnd`로 설정되어 있습니다. 이는 원본 스크립트 요소 선언과 동일합니다. 다른 값으로는 `.atDocumentStart`가 있습니다.\n\n만약 자바스크립트 코드가 콘텐츠 요소에 의존한다면, 코드를 `.atDocumentEnd`에 주입하는 것이 가장 좋을 수 있습니다.\n\n만약 자바스크립트 코드가 라이브러리이면, 코드를 `.atDocumentStart`에 주입하는 것이 가장 좋을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nforMainFrameOnly 인수는 부울 값입니다. true를 전달하면 자바스크립트 코드가 주 페이지에만 삽입됩니다. 애플리케이션은 모든 iframe 요소에 동일한 자바스크립트 코드를 삽입하지 않습니다. 그렇지 않으면 자바스크립트 코드는 주 페이지와 해당 iframe 요소에 삽입됩니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_8.png)\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_9.png)\n\n웹 인스펙터에서 삽입된 자바스크립트 코드는 \"추가 스크립트 `user-script:1`\" 아래에 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 하이퍼링크를 통해 다른 웹 페이지로 이동하면, 애플리케이션이 해당 웹 페이지에 동일한 자바스크립트 블록을 삽입합니다.\n\n이 웹 페이지에 iframe을 추가하고 forMainFrameOnly를 false로 설정해봅시다.\n\n![image](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_10.png)\n\n웹 인스펙터에서 \"user-script:1\"이 두 번 표시됩니다. 각 웹 페이지는 자바스크립트 코드 블록을 수신합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용 시나리오\n\n## 앱 내 사용자 가이드\n\niOS 또는 macOS 애플리케이션에서 사용자 가이드나 맥락에 맞는 도움말 정보를 제공해야 하는 경우, 어떻게 할까요?\n\nUIKit의 UILabel 및 SwiftUI의 Text 요소는 기본적인 마크다운 형식을 지원합니다. 서식이 있는 텍스트와 이미지로 유용한 도움말 페이지를 만드는 것은 다소 귀찮은 작업이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도움 페이지는 HTML과 CSS를 사용하여 웹 페이지로 작성할 수도 있습니다. 도움 페이지는 앱 내에 포함되어 WKWebView를 사용하여 표시될 수 있습니다.\n\n## 사용자 인터페이스\n\nSwiftUI 또는 UIKit을 사용하여 전체 네이티브 애플리케이션을 만드는 대신 대부분의 사용자 인터페이스를 HTML과 CSS를 사용하여 구현할 수 있습니다. 대부분의 비즈니스 로직은 Javascript를 사용하여 구현할 수 있습니다.\n\nReactJS, Angular, VueJS 등의 Javascript 프레임워크를 사용하면 프론트엔드 로직을 구성하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 UI 라이브러리인 Bootstrap, Foundation, Semantic UI, Tailwind Elements 등은 많은 매력적인 UI 구성 요소들을 제공해요. 이 라이브러리들은 네이티브 애플리케이션의 느낌과 모양에 맞게 사용자정의할 수 있어요.\n\n물론, 이러한 라이브러리와 프레임워크를 사용하면 애플리케이션의 크기가 커질 수 있어요. 현명하게 사용해야 해요!\n\n# 샘플 XCode 프로젝트\n\n해당 XCode 프로젝트에 대한 GitHub 링크는 여기에서 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- WKWebView\n- UIViewRepresentable\n- Coordinator\n- WKUIDelegate\n- WKUserContentController\n- WKWebViewConfiguration\n- WKContentWorld\n- WKScriptMessageHandler\n- WKScriptMessageHandlerWithReply\n- WKScriptMessage\n- DOM 메시지 이벤트 및 window.postMessage 메서드\n- WKUserScript\n\n이 기사는 여기서 끝입니다. 아마도 여러분이 프로젝트에서 WKWebView를 어떻게 활용할 수 있는지에 대한 아이디어를 얻을 수 있기를 바랍니다.\n\n이 기사를 즐겁게 읽어 주셨으면 좋겠습니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png"},"coverImage":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png","tag":["Tech"],"readingTime":34},{"title":"ERR_BLOCKED_BY_RESPONSENotSameOrigin 에 대한 간단한 해결 방법","description":"","date":"2024-05-20 23:04","slug":"2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png\" /\u003e\n\n\"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\"은 일반적으로 웹 브라우저에서 발생하는 오류입니다. 이 오류는 웹페이지가 접근하려는 리소스가 페이지 자체와 다른 출처(또는 도메인)를 가지고 있는 경우에 발생합니다. 이는 웹 브라우저에 내장된 보안 기능으로, 다중 사이트 스크립팅 공격을 방지하기 위한 것입니다.\n\n웹 페이지가 다른 출처로 요청을 시도할 때, 브라우저는 해당 요청을 차단하고 \"ERR_BLOCKED_BY_RESPONSE.NotSameOrigin\" 오류 메시지를 반환합니다. 이는 요청을 허용할 경우 민감한 정보가 노출되거나 악성 코드가 페이지에서 실행될 수 있기 때문입니다.\n\n이 오류를 해결하려면 페이지가 접근하려는 모든 리소스(예: 이미지, 스크립트 및 기타 파일)가 페이지 자체와 동일한 도메인에 호스팅되어 있는지 확인해야 합니다. 또는 특정 출처가 리소스에 액세스할 수 있도록 크로스 출처 리소스 공유(CORS)를 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 프로젝트에서 가져온 간단한 예시입니다:\n\n이미지 파일 위치를 지정하는 src 속성이 있는 HTML img 태그입니다. 이는 제3자 API입니다.\n\n```js\n\u003cimg src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=\"flag\"/\u003e\n```\n\nimg 태그에 crossorigin 속성을 간단히 추가할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cimg crossorigin='anonymous' src={`https://countryflagsapi.com/png/${country.alpha3Code.toLowerCase()}`} alt=”flag”/\u003e\n```\n\n문제를 해결할 수 있는 또 다른 고급 방법이 있습니다. Helmet을 사용하여 crossOriginEmbedderPolicy 미들웨어를 비활성화하는 방법도 있습니다. 더 많은 세부 정보는 여기에서 확인할 수 있습니다.\n\n추가 자료:\nRFC 섹션-3.4.2\n","ogImage":{"url":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png"},"coverImage":"/assets/img/2024-05-20-AsimplewaytosolveERR_BLOCKED_BY_RESPONSENotSameOrigin_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트로 계산기 프로젝트 만들기","description":"","date":"2024-05-20 23:03","slug":"2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects","content":"\n\n\n![Simple Calculator](/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png)\n\nAs a 1st year IT undergraduate, I always work on pet projects to enhance my skills. I thought I would share my little pet project with you - a simple calculator.\n\n## How did I create this?\n\nI used HTML, CSS, and JavaScript to create this project and used Visual Studio Code as my code editor.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 하는 일의 중요성 반려동물 프로젝트\n\n요즘에는 인터넷에서 프로그래밍, 코딩 또는 원하는 것을 배울 수 있어요. 기술이 발전함에 따라 지금은 모든 것이 손끝에 있어요. 무엇을 배우든 모든 것을 기억할 수 없을 거예요. 그게 인간의 본성이에요. 하지만 배운 것을 실천해보려고 노력하면 기억에 큰 도움이 될 거예요. 저는 IT 학부생으로 항상 반려동물 프로젝트를 합니다. 반려동물 프로젝트를 통해 당신은\n\n- 이전에 배운 것을 상기시킬 수 있어요.\n- 이론의 실제 응용을 알 수 있어요.\n- 코딩과 프로그래밍을 연습할 수 있어요.\n- 실수로부터 배울 수 있어요.\n- 기술을 향상시키는 좋은 방법이에요.\n- 천천히 산업 수준으로 진입할 수 있어요.\n\n또한, 이렇게 만든 반려동물 프로젝트를 취업 면접에서 보여줄 수 있어요. 분명히 당신에게 이점을 줄 거예요. 아직 시작하지 않았다면, 지금 반려동물 프로젝트에 착수하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 내 간단한 계산기에 관한 작은 비디오\n\n# 내 간단한 계산기를 확인해 보세요","ogImage":{"url":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png"},"coverImage":"/assets/img/2024-05-20-CheckoutmySimpleCalculatorImportanceofdoingPetprojects_0.png","tag":["Tech"],"readingTime":1},{"title":"웹 개발에 필요한 내용들 전반적으로 소개","description":"","date":"2024-05-20 23:02","slug":"2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT","content":"\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만들고 유지 보수하는 동적이고 끊임없이 발전하는 분야입니다. 이 블로그에서는 웹 개발의 개요를 제공하고 프론트엔드, 백엔드, 풀스택 개발 간의 차이를 살펴보며 필수 도구와 기술을 소개할 것입니다. 이 분야에 처음 발을 딛는 초보자이든, 지식을 업데이트하고자 하는 경험 많은 개발자이든, 이 안내서가 안정적인 기반을 제공할 것입니다.\n\n![웹 개발 소개](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png)\n\n웹 개발은 웹 사이트 및 웹 애플리케이션을 만드는 모든 활동을 포괄합니다. 코딩 및 마크업, 스크립팅, 네트워크 구성, CMS(콘텐츠 관리 시스템) 개발 등이 모두 포함됩니다. 주요 목표는 기능적이고 사용자 친화적이며 시각적으로 매력적인 사이트를 만드는 것입니다.\n\n- 웹 디자인: 웹 사이트의 레이아웃, 색상 구도, 타이포그래피, 전반적인 사용자 경험(UX) 및 사용자 인터페이스(UI) 디자인과 같은 미학적 측면을 다룹니다.\n- 웹 콘텐츠: 웹사이트에서 사용자 경험의 일부로 만나는 텍스트, 시각적 또는 청각적 콘텐츠를 말합니다.\n- 클라이언트 측 스크립팅: 사용자의 웹 브라우저에서 실행되는 코드를 작성하여 상호 작용성과 사용자 경험을 향상시킵니다. HTML, CSS, JavaScript와 같은 기술이 일반적으로 사용됩니다.\n- 서버 측 스크립팅: 서버에서 실행되고 데이터베이스와 상호작용하며 사용자 인증을 처리하고 사용자에게 웹 페이지를 제공하는 코드를 작성하는 것을 말합니다. PHP, ASP.NET, Node.js, Python과 같은 기술이 널리 사용됩니다.\n- 데이터베이스 관리: 웹 애플리케이션을 위해 데이터를 저장하는 데이터베이스를 생성하고 관리하는 작업입니다. MySQL, PostgreSQL, MongoDB와 같은 인기있는 데이터베이스가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발은 일반적으로 프론트엔드, 백엔드 및 풀스택 개발 세 가지 주요 범주로 나뉩니다. 각각은 기능적인 웹 애플리케이션을 구축하는 데 중요한 역할을 합니다.\n\n프론트엔드 개발, 또는 클라이언트 측 개발로도 알려져 있으며 사용자가 직접 상호작용하는 웹 사이트 부분에 초점을 맞춥니다. 이는 사용자가 웹 브라우저에서 보거나 상호작용하는 모든 것을 포함합니다. 레이아웃, 버튼, 이미지 및 폼 등이 포함됩니다.\n\n- HTML (Hyper Text Markup Language): 웹 페이지를 생성하는 데 사용되는 표준 마크업 언어로, 웹의 내용을 구조화합니다.\n- CSS (Cascading Style Sheets): HTML로 작성된 문서의 표현을 설명하는 스타일시트 언어로, 레이아웃, 색상, 폰트 및 전반적인 스타일을 제어합니다.\n- JavaScript: 상호작용적인 웹 페이지를 만들 수 있는 프로그래밍 언어로, 동적 콘텐츠 생성, 멀티미디어 제어, 이미지 애니메이션 등 다양한 용도에 사용됩니다.\n- 프론트엔드 프레임워크 및 라이브러리: React, Angular, Vue.js와 같은 도구를 사용하여 재사용 가능한 컴포넌트와 효율적인 상태 관리를 제공하여 프론트엔드 개발을 단순화하고 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드 개발 또는 서버 측 개발은 웹 사이트의 서버 측에 초점을 맞춥니다. 이는 데이터를 처리하고 전면에서 의도한 대로 작동하도록 하는 메커니즘을 생성하고 유지하는 작업을 포함합니다. \n\n- 서버 사이드 언어: Python, Ruby, Java, PHP, C#과 같은 언어들이 서버 측 로직을 작성하는 데 일반적으로 사용됩니다.\n- 프레임워크: Express(Node.js), Django(Python), Ruby on Rails(Ruby), ASP.NET(C#)과 같은 프레임워크는 견고한 백엔드 애플리케이션을 개발하기 위한 구조와 도구를 제공합니다.\n- 데이터베이스: MySQL, PostgreSQL, MongoDB, SQL Server 등의 데이터베이스는 웹 애플리케이션의 데이터를 저장하고 관리합니다.\n- API (Application Programming Interfaces): RESTful 및 GraphQL API는 전면 및 백엔드 간, 백엔드 서비스 간의 통신을 활성화하는 데 사용됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_2.png\" /\u003e\n\n풀 스택 개발은 개발자가 웹 애플리케이션의 전면 및 백엔드 부분 모두에 작업하는 포괄적인 접근 방식을 의미합니다. 풀 스택 개발자는 넓은 스킬 세트를 갖추고 프로젝트를 처음부터 끝까지 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기술:\n\n- 프론트엔드 및 백엔드 기술 능숙\n- 데이터베이스 및 데이터 관리 이해\n- Git과 같은 버전 관리 시스템에 대한 이해\n- API 작업 및 다른 서비스 통합 능력\n\n숙련된 웹 개발자가 되기 위해서는 다양한 도구와 기술에 익숙해져야 합니다. 여기 몇 가지 필수 요소가 있습니다:\n\n텍스트 편집기 및 통합 개발 환경(IDE): Visual Studio Code, Sublime Text, IntelliJ IDEA와 같은 도구는 코딩에 효율적인 환경을 제공합니다.\n버전 관리 시스템: Git은 가장 인기 있는 버전 관리 시스템이며, GitHub, GitLab, Bitbucket과 같은 플랫폼은 협력 개발과 코드 공유를 용이하게 합니다.\n패키지 관리자: npm(Node Package Manager)와 yarn과 같은 도구는 프로젝트 의존성 및 라이브러리를 관리하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- HTML/CSS/JavaScript: 웹 페이지를 구축하고 스타일링하는 데 필수적인 핵심 기술들입니다.\n- 프런트엔드 프레임워크/라이브러리: React, Angular, Vue.js는 동적 사용자 인터페이스를 구축하는 데 인기 있는 선택지입니다.\n- 반응형 디자인: Bootstrap 및 Foundation 같은 프레임워크는 반응형 및 모바일 친화적인 디자인을 도와줍니다.\n\n- 서버 사이드 언어: JavaScript (Node.js), Python, Ruby, Java, C#과 같은 언어들이 있습니다.\n- 백엔드 프레임워크: Express (Node.js), Django (Python), Ruby on Rails (Ruby), ASP.NET (C#) 등이 있습니다.\n- 데이터베이스: MySQL, PostgreSQL와 같은 SQL 데이터베이스와 MongoDB와 같은 NoSQL 데이터베이스가 있습니다.\n\n- 버전 관리: Git과 GitHub 같은 플랫폼입니다.\n- 작업런너 및 모듈 번들러: Gulp, Grunt, Webpack과 같은 도구들은 반복적인 작업을 자동화하고 JavaScript 파일을 번들링하는 데 도움이 됩니다.\n- API 테스팅 도구: Postman 및 Insomnia는 API를 테스트하고 디버깅하는 데 유용합니다.\n\n웹 개발은 다양한 기술과 지식을 요구하는 다각적인 분야입니다. 프런트엔드, 백엔드 및 풀스택 개발의 차이를 이해하고 필수 도구와 기술에 익숙해지면 능숙한 웹 개발자로 나아갈 수 있습니다. 앞으로의 블로그에서는 웹 개발의 각 측면을 더 자세히 살펴보며 실전 예제와 상세한 설명을 제공하여 견고하고 동적인 웹 애플리케이션을 만드는 과정을 안내할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png"},"coverImage":"/assets/img/2024-05-20-1INTRODUCTIONTOWEBDEVELOPMENT_0.png","tag":["Tech"],"readingTime":4},{"title":"Tailwind CSS로 가독성 좋은 웹사이트 만드는 방법","description":"","date":"2024-05-20 23:01","slug":"2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS","content":"\n\n\n![Tips for Writing Maintainable and Readable Code with Tailwind CSS](/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png)\n\n웹 개발에서 깔끔하고 확장 가능한 코드베이스를 유지하는 것은 매우 중요합니다. 특히 대규모 프로젝트에서 스타일을 관리할 때는 더욱 그렇습니다. Tailwind CSS는 유용성이 우선인 CSS 프레임워크로, 애플리케이션을 효율적으로 스타일링하는 구조화된 방법을 제공합니다. 그러나 모든 도구와 마찬가지로, Tailwind의 장점을 최대로 발휘하려면 최상의 관행을 준수해야 합니다. 아래에서는 유지보수 가능하고 가독성 있는 Tailwind CSS 코드를 작성하는 핵심 전략에 대해 실용적인 예제를 통해 살펴봅니다.\n\n## 유틸리티 클래스의 일관된 순서\n\nHTML 요소에서 유틸리티 클래스의 일관된 순서를 유지하면 스타일을 쉽게 스캔하고 수정할 수 있습니다. 예를 들어, 표시 속성(display: flex, grid)으로 시작하여 위치 지정 (m, p), 그 다음에 글꼴 (text-, font-), 마지막으로 색상 및 그림자와 같은 코스메틱 스타일로 끝나는 규칙을 정의하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n이 예시에서는 레이아웃 속성(flex, flex-col)이 먼저 정의되고, 간격(p-4, md:p-8), 배경(bg-white), 그림자(shadow-lg), 그리고 둥근 모서리(rounded-lg)가 따릅니다. 타이포그래피 속성 (text-2xl, font-bold, text-gray-900)은 텍스트 요소에 적용됩니다.\n\n## 반응형 접두사 활용하기\n\n시스템적으로 반응형 접두사를 사용하면 스타일이 기기에 맞게 신속하게 적응합니다. 항상 가장 작은 브레이크포인트부터 시작하여 일관성을 유지하면서 작업해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n이 `div`는 텍스트 크기를 뷰포트 너비에 따라 조정합니다. 텍스트 크기는 모바일에서 `text-base`부터 태블릿에서 `text-lg`, 데스크톱에서 `text-xl`로 증가합니다.\n\n## 반복되는 유틸리티 패턴에 @apply 활용\n\n다양한 컴포넌트에서 동일한 유틸리티 클래스 조합을 반복적으로 사용할 때, @apply 지시문을 사용하여 CSS 파일에서 이를 결합하여 중복을 줄일 수 있는 사용자 지정 클래스로 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n여기서 일반 버튼 스타일링은 .btn-primary 및 .btn-secondary 클래스로 추상화되어 HTML을 깔끔하고 집중할 수 있습니다.\n\n## 복잡한 컴포넌트용 컴포넌트 클래스 구현\n\n더 복잡한 컴포넌트의 경우 특정 컴포넌트 클래스를 만드는 것이 더 실용적일 수 있습니다. 이렇게 하면 세부 스타일을 캡슐화할 수 있으면서도 작은 조정에 유틸리티 클래스를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n이 예시에서는 .card 클래스가 모든 일반적인 스타일을 다루며, 유틸리티 클래스는 카드 내의 요소에 직접 추가하여 특정 조정을 할 수 있습니다.\n\n## PurgeCSS 통합\n\nPurgeCSS를 빌드 프로세스에 통합하면 실제로 사용되는 스타일만 제작 파일에 포함되어 파일 크기가 크게 줄어듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구성은 PurgeCSS를 설정하여 HTML 및 Vue 파일을 스캔하여 최종 CSS에서 사용되지 않는 Tailwind 클래스를 제거합니다.\n\n# 결론\n\nTailwind CSS에 대한 이러한 모범 사례를 채택하면 코드의 가독성과 유지 관리성뿐만 아니라 응용 프로그램의 전반적인 성능도 향상됩니다. 일관된 패턴을 설정하고 내장 유틸리티를 지능적으로 활용하며 깨끗한 코드베이스를 유지하여 개발자는 Tailwind CSS의 강력함을 완전히 활용하여 멋진 효율적인 웹 인터페이스를 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png"},"coverImage":"/assets/img/2024-05-20-TipsForWritingMaintainableandReadableCodewithTailwindCSS_0.png","tag":["Tech"],"readingTime":3},{"title":"웹사이트 속도와 품질 테스트하기","description":"","date":"2024-05-20 22:55","slug":"2024-05-20-TestingWebsiteSpeedAndQuality","content":"\n\n\n![Speed and Quality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png)\n\n웹 사이트나 애플리케이션의 속도, 크기 및 효율성은 사용자뿐만 아니라 백엔드에서도 가장 중요한 요소 중 하나입니다. 큰, 뚱뚱하고 부풀어 올라간 코드베이스는 프레임워크 팬보이들의 반대 주장에도 불구하고 작업이 어려워지며, 초과 서버 부하를 초래합니다.\n\n접근성 및 효율성 컨설턴트로 프리랜싱을 하면서 지난 15년 동안 수많은 웹사이트를 살펴본 적이 있습니다. 이러한 웹사이트들은 매우 낮은 트래픽을 처리하기 위해 고군분투하고 있는 것으로 나타났습니다. 콘텐츠와 기능이 $10/mo VPS보다 더 필요하지 않은 매니지드 전용 호스팅 계획으로 다중 프로세서 비용이 많이 드는 것입니다.\n\n그러나 가장 끔찍한 것은 해당 사이트들이 \"반드시 그렇게\" 되어야 하는 무수한 엘리베이터들이다. \"기업용 등급\"이라고 주장하며 (\"그게 실제로 무엇을 의미하는지. \"바보들이기 때문에 쓰레기인가 봅니다\"); \"협업을 위해 필요한 코드를 십 배로 작성해야한다\" 또는 \"새로운 입사자를 빠르게 숙달\" 시킬 필요가 있다고 주장하는 등 자신의 무능함을 덮기 위한 모든 헛소리와 함께. 내 이전 기사의 댓글을 다시 읽어보면 많은 귀찮은 변명들을 볼 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n살인범은 빠른 웹사이트를 만드는 것이 어렵지 않다는 것이 가장 중요한데요. 그에 대해 이전에 글을 썼었습니다:\n[여기를 클릭하세요!](https://medium.com/codex/so-you-want-to-make-your-website-faster-d2a00db39097)\n\n하지만 기존 웹사이트의 속도를 분석하는 것은 대부분의 사람들이 처리하기 어려운 기술을 요구합니다. HTML, CSS를 알고 있고 관심을 가지고 있다면 쉬울텐데요. 안타깝게도, 프레임워크를 사용하는 바보들, 백엔드 개발자들이 프런트엔드를 다룰 수 있다고 속이는 사람들, \"웹 디자이너\"라는 착각에 빠진 예술가들, 전체 과정에 대한 큰 문제를 일으키는 많은 다른 사람들이 거의 제로로 기술합니다.\n\n이를 해결해보겠습니다.\n\n# 추천 도구\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자동화는 일반적으로 플레이스보로 사용됩니다. 머리 속에 있는 것을 활용하지 않으면 정확하지 않습니다. 모든 것이 약간의 출발점으로 사용할 수는 있지만 그것이 하는 일을 큰 그릇으로 받아들여야 한다는 것이죠.\n\nGoogle Lighthouse은 대부분의 Blink 기반 Chrome과 유사한 브라우저(Chrome, Vivaldi, Opera, \"최신\" Edge 릴리스)의 검사 도구로 내장되어 있습니다. Lighthouse는 속도, 사용성, 접근성, 이미지 최적화, 파일 형식과 관련된 여러 문제를 지적할 수 있습니다. 아마도 우리에게 주어진 최고의 자동화 도구일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그러나\n\n저는 등대가 수백 개의 개별 파일로 구성된 2MB 페이지에 100% 완벽한 속도 점수를 주는 것을 본 적이 있고, 동시에 6개 이하의 파일로 만든 50k 페이지에는 50%의 점수를 주었습니다. 물론 등대가 제시하는 내용을 사용하여 최적화하는 것을 권장하지만, 페이지가 빠른지 여부를 확인하는 데는 좋은 도구가 아니라고 생각합니다. 이 도구는 페이지가로드된 후에 \"렌더(render)\"와 같은 것을 과대평가하고 파일 수와 크기를 지나치게 과소평가합니다.\n\n예를 들어, 이 FailwindUI 쓰레기 코드를 살펴보십시오:\nhttps://spotlight.tailwindui.com/about\n\n이는 26개 파일에서 615k이며, 압축 해제하면 218k로 감소됩니다. 따라서 파일 수만으로 최악의 경우 18초의 오버헤드가 발생합니다. 실제 세계에서는 3초 정도로 설명하겠습니다. 그런데 왜 이러는 걸까요? 1.4k의 일반 텍스트와 하나의 콘텐츠 미디어(우주 비행사 이미지)인가요? 심지어 파일 9개로 52k도 안 되는 일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐시를 활용하지 않도록 작성되었고, 효율성을 덮어두려는 것보다는 \"아무것도 아닌 SPA\"로 스크립트를 던져 처리하려고 하며, 이는 \"더 많은 코드를 던져 더 빠르게 만들 수 있다\"는 어리석음의 전형입니다.\n\n그럼에도 불구하고, 이것의 라이트하우스 점수는 무엇인가요?\n\n![텍스트](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_2.png)\n\n저는 \"성능\"을 주면서 60점을 줄 것입니다. 그런데 왜 그렇게 후하다고 생각하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라이트하우스는 실제 세계의 제한 없이 당신의 연결 속도와 그들의 연결 속도에 기반을 두고 있어요. 광섬유의 마법 땅에 있는 우리에게는 어떤 쓰레기도 꽤 괜찮은 점수를 얻을 수 있어요.\n\n하지만 그 기준으로 대부분을 가리킴을 살펴보세요. 전송 시간은 심지어 나열되지 않았어요. First paint, contentful paint? 그것은 렌더링이죠. 최적화하기에 유용하지만, 확실히 페이지 속도의 전부가 아니에요.\n\n이것은 이전 게시물을 위해 한 페이지의 리라이트를 사용하여 명백해져요: https://cutcodedown.com/for_others/medium_articles/failwindUI/shotlightFull/about.php\n\n여기에서 라이트하우스 점수가 거의 동일합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![TestingWebsiteSpeedAndQuality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_3.png)\n\n전송 크기의 1/5이지만 파일 개수의 1/4, DOMContentReady에 도달하는 시간은 1/3로 단축되며 서브 페이지에 대한 사전 캐싱을 활용하여 SPA / CSR JavaScript의 90%가 무의미한 코드 팽창으로 소멸되는 경우가 있습니다...\n\n그러나 통계와 마케팅을 진지하게 검토하는 사람들이 이 두 숫자를 매우 심각하게 받아 듭니다. 사용자가 사이트를 3초 안에 포기할 수 있다는 사실을 알기 때문입니다! 4초 이상이면 25% 이상의 탈퇴 위험이 있으며, 그 이후로매초마다 16%가 증가합니다.\n\n탈퇴란 사용자가 \"이건 말아먹겠다. 다른 데 가야지!\" 하는 것을 비하한 용어입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 접속 속도가 관련이 있는 것 뿐만 아니라 속도 점수는 도구가 만들어진 시간에 다른 웹 사이트와 상대적으로 기반을 두고 있습니다. 따라서 웹이 만들어진 시점에 좋지 않았다면, 어떤 시점을 넘어서면 더 나은 것이 있다고 말할 \"여력\"이 없습니다.\n\n또한 이러한 높은 평가를 개발자로서 우리 스스로에게 돌릴 수도 있습니다. 두 예제 모두 저 트래픽 환경에서 운영되며 괜찮은 호스팅 환경에서 작동합니다. 이 데모 템플릿들이 다뤄야 할 연결 제한, 서버 부하 또는 다른 여러가지 실제 웹 사이트에서 다뤄야 하는 것들과 부딪히지 않습니다.\n\n그래서 라이트하우스에 대해서는 \"수리해야 할 것을 수리하라\"고 말합니다. 그것은 그런 일에 대한 놀라운 도구입니다. 그 수리를 하면 페이지가 더 빨라지고 더 접근 가능해질 것입니다. 그저 \"100 성능\" 평가를 신뢰하지 마세요. 이것은 실제 사이트 속도의 좋은 지표가 아닙니다.\n\n## 파이어폭스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Testing Website Speed and Quality](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_4.png)\n\n브라우저는 속도 평가에 중요한 부분입니다. 자동화를 믿지 말고 실제 브라우저에서 실제 환경에서 테스트하는 것이 더 현명합니다.\n\n각 브라우저 엔진은 파티에 자신만의 특별한 도구를 가져옵니다. 파이어폭스의 검은 네트워크 탭은 실제 파일 크기를 보여줍니다. 압축된 크기뿐만 아니라 실제 크기를 보여주죠. 크롬 같은 세부사항은 보여주지 않습니다!\n\n파이어폭스에서 페이지를 로드하고 문서 인스펙터를 열려면 마우스 오른쪽 버튼을 클릭하고 \"검사\"를 선택하거나 F12를 누르세요 — 그 안에 탭이 나타납니다. 위의 FailwindUI 템플릿을 사용하여 \"네트워크\" 탭으로 이동하고 캐시를 지우고 페이지를 다시 로드하세요: CTRL-F5\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_5.png)\n\n우리는 모든 파일에 대한 \"폭포수\"를 얻습니다. 기본 정렬 순서는 파일이 로드된 순서이며, 오른쪽의 그래프에서는 지연, 핸드셰이킹, 전송 시간을 보여줍니다. 두 가지 파일 크기를 얻을 수 있습니다: 실제 파일 크기 및 전송될 때의 크기. 후자의 숫자는 일반적으로 파일이 gzip 압축으로 전송된 경우 더 작을 것입니다.\n\n푸터에 있는 정보도 중요합니다. DOMContentLoaded는 브라우저가 페이지 렌더링을 시작하기에 충분한 정보를 갖고 있다고 판단하는 시간이며, \"로드\"는 기본적으로 렌더링이 완료된 시점입니다. 자주 JavaScript의 로드 후 파일이 있을 수 있으며, 이는 Reflow를 강제할 수도 있습니다(결과적으로 불편한 동작이 발생할 수 있음) 또는 사용자가 아직 수행하지 않은 조치를 위해 로드될 수 있습니다.\n\n또한 파비콘은 항상 페이지가 \"완료\"된 후에 로드됨을 기억해 주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사람들이 종종 내게 물어보는 질문 중 하나는 내가 얼마나 많은 파일이 로드되었는지 또는 총 크기가 얼마인지를 어떻게 알 수 있는지이다. 여기 있습니다.\n\n## Chrome처럼\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_6.png)\n\n속도 테스트에 대한 가장 큰 실수 중 하나는 자기 연결이 \"일반 사람들이 얻는 것\"을 대표한다고 믿는 것입니다. \"하지만 내게는 빠르다\"란 오류로 이어집니다. 여러분은 항상 내가 말하는대로 알고 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신과 당신의 마법 같은 판타지 세계의 네트워크 연결이나 완벽한 5G 수신만이 중요한 건 아니에요, 다른 사람들도 중요한 거예요.\n\n특히 바보 같은 사람들이 그런 사용자들을 \"가난뱅이\"라고 불러서 더욱 짜증스러울 수 있어요. 실제로 그냥 '계급 전쟁'으로 빠지는 거죠.\n\n따라서 연결을 인위적으로 제한하면, 허위 인식을 없앨 수 있어요. 안타깝게도 Firefox의 네트워크 탭은 연결 제한이 활성화되면 종종 페이지의 하위 파일을 다시로드하지 않을 수 있어요. 그러면 제한하는 의미가 없어지죠. 그래서 Chrome과 비발디(Vivaldi)와 같은 브라우저의 동등한 기능을 사용해야만 해요. 그렇게 하면 됩니다. 저의 일상용 운전사람이에요.\n\n파일 크기를 실제로 보여주지 않지만, 테스트 단계에서 우리는 실제로 전송되는 것에 더 관심이 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 툴바 아래에 \"스로틀링 없음\"이라고 쓰인 드롭다운이 있어요. 그 드롭다운의 기본 값은... 좀 부족해요.\n\n그래서 보통 이런 설정을 추가해서 \"실제 세계\"를 시뮬레이션해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_9.png\" /\u003e\n\n다운로드 속도 2 Mbits, 업로드 속도 512kbits, 지연 시간 200ms입니다. 패킷 손실은 걱정하지 마세요. 이것은 우리의 요구를 충분히 제한할 것입니다.\n\n이 속도 제한으로 동일한 네트워크 폭포도를 가져올까요?\n\n\u003cimg src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_10.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게 끔찍하게 보이지는 않을 수도 있어요 — 25개 요청이 있는 병렬처리는 여전히 많은 나쁜 선택지들을 집어삼키고 있답니다. 하지만 그래서 연결 제한을 조절할 수 없는 자동화에 대해 우리 스스로 속임수를 부리고 있는 것 아닐까 싶어요. 그래도 제가 쓴 것과 비교해보세요:\n\n![image](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_11.png)\n\n어쨌든, 저는 한 가지 방안을 제안해요 — Blink(크롬과 비슷한 엔진)과 Gecko(파이어폭스, 아이스위젤 등) 모두를 사용해보세요. 호환성 뿐만 아니라 속도와 도구 사이의 차이점을 테스트하기 위해서죠. 네트워킹 워터폴은 여러분의 친구입니다. 여러분의 로드 순서에서 병목 현상이 발생하는 곳을 정확히 파악하는 데 도움이 될 거예요.\n\n# 페이지스피드 인사이트: 비추천!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"구글 '페이지속도'는 한때 — 10년이 넘게 전— 유용한 도구였습니다. 그러나 그 이후로 그 저의는 희석되었고, 오도된, 오해되고, 오늘날에는 사실보다는 플래이스보로 여겨지고 있습니다. 어느 순간에는 마케팅 사기 같은 느낌까지 들었죠!\n\n그 하락 추세는 실질적인 해를 가져오는 요소에 중점을 두기 시작했을 때 시작되었습니다. 이에 대한 한 예로 '페이지의 폴드 위' CSS를 마크업에 넣는 어리석은 방법이 있습니다. 이것은 '캐시를 비우는 첫 번째 로딩'을 가속화할 수 있지만, Bootcrap이나 Failwind 같은 멍청한 쓸모없는 쓰레기의 비용을 지불하게 됩니다. 예를 들어, 지연된 HTTP 병렬성, 하위 페이지 전체에 걸쳐 공유하는 스타일에 대한 사전 캐싱 기회의 놓침, 재방문 시 캐싱 놓침 등이 있습니다. 'text-center col-4-s col-6-m text-400-red'와 같은 클래스가 무식한 헛소리라는 것과 마찬가지로 정적 마크업에 'style' 태그의 순수 존재도 무식한 헛소리라고 말할 수 있습니다. 주목할 점은 그게 마크업 안에 있다는 것이며, 페이지 로드 후 스크립팅 전용 스타일로 추가되는 것에는 문제가 없습니다.\n\n그리고, 문서 검사기는 소스/마크업을 표시하지 않습니다. 그것은 DOM을 보여줍니다!\n\nPageSpeed에 나쁜 조언이 스며들기 시작할 때 그것들이 끌어 당겼던 상황이 확실해졌습니다. 우리에게 유용한 도구를 제공하여 우리를 중독시킨 후, \"페이지속도 서비스\"라는 우리를 속이려는 쓰레기 'CDN 대체'를 이용하도록 조장하는 마케팅 플랫폼으로 사용했습니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"서비스\" 라는 말은 고객을 정말로 섬기고 있습니다. \"속도\"를 불필요하게 느린 것을 고쳐 사용할 수 없는 클라이언트 측 스크립팅의 꼬마 조각들로 만드는 동시에 그렇지 않으면 건강한 사이트를 운영하는 데 더 비싼 방향으로 만들고 있어요!\n\n사기, 사기, 사기 같은 말을 자주 쓰는 건 알아요... 하지만 정말… 제발요.\n\nGoogle PageSpeed가 말하는 거 하나 믿지 말라고 권하고 싶네요. 라이트하우스가 비슷한 운명을 맞이하지 않기를 바랄 뿐이에요.\n\n# 진정 중요한 것은 무엇인가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도구가 무엇인가를 알려준다고 해서 항상 그 의미를 완전히 이해한다는 것은 아니에요. 마찬가지로, 자동화된 도구는 주로 시작하는 지점이며 여전히 올바르게 사용하기 위해 약간 자신의 뇌를 사용해야 합니다. 라이트하우스의 숫자를 보고 \"괜찮아\"라고 생각하기가 너무 쉽습니다. 심지어 그렇지 않을 때도요.\n\n실제로 걱정해야 할 세 가지 주요 요소가 있어요. 도구들은 당신이 가진 것을 말해줄 뿐, 꼭 필요한 것이나 여전히 문제가 있는지를 반드시 알려주진 않아요.\n\n## #1 대역폭과 파일 크기\n\n이것은 가장 쉽게 평가하고 문제 해결할 수 있는 부분이에요. 또한, 무능한 사기꾼들이 때때로 \"모두가 이제 브로드밴드를 갖고 있다\"고 사측적으로 무시하거나 피할 다른 쓸데없는 변명을 찾기 때문에 그들이 가장 쉽게 무시하는 부분 중 하나에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 \"무시\"의 실제 예시로 최근 다른 프로그래머가 내가 개선할 때 \"최적\" AVIF 대신 PNG 사용했어야 했다며 화를 내서 몹시 화를 내는 상황이 있었습니다. 20k를 절약할 수 있었다고 했죠. 그는 내가 \"허튼 소리만 한다\"는 예시로 사용했습니다. 전 그냥 2.5 메가바이트의 \"아무 의미없는\" JS를 12k의 코드로 교체했다는 사실을 완전히 무시했습니다. 더구나 해당 클라이언트는 의료 시설로, IE7이 최첨단이었던 Win ME 기반의 얇은 클라이언트를 사용하고 있습니다. IE에서 AVIF나 webp는 지원되지 않습니다.\n\n많은 개발자들은 반복적으로 자신의 HTML, CSS 및 JavaScript 크기를 무시하면서 대역폭을 절약하기 위해 가능한 모든 자동화를 시도합니다. 그래서 무능한 jQuery, Tailwind, Bootstrap과 같은 것들이 위험한 이유입니다. 제가 계속 강조해 온 것처럼:\n\n사실 미디어 파일 - 오디오, 비디오, 이미지 - 가 코드보다 세 배 이상이나 작아지는 것이 흔해졌습니다. 그 중 대부분의 책임은 JavaScript의 몫입니다. 또한 며칠전에도 말한 바 있듯이, jQuery로 수행된 것 중 세 가지 범주에 속하지 않는 것은 본 적이 없습니다:\n\n- JavaScript 없이 할 수 있는 HTML 및 CSS 작업\n- jQuery 없이 더 간단하고 코드가 적은 작업\n- 웹사이트나 어플리케이션에서 하면 안 되는 작업들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제는 JavaScript를 사용하여 80% 이상을 수행하는 작업에 대해서도 확장해야 한다고 생각합니다. Typescript와 같은 Transpiler는 출력 코드의 크기가 얼마나 크든 상관하지 않고, 더 복잡하고 유지보수하기 어려운 코드를 작성하도록 장려합니다; React나 Angular와 같은 쓸데없는 프런트엔드 프레임 워크가 서버의 \"잘못된 쪽\"에서 작업을 수행함; 모달 대화 상자나 햄버거 메뉴와 같은 스크립팅 요소를 사용하여 `esc` 키를 눌러 닫히도록 하는 일이 정말 필요한 일인데도 불구하고 1k가 딱 헤더에 들어가도록 presentational한 디자인이 해결되어 있는 것처럼 표시하지 않습니다.\n\nBootcrap나 Failwind와 같은 프런트엔드 프레임워크 쓰레기통과 같은 무능한 재앙도 마찬가지 입니다. 이러한 것들을 사용하도록 속이거나, 사용하지 않았을 때보다 훨씬 더 많은 코드를 작성할 수 있게끔 꾀어냅니다; HTTP 병렬 처리를 지연시키며, 캐싱 기회를 놓치게 하며, 작업을 수행하는 데 필요한 코드 양의 2배에서 10배까지 배포합니다.\n\n그리고 사람들이 \"Simple Jack\"이 멋진 여자 앞에서 마주하는 것 처럼 자신들의 사이트나 앱이 느리다고 궁금해 할 때도 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_12.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모든 것에 대해 생각하는 것은 자동화된 도구가 사람들을 잘못된 안전감에 빠트리고 있다는 점이라고 생각해요. 이미지 최적화, 파일 축소? 모두 좋고 필요한 작업이죠. 하지만 거기서 멈추어선 안 돼요!\n\n코드 부풀림; 의존성 지옥; 아무 의미 없는 파일들을 위해 개별 파일; 아무 의미 없는 파일을 위한 통합 파일 (모든 것을 마크업에 넣는 것 같은 행위); 아무 의미 없는 추가 함수들. 지금 대부분의 쓰레기를 만드는 사람들의 능력에 대해 의문을 제기하게 되는 부분들이 점점 더 성능, 지속 가능성, 유지 관리성과 관련하여 더욱 걱정되는 부분이죠.\n\n의미 있는 그림이 나타나기 전에 HTML의 크기와 스크립팅이 얼마나 큰지는 아마도 가장 중요한 파일들 중 하나이자 무시되는 부분일 수도 있어요. 왜냐하면 HTTP 병렬성을 연기하고 캐싱 기회를 놓치고 있기 때문이거든요.\n\nFF와 Chrome과 같은 워터폴을 보세요. 문서가 완료될 때까지 다른 것들이 로딩 될 수 없다는 것을 보세요. 저의 계산기 데모에서 가져온 것들 처럼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하위 파일이 HTML 작성이 완료될 때까지 다운로드를 시작할 수 없습니다. 그리고 HTTP 2.0 푸시 또는 HTML 5 사전로드 / 모듈 사전로드도 이를 해결하지 못합니다! 다른 사람들이 말하는 대로라고 주장할 수 있을지라도.\n\n그래서 HTML 파일에 불필요한 것들을 넣을수록( \"text-large text-center text-400-red\"와 같이) 다른 모든 파일의 다운로드를 지연시키며, HTTP가 여러 파일을 동시에 전송할 수 있는 능력을 최대한 활용할 수 없게 됩니다. (여러 패킷이 A지점에서 B지점 사이의 다른 경로를 통해 이동할 수 있기 때문입니다)\n\n같은 스타일을 여러 페이지에 걸쳐 공유할 경우 캐싱 기회를 놓치게 됩니다. 각 방문뿐만 아니라 같은 방문 내에서 페이지 간에도 캐싱이 가능한 외부 파일로 모든 것을 이동시킬 수 있는데, 이러한 부분이 CSS가 존재하는 이유입니다. 스타일을 정적으로 설정하는 것이 아니라 마크업에서 \"style\"을 지정해야하며 외관을 고르게 만들기 위해 \"style = \"\"을 사용해야 합니다. 그리고 \"이 것은 작은 화면에 4열, 큰 화면에는 6열로 중앙 정렬된 텍스트와 빨간색으로 표시되는 것\"을 나타내는 클래스가 무지하고 무능력한 반대표! 프레임워크뿐만 아니라 전체 \"컴포넌트\"의 어리석은 사고도 물어뜯어야 합니다. HTML 3.2 이해의 최전선이 미래가 되어서는 안됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아니요, \"원자적\"이나 \"유틸리티\" 클래스가 얼마나 무지하고 불행하며 쓸모 없는 쓰레기인지 정말로 표현할 수 있는 공손한 말은 없습니다.\n\nHTML의 미리 정의된 태그들이 의미를 갖기 때문에, 관심사의 분리를 실천하면 실제로 콘텐츠와 목적에 따라 HTML의 크기를 추정할 수 있습니다... 적어도 대부분의 전통적인 웹 페이지에 대해 해당합니다. 저는 다음 공식을 사용합니다 (모든 값은 바이트 단위)\n\n2048 +\n일반 텍스트 * 1.5 +\n앵커 (또는 A의 작업을 하는 버튼) * 192 +\n폼 요소 (input, select, textarea, option) * 128 +\n미디어 (img, video, audio) * 256\n\n2k는 `!DOCTYPE`에서 `/head`까지의 모든 것이 포함되어야 하는 상한선이며, 콘텐츠 당 50% 비용은 완전히 합리적입니다. 192는 URL이나 INPUT/TEXTAREA/SELECT/OPTION 크기에 대한 관대한 추정치이며, 미디어 요소에 대한 256바이트 역시 그러한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보통 견적을 50% 이상 초과하면 페이지에 문제가 있습니다. 그러면 이를 두 배 이상 초과하면, 웹 기술과 전혀 관련이 없는 사람들이 만든 무식하고 무능한 쓰레기입니다.\n\n웃기게도, 웹 앱이라면? 4k. 플랫. 그 이유는 마크업에 있는 건 헤더 안의 내용(스타일시트 로드, 프리로드, 제목), 'script' 로드, 그리고 'noscript' 경고뿐이어야 하기 때문입니다. 당신의 \"마크업\"이 스크립팅이 있는 상태에서만 기능한다면, 그것을 블러디 HTML이 아닌 스크립트에 구축하세요!\n\n\"일반 텍스트\"를 가져오는 방법이 궁금하다면, 그냥 HTML 없는 페이지 텍스트를 의미합니다. 바로 'body' 내의 모든 CDATA (문자 데이터)입니다. 기존 페이지에서 그것을 추출하는 가장 쉬운 방법은 브라우저에서 열고, CTRL-A를 눌러 전체 선택한 후, CTRL-C로 복사하고, 그것을 평문 편집기에 CTRL-V하여 얼마나 많은 텍스트가 있는지 확인하는 것입니다.\n\n퇴보한 부트스트랩의 가격표 페이지를 예로 들어 보겠습니다:\nhttps://getbootstrap.com/docs/5.3/examples/pricing/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n평문 888바이트, 앵커(또는 버튼) 20개 및 미디어 요소 하나를 포함하고 있어야 할 텐데, 그렇게 되면 5,428바이트가 되겠네요. 그들은 어느 정도의 HTML을 사용했을까요? 17.3k! 사람들은 내가 그들의 무능한 쓰레기를 계속해서 비난하는 이유에 대해 궁금해할 것입니다.\n\n몇 년 전에 쓴 것을 고려해보세요:\nhttps://cutcodedown.com/for_others/medium_articles/bootStrapRewrites/pricing/pricing.template.html\n\n이는 HTML을 올바르게 사용하며, 마크업에 형식화 클래스를 주입하지 않습니다. 그 결과 5,528바이트에 불과합니다. 나의 공식이 제공한 \"대략값\"과 거의 일치하죠.\n\nCSS도 상당히 예측 가능합니다. 사이트의 단일 페이지에 대해 약 20k 정도가 대체로 정상이지만, 전체 사이트에 대해서는 공유되어야 하는 스타일 양 때문에 미디어 대상에 대한 상한선은 48k입니다. 많은 웹 사이트에서 필요로 하는 것은 48k으로 media=\"screen\"용 하나 또는 두 개의 파일이고, 대체로 인쇄의 역할은 쓸모없는 것들을 제거하고 단색으로 가기 때문에 media=\"print\"용 32k의 CSS로도 충분합니다. 전체 사이트에 대해서 말이죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스크린과 인쇄용으로 총 80k가 넘는 CSS 파일이 세 개나 네 개 필요 없어. 그거야!\n\n...그리고 왜 저 부끄럽고 무식한 것들이 있는 부트크랩 페이지는 엉성하고 느리고 작업하기 힘든 말도 안 되는 것으로 만들어졌는지, 웹 기술을 사용하는 방법을 아는 게 아닌 사람들에 의해 만들어졌다! (Failwind도 마찬가지야!). 어떻게 말해야 할까?\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_13.png)\n\n그렇게 말이야. 부트크랩은 압축 시 최소한 전체 사이트의 2/3는 되는데, 왜냐하면 계속해서 마크업에 당신을 허술하게 만들기 때문이야? 압축하지 않았을 때, 그들의 라이브러리가 아닌 CSS는 14k이며, 그것들을 합쳐도 전체 페이지는 HTML+CSS로 32k이야... 즉, 현재 단일 페이지이며, 그들의 독특한 코드 — 부트스트랩을 제외한 것 —은 10.3k인 내 리라이트와는 달리 세 배가 돼. 그들의 단독 HTML만 해도, 나와 비교하면 HTML과 CSS 합쳐도 70%가 더 커! \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게하면 체중이 늘어나고, 느려지며 유지보수하기 어려운 웹사이트가 되어버릴 거예요. 사용성과 접근성을 무시하는 결과는 더할 나위 없는 형편입니다.\n\n계속해서 언급했듯이:\n\n그리고 그 증거는 숫자 속에 있어요. 숫자에 대해 이야기해보겠습니다...\n\n## #2 파일 개수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n페이지에 있는 별도 파일 수는 로드 시간에 막대한 영향을 줄 수 있습니다. 경우에 따라 전체 파일 크기보다 더 많은 영향을 미칠 수도 있죠!\n\nFTP를 사용해 본 적이 있다면 100개의 별도 1k 파일을 전송하는 데 단일 100k 파일을 전송하는 것보다 훨씬 오래 걸린다는 것을 알아챌 수 있을 겁니다. 이는 서버와 시스템이 파일이 있는지, 작성해야 하는지, 이미 캐시되어 있는지 등을 계속 확인하며 소통하는 \"핸드셰이킹\" 오버헤드에서 비롯됩니다. HTTP도 동일한 문제를 겪지만, 병렬 처리(동시에 여러 전송)를 활용하여 패널티를 줄이고, HTTP 2 푸시 및 HTML 5 사전로드와 같은 새로운 기술을 사용하여 문제를 더욱 완화할 수 있습니다.\n\n하지만 이 문제가 마술처럼 사라진다는 것은 아닙니다.\n\n이제 일부 사람들은 \"모든 것을 한 파일에 모아놓으면 왜 안 되지?\"라고 과도하게 반응하기도 합니다. 사실 많은 사람들이 이 방식을 취하고 있지만, 해당 방법은 많은 문제를 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 하나의 파일에 모든 것이 들어 있고 하위 페이지가 동일한 데이터를 공유하는 경우 - 표현 이미지, 아이콘, 메뉴, 헤더, 푸터, 일반 스타일링 - 서브 페이지에 대해 캐싱/미리로드를 하지 않습니다. 각 페이지 로드마다 이를 로드해야 하기 때문에 서브 페이지의 속도를 희생하는 것입니다. 캐시가 비어 있는 첫 번째 로드를 위해 속도를 포기합니다.\n- HTTP의 파일 병렬로 로드하는 능력을 활용하고 있지 않습니다. 이는 단일 연결이 가질 수 있는 \"속도 제한\"을 피할 수 있습니다.\n- 이는 서버가 동적 페이지를 구성하는 데 더 많은 노력을 들게 만듭니다.\n\n다른 말로 하면 Bootstrap, Tailwind, HTMX 및 수십 개의 기타 \"나도 인터넷 할 수 있어요\" 개발과 같은 어리석은 문제입니다.\n\n파일의 수를 줄이려고 하지 않는 이유는 없습니다. 다른 것처럼 지나칠 수도 있습니다. 캐싱 등을 위해 별도의 파일이 필요하지만 핸드셰이크 오버헤드 때문에 페이지 로드 속도가 느려지는 개별 파일이 너무 많아서도 안됩니다.\n\n푸시 또는 프리로드를 사용하지 않는 경우, 좋은 규칙은 첫 번째 여덟 개의 파일이 \"무료\"라는 것입니다. 그 이후의 각 파일은 실제로 200ms의 현실적인 벌칙을 받습니다. 최악의 경우 일부 사람들은 1초정도까지 느낄 수도 있습니다. 따라서 48개의 별도 파일로 이루어진 전통적인 \"올드 스쿨\" 페이지는 8부터 40초의 핸드셰이킹 오버헤드를 볼 수 있습니다. 이는 80% 이상의 이탈 영역입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알겠어요, 20ms 정도로 더 적은 숫자가 나올 수도 있어서 즉시 통신 중단은 아니지만, 그건 서버나 주요 백본에 가깝다는 뜻이에요. \"당신의 일이 아니니까\"라고 다시 말하자면, 여러분 모두에게 영향을 미치는 거잖아요.\n\n푸시/사전로드를 사용하면 초기 HTML 파일과 동일한 연결에서 핸드셰이킹이 처리돼요. 이렇게 하면 이러한 파일에 대한 핸드셰이킹 오버헤드가 없어져요... 어느 정도, 말이에요.\n\n이 더 최신 기술을 사용할 때는 주의를 기울여야 해요. 조금은 수익이 줄어들 수도 있답니다. 브라우저 구현 문제인지, 시간이 많이 걸리는 것인지 잘 모르겠지만, 파일이 8개를 넘어가면 효과가 크게 떨어진다고 해요. 그래서 푸시/사전로드를 사용할 때는 다음과 같이 제한하는 것을 제안해요:\n\n- media=\"screen\" CSS(하나 또는 두 개의 파일이어야 함)\n- 외부 JavaScript(세 개 또는 네 개의 파일로 제한)\n- 웹폰트\n- \"대규모\" 배경 이미지와 같은 중요한 정적 요소들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 목록에서 4번 항목은 정말 필요없는 항목이에요. 하지만 난 ‘디자이너’를 자칭하는 예술적인 사람들이 그런 종류의 사물을 좋아하는 걸 알아요. 기본적인 디자인 지식이 없더라도요. 그리고 rel=\"modulepreload\"도 있어요. 이건 새로운 \"JavaScript 모듈\"과 함께 사용되지만, 로딩에 제한이 없어 보여요. 서버가 허용하는 한 전송/연결을 많이 사용할 수 있는 이유를 알아내기 위해 더 많이 실험을 해봐야 할 것 같아요.\n\n하지만 서버나 브라우저가 처리할 수 있는 연결에는 한계가 있다는 걸 기억해야 해요. 서버에 트래픽이 많을수록 사용자에게 유지할 수 있는 연결이 점점 줄어들게 돼요. Google, Xitter, 또는 Facebook과 같은 큰 기업들에겐 큰 문제가 아니겠지만, 대부분의 일반적인 사이트 소유자나 기업들에게는 쉽지 않은 문제일 수 있어요.\n\n예를 들어, 한가한 시간대에 근처 캠퍼스의 혼잡한 무료 인터넷에 연결된 상황을 상상해보세요. 혹은 집에서 pooky가 지하실에서 게임과 영화를 얻어다 주는 동안, 부인이 Mando를 보면서 다섯 개의 소셜미디어 사이트를 동시에 스크롤하고 있는 경우… 집의 인터넷 연결 한도는 얼마나 남을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle은 하드웨어를 그냥 투입하는 것만으로 해결할 수 있는 문제도 있지만, 그들은 네트워킹, 프로토콜 및 명세 변경을 추진하여... 최소한으로 줄일 수 있도록 노력하고 있습니다. 오늘날 우리가 HTTP 2.0 푸시라고 부르는 것은 Google SPDY라는 이름으로 출발했습니다. 크롬을 위해 만들지 않고 오픈 소스로 공개하고 HTTP 명세로 적용시킨 덕분에 Google이 절약한 돈은 상당히 많을 것입니다.\n\n우리 모두가 이로 인해 혜택을 받는다구요? 저는 이에 불만을 품지 않겠습니다.\n\n모든 이런 개선 사항에도 불구하고, 일반적인 사이트에 HTML+CSS+JS 파일이 8개 이상, 또는 실제로 애플리케이션이 될만한 \"웹 애플리케이션\"에는 24개의 파일이 넘어간다면, 여러분의 코드는 아마 성능이 좋지 않을 겁니다. 특히 자바스크립트 부분에서 이 코드 한 줄마다 추가 함수를 만들고, 각 함수를 위한 파일을 만드는 것이 \"좋은 행위\"가 된 것에 대해 충격을 받고 있습니다. 정말 부정직한 일이죠!\n\n하지만 전체 파일 수를 효율적으로 관리하는데 도움을 줄 수 있는 기술도 더 많이 있습니다. 가장 고전적인 기법 중 하나인 \"CSS 스프라이트\"는 모든 디자인 이미지/아이콘을 한 이미지에 넣고, 배경으로 적용하고, 배경 위치를 조정하여 원하는 부분만 나타내는 것을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우 SVG 및 웹폰트로 대체되었습니다. 이러한 방법을 사용하면 핸드셰이크 수를 줄일 뿐만 아니라 해상도 감소 없이 어떤 크기에도 완벽하게 확장이 가능합니다.\n\n단색 아이콘이 있다면 \"Font-awesome\"와 같은 폰트에 넣는 것은 여러 아이콘을 한 고작한 파일로 효율적으로 사용할 수 있는 좋은 방법입니다. 다양한 색상 지원이 준비 중이지만 아직은 다소 불안정합니다. 그러나 마크업을 건드리지 않고 색상을 변경하고 싶다면 SVG보다 우수합니다.\n\n일반적으로 아이콘에 대해 SVG를 사용하는 것에는 여러 문제가 있습니다. 가장 큰 문제 중 하나는 대부분의 사람들이 HTML에 그것들을 잘못 넣어 반복해서 사용하며 공유된 페이지 간에 캐시되지 않고 HTTP 병렬성을 지연시킨다는 것입니다. 이 문제의 해결책은 CSS로 이동하여 배경 이미지로 사용하는 것입니다. XML 텍스트이기 때문에 CSS로 쉽게 인코딩할 수 있습니다.\n\n그러나 CSS에 넣었음에도 불구하고 CSS에서 색상을 제어할 수 없고, 반복해서 사용해야 합니다. (필터를 사용하면 몇 가지 귀여운 트릭을 사용할 수 있습니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여전히 SVG 및 웹 폰트는 수백 개의 파일을 하나로 교체하는 능력을 발휘하고 있습니다. 이를테면 캐싱과 병렬성을 희생하지 않고요.\n\n요점은 무엇일까요? 파일 수를 적게 유지하되, 할 일이 도리보다 더 나쁘게 되지 않도록 지나치게 너무 열중하지 마세요.\n\n솔직히 말해서, 이 조언은 대부분 웹 관련 모든 것에 적용됩니다. 사람들은 한 가지 방법을 배우고는 모든 것에 적용하려고 하거나, 어떤 \"속도 향상\" 기술에 대해 듣고 나서는 아무도 그것을 이해하고 싶어하지않아 너무 지나치게 적용하곤 하죠. 그냥 건드리지 않았더라면 하는 것보다 더 많은 피해를 줄 때도 있죠!\n\n## #3 렌더링 시간\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서, 브라우저가 서버에서 검색한 코드를 사용 가능한 페이지로 변환하는 데 소요되는 시간은 충분한 파일이 있는 이후입니다.\n\n이것은 많은 사람들이 나쁜 습관을 정당화하기 위해 사용하는 비열한 수식어로 많이 사용됩니다. 개발자들이 실제로 코드 크기를 두 배나 네 배로 늘려 브라우저가 \"페이지를 렌더링하는 데 소요되는 시간\"을 몇 밀리초 짜내려고 할 때 이 중 가장 나쁜 경우입니다. 그들이 코드 부풀리기로 전체 로드 시간을 더 느리게 만든다는 것에 대해 깨닫지 못합니다.\n\n이것은 \"레이아웃에 테이블을 사용하지 마십시오\"를 \"테이블을 절대 사용하지 말아라!!!\" 라고 하며 변형한 어리석은 구호로 발전한 바보들이 돌아다닌 엽기적인 지들을 향한 가증스럽게 병적인 변명이 되어왔습니다. 그들은 \"테이블은 렌더링하는 데 너무 느리다\"라고 말한 것은 그들의 무지를 정당화하는 겨우란 어림짐작의 변명으로 사용했습니다.\n\n옛날에 웃기며 말한 것처럼:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금, \"렌더 시간\"이 하찮다는 걸 의미하나요? 전혀 아니에요. 그냥 많은 사람들이 그것에 대해 어리석은 부분에 집착한다는 거죠 (라이트하우스가 레이어드 선형 그라디언트에 열광하면서 거대한 이미지 위의 텍스트에는 신경쓰지 않는 것을 보세요), 이것은 방정식에서 아주, 아주 작은 부분일 뿐입니다.\n\n더 나쁜 것은 CSS와 같은 것을 탓하는 사람들이 있지만, 그들은 두 자리 이상의 킬로바이트 업무를 하는 메가바이트의 JavaScript를 가지고 있습니다.\n\n더 많은 코드가 있을수록, 렌더가 시작되기 전에 걸리는 시간이 더 오래 걸립니다. 더 많은 마크업, CSS 규칙 및 스크립팅을 사용할수록 렌더 시간이 더 오래 걸립니다. 그래서 Failwind나 Bootcrap과 같은 어리석음은 비성능적인 쓰레기인 것이죠. 이들은 자신들과는 반대되는 근거 없는 주장을 하지만요.\n\n그리고 확실히 선형 그라디언트, 박스 그림자, 텍스트 그림자 등은 처리 성능과 렌더 시간이 많이 소요되는 것이 사실입니다. 그러나 정적 이미지를 사용하는 것과 비교했을 때, 오래된 하드웨어를 제외하고 모든 것에 대한 소요 시간/오버헤드가 분원인 것을 보면요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n… 그리고 우리는 영원히 \"와 응 응 아이 던즈 워나 스탑 유징 윈블로우즈 XP 앤 머 겟 빈티엄 4\" 사람들을 위해 유연하게 휘어져서 서 있을 수 없어요.\n\n## 내 Tandy 1000SX가 윈도우 XP를 실행할 것을 기대하는 것만큼 터무니없어요.\n\n![이미지](/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_14.png)\n\n완전히 헛소리는 아니지만, 나는 Lighthouse가 당신에게 말하는 대로 해 보라고 말할 거예요... 그래도 명백히 헛소리인 것으로 약간의 성능 점수를 받아도? 어쨌든 그래도 될 거예요. 대부분 \"렌더링\"에서 지연을 초래하는 실제 근본적인 원인들은 다 다루기 쉽기 때문에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM 요소가 너무 많이 있어요. 즉, 마크업을 적게 사용해주세요.\n- CSS 규칙이 너무 많아요. 적은 CSS를 사용하고 모든 것에 클래스를 부착하지 마세요.\n- JavaScript가 너무 많이 사용되었어요. JavaScript 없이 할 수 있는 경우에는 반드시 그렇게 하세요!\n- 파일이 너무 많아요. 렌더링은 \"window.onload\"이 발생하기 전까지 시작할 수 없음을 기억해주세요.\n\n다시 말해서, 제가 거의 모든 기사, 포럼 게시물, 소셜 미디어 등에서 수십 년 동안 계속 말해 온 것들이에요. 그리고 Resig, Otto, Thornton, Wathan과 같은 사기꾼들이 치켜 들고 있는 것들이에요.\n\n# 요약\n\n웹사이트의 90% 이상이 속도에 있어 코드 크기, 코드 복잡성, 개별 파일 수 및 전체 파일 크기 등과 관련이 있어요. 이 중에서 파일 크기는 실제로 지난 10년 동안 가장 큰 문제가 될 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 수를 살펴보세요. HTML 파일의 크기와 전달하려는 실제 내용을 비교해 보세요. 전체 코드 양과 작업과 비교해서 얼마나 많은 코드가 있는지 살펴보세요. 대부분의 \"속도 문제\"는 여기서 기인합니다. 계속 말하고 있는 것처럼, 블라인드로 코드를 복사하거나 붙여넣기하여 \"프레임워크 덤비\"하거나 HTML, CSS, JavaScript를 제대로 사용하는 가장 기본적인 개념에 대한 무지의 결과입니다.\n\n텍스트 4k와 이미지 1다스를 전달하기 위해 4십 때의 파일에 메가바이트의 코드가 있다면, \"여기가 문제의 근원입니다.\" 또한, 기사 작성에 있던 공백에 대해 사과드립니다. 이 기사는 90% 정도 완성된 채로 두 달 동안 오픈 탭에 열려 있었고, 이와 유사한 여러 기사들도 마찬가지였습니다. 지금은 내 일정이 매우 바쁘고 봄/여름이 시작되어 상황이 더욱 악화되고 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png"},"coverImage":"/assets/img/2024-05-20-TestingWebsiteSpeedAndQuality_0.png","tag":["Tech"],"readingTime":20},{"title":"앵귤러 대비 리액트 비즈니스 요구사항에 가장 적합한 프레임워크는 무엇일까요","description":"","date":"2024-05-20 22:53","slug":"2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png\" /\u003e\n\n웹 애플리케이션을 위한 적절한 프레임워크를 선택하는 것은 성공적이고 확장 가능한 제품을 보장하는 데 중요합니다. 다양한 선택지 가운데 Angular와 React는 두 가지 인기 있는 프레임워크로 두드러지며 가장 강력한 옵션입니다. 두 프레임워크는 각각 독특한 장점과 약점을 가지고 있어 귀사의 특정 비즈니스 요구에 매우 의존하게됩니다. 이 블로그에서는 Angular와 React의 주요 차이점, 장단점, 그리고 잠재적인 단점을 살펴보고 정보를 토대로 결정을 내릴 수 있도록 돕겠습니다.\n\n# Angular과 React 이해하기\n\n## Angular\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 구글에서 개발 및 유지보수하는 강력한 프론트엔드 프레임워크입니다. 2010년에 먼저 AngularJS로 출시되었으며 그 이후로 상당한 변화를 거쳐 현재 버전인 Angular 또는 Angular 2+로 불리고 있습니다.\n\n주요 특징:\n\n- 포괄적인 프레임워크: Angular는 데이터 바인딩, 의존성 주입, 강력한 CLI와 같은 내장 기능을 제공하는 완전한 솔루션을 제공합니다.\n- 양방향 데이터 바인딩: 이 기능은 UI의 변경 사항이 즉시 기저 데이터 모델에 반영되고 그 반대도 보장합니다.\n- TypeScript: Angular는 정적 유형을 추가하는 JavaScript의 슈퍼셋인 TypeScript로 개발되었습니다. 이를 통해 코드 품질과 유지보수성이 향상됩니다.\n- 구성 요소 기반 아키텍처: Angular 애플리케이션은 재사용 가능한 구성 요소를 사용하여 개발을 더 체계적이고 확장 가능하게 만듭니다.\n\n## React\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact는 Facebook이 개발한 JavaScript 라이브러리로 사용자 인터페이스를 구축하는 데 사용됩니다. 2013년에 출시된 이후 React는 그 간단함과 유연성으로 매우 인기가 높아졌습니다.\n\n중요 기능:\n\n- 가상 DOM: React는 변경된 부분만 업데이트하여 렌더링 성능을 최적화하기 위해 가상 DOM을 사용합니다.\n- 일방향 데이터 바인딩: React의 일방향 데이터 바인딩은 데이터 흐름을 더 잘 제어하며, 애플리케이션을 디버그하기 쉽게 만듭니다.\n- JavaScript XML (JSX): React는 JSX를 사용하며, JavaScript 내에서 HTML과 유사한 코드를 작성할 수 있어 코드의 가독성과 구조를 향상시킵니다.\n- 컴포넌트 기반 아키텍처: Angular와 유사하게, React도 재사용 가능한 컴포넌트의 사용을 촉진합니다.\n\n# Angular와 React 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 학습 곡선\n\nAngular: Angular은 포괄적인 성격으로 인해 학습 곡선이 가파릅니다. TypeScript 및 복잡한 구문에 익숙해져야 합니다. 의존성 주입, 서비스 및 RxJS와 같은 프레임워크의 포괄적인 기능 및 개념은 초보자에게 혼란스러울 수 있습니다.\n\nReact: React는 부드러운 학습 곡선으로 유명합니다. JavaScript에 익숙한 개발자는 빠르게 React를 시작할 수 있습니다. JSX의 간결함과 재사용 가능한 컴포넌트 구축에 대한 집중으로 새로운 개발자들이 학습하고 사용하기 쉬워집니다.\n\n## 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular: Angular의 성능은 미리 컴파일(AOT) 및 트리 쉐이킹을 통해 최적화되었습니다. 그러나 양방향 데이터 바인딩과 프레임워크의 복잡성 때문에 때로는 React와 비교하여 성능이 느릴 수 있습니다.\n\nReact: React는 가상 DOM을 사용하여 효율적인 업데이트와 렌더링을 보장하여 높은 성능을 제공합니다. 일방향 데이터 바인딩은 데이터 흐름을 간소화하여 더 나은 성능을 제공합니다.\n\n## 유연성과 확장성\n\nAngular: Angular는 완전한 프레임워크로, 필요한 모든 것을 제공합니다. 일관된 구조가 필요한 대규모 애플리케이션에 유용할 수 있습니다. 그러나 Angular의 방식을 따르도록 개발자가 제한될 수 있어 유연성이 제한될 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact: React은 더 큰 유연성을 제공하여 개발자가 라우팅, 상태 관리 및 기타 기능에 대해 자체 라이브러리 및 도구를 선택할 수 있습니다. 이 모듈식 접근 방식은 아키텍처에 대한 더 많은 제어를 제공하여 확장 가능한 응용 프로그램을 구축하는 데 유용할 수 있습니다.\n\n## 커뮤니티 및 생태계\n\nAngular: Angular는 Google의 강력한 후원을 받고 강력한 커뮤니티를 갖고 있습니다. 방대한 문서와 다양한 제삼자 라이브러리와 도구를 제공합니다. 그러나 때로는 React와 비교하면 프레임워크의 생태계가 덜 다이나믹할 수 있습니다.\n\nReact: React는 Facebook의 지원을 받은 크고 활발한 커뮤니티를 자랑합니다. 다양한 제삼자 라이브러리, 도구 및 풍부한 자습서와 리소스가 포함된 풍부한 생태계를 제공합니다. React의 인기는 지속적인 업데이트와 혁신을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례\n\n**Angular:** Angular은 기업급 애플리케이션, 복잡한 SPA(Single Page Application) 및 많은 내장 기능 및 일관된 아키텍처를 필요로 하는 애플리케이션을 구축하는 데 이상적입니다.\n\n**React:** React는 동적 및 대화형 UI, 점진적 웹 앱 및 고성능 및 유연성이 필요한 애플리케이션에 적합합니다. React Native와 결합하면 모바일 앱 개발에도 좋습니다.\n\n# 확장 가능한 솔루션을 위한 적절한 프레임워크 선택: 황제 브레인을 위한 비교 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular: 종합적인 특성과 내장된 기능으로 Angular은 견고한 프레임워크와 광범위한 기능이 필수적인 프로젝트에 적합합니다. 이는 기업급 응용 프로그램 및 복잡한 SPA에 이상적입니다. Angular의 구조화된 아키텍처는 조직화되고 확장 가능한 개발이 필요한 부분과 조화를 이루며, 고품질 솔루션을 제공하는 Emperor Brains의 목표와 일치하는 전문적인 접근을 반영합니다.\n- React: React의 유연성과 성능 최적화는 동적이고 인터랙티브한 사용자 인터페이스, 점진적 웹 앱 및 확장성과 혁신이 중요한 시나리오에 적합합니다. React의 모듈식 접근 방식은 Emperor Brains의 개발자들이 프로젝트별 최적의 도구와 라이브러리를 활용할 수 있도록 하며, 선순환적이고 적응력 있는 전략에 부합합니다.\n\nEmperor Brains는 종합적인 프레임워크와 내장된 기능, 일관된 아키텍처를 요구하는 프로젝트에 Angular을 고려하는 것이 유리할 것입니다. 반면에 React는 고도의 유연성, 성능 최적화, 사용자 인터페이스 디자인에서의 혁신이 필요한 프로젝트에 적합합니다. 최종적으로 Angular와 React 중 선택은 특정 프로젝트 요구사항, 확장성 요구사항 및 개발팀의 전문성과 부합해야 합니다.","ogImage":{"url":"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png"},"coverImage":"/assets/img/2024-05-20-AngularvsReactWhichFrameworkisBestforYourBusinessNeeds_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular로 컴포넌트 만드는 방법","description":"","date":"2024-05-20 22:51","slug":"2024-05-20-AngularAdvancedComponents","content":"\n\n\n![Screenshot](/assets/img/2024-05-20-AngularAdvancedComponents_0.png)\n\n# 안녕하세요 여러분,\n\n오늘은 우리의 작업을 더 쉽게 만들어주는 Angular의 두 가지 데코레이터, ViewChild와 ViewChildren에 대해 이야기하겠습니다.\n\nAngular의 ViewChild와 ViewChildren 데코레이터는 컴포넌트 내에서 요소에 접근하기 위해 사용되는 특별한 데코레이터입니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n태그를 Markdown 형식으로 변경해 보겠습니다.\n\n## ViewChild\n\n는 컴포넌트 클래스 내에서 DOM에 있는 객체를 나타낼 수 있게 해주는 데코레이터입니다. 이론적으로 설명할 때는 조금 지루해 보일 수 있지만, 실제 예시로 넘어가 봅시다.\n\n![Image](/assets/img/2024-05-20-AngularAdvancedComponents_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 구성 요소를 만들었고 Child1Component로 이름을 지었습니다. 기본적으로 셀렉터에는 'app-child1'이라는 값이 할당됩니다. 이 값을 사용하면 HTML 태그를 사용하여 메인 컴포넌트의 HTML에서 이 컴포넌트를 호출할 수 있습니다.\n\n![image](/assets/img/2024-05-20-AngularAdvancedComponents_2.png)\n\n그런 다음, 주 컴포넌트(app)에서 컴포넌트1을 호출하고 가져옵니다. 이처럼 `app-child2 #h``/app-child2` `br` 이렇게 하죠.\n여기서 볼 수 있듯이 'h' 값으로 DOM 개체를 표시하고 있습니다. 이렇게 함으로써 주요 컴포넌트에 접근하고 있습니다.\n\n이제 어떻게 진행해야 합니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 의도는 이 표시된 DOM 객체에 우리의 데코레이터를 적용하는 것이었죠, 맞나요? 네, 지금 그것을 하러 가보겠습니다.\n\n\n![Angular Advanced Components](/assets/img/2024-05-20-AngularAdvancedComponents_3.png)\n\n\nViewChild 데코레이터를 사용하면 주요 컴포넌트 아래에서 원하는 값으로 표시된 DOM 객체에 개입할 수 있습니다. ElementRef 타입으로 표시된 것이기 때문에, 우리는 이 방법으로 'h' 값을 사용해 DOM 객체를 포착합니다.\n\n지금까지 좋은가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 예시에서는 또 다른 예시를 보실 수 있습니다. 걱정하지 마세요, 완전히 동일한 동작을 수행합니다. 다만 이번에는 이 DOM 객체에 컴포넌트를 통해 접근하고 있습니다. 같은 방식으로 child1Component와 Child1Component 유형으로 이 값을 캡처합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-AngularAdvancedComponents_4.png\" /\u003e\n\n이제 'static'이 무엇을 의미하는지 궁금하신가요? 간단히 설명드리겠습니다.\n\nstatic: true는 프로그램이 실행될 때 이 값이 필요한 DOM 객체(컴포넌트)가 생성되어야 함을 나타냅니다. 제 말이 무엇을 의미하는지 궁금하시면, 예시를 통해 설명해 드리도록 하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경되었습니다.\n\n\n![Angular Advanced Components 5](/assets/img/2024-05-20-AngularAdvancedComponents_5.png)\n\n인터넷 사이트에서 양식 프로세스를 상상해보십시오. 해당 양식 작업을 수행할 의도가 없는 사용자에게 양식을로드하는 것은 비용을 증가시키고 사용자에게 느린 경험을 제공할 수 있습니다. 따라서 사이트가 열릴 때 설정해야 하는 DOM 객체에 대해서는 그 옆에 'true' 값을 반환합니다. 그러나 예제와 같은 양식 프로세스의 경우 'false' 값을 반환하는 것이 더 논리적일 것입니다.\n\n![Angular Advanced Components 6](/assets/img/2024-05-20-AngularAdvancedComponents_6.png)\n\n이제 이것을 이해했으니 계속해보겠습니다...\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 DOM에서 데코레이터를 사용하여 다른 작업을 수행하는 방법에 대해 궁금하다면, 한 가지 속성에 대해 알려드릴게요. 좀 더 심화된 접근 방식에서는, 우리는 컴포넌트 내에 제공된 제공자를 통해 컴포넌트에 액세스할 수 있습니다. 이를 통해 제공자에서 지정된 데이터에 액세스할 수 있게 됩니다.\n\n이것을 read라고 부릅니다. 아래에 표시된 것처럼, 이 속성을 사용하여 컴포넌트의 제공자를 통해 액세스된 DOM 객체에 필요한 작업을 수행할 수 있습니다.\n\n![이미지 1](/assets/img/2024-05-20-AngularAdvancedComponents_7.png)\n\n![이미지 2](/assets/img/2024-05-20-AngularAdvancedComponents_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이거도 얻었어요! 조작은 어디로 가나요??\n\n이렇게 캡처한 후에는 컴포넌트 내에서 이러한 객체에 필요한 작업을 수행합니다. 일반적으로 이는 ngOnInit() 및 ngAfterViewInit() 두 가지 특별한 함수를 통해 수행됩니다.\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_9.png)\n\n여기서는 간단히 콘솔에 로그를 기록했지만, 필요에 따라 컴포넌트 내에서 이러한 객체에 대해 필요한 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 다른 질문이 있어요: 왜 이 모든 것이 한 함수에 없는 거죠? 이러한 함수들의 차이는 무엇인가요? 간단히 설명해 드릴게요. 폼 프로세스의 맥락에서 생각해 보세요:\n\nngOnInit 함수는 프로그램이 실행되기 시작할 때 호출되며, 시작할 때 수행해야 하는 초기 프로세스를 호출하는 데 사용됩니다.\n\n반면에 ngAfterViewInit은 폼이 필요할 때 호출할 함수로 생각할 수 있습니다. 이를 바탕으로, `false`로 표시된 데코레이터는 ngOnInit 함수로 호출할 수 없다고 말할 수 있습니다.\n\n# ViewChildren\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n특정 컴포넌트 내에서 특정 유형의 모든 요소에 액세스하는 데 사용됩니다. 다시 말해, 하나의 컴포넌트 내에서 여러 자식 컴포넌트에 액세스하려고 할 때 사용됩니다.\n\n이러한 개념을 설명한 후에는 지금 무슨 일이 일어나고 있는지 충분히 이해했을 것으로 믿습니다. :D 명확한 그림이 그려졌는지 확인하기 위해 예제를 제공하겠습니다. 그런 다음 더 이상 문제가 되지 않을 것입니다.\n\n아래에서 생성한 세 개의 컴포넌트가 있다고 가정해 봅시다. 이 세 개는 모두 동일한 공급자를 가지지만 다른 값을 갖습니다. 이를 어떻게 처리할 수 있을까요? 즉시 설명해 드리겠습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-AngularAdvancedComponents_10.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_11.png)\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_12.png)\n\n그런 다음 사용하는 모든 구성 요소를 가져와야합니다. 아래에서 볼 수 있듯이 모든 구성 요소에는 동일한 \"h\" 태그가 있습니다.\n\n![이미지](/assets/img/2024-05-20-AngularAdvancedComponents_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5번째 예제에서 확인할 수 있듯이, 같은 'h' 값을 가진 모든 요소를 캡처하기 위해 @ViewChildren을 사용했습니다. 그런 다음 ‘read’ 속성을 사용하여 이러한 구성 요소 내부의 값을 읽고 'list' 변수에 저장했습니다. 보시다시피 QueryList로 모든 값을 캡처하여 데이터 유형을 지정했습니다. 그리고 이제 원하는대로 조작할 수 있습니다. :)\n\n\u003cimg src=\"/assets/img/2024-05-20-AngularAdvancedComponents_14.png\" /\u003e\n\n결론적으로, Angular에서 강력한 데코레이터 @ViewChild와 @ViewChildren을 탐구했습니다. 이들을 사용하여 구성 요소 내의 요소와 상호 작용하고 조작할 수 있는 방법을 이해했습니다. 실제 예제를 통해 이러한 데코레이터를 사용하여 DOM 요소에 액세스하고 특정 시나리오에 기반한 작업을 수행하는 방법을 알아보았습니다. 또한, 고급 조작을 위한 구성 요소 제공자를 통한 'read' 속성에 대해 다뤄보았습니다.\n\n더 많은 고급 주제로 계속 읽어주셔서 감사합니다!!","ogImage":{"url":"/assets/img/2024-05-20-AngularAdvancedComponents_0.png"},"coverImage":"/assets/img/2024-05-20-AngularAdvancedComponents_0.png","tag":["Tech"],"readingTime":5}],"page":"62","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"62"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>