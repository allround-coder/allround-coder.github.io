<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/7" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/7" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular에서 꼭 알아야 할 RxJS 연산자들" href="/post/2024-06-23-RxJSOperatorsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 꼭 알아야 할 RxJS 연산자들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 꼭 알아야 할 RxJS 연산자들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 꼭 알아야 할 RxJS 연산자들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" href="/post/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular Reactive Forms setValue와 patchValue 함수 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular Reactive Forms setValue와 patchValue 함수 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" href="/post/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" href="/post/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular에서 Firebase 인증 사용하는 방법" href="/post/2024-06-23-Firebaseauthenticationinangular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular에서 Firebase 인증 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular에서 Firebase 인증 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular에서 Firebase 인증 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular HttpClient와 Signals를 연결하는 방법" href="/post/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular HttpClient와 Signals를 연결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular HttpClient와 Signals를 연결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular HttpClient와 Signals를 연결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v15에 Google Analytics 추가하는 방법" href="/post/2024-06-23-AddingGoogleAnalyticstoAngularv15"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v15에 Google Analytics 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v15에 Google Analytics 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 커스텀 파이프 사용 방법" href="/post/2024-06-23-AngularCustomPipes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AngularCustomPipes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 커스텀 파이프 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 커스텀 파이프 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" href="/post/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" href="/post/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link posts_-active__YVJEi" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular에서 꼭 알아야 할 RxJS 연산자들","description":"","date":"2024-06-23 14:10","slug":"2024-06-23-RxJSOperatorsinAngular","content":"\n\nRxJS 연산자는 Angular의 강력한 기능으로, 데이터 스트림을 조작하고 변환할 수 있는 기능입니다. Observable과 함께 사용하여 데이터를 필터링, 매핑, 축소하고 기타 작업을 수행할 수 있습니다.\n\n파이프 연산자(Pipeable Operator)는 Observable을 입력으로 받아 다른 Observable을 반환하는 함수입니다. 이는 순수한 작업입니다: 이전 Observable은 변경되지 않습니다.\n\n다음은 Angular에서 자주 사용되는 몇 가지 RxJS 연산자 예시입니다:\n\n- map: 이 연산자는 observable에서 방출되는 데이터를 변환하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 observable이 있다면, 각 숫자의 값을 두 배로 만들기 위해 map 연산자를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nimport 'of' from ‘rxjs’;\n\nimport 'map' from ‘rxjs/operators’;\n\n![Image 1](/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png)\n\n![Image 2](/assets/img/2024-06-23-RxJSOperatorsinAngular_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- filter : 이 연산자는 옵저버블에서 방출된 데이터를 필터링하는 데 사용됩니다. 예를 들어, 숫자 스트림을 방출하는 옵저버블이 있다면, filter 연산자를 사용하여 짝수만 방출할 수 있습니다:\n\n```javascript\nimport { of } from ‘rxjs’;\nimport { filter } from ‘rxjs/operators’;\n```\n\n![RxJS Operators in Angular](/assets/img/2024-06-23-RxJSOperatorsinAngular_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_3.png)\n\n- mergeMap: 이 연산자는 여러 개의 옵저버블을 하나의 옵저버블로 병합하는 데 사용됩니다. 예를 들어 데이터 스트림을 방출하는 두 옵저버블이 있다면 mergeMap 연산자를 사용하여 두 스트림을 하나로 병합할 수 있습니다:\n\nimport { of } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-23-RxJSOperatorsinAngular_4.png)\n\n![이미지2](/assets/img/2024-06-23-RxJSOperatorsinAngular_5.png)\n\n- forkJoin: RxJS의 forkJoin 연산자는 여러 옵저버블이 완료될 때까지 기다린 다음 각 옵저버블이 발행한 마지막 값의 배열을 방출하는 데 사용됩니다. 이 연산자는 여러 요청을 동시에 수행하고 모든 요청이 완료된 후에만 작업을 수행해야 할 때 유용합니다.\n\n아래는 Angular에서 forkJoin을 사용하여 여러 HTTP 요청을 수행한 다음 결과를 결합하는 예시입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nimport { forkJoin, of } from 'rxjs';\n\nimport { HttpClient } from '@angular/common/http';\n\nconstructor(private http: HttpClient) {}\n\n![RxJS Operators in Angular 6](/assets/img/2024-06-23-RxJSOperatorsinAngular_6.png)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 HttpClient 모듈을 사용하여 두 개의 HTTP 요청을 보냈고 forkJoin 연산자를 사용하여 두 요청이 완료될 때까지 기다렸습니다. 그런 다음 구독(subscribe) 메서드를 사용하여 결과를 처리하는데, 이는 두 요청에서 마지막으로 방출된 값들의 배열입니다.\n\n또한 forkJoin은 observables의 배열을 사용할 수도 있으므로 2개 이상의 요청을 기다리는 데 사용할 수 있습니다.\n\nforkJoin은 여러 요청이 완료될 때까지 기다려야 하는 경우 유용한 연산자이며, 코드를 더 읽기 쉽고 유지 관리하기 쉽게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- switchMap: RxJS의 switchMap 연산자는 옵저버블에서 방출되는 값들을 주어진 함수를 적용하여 새로운 옵저버블로 평탄화하는 데 사용됩니다. 이 연산자는 현재 옵저버블의 값에 따라 요청을 만든 다음 값이 변경되면 새로운 옵저버블로 전환할 때 유용합니다.\n\n다음은 Angular에서 switchMap을 사용하여 검색 입력란에 입력된 텍스트를 기반으로 서버에서 사용자를 검색하는 방법의 예시입니다:\n\n![이미지](/assets/img/2024-06-23-RxJSOperatorsinAngular_8.png)\n\n위 예시에서 fromEvent는 사용자가 검색 입력란에 타이핑할 때 이벤트를 방출하는 옵저버블을 만드는 데 사용되고, debounceTime 연산자는 사용자가 타이핑을 멈출 때까지 기다렸다가 값을 방출하는 데 사용됩니다. distinctUntilChanged 연산자는 값이 변경될 때만 값을 방출하고, 마지막으로 switchMap은 http 요청에 의해 생성된 새로운 옵저버블로 전환하는 데 사용됩니다. 각 새로운 keyup 이벤트마다 이전 요청이 취소되고 새로운 요청이 수행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`switchMap`는 현재 observable 값에 기반하여 새로운 observable로 전환해야 하는 시나리오를 처리하는 데 사용할 수 있는 강력한 연산자입니다. 새 값이 발행될 때 과거 요청을 취소하는 데 유용합니다.\n\n- **concatMap**: RxJS에서 Observable을 해체하여 각 값에 대해 매핑 함수를 적용하고, 그 결과 Observables를 발행된 순서대로 연결하는 연산자입니다. 배열의 각 항목에 대해 HTTP 요청을 만들기 위해 `concatMap`을 사용하는 예시가 다음에 나와 있어요:\n\n![2024-06-23-RxJSOperatorsinAngular_9.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_9.png)\n\n![2024-06-23-RxJSOperatorsinAngular_10.png](/assets/img/2024-06-23-RxJSOperatorsinAngular_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제는 관찰 가능한을 만들기 위해 from을 사용하여 숫자 1, 2, 3을 방출합니다. 그런 다음 concatMap 연산자를 사용하여 각 숫자를 URL에서 JSON 객체를 가져오는 HTTP 요청으로 매핑합니다. 결과 관찰 가능은 숫자가 방출된 순서대로 JSON 객체를 방출할 것입니다.\n\n이것은 RxJS에서 사용 가능한 많은 연산자 중 일부 예시에 불과합니다. 이러한 연산자를 조합하여 다양한 사용 사례를 처리하는 강력하고 표현력 있는 데이터 파이프라인을 만들 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n계속 학습하려면 저를 따라 주세요!","ogImage":{"url":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-RxJSOperatorsinAngular_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular Reactive Forms setValue와 patchValue 함수 사용 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions","content":"\n\nsetValue() 및 patchValue() 함수는 Angular에서 반응형 폼 컨트롤을 채우는 데 사용됩니다. 두 함수의 사용 사례가 다릅니다.\n\n다음의 반응형 폼 예제와 함께 두 함수가 동작하는 방식을 이해해보겠습니다.\n\n```js\nmyForm: FormGroup;\n\nconstructor(private fb: FormBuilder) {}\n\nngOnInit() {\n  this.myForm = this.fb.group({\n    firstName: ['', Validators.required],\n    lastName: ['', Validators.required],\n    email: ['', [Validators.required, Validators.email]],\n  });\n}\n```\n\n- setValue() 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsetValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  setValueExample() {\n    this.myForm.setValue({\n      firstName: 'John',\n      lastName: 'Doe',\n      email: 'john.doe@example.com',\n    });\n  }\n```\n\nsetValue() 함수는 폼의 모든 컨트롤을 업데이트하고 싶을 때 사용됩니다. setValue() 함수를 사용할 때에는 모든 컨트롤 값을 제공해야 하므로 부분 데이터가 있는 경우나 폼의 모든 컨트롤을 채우고 싶지 않은 경우에는 이 함수를 사용할 수 없습니다.\n\n2. patchValue() 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npatchValue() 함수는 반응형 폼 컨트롤의 값을 설정하는 데 사용됩니다.\n\n```js\n  patchValueExample() {\n    this.myForm.patchValue({\n      firstName: 'UpdatedFirstName',\n      lastName: 'UpdatedLastName',\n    });\n  }\n```\n\npatchValue() 함수는 반응형 폼의 모든 컨트롤을 업데이트하고 싶지 않을 때 사용됩니다. 폼의 일부 컨트롤만 채우고 싶을 때 사용됩니다.\n\n예를 들어, 폼에 선택 사항 입력란이 하나 있고 사용자가 해당 입력란을 작성하지 않았을 때, 이 값을 데이터베이스에 null 또는 빈 문자열로 저장할 수 있습니다. 따라서 폼 컨트롤을 채울 때 이 입력 컨트롤을 업데이트하거나 채우고 싶지 않을 수 있습니다. 이럴 때 patch value를 사용할 수 있습니다. 이 함수를 사용하면 부분 폼 컨트롤을 채울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발자들은 사용 사례 시나리오에 따라 두 함수를 모두 사용합니다. setValue() 함수는 양식의 모든 컨트롤을 필수적으로 채우려 할 때 사용하고, patchValue() 함수는 양식의 일부 컨트롤만 채우려 할 때 사용합니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png"},"coverImage":"/assets/img/2024-06-23-AngularReactiveformssetvalueandpatchvaluefunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates","content":"\n\n\n![Angular 17 Release](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png)\n\nAngular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.\n\n이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.\n\n다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (user.isHuman) {\n  \u003chuman-profile [data]=\"user\" /\u003e\n   @for (skill of user.skills; track $index) {\n     \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n   } @empty {\n    \u003cspan\u003e기술이 추가되지 않았습니다.\u003c/span\u003e\n   }\n} @else if (user.isRobot) {\n  \u003c!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. --\u003e\n  @defer {\n    \u003crobot-profile [data]=\"user\" /\u003e\n  }\n} @else {\n  \u003cp\u003e프로필을 알 수 없습니다!\u003c/p\u003e\n}\n```\n\n## @if 블록 조건\n\n@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.\n\n```js\n@if (loggedIn) {\n  환영합니다 {username}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntable 태그를 Markdown 형식으로 변경할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n}\n\n\n트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.\n\n콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:\n\n![contextual variables](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n} @empty {\n  \u003cspan\u003e 기술이 추가되지 않았습니다.\u003c/span\u003e\n}\n```\n\n## @switch 블록 — 선택\n\n다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@switch (condition) {\n@case (caseA) {\nCase A.\n}\n@case (caseB) {\nCase B.\n}\n@default {\nDefault case.\n}\n}\n```\n\nAngular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.\n\n## Angular에서 @를 선택한 이유는?\n\nAngular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 \"@-구문\"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 \"#-syntax\" 대신 커뮤니티가 제안한 \"@-syntax\"를 선호했습니다.\n\n이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:\n\n![Angular Team Survey](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png)\n\nAngular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 어떤 제어 흐름이 대체될 것인가\n\n- @switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.\n- @for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.\n\n## 구조 지시어에서 마이그레이션\n\n이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ ng generate @angular/core:control-flow\n```\n\n이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:\n\n- **박수**를 치고 작가를 팔로우 해 주세요 👏\n- 저를 팔로우 해 주세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"},"coverImage":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터 전달하는 방법","description":"","date":"2024-06-23 14:07","slug":"2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png\" /\u003e\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 데이터/변수를 전달하는 여러 가지 방법이 있습니다. 가장 흔한 두 가지 방법은 다음과 같습니다:\n\n- @Input 데코레이터 사용\n- 공유 서비스 사용\n\n## 1. @Input 데코레이터 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 방법은 자식 컴포넌트에서 데이터를 수신할 변수를 선언하는 데 @Input() 데코레이터를 사용하는 것입니다.\n\n부모 컴포넌트의 템플릿에서, 속성 바인딩 구문(대괄호)을 사용하여 변수의 값을 자식 컴포넌트의 입력에 바인딩합니다.\n\n예를 들어, 부모 컴포넌트의 템플릿에서:\n\n```js\n\u003c!--parent.component.html--\u003e\n\n\u003capp-child [inputFromParent]=\"data\"\u003e\u003c/app-child\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아이 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cp\u003e{ inputFromParent }\u003c/p\u003e\n  `\n})\nexport class ChildComponent {\n  @Input() inputFromParent: any;\n}\n```\n\n## 2. 공유 서비스 사용\n\n다른 방법은 공유 서비스를 사용하는 것입니다. 공유 서비스는 서로 직접적으로 관련이 없는 컴포넌트 간에 데이터를 공유하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부모 컴포넌트의 클래스에서:\n\n```js\n// parent.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-parent',\n  template: `\n    \u003capp-child\u003e\u003c/app-child\u003e\n  `\n})\nexport class ParentComponent {\n  constructor(private dataService: DataService) {\n    this.dataService.data = '부모 컴포넌트에서 안녕하세요!';\n  }\n}\n```\n\n자식 컴포넌트의 클래스에서:\n\n```js\n// child.component.ts\n\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cp\u003e{ data }\u003c/p\u003e\n  `\n})\nexport class ChildComponent {\n  data: any;\n  constructor(private dataService: DataService) {\n    this.data = this.dataService.data;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 부모 컴포넌트에서 자식 컴포넌트로 변수를 전달하는 다른 방법이 있을 수 있습니다. 이것들은 기본 접근 방법 중 두 가지에 불과합니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png"},"coverImage":"/assets/img/2024-06-23-HowtopassdatafromparentcomponenttochildcomponentinAngular_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular에서 Firebase 인증 사용하는 방법","description":"","date":"2024-06-23 14:06","slug":"2024-06-23-Firebaseauthenticationinangular","content":"\n\n이 기사에서는 Angular 프로젝트에 Firebase 인증을 Google Single Sign-On (SSO)과 빠르게 설정하는 방법을 제안합니다. 또한 선택한 백엔드에 인증된 요청을 하는 방법도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png)\n\n전체 코드는 여기에서 확인할 수 있습니다: https://github.com/Gabriel2409/demofirebase\n\n# Firebase 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase에 가서 새 프로젝트를 만들어주세요.\n\n## 앱 설치\n\n프로젝트 개요 페이지에서 Web 아이콘을 클릭하거나 +앱 추가 아이콘을 클릭하여 웹 애플리케이션을 추가하세요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열리는 창에서 앱에 이름을 지정하고, 예를 들어 myangularapp처럼 등록해주세요. Firebase 구성을 어딘가에 저장하세요. 다음과 같이 보여야 합니다:\n\n```js\nconst firebaseConfig = {\n  apiKey: \"\u003cfirebase-api-key\u003e\",\n  authDomain: \"\u003cmy-project-id\u003e.firebaseapp.com\",\n  projectId: \"\u003cmy-project-id\u003e\",\n  storageBucket: \"\u003cmy-project-id\u003e.appspot.com\",\n  messagingSenderId: \"\u003cmy-messaging-sender-id\",\n  appId: \"\u003cmy-app-id\u003e\",\n};\n```\n\n프로젝트 설정의 일반 탭(톱니바퀴 아이콘)로 이동하여 아무 때나 앱의 Firebase 구성에 액세스할 수 있음을 유념하세요.\n\n## 인증 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 제품으로 이동한 다음 **인증**을 선택하세요. **로그인 방법**에서 **새로운 제공자 추가**를 클릭하고 Google을 선택하세요. Firebase는 Google과 긴밀하게 통합되어 있기 때문에 별도의 설정이 필요하지 않습니다.\n\n그게 다에요! 이제 Google SSO를 사용하여 Firebase 사용자를 인증할 준비가 되었습니다.\n\n참고: 다른 제공자도 추가할 수 있습니다(예: 이메일/비밀번호, 아래 이미지 참조), 하지만 이 기사에서는 Google SSO에 중점을 두고 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Angular 설정\n\n## 프로젝트 생성\n\n먼저, npm install -g @angular/cli를 사용하여 Angular을 전역으로 설치하세요. 저는 버전 17.0.1을 사용하고 있어요.\n\n그런 다음, demofirebase라는 새 폴더를 만들고 해당 폴더에서 ng new frontend --no-standalone --routing ssr=false을 실행하세요. 이렇게 하면 필요한 파일이 포함된 frontend 폴더가 생성됩니다. 이 단계를 마치면 저장소 구조는 다음과 같아야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndemofirebase\n└── frontend\n```\n\n하나의 추가 패키지가 필요합니다. frontend 폴더에서 npm i @angular/fire 명령어를 실행해주세요.\n\n다음으로, 개발 및 프로덕션을 위한 환경을 생성할 때 ng g environments를 사용합니다.\n이는 src/environments 폴더에 2개의 파일을 생성합니다: environment.development.ts와 environment.ts.\n로컬에서 개발할 때는 environment.ts가 environment.development.ts로 대체되어 environment.ts에서 import를 하면 자동으로 environment.development.ts의 변수들을 사용할 수 있습니다. 이는 angular.json 파일에서 확인할 수 있습니다:\n\n```js\n\"fileReplacements\": [\n    {\n        \"replace\": \"src/environments/environment.ts\",\n        \"with\": \"src/environments/environment.development.ts\"\n    }\n]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase 구성을 environment.development.ts에 붙여 넣으세요.\n\n```js\n// environment.development.ts\nexport const environment = {\n  production: false,\n  // 백엔드에 요청을 보낼 수 있는 가정\n  backendUrl: \"http://127.0.0.1:8000\",\n  // 콘솔에서 가져온 Firebase 구성입니다.\n  // 이것은 민감한 정보가 아님을 주의하세요\n  firebaseConfig: {\n    apiKey: \"\u003cfirebase-api-key\u003e\",\n    authDomain: \"\u003cmy-project-id\u003e.firebaseapp.com\",\n    projectId: \"\u003cmy-project-id\u003e\",\n    storageBucket: \"\u003cmy-project-id\u003e.appspot.com\",\n    messagingSenderId: \"\u003cmy-messaging-sender-id\",\n    appId: \"\u003cmy-app-id\u003e\",\n  },\n};\n```\n\n참고: production용 (environment.ts 파일)으로 가시려면, backendUrl을 배포된 백엔드로, firebaseConfig을 production 구성으로 대체하시면 됩니다. Firebase 프로젝트는 여러 환경을 가질 수 없으므로 환경마다 프로젝트를 생성하는 것이 좋습니다. 지금은 빠른 진행을 위해 더미 값만 사용하셔서 IDE에서 필드 부족으로 에러가 발생하지 않도록 하세요.\n\n```js\n// environment.ts\nexport const environment = {\n  production: true,\n  backendUrl: \"backendUrl\",\n  firebaseConfig: {},\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 모듈(app.module.ts)에 필요한 import 문을 추가하고 애플리케이션을 초기화하세요:\n\n```js\n//app.module.ts\nimport { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { AppRoutingModule } from \"./app-routing.module\";\nimport { AppComponent } from \"./app.component\";\nimport { AngularFireModule } from \"@angular/fire/compat\";\nimport { AngularFireAuthModule } from \"@angular/fire/compat/auth\";\nimport { environment } from \"../environments/environment\";\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    AngularFireAuthModule,\n    AngularFireModule.initializeApp(environment.firebaseConfig),\n    BrowserModule,\n    AppRoutingModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 필요한 컴포넌트와 라우트 생성\n\n첫째로, Google SSO를 위한 컴포넌트를 생성하려면 'ng g c signin'을 사용하고, 랜딩 페이지를 위한 컴포넌트를 생성하려면 'ng g c landing'을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown으로 테이블 태그를 변경하세요.\n\n그럼, app-routing.module.ts을 수정하세요:\n\n```typescript\nimport { NgModule } from \"@angular/core\";\nimport { RouterModule, Routes } from \"@angular/router\";\nimport { SigninComponent } from \"./signin/signin.component\";\nimport { LandingComponent } from \"./landing/landing.component\";\n\nconst routes: Routes = [\n  { path: \"\", component: LandingComponent },\n  { path: \"signin\", component: SigninComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n마지막으로, app.component를 수정하세요:\n\n```typescript\n// app.component.ts\n\u003cnav\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/\"\u003e랜딩 페이지\u003c/a\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/signin\"\u003e로그인 페이지\u003c/a\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 ng serve를 실행하고 http://localhost:4200으로 이동하면 아주 아름다운 페이지를 볼 수 있고, 랜딩 페이지와 로그인 페이지 사이를 이동할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_3.png)\n\n## 구글 SSO 추가하기\n\n구글 SSO를 추가하려면 단순히 버튼에 click 이벤트 리스너를 추가하면 됩니다. 저는 재사용 가능하도록 지시어를 사용하는 것을 선호하는데, 아래에 제가 보여주는 구현 방법을 사용하시면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 SSO를 실행하여 지시문을 만들고 app.module.ts에 자동으로 추가합니다.\n\n```js\n//google-sso.directive.ts\nimport { Directive, HostListener } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { GoogleAuthProvider } from \"@firebase/auth\";\n\n@Directive({\n  selector: \"[googleSso]\",\n})\nexport class GoogleSsoDirective {\n  constructor(private angularFireAuth: AngularFireAuth) {}\n  @HostListener(\"click\")\n  async onClick() {\n    const creds = await this.angularFireAuth.signInWithPopup(\n      new GoogleAuthProvider(),\n    );\n    // 자격 증명으로 할 일을 실행합니다, 예를 들어 Firestore에 추가하기...\n  }\n}\n```\n\napp.module.ts에 지시문을 추가하십시오.\n\n이제 로그인 페이지에서 해당 지시문을 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- signin.component.html --\u003e\n\u003cbutton googleSso\u003eGoogle 계정으로 로그인\u003c/button\u003e\n```\n\n그게 다에요. 작동하는지 확인하려면 프론트엔드로 이동하여 만든 버튼을 클릭하세요. 로그인한 후에 Firebase 콘솔로 돌아가세요. 인증에서 사용자 탭으로 이동하면 로그인에 사용한 이메일이 나타날 것입니다.\n\n계속 진행하기 전에 로그아웃이 가능하도록 로그인 구성요소를 수정해봅시다.\n\n```js\n// signin.component.ts\nimport { Component } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n@Component({\n  selector: \"app-signin\",\n  templateUrl: \"./signin.component.html\",\n  styleUrl: \"./signin.component.scss\",\n})\nexport class SigninComponent {\n  constructor(public angularFireAuth: AngularFireAuth) {}\n  logOut() {\n    this.angularFireAuth.signOut();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003c!-- signin.component.html --\u003e\n@if (angularFireAuth.authState | async) {\n\u003cbutton (click)=\"logOut()\"\u003eLog out\u003c/button\u003e\n} @else {\n\u003cbutton googleSso\u003eSign in with google\u003c/button\u003e\n}\n\n\n## Adding a route available only for logged in users\n\nLet’s create another component: ng g c require-auth\n\nThen let’s create a guard: ng g g auth then select CanActivate\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// auth.guard.ts\nimport { CanActivateFn } from \"@angular/router\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\n\nexport const authGuard: CanActivateFn = async (route, state) =\u003e {\n  const angularFireAuth = inject(AngularFireAuth);\n  const user = await angularFireAuth.currentUser;\n  // coerce to boolean\n  const isLoggedIn = !!user;\n  return isLoggedIn;\n};\n```\n\n그런 다음 app-routing.module.ts의 라우트를 수정합니다.\n\n```js\n// app-routing.module.ts - new lines\n...\nimport { RequireAuthComponent } from './require-auth/require-auth.component';\nimport { authGuard } from './auth.guard';\nconst routes: Routes = [\n  ...\n  {\n    path: 'require-auth',\n    component: RequireAuthComponent,\n    canActivate: [authGuard],\n  },\n];\n...\n```\n\napp.component.html에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cli\u003e\n  \u003ca routerLink=\"/require-auth\"\u003eAuth protected\u003c/a\u003e\n\u003c/li\u003e\n```\n\n이제 로그인한 상태에서만 액세스할 수 있는 경로가 생겼어요.\n\n## 백엔드 경로로 bearer 토큰을 보내는 인터셉터\n\n백엔드에서 요청을 인증하려면 Firebase에서 제공한 토큰을 Authorization 헤더에 추가해야 합니다. 백엔드에서는 토큰을 확인하는 작업을 담당할 것입니다(본 문서의 범위를 벗어남).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng g interceptor bearer-token 명령을 사용하여 interceptor를 생성하세요.\n\n```js\n// bearer-token.interceptor.ts\nimport { HttpEvent, HttpHandlerFn, HttpInterceptorFn, HttpRequest } from \"@angular/common/http\";\nimport { inject } from \"@angular/core\";\nimport { AngularFireAuth } from \"@angular/fire/compat/auth\";\nimport { from, lastValueFrom } from \"rxjs\";\nimport { environment } from \"../environments/environment\";\n\n// 토큰을 얻는 작업이 비동기적이므로 이 함수를 추가해야 합니다.\nconst addBearerToken = async (\n  req: HttpRequest\u003cany\u003e,\n  next: HttpHandlerFn,\n): Promise\u003cHttpEvent\u003cany\u003e\u003e =\u003e {\n  const angularFireAuth = inject(AngularFireAuth);\n  const firebaseUser = await angularFireAuth.currentUser;\n  const token = await firebaseUser?.getIdToken();\n  if (token) {\n    req = req.clone({\n      setHeaders: { Authorization: `Bearer ${token}` },\n    });\n  }\n  return lastValueFrom(next(req));\n};\nexport const bearerTokenInterceptor: HttpInterceptorFn = (req, next) =\u003e {\n  // 이 bearer token을 백엔드로 보내는 요청에만 추가합니다.\n  // 특정 요청에만 bearer token을 추가하도록 사용자 정의할 수 있습니다.\n  if (req.url.startsWith(environment.backendUrl)) {\n    return from(addBearerToken(req, next));\n  } else {\n    return next(req);\n  }\n};\n```\n\n그런 다음 app.module.ts에 provider를 추가해야 합니다.\n\n```js\n// app.module.ts\n\n...\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\nimport { bearerTokenInterceptor } from './bearer-token.interceptor';\n...\n  providers: [provideHttpClient(withInterceptors([bearerTokenInterceptor]))],\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 확인해보기 위해 백엔드를 호출하는 서비스를 생성해봅시다: ng g s api\n\n```js\n// api.service.ts\nimport { HttpClient } from \"@angular/common/http\";\nimport { Injectable } from \"@angular/core\";\nimport { environment } from \"../environments/environment\";\nimport { Observable } from \"rxjs\";\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class ApiService {\n  // 현재 사용자의 firebase 사용자 ID를 반환하는 백엔드 URL\n  userIdUrl = `${environment.backendUrl}/userid`;\n  constructor(private http: HttpClient) {}\n  getUserId(): Observable\u003cany\u003e {\n    return this.http.get(this.userIdUrl);\n  }\n}\n```\n\n그리고 랜딩 컴포넌트에서:\n\n```js\n\u003cbutton (click)=\"getUserId()\"\u003e사용자 ID 가져오기\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from \"@angular/core\";\nimport { ApiService } from \"../api.service\";\n@Component({\n  selector: \"app-landing\",\n  templateUrl: \"./landing.component.html\",\n  styleUrl: \"./landing.component.scss\",\n})\nexport class LandingComponent {\n  constructor(private apiService: ApiService) {}\n  getUserId() {\n    this.apiService.getUserId().subscribe({\n      next: (res) =\u003e console.log(res),\n      error: (err) =\u003e console.log(err),\n    });\n  }\n}\n```\n\n이제 백엔드에 요청을 보내는 버튼이 생겼어요. 개발자 도구의 네트워크 탭에서 인증되어 있다면 토큰이 Authorization 헤더에 추가되는 것을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-06-23-Firebaseauthenticationinangular_4.png)\n\n## 추가 정보: Firebase는 로그인 정보를 어디에 저장하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 인터셉터를 사용할 때 다음 코드를 사용했습니다:\n\n```js\nconst angularFireAuth = inject(AngularFireAuth);\nconst firebaseUser = await angularFireAuth.currentUser;\nconst token = await firebaseUser?.getIdToken();\n```\n\n하지만 이 코드는 실제로 어떻게 작동할까요? 정보는 어디에 저장되나요?\n\n사실, Google SSO로 인증할 때, 인증 정보가 브라우저에 저장됩니다. 브라우저 개발자 도구를 열고 저장소 탭 (Chrome의 경우 Application)으로 이동하신 다음 Indexed DB로 이동해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png"},"coverImage":"/assets/img/2024-06-23-Firebaseauthenticationinangular_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular HttpClient와 Signals를 연결하는 방법","description":"","date":"2024-06-23 14:04","slug":"2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals","content":"\n\nEver since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.\n\nBut first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.\n\nAmidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## RxJS 직접 구독\n\n가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.\n\n```js\npublic data = signal\u003cnumber[]\u003e([])\n....\nconstructor(private testService: TestService) {}\n....\npublic ngOnInit() {\n  this.testService.getItems().subscribe((items) =\u003e {\n    // 시그널 덮어쓰기/생성\n    this.data = signal(items);\n    // 또는 값 직접 설정\n    this.data.set(items);\n  });\n}\n```\n\n## Promises 활용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:\n\n- async/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.\n- 또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.\n\n```js\npublic async ngOnInit() {\n  // observable 소스를 즉시 구독합니다\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n  // 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음\n```\n\n코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npublic async initData() {\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n}\n\npublic ngOnInit() {   \n  this.initData();\n  ....\n}\n```\n\n```js\npublic ngOnInit() {    \n  (async () =\u003e {\n    this.data = signal(await firstValueFrom(this.testService.getItems()));\n    console.log('data inited');\n  })();\n  ....\n}\n```\n\n다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.\n\n```js\npublic ngOnInit() {   \n  firstValueFrom(this.testService.getItems()).then((items) =\u003e {\n    this.data = signal(items);\n  });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## rxjs-interop을 사용하여 toSignal을 활용해보세요\n\nrxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:\n\n- 주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.\n- default 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.\n- API 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.\n- 읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.\n\n```js\nprivate _injector = inject(Injector);\n\npublic ngOnInit() {  \n  this.data = toSignal(this.testService.getItems(), {\n    // injector에 대한 참조 제공\n    injector: this._injector,\n    // default 값을 제공\n    initialValue: [],\n  });\n\n  // 또는 runInInjectionContext를 사용\n  runInInjectionContext(this._injector, () =\u003e {\n    toSignal(this.testService.getItems(), {\n      initialValue: [],\n    });\n  });\n  ....\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론:\n\n현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.\n\n유용한 링크:\nhttps://angular.dev/guide/signals\nhttps://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context","ogImage":{"url":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"},"coverImage":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular v15에 Google Analytics 추가하는 방법","description":"","date":"2024-06-23 14:03","slug":"2024-06-23-AddingGoogleAnalyticstoAngularv15","content":"\n\n아마 당신도 저와 같이 포트폴리오를 만들고 방문자 추적을 원하시는 분들 중 하나일 것 같아요. 다음 직업에 얼마나 가까운지 확인하려고 사이트 트래픽을 추적하고 싶어하시는 분들일 것이라고 생각해요. 혹은 스타트업에서 일하고 있는데 사용자 참여를 추적하길 원하는 경우도 있을 거예요. 어떤 케이스이든 데이터는 웹 개발에서 매우 중요하며 사람들의 일상 생활과 상호 작용하는 방식으로 상당히 중요합니다.\n\n그러니까 더 이상 말이 필요 없겠죠! Angular v15를 사용하여 Google Analytics를 통해 당신의 분석을 어떻게 추적할 수 있는지 단계별로 알려드릴게요.\n\n## 단계 1: Google Analytics 가입하기\n\n우선 처음으로 Google Analytics에 가입해야 해요. 이미 가입한 경우에는 걱정하지 마세요. 아직 가입하지 않은 경우에는 걱정하지 마시고 시작하려면 이 링크의 지시에 따라 https://analytics.withgoogle.com/ 진행한 다음 이 페이지로 돌아오세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가입 절차를 완료하셨다면 또는 이미 이 과정을 완료했다면, 아래 화면을 확인해야 합니다.\n\n![Google Analytics](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png)\n\n파란색 버튼 위에 측정 ID가 표시되어 있는 것을 알 수 있을 겁니다. 제 사진에서는 측정 ID가 흐릿하게 처리되어 있습니다. 예시로, 저의 경우 일시적으로 1234로 설정되어 있습니다.\n\n## Step 2: Angular 애플리케이션에 Google Analytics 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 index.html 파일을 열어야 합니다. 파일이 열리면 아래 코드를 head 태그 밑에 추가해야 합니다. 그러나 body 위에 추가해야 합니다. 아래와 같이 보이는대로 추가해주세요:\n\n```js\n \u003c!-- Google tag (gtag.js) --\u003e\n    \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-M7DLQTY7NJ\"\u003e\u003c/script\u003e\n    \u003cscript\u003e\n      window.dataLayer = window.dataLayer || [];\n      function gtag(){dataLayer.push(arguments);}\n      gtag('js', new Date());\n\n      gtag('config', \u003cyour_sites_measurement_ID\u003e);\n    \u003c/script\u003e\n```\n\n측정 ID는 이 튜토리얼의 1단계에서 찾은 ID로 교체해주세요. 완료하면 이와 같이 보여야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: 분석 서비스 작성하기\n\n이번에 처음으로 Angular 서비스를 생성하고 계신다면, Angular 구조를 따르기 위해 app 폴더 내에 services라는 새 폴더를 생성하는 것을 제안드립니다. 다음과 같이 보여야 합니다:\n\n![폴더 구조](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_2.png)\n\n그런 다음, 새로운 서비스를 생성하고 분석.service.ts라는 이름의 새 서비스를 만들어 새 services 폴더 안에 넣으세요. 분석.service.ts 파일 내에는 다음 코드를 적용하게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\nimport { Injectable } from '@angular/core';\n\ndeclare var gtag: any;\n\n@Injectable({providedIn: 'root'})\nexport class AnalyticsService {\n\n  trackEvent(eventName: string, eventDetails: string, eventCategory: string) {\n    gtag('event', eventName, {\n    // event Type - example: 'SCROLL_TO_TOP_CLICKED'\n    'event_category': eventCategory,\n    // the label that will show up in the dashboard as the events name\n    'event_label': eventName,\n    // a short description of what happened\n    'value': eventDetails\n    })\n  }\n}\n```\n\nvar gtag를 선언함으로써 Angular에게 애플리케이션 어딘가에 참조하려는 gtag라는 메서드가 있는 것을 알려줍니다. 이제 gtag를 index.html 파일에 가져와서 새로운 메서드를 만들 수 있게 되었습니다. 우리가 만든 새로운 메서드는 trackEvent()입니다. 각 속성이 대시보드에 어떻게 표시될지 이해하는 데 도움이 되도록 주석을 남겨 두었습니다.\n\n다음 단계는 선택 사항입니다. 그러나 대부분의 주요 응용 프로그램은 이 구조를 따르므로 이 프레임워크가 익숙하지 않다면 해당 폴더의 index.ts 파일을 업데이트하는 습관을 가져가는 것을 제안합니다. 그런 경우가 아니라면 services 폴더 내에 index.ts 파일을 생성하여 * 장식자를 사용하여 모든 서비스 콘텐츠를 내보낼 수 있도록 합니다. 아래 정보를 참고로 사용하십시오.\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 새로운 분석 서비스 사용하기\n\n이제 사용 중인 컴포넌트에 새 서비스를 가져와야 합니다. 이 튜토리얼은 v15용이므로 독립형 컴포넌트 방법을 사용할 것입니다. 이전 버전을 사용 중이라면 서비스를 컴포넌트가 포함된 모듈 또는 앱 모듈로 가져와야 합니다.\n\n당신의 파일은 Angular의 최신 버전을 사용 중이라면 다음과 유사한 모습이어야 합니다:\n\n![이미지](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 서비스를 가져와서 제공자 목록에 추가하세요. 그런 다음 @angular/core에서 ngOnInit()를 구현할 것입니다. 이렇게 하면 Angular 라이프사이클에서 생성자가 완료된 후 footer가 로드되었다는 이벤트를 보낼 수 있게 됩니다. 그런 다음 분석 서비스를 타겟팅하고 trackEvent() 메서드에 액세스하여 일부 데이터를 전달할 것입니다. 저는 footer 컴포넌트를 예시로 사용하겠습니다. 아래 이미지에서 보여지는 것처럼:\n\n![Adding Google Analytics to Angular v15_5](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_5.png)\n\n## 단계 5: 배포 및 테스트\n\n마지막 단계는 애플리케이션을 배포하고 최종 결과를 테스트하는 것입니다. 대시보드로 돌아가서 리포트에 있는 실시간 탭으로 이동할 수 있습니다. 사이트에 방문하면 지도상에서 자신을 확인할 수 있고 새 이벤트가 애플리케이션에 추가되었음을 확인할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Google Analytics Event Network Tab](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_6.png)\n\n이벤트를 트리거할 때 컬렉션 이벤트 트리거를 보게 될 것입니다. 또한 쿠키에서 태그를 볼 수 있습니다. 두 가지 이미지 모두 아래에서 확인할 수 있습니다.\n\n![Collection Event Trigger in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_7.png)\n\n![Viewing the Tag in Cookies](/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞으로의 개발 팁과 요령을 팔로우해주세요. 읽어 주셔서 감사합니다. 여러분의 지원에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png"},"coverImage":"/assets/img/2024-06-23-AddingGoogleAnalyticstoAngularv15_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 커스텀 파이프 사용 방법","description":"","date":"2024-06-23 14:02","slug":"2024-06-23-AngularCustomPipes","content":"\n\nMarkdown 형식으로 테이블 태그를 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 간단한 사용자 정의 파이프 만들기\n\n우리가 하는 일을 시작하기 위해 문자열에서 각 단어의 첫 글자를 대문자로 변경하는 파이프를 만들어보는 간달한 예제부터 사용해 봅시다.\n\n1. 파이프 생성하기\n\n```js\nng generate pipe capitalize\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 로직 구현\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'capitalize'\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return value;\n    return value.replace(/\\b\\w/g, char =\u003e char.toUpperCase());\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용\n\n```html\n\u003cp\u003e{ 'hello world' | capitalize }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 매개변수를 사용한 Pipe 생성하기\n\n사용자 정의 파이프는 매개변수도 받을 수 있습니다. 이 예제에서는 어떻게 매개변수를 가진 파이프를 생성하는지 자세히 살펴보겠습니다. 이 파이프 예제는 숫자를 지정된 소수 자리로 서식 지정합니다. \n\n1. 파이프 생성하기\n\n```js\nng generate pipe decimalFormatter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Pipe Logic을 구현하세요\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'decimalFormatter'\n})\nexport class DecimalFormatterPipe implements PipeTransform {\ntransform(value: number, decimalPlaces: number): string {\n if (isNaN(value)) return value.toString();\n return value.toFixed(decimalPlaces);\n }\n}\n```\n\n3. 파라미터와 함께 Pipe 사용하기\n\n```js\n\u003cp\u003e{ 1234.56789 | decimalFormatter:2 }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 복잡한 변환에는 Pipes를 사용해요\n\n가끔, Pipes는 더 복잡한 변환을 다루어야 할 때가 있어요. 특정 속성과 값에 따라 객체 배열을 필터링하는 Pipe를 만들어 보도록 해요.\n\n1. Pipe 생성하기\n\n```js\nng generate pipe filter\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 파이프 논리 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'filter'\n})\nexport class FilterPipe implements PipeTransform {\n  transform(items: any[], property: string, value: any): any[] {\n    if (!items || !property || value === undefined) return items;\n    return items.filter(item =\u003e item[property] === value);\n  }\n}\n```\n\n3. 템플릿에서 파이프 사용하기\n\n```js\nexport class AppComponent {\n  users = [\n    { name: 'AJ', role: 'admin' },\n    { name: 'Segun', role: 'user' },\n    { name: 'Homelander', role: 'admin' },\n    { name: 'Alice', role: 'user' }\n  ];\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cul\u003e\n@for(user of users; track user | filter:'role':'admin') {\n \u003cli\u003e\n { user.name } ({ user.role })\n \u003c/li\u003e\n}\n\u003c/ul\u003e\n```\n\n## 비동기 파이프 생성하기\n\nAngular는 Observables 또는 Promises를 사용하여 비동기 파이프를 지원합니다. API에서 데이터를 가져와 표시하는 파이프를 만들어보겠습니다.\n\n1. 파이프 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate pipe fetchData\n```\n\n2. Pipe 로직 구현하기\n\n```js\n@Pipe({\n name: 'fetchData',\n pure: false\n})\nexport class FetchDataPipe implements PipeTransform {\n private http = inject(HttpClient)\n transform(url: string): Observable\u003cany\u003e {\n return this.http.get(url);\n }\n}\n```\n\n3. 템플릿에서 Pipe 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cdiv\u003e\n@if(apiUrl | fetchData | async as data) {\n \u003cpre\u003e{ data | json }\u003c/pre\u003e\n}\n\u003c/div\u003e\n//apiUrl: string = 'https://api.example.com/data'\n```\n\n## 파이프 성능 최적화\n\n기본적으로 Angular 파이프는 순수입니다. 이는 입력 참조가 변경될 때만 다시 실행됨을 의미합니다. 성능 상의 이유로 가능한 곳에서 이 동작을 활용하는 것이 중요합니다. 그러나 입력 데이터가 가변적인 경우, @Pipe 데코레이터의 pure 속성을 false로 설정하여 순수하지 않은 파이프를 생성할 수 있습니다.\n\n순수하지 않은 파이프의 예시\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 파이프 생성하기\n\n```js\nng generate pipe impure\n```\n\n2. 파이프 로직 구현하기\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n name: 'impure',\n pure: false\n})\nexport class ImpurePipe implements PipeTransform {\ntransform(value: any, …args: any[]): any {\n // 사용자 정의 변환 로직\n return value;\n }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 커스텀 파이프에 대한 최상의 방법\n\n가능한 경우 Pipes Pure를 유지하여 Angular의 변경 감지 최적화를 활용하세요.\n단일 책임: 각 파이프는 단일 책임을 가져야 합니다. 변환 작업이 복잡한 경우 여러 파이프로 분리하는 것을 고려해보세요.\n성능 고려사항: 특히 복잡한 변환 작업이나 대량 데이터세트의 경우 성능에 신경을 써야 합니다. 필요한 경우 캐싱 전략을 사용하세요.\n오류 처리: 특히 외부 서비스와 상호작용이나 복잡한 작업을 수행하는 파이프의 경우 오류 처리를 구현하세요.\n재사용성: 다른 컴포넌트 및 모듈에서 재사용할 수 있는 파이프를 만들어 중복을 피하세요.\n\nAngular의 사용자 정의 파이프는 템플릿에서 데이터를 직접 변환하고 형식화하는 강력한 방법을 제공합니다. 이는 간단한 텍스트 변환부터 복잡한 데이터 조작 및 비동기 작업까지 다양할 수 있습니다. 사용자 정의 파이프를 효과적으로 이해하고 구현함으로써 Angular 애플리케이션의 가독성과 유지 관리성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-AngularCustomPipes_0.png"},"coverImage":"/assets/img/2024-06-23-AngularCustomPipes_0.png","tag":["Tech"],"readingTime":4},{"title":"NestJS, TypeORM 및 PostgreSQL 예제  데이터베이스 마이그레이션을 사용한 전체 개발 및 프로젝트 설정 방법","description":"","date":"2024-06-23 14:00","slug":"2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations","content":"\n\n상태 데이터와 데이터베이스를 다루는 것은 어렵습니다. 특히 프로젝트가 시간이 지남에 따라 커지면 더욱 어려워집니다. 개발 프로젝트의 성공을 위해서는 처음부터 좋은 개발 및 프로젝트 설정을 갖추는 것이 중요합니다. 이 글에서는 대부분의 프로젝트를 설정하는 방법을 보여드리고, 설정 뒤에 있는 몇 가지 생각을 강조하려고 합니다.\n\n이 예시에서는 데이터 저장을 위해 PostgreSQL 데이터베이스를 사용하는 간단한 NodeJS API 작업을 진행하고 개발자의 편의를 위해 일부 도구를 설정합니다.\n\n다음은 설정입니다:\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS에서 API를 빌드하기 위해 NestJS를 사용할 예정입니다. NestJS는 상당히 유연한 프레임워크로 ExpressJS 원칙에 기반을 두고 있어 NodeJS 서비스를 쉽고 빠르게 개발할 수 있게 해줍니다. 이 프레임워크에는 여러 가지 편의 기능 (전체 TypeScript 지원, 의존성 주입, 모듈 관리 등)이 내장되어 있습니다.\n\n더 많은 정보를 보려면 여기 웹사이트를 방문해보세요: http://nestjs.com\n\n프로젝트와 도구\n\nNestJS는 보일러플레이트를 처리해주는 멋진 CLI 도구를 함께 제공하여 작업을 빠르게 시작할 수 있습니다. 개인적으로 CLI에서 생성된 NestJS 프로젝트가 완벽한 시작점이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 블랙 매직 코드는 실제로 무엇을 하는지 알지 못한 채 조정하거나 확장하려고 할 때 문제가 될 수 있습니다. 그래서 저는 항상 아주 작게 시작하고 필요한 기능을 시간이 지남에 따라 추가하고 배우는 것을 선호합니다. 필요하지 않거나 이해하지 못하는 많은 기능이 있는 오버블로운 스타터 프로젝트를 사용하지 않는 것이죠.\n\n프로젝트 준비하기 — 보일러플레이트\n\n좋아요, 이 몇 줄로 프로젝트를 생성하여 시작해보죠:\n\n```js\nnpm i -g @nestjs/cli\nnest new project-name\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 내용은 NestJS 및 CLI에 대해 여기에서 찾아볼 수 있어요.\n\n귀하의 프로젝트는 다음과 같이 보일 것입니다:\n\n![project image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_1.png)\n\n지금까지 모든 작업이 잘 되는지 테스트해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run start:dev\n```\n\n이제 프로젝트 기본 설정이 완료되었으니, 데이터 영속성 레이어를 추가해 봅시다.\n\n데이터베이스 스키마를 관리하기 위해 TypeORM을 사용할 것입니다. TypeORM의 장점은 TypeScript로 데이터 엔티티를 모델링할 수 있으며, 이후 이러한 모델을 데이터베이스의 테이블 구조로 적용하거나 동기화할 수 있다는 것입니다. (물론 PostgreSQL 데이터베이스뿐만 아니라 다른 데이터베이스와도 작동합니다. TypeORM 문서에서 지원하는 데이터베이스에 대한 자세한 정보 찾아보세요.)\n\n로컬 PostgreSQL 데이터베이스 인스턴스 설정 - 도커 자동화와 함께!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 데이터 지속성 작업을 위해 데이터베이스 서버와 연결해야 합니다. PostgreSQL 데이터베이스 서버를 로컬 머신에 설정해야 하는 방법 중 하나가 있지만, 저는 이 방법을 크게 선호하지 않아요. 왜냐하면 프로젝트가 내 머신에 많이 종속될 수 있기 때문이죠. 즉, 팀으로 프로젝트를 진행하거나 머신을 바꾸면 매번 다시 설정해야 하거나 어떻게든 설정 가이드를 작성해야 합니다 (서로 다른 운영 체제를 사용하는 머신에서는 더욱 까다로워집니다).\n\n그렇다면 우리는 어떻게 이 문제를 해결할 수 있을까요? 자동화를 통해!\n\n미리 구축된 PostgreSQL 도커 이미지를 사용하고 데이터베이스 서버를 도커 프로세스로 실행합니다. 이렇게 하면 몇 줄의 셸 코드로 전체 설정을 스크립팅하여 서버 인스턴스를 실행하고 연결할 준비가 끝난 빈 데이터베이스를 준비할 수 있습니다. 이것은 재현 가능하고 설정 코드를 프로젝트 코드의 나머지와 함께 소스 제어로 관리할 수 있어, 다른 개발자들이 프로젝트에 빠르게 참여할 수 있도록 만들어줍니다.\n\n이 스크립트는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 package.json 실행 스크립트에 그 명령어를 추가해서 쉽게 실행할 수 있도록 합시다.\n\n```js\n\"start:dev:db\": \"./src/scripts/start-db.sh\"\n```\n\n좋아, 이제 실행할 수 있는 명령어가 생겼고 데이터베이스 서버와 기본 데이터베이스가 설정됩니다.\n\n프로세스를 더 견고하게 만들기 위해 항상 도커 컨테이너에 동일한 이름($SERVER 변수 스크립트에서)을 사용할 거에요. — 이렇게 하면 추가적인 확인을 추가할 수 있어요 — 만약 컨테이너가 이미 실행 중이면 종료하고 제거해서 깔끔한 상태를 보장할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS를 데이터베이스에 연결하는 방법\n\n모든 것을 위해 이미 NestJS 프로젝트를 데이터베이스에 연결하는 데 도움이 되는 NPM 모듈이 있습니다. 우리 프로젝트에 사전 빌드된 NestJS-to-TypeORM 모듈을 사용하여 TypeORM 지원을 추가해 봅시다.\n\n다음과 같이 필요한 모듈을 추가할 수 있습니다:\n\n```js\nnpm install --save @nestjs/typeorm typeorm pg\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보는 NestJS 문서에서 찾을 수 있어요.\n\n구성 관리\n\n이제 모든 것을 하나로 묶는 시간입니다.\n\nNestJS에서 TypeORM에게 어떤 데이터베이스 서버에 연결해야 하는지 알려주는 방법은 TypeOrmModule을 사용하는 것이에요.\nforRoot 메소드를 사용하여 구성을 전달할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것을 잘 작동시키려면 다음과 같이 설정 서비스를 작성할 수 있습니다.\n\n이 config 클래스의 아이디어는 API 서버 main.ts가 시작되기 전에 실행되도록 하는 것입니다. 이 클래스는 환경 변수에서 구성을 읽어오며, 실행 중에 읽기 전용으로 값을 제공할 수 있습니다.\n\n개발 및 운영 모드에 유연하게 대응하기 위해 dotenv 모듈을 사용할 것입니다.\n\n```js\nnpm install --save dotenv\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모듈을 사용하면 로컬 개발 환경의 프로젝트 루트에 \" .env\" 파일을 만들어 구성 값을 준비할 수 있고, 프로덕션 환경에서는 프로덕션 서버의 환경 변수에서 값만 읽어올 수 있습니다. 이는 매우 유연한 방식이며 이 파일을 팀 내 다른 개발자들과 쉽게 공유할 수도 있습니다.\n\n참고: 그러나 이 파일을 git으로 무시하는 것을 강력히 권장합니다. 이 파일에 실제 비밀 정보를 넣을 수 있기 때문에 프로젝트 외부로 누설되거나 실수로 커밋하는 것을 원하지 않을 것입니다.\n\n아래는 .env 파일이 어떻게 보일 수 있는지에 대한 예시입니다:\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=5432\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=mysecretpassword\nPOSTGRES_DATABASE=my_database\nPORT=3000\nMODE=DEV\nRUN_MIGRATIONS=true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 ConfigService는 싱글톤 서비스로 실행되며 시작할 때 구성 값을 로드하여 다른 모듈에 제공합니다. 서비스에는 오류 조기 패턴이 포함됩니다. 즉, 해당 서비스가 제공할 수없는 값에 대해 요청을하면 의미 있는 오류를 throw합니다. 이렇게 함으로써 구성 오류를 런타임 라이프사이클이 아닌 빌드/부트 시간에 감지하여 설정이 더 견고해집니다. 이렇게하면 서버를 배포/시작 할 때가 아닌 소비자가 API를 사용할 때 이것을 일찍 감지할 수 있습니다.\n\n이것이 ConfigService의 모습이며, NestJS 앱 모듈에 추가하는 방법입니다:\n\n이제 첫 번째 테스트를 시작할 준비가 거의 완료되었지만, 실제로 개발 시 TypeScript에서 작업하려면 nodemon과 함께 ts-node를 사용할 것이므로 특별한 nodemon.json을 사용하여 typescript 컴파일러를 활성화하는 ts-node 모듈을 사용하여 개발 서버를 실행할 수 있습니다. 그러니까 nodemon과 ts-node를 설치합시다.\n\n```sh\nnpm i --save-dev nodemon ts-node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉토리에 debug 및 ts-node 지원이 포함된 nodemon.json 파일을 추가해주세요.\n\n```js\n{\n \"watch\": [\"src\"],\n \"ext\": \"ts\",\n \"ignore\": [\"src/**/*.spec.ts\"],\n \"exec\": \"node --inspect=127.0.0.1:9223 -r ts-node/register -- src/main.ts\",\n \"env\": {}\n}\n```\n\n마지막으로 package.json 파일의 start:dev 스크립트를 다음과 같이 수정해주세요:\n\n```js\n\"start:dev\": \"nodemon --config nodemon.json\",\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 API 서버를 시작하기 위해 npm run start:dev를 실행할 수 있어요. 시작 시 ConfigService에서 .env 값들을 가져와 데이터베이스에 TypeORM이 연결될 겁니다. 또한, 이 작업은 제 컴퓨터에 바운드되어 있지 않아요. 멋지죠!\n\n데이터 모델 엔티티를 정의하고 로드해봅시다.\n\nTypeORM은 데이터 모델 엔티티의 자동 로딩을 지원해요. 단순히 모든 엔티티를 한 폴더에 넣고 구성에서 패턴을 사용하여 로드할 수 있어요. 저희는 model/`name`.entity.ts에 엔티티를 넣었어요. (ConfigService의 TypeOrmModuleOptions의 entities 속성을 참고해주세요)\n\n![이미지](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeORM의 또 다른 멋진 기능은 Entity 모델들이 상속을 지원한다는 것입니다.\n\n예를 들어 특정 데이터 필드가 모든 엔티티에 있도록 원한다면 정말 멋진 기능입니다.\n\n예를 들어, 자동으로 생성된 UUID id 필드와/또는 createDateTime, lastChangedDateTime 필드 등이 있습니다.\n참고: 이러한 베이스 클래스들은 추상적이어야 합니다.\n\n따라서 TypeORM에서 데이터 모델 엔티티를 정의하면 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 지원되는 데이터 어노테이션을 TypeORM 문서에서 찾아보세요.\n\n파티 시간이에요 — API를 시작하고 작동하는지 확인해 봅시다.\n\n```js\nnpm run start:dev:db\nnpm run start:dev\n```\n\n… 멋지네요 — 작동하는 것 같지만, 사실 데이터베이스는 아직 데이터 모델을 반영하지 않았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 스키마를 적용하고 데이터베이스 마이그레이션을 생성하고 실행하세요.\n\n이전에 언급했듯이, TypeORM은 데이터 모델을 데이터베이스의 테이블로 동기화하는 기능을 제공합니다.\n\n이 모델의 동기화는 좋지만 위험할 수도 있습니다.\n\n왜냐하면 초창기 개발 단계에서는 좋습니다. 모든 데이터 엔티티가 아직 확정되지 않았기 때문입니다. 그래서 코드에서 클래스를 변경하면 모든 것이 데이터베이스에서 잘 동작합니다. 기본적으로 데이터베이스의 상태에 대해 생각할 필요가 그리 많지 않습니다. TypeORM이 모든 일을 대신 처리해 주니까요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기서 tricky한 부분이 나타납니다. 데이터베이스에 실제 데이터가 있을 때는 모든 엔티티 변경에서 손실을 입고 싶지 않습니다. 이것은 조금 더 복잡해집니다. 이 동기화 기능은 데이터베이스 테이블에 필요한 변경 사항을 적용하기 위해 테이블을 삭제하고 다시 생성하는 방식으로 작동합니다. 이는 테이블 내의 데이터가 손실된다는 것을 의미합니다. 당연히 프로덕션 환경에서 피해야 하지만 개발 환경에서도 예상치 못한 부작용을 야기할 수 있습니다.\n\n그래서 저는 개발 초기부터 코드에서 데이터베이스 마이그레이션을 사용하는 것을 선호합니다.\n\n이렇게 함으로써 데이터 세트의 변경 사항을 더 잘 추적하고 이에 대해 더 적극적으로 생각하게 하여 프로덕션 시나리오에서의 변경 및 데이터 손실을 방지하는 데 도움이 됩니다.\n\n그러니 이 문제를 해결해 봅시다 - 다행히 TypeORM에는 이에 대한 솔루션이 포함되어 있고, SQL 명령을 생성하는 작업을 처리하는 'CLI' 명령도 있습니다. 이를 통해 내부에 어떤 마법도 없이 생성된 SQL 명령을 쉽게 확인하고 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 typeORM CLI를 쉽게 설정할 수 있어요.\n\n1. typeORM CLI 설정\n\n이미 ConfigService로 필요한 모든 설정을 추가했어요.\n\n하지만 typeORM CLI는 ormconfig.json 파일과 함께 작동하며 올바른 설정이 있어야 해요. 또한 CLI를 실제 API 서버와 별도로 실행하고 싶어요. CLI를 사용하기 전에 설정 파일을 생성하므로 .gitignore-list에 추가해주세요. 설정 파일을 작성하는 퀵 도우미 스크립트를 추가해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { configService } from '../config/config.service';\nconst fs = require('fs');\nfs.writeFileSync('ormconfig.json',\n JSON.stringify(configService.getTypeOrmConfig(), null, 2)\n);\n```\n\n그리고 npm 스크립트 작업을 추가하여 해당 스크립트를 실행하고 typeorm:migration:generate 및 typeorm:migration:run 명령어를 실행할 수 있습니다.\n\n이렇게 하면 typeORM CLI 명령을 실행하기 전에 ormconfig가 생성됩니다.\n\n```js\n\"pretypeorm\": \"(rm ormconfig.json || :) \u0026\u0026 ts-node -r tsconfig-paths/register src/scripts/write-type-orm-config.ts\",\n\"typeorm\": \"ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli.js\",\n\"typeorm:migration:generate\": \"npm run typeorm -- migration:generate -n\",\n\"typeorm:migration:run\": \"npm run typeorm -- migration:run\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 마이그레이션 작성\n\n이제 이 명령을 실행하여 초기 마이그레이션을 생성할 수 있습니다:\n\n\nnpm run typeorm:migration:generate -- my_init\n\n\n이 명령은 typeORM을 데이터베이스에 연결하고 데이터베이스 마이그레이션 스크립트 my_init`timestamp`.ts(타입스크립트)를 생성하고 프로젝트의 마이그레이션 폴더에 넣습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 마이그레이션 스크립트를 소스 컨트롤에 커밋하고 파일을 읽기 전용으로 다루어야 합니다. 이 스크립트는 서로 위에 순서대로 작동합니다.\n\n만약 어떤 것을 변경하고 싶다면, cli 명령어를 사용하여 맨 위에 다른 마이그레이션을 추가하는 것이 아이디어입니다.\n\n![migration](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_3.png)\n\n3. 마이그레이션 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm run typeorm:migration:run\n```\n\n이 명령어는 아직 적용되지 않은 데이터베이스에 있는 모든 마이그레이션을 적용합니다. (이미 모든 것이 최신 상태인 경우 아무 작업도 수행하지 않음)\n\n이제 API 서버 프로젝트를 실행하지 않고도 마이그레이션을 생성하고 실행하는 데 필요한 모든 도구를 갖추었습니다. 이렇게 하면 원할 때마다 다시 실행하거나 다시 만들거나 추가할 수 있어 개발 시 유연성이 높습니다.\n\n그러나 프로덕션 또는 스테이지 환경에서는 배포 후 API 서버를 시작하기 전에 마이그레이션 스크립트를 자동으로 실행하는 것이 안전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇게 하면 start.sh 스크립트를 추가할 수 있어요.\n\n마이그레이션을 자동으로 실행할지 여부를 제어하기 위해 환경 변수 RUN_MIGRATIONS=`0|1`을 추가할 수도 있어요.\n\n```js\n#!/bin/bash\nset -e\nset -x\nif [ \"$RUN_MIGRATIONS\" ]; then\n  echo \"마이그레이션 실행 중\";\n  npm run typeorm:migration:run\nfi\necho \"서버 시작\";\nnpm run start:prod\n```\n\n디버깅 및 데이터베이스 도구\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와우, 우리 API 및 DB 설정이 작동하는 것 같네요! 하지만 우리 데이터베이스가 실제 데이터 모델을 잘 반영하고 있는지 확인해야 해요.\n\n이를 확인하기 위해 CLI 스크립트 쿼리를 실행하거나 빠른 디버깅을 위해 UI 데이터베이스 관리 도구를 사용할 수 있어요.\n\nPostgreSQL 데이터베이스를 사용할 때, 저는 pgAdmin을 사용해요.\n\n이 도구는 현재 상황을 보기 위한 멋진 UI를 제공하는 강력한 도구에요. 그러나 다음과 같은 워크플로우를 추천해 드릴게요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Table Image](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_4.png)\n\n이제 데이터베이스에 테이블이 생성된 것을 볼 수 있습니다.\n\n1. 프로젝트에서 정의한 항목 테이블\n2. 이 테이블에서 typeORM이 이미 실행한 마이그레이션을 추적하는 마이그레이션 테이블 (참고: 이 테이블을 읽기 전용으로 처리해야만 합니다. 그렇지 않으면 typeORM CLI가 혼란스러워질 수 있습니다.)\n\n일부 비즈니스 로직 추가중\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 비즈니스 로직을 추가해 봅시다.\n데모를 위해 테이블에 있는 데이터를 반환하는 간단한 엔드포인트를 추가하겠습니다.\n\n이를 위해 항목 컨트롤러와 항목 서비스를 추가할 것이고, NestJS CLI를 사용할 겁니다.\n\n```js\nnest -- generate controller item\nnest -- generate service item\n```\n\n이렇게 하면 우리를 위한 기본 템플릿이 생성되고,\n그런 다음 우리가 추가해야 할 내용은요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'그리고 ItemModule안에서 물건들을 함께 연결하고, 그것을 AppModule에서 가져와요.\n\nAPI를 시작한 후 curl 명령어를 통해 다음을 얻을 수 있어요:\n\n```js\ncurl localhost:3000/item | jq\n[] # \u003c\u003c 데이터베이스에 아이템이 없음을 나타냅니다 - 멋지죠 :)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔티티를 노출하지 마세요 - DTO 및 응답 추가하기\n\n하나의 1대1 데이터 모델을 영속성을 통해 API를 통해 소비자에게 직접 노출시키지 않는 것이 아이디어입니다.\n\n처음 프로젝트를 설정할 때 이것을 바로 하지 않는 것은 처음에는 이점이 직접적으로 보이지 않기 때문에 유혹을 받을 수 있습니다. 물론, 각 데이터 엔티티를 데이터 전송 객체로 래핑해야 하고 직렬화 및 역직렬화를 수행해야 해서 종종 보일러플레이트처럼 느껴질 수 있습니다.\n\n항상 이런 설정을 권장합니다. 따라서 내부 데이터 모델(API to Database)과 외부 모델(API-consumer to API) 사이에 명확한 구분을 두게 됩니다. 이렇게 하면 사물을 분리시키고 장기적으로 유지보수를 더 쉽게할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 이점:\n- 도메인 주도 설계 원칙 적용을 위한 분리\n- 성능, 쿼리 최적화가 훨씬 쉽게 가능\n- 진화, 버전 관리 — 동일한 지속성으로 다른 응답을 반환\n- 테스트 용이성 — 모의(mocking)를 할 수 있음\n… 그리고 훨씬 더 많은 기능\n\n그래서 우리는 데이터베이스의 항목 엔티티에서 채워진 ItemDTO 응답 클래스를 추가할 것입니다.\n간단한 서비스와 응답 DTO는 다음과 같이 보일 수 있습니다.\n\n참고: 이를 위해 `@nestjs/swagger`, `class-validator` 및 `class-transformer`를 설치해야 합니다.\n\n이제 우리는 이 DTO를 간단하게 다음과 같이 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAPI (Swagger) 설정하기\n\nDTO 접근 방식을 통해 API 문서 (openAPI 또는 스웨거 문서)를 생성할 수도 있습니다. 간단히 다음을 설치하면 됩니다:\n\n```js\nnpm install --save @nestjs/swagger swagger-ui-express\n```\n\n그리고 main.ts 파일에 다음 몇 줄을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 다 됐어요:\n\n![이미지 이름](/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_5.png)\n\n해당 주제에 대한 자세한 정보는 여기서 확인하세요.\n\n씨드 데이터 정의.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 이제 화려한 비즈니스 로직을 통해 프로젝트를 확장하는 데 필요한 거의 모든 것을 갖췄어요. 프로젝트 작업 시 당신과 팀의 생산성을 실제로 향상시킬 수 있는 것은 데이터 씨드 스크립트입니다.\n\n이 스크립트는 데이터베이스를 테스트용이나 더미 데이터로 설정합니다. 우리는 이미 데이터베이스 서버를 자동으로 생성하고 사용할 수 있는 빈 데이터베이스를 추가했다는 것을 기억하세요. 이제 우리는 해당 데이터베이스에 \"의미 있는 더미 데이터\"를 생성할 수 있는 스크립트를 추가할 거예요. 이것은 개발에 도움이 되며(모두가 동일한 데이터 집합으로 로컬에서 작업하지만, 또한 영속성 상태를 알 수 있기 때문에 테스트 시스템에 대해 통합 테스트 실행도 가능합니다).\n\n우리는 스크립트를 작성하는 방법을, 이미 정의된 모델을 사용하도록 하며(필요하다면 서비스 레이어 등도 사용할 수 있습니다). 제어의 역전, 클래스 생성자에서의 의존성 주입을 통해 프로젝트의 리포지토리와 서비스의 인스턴스를 생성할 수 있습니다. 이렇게 하면 NestJS API 서버를 시작하지 않고도 TypeScript 파일에서 데이터베이스 연결을 제공하여 수동으로 생성할 수 있습니다.\n\n이것은 정말 좋아요 — 이러한 유형의 시험 코드를 실행하여 코드를 시험하면서 실제 서버를 시작하기 전에 독립적으로 시드 프로세스를 실행하며, 시드 스크립트 논리가 실제 비즈니스 로직 코드로 빠져나가지 않으며 오히려 그것을 활용할 수 있습니다. 보통 제가 스크립트를 매우 일반적인 방식으로 작성해서 한 번에 한 번 실행되어도 다른 것에 의존하지 않고 랜덤 값을 무작위로 생성하여 \"시드-id\"를 넣어 작업하는 편입니다. 이렇게 하면 스크립트를 여러 차례 실행하여 계속해서 더 많은 데이터를 생성하지만 매번 실행할 때마다 뭔가 잘못 되지 않음이 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 스크립트에서 데이터베이스 연결을 설정하기 위해서는 작성한 configService를 재사용하고 ts-node 모듈을 사용하여 실행하면 됩니다.\n\n씨드 스크립트는 다음과 같이 생겼을 수 있습니다:\n\n우리는 다음처럼 실행합니다\n\n```js\nnpm run start:dev:db:seed\n# 결과\n# 완료 -\u003e seed2302-1\n# 완료 -\u003e seed2302-2\n# ...스크립트 실행 종료까지 기다립니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI를 시작한 후에는 데이터베이스에서 이 데이터를 가져옵니다.\n\n```js\ncurl localhost:3000/item | jq\n[\n {\n  \"id\": \"393a370b-762b-44fb-9830-9526a1d6a685\",\n  \"name\": \"seed8239-1\",\n  \"description\": \"created from seed\"\n },\n // ...\n]\n```\n\n마지막으로\n\n로컬에서 데이터베이스 상태를 관리하는 모든 도구를 설정하는 방법을 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 설정부터 모델, 후킹, 그리고 데이터베이스 작업까지.\n\n모든 도구는 어떤 식으로든 코드에 의존하며 UI로 가서 버튼을 클릭하여 설정하는 대신에. 이 \"코드\" 접근 방식을 통해 일을 쉽게 복제할 수 있습니다. 새 팀원을 온보딩하거나, 혹은 2년 후 프로젝트를 다시 방문하여 설정 방법을 잊어버렸다면 — 매우 쉽게 처리할 수 있을 것입니다. 시작하려면 단순히 3~4개의 명령을 실행하면 되며 명령이 어떻게 작동하는지 알기 위해서는 프로젝트 파일을 살펴보기만 하면 됩니다. 왜냐하면 모든 것이 코드로 제공되기 때문입니다.\n\n저는 이를 통해 NestJS, typeORM, 그리고 PostgreSQL 데이터베이스와 함께 작업할 때 여러분을 빠르게 출발시킬 수 있었기를 바랍니다. 여러분은 어떠신가요? 비슷하거나 더 나은 도구/접근 방식이 있으신가요? 아래 댓글에 알려주시면 감사하겠습니다!\n\n건배!","ogImage":{"url":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png"},"coverImage":"/assets/img/2024-06-23-NestJSTypeORMandPostgreSQLfullexampledevelopmentandprojectsetupworkingwithdatabasemigrations_0.png","tag":["Tech"],"readingTime":14},{"title":"2024년 Nodejs와 TypeScript로 API 구축하는 방법 Expressjs 실전 가이드","description":"","date":"2024-06-23 13:57","slug":"2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024","content":"\n\n![Express.js in Action: How to Build an API with Node.js and TypeScript in 2024](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png)\n\n안녕하세요! 이 프로젝트는 여러 포스트로 이어지게 될 거에요. 새로운 파트를 올릴 때 알림을 받으려면 저를 팔로우해 주세요. Node.js와 TypeScript를 사용해 백엔드 개발을 배우고 싶으시다면, 이 시리즈를 확인해보세요. 유용하고 즐거운 정보가 될 거에요.\n\n이 프로젝트에서는 Node.js와 TypeScript를 사용하여 빠르게 API를 구축하겠습니다. Node.js와 TypeScript를 사용하여 API를 처음부터 만드는 방법에 대해 단계별 가이드를 제공할 거에요. 프로젝트에서 다음 기능들을 구현할 예정입니다:\n\n- 프로젝트 구조 설정 및 TypeScript 구성\n- 미들웨어 사용하여 요청 분석 및 응답 전송과 같은 공통 작업 처리\n- 환경 변수를 사용하여 설정 및 비밀 정보 저장\n- 동적 환경\n- 유용한 정보 기록 및 표시하기 위해 로거 사용\n- CORS 활성화 및 기본 인증을 통해 API 보호\n- 유효성 검사 및 예외 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 구조\n\n우리의 프로젝트 구조는 간단하면서도 확장 가능한 구조로, 잘 조직된 코드를 쉽게 확장하고 유지보수할 수 있게 해줍니다. 불필요한 복잡성을 피하며 모든 것을 간단하게 유지합니다.\n\n```js\n-- src\n   -- controllers\n   -- models\n   -- utils\n      -- helpers\n      -- middlewares\n      -- validations\n      -- exceptions\n   -- app.ts\n```\n\n# 프로젝트 초기화 및 TypeScript 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하려면 node 및 npm이 이미 설치되어 있어야합니다. 이 튜토리얼에서는 node v20.11.0 (npm v10.2.4)를 사용할 것입니다. 또한 IDE로 Visual Studio Code를 사용할 것입니다.\n\n- 여기서 node를 설치하세요.\n- 여기서 vscode를 설치하세요.\n- (선택 사항 - bash 터미널을 얻기 위해) 여기서 windows용 git을 설치하세요.\n\n프로젝트를 위한 새 폴더를 만들어 시작하겠습니다. 이것을 node-api-ts로 이름 지을 것입니다. vscode에서 프로젝트 폴더를 열어보세요. 파일을 '열기...'를 통해 열거나 터미널을 사용해서 프로젝트 폴더로 이동하여 다음 명령어를 사용하세요:\n\n```js\ncode .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Ctrl + `를 사용하여 vscode 통합 터미널을 엽니다. 이렇게 하면 기본 터미널이 열릴 것입니다.\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_1.png)\n\n이 튜토리얼에서는 리눅스 및 맥 시스템에서 일반적인 베이시 터미널 명령어를 사용할 것입니다. Windows 사용자는 git bash를 설치하여 유사한 환경을 얻을 수 있습니다. git bash는 베이시 터미널을 에뮬레이트하는 무료 소프트웨어입니다.\n\n# 프로젝트 초기화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 프로젝트 폴더에서 다음 명령어를 사용하여 빈 Node.js 프로젝트를 초기화해보겠습니다. 진행하시기 전에 프로젝트 디렉토리에 있는지 확인해주세요:\n\n```js\nnpm init\n```\n\n앞서 언급한 명령어는 package.json 파일을 생성하기 위해 몇 가지 질문을 통해 새로운 Node.js 패키지/프로젝트를 초기화합니다. 기본적으로 index.js를 덮어씌우기 위해 entry point를 build/app.js로 변경해야 합니다. TypeScript를 사용하기 때문에 나중에 해당 내용을 알아보겠습니다.\n\n```js\npackage name: (api-ts) node-api-ts\nversion: (1.0.0) \ndescription: API with Node.js and TypeScript\nentry point: (index.js) build/app.js\ntest command: \ngit repository: \nkeywords: node.js,express,api,typescript\nauthor: Mahmoud Kassem\nlicense: (ISC) \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더를 확인해보세요. 아마 이와 유사한 내용을 찾을 수 있을 거에요:\n\n```js\n{\n  \"name\": \"node-api-ts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"API with Node.js and TypeScript\",\n  \"main\": \"build/app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n  },\n  \"keywords\": [\n    \"node.js\",\n    \"express\",\n    \"api\",\n    \"typescript\"\n  ],\n  \"author\": \"Mahmoud Kassem\",\n  \"license\": \"ISC\"\n}\n```\n\n# 의존성 설치\n\n무언가를 시작하기 전에 먼저 사용할 종속성(dependancies) 및 개발 종속성(devDependancies)을 나열하고 각각의 사용 목적을 설명해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성(dependencies):\n\n- express: 우리의 API를 구축하는 노드.제이에스 API 프레임워크\n- cors: 프로젝트에서 교차 출처를 활성화함\n- dotenv: .env 파일에서 환경 변수를 읽어 동적 환경을 생성함\n- helmet: 응답 헤더에서 민감한 데이터를 제거하여 API를 보호함\n- morgan: 디버깅 및 모니터링 앱 활동을 위한 로깅 미들웨어\n\n개발 의존성(devDependencies):\n\n- typescript: 코드를 빌드하여 JavaScript로 변환하는 데 사용\n- types (@types/express, @types/helmet, @types/morgan, @types/dotenv): 자바스크립트 생태계의 일부 패키지는 자체 유형 정의를 제공하지 않아 TypeScript 개발자가 사용하기 어렵게 만들 수 있습니다. 다행히 이러한 패키지를 위한 유형 정의를 제공하는 @types 선언 패키지가 있습니다. 예를 들어, @types/express, @types/helmet, @types/morgan 및 @types/dotenv는 각각 express, helmet, morgan 및 dotenv에 대한 유형 정의를 제공하는 선언 패키지입니다. 이러한 선언 패키지를 devDependencies로 설치하고 TypeScript 코드에서 가져와서 해당 패키지에 대한 유형 검사와 코드 완성을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 종속성을 먼저 설치하세요 — 여러 개의 패키지를 설치할 때는 각 패키지 이름 사이에 공백을 사용하면 됩니다:\n\n```js\nnpm install express cors dotenv helmet morgan\n```\n\n그런 다음 다음 명령어를 사용하여 개발용 종속성을 설치하세요:\n\n```js\nnpm install --save-dev typescript @types/express @types/cors @types/dotenv @types/helmet @types/morgan\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지.json 파일을 확인했다면, 설치된 패키지와 그 버전이 업데이트되었음을 알 수 있습니다. 또한 프로젝트에 node_modules와 package-lock.json이 추가된 것을 발견하게 될 거에요.\n\nnode_modules 폴더 안에는 설치된 의존성이 포함되어 있습니다. 그리고 그 의존성의 종속 항목을 찾아볼 수 있습니다. 이 파일들은 우리가 만들고 있는 것과 유사한 노드 패키지입니다.\n\npackage-lock.json은 노드 패키지 매니저(npm)에 의해 자동으로 생성됩니다. 이 파일은 모든 의존성 및 이에 대한 트리의 정확한 버전을 저장합니다. 프로젝트에서 어떤 종속성을 설치하거나 업데이트할 경우 업데이트될 거에요.\n\n## TypeScript 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js는 JavaScript의 런타임으로, 개발자들이 확장 가능하고 효율적인 웹 애플리케이션을 만들 수 있게 합니다. TypeScript는 JavaScript의 슈퍼셋으로, 정적 유형 지정, 객체 지향 프로그래밍, 데코레이터 등의 기능을 추가합니다. 그러나 TypeScript 코드는 Node.js에서 직접 실행되지 않고 먼저 JavaScript로 컴파일해야 합니다.\n\n우리 프로젝트에서 TypeScript를 지원하려면, 먼저 그것을 구성해야 합니다. 아래 명령을 사용하여 구성 파일을 초기화하십시오. 나중에 이 파일을 수정하여 일부 기본값을 변경할 것입니다:\n\n```js\nnpx tsc --init\n```\n\n이전 명령은 다음 내용을 출력할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n다음은 TypeScript의 기본 구성이지만 변경할 수 있습니다. tsconfig.json이라는 새 파일이 생성된 것을 알 수 있을 거에요.\n\n이전에 설정한 프로젝트 폴더 구조에 맞추기 위해 일부 기본값을 수정할 거에요.\n\nrootDir 주석 처리를 해제하고 값을 ./src로 변경해주세요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n...\n\"rootDir\": \"./src\",\n...\n}\n```\n\n이 명령은 프로젝트의 루트 디렉토리를 설정합니다. 이는 TypeScript가 이 폴더 내에만 .ts 파일을 찾도록 하는 것을 의미합니다.\n\noutDir를 주석 처리해제하고 값으로 ./build를 변경하세요.\n\n```js\n{\n...\n\"outDir\": \"./build\",\n...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 transpiled TypeScript의 기본 출력 디렉터리를 변경합니다.\n\n— 이전 파트는 프로젝트 폴더 이름에 따라 변경할 수 있습니다. src를 app, source 또는 다른 이름으로 변경할 수 있지만, 그러면 rootDir을 선택한 폴더 이름과 일치하도록 변경해야 하며 outDir도 동일합니다.\n\n# Express 서버\n\n이제 코드를 작성해 보겠습니다. 전체 프로젝트의 첫 번째 파일 및 주 파일을 만들어 보겠습니다. npm을 사용하여 노드 프로젝트를 초기화하고 일치하는 엔트리 포인트를 build/app.js로 선택했던 것을 기억하십니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.ts 파일을 생성하여 이 파일로 컴파일될 것입니다. 그래서 먼저 해야 할 일은 소스 폴더를 생성하는 것입니다. src 폴더를 루트 디렉토리로 설정한 다음, ./src/app.ts 라는 새 파일을 만들어야 합니다. 그 안에 다음과 같은 코드를 작성해 봅시다.\n\n```js\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport morgan from 'morgan';\n\n// Express 서버 생성\nconst app = express(); // 새 express 인스턴스\nconst port = 3000; // 포트 번호\n\n// Express 설정\napp.use(cors()); // CORS 활성화\napp.use(helmet()); // Helmet 활성화\napp.use(morgan('dev')); // Morgan 활성화\n\n// Express 서버 시작\napp.listen(port, () =\u003e {\n  // 서버가 성공적으로 시작되면 콜백 함수 실행\n  console.log(`서버가 http://localhost:${port} 에서 시작되었습니다.`);\n});\n\n// Express 앱 내보내기\nexport default app;\n```\n\n이전 코드에서는 express 서버 인스턴스를 생성하고 몇 가지 (선택적) 미들웨어로 구성했습니다. 이를 통해 보안, 모니터링 및 디버깅을 개선할 수 있습니다.\n\n이제 다음 명령어를 실행하여 응용 프로그램을 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx tsc \u0026\u0026 node .\n```\n\n이제 터미널에서 다음 줄로 끝나는 출력을 확인해야합니다:\n\n```js\n서버가 http://localhost:3000에서 시작되었습니다\n```\n\n이것은 서버가 성공적으로 시작되었음을 보여주는 콜백 함수의 텍스트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 첫 번째 라우트 생성하기\n\n이제 우리는 애플리케이션을 구성하고 시작했지만 아직 기능이 없습니다. API를 구축해야 하므로 몇 가지 라우트를 생성해야 합니다.\n\n아래 코드는 express의 get() 메서드를 사용하여 경로 / 에 대한 리스너를 만들고 간단한 Hello World! 문자열을 반환합니다.\n\nStart Express Server 코드 블록 앞에 다음 코드를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Express 라우트 정의\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World!');\n});\n```\n\n이제 터미널로 이동해서 현재 프로세스를 Ctrl + C로 중지한 후 npx tsc \u0026\u0026 node . 명령어를 입력하여 다시 빌드하고 서버를 시작합니다.\n\n이제 새로 만든 라우트를 테스트해보겠습니다. GET 요청을 테스트하기 때문에 http://localhost:3000을 열어보면 다음 출력이 표시됩니다:\n\n![이미지](/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 하셨습니다! 첫 번째 라우트를 만드셨네요.\n\n이 튜토리얼에서 사용된 소스 코드가 포함된 레포지토리입니다. 새 커밋이 있는 경우마다 업데이트될 예정이에요. mahkassem/node-api-ts\n\n2부를 보려면 (여기를 클릭해주세요)","ogImage":{"url":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png"},"coverImage":"/assets/img/2024-06-23-ExpressjsinActionHowtoBuildanAPIwithNodejsandTypeScriptin2024_0.png","tag":["Tech"],"readingTime":8}],"page":"7","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"7"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>