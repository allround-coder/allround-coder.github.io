<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/6" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/6" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용" href="/post/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법" href="/post/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 탐구하고 이해하는 석유물리학의 방정식들" href="/post/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 탐구하고 이해하는 석유물리학의 방정식들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 탐구하고 이해하는 석유물리학의 방정식들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬으로 탐구하고 이해하는 석유물리학의 방정식들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="탁월한 프로그래머의 상위 10가지 습관" href="/post/2024-06-23-TheTop10HabitsofExceptionalProgramers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="탁월한 프로그래머의 상위 10가지 습관" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="탁월한 프로그래머의 상위 10가지 습관" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">탁월한 프로그래머의 상위 10가지 습관</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" href="/post/2024-06-23-TheLatestinDataEngineering"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheLatestinDataEngineering_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" href="/post/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이렇게 Python 함수 작성 안 하면 PR 거부" href="/post/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이렇게 Python 함수 작성 안 하면 PR 거부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이렇게 Python 함수 작성 안 하면 PR 거부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이렇게 Python 함수 작성 안 하면 PR 거부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 코드 속도를 높이는 8가지 팁" href="/post/2024-06-23-8TipstoSpeedUpYourPythonCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 코드 속도를 높이는 8가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 코드 속도를 높이는 8가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 코드 속도를 높이는 8가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" href="/post/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" href="/post/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link posts_-active__YVJEi" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"간단한 React 아코디언 컴포넌트 만들기Props와 Children props 사용","description":"","date":"2024-06-23 13:38","slug":"2024-06-23-SimpleReactAccordionComponentPropsChildrenprops","content":"\n\n\n![SimpleReactAccordionComponentPropsChildrenprops](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png)\n\n간단한 기본 React 아코디언을 만들 때에는 React의 기본 지식만 필요합니다. React props 및 useState를 사용하여 상태 관리하는 데 일부 기본 기술이 필요합니다.\n\nReact 컴포넌트는 props를 사용하여 서로 통신합니다. 모든 부모 컴포넌트는 자식 컴포넌트에 정보를 전달할 수 있습니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 매핑하여 아코디언 항목을 표시하겠습니다.\n\n이 프로젝트에서는 정적 데이터를 사용할 것이며, 외부 API에서 데이터를 전달할 수도 있습니다. 아래는 사용할 데이터입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Img1](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_1.png)\n\n첫 번째 할 일은 부모 Accordion.jsx 컴포넌트를 생성하는 것입니다. 이 컴포넌트에서 데이터를 AccordionItem.jsx 컴포넌트로 매핑할 것입니다;\n\n![Img2](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_2.png)\n\n참고: 스타일링은 tailwind css를 사용했습니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 구성 요소에서는 \"currOpen\" 상태를 사용하여 데이터 배열에서 현재 열린 데이터를 결정하므로 true이면 표시되고, 그렇지 않으면 표시되지 않습니다.\n\n데이터를 accordionItem 구성 요소에 매핑할 때 항목과 상태를 프롭으로 전달했는데, 이를 사용하여 자식 구성 요소에서 아코디언을 열고 닫을 수 있습니다.\n\n# 자식 구성 요소 내에서 프롭 읽기\n\n항목, currOpen 및 setCurrOpen과 같은 이름의 프롭을 ('와 ') 사이에 쉼표로 구분하여 AccordionItem 함수 바로 뒤에 나열하여 AccordionItem 코드 내에서 변수처럼 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![SimpleReactAccordionComponentPropsChildrenprops](/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_3.png)\n\n참고: 내 경우에는 외부 버튼 구성 요소를 사용했지만, 일반 버튼 요소를 사용하고 아코디언 상태를 변경하기 위한 onclick 메서드를 추가할 수도 있습니다.\n\n첫 번째로 하는 일은 \"item.Id\"를 \"currOpen\"으로 설정하는 것입니다. 이렇게 하면 한 번에 하나의 아코디언만 열리도록 보장되며, 동시에 두 개의 아코디언을 열 수 없습니다. 이는 상태 관리가 부모 구성 요소에서 제어되기 때문에 가능합니다.\n\ntoggleClick 메서드는 아코디언을 열고 해당 아코디언이 열려 있는지 확인하고 다시 클릭되었는지 확인한 후 상태가 null로 설정되어 아코디언이 닫힙니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아코디언이 열리지 않았을 경우, onclick 메서드를 사용하여 toggleClick이 항목의 id를 \"currOpen\"으로 설정한 후 아코디언을 엽니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_4.png\" /\u003e\n\n페이지에서는 다른 아코디언은 닫힌 채로 두고 두 번째 아코디언만 열려 있습니다. 쉽죠!\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleReactAccordionComponentPropsChildrenprops_0.png","tag":["Tech"],"readingTime":2},{"title":"DuckDB를 사용해 SQL 지원 네트워크 데이터베이스로 Pandas DataFrame 활용하는 방법","description":"","date":"2024-06-23 13:37","slug":"2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB","content":"\n\n만약 대규모 데이터셋을 생성하거나 수정한 다음 SQL 준비 데이터로 공유해야 하는 데이터 과학자라면 ChipmunkDB가 답입니다.\n\n![ChipmunkDB](/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png)\n\n# 대부분의 데이터베이스가 시계열 데이터에 취약한 이유\n\n일단 역사적 주식 데이터의 대규모 데이터셋을 다운로드하여 데이터를 수정하고 일부 지표를 추가한 다음 그 중에서 일부만 쿼리하여 프론트엔드에 표시하려고 할 때 상황을 가정해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 최소 요구 사항입니다:\n\n- 초당 50MB에서 500MB를 저장할 수 있는 매우 빠른 읽기 및 쓰기 데이터베이스가 필요합니다.\n- 모든 시계열에 대한 새 열을 추가하는 데 초단위로 작업이 완료되어야 하며, 모든 행을 반복하지 않아야 합니다.\n- SQL을 통해 시간 범위 내의 3개 열에 대한 쿼리만 가능해야 합니다.\n- 네트워크 데이터베이스여야 합니다.\n\n위에서 설명한 문제를 해결하기 위해 수백 개의 데이터베이스를 시도했지만, 이 중에서 모든 요구 사항을 충족하는 것은 없었습니다.\n\n# DuckDB는 좋은 솔루션입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어느 날 DuckDB (https://duckdb.org/)을 우연히 발견했는데, 정말 놀라웠어요. 판다스 데이터프레임을 쉽게 SQL 데이터베이스로 변환할 수 있어요. 또한, 로컬 디스크에 저장하고 로드하는 속도도 숨막히게 빠릅니다.\n\nDuckDB의 유일한 단점은 시계열 데이터에 좀 부족한 부분이 있고, 네트워크 솔루션이 아니다.\n\n그래서 저는 ChipmunkDB를 시작했어요.\n\n# ChipmunkDB가 시계열 데이터에 강력한 이유의 예시입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nyahofinance에서 DataFrame 몇 개를 다운로드합시다.\n\n```js\nimport yfinance as yf\n\n# 작은 데이터셋 다운로드\nprices_df = yf.download(tickers=[\"QQQ\", \"NVDA\", \"AMD\", \"AAPL\", \"TSLA\", \"MSFT\"], period='60d', interval='5m')\nprices_df = prices_df.stack()\nprices_df.index.names = ['date', 'symbol']\n\n# 이제 28037행과 6열을 가진 데이터프레임을 가지고 있습니다\n```\n\n이제 이 데이터를 데이터베이스에 매우 빠르게 저장하거나 기존의 시간 범위에 \"첨부\"하고 싶습니다.\n\n```js\nimport time\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\nchipmunkDb = ChipmunkDb(\"localhost\")\n\n# 데이터프레임을 chipmunkdb에 저장하는 데 걸린 시간 계산해 봅시다\nstart = time.time()\nchipmunkDb.save_as_pandas(prices_df, \"stock_prices\")\nprint(\"저장하는 데 걸린 시간: \", time.time()-start, \" 초\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와! 놀라울 정도로 빠릅니다! 데이터를 저장하는 데 190ms밖에 걸리지 않는군요. 다시 실행하면 새로운 행만 추가하기 때문에 60ms만 소요됩니다.\n\n이제 전체 DataFrame을 새로운 판다스 DataFrame으로 다시 읽어봅시다.\n\n```js\n# chipmunkdb에서 DataFrame을 읽어봅시다\nimport time\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\nchipmunkDb = ChipmunkDb(\"localhost\")\n\n# DataFrame을 다시 로드하고 시간을 측정해봅시다\nstart = time.time()\ndf = chipmunkDb.collection_as_pandas(\"stock_prices\")\nprint(\"로드 시간: \", time.time()-start, \" 초\")\n```\n\n전체 DataFrame을 로드하는 데 73ms가 소요됩니다. 이제 전체 DataFrame을 사용할 수 있고 새로운 열을 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 새 열을 추가합시다\ndf[\"Volume_Quote\"] = df[\"Volume\"] * df[\"Close\"]\n\n# 다시 chipmunkdb에 데이터프레임을 저장하는 데 걸리는 시간을 계산해봅시다\nstart = time.time()\nchipmunkDb.save_as_pandas(prices_df, \"stock_prices\")\nprint(\"저장하는 데 걸린 시간: \", time.time()-start, \" 초\")\n\n```\n\n새로운 \"Volume_Quote\" 열을 추가했고, 이를 ChipmunkDB에 저장했습니다.\n\n# 이제 멋진 DuckDB 지원이 됩니다\n\n하지만 이것은 ChipmunkDB의 많은 멋진 기능 중 하나에 불과합니다. 이제 위에서 생성한 DataFrame의 일부분만 쿼리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom chipmunkdb.ChipmunkDb import ChipmunkDb\n# \"NVDA\" 및 \"AAPL\" 심볼에 대한 마지막 10행만 쿼리하겠습니다.\nstart = time.time()\nresults = chipmunkDb.query(\"select index_symbol, LAST(Close) from stock_prices WHERE index_symbol IN ('AAPL', 'NVDA') group by index_symbol \")\nprint(\"쿼리 시간: \", time.time()-start, \" 초\")\n```\n\n덕DB의 지원으로 ChipmunkDB 내부 데이터 프레임에서 SQL 쿼리를 실행할 수 있습니다.\n\n# 현재 클라이언트 라이브러리는 NodeJS 및 Python입니다\n\n2개의 클라이언트 라이브러리를 구축했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNodeJS 클라이언트 라이브러리는 ChipmunkDB에서 데이터를 쿼리하는 데 중점을 두고 있습니다. pandas DataFrame은 NodeJS에서 지원되지 않기 때문입니다.\n\nPython 클라이언트 라이브러리는 pandas 및 쿼리 기능의 전체 목록을 지원합니다.\n\nPython 클라이언트는 또한 SQL Alchemy 네트워크 기능을 지원합니다. 예를 들어 SuperSet 또는 기타 BI 시스템에서 pandas에서 데이터를 쿼리하는 데 사용할 수 있습니다. (가까운 미래에 관련 이야기를 쓸 예정입니다)\n\n# Docker, ContainerD 또는 Kubernetes에서 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 환경 안에서 ChipmunkDB를 데이터베이스 저장소로 사용할 수 있는 클라우드 컨테이너를 몇 개 만들었어요.\n\n여기서 헬름 차트를 찾을 수 있어요:\n\n그리고 여기서 도커 컨테이너를 찾을 수 있어요:\n\n# ChipmunkDB의 개발 계획\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n길고도 험난한 여정이긴 하겠지만, 다음 기능 업데이트 계획이 있어. \n\n- 클라이언트 라이브러리 업데이트\n- 컬렉션에 스키마 지원으로 JOIN 지원\n- 컬렉션 업데이트를 받기 위한 웹훅 지원 추가\n- 인증 지원 추가\n- 컬렉션에서 변경 사항을 찾기 위한 로그 엔진 지원\n- PgAdmin 지원 추가","ogImage":{"url":"/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png"},"coverImage":"/assets/img/2024-06-23-UsePandasDataframewithSQL-SupportasaNetworkDatabaseThankstoDuckDB_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬으로 탐구하고 이해하는 석유물리학의 방정식들","description":"","date":"2024-06-23 13:36","slug":"2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics","content":"\n\n\n![Image](/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png)\n\n기술적인 주제를 학습할 때, 산유물리학 등 많은 방정식과 관련이 있는 경우, 모든 매개변수가 어떻게 관련되는지 이해하기 어려울 수 있습니다.\n\n여러 해 전에 산유물리학을 시작할 때, 저는 Archie Water Saturation 방정식과 같은 일반적인 방정식을 탐구하기 위해 Excel을 사용했습니다. 이 방법은 각 매개변수가 계산 결과에 미치는 영향을 이해하는 좋은 방법이었습니다.\n\n본 문서에서는 Python을 사용하여 방정식의 다른 매개변수가 결과에 미치는 영향을 배우고 이해하는 세 가지 방법을 살펴볼 것입니다. 사용된 예시 방정식은 암석 내에 채워진 물의 양을 계산하는 Archie Water Saturation (Sw) 방정식입니다. 이를 통해 암석 내에 얼마나 많은 탄화수소가 함유되어 있는지 추정할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 석유물리학에 익숙하지 않다면, 동일한 작업 흐름과 예제를 원하는 방정식에 적용할 수 있습니다. 당신이 원하는 데이터를 보여주기 위해 최종 예제를 조정해야 할 수도 있습니다.\n\n# 함수로 간단한 방정식\n\n방정식을 탐색하는 가장 간단한 방법은 계산을 수행하는 함수를 만드는 것입니다. 이 함수는 여러 매개변수를 받아들이며, 각각의 매개변수에는 기본값이 할당됩니다.\n\n매개변수에 대한 기본값을 제공함으로써, 우리는 각각의 값을 매번 입력하는 대신 원하는 매개변수를 변경할 수 있게 됩니다. 예를 들어, rt 매개변수를 변경하려면, 다음과 같이 함수를 호출할 수 있습니다: archie_sw(rt=100)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef archie_sw(a=1, phi=0.15, m=2, rw=0.2, rt=200, n=2):\n    Sw = ((a / phi**m) * (rw / rt))**(1/n)\n    return Sw\n```\n\n하지만, 일단 함수를 호출하고 매개변수를 제공하지 않으면 기본 값이 사용됩니다.\n\n```js\narchie_sw()\n```\n\n그리고 이 결과는 Sw가 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n0.21081851067789195\r\n```\n\n만약 투과성 (a) 및 다공성 (phi) 매개변수를 변경하면 다음과 같습니다:\n\n```js\r\narchie_sw(a=1.2, phi=0.25)\r\n```\n\n새로운 Sw 값이 반환됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n0.13856406460551018\n```\n\nArchie 방정식의 매개변수를 탐색하는 좋고 간단한 방법이지만 값들을 바꾸고 셀을 다시 실행해야 하는 것은 매우 지루하고 시간이 많이 소요될 수 있습니다.\n\n# ipywidgets를 사용한 상호 작용성 생성\n\n파라미터를 변경할 때마다 함수를 다시 실행하고 호출해야 하는 번거로움 대신 노트북 내에서 대화형 위젯을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업은 ipywidgets에서 위젯을 가져와 각 매개변수에 연결된 여러 하위 위젯을 설정하는 것으로 완료됩니다.\n\n먼저, 몇 가지 모듈을 가져와야 합니다. 첫 번째로는 ipywidgets에서 위젯들을 가져오고, 노트북 안에 위젯들을 표시하기 위해 IPython.display에서 display를 가져와야 합니다.\n\n다음으로, Archie Water Saturation 방정식과 관련 매개 변수들을 선언합니다. 이 함수는 그런 다음 update_widget 함수 내에서 호출됩니다. \n\n마지막으로, 표시할 위젯들과 그 종류, 기본값 및 허용 값 범위를 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport ipywidgets as widgets\nfrom IPython.display import display\n\n# Archie's Equation function\ndef archie_sw(a, PHI, m, Rw, Rt, n):\n    Sw = ((a / PHI**m) * (Rw / Rt))**(1/n)\n    return Sw\n\n# Interactive widget\ndef update_widget(a=1, PHI=0.2, m=2, Rw=0.1, Rt=2, n=2):\n    Sw = archie_sw(a, PHI, m, Rw, Rt, n)\n    print(f\"Water Saturation (Sw): {Sw:.2f}\")\n\nwidgets.interact(update_widget, \n                 a=widgets.FloatSlider(value=1, min=0.1, max=5, step=0.1, description='a:'),\n                 PHI=widgets.FloatSlider(value=0.2, min=0.01, max=0.4, step=0.01, description='PHI:'),\n                 m=widgets.FloatSlider(value=2, min=1, max=4, step=0.1, description='m:'),\n                 Rw=widgets.FloatSlider(value=0.1, min=0.01, max=1, step=0.01, description='Rw:'),\n                 Rt=widgets.FloatSlider(value=2, min=1, max=100, step=1, description='Rt:'),\n                 n=widgets.FloatSlider(value=2, min=1, max=4, step=0.1, description='n:'))\n```\n\n위 코드를 노트북에서 실행하면 다음과 같이 상호 작용하는 슬라이더가 표시됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:656/1*tKwrqeihgZYjPbCbbP4dyw.gif\" /\u003e\n\n슬라이더 중 하나를 조절하면 해당 Sw 값이 자동으로 업데이트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Jupyter에서 ipywidgets 사용하기 (데이터프레임 + 로그 플롯)\n\n암상해석을 다룰 때는 하나의 데이터 포인트가 아닌 연속된 데이터를 다루는 경우가 많습니다. 이전 방법은 하나의 Sw 값에 대해 각 매개변수와 그 영향을 탐색하려는 경우 간단하게 유지됩니다.\n\n우리는 위에서 한 작업을 확장하여 실제 데이터를 사용하고 어떤 매개변수가 변경되면 업데이트되는 기본 로그 플롯을 만들 수 있습니다.\n\n이 예시에서 공개적으로 사용 가능한 볼브(Volve) 데이터셋에서 포로시티( phi ) 커브와 저항도( rt ) 커브를 가지고 있습니다. 두 가지 모두 아키 워터 포화방정식의 필수 입력값입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n남은 매개변수를 조정하여 전체 저수지 부분에 미치는 영향을 설명할 수 있습니다.\n\n가장 위에 있는 서브플롯(트랙)에서 우리는 기본 매개변수를 사용하여 계산된 물 포화도를 기준으로 합니다. 이것은 대화식 매개변수를 사용하여 계산된 결과와 함께 플로팅됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*ousiE50m2vaWq5ME7RykYw.gif)\n\n상기 플롯을 생성하려면 다음 코드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nfrom IPython.display import display\n\ndf = pd.read_csv('../data/Volve/15_9-19.csv', usecols=['DEPTH','PHIT', 'GR','RT'], na_values=-999)\n\n#Extract a small depth interval\ndf = df.query('3800 \u003c= DEPTH \u003c= 4100')\n\ndef archie_sw(a=1, phi=0.15, m=2, rw=0.2, rt=200, n=2):\n    Sw = ((a / phi**m) * (rw / rt))**(1/n)\n    return Sw\n\ndf['SW_ARCH_BASE'] = df.apply(lambda row: archie_sw(phi=row['PHIT'], rt=row['RT']), axis=1)\n\n@widgets.interact(a=(0.5, 1.5, 0.05),\n                  m=(1.5, 2.5, 0.05),\n                  rw = (0.1, 10, 0.1),\n                  n=(1.5, 2.5, 0.05))                  \ndef update_plot(a=1, m=2, rw=1, n=2):\n    depth = df['DEPTH']\n\n    df['SW_ARCH_NEW'] = df.apply(lambda row: archie_sw(phi=row['PHIT'], rt=row['RT'], \n                                                      a=a,\n                                                      m=m,\n                                                      rw=rw,\n                                                      n=n), axis=1)\n    \n    fig, ax = plt.subplots(nrows=4, ncols=1, sharex=True, figsize=(20, 10))\n    \n    ax[0].plot(depth, df['SW_ARCH_BASE'], c='k')\n    ax[0].plot(depth, df['SW_ARCH_NEW'], c='red')\n    ax[0].fill_between(depth, 1, df['SW_ARCH_NEW'], color='green')\n    ax[0].fill_between(depth, 0, df['SW_ARCH_NEW'], color='skyblue')\n\n    ax[1].plot(depth, df['RT'], c='k')\n    ax[2].plot(depth, df['PHIT'])\n    ax[3].plot(depth, df['GR'], c='green')\n\n    ax[0].set_ylim(0, 1.0)\n    ax[1].semilogy()\n    ax[2].set_ylim(0, 0.5)\n    ax[3].set_ylim(0, 150)\n\n    ax[0].set_ylabel('SW')\n    ax[1].set_ylabel('RT')\n    ax[2].set_ylabel('PHIT')\n    ax[3].set_ylabel('Gamma')\n    \n    plt.show()\n```\n\n# 요약\n\n학습 프로세스를 보다 인터랙티브하게 만들수록 학습한 정보를 더욱 잘 보존할 가능성이 높아집니다.\n\n이 글에서는 파이썬을 사용하여 석유물리학의 기본 방정식을 이해하는 데 도움이 되는 세 가지 다른 간단한 방법을 소개했습니다. 최종 예제에서 매개변수를 인터랙티브하게 만들어 실제 데이터에 대한 각각의 영향을 탐색할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용된 데이터셋\n\n이 튜토리얼에서 사용된 데이터는 2018년 Equinor가 공개한 Volve 데이터셋의 일부입니다. 데이터셋의 자세한 내용 및 라이선스는 아래 링크에서 확인할 수 있습니다.\n\n[Volve field data set download — Equinor](링크)\n\nVolve 데이터 라이선스는 CC BY 4.0 라이선스를 기반으로 합니다. 라이선스 협약의 자세한 내용은 여기에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://cdn.sanity.io/files/h61q9gi9/global/de6532f6134b9a953f6c41bac47a0c055a3712d3.pdf?equinor-hrs-terms-and-conditions-for-licence-to-data-volve.pdf\n\n읽어 주셔서 감사합니다. 나가시기 전에 반드시 내 콘텐츠를 구독하고 제 문서를 이메일로 받아보세요. 여기에서 구독할 수 있어요! 이 콘텐츠를 즐겼고 감사의 표시를 하고 싶으시다면 손뼉을 몇 번 치시는 것도 좋아요.","ogImage":{"url":"/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png"},"coverImage":"/assets/img/2024-06-23-UsingPythontoExploreandUnderstandEquationsinPetrophysics_0.png","tag":["Tech"],"readingTime":7},{"title":"탁월한 프로그래머의 상위 10가지 습관","description":"","date":"2024-06-23 13:34","slug":"2024-06-23-TheTop10HabitsofExceptionalProgramers","content":"\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png)\n\n이 세상에는 소프트웨어 개발에 열정적인 수백만 명의 사람들이 있습니다. 이들은 소프트웨어 엔지니어, 프로그래머, 코더, 개발자 등 다양한 이름으로 알려져 있습니다. 시간이 지나면서 이들은 능숙한 코더가 되어 컴퓨터 언어를 사용하여 작업을 수행하는 방법에 매우 익숙해집니다.\n\n그러나 프로그래머로 진정으로 뛰어나려면 몇 가지 추가적인 요소를 고려해야 합니다. 뛰어난 프로그래머가 되고 싶다면 특별히 주의해야 할 습관이 있습니다. 이 열 가지가 당신의 습관이 되어야만 참으로 우수한 프로그래머로 간주될 수 있습니다.\n\n# 1. 학습은 끝없는 여정입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_1.png\" /\u003e\n\n프로그래밍 경험 10년이 넘게 쌓았다 해도, 끊임없는 지식 탐구는 여전히 중요합니다. 컴퓨터의 끝없는 발전 세계에서 창의력이 번성하여 매일 다양한 혁신이 탄생합니다. 시대에 발맞추기 위해 새로운 프로그래밍 언어와 새로운 프레임워크를 지속적으로 익히는 것이 중요합니다. 산업 소식을 파악하고 활기찬 커뮤니티 내에서 온라인 토론에 적극적으로 참여하여 소프트웨어 개발 트렌드의 펄스를 파악하는 것이 필수적입니다.\n\nGitHub, Stack Overflow, TechCrunch 등의 훌륭한 플랫폼은 귀중한 통찰과 리소스를 제공합니다. Reddit, Medium과 같은 세계적으로 인정받는 플랫폼은 다양한 블로그를 종합하여 기술적 발전의 종합적인 시각을 제공합니다. 이러한 지속적인 학습의 정신을 수용하는 것은 경력 있는 프로그래머들에게 필수적이며, 소프트웨어 개발의 역동적인 세계에서 탁월함을 향상시킬 수 있습니다.\n\n#2. 새로운 것에 열린 마음\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_2.png\" /\u003e\n\n우수한 프로그래머들의 영역에서 \"새로운 것에 열려있다\"는 그저 경솔한 태도보다는 지속적인 성장과 혁신을 이끄는 기본적인 마음가짐이라는 것을 인지해야 합니다. 우수한 프로그래머들은 기술 영역이 지속적으로 발전하고 새로운 언어, 도구 및 방법론이 지속적으로 등장하는 것을 알아차립니다. 낡은 관행에 집착하거나 기존 지식에 안주하지 않고, 새로운 기술과 접근법을 기꺼이 수용합니다.\n\n이 새로운 것에 대한 개방은 다음과 같은 여러 가지 키 요소로 나타납니다:\n\n- 호기심: 우수한 프로그래머들은 기술 세계에 대한 자연스러운 호기심을 가지고 있습니다. 글을 읽거나 워크샵에 참여하거나 자유 시간에 새로운 도구를 시도하는 등 새로운 정보를 적극적으로 찾습니다.\n- 적응성: 소프트웨어 개발의 빠른 세계에서 적응력은 필수적입니다. 우수한 프로그래머들은 기술, 산업 트렌드 또는 프로젝트 요구사항의 변화에 신속히 대응하여 자리를 유지하고 역할에서 효과적으로 활동합니다.\n- 실험: 우수한 프로그래머들은 편안한 지역을 벗어나 새로운 것을 시도하는 데 두려워하지 않습니다. 혁신은 종종 실험에서 나온다는 것을 이해하고, 새로운 아이디어나 접근법을 탐구하기 위해 계산된 위험을 감당하려고 합니다.\n- 협업: 새로운 것에 개방되어 있다는 것은 다른 사람들로부터 의견과 협업을 받아들일 수 있다는 것을 의미합니다. 우수한 프로그래머들은 다양한 시각을 중요시하며, 다른 사람과 협력함으로써 새로운 통찰력과 돌파구를 찾을 수 있다는 것을 인지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 여러 언어를 습득하세요\n\n![image](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_3.png)\n\n프로그래밍 언어마다 가장 적합한 영역이 있습니다. 해결해야 할 문제에 직면했을 때, 해당 문제를 해결하기에 가장 적합한 언어를 식별해야 합니다.\n\n예를 들어, 성능이 중요한 경우 C/C++이 선호될 수 있습니다. 다중 플랫폼 호환성이 중요한 경우 Java가 가장 적합할 수 있습니다. 웹 개발의 경우 PHP, ASP, Ajax 및 JSP와 같은 언어들을 선택할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 처리 및 다른 응용 프로그램과 상호 작용할 때, Perl과 Python이 빛이 나는 경우가 많습니다. 따라서 아직 익숙하지 않은 다른 프로그래밍 언어를 탐험하는 데 시간을 투자해보세요. 시야를 넓힘으로써 여러분의 무기함을 강화하고, 보다 포괄적인 문제 해결이 가능해집니다. 이는 여러분과 프로젝트에 큰 혜택을 줄 것입니다.\n\n# 4. 다른 운영 체제나 기술에 이성적으로 접근하기\n\n![TheTop10HabitsofExceptionalProgramers_4](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_4.png)\n\n프로그래머들은 종종 우분투, 데비안, 윈도우, FreeBSD, MacOSX, 솔라리스 등 자신만의 선호하는 기술과 운영 체제를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 우수한 프로그래머들만이 서로 다른 운영 체제의 강점, 약점 및 세부 사항을 정말로 이해합니다. 이러한 이해는 그들이 감정적 편향 없이 시스템을 선택할 때 객관적이고 중립적인 결정을 내릴 수 있도록 합니다.\n\n마찬가지로, 프로그래밍 언어의 선택은 프로그래머들 사이에서 논쟁거리가 될 수 있습니다. Java와 Perl 같은 언어 또는 VC++과 Delphi와 같은 플랫폼을 비교하는 토론은 흔합니다. 그러나 이러한 논쟁에 참여하면 종종 깊이 있는 통찰보다 피상적이고 성급한 면을 보여줄 뿐입니다.\n\n우수한 프로그래머들은 이러한 방해 요소를 넘어서며 이성적인 분석과 명쾌한 사고로 언어와 플랫폼 선택에 접근합니다. 바로 이러한 이성적인 태도가 그들이 감정적인 부착이나 편향을 받지 않은 판단을 내릴 수 있게 합니다.\n\n\n# 5. 코드 관리를 위해 버전 관리 도구 활용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_5.png)\n\n버전 관리 도구인 GitHub과 같은 도구를 적극적으로 활용하여 코드베이스를 효과적으로 관리하세요. 개발자가 버전 관리의 중요성을 무시할 여유가 있던 시절은 이미 지나갔습니다. 소스 코드 버전 관리의 이점을 모르겠다면, 산업 표준에 뒤쳐지지 않도록 이를 이해하는 것이 시급합니다.\n\nGitHub을 고려해보세요. 이 플랫폼은 강력한 버전 관리 기능으로 유명하며, 협업을 최적화하고 프로젝트 관리를 향상시키기 위한 다양한 기능에 액세스할 수 있습니다. 다수의 기여자 간 변경 사항 추적부터 인기 있는 개발 흐름과의 원활한 통합을 통해, GitHub은 현대 소프트웨어 개발 팀의 요구에 맞는 포괄적인 솔루션을 제공합니다.\n\n오해하지 마세요: 버전 관리 시스템을 구현하지 않는 것은 구식 관행에 고수하는 것과 같습니다. 민첩성과 협업이 요구되는 급변하는 개발 환경에서, 버전 관리를 받아들이는 것은 선택이 아닌 필수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 훌륭한 팀 플레이어가 되기\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_6.png)\n\n혼자서 즐거워하는 것이 아니라면, 혼자 늑대라고 생각하는 것이 아니라면, 오늘날 거의 모든 성숙한 소프트웨어 프로젝트를 혼자서 성취하기 어렵습니다. 당신이 팀의 MVP일지라도, 그것만으로는 훌륭한 팀 플레이어가 되는 것은 아닙니다. 당신의 스킬은 진정으로 빛을 발할 때 협업 노력의 한 부분일 때입니다.\n\n팀원들과 의사 소통을 할 때 공손한가요? 정기적으로 소통하고 모든 사람이 문제를 편안하게 논의할 수 있는 환경을 조성하나요? 축구 팀을 상상해보세요 - 다른 사람들과 잘 어울리나요? 경기장에서의 당신의 행동이 동료를 도와주나요? 당신의 스프린트, 패스 또는 태클을 통해 동료들을 영감을 주나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니까, 게임을 혼자 이기기 위해 계획이 없다면, 팀워크의 중요성을 받아들이세요. 다른 사람들의 기술과 노력과 결합할 때 당신의 기여는 더욱 커집니다. 자신만이 아닌 전체 팀을 끌어올리는 선수가 되어보세요.\n\n# 7. 작업을 문서화로 변환하기\n\n![image](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_7.png)\n\n이 지침은 당연히 코드에 주석을 달아야 한다는 것을 포함하지만, 그것이 시작에 불과합니다. 더 많은 일을 해야 합니다. 명확하고 간결한 주석이 달린 코드는 문서화의 기초를 형성하여 당신과 팀이 당신의 의도와 생각을 이해하기 쉽게 만듭니다. 당신의 작업을 문서화하는 것은 당신의 사고과정을 상기시키는 것뿐만 아니라 팀 내 오프라인 커뮤니케이션 수단 및 지식 전달 수단으로 작용합니다. 당신이 알고 있는 것을 모두 문서화하는 습관은 귀중합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 솔직히 말해서, 가장 바쁠 때 다른 사람들이 계속 질문을 던지거나 휴가 중에 회사에서 전화를 받아 일에 관해 물어 들을 때 참기 어려운 건 아닐 겁니다. 당신의 지식을 저장함으로써, 당신은 자신의 영역에 갇히기만 할 뿐 더 많이 하기 위한 시간을 남기지 못할 것입니다. \"제자를 가르치면 선생님은 굶어죠\"라고 생각할 수도 있지만, 당신의 보수적인 태도는 당신이 더 큰 기회를 놓칠 뿐입니다. 믿어봐요, 저는 이 사항을 과장하려는 게 아니에요.\n\n# 8. 백업과 보안\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_8.png)\n\n백업의 중요성을 이미 알고 있기 때문에 이것이 \"뻔한 얘기\"라고 생각할 수 있겠지만, 여전히 강조하고 싶습니다. 물건을 잃는 것은 삶의 한 부분이며, 피할 수 없는 손실을 항상 경험하게 될 것입니다. 예를 들어, 노트북이 도난당할 수 있고, 하드 드라이브가 고장날 수 있으며, 컴퓨터에 바이러스가 감염될 수 있고, 시스템이 해킹당할 수도 있으며, 건물 전체가 불이 날 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러므로 적절한 백업을 보장하는 것이 매우 중요합니다. 하드 드라이브는 믿을 수 없으므로 규칙적으로 CD나 테이프를 복사하는 것이 좋은 방법일 수 있습니다. 네트워크도 믿을만하지 않으니 바이러스와 해커에 대해 조심해야 합니다. 소프트웨어 기반 보안 조치만 사용하는 것뿐만 아니라 견고한 관리 시스템도 필요합니다. 또한, 데이터를 다른 위치에 저장하고 일일, 주간, 월간으로 정기적인 백업 전략을 수립하는 노력도 필요합니다.\n\n# 9. 발을 쏴버리지 않기\n\n![이미지](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_9.png)\n\n프로그래머들은 자신의 작업을 빨리 끝내려는 안 좋은 습관을 가지고 있습니다. 그러나 일은 항상 예정대로 진행되지 않습니다. 서두르면 서두를수록 문제가 발생할 가능성이 높아지거나 문제를 완전히 놓치게 됩니다. 결국 처음부터 충분한 시간을 들인다면 문제를 고치는 데 소비하는 시간과 에너지가 더 적게 들 것입니다. 서두르다가 오류가 나게 되니 서두르지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우수한 프로그래머들의 습관은 추가 시간을 투자하여 다양한 해결책을 실험하고 조사하는 것입니다. 시간이 허용된다면, 프로그래밍 3시간마다 휴식을 취하고 다음 3시간에 다시 시작하는 것이 좋은 습관입니다.\n\n물론, 이는 사람에 따라 다를 수 있지만, 핵심은 꾸준히 진행 상황을 되돌아보고 자신에게 세 가지 질문을 던지는 것입니다:\n\n- 이 방법이 옳은가요?\n- 모든 가능한 시나리오를 고려했나요?\n- 더 나은 방법이 있을까요? 고민하고, 주기적으로 진행 상황을 검토하고 지난 경험을 되짚어보세요. 이 습관은 장기적으로 큰 도움을 줄 것입니다.\n\n# 10. 불편함에 익숙해지는 법을 배웁니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-23-TheTop10HabitsofExceptionalProgramers_10](/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_10.png)\n\n이것은 성장과 발전의 필수적인 부분으로 불편함을 받아들이는 아이디어를 총망라하고 있습니다. 프로그래밍과 같은 전문적인 노력뿐만 아니라 인생의 다양한 측면에서 진전을 이루려면 자신의 편안한 영역을 벗어나서 익숙하지 않거나 어려울 수 있는 과제에 도전해야 합니다.\n\n프로그래머에게는 다음과 같은 개념이 함축됩니다:\n\n- 도전 수용: 어려운 과제나 익숙하지 않은 기술을 피하지 않고, 성공적인 프로그래머는 도전에 직면하기를 원합니다. 그들은 장애물을 극복하는 것이 학습과 성장의 필수적인 부분이라고 인식합니다.\n- 성장 기회 탐색: 안락함은 타성을 낳으며, 불편함은 성장을 촉진합니다. 우수한 프로그래머는 새로운 프로젝트를 맡거나 새로운 프로그래밍 언어를 배우거나 경계를 넓히는 복잡한 문제에 도전함으로써 스스로를 발전시키는 기회를 적극적으로 찾습니다.\n- 변화 대응: 기술의 빠른 세계에서 변화는 불가피합니다. 불편함을 받아들이는 프로그래머는 새로운 기술, 방법론 및 산업 동향에 적응하는 데 더 유연하게 대처하여 현재보다 앞섰고 분야에서 중요한 위치를 유지할 수 있습니다.\n- 탄력성 구축: 불편함을 받아들이는 것은 또한 탄력성을 키웁니다 - 실패로부터 튀어 올라오고 역경 속에서 끈질기게 버텨내는 능력입니다. 계획대로 되지 않을 때, 탄력 있는 프로그래머들은 실수에서 배우고 솔루션을 반복해 나가며 궁극적으로 성공을 거둘 수 있는 능력을 더 좋게 갖출 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png"},"coverImage":"/assets/img/2024-06-23-TheTop10HabitsofExceptionalProgramers_0.png","tag":["Tech"],"readingTime":7},{"title":"데이터 엔지니어링의 최신 동향 2024 놓치지 말아야 할 신기술과 트렌드","description":"","date":"2024-06-23 13:33","slug":"2024-06-23-TheLatestinDataEngineering","content":"\n\n## 주요 개발 사항 및 그 영향\n\n최근 몇 주 동안 DuckDB, Snowflake, DataBricks 및 Polars에서 중요한 발표를 통해 데이터 엔지니어링 분야가 상당히 발전하고 있습니다. 이러한 발전은 데이터 생태계 내 중요성과 혁신의 증가를 강조하고 있습니다. 제 평소의 글과는 다르지만, 최근 이러한 발표들을 살펴보고 데이터 엔지니어링의 미래에 대해 어떤 의미를 갖을지 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-23-TheLatestinDataEngineering_0.png)\n\n# 뉴스 속으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DuckDB v1.0.0 릴리스\n\nDuckDB는 SQL OLAP 데이터베이스 관리 시스템으로, 1.0.0 마일스톤에 도달했습니다. DuckDB에 대한 별도의 기사를 썼는데, 여기서 더 많은 정보를 찾을 수 있습니다. 이번 릴리스인 \"Nivis\"는 신화 속 눈오리 오리 이름을 지어 안정성과 하위 호환성을 강조했습니다. 대규모 테이블을 전체 트랜잭션 의미론과 최신 압축 기술을 사용하여 관리할 수 있도록 하는 DuckDB의 사용자 정의 저장 형식은 이제 버전 간 호환성을 보장합니다. 이 릴리스는 DuckDB의 성숙성과 신뢰성을 나타내며 데이터베이스 운영에 안정적인 선택지로 만듭니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n## Snowflake의 Polaris, 오픈 소스 아이스버그 카탈로그\n\nSnowflake은 Apache Iceberg를 위한 벤더 중립적 카탈로그 구현인 Polaris를 공개했습니다. 오픈 소스로 나아가는 이 전략적인 움직임은 데이터 관리 커뮤니티에서 보다 큰 협력과 표준화를 촉진하기 위한 것입니다. Polaris는 앞으로 3개월 동안 오픈 소스로 공개될 예정이며, Snowflake의 상호 운용성과 혁신에 대한 약속을 강화합니다. 오픈 소스를 채택함으로써 Snowflake는 생태계의 유연성을 향상시켜 사용자가 다양한 플랫폼에서 데이터를 보다 효율적으로 관리하고 쿼리할 수 있도록 합니다. 릴리스에 대한 링크는 여기에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DataBricks 오픈소스 Unity 카탈로그\n\n스노우플레이크의 발표에 반응하여 DataBricks는 Unity 카탈로그를 오픈소스로 공개하기로 결정했습니다. 이 카탈로그는 Iceberg, Hudi 및 Delta 데이터 레이크하우스 파일 형식을 지원하여 현대적인 데이터 관리 필요에 대한 포괄적인 솔루션을 제공합니다. 이 오픈소스 코드는 오늘부터 GitHub에서 사용 가능할 것이며, 투명성 및 커뮤니티 기반의 향상을 촉진할 것입니다. 이러한 조치는 고급 데이터 관리 도구에 대한 접근을 민주화할 뿐만 아니라 DataBricks를 오픈소스 데이터 생태계의 선도 업체로 위치시킵니다. DataBricks 웹사이트에서 아직 정보를 찾을 수 없지만, PR Newswire에서 링크를 확인할 수 있습니다.\n\n## Polars v1.0.0 곧 출시 예정\n\nRust로 작성된 고성능 DataFrame 라이브러리인 Polars는 앞으로 몇 주 안에 1.0.0 버전을 출시할 예정입니다. 현재 1.0.0 버전은 여기에서 알파 버전으로 제공됩니다. 다중 코어 프로세서를 활용하여 빠른 데이터 처리를 지원하는 능력으로 알려진 Polars는 대규모 데이터 분석용 Pandas의 매력적인 대안을 제공합니다. 이 도구는 여러 기술 문서에 사용하는 내 선택 도구이며, 제 GitHub 계정에서 강력하게 활용될 것입니다. 이 출시는 다양한 새로운 기능과 성능 향상을 가져와서 Python을 사용하는 데이터 엔지니어들에게 필수적인 도구로서의 입지를 더욱 굳히게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DataBricks가 Tabular를 인수했습니다\n\n전략적으로 DataBricks가 Iceberg 테이블 형식의 창시자들에의해 설립된 Tabular를 인수했습니다. 이번 인수는 Tabular의 전문지식과 기술을 DataBricks 플랫폼에 통합하여 대용량 데이터 형식을 처리하는 능력을 강화하는 것을 목표로 합니다. 병합은 데이터 저장 및 관리에 혁신을 도모해 사용자들에게 더 견고하고 확장 가능한 솔루션을 제공할 것으로 예상됩니다.\n\n# 데이터 엔지니어링의 미래에 대한 영향\n\n이러한 발표들은 오픈 소스 솔루션, 상호운용성 및 향상된 데이터 관리 능력으로 나아가는 일반적인 추세를 반영합니다. 이러한 발전들이 데이터 엔지니어링의 미래에 미치는 의미는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 향상된 안정성과 신뢰성: DuckDB의 v1.0.0 릴리스에서 안정성에 대한 강조는 다른 데이터베이스 관리 시스템에 선례를 제공합니다. 신뢰성 있고 하위 호환성 있는 시스템은 데이터 무결성과 가용성이 중요한 기업 애플리케이션에서 필수적입니다.\n- 오픈 소스 우위: Snowflake와 DataBricks의 오픈 소스 노력은 커뮤니티 기반 개발과 협업의 중요성을 강조합니다. 오픈 소스 프로젝트는 다른 성공적인 오픈 소스 데이터베이스 및 도구들과 마찬가지로 빠른 혁신과 채택을 이끌어냅니다.\n- 향상된 데이터 상호 운용성: Polaris와 Unity Catalog의 오픈 소스화와 같이 벤더 중립 카탈로그의 도입으로 다양한 시스템 간 데이터 관리 및 쿼리가 더욱 원활해질 것입니다. 이러한 상호 운용성은 다양한 데이터 소스와 형식을 다루는 기관에 중요합니다.\n- 성능 최적화: Polars와 DuckDB와 같은 도구들은 고성능 데이터 처리 라이브러리의 필요성을 강조합니다. 데이터 양이 계속해서 증가함에 따라 효율적인 데이터 처리는 실시간 분석과 의사 결정에 중요할 것입니다.\n- 전략적 인수: DataBricks가 Tabular를 인수한 것은 플랫폼 기능을 향상시키기 위해 전문 지식과 기술을 통합하는 추세를 보여줍니다. 기업이 데이터 관리 솔루션을 강화하려는 노력으로 이러한 전략적 움직임은 계속될 것입니다.\n\n# 결론\n\n저는 오픈 소스의 팬이라서 이러한 발표들이 나를 흥분시킵니다. 안정성, 오픈 소스 협업 및 성능 향상에 초점을 맞추면, 데이터 엔지니어링의 미래는 밝아 보입니다. 이러한 혁신은 기업이 데이터를 더 효과적으로 처리하고 더 나은 통찰과 비즈니스 결과를 이끌어내도록 할 것입니다. 앞으로 나아가면서, 이러한 트렌드를 주시하는 것은 데이터 전문가가 끊임없이 변화하는 데이터 생태계에서 앞서 나가기 위한 중요한 요소가 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png"},"coverImage":"/assets/img/2024-06-23-TheLatestinDataEngineering_0.png","tag":["Tech"],"readingTime":4},{"title":"HTTP 요청 로그를 통해 봇 트래픽 측정 및 감사하는 방법","description":"","date":"2024-06-23 13:31","slug":"2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs","content":"\n\n현재 인터넷 트래픽의 약 30%는 봇, 스파이더 및 크롤러에 의해 생성됩니다. 이들은 다양한 목적으로 웹을 스캔하는 자동화 프로그램입니다.\n\n이 프로그램 중 일부는 다음과 같은 중요한 인터넷 작업을 수행합니다:\n\n- 검색 엔진 인덱싱\n- 성능 모니터링\n- 인터넷 매핑\n- 선의의 취약점 스캔\n\n해당 주제에서 제가 찾을 수 있는 가장 포괄적인 목록은 클라우드플레어의 목록입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 합법적인 또는 조작된 것인가요?\n\n좋은 크롤러 외에도, 다른 많은 봇들은 단순히 자원을 낭비하거나 비패치된 취약점을 악용하려 하거나 웹사이트의 콘텐츠를 훔치려고 시도하는 경우가 많습니다.\n\n좋은 봇과 나쁜 봇을 구분하는 것은 어려운 주제입니다. 몇몇 영리한 봇은 사용자 에이전트 필드를 조정하여 실제로 보이도록 속이려고 합니다. 사용자 에이전트 필드는 브라우저가 웹사이트로 보내는 것이며, 자기 자신을 식별하는 방법입니다.\n\n```js\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래도 프로그래밍으로 요청을 보낼 때, 어떤 개발자든 해당 요청에 원하는 사용자 에이전트를 설정할 수 있어요. 그래서 HTTP 요청이 필수적인 봇에서 시작되었는지를 확인하는 방법은 사용자 에이전트 값을 살펴보는 것 뿐이에요.\n\n## robots.txt는 어떤가요?\n\n웹사이트 루트에 위치한 robots.txt 파일은 자동화된 요청에 대한 해당 웹사이트의 정책을 나타냅니다. 크롤러(또는 프로그램)가 지시 사항을 존중하고 이행하는 것은 그들에 달려 있어요.\n\n# 원본 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도, 주요 인터넷 업체들은 명확한 확인 지침을 제공하고 최신 IP 목록을 유지하고 있습니다. 이를 통해 누구든지 특정 서비스에서 오는 임의의 요청인지 여부를 확인할 수 있습니다.\n\n지금 당장, 이 정보를 공유하는 기업들 사이에 공통 표준이 없습니다. 이 공통 표준의 부재는 괜찮습니다; 웹에는 더 많은 대화가 필요합니다 — 더 많은 규제가 아닌요.\n\n아래를 읽어보세요.\n## Google\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle은 사전 정의된 URL에서 제공되는 JSON 형식(기계가 읽을 수 있는 형식)으로 봇 IP 범위를 공개합니다. Google은 현재 세 가지 주요 크롤러를 운영 중입니다:\n\n- GoogleBot — Google 검색용 초기 크롤러\n- GoogleBot Special + AdsBot — 광고 및 기타 서비스\n- GoogleBot User Triggered — 사용자 요청에 따른 색인 작업\n\n## Bing\n\nMicrosoft는 검색 결과를 개선하기 위해 BingBot을 사용하며, Google과 동일한 JSON 형식으로 IP 범위를 나열합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## OpenAI\n\nGPTBot은 OpenAI의 봇으로, 웹사이트 콘텐츠를 다운로드하는 데 사용될 가능성이 높습니다. 이를 통해 ChatGPT와 같은 AI 모델을 훈련할 수 있습니다. IP 범위는 JSON 형식으로 제공됩니다. robots.txt를 사용하여 이들을 차단할 수 있습니다.\n\n## DuckDuckGo\n\nDuckDuckGo는 Google의 대체로서 개인정보 보호에 중점을 둔 검색 엔진입니다. 이 페이지에서 각 개별 봇의 IP를 공개합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메타\n\n메타는 웹사이트에 접근하기 위해 Facebook 크롤러를 사용합니다. IP 범위는 radb.net 레지스트리를 사용하여 공개됩니다.\n\n## Amazon, Apple, Baidu, Sogou, Yahoo, Yandex\n\n이 기업들은 인터넷을 스캔하는 데 사용되는 IP 주소의 고정된 목록이나 자동 업데이트되는 목록을 공개하지 않습니다. 그러나, bot 트래픽이 자신들의 시스템에서 유래되었는지 확인하는 문서화된 방법을 갖고 있습니다. host 명령을 사용하여 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ host 17.58.101.179\n179.101.58.17.in-addr.arpa domain name pointer 17-58-101-179.applebot.apple.com.\n\n\n## 인터넷 아카이브\n\n인터넷 아카이브 봇은 웨이백 머신/아카이브 닷오르그 프로젝트를 위한 크롤러입니다. 그들은 웹의 콘텐츠를 역사적인 이유로 저장합니다. 웹사이트는 변화하고 페이지는 매일 생성되고 사라집니다.\n\nIABot은 host 명령을 사용하여 확인할 수 있습니다. robots.txt의 내용을 무시하기 때문에 차단하기 어렵습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## CommonCrawl\n\n커먼크롤(CommonCrawl)은 인터넷 아카이브와 유사한 비영리 기관입니다. 전체 인터넷의 주기적인 스냅샷 또는 데이터셋을 생성하고 이를 공개적으로 제공합니다.\n\n커먼크롤은 해당 주제에 대한 정보를 과도하게 공유하지 않으며, 실제 CCBot를 식별하는 것은 대규모 온디맨드 AWS 인프라에서 실행되므로 더 복잡합니다.\n\n한 가지 방법은 사용자 에이전트와 호스트를 모두 확인하는 것입니다. 이는 완벽한 방법은 아니지만, 모든 EC2 클라우드 인스턴스가 같은 .amazonaws.com 호스트 이름을 공유하기 때문에 복잡합니다. 그러나 두 가지가 일치하면, 요청이 실제 CCBot에서 시작되었을 가능성이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이 스크립트로 변환하기\n\nGitHub에는 자체 업데이트되는 좋은 봇 IP 목록 및 프로젝트가 많이 있습니다. 주요 단점은 이러한 프로젝트 관리자에게 의존한다는 것입니다. 이러한 프로젝트의 계획 또는 EOL(수익화 종료) 날짜는 알려져 있지 않으며 라이선스도 명확하지 않습니다.\n\n그것을 고려하면 아래 스크립트는 생성자에서 IP 범위에 관한 모든 정보를 다운로드합니다. 그 정보는 직접 제공되는 서비스에서 가져옵니다. 따라서 HTTP 요청 로그 항목의 IP 및 사용자 에이전트를 확인할 수 있습니다.\n\n안타깝게도 이 스니펫은 완전한 Python 패키지로 발전시키기 위해 추가 작업이 필요하므로 현재는 Gist 상태입니다. 호스트 호출로 인해 실시간 사용에 대한 도움 클래스는 충분히 빠르지 않을 것입니다. 50,000개의 로그 항목을 확인하는 데 약 15분이 소요됩니다. 서브프로세스 호출에 대해 교차 플랫폼 작업이 필요할 수 있습니다. IPv6 지원은 없습니다. 가독성을 우선시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 응용 프로그램 방화벽(WAF)가 실시간으로 이러한 요청을 차단해야 한다면 CloudFlare, RunCloud 등의 검증된 서비스를 선택하세요.\n\n현재 클래스는 과거의 HTTP 서버 로그 항목을 테스트할 수 있습니다. 서버가 받는 건강한 봇/크롤러/스파이더 트래픽의 양을 확인하는 데 사용할 수 있습니다.\n\n# 사용 방법\n\n저는 NGINX 서버의 봇 트래픽을 확인하기 위해 아래 스크립트를 사용했습니다.\n아래의 사용 예는 하위 폴더 내에있는 모든 access.log[.*.gz] 파일을 구문 분석합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# NGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로 로드합니다  \nNGINX 로그 파일에서 모든 데이터를 pandas DataFrame으로로드합니다.  \n\n# tqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다\ntqdm을 사용하여 요청 정보를 확인하고 진행 상황을 보고합니다. 이 단계는 시간이 걸릴 수 있으므로 주의해주세요.  \n\n# 디스크에 보고서 저장 및 요약 출력  \n디스크에 보고서를 저장하고 요약을 출력합니다.  \n\n이 스크립트는 NGINX 로그 파일에 작동합니다. NGINX는 인그레스 컨트롤러로 가장 인기 있는 선택지이기 때문에 잘 작동합니다.  \n위 코드 조각들은 어떤 데이터 분석 사용 사례 및 다른 인그레스 컨트롤러에 대한 확장이 가능하도록 충분히 일반적입니다.  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n사실, 로봇 요청 중에서 4%만 진짜 서비스에서 시작된 것으로 나타났습니다. 즉, 25개 중 1개만이 진짜 요청입니다.\n\n나머지는 단지 대역폭과 자원을 낭비하는 것 뿐입니다.\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoMeasureandAuditBotTrafficbyHTTPRequestLogs_0.png","tag":["Tech"],"readingTime":5},{"title":"이렇게 Python 함수 작성 안 하면 PR 거부","description":"","date":"2024-06-23 13:30","slug":"2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png\" /\u003e\n\n이건 나의 직장에서 기술 리드로부터 받았던 에너지였죠. 사실 나도 이 시점에서 그와 동의합니다.\n\n# 우리에게 파이썬 함수를 어떻게 작성하는지 배웠는가\n\n다음은 간단한 매개변수를 사용하는 함수입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 숫자 목록 num_list가 있습니다.\n- 숫자 num이 있습니다.\n- num_list에 있는 모든 숫자에 num을 더한 새로운 목록을 반환합니다.\n\n```js\ndef add_all(num_list, num):\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n문제 - 첫눈에 알기 어려운 것들:\n\n- 이 함수가 어떤 데이터 유형을 사용하는지\n- 이 함수가 어떤 데이터 유형을 반환하는지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음, 코드를 읽으면 num_list가 숫자의 목록이고 num은 숫자이며, 함수가 숫자의 목록을 반환한다는 것을 유추할 수 있다는 걸 알 수 있어. 그러나 이건 즉시 알 수 있는 게 아니잖아.\n\n그리고 대규모 제품용 앱에서는 수천 개의 함수가 처리되어야 한다. 정말 그 추가 시간을 들여서 데이터 유형을 이해하고 추론해야 할까?\n\n# 타입 주석 (타입 힌트)이 구해줍니다 \n\n참고 - 우리는 이것을 타입 힌트 또는 타입 주석이라고 부를 수 있어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 위의 함수에 몇 가지 타입 힌트를 추가해 봅시다.\n\n```python\nfrom typing import List, Union\n\ndef add_all(\n    num_list: List[Union[int, float]],\n    num: Union[int, float]\n) -\u003e List[Union[int, float]]:\n    \"\"\"\n    num_list의 모든 숫자에 num을 추가합니다  \n\n    inputs:\n        num_list: 숫자 리스트\n        num: 숫자\n    \"\"\"\n    output = []\n    for n in num_list:\n        output.append(n + num)\n    return output\n\nx: List[Union[int, float]] = add_all([3, 4, 5], 10)\n\nprint(x) # 13, 14, 15\n```\n\n- Union[int, float]은 int 또는 float 중 하나를 의미합니다.\n- List[Union[int, float]]은 정수 또는 소수의 리스트를 의미합니다.\n\nnum_list: List[Union[int, float]]은 num_list가 숫자 (정수 또는 소수)의 리스트여야 함을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, `num: Union[int, float]`은 num이 정수 또는 부동 소수점 숫자여야 함을 의미합니다.\n\n마지막으로, `- List[Union[int, float]]`은 이 함수가 정수 또는 부동 소수점 숫자들의 리스트를 반환해야 함을 의미합니다.\n\n참고 - 함수의 첫 줄에 우리 함수가 무엇을 하는지 간단히 설명하고 문서화하기 위해 (세 개의 따옴표로 둘러싼 것) 독스트링을 추가합니다.\n\n# 네, 이렇게 함수를 작성해야 합니다. 그렇지 않으면 PR이 거부될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 기술 리드가 우리에게 함수를 이렇게 작성하라고 요청하는지 알려드릴게요:\n\n- 변수의 데이터 유형이 한눈에 알 수 있습니다.\n- 이를 유추할 필요가 없어져 시간을 절약할 수 있습니다.\n- 함수가 반환해야 하는 것을 한눈에 알 수 있습니다.\n- 독스트링을 통해 함수가 하는 일을 코드를 살펴보지 않고도 한눈에 알 수 있습니다. 더 많은 시간을 절약할 수 있죠.\n- 이렇게 함으로써 함수가 장기적으로 유지보수하기에 더 적합해집니다.\n\n# 더 널리 사용되는 타입 힌트들\n\n기본 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\na: int = 5\n\nb: float = 3.14\n\nc: bool = True\n\nd: str = 'apple orange pear'\n```\n\n리스트, 사전, 튜플, 셋:\n\n```js\nfrom typing import List, Dict, Tuple, Set\n\n# 정수 리스트\na: List[int] = [1, 2, 3]  \n\n# 문자열 리스트\nb: List[str] = ['apple', 'orange'] \n\n# 키가 문자열이고 값이 정수인 사전\nc: Dict[str, int] = {'apple':4, 'orange':5}\n\n# 키가 정수이고 값이 부울인 사전\nd: Dict[int, bool] = {1: True, 2: False, 3: True}\n```\n\n변수가 정수 또는 부동 소수점 숫자일 수 있는 경우 Unions을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom typing import Union, Dict\n\ndef add10(number: Union[int, float]):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, Union[int, float, bool]]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n대안적인 방법으로 `Union`을 사용하는 대신에 다음과 같이 작성할 수 있습니다:\n\n```js\nfrom typing import Dict\n\ndef add10(number: int | float):\n    # number은 정수 또는 부동소수점이어야 합니다\n    pass\n\ndef test(d: Dict[str, int | float | bool]):\n    # d는 사전이어야 합니다\n    # d의 키는 모두 문자열이어야 합니다\n    # d의 값은 정수, 부동소수점 또는 부울이어야 합니다\n    pass\n```\n\n^ `Union[int, float]` 대신에 `int | float`을 사용하는 대체 방법입니다. 저는 이 방법을 더 우아하게 보이고(그리고 덜 타이핑해야 하기 때문에) 주로 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 옵셔널 변수에 대한 예제입니다:\n\n```python\nfrom typing import Optional\nfrom random import random\n\ndef test() -\u003e Optional[int]:\n    \"\"\"\n    50%의 확률로 1000 반환\n    50%의 확률로 None 반환\n    \"\"\"\n    random_float: float = random()\n\n    if random_float \u003e 0.5:\n        return 1000\n\n    return None\n```\n\n여기서 Optional[int]는 변수가 int 또는 None 중 하나일 수 있음을 나타냅니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 정말이죠. 만약 우리 중 누군가가 타입 주석이나 독스트링을 추가하지 않고 코드를 작성한다면, 우리는 리더들로부터 그것을 추가하라는 의견을 받게 될 거에요.\n\n그것이 나쁜 일은 아니에요, 왜냐하면 코드는 읽기 쉽도록 만들어졌으니까요.\n\n# 만약 크리에이터로서 저를 지원하고 싶다면\n\n- 제 책을 사 주세요! — 101 Things I Never Knew About Python\n- 어디서 찾을 수 있나요: https://payhip.com/b/vywcf\n- 이 이야기에 50번 박수를 보내주세요\n- 여러분의 생각을 나에게 말씀해 주세요\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"},"coverImage":"/assets/img/2024-06-23-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png","tag":["Tech"],"readingTime":5},{"title":"파이썬 코드 속도를 높이는 8가지 팁","description":"","date":"2024-06-23 13:29","slug":"2024-06-23-8TipstoSpeedUpYourPythonCode","content":"\n\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png)\n\n파이썬은 C/C++와 같은 컴파일된 언어와 비교했을 때 효율성과 성능 면에서 몇 가지 단점을 가지고 있는 스크립팅 언어입니다. 그러나 파이썬의 효율성이 상상 이상으로 과장되지 않는 경우가 많습니다. 이 기사는 파이썬 코드의 실행 속도를 높이는 몇 가지 팁을 요약한 것입니다.\n\n# 0 코드 최적화 원칙\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 Python 코드 실행 속도를 높이는 여러 기술을 소개할 것입니다. 코드 최적화의 세부 사항에 들어가기 전에 코드 최적화의 기본 원칙 몇 가지를 이해해야 합니다.\n\n첫 번째 기본 규칙은 너절로 최적화하지 말아야 한다는 것입니다. 많은 사람들이 성능 최적화를 목표로 코드를 작성하기 시작합니다. \"올바른 프로그램을 더 빠르게 만드는 것은 빠른 프로그램을 올바르게 만드는 것보다 훨씬 쉽습니다.\" 따라서 최적화의 선행 조건은 코드가 제대로 작동해야 한다는 것입니다. 조기 최적화는 종합적 성능 지표를 파악하는 것을 무시할 수 있습니다. 전역 결과를 얻기 전에 우선순위를 바꾸지 마세요.\n\n두 번째 기본 원칙은 최적화 비용을 따져보는 것입니다. 최적화에는 비용이 발생하며 모든 성능 문제를 해결하는 것은 거의 불가능합니다. 선택해야 하는 것은 일반적으로 공간에 대한 시간 또는 시간에 대한 공간입니다. 또한, 개발 비용도 고려해야 합니다.\n\n세 번째 원칙은 중요하지 않은 부분을 최적화하지 말아야 한다는 것입니다. 코드의 모든 부분을 최적화하려고 한다면 이러한 변경으로 코드가 읽고 이해하기 어려워질 수 있습니다. 코드가 느리게 실행된다면, 코드가 느린 부분을 찾아보고 보통 내부 루프에 해당하는 부분에 중점을 두어 최적화를 집중하세요. 그 외의 부분은 약간의 시간 손실이 큰 차이를 만들지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1 전역 변수 피하기\n\n```js\n# 비권장. 소요 시간: 26.8 초\nimport math\n\nsize = 10000\nfor x in range(size):\n    for y in range(size):\n        z = math.sqrt(x) + math.sqrt(y)\n```\n\n많은 프로그래머들은 파이썬에서 간단한 스크립트를 작성할 때 시작합니다. 스크립트를 작성할 때 일반적으로 위 코드와 같이 전역 변수로 직접 작성하는 습관이 있습니다. 그러나 전역 변수와 지역 변수의 구현 방식이 다르기 때문에 전역 범위에 정의된 코드는 함수에 정의된 코드보다 훨씬 느리게 실행됩니다. 스크립트 문장을 함수로 넣음으로써 일반적으로 15% ~ 30%의 속도 향상을 얻을 수 있습니다.\n\n```js\n# 권장. 소요 시간: 20.6 초\ndef main():\n    size = 10000\n    for x in range(size):\n        for y in range(size):\n            z = math.sqrt(x) + math.sqrt(y)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 점 피하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_2.png)\n\n## 2.1 모듈 및 함수 속성 접근 피하기\n\n```python\n# 권장되지 않음. 실행 시간: 14.5 초\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    for i in range(size):\n        result.append(math.sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n각각 . (속성 액세스 연산자)을 사용할 때 특정 메서드인 __getattribute__() 및 __getattr__()이 트리거됩니다. 이러한 메서드는 사전 작업을 수행하므로 추가 시간 소요가 발생할 수 있습니다. 속성 액세스는 from import 문을 통해 제거할 수 있습니다.\n\n```js\nfrom math import sqrt\n\ndef computeSqrt(size: int):\n    result = []\n    for i in range(size):\n        result.append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n제1 섹션에서 전역 변수보다 로컬 변수의 검색이 빠를 것이라고 언급했습니다. 때문에 빈번하게 액세스되는 변수 sqrt에 대해 이를 로컬 변수로 변경함으로써 작업을 가속화할 수 있습니다.\n\n```js\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    sqrt = math.sqrt\n    for i in range(size):\n        result.append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수학.sqrt 외에도 computeSqrt 함수에는 리스트의 append 메소드를 호출하는 .이 있습니다. 이 메소드를 지역 변수에 할당하여 computeSqrt 함수의 for 루프 내부에서의 . 사용을 완전히 제거할 수 있습니다.\n\n```js\n# 권장됨. 시간 소요: 7.9초\nimport math\n\ndef computeSqrt(size: int):\n    result = []\n    append = result.append\n    sqrt = math.sqrt\n    for i in range(size):\n        append(sqrt(i))\n    return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        result = computeSqrt(size)\n\nmain()\n```\n\n## 2.2 내부 속성 접근 피하기\n\n```js\n# 비권장. 시간 소요: 10.4초\nimport math\nfrom typing import List\n\nclass DemoClass:\n    def __init__(self, value: int):\n        self._value = value\n    \n    def computeSqrt(self, size: int) -\u003e List[float]:\n        result = []\n        append = result.append\n        sqrt = math.sqrt\n        for _ in range(size):\n            append(sqrt(self._value))\n        return result\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        demo_instance = DemoClass(size)\n        result = demo_instance.computeSqrt(size)\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`.table` 태그를 Markdown 형식으로 변경하세요.\n\n```js\n| Recommended | Cost time: 8.3 seconds |\n|--------------|-----------------------|\n| import math | |\n| from typing import List | |\n| |\n| class DemoClass: | |\n|\u0026nbsp;\u0026nbsp;def __init__(self, value: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self._value = value | |\n| |\n|\u0026nbsp;\u0026nbsp;def computeSqrt(self, size: int) -\u003e List[float]: | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;result = [] | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;append = result.append | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sqrt = math.sqrt | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;value = self._value | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for _ in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;append(sqrt(value)) | |\n|\u0026nbsp;\u0026nbsp;return result | |\n| |\n| def main(): | |\n|\u0026nbsp;\u0026nbsp;size = 10000 | |\n|\u0026nbsp;\u0026nbsp;for _ in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance = DemoClass(size) | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance.computeSqrt(size) | |\n| main() | |\n```\n\n# 3 불필요한 추상화 피하기\n\n```js\n| Not recommended | Cost time: 0.55 seconds |\n|-----------------|------------------------|\n| class DemoClass: | |\n|\u0026nbsp;\u0026nbsp;def __init__(self, value: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self.value = value | |\n| |\n|\u0026nbsp;\u0026nbsp;@property | |\n|\u0026nbsp;\u0026nbsp;def value(self) -\u003e int: | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return self._value | |\n|\u0026nbsp;\u0026nbsp;@value.setter | |\n|\u0026nbsp;\u0026nbsp;def value(self, x: int): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;self._value = x | |\n| |\n| def main(): | |\n|\u0026nbsp;\u0026nbsp;size = 1000000 | |\n|\u0026nbsp;\u0026nbsp;for i in range(size): | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance = DemoClass(size) | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;value = demo_instance.value | |\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;demo_instance.value = i | |\n| main() | |\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가 계층으로 코드를 래핑할 때 (데코레이터, 프로퍼티 액세스, 디스크립터와 같은), 코드 실행 속도가 느려질 수 있습니다. 대부분의 경우, 프로퍼티 액세스 사용 정의를 다시 검토하는 것이 필요합니다. 프로퍼티 액세서를 사용할 때 getter/setter 함수를 사용하는 것은 일반적으로 C/C++ 프로그래머가 남긴 코딩 스타일입니다. 꼭 필요하지 않은 경우, 간단한 속성을 사용해보세요.\n\n```js\n# 추천하는 방법. 실행 시간: 0.33 초\nclass DemoClass:\n    def __init__(self, value: int):\n        self.value = value\n\ndef main():\n    size = 1000000\n    for i in range(size):\n        demo_instance = DemoClass(size)\n        value = demo_instance.value\n        demo_instance.value = i\n\nmain()\n```\n\n# 4 데이터 복사 피하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4.1 무의미한 데이터 복사 피하기\n\n```js\n# 권장하지 않습니다. 시간 소요: 6.5 초\ndef main():\n    size = 10000\n    for _ in range(size):\n        value = range(size)\n        value_list = [x for x in value]\n        square_list = [x * x for x in value_list]\n\nmain()\n```\n\n위 코드에서 value_list는 완전히 불필요하며 불필요한 데이터 구조 또는 복사를 생성할 것입니다.\n\n```js\n# 권장합니다. 시간 소요: 4.8 초\ndef main():\n    size = 10000\n    for _ in range(size):\n        value = range(size)\n        square_list = [x * x for x in value]\n\nmain()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 다른 상황은 Python의 데이터 공유 메커니즘에 대해 지나치게 걱정하고 있거나 Python의 메모리 모델을 충분히 이해하거나 신뢰하지 않아 copy.deepcopy()와 같은 함수를 남용하는 경우입니다. 일반적으로 이러한 코드에서는 복사 작업을 제거할 수 있습니다.\n\n## 4.2 값을 교환할 때 중간 변수를 사용하지 마세요\n\n```js\n# 권장되지 않음. 소요 시간: 0.07초\ndef main():\n    size = 1000000\n    for _ in range(size):\n        a = 3\n        b = 5\n        temp = a\n        a = b\n        b = temp\n\nmain()\n```\n\n위 코드는 값을 교환할 때 임시 변수 temp를 생성합니다. 중간 변수의 도움 없이 코드는 더 간결하고 빨리 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 권장됨. 시간 소요: 0.06 초\ndef main():\n    size = 1000000\n    for _ in range(size):\n        a = 3\n        b = 5\n        a, b = b, a\n\nmain()\r\n```\n\n# 5 if 조건문의 단락회로 기능 사용하기\n\n```js\n# 권장되지 않음. 시간 소요: 0.05 초\nfrom typing import List\n\ndef concatString(string_list: List[str]) -\u003e str:\n    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}\n    abbr_count = 0\n    result = ''\n    for str_i in string_list:\n        if str_i in abbreviations:\n            result += str_i\n    return result\n\ndef main():\n    for _ in range(10000):\n        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']\n        result = concatString(string_list)\n\nmain()\r\n```\n\nif 조건문의 단락회로 특성은 if a and b와 같은 문장에서 a가 False인 경우 직접 반환되어 b가 계산되지 않고, if a or b와 같은 문장에서 a가 True인 경우 직접 반환되어 b가 더 이상 계산되지 않는 것을 의미합니다. 따라서 실행 시간을 절약하기 위해 or 문에서는 더 높은 확률로 True인 변수가 or 앞에 나와야 하며, and는 뒤로 미루어져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 권장사항. 시간 소요: 0.03 초\nfrom typing import List\n\ndef concatString(string_list: List[str]) -\u003e str:\n    abbreviations = {'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'}\n    abbr_count = 0\n    result = ''\n    for str_i in string_list:\n        if str_i[-1] == '.' and str_i in abbreviations:\n            result += str_i\n    return result\n\ndef main():\n    for _ in range(10000):\n        string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.']\n        result = concatString(string_list)\n\nmain()\r\n```\n\n# 6 루프 최적화\n\n![이미지](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_4.png)\n\n## 6.1 `while` 루프 대신 `for` 루프 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 비추천합니다. 소요 시간: 6.7 초\ndef computeSum(size: int) -\u003e int:\n    sum_ = 0\n    i = 0\n    while i \u003c size:\n        sum_ += i\n        i += 1\n    return sum_\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum_ = computeSum(size)\n\nmain()\n```\n\n파이썬의 `for` 루프가 `while` 루프보다 빠릅니다.\n\n```js\n# 추천합니다. 소요 시간: 4.3 초\ndef computeSum(size: int) -\u003e int:\n    sum_ = 0\n    for i in range(size):\n        sum_ += i\n    return sum_\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum_ = computeSum(size)\n\nmain()\n```\n\n## 6.2 명시적 `for` 루프 대신 암시적 `for` 루프 사용하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제에서는 명시적인 for 루프 대신 함축적인 for 루프를 사용할 수 있습니다.\n\n```js\n# 권장됨. 소요 시간: 1.7 초\ndef computeSum(size: int) -\u003e int:\n    return sum(range(size))def main():\n    size = 10000\n    for _ in range(size):\n        sum = computeSum(size)\n\nmain()\r\n```\n\n## 6.3 내부 `for` 루프의 계산 감소\n\n```js\n# 권장되지 않음. 소요 시간: 12.8 초\nimport math\n\ndef main():\n    size = 10000\n    sqrt = math.sqrt\n    for x in range(size):\n        for y in range(size):\n            z = sqrt(x) + sqrt(y)\n\nmain()\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 `sqrt(x)`은 for 루프 내에 있으며 각 훈련 과정마다 다시 계산되어 시간을 많이 소비합니다.\n\n```js\n# 권장됨. 소요 시간: 7초\nimport math\n\ndef main():\n    size = 10000\n    sqrt = math.sqrt\n    for x in range(size):\n        sqrt_x = sqrt(x)\n        for y in range(size):\n            z = sqrt_x + sqrt(y)\n\nmain()\r\n```\n\n# 7 numba.jit 사용\n\n위에서 소개한 예시를 따라 numba.jit을 사용합니다. numba는 Python 함수를 JIT 컴파일하여 기계 코드로 변환하여 코드 실행 속도를 크게 향상시킵니다. numba에 대한 자세한 정보는 아래 홈페이지를 참조하세요: [http://numba.pydata.org/numba.pydata.org](http://numba.pydata.org/numba.pydata.org).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 추천. 소요 시간: 0.62 초\nimport numba\n\n@numba.jit\ndef computeSum(size: float) -\u003e int:\n    sum = 0\n    for i in range(size):\n        sum += i\n    return sum\n\ndef main():\n    size = 10000\n    for _ in range(size):\n        sum = computeSum(size)\n\nmain()\r\n```\n\n# 8. 적절한 데이터 구조 선택하기\n\n![image](/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_5.png)\n\n파이썬의 내장 데이터 구조인 str, tuple, list, set, dict은 모두 C 언어로 최하위 수준에서 구현되어 매우 빠릅니다. 성능 측면에서 내장 속도를 달성하기 위해 스스로 새로운 데이터 구조를 구현하는 것은 거의 불가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nList는 C++의 std::vector과 유사하며, 동적 배열이다. 일정량의 메모리 공간을 미리 할당한다. 미리 할당된 메모리 공간이 사용되고 요소가 추가될 때, 더 큰 메모리 공간이 적용된다. 그럼 기존 요소를 모두 복사하고 이전 메모리 공간을 파괴하며 새 요소를 삽입한다.\n\n요소를 삭제할 때도 유사하다. 사용된 메모리 공간이 미리 할당된 메모리 공간의 절반보다 작으면 추가적인 작은 메모리가 적용되고, 요소 복사가 이루어진 뒤 큰 원래 메모리 공간이 파괴된다.\n\n따라서, 자주 추가 및 삭제 작업이 이뤄지고 추가 및 삭제된 요소의 수가 많은 경우, 리스트의 효율성은 높지 않을 수 있다. 이때 collections.deque를 사용하는 것을 고려해야 한다. collections.deque는 스택과 큐의 특성을 모두 가지며, 양쪽 끝에서 O(1) 복잡도의 삽입 및 삭제 작업을 수행할 수 있다.\n\n리스트 검색 작업도 매우 시간이 소요된다. 리스트에서 특정 요소를 자주 검색하거나 순서대로 이러한 요소에 자주 액세스해야 하는 경우, bisect를 사용하여 리스트 객체의 순서를 유지하고 검색 효율성을 향상시킬 수 있는 이진 검색을 수행할 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자주 필요한 요구사항은 최솟값 또는 최댓값을 찾는 것입니다. 이 경우 heapq 모듈을 사용하여 리스트를 힙으로 변환하여 최솟값을 얻는 시간 복잡도를 O(1)로 만들 수 있습니다.\n\n다음 웹 페이지에는 일반적으로 사용되는 Python 데이터 구조의 다양한 작업의 시간 복잡도가 나와 있습니다: [Python Time Complexity](https://wiki.python.org/moin/TimeComplexity).\n\n참고:\n\n- David Beazley \u0026 Brian K. Jones. Python Cookbook, Third edition. O’Reilly Media, ISBN: 9781449340377, 2013.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼도 방문해 주세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 대해 걱정할 필요 없는 블로그 플랫폼이 필요하시다구요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png"},"coverImage":"/assets/img/2024-06-23-8TipstoSpeedUpYourPythonCode_0.png","tag":["Tech"],"readingTime":13},{"title":"JVM 없이 순수 파이썬으로 데이터 레이크 감사 및 게시 방법","description":"","date":"2024-06-23 13:27","slug":"2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM","content":"\n\n## 아파치 아이스버그, 람다 및 프로젝트 네시를 사용하여 WAP의 오픈 소스 구현, 모두 Python으로 완전히 실행\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png)\n\n# 소개\n\n이 블로그 포스트에서는 Apache Iceberg를 열린 테이블 포맷으로 사용하고 git과 유사한 시맨틱을 지원하는 데이터 카탈로그인 프로젝트 네시를 사용하여 데이터 레이크에서 Write-Audit-Publish(WAP) 패턴에 대한 간결한 참조 구현을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNessie를 선택한 이유는 그 분기 기능이 WAP 디자인을 구현하는 데 좋은 추상화를 제공하기 때문입니다. 무엇보다도 개발자 경험 측면에서 JVM이 필요하지 않도록 PyIceberg를 기반으로 구축하도록 선택했습니다. 실제로 통합 애플리케이션을 포함한 전체 프로젝트를 실행하려면 Python과 AWS만 필요합니다.\n\nNessie는 기술적으로 Java로 구축되었지만 이 프로젝트에서는 데이터 카탈로그가 AWS Lightsail에 의해 컨테이너로 실행되며 우리는 단지 엔드포인트를 통해서만 상호 작용할 것입니다. 결과적으로 우리는 Python에서 쿼리 다운스트림을 포함한 전체 WAP 로직을 표현할 수 있습니다!\n\nPyIceberg가 상대적으로 새로운데, 기본으로 지원되지 않는 것들이 많습니다. 특히, 쓰기는 여전히 초기 단계에 있으며, Iceberg 테이블의 분기는 아직 지원되지 않습니다. 따라서 여기에서 찾을 수 있는 것은 Python에서 직접 Nessie에서 Iceberg 테이블을 분기하는 것이 가능하도록 우리가 직접 수행한 일부 원래 작업의 결과입니다.\n\n그렇게 해서 모든 것이 어느 정도 이루어졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 와닝! 낯선 단어 \"WAP\"이 나타났어요!\n\n2017년에 Netflix의 Michelle Winters가 데이터에서 사용되는 디자인 패턴인 Write-Audit-Publish (WAP)에 대해 이야기를 했어요. 기본적으로 WAP는 데이터 품질 검사를 하기 쉽게 만들기 위한 기능적 디자인을 지향해요. 이를 통해 데이터가 하류 사용자에게 제공되기 전에 데이터 품질 검사를 구현하는 것이 목표에요.\n\n예를 들어, 대표적인 사용 사례는 데이터 수집 시 데이터 품질을 확인하는 것이에요. 이 과정은 새로 수집된 데이터에 대해 스테이징 환경을 생성하고 품질 테스트를 진행한 후, 해당 데이터를 하류 애플리케이션에 제공하는 것처럼 보여요.\n\n이름에서 알 수 있듯이, WAP에는 기본적으로 세 단계가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작성. 소비자가 접근할 수 없는 위치에 데이터를 배치하십시오(예: 스테이징 환경 또는 브랜치).\n- 감사. 데이터를 변환하고 테스트하여 사양을 준수하는지 확인하십시오(예: 스키마가 갑자기 변경되었거나 NULL과 같이 예기치 않은 값이 있는지 확인).\n- 배포. 데이터를 소비자가 읽을 수 있는 위치에 배치하십시오(예: 프로덕션 데이터 레이크).\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_1.png)\n\n이것은 WAP 패턴의 가능한 응용 사례 중 하나에 불과합니다. ETL 및 데이터 수집부터 분석 및 ML 응용프로그램을 지원하는 복잡한 데이터 파이프라인까지 데이터 수명주기의 다양한 단계에서 적용할 수 있다는 것을 쉽게 알 수 있습니다.\n\n매우 유용한 WAP이지만 아직 널리 보급되지 않았으며 최근에 기업들이 더 체계적으로 생각하기 시작했습니다. 오픈 테이블 형식 및 Nessie, LakeFS와 같은 프로젝트의 등장으로 이 과정이 가속화되고 있지만 아직은 조금 전방적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어쨌든, 데이터에 대해 생각하는 아주 좋은 방법이며, 엔지니어들을 깨어나게 하는 일반적인 문제를 해결하는 데 굉장히 유용합니다. 그래서 우리가 어떻게 구현할 수 있는지 살펴봅시다.\n\n# Python에서 데이터 레이크에 대한 WAP\n\n우리는 WAP에 대한 이론적 논의를 하지 않을 것이며, 다른 방법을 구현하는 방법의 철저한 조사를 제공하지 않을 것입니다 (Dremio의 Alex Merced 및 LakeFs의 Einat Orr가 이미 이에 대해 훌륭한 작업을 하고 있습니다). 대신, 데이터 레이크에 대한 WAP의 참조 구현을 제공할 것입니다.\n\n# 아키텍처 및 워크플로우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 아이디어는 섭밽 워크플로우를 시뮬레이션하고 데이터 레이크를 분기하고 데이터 품질 테스트를 실행하여 WAP 패턴을 구현하는 것입니다. 그 후 해당 데이터를 데이터 레이크의 최종 테이블에 넣을지 결정합니다.\n\n저희는 Nessie 분기 기능을 사용하여 다운스트림 소비자가 데이터를 읽을 수 없는 샌드박스 환경을 확보하고 AWS Lambda를 사용하여 WAP 로직을 실행합니다.\n\n기본적으로 새로운 파케이 파일이 업로드될 때마다 람다가 실행되어 데이터 카탈로그에서 브랜치를 생성하고 데이터를 아이스버그 테이블에 추가합니다. 그런 다음, PyIceberg를 사용하여 간단한 데이터 품질 테스트를 수행하여 테이블의 특정 열에 NULL 값이 포함되어 있는지 확인합니다.\n\n만약 그렇다면, 데이터 품질 테스트가 실패합니다. 새로운 브랜치는 데이터 카탈로그의 주요 브랜치에 병합되지 않으며, 데이터 레이크의 주요 브랜치에서 데이터를 읽을 수 없게 됩니다. 대신, 슬랙으로 경고 메시지가 전송될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 답이 '아니오'이고 데이터에 NULL 값이 포함되어 있지 않다면, 데이터 품질 테스트가 통과됩니다. 새 브랜치는 데이터 카탈로그의 주 브랜치로 병합되며 다른 프로세스가 읽을 수 있도록 데이터 레이크의 Iceberg 테이블에 데이터가 추가됩니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_2.png)\n\n모든 데이터는 완전히 합성되어 있으며 프로젝트를 실행함으로써 자동으로 생성됩니다. 물론, 데이터 품질 사양을 준수하는 데이터를 생성할지 또는 일부 NULL 값을 포함하는 데이터를 생성할지 선택할 수 있습니다.\n\n전체 엔드투엔드 플로우를 구현하기 위해 다음 구성 요소를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저장소: AWS S3\n- 오픈 테이블 형식: Apache Iceberg\n- 데이터 카탈로그: Project Nessie\n- 코드 구현: PyIceberg, PyNessie\n- 서버리스 런타임: Lambda\n- 가상 전용 서버: Lightsail\n- 경보 시스템: Slack\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_3.png)\n\n이 프로젝트는 상당히 자립적이며 전체 인프라를 설정하는 스크립트가 함께 제공되므로 AWS 및 Python에 대한 입문 수준만 있으면 됩니다.\n\n또한, 이 프로젝트는 프로덕션에 즉시 사용할 수 있는 솔루션이 아닌 참고 구현으로, 더 복잡한 시나리오를 위한 출발점입니다. 코드는 매우 상세하고 주석이 많아서 기본 개념을 수정하고 확장하여 누구의 사용 사례에 더 적합하게 만드는 것이 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시각화\n\n데이터 품질 테스트 결과를 시각화하기 위해 매우 간단한 Streamlit 앱을 제공합니다. 새 데이터가 S3의 첫 번째 위치에 업로드될 때 발생하는 일을 확인할 수 있습니다 — 이 위치는 하류 소비자들에게 제공되지 않습니다.\n\n앱을 사용하여 서로 다른 브랜치 간의 테이블에 있는 행의 개수를 확인할 수 있습니다. 또한, main 이외의 브랜치에서는 데이터 품질 테스트가 실패한 열과 행 수를 쉽게 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 호수에서 호수집까지\n\n아이스버그를 기반으로 한 WAP 플로우가 구성되면 이를 활용하여 하류 소비자를 위해 구성 가능한 디자인을 구현할 수 있습니다. 우리의 저장소에는 이러한 아키텍처 가능성을 탐색하는 방법으로 Snowflake 통합을 설명하는 지침을 제공합니다.\n\n![이미지](/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_5.png)\n\n이것은 호수집 아키텍처의 주요 원칙 중 하나로, 현대 데이터 웨어하우스보다 유연하고 전통적인 데이터 호수보다 사용하기 쉬운 설계로 고안되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한편, Lakehouse는 객체 저장소를 활용하여 데이터 중복을 제거하고 동시에 저장 비용을 낮추는 데 의존하며, 다른 목적을 위해 다양한 컴퓨트 엔진을 선택하는 데 더 많은 유연성을 제공해야 합니다.\n\n모든 것이 이론상 매우 흥미로워 보이지만, 대규모로 엔지니어링하는 것은 매우 복잡하게 느껴질 수 있습니다. 심지어 Snowflake와 S3 버킷 간의 단순한 통합조차 꽤 지루할 정도입니다.\n\n그렇다고 해도, 천 마일의 여정도 한 걸음부터 시작된다는 것을 염두에 두면, 간단하지만 구체적이고 실용적인 결과를 얻을 수 있는 가장 낮은 과일을 따라가는 게 어떨까요?\n\n저장소에서의 예시는 WAP 및 데이터 품질 테스트 중 하나를 보여줍니다. 여기서 WAP 패턴은 데이터 품질 테스트(그리고 어떤 경우에는 일부 적재 ETL에 대해서도)에 필요한 계산을 데이터 웨어하우스 외부로 이동시키는 기회를 제공하면서도 인증된 자산에 대한 높은 가치 분석 워크로드에 대한 Snowflake의 장점을 활용할 수 있도록 합니다. 이 게시물이 개발자들이 자신의 개념 증명을 구축하고 이용하는 데 도움이 되기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n여기 제안된 참조 구현에는 여러 가지 장점이 있습니다:\n\n## 테이블이 파일보다 좋습니다\n\n데이터 레이크는 과거에 개발하기 어려웠던 영역이었습니다. 왜냐하면 데이터 추상화는 일반적으로 좋은 구식 데이터베이스에서 채택된 것과 매우 다르기 때문입니다. Spark와 같은 Big Data 프레임워크는 먼저 파일로 저장된 대량의 원시 데이터를 처리할 수 있는 기능을 제공했지만, 사람들은 종종 파일의 관점으로 생각하지 않고 테이블의 관점으로 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이유가 있어 오픈 테이블 형식을 사용합니다. Iceberg는 주 파일 대신 테이블로 주 데이터 레이크 추상화를 변환하여 상당히 직관적으로 만듭니다. 데이터를 탐색하기 위해 이제는 SQL 쿼리 엔진을 네이티브로 사용할 수 있으며 정확한 스키마 진화를 제공할 수 있도록 Iceberg를 신뢰할 수 있습니다.\n\n## 상호 운용성이 좋아요\n\nIceberg는 아키텍처적으로 더 큰 상호 운용성도 허용합니다. 오픈 테이블 형식을 사용하는 주요 이점 중 하나는 데이터를 객체 저장소에 보관하면서 고성능 SQL 엔진(Spark, Trino, Dremio) 및 데이터 창고(Snowflake, Redshift)를 사용하여 쿼리할 수 있다는 것입니다. Iceberg가 대부분의 계산 엔진에서 지원된다는 사실은 우리가 데이터 플랫폼을 설계하는 방식에 깊은 영향을 미칩니다.\n\n위에서 설명한 대로, Snowflake와의 제안된 통합은 조정으로 ETL 처리 및 데이터 품질 테스트를 데이터 창고 밖으로 이동시키고 대규모 분석 작업 및 고성능 필요한 마지막 마일 쿼리에 대한 데이터 창고를 유지하는 것이 대규모 분석 작업으로 전환되어 상당히 낮은 비용으로 이어질 수 있다는 것을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 브랜치는 유용한 추상화입니다\n\nWAP 패턴은 데이터를 소비자가 실수로 읽을 수 없는 위치에 작성하는 방법을 필요로 합니다. 브랜치 세맨틱스는 이를 구현하는 방법을 제공하므로, 데이터 카달로그 수준에서 브랜치 세맨틱스를 활용하기 위해 Nessie를 사용합니다. Nessie는 Iceberg 및 해당 타임 트래버스 및 테이블 브랜치 기능을 기반으로 구축됩니다. 우리의 레포지토리에서 수행하는 많은 작업은 Nessie를 직접 Python에서 작동하도록 만드는 것입니다. 결과적으로 Nessie 카달로그에 상호 작용하고 데이터 카달로그의 여러 브랜치에 Iceberg 테이블을 작성할 수 있으며 JVM 기반 프로세스를 사용하지 않아도 됩니다.\n\n## 개발자 경험을 간소화합니다\n\n마지막으로, 끝에서 끝까지 완전히 Python 기반 경험을 만드는 것은 시스템 설정 및 상호 작용을 현저하게 간소화합니다. 우리가 알고있는 다른 시스템은 JVM이나 추가 호스팅 서비스가 필요하거나 서로 다른 브랜치에 다시 Iceberg 테이블을 작성하기 위해 외부에서 호스팅되어야 하는 반면, 이 구현에서는 전체 WAP 논리가 단일 람다 함수 내에서 실행될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJVM에는 본질적으로 문제가 없습니다. 많은 빅데이터 프레임워크의 근본적인 구성 요소로서, 특정 플랫폼 리소스와 작업하기 위한 공통 API를 제공함과 동시에 보안과 정확성을 보장합니다. 그러나 JVM은 개발자 경험 측면에서 부담이 될 수 있습니다. Spark와 작업한 사람들은 JVM 기반 시스템이 까다로우며 신비한 오류로 실패하는 경향이 있다는 사실을 알고 있습니다. 데이터 작업을 하는 많은 사람들은 Python을 주 프로그래밍 언어로 삼고 있기 때문에 JVM의 이점이 사용성 측면에서 비용이 드는 것으로 여겨집니다.\n\n우리는 이러한 것들처럼 더 많은 사람들이 조립 가능한 디자인에 대해 흥미를 가지길 바라며, Iceberg와 Arrow와 같은 오픈 표준이 표준이 될 것을 희망합니다. 그리고 무엇보다도 우리는 이것이 유용할 것이라고 기대합니다.\n\n그렇게 됩니다.","ogImage":{"url":"/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png"},"coverImage":"/assets/img/2024-06-23-Write-Audit-PublishforDataLakesinPurePythonnoJVM_0.png","tag":["Tech"],"readingTime":8},{"title":"Matplotlib, Pandas, Scikit으로 하는 지구 온난화 분석 방법","description":"","date":"2024-06-23 13:26","slug":"2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit","content":"\n\nNASA의 실제 글로벌 표면 온도 데이터 분석입니다.\n\n지난 몇 년 동안 여름에 온도 상승을 느낄 수 있었어요. 우리는 지난 몇 십 년간 NASA에 기록된 글로벌 표면 온도 지수에 대한 연구를 진행하고 파이썬 선형 회귀 모델을 기반으로 미래 추세를 파악할 거에요.\n\n![Global Warming Plot](/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png)\n\n지난 140년간의 지구 온난화 그래프:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터 프레임 gw에 전체 지구 온난화 데이터를 로드하고, 지난 140년간의 완전한 그래프 플롯을 생성했습니다 (음수 섭씨는 녹색, 양수 섭씨는 빨강색). 1970년부터 온도가 천천히 빨간 색으로 변하기 시작했고, 되돌아보지 않은 것 같습니다. 표면 온도가 0도 섭씨를 넘어선 후로 남극과 북극의 얼음이 천천히 녹고 있습니다.\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ngw = pd.read_csv(\"Global_Warming.csv\") # 지구 온난화 데이터를 gw에 로드합니다.\n\nx = gw['Year'] # 연도 값을 x에 할당합니다.\ny = gw['Index'] # 지수 값을 y에 할당합니다.\n\ngw2000 = gw[(gw['Year'] \u003e 1999)]  # 2000년 이후의 데이터를 gw2000에 할당합니다.\ngw2010 = gw[(gw['Year'] \u003e 2009)]  # 2010년 이후의 데이터를 gw2010에 할당합니다.\n\nx1 = gw2000['Year']\ny1 = gw2000['Index']\n\nx2 = gw2010['Year']\ny2 = gw2010['Index']\n\n# 음수 지수는 녹색, 양수는 빨간색으로 표시됩니다.\ncolors = np.where(gw['Index'] \u003e= 0, 'r', 'g') \n\nplt.figure(figsize =(20,8))\nplt.subplot(2, 1, 1)  # 전체 그래프를 표시할 첫 번째 행입니다.\nplt.xlabel('Year') \nplt.ylabel('Index') \nplt.bar(x, y, color=colors)\n\nplt.subplot(2, 2, 3) # 2000년 이후 그래프를 표시할 두 번째 행 첫 번째 열입니다.\nplt.xlabel('2000년부터의 연도') \nplt.ylabel('Index') \nplt.scatter(x1, y1, s=100, c='y', marker=\"o\", alpha=1, edgecolor='r')\n\nplt.subplot(2, 2, 4) # 2010년 이후 그래프를 표시할 두 번째 행 두 번째 열입니다.\nplt.xlabel('2010년부터의 연도') \nplt.ylabel('Index') \n\nplt.scatter(x2, y2, s=400, c='r', marker=\"^\", alpha=1, edgecolor='b')\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_1.png\" /\u003e\n\n직선 방정식의 값을 식별하는 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nY = mx + c의 직선 방정식입니다.\n여기서 m은 추세의 기욱이고 c는 Y-절편의 높이입니다.\nscikit 라이브러리를 사용하여 기울기(m)와 Y-절편(c)의 값을 생성할 예정입니다.\n\n```js\n# 완전한 데이터 세트 중 1974 이후의 데이터로 데이터프레임 생성.\nfrom sklearn.linear_model import LinearRegression\nmodel = LinearRegression()\nX = np.array(gw1974['Year'])\ny = np.array(gw1974['Index'])\nregression_model = LinearRegression() # scikit의 선형 회귀 모델 사용\nregression_model.fit(X.reshape(-1,1), y)\nslope = regression_model.coef_  # 기울기 값 식별\nintercept = regression_model.intercept_ # Y-절편 값 식별\nprint(\"기울기(m) 값은 \", slope, \"|| Y-절편(c) 값은 \", intercept)\n```\n\n```js\n1975년 이후의 NASA 표면 온도 지수(Celsius) 데이터셋입니다.\nYear Index\n1975 0.02\n1976 0.04\n1977 0.07\n1978 0.12\n1979 0.16\n...\n2022 1.00\n2023 1.02\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래 추세를 생성하기 위해 기울기와 Y-절편을 기반으로 하는 테이블 값을 변환했습니다:\n\n```js\ndef line(x):\n  # 함수 y = mx + c에 기울기(m)와 절편(c) 값을 할당합니다.\n  return 0.0196163 * x + (-38.71344489795919) \nx_pred = range(1974,2051)  # 1974년부터 2051년까지의 범위입니다.\n\n# 연도가 증가함에 따라 직선 방정식을 기반으로 기울기가 추가됩니다.\ny_pred = [line(i) for i in x_pred] \n\nimport matplotlib.pyplot as plt\nfig,ax = plt.subplots()\nax.bar(gw1974['Year'],gw1974['Index'],color = ['g'])\nax.stackplot(x_pred,y_pred, color=\"y\",linewidth = 2.5,linestyle = '--',alpha = 0.40)\nax.set_xlabel('Year')\nax.set_ylabel('표면 온도 지수')\nplt.title('지구 온난화 추세')\nplt.show()\n```\n\n직선 방정식을 기반으로 미래 추세를 생성하고, 지구 표면 지수가 매우 빠른 시간 내에 1.4도 섭씨를 넘는 것을 확인했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 몇 년 동안 표면 온도 분석을 기반으로 한 추론:\n\n- 탄소 배출이 중요하게 제어/감소되지 않으면 다음 24년 안에 표면 온도가 1.40도 섭씨를 넘을 것입니다.\n- 탄소 배출량이 증가하면 2050년 이전에 표면 온도가 1.50도 섭씨를 넘을 가능성이 있습니다.\n- 지속 가능한 에너지(태양광, 풍력, 수력, 생물 에너지)가 앞으로 지구 온난화를 통제하는 유일한 해결책이 될 것입니다.\n\n분석을 통해, 온난화가 개념으로만 여겨졌던 것보다 실제로 더 위험한 것으로 보입니다. 탄소 배출이 감소되지 않으면 전 세계적으로 재앙적인 기후 변화가 발생할 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png"},"coverImage":"/assets/img/2024-06-23-GlobalWarmingAnalyticsusingMatplotlibPandasandScikit_0.png","tag":["Tech"],"readingTime":4}],"page":"6","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"6"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>