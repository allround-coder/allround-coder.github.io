<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/6" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/6" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " href="/post/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 </strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" href="/post/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" href="/post/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="글의 가능성을 높이는 단어 카운터와 텍스트 분석기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">글의 가능성을 높이는 단어 카운터와 텍스트 분석기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 clean code를 작성하는 방법" href="/post/2024-05-20-Whyshouldweusecleancodeinflutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 clean code를 작성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 clean code를 작성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Flutter에서 clean code를 작성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 코드를 작성하는 간단한 방법" href="/post/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 코드를 작성하는 간단한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 코드를 작성하는 간단한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">플러터에서 코드를 작성하는 간단한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 최고의 Bloc 상태 관리 파트 2" href="/post/2024-05-20-BestBlocstatehandlinginFlutterpart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 최고의 Bloc 상태 관리 파트 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 최고의 Bloc 상태 관리 파트 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">플러터에서 최고의 Bloc 상태 관리 파트 2</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 3.22에 새로 추가된 내용 정리" href="/post/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 3.22에 새로 추가된 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 3.22에 새로 추가된 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">플러터 3.22에 새로 추가된 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Google IO, Flutter가 발표한 최신 내용들 정리" href="/post/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Google IO, Flutter가 발표한 최신 내용들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Google IO, Flutter가 발표한 최신 내용들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Google IO, Flutter가 발표한 최신 내용들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" href="/post/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" href="/post/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">34<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link posts_-active__YVJEi" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"5가지 최고 무료 Python 앱 호스팅 플랫폼 2024 ","description":"","date":"2024-05-20 23:24","slug":"2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives","content":"\n\n파이썬 스크립트를 실행하는 방법이 궁금하거나 파이썬 애플리케이션을 서버에 배포하는 방법을 알고 싶거나, 파이썬 프로젝트에 대한 최상의 클라우드 호스팅 솔루션을 찾고 계신다면 망설이지 마세요.\n\n![이미지](/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png)\n\n본 비교에서는 네이티브 파이썬 지원을 제공하는 다섯 가지 인기 호스팅 플랫폼을 살펴볼 것입니다. 비교를 도와줄 이전 멘션되지 않은 Heroku가 마지막에 포함되어 있습니다.\n\n본 비교는 다음 기준을 탐색합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어\n- 가장 저렴한 유료 인스턴스의 비용\n- 배포 방법\n- 지원되는 워크로드\n- 네이티브 파이썬 지원\n- 도커 파일 지원\n- 지원되는 지역\n- 기본 인프라\n- 파이썬 배포에 대한 문서\n\n모든 이 솔루션은 클라우드에서 애플리케이션을 신속하게 배포하는 데 도움이 됩니다. 이 비교 기준은 귀하의 프로젝트에 가장 적합한 솔루션을 식별하는 데 도움이 될 것입니다. 이제 소개 없이 2024년에 당신의 파이썬 애플리케이션을 호스팅할 수 있는 최고의 호스팅 플랫폼을 살펴보겠습니다.\n\n# 1. Koyeb\n\n웹사이트: https://www.koyeb.com/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어: 서비스 하나 및 관리형 PostgreSQL 데이터베이스 하나 배포 가능합니다.\n- 가장 저렴한 유료 인스턴스 비용: eNano 인스턴스는 초 단위로 과금됩니다. 한 달 동안 실행하면 $1.61이 소요됩니다.\n- 배포 방법: Git을 통한 배포 및 Docker 기반의 배포가 가능합니다. CLI 및 제어판을 통해 실행할 수 있습니다.\n- 지원하는 워크로드: 풀 스택 애플리케이션, 웹 서비스, API, 백그라운드 작업 및 데이터베이스를 지원합니다.\n- 네이티브 Python 지원: ✅ 플랫폼에 배포된 Python 프로젝트를 식별하고 빌드하는 네이티브 빌드팩이 제공됩니다.\n- Dockerfile 지원: ✅ Dockerfile에서 빌드할 수 있어 빌드 프로세스를 더 세밀하게 제어할 필요가 있는 경우에도 지원됩니다.\n- 지원하는 지역: 세계 세 대륙에 걸쳐 총 여섯 개의 지역을 지원합니다. 샌프란시스코(미국), 워싱턴 D.C.(미국), 프랑크푸르트(독일), 파리(프랑스), 도쿄(일본) 및 싱가포르.\n- 기반이 되는 인프라: Koyeb는 베어 메탈 머신에서 직접 실행됩니다.\n\nPython 배포용 문서\n\n- Koyeb에서 Python Flask 배포\n- Koyeb에서 Python Django 배포\n- Koyeb에서 Python FastAPI 배포\n- Koyeb에서 Git을 통한 Python 배포\n- Koyeb에서 Celery Worker 배포\n\n# 2. pythonanywhere.com\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어: 웹 애플리케이션 1개\n- 가장 저렴한 유료 인스턴스 비용: 월 $5\n- 배포 방법: GitHub 또는 Bitbucket을 통해 배포합니다. 도커 컨테이너를 배포할 수 없습니다. CLI 및 대시보드 사용 가능\n- 지원하는 작업 부하: 웹 애플리케이션, 크론 작업, 데이터베이스 및 정적 사이트\n- 네이티브 파이썬 지원: 가능\n- Dockerfile 지원: Dockerfile에서 빌드 지원 불가\n- 지원하는 지역: 미국 동부의 1개 위치. 플랫폼의 EU 버전은 프랑크푸르트 지역에 작업 부하를 실행합니다.\n- 기반이 되는 인프라: PythonAnywhere은 AWS 위에서 실행됩니다.\n\nPython 배포를 위한 문서\n\n- PythonAnywhere에서 Python Flask 배포하기\n- PythonAnywhere에서 Python Django 배포하기\n\n# 3. Render\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹사이트: https://render.com/\n\n- 무료 티어: 매달 한 서비스당 750시간.\n- 가장 저렴한 유료 인스턴스 비용: 월 $7.\n- 배포 방법: Git 및 Docker 기반 배포. CLI 및 제어판 제공.\n- 지원되는 Workloads: 웹 서비스, 정적 사이트, 데이터베이스 및 cron 작업.\n- 네이티브 파이썬 지원: Render에서 파이썬을 배포할 수 있도록 네이티브 런타임 제공.\n- Dockerfile 지원: Dockerfile에서 빌드하는 기능도 지원됩니다.\n- 지원되는 지역: 세 대륙에 걸쳐 네 개 지역 – 오리건 (미국), 오하이오 (미국), 프랑크푸르트 (독일), 싱가포르.\n- 기본 인프라: Render는 AWS 및 GCP 상에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n- Render에서 Python Django 배포하기\n- Render에서 Python Flask 배포하기\n- Render에서 Celery Worker 배포하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. Fly.io\n\n- 무료 티어: $5 회원 가입 크레딧. 무료 자원을 사용하여 최대 3개의 서비스를 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월 $1.94\n- 배포 방법: 애플리케이션, 크론 작업, 대기열 및 데이터베이스.\n- 지원되는 워크로드: 도커화된 애플리케이션.\n- 내장된 Python 지원: 내장 Python 빌더 탑재.\n- Dockerfile 지원: Dockerfile에서 빌드 지원됨.\n- 지원되는 지역: 전 세계 35개 지역 지원.\n- 기반이 되는 인프라: Fly.io는 베어 메탈 머신 상에서 실행됩니다.\n\nPython 배포에 대한 문서\n\n- Fly.io에서 Python Flask 배포하기\n- Fly.io에서 Python Django 배포하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. DigitalOcean 앱 플랫폼\n\n웹사이트: https://www.digitalocean.com/products/app-platform\n\n- 무료 티어: 무료로 3개의 정적 사이트를 빌드하고 배포할 수 있습니다.\n- 가장 저렴한 유료 인스턴스 비용: 월별 $5.\n- 배포 방법: Git 기반의 배포 및 미리 빌드된 Docker 이미지 사용 가능.\n- 지원하는 워크로드: 어플리케이션, 정적 사이트, 크론 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네이티브 빌드팩으로 파이썬 프로젝트를 식별하고 빌드합니다.\n- Dockerfile 지원: Dockerfile로부터 빌드하는 기능을 지원합니다.\n- 지원되는 지역: 9개 지역을 지원합니다.\n- 기반 인프라: DigitalOcean 앱 플랫폼은 DigitalOcean의 인프라에서 실행됩니다.\n\n파이썬 배포를 위한 문서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DigitalOcean 앱 플랫폼에 Python Flask 배포\n- DigitalOcean 앱 플랫폼에 Python Django 배포\n\n# 6. Heroku\n\n웹사이트: https://www.heroku.com/\n\n- 무료 티어: Heroku는 무료 티어를 중단했습니다.\n- 가장 저렴한 유료 인스턴스 비용: 매월 $5.\n- 배포 방법: Git 기반의 배포 및 미리 구축된 Docker 이미지 사용.\n- 지원되는 작업 부하 유형: 애플리케이션, 백그라운드 작업, cron 작업, 데이터베이스.\n- 네이티브 파이썬 지원: 네, Heroku의 네이티브 빌드팩은 파이썬 프로젝트를 인식하고 빌드합니다.\n- Dockerfile 지원: Heroku는 Dockerfile에서 빌드하는 것을 지원하지만, Heroku는 고급 사용 사례에 대해 Heroku 컨테이너 스택 사용을 권장합니다. Heroku의 기본 빌드팩 시스템이 권장됩니다.\n- 지원되는 지역: 유럽과 미국 두 군데의 지역이 지원됩니다. 엔터프라이즈 플랜이 없으면.\n- 기본 인프라: Heroku는 AWS 위에서 운영됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 배포에 대한 문서\n\n- 파이썬 시작하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/getting-started-with-python)\n- Heroku에서 파이썬 및 장고 앱 배포하기: [여기를 클릭하세요](https://devcenter.heroku.com/articles/deploying-python)\n\n# 결론: 원하는 곳에 배포하세요!\n\n다뤄 본 내용: 무료 티어, 배포 방법, 워크로드 호환성, 기본 인프라 및 예산을 그대로 유지할 수 있는 유료 요금제에 대해 다루었습니다. 아마도 여러분의 프로젝트에 가장 적합한 선택을 할 수 있도록 도움이 될 통찰력을 발견했을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 비교를 마무리하면, 여러분의 호스팅 플랫폼은 앱의 성능에 영향을 미칠 뿐만 아니라 데브옵스에서 시간을 확보하여 앱 개발에 집중할 수도 있습니다. 행복하고 빠른 배포를 기원합니다!","ogImage":{"url":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png"},"coverImage":"/assets/img/2024-05-20-5TopFreeHostingPlatformsforPythonApps2024BestHerokuAlternatives_0.png","tag":["Tech"],"readingTime":5},{"title":"Ecotone을 활용한 Symfony 다중 테넌트 애플리케이션","description":"","date":"2024-05-20 23:21","slug":"2024-05-20-SymfonyMulti-TenantApplicationswithEcotone","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png\" /\u003e\n\n비즈니스 도메인에 따라 멀티 테넌시를 어떻게 구현하는지가 달라집니다. 데이터베이스를 공유해야 할 수도 있고 완전히 격리된 별도의 데이터베이스를 필요로 할 수도 있습니다. 테넌트가 몇 개뿐인 경우도 있지만 수백 개인 경우도 있습니다. 주어진 테넌트의 성능에 대한 쿼터링 또는 성능 향상이 필요할 수 있습니다. 이 모든 것은 멀티 테넌시가 기술적인 측면 뿐만 아니라 비즈니스적인 고려 사항이기도 함을 의미합니다.\n\n이전 기사에서는 최소한의 노력으로 Laravel 및 Ecotone을 사용하여 멀티 테넌트 시스템을 구축하는 방법에 대해 설명했습니다. 이번에는 Symfony 프레임워크에 대해 동일한 작업을 수행할 것입니다.\n\n이 기사의 시나리오는 각 섹션의 끝에 연결된 데모와 함께 제시될 것입니다. 이렇게 하면 예제를 논의할 뿐만 아니라 실행 가능한 데모를 참고할 수도 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테넌트별 데이터베이스로 메시지 전송\n\n만약 전자 상거래 도메인에서 활동 중이고 각각이 별도의 데이터베이스를 가지고 있는 두 개의 테넌트가 있다고 가정합시다(DB per Tenant 전략).\nE-커머스 시스템에서 가장 먼저 발생해야 하는 것은 새로운 고객 등록이며, 이것에 대해 지금 집중하겠습니다.\n\n새로운 고객을 등록하는 과정은 다음과 같이 진행됩니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 Command Handler로 등록 고객 Command Message를 보낼 것입니다.\n\nCommand Bus를 사용하여 Command Handler에 등록 고객 Command를 보내서 새로운 고객을 데이터베이스에 저장할 것입니다. 중요한 부분은 주어진 테넌트와 관련된 데이터베이스에 고객을 저장하려고 한다는 것입니다.\n\n시작하기 위해 Symfony용 Ecotone을 설치해 봅시다:\n\n이를 통해 Ecotone의 Symfony 통합 및 데이터베이스 지원 도구를 제공받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테넌트에 대한 연결 매핑\n\n우리는 예제로 Doctrine ORM을 사용할 것입니다. 각 테넌트는 자체 데이터베이스 연결을 갖게 될 것이므로, 먼저 각 테넌트에 대한 Doctrine 구성을 정의해야합니다(doctrine.yaml).\n\n연결이 정의되면, 이제 어떻게 테넌트 이름에 매핑될지 설정할 수 있습니다. Ecotone의 ServiceContext 속성으로 표시된 구성 방법을 사용하여 수행합니다.\n\n이것이 기본적으로 전부입니다. Ecotone은 이제 지정된 테넌트 이름이 지정된 연결에 매핑되는 방법을 알게 됩니다. 따라서 어떤 종류의 메시지(명령/쿼리/이벤트)를 보내면 어떤 연결을 사용해야 하는지 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Multi-Tenant Command Handler\n\n우리는 다중 테넌트 시스템에 Ecotone의 CQRS를 사용할 것입니다. 이를 통해 다중 테넌트 시스템에서 사용할 수 있는 다양한 기본 기능을 제공받습니다.\n\n우리의 Register Customer Command Handler를 정의해봅시다:\n\nCommand Handler를 보면 특별한 것이 없는 것을 알 수 있습니다. PHP 속성으로 표시된 비즈니스 로직을 수행하는 메서드일 뿐입니다. 우리의 Command Handler는 Command Class를 가져와 Doctrine ORM을 사용하여 고객을 저장합니다. 이 코드는 단일 테넌트 환경에서도 문제없이 작동할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 꼼꼼한 부분은 특정 Tenant에 대한 ObjectManager/EntityManager를 사용해야 한다는 것입니다. 각 Tenant마다 자체 데이터베이스 연결이 있기 때문입니다.\n#[MultiTenantObjectManager] 속성을 추가함으로써 Ecotone에게 현재 활성화된 Tenant에 대한 ObjectManager를 주입하도록 알려줍니다. 이렇게 하면 고객을 올바른 Tenant의 데이터베이스에 저장하고 코드를 Multi-Tenancy에 대해 직관적으로 유지할 수 있습니다.\n\n이제 RegisterCustomer Command Class를 정의해봅시다:\n\nCommand Class는 간단한 POPO (Plain Old PHP Object)이며 특정 프레임워크 클래스를 확장하거나 구현하지 않습니다. Command에는 고객 등록에 필요한 모든 데이터가 포함되어 있습니다.\n\n# Multi-Tenant Message Bus\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 코드베이스에 Command Handler를 소개한 후에는 이제 주어진 테넌트에 대해 Command를 보낼 수 있습니다.\n우리는 주어진 테넌트의 문맥에서 주어진 Command를 실행할 것입니다:\n\n여기서는 Command를 Command Bus를 통해 보내고 메타데이터 (메시지 헤더)를 사용하여 테넌트 이름을 전달합니다. 이렇게 하면 Ecotone이 해당 Command Handler를 주어진 테넌트의 데이터베이스 context에서 수행하고 있다는 것을 이해할 것입니다. 일반적으로 HTTP 도메인 또는 사용자 세션을 기반으로 여기서 테넌트 이름을 해결할 것입니다.\n\n이것이 말 그대로 다중 테넌트 환경에서 고객을 저장하는 데 필요한 모든 것입니다. 기본적으로 우리의 코드는 단일 테넌트 또는 다중 테넌트 모두에 대해 작동할 것입니다. 다중 테넌시에 완전히 중립적이기 때문입니다. 이제 우리의 다중 테넌트 시스템에서 필요할 수 있는 더 많은 시나리오를 확인해 봅시다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공유 및 다중 데이터베이스 테넌트\n\n기본적으로 우리는 각 테넌트를 동일한 데이터베이스에 넣지만, 고객이 프리미엄을 구매하면 별도의 데이터베이스 인스턴스를 받게되는 비즈니스 모델을 가질 수 있습니다.\n\n이러한 경우를 처리하기 위해 Ecotone은 기본 연결을 제공합니다. 따라서 주어진 테넌트 이름에 대한 매핑이 없는 경우 기본값이 사용됩니다:\n\n# 메시지 핸들러에서 현재 테넌트에 액세스하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 시나리오에서는 실행이 수행되는 테넌트의 맥락을 인식해야 할 수도 있습니다. 예를 들어, 특정 테넌트가 고급 상점을 가지고 있을 때는 주문 후 즉시 배송이 이뤄져야 하지만, 다른 테넌트에게는 시간이 중요하지 않을 수도 있습니다.\n\nEcotone의 경우, 메시지 헤더(메타데이터)를 통해 전송하는 모든 것은 메시지 핸들러 수준에서 접근할 수 있습니다. 따라서 필요에 따라 특정 메타데이터를 무시하거나 접근할 수 있습니다. 그리고 메시지 헤더를 통해 테넌트 이름을 전송하므로 필요한 경우 이를 접근할 수 있습니다:\n\n헤더 속성은 접근하려는 메시지 헤더를 나타냅니다. 우리의 경우, 우리가 이전에 커맨드 버스를 통해 전송한 테넌트 헤더에 접근하려고 합니다.\n\n# 테넌트 전환에 연결하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 멀티 테넌트 애플리케이션이 실행 중이라면, 사용자 정의 라이브러리나 통합을 사용하고 있을 가능성이 높습니다. 이러한 경우 특정 테넌트가 활성화되거나 비활성화될 때 일부 코드를 트리거해야 할 수도 있습니다.\n\nEcotone은 테넌트 전환 프로세스에 훅을 걸 수 있는 가능성을 엽니다. 여기에서 활성화될 Connection과 테넌트 이름을 제공할 수 있습니다.\n\n활성화할 메소드를 OnTenantActivation 또는 OnTenantDeactivation으로 표시하기만 하면 되며, 지정된 메소드는 트리거될 것이며 이에 따라 작업이 수행됩니다. 이 방법으로 특정 어트리뷰트로 메소드를 표시함으로써, 흐름에 훅을 걸고 필요한 로직을 수행할 수 있습니다.\n\n데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이벤트 및 테넌트 전파\n\n고객이 등록되면 환영 메시지가 포함된 이메일을 보내는 등 부수 효과를 발생시키고 싶을 수 있습니다. 이러한 상황에서는 이벤트 및 이벤트 핸들러를 정의할 수 있습니다.\n\n고객이 등록되면 Event Bus를 사용하여 CustomerWasRegistered 이벤트 메시지를 발행합니다. 그런 다음 구독하는 이벤트 핸들러에 대한 모든 메서드(첫 번째 매개변수는 구독하는 이벤트를 지정)가 실행됩니다.\n\nEcotone을 사용하면 이벤트 핸들러에서 테넌트 메시지 헤더에 액세스할 수 있습니다. 이는 Ecotone의 메타데이터 전파 기능 덕분에 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 링크에서 데모 구현을 찾을 수 있습니다.\n\n# 컨텍스트 및 메타데이터 전파\n\nEcotone은 기본적으로 모든 메시지 헤더를 자동으로 전파합니다. 이를 통해 컨텍스트인 테넌트를 보존합니다. 우리의 경우, 고객 등록이 진행된 테넌트의 컨텍스트에서 알림을 보낼 것입니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메타데이터는 명령에서 발행된 이벤트로 자동 전파됩니다.\n\n물론 우리는 Event Handlers에서 또한 테넌트 이름에 접근할 수 있습니다.\n\n## 비동기 이벤트\n\n우리는 기본적으로 이벤트 핸들러를 동기적으로 실행할 수 있지만 비동기적으로 실행할 수도 있습니다. Ecotone은 RabbitMQ, Redis, Database 채널과 같은 비동기 처리를 위한 통합 세트를 제공하며 Symfony Messenger Transport를 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 데이터베이스 채널을 사용하려고 합니다. 이는 주어진 테넌트의 메시지를 해당 테넌트의 데이터베이스에 저장할 것으로 기대됩니다. 이를 위해 Ecotone의 데이터베이스 메시지 채널을 사용할 것입니다. 이는 멀티 테넌시를 지원하기 때문에 사용합니다.\n\n![Image](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_3.png)\n\n이제 이벤트 핸들러를 비동기적으로 처리하도록 표시해 봅시다.\n\n해당 이벤트 핸들러는 이제 비동기적으로(백그라운드에서) 처리된다는 것을 의미하고, 이벤트 메시지는 \"notifications\" 메시지 채널로 전송될 것입니다. 그래서 이 채널을 데이터베이스 큐로 정의합시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 이벤트 핸들러를 비동기로 구성하는 데 필요한 모든 작업은 여기까지입니다. 이제 이벤트 핸들러가 실행될 때마다 이벤트 메시지가 주어진 테넌트의 데이터베이스 대기열로 먼저 이동한 다음 비동기적으로 소비될 것입니다.\n\n# 비동기 메시지 소비자 실행\n\n비동기 메시지 채널(우리 경우 데이터베이스 대기열)에 메시지를 발행하면 이를 소비해야 합니다.\n메시지 소비자를 실행하기 위해 내장된 콘솔 명령 \"ecotone:run\"을 사용할 것입니다:\n\n이 명령은 \"notifications\" 채널로 오는 메시지를 가져와 실행하는 별도의 메시지 소비 프로세스가 실행될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 테넌트 환경에서 운영 중이며 우리의 \"알림\"은 데이터베이스 큐입니다. 이는 각 테넌트마다 별도의 대기열을 가진 별도의 데이터베이스가 있음을 실제로 의미합니다. 이것은 소비 과정에서 고려되어야 합니다.\n\n작업 중인 비즈니스 도메인에 따라 수백 개의 테넌트가 있을 수 있으므로 수백 개의 메시지 소비자를 실행하는 것이 이상적이라고는 할 수 없습니다. 이러한 상황에서 Ecotone은 기본적으로 라운드로빈 전략을 사용하여 단일 프로세스를 사용하여 수용합니다. 이는 각 테넌트에서 순서대로 가져올 것을 의미합니다:\n\n![이미지](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_4.png)\n\nEcotone은 다중 테넌트에서 메시지를 소비하는 데 라운드 로빈 전략을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법으로 소비하는 것은 즉시 작동합니다. 이를 실현하기 위해 고객 구성을 할 필요가 없습니다. 메시지 소비 속도를 높이고 싶다면 해당 프로세스를 여러 개 실행할 수 있습니다.\n사실, 우리는 특정 프리미엄 테넌트의 메시지 소비 속도를 높이거나, 많은 메시지를 생성하는 테넌트의 제어를 가져가서 전체 프로세스를 관리할 수 있습니다. 그러나 이 부분은 별도의 기사에서 탐구할 것입니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 데이터베이스 트랜잭션 및 아웃박스 패턴\n\n시스템을 장애에 강하게 만들기 위해 데이터베이스 트랜잭션을 활성화하고 싶을 수 있습니다. 물론 우리의 경우에는 트랜잭션을 지정된 테넌트의 데이터베이스에 대해 시작하길 원할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_5.png\" /\u003e\n\nCommand Bus가 실행될 때 자동으로 데이터베이스 트랜잭션이 시작됩니다.\n\n우리가 Command를 실행할 때 Ecotone은 올바른 테넌트 데이터베이스를 자동으로 시작하기 위해 데이터베이스 트랜잭션을 시작합니다. 이것은 Symfony Starter와 함께 설치된 Dbal Module에서 사용 가능한 기능으로, 추가 구성이 필요하지 않습니다. 트랜잭션을 구성하는 방법에 대해 더 알고 싶다면 문서를 참조해 주세요.\n\n이벤트를 데이터베이스 큐로 비동기적으로 발행할 때 이 역시 트랜잭션으로 처리됩니다. 이렇게 함으로써 예외가 발생한 경우 모든 과정이 함께 롤백될 것임을 확신할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![SymfonyMulti-TenantApplicationswithEcotone_6](/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_6.png)\n\n이 작업은 Multi-Tenant 시스템에서 Outbox 패턴으로 작동합니다. 이외에도 Ecotone은 메시지가 데이터베이스에서 메시지 브로커(예: RabbitMQ, Redis, SQS)로 자동으로 이동될 수 있는 결합된 메시지 채널을 제공합니다. 이렇게 하면 메시지 처리가 메시지 브로커 소비자(그리고 그것들을 확장할 수 있음)를 위해 이루어지고, 데이터베이스 소비자가 아닙니다.\n\n# Dbal Business Methods\n\nDbal 모듈은 Business Interface를 제공하는데, 이는 추상화된 형태로 감춰진 데이터베이스 쿼리를 쉽게 작성할 수 있는 방법입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이루고 싶은 것의 인터페이스를 정의하고 Ecotone이 해결방안을 처리합니다. 이것은 우리가 해야 할 일은 인터페이스를 작성하는 것뿐이며 구현은 제공되며 의존성 컨테이너에 등록될 것임을 의미합니다.\n비즈니스 인터페이스는 메시지 핸들러(Command/Query/Event Handlers)에서 호출될 때 자동으로 테넌트의 연결을 상속받습니다.\n\n더 많은 정보를 알고 싶다면 Dbal을 기반으로 한 비즈니스 인터페이스 사용에 대한 이 기사를 읽어보세요.\n\n# 명령을 직접 모델로 보내기\n\nEcotone은 명령을 우리의 Doctrine ORM Entity에 직접 보내는 것을 지원합니다. 이 방법으로는 어떤 위임 수준의 코드도 작성할 필요가 없습니다.\n물론, 이는 멀티 테넌시와 함께도 작동합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서 보듯이 정적 팩토리 메서드를 생성했습니다. 이 방법으로 Ecotone에게 이 팩토리 메서드 \"register\"가 새로운 고객을 생성한다고 알려줍니다. 이 메서드가 실행된 후, Ecotone은 해당 테넌트에 대해 EntityManager를 사용하여 올바른 데이터베이스에 저장합니다.\n이것은 더 이상 이와 같은 코드를 작성할 필요가 없다는 것을 의미합니다:\n\n컨트롤러 측에서는 아무 것도 바뀌지 않고 이전과 똑같이 보냅니다:\n\n중요한 점은 이것이 Action 기반 메서드에 대해서도 작동하며, 일부 시나리오에서 Command 클래스를 완전히 없앨 수 있게 합니다:\n\n그리고 다음과 같이 Command Bus를 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmetadata를 통해 aggregate.id를 전달하여 어떤 Customer 인스턴스에서 메서드를 실행할지를 나타낼 수 있습니다. 이 주제에 대해 더 알아보려면 Doctrine ORM을 Aggregate로 사용하는 방법에 대해 이 기사에서 읽을 수 있습니다.\n\n데모 구현은 이 링크에서 찾을 수 있습니다.\n\n# 이벤트 소싱\n\n시스템에서 다른 뷰를 구축하거나 변경 사항을 감사하는 경우, Event Sourcing을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEcotone는 다양한 테넌트 시스템을 위해 프로덕션에 적합한 이벤트 소싱 애플리케이션을 신속하게 구현할 수 있는 완전한 이벤트 소싱 지원이 제공됩니다.\n\n이 프로세스는 이전에 살펴본 Doctrine ORM 집합체와 동일하게 작동합니다. 차이점은 이벤트 소싱된 집합체가 내부 상태를 변경하는 대신 이벤트 클래스를 반환한다는 것입니다.\n\n## Auto-Setup\n\n물론, 각 테넌트의 이벤트를 저장할 곳이 필요한데, 이를 위해 테넌트의 데이터베이스에 이벤트 저장소를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에코톤은 이벤트의 직렬화와 역직렬화, 주어진 테넌트 데이터베이스에 이벤트 스토어 설정(포스트그레SQL, MySQL, MariaDB에 내장된 지원) 및 리드 모델 프로젝션 설정을 도와줍니다.\n\n## 리드 모델 프로젝션\n\n프로젝션은 이벤트에서 다양한 뷰를 만드는 데 사용됩니다. 각 프로젝션은 데이터베이스의 별도의 테이블이나 테이블 세트일 수 있으며 동적으로 생성됩니다:\n\n이벤트가 발행되면 관련 프로젝션이 트리거됩니다. 메타데이터에 기반하여 에코톤은 어떤 테넌트와 관련이 있는지 이해하고 이전에 발생하지 않은 경우 프로젝션을 초기화할 것입니다.\n초기화 후 우리 프로젝션의 이벤트 핸들러가 트리거됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 모든 작업은 동기적으로 발생하며, 이는 이벤트 소싱을 작업하기 매우 쉽게 만듭니다. 필요한 경우 프로젝션을 비동기적으로 실행하도록 전환할 수도 있습니다.\n\n더 많은 내용을 알고 싶다면 문서를 참조하세요. 이벤트 소싱 주제에 대해 더 탐구하고 싶다면 데모 구현은 다음 링크에서 찾을 수 있습니다.\n\n# 요약\n\n이 문서에서는 미리 계획된 코드를 사용하여 Multi-Tenant 친화적인 Symfony 애플리케이션을 구축하는 방법을 활성화했습니다. 이 방식을 통해 우리가 작성한 코드는 어떠한 변경 없이도 단일 테넌트 및 멀티 테넌트 환경에서 작동할 수 있어 애플리케이션을 쉽게 구축하고 유지할 수 있습니다. Ecotone은 컨텍스트 전파를 처리해 줍니다. 따라서 코드가 동기적인지 비동기적인지에 상관없이 작업이 실행되는 테넌트의 컨택스트가 우리를 위해 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 처리와 백그라운드 작업을 시작하게 되면 더 정교한 큐 기반 솔루션이 필요할 수 있습니다. 메시지를 너무 많이 생성하는 테넌트의 처리량을 제어하고, \"프리미엄\" 테넌트의 처리 속도를 높이며, 쉽게 작업할 수 있는 방식으로 실패 및 재시도를 처리하고자 할 때 이러한 문제가 발생할 수 있습니다. Ecotone은 이를 제공하지만, 이 주제는 별도의 글이 필요합니다.","ogImage":{"url":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png"},"coverImage":"/assets/img/2024-05-20-SymfonyMulti-TenantApplicationswithEcotone_0.png","tag":["Tech"],"readingTime":10},{"title":"글의 가능성을 높이는 단어 카운터와 텍스트 분석기","description":"","date":"2024-05-20 23:19","slug":"2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer","content":"\n\n텍스트 분석을 통해 더 나은 글을 작성할 수 있는 잘 알려진 도구입니다\n\n![Image](/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png)\n\n참고: 이것은 제가 Medium에 작성한 첫 번째 기사이므로, 부디 제 미숙한 글쓰기와 오타를 용서해 주시기 바랍니다. 😊\n\n안녕하세요 여러분!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 잘 알려진 속담으로 기사를 시작하려고 합니다:\n\n\"정확하게 사용한다면 모든 말이 할 수 있는 일을 강조하는 가장 좋은 방법입니다.\"\n\n기사를 발행할 글이나 시험 답안을 분석해야 하는 상황에 처해본 적이 있나요?\n\n그렇다면, 저는 텍스트를 분석하고 단어 수, 불용어, 고유한 단어, 단락, 문장, 줄 수 등과 같은 중요한 통계 정보를 제공하며 독해, 쓰기, 말하기, 타이핑 시간과 같은 시간 관련 측정값을 제공하는 효과적인 도구를 개발했다는 것을 기쁘게 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것을 고려해도 무료이며 모든 기능에 무제한 액세스가 가능합니다.\n\n이 도구를 사용하려면 여기에서 이용할 수 있습니다: [https://livingtocode.com/word-counter/](https://livingtocode.com/word-counter/) 자유롭게 확인해보세요.\n\n이 도구는 SEO 전문가, 학생, 작가, 연구자, 저자, 선생님들이 일상생활에서 글을 평가하고 최적화하는 데 도움이 될 수 있습니다.\n\n위의 모두에 대해 처음이더라도 이 도구는 여전히 글쓰기 기술을 향상시키는 데 도움이 되며, 동기부여를 제공하고 제한 내에서 텍스트를 최적화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"많은 도구들이 이미 같은 작업을 수행하고 있지만, 가능성을 탐험하기 위해 한 번 만들어 보고 싶었습니다.\n\n건의나 개선 아이디어가 있으면 언제든 환영합니다.\n\n의견을 공유해 주세요.\n\n읽어 주셔서 감사합니다.\"","ogImage":{"url":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png"},"coverImage":"/assets/img/2024-05-20-Improveyourwordpotentialwithawordcounterandtextanalyzer_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 clean code를 작성하는 방법","description":"","date":"2024-05-20 23:18","slug":"2024-05-20-Whyshouldweusecleancodeinflutter","content":"\n\n![image](/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png)\n\n플러터에서 깨끗한 코드를 사용하는 것은 유지보수성, 가독성, 확장성 및 디버깅의 용이성을 포함한 여러 가지 이유로 중요합니다. 아래에는 깨끗한 코드의 중요성을 설명하기 위한 몇 가지 구체적인 예와 함께 자세한 설명이 나와 있습니다.\n\n- 유지보수성\n\n깨끗한 코드는 이해하기 쉽고 수정하기 쉽습니다. 코드베이스가 커질수록 잘 구성되고 이해하기 쉬운 코드를 가지고 있으면 버그를 수정하고 새로운 기능을 추가하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// .......................코드 작성이 잘못된 부분............................\n\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('내 앱'),\n    ),\n    body: Column(\n      children: [\n        Text('내 앱에 오신 것을 환영합니다', style: TextStyle(fontSize: 24)),\n        RaisedButton(\n          onPressed: () {\n            // 복잡한 로직\n          },\n          child: Text('눌러보세요'),\n        ),\n      ],\n    ),\n  );\n}\n\n// .......................깔끔한 코드...................................\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: _buildAppBar(),\n      body: _buildBody(),\n    );\n  }\n\n  AppBar _buildAppBar() {\n    return AppBar(\n      title: Text('내 앱'),\n    );\n  }\n\n  Widget _buildBody() {\n    return Column(\n      children: [\n        _buildWelcomeText(),\n        _buildPressMeButton(),\n      ],\n    );\n  }\n\n  Widget _buildWelcomeText() {\n    return Text(\n      '내 앱에 오신 것을 환영합니다',\n      style: TextStyle(fontSize: 24),\n    );\n  }\n\n  Widget _buildPressMeButton() {\n    return RaisedButton(\n      onPressed: _handlePressMeButton,\n      child: Text('눌러보세요'),\n    );\n  }\n\n  void _handlePressMeButton() {\n    // 복잡한 로직\n  }\n}\n```\n\n깔끔한 코드 예제에서, build 메서드는 더 작고 더 집중된 메서드로 분해되어 유지보수가 더 쉽습니다.\n\n2. 가독성\n\n깔끔한 코드는 더 읽기 쉽고 이해하기 쉽습니다. 이는 코드가 작성되기보다는 더 자주 읽히기 때문에 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// .......................작성된 코드가 좋지 않습니다............................\n\nvoid updateUserProfile(User user) {\n  if (user.name != null \u0026\u0026 user.email != null) {\n    // 프로필 업데이트\n  }\n}\n\n\n// ............................깨끗한 코드................................\n\nvoid updateUserProfile(User user) {\n  if (_isUserProfileValid(user)) {\n    _updateProfileInDatabase(user);\n  }\n}\n\nbool _isUserProfileValid(User user) {\n  return user.name != null \u0026\u0026 user.email != null;\n}\n\nvoid _updateProfileInDatabase(User user) {\n  // 프로필 업데이트\n}\n```\n\n깨끗한 코드 예제는 조건을 잘 명명된 메서드로 추상화하여 가독성을 향상시킵니다.\n\n3. 확장성\n\n프로젝트가 확장될수록, 깨끗한 코드는 코드베이스의 품질을 저하시키지 않고 새로운 기능을 추가하는 것을 더 쉽게 만듭니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// ..........잘못 작성된 코드.........\n\nvoid performAction(String action) {\n  if (action == 'login') {\n    // 로그인 로직\n  } else if (action == 'logout') {\n    // 로그아웃 로직\n  } else if (action == 'signup') {\n    // 가입 로직\n  }\n}\n\n// ...........깔끔한 코드...............\n\nvoid performAction(String action) {\n  switch (action) {\n    case 'login':\n      _login();\n      break;\n    case 'logout':\n      _logout();\n      break;\n    case 'signup':\n      _signup();\n      break;\n    default:\n      _handleUnknownAction();\n  }\n}\n\nvoid _login() {\n  // 로그인 로직\n}\n\nvoid _logout() {\n  // 로그아웃 로직\n}\n\nvoid _signup() {\n  // 가입 로직\n}\n\nvoid _handleUnknownAction() {\n  // 알 수 없는 동작 처리\n}\n```\n\n깔끔한 코드 예시는 switch 문을 사용하여 동작을 각각의 메서드로 분리하여 새로운 동작을 추가하기 쉽게 만듭니다.\n\n4. 디버깅 용이성\n\n깔끔한 코드는 더 직관적으로 코드를 추적하고 실행 흐름을 이해하기 쉬워져 디버깅을 단순화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘못 작성된 코드:\n\n```js\n// ...........잘못 작성된 코드..............\n\nvoid processOrder(Order order) {\n  if (order.isValid()) {\n    if (order.total \u003e 100) {\n      applyDiscount(order);\n    }\n    // 주문 처리\n  }\n}\n\n\n// ...........깨끗한 코드..............\n\nvoid processOrder(Order order) {\n  if (!order.isValid()) {\n    return;\n  }\n  _applyDiscountIfEligible(order);\n  _processOrderDetails(order);\n}\n\nvoid _applyDiscountIfEligible(Order order) {\n  if (order.total \u003e 100) {\n    applyDiscount(order);\n  }\n}\n\nvoid _processOrderDetails(Order order) {\n  // 주문 처리\n}\n```\n\n깨끗한 코드 예시에서는 로직이 작고 관리하기 쉬운 메소드로 분해되어 있어 이해하고 디버그하기가 더 쉽습니다.\n\n추가 예시: 변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// ........잘못 작성된 코드......\n\nint a;\nString b;\n\n// ........깔끔한 코드..........\n\nint productCount;\nString activeUserName;\n```\n\n함수:\n\n```js\n// ........잘못 작성된 코드.......\n\nvoid doSomething();\nString getSomething();\n\n// ........깔끔한 코드..........\n\nvoid updateProductCount() {\n  // ...\n}\n\nString getUserName() {\n  // ...\n}\n```\n\n클래스:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n// ......잘못 작성된 코드....\n\nclass MyClass {\n  // ...\n}\n\n// ........깔끔한 코드..........\n\nclass VideoList {\n  // ...\n}\n\nclass UserAccount {\n  // ...\n}\n\n\n## 결론\n\nFlutter에서 깔끔한 코드를 사용하면 코드베이스가 유지 가능하고 가독성이 높고 확장 가능하며 쉽게 디버깅할 수 있습니다. 깔끔한 코드 원칙을 준수하면 애플리케이션의 전반적인 품질을 향상시켜 미래에 코드를 작업할 때 자신과 다른 사람들이 더 쉽게 작업할 수 있게 됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 즐겁게 보셨기를 바라요! 제공된 정보를 감사하게 여기신다면, 'Buy Me A Coffee'로 저를 지원할 수 있어요! 여러분의 센스에 감사드릴 거예요!","ogImage":{"url":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png"},"coverImage":"/assets/img/2024-05-20-Whyshouldweusecleancodeinflutter_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터에서 코드를 작성하는 간단한 방법","description":"","date":"2024-05-20 23:16","slug":"2024-05-20-ASimplewaytoorganizeyourcodeinFlutter","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png\" /\u003e\n\n플러터를 개발 앱에 매일 사용하는 과정에서 앞으로도 문제가 되지 않도록 코드를 체계적으로 구성할 방법을 찾고 있었습니다. 여러 프로젝트를 유지하는 것은 언제나 쉽지 않은 일이며, 코드가 깨끗할수록 쉬워집니다. 그래서 이전에 네이티브 안드로이드, Apache Flex, 심지어 PHP와 같은 기술을 경험한 바탕으로 체계적인 프로젝트 구조를 만들었습니다. 여러분에게도 도움이 되었으면 합니다.\n\n# 앱의 구조\n\n저는 모든 프로젝트에서 사용하는 이 구조를 사용하여 프로젝트 간의 이동이 쉽고 물건의 위치를 파악하기 위해 더 이상 찾아다니지 않아도 됩니다. 저희 팀은 이 구조에 익숙해져 있어, 제작량을 최소화하여 며칠 안에 앱을 개발할 수 있는 수준까지 줄일 수 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_1.png)\n\n자, 좀 더 구조에 대해 이야기해 봐요:\n\n화면: 이 폴더에는 일반적으로 앱의 모든 화면이 들어갑니다. 스크린샷에서 볼 수 있듯이, 각 화면에는 각각의 폴더가 있습니다. 이 구체적인 예에서 이 앱에는 하단 내비게이션 바를 사용하는 홈 화면과 4개의 주요 화면(war, news, major_orders, game)이 있습니다. 이 부분에 대해 나중에 더 자세히 설명하겠습니다.\n\n위젯: 이 폴더에는 일반적으로 앱의 재사용 가능한 위젯이 들어갑니다. 이 폴더에는 custom_scaffold와 \"리사이클러\" 또는 리스트 아이템 위젯과 같은 파일을 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스: 나는 내가 만드는 앱에서 사용하는 모든 외부 서비스를 가지고 있는 DIO 폴더로 알려진 것이다. 여기에는 보통 앱에 데이터를 공급하는 REST API에 연결하는 클래스들이 포함되어 있습니다.\n\n모델: 서비스 폴더를 따라서 항상 나는 모델(객체 클래스)들을 Models라는 별도의 폴더에 유지합니다. 과거에 Flex 또는 AIR를 사용한 사람들을 위해, 이곳은 예전에 내 ValueObjects 폴더였습니다. 사전 용어에 대한 모델 예시:\n\n```js\nclass TermVO {\n  int? id;\n  String? title;\n  String? description;\n  String? language;\n\n  TermVO({this.id, this.title, this.description, this.language});\n\n  TermVO.fromJson(Map\u003cString, dynamic\u003e json) {\n    id = json['id'];\n    title = json['title'];\n    description = json['description'];\n    language = json['language'];\n  }\n}\n```\n\n유틸리티: 이 폴더는 외부 API나 로컬 라이브러리를 위한 \"도우미\" 파일들의 집입니다. 여기에는 Firebase 헬퍼 클래스, OneSignal 헬퍼 클래스 또는 우리 프로젝트에서 문자열을 포맷하는 함수를 포함하는 내 StringHelper 클래스와 같은 것들이 들어갈 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nStyles: 테마와 스타일을 포함하므로 직관적입니다.\n\nCommons.dart: 이 파일은 앱에서 사용되는 모든 것을 주요 \"import\"로 사용합니다. 이렇게 하면 파일에서 하나의 파일만 가져오면 빠른 리팩터링, 변경 또는 라이브러리 추가에도 도움이 됩니다.\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_2.png)\n\n이 구조를 사용하면 큰 프로젝트조차도 상당히 조직화하여 귀하의 삶을 훨씬 쉽게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# UI와 코드의 분리\n\n우리 모두 알다시피, Flutter는 의견이 강제되지 않아서 코드를 자유롭게 작성할 수 있습니다. Flutter에서 부족하다고 생각했던 한 가지는 Native Android(xml + kt 파일)나 심지어 사랑하는 과거 기술인 Apache Flex(MXML으로 UI를 작성하고 코드는 AS로 분리)처럼 코드와 UI를 분리하는 것이었습니다. 개발자 친구와 함께 이를 논의한 결과, Roipeker님의 제안을 토대로 이 아이디어를 실현했습니다. 이것이 바로 우리가 여기에 있는 이유입니다(Roipeker님 감사합니다).\n이 아이디어의 핵심은 각 화면이 UI를 포함하는 한 개의 파일과 화면의 모든 기능, 변수, 작동 코드를 포함하는 다른 파일로 분리된다는 것입니다.\nREST API에서 뉴스 목록이 포함된 화면의 예시를 살펴보겠습니다.\n\n![News screen](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_3.png)\n\n\"뉴스\" 화면은 UI를 포함하는 *_screen.dart 파일과 기능을 포함하는 *_controller.dart 파일로 나뉘어 있음을 확인할 수 있습니다. 이를 달성하기 위해, screen.dart에서 \"part 'news_controller.dart'\"를 사용하고, controller.dart 파일에서는 \"part of 'news_screen.dart'\"를 사용합니다. 이렇게 두 파일이 하나처럼 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image1](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_4.png)\n\nYou can see that the first file is simple and only contains the UI part.\n\n![image2](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_5.png)\n\nThis is the controller file which is used to load the news and sort them. As you can see, the newsList is loaded with content in the `controller.dart` and used in the `screen.dart`.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 간단한 예제이지만 코드를 정리하고 깨끗하게 유지하는 두 파일을 가지는 가치를 볼 수 있습니다.\n\n더 나아가서 개발 시간을 최소화하는 것을 목표로 이를 더 발전시키기 위해 Android Studios에서 File 및 Code 템플릿으로 통합했습니다. 이렇게 하면 각 새로운 화면을 빠르게 만들 수 있습니다.\n\n# 2개 파일의 화면 구조에 대한 템플릿 만들기\n\n이를 템플릿에 추가하려면 다음 단계를 따라야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_6.png)\n\n- 파일 — 설정 — 코드 스타일 — 파일 및 코드 템플릿\n- 새 항목 추가\n- 아무 이름으로 지정 (저는 뷰 상태를 이름으로 사용했습니다)\n\n![screenshot](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_7.png)\n\n- 파일 이름은 $'NAME'_screen이어야 합니다\n- 확장자는 dart여야 합니다\n- 메인 파일 (screen.dart)에 대한 다음 코드 사용\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart '${NAME}_controller.dart';\n\nclass ${class}Screen extends StatefulWidget {\n  const ${class}Screen({Key? key}) : super(key: key);\n\n  @override\n  createState() =\u003e _${class}Screen();\n}\n\nclass _${class}Screen extends ${class}Controller {\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n```\n\n7. 메인 파일 아래에 다음 코드와 함께 자식 템플릿 파일을 만듭니다.\n\n```md\n#set($class = ${NAME})\n#set($class_start = $class.substring(0,1).toUpperCase())\n#set($class_rest = $class.substring(1).toLowerCase())\n#set($class = $class_start + $class_rest)\n\npart of '${NAME}_screen.dart';\n\nabstract class ${class}Controller extends State\u003c${class}Screen\u003e {\n\n  @override\n  void initState() {\n    // TODO: initState 구현\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    // TODO: dispose 구현\n    super.dispose();\n  }\n}\n```\n\n8. 자식 템플릿 파일을 '$'NAME'_controller.dart'로 명명하고 확장자는 이전과 동일한 dart로 설정합니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_8.png)\n\n9. 적용 및 확인을 눌러 완료합니다\n\n이후에는 폴더로 이동하여 새로운 테스트 폴더(screens-test)를 생성한 다음 해당 폴더에서 마우스 오른쪽 버튼을 클릭하여 — 새로 만들기 — View State — 이름을 지정하세요.\n그러면 name_screen 및 name_controller 두 파일이 생성됩니다.\n\n제가 앞서 말했듯이, 이것은 제 팀이 코드를 구성하는 방식일 뿐이며 다양한 방법이 있지만, 2019년 첫 번째 Flutter 프로젝트의 엉망으로부터 잘 구성되고 유지 관리가 빠른 방식으로 나아가게 도와준 것을 잠시 공유하고 싶었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 메서드를 좋아하신다면, 귀하의 프로젝트에 통합하고 플러터 개발자 동료들과 공유하며 박수 치는 것을 잊지 마세요.","ogImage":{"url":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png"},"coverImage":"/assets/img/2024-05-20-ASimplewaytoorganizeyourcodeinFlutter_0.png","tag":["Tech"],"readingTime":6},{"title":"플러터에서 최고의 Bloc 상태 관리 파트 2","description":"","date":"2024-05-20 23:15","slug":"2024-05-20-BestBlocstatehandlinginFlutterpart2","content":"\n\n안녕하세요, 친구들,\n첫 번째 파트에 대한 좋은 피드백에 기쁩니다.\n이번 파트에서는 디자인에서 EventStatus를 사용하는 방법을 가르치고 디자인의 모든 상태를 다루는 것을 알려드리고 싶어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:580/1*wL6d8JPLeO4MbkwBPLHwcA.gif)\n\n지난 파트에서는 Bloc_state에서 상태를 다루기위해 EventStatus 클래스를 사용했었습니다.\n\nhttps://medium.com/@moeinmoradi.dev/best-bloc-state-handling-in-flutter-0f95a8e89e40\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 친구 한 명의 제안에 따라, EventStatus 클래스에 대해 좀 더 나은 컨셉을 제안하고 그 이름을 StateStatus로 변경해보겠습니다. 다음과 같이 변경해주세요.\n\n```js\n@immutable\nabstract class StateStatus\u003cT\u003e {\n  final int? itemId;\n  final T? data;\n  final ErrorModel? message;\n\n  const StateStatus({\n    this.itemId,\n    this.data,\n    this.message,\n  });\n}\n\nclass StateLoading\u003cT\u003e extends StateStatus\u003cT\u003e {\n  const StateLoading({super.itemId});\n}\n\nclass StateCompleted\u003cT\u003e extends StateStatus\u003cT\u003e {\n  const StateCompleted({required super.data});\n}\n\nclass StateInitial\u003cT\u003e extends StateStatus\u003cT\u003e {}\n\nclass StateError\u003cT\u003e extends StateStatus\u003cT\u003e {\n  const StateError({required super.message});\n}\n```\n\n좋아요, StateStatusLayout를 위한 클래스를 만들어봅시다.\n\n# StateStatusLayout\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStateStatus에 따라 다른 디자인 상태를 표시하는 클래스가 필요합니다. 이 클래스는 각 상태와 해당 위젯을 표시할 수 있어야 합니다.\n\n이 클래스에서 BlocBuilder로부터 StateStatus를 받고 States에 따라 위젯을 반환했습니다 :\n\n```js\nclass StateStatusLayout\u003cT\u003e extends StatelessWidget {\n  final StateStatus\u003cT\u003e status;\n  final Widget onErrorStatus;\n  final void Function(ErrorModel error)? onErrorListener;\n  final Widget Function(BuildContext context, T? data) onCompletedStatus;\n  final Widget onInitialStatus;\n  final Widget onLoadingStatus;\n  const StateStatusLayout({\n    super.key,\n    required this.status,\n    required this.onCompletedStatus,\n    required this.onErrorStatus,\n    required this.onInitialStatus,\n    required this.onLoadingStatus,\n    this.onErrorListener,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    if (status is StateError) {\n      if (onErrorListener != null) {\n        onErrorListener!(status.message!);\n      }\n    }\n    if (status is StateCompleted) {\n      return StreamBuilder(\n        stream: Stream.value(status),\n        builder: (context, snapshot) {\n          log(status.data!.toString());\n          return onCompletedStatus(context, status.data);\n        },\n      );\n    }\n    if (status is StateError) {\n      return onErrorStatus;\n    }\n    if (status is StateInitial) {\n      return onInitialStatus;\n    }\n    if (status is StateLoading) {\n      return onLoadingStatus;\n    }\n    return Container();\n  }\n}\n```\n\n그런데, StateCompleted 조건을 살펴보세요. 데이터를 표시하기 위해 StreamBuilder를 사용했습니다. 이것에 대해 어떻게 생각하시나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:700/1*I6k_gZJ0KRZYR4KU22Okig.gif)\n\n가끔 블록 쪽에서 데이터를 페이지네이션하거나 스트리밍해야 할 때, 위젯은 반드시 모든 상황에서 업데이트되어야 합니다. 그리고 위젯에서 오류가 발생하지 않도록하기 위해 이러한 가능한 상황을 고려하기 위해 StreamBuilder를 사용합니다.\n\n간단한 샘플 코드를 보여드리겠습니다. StateStatusLayout을 사용한 코드입니다:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass ShowLayout extends StatelessWidget {\n  const ShowLayout({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder\u003cShowBloc, ShowState\u003e(\n        builder: (context, state) {\n          return StateStatusLayout(\n            status: state.showsStatus,\n            onCompletedStatus: (context, data) {\n              return GridView.count(\n                shrinkWrap: true,\n                padding: const EdgeInsets.all(10),\n                physics: const ClampingScrollPhysics(),\n                crossAxisSpacing: 10,\n                mainAxisSpacing: 20,\n                crossAxisCount: 4,\n                childAspectRatio: 9 / 16,\n                children: List.generate(data!.shows!.length, (index) {\n                  ShowModel item = data.shows![index];\n                  return ShowCard(\n                      show: item,\n                      onSelected: () {\n                        /// do Somethigs...\n                      },\n                    );\n                }),\n              );\n            },\n            onErrorStatus: const SizedBox(),\n            onInitialStatus: const SizedBox(),\n            onLoadingStatus: Padding(\n              padding: const EdgeInsets.all(48.0),\n              child: SizedBox(\n                width: 50,\n                height: 50,\n                child: SpinKitRipple(\n                  color: themeData.colorScheme.secondary,\n                  size: 40,\n                ),\n              ),\n            ),\n          );\n        },\n      );\n  }\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 샘플 코드에서는 Bloc이 emit() 함수로 갱신될 때 showsStatus 상태에 대한 onCompletedStatus 및 onLoadingStatus를 처리했습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*XwwugAFY35KNciVoDHThEw.gif)\n\n## 지금까지 함께 해주셔서 감사합니다\n나와 함께 계속 이야기를 공유해주시고 피드백을 기다리고 있습니다. 분들의 소중한 의견을 기다리고 있습니다. 🙏","ogImage":{"url":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png"},"coverImage":"/assets/img/2024-05-20-BestBlocstatehandlinginFlutterpart2_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 3.22에 새로 추가된 내용 정리","description":"","date":"2024-05-20 23:13","slug":"2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings","content":"\n\n## 플러터 3.22 릴리스는 웹 어셈블리, 불칸 그래픽, 위젯 상태 향상 등을 포함하고 있습니다\n\n![이미지](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png)\n\n이 글에서는 플러터 3.22의 새로운 기능을 알아보겠습니다. 플러터 3.22에서는 성능 향상을 위해 웹 어셈블리 지원과 안드로이드에서 더 부드러운 그래픽을 위한 불칸 백엔드가 소개되었습니다. 위젯 상태 관리가 **위젯 상태 속성**과 함께 강화되었으며, **동적 뷰 크기 조정**으로 UI 적응성이 향상되었습니다. 또한 **개선된 폼 유효성 검증**을 통해 사용자 입력 처리를 강화했습니다.\n\n**플레이버 조건부 자산 번들링**을 통해 앱 플레이버를 기반으로 선택적 자산 번들링이 가능하게 되었으며, **Gradle Kotlin DSL 지원**은 코드 편집을 개선했습니다. iOS에서 플랫폼 뷰 성능이 **스크롤링에 특히 더 나아졌습니다.** Firebase Dart SDK 미리보기를 통해 **Vertex AI**를 활용한 AI 기능을 구현할 수 있으며, **Google Mobile Ads SDK 5.0.1**은 **UMP SDK** 및 더 많은 중재 파트너에 대한 향상된 지원을 제공합니다. 이러한 업데이트는 플러터에서 앱 성능, 사용자 경험 및 개발자 생산성을 향상시키기 위해 종합적으로 목표로 하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, 플러터 3.22 릴리스에서의 탑 10 업데이트를 소개할게요:\n\n1. WebAssembly 지원\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*JPFkftr0XrFTo1zLm8U3WQ.gif)\n\n플러터 3.22의 WebAssembly (Wasm) 지원은 웹 앱 개발에 큰 도약이에요. Wasm은 코드를 브라우저가 효율적으로 실행할 수 있는 바이너리 형식으로 컴파일함으로써, 플러터 웹 앱이 거의 네이티브 속도로 실행되도록 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전통적인 웹 기술과 비교했을 때, 이는 혁신적인 성능 향상을 가져옵니다. 게다가, Wasm은 주요 웹 브라우저에서 널리 지원되어 Flutter 웹 앱에 대한 광범위한 호환성을 보장합니다. Wasm을 활용함으로써 Flutter는 코드 크기를 줄이고 빠른 로드 시간 및 향상된 전반적인 성능을 제공합니다. 게다가, Wasm은 빠르게 발전하는 기술로, 앞으로 더 많은 향상이 기대됩니다.\n\n전반적으로, Flutter 3.22에서의 Wasm 지원은 웹 개발을 위한 플랫폼 기능을 향상시켜 개발자에게 고성능 웹 애플리케이션을 구축하는 강력하고 효율적인 도구를 제공합니다.\n\n2. Impeller를 위한 Vulkan Backend\n\nFlutter 3.22에서 Impeller의 Vulkan 백엔드는 안드로이드에서 Flutter 앱에서 사용되는 렌더링 엔진에 대한 중요한 향상입니다. Vulkan은 현대적인 GPU에 대한 고효율적이고 크로스 플랫폼 액세스를 제공하는 저부하, 크로스 플랫폼 3D 그래픽 및 컴퓨팅 API입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n임펠러에 Vulkan을 통합함으로써, 플러터는 Vulkan의 능력을 활용하여 그래픽을 더 효율적으로 렌더링할 수 있어 안드로이드 기기에서 플러터 앱의 그래픽이 더 부드럽고 성능이 향상될 수 있습니다. 이 향상은 특히 애니메이션과 풍부한 전환 효과를 갖는 앱에 유용하며, 부드러운 프레임 속도를 유지하고 전반적인 사용자 경험을 향상시킵니다.\n\n### 위젯 상태 속성\n\n플러터 3.22의 위젯 상태 속성은 위젯이 외관과 동작을 어떻게 추적하는지에 관한 것입니다. 플러터는 이를 관리하는 특별한 방법인 \"매터리얼 상태(MaterialState)\"라는 것을 갖고 있습니다. 이번 업데이트에서 매터리얼 상태는 \"위젯 상태(WidgetState)\"로 이름이 변경되었으며 플러터의 더 많은 부분에서 사용할 수 있습니다.\n\n이 변경으로 개발자는 위젯이 어떻게 보이고 작동하는지를 더 쉽게 제어할 수 있게 되었으며, 이는 잘 작동하고 멋지게 보이는 플러터 앱을 만드는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 동적 뷰 크기 조정\n\nFlutter 3.22에서의 동적 뷰 크기 조정은 반응형 레이아웃을 처리하는 프레임워크의 기능을 향상시키는 기능입니다. 이 기능은 위젯이 사용 가능한 화면 공간에 기반하여 크기를 조절하도록 개선합니다. 이는 작은 스마트폰부터 큰 태블릿까지 다양한 기기에 걸쳐 일관적이고 매력적인 사용자 인터페이스를 만들 때 특히 유용합니다.\n\n이 업데이트 이전에, 개발자들은 종종 다양한 화면 크기에서 올바르게 표시되도록 위젯의 크기를 수동으로 계산하고 설정해야했습니다. 동적 뷰 크기 조정을 통해, 개발자들은 `Expanded`, `Flexible`, `MediaQuery`와 같은 기능을 사용하여 레이아웃을 생성할 수 있습니다. 이를 통해 위젯 크기를 화면의 차원에 따라 동적으로 조정할 수 있습니다.\n\n예를 들어, `Expanded` 또는 `Flexible` 컨테이너로 래핑된 위젯은 자동으로 확장 또는 축소하여 사용 가능한 공간을 채울 수 있어 반응형 디자인을 쉽게 만들 수 있습니다. 마찬가지로, `MediaQuery` 클래스를 사용하면 현재 화면 크기를 조회하고 위젯 크기를 조정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동적 뷰 크기 조정은 반응형 플러터 레이아웃을 만드는 프로세스를 간단화해줍니다. 이는 다양한 기기와 화면 크기에서 일관된 사용자 경험을 제공하는 앱을 결과적으로 만들어냅니다.\n\n5. 폼 유효성 검사 개선\n\nFlutter 3.22에서 개선된 폼 유효성 검사는 사용자 입력을 다루는 더 유연하고 견고한 방법을 제공합니다. 이러한 향상된 기능은 개발자들이 사용자 입력을 어떻게 유효성을 검사할지 더 많은 제어력을 제공하며, 특정 애플리케이션 요구에 맞게 사용자 정의 유효성 검사 로직을 구현할 수 있게 해줍니다.\n\n이 개선된 유효성 검사 능력은 더 사용자 친화적인 경험으로 이어지며, 잘못된 데이터를 입력할 때 앱이 사용자에게 보다 정확한 피드백을 제공할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 이러한 향상된 기능은 인젝션 공격과 같은 보안 취약점을 예방하여 증가된 보안을 제공합니다. 총괄적으로 말하면, Flutter 3.22에서 개선된 양식 유효성 검사는 Flutter 앱의 사용성, 보안 및 유연성을 강화하며, 더 견고하고 사용자 친화적인 애플리케이션을 개발하는 데 강력한 도구를 제공합니다.\n\n6. 플레이버 조건부 자산 번들링\n\nFlutter 3.22의 플레이버 조건부 자산 번들링은 개발자들이 앱의 여러 버전 또는 \"플레이버\" 간에 효과적으로 자산을 관리할 수 있는 기능입니다. 이 기능을 통해 개발자는 앱의 플레이버에 기초하여 어떤 자산(예: 이미지, 폰트, 또는 설정 파일)을 앱 번들에 포함해야 하는지 지정할 수 있습니다.\n\n이는 특정 버전의 앱에 특정한 자산(예: 브랜드 자산 또는 설정 파일)을 포함시킬 수 있으면서 다른 버전의 앱에 영향을 미치지 않게 됨을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자산을 이렇게 정리함으로써, 개발자들은 더 깔끔하고 조직화된 코드베이스를 유지할 수 있어 필요할 때 자산을 관리하고 업데이트하기가 더 쉬워집니다. 또한 각 버전에 필요한 자산만 포함함으로써, 앱 번들의 전체 크기를 줄일 수 있어 사용자들에게 빠른 다운로드 및 시작 시간을 제공할 수 있습니다.\n\n전반적으로, Flavor-Conditional Asset Bundling은 개발 프로세스를 향상시키고 Flutter 앱의 성능을 향상시키는 가치 있는 기능입니다.\n\n7. Gradle Kotlin DSL 지원\n\nFlutter 3.22에서의 Gradle Kotlin DSL 지원은 개발자들이 Gradle 빌드 스크립트를 작성할 때 Groovy 대신 Kotlin을 사용할 수 있게 해주는 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin은 Groovy보다 여러 가지 이점을 제공하는 현대적이고 표현력 있는 프로그래밍 언어입니다. 이점으로는 더 나은 타입 안전성, 널 안전성, 그리고 향상된 도구 지원이 있습니다. Gradle Kotlin DSL 지원을 통해, 개발자들은 Flutter 프로젝트용 빌드 스크립트를 작성할 때 이러한 이점을 활용할 수 있습니다.\n\n이는 더 읽기 쉽고 유지보수하기 쉽며 견고한 빌드 스크립트로 이어져, 결국 Flutter 개발자들의 전체 개발 경험을 향상시킬 수 있습니다.\n\n8. 플랫폼 뷰 성능 개선 (iOS)\n\nFlutter 3.22에서의 플랫폼 뷰 성능 개선은 iOS 앱 내에서 플랫폼 뷰의 성능을 향상시키는 데 초점을 맞춥니다. 플랫폼 뷰는 지도나 웹 뷰와 같은 네이티브 구성 요소를 Flutter 앱에 통합하는 데 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 업데이트는 주로 여러 플랫폼 뷰가 자주 사용되는 스크롤 뷰 내의 성능을 대상으로 합니다. 개선 사항에는 GPU 사용량이 50% 감소하여 배터리 효율성이 향상되고 사용자 상호 작용이 더 부드러워질 수 있는 잠재적인 이점이 포함되어 있습니다.\n\n게다가, 평균 프레임 렌더 시간이 1.66ms만큼 줄어든 것으로 (33%의 향상), 최악의 경우 렌더 시간은 3.8ms만큼 감소하여 (21%의 향상) 스무스한 애니메이션과 스크롤 중에 버벅임이 줄어들어 더 나은 경험을 제공하게 되었습니다.\n\n이러한 최적화는 iOS 기기에서 플랫폼 뷰를 활용하는 Flutter 앱의 성능을 현저히 향상시키도록 설계되었으며, 사용자에게 더 부드럽고 반응성 있는 경험을 제공합니다.\n\n9. Firebase Dart SDK 미리보기용 Vertex AI\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_1.png)\n\n플러터 3.22에 대한 Vertex AI for Firebase Dart SDK 미리보기는 제니미 API를 소개합니다. 이를 통해 개발자들은 자체 Dart 또는 Flutter 앱에 생성 AI 기능을 통합할 수 있습니다.\n\n이 SDK는 생산 수준의 성능과 확장성을 제공하며 Firebase App Check와의 통합으로 보안을 강화합니다. 개발자들은 이 SDK를 사용하여 이미지 및 텍스트 생성과 같은 제니미 API의 기능을 앱에서 사용할 수 있습니다.\n\n이 미리보기 릴리스는 프로모션 코드로 무료로 제공되며, 개발자들은 앱에 통합하기 전에 SDK의 기능을 탐색하고 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10. Google Mobile Ads SDK 5.0.1\n\n플러터 3.22의 Google Mobile Ads SDK 5.0.1은 광고로 Flutter 앱을 수익화하는 개발자들을 위한 여러 개선 사항을 가져왔어요.\n\n이 업데이트에는 사용자 메시징 플랫폼 (UMP) SDK에 대한 향상된 지원이 포함되어 있어요. 개인화된 광고에 대한 동의 수집 프로세스를 간소화하기 위한 새로운 API가 제공돼요. 게다가 이제 SDK는 Unity, Meta, AppLovin, Iron Source, Mintegral, Pangle, DT Exchange, InMobi, Liftoff를 포함한 확장된 중개 파트너를 지원해요.\n\n이러한 통합은 개발자들에게 더 많은 기회를 제공하여 앱 수익을 극대화하는 광고 수익화 옵션을 확대시켜 줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, Flutter 3.22는 앱 개발자들을 위한 몇 가지 큰 개선 사항을 가져왔습니다. 그들은 그래픽 및 애니메이션에 특히 빠르고 부드러운 사용을 가능하게 만들었습니다. 또한 이미지 및 폰트와 같은 앱 자산을 구성하고 관리하는 새로운 방법을 추가하여 앱을 구축하고 유지하는 것을 더 쉽게 만들었습니다. 게다가 Android 및 iOS용으로 더 나은 딥 링크 지원 및 부드러운 스크롤링을 위한 멋진 새로운 기능이 추가되었습니다.\n\n전반적으로, Flutter 3.22는 훌륭한 앱을 만드는 것을 더 쉽고 재미있게 만들어줍니다. 또한 이 정보는 다양한 웹사이트를 조사하여 수집했습니다. 잘못된 정보나 오해된 정보가 있는 경우 아래 댓글로 알려주시면 감사하겠습니다.\n\n내용 중 오류가 있었다면 댓글에 언급해주세요. 개선하고 싶어합니다. 여러분의 지원은 저에게 매우 큰 의미를 갖습니다! 만족스러우셨다면 구독 고려해 주시면 감사하겠습니다.\n\n저는 Sherish Shukla입니다, 창의적인 개발자이자 기술 애호가입니다. LinkedIn에서 저를 찾을 수도 있고 Twitter에서도 팔로우할 수 있으며 자세한 내용을 보려면 포트폴리오로 가보세요. 물론 GitHub에서도 팔로우해 주시면 감사하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋은 하루 되세요!🙂","ogImage":{"url":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png"},"coverImage":"/assets/img/2024-05-20-WhatsnewinFlutter322letsdiscussthetop10newthings_0.png","tag":["Tech"],"readingTime":7},{"title":"Google IO, Flutter가 발표한 최신 내용들 정리","description":"","date":"2024-05-20 23:12","slug":"2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements","content":"\n\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png)\n\n위의 스냅샷이 모두의 본질을 잡아냈음에 기쁩니다. 올해 개인적으로 Google I/O에 참석할 수 있었던 것은 정말 특권이었고, 이 기사는 행사 중에 메모한 내용을 반영하고 있습니다.\n\nGoogle I/O에 처음 참석한 나로서는, 개발자에게는 놀라운 경험이었으며 온라인에서만 알고 있던 사람들을 직접 만날 기회가 생기는 것은 더욱 소중한 경험입니다. \"Flutter로 적응형 UI를 구축하는 방법\"에 대한 Reid와 Tyler의 강연 후의 스냅샷은 행사 전반에 걸쳐 나의 흥분을 완벽하게 담아 냈습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알았어요. 그럼, 구글 I/O 2024 및 그 이후의 Flutter에서 무엇이 새로운지에 대해 이야기해 봅시다. 케빈과 존이 진행한 'What's new in Flutter' 동안 주요 개선 사항이 다음과 같은 주제로 요약되었습니다.\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_2.png)\n\n## 주요 진전:\n\n- Google AI Dart SDK: 이 Flutter 프레임워크의 새로운 추가 사항은 또한 존과 케빈의 발표에서 강조되었습니다. 현재 Flutter 3.19가 라이브 중이며, 이로써 구글의 최신 생성적 AI(젬니) 기능이 Flutter 앱으로 제공되어 많은 창의적인 가능성과 쉬운 통합이 가능해졌습니다. 이제 개발자는 간단히 다음과 같이 시작할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_3.png\" /\u003e\n\n- 캐주얼 게임 도구 키트: Flutter를 사용한 게임 개발 가속화를 위한 리소스로 발표되었습니다.\nhttps://docs.flutter.dev/resources/games-toolkit\n- 임펠러: Google I/O 2024에서 특정 발표는 없었지만, Vulkan 백엔드가 강조되어 Flutter 앱의 그래픽 렌더링에서 현저한 개선을 제공한다는 것이 언급되었습니다. 즉시 성능을 향상시키려는 개발자들에게 좋은 대안이 될 수 있습니다. 임펠러로 전환하려면 단순히 다음을 실행하십시오:\n\n\u003cimg src=\"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_4.png\" /\u003e\n\n- 안정적인 WebAssembly 지원: 이는 Flutter 웹 개발을 위한 게임 체인저입니다. WebAssembly (Wasm)로 컴파일함으로써 기존 JavaScript 백엔드 대비 크게 빠른 렌더링 속도(2-3배)를 달성할 수 있습니다. 이는 Flutter를 사용한 고성능 웹 앱 개발을 위한 길을 열어줍니다.\n- Dart 3.4 통합: 이번 업데이트로 Flutter 개발자들을 위한 흥미로운 새로운 기능이 도입되었습니다. Experimental macros: Flutter 개발의 미래를 엿볼 수 있는 기능으로, macros는 편집기 내부에 내장된 기능으로 코드 생성을 가능하게 합니다. 이는 뼈대 코드를 크게 줄이고 유지보수성을 개선하며 반복되는 작업을 자동화할 수 있습니다. 초기 예시로, 새로운 내장 매크로가 JSON 데이터 직렬화 및 역직렬화를 간단하게 만들어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 주제와 관련된 보다 구체적인 정보를 찾으려면 다음 링크를 방문해보세요:\n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_5.png)\n\n## 추가 개선 사항:\n\n- 향상된 웹 앱 성능: 웹어셈블리(WebAssembly) 이상, Flutter 3.22는 웹 앱을 위한 다른 최적화도 제공하여 사용자 경험을 더욱 원활하게 만듭니다.\n- 최신 업데이트를 통해 Flutter 앱은 안드로이드 예측 제스처와 완벽하게 통합되어 사용자가 백 스와이프를 시작하는 동안 이전 화면(홈 화면이나 다른 앱)을 간략히 볼 수 있습니다.\n- Flutter 앱에서 iOS 플랫폼 뷰가 속도 향상을 겪었습니다! CPU 사용량이 최대 50% 감소되어 더 원활한 사용자 경험을 제공합니다.\n- 부드러운 그래픽을 위한 Vulkan 백엔드: 이 업데이트로 안드로이드에서 Flutter 앱의 그래픽 렌더링이 현저히 향상되었습니다.\n- 더 나은 위젯 상태 관리: Flutter 3.22는 위젯이 상태를 처리하는 방법에 대한 향상을 제공하여 유지 및 효율적인 코드를 이끌어냅니다.\n- 폼 유효성 검사, 자산 번들링 및 Gradle 스크립트 편집: Flutter 3.22의 추가 기능 중 일부로 개발 워크플로우를 간소화하고 앱 품질을 향상시킵니다.\n- CameraX를 사용한 Flutter에서 일관되고 신뢰할 수 있는 카메라 경험 구축: (Building Consistent and Reliable Camera Experiences in Flutter with CameraX 비디오를 기반으로 함) Android에서의 Flutter 카메라 플러그인의 새로운 구현은 CameraX를 사용하여 구축되었습니다. CameraX는 카메라 개발을 더 쉽게 만들고 카메라 동작을 기기 간 일관되게 유지하는 목적으로 만들어진 Jetpack 라이브러리입니다. CameraX에는 자동 선택 및 기기별 문제 수정이라는 두 가지 주요 혜택이 있습니다. 자동 선택은 해상도나 종횡비를 명시하지 않거나 지정된 값이 사용 불가능한 경우 최상의 해상도나 종횡비를 결정하여 개발자를 돕습니다. CameraX는 또한 기기별 카메라 버그를 수정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 향상된 개발자 경험:\n\n- Material 3로 새롭게 업그레이드된 DevTools: 친숙한 DevTools 인터페이스가 현대적인 Material 3 디자인 언어로 새롭게 탄생하여 미적으로 매력적이고 접근성이 좋은 경험을 제공합니다.\n- 강력한 DevTools 기능 개선: DevTools는 고급 필터링과 타임라인에서 CPU 샘플 지원으로 더욱 강력해졌습니다. 이를 통해 Flutter 앱의 프로파일링과 최적화를 더욱 정밀하게 할 수 있습니다.\n- 딥 링크 디버깅 단순화: Flutter 앱과 웹 경험 사이의 딥 링크 문제 해결이 더욱 쉬워졌습니다. 새로운 딥링크 유효성 검사 도구를 통해 구성 오류를 신속하게 식별하고 수정할 수 있습니다.\n\n## 실제 적용사례:\n\n- Universal Studios Destinations \u0026 Experiences, LG, Brickit 등 주요 기업들이 Flutter를 점점 더 많이 도입하며 프레임워크의 성숙성과 기능을 전시하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 업데이트는 Flutter에 대한 중대한 발전을 의미하며, 아름답고 고성능이며 크로스 플랫폼 애플리케이션을 더욱 쉽게 구축할 수 있는 선택지로 만들어줍니다. 구글 I/O에서 발표된 사진은 Flutter가 전 세계에서 가장 인기 있는 크로스 플랫폼 프레임워크로 부상하는 모습을 보여줍니다.\n\n![Flutter Soars at Google I/O](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_6.png)\n\n## 게다가, 다음 자료들로 특정 측면에 대해 자세히 알아볼 수 있습니다:\n\n- John Ryan과 Kevin Moore에 의한 Flutter 최신 소식 토크\n- Reid Baker와 Tyler Holland에 의한 Flutter로 적응형 UI 구축하기 방법\n- Hangyu Jin과 Zoey Fan에 의한 Flutter에서 딥링킹 성공: 더 이상 깨진 링크가 없음\n- Camille Simon에 의한 Flutter에서 CameraX로 완벽한 카메라 경험 구축하기\n- Michael Thomsen의 최신 Flutter 3.22 및 Dart 3.4에 관한 기사\n- Vertex AI for Firebase SDK를 사용하여 Gemini API 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다.\n\n기사를 즐겼으면 좋겠고, 앞으로 더 많은 게시물을 기대해 주세요. 건배!!! \n\n![이미지](/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_7.png)","ogImage":{"url":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png"},"coverImage":"/assets/img/2024-05-20-FlutterSoarsatGoogleIOShorelineADeveloperstakefromtheLatestAnnouncements_0.png","tag":["Tech"],"readingTime":5},{"title":"웹사이트 만들 때 HTML-우선 백엔드 개발을 해야하는 이유","description":"","date":"2024-05-20 23:10","slug":"2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps","content":"\n\n\n![image](/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png)\n\n웹 개발에서 간단함과 효과적인 기능 사이의 균형을 찾는 것이 중요합니다.\n\n개발자로서, 우리는 프로세스를 최적화하고 우수한 결과를 제공하는 방법을 계속해서 찾고 있습니다.\n\nHTML을 우선으로 한 백엔드 개발은 웹 애플리케이션 분야에서 그 가치를 입증해온 실증된 접근 방식으로 부상했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# HTML-First로 간단하게 유지하는 것이 왜 중요한가요\n\n기본 웹 애플리케이션을 구축해야 한다고 상상해보세요. 간단한 필터 옵션으로 데이터를 표시하는 테이블과 같은 웹 애플리케이션입니다.\n\n일반적으로 개발자들은 React 또는 Vue와 같은 복잡한 프론트엔드 프레임워크를 사용하여 이러한 작업을 수행할 수 있습니다.\n\n하지만, 이러한 프레임워크는 사용자 입력 이벤트를 듣는다거나 일반적으로 JSON 형식의 데이터를 가져와서 이 데이터를 동적으로 HTML로 렌더링하는 등 복잡한 단계들이 많이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 잠시 멈추어서 스스로에게 물어보세요. 사용자에게 구조화된 HTML을 제시하는 것이 최종 목표인데, 왜 이 복잡한 JSON 중간 매개체를 통해 탐색해야 하는 걸까요?\n\nHTML 중심 접근 방식을 채택함으로써, 우리는 불필요한 복잡성을 우회하고 더 직접적인 경로를 택하게 됩니다.\n\n라라벨, 장고, 루비 온 레일스와 같이 널리 사용되는 백엔드 프레임워크들은 템플릿을 사용하여 구조화된 HTML을 생성하는 강력한 기능을 제공합니다. 이것은 개발 프로세스를 간단하게 만들뿐만 아니라 성능을 향상시킴으로써 큰 장점을 제공합니다.\n\n# 팬시한 프론트엔드 프레임워크 없이 간소화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 내에서 드롭다운 필터를 구현한다고 상상해보세요.\n\n프론트엔드 프레임워크의 복잡성에 의존하는 대신에 기본 HTML 폼 입력과 전통적인 폼 제출 메커니즘을 활용할 수 있습니다.\n\n아래는 작동 방식입니다:\n\n- 백엔드가 필요한 모든 데이터를 포함한 초기 뷰로 작동합니다.\n- 사용자가 필터와 상호 작용하면 폼이 데이터를 백엔드로 제출하고, 그러면 백엔드가 필터링된 데이터셋으로 페이지를 다시로드합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 전체 페이지 다시로드를 필요로 할 수 있지만, 상당한 이점을 제공합니다.\n\n특히, 현재 상태(적용된 필터와 같은)를 URL에 직접 인코딩함으로써, 응용 프로그램의 특정 뷰를 공유하고 재현하는 것을 간단하게 만든다는 점이 두드러집니다.\n\n또한 별도의 API 계층이 필요하지 않아 응용 프로그램 아키텍처를 간소화하고 전반적인 복잡성을 줄이는 효과가 있습니다.\n\n# 최신 JavaScript로 사용자 경험을 더 나은 방향으로 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 사용자 경험 문제를 다루어보겠습니다. 특히 전체 페이지 새로 고침 상황에서 말이죠. 전통적인 HTML 중심 접근 방식은 단숨함과 신뢰성을 제공하지만, 쾌적한 사용자 경험을 제공하는 데는 부족할 수 있습니다.\n\n이를 해소하기 위해 현대적인 JavaScript 기술을 도입하여 단순함을 희생하지 않고 상호 작용성을 향상시킬 수 있습니다:\n\n- JavaScript를 사용하여 양식 제출을 가로채서 기본 동작을 방지합니다.\n- 백엔드로부터 업데이트된 데이터를 비동기적으로 요청하기 위해 fetch API를 활용합니다.\n- 새로 가져온 데이터로 테이블과 같은 페이지의 해당 부분만 동적으로 교체합니다.\n\n이 방식은 현대적인 프론트엔드 관행을 통합하면서 HTML 중심 개발의 핵심 원칙을 보존합니다. URL을 동적으로 업데이트함으로써 응용 프로그램이 단순함을 희생하지 않고 사용자 친화적이고 효율적으로 유지되도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# HTMX를 사용하여 멋진 상호 작용\n\nHTML-중심 애플리케이션에서 더 많은 유연성과 동적 성을 찾는 개발자들을 위해, HTMX와 같은 도구는 매력적인 해결책을 제공합니다.\n\nHTMX를 사용하면 특별 속성을 HTML에 추가하여 동적 콘텐츠 업데이트를 용이하게 할 수 있습니다.\n\n다음 기능을 고려해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터를 가져오기 위해 GET 요청을 트리거하는 hx-get 활용하기.\n- 가져온 콘텐츠가 삽입될 위치를 정의하는 hx-target 사용하여 대상 요소 지정하기.\n- 상호 작용성을 향상시키기 위해 특정 이벤트에 따라 업데이트를 트리거하는 hx-trigger 활용하기.\n\nHTMX를 HTML을 우선으로 한 개발 워크플로에 통합함으로써, 개발자는 동적 상호 작용성의 힘을 활용하면서 백엔드에서 렌더링된 HTML의 간결함과 효율성을 유지할 수 있습니다.\n\n**실무에 적용하기: 다단계 폼**\n\nHTML을 우선으로 한 개발의 실용적인 적용을 설명하기 위해 다단계 폼을 구축하는 시나리오를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTMX의 도움을 받아 개발자들은 전체 페이지 새로 고침 없이 동적인 양식 제출 및 유효성 처리를 구현할 수 있습니다:\n\n- 각 양식 단계는 백엔드에서 별도의 HTML 엔드포인트로 제공됩니다.\n- 양식 제출은 후속 단계 로딩이나 동적 유효성 오류 표시를 트리거하며, 전체 페이지 새로 고침이 필요하지 않습니다.\n\n이 접근 방식은 HTML 중심 개발이 복잡한 상호 작용을 수용하면서도 간결함과 효율성을 유지하는 우아함을 보여줍니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 프레임워크는 의심의 여지없이 고급 기능과 기능을 제공하지만, 모든 웹 애플리케이션에 항상 최적의 선택은 아닙니다.\n\n많은 프로젝트가 HTML 기반 백엔드 접근 방식의 간결함과 효율성을 크게 누릴 수 있습니다.\n\n최신 JavaScript 기술을 통합하고 HTMX와 같은 도구를 선택적으로 통합함으로써, 개발자는 사용자 경험에 중점을 두면서 강인하고 유지보수 가능한 웹 애플리케이션을 만들 수 있습니다.\n\nHTML 기반 방식은 간결성, 효율성 및 효과적인 요소의 매력적인 혼합물을 제공하는 단단한 선택이 계속되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 스타일을 위해 AI 도움을 받아 작성되었고, 내용은 정보를 제공하기 위한 것으로 제시된 아이디어에 대해 비판적으로 참여할 것을 촉구합니다.\n\n이 글이 마음에 들었다면 👏 로 박수를 보내고 팔로우해 주세요! 가장 좋아하는 부분을 강조해도 좋습니다. 당신의 참여가 저를 영감을 주어요!","ogImage":{"url":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png"},"coverImage":"/assets/img/2024-05-20-WhyHTML-FirstBackendDevelopmentisStillaSmartChoiceforWebApps_0.png","tag":["Tech"],"readingTime":4},{"title":"SwiftUI에서 WKWebView와 네이티브 애플리케이션 간 메시지 전달하기","description":"","date":"2024-05-20 23:05","slug":"2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI","content":"\n\n이 문서는 WKWebView와 네이티브 측 간의 프로세스간 통신을 탐구합니다. 이는 로컬/임베디드 웹 페이지에 집중할 것입니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png)\n\n# WKWebView의 탄생\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플은 2003년 맥용 Safari 웹 브라우저의 첫 번째 버전을 출시할 때, 네이티브 애플리케이션에서 웹 콘텐츠를 표시하기 위한 최초 세대의 프로그래밍 인터페이스인 WebView 클래스를 개발했습니다.\n\n2007년, 스티브 잡스가 최초의 iPhone을 발표했습니다. 이후 해에는 iPhone 3G가 출시되었으며 WebKit 프레임워크도 함께 출시되었습니다. 이 프레임워크에는 iOS용 또 다른 프로그래밍 인터페이스인 UIWebView 클래스가 포함되어 있습니다.\n\n애플은 2010년에 WebKit의 두 번째 세대에 대한 작업을 시작했습니다. 4년 후, WebView (macOS) 및 UIWebView (iOS) 클래스를 대체하기 위해 WKWebView가 출시되었습니다. 두 클래스는 2018년에 폐기되었습니다.\n\n이것이 WKWebView의 간단한 역사입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# WKWebView이 뭔가요?\n\n답은 애플 문서에 있어요.\n\n중요한 점은 네이티브 애플리케이션이 동일한 뷰에서 HTML 및 SwiftUI/UIKit 구성 요소를 표시할 수 있다는 거예요.\n\n왜 HTML과 네이티브 구성 요소를 함께 사용해야 하죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 콘텐츠나 멋진 UI를 SwiftUI/UIKit로 서식 지정하는 것은 상당히 어려울 수 있습니다. HTML과 CSS는 검증된 기술입니다. 웹 개발자가 모바일 친화적 웹사이트를 제작할 수 있다면, 네이티브 애플리케이션용 UI를 쉽게 만들 수 있습니다!\n\n그로 인해 네이티브 애플리케이션 개발자들이 다른 작업을 처리할 수 있게 되죠...\n\n이 글에서는 좀 더 탐구해보겠습니다.\n\n웹 콘텐츠는 어디서 오는 걸까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히, 웹 브라우저는 웹 서버에서 웹 페이지를 로드합니다. WKWebView이 로컬 파일이나 심지어 HTML 스트링에서 웹 콘텐츠를 로드할 수 있다는 것을 알아내는 것은 흥미롭습니다.\n\n로컬 웹 콘텐츠!\n\n이것은 의미하는 바는 기기가 오프라인 상태일 때에도 네이티브 애플리케이션이 여전히 작동할 수 있다는 것입니다! 게다가, 네이티브 애플리케이션은 네트워크 지연을 피할 수도 있습니다.\n\nWKWebView에 대해 자세히 알아봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 뷰 생성하기\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    typealias UIViewType = WKWebView\n    \n    var vm: BaseWebViewVM\n\n    // 뷰 모델로 초기화\n    init(viewModel: BaseWebViewVM) {\n        self.vm = viewModel\n    }\n    \n    func makeUIView(context: Context) -\u003e WKWebView {\n        return vm.webView\n    }\n    \n    func updateUIView(_ uiView: WKWebView, context: Context) {\n    }\n    \n    func makeCoordinator() -\u003e Coordinator {\n        return Coordinator(viewModel: vm)\n    }\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject {\n        var viewModel: BaseWebViewVM \n        \n        init(viewModel: BaseWebViewVM) {\n            self.viewModel = viewModel\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    @Published var webResource: String?\n    var webView: WKWebView\n\n    init(webResource: String? = nil) {\n        self.webResource = webResource\n        \n        self.webView = WKWebView(frame: .zero,\n                                 configuration: WKWebViewConfiguration())\n    }\n\n    func loadWebPage() {\n        if let webResource = webResource {\n            guard let url = URL(string: webResource) else {\n                print(\"잘못된 URL\")\n                return\n            }\n\n            let request = URLRequest(url: url)\n            webView.load(request)\n        }\n    }\n}\n```\n\n이 코드만 있으면 WKWebView에서 웹 페이지를 보여줄 수 있어요.\n\n## SwiftUIWebView\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWKWebView은 UIView입니다. SwiftUIWebView는 UIViewRepresentable을 구현하는 구조체로 표현되어야 합니다.\n\nSwiftUIWebView는 BaseWebViewVM의 인스턴스로 초기화되어야 합니다.\n\nmakeUIView 메서드는 뷰 모델에서 WKWebView의 인스턴스를 반환합니다.\n\nmakeCoordinator 메서드는 Coordinator의 인스턴스를 반환합니다. Coordinator에는 WKWebView를 위한 델리게이트 함수들이 포함되어 있습니다. 현재로서는 특별한 작업을 수행하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## BaseWebViewVM\n\nBaseWebViewVM에는 공개된 속성 webResource가 있습니다. 이 속성은 클래스 생성자(init 메서드)를 통해 초기화될 수 있습니다. 또한 사용자 인터페이스를 통해 채워질 수도 있습니다.\n\n생성자는 대상 webResource를 로드하지 않은 WKWebView의 인스턴스를 만듭니다.\n\n일단 loadWebPage 메서드는 인터넷 웹 리소스를 로드할 것입니다. 나중에 로컬 웹 콘텐츠를 처리하는 방법도 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXCode Playground에서 시도해 보고 싶다면 다음을 추가해보세요:\n\n```js\nimport SwiftUI\nimport WebKit\nimport PlaygroundSupport\n\n// 위의 코드를 포함해주세요\n\nstruct ContentView: View {\n    let vm = BaseWebViewVM(webResource: \"http://www.google.com\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n\nPlaygroundPage.current.setLiveView(ContentView())\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_2.png\" /\u003e\n\n인터넷 웹 페이지를 표시하는 데 유용합니다. 로컬 웹 콘텐츠를 표시하는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 내장 웹 페이지 표시\n\n먼저 XCode 프로젝트 루트에 Web 폴더를 생성합니다. 모든 웹 페이지와 관련 자료가 포함되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_3.png\" /\u003e\n\n웹 콘텐츠 폴더는 원시 애플리케이션 프로젝트의 물리적인 일부일 수도 있고 그렇지 않을 수도 있습니다. 두 개가 별도의 개체이면 소스 코드 관리에 특히 주의해야 합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 특정 HTML 파일에 액세스하는 방법은 무엇인가요?\n\n애플리케이션이 Web 폴더에있는 다음 웹 페이지에 액세스해야 하는 경우: (위 스크린샷 참조)\n\n```js\nWeb/userGuide/section1/login.html\n```\n\n이것은 상대 경로입니다. 애플리케이션은 절대 경로로만 파일을 열 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 시뮬레이터에서\n\n/Users/\u003cyour user ID\u003e/Library/Developer/CoreSimulator/Devices/.../Web/userGuide/section1/login.html\n\n# XCode Playground 프로젝트에서\n\n/var/folders/.../Web/userGuide/section1/login.html\n```\n\n상대 경로를 절대 경로로 변환하는 코드는 다음과 같습니다:\n\n```js\nlet nswr = NSString(string: relativePath)\n\nlet pathName = nswr.deletingLastPathComponent\nlet fileExtension = nswr.pathExtension\nlet fileName = nswr.lastPathComponent.replacing(\".\\(fileExtension)\", with: \"\")\n\n// pathName: Web/userGuide/section1\n// fileName: login\n// fileExtension: html\n\nlet absolutePath = Bundle.main.path(forResource: fileName,\n                                    ofType: fileExtension,\n                                    inDirectory: inDirectory)\n```\n\n애플리케이션 메인 번들에서 path 메서드는 주어진 파일 정보를 절대 경로로 변환하려고 합니다. 만약 주어진 파일 정보가 잘못되었다면 nil을 반환합니다.``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 HTML 파일의 절대 경로를 획득하면, 웹 뷰에 해당 파일을 로드할 수 있습니다.\n\n```js\nlet url = URL(filePath: absolutePath)\nwebView.loadFileURL(url, allowingReadAccessTo: url)\n```\n\n로드 메서드 대신에 파일 경로를 사용할 때는 loadFileURL 메서드를 사용해야 합니다.\n\n위 샘플 코드를 기준으로 설명하자면, LocalWebViewVM이라는 새 클래스를 추가할 것입니다. 이 클래스는 BaseWebViewVM의 하위 클래스입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nclass LocalWebViewVM: BaseWebViewVM {\n    private func processWebResource(webResource: String) -\u003e (inDirectory: String,\n                                                             fileName: String,\n                                                             fileExtension: String) {\n        // 상대 경로명을 구성 요소로 분해하는 코드\n    }\n\n    override func loadWebPage() {\n        if let webResource = webResource {\n            let (inDirectory,\n                 fileName,\n                 fileExtension) = processWebResource(webResource: webResource)\n\n            guard let filePath = Bundle.main.path(forResource: fileName,\n                                                  ofType: fileExtension,\n                                                  inDirectory: inDirectory) else {\n                print(\"잘못된 경로\")\n                return\n            }\n\n            print(filePath)\n            let url = URL(filePath: filePath)\n\n            webView.loadFileURL(url, allowingReadAccessTo: url)\n        }\n    }\n}\n```\n\n해당 하위 클래스는 loadWebPage 메서드를 오버라이드합니다.\n\nContentView를 다른 뷰 모델로 업데이트합니다.\n\n```swift\nstruct ContentView: View {\n    let vm = LocalWebViewVM(webResource: \"Web/userGuide/section1/login.html\")\n    \n    var body: some View {\n        SwiftUIWebView(viewModel: vm)\n            .onAppear(perform: vm.loadWebPage)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 캔버스에서 표시되는 내용입니다. (XCode Playground에서 라이브 뷰로 확인)\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_4.png)\n\n# 사용자 상호작용\n\n## 자바스크립트 경고\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지나 어플리케이션은 다음과 같은 Javascript 코드를 통해 사용자에게 알림 메시지를 표시할 수 있습니다:\n\n```js\nalert(\"이것은 알림입니다\");\n```\n\n이것이 발생할 때 WKWebView는 대화 상자를 표시하지 않습니다. 대신, 이 역할은 호스팅 애플리케이션에 위임됩니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -\u003e WKWebView {\n        // 알림 처리\n        vm.webView.uiDelegate = context.coordinator\n        \n        return vm.webView\n    }\n\n    ...\n}\n\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 Javascipt 알림을 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptAlertPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping () -\u003e Void) {\n            viewModel.webPanel(message: message,\n                               alertCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // Javascript 알림, 확인, 프롬프트 대화 상자에 대한 프로퍼티\n    @Published var showPanel: Bool = false\n    var panelTitle: String = \"\"\n    var panelType: JSPanelType? = nil\n    \n    var panelMessage: String = \"\"\n        \n    // 알림 프로퍼티\n    var alertCompletionHandler: () -\u003e Void = {}\n\n    // 해당 알림 UI를 위한 프로퍼티 설정\n    func webPanel(message: String,\n                  alertCompletionHandler completionHandler: @escaping () -\u003e Void) {\n        self.panelTitle = JSPanelType.alert.description // \"알림\"\n        self.panelMessage = message\n        self.alertCompletionHandler = completionHandler\n        self.panelType = .alert\n        self.showPanel = true\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 응용 프로그램은 context.coordinator를 웹 뷰 uiDelegate 속성에 할당해야 합니다.\n\nCoordinator 클래스는 WKUIDelegate 프로토콜을 구현하고 여러 webView 함수 중 하나를 구현해야 합니다. 더 구체적으로는 Javascript alert용 함수입니다. 이 webView 함수는 UI 표시를 시작하지 않습니다. 대신, 알림 메시지와 콜백 함수를 뷰 모델로 전달합니다.\n\nJavascript alert는 모든 웹 페이지에 대해 일반적인 기능이므로 해당 기능을 하위 클래스가 아닌 BaseWebViewVM에 구현하는 것이 가장 좋습니다.\n\n다음은 몇 가지 새로운 속성입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nshowPanel - ContentView에서 UI 표시를 토글하는 발행된 속성입니다.\n\npanelTitle - 일반적인 UI 표시 제목입니다.\n\npanelMessage - 웹 페이지에서 나오는 메시지입니다.\n\npanelType - UI 표시의 유형을 나타냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nalertCompletionHandler — 특정 Javascript 경고 콜백 함수\n\nwebPanel 함수는 panelType을 JSPanelType.alert로 설정합니다. 또한 showPanel을 true로 설정하여 해당 UI 프레젠테이션을 트리거해야 합니다.\n\nJSPanelType은 열거 유형입니다. 현재는 alert 값만 포함하고 있습니다. 또한 선택한 값에 대한 제목 설명을 반환하는 description이라는 계산된 속성이 있습니다.\n\n다음은 업데이트된 ContentView입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                           switch vm.panelType {\n                           case .alert:\n                               Button(\"Close\") {\n                                   vm.alertCompletionHandler()\n                               }\n                           default:\n                               Button(\"Close\") {}\n                           }\n                       }, message: {\n                           Text(vm.panelMessage)\n                       })\n        }\n        .padding()\n    }\n}\n```\n\nSwiftUIWebView에는 alert modifier가 포함되어 있습니다. 해당 alert에는 Close 버튼이 있습니다. 이 버튼은 alertCompletionHandler 함수를 호출할 것입니다.\n\n다음은 웹 페이지입니다:\n\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cbutton onclick=\"alert('This is an alert!')\"\u003eAlert\u003c/button\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:508/1*crNpOlR8VlOFpZSVQXkF-Q.gif)\n\n이것은 표준 프레젠테이션입니다. 그러나 필요에 따라 시트, 팝오버 또는 응용 프로그램에 적합한 UI로 구현할 수 있습니다.\n\n## Javascript Confirm\n\nJavascript confirm 기능은 javascript alert와 유사합니다. 표준 프레젠테이션에서 모달에는 메시지, 확인 버튼 및 취소 버튼이 포함됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconfirm(\"Are you sure?\")\n```\n\n자바스크립트 confirm 함수는 OK 버튼을 클릭할 때 TRUE를 반환합니다. 그렇지 않으면 FALSE를 반환합니다.\n\nSwift에서 자바스크립트 confirm을 처리하려면 애플리케이션은 다른 WKUIDelegate webView 함수를 추가해야 합니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수가 자바스크립트 confirm을 처리합니다.\n        func webView(_ webView: WKWebView,\n                     runJavaScriptConfirmPanelWithMessage message: String,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (Bool) -\u003e Void) {\n            viewModel.webPanel(message: message,\n                               confirmCompletionHandler: completionHandler)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 확인 속성\n    var confirmCompletionHandler: (Bool) -\u003e Void = { _ in }\n\n    // 해당 확인 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  confirmCompletionHandler completionHandler: @escaping (Bool) -\u003e Void) {\n        self.panelTitle = JSPanelType.confirm.description\n        self.panelMessage = message\n        self.confirmCompletionHandler = completionHandler\n        self.panelType = .confirm\n        self.showPanel = true\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript의 confirm을 위한 webView 함수는 약간 다른 콜백 함수 서명을 가지고 있어요.\n\n```js\ncompletionHandler: @escaping (Bool) -\u003e Void\n```\n\nboolean 값을 인자로 받아요.\n\nJSPanelType에 confirm 값을 추가해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBaseWebViewVM에 confirmCompletionHandler 속성을 추가하십시오. Javascript confirm을 위한 다른 webPanel 함수를 추가하십시오. panelType 속성을 JSPanelType.confirm으로 설정하십시오. 다시 한번 showPanel을 true로 설정하여 UI 표시를 트리거합니다.\n\n다음은 업데이트된 ContentView입니다:\n\n```swift\nstruct ContentView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                .onAppear(perform: vm.loadWebPage)\n                .alert(vm.panelTitle,\n                       isPresented: $vm.showPanel,\n                       actions: {\n                    switch vm.panelType {\n                    case .alert:\n                        Button(\"Close\") {\n                            vm.alertCompletionHandler()\n                        }\n                    case .confirm:\n                        Button(\"Ok\") {\n                            vm.confirmCompletionHandler(true)\n                        }\n                        Button(\"Cancel\") {\n                            vm.confirmCompletionHandler(false)\n                        }\n                    default:\n                        Button(\"Close\") {}\n                    }\n                }, message: {\n                    Text(vm.panelMessage)\n                })\n        }\n        .padding()\n    }\n}\n```\n\n다음은 업데이트된 웹 페이지입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003cscript\u003e\n    ...\n    function callConfirm() {\n      if (confirm(\"This is a confirm dialog\")) {\n        document.getElementById(\"confirmValue\").innerText = \"You hit ok\";\n      } else {\n        document.getElementById(\"confirmValue\").innerText = \"You hit cancel\";\n      }\n    }    \n  \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  ...\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"callConfirm()\"\u003eConfirm\u003c/button\u003e\n    \u003cdiv\u003eConfirmed? \u003cspan id=\"confirmValue\"\u003e\u003c/span\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n![Image](https://miro.medium.com/v2/resize:fit:504/1*DJyWQIktvhBdSEaqEIYJlw.gif)\n\n## Javascript Prompt\n\nThe last standard Javascript modal is prompt. The modal contains a text field for user input.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nvar response = prompt(\"이것은 프롬프트입니다! 어떻게 지내세요?\", \"좋음\");\n```\n\nprompt 함수의 두 번째 선택적 매개변수는 기본값입니다. 기본값은 webView 델리게이트 메서드를 통해 전달됩니다.\n\n다시 한 번, 응용 프로그램은 다른 WKUIDelegate webView 함수를 추가해야 하며, JSPanelType을 업데이트하고 BaseWebViewVM 클래스에 새 속성 및 webPanel 함수를 추가해야 합니다.\n\n```swift\nextension SwiftUIWebView {\n    class Coordinator: NSObject, WKUIDelegate {\n        ...\n\n        // webView 함수는 자바스크립트 프롬프트를 처리합니다\n        func webView(_ webView: WKWebView,\n                     runJavaScriptTextInputPanelWithPrompt prompt: String,\n                     defaultText: String?,\n                     initiatedByFrame frame: WKFrameInfo,\n                     completionHandler: @escaping (String?) -\u003e Void) {\n            viewModel.webPanel(message: prompt,\n                               promptCompletionHandler: completionHandler,\n                               defaultText: defaultText)\n        }\n    }\n}\n\nenum JSPanelType {\n    case alert\n    case confirm\n    case prompt\n    \n    var description: String {\n        switch self {\n        case .alert:\n            return \"알림\"\n        case .confirm:\n            return \"확인\"\n        case .prompt:\n            return \"프롬프트\"\n        }\n    }\n}\n\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 프롬프트 속성\n    var promptInput: String = \"\"\n    var promptCompletionHandler: (String?) -\u003e Void = { _ in }\n\n    // 해당 프롬프트 UI에 대한 속성 설정\n    func webPanel(message: String,\n                  promptCompletionHandler completionHandler: @escaping (String?) -\u003e Void,\n                  defaultText: String? = nil) {\n        self.panelTitle = JSPanelType.prompt.description\n        self.panelMessage = message\n        self.promptInput = defaultText ?? \"\"\n        self.promptCompletionHandler = completionHandler\n        self.panelType = .prompt\n        self.showPanel = true\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백 함수는 promptInput 속성 값을 전달합니다. promptInput은 null이 아닌 문자열 속성임을 유의하세요. 따라서 콜백은 빈 문자열이거나 사용자 입력일 수 있습니다.\n\n다음은 업데이트된 웹 페이지입니다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003cscript\u003e\n    ...\n    function callPrompt() {\n      var response = prompt(\"프롬프트입니다! 어떻게 지내세요?\", \"좋아요\");\n      if (response) {\n        document.getElementById(\"promptResult\").innerText =\n          \"당신의 응답은: \" + response;\n      } else {\n        document.getElementById(\"promptResult\").innerText = \"취소됨\";\n      }\n    }  \n    \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  ...\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"callPrompt()\"\u003e프롬프트\u003c/button\u003e\n    \u003cdiv\u003e\u003cspan id=\"promptResult\"\u003e\u003c/span\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:508/1*rlolSsaDf_BRguFOB8td5Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML5에서는 다이얼로그 요소가 있습니다. 이 요소는 HTML에서 모달 및 비모달 대화 상자를 만드는 데 사용됩니다.\n\n다이얼로그 요소를 사용하면 사용자 정의 경고, 확인 대화 상자 및 프롬프트 모달 대화 상자를 만들 수 있습니다. 이 접근 방식을 사용하면 모달을 다른 웹 애플리케이션과 일치하도록 스타일링할 수 있습니다.\n\n다이얼로그 요소를 사용하면 Swift 코드를 작성하는 대신 모든 사용자 상호 작용을 처리하기 위해 Javascript 코드를 작성해야 합니다. 하지만 이것은 원격 대화 상자를 생성하는 방법을 호스트(기본)에게 전달할 수 없다는 것을 의미하지는 않습니다. 다음 섹션에서는 웹 페이지와 호스트(기본) 응용 프로그램 간의 메시지나 이벤트를 전송하는 방법에 대해 알아볼 것입니다.\n\n# 웹 페이지와 기본 응용프로그램 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹킷 프레임워크는 Objective-C 및 Swift를 위해 설계되었습니다. WebKit JS라고도 하는 자바스크립트 부분도 있습니다. 이는 Safari DOM 확장 기능입니다. (그것이 원래 이름일 수도 있습니다!) 기본적으로 이는 Safari 환경에 터치 제스처 이벤트, 스타일링 및 시각적 효과를 추가합니다. 실제로 그 기능 중 일부는 이미 W3C 표준의 일부로 채택되었습니다.\n\n웹 페이지에서 네이티브 애플리케이션으로 메시지/데이터를 보내려면 수신 측에 \"리스너\" 또는 WebKit 용어로는 메시지 핸들러가 필요하고, 보내는 쪽에는 메시지 전송 함수가 있어야 합니다.\n\n이 섹션에서는 웹 뷰에서 네이티브 애플리케이션으로 메시지를 보내거나 받고 응답하는 방법을 설명합니다.\n\n우선 웹 콘텐츠부터 시작해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n\u003c!-- index2.html --\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n  \u003ctitle\u003eIndex 2\u003c/title\u003e\n  \u003cscript\u003e\n    async function sendWebKitMessage(handler, message) {\n      if (\n        message != \"\" \u0026\u0026\n        handler != \"\" \u0026\u0026\n        window.webkit \u0026\u0026\n        window.webkit.messageHandlers \u0026\u0026\n        window.webkit.messageHandlers.hasOwnProperty(handler)\n      ) {\n        console.log(\"Going to send a message to\", handler)\n        var reply = await window.webkit.messageHandlers[handler].postMessage(message);\n        return reply\n      } else {\n        throw Error(\"뭔가 빠지는 게 있어요!\");\n      }\n    }\n\n    async function sendReceiveReply(handler, message, elementId) {\n      try {\n        var reply = await sendWebKitMessage(handler, message);\n\n        var sanitizedReply = reply.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\");\n        document.getElementById(elementId).innerHTML = sanitizedReply;\n      } catch (error) {\n        document.getElementById(elementId).innerHTML = \"에러: \" + error.message;\n      }\n    }\n  \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003cbutton onclick=\"sendWebKitMessage('fromWebPage', '웹 뷰에서 온 메시지')\"\u003e메시지 보내기\u003c/button\u003e\n  \u003c/div\u003e\n  \u003cdiv style=\"margin-top: 15px\"\u003e\n    \u003cbutton onclick=\"sendReceiveReply('getData', '보내줘야 할 데이터 있어?', 'reply')\"\u003e데이터 가져오기\u003c/button\u003e\n    \u003cdiv id=\"reply\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Send Message\" 버튼으로부터 발생한 처리되지 않은 예외의 스크린샷과 \"Get Data\" 버튼에서 처리된 예외의 스크린샷입니다.\n\n![예외 스크린샷](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_5.png)\n\n핸들러는 window.webkit.messageHandlers 네임스페이스에 있는 객체입니다. 모든 메시지 핸들러에는 postMessage라는 메소드가 있습니다. 이 메소드는 네이티브 애플리케이션으로 메시지/데이터를 보내는 데 사용됩니다.\n\nsendWebKitMessage 함수에는 console.log가 있습니다. 이 함수는 웹 인스펙터 콘솔 영역에 메시지를 표시할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네이티브 애플리케이션 UI와 웹 뷰를 Safari 웹 브라우저에서 검사할 수 있도록 몇 가지 변경을 가해봅시다.\n\n```js\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // 웹 뷰로부터의 메시지\n    @Published var messageFromWV: String = \"\"\n\n    init(webResource: String? = nil) {\n        ...\n        \n#if DEBUG\n        // 검사 가능한 웹 뷰\n        self.webView.isInspectable = true\n#endif\n    }\n\n    ...\n}\n\nstruct ContentView: View {\n    // 이 VM은 메시지를 보내는 로컬 웹 페이지를 표시합니다.\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index2.html\")\n\n    var body: some View {\n        VStack {\n            SwiftUIWebView(viewModel: vm)\n                ...\n            Text(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n        }\n    }\n}\n```\n\nBaseWebViewVM에서 messageFromWV라는 publish된 속성이 추가되었습니다. 이 속성은 웹 뷰에서 수신된 메시지를 저장할 것입니다. Text 요소가 이 변수에 바인딩됩니다.\n\n```js\n@Published var messageFromWV: String = \"\"\n\nText(\"웹 뷰에서 온 메시지:\\n\\(vm.messageFromWV)\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBaseWebViewVM 이니셜라이저에는 다음과 같은 코드 줄이 포함되어 있습니다.\n\n```js\n#if DEBUG\n    self.webView.isInspectable = true\n#endif\n```\n\n이를 통해 Safari가 웹 뷰 안에 있는 웹 페이지를 검사할 수 있습니다. 샘플 웹 페이지의 제목이 \"Index 2\"인 것에 유의하십시오. iOS 시뮬레이터에서 애플리케이션을 실행할 때 Develop \u003e Simulator 하위 메뉴 아래에서 웹 페이지 제목을 볼 수 있어야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML 버튼이 네이티브 애플리케이션과 상호 작용하도록 만들어 봅시다.\n\n먼저 \"fromWebPage\"와 \"getData\"에 대한 메시지 핸들러를 정의해야 합니다.\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n    func makeUIView(context: Context) -\u003e WKWebView {\n        let userContentController = vm.webView\n            .configuration\n            .userContentController\n        \n        // 모든 메시지 핸들러를 제거합니다 (기존에 있으면)\n        userContentController.removeAllScriptMessageHandlers()\n\n        // 응답 없이 메시지 핸들러 추가\n        userContentController.add(context.coordinator,\n                                  name: \"fromWebPage\")\n\n        // 응답과 함께 메시지 핸들러 추가\n        userContentController.addScriptMessageHandler(context.coordinator,\n                                                      contentWorld: WKContentWorld.page,\n                                                      name: \"getData\")\n        ...\n    }\n}\n```\n\n사용자 콘텐츠 컨트롤러(WKUserContentController)는 \"앱의 네이티브 코드와 웹페이지의 스크립트 및 기타 콘텐츠 간의 상호 작용을 조정\"합니다. 이것은 웹 뷰 구성(WKWebViewConfiguration) 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메시지 송수신 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 add 메서드를 사용해야 합니다.\n\n메시지 송수신-응답 핸들러를 위해 애플리케이션은 사용자 콘텐츠 컨트롤러의 addScriptMessageHandler 메서드를 사용해야 합니다.\n\n두 메서드 모두 사용자 콘텐츠 컨트롤러 메서드를 구현한 객체와 메시지 핸들러의 이름을 전달해야 합니다. 메시지 송수신의 경우, 객체는 WKScriptMessageHandler 프로토콜을 구현해야 합니다. 메시지 송수신-응답의 경우, 객체는 WKScriptMessageHandlerWithReply를 구현해야 합니다.\n\naddScriptMessageHandler는 또한 메시지 핸들러를 설치할 위치를 알아야 합니다. 이 샘플 코드에서, 애플리케이션은 WKContentWorld.page를 contentWorld 인자에 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자연스럽게, 코디네이터가 메시지 통신을 처리할 것입니다. 여기 구현입니다.\n\n```js\nextension SwiftUIWebView {\n    class Coordinator: ..., WKScriptMessageHandler, WKScriptMessageHandlerWithReply {\n        ...\n\n        // MARK: - WKScriptMessageHandler delegate function\n\n        // 메시지 송수신을 위한\n        func userContentController(_ userContentController: WKUserContentController, \n                                   didReceive message: WKScriptMessage) {\n            self.viewModel.messageFrom(fromHandler: message.name,\n                                       message: message.body)\n        }\n\n        // MARK: - WKScriptMessageHandlerWithReply delegate function\n\n        // 메시지 송수신 및 응답을 위한\n        func userContentController(_ userContentController: WKUserContentController,\n                                   didReceive message: WKScriptMessage,\n                                   replyHandler: @escaping (Any?, String?) -\u003e Void) {\n            do {\n                let returnValue = try self.viewModel.messageFromWithReply(fromHandler: message.name,\n                                                                          message: message.body)\n                \n                replyHandler(returnValue, nil)\n            } catch WebViewErrors.GenericError {\n                replyHandler(nil, \"일반 오류\")\n            } catch WebViewErrors.ErrorWithValue(let value) {\n                replyHandler(nil, \"값 오류: \\(value)\")\n            } catch {\n                replyHandler(nil, error.localizedDescription)\n            }\n        }\n    }\n}\n```\n\nuserContentController 두 가지 구현은 사용자 컨텐츠 컨트롤러 및 수신 메시지에 대한 참조를 받습니다.\n\n메시지인 WKScriptMessage는 두 가지 중요한 매개변수, 메시지 핸들러의 이름(name)과 메시지 내용(body)을 포함합니다. 이 샘플 코드에서, 두 구현은 모두 이름과 내용을 사용하여 뷰 모델 메서드를 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보내기-수신-응답 버전을 위해 추가적인 replyHandler 클로저 인자가 있습니다. 클로저는 반환값과 오류 메시지 2개의 인자를 갖습니다. 클로저를 호출할 때 애플리케이션이 \"something\"을 한 인자로 전달하고 다른 하나는 nil입니다.\n\n마지막으로, 애플리케이션은 수신 메시지의 의도를 실행하기 위한 메서드를 구현해야 합니다.\n\n```swift\nclass BaseWebViewVM: ObservableObject {\n    ...\n\n    // MARK: - 메시징을 위한 함수\n    func messageFrom(fromHandler: String, message: Any) {\n        self.panelTitle = JSPanelType.alert.description // \"Alert\"\n        self.panelMessage = String(describing: message)\n        self.alertCompletionHandler = {}\n        self.panelType = .alert\n        self.showPanel = true\n        self.messageFromWV = String(describing: message)\n    }\n\n    func messageFromWithReply(fromHandler: String, message: Any) throws -\u003e String {\n        self.messageFromWV = String(describing: message)\n\n        var returnValue: String = \"Good\"\n\n        /*\n         * 이 함수는 다음과 같은 예외를 던질 수 있습니다:\n         *\n         * - WebViewErrors.GenericError\n         * - WebViewErrors.ErrorWithValue(value: 99)\n         */\n        \n        if fromHandler == \"getData\" {\n            returnValue = \"{ data: \\\"It is good!\\\" }\"\n        }\n        \n        return returnValue\n    }\n}\n```\n\nmessageFrom 메서드는 send-receive 메시징을 처리합니다. 예외를 던지지는 않는다는 점에 유의하십시오. 던진다 해도 userContentController 메서드는 해당 오류를 웹 뷰로 다시 전달할 수 없을 것입니다. 오류를 웹 뷰로 다시 전달해야 하는 경우 send-receive-reply 메시징 전략을 사용해야 합니다 - messageFromWithReply 메서드를 사용하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmessageFromWithReply 메서드는 예외를 throw하고 문자열 값을 반환합니다. 샘플 코드에서는 JSON 문자열을 웹 뷰로 다시 반환합니다. 자바스크립트 세계에서는 JSON 문자열을 쉽게 자바스크립트 객체로 파싱할 수 있습니다.\n\n현재 샘플 코드는 예외를 throw하지 않습니다. 그러나 이 샘플 프로젝트에서 정의된 오류는 다음과 같습니다.\n\n```js\nenum WebViewErrors: Error {\n    case ErrorWithValue(value: Int)\n    case GenericError\n}\n```\n\n첫 번째 오류는 정수값을 받습니다. 하나 이상의 인수를 받을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱의 enum을 앱에 맞게 사용자 정의하세요!\n\n마침내, 이것이 보이는 모습입니다:\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-PYrd32kdzvXGs27tgr8yQ.gif)\n\n네이티브 애플리케이션에서 웹 뷰로 메시지를 보내는 방법은 어떤가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네이티브 애플리케이션에서 메시지를 수신하려면 웹 페이지가 \"메시지\" 이벤트를 \"청취\"해야 합니다.\n\n다음은 샘플 웹 페이지입니다:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  ...\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv\u003e\n    \u003clabel for=\"\"\u003e호스트로부터의 메시지:\u003c/label\u003e\n    \u003cbr\u003e\n    \u003cdiv id=\"message\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\u003c/body\u003e\n\u003cscript\u003e\n  window.addEventListener(\"message\", (event) =\u003e {\n    // 수신 메시지 소독(Process of cleaning untrusted input)\n    var content = event.data.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\")\n    document.getElementById(\"message\").innerHTML = content\n  })\n\u003c/script\u003e\n\n\u003c/html\u003e\n```\n\n웹 페이지는 \"메시지\" 이벤트리스너를 추가합니다. event.data에는 메시지 콘텐츠가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 페이지가 \"메시지\"를 수신하면 해당 내용을 웹 페이지에 단순히 표시합니다.\n\n웹 뷰에 메시지를 보낼 수 있는 UI를 만들어봅시다.\n\n```js\nstruct MessageToWebView: View {\n    @ObservedObject var vm = LocalWebViewVM(webResource: \"index3.html\")\n    @State var message: String = \"\"\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"메시지:\")\n                .font(.system(size: 26))\n            HStack(alignment: .center, spacing: 10) {\n                TextField(\"메시지를 입력하세요\", text: $message)\n                    .textFieldStyle(.roundedBorder)\n                    .border(.blue)\n                    .font(.system(size: 26))\n                Button(\"전송\") {\n                    vm.messageTo(message: message)\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            WebView(vm: vm)\n        }\n        .padding()\n    }\n}\n```\n\n![MessagingBetweenWKWebViewandNativeApplicationinSwiftUI](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"보내기\" 버튼은 뷰 모델에서 messageTo 메서드를 호출합니다.\n\n```js\nfunc messageTo(message: String) {\n    let escapedMessage = message.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    \n    let js = \"window.postMessage(\\\"\\(escapedMessage)\\\", \\\"*\\\")\"\n    self.webView.evaluateJavaScript(js) { (result, error) in\n        if let error = error {\n            print(\"Error: \\(error.localizedDescription)\")\n        }\n    }\n}\n```\n\n위의 다른 시나리오들과는 달리, 구현해야 할 프로토콜 메서드가 없습니다. 웹 뷰로 메시지를 보내기 위한 네이티브 메서드도 없습니다.\n\n대신 네이티브 애플리케이션은 Javascript postMessage 호출을 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nwindow.postMessage(...)\n```\n\npostMessage 메서드는 텍스트 인수를 받습니다. 결과적으로, 웹 뷰의 evaluateJavaScript 메서드에서 실행하기 전에 콘텐츠를 올바르게 이스케이프하고 인코딩해야 합니다.\n\n```js\nfunc evaluateJavaScript(\n    _ javaScriptString: String,\n    completionHandler: ((Any?, Error?) -\u003e Void)? = nil\n)\n```\n\nevaluateJavaScript에는 completionHandler가 있습니다. 이는 반환 값을 또는 에러를 네이티브 응용 프로그램으로 돌려 보내는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nevaluateJavaScript 메서드는 JavaScript 코드를 실행하거나 평가할 수 있습니다. 예시 코드에서 window.postMessage 호출은 값을 반환하거나 오류를 반환하지 않습니다. 다른 경우에는 실행되는 코드가 값이 반환되고 예외가 발생할 수 있습니다.\n\n마지막으로, 실제 동작을 확인할 수 있습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AZXEKStS4IuR49Ho-HwihA.gif)\n\n위 웹 페이지에는 이벤트 리스너 선언을 포함한 스크립트 요소가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 모든 웹 페이지에 동일한 Javascript 코드를 주입해야 할 때, 모든 웹 페이지에 수동으로 스크립트 요소를 추가하는 대신, 사용자 콘텐츠 컨트롤러의 addUserScript 메서드를 활용할 수 있습니다.\n\n다음은 간단한 구현입니다:\n\n```js\nstruct SwiftUIWebView: UIViewRepresentable {\n    ...\n\n   func makeUIView(context: Context) -\u003e WKWebView {\n      ...\n\n      injectJS(userContentController)\n\n      ...\n    }\n\n    func injectJS(_ userContentController: WKUserContentController) {\n        // 메시지 이벤트 리스너 정의\n        //\n        // \u003cscript\u003e HTML 요소를 포함할 필요가 없다는 점에 유의하십시오.\n        let msgEventListener = \"\"\"\nwindow.addEventListener(\"message\", (event) =\u003e {\n    // 수신된 메시지 정제\n    var content = event.data.replace(/\u003c/g, \"\u0026lt;\").replace(/\u003e/g, \"\u0026gt;\")\n    document.getElementById(\"message\").innerHTML = content\n})\n\"\"\"\n\n        // 이벤트 리스너 주입\n        userContentController.addUserScript(WKUserScript(source: msgEventListener,\n                                                         injectionTime: .atDocumentEnd,\n                                                         forMainFrameOnly: true))\n    }\n}\n```\n\ninjectJS 함수는 동일한 이벤트 리스너 코드를 가진 변수(msgEventListener)를 포함하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`addUserScript` 함수에는 `WKUserScript`의 인스턴스가 필요합니다.\n\n`injectionTime`은 `.atDocumentEnd`로 설정되어 있습니다. 이는 원본 스크립트 요소 선언과 동일합니다. 다른 값으로는 `.atDocumentStart`가 있습니다.\n\n만약 자바스크립트 코드가 콘텐츠 요소에 의존한다면, 코드를 `.atDocumentEnd`에 주입하는 것이 가장 좋을 수 있습니다.\n\n만약 자바스크립트 코드가 라이브러리이면, 코드를 `.atDocumentStart`에 주입하는 것이 가장 좋을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nforMainFrameOnly 인수는 부울 값입니다. true를 전달하면 자바스크립트 코드가 주 페이지에만 삽입됩니다. 애플리케이션은 모든 iframe 요소에 동일한 자바스크립트 코드를 삽입하지 않습니다. 그렇지 않으면 자바스크립트 코드는 주 페이지와 해당 iframe 요소에 삽입됩니다.\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_8.png)\n\n![이미지](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_9.png)\n\n웹 인스펙터에서 삽입된 자바스크립트 코드는 \"추가 스크립트 `user-script:1`\" 아래에 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 하이퍼링크를 통해 다른 웹 페이지로 이동하면, 애플리케이션이 해당 웹 페이지에 동일한 자바스크립트 블록을 삽입합니다.\n\n이 웹 페이지에 iframe을 추가하고 forMainFrameOnly를 false로 설정해봅시다.\n\n![image](/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_10.png)\n\n웹 인스펙터에서 \"user-script:1\"이 두 번 표시됩니다. 각 웹 페이지는 자바스크립트 코드 블록을 수신합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용 시나리오\n\n## 앱 내 사용자 가이드\n\niOS 또는 macOS 애플리케이션에서 사용자 가이드나 맥락에 맞는 도움말 정보를 제공해야 하는 경우, 어떻게 할까요?\n\nUIKit의 UILabel 및 SwiftUI의 Text 요소는 기본적인 마크다운 형식을 지원합니다. 서식이 있는 텍스트와 이미지로 유용한 도움말 페이지를 만드는 것은 다소 귀찮은 작업이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도움 페이지는 HTML과 CSS를 사용하여 웹 페이지로 작성할 수도 있습니다. 도움 페이지는 앱 내에 포함되어 WKWebView를 사용하여 표시될 수 있습니다.\n\n## 사용자 인터페이스\n\nSwiftUI 또는 UIKit을 사용하여 전체 네이티브 애플리케이션을 만드는 대신 대부분의 사용자 인터페이스를 HTML과 CSS를 사용하여 구현할 수 있습니다. 대부분의 비즈니스 로직은 Javascript를 사용하여 구현할 수 있습니다.\n\nReactJS, Angular, VueJS 등의 Javascript 프레임워크를 사용하면 프론트엔드 로직을 구성하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 UI 라이브러리인 Bootstrap, Foundation, Semantic UI, Tailwind Elements 등은 많은 매력적인 UI 구성 요소들을 제공해요. 이 라이브러리들은 네이티브 애플리케이션의 느낌과 모양에 맞게 사용자정의할 수 있어요.\n\n물론, 이러한 라이브러리와 프레임워크를 사용하면 애플리케이션의 크기가 커질 수 있어요. 현명하게 사용해야 해요!\n\n# 샘플 XCode 프로젝트\n\n해당 XCode 프로젝트에 대한 GitHub 링크는 여기에서 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- WKWebView\n- UIViewRepresentable\n- Coordinator\n- WKUIDelegate\n- WKUserContentController\n- WKWebViewConfiguration\n- WKContentWorld\n- WKScriptMessageHandler\n- WKScriptMessageHandlerWithReply\n- WKScriptMessage\n- DOM 메시지 이벤트 및 window.postMessage 메서드\n- WKUserScript\n\n이 기사는 여기서 끝입니다. 아마도 여러분이 프로젝트에서 WKWebView를 어떻게 활용할 수 있는지에 대한 아이디어를 얻을 수 있기를 바랍니다.\n\n이 기사를 즐겁게 읽어 주셨으면 좋겠습니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png"},"coverImage":"/assets/img/2024-05-20-MessagingBetweenWKWebViewandNativeApplicationinSwiftUI_0.png","tag":["Tech"],"readingTime":34}],"page":"6","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"6"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>