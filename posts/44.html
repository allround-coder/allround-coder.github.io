<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/44" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/44" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-af801b1eee26eff3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="전문 개발자를 위한 18가지 고급 JavaScript 기술" href="/post/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="전문 개발자를 위한 18가지 고급 JavaScript 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="전문 개발자를 위한 18가지 고급 JavaScript 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">전문 개발자를 위한 18가지 고급 JavaScript 기술</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" href="/post/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">API 응답에 TypeScript 유형을 올바르게 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" href="/post/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내가 좋아하는 JavaScript 짧은 코드 한 줄" href="/post/2024-05-14-MyFavouriteJavaScriptOne-Liners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내가 좋아하는 JavaScript 짧은 코드 한 줄" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내가 좋아하는 JavaScript 짧은 코드 한 줄" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">내가 좋아하는 JavaScript 짧은 코드 한 줄</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC에서 구성 요소 간 통신" href="/post/2024-05-14-ComponentCommunicationinLWC"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC에서 구성 요소 간 통신" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC에서 구성 요소 간 통신" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC에서 구성 요소 간 통신</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입" href="/post/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹을 더 접근성 있게 만들기 메뉴와 로더" href="/post/2024-05-14-Makingthewebmoreaccessiblemenusandloaders"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹을 더 접근성 있게 만들기 메뉴와 로더" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹을 더 접근성 있게 만들기 메뉴와 로더" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹을 더 접근성 있게 만들기 메뉴와 로더</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요" href="/post/2024-05-14-HowtogetGithubCopilotfor100free"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="캔버스의 마법을 해제해 보세요" href="/post/2024-05-14-UnlockingtheMagicofCanvas"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="캔버스의 마법을 해제해 보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="캔버스의 마법을 해제해 보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">캔버스의 마법을 해제해 보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" href="/post/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link posts_-active__YVJEi" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"전문 개발자를 위한 18가지 고급 JavaScript 기술","description":"","date":"2024-05-14 15:16","slug":"2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png\" /\u003e\n\n# 브라우저\n\n# 전체 화면 달성하기 🖥️\n\n현재 화면을 전체 화면으로 표시해야 할 때\n\n\n\n```\n# 전체 화면으로 변환하기 ✨\n\n```js\nfunction fullScreen() {  \n    const el = document.documentElement\n    const rfs = \n    el.requestFullScreen || \n    el.webkitRequestFullScreen || \n    el.mozRequestFullScreen || \n    el.msRequestFullscreen\n    if(typeof rfs != \"undefined\" \u0026\u0026 rfs) {\n        rfs.call(el)\n    }\n}\n// 클릭하여 🌐 전체 화면으로 전환하기!\nfullScreen()\n```\n\n# 전체 화면 나가기 🏁\n\n전체 화면을 나가려면\n\n```js\nfunction exitScreen() {\n    if (document.exitFullscreen) { \n        document.exitFullscreen()\n    } \n    else if (document.mozCancelFullScreen) { \n        document.mozCancelFullScreen()\n    } \n    else if (document.webkitCancelFullScreen) { \n        document.webkitCancelFullScreen()\n    } \n    else if (document.msExitFullscreen) { \n        document.msExitFullscreen()\n    } \n    if(typeof cfs != \"undefined\" \u0026\u0026 cfs) {\n        cfs.call(el)\n    }\n    // 전체 화면에서 나가기 🚪🏃\n}\nexitScreen()\n```\n\n\n\n# 페이지 인쇄 🖨️\n\n현재 페이지를 인쇄해야 할 때\n\n```js\n// 페이지를 인쇄하려면 클릭 🖨️\nwindow.print()\n```\n\n# 인쇄 내용 스타일 변경 📄\n\n\n\n현재 페이지를 인쇄하려면서 레이아웃을 수정해야 할 때\n\n```js\n\u003cstyle\u003e\n/* 인쇄 레이아웃 조정 🔧 */\n@media print {\n    .noprint {\n        display: none;\n    }\n}\n\u003c/style\u003e\n\u003cdiv class=\"print\"\u003e인쇄\u003c/div\u003e\n\u003cdiv class=\"noprint\"\u003e인쇄 안 함\u003c/div\u003e\n```\n\n# 차단 닫기 이벤트 🔒\n\n사용자가 새로 고침하거나 브라우저를 닫는 것을 막아야 할 때, beforeunload 이벤트를 트리거하도록 선택할 수 있습니다. 일부 브라우저에서는 텍스트 내용을 사용자 지정할 수 없습니다.\n\n\n\n```\n```js\nwindow.onbeforeunload = function(){\n    return 'haorooms 블로그를 나가시겠습니까? 🚪🤔';\n};\n```\n\n# 화면 녹화 📹\n\n현재 화면을 녹화하고 녹화된 화면을 업로드 또는 다운로드해야 할 때\n\n```js\n// 이곳에서 화면 녹화하기 🎬\nconst streamPromise = navigator.mediaDevices.getDisplayMedia()\nstreamPromise.then(stream =\u003e {\n    var recordedChunks = [];// 녹화된 비디오 데이터\n    var options = { mimeType: \"video/webm; codecs=vp9\" };// 인코딩 형식 설정\n    var mediaRecorder = new MediaRecorder(stream, options);// MediaRecorder 인스턴스 초기화\n    mediaRecorder.ondataavailable = handleDataAvailable;// 데이터가 사용 가능한 경우 콜백 설정 (화면 녹화 종료)\n    mediaRecorder.start();\n    // 비디오 조각화\n    function handleDataAvailable(event) {\n        if (event.data.size \u003e 0) {\n            recordedChunks.push(event.data);// 데이터 추가, event.data는 BLOB 객체\n            download();// BLOB 객체로 래핑하여 다운로드\n        }\n    }\n    // 파일 다운로드\n    function download() {\n        var blob = new Blob(recordedChunks, {\n            type: \"video/webm\"\n        });\n        // 여기서 비디오를 백엔드로 업로드할 수 있음\n        var url = URL.createObjectURL(blob);\n        var a = document.createElement(\"a\");\n        document.body.appendChild(a);\n        a.style = \"display: none\";\n        a.href = url;\n        a.download = \"test.webm\";\n        a.click();\n        window.URL.revokeObjectURL(url);\n    }\n})\n```\n\n\n\n# 가로 및 세로 화면 판단하기 🔄\n\n모바일 전화기의 가로 또는 세로 화면 상태를 판단해야 할 때\n\n```js\nfunction hengshuping() {\n    if (window.orientation == 180 || window.orientation == 0) {\n        alert(\"세로 모드! 📱\");\n    }\n    if (window.orientation == 90 || window.orientation == -90) {\n        alert(\"가로 모드! 🌅\");\n    }\n}\n// 화면 방향 변경을 위한 리스너 추가 🔄\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", hengshuping, false);\n```\n\n# 가로 및 세로 화면 스타일 변경하기 ↔️\n\n\n\n다양한 스타일을 수평 및 수직 화면에 대해 설정해야 할 때\n\n```js\n\u003cstyle\u003e\n@media all and (orientation : landscape) {\n    body {\n        background-color: #ff0000;\n    }\n}\n@media all and (orientation : portrait) {\n    body {\n        background-color: #00ff00;\n    }\n}\n\u003c/style\u003e\n```\n\n# 탭 페이지가 숨김 처리됨 🙈\n\n탭이 표시되거나 숨겨지는 이벤트를 모니터링해야 할 때\n\n\n\n```js\n// 탭 페이지 숨김 🙈\nconst {hidden, visibilityChange} = (() =\u003e {\n    let hidden, visibilityChange;\n    if (typeof document.hidden !== \"undefined\") {\n      // Opera 12.10 및 Firefox 18 이후 지원\n      hidden = \"hidden\";\n      visibilityChange = \"visibilitychange\";\n    } else if (typeof document.msHidden !== \"undefined\") {\n      hidden = \"msHidden\";\n      visibilityChange = \"msvisibilitychange\";\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      hidden = \"webkitHidden\";\n      visibilityChange = \"webkitvisibilitychange\";\n    }\n    return {\n      hidden,\n      visibilityChange\n    }\n})();\n\nconst handleVisibilityChange = () =\u003e {\n    console.log(\"현재 숨겨진 상태\", document[hidden]);\n};\ndocument.addEventListener(\n    visibilityChange,\n    handleVisibilityChange,\n    false\n);\n```\n\n# 이미지\n\n# 로컬 이미지 미리보기 🌄\n\n클라이언트로부터 이미지를 받았지만 즉시 서버에 업로드할 수 없고 미리보기해야 하는 경우\n\n\n\n\n```js\n\u003c!-- 이미지 업로드 및 미리보기 📸 --\u003e\n\u003cdiv class=\"test\"\u003e\n    \u003cinput type=\"file\" name=\"\" id=\"\"\u003e\n    \u003cimg src=\"\" alt=\"\"\u003e\n\u003c/div\u003e\n\u003cscript\u003e\nconst getObjectURL = (file) =\u003e {\n    let url = null;\n    if (window.createObjectURL != undefined) { // basic\n        url = window.createObjectURL(file);\n    } else if (window.URL != undefined) { // webkit or chrome\n        url = window.URL.createObjectURL(file);\n    } else if (window.URL != undefined) { // mozilla(firefox)\n        url = window.URL.createObjectURL(file);\n    }\n    return url;\n}\ndocument.querySelector('input').addEventListener('change', (event) =\u003e {\n    document.querySelector('img').src = getObjectURL(event.target.files[0])\n})\n\u003c/script\u003e\n```\n\n# 이미지 미리로딩 🔄\n\n사진이 많을 때는 화면이 하얗게 보이지 않도록 사진을 미리로딩해야 합니다.\n\n```js\nconst images = []\nfunction preloader(args) {\n    for (let i = 0, len = args.length; i \u003c len; i++) {  \n        images[i] = new Image()  \n        images[i].src = args[i]\n    } \n}  \npreloader(['1.png', '2.jpg'])\n```\n\n\n\n# Js\n\n# 문자열 스크립트 💬\n\n문자열을 js 스크립트로 변환해야 할 때는 이 방법이 xss 취약점이 있으니 주의해서 사용해야 합니다\n\n```js\nconst obj = eval('({ name: \"jack\" })')\n// obj는 object{ name: \"jack\" }로 변환됩니다\nconst v = eval('obj')\n// v는 변수 obj가 됩니다\n```\n\n\n\n# 재귀 함수 이름 분리하기 🔗\n\n재귀 함수를 작성할 때 함수 이름을 선언하지만 함수 이름을 수정할 때마다 내부 함수 이름을 수정하는 것을 항상 잊어버립니다. argument는 함수의 내부 객체로, 함수에 전달된 모든 매개변수를 포함하며 arguments.callee는 함수 이름을 나타냅니다.\n\n```js\n// 이것은 기본 피보나치 수열입니다\nfunction fibonacci (n) {\n    const fn = arguments.callee\n    if (n \u003c= 1) return 1\n    return fn(n - 1) + fn(n - 2)\n}\n```\n\n\n\n# 암묵적 판단 👁️‍🗨️\n\n페이지 뷰에 현재 DOM 요소가 나타나 있는지 판단해야 할 때 IntersectionObserver를 사용해보세요.\n\n```js\n\u003cstyle\u003e\n.item {\n    height: 350px;\n}\n\u003c/style\u003e\n\n\u003cdiv class=\"container\"\u003e\n  \u003cdiv class=\"item\" data-id=\"1\"\u003e보이지 않음\u003c/div\u003e\n  \u003cdiv class=\"item\" data-id=\"2\"\u003e보이지 않음\u003c/div\u003e\n  \u003cdiv class=\"item\" data-id=\"3\"\u003e보이지 않음\u003c/div\u003e\n\u003c/div\u003e\n\u003cscript\u003e\n  if (window?.IntersectionObserver) {\n    let items = [...document.getElementsByClassName(\"item\")]; // 진정한 배열로 변환하여 파싱, Array.prototype.slice.call()도 사용 가능\nlet io = new IntersectionObserver(\n      (entries) =\u003e {\n        entries.forEach((item) =\u003e {\n          item.target.innerHTML =\n            item.intersectionRatio === 1 // 요소의 표시 비율, 1이면 완전히 보이고 0이면 완전히 보이지 않음\n              ? `요소가 완전히 보입니다`\n              : `요소가 부분적으로 보이지 않습니다`;\n        });\n      },\n      {\n        root: null,\n        rootMargin: \"0px 0px\",\n        threshold: 1, // 임계값을 1로 설정하고, 비율이 1에 도달할 때만 콜백 함수가 트리거됨\n      }\n    );\n    items.forEach((item) =\u003e io.observe(item));\n  }\n\u003c/script\u003e\n```\n\n# 편집 가능 요소 ✏️\n\n\n\nDOM 요소를 편집해야 할 때, 텍스트 영역처럼 클릭하세요.\n\n```js\n\u003cdiv contenteditable=\"true\"\u003e여기를 편집할 수 있어요\u003c/div\u003e\n```\n\n# 요소 속성 감시하기 👀\n\n```js\n\u003cdiv id=\"test\"\u003e테스트\u003c/div\u003e\n\u003cbutton onclick=\"handleClick()\"\u003e확인\u003c/button\u003e\n\n\u003cscript\u003e\n  const el = document.getElementById(\"test\");\n  let n = 1;\n  const observe = new MutationObserver((mutations) =\u003e {\n    console.log(\"속성이 변경되었어요\", mutations);\n  })\n  observe.observe(el, {\n    attributes: true\n  });\n  function handleClick() {\n    el.setAttribute(\"style\", \"color: red\");\n    el.setAttribute(\"data-name\", n++);\n  }\n  setTimeout(() =\u003e {\n    observe.disconnect(); // 감시 중지\n  }, 5000);\n\u003c/script\u003e\n```\n\n\n\n# DOM 요소 출력하기 🖨️\n\n개발 과정에서 DOM 요소를 출력해야 할 때, console.log을 사용하면 종종 전체 DOM 요소만 출력되고 내부 속성을 볼 수 없습니다. console.dir을 사용해보세요.\n\n```js\nconsole.dir(document.body)\n```\n\n# 기타\n\n\n\n# 어플리케이션 활성화하기 🚀\n\n모바일 측면에서 개발할 때, 다른 애플리케이션을 열어야 할 때가 있어요. 아래 방법들은 location.href 할당을 통해서도 작동할 수 있어요.\n\n```js\n\u003c!-- 다음 링크들을 사용해서 폰 기능을 활성화해보세요 📲 --\u003e\n\u003ca href=\"tel:12345678910\"\u003e전화 걸기\u003c/a\u003e\n\u003ca href=\"sms:12345678910,12345678911?body=안녕하세요\"\u003e안드로이드 메시지\u003c/a\u003e \n\u003ca href=\"sms:/open?addresses=12345678910,12345678911\u0026body=안녕하세요\"\u003eiOS 메시지\u003c/a\u003e\n\u003ca href=\"wx://\"\u003eiOS 메시지\u003c/a\u003e\n```\n\n# 쉬운 용어로 설명 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수치고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png"},"coverImage":"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png","tag":["Tech"],"readingTime":9},{"title":"API 응답에 TypeScript 유형을 올바르게 사용하는 방법","description":"","date":"2024-05-14 15:14","slug":"2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse","content":"\n\n## JSON 응답을 받을 때 올바른 타입을 보장받을 수 없습니다. 물론 형 변환을 수행하고 모든 것이 괜찮다고 가정할 수 있지만, 이 상황에서 정말로 타입 안전한 방법을 알고 계신가요?\n\n![How to correctly use TypeScript types for your API response](/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png)\n\n조금 더 일반적인 주제부터 시작해봅시다. 우리는 어떻게 타입을 확인할 수 있을까요? 두 가지 접근 방식이 있습니다. 정적으로 타입을 확인할 수 있습니다(컴파일 시간, 정적 분석기) 또는 런타임에서 확인할 수 있습니다.\n\n정적 타입 확인은 우리가 미리 데이터를 알고 있다는 경우에는 충분히 강력합니다. 그러나 대부분의 상황에서는 해당되지 않습니다. 데이터는 대개 API, 파일 또는 사용자 입력과 같은 소스에서 가져옵니다. 이러한 소스의 인터페이스는 문자열을 반환하며, 우리의 책임은 그것을 우리 프로그램에서 기대하는 형태로 파싱하는 것입니다.\n\n\n\n100% 유형 안전성을 위해 실행 시 데이터를 분석해야 합니다. 대부분의 유형 안전성 언어는 정적 유형 확인을 실행 시 확인과 결합합니다. 하지만 TypeScript의 경우는 어떨까요?\n\nTypeScript는 컴파일 시에만 유형을 확인합니다. JavaScritp로 컴파일된 후에는 유형에 대한 정보가 남지 않으므로 우리가 동적 데이터(예: API 응답)가 가정한 형식을 실제로 갖고 있는지 확신할 수 없습니다.\n\n# 예시 시간\n\n이러한 동작을 설명하는 가장 좋은 방법은 예시를 통해 보여주는 것입니다. 다음 예시는 API에서 데이터를 가져오는 일반적인 상황을 보여줍니다.\n\n\n\n우리가 처음에 마주한 문제는 코드 완성 기능의 부재였습니다. TypeScript를 사용하고 있기 때문에 쉽게 해결할 수 있어요. 우리가 기대하는 응답에 대한 타입을 정의해주면 되죠.\n\n이제는 타입 캐스팅을 사용하여 코드 완성기능을 사용할 수 있게 되었어요.\n\n이제 우리는 끝났다고 생각할 수 있지만, 여전히 코드를 개선할 수 있는 부분이 있습니다. fetchData 함수의 반환 타입 any는 최선의 방법이 아닙니다. 이를 Article로 변경할 수 있지만, 그렇게 하면 함수가 특정 반환 타입에 의존하게 되어버립니다. 이 경우에 이상적인 해결책은 제네릭을 사용하는 것이에요.\n\n이 방법을 통해 typecast (as Article)를 삭제할 수도 있습니다.\n\n\n\n지금 우리 코드가 멋지게 보이고 함수 fetchData를 다른 엔드포인트에도 사용할 수 있게 되었어요. 그런데 만약 API 응답이 우리 코드에 정의된 타입과 일치하지 않으면 어떻게 될까요? 우리의 타입 시스템이 그것에 대해 경고를 해줄까요? 답은 NO에요. 제가 소개에서 말했듯이, TypeScript에서 런타임에는 타입 체크가 없어요.\n\n# 런타임에서 타입을 확인하는 방법은?\n\nTS에서는 리플렉션을 지원하지 않기 때문에 수동으로 처리해야 해요. string이나 number와 같은 기본 타입을 위해서는 쉬워요. 간단한 if 문을 작성하고 끝이에요.\n\n```js\nif (typeof myVariable === 'number') {\n  // 우리 작업을 해요\n}\nif (typeof myVariable === 'string') {\n  // 우리 작업을 해요\n}\n```\n\n\n\n하지만 객체들은 훨씬 복잡합니다. 변수가 객체인지 확인하고, null을 체크하고, 각 속성에 대해 객체 내에서 존재하는지 확인하고 별도의 유형 체크를 해야 합니다.\n우리의 Article에 대한 적절한 제어는 다음과 같이 보일 것입니다.\n\n더 복잡하거나 심지어 중첩된 객체에 대해 이겨내야 한다고 상상할 수 있나요? 그걸 하기는 정말 괴로운 아이디어이고, 너무나도 오류가 발생하기 쉽습니다. 그렇다면 어떻게 하면서 다른 부분을 망치치 않을 수 있을까요?\n\n## 타입 가드\n\n한 가지 가능한 해결책은 타입 가드를 생성하는 것입니다. 타입 가드는 보통 함수들이지만 함수의 시그니처가 TS에게 함수의 매개변수가 특정 유형을 가지고 있음을 알려줍니다. 시그니처는 두 가지로 구성됩니다. 함수는 boolean을 반환해야 하며 반환 형식은 param is myType이어야 합니다.\n다음 예제는 타입 가드가 어떻게 사용되는지를 보여줍니다.\n\n\n\n이전 예제의 if 문과 마찬가지로 타입 가드의 구현을 볼 수 있습니다. 유용한 해결책은 이러한 타입 가드를 생성하는 것일 것입니다. 그러나 이것 또한 많은 단점을 가지고 있습니다. 내가 보기에, 이전 예제와 동일한 문제들 외에 가장 큰 문제는 타입 정의와의 동기화입니다.\n\n# 런타임 타입에서 TS 타입 추론하기\n\n수동 접근 방법은 널리 사용하기에는 충분히 실용적이지 않다는 것을 보았습니다. 진짜 열쇠는 typeof 연산자에 숨겨져 있습니다. 우리는 런타임 타입에서 TS 타입을 추론하는 데 이것을 사용할 수 있습니다.\n\n타입을 추론하는 기술 중 하나는 타입 가드의 사용입니다. 실제로 위의 예제에서 이를 보았습니다.\n\n\n\n두 번째로 비슷한 방법은 단언 함수를 사용하는 것입니다. 이러한 함수들은 부울 대신에 매개변수 유형이 잘못된 경우 오류를 throw합니다.\n\n이 방법의 장점 중 하나는 예외와 관련된 메시지가 있어 문제가 발생한 위치를 알 수 있다는 것입니다. 또한 함수를 호출할 때 조건을 작성할 필요가 없습니다. 그러나 그러한 함수의 반환 유형은 void 여야 하며 나중에 보게 될 것처럼 다른 것을 반환하는 것이 유용할 수 있습니다.\n\n## 기능적 접근\n\nEither를 사용하여 유형 검사 함수를 사용할 수 있습니다.\n\n\n\n이제는 이렇게 할 수도 있다는 것을 언급하고 싶어요. 이 개념에 익숙하지 않다면 걱정할 필요 없이 계속 읽어주세요.\n\n## 기본 타입에 대한 최소 구현\n\n비기능적인 방법은 예외를 사용하고 타입이 올바른 경우 입력 매개변수를 반환하는 것입니다. 기본 타입에 대한 최소 구현은 다음과 같이 보일 수 있습니다.\n\n이러한 예는 간단하며 설명이 거의 필요하지 않습니다. TypeGuard`T` 타입은 이러한 함수의 타입이며 이후의 예제에서 더 널리 사용될 것입니다.\n\n\n\n이 기능은 배열의 모든 항목이 내부 유형 가드로 강제되는지 확인합니다.\n\n여기서 보여줄 가드 중에서 가장 복잡한 것입니다. 가드 객체를 인수로 사용하여 해당 객체의 모든 속성이 올바른 유형인지 확인하는 함수를 반환합니다.\n\n## 사용법\n\n위의 함수들은 매우 간단하게 사용할 수 있습니다.\n\n\n\n일반적인 타입 정의 구문과 유사하지만 이제 우리는 런타임 세계에 저장된 타입을 가지게 되었어요. 그리고 앞서 언급했듯이 런타임에서 타입 세계로 정보를 쉽게 얻을 수 있어요. typeof 연산자를 사용하면 끝이에요.\n\n```js\ntype Article = ReturnType\u003ctypeof Article\u003e\n```\n\n타입에 동일한 이름을 사용할 수도 있어요.\n\n# 데이터를 가져오는 안전한 방법\n\n\n\n우리가 보여준 기술을 사용해서 원래 예제를 리팩토링할 수 있어요.\n\n그게 그냥 이렇게 간단해요.\n\n# 새로운 타입의 슈퍼파워\n\n타입 가드는 어떤 함수든 될 수 있어요. 이것은 당신이 원하는 대로 타입을 정의할 수 있다는 걸 의미해요. 항상 짝수인 타입을 가지고 싶다고 상상해보세요. 문제없어요. 당신의 가드만 정의하면 됩니다.\n\n\n\n여기서의 한계는 단지 당신의 상상력뿐이지만, 몇 가지 엉뚱한 유형을 만들 때 조심하는 것이 좋습니다.\n\n# 결론\n\n외부 소스로부터 데이터를 다룰 때는 해당 데이터가 올바른 유형을 가지고 있는지 100% 확신할 수 없습니다. 우리는 TypeScript 유형을 정의하고, 변수를 유형으로 캐스팅하여 모든 것이 작동할 것을 기대할 수 있습니다. 하지만 그것은 단지 희망일 뿐입니다. 우리는 런타임에서 유형을 확인할 방법이 필요하지만 TS에는 이를 위한 세련된 내장 도구가 없습니다. 수동 유형 가드를 작성할 수 있지만 많은 단점이 있습니다. 유형 정의와 유형 가드를 동기화할 필요를 없애기 위해 먼저 유형 가드를 정의하고 typeof 연산자를 사용하여 런타임 정의에서 TS 유형을 추론할 수 있습니다.\n\n# 라이브러리\n\n\n\n이 글에서 소개된 것보다 더 견고한 해결책을 찾고 있다면 다음과 같은 기능을 제공하는 몇 가지 라이브러리가 있습니다.\n\n- IO-ts - 함수형 라이브러리\n- Zod\n- Runtypes\n- 여기서 더 많은 정보를 얻을 수 있습니다.\n\n오늘 제가 가진 것은 여기까지입니다. 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png","tag":["Tech"],"readingTime":5},{"title":"Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의","description":"","date":"2024-05-14 15:12","slug":"2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy","content":"\n\n![2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png](/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png)\n\n자, 그러면 나에 대한 소소한 이야기부터 시작해볼까요? 저는 경력이 약 열 년 정도인 소프트웨어 개발자입니다. 처음에는 PHP로 일하다가 서서히 JavaScript로 전환했어요.\n\n약 다섯 년 전 TypeScript를 사용하기 시작했고, 그 이후로는 결코 JavaScript로 돌아가지 않았습니다. TypeScript를 사용하기 시작한 순간, 이 전세계에서 가장 멋진 프로그래밍 언어인 것 같다고 생각했어요. 모두가 그것을 사랑하고 사용하니까요... 정말 최고의 언어인 거 맞죠? 맞죠? 그렇죠?\n\n그런데 다른 언어들을 좀 더 현대적인 것으로 시도해보기 시작했어요. 먼저 Go를 접했고, 이어서 천천히 Rust를 목록에 추가했어요 (감사합니다, Prime).\n\n\n\n알지 못할 때 뭔가를 놓치는 것은 어렵습니다.\n\n제가 얘기하고 싶은 것은 무엇일까요? Go와 Rust가 공유하는 공통점은 무엇인가요? 오류입니다. 그것이 가장 눈에 띄는 점이었죠. 그리고 좀 더 구체적으로, 이러한 언어들이 오류를 어떻게 처리하는지에 대해서요.\n\nJavaScript는 오류를 처리하기 위해 예외를 던지는 데 의존하지만, Go와 Rust는 그것들을 값으로 취급합니다. 이게 그다지 큰 문제가 아니라고 생각할 수도 있습니다만... 하지만, 정말 그럴듯하게 들릴지도 몰라요; 하지만, 이것은 게임 체인저입니다.\n\n마주하겠습니다. 각 언어에 대해 깊게 들어가지는 않을 거에요; 일반적인 접근 방식을 알고 싶어 하는 것이죠.\n\n\n\n자바스크립트/타입스크립트와 작은 게임으로 시작해볼까요?\n\n아래 코드를 5초 동안 살펴보고, 왜 try/catch로 감싸야 하는지 답해보세요.\n\n```js\ntry {\n  const request = { name: \"test\", value: 2n };\n  const body = JSON.stringify(request);\n  const response = await fetch(\"https://example.com\", {\n    method: \"POST\",\n    body,\n  });\n  if (!response.ok) {\n    return;\n  }\n  // handle response\n} catch (e) {\n  // handle error\n  return;\n}\n```\n\n대부분의 분들이 예상한 대로, response.ok를 확인하고 있는데도 fetch 메서드가 오류를 발생시킬 수 있다는 것을 알았을 것입니다. response.ok는 4xx와 5xx 네트워크 오류만을 \"잡아내지\"요. 그러나 네트워크 자체에 문제가 발생하면 오류가 발생합니다.\n\n\n\n하지만 JSON.stringify가 오류를 던질 것이라는 것을 얼마나 많은 사람이 추측했을지 궁금하네요. 이유는 요청 객체에 bigint (2n) 변수가 포함되어 있기 때문에 JSON이 이를 문자열화하는 방법을 모른다는 점입니다.\n\n그래서 첫 번째 문제는, 개인적으로는 JavaScript 역사상 가장 큰 문제라고 생각합니다: 어떤 것이 오류를 발생시킬 수 있는지 모른다는 것입니다. JavaScript 오류 관점에서, 이는 다음과 같습니다:\n\n```js\ntry {\n  let data = \"Hello\";\n} catch (err) {\n  console.error(err);\n}\n```\n\nJavaScript는 모릅니다; JavaScript는 신경 쓰지 않습니다. 하지만 여러분은 알아야 합니다.\n\n\n\n두 번째로, 여기 완벽히 유효한 코드입니다:\n\n```js\nconst request = { name: \"test\", value: 2n };\nconst body = JSON.stringify(request);\nconst response = await fetch(\"https://example.com\", {\n  method: \"POST\",\n  body,\n});\nif (!response.ok) {\n  return;\n}\n```\n\n에러 없이, 린터도 통과하여도 여전히 앱을 망가뜨릴 수 있답니다.\n\n지금 내 머릿속에서 \"뭐가 문제니, 그냥 모든 곳에 try/catch를 사용하면 되지\"라는 목소리를 듣는 것 같아요. 여기 세 번째 문제가 나타나죠: 어떤 예외가 발생하였는지 알 수 없어요. 물론 에러 메시지를 통해 어떤 예외가 발생했는지 어느 정도는 추측할 수 있지만, 에러가 발생할 수 있는 많은 서비스/기능이 있는 큰 프로젝트라면 어떻게 할 건가요? 당신이 모든 예외 상황을 try/catch로 제대로 처리하고 있는지 확신할 수 있나요?\n\n\n\n알았어요, JS를 비난하는 걸 그만하고 다른 얘기로 넘어갈까요? 이 Go 코드로 시작해봐요:\n\n```go\nf, err := os.Open(\"filename.ext\")\nif err != nil {\n  log.Fatal(err)\n}\n// 열린 *File f로 무언가를 처리합니다\n```\n\n우리는 파일을 열어서 파일 또는 오류를 반환하려고 해요. 이걸 자주 볼 거에요, 왜냐하면 어떤 함수가 항상 오류를 반환하는지 알고 있기 때문이에요. 한 번도 놓치지 않아요. 여기서 오류를 값으로 다루는 첫 번째 예시를 볼 수 있어요. 어떤 함수가 그것들을 반환할 수 있는지 지정하고, 반환하고, 할당하고, 확인하고, 다루는거죠.\n\n그리고 이것은 그렇게 다채롭지 않다는 점도 있고, Go가 비판받는 것 중 하나인 ‘\"오류 확인 코드\"’인데요, err != nil ' … 같은 부분이 종종 나머지보다 더 많은 줄을 차지하기도 해요.\n\n\n\n```js\n만약 에러가 발생하면 {\n  …\n  만약 에러가 발생하면 {\n    …\n    만약 에러가 발생하면 {\n      … \n    }\n  } \n}\n만약 에러가 발생하면 {\n  … \n}\n…\n만약 에러가 발생하면 {\n  … \n}\n```\n\n전체 노력이 확실히 가치 있어, 믿어도 괜찮아.\n\n그리고 마지막으로, Rust:\n\n```js\nlet greeting_file_result = File::open(\"hello.txt\");\nlet greeting_file = match greeting_file_result {\n  Ok(file) =\u003e file,\n  Err(error) =\u003e panic!(\"파일 열기에 문제 발생: {:?}\", error),\n};\n```\n\n\n\n여기 세 가지 중 가장 상세하고, 기이하게도 가장 좋은 것이 있습니다. 그래서, 먼저 러스트는 놀라운 enum을 사용하여 오류를 처리합니다 (TypeScript의 enum과는 다릅니다!). 자세히 설명하지 않고 중요한 것은 두 가지 변형을 가진 Result라는 enum을 사용한다는 것입니다: Ok과 Err입니다. 상상컨대 Ok에는 값이 포함되어 있고 Err에는... 놀랍게도 오류가 포함되어 있습니다 :D.\n\nGo 문제를 완화하기 위해 더 편리하게 처리하기 위한 방법이 많이 있습니다. 가장 잘 알려진 방법 중 하나는 ? 연산자입니다.\n\n```js\nlet greeting_file_result = File::open(\"hello.txt\")?;\n```\n\n여기서 주요한 점은 Go와 Rust가 항상 어디에 오류가 발생할 수 있는지 알고 있고, 오류가 나타난 곳에서 바로 처리하도록 강제한다는 것입니다 (대부분). 숨겨진 오류나 추측, 놀란 얼굴로 앱이 깨지는 일은 없습니다.\n\n\n\n그리고 이 방법이 그냥 더 나은 거야. 아주 많이.\n\n그럼, 솔직해지는 시간이야; 난 조금 거짓말을 했어. TypeScript 오류를 Go/Rust와 같이 작동하도록 만들 수는 없어. 여기서의 제한 요인은 언어 자체야; 그 일을 수행할 적절한 도구가 없거든.\n\n하지만 우리가 할 수 있는 건 비슷하게 만들어 보려고 노력하는 거야. 그리고 간단하게 만드는 거야.\n\n이렇게 시작해 보자:\n\n\n\n```js\nexport type Safe\u003cT\u003e =\n  | {\n    success: true;\n    data: T;\n  }\n  | {\n    success: false;\n    error: string;\n  };\n```\n\n여기에는 특별한 것은 없어요. 그냥 간단한 제네릭 타입일 뿐이에요. 그러나 이 작은 아이가 코드를 완전히 바꿀 수 있어요. 아마도 알아차릴 수 있을 거예요만, 이곳에서 가장 큰 차이점은 데이터를 반환하거나 에러를 반환한다는 점이죠. 익숙해 보이나요?\n\n그리고… 또 하나의 거짓말, 우리는 몇 개의 try/catch가 필요해요. 좋은 점은 100,000이 아니라 약 두 개만 필요하다는 것이에요.\n\n```js\nexport function safe\u003cT\u003e(promise: Promise\u003cT\u003e, err?: string): Promise\u003cSafe\u003cT\u003e\u003e;\nexport function safe\u003cT\u003e(func: () =\u003e T, err?: string): Safe\u003cT\u003e;\nexport function safe\u003cT\u003e(\n  promiseOrFunc: Promise\u003cT\u003e | (() =\u003e T),\n  err?: string,\n): Promise\u003cSafe\u003cT\u003e\u003e | Safe\u003cT\u003e {\n  if (promiseOrFunc instanceof Promise) {\n    return safeAsync(promiseOrFunc, err);\n  }\n  return safeSync(promiseOrFunc, err);\n}\n\nasync function safeAsync\u003cT\u003e(\n  promise: Promise\u003cT\u003e, \n  err?: string\n): Promise\u003cSafe\u003cT\u003e\u003e {\n  try {\n    const data = await promise;\n    return { data, success: true };\n  } catch (e) {\n    console.error(e);\n    if (err !== undefined) {\n      return { success: false, error: err };\n    }\n    if (e instanceof Error) {\n      return { success: false, error: e.message };\n    }\n    return { success: false, error: \"Something went wrong\" };\n  }\n}\n\nfunction safeSync\u003cT\u003e(\n  func: () =\u003e T, \n  err?: string\n): Safe\u003cT\u003e {\n  try {\n    const data = func();\n    return { data, success: true };\n  } catch (e) {\n    console.error(e);\n    if (err !== undefined) {\n      return { success: false, error: err };\n    }\n    if (e instanceof Error) {\n      return { success: false, error: e.message };\n    }\n    return { success: false, error: \"Something went wrong\" };\n  }\n}\n```\n\n\n\n\"와우, 무슨 천재인가요. try/catch를 위한 래퍼를 만들었네요.\" 네, 맞아요; 이것은 Safe 타입을 반환하는 래퍼일 뿐입니다. 하지만 때로는 간단한 것만으로 충분할 때도 있죠. 위의 예시와 함께 결합해봅시다.\n\n예전 코드 (16 줄):\n\n```js\ntry {\n  const request = { name: \"test\", value: 2n };\n  const body = JSON.stringify(request);\n  const response = await fetch(\"https://example.com\", {\n    method: \"POST\",\n    body,\n  });\n  if (!response.ok) {\n    // 네트워크 에러 처리\n    return;\n  }\n  // 응답 처리\n} catch (e) {\n  // 에러 처리\n  return;\n}\n```\n\n새 코드 (20 줄):\n\n\n\n```js\nconst request = { name: \"test\", value: 2n };\nconst body = safe(\n  () =\u003e JSON.stringify(request),\n  \"요청을 직렬화하는 데 실패했습니다\",\n);\nif (!body.success) {\n  // 에러 처리 (body.error)\n  return;\n}\nconst response = await safe(\n  fetch(\"https://example.com\", {\n    method: \"POST\",\n    body: body.data,\n  }),\n);\nif (!response.success) {\n  // 에러 처리 (response.error)\n  return;\n}\nif (!response.data.ok) {\n  // 네트워크 에러 처리\n  return;\n}\n// 응답 처리 (body.data)\n```\n\n그래서 새롭게 제안된 솔루션은 더 길지만, 다음과 같은 이유로 성능이 우수합니다:\n\n- try/catch가 없음\n- 발생한 각 오류를 해당 위치에서 처리\n- 특정 함수에 대한 오류 메시지 지정 가능\n- 상단부터 하단까지 좋은 논리 구조, 모든 오류가 상단에 있고 가장 아래에는 응답만 있음\n\n다음의 내용을 확인하는 것을 잊을 경우 어떻게 될까요?\n\n\n\n\n```js\nif (!body.success) {\n  // 에러 처리 (body.error)\n  return;\n}\n```\n\n문제는... 우리는 그것을 할 수 없어요. 네, 그 확인을 해야 합니다. 그것을 하지 않으면 body.data가 존재하지 않을 거에요. LSP가 \"Property 'data' does not exist on type 'Safe`string`’\" 오류를 던져서 우리를 알릴 거에요. 그리고 그건 우리가 만든 간단한 Safe 타입 덕분이에요. 그리고 에러 메시지에도 작동해요. 우리는 !body.success를 확인하지 않으면 body.error에 액세스할 수 없어요.\n\n여기 TypeScript를 감사하게 생각해야 할 때예요. 그리고 이것이 적용되는 방법은 다음과 같아요:```\n\n\n\n```js\nif (!response.success) {\n  // 오류 처리 (response.error)를 핸들링하세요\n  return;\n}\n```\n\n!response.success를 제거할 수 없는 이유는 그렇게 하지 않으면 response.data가 존재하지 않을 수 있기 때문입니다.\n\n물론, 우리의 해결책에는 문제가 없지 않습니다. 가장 큰 문제는 오류를 발생시킬 수 있는 Promise/함수를 안전한 래퍼로 감싸야 한다는 것을 기억해야 한다는 점입니다. 이 \"우리가 알아야 하는\" 것은 극복할 수 없는 언어 제한입니다.\n\n어렵게 들릴 수 있지만, 실제로는 그렇지 않습니다. 곧 코딩에서 거의 모든 Promise가 오류를 발생할 수 있고 동기 함수 중에서도 그런 것을 알아보고 그 수가 많지 않다는 것을 깨닫게 될 것입니다.\n\n\n\n\n여전히 의문이 있을 수도 있겠죠? 하지만 저희는 그것이 가치가 있다고 생각해요. 저희 팀에서는 정말 잘 작동하고 있거든 :). 예를 들어, 어디에서나 try/catch가 없는 큰 서비스 파일을 본다면, 모든 오류가 발생한 곳에서 처리되고, 논리적으로 순조롭게 흘러간다면... 정말 멋지게 보이죠.\n\n여기 SvelteKit FormAction을 사용한 실제 예제가 있어요:\n\n```js\nexport const actions = {\n  createEmail: async ({ locals, request }) =\u003e {\n    const end = perf(\"CreateEmail\");\n    const form = await safe(request.formData());\n    if (!form.success) {\n      return fail(400, { error: form.error });\n    }\n    const schema = z\n      .object({\n        emailTo: z.string().email(),\n        emailName: z.string().min(1),\n        emailSubject: z.string().min(1),\n        emailHtml: z.string().min(1),\n      })\n      .safeParse({\n        emailTo: form.data.get(\"emailTo\"),\n        emailName: form.data.get(\"emailName\"),\n        emailSubject: form.data.get(\"emailSubject\"),\n        emailHtml: form.data.get(\"emailHtml\"),\n      });\n    if (!schema.success) {\n      console.error(schema.error.flatten());\n      return fail(400, { form: schema.error.flatten().fieldErrors });\n    }\n    const metadata = createMetadata(URI_GRPC, locals.user.key)\n    if (!metadata.success) {\n      return fail(400, { error: metadata.error });\n    }\n    const response = await new Promise\u003cSafe\u003cEmail__Output\u003e\u003e((res) =\u003e {\n      usersClient.createEmail(schema.data, metadata.data, grpcSafe(res));\n    });\n    if (!response.success) {\n      return fail(400, { error: response.error });\n    }\n    end();\n    return {\n      email: response.data,\n    };\n  },\n} satisfies Actions;\n```\n\n다음 사항 몇 가지를 강조해보겠어요:\n\n\n\n- 저희 사용자 정의 함수 grpcSafe는 gGRPC 콜백 처리를 돕습니다.\n- createMetadata는 Safe를 반환하므로 래핑할 필요가 없습니다.\n- zod 라이브러리도 동일한 패턴을 사용합니다 :) 스키마.success 확인을 하지 않으면 스키마.data에 접근할 수 없습니다.\n\n깔끔하게 보이지 않나요? 한번 시도해보세요! 아마도 여러분에게도 잘 맞을지도 모르겠네요 :)\n\n읽어 주셔서 감사합니다.\n\nP.S. 비슷해 보이나요?\n\n\n\n```js\nf, err := os.Open(\"filename.ext\")\nif err != nil {\n  log.Fatal(err)\n}\n// 열린 *File f를 사용해 작업을 수행합니다\n```\n\n```js\nconst response = await safe(fetch(\"https://example.com\"));\nif (!response.success) {\n  console.error(response.error);\n  return;\n}\n// response.data를 활용해 작업을 수행합니다\n```\n\n만약 마음에 드셨다면, 저의 트위터를 팔로우해주시고 공유해주시면 정말 감사하겠습니다! 제가 gRPC와 페이지로 데이터를 점진적으로 스트리밍하는 등, 잘 알려지지 않은 기술들에 대해 지식을 나누기를 원합니다. :)\n\n[트위터에서 팔로우하기](https://twitter.com/mapiorowski)","ogImage":{"url":"/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png"},"coverImage":"/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png","tag":["Tech"],"readingTime":10},{"title":"내가 좋아하는 JavaScript 짧은 코드 한 줄","description":"","date":"2024-05-14 15:11","slug":"2024-05-14-MyFavouriteJavaScriptOne-Liners","content":"\n\n\n![My Favourite JavaScript One-Liners](/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png)\n\n오늘은 다양한 코딩 과제에서 많은 도움을 받은 가장 유용하고 간단한 JavaScript 원 라이너를 여러분과 공유하고 싶어요.\n\n다음의 속임수를 사용함으로써 복잡한 함수를 프로그래밍하는 데 많은 작업을 줄일 수 있어요.\n\n그러니 이제 말이 더 필요 없죠! 함께 시작해봐요!\n\n\n\n\n# 디자인 모드\n\n일반적으로 꺼져 있는 이 기능을 활성화하면 웹사이트에서 어떤 텍스트든 선택하고 편집할 수 있습니다. 이를 통해 소스 코드를 변경하지 않고도 빠르게 다양한 텍스트나 단어를 시도해 볼 수 있습니다.\n\n이 기능을 활성화하려면 아래 코드만 필요합니다:\n\n```js\ndocument.designMode = \"on\"\n```\n\n\n\n# 배열 병합\n\n```js\nconst merge = [...array1, ...array2];\n```\n\n이 코드 스니펫은 JavaScript의 전개 구문을 활용하여 두 배열의 내용을 매끄럽게 병합합니다. 각 배열의 요소를 대괄호 안에 펼쳐서 새로운 배열을 만들어 두 소스 배열의 모든 요소를 포함시킵니다.\n\n이 간결한 접근 방식은 원본 배열을 변형시키지 않고 배열을 결합하는 과정을 간단하게 만들어 줍니다.\n\n\n\n중복을 피하고 각 요소가 한 번만 존재하도록 하려면 Set() 메서드를 사용하십시오:\n\n```js\nconst merge = [...new Set([...array1, ...array2])];\n```\n\n# 랜덤 Hex 색상 생성\n\n다음 코드는 16진수 코드로 랜덤 색상을 생성합니다. 이는 데이터 시각화나 동적 콘텐츠 생성 시 매우 유용합니다.\n\n\n\n```js\nconst randomHexColor = '#' + Math.floor(Math.random() * 16777215).toString(16);\n```\n\n# 클립보드에 복사\n\n선택된 웹사이트의 일부를 클립보드에 복사할 수 있습니다.\n\n```js\ndocument.execCommand('copy');\n```\n\n\n\n자바스크립트를 사용하여 텍스트를 클립보드에 복사하는 방법은 클립보드 API를 사용하는 것입니다. 간단한 예제를 보여드리겠습니다:\n\n```js\nfunction copyToClipboard(text) {\n  const textarea = document.createElement('textarea');\n  textarea.value = text;\n  document.body.appendChild(textarea);\n  textarea.select();\n  document.execCommand('copy');\n  document.body.removeChild(textarea);\n}\n\n// 사용 예시:\nconst textToCopy = \"안녕하세요, 세상!\";\ncopyToClipboard(textToCopy);\n```\n\n- copyToClipboard 함수는 임시 텍스트영역 요소를 생성하여 해당 값으로 설정하고, 문서 바디에 추가한 뒤 해당 내용을 선택하고, 복사 명령을 실행하여 마지막으로 DOM에서 텍스트영역 요소를 제거합니다.\n- \"안녕하세요, 세상!\"을 복사할 텍스트로 교체해주세요.\n\n```\nconsole.table\n```\n\n\n\n이 함수는 특히 대량 데이터의 콘솔 출력을 용이하게 합니다. console.log()에 비해 데이터를 표로 표시하여 더 명확한 대안을 제공합니다.\n\n```js\nconst data = [\n  { name: 'John', age: 30, city: 'New York' },\n  { name: 'Alice', age: 25, city: 'Los Angeles' },\n  { name: 'Bob', age: 35, city: 'Chicago' }\n];\n\nconsole.table(data);\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_1.png\" /\u003e\n\n이 게시물이 여러분의 문제 중 일부를 해결하고 즐겁게 읽으셨기를 바랍니다! 여러분의 가장 좋아하는 JavaScript 원라이너가 무엇인지 댓글로 알려주세요.\n\n\n\n가장 최신 컨텐츠를 받아보려면 구독을 잊지마세요! 👍\n\n코딩 즐기세요! 🚀","ogImage":{"url":"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png"},"coverImage":"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png","tag":["Tech"],"readingTime":3},{"title":"LWC에서 구성 요소 간 통신","description":"","date":"2024-05-14 15:09","slug":"2024-05-14-ComponentCommunicationinLWC","content":"\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png)\n\n이 주제에서는 LWC 컴포넌트가 서로 통신하는 방법을 다룰 것입니다.\n\n컴포넌트 간에 통신하는 네 가지 방법이 있습니다.\n\n- 부모에서 자식으로의 통신\n- 자식에서 부모로의 통신\n- Pub-Sub 모델을 사용한 독립형 컴포넌트 간 통신 (구식 기술)\n- 교차 프레임워크 (VF 페이지, Aura 및 라이트닝 메시징 서비스를 사용한 LWC 간 통신)\n\n\n\n# 부모 자식간 통신\n\n부모 자식 간 통신을 하려면 아래 단계를 따라하세요.\n\n- 컴포넌트 구성을 만듭니다. 부모 클래스에서 `c-component-communication-child`와 같은 자식 컴포넌트에 액세스할 수 있습니다.\n- 자식 컴포넌트에서 부모 데이터를 보관할 public 속성을 만들어야 합니다.\n- public 속성을 만들기 위해 @api 데코레이터를 사용하십시오.\n- 부모 컴포넌트에서 자식 컴포넌트의 public 속성을 정의하려면 하이픈(-) 부호를 사용합니다. 예를 들어, 자식 컴포넌트에 @api userDetails가 있다면 부모 컴포넌트에 user-details와 같이 작성해야 합니다.\n\n## 부모에서 자식으로 통신하는 방법이 4가지 있습니다.\n\n\n\nA. 자식에게 기본 데이터 전달\nB. 자식에게 비 기본 데이터 전달\nC. 작업 이벤트에서 자식에게 데이터 전달\nD. 자식 메서드를 부모에서 호출\n\n자식에게 기본 데이터 전달\n--- --- --- --- --- --- --- ---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_1.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_2.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_3.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_4.png)\n\n\n\n\n결과\n\n\u003cimg src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_5.png\" /\u003e\n\n## 자식에게 비 기본 데이터 전달\n\n---\n\n\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_6.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_7.png)\n\n자식 컴포넌트\n\n\n\n\n![Component Communication in LWC - Step 8](/assets/img/2024-05-14-ComponentCommunicationinLWC_8.png)\n\n![Component Communication in LWC - Step 9](/assets/img/2024-05-14-ComponentCommunicationinLWC_9.png)\n\n### Result\n\n![Component Communication in LWC - Step 10](/assets/img/2024-05-14-ComponentCommunicationinLWC_10.png)\n\n\n\n\n## 액션 이벤트 발생 시 자식에 데이터 전달\n\n---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_11.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_12.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_13.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_14.png)\n\n\n\n\n결과\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*YiKgaCBRXqveyetchoFM8A.gif\" /\u003e\n\n## 부모에게 자식 메서드 호출하기\n\n---\n\n\n\n이 코드를 사용하면 querySelector 매개변수에 자식 컴포넌트 이름을 전달하여 자식 컴포넌트 메서드를 호출할 수 있습니다.\n예시: this.template.querySelector('c-component-communication-child').childMethod().\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_15.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_16.png)\n\n\n\nChild Component\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_17.png)\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_18.png)\n\nResult\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TkpNP-vozpdAfIjKnElUeA.gif)\n\n# 자식에서 부모로 통신하기\n\n자식에서 부모로 통신하려면 사용자 지정 이벤트를 사용하고 해당 이벤트를 발송해야 합니다. 하지만 사용자 지정 이벤트로 넘어가기 전에 먼저 이벤트가 무엇인지 알아보겠습니다.\n\n이벤트란 무엇인가?\nJS와 HTML의 상호 작용은 모두 이벤트를 통해 처리됩니다. 사용자나 브라우저가 페이지를 조작하려고 할 때 해당 페이지가 로드될 때 이를 이벤트라고 합니다. 모든 이벤트는 'on' 키워드로 시작합니다.\n\n\n\n\n예를 들어, onclick, onchange, onkeyup 등.\n\n## 커스텀 이벤트 생성 및 발송\n\n커스텀 이벤트를 생성하려면 CustomEvent() 생성자를 사용하세요. 이 생성자에는 이벤트 유형을 나타내는 문자열이 필수 매개변수로 전달되어야 합니다.\n\n커스텀 이벤트를 발송하려면 EventTarget.dispatchEvent()를 사용하세요. LWC에서 EventTarget는 this를 의미합니다.\n\n\n\n부모 컴포넌트\n\n![이미지1](/assets/img/2024-05-14-ComponentCommunicationinLWC_19.png)\n\n![이미지2](/assets/img/2024-05-14-ComponentCommunicationinLWC_20.png)\n\n자식 컴포넌트\n\n\n\n\n![Screenshot 1](/assets/img/2024-05-14-ComponentCommunicationinLWC_21.png)\n\n![Screenshot 2](/assets/img/2024-05-14-ComponentCommunicationinLWC_22.png)\n\nResult\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*4gUjy7HDpHBU0m-ucNilTQ.gif)\n\n\n\n\n# Pub-Sub 모델을 사용한 독립 구성 요소 간 통신\n\n두 개의 독립 구성 요소 간의 통신을 위해 두 가지 기술인 1) Pub-Sub 모델과 2) 라이트닝 메시지 서비스(LMS)를 사용합니다.\n\n이 주제에서는 Pub-Sub 모델을 사용하여 독립 구성 요소 간 통신하는 방법을 배워 보겠습니다.\n\n먼저, 원하는 이름으로 컴포넌트를 만들어야 합니다. 저는 pubsub이라는 이름을 사용했습니다.\n해당 컴포넌트에는 아래 코드를 js 파일에 붙여넣으십시오.\n\n\n\n```js\n/* eslint-disable no-console */\nconst store = {};\n/**\n * 이벤트에 대한 콜백 함수를 구독합니다.\n * @param {string} eventName - 청취할 이벤트의 이름.\n * @param {function} callback - 해당 이벤트가 발생했을 때 호출할 함수.\n */\n\nconst subscribe = (eventName, callback) =\u003e {\n    if (!store[eventName]) {\n        store[eventName] = new Set();\n    }\n    store[eventName].add(callback);\n};\n\n/**\n * 이벤트에 대한 콜백 함수 구독을 취소합니다.\n * @param {string} eventName - 구독을 취소할 이벤트의 이름.\n * @param {function} callback - 구독을 취소할 함수.\n */\nconst unsubscribe = (eventName, callback) =\u003e {\n    if (store[eventName]) {\n        store[eventName].delete(callback);\n    }\n};\n\n/**\n * 청취자에게 이벤트를 발행합니다.\n * @param {string} eventName - 발행할 이벤트의 이름.\n * @param {*} payload - 발행할 이벤트의 페이로드.\n */\n\nconst publish = (eventName, payload) =\u003e {\n    if (store[eventName]) {\n        store[eventName].forEach(callback =\u003e {\n            try {\n                callback(payload);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n};\n\nexport default {\n    subscribe,\n    unsubscribe,\n    publish\n};\n```\n\n위의 코드에서 두 개의 매개변수를 보유하는 세 개의 Const 변수가 있습니다. 첫 번째는 eventName이고 두 번째는 콜백 메서드입니다.\n\nPubSubComp_A\n\n![ComponentCommunicationinLWC_23](/assets/img/2024-05-14-ComponentCommunicationinLWC_23.png)\n\n\n\n\n\n![PubSubComp_B](/assets/img/2024-05-14-ComponentCommunicationinLWC_25.png)\n\n![Image](/assets/img/2024-05-14-ComponentCommunicationinLWC_26.png)\n\n\n\n\n결과\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*50ZgsP84cx1CGezDS_iu6A.gif)","ogImage":{"url":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png","tag":["Tech"],"readingTime":6},{"title":"Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입","description":"","date":"2024-05-14 15:07","slug":"2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection","content":"\n\nVueJS를 사용하면 반응형 컴포넌트, 함수, 라이브러리 및 플러그인을 효율적으로 재사용할 수 있습니다. 이러한 기능들은 VueJS의 한 가지 우아하고 강력한 API 중 하나인 의존성 주입을 활용합니다.\n\n의존성 주입을 통해 부모 컴포넌트에서 후손 컴포넌트로 효율적인 로직 재사용이 가능하며, 프롭 전달에 대한 고민을 없애줍니다. 부모 컴포넌트에서 API로부터 데이터를 가져와 이 데이터를 계층 구조 내의 여러 하위 컴포넌트로 전송해야 하는 시나리오를 고려해 보세요. 이러한 하위 컴포넌트들은 부모로부터 전달된 데이터에 의존하여 정보를 렌더링합니다. 기존에는 모든 하위 컴포넌트에 데이터를 전달했을 것입니다. 데이터가 필요하지 않은 하위 컴포넌트에게까지 말이죠.\n\n이는 특정 컴포넌트로 무관한 데이터의 전달을 포함하는 프롭 드릴링(Prop Drilling)으로 이어질 수 있습니다.\n\n![image](/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png)\n\n\n\n이 접근 방식은 불필요한 구성 요소에 영향을 미치며, 우리가 깊이 파고들수록 유지 보수가 복잡해질 수 있습니다. 이러한 종류의 로직을 다루는 것은 부담스럽고 역생산적일 수 있습니다. 그러나 의존성 주입을 활용하면 이러한 어려움을 완전히 우회할 수 있습니다.\n\nVueJS 3 Composition API에서 의존성 주입을 구현하는 방법을 살펴보겠습니다. 우리는 이를 통해 VueJS 애플리케이션 내에서 모듈성을 보장하기 위해 그것을 활용하는 다양한 방법을 살펴볼 것입니다. 이를 설명하기 위해 샘플 사용 사례를 살펴볼 것입니다.\n\n## 예시\n\nVueJS 앱을 만들어보겠습니다. 가이드를 따라 VueJS 앱을 만들 수 있습니다.\n\n\n\n전제 조건\n\n- 명령줄에 익숙하신 분\n- Node.js 버전 16.0 이상 설치\n\nVue.js를 설정하고 모든 준비가 완료되었다고 가정하고 진행할 수 있습니다.\n\n## 앱 수준 종속성 주입\n\n\n\n앱 레벨 의존성 주입은 주입된 프로바이더를 렌더링된 앱 내 모든 컴포넌트에서 접근할 수 있도록 보장합니다. 주입될 프로바이더는 애플리케이션 상수, 변수, 핸들러 함수 등이 될 수 있습니다. 이러한 프로바이더는 자식이든 부모이든 관계없이 컴포넌트 계층 구조 어디에서든 사용할 수 있습니다.\n\n프로바이더는 두 개의 매개변수를 사용하여 선언됩니다. provide의 첫 번째 매개변수는 provide의 이름을 나타내며 문자열이어야 합니다. 두 번째 매개변수는 값을 정의합니다. 프로바이더가 여러 값을 하나의 프로바이더 이름 아래 캡슐화해야 할 때 객체도 받을 수 있다는 것을 명심하세요.\n\n현재 날짜를 제공하여 프로젝트 내에서 렌더링된 컴포넌트 어디에서나 편리하게 액세스하고 재사용할 수 있게 하려는 시나리오를 고려해보세요.\n\n프로젝트 설정 중 JavaScript 또는 TypeScript를 선택한 경우 main.js 또는 main.ts 파일로 이동하세요.\n\n\n\n위의 코드 스니펫에서는 날짜 변수의 값을 할당한 날짜를 제공합니다.\n\n## 구성 요소에서 제공된 항목에 액세스\n\n애플리케이션의 렌더링된 모든 구성 요소 내에서, 우리는 inject 함수를 활용하고 제공의 이름을 매개변수로 전달하여 날짜에 액세스할 수 있습니다.\n\n## 제공을 통해 도우미 함수 전달하기\n\n\n\n가정해 봅시다. 저희 애플리케이션에서 다양한 컴포넌트에서 제공하고 사용할 수 있는 헬퍼 함수가 있다고 합시다. 핸들러 함수를 가지고 제공으로 전달할 수도 있고 필요할 때마다 이를 액세스할 수 있습니다.\n\n우리의 사용 사례 시나리오를 수정해 봅시다. 우리 애플리케이션의 특정 컴포넌트에서 상대 시간을 표시하려고 합니다. 이를 위해 formatDateTimeWithRelativeTime 함수를 정의할 것입니다. 이 함수는 입력으로 날짜 문자열을 받아 그 날짜의 상대 시간을 현재 날짜 및 시간과 비교하여 결정합니다.\n\n이 함수를 날짜 제공 프로바이더로 제공하여 렌더링된 컴포넌트 내에서 액세스할 수 있도록 할 것입니다.\n\n렌더링된 컴포넌트 내에서 함수에 액세스하고 활용하는 것은 다른 함수와 동일하게 간단합니다. 특히 이 특정 시나리오에서는 아래 코드 스니펫에 표시된 대로 이를 관리할 수 있습니다.\n\n\n\n## 기본값 및 유연성\n\n우리가 제공되는 값이 없을 때 기본값을 제공하고 싶은 경우, 두 번째 매개변수를 제공하여 기본값으로 작용하게 할 수 있습니다. 즉,\n\n```js\n\u003cscript setup lang=\"ts\"\u003e\nimport { inject } from 'vue';\n\nconst date = inject('dates', \"20230812T144718\");\n\n//'20230812T144718'는 'dates' 제공자가 존재하지 않을 때 기본 날짜입니다.\n\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cmain\u003e\n    \u003cdiv\u003e\n      \u003cp\u003e의존성 주입\u003c/p\u003e\n      \u003cp\u003e날짜는 { date }입니다.\u003c/p\u003e\n    \u003c/div\u003e\n  \u003c/main\u003e\n\u003c/template\u003e\n```\n\n## 반응성과 유지보수\n\n\n\n사용자를 대상으로 하는 애플리케이션에서 값 제공을 위해 동적 업데이트가 필요할 수 있습니다. 이를 달성하기 위해서는 반응성이 우리를 이끌어 컴포넌트를 전략적으로 업데이트하고, 최적의 유지보수를 위해 관련 코드를 중앙집중화해야 합니다. 이 방식은 코드 관리를 간소화합니다.\n\nReactive provide/inject 값을 사용할 때 변경 사항을 가능한 한 제공자 내의 반응형 상태로 제한하는 것이 좋습니다. 이 실천은 제공된 상태와 잠재적인 변경 사항이 동일한 컴포넌트에 존재하도록 보장하여, 향후 유지보수를 간소화합니다.\n\n이 안내서에서 사용된 코드는 GitHub에서 찾을 수 있습니다.\n\n## 자원\n\n\n\n- https://vuejs.org/api/composition-api-dependency-injection.html\n- https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject\n\n## 결론\n\n의존성 주입은 특히 다른 대안들을 사용했을 때 prop 드릴링이 발생할 수 있는 시나리오에서 매우 유용합니다. 이 메커니즘을 통해 애플리케이션 전체에서 접근 가능해야 하는 중요한 기능, 변수 및 상수를 중앙 집중화하고, 중복을 제거하여 한 번만 포함시킴으로써 효율을 높일 수 있습니다.\n\n이 가이드를 따라 주셔서 감사합니다. 다른 사람들과 공유해주시면 감사하겠습니다. 궁금한 사항, 제안 사항이 있거나 단순히 이야기를 나누고 싶다면, X에서 @amjohnphilip과 연락하십시오. 귀하의 참여를 환영합니다!\n\n\n\n## 더 많은 읽을거리\n\n# 쉬운 영어로\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려해 주시고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾으실 수 있습니다. 🚀\n- 무료 주간 뉴스레터에 가입해 주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png"},"coverImage":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png","tag":["Tech"],"readingTime":4},{"title":"웹을 더 접근성 있게 만들기 메뉴와 로더","description":"","date":"2024-05-14 15:03","slug":"2024-05-14-Makingthewebmoreaccessiblemenusandloaders","content":"\n\n웹 애플리케이션을 개발할 때 종종 접근성이 간과되곤 합니다. 하지만 이는 인터넷을 더 포용적인 공간으로 만드는 데 큰 도움이 됩니다.\n\n대부분의 개발자들은 특히 처음 시작할 때 접근성에 집중하지 않는데, 접근성과 관련된 매우 기본적인 인터뷰 질문을 클리어하는 데 주로 관심을 가집니다.\n\n그러므로 시작해 보겠습니다. 웹에서 자주 마주치는 아주 흔한 시나리오를 살펴보겠습니다:\n\n- 메뉴 열기\n- 항목 클릭\n- 클릭한 항목이 로드될 때 까지 기다리기\n\n\n\n접근성을 생각할 때, 이 행동을 웹사이트를 사용하는 사람의 관점에서 더 자세히 살펴봅니다. 예를 들어 사용자는 메뉴와 메뉴 항목에 대해 상호작용하는 것을 알아야 하며, 메뉴에 몇 개의 항목이 있는지 알아야 하며, 항목에 다른 하위 메뉴가 있는지 등을 알아야 합니다.\n\n사용 사례 및 UI 상호작용의 복잡성에 따라 단계가 더욱 세심해질 수 있습니다.\n\n## 메뉴 만들기\n\n메뉴를 만들기 위해 먼저 로컬 HTML 파일에 다음의 시작 코드를 복사하여 붙여넣을 수 있습니다:\n\n\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\" /\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n  \u003ctitle\u003e문서\u003c/title\u003e\n  \u003cstyle\u003e\n    body {\n      margin: 0 auto;\n    }\n\n    .navbar {\n      display: flex;\n      background-color: #ccc;\n      font-family: Arial;\n    }\n\n    .navbar\u003eul {\n      list-style: none;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin: 0;\n      padding: 10px;\n      width: 100%;\n    }\n\n    .navbar li {\n      font-size: 16px;\n      color: black;\n      text-align: center;\n      padding: 10px;\n      border-radius: 5px;\n      text-decoration: none;\n    }\n\n    .dropdown {\n      overflow: hidden;\n    }\n\n    .dropdown .dropbtn {\n      font-size: 16px;\n      border: none;\n      color: black;\n      background-color: inherit;\n      font-family: inherit;\n      margin: 0;\n    }\n\n    .navbar li:hover,\n    .dropdown:hover .dropbtn {\n      background-color: #e6e6e6;\n    }\n\n    .navbar .dropdown-content {\n      display: none;\n      position: absolute;\n      background-color: #f9f9f9;\n      box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\n      z-index: 1;\n    }\n\n    .dropdown-content li {\n      color: black;\n      text-decoration: none;\n      display: block;\n      text-align: left;\n    }\n\n    .dropdown-content li:hover {\n      background-color: #ddd;\n    }\n\n    .dropdown:hover .dropdown-content {\n      display: flex;\n      flex-direction: column;\n      padding: 10px;\n    }\n\n    .loader-wrapper {\n      display: none;\n    }\n\n    .content-wrapper .show-loader-wrapper {\n      display: block;\n      margin: 0 auto;\n      margin-top: 200px;\n      text-align: center;\n    }\n\n    .loader {\n      border: 16px solid #f3f3f3;\n      margin: 0 auto;\n      border-top: 16px solid #3498db;\n      border-radius: 50%;\n      width: 120px;\n      height: 120px;\n      animation: spin 2s linear infinite;\n    }\n\n    @keyframes spin {\n      0% {\n        transform: rotate(0deg);\n      }\n\n      100% {\n        transform: rotate(360deg);\n      }\n    }\n  \u003c/style\u003e\n  \u003cscript\u003e\n    function doSomething() {\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() =\u003e {\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        document.querySelector('.loader-progress').innerHTML = `${timer} %`;\n      }, 400);\n\n    }\n  \u003c/script\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cmain class=\"content-wrapper\"\u003e\n    \u003cnav class=\"navbar\"\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca onclick=\"doSomething()\"\u003e홈\u003c/a\u003e\u003c/li\u003e\n        \u003cli class=\"dropdown\"\u003e\n          \u003cdiv class=\"dropbtn\"\u003e\n            드롭다운\n            \u003ci class=\"fa fa-caret-down\"\u003e\u003c/i\u003e\n          \u003c/div\u003e\n          \u003cul class=\"dropdown-content\"\u003e\n            \u003cli\u003e\u003ca onclick=\"doSomething()\"\u003e링크 1\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca onclick=\"doSomething()\"\u003e링크 2\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca onclick=\"doSomething()\"\u003e링크 3\u003c/a\u003e\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\u003ca onclick=\"doSomething()\"\u003e뉴스\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/nav\u003e\n    \u003cdiv class=\"loader-wrapper\" id=\"main-loader\"\u003e\n      \u003cdiv class=\"loader\"\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"loader-progress-container\"\u003e로딩 중 \u003cspan class=\"loader-progress\"\u003e\u003c/span\u003e\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/main\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\n\n자, 이제 우리는 이를 접근성 있게 만드는 방법은 무엇인가요?\n\n## 내비게이션 메뉴를 접근성 있게 만드는 방법\n\n우리는 사용자들이 마우스나 다른 포인터 장치를 사용하지 못하거나 서로 다른 색상을 구별하지 못하는 등의 다양한 도전에 직면할 수 있음을 고려해야 합니다.\n\n이는 예를 들어 학술 환경에서 사용되는 웹사이트를 만드는 경우 특히 중요해집니다. 거기에는 기술을 사용할 때 다양한 도전에 직면하는 많은 사용자들이 있을 수 있기 때문입니다.\n\n\n\n현재 상태에서 네브바를 확인해 보겠습니다. 먼저 고려사항 중 하나인 마우스나 다른 포인터 장치를 사용하지 않고 네비게이션을 하는 것을 검증할 겁니다.\n\n이를 위해 Tab 키를 사용하여 페이지의 다음 항목으로 이동하고 Shift + Tab 키를 사용하여 이전 항목으로 이동할 것입니다.\n\n우리 웹페이지에서 시도해 보겠습니다. 페이지의 빈 영역을 클릭한 후 Tab 키를 눌러주세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*JwlfxSNzMs_IYp2zWhG9wQ.gif)\n\n\n\n당신은 메뉴를 탭 키로 전혀 탐색할 수 없다는 것을 알게 될 거에요. 우리가 모든 것을 올바르게 했음에도 불구하고요.\n\n키보드 탐색에 관해서, 일부 요소는 브라우저에 의해 0으로 설정된 tabindex가 자동으로 할당됩니다.\n\n버튼, 입력 필드, 선택 상자, 텍스트 영역과 같은 익숙한 요소 몇 가지는 이렇게 자동으로 할당됩니다. 그리고 앵커 태그도요.\n\n하지만, 앵커 태그를 사용하는 우리도 똑같죠?\n\n\n\n앵커 태그에 연결된 href가 없는 경우 tabindex가 자동으로 할당되지 않습니다.\n\n\"Home\" 목록 항목에 href를 연결하고 확인해보세요:\n\n```js\n\u003cli\u003e\u003ca onclick=\"doSomething()\" href=\"#\"\u003eHome\u003c/a\u003e\u003c/li\u003e\n```\n\n위와 같은 결과를 확인할 수 있어야 합니다. \"Home\" 버튼은 이제 Tab 키를 눌러 접근할 수 있을 것입니다. 외곽선은 중요하며 곧 볼 대비 기준이 있을 것입니다:\n\n\n\n다른 옵션은 모든 앵커 태그를 버튼으로 변환하는 것입니다. 실제 링크로 이동하는 대신 함수를 호출하고 있으므로 지금 그렇게 하겠습니다.\n\n```js\n\u003cbody\u003e\n  \u003cmain class=\"content-wrapper\"\u003e\n    \u003cnav class=\"navbar\"\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003cbutton onclick=\"doSomething()\" href=\"#\"\u003e홈\u003c/button\u003e\u003c/li\u003e\n        \u003cli class=\"dropdown\"\u003e\n          \u003cdiv class=\"dropbtn\"\u003e\n            \u003cbutton\u003e드롭다운\u003c/button\u003e\n            \u003ci class=\"fa fa-caret-down\"\u003e\u003c/i\u003e\n          \u003c/div\u003e\n          \u003cul class=\"dropdown-content\"\u003e\n            \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e링크 1\u003c/button\u003e\u003c/li\u003e\n            \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e링크 2\u003c/button\u003e\u003c/li\u003e\n            \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e링크 3\u003c/button\u003e\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e뉴스\u003c/button\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/nav\u003e\n    \u003cdiv class=\"loader-wrapper\" id=\"main-loader\"\u003e\n      \u003cdiv class=\"loader\"\u003e\n      \u003c/div\u003e\n      \u003cdiv class=\"loader-progress-container\"\u003e로딩 중 \u003cspan class=\"loader-progress\"\u003e\u003c/span\u003e\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/main\u003e\n\u003c/body\u003e\n```\n\n그러면 키보드의 Tab 키를 통해 네비게이션 바의 각 항목을 \"탭할 수 있는\" 상태로 만드는 페이지가 나올 것입니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*nQaPuP3mAFVyx63sB4DxtA.gif\" /\u003e\n\n\n\n하지만 버튼들이 조금 못생겼죠? 기본 CSS를 사용하여 이를 수정해 봅시다. 다음 스타일을 추가하여 버튼을 스타일링하세요:\n\n```js\n.navbar button {\n  background: #e6e6e6;\n  border: none;\n  padding: 10px;\n  border-radius: 5px;\n}\n```\n\n좋아요! 이제 \"Dropdown\" 옵션의 하위 메뉴를 키보드로 접근할 수 있도록 만들어 봅시다.\n\n## 키보드로 중첩된 메뉴에 액세스하기\n\n\n\n지금은 \"Dropdown\" 옵션으로 탭을 이동해도 메뉴가 열리지 않는 문제가 있습니다. 심지어 \"Enter\" 키를 눌러도 열리지 않습니다. 이는 하위 메뉴의 가시성을 css로 제어하고 있기 때문입니다. \n\n이 문제를 해결하기 위해 Dropdown으로 탭을 이동하면 사용자가 Enter 키와 같은 키를 눌러서 하위 메뉴를 열 수 있어야 합니다. \"Dropdown\" 버튼에 추가된 onclick을 주목해주세요:\n\n```js\n\u003cli class=\"dropdown\"\u003e\n  \u003cdiv class=\"dropbtn\"\u003e\n    \u003cbutton onclick=\"openSubmenu()\"\u003eDropdown\u003c/button\u003e\n    \u003ci class=\"fa fa-caret-down\"\u003e\u003c/i\u003e\n  \u003c/div\u003e\n  \u003cul class=\"dropdown-content\"\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003eLink 1\u003c/button\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003eLink 2\u003c/button\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003eLink 3\u003c/button\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/li\u003e\n```\n\n이제 스크립트 태그에 \"openSubmenu\" 함수를 추가하여 하위 메뉴에 클래스를 추가하고 그 표시 속성을 설정합니다.\n\n\n\n```js\n\u003cscript\u003e\n  function doSomething() {\n    console.log('로더가 활성화됐어요');\n    document.getElementById('main-loader').classList.add('show-loader-wrapper');\n    let timer = 0;\n    const timerInterval = setInterval(() =\u003e {\n      if (timer === 99) {\n        clearInterval(timerInterval);\n      }\n      timer += 1;\n      document.querySelector('.loader-progress').innerHTML = `${timer} %`;\n    }, 400);\n\n  }\n\n  // 새로 추가된 기능\n  function openSubmenu() {\n    console.log('서브메뉴 열기');\n    const submenu = document.querySelector('.dropdown-content');\n    submenu.classList.add('show-submenu');\n    submenu.getElementsByTagName('button')[0].focus();\n  }\n\u003c/script\u003e\n```\n\n그런 다음, 이 클래스에 hover 효과와 동일한 스타일 속성을 부여하기 위해 기존 스타일에 클래스 이름을 추가하여 CSS 선택기를 사용하십시오:\n\n```css\n.dropdown:hover .dropdown-content,\n.navbar .dropdown-content.show-submenu {\n  display: flex;\n  flex-direction: column;\n  padding: 10px;\n}\n```\n\n이후에는 키보드로 하위 메뉴에 접근할 수 있게 됩니다. 사용자가 Enter 키를 누르면 \"openSubmenu()\" 함수에서 다음 줄 때문에 자동으로 포커스가 서브메뉴의 첫 번째 항목으로 이동할 것입니다:\n\n\n\n\n```js\nsubmenu.getElementsByTagName('button')[0].focus();\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*VecBx6iFQ-moyNqkwEOAfw.gif)\n\n지금까지 페이지를 키보드나 보조 기술 장치를 통해 액세스할 수 있게 했습니다. 사용자가 페이지의 요소들 사이를 이동할 수 있는 키를 제공할 수 있는 장치입니다.\n\n이제 사용자가 페이지의 요소들을 적절하게 구별할 수 있게하는 방법에 대해 이야기해 보겠습니다.\n\n\n\n## 웹 페이지의 접근성을 높이는 대비의 역할\n\n요소 색상과 음영 사이의 효과적인 대비를 정의하는 몇 가지 지침을 제시했습니다. 이 대비 체커와 같은 유용한 사이트를 사용하여 당사의 버튼 및 내비게이션 바가 이 기준을 충족하는지 확인해 봅시다.\n\n우리의 내비게이션 바의 색상 코드는 #ccc이며, 버튼의 색상은 #e6e6e6입니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png)\n\n\n\n이 문맥에서 \"그래픽 개체 및 사용자 인터페이스 구성요소\"에 주의를 기울입니다. WCAG AA에도 실패하는 것을 볼 수 있습니다. 접근성의 최소 수준이어야 하는데요. 같은 도구를 사용하여 이 기준을 충족하는 더 유용한 쉐이드를 찾아봅시다. WCAG는 그러한 요소에 대해 최소 3대 1의 대조 비를 요구합니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_1.png)\n\n버튼과 탐색 막대를 비교하고 있으니, 지금은 스크린샷의 마지막 기준에만 신경 쓰겠습니다. 이제 버튼의 배경을 업데이트해봅시다.\n\n```css\n.navbar button {\n      background: #6e6e6e;\n      border: none;\n      padding: 10px;\n      border-radius: 5px;\n}\n```\n\n\n\n이제 또 다른 문제에 부딪히게 되었어요. 우리의 네비게이션 바는 이렇게 보입니다:\n\n![Navbar](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_2.png)\n\n텍스트가 버튼의 배경과 거의 구분되지 않아요. 다시 대비 확인 도구를 사용해서 텍스트에 어울리는 색상을 선택해 볼까요:\n\n![대비 확인](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_3.png)\n\n\n\n우리는 WCAG AAA 지원의 높은 기준을 충족하기 위해 버튼을 약간 어둡게 만들고 버튼 텍스트를 흰색 (#fff)으로 바꿔야 할 것입니다. 이전에 정의한 다음 스타일을 찾아서 아래와 같이 색 속성을 업데이트해 주세요:\n\n```js\n.navbar button {\n      background: #595959;\n      color: #fff;\n      border: none;\n      padding: 10px;\n      border-radius: 5px;\n}\n```\n\n동시에 키보드로 탭을 눌러 버튼 아웃라인도 강조합니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_4.png)\n\n\n\n기본 아웃라인의 색상과 스타일을 변경하여 대비 기준을 충족시키는 방법에 대해 생각해 보는 것은 연습으로 남겨두겠습니다.\n\n# 우리의 메뉴는 정말로 접근성이 확보되었을까요?\n\n다음 단계에서는 화면 낭독기와 같은 보조 기술과 호환될 수 있도록 메뉴를 확인해야 합니다.\n\n## 설정\n\n\n\n웹 접근성을 고려해 코딩할 때, 스크린 리더와 같은 접근성 도구를 사용하여 테스트하는 것이 좋습니다. 데스크탑에서는 Windows 전용인 무료 NVDA를 사용할 수 있습니다.\n\n맥북에는 내장된 Apple VoiceOver가 함께 제공됩니다. command + f5를 눌러 시작/중지할 수 있어요.\n\nGoogle 확장 프로그램인 Chrome Vox도 사용 가능하지만, 제 경험에 따르면 다소 어색하게 느껴집니다.\n\n불행히도, 이 블로그에 스크린 리더 비디오를 직접 첨부할 수 없습니다. 그래서 시스템의 VoiceOver 프롬프트를 사용할 거예요. 그것들도 화면 리더에 의해 말해진 내용을 보여줍니다.\n\n\n\n시스템에 NVDA를 설치하거나 보이스오버를 사용하여 다음 단계를 따를 수 있어요. 화면 낭독기는 콘텐츠를 읽는 방식이 약간 다를 수 있지만, 사용자에게 웹사이트에 대한 기본적인 이해를 제공할 수 있어야 해요.\n\n## 구현 방법\n\n이제 화면 낭독기를 시작한 후에 페이지로 탭을 이동하면 화면 낭독기가 \"홈 버튼, 3개 항목이 있는 목록\"과 같은 내용을 말해줄 거예요. 당신이 현재 위치한 버튼을 설명하고 이용 가능한 총 항목 수를 알려줄 거예요.\n\n그러나 \"드롭다운\" 버튼으로 탭을 이동하면 부 메뉴임을 사용자에게 알리지 않아요. 화면 낭독기는 \"목록 항목 2, 드롭다운 버튼\"이라고 말하거나 그냥 \"드롭다운 버튼\"이라고 할 거예요.\n\n\n\n사용자가 유용한 정보를 놓치지 않게 하려면 \"Dropdown\" 버튼이 추가로 사용 가능한 메뉴를 가지고 있다는 것을 알려줄 필요가 있습니다.\n\n이것을 해결해 보겠습니다. 우리가 가지고 있는 WCAG 문서의 가이드라인을 참고하겠습니다.\n\n현재 가이드라인에 따르면, 우리는 이미 button 요소를 사용하고 있기 때문에 button 역할은 이미 다 covered되어 있습니다. 그러나 화면 낭독기와 같은 보조 기술을 돕기 위해 aria-haspopup와 aria-expanded 속성을 업데이트해야 합니다.\n\n또한 \"menu\" 역할을 적절하게 할당해야 합니다. 하위 메뉴는 사용자가 escape 키를 누르거나 하위 메뉴의 마지막 항목을 벗어날 때 닫혀야 합니다.\n\n\n\n지금 이것을 해 봅시다. 먼저 사용자가 하위 메뉴를 닫을 수 있도록 허용해 주겠습니다:\n\n```js\nfunction closeSubmenu() {\n  const submenu = document.querySelector(\".dropdown-content\");\n  submenu.classList.remove(\"show-submenu\");\n}\n\nfunction openSubmenu() {\n  console.log(\"하위 메뉴 열기\");\n  const submenu = document.querySelector(\".dropdown-content\");\n  submenu.classList.add(\"show-submenu\");\n  submenu.getElementsByTagName(\"button\")[0].focus();\n\n  // 메뉴를 닫는 핸들러 추가\n  window.addEventListener(\"keydown\", (event) =\u003e {\n    if (event.key === \"Escape\" \u0026\u0026 submenu.classList.contains(\"show-submenu\")) {\n      closeSubmenu();\n      const dropdownBtn = document.querySelector(\".dropbtn button\");\n      dropdownBtn.focus();\n    }\n  });\n}\n```\n\n우리는 드롭다운 컨테이너에 메뉴의 역할을 추가하고, 마지막 항목에서 벗어날 때 메뉴를 닫기 위해 마지막 요소에 \"onblur\"를 추가하고 closeSubmenu 함수를 호출합니다:\n\n```js\n\u003cli class=\"dropdown\" role=\"menu\"\u003e\n  \u003cdiv class=\"dropbtn\"\u003e\n    \u003cbutton onclick=\"openSubmenu()\"\u003e드롭다운\u003c/button\u003e\n    \u003ci class=\"fa fa-caret-down\"\u003e\u003c/i\u003e\n  \u003c/div\u003e\n  \u003cul class=\"dropdown-content\"\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e링크 1\u003c/button\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\"\u003e링크 2\u003c/button\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cbutton onclick=\"doSomething()\" onblur=\"closeSubmenu()\"\u003e링크 3\u003c/button\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/li\u003e\n```\n\n\n\n이것을 수행하는 방법은 여러 가지가 있습니다. 현재는 이를 위한 매우 간단한 해결책을 사용했습니다. 중요한 것은 메뉴가 닫힌 후에 올바른 요소로 포커스를 돌려주는 것입니다.\n\n이제 이스케이프 키를 사용하여 하위 메뉴를 닫아보세요. 작동해야 합니다.\n\n이제 접근성 도구를 사용하여 메뉴를 테스트해 보죠.\n\n화면 하단의 스크린 리더 안내문을 주목해보세요. 이제 (조금 더) 메뉴 항목으로 식별되는 것을 알 수 있을 겁니다.\n\n\n\n위의 기준에 따라 유효한 aria 속성을 설정하도록 더 세부적으로 정제하겠습니다. 또한 여기에 정의된 메뉴 및 메뉴바 기준도 설정하겠습니다.\n\n```js\nnav태그에 class=\"navbar\"를 추가합니다:\n  - 메뉴바 역할(role)을 가진 ul요소를 추가합니다:\n    - Home 버튼에 onclick=\"doSomething()\" href=\"#\"를 추가합니다.\n    - dropdown class가 있는 li요소를 추가합니다:\n      - dropbtn class를 가진 div에 다음을 추가합니다:\n        - dropdown-trigger id를 가진 버튼에 onclick=\"openSubmenu(true)\" onfocus=\"openSubmenu(false)\"을 추가하고,\n          aria-controls=\"dropdown-submenu\", aria-haspopup=\"true\", aria-expanded=\"false\"를 추가합니다.\n        - fa-caret-down class를 가진 i요소를 추가합니다.\n      - dropdown-content class를 가진 ul요소를 추가하고, aria-labelledby=\"dropdown-trigger\", role=\"menu\", id=\"dropdown-submenu\"를 추가합니다:\n        - menuitem 역할(role)을 가진 각각의 li요소를 추가하고, aria-owns=\"dropdown-submenu\"를 추가합니다.\n          - onclick=\"doSomething()\"를 추가한 버튼을 추가합니다.\n    - News 버튼에 onclick=\"doSomething()\"를 추가합니다.\n```\n\n\n\n위에 한 일들을 확인해 보세요.\n\n또한 스크립트를 수정하여 aria 확장 상태를 업데이트합시다:\n\n```js\nfunction closeSubmenu() {\n  const submenu = document.querySelector('.dropdown-content');\n  submenu.classList.remove('show-submenu');\n}\n\nfunction openSubmenu(focusOnlistItem) {\n  console.log('opening submenu');\n  const dropdownBtn = document.querySelector('.dropbtn button');\n\n  // aria 확장 상태 설정\n  dropdownBtn.ariaExpanded = true;\n  const submenu = document.querySelector('.dropdown-content');\n  submenu.classList.add('show-submenu');\n  if (focusOnlistItem) {\n    submenu.getElementsByTagName('button')[0].focus();\n  }\n  window.addEventListener(\"keydown\", (event) =\u003e {\n    if (event.key === 'Escape' \u0026\u0026 submenu.classList.contains('show-submenu')) {\n      closeSubmenu();\n\n      // 닫을 때 aria 확장 상태 재설정\n      dropdownBtn.ariaExpanded = false;\n      dropdownBtn.focus();\n    }\n  });\n}\n```\n\n이제 화면 리더가 알림을 하면서 말하는 내용을 확인해 봅시다.\n\n\n\n아래 프롬프트를 보면, 스크린 리더가 메뉴의 \"확장된\" 상태를 읽어 줍니다.\n\n서브 메뉴도 올바르게 읽혀지며 각 항목들은 적절한 menuitem 역할과 aria-owns 속성을 가지고 부모 메뉴 id를 가리킵니다:\n\n이 모든 것을 보면, 심지어 간단한 내비게이션 메뉴조차 완전히 접근 가능하게 만드는 데 얼마나 많은 것이 필요한지 놀랄 것입니다.\n\n# 접근 가능한 로더 만들기\n\n\n\n메뉴를 접근 가능하게 만든 후에 \"Enter\" 키를 눌러 화면 리더를 켠 채로 로더를 실행해보세요.\n\n이제 로더는 상호 작용 요소는 아니지만, 웹사이트를 제대로 볼 수 없는 사용자에게 페이지의 현재 상태에 대해 알려주어야 합니다. 여기서 몇 가지 잘 알려지지 않은 aria 태그가 유용할 수 있습니다.\n\n이 중 첫 번째는 aria-live입니다. 자세히 설명드리겠습니다. 이 태그는 기본적으로 페이지의 동적인 부분에 대한 정보를 사용자에게 알리는 데 사용됩니다. 화면 리더나 보조 기술이 이 태그를 인식하고 태그에 지정된 값대로 업데이트를 알려줍니다.\n\n\"doSomething\" 목업 로더 함수에 다음과 같은 변경 사항을 가해보세요:\n\n\n\n```js\n\u003cscript\u003e\n    function doSomething() {\n      console.log('fireddd');\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() =\u003e {\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        document.querySelector('.loader-progress').innerHTML = \n          `\u003cspan aria-live=\"polite\"\u003e${timer} % \u003c/span\u003e`;\n      }, 400);\n\n    }\n\n    function closeSubmenu() {\n      ...\n    }\n\n    function openSubmenu(focusOnlistItem) {\n      ...\n    }\n\u003c/script\u003e\n```\n\n위 코드에서 innerHTML에 추가한 특정한 라인을 주목해주세요:\n\n```js\n\u003cspan aria-live=\"polite\"\u003e${timer} % \u003c/span\u003e\n```\n\n이 라인을 통해 진행 상황을 호출하는 것이 시작될 것입니다.\n\n\n\n하지만 또 다른 문제가 있어요. 화면 판독기가 업데이트를 읽어주는 동안 로더는 여러 단위로 진행돼요.\n\n이로 인해 로더의 진행 상황과 실제 진행 상황이 맞지 않게 될 수 있어요.\n\n예를 들어, 아래는 진행 불일치의 스크린샷이에요. 화면 판독기 안내와 실제 로더 진행 상황을 주목해주세요:\n\n로더 진행률은 42%인데, 화면 판독기는 \"12%\"라고 읽어주는 걸 알 수 있어요. 이는 말로 진행 상황을 명확히 이야기하는 데 걸리는 시간 때문이에요.\n\n\n\n이 문제를 해결하기 위해 특정 간격 이후에 진행 상황을 읽어주도록 할 수 있습니다. 이 간격은 예를 들어 10% 진행 후에 발생할 수 있습니다.\n\n이를 위해 true/false로 설정된 aria-busy라는 또 다른 속성을 사용할 것입니다. 여기에는 관련 문서가 있으나, 이것은 true로 설정되어 있는 동안 업데이트를 잠깐 차단할 것입니다.\n\n로더에 대한 HTML 코드를 수정해 봅시다:\n\n```js\n\u003cdiv class=\"loader-wrapper\" id=\"main-loader\"\u003e\n  \u003cdiv class=\"loader\"\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"loader-progress-container\"\u003e\n    \u003cspan class=\"loader-progress\"\u003e\n      \u003cspan id=\"load-progress\" aria-live=\"polite\" aria-busy=\"true\"\u003e\u003c/span\u003e\n    \u003c/span\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n```\n\n\n\n로드 진행률 스팬을 동적으로 스크립트를 통해 생성하는 대신 HTML로 옮겼습니다. 이는 이제 aria-live 및 aria-busy 속성을 추적하여 업데이트해야 하기 때문입니다. 이전에는 매번 새 요소를 생성했습니다. 이제는 요소의 단일 인스턴스가 필요하며 해당 aria 속성만 업데이트해야 합니다.\n\n다음 단계는 업데이트마다(첫 번째 업데이트 포함) 10%씩 읽어 주는 것입니다. 이를 간단히 JS 코드를 사용하여 aria-busy 속성을 true/false로 설정하여 수행할 것입니다:\n\n```js\n\u003cscript\u003e\n    function doSomething() {\n      console.log('fireddd');\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() =\u003e {\n\n        // 로드 진행률 스팬을 가져와 타이머를 업데이트합니다\n        const loadProgressElm = document.getElementById(\"load-progress\");\n        if (loadProgressElm) {\n          if (timer % 10 === 0 || timer === 1) {\n            // 음성 업데이트 허용\n            loadProgressElm.ariaBusy = \"false\";\n          } else {\n            // 음성 업데이트 차단\n            loadProgressElm.ariaBusy = \"true\";\n          }\n        }\n\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        loadProgressElm.innerHTML = `로딩 중 ${timer} %`;\n      }, 400);\n\n    }\n\n    function closeSubmenu() {\n      ...\n    }\n\n    function openSubmenu(focusOnlistItem) {\n      ...\n    }\n  \u003c/script\u003e\n```\n\n실시간으로 어떻게 보이는지 확인해보세요. 하단의 프롬프트를 주목하면 마지막 진행 업데이트와 동기화되어 있음을 알 수 있습니다:\n\n\n\n그렇게 하면 스크린 리더 및 보조 기술에서 이해하기 쉬운 로더를 얻을 수 있습니다.\n\n## 결론\n\n위에서 살펴본 것을 통해 웹 사이트의 이해를 돕는 중요성에 대해 감을 잡을 수 있습니다. 위의 프로젝트를 더 다듬을 부분과 몇 가지 버그가 있지만, 이는 접근성을 구현하는 효과적인 전략 개요를 제공하는 데 사용된 데모였습니다.\n\n간단한 메뉴/로더 구현만으로도 접근성이 의미 있는 태그와 매우 높은 수준의 aria 속성을 넘어 사용자에게 가장 관련성 있는 업데이트를 제공해야 함을 이해할 수 있습니다.\n\n\n\n많은 aria 태그와 이를 구현하는 데 사용할 수 있는 해결책들이 있습니다. MDN에서 읽어보거나 WCAG 가이드라인을 확인해보세요.\n\n언제나 사용자 경험이 접근 가능해야 합니다. 사용하는 의미론적 태그의 수나 알고 있는 aria 속성의 종류와는 무관하게요!","ogImage":{"url":"/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png"},"coverImage":"/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png","tag":["Tech"],"readingTime":18},{"title":"획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요","description":"","date":"2024-05-14 15:02","slug":"2024-05-14-HowtogetGithubCopilotfor100free","content":"\n\n대부분의 분들이 GitHub Copilot이 무엇인지 알고 계실 것으로 믿습니다. 알지 못하는 경우를 대비해 아래에 설명드리겠습니다.\n\n\"GitHub Copilot은 AI 페어 프로그래머로, 코드를 더 빠르고 더 쉽게 작성할 수 있도록 돕습니다. 주석과 코드에서 문맥을 추출하여 개별 라인과 전체 함수를 즉시 제안합니다. GitHub Copilot은 OpenAI가 만든 Codex라는 생성 사전 훈련 언어 모델에 의해 제공됩니다. Visual Studio Code, Visual Studio, Neovim 및 JetBrains 통합 개발 환경(IDE) 패밀리용 확장으로 제공됩니다.\"\n\n![이미지](/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png)\n\n아래 비디오를 시청하시거나 글을 끝까지 읽어보시면 무료로 Github Co-Pilot을 얻는 방법에 대해 알 수 있습니다.\n\n\n\n이전에 Github Co-Pilot은 미리 등록된 모든 사용자에게 무료였습니다. 이는 Github가 다양한 언어와 코드베이스를 통해 트레이닝하여 코-파일러의 AI 모델을 사용자 친화적으로 만들고 싶었기 때문입니다. 현재 Github Co-Pilot의 정확도는 약 26%로 도달했습니다. 이제 Github는 Github Co-Pilot에 대해 요금을 부과하기 시작하는 좋은 정확도라고 생각하고 있습니다.\n\n현재 Github Co-Pilot의 구독 비용은 얼마인가요:\n\n[https://github.com/github-copilot/signup](https://github.com/github-copilot/signup)\n\n![그림](/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_1.png)\n\n\n\n비록 이 소프트웨어는 인간의 창조물 중에 빛나는 작품이지만, 모두가 이를 구매할 수 있는 것은 아닙니다 (대부분의 사람들은 무료 소프트웨어를 사용하는 것에 익숙합니다). 그래서, 나는 Github Co-pilot을 무료로 얻는 합법적인 방법을 찾아 냈습니다.\n\nGithub의 공식 문서에 언급되어 있듯이, Co-pilot은 오픈 소스 기여자와 학생들을 위해 무료로 제공될 것입니다.\n\n- 오픈 소스에 적극적으로 기여하고 있는 경우, 즉 인기 있는 라이브러리를 만들거나 기존 인기 있는 라이브러리의 버그를 수정하는 경우 Github는 이미 당신을 알고 있습니다. Github Co-pilot 구독을 신청하려고 할 때, 무료로 제공됩니다.\n- 또는 고등학교, 중학교, 대학, 자평, 또는 유사한 교육 기관과 같은 학위나 자격증이 주어지는 과정에 등록된 학생인 경우, Github Co-pilot을 무료로 이용할 수 있습니다. Github는 교육 세부 정보를 확인하고 유효성을 인증할 것입니다. 올바른 세부 정보를 제공하면 Github Co-Pilot에 무료로 액세스할 수 있습니다.\n- 이미 일을 하고 있고 파트타임 교육/자격증 프로그램을 이수 중인 경우 학생 범주 하에서 라이선스를 신청할 자격이 있을 수 있습니다. 그러나 Github의 심사 과정에 대해서는 확신할 수는 없지만, 시도해 볼 가치가 있습니다.\n\n위의 단계 중 어떤 것도 작동하지 않는다면, Github Co-pilot의 대안인 여러 개의 오픈 소스가 있습니다. 해당 대안에 대해 알고 싶다면 댓글 섹션에 알려주세요. 저는 그것들을 설명하는 기사를 작성할 것입니다.\n\n\n\n만약 개인적으로 모의 면접, 면접 대비 팁과 노하우, 또는 이력서 검토에 대해 이야기를 나누고 싶다면, 여기에서 세션을 예약할 수 있어요:\n\n즐거운 독서, 다음 기사에서 뵙겠습니다.\n\n동일한 저자의 다른 기사들:\n\n- 90%가 풀지 못할 페이스북 면접 문제\n- 드디어 Github Co-Pilot이 모두에게 공개되었어요\n- Meta, Amazon, Google, Apple, Microsoft 프론트엔드 개발자 면접 문제 풀기\n- 최근 페이스북 프론트엔드 개발자 면접 문제 풀기","ogImage":{"url":"/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png"},"coverImage":"/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png","tag":["Tech"],"readingTime":2},{"title":"캔버스의 마법을 해제해 보세요","description":"","date":"2024-05-14 15:01","slug":"2024-05-14-UnlockingtheMagicofCanvas","content":"\n\n## 예술이 코드와 만나는 곳\n\n# 캔버스란?\n\n캔버스는 HTML5 스위트 내에서 놀라운 기능으로, 웹 브라우저 안에서 예술적 및 계산적 가능성을 펼칠 수 있도록 설계되었습니다. 그래픽 콘텐츠와 애니메이션에 대한 강력한 플레이그라운드로서, 개발자들이 제3자 플러그인이나 라이브러리가 필요 없이 자신의 창의성과 기술을 펼칠 수 있도록 초대합니다.\n\n![캔버스 이미지](/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png)\n\n\n\n# 캔버스의 탁월한 기능들\n\n- 유연성: 캔버스는 예술가를 위한 빈 캔버스와 같습니다; 다양한 그래픽 및 애니메이션을 만들기 위한 절대적인 유연성을 제공합니다.\n- 클라이언트 측 렌더링: 캔버스의 놀라운 점 중 하나는 모든 렌더링 작업이 클라이언트 측에서 수행되어 서버 부하를 줄이고 더 빠르고 효율적인 실행을 보장한다는 것입니다.\n- 고성능: 하드웨어 가속을 통해 캔버스는 유동적인 애니메이션 및 복잡한 그래픽 작업에 대한 빠른 옵션으로 빛납니다.\n- 다재다능한 렌더링: 2D 또는 WebGL이든, 캔버스는 프로젝트의 필요에 맞는 다양한 렌더링 옵션을 제공합니다.\n- JavaScript와의 깊은 통합: 포괄적인 JavaScript API로, 캔버스는 복잡한 작업 및 조작을 손쉽게 수행할 수 있게 합니다.\n\n# 다양한 응용 분야\n\n- 데이터 시각화: 인터랙티브 그래프, 상세한 지도, 실시간 분석 대시보드 등을 상상해보세요.\n- 게임 개발: 캔버스 덕분에 웹 기반 게임이 살아나고 있습니다.\n- 이미지 처리: 사진 편집부터 필터 적용까지, 가능성은 무한합니다.\n- 인터랙티브 애니메이션: 시각적으로 매력적인 UI 및 애니메이션 스토리텔링을 구축하는 데 중요한 역할을 합니다.\n- 실시간 렌더링: 음악 파형, 실시간 데이터 시각화 - 무엇이든, 캔버스가 처리할 수 있습니다.\n\n\n\n# 훌륭한 예시\n\n여기에 당신을 위한 CodePen 샌드박스가 있어요. 페이지를 클릭해서 즐겁게 놀아보세요!\n\n# 코드 설명\n\n## HTML 구조\n\n\n\n우리는 HTML에서 `canvas` 태그를 정의하고 ID를 할당하여, 그래픽 가능성의 세계로의 게이트웨이 역할을 하도록 시작합니다.\n\n```html\n\u003cdiv class=\"page\" \u003e\n  \u003ccanvas id=\"canvas\" class=\"canvas\"\u003e\u003c/canvas\u003e\n\u003c/div\u003e\n```\n\n## 스타일링하기\n\nCSS에서는 Canvas가 정말 빛날 수 있는 세련된 환경을 설정합니다.\n\n\n\n```js\n.page {\n  /* 페이지 콘텐츠를 가운데 정렬 */\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  width: 100vw;\n}\n.canvas {\n  /* Canvas를 전체 화면으로 설정하고 가장 하단 레이어에 위치시킴 */\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: -1;\n  background-color: #000;\n}\n```\n\n## JavaScript 생태계\n\n여기서 우아한 두 가지 클래스인 StarrySky와 Particle을 소개합니다.\n\n```js\nclass StarrySky {\n    canvas;\n    ctx;\n    particles;\n    count;\n    actions;\n    action;\n\n    constructor() {\n        this.canvas = document.getElementById('canvas');\n        this.canvas.width = innerWidth;\n        this.canvas.height = innerHeight;\n        this.canvas.style.zIndex = '-1';\n        this.ctx = this.canvas.getContext('2d');\n        this.particles = [];\n        this.count = 300;\n\n        this.actions = ['right', 'left', 'up', 'down', 'around'];\n        this.action = 0;\n    }\n\n    init() {\n        this.animate();\n        this.event();\n    }\n\n    event() {\n        document.body.addEventListener('click', () =\u003e {\n            this.action += Math.floor(Math.random() * this.actions.length) || 1;\n            this.action = this.action % this.actions.length;\n        });\n    }\n\n    draw() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.particles.length \u003c this.count) {\n            this.particles.push(\n                new Particle(this.canvas.width, this.canvas.height, this.ctx)\n            );\n        }\n        for (let i in this.particles) {\n            const p = this.particles[i];\n            p.update(this.actions[this.action]);\n            p.draw();\n        }\n    }\n\n    animate() {\n        requestAnimationFrame(() =\u003e this.animate());\n        this.draw();\n    }\n\n}\n\nclass Particle {\n    x;\n    y;\n    vx;\n    w;\n    h;\n    ctx;\n\n    constructor(width, height, ctx) {\n        this.w = width;\n        this.h = height;\n        this.ctx = ctx;\n        this.x = Math.random() * width;\n        this.y = Math.random() * height;\n        this.vx = Math.random();\n    }\n\n    update(direction = 'right') {\n        switch (direction) {\n            case 'right':\n                this.x += this.vx * 3;\n                if (this.x \u003e this.w) this.x = 0;\n                break;\n            case 'left':\n                this.x -= this.vx * 3;\n                if (this.x \u003c 0) this.x = this.w;\n                break;\n            case 'up':\n                this.y -= this.vx * 3;\n                if (this.y \u003c 0) this.y = this.h;\n                break;\n            case 'down':\n                this.y += this.vx * 3;\n                if (this.y \u003e this.h) this.y = 0;\n                break;\n        }\n    }\n\n    draw() {\n        this.ctx.beginPath();\n        this.ctx.arc(this.x, this.y, 1 + this.vx, 0, Math.PI * 2);\n        this.ctx.fillStyle = `rgba(255, 255, 255, ${this.vx})`;\n        this.ctx.fill();\n    }\n}\n```\n\n\n\n- StarrySky: 캔버스와 입자 객체를 초기화하고 관리하는 역할을 맡습니다.\n- Particle: 개별 입자의 렌더링 및 업데이트에 초점을 맞춥니다.\n\n```js\n// 초기화\nconst starrySky = new StarrySky();\nwindow.onload = () =\u003e {\n  starrySky.init();\n};\nwindow.onresize = () =\u003e {\n  starrySky.canvas.width = innerWidth;\n  starrySky.canvas.height = innerHeight;\n};\n```\n\n페이지가 로드될 때 우리는 StarrySky 클래스의 경이로운 힘을 소환합니다. 또한, 창 크기가 조정될 때 캔버스의 크기를 동적으로 조정하여 항상 매혹적인 경험을 제공합니다.\n\n## 코드 자세히 설명\n\n\n\n- 캔버스와 컨텍스트: this.canvas = document.getElementById(`canvas`); 및 this.ctx = this.canvas.getContext(`2d`); 라인을 사용하여 캔버스의 우주와 2D 그리기 공간에 접근합니다.\n- 입자 이동: this.actions = [`right`, `left`, `up`, `down`, `around`]; 라인에서는 클릭으로 입자가 날아갈 방향을 조절할 수 있는 능력을 제공합니다.\n- 애니메이션 루프: requestAnimationFrame(() =` this.animate()); 라인은 매혹적이고 끝없는 애니메이션 루프를 제공합니다.\n- 이벤트 리스너: document.body.addEventListener(`click`, () =` ' ... ');를 통해 각 클릭이 입자 행동을 변화시켜 애니메이션을 더 인터랙티브하고 동적으로 만듭니다.\n- 입자 업데이트 및 렌더링: this.particles.push(new Particle(...));을 통해 새로운 우주 입자를 생성하고 p.update() 및 p.draw()를 통해 이동과 외관을 업데이트합니다.\n\n캔버스는 웹 개발 세계에서 놀라운 기술로 자리 잡고 있습니다. 데이터 시각화부터 대규모 웹 기반 게임 제작까지, 응용 분야는 여러분의 상상력만큼 무한합니다. 이 가이드는 캔버스에 대한 이해를 풍성하게 하고 멋진 프로젝트를 시작할 자극을 드리기 위해 노력합니다. 그러니 할 수 있어요, 캔버스가 여러분의 타작게요!\n\n만약 이 글을 좋아한다면, 박수를 보내주세요. 여러분의 응원이 제 창의적 엔진을 충전합니다. 건배하며 백만 번 감사합니다!\n\n\u003cimg src=\"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_1.png\" /\u003e","ogImage":{"url":"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png"},"coverImage":"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png","tag":["Tech"],"readingTime":6},{"title":"NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법","description":"","date":"2024-05-14 15:00","slug":"2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png\" /\u003e\n\nGET 및 POST 엔드포인트는 REST API에서 가장 일반적인 엔드포인트 중 두 가지입니다. GET 엔드포인트를 사용하면 클라이언트가 서버에서 데이터를 검색할 수 있고, POST 엔드포인트를 사용하면 클라이언트가 서버로 데이터를 보낼 수 있습니다. 여기에서는 NodeJS와 ExpressJS를 사용하여 필수 GET 및 POST 엔드포인트를 만드는 방법을 보여드릴 거에요.\n\n# GET 엔드포인트 생성\n\nGET 엔드포인트를 만들려면 app.get() 메서드를 사용할 수 있어요. 이 메서드는 두 개의 매개변수를 가지는데, 첫 번째는 엔드포인트의 경로이고, 두 번째는 클라이언트가 엔드포인트에 GET 요청을 할 때마다 실행될 콜백 함수입니다.\n\n\n\n다음은 /users-list 경로에 GET 엔드포인트를 만드는 방법의 예시입니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.get('/users-list', (req, res) =\u003e {\n  // 사용자 목록 전체를 가져옵니다\n  const usersList = [];\n\n  // 사용자 목록을 클라이언트에 응답으로 전송합니다\n  res.send(usersList);\n});\n```\n\n다음은 위에서 만든 엔드포인트를 사용하여 GET 요청을 보내는 방법의 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nfetch('http://localhost:3000/users-list')\n  .then(response =\u003e response.json())\n  .then(usersList =\u003e {\n    console.log(usersList.data);\n    // 응답으로 수행하려는 동작을 작성합니다\n  })\n  .catch(error =\u003e {\n    console.log(error);\n    // 요청이 성공적이지 않을 때의 오류를 처리합니다\n  });\n```\n\n\n\n만일 이 엔드포인트를 테스트하고 싶다면, Postman에서 다음 단계를 따르세요:\n\n- Postman을 열고 새 요청을 생성하세요.\n- HTTP 메소드를 GET으로 설정하세요.\n- URL을 http://localhost:3000/users-list로 설정하세요.\n- 보내기 버튼을 클릭하여 요청을 보내세요.\n\n가끔은 GET 요청과 함께 쿼리 매개변수를 보내야 할 때가 있습니다. 여기에 간단한 코드 조각이 있습니다:\n\n```js\nconst express = require('express');\nconst app = express();\napp.get('/users-list/:id', (req, res) =\u003e {\n  const id = req.params.id;\n  // 데이터베이스에서 사용자 데이터 가져오기\n  const user = {\n    id: 1,\n    name: 'John Doe',\n  };\n  // 클라이언트에 응답 보내기\n  res.send({\n    user: user,\n  });\n});\n```\n\n\n\n# POST 엔드포인트 생성하기\n\nPOST 엔드포인트를 만들려면 app.post() 메소드를 사용할 수 있어요. 이 함수는 app.get() 메소드와 유사하게 두 개의 매개변수를 사용해요. 하지만 여기서는 콜백 함수에서 요청 바디인 즉, 클라이언트가 요청할 때 보내는 데이터에 접근할 수 있어요. 이 엔드포인트를 사용하여 새로운 사용자를 만들 수 있어요.\n\n다음은 /users-list 경로에 POST 엔드포인트를 만드는 예시에요:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.post('/users-list', (req, res) =\u003e {\n  const usersList = req.body;\n\n  // 클라이언트가 보낸 사용자 데이터를 저장해요\n\n  // 요청이 성공적이었음을 보여주는 응답을 클라이언트에게 보내요\n  res.send({\n    message: '새 사용자가 목록에 추가되었어요',\n  });\n});\n```\n\n\n\n위에서 만든 엔드포인트를 사용하여 POST 요청을 보내는 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nconst user = {\n  name: \"John Doe\",\n  email: \"john.doe@example.com\"\n};\n\nfetch('http://localhost:3000/users-list', {\n  method: 'POST',\n  body: JSON.stringify(user)\n})\n  .then(response =\u003e {\n    console.log(response.data);\n  })\n  .catch(error =\u003e {\n    console.log(error);\n});\n```\n\n아래는 이 엔드포인트를 Postman에서 테스트하는 방법에 대한 단계입니다:\n\n- Postman을 열고 새 요청을 작성합니다.\n- HTTP 메서드를 POST로 설정합니다.\n- URL을 http://localhost:3000/users-list로 설정합니다.\n- Body 탭에서 content-type 헤더를 application/json로 설정합니다.\n- 그런 다음 보내고 싶은 JSON 데이터를 본문 탭에 붙여넣습니다.\n- Send 버튼을 클릭하여 요청을 보냅니다.\n\n\n\n위에 제시된 예시들은 매우 기본적이고 데모 목적으로 제공되었어요. 그러나 당신의 요구에 따라 더 복잡한 엔드포인트를 생성하기 위해 같은 단계를 따를 수 있어요.\n\n아래는 엔드포인트를 생성하는 동안 고려할 수 있는 몇 가지 추가 팁이에요:\n\n- 개발자가 실제로 엔드포인트가 무엇을 하는지 이해하는 데 도움이 되는 설명적인 엔드포인트 경로를 사용하세요.\n- POST 엔드포인트의 요청 본문을 유효성 검사할 수도 있어요. 이것은 받는 데이터가 올바른 형식에 있는지 확인하는 추가적인 검사층 역할을 해요.\n- 가능하다면 팀 내 다른 개발자에게 쉽게 엔드포인트를 설명할 수 있는 철저한 문서를 유지하는 것이 좋아요.\n\n위의 정보가 도움이 되었기를 바래요. 읽어주셔서 감사해요. 질문, 의견 또는 관심사가 있으면 아래에 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png","tag":["Tech"],"readingTime":4}],"page":"44","totalPageCount":94,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"44"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>