<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/121" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/121" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" href="/post/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="브라우저 아키텍처의 과거와 현재" href="/post/2024-05-12-ThePastandPresentofBrowserArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="브라우저 아키텍처의 과거와 현재" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="브라우저 아키텍처의 과거와 현재" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">브라우저 아키텍처의 과거와 현재</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디자인 패턴 더 나은 코드 작성하기" href="/post/2024-05-12-DesignPatternsBuildingBetterCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 패턴 더 나은 코드 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 패턴 더 나은 코드 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디자인 패턴 더 나은 코드 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 HTTP Interceptors" href="/post/2024-05-12-HTTPInterceptorsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 HTTP Interceptors</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Gulp v5를 발표 내용 정리" href="/post/2024-05-12-AnnouncingGulpv5"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-AnnouncingGulpv5_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Gulp v5를 발표 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Gulp v5를 발표 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" href="/post/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 스크레이퍼의 도구 상자 필수 도구와 전략" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 스크레이퍼의 도구 상자 필수 도구와 전략</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" href="/post/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 5 게임 만들기  타일 게임 튜토리얼" href="/post/2024-05-12-MakeHTML5GamesTileGameTutorial"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 5 게임 만들기  타일 게임 튜토리얼" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 5 게임 만들기  타일 게임 튜토리얼</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현대 웹을 위해 새롭게 탄생한 자동완성 상자" href="/post/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현대 웹을 위해 새롭게 탄생한 자동완성 상자" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">현대 웹을 위해 새롭게 탄생한 자동완성 상자</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 18의 새로운 기능 정리 비교" href="/post/2024-05-12-Angular18NewFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-Angular18NewFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 18의 새로운 기능 정리 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 18의 새로운 기능 정리 비교</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link posts_-active__YVJEi" href="/posts/121">121</a><a class="link" href="/posts/122">122</a><a class="link" href="/posts/123">123</a><a class="link" href="/posts/124">124</a><a class="link" href="/posts/125">125</a><a class="link" href="/posts/126">126</a><a class="link" href="/posts/127">127</a><a class="link" href="/posts/128">128</a><a class="link" href="/posts/129">129</a><a class="link" href="/posts/130">130</a><a class="link" href="/posts/131">131</a><a class="link" href="/posts/132">132</a><a class="link" href="/posts/133">133</a><a class="link" href="/posts/134">134</a><a class="link" href="/posts/135">135</a><a class="link" href="/posts/136">136</a><a class="link" href="/posts/137">137</a><a class="link" href="/posts/138">138</a><a class="link" href="/posts/139">139</a><a class="link" href="/posts/140">140</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"자바스크립트에서 외부에서 프로미스 해결하기 실용적인 사용 예시","description":"","date":"2024-05-12 23:51","slug":"2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases","content":"\n\n\n![Image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png)\n\nIt's one of those cool things you can do in JavaScript that's immensely powerful in the real world.\n\n# Powerful practical use cases\n\n## Action (A) waiting for another (B)\n\n\n\nA는 진행 중입니다만 사용자는 B를 하고 싶지만 A가 먼저 발생해야 합니다.\n\n예시: 사용자가 게시물을 생성, 저장 및 게시할 수 있는 소셜 앱. 마치 Medium처럼.\n\n![이미지1](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_1.png)\n\n![이미지2](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_2.png)\n\n\n\n만약 사용자가 저장 중에 게시물을 발행하길 원한다면 어떻게 할까요?\n\n해결책: 발행되기 전에 게시물이 저장되도록 확인하세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:588/0*u7Littlul1VVDuUU.gif)\n\n\n\n이 논리를 Deffered 클래스로 추상화하면 더욱 좋아집니다:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_4.png)\n\n리팩토링✅:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_5.png)\n\n\n\n그리고 이전과 정확히 같이 작동합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:588/0*dv5w4HYCmh1giS5w.gif)\n\nDeferred는 훨씬 깔끔합니다. 그래서 우리는 ts-deferred, deferred, promise-deferred와 같은 수많은 NPM 라이브러리를 가지고 있습니다.\n\n![image](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_6.png)\n\n\n\n## 이벤트 스트림 Promisifying하기\n\n이건 내가 여러 번 사용해 본 멋진 설정이야.\n\n실제로 이벤트 스트림이 발생할 때 대기하는 비동기 작업을 수행하는 것입니다. 내부적으로:\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_7.png)\n\n\n\n# 마무리\n\n외부에서 약속을 이행하는 것은 강력한 패턴을 발휘합니다.\n\n사용자 조치부터 이벤트 스트림까지 깔끔하고 유연한 코드를 유지합니다. 그리고 ts-deferred와 같은 라이브러리를 사용하면 더 나은 처리가 가능합니다.\n\n# 자바스크립트가 하는 모든 미친 일\n\n\n\n알고 있던 것이 모두라 생각했을 때 새로운 것을 알려드릴게요.\n자바스크립트의 세심한 주의사항과 잘 알려지지 않은 부분들을 담은 Every Crazy Thing JavaScript Does 가이드로 고통스러운 버그를 피하고 소중한 시간을 절약하세요.\n\n오늘 여기서 무료로 받아보세요.\n\n![이미지](/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_8.png)","ogImage":{"url":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png"},"coverImage":"/assets/img/2024-05-12-ResolveaPromisefromoutsideinJavaScriptpracticalusecases_0.png","tag":["Tech"],"readingTime":2},{"title":"브라우저 아키텍처의 과거와 현재","description":"","date":"2024-05-12 23:47","slug":"2024-05-12-ThePastandPresentofBrowserArchitecture","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png\" /\u003e\n\n브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.\n\n# 1. 브라우저 아키텍처의 진화\n\n2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:\n\n\n\n![브라우저 아키텍처의 과거와 현재](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png)\n\n단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:\n\n- 불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.\n- 부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.\n- 보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.\n\n단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.\n\n\n\n2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:\n\n![다이어그램](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png)\n\n이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.\n\n프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.\n\n\n\n멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.  \n\n샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다. \n\n최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:\n\n![Chrome Browser Components](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png)\n\n\n\n브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 \"스케줄러\"로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.\n\nGPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.\n\n현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:\n\n![Diagram](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png)\n\n\n\n# 2. 브라우저 페이지 열리는 과정\n\n- 탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.\n- 사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.\n- 브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.\n- 네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.\n- 캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.\n- 네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.\n- 200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.\n- 브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.\n- 브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 \"문서 제출\" 메시지를 보냅니다.\n- 데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.\n\n# 3. 렌더링 프로세스\n\n현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:\n\n\n\n- 사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.\n- URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.\n- DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.\n- 소켓 연결 — 사용자와 서버 IP 간의 연결 설정.\n- HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.\n- 서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.\n- 플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.\n- 브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.\n- 응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.\n- DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.\n- 스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.\n- JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.\n- 페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.\n\n## 3.1 HTML 구문 분석\n\n브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.\n\n## 3.2 CSS Object Model\n\n\n\nCSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.\n\n## 3.3 레이아웃 관리자\n\n레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.\n\n# 4 플러그인 메커니즘\n\n\n\n## 4.1 플러그인 개발 역사\n\n플러그인 메커니즘의 개발 과정은 다음과 같습니다:\n\n- 2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.\n- 2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.\n- 2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.\n- 2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.\n- 2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.\n- 2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.\n- 2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.\n- 2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.\n- 2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.\n- 2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.\n- 2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.\n- 2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.\n- 2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.\n- 2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.\n- 2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.\n- 2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.\n- 2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.\n- 2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.\n- 2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.\n\n총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.\n\n\n\nManifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.\n\n## 4.2 Manifest의 기능 및 버전 이전\n\nManifest V2의 기능:\n\n- Content-Security-Policy (CSP)를 설정하여 script-src 'self'; object-src 'self';를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.\n- 플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.\n- 브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.\n\n\n\nManifest V3의 기능:\n\n- Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.\n- 네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.\n- 원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.\n- Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.\n- Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.\n- 웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.\n- 콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.\n\nManifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.\n\nV2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.\n\n\n\n또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.\n\n## 4.3 Chrome 확장 프로그램의 주요 구성 요소\n\n4.3.1 매니페스트 파일\n\n매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.\n\n\n\nManifest V2의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 2,\n  // 플러그인 이름\n  \"name\": \"...\",\n  // 플러그인 버전\n  \"version\": \"1.0.0\",\n  // 플러그인 설명\n  \"description\": \"...\",\n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  // 브라우저의 백그라운드 JS 또는 백그라운드 페이지\n  \"background\": {\n    \"scripts\": [\"js/background.js\"]\n  },\n  // 브라우저 아이콘 설정: browser_action, page_action, app\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 특정 페이지가 열릴 때에만 표시되는 아이콘\n  \"page_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 페이지에 직접 주입되는 JS\n  \"content_scripts\": [{\n    \"matches\": [\"\u003call_urls\u003e\"],\n    \"js\": [\"js/content-script.js\"],\n    \"css\": [\"css/custom.css\"],\n    // 코드 주입 시기, 기본값은 document_idle\n    \"run_at\": \"document_start\"\n  }],\n  // 요청되는 권한\n  \"permissions\": [\n    \"contextMenus\", // 우클릭 메뉴\n    \"tabs\", // 탭\n    \"notifications\", // 알림\n    \"webRequest\", // 웹 요청\n    \"webRequestBlocking\",\n    \"storage\", // 플러그인 로컬 저장소\n    \"https://*/*\" // executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트\n  ],\n  // 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", // 플러그인 홈페이지\n  \"chrome_url_overrides\": { // 브라우저 기본 페이지 재정의\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": { // 플러그인 옵션 페이지\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": { \"keyword\" : \"...\" }, // 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능\n  \"default_locale\": \"en\", // 기본 언어\n  \"devtools_page\": \"devtools.html\", // Devtools 페이지 진입점, HTML 파일만 지정 가능    \"content_security_policy\": \"...\", // 보안 정책\n  \"web_accessible_resources\": [ // 로드 가능한 리소스\n    \"RESOURCE_PATHS\"\n  ]\n}\n```\n\nManifest V3의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 3,\n  \"name\": \"...\", \n  \"version\": \"1.0.0\",\n  \"description\": \"...\", \n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  \"background\": {\n    \"service_worker\": \"js/background.js\"\n  },\n  \"action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\", \n    \"default_popup\": \"popup.html\"\n  },\n  \"content_security_policy\": {\n    \"extension_pages\": \"...\",\n    \"sandbox\": \"...\"\n  },\n  \"web_accessible_resources\": [\n    {\n      \"resources\": [\"RESOURCE_PATHS\"]\n    }\n  ],\n  \"permissions\": [\n    \"contextMenus\",\n    \"tabs\",\n    \"notifications\",\n    \"webRequest\",\n    \"webRequestBlocking\",\n    \"storage\",\n    \"https://*/*\"\n  ],\n  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", \n  \"chrome_url_overrides\": {\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": {\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": {\n    \"keyword\": \"...\"\n  },\n  \"default_locale\": \"zh_CN\", \n  \"devtools_page\": \"devtools.html\",\n  \"content_security_policy\": \"...\",\n  \"web_accessible_resources\": [\"RESOURCE_PATHS\"]\n}\n```\n\n\n\n4.3.2 콘텐츠 스크립트\n\n크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.\n\n- chrome. extension\n- chrome.i18n\n- chrome. runtime\n- chrome.storage\n\n다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.\n\n\n\n### 4.3.3 배경 스크립트\n\n크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.\n\n### 4.3.4 팝업 창\n\n팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.\n\n\n\n### 4.3.5 스크립트 삽입\n\n크롬 확장 프로그램 개발 중 개발자들이 \"스크립트 삽입\"이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.\n\n## 4.4 크롬 확장 프로그램의 통신 메커니즘\n\n크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:\n\n\n\n- 인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.\n- 컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.\n- 팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.\n- 백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, \"chrome.tabs.sendMessage\", chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.\n- 개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.\n\n각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.\n\n과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"},"coverImage":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png","tag":["Tech"],"readingTime":15},{"title":"디자인 패턴 더 나은 코드 작성하기","description":"","date":"2024-05-12 23:46","slug":"2024-05-12-DesignPatternsBuildingBetterCode","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png\" /\u003e\n\n## 소개\n\n소프트웨어 개발 세계에서 효율적이고 유지보수 가능하며 확장 가능한 코드를 작성하는 것이 매우 중요합니다. 하지만 프로젝트가 복잡해지면 이를 관리하는 것이 점점 어려워집니다. 여기서 디자인 패턴이 필요해집니다.\n\n## 디자인 패턴이란 무엇인가요?\n\n\n\n디자인 패턴은 코딩에서 흔히 발생하는 문제에 대한 준비된 솔루션과 같아요. 그들은 개발자들이 항상 직면하는 까다로운 코딩 퍼즐을 해결하기 위한 레시피 같습니다. 요리를 할 때 레시피를 사용하는 것처럼, 개발자들은 디자인 패턴을 사용하여 똑똑한 방식으로 코드를 작성해요.\n\n## 디자인 패턴을 사용하는 이유는?\n\n디자인 패턴은 유용합니다:\n\n코드 재사용성: 재사용 가능한 솔루션을 제공하기 때문에, 개발자들은 문제를 만날 때마다 바퀴를 다시 발명할 필요가 없어요.\n\n\n\n# 확장성: 새로운 기능을 추가하거나 프로젝트의 규모를 확장하는 데 도움을 줍니다. 이렇게 함으로서 코드를 엉망으로 만들지 않고 처리할 수 있습니다.\n\n# 유지보수성: 프로젝트가 시간이 지나도 코드를 조직화하고 이해하기 쉽게 도와줍니다.\n\n# 오류 감소: 정해진 패턴을 따름으로써 개발자는 흔한 실수와 버그를 피할 수 있습니다.\n\n# 성능 향상: 디자인 패턴은 효율적인 코딩 방법을 장려하여 더 나은 성능의 소프트웨어로 이끕니다.\n\n\n\n협업: 여러 개발자가 동일한 코드베이스에서 작업하기가 더 쉽습니다. 팀워크와 생산성을 촉진합니다.\n\n## 디자인 패턴의 종류\n\n주요 세 가지 유형이 있습니다:\n\n생성 패턴: 이러한 패턴은 객체가 어떻게 생성되는지 다룹니다. 객체를 언제, 어떻게 생성할지 결정하는 데 도움이 됩니다. 코드의 유연성과 성능을 향상시킬 수 있습니다.\n\n\n\n구조 패턴: 이러한 패턴은 클래스와 객체가 대형 구조를 형성하는 방식에 중점을 둡니다. 코드를 이해하고 유지 관리하기 쉬운 방식으로 구조화하는 데 도움을 줍니다.\n\n행동 패턴: 이러한 패턴은 객체 간의 통신 방식을 정의합니다. 코드를 유연하고 결합도가 낮은 방식으로 설계할 수 있게 도와줍니다. 이는 코드의 다른 부분이 서로에게 지나치게 의존하지 않도록 합니다.\n\n## 일반적으로 사용되는 디자인 패턴\n\n생성 패턴:\n\n\n\n- 팩토리 메서드: 이 패턴은 구체적으로 인스턴스화할 클래스를 지정하지 않고 객체를 생성하는 데 도움을 줍니다. 이는 느슨한 결합을 촉진하고 코드를 더 유연하게 만듭니다.\n\n```js\n{\nclass Fruit {\nconstructor(name) {\nthis.name = name;\n}\neat() {\nconsole.log(`${this.name}을(를) 먹는 중`);\n}\n}\nclass FruitStand {\nstatic create(name) {\nreturn new Fruit(name);\n}\n}\nconst fruit1 = FruitStand.create(\"사과\");\nconst fruit2 = FruitStand.create(\"오렌지\");\nfruit1.eat(); // 사과를 먹는 중\nfruit2.eat(); // 오렌지를 먹는 중\n}\n```\n\n- 싱글톤: 이 패턴은 클래스가 하나의 인스턴스만 가지도록 보장하고 해당 인스턴스에 대한 전역 액세스 지점을 제공합니다. 설정 또는 로깅에 유용하지만 남용하면 결합이 강화될 수 있으므로 삼가 사용하세요.\n\n```js\nclass Singleton {\nconstructor() {\nif (Singleton.instance) {\nreturn Singleton.instance;\n}\nSingleton.instance = this;\n}\n// 여기에 코드 작성\n}\nmodule.exports = Singleton;\n```\n\n\n\n프론트엔드 개발자님 안녕하세요!\n\n- Builder: 복합 객체의 생성을 표현으로부터 분리하여 동일한 생성 프로세스가 다양한 표현을 만들 수 있게 합니다. 많은 선택적 매개변수나 구성을 갖는 객체를 다룰 때 매우 유용합니다.\n\n구조 패턴:\n\n- Adapter: 이 패턴을 사용하면 호환되지 않는 인터페이스끼리 함께 작동할 수 있습니다. 서로 다른 인터페이스를 가진 두 클래스 사이에 다리 역할을 합니다.\n\n```js\n// 기존 Animal 클래스\nclass Animal {\nconstructor(name) {\nthis.name = name;\n}\nspeak() {\nconsole.log(`${this.name} makes a sound.`);\n}\n}\n// Adapter 클래스\nclass LionAdapter {\nconstructor(animal) {\nthis.animal = animal;\n}\nroar() {\nconsole.log(`${this.animal.name} roars loudly!`);\n}\n}\n// 사용법\nconst genericAnimal = new Animal(\"일반 동물\");\nconst lion = new LionAdapter(genericAnimal);\nlion.roar(); // 일반 동물이 크게 웁니다!\n```\n\n\n\n- 데코레이터: 이 패턴은 기존 객체에 동적으로 새로운 기능을 추가합니다. 핵심 기능을 수정하지 않고 여러 데코레이터를 추가할 수 있습니다.\n\n행동 패턴:\n\n- 옵저버: 이 패턴은 객체 간의 일대다 종속성을 정의합니다. 한 객체의 상태 변경 시 모든 종속 객체에게 알립니다. 이는 이벤트 처리나 실시간 업데이트와 같은 기능을 구현하는 데 유용합니다.\n\n```js\nclass FruitObserver {\nconstructor() {\nthis.observers = [];\n}\nsubscribe(fn) {\nthis.observers.push(fn);\n}\nunsubscribe(fn) {\nthis.observers = this.observers.filter(fruitListener =\u003e fruitListener !== fn);\n}\nnotify(data) {\nthis.observers.forEach(observer =\u003e observer(data));\n}\n}\nconst fruitObserver = new FruitObserver();\nfruitObserver.subscribe(data =\u003e console.log(`Subscribed to ${data}`));\nfruitObserver.notify(\"Apple\"); // Subscribed to Apple\n```\n\n\n\n- 전략: 이 패턴은 알고리즘의 동작을 실행 중에 동적으로 변경할 수 있게 합니다. 클라이언트 코드를 수정하지 않고 다양한 전략 사이를 전환할 수 있습니다.\n\n## 결론\n\n디자인 패턴을 코드의 구성 요소로 생각해보세요. 프로그래머들이 자주 마주치는 문제에 대한 검증된 솔루션이죠. 이러한 패턴을 배움으로써, 초보자든 전문가든 상관없이 빠르게 더 좋은 코드를 작성할 수 있습니다.\n\n읽어주셔서 감사합니다! 🎉","ogImage":{"url":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png"},"coverImage":"/assets/img/2024-05-12-DesignPatternsBuildingBetterCode_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" /\u003e\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" /\u003e\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent\u003cany\u003e) =\u003e {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cunknown\u003e\u003e {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) =\u003e {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" /\u003e\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},{"title":"Gulp v5를 발표 내용 정리","description":"","date":"2024-05-12 23:43","slug":"2024-05-12-AnnouncingGulpv5","content":"\n![Announcing Gulp v5.0](/assets/img/2024-05-12-AnnouncingGulpv5_0.png)\n\ngulp 5로 가는 길은 길었지만, 우리가 여기까지 왔어요! 이 릴리스에는 60개 이상의 프로젝트에 대한 4년치 작업이 포함되어 있습니다. 함께하여 팀은 200개 이상의 이슈와 풀 리퀘스트를 마무리했어요. 🤯\n\n# Streamx\n\n처음부터 gulp는 스트림을 중심으로 만들어졌어요. gulp 5에서는 mafintosh의 우수한 streamx 라이브러리로 전환했어요. Streamx에는 Node.js 코어 스트림 대비 여러 이점이 있습니다. `pipe()` 함수에서 객체 및 버퍼 모드를 투명하게 처리하며 에러 처리가 가능해요.\n\n저희는 이 훌륭한 스트림 구현에 대해 더 많은 글을 쓸 시간을 갖고 싶어합니다. 그러나 대부분의 사용자들은 Node.js 코어 스트림과의 호환성을 유지하려는 노력 덕분에 차이를 느끼지 못할 것입니다. gulp 5 개발 과정에서 Mathias님의 도움과 버그 수정에 감사드립니다! 그의 작업을 후원해주시기를 고려해 주세요.\n\n# 종속성\n\n이번 릴리스의 주요 초점은 의존성 트리를 줄이고 대부분 유지하는 것으로 통합하는 데 있습니다. gulp 4가 발표된 이후 사용하던 많은 종속성이 유지되지 않았고, 따라서 이를 제거하거나 유지 책임을 갖기로 결정했습니다.\n\ngulpjs GitHub 조직은 70개 이상의 저장소로 성장했습니다. 이 세분화된 분리는 우리가 빠르게 작은 수정을 할 수 있게 하며, 다른 프로젝트들이 우리 패키지의 일부에 의존할 수 있게 합니다. 그러나 이에 대한 희생은 프로젝트 전체에 대한 대규모 변화를 만들기까지 시간이 걸린다는 것입니다.\n\n# 주요 변경 사항\n\n\"breaking changes\"가 없는 SemVer 주요 릴리스는 없겠죠. 유저들이 업그레이드할 때 문제가 없거나 거의 없기를 바라지만, 변경된 사항을 꼭 숙지하셔야 합니다.\n\n이번 대규모 릴리스에서 여기서 다루는 변경 사항은 일부분에 불과하기 때문에, 무언가가 다르게 느껴지는 것이 있다면 저희의 종합 변경 로그와 개별 프로젝트 변경 로그를 확인해주세요.\n\n## 스트림 인코딩\n\n저희 스트림은 이제 UTF-8 인코딩이 기본 설정으로 적용됩니다. 이전에는 스트림이 발생한 데이터를 인코딩을 고려하지 않고 그대로 가져왔었는데, 이번 릴리스에서는 10년 된 문제를 해결하여 사용자 정의 인코딩을 지원하고 이를 기본값으로 UTF-8로 설정했습니다. 대부분의 사용 방법은 gulp을 변경할 필요가 없을 것이지만, 일부 플러그인은 UTF-8이 아닌 출력물을 생성할 수 있으며 gulp 스트림에서 `' encoding: false '`로 설정해야 할 수 있습니다.\n\n## 글롭(Globs)\n\n또한 모든 API에서 글로빙 라이브러리를 통일했습니다. 이전에는 `src()`가 node-glob 라이브러리를 사용하고 `watch()`가 anymatch 라이브러리를 chokidar를 통해 사용했었습니다. 몇 년 동안 특정 글로브들이 이러한 함수 간에 동일하게 작동하지 않는 문제가 여러 개 개설되었었습니다. gulp 5부터는 글로브 지원으로 일관되게 anymatch를 사용합니다.\n\n게다가 “순서가 있는 글로브(ordered globs)\"를 더 이상 지원하지 않습니다. “순서가 있는 글로브\"는 음수 글로브가 배열에서 뒤에 나오는 양수 글로브에 의해 무시될 수 있는 기능이었습니다. 다른 글로빙 라이브러리에서는 이것이 흔하지 않기 때문에 모든 음수 글로브는 생태계에 일관성을 주기 위해 모든 양수 글로브에서 경로를 필터링합니다. 순서가 있는 스트림이 필요하면, ordered-read-streams 라이브러리를 제공합니다.\n\n## CLI\n\n우리는 `swc`, `esbuild`, 그리고 `sucrase`의 로더를 추가했어요. 많은 사용자들이 `.mjs`와 `.cjs` 확장자를 지원해줄 것을 요청했기 때문에, 이제 이 둘을 사용할 수 있어요. 의존성 트리를 간소화하는 과정에서 많은 구식이며 폐기된 로더들을 제거했어요. 만약 우리가 지원했던 더 색다른 로더들을 사용 중이셨다면, 더 현대적인 것으로 변경해야 할지도 모르겠어요.\n\n우리는 `—verify` 플래그를 마침내 제거했어요. 왜냐하면 오랫동안 플러그인 금지 목록을 유지하지 않고 있어서 그랬거든요. 그리고 `—require`를 `—preload`로 이름을 변경해야 했어요. 그렇게 함으로써 Node.js 플래그와 충돌을 피할 수 있어요.\n\n## Logging\n\n`gulplog`을 사용하는 모든 플러그인은 v1에서 v2로 업그레이드해야 하며, 만약 v1을 사용 중이면 사용자에게 사용 중단 경고가 표시됩니다.\n\n# 노드 지원\n\n우리는 오랫동안 gulp가 안정적인 소프트웨어임을 말해 왔으며, 가능한 많은 사용자를 지원하는 것에 관심이 있습니다. Gulp 4는 릴리스 시점에 널리 사용되었던 Node.js v0.10 사용자를 목표로 지원하는 것을 명시적으로 설정하였습니다. 10년이 지난 지금, 플랫폼이 성장하고 JavaScript가 발전함에 따라 Node.js는 이제 6개월마다 새로운 안정 버전을 출시하며, LTS 지원 기간은 30개월입니다. 이러한 새로운 버전에는 gulp를 더 나아지고 더 안정적으로 만들기 위해 활용하길 원하는 기능이 포함되어 있어서, 우리는 Node.js v10.13.0 미만의 모든 버전을 지원 중단했습니다.\n\n지원하는 Node.js 버전을 제한함으로써 의존성 트리에서 많은 플랫폼 및 JavaScript 쉼들을 제거할 수 있었습니다. 이 중 많은 부분은 유지보수되지 않았거나 스캐너에 의해 문제가 발견된 것입니다. 2018년에 발표된 Node.js 버전(그리고 LTS 지원 기간 외부)을 계속 지원함으로써 희망을 갖고 있습니다. 모든 사용자가 gulp 5로 원활하게 업그레이드할 수 있기를 바랍니다.\n\n마침내, 우리는 Windows, Mac 및 Linux을 우선 플랫폼으로 고려해 왔기 때문에 v3, v4 및 v5 사이의 인프라에 상당한 변동이 있었습니다. 이 세 가지 운영 체제를 일관되게 지원하고 사용하기 쉬운 지속적 통합 서비스를 찾는 데 많은 시간이 소요되었습니다. 우리는 우리 주요 대상을 지원하고 release-please와 같은 도구를 활용할 수 있는 GitHub Actions을 중심으로 인프라를 안정화하는 데 상당한 시간을 투자했습니다.\n\n# 앞으로\n\n할 일은 언제나 더 많이 남아 있습니다. 다가오는 몇 주 동안, 나는 우리 v5 이후 프로젝트 보드를 검토하고 중단되지 않는 후속 작업을 위한 토의를 만들 계획입니다. 우리는 gulp 5를 일정 기간 안정화한 후 다음 주요 버전을 계획하기 전에 문제가 발생하면 수정할 수 있도록 할 것입니다.\n\n우리는 더 넓은 커뮤니티로부터 피드백을 받기 위해 설문 조사를 작성 중입니다. 5월 경에 발표될 예정이니 주목해주시기 바랍니다.\n\n지금은 새 릴리스를 즐기시길 바라며, 프로젝트에 기여하거나 저희의 작업을 후원해주시면 감사하겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png"},"coverImage":"/assets/img/2024-05-12-AnnouncingGulpv5_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터 스크레이퍼의 도구 상자 필수 도구와 전략","description":"","date":"2024-05-12 23:39","slug":"2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies","content":"\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png)\n\n# 1. 웹 스크래핑이란?\n\n웹 스크래핑은 웹사이트에서 데이터를 추출하는 기술입니다. 이 과정은 자동화된 도구를 사용하여 가격 목록, 제품 세부정보, 이메일 주소 및 심지어 이미지와 같은 특정 정보를 수집하는 것을 포함합니다. 수집된 데이터는 시장 조사, 경쟁 분석 또는 온라인 데이터베이스 업데이트와 같은 다양한 목적으로 사용될 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/0*MwktrV5bs-basgRX.gif)\n\n\n\n일반적으로 시작하는 과정은 스크레이퍼 프로그램이 웹 페이지에 요청을 보내는 것으로 시작합니다. 그런 다음 페이지의 HTML 콘텐츠를 구문 분석하여 특정 데이터 요소를 검색합니다. 웹 스크래핑의 유연성 덕분에 웹 사이트에서 보이는 거의 모든 유형의 정보를 캡쳐할 수 있어 데이터 기반 의사 결정에 귀중한 도구가 됩니다.\n\n## 2. 웹 스크래핑의 이점\n\n가격 모니터링:\n\n웹 스크래핑의 첫 번째 이점은 시장에서 제품 가격을 모니터링하는 것입니다. 예를 들어, 특정 유형의 식품을 판매하는 비즈니스를 소유하고 있다면, 유사한 항목이 판매되는 가격 범위를 항상 알고 있어야 합니다. 웹 스크래핑을 통해 가격을 쉽게 추적할 수 있습니다. 경쟁 업체가 얼마를 청구하는지 알면 자신의 제품 가격을 설정하는 것이 훨씬 간단해집니다.\n\n\n\n다른 회사로부터 정보 수집:\n\n다른 회사와 파트너십을 맺으려고 할 때 그들에 대해 더 많이 알아야 합니다. 웹 스크레이핑을 사용하면 잠재적인 파트너들에 대한 방대한 데이터를 수집할 수 있습니다. 이 정보를 통해 회사가 신뢰할 만하고 협력에 적합한지를 판단할 수 있습니다. 따라서 이 과정은 탄탄한 비즈니스 결정에 중요한 역할을 합니다.\n\n시장 조사:\n\n시장 조사는 모든 비즈니스에 있어 중요합니다. 사용자들이 원하는 것을 밝혀내고 효과적인 마케팅 전략을 구축하기 위한 기초 역할을 합니다. 시장 조사에는 가장 정확한 정보가 필수이며, 웹 스크레이핑은 이를 달성하는 데 도움을 줄 수 있습니다. 웹 스크레이핑을 통해 소비자들이 선호하는 최신 트렌드를 발견할 수 있습니다. 이 데이터를 분석하여 당신의 타겟 시장을 겨냥한 제품 개발을 안내하는 데 활용할 수 있습니다.\n\n\n\n뉴스 및 콘텐츠 모니터링:\n\n브랜드를 구축하는 가장 쉬운 방법 중 하나는 미디어를 새 제품 출시 행사로 초대하는 것입니다. 미디어는 행사를 취재하고 제품을 검토하여 귀중한 홍보를 만들어내어 비즈니스에 큰 도움이 됩니다. 미디어 보도를 모니터링하는 것은 웹 스크레이핑을 통해 손쉽게 할 수 있어 여러분의 제품 및 비즈니스에 대한 보도 내용을 확인할 수 있습니다.\n\n리드 생성:\n\n새로운 리드를 확보하기 위한 중요한 전략은 잠재고객으로부터 가능한 많은 연락처 정보를 수집하는 것입니다. 웹 스크레이핑은 잠재고객의 연락처 정보를 획득하는 데 매우 효과적인 방법으로, 새로운 고객을 대상으로 하는 데 도움이 됩니다.\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:960/0*LjUSDEg8no_fYQ64.gif)\n\n# 3. 웹 스크래핑 기술\n\n![image](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_1.png)\n\n일반적으로 웹 스크래핑에는 두 가지 방법이 있습니다:\n\n\n\n수동: 이 방법은 웹 페이지에서 데이터를 직접 복사하여 붙여넣기해야 합니다. 직관적이지만 대규모 데이터셋과 작업할 때 극도로 시간이 많이 걸리고 지루할 수 있습니다.\n\n자동: 이 방법은 코딩, 소프트웨어 응용 프로그램 또는 브라우저 확장 프로그램을 활용합니다. 자동화는 데이터를 신속하게 스크래핑할 수 있는 능력으로 인해 인기를 얻고 있습니다. 사용 중인 구체적인 도구 또는 소프트웨어에 따라 방법이 다르지만, 모든 웹 스크래핑 봇은 세 가지 기본 원칙을 따릅니다:\n\n- 요청:\n이 과정은 GET 방법을 사용하여 대상 웹 사이트에 HTTP 요청을 보내는 것으로 시작됩니다. 프로그램은 원하는 웹 페이지에 액세스하여 정보를 가져옵니다. 이 단계를 통해 봇이 연결을 설정하고 데이터 추출을 위해 웹 페이지를 식별할 수 있도록 합니다.\n- 파싱:\n웹사이트로부터 응답을 받은 후, 프로그램은 파싱 프로세스를 시작합니다. 파싱은 데이터 스크래핑 기술을 활용하여 웹 페이지에서 특정 데이터 포인트를 추출하는 것을 의미합니다. 프로그램은 HTML 마크업 또는 다른 구조적 형식을 기반으로 관련 정보를 식별하고 분리합니다.\n- 표시:\n파싱을 통해 원하는 데이터를 수집하고 식별한 후, 읽기 쉬운 보고서나 표시로 변환됩니다. 데이터는 테이블, 그래프 또는 이전에 정의된 사양이나 필요에 맞는 구조와 일치하는 다양한 형식으로 제시될 수 있습니다. 최종 목표는 정보를 쉽게 이해할 수 있는 형식으로 제공하여 추가 분석이나 전략적 의사 결정에 활용할 수 있도록 하는 것입니다.\n\n# 4. 웹 스크래핑 방법\n\n\n\n- 대상 웹사이트 선택\n스크래이핑할 웹사이트를 식별하여 시작하세요. 예를 들어, 고객 서평을 분석하려면 Amazon, Goodreads 또는 LibraryThing과 같은 웹사이트를 고려할 수 있습니다.\n- 페이지 검사\n코드에 뛰어들기 전에 스크래이핑할 데이터를 식별하는 것이 중요합니다. 페이지를 마우스 오른쪽 버튼으로 클릭하고 \"요소 검사\" 또는 \"페이지 소스 보기\"를 선택하여 웹사이트의 기본 HTML 코드를 확인합니다. 이를 통해 데이터의 구조를 파악할 수 있습니다.\n- 원하는 데이터 식별\nAmazon의 책 평가에 집중한다면, 페이지의 HTML 코드에서 평가가 있는 위치를 찾으세요. 대부분의 브라우저는 선택된 프런트엔드 콘텐츠와 해당 백엔드 코드를 강조합니다. 여기서 목표는 관련 데이터를 격리하는 데 도움이 되는 고유한 태그를 식별하는 것입니다.\n- 코드 작성\n관련 태그를 정확하게 찾았다면, 해당 태그를 스크래이핑 소프트웨어에 통합하세요. 이를 위해 파이썬이 주로 사용되며, 스크래이핑 프로세스를 단순화하는 강력한 라이브러리를 갖추고 있습니다. 분석하고 저장할 정확한 데이터를 책 제목, 작가 이름, 평점 등으로 지정하는 것을 잊지 마세요.\n- 코드 실행\n코드를 작성한 후에는 다음 단계인 실행 단계로 넘어가세요. 스크레이퍼는 사이트 접근을 요청하고 데이터를 추출하여 분석할 것입니다.\n- 데이터 저장\n추출, 분석 및 관련 데이터 수집을 마치면, 그것을 저장해야 합니다. 코드에 추가 라인을 넣어 알고리즘에 그 기능을 수행하도록 지시할 수 있습니다. 선택한 형식은 중요하지 않지만 가장 일반적인 Excel 형식에 준수해야 합니다. Python 정규식 모듈을 통해 코드를 실행하여 데이터셋을 더 깔끔하게 추출하는 것도 가능합니다.\n\n# 5. 웹 스크래이핑 도구\n\n웹 스크래이핑 도구는 웹사이트로부터 데이터를 자동으로 추출하기 위해 설계된 필수 소프트웨어 응용프로그램입니다. 이 도구들은 인터넷에서 대량의 정보를 수집하여 시장 조사, 감정 분석, 경쟁 분석 및 학술 연구와 같은 다양한 목적으로 정보를 접근 가능하고 사용 가능하게 만듭니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_2.png)\n\n\n\n서버 측 스크래핑을 위해 개발자들은 효율성과 속도 때문에 Node.js를 자주 사용합니다. Playwright와 같은 라이브러리는 무해한 브라우저를 제어할 수 있어 실제 사용자가 웹 페이지를 탐색하는 것처럼 상호 작용을 자동화할 수 있습니다. 이는 웹 사이트에 로그인하거나 사용자 상호 작용 시에만로드되는 동적 AJAX 콘텐츠를 캡처하는 것을 포함할 수 있습니다. 인기 있는 라이브러리 Cheerio는 HTML 분석을 간단하게 제공하여 jQuery와 유사하게 데이터를 선택하고 조작하기 쉽게합니다. 또한 서버 작업에 적합한 속도와 효율성이 추가되어 있습니다.\n\nPlaywright의 주요 기능 중 하나는 브라우저 콘텍스트의 사용으로, 별도 및 독립적인 브라우저 세션을 모의합니다. 이는 여러 페이지 또는 시나리오를 동시에 처리할 수 있기 때문에 대용량 데이터 집합을 스크래핑하거나 여러 웹 페이지를 동시에 모니터링하는 데 적합합니다. 이러한 브라우저 콘텍스트를 다양한 네트워크 조건이나 장치와 일치하도록 사용자 정의함으로써, 안티 봇 조치를 우회하고 정확한 데이터를 수집할 수 있습니다.\n\nPlaywright는 현대 웹 기술의 복잡성을 탐색하는 데 특히 뛰어납니다. 이러한 기술들은 클라이언트 측 렌더링을 위해 JavaScript에 매우 의존하기 때문입니다. Playwright는 실제 사용자가 콘텐츠와 상호 작용하는 방식을 복제하기 위해 전체 브라우저 세션을 시작하여 데이터가 완전히로드 될 때까지 스크래핑 작업을 수행합니다. 이 기능은 전통적인 스크래핑 방법으로 종종 놓치는 동적 콘텐츠를 정확하게 캡처하기 위한 필수적인 요소입니다.\n\n뿐만 아니라, JavaScript 웹 스크래핑 도구는 일정 간격으로 데이터 수집을 자동화하거나 특정 트리거에 응답하여 대량의 데이터를 효율적으로 처리할 수 있습니다. 캡처된 데이터는 JSON 또는 CSV와 같은 다양한 형식으로 내보낼 수 있으며, 데이터베이스 및 분석 파이프라인에 직접 공급하여 데이터 주도 애플리케이션과 프로세스에 쉽게 통합할 수 있습니다.\n\n\n\n자동화는 Playwright가 빛나는 또 다른 영역입니다. Node.js를 기반으로 한 이 프레임워크는 자동화된 스크레이핑 작업을 정기적으로 예약하거나 특정 이벤트에 의해 트리거할 수 있도록 가능하게 합니다. 이 수준의 자동화는 데이터셋을 최신 상태로 유지하고 수동 개입을 줄여 비즈니스 및 연구자들 모두에게 데이터 수집을 간소화합니다.\n\n# 6. HTML — HTML이란 무엇인가요?\n\n웹 스크레이핑에서 HTML은 중요합니다. 데이터가 추출되는 웹 페이지의 구조를 형성하기 때문입니다. 각 웹 페이지의 HTML 코드는 콘텐츠의 구조와 조직을 나타내며, 스크레이퍼가 특정 데이터 포인트를 탐색하고 찾는 데 도움을 줍니다. HTML 프레임워크에는 `div`, `a`, `table`과 같이 다양한 태그가 있으며, 각각이 단락, 링크, 이미지 및 테이블과 같은 다른 구성 요소를 나타냅니다.\n\nHTML의 계층 구조는 스크레이퍼가 콘텐츠가 어떻게 구성되어 있는지 이해하는 데 도움을 줍니다. 태그에는 id 및 class와 같은 속성이 포함되어 있으며, 이는 요소에 대한 고유한 식별자로 작용하여 스크레이퍼가 특정 정보를 빨리 찾을 수 있게 합니다. 예를 들어, 스크레이퍼가 특정 클래스 속성이 있는 'table'을 찾아 테이블 데이터를 추출하거나 고유한 id를 가진 'div' 내의 링크를 대상으로 할 수 있습니다.\n\n\n\n특별한 스크레이핑 도구와 라이브러리를 사용하여 HTML을 파싱하면 개발자는 스크레이퍼가 필요로 하는 정확한 태그 또는 패턴을 찾도록 지시할 수 있습니다. 예를 들어, 전자 상거래 사이트에서 제품 리뷰를 수집한다면, 스크레이퍼는 각 리뷰를 둘러싼 HTML 태그와 속성을 식별하며 사용자 평가, 댓글 및 제품 이름을 추출할 것입니다.\n\nJavaScript를 사용하여 콘텐츠를 비동기적으로 로드하는 동적 웹 페이지는 도전을 제기할 수 있습니다. 그러나 브라우저 자동화 도구를 갖춘 스크레이퍼는 실제 브라우징 세션을 시뮬레이트하여 원하는 데이터를 추출하기 전에 페이지가 완전히 렌더링되도록 할 수 있습니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003e간단한 HTML 예제\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ch1\u003e안녕, 세상아!\u003c/h1\u003e\n    \u003cp\u003e기본 HTML 페이지에 오신 것을 환영합니다.\u003c/p\u003e\n    \u003ca href=\"https://www.example.com\"\u003e예제 방문하기\u003c/a\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n# 설명:\n\n\n\n- `!DOCTYPE html`: 이 선언은 직접적으로 웹 스크래핑에 사용되지는 않지만 HTML5 표준을 기대한다는 것을 파서에 알려줍니다.\n- `html lang=\"en\"`: 페이지의 루트 요소로, 언어를 영어로 지정합니다. 언어 속성(lang)은 직접적으로 대상이 되지 않을 수 있지만, 언어 특정 사항에 기반한 조건부 스크래핑에 유용할 수 있습니다.\n- `head`:\n\n- `meta charset=\"UTF-8\"`: 이 태그는 문자 인코딩을 UTF-8로 설정합니다. 텍스트를 올바르게 해석하는 데 중요하며, 특히 영어가 아닌 콘텐츠를 스크래핑할 때 인코딩 문제를 피하기 위해 중요합니다.\n- `title`Simple HTML Example`/title`: 문서의 제목은 웹 스크래핑의 흔한 대상입니다. 페이지의 내용을 빨리 이해하거나 검색 결과 사이에서 페이지를 분류하는 데 자주 사용됩니다.\n\n4. `body`:\n\n- `h1`Hello, World!`/h1`: 제목은 스크래핑의 주요 대상이며, 주로 중요 정보나 요약을 포함합니다. 이 h1은 주제를 식별하는 데 사용되거나 웹 사이트를 통해 페이지 구조를 이해하는 데이터 세트의 일부로 사용될 수 있습니다.\n- `p`Welcome to a basic HTML page.`/p`: 단락 태그는 페이지의 본문 텍스트를 주로 담고 있습니다. 이 데이터를 스크래핑하여 설명, 세부 사항 또는 관련 텍스트 콘텐츠를 추출하는 데 유용할 수 있습니다.\n- `a href=\"https://www.example.com\"`Visit Example`/a`: 하이퍼링크는 스크래핑 중에 웹 탐색에 중요합니다. href 속성은 URL을 제공하여 링크를 따르거나 리소스를 수집하거나 연결된 페이지를 스크래핑하는 데 사용할 수 있습니다. 이는 재귀적 기술을 사용하여 연결된 페이지 전체에서 데이터를 검색하는 깊은 웹 스크래핑에 필수적입니다.\n\n\n\n# 7. HTTP - HTTP 개념\n\nHTTP 또는 HyperText 전송 프로토콜은 월드 와이드 웹에서 데이터 통신의 기본 프로토콜로, 웹 브라우저를 서버와 연결합니다. 웹 스크래핑에 있어서 HTTP의 복잡성을 이해하는 것은 웹 사이트에서 데이터에 효과적으로 접근하고 검색하는 데 중요합니다.\n\n![이미지](/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_3.png)\n\n웹 스크래핑과 관련된 HTTP의 기본적인 측면:\n\n\n\n요청 및 응답: HTTP의 핵심은 요청과 응답 프로세스에 있습니다. 웹 스크래퍼는 브라우저 요청을 시뮬레이트하여 웹 페이지를 검색합니다. 각 요청은 GET과 같은 다양한 방법을 활용할 수 있습니다. 페이지 내용을 가져 오는 데 일반적으로 사용되는 방법과 POST, 종종 폼 데이터를 제출하거나 사이트에 로그인하는 데 사용되는 방법을 사용할 수 있습니다.\n\n헤더: HTTP 요청 및 응답의 헤더는 중요한 메타 데이터를 전달합니다. 웹 스크래핑을 위해 User-Agent와 같은 헤더는 스크래퍼를 합법적인 브라우저로 위장시켜 기본적인 안티-스크래핑 검사를 우회하는 데 도움이 됩니다. 헤더 내의 쿠키는 세션 상태를 관리하여 스크래퍼가 여러 페이지를 걸쳐 로그인 상태를 유지할 수 있도록합니다.\n\n상태 코드: 이 코드는 클라이언트에게 요청 상태에 대해 알려줍니다. 예를 들어, 200 상태 코드는 성공을 나타내고 404는 요청한 리소스가 없음을 나타냅니다. 이러한 코드를 이해하면 스크래퍼가 오류와 리디렉션을 효과적으로 처리 할 수 있습니다.\n\n요청 제한: 많은 웹 사이트는 액세스 빈도를 제어하기 위해 요청 제한을 시행합니다. 웹 스크래퍼는 이러한 제한을 트리거하지 않도록 요청 속도를 관리해야하며, 그렇지 않으면 차단된 액세스 또는 법적 문제가 발생할 수 있습니다.\n\n\n\n안녕하세요! 아래는 Markdown 형식으로 새롭게 구성된 내용입니다:\n\n**보안 통신:** HTTP 요청은 HTTPS로 보안될 수 있습니다. 이를 통해 브라우저와 서버 간에 교환되는 데이터가 암호화됩니다. 이는 민감한 데이터를 수집할 때 개인 정보 보호와 보안을 유지하는 데 매우 중요합니다.\n\n**APIs:** API를 통해 데이터를 제공하는 웹사이트는 HTML 파싱보다 데이터에 접근하는 구조화된 방법을 제공하며 종종 더 신뢰할 수 있습니다. API는 일반적으로 JSON 또는 XML과 같은 형식으로 데이터를 응답하며, 이는 스크래퍼가 처리하기에 편리합니다.\n\n**8. PlayWright Javascript를 사용하여 가격 및 제품 정보 스크랩 합니다**\n\nJavaScript에서 Playwright를 사용하여 웹 스크래핑 스크립트를 생성하기 전에 필요한 개발 환경을 설정하는 것이 중요합니다. 이 준비 단계를 통해 효율적이고 효과적인 웹 스크래핑에 필요한 모든 도구와 라이브러리가 마련됩니다.\n\n\n\n개발 환경 설정하기\n\n1. Visual Studio Code (VS Code) 설치:\n\n- Visual Studio Code은 Microsoft에서 제공하는 가벼우면서도 강력한 소스 코드 편집기입니다. JavaScript와 Node.js를 기본으로 지원하며, 디버깅, 지능형 코드 완성 (IntelliSense), 쉬운 탐색을 포함한 다양한 확장 기능을 제공합니다.\n- 먼저, 공식 Visual Studio Code 웹사이트에서 Visual Studio Code를 다운로드하고 설치하세요. 운영 체제 (Windows, macOS 또는 Linux)에 맞는 설치 지침을 따릅니다.\n\n2. Node.js와 npm 설치:\n\n\n\n- Node.js는 서버 측에서 JavaScript를 실행할 수 있게 해주는 런타임 환경이에요. Node.js에는 npm(node package manager)이 포함되어 있어서 Node.js 애플리케이션에 대한 의존성을 관리하는 데 도움을 줘.\n- 공식 Node.js 웹사이트에서 Node.js를 다운로드하세요. 기본 옵션으로 Node.js를 설치하면 npm도 함께 설치되어 Playwright를 포함한 다양한 라이브러리를 다룰 준비가 돼.\n- 설치 후에는 터미널이나 명령 프롬프트를 열어 node -v와 npm -v를 입력하면 시스템에 설치된 Node.js와 npm의 현재 버전을 확인할 수 있어.\n\n3. Node.js 프로젝트 설정하기:\n\n- Visual Studio Code를 열고 새 프로젝트 폴더를 만들거나 기존 폴더로 이동해.\n- VS Code에서 터미널을 열고(또는 운영 체제 터미널을 사용해) 프로젝트 디렉토리로 이동한 후 npm init을 실행하여 새 Node.js 프로젝트를 초기화해. 이 명령은 프로젝트 디렉토리에 package.json 파일을 생성하며 모든 의존성과 프로젝트 메타데이터를 추적할 거야.\n\n4. Playwright 설치하기:\n\n\n\n- Node.js 환경이 준비되었습니다. npm install playwright 명령어를 실행하여 Playwright를 설치해보세요. 이 명령어는 Playwright와 의존성을 다운로드하고 이를 프로젝트의 node_modules 디렉토리에 추가합니다. 또한 package.json을 업데이트하여 Playwright를 의존성으로 포함시킵니다.\n- Playwright 설치에는 Chromium, Firefox 및 WebKit용 브라우저 이진 파일이 포함되어 있어 스크립트가 다양한 브라우징 환경을 시뮬레이트할 수 있습니다.\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n```\n\n- const playwright = require(`playwright`);:\n\n- 이 코드는 Playwright 라이브러리를 현재 파일로 가져옵니다. Playwright는 웹 스크레이핑 및 테스팅을 포함한 브라우저 자동화를 가능하게 하는 인기 있는 도구입니다.\n- 이 import를 통해 다양한 브라우저(Chromium, Firefox, WebKit)에서 프로그래밍 방식으로 웹 페이지와 상호 작용하는 Playwright API를 사용할 수 있습니다.\n\n\n\n2. const fs = require(`fs`);:\n\n- 이는 Node.js의 fs (파일 시스템) 모듈을 가져와요. 이 모듈은 로컬 파일 시스템과 상호작용하기 위한 함수들을 제공해요.\n- 이를 통해 스크립트는 파일을 읽고 쓸 수 있어요. 이는 로깅, 데이터 저장, 또는 기존 파일 작업에 유용해요.\n\n3. const path = require(`path`);:\n\n- 이는 Node.js의 path 모듈을 가져와요. 이 모듈은 파일 경로를 일관적이고 크로스 플랫폼으로 다루는 데 도움이 돼요.\n- 파일 및 디렉토리 경로를 처리하는 유틸리티를 제공하며, 운영 체제에 관계없이 올바른 구문을 사용하도록 해줘요.\n\n\n\n함께 해보기:\n\n- 이러한 import를 사용하면 스크립트가 Playwright를 기반으로 한 웹 스크래핑이나 브라우저 자동화 프로젝트를 위한 기반을 설정합니다.\n- playwright는 브라우저를 제어하여 URL로 이동하거나 요소를 클릭하고 데이터를 캡처하는 등의 상호작용을 가능하게 합니다.\n- fs는 스크래핑 프로세스 중에 수집된 데이터를 저장하는 데 도움을 주며, JSON이나 CSV 파일로 저장하는 것도 가능합니다.\n- path는 파일 경로를 적절하게 관리하여 어떤 운영 체제에서도 효율적으로 데이터를 저장하거나 읽을 수 있도록 도와줍니다.\n\n예시 사용 사례:\n\n- Playwright를 사용하여 웹페이지에 이동하고 정보를 스크래핑합니다.\n- fs를 사용하여 수집한 데이터를 구조화된 형식으로 저장합니다.\n- path를 사용하여 출력 파일을 효과적으로 정리합니다.\n\n\n\n```js\n(async () =\u003e {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n```\n\n- (async () =` '...')():\n\n- 이 구조는 즉시 호출되는 함수 표현식 (IIFE)으로, 코드가 정의된 즉시 실행되도록합니다.\n- async 키워드는 함수에 비동기 작업이 포함되어 있음을 나타내며, 함수 내부에서 await을 사용할 수 있도록 합니다.\n- 이 함수를 즉시 실행함으로써 비동기 작업을 깔끔하게 처리하고 전역 범위를 깔끔하게 유지할 수 있습니다\n\n2. const browser = await playwright.chromium.launch();:\n\n\n\n- 이 코드는 Playwright의 크로미움 엔진을 사용하여 브라우저 인스턴스를 초기화합니다.\n- playwright.chromium은 Playwright의 크로미움 브라우저 자동화 엔진을 가리킵니다. 비슷한 옵션으로는 firefox와 webkit이 있습니다.\n- launch()는 새로운 헤드리스(기본값) 브라우저 세션을 시작하는 비동기 메서드입니다.\n- await 키워드는 함수가 브라우저가 완전히 로드될 때까지 실행을 일시 중지하고, 그 후에 로드된 브라우저 인스턴스를 browser 변수에 할당합니다.\n\n3. const page = await browser.newPage();:\n\n- 이 코드는 시작된 브라우저 인스턴스 내에서 새 페이지(또는 탭)를 생성합니다.\n- 새 페이지는 독립적으로 작동하며, 한 페이지에서의 동작은 동일한 브라우저에서 열린 다른 페이지에 영향을 주지 않습니다.\n- await 키워드는 다시 한 번 새 페이지가 준비될 때까지 실행을 일시 중지하고, 이를 page 변수에 할당합니다.\n\n```js\n\n  await page.goto('https://www.unitedbike.com/bikes');\n```\n\n\n\n- await: 이 키워드는 프로미스가 해결될 때까지 함수 실행을 일시 중지합니다. 이 경우에는 페이지가 완전히로드될 때까지 기다린 후 다음 라인으로 진행합니다.\n- page.goto(url):\n- 'goto'는 Playwright가 제공하는 메소드로, 브라우저 페이지를 지정된 URL로 이동하도록 지시합니다.\n- 여기서 'url'은 방문할 웹 주소로, `https://www.unitedbike.com/bikes`로 지정되어 있습니다.\n- 이 라인이 실행되면 Playwright 페이지 인스턴스는 주어진 URL로 이동하여 실제 브라우저처럼 페이지를 완전히 렌더링하고 JavaScript 기반 동적 콘텐츠를 포함합니다.\n\n```js\n  const productInfoElements = await page.$$eval('.product-information', elements =\u003e elements.map(el =\u003e {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n```\n\n이 코드 스니펫은 Playwright 페이지 객체를 사용하여 특정 제품 정보를 추출하는 더 큰 웹 스크래핑 스크립트의 일부입니다. 각 부분의 설명을 보여드릴게요:\n\n- const productInfoElements = await page.$$eval(...):\n\n\n\n- const: 이 키워드는 페이지에서 추출된 데이터를 저장할 변수 productInfoElements를 선언합니다.\n- await: 이 함수는 작업이 완료될 때까지 실행을 일시 중지하여 데이터가 준비되면 변수에 할당됩니다.\n- page.$$eval:\n- $$eval은 페이지의 모든 일치하는 요소에 대해 함수를 평가하는 Playwright 메서드입니다.\n- 첫 번째 인수인 `.product-information`은 클래스가 .product-information인 모든 HTML 요소를 대상으로 하는 CSS 셀렉터입니다.\n- 두 번째 인수는 선택된 요소에 대해 실행할 함수이며, 이 함수는 해당 요소들을 매개변수 elements로 받습니다.\n\n2. elements.map(el =\u003e ` '...'):\n\n- 이 map 함수는 elements 배열의 각 HTML 요소를 반복하며 각각의 요소를 처리하여 필요한 정보를 추출합니다.\n\n3. const caption = el.querySelector(`.caption`).textContent.trim();:\n\n\n\n- 코드는 각 .product-information 요소 내에서 클래스가 .caption인 자식 요소를 검색합니다.\n- textContent는 해당 요소의 텍스트 콘텐츠를 가져오고, trim()은 앞뒤 공백을 제거합니다.\n- 결과는 caption 변수에 저장됩니다.\n\n4. const price = el.querySelector(`.price`).textContent.trim();:\n\n- 캡션과 유사하게, 이 줄은 클래스가 .price인 자식 요소를 검색합니다.\n- textContent는 .price 요소의 내부 텍스트를 추출하는데, 일반적으로 제품의 가격을 나타냅니다.\n- trim()은 추가로 공백이 포함되지 않도록 합니다.\n\n5. return $'caption',$'price';:\n\n\n\n- 각 반복은 캡션과 가격 값을 쉼표로 구분된 형식으로 반환하는 문자열을 생성합니다.\n\n```js\nconst outputFilePath = path.join(__dirname, 'product_information.csv');\n\nfs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\nconsole.log(`Data telah diekspor ke file: ${outputFilePath}`);\nawait browser.close();\n```\n\n- const outputFilePath=path.join(__dirname,`product_information.csv`);:\n\n- path.join:\n- join은 여러 경로 세그먼트를 하나의 일관된 경로 문자열로 결합하는 path 모듈의 메서드입니다.\n- 올바른 경로 구분자를 자동으로 적용하여 경로를 크로스 플랫폼으로 만듭니다(예: Windows의 백슬래시, Linux/macOS의 슬래시).\n- __dirname:\n- 이 특별한 변수는 현재 실행 중인 스크립트가 위치한 디렉토리의 절대 경로를 보유합니다.\n- `product_information.csv`:\n- 이것은 데이터가 저장될 CSV 파일의 이름입니다.\n- path.join을 사용하면 실행 중인 스크립트의 디렉토리 내에 product_information.csv라는 이름의 파일의 전체 경로가 생성됩니다.\n\n\n\n2. fs.writeFileSync(outputFilePath, productInfoElements.join(`\\n`), `utf8`);:\n\nfs.writeFileSync:\n\n- fs 모듈의 이 동기 방식 메서드는 지정된 파일에 데이터를 직접 작성합니다.\n- 세 가지 주요 인수를 취합니다.\n\n- productInfoElements는 문자열의 배열(아마 제품 데이터를 포함한 것으로 예상)이어야 합니다.\n- join(`\\n`)은 이러한 문자열을 새 줄 문자(\\n)로 구분하여 하나의 문자열로 연결하므로 CSV 데이터로 작성하기에 적합합니다.\n\n\n\n- UTF-8로 지정된 인코딩 형식을 사용하여 파일에 올바른 텍스트 표현을 보장합니다.\n\n3. console.log('데이터가 파일로 내보내졌습니다: $'outputFilePath');:\n\n- 생성된 파일의 경로를 제공하고 데이터가 내보내졌음을 확인하는 콘솔 메시지를 출력합니다.\n\n4. await browser.close();:\n\n\n\n- 이전에 스크립트를 시작할 때 열었던 Playwright 브라우저 인스턴스를 종료합니다.\n- 시스템 자원을 해제하고 모든 웹 스크래핑 작업이 완료된 후 깔끔하게 종료됩니다.\n\n이제 터미널에서 다음 코드를 실행하세요:\n\n```js\n$ node scrap.js\n```\n\n출력 결과는 다음과 같을 것입니다.\n\n\n| 모델명          | 가격                              |\n|----------------|-------------------------------|\n| VITESSA 2.00   | Rp 9,820,000, Rp 9,820,000   |\n| VITESSA 1.00   | Rp 7,960,000, Rp 7,960,000   |\n| STYGMA LITE   | Rp 14,060,000, Rp 14,060,000 |\n| STYGMA        | Rp 18,640,000, Rp 18,640,000 |\n| STERLING R2 DISC | Rp 33,260,000, Rp 33,260,000 |\n| STERLING R1 DISC | Rp 26,200,000, Rp 26,200,000 |\n| STERLING PRO DISC | Rp 75,000,000, Rp 75,000,000 |\n| OXYDE PRO     | Rp 67,725,000, Rp 67,725,000 |\n| OXYDE ONE     | Rp 20,370,000, Rp 20,370,000 |\n| KYROSS 2.1    | Rp 18,140,000, Rp 18,140,000 |\n| KYROSS 2.00+  | Rp 17,630,000, Rp 17,630,000 |\n| KYROSS 1.1    | Rp 12,850,000, Rp 12,850,000 |\n| KYROSS 1.00   | Rp 12,850,000, Rp 12,850,000 |\n| GAVRIIL       | Rp 16,620,000, Rp 16,620,000 |\n| E-GAVRIIL     | Rp 48,280,000, Rp 48,280,000 |\n| EPSILON T6    | Rp 45,350,000, Rp 45,350,000 |\n\n여기에 전체 코드가 있습니다:\n\n```js\nconst playwright = require('playwright');\nconst fs = require('fs');\nconst path = require('path');\n\n(async () =\u003e {\n  const browser = await playwright.chromium.launch();\n  const page = await browser.newPage();\n\n  await page.goto('https://www.unitedbike.com/bikes');\n\n  const productInfoElements = await page.$$eval('.product-information', elements =\u003e elements.map(el =\u003e {\n    const caption = el.querySelector('.caption').textContent.trim();\n    const price = el.querySelector('.price').textContent.trim();\n    return `${caption},${price}`;\n  }));\n\n  const outputFilePath = path.join(__dirname, 'product_information.csv');\n\n  fs.writeFileSync(outputFilePath, productInfoElements.join('\\n'), 'utf8');\n\n  console.log(`데이터가 파일로 내보내졌습니다: ${outputFilePath}`);\n  await browser.close();\n})();\n```\n\n아마도 여기까지 JavaScript 플레이 라이팅 소개의 끝입니다. 웹 스크래핑과 playwright에 대해 더 깊이 파고들고 싶다면 이 웹 사이트를 방문해보세요.\n\n\n\n\n감사합니다! :3","ogImage":{"url":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-12-TheDataScrapersToolkitEssentialToolsandStrategies_0.png","tag":["Tech"],"readingTime":17},{"title":"Vue3와 함께 더 나은 저장소 만들기 - Pinia에서 글로벌 저장소, 중첩 및 Vue Router에 접근하기","description":"","date":"2024-05-12 23:37","slug":"2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia","content":"\n\n![이미지](/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png)\n\nVue 2에서 Vue 3로 이주하면서 Pinia가 이제 Vue 3를 위한 권장 스토어 플러그인이 되었고 Vuex가 아니게 되어 전환이 필요했습니다. 우리 아키텍처와 팀 전체가 Vuex와 작업하는 데 익숙했기 때문에 모든 스토어를 하나의 전역 변수 $store로 액세스하고 모든 곳에서 손쉽게 액세스할 수 있을 때를 좋아합니다!\n\n그래서 우리는 Pinia에서 부족해 보이는 3가지 핵심 기능을 지원하기 위해 일부 사항을 수정했습니다.\n\n- 우리 아직까지 사용 중인 this.$store를 통해 스토어에 액세스하기\n- 중첩 구조의 스토어 보유\n- 액션 내에서 Vue Router에 액세스하기\n\n\n\n# 기본 설정\n\n우리는 src/stores 안에 비슷한 디렉토리 구조를 가진 모든 스토어를 생성했습니다.\n\n```javascript\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n```\n\n주요 index.js는 중첩과 모든 것을 포함한 완전한 스토어의 진입점 역할을 하며, 중첩이 어떻게 작동하는지 등에 대한 설명은 다음 단계에서 설명하겠습니다.\n\n\n\n```js\n// src/store/index.js\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\nexport default {\n  token: null\n}\n```\n\n\n\n```js\n// src/store/auth/getters.js\n\nexport default {}\n```\n\n# 1. Pinia에서 스토어 중첩하기\n\n기본적으로 Pinia는 필요할 때 스토어를 직접 가져와서 사용하는 것이지만, 우리가 원하는 것은 그게 아닙니다. Vuex에서 했던 것처럼 쉽게 접근하고 싶습니다. 그래서 다음과 같이 했습니다.\n\n메인 스토어에 스토어 이름(예: auth)으로 새로운 상태 변수를 만듭니다.\n\n\n\n```js\n// src/store/state.js\nexport default {\n  auth: null\n}\n```\n\n이 변수를 사용하려는 Pinia 스토어에 초기화하고 설정하세요. 예를 들어, authStore 를 사용하시려면 주요 스토어의 액션에 추가하여 필요한 모든 스토어를 초기화할 수 있습니다. 예를 들어, setStores()에 다음을 추가하세요.\n\n```js\n// src/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore() // 액션 내에서 스토어를 초기화합니다.\n    },\n    ... // 다른 메서드\n  }\n})\n```\n\n주요 스토어를 초기화한 후에 이 액션을 호출하세요.\n\n\n\n```js\n// main.js\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\nexport const $store = store() // 메인 스토어 초기화\n$store.setStores() // 모든 중첩 스토어 초기화하는 액션 호출\n```\n\n그게 다야! 이제 모든 스토어에 메인 스토어에서 직접 액세스할 수 있습니다. 다음은 예시입니다 (Options API),\n\n```js\n\u003cscript\u003e\nimport { $store } from \"@/main.js\"\n\nexport default {\n    mounted() {\n       console.log($store.auth.token) // auth 상태에 액세스\n       console.log($store.auth.setToken(\"12345\")) // auth 액션 호출\n       console.log($store.someState) // 메인 스토어 상태에 액세스\n    }\n}\n\n\u003c/script\u003e\n```\n\n# 2. 핀니아 스토어를 전역적으로 접근 가능하게 만들기\n\n\n\n이제 한 변수를 통해 중첩된 상점에 접근할 수 있게 되었으니, 이제 그것을 컴포넌트 내에서 직접 액세스할 수 있도록 만들어보겠습니다. 그렇게 하려면 vue의 Global Properties를 사용하여 매핑해야 합니다. 다음과 같이 해보세요.\n\n- main.js에서 메인 상점을 초기화하십시오.\n- $store라는 전역 속성을 설정하고 해당 상점을 할당하십시오.\n- 즐기세요!\n\n```js\n// main.js\n\n...\nimport { createPinia } from 'pinia'\n...\nimport store from \"@/store\"\n...\napp.use(createPinia()) // Pinia 생성\n\nexport const $store = store() // 주 상점 초기화\napp.config.globalProperties.$store = $store // 상점을 전역적으로 액세스 가능하게 만듦\napp.config.globalProperties.$store.setStores() // 모든 중첩된 상점을 초기화하는 작업 호출\n```\n\n이것으로 끝났습니다! 이제 옵션 API를 사용하는 컴포넌트 내에서 다음과 같이 액세스할 수 있습니다:\n\n\n\n```js\n\u003cscript\u003e\nexport default {\n    mounted() {\n       console.log(this.$store.auth.token) // \"auth\" 상태에 접근하기\n       console.log(this.$store.auth.setToken(\"12345\")) // \"auth\" 액션 호출하기\n       console.log(this.$store.someState) // 메인 상점의 상태에 접근하기\n    },\n    watch: {\n        '$store.auth.token'() { console.log(\"변경 발생\") } // 워치하여 변경 감지하기\n    } \n}\n\n\u003c/script\u003e\n```\n\n# 3. 핀이아 액션 내부에서 Vue Router에 액세스하기\n\n우리는 상점에서 라우터 인스턴스를 직접 가져오고 사용하려고 시도했지만, 올바르지 않은 것처럼 보였습니다. 그때 우리는 특정 속성을 설정할 수 있는 방법을 찾았고 이렇게 설정할 수 있습니다.\n\n```js\n// main.js\n\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기서 라우터를 설정하여 상점 내에서 접근할 수 있도록 하기\napp.use(pinia)\n\n...\n```\n\n\n\n이렇게 하면 우리는 스토어 내에서 언제든지 라우터 인스턴스에 액세스할 수 있어요.\n\n```js\n// srcs/store/index.js\n\n...\nimport authStore from \"./auth\"\n...\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    logRoute() {\n       console.log(this.router) // Router Instance\n       console.log(this.router.currentRoute) // 현재 라우트 가져오기 (this.$route)\n    }\n    ... // 다른 메서드\n  }\n})\n```\n\n그리고 이렇게 함으로써 우리는 세 가지 고통을 해결했어요! 세 가지가 모두 구현된 완전한 스크립트는 다음과 같아요.\n\n```js\n디렉토리 구조\n- src\n  -\u003e store\n     -\u003e auth\n        -\u003e getters.js\n        -\u003e index.js\n        -\u003e state.js\n     -\u003e index.js\n     -\u003e state.js\n  -\u003e main.js\n  -\u003e router\n     -\u003e index.js\n```\n\n\n\n```js\n// src/store/index.js\n\nimport state from \"./state.js\"\nimport authStore from \"./auth\"\n\nexport const useStore = defineStore('core', {  \n  state: () =\u003e state,\n  actions: {\n    setStores() {\n      this.auth = authStore()\n    }\n  }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/state.js\nexport default {   \n    auth: null,\n    version: \"1.0.0\",\n}\n```\n\n```js\n// src/store/auth/index.js\n\nimport state from \"./state.js\"\nimport getters from \"./getters.js\"\n\nexport const useStore = defineStore('auth', {  \n  state: () =\u003e state,\n  getters,\n  actions: {\n    updateUserToken (token) {\n      this.token = token\n      localStorage.setItem('token', token)\n    }\n})\n\nexport default useStore\n```\n\n```js\n// src/store/auth/state.js\n\nexport default {\n  token: null\n}\n```\n\n\n\n```js \n// src/store/auth/getters.js\n\nexport default {}\n```\n\n```js\n// main.js\n...\nimport router from '@/router'\n...\nimport { createPinia } from 'pinia'\n\nlet pinia = createPinia()\npinia.use({store} =\u003e {store.router = router}) // 여기에 router를 설정하여 store 내부에서 접근할 수 있게 함\napp.use(pinia)\n...\n\nexport const $store = store() // 주요 Store 초기화\napp.config.globalProperties.$store = $store // Store를 전역적으로 접근 가능하게 함\napp.config.globalProperties.$store.setStores() // 모든 중첩 Store를 초기화하는 작업 호출\n```\n\n여기까지입니다! 같은 결과를 달성할 수 있는 다른 방법을 발견하면 알려주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png"},"coverImage":"/assets/img/2024-05-12-BetterStoresinPiniawithVue3GlobalStoresNestingandAccessingVueRouterinPinia_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML 5 게임 만들기  타일 게임 튜토리얼","description":"","date":"2024-05-12 23:33","slug":"2024-05-12-MakeHTML5GamesTileGameTutorial","content":"\n\n## 모든 필요한 것\n\n이 튜토리얼과 매칭 비디오 튜토리얼에서는 HTML 5 Canvas와 JavaScript를 사용하여 타일 게임을 코딩하는 단계를 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png)\n\n타일 게임은 기본적으로 그리드로 배열된 게임이거나 타일을 드래그하는 게임입니다. 이 경우, 우리는 객체의 나머지가 변화하는 것과 달리 어떤 객체가 변하지 않는지 알아내는 그리드 기반 게임을 가지고 있습니다. 이 게임은 또한 패턴 게임이라고도 불릴 수 있습니다.\n\n\n\n화면 하단에는 찾아야 할 \"영원한\" 물체의 수와 소요된 시간이 표시됩니다. 다섯 개의 레벨이 있으며, 각 레벨마다 더 많은 물체와 찾아야 할 더 많은 물체가 있습니다. 리더보드를 사용하여 가장 낮은 시간을 추적합니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_1.png)\n\n간단한 Tile 게임과 완전한 Tile 게임 두 가지 예제가 있습니다. 먼저 간단한 것을 살펴보셔도 좋지만, 튜토리얼에서는 완전한 게임을 만드는 단계를 안내해드립니다.\n\n## 준비하기\n\n\n\n아무도 따라 할 수 있어야 하지만, 이러한 종류의 게임을 직접 만드는 데 사용되는 많은 기술과 기술이 있습니다. 이 마법의 세계를 소개하는 ◎ 캔버스에서 코딩 창의성 가이드를 확인해보세요.\n\n![게임 만들기](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_2.png)\n\n우리는 코딩 창의성을 위한 ZIM JavaScript 캔버스 프레임워크로 게임을 만들 것입니다! ZIM으로 만들 수 있는 다양한 것들을 확인해보기를 원할 수도 있습니다. ZIM으로 만들 수 있는 많은 것들이 있는 사이트도 확인해보세요. Zapp이 많이 있는 온라인 편집기도 있습니다!\n\n## 편집기\n\n\n\n일반적으로 Microsoft의 무료이고 빠르게 설치할 수 있는 VS Code와 같은 데스크탑 편집기에서 게임을 만듭니다. 여러분이 VS Code를 사용 중이라고 가정하고 튜토리얼을 진행할 것입니다. 하지만 원한다면 온라인에서 모두 코딩할 수 있는 ZIM 편집기에서도 작업할 수 있어요.\n\n## 템플릿\n\nVS Code에서 시작하려면 tile.html이라는 새 파일을 만들고 https://zimjs.com/code에서 ZIM 템플릿을 가져오세요. \"COPY\" 버튼을 눌러 페이지에 붙여넣기하세요. ZIM 편집기에서 작업 중이라면 이 과정이 필요하지 않아요.\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_3.png\" /\u003e\n\n\n\n저장 후 브라우저에서 페이지를 확인해보세요. 파일 시스템에서 페이지를 찾아 브라우저에 끌어다 놓거나 마우스 오른쪽 버튼을 클릭하여 Chrome 등으로 열 수 있습니다. 또한 VS Code에 Open In Browser 또는 Live Server 확장 프로그램을 설치하여 핫키로 또는 마우스 오른쪽 버튼으로 바로 VS Code에서 파일을 열 수 있습니다.\n\n![MakeHTML5GamesTileGameTutorial_4](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_4.png)\n\n브라우저에서 보면 창에 맞는 회색 상자 안에 끌어올릴 수 있는 보라색 원이 있을 것입니다. 이 원, 가운데 정렬 및 드래그 코드를 삭제하세요. 테스트해보면 회색 상자가 표시될 것입니다.\n\n![MakeHTML5GamesTileGameTutorial_5](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_5.png)\n\n\n\n## 템플릿 코드 대 ZIM 편집기\n\n# 게임 만들기\n\n이 게임에서는 타이머와 소리 아이콘에 대한 ZIM 게임 및 Pizzazz 모듈을 사용할 것입니다. 프레임 내의 크기와 색상을 조정하려면 아래와 같이 코드를 조정해봅시다:\n\n```js\nimport zim from \"https://zimjs.org/cdn/016/zim_game\";\nimport zim2 from \"https://zimjs.org/cdn/016/zim_pizzazz\";\n\n// FIT, FILL, FULL 및 TAG에 대한 Frame의 Docs 참조\nnew Frame(FIT, 720, 1280, black, darker, ready);\n```\n\n\n\n만약 ZIM 편집기를 사용 중이라면, 상단의 Phone에서 P를 눌러서 portrait 모드로 설정하고, Game과 Pizzazz 상자를 위로 올려놓으세요. 또한 F.color를 black으로 설정하세요.\n\n![image](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_6.png)\n\n## 타일 살펴보기\n\n간단한 ZIM Tile()을 살펴봅시다. 이는 항목의 그리드입니다.\n\n\n\n```js\n// Tile(obj, cols, rows, spacingH, spacingV, ... lots more)\nconst pods = new Tile(new Circle(50, [pink, blue, yellow]), 6, 10, 10, 10)\n  .center();\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_7.png)\n\nCircle에 전달된 색상 배열은 ZIM VEE 값이라고 불리며, ZIM VEE의 버전 5에서 동적 매개변수를 위해 고안된 것입니다. 이를 통해 Tile은 배열에서 무작위로 항목을 선택하여 생성할 수 있습니다. Pick 문서를 참조하세요. 다른 ZIM VEE 값은 시리즈입니다. Circle 코드를 아래와 같이 수정하세요:\n\n```js\nnew Circle(50, series(pink, blue, yellow))\n```\n\n\n\n\n![Tutorial Step 8](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_8.png)\n\n각 항목을 누를 때마다 빨간색으로 변경해 봅시다. ZIM이 구축된 CreateJS는 JavaScript의 addEventListener()와 비슷한 on() 메소드를 제공하는데, 짧고 간결하며 mousedown 이벤트를 캡처할 수 있습니다. 'e'는 이벤트 객체로서 우리에게 목표물인 이벤트를 일으킨 객체와 같은 추가 정보를 제공합니다. 변화가 갱신되도록 stage update()를 사용합니다. 자동으로 업데이트하지 않아 배터리 소모를 줄입니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n e.target.color = red;\n S.update();\n});\n```\n\n![Tutorial Step 9](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_9.png)\n\n\n\n만약 선택된 색상이 분홍색인 경우에만 색상을 빨간색으로 변경할 수도 있어요:\n\n```js\npods.on(\"mousedown\", e=\u003e{\n if (e.target.color == pink) {\n  e.target.color = red;\n  S.update();\n } \n});\n```\n일정 시간마다 발생하는 ZIM interval로 색상을 변경할 수도 있어요:\n\n```js\ninterval(.2, ()=\u003e{ // 초 단위로 지정하며 호출할 함수\n // pluck은 임의의 항목을 가져오고 true는 해당 항목을 제거합니다\n pluck(pods.items, true).color = purple;\n S.update();\n}, pods.items.length); // interval을 실행할 횟수\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_10.png\" /\u003e\n\n## 포드\n\n우리 타일은 플라즈마 포드들이에요! 백 개의 포드를 담고 있는 그림을 만들었어요.\n\n우리는 Frame()의 자산 및 경로 매개변수를 사용해서 자산을 로드합니다. 혹시 ZIM 에디터를 사용 중이라면, Frame의 loadAssets() 메서드를 사용하여 완료 이벤트를 추가하세요. VS 코드에서 작업 중이라면, Tile 코드를 삭제하거나 주석 처리하고 다음 코드를 추가하세요. 기억하세요, Frame과 ready의 끝 부분을 교체하고 있습니다.\n\n\n\n```js\n// FIT, FILL, FULL 및 TAG에 대한 프레임을 참조하세요\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.org/assets/\";\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path);\nfunction ready() {\n    \n // 주어진 F (Frame), S (Stage), W (너비), H (높이)\n // 여기에 코드를 넣으세요\n\n new Pic(\"plasmapods.jpg\").center().drag();\n\n} // 준비 끝\n```\n\n만약 ZIM 편집기를 사용 중이라면, 이 코드를 사용하세요:\n\n```js\nconst assets = [\"plasmapods.jpg\"];\nconst path = \"https://zimjs.com/assets/\";\nF.loadAssets(assets, path);\nF.on(\"complete\", () =\u003e {\n\n new Pic(\"plasmapods.jpg\").center().drag();\n // 이제부터 여기에 코드를 작성하세요\n\n S.update();\n}) // loadAssets 끝\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_11.png\" /\u003e\n\n\n\n\n## 스프라이트\n\n우리는 플라즈마 팟 사진을 스프라이트 시트로 사용하여 ZIM Sprite()를 만들 것입니다. 이것에 대한 다른 용어로는 텍스처 아틀라스가 있습니다. 새로운 Pic()을 100개의 팟을 50초 동안 표시하는 새로운 Sprite()로 교체합니다. 우리는 선택 링을 쉽게 찾을 수 있도록 등록 지점을 중앙에 맞추기도 합니다.\n\n```js\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).centerReg().run(50);\n```  \n\n## 타일\n\n\n\n모든 pod를 가로와 세로 갯수를 정하는 ZIM Tile()로 타일링해보세요. 이 함수는 obj, cols, rows, spacingH, spacingV를 받습니다. 여러분의 코드를 다음과 같이 변경해보세요:\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \nlet cols = 4;\nlet rows = 5;\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n// 모든 pod를 반복하며 처리합니다\npods.loop(pod=\u003e{  \n pod.frame = rand(99); \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_12.png\" /\u003e\n\n## 고유한 Pods\n\n\n\n일부 팟들이 반복되는 것을 주목해주세요. 그것은 우리가 원치 않습니다. 그래서 0부터 99까지의 100개 인덱스를 ZIM shuffle()을 사용해서 무작위로 섞고 싶습니다.\n\n```js\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100개\nshuffle(options);\n\n// 모든 팟들을 순회합니다\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_13.png\" /\u003e\n\n## Eternals\n\n\n\n특별한 오브를 \"영원한 것\"이라고 부를 거에요. 이건 배열 조작이 조금 복잡해질 거에요.\n\n첫 번째 레벨에서는 무작위 목록에서 두 개를 빼야 해요. JavaScript의 splice()를 사용해 첫 번째 두 개를 제거하고 저장할 거에요. 우리는 타일의 랜덤하게 선택된 두 곳의 프레임 넘버를 우리의 영원한 프레임 넘버로 변경할 거에요. 여기에 전체 코드가 있어요. 위에 있는 변경 사항을 주목해 주세요.\n\n```js\n// SPRITE\nconst pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER); \n\n// LEVELS\nlet level = 0;\n\n// TILE\nlet cols = 4;\nlet rows = 5;\nlet stable = level+2; // 변하지 않는 것의 수\n\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center();\n\n// 프레임 설정\n\nconst options = [];\nloop(100, i=\u003e{options.push(i)}); // 모든 100\nshuffle(options); // 섞음\n\nconst eternals = options.splice(0,stable); // 100개 중 두 개의 프레임\n\n// 영원한 프레임의 위치 찾기\n// 가능한 모든 타일 인덱스 생성\nconst allSpots = [];\nloop(cols*rows, i=\u003e{allSpots.push(i)});\n// 영원한 프레임을 위해 두 개의 랜덤 지점 가져오기\nconst spots = shuffle(allSpots).splice(0,stable);\n\n// 모든 파드 반복\npods.loop((pod,i)=\u003e{  \n pod.frame = options[i]; \n let index = spots.indexOf(i); // i의 인덱스 찾기, 없으면 -1\n if (index \u003e= 0) pod.frame = eternals[index]; // 영원한 것으로 덮어씀 \n});\n\n// 영원한 것 테스트:\nSTYLE = {dashed:true}\nloop(spots, index=\u003e{\n // 팟의 너비는 크기 조정된 타일 안에 있음\n // 하지만 원형 링은 밖에 있으므로 크기에 맞게 조정\n new Circle(pod.width/2*pods.scale, clear, white, 10)\n  .loc(pods.items[index]);\n});\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_14.png\" /\u003e\n\n\n\n## 간격\n\n다른 팟들을 변경할 수 있게끔 ZIM interval()을 사용해봐요. 먼저 초 단위로 설정하고, 호출할 함수, 실행횟수, 그리고 바로 시작할지 여부를 넣어야 해요. 우리는 기존 팟들 사이를 반복하는 함수 주변에 간격 함수를 설정할 거예요. 그리고 이를 즉시 실행할 거예요. 각 번마다 옵션을 섞어주는 것도 잊지 않도록 하죠. 스테이지 업데이트도 필요해요.\n\n```js\nlet inter = interval(1, ()=\u003e{\n shuffle(options);\n // 모든 팟들을 반복\n pods.loop((pod,i)=\u003e{  \n  pod.frame = options[i]; \n  let index = spots.indexOf(i); // i의 spots 내 인덱스, 없으면 -1\n  if (index \u003e= 0) pod.frame = spots[index]; // 영구 프레임으로 덮어쓰기\n });\n S.update()\n}, null, true); // 바로 실행하려면 true로 설정\n```\n\n우리의 영구들은 변하지 않아요! 우리는 그들 주위에 링을 둘러보았어요... 게임을 플레이할 수 있도록 링들을 주석처리해볼까요 (선택 후 CTRL 또는 ⌘ / 를 눌러주세요)?\n\n\n\n```js\n// // test eternals:\n// STYLE = {dashed:true}\n// loop(spots, index=\u003e{\n//  // the width of the pod is inside a scaled Tile \n//  // but circle ring is outside, so adjust for scale\n//  new Circle(pod.width/2*pods.scale, clear, white, 10)\n//   .loc(pods.items[index]);\n// });\n```\n\n## 상호작용\n\n이제, pods를 눌러서 정답을 맞는지 확인하고 싶습니다. .cur()를 사용하여 타일의 커서를 활성화할 수 있습니다. 그래서 타일에 그것을 추가해 보겠습니다. 또한 타일에 mousedown 이벤트를 추가할 것입니다. 일단은... 우리가 누른 팟을 제거하는 것으로만 테스트해 보겠습니다. 다음과 같이 팟 코드를 조정하세요:\n\n```js\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n const pod = e.target;\n pod.removeFrom();\n S.update();\n});\n```\n\n\n\n## 틀린 방법과 올바른 방법\n\n타일(좇) 안의 각 아이템은 해당 인덱스와 일치하는 tileNum을 가지고 있습니다. 우리는 해당 tileNum이 eternals의 인덱스를 보유하는 spots 배열 안에 있는지 확인할 수 있습니다.\n\n```js\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 스팟의 인덱스 중 하나를 눌렀는지 알아냅니다\n // 타일의 각 요소는 tileNum을 가지고 있습니다\n // spots 배열은 영구 요소의 타일 내 인덱스를 보유합니다\n // 따라서 우리가 누른 요소의 tileNum이 spots 안에 있는지 확인합니다\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0) {  // 올바른 방법\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역이며, 크기가 조정된 타일 내부가 아닙니다\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n } else { // 틀린 방법\n  e.target.sca(.5); // 일단은 무언가를 수행합니다...\n }\n S.update();\n});\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_16.png\" /\u003e\n\n## 레벨 완료\n\n우리가 추측을 끝냈는지 어떻게 알 수 있을까요? 만약 우리가 같은 것을 두 번 이상 추측하면 어떻게 해야 할까요? 이 문제를 해결하기 위해 우리는 올바른 추측을 추적하기 위해 배열을 사용하고, 이미 배열에 있는 경우 올바른 추측으로 계산하지 않습니다. 배열의 길이가 레벨에 대한 stable 변수와 같아지면 레벨을 완료한 것입니다.\n\n```js\nconst correct = [];\nconst pods = new Tile(pod, cols, rows, 10, 10)\n .scaleTo(S, 95, 95)\n .center()\n .cur();\npods.on(\"mousedown\", e=\u003e{\n // 우리가 영구적인 위치의 색인을 눌렀는지 확인합니다.\n // 타일의 각 요소는 타일번호를 가지고 있습니다.\n // spots 배열은 영구적인 위치의 타일 인덱스를 보유합니다.\n // 따라서 누른 것의 타일번호가 spots에 있는지 확인해 봅니다.\n const ind = spots.indexOf(e.target.tileNum);\n if (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정확하고 이미 찾은 것이 아닌 경우\n  STYLE = {dashed:true, once:true}\n  // 스팟을 강조 표시합니다 - 주의, 링은 전역 변수이며, 스케일 조정된 타일 내에 있지 않습니다.\n  new Circle(pod.width/2*pods.scale, clear, white, 18).loc(e.target);\n  correct.push(ind);\n  if (correct.length == stable) nextLevel();\n } else { // 틀린 경우\n  e.target.sca(.5); // 지금은 그냥 무언가를 해 봅니다...\n }\n S.update();\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 위해 F12를 사용하세요 (또는 노트북의 기능 키 F12)\n}\n```\n\n\n\n# 레벨\n\n코드의 레벨 부분을 찾아 아래와 같이 조정하세요. 패턴을 따르지 않는 레벨 열과 행을 보유한 배열을 만들 것입니다. 또한 다가오는 makeLevel() 함수 외부에서 필요한 몇 가지 변수를 준비합니다. 기존 코드에서 inter의 let을 제거해야 합니다.\n\n```js\n// 레벨\nlet level = 0;\n\n// 각 레벨의 열과 행을 나타내는 배열을 만듭니다.\n// 이를 사용해서 더 짧은 테스트를 실행하세요\n// const levels = [[4,5],[5,7]];\nconst levels = [[4,5],[5,7],[6,8],[7,10],[8,11]];\n\nlet lastPods;\nlet inter;\n\n// 정확한 추측 링을 보유합니다.\nconst rings = new Container(W,H).addTo();\n```\n\n```js\n// 기존 간격 코드에서 let을 제거하세요:\ninter = interval(1, ()=\u003e{\n```\n\n\n\n위의 코드를 makeLevel() 함수로 감싸세요. TILE 섹션 위에서부터 시작하는 코드를 makeLevel() 함수로 감싸세요. 또한 cols와 rows를 levels 배열을 사용하도록 조정하세요. makeLevel() 함수의 맨 위 코드는 다음과 같습니다.\n\n```js\nfunction makeLevel() {\n            \n // TILE\n const cols = levels[level][0];\n const rows = levels[level][1];\n const stable = level+2; // 원하는 만큼 고정될 타일 수\n```\n\n가장 아래 부분까지 이동해서 VS Code에서 end ready if 내에 남은 makeLevel() 함수의 끝 부분을 추가하세요. 그리고 함수를 호출하세요.\n```js\n} // makeLevel 함수의 끝\n\nmakeLevel();\n```\n\n\n\n## 단계 진행하기\n\n새 단계를 위한 새로운 타일을 만들기 전에 이전 타일과 링을 제거해야 합니다. 이미 rings Container를 만들었습니다. 이것을 사용하여 링을 보관할 것입니다. 그러므로 링 코드를 조정하세요. 우리는 링을 loc()에 추가했다는 것을 주목하세요. 나중에 rings의 모든 하위 항목을 제거할 수 있게 될 것입니다.\n\n```js\nnew Circle(pod.width/2*pods.scale, clear, white, 18)\n .loc(e.target, null, rings);\n```\n\n\n\n이제 nextLevel() 함수 위에 이 코드를 추가하세요. 이것은 NEXT 레벨이며 makeLevel이 아닌 것입니다. 여기서는 pods을 alpha 0에서 animate하여 불투명도를 조절합니다. 이렇게 하면 레벨 간에 서서히 사라집니다. 현재 pods을 lastPods에 저장하여 다음 레벨로 이동할 때 기억합니다. 반지를 퇴장시키고 완료되면 제거합니다.\n\n```js\n// LEVEL 처리\n\npods.alp(0).animate({\n wait:lastPods?1:0,\n props:{alpha:1},\n time:.5\n});\nlastPods = pods;\n\n// 반지를 숨기고 지우고 표시합니다.\nrings.top().animate({\n rewind:true,\n time:.5,\n props:{alpha:0},\n rewindCall:()=\u003e{\n  rings.removeAllChildren();\n }\n});\n\nfunction nextLevel() {\n zogg(\"다음 레벨\"); // 콘솔을 열려면 F12 키(혹은 노트북의 Function F12 키)를 사용하세요\n}\n```\n\nnextLevel() 함수 안에 이 코드를 추가하세요. 마지막 pods를 animate하여 사라지게 하고, 마지막 간격을 지우고, 레벨을 늘리고, 게임의 끝인지 확인한 후 makeLevel()을 호출하세요.\n\n```js\nfunction nextLevel() {\n\n // 마지막 pods를 animate하여 사라지게 함\n // 캐싱은 모바일에서의 부드러운 애니메이션에 도움이 됨\n lastPods.cache().animate({\n  props:{alpha:0},\n  time:.5,\n  call:target=\u003e{target.dispose();}\n });   \n\n inter.clear(); // 현재 간격을 지움\n\n level++;\n if (level \u003c levels.length) { // 더 많은 레벨\n  makeLevel();\n } else { // 게임 종료\n\n  zogr(\"게임 끝\");   \n  \n } // 게임 종료\n\n} // nextLevel의 끝\n```  \n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_17.png\" /\u003e\n\n## 발신자\n\n선택 사항을 ZIM Emitter()로 향상시킬 수 있습니다. 이는 입자를 방출합니다. 발신자를 링 컨테이너 아래에 만들어보세요:\n\n```js\n// 정확한 추측 링을 보관합니다\nconst rings = new Container(W, H).addTo();\n\nSTYLE = {dashed: true};\nconst emitter = new Emitter({\n obj: new Circle(90, clear, series(pink, purple), 18),\n interval: .3,\n gravity: 0,\n force: 0,\n animation: {props: {scale: 5},\n startPaused: true\n});\nSTYLE = {}\n```\n\n\n\nemitter에서 pod의 mousedown 이벤트가 발생했을 때 spurt() 함수를 호출하세요. 기존의 nextLevel() 함수 호출 아래에 추가하세요.\n\n```js\ncorrect.push(ind);\nif (correct.length === stable) nextLevel();\n\nemitter.loc(e.target).spurt(2);\nemitter.particles.top(); // 입자들이 emitter와 별개로 존재하기 때문에 tricky 함\n```\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_18.png)\n\n흰색 링은 emitter 작업이 대부분 완료될 때까지 표시되지 않아야 하므로 기존 링 Circle에 페이드 인 애니메이션을 추가하세요. 세미콜론(;)을 확인해주세요.\n\n\n\n```js\n새 Circle(pod.width / 2 * pods.scale, clear, white, 18)\n .loc(e.target, null, rings)\n .alp(0)\n .animate({\n  wait: .5,\n  alpha: .9\n });\n```\n\n## 보상 화면\n\n우리는 한 수준에서 다른 수준으로 애니메이션화되는 것에 만족하지 않습니다. 어떤 보상이 필요합니다. 소리는 도움이 될 것입니다... 하지만 이쁜 구체들이 있습니다. 플레이어에게 수집한 영구 구체들을 보여주는 약간 더 많은 시간을 쓰도록 합시다. 기존의 lastPods animate 코드 하단에 기다림을 조절하고 한 번 보여주세요!\n\n```js\nlastPods.cache().animate({\n wait:1, // 기다리기 추가\n props: {alpha: 0},\n time: .5,\n call: target =\u003e {target.dispose();}\n});\n\n// 영구 보여주기 – 플레이어에게 잠시 휴식 시간을 줌과 더 큰 플라즈마를 보여줍니다\nconst showcase = new Tile({\n obj: pod.clone().sca(1.5),\n cols: 2,\n rows: 3,\n spacingH: 20,\n spacingV: 20,\n count: stable\n})\n .center();\nshowcase.loop((pod, i) =\u003e {\n // eternals는 영구 구체들의 인덱스를 저장합니다\n pod.run({startFrame: eternals[i], endFrame: eternals[i]});\n});\nshowcase\n .alp(0)\n .animate({\n  props: {alpha: 1},\n  wait: 1.5,\n  time: .5,\n  rewindWait: 1,\n  rewind: true,\n  call: target =\u003e {target.dispose();}\n });\n\ninter.clear(); // 현재 간격을 지웁니다\n```\n\n\n\n이제 우리는 팟 애니메이트 대기 시간을 조정해야 합니다:\n\n```js\npods.alp(0).animate({\n wait:lastPods?3.5:0, // 3.5로 변경\n props:{alpha:1},\n time:.5\n});\n```\n\n# 마무리\n\n이제 기본 게임 구성은 완료되었습니다. 실제 게임을 먼저 코딩하고 이를 수행할 수 있고 마음에 드는지 확인해야 합니다. 그런 다음 소리, 점수, 패널, 인터페이스 등과 같은 최종 터치를 추가하십시오. 종종 이미지는 마지막에 남겨두지만 스프라이트와 함께 작업하는 것도 좋았습니다.\n\n\n\n## 더 많은 에셋\n\n로고를 위한 폰트와 몇 가지 사운드를 로드할 예정입니다. Frame() 영역에 이를 추가하세요. 기존 Frame() 함수에는 추가된 progress 매개변수가 있음을 주의하세요.\n\n```js\nconst audioSpriteData = {\n  src: \"audiosprite.mp3\",\n  audioSprite: [\n    // [id, 시작시간(초), 끝시간(초)] \n    // 프리미어에서 확인 - 다른 형식들도 존재함\n    ['blackball', 1.041, 2.475],\n    ['bounce', 3.567, 4.232],\n    ['end', 5.396, 9.315],\n    ['help', 10.373, 10.499],\n    ['powerdown', 11.607, 14.254],\n    ['powerup', 15.672, 17.081],\n    ['slow', 18.354, 19.163],\n    ['start', 20.151, 23.594],\n    ['submit', 24.931, 27.673],\n    ['wallend', 28.632, 29.351],\n    ['wallstart', 30.640, 32.323]\n  ]\n};\n\nconst assets = [\"gf_Honk\", \"plasmapods.jpg\", \"intro.mp3\", audioSpriteData];\nconst path = \"https://zimjs.com/assets/\";\nconst progress = new Waiter();\n\nnew Frame(FIT, 720, 1280, black, darker, ready, assets, path, progress);\nfunction ready() {\n```\n\n만약 ZIM Editor를 사용 중이라면, 아래와 같이 사용하세요:\n\n\n\n```js\nF.loadAssets(assets, path, progress);\n```\n\n## 로고\n\n로고를 맨 위에 추가하세요. 로고에 사용자 지정 글꼴이 얼마나 더 좋은지 확인해보세요! Google Fonts로 가는 바로 가기를 사용하면 assets에 있는 gf_… 를 사용하는 것이 정말 쉬워집니다. ready 함수 내부의 맨 위에 다음을 추가하세요:\n\n```js\nnew Label(\"ETERNAL ORBS\", 110, \"Honk\").pos(0, 50, CENTER);\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_19.png\" /\u003e\n\n## 컨트롤\n\n우리는 밑부분에 인터페이스를 추가할 것입니다. 이 인터페이스에는 음소거 버튼, 찾아야 할 무한루프 수를 보여주는 라벨, 그리고 타이머가 있을 것입니다. 이를 위해 타일을 사용하여 이쁘게 정렬할 것입니다. 이 코드를 로고 아래에 추가해주세요.\n\n```js\n// 밑에 있는 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n})\n\nconst find = new Label(\"찾기 2\", 85, \"Honk\");\n\nconst timer = new Timer({\n backgroundColor: new GradientColor([yellow, red], 90),\n down: false,\n time: 0\n});\n\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM);\n```\n\n\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_20.png)\n\n각 레벨을 찾기 위한 'eternals'의 수를 업데이트해야 합니다. HANDLE LEVELS 섹션에 다음 라인을 추가해주세요:\n\n```js\n// HANDLE LEVELS\n\nfind.text = \"FIND \" + stable;\n```\n\n## Sound\n\n\n\n위에, 로고 아래에 우리의 모든 소리를 준비해봅시다. 우리는 새로운 Aud()를 사용해서 소리 객체를 만들어요. 그리고 우리가 그 소리를 듣고 싶을 때에는 play() 메소드를 사용해요. 상호작용을 할 때 까지 소리를 재생할 수 없지만, 그 부분은 맨 처음에 LeaderBoard를 추가하여 처리할 거에요.\n\n```js\n// SOUND\n// 파일, 볼륨, 루프, 등 여러 가지가 있어요\nconst introSound = new Aud(\"intro.mp3\", .1, true); \nconst startSound = new Aud(\"wallstart\", .3);\nconst rightSound = new Aud(\"powerup\", .3);\nconst wrongSound = new Aud(\"wallend\", .3);\nconst endSound = new Aud(\"submit\", .3);\nlet intro; // 이 변수는 mute fading을 위해 introSound SoundInstance를 보관할 거에요\n```\n\n코드 전체에 소리를 뿌리뿌리 흩뿌려봅시다. LeaderBoard를 소개할 때 intro 소리를 들려줄 거에요. play() 코드가 들어간 줄을 추가하고 있어요.\n\n```js\npods.alp(0).animate({\n wait: lastPods ? 3.5 : 0,\n waitedCall: () =\u003e {if (!mute.toggled) startSound.play();},\n props: {alpha: 1},     \n time: .5\n});\n```\n\n\n\n그리고 파드의 마우스 다운시에 play() 코드를 추가하고 있습니다.\n\n```js\nif (ind \u003e= 0 \u0026\u0026 !correct.includes(ind)) { // 정답이고 이미 찾은 것이 아니라면\n if (!mute.toggled) rightSound.play();\n```\n\n틀린 추측에서는 play() 코드를 추가하고 있습니다.\n\n```js\n} else { // 틀렸을 때\n if (!mute.toggled) wrongSound.play();\n e.target.sca(.5); // 일단은 무언가를 해보세요...      \n}\n```\n\n\n\n## 리더 보드\n\n기존 BOTTOM INTERFACE 코드 아래에 다음 코드를 추가하세요. bottom을 removeFrom()하여 Play 버튼을 누를 때까지 표시되지 않도록 하고 bottom을 addTo() 하세요. 코드 맨 아래에는 이미 가지고 있는 SPRITE 코드가 있으므로 중복해서 작성하지 말아주세요. 그리고 startGame() 함수의 괄호를 닫아주세요. 그 다음 작업을 해보겠습니다.\n\n```js\nconst bottom = new Tile([mute, find, timer], 3, 1, 80, 0, true)\n .pos(0, 40, CENTER, BOTTOM)\n .removeFrom();\n\n// 리더 보드\nconst lb = new LeaderBoard({\n data: \"Y9HC384\",\n corner: 0,\n backgroundColor: dark,\n titleColor: light,\n title: \"Lowest Finish Times\",\n reverse: true\n}).scaleTo(S, 90, 90).center().mov(0, 20);\nlb.on(\"close\", startGame);\n\nconst play = new Button({\n label: \"PLAY\",\n backgroundColor: new GradientColor([orange, purple], 90)\n})\n .pos(0, 40, CENTER, BOTTOM).tap(() =\u003e {\n  lb.removeFrom();\n  startGame();\n });\n\n\n// 시작 게임\n\nfunction startGame() {\n\n bottom.addTo();\n timer.time = 0;\n\n // 나중에 음소거하려면 play SoundInstance를 저장하세요\n if (!mute.toggled \u0026\u0026 !intro) intro = introSound.play(); \n if (!mute.toggled) startSound.play();\n\n play.removeFrom();\n\n // SPRITE\n const pod = new Sprite(\"plasmapods.jpg\", 10, 10).reg(CENTER);\n}\n\nstartGame 함수를 호출한 후 makeLevel()을 호출하여 startGame() 함수를 종료하세요. 문서를 올바르게 들여쓰기하여 형식을 유지해주세요. VS Code에서 오른쪽 클릭하여 \"Format Document\"를 실행해주세요.\n\n\n\n } // makeLevel 함수 끝\n\n makeLevel();\n\n} // startGame 함수 끝\n\n![MakeHTML5GamesTileGameTutorial 이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_21.png)\n\n## 음소거 버튼\n\n음소거 기능을 추가하세요. 기존 버튼에 expand()와 tap()을 추가하세요. expand는 모바일에서 쉽게 누를 수 있게 만듭니다.\n\n\n\n// 하단 인터페이스\nconst mute = new Button({\n width: 80,\n backing: makeIcon(\"sound\", orange).sca(2),\n toggleBacking: makeIcon(\"mute\", orange).sca(2)\n}).expand().tap(() =\u003e {\n if (mute.toggled \u0026\u0026 intro) intro.fade(0);\n else if (!mute.toggled \u0026\u0026 intro) intro.fade(.1);\n});\n\n\u003cimg src=\"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_22.png\" /\u003e\n\n## 게임 종료\n\n여기까지 오지 못할 것 같았나요? 오답을 수정해봅시다. 틀린 답을 맞출 때마다 타이머를 늘릴 겁니다.\n```\n\n\n\n```js\n} else { // 잘못됨\n if (!mute.toggled) wrongSound.play();\n timer.time += 10;   \n}\n```\n\n게임의 조건이 끝날 때, 시간을 리더보드에 추가하고 모든 것을 멈추기 위해 끝 코드를 추가합니다.\n\n```js\n} else { // 게임 종료\n\n // 게임 끝났습니다\n\n inter.clear();\n rings.animate({\n  time: .2,\n  props: {alpha: 0}\n });\n // 점수를 리더보드로 전송\n // 상위 열 개 안에 들지 않으면 무시됩니다\n lb.score(timer.time);\n // 최종 쇼케이스를 보기 위해 시간을 제공합니다\n timeout(3.5, () =\u003e {\n  bottom.removeFrom();\n  pods.dispose();\n  rings.dispose();\n  lb.addTo();\n  play.addTo();\n  if (!mute.toggled) endSound.play();\n });\n\n} // 게임 종료의 끝\n```\n\n이를 쉽게 테스트하기 위해 레벨을 줄일 수 있습니다. LEVELS 코드에서 찾아서 게임을 두 레벨(또는 한 레벨) 후에 종료되도록 변경하세요. 도전적인 레벨을 다시 시도하려면 다시 변경해야 합니다!\n\n\n\n```js\n// 이것은 각 레벨마다 열과 행이 얼마나 있는지 나타냅니다\n// 간단한 테스트 실행에 사용하세요\nconst levels = [[4,5],[5,7]];\n// const levels = [[4, 5], [5, 7], [6, 8], [7, 10], [8, 11]];\n```\n\n# 결론\n\n이 튜토리얼에서는 로고와 커스텀 폰트, 리더보드, 오디오 스프라이트와 음소거 버튼을 포함한 완전한 타일/패턴 게임을 만들기 위해 시간을 들였습니다. 또한, 레벨, 리워드 이밋터 및 스프라이트 텍스처 애트라스를 포함하였습니다.\n\n우리는 ZIM을 사용하여 여러 가지 타일형 게임을 만들었습니다. 게임 및 ZIM 예제에 대해 ZIM 배너 페이지를 살펴보세요.\n\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_23.png)\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_24.png)\n\nZIM의 Learn Apps 섹션에는 많은 종류의 타일 게임을 사용하는 e러닝 게임이 있습니다. 메모리 게임과 스크램블 퍼즐과 같은 게임들이 있습니다.\n\n![이미지](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_25.png)\n\n\n\n**HTML 5 Games 튜토리얼 및 자료**\n\n- HTML 5 게임 만들기 - 이소메트릭 보드 게임 튜토리얼\n- HTML 5 게임 만들기 - 사이드 스크롤러 게임 튜토리얼\n\n더 많은 ZIM 기능과 ZIM 예제가 있습니다. ZIM 포럼이나 디스코드에 참여하시면 즐거운 도움을 받을 수 있습니다!\n\nDr Abstract\n\n\n\n![MakeHTML5GamesTileGameTutorial](/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_26.png)","ogImage":{"url":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png"},"coverImage":"/assets/img/2024-05-12-MakeHTML5GamesTileGameTutorial_0.png","tag":["Tech"],"readingTime":22},{"title":"현대 웹을 위해 새롭게 탄생한 자동완성 상자","description":"","date":"2024-05-12 23:31","slug":"2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb","content":"\n\n## 모든 곳에서 작동하며 의존성이 전혀 없는 다재다능한 접근 가능한 자동완성 웹 구성 요소.\n\n![이미지](/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png)\n\n생각해 보면, 텍스트 상자에서의 자동완성은 일종의 상용품이 되어가고 있고, 수많은 UI 프레임워크가 자체적인 구현을 제공하고 있습니다.\n\n큰 프레임워크를 사용하지 않거나 자동완성 UI 구성 요소를 포함한 기존 디자인 시스템을 사용하지 않고 현대적인 웹 앱을 구축할 때, 우리는 혼자서 해결해야 합니다.\n\n\n\n지금까지.\n제가 AutoComplete ECMAScript 클래스를 작성했고 해당 클래스를 구현하는 `omni-box`라는 표준 기반 웹 컴포넌트를 만들었습니다.\n\n# OmniBox\n\nAutoComplete 클래스는 모든 기본 로직을 호스팅하며, 텍스트 기반 HTML 입력 요소에 자동 완성 로직을 연결하는 데 사용할 수 있습니다.\n\n\n\nOmniBox 웹 컴포넌트는 검색 입력을 생성하고 AutoComplete 컴포넌트를 연결합니다.\n\n## 왜 OmniBox를 사용해야 하는가?\n\n이는 의존성이 전혀 없는 매우 다재다능한 자동완성 컴포넌트로, 모든 브라우저에서 실행되며 웹 컴포넌트로 구현되었습니다. OmniBox라는 이름은 이 컴포넌트로 간단한 자동완성 시나리오를 용이하게 할 수 있을 뿐만 아니라 LinkedIn, Facebook 또는 Office.com에서 보는 것처럼 복잡한 다중 소스 시스템도 구현할 수 있다는 사실을 나타냅니다.\n\n자동완성 결과는 고정(Array) 데이터에서 가져올 수 있지만, REST API와 같은 여러 소스와 연동해야 하는 더 복잡한 상황에서도 작업할 수 있습니다. 여러 호출 결과를 집계해야 하는 상황도 다룰 수 있습니다.\n\n\n\n또한 자동 완성 결과 항목을 선택할 때 단순히 입력란을 채우는 대신 사용자 정의 작업을 호출하도록 구성할 수도 있습니다.\n\n# 기능\n\n- 표준 기반의 웹 컴포넌트.\n- 의존성 없음.\n- 타입하는 대로 자동 완성 결과가 집계되는 구성 가능한 자동 완성 카테고리.\n- 각 카테고리에는 Array, Function 또는 Promise를 반환할 수 있는 'getItems' 속성이 있습니다.\n- 각 카테고리에는 정렬 색인이 있습니다.\n- 각 카테고리에는 'getItems'가 호출되는 시점을 결정하는 트리거 함수가 있습니다.\n- 각 카테고리에는 항목 선택을 위해 정의된 사용자 정의 작업을 가질 수 있습니다.\n\n# CodePen\n\n\n\n아래 Markdown 형식을 사용하여 CodePen에서 컴포넌트를 살펴보세요:\n\n# 더 많은 표준 기반의 유용한 것들\n\n다음의 탭 스트립도 확인해보세요. Marc van Neerven 저, CTO-as-a-Service 블로그의 The TabStrip, reinvented for the Modern Web 기사에서도 볼 수 있습니다.\n\n## PurePWA\n\n\n\n저는 PurePWA를 소개하는 \"웹 개발의 급격한 전환\"의 저자입니다. 이 책에서는 시맨틱 HTML과 ECMAScript를 사용하여 현대적인 PWA를 구축할 때 프레임워크, 빌드 시스템 또는 기타 종속성 없이 어떤 가능성이 있는지 탐구하고 있어요.\n\n🔗 LinkedIn에서 제 소식을 받아보세요","ogImage":{"url":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png"},"coverImage":"/assets/img/2024-05-12-TheAutoCompleteboxreinventedfortheModernWeb_0.png","tag":["Tech"],"readingTime":2},{"title":"Angular 18의 새로운 기능 정리 비교","description":"","date":"2024-05-12 23:30","slug":"2024-05-12-Angular18NewFeatures","content":"\n\u003cimg src=\"/assets/img/2024-05-12-Angular18NewFeatures_0.png\" /\u003e\n\n웹 어플리케이션을 구축하기 위한 주요 프레임워크 중 하나인 Angular은 현대 웹 개발 요구 사항을 충족하기 위해 지속적으로 발전해 왔습니다. 각 버전마다 새로운 기능, 최적화, 개선 사항을 가져왔습니다. 커뮤니티는 Angular 18의 릴리즈를 열심히 기다리며, 다음 주요 버전에서 기대할 수 있는 것을 살펴보겠습니다.\n\nAngular 18은 2024년 5월에 발매 예정이며, 이미 다가오는 버전에 포함될 확정된 여러 기능이 있어서 이번 버전에서 논의할 수 있습니다.\n\n# 함수를 이용한 경로 리디렉션\n\nAngular 18에서는 리디렉트를 관리하는 새로운 기능이 도입되었습니다. 이제 라우트 객체의 redirectTo 속성 내에서 리디렉트 URL을 지정하기 위해 문자열 대신 함수를 사용할 수 있습니다. 이 향상된 기능은 라우팅에서 더 많은 유연성을 제공하며 새로운 가능성을 열어줍니다.\n\n해당 함수 내에서는 URL 정보를 포함하는 객체에 액세스가 허용됩니다.\n\n```js\n//\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: \"/page2\",\n    pathMatch: \"full\",\n  },\n];\n\n//redirectTo function\nexport const routes: Routes = [\n  {\n    path: \"page1\",\n    redirectTo: (url) =\u003e {\n      return \"/page2\";\n    },\n    pathMatch: \"full\",\n  },\n];\n```\n\n함수는 문자열 또는 UrlTree를 반환해야 합니다. Angular에서 UrlTree는 URL을 나타내는 데이터 구조입니다. 이는 Angular 라우터가 응용 프로그램 내에서 탐색하는 데 사용하는 URL의 구문 분석된 표현입니다. UrlTree에는 URL 세그먼트, 쿼리 매개변수 및 조각과 같은 정보가 캡슐화되어 있습니다. 이는 Angular의 라우팅 시스템에서 URL 조작, 탐색 및 라우팅 가드와 같은 작업에 일반적으로 사용됩니다. UrlTree를 사용함으로써 Angular은 응용 프로그램 내에서 일관된 신뢰할 수 있는 탐색 동작을 보장합니다.\n\n“url\" 객체에는 라우트에 관한 모든 정보가 포함되어 있습니다. 이 정보에는 데이터, 제목, 쿼리 매개변수, 라우팅 세그먼트 등이 포함됩니다.\n\n# 새로운 RedirectCommand\n\nAngular 버전 18에서는 NavigationExtras를 처리하기 위해 설계된 새 RedirectCommand 클래스가 소개되었습니다. 이 추가로 Guards 및 Resolvers 내에서 향상된 리디렉션 기능을 구현할 수 있습니다. RedirectCommand 클래스의 통합은 유지보수성과 유연성을 크게 향상시키며, Angular 애플리케이션에서 복잡한 네비게이션 패턴을 보다 쉽게 관리할 수 있습니다.\n\n```js\nconst route: Route = {\n  path: \"page1\",\n  component: PageComponent,\n  canActivate: [\n    () =\u003e {\n      const router: Router = inject(Router);\n      const urlTree: UrlTree = router.parseUrl(\"./page2\");\n      return new RedirectCommand(urlTree, { skipLocationChange: true });\n    },\n  ],\n};\n```\n\n# ng-content 기본 콘텐츠\n\n이제는 ng-content 태그에 기본 콘텐츠를 넣을 수 있습니다. 이 기능은 ng-content 요소의 논리적 확장입니다. 콘텐츠를 위한 태그가 있는 경우, 기본 콘텐츠도 해당 태그 자체에 포함되어야 합니다.\n\n예를 들어, 템플릿에서 ng-content가 포함된 컴포넌트가 있다면 제공된 콘텐츠가 없을 경우 렌더링될 기본 콘텐츠도 포함할 수 있습니다.\n\n```js\n\u003cdiv\u003e\n  \u003ch1\u003e헤더\u003c/h1\u003e\n  \u003cng-content\u003e기본\u003c/ng-content\u003e\n\u003c/div\u003e\n```\n\n# Zoneless applications\n\nSignals의 주요 목표 중 하나는 zone.js 없이 응용 프로그램이 작동할 수 있도록 하는 것입니다. 초기에는 이 것이 Signal Components를 통해서만 가능했을 것입니다. 그러나 그 이후에 상황이 변화했습니다. 이제 Angular 18부터는 Signal Components를 사용하지 않고도 이것을 달성할 수 있을 것입니다. Angular 18은 다음 달에 발표될 예정입니다.\n\nMatthieu Riegler와 Enea Jahollari는 이 주제에 집중한 각각의 기사를 게시했습니다.\n\nMatthieu의 기사는 새로운 하이브리드 변경 감지 시스템을 탐구하며, 어느 Signal 변경, 비동기 파이프 또는 markForCheck를 호출하는 다른 작업이 zone.js 외부에서 발생하더라도(예외적인 상황) 이제 자동으로 변경 감지가 트리거될 것이라고 합니다.\n\nEnea의 글은 zone.js를 완전히 비활성화하고 응용 프로그램 상태 변경을 관리하는 데 이러한 새로운 트리거 메커니즘에만 의존하는 과정을 논의합니다.\n\n# 읽어 주셔서 감사합니다!\n\n여러분의 생각을 듣고 싶어요. 그러니 자유롭게 댓글을 남겨주시거나 박수를 보내거나 팔로우해 주세요. 👏\n\n이 글이 마음에 들었다면, 여러분의 커뮤니티, 기술 친구 및 흥미를 가질 것으로 생각되는 다른 사람들과 공유하는 것도 생각해보세요. LinkedIn에서도 제 소식을 더 받아보기 위해 팔로우를 잊지 말아주세요!\n","ogImage":{"url":"/assets/img/2024-05-12-Angular18NewFeatures_0.png"},"coverImage":"/assets/img/2024-05-12-Angular18NewFeatures_0.png","tag":["Tech"],"readingTime":3}],"page":"121","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"121"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>