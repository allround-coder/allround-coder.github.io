<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/53" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/53" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="앵귤러 Observable의 포괄적 가이드" href="/post/2024-06-20-AComprehensiveGuidetoAngularObservables"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러 Observable의 포괄적 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러 Observable의 포괄적 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러 Observable의 포괄적 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenLayers를 사용하여 Ionic 앱 만들기" href="/post/2024-06-20-BuildinganIonicAppwithOpenLayers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenLayers를 사용하여 Ionic 앱 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenLayers를 사용하여 Ionic 앱 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">OpenLayers를 사용하여 Ionic 앱 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러의 파이프" href="/post/2024-06-20-PipesinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러의 파이프" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-PipesinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러의 파이프" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러의 파이프</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular i18n을 사용하여 성능 향상과 구성 요소 수준 조직을 위한 사용자 정의 번역 서비스" href="/post/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular i18n을 사용하여 성능 향상과 구성 요소 수준 조직을 위한 사용자 정의 번역 서비스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular i18n을 사용하여 성능 향상과 구성 요소 수준 조직을 위한 사용자 정의 번역 서비스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular i18n을 사용하여 성능 향상과 구성 요소 수준 조직을 위한 사용자 정의 번역 서비스</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular의 새로운 let 구문 탐험 템플릿 변수 선언 강화" href="/post/2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular의 새로운 let 구문 탐험 템플릿 변수 선언 강화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular의 새로운 let 구문 탐험 템플릿 변수 선언 강화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular의 새로운 let 구문 탐험 템플릿 변수 선언 강화</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ionic 앱에 지문 및 얼굴 인식을 통합해보세요" href="/post/2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ionic 앱에 지문 및 얼굴 인식을 통합해보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ionic 앱에 지문 및 얼굴 인식을 통합해보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Ionic 앱에 지문 및 얼굴 인식을 통합해보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트" href="/post/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 접근성 모든 사용자를 위해 만드는 방법" href="/post/2024-06-20-AccessibleAngularBuildingforEveryUser"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 접근성 모든 사용자를 위해 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 접근성 모든 사용자를 위해 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 접근성 모든 사용자를 위해 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 " href="/post/2024-06-20-HowtoCreateanAngularProjectfromScratch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular afterRender, afterNextRender 새로운 phases API" href="/post/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular afterRender, afterNextRender 새로운 phases API" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular afterRender, afterNextRender 새로운 phases API" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular afterRender, afterNextRender 새로운 phases API</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link posts_-active__YVJEi" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"앵귤러 Observable의 포괄적 가이드","description":"","date":"2024-06-20 00:41","slug":"2024-06-20-AComprehensiveGuidetoAngularObservables","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\" /\u003e\n\n# 소개\n\nAngular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.\n\nObservables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 옵저버블이란 무엇인가요?\n\n옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:\n\n- 옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.\n- 옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.\n- 옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.\n\n옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Observable Creation\n\n앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:\n\n- 처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:\n\n```js\nconst myObservable = new Observable(observer =\u003e {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:\n\n```js\nimport { of } from 'rxjs';\n\nconst myObservable = of(1, 2, 3);\n```\n\n- 이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { fromEvent } from 'rxjs';\n\nconst button = document.getElementById('myButton');\nconst clickObservable = fromEvent(button, 'click');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.\n\n# Observables와 Operators\n\nOperators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:\n\n- map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3);\nconst squared = numbers.pipe(map(x =\u003e x * x));\n\nsquared.subscribe(x =\u003e console.log(x)); // 출력: 1, 4, 9\n```\n\n- filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3, 4, 5);\nconst evenNumbers = numbers.pipe(filter(x =\u003e x % 2 === 0));\n\nevenNumbers.subscribe(x =\u003e console.log(x)); // 출력: 2, 4\n```\n\n- merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of, merge } from 'rxjs';\n\nconst numbers1 = of(1, 2, 3);\nconst numbers2 = of(4, 5, 6);\nconst merged = merge(numbers1, numbers2);\n\nmerged.subscribe(x =\u003e console.log(x)); // Output: 1, 2, 3, 4, 5, 6\n```\n\nAngular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.\n\n# Observables 구독하기\n\nObservable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\n\nconst numbers = of(1, 2, 3);\nnumbers.subscribe(\n  value =\u003e console.log(value),\n  error =\u003e console.error(error),\n  () =\u003e console.log('Completed')\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:\n\n- 첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.\n- 두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.\n- 세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.\n\n이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObservables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.\n\n# Angular 서비스에서 Observables 사용하기\n\nAngular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  private apiUrl = '\u003chttps://jsonplaceholder.typicode.com/posts\u003e';\n  constructor(private http: HttpClient) {}\n  getPosts(): Observable\u003cany[]\u003e {\n    return this.http.get\u003cany[]\u003e(this.apiUrl);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 https://jsonplaceholder.typicode.com/posts인 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다. \n\n컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003ch1\u003ePosts\u003c/h1\u003e\n    \u003cul\u003e\n      \u003cli *ngFor=\"let post of posts\"\u003e{{ post.title }}\u003c/li\u003e\n    \u003c/ul\u003e\n  `\n})\nexport class AppComponent {\n  posts: any[];\n  constructor(private dataService: DataService) {}\n  ngOnInit() {\n    this.dataService.getPosts().subscribe(\n      data =\u003e this.posts = data,\n      error =\u003e console.error(error),\n      () =\u003e console.log('Posts loaded')\n    );\n  }\n}\n```\n\n이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.\n\n# Observables 조합하기\n\nObservables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:\n\n- Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport { interval, merge } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst merged = merge(source1, source2);\r\nmerged.subscribe(\r\n  value =\u003e console.log(value)\r\n);\r\n```\r\n\r\n이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.\r\n\r\n- CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:\r\n\r\n```js\r\nimport { interval, combineLatest } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst combined = combineLatest(source1, source2);\r\ncombined.subscribe(\r\n  value =\u003e console.log(value)\r\n);\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n- Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of, zip } from 'rxjs';\n\nconst source1 = of(1, 2, 3);\nconst source2 = of('a', 'b', 'c');\nconst zipped = zip(source1, source2);\nzipped.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.\n\n# 데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기\n\n오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:\n\n- Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst mapped = source.pipe(map(value =\u003e value * 2));\nmapped.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.\n\n- Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst filtered = source.pipe(filter(value =\u003e value % 2 === 0));\nfiltered.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.\n\n- Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { reduce } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst reduced = source.pipe(reduce((acc, value) =\u003e acc + value));\nreduced.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.\n\n# Subjects를 사용하여 값을 방출하기\n\nObservable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.\n\n다음은 Angular에서 Subject를 생성하는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Subject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new Subject\u003cstring\u003e();\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.\n\nSubject를 다른 Observable처럼 구독할 수 있습니다:\n\n```js\nmyComponent.mySubject.subscribe(\n  value =\u003e console.log(value)\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.\n\n한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:\n\n```js\nimport { BehaviorSubject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new BehaviorSubject\u003cstring\u003e('initial value');\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 `initial value`로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSubject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.\n\n# 결론\n\nAngular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.\n\n이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.\n\n다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png"},"coverImage":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png","tag":["Tech"],"readingTime":12},{"title":"OpenLayers를 사용하여 Ionic 앱 만들기","description":"","date":"2024-06-20 00:40","slug":"2024-06-20-BuildinganIonicAppwithOpenLayers","content":"\n\n요즘 애플리케이션에서 대화식 및 동적 지도가 점점 필요해지면, OpenLayers와 같은 강력한 지도 라이브러리를 모바일 애플리케이션에 통합하는 것이 중요합니다. 이 튜토리얼에서는 Angular의 독립 구성 요소 기능을 활용하여 OpenLayers를 사용하는 Ionic 앱을 생성하는 과정을 안내합니다.\n\n# 소개\n\nOpenLayers는 모든 지도 요구에 대한 고성능이며 각종 기능을 갖춘 라이브러리입니다. Ionic의 강력한 모바일 앱 구축 프레임워크와 결합하면 강력하고 시각적으로 매력적인 지도 기반 애플리케이션을 만들 수 있습니다. 함께 시작해보겠습니다!\n\n![Building an Ionic App with OpenLayers](/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 준비물\n\n시작하기 전에, 컴퓨터에 다음 사항이 설치되어 있는지 확인해주세요:\n\n- Node.js와 npm: 다운로드 및 설치\n- Ionic CLI: npm을 이용하여 전역으로 설치하기\n\n```js\nnpm install -g @ionic/cli\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 1: Ionic Framework 설정하기\n\n먼저, 새 Ionic 프로젝트를 만들어 봅시다:\n\n```js\nionic start myOpenLayersApp blank --type=angular\ncd myOpenLayersApp\n```\n\n# 단계 2: OpenLayers 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 디렉토리로 이동하여 OpenLayers를 설치해주세요:\n\n```js\nnpm install ol\n```\n\n# 단계 3: 지도를 위한 독립형 컴포넌트 생성\n\nAngular CLI를 사용하여 독립형 컴포넌트를 생성해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate component open-layers-map --standalone\n```\n\n# 단계 4: tsconfig.json에서 Lib 체크 플래그 설정\n\n프로젝트 디렉토리로 이동하여 tsconfig.json 파일을 엽니다. compilerOptions 아래에 아래 줄을 추가합니다.\n\n```js\n \"skipLibCheck\": true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![OpenLayers Map](/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_1.png)\n\n# 컴포넌트 수정\n\n- open-layers-map.component.ts\n\n```javascript\nimport { Component, AfterViewInit, ElementRef, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Map, View } from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\nimport { fromLonLat } from 'ol/proj';\n\n@Component({\n  selector: 'app-open-layers-map',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './open-layers-map.component.html',\n  styleUrls: ['./open-layers-map.component.scss']\n})\nexport class OpenLayersMapComponent implements AfterViewInit {\n  @ViewChild('mapElement', { static: false }) mapElement!: ElementRef;\n  map!: Map;\n\n  ngAfterViewInit() {\n    this.map = new Map({\n      target: this.mapElement.nativeElement,\n      layers: [\n        new TileLayer({\n          source: new OSM()\n        })\n      ],\n      view: new View({\n        center: fromLonLat([0, 0]),\n        zoom: 2\n      })\n    });\n  }\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. open-layers-map.component.html:\n\n```html\n\u003cdiv #mapElement class=\"map\"\u003e\u003c/div\u003e\n```\n\n3. open-layers-map.component.scss:\n\n```scss\n.map {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: 지도 컴포넌트를 메인 페이지에 통합하기\n\n- home.page.ts:\n\n```js\nimport { Component } from '@angular/core';\nimport { IonicModule } from '@ionic/angular';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { OpenLayersMapComponent } from '../open-layers-map/open-layers-map.component';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n  standalone: true,\n  imports: [IonicModule, CommonModule, FormsModule, OpenLayersMapComponent]\n})\nexport class HomePage {}\n```\n\n2. home.page.html:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cion-header\u003e\n  \u003cion-toolbar\u003e\n    \u003cion-title\u003e\n      OpenLayers Map\n    \u003c/ion-title\u003e\n  \u003c/ion-toolbar\u003e\n\u003c/ion-header\u003e\n\n\u003cion-content\u003e\n  \u003capp-open-layers-map\u003e\u003c/app-open-layers-map\u003e\n\u003c/ion-content\u003e\n```\n\n# 5단계: 애플리케이션 실행하기\n\n작성한 애플리케이션을 확인하려면 다음 명령어를 사용하세요:\n\n```js\nionic serve\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIonic 앱의 메인 페이지에서 간단한 OpenLayers 지도를 확인할 수 있어요.\n\n# 결론\n\nAngular의 독립 구성 요소를 활용하여 Ionic 앱에 OpenLayers를 통합하는 과정은 간단합니다. 이 설정을 사용하면 휴대폰 애플리케이션을 위한 대화식이고 기능이 풍부한 지도를 만들 수 있어요. 필요에 따라 레이어, 컨트롤 및 상호 작용을 추가하여 지도를 더 맞춤화해보세요.\n\n즐거운 맵핑 되세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png"},"coverImage":"/assets/img/2024-06-20-BuildinganIonicAppwithOpenLayers_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러의 파이프","description":"","date":"2024-06-20 00:37","slug":"2024-06-20-PipesinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-PipesinAngular_0.png\" /\u003e\n\n알다시피, Angular은 현대 웹 애플리케이션을 구축하는 인기 있는 웹 프레임워크이며, 개발자에게 많은 강력한 기능을 제공합니다.\n\n이러한 기능 중 하나인 파이프는 데이터를 표시하기 전에 간단하고 효율적인 방법으로 변환하는 기능을 제공합니다.\n\n이 기사에서는 Angular의 파이프에 대해 포괄적으로 살펴보겠습니다. 그 중에는 파이프가 무엇인지, 어떻게 사용하는지, 몇 가지 일반적인 사용 사례 예시가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목차:\n\n- 소개\n- 순수 및 불순 파이프\n- 내장 파이프\n- 사용자 정의 파이프 생성\n- 파이프 연결하기\n- 주요 포인트 요약\n- Angular에서 파이프 사용하는 최상의 실천 방법\n- 마무리와 권장 사항\n\nAngular에서 파이프 이해하고 구현하는 데 관련된 모든 개념을 다룰 예정입니다.\n\n그럼 시작해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular에서의 Pipes 소개\n\nAngular의 Pipes는 응용 프로그램에서 데이터를 표시하기 전에 변환할 수 있도록 해주는 기능입니다.\n\nPipes를 사용하면 데이터를 형식화, 필터링, 정렬할 수 있으며 템플릿 기반 및 반응형 폼뿐만 아니라 기타 Angular 구성 요소 및 서비스와 함께 사용할 수 있습니다.\n\n# 2. 순수 및 불순한 Pipes\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러에서는 파이프가 순수한지 또는 불순한지로 나뉩니다.\n\n순수 파이프는 상태를 가지지 않고, 출력에 영향을 미칠 수 있는 내부 상태가 없도록 설계되어 있습니다.\n\n그 대신, 순수 파이프는 입력 데이터를 가져와 변환된 출력 데이터를 반환합니다. 순수 파이프는 또한 메모이제이션되어 있어, 입력 데이터가 마지막으로 파이프가 호출된 이후 변경되지 않았다면, 파이프는 다시 실행되지 않습니다.\n\n순수 파이프를 사용하는 장점은 필요할 때에만 실행되기 때문에 앵귤러 애플리케이션의 성능을 향상시킬 수 있다는 것입니다. 게다가, 순수 파이프는 불필요한 변경 감지 주기를 방지할 수 있어 전체 애플리케이션 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 순수 파이프를 만들려면 다음처럼 @Pipe 데코레이터에 pure: true 옵션을 추가해야 합니다:\n\n```js\n@Pipe({\n  name: 'myPurePipe',\n  pure: true\n})\n```\n\n일부 경우에는 무즙 파이프를 사용하는 것이 유용할 수 있습니다. 예를 들어, 무거운 계산이 필요하거나 외부 API에서 데이터를 가져와야 할 때입니다.\n\n그러나 가능한한 항상 성능을 향상시키고 불필요한 변경 감지 주기를 방지하기 위해 순수 파이프를 사용하는 것이 일반적으로 권장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. Angular 내장 파이프\n\nAngular에는 템플릿에서 사용할 수 있는 여러 내장 파이프들이 내장되어 있습니다. 아래는 Angular에서 가장 일반적으로 사용되는 몇 가지 내장 파이프입니다:\n\n- 통화 파이프\n- 날짜 파이프\n- JSON 파이프\n- 소문자 변환 파이프\n- 대문자 변환 파이프\n- 퍼센트 파이프\n- Slice 파이프\n- TitleCase 파이프\n- Async 파이프\n\n## 1. 통화 파이프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 로케일에 따라 통화 기호, 소수점 구분 기호 및 그룹 구분 기호를 고려하여 사용자 친화적인 형식으로 통화 값을 표시하는 방법을 제공합니다.\n\nAngular에서 CurrencyPipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  price: number = 12345.6789;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.component.html:\n\n```html\n\u003cdiv\u003e\n  \u003ch2\u003eUsing CurrencyPipe\u003c/h2\u003e\n  \u003cp\u003ePrice: {{ price | currency }}\u003c/p\u003e\n  \u003cp\u003ePrice: {{ price | currency:'EUR':'symbol-narrow':'4.2-2' }}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n위의 예제에서 숫자 값인 12345.6789를 보유하는 price 변수가 있습니다. 그런 다음 화폐 파이프를 사용하여 템플릿에서 price 변수를 화폐 값으로 형식화합니다.\n\n파이프의 첫 번째 사용은 기본 설정으로 이루어집니다. 현재 로캘의 기본 화폐로 price 변수를 형식화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이프의 두 번째 사용 예시에는 몇 가지 추가 매개변수가 포함되어 있습니다. 이는 가격 변수를 EUR 통화 기호로, 좁은 심볼로 형식화시키며, 형식 문자열은 4.2-2로 설정되어 있습니다. 형식 문자열은 십진 분리자 앞에 최소 4자리, 십진 분리자 뒤에 최대 2자리를 가지고 있어야 하며 로케일의 십진 및 그룹화 분리자를 사용해야 합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\nCurrencyPipe 사용\n가격: $12,345.68\n가격: €12,345.68\n```\n\n첫 번째 출력 행은 현재 로캘에 대해 기본으로 형식화된 통화 값을 보여줍니다. 두 번째 출력 행은 유로 통화 기호, 좁은 심볼 및 특정 형식 문자열을 사용한 사용자 지정 형식화된 통화 값을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. Date Pipe\n\n현재 로캘에 기반을 둔 사용자 친화적인 형식으로 날짜 값을 표시하는 방법을 제공합니다.\n\n다음은 Angular에서 DatePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  currentDate: Date = new Date();\n}\n```\n\napp.component.html:\n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003eUsing DatePipe\u003c/h2\u003e\n  \u003cp\u003e현재 날짜: {{ currentDate | date }}\u003c/p\u003e\n  \u003cp\u003e현재 날짜: {{ currentDate | date:'fullDate' }}\u003c/p\u003e\n  \u003cp\u003e현재 날짜: {{ currentDate | date:'short' }}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n위 예제에서는 현재 날짜 객체를 저장하는 currentDate 변수가 있습니다. 그런 다음 템플릿에서 currentDate 변수를 날짜 값으로 형식화하기 위해 date 파이프를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nDatePipe를 사용한 경우\n현재 날짜: 2023년 3월 3일 금요일\n현재 날짜: 2023년 3월 3일\n현재 날짜: 23. 3. 3. 오전 12:17\n\n첫 번째 줄은 현재 로캘에 맞는 기본 형식으로 날짜 값을 표시합니다. 두 번째 줄은 currentDate 변수를 전체 날짜 문자열로 서식화한 것을 보여줍니다. 세 번째 줄은 currentDate 변수를 짧은 날짜 문자열로 서식화한 것을 보여줍니다.\n\n## Json Pipe\n\nJson 파이프를 사용하면 객체 값을 서식이 지정된 JSON 문자열로 표시할 수 있습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 Angular에서 JsonPipe를 사용할 수 있습니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myObject: any = {\n    name: 'John',\n    age: 30,\n    email: 'john@example.com'\n  };\n}\n```\n\napp.component.html:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n\u003cdiv\u003e\n  \u003ch2\u003eJsonPipe 사용하기\u003c/h2\u003e\n  \u003cpre\u003e{ myObject | json }\u003c/pre\u003e\n\u003c/div\u003e\r\n```\n\n위 예제에서는 이름, 나이, 이메일 속성을 포함한 객체를 보유하는 myObject 변수가 있습니다. 그런 다음 json 파이프를 사용하여 myObject 변수를 JSON 문자열로 변환합니다.\n\n출력에서 공백과 형식을 보존하기 위해 pre 태그가 사용됩니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nJsonPipe 사용\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"email\": \"john@example.com\"\n}\n```\n\n출력된 결과는 myObject 변수가 포맷된 공백과 함께 JSON 문자열로 변환된 것을 보여줍니다. 이는 디버깅 및 객체 값을 읽기 쉬운 형식으로 표시하는 데 유용할 수 있습니다.\n\n## 4. LowerCase 파이프\n\nAngular에서 LowerCasePipe를 사용하는 예제입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myString: string = '대소문자가 혼합된 문자열입니다';\n}\n```\n\napp.component.html:\n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003eLowerCasePipe 사용하기\u003c/h2\u003e\n  \u003cp\u003e원본 문자열: {{ myString }}\u003c/p\u003e\n  \u003cp\u003e소문자로 변환된 문자열: {{ myString | lowercase }}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제에서는 혼합된 대소문자 값을 저장하는 myString 변수가 있습니다. 그런 다음 소문자 파이프를 사용하여 myString 변수를 소문자로 변환합니다.\n\n위의 코드를 실행하면 다음과 같은 출력이 표시됩니다:\n\n```js\nUsing LowerCasePipe\nOriginal String: This is a STRING in Mixed CASE\nLowercased String: this is a string in mixed case\n```\n\n첫 번째 출력 라인에는 원래 문자열 값이 표시됩니다. 두 번째 출력 라인에는 소문자 파이프를 사용한 후 변환된 문자열 값이 표시됩니다. 문자열의 모든 문자가 소문자로 변환된 것에 유의하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 대문자 변환 파이프\n\nAngular에서 UpperCasePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myString: string = 'This is a STRING in Mixed CASE';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.component.html:\n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003eUpperCasePipe를 사용하는 방법\u003c/h2\u003e\n  \u003cp\u003e원래 문자열: { myString }\u003c/p\u003e\n  \u003cp\u003e대문자로 변환된 문자열: { myString | uppercase }\u003c/p\u003e\n\u003c/div\u003e\n```\n\n위 예시에서는 대소문자를 섞어 가지고 있는 문자열 값을 저장하는 myString 변수가 있습니다. 그 후에 uppercase 파이프를 사용하여 myString 변수를 모두 대문자로 변환합니다.\n\n위의 코드를 실행하면 다음과 같은 결과가 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n대문자 파이프 사용\n원본 문자열: This is a STRING in Mixed CASE\n대문자 변환된 문자열: THIS IS A STRING IN MIXED CASE\n```\n\n첫 번째 출력 라인은 원래 문자열 값을 보여줍니다. 두 번째 출력 라인은 대문자 파이프를 사용한 후 변환된 문자열 값을 보여줍니다. 모든 문자가 대문자로 변환되었음을 주의하세요.\n\n## 5. 퍼센트 파이프\n\n다음은 Angular에서 퍼센트 파이프를 사용하는 예시입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myNumber: number = 0.23;\n}\n```\n\napp.component.html:\n\n```html\n\u003cdiv\u003e\n  \u003ch2\u003eUsing PercentPipe\u003c/h2\u003e\n  \u003cp\u003e원래 숫자: {{ myNumber }}\u003c/p\u003e\n  \u003cp\u003e백분율 값: {{ myNumber | percent }}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서는 숫자 값을 보관하는 myNumber 변수가 있습니다. 그런 다음 퍼센트 파이프를 사용하여 myNumber 변수를 백분율 값으로 변환합니다.\n\n위의 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\nUsing PercentPipe\nOriginal Number: 0.23\nPercentage Value: 23%\n```\n\n첫 번째 출력 라인은 원래 숫자 값을 보여줍니다. 두 번째 출력 라인은 퍼센트 파이프를 사용한 후 변환된 백분율 값을 보여줍니다. 소수 값에 100을 곱하고 값 끝에 백분율 기호가 추가됨에 유의하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. Slice Pipe\n\nSlicePipe은 Angular에 내장된 pipe로, 기존 배열이나 문자열의 일부분을 포함하는 새로운 배열이나 문자열을 만드는 데 사용됩니다.\n\n아래는 Angular에서 SlicePipe를 사용하는 예시입니다:\n\napp.component.ts:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  myArray: any[] = ['apple', 'banana', 'orange', 'grape', 'mango'];\n  myString: string = 'This is a long string.';\n}\n```\n\napp.component.html:\n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003e배열에 SlicePipe 사용하기\u003c/h2\u003e\n  \u003cp\u003e원본 배열: { myArray }\u003c/p\u003e\n  \u003cp\u003e잘린 배열: { myArray | slice:1:3 }\u003c/p\u003e\n\u003c/div\u003e\n```\n\n```js\n\u003cdiv\u003e\n  \u003ch2\u003e문자열에 SlicePipe 사용하기\u003c/h2\u003e\n  \u003cp\u003e원본 문자열: { myString }\u003c/p\u003e\n  \u003cp\u003e잘린 문자열: { myString | slice:0:7 }\u003c/p\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예제에서는 과일 배열을 보관하는 myArray 변수와 문자열 값을 보관하는 mySecodString 변수가 있습니다. 그런 다음 슬라이스 파이프를 사용하여 원래 배열 또는 문자열의 일부를 포함하는 새로운 배열 또는 문자열을 만듭니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n```js\n슬라이스 파이프를 배열에 사용\n\n원래 배열: apple,banana,orange,grape,mango\n스라이스된 배열: banana,orange\n\n문자열에 슬라이스 파이프를 사용\n\n원래 문자열: This is a long string.\n스라이스된 문자열: This is\n```\n\n첫 번째 출력 섹션은 슬라이스 파이프를 사용하여 원래 배열 값과 슬라이스된 배열 값을 보여줍니다. 슬라이스는 인덱스 1에서 시작하여 인덱스 3에서 끝나기 때문에 슬라이스된 배열에는 인덱스 1과 인덱스 2의 요소가 포함됩니다(인덱스 3은 포함되지 않음). 두 번째 출력 섹션은 슬라이스 파이프를 사용하여 원래 문자열 값과 슬라이스된 문자열 값을 보여줍니다. 슬라이스는 인덱스 0에서 시작하여 인덱스 7에서 끝나기 때문에 슬라이스된 문자열에는 인덱스 0부터 인덱스 6까지의 문자가 포함됩니다(인덱스 7은 포함되지 않음).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. TitleCase Pipe\n\n앵귤러에서 TitleCasePipe를 사용하는 예제입니다:\n\napp.component.ts:\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  myString: string = 'this is a sentence in lowercase.';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예제에서는 문자열 값을 저장하는 myString 변수가 있습니다. 그런 다음 titlecase 파이프를 사용하여 myString 변수를 타이틀 케이스로 변환합니다.\n\n```js\n## TitleCasePipe 사용\n\n원본 문자열: { myString }\n\n변환된 문자열: { myString | titlecase }\n```\n\n위 코드를 실행하면 다음과 같은 출력이 표시됩니다:\n\n```js\nTitleCasePipe 사용\n원본 문자열: this is a sentence in lowercase.\n변환된 문자열: This Is A Sentence In Lowercase.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 출력 라인은 원래 문자열 값을 보여줍니다. 두 번째 출력 라인은 titlecase 파이프를 사용한 후의 변환된 타이틀 케이스 값을 보여줍니다.\n\n## 8. Async Pipe\n\nAsyncPipe는 Angular 내장 파이프로, 비동기 데이터 스트림을 처리하는 데 사용됩니다. 일반적으로 옵저버블이나 프로미스를 구독하고 뷰에 출력된 값들을 표시하는 데 사용됩니다.\n\n다음은 Angular에서 AsyncPipe를 사용하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱.component.ts:\n\n```js\nimport { Component } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  myObservable$: Observable\u003cnumber\u003e = of(42);\n  myPromise$: Promise\u003cstring\u003e = Promise.resolve('Hello World!');\n}\n```\n\n위 예시에서는 숫자 42를 방출하는 Observable을 저장하는 myObservable$ 변수와 문자열 'Hello World!'로 해결되는 Promise를 저장하는 myPromise$ 변수가 있습니다. 그런 다음 async pipe를 사용하여 이러한 Observable 및 Promise를 구독하고 뷰에 방출된 값을 표시합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n    # Observable을 사용하는 AsyncPipe\n    { myObservable$ | async }\n\n    # Promise를 사용하는 AsyncPipe\n    { myPromise$ | async }\n\n\n\nObservable을 사용하는 AsyncPipe\n42\nPromise를 사용하는 AsyncPipe\nHello World!\n\n\n첫번째 출력 섹션은 Observable을 통해 발행된 값을 보여줍니다. 두번째 출력 섹션은 Promise를 통해 해결된 값을 보여줍니다. AsyncPipe는 자동으로 Observable 및 Promise에 구독하며, 컴포넌트가 파괴되면 메모리 누수를 방지하기 위해 구독을 해제합니다.\n\n# 4. 사용자 정의 Pipe 생성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러에서는 새 클래스를 정의하고 PipeTransform 인터페이스를 구현하여 사용자 정의 파이프를 만들 수 있어요. PipeTransform 인터페이스에는 입력 값을 받아 변환된 값을 반환하는 transform이라는 단일 메서드가 포함돼요.\n\ncustom.pipe.ts:\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({name: 'filterByLength'})\nexport class CustomPipe implements PipeTransform {\n  transform(values: string[], minLength: number): string[] {\n    return values.filter(value =\u003e value.length \u003e= minLength);\n  }\n}\n```\n\n위 예제에서 CustomPipe 클래스를 정의하고 PipeTransform 인터페이스를 구현하는 것을 볼 수 있어요. transform() 메서드는 문자열 배열과 최소 길이라는 두 인수를 받아와요. 그런 다음 배열에서 지정된 길이 이상인 문자열을 걸러내요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 클래스에 @Pipe 데코레이터를 사용하여 해당 파이프에 이름을 제공합니다. 이름 속성을 사용하여 템플릿에서 파이프를 참조할 수 있습니다.\n\napp.module.ts\n\n```js\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\n\nimport { CustomPipe } from \"./custom.pipe\";\n\nimport { AppComponent } from \"./app.component\";\n\n@NgModule({\n  declarations: [AppComponent, CustomPipe],\n  imports: [BrowserModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n```\n\napp.component.ts\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  template: './app.component.html'\n})\nexport class AppComponent {\n  values: string[] = ['apple', 'banana', 'carrot', 'date'];\n}\n```\n\n```js\n\u003ch2\u003eUsing Custom Pipe\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli *ngFor=\"let value of values | filterByLength: 5\"\u003e{{ value }}\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n위 예제에서는 몇 가지 문자열을 포함하는 값 배열이 있습니다. 그런 다음 filterByLength 파이프를 사용하여 5자보다 짧은 문자열을 필터링합니다. *ngFor 지시문을 사용하여 필터링된 값들을 반복하고 그 값을 순서가 없는 목록으로 표시합니다.\n\n위 코드를 실행하면 다음 출력이 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nUsing Custom Pipe\n사과\n바나나\n당근\n```\n\n값 배열에서 5글자 이상인 두 개의 문자열을 표시합니다.\n\n# 5. 파이프 연결하기\n\nAngular에서 파이프를 연결하는 것은 템플릿에서 데이터를 변환하기 위해 여러 파이프를 연이어 적용하는 것을 의미합니다. 파이프를 연결하려면 파이프 연산자 (|)를 여러 번 사용하여 각각의 파이프가 별도의 변환을 나타내도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 문자열 형식을 지정하고 대문자로 변환하고 싶은 날짜 문자열이 있다고 가정해보세요. 다음과 같이 날짜 및 대문자 파이프를 연결할 수 있습니다.\n\n```js\n{ myDate | date:'medium' | uppercase }\n```\n\n이 예에서는 myDate 값이 먼저 date 파이프를 통해 전달되며, 이 파이프는 `medium` 형식을 사용하여 날짜를 형식화합니다. 그 결과값은 그 다음으로 uppercase 파이프를 통해 전달되며, 해당 값을 대문자로 변환합니다.\n\n여러 파이프를 연결하는 것은 성능에 영향을 줄 수 있으므로, 특히 대규모 데이터 집합을 처리할 때 주의해야 합니다. 템플릿에서 여러 파이프를 연결하게 되면, 변환 로직을 사용자 정의 파이프로 이동하거나 데이터를 템플릿으로 전달하기 전에 구성 요소에서 데이터를 변환하는 것을 고려해보세요. 이렇게 함으로써 성능을 향상시키고 코드를 읽기 쉽고 유지 보수하기 쉽게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 주요 포인트 요약\n\n- 파이프는 Angular 템플릿에서 데이터를 변환하여 사용자에게 표시되기 전에 사용됩니다.\n- Angular에는 CurrencyPipe, DatePipe, DecimalPipe, UpperCasePipe, LowerCasePipe, TitleCasePipe 및 AsyncPipe와 같은 여러 내장 파이프가 포함되어 있습니다.\n- 파이프는 | 문자와 함께 템플릿 표현식에서 사용할 수 있습니다.\n- 파이프는 하나 이상의 인수를 취할 수도 있으며, 이는 | 문자 뒤에 전달됩니다.\n- PipeTransform 인터페이스를 구현하는 클래스를 정의하고 해당 클래스를 모듈의 declarations 배열에 추가하여 직접 사용자 정의 파이프를 만들 수 있습니다.\n- 사용자 정의 파이프를 정의할 때, 파이프의 이름을 지정하고, 이 이름을 템플릿에서 사용할 수 있도록 하며, 입력 데이터와 인수를 취하여 변환된 데이터를 반환하는 변환 함수를 제공해야 합니다.\n- 템플릿에서 사용자 정의 파이프를 사용하기 위해서는, | 문자 뒤에 파이프 이름을 추가하고, 콜론 뒤에 인수를 추가해야 합니다.\n- 파이프를 사용할 때 올바른 파이프 이름과 인수를 사용하고, 올바른 입력 데이터를 파이프로 전달하는 것이 중요합니다. 파이프가 예상대로 작동하지 않으면 이러한 사항을 확인하여 문제를 해결해야 할 수도 있습니다.\n\n# 7. 파이프 사용의 Best Practices\n\nAngular에서 파이프를 사용할 때 염두에 둘 몇 가지 Best Practices가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 가능한 경우에는 내장 파이프를 사용해 보세요 — Angular은 DatePipe, CurrencyPipe, DecimalPipe 등과 같은 일반적인 변환을 위한 여러 내장 파이프를 제공합니다. 이러한 파이프들은 성능을 최적화했으며 불필요한 오버헤드를 피하기 위해 가능한 한 사용해야 합니다.\n- 너무 많은 파이프 연결을 피하세요 — 여러 파이프를 연결하면 성능 문제가 발생할 수 있습니다, 특히 대규모 데이터셋을 다룰 때. 대신 사용자 정의 파이프를 고려하거나 데이터를 템플릿으로 전달하기 전에 컴포넌트에서 변환하는 것을 고려해 보세요.\n- 성능에 주의하세요 — 특히 대규모 데이터셋을 다룰 때 파이프는 비용이 많이 드는 작업일 수 있습니다. 성능 문제를 피하기 위해 파이프가 호출되는 횟수를 제한하고 파이프 내에서 무거운 계산을 피하세요.\n- 파이프를 간단하게 유지하세요 — 파이프는 간단하고 단일 변환에 집중되어야 합니다. 하나의 파이프에서 너무 많은 작업이나 복잡한 논리를 갖는 파이프를 만드는 것을 피하세요. 이렇게 하면 유지 및 디버깅이 어려워질 수 있습니다.\n- 가능한 경우 순수 파이프를 사용하세요 — 순수 파이프는 입력이 변경될 때에만 호출됩니다. 이는 성능을 향상시킬 수 있습니다. 사용자 정의 파이프를 만들 때 가능한 경우 순수 파이프로 만드는 것을 고려해 보세요.\n- 데이터 유형을 주의하세요 — 변환될 데이터 유형에 따라 파이프의 작동 방식이 달라집니다. 예를 들어 DatePipe는 입력으로 Date 객체를 기대하고, CurrencyPipe는 숫자를 기대합니다. 예상치 못한 동작을 피하기 위해 파이프에 올바른 데이터 유형을 전달하도록 주의하세요.\n- 파이프를 테스트하세요 — 사용자 정의 파이프를 만들 때는 제대로 작동하는지 확실히 테스트하세요. 이는 파이프의 변환 논리에 대한 단위 테스트뿐만 아니라 컴포넌트의 맥락에서도 테스트하는 것을 포함할 수 있습니다.\n\n이러한 모범 사례를 따르면 Angular 애플리케이션에서 데이터를 변환하는 파이프가 효율적이고 유지보수가 용이하며 효과적이라는 것을 보장할 수 있습니다.\n\n# 8. 마지막 생각과 권장사항\n\n총론적으로, Angular에서 파이프는 컴포넌트에 추가적인 코드 없이 템플릿에서 데이터를 변환할 수 있는 강력한 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내장 파이프를 사용하거나 사용자 지정 파이프를 만들면 날짜, 숫자, 문자열을 포맷팅하고 데이터를 필터링하며 다른 유용한 변환을 수행할 수 있습니다.\n\nAngular 애플리케이션에서 파이프를 사용할 때는 성능을 염두에 두는 것이 중요합니다.\n\n너무 많은 파이프를 연쇄적으로 사용하지 않고 파이프 내에서 무거운 계산에 주의해야 합니다. 이는 성능에 영향을 줄 수 있습니다.\n\n또한 순수 파이프를 사용하고 사용자 지정 파이프를 충분히 테스트하여 예상대로 작동하는지 확인하는 것이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 권장 사항으로, Angular의 기본 파이프를 탐색하고 사용자 정의 파이프를 만들어보는 것을 제안합니다. 파이프를 효과적으로 활용하면 Angular 애플리케이션의 사용자 인터페이스를 더 다이나믹하고 매력적으로 만들 수 있습니다.\n\nCodeSandBox에서 실시간 예제를 확인할 수 있어요.\n\n그럼 이만! 이 글 끝까지 참여주셔서 정말 감사합니다! 도움이 되셨기를 바랍니다. 저를 Medium, Twitter, Linkedin 그리고 Facebook에서 팔로우할 수 있습니다.\n\n궁금한 점이 있으면 언제든지 물어봐주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제게 커피를 사주시면 감사하겠어요 🙂\n\n더 많은 흥미로운 프로그래밍 조각들을 기대해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-PipesinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-PipesinAngular_0.png","tag":["Tech"],"readingTime":17},{"title":"Angular i18n을 사용하여 성능 향상과 구성 요소 수준 조직을 위한 사용자 정의 번역 서비스","description":"","date":"2024-06-20 00:35","slug":"2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_0.png\" /\u003e\n\nAngular 애플리케이션의 다국어화는 종종 앱에 대한 모든 레이블과 번역을 포함하는 대규모 집중화된 en.json 파일을 유지하는 작업을 포함합니다. 이 방법은 번역 데이터를 집중화하지만, 애플리케이션이 커짐에 따라 관리하기 어려워지고 더욱 복잡해질 수 있습니다. 또한, 모든 번역을 미리 로드하는 것은 특히 lazy-loaded 컴포넌트에서 성능에 부정적인 영향을 줄 수 있습니다.\n\n이러한 도전에 대처하기 위해 저는 컴포넌트별 번역 파일을 허용하는 사용자 지정 트랜스레이션 서비스를 개발했습니다. 이 방법은 조직화를 개선하고 유지보수를 간단화하며 en.json 파일을 더 작고 컴포넌트별 부분으로 나눔으로써 성능을 최적화합니다.\n\nAngular i18n에서 흔히 사용되는 관행은 assets/i18n 디렉토리에 있는 단일 en.json 파일에 모든 번역을 저장하는 것입니다. 이 접근 방식에는 장점이 있지만 여러 문제점도 도입됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡성과 혼잡성: 더 많은 번역이 추가됨에 따라 en.json 파일을 관리하기가 점점 어려워집니다.\n- 유지보수 부담: 모든 라벨이 하나의 파일에 있을 때 번역을 업데이트하는 것은 시간이 많이 걸리고 오류가 발생할 수 있습니다.\n- 성능 문제: 큰 번역 파일을 로드하면 응용 프로그램이 느려질 수 있으며, 특히 컴포넌트가 지연로드될 때 더 그러합니다.\n\n이러한 문제를 해결하기 위해 컴포넌트별 번역 파일 사용을 지원하는 사용자 정의 번역 서비스를 만들었습니다. 각 컴포넌트는 자체 번역 파일을 가지며, 해당 파일은 컴포넌트와 동일한 디렉토리에 저장됩니다. 이 접근 방식에는 여러 가지 이점이 있습니다:\n\n- 조직 개선: 특정 컴포넌트와 관련된 번역 파일은 관리하고 탐색하기가 더 쉽습니다.\n- 편리한 유지보수: 번역 업데이트는 개별 컴포넌트에 로컬화되어 오류 발생 위험이 줄어듭니다.\n- 더 나은 성능: 필요한 번역만 로드되어 성능이 향상되며, 특히 지연로드되는 컴포넌트에서 효과적입니다.\n\n# 사용자 정의 번역 서비스 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 구성 요소마다 구성 요소 디렉터리에 별도의 번역 파일을 만드세요. 예를 들어 aBlogPostComponent의 경우 해당 구성 요소에 대한 en.ts 파일을 만들어야 합니다.\n\n이제 우리만의 사용자 정의 번역 서비스를 만들 것입니다. 우리의 서비스는 `ngx-translate` 라이브러리에서 제공하는 TranslateService 위에 래퍼(wrapper)로 작용합니다. 이를 통해 기본 라이브러리 메서드를 사용하여 우리만의 사용자 정의 도우미 함수를 작성할 수 있게 됩니다.\n\n이 서비스에서 한 클래스와 하나의 함수를 생성해야 합니다. 여기서 setDefaultLocale를 만들었습니다. 이 함수에서는 setDefaultLang으로 번역 언어를 설정합니다. 1단계에서 만든 파일을 여기서 세션에 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 번역 모듈을 설정하겠습니다.\n\n[이미지를 확인하시려면 클릭하세요.](/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_2.png)\n\n모듈 파일을 생성하고 해당 모듈 파일에서 위에 표시된 대로 하나의 클래스를 내보내야 합니다. Observable 페이지 변경을 감지하고 번역 파일을 여기에 설정할 것입니다.\n\n[이미지를 확인하시려면 클릭하세요.](/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번역 모듈 파일에서 translateModule의 forRoot를 정의해야 합니다.\n\n아래 형식과 같이 en.ts와 같은 번역 파일을 만들어야 합니다.\n\n![image](/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_4.png)\n\n우리의 템플릿 파일에서 텍스트를 번역하려면, 텍스트(또는 변수)를 번역 파이프와 함께 파이핑하면 브라우저에서 마법이 일어나는 것을 확인할 수 있습니다. 그리고 그 서비스와 함수를 호출하고, 2단계에서 만든 en.ts 파일을 전달해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_5.png)\n\n# 사용자 정의 번역 서비스의 이점\n\n구성 요소별 번역 파일을 지원하는 사용자 정의 번역 서비스를 구현하면 여러 가지 이점이 제공됩니다:\n\n- 향상된 조직화: 번역을 해당 구성 요소에 가깝게 유지함으로써 코드베이스가 보다 조직화되고 탐색하기 쉬워집니다.\n- 단순화된 유지 관리: 특정 구성 요소의 번역을 업데이트하는 것이 더 쉽고 오류 가능성이 낮아집니다.\n- 향상된 성능: 필요한 번역 파일만 로드하면 메모리 사용량이 줄어들고 애플리케이션 성능이 향상되어 특히 지연로드된 구성 요소에 유용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 코드의 가독성과 유지 관리성을 향상시키는데 그치지 않고 Angular 애플리케이션 전체의 성능도 향상시킵니다. 다음 프로젝트에서 이 방법을 시도해보고 보다 간소하고 효율적인 국제화 프로세스의 혜택을 경험해보세요.","ogImage":{"url":"/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_0.png"},"coverImage":"/assets/img/2024-06-20-Angulari18nwithaCustomTranslationServiceforBetterPerformanceandComponent-LevelOrganization_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular의 새로운 let 구문 탐험 템플릿 변수 선언 강화","description":"","date":"2024-06-20 00:34","slug":"2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations","content":"\n\n\n![이미지](/assets/img/2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations_0.png)\n\nAngular의 진화가 계속되면서 최근 병합된 @let 구문과 같은 흥미로운 새로운 기능들이 추가되었습니다. 이 기능은 아직 릴리스되지 않았지만 최근에 병합되었습니다. 이러한 추가 기능은 개발자가 템플릿 내에서 로컬 변수를 선언하고 제어 흐름을 직접 관리할 수 있는 간소화된 방법을 제공합니다. 이 기능은 템플릿 로직을 간단화하고 가독성을 향상시키는 데 초점을 맞추며, 특히 비동기 데이터와 복잡한 조건 처리 시 유용합니다. 새로운 @let 구문의 다양한 사용 사례와 장점을 자세히 살펴보겠습니다.\n\n# @let 구문 이해\n\n@let 구문을 사용하면 Angular 템플릿 내에서 로컬 변수를 선언하고 사용할 수 있습니다. 사용법을 설명하기 위해 다음과 같이 간단한 예제를 살펴봅시다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@let user = user$ | async;\n@let greeting = user ? 'Hello, ' + user.name : 'Loading';\n\n# \u003ch1\u003e{ greeting }\u003c/h1\u003e\n```\n\n이 예제에서 user$는 사용자 데이터를 방출하는 observable입니다. @let 구문을 사용하면 비동기 데이터 처리 및 조건부 렌더링 작업을 간단하게 처리할 수 있습니다.\n\n# let 구문의 사용 사례\n\n## Falsy 값 회피 또는 Async Pipe를 사용한 여러 구독 방지\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n템플릿에서 관측 가능한 항목과 해당 값들을 처리하는 것은 반복적인 코드와 여러 구독을 야기할 수 있습니다. 자주 발생하는 문제 몇 가지와 @let이 이를 해결하는 방법을 살펴봅시다.\n\n첫째, @if 문 내에서 async 파이프를 사용할 때 관측 가능한 값이 falsy인 경우(예: 0 또는 false) 제대로 작동하지 않습니다:\n\n```js\n@if (total$ | async as total) {\n  \u003cp\u003e{ total }\u003c/p\u003e\n}\n```\n\n둘째, async 파이프를 직접 여러 곳에서 사용하면 여러 구독이 발생하여 비효율적이며 성능 문제를 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@let total = total$ | async;\n\n\u003cdiv\u003e{ total }\u003c/div\u003e\n\u003cdiv\u003e{ total }\u003c/div\u003e\n```\n\n해결 방법은 observable 값에 대한 변수를 선언하기 위해 @let 구문을 사용하는 것입니다. 이 접근 방식은 단일 구독을 보장하고 falsy 값에 대해 올바르게 처리합니다.\n\n## 템플릿에서의 신호 유형 좁히기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신호에 대한 가장 귀찮은 문제 중 하나는 템플릿 내에서의 타입 좁힘 능력의 부재입니다. Angular은 이에 대한 해결책을 개발 중이지만, 그 동안 우리는 @let 기능을 활용하여 이 문제를 해결할 수 있습니다:\n\n```js\n@let txType = tx().type;\n\n@switch(txType) {\n  @case('a') {}\n  @case('b') {}\n}\n\n@let address = person()?.address();\n\n@if (address) {\n \u003capp-address [address]=\"address\"\u003e\n}\n```\n\n## for 루프 내부\n\n@let 구문은 특히 @for 루프 내에서 유용합니다. 개발자는 템플릿 내에서 중간 속성을 생성하여 가독성을 높이고 추가 컴포넌트 로직이 필요한 경우를 줄일 수 있습니다. 예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@for (user of users(); track user.id) {\n  @let address = user.address;\n\n  \u003cdiv\u003e\n    \u003ch3\u003eUser: { user.name }\u003c/h3\u003e\n    \u003cdiv\u003e\n      \u003cp\u003eStreet: { address.street }\u003c/p\u003e\n      \u003cp\u003eCity: { address.city }\u003c/p\u003e\n      \u003cp\u003eZipcode: { address.zipcode }\u003c/p\u003e\n    \u003c/div\u003e\n    @for (order of user.orders) {\n      \u003cdiv\u003e\n        \u003ch4\u003eOrder: { order.id }\u003c/h4\u003e\n        \u003cp\u003eProduct: { order.productName }\u003c/p\u003e\n        \u003cp\u003eQuantity: { order.quantity }\u003c/p\u003e\n      \u003c/div\u003e\n    }\n  \u003c/div\u003e\n}\n```\n\n## 파이프를 여러 번 사용하는 경우\n\n템플릿에서 비용이 많이 드는 파이프를 여러 번 사용할 때는 종종 변환된 데이터를 저장할 컴포넌트의 속성을 만들어야합니다. @let 구문을 사용하면 변환된 변수를 한 번 선언하고 재사용하여 계산 부하를 줄이고 템플릿을 깔끔하게 유지할 수 있습니다.\n\n```js\n@let expensiveResult = someData | expensivePipe;\n\n\u003cp\u003e{ expensiveResult }\u003c/p\u003e\n\u003cp\u003e{ expensiveResult }\u003c/p\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAngular의 @let 구문은 @if 및 @for과 같은 새로운 제어 흐름 기능과 결합되어 템플릿 변수 선언 및 제어 흐름 관리에 상당한 향상을 제공합니다. 상태 관리를 위해 계속 시그널 사용을 주장하는 사람도 있지만, @let 구문은 템플릿 내부의 로컬 변수를 처리하는 우아한 해결책을 제공합니다. Falsy 값 처리, 다중 구독 피하기 및 반복 코드 감소와 같은 일반적인 도전 과제를 해결함으로써이 새로운 기능은 Angular 개발자들에게 개발 경험을 향상시키기 위한 준비를 마쳤습니다.\n\nAngular 및 JS에 관해 더 많이 읽으시려면 Medium이나 Twitter에서 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations_0.png"},"coverImage":"/assets/img/2024-06-20-ExploringAngularsNewletSyntaxEnhancingTemplateVariableDeclarations_0.png","tag":["Tech"],"readingTime":3},{"title":"Ionic 앱에 지문 및 얼굴 인식을 통합해보세요","description":"","date":"2024-06-20 00:33","slug":"2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID","content":"\n\n생체 인증은 지문 및 얼굴 인식을 포함하여 사용자가 안전하고 편리하게 인증할 수 있는 방법을 제공합니다. 이 튜토리얼에서는 cordova-plugin-fingerprint-aio 플러그인을 사용하여 Ionic 앱에 생체 인증을 통합하는 방법을 알아보겠습니다. 이 플러그인은 특정 생체 인식 방법을 추상화하며 지문 및 얼굴 인식을 모두 지원하며 사용자 기기에서 사용 가능한 것에 맞게 적응합니다.\n\n![이미지](/assets/img/2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID_0.png)\n\n# 준비 사항\n\n시작하기 전에 다음 설정이 완료되었는지 확인하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Node.js 및 npm이 설치되어 있습니다.\n- Ionic CLI가 설치되어 있습니다 (npm install -g @ionic/cli).\n- Android 개발을 위해 Android Studio가 필요합니다.\n- macOS에서 iOS 개발을 위해 Xcode가 필요합니다.\n- 생체 인식 기능(지문 또는 얼굴 인식)이 있는 실제 기기\n\n# 단계 1: 새 Ionic 프로젝트 생성\n\n먼저, 새 Ionic 프로젝트를 생성해야 합니다. 이미 프로젝트가 있는 경우, 이 단계를 건너뛸 수 있습니다.\n\n```bash\nionic start biometric-auth blank --type=angular\ncd biometric-auth\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 지문 AIO 플러그인 추가하기\n\n이제 cordova-plugin-fingerprint-aio 플러그인과 Ionic Native 래퍼를 설치해야 합니다.\n\n```js\nionic cordova plugin add cordova-plugin-fingerprint-aio\nnpm install @awesome-cordova-plugins/fingerprint-aio\n```\n\n# 단계 3: 앱 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# app.module.ts 업데이트\n\n우리 앱이 FingerprintAIO 프로바이더를 사용하도록 구성해야 합니다. src/app/app.module.ts 파일을 열어 다음과 같이 업데이트해 주세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { RouteReuseStrategy } from '@angular/router';\n\nimport { IonicModule, IonicRouteStrategy } from '@ionic/angular';\nimport { SplashScreen } from '@ionic-native/splash-screen/ngx';\nimport { StatusBar } from '@ionic-native/status-bar/ngx';\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { FingerprintAIO } from '@awesome-cordova-plugins/fingerprint-aio/ngx';\n\n@NgModule({\n  declarations: [AppComponent],\n  entryComponents: [],\n  imports: [BrowserModule, IonicModule.forRoot(), AppRoutingModule],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    FingerprintAIO,\n    { provide: RouteReuseStrategy, useClass: IonicRouteStrategy }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n```\n\n# 생체 인증 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 홈페이지 구성요소에 생체 인증을 구현할 것입니다.\n\n## 홈페이지 파일 업데이트\n\nsrc/app/home/home.page.ts 파일을 열어 아래 내용으로 업데이트해 주세요:\n\n```js\nimport { Component } from '@angular/core';\nimport { FingerprintAIO } from '@awesome-cordova-plugins/fingerprint-aio/ngx';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n})\nexport class HomePage {\n\n  constructor(private faio: FingerprintAIO) {}\n\n  async showFingerprintAuth() {\n    try {\n      // 생체 인증 사용 가능 여부 확인\n      const available = await this.faio.isAvailable();\n      if (available) {\n        const result = await this.faio.show({\n          title: '생체 인증', // 생체 인증 다이얼로그의 제목\n          subtitle: '접근 권한 인증', // 생체 인증 다이얼로그의 부제목\n          description: '지문 또는 얼굴을 사용하여 인증하세요', // 생체 인증 다이얼로그 설명\n          fallbackButtonTitle: '백업 사용', // 백업 버튼 제목\n          disableBackup: true // 안드로이드에서 '백업 사용' 옵션 비활성화 (선택 사항)\n        });\n        console.log(result);\n        alert('인증 성공');\n      } else {\n        alert('이 장치에서는 생체 인증을 사용할 수 없습니다.');\n      }\n    } catch (e) {\n      console.error(e);\n      alert('인증 실패');\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 홈 페이지 업데이트\n\nsrc/app/home/home.page.html 파일을 열고 다음과 같이 업데이트하십시오:\n\n```js\n\u003cion-header\u003e\n  \u003cion-toolbar\u003e\n    \u003cion-title\u003e\n      생체 인증\n    \u003c/ion-title\u003e\n  \u003c/ion-toolbar\u003e\n\u003c/ion-header\u003e\n\n\u003cion-content\u003e\n  \u003cion-button (click)=\"showFingerprintAuth()\"\u003e\n    지문/얼굴 ID로 인증하기\n  \u003c/ion-button\u003e\n\u003c/ion-content\u003e\n```\n\n# 단계 4: 앱 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 앱을 테스트할 시간입니다. 바이오메트릭 기능은 시뮬레이터나 에뮬레이터에서 테스트할 수 없으므로 실제 기기에서 앱을 실행해야 합니다.\n\n# 결론\n\n이 튜토리얼에서는 cordova-plugin-fingerprint-aio 플러그인을 사용하여 Ionic 앱에 바이오메트릭 인증을 통합했습니다. 이 플러그인은 사용자 기기에서 사용 가능한 지문 및 얼굴 인식을 모두 지원하며, 위에서 안내한 단계를 따라 Ionic 앱의 보안 및 사용자 경험을 바이오메트릭 인증으로 향상시킬 수 있습니다.\n\n구현을 더 자유롭게 사용자 흐름에 통합하고 개선해보세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID_0.png"},"coverImage":"/assets/img/2024-06-20-IntegrateBiometricAuthenticationinYourIonicAppwithFingerprintandFaceID_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트","description":"","date":"2024-06-20 00:32","slug":"2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents","content":"\n\nAngular v18의 릴리스는 프레임워크에 흥미로운 새로운 기능과 개선 사항을 도입했습니다.\n\n그 중 하나의 기능은 특히 유망하며, Angular Forms 라이브러리 내에서 새로운 기능을 소개하여 AbstractControl 클래스를 통해 통합된 컨트롤 상태 변경 이벤트를 향상시킵니다.\n\n내 글에서는 주제에 집중하기 전에 기본 사항을 먼저 검토하는 것이 관습입니다. 이는 다가오는 내용을 더 잘 이해하도록 도와줄 것입니다.\n\n# Angular 반응형 Forms: 기본 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 반응형 폼은 양식 입력을 처리하는 모델 중심 접근 방식을 제공하며, 데이터 모델에 대한 동기식 액세스, 입력 유효성 검사 및 변경 추적을 위한 강력한 도구를 Observables를 통해 제공합니다.\n\n반응형 폼 데이터 모델은 다음 클래스를 사용하여 구성됩니다:\n\n- FormControl: 단일 입력 양식을 나타냅니다. 값은 기본 유형입니다.\n- FormGroup: FormControl 그룹을 나타냅니다. 값은 객체입니다.\n- FormArray: FormControl 목록을 나타냅니다. 값은 배열입니다.\n\nFormGroup으로 나타낼 수 있는 폼의 일반적인 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { FormGroup, FormControl, FormArray } from '@angular/forms';\n\nconst articleForm = new FormGroup({\n  title: new FormControl(''),\n  content: new FormControl(''),\n  tags: new FormArray([])\n});\n```\n\n이 모든 클래스들은 여기서는 컨트롤이라고만 부르겠습니다. 이 컨트롤들은 AbstractControl 클래스에서 파생되었기 때문에 공통 속성과 메소드를 공유합니다.\n\n## 템플릿 바인딩\n\nAngular Reactive Forms 모델 기반 접근 방식은 라이브러리 자체에서 제공하는 다양한 디렉티브에 의해 지원되며, 이는 폼 컨트롤을 HTML 요소와 쉽게 통합할 수 있도록 합니다. \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음의 FormGroup을 예시로 삼아보겠습니다:\n\n```js\nthis.articleForm = new FormGroup({\n  author: new FormGroup({\n    name: new FormControl(''),\n  }),\n  tags: new FormArray([ new FormControl('Angular') ]),\n});\n```\n\n제공된 지시문을 사용하여 템플릿에 쉽게 바인딩할 수 있습니다:\n\n```js\n\u003cform [formGroup]=\"articleForm\"\u003e\n  \u003cdiv formGroupName=\"author\"\u003e\n    \u003cinput formControlName=\"name\" /\u003e\n  \u003c/div\u003e\n\n  \u003cdiv formArrayName=\"tags\"\u003e\n    \u003cdiv *ngFor=\"let tag of tags.controls; index as i\"\u003e\n      \u003cinput [formControlName]=\"i\" /\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/form\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잊지 말아야 할 중요한 점은, 지나치게 깊게 파고들지 않으면서도 필요한 내용은, FormGroupDirective를 사용하여 쉽게 폼을 재설정하는 버튼과 해당 값을 제출하는 버튼을 만들 수 있다는 것입니다:\n\n```js\n\u003cform [formGroup]=\"articleForm\"\u003e\n  \u003c!-- 폼 템플릿 --\u003e\n\n  \u003cbutton type=\"reset\"\u003e지우기\u003c/button\u003e\n  \u003cbutton type=\"submit\"\u003e저장\u003c/button\u003e\n\u003c/form\u003e\n```\n\nFormGroupDirective는 이러한 버튼에서 발생하는 클릭 이벤트를 가로채어 컨트롤의 reset() 함수를 트리거하고, 컨트롤을 초기 값으로 재설정하며 directive의 ngSubmit 출력 이벤트를 트리거합니다.\n\n## 값 변경 감시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 작업을 수행하기 위해 값을 변경하는 것을 듣기 위해, 추적하려는 컨트롤의 valueChanges observable에 구독할 수 있습니다:\n\n```js\nmyControl.valueChanges.subscribe(value =\u003e {\n  console.log('새 값:', value)\n});\n```\n\n## 비활성화된 컨트롤\n\n각 컨트롤은 비활성화로 설정되어 사용자가 값을 편집하는 것을 방지할 수 있습니다. 이는 HTML 비활성화 속성(Disabled attribute)의 동작을 모방합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 수행하기 위해서는 컨트롤을 비활성화하는 방법으로 사용할 수도 있고, disable()와 enable() 함수를 사용하여 이 상태를 전환할 수도 있습니다:\n\n```js\nimport { FormControl } from '@angular/forms';\n\nconst myControl = new FormControl({ value: '', disabled: true });\nconsole.log(myControl.disabled, myControl.enabled) // true, false\n\nmyControl.enable();\nconsole.log(myControl.disabled, myControl.enabled) // false, true\n\nmyControl.disable();\nconsole.log(myControl.disabled, myControl.enabled) // true, false\n```\n\n위 예제에서 보듯이 AbstractControl 클래스는 이 상태를 설명하기 위해 disabled와 enabled라는 두 가지 전용 속성을 제공합니다.\n\n## Validators\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 규칙을 강제하고 컨트롤이 특정 기준을 충족하는지 확인하려면 일부 유효성 검사 규칙 또는 유효성 검증기를 지정할 수도 있습니다.\n\n유효성 검증기는 동기식일 수도 있고(@required 또는 @minLength와 같은), 외부 리소스에 의존하는 유효성 검사를 처리하는 비동기식일 수도 있습니다.\n\n```js\nimport { FormControl, Validators } from '@angular/forms';\nimport { MyCustomAsyncValidators } from './my-custom-async-validators.ts';\n\nconst myFormControl = new FormControl('', {\n  validators: [ Validators.required, Validators.minLength(3) ],\n  asyncValidators: [ MyCustomAsyncValidators.validate ]\n});\n```\n\n이러한 규칙을 기반으로 AbstractControl 클래스는 유효성 상태를 설명하는 몇 가지 속성도 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- valid: 제어 값이 모든 유효성 검사 테스트를 통과했는지 여부를 나타내는 부울 값입니다;\n- invalid: 제어 값이 모든 유효성 검사 테스트를 통과하지 못했는지 여부를 나타내는 부울 값입니다; valid 속성의 반대입니다;\n- pending: 제어 값이 유효성 검사를 수행 중인지 여부를 나타내는 부울 값입니다.\n\n## FormControlStatus\n\n비활성 상태와 유효성 상태는 서로 연결되어 있습니다.\n사실, 이들은 다음과 같이 유형이 지정된 상태 속성으로 파생됩니다:\n\n```js\ntype FormControlStatus = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원형과 접촉됨\n\nAbstractControl 클래스는 사용자가 양식과 상호 작용한 방식을 설명하는 여러 속성도 제공합니다:\n\n- pristine: 컨트롤이 원형 상태인지 여부를 나타내는 부울 값으로, 즉 아직 수정되지 않은 상태임을 의미합니다;\n- dirty: 컨트롤이 수정되었는지 여부를 나타내는 부울 값입니다;\n- untouched: 컨트롤이 아직 터치되지 않았는지 여부를 나타내는 부울 값으로, 즉 아직 상호 작용되지 않았음을 의미합니다;\n- touched: 컨트롤이 터치되었는지 여부를 나타내는 부울 값입니다.\n\nAngular 반응형 폼의 기본 사항 중 일부를 다시 살펴보았으니, 이제 이 글의 주제를 소개할 때입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png)\n\n# 새로운 통합 제어 상태 변경 이벤트\n\nAngular v18부터 AbstractControl 클래스는 이제 모든 제어 상태 변경 이벤트를 추적하기 위한 새로운 이벤트 observable을 노출합니다.\n\n이를 통해 이제 PristineEvent, ValueChangeEvent, StatusEvent 및 TouchedEvent 이벤트를 통해 FormControl, FormGroup 및 FormArray 클래스를 모니터링할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof PristineChangeEvent))\n  .subscribe((event) =\u003e console.log('Pristine:', event.pristine));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof ValueChangeEvent))\n  .subscribe((event) =\u003e console.log('Value:', event.value));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof StatusChangeEvent))\n  .subscribe((event) =\u003e console.log('Status:', event.status));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof TouchedChangeEvent))\n  .subscribe((event) =\u003e console.log('Touched:', event.touched));\n```\n\n이러한 기능들은 매우 강력합니다. 특히 valueChange를 제외하고는 이전에 상태 변경을 제대로 추적하기가 어려웠습니다.\n\n게다가 FormGroup 클래스는 events observable을 통해 FormSubmittedEvent와 FormResetEvent 두 가지 추가 이벤트를 발생시킬 수도 있습니다.\n\n```js\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof FormSubmittedEvent))\n  .subscribe((event) =\u003e console.log('Submit:', event));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof FormResetEvent))\n  .subscribe((event) =\u003e console.log('Reset:', event));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFormSubmittedEvent와 FormResetEvent는 모두 FormGroupDirective에서 상속되며 실제로 지시자 자체에서만 발생됩니다.\n\n## 추가 정보\n\n이 새로운 추가로, 다음 AbstractControl 메소드들은 emitEvent 매개변수를 지원하도록 업데이트되었습니다:\n\n- markAsPristine(): 컨트롤을 pristine으로 표시;\n- markAsDirty(): 컨트롤을 dirty로 표시;\n- markAsTouched(): 컨트롤을 touched로 표시;\n- markAsUntouched(): 컨트롤을 untouched로 표시;\n- markAllAsTouched(): 컨트롤과 하위 요소를 모두 touched 상태로 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n피드백을 받고 싶어요. 댓글을 남겨주시거나 클랩을 눌러주세요. 👏 \n\n그리고 만약에 정말 좋았다면, 당신의 커뮤니티, 기술 브라더들, 누구든지 공유해주세요. 그리고 리링크드인 팔로우도 잊지 말아주세요. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png"},"coverImage":"/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png","tag":["Tech"],"readingTime":7},{"title":"Angular 접근성 모든 사용자를 위해 만드는 방법","description":"","date":"2024-06-20 00:30","slug":"2024-06-20-AccessibleAngularBuildingforEveryUser","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png\" /\u003e\n\n모든 사용자의 능력에 관계없이 웹 애플리케이션을 만드는 것은 도덕적인 의무뿐만 아니라 실용적인 필요성도 있습니다. Angular는 강력한 기능과 모듈식 구조로 장애를 가진 사람들을 포함한 모든 사용자를 대상으로 하는 접근성과 포괄성 있는 웹 애플리케이션을 구축하기에 적합합니다. 본 문서에서는 Angular 애플리케이션이 모든 사람에게 접근 가능하도록 하는 데 필요한 모범 사례와 기술을 탐구합니다. 이 문서는 어느 한 형태에 국한되지 않고 개개인들이 포용을 필수적인 애플리케이션을 구축하는 데 필요한 구성 요소로 간주하도록 독려합니다.\n\n## 접근성의 필요성\n\n접근성은 장애를 가진 사람들을 포함한 모든 사용자가 웹 콘텐츠를 인지, 이해, 탐색 및 상호 작용할 수 있도록 보장합니다. 이는 포용성, 사용성 및 종종 법적 준수에 관한 문제입니다. 접근성이 있는 웹 애플리케이션은 사용자 경험을 개선하고 대중의 범위를 확대하며 사회적 책임을 실천함을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹 접근성의 주요 원칙\n\n## 인지할 수 있는\n\n모든 사용자가 인지할 수 있는 방식으로 콘텐츠를 제공해야 합니다. 이에는 비텍스트 콘텐츠에 대한 텍스트 대체물을 제공하고 정보가 다양한 방식(예: 소리와 시각)으로 제공되도록 하는 것이 포함됩니다.\n\n## 조작할 수 있는\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터페이스 요소들은 작동 가능해야 합니다. 사용자들은 키보드, 마우스, 터치 등 다양한 입력 방법을 사용하여 콘텐츠를 탐색하고 상호 작용할 수 있어야 합니다.\n\n## 이해하기 쉬움\n\n콘텐츠는 이해하기 쉬워야 합니다. 사용자들은 사용자 인터페이스의 정보와 작동을 이해할 수 있어야 합니다.\n\n## 견고함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넓은 범위의 사용자 에이전트 및 보조 기술을 신뢰할 수 있는 방식으로 해석할 수 있도록 콘텐츠가 강화되어야 합니다.\n\n## 접근 가능한 Angular 애플리케이션 구축을 위한 모범 사례\n\n## 1. 의미 있는 HTML 사용\n\n의미 있는 HTML은 웹 콘텐츠에 의미를 부여하여 접근성을 높입니다. ``header``, ``nav``, ``main``, 그리고 ``footer``와 같은 태그는 응용 프로그램에 구조를 제공하고 보조 기술이 콘텐츠를 올바르게 해석하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nhtml\n\u003cheader\u003e\n  \u003cnav\u003e\n    \u003ca routerLink=\"/\" aria-current=\"page\"\u003eHome\u003c/a\u003e\n    \u003ca routerLink=\"/me\"\u003eMe\u003c/a\u003e\n    \u003ca routerLink=\"/blog\"\u003eBlogs\u003c/a\u003e\n  \u003c/nav\u003e\n\u003c/header\u003e\n\u003cmain\u003e\n  \u003ch1\u003eWelcome to my Page\u003c/h1\u003e\n  \u003cp\u003eSubscribe to my YouTube Channel! @babatundelmd\u003c/p\u003e\n\u003c/main\u003e\n\u003cfooter\u003e\n  \u003cp\u003e© 2024 Babatunde Lamidi\u003c/p\u003e\n\u003c/footer\u003e\n\n\n## 2. Implement ARIA (Accessible Rich Internet Applications)\n\nARIA 속성은 웹 콘텐츠의 의미를 향상시켜 보조 기술에 대한 추가 정보를 제공하여 응용 프로그램을 보다 접근성이 높게 만들어줍니다. ARIA 역할, 상태 및 속성을 사용하여 응용 프로그램을 더 쉽게 접근할 수 있도록 만들어보세요.\n\n\n\u003cbutton aria-label=\"close\" role=\"button\"\u003eX\u003c/button\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 키보드 탐색 보장하기\n\n모든 상호작용 요소가 키보드로 접근할 수 있도록 보장하세요. 이는 `tabindex` 속성과 Angular의 기본 포커스 관리를 사용하는 것을 포함합니다.\n\n```js\nimport { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';\n@Component({\n selector: 'app-example',\n template: `\u003cbutton #myButton\u003eClick Me\u003c/button\u003e`,\n})\nexport class ExampleComponent implements AfterViewInit {\n @ViewChild('myButton') myButton: ElementRef;\nngAfterViewInit() {\n this.myButton.nativeElement.focus();\n }\n}\n```\n\n## 4. 포커스 프로그래밍 방식으로 관리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular의 FocusMonitor를 사용하여 포커스를 동적으로 관리하여 사용자가 항상 애플리케이션 내에서 자신의 위치를 인식할 수 있도록합니다.\n\n```js\nimport { Component, OnInit, ElementRef, ViewChild } from '@angular/core';\nimport { FocusMonitor } from '@angular/cdk/a11y';\n\n@Component({\n selector: 'app-focus-example',\n template: `\u003cinput #inputField type=\"text\" /\u003e`,\n})\nexport class FocusExampleComponent implements OnInit {\n @ViewChild('inputField') inputField: ElementRef;\n private focusMonitor = inject(FocusMonitor)\n\n ngOnInit() {\n  this.focusMonitor.monitor(this.inputField.nativeElement).subscribe(origin =\u003e {\n   if (origin) {\n    console.log('Focused from', origin);\n   } else {\n    console.log('Blurred');\n   }\n  });\n }\n}\n```\n\n## 5. 양식 접근성 확보\n\n양식 컨트롤에 레이블을 올바르게 지정하고 적절한 ARIA 속성을 사용하십시오. 키보드를 사용하여 양식을 탐색하고 제출할 수 있도록 보장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003clabel for=\"username\"\u003e사용자 이름\u003c/label\u003e\n\u003cinput type=\"text\" id=\"username\" name=\"username\" /\u003e\n\u003clabel for=\"email\"\u003e이메일\u003c/label\u003e\n\u003cinput type=\"email\" id=\"email\" name=\"email\" /\u003e\n\u003cbutton type=\"submit\" role=\"button\"\u003e제출\u003c/button\u003e\n\n\n## 6. 충분한 색 대비 보장\n\n시각 장애가 있는 사용자를 위해 텍스트와 배경 간의 높은 대비는 가독성을 향상시킵니다. WebAIM의 색 대비 점검기와 같은 도구를 사용하여 접근성 표준을 준수하는지 확인해보세요.\n\n## 7. 비 텍스트 콘텐츠를 위한 텍스트 대체 제공하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cimg src=\"image.jpg\" alt=\"이미지 설명\" aria-label=\"프로필 사진\"\u003e\n\u003cvideo controls\u003e\n  \u003csource src=\"intro.mp4\" type=\"video/mp4\" /\u003e\n  \u003ctrack kind=\"captions\" src=\"intro_captions.vtt\" srclang=\"en\" label=\"영어\"\u003e\n\u003c/video\u003e\n```\n\n## Angular CDK를 활용한 접근성 강화\n\nAngular Component Dev Kit (CDK)은 접근성이 뛰어난 애플리케이션 구축을 더 쉽게 해주는 도구를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## A11yModule\n\n이 모듈은 포커스 관리 및 실시간 공지를 포함한 다양한 접근성 유틸리티를 제공합니다.\n\n```js\nimport { A11yModule } from '@angular/cdk/a11y';\n@NgModule({\n imports: [A11yModule],\n})\nexport class AppModule {}\n```\n\n## FocusTrap\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 요소 내에서 포커스를 잡아두어, 모달과 대화 상자 등에 유용합니다.\n\n```js\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';\n\n@Component({\n selector: 'app-modal',\n template: `\u003cdiv #modalContent\u003e\u003cbutton\u003eClose\u003c/button\u003e\u003c/div\u003e`,\n})\nexport class ModalComponent implements AfterViewInit {\n @ViewChild('modalContent') modalContent: ElementRef;\n private focusTrap;\n\n constructor(private focusTrapFactory: FocusTrapFactory) {}\n\n ngAfterViewInit() {\n this.focusTrap = this.focusTrapFactory.create(this.modalContent.nativeElement);\n this.focusTrap.focusInitialElement();\n }\n}\n```\n\n## 웹 접근성을 고려한 Angular Material\n\nAngular Material은 웹 접근성을 고려하여 설계되었습니다. 해당 컴포넌트는 WCAG(`Web Content Accessibility Guidelines` 표준)을 준수하는 데 사용되어, 애플리케이션이 강력한 접근성 기반으로 시작될 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { MatInputModule, MatButtonModule } from '@angular/material';\n@NgModule({\n imports: [MatInputModule, MatButtonModule],\n})\nexport class AppModule {}\n```\n\n웹 접근성이란 모든 사용자에게 포용되고 사용하기 쉬운 웹 환경을 만드는 데 준수만큼 중요합니다. Angular의 도구와 기능을 활용하고 최상의 모범 사례를 따르며 애플리케이션을 지속적으로 테스트하고 개선함으로써 모든 사용자가 웹 애플리케이션에 접근하고 혜택을 받을 수 있도록 보장할 수 있습니다. 개발 프로세스에서 웹 접근성을 핵심 원칙으로 받아들이면 포괄적이고 사용자 친화적인 애플리케이션을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png"},"coverImage":"/assets/img/2024-06-20-AccessibleAngularBuildingforEveryUser_0.png","tag":["Tech"],"readingTime":6},{"title":"제목 Angular 프로젝트를 처음부터 만드는 방법DidLoad 어드바이저, 당신의 열정과 프로그래밍 기술이 빛을 발하는 시간입니다 오늘은 Angular 프로젝트를 처음부터 만들어보는 방법에 대해 알아볼 거에요 함께 시작해볼까요 ","description":"","date":"2024-06-20 00:29","slug":"2024-06-20-HowtoCreateanAngularProjectfromScratch","content":"\n\n\n![Angular Project](/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png)\n\nAngular은 강력하고 확장 가능한 웹 애플리케이션을 구축할 수 있는 널리 사용되는 웹 개발 프레임워크입니다. Angular에 처음이신 분들을 위해 스크래치에서 자체 프로젝트를 개발하기 시작하고 싶다면, 이 기사가 필요한 단계를 안내해 드립니다. 새 프로젝트를 설정하고, 컴포넌트를 생성하고, 라우트를 구현하는 방법 등을 배우게 될 것입니다. 시작해 봅시다!\n\nRead this article in Spanish: Crear un proyecto en Angular | Medium\n\n# Prerequisites\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에, 당신의 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. Node.js는 공식 Node.js 웹사이트(https://nodejs.org)에서 다운로드하여 설치할 수 있습니다. Angular는 Node.js와 npm(Node Package Manager)을 사용하여 종속성 및 개발 환경을 관리합니다.\n\n# 단계 1: Angular CLI 설치\n\nAngular CLI(Command Line Interface)는 Angular 프로젝트를 쉽게 생성하고 관리할 수 있도록 도와주는 명령줄 도구입니다. 터미널을 열고 다음 몤령어를 실행하여 Angular CLI를 전역으로 설치해보세요:\n\n```js\nnpm install -g @angular/cli\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설치가 완료되었으면 다음 명령을 실행하여 Angular CLI가 성공적으로 설치되었는지 확인하세요:\n\n```js\nng version\n```\n\n# 단계 2: 새 프로젝트 생성\n\n이제 Angular CLI를 설치했으므로 새 Angular 프로젝트를 생성할 수 있습니다. 터미널에서 다음 명령을 실행하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng new my-angular-project\n```\n\n이 명령은 \"my-angular-project\"라는 새 디렉토리를 만들고 초기 프로젝트 구조를 생성합니다.\n\n# 단계 3: 프로젝트 디렉토리로 이동\n\n다음 명령을 사용하여 새로 생성된 프로젝트 디렉토리로 이동하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd my-angular-project\n```\n\n# 단계 4: 개발 서버 시작하기\n\n프로젝트 디렉토리에 들어간 후, 아래 명령을 실행하여 Angular 개발 서버를 시작하세요:\n\n```js\nng serve\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트를 컴파일하고 로컬 서버에서 실행합니다. 웹 브라우저를 열고 http://localhost:4200으로 이동하세요. Angular 애플리케이션이 정상적으로 작동하는 것을 확인할 수 있습니다.\n\n# 단계 5: 컴포넌트 생성하기\n\n컴포넌트는 Angular에서의 기본적인 구성 요소입니다. 다음 명령어를 사용하여 컴포넌트를 생성할 수 있습니다:\n\n```js\nng generate component 컴포넌트명\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 새로운 컴포넌트를 위해 필요한 TypeScript 파일, HTML 템플릿 및 CSS 스타일링 파일이 자동으로 생성됩니다.\n\n# 단계 6: 라우트 구성\n\n라우트를 설정하면 애플리케이션 내의 여러 컴포넌트 간을 이동할 수 있습니다. 라우트를 구성하려면 app-routing.module.ts 파일을 열고 다음 코드를 추가하세요:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n];\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n위 코드는 \"HomeComponent\"와 \"AboutComponent\" 두 개의 컴포넌트를 위한 라우트를 구성합니다. 이에 따라 이러한 컴포넌트와 해당하는 템플릿을 만들어주세요.\n\n# 단계 7: 컴포넌트에 내용 추가하기\n\n이제 새롭게 생성한 컴포넌트에 내용을 추가할 수 있습니다. 컴포넌트 파일 (component-name.component.ts, component-name.component.html, 그리고 component-name.component.css)을 열고 필요에 맞게 사용자 정의하세요. 텍스트, 이미지, 링크 등을 추가할 수 있습니다.  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: 애플리케이션 실행\n\n컴포넌트에 내용을 추가한 후 파일을 저장하고 터미널로 돌아가세요. Angular 개발 서버가 여전히 실행 중인지 확인해주세요. 그렇지 않은 경우 다음 명령을 다시 실행하세요:\n\n```js\nng serve\n```\n\n그런 다음 브라우저를 열고 http://localhost:4200 으로 이동하세요. 여태까지 생성한 Angular 애플리케이션과 컴포넌트 및 라우트가 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n축하합니다! 처음으로 Angular 프로젝트를 처음부터 만드셨군요. 이제 더 많은 것을 탐험하고 배우실 수 있을 거에요.\n\n# 요약 및 권장 사항\n\n이 글에서는 처음부터 Angular 프로젝트를 만드는 방법을 배우셨습니다. Angular CLI 설치부터 라우트 구성, 컴포넌트 생성까지 기본 단계를 다뤘습니다. 몇 가지 최종 권장 사항을 안내해드리겠습니다:\n\n- Angular CLI에 의해 생성된 파일 구조에 익숙해지세요. 프로젝트를 효율적으로 구성하는 데 도움이 될 거에요.\n- Angular 공식 문서(https://angular.io)를 살펴보세요. 프레임워크의 기능과 능력에 대해 더 알 수 있을 거에요.\n- 다양한 컴포넌트를 구축하고 Angular 기능들을 실험해보세요.\n- Angular 커뮤니티에 가입하고 포럼과 토론 그룹에 참여하세요. 다른 개발자들로부터 배우고 교류하는 좋은 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 자신의 프로젝트를 Angular로 만들 준비가 되셨군요! 즐거운 여정을 즐기시고 계속해서 배워 나가세요.\n\n이 게시물을 좋아하신다면 제 팔로우를 눌러주시거나 이야기에 박수를 보내주시거나 내가 준비 중인 다음 이야기를 구독해주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoCreateanAngularProjectfromScratch_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular afterRender, afterNextRender 새로운 phases API","description":"","date":"2024-06-20 00:28","slug":"2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI","content":"\n\n앵귤러는 컴포넌트 상호 작용을위한 강력한 라이프사이클 후크를 제공하지만 때로는 렌더링 후에 DOM과 직접 작업해야 하는 경우가 있습니다. 이때 afterRender 및 afterNextRender가 유용합니다.\n\n## 필요성 이해하기\n\nDOM 요소를 시각화하는 데 DOM을 사용하는 타사 차트 라이브러리를 통합하려고 상상해보십시오. 표준 라이프사이클 후크는 이러한 시나리오에 이상적이지 않을 수 있으며 라이브러리가 초기화되기 전에 DOM이 완전히 준비되어 있어야 할 수도 있습니다. 이러한 경우에 afterRender 및 afterNextRender가 해결책을 제공합니다.\n\n## 주요 차이점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 후크가 후처리 작업을 다루지만 중요한 차이점이 있습니다:\n\n- afterRender: 각 렌더 사이클 다음에 실행되는 콜백을 등록할 수 있습니다.\n- afterNextRender: DOM이 로드될 때마다 한 번만 실행되는 콜백을 등록합니다.\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png)\n\n# 적절한 후크 선택하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `afterNextRender`은 초기화 되어야 하는 타사 라이브러리를 설정하거나 엘리먼트 관찰자를 설정하는 것과 같은 일회성 DOM 조작에 사용합니다.\n- `afterRender`은 동적으로 콘텐츠에 기반하여 엘리먼트 크기를 동적으로 조정하는 것과 같이 빈번한 DOM 변경에 반응해야 할 때 사용합니다.\n\n기억해주세요: `afterRender`을 자주 사용하면 성능에 영향을 줄 수 있으므로 신중하게 사용해야 합니다. 그리고 이 두 가지는 모두 삽입 컨텍스트 내에서 사용되어야 합니다. 이 후크들은 SSR 또는 사전 렌더링에서 작동하지 않습니다.\n\n# 단계의 순서\n\n![Order of Phases](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 렌더링 중에 제어된 DOM 액세스를 위한 구분된 단계를 정의합니다:\n\n- EarlyRead: 후속 쓰기 작업 전에 DOM에서 데이터를 읽을 수 있습니다.\n- Write: DOM에 데이터를 쓰는 것을 허용합니다 (이 단계에서 읽기는 피하십시오).\n- MixedReadWrite: 읽기와 쓰기가 모두 가능하지만 성능 저하 가능성으로 신중하게 사용해야 합니다.\n- Read: DOM에서 데이터를 읽는 것을 허용합니다 (이 단계에서 쓰기는 피하십시오).\n\n# 콜백 실행 순서 ➡️\n\n동일한 단계 내에서 등록된 콜백은 등록된 순서대로 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 렌더 주기가 끝난 후에는 콜백이 실행됩니다. 그리고 다음과 같은 특정 단계 순서를 따릅니다:\n\n- earlyRead\n- write\n- mixedReadWrite\n- read\n\n# 초기화 과정 중 (angular.dev 기준)\n\n![Angular Initialization](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이후의 업데이트 (angular.dev에서)\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_3.png)\n\n# 단계 간 매개변수 전달\n\n첫 번째 단계 콜백(earlyRead)은 매개변수를 전달받지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 후속 단계 콜백은 이전에 실행된 단계 콜백의 반환 값을 매개변수로 받습니다. 이를 통해 여러 단계에 걸쳐 작업을 조정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_4.png)\n\n# 수익성 있는 예시\n\n다음은 이러한 후크를 사용하는 몇 가지 실용적인 사례들입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 써드파티 라이브러리 초기화: DOM이 준비되기 전에 Chart.js와 같은 라이브러리를 초기화하기 전에 afterNextRender를 사용해주세요.\n- 엘리먼트 감시 설정: afterNextRender를 활용하여 IntersectionObserver 또는 ResizeObserver를 설정하십시오. 이들 API는 엘리먼트가 DOM에 존재해야만 작동합니다.\n- 동적 콘텐츠 사이즈 조정: 동적으로 로드된 콘텐츠에 기반하여 엘리먼트 차원을 조정하기 위해 Read 단계와 함께 afterRender를 구현하십시오.\n- 임시 엘리먼트 분리: 렌더링 프로세스 중에 추가한 임시 엘리먼트를 제거하기 위해 afterNextRender를 사용하십시오(모달을 닫은 후 정리하는 등).\n\n# 중요 고려 사항 ⚠️\n\n- afterRender와 afterNextRender는 브라우저별 작업에 사용되며 서버 측 렌더링 중에는 작동하지 않습니다.\n- 가능한 경우 Angular의 내장 기능 인 ngAfterViewInit을 사용하여 컴포넌트 초기화 작업을 수행할 수 있습니다.\n- afterRender는 DOM을 읽는 것을 가능하게 하지만, 서버와 클라이언트 렌더링 간의 수분화 불일치로 인해 주의해야 합니다.\n- 이들은 주입 컨텍스트에서만 선언할 수 있습니다.\n\n이러한 개념을 이해함으로써 Angular 애플리케이션과 DOM 간에 원활한 상호 작용을 만들기 위해 afterRender 및 afterNextRender를 효과적으로 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 지정 Inject 함수\n\nOnInit 로그인을 사용자 정의 inject 함수로 캡슐화할 수 있습니다. 이 기능을 제공해준 Chau Tran에게 감사드립니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_5.png\" /\u003e\n\n여기서 코드를 실험해볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://stackblitz.com/edit/stackblitz-starters-a39kev?file=package.json\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n피드백을 주시면 감사하겠습니다. 댓글이나 박수, 팔로우 부탁드려요. 👏\n\n좋았다면 꼭 여러분의 커뮤니티, 기술 동료 또는 원하는 누군가와 공유해주세요. 그리고 LinkedIn, YouTube 또는 Substack에서도 팔로우 부탁드립니다. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png"},"coverImage":"/assets/img/2024-06-20-AngularafterRenderafterNextRenderNEWphasesAPI_0.png","tag":["Tech"],"readingTime":4}],"page":"53","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"53"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>