<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/53" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/53" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리액트 타입스크립트  Vite  리액트" href="/post/2024-05-12-ReactTypeScriptViteReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 타입스크립트  Vite  리액트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-ReactTypeScriptViteReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 타입스크립트  Vite  리액트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 타입스크립트  Vite  리액트</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유" href="/post/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 소켓 만들기 프로그래머의 실시간 경험" href="/post/2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 소켓 만들기 프로그래머의 실시간 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 소켓 만들기 프로그래머의 실시간 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 소켓 만들기 프로그래머의 실시간 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서 Gemini AI 통합" href="/post/2024-05-12-IntegrationofGeminiAIInReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서 Gemini AI 통합" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-IntegrationofGeminiAIInReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서 Gemini AI 통합" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서 Gemini AI 통합</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 라우터에서 경로 형성하기" href="/post/2024-05-12-FormingRoutesinReactRouter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 라우터에서 경로 형성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 라우터에서 경로 형성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 라우터에서 경로 형성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 NextJs 프로젝트에 PayPal Checkout 통합하기" href="/post/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 NextJs 프로젝트에 PayPal Checkout 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 NextJs 프로젝트에 PayPal Checkout 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">당신의 NextJs 프로젝트에 PayPal Checkout 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법" href="/post/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 19 데이터 관리 라이브러리에 미치는 영향" href="/post/2024-05-12-React19ImpactonDataManagementLibraries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 19 데이터 관리 라이브러리에 미치는 영향" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 19 데이터 관리 라이브러리에 미치는 영향" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 19 데이터 관리 라이브러리에 미치는 영향</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Type Guards in TypeScript 코드 버그를 방지하는 방법" href="/post/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Type Guards in TypeScript 코드 버그를 방지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Type Guards in TypeScript 코드 버그를 방지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Type Guards in TypeScript 코드 버그를 방지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" Jest 테스트를 최대 10배 빠르게 만들기 " href="/post/2024-05-12-MakeyourJestTestsupto10xFaster"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" Jest 테스트를 최대 10배 빠르게 만들기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" Jest 테스트를 최대 10배 빠르게 만들기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl"> Jest 테스트를 최대 10배 빠르게 만들기 </strong><div class="PostList_meta__VCFLX"><span class="date">May 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리액트 타입스크립트  Vite  리액트","description":"","date":"2024-05-12 23:08","slug":"2024-05-12-ReactTypeScriptViteReact","content":"\n\nVite는 현대 웹 프로젝트용 빌드 도구입니다. 더 빠르고 간결한 개발 경험을 제공하도록 목표로 합니다.\n\n지원되는 템플릿 프리셋은 다음과 같습니다:\n\n![React TypeScript Vite 프로젝트 생성](/assets/img/2024-05-12-ReactTypeScriptViteReact_0.png)\n\n첫 번째 React TypeScript 프로젝트를 생성하는 중:\n\n\n\n```js\nnpm create vite@latest my-react-ts-app -- --template react-ts\n...\ncd my-react-ts-app\nnpm install\nnpm run dev\n```\n\nCommand line interface:\n\n```js\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // 개발 서버 시작, 별칭: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // 프로덕션을 위한 빌드\n    \"preview\": \"vite preview\" // 로컬에서 프로덕션 빌드 미리 보기\n  }\n}\n```\n\n추가 CLI \"port\" 옵션 지정:\n\n\n\nvite.config.ts 파일을 업데이트하는 중입니다:\n\n```js\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 4200,\n  }\n})\n```\n\n도움이 되셨길 바랍니다. 읽어 주셔서 감사합니다. 🙏\n\n저와 소통해요! 저는 다음에서 찾을 수 있습니다:\n\n\n\n- Medium: [https://medium.com/@nhannguyendevjs/](https://medium.com/@nhannguyendevjs/)\n- Dev: [https://dev.to/nhannguyendevjs/](https://dev.to/nhannguyendevjs/)\n- Hashnode: [https://nhannguyen.hashnode.dev/](https://nhannguyen.hashnode.dev/)\n- Linkedin: [https://www.linkedin.com/in/nhannguyendevjs/](https://www.linkedin.com/in/nhannguyendevjs/)\n- X (formerly Twitter): [https://twitter.com/nhannguyendevjs/](https://twitter.com/nhannguyendevjs/)\n- Buy Me a Coffee: [https://www.buymeacoffee.com/nhannguyendevjs](https://www.buymeacoffee.com/nhannguyendevjs)","ogImage":{"url":"/assets/img/2024-05-12-ReactTypeScriptViteReact_0.png"},"coverImage":"/assets/img/2024-05-12-ReactTypeScriptViteReact_0.png","tag":["Tech"],"readingTime":2},{"title":"React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유","description":"","date":"2024-05-12 23:07","slug":"2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact","content":"\n\n리액트 개발자로서, UI에 대해 함수형 컴포넌트 또는 클래스 컴포넌트를 사용할 수 있습니다. 클래스 컴포넌트는 리액트 개발자들이 선호하는 선택이었습니다. 그러나 2018년 리액트 버전 16.8에서 리액트 훅이 소개되면서 함수형 컴포넌트가 리액트 개발자들에게 선호되는 선택이 되었습니다.\n\n![이미지](/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png)\n\n# 왜 리액트 개발자들이 과거에 클래스 컴포넌트를 함수형 컴포넌트보다 선호했는가\n\n리액트에서 컴포넌트 UI를 렌더링하는 두 가지 방법이 있습니다. 하나는 JavaScript 함수인 함수형 컴포넌트이고, 다른 하나는 JavaScript 클래스인 클래스 컴포넌트입니다. 클래스 컴포넌트는 UI를 동적으로 만들기 위해 로직과 상태를 추가할 수 있어서 리액트 개발자들에게 선호되었습니다. 함수형 컴포넌트는 과거에는 정적 UI만 렌더링했습니다. 특히 현대적인 웹 앱을 개발할 때 클래스 컴포넌트가 리액트 개발자들에게 선호되었던 이유가 분명합니다.\n\n\n\n# React에서 Hooks가 소개된 이유\n\n기존에는 클래스 컴포넌트가 UI를 렌더링하는 선호 방법이었지만, 이에는 문제점이 있었습니다. 하나의 문제는 클래스 컴포넌트 사이에서 로직과 상태 데이터를 공유하는 것이 어려웠다는 점입니다. 클래스 컴포넌트 사이에서 데이터 흐름을 관리하는 것은 번거로운 작업이었습니다. 또 다른 문제는 클래스 컴포넌트가 상태 로직이 커질수록 이해하기 어렵다는 것이었습니다. 이 복잡성으로 인해 컴포넌트를 렌더링하는 것이 더 어려워졌습니다. 이러한 문제를 해결하기 위해 React에서 Hooks가 소개되었습니다. Hooks를 사용하면 개발자가 함수형 컴포넌트에 더 많은 로직과 상태를 추가할 수 있으며, 이를 통해 컴포넌트 UI를 동적으로 만들고 로직을 재사용할 수 있게 되었습니다. 결과적으로 함수형 컴포넌트는 UI 컴포넌트를 렌더링하는 선호 방법이 되었으며, Hooks를 통해 개발자들이 함수형 컴포넌트를 통해 더 명확하고 관리하기 쉬운 코드를 작성할 수 있었습니다.\n\n# 결론\n\n그래서 React 개발자로서 함수형 컴포넌트를 전용으로 사용해야 합니다. 유지보수해야 할 레거시 코드베이스가 있는 경우를 제외하고요.","ogImage":{"url":"/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png"},"coverImage":"/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png","tag":["Tech"],"readingTime":2},{"title":"웹 소켓 만들기 프로그래머의 실시간 경험","description":"","date":"2024-05-12 23:06","slug":"2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer","content":"\n\n![Crafting Web Sockets: The Real-Time Experiences of A Programmer](/assets/img/2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer_0.png)\n\n거의 1년이 지난 지금, 포트폴리오를 풍부하게 하기 위해 레스토랑 관리 시스템을 개발하는 여정을 시작한 지 얼마 되지 않았습니다. 이 시스템은 다음 세 가지 주요 패널을 갖추고 있습니다: 웹에서 액세스할 수 있는 관리자 패널과 웹을 통해 액세스할 수 있는 사용자용 패널 그리고 최적화된 모바일 사용을 위해 만들어진 라이더 패널이 있습니다. 이 여정에서 웹 소켓이 무엇이며 왜 중요한지, 그리고 일반 HTTP 요청과 어떻게 다른지 탐험하면서 그 내용을 기록한 이 블로그는 그 시기에 배운 기본 원리를 소개합니다.\n\n# 차이 발견하기: 웹 소켓 VS HTTP 요청\n\n웹 소켓과 HTTPS 요청은 각기 다른 연결 동작을 가지고 있습니다. HTTP에서는 현재 요청이 끝나면 연결이 종료되기 때문에 실시간 데이터 전송에는 적합하지 않습니다. 그에 반해 웹 소켓은 오픈 연결을 유지하여 사용자가 언제든지 데이터를 보내고 받을 수 있도록 합니다. 채팅이 웹 소켓 기술의 가장 일반적인 사용 사례 중 하나일 것입니다. 사용자들은 계속해서 연결되어 있어야 하기 때문입니다.\n\n\n\nYouTube 동영상, 기사 및 웹 소켓 관련 문서를 참고해도 MERN 스택에서 내 웹 앱을 개발하는 것은 상당히 어려웠어요. 웹 소켓을 다루기가 쉽지 않아서 성능이 문제가 될 수 있어요. 아래에 몇 가지 관련 단계가 나와 있습니다.\n\n- 설치: Node.js에서 웹 소켓을 다루기 위한 필요한 라이브러리를 설치하세요\n\n```js\nnpm install socket.io\nnpm install https\n```\n\n2. 설정: React 프론트 엔드와 Node.js 백엔드에서 웹 소켓을 설정하여 서버와 클라이언트 간의 통신이 원활하지 않게 되지 않도록 해야 해요\n\n\n\n```js\nimport { Server } from 'socket.io';\nimport http from \"http\"\n\nconst server = http.createServer(app)\n\nconst io = new Server(server,{\n  cors: {\n      origin: process.env.BASE_URL, \n      methods: [\"GET\", \"POST\"]\n  }\n})\n/*\n프론트엔드의 URL 주소는 해당 origin으로 설정됩니다. 예를 들어, 프론트엔드가 localhost:3000에 위치한다면 http://localhost:3000/ 가 됩니다.\n/*\n```\n\n위의 코드는 웹 소켓을 설정하는 방법을 보여줍니다. 먼저 서버는 HTTP 서버로 생성되고 server 변수에 저장됩니다. 그 후, 이 서버는 실시간 통신을 가능하게 하는 웹 소켓 서버를 초기화하는 데 사용됩니다. 이를 통해 서버가 CORS를 지원하므로 백엔드와 프론트엔드 간 상호작용을 허용하여 실시간 통신이 가능해집니다. 마찬가지로, 설정을 올바르게 지정하여 백엔드에 있는 애플리케이션이 지정된 엔드 포인트를 통해 올바른 위치로 이동하도록 해야 합니다.\n\n```js\nconst app = express();\n\napp.listen(PORT, () =\u003e console.log(`서버 포트: ${PORT}`));\n```\n\n위와 같이 앱을 서버를 통해 듣도록 설정해야 합니다.\n```\n\n\n\n```js\n서버.listen(PORT, () =\u003e console.log(`서버 포트: ${PORT}`));\n```\n\n웹 소켓이 연결되었는지 확인하려면 아래 코드를 사용하여 웹 소켓이 성공적으로 설정되었는지 테스트할 수 있습니다.\n\n```js\nio.on(\"connection\",(socket)=\u003e{\n  console.log(\"사용자가 연결되었습니다\",socket.id);\n}\n```\n\n3. 기능 구현: 필요한 기능을 구성하고 웹 소켓을 통해 제공되는 함수를 사용하여 적용하세요. 기능 구현\n\n\n\n라이브 데이터 전송 능력을 가진 대시 가능성으로 인해 구현 기능의 가능성은 무한하지만 어렵습니다. 관리자 패널에서 창의성을 시연하기 위해 한 예로는 데이터베이스 테이블을 모니터링하여 발생할 수 있는 변경 사항을 확인했습니다. 변경 사항이 발생하면 즉시 관리자 패널을 통해 경고 메시지를 보냅니다. 이 기능은 시스템의 기능을 전반적으로 크게 향상시킬 수 있는 즉각적인 인식과 신속한 의사 결정 옵션을 제공하는 것 외에도 관리자 인터페이스의 응답 속도와 효율성을 높입니다.\n\n```js\nimport Orders from \"./model/orders.js\"\nconst changeStream = Orders.watch()\n\nchangeStream.on('change', function(data) {\n\nconsole.log(\"주문 테이블에서 변경 감지\");\n}\n```\n\n위의 코드는 Node.js를 사용하여 MongoDB 테이블에서 변경 사항을 감지하는 방법을 보여줍니다. 이 경우 Orders 모델이 있으며 이는 파일 model/orders.js에 위치한 MongoDB 컬렉션입니다. Orders 컬렉션은 watch() 메서드를 사용하여 변경 사항을 실시간으로 모니터링하는 변경 스트림을 생성합니다. 이벤트 리스너 changeStream.on('change', function(data) '...')로 감지된 변경 사항이 있을 경우 콘솔에 주문 테이블에서 변경 감지가 출력됩니다. 변경 스트림 기능은 MongoDB를 사용할 때 테이블 내에서 편집, 삭제 또는 추가와 같은 변경 사항을 더 나은 방식으로 효과적으로 모니터링하기 위해 실제로 구현되었습니다.\n\nReact.JS에서 웹 소켓을 설정하는 첫 번째 단계는 socket.io-client를 설치하는 것입니다.\n\n\n\n```js\nnpm i socket.io-client\n```\n\n이후에 아래 코드를 통해 React JS에서 웹소켓을 구성하는 방법을 보여줍니다.\n\n```js\nimport io from 'socket.io-client';\nconst socket=io.connect(process.env.BASE_URL);\n\n/*\nprocess.env.BASE_URL를 기반 URL로 연결하면 \n서버 URL인 localhost:5000와 같은 서버가 있는 경우에는 \nhttp://localhost:5000/가 됩니다.\n/*\n```\n\n마지막 단계는 백엔드에서 프론트엔드로 데이터를 전송하기 위해 웹소켓을 활용하는 것입니다. 예를 들어, 데이터베이스 테이블이 변경되는 경우, 서버 사이트에서 프론트엔드로 메시지를 효과적으로 전송할 수 있을까요?\n\n\n\n우리는 사실 io.emit 기능을 사용하여 이것을 할 수 있어요. 위의 코드를 다음과 같이 다시 작성해 봅시다.\n\n```js\nimport Orders from \"./model/orders.js\"\nconst changeStream = Orders.watch()\n\nchangeStream.on('change', function(data) {\n\n  io.emit(\"statusChanged\", { message: \"주문 테이블에서 변경이 감지되었습니다\" });\n}\n```\n\n이제 io.emit()은 모든 연결된 클라이언트에게 메시지를 보내고, 다음과 같은 코드를 사용하여 프론트엔드에서 메시지를 받을 수 있어요.\n\n```js\nuseEffect(() =\u003e {\n\n  socket.on('statusChanged', data =\u003e {\n\n    const filtered = data.filter(item =\u003e item.status.includes(\"보류 중\"));\n    SetOrdersData(filtered)\n  });\n\n}, [socket])\n```\n\n\n\nuseEffect()은 React 컴포넌트로, 컴포넌트가 로드될 때마다 실행됩니다. 그러나 [socket]을 매개변수로 전달했기 때문에 useEffect()은 socket에 변경이 있을 때마다 실행됩니다.\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 박수를 치고 작가를 팔로우해 주시면 감사하겠습니다! 👏\n- 저희를 팔로우해 주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 주세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로그 플랫폼에 지쳤나요? Differ를 시도해 보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인해 보세요","ogImage":{"url":"/assets/img/2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer_0.png"},"coverImage":"/assets/img/2024-05-12-CraftingWebSocketsTheReal-TimeExperiencesofAProgrammer_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트에서 Gemini AI 통합","description":"","date":"2024-05-12 23:05","slug":"2024-05-12-IntegrationofGeminiAIInReact","content":"\n\n여러분은 Gemini AI 도구에 대해 알고 계시죠. 친숙하지 않은 분들을 위해 간단히 소개하면, Gemini AI는 Google에서 개발한 AI 도구에요. 이 기사에서는 React 애플리케이션에 Gemini AI를 통합하는 과정을 안내해 드릴게요.\n\n단계 1: React 애플리케이션에 다음 npm 패키지를 설치해 주세요.\n\n```js\nnpm i @google/generative-ai\n```\n\n우리는 응용 프로그램에서 Gemini AI를 사용하기 위해 개발자 API 키가 필요해요. 개발자 API 키를 생성하려면 다음 링크를 클릭하여 한 개 만들어 주세요. 생성되면 애플리케이션에서 더 사용할 수 있도록 안전한 위치에 복사해 두세요.\n\n\n\naistudio.google.com\n\n```js\nimport { GoogleGenerativeAI } from '@google/generative-ai';\n```\n\n위 모듈을 컴포넌트의 최상위 수준에서 가져와서 다음 코드 스니펫을 컴포넌트 내에 붙여넣고 API 키를 전달해주세요.\n\n```js\n const genAI = new GoogleGenerativeAI(\n    \"API 키\"\n  );\n```\n\n\n\n제공된 코드 스니펫에서 우리는 API 키를 전달하여 GoogleGenerativeAI의 인스턴스를 초기화하고 있습니다. 객체를 생성하면 제공하는 기능에 액세스할 수 있습니다.\n\n저희 Gemini AI는 우리의 질문에 답변하고 응답하는 기능을 제공합니다. Gemini AI와 소통하기 위해 간단히 입력 메시지, 즉 프롬프트를 제공하면 됩니다.\n\n```js\n  const [inputValue, setInputValue] = useState(''); \n\n\n   const handleInputChange = (e) =\u003e {\n    setInputValue(e.target.value);\n  };\n\n\u003cinput\n       type=\"text\"\n       value={inputValue}\n       onChange={handleInputChange}\n       placeholder=\"Ask Me Something You Want\"\n       className=\"input-field\"\n     /\u003e\n```\n\n위 코드 스니펫에서는 사용자로부터 입력을 받아와서 변수처럼 상태로 업데이트하는 inputValue라는 것을 읽고 있습니다.\n\n\n\n```js\nconst [promptResponses, setPromptResponses] = useState([]);\n\nconst getResponseForGivenPrompt = async () =\u003e {\ntry{\n  const model = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n  const result = await model.generateContent(inputValue);\n  const response = await result.response;\n  const text = await response.text();\n  setPromptResponses([\n    ...promptResponses,\n    text\n  ]);\n}\ncatch(error){\n  console.log(\"Something Went Wrong\");\n}\n};\n\n\u003cbutton onClick={getResponseForGivenPrompt}\u003eSend\u003c/button\u003e\n```\n\n'전송' 버튼을 클릭하면 inputMessage 또는 Your Prompt를 입력한 후 getResponseForGivenPrompt라는 함수가 호출됩니다. 이 함수에서는 모델을 얻고 generateContent 메소드를 호출하여 해당 메소드에 프롬프트 또는 inputMessage를 전달합니다. 이 메소드는 우리의 Prompt 또는 input Message에 대한 내용이나 답변을 생성합니다. 그 결과는 promptResponses라는 상태 변수에 업데이트됩니다.\n\n```js\n{promptResponses.map((promptResponse, index) =\u003e (\n  \u003cdiv key={index} \u003e\n    \u003cdiv \u003e{promptResponse}\u003c/div\u003e\n  \u003c/div\u003e\n))}\n```\n\n위 코드 스니펫은 `promptResponses` 배열을 반복하며 각 응답을 UI에 표시합니다.\n```  \n\n\n\n여기에 완전한 코드가 있어요.\n\n```js\nimport React, { useState } from 'react';\nimport { GoogleGenerativeAI } from '@google/generative-ai';\n\nfunction GeminiInReact() {\n  const [inputValue, setInputValue] = useState('');\n  const [promptResponses, setpromptResponses] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const genAI = new GoogleGenerativeAI(\n    \"API KEY\"\n    // 여기에 당신의 API 키를 넣어주세요\n  );\n\n  const handleInputChange = (e) =\u003e {\n    setInputValue(e.target.value);\n  };\n\n  const getResponseForGivenPrompt = async () =\u003e {\n    try {\n      setLoading(true)\n      const model = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n      const result = await model.generateContent(inputValue);\n      setInputValue('')\n      const response = result.response;\n      const text = response.text();\n      console.log(text)\n      setpromptResponses([...promptResponses, text]);\n\n      setLoading(false)\n    } catch (error) {\n      console.log(error)\n      console.log(\"문제가 생겼어요\");\n      setLoading(false)\n    }\n  };\n\n  return (\n    \u003cdiv className=\"container\"\u003e\n      \u003cdiv className=\"row\"\u003e\n        \u003cdiv className=\"col\"\u003e\n          \u003cinput\n            type=\"text\"\n            value={inputValue}\n            onChange={handleInputChange}\n            placeholder=\"물어보고 싶은 것을 말해주세요\"\n            className=\"form-control\"\n          /\u003e\n        \u003c/div\u003e\n        \u003cdiv className=\"col-auto\"\u003e\n          \u003cbutton onClick={getResponseForGivenPrompt} className=\"btn btn-primary\"\u003e전송\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n\n      {loading ? (\n        \u003cdiv className=\"text-center mt-3\"\u003e\n          \u003cdiv className=\"spinner-border text-primary\" role=\"status\"\u003e\n            \u003cspan className=\"visually-hidden\"\u003e로딩중...\u003c/span\u003e\n            // 당신의 질문에 대한 답변이 생성되는 동안에 표시되는 메시지\n          \u003c/div\u003e\n        \u003c/div\u003e\n      ) : (\n        promptResponses.map((promptResponse, index) =\u003e (\n          \u003cdiv key={index}\u003e\n            \u003cdiv className={`response-text ${index === promptResponses.length - 1 ? 'fw-bold' : ''}`}\u003e{promptResponse}\u003c/div\u003e\n            // 가장 최근 응답이 굵게 표시됩니다\n          \u003c/div\u003e\n        ))\n      )}\n    \u003c/div\u003e\n  );\n}\n\nexport default GeminiInReact;\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-IntegrationofGeminiAIInReact_0.png\" /\u003e\n\n의문점이 있으시면 이 게시물에 댓글을 달아주세요, 답변해 드릴게요 :)\n\n\n\n---Ashok Adurinti","ogImage":{"url":"/assets/img/2024-05-12-IntegrationofGeminiAIInReact_0.png"},"coverImage":"/assets/img/2024-05-12-IntegrationofGeminiAIInReact_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 라우터에서 경로 형성하기","description":"","date":"2024-05-12 23:03","slug":"2024-05-12-FormingRoutesinReactRouter","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png\" /\u003e\n\n리액트는 웹 개발 세계를 뒤흔들 정도로 인기 있는 프런트엔드 자바스크립트 라이브러리입니다. 그 인기의 이유 중 하나는 컴포넌트 기반 접근 방식으로, 웹 페이지 UI가 여러 컴포넌트나 함수로 나뉘어 효율적이고 인터랙티브한 사용자 인터페이스를 만들어내기 때문입니다. 오픈 소스 라이브러리인 리액트는 개발자들에게 뛰어난 웹 응용프로그램을 만들 수 있는 무한한 가능성을 제공합니다. 이 글에서는 특정 패키지인 React Router 패키지에 초점을 맞추어 다룰 것인데, 이 패키지는 리액트 응용프로그램에서 URL 라우팅을 통해 여러 리액트 컴포넌트의 탐색을 처리할 수 있도록 합니다.\n\n# 시작하기 전에\n\n아래 내용은 Windows OS 환경에서 Visual Studio Code를 코드 편집기로 사용하여 React Router와 React를 사용하는 방법에 대한 상세한 가이드를 제공합니다. 예시는 React 버전 18.3과 React Router 버전 6.2를 기반으로 합니다. 그러나 세팅 과정에서 다른 점이 발견된다면, 설치된 패키지 버전을 확인하기 위해 package.json 파일을 확인하는 것이 좋습니다. 리액트와 리액트 라우터가 계속 발전함에 따라, 이 안내서의 코드는 오래되어질 수 있습니다. 리액트와 리액트 라우터는 자신들의 패키지의 최신 버전으로 업그레이드하기 위한 상세한 문서를 제공하고 있습니다.\n\n\n\n# 기본 설정\n\n시작하려면 기본적인 React 앱을 만들어야 합니다. 필요한 패키지를 수동으로 코딩하고 다운로드하는 방법도 있지만, React에서는 더 간단한 대안을 제공합니다. 먼저 터미널에서 앱을 저장할 디렉토리로 이동합니다. 그런 다음 해당 명령을 실행하세요.\n\n```js\nnpx create-react-app your-app-name\n```\n\n이 명령은 항상 현재 React 버전이 설치되어 있는지 확인합니다. 그런 다음이 명령을 사용하여 앱으로 이동합니다:\n\n\n\n```js\ncd your-app-name\n```\n\n설정에 따라 오픈 명령이 다를 수 있습니다. 제가 사용하는 것은 Visual Studio Code에서 앱을 열기 위해 code . 입니다. 어떤 경우든 코드 편집 소프트웨어가 터미널에 연결되어 있는 것이 중요합니다. 기본적인 React 코딩 환경만 필요하다면 모두 준비된 상태입니다! 하지만 싱글 페이지 애플리케이션을 더욱 확장하고 싶다면 클라이언트 측 라우팅을 활용하여 효율적으로 만들 수 있습니다.\n\n# 클라이언트 측 라우팅이란?\n\n이 주제에 대해 자세히 설명하진 않겠지만, 기본 개념에 대해 간단히 설명해 드릴게요. 더 자세히 알고 싶다면 이와 같은 유용한 블로그 포스트와 같은 많은 자료들이 있습니다. 서버 측 라우팅에서는 웹페이지의 링크를 클릭할 때 라우팅이 발생하며 해당 링크 URL을 가집니다. 그러면 브라우저는 해당 특정 페이지에 대한 GET 요청을 서버에 생성하고 서버는 페이지를 그 URL 라우트로 채우기 위해 필요한 데이터로 응답합니다. 사용자가 경험하는 대부분의 버퍼링은 이 과정에서 생성된 GET 요청으로 인한 것입니다. 반면 클라이언트 측 라우팅은 이러한 방식과는 다릅니다. JavaScript를 통해 모든 라우팅을 처리하고 초기 로드 중에 모든 요청을 수행합니다. 이 기술에는 여러 장단점이 있지만, 대부분의 사용자가 빠른 속도를 경험하는 장점이 있습니다. 다음 단락에서는 React Router에 대해 살펴보며 이 라우팅 논리를 React 환경에서 사용하는 것이 훨씬 쉬워진 패키지에 대해 논의할 것입니다.```\n\n\n\n# React Router 설정하기\n\nReact Router Dom의 도구를 사용하려면 먼저 React 애플리케이션에 설치해야 합니다. React 애플리케이션 내에서 아래 명령어를 실행해주세요:\n\n```js\nnpm i react-router-dom\n```\n\n그런 다음 package.json 파일을 확인하고, 다음과 유사한 정보를 찾아보세요:\n\n\n\n```js\r\n//\n\"dependencies\": {\n    \"@testing-library/jest-dom\": \"^5.17.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"react-router-dom\": \"^6.23.0\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n//\r\n```\n\n만약 React Router Dom 부분에서 버전이 v5 이상이면 모두 설정이 완료된 것입니다!\n\n만약 앞에서 설명한대로 Create React App을 사용했다면, 아래 이미지는 코드 편집기에 따라 다를 수는 있지만 완전히 같아야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_1.png\" /\u003e\n\n\n\n지금은 React가 index.js 파일을 통해 App.js만 렌더링하고 있어요. 이 블로그를 만드는 목적을 완전히 무너뜨리고 있네요! 그래서 변경할게요. index.js 파일로 이동해서 필요한 변경사항을 해봐요.\n\n원래 코드:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cApp /\u003e\n  \u003c/React.StrictMode\u003e\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n```\n\n다음과 같이 변경해주세요:\n\n\n\n```js\r\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom';\nconst router = createBrowserRouter([\n  {\n    path : '/',\n    element : \u003cApp /\u003e\n  }\n])\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\u003cRouterProvider router={router}/\u003e)\n\n// 알겠어요. React에서 특정 컴포넌트를 렌더링할 때는, root.render을 사용하여 특정 div의 ID가 있는 위치에 컴포넌트를 표시합니다. 그러나 만약 URL 경로에 기반하여 여러 컴포넌트를 렌더링하고 싶을 때는 어떻게 해야 할까요? 이때 React Router Dom 도구가 필요합니다. React Router Dom을 구현하려면 먼저 react-router-dom에서 createBrowserRouter와 RouterProvider를 가져와야 합니다. createBrowerRouter는 애플리케이션 내에서 탐색하는 데 필요한 라우터를 생성하고, RouterProvider는 라우터를 애플리케이션에 제공합니다. 그런 다음에는 URL 경로를 담을 수 있는 router라는 변수를 설정합니다. 이 변수에는 배열이 사용됩니다. router 배열을 사용하면 URL 경로를 해당하는 컴포넌트로 매핑할 수 있습니다. 모든 애플리케이션에는 지정된 \"홈\" 페이지가 필요하기 때문에, 사용자가 웹사이트로 이동할 때 초기로드할 컴포넌트로 App.js를 만들었습니다. 이는 router 배열 내에서 객체를 만들어 이루어졌습니다. 그런 다음 \"path\" 키를 사용하여 해당 URL 경로를 입력하여 그에 연결된 컴포넌트를 표시할 수 있습니다. \"element\" 키를 사용하여 해당 URL 경로의 사용자가 DOM을 표시하는 데 사용할 컴포넌트를 할당했습니다. 마지막으로 ReactProvider를 사용하여 일반적인 React 컴포넌트처럼 호출하고 변수 router를 속성(prop)으로 넘겨줍니다. 이를 통해 React 애플리케이션이 사용자가 입력한 URL 경로에 따라 동적으로 다른 컴포넌트를 렌더링할 수 있게 되었습니다.\n\n좋아요, 모든 것을 이해했어요. 그러나 사용자가 다른 URL로 이동하는 방법은 어떻게 할까요? URL 경로를 직접 입력하는 것은 좋지 않은 사용자 경험입니다. 이때 React Router가 제공하는 또 다른 도구인 Link와 Navlink를 활용합니다. 이 도구들을 사용하는 방법을 알아보겠습니다. src 내의 두 번째 URL에 연결된 다른 React 컴포넌트를 만들어보겠습니다. 이 블로그에서는 JSX와 같은 React 컴포넌트 구문에 대한 내용을 다루지 않지만, 더 자세히 알고 싶은 사람들을 위한 좋은 자료가 많이 있습니다. 물론 가장 좋은 자료는 React 문서 자체입니다.\n\n여기 우리의 기본 예제 컴포넌트가 있습니다```\n\n\n\n![2024-05-12-FormingRoutesinReactRouter_2.png](/assets/img/2024-05-12-FormingRoutesinReactRouter_2.png)\n\n이 시점에서 App 컴포넌트가 콘텐츠로 가득 찼다는 것을 눈치챘을 것입니다. 이 콘텐츠는 create react app 명령을 사용하여 애플리케이션을 생성할 때 채워졌습니다. 함수 자체와 내부의 wrapper div만 남기고 모두 안전하게 삭제할 수 있습니다. App 컴포넌트 내에 h1 요소에 코드를 추가하여 예제 컴포넌트와 동일하게 텍스트 내용을 \"hello\"로 만드세요.\n\n![2024-05-12-FormingRoutesinReactRouter_3.png](/assets/img/2024-05-12-FormingRoutesinReactRouter_3.png)\n\npackage.json 파일로 이동하여 스크립트 섹션을 살펴보면 다음과 같은 항목이 있는 것을 확인할 수 있습니다:\n\n\n\n```json\n\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n```\n\n이 명령은 터미널에서 사용할 수 있는 스크립트입니다. 터미널에서 `npm start`를 실행하여 시작 스크립트를 실행하면 모의 프론트엔드 서버가 실행되어 컴포넌트를 렌더링할 것입니다.\n\n이 시점에는 모킹 페이지에 검은색 Hello가 표시되어 있어야 합니다. 잘 했어요! 그런데 예시 컴포넌트는 어디로 갔을까요? 페이지를 렌더링하는 방법을 생각해보세요. 다시 index.js로 돌아가서 예시 컴포넌트를 렌더링할 페이지로 추가해야 합니다. 그러면 이제 그렇게 해 봅시다!\n\n![React Router를 사용한 라우트 구성](/assets/img/2024-05-12-FormingRoutesinReactRouter_4.png)```\n\n\n\n저희는 예제 컴포넌트를 index.js에 불러왔고, 그 후에 라우팅 오브젝트를 형성하여 예제에 라우팅 URL을 지정했습니다. 이제 URL \"/example\"을 입력하면 \"Hello World!\"가 화면에 표시됩니다.\n\n이전에 말한대로, 이는 서로 다른 URL 경로 간에 이동하는 끔찍한 방법입니다. 대신 Link와 Navlink를 사용해보죠. Link와 Navlink는 모두 to 속성이라는 특별한 속성을 갖고 있으며, 이를 통해 사용자를 제공된 URL로 이동시킵니다. 두 가지의 차이점은 NavLink에는 쉽게 CSS로 스타일을 지정할 수 있는 active 클래스가 있어 사용자에게 현재 활성화된 페이지를 보여줍니다. 우선 Link만 사용해보겠습니다. 다음과 같이 두 컴포넌트에 Link를 가져오세요:\n\n```js\nimport { Link } from \"react-router-dom\"\n```\n\nApp 및 예제 컴포넌트에서 둘 다 wrapper 엘리먼트인 nav를 사용하여 링크 엘리먼트를 형성한 다음, to 속성에 해당 링크가 이동할 라우팅 경로를 제공해주세요:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_5.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_6.png\" /\u003e\n\n이제 목업 페이지로 돌아가서 링크를 클릭해보세요. URL 경로가 변경되는 것을 주목하셨나요? 이제 다른 리액트 컴포넌트로의 경로를 포함하는 싱글 페이지 애플리케이션을 성공적으로 생성했습니다!\n\n# 결론\n\n\n\n# React Router은 독특한 콘텐츠를 가진 상호 연결된 React 컴포넌트를 생성할 수 있는 무궁무진한 가능성을 제공하는 강력한 도구입니다. 동적 URL 라우팅, 상태 관리 및 useEffect 훅을 통해 혁신의 잠재력이 굉장히 높습니다. 기본 도면조차도 무한한 가능성을 탐험하고 창의성을 발휘할 수 있도록 영감을 줄 수 있습니다. 그러니 바로 React Router에 뛰어들어서, 상상력이 당신을 이끌어갈 곳을 확인해 보세요!\n\n리소스\n\n- [React 문서](https://reactjs.org/)\n- [React Router 문서](https://reactrouter.com/)","ogImage":{"url":"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png"},"coverImage":"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png","tag":["Tech"],"readingTime":8},{"title":"당신의 NextJs 프로젝트에 PayPal Checkout 통합하기","description":"","date":"2024-05-12 23:01","slug":"2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject","content":"\n\n## NEXT.JS 앱 라우터에 관한 기사\n\n![이미지](/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png)\n\n참고: Next.Js 앱 라우터를 사용할 것입니다. 페이지 라우터가 아닙니다.\n\n간단한 전자상거래 스토어를 만드는 데 항상 고민했었습니다. 카트와 체크아웃이 제 머리를 얽히게 만들었는데, Stripe, PayPal 또는 심지어 Square를 웹사이트에 통합하려고 노력했기 때문입니다.\n\n\n\n하지만 전자 상거래 스토어에서의 고난이 그치지 않았습니다. 결제 통합 시에도 고난이 있었습니다. 그래서 웹사이트용 결제 포털을 만드는 일에 나는 압도되었습니다. \"이걸 어떻게 해야하지?\"라고 스스로 물었습니다.\n\nSquare는 웹사이트에 통합하기 가장 어려운 지불 프로세서입니다. 대면 거래에 더 적합합니다. 그럼에도 불구하고 Square로 설정을 해보았지만 전혀 실패했습니다.\n\n이어 Stripe로 넘어가 보겠습니다. 이것은 온라인 비즈니스에 좋은 옵션입니다. 그러나 고객 서비스와 관련된 다른 문제로 통합에 들어가기 전에 실패했습니다. 그래서 다른 것을 찾아봐야 했습니다.\n\n마지막으로 PayPal을 시도해 본 결과, 다른 온라인 비즈니스에서 성공을 들은 뒤, PayPal로 결제 포털을 만드는 데 성공했습니다. 이제 그 방법을 보여드릴 차례입니다. 그러니 함께 알아보겠습니다:\n\n\n\n# 시작하기\n\n![이미지](/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_1.png)\n\n알겠어요. 저는 뭔가 간단한 것을 이루고 싶었어요. 사용자가 지불할 금액을 선택하고 지불하도록 하고 싶었어요. 그건 충분히 간단한 목표죠.\n\n시작하려면 API 엔드포인트를 만드는 방법이 필요합니다. 우리는 App Router를 사용하기 때문에 API 엔드포인트에 대한 제 게시물을 확인해주세요.\n\n\n\n만약 당신이 이 글을 읽고 있고 Next.Js 프로젝트를 어떻게 생성하는지 모른다면 뭐하고 있는 거야!? 어쨌든, Next.Js 프로젝트를 만들려면 터미널에서 npx create-next-app@latest을 실행하면 됩니다.\n\n# 금액 구하는 중\n\n이어서, 지불 포털용 페이지를 생성하세요. 또한, 처음에 payment-form이라고 이름 지은 컴포넌트를 만드세요. 왜냐하면 금액 페이지를 체크아웃 페이지와 결합할 것이라고 생각했기 때문입니다. 그러나 결국 그렇게 하지 않았습니다.\n\n그리고 우리가 하는 동안, API 엔드포인트와 이를 위해 필요한 나머지 파일들도 만들어봅시다. 마지막에는 이렇게 된 것처럼 보일 거에요:\n\n\n\n```js\n프로젝트/\n│\n├──페이지/api/\n│   ├── get-token.ts\n|   ├── paypal-client-id.ts\n|   ├── paypal.ts\n└──src/app\n    ├──결제-포털/\n    │   ├── page.tsx\n    └── 결제-페이지/\n    │  ├── page.tsx\n    ├── 컴포넌트/\n    │   ├── payment-form.tsx\n    │   ├── paypal-buttons.tsx\n    ├── layout.tsx\n    ├── page.tsx\n```\n\n우리는 `payment-form.tsx` 파일 맨 위에 ‘use client’를 추가해서, 이 파일의 코드를 기본 서버 측이 아닌 클라이언트 측으로 만들 수 있습니다.\n\n또한, react에서 `useState` 훅과 axios, 그리고 next/navigation에서 `useRouter` 훅을 import 해보겠습니다:\n\n```js\n'use client';\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { useRouter } from 'next/navigation';\n```\n\n\n\n이제 PaymentFormProps 인터페이스를 사용하여 PaymentForm 컴포넌트의 예상 프롭을 정의해 봅시다.\n\n```js\ninterface PaymentFormProps {\n  onSuccess: (orderId: string) =\u003e void;\n}\n```\n\n우리는 onSuccess를 프롭으로 받는 함수형 컴포넌트를 정의해야 합니다. 이를 PaymentForm이라고 부르겠습니다.\n\n```js\nconst PaymentForm: React.FC\u003cPaymentFormProps\u003e = ({ onSuccess }) =\u003e {\n\n}\n```\n\n\n이제, handlePaymentSubmit이란 이름의 함수를 만들어서 결제 양식 제출을 처리하는 함수를 만들겠습니다. 이 함수는 POST 요청을 사용하여 api/paypal로 결제 양식을 제출하려 합니다. 성공하면 Payment-Page로 이동합니다. 실패하면 오류 메시지를 표시합니다:\n\n```js\n  const handlePaymentSubmit = async () =\u003e {\n    try {\n      setLoading(true);\n      setError('');\n\n      const response = await axios.post('/api/paypal', { amount });\n\n      setLoading(false);\n\n      if (response.data.success) {\n        onSuccess(response.data.orderId);\n        router.push(`/Payment-Page?amount=${amount}`);\n      } else {\n        setError(response.data.error);\n      }\n    } catch (error) {\n      console.error('결제 초기화 오류:', error);\n      setLoading(false);\n      setError('결제 초기화 중 오류가 발생했습니다. 나중에 다시 시도해주세요.');\n    }\n  };\n```\n\n마지막으로, 입력 필드와 제출 버튼을 추가하겠습니다:\n\n```js\n  return (\n    \u003cdiv className=\"flex flex-col gap-4 items-center\"\u003e\n      \u003clabel\u003e\n        금액 입력:\n      \u003c/label\u003e\n      \u003cinput type=\"number\" name=\"amount\" value={amount} onChange={handleAmountChange} className='text-black text-xl font-semibold p-2 rounded'/\u003e\n      \u003cbutton onClick={handlePaymentSubmit} disabled={loading} className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded m-2\"\u003e\n        {loading ? '처리 중...' : '결제 제출'}\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e오류: {error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n```\n\n\n\n새로운 코드 아래에 `export default PaymentForm;`를 추가해주세요.\n\n최종 payment-form.tsx 코드는 다음과 같이 보여야 합니다:\n\n```js\n'use client';\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport { useRouter } from 'next/navigation';\n\ninterface PaymentFormProps {\n  onSuccess: (orderId: string) =\u003e void;\n}\n\nconst PaymentForm: React.FC\u003cPaymentFormProps\u003e = ({ onSuccess }) =\u003e {\n  const router = useRouter();\n  const [amount, setAmount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n\n  const handleAmountChange = (event: React.ChangeEvent\u003cHTMLInputElement\u003e) =\u003e {\n    setAmount(Number(event.target.value));\n  };\n\n  const handlePaymentSubmit = async () =\u003e {\n    try {\n      setLoading(true);\n      setError('');\n\n      const response = await axios.post('/api/paypal', { amount });\n\n      setLoading(false);\n\n      if (response.data.success) {\n        onSuccess(response.data.orderId);\n        router.push(`/Payment-Page?amount=${amount}`);\n      } else {\n        setError(response.data.error);\n      }\n    } catch (error) {\n      console.error('Error initiating payment:', error);\n      setLoading(false);\n      setError('An error occurred while initiating payment. Please try again later.');\n    }\n  };\n\n  return (\n    \u003cdiv className=\"flex flex-col gap-4 items-center\"\u003e\n      \u003clabel\u003e\n        Enter Amount: \n      \u003c/label\u003e\n      \u003cinput type=\"number\" name=\"amount\" value={amount} onChange={handleAmountChange} className='text-black text-xl font-semibold p-2 rounded'/\u003e\n      \u003cbutton onClick={handlePaymentSubmit} disabled={loading} className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded m-2\"\u003e\n        {loading ? 'Processing...' : 'Submit Payment'}\n      \u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003eError: {error}\u003c/p\u003e}\n    \u003c/div\u003e\n  );\n};\n\nexport default PaymentForm;\n```\n\n# 주문 생성하기\n\n\n\npaypal.ts 파일에 NextApiRequest와 NextApiResponse를 next에서, axios를 그리고 get-token.ts에서 getToken을 import해서 추가해봐요. getToken 코드는 나중에 보여줄게요.\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport axios from 'axios';\nimport getToken from './get-token ';\n```\n\n이제 API 엔드포인트를 만들어봅시다. 먼저 HTTP 메소드가 POST인지 확인한 후, 요청 본문에서 amount를 추출해요. 우리는 getToken 함수를 호출해서 액세스 토큰을 받을 거에요. PayPal에서 생성된 액세스 토큰은 .env 파일에 있어야 해요. 코드는 그런 다음 PayPal API로 POST 요청을 보낼 거에요:\n\n```js\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    try {\n      const { amount } = req.body;\n      const accessToken = await getToken();\n\n      const paypalResponse = await axios.post(\n        'https://api.paypal.com/v2/checkout/orders',\n        {\n          intent: 'CAPTURE',\n          purchase_units: [\n            {\n              amount: {\n                currency_code: 'USD',\n                value: amount.toString(),\n              },\n            },\n          ],\n        },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        }\n      );\n\n      const { id: orderId } = paypalResponse.data;\n\n      res.status(200).json({ success: true, orderId });\n    } catch (error) {\n      console.error('PayPal API error:', error);\n      res.status(500).json({ success: false, error: 'Internal server error' });\n    }\n  } else {\n    res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n}\n```\n\n\n\n위의 코드를 한국어로 번역하면 다음과 같습니다:\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport axios from 'axios';\nimport getToken from './get-token';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    try {\n      const { amount } = req.body;\n      const accessToken = await getToken();\n\n      const paypalResponse = await axios.post(\n        'https://api.paypal.com/v2/checkout/orders',\n        {\n          intent: 'CAPTURE',\n          purchase_units: [\n            {\n              amount: {\n                currency_code: 'USD',\n                value: amount.toString(),\n              },\n            },\n          ],\n        },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${accessToken}`,\n          },\n        }\n      );\n\n      const { id: orderId } = paypalResponse.data;\n\n      res.status(200).json({ success: true, orderId });\n    } catch (error) {\n      console.error('PayPal API 에러:', error);\n      res.status(500).json({ success: false, error: '내부 서버 오류' });\n    }\n  } else {\n    res.status(405).json({ success: false, error: '허용되지 않은 메소드' });\n  }\n}\n```\n\n# Access Token 가져오기\n\nget-token.ts 코드에 추가할 예정입니다.\n\n\n\naxios를 가져와봐요:\n\n```js\nimport axios from 'axios';\n```\n\n그리고 PAYPAL_CLIENT_ID 및 PAYPAL_CLIENT_SECRET를 환경 변수에서 가져와요:\n\n```js\nconst CLIENT_ID = process.env.PAYPAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.PAYPAL_CLIENT_SECRET;\n```\n\n\n\n그럼 우리는 PayPal API에서 액세스 토큰을 검색하는 getToken이라는 비동기 함수를 만들고 싶어요:\n\n```js\nconst getToken = async () =\u003e {\n  const credentials = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');\n\n  const response = await axios.post(\n    'https://api.paypal.com/v1/oauth2/token',\n    'grant_type=client_credentials',\n    {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${credentials}`,\n      },\n    }\n  );\n\n  return response.data.access_token;\n};\n\nexport default getToken;\n```\n\n전체 코드는 다음과 같습니다:\n\n```js\nimport axios from 'axios';\n\nconst CLIENT_ID = process.env.PAYPAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.PAYPAL_CLIENT_SECRET;\n\nconst getToken = async () =\u003e {\n  const credentials = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');\n\n  const response = await axios.post(\n    'https://api.paypal.com/v1/oauth2/token',\n    'grant_type=client_credentials',\n    {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${credentials}`,\n      },\n    }\n  );\n\n  return response.data.access_token;\n};\n\nexport default getToken;\n```\n\n\n\n# PayPal 버튼 만들기\n\nPayPal 버튼을 만들기 위해 paypal-buttons.tsx 파일을 서버 측이 아닌 클라이언트 측으로 변경해 보겠습니다. ‘use client’를 추가해 주세요. 그리고 여기서 react에서 useEffect 훅을 import해 주세요:\n\n```js\n'use client';\nimport React, { useEffect } from 'react';\n```\n\nTypeScript를 사용하기 때문에 전역 창에 속성을 추가하여 오류를 방지해 보겠습니다:\n\n\n\n```js\n전역을 선언합니다:\n   \n```typescript\ndeclare global {\n    interface Window {\n      paypal?: any;\n    }\n}\n```\n\n이제 네 개의 속성 유형을 지정하는 객체를 인수로 취하는 함수형 컴포넌트를 정의해야 합니다:\n\n```js\nconst PayPalPaymentButton = ({ amount, paypalClientId, onSuccess, onError }: { amount: number; paypalClientId: string | null; onSuccess: () =\u003e void; onError: (err: any) =\u003e void; }) =\u003e {\n\n}\n```\n\n함수형 컴포넌트인 PayPalPaymentButton 안에서 useEffect를 사용하여 컴포넌트가 마운트될 때 PayPal SDK 스크립트를 DOM에 추가하세요:\n\n\n\n```js\n  useEffect(() =\u003e {\n    const script = document.createElement('script');\n    script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}`;\n    script.async = true;\n    script.onload = () =\u003e {\n      initializePayPalButton();\n    };\n    document.body.appendChild(script);\n\n    return () =\u003e {\n      document.body.removeChild(script);\n    };\n  }, []);\n```\n\n이제 웹페이지에 PayPal 버튼을 렌더링하는 함수를 만들어봅시다:\n\n```js\n  const initializePayPalButton = () =\u003e {\n    window.paypal.Buttons({\n      createOrder: function(data: any, actions: any) {\n        return actions.order.create({\n          purchase_units: [{\n            amount: {\n              value: amount,\n              currency_code: 'USD', // 원하는 통화로 변경\n            },   \n            application_context: {\n              user_action: 'PAY_NOW',\n              shipping_preference: 'NO_SHIPPING',\n              payment_method: { payee_preferred: 'IMMEDIATE_PAYMENT_REQUIRED' },\n              return_url: 'https://YOUR_WEBSITE_URL',\n              cancel_url: 'https://YOUR_WEBSITE_URL',\n            },\n          }],\n        });\n      },\n      onApprove: function(data:any, actions:any) {\n        return actions.order.capture().then(function(details: any) {\n          onSuccess();\n        });\n      },\n      onError: function(err: any) {\n        onError(err);\n      },\n    }).render('#paypal-button-container');\n  };\n```\n\n이제 버튼을 표시하는 것만 남았습니다:\n```\n\n\n\n```js\nreturn \u003cdiv id=\"paypal-button-container\" className='bg-gray-200'\u003e\u003c/div\u003e;\n```\n\n최종 코드:\n\n```js\n'use client';\nimport React, { useEffect } from 'react';\n\ndeclare global {\n    interface Window {\n      paypal?: any;\n    }\n}\n\nconst PayPalPaymentButton = ({ amount, paypalClientId, onSuccess, onError }: { amount: number; paypalClientId: string | null; onSuccess: () =\u003e void; onError: (err: any) =\u003e void; }) =\u003e {\n  useEffect(() =\u003e {\n    const script = document.createElement('script');\n    script.src = `https://www.paypal.com/sdk/js?client-id=${paypalClientId}`;\n    script.async = true;\n    script.onload = () =\u003e {\n      initializePayPalButton();\n    };\n    document.body.appendChild(script);\n\n    return () =\u003e {\n      document.body.removeChild(script);\n    };\n  }, []);\n\n  const initializePayPalButton = () =\u003e {\n    window.paypal.Buttons({\n      createOrder: function(data: any, actions: any) {\n        return actions.order.create({\n          purchase_units: [{\n            amount: {\n              value: amount,\n              currency_code: 'USD',\n            },   \n            application_context: {\n              user_action: 'PAY_NOW',\n              shipping_preference: 'NO_SHIPPING',\n              payment_method: { payee_preferred: 'IMMEDIATE_PAYMENT_REQUIRED' },\n              return_url: 'https://YOUR_WEBSITE_URL',\n              cancel_url: 'https://YOUR_WEBSITE_URL',\n            },\n          }],\n        });\n      },\n      onApprove: function(data:any, actions:any) {\n        return actions.order.capture().then(function(details: any) {\n          onSuccess();\n        });\n      },\n      onError: function(err: any) {\n        onError(err);\n      },\n    }).render('#paypal-button-container');\n  };\n\n  return \u003cdiv id=\"paypal-button-container\" className='bg-gray-200'\u003e\u003c/div\u003e;\n};\n\nexport default PayPalPaymentButton;\n```\n\n# PayPal 클라이언트 ID 가져오기\n\n\n\n나중에 필요할 것이므로 지금 처리해 봐요. 당신의 paypal-client-id는 환경 변수 중에 PAYPAL_CLIENT_ID가 있는지 확인하고 그것을 클라이언트 쪽으로 보내요:\n\n```js\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const paypalClientId = process.env.PAYPAL_CLIENT_ID;\n\n  if (!paypalClientId) {\n    return res.status(500).json({ error: 'PayPal client ID not found.' });\n  }\n\n  return res.status(200).json({ paypalClientId });\n}\n``` \n\n# Payment-Portal Page.tsx에 코드 추가하기\n\n\n\n```js\nimport PaymentComponent from \"../components/payment-form\";\n```\n\n결제 성공에 대한 함수를 정의하세요:\n\n```js\n  const handlePaymentSuccess = (orderId: string) =\u003e {\n    console.log('결제 성공! 주문 ID:', orderId);\n  };\n```\n\nPaymentComponent를 반환하세요:\n\n\n\n```jsx\n  return (\n    \u003cmain\u003e\n      \u003cdiv\u003e\n        \u003cPaymentComponent onSuccess={handlePaymentSuccess} /\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  );\n```\n\n# Payment-Page 페이지에 코드 추가하기\n\n파일의 맨 위에 'use client';를 추가해야 합니다. 그 다음으로 useEffect 훅, useState 훅, 그리고 Suspense를 react에서 임포트해주세요. 또한 next/navigation에서 useRouter와 useSearchParams를 임포트해주세요. 마지막으로 paypal-buttons.tsx에서 PayPalPaymentButtons를 임포트해주세요:\n\n```jsx\n'use client';\nimport React, { useEffect, useState, Suspense } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport PayPalPaymentButtons from '../ui/PayPalButtons';\n```\n\n\n\n이제 paymentPage라는 기능 구성 요소를 만들 수 있습니다. 내부에서 useRouter 훅을 사용하여 router 객체에 액세스하는 코드를 추가하고 URL에서 검색 매개 변수를 가져 오는 것을 시도해 보겠습니다. 또한 상태 변수를 선언해 봅시다:\n\n```js\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const amount = searchParams ? searchParams.get('amount') : null;\n  const [paypalClientId, setPaypalClientId] = useState\u003cstring | null\u003e(null);\n```\n\nuseEffect 훅을 사용하여 API 엔드 포인트 paypal-client-id.ts에서 PayPal 클라이언트 ID를 가져 오는 것을 시도해 보겠습니다:\n\n```js\n  useEffect(() =\u003e {\n    fetch('/api/paypal-client-id')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e {\n        if (data.paypalClientId) {\n          setPaypalClientId(data.paypalClientId);\n        } else {\n          console.error('PayPal 클라이언트 ID를 찾을 수 없습니다.');\n        }\n      })\n      .catch((error) =\u003e {\n        console.error('PayPal 클라이언트 ID를 가져 오지 못했습니다:', error);\n      });\n  }, []);\n```\n\n\n\n페이팔 클라이언트 ID가 없는 경우 \"로딩 중...\"이 표시됩니다:\n\n```js\nif (!paypalClientId) {\n  return \u003cdiv\u003e로딩 중...\u003c/div\u003e;\n}\n```\n\n성공 및 오류 처리를 다음과 같이 수행할 거에요:\n\n```js\nconst handleSuccess = () =\u003e {\n  router.push('/');\n};\n\nconst handleError = (error: any) =\u003e {\n  console.error('결제 오류:', error);\n};\n```\n\n\n\n그럼 모든 것을 표시할 거예요:\n\n```js\n  return (\n    \u003cdiv className='bg-blue-900'\u003e\n      \u003cdiv className=\"w-full bg-blue-900 flex flex-col justify-center items-center\"\u003e\n      \u003ch1 className=\"md:text-5xl text-3xl font-bold text-blue-500\"\u003e결제 페이지\u003c/h1\u003e\n      \u003cp\u003e총액: ${amount}\u003c/p\u003e\n      \u003cdiv className=\"w-screen p-14\"\u003e\n      \u003cPayPalPaymentButtons amount={parseFloat(amount as string)} paypalClientId={paypalClientId} onSuccess={handleSuccess} onError={handleError} /\u003e\n      \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n```\n\n실제 페이지는 Suspense 경계로 둘러싸여야 합니다:\n\n```js\nconst actualPage: React.FC = () =\u003e {\n  return \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\u003cPaymentPage /\u003e\u003c/Suspense\u003e;\n}\n\nexport default actualPage;\n```\n\n\n\n전체 코드:\n\n```js\n'use client';\nimport React, { useEffect, useState, Suspense } from 'react';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport PayPalPaymentButtons from '../ui/paypal-buttons';\n\nconst PaymentPage: React.FC = () =\u003e {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const amount = searchParams ? searchParams.get('amount') : null;\n\n  const [paypalClientId, setPaypalClientId] = useState\u003cstring | null\u003e(null);\n\n  useEffect(() =\u003e {\n    fetch('/api/paypal-client-id')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e {\n        if (data.paypalClientId) {\n          setPaypalClientId(data.paypalClientId);\n        } else {\n          console.error('PayPal client ID not found.');\n        }\n      })\n      .catch((error) =\u003e {\n        console.error('Failed to fetch PayPal client ID:', error);\n      });\n  }, []);\n\n  if (!paypalClientId) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  const handleSuccess = () =\u003e {\n    router.push('/');\n  };\n\n  const handleError = (error: any) =\u003e {\n    console.error('Payment error:', error);\n  };\n\n  return (\n    \u003cdiv className='bg-blue-900'\u003e\n      \u003cdiv className=\"w-full bg-blue-900 flex flex-col justify-center items-center\"\u003e\n        \u003ch1 className=\"md:text-5xl text-3xl font-bold text-blue-500\"\u003ePayment Page\u003c/h1\u003e\n        \u003cp\u003eTotal Amount: ${amount}\u003c/p\u003e\n        \u003cdiv className=\"w-screen p-14\"\u003e\n          \u003cPayPalPaymentButtons amount={parseFloat(amount as string)} paypalClientId={paypalClientId} onSuccess={handleSuccess} onError={handleError} /\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\nconst actualPage: React.FC = () =\u003e {\n  return \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\u003cPaymentPage /\u003e\u003c/Suspense\u003e;\n}\n\nexport default actualPage;\n```\n\n이렇게해요. 이 글은 Next.js 프로젝트에 PayPal 체크아웃을 통합하는 것에 대한 내용이었습니다. 파일 이름과 코드의 일부 이름으로 보았듯이, 모든 것이 가지고 있기 전에 약간 실험을 해봤습니다. 이 글이 결제 페이지를 만들 때 올바른 방향으로 안내가 되길 바랍니다. 이 튜토리얼을 좋아하셨다면 박수를 보내주시고, 팔로우를 눌러주세요. 질문이 있으시면 언제든지 답변해 드리겠습니다.\n\n즐거운 코딩되세요!\n```","ogImage":{"url":"/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png"},"coverImage":"/assets/img/2024-05-12-IntegratingPayPalCheckoutIntoYourNextJsProject_0.png","tag":["Tech"],"readingTime":19},{"title":"리액트 훅 패턴 이해 및 순수 자바스크립트에서의 구현 방법","description":"","date":"2024-05-12 22:59","slug":"2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png\" /\u003e\n\n안녕하세요! 여러분은 이들을 보았고, 그들에 대해 읽었으며 널리 사용했습니다. 하지만 그들이 어떻게 작동하며 JavaScript에서 이미 알려진 패턴을 따르는지 궁금했던 적이 있나요? 예를 들어, useState hook을 고려해 봅시다.\n\n```js\nconst [counter1, setCounter1] = useState(0);\nconst [counter2, setCounter2] = useState(0);\n```\n\nuseState는 어떻게 호출될 로컬 상태 변수(counter1 또는 counter2)를 알 수 있을까요? 두 메소드 호출이 동일한 서명을 가지고 있음을 주목해 주세요!\n\n\n\n다음 섹션으로 넘어가기 전에 잠시 생각해보세요.\n\n훅은 React의 기능으로, 함수 컴포넌트에서 상태 및 다른 React 기능을 사용할 수 있게 해줍니다. React 16.8에서 소개된 훅은 현대적인 React 개발에서 필수 요소가 되어, 컴포넌트 상태 및 라이프사이클 관리에 더 함수형 접근을 제공합니다.\n\n이 글에서는 훅 패턴을 자세히 살펴보고, 이 패턴을 순수 JavaScript에서 구현하는 방법을 제시할 것입니다. React에서 이 패턴은 모든 종류의 훅에 적용됩니다 - useState, useEffect, useId 등(React v18의 완전한 목록은 Hooks에서 확인할 수 있습니다) - 하지만 여기서는 상태 관리와 useState 훅에 초점을 맞출 것입니다.\n\n## 클래스 컴포넌트에서 상태 관리\n\n\n\n먼저 리액트 클래스 컴포넌트에서 상태 관리가 작동하는 방법을 간단히 알아보겠습니다. 리액트 클래스 컴포넌트에서 상태는 this.State 속성과 this.setState(…) 메서드로 관리됩니다:\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // 여러 상태 변수를 초기화합니다\n    this.state = {\n      value1: 0,\n      value2: 1\n    };\n  }\n \n  render() {\n    /* value1과 value2를 사용한 JSX */\n  }\n \n}\n```\n\n클래스 컴포넌트에서 상태를 업데이트하려면 this.setState를 사용합니다. 이 메서드는 컴포넌트의 상태 업데이트를 예약하고 리액트에게 컴포넌트를 다시 렌더링하도록 지시합니다 (훅이 있는 함수형 컴포넌트와 마찬가지로). 다음은 클래스 내에서 로컬 상태를 업데이트하는 방법입니다:\n\n```js\nthis.setState({ value1: this.state.value1 + 1 });\nthis.setState({ value2: this.state.value2 + 1 });\n```\n\n\n\n위의 코드에서 확인할 수 있듯이 상태는 명시적으로 키에 의해 매핑됩니다. 여기서 각 키가 특정 상태 변수에 해당하는 객체를 정의합니다. 따라서 상태 변수와 업데이트 사이의 관계가 명확하고 직접적으로 나타납니다. 이는 JavaScript에서 더 전통적이고 표준적인 코드 패턴입니다. 이제 React Hooks를 살펴보겠습니다.\n\n## 함수형 컴포넌트에서 상태 관리\n\n```js\nfunction MyComponent() {\n   \n   const [value1, setValue1] = useState(0); // 초기 render 시 value1을 0으로 초기화하거나 후속 render에서 value1을 가져옵니다.\n   const [value2, setValue2] = useState(1); // 초기 render 시 value2를 1로 초기화하거나 후속 render에서 value2를 가져옵니다.\n\n   render(\n    /* value1과 value2를 사용한 JSX */\n   );\n  ...\n}\n```\n\n클래스 컴포넌트와는 다르게, 여기서 상태 관계는 암시적입니다. 함수형 컴포넌트의 useState 훅에서는 각 상태 변수(value1 및 value2 예시에서)가 독립적으로 선언되며 업데이트 메커니즘(세터 함수)이 암시적으로 연결됩니다. 상태 변수와 연결된 객체 매핑 키가 없고, useState 호출마다 현재 상태 값과 업데이트를 위한 메서드 쌍이 반환됩니다.\n\n\n\n함수형 컴포넌트에서 상태를 업데이트하려면, React의 useState 메서드를 호출하여 해체된 'setter' 함수를 사용합니다:\n\n```js\nsetValue1(value1 + 1);\nsetValue2(value2 + 1);\n```\n\n이 글의 목적은 React Hooks에서의 **암시적 상태 연관** 이면을 탐색하고, React 이외의 일반 JavaScript에서 어떻게 구현할 수 있는지 알아보는 것입니다.\n\n# 접근 방식\n\n\n\n리액트의 useState 및 유사한 훅이 제공하는 기능은 잘 알려진 JavaScript 디자인 패턴의 전통적인 범주에 정확히 속하지는 않습니다. 대신 이는 주로 함수형 프로그래밍에서 비롯된 여러 프로그래밍 개념들을 고유하게 결합한 것으로, 주로 함수형 컴포넌트 및 반응성 모델의 리액트 컨텍스트에서 특화되어 있습니다. 이는 리액트의 렌더링 및 조정 프로세스와 원활하게 작동하도록 설계되어 있어, 전통적인 JavaScript 패턴과는 다릅니다. 그러나 여전히 몇 가지 이미 존재하는 패턴과 개념들과 느슨하게 관련짓을 수 있습니다. 이 중 몇 가지는 다음과 같습니다:\n\n- Factory Functions\nuseState는 상태의 인스턴스와 해당 setter 함수를 생성하는 일종의 팩토리 함수로 볼 수 있습니다. 팩토리 함수는 JavaScript에서 객체를 생성하고 반환하는 일반적인 패턴입니다.\n- 함수형 프로그래밍\nuseState는 변경 불가능한 상태 업데이트의 사용을 권장하며 함수형 프로그래밍 패러다임 내에서 잘 맞습니다. 여기서 함수에 부작용이 없는 순수 함수들이 존재합니다.\n- 클로저\nuseState에 의해 반환된 setter 함수(예: const [state, setState] = useState(initialValue)에서 setState부분)는 클로저입니다. 이는 함수 컴포넌트의 스코프 내에서 variable에 대한 접근을 유지하며, 그 외의 즉시적인 스코프 외부에서도 호출됩니다.\n- Command Pattern\nsetter 함수 역시 명령 패턴을 통해 볼 수 있습니다. 여기 요청(상태 변경)을 객체로 캡슐화하는 함수입니다.\n- Observer Pattern\n직접적인 옵저버 패턴의 실행은 아니지만, 리액트에서 상태 변경이 컴포넌트 재랜더링을 트리거하는 방식은 개념적으로 유사합니다. 상태는 \"주체\" 역할을 하며, 컴포넌트 재랜더링은 상태 변경에 반응하는 \"옵저버\"인 셈입니다.\n- 함수 호출 추적\n훅의 가장 중요한 측면입니다. 이를 통해 React가 특정 함수형 컴포넌트 인스턴스와 상태 및 효과를 관리하고 관련시킬 수 있습니다. 이 기능은 결국 useState나 다른 훅 함수를 여러 번 호출할 수 있게끔 해 주는 것입니다. 컴포넌트가 useState(...)를 여러 번 호출할 때 특정 상태가 어디에 대해 호출되는지를 명시적으로 나타내지 않는다는 것을 참고하세요. 이 메커니즘은 컴포넌트 내에서의 훅 호출 순서에 기반을 두고 작동합니다.\n\n다음의 리액트 코드 스니펫에서, 컴포넌트가 다시 렌더링되고 함수가 다시 호출될 때, 첫 번째 useState 호출은 내부 상태 구조의 첫 번째 \"슬롯\"(여기에서는 배열을 사용할 수 있음)에서 현재 상태를 가져오며, state1과 같습니다. 그리고 두 번째 useState 호출은 두 번째 슬롯에서 state2를 가져오게 됩니다. 이와 같은 방식으로 React가 특정 useState 호출에 어떤 상태가 대응하는지를 파악할 수 있다는 것이 중요한 포인트입니다.\n\n```js\nconst [state1, ..] = useState(...)   // 첫 번째 호출은 첫 번째 상태에 대한 매핑을 생성합니다\nconst [state2, ..] = useState(...)   // 두 번째 호출은 두 번째 상태에 대한 매핑을 생성합니다\n...\nconst [stateN, ..] = useState(...)   // N번째 호출은 n번째 상태에 대한 매핑을 생성합니다\n```\n\n7. 컴포넌트 상태 및 효과 관리\n\n\n\n이 추적 덕분에 훅의 상태가 변경되거나 이펙트가 실행되어야 할 때 React는 정확히 상호 작용해야 하는 상태나 이펙트를 알 수 있습니다. 이는 컴포넌트의 인덱싱된 목록 내에서 훅의 위치를 참조할 수 있기 때문입니다!\n\nReact에서의 훅 패턴, 특히 useState는 함수형 컴포넌트와 그들의 반응성 모델에 특화되어 있습니다. 이는 React의 렌더링 및 조화 과정과 원활하게 작동하도록 설계되어 있어서, 전통적인 JavaScript 패턴과 구분됩니다. 일부 일반적인 프로그래밍 개념을 이용하지만, React 컴포넌트 라이프사이클 및 이벤트 처리와 어우러져 있는 방식이 독특합니다.\n\n# 구현 — 첫 번째 시도\n\n이전 섹션에서 설명한 훅의 본질은 순수 JavaScript로 에뮬레이션될 수 있으며, 상태 관리 및 함수 호출 추적의 기본 개념을 보여줍니다. 우리가 만든 HookState 구현의 전체 코드를 살펴보겠습니다. 여기서 주요 부분들입니다.\n\n\n\n## 상태, 세터 및 상태 인덱스\n\n```js\nlet states = [];    // **state** 값을 보관하기 위한 배열입니다. useState와 비슷한 훅을 흉내내고 싶지만 단순히 'hooks'로 이름을 지을 수도 있습니다\nlet setters = [];   // **setter** 함수를 보관하기 위한 배열입니다\nlet stateIndex = 0; // 현재 상태 인덱스를 추적하는 카운터 역할을 합니다\n```\n\n## 인덱스 초기화 메서드\n\n이 메서드는 다시 렌더링을 시뮬레이션합니다. 각 새로운 렌더링 사이클(컴포넌트가 다시 렌더링되어야 할 때)마다 이 함수를 호출하여 상태 인덱스를 0으로 재설정해야 합니다:\n\n\n\n```js\nexport function resetHookIndex() {\n  stateIndex = 0;\n}\n```\n\n이 모든 것을 종합해보면, 여기에 순수 JavaScript로 구현된 간단한 훅 시스템이 있습니다.\n\n## HookPattern.js\n\nHookPattern.js는 useHookPattern과 resetHookIndex 두 가지 메서드를 내보냅니다. 이전에 언급했듯이, resetHookIndex는 다시 렌더링 단계를 시뮬레이션하며, 이 글에서는 훅 사용자 코드에서 수동으로 호출할 것입니다. React에서는 이것이 렌더링 및 조정 엔진의 일부이며, 프레임워크에 의해 자동으로 호출될 것이라고 믿을 수 있습니다.```\n\n\n\n```js\n// HookPattern.js\n\nlet states = []; \nlet setters = [];  \nlet stateIndex = 0;  \n\nexport function resetHookIndex() {\n  stateIndex = 0;\n}\n\nexport function useHookPattern(initialValue) {\n  const currentStateIndex = stateIndex;\n   \n  // state already initialized? \n  if (!setters[currentStateIndex]) {\n    // If not, initialize state and create a setter\n    states[currentStateIndex] = initialValue;\n    \n    setters[currentStateIndex] = (newValue) =\u003e {\n      states[currentStateIndex] = newValue;\n    };\n  }\n  \n  stateIndex++;\n  return [states[currentStateIndex], setters[currentStateIndex]];\n}\n```\n\n이제 순수 JavaScript useHookPattern을 사용해 봅시다. 이 예제에서는 React를 사용하지 않습니다.\n\n## ExampleUseHookPattern.js\n\n```js\n// ExampleUseHookPattern - 우리가 만든 HookPattern의 사용법을 보여줍니다.\n\nimport { useHookPattern, resetHookIndex } from './HookPattern';\n\nfunction ExampleHook() {\n  // 다시 렌더링하기 전에 인덱스를 리셋합니다. React에서는 렌더링 엔진의 일부입니다.\n  resetHookIndex();\n\n  const [value1, setValue1] = useHookPattern(0);\n  const [value2, setValue2] = useHookPattern(1);\n\n  function handleClick() {\n    setValue1(value1 + 1);\n    setValue2(value2 + 1);\n  }\n\n  return {\n    render: () =\u003e console.log(`Value1: ${value1}, Value2: ${value2}`),\n    handleClick\n  };\n}\n\n// 컴포넌트 렌더링 모의 실행\nconst myComponent = ExampleHook();\n\nmyComponent.render(); \n// 이는 다음을 출력해야 합니다: Value1: 0, Value2: 1\n\n// 핸들 클릭 및 상태 업데이트 모의 실행\nmyComponent.handleClick();\n\n\n// 컴포넌트 다시 렌더링 등 모의 실행\nconst myComponentUpdated = ExampleHook();\n\nmyComponentUpdated.render(); \n// 이는 다음을 출력해야 합니다: Value1: 1, Value2: 2\n```\n\n\n\n여기서 중요한 점은 ExampleHook의 모든 렌더링에서 value1에 대한 useHookPattern이 항상 value2에 대한 useHookPattern보다 먼저 호출된다는 것입니다. 렌더링 간에 이 순서는 React의 훅 동작을 모방하기 위해 일관되어야 합니다.\n따라서 함수 컴포넌트 실행 중에 hookPattern이 호출되는 순서가 중요합니다.\n\n그럼, 이제 작동 방식을 살펴보겠습니다:\n\n먼저, ES6 모듈에 익숙하지 않다면, ES6 import 메커니즘은 가져온 바인딩(상태, 설정자, useHookPattern, resetHookIndex)이 내보낸 값을 실시간 읽기 전용 뷰로 보장합니다. HookPattern.js 모듈에서 이러한 내보낸 값에 대한 변경 사항은 즉시 가져온 모듈에서 볼 수 있습니다.\n\n## 컴포넌트 라이프사이클 시뮬레이션\n\n\n\n각각 ExampleHook이 호출될 때마다 컴포넌트의 \"렌더\"를 시뮬레이션합니다. ExampleHook()를 처음 호출할 때는 hookPattern(initialValue)이 상태 변수들을 초기화하고 만나는 각 상태 변수에 대한 상태와 세터를 설정합니다(states[currentStateIndex]를 설정하고 setters[currentStateIndex]에 세터를 생성함). 따라서 초기에 상태 변수 value1은 0으로 설정되고 상태 변수 value2는 1로 설정됩니다.\n\n처음으로 myComponent.render()를 호출하면, 렌더링됩니다 (여기서 콘솔에 출력됩니다):\n\nValue1: 0, Value2: 1\n\n이후의 ExampleHook() 호출에서는 stateIndex가 ExampleHook()의 시작에서 resetHookIndex()로 재설정되므로, hookPattern() 호출마다 states와 setters에서 동일한 인덱스 위치에 접근됩니다. 이것은 이전에 설정된 상태와 해당 세터들을 초기화 없이 재사용할 수 있도록 해주기 때문에 중요합니다.\n\n\n\n그래서 두 번째로 myComponent.render()를 호출하면 다음과 같이 렌더링됩니다:\n\nValue1: 1, Value2: 2\n\n바로 React에서 동작하는 방식입니다!\n\n# 구현 — 두 번째 패스\n\n\n\n결과적으로, 우리가 고안한 HookPattern의 사용법은 실제 React 컴포넌트에서 쉽게 시연됩니다!\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { useHookPattern, resetHookIndex } from './HookPattern';\n\nfunction ExampleHook() {\n    const [value1, setValue1] = useHookPattern(0); // 우리의 'useState' 훅\n    const [value2, setValue2] = useHookPattern(1);\n    const [trigger, setTrigger] = useState(0);     // React의 useState 훅\n\n    function handleClick() {\n        setValue1(value1 + 1);\n        setValue2(value2 + 2);\n        // 리렌더링 트리거\n        setTrigger(trigger + 1); \n    }\n\n    useEffect(() =\u003e {\n        // 각 렌더링 후 훅 인덱스 재설정\n        resetHookIndex(); \n    });\n\n    return (\n        \u003c\u003e\n            Value1: {value1} Value2: {value2}\n            \u003cbutton onClick={handleClick}\u003e훅 패턴 테스트\u003c/button\u003e\n        \u003c/\u003e\n    );\n}\n\nexport default ExampleHook;\n```\n\n# 마치며\n\nHookPattern.js에 제공된 구현과 해당 패턴을 순수 JavaScript 및 React 컴포넌트에서 사용하는 것은 훅 패턴에 대한 기초적 이해를 제공합니다. 이 연습용 구현은 훅의 본질을 포착하지만 완전한 기능, 최적화, React 컴포넌트 라이프사이클 및 상태 관리 시스템과의 통합 부분은 빠져 있습니다. React의 실제 useState 및 useEffect와 같은 훅 구현은 React 렌더링 라이프사이클의 성능에 최적화되고 더 복잡합니다.\n\n\n\n제가 믿는 바로는 이 탐구가 React 훅의 근본 원리들 중 일부에 대해 명확하게 알려주었고, 현대 웹 개발 세계에서의 학습 또는 가르침에 유익할 것이라고 생각됩니다.","ogImage":{"url":"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png"},"coverImage":"/assets/img/2024-05-12-UnderstandingtheReactHookPatternanditsImplementationinPlainJavaScript_0.png","tag":["Tech"],"readingTime":10},{"title":"React 19 데이터 관리 라이브러리에 미치는 영향","description":"","date":"2024-05-12 22:57","slug":"2024-05-12-React19ImpactonDataManagementLibraries","content":"\n\n![이미지](/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png)\n\nReact 19에서는 데이터 처리 방식에 주로 초점을 맞춘 많은 새로운 기능이 도입되었습니다. 네, 이제 React는 효율적인 데이터 가져오기 및 데이터 변경을 처리하기 위한 많은 훅을 제공합니다. 여기에 모두 빠르게 나열해 보겠습니다.\n\n새로운 훅:\n- 많은 향상된 점:\n\n액션 소개:\n\n\n\nReact에서의 액션은 사용자가 UI와 상호작용한 후 수행하려는 모든 것을 의미합니다.\n예: 버튼을 클릭하는 것이 액션입니다. 양식을 제출하는 것도 액션입니다. 그리고 계속 나열됩니다.\n\n이전에는 useEffect, useState, useMemo과 같은 여러 후크를 결합하여 작업을 수행했습니다.\n\n하지만 이제 React에서 직관적인 API를 도입하여 더 이상 보일러플레이트 코드를 해결하기 위해 사용할 필요가 없습니다.\n\n간단한 예로 사용자 세부정보 저장을 살펴봅시다:\n\n\n\n```js\nfunction UpdateUser() {\n    const [status, setStatus] = useState(\"idle\");\n    const saveUser = (userData) =\u003e {\n        setStatus(\"saving\");\n        service.saveUser(userData)\n        .then(() =\u003e {\n            setStatus(\"idle\");\n            redirect(\"/userdetail\");\n        }).catch(() =\u003e {\n            setStatus(\"error\");\n        })\n    }\n\n   return (\n        \u003c\u003e\n            {status == \"saving\" ? \"저장 중....\" : \"\"}\n            \u003cbutton onClick={() =\u003e saveUser()}\u003e사용자 저장\u003c/button\u003e\n        \u003c/\u003e\n   )\n}\n```\n\nWith action:\n\n```js\nfunction UpdateUser() {\n    const [isPending, startTransition] = useTransition();\n    const [error, setError] = useState();\n    const saveUser = (userData) =\u003e {\n        startTransition(async () =\u003e {\n            await service.saveUser(userData)\n                .then(() =\u003e {\n                   redirect(\"/userdetail\");\n                })\n                .catch(err =\u003e {\n                    setError(err);\n                });\n        });\n    }\n\n   return (\n        \u003c\u003e\n            {isPending ? \"저장 중....\" : \"\"}\n            \u003cbutton onClick={() =\u003e saveUser()}\u003e사용자 저장\u003c/button\u003e\n        \u003c/\u003e\n   )\n}\n```\n\n\n\n동작을 래핑함으로써 React는 두 가지 훅을 도입했습니다: useActionState, useOptimistic.\n\nuseActionState 훅:\n\n이 훅은 데이터 변경 상태를 처리하는 데 사용됩니다. 예를 들어, 서버로 데이터를 보내는 경우 등에 활용됩니다. 예를 들어, 프로필 정보를 업데이트하는 간단한 예시가 여기 있습니다.\n\n```js\nimport { useActionState } from 'react';\n\nexport function MemberForm() {\n  const [error, submitAction, isPending] = useActionState(\n    async (previewState, formData) =\u003e {\n      const error = await updateUser(formData).catch(\n          (err) =\u003e 'Error ' + previewState\n      );\n      if(!error) {\n        redirect(\"/memberdetail\");\n        return null;\n      }\n      return error;\n    }\n  );\n\n  return (\n    \u003cform id=\"memberForm\" name=\"memberForm\" action={submitAction}\u003e\n      {isPending \u0026\u0026 \u003cp\u003e업데이트 중...\u003c/p\u003e}\n      \u003cfieldset\u003e\n        \u003clabel htmlFor=\"firstName\"\u003e이름\u003c/label\u003e\n        \u003cinput id=\"firstName\" name=\"FirstName\" type=\"text\" /\u003e\n      \u003c/fieldset\u003e\n      \u003cfieldset\u003e\n        \u003clabel htmlFor=\"lastName\"\u003e성\u003c/label\u003e\n        \u003cinput id=\"lastName\" name=\"LastName\" type=\"text\" /\u003e\n      \u003c/fieldset\u003e\n      \u003c!-- 구현 아래에 --\u003e\n      \u003cPhoneNumber /\u003e\n      \u003cbutton type=\"submit\"\u003e저장\u003c/button\u003e\n      {error \u0026\u0026 \u003cp\u003e{error} \u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n\n\nuseActionState()에 제공된 action 함수는 수행된 작업에 대해 null 또는 오류를 반환해야하고, 폼은 자동으로 재설정됩니다. previewState는 우리가 action에서 반환한 것과 같아집니다.\n\nuseFormStatus 훅:\n\n이 훅을 사용하면 폼 컴포넌트 내에서 폼 제출 상태를 알 수 있습니다.\n\n```js\nfunction PhoneNumber() {\n  const { pending } = useFormStatus();\n  return (\n     \u003cfieldset disabled={pending}\u003e\n       \u003clabel htmlFor=\"Phone\"\u003e전화번호\u003c/label\u003e\n       \u003cinput id=\"Phone\" name=\"Phone\" type=\"number\" /\u003e\n     \u003c/fieldset\u003e\n  )\n}\n```\n\n\n\n`useOptimistic()` 훅:\n\n이 훅은 서버로부터 응답을 기다리는 동안 UI에 낙관적인 업데이트를 수행하는 데 사용됩니다. 예: 좋아요 버튼을 클릭할 때, 우리는 서버가 성공 상태로 응답할 때까지 좋아요 반응을 표시하기를 기다리고 싶지 않습니다. 우리는 즉시 반응을 보여줄 수 있고, 서버에서 응답이 왔을 때, 그것을 로컬 상태에 동기화할 것입니다. 이것이 낙관적인 업데이트라고 불리는 것입니다.\n\n이를 위해 이전에는 API의 상태를 추적하고, API가 실패한 경우 이전 값으로 수동으로 전환해야 했습니다. 이 훅을 사용하면 코드가 더 간단해집니다. 여기 좋아요 버튼의 간단한 예시가 있습니다.\n\n```js\nimport React from 'react';\n\nfunction LikeButton({ count, onClick }) {\n  // 좋아요 카운트에 대한 낙관적 상태 생성.\n  const [optimisticCount, setOptimisticCount] = React.useOptimistic(\n    count,\n    (state, newValue) =\u003e {\n      // 여기서 우리는 즉시 상태를 계산합니다.\n      // 이 상태 함수의 반환 값은 즉시 optimisticCount에 설정될 것입니다.\n      console.log('낙관적 콜백 호출', state, newValue);\n      return newValue;\n    }\n  );\n\n  // 좋아요 상태 업데이트를 위한 전환 생성\n  // setOptimisticCount 메서드는 Action 내에서만 호출할 수 있기 때문에\n  // Action은 startTransition() 메서드 내부의 간단한 비동기 함수입니다.\n  const [isPending, startTransition] = React.useTransition();\n\n  const updateCount = () =\u003e {\n    startTransition(async () =\u003e {\n      // 즉시 카운트 증가\n      setOptimisticCount(optimisticCount + 1);\n      // 값이 부모 구성 요소에 저장될 때까지 대기\n      await onClick(optimisticCount).catch((err) =\u003e console.log(err));\n      // 반환될 때까지 이 전환은 보류 상태에 있을 것입니다.\n      return null;\n    });\n  };\n\n  return (\n    \u003cp\u003e\n      \u003cspan\u003e\n        {optimisticCount} {count !== optimisticCount ? '업데이트 중...' : ''}\n      \u003c/span\u003e\n      \u003cbutton onClick={updateCount}\u003e좋아요\u003c/button\u003e\n    \u003c/p\u003e\n  );\n}\n\nexport function ReactionComponent() {\n  const [count, setCount] = React.useState(0);\n  const onClick = () =\u003e {\n    return new Promise((resolve, reject) =\u003e {\n      // 지연을 모방\n      setTimeout(() =\u003e {\n        setCount(count + 1);\n        reject();\n      }, 2000);\n    });\n  };\n  return \u003cLikeButton count={count} onClick={onClick} /\u003e;\n}\n```\n\n\n\nAPI를 사용하실 건가요?\n\n컴포넌트 내에서 리소스를 소비하는 데 사용됩니다. 이 리소스는 다음과 같을 수 있어요:\n\n- React Context: 여기에는 사용자 세션을 유지하기 위한 간단한 유틸리티 컴포넌트와 훅이 있습니다.\n\n```js\n import React from 'react';\n\n const UserContext = React.createContext();\n\n export function UserSession({ children }) {\n   const user = React.useMemo(() =\u003e ({ id: '001', name: 'user' }), []);\n   return \u003cUserContext.Provider value={user}\u003e{children}\u003c/UserContext.Provider\u003e;\n }\n\n export function useUser() {\n   return React.use(UserContext);\n }\n```\n\n\n\n2. Promises: 이 기능을 사용하면 구성 요소 내에서 데이터를 직접로드 할 수 있습니다. 추가적인 보일러플레이트 코드가 필요하지 않습니다. 이 기능을 사용하기 전에 어떻게 했었는지 간단한 예시를 살펴보겠습니다.\n\n이전:\n\n```js\r\n //Before\n function UserDetailComponent({ userId }) {\n     const [user, setUser] = useState(null);\n     useEffect(() =\u003e {\n         fetchUser(userId)\n             .then(setUser);\n     }, [userId]);\n }\r\n```\n\n이후: 약속을 구성 요소에 직접 전달하고 사용할 수 있습니다. 'use'를 사용하여 소비합니다.\n\n\n\n```js\n// 이후\nfunction UserDetailComponent({ userPromise }) {\n    const user = use(userPromise);\n}\n\nfunction UserProfileComponent({ userId }) {\n    // 이는 매 렌더링마다 새 promise를 만들지 않았는지 확인하기 위한 것입니다.\n    // 일반적으로 데이터를 가져오는 라이브러리를 사용하여\n    // 리렌더링 간에 동일한 promise를 반환합니다.\n    const userPromise = useMemo(() =\u003e {\n        return fetchUser(userId);\n    }, [userId]);\n\n    return (\n        \u003cReact.Suspense fallback={\"로딩 중...\"}\u003e\n            \u003cUserDetailComponent userPromise={userPromise} /\u003e\n        \u003c/React.Suspense\u003e\n    );\n}\n```\n\n개선 사항:\n\n- 컴포넌트 속성으로 ref 사용:\n\n이후에는 새 인자로 선언하는 대신 컴포넌트 속성에서 ref를 가져올 수 있습니다.\n```\n\n\n\n```js\n// 이전\nexport React.forwardRef(function UserDetails(props, ref) =\u003e {\n});\n\n// 이후\nexport function UserDetails({ user, ref }) {\n   useImperativeHandle(ref, function () {\n    return {};\n   });\n}\n\n//...\n\u003cUserDetails ref={ref}/\u003e\r\n```\n\n2. ref 콜백이 정리 함수를 반환합니다:\n\n이 향상으로 불필요한 보일러플레이트 코드를 제거할 수 있습니다\n\n```js\n// 이전\nfunction ProfileDetail() {\n    const ref = React.createRef();\n\n    useEffect(() =\u003e {\n     const listener = () =\u003e {};\n     ref.current.addEventListener(\"keydown\", listener);\n     return () =\u003e ref.current.removeEventListener(\"keydown\");\n    }, []);\n\n    return (\n        \u003cinput ref={ref}/\u003e\n    )\n}\n\n// 이후\nfunction ProfileDetail() {\n    function inputRef(ref) {\n       const listener = () =\u003e {};\n       ref.current.addEventListener(\"keydown\", listener);\n       return () =\u003e ref.current.removeEventListener(\"keydown\");\n    }\n\n    return (\n        \u003cinput ref={inputRef}/\u003e\n    )\n}\r\n```\n\n\n\n3. 컴포넌트에서의 메타 태그 지원:\n\n이제 클라이언트 컴포넌트 내에서 사용자가 있는 위치에 따라 문서 제목을 변경할 수 있습니다.\n\n```js\n\u003cRouter\u003e\n    \u003cRoute path=\"/dashboard\" element={Dashboard} /\u003e\n    \u003cRoute path=\"/profile\" element={Profile} /\u003e\n\u003c/Router\u003e\n\nfunction Dashboard() {\n    return (\n        \u003ctitle\u003e판매 대시보드\u003c/title\u003e\n    )\n}\n\nfunction Profile() {\n    return (\n        \u003ctitle\u003e존의 프로필\u003c/title\u003e\n    )\n}\n```\n\n# 정말 신경 써야 할까요:\n\n\n\n새로운 기능들과 개선사항을 고려할 때, React Query, SWR과 같은 데이터 관리 라이브러리를 사용하는 사용자라면 React에서 기본적으로 제공하는 이러한 새로운 데이터 관리 옵션에 대해 신경써야 할까요?\n\n내 의견으로는, 이것들은 모두 낮은 수준의 훅들로, 라이브러리 작성자가 코드베이스 내에서 보일러플레이트 코드를 제거하는 데 사용할 수 있습니다. 이미 상기한 데이터 관리 라이브러리를 통해 컴포넌트 수준에서 데이터를 가져오고, 로컬 캐싱과 유효한 무효화와 같은 기능을 활용하고 있기 때문에요.\n\nref, use(Context), 메타 태그와 같은 개선 사항을 활용하여 보일러플레이트 코드를 제거하고 코드베이스를 더 깔끔하게 만들 수 있습니다.\n\n데이터 관리를 위해 네이티브 폼 요소로 전환하는 주요 목적은 점진적인 향상을 선택하는 것입니다. 이 관점에서 코드베이스를 점진적으로 변경하여 앱이 최소한의 JavaScript로 작동하도록 할 수 있습니다.\n\n\n\n여기 샘플 놀이터가 있습니다.\n\n원본 게시물: 2024년 5월 9일, https://yab.hashnode.dev에서 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png"},"coverImage":"/assets/img/2024-05-12-React19ImpactonDataManagementLibraries_0.png","tag":["Tech"],"readingTime":9},{"title":"Type Guards in TypeScript 코드 버그를 방지하는 방법","description":"","date":"2024-05-12 22:56","slug":"2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png\" /\u003e\n\n타입 가드(Type Guard)는 TypeScript에서 변수의 타입을 특정 코드 블록 내에서 좁힐 수 있는 메커니즘입니다. 이것은 TypeScript 컴파일러에 변수의 타입에 대한 추가 정보를 제공하여 런타임에서 변수의 타입을 더 정확하게 추론하고 TypeScript 코드의 타입 안전성을 향상시킵니다. 이를 통해 변수가 숫자, 문자열 또는 특정 속성을 가진 객체와 같은 어떤 종류의 데이터를 보유할 수 있는지 정의할 수 있습니다.\n\n하지만 변수가 여러 가지 유형을 동시에 가질 수 있는 경우는 어떻게 될까요? 이것이 타입 가드가 유용해지는 시점입니다. 이것들은 변수의 정확한 유형을 그 자리에서 찾아내도록 도와주는 탐정 도구와 같은 것입니다.\n\n타입 가드가 왜 중요한가요?\n\n\n\n`userInfo`라는 변수가 있고 이 변수에는 string(사용자 이름) 또는 더 많은 세부 정보(이름, 이메일)를 가진 객체가 포함될 수 있다고 가정해 봅시다. 타입 가드가 없는 경우 TypeScript는 객체에만 존재할 수 있는 특정 속성에 액세스할 수 없도록 오동작 할 수 있습니다.\n\n타입 가드는 `userInfo`의 타입을 런타임에서 확인하여 상황을 명확하게 해줍니다. 이렇게 하면 코드가 더:\n\n1. 신뢰할 수 있게 됩니다: 타입을 확인하여 `userInfo`를 정확히 사용하는 방법을 알 수 있습니다.\n\n2. 가독성이 좋아집니다: 코드가 당신과 다른 사람들에게 이해하기 쉬워집니다.\n\n\n\n3. 버그 없음: 초기에 형 불일치를 잡아 내어 프로그램을 충돌시킬 수있는 오류를 피할 수 있습니다.\n\n타입 가드의 종류: 탐정 키트\n\n타입 가드를 사용하는 다양한 방법이 있으며 각각의 장점이 있습니다:\n\n- in 연산자: 이 연산자는 객체에 특정 속성이 있는지 확인합니다. 특정 속성이 있는지 확인하는 데 도움이 됩니다.\n\n\n\n```typescript\nlet userInfo: string | { name: string, email: string };\nif (typeof userInfo === \"object\" \u0026\u0026 \"email\" in userInfo) {\nconsole.log(userInfo.email);\n}\n```\n\n- 타입 캐스팅: 타입 캐스팅 또는 타입 어서션이라고도 불립니다. TypeScript 컴파일러에 특정 타입으로 값을 취급하도록 지시하는 방법입니다. TypeScript에게 \"너보다 더 잘 안다고; 이 경우 값이 특정 타입임을 믿어줘\"라고 말하는 것과 같습니다.\n\n```typescript\nlet userInfo = (user as { name: string }).name;\nconsole.log(userInfo);\n```\n\n- 커스텀 타입 가드: 특정 조건을 확인하는 함수들입니다.\n\n\n\n```js\nfunction isUserObject(user: any): user is { name: string } {\nreturn typeof user === \"object\" \u0026\u0026 \"name\" in user;\n}\nif (isUserObject(userInfo)) {\nconsole.log(userInfo.name);\n}\n```\n\n사용 사례: 케이스를 풀어라:\n\n타입 가드는 다양한 상황에서 매우 유용합니다:\n\n- 사용자 입력 처리: 예상 형식에 맞는지 확인하기 위해 양식 데이터를 유효성 검사합니다 (숫자는 숫자 위치에, 텍스트는 텍스트 위치에).\n- 외부 데이터 처리: API나 파일에서 가져온 데이터가 항상 완벽하게 구조화되어 있지 않을 수 있습니다. 타입 가드는 형식을 식별하고 그에 맞게 처리할 수 있도록 도와줍니다.\n- 유연한 함수 작성: 타입 가드를 어댑터처럼 작용하여 다양한 유형의 데이터를 처리할 수 있는 함수를 작성합니다.\n\n\n\n유형 가드는 TypeScript의 유니언 유형이나 복잡한 데이터 구조와 같이 TypeScript의 유형 추론 능력이 제한되는 시나리오에서 특히 유용합니다. 이들은 TypeScript가 변수의 특정 유형을 이해하도록 도와 안정적이고 오류가 적은 코드를 작성하기 쉽게 만듭니다.\n\n유형 가드는 TypeScript 프로그래밍에서 핵심적인 역할을 하며, 개발자가 작업 중인 변수의 유형에 대해 정보를 얻고 안전하고 유지보수가 용이한 코드베이스를 작성할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png"},"coverImage":"/assets/img/2024-05-12-TypeGuardsinTypeScriptKeepingTheCodeBugFree_0.png","tag":["Tech"],"readingTime":3},{"title":" Jest 테스트를 최대 10배 빠르게 만들기 ","description":"","date":"2024-05-12 22:55","slug":"2024-05-12-MakeyourJestTestsupto10xFaster","content":"\n\n\n![이미지](/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png)\n\n중규모 리액트 프로젝트의 단위 테스트를 기다리는 데 30분이나 걸리는 것은 짜증납니다. 속도에 집중하기 위해 이를 개선하기 위한 몇 가지 조치를 취하기로 결정했습니다.\n\n우리가 모두 하는 대로, 우리는 구글에서 jest 성능을 향상시키기 위한 다양한 방법을 찾기 시작했습니다. 이 기사에는 우리가 가진 모든 관측치와 결과가 나열되어 있습니다. 이는 여러분의 구성에서 작동할 수도 있고, 그렇지 않을 수도 있습니다. 하지만, 이 기사를 살펴보고 각 방법을 시도하여 차이가 있는지 확인하는 것을 권장합니다.\n\n모든 최적화의 황금 규칙은 측정하는 것입니다. 네, 현재 상황을 측정해야 합니다. 우리가 추적해야 하는 모든 측정 항목이 여기에 나열되어 있습니다.\n\n- 전체 test suite 실행 시간.\n- 시간과 함께 상위 10개 느린 suite.\n- 전체 사용된 메모리.\n\n# # 1 Tests 내부에서 네트워크 호출하기\n\n테스트가 느린 이유를 찾아보던 중 팀에서 받은 관찰 중 하나는 테스트가 불안정하며, 반응 컴포넌트 내부에서 API 호출을 하고 있을 수 있다는 것이었습니다. 이에 호기심을 느끼기 시작했고, 이는 사실이었습니다. 테스트 케이스가 API 호출을 하고 응답을 기다리고 있어서 테스트가 느린 이유 중 하나였습니다.\n\n최상의 단위 테스트는 테스트를 실행할 때마다 항상 동일한 결과를 제공하는 테스트입니다. 네트워크에 의존하면 이를 달성하는 것이 불가능합니다.\n\n\n\n다음 단계는 이러한 문제를 피하는 방법을 찾는 것이었고, 그때 jest-offline을 발견했습니다. 이를 구현하기 시작했지만, 다음 문제는 많은 테스트 케이스가 API 호출을 하고 있었기 때문에 이를 모두 식별하고 호출을 모킹해야 했었습니다. 이 작업은 시간이 걸렸지만 노력할 가치가 있었습니다.\n\n지금은 jest-offline이 이 규칙을 강제하기 때문에, 우리가 호출을 모킹하지 않는다면 테스트가 직접 실패합니다.\n\n# #2 네트워크 호출 이상 외에도 더 많은 문제가 있을 수 있습니다.\n\n네트워크 호출이 하나의 문제일 수 있다는 것을 발견한 후, 다음은 비슷한 문제를 찾고 있었던 것입니다. 우리는 운좋게도 더 개선된 테스트 실행 시간의 문제를 하나 더 발견했습니다.\n\n\n\n단위 테스트는 독립적이고 정확해야 합니다. 그러나 우리는 테스트 케이스를 Redux Provider로 감싸고 있었는데, 이는 redux-persist의 persistReducer로 구성되어 있었습니다. Redux persist의 주요 목적은 서로 다른 탭 및 세션 간에 데이터를 유지하는 것이었지만 UT(단위 테스트)의 경우 이것은 정반대였습니다. 그래서 이를 제거하여 모든 테스트에서 IO 작업을 하나 줄였고, 많은 시간을 절약할 수 있었습니다.\n\n주목해야 할 사항\n\n- LocalStorage와 같은 불필요한 IO 작업 정리\n- 테스트 케이스에서 unMocked 타이머\n- 컴포넌트에 대한 불필요한 래퍼\n- Sentry 래퍼 → UT에 필요하지 않음\n- 분석 래퍼 → UT에 필요하지 않음\n\n# #3 최적 성능을 얻기 위해 MaxWorkers=50% 사용하기\n\n\n\n아래 언급된 기사에서 영감을 받아, 더 많은 내용을 읽을 수 있습니다.\n\nhttps://dev.to/vantanev/make-your-jest-tests-up-to-20-faster-by-changing-a-single-setting-i36\n\n## #4 yarn + Node V16 + Jest 28로 전환\n\nJest는 많은 성능 향상을 이루었습니다. 그래서 우리는 28로 업그레이드했고, NodeJS도 마찬가지입니다. 이 변경으로 성능이 크게 향상되었습니다.\n\n\n\n# #4 가장 느린 테스트 케이스 개선하기\n\n모든 최적화의 첫 단계는 무엇이 잘못되었는지를 파악하는 것이기 때문에, 가장 느린 테스트를 식별하는 것도 중요합니다. 아마 가장 느린 열 개의 테스트가 실행 시간의 80% 이상을 차지할 수도 있습니다. 누가 알겠어요!\n\njest-slow-test-reporter를 사용하여 가장 느린 테스트를 식별한 다음, 그 성능을 개선하는 작업에 착수하세요. 대부분의 테스트가 100ms 이하인 것이 좋습니다. 가장 느린 테스트도 최대 300ms 정도여야 합니다. 그 이상이면 심각한 문제가 있습니다.\n\n# #5 놀라운 성능 향상을 위해 swc/jest로 전환하기.\n\n\n\nesbuild의 등장으로 프론트엔드 세계는 개발 환경에서 속도에 더 많은 요구를 하게 되었습니다. swc는 러스트로 작성된 초고속 컴파일러입니다. 그렇다면 단위 테스트에도 똑같이 사용해볼까요?\n\n@swc/jest로 전환하면 성능이 즉시 향상된 것을 확인할 수 있습니다. 더 자세한 정보는 https://miyauchi.dev/posts/speeding-up-jest/를 참고해주세요.\n\n## 6. 메모리 누수\n\n느린 및 불안정한 테스트의 또 다른 원인은 메모리 누수입니다. 이 부분은 종종 무시되지만, 메모리 누수를 일으키는 테스트를 식별하는 것이 중요합니다.\n\n\n\n더 많은 정보를 얻기 위해 테스트에서 메모리 누수를 식별하는 방법은 다음을 참조할 수 있습니다: [여기](https://chanind.github.io/javascript/2019/10/12/jest-tests-memory-leak.html)\n\n# #6 React 테스팅 라이브러리\n\n성능 문제를 찾아보는 또 다른 장소는 테스트 케이스를 작성하는 방식입니다. 올바른 셀렉터의 사용이 느린 테스트의 주요 원인 중 하나입니다. 몇 가지 문제들은 다음과 같습니다.\n\n- .type을 여기저기 사용하면 안 됩니다. 필요한 곳에서만 사용하고, 그렇지 않으면 대안으로 .paste로 돌아가세요. 훨씬 빠릅니다.\n- React 테스팅 라이브러리를 사용할 때 흔히 발생하는 실수에 대한 자세한 내용은 [여기](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)를 참조할 수 있습니다.\n\n\n\n올바른 선택자와 기능을 사용하면 단위 테스트의 품질과 성능이 향상됩니다.\n\n## 추가 팁\n\n성능을 향상시키기 위해 사용할 수 있는 몇 가지 추가 팁을 아래에 나열했습니다.\n\n`findRelatedTests`\n\n\n\n이 플래그를 사용하면 코드 변경과 관련된 테스트만 실행되므로 테스트 실행 시간이 즉시 줄어듭니다. 따라서 1000개 이상의 테스트를 실행하는 대신 이제 변경한 20개 파일에 대해 20개의 테스트 케이스만 실행할 수 있습니다.\n\n또한 `--changedSince`을 사용하여 지정된 브랜치나 커밋 해시 이후의 변경 사항에 관련된 테스트를 실행할 수도 있습니다.\n\n```js\njest --changedSince \u003ccommit-id\u003e\n```\n\nJSDOM 변경\n\n\n\n테스트 환경을 jsdom에서 LinkeDOM과 같은 것으로 변경하면 성능이 최소 2배 향상될 것입니다. 그러나 이것은 전문적으로 사용해 보지 않았기 때문에 권장하지는 않습니다. 권장할만한데요, 한 번 시도해보고 구성과 어떻게 작동하는지 확인해보세요.\n\n# 영향\n\n- 개발자들이 PR에서 빌드 확인을 보기 위해 기다려야 했던 시간의 일부만 기다리면 되기 때문에, 개발자 생산성 및 시간 관리가 개선됩니다.\n- CI의 부하가 현저히 줄어들어 더 많은 비용 절감이 이루어집니다.\n\n이러한 단계들이 순위 테스트 실행에 소요되는 시간을 크게 줄이는 데 도움이 될 것을 기대합니다. 이러한 팁으로 큰 변화를 이루실 수 있었는지, 이에 관한 성과를 남겨주세요.\n\n\n\n이 글은 원래 https://kirananto.com/make-your-jest-test-upto-10x-faster/ 에 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png"},"coverImage":"/assets/img/2024-05-12-MakeyourJestTestsupto10xFaster_0.png","tag":["Tech"],"readingTime":4}],"page":"53","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"53"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>