<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/110" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/110" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Vue 3  동적 컴포넌트" href="/post/2024-05-14-Vue3DynamicComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue 3  동적 컴포넌트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Vue3DynamicComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue 3  동적 컴포넌트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue 3  동적 컴포넌트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년을 향한 새로운 JavaScript 7 기능" href="/post/2024-05-14-7NEWJavaScript2024Features"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년을 향한 새로운 JavaScript 7 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년을 향한 새로운 JavaScript 7 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년을 향한 새로운 JavaScript 7 기능</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WASM을 전혀 잘못 이해하고 있었어요 " href="/post/2024-05-14-IwasunderstandingWASMallwrong"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WASM을 전혀 잘못 이해하고 있었어요 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WASM을 전혀 잘못 이해하고 있었어요 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">WASM을 전혀 잘못 이해하고 있었어요 </strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" href="/post/2024-05-14-FrontendWeeklyDigest362612May2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" href="/post/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" href="/post/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트의 비밀 병기를 발휘하라 StrictMode" href="/post/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트의 비밀 병기를 발휘하라 StrictMode" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트의 비밀 병기를 발휘하라 StrictMode</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴포넌트 라이프사이클 메서드" href="/post/2024-05-14-ReactComponentLifecycleMethods"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴포넌트 라이프사이클 메서드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴포넌트 라이프사이클 메서드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="갇혀 있는 극악무도한 보안의 심연으로부터" href="/post/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="갇혀 있는 극악무도한 보안의 심연으로부터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">갇혀 있는 극악무도한 보안의 심연으로부터</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Js 설치 방법 완전 초보자용" href="/post/2024-05-14-HowToInstallReactJsForcompletebeginners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Js 설치 방법 완전 초보자용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Js 설치 방법 완전 초보자용</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link posts_-active__YVJEi" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Vue 3  동적 컴포넌트","description":"","date":"2024-05-14 12:29","slug":"2024-05-14-Vue3DynamicComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3DynamicComponents_0.png\" /\u003e\n\n블로그 포스트 목록이 있다고 상상해봅시다 (여기 예시를 사용하고 있어요). 대부분의 경우, 모든 포스트가 너무 비슷해서 우리는 하나의 컴포넌트를 추출하고 재사용하고 싶을 것입니다. 이를 blogPost.vue라고 부를게요. 이런 경우에는 제목, 부제목 및 이미지를 표시하고 싶을 때 사용할 수 있어요.\n\n이제 블로그 포스트가 다른 특성을 가지고 있다고 상상해보세요. 어떤 포스트는 이미지 대신 상호작용이 필요한 인포그래픽을 가지고 있을 수도 있고, 어떤 것은 그저 다른 디자인이 필요할 수도 있어요. 이 문제를 해결하는 한 가지 방법은 blogPost.vue 컴포넌트 내부에 많은 if (조건부) 렌더링을 만드는 것이 있습니다. 다른 방법은 동적 컴포넌트를 사용하는 것이죠!!\n\n## 예제\n\n\n\n위에서 시작한 프로젝트를 확장해 나가려고 합니다. 이것은 Medium에서 가져온 블로그 포스트 목록입니다. 현재 이들은 모두 같은 디자인을 가지고 있지만, 동적 컴포넌트를 사용하여 컴포넌트를 깨끗하게 유지하면서 세 가지 다른 디자인을 만들 것입니다.\n\n기본적인 blogPost.vue 컴포넌트는 다음과 같이 보입니다:\n\n```js\n\u003cscript setup\u003e\nconst props = defineProps(['post'])\nconst openPostWindow = (url) =\u003e {\n  window.open(url, '_blank')\n}\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"card\" @click=\"openPostWindow(post.mediumUrl)\"\u003e\n    \u003cdiv class=\"card__header\"\u003e\n      \u003cimg :src=\"`https://miro.medium.com/v2/resize:fill:500:200/${post.previewImage.id}`\" alt=\"Post Image\" class=\"post-image\" /\u003e\n\n    \u003c/div\u003e\n    \u003cdiv class=\"card__body\"\u003e\n      \u003ch4\u003e\n        { post.title }\n      \u003c/h4\u003e\n      \u003cp\u003e\n        { post.extendedPreviewContent.subtitle }\n      \u003c/p\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"card__footer\"\u003e\n      \u003cdiv class=\"user\"\u003e\n        \u003cdiv class=\"user__info\"\u003e\n          \u003csmall\u003e\n            { Math.ceil(post.readingTime) } 분\n          \u003c/small\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cstyle scoped\u003e\n /* 스타일은 실제 저장소에 있습니다 */\n\u003c/style\u003e\n```\n\n\n\n```javascript\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\n\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\n\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"MediumPreview\" :post=\"post\" v-for=\"post in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n지금까지 잘 진행되고 있어요! 이제 우리는 동적 접근 방식을 사용하고 있습니다. component 키워드를 사용하여 Vue에게 MediumPreview.vue 컴포넌트를 사용하도록 하고 있어요. 결과는 이렇게 나와요:\n\n![2024-05-14-Vue3DynamicComponents_1](/assets/img/2024-05-14-Vue3DynamicComponents_1.png)\n\n\n\n\n## 동적이 멋있어지는 때\n\n지금까지 우리는 동적 접근 방식만 사용하여 동일한 컴포넌트를 표시했습니다. 이것은 좋은 시작점이지만, 동적 컴포넌트의 진정한 힘을 활용하지 못합니다. 그것은 여러 컴포넌트를 사용할 때에만 얻을 수 있습니다. 그래서 포스트용으로 또 다른 디자인을 추가해 볼까요?\n저는 단순히 MediumPreview2.vue로 불리는 다른 컴포넌트를 만들었습니다. 보기에는 비슷해 보이지만, 이 예제에서는 중요하지 않습니다. 각 컴포넌트가 코드를 더 깨끗하게 만드는 충분히 다른 컴포넌트임을 상상해 봅시다.\n\n이제 부모 컴포넌트는 이렇게 생겼습니다.\n\n```js\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\n\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\nimport MediumPreview2 from './blogDesigns/MediumPreview2.vue'\n\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"index % 2 === 0 ? MediumPreview : MediumPreview2\" :post=\"post\" v-for=\"(post, index) in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n\n\n결과는 아래와 같습니다:\n\n![Vue3 Dynamic Components](/assets/img/2024-05-14-Vue3DynamicComponents_2.png)\n\n## 최종 목표\n\n동적 컴포넌트의 일반적인 사용 사례는 사용자가 어떤 종류의 뷰/디자인을 사용하고 싶은지 선택할 수 있는 탭일 수도 있습니다. 따라서 사용자가 보여져야 하는 디자인의 종류를 선택할 수 있는 탭을 포함한 예제를 확장할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3DynamicComponents_3.png\" /\u003e\n\nPinia store를 사용하여 쉽게 이루어집니다. 어떤 디자인을 보여줄지의 값을 저장하기 위한 Pinia store를 사용합니다 →\n\n```js\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\nimport { useTabStore } from './../stores/tab'\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\nimport MediumPreview2 from './blogDesigns/MediumPreview2.vue'\n\nconst componentMap = { MediumPreview, MediumPreview2 }\nconst tabStore = useTabStore()\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"componentMap[tabStore.tab]\" :post=\"post\" v-for=\"(post, index) in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\r\n```\n\n## 결론\n\n\n\n동적 구성 요소를 설정하는 것은 코드베이스를 간단하게 유지하고 분할하는 효과적인 방법일 수 있어요. 새로운 디자인을 추가하는 것은 완전히 별도의 파일에서 할 수 있어서 현재 구성 요소에 오류와 버그를 도입할 가능성이 줄어들어요.\n\n여기서 전체 예제 repo를 확인하세요\n\n여기서 데모 사이트를 확인하세요\n\n아래 내용도 참고해보세요:\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-Vue3DynamicComponents_0.png"},"coverImage":"/assets/img/2024-05-14-Vue3DynamicComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년을 향한 새로운 JavaScript 7 기능","description":"","date":"2024-05-14 12:27","slug":"2024-05-14-7NEWJavaScript2024Features","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png\" /\u003e\n\n2024년 JavaScript 업데이트는 7가지 주요 기능을 소개합니다.\n\n텍스트와 날짜를 간편하게 처리하는 방법부터 프로그램이 함께 기다리고 작동하는 새로운 방법, 그리고 패턴을 더 쉽게 찾을 수 있도록 도와주는 기능까지 있습니다.\n\n뉴스를 확인해보세요!\n\n\n\n# 잘 형성된 유니코드 문자열\n\n잘 형성된 유니코드 문자열은 JavaScript에서 UTF-16 인코딩으로 올바르게 형식화된 문자열을 보장하는 방법을 소개합니다.\n\n이 기능은 JavaScript가 유니코드를 다루는 방식을 개선하여, 문자열 내의 부적절하게 쌍을 이룬 서로 대용 코드 포인트를 감지하고 수정함으로써 다른 언어 및 문자와 작업하기 쉬워지도록 목표로 합니다.\n\n## 사용법 실습\n\n\n\n사용자가 생성한 다양한 언어와 기호를 포함할 수 있는 콘텐츠로 작업 중이라고 상상해보세요.\n\n이 콘텐츠가 올바르게 인코딩되어 있는지 확인하는 것은 오류 없이 처리하고 표시하는 데 중요합니다.\n\n- 올바르게 형식이 지정된 유니코드 문자열을 확인하세요: String.prototype.toWellFormed을 사용하여 문자열이 올바르게 인코딩되어 있는지 확인하고 혼자 있는 서로게이트가 있는지 확인합니다.\n\n```js\nconst exampleString = \"Example with Unicode 🌈\";\nconsole.log(exampleString.isWellFormed()); // 혼자 있는 서로게이트가 없으면 True\n```\n\n\n\n- Unicode 문자열을 잘 구성된 문자열로 변환하십시오: String.prototype.toWellFormed를 사용하여 불완전한 서로게이트가 포함된 문자열을 Unicode 대체 문자(U+FFFD)로 대체하여 잘 구성된 문자열로 변환하십시오.\n\n```js\nconst malformedString = \"Example with a lone surrogate \\uD800\";\nconsole.log(malformedString.toWellFormed()); // \"\\uD800\" 대신 U+FFFD로 대체됩니다\n```\n\n이 기능은 국제화 또는 이모지를 다룰 때 특히 유용하며, 다양한 플랫폼 및 환경에서 문자열을 더 신뢰성 있게 처리할 수 있도록 합니다.\n\n이는 웹 애플리케이션에서 흔한 버그 원인을 다루며, JavaScript가 글로벌 콘텐츠를 처리하는 데 더 강력하도록 만듭니다.\n\n\n\n# Atomic waitSync\n\nAtomic waitSync는 기존 Atomics API를 보완하는 동기화 기본 요소입니다.\n\n이를 통해 메인 스레드와 워커 간의 더 나은 조정을 가능하게 하는 공유 메모리 위치에서 동기화 대기가 가능하며, 이는 복잡한, 멀티 스레드 웹 애플리케이션에서 중요합니다.\n\n## 동기화 예제\n\n\n\n웹 어플리케이션에서 웹 워커에서 중달처리나 실시간 데이터 처리를 수행하는 경우,\n\n주요 스레드와 워커 스레드를 효율적으로 조정하는 것이 성능과 데이터 무결성을 유지하는 데 중요합니다.\n\n```js\n// 공유 Int32Array 버퍼를 가정\nconst sharedBuffer = new SharedArrayBuffer(1024);\nconst intArray = new Int32Array(sharedBuffer);\n\n// 주요 스레드가 값을 설정함\nAtomics.store(intArray, 0, 123);\n\n// 워커 스레드가 값이 변경될 때까지 동기적으로 대기함\nAtomics.waitSync(intArray, 0, 123);\n\n// 워커에서 일부 작업을 수행한 후\nAtomics.store(intArray, 0, 456); // 공유 메모리 값 변경\n\n// 주요 스레드는 이 변경을 통지받거나 이에 대해 조치를 취할 수 있음\n```\n\n원자적인 waitSync는 복잡하고 오류를 유발할 수 있는 메시징이나 폴링 메커니즘을 사용하지 않고 주요 스레드와 웹 워커 간 작업을 동기화하는 더 직관적인 방법을 제공하여 JavaScript의 동시성 모델을 향상시킵니다.\n\n\n\n병렬 처리를 필요로 하는 응용 프로그램의 성능과 신뢰성을 크게 향상시킬 수 있습니다.\n\n# RegExp v Flag with Set Notation + Properties of Strings\n\n정규 표현식(RegEx)에서 문자열의 속성과 집합 표기법과 함께 v 플래그를 도입하는 것은 JavaScript의 패턴 매칭 능력을 상당히 향상시킨 것을 의미합니다.\n\n이 기능은 RegEx의 표현력과 강력한 구문을 더욱 간단하게 만들어주며, 복잡한 패턴을 기반으로 텍스트를 매칭하고 교체하는 프로세스를 단순화합니다. 이는 특히 국제화 및 다국어 콘텐츠를 다루는 작업에 매우 유용합니다.\n\n\n\n## 고급 검색\n\nv 플래그와 집합 표기법 및 문자열 속성을 결합하면 Unicode 속성에 의해 정의된 특정 문자 집합과 일치시킬 수 있는 정규 표현식을 만들 수 있습니다.\n\n이 개선은 특히 다양한 문자 집합과 다국어 지원이 필요한 응용 프로그램에 유용합니다.\n\n- 화이트스페이스 또는 이모지 일치: v 플래그는 집합 표기법 내에서 Unicode 속성 이스케이프의 사용을 가능하게 하며, 이를 통해 이모지나 화이트스페이스 문자와 같은 광범위한 문자 범주와 정확히 일치시킬 수 있습니다.\n\n\n\n```js\nconst regex = new RegExp(\"[\\\\p{Emoji}\\\\p{White_Space}]\", \"v\");\n```\n\n예시 사용법: 이모지와 공백이 모두 포함된 문자열에 대해 정규식을 테스트하면 이러한 문자 유형을 정확하게 식별하는 능력을 확인할 수 있습니다.\n\n```js\nconst testString = \"Here is an emoji 😊 and some spaces\";\nconsole.log(testString.match(regex)); // 이모지와 공백이 일치할 것으로 예상됩니다\n```\n\n이 RegExp의 개선 사항은 복잡한 문자 집합을 다룰 때 보다 직관적이고 오류 가능성이 낮아져서 다양한 언어와 기호를 수용해야 하는 글로벌 응용 프로그램을 다룰 때 매우 유용합니다.\n\n\n\n# 파이프라인 연산자 (|`)\n\n파이프라인 연산자는 JavaScript에서 연산 순서를 더 가독성 있고 기능적으로 작성할 수 있는 방법을 소개합니다.\n\n이를 통해 개발자들은 중첩된 함수 호출보다 직관적이고 깔끔한 방식으로 함수를 연결할 수 있으며, 데이터 처리나 함수형 프로그래밍 환경에서 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.\n\n## 예제\n\n\n\n여러 번의 변환을 적용해야 하는 상황을 생각해봅시다. 파이프라인 연산자를 사용하면 각 단계가 명확하게 구분되어 코드를 더 쉽게 따를 수 있어요.\n\n```js\n// 파이프라인에 사용될 예시 함수들\nconst double = n =\u003e n * 2;\nconst increment = n =\u003e n + 1;\n\n// 함수들을 적용하기 위해 파이프라인 연산자 사용\nlet result = 5 |\u003e double |\u003e increment;\n\nconsole.log(result); // 결과는 11이 출력됩니다.\n파이프라인 연산자는 JavaScript 내에서 함수형 프로그래밍 스타일로 가는 중요한 한 발걸음을 의미해요.\n```\n\n현대 JavaScript 개발의 가독성과 구성 목표와 잘 맞고, 표현력이 풍부한 구문적 해결책을 제공합니다.\n\n# Temporal API\n\n\n\nTemporal API는 JavaScript에서의 날짜 및 시간 조작의 복잡성과 일관성 부재를 해결합니다.\n\n날짜, 시간, 시간대 및 기간 처리를 다루기 위한 다양한 객체 및 메서드를 제공하여 Temporal API는 시간 관련 데이터 처리를 단순화합니다.\n\n이를 통해 Temporal API는 견고하고 표준화된 솔루션으로 제3 자 라이브러리가 필요한 필요성을 대체하고자 합니다.\n\n## Temporal API 사용 예제\n\n\n\n날짜와 시간을 다루다 보면, 시간대, 일광 절약 시간 변경 및 형식 지정과 관련된 작업을 해야 합니다.\n\nTemporal API를 사용하면 이러한 작업이 더 간단하고 오류가 적은 방식으로 처리됩니다.\n\n```js\n// 특정 시간대에서 날짜-시간 객체 생성\nconst meetingDate = Temporal.PlainDateTime.from(\"2024-03-25T15:00:00\");\nconst zonedDate = meetingDate.withTimeZone(\"America/New_York\");\n\nconsole.log(zonedDate.toString()); // \"2024-03-25T15:00:00-04:00[America/New_York]\"\n\n// 두 날짜 간의 차이 계산\nconst startDate = Temporal.PlainDate.from(\"2024-01-01\");\nconst endDate = Temporal.PlainDate.from(\"2024-03-01\");\nconst difference = startDate.until(endDate);\n\nconsole.log(difference.toString()); // \"P2M\" (2개월간의 기간)\n```\n\n이 기능은 기존 Date 객체보다 훨씬 직관적이고 강력한 도구 세트를 제공하여 날짜와 시간 조작의 모든 측면에 대해 개발자들에게 큰 개선을 제공합니다.\n\n\n\nJS 애플리케이션에서 시간 데이터를 다룰 때 개발 경험을 크게 향상시킵니다.\n\n# 레코드와 튜플\n\n레코드와 튜플은 JavaScript에서 새롭고 변경할 수 없는 데이터 구조로 제안되어 코드 신뢰성과 간결함을 향상시키려고 합니다.\n\n- 레코드는 한 번 생성되면 변경할 수 없지만 개체와 유사한 변경할 수 없는 키-값 쌍을 만들 수 있습니다.\n- 튜플은 생성 후 변경할 수 없는 배열과 유사한 변경할 수 없는 순서가 지정된 목록입니다.\n\n\n\n이러한 구조들은 데이터가 예기치 않게 변경되지 않도록 보장해주어 함수형 프로그래밍 및 애플리케이션 상태 관리에 특히 유용합니다.\n\n## 예시\n\n레코드와 튜플이 어떻게 적용될 수 있는지 살펴봅시다. 사용자 프로필 관리 시나리오에서 레코드를 사용하여 애플리케이션의 생명주기 내내 데이터 무결성을 유지하는 방법을 알아봅시다.\n\n레코드를 사용하여 변경할 수 없는 사용자 프로필 만들기:\n\n\n\n- 사용자 프로필을 변경할 수 없는 키-값 쌍으로 정의하는 Records를 사용하여 데이터 무결성을 유지합니다. 사용자 프로필을 설정하면 변경할 수 없으므로 데이터의 무결성이 보장됩니다.\n\n```js\nconst userProfile = #{\n  name: \"Jane Doe\",\n  age: 28,\n};\n```\n\nTuples를 사용하여 순서가 있는 데이터를 관리하는 방법:\n\n- Tuples를 구현하여 포인트나 좌표와 같은 데이터 시퀀스를 처리합니다. 한 번 초기화되면 수정 실수의 위험이 사라지고 일정합니다.\n\n\n\n```js\nconst points = #[1, 2, 3];\n```\n\n또한 애플리케이션 실행 중 데이터 상태에 대해 확신을 제공하여 의도치 않은 변이로 인한 버그를 방지합니다.\n\n특히 복잡한 상태 관리가 필요하거나 함수형 프로그래밍 패턴이 적용된 애플리케이션에서 특히 유용합니다.\n\nECMAScript 2024에 예정된 이러한 기능은 그뿐만 아니라 JavaScript를 현대화하고 더 강력하게 만들며 개발자 경험을 개선하는 필수적인 단계입니다.\n\n\n\n데이터 무결성과 코드 가독성을 모두 고려한 레코드와 튜플, 그리고 향상된 패턴 매칭을 통해 ES15은 개발자들이 더 효율적이고 신뢰할 수 있으며 유지보수가 용이한 애플리케이션을 작성할 수 있는 도구를 제공할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png"},"coverImage":"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png","tag":["Tech"],"readingTime":6},{"title":"WASM을 전혀 잘못 이해하고 있었어요 ","description":"","date":"2024-05-14 12:24","slug":"2024-05-14-IwasunderstandingWASMallwrong","content":"\n\n# 요약\n\n- WASM은 프론트엔드와 백엔드 모두에 적합하며 브라우저에서 JavaScript의 실행 속도를 높이는 데 사용됩니다.\n- 백엔드에서의 WASM은 외부 함수 인터페이스(FFI)와는 다르게 작동합니다. WASM은 빠르고 효율적으로 실행되도록 설계되었습니다.\n- WASM의 속도는 저수준 이진 형식, 간단한 메모리 모델 및 미리 컴파일된 특성에서 나옵니다. 이는 오버헤드를 최소화하여 네이티브 코드와 유사한 성능을 제공합니다.\n- 저는 Rust와 WASM을 사용하여 wa-ulid에서 ULID 생성을 최적화했습니다. 그 결과 JavaScript 버전보다 40배 빨랐습니다.\n- 현재 WASM 파일은 JavaScript보다 크기가 크기 때문에 도전적일 수 있습니다. 그러나 WASM 툴체인과 최적화 기술이 개선됨에 따라, WASM은 백엔드 및 프론트엔드 애플리케이션에 더욱 실용적일 것입니다.\n\n# 소개\n\n개발자로서 저는 종종 Gartner Hype Cycle과 유사한 새로운 기술을 탐험하는 단계를 거치곤 합니다. 이 주기는 새로운 기술을 채택하는 일반적인 경로를 보여줍니다. 이 글에서는 WASM을 통해 백엔드 성능을 향상시키는 방법에 대해 의심에서 호기심으로 변화하는 과정을 설명하고 싶습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png)\n\nWASM은 저수준 명령어 형식입니다. 이는 C, C++, Rust와 같은 언어들의 컴파일 대상으로 설계되었습니다. 주요 목표는 고성능 웹 애플리케이션을 가능하게 하는 것입니다. 그러나 성능이 중요한 경우 서버 측에서도 점점 더 사용되고 있습니다.\n\n내 WASM 여행은 좋은 일과 나쁜 일이 있었습니다. 과대 기대로 시작해서 실망으로 끝났지만 확고한 이해와 실용적인 적용으로 마무리되었습니다.\n\n# 초기 오해들\n\n\n\nWASM에 대한 소문을 처음 들었을 때 기대가 컸어요. WASM을 통해 복잡한 계산을 웹 브라우저에 원활하게 통합할 수 있을 것으로 생각했어요. 이것은 FFI가 고수준 언어가 기계 코드를 실행할 수 있도록 하는 방법과 비슷하다고 느꼈어요.\n\n## FFI란 무엇인가요?\n\nFFI는 한 언어의 코드가 다른 언어의 코드를 직접 호출할 수 있게 해줍니다. 성능이 중요하고 로직의 일부가 C 또는 Rust와 같은 저수준 언어로 구현된 경우 사용됩니다. 그 저수준 코드는 그런 후 Python이나 JavaScript와 같은 고수준 언어에서 호출됩니다.\n\n나는 WASM이 FFI와 같은 것으로 여겨, 브라우저에서 기계 수준의 코드를 실행하는 방법일 것이라고 생각했어요. WASM은 고수준 언어를 저수준 바이너리 형식으로 컴파일하기 때문에 이것은 타당했던 것 같아요. 하지만 WASM의 독특한 아키텍처와 제약을 간과하고 있던 거였죠.\n\n\n\n## WASM과 FFI 비교\n\nWASM을 FFI로 보았을 때, WASM이 전통적인 기계 코드와 다른 점을 그리워했어요. FFI에서는 종종 호스트 언어와 외부 함수 간 전환 시 주요 오버헤드가 발생합니다. 서로 다른 메모리 레이아웃 간 데이터 이동 또한 비용이 많이 듭니다.\n\n# 현실 확인\n\nWASM을 더 탐험하면서, 처음 기대와 실제 사용 간의 차이를 볼 수 있었어요.\n\n\n\n## WASM과 Rust로의 첫 걸음\n\n나는 WASM을 실험하기 시작했고, wasm-bindgen이라는 도구를 사용했다. 이 도구는 WASM 모듈과 JavaScript가 함께 작동할 수 있도록 도와준다. 나의 첫 예제는 간단했다:\n\n```js\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: u32, b: u32) -\u003e u32 {\n  a + b\n}\n```\n\nLink-time optimization (LTO)을 사용하여 wasm-pack을 이용하면, 이 기본적인 덧셈 함수가 작은 214바이트의 WASM 모듈로 컴파일된다. 처음에는 이로 인해 WASM이 간결하고 효율적인 코드를 제공할 수 있다는 것을 입증한 것으로 여겨졌다.\n\n\n\n## WAT 형식 알아보기\n\n이 작은 코드 조각이 어떻게 작동하는지 더 잘 이해하기 위해, WAT(WebAssembly 텍스트 형식) 버전을 살펴보았습니다. WAT는 WASM 이진 코드의 가독성 있는 버전입니다. WASM 애플리케이션을 디버깅하고 최적화하는 데 필수적입니다. 'add' 함수의 WAT는 다음과 같습니다:\n\n```js\n(module\n  (type (;0;) (func (param i32 i32) (result i32)))\n  (func (;0;) (type 0) (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (memory (;0;) 17)\n  (export \"memory\" (memory 0))\n  (export \"add\" (func 0)))\n```\n\n이 간결한 형식은 WASM의 간단한 계산 작업에 대한 효율성을 보여줍니다 — 여분의 오버헤드가 없고, 함수를 수행하는 핵심 연산만 있습니다.\n\n\n\n## 복잡성 추가의 영향\n\n나는 그 예시를 수정하여 문자열 작업을 추가하여 모듈 크기에 미치는 영향을 살펴보았습니다:\n\n```js\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: u32, b: u32) -\u003e u32 {\n    let a = a.to_string().parse::\u003cu32\u003e().unwrap();\n    let b = b.to_string().parse::\u003cu32\u003e().unwrap();\n    return a + b;\n}\n```\n\n똑같은 계산을 하지만, 이 버전은 훨씬 더 큰 14.5KB의 WASM 모듈을 생성했습니다. WAT 파일은 7,126줄 이상으로 늘어나며, 문자열 처리의 추가 복잡성과 오버헤드를 반영했습니다.\n\n\n\n![2024-05-14-IwasunderstandingWASMallwrong_1.png](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_1.png)\n\n웹어셈블리( WebAssembly) 인스턴스 생성자는 4KB 미만의 모듈만 동기적으로 컴파일할 수 있습니다. 더 큰 모듈은 비동기적으로 컴파일해야 합니다. 하지만 그 한도 이내로 WASM 파일을 유지하는 것은 불가능한 것 같았어요.\n\n# 환상의 깨달음\n\n문자열 조작과 같은 기능을 추가하면 WASM 모듈의 크기가 급격하게 증가하는 것이 큰 과제였습니다. 파일 크기의 급증은 WASM이 경량이고 효율적인 형식으로서의 약속과 상반됐어요.\n\n\n\n## WASM 모듈 크기 최적화\n\n이러한 문제를 해결하기 위해 WASM 모듈 크기를 최적화하는 방법을 탐색했습니다. 다음은 WASM 애플리케이션의 크기를 최소화하기 위한 몇 가지 전략입니다:\n\n- 패닉 회피하기: Rust의 패닉 처리는 오버헤드를 추가합니다. `Option` 및 `Result` 유형을 사용하여 오류를 효율적으로 처리하고 패닉의 부풀어 오름을 피합니다.\n- 문자열 사용 제한: 동적 문자열 작업은 WASM 모듈 크기를 크게 불리울 수 있습니다. 정수 또는 고정 크기 데이터 유형을 사용하여 모듈을 간결하게 유지합니다.\n- 링크-시간 최적화 (LTO): Rust 컴파일러에서 LTO를 활성화하면 사용되지 않는 코드를 제거하고 크레이트 경계를 효율적으로 최적화하여 컴파일된 WASM 크기를 줄일 수 있습니다.\n- 수동 트리 셰이킹: Rust-to-WASM 파이프라인에서 자동 트리 셰이킹이 제한되지만, 필요한 함수 및 종속성만 포함되도록 수동으로 확인하여 부풀림을 줄입니다.\n\n이러한 노력에도 불구하고 때로는 복잡한 데이터 유형 및 고수준 프로그래밍 작업에서 흔히 발생하는 작업으로 인해 극복하기 어려운 과제가 있었습니다.\n\n\n\n## 웹어셈블리(WASM)에서 동적 언어\n\nWASM의 난점은 러스트에만 해당하는 것은 아닙니다. 특히 파이썬과 같은 동적 언어는 더 큰 어려움을 겪습니다. 왜 그런지 살펴보려면 동적 언어를 WASM으로 컴파일하는 것을 고려해보세요:\n\n- 인터프리터 컴파일: 파이썬의 경우, 사용자의 코드뿐만 아니라 전체 인터프리터를 WASM으로 컴파일해야 합니다. 이는 언어가 지원하는 모든 내장 함수와 라이브러리를 포함합니다.\n- 코드 실행: WASM으로 컴파일된 파이썬 코드를 실행하려면 인터프리터 내에서 인터프리터를 실행해야 합니다. 이는 상당한 오버헤드를 발생시키며 큰 WASM 이진 파일을 만들 수 있습니다.\n\n\n\n고도 정적 타입 컴파일 언어인 Go의 경우에도, 최소 WASM 파일 크기는 Go 프로그래밍 언어 위키에 따르면 2MB입니다.\n\n## 커뮤니티 도전 과제\n\n나는 다른 개발자 커뮤니티와 같이 저의 환멸을 겪었습니다. 많은 기사들이 유사한 어려움을 논의했습니다:\n\n- Zaplib 사후 분석: 이는 성능 향상 부족 및 개발 복잡성으로 인해 WASM을 버리기로 한 스타트업의 선택을 자세히 다룹니다.\n- 나무 흔들기, 식물학적으로 오류가 있는 알고리즘: 이는 WASM 도구 체인에서 나무 흔들기의 미숙함을 강조하며, 사용하지 않는 코드를 제거하여 최종 바이너리 크기를 줄이는 중요한 프로세스를 강조합니다.\n\n\n\n이 커뮤니티 경험들은 현재의 WASM을 사용하는 데 어려움을 겪는 것을 강조하며 처음에 느꼈던 흥분을 식게 만드는 반대 의견을 제공했습니다.\n\n# 변화의 시작\n\nWASM에 대한 실망을 극복하면서, Uber에서 개발한 h3 라이브러리를 찾았을 때 판별적인 순간이 찾아왔습니다. 이 라이브러리는 여러 언어(C, Python, Java, JavaScript)로 구현된 버전을 포함하고 있으며, h3-js는 C에서 컴파일된 WASM을 사용하는 JavaScript와 WASM을 연결하기 위해 Emscripten을 사용합니다.\n\n## h3 이해하기\n\n\n\nh3는 지리 공간 색인을 위해 설계되었습니다. 이는 좌표를 육각형 그리드에 색인화하는 방법을 제공합니다. 이 시스템은 대규모 지리 공간 데이터셋을 가진 애플리케이션에 특히 유용합니다. 저는 자주 쓰는 한 가지 함수는 `latLngToCell`인데, 이 함수는 위도와 경도 좌표를 육각형 그리드 셀 식별자로 변환해줍니다.\n\n## 성능 비교\n\nh3-js의 성능을 측정하기 위해 C 구현과 JavaScript 버전을 WASM을 사용하여 벤치마크했습니다. 다행히, 두 레포지토리에 이미 벤치마킹 프로그램이 포함되어 있었습니다. 여기 내 로컬 M1 MacBookPro에서의 결과입니다:\n\n# WASM의 기능 탐색\n\n\n\n의완 놀라운 h3-js 결과에 영감을 받아 WASM의 능력을 더 파헤치기로 결정했어요. Collatz 추측을 사용하여 JavaScript와 FFI의 성능을 비교해봤어요.\n\n## Collatz 추측이란?\n\nCollatz 추측은 “3n + 1 문제\"로 알려진 수학적 가설로, 다음과 같이 정의된 순서를 포함합니다:\n\n- 양의 정수 n으로 시작합니다.\n- 만약 n이 짝수이면 2로 나눕니다.\n- 만약 n이 홀수이면 3을 곱하고 1을 더합니다.\n- n이 1이 될 때까지 이 과정을 반복합니다.\n\n\n\n![Image](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_3.png)  \n\n가설은 시작하는 n 값이 무엇이든, 시퀀스는 항상 결국 1에 도달한다고 주장합니다.\n\n## JS, FFI 및 WASM에서 Collatz 가설\n\n성능을 비교하기 위해 가설을 순수 JavaScript로 구현했고, Rust 함수를 호출하기 위해 FFI를 사용했으며 WASM에서 직접 구현했습니다. 그리고 입력값으로 n = 670617279을 사용했는데, 이는 1에 도달하는 데 986단계가 필요합니다.\n\n\n\n- JavaScript\n\n```js\nfunction collatzSteps(n) {\n    let counter = 0;\n    while (n !== 1) {\n      if (n % 2 === 0) {\n        n /= 2;\n      } else {\n        n = 3 * n + 1;\n      }\n      counter++;\n    }\n    return counter;\n  }\n```\n\n- Rust (FFI) and Rust (WASM)\n\n```js\npub fn collatz_steps(mut n: u64) -\u003e u64 {\n    let mut counter = 0;\n    while n != 1 {\n      if n % 2 == 0 {\n        n /= 2;\n      } else {\n        n = 3 * n + 1;\n      }\n      counter += 1;\n    }\n    return counter;\n  }\n```\n\n\n\n더 많은 세부 정보를 원하시면 제 리포지토리를 확인해주세요. 다음은 M1 MacBook Pro와 관련한 벤치마크입니다:\n\n이러한 결과는 WASM이 연산 집중적인 작업에 특히 네이티브 JavaScript 및 FFI보다 우월한 성능을 보일 수 있다는 것을 입증했습니다.\n\n# WASM 성능에 대한 깊은 탐구\n\nh3-js와 콜라츠 추측에서의 WASM의 뛰어난 성능을 보고 나니, WASM에 대해 처음에 이해한 것 이상의 가능성이 있다는 것이 분명해졌습니다.\n\n\n\n## WASM이 FFI와 다른 점\n\nWASM의 효율성을 이해하는 핵심은 낮은 수준의 이진 명령 형식으로 설계된 것에 있습니다. 이것은 플랫폼에 의존하지 않을 뿐만 아니라 실행 속도와 조밀성을 최적화했습니다. 이는 FFI와 달리 높은 오버헤드가 발생할 수 있는데, 이는 실행 컨텍스트 간 데이터 매샬링과 다른 메모리 모델 처리로 인해 발생할 수 있습니다. 이 구성은 다음을 통해 일반적인 FFI 오버헤드를 최소화합니다:\n\n- 메모리 관리가 직선적이고 일관적임: WASM은 단일 연속 메모리 블록을 사용하여 호스트 환경과의 인터페이스를 단순하게 만듭니다. 이는 전통적인 FFI 환경에서 메모리 관리와 관련된 비용을 줄입니다.\n- 실행에 최적화된 이진 형식: WASM 이진 형식은 현대 JIT(Just-In-Time) 컴파일러에 의해 효율적으로 디코딩 및 실행되도록 설계되었습니다. 이는 일반적인 런타임 해석 벌칙을 따르지 않아도 네이티브 기계 코드 속도에 근접한 성능을 제공합니다.\n\n## WASM의 백엔드 사용 사례\n\n\n\nh3-js 라이브러리 조사 결과와 내 Collatz 추측 실험으로 인해 WASM의 응용 프로그램 랜드스케이프에 대한 시각이 변화했습니다:\n\n- Frontend보다 Backend: WASM은 초반에는 웹 애플리케이션 잠재력으로 알려졌지만, 그 강점은 특히 백엔드 및 브라우저 이외의 환경에서 데이터 처리, 과학적 계산 및 실시간 미디어 인코딩/디코딩과 같은 공통 계산 중심 환경에서 두드러집니다.\n- Edge Computing: WASM은 엣지 컴퓨팅 애플리케이션에 이상적으로 적합하며, 데이터 소스 근처에서 코드를 실행함으로써 응답 시간을 크게 개선하고 대역폭 사용량을 줄일 수 있습니다.\n\n# WASM을 활용한 ULID 생성 최적화\n\nWASM의 성능을 활용한 실용적인 응용 프로그램 중 하나는 Universally Unique Lexicographically Sortable Identifiers (ULID)를 생성하는 것입니다. ULID는 UUID와 유사한 목적을 가지고 있지만 정렬 가능합니다. 타임스탬프와 무작위 구성 요소로 구성되어 있으며, 고유성과 사전식 정렬 가능성을 보장하기 위해 인코딩되어 있습니다. 이로 인해 정렬 순서와 고유성이 중요한 분산 시스템에서 특히 유용합니다.\n\n\n\n## 40배 성능 향상\n\n기존 JavaScript ULID 생성 구현을 Rust로 변환하여 WASM으로 컴파일했더니, 상당한 성능 향상을 이뤘습니다. 원래 JavaScript 버전보다 약 40배 빠릅니다.\n\n이 초기 번역은 간단했지만, 성능을 더 최적화하기 위해 섬세한 방법이 이어졌습니다.\n\n## 이후 최적화\n\n\n\n먼저, 성능 향상은 초기에 약 10배 빨라졌습니다. 그러나 러스트 구현에서 여러 최적화를 통해 이를 40배로 높였습니다. 이 높은 성능 향상에 기여한 주요 기술들은 WASM에 특정되지는 않지만 다음과 같습니다:\n\n1. 효율적인 데이터 구조 사용\n\n구현에 사용되는 데이터 구조를 최적화하는 것, 즉 동적으로 크기를 조절하는 대신 미리 할당 용량을 갖춘 벡터와 같은 데이터 구조를 사용하는 것은 메모리 할당을 최소화하고 성능이 빈번한 메모리 작업에 의해 방해받지 않도록 보장했습니다.\n\n```rust\n// 이전\nString::new();\n// 이후\nString::with_capacity(len);\n```\n\n\n\n2. 불필요한 변환과 메모리 할당 피하기\n\n원래의 러스트 구현은 계산 비용이 많이 드는 문자열 및 문자 변환을 포함했습니다. 데이터 처리 방식을 최적화하고 메모리 할당을 줄이는 것으로 성능이 크게 향상되었습니다. 예를 들어, 가능한 경우에 문자열이나 문자로 변환하는 대신 직접 바이트 배열을 사용하는 것이 오버헤드를 줄이는 데 도움이 되었습니다.\n\n```js\n// 이전\nconst ENCODING: \u0026str = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\n...\nlet mut chars = Vec::with_capacity(len);\nfor index in 0..len {\n    chars.push(ENCODING.chars().nth(index).unwrap());\n}\n\n// 이후\nconst ENCODING: \u0026str = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst ENCODING_BYTES: \u0026[u8] = ENCODING.as_bytes();\n...\nlet mut chars = Vec::with_capacity(len);\nfor index in 0..len {\n    chars.push(ENCODING_BYTES[index] as char);\n}\n```\n\n\n\n함수 호출간에 반복적으로 사용되는 값, 예를 들어 인코딩 길이의 제곱과 같은 값을 미리 계산하고 캐싱함으로써 계산 부하를 크게 줄였습니다. 이는 `decode_time`과 같은 함수에 특히 효과적이었습니다. 이 함수들은 반복적이고 예측 가능한 작업들이 많았기 때문이죠.\n\n```js\n// Before\nconst ENCODING_LEN: usize = 32;\nconst TIME_LEN: usize = 10;\n...\nfor i in 0..TIME_LEN {\n    time += i as f64 * (ENCODING_LEN as u64).pow(index as u32) as f64;\n}\n\n// After\nconst ENCODING_LEN: usize = 32;\nconst POWERS: [f64; 10] = [1.0, 32.0, ..., 35184372088832.0];\n...\nfor i in 0..TIME_LEN {\n    time += i as f64 * POWERS[index];\n}\n```\n\n# 결론\n\nWASM을 활용한 ULID 생성의 최적화는 WASM의 성능을 이해하고 활용함으로써 실제 응용 프로그램에서 상당한 성능 향상을 이끌어냈습니다. 이 사례 연구는 성능과 효율이 중요한 백엔드 시스템 뿐만 아니라 웹에서도 툴체인이 발전함에 따라 WASM이 효과적으로 활용될 수 있는 한 예입니다.\n\n\n\n현재, 대규모 이진 크기의 문제로 WASM 사용이 프론트엔드 애플리케이션에서 다운로드 및 실행 속도가 중요한 경우에 제한되는 도전 과제가 있습니다. 그러나 이는 영구적인 제한이 아니라 현재의 장애물입니다. WASM 툴체인이 트리 쉐이킹 및 바이너리 출력 최적화와 같은 기술에서 더 발전함에 따라 이진 크기가 크게 축소될 것으로 예상됩니다.\n\n웹에서의 WASM의 미래는 밝습니다. 툴체인이 발전하고 더 작고 효율적인 바이너리를 생성하는 능력을 향상함에 따라 WASM은 웹 성능과 기능을 혁신할 잠재력이 커집니다. 이것은 백엔드 애플리케이션을 향상시키는 것뿐만 아니라 복잡한 애플리케이션이 브라우저 환경에서 배포되고 실행되는 방식을 철저히 변화시킬 수 있어, 원시 환경과 동등하게 효율적이고 강력하게 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png"},"coverImage":"/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png","tag":["Tech"],"readingTime":10},{"title":"프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일","description":"","date":"2024-05-14 12:23","slug":"2024-05-14-FrontendWeeklyDigest362612May2024","content":"\n\n![이미지](/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png)\n\n# 웹 개발\n\n- HTML 툴팁에 Popover API 사용하기\n- Figma의 모바일 엔진 진화: TypeScript로의 Figma 여정\n- Google Gemini를 활용한 채팅 통합 구축\n- Frontend 용어 분석: Jamstack에 대해\n- 모바일 핀테크 API 작업의 어려움 극복하기\n- 의도적인 렌더링 차단\n- React Three Fiber로 3D 텍스트 왜곡 효과 탐색\n- Target=_blank은 rel=noopener를 의미합니다\n\n- 도구\n  - 5개의 노드 버전 관리자 비교 - 어떤 것이 적합한가요?\n  - Gulp 개발자 설문조사 소개\n\n- 접근성\n  - 왜 웹 접근성에 크게 관심을 가지고 있고 당신도 해야 할 이유\n  - 유럽 접근성 법안 (EAA) 소개\n  - 강조된 텍스트에 대한 간단한 주의 문단\n\n\n\n# CSS\n\n- 섹션 기반 스크롤 진행 표시기에 CSS 스크롤-드리븐 애니메이션 사용하기\n- CSS 앵커 위치 지정 API 소개\n- CSS 모양 만드는 현대 가이드\n- 왜 더 이상 CSS를 최소화하는 것에 대해 이야기하지 않을까요?\n\n# JavaScript\n\n- JavaScript에 대한 5가지 기본적인 것, 비 JavaScript 중심 웹 디자이너에 도움이 될 것\n- innerHTML에 대한 새로운 대안\n- 글로벌 변수 수정이 해로운 이유\n- JavaScript에서 완벽한 깊은 동등성 얻는 방법\n\n\n\n- 리액트\n\t- [리액트 개발자 도구 사용 방법 - 예제를 통한 설명](#)\n\t- [리액트 서버 컴포넌트(RSCs)의 범죄 조사](#)\n\t- [왜 리액트 쿼리를 사용해야 하는가?](#)\n\t- [코드 400줄로 나만의 리액트.js 만들기](#)\n\t- [리액트를 위한 헤들리스 UI v2.0](#)\n\t- [RedwoodJS에서 리액트 서버 컴포넌트 활용하기](#)\n\t- [반응형 디자인을 위해 리사이즈 옵저버 API 사용하기](#)\n\n- 앵귤러\n\t- [앵귤러에서 미뤄진 뷰에서의 번들 크기 개선](#)\n\t- [앵귤러의 변경 감지에 대한 신비를 해소하다: 철저한 가이드](#)\n\t- [앵귤러 뷰 엔진 vs Ivy: 철저한 가이드](#)\n\t- [앵귤러: DOM 살포화](#)","ogImage":{"url":"/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png"},"coverImage":"/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기","description":"","date":"2024-05-14 12:20","slug":"2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications","content":"\n\n현대 웹 애플리케이션에서 상태를 관리하는 것은 종종 복잡하고 번거로울 수 있습니다, 특히 API 요청과 같은 비동기 데이터를 처리할 때. 그러나 Redux Toolkit Query (RTK Query)를 사용하면 데이터 가져오기, 캐싱 및 상태 관리가 간소화되어 개발자들이 더 적은 코드로 성능 최적화된 애플리케이션을 작성할 수 있습니다. 이 기사에서는 RTK Query를 사용하여 Todo 애플리케이션 설정하는 방법을 안내하며, 그 강력함과 효율성을 소개하겠습니다.\n\n# 프로젝트 구조 설정하기\n\n먼저 React 프로젝트를 구성하여 시작하고 Redux Toolkit 및 RTK Query가 설치되어 있는지 확인하세요. 프로젝트 구조에는 주 진입 파일, API 서비스 슬라이스 및 Todo 컴포넌트가 포함됩니다.\n\n```js\n//main.jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.jsx';\nimport { ApiProvider } from \"@reduxjs/toolkit/query/react\";\nimport apiSlice from \"./feature/todo/todoAPI/apiSlice.js\";\n\n// 루트 엘리먼트를 설정하고 전체 애플리케이션을 RTK Query용으로 ApiProvider로 랩합니다\nReactDOM.createRoot(document.getElementById('root')).render(\n  \u003cReact.StrictMode\u003e\n    \u003cApiProvider api={apiSlice}\u003e\n        \u003cApp /\u003e\n    \u003c/ApiProvider\u003e\n  \u003c/React.StrictMode\u003e,\n);\n```\n\n\n\n# API 서비스 슬라이스 구성하기\n\nAPI 슬라이스는 RTK Query를 사용하여 할 일을 가져오고 추가하고 업데이트하고 삭제하는 방법을 정의하는 곳입니다.\n\n```js\n//apiSlice.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst todoApi = createApi({\n    reducerPath: \"api\", // API 상태 슬라이스를 위한 고유한 키\n    baseQuery: fetchBaseQuery({ baseUrl: \"http://localhost:5050\" }), // 가져오기 로직을 처리하는 기본 쿼리\n    tagTypes: [\"TODOS\"], // 자동 캐시 다시 가져오기를 위한 태그\n    endpoints: (builder) =\u003e ({\n        getTodos: builder.query({ // 할 일을 가져오는 엔드포인트\n            query: () =\u003e \"/todos\",\n            providesTags: [\"TODOS\"]\n        }),\n        addTodo: builder.mutation({ // 새로운 할 일 추가하는 엔드포인트\n            query: (todo) =\u003e ({\n                url: \"/todos\",\n                method: \"POST\",\n                body: todo\n            }),\n            invalidatesTags: [\"TODOS\"]\n        }),\n        updateTodo: builder.mutation({ // 기존 할 일을 업데이트하는 엔드포인트\n            query: (todo) =\u003e ({\n                url: `/todos/${todo.id}`,\n                method: \"PATCH\",\n                body: todo\n            }),\n            invalidatesTags: [\"TODOS\"]\n        }),\n        deleteTodo: builder.mutation({ // 할 일을 삭제하는 엔드포인트\n            query: ({ id }) =\u003e ({\n                url: `/todos/${id}`,\n                method: \"DELETE\",\n            }),\n            invalidatesTags: [\"TODOS\"]\n        })\n    })\n});\n\nexport const { useGetTodosQuery, useAddTodoMutation, useUpdateTodoMutation, useDeleteTodoMutation } = todoApi;\n\nexport default todoApi;\n```\n\n# 할 일 컴포넌트 구성하기\n\n\n\nTodo 컴포넌트에서 할 일을 표시하고 관리하는 기능을 구현해보세요.\n\n```js\n//TodoApp.jsx\nimport { useState } from 'react';\nimport styles from './TodoApp.module.css';\nimport { useAddTodoMutation, useDeleteTodoMutation, useGetTodosQuery, useUpdateTodoMutation } from \"./todoAPI/apiSlice.js\";\n\nfunction TodoApp() {\n    const [task, setTask] = useState('');\n    const { data: todos, isLoading, isError, isSuccess, error } = useGetTodosQuery();\n    const [addTodo] = useAddTodoMutation();\n    const [updateTodo] = useUpdateTodoMutation();\n    const [deleteTodo] = useDeleteTodoMutation();\n\n    // 할 일 추가를 처리하는 함수\n    function addTodoHandler() {\n        const newTodo = { id: Math.random(), task: task, isCompleted: false };\n        addTodo(newTodo);\n        setTask('');\n    }\n\n    // 할 일 완료 상태 전환을 처리하는 함수\n    function toggleCompletion(todo) {\n        updateTodo({ ...todo, isCompleted: !todo.isCompleted });\n    }\n\n    // 할 일 삭제를 처리하는 함수\n    function deleteTodoHandler(todo) {\n        deleteTodo(todo);\n    }\n\n    return (\n        \u003cdiv className={styles.container}\u003e\n            \u003ch1 className={styles.title}\u003e할 일 목록\u003c/h1\u003e\n            \u003cinput\n                type=\"text\"\n                placeholder=\"새로운 작업 추가\"\n                value={task}\n                onChange={(e) =\u003e setTask(e.target.value)}\n                className={styles.todoInput}\n            /\u003e\n            \u003cbutton className={styles.button} onClick={addTodoHandler}\u003e할 일 추가\u003c/button\u003e\n            \u003cul className={styles.todoList}\u003e\n                {isLoading \u0026\u0026 \u003cp\u003e로딩 중...\u003c/p\u003e}\n                {todos \u0026\u0026 \u003c\u003e\n                    {todos.map((todo) =\u003e (\n                        \u003cli key={todo.id} className={styles.todoItem}\u003e\n                            \u003cspan\n                                className={styles.todoTask}\n                                style={{ textDecoration: todo.isCompleted ? 'line-through' : 'none' }}\n                                onClick={() =\u003e toggleCompletion(todo)}\n                            \u003e\n                              {todo.task}\n                            \u003c/span\u003e\n                            \u003cbutton className={`${styles.button} ${styles.delete}`} onClick={() =\u003e deleteTodoHandler(todo)}\u003e삭제\u003c/button\u003e\n                        \u003c/li\u003e\n                    ))}\n                \u003c/\u003e}\n            \u003c/ul\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default TodoApp;\n```\n\n참고: 코드샌드박스 링크에는 컴포넌트를 스타일링하는 CSS 파일도 제공됩니다.\n\n# 마무리\n\n\n\nRTK Query는 Redux 애플리케이션에서 서버 측 데이터를 효율적으로 관리할 수 있는 강력한 솔루션을 제공합니다. 데이터 가져오기 및 상태 관리 로직을 추상화함으로써, 개발자들이 기능 구축에 집중할 수 있도록 도와줍니다. React 개발자들에게 꼭 필요한 도구가 될 수 있습니다.\n\n[여기를 클릭하여 데모 사이트에서 확인해보세요!](https://codesandbox.io/p/devbox/rtk-query-r8ttsh?embed=1\u0026file=%2Fsrc%2Ffeatures%2Ftodo%2FtodoAPI%2FapiSlice.js)","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제","description":"","date":"2024-05-14 12:18","slug":"2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png)\n\n자바스크립트는 현대 웹 개발의 기초가 된 다재다능하고 동적인 프로그래밍 언어입니다. React, Angular, Vue.js와 같은 인기있는 프레임워크들이 등장함에 따라 특정 프레임워크를 배우기에 싫증이 나게 되기 쉽습니다. 그러나 점프하기 전에 자바스크립트 기초를 확실히 이해하는 것이 중요합니다. 이 블로그 포스트에서는 React 또는 다른 자바스크립트 프레임워크로 넘어가기 전에 반드시 숙달해야 할 핵심 주제를 살펴보겠습니다.\n\n# 1. 변수, 데이터 유형 및 연산자\n\n자바스크립트의 변수, 데이터 유형 및 연산자의 기초를 이해하는 것은 어떤 프로그래밍 작업에도 꼭 필요합니다. 이에는 다음이 포함됩니다:\n\n\n\n- 변수 선언 (let, const, var)\n- 데이터 유형 (원시, 복합, null, undefined)\n- 유형 강제 변환 및 변환\n- 연산자 우선순위 및 결합성\n\n코드 예시:\n\n\n# 변수 선언:\n\nJavaScript\n\n\n\n\n```js\nlet name = 'John';\nconst PI = 3.14;\nvar age = 30;\n```\n\n# 데이터 유형:\n\n자바스크립트\n\n```js\nlet isAdmin = true; // 불리언\nlet num = 42; // 숫자\nlet greeting = 'Hello'; // 문자열\n```\n\n\n\n# 형 변환:\n\n자바스크립트\n\n```js\nlet num = '42'; // 문자열\nconsole.log(num * 2); // 84 출력 (숫자로 강제 변환)\n```\n\n# 연산자 우선순위:\n\n\n\n자바스크립트\n\n```js\nlet result = 2 + 3 * 4; // 결과는 14가 나옵니다 (곱셈이 덧셈보다 높은 우선순위를 갖습니다)\n```\n\n## 2. 제어 구조 및 함수\n\n제어 구조 및 함수는 자바스크립트 프로그래밍의 기본 요소입니다. 다음을 확실히 이해해두세요:\n\n\n\n- 조건문 (if/else, switch)\n- 반복문 (for, while, do-while)\n- 함수 (선언, 표현식, 화살표 함수)\n- 함수 매개변수 및 반환 유형\n\n코드 예시:\n\n```javascript\n// 조건문:\n\n```\n\n\n\n```javascript\nlet age = 25;\nif (age \u003e= 18) {\n  console.log('당신은 성인입니다.');\n} else {\n  console.log('당신은 미성년자입니다.');\n}\n```\n\n# 반복문:\n\nJavaScript\n\n```javascript\nfor (let i = 0; i \u003c 5; i++) {\n  console.log(i);\n}\n```\n\n\n\n# Functions:\n\n자바스크립트\n\n```js\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('John'); // \"Hello, John!\"을 출력합니다\n```\n\n# 화살표 함수:\n\n\n\n자바스크립트\n\n```js\nlet double = x =\u003e x * 2;\nconsole.log(double(5)); // 10을 출력합니다.\n```\n\n## 3. 객체지향 프로그래밍 (OOP) 개념\n\n자바스크립트는 객체지향 언어이며, OOP 원칙을 이해하는 것이 중요합니다.\n\n\n\n- 객체와 속성\n- 생성자와 프로토타입\n- 상속과 다형성\n- 캡슐화와 추상화\n\n코드 예시:\n\n# 객체와 속성:\n\nJavaScript\n\n\n\n```js\nlet person = {\n  name: '존',\n  age: 30,\n  greet: function() {\n    console.log(`안녕, 내 이름은 ${this.name}이야!`);\n  }\n};\nperson.greet(); // \"안녕, 내 이름은 존이야!\"\n\n# 생성자와 프로토타입:\n\nJavaScript\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.greet = function() {\n  console.log(`안녕, 내 이름은 ${this.name}이야!`);\n};\nlet john = new Person('존', 30);\njohn.greet(); // \"안녕, 내 이름은 존이야!\"\n\n\n\n# 상속:\n\n자바스크립트\n\nfunction Employee(name, age, department) {\n  Person.call(this, name, age);\n  this.department = department;\n}\nEmployee.prototype = Object.create(Person.prototype);\nlet employee = new Employee('Jane', 25, '마케팅');\nemployee.greet(); // \"안녕하세요, 제 이름은 Jane입니다!\"\n\n# 4. DOM 조작과 이벤트\n\n\n\n문서 객체 모델(DOM)은 웹 개발의 기바입니다. 다음을 배워보세요:\n\n- DOM 요소 선택 및 조작하기\n- 이벤트 처리하기 (클릭, 호버, 제출 등)\n- 이벤트 위임과 버블링 사용하기\n\n코드 예시:\n\n- DOM 요소 선택 및 조작하기:\n\n\n\nJavaScript\n\nlet heading = document.querySelector('h1');\nheading.textContent = '새 헤딩';\n\n# 이벤트 처리:\n\nJavaScript\n\n\n\nlet button = document.querySelector('button');\nbutton.addEventListener('click', function() {\n  console.log('버튼이 클릭되었습니다!');\n});\n\n# 이벤트 위임:\n\nJavaScript\n\nlet ul = document.querySelector('ul');\nul.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    console.log('리스트 아이템이 클릭되었습니다!');\n  }\n});\n\n\n\n# 5. 비동기 프로그래밍과 콜백\n\n자바스크립트에서 비동기 프로그래밍은 매우 중요합니다. 특히 외부 데이터나 API를 다룰 때:\n\n- 콜백과 고차 함수를 이해하세요.\n- 프로미스 및 async/await 구문에 대해 배우세요.\n- 오류 및 예외 상황을 다루세요.\n\n코드 예시:\n\n\n\n## 콜백:\n\n자바스크립트\n\nfunction loadData(callback) {\n  setTimeout(function() {\n    callback(['John', 'Jane', 'Bob']);\n  }, 2000);\n}\nloadData(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n\n## 프로미스:\n\n\n\nJavaScript\n\nfunction loadData() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(['John', 'Jane', 'Bob']);\n    }, 2000);\n  });\n}\nloadData().then(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n\n# Async/await:\n\nJavaScript\n\n\n\nasync function loadData() {\n  try {\n    let data = await fetch('(링크 제공 불가)');\n    console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n  } catch (error) {\n    console.error(error);\n  }\n}\nloadData();\n\n# 6. JavaScript 객체 메소드와 배열\n\n필수 객체 메소드와 배열 조작 기술을 익혀보세요:\n\n- 객체 메소드 (keys, values, entries 등)\n- 배열 메소드 (map, filter, reduce 등)\n- 배열 구조 분해 및 전개\n\n\n\n코드 예시:\n\n# 객체 메소드:\n\n자바스크립트\n\nlet person = { name: 'John', age: 30 };\nconsole.log(Object.keys(person)); // 출력: [\"name\", \"age\"]\nconsole.log(Object.values(person)); // 출력: [\"John\", 30]\n\n\n\n# 배열 메소드:\n\n자바스크립트\n\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(numbers.map(x =\u003e x * 2)); // 결과: [2, 4, 6, 8, 10]\nconsole.log(numbers.filter(x =\u003e x % 2 === 0)); // 결과: [2, 4]\n\n# 배열 해체 및 전개:\n\n\n\n자바스크립트\n\nlet arr = [1, 2, 3];\nlet [first, ...rest] = arr;\nconsole.log(first); // 결과는 1\nconsole.log(rest); // 결과는 [2, 3]\n\nlet newArr = [...arr, 4, 5];\nconsole.log(newArr); // 결과는 [1, 2, 3, 4, 5]\n\n# 7. 클로저와 'this' 키워드\n\n\n\n클로저와 ‘this’ 키워드는 조금 까다로울 수 있지만, 이해하는 것이 중요합니다:\n\n- 클로저와 렉시컬 스코핑\n- ‘this’ 키워드와 컨텍스트 바인딩\n- bind, call, apply 메소드의 사용법\n\n코드 예시:\n\n# 클로저:\n\n\n\nJavaScript\n\nfunction outer() {\n  let x = 10;\n  function inner() {\n    console.log(x); // 10을 출력합니다\n  }\n  return inner;\n}\nlet innerFunc = outer();\ninnerFunc(); // 10을 출력합니다\n\n# 'this' 키워드:\n\nJavaScript\n\n\n\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}!`);\n};\nlet john = new Person('John');\njohn.greet(); // 출력: \"Hello, my name is John!\"\n\n# Bind, call, and apply:\n\nJavaScript\n\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\nlet greetJohn = greet.bind(null, 'John');\ngreetJohn(); // 출력: \"Hello, John!\"\n\n\n\nlet person = { name: 'Jane' };\ngreet.call(person, person.name); // 출력: \"안녕, Jane!\"\nlet numbers = [1, 2, 3];\nconsole.log(Math.max.apply(null, numbers)); // 출력: 3\n\n# 8. 오류 처리 및 디버깅\n\n오류를 처리하고 코드를 효과적으로 디버깅하는 방법을 배워보세요:\n\n- 오류 객체와 스택 추적 이해하기\n- console.log, debugger, 그리고 브라우저의 개발자 도구 사용하기\n- try-catch 블록 및 오류 처리 전략 구현하기\n\n\n\n코드 예시:\n\n## 오류 처리:\n\nJavaScript\n\ntry {\n  let x = 10 / 0;\n} catch (error) {\n  console.error(error); // \"Error: Division by zero\"이 출력됩니다.\n}\n\n\n\n# 디버깅:\n\nJavaScript\n\nconsole.log('Hello'); // \"Hello\"를 출력합니다\ndebugger; // 실행을 일시 중단하고 DevTools를 엽니다\n\n# 9. JavaScript Best Practices and Code Organization\n\n\n\n깨끗하고 유지보수 가능한 코드를 작성하기 위해 최상의 관행을 따르고 코드베이스를 조직화하세요:\n\n- 모듈식 코드와 임포트 사용\n- 네이밍 규칙과 코딩 표준 준수\n- 코드 분할과 트리 쉐이킹 구현\n\n코드 예시:\n\n\n# 모듈식 코드:\n\n\n\nJavaScript\n\n// greet.js\nfunction greet(name) {\n  console.log(`안녕, ${name}!`);\n}\nexport { greet };\n\nJavaScript\n\n// main.js\nimport { greet } from './greet.js';\ngreet('John'); // 출력 결과: \"안녕, John!\"\n\n\n\n# 네이밍 규칙 및 코딩 표준:\n\nJavaScript\n\n// 일관된 네이밍 규칙을 따르세요\nlet firstName = 'John';\nlet lastName = 'Doe';\n\n// 일관된 들여쓰기와 공백을 사용하세요\nif (true) {\n  console.log('Hello');\n}\n\n\n\n# 코드 분할과 트리 쉐이킹:\n\n자바스크립트\n\n// Webpack 또는 Rollup을 사용하여 코드를 작은 조각으로 분할하고\n// 사용하지 않는 코드를 제거하세요 (트리 쉐이킹)\n\n# 10. 브라우저 호환성 및 웹 표준\n\n\n\n여러 브라우저에서 코드가 작동하도록 보장하고 웹 표준을 따르세요:\n\n- 브라우저의 특이점과 불일치를 이해하세요\n- 기능 감지와 폴리필 사용하기\n- 웹 표준과 접근성 가이드라인 준수하기\n\n코드 예시:\n\n\n# 기능 감지:\n\n\n\n\n자바스크립트\n\nif (typeof window.addEventListener === 'function') {\n  // 이벤트 리스너 추가\n} else {\n  // 대체 방법 사용\n}\n\n## 폴리필:\n\n자바스크립트\n\n\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement) {\n    // Polyfill 구현\n  };\n}\n\n# 웹 표준과 접근성:\n\nJavaScript\n\n// 시맨틱 HTML 요소 사용\n\u003cheader\u003e헤더\u003c/header\u003e\n\u003cnav\u003e네비게이션\u003c/nav\u003e\n\u003cmain\u003e주요 콘텐츠\u003c/main\u003e\n\n\n\n// 접근성을 위해 ARIA 속성을 사용하세요\n\u003cbutton aria-label=\"제출\"\u003e제출\u003c/button\u003e\n\n추가 자료\n\n- MDN Web Docs: JavaScript 문서 및 튜토리얼에 대한 포괄적인 자료\n- W3Schools: 웹 개발 튜토리얼 및 참고 자료가 있는 인기 있는 웹사이트\n- JavaScript Subreddit: JavaScript와 웹 개발에 대한 토론을 하는 커뮤니티 주도 포럼\n- Udemy 및 Coursera 강좌: JavaScript와 웹 개발 학습을 위한 온라인 강좌 및 튜토리얼\n\n# 결론\n\n\n\n\n자바스크립트의 기본을 완벽히 이해하는 것은 견고하고 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 구축하는 데 중요합니다. 이 블로그 포스트에서 다루는 주요 주제를 이해하면 더 고급 개념과 React, Angular, Vue.js와 같은 프레임워크에 대처할 준비가됩니다. 유능한 자바스크립트 개발자로 발전하기 위해 연습하고 실험하며 계속 학습해야합니다. 즐겨 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트의 비밀 병기를 발휘하라 StrictMode","description":"","date":"2024-05-14 12:17","slug":"2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode","content":"\n\n![StrictMode image](/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png)\n\nStrictMode는 당신이 그녀/그를 듣고 싶지 않더라도 진실을 말해주는 진짜 친구입니다. React 개발자들이 더 나은 방식으로 앱을 작성할 수 있도록 도와주는 도구로, 앱을 개발하는 과정에서 가능한 버그를 알려줍니다. 이는 개인용 들여쓰기 보조견과 같아요!\n\n# StrictMode에 관심을 가져야 하는 이유\n\nReact 개발자에게 StrictMode가 중요한 이유는 여러 가지가 있습니다:\n\n\n\n- 위험한 코드 식별: StrictMode를 사용하면 Android 문자열 ref API 사용이나 원치 않는 부작용과 같은 실행중 오류로 나타날 수 있는 문제를 잡을 수 있습니다.\n- 미래를 준비: StrictMode는 컴포넌트가 최신 React 버전 (그리고 동시 렌더링 같은 특징을 포함하는)과 완벽하게 작동하는 것을 보장합니다.\n- 성능 향상: StrictMode가 비효율적인 코드에 주목할 때, 응용 프로그램의 성능을 향상시키는 방법을 도와줍니다.\n\n# StrictMode의 주요 기능\n\nStrictMode는 더 깨끗하고 효율적인 React 코드를 작성하는 데 도움이 되는 여러 가지 확인 사항을 제공합니다:\n\n- 안전하지 않은 라이프사이클 식별: StrictMode는 componentWillMount, componentWillReceiveProps, componentWillUpdate 같은 고전 라이프사이클 방법을 사용하는 경우 동시 렌더링에서 불규칙성을 가져올 수 있는 경고를 표시합니다.\n- 레거시 문자열 ref API 사용에 대한 경고: 문자열 ref는 사용이 불필요하며 컴포넌트가 내부로 누출될 수 있습니다. StrictMode는 여전히 사용 중인 경우에 경고를 표시하여 콜백 기반 ref API로 전환하도록 장려합니다.\n- 예상치 못한 부작용 감지: StrictMode는 부작용을 나타내는 함수를 공개하고, 이는 불안정성, 성능 문제 및 더 어려운 추론을 초래할 수 있습니다.\n- 컨텍스트 API 호환성 보장: StrictMode는 응용 프로그램이 동시 렌더링을 허용하는 방식으로 컨텍스트 API를 사용하는지를 검증합니다.\n\n\n\n# 애플리케이션에 StrictMode 사용하기\n\nReact 애플리케이션에 StrictMode를 추가하는 것은 매우 쉽습니다. 확인하려는 컴포넌트를 `StrictMode` 컴포넌트로 감싸기만 하면 됩니다:\n\n```js\nimport React from 'react';\n\nfunction MyComponent() {\n  // ... 여러분의 컴포넌트 코드 ...\n}\n\nfunction App() {\n  return (\n    \u003cStrictMode\u003e\n      \u003cMyComponent /\u003e\n    \u003c/StrictMode\u003e\n  );\n}\n```\n\nStrictMode는 개발 도구일 뿐입니다. 프로덕션 빌드에 영향을 미치지 않습니다. 프로세스 초기에 문제가 있는 부분을 미리 발견하고 사용자에게 영향을 주지 않고 변경할 수 있도록 도와줍니다.\n\n\n\n# StrictMode의 현실 세계에서 얻는 이점\n\n저는 거대한 React 애플리케이션을 작업하는 세 명의 팀 중 한 명이었을 때 이상한 렌더링 버그로 골머리를 앓고 있었습니다. 마음이 놓여지지 않아 제 남은 머리카락을 뽑았지만, 우리 모듈을 StrictMode 명령어로 감싸보기로 결정했습니다. 놀라운 일에, 많은 결함을 즉시 가리켰는데, 그 중에는 위험한 라이프사이클 메소드를 사용하는 문제와 부작용이 있었습니다.\n\n우리는 이러한 문제에 신속히 대응할 수 있었고, 이로써 우리의 애플리케이션을 더 안정적이고 효율적으로 만들었습니다. 의심의 여지 없이, Android StrictMode는 우리 코드에 건강 진단을 해준 것이었습니다!\n\n# 결론: StrictMode 이점을 온전히 받아들이세요\n\n\n\nStrictMode는 모든 리액트 개발자가 코드 품질을 향상시키면서 더 능숙해지도록 도와주는 도구입니다. 어쩌면 조금 엄격한 친구처럼 느껴질 수 있지만 제공되는 사실들은 최상이며 가장 소중합니다. 그러므로 StrictMode에 대해 더 깊이 배우고, 리액트 코딩 경험을 한 단계 높여줄 가능성을 지켜보는 것을 꺼리지 마세요!\n\n# 콜 투 액션: 오늘부터 StrictMode 사용하기!\n\nStrictMode 도구를 귀하의 리액트 애플리케이션에 추가해 주시기 바랍니다. 게다가, 이와 같은 도구는 해당 문제와 코드에 미칠 긍정적인 영향에 대해 귀하를 놀라게 할 수도 있습니다. 약간의 엄격함은 리액트 개발 현상에서 중요하다는 말을 기억하세요.","ogImage":{"url":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png"},"coverImage":"/assets/img/2024-05-14-UnleashthePowerofReactsSecretWeaponStrictMode_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 컴포넌트 라이프사이클 메서드","description":"","date":"2024-05-14 12:16","slug":"2024-05-14-ReactComponentLifecycleMethods","content":"\n\n![React Component Lifecycle Methods](/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png)\n\n프론트엔드 개발에서 React는 사용자 인터페이스를 구축하기 위한 가장 인기 있는 JavaScript 라이브러리 중 하나입니다. React가 강력한 이유 중 하나는 구성 요소 기반 아키텍처입니다. React 구성 요소가 라이프사이클 동안 어떻게 작동하는지 이해하는 것은 효율적인 애플리케이션을 구축하는 데 중요합니다.\n\n# React 구성 요소 라이프사이클 메서드란?\n\nReact 구성 요소는 초기화부터 파괴까지 라이프사이클 동안 다양한 단계를 거칩니다. React는 마운팅, 업데이팅 및 언마운팅 세 가지 단계로 분류할 수 있는 빌트인 메서드 집합인 라이프사이클 메서드를 제공합니다. 이 메서드를 사용하면 개발자는 이러한 단계에 훅을 걸어 작업을 수행할 수 있습니다.\n\n\n\n# 마운팅 단계:\n\n— constructor(): 이 메서드는 컴포넌트가 초기화될 때 호출됩니다. 상태를 초기화하고 이벤트 핸들러를 바인딩하는 데 사용됩니다.\n— render(): 이는 컴포넌트 UI의 JSX 표현을 반환하는 필수적인 메서드입니다. 컴포넌트가 다시 렌더링되어야 할 때마다 호출됩니다.\n— componentDidMount(): 컴포넌트가 마운트된 직후에 즉시 호출됩니다. 데이터 가져오기, 구독, 또는 제3자 라이브러리 초기화와 같은 부작용을 수행하는 데 자주 사용됩니다.\n\n# 업데이트 단계:\n\n— static getDerivedStateFromProps(): 이 메서드는 새로운 속성이 수신될 때 렌더링하기 바로 전에 호출됩니다. 속성 변경에 따라 상태를 업데이트할 수 있도록 합니다.\n— shouldComponentUpdate(): 이 메서드는 컴포넌트가 다시 렌더링해야 할지 여부를 결정합니다. 불필요한 다시 렌더링을 방지하여 성능을 최적화하는 데 사용됩니다.\n— render(): 업데이트된 상태나 속성으로 컴포넌트를 다시 렌더링합니다.\n— getSnapshotBeforeUpdate(): 가상 DOM의 변경이 실제 DOM에 반영되기 전 바로 호출됩니다. 업데이트 전에 일부 정보(예: 스크롤 위치)를 캡처할 수 있습니다.\n— componentDidUpdate(): 컴포넌트의 업데이트가 DOM으로 플러시된 후에 호출됩니다. 업데이트 이후에 업데이트된 데이터 가져오기 또는 업데이트 후 DOM과 상호 작용하는 등 부작용 수행에 자주 사용됩니다.\n\n\n\n# Unmounting Phase:\n\n— `componentWillUnmount()`: 컴포넌트가 언마운트되고 파괴되기 직전에 즉시 호출됩니다. 이는 이벤트 리스너 제거 또는 네트워크 요청 취소와 같은 정리 작업에 사용됩니다.\n\n라이프사이클 메소드 이해하기: \n각 라이프사이클 메소드는 특정 목적을 위해 제공되며, 개발자가 컴포넌트의 라이프사이클의 다른 단계에 훅을 걸고 그에 따라 작업을 수행할 수 있게 합니다.\n\n# 최상의 실천 방법:\n\n\n\n- 라이프사이클 메서드를 적게 사용하세요: React Hooks가 소개되면서 라이프사이클 메서드 대부분은 레거시로 간주되어 `useEffect`와 같은 Hooks를 선호하는 방식으로 대체되고 있습니다.\n- `render()`에서 부작용을 피하세요: `render()` 메서드는 순수해야 하며 부작용을 발생시키지 말아야 합니다. 부작용은 `componentDidMount()`나 함수형 컴포넌트의 `useEffect()`에서 수행되어야 합니다.\n- 성능에 유의하세요: `shouldComponentUpdate()`나 `React.memo()`를 사용하여 불필요한 다시 렌더링을 방지하여 컴포넌트 성능을 최적화하세요.\n- 자원 정리: 항상 `componentWillUnmount()`나 `useEffect()` 정리 함수에서 이벤트 리스너 제거 또는 구독 취소와 같은 정리 작업을 수행하세요.\n\n# 결론:\n\nReact 컴포넌트 라이프사이클 메서드를 이해하는 것은 확장 가능하고 효율적인 애플리케이션을 구축하는 데 중요합니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLifecycleMethods_0.png","tag":["Tech"],"readingTime":3},{"title":"갇혀 있는 극악무도한 보안의 심연으로부터","description":"","date":"2024-05-14 12:15","slug":"2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity","content":"\n\nChapter three\n\n![Locked away from the depths of maximum security](/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png)\n\n금속 잠금장치가 동기화되어 열리는 소리가 복도를 통과하던 중, 트로이는 셀의 구금에서 벗어난다. 낮 시간이라 불리는 이 방 안에는 각각 여덟 개의 의자가 놓인 네 개의 탁자와 그 위에 위험하게 걸린 작은 32인치 TV가 있었다. 이것은 그들의 수감 상황을 뚜렷하게 상기시키는 것이었다. 수감자들이 셀에서 나와 공동 샤워, 카드 게임, 체스 대결 및 혼자만의 독서를 위한 필수품을 가지고 나왔다.\n\n그에게 다가온 것은 트로이가 그 유닛의 권위자로 가정했던 수감자였다. 5피트 9인치의 자신과 비슷한 키에 밝은 피부와 풍만한 체격을 가진 그 남자는 자신의 총명한 눈이 트로이의 눈을 뚫어봤다. 그는 “절차 알지? 정원에 있거나 짐 싸\"라고 권위적으로 말했다. 트로이는 ‘정원’이라는 말이 가지고 있는 함의를 이해했고, 이는 동맹원들이 구성원들에 대한 기록을 유지하는 시스템으로, 충돌 발생 시 중요하다. “자가 통치 선택권이 있어,\" 트로이가 반박했다.\n\n\n\n사람은 트로이의 억양을 무시하며, 최대한의 단위에서는 그와 같은 선택지가 없다고 설명했습니다. 트로이는 잠시 고민한 뒤 결과를 따져 보았습니다. '물러나다'는 자신을 드러내어 보호자가 되었지만 보복에 취약하게 남게 될 것이었습니다. 보호 관찰은 선택지가 아니었습니다. 그래서 마침내, 그는 설립된 기관들과 조인하기로 선택했습니다. 사람은 자신을 프리모로 소개했습니다. 트로이는 자신의 혐의를 폄하했습니다. 폭력사건 중에서도 어울리지 않는 약물 범행의 나열이었습니다. 프리모는 안심시켜 주며, 다른 구금구역으로의 이송을 약속했고, 그것은 트로이의 불안을 일시적으로 완화시켰습니다.\n\n그러나 폭력적인 범죄자들과 함께 한 유닛을 공유해야 한다는 현실은 트로이에게 큰 부담이었습니다. 다른 수감자들에게 다가올 때, 그는 조심스럽게 경계를 지키며 잠재적인 위협에 대해 예민하게 인식했습니다. TV의 깜박이는 빛 앞에 서있을 때, 트로이는 가족 - 어머니, 일곱 형제자매, 당시의 여자친구에 대한 생각으로 빛난 것에 주목했습니다. 외부 세계와의 연결 통로인 전화는 절망적인 전화를 위한 자금이 부족하여 조용했습니다.\n\n빅 에이가 제공한 수건, 비누, 식사화로 트로이는 지친 신체를 풀며 수영장으로 향했습니다. 재순환된 공기와 머무른 땀의 쇠약한 향기에 감싸여. 하루의 노엽을 씻어내는 고독 속에서, 트로이의 마음은 대립하는 생각과 달려 있는 것으로 뒹굴었습니다. 그를 둘러쌓은 피부에 남아 있는 늙은 먼지의 익숙한 냄새는, 그의 처지 - 사생활의 부재, 결정의 무게, 그리고 반복되는 감금에 대한 가족의 감정의 불확실함을 생생히 상기시켰습니다.\n\n트로이가 지친 몸에 쏟아지는 뜨거운 물과 함께, 그의 생각은 더욱 조각난 것처럼 더 혼란스러워졌습니다. 각각의 물방울은 그의 의심과 두려움을 메아리하며, 옥상을 흐르는 목소리와 금속의 딩동 소리와 섞였습니다. 트로이는 침착을 유지하려고 애썼지만, 그를 꺾어버릴 듯한 불안감의 끈 같은 감정이 그를 잡아채는 것을 흔들릴 수 없었습니다.\n\n\n\n한 시간 반이 지났지만, 갇힌 삶의 답답한 반복 속에서는 영원히 느껴졌다. 시간은 흘러가고, 트로이는 방향감소와 외부 세계에 대한 그리움을 느끼게 되었다. 다른 죄수들이 다시 감방으로 후퇴하는 것을 지켜보면서, 그는 지역 감옥 벽 안에서 시간이 무자비하게 흘러가는 것에 절망적인 감정을 억누를 수 없었다.","ogImage":{"url":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png"},"coverImage":"/assets/img/2024-05-14-LockedAwayFromtheDepthsofMaximumSecurity_0.png","tag":["Tech"],"readingTime":2},{"title":"React Js 설치 방법 완전 초보자용","description":"","date":"2024-05-14 12:14","slug":"2024-05-14-HowToInstallReactJsForcompletebeginners","content":"\n\n\n![React installation](/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png)\n\n요즘 리액트를 배우는 데 흥미를 느끼고 있고 리액트를 시작했습니다. 이 강력한 JavaScript 프레임워크를 사용하는 첫 번째 단계는 무엇일까요? React를 설치하기 전에 먼저 Node를 설치해야 합니다. 프로세스는 node 웹 사이트를 방문하고 최신 지원 버전을 다운로드하는 것만큼 간단합니다. Node가 필요한 이유가 궁금하다면, Node.js는 서버 측에서 JavaScript를 실행할 수 있는 JavaScript 런타임 환경입니다 (나중에 이에 대한 자세한 기사를 쓸 것입니다). 그 후 명령줄로 이동하여 명령줄이 익숙하지 않은 경우를 대비해 검색할 수 있습니다. React를 설치하는 방법에는 여러 가지가 있습니다:\n\na) CDN 사용 (가장 쉬운 방법)\n\n이 코드 조각을 html 코드의 head 부분에 포함하세요.\n\n\n\n\n```js\n\u003cscript crossorigin src=\"https://unpkg.com/react@18/umd/react.development.js\"\u003e\u003c/script\u003e\n\u003cscript crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"\u003e\u003c/script\u003e\n```\n\n이것은 쉽지만 제품 환경보다는 개발 환경에 권장됩니다. 학습을 시작할 때만 사용하는 것이 좋습니다.\n\na) Vite를 사용하는 방법\n\n명령줄에 다음과 같이 입력하세요: npm create vite@latest app_name — — template react. 그리고 npm install을 실행하고 코드를 행복하게 작성하세요. 이 방법의 장점은 vite가 다양한 기능을 갖추고 빠르며 서버를 빠르게 실행한다는 것입니다.\n\n\n\nb) 이전 React 방식을 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-react-app 앱-이름. 그리고 나서 코딩을 즐기세요. 이 방법은 vite와 같은 다른 방법보다 서버를 빨리 구동하는 것에 비해 느릴 수 있습니다.\n\nc) Next.js 프레임워크를 사용하는 방법\n\n명령줄에 다음을 입력하세요: npx create-next-app@latest 질문에 답하고 설치하세요. 다만, TypeScript/JavaScript, React, 그리고 tailwind CSS에 대한 선행 지식이 필요합니다.\n\n\n\n기존 프로젝트에서는 npm install react react-dom을 사용하여 프로젝트에 React를 추가할 수 있어요. Gatsby, remix와 같은 다양한 프레임워크도 설치할 수 있어요. 더 많은 정보를 원하시면 직접 찾아보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png"},"coverImage":"/assets/img/2024-05-14-HowToInstallReactJsForcompletebeginners_0.png","tag":["Tech"],"readingTime":2}],"page":"110","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"110"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>