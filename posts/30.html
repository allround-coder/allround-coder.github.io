<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/30" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/30" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 " href="/post/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법" href="/post/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="거북이와 토끼의 이야기 승리의 비결은 무엇일까" href="/post/2024-06-22-thetaleoftortoiseandhare"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="거북이와 토끼의 이야기 승리의 비결은 무엇일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="거북이와 토끼의 이야기 승리의 비결은 무엇일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">거북이와 토끼의 이야기 승리의 비결은 무엇일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법" href="/post/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까" href="/post/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법" href="/post/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="adamant-api v240 출시 v200 이후 달라진 점은" href="/post/2024-06-22-adamant-apiv240isoutWhatschangedsincev200"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="adamant-api v240 출시 v200 이후 달라진 점은" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="adamant-api v240 출시 v200 이후 달라진 점은" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">adamant-api v240 출시 v200 이후 달라진 점은</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" href="/post/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" href="/post/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" href="/post/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link posts_-active__YVJEi" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Web Workers 자바스크립트 멀티스레딩 잠재력 해방하기 ","description":"","date":"2024-06-22 02:05","slug":"2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png\" /\u003e\n\nJavaScript은 초기에 Brendan Eich에 의해 고안된대로 시작되어 웹 페이지 내 간단한 동적 기능을 위해 설계된 간결한 스크립팅 언어로 출발했습니다. JavaScript는 오늘날의 웹 애플리케이션에서 볼 수 있는 복잡성을 다루기 위해 만들어진 것이 아니었습니다. 이것이 JavaScript가 단일 스레드 언어로 구축된 이유입니다. 동시에 다중 스레드가 동일한 DOM 요소를 동시에 사용하려고 한다면 어떤 혼란이 벌어질지 상상해보세요! 🤯\n\n# 단일 스레드 현실\n\n단일 스레드는 JavaScript의 핵심입니다. 브라우저는 JavaScript 이벤트를 한 번에 하나씩 처리할 수 있도록 설계되었습니다. 이에는 중요한 영향이 몇 가지 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 동시 실행 불가: JavaScript가 실행 중일 때 이벤트 핸들러나 타이머와 같은 다른 작업은 차례를 기다립니다.\n- 반응성이 중요합니다: 오랫동안 실행되는 JavaScript 함수는 브라우저를 멈출 수 있어 사용자 경험이 불편해질 수 있습니다.\n\n이것이 바로 현대의 fetch()와 같은 비동기 API가 만들어진 이유입니다 - 메인 스레드를 막힘 없이 유지하기 위해서!\n\n# 웹 워커로 진입 💪\n\n웹 앱이 더 복잡해지고 데이터 조작 및 복잡한 논리 처리를 위해 더 많은 처리 능력을 요구함에 따라 JavaScript의 단일 스레드 모델의 한계가 드러납니다. 이때 웹 워커가 구원에 나서는 것입니다. 🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커는 HTML5 사양의 일부로 실제로 오랫동안 사용되어 왔습니다! 이 개념은 2009년에 처음 제안되었습니다. 웹 워커를 사용하면 백그라운드 스레드에서 스크립트를 실행할 수 있어서 주 웹페이지의 스레드와 독립적으로 작동합니다. 이는 더 부드러운 성능과 더 만족스러운 사용자 경험을 제공합니다. 😃\n\n# 웹 워커의 종류\n\n웹 워커에는 세 가지 주요 유형이 있습니다:\n\n- 전용 워커(Dedicated Workers): 이 워커는 생성된 특정 스크립트에 연결됩니다. 즉, 일대일 관계입니다.\n- 공유 워커(Shared Workers): 이름에서 알 수 있듯이, 이 워커는 동일한 도메인에 속하는 여러 창 또는 아이프레임에서 실행되는 여러 스크립트에서 공유할 수 있습니다.\n- 서비스 워커(Service Workers): 이 특별한 워커는 웹 앱, 브라우저, 네트워크 사이에 위치하여 프록시처럼 동작합니다. 이를 통해 견고한 오프라인 경험을 구축하고, 네트워크 요청을 가로채는 기능과 푸시 알림과 같은 기능을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 워커 사용하기: 간단한 예제\n\n기본 예제를 살펴보겠습니다:\n\n메인 스레드:\n\n```js\nconst worker = new Worker(\"/worker.js\");\n\nworker.onmessage = (e) =\u003e {\n  console.log(e.data); // 출력: \"안녕, 주인님!\"\n};\nworker.postMessage(\"안녕하세요, 워커!\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워커 스레드(worker.js):\n\n```js\nself.onmessage = (e) =\u003e {\n  console.log(e.data); // 출력: \"안녕, 워커!\" \n  self.postMessage(\"안녕하세요, 마스터!\");\n};\n```\n\n# 웹 워커 생성\n\n웹 워커를 생성하는 것은 간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst worker = new Worker(aURL, options);\n```\n\n위의 코드를 보겠습니다:\n\n- aURL: 워커가 실행할 JavaScript 파일의 경로입니다. 중요한 점은, 워커 스크립트가 메인 웹페이지와 동일한 도메인에 호스팅되어야 한다는 동일 출처 정책을 따라야 합니다.\n- options (옵션): 이 인자를 사용하여 워커의 몇 가지 측면을 사용자 정의할 수 있습니다.\n\n# 웹 워커를 이용한 오류 처리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커는 두 가지 유용한 오류 처리 이벤트를 제공합니다:\n\n- error: 워커 내에서 오류가 발생했을 때 트리거됩니다.\n- messageerror: 이 이벤트는 워커가 올바르게 역직렬화할 수 없는 메시지를 수신했을 때 발생합니다.\n\n![웹 워커 이미지](/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_1.png)\n\n# 스레드 간 데이터 교환: 평범하지 않은 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript의 Web Workers는 스레드 간 데이터 교환을 용이하게 하는 간단한 메커니즘을 사용합니다:\n\n- 구조화된 복제 알고리즘: 이것은 기본 및 가장 호환성 있는 방법입니다. 객체의 깊은 복사본을 안전하게 공유할 수 있는 견고한 방법입니다.\n- 전송 가능한 객체: 최적의 성능을 요구하는 시나리오에서는 전송 가능한 객체를 사용하는 것이 좋습니다. 이들은 ArrayBuffers와 같은 특정 데이터 유형의 소유권 이전을 가능하게 하여, 불필요한 복사를 없애줍니다.\n- SharedArrayBuffer: 이것은 스레드 간의 진정한 공유 메모리를 활성화합니다. 동시 액세스와 수정을 허용하며, 그러나 경쟁 조건을 방지하고 데이터 무결성을 보장하기 위해 추가적인 주의가 필요합니다.\n\n![이미지](/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_2.png)\n\n# 실용적인 응용: 웹 워커의 작동 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커는 이런 경우에 빛을 발합니다:\n\n- CPU 집약적 작업: 데이터 처리, 이미지 조작 또는 암호화와 같은 작업을 워커에 넘겨서 메인 UI 스레드를 반응성 있게 유지하세요.\n- 비동기 작업: 데이터 가져오기 또는 기타 비동기 작업을 처리할 때, 웹 워커는 이러한 작업이 사용자 인터페이스의 원할한 흐름을 방해하지 않도록 합니다.\n\n# 웹 워커를 사용해야 할 때 (그리고 사용하지 말아야 할 때)\n\n웹 워커는 강력하지만 항상 필요한 것은 아닙니다. 간단하고 단기적인 작업의 경우에는, 웹 워커를 사용하면 오히려 불필요한 작업부하가 생길 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 몇 가지 지침입니다:\n\n- 장기적인 워커: 워커를 자주 생성하고 파괴하는 대신, 작업 스트림을 처리하는 지속적인 워커를 만드는 것이 좋습니다.\n- 스레드 관리: 과도한 워커 생성은 시스템 자원을 과도하게 소모할 수 있습니다. 최적의 성능을 위해 활성 워커 수를 신중하게 고려해야 합니다.\n\n# 결론: 웹 워커, 귀하의 아뮬렛에 담긴 강력한 도구\n\n웹 워커는 JavaScript 개발자 툴킷에 중요한 요소로, 고성능 및 응답성이 뛰어난 웹 응용 프로그램을 구축할 수 있도록 도와줍니다. 이들의 능력과 한계를 이해함으로써, 브라우저에서 멀티스레딩의 참 꽃을 펼칠 수 있습니다. 즐거운 코딩하세요! 😄\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 평문으로 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 👏 둘썽 박수를 치고 작성자를 팔로우하세요!\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼도 방문해보세요: CoFeed | Differ\n- PlainEnglish.io 에서 더 많은 콘텐츠를 확인하세요.","ogImage":{"url":"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png"},"coverImage":"/assets/img/2024-06-22-WebWorkersUnlockingJavaScriptsMultithreadingPotential_0.png","tag":["Tech"],"readingTime":4},{"title":"고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법","description":"","date":"2024-06-22 02:03","slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree","content":"\n\n## 최적화에 실패한 보통의 데이터 구조\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png)\n\n가끔 데이터 구조는 직접적이고 매우 실용적인 사용 사례를 가지고 있어 누군가 그것을 고안할 만한 이유를 이해할 수 있습니다.\n\n그런데 항상 그렇지만은 않습니다. 때로는 데이터 구조가 그저 어떤 이점이나 성능 향상을 제공하기 위해 존재하는 경우도 있습니다. 항상 사용하실 건가요? 아마도 그렇지 않을 것입니다. 하지만 실제로 유용하게 사용할 때 알아 두어서 기뻐할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 BIT 또는 다른 말로 이진 인덱스 트리에 대해 이야기하고 싶어요. 이 데이터 구조는 검색 및 삽입을 최적화하려고 노력하지만 그것을 실패하는 특징을 가지고 있어요.\n\n# BITs 뒤에 숨겨진 의도\n\nBITs를 \"보통인 데이터 구조\"라고 부르고 싶어요. 다른 데이터 구조들이 트리에서 삽입 또는 읽기 연산 중 하나를 최적화하려고 하는데 그 결과를 O(1)로 만들고 다른 하나는 O(n)으로 놓는 것에 집중하는 반면, BITs는 두 가지 모두를 개선하려고 해요.\n\n그런데 트리에 삽입하고 읽기를 상수 시간 안에 수행하는 것은 불가능하기 때문에, 이 구조체가 시도하는 것에 실패한다고 말하는 건 정말 그렇게 생각해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말이 그렇게 되면, 실제로 BITs는 O(Log n) 성능으로 데이터를 삽입하고 읽을 수 있게 해줍니다. 대단하지도 않고 최악도 아니라서, 그러니까 그냥 보통 정도입니다.\n\n농담은 그만두고, BITs를 사용하면 트리를 쿼리하고 업데이트하는 데 합리적인 성능을 제공합니다. 따라서 트리 모양의 구조물을 다루고 논리가 그것에 많은 읽기 및 쓰기를 수행하는 경우, 이것이 당신에게 적합한 데이터 구조일 수 있습니다.\n\n이 데이터 구조의 주요 사용 사례는 배열 내 요소들의 효율적인 접두사 합계(즉, n번째까지의 모든 요소의 합)를 가질 수 있는 능력입니다. 이것은 산술 코딩을 사용할 때 편리하다고 합니다. 그러나 우리는 지금 그 무한한 토끼굴에 들어가지 않겠습니다.\n\n# JavaScript에서 이진 색인 트리 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드를 구현할 때, 예상과는 다르게 할 것입니다. 클래스로 트리 구조를 구현하는 대신, 이 구조를 배열로 나타내고 트래버스하는 방법으로 이해할 수 있도록 특수한 비트 연산을 사용할 것입니다.\n\n두 가지 작업에 초점을 맞출 것입니다: 업데이트와 특정 위치까지의 합을 얻는 것입니다.\n\n업데이트 작업은 주어진 값을 원하는 위치에 추가하고, 또한 구조를 트래버스하여 모든 하위 항목을 업데이트 할 것입니다.\n\n\"getSum\" 작업은 원하는 노드까지의 서브트리의 합을 반환할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## BIT 생성하기\n\n처음 다룰 주제는 어떻게 만드는 지입니다. 앞서 말했듯이 배열로 표현하고, 현재 인덱스의 마지막 설정 비트를 계산하여 이동하며, 트리를 탐색할 때 이를 추가하거나 제거합니다.\n\n먼저, BIT를 초기 생성할 때는 아래로 이동하므로, 마지막 설정된 비트를 추가합니다.\n\n초기에 BIT 배열은 모두 0으로 설정되어 있고, 우리는 원본 값의 배열을 지나가며 이 논리를 따릅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 첫 번째 인덱스(이 경우에는 0)부터 시작합니다.\n- 인덱스에 1을 추가합니다(BIT 배열은 초기 요소가 비어 있는 상태입니다).\n- 현재 인덱스의 배열 값과 BIT 배열 내의 새 위치에 값을 추가합니다.\n- 인덱스의 마지막으로 설정된 비트(즉, 1)을 가져와 인덱스에 추가하여 2로 바꿉니다.\n- 단계 1로 돌아갑니다.\n\n시작할 배열이 다음과 같다고 가정해 봅시다: [2, 1, 1, 3, 2, 3], 그리고 BIT에 접두사 합을 저장하려고 할 때:\n\n- 인덱스 0에서 2의 값을 얻습니다.\n- BIT 배열에 가서 1을 추가하여 BIT 인덱스를 1로 만듭니다.\n- BIT 배열의 위치 1에 있는 값에 2를 추가하여 2로 만듭니다.\n- 1의 마지막 설정된 비트인 1을 가져와 BIT 인덱스에 추가하여 2로 만듭니다.\n- BIT 배열의 인덱스 2에서는 다시 2를 추가하여 2가 됩니다.\n- 2의 마지막 설정된 비트(10)는 2이므로 BIT 인덱스 4로 이동합니다.\n- BIT 인덱스 4에 2를 추가하여 마찬가지로 2가 됩니다.\n- 4의 마지막 설정된 비트(100)도 4이므로 존재하지 않는 8로 이동하게 되고 여기서 종료됩니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 2, 0, 2, 0, 0]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 우리는 원래 배열의 첫 번째 2개만 추가했습니다. 이제 우리 배열의 두 번째 요소에도 같은 작업을 수행합니다(위치 1):\n\n- 원래 인덱스 1은 BIT 인덱스 2를 의미합니다(시작 시 인덱스에 1을 추가하는 것을 기억하세요).\n- 우리는 BITArray[2]의 값에 1을 추가하여 3으로 만듭니다.\n- 2가 4로 변하기 때문에 BIT 배열의 4번째 위치에 1을 추가하여 또한 3으로 만듭니다.\n- 그리고 이제 4가 8로 변하면서 다시 범위를 벗어나게 되므로 여기서 멈춥니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 3, 0, 3, 0, 0]\n\n그리고 계속 진행하면 다음과 같은 결과를 얻게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nIdx — BIT 배열\n0 — [0, 0, 0, 0, 0, 0, 0] - 초기 상태\n1 — [0, 2, 2, 0, 2, 0, 0] - 첫 번째 반복\n2 — [0, 2, 3, 0, 3, 0, 0] - 두 번째 반복 (위에서 설명한대로)\n3 — [0, 2, 3, 1, 4, 0, 0]\n4 — [0, 2, 3, 1, 7, 0, 0]\n5 — [0, 2, 3, 1, 7, 2, 2]\n6 — [0, 2, 3, 1, 7, 2, 5]\r\n```\n\n모든 값을 BIT 배열에 추가한 후에는 [0, 2, 3, 1, 7, 2, 5]가 됩니다.\n\n이해를 돕기 위해 다음과 같이 구현을 살펴보겠습니다:\n\nconstructBITree 함수는 배열을 초기화하고 각 값에 대해 업데이트하는 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 배열이 설정되면, 원하는 색인까지의 접두사 합을 요청할 수 있는 쿼리를 시작할 수 있습니다.\n\n## 트리 쿼리\n\n트리를 쿼리하는 것은 이전과 유사한 접근 방식을 따릅니다만, 역으로 진행됩니다.\n\n인덱스 0 대신 우리가 찾고 있는 인덱스에서 (물론 1을 더한 값으로) 시작하고, 해당 인덱스의 마지막 비트를 제거하여 0 또는 그 이하로 이동하면서 트리를 \"위로\" 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 BIT 배열 [0, 2, 3, 1, 7, 2, 5]에서 트리에 쿼리하여 5번째 요소의 접두사 합을 얻고 싶다고 합시다. 물론, 이는 원래 배열의 모든 값을 더하는 것과 동일하다는 것을 의미합니다 (6개의 값이 있음).\n\n- 이제, 인덱스 5에서 시작하지만 1을 추가하여 6이 되었습니다.\n- BIT 배열의 6번째 인덱스의 값은 5입니다.\n- 이제, 인덱스의 마지막 설정된 비트 (6이며 2진법으로 110입니다)를 빼서 4로 만듭니다.\n- 우리의 BIT 배열에서 4번째 인덱스의 값은 7이므로 5에 추가하여 약 12가 됩니다.\n- 4의 마지막 설정된 비트는 4이므로, 빼서 0이 됩니다.\n- 끝났습니다.\n\n원래 배열을 모두 순회하여 모든 숫자를 더하는 대신, 우리는 BIT 배열에서 2개의 값을 필요로 했습니다. 이 변경으로 O(n)을 O(Log2(n)) 알고리즘으로 변환했습니다. 꽤 멋지죠?!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 구현을 살펴봅시다:\n\n이것은 간단한 구현입니다. 핵심은 8번 라인이며, 여기서 현재 인덱스에서 마지막으로 설정된 비트를 뺍니다. 여기서 모든 마법이 벌어집니다.\n\n읽어주셨나요? IT 산업에서 2 십년의 지혜를 무료로 공유하는 제 뉴스레터를 구독해보세요. \"늙은 개발자의 헛소리\"에 가입하세요!\n\n이진 색인 트리는 그 뒤의 논리를 이해하면 매우 멋집니다. 첫 시도에서 이해하기 어려워 해도 걱정하지 마세요. \"이해하는 데 오랜 시간이 걸렸어요\". 중간값을 저장된 배열에서 확인하고 위에 보여준 단계를 따라 가는 것이 내 추천입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBITs를 사용해 보신 적이 있나요? 그것으로 무엇을 하셨나요? 이 데이터 구조의 실제 구현에 대해 알고 싶어요! 그러니까 의견란에 공유해 주세요!\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 구축하기\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_1.png)\n\nBit의 오픈소스 도구는 25만 명 이상의 개발자가 구성 요소로 앱을 만드는 데 도와주고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업하기가 더 쉽고 빠르게 빌드할 수 있어요.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 저장소\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png","tag":["Tech"],"readingTime":5},{"title":"거북이와 토끼의 이야기 승리의 비결은 무엇일까","description":"","date":"2024-06-22 02:02","slug":"2024-06-22-thetaleoftortoiseandhare","content":"\n\n# 소개\n\n거북이와 토끼 알고리즘 또는 플로이드의 순환 감지 알고리즘은 연결 리스트의 경우에 매우 일반적으로 사용되는 알고리즘입니다. 이는 기초 역학 법칙과 직관에 기반을 둔 것입니다. 본문은 본 알고리즘에 대해 간단히 설명하고, 이 마법 같은 알고리즘에 대해 모두에게 알려주려고 합니다.\n\n# 직관\n\n우리에게 루프가 있는 연결 리스트가 있다고 가정해 봅시다. 만약 여러분이 연결 리스트의 루프가 무엇인지 모르는 경우, 마지막 노드가 리스트의 중간 노드를 자신의 노드로 가지고 있는 경우를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 무한 루프를 만들어버리네요!!!\n\n![image](/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png)\n\n하지만 어떻게 해결할 수 있을까요?\n\n한 순간 동안 이 문제를 내버려두고 다른 영역으로 들어가볼까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고속과 저속(토끼와 거북이) 두 개의 포인터를 만들어서 거북이와 토끼를 반영하겠습니다. 빠른 포인터는 2의 속도(반복당 두 노드)로 이동하고, 느린 포인터는 1의 속도(반복당 한 노드)로 이동합니다. 두 포인터가 만난다면 이는 반복이 있음을 의미합니다.\n\n하지만 이 두 포인터가 어떻게 만나게 되는지 아십니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 수학적 증명\n\n알고리즘이 왜 동작하는지 자세히 살펴보겠습니다.\n\n지금 우리는 느린 포인터와 빠른 포인터가 서로 다른 시간에 루프에 들어간다는 것을 알고 있습니다. 느린 포인터는 속도가 1이므로 각 반복에서 링크를 한 번씩만 건너뜁니다. 빠른 포인터는 속도가 2입니다. 따라서 매 반복마다 빠른 포인터는 1단계씩 느린 포인터에 접근하게 되고, 루프에 들어갈 때 느린 포인터와 빠른 포인터 사이의 거리는 항상 1로 나눌 수 있으므로, 빠른 포인터는 한 번의 루프 이내에 느린 포인터를 잡아내게 됩니다.\n\n또 다른 방식으로 생각해 보실 수도 있습니다. 느린 포인터가 한 위치에 갇혀 있고 전체 링크드 리스트가 속도 1로 움직인다고 상상해 보십시오. 이것은 빠른 포인터가 느린 포인터에 대해 매 반복에서 노드 1개씩만 움직인다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지 1](/assets/img/2024-06-22-thetaleoftortoiseandhare_2.png)\n\n![이미지 2](/assets/img/2024-06-22-thetaleoftortoiseandhare_3.png)\n\n빠른 속도와 느린 속도 사이의 거리와 시작 위치와는 관계없이 루프가 있다면 결국 만날 것을 증명했습니다.\n\n# 코드\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내감으로 코드를 작성해볼까요?\n\n우선, 노드를 만들어봅시다.\n\n```js\nclass Node {\n    constructor(name = null) {\n        this.val = name;\n        this.next = null;\n    }\n}\n```\n\n그런 다음 두 개의 포인터를 생성하고, 이를 헤드를 가리키도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n}\n```\n\n제거 사례 설정 중입니다.\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null \u0026\u0026 fast.next != null) {\n\n    }\n    return false\n}\n```\n\n포인터를 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null \u0026\u0026 fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n이제 우리의 코드가 완성되었어요. 우리는 드디어 루프를 감지할 수 있는 코드를 작성했어요.\n\n그게 다일까요? 이 알고리즘의 유일한 용도인가요?\n\n# 사용 사례\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘의 주요 사용 사례 중 하나가 사이클 탐지인데, 단순히 그것만이 아닙니다. 다른 사용 사례를 살펴봅시다.\n\n연결 리스트의 중간을 찾아 봅시다. 우연히도 이를 수행하는 최적 알고리즘은 토끼와 거북이 알고리즘입니다.\n\n두 대의 차량이 있는 트랙이 있다고 가정해 봅시다. 차량 1은 차량 2의 반 속도입니다. 따라서 차량 2가 트랙 끝에 도달할 때, 차량 1은 트랙의 중간에 있을 것입니다. 이것이 우리의 직관입니다.\n\n이를 코딩해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 코드 함수 변환\nvar mid = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null || fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n}\n```\n\n다른 예제 사용 사례로는 연결 리스트의 중간 노드를 삭제하는 것이 있습니다.\n\n이전 솔루션을 이 질문에 구현하려고 하면 문제가 발생합니다. 만약 중간 노드를 삭제해야 한다면, 우리는 slow가 중간 노드 직전 노드에서 멈추길 원합니다. 어떻게 할 수 있을까요?\n\n한 가지 분명한 해결책은 slow 포인터보다 한 단계 이전인 이전 포인터를 사용하는 것일 수 있고, 실제로 이것은 좋은 해결책입니다. 그러나 더 나은 해결책은 fast 포인터에 앞서 시작하는 기회를 주는 것입니다. 이렇게 하면 slow가 이전 알고리즘보다 한 단계 더 적게 이동합니다. 그러므로 우리는 해결책을 찾았습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션을 코드로 작성해 보겠습니다.\n\n```js\nvar midRemover = function(head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next.next;\n    while (fast != null \u0026\u0026 fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    slow.next = slow.next.next;\n    return head;\n}\n```\n\n그래서 Linked Lists의 경우 거북이와 토끼 알고리즘은 매우 유용하지만, 시간 복잡도와 공간 복잡도는 어떨까요?\n\n# 시간 복잡도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘의 시간 복잡도를 찾아 봅시다. 머리와 루프의 시작 사이에 거리 x가 있다고 가정하고, 루프의 길이가 y이라고 합시다. slow가 루프의 시작점에 도달할 때, 걸린 반복 횟수는 x일 것입니다. 또한, fast 포인터가 slow가 루프의 시작점에 도달할 때 어디에 있든, fast가 slow에 도달하는 데 걸릴 수 있는 최대 반복 횟수는 y입니다. 왜냐하면 두 지점 사이의 최대 가능한 거리는 y-1이기 때문에, 거리는 1단위로 감소하므로 fast가 slow에 도달하는 데 걸리는 최대 시간은 y-1이지만 우리는 y로 근사합니다.\n\n따라서 알고리즘의 시간 복잡도는 O(N)입니다.\n\n# 공간 복잡도\n\n이 알고리즘은 두 개의 포인터만 사용합니다. 따라서 링크드 리스트의 크기가 변경되더라도 알고리즘에 사용되는 추가 공간은 변하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘에 사용된 추가 공간은 O(1)입니다.","ogImage":{"url":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png"},"coverImage":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png","tag":["Tech"],"readingTime":5},{"title":"30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법","description":"","date":"2024-06-22 02:01","slug":"2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode","content":"\n\n\n![image](/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png)\n\n# 1. Why\n\n## Why Control Concurrency?\n\nControlling concurrency is essential for effectively managing system resources, preventing overload, improving performance and response time, ensuring system stability, and maintaining a good user experience. By limiting the number of concurrent requests, the system can continue to operate normally even under high load conditions.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 무엇\n\n## 2.1 동시성이란 무엇인가요?\n\n동시성은 시스템 또는 프로그램이 동시에 여러 작업이나 요청을 처리할 수 있는 능력을 의미합니다. 일반적으로 이는 여러 프로세스나 스레드가 동시에 작업을 실행하여 시스템의 처리량과 응답 속도를 높이는 것을 포함합니다. 동시 환경에서 여러 작업이 번갈아가며 실행되어 리소스 활용이 더 효율적으로 이루어집니다. 그러나 리소스 충돌, 성능 저하, 데드락과 데이터 불일치 등의 문제를 방지하기 위해 효과적인 관리와 제어가 필요합니다.\n\n## 2.2 일반적인 동시 작업\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발에서 일반적인 동시 작업이 많이 있습니다. 프론트엔드, 백엔드, 데이터베이스 작업 및 시스템 수준의 작업 처리 등을 다룹니다. 웹 개발에서 일반적인 동시 작업의 몇 가지 예는 다음과 같습니다:\n\n- 여러 동시 인터페이스 요청: 프론트엔드 개발에서는 데이터를 가져오기 위해 동시에 여러 API 엔드포인트에 요청을 보내는 것이 일반적입니다.\n- 동시에 여러 요청 처리: 웹 서버는 동시에 여러 클라이언트 요청을 처리합니다.\n- 병렬로 작업 실행: 예를 들어 Node.js의 비동기 기능을 사용하여 여러 작업을 병렬로 실행하는 것입니다.\n\n# 3. 방법\n\n## 3.1 Promise.all\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드에서 동시 요청을 보낼 때 Promise.all을 많이 사용합니다. 예를 들어:\n\n```js\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      resolve(`총 ${duration}밀리초 소요`);\n    }, duration);\n  });\n}\n\n// 모든 비동기 작업이 완료될 때까지 기다리기 위해 Promise.all 사용\nfunction simulatePromiseAll() {\n  const promise1 = asyncOperation(1000);\n  const promise2 = asyncOperation(2000);\n  const promise3 = asyncOperation(3000);\n\n  Promise.all([promise1, promise2, promise3])\n    .then((results) =\u003e {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result =\u003e console.log(result));\n    })\n    .catch((error) =\u003e {\n      console.error('오류 발생:', error);\n    });\n}\n\n// Promise.all 함수 시뮬레이션 실행\nsimulatePromiseAll();\r\n```\n\n그러나 Promise.all은 동시성을 제어할 수 없거나 정확히는 이 능력을 가지고 있지 않습니다. 따라서 각 asyncOperation을 수정하여 Promise.all이 Promise를 실행할 때 동시성 제어를 지원하도록 몇 가지 수정을 해야 합니다.\n\n## 3.2 구현 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 아이디어는 100개의 동시 작업이 있고 최대 동시성을 10으로 설정한다면 다음 단계를 따릅니다:\n\n1. 먼저 10개의 슬롯을 설정합니다.\n2. 처음 10개의 동시 작업이 슬롯을 차지하고 실행됩니다.\n3. 어떤 슬롯이 먼저 작업을 완료했는지 모니터링한 후, 나머지 작업에서 다른 작업을 가져와 슬롯을 채웁니다.\n4. 모든 동시 작업이 완료될 때까지 단계 3을 반복합니다.\n\n```js\n// 우리가 구현해야 하는 함수\nconst simulateLimit = () =\u003e {\n  // 코드 작성 \n}\n\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      resolve(`Completed in ${duration} ms`);\n    }, duration);\n  });\n}\n\n// 동시성을 제한하기 위해 simulateLimit을 사용합니다\nfunction simulateControlledPromiseAll() {\n  const limit = simulateLimit(10);\n\n  const tasks = [\n    limit(() =\u003e asyncOperation(1000)),\n    limit(() =\u003e asyncOperation(2000)),\n    limit(() =\u003e asyncOperation(3000)),\n    limit(() =\u003e asyncOperation(1500)),\n    limit(() =\u003e asyncOperation(2500)),\n    limit(() =\u003e asyncOperation(3500)),\n    // 여기에 더 많은 작업을 추가하세요\n    // ...\n  ];\n\n  Promise.all(tasks)\n    .then((results) =\u003e {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result =\u003e console.log(result));\n    })\n    .catch((error) =\u003e {\n      console.error('에러가 발생했습니다:', error);\n    });\n}\n\nsimulateControlledPromiseAll();\r\n```\n\n3.3 30줄의 코드로 simulateLimit를 구현하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 바꿔주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반환된 함수 내부에서는 실제 작업 함수 fn을 래핑하는 작업 함수를 만듭니다. task가 호출되면 activeCount를 증가시키고 작업 함수 fn을 실행합니다. 작업이 완료되면 성공 또는 실패 여부에 상관없이 다음 함수가 호출됩니다.\n\n```js\nconst task = () =\u003e {\n  activeCount++;\n\n  fn(...args).then(\n    (value) =\u003e {\n      resolve(value);\n      next();\n    },\n    (error) =\u003e {\n      reject(error);\n      next();\n    }\n  );\n};\n```\n\n현재 작업이 완료된 후 next 함수가 호출됩니다. activeCount를 감소시키고 대기 중인 작업이 있고 동시성 제한이 아직 초과되지 않았다면 대기열에서 다음 작업을 가져와 실행합니다.\n\n```js\nconst next = () =\u003e {\n  activeCount--;\n  if (queue.length \u003e 0 \u0026\u0026 activeCount \u003c concurrency) {\n    const nextTask = queue.shift();\n    nextTask();\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반환된 함수 내부에서 현재 활성 작업 수 activeCount가 동시성 제한(concurrency)보다 작은지 확인합니다. 작업 수가 모자라면 해당 작업을 즉시 실행하고, 그렇지 않다면 해당 작업을 대기열에 추가합니다.\n\n```js\nif (activeCount \u003c concurrency) {\n  task();\n} else {\n  queue.push(task);\n}\n```\n\n전체 코드 구현은 아래와 같습니다:\n\n```js\nfunction simulateLimit(concurrency) {\n  const queue = [];\n  let activeCount = 0;\n\n  return function (fn, ...args) {\n    return new Promise((resolve, reject) =\u003e {\n      const task = () =\u003e {\n        activeCount++;\n        fn(...args).then(\n          (value) =\u003e {\n            resolve(value);\n            next();\n          },\n          (error) =\u003e {\n            reject(error);\n            next();\n          }\n        );\n      };\n\n      const next = () =\u003e {\n        activeCount--;\n        if (queue.length \u003e 0 \u0026\u0026 activeCount \u003c concurrency) {\n          const nextTask = queue.shift();\n          nextTask();\n        }\n      };\n\n      if (activeCount \u003c concurrency) {\n        task();\n      } else {\n        queue.push(task);\n      }\n    });\n  };\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 이것은 유명한 라이브러리인 p-limit의 소스 코드입니다. 더 완벽한 사용법과 정제된 코드를 보려면 npm에서 p-limit을 참조해주세요. 배워갔나요?\n\n# 간단하고 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우하기 ️👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 만나기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보기","ogImage":{"url":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬에서 Boolean 연산자, 정말 우리가 생각하는 것과 다를까","description":"","date":"2024-06-22 02:00","slug":"2024-06-22-BooleanOperatorsinPythonArentWhatYouThink","content":"\n\n\n![Boolean Operators in Python](/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png)\n\n파이썬 프로그래머로서 나름 꽤 괜찮은 실력을 가지고 있다고 생각해요. 과거에 이 언어를 광범위하게 사용해 온 경험이 있고, 일반적으로 가장 편안하게 사용할 수 있는 언어라고 느껴지죠.\n\n하지만 편안한 영역 안에서도 가끔씩 익숙하지 않은 \"어?\"란 순간을 만나곤 해요. 최근에 저도 이런 순간을 겪었는데, 그것은 어딜 봐도 상상할 수 없는 곳에서 일어난 거였어요: Boolean 연산자들입니다.\n\n제가 보기에는 그 순간까지 True와 False, \"abc\"와 \"\", None 또는 0과 같은 표현식들이 모두 False로 평가될 것이라고 생각했어요. 왜냐하면 파이썬은 False, None, 빈 문자열, 모든 종류의 숫자 0, 그리고 다른 값들을 거짓 값으로 해석하기 때문이라고 생각했거든요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 이게 왜 일어날 수 있는지 생각해봐도 되지 않을까요? 결국, 우리는 계속해서 if 문을 사용해온 만큼 그것들이 결코 실망시켜 준 적이 없습니다.\n\n```js\nif 1 and 0:\n    print(\"이 문구는 절대 출력 안 됩니다...\")\nif 1 or 0:\n    print(\"하지만 이건 볼 수 있을 겁니다!\")\n```\n\n명백하죠, 1 and 0은 False에 해당하며 1 or 0은 True에 해당합니다, 맞나요?\n\n하지만 여기서 한 가지 주목할 점이 있습니다: Python은 특정한 비-부울 값들(예: 1 또는 \"\")을 부울 문맥(즉, 부울 연산자와 함께 사용되었을 때)에서 True 또는 False로 해석하더라도 해당 문맥의 반환 값을 결정하는 데 아무 영향도 미치지 않습니다. 다시 말해, val = True and 1은 어떤 결과를 얻게 될까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n불리언 연산은 마지막으로 평가된 인수의 값을 반환한다는 것을 알게 되었습니다. and의 경우에는 non-true (또는의 경우에는 true) 값이 발견되자마자 표현식이 중단됩니다. 그렇지 않은 경우, 모든 인수의 참값을 확인해야 합니다.\n\n따라서 위 표현식의 경우, 1이 마지막으로 평가된 인수이며, val은 결과적으로 1의 값을 받게 됩니다.\n\n여기 몇 가지 더 예제가 있습니다:\n\n```js\nval = False and True # val = False\nval = \"abc\" and \"\" # val = \"\"\nval = \"\" or \"abc\" # val = \"abc\"\nval = None or 0 # val = 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 이겢 유용한가요?\n\n이를 알면 예를 들어 이러한 동작을 활용하여 대입 중에 간결한 null 확인을 수행할 수 있습니다.\n\n대안은 명시적으로 person이 None인지 확인해야 합니다:\n\n```js\nage = person.age if person else None\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Python에는 특이하지 않아요\n\n사실, Python이 이와 같은 방식으로 동작하는 유일한 프로그래밍 언어는 아닙니다. 일부 Reddit 사용자들이 언급했듯이, 특히 JavaScript는 비슷하게 동작하며 선택적 체이닝 연산자 (?.)를 제공하여 한 단계 더 나아갑니다.\n\n만약 우리의 Person 클래스를 JavaScript로 옮겼다고 가정하면, 이 연산자를 사용하여 다음과 같이 수행할 수 있습니다:\n\n```js\nperson = new Person(18)\nage = person?.age // age = 18\nperson = undefined\nage = person?.age // age = undefined\nname = person?.name ?? \"John Doe\" // name = \"John Doe\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, ??를 사용하여 후속 값들을 지정할 수 있습니다.\n\n참고: 루트 개체(우리 예시에서는 person)가 None(Python)이나 undefined/null(JavaScript)이 될 수 있지만 반드시 선언되어 있어야 합니다.\n\n# 결론\n\n이 작은 정보가 유용했으면 좋겠습니다. 생각을 공유해 주시고 궁금한 점이 있으면 언제든지 물어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자료\n\n- 불리언 연산 | 파이썬 문서\n- 단락 평가 | 위키백과\n- 파이썬의 불리언 연산자는 불리언을 반환하지 않음 | 레딧\n- 선택 연쇄 (?.) | MDN 웹 문서","ogImage":{"url":"/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png"},"coverImage":"/assets/img/2024-06-22-BooleanOperatorsinPythonArentWhatYouThink_0.png","tag":["Tech"],"readingTime":3},{"title":"Formik과 Yup 라이브러리로 React 폼 유효성 검사를 간편하게 하는 방법","description":"","date":"2024-06-22 01:59","slug":"2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries","content":"\n\n가끔 React 애플리케이션에서 유효성 검사를 구현하는 것은 꽤 짜증날 수 있어요. 최근 이 분야를 탐험해본 결과, Formik과 Yup이라는 두 라이브러리를 발견했어요.\n\n**Formik**: Formik은 상태를 관리하는 데 도움이 되는 오픈 소스 라이브러리에요 (이렇게 생각해보세요: 필드 내용을 수정할 때, 필드 값이 자동으로 업데이트됩니다) 그리고 폼 제출을 처리합니다.\n\n**Yup**: Yup은 검사를 효율적으로 간단하게 만드는 또 다른 오픈 소스 라이브러리에요.\n\n유효성을 갖춘 어떤 형식으로든 폼을 만들 때, 최소한의 코드를 사용하여 이것을 달성하는 것은 다른 방법에 비해 불가능하다고 느낄 수 있어요. 이러한 라이브러리를 사용하는 목표는 기존 솔루션을 활용하는 것에요. 누군가 이미 작업을 완료했다면, 왜 우리는 처음부터 시작해야 할까요? 이 도구들을 사용해서 프로세스를 더 간단하고 정확하게 만들어봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 나온 사용자 작성 코드를 통해 회원 가입 페이지에 대해 설명해 드리겠습니다:\n\nFormik 태그는 모든 코드를 감싸고 그 안의 각 필드 상태를 관리합니다. initialValues는 모든 필드의 기본값을 설정합니다. validationSchema은 Yup을 사용하여 각 필드를 유효성 검사합니다. 요구 사항에 따라 로직을 작성하는 스키마를 정의합니다. handleSubmit 함수는 폼이 제출될 때 트리거됩니다. isSubmitting 속성은 폼에 문제가 있거나 필드가 제대로 입력되지 않았을 때 버튼을 비활성화하는 데 도움을 줍니다. setSubmitting 함수는 제출 버튼이 활성화되거나 비활성화되는지 제어하는 상태를 변경하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png)\n\n참고: 오픈 소스를 활용하고, 그들의 신뢰성을 확인하고 적용하세요.\n","ogImage":{"url":"/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png"},"coverImage":"/assets/img/2024-06-22-SimplifyReactFormValidationsUsingFormikandYupLibraries_0.png","tag":["Tech"],"readingTime":2},{"title":"adamant-api v240 출시 v200 이후 달라진 점은","description":"","date":"2024-06-22 01:56","slug":"2024-06-22-adamant-apiv240isoutWhatschangedsincev200","content":"\n\nadamant-api는 패키지의 가장 큰 업데이트 이후 중요한 개선 사항과 수정 사항을 거쳐 상당한 향상을 이루었습니다. 전체적인 개발자 경험과 버그 수정을 목표로 한 패키지의 최대 업데이트 이후 주요 변경 사항을 살펴봅시다.\n\n![image](/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png)\n\n# 버그 수정\n\n- voteForDelegate() 유효성 검사 (v2.4.0): API.voteForDelegate() 메서드 내에서 공개 키 및 대표자 이름의 유효성 검사를 수정하였으며, 주소가 실제 대표자인지 체크하여 ADM 토큰의 낭비를 방지하였습니다.\n- 노드 체크 버그 (v2.3.1): 헬스 체크 프로세스 중에 랜덤 노드가 한 개만 체크되던 버그를 해결하였습니다.\n- 전역 설치 (v2.3.0): adamant-api에 의존하는 패키지의 전역 설치 문제를 해결하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DX 개선 사항\n\n- 로그 메시지 (v2.3.1): 보건 점검에 대한 로그 메시지를 개선하여 문제를 진단하고 시스템 상태를 모니터링하기 쉽게 했습니다.\n- 트랜잭션 쿼리 메서드 (v2.3.0): 트랜잭션 쿼리 언어를 사용하는 엔드포인트에 대해 중첩 객체를 사용하도록 변경하였습니다:\n\n```js\nconst blocks = await api.getTransactions({\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280, // 'and:toHeight' 대신 7586280 사용\n  },\n  or: {\n    senderId: 'U18132012621449491414', // 'or:senderId' 대신 '...' 사용\n  },\n});\n```\n\n- WebSocket 초기화 (v2.1.0): api.initSocket() 메서드는 이제 WebSocketClient의 인스턴스를 수락합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst socket = new WebSocketClient({ /* ... */ });\napi.initSocket(socket);\n```\n\n- 메시지 인코딩 및 디코딩 (v2.1.0): encodeMessage() 및 decodeMessage() 함수가 퍼블릭 키를 Uint8Array 또는 Buffer로 받고, 패스프레이스 대신 키 쌍을 직접 전달할 수 있도록 업그레이드되었습니다:\n\n```js\nimport {encodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst {publicKey} = createKeypairFromPassphrase('...');\nconst message = encodeMessage(,, publicKey);\n```\n\n```js\nimport {decodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst keyPair = createKeypairFromPassphrase('...');\nconst message = decodeMessage(,, keyPair);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유틸리티 함수\n\n- Validator 유틸리티(v2.2.0): API 내에서 여러 엔티티의 유효성을 향상시키기 위해 다양한 validator 유틸리티 함수를 내보냈습니다:\n\n```js\nfunction isPassphrase(passphrase: unknown): passphrase is string;\nfunction isAdmAddress(address: unknown): address is AdamantAddress;\nfunction isAdmPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForAddress(address: unknown): boolean;\nfunction isAdmVoteForDelegateName(delegateName: unknown): delegateName is string;\nfunction validateMessage(message: string, messageType: MessageType = MessageType.Chat): {success: false; error: string} | {success: true};\nfunction isDelegateName(name: unknown): name is string;\nfunction admToSats(amount: number): number;\n```\n\n- 거래 쿼리 객체 변환(v2.3.0): transformTransactionQuery 함수를 소개하여 거래 쿼리를 간결화하고 구조화하여 더 읽기 쉽고 관리하기 쉽도록 만들었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n상수 transformed를 transformTransactionQuery 함수로 변환했습니다. {\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280,\n  },\n  or: {\n    senderId: 'U18132012621449491414',\n  },\n});\nconsole.log(transformed); // {'and:toHeight': 7586280, 'or:senderId': /* ... */}\n```\n\n# 타입 정의\n\n- 많은 메소드 내에서 트랜잭션 id에 대한 유형 정의가 수정되었으며, ChatTransactionData 인터페이스 내의 amount 속성 및 주 클래스의 options 내의 logLevel에 대한 유형 정의가 수정되었습니다.\n\nGitHub의 릴리스 노트를 확인하십시오: [여기](https://github.com/Adamant-im/adamant-api-jsclient/blob/master/CHANGELOG.md)\n","ogImage":{"url":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png"},"coverImage":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png)\n\n소개:\nReact.js와 Node.js는 효율성, 확장성 및 유연성으로 현대적인 웹 애플리케이션을 구축하는 데 인기 있는 선택지가 되었습니다. 이 블로그 포스트에서는 이러한 기술을 사용하여 풀 스택 웹 애플리케이션을 만드는 과정을 안내하겠습니다.\n\n필수 준비물:\n다음이 설치되어 있는지 확인하십시오:\n- Node.js (버전 14 이상)\n- npm (Node 패키지 관리자)\n- React.js (프론트엔드를 설정하기 위한 create-react-app)\n- Express.js (백엔드 서버를 설정하기 위해)\n\n단계 1: 환경 설정하기\n프로젝트용 새 디렉터리를 생성하고 프론트엔드와 백엔드를 설정하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nmkdir fullstack-app\ncd fullstack-app\n\n# 프론트엔드 설정하기 - create-react-app 사용\nnpx create-react-app client\ncd client\n\n# 백엔드 설정하기 - Express.js 사용\nmkdir server\ncd server\nnpm init -y\nnpm install express\n\n\n단계 2: 백엔드 API 생성하기\n`server` 디렉토리 내에 Express.js 서버용 `index.js` 파일을 만들어 보세요:\n\n```js\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.get('/api/data', (req, res) =\u003e {\n  const data = [\n    { id: 1, name: 'John Doe' },\n    { id: 2, name: 'Jane Smith' },\n    // 필요한 만큼 데이터 추가\n  ];\n  res.json(data);\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n단계 3: React.js로 프론트엔드 설정하기\n`client` 디렉토리 (create-react-app에서 생성됨)에서 `App.js`를 수정하여 백엔드 API에서 데이터를 가져올 수 있도록 설정하세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\r\nimport React, { useEffect, useState } from 'react';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  const [data, setData] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetch('/api/data')\r\n      .then(res =\u003e res.json())\r\n      .then(data =\u003e setData(data))\r\n      .catch(err =\u003e console.error('데이터를 가져오는 중 오류가 발생했습니다:', err));\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv className=\"App\"\u003e\r\n      \u003ch1\u003e풀 스택 웹 애플리케이션\u003c/h1\u003e\r\n      \u003cul\u003e\r\n        {data.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.name}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\nStep 4: 애플리케이션 실행하기\r\n프론트엔드와 백엔드 서버를 동시에 실행하세요:\r\n\r\n\n# 'client' 디렉토리에서\r\nnpm start\r\n\r\n# 'server' 디렉토리에서\r\nnode index.js\r\n\n\r\n결론:\r\n이 블로그 포스트에서 React.js와 Node.js를 사용하여 풀 스택 웹 애플리케이션을 구축하는 기본적인 내용을 다뤘습니다. 환경을 설정하는 방법, Express.js를 사용하여 백엔드 API를 생성하는 방법, 그리고 백엔드에서 데이터를 가져와 React.js 프론트엔드에 표시하는 방법을 배웠습니다. 이 프로젝트를 확장하여 더 많은 기능을 추가하거나 MongoDB와 같은 데이터베이스를 통합하거나 Heroku나 AWS와 같은 플랫폼에 애플리케이션을 배포하는 등의 작업을 자유롭게 진행해보세요.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 많은 자료:\n\n- React.js 문서: [reactjs.org](https://reactjs.org/)\n- Node.js 문서: [nodejs.org](https://nodejs.org/)\n- Express.js 문서: [expressjs.com](https://expressjs.com/)\n\nReact.js와 Node.js의 더 심화된 주제를 탐색하여 풀스택 개발 능력을 향상시키세요. 떠오르는 기술들에 대한 더 많은 튜토리얼과 프로젝트를 기대해주세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide","content":"\n\n로컬호스트에서 HTTPS를 실행하는 것은 안전한 웹 애플리케이션을 개발하고 테스트하는 데 필수적입니다.\n보안 소켓 계층(SSL) 또는 전송 계층 보안(TLS)은 인터넷을 통해 안전한 통신을 제공하는 방법을 제공합니다. 로컬호스트에서 HTTPS 서버를 실행하면 제품 서버에 배포될 때 웹 애플리케이션이 작동할 안전한 환경을 시뮬레이션할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png)\n\n이 안내서에서는 자체 서명된 인증서 및 Node.js 서버를 사용하여 로컬 머신에서 HTTPS를 설정하는 과정을 안내하겠습니다.\n\n#  준비 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 다음 사전 요구 사항을 준비해 주세요:\n\n- Node.js 및 npm: 시스템에 Node.js 및 npm이 설치되어 있는지 확인하세요. 이것들은 nodejs.org에서 다운로드할 수 있습니다.\n- HTTPS의 기본 지식\n\n# 단계 1: 자체 서명 루트 인증서 생성\n\n첫 번째 단계는 자체 서명 루트 인증서를 생성하는 것입니다. 해당 인증서를 컴퓨터에 설치하고 서버에서 사용할 다른 인증서를 서명할 것입니다. 루트 인증서를 설치하면 해당 루트 인증서로 서명된 다른 인증서를 신뢰하는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 터미널이나 명령 프롬프트를 열고 인증서를 저장할 디렉토리로 이동하세요.\n- 다음 명령을 실행하여 루트 인증서용 개인 키를 생성하세요:\n\n```js\nopenssl genrsa -out root.key 2048\n```\n\n3. 이제 해당 개인 키를 사용하여 자체 서명된 루트 인증서를 생성하세요:\n\n```js\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. macOS를 사용 중이라면, root.crt 파일을 두 번 클릭하여 시스템의 신뢰할 수 있는 인증서에 루트 인증서를 추가할 수 있습니다. Keychain Access 애플리케이션이 열릴 것입니다. \"System\" 키체인을 선택한 후, \"추가\"를 클릭하여 root.crt 파일을 찾아 선택하고 다시 \"추가\"를 클릭합니다. 인증서가 신뢰할 수 있는 것으로 표시되었는지 확인해주세요.\n\n이러한 단계를 거친 후, 우리는 자체 서명 루트 인증서를 만들어 신뢰할 수 있는 저장소에 추가했습니다.\n\n# 단계 2: 서버 인증서 생성\n\n다음으로, 로컬호스트를 위한 서버 인증서를 만들 것입니다. 이 인증서를 사용하면 로컬 서버가 안전한 연결을 설정할 수 있습니다. 서버의 인증서를 루트 인증서로 서명하여 컴퓨터가 서버의 신뢰성을 보장할 수 있도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버용 개인 키 생성:\n\n```js\nopenssl genrsa -out server.key 2048\n```\n\n2. 서버용 개인 키를 사용하여 인증서 서명 요청 (CSR) 생성:\n\n```js\nopenssl req -new -key server.key -out server.csr\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이 명령은 공통 이름 (CN) 및 조직 세부 정보와 같은 CSR에 대한 일부 정보를 제공하도록 요구합니다. 공통 이름을 서버와 연결된 호스트명 또는 도메인 이름 (예: localhost)으로 설정해야 합니다.\n\n4. 루트 인증서로 CSR에 서명하여 서버 인증서를 만듭니다:\n\n```js\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n```\n\n5. 이 명령은 루트 인증서와 개인 키를 사용하여 CSR에 서명하고, 365일 동안 유효한 새로운 서버 인증서인 server.crt를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 거치면 서버에서 사용할 인증서를 만들고 PC가 신뢰하는 인증서로 설정합니다.\n\n# 단계 3: Node.js 서버 생성\n\n이제 서버 인증서를 준비했으니, HTTPS로 콘텐츠를 제공하기 위한 간단한 Node.js 서버를 만들어봅시다. 이 예시에선 Node.js와 Express 프레임워크를 사용하지만, 다른 언어와 프레임워크에 이 단계를 적용할 수도 있습니다.\n\n- server.js 라는 파일을 생성하고 다음 코드를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('~/certs/practice/server.key'), // 귀하의 키 경로로 대체하세요\n    cert: fs.readFileSync('~/certs/practice/server.crt'), // 귀하의 인증서 경로로 대체하세요\n}\n\nhttps.createServer(options, (req, res) =\u003e {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () =\u003e {\n  console.log('서버가 443 포트에서 실행 중입니다');\n});node\n```\n\n2. 파일을 저장한 후 터미널에서 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\nnode server.js\n```\n\n3. HTTPS 서버가 443 포트에서 실행 중이며, https://localhost 에서 액세스할 수 있습니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: 루트 인증서 신뢰 (macOS 전용)\n\n만약 macOS를 사용 중이라면, 루트 인증서를 신뢰하기 위해 다음 추가 단계를 따라주세요:\n\n- Keychain Access 애플리케이션을 엽니다.\n- 왼쪽 사이드바에서 \"시스템\" 키체인을 선택합니다.\n- \"파일\"을 클릭한 후 \"항목 가져오기\"를 선택하고 root.crt 파일을 선택합니다.\n- 가져온 인증서를 더블 클릭하고 \"신뢰\" 섹션을 확장한 후 \"이 인증서 사용 시\"를 \"항상 신뢰함\"으로 설정합니다.\n\n# 단계 5: 최종 스크립트 (옵션)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증서 생성 및 서버 설정을 자동화하려면 다음 스크립트를 사용할 수 있어요:\n\n```js\necho \"루트 서버 생성 중\"\nopenssl genrsa -out root.key 2048\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n\necho \"서버 인증서 생성 중\"\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -out server.csr\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n\necho \"서버 파일 생성 중\"\ntouch server.js\necho \"\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('/Users/akshitdev/certs/practice/server.key'),\n    cert: fs.readFileSync('/Users/akshitdev/certs/practice/server.crt'),\n}\n\nhttps.createServer(options, (req, res) =\u003e {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () =\u003e {\n  console.log('서버가 포트 443에서 실행 중입니다');\n});\n\" \u003e\u003e server.js\n\necho \"서버를 루트에 추가 중\"\nsudo security add-trusted-cert -d -r trustRoot -k \"/Library/Keychains/System.keychain\" \u003c인증서_파일_경로\u003e\n\necho \"서버 실행 중\"\nnode server.js\n```\n\n이 스크립트를 사용하면 인증서 생성 및 서버 설정 과정을 자동화할 수 있어요.\n\n끝났어요! 셀프 사이닝된 인증서를 사용하여 로컬호스트에서 HTTPS를 성공적으로 구성했어요.","ogImage":{"url":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기","description":"","date":"2024-06-20 07:35","slug":"2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend","content":"\n\n오늘날 연결된 세상에서 안전한 웹 앱을 만드는 것은 매우 중요합니다. 애플리케이션의 통신 링크는 민감한 사용자 데이터를 관리하거나 거래를 돕는 경우 모두 안전해야 합니다. 다른 이의 엿보는 데서 민감한 데이터를 보호하기 위해, 리액트 프로젝트에서 API 호출을 안전하게 하는 방법에 대해 살펴보면서 업계 모베스트 프랙티스를 준수합니다.\n\n소개\n프런트엔드와 백엔드 간의 통신을 보호하는 것은 웹 애플리케이션 보안에서 가장 중요한 부분 중 하나입니다. 이는 API 엔드포인트를 보호하고 데이터 통신을 암호화하며 강력한 인증 절차를 수립하는 것을 포함합니다. 이러한 안전장치를 구현함으로써 무단 접근, 데이터 유출 및 기타 보안 결함의 가능성을 줄일 수 있습니다.\n\n# Node.js 백엔드 설정하기\n\n우리의 여정은 Node.js와 Express.js를 사용하여 백엔드를 설정하는 것으로 시작됩니다. Express.js는 Node.js를 위한 인기 있는 웹 애플리케이션 프레임워크입니다. 우리는 인증 기능을 갖춘 간단한 RESTful API를 만들어 보호된 리소스에만 인증된 사용자가 접근할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 Node.js 백엔드에서는:\n\n- Express.js를 사용하여 서버를 생성하고 HTTP 요청을 처리합니다.\n- 인증은 현대적인 웹 애플리케이션에서 널리 사용되는 stateless 인증 메커니즘인 JSON Web Tokens (JWT)를 사용하여 구현됩니다.\n- 사용자 로그인 (/login) 및 보호된 데이터 검색 (/api/data)을 위한 라우트를 정의하고, 후자에 대한 인증을 강제합니다.\n\n```js\n// server.js\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\nconst SECRET_KEY = 'your_secret_key';\n\napp.use(express.json());\n\n// 사용자 데이터 모의 (실제 시나리오에서는 데이터베이스에서 검색됨)\nconst users = [\n  { id: 1, username: 'user1', password: 'password1' },\n  { id: 2, username: 'user2', password: 'password2' }\n];\n\n// JWT 토큰 생성을 위한 로그인 라우트\napp.post('/login', (req, res) =\u003e {\n  const { username, password } = req.body;\n  const user = users.find(u =\u003e u.username === username \u0026\u0026 u.password === password);\n  if (!user) {\n    return res.status(401).json({ message: '유효하지 않은 사용자 이름 또는 비밀번호' });\n  }\n  const token = jwt.sign({ userId: user.id }, SECRET_KEY);\n  res.json({ token });\n});\n\n// 보호된 라우트\napp.get('/api/data', verifyToken, (req, res) =\u003e {\n  res.json({ message: '보호된 데이터' });\n});\n\nfunction verifyToken(req, res, next) {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({ message: '인가되지 않음' });\n  }\n  jwt.verify(token, SECRET_KEY, (err, decoded) =\u003e {\n    if (err) {\n      return res.status(401).json({ message: '유효하지 않은 토큰' });\n    }\n    req.userId = decoded.userId;\n    next();\n  });\n}\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n});\n```\n\n# React로 프론트엔드 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드 설정이 완료되어, 이제 프론트엔드에 주력하게 됩니다. 리액트 애플리케이션을 구축하여 백엔드 API와 상호작용할 것입니다. 리액트 앱은 사용자 인증을 용이하게 하며, 보호된 데이터를 가져오기 위해 백엔드로 요청을 보냅니다.\n\n우리의 리액트 프론트엔드에서 주요한 부분은 다음과 같습니다:\n\n- React 컴포넌트 내에서 백엔드 엔드포인트에 HTTP 요청을 보내기 위해 fetch API를 사용합니다.\n- 성공적으로 인증된 후, JWT 토큰을 클라이언트의 로컬 상태에 저장합니다.\n- 토큰은 보호된 API 엔드포인트로의 후속 요청의 Authorization 헤더에 포함됩니다.\n\n```js\n// App.js\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [token, setToken] = useState('');\n  const [data, setData] = useState('');\n\n  const login = async () =\u003e {\n    const response = await fetch('/login', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ username: 'user1', password: 'password1' })\n    });\n    const { token } = await response.json();\n    setToken(token);\n  };\n\n  const fetchData = async () =\u003e {\n    const response = await fetch('/api/data', {\n      method: 'GET',\n      headers: {\n        'Authorization': token\n      }\n    });\n    const result = await response.json();\n    setData(result.message);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={login}\u003e로그인\u003c/button\u003e\n      {token \u0026\u0026 \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e}\n      \u003cdiv\u003e{data}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# API 호출 및 데이터 전송 보안\n\nAPI 호출을 보호하는 것은 여러 층의 보호를 포함합니다:\n\n- HTTPS: 백엔드 API가 HTTPS를 통해 제공되도록하여 클라이언트와 서버 간에 전송되는 데이터를 암호화하여 도청과 변경을 방지합니다.\n- JWT 인증: JWT 토큰을 사용하여 클라이언트가 자신을 인증하고 안전하게 보호된 리소스에 액세스할 수 있도록 인증합니다.\n- 권한 부여: 민감한 정보에 액세스할 수 있는 사용자가 인증되었는지 확인하기 위해 보호된 엔드포인트에 권한 확인을 구현합니다.\n- 프록시된 요청: 클라이언트에게 백엔드 API의 세부 정보를 숨기기 위해 서버를 통해 요청을 프록시 처리하여 보안을 강화하고 백엔드 엔드포인트가 직접 노출되는 것을 방지합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 프로젝트에서 Node.js 백엔드와 API 호출을 할 때는 최상의 방법을 준수하고 견고한 보안 메커니즘을 적용하여 안전하게 보호할 수 있습니다. JWT 토큰으로 인증 설정부터 서버를 통해 요청 프록시하는 것까지, 각 단계는 미인가된 접근으로부터 민감한 데이터를 보호하고 잠재적인 보안 문제를 예방하는 데 중요합니다.\n\n데이터 프라이버시와 보안이 중요한 점이 갈수록 높아지는 현대 세계에서는 이러한 보안 원칙을 구현하는 것이 권장 사항뿐만 아니라 사용자 신뢰와 확신을 구축하기 위한 필수 요소입니다. 보안을 강조함으로써, 우리는 웹 애플리케이션이 증가하는 위협과 취약점에 강건하게 대응하여 사용자에게 안전하고 안전한 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png"},"coverImage":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png","tag":["Tech"],"readingTime":5}],"page":"30","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"30"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>