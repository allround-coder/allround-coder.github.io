<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/30" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/30" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="adamant-api v240 출시 v200 이후 달라진 점은" href="/post/2024-06-22-adamant-apiv240isoutWhatschangedsincev200"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="adamant-api v240 출시 v200 이후 달라진 점은" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="adamant-api v240 출시 v200 이후 달라진 점은" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">adamant-api v240 출시 v200 이후 달라진 점은</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" href="/post/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" href="/post/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" href="/post/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="올바른 Docker 없이 Open WebUI를 설치하는 방법" href="/post/2024-06-20-HowtoinstallOpenWebUIwithoutDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="올바른 Docker 없이 Open WebUI를 설치하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="올바른 Docker 없이 Open WebUI를 설치하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">올바른 Docker 없이 Open WebUI를 설치하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node Boost 클러스터, 스레드" href="/post/2024-06-20-NodeBoostClustersThreads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node Boost 클러스터, 스레드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-NodeBoostClustersThreads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node Boost 클러스터, 스레드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Node Boost 클러스터, 스레드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법" href="/post/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" href="/post/2024-06-20-Why3in123falseinJavaScriptTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC 인터뷰 질문 시리즈 1" href="/post/2024-06-20-LWCInterviewQuestionsSeries1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC 인터뷰 질문 시리즈 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC 인터뷰 질문 시리즈 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC 인터뷰 질문 시리즈 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" href="/post/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link posts_-active__YVJEi" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"adamant-api v240 출시 v200 이후 달라진 점은","description":"","date":"2024-06-22 01:56","slug":"2024-06-22-adamant-apiv240isoutWhatschangedsincev200","content":"\n\nadamant-api는 패키지의 가장 큰 업데이트 이후 중요한 개선 사항과 수정 사항을 거쳐 상당한 향상을 이루었습니다. 전체적인 개발자 경험과 버그 수정을 목표로 한 패키지의 최대 업데이트 이후 주요 변경 사항을 살펴봅시다.\n\n![image](/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png)\n\n# 버그 수정\n\n- voteForDelegate() 유효성 검사 (v2.4.0): API.voteForDelegate() 메서드 내에서 공개 키 및 대표자 이름의 유효성 검사를 수정하였으며, 주소가 실제 대표자인지 체크하여 ADM 토큰의 낭비를 방지하였습니다.\n- 노드 체크 버그 (v2.3.1): 헬스 체크 프로세스 중에 랜덤 노드가 한 개만 체크되던 버그를 해결하였습니다.\n- 전역 설치 (v2.3.0): adamant-api에 의존하는 패키지의 전역 설치 문제를 해결하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DX 개선 사항\n\n- 로그 메시지 (v2.3.1): 보건 점검에 대한 로그 메시지를 개선하여 문제를 진단하고 시스템 상태를 모니터링하기 쉽게 했습니다.\n- 트랜잭션 쿼리 메서드 (v2.3.0): 트랜잭션 쿼리 언어를 사용하는 엔드포인트에 대해 중첩 객체를 사용하도록 변경하였습니다:\n\n```js\nconst blocks = await api.getTransactions({\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280, // 'and:toHeight' 대신 7586280 사용\n  },\n  or: {\n    senderId: 'U18132012621449491414', // 'or:senderId' 대신 '...' 사용\n  },\n});\n```\n\n- WebSocket 초기화 (v2.1.0): api.initSocket() 메서드는 이제 WebSocketClient의 인스턴스를 수락합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst socket = new WebSocketClient({ /* ... */ });\napi.initSocket(socket);\n```\n\n- 메시지 인코딩 및 디코딩 (v2.1.0): encodeMessage() 및 decodeMessage() 함수가 퍼블릭 키를 Uint8Array 또는 Buffer로 받고, 패스프레이스 대신 키 쌍을 직접 전달할 수 있도록 업그레이드되었습니다:\n\n```js\nimport {encodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst {publicKey} = createKeypairFromPassphrase('...');\nconst message = encodeMessage(,, publicKey);\n```\n\n```js\nimport {decodeMessage, createKeypairFromPassphrase} from 'adamant-api';\nconst keyPair = createKeypairFromPassphrase('...');\nconst message = decodeMessage(,, keyPair);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유틸리티 함수\n\n- Validator 유틸리티(v2.2.0): API 내에서 여러 엔티티의 유효성을 향상시키기 위해 다양한 validator 유틸리티 함수를 내보냈습니다:\n\n```js\nfunction isPassphrase(passphrase: unknown): passphrase is string;\nfunction isAdmAddress(address: unknown): address is AdamantAddress;\nfunction isAdmPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForPublicKey(publicKey: unknown): publicKey is string;\nfunction isAdmVoteForAddress(address: unknown): boolean;\nfunction isAdmVoteForDelegateName(delegateName: unknown): delegateName is string;\nfunction validateMessage(message: string, messageType: MessageType = MessageType.Chat): {success: false; error: string} | {success: true};\nfunction isDelegateName(name: unknown): name is string;\nfunction admToSats(amount: number): number;\n```\n\n- 거래 쿼리 객체 변환(v2.3.0): transformTransactionQuery 함수를 소개하여 거래 쿼리를 간결화하고 구조화하여 더 읽기 쉽고 관리하기 쉽도록 만들었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n상수 transformed를 transformTransactionQuery 함수로 변환했습니다. {\n  fromHeight: 7585271,\n  and: {\n    toHeight: 7586280,\n  },\n  or: {\n    senderId: 'U18132012621449491414',\n  },\n});\nconsole.log(transformed); // {'and:toHeight': 7586280, 'or:senderId': /* ... */}\n```\n\n# 타입 정의\n\n- 많은 메소드 내에서 트랜잭션 id에 대한 유형 정의가 수정되었으며, ChatTransactionData 인터페이스 내의 amount 속성 및 주 클래스의 options 내의 logLevel에 대한 유형 정의가 수정되었습니다.\n\nGitHub의 릴리스 노트를 확인하십시오: [여기](https://github.com/Adamant-im/adamant-api-jsclient/blob/master/CHANGELOG.md)\n","ogImage":{"url":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png"},"coverImage":"/assets/img/2024-06-22-adamant-apiv240isoutWhatschangedsincev200_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트js와 노드js를 활용한 풀스택 웹 애플리케이션 개발하기 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png)\n\n소개:\nReact.js와 Node.js는 효율성, 확장성 및 유연성으로 현대적인 웹 애플리케이션을 구축하는 데 인기 있는 선택지가 되었습니다. 이 블로그 포스트에서는 이러한 기술을 사용하여 풀 스택 웹 애플리케이션을 만드는 과정을 안내하겠습니다.\n\n필수 준비물:\n다음이 설치되어 있는지 확인하십시오:\n- Node.js (버전 14 이상)\n- npm (Node 패키지 관리자)\n- React.js (프론트엔드를 설정하기 위한 create-react-app)\n- Express.js (백엔드 서버를 설정하기 위해)\n\n단계 1: 환경 설정하기\n프로젝트용 새 디렉터리를 생성하고 프론트엔드와 백엔드를 설정하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nmkdir fullstack-app\ncd fullstack-app\n\n# 프론트엔드 설정하기 - create-react-app 사용\nnpx create-react-app client\ncd client\n\n# 백엔드 설정하기 - Express.js 사용\nmkdir server\ncd server\nnpm init -y\nnpm install express\n\n\n단계 2: 백엔드 API 생성하기\n`server` 디렉토리 내에 Express.js 서버용 `index.js` 파일을 만들어 보세요:\n\n```js\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\napp.get('/api/data', (req, res) =\u003e {\n  const data = [\n    { id: 1, name: 'John Doe' },\n    { id: 2, name: 'Jane Smith' },\n    // 필요한 만큼 데이터 추가\n  ];\n  res.json(data);\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n단계 3: React.js로 프론트엔드 설정하기\n`client` 디렉토리 (create-react-app에서 생성됨)에서 `App.js`를 수정하여 백엔드 API에서 데이터를 가져올 수 있도록 설정하세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\r\nimport React, { useEffect, useState } from 'react';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  const [data, setData] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetch('/api/data')\r\n      .then(res =\u003e res.json())\r\n      .then(data =\u003e setData(data))\r\n      .catch(err =\u003e console.error('데이터를 가져오는 중 오류가 발생했습니다:', err));\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv className=\"App\"\u003e\r\n      \u003ch1\u003e풀 스택 웹 애플리케이션\u003c/h1\u003e\r\n      \u003cul\u003e\r\n        {data.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.name}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\nStep 4: 애플리케이션 실행하기\r\n프론트엔드와 백엔드 서버를 동시에 실행하세요:\r\n\r\n\n# 'client' 디렉토리에서\r\nnpm start\r\n\r\n# 'server' 디렉토리에서\r\nnode index.js\r\n\n\r\n결론:\r\n이 블로그 포스트에서 React.js와 Node.js를 사용하여 풀 스택 웹 애플리케이션을 구축하는 기본적인 내용을 다뤘습니다. 환경을 설정하는 방법, Express.js를 사용하여 백엔드 API를 생성하는 방법, 그리고 백엔드에서 데이터를 가져와 React.js 프론트엔드에 표시하는 방법을 배웠습니다. 이 프로젝트를 확장하여 더 많은 기능을 추가하거나 MongoDB와 같은 데이터베이스를 통합하거나 Heroku나 AWS와 같은 플랫폼에 애플리케이션을 배포하는 등의 작업을 자유롭게 진행해보세요.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 많은 자료:\n\n- React.js 문서: [reactjs.org](https://reactjs.org/)\n- Node.js 문서: [nodejs.org](https://nodejs.org/)\n- Express.js 문서: [expressjs.com](https://expressjs.com/)\n\nReact.js와 Node.js의 더 심화된 주제를 탐색하여 풀스택 개발 능력을 향상시키세요. 떠오르는 기술들에 대한 더 많은 튜토리얼과 프로젝트를 기대해주세요!","ogImage":{"url":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaFull-StackWebApplicationwithReactjsandNodejsStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"로컬호스트에서 HTTPS를 실행하는 방법 단계별 안내","description":"","date":"2024-06-20 07:36","slug":"2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide","content":"\n\n로컬호스트에서 HTTPS를 실행하는 것은 안전한 웹 애플리케이션을 개발하고 테스트하는 데 필수적입니다.\n보안 소켓 계층(SSL) 또는 전송 계층 보안(TLS)은 인터넷을 통해 안전한 통신을 제공하는 방법을 제공합니다. 로컬호스트에서 HTTPS 서버를 실행하면 제품 서버에 배포될 때 웹 애플리케이션이 작동할 안전한 환경을 시뮬레이션할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png)\n\n이 안내서에서는 자체 서명된 인증서 및 Node.js 서버를 사용하여 로컬 머신에서 HTTPS를 설정하는 과정을 안내하겠습니다.\n\n#  준비 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에 다음 사전 요구 사항을 준비해 주세요:\n\n- Node.js 및 npm: 시스템에 Node.js 및 npm이 설치되어 있는지 확인하세요. 이것들은 nodejs.org에서 다운로드할 수 있습니다.\n- HTTPS의 기본 지식\n\n# 단계 1: 자체 서명 루트 인증서 생성\n\n첫 번째 단계는 자체 서명 루트 인증서를 생성하는 것입니다. 해당 인증서를 컴퓨터에 설치하고 서버에서 사용할 다른 인증서를 서명할 것입니다. 루트 인증서를 설치하면 해당 루트 인증서로 서명된 다른 인증서를 신뢰하는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 터미널이나 명령 프롬프트를 열고 인증서를 저장할 디렉토리로 이동하세요.\n- 다음 명령을 실행하여 루트 인증서용 개인 키를 생성하세요:\n\n```js\nopenssl genrsa -out root.key 2048\n```\n\n3. 이제 해당 개인 키를 사용하여 자체 서명된 루트 인증서를 생성하세요:\n\n```js\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. macOS를 사용 중이라면, root.crt 파일을 두 번 클릭하여 시스템의 신뢰할 수 있는 인증서에 루트 인증서를 추가할 수 있습니다. Keychain Access 애플리케이션이 열릴 것입니다. \"System\" 키체인을 선택한 후, \"추가\"를 클릭하여 root.crt 파일을 찾아 선택하고 다시 \"추가\"를 클릭합니다. 인증서가 신뢰할 수 있는 것으로 표시되었는지 확인해주세요.\n\n이러한 단계를 거친 후, 우리는 자체 서명 루트 인증서를 만들어 신뢰할 수 있는 저장소에 추가했습니다.\n\n# 단계 2: 서버 인증서 생성\n\n다음으로, 로컬호스트를 위한 서버 인증서를 만들 것입니다. 이 인증서를 사용하면 로컬 서버가 안전한 연결을 설정할 수 있습니다. 서버의 인증서를 루트 인증서로 서명하여 컴퓨터가 서버의 신뢰성을 보장할 수 있도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버용 개인 키 생성:\n\n```js\nopenssl genrsa -out server.key 2048\n```\n\n2. 서버용 개인 키를 사용하여 인증서 서명 요청 (CSR) 생성:\n\n```js\nopenssl req -new -key server.key -out server.csr\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이 명령은 공통 이름 (CN) 및 조직 세부 정보와 같은 CSR에 대한 일부 정보를 제공하도록 요구합니다. 공통 이름을 서버와 연결된 호스트명 또는 도메인 이름 (예: localhost)으로 설정해야 합니다.\n\n4. 루트 인증서로 CSR에 서명하여 서버 인증서를 만듭니다:\n\n```js\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n```\n\n5. 이 명령은 루트 인증서와 개인 키를 사용하여 CSR에 서명하고, 365일 동안 유효한 새로운 서버 인증서인 server.crt를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 거치면 서버에서 사용할 인증서를 만들고 PC가 신뢰하는 인증서로 설정합니다.\n\n# 단계 3: Node.js 서버 생성\n\n이제 서버 인증서를 준비했으니, HTTPS로 콘텐츠를 제공하기 위한 간단한 Node.js 서버를 만들어봅시다. 이 예시에선 Node.js와 Express 프레임워크를 사용하지만, 다른 언어와 프레임워크에 이 단계를 적용할 수도 있습니다.\n\n- server.js 라는 파일을 생성하고 다음 코드를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('~/certs/practice/server.key'), // 귀하의 키 경로로 대체하세요\n    cert: fs.readFileSync('~/certs/practice/server.crt'), // 귀하의 인증서 경로로 대체하세요\n}\n\nhttps.createServer(options, (req, res) =\u003e {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () =\u003e {\n  console.log('서버가 443 포트에서 실행 중입니다');\n});node\n```\n\n2. 파일을 저장한 후 터미널에서 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\nnode server.js\n```\n\n3. HTTPS 서버가 443 포트에서 실행 중이며, https://localhost 에서 액세스할 수 있습니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: 루트 인증서 신뢰 (macOS 전용)\n\n만약 macOS를 사용 중이라면, 루트 인증서를 신뢰하기 위해 다음 추가 단계를 따라주세요:\n\n- Keychain Access 애플리케이션을 엽니다.\n- 왼쪽 사이드바에서 \"시스템\" 키체인을 선택합니다.\n- \"파일\"을 클릭한 후 \"항목 가져오기\"를 선택하고 root.crt 파일을 선택합니다.\n- 가져온 인증서를 더블 클릭하고 \"신뢰\" 섹션을 확장한 후 \"이 인증서 사용 시\"를 \"항상 신뢰함\"으로 설정합니다.\n\n# 단계 5: 최종 스크립트 (옵션)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증서 생성 및 서버 설정을 자동화하려면 다음 스크립트를 사용할 수 있어요:\n\n```js\necho \"루트 서버 생성 중\"\nopenssl genrsa -out root.key 2048\nopenssl req -x509 -new -nodes -key root.key -sha256 -days 365 -out root.crt\n\necho \"서버 인증서 생성 중\"\nopenssl genrsa -out server.key 2048\nopenssl req -new -key server.key -out server.csr\nopenssl x509 -req -in server.csr -CA root.crt -CAkey root.key -CAcreateserial -out server.crt -days 365 -sha256\n\necho \"서버 파일 생성 중\"\ntouch server.js\necho \"\n// server.js\nconst app = require('express')();\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n    key: fs.readFileSync('/Users/akshitdev/certs/practice/server.key'),\n    cert: fs.readFileSync('/Users/akshitdev/certs/practice/server.crt'),\n}\n\nhttps.createServer(options, (req, res) =\u003e {\n  res.writeHead(200);\n  res.end('Hello, HTTPS World!');\n}).listen(443, () =\u003e {\n  console.log('서버가 포트 443에서 실행 중입니다');\n});\n\" \u003e\u003e server.js\n\necho \"서버를 루트에 추가 중\"\nsudo security add-trusted-cert -d -r trustRoot -k \"/Library/Keychains/System.keychain\" \u003c인증서_파일_경로\u003e\n\necho \"서버 실행 중\"\nnode server.js\n```\n\n이 스크립트를 사용하면 인증서 생성 및 서버 설정 과정을 자동화할 수 있어요.\n\n끝났어요! 셀프 사이닝된 인증서를 사용하여 로컬호스트에서 HTTPS를 성공적으로 구성했어요.","ogImage":{"url":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoRunHTTPSonLocalhostAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 앱에서 노드js 백엔드를 통해 API 호출 보안하기","description":"","date":"2024-06-20 07:35","slug":"2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend","content":"\n\n오늘날 연결된 세상에서 안전한 웹 앱을 만드는 것은 매우 중요합니다. 애플리케이션의 통신 링크는 민감한 사용자 데이터를 관리하거나 거래를 돕는 경우 모두 안전해야 합니다. 다른 이의 엿보는 데서 민감한 데이터를 보호하기 위해, 리액트 프로젝트에서 API 호출을 안전하게 하는 방법에 대해 살펴보면서 업계 모베스트 프랙티스를 준수합니다.\n\n소개\n프런트엔드와 백엔드 간의 통신을 보호하는 것은 웹 애플리케이션 보안에서 가장 중요한 부분 중 하나입니다. 이는 API 엔드포인트를 보호하고 데이터 통신을 암호화하며 강력한 인증 절차를 수립하는 것을 포함합니다. 이러한 안전장치를 구현함으로써 무단 접근, 데이터 유출 및 기타 보안 결함의 가능성을 줄일 수 있습니다.\n\n# Node.js 백엔드 설정하기\n\n우리의 여정은 Node.js와 Express.js를 사용하여 백엔드를 설정하는 것으로 시작됩니다. Express.js는 Node.js를 위한 인기 있는 웹 애플리케이션 프레임워크입니다. 우리는 인증 기능을 갖춘 간단한 RESTful API를 만들어 보호된 리소스에만 인증된 사용자가 접근할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 Node.js 백엔드에서는:\n\n- Express.js를 사용하여 서버를 생성하고 HTTP 요청을 처리합니다.\n- 인증은 현대적인 웹 애플리케이션에서 널리 사용되는 stateless 인증 메커니즘인 JSON Web Tokens (JWT)를 사용하여 구현됩니다.\n- 사용자 로그인 (/login) 및 보호된 데이터 검색 (/api/data)을 위한 라우트를 정의하고, 후자에 대한 인증을 강제합니다.\n\n```js\n// server.js\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\nconst SECRET_KEY = 'your_secret_key';\n\napp.use(express.json());\n\n// 사용자 데이터 모의 (실제 시나리오에서는 데이터베이스에서 검색됨)\nconst users = [\n  { id: 1, username: 'user1', password: 'password1' },\n  { id: 2, username: 'user2', password: 'password2' }\n];\n\n// JWT 토큰 생성을 위한 로그인 라우트\napp.post('/login', (req, res) =\u003e {\n  const { username, password } = req.body;\n  const user = users.find(u =\u003e u.username === username \u0026\u0026 u.password === password);\n  if (!user) {\n    return res.status(401).json({ message: '유효하지 않은 사용자 이름 또는 비밀번호' });\n  }\n  const token = jwt.sign({ userId: user.id }, SECRET_KEY);\n  res.json({ token });\n});\n\n// 보호된 라우트\napp.get('/api/data', verifyToken, (req, res) =\u003e {\n  res.json({ message: '보호된 데이터' });\n});\n\nfunction verifyToken(req, res, next) {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({ message: '인가되지 않음' });\n  }\n  jwt.verify(token, SECRET_KEY, (err, decoded) =\u003e {\n    if (err) {\n      return res.status(401).json({ message: '유효하지 않은 토큰' });\n    }\n    req.userId = decoded.userId;\n    next();\n  });\n}\n\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 http://localhost:${PORT}에서 실행 중입니다.`);\n});\n```\n\n# React로 프론트엔드 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드 설정이 완료되어, 이제 프론트엔드에 주력하게 됩니다. 리액트 애플리케이션을 구축하여 백엔드 API와 상호작용할 것입니다. 리액트 앱은 사용자 인증을 용이하게 하며, 보호된 데이터를 가져오기 위해 백엔드로 요청을 보냅니다.\n\n우리의 리액트 프론트엔드에서 주요한 부분은 다음과 같습니다:\n\n- React 컴포넌트 내에서 백엔드 엔드포인트에 HTTP 요청을 보내기 위해 fetch API를 사용합니다.\n- 성공적으로 인증된 후, JWT 토큰을 클라이언트의 로컬 상태에 저장합니다.\n- 토큰은 보호된 API 엔드포인트로의 후속 요청의 Authorization 헤더에 포함됩니다.\n\n```js\n// App.js\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [token, setToken] = useState('');\n  const [data, setData] = useState('');\n\n  const login = async () =\u003e {\n    const response = await fetch('/login', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ username: 'user1', password: 'password1' })\n    });\n    const { token } = await response.json();\n    setToken(token);\n  };\n\n  const fetchData = async () =\u003e {\n    const response = await fetch('/api/data', {\n      method: 'GET',\n      headers: {\n        'Authorization': token\n      }\n    });\n    const result = await response.json();\n    setData(result.message);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={login}\u003e로그인\u003c/button\u003e\n      {token \u0026\u0026 \u003cbutton onClick={fetchData}\u003e데이터 가져오기\u003c/button\u003e}\n      \u003cdiv\u003e{data}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# API 호출 및 데이터 전송 보안\n\nAPI 호출을 보호하는 것은 여러 층의 보호를 포함합니다:\n\n- HTTPS: 백엔드 API가 HTTPS를 통해 제공되도록하여 클라이언트와 서버 간에 전송되는 데이터를 암호화하여 도청과 변경을 방지합니다.\n- JWT 인증: JWT 토큰을 사용하여 클라이언트가 자신을 인증하고 안전하게 보호된 리소스에 액세스할 수 있도록 인증합니다.\n- 권한 부여: 민감한 정보에 액세스할 수 있는 사용자가 인증되었는지 확인하기 위해 보호된 엔드포인트에 권한 확인을 구현합니다.\n- 프록시된 요청: 클라이언트에게 백엔드 API의 세부 정보를 숨기기 위해 서버를 통해 요청을 프록시 처리하여 보안을 강화하고 백엔드 엔드포인트가 직접 노출되는 것을 방지합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 프로젝트에서 Node.js 백엔드와 API 호출을 할 때는 최상의 방법을 준수하고 견고한 보안 메커니즘을 적용하여 안전하게 보호할 수 있습니다. JWT 토큰으로 인증 설정부터 서버를 통해 요청 프록시하는 것까지, 각 단계는 미인가된 접근으로부터 민감한 데이터를 보호하고 잠재적인 보안 문제를 예방하는 데 중요합니다.\n\n데이터 프라이버시와 보안이 중요한 점이 갈수록 높아지는 현대 세계에서는 이러한 보안 원칙을 구현하는 것이 권장 사항뿐만 아니라 사용자 신뢰와 확신을 구축하기 위한 필수 요소입니다. 보안을 강조함으로써, 우리는 웹 애플리케이션이 증가하는 위협과 취약점에 강건하게 대응하여 사용자에게 안전하고 안전한 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png"},"coverImage":"/assets/img/2024-06-20-SecuringAPICallsinReactAppswithNodejsBackend_0.png","tag":["Tech"],"readingTime":5},{"title":"올바른 Docker 없이 Open WebUI를 설치하는 방법","description":"","date":"2024-06-20 07:33","slug":"2024-06-20-HowtoinstallOpenWebUIwithoutDocker","content":"\n\n![image](/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png)\n\n이 안내서는 도커 없이 올라마 웹 UI를 설정하는 방법을 안내합니다. 도커는 편의 및 지원을 위해 공식적으로 권장되지만, 이 매뉴얼 방법은 제약 사항이 있는 개발자나 환경에 유용할 수 있습니다. 기억하세요, 지원되지 않는 설치 문제 해결은 개별 노력이 필요할 수 있습니다.\n\n## 프로젝트 구성 요소:\n\n- 프론트엔드: 상호 작용하는 웹 인터페이스입니다.\n- 백엔드: 뒷면에서의 통신 및 기능을 처리합니다. 두 구성 요소는 동시에 실행되어야 개발할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 요구 사항:\n\n- Node.js `= 20.10`: 프론트엔드 빌드에 사용됨.\n\n- Python `= 3.11`: 백엔드 실행에 사용됨.\n\n- Ollama: 모델용.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시작해보자! 설치 단계:\n\n- Ollama 웹 UI 저장소를 복제하세요:\n\n```js\ngit clone https://github.com/open-webui/open-webui.git\n```\n\n- 프로젝트 디렉토리로 이동하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd ollama-webui/\n```\n\n- 환경 파일을 복사합니다:\n\n```js\ncp -RPp example.env .env\n```\n\n참고: 이 파일에는 설정과 구성이 저장됩니다. 필요에 따라 업데이트하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프론트엔드 빌드:\n\n- 노드를 사용하여 프론트엔드 빌드하기\n\n```js\nnpm install\n```\n\n```js\nnpm run build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 백엔드 시작:\n\n- 가상 환경 만들기:\n\n```js\ncd ./backend\n\n# virtualenv 패키지 설치\npip install -U virtualenv\n\n# backend 폴더에 가상 환경 생성\nvirtualenv venv\n\n# 가상 환경 활성화\nsource venv/Scripts/activate\n```\n\n- 백엔드와 함께 프론트엔드 제공\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npip install -r requirements.txt -U\n```\n\n```js\nbash start.sh\n```\n\n## Ollama 웹 UI에 액세스하기:\n\n- 웹 브라우저에서 http://localhost:8080/을 열어주세요. 인터페이스가 실행 중이어야 합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 및 문제 해결:\n\n에러가 발생하면 단서를 찾기 위해 콘솔 출력을 확인해보세요. 추가 구성 옵션 및 고급 기능에 대한 정보는 Ollama Web UI 설명서를 참조하세요. Docker가 아닌 설정은 공식적으로 지원되지 않으므로 문제 해결 작업에 대비해야 합니다.\n\nOllama Web UI를 즐기세요!\n\n이 튜토리얼은 Docker 없이 Ollama Web UI를 시작하는 데 도움이 될 것입니다. 일반적으로 Docker를 선호하지만 이 설명서 방식은 특정 상황에 대해 유연성을 제공합니다. 약간의 노력으로 이 강력한 대화형 도구를 시작할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoinstallOpenWebUIwithoutDocker_0.png","tag":["Tech"],"readingTime":2},{"title":"Node Boost 클러스터, 스레드","description":"","date":"2024-06-20 07:33","slug":"2024-06-20-NodeBoostClustersThreads","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png\" /\u003e\n\nNode.js 어플리케이션 성능 최적화 전략\n\n이 글에서는 이러한 상황을 효과적으로 관리하는 다양한 전략에 대해 살펴볼 것입니다.\n\n# 이벤트 루프 도전 이해하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js에서 이벤트 루프는 비동기 작업을 처리하는 핵심 개념입니다. 그러나 이벤트 루프 내에 너무 많은 작업이 존재하면 성능 병목 현상이 발생할 수 있습니다. 이 문제는 특히 많은 작업을 효율적으로 처리해야 하는 고성능 응용 프로그램에서 특히 중요해집니다.\n\n# 전략 1: Node.js 클러스터 모듈 활용\n\n성능 문제를 처리하는 효과적인 방법 중 하나는 Node.js의 클러스터 모듈을 활용하는 것입니다. 이 모듈을 사용하면 여러 인스턴스의 Node.js 애플리케이션을 각각 독립적인 이벤트 루프를 가지고 동일한 서버 포트를 공유하여 실행할 수 있습니다. 작동 방식은 다음과 같습니다:\n\n- 여러 Node 인스턴스: 클러스터 모듈을 통해 여러 Node.js 인스턴스를 생성할 수 있습니다. 각 인스턴스는 별도의 프로세스로 실행되어 응용 프로그램이 여러 CPU 코어를 효과적으로 활용할 수 있게 합니다.\n- 부하 분산: Node.js 클러스터 모듈은 여러 인스턴스 사이에 들어오는 요청을 분산하여 부하를 균형 있게 유지하고 단일 인스턴스에 병목 현상이 발생하지 않도록 합니다.\n- 성능 향상: 요청을 처리하는 여러 인스턴스가 존재하므로 애플리케이션 전체의 성능이 향상되며, 작업이 서로 다른 인스턴스 간에 동시에 처리되어 효율적으로 이루어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클러스터 모듈은 노드.js를 다중 스레딩으로 만들지는 않지만 병렬로 동작하는 여러 이벤트 루프를 생성하여 다중 스레딩을 시뮬레이트합니다.\n\n개요:\n노드.js의 클러스터 모듈은 애플리케이션이 CPU의 별도 코어에서 실행되는 노드.js 프로세스의 여러 인스턴스를 생성할 수 있도록 합니다. 이를 통해 부하를 분산시키고 무거운 작업에 의해 단일 인스턴스가 과부하되는 것을 방지할 수 있습니다.\n\n구현:\n\n- 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클러스터 모듈을 사용하여 Node.js 애플리케이션을 설정하세요.\n- 클러스터 모듈을 사용하여 기본 프로세스를 여러 워커 프로세스로 포크하세요.\n\n- 장점:\n  \n- 각 워커 프로세스는 독립적인 이벤트 루프를 실행합니다.\n- 부하가 여러 CPU 코어에 분산됩니다.\n- 스케일링 및 장애 허용성이 향상되며, 한 워커 프로세스의 실패가 다른 프로세스에 영향을 미치지 않습니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\nif (cluster.isMaster) {\n  for (let i = 0; i \u003c numCPUs; i++) {\n    cluster.fork();\n  }\n  cluster.on('exit', (worker, code, signal) =\u003e {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  http.createServer((req, res) =\u003e {\n    res.writeHead(200);\n    res.end('Hello World\\n');\n  }).listen(8000);\n}\n```\n\n# 전략 2: 워커 스레드 활용\n\n성능을 향상시키는 또 다른 방법은 워커 스레드를 사용하는 것입니다. 워커 스레드는 CPU 집약적인 작업을 실행하는 데 유용합니다. 다음은 워커 스레드를 통합하는 방법입니다:\n\n- 스레드 풀: Node.js에는 libuv 라이브러리를 통해 기본 스레드 풀이 포함되어 있습니다. 워커 스레드는 이 스레드 풀에 무거운 계산을 할당하여 주 이벤트 루프를 다른 작업 처리에 확보할 수 있습니다.\n- 병행성: 워커 스레드를 이용하면 작업이 병렬로 실행되어 응용 프로그램의 처리량과 응답성을 크게 향상할 수 있습니다.\n- 구현: 워커 스레드를 설정하는 것은 함수를 독립적으로 실행할 수 있는 스레드 풀을 만드는 과정을 포함합니다. 이 설정은 데이터 처리, 이미지 처리 및 복잡한 계산과 같은 작업에 이상적입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개요:\n워커 스레드는 여러 스레드에서 JavaScript를 병렬로 실행하여 중요한 계산을 메인 이벤트 루프에서 벗어나 실행하는 방법을 제공합니다.\n\n구현:\n\n- 설정:\n\n- worker_threads 모듈을 사용하여 워커 스레드를 생성합니다.\n- CPU 집약적인 작업을 이 워커 스레드에 위임합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 혜택:\n\n- 주요 스레드가 차단되지 않도록 무거운 계산을 완화합니다.\n- 하나의 Node.js 프로세스 내에서 다중 스레딩 기능을 활용합니다.\n- 애플리케이션의 반응성을 향상시킵니다.\n\n예시:\n\n```js\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\nif (isMainThread) {\n  const worker = new Worker(__filename);\n  worker.on('message', message =\u003e {\n    console.log(`Received message from worker: ${message}`);\n  });\n  worker.postMessage('Start work');\n} else {\n  parentPort.on('message', message =\u003e {\n    // 무거운 계산 수행\n    let result = heavyComputation();\n    parentPort.postMessage(result);\n  });\n  function heavyComputation() {\n    // 무거운 작업 시뮬레이션\n    let sum = 0;\n    for (let i = 0; i \u003c 1e9; i++) {\n      sum += i;\n    }\n    return sum;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최적의 방법과 권장 사항\n\n클러스터 모듈과 워커 스레드는 모두 상당한 성능 향상을 제공하지만, 적절한 사용 시나리오를 고려하는 것이 중요합니다:\n\n- 먼저 클러스터 모듈을 사용해 보세요: 대부분의 애플리케이션에 대해, 클러스터 모듈을 사용하는 것이 좋습니다. 이는 여러 CPU 코어를 효율적으로 활용하여 애플리케이션 코드를 크게 수정할 필요 없이 작동합니다.\n- CPU 집약적인 작업에 워커 스레드 활용: 애플리케이션이 무거운 계산 작업을 포함하는 경우, 워커 스레드를 통합하는 것을 고려해 보세요. 이 방법은 실험적이지만 특정 사용 사례에 대해 상당한 성능 향상을 제공할 수 있습니다.\n- 모니터링과 테스트: 항상 다양한 부하와 시나리오에서 애플리케이션의 성능을 모니터링하세요. 성능 테스트 도구를 사용하여 병목 현상을 식별하고 이러한 최적화의 영향을 평가하세요.\n\n# 성능 최적화를 위한 권장 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클러스터 모듈부터 시작해 보세요:\n\n- 클러스터 모듈은 성능을 향상시키는 것에 검증된 신뢰할 수 있는 방법입니다.\n- 개선된 부하 처리와 오류 허용이 필요한 애플리케이션에 이상적입니다.\n\n- 워커 스레드로 실험해 보세요:\n\n- 특정한 무거운 계산 작업이 있는 애플리케이션에 대해 워커 스레드를 사용하면 매우 효과적입니다.\n- 이 접근 방식은 실험적이지만 특정 사용 사례에 대해 상당한 성능 향상을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전략 통합:\n\n- 일부 시나리오에서는 클러스터 모듈과 워커 스레드를 결합하여 양쪽의 장점을 최대로 활용할 수 있습니다.\n- 이 하이브리드 방식은 시스템 리소스의 활용을 극대화할 수 있습니다.\n\n# 결론\n\n성능을 위해 Node.js 애플리케이션을 최적화하는 것은 클러스터 모듈과 워커 스레드와 같은 사용 가능한 도구를 전략적으로 활용하는 것을 포함합니다. 작업 부하를 효과적으로 분산하고 무거운 계산을 처리하는 방식으로 개발자는 애플리케이션이 반응적이고 효율적으로 유지될 수 있도록 할 수 있습니다. 신뢰성을 갖춘 클러스터 모듈부터 시작하여 특정 작업에 대해 워커 스레드를 통합하면 상당한 성능 향상이 기대됩니다. 이 알고리즘에 대한 이해를 더 깊이 파고 싶다면, 제 GitHub 저장소(algorithms-data-structures)를 탐험해보세요. 여기에서는 실험하고 연습하며 지식을 확고히 하는 데 도움이 되는 다양한 알고리즘 및 데이터 구조가 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언젠가는 완성될 예정인 몇 개 섹션들이 있습니다. 제 꾸준한 학습 여정을 반영한 것입니다. 이 프로세스는 완료되기까지 2-3년이 소요될 것으로 예상됩니다. 그러나 저장소는 끊임없이 발전하고 있습니다.\n\n탐험으로 끝나는 것이 아니에요! 여러분의 피드백을 소중히 생각합니다. 도전적인 상황을 마주했거나 건설적인 비평을 하고 싶거나 알고리즘과 성능 최적화에 대해 토론하고 싶다면 언제든지 연락해 주세요. Twitter에서 @m_mdy_m으로, Telegram에서는 @m_mdy_m으로 저에게 연락할 수 있습니다. 또한 GitHub 계정인 m-mdy-m에서 토론에 참여할 수도 있습니다. 지식을 공유하고 우리의 이해 범위를 넓히는 활기찬 학습 커뮤니티를 함께 만들어봐요. 함께 해요!","ogImage":{"url":"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png"},"coverImage":"/assets/img/2024-06-20-NodeBoostClustersThreads_0.png","tag":["Tech"],"readingTime":5},{"title":"우분투 2204, 2004 및 1804에서 Intel x64, AMD, ARM64 CPU용 Nodejs 20 설치하는 방법","description":"","date":"2024-06-20 07:32","slug":"2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png\" /\u003e\n\n이 이야기에서는 Intel/AMD 및 ARM64 CPU에서 실행 중인 Ubuntu 22.04, 20.04 및 18.04에 Node.js v20.x를 무인으로 설치하는 방법을 배우게 됩니다.\n\n# 가장 오래된 버전의 Node.js 삭제하기\n\n선택적 단계: Node.js 버전 20.x를 설치하기 전에 아래의 BASH 명령어를 사용하여 가장 오래된 Node.js 버전을 삭제할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\nsudo apt-get remove nodejs\n```\n\n## 우분투 Intel/AMD CPU에 NodeJS 설치 방법:\n\n아래는 INTEL/AMD CPU에 Node.js 버전 20.x를 설치하는 데 필요한 문장들입니다:\n\n```sh\nsudo apt update\nsudo apt install -y ca-certificates curl gnupg\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\nNODE_MAJOR=20\necho \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main\" | sudo tee /etc/apt/sources.list.d/nodesource.list\nsudo apt update\nsudo apt install -y nodejs\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 우분투 ARM64 CPU에 NodeJS 설치 방법:\n\n아래는 ARM64 CPU에서 Node.js 버전 20.x을 설치하는 데 필요한 문장들입니다:\n\n```js\nnodeVersion=20.14    \nsudo apt-get remove nodejs\nwget \"https://nodejs.org/dist/v${nodeVersion}.0/node-v${nodeVersion}.0-linux-arm64.tar.gz\"\ntar -xvf \"node-v${nodeVersion}.0-linux-arm64.tar.gz\"\nsudo cp \"node-v${nodeVersion}.0-linux-arm64\" \"/etc/node${nodeVersion}\" -r\nsudo ln -s \"/etc/node${nodeVersion}/bin/node\" /usr/bin/node\nsudo ln -s \"/etc/node${nodeVersion}/bin/npm\" /usr/bin/npm\n```\n\n# Node.js 설치 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 명령을 실행하여 설치가 완료되었는지 확인해보세요:\n\n```js\nguillermo@kopi-vm:~$ node -v\nv20.14.0\n```\n\n이게 전부에요! 만약 이 이야기를 좋아했다면, 👏을 눌러 지원을 보여주세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoInstallNodejs20onUbuntu22042004and1804forIntelx64AMDandARM64CPUs_0.png","tag":["Tech"],"readingTime":2},{"title":"자바스크립트와 타입스크립트에서 1, 2, 3에 3이 있는지 확인하면 왜 false인가요","description":"","date":"2024-06-20 07:31","slug":"2024-06-20-Why3in123falseinJavaScriptTypeScript","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png\" /\u003e\n\n안녕 친구들, 이번 주에는 몇 가지 재미있는 것들을 배웠어요. 오늘은 그 중 일부를 공유하고 싶습니다. 주제는 in 연산자에 대한 것이에요. 간단한 예제로 시작해보죠:\n\n```js\nconsole.log(3 in [1, 2, 3]) // false\n```\n\n의아하지 않나요? 3이 [1, 2, 3] 안에 없어요. 왜 그럴까요??? 그 이유를 알아보기 위해 in 연산자를 살펴보도록 해요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것에 대해 아시지 못하는 분들을 위해, in 연산자는 지정된 속성이 지정된 객체나 해당 프로토타입 체인에 있는지 확인하여 true를 반환합니다. (MDN에 따르면). 이해가 되지 않는다면, 아래에서 in 연산이 하는 일을 살펴봅시다:\n\n- 속성이 객체 자체에 있는지 여부를 확인합니다.\n- 속성이 객체에 있으면 true를 반환하고, 그렇지 않으면 이 객체의 부모 클래스를 확인합니다.\n- 단계 2는 이 JavaScript 및 TypeScript (Object 클래스)의 모든 객체의 부모 클래스를 확인할 때까지 반복됩니다. 속성이 존재하면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n이 개념을 설명하기 위해 빠른 예시를 살펴봅시다:\n\n```js\nclass Person {\n    constructor(public name: string, public age: number) { }\n}\n\nlet person: Person = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log('name' in person); // true\nconsole.log('age' in person); // true\nconsole.log('job' in person); // false\n\n// 결과\n// true\n// true\n// false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nperson 객체에는 이름과 나이가 있습니다. 따라서 `name` 및 `age`가 age에 대해 true를 반환하며, age도 마찬가지입니다. 그러나 person은 직업을 가지고 있지 않으므로 `job`은 person에서 false를 반환합니다.\n\n이제 Person 클래스를 상속한 Developer 클래스를 만들고 새로운 개발자 객체를 생성합니다:\n\n```js\nclass Developer extends Person {\n    constructor(name: string, age: number, public job: string) {\n        super(name, age);\n    }\n}\n\nlet developer: Developer = new Developer('John Doe', 24, 'Software Developer');\n\nconsole.log('name' in developer); // true\nconsole.log('age' in developer); // true\nconsole.log('job' in developer); // true\n\n// 출력\n// true\n// true\n// true\n```\n\n이제 developer 객체에는 job 속성이 있지만 명시적으로 이름과 나이가 없습니다. 이러한 속성은 Person 클래스에서 상속되었습니다. 그러나 `name` in developer는 여전히 true를 반환합니다. 왜냐하면 name은 Person 클래스의 속성이며 Developer 클래스가 이를 상속하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알았어요. 그건 운영 동작을 위한 것이에요. 간단하죠? 그런데 왜 '운영 동작은 위험하다'고 말할까요? 제 의견으로는 두 가지 주요 이유가 있어요.\n\n1. 배열에서 요소를 확인하기 위해 in을 사용\n\n먼저, 사람들은 일반적으로 배열에 요소가 포함되어 있는지 확인할 때 in을 사용해요. 이렇게 하면 위험한데요, 왜냐하면 이 경우 in이 기대한 대로 작동하지 않기 때문이에요. 간단한 예제를 통해 살펴볼게요:\n\n```js\nlet arr = [1, 2, 3];\n\nconsole.log(1 in arr); // true\nconsole.log(2 in arr); // true\nconsole.log(3 in arr); // false\n\n// 출력 결과\n// true\n// true\n// false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 1과 2와 잘 동작하는 것을 볼 수 있지만, 3에서는 그렇지 않다는 것을 알 수 있어요. 왜 그럴까요? JavaScript와 TypeScript에서 배열은 인덱스가 키이고 값이 값인 객체입니다. 다른 버전에서 이 예시를 다시 작성해보도록 할게요.\n\n```js\nlet arr = {\n    0: 1, 1: 2, 2: 3\n}\n\nconsole.log(1 in arr); // true\nconsole.log(2 in arr); // true\nconsole.log(3 in arr); // false\n\n// 출력\n// true\n// true\n// false\n```\n\n이 예시는 이전과 완전히 동일하지만, 배열 형태로 나타내지 않고 객체 형태로 다시 작성했어요. 이렇게 하면 arr[0] = 1, arr[1] = 2, arr[2] = 3를 볼 수 있죠. 이전과 마찬가지로, 이제 모든 것이 명확해졌어요. 사실 키 3은 arr에 없기 때문에 3 in arr은 false를 반환합니다. 이것이 글 맨 위의 질문에 대한 답이에요. 이 동작은 매우 위험하며 배열에 요소가 포함되어 있는지 확인할 때 in을 사용해서는 안 돼요. 대신 includes를 사용해야 해요.\n\n```js\nlet arr = [1, 2, 3];\n\nconsole.log(arr.includes(1)); // true\nconsole.log(arr.includes(2)); // true\nconsole.log(arr.includes(3)); // true\n\n// 출력\n// true\n// true\n// true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 정의되지 않은 속성과 함께 사용하기\n\n자바스크립트에서는, 객체가 특정 속성을 가지고 있지 않은 경우, 예를 들어 person이 직업을 가지고 있지 않으면 person.job = undefined가 됩니다 (이 동작은 자바스크립트에만 해당되며, TypeScript에서 person 객체의 job에 접근하려고 시도하면 오류가 발생합니다). 그래서 사람들(나 포함)은 일반적으로 undefined 값을 가진 속성은 객체에 해당 속성이 존재하지 않음을 의미한다고 생각합니다. 그러나 이 직관은 전혀 사실이 아닙니다. 예를 살펴보겠습니다:\n\n```js\ninterface IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\nperson.name = undefined;\n\nconsole.log(person.name, 'name' in person); // undefined true\n```\n\n명시적으로 person의 name을 undefined로 설정해도, `person`에 `name`이 여전히 true를 반환하는 것을 볼 수 있습니다. JavaScript와 TypeScript는 이 경우를 “name은 여전히 person 안에 있으며, 그저 정의되지 않았지만 여전히 존재한다”로 처리합니다. 이 경우는 디버깅하기 매우 어렵습니다. 왜냐하면 어디서 실수를 저질렀는지조차 알 수 없기 때문입니다. 그래서 우리가 해야 할 일은 무엇일까요? person.name = undefined로 설정하는 대신, 객체의 속성을 완전히 제거할 수 있는 삭제(delete) 작업이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\ndelete person.name;\n\nconsole.log(person.name, 'name' in person); // undefined false\n```\n\n\n아하, 그러니까 이제 없어졌네요. 속성을 삭제하지 않고 값을 undefined로 설정하고 싶다면 in 대신 !== 연산자를 사용할 수 있습니다:\n\n```js\n인터페이스 IPerson {\n    name?: string;\n    age: number;\n}\n\nlet person: IPerson = {\n    name: 'John Doe',\n    age: 24\n};\n\nconsole.log(person.name, 'name' in person); // John Doe true\n\nperson.name = undefined;\n\nconsole.log(person.name, person.name !== undefined); // undefined false\n```\n\n빠르게 다시 한 번 요약해보면\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본문 전체를 읽을 시간이 없는 분들을 위해 복습해 드릴게요:\n\n- 객체와 함께 작업할 때에만 in 연산자를 사용해야 하며, 배열과 함께 사용해서는 안 됩니다.\n- 속성을 undefined로 설정하는 대신에 완전히 제거하려면 delete 연산자를 사용하세요.\n- 만약 속성을 undefined로 설정하길 원한다면 in 연산자 대신 !== 연산자를 사용하세요.\n\n이번 글은 여기까지입니다. 읽어주셔서 감사합니다. 다음 흥미로운 글에서 만나요 :)","ogImage":{"url":"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png"},"coverImage":"/assets/img/2024-06-20-Why3in123falseinJavaScriptTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"LWC 인터뷰 질문 시리즈 1","description":"","date":"2024-06-20 07:28","slug":"2024-06-20-LWCInterviewQuestionsSeries1","content":"\n\n## (2024)\n\n![LWC Interview Questions](/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png)\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 개발 분야에서 동적이고 반응적인 사용자 인터페이스를 개발하는 강력한 도구입니다. 성능을 향상시키고 개발 프로세스를 더 효율적으로 만들어 주는 능력 덕분에 LWC는 현대 Salesforce 플랫폼 앱의 기본 구성 요소가 되었습니다. 자격 있는 LWC 개발자를 찾는 것은 이 기술을 완벽히 활용할 수 있는 유능한 팀을 구성하기 위해 매우 중요합니다.\n\n우리는 이러한 노력을 돕기 위해 개념적 이해와 현실 시나리오에 대한 LWC 인터뷰 문제를 철저하게 수집했습니다. 이러한 질문의 목적은 후보자의 문제 해결 능력, LWC 개발에 대한 전문 지식, 그리고 Salesforce 개발의 최선의 실천 방법의 적용을 평가하는 데 도움을 주는 것입니다. 이제 시작해 보겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주의 !\n\nLWC 인터뷰 준비는 압도적인 과제일 수 있습니다. LWC 개념, 최고의 실천 방법 및 실무 경험을 철저히 이해해야 합니다. 여러분의 여정을 돕기 위해 LWC 관련 다양한 주제를 다루는 면접 질문 목록을 엄선했습니다.\n\n이 블로그 시리즈에서는 LWC 개발자들이 면접에서 자주 묻는 개념 및 시나리오 기반의 LWC 인터뷰 질문을 모두 다루려고 노력했습니다.\n\n## 인터뷰 시리즈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번쨰 인터뷰 시리즈를 시작해볼까요? 라이트닝 웹 컴포넌트에 대해 얘기해보려고 해요. 인터뷰어와 인터뷰 대상자 사이에서 진행될거에요.\n\n# 개념적인 질문들:\n\n## 인터뷰어: 라이트닝 웹 컴포넌트(Lightning Web Components, LWC)란 무엇이고, Aura 컴포넌트와 어떻게 다른가요?\n\n## 인터뷔 대상자:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번개 웹 컴포넌트(LWC)는 Salesforce 플랫폼에서 번개 컴포넌트를 구축하기 위한 새로운 프로그래밍 모델입니다. 이는 ECMAScript 6와 같은 현대 웹 표준을 활용하여 Aura 컴포넌트와 비교하여 더 나은 성능을 제공합니다. Aura와 달리 LWC는 더 가벼운 프레임워크를 사용하며 웹 개발에 더 간단하고 표준 기반의 접근을 촉진합니다.\n\n## 주목하세요!\n\n여기서 인터뷰어는 위의 질문을 다른 방식으로도 할 수 있습니다.\n\n## 인터뷰어: LWC와 Aura 컴포넌트의 주요 차이점은 무엇인가요? 아키텍처, 성능 및 개발 경험을 비교해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터뷰ee: LWC와 헤일로 컴포넌트 사이의 차이점:\n\n## 1. 구조:\n\n헤일로 컴포넌트:\n\n- 클라이언트 측 JavaScript 프레임워크 및 서버 측 Apex 컨트롤러를 활용하는 Aura 프레임워크에 기반함.\n- 마크업, JavaScript 컨트롤러 및 스타일이 하나의 파일 내에 캡슐화된 컴포넌트 기반 구조를 따름.\n- 이벤트, 속성 및 메소드를 포함한 컴포넌트 간 통신을 위해 Aura 컴포넌트 모델을 활용함.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLWC (라이트닝 웹 컴포넌트):\n\n- W3C가 지원하는 최신 웹 컴포넌트 표준을 기반으로 한 웹 표준에 맞춰 개발되었습니다.\n- 형태, 자바스크립트 및 스타일을 위한 별도의 파일을 사용하여 모듈화 아키텍처를 따르며, 캡슐화를 위해 셰도우 DOM을 준수합니다.\n- 컴포넌트 개발을 위해 ECMAScript 모듈과 표준 DOM API를 활용하여, 다른 프레임워크와의 상호 운용성을 제공합니다.\n\n## 2. 성능:\n\nAura 컴포넌트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능은 프레임워크의 오버헤드와 통신을 위한 Aura 컴포넌트 모델의 사용으로 영향을 받을 수 있습니다.\n- 데이터 검색 및 업데이트를 위한 서버 라운드트립은 지연을 유발하고 전체적인 성능에 영향을 줄 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- Shadow DOM 및 가상 DOM과 같은 최적화 기술을 사용하여 원시 웹 표준을 사용하므로 성능이 향상됩니다.\n- 클라이언트 측 렌더링 및 최소한의 서버 라운드트립은 더 빠른 로딩 시간과 더 나은 응답성에 기여합니다.\n\n## 3. 개발 경험:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오로라 컴포넌트:\n\n- 개발 경험은 오로라 프레임워크의 학습 곡선과 복잡성에 의해 특징 지어질 수 있습니다.\n- 컨트롤러, 헬퍼 및 이벤트와 같은 오로라 특정 개념에 대한 친숙함이 필요합니다.\n- 오로라 개발에 대한 도구 지원은 다른 현대 웹 개발 프레임워크와 비교하여 더 제한적일 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- ECMAScript 6+ 기능과 표준 웹 API를 지원하여 더 간소화되고 현대적인 개발 경험을 제공합니다.\n- Salesforce CLI 및 VS Code 확장 프로그램과 같은 현대적인 도구를 활용하여 효율적인 개발 워크플로우를 위해 지원합니다.\n- 오로라와 비교하여 더 깨끗하고 직관적인 구문을 제공하여 코드의 가독성과 유지 보수성이 향상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개요: 전반적으로 LWC는 Aura 구성 요소에서 중요한 발전을 나타내며, Salesforce 플랫폼에서 구성 요소를 구축하기 위해 더 현대적이고 성능 중심적인 접근 방식을 제공합니다. Aura 구성 요소는 계속 지원되지만, LWC는 Salesforce 개발의 미래 방향으로 위치하고 있으며, 개발자들에게 더 효율적이고 확장 가능한 프레임워크를 제공하여 Lightning UI를 구축합니다.\n\n## 인터뷰어: LWC(Lightning Web Components)에서 데이터 바인딩 개념을 설명해 주세요. 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 통신을 어떻게 용이하게 하는가요?\n\n## 인터뷉이:\n\n라이트닝 웹 컴포넌트(LWC)에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 연결을 설정하는 메커니즘입니다. 이를 통해 두 요소 간에 데이터의 동기화를 가능케 하여 JavaScript 컨트롤러에서 수행한 변경 사항이 HTML 템플릿에 반영되고 그 반대도 성립합니다. 데이터 바인딩은 컴포넌트 내에서 무결한 통신과 상호작용을 용이하게 하며, 데이터나 사용자 입력의 변경에 따라 동적으로 업데이트하고 콘텐츠를 렌더링할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데이터 바인딩이 어떻게 통신을 용이하게 하는지:\n\n## 1. 속성 바인딩:\n\n- 속성 바인딩은 JavaScript 속성을 HTML 템플릿의 요소나 속성에 바인딩하는 데 사용됩니다.\n- 중괄호 구문 `''`을 사용하여 HTML 템플릿 내에서 JavaScript 속성을 참조합니다.\n- JavaScript 컨트롤러에서 속성 값이 변경되면 HTML 템플릿의 해당 요소나 속성이 자동으로 새 값으로 업데이트됩니다.\n- 마찬가지로 HTML 템플릿의 값이 변경되면 JavaScript 컨트롤러에 다시 반영됩니다.\n\n## 2. 이벤트 바인딩:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 바인딩을 사용하면 DOM 이벤트를 JavaScript 컨트롤러의 메서드나 함수에 바인딩할 수 있습니다.\n- HTML 템플릿에서 이벤트 바인딩을 지정하려면 이벤트 이름 뒤에 `on-` 접두사를 사용합니다.\n- 지정된 DOM 이벤트가 트리거될 때, JavaScript 컨트롤러의 연관된 메서드나 함수가 호출됩니다.\n- 이를 통해 컴포넌트의 로직 내에서 사용자 상호작용이나 브라우저 이벤트를 처리할 수 있습니다.\n\n아래는 LWC에서 데이터 바인딩을 보여주는 예시입니다:\n\nHTML 템플릿 (dataBinding.html):\n\n```js\n\u003c!--dataBinding.html--\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"Input Component Example\" variant=\"narrow\"\u003e\n    \u003cdiv class=\"slds-p-around_medium\"\u003e\n      \u003cp\u003e{message}\u003c/p\u003e\n      \u003cdiv class=\"slds-m-top_medium\"\u003e\n        \u003clightning-input type=\"text\" onchange={handleChange}\u003e\u003c/lightning-input\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript Controller (dataBinding.js):\n\n```js\n//dataBinding.js\nimport { LightningElement,track } from 'lwc';\n \nexport default class DataBinding extends LightningElement {\n  @track message = 'Initial message';\n \n  handleChange(event) {\n      this.message = event.target.value;\n  }\n}\n```\n\n## 이 예제에서:\n\n- HTML 템플릿에서 `'message'` 구문은 속성 바인딩을 나타내며, JavaScript 컨트롤러의 `message` 속성이 ``p`` 요소의 내용에 바인딩됩니다.\n- 입력 필드의 값이 변경될 때 (`onchange` 이벤트), JavaScript 컨트롤러의 `handleChange` 메서드가 호출되어 `message` 속성이 업데이트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로, ``p`` 요소의 내용이 `message` 속성의 새 값으로 자동으로 업데이트됩니다.\n\n## 결과:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*erCBAckytrHhVEgu.gif\" /\u003e\n\nLWC에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간에 원활한 통신을 용이하게 합니다. 이를 통해 컴포넌트의 UI 내에서 동적 업데이트와 상호 작용이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인터뷰어: 쉐도우 DOM이란 무엇이며, LWC가 어떻게 활용하는가?\n\n## 인터뷔이:\n\n쉐도우 DOM(쉐도우 문서 객체 모델)은 웹 컴포넌트의 기본 기능으로, 스타일, 마크업 및 동작을 문서의 나머지 부분과 분리된 범위 내에 캡슐화하는 것을 허용합니다. 이 캡슐화는 스타일 및 스크립트가 누출되지 않고 페이지의 다른 부분과 충돌하지 않도록 방지하여 더 나은 모듈성과 재사용성을 제공합니다.\n\n라이트닝 웹 컴포넌츠(LWC)에서는 쉐도우 DOM이 컴포넌트의 마크업과 스타일을 주변 문서와 격리시키는 데 활용됩니다. 이는 컴포넌트 내에서 정의한 스타일이 해당 컴포넌트의 쉐도우 DOM 내 요소에만 적용되도록 함으로써 페이지의 다른 컴포넌트나 요소와의 의도치 않은 스타일 충돌을 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시:\n\n간단한 LWC 컴포넌트인 helloWorld를 고려해 보겠습니다. 이 컴포넌트는 인사 메시지를 표시합니다:\n\n```javascript\n\u003c!-- helloWorld.html --\u003e\n\u003ctemplate\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003e{greeting}\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c/template\u003e\n```\n\n```javascript\n// helloWorld.js\nimport { LightningElement } from 'lwc';\n\nexport default class HelloWorld extends LightningElement {\n    greeting = 'Hello, World!';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는:\n\n- `helloWorld` 컴포넌트는 `greeting` 속성의 값을 표시하는 `h1` 제목이 있는 `div` 컨테이너로 구성됩니다.\n- `greeting` 속성은 JavaScript 파일에 정의되어 \"Hello, World!\" 값으로 초기화됩니다.\n\n## 결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`helloWorld` 컴포넌트가 렌더링되면 라이트닝 웹 컴포넌트 컨텍스트에서 자체 Shadow DOM을 생성합니다. 브라우저에 나타나는 결과물은 다음과 같습니다:\n\n```js\n\u003c!----shadow-root (open)----\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eHello, World!\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c!----/shadow-root----\u003e\r\n```\n\n``div class=”container”``와 ``h1`` 요소는 `helloWorld` 컴포넌트의 Shadow DOM 경계 내에 캡슐화됩니다. 이러한 요소에 적용된 스타일은 컴포넌트 내의 요소에만 영향을 미치므로 격리되어 의도치 않은 스타일 충돌을 방지합니다.\n\n요약하자면, LWC의 Shadow DOM은 컴포넌트 마크업, 스타일링, 동작을 캡슐화하는 메커니즘을 제공하여 향상된 모듈성, 재사용성, 그리고 컴포넌트 기능의 더 나은 캡슐화를 도모합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: LWC의 맥락에서 명령형과 선언형 프로그래밍을 구별하십시오.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)의 맥락에서 명령형과 선언형 프로그래밍은 컴포넌트를 구축하고 상호 작용하는 두 가지 다른 방식을 나타냅니다.\n\n## 명령형 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명령형 프로그래밍은 작업이 어떻게 수행되어야 하는지를 명시적으로 정의하는 상세한 지시 사항을 지정하는 것을 포함합니다. LWC의 맥락에서 명령형 프로그래밍은 일반적으로 DOM을 직접 조작하거나 외부 리소스와 상호 작용하기 위해 명령형 API 호출을 하는 것을 포함합니다.\n\nLWC에서의 명령형 프로그래밍 예시:\n\n```js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n \nexport default class ImperativeExample extends LightningElement {\n    recordId;\n    error;\n \n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터 처리\n        } else if (error) {\n            // 오류 처리\n        }\n    }\n \n    handleClick() {\n        // 레코드 데이터를 로드하기 위한 명령형 호출\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n## 선언적 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반면에 선언적 프로그래밍은 어떻게 해야 하는지 자세히 설명하지 않고 달성해야 할 목표를 지정하는 것을 포함합니다. LWC에서 선언적 프로그래밍은 주로 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능 및 기능을 활용하는 것을 포함합니다.\n\nLWC에서 선언적 프로그래밍의 예시:\n\n```js\n\u003c!--declarativeExample.html--\u003e\n\u003ctemplate\u003e\n    \u003clightning-card title=\"Declarative Example\"\u003e\n        \u003cdiv if:true={isDataLoaded}\u003e\n            \u003c!-- 데이터에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003e{accountName}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv if:true={error}\u003e\n            \u003c!-- 오류에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003eError: {error}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003clightning-button label=\"Load Data\" onclick={handleClick}\u003e\u003c/lightning-button\u003e\n    \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n//declarativeExample.js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n\nexport default class DeclarativeExample extends LightningElement {\n    recordId = '001XXXXXXXXXXXXXXX';\n    error;\n    accountName;\n    isDataLoaded = false;\n\n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터를 선언적으로 처리\n            this.accountName = data.fields.Name.value;\n            this.isDataLoaded = true;\n        } else if (error) {\n            // 오류를 선언적으로 처리\n            this.error = error.body.message;\n        }\n    }\n\n    handleClick() {\n        // 레코드 데이터 로드를 선언적으로 트리거\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 예시입니다:\n\n- `accountName`과 `isDataLoaded`는 컴포넌트 속성으로 초기화됩니다.\n- recordId는 JavaScript 클래스의 속성 `recordId`에 직접 할당됩니다. 이로써 `handleClick()` 내에서 `this.recordId = ‘001XXXXXXXXXXXXXXX’;`를 호출할 필요가 없어집니다.\n- 컴포넌트가 로드될 때, 와이어 어댑터를 사용하여 자동으로 계정 레코드의 이름을 불러옵니다.\n- 버튼 클릭 이벤트가 레코드 데이터 로드를 트리거하지만, 정적 recordId를 사용하기 때문에 시각적으로 변화는 없습니다.\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차이점:\n\nLWC에서 명령형과 선언적 프로그래밍의 주요 차이점은 구성 요소 동작이 어떻게 정의되고 구현되는지에 있습니다:\n\n## 1. 명령형 프로그래밍:\n\n- 작업을 수행하는 방법에 명확한 지시사항을 지정하는 것을 포함합니다.\n- 주로 DOM을 직접 조작하거나 명령형 API 호출을 하는 것을 포함합니다.\n- 더 많은 제어와 유연성을 제공하지만 길고 가독성이 떨어지는 코드로 이어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 선언형 프로그래밍:\n\n- 어떻게 해야 하는지를 명시하지 않고 무엇을 달성해야 하는지를 정의하는 것을 포함합니다.\n- 종종 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능을 활용하는 것을 포함합니다.\n- 구성 요소 동작을 정의하는 더 간결하고 표현력이 있는 방식을 제공하여 더 깨끗하고 유지보수가 쉬운 코드를 만들어줍니다.\n\nLWC 개발에서 명령형 및 선언형 프로그래밍 패러다임은 각각의 장소를 가지고 있으며, 개발자는 종종 구성 요소의 특정 요구사항과 복잡성에 가장 적합한 방법을 선택합니다.\n\n## 인터뷰어: LWC는 구성 요소 간 통신을 어떻게 용이하게 해주나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\nLWC는 구성 요소 통신을 위한 여러 메커니즘을 제공합니다. 속성 전달, 이벤트 처리 및 pub-sub 패턴을 포함합니다. 구성 요소는 속성과 속성을 통해 데이터를 교환하거나 이벤트를 발행하고 처리하거나 라이트닝 메시지 서비스나 플랫폼 이벤트를 사용하여 사용자 정의 이벤트에 가입함으로써 데이터를 교환할 수 있습니다.\n\n## 주의!\n\n여기서 인터뷰관은 위의 질문들을 다른 방식으로도 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: 라이트닝 웹 컴포넌트 간 통신하는 다양한 방법은 무엇인가요? 컴포넌트 이벤트, 공개 속성, 그리고 메소드의 사용법에 대해 비교하고 대조해보세요.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서는 컴포넌트 간 통신을 위한 여러 방법이 있으며, 각각의 사용 사례와 장단점을 갖고 있습니다. 주요 방법으로는 컴포넌트 이벤트, 공개 속성, 그리고 메소드가 포함됩니다. 이러한 접근 방식을 비교하고 대조해보겠습니다:\n\n## 1. 컴포넌트 이벤트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목적: 컴포넌트 이벤트는 컴포넌트 계층 구조에서 직접적으로 관려되지 않은 컴포넌트 간의 통신을 가능하게 합니다. 이를 통해 컴포넌트가 서로의 구현 세부 정보를 알 필요 없이 통신할 수 있는 느슨한 결합을 가능하게 합니다.\n\n사용법: 컴포넌트는 `CustomEvent` 생성자나 `dispatchEvent` 메서드를 사용하여 이벤트를 발송합니다. 다른 컴포넌트는 이러한 이벤트를 템플릿 안의 이벤트 핸들러를 통해 처리할 수 있습니다.\n\n예시:\n\n```js\n// 커스텀 이벤트 발송\nthis.dispatchEvent(new CustomEvent('customEventName', { detail: eventData }));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 컴포넌트를 분리함으로써 재사용성이 높아지고 모듈화가 용이해집니다.\n- 계층적 관계와 무관하게 컴포넌트 간의 통신이 가능합니다.\n\n단점:\n\n- 다른 방법에 비해 추가 설정과 오버헤드가 필요합니다.\n- 특히 초보자에게는 구현과 이해가 더 복잡할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 공개 속성:\n\n목적: 공개 속성은 컴포넌트에서 노출되는 속성으로, 다른 컴포넌트가 설정하거나 액세스할 수 있습니다. 부모-자식 간 통신을 가능하게 해 부모 컴포넌트가 데이터나 구성을 자식 컴포넌트에 전달할 수 있게 합니다.\n\n사용법: 공개 속성은 자식 컴포넌트에서 `@api` 데코레이터로 표시됩니다. 부모 컴포넌트는 자식 컴포넌트를 인스턴스화할 때 이러한 속성의 값을 설정합니다.\n\n예제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```html\n// 자식 컴포넌트\nimport { LightningElement, api } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    @api message;\n}\n```\n\n장점:\n\n- 구현하기 간단하고 직관적입니다.\n- 부모 및 자식 컴포넌트간의 통신을 용이하게합니다.\n\n단점:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 더 복잡한 통신 시나리오에는 사용할 수 없는 부모-자식 관계로 제한됩니다.\n- 컴포넌트 내부를 부모 컴포넌트에 노출하여 긴밀한 결합을 유발할 수 있습니다.\n\n## 3. 메서드:\n\n목적: 메서드를 사용하면 다른 컴포넌트에서 호출할 수 있는 기능을 노출시킬 수 있습니다. 부모-자식 및 자식-부모 간 통신을 가능하게 하여 컴포넌트가 상호작용하고 협업할 수 있습니다.\n\n사용법: 메서드는 컴포넌트의 JavaScript 클래스에서 정의되며 다른 컴포넌트에서 메서드 호출을 통해 호출될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\n// 하위 컴포넌트\nimport { LightningElement } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    handleClick() {\n        // 클릭 로직 처리\n    }\n}\n```\n\n장점:\n\n- 컴포넌트가 서로 기능을 호출하여 상호작용하고 협업하는 방법을 제공합니다.\n- 부모에서 자식으로, 그리고 자식에서 부모로 통신을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점:\n\n- 상호 참조를 가진 구성 요소에 제한되어 더 자유롭게 결합된 시나리오에는 사용이 제한될 수 있습니다.\n- 과도하게 사용되거나 잘못 사용될 경우 강력한 결합을 초래할 수 있습니다.\n\n요약하면, 구성 요소 이벤트, 공용 속성 및 메서드는 모두 라이트닝 웹 컴포넌트 간의 통신을 촉진하는 데 유용한 도구입니다. 어떤 방법을 사용할지 선택하는 것은 통신 시나리오의 특정 요구 사항, 관련된 구성 요소 간의 관계 및 원하는 캡슐화 및 결합 수준에 따라 달라집니다.\n\n## 인터뷰어: LWC에서 라이프사이클 훅의 개념을 설명해주세요. 사용 가능한 여러 라이프사이클 훅은 무엇이며, 구성 요소 라이프사이클 중에 언제 호출되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서의 라이프사이클 훅은 컴포넌트의 라이프사이클 중 특정 시점에 자동으로 호출되는 메서드입니다. 이러한 훅을 사용하면 초기화, 렌더링 및 소멸과 같은 컴포넌트의 라이프사이클의 다양한 단계에서 사용자 정의 로직을 실행할 수 있습니다. 라이프사이클 훅을 활용하여 데이터 초기화, 외부 리소스 가져오기 및 컴포넌트가 소멸될 때 리소스 정리와 같은 작업을 수행할 수 있습니다.\n\nLWC의 다양한 라이프사이클 훅:\n\n1. constructor():\n   생성자 함수는 생성자 메서드로서 객체 인스턴스가 생성될 때 호출되는 훅입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트가 생성될 때 호출됩니다.\n- 컴포넌트 속성 및 상태를 초기화하는 데 사용됩니다.\n\n예시:\n\n```js\nconstructor() {\n    super();\n    // 초기화 로직\n}\n```\n\n2. connectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에 구성 요소가 삽입될 때 호출됩니다.\n- DOM에 액세스가 필요한 설정 작업을 수행하는 데 사용됩니다.\n\n예:\n```js\nconnectedCallback() {\n    // 설정 작업\n}\n```\n\n3. renderedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소 템플릿 렌더링 후에 호출됩니다.\n- 렌더링된 DOM에 따라 동작을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nrenderedCallback() {\n    // DOM 조작\n}\n```\n\n4. disconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에서 구성 요소가 제거될 때 호출됩니다.\n- 리소스 정리 또는 정리 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\ndisconnectedCallback() {\n    // 정리 작업\n}\n```\n\n5. render():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트 템플릿을 렌더링하기 위해 호출됩니다.\n- 컴포넌트 UI의 구조와 내용을 정의하는 데 사용됩니다.\n\n예시:\n\n```js\nrender() {\n    return html`\u003cdiv\u003eHello, World!\u003c/div\u003e`;\n}\n```\n\n6. reconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소가 제거된 후 DOM에 다시 삽입될 때 호출됩니다.\n- 상태를 재설정하거나 설정 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nreconnectedCallback() {\n    // 초기화 작업\n}\n```\n\n라이프사이클 훅 호출:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성자(Constructor): 컴포넌트가 생성될 때 호출됩니다.\n- 연결된 콜백(Connected Callback): 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 렌더링된 콜백(Rendered Callback): 컴포넌트의 템플릿이 렌더링된 후 호출됩니다.\n- 연결 해제된 콜백(Disconnected Callback): 컴포넌트가 DOM에서 제거될 때 호출됩니다.\n- 렌더(Render): 컴포넌트가 템플릿을 렌더링해야 할 때 호출됩니다.\n- 다시 연결된 콜백(Reconnected Callback): 컴포넌트가 제거된 후 다시 DOM에 삽입될 때 호출됩니다.\n\nLWC(Lightning Web Components)에서 제공되는 라이프사이클 훅과 그 호출 순서를 이해함으로써, 개발자들은 컴포넌트 초기화, 렌더링 및 정리 작업을 효과적으로 관리하여 컴포넌트의 라이프사이클 동안 최적의 성능과 동작을 확보할 수 있습니다.\n\n더 궁금한 점이 있다면 아래 링크를 방문해주세요:\n\n희망하건대, 이번 Lightning Web Components (LWC) 인터뷰 시리즈가 LWC 개념에 관한 질문들을 명확히 이해하고 인터뷰에 성공하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png"},"coverImage":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png","tag":["Tech"],"readingTime":15},{"title":"리스코프 치환 원칙은 복잡하지 않아요 한 번 시도해 보세요","description":"","date":"2024-06-20 07:26","slug":"2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry","content":"\n\n## 리스코프 치환 원칙을 더 잘 이해할 수 있는 가이드\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png)\n\n# 소개\n\n우리 모두가 알다시피, 소프트웨어 요구 사항은 항상 변합니다. 그리고 우리 개발자로서는 이러한 변경으로 기존 코드가 망가지지 않도록 해야 합니다. 그래서 객체지향 설계에서 SOLID 원칙이 소개되었습니다. 이를 통해 이 프로세스를 더 쉽게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSOLID 원칙은 로버트 C. 마틴 (Bob 삼촌)이 만든 원칙 세트입니다. 이 원칙들은 더 유연하고 유지보수 가능하며 이해하기 쉬운 소프트웨어를 만드는 데 도움을 줍니다. 이 원칙들은 다음과 같습니다:\n\n- 단일 책임 원칙 (Single Responsibility Principle)\n- 개방-폐쇄 원칙 (Open-Closed Principle)\n- 리스코프 치환 원칙 (Liskov Substitution Principle)\n- 인터페이스 분리 원칙 (Interface Segregation Principle)\n- 의존성 역전 원칙 (Dependency Inversion)\n\n이전 글에서 개방-폐쇄 원칙을 소개한 후 이번 글에서는 SOLID 약어에서의 \"L\"인 리스코프 치환 원칙 (LSP)에 대해 논의하겠습니다.\n\n# 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수학적으로 LSP의 정의를 소개하고 자세히 알아보겠습니다. Barbara Liskov는 1988년에 이를 도입했습니다.\n\n기본 객체지향 설계는 상속 또는 구성을 사용하여 객체 간의 관계를 제어합니다. 상속은 IS-A 관계로, 어떤 것이 다른 것의 한 종류이면 발생합니다. 예를 들어, 말은 동물의 일종이라고 할 수 있습니다.\n\n반면에, 구성은 다른 것과의 HAS-A 관계로 이루어집니다. 예를 들어, 주소는 그와 관련된 도시를 가지고 있습니다. LSP는 객체지향 설계에 추가적인 제약을 가져와서 이러한 관계가 충분하지 않으며 IS-SUBSTITUTABLE-FOR로 대체되어야 함을 명시합니다.\n\n하지만 이것이 의미하는 바는 무엇일까요? 간단히 말해, 슈퍼타입은 서브타입으로 대체될 수 있어야 하며 기존 코드를 망가뜨리지 않고 대체될 수 있어야 합니다. 다시 말해, 슈퍼타입은 서브타입과 동일하게 동작해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 어떻게 우리가 슈퍼타입을 서브타입으로 교체해도 기존 코드에 부작용이 없는지 보장할 수 있을까요?\n\n# LSP은 OCP를 확장한다\n\n5가지 SOLID 원칙이 어떤 방식으로 연관돼 있는지 고려해 보세요. 하나의 원칙을 따르는 것이 다른 원칙을 올바르게 따르는 것을 보장하지 않는다는 점을 명심하세요.\n\n우리가 보게 되겠지만, LSP는 Open-Closed 원칙을 확장하며, OCP의 규칙을 따르는 것만으로는 코드가 확장을 허용하고 수정을 닫는지 보장할 수 없습니다. 하지만 코드는 부작용을 피하기 위해 리스코프 치환 원칙에도 준수해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 이 점을 더 잘 이해하는 데 도움이 되는 예시입니다:\n\n![예시 이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_1.png)\n\n보시다시피, 이 예시는 OCP를 완벽하게 따릅니다. 새로운 직원 역할을 추가하고 싶다면, 새로운 클래스를 추가하면 되며, 해당 클래스는 IEmployee 계약에 준수하는 새로운 역할 기능을 포함하면 됩니다.\n\n좋아 보이네요. 그러나 한 가지 질문이 있습니다. 게스트 역할을 어떻게 구현하겠습니까? 네, 게스트 역할은 listPosts를 수행할 수 있지만, 게스트 직원에 대한 인증이 없으므로 로그인 기능을 어떻게 처리할지 궁금합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 텍스트를 번역해 드리겠습니다.\n\n당신이나 빈 기능이 없이 빈칸으로 남겨 둘 수 있거나 로그인 메소드에서 지원되지 않는 예외를 throw할 수 있다고 생각해 볼 수 있어요. 네, 이런 해결책들은 LSP를 고려하지 않는다면 직관적일 수 있어요.\n\n다시 말해, OCP를 완벽하게 준수했다면 문제를 발생시키는 것이 LSP를 어기는 것이 무엇인지에 대해 물어볼 수 있습니다. 이 질문은 암묵적으로 옳은 점을 지적합니다: 일부 원칙이 다른 것보다 중요하다는 것을 의미합니다. 그러나 어떤 원칙이 중요하지 않다고 해서 무시해서는 안 됩니다.\n\n우리가 이미 알고 있듯이, LSP는 상위 유형과 하위 유형을 교체하더라도 기존 클라이언트 코드에 영향을 미치지 않는 것입니다. 이 점을 염두에 두고 다시 당신의 해결책들을 살펴보죠:\n\n- 기능이 없이 빈칸으로 남겨 둘 경우: 이제 클라이언트 코드는 인증된 사용자 토큰을 반환하는 로그인 함수를 기대합니다. 아무것도 반환하지 않는 Guest.login을 사용하면 어떻게 될까요? 기존 코드가 망가질 거예요, 맞죠?\n- 지원되지 않는 예외를 throw하는 경우: 다시 말해서, 기존 코드는 Guest.login으로부터 이 새로운 예외를 처리하지 않습니다. 결과적으로 Guest.login을 사용하면 기존 코드가 망가질 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의왕 교체하신 것에 깜짝 놀랐네요! 요 디자인은 OCP를 완벽하게 따르고 있어요. 그러나 LSP를 위반하고 있군요.\n\n# LSP 규칙\n\n![Liskov Substitution Principle](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_2.png)\n\n아쉽게도 이 원칙을 코드에 강제로 적용하는 쉬운 방법은 없어요. 그러나 코드에서 이 원칙을 올바르게 적용하려면 두 가지 유형의 규칙, 즉 서명과 동작을 따라야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바와 같은 컴파일된 언어를 사용하여 서명 규칙을 강제할 수는 있지만 행동 규칙을 강제할 수는 없습니다. 대신 특정 동작을 강제하기 위해 검사를 구현해야 합니다.\n\n## 먼저, 서명 규칙을 소개해 보겠습니다.\n\n1. 메서드 인수의 반변성: 이것은 보다 구체적인 유형에서 보다 일반적인 유형으로의 변환입니다. 다시 말해, 오버라이드된 서브 유형 메서드 인수는 수퍼 유형이나 더 넓은 유형과 동일해야 합니다.\n\n클라이언트 코드가 SuperType에서 문자열 인수만 예상한다면, 해당 SuperType을 문자열 또는 숫자 인수 (더 넓은)를 허용하는 SubType으로 대체하면 클라이언트 코드에는 차이점이 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 반환 유형의 공변성: 보다 일반적인 유형에서 보다 구체적인 유형으로 변환됩니다. 다시 말해, 오버라이드된 서브유형 메서드의 반환 유형은 수퍼유형이나 더 좁은 유형과 같아야 합니다.\n\n클라이언트 코드는 이미 슈퍼유형에서 오는 문자열이나 숫자 응답을 처리했습니다. 따라서 만약 슈퍼유형을 문자열 응답만 반환하는 서브유형으로 대체한다면, 클라이언트 코드가 손상되지 않을 것입니다.\n\n3. 예외: 서브유형 메서드는 슈퍼유형이나 더 좁은 예외를 던져야 합니다. 모든 컴파일된 언어가이 규칙을 강제할 수는 없습니다. Java와 같이 이를 강제할 수 있는 언어와 TypeScript와 같이 강제할 수 없는 언어가 있습니다.\n\n이전 규칙과 마찬가지로, 클라이언트 코드가 슈퍼유형에 더 많은 예외를 처리하도록 의존한다면, 이 슈퍼유형을 더 적은 예외를 처리하는 서브유형으로 대체한다 해도 클라이언트 코드에는 차이가 없을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그 다음, 행동 규칙을 소개할게요\n\n1. 클래스 불변성 (속성 규칙): 서브타입 메서드는 슈퍼타입의 클래스 불변성을 유지하거나 강화해야 합니다.\n\n서브타입은 같은 슈퍼타입의 불변성을 유지하거나 강화해야 합니다. 생각해보세요, 만약 서브타입이 같은 슈퍼타입의 불변성을 유지하지 않는다면, 슈퍼타입 대신 사용될 수 없으며 슈퍼타입에서 특정 동작을 기대하는 클라이언트 코드가 망가질 수 있습니다.\n\n2. 이력 제약 (속성 규칙): 서브타입 메서드는 슈퍼타입이 허용하지 않는 상태 변경을 허용해서는 안 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 SubType이 상속받은 제약을 무시한다면, 이는 이러한 제약에 의존하는 클라이언트 코드를 손상시킬 수 있습니다. 따라서 SubType은 SuperType으로 대체될 수 없습니다.\n\n2. 사전조건 (메서드 규칙): 서브타입 메서드는 오버라이드된 수퍼타입 메서드의 사전조건을 보존하거나 약화해야 합니다. 여기서 조건을 약화한다면 그 제약을 완화합니다.\n\n이전 예제에서, SuperType 조건 hour ` 0 \u0026\u0026 hour ` 12가 적용된 시간 입력을 제공하는 클라이언트 코드는 SubType에서 시간 ` 0 \u0026\u0026 시간 ` 23의 더 넓은 범위를 적용받습니다. 다시 말해, 부작용 없이 SubType이 SuperType을 대체할 수 있습니다.\n\n3. 사후조건 (메서드 규칙): 서브타입 메서드는 오버라이드된 수퍼타입 메서드의 사후조건을 보존하거나 강화해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제처럼 SuperType으로부터 반환된 값의 최댓값이 50이라고 클라이언트 코드가 기대한다면, 이를 SubType으로 변경하여 30의 최댓값을 반환하는 값으로 대체하면 유효해질 것입니다.\n\n# 나처럼 혼동스럽지 마세요\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_3.png)\n\n처음에는 Liskov 치환 원칙이 상속에 관한 모든 것이라고 생각할 수 있지만, 그렇지 않습니다. 이 원칙을 배우는 동안 많이 혼란스러웠기 때문에 이 점을 강조하기 위해 별도의 섹션을 할애하는 것을 선호했습니다. LSP는 상속을 사용할 때만 적용할 수 있다고 생각했었죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스코프 치환 원칙은 상속과는 아무런 관련이 없습니다. LSP는 단순히 서브타이핑에 관한 것입니다. 그럼에도 불구하고, 이 서브타이핑은 상속이나 합성에서 나올 수 있습니다. LSP는 상속과는 관련이 없기 때문에 상속을 사용하든 말든 LSP가 적용되는지 여부는 중요하지 않습니다. StackExchange의 이 해결책을 살펴보세요.\n\n그러므로, LSP와 상속 개념을 엄격하게 연결하지 마세요. 대신, 상속을 사용해야 할 때에 LSP를 염두에 두세요. \"LSP는 OCP를 확장한다\" 섹션 예제를 다시 살펴보세요.\n\n# LSP 위반\n\n![이미지](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 일반적인 LSP 위반 사례를 소개하고 LSP를 준수하도록 다시 디자인해보겠습니다.\n\n## 1. Type checking\n\n폴리모픽 코드 내부에서 변수의 유형을 확인하는 경우입니다. 아래 예제를 살펴보세요:\n\n코드에서 보듯이 이 루프는 직원 유형에 따라 두 가지 다른 기능을 수행합니다. 그러나 이 구현에서 어떤 문제가 있는 것일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 더 생각해보세요. 여기서 첫 번째 문제는 직원과 작업할 때마다, 특정 기능을 실행하기 위해 이 직원이 '게스트' 유형인지를 확인해야 할 수도 있다는 것입니다. 또 다른 유형인 경우 다른 기능을 실행해야 할 수도 있습니다.\n\n두 번째 문제는 추후 새로운 유형을 추가할 수 있으며, 이러한 새로운 유형을 지원하기 위해 이 확인이 존재하는 모든 곳을 방문해야 할 수 있다는 것입니다. 게다가 이는 개방-폐쇄 원칙을 위반하는 것이기도 합니다.\n\n그렇다면 이 문제를 어떻게 해결할 수 있을까요? 한 가지 해결책은 '말하고, 물어보지 말 것' 원칙 또는 캡슐화를 사용하는 것입니다. 이는 인스턴스에게 해당 유형에 대해 질문하고 조건부로 특정 작업을 실행하는 대신, 그 로직을 유형에 캡슐화하고 작업을 수행하도록 지시하는 것을 의미합니다. 이를 이전 예제에 적용해봅시다:\n\n## 2. Null checking\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 형식 검사와 동일한 동작을 갖습니다. 아래 예제를 확인해보세요. Guest 유형을 확인하는 대신, 이처럼 null 값에 대해 확인하고 있습니다. (employee === null) 이것은 LSP를 위반합니다.\n\n하지만 이 문제를 어떻게 해결할 수 있을까요? 이 문제에 대한 일반적인 해결책 중 하나는 Null Object 디자인 패턴을 사용하는 것입니다. 이 재설계를 살펴보세요:\n\n## 3. 구현되지 않은 예외 던지기\n\n이것은 인터페이스나 기본 클래스의 부분적 구현으로 인해 발생하는 일반적인 문제입니다. \"LSP extends OCP\" 섹션의 예제를 다시 살펴보세요. Guest 하위 유형의 login 메소드에서는 IEmployee 인터페이스 (상위 유형)를 완전히 구현할 수 없기 때문에 Not Implemented Exception을 던져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제의 해결책은 수퍼타입을 완전히 구현하는 것입니다. 이것이 인터페이스인지 기본 클래스인지에 상관없이요.\n\n하지만 때로는 예시처럼 인터페이스를 완전히 구현하는 것이 어려울 수 있다는 점을 주장할 수 있습니다. 맞아요. 그런 경우에는 수퍼타입과 서브타입 간의 관계를 더 신중하게 확인해야 할 것입니다. 서브타입이 이 수퍼타입의 대체 가능성을 충족하지 못할 수도 있으며, 다시 말해 인터페이스 분리 원칙을 위반한 것일 수 있습니다.\n\n# 결론\n\n이 글에서는 리스코프 치환 원칙을 소개했습니다. LSP가 객체 지향 설계에 새로운 제약 조건을 추가한다는 것을 이해했습니다. 이것은 관계만으로는 충분하지 않고 서브타입이 수퍼타입을 대체할 수 있는지 확인해야 한다는 것을 말합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 원칙을 올바르게 적용하기 위해 따라야 하는 규칙을 알고 계셨습니다. 그리고 이러한 규칙은 서명 및 행동 규칙으로 분류할 수 있습니다.\n\n이후에는 이 원칙을 위반하는 몇 가지 일반적인 사례들과 그에 대한 해결책을 소개했습니다.\n\n# 떠나시기 전에\n\n만일 이 글이 유용하다고 느끼셨다면, 아래의 글도 함께 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 단일 책임 원칙을 정말로 이해하고 계신가요?\n- 개방-폐쇄 원칙: 어려운 부분\n- 전략 vs 상태 vs 템플릿 디자인 패턴\n- SQL Server에서의 잠금 기반 격리\n\n지금까지 함께해 주셔서 정말 감사합니다. 이 기사를 읽으시는 데 즐거움이 있기를 바랍니다.\n\n![image](/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_5.png)\n\n# 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- C# 개발자를 위한 SOLID 원칙\n- 자바에서의 Liskov 대체 원칙\n- 코드 예제와 함께 설명하는 SOLID 디자인 원칙: Liskov 대체 원칙\n- 사전조건/사후조건 강화/약화에 대한 혼란\n- 이것이 Liskov 대체 원칙 위반인가요?\n\n원문은 https://mayallo.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png"},"coverImage":"/assets/img/2024-06-20-LiskovSubstitutionPrincipleIsntComplexJustGiveItaTry_0.png","tag":["Tech"],"readingTime":8}],"page":"30","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"30"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>