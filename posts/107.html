<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/107" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/107" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" href="/post/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" href="/post/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시작하기 JavaScript LLM 앱용 LangSmith" href="/post/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시작하기 JavaScript LLM 앱용 LangSmith" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시작하기 JavaScript LLM 앱용 LangSmith" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">시작하기 JavaScript LLM 앱용 LangSmith</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 Angular 17 기능 새로운 제어 흐름 구문" href="/post/2024-05-14-NewAngular17featurenewcontrolflowsyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Angular 17 기능 새로운 제어 흐름 구문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Angular 17 기능 새로운 제어 흐름 구문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 Angular 17 기능 새로운 제어 흐름 구문</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" href="/post/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 함수에 대한 인터뷰 개념" href="/post/2024-05-14-InterviewConceptsonJavaScriptFunctions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 함수에 대한 인터뷰 개념" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 함수에 대한 인터뷰 개념" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 함수에 대한 인터뷰 개념</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" href="/post/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기" href="/post/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내" href="/post/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용" href="/post/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link posts_-active__YVJEi" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JS를 사용하여 오디오 녹음하고 WAV 또는 MP3 파일로 백엔드에 업로드하기","description":"","date":"2024-05-14 14:17","slug":"2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png\" /\u003e\n\n우리 스타트업은 아이들이 화면에서 색칠된 템플릿을 생동감있게 만들 수 있게 해줘. 종이에 색칠된 템플릿을 업로드하여 디지털 세계를 구축하는 것만으로도 흥미로운 경험이지만, 우리는 아이들에게 추가로 동물에 대한 목소리를 녹음할 기회를 주고 싶었어.\n\n\u003cimg src=\"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_1.png\" /\u003e\n\n## 문제\n\n\n\n작업한 것을 기록합니다. 음성 녹음을 위한 MediaRecorder API 부분은 간단했지만, 업로드한 오디오 파일이 재생되지 않거나 손상된 것으로 보였습니다. 이는 브라우저가 mp3 또는 wav로 오디오를 기록하지 않고 webm으로 기록하기 때문입니다 (적어도 Chrome에서).\n\n우리가 할 일:\n\n- wav로 오디오 녹음\n- wav를 mp3로 변환\n- 오디오 파일을 서버에 업로드\n- 로컬 디스크 또는 S3에 파일 저장\n\n# 오디오 변환을 wav로 변경\n\n\n\n최종적으로 녹음을 mp3 파일로 변환하려면 먼저 wav 형식으로 변환해야 했습니다. 이를 위해 기본 MediaRecorder의 대체물인 확장 가능한 drop-in MediaRecorder인 chrisguttandin/extendable-media-recorder 라이브러리를 사용했습니다.\n\n다음과 같이 설치하세요:\n\n```js\nnpm install extendable-media-recorder\n```\n\n# 오디오 녹음\n\n\n\ngetUserMedia를 사용하여 오디오를 녹음하는 방법에 대한 많은 안내서가 있어요. 저는 간단하게 유효한 mp3 또는 wav 오디오 파일을 만드는 핵심 부분을 다룰 거에요.\n\n```js\nimport {MediaRecorder, register} from 'extendable-media-recorder';\nimport {connect} from 'extendable-media-recorder-wav-encoder';\n\nlet mediaRecorder = null;\nlet audioBlobs = [];\nlet capturedStream = null;\n\n// extendable-media-recorder-wav-encoder를 등록합니다.\nasync function connect() {\n  await register(await connect());\n}\n\n// 오디오 녹음을 시작합니다.\nfunction startRecording() {\n\n  return navigator.mediaDevices.getUserMedia({\n    audio: {\n      echoCancellation: true,\n    }\n  }).then(stream =\u003e {\n      audioBlobs = [];\n      capturedStream = stream;\n\n      // 확장된 MediaRecorder 라이브러리를 사용합니다.\n      mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/wav'\n      });\n\n      // 녹음 중 오디오 블롭을 추가합니다.\n      mediaRecorder.addEventListener('dataavailable', event =\u003e {\n        audioBlobs.push(event.data);\n      });\n\n      mediaRecorder.start();\n  }).catch((e) =\u003e {\n    console.error(e);\n  });\n\n}\n```\n\n그리고 녹음을 중지하는 함수:\n\n```js\nfunction stopRecording() {\n  return new Promise(resolve =\u003e {\n    if (!mediaRecorder) {\n      resolve(null);\n      return;\n    }\n\n    mediaRecorder.addEventListener('stop', () =\u003e {\n      const mimeType = mediaRecorder.mimeType;\n      const audioBlob = new Blob(audioBlobs, { type: mimeType });\n\n      if (capturedStream) {\n        capturedStream.getTracks().forEach(track =\u003e track.stop());\n      }\n\n      resolve(audioBlob);\n    });\n    \n    mediaRecorder.stop();\n    \n  });\n}\n```\n\n\n\n브라우저에서 오디오를 재생하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\n playAudio(audioBlob) {\n  if (audioBlob) {\n    const audio = new Audio();\n    audio.src = URL.createObjectURL(audioBlob);\n    audio.play();\n  }\n}\n```\n\n# Wav를 mp3로 변환\n\nWav를 mp3로 변환하기 위해 lamejs 라이브러리를 사용했어요:\n\n\n\n설치\n\n```js\nnpm install @breezystack/lamejs\n```\n\n이제 `convertWavToMp3` 함수를 만들고 녹음된 오디오Blob을 전달하여 mp3 Blob을 얻을 수 있습니다.\n\n```js\nimport * as lamejs from '@breezystack/lamejs';\n\nconvertWavToMp3(wavBlob) {\n  return new Promise((resolve, reject) =\u003e {\n    const reader = new FileReader();\n\n    reader.onload = function () {\n      const arrayBuffer = this.result;\n\n      // WAV 디코더 생성\n      // @ts-expect-error - 무슨 일인지 모르겠어요\n      const wavDecoder = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));\n\n      // WAV 오디오 데이터를 샘플 배열로 가져옴\n      const wavSamples = new Int16Array(arrayBuffer as ArrayBuffer, wavDecoder.dataOffset, wavDecoder.dataLen / 2);\n\n      // MP3 인코더 생성\n      const mp3Encoder = new lamejs.Mp3Encoder(wavDecoder.channels, wavDecoder.sampleRate, 128);\n\n      // WAV 샘플을 MP3로 인코딩\n      const mp3Buffer = mp3Encoder.encodeBuffer(wavSamples);\n\n      // MP3 인코딩 완료\n      const mp3Data = mp3Encoder.flush();\n\n      // MP3 헤더와 데이터를 새로운 ArrayBuffer로 결합\n      const mp3BufferWithHeader = new Uint8Array(mp3Buffer.length + mp3Data.length);\n      mp3BufferWithHeader.set(mp3Buffer, 0);\n      mp3BufferWithHeader.set(mp3Data, mp3Buffer.length);\n\n      // ArrayBuffer에서 Blob 생성\n      const mp3Blob = new Blob([mp3BufferWithHeader], { type: 'audio/mp3' });\n\n      resolve(mp3Blob);\n    };\n\n    reader.onerror = function (error) {\n      reject(error);\n    };\n\n    // 입력 Blob을 ArrayBuffer로 읽기\n    reader.readAsArrayBuffer(wavBlob);\n  });\n}\n```\n\n\n\n# 파일 업로드\n\n파일 업로드는 상당히 쉬운 부분이며 코드를 통해 자세하게 설명할 수 있어서 매우 쉽게 이해할 수 있을 겁니다:\n\n```js\n/**\n * 오디오 blob을 서버에 업로드합니다\n * @params {Blob} audioBlob - 오디오 blob 데이터\n * @params {string} fileType - 'mp3' 또는 'wav'\n * @return {Promise\u003cobject\u003e}\n */\nfunction uploadBlob(audioBlob, fileType) {\n  const formData = new FormData();\n  formData.append('audio_data', audioBlob, 'file');\n  formData.append('type', fileType || 'mp3');\n\n  // 오디오를 업로드하기 위한 서버 엔드포인트:\n  const apiUrl = \"http://localhost:3000/upload/audio\";\n\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    cache: 'no-cache',\n    body: formData\n  });\n\n  return response.json();\n}\n```\n\n# 전부 함께\n\n\n\n위의 모든 함수를 함께 사용하는 빠른 예제:\n\n```js\n// 초기화\nawait connect();\n\n// 사용자가 녹음 버튼을 클릭함\nstartRecording();\n\n// 사용자가 정지 버튼을 클릭하거나 정의된 시간 초과\nconst wavAudioBlob = await stopRecording();\n\n// 재미로: 재생\nplayAudio(wavAudioBlob);\n\n// mp3로 변환\n// 참고: mp3는 Chrome 및 Firefox에서만 작동했습니다\n// Safari는 이에 대한 호감을 잃어 보였으므로 Safari에는 .wav를 업로드했습니다\nconst mp3Blob = await convertWavToMp3(wavAudioBlob);\n\n// 서버에 블랍 업로드\nconst response = await uploadBlob(mp3Blob, 'mp3');\n```\n\ntry/catch를 사용하고 일부 변수가 null인지 확인하는 것이 좋습니다.\n\n# 파일 저장 — Flask\n\n\n\n오디오 파일을 엔드포인트에 POST한 후에는 저장을 원할 것입니다. Python Flask에서 파일을 로컬로 저장하거나 S3 버킷에 저장하는 방법을 보여드릴게요. 다른 언어(NodeJS, PHP 등)에서도 비슷하게 적용할 수 있어요.\n\n```js\ndef uploadAudio(request):\n\n  # 파라미터 가져오기\n  audio_file = request.files.get('audio_data')\n  file_type = request.form.get(\"type\", \"mp3\")\n  \n  # 파일명에 UUID 생성하는 것을 고려할 수 있어요\n  filename = \"myAudioFile.\" + file_type\n  \n  # 로컬 디스크에 저장하기\n  target_path = (\"your/local/dir/%s\" % filename)\n  audio_file.save(target_path)\n\n  # 또는: AWS S3에 파일 저장하기\n  session = boto3.Session(\"\"\" API 인증 정보 \"\"\")\n  s3 = session.resource('s3')\n  bucket = s3.Bucket(\"your-bucket-name\")\n  destination_dir = \"audiofiles/\"\n  response = bucket.upload_fileobj(audio_file, destination_dir, ExtraArgs={\n    \"ContentType\": \"audio/\" + file_type\n  })\n```\n\n버그를 발견하거나 개선 제안이 있다면 댓글로 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png"},"coverImage":"/assets/img/2024-05-14-RecordAudioinJSanduploadaswavormp3filetoyourbackend_0.png","tag":["Tech"],"readingTime":6},{"title":"더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들","description":"","date":"2024-05-14 14:16","slug":"2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity","content":"\n\n![Chrome DevTools JavaScript Debugging Features for Better Productivity](/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png)\n\n소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.\n\n현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).\n\n생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!\n\n\n\n# 변수와 표현식 감시하기\n\n디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.\n\nDevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if(s === 60) {\n    m++;\n    s = 0;\n  }\n}, 1000);\n```\n\n\n\n위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif)\n\n매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif)\n\n\n\n# 콘솔에서 디버거 컨텍스트 사용하기\n\n우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:\n\n```js\nfunction getMagicDate(d) {\n  if(d.getDate() % 2 === 0) {\n    d.setDate(d.getDate() + 2);\n  }\n  else {\n    d.setMonth(d.getMonth() + 1);\n  }\n  return d;\n}\n\ngetMagicDate(new Date());\n```\n\n먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:\n\n\n\n![Live Expressions](https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif)\n\n# 중단점 없이 실시간 표현식 만들기\n\n첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.\n\n이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:\n\n\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if (s === 60) {\n    m++;\n    s = 0;\n  }\n\n  console.log(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);\n}, 1000);\n```\n\n\n\n# 마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법\n\n자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:\n\n![예제](https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif)\n\n위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.\n\n\n\n우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif\" /\u003e\n\n공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.\n\n다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:\n\n\n\n# 이벤트 리스너 브레이크포인트 설정하기\n\n풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.\n\n다음 코드를 살펴보세요:\n\n```js\nlet btn = document.getElementById('btn');\nlet count = 0;\n\nbtn.addEventListener('click', (e) =\u003e {\n  btn.innerText = `Clicked ${++count} times`;\n});\n```\n\n\n\n우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif)\n\n위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.\n\n다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:\n\n\n\n# 네트워크 요청 중단점 사용하기\n\nXHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:\n\n![네트워크 요청 중단점](https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif)\n\n이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.\n\n\n\n# 호출 스택 검사\n\n개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.\n\n스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif)\n\n\n\n호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:\n\n읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png","tag":["Tech"],"readingTime":6},{"title":"시작하기 JavaScript LLM 앱용 LangSmith","description":"","date":"2024-05-14 14:14","slug":"2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps","content":"\n\n대용량 언어 모델(Large Language Models, LLM)의 파워를 LangSmith와 함께 발휘하세요: 시작부터 끝까지 AI 개발을 최적화해보세요!\n\n대용량 언어 모델(LLM) 위에 챗봇을 구축하고 있다고 상상해보세요. 감정 분석, RAG 검색 또는 문맥 이해와 같은 복잡한 기능을 통합할 때 예기치 않은 오류에 직면합니다. 이러한 문제를 해결하더라도 새로운 도전이 나타나고 앱에 작은 변경 사항이나 LLM의 업데이트로 인해 발생할 수 있습니다. LLM과 작업하면 마법 상자에 연결된 것처럼 느껴지기도 합니다. 때로는 결과가 놀라울 정도로 훌륭하고 때로는 그렇지 않을 수도 있습니다. 그들이 왜 그렇게 행동하는지, 그것이 앱에 어떤 영향을 미치는지 알기 어려울 때가 있습니다.\n\nLangSmith는 개발부터 모니터링까지 LLM 애플리케이션의 전체 라이프사이클을 최적화하는 포괄적인 데브옵스 플랫폼으로 이 문제를 해결합니다. 이 통합은 개발을 단순화하는 것뿐만 아니라 개발자들 사이의 신뢰를 높이고 품질을 보장하며 비용을 관리하고 지연 시간을 줄여, LLM 애플리케이션 개발을 더욱 접근 가능하고 효율적으로 만듭니다.\n\n본 문서에서는 LangSmith가 무엇인지, 왜 사용해야 하는지, 어떻게 사용해야 하는지, 그리고 런 트레이스 기능의 빠른 데모를 진행하겠습니다.\n\n\n\nLangSmith을 사용해야 하는 이유는 무엇일까요?\n\n- 포괄적인 개발 도구: LangSmith는 LLM 애플리케이션을 위한 맞춤형 개발 도구를 제공하여 상세한 호출 순서 가시성, 실시간 디버깅, 및 성능 최적화 기능을 제공합니다.\n- 고급 테스팅 및 평가: 이 플랫폼은 강력한 테스트 프레임워크와 AI 지원 평가를 제공하여 응답의 품질을 보장하며, 관련성, 정확성, 민감성을 포괄합니다.\n- 배포 및 확장성: LangSmith는 리소스 집약적인 LLM 애플리케이션의 배포와 확장을 간소화하여 성능 저하 없이 증가된 부하를 관리합니다.\n- 실시간 모니터링 및 분석: 종합적인 모니터링은 비용, 지연 시간, 품질을 추적하며, 실시간 분석을 통해 신속한 결정을 내릴 수 있도록 지원합니다.\n- 비용 관리: LangSmith는 LLM 프로젝트의 재정 측면을 관리하는 데 도움을 줌으로써 지출을 최적화하고 애플리케이션 효율성을 극대화하는 통찰을 제공합니다.\n- 협업 기능: 이 플랫폼은 공유 작업 공간, 버전 관리, 그리고 커뮤니케이션 도구로 팀워크를 강화하여, 지역 간 원활한 협업을 지원합니다.\n\n# 주요 기능\n\nLangSmith에는 많은 기능이 있으며 새로운 기능을 지속적으로 추가합니다. 여기 몇 가지 주요 기능을 살펴보세요:\n\n\n\n## 실행 추적\n\n추적은 LLM 애플리케이션의 동작을 이해하는 데 도움이 되는 강력한 도구입니다. 추적을 사용하면 예기치 않은 결과나 에이전트가 루프를 도는 이유, 실행이 느린 이유, 비용이 얼마나 드는지, 또는 고객이 최적의 응답을 받지 못하는 이유 등의 문제를 진단할 수 있습니다.\n\n## 주석이 달린 큐\n\n주석이 달린 큐는 데이터를 빠르게 순환하고 주석을 달 수 있는 사용자 친화적인 방법입니다. 사람들이나 LLM이 결과를 평가할 수 있는 워크플로우를 만들 수 있습니다. 이 데이터는 애플리케이션의 테스트 및 개선에 사용될 수 있습니다.\n\n\n\n## 데이터셋 및 테스트\n\n데이터셋은 업로드할 수도 있고 실제 실행에서 파생될 수도 있습니다. 그런 다음 이 데이터를 사용하여 응용 프로그램의 성능과 정확도를 측정하는 평가자를 사용하여 테스트를 실행할 수 있습니다.\n\n## 허브\n\n허브를 사용하면 LLM 프롬프트용 GitHub과 같은 협업, 테스트 및 공유가 가능합니다. 프롬프트를 효과적으로 작성하는 방법을 확인하는 데 도움되는 것뿐만 아니라 프롬프트를 관리하는 훌륭한 방법이기도 합니다.\n\n\n\n이 기사에서는 실시간 디버깅에 대해 자세히 살펴보겠습니다.\n\n# LangChain과 프로젝트 통합\n\nLangChain.js를 사용하여 간단한 앱을 만들었는데, 이는 LangSmith와의 통합 설정에 좋은 시작점을 제공할 것입니다.\n\n- 저장소 복제: git clone git@github.com:kenzic/simple-langsmith-demo.git\n- 의존성 설치: yarn\n- LangSmith 계정 등록\n- API 키 받기\n- OpenAI API 키 받기\n- .env.example을 .env로 이동하고 다음 값을 채워 넣으세요:\n\n\n\n```js\nLANGCHAIN_PROJECT=\"langsmith-demo\"\nLANGCHAIN_TRACING_V2=true\nLANGCHAIN_API_KEY=\u003cyour-api-key\u003e\n\n# OpenAI API를 사용하여 LLM에 호출을 하지만, LangSmith를 사용하는 데 필수적이지는 않습니다\nOPENAI_API_KEY=\u003cyour-openai-api-key\u003e\r\n```\n\n시작하기 전에 코드를 이해하는 데 1 ~ 2분 정도 소요되도록 사전에 시간을 투자해보세요. 이 코드는 높은 수준에서 다음과 같은 작업을 수행합니다:\n\n- 입력값 \"프랑스의 수도는 무엇인가요?\"로 앱을 호출합니다.\n- 대화 검색 체인 (RunnableSequence):\n  - 문서 검색 체인을 호출하여 컨텍스트를 추가합니다. 이는 사용자의 질문에 답변하기 위해 데이터를 가져오는 사용자 지정 검색기를 사용합니다 (RunnableMap).\n  - 문서 검색 체인에서 가져온 컨텍스트를 사용하여 사용자 질문에 대한 LLM 답변을 Mr. Burns의 억양으로 작성하는 프롬프트를 생성합니다 (ChatPromptTemplate).\n  - LLM을 호출합니다 (ChatOpenAI).\n  - 응답을 구문 분석하여 문자열로 반환합니다 (StrOutputParser).\n\n# 실습하기\n\n\n\n이 기사에서는 아마도 가장 강력한 기능인 실행 추적 및 디버깅 기능에 초점을 맞출 것입니다.\n\n이제 우리 앱을 테스트하고 디버깅할 준비가 되었어요!\n\n다음을 실행하여 시작하십시오: yarn start\n\n스크립트는 앱에 \"프랑스의 수도는 어디인가요?\"라고 묻습니다.\n\n\n\n우리가 받은 결과가 상당히 예상치 못한 것 같아요. 프랑스의 수도가 스프링필드라고 생각하고 있는 것 같아요. 이상하죠.\n\n우리 중 일부는 프랑스의 수도가 스프링필드가 아니라 파리임을 알고 있죠. 그래서 왜 이런 결과를 받는 걸까요? 게다가 앱이 답변을 제대로 주기까지 오래 걸리는 것 같아요. 이 부분을 빨리 처리할 수는 없을까요?\n\nhttps://smith.langchain.com/ 로 이동해서 \"langsmith-demo\" 프로젝트를 클릭해주세요. 프로젝트 내부에 들어가면 실행 기록을 볼 수 있어요. 최근 실행부터 시작해서 무슨 일이 일어나고 있는지 힌트가 있는지 확인해보겠어요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png)\n\n\n\n최상위 수준의 추적 결과 (RunnableSequence)를 살펴보면, 앱이 실행되는 데 3.33초가 걸리고 입력과 출력이 일치함을 볼 수 있지만 출력물은 명백히 잘못되었습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_1.png)\n\n다음 수준인 (RunnableMap)로 이동하면, 앱의 일부분이 LLM이 답변을 안내하는 데 사용할 문맥이나 지식을 검색하는 역할을 살펴볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_2.png)\n\n\n\n여기에서 무슨 일이 일어나고 있는지 빠르게 파악할 수 있어요. 저희 리트리버가 사실과 다른 정보를 제공하고 있네요. 이 데모에서는 \"프랑스의 수도는 파리입니다\"라는 내용으로 문서 내용을 바꿔서 수정할 수 있어요.\n\n쉬웠죠! 하지만 아직 앱이 조금 느린 것 같아요. 왜 그럴까요? 계속 추적해보면 ChatPromptTemplate은 잘 보이고 실행 시간은 0.00초가 걸리므로, 그 부분은 아닌 것 같아요.\n\n![image](/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_3.png)\n\n다음으로, ChatOpenAI 단계는 조금 느린데, 인터넷을 통해 요청을 보내고 있기 때문에 예상대로 그럴 수 있어요. 또한 OpenAI에 대한 호출이 총 139개의 토큰을 사용하여 총 $0.0001165를 소비했다는 점을 알려드릴게요. 앱이 더 복잡해지면 이 비용을 이해하기 위해 이 숫자에 주의해야 할 거예요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_4.png\" /\u003e\n\n마침내 StrOutputParser로 이동합니다. 실행 시간이 0.00초이고 출력을 올바르게 구문 분석했으므로 여기서 모든 것이 정상인 것 같습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_5.png\" /\u003e\n\n그래서 앱에서 병목 현상이 어디에 있는지 궁금하신가요? RunnableMap으로 돌아가 봅시다. 이 부분이 2.01초가 걸리는 것을 볼 수 있습니다. 한 개의 하드코딩된 문서를 반환하는 간단한 작업에 대해 이 시간은 높아 보입니다. 코드를 살펴보면 기능 slowLookupTask이 있음을 알 수 있습니다. 이 기능은 데모를 위해 인위적으로 만들어졌지만, 실제 시나리오에서는 검색기가 응용 프로그램의 지연 원인이 될 수 있으며, 종종 제어할 수 있는 부분 중 하나입니다.\n\n\n\n마침내 스크립트를 다시 실행합시다. 어떻게나! 이제 쿼리에 올바른 답변을 받아, 2초를 절약했습니다!\n\n## 다음 단계\n\nLangSmith의 능력의 일부에 불과하지만, 이 짧은 글이 어떤 가능성을 밝혀주기를 바랍니다.\n\nLangSmith의 디버깅 기능을 활용하여 더욱 탐험하면, 그 가능성을 최대로 발휘할 수 있습니다:\n\n\n\n- 고급 테스트 및 평가 도구를 활용하여 응답 품질을 지속적으로 확인합니다.\n- 비용 관리 통찰력을 활용하여 리소스 사용량 및 비용을 최적화합니다.\n- 공동 작업 공간, 버전 관리 및 빠른 라이브러리를 활용하여 협업을 촉진합니다.\n- 감정 분석 및 맥락 이해와 같은 고급 기능을 통합합니다.\n- LangSmith의 미래를 형성하기 위해 새로운 릴리스에 주목하고 LangSmith 커뮤니티에 참여하세요.\n\nLLM 애플리케이션은 발전함에 따라 LangSmith가 개발을 간소화하고 성능을 보장하며 AI 혁신을 이끌어내는 도구를 제공합니다.\n\n# 마무리\n\nLangSmith 소개를 마치고 대형 언어 모델 애플리케이션 개발 마스터에 한 발짝 다가가셨습니다. 이 안내서에서는 고대형 언어 모델 프로젝트의 개발 및 유지 관리를 간소화하기 위해 LangSmith와 LangChain을 설정하고 사용하는 방법을 개요로 설명했습니다.\n\n\n\n다룬 내용을 간단히 요약해 드리겠습니다:\n\n- 프로젝트를 LangChain과 LangSmith와 통합 설정하는 방법.\n- 애플리케이션을 이해하고 최적화하기 위해 실시간 디버깅 및 실행 추적을 활용하는 방법.\n\nLangSmith로 수행할 수 있는 많은 작업이 있습니다. 이에 관한 내용은 나중에 다룰 것이지만, 오늘 LangSmith를 사용하고 있지 않다면 기술 스택에 추가할 가치가 있다는 것을 확신시켜 드릴 수 있기를 바랍니다.\n\n연결 유지하고 여정을 공유하기 위해 아래 채널을 통해 언제든지 연락해 주세요:\n\n\n\n- 👨‍💼 LinkedIn: LLM 개발 및 기술 혁신에 대한 자세한 통찰력을 얻으려면 저와 함께하세요.\n- 💻 GitHub: 제 프로젝트를 살펴보고 지속적인 작업에 기여하세요.\n- 📚 Medium: LangSmith, LangChain 및 기타 AI 기술에 대한 보다 심층적인 토론을 위해 제 기사를 팔로우하세요.\n\n귀하의 피드백 및 협업은 귀중합니다. 행복한 개발하고 LangSmith로 만드는 놀라운 응용 프로그램을 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedLangSmithforJavaScriptLLMApps_0.png","tag":["Tech"],"readingTime":6},{"title":"새로운 Angular 17 기능 새로운 제어 흐름 구문","description":"","date":"2024-05-14 14:12","slug":"2024-05-14-NewAngular17featurenewcontrolflowsyntax","content":"\n\n# Angular의 새로운 선언적 제어 흐름을 시그널 기반 예시로 설명합니다\n\n![이미지](/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png)\n\nAngular 17은 11월 초에 출시될 예정이며, 선언적 제어 흐름을 갖는 새로운 템플릿 제어 블록 구문을 제공할 것입니다. 이 새로운 블록을 사용하는 두 가지 그룹의 특징이 있습니다:\n\n- 지연 로딩 블록: Angular 17은 블록 내용의 지연 로딩을 가능케 하는 @defer 제어 블록을 가집니다. 블록 내용의 종속 항목에도 지연 로딩이 적용됩니다: 모든 컴포넌트, 지시문 및 파이프도 지연 로딩이 될 것입니다. 이전 기사에서 defer 블록이 어떻게 작동하는지 예시로 보여드렸습니다.\n- 조건부 렌더링과 컬렉션 항목 렌더링을 제공하는 블록 (RFC): 이는 NgIf, NgFor 및 NgSwitch 지시문에 대한 대안입니다.\n\n\n\n이러한 새 제어 블록의 가장 중요한 이점 중 하나는 시그널을 통해 영역이 없는 애플리케이션을 지원한다는 것입니다.\n\n이 기사에서는 다음을 보여줍니다:\n\n- 새 제어 블록 구문을 사용하여 @if와 @else를 사용하여 조건에 따라 렌더링되는 블록 만들기\n- @switch, @case, @default를 사용하여 스위치 및 케이스 블록 만들기\n- @for를 사용하여 루프를 만들고 @empty 블록으로 빈 컬렉션을 처리하는 방법\n- ngIf, ngFor 및 ngSwitch를 새 제어 블록 구문으로 이전하는 방법\n\n전체 소스 코드는 여기에서 사용할 수 있습니다:\n\n\n\nhttps://github.com/gergelyszerovay/angular-17-control-flow\n\n저는 Angular v17.0.0-next.8을 사용했습니다. 독립 구성 요소와 시그널을 사용했습니다. 프론트엔드를 시작하려면 yarn run start 또는 npm run start를 입력하세요.\n\n# 조건적으로 렌더링되는 컨트롤 블록: @if 및 @else\n\n첫 번째 예제에서는 체크박스를 만들고 isChecked 시그널에 바인딩합니다. 시그널의 기본값은 true이므로 초기에 체크박스가 선택되고 @if 블록 내용이 렌더링됩니다. 아래 예제는 src\\app\\app.component.html 템플릿 파일에서 가져온 것입니다.\n\n\n\n```js\n\u003ch3\u003e\u0026#64;if and \u0026#64;else\u003c/h3\u003e\n\u003cdiv\u003e\n  \u003cinput #checkbox type=\"checkbox\" [checked]=\"isChecked()\" (change)=\"isChecked.set(checkbox.checked)\" id=\"checkbox\"/\u003e\n\u003c/div\u003e\n\u003cdiv\u003e\n@if (isChecked()) {\n  \u003cspan\u003eChecked\u003c/span\u003e\n} \n@else {\n  \u003cspan\u003eNot checked\u003c/span\u003e\n}\n\u003c/div\u003e\n```\n\n'@if (logical_expression)' 문은 논리 표현식을 사용하여 @if 블록을 생성합니다. 저는 논리 표현식으로 isChecked() 신호를 사용했는데, 이는 부울 값으로 평가됩니다.\n\n@else 블록을 @if 블록 아래에 추가했습니다. 이 블록은 @if 블록의 논리 표현식이 false로 평가될 때 렌더링됩니다. 즉, isChecked() 신호의 값이 false인 경우에 해당합니다. 따라서 체크박스를 해제하면 Angular가 @else 블록의 내용을 렌더링합니다.\n\n새로운 제어 블록 구문과 관련된 중요한 사항이 하나 더 있습니다: '@', '' 및 '' 문자에 특별한 의미가 있기 때문에 템플릿의 텍스트에서 이를 대체해야 합니다. HTML 엔티티를 사용해야 합니다:\n\n\n\n\n- '@' 대신에 \u0026#64;을 사용하세요. 위 코드의 'h3' 헤딩을 확인해보세요.\n- ' ' 대신에 \u0026#123;을 사용하세요.\n- ' ' 대신에 \u0026#125;을 사용하세요.\n\n그렇지 않으면 다음과 같은 컴파일 오류 중 하나가 발생할 수 있습니다:\n\n- [ERROR] NG5002: Incomplete block \"…\". If you meant to write the @ character, you should use the \"@\" HTML entity instead. [plugin angular-compiler]\n- [ERROR] NG5002: Unexpected character \"EOF\" (Do you have an unescaped \"'\" in your template? Use \"'' ‘'’ ''\") to escape it.)\n\n# Collection의 항목을 렌더링하기 위해 @for 블록 사용\n\n\n\n아이템 배열을 컴포넌트 클래스에서 정의해 봅시다:\n\n```js\ncollection = [\n    { id: 1, name: '아이템 1' },\n    { id: 2, name: '아이템 2' },\n    { id: 3, name: '아이템 3' }\n  ];\n```\n\n컬렉션 요소를 렌더링하기 위해 @for (item of items; track item.id) ' 블록을 사용할 수 있습니다:\n\n```js\n\u003cul\u003e\n@for (item of collection; track item.id; let index = $index, first = $first; let last = $last, even = $even, odd = $odd; let count = $count) {\n\u003cli\u003e\u003cstrong\u003e{item.name}\u003c/strong\u003e index={index} first={first} last={last} even={even} odd={odd} count={count}\u003c/li\u003e\n}\n\u003c/ul\u003e\n```\n\n\n\n컬렉션 내 각 항목은 고유한 속성(예: id와 같은)을 가져야 하며, 이 값을 track 인수로 참조해야 합니다. 컬렉션이 객체가 아닌 문자열이나 숫자를 포함하는 경우에는 항목 자체를 track 값으로 사용할 수 있습니다: @for (item of items; track item) '.\n\n현재 항목 옆에 @for 표현식을 사용하면 블록 내에서 다음 값에 액세스할 수 있습니다:\n\n- $index: 컬렉션 내 항목의 인덱스\n- $even: 인덱스가 짝수인 경우 true\n- $odd: 인덱스가 홀수인 경우 true\n- $count: 컬렉션 내 항목 수\n- $first: 현재 항목이 컬렉션 내 첫 번째인 경우 true\n- $last: 현재 항목이 컬렉션 내 마지막인 경우 true\n\n# @for에서 전달된 빈 컬렉션을 처리하기 위해 @empty 블록 사용하기\n\n\n\n@for 블록 아래에 @empty 블록을 추가할 수 있습니다. @empty 블록의 내용은 @for 블록에 전달한 컬렉션이 비어있을 때 렌더링됩니다:\n\n```js\n\u003cul\u003e\n@for (item of emptyCollection; track item.id;) {\n\u003cli\u003e\u003cstrong\u003e{item.name}\u003c/strong\u003e\u003c/li\u003e\n}\n@empty {\n  \u003cspan\u003e컬렉션이 비어 있습니다\u003c/span\u003e\n}\n\u003c/ul\u003e\n```\n\n# @switch, @case 및 @default로 제어 흐름 변경\n\n다음 예시에서 네 개의 라디오 버튼과 radioValue signal을 생성합니다. signal의 초기값은 1이며 사용자가 라디오 버튼을 클릭할 때 signal의 값이 1, 2, 3 또는 4로 변경됩니다:\n\n\n\n```js\n\u003cdiv\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 1\" (change)=\"radioValue.set(1)\" id=\"radio1\"/\u003e\n    \u003clabel for=\"radio1\"\u003e1\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 2\" (change)=\"radioValue.set(2)\" id=\"radio2\"/\u003e\n    \u003clabel for=\"radio2\"\u003e2\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 3\" (change)=\"radioValue.set(3)\" id=\"radio3\"/\u003e\n    \u003clabel for=\"radio3\"\u003e3\u003c/label\u003e\n  \u003c/div\u003e\n  \u003cdiv\u003e\n    \u003cinput type=\"radio\" [checked]=\"radioValue() === 4\" (change)=\"radioValue.set(4)\" id=\"radio4\"/\u003e\n    \u003clabel for=\"radio4\"\u003e4\u003c/label\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv\u003e\n```\n라디오 버튼 3개를 선택했습니다.\n```js\n@switch (radioValue()) {\n  @case (1) {\n    \u003cspan\u003eCase 1\u003c/span\u003e\n  }\n  @case (2) {\n    \u003cspan\u003eCase 2\u003c/span\u003e\n  }\n  @default {\n    \u003cspan\u003eDefault case (Not 1 or 2)\u003c/span\u003e\n  }\n}\n\u003c/div\u003e\n```\n\n\n\n앱 템플릿의 이전 구조 지시문을 새 제어 블록으로 변환하려면 다음 스키마틱을 실행하세요:\n\n```js\nng g @angular/core:control-flow-migration\n```\n\n# 요약\n\n본 문서에서는 Angular 17의 새로운 제어 흐름이 어떻게 작동하는지를 보여드렸습니다: 새로운 제어 블록 구문을 사용하여 조건부 블록 및 반복문을 만드는 방법을 안내했습니다. 내 튜토리얼이 유용했기를 바라며!\n\n\n\n이 기사 시리즈의 첫 부분에서는 새로운 지연 블록의 작동 방식과 이러한 블록 내용의 로딩 및 렌더링을 트리거할 조건을 지정하는 방법에 대해 설명했습니다: 새로운 Angular 17 기능: 지연 로딩.\n\n그리고 언제든지 피드백을 주시면 감사하겠습니다!\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이고, 프론트엔드 개발 챕터 리드로 일하고 있습니다. Angular 가르치기 (및 배우기)는 제 소질 중 하나입니다. Angular 관련 콘텐츠를 매일 소비합니다 — 기사, 팟캐스트, 컨퍼런스 강연 등을 포함하여요.\n\n\n\n저는 매달 발견한 최고의 자료를 여러분에게 보낼 수 있도록 Angular Addict 뉴스레터를 만들었어요. 경험 많은 Angular Addict 이든 초보자든 모두 대상입니다.\n\n뉴스레터 외에도 Angular Addicts라는 제 판에서 — 맞아요! — 수집한 가장 유익하고 흥미로운 자료들을 소개하고 있어요. 글쓴이로 참여하고 싶다면 언제든지 알려주세요.\n\n함께 Angular를 배워봐요! 여기서 구독하기 🔥\n\nSubstack, Medium, Dev.to, Twitter 또는 LinkedIn에서 저를 팔로우해서 Angular에 대해 더 많은 정보를 얻어보세요!","ogImage":{"url":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png"},"coverImage":"/assets/img/2024-05-14-NewAngular17featurenewcontrolflowsyntax_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 30의 새로운 지평을 제시하는 길잡이 브라우징 너머로 나아가기 - 파트 1","description":"","date":"2024-05-14 14:09","slug":"2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1","content":"\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png)\n\n웹 3.0의 개념은 2000년대 초반에 나타나기 시작했으며, 웹 2.0의 잠재적인 후속자로 손에 잡히는 관심을 끌었습니다. 그 시작 시기는 정확히 정해져 있지 않지만, \"웹 3.0\"이라는 용어는 2000년대 중반쯤에 기술자들과 사고 선도자들이 인터넷 진화의 다음 단계를 상상하기 시작함에 따라 널리 통용되었습니다.\n\n웹 3.0은 인터넷 진화의 혁명적인 단계로 생겨나며, 분산된 신뢰성 없는 프레임워크로 전통적인 표준을 깰 준비를 하고 있습니다. 이 개혁적인 패러다임 변화는 중앙화된 권한으로부터 벗어나 개인 이해관계자 간에 권력이 민주화된 시대를 예고하고 있습니다. 블록체인, 분산저장 및 스마트 계약과 같은 최첨단 기술을 활용하여, 웹 3.0은 조직이 운영에서 향상된 보안, 투명성 및 효율성을 추구하는 동력적 제안을 제시하고 있습니다. 이 대대적인 변화는 거래의 모습을 재정립 뿐만 아니라, 점차적으로 디지턀 배경에서 혁신을 받아들여 번영하기 위한 필요성을 강조합니다. 조직이 웹 3.0의 모습을 탐색하는 동안, 그들은 새로운 기회의 가능성을 풀고 산업의 궤도를 형성할 수 있는 변형적인 여정에 나서며, 보다 분산된, 유연한 및 포용적인 생태계로 향하는 전환적인 여정을 시작합니다.\n\n# 웹 2.0의 문제점과 웹 3.0의 발명을 이끈 문제들\n\n\n\n웹 2.0는 여러 측면에서 혁명적이었지만 몇 가지 문제와 제약도 함께 가져왔습니다. 이 기사에서 몇 가지를 강조하고 싶습니다:\n\n## 권력의 중앙화\n\n웹 2.0 플랫폼은 대부분 중앙 집중화되어 있어서 소수의 대형 기업이 사용자 데이터, 콘텐츠 배포, 플랫폼 운영에 상당한 통제력을 갖고 있습니다. 이 중앙 집중화는 검열, 데이터 유출, 그리고 통제된 상업 관행과 같은 문제로 이어질 수 있습니다.\n\n## 프라이버시 부재\n\n\n\n웹 2.0 기반 애플리케이션은 일반적으로 명확한 동의나 적절한 개인정보 보호 없이도 사용자 데이터를 대상으로 한 광고 및 기타 목적을 위해 방대한 양을 수집합니다. 이러한 프라이버시의 부족은 사용자 신뢰를 약화시키고 데이터 남용과 감시에 대한 우려를 야기할 수 있습니다.\n\n## 상호 운용성 도전\n\n현재의 애플리케이션은 종종 재고를 축적하여 사용자가 서로 다른 서비스와 애플리케이션 간의 데이터와 정보를 원할하게 전송하는 것을 어렵게 만듭니다. 이러한 상호 운용성의 부족은 혁신을 억제하고 사용자 선택을 제한하며 새로운 경쟁 업체에 대한 진입 장벽을 만들 수 있습니다.\n\n## 보안 취약점\n\n\n\n오늘날의 웹 2.0 기반 구현은 때로 보안 취약점과 데이터 유출에 노출될 수 있어서 사용자 정보를 위험에 빠뜨릴 수 있습니다. 데이터의 중앙 집중 저장 및 단일 장애 지점에 의존하면 사이버 공격 및 민감한 정보에 대한 무단 액세스 가능성이 증가합니다.\n\n![그림](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_1.png)\n\n## 이용자 제어의 제한\n\n웹 2.0에서 사용자는 자신의 데이터, 신원 및 디지털 자산에 대해 제한된 제어권을 갖고 있습니다. 플랫폼은 종종 서비스 약관을 지시하고 컨텐츠를 검열하거나 액세스를 제한하거나 사용자에게 별다른 대응 기회 없이 계정을 해지할 권한을 갖고 있습니다.\n\n\n\n## 수익 모델\n\n애플리케이션은 주로 광고 수익과 사용자 데이터 활용을 통해 수익을 창출합니다. 이는 플랫폼이 사용자의 복지보다는 사용자 참여 지표를 우선시하도록 장려하며, 부정한 행위와 관심 조작으로 이어질 수 있습니다.\n\n## 신뢰 문제\n\n플랫폼은 불투명한 알고리즘, 편향적인 콘텐츠 관리, 그리고 의사결정 프로세스의 투명성 부족으로 인해 신뢰 문제를 겪을 수 있습니다. 이는 온라인 정보와 상호 작용의 정직성과 신뢰성에 대한 사용자의 신뢰를 약화시킬 수 있습니다.\n\n\n\n# 웹 3.0의 핵심 원칙\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_2.png)\n\n## 분산화\n\n웹 3.0은 통제를 분산화하고 중앙 당국 또는 중개인에 의존성을 제거하려고 합니다. 소수 기업이나 개체의 손에 집중시키는 대신 사용자 네트워크 사이에서 권력을 분산시켜 더 견고하고 포용적이며 검열 방지혁 인터넷 생태계를 만들려고 합니다. 이더리움 블록체인에 배포된 탈중앙화 애플리케이션(DApp)과 상호 작용하기 위해 web3.js 라이브러리를 사용하는 다음 예제를 확인해보세요.\n\n\n\n```js\n// Web3.js 라이브러리를 가져옵니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 ('http://localhost:8545'를 자신의 이더리움 노드 URL로 바꿉니다)\nconst web3 = new Web3('http://localhost:8545');\n\n// 스마트 계약의 주소와 ABI (Application Binary Interface)를 정의합니다\nconst contractAddress = '0x1234567890123456789012345678901234567890'; // 귀하의 계약 주소로 대체합니다\nconst contractABI: any[] = [\n  // 귀하의 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n\n// 계약 인스턴스를 생성합니다\nconst contract = new web3.eth.Contract(contractABI, contractAddress);\n\n// 스마트 계약에서 데이터를 가져오는 함수\nasync function fetchData(): Promise\u003cvoid\u003e {\n  try {\n    // 스마트 계약의 getData 함수 호출\n    const data: number = await contract.methods.getData().call();\n    console.log('스마트 계약에서 검색된 데이터:', data);\n  } catch (error) {\n    console.error('데이터를 가져오는 중 오류 발생:', error);\n  }\n}\n\n// fetchData 함수 호출합니다\nfetchData();\n```\n\n## 상호 운용성\n\n웹 3.0의 개념은 서로 다른 플랫폼, 응용 프로그램 및 프로토콜간의 상호 운용성을 촉진합니다. 이는 다양한 생태계 간의 원활한 데이터 교환과 협력을 가능케 하며, 혁신을 촉진하고 사용자가 사일로된 데이터나 닫힌 시스템으로 제약받지 않고 웹을 더 유연하게 탐색할 수 있도록 합니다.\n\n다음은 서로 다른 네트워크에 배포된 두 개의 이더리움 기반 스마트 계약 간의 상호 운용성을 보여주는 TypeScript의 기본 예제입니다.\n\n\n\n```js\n// Web3.js 라이브러리를 가져와서 사용합니다\nimport Web3 from 'web3';\n\n// 이더리움 네트워크에 연결합니다 (이더리움 노드 URL과 네트워크 ID를 교체해주세요)\nconst web3NetworkA = new Web3('http://networkA:8545');\nconst web3NetworkB = new Web3('http://networkB:8545');\n\n// 네트워크 A에 배포된 첫 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressA = '0x1234567890123456789012345678901234567890'; // 네트워크 A의 계약 주소로 교체해주세요\nconst contractABIA: any[] = [\n  // 네트워크 A에 배포된 스마트 계약의 ABI\n  // 네트워크 A의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 네트워크 B에 배포된 두 번째 스마트 계약의 주소와 ABI를 정의합니다\nconst contractAddressB = '0x0987654321098765432109876543210987654321'; // 네트워크 B의 계약 주소로 교체해주세요\nconst contractABIB: any[] = [\n  // 네트워크 B에 배포된 스마트 계약의 ABI\n  // 네트워크 B의 계약과 상호작용할 메서드를 정의합니다\n];\n\n// 두 계약의 인스턴스를 생성합니다\nconst contractA = new web3NetworkA.eth.Contract(contractABIA, contractAddressA);\nconst contractB = new web3NetworkB.eth.Contract(contractABIB, contractAddressB);\n\n// 두 계약 간 데이터 전송하는 함수를 정의합니다\nasync function transferData(): Promise\u003cvoid\u003e {\n  try {\n    // 계약 A에서 데이터를 검색하는 메서드 호출\n    const data = await contractA.methods.getData().call();\n\n    // 계약 B에서 데이터를 설정하는 메서드 호출\n    await contractB.methods.setData(data).send({ from: '0x당신의주소', gas: 500000 });\n    \n    console.log('계약 A에서 계약 B로 데이터 전송 성공:', data);\n  } catch (error) {\n    console.error('데이터 전송 중 오류 발생:', error);\n  }\n}\n\n// 상호운용성을 보여주기 위해 transferData 함수 호출\ntransferData();\n```\n\n## 개인정보\n\n개인정보 보호는 Web 3.0의 핵심 원칙으로, 사용자가 개인 데이터를 제어하고 소유하는 것을 강조합니다. 사용자 데이터가 수집되고 이익을 위해 활용되며 침해를 받는 Web 2.0과는 달리, Web 3.0은 사용자의 개인 정보를 보호하는 메커니즘을 우선시합니다. 이는 분산 저장, 암호화, 자기 주권 식별 솔루션 등을 포함합니다.\n\n다음은 TypeScript를 사용한 간단한 예제로, 암호 기술과 분산 인증 메커니즘을 활용하여 사용자의 개인 정보 보호를 강화하는 웹3-react 라이브러리를 이용한 탈중앙화 애플리케이션(DApp)과 상호 작용하는 방법을 보여줍니다.\n\n\n\n```js\nimport { ethers } from 'ethers';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { useWeb3React } from '@web3-react/core';\n\n// 주입된 커넥터를 초기화합니다.\nconst injectedConnector = new InjectedConnector({ supportedChainIds: [1, 3, 4, 5, 42] });\n\n// 이더리움 프로바이더를 초기화합니다.\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n// 계정 세부 정보를 가져오는 함수\nasync function fetchAccountDetails(): Promise\u003cvoid\u003e {\n  try {\n    // 사용자의 이더리움 계정에 접근 권한을 요청합니다.\n    await provider.send('eth_requestAccounts', []);\n\n    // 서명자를 가져옵니다.\n    const signer = provider.getSigner();\n\n    // 사용자의 이더리움 주소를 가져옵니다.\n    const address = await signer.getAddress();\n\n    // 주소 출력\n    console.log('사용자 주소:', address);\n  } catch (error) {\n    console.error('계정 세부 정보 가져오기 오류:', error);\n  }\n}\n\n// 주요 함수\nasync function main(): Promise\u003cvoid\u003e {\n  // 계정 세부 정보 가져오기\n  await fetchAccountDetails();\n}\n\n// 주요 함수 실행\nmain();\n```\n\n## 사용자 권한 부여\n\n또한 사용자에게 온라인 경험, 아이덴티티 및 디지털 자산에 대한 더 큰 통제력을 제공하여 사용자들을 권한 부여하는 것을 목표로 합니다. Web 3.0에서 탈중앙화된 거버넌스, 자체 실행 스마트 계약 및 토큰화와 같은 기능을 통해 사용자들은 의사 결정 과정에 더 적극적으로 참여하고 새로운 경제적 기회에 접근하며 디지털 삶 소유권을 주장할 수 있습니다.\n\nTypeScript를 사용한 Web 3.0에서 사용자 권한 부여를 보여주는 간단한 예제로 탈중앙화된 아이덴티티(DID) 솔루션을 사용합니다. 이 예제에서는 이더리움에서 탈중앙화된 아이덴티티 관리의 인기 있는 선택인 uPort 라이브러리를 사용할 것입니다.\n\n\n\n\n```js\nimport { Connect, SimpleSigner } from 'uport-connect';\n\n// uPort 인스턴스 생성\nconst uport = new Connect('당신의앱이름', {\n  clientId: '당신의클라이언트아이디', // 여러분의 uPort 클라이언트 ID로 대체해주세요\n  signer: SimpleSigner('당신의개인키') // 여러분의 개인 키로 대체해주세요\n});\n\n// 사용자를 위한 탈중앙화 식별자(DID) 생성하는 함수\nasync function createDID(): Promise\u003cvoid\u003e {\n  try {\n    // 사용자에게 탈중앙화 식별자를 만들기 위한 동의를 요청함\n    const credentials = await uport.requestCredentials({\n      requested: ['name', 'avatar'], // 요청된 사용자 속성\n      notifications: true // 크리덴셜 요청을 위한 푸시 알림 활성화\n    });\n\n    // 사용자의 탈중앙화 식별자를 기록함\n    console.log('탈중앙화 식별자(DID):', credentials);\n  } catch (error) {\n    console.error('탈중앙화 식별자 생성 중 오류 발생:', error);\n  }\n}\n\n// 사용자를 위해 탈중앙화 식별자를 만들기 위해 createDID 함수 호출\ncreateDID();\n```\n\n# 웹 3.0에 대해 더 알아보기\n\n위의 기사에서 몇 가지 용어를 언급했는데, 분명 일부 용어가 블록체인과 관련이 있다는 걸 알아챘을 거예요. 그래서 우리는 블록체인이 웹 3.0을 위한 기술적 기반으로 작용한다고 할 수 있어요. 이제 웹 3.0 관련 용어 몇 가지 더 살펴봅시다.\n\n## 탈중앙화 애플리케이션 (DApp)\n\n\n\n분산 애플리케이션(DApp)은 블록체인 기술을 활용하는 분산 네트워크에서 작동하는 소프트웨어 응용 프로그램 유형입니다. 일반적으로 중앙화된 서버에 호스팅되고 단일 엔티티에 의해 제어되는 전통적인 애플리케이션과는 달리, DApp은 컴퓨터(노드)들의 동등 네트워크에서 실행되며 데이터와 작업이 네트워크 상으로 분산됩니다. DApp의 주요 특징으로는 분산화, 오픈 소스, 토큰화, 스마트 계약, 변경할 수 없는 데이터와 상호 운용성이 있습니다.\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_3.png)\n\n분산화 응용 프로그램의 몇 가지 예시로는 분산 재무(DeFi) 플랫폼, 분산 거래소 (DEX), 블록체인 기반 게임, 소셜 네트워크 및 공급망 관리 시스템 등이 있습니다.\n\n## 스마트 계약 및 ABI\n\n\n\n스마트 계약은 합의 조건이 직접 코드로 작성된 자체 실행 계약입니다. 이러한 계약은 이더리움과 같은 블록체인 네트워크에 저장되고 실행되며 중개인 없이 당사자 간의 합의 조건을 자동으로 시행합니다. 스마트 계약의 주요 특징으로는 자치성, 신뢰 없음, 보안, 투명성, 효율성 및 분산화가 있습니다.\n\n위 예제에서 스마트 계약인 다음 코드를 주목했을 것입니다:\n\n```js\nconst contractABI: any[] = [\n  // 스마트 계약 메서드의 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getData\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n];\n```\n\n![이미지](/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_4.png)\n\n\n\nABI는 \"Application Binary Interface\"의 약자입니다. ABI는 이더리움 블록체인에 배포된 스마트 계약의 인터페이스를 JSON으로 나타낸 것입니다. 스마트 계약의 메서드와 속성을 정의하며, 해당 메서드와 속성의 이름, 매개변수, 반환 유형 및 가시성을 포함합니다.\n\nABI는 탈중앙화된 응용프로그램(DApps)이나 스크립트와 같은 외부 응용프로그램에서 스마트 계약과 상호작용하는 데 중요합니다. ABI는 이더리움 가상 머신(EVM)과 외부 응용프로그램 사이의 다리 역할을 하며, 배포된 스마트 계약에서 함수를 호출하고 상호작용할 수 있게 합니다.\n\nAPI와는 다른 ABI에 대한 내용을 자세히 다룬 좋은 기사가 있습니다.\n\n## 검열 저항력\n\n\n\nWeb 3.0 아키텍처는 검열에 강하게 설계되어 시각과 표현의 자유를 지킵니다. 탈중앙화된 네트워크와 프로토콜을 통해 어떠한 단일 엔티티도 콘텐츠를 통제하거나 검열하는 것이 어렵게 되어, 정보가 모든 이에게 접근 가능하도록 보장됩니다.\n\n다음은 IPFS Helia를 사용한 간단한 TypeScript 예제로, 탈중앙화된 저장소가 검열에 대항하는 데 어떻게 기여할 수 있는지 보여줍니다:\n\n```js\n// IPFS Helia 불러오기\nimport IPFSHelia from 'ipfs-helia';\n\n// IPFS Helia 노드에 연결하기 ('localhost'를 IPFS Helia 노드 주소로 대체)\nconst ipfsHelia = new IPFSHelia({ host: 'localhost', port: '5002', protocol: 'http' });\n\n// IPFS Helia에 파일을 업로드하는 함수\nasync function uploadFile(): Promise\u003cstring\u003e {\n  try {\n    const fileContent = Buffer.from('Hello, world!', 'utf-8');\n\n    // 파일을 IPFS Helia에 업로드\n    const result = await ipfsHelia.add(fileContent);\n    const ipfsHash = result.cid.toString();\n\n    console.log('해시 값으로 IPFS Helia에 파일 업로드 완료:', ipfsHash);\n    return ipfsHash;\n  } catch (error) {\n    console.error('IPFS Helia에 파일을 업로드하는 중 오류 발생:', error);\n    throw error;\n  }\n}\n\n// 해시 값을 사용하여 IPFS Helia에서 파일을 검색하는 함수\nasync function retrieveFile(ipfsHash: string): Promise\u003cvoid\u003e {\n  try {\n    // IPFS Helia에서 파일을 검색\n    const fileBuffer = await ipfsHelia.cat(ipfsHash);\n    const fileContent = fileBuffer.toString();\n\n    console.log('IPFS Helia로부터 검색된 파일 내용:', fileContent);\n  } catch (error) {\n    console.error('IPFS Helia로부터 파일을 검색하는 중 오류 발생:', error);\n  }\n}\n\n// 파일을 IPFS Helia에 업로드\nuploadFile()\n  .then((ipfsHash) =\u003e {\n    // IPFS Helia로부터 업로드된 파일 검색\n    retrieveFile(ipfsHash);\n  })\n  .catch((error) =\u003e {\n    console.error('오류:', error);\n  });\n```\n\n## 향상된 확장성과 성능\n\n\n\n웹 3.0은 이전 웹의 확장성과 성능 문제에 대응하기 위해 노력합니다. 샤딩, 레이어 2 솔루션 및 개선된 합의 메커니즘과 같은 혁신들은 웹 3.0 플랫폼이 더 높은 거래 및 상호 작용의 부하를 더 효율적으로 처리할 수 있도록 합니다.\n\n## 토큰화와 디지털 자산\n\n웹 3.0은 자산과 서비스를 블록체인 네트워크 상의 디지털 토큰으로 표현하는 토큰화 개념을 소개합니다. 이로써 부분 소유권을 용이하게 만들고 유동성을 향상시키며 새로운 형태의 가치 교환과 통화화를 가능하게 합니다. 다음은 이더리움 블록체인에서 ERC-20 표준을 사용하여 토큰화와 디지털 자산을 설명하는 간단한 예시입니다.\n\n```js\nimport Web3 from 'web3';\nimport { Contract, ContractFactory } from 'ethers';\nimport { ethers } from 'hardhat';\n\n// 이더리움 네트워크에 연결하기 ('http://localhost:8545'를 사용 중인 이더리움 노드 URL로 대체하세요)\nconst web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));\n\n// ERC-20 토큰 컨트랙트 ABI\nconst tokenABI: any[] = [\n  // ERC-20 표준 메소드 ABI\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  // 다른 메소드들...\n];\n\n// ERC-20 토큰 컨트랙트를 배포하는 함수\nasync function deployTokenContract(name: string, symbol: string, initialSupply: number): Promise\u003cvoid\u003e {\n  try {\n    // 서명자 얻기\n    const signer = ethers.provider.getSigner();\n\n    // ERC-20 토큰 컨트랙트 배포\n    const tokenFactory = new ContractFactory(tokenABI, ERC20Token.bytecode, signer);\n    const tokenContract = await tokenFactory.deploy(name, symbol, initialSupply);\n\n    console.log('ERC-20 토큰 컨트랙트 배포됨:', tokenContract.address);\n  } catch (error) {\n    console.error('ERC-20 토큰 컨트랙트 배포 중 오류 발생:', error);\n  }\n}\n\n// deployTokenContract 함수를 호출하여 ERC-20 토큰 컨트랙트를 배포합니다.\ndeployTokenContract('MyToken', 'MTK', 1000000);\n```\n\n\n\n여기까지 도착했다면, 이 글의 제2부를 계속 읽고 싶은 것 같네요. 아래 링크에서 제2부를 확인해보세요. \n\n[https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220](https://vikeshm.medium.com/beyond-browsing-charting-the-course-to-web-3-0s-new-horizons-part-2-3bd670639220)","ogImage":{"url":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png"},"coverImage":"/assets/img/2024-05-14-BeyondBrowsingChartingtheCoursetoWeb30sNewHorizonsPart1_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 함수에 대한 인터뷰 개념","description":"","date":"2024-05-14 14:08","slug":"2024-05-14-InterviewConceptsonJavaScriptFunctions","content":"\n\n![image](/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png)\n\n이 기사는 현재 작업 중인 JavaScript 인터뷰 컨셉을 준비하는 데 도움이 되는 안내서를 기반으로 합니다. 처음 두 장(chapter)는 지금 무료로 다운로드할 수 있습니다. 가이드에 대한 피드백을 주시면 감사하겠습니다.\nPDF 다운로드 링크는 여기에 있습니다. [PDF 다운로드 링크](https://9820419704756.gumroad.com/l/gdycz)\n\n이제, 이 기사의 주제로 넘어가 봅시다!\n\nJavaScript에서 함수를 여러 가지 방법으로 만들 수 있습니다.\n\n\n\n'function' 키워드를 사용하여 함수를 생성할 수 있습니다. 이를 함수 선언이라고 합니다. 아래는 예시입니다:\n\n```js\nfunction addNumbers(a, b) {\n  return a + b;\n}\n```\n\n이 예시에서 'addNumbers'라는 함수를 선언했습니다. 두 개의 인수 'a'와 'b'를 받습니다. 함수의 코드 블록에서는 + 연산자를 사용하여 두 인수를 더한 후 결과를 반환합니다.\n\n함수 선언을 사용하는 장점 중 하나는 호이스팅이 가능하다는 것입니다. 즉, 선언되기 전에 호출할 수 있다는 의미입니다.\n\n\n\n기능 표현식: 함수 표현식은 함수를 변수에 할당하여 선언하는 방법입니다. 예시입니다:\n\n```js\nconst multiply = function(a, b) {\n  return a * b;\n}\nconsole.log(multiply(2,3)); // 결과: 6\n```\n\n함수 표현식을 사용하는 장점은 다른 함수에 인수로 전달할 수 있다는 것입니다.\n\n화살표 함수: 화살표 함수는 JavaScript에서 함수를 선언하는 새로운 방법이며 `=` 연산자를 사용합니다. 여기 예시가 있습니다:\n\n\n\n```js\nconst divide = (a, b) =\u003e {\n  return a / b;\n}\nconsole.log(divide(6,3)); // 출력: 2\n```\n\n화살표 함수는 간결한 구문을 가지고 있어서 함수가 충분히 간단하다면 한 줄로 작성할 수 있습니다.\n\n익명 함수: 익명 함수는 이름이 없는 함수로 다른 함수의 매개변수로 사용됩니다. 다음은 예시입니다:\n\n```js\nconst numbers = [1, 2, 3, 4];\nconst double = numbers.map(function(num) {\n  return num * 2;\n})\nconsole.log(double); // 출력: [2, 4, 6, 8]\n```\n\n\n\n익명 함수를 사용하는 장점은 다른 함수의 콜백 함수로 사용할 수 있다는 것입니다.\n\n면접에서 기대할 수 있는 질문\n\n자바스크립트에서 함수 범위의 개념을 설명해주세요.\n\n함수 범위는 함수 내에서 변수의 가시성을 의미합니다. 함수 내에서 선언된 변수는 해당 함수 내에서만 지역 변수로써 사용되며 외부에서 접근할 수 없습니다. 이는 명명 충돌을 방지하고 캡슐화를 촉진하는 데 도움이 됩니다.\n\n\n\n```js\nfunction greet() {\n  let message = \"Hello!\";\n  console.log(message); // \"Hello!\"\n}\ngreet();\nconsole.log(message); // Uncaught ReferenceError: 'message' is not defined\n```\n\nJavaScript에서 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 함수의 인수로 전달되어 외부 함수 내에서 호출되는 함수를 말합니다. 콜백 함수는 주로 비동기 작업, 이벤트 처리 및 고차 함수에서 사용됩니다.\n\n```js\nfunction doSomething(callback) {\n   console.log(\"작업 중...\");\n   callback(); // 콜백 함수 실행\n}\nfunction callbackFunction() {\n   console.log(\"콜백 함수 실행됨!\");\n}\n// doSomething에 callbackFunction을 콜백으로 전달\ndoSomething(callbackFunction);\n// 출력\n/* \"작업 중...\"\n\"콜백 함수 실행됨!\"\n*/\n```\n\n\n\n자바스크립트에서 고차 함수란 무엇인가요?\n\n고차 함수는 다른 함수를 인수로 받거나 함수를 결과로 반환하는 함수를 말합니다. 고차 함수는 함수 합성, 커링, 콜백과 같은 기능적 프로그래밍 패러다임을 지원합니다.\n\n```js\n// 고차 함수 예시\nfunction operateOnArray(array, operation) {\n  return array.map(operation); // 'operation'은 콜백 함수입니다\n}\nfunction double(num) {\n  return num * 2;\n}\nlet numbers = [1, 2, 3];\nlet doubledNumbers = operateOnArray(numbers, double);\nconsole.log(doubledNumbers); // 출력: [2, 4, 6]\n```\n\n자바스크립트에서 함수 호이스팅이란 무엇인가요?\n\n\n\n펑션 호이스팅은 JavaScript의 행동 중 하나로, 펑션 선언들이 컴파일 단계에서 자신을 포함하는 스코프의 맨 위로 이동하는 것을 말합니다. 이로 인해 함수들이 코드 내에서 선언되기 전에 호출될 수 있게 됩니다.\n\n```js\nsayHello(); // 출력: \"Hello!\"\nfunction sayHello() {\n  console.log(\"Hello!\");\n}\n```\n\nJavaScript에서 클로저(concept of closure)란 무엇인가요?\n\n클로저는 함수와 해당 함수가 선언된 렉시컬 환경(lexical environment)의 조합을 의미합니다. 클로저를 통해 함수는 포함하는 스코프의 변수에 대한 참조를 유지하고 접근할 수 있게 되며, 포함하는 스코프의 실행이 완료된 이후에도 영향을 받습니다.\n\n\n\n```js\nfunction outerFunction() {\n  let outerVariable = \"외부 함수에서 왔어요\";\n  function innerFunction() {\n    console.log(outerVariable); // 클로저에서 outerVariable에 접근\n  }\n  return innerFunction;\n}\nlet closureFunc = outerFunction();\nclosureFunc(); // 출력: \"외부 함수에서 왔어요\"\n```\n\n자바스크립트 함수에서 `this` 키워드의 목적은 무엇인가요?\n\n자바스크립트 함수에서 `this` 키워드는 함수가 호출된 위치의 문맥을 가리킵니다. 이를 통해 함수들은 자신을 호출한 객체의 속성에 접근하고 조작할 수 있어 코드 재사용 및 객체지향 프로그래밍 원칙을 용이하게 합니다.\n\n```js\nlet person = {\n  name: \"John\",\n  greet: function() {\n    console.log(\"안녕, \" + this.name + \"!\");\n  }\n};\nperson.greet(); // 출력: \"안녕, John!\"\n```\n\n\n\n자바스크립트에서 함수 커링(function currying)이란 무엇인가요?\n\n함수 커링은 여러 인수를 받는 함수를 각각 하나의 인수를 받는 중첩된 함수들의 연속으로 변환하는 과정입니다. 커링은 함수의 부분 적용을 가능하게 하여 더 큰 유연성과 재사용성을 제공합니다.\n\n```js\n// 함수 커링 예시\nfunction multiply(a) {\n  return function(b) {\n    return a * b;\n  };\n}\nlet multiplyByTwo = multiply(2);\nconsole.log(multiplyByTwo(5)); // 출력: 10\n```\n\n자바스크립트에서 즉시 호출 함수 표현식(IIFE)이란 무엇인가요?\n\n\n\nIIFE는 JavaScript 디자인 패턴으로, 함수를 괄호로 둘러싸고 즉시 호출하는 것을 포함합니다. 함수에 대한 개인 스코프를 만들어 전역 스코프에서 변수 오염을 방지합니다.\n\n```js\n// 즉시 호출되는 함수 표현(IIFE)\n(function() {\n  let message = \"IIFE에서 안녕하세요\";\n  console.log(message);\n})();\n// 출력: \"IIFE에서 안녕하세요\"\n```\n\n메모이제이션의 개념은 무엇이며, JavaScript 함수에서 어떻게 구현할 수 있을까요?\n\n메모이제이션은 비싼 함수 호출의 결과를 저장하고 같은 입력이 다시 발생할 때 캐시된 결과를 반환하는 최적화 기술입니다. 클로저를 사용하여 이전에 계산된 결과를 캐싱함으로써 구현할 수 있습니다.\n\n\n\n```js\nfunction memoize(fn) {\n  let cache = {};\n  return function(...args) {\n    let key = JSON.stringify(args);\n    if (!cache[key]) {\n      cache[key] = fn(...args);\n    }\n    return cache[key];\n  };\n}\n// 메모이제이션에 이점을 가지는 함수 예시\nconst fibonacci = memoize(function(n) {\n  if (n \u003c= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n});\nconst result = fibonacci(10);\nconsole.log(result); // 결과 55\n```\n\n이것으로 모두 마무리입니다! 이 기사 끝까지 읽어 주셔서 감사합니다. 계속해서 학습하고成長해 나가요.\n\nJavaScript Interview Concepts- A Guide를 다운로드하시기를 잊지 마세요. 한정 기간 동안 무료로 제공될 것입니다.\n\n만약 이 기사에서 가치 있는 내용을 좋아하고 배웠다면, 구독해주시고 기사에 박수를 보내주세요.","ogImage":{"url":"/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png"},"coverImage":"/assets/img/2024-05-14-InterviewConceptsonJavaScriptFunctions_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트를 사용해서 간단한 버전 관리 시스템을 구현해보면 Git에 대한 이해도가 높아집니다","description":"","date":"2024-05-14 14:06","slug":"2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter","content":"\n\nGit 내부를 배우면서 더 나은 이해를 위해 간소화된 버전을 구현해 보세요!\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png)\n\n## Git 또는 일반적으로 버전 관리란?\n\n우리 프로젝트를 시간에 따라 추적하는 데 도움이 되는 것이에요. 좋은 예시 중 하나는 소스 코드를 쉽게 과거의 특정 시간에 어떻게 보였는지 볼 수 있다는 것이죠.\n\n\n\n# 왜 그것을 이해해야 할까요?\n\n우선, 무언가 잘못되었을 때 몇 가지 명령어를 무심코 알아서는 도움이 되지 않습니다. 둘째로, 매일 다루고 있는 것이 어떻게 작동하는지 이해하지 못한다면, 재미가 어디에 있을까요?\n\n이제 슈퍼 간단한 버전 관리 시스템인 Gitj를 구현하는 방법을 하나씩 이해해 보겠습니다.\n\n# 구현\n\n\n\ngit은 압축 및 데이터 저장 방식과 같이 더 고급 기능을 수행한다는 것을 염두에 두세요. 이 내용은 별도의 기사에서 다룰 수 있습니다.\n\n# 첫 번째 명령어 적용: Init!\n\n아마도 알고 계시다시피 프로젝트를 git init으로 시작하면 git은 .git 폴더를 생성하고 데이터를 그 안에 저장합니다. 이를 구현해보겠습니다:\n\ngit이 생성하는 두 가지 중요한 폴더는 refs와 objects입니다. objects는 git의 구성 요소입니다. 3가지 유형(사실 4가지!)이 있을 수 있습니다: commit, tree 및 blob입니다. 이러한 각 유형을 자세히 살펴보겠습니다. refs 폴더에는 브랜치와 각 브랜치의 최신 커밋이 포함된 heads라는 하위 폴더가 있습니다(이름에서 알 수 있듯이 브랜치의 헤드를 저장하는 것으로 보입니다). 또한 현재 브랜치 또는 커밋을 유지하는 HEAD라는 중요한 파일이 있습니다.(가끔은 브랜치 대신 커밋에서 checkout을 수행할 수 있습니다)\n\n\n\n\"이제 init 함수를 호출하면 이러한 폴더들을 만들어 보겠습니다.\n\n```js\nconst fs = require(\"fs\");\n\nfunction init() {\n    // .gitj라는 폴더를 만들고, .gitj/objects와 .gitj/refs, .gitj/refs/heads와 같은 하위 폴더들을 생성합니다.\n    fs.mkdirSync(\".gitj\");\n    fs.mkdirSync(\".gitj/objects\");\n    fs.mkdirSync(\".gitj/refs\");\n    fs.mkdirSync(\".gitj/refs/heads\");\n    // .gitj/refs/heads/master라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/refs/heads/master\", \"\");\n    // .gitj/HEAD라는 파일을 생성합니다.\n    fs.writeFileSync(\".gitj/HEAD\", \"ref: refs/heads/master\");\n}\n\ninit();\n```\n\n# Git Add! 파일을 스테이징 영역에 추가하기\n\nGit에서 파일은 세 가지 다른 단계에 있을 수 있습니다:\"\n\n\n\n![image](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_1.png)\n\n- Working Directory: 평소 작업하는 디렉토리로 파일 및 폴더를 변경하고 구조를 수정합니다.\n\n- Staging Directory: 작업 디렉토리의 한 순간의 스냅샷이며 git add 명령을 사용하면 실제로 파일이 .git 폴더로 복사됩니다. 주의할 점은 스테이징 파일들이 이후에 리포지토리에 커밋하려는 최종 원고이라는 것입니다.\n\n- Repository: commit 명령을 실행하면 리포지토리에 새로운 스냅샷이 생성됩니다. 이제 이 커밋의 SHA 해시를 사용하여 이 스냅샷을 가리킬 수 있습니다(스테이징 파일을 가리킬 수는 없으며 스테이징 파일은 종이 딱지 같은 역할을 합니다).\n\n\n\n이제 git add 명령어를 구현해 봅시다.\n\ngit add에서 수행해야 할 단계는:\n\n- 파일 내용 읽기\n- 파일 내용을 해싱하기\n- 해시를 파일 이름으로 사용하여 객체 폴더에 저장하기\n- 파일이 이미 존재하는 경우 아무 작업도 수행하지 않습니다. 동일한 내용을 가진 파일이 10개 있다면(심지어 다른 파일 이름과 폴더 위치를 가지더라도), git은 그것들을 10번 복사하는 게 아니라 blob를 재사용할 수 있습니다.\n\n또한, git은 해시의 처음 두 글자를 사용하여 폴더 이름을 생성합니다. 예를 들어, 해시가 4f9be057f0ea5d2ba72fd2c810e8d7b9aa98b469라면 git은 이 폴더에 저장합니다: 4f 및 나머지는 파일로 생성합니다: 9be057f0ea5d2ba72fd2c810e8d7b9aa98b469. 왜냐하면 시간이 지남에 따라 단일 폴더에 많은 파일이 있으면 파일에 액세스하는 데 시간이 더 오래 걸릴 수 있기 때문에 git은 폴더에 처음 두 글자를 사용함으로써 이 문제를 방지하려고 합니다.\n\n\n\n```js\nconst fs = require(\"fs\");\nconst crypto = require(\"crypto\");\n\nfunction add(filename) {\n    try {\n        // 파일이 존재하는지 확인\n        fs.accessSync(filename);\n        // 파일 읽기\n        const content = fs.readFileSync(filename);\n        // 파일 해싱\n        const hash = crypto.createHash(\"sha1\");\n        hash.update(content);\n        const sha = hash.digest(\"hex\");\n        // 해시의 첫 두 문자로 폴더 생성 (폴더가 없는 경우)\n        if (!fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}`)) {\n            fs.mkdirSync(\".gitj/objects/\" + sha.slice(0, 2), { recursive: true });\n        }\n        if (fs.existsSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`)) {\n            // 이미 같은 내용의 블롭이 존재함\n            process.exit(0);\n        }\n        // 파일을 objects 폴더에 쓰기\n        fs.writeFileSync(`.gitj/objects/${sha.slice(0, 2)}/${sha.slice(2)}`, content);\n    } catch (error) {\n        console.log(error);\n        console.log(`파일 ${filename}이(가) 존재하지 않습니다.`);\n        process.exit(1);\n    }\n}\n\nadd('./sample/src/readme.md')\n```\n\nadd.js를 실행하여 소스 코드에서 파일을 추가한 후, 객체 저장소에 다음과 같은 파일이 생겼어야 합니다.\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_2.png)\n\n# 변경사항을 커밋하세요!\n\n\n\n\n커밋 자체도 객체 유형입니다. 아마도 예측하신 것처럼 우리의 객체 폴더에 더 많은 파일을 생성해야 합니다.\n\n커밋의 목적은 현재 상황(파일 및 폴더)에 대한 포인터를 만들어 이 상태로 돌아올 수 있도록 하는 것입니다.\n\nGit의 커밋 객체에는 다음 정보가 포함됩니다:\n\n- 작성자: 변경사항을 만든 사람\n- 커미터: 변경사항을 커밋한 사람 (때로는 다른 사람으로부터 패치를 받아 변경사항을 커밋해야 할 수도 있습니다.)\n- 커밋일\n- 커밋 메시지\n- 트리 (작업 디렉토리의 모양을 생성 시점에 유지하는 또 다른 객체)\n- 부모(존재하는 경우)\n\n\n\n## Git Commit이 어떻게 보이는지 알아봅시다\n\n만약 git log 명령어를 사용하면 커밋 해시 목록을 확인할 수 있고, 이 중 하나를 복사하여 git show --pretty=raw commitHash 명령어를 사용할 수 있습니다. 이 몤령어의 결과 예시는 다음과 같습니다(날짜는 커미터와 저자 이름 뒤의 타임스탬프로 표시됩니다):\n\n![Git Commit](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_3.png)\n\n이 예제에서는 부모가 있지만, 만약 커밋이 모든 첫 번째 커밋이라면 부모가 없습니다.\n\n\n\n부모가 커밋 객체 내에 존재하는 이유는 이러한 커밋들을 연결하여 연결할 수 있기 때문입니다. 따라서 우리가 과거의 커밋을 수동으로 변경하면 모든 커밋 해시를 다시 계산해야 하므로 모든 것이 엉망이 됩니다. 이는 리베이스와 같은 명령어를 사용하여 수행하는 작업입니다.\n\n## Git에서 Tree 객체 유형은 무엇인가요?\n\n폴더와 파일의 구조를 유지하는 객체 유형입니다. 예를 들어, 저가 보여준 커밋 예제에서 Tree 객체를 확인하고 내용을 볼 수 있습니다. Tree를 확인하려면 git ls-tree treeHash를 사용해야 합니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_4.png)\n\n\n\n이것은 기본 트리입니다. 작업 디렉토리의 파일과 폴더를 포함하고 있습니다. 여기서 두 가지 다른 유형을 볼 수 있는데, 파일을 나타내는 blob과 이 경우 하위 폴더를 나타내는 다른 트리 객체를 가리키는 tree가 있습니다.\n\n결과에서 두 번째 열은 객체의 유형, 세 번째 열은 SHA이며, 마지막 열은 파일 또는 폴더 이름입니다(파일 이름을 blob 밖에 유지하는 것은 동일한 내용을 반복해서 재사용하는 데 도움이 된다는 점을 이미 언급했습니다). 아직 알지 못하는 것은 첫 번째 열입니다. 첫 번째 열은 파일 모드입니다. 파일 모드는 객체의 유형 (예: blob, tree)과 해당 권한을 지정합니다. 040000 또는 100644와 같은 앞부분의 숫자는 8진수 표기법으로 파일 모드를 나타냅니다. 가장 일반적인 모드는 다음과 같습니다:\n\n- 100644: 읽기-쓰기 권한이 있는 일반 파일 (blob)을 나타냅니다.\n- 100755: 읽기-쓰기-실행 권한이 있는 실행 파일 (blob)을 나타냅니다.\n- 040000: 디렉토리 (tree)를 나타냅니다.\n\n커밋 기능을 구현하기 위해 필요한 조치:\n\n\n\n- 현재 작업 디렉토리의 트리를 생성하세요\n- 커밋 객체를 생성하세요\n- 부모 커밋(Head)을 얻으세요. 만약 부모가 없다면 이 커밋 이후에 head(master)를 업데이트하세요.\n\n우리는 git이 하는 방식과 동일한 파일 및 폴더 구조를 생성하는 간단한 트리를 만들 것입니다.\n\n## 트리 생성 함수 구현!\n\n각 파일의 파일 모드를 가져오는 작은 함수:\n\n\n\n```js\nasync function getTreeFileMode(fileType, fileOrFolder) {\n    const { mode } = await fs.stat(fileOrFolder);\n    return fileType === 'tree' ? '040000' : '100' + ((mode \u0026 parseInt(\"777\", 8)).toString(8));\n}\n```\n\n파일의 해시 값을 가져오는 함수\n\n```js\nasync function getHashOfFile(path) {\n    const content = await fs.readFile(path);\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(content);\n    const sha = hash.digest(\"hex\");\n    return sha;\n}\n```\n\n이제 메인 함수입니다.\n\n\n\n```js\nasync function createTreeObjectsFromPaths(folderPath) {\n    let treeFileContent = '';\n    let treeHash = ''\n    // 이 함수의 설명:\n    // 1- fs.readdir 결과를 반복한다.\n    // 2- 만약 디렉토리라면 유형은 tree이고 이 함수를 재귀적으로 호출한다. 그렇지 않으면 파일 또는 blob이다.\n    //    그리고 우리는 해시를 계산해야 한다.\n    // 3- 우리는 트리 객체를 만들기 위해 파일 모드(040000, 100644, ...)를 가져온다.\n    // 4- 트리 객체의 내용을 가지고 있다. 이제 해시를 생성할 수 있다.\n    // 5- 객체(현재 트리의 해시)가 존재하면 아무것도 할 필요가 없고, 그렇지 않으면 객체를 만들어서 객체 폴더에 저장한다.\n\n    // 이 함수를 실행해서 제대로 작동하는지 확인해봅시다:\n}\n```\n\n이 함수를 실행해보고 정상적으로 작동하는지 확인해보겠습니다:\n\n\n\n이제 폴더 구조는 이렇게 보입니다.\n\n![Folder Structure](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_5.png)\n\n이제 `createTreeObjectsFromPaths('.')`를 실행합니다. 결과로 Gitj 폴더에 두 개의 새 객체가 생성됩니다:\n\n![Result](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_6.png)\n\n\n\n이 중 하나의 객체 내용은 루트 폴더에 있는 package.json을 blob 유형으로 가지고 있을 것으로 예상되고 src 폴더를 가리키는 다른 tree 객체를 기대합니다:\n\n![image 1](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_7.png)\n\n이 tree 커밋 해시는 이제 src 폴더의 구조를 저장하는 다른 객체를 가리킵니다:\n\n![image 2](/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_8.png)\n\n\n\n이제 커밋 기능을 구현할 시간입니다.\n\n```js\nconst fs = require('fs').promises;\nconst crypto = require('crypto');\nconst { createTreeObjectsFromPaths, folderOrFileExist } = require('./tree');\n\nasync function commit(commitMessage) {\n    const treeHash = await createTreeObjectsFromPaths('./sample');\n    const parentHash = await getLatestCommitHash();\n    const author = 'test';\n    const committer = 'test';\n    const commitDate = Date.now();\n    const commitContent = `tree ${treeHash}\\nparent ${parentHash}\\nauthor ${author}\\ncommitter ${committer}\\ncommit date ${commitDate}\\n${commitMessage}`;\n    const hash = crypto.createHash(\"sha1\");\n    hash.update(commitContent);\n    const commitHash = hash.digest(\"hex\");\n    // commit 객체를 objects 폴더에 작성합니다.\n    if (!await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}`)) {\n        await fs.mkdir(`.gitj/objects/${commitHash.slice(0, 2)}`, { recursive: true });\n    }\n    if (await folderOrFileExist(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`)) {\n        // 이미 동일한 내용의 커밋이 존재합니다.\n        console.log(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`);\n        return commitHash;\n    }\n    // 파일을 objects 폴더에 작성합니다.\n    await fs.writeFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, commitContent);\n    // 현재 브랜치의 헤드를 커밋 해시로 설정합니다.\n    await fs.writeFile('.gitj/refs/heads/master', commitHash);\n    return commitHash;\n}\n```\n\n어려운 부분은 트리 객체였는데, 이제 모든 데이터를 갖고 있고 이를 함께 묶어 새로운 커밋 객체를 만듭니다. 또한, 브랜치의 헤드를 업데이트하여 이 새로운 스냅샷을 가리키도록 해야 합니다 (당연히 커밋 해시).\n\n\n\n## 마스터 브랜치 또는 메인 브랜치 또는 다른 브랜치가 무엇을 의미하죠?\n\n브랜치는 단순히 커밋을 가리키는 참조 또는 책갈피입니다. 커밋의 구현에서 본 것처럼 파일 내용을 업데이트 했을 때 refs/head/master 와 같은 파일의 내용을 볼 수 있습니다. 그것은 단지 커밋 해시입니다. 이 커밋 해시에는 부모가 있을 수 있으며(첫 번째 커밋이 아닌 경우), 더 이상 커밋이 없을 때까지 과거로 돌아갈 수 있습니다. 즉, 이 브랜치 이름을 사용하여 최신 커밋(Head!)에 액세스할 수 있습니다. 간단히 말해, 특정 브랜치에 있는 것은 다른 head를 가리키고 있다는 것을 의미합니다.\n\nblob에 파일 이름을 저장하지 않으므로, 파일 이름이 다르더라도 git이 blob을 사용할 수 있는 이점이 있습니다.\n\n## Git Checkout를 어떻게 실행하나요?\n\n\n\n이미 커밋 기능을 구현했으므로, 커밋에는 트리 객체(모든 폴더와 파일을 재귀적으로 가리킨다)에 접근할 수 있고, 파일은 .git(우리 경우 .gitj)에 blob으로 저장되어 있습니다. 따라서 먼저 작업 디렉토리를 제거한 다음 누군가가 다른 커밋(또는 브랜치 - 브랜치 헤드는 커밋 해시를 가리킨다)을 확인할 때 전체 디렉터리를 다시 만들어야 합니다. 하지만 먼저 커밋 해시 또는 브랜치 이름을 HEAD 파일에 저장해야 합니다.\n\n그 전에, 해당 커밋의 트리 객체를 가져오는 작은 함수를 구현하고 싶습니다:\n\n```js\nasync function getTreeHashFromCommit(commitHash) {\n    const commitContent = await fs.readFile(`.gitj/objects/${commitHash.slice(0, 2)}/${commitHash.slice(2)}`, 'utf-8');\n    const array = commitContent.split('\\n').map(e=\u003e e.split(' '))\n    const elem = array.find(e =\u003e e[1] === 'tree');\n    return elem[2];\n};\n```\n\n이제 트리를 가지고 있으면 전체 폴더를 다시 만들어야 합니다:\n\n\n\n먼저, 이 커밋을 HEAD 파일에 써서 헤드가 더 이상 마스터에 있지 않음을 기억합니다. 전체 폴더를 다시 만들기 위해 트리와 블롭을 재귀적으로 가져와야 합니다. 다음은 구현 내용입니다:\n\n```js\nasync function convertTreeObject(treeHash, folderPrefix = '', files = []) {\n    const treeObject = await fs.readFile(`.gitj/objects/${treeHash.slice(0, 2)}/${treeHash.slice(2)}`, 'utf-8');\n    const array = treeObject.split('\\n').map(e=\u003e e.split(' '))\n    for (const file of array) {\n        if (!file || file.length \u003c 2) continue;\n        const [mode, type, hash, name] = file;\n        if (type === 'tree') {\n            await convertTreeObject(hash, folderPrefix + name + '/', files);\n        } else {\n            files.push({\n                mode: mode,\n                type: type,\n                hash: hash,\n                name: folderPrefix + name\n            })\n        }\n    }\n    return files;\n}\n```\n\n만약 파일이 있다면 파일의 이름과 블롭(파일의 내용)을 배열에 추가합니다. 객체 타입이 tree이면 이것이 폴더라는 것이고, 이 함수를 재귀적으로 호출하여 올바른 파일 경로를 생성하기 위해 부모 폴더의 경로를 전달해야 합니다.\n\n\n\n## 앞으로 구현하고 싶은 몇 가지 기능\n\n- Git 상태 확인\n- Git 차이 확인\n\n# 결론\n\n우리는 git이 히스토리를 추적할 수 있는 능력을 제공하기 위해 해시 및 커밋 해시 체인을 사용하는 방법을 배웠습니다. 개인적으로는 이런 식의 심층적인 탐구가 내용을 정말 잘 배우는 가장 좋은 방법이라고 생각합니다. 유용했기를 바랍니다. 만약 git에 더 많은 기능을 구현하는 데 관심이 있다면 이 GitHub 저장소를 확인해보세요.\n\n\n\n# 참고 자료\n\n- [CS50 YouTube 영상](https://www.youtube.com/watch?v=lG90LZotrpo\u0026ab_channel=CS50)\n- [유튜브의 인코드된 비디오](https://www.youtube.com/watch?v=P6jD966jzlk\u0026pp=ygUgR2l0IGludGVybmFscyBob3cgaXQgc3RvcmVzIGRhdGE%3D)\n- [GOTO Conferences YouTube 채널](https://www.youtube.com/watch?v=dBSHLb1B8sw\u0026ab_channel=GOTOConferences)\n\n\n\nhttps://www.youtube.com/watch?v=52MFjdGH20o\u0026ab_channel=Brief","ogImage":{"url":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementaSimpleVersionControlwithJavaScripttoUnderstandGitBetter_0.png","tag":["Tech"],"readingTime":12},{"title":"고통 없는 리액트 다시 렌더링 피하기와 의존성 간소화하기","description":"","date":"2024-05-14 14:04","slug":"2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies","content":"\n\n\n![React without Pain: Avoid Re-Renders and Simplify Dependencies](/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png)\n\nReact에서 다시 렌더링을 추적하는 것은 고통스러운 과정일 수 있습니다. Fine-grain 반응성 패턴은 이 문제를 완전히 제거하는 해결책을 제공하여 React 엔지니어가 종속성을 추적하는 것을 잊고 코드 작성에 집중할 수 있게 합니다. 이 기사에서는 라이브러리 Mlyn이 종속성 관리를 간단하게 하고 React 애플리케이션에서 불필요한 다시 렌더링을 방지하는 방법을 살펴보겠습니다.\n\n# 종속성 관리: 공통 문제\n\n기존의 React 애플리케이션에서 상태와 종속성을 관리하는 것은 종종 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다. 이 문제를 설명하기 위해 간단한 카운터 예제를 살펴보겠습니다.\n\n\n\n\n# 전통적인 리액트 예제\n\n```js\nimport React, { useState, useCallback } from \"react\";\nconst Counter = () =\u003e {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() =\u003e {\n    setCount(prevCount =\u003e prevCount + 1);\n  }, [count]); // count에 의존\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e카운트: {count}\u003c/h1\u003e\n      \u003cbutton onClick={onIncrement}\u003e증가\u003c/button\u003e\n    \u003c/div\u003e\n  );\n};\nexport default Counter;\n```\n\n# 의존성 문제\n\n이 예제에서 onIncrement 함수는 count를 의존성으로 하는 useCallback으로 래핑되어 있습니다. count가 변경될 때마다 onIncrement가 다시 생성됩니다.\n\n\n\n# Mlyn과 함께 간단하게\n\nMlyn은 세부적인 반응성을 소개하여 의존성을 걱정하지 않고 상태 업데이트를 관리할 수 있습니다. Mlyn을 사용하여 동일한 예제를 다시 작성해 봅시다.\n\n# Mlyn 예제\n\n```js\nimport React, { useCallback } from \"react\";\nimport { rc, useSubject } from \"mlyn/react\";\nconst Counter = rc(() =\u003e {\n  const state = useSubject({ count: 0 });\n  const increment = useCallback(() =\u003e {\n    state.count(state.count() + 1);\n  }, []);\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eCount: {state.count()}\u003c/h1\u003e\n      \u003cbutton onClick={onIncrement}\u003eIncrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\n\nexport default Counter;\n```  \n\n\n\nstate.count의 참조가 변경되지 않기 때문에 useCallback에서 해당 값을 다시 만들지 않고도 읽을 수 있습니다.\n\n# 정교한 Reactivity의 장점\n\n- Stable Callbacks: Mlyn의 onIncrement 함수는 state.count를 의존성으로 필요로하지 않습니다. 이러한 안정성은 함수의 불필요한 재생성을 방지합니다. 그리고 onIncrement의 소비자들은 count가 변경되어도 다시 렌더링되지 않습니다.\n- 단순화된 코드: Mlyn을 사용하면 종속성을 수동으로 추적할 필요가 없습니다.\n\n# IncrementButton 추출: 다시 렌더링에 대한 더 깊은 이해\n\n\n\nLet’s extract the increment button into theIncrementButton component to understand how Mlyn’s approach prevents unnecessary re-renders.\n\n# Traditional React: Re-Rendering Issue\n\nIn the traditional example, IncrementButton re-renders every time count changes because increment is a new function reference each time.\n\n```js\nconst IncrementButton = React.memo(({ onIncrement }) =\u003e {\n  console.log(\"IncrementButton re-rendered\");\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={onIncrement}\u003eIncrement from Child\u003c/button\u003e\n    \u003c/div\u003e\n  );\n});\n\nconst Counter = () =\u003e {\n  const [count, setCount] = useState(0);\n  const onIncrement = useCallback(() =\u003e {\n    setCount(prevCount =\u003e prevCount + 1);\n  }, [count]); // Dependency on count\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eCount: {count}\u003c/h1\u003e\n      \u003cIncrementButton onIncrement={onIncrement} /\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n\n\n# Mlyn: 불필요한 다시 렌더링 방지\n\nMlyn을 사용하면 onIncrement가 동일한 참조로 유지되어 IncrementButton이 불필요하게 다시 렌더링되지 않습니다. 이것은 섬세한 용량으로 반응하는 주요 장점입니다.\n\n# 예제 재방문\n\n```js\nconst Counter = rc(() =\u003e {\n  const state = useSubject({ count: 0 });\n  const onIncrement = useCallback(() =\u003e {\n    state.count(state.count() + 1); // 어떤 종속성도 필요하지 않습니다\n  }, []);\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eCount: {state.count()}\u003c/h1\u003e\n      \u003cIncrementButton onIncrement={onIncrement} /\u003e\n    \u003c/div\u003e\n  );\n});\n```\n\n\n\n# 개요\n\nMlyn의 섬세한 리액티브는 상태 관리를 간단하게 만들어 줍니다:\n\n- 의존성 추적이 필요 없어집니다: 수동으로 종속성을 업데이트할 필요 없이 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n- 불필요한 다시 렌더링 방지: 컴포넌트는 실제 상태나 프롭이 변경될 때만 다시 렌더링되어 성능과 효율성을 향상시킵니다.\n\nMlyn을 도입함으로써, React 엔지니어는 복잡한 상태 종속성을 관리하는 귀찮음 없이 기능이 풍부한 코드 작성에 집중할 수 있습니다. 다음 프로젝트에 Mlyn을 통합해보고 섬세한 리액티브의 편리함을 경험해보세요!\n\n\n\nmlyn에 관심이 있다면, GitHub에서 확인해보세요: [https://github.com/vaukalak/mlyn](https://github.com/vaukalak/mlyn)","ogImage":{"url":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png"},"coverImage":"/assets/img/2024-05-14-ReactwithoutPainAvoidRe-RendersandSimplifyDependencies_0.png","tag":["Tech"],"readingTime":4},{"title":"JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내","description":"","date":"2024-05-14 14:02","slug":"2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide","content":"\n\n![image](/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png)\n\n라이브 기사 — 최근 업데이트: 2024년 2월 7일.\n\n프로그래밍 언어에서 새로운 기능을 발견하는 것은 휴일이나 생일처럼 기대감과 새로운 선물을 탐험하는 기쁨으로 가득한 흥미진진한 시간입니다. ES2024®의 제안된 기능으로 인해 개발자들은 JavaScript 코딩을 더 효율적이고 가독성 있고 견고하게 만들어 주는 다양한 향상을 풀어나가려는 이유입니다. 최상위 await의 직관적인 구문부터 파이프라인 연산자의 표현력 있는 기능, 그리고 불변 레코드와 튜플의 신뢰성까지, 각 새로운 기능은 선택된 선물처럼 주어져서 JavaScript 생태계를 발전시키고 개발자들에게 더 많은 도구를 제공하기 위해 공들여 디자인되었습니다.\n\nECMAScript 2024 국제화 API 사양(ECMA-402 11판)에 따르면 ES2024에는 여러 기능이 포함될 예정입니다.\n\n\n\n그냥 유의해 주세요. 몇 가지는 여전히 \"제안 사항\"이라서 조금씩 변경될 수 있지만, 다행히도 이 문서는 승인된 변경 사항에 맞춰 조정될 것입니다!\n\n더 이상 미루지 말고…\n\n# 잘 형성된 유니코드 문자열\n\n이 기능은 JavaScript가 유니코드 문자열을 처리하는 방식을 개선하려는 것입니다. 유니코드 문자열은 다양한 언어와 기호를 나타내는 데 중요합니다. 이 업데이트는 다른 JavaScript 환경에서 이러한 문자열을 일관되고 정확하게 처리할 수 있도록 보장할 것입니다.\n\n\n\n```js\nconst sampleStrings = [\n  // 혼자 있는 대체문자가 포함된 예제\n  \"igor\\uD800\", // 앞 부분 대체문자\n  \"igor\\uD800komolov\", // 앞 부분 대체문자 뒤에 텍스트\n  \"\\uDC00yourfuse\",    // 뒷 부분 대체문자\n  \"your\\uDC00fuse\",    // 뒷 부분 대체문자 뒤에 텍스트\n  \n  // 올바르게 작성된 예제\n  \"yourFuse\",       // 대체문자 없는 일반 문자열\n  \"emoji\\uD83D\\uDE00\", // 완전한 대체 문자 쌍(이모지)을 갖는 문자열\n];\n\nsampleStrings.forEach(str =\u003e {\n  console.log(`처리된 문자열: ${str.toWellFormed()}`);\n});\n\n// 기대 출력:\n// \"처리된 문자열: igor�\"\n// \"처리된 문자열: igor�komolov\"\n// \"처리된 문자열: �yourfuse\"\n// \"처리된 문자열: your�fuse\"\n// \"처리된 문자열: yourFuse\"\n// \"처리된 문자열: emoji😀\"\n```\n\n위의 예제에서는 toWellFormed() 메소드가 혼자 있는 대체 문자와 올바르게 작성된 문자열이 포함된 문자열 배열에 적용됩니다. 이 메소드는 혼자 있는 대체 문자를 올바르게 작성된 유니코드 문자열로 변환하여 잘못된 시퀀스를 대체 문자로 바꾸며, 이미 올바르게 작성된 문자열은 변경하지 않습니다.\n\n```js\nconst problematicURL = \"https://yourfuse.com/query=\\uDC00data\";\n\ntry {\n  encodeURI(problematicURL);\n} catch (e) {\n  console.log('에러:', e.message); // 기대 결과: URIError: URI malformed\n}\n\n// toWellFormed()를 사용하여 에러 방지\nconsole.log('올바른 형식의 URI:', encodeURI(problematicURL.toWellFormed())); \n// 기대 출력: \"https://yourfuse.com/query=%EF%BF%BDdata\"\n```\n\n- problematicURL 변수에는 뒷 부분 대체 문자(\\uDC00)를 포함한 URL이 들어 있습니다.\n- encodeURI()로 이 URL을 인코딩하려고 하면 잘못된 유니코드 문자열로 인해 URIError가 발생합니다.\n- toWellFormed()를 적용하면 혼자 있는 대체 문자가 유니코드 대체 문자(U+FFFD, %EF%BF%BD로 인코드)로 대체되어 encodeURI()가 오류 없이 처리할 수 있게 됩니다.\n\n\n\n# Atomic waitSync\n\n이 추가 사항은 주로 공유 메모리 컨텍스트에서 동시 작업을 대상으로 합니다. 이는 데이터 무결성을 보장하고 멀티스레드 작업에서 경합 조건을 방지하는 데 중요한 동기화 메커니즘을 제공합니다. 예를 들어, waitSync는 여러 작업자 간의 공유 버퍼에 대한 액세스를 동기화하는 데 사용될 수 있습니다.\n\n아직 예제가 제공되지 않아 문서가 아직 작성 중이므로 어떻게 구현될지 보여드릴 수 없습니다. 그러나 기존 Atomics 메서드를 기반으로 가정을 할 수 있습니다. 다음과 같습니다...\n\n```js\n// sharedArray가 SharedArrayBuffer임을 가정합니다.\nconst sharedArray = new Int32Array(new SharedArrayBuffer(1024));\n\nfunction performSynchronizedOperation(index, value) {\n    // waitSync 메서드는 특정 조건이 충족될 때까지 실행을 차단합니다.\n    // 예를 들어, 지정된 인덱스의 값이 0이 아닌 값이 될 때까지 기다릴 수 있습니다.\n    Atomics.waitSync(sharedArray, index, 0);\n\n    // 공유 메모리에서 작업 수행\n    sharedArray[index] = value;\n\n    // 다른 스레드나 작업자에게 인덱스의 값이 업데이트되었음을 알립니다.\n    Atomics.notify(sharedArray, index, 1);\n}\n\n// 웹 워커나 다른 스레드에서\nperformSynchronizedOperation(0, 123);\n```\n\n\n\n# 정규 표현식의 v 플래그와 집합 표기법 + 문자열 속성\n\n자바스크립트의 정규 표현식에 대한 이 개선 사항은 더 복잡한 패턴 매칭과 문자열 조작을 가능하게 합니다. 'v' 플래그와 집합 표기법을 사용하면 더 정확하고 표현력 있는 정규식 패턴을 생성할 수 있습니다. 예를 들어, 이 기능을 사용하여 특정 유니코드 속성을 가진 문자 집합을 일치시킬 수 있습니다.\n\n```js\n// 차이/빼기\n[A--B]\n\n// 교집합\n[A\u0026\u0026B]\n\n// 중첩된 문자 클래스\n[A--[0-9]]\n```\n\nA와 B는 문자 클래스(예: [a-z])나 속성 이스케이프를 나타냅니다. 제안에 대한 설명적인 예제와 FAQ을 확인할 수 있습니다.\n\n\n\n# 최상위 await\n\n이 \"Just Do It\" 기능은 await 키워드가 비동기 함수 외부에서도 사용되도록 허용하여 비동기 코드를 더 쉽게 작성하고 읽을 수 있게 합니다. 예를 들어, 모듈의 최상위 수준에서 프로미스를 직접 await할 수 있어 모듈 가져오기 또는 데이터 비동기로 가져오는 코드를 간소화할 수 있습니다.\n\n```js\n// 최상위 await 사용\nconst data = await fetchData();\nconsole.log(data);\n```\n\n정말로 무겁고 복잡한 async/await 구조에 새로운 바람을 불어넣어 줍니다!\n\n\n\n# 파이프라인 연산자\n\n파이프라인 연산자(`|`)는 여러 함수 호출로 이루어진 코드의 가독성을 향상시킵니다. 이는 함수형 스타일 구문을 허용하여 식의 결과를 다음 함수의 인자로 전달할 수 있게 합니다. 예를 들어, 중첩된 함수 호출을 명확한 연산 순서로 재구성할 수 있습니다:\n\n```js\n// 파이프라인 연산자 없이\nconst calculatedValue = Math.ceil(Math.pow(Math.max(0, -10), 1/3));\n\n// 파이프라인 연산자 사용 시\nconst calculatedValue = -10\n  |\u003e (n =\u003e Math.max(0, n)) // Math.max 대체\n  |\u003e (n =\u003e Math.pow(n, 1/3)) // Math.pow 대체\n  |\u003e Math.ceil; // Math.ceil 사용\n```\n\n이 예제에서:\n\n\n\n- Math.max 함수는 숫자가 음수가 아닌지 확인합니다.\n- Math.pow 함수는 세제곱근을 계산합니다 (1/3의 거듭제곱).\n- Math.ceil 함수는 숫자를 가장 가까운 정수로 올립니다.\n\n파이프라인 연산자(`|`)는 이러한 작업들을 연쇄적으로 쉽게 할 수 있게 해주어 코드를 더 읽기 쉽게 만듭니다.\n\n이제 다음은 데이터 변환에 파이프라인 연산자가 얼마나 유용한지 보여주는 예제입니다:\n\n```js\n// 파이프라인 연산자는 일련의 함수들을 명확하고 간결한 방식으로 연쇄적으로 적용하여 복잡한 데이터 조작을 간단하게 합니다.\n\nconst numbers = [10, 20, 30, 40, 50];\n\nconst processedNumbers = numbers\n  |\u003e (_ =\u003e _.map(n =\u003e n / 2)) // 각 숫자를 절반으로 나누기\n  |\u003e (_ =\u003e _.filter(n =\u003e n \u003e 10)); // 10보다 작거나 같은 숫자 제외하기\n\nconsole.log(processedNumbers); // [15, 20, 25]\n```  \n\n\n\n이 예제에서:\n\n- map 함수는 배열 내의 각 숫자를 절반으로 나눕니다.\n- filter 함수는 10 이하인 숫자를 제거합니다.\n- 파이프라인 연산자 (|`)를 사용하여 이러한 변환을 우아하게 연결하여 코드 가독성을 향상시킵니다.\n\n기억하세요, 파이프라인 연산자는 여전히 \"Draft\" 상태인 TC39의 단계 2에 있습니다.\n\n# 레코드 및 튜플\n\n\n\n이 변하지 않는 데이터 구조들은 각각 객체와 배열과 유사하지만 생성 후 수정할 수 없습니다. 예를 들어, 레코드나 튜플을 업데이트하면 새로운 인스턴스가 생성됩니다:\n\n```js\n// 불변한 레코드 생성\nconst userProfile = #{\n  username: \"IgorKomolov\",\n  age: 39,\n};\n\n// 불변한 튜플 생성\nconst numberSequence = #[10, 20, 30];\n\n// 이러한 구조를 업데이트하면 새로운 인스턴스가 생성됩니다\nconst updatedProfile = userProfile.with({ age: 40});\nconsole.log(updatedProfile); // #{ username: \"IgorKomolov\", age: 40 }\nconsole.log(userProfile); // #{ username: \"IgorKomolov\", age: 39 } (변하지 않음)\n\nconst newNumberSequence = numberSequence.with(1, 25);\nconsole.log(newNumberSequence); // #[10, 25, 30]\nconsole.log(numberSequence); // #[10, 20, 30] (변하지 않음)\n```\n\n레코드는 객체와 유사하게 동작하고, 튜플은 배열과 유사합니다. 그러나 그들의 핵심 특징은 불변성입니다.\n\n레코드와 튜플은 특정 상황에서 성능을 향상시키고 코드베이스에서 불변성을 강제할 수 있습니다. 이들은 제안의 2단계에 있으며 아직 JavaScript 엔진에 구현되지는 않았지만, 개발자들은 Babel과 같은 트랜스파일러를 사용하여 이들을 실험할 수 있습니다.\n\n\n\n# 데코레이터\n\n이제 이게 가능해졌어요, TypeScript에 감사해요! 클래스, 메서드, 속성 또는 매개변수의 동작을 수정하거나 확장하는 기능을 제공합니다. 주석 추가, 로깅 또는 선언적 방식으로 동작을 수정하는 데 특히 유용합니다:\n\n```js\n// 메서드 실행을 추적하기 위해 데코레이터 적용\nclass SampleClass {\n  @trackExecution\n  performAction(parameter1, parameter2) {\n    // 메서드 구현 내용이 여기에 있습니다\n  }\n}\n```\n\n이 예시에서:\n\n\n\n- SampleClass는 정의되는 클래스입니다.\n- @trackExecution은 performAction 메서드 호출을 기록하거나 추적하기 위해 사용되는 데코레이터입니다.\n- performAction은 SampleClass 내의 메서드로, 두 개의 매개변수(parameter1 및 parameter2)를 사용합니다. 이 데코레이터는 이 메서드에 대한 각 호출을 기록하거나 추적합니다.\n\n# 패턴 매칭\n\n이 기능은 복잡한 데이터 구조의 비구조화 및 일치에 대한 간결한 구문을 소개하여 코드 가독성을 높이고 보일러플레이트를 줄입니다.\n\n(연구 중) 더 많은 정보가 곧 제공될 예정이니 나중에 다시 확인해주세요!\n\n\n\n# Temporal\n\n잠시만요! 엄청 오래전에 기획되었지만, 업데이트된 Temporal은 JavaScript를 위해 제안된 최신 및 포괄적인 날짜 및 시간 API로, 현재 Stage 3에 있어요. 기존 Date 객체의 제한 사항과 복잡성 중 많은 부분을 해결하기 위해 설계되었어요. 여기 ES2024에서 Temporal을 사용하는 몇 가지 예시가 있어요:\n\n이 객체는 현재 시간에 대한 Temporal 값을 생성하기 위한 여러 팩토리 메서드를 제공해요.\n\n## UTC에서 현재 시간 가져오기\n\n\n\n\nTemporal.Now.instant().toString()\n\n## 특정 시간대에서 현재 존재하는 날짜 및 시간 가져오기\n\nTemporal.Now.zonedDateTimeISO(`Asia/Shanghai`).toString()\n\n## ISO 형식의 현재 플레인 날짜 및 시간 가져오기\n\n\n\n\n표를 아래와 같이 Markdown 형식으로 변경해주세요.\n\nTemporal.Now.plainDateTimeISO().toString()\n\n## 현재 plain 시간을 ISO 형식으로 얻기\n\nTemporal.Now.plainTimeISO().toString().\n\n## ZonedDateTime.prototype의 속성\n\n\n\nTemporal의 ZonedDateTime 클래스에는 날짜 및 시간 정보를 자세히 조작하고 검색할 수 있는 여러 속성과 메서드가 있습니다.\n\n- 이러한 속성 및 메서드에는 달력, 시간대, 연도, 월, 일, 시간, 분, 초 및 나노초를 반환하는 getter가 포함됩니다.\n- .with(), .add(), .subtract(), .until(), .since(), .round()과 같은 메서드도 포함되어 있어, 지역 시간 값을 다루는 데 풍부한 기능을 제공합니다.\n\n## Temporal의 Plain Time 클래스\n\nTemporal은 시간대 없이 시간을 나타내는 추상 클래스인 \"plain\" 클래스를 소개합니다.\n\n\n\n- 이러한 클래스에는 PlainDateTime, PlainDate 및 PlainTime이 포함됩니다.\n- 이들은 특정 시간대에서 벽시간을 표시하거나 1984년 6월의 첫 번째 화요일을 찾는 것과 같이 시간대가 중요하지 않은 시간 계산에 유용합니다.\n\n이 예시들은 ES2024의 Temporal이 JavaScript에서의 날짜 및 시간 처리를 간단하고 향상시킬 수 있다는 것을 보여줍니다. 개발자들에게 더 견고하고 다재다능한 도구를 제공합니다.\n\n지금 사용해보고 싶으신가요? 문제없어요!\n\n제안을 가져오거나 Babel Polyfil을 사용해보세요. 이렇게 제안을 가져오는 방법이 있습니다...\n\n\n\n```js\n//네 맞아요, 제안서도 가져올 수 있어요 :)\nimport { Temporal } from '@std/proposal-temporal';\n\n\n//기본 연산\nconst now = Temporal.Now.zonedDateTimeISO('America/New_York');\nconsole.log(now.toString());\n\n//조작 및 비교\n\nconst date = Temporal.PlainDate.from('2024-01-01');\nconst newDate = date.add({ days: 10 });\nconsole.log(newDate.toString()); // 결과 '2024-01-11'\n```\n\n# 에르고노믹 브랜드 체크\n\n사용자 지정 클래스 및 데이터 구조에서 객체 타입을 확인하는 것을 단순화하여 유형 검증을 더 직관적이고 실수를 줄입니다. 이제 부모 복제본은 보지 않을 거예요!\n\n## 전통적인 방법 (ES2024 이전)\n\n\n\n```js\nclass Book {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        try {\n            obj.#author; // 비공개 필드에 접근 시도\n            return true; // 접근 성공\n        } catch (err) {\n            if (err instanceof TypeError) {\n                return false; // 접근 실패, 필드가 존재하지 않음\n            }\n            throw err; // 다른 오류는 다시 던짐\n        }\n    }\n}\n\n// 사용 예시:\nconst myBook = new Book(\"Igor Komolov\");\nconsole.log(Book.hasAuthorField(myBook)); // 예상 결과: true\n\nconst otherObject = {};\nconsole.log(Book.hasAuthorField(otherObject)); // 예상 결과: false\n```\n\n## 새로운 ES2024 방식\n\n```js\nclass BookES2024 {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        return #author in obj; // 비공개 필드를 확인하는 새로운 ES2024 구문\n    }\n}\n\n// 사용 예시:\nconst myBook2024 = new BookES2024(\"Igor Komolov\");\nconsole.log(BookES2024.hasAuthorField(myBook2024)); // 예상 결과: true\n\nconst otherObject2024 = {};\nconsole.log(BookES2024.hasAuthorField(otherObject2024)); // 예상 결과: false\n```\n\n이 예제에서 Book 클래스는 전통적인 방식을 보여주고, BookES2024는 새로운 ES2024 구문을 사용합니다. hasAuthorField 정적 메소드는 #author 비공개 필드가 객체에 존재하는지 확인하며, 각 클래스에서 서로 다른 접근 방식을 사용합니다.\n\n\n\n# Realms API\n\n이 API는 격리된 JavaScript 환경을 만드는 메커니즘을 제공합니다. 안전한 코드 실행 및 샌드박싱에 유용하며, 제어된 격리된 컨텍스트에서 코드를 실행할 수 있게 합니다. 게다가, 이름도 너무 멋져요!\n\n## Realm 생성 및 간단한 표현식 평가\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('3 * 5'); // Igor의 영역에서 15로 계산됨\n```\n\n\n\n## 다른 영역 간 심볼 공유\n\n```js\nconst igorsRealm = new Realm();\nSymbol.for('y') === igorsRealm.evaluate('Symbol.for(\"y\")'); // true 반환, 공유된 심볼 'y'\n```\n\n## 자동 래핑된 함수 사용\n\n한 영역에서 다른 영역으로 전송된 호출 가능한 객체의 경우 대상 영역에서 래핑된 함수 이국적 객체가 생성됩니다. 호출되는 경우 래핑된 함수는 원래 영역의 연결된 함수로 호출을 연결합니다.\n\n\n\n```js\nconst igorsRealm = new Realm();\nconst doubleFunction = igorsRealm.evaluate('num =\u003e num * 2');\ndoubleFunction(10); // 결과: 20\n```\n\n## 콜백을 이용한 함수 평가\n\n```js\nconst igorsRealm = new Realm();\nconst processNumber = igorsRealm.evaluate('(number, callback) =\u003e callback(number + 5)');\nprocessNumber(5, (result =\u003e console.log(result))); // 로그: 10 (5 + 5)\n```\n\n## 제한된 전역 컨텍스트 접근\n\n\n\n\n글로벌 객체인 globalThis, 배열 또는 Object.prototype에 realm.evaluate를 통해 직접 액세스하는 것은 TypeError를 발생시킵니다.\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('this'); // TypeError 발생\nigorsRealm.evaluate('new Array()'); // TypeError 발생\nigorsRealm.evaluate('Object.keys({})'); // TypeError 발생\n```\n\nES2024에서 예정된 새로운 기능들은 자바스크립트 코딩에 접근하는 방식을 혁신할 것으로 예상됩니다. 이러한 향상들은 코드 가독성과 효율성을 향상시키는 것뿐만 아니라 불변 데이터 구조와 고급 패턴 매칭과 같은 강력한 새로운 패러다임을 소개하기도 합니다. 이러한 기능들이 제안에서 구현으로 이동할 때, 개발자들이 더 깨끗하고 유지보수 가능하며 표현력이 풍부한 자바스크립트 코드를 작성할 수 있는 새로운 가능성을 열어줍니다. 이러한 진보로운 발전과 함께 자바스크립트의 미래는 밝아보이며, 현대 웹 개발의 중요한 요충지가 된 언어의 지속적인 발전을 시사합니다.","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"크롬 콘솔 유틸리티 모든 개발자가 알아야 할 내용","description":"","date":"2024-05-14 14:00","slug":"2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow","content":"\n\n\n![ChromeConsoleUtilities](/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png)\n\n모든 표준 웹 브라우저는 일반적으로 개발자가 웹 앱을 디버깅할 수 있는 도구를 제공합니다. 예를 들어 대부분의 브라우저에는 내장된 JavaScript 디버거, DOM 트리 인스펙터, 네트워크 모니터 및 네트워크 속도 시뮬레이터가 있습니다. 인기 있는 Google Chrome 브라우저는 생산성 중심의 웹 앱 디버깅 기능을 제공하는 잘 알려진 DevTools 툴킷을 제공합니다. DevTools 프로토콜 덕분에 네이티브 웹 앱 디버깅 외에도 Chrome에서 TypeScript, Deno, Node.js 및 React Native 앱을 디버깅할 수 있습니다.\n\n웹 앱 디버깅 프로세스는 주로 브라우저 콘솔, 디버거 인터페이스 및 DOM 인스펙터를 사용합니다. 웹 개발자들은 보통 브라우저 콘솔을 사용하여 디버깅과 실험적인 목적을 위해 빠른 코드 조각을 실행하고 디버깅 관련 로그 값을 확인합니다. Chrome은 GNU/Linux 터미널에서 개발자 생산성을 높이는 Bash 해석기와 같은 여러 생산성 중심 단축키를 제공하여 콘솔에서 코드 조각을 효율적으로 작성하는 데 도움을 줍니다. 이러한 Chrome 콘솔 유틸리티 단축키를 사용하여 웹 애플리케이션 디버깅 관련 작업(예: 인스펙터에서 선택된 DOM 요소 가져오기)을 빠르게 처리할 수 있습니다. 이러한 콘솔 유틸리티는 브라우저 콘솔에서만 작동하므로 웹 앱 소스 파일에서 이름 충돌을 걱정할 필요가 없습니다.\n\n이 기사에서는 Chrome에서 사용할 수 있는 여러 콘솔 유틸리티를 설명하여 웹 애플리케이션을 더 빠르게 디버깅할 수 있도록 도와드리겠습니다. 디버깅 활동 중에 번거롭고 긴 코드 입력이 필요한 마우스 클릭이나 입력을 피하고 Chrome 콘솔에서 이러한 빠른 단축키를 사용하세요.\n\n\n\n\n# 빠른 DOM 노드 선택을 위한 JQuery 스타일 셀렉터\n\n인기있는 JQuery 라이브러리는 기존의 웹 API보다 CSS 셀렉터를 기반으로 DOM 요소를 선택하는 더 생산적인 방법을 제공합니다. 만약 콘솔에서 일부 DOM 노드 속성에 액세스하거나 일부 DOM 노드를 검색해야 하는 경우는 어떨까요? 웹 앱이 JQuery를 사용한다면 JQuery를 사용할 수 있으므로 $ 구문을 사용할 수 있지만, 만약 JQuery를 사용하지 않는다면요?\n\nChrome은 JQuery 라이브러리를 사용하지 않아도 콘솔에서 $ 구문을 사용할 수 있게 해줍니다. Chrome 콘솔에서 $는 단일 요소를 즉시 쿼리할 수 있도록 document.querySelector 메서드의 단축키로 작동합니다:\n\n```js\n$('.item-01')\n```\n\n\n\n위의 코드 스니펫은 item-01 클래스 이름을 가진 첫 번째 DOM 노드를 출력합니다. 비슷하게, $$ 바로 가기는 document.querySelectorAll 메서드를 트리거하고 하나 이상의 요소를 반환합니다. 예를 들어, 다음 코드 스니펫은 모든 `h1` 요소를 출력합니다:\n\n```js\n$$('h1')\n```\n\nXPath 표현식을 기반으로 DOM 요소를 선택할 수도 있습니다. 다음과 같이 사용합니다:\n\n```js\n$x('/html/body/div')\n```\n\n\n\n# 표준 콘솔 API 단축키\n\n모든 브라우저와 Node.js와 같은 JavaScript 실행 환경은 웹 앱 코드베이스에서 디버깅을 위해 개발자들이 사용할 수 있는 완전한 기능을 갖춘 콘솔 API를 제공합니다. 예기치 않은 문제가 발생할 때 브라우저 콘솔에 몇 가지 메시지를 기록할 수 있습니다. 그런 다음 개발자 또는 사용자 테스트 중에 중요 문제를 진단하기 위해 분석할 수 있습니다. console.log, console.error, console.warn은 일반적으로 사용되는 콘솔 로깅 방법입니다.\n\nChrome은 디버깅 생산성을 향상시키기 위해 여러 콘솔 API에 대한 단축 함수 이름만을 제공합니다. dir 함수는 console.dir API 메소드를 트리거하므로 객체의 키-값 데이터를 출력하는 데 사용할 수 있습니다. 이것은 콘솔이 기본적으로 HTML 코드와 함께 요소를 출력할 때 DOM 요소 속성을 출력하는 좋은 메커니즘입니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*edY7C6664IEZlnhK3uEfCA.gif)\n\n\n\n비슷하게, 콘솔 표시 방법을 이용하기 위해 table 함수를 사용할 수 있습니다. 또한 clear 함수는 console.clear 메서드를 호출하여 브라우저 콘솔을 지웁니다.\n\n콘솔 API는 또한 성능 프로파일러를 시작하고 중지하는 두 가지 표준이 아닌 메서드를 제공합니다. Chrome은 profile 및 profileEnd 콘솔 함수 단축키를 통해 이러한 프로파일러 전용 콘솔 API 메서드를 호출하며, 다음 미리 보기에 나와 있습니다:\n\n![JavaScript Object API Shortcuts](https://miro.medium.com/v2/resize:fit:1400/1*Bh2JR81JSCzdF55B1PFeng.gif)\n\n\n\n현대적인 범용 프로그래밍 언어인 JavaScript는 거의 모든 개발 요구 사항을 위한 완전히 갖춘 미리 로드된 표준 라이브러리를 제공합니다. JavaScript는 JSON과 유사한 객체 개념과 내장 JSON 직렬화/역직렬화를 사용하여 객체를 다루는 데 생산적인 방법을 제공합니다. 모든 웹 개발자가 Object.keys 및 Object.values 메서드를 알고 있습니다. 이들은 JavaScript 객체에서 키와 값을 추출하는 데 도움이 되는 메서드입니다. Chrome 콘솔 유틸리티는 키와 값 내장 기능 바로 가기를 구현하며 디버깅 활동 중에 이러한 자주 사용되는 Object API 메서드를 생산적으로 사용할 수 있게 해줍니다.\n\n다음 객체의 키와 값을 별도로 검사해야 한다고 가정해 보겣습니다:\n\n```js\nconst doc = {\n  id: 100,\n  title: 'My document',\n  size: 'A4',\n  authorId: 100\n}\n```\n\n위 객체의 키만 출력하려면, 다음 미리보기에 표시된 대로 keys 함수를 사용할 수 있습니다.\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*kDCuc9qJcb5Af0z8nH0FOQ.gif)\n\n\"values\" 함수는 특정 객체의 모든 값을 출력하는 효율적인 방법을 제공합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*1eIQH3rgOnfb6Po5Kgu5hQ.gif)\n\n다음 이야기는 경험 많은 웹 개발자로서 알아야 할 새로운 브라우저 API를 설명합니다:\n\n\n\n\n# 브레이크포인트 설정 및 소스 코드 검사를 위한 바로 가기\n\n현대 웹 앱 디버깅 프로세스는 일반적으로 브레이크포인트와 DOM 검사를 활용합니다. 브레이크포인트는 JavaScript 디버깅을 도와주고, DOM 검사는 HTML 분석 및 CSS 기반 스타일링 개선을 지원합니다. 브레이크포인트를 설정하려면 개발자 도구 인터페이스나 디버거 JavaScript 문을 사용할 수 있습니다. Chrome 콘솔도 브레이크포인트 설정을 위한 생산성 바로 가기를 제공합니다.\n\n다음과 같은 함수가 현재 콘솔 컨텍스트에 로드되어 있고 사용 가능하다고 가정해 봅시다:\n\n```js\nfunction genArr(n) {\n  let sq = n ** 2;\n  sq = Math.min(sq, 1000);\n  let arr = [...new Array(sq).keys()];\n  return arr;\n}\n```\n\n\n\ngenArr 함수 내에서 중단점을 설정해야 한다고 가정해봅니다. 콘솔에서 debug 함수를 호출하여 자동 중단점을 활성화할 수 있습니다:\n\n```js\ndebug(genArr)\n```\n\n그러면, 개발자 도구가 genArr 함수에 자동으로 중단점을 추가할 것입니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*FkCGFnh2yVQ1O9lWH0B8fQ.gif\" /\u003e\n\n\n\n지금은 genArr 함수가 실행될 때 자동 중단점이 코드 실행을 중단시킵니다. 다음 함수 호출로 자동 중단점을 비활성화할 수 있습니다:\n\n```js\nundebug(genArr)\n```\n\n위 접근법을 사용하면 중단점을 설정하고 함수를 검색할 수 있습니다. 자동 중단점을 활성화하지 않고 함수 소스를 확인해야 하는 경우 inspect 함수가 도움이 됩니다. 특정 함수로 이동하고 콘솔에 해당 함수의 소스를 출력합니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*f33oL_zYjf0OJikBbmUxmQ.gif\" /\u003e\n\n\n\n현재 활성 요소를 검사하는 기능을 사용할 수 있어요. \n\n```js\ninspect(document.activeElement)\n```\n\n# 함수 호출 모니터링\n\n디버깅 작업 중에 함수 호출을 감지하는 여러 방법이 있어요. 일부 개발자들은 주로 콘솔에 일부 값을 출력하여 함수 호출을 감지하기 위해 console.log 문을 수동으로 사용하죠. 한편, 일부 개발자들은 중단점을 설정합니다. 이러한 접근 방법에는 여러 가지 단점이 있어요. 특정 함수가 수천 번 호출된다면, 중단점으로는 시간이 많이 소요될 거에요. 반면 콘솔.log 기반 방법을 사용하려면 소스를 수동으로 편집해야 해요.\n\n\n\n크롬 콘솔 유틸리티에는 빌트인 콘솔 함수인 monitor 및 unmonitor이 있어서 소스 파일을 직접 편집하거나 중단점을 사용하지 않고도 함수 호출을 효율적으로 모니터링할 수 있습니다.\n\n이전 genArr 함수 실행을 모니터링해야 한다고 가정해봅시다:\n\n```js\nfunction genArr(n) {\n  let sq = n ** 2;\n  sq = Math.min(sq, 1000);\n  let arr = [...new Array(sq).keys()];\n  return arr;\n}\n```\n\n먼저 특정 함수에 대해 모니터링 기능을 활성화하세요:\n\n\n\n```js\nmonitor(genArr)\n```\n\n지금부터 genArr 함수에 들어오는 모든 호출을 모니터링하고 콘솔에 입력된 인수를 출력합니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*K8rzCdmRGu0IZXTa5EV7Vw.gif\" /\u003e\n\n다음 코드 스니펫을 사용하여 genArr 함수의 함수 모니터링을 비활성화할 수 있습니다:\n\n\n\n```js\nunmonitor(genArr)\n```\n\n# 콘솔 내에서 이벤트 처리하기\n\nDevTools에는 브라우저 이벤트를 감지하는 여러 가지 방법이 있습니다. 특정 이벤트가 트리거될 때 소스 브레이크포인트를 자동으로 설정하는 이벤트 브레이크포인트를 설정할 수 있습니다. 또한 window 객체에 연결된 전역 이벤트를 찾는 기능도 제공합니다. 그렇다면 콘솔에서 웹 앱 이벤트를 직접 감지하고 탐색하고 싶다면 어떻게 해야 할까요?\n\nChrome 콘솔 유틸리티는 getEventListeners 내장 함수를 제공하여 특정 객체의 등록된 이벤트 리스너를 찾을 수 있습니다. 예를 들어, 다음 코드 조각은 현재 활성 DOM 요소 객체에 연결된 모든 이벤트 리스너를 출력합니다:\n\n\n\n```js\ngetEventListeners(document.activeElement)\n```\n\n위의 유틸리티 함수는 등록된 이벤트 리스너를 살펴보는 데 도움이 됩니다. 특정 이벤트가 어떻게 트리거되었는지를 알고 싶을 때, DevTools GUI의 이벤트 리스너 브레이크포인트 기능을 사용하지 않고는 어떻게 할 수 있을까요?\n\nmonitorEvents 및 unmonitorEvents 바로 가기 함수를 사용하면 JavaScript 객체를 기반으로 브라우저 이벤트를 모니터링할 수 있습니다.\n\n다음 코드 스니펫을 살펴보세요:\n\n\n\n```js\nmonitorEvents(document.activeElement, 'click')\n```\n\n위의 코드 조각을 콘솔에 입력하면 현재 활성 요소의 모든 클릭 이벤트를 찾을 수 있어요:\n\n![click event monitoring](https://miro.medium.com/v2/resize:fit:1400/1*LRnKHf1OPXuqUl7z6YbDag.gif)\n\n다음 코드 조각으로 이벤트 모니터링을 비활성화할 수 있어요:\n\n\n\n```js\nunmonitorEvents(document.activeElement)\n```\n\n# 줄임표 디버그 관련 변수들\n\n모든 명령 줄 해석기는 일반적으로 개발 작업을 가속화하는 다양한 생산성 중심의 단축키를 제공합니다. 예를 들어 Bash 해석기는 이전 명령의 프로세스 종료 코드를 얻기 위한 특별 매개 변수 $?를 제공합니다. 비슷하게, Chrome 콘솔 해석기는 웹 앱 디버깅 작업을 위한 각종 줄임표 변수들을 제공합니다.\n\n$_ 줄임표 변수는 콘솔에서 실행된 이전 표현식의 반환 값을 리턴합니다.\n\n\n\n아래 예시를 살펴봐주세요:\n\n\u003cimg src=\"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_1.png\" /\u003e\n\n이전에 document.activeElement 속성과 $ 쿼리 선택자 단축키를 사용하여 DOM 요소를 참조했습니다. 그러나 디버깅 중에 실제 렌더링된 DOM의 포커스를 변경하지 않고도 요소 탭(인스펙터) 내에서 DOM 트리 요소를 선택하는 것이 일반적입니다. 인스펙터에서 현재 선택된 DOM 요소를 가져오기 위한 단축 변수가 있다면 document.activeElement나 $ 기반 선택자 구문을 사용하지 않고도 콘솔에서 효율적으로 사용할 수 있습니다.\n\nChrome에서는 $0 단축 변수를 사용하여 인스펙터에서 선택된 DOM 요소를 참조할 수 있습니다. 콘솔을 통해 선택된 DOM 요소의 데이터 속성을 변경해야 한다고 가정해보세요. 다음 미리보기에 표시된 대로 수행할 수 있습니다:\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*XHlPmNHQwVPU4uTkxzMaKQ.gif)\n\n여기 이 기사의 보너스 디버깅 팁을 알려 드리겠습니다. 시스템 클립보드로 역직렬화된 JavaScript 객체를 복사하는 데 복사 함수를 사용할 수 있습니다.\n\n다음 예제 코드 조각을 살펴보세요. 이 코드는 샘플 JavaScript 객체를 시스템 클립보드로 복사합니다:\n\n```js\nconst doc = {\n  id: 100,\n  title: '내 문서',\n  size: 'A4',\n  authorId: 100\n};\ncopy(doc)\n```\n\n\n\n더 많은 생산성 중심 기능을 Chrome DevTools에서 배울 수 있는 다음 이야기를 확인해보세요:\n\n읽어줘서 고마워.","ogImage":{"url":"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeConsoleUtilitiesThatEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":8}],"page":"107","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"107"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>