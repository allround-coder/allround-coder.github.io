<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/107" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/107" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" href="/post/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LWC에서 LMS를 통한 커뮤니케이션" href="/post/2024-05-14-CommunicationThroughLMSinLWC"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">LWC에서 LMS를 통한 커뮤니케이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" href="/post/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" href="/post/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" href="/post/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Fetch API CORS 및 no-cors에 대한 궁극의 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Fetch API CORS 및 no-cors에 대한 궁극의 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기" href="/post/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러의 조화 인젝터와 디렉티브의 힘" href="/post/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러의 조화 인젝터와 디렉티브의 힘" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러의 조화 인젝터와 디렉티브의 힘" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러의 조화 인젝터와 디렉티브의 힘</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요" href="/post/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript에서 Promise의 사용법과 이유" href="/post/2024-05-14-TheHowandWhyofPromisesinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript에서 Promise의 사용법과 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript에서 Promise의 사용법과 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript에서 Promise의 사용법과 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">36<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐" href="/post/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link posts_-active__YVJEi" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"ASCII Box Editor 간단한 문제에 대한 복잡한 웹 앱 솔루션 제작","description":"","date":"2024-05-14 13:22","slug":"2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem","content":"\n\n# 아이디어의 시작\n\n모든 것은 간단한 필요성에서 시작되었습니다: 내 스크립트에서 함수로 관리되는 레이어의 시각적 표현이 포함된 코멘트를 작성하고 싶었습니다. 몇 가지 특수 문자(ASCII 문자)가 존재하여 상자의 변에는 직선, 모퉁이에는 각도, 교차점에는 십자가 있는 다이어그램을 만드는 데 복사하여 붙여넣을 수 있다는 것을 알고 있었습니다.\n\n![다이어그램](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png)\n\n모든 이러한 문자들은 함께 작동하고 정렬하기 위해 설계되었습니다. 이러한 문자들은 상자 그리기 문자로 알려져 있습니다. 그러나 문자를 복사하여 붙여넣어 복잡한 다이어그램을 수동으로 만드는 것은 지루하고 실수할 여지가 많습니다.\n\n\n\n```js\n┌─┬┐  ╔═╦╗  ╓─╥╖  ╒═╤╕\n│ ││  ║ ║║  ║ ║║  │ ││\n├─┼┤  ╠═╬╣  ╟─╫╢  ╞═╪╡\n└─┴┘  ╚═╩╝  ╙─╨╜  ╘═╧╛\n┌───────────────────┐\n│  ╔═══╗ 일부 텍스트  │▒\n│  ╚═╦═╝ 상자 안에    │▒\n╞═╤══╩══╤═══════════╡▒\n│ ├──┬──┤           │▒\n│ └──┴──┘           │▒\n└───────────────────┘▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n```\n\n이 작업을 간단하게 처리할 수있는 도구의 잠재력을 깨달았을 때, 기존 솔루션을 검색했지만 제 요구 사항을 충족하는 것은 없었습니다. 우리가 \"프로그래머의 저주\"라고 부를 수있는 것에 격려되어, 제 즉각적인 문제를 수동으로 해결하지 않고 누구나 사용할 수있는 프로세스를 자동화하는 솔루션을 생성하기로 결정했습니다.\n\n## 비전 정의\n\n내 비전은 분명했습니다: 누구나 ASCII 상자를 그리고 클릭하고 드래그하여 코멘트를 추가 할 수있는 직관적이고 쉽게 접근할 수있는 웹 앱을 개발하는 것 — Adobe Illustrator와 같은 도구의 간단함과 강력함을 반영하는 것입니다.\n\n\n\n# 핵심 구축: ASCII 아트의 로제타 스톤\n\n이 도구(ASCII Box Editor)의 기초를 다지기 위해, 나는 디지털 캔버스 상에서 서로 다른 ASCII 문자들이 어떻게 결합되는지에 대한 도전에 직면했습니다. 예를 들어, 수직 선 위에 수평 선을 그리는 것은 단순히 겹치는 것이 아니라 교차점을 형성해야 합니다.\n이러한 과정에서 나는 \"로제타\"라는 시스템을 설계하기로 결심했습니다. 이 시스템은 서로 다른 타격과 문자가 어떻게 병합되는지를 정의하는 복잡한 배열 기반 객체입니다.\n이 아이디어는 각 문자를 함수에 의해 해석될 수 있는 표현으로 변환하는 것입니다. 각 문자마다 그 카디널 포인트에 경로의 존재에 대응하는 등가 배열을 얻게 됩니다.\n\n```js\n[ ╳, ╳, ╳, ╳ ]                         \n  │  │  │  │                           \n  └──┼──┼──┼──▶ 상단에 경로가 있나요?  \n     └──┼──┼──▶ 우측에 경로가 있나요?  \n        └──┼──▶ 하단에 경로가 있나요?  \n           └──▶ 좌측에 경로가 있나요?  \n\n왼쪽 상단 모서리 문자 '┌'의 예\n       ┌┄┄┄┄┄┄┄┄┄┄┄┄┐           \n       ┆            ▽           \n    ╔══╧══╗ '┌' = [ 0, 1, 1, 0 ]   \u003e 0 = 없음\n    ║     ║            ▲  ▲  △     \u003e 1 = 경로가 이 위치에 있음\n  ┌┄╢  ┏━╸╟────────────┘  │  ┆  \n  ┆ ║  ┃  ║               │  ┆  \n  ┆ ╚══╤══╝               │  ┆  \n  ┆    └──────────────────┘  ┆  \n  └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘  \n```\n\n이러한 논리를 기반으로, 각 문자에 대한 모든 등가 배열을 보관할 asciiBox_Rosetta 객체를 생성했으며, 문자('char') 표현에서 배열('code')로 변환하고 그 반대로 변환하는 두 가지 함수를 첨부했습니다.\n\n\n\n```js\n// ROSETTA: ASCII 문자를 배열 표현으로 매핑하기\nclass asciiBox_Rosetta {\n  constructor() {\n    this.rosetta = {\n      '─': [0, 1, 0, 1], // 수평선\n      '│': [1, 0, 1, 0], // 수직선\n      '┼': [1, 1, 1, 1], // 교차점\n      // 기타 등등...\n    };\n  }\n  // 문자와 코드 사이의 변환을 위한 메소드\n  getCharFromCode(code) {…}\n  getCodeFromChar(char) {…}\n}\n```\n\n로제타를 사용하면, 나는 이제 문자들 간 상호작용에 기반한 동적 문자 변환을 수행할 수 있는 간단한 중첩 문자 논리를 구성할 수 있었습니다. 이는 디지털 회로의 논리 연산을 모방하지만 텍스트 캔버스 상에서 이루어집니다.\n\n```js\n'─'와 '│' 사이의 조합 예제\n\n '─' + '│' = [0, 1, 0, 1] + [1, 0, 1, 0] = [1, 1, 1, 1] = '┼'   \n└┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┈┈┈┈┈┈┈┈┈┘ └┈┈┈┘  \n수평선      배열 표현          최종 배열       교차점\n\u0026 수직선                                          \n```\n\n이 간단한 논리 알고리즘은 문자 간의 중첩을 효과적으로 처리하는 데 매우 효과적이었습니다. 이 알고리즘을 통해, 나는 그림을 그리기 위해 마우스 이벤트를 캡처하고, 굵은 글꼴, 점선, 이중 선 등의 스타일 변경 및 화살표와 같은 방향 표시용 끝 캡슐을 통합하는 것만으로도 가능했습니다.\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*tPD4T6_yVr6wBlKDj6RKGw.gif\" /\u003e\n\n# 기능 구현: 선 그리기를 넘어서\n\n정적 디자인으로부터 완전히 상호작용형 웹 애플리케이션으로의 여정은 다양한 사용자 도구를 관리하는 것을 포함하여 수많은 도전을 안겨주었습니다. 각 도구마다 고유한 특성과 동작이 있기 때문에 그것을 관리하는 것이 쉽지 않았습니다.\n\nASCII Box Editor의 핵심은 asciiBox_ToolManager인데, 이 동적 시스템은 사용자의 작업에 따라 도구를 전환할 수 있도록 설계되었습니다. 이 시스템은 부드러운 사용자 경험을 제공할 뿐만 아니라 코드베이스를 획기적으로 간소화하는 데 중요합니다.\n\n\n\n```js\n// 도구 관리자: 도구의 활성화와 사용을 관리합니다\nclass asciiBox_ToolManager {\n    constructor(db, styleContainer) {\n        this.currentTool = null;  // 현재 활성화된 도구\n        this.previousTool = null;  // 빠른 전환을 위해 이전에 사용한 도구\n        // 일련의 도구로 초기화\n        this.tools = {\n            \"직선 그리기\": new asciiBox_DrawLine(this),\n            \"상자 그리기\": new asciiBox_DrawBox(this),\n            \"지우개\": new asciiBox_Erase(this),\n            // 여기서 더 많은 도구를 초기화합니다...\n        };\n    }\n    // 사용자 선택에 따라 도구를 설정하는 함수\n    setTool(toolName) {\n        this.previousTool?.deactivate();  // 이전 도구 비활성화\n        this.currentTool = this.tools[toolName];\n        this.currentTool.activate();  // 새 도구 활성화\n    }\n}\n```\n\n전통적인 절차적 코드는 각 도구를 별도의 함수로 처리하거나 if-else 문의 일련의 문장으로 처리할 수 있었으며, 이는 코드가 비대하고 반복적이며 유지보수하기 어렵게 만들었습니다. 반면, 객체지향 접근 방식은 각 도구의 기능을 클래스 내부에 캡슐화합니다. 이로 인해 코드가 더 깨끗하고 디버깅하기 쉬워지면서 확장성도 향상됩니다. 새로운 도구를 추가하는 것은 새 클래스를 정의하고 도구 관리자에 추가하는 것만으로 간단해집니다.\n\n각 도구는 일반 asciiBox_Tool 클래스에서 상속을 받으며 활성화 및 비활성화와 같은 공통 동작을 정의하고 특정 동작은 각 도구의 필요에 맞게 하위 클래스에 재정의됩니다. 이 다형성은 asciiBox_ToolManager가 도구 세부 사항에 대해 무관하게 유지되면서 다양한 기능을 활성화할 수 있도록 합니다.\n\n```js\n// 일반 도구 클래스\nclass asciiBox_Tool {\n    constructor(name, manager) {\n        this.name = name;\n        this.manager = manager;\n        this.isActive = false;\n    }\n    activate() { this.isActive = true; }\n    deactivate() { this.isActive = false; }\n    onMouseDown(args) { /* 기본 마우스 다운 동작 */ }\n}\n\n// 특정 도구 생성\nclass asciiBox_Select extends asciiBox_Tool {\n    constructor(manager) {\n        super('선택', manager);\n        // 더 많은 초기화 변수\n    }\n    // 사용자 입력 이벤트 처리를 위한 함수 로직\n}\n```\n\n\n\n사용자 상호작용의 세부 사항을 주의 깊게 고려하여 필요한 모든 도구를 설정했습니다. 간단한 클릭부터 복잡한 드래그 앤 드롭 제스처까지 ASCII Box Editor가 모든 단계에서 직관적으로 유지될 수 있도록했습니다.\n이 유연한 아키텍처는 많은 시간을 절약했습니다. 앱이 발전함에 따라 asciiBox_ToolManager의 유연성으로 인해 새로운 도구와 스타일을 소개할 수 있었지만 이전 기능의 핵심 기능을 방해하지 않았습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jJFHQSLocMxTWVT5nMofiA.gif)\n\n# 여정이 계속됩니다\n\n처음부터 비전은 간단한 필요성을 보편적인 해결책으로 변형하는 것이었습니다. ASCII Box Editor는 그 비전의 실행입니다. ASCII 코멘트를 생성하는 것을 간소화하면서도 정교한 디자인 도구의 간편함과 강력함을 유지합니다.\n\n\n\n위 설명에서 볼 수 있듯이, 때로는 \"프로그래머의 저주\"가 초기 도전을 벗어나 혁신적인 해결책을 이끌어낼 수 있습니다.\n\n어떻게 작동하는지 궁금하신가요? ASCII Box Editor를 한 번 시도해 보세요!\ntheokva.github.io/ascii-box-editor 👋\n\n![출력](/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_1.png)\n\n—Theo\n\n\n\n만약 이 기사가 마음에 드셨다면 👏 클랩(clap)을 부탁드려요. \n더 많은 이야기를 보시려면 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png"},"coverImage":"/assets/img/2024-05-14-ASCIIBoxEditorCraftingacomplexweb-appsolutionforasimpleproblem_0.png","tag":["Tech"],"readingTime":6},{"title":"LWC에서 LMS를 통한 커뮤니케이션","description":"","date":"2024-05-14 13:20","slug":"2024-05-14-CommunicationThroughLMSinLWC","content":"\n\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png)\n\nSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\n\n# Lightning Message Service란?\n\nLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\n\n\n\n\n그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\n\nLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\n\n아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\n\n\n\n# 라이트닝 메시지 서비스(LMS) 이해하기:\n\nLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\n\n라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\n\n## 1. 발행자(Publisher):\n\n\n\n- Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\n- 이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\n- Publisher 구성 요소를 생성할 때는 `@salesforce/messageChannel` 모듈에서 `publish()` 함수를 import해야 합니다.\n- 이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\n\n## 2. Subscriber:\n\n- Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\n- 이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\n- 중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png)\n\n\n\n## 주의 !\n\n# LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\n\n## 메시지 채널 메타데이터 정의:\n\n컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\n\n\n\n- Salesforce 프로젝트 구조의 `force-app/main/default` 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\n\n2. 이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\n\n3. 아래 코드를 참고하여 .xml 파일에 `lightning message field`를 정의해주세요:\n\n\nsampleMessageChannel.messageChannel-meta.xml\n\n\n\n\nmd\n```js\n\u003c!--?xml version=\"1.0\" encoding=\"UTF-8\"?--\u003e\n\u003clightningmessagechannel xmlns=\"http://soap.sforce.com/2006/04/metadata\"\u003e\n    \u003cmasterlabel\u003eSampleMessageChannel\u003c/masterlabel\u003e\n    \u003cisexposed\u003etrue\u003c/isexposed\u003e\n    \u003cdescription\u003eThis is a sample Lightning Message Channel.\u003c/description\u003e\n     \n    \u003c!-- Define message payload fields --\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordId\u003c/fieldname\u003e\n        \u003cdescription\u003eThis is the record Id that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordData\u003c/fieldname\u003e\n        \u003cdescription\u003eThe current data representing the record that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n\u003c/lightningmessagechannel\u003e\n```\n\n## 설명:\n\n- `isExposed` 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\n- `lightningMessageFields` 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 `recordId`를 정의할 수 있습니다.\n- `description` 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\n- `.messageChannel-meta.xml` 파일이 작성되면 Salesforce org에 배포하세요.\n\n## 메시지 서비스 기능 가져오기:\n\n\n\n\n번역 : \n\n당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\n\n```js\nimport { publish, subscribe, unsubscribe, APPLICATION_SCOPE, MessageContext } from 'lightning/messageService';\nimport msgService from '@salesforce/messageChannel/messageChannelName__c';\n```\n\n## 메시지 서비스 범위 정의:\n\n`@wire 어댑터`를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 `@wire 어댑터`로만 스코핑이 가능합니다.\n\n\n\n예시:\n\n```js\n@wire(MessageContext)\nmessageContext;\n```\n\n# 메시지 채널 발행:\n\n메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 `publish()` 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\n\n\n\n```js\nconst messagePayload = {\n    recordId: '0012y00000L5R6jAAF',\n    recordData: { /* 레코드를 나타내는 데이터 */ }\n};\npublish(this.messageContext, msgService, messagePayload);\n```\n\n`publish()` 메소드는 3개의 파라미터를 받습니다 :\n\n- 메시지 컨텍스트 (객체 타입)\n- 메시지 채널 (객체 타입)\n- 메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\n\nmessageContext : `MessageContext` 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\nmessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 `@salesforce/messageChannel`과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\n\nmessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\n\n# 메시지 채널 구독:\n\n\n\n특정 메시지 채널의 메시지를 구독하려면 `subscribe()` 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\n\n```js\nthis.subscription = subscribe(\n    this.messageContext,\n    msgService,\n    (message) =\u003e this.handleMessage(message)\n);\n```\n\n`subscribe()` 메서드는 4개의 매개변수를 받습니다:\n\n- 메시지 컨텍스트 (객체 형식)\n- 메시지 채널 (객체 형식)\n- 리스너 (함수 형식)\n- 구독자 옵션 (객체 형식)\n\n\n\n메시지 컨텍스트: `MessageContext` 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터를 통해 가져오거나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\n메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 `@salesforce/messageChannel`을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\n\n리스너: 발행된 메시지를 처리하는 함수입니다.\n\n\n\nsubscriberOptions: (선택 사항) 이 객체는 `'scope: APPLICATION_SCOPE'`로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. `lightning/messageService`에서 `APPLICATION_SCOPE`를 가져와야 합니다.\n\n# 메시지 채널 구독 취소:\n\n메시지 채널 구독을 취소하려면 `unsubscribe()` 메서드를 사용하고, `subscribe()` 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\n\n```js\nunsubscribe(this.subscription);\n```\n\n\n\n# Salesforce Lightning Message Service를 언제 사용해야 할까요?\n\n라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\n\n- 부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\n- 동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\n- 크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\n- 동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\n\n다음은 Lightning Message Service의 사용 예시 시나리오입니다:\n\n\n\n당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\n\n# Salesforce Lightning Message Service의 제한 사항\n\n- LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\n- LMS는 iframe에서 작동하지 않습니다.\n- LMS는 Salesforce 클래식에서 작동하지 않습니다.\n- Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\n\n# 결론:\n\n\n\n라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\n\n\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\n\n즐거운 LWC 코딩하세요!\n\n더 자세한 내용은 아래 링크를 방문해주세요:","ogImage":{"url":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png","tag":["Tech"],"readingTime":7},{"title":"네덜란드의 사무실 위치를 나타내는 맵 시각화 - GeoJSON, D3 및 SVG를 사용하여","description":"","date":"2024-05-14 13:18","slug":"2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG","content":"\n\n![지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png)\n\nGeoJSON 데이터셋과 JavaScript d3.js를 사용한 SVG 시각화의 결합은 지리적 데이터(지역, 국가, 주, 성, 도시 등)에 대한 풍부하고 상호 작용적인 시각화를 만드는 데 매우 가치가 있습니다. 이 기사에서는 저의 거주 지역인 네덜란드에 이 강력한 결합을 적용할 것입니다. 네덜란드의 12개 성에 대한 데이터가 포함된 GeoJSON 파일을 찾아서 d3.js를 사용하여 간단한 웹 애플리케이션에서 국가와 그 성을 시각화할 것입니다. 그런 다음, 저가 CTO로서 역할을 맡고 있는 Conclusion 회사들의 사무실 위치를 나타내는 마커를 추가할 것입니다.\n\n최근 몇 개의 기사에서는 세계 데이터셋에서 특정 속성에 따라 국가에 색상을 할당한 테마별 세계지도를 사용한 데이터 시각화에 대해 d3.js 라이브러리의 사용법을 소개했습니다. 이를 위해 SVG와 함께 사용하는 방법을 소개했는데, GeoJSON 데이터 형식은 국가 및 주에서 도시, 호수 및 산림까지 다양한 지리적 정의가 가능합니다. 어떻게 지도를 다른 속성 간에 쉽게 전환하고 상호 작용성을 추가할 수 있는지(국가를 클릭하여 선택하고 지도의 회전 또는 동서 방향 이동 변경)를 보여 주었습니다. 네 번째 기사에서는 프로그래밍 방식과 사용자 시작으로 확대(그리고 다시 축소)하는 두 가지 다른 방법에 대해 논의했습니다.\n\n이 기사에서는 이전 기사에서 만든 것을 적용하여 네덜란드 관련 데이터를 다룰 것입니다.\n\n\n\n# 네덜란드 시각화\n\nd3.js를 사용하여 세계의 일부를 시각화하는 첫 단계는 분명히 지리 정보를 제공하는 GeoJSON 파일을 찾는 것입니다. 조금 찾아보니 Cartomap GitHub 저장소를 발견했는데, 다양한 지역 시스템에 대한 지리 정보를 제공하는 유용한 GeoJSON 파일이 많이 있습니다. 재판소, 소방서, 노동시장, 관광, 보건, 자치구, 도시지역, 청소년, 상공회의소, 농업, 공공시설, 경찰, 지방, 소속기관, 동네, 안전 지역 등을 위한 파일들이 많이 있습니다. 대부분의 파일은 여러 해에 대해 사용 가능합니다.\n\n저는 wgs84/provincie_2023.geojson 파일을 활용하기로 결정했습니다. 이 파일은 12개의 지방에 대한 경계 점의 지리 좌표를 포함하고 있습니다. 각 지방의 이름도 포함되어 있습니다. 이것만 있으면 지도를 그릴 수 있습니다.\n\n![네덜란드 지역의 공식 위치 시각화 지도](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_1.png)\n\n\n\n저는 세계를 시각화하는 기사에서 대부분 했던 작업을 가져왔어요. \"country/countries(국가/국가들)\"에 대한 모든 참조를 \"area/areas(지역/지역들)\"로 변경했어요. 여기서 적절한 초기 축척 요소(네덜란드는 작은 국가이기 때문에 대규모 축척로 했을 때 거의 보이지 않는다)와 적절한 투영 회전을 찾았어요. d3.geoEquirectangular 투영 대신에 이제 d3.geoMercator를 사용하고 있어요(지구의 모양이 투영에 방해가 되지 않는 더 작은 국가에 더 적합해요). 국가의 형태에 따라 mapHeight(너비에 비해 상대적으로 높이를 증가했어요).\n\nGeoJSON 기능에서 제공되는 제목(마우스 호버 텍스트) 및 식별에 관한 내용을 제공하는 상수를 정의했어요:\n\n이러한 변경 사항은 redrawMap() 함수에서 나타납니다:\n\n\n\n![그림1](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_3.png)\n\n아래는 영역을 선택하거나 해제하는 논리에 대한 코드 예시입니다:\n\n![그림2](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_4.png)\n\n현재 index.html 파일의 상태입니다. GitHub Pages에서 데모를 확인해보세요.\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*GUemI5VHeyQPqQiATAoNZQ.gif\" /\u003e\n\n# 지도상의 위치 표시\n\n이것은 좋은 첫걸음입니다: 네덜란드와 그 주요 지역 구획의 시각화입니다.\n\n한 발 더 나아가서 지도에 위치를 추가해봐요. 도시를 대표하는 지리적 지점들이나, Conlusion 사무실 위치 등을 예로 들 수 있습니다.\n\n\n\n이 GeoJSON 파일에는 대도시 지역이 포함되어 있습니다. 이 지역은 다각형을 통해 다시 정의됩니다. 이들은 지방에 그려질 수 있으며, 해당 국가의 주요 도시를 나타낼 수 있습니다.\n\n도시 지역을 포함하려면 필요한 변경 사항은 다음과 같습니다:\n\n- 도시 지역을 위한 스타일 클래스를 정의합니다.\n- City GeoJSON을 로드하고 이를 지방 세부 정보와 병합합니다.\n- 각각 지방과 도시에 대한 생성된 모양에 적절한 스타일 클래스를 할당합니다.\n\n클래스 도시:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_5.png\" /\u003e\n\n도시 GeoJSON을 로딩하고 병합:\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_6.png\" /\u003e\n\nSVG 모양을 렌더링할 때 적절한 스타일 클래스 할당하기:\n\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_7.png)\n\n생성된 지도는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_8.png)\n\n모든 도시 지역이 강조되어 있습니다. 각각에는 호버 텍스트에 해당하는 이름이 있습니다. 그리고 도시 지역도 마찬가지로 선택할 수 있습니다:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_9.png\" /\u003e\n\n이 시점의 index.html 파일입니다. 그리고 라이브 데모입니다.\n\n이제 도시를 다각형 영역으로 그리는 대신, 각 도시를 원으로 나타내는 것이 더 나을 것 같습니다. 이것은 Polygon 대신 GeoJSON Point에서 파생됩니다.\n\n이를 달성하기 위해 해야 할 일은 도시 GeoJSON의 모든 요소를 처리하고 각각을 만들어 집합니다. 그런 다음 치에서 파생된 geojsonData에 추가하는 것입니다.\n\n\n\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_10.png)\n\n생성된 지도:\n\n![사무실 위치 지도 시각화](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_11.png)\n\n네덜란드 지리에 익숙하신 분들은 이 도시 원들이 실제 도시가 위치한 곳에 모두 있는 것이 아니라는 점을 알 수 있을 것입니다. 분명히, 도시 영역을 경계 지정하는 직사각형의 중심이 항상 실제 도시 중심과 같은 곳에 있는 것이 아닙니다.\n\n\n\n\n점(도시)의 시각화 크기와 색상을 조절할 수 있어요. 가장 간단한 방법은 원의 반지름을 사용자 정의하여 경로 생성기를 정의하는 것입니다: d3.geoPath().pointRadius(custom-circle-radius);\n\nGeoJSON 기능을 위한 SVG 객체를 만들 때 사용되는 경로 생성기 함수를 수정하여 Points에 대한 사용자 지정 함수를 호출할 수 있어요.\n\n사용자 정의 함수를 구현한 예시 중 하나는 간단한 집 모양(사실 직사각형과 삼각형입니다)을 그리는 경로를 만드는 함수입니다:\n\n\n\n![Map Visualization](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_13.png)\n\n지도 상에 각 도시의 위치에 간단한 집 모양이 표시되었습니다:\n\n![Map Update](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_14.png)\n\n이 시점에서의 index.html 파일 상태 및 실시간 데모 페이지입니다.\n\n\n\n# 컨클루전 사무실 위치 추가\n\n2023년 5월 1일 현재, 저는 IT 기업 그룹인 컨클루전의 CTO입니다. 컨클루전은 각기 다른 전문성, 문화, 역사(및 미래), 제안 및 고객을 갖춘 30개 이상의 자율적인 회사들로 구성되어 있습니다. 이러한 회사들은 내부적으로 협력하여 더 스마트하고 효율적으로 일을 처리하고, 노하우와 경험을 공유하는 좋은 실천 방법을 기반으로 한 활동, 스포츠 이벤트, 문화 활동 및 자선 행사에서 더 즐거운 시간을 보내며, 동료들이 자매 회사의 다른 역할에서 경력을 쌓을 수 있도록 가능하게 하며, 외부적으로는 고객에게 상호 일치하는 다양한 서비스를 제공하기 위해 협력합니다.\n\n네덜란드 내에서 컨클루전은 12개 이상의 장소에 사무실을 두고 있습니다. 대부분은 개별 회사용이며 일부는 여러 회사를 수용하고 있습니다. 대부분의 동료들은 사무실에 출근하고 싶은 경우 모든 사무실을 이용할 수 있습니다.\n\n모든 컨클루전 사무실 위치를 시각화하기 위해 네덜란드의 지도를 사용할 예정입니다.\n\n\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_15.png)\n\n결론 사무실의 위치를 나타내는 새로운 GeoJSON 파일을 추가할 거에요. 이 파일은 저 혼자 만들어야 해요. 이 위치들은 Point 유형의 특징이며 방금 도시들에 사용한 집 아이콘으로 시각화되어야 해요.\n\n사무실을 위한 새로운 CSS 스타일을 정의했어요.\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_16.png)\n\n\n\n새로운 파일이 로드되고 사무실 위치에 대한 데이터가 geojsonData 세트에 포함되었습니다\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_17.png)\n\n기능이 사무실 위치를 설명하는 경우 작은 집 아이콘을 그릴 사용자 정의 기능이 호출됩니다:\n\n![이미지](/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_18.png)\n\n\n\n다음과 같은 지도가 생성됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-네덜란드의사무소위치시각화-GeoJSON, D3, SVG_19.png\" /\u003e\n\n실시간 데모에서 직접 이 결과를 확인할 수 있습니다. index.html의 현재 상태도 확인할 수 있습니다.\n\n다음 단계로는 오피스를 클릭하면 해당 위치와 그 안에 위치한 회사에 대한 정보를 보여주는 팝업 창을 구현할 수 있습니다 (필요한 정보는 이미 GeoJSON 파일에 포함되어 있습니다).\n\n\n\n# 결론\n\n이 글에서는 GeoJSON 데이터를 네덜란드의 맥락에서 시각화할 수 있다는 것을 보여드렸어요. 전 세계 지도에 대한 모든 코드를 재사용하여 네덜란드의 지방 및 도시 데이터가 포함된 GeoJSON 파일을 손쉽게 추가하고 시각화할 수 있습니다 (매우 조정된 스케일 요인을 사용). 그리고 커스텀 포인트 표현을 소개했어요 - 결론 생태계의 사무실 위치를 보여주기 위해 (네덜란드에 있습니다.; 독일, 벨기에, 포르투갈, 스페인, 남아프리카에도 위치가 있어요. 혹시 다음 글에서 이를 추가할지도 몰라요).\n\n# 자료\n\n이 글에 대한 코드가 포함된 GitHub 저장소, 새로운 GeoJSON 파일을 포함하고 있어요 - 결론 사무실 위치를 나타내기 위해 제가 직접 만들어야 했던 파일이에요.\n\n\n\n내 이전 기사들을 통해 세계지도 데이터 시각화에 대해 소개하겠습니다:\n\n1. 나라 데이터 시각화를 위한 대화형 세계지도 생성하기 - https://medium.com/@lucasjellema/create-interactive-world-map-to-visualize-country-data-baa5b242bfbb - d3, SVG 및 JavaScript를 사용한 세계지도 데이터 시각화 소개.\n\n2. 세계지도 시각화를 활용한 데이터로 세계를 소개하기 - https://medium.com/@lucasjellema/presenting-the-world-in-data-using-world-map-visualization-d3-kaggle-world-data-set-7c16ca207fb0 - 첫 번째 기사에서 데이터 시각화에 대한 간단한 접근 방식과 Kaggle의 풍부한 데이터 세트를 결합하여 세계의 모든 국가에 대한 교육, 건강, 경제, 인구 통계, 기후 등 많은 흥미로운 세부 정보를 제공합니다.\n\n3. 세계지도 내 대화형 데이터 시각화 - 확대, 이동, 범례 - https://medium.com/@lucasjellema/interactive-data-visualization-in-world-map-translate-select-legend-popup-4d28261110df - 세계지도에 상호 작용을 추가하는 것에 대해 자세히 살펴보겠습니다. 특히: 지도의 회전을 변경, 나라 선택(클릭으로), 나라 세부 정보 팝업 창 표시 및 범례 - 색상 스케일 (히트맵 색상을 숫자 값에 매핑) 표시하기.\n\n\n\n4. World Map Data Visualization with d3.js, GeoJSON and SVG - Zooming, Panning and Dragging\n- 더 자세한 내용은 [여기](https://medium.com/@lucasjellema/world-map-data-visualization-with-d3-js-geojson-and-svg-zooming-and-panning-and-dragging-194fb16dec9a)를 확인해보세요!  \n- 월드맵에 확대/축소, 이동 및 드래그 기능을 사용자 및 프로그램으로 구현했습니다.\n- 원본 게시물은 2024년 1월 2일에 [여기](https://technology.amis.nl)에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png"},"coverImage":"/assets/img/2024-05-14-MapVisualizationofofficelocationsinTheNetherlands-usingGeoJSOND3andSVG_0.png","tag":["Tech"],"readingTime":8},{"title":"대학에서 프로그래밍을 배우는 것이 여전히 도움이 될까요","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays","content":"\n\n## 프로그래밍\n\n![이미지](/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png)\n\n대학이나 대학교에 다니는 것이 프로그래밍에 도움이 되는 이유를 정리해 보았어요.\n\n1. 대학에 다니면 전문가로 성장할 수 있어요. 직업에 상관없이 공부를 하면 뚜렷한 차이가 있어요. 대학은 교육을 제공하고 그 기반이 되는 것으로 각자 자아를 세워나가게 해줘요. 니든, 버핏, 또는 빌 게이츠처럼 천재가 아닌 이상, 대학은 무궁무진한 장점을 줄 거예요.\n\n\n\n2. 요즘에는 온라인으로 모든 것을 배울 수 있어요. Coursera나 Udemy와 같은 무료 또는 믿을 수 없을 만큼 저렴한 강좌를 제공하는 플랫폼이 많이 있어요. 어떤 대학들은 수업을 녹화해서 유튜브에 무료로 올리기도 해요.\n\n문제는 여전히 자격 증명과 학위를 높이 평가하는 사회에서 살고 있다는 거예요. 그래서 대학을 가지 않은 사람이 일자리를 구하는 데 훨씬 더 어려움을 겪을 확률이 매우 높아요. 좋은 프로그래머가 되려면 반드시 대학에 다녀야 하는 것은 아니지만, 다녀도 안 하지 않는 게 무의미한 건 아니에요.\n\n3. 대학의 주요 기능은 많은 주제에 대한 비교적 기본적인 개요를 제공하는 것이에요. 유용하긴 하지만 스스로 계속 공부해야 해요. 스스로 공부하거나 대학에서 배우는 차이는 대학이 당신이 도움이 되지 않을 것 같아서 무시하거나 지루하다고 생각하던 주제를 봐야 한다는 점이에요. 또한 고려해야 할 내용이라고 전혀 모르던 주제까지 볼 수도 있어요. 대학은 또한 당신에게 (컨퍼런스, 강좌, 인턴쉽과 같은) 문을 여는데, 이를 통해 당신의 시야를 넓힐 수 있게 해줄 거에요.\n\n4. 대학은 좋은 프로그래머를 보장해 줄 수준이 아니에요. 프로그래밍에 전념하지 않는 가득 찬 강의가 많이 있어서 소중한 시간을 낭비하게 될 수도 있어요. 게다가, 이 수업은 스스로 알고 있거나 모르는지 알려줘야 하는 학생들을 대상으로 같은 내용을 가르치기 때문에, 많은 대학들이 특정 언어의 여러 레벨을 제공하지 않아요. 하지만 당신이 지식의 표면을 긁어 보는 데는 도움이 될 거에요.\n\n\n\n5. 보통 프로그래머들이 더 나아지고 있다고 생각해요. 왜냐하면 그들은 더 좋은 기반으로 시작하기 때문이에요. 이 직업에서는 매일 무언가가 발명되고, 많은 해를 경험을 통해 배우는 것은 처음부터 그 가치가 무엇이며 막다른 길에 뉴런을 낭비하지 않는 것과는 다릅니다.\n\n6. 대학교는 말하자면, 어떻게 배우는지를 가르쳐줍니다. 자원을 찾아내고 어디에서 찾을 수 있는지를 아는 것이죠. 대학교가 당신을 좋은 프로그래머로 만든다고 생각하지 않아요. IDE(코드를 작성하는 환경)과 처음으로 대면했을 때, 색깔에 놀랐어요. 첫 디버깅을 했을 때, 브레이크포인트를 설정할 수 있다는 것을 보고 놀랐어요.\n\n아직도 세상에는 직업 세계를 접하지 않은 공룡 교수님들이 있는 대학교가 있어요. 그들은 실제로 어떻게 하는지 알지 못해요. 오늘날은 어떤 IDE나 버전 관리 도구, 모든 친구들에게도 참을 수 없어요.\n\n7. 대학교에서는 배우는 법을 배웁니다. 미래의 프로그래머로, 당신은 스스로 학습하는 습관을 길러야 합니다. 때로는 강제적인 속도로 학습해야 할 때도 있죠.\n\n\n\n프로그래밍 스킬의 90%를 스스로 얻는다는 것을 이해한다면, 대학 외부에서 공부하거나 동료 학생들과 협력하면서 얻게 될 것이다.\n\n그래서, 네, 대학은 당신을 더 나은 프로그래머로 만들어줄 것입니다. 교과목들이 당신에게 가르치는 것만으로 충분히 숙련된 프로그래머로 성장할 수 있다고 기대한다면, 그렇지 않습니다. 대학은 당신을 더 나은 프로그래머로 만들어주지 않을 것입니다.\n\n훈련을 통해 많은 계획이 오랜 시간 동안 세심하게 고안되고 개선되어온 것을 알 수 있습니다. 이는 과거의 프로그래머들에 의해 잘 계획된 구조와 체계의 유형과 문제 분류를 교육합니다. 좋은 코드를 만드는 것은 창의력의 문제이지만, 그 창의력이 더 복잡한 구조와 체계에서 작동하며, 과거에 다른 사람들이 잘 계획한 것들을 이용한다면, 엄청난 힘이 됩니다.\n\n나는 코드를 작성하는 데에 특별히 전념하지는 않지만, 주로 계산 소프트웨어를 사용하여 무척 뛰어난 방식으로 \"프로그래밍\"하는 라인들을 사용합니다. 물론, 대학에서 가르쳐준 것이 매우 유용했기 때문에 처음부터 쓰는 것이 아니라 모든 것을 더 효율적으로 만드는 순차적인 구조를 사용합니다.\n\n\n\n좋은 프로그래머가 되는 데에는 개인적인 기술이 필요하지만, 수십 년 동안 다른 사람들이 개발한 구조를 활용하여 자신의 재능을 향상시키는 것은 명백한 이점이 있어요!\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 이 포스트를 나가기 전에:\n\n- 반드시 체리와 작가를 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 컨텐츠를 처리해야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io 에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png"},"coverImage":"/assets/img/2024-05-14-DoesCollegeStilHelpYouWithProgrammingTheseDays_0.png","tag":["Tech"],"readingTime":3},{"title":"Fetch API CORS 및 no-cors에 대한 궁극의 가이드","description":"","date":"2024-05-14 13:16","slug":"2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png\" /\u003e\n\n웹 애플리케이션에서 제3자 API 또는 서버에서 데이터를 가져와야 하는 경우가 있나요? 그렇다면, 요청한 데이터에 액세스하는 데 방해가 되는 Cross-Origin Resource Sharing (CORS) 오류를 만날 수도 있습니다.\n\n이 블로그 포스트에서는 Fetch API에서 CORS 및 No-CORS 모드를 사용하여 이러한 제약을 극복하고 외부 소스에서 데이터를 성공적으로 가져오는 방법을 살펴볼 것입니다.\n\n먼저, CORS가 무엇이며 왜 중요한지 이해해 봅시다.\n\n\n\n\n그러나 웹 애플리케이션에서 제3자 API 또는 서버로 요청을 보내야 할 때는 장애가 될 수도 있습니다.\n\n![image](/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_1.png)\n\nFetch API는 웹 애플리케이션에서 HTTP 요청을 보내는 방법을 제공합니다. Fetch를 사용하면 fetch() 함수의 mode 옵션을 사용하여 요청의 모드를 지정할 수 있습니다.\n\nmode 옵션은 `cors`, `no-cors`, `same-origin`, 또는 `navigate` 중 하나로 설정할 수 있습니다.\n\n\n\n`cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하며, 서버가 허용 여부를 나타내는 Access-Control-Allow-Origin 헤더로 응답할 것을 기대합니다.\n\n서버가 적절한 헤더로 응답하면, 브라우저는 요청을 계속 진행하도록 허용하고 응답을 웹 페이지에 제공합니다. 이 모드는 제3자 API나 서버에 요청을 보낼 때 유용합니다.\n\n```js\nfetch('https://example.com/api/data', {\n  mode: 'cors',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    key1: 'value1',\n    key2: 'value2'\n  })\n})\n.then(response =\u003e response.json())\n.then(data =\u003e console.log(data))\n.catch(error =\u003e console.error(error));\n```\n\n`no-cors` 모드에서는 브라우저가 요청에 Origin 헤더를 포함하지 않으며, 서버의 응답이 불투명하게 처리되어 JavaScript 코드로 액세스할 수 없습니다. 이 모드는 서버로부터의 응답이 필요하지 않은 경우, 예를 들어 제3자 애널리틱스 서비스에 요청을 보낼 때 사용됩니다.\n\n\n\n이제 Fetch API에서 CORS 및 No-CORS 모드를 사용하는 방법을 이해했으므로, 언제 사용해야 하는지에 대해 이야기해보겠습니다.","ogImage":{"url":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png"},"coverImage":"/assets/img/2024-05-14-FetchAPITheUltimateGuidetoCORSandno-cors_0.png","tag":["Tech"],"readingTime":2},{"title":"Vue 3 올바른 방법으로 기본 입력 컴포넌트 구현하기","description":"","date":"2024-05-14 13:14","slug":"2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay","content":"\n\n대규모 애플리케이션을 만드는 것은 아주 큰 탑을 짓는 것과 같을 수 있어요. 하지만 그 탑들이 작고 간단한 건물 블록들로 이루어져 있는 것처럼 말이죠. 이 기본 부품 중 하나가 입력 상자인데요. 기본적으로 보일 수도 있지만, 복잡한 기능을 갖추게 하면 정말 복잡해질 수 있어요.\n\n함께 기본 입력 컴포넌트를 구현해봐요. 이것은 어떤 애플리케이션을 만들 때 중요한 작은 단계일 거예요.\n\n## 네이밍\n\n명명하는 것은 어렵죠. 다행히 Vue 스타일 가이드는 기본 컴포넌트의 이름을 Base App 또는 V 접두사와 함께 사용하는 것을 강하게 권장하고 있어요.\n\n\n\nAppInput.vue 이름은 우리의 사용 사례에 딱 맞는 것 같아요.\n\n## 초기화\n\n먼저 일관성을 위해 CSS 초기화가 필요해요.\n\n```js\nnpm install normalize.css\n```\n\n\n\n```js\n/* main.css */\n@import 'normalize.css'\n```\n\n## Basic Styles\n\n기본 스타일부터 시작해봅시다. 우선 입력란에 대한 기본 구현부터 해보겠습니다. 지금은 모든 입력란이 동일한 모양과 느낌을 가지도록 하는 것이 목표입니다.\n\n```js\n\u003ctemplate\u003e\n  \u003cinput\n    type=\"text\"\n    class=\"input\"\n  /\u003e\n\u003c/template\u003e\n\n\u003cstyle lang=\"scss\" scoped\u003e\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: #f5f8fa;\n  border: 1px solid #cccccc;\n  padding: 8px 20px;\n  outline: 0;\n  border-radius: 8px;\n}\n\u003c/style\u003e\n```\n\n\n\n사용법이 간단합니다.\n\n```js\n\u003cscript setup lang=\"ts\"\u003e\nimport AppInput from '@/components/AppInput.vue'\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cmain\u003e\n    \u003ch1\u003e기본 입력란 데모\u003c/h1\u003e\n    \u003cAppInput placeholder=\"이름을 입력해주세요\" /\u003e\n  \u003c/main\u003e\n\u003c/template\u003e\n```\n\n플레이스홀더에 fallthrough 속성을 사용 중임을 유의하세요. 이것은 컴포넌트의 루트 요소로 자동 전달됩니다.\n\n![이미지](/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png)\n\n\n\n## 검색 변형\n\n이제 더 둥근 UI를 가진 검색을 위해 다른 변형을 만들어보겠습니다. 이를 위해 pill이라는 프롭을 사용할 것입니다.\n\n```js\n\u003cscript lang=\"ts\" setup\u003e\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cinput\n    type=\"text\"\n    class=\"input\"\n    :class=\"{\n      pill,\n    }\"\n  /\u003e\n\u003c/template\u003e\n\n\u003cstyle lang=\"scss\" scoped\u003e\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: #f5f8fa;\n  border: 1px solid #cccccc;\n  padding: 8px 20px;\n  outline: 0;\n  border-radius: 8px;\n\n  \u0026.pill {\n    border-radius: 32px;\n  }\n}\n\u003c/style\u003e\n```\n\n```js\n\u003cAppInput pill placeholder=\"검색\" /\u003e\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| The only interesting thing is | `:class=\"'pill'\"` | It will apply the class pill if the prop variable with the same name is truthy. |\n|------------------------------|-------------------|--------------------------------------------------|\n| Remove Hardcoded CSS Values  | Before moving on let’s tackle the hardcoded values in our styles. As our application grows larger we should have our pallete, typography, and spacings declared in a centralized place for everyone to use. This can be done with CSS variables or SCSS variables. We will use SCSS this time. |\n\n\n\n다음 내용을 포함한 _variables.scss 파일을 만들어주세요.\n\n```scss\n$color-light: #f5f8fa;\n$color-border: #cccccc;\n\n@function spacing($factor: 1) {\n  @return $factor * 4px;\n}\n\n$border-radius-input: spacing(2);\n$border-radius-pill: spacing(8);\n```\n\n스페이싱 믹스인은 4픽셀 그리드를 강제하는 방법으로, 시각적 리듬을 가진 쾌적한 UI를 만드는 데 도움이 됩니다.\n\n이제 공통 변수를 사용하여 스타일을 업데이트할 수 있습니다.\n\n\n\n```js\n...\n\n\u003cstyle lang=\"scss\" scoped\u003e\n@import \"@/assets/styles/_variables.scss\";\n\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  \u0026.pill {\n    border-radius: $border-radius-pill;\n  }\n}\n\u003c/style\u003e\n```\n\n반면에 모든 컴포넌트에 import하는 것을 피하기 위해 vite.config.ts 파일을 다음과 같이 업데이트할 수도 있습니다:\n\n```js\nexport default defineConfig({\n  ...\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `\n          @import \"@/assets/styles/_variables.scss\";\n        `\n      }\n    }\n  }\n  ...\n})\n```\n\n## 레이블\n\n\n\n플레이스홀더를 레이블로 사용하는 것은 접근성이 떨어지고 전체적으로 사용자 경험이 좋지 않습니다. 이 문제를 해결하기 위해 플로팅 레이블을 구현해 봅시다. 이를 위해 우선 입력란을 래퍼로 감싸고 약간 정리해야 합니다.\n\n```js\n\u003cscript lang=\"ts\" setup\u003e\ndefineOptions({\n  inheritAttrs: false,\n});\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"input-wrapper\"\u003e\n    \u003cinput\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :class=\"{\n        'has-label': $slots.label,\n        pill,\n      }\"\n    /\u003e\n    \u003cdiv class=\"label\"\u003e\n      \u003cslot name=\"label\" /\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cstyle lang=\"scss\" scoped\u003e\n.input-wrapper {\n  position: relative;\n}\n\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  \u0026.pill {\n    border-radius: $border-radius-pill;\n  }\n  \u0026.has-label {\n    padding-top: spacing(6);\n    \u0026::placeholder {\n      color: transparent;\n    }\n  }\n}\n\n.label {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  padding: spacing(4) spacing(5);\n  pointer-events: none;\n  transform-origin: 0 0;\n  transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;\n}\n\n.input:focus ~ .label,\n.input:not(:placeholder-shown) ~ .label {\n  opacity: 0.65;\n  transform: scale(0.85) translateY(-0.5rem) translateX(0.15rem);\n}\n\u003c/style\u003e\r\n```\n\n이제 입력란이 더 이상 루트 요소가 아니기 때문에 inheritAttrs 옵션을 false로 설정하고 수동으로 $attrs를 바인딩해야 합니다.\n\n실제 레이블은 동일한 이름의 슬롯을 사용하여 전달됩니다. 이 레이블은 절대 위치에 있으며 상태 간에 전환에 사용되는 트랜지션을 가지고 있습니다.\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*l91i6d4b3MVHxv1QMUP5tA.gif\" /\u003e\n\n## 접두사 및 접미사\n\n입력란은 일반적으로 통화, 아이콘 또는 동작이 있는 다른 컴포넌트와 같은 추가 정보와 관련이 있습니다. 기본 컴포넌트는 슬롯을 사용하여 나타나기 전이나 나타난 후에 사용자 정의 콘텐츠를 지원해야 합니다.\n\n```js\n\u003cscript lang=\"ts\" setup\u003e\ndefineOptions({\n  inheritAttrs: false,\n});\ndefineProps({\n  pill: {\n    type: Boolean,\n  },\n});\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"input-wrapper\"\u003e\n    \u003cinput\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :class=\"{\n        'has-prefix': $slots.prefix,\n        'has-suffix': $slots.suffix,\n        'has-label': $slots.label,\n        pill,\n      }\"\n    /\u003e\n    \u003cdiv class=\"label\"\u003e\n      \u003cslot name=\"label\" /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"prefix\"\u003e\n      \u003cslot name=\"prefix\" /\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"suffix\"\u003e\n      \u003cslot name=\"suffix\" /\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cstyle lang=\"scss\" scoped\u003e\n.input-wrapper {\n  position: relative;\n  + .input-wrapper {\n    margin-top: spacing(4);\n  }\n}\n.input {\n  box-sizing: border-box;\n  width: 100%;\n  background: $color-light;\n  border: 1px solid $color-border;\n  padding: spacing(2) spacing(5);\n  outline: 0;\n  border-radius: $border-radius-input;\n  \u0026.pill {\n    border-radius: $border-radius-pill;\n  }\n  \u0026.has-prefix {\n    padding-left: spacing(12);\n  }\n  \u0026.has-suffix {\n    padding-right: spacing(12);\n  }\n  \u0026.has-label {\n    padding-top: spacing(6);\n    \u0026::placeholder {\n      color: transparent;\n    }\n  }\n}\n\n.label {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  padding: spacing(4) spacing(5);\n  pointer-events: none;\n  transform-origin: 0 0;\n  transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;\n}\n.input.has-prefix ~ .label {\n  left: spacing(7);\n}\n\n.input:focus ~ .label,\n.input:not(:placeholder-shown) ~ .label {\n  opacity: 0.65;\n  transform: scale(0.85) translateY(-0.5rem) translateX(0.15rem);\n}\n\n.prefix, .suffix {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.prefix {\n  left: spacing(4);\n}\n.suffix {\n  right: spacing(4);\n}\n\u003c/style\u003e\n```\n\n\n\n이것은 prefix와 suffix라는 두 가지 추가 슬롯이 있는 레이블과 동일한 기술을 사용합니다.\n\n## 변경 사항을 듣기\n\n반응하는 것이 빠진 유일한 부분입니다. V-모델은 바로 이를 위해 Vue에서 제공됩니다.\n\n우리의 데이터를 보유하는 반응형 객체인 userInfo가 있다고 가정해 봅시다. v-model=\"userInfo.name\"을 추가해야 합니다.\n\n\n\n```js\r\n\u003cscript setup lang=\"ts\"\u003e\r\nimport { reactive } from \"vue\";\r\n\r\nconst userInfo = reactive({\r\n  name: \"Fotis\",\r\n  ...\r\n});\r\n\u003c/script\u003e\r\n\r\n\u003ctemplate\u003e\r\n  \u003cmain\u003e\r\n    \u003ch1\u003eBase Input Demo\u003c/h1\u003e\r\n\r\n    \u003cAppInput v-model=\"userInfo.name\" placeholder=\"이름\"\u003e\r\n      \u003ctemplate #label\u003e 이름 \u003c/template\u003e\r\n    \u003c/AppInput\u003e\r\n  \u003c/main\u003e\r\n\u003c/template\u003e\r\n```\r\n\r\nv-model은\r\n\r\n```js\r\n :value=\"modelValue\"\r\n @input=\"emit('update:modelValue', $event.target.value)\"\r\n```\r\n\r\n의 단축 버전입니다.\r\n\r\n이를 반영하여 AppInput을 업데이트해보겠습니다.\n\n\n\n```js\r\n\u003cscript lang=\"ts\" setup\u003e\ndefineOptions({\n  inheritAttrs: false,\n});\n\ndefineProps({\n  modelValue: {\n    type: String\n  },\n  pill: {\n    type: Boolean,\n  },\n});\n\nconst emit = defineEmits(['update:modelValue'] )\nconst updateValue = (e: Event) =\u003e {\n  emit('update:modelValue', (e.target as HTMLInputElement).value)\n};\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"input-wrapper\"\u003e\n    \u003cinput\n      type=\"text\"\n      class=\"input\"\n      v-bind=\"$attrs\"\n      :value=\"modelValue\"\n      @input=\"updateValue\"\n      :class=\"{\n        'has-prefix': $slots.prefix,\n        'has-suffix': $slots.suffix,\n        'has-label': $slots.label,\n        pill,\n      }\"\n    /\u003e\n    ...\n  \u003c/div\u003e\n\u003c/template\u003e\r\n```\n\n위의 변경 사항은 다음과 같습니다:\n\n- modelValue prop을 추가했습니다.\n- update:modelValue 이벤트를 선언했습니다.\n- input 요소의 value와 input 속성에 둘 다 바인딩됐습니다.\n\n이제 input 값을 변경하면 반응성 있는 userInfo 객체에 반영될 것입니다.\n\n\n\n## 모든 것을 모아보기\n\n마지막으로, 간단한 폼을 만들어 입력 사용법을 보여드릴게요.\n\n```js\n\u003cscript setup lang=\"ts\"\u003e\nimport AppInput from \"@/components/AppInput.vue\";\nimport AppIcon from \"@/components/AppIcon.vue\";\nimport { reactive } from \"vue\";\n\nconst userInfo = reactive({\n  name: \"Fotis\",\n  bio:\n    \"Lorem ipsum dolor sit amet consectetur adipisicing elit. Expedita deleniti laboriosam eligendi. Incidunt dolores dicta veritatis. Quaerat ad, magnam esse, illo atque delectus minus, nihil adipisci tempora nobis iusto. Excepturi?\",\n  location: \"Barcelona\",\n  website: \"fadamakis.com\",\n});\n\nfunction submitForm() {\n  alert('Info submitted: ' + JSON.stringify(userInfo))\n}\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cmain\u003e\n    \u003ch1\u003eBase Input Demo\u003c/h1\u003e\n\n    \u003cAppInput v-model=\"userInfo.name\" placeholder=\"이름\"\u003e\n      \u003ctemplate #label\u003e 이름 \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n    \u003cAppInput v-model=\"userInfo.bio\" placeholder=\"소개\"\u003e\n      \u003ctemplate #label\u003e 소개 \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n    \u003cAppInput v-model=\"userInfo.location\" placeholder=\"위치\"\u003e\n      \u003ctemplate #label\u003e 위치 \u003c/template\u003e\n      \u003ctemplate #prefix\u003e\n        \u003cAppIcon icon=\"pin\" /\u003e\n      \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n    \u003cAppInput v-model=\"userInfo.website\" placeholder=\"웹사이트\"\u003e\n      \u003ctemplate #label\u003e 웹사이트 \u003c/template\u003e\n      \u003ctemplate #prefix\u003e\n        \u003cAppIcon icon=\"link\" /\u003e\n      \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n    \u003cbutton @click=\"submitForm\"\u003e\n      제출하기 \u003cAppIcon size=\"2x\" icon=\"arrow-right-circle\" /\u003e\n    \u003c/button\u003e\n\n    \u003chr /\u003e\n\n    \u003cAppInput pill name=\"search\" placeholder=\"검색\"\u003e\n      \u003ctemplate #prefix\u003e\n        \u003cAppIcon icon=\"search\" /\u003e\n      \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n    \u003cAppInput placeholder=\"메시지를 보내주세요...\"\u003e\n      \u003ctemplate #suffix\u003e\n        \u003cAppIcon size=\"2x\" icon=\"arrow-right-circle\" /\u003e\n      \u003c/template\u003e\n    \u003c/AppInput\u003e\n\n  \u003c/main\u003e\n\u003c/template\u003e\n```\n\n결과는 다음과 같습니다:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_1.png\" /\u003e\n\n실제로 테스트해보고 GitHub에서 소스 코드를 확인할 수 있어요.\n\n구현에 대한 피드백, 아이디어 또는 다른 의견이 있다면 매우 환영합니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_2.png\" /\u003e\n\n\n\nⓘ 이 글은 Base Component 구현 시리즈의 일부입니다:\n\n- AppInput.vue (여기 있습니다!)\n- AppModal.vue\n- AppIcon.vue\n\n추가로 하고 싶은 내용이 있으시면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png"},"coverImage":"/assets/img/2024-05-14-Vue3ImplementaBaseInputComponenttheRightWay_0.png","tag":["Tech"],"readingTime":11},{"title":"앵귤러의 조화 인젝터와 디렉티브의 힘","description":"","date":"2024-05-14 13:13","slug":"2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives","content":"\n\n앵귤러는 여러 해 동안 크게 발전해 왔어요. 불과 10년 만에 v2부터 v17로 왔지요! 이 기간 동안 앵귤러에 많은 변화가 있었지만, 핵심 개념과 철학은 동일하게 유지되었어요. 우리는 이 중요한 앵귤러 컴포넌트 두 가지를 사용하여 강력한 것을 만들어보려고 해요.\n\n## 샘플 애플리케이션\n\n예시로 파일 업로드 컴포넌트를 만들어볼 거예요. 이 컴포넌트는 사용자가 로컬 기기에서 파일을 애플리케이션으로 업로드할 수 있도록 하는 기능을 맡을 거에요. 업로드되는 파일의 최대 크기를 제한하고, 이를 사용자 정의할 수 있어야 해요. 이는 Input 데코레이터 패턴을 사용하여 쉽게 구현할 수 있어요.\n\n이 구현은 업로드된 파일 크기가 허용된 크기보다 큰지 확인하고, 그에 적절하게 경고를 보여줍니다.\n\n\n\n보시는 대로 파일 업로드 한도를 컴포넌트의 입력으로 가져오고 있습니다. 이 컴포넌트의 모든 소비자는 요구 사항에 따라 이를 입력으로 전달할 수 있습니다.\n\n이 방법은 작동하지만 조금 번거로울 수 있습니다. 컴포넌트를 사용할 때마다 파일 크기 제한을 전달해야 합니다. 실제로 이러한 제한은 대부분 응용 프로그램/라이브러리 또는 있는 모듈에 따라 달라집니다. 예를 들어, 모든 고객을 대상으로 하는 파일 업로드는 5MB로 제한되어야 하지만 모든 관리자 구성 요소는 최대 10MB까지 업로드할 수 있어야 합니다. 관리자 구성 요소는 원칙적으로 항상 10MB로 제한되어야 한다는 것을 알고 있지만, 관리자 페이지에서 컴포넌트를 사용할 때마다 이 데이터를 입력으로 전달해야합니다.\n\n## Injector 패턴\n\n여기서 Angular 인젝터가 유용하게 사용됩니다. Injector 패턴을 사용하여이 컴포넌트를 다시 작성해 봅시다.\n\n\n\n우리는 InjectionToken을 만들고 기본값으로 7MB를 제공했습니다. 그런 다음 새로운 inject 기능 덕분에 유틸 메서드를 사용하여 이 토큰을 컴포넌트에서 소비합니다.\n\n기본적으로 이 컴포넌트를 사용하는 모든 곳에서 업로드 제한으로 7MB가 설정될 것입니다.\n\n이전에 언급했듯이, 모든 관리자 컴포넌트는 10MB 제한이어야 합니다. 이제 단순히 관리자 모듈(또는 상위/라우트 수준 컴포넌트)로 이동할 수 있습니다.\n\n고객 모듈의 경우,\n\n\n\n요약하자면 우리는 Angular injectors를 사용하여 응용 프로그램에서 데이터 공급자를 효과적으로 사용자 정의했습니다. 이것은 더 결정론적이며 데이터가 더 높은 수준에서 제공되기 때문에 오류 발생 가능성이 줄어듭니다.\n\n하지만, 같은 구성 요소에서 앱 파일 업로드의 두 인스턴스를 각각 다른 파일 크기 제한을 가지고 싶다면 어떻게 해야 할까요? Angular에서 주입기 트리의 가장 낮은 수준은 컴포넌트 데코레이터이며 여기서 주입기를 제공할 수 있는 곳입니다. 템플릿 수준에서 주입기를 제공하는 것은 불가능합니다.\n\n## 디렉티브로 승리!\n\nAngular에서 디렉티브는 템플릿의 요소에 새로운 동작을 추가하거나 기존 동작을 수정할 수 있는 클래스입니다. 디렉티브는 템플릿이 없는 컴포넌트로 생각할 수 있습니다. 즉, 우리는 디렉티브에 여러 가지를 제공할 수 있고 디렉티브가 템플릿의 일부에 적용될 수 있기 때문에 템플릿 수준에서 데이터를 제공하는 데 사용할 수 있습니다!\n\n\n\n본문을 요약하면 템플릿에 데이터 제공자로서 지시문을 사용할 수 있다는 것을 알 수 있습니다. 이제 이를 사용하여 동일한 컴포넌트에 여러 인젝터를 제공하여 인젝터를 통해 동일한 컴포넌트에서 두 가지 다른 파일 크기를 가질 수 있습니다.\n\n우리는 각각 10MB와 2MB용 데이터 제공자로 두 개의 지시문을 생성할 것입니다.\n\n이제 간단히 컴포넌트에 이를 적용해 봅시다.\n\n## 결론\n\n\n\nAngular에서는 지시문을 데이터 제공자로 사용할 수 있어요. 지시문과 인젝터를 결합하여 모듈식이고 유연한 강력한 컴포넌트 디자인 패턴을 만들 수 있어요.\n\n샘플 애플리케이션은 여기에서 확인할 수 있어요 - https://github.com/BharathRavi27/angular-injector-decorator\n\nAngular에서 더 많은 디자인 패턴을 배우고 싶나요? 아래의 이전 기사를 확인해보세요!","ogImage":{"url":"/assets/img/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives_0.png"},"coverImage":"/assets/img/2024-05-14-HarmonizingAngularThePowerofInjectorsDirectives_0.png","tag":["Tech"],"readingTime":3},{"title":"누군가가 저에게 자가학습 프로그래머들이 부족한 점을 물어봤어요","description":"","date":"2024-05-14 13:11","slug":"2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack","content":"\n\n## 프로그래밍 의견\n\n![이미지](/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png)\n\n이 경우 서두르지 말 것이 좋습니다. 또한, 자습 중이라면 형식적인 교육을 받은 사람들의 가정에 대해서 당신 스스로 발목을 잡는 것입니다.\n\n저는 자습으로 배웠고, 거의 모든 사람들이 나보다 더 좋은 기술을 가지고 있다는 생각이 들지 않았습니다.\n\n\n\n두 명의 프로그래머 사이의 차이는 대학에서 공부했느냐 자기 학습을 했느냐와 같은 문제들보다는 그가 무엇을 배우기 위해 동기부여 받았는지, 무엇을 배웠는지, 실제로 얼마나 배웠는지, 그리고 어느 정도의 재능을 가지고 있는지가 훨씬 중요합니다.\n\n나는 IT 분야에서 학위를 받은 많은 사람들이 나 같이 많은 해가 지난 후 고등학교를 졸업한 이후 프로그래머로서의 자리를 잘 표현하지 못하는 것을 많이 보았습니다. 그리고 예, 자가 학습형 개발자로서 어떤 사람을 나눌 필요가 있다는 가정을 보면 좀 짜증나기도 합니다. \n\n나는 이런 이유 중 하나로 이 주제에 대해 이야기하고 싶었습니다. 자가 학습형 개발자가 교육을 받은 개발자만큼 좋은 프로그래머가 되기 위해 할 일은 무엇인지 물어봤던 적이 있었거든요. 음, 아주 많은 경우 그는 아무 것도 해야 할 필요가 없을 수도 있습니다. 그리고 뭔가를 해야 한다면, 그것은 자가 학습을 했기 때문이 아니라 특정한 단점 때문에이므로 그런 질문에 대한 일반적인 답은 없습니다.\n\n특히 정식 교육을 받은 사람들도 동일하거나 다른 단점을 가질 수 있습니다. 그렇습니다, 컴퓨터 공학 분야의 범위를 재검토하는 것이 좋을 수도 있습니다. 예를 들어, Warsaw 대학에서 제공하는 매우 포괄적인 자료는 자가 학습을 하는 학생들에게도 유용할 수 있습니다. 당신이 만나지 못한 학습에서 다루는 주제가 있는지 알아보는 것이 가치가 있습니다.\n\n\n\n자학하는 사람들도 많아서 그룹으로 다루는 것은 매우 불합리합니다. 제가 프로그래밍을 시작한 지 15년이 넘었습니다. 많은 사람들이 몇 달의 과정을 수료한 후에는 가장 재능 있는 사람이 아니면 작업 준비가 되기 힘듭니다. 동기부여도 서로 다릅니다.\n\n가치 있는 직원이 되고 싶다면 학생 자료를 검토하는 것보다 첫 직장을 얻고 무엇을 할 수 없는지 확인하는 것이 훨씬 더 유용할 것입니다. 배워야 할 것이 너무 많아서 아무 대학의 선택을 당연시하고 최고로 여기는 것은 적절하지 않습니다. 그러나 만족을 위해 학습하고 즐거움을 얻는다면, 놓친 것에 대해 궁금해해야 합니다.\n\n그에 반해, 대학 프로그램의 불합리성을 고려할 때, 이론적으로 프로그래머로 취업하거나 다른 직책에서 일을 시작하고 대학 대신 전문 분야에서 5년의 경험을 쌓을 수 있는 사람이 전반적으로 시장에서 훨씬 더 나은 역량을 갖게 될 것입니다. \n\n하지만 저의 경우처럼 이 경로나 저 경로를 따르는 것보다 그냥 자신이 좋아하는 일을 하는 것이 최선이라고 생각합니다. 자신만의 밀폐된 대학 환경을 갖고 있지만 종종 시장의 현실과 부합하지 않거나 아예 맞지 않고 객관적인 허튼 소리를 가르치는 사람들이 유용하다고 여기는 것에 집중하지 마세요. 하지만 대기업의 동적인 매니저들이 우리에게 기대하는 능력만 습득하지 말아야 합니다. 그렇게 하면 정말 지루할 것입니다.\n\n\n\n프로그래밍을 정말 좋아한다면 많은 것을 알고 많은 돈을 벌게 될 거예요. 누군가가 당신을 자학한 사람으로 레이블 붙이려고 해도, 댓글을 심지어 할 수 없으며, 단지 그에게 얼마나 많이 벌고 싶은지 말하고 그에게 결정하도록 하세요.\n\n제 인생에서 면접을 봤었고, 세 가지 종류의 기술 질문을 받은 적이 있어요:\n\n1. 이력서에 포함했던 주제에 관한 질문 – 아마도 저에게는 너무나 단순한 질문일 겁니다.\n2. 내가 관심 있는 주제에 관한 질문 – 잘 모르겠다고 해도, 항상 \"논리적으로 기반을 둔\" 정답을 추측하려 노력했어요.\n3. 누군가가 만들어낸 미친 질문 – 결코 사용되지 않는 것에 관한 질문이었고, 기적적으로 필요하다면 구글에서 확인됐어요.\n\n그리고 누군가가 위대한 기술을 갖고 있음에도 불구하고 인정받지 못할까봐 두렵다면, 앉아서 자신의 모든 역량을 나타내는 좋은 프로젝트를 작성해보는 걸 추천해요. 언어 사용 능력, 소프트웨어 엔지니어링 이해, 노출하고 싶은 관련 주제에 대한 지식, 즉 컴퓨터 아키텍처, 시스템, 네트워크, 그래픽 따위에 대한 지식 등을 보여주는 것이 중요합니다.\n\n\n\n하지만 프로그래밍을 배우는 사람이 프로젝트를 작성하는 것은 보편적인 일이라고 생각합니다. 저는 15년 전에 시작했지만 특별한 것을 보여줄 것이 없다고 생각해요. 그러나 제 경력이 막히고 해결해야 할 문제가 생긴다면, 5년 동안 공부하는 대신 3개월 만에 그런 일을 처리할 것 같아요.\n\n대학을 졸업한 사람들 중에서는 어떤 면에서는 제가 능가하지만, 제가 그들보다 나은 점도 있을 거예요. 하지만 제 학업을 완료한 사람들보다 제가 뛰어나다고 생각하는 사람이 더 많아요. 그러니 모든 사람이 자신이 원하는 방식으로 배우도록 하고, 그들의 실력을 직접 평가하도록 하죠.\n\n누군가에게 학업을 완료하라고 권유한 적이 없으니, 누군가는 나에게 그들을 향해 자신을 깎아내리라고 말하지 말아주세요. 왜냐하면 그 이유를 보지 못하기 때문이에요.\n\n# Stackademic 🎓\n\n\n\n고맙습니다. 끝까지 읽어주셔서!\n\n- 작가를 클로밍하고 팔로우해주시면 감사하겠습니다! 👏\n- 다음을 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해주세요: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인해주세요.","ogImage":{"url":"/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png"},"coverImage":"/assets/img/2024-05-14-SomeoneAskedMeWhatSelfTaughtProgrammersLack_0.png","tag":["Tech"],"readingTime":3},{"title":"JavaScript에서 Promise의 사용법과 이유","description":"","date":"2024-05-14 13:05","slug":"2024-05-14-TheHowandWhyofPromisesinJavaScript","content":"\n\n![Promises](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png)\n\n프로미스는 자바스크립트의 덤블도르라고 생각됩니다. JS에서 비동기적인 모든 것은 이 마법사에 의존합니다. 프로미스를 연구하는 두 종류의 사람이 있습니다. 첫째는 \"오케이, Resolve와 Reject를 매개변수로 받는 함수를 전달하여 프로미스 생성자에 전달하고 비동기 작업을 수행하면 끝이야. 응, 쉬워서 쉽네\" 하고 하는 사람들이고, 둘째는 프로미스의 작동에 관한 복잡한 질문이나 까다로운 질문을 생각해내는 사람들입니다. 이 영문은 정확히 그에 관한 것입니다. 프로미스 \"Under the Hood\".\n\n# 이 영문에서 다룰 내용은 다음과 같습니다:\n\n- 기본 프로미스 생성부터 시작하기.\n- 여러 프로미스를 연결하는 방법 (프로미스 체이닝).\n- .then()과 .catch()에서 반환하는 이유 (및 반환할 수 있는 모든 것).\n- then()/catch()/finally() 내부의 핸들러 메소드의 부재.\n- 동일한 프로미스 객체에 여러 핸들러 연결.\n- .then()의 동기적 성격과 핸들러 메소드의 비동기적 성격.\n- 처리되지 않은 프로미스의 [[Promise]] 슬롯의 연결.\n- .then()으로 isRejected() 핸들러 vs. .catch()으로 isRejected() 핸들러.\n- 몇 가지 tricky 코드 스니펫의 출력 예측.\n- 프로미스 작동 방식을 이해하기 위해 커스텀 프로미스 생성하기.\n\n\n\n노트-: 먼저 약속의 A-Z 작동 방식을 이해하는 데 도움이 되도록 익명 및 화살표 함수를 사용하지 않겠습니다. 그러나 이해도가 높아지면 코드에 이들을 도입할 것입니다.\n\n## 자바스크립트에서 Promise는 무엇인가요?\n\n![Promise](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_1.png)\n\n이걸 꺾어 말해야해서 죄송하지만, Promise들은 덤블도어가 아니에요. 그냥 Promise 클래스의 객체일 뿐이죠. Promise들은 일련의 콜백 함수에 엮이는 거죠. MDN에서 이를 다음과 같이 정의했습니다:\n\n\n\n조금 덜 무서운 비유적인 얘기로 말하자면, 엄마가 냄비에 우유를 담아 끓이기 위해 가스레인지에 놓고 급히 다른 일을 처리해야 할 때, 우유를 지켜보라고 너에게 부탁할 것이고 너는 필요한 양의 끓는 정도에 도달하면 버너를 끄거나 너무 끓어 넘치면 쏟아진 우유를 닦아내야 할 거야.\n\n이 비유에서 당신의 엄마는 JS 해석기인데, 이 해석기는 단일 스레드이며 동기화 방식이니 main 쓰레드가 블록되지 않도록 (비동기 작업은 실행에 시간이 걸릴 수 있으므로, JS 해석기의 유일한 쓰레드인 main 쓰레드는 그 작업에 의해 블록됩니다.) 대기 중인 작업들을 계속 실행해야 합니다. 우유 끓이기는 비동기 작업을 나타냅니다. 버너를 끄는 것은 비동기 작업의 성공적인 완료시 수행해야 할 동작을 나타내며, 쏟아진 우유를 닦아내는 것은 비동기 작업 실행 중에 실패를 만났을 때 수행해야 할 동작을 나타냅니다. 그리고 마지막으로 당신은 Promise 객체입니다.\n\n# 섹션 1: 기본 Promises\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_2.png)\n\n\n\n비유는 여기까지입니다. 자 이제 상황을 Promises를 사용하여 구현하는 코드를 작성해 보겠습니다-:\n\n```js\nfunction boilMilk(resolve, reject) {\n  let milkBoiled = Math.random();\n  if (milkBoiled \u003e= 0.5) resolve(\"우유가 성공적으로 끓었습니다\");\n  else reject(new Error(\"우유가 너무 끓어 넘쳤습니다\"));\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 그리고 버너가 꺼졌습니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 따라서 넘친 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nconst motherPromise = new Promise(boilMilk);\n\nmotherPromise\n  .then(isResolved)\n  .catch(isRejected);\n```\n\n쉽죠? 그렇지 않다면 코드를 부분별로 살펴보세요:\n\n- `new Promise(……)`는 Promise 클래스의 생성자 호출로 Promise 객체를 반환합니다. Promise 객체는 다음과 같습니다:\n\n\n\n\n![Promise States](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_3.png)\n\n여기서 [[PromiseState]]는 Promise 객체의 상태를 나타냅니다. Promise는 다음 중 하나의 상태를 가질 수 있습니다:\n\na. pending-: Promise 객체가 생성될 때의 초기 상태입니다. Promise 객체의 해결 또는 거부에 의해 변경될 것을 기다리고 있습니다.\n\nb. fulfilled-: Promise가 해결되었음을 나타내는 상태이거나 비동기 작업이 성공했음을 의미합니다.\n\n\n\n\nc. rejected-: 이것은 Promise의 상태로, Promise가 거부되었거나 비동기 작업이 실패했다는 것을 나타냅니다.\n\n[[PromiseResult]]은 비동기 작업에 의해 반환된 실제 데이터, 메시지 또는 오류가 저장된 위치입니다.\n\n2. 약속 생성자(boilMilk())에 전달된 함수는 Executor 함수로 알려져 있습니다. Executor 함수는 즉시 호출되는 콜백 함수로, 수행할 비동기 작업을 나타냅니다.\n\n3. resolve()와 reject()는 약속 클래스의 도우미 함수로, 약속 객체의 상태를 대기 중인 상태에서 이행된 상태로 변이시키거나 반대로 거부된 상태로 변이하는 책임이 있습니다.\n\n\n\n노트: Executor 함수의 인수로 흔히 볼 수 있는 resolve와 reject는 단순히 변수이기 때문에 아래 예시처럼 다른 이름을 지을 수 있습니다. 이들은 내부적으로 Promise 생성자에 의해 전달된 resolve()와 reject() 함수를 저장하는 데 사용됩니다. 섹션 10에서 사용자 정의 Promise를 만들 때 이를 실제로 보게 될 것입니다.\n\n```js\nfunction boilMilk(resolveMethod, rejectMethod) {\n  let milkBoiled = Math.random();\n  if (milkBoiled \u003e= 0.5)    \n    resolveMethod(\"우유가 성공적으로 끓었습니다\");\n  else \n    rejectMethod(new Error(\"우유가 과도하게 끓어 넘쳤습니다\"));\n}\n\nconst motherPromise = new Promise(boilMilk);\n```\n\n4. \"약속이 처리되었다\"라고 말할 때, 이는 Promise가 최종 상태(이행되었거나 거부된 상태)에 도달했다는 것을 의미합니다. 처리된 Promise는 비동기 작업을 완료하고 결과가 결정된 Promise입니다.\n\n5. .then(), .catch() 및 .finally()는 Promise 클래스에 정의된 함수들입니다. 이러한 메서드를 사용하면 Promise에 \"핸들러\"를 연결하고 Promise가 성공 또는 실패할 때 무엇을 해야 하는지 지정할 수 있습니다. 이러한 메서드는 JS 해석기에 의해 \"동기적으로\" 호출됩니다. 각각의 메서드는 반환될 때 \"보류 중\" 상태인 새로운 Promise를 반환하며, 현재 Promise의 상태에 관계없이 해당됩니다. 이러한 메서드 각각은 Handler 메서드(우리의 경우 isResolved() 및 isRejected())라고 불리는 콜백 함수를 허용합니다. 반환된 Promise의 최종 상태는 이러한 핸들러에 달려 있습니다. 위 세 가지 메서드의 구문은 다음과 같습니다:\n\n\n\na. then(onFulfillment, onRejected) -: 여기서 onRejected 핸들러는 선택 사항입니다.\n\nb. catch(onRejected) -: 위 체인에서 거부된 프로미스를 잡습니다.\n\nc. finally(onFinally) -: 현재 프로미스의 상태에 관계없이 항상 실행됩니다. 주로 프로미스가 해결된 후 처리하거나 정리하는 데 사용됩니다.\n\n6. onFulfillment(), onRejection() 및 onFinally()은 .then(), .catch() 및 .finally() 메서드에 전달되는 핸들러입니다. 현재 프로미스가 해결되면 onFulfillment() 핸들러가 \"비동기적으로\" 호출되고, 현재 프로미스가 거부되면 onRejection() 핸들러가 \"비동기적으로\" 호출되며, onFinally() 핸들러는 프로미스의 상태에 관계없이 항상 실행됩니다. 이러한 핸들러는 데이터, 오류 또는 새로운 프로미스를 반환할 수 있으며, 이를 .then() 및 .catch()로 계속 연결할 수 있습니다. 첫 번째 경우 .then()은 해당 데이터로 해결된 프로미스를 반환하고, 두 번째 경우 .then() 또는 .catch()는 오류가 포함된 거부된 프로미스를 반환합니다.\n\n\n\n만약 위의 이야기가 어려운 것 같다면, 실제로 무슨 일이 일어나는지 더 잘 이해하기 위해 우리 코드의 제어 흐름을 살펴보겠습니다:\n\n단계 1: JS Interpreter의 실행 단계에서, 먼저 새 Promise 인스턴스가 생성됩니다 (이 때 Promise의 상태는 \"대기 중\"입니다) 그리고 Executor 함수(boilMilk())가 Promise 생성자에 의해 즉시 호출됩니다.\n\n단계 2: Executor 함수는 무작위로 생성된 값에 따라 즉시 resolve() 또는 reject() 함수를 호출하며, 메시지나 에러와 함께 해당 함수를 호출합니다. resolve()/reject() 함수는 Promise 객체의 상태([[PromiseState]])를 변경하고 [[PromiseResult]]에 메시지나 에러를 할당합니다.\n\n참고: Promise 객체의 상태 변경은 resolve() 또는 reject()가 일정 지연 후에 호출될 때(비동기 실행을 모방하기 위해) 다음과 같이 확인할 수 있습니다:\n\n\n\n```js\nfunction boilMilk(resolve, reject) {\n  setTimeout(() =\u003e {\n    let milkBoiled = Math.random();\n    if (milkBoiled \u003e= 0.5)\n        resolve(\"우유 끓였어요\");\n    else\n        reject(new Error(\"우유가 넘쳐서 쏟았어요\"));\n  }, 2000);\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 후에 버너를 끕니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 이라서 쏟아진 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nvar motherPromise = new Promise(boilMilk);\nconsole.log(motherPromise);\n\nmotherPromise\n  .then(isResolved)\n  .catch(isRejected);\n\nsetTimeout(() =\u003e console.log(motherPromise), 3000);\n```\n\nboilMilk() 함수는 이제 setTimeout()을 사용하여 2초 후에 resolve() 또는 reject()를 호출하며, 첫 번째 console.log 문이 실행될 때 promise 객체의 상태가 \"대기 중\"이 됩니다. 이후 \"이행됨\"으로 변경됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_4.png\" /\u003e\n\n단계 3: 이제 .then() 도우미 메서드가 \"동기적으로\" 호출되며, 여기서 핸들러 콜백은 \"비동기적으로\" 호출됩니다. 이는 \"대기 중\" promise를 반환합니다.\n\n\n\n### 단계 4: 현재 Promise 객체의 상태가 \"이행(fulfilled)\" 상태가 된 것을 고려하면 isResolved() 핸들러가 호출됩니다. 이때 현재 Promise 객체의 [[PromiseResult]]를 인수로 전달받습니다.\n\n### 단계 5: isResolved() 핸들러는 .then()으로 반환된 Promise의 상태를 \"이행(fulfilled)\"으로 변경합니다. 그리고 shutBurner() 메소드가 아무 것도 반환하지 않기 때문에 새로 반환된 Promise의 [[PromiseResult]]에는 undefined가 들어갑니다. 아래에서 이를 설명했습니다:\n\n```js\nfunction boilMilk(resolve, reject) {\n  setTimeout(() =\u003e {\n    let milkBoiled = Math.random();\n    if (milkBoiled \u003e= 0.5) \n        resolve(\"우유가 성공적으로 끓었습니다\");\n    else \n        reject(new Error(\"우유가 너무 끓어 넘쳐버림\"));\n  },5000);\n}\n\nfunction shutBurner(resolveValue) {\n  console.log(`${resolveValue} 그리고 버너를 끕니다`);\n}\n\nfunction cleanSpilledMilk(rejectValue) {\n  console.log(`${rejectValue} 그래서 넘쳐난 우유를 청소합니다`);\n}\n\nfunction isResolved(resolveValue) {\n  return shutBurner(resolveValue);\n}\n\nfunction isRejected(rejectValue) {\n  return cleanSpilledMilk(rejectValue);\n}\n\nconst motherPromise = new Promise(boilMilk);\n\nconst thenPromise = motherPromise.then(isResolved).catch(()=\u003e{});\nconsole.log(thenPromise);\nsetTimeout(()=\u003econsole.log(thenPromise),6000);\n\nconst catchPromise = motherPromise.catch(isRejected);\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_5.png\" /\u003e\n\n참고: .then() 메소드에 .catch()를 첨부하는 이유는 나중에 섹션 7에서 설명될 예정입니다.\n\n단계 6: 해결된 프로미스는 .catch() 메소드가 첨부된 체인으로 전달됩니다. 그러나 isRejected() 핸들러는 호출되지 않으며, 마지막으로 .catch()는 \"보류 중\"인 프로미스를 반환하며, 이는 우리 코드에서 나중에 사용되지 않기 때문에 가비지 컬렉션됩니다.\n\n# 섹션 2: 프로미스 체이닝\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_6.png\" /\u003e\n\n이 섹션에 도달하여 축하합니다. 이제 \"기본 프로미스가 작동하는 방법\"에 대한 이해가 있습니다. 더 나아가서 여러 프로미스가 연속적으로 실행되거나 1개의 프로미스의 완료 또는 거부가 다른 프로미스를 처리하는 상황을 살펴봅시다.\n\n문제 설명:\n\n엄마로부터 (우유 끓이기)라는 작업을 할당 받은 후에, 작업을 성공적으로 수행하면 엄마가 오늘 저녁을 만들어야 하고 당신은 다른 작업을 수행할 수 있어야 한다고 말합니다. 그리고 저녁으로 페스토 스파게티를 먹기를 희망하고 있습니다. 보관함을 검사하고 파스타가 충분히 있다는 것을 발견하면, 파스타 요리는 성공적이지만, 1인분조차 충분하지 않는다면 실패합니다.\n\n\n\n위의 코드는 두 개의 Promise 기능을 사용하여 우유 끓이기와 스파게티 요리하기를 나타냅니다. 우유를 끓일 때는 `boilMilk` 함수를 사용하고, 스파게티를 요리할 때는 `cookSpaghetti` 함수를 사용합니다. 그리고 제대로 끓였을 때와 재료가 부족했을 때에 따라 다른 결과를 반환합니다. 코드를 실행하면서 발생하는 결과는 아래 이미지와 같습니다:\n\n![Possible outcomes](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_7.png)\n\n\n\n![표 이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_8.png)\n\n![표 이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_9.png)\n\n이렇게 간단했어요. 하나의 promise가 또 다른 promise로 이어지고, 두 promise 모두 작동 방식은 같아요.\n\n이제 Promise를 구현하는 방법을 알았으니, 위 코드에서 모든 함수 정의를 익명 함수와 화살표 함수로 바꾼 것을 보셔도 무서워하지 마세요.\n\n\n\n## Section 3: .then() 및 .catch()에서 반환하기\n\n```js\nconst motherPromise = new Promise((resolve, reject) =\u003e {\n  let milkBoiled = Math.random();\n  if (milkBoiled \u003e= 0.5) \n    resolve(\"우유가 성공적으로 끓었어요\");\n  else \n    reject(new Error(\"과도한 끓임으로 우유가 흘렀어요\"));\n})\n  .then((resolveValue) =\u003e {\n    console.log(`${resolveValue} 그리고 버너가 꺼졌어요`);\n    return new Promise((resolve, reject) =\u003e {\n      let spaghettiStock = Math.random();\n      if (spaghettiStock \u003e= 0.5)\n        resolve(\"스파게티가 성공적으로 요리되었어요\");\n      else \n        reject(new Error(\"충분한 파스타가 없어요\"));\n    })\n      .then((resolveValue) =\u003e console.log(`${resolveValue} 그리고 접시에 담겼어요`))\n      .catch((rejectValue) =\u003e console.log(`${rejectValue} 그래서 지루한 음식이 요리되고 접시에 담겼어요`));\n  })\n  .catch((rejectValue) =\u003e {\n    console.log(`${rejectValue} 그래서 흘린 우유를 청소하고`);\n    return \"마지막으로 바닥을 닦았어요\";\n  });\n```\n\n비슷하게, 우유가 흐르게 되었을 때 엄마가 수행해야 할 추가 작업에 대한것을 생각할 수 있고, 쓰레기 처리를 하고 원래 Promise의 catch() 메서드에서 그것을 반환할 수 있어요.\n\n\n\n![image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_10.png)\n\n3.1. .then() 및 .catch()에서 반환할 수 있는 모든 것은 무엇인가요?\n\n기술적으로 .then() 및 .catch()에서는 어떤 것이든 반환할 수 있습니다. 다만, 연쇄(chain)에서 위에서 전달된 값이 받아들이거나 catch해야 할 것이 있어야 합니다. 그렇지 않으면 Uncaught error 예외가 발생할 수도 있고, 로그에 예상치 못한 출력이 나올 수도 있습니다.\n\n예시 1:\n\n\n\n```js\nconst promise = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(num \u003e= 0.5? resolve(\"Promise resolved\") : reject(\"Promise rejected\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(resolveValue);\n})\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n위의 코드는 명확하게 \"Promise Resolved\" 또는 \"Promise Rejected\" 둘 중 하나의 결과를 얻을 수 있습니다. 내부적으로 then()은 [[PromiseResult]]가 undefined인 처리된 Promise를 반환합니다. 이는 catch()로 처리할 필요 없이 코드가 종료됩니다. 그렇다면 체인에 다른 then()이 있는 경우 어떻게 될까요? 확인해 봅시다:\n\n예시 2:\n\n```js\nconst promise = new Promise((resolve,reject) =\u003e setTimeout(() =\u003e resolve(\"Promise resolved\"),2000))\n.then(function (resolveValue) {\n    console.log(resolveValue);\n})\n.then((resolveValue) =\u003e {\n    console.log(resolveValue);\n})\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_11.png)\n\n여기서 왜 undefined를 얻었을까요? 이건 초기 프로미스가 해결되었을 때 then()의 onFulfillment() 핸들러가 실행됐기 때문입니다. 그리고 핸들러가 아무것도 반환하지 않았기 때문에 then()으로 반환된 프로미스의 [[PromiseResult]]가 undefined로 저장됐다는 것입니다.\n\n이 문제는 원래 프로미스로부터 전달된 해결된 값이 없는 경우 반환문이 없어서 연쇄에서 아래에서 사용할 수 없게 되는 것입니다. 이를 수정해봅시다:\n\n예제 3:\n\n\n\n```js\nconst promise = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(() =\u003e resolve(\"Promise resolved\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`First then: ${resolveValue}`);\n    return resolveValue;\n})\n.then((resolveValue) =\u003e console.log(`Second then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(rejectValue);\n});\n```\n\n![Example](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_12.png)\n\n와 그럼, 예시 4:\n\n\n\n```js\n//Code 1:\nconst promise = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(() =\u003e resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    throw new Error(\"버려진 오류\");\n})\n.then((resolveValue) =\u003e console.log(`두 번째 then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\n/*\n출력:\n첫 번째 then: 약속 지켜짐\ncatch 안: Error: 버려진 오류\n*/\n\n//Code 2:\nconst promise1 = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(() =\u003e resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    return new Error(\"버려진 오류\");\n})\n.then((resolveValue) =\u003e console.log(`두 번째 then: ${resolveValue}`))\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\n/*\n출력:\n첫 번째 then: 약속 지켜짐\n두 번째 then: Error: 버려진 오류\n*/\n```\n\n이건 중요한 사례야. 코드 1에서, then() 내부의 Handler 함수가 오류를 \"throw\" 했어. 이는 핸들러 메서드에서 무언가가 실패했기 때문에 then()에서 반환된 프로미스가 오류로 거부된 것을 의미해. 그러나 코드 2에서는 아무 문제가 없어. 핸들러 메서드에서 새 Error 객체가 반환되었을 뿐이라서 then()에서 반환된 프로미스가 이행되고 이제 그 [[PromiseResult]]에는 Error 객체가 포함돼.\n\n\n\n[마지막] 예시 5:\n\n```js\nvar v;\nconst promise = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(() =\u003e resolve(\"약속 지켜짐\"),2000);\n})\n.then(function (resolveValue) {\n    console.log(`첫 번째 then: ${resolveValue}`);\n    v = new Promise((resolve, reject) =\u003e resolve(\"하위 프로미스 지켜짐\"));\n    return v;\n})\n.catch(function(rejectValue) {\n    console.log(`catch 안: ${rejectValue}`);\n});\nsetTimeout(() =\u003e console.log(v), 2000);\n\n/*\n출력:\n첫 번째 then: 약속 지켜짐\nPromise {\u003cfulfilled\u003e: '하위 프로미스 지켜짐'}\n[[Prototype]]: Promise\n[[PromiseState]]: \"fulfilled\"\n[[PromiseResult]]: \"하위 프로미스 지켜짐\"\n*/\n```\n\n\n\n이 경우에는 하위 프로미스가 해결되지만 호출할 핸들러가 없기 때문에 프로그램이 종료됩니다. (좋은 방식이 아닙니다).\n\n# 섹션 4: then()/catch()/finally()에 핸들러 메서드가 없는 경우\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_13.png)\n\n지금까지 우리는 모든 then() 또는 catch()에 핸들러 메서드(onRejection()/onFulfillmemnt())가 인자로 전달된 (보통) 경우를 살펴보았습니다. then() 또는 catch() 내부에 핸들러 메서드를 전달하지 않는다면 어떻게 될까요? 문법 오류가 발생할까요?\n\n\n\n실제로는 아니에요. 이는 약속(Promises)이 내부적으로 구현된 방식으로 잘 처리됩니다. onFulfillment() 핸들러가 then()에 전달되지 않을 경우, 내부적으로 Identity 함수 ( (x) =\u003e x )로 대체되어 그냥 완료 값을 체인으로 전달합니다. 마찬가지로, onRejection() 핸들러가 then()에 전달되지 않으면 내부적으로 Thrower 함수 ( (x) =\u003e throw x )로 대체되어 받은 거부 값을 throw합니다. 예시 -:\n\n```js\nconst promise = new Promise((resolve, reject) =\u003e reject(\"거부됨!\"));\npromise.catch();\n```\n\n그 결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_14.png\" /\u003e\n\n\n\n내부적으로는 다음과 같이 보입니다:\n\n```js\n/*\n  내부적으로는 다음과 같이 대체됩니다:\n\n  promise.catch((reason) =\u003e throw reason);\n*/\n\n/*\n  실제 onRejected 함수를 전달하는 경우:\n  \n  promise.catch(reason =\u003e console.log(reason));\n*/\n```\n\n로그에서 \"Uncaught Rejected Promise\"가 표시되는 이유는 새로 대체된 핸들러가 \"return\"이 아닌 \"throw\" 키워드를 사용하기 때문입니다.\n\nthen()의 경우:\n\n\n\n```js\nconst promise = new Promise((resolve, reject) =\u003e resolve(\"Resolved!\"));\npromise.then();\n\n/*\n  내부적으로 다음과 같이 변경됩니다:\n\n  promise.then((value) =\u003e value);\n*/\n```\n\n위의 코드는 로그에 아무 내용도 출력하지 않기 때문에 거기에 무언가를 보고 싶다면 다음과 같이 해야합니다:\n\n```js\nconst promise = new Promise((resolve, reject) =\u003e resolve(\"Resolved!\"));\npromise.then()\n  .then((value) =\u003e console.log(value)); //logs \"Resolved!\"\n```\n\n# 섹션 5: 동일한 Promise 객체에 여러 핸들러를 첨부하기\n\n\n\nmd\n![](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_15.png)\n\n동일한 Promise 객체에 여러 핸들러를 연결하고 싶은 이유를 묻는다면? 동일한 비동기 작업의 결과에 여러 부분이 의존할 때 이 작업이 수행됩니다.\n\n예를 들어, 우유를 성공적으로 끓일 수 있다면, 불을 끄고 부엌을 닫아야 할 것입니다. 이 경우 코드는 다음과 같이 보일 것입니다-:\n\n```js\nfunction turnOffLights(resolveValue) {\n  console.log(`${resolveValue} 불 끄기`);\n}\n\nfunction closeTheKitchen() {\n  console.log(\"부엌 문 닫기.\");\n}\n\nconst motherPromise = new Promise((resolve, reject) =\u003e {\n  let milkBoiled = Math.random();\n  if (milkBoiled \u003e= 0.5)\n    resolve(\"우유가 성공적으로 끓었고 버너가 꺼졌습니다. 이제\");\n  else \n    reject(new Error(\"우유가 너무 끓어서\"));\n});\n\nmotherPromise.then(turnOffLights)\n    .catch(() =\u003e {});\nmotherPromise.then(closeTheKitchen)\n    .catch(() =\u003e {});\nmotherPromise.catch((resolveValue) =\u003e\n  console.log(`${resolveValue} 따라서 엎어진 우유를 씁니다`)\n);\n\n/*\n가능한 결과 1:\n\n우유가 성공적으로 끓었고 버너가 꺼졌습니다. 이제 불 끄기\n부엌 문 닫기.\n\n가능한 결과 2:\n\nError: 우유가 너무 끓어서 따라서 엎어진 우유를 씁니다\n*/\n```\n\n\n\n\n참고: 각 then() 뒤에 catch()를 붙이는 것은 필수입니다. 그렇지 않으면 Uncaught Rejected Promise 예외가 발생합니다. 이에 대한 이유는 나중에 섹션 7에서 설명하겠습니다.\n\n위 코드의 작동 방식은 해결된 motherPromise가 then()의 모든 onFulfillment() 핸들러를 트리거하는 것입니다. 그리고 모든 핸들러는 정의된 순서대로 실행됩니다.\n\n이 작업은 Promise 체이닝을 사용하여 수행할 수 있다고 말할 수 있지만, 필요한 추가(중첩된) 프로미스를 만들어야 할 필요가 있는지 생각해보겠습니다. 또한, 수행해야 할 후속 작업이 동기적일 수도 있으므로 프로미스가 필요하지 않을 수도 있습니다.\n\n# 섹션 6: .then()의 동기적 성격 및 핸들러 메서드의 비동기적 성격.\n\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_16.png)\n\nPromises로 시작한 사람들이 가장 헷갈리는 것 중 하나에요. 일반적인 오해는 then()/catch()/finally()이 비동기적으로 실행된다는 것, 즉 프로미스가 해결되거나 거부될 때만 실행된다는 것입니다. 하지만 실제로는 그렇지 않아요. 실제로 이들은 현재 프로미스가 해결되거나 거부될 때까지 기다리지 않고 JS 해석기에 의해 동기적으로 실행됩니다. 그 결과 then()/catch()/finally() 메소드는 \"pending\" 상태의 프로미스를 반환하게 됩니다. 참고: 이 상태는 후속 핸들러 메소드의 반환 값에 따라 나중에 변경될 수 있어요. 실제로는 핸들러 메소드(onFulfillment(), onRejection() 및 onFinally())가 비동기적으로 실행되며, then()/catch()/finally() 메소드에 의해 현재 프로미스 인스턴스의 상태에 따라 실행될 예정입니다. 아래에서 확인할 수 있어요:\n\n```js\nfunction boilMilk(resolve, reject) {\n    setTimeout(() =\u003e {\n      let milkBoiled = Math.random();\n      if (milkBoiled \u003e= 0.5) \n          resolve(\"우유가 성공적으로 끓었어요\");\n      else \n          reject(new Error(\"우유가 너무 끓어 넘쳤어요\"));\n    },1000);\n  }\n  \n  function shutBurner(resolveValue) {\n    console.log(`${resolveValue}을(를) 끓인 후 버너를 끄세요`);\n  }\n  \n  function cleanSpilledMilk(rejectValue) {\n    console.log(`${rejectValue} 때문에 넘쳐 흐른 우유를 청소하세요`);\n  }\n  \n  function isResolved(resolveValue) {\n    return shutBurner(resolveValue);\n  }\n  \n  function isRejected(rejectValue) {\n    return cleanSpilledMilk(rejectValue);\n  }\n  \n  const motherPromise = new Promise(boilMilk);\n  \n  const thenPromise = motherPromise.then(isResolved).catch(()=\u003e console.log(\"예외 발생\"));\n  console.log(thenPromise);\n  setTimeout(()=\u003econsole.log(thenPromise),2000);\n  \n  const catchPromise = motherPromise.catch(isRejected);\n```\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_17.png)\n\n\n\n\n위 코드에서는 .then()이 동기적으로 실행되었다는 것이 명확합니다 (그래서 로그가 \"보류 중\" Promise를 보여줍니다) 하지만 나중에 onFulfillment() 핸들러가 실행된 후에는 동일한 Promise의 상태가 \"이행\"으로 변경됩니다. 이러한 기능의 이유는 핸들러 간의 경합 상태를 피하기 위해서입니다: .then()이 비동기적이면 (여러 then() 메소드의 경우) 어떤 핸들러가 먼저 예약되는지에 따라 예측할 수없는 결과로 이어질 수 있습니다.\n\n참고: 위 코드에서 .then() 메소드에 .catch()를 첨부하는 이유는 다음 섹션에서 설명될 것입니다.\n\n# 섹션 7: 미처리된 Promise의 [[Promise]] 슬롯의 연결\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_18.png\" /\u003e\n\n\n\n지금까지 우리는 부모 프로미스에 직접 .then()과 .catch()이 추가된 시나리오를 보았습니다. 이 경우에는 위에 .then()에 .catch()를 연결해야 했습니다. 그러나 이를 하지 않았을 때 무슨 일이 발생하는지 살펴보지는 않았습니다:\n\n```js\nconst p0 = new Promise((resolve,reject) =\u003e {\n    let num = Math.random();\n    setTimeout(()=\u003ereject(\"Promise rejected\"), 5000);\n});\n\nconst p1 = p0.then(function (resolveValue) {\n    console.log(\"Then 핸들러가 실행되었습니다\");\n    console.log(resolveValue);\n})\nconsole.log(\"P1\");\nconsole.log(p1);\n\nconst p2 = p0.catch((rejectValue) =\u003e {\n    console.log(\"Catch 핸들러가 실행되었습니다\");\n    console.log(rejectValue);\n})\nconsole.log(\"P2\");\nconsole.log(p2);\nsetTimeout(()=\u003e {\n    console.log(\"P1\");\n    console.log(p1);\n}, 10000);\nsetTimeout(()=\u003e {\n    console.log(\"P2\");\n    console.log(p2);\n}, 15000);\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_19.png\" /\u003e\n\n이 일이 왜 발생했을까요? \"거부된\" 프로미스가 이미 catch()의 onRejection() 핸들러에 의해 처리되었다면 콘솔에 추가로 Uncaught Rejected Promise가 나타나는 이유는 무엇일까요? onRejection() 핸들러를 then() 메서드에 전달하지 않았을 때 P1의 상태가 \"보류 중\"에서 \"거부됨\"으로 변경된 이유는 무엇일까요?\n\n\n\n이유를 이야기하자면 정말 간단한 것이 아니며 많은 사람들이 잘 알지 못하는 내용입니다. 이 문제에 대해 알아내기 위해 3~4일 동안 삽질한 기억이 납니다.\n\n여기 그 이유가 있습니다: 각 Promise 객체(예: P1)에는 [[Promise]] 슬롯이 있습니다. 이 슬롯은 P1이 속한 Promise 객체를 가리키거나 발생시킨 부모 Promise 객체를 가리킵니다. 따라서 위 코드에서 P1이 생성될 때 상태가 \"대기 중(pending)\"인 이유는 onFulfillment() 핸들러가 비동기적으로 실행되기 때문입니다. 그리고 나중에 P0가 \"거부(rejected)\"되면 catch()에 예약된 onRejection() 핸들러가 실행되어 메시지를 기록하고 마지막으로 P2가 undefined로 \"이행(fulfilled)\"됩니다. 그러나 만약 코드가 여기서 끝났다면, P1은 영원히 \"대기 중(pending)\" 상태로 남아 있었을 것입니다. 그러나 P1의 [[Promise]] 슬롯이 P0를 가리키므로, P0가 \"거부(rejected)\"된 즉시 P1은 P0의 상태와 결과를 취하게 됩니다. 여기서 주목할 점은 이 현상이 매번 모든 상황에서 발생한다는 점입니다. 우리가 이 현상을 보지 못하는 이유는 그때 then()에 전달된 핸들러 메서드가 실행될 때, then() 메서드에 의해 반환된 Promise의 상태와 결과가 핸들러 메서드의 반환 값의 유형에 따라 결정되기 때문입니다. 따라서, 흐름은 다음과 같습니다:\n\na. P0의 이행/거부\n\nb. P1은 P0의 상태와 결과를 취합니다\n\n\n\nc. P1의 상태와 결과가 다시 변경되었습니다. 이번에는 Handler 메서드의 반환 값 유형에 의해 변경되었습니다.\n\n참고: 이것은 Promise가 영원히 대기 상태에 있을 수 없다는 것을 의미하는 것은 아닙니다. 루트 또는 첫 번째 Promise 인스턴스는 resolve() 또는 reject()가 호출되지 않는 한 \"대기 중\" 상태로 남을 수 있습니다.\n\n# 섹션 8: .then() 대비 .catch()를 사용한 isRejected() 핸들러.\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_20.png)\n\n\n\n지금까지 우리의 코드에서는 then()과 함께 onFulfillment() 핸들러만 사용해 왔지만 섹션 1에서 보았듯이 then() 메서드의 구문은 다음과 같습니다: then(onFulfillment, onRejected) 여기서 onRejection()은 선택 사항입니다. 그래서 then() 내부에서 거부된 promise를 처리하는 것과 catch() 내부에서 처리하는 것의 차이는 무엇일까요? 다음 코드를 살펴봅시다:\n\n```js\n//코드 1:\nPromise.reject('거절된:')\n  .then(() =\u003e console.log(\"만세!!\"), (rejectValue) =\u003e console.log(`${rejectValue} 부우!!`));\n\n//코드 2:\nPromise.reject('거절된:')\n  .then(() =\u003e console.log(\"만세!!\"))\n  .catch((rejectValue) =\u003e console.log(`${rejectValue} 부우!!`));\n```\n\n위 예제의 두 코드는 모두 \"거절된: 부우!!\"를 로그로 출력합니다. 그러나 내부적으로 두 코드는 매우 다르게 실행됩니다. 코드 1에서 onRejected() 핸들러는 직접 부모 promise 객체에 작용하지만 코드 2에서 onRejected() 핸들러는 실제로 .then()이 반환하는 promise에 작용합니다(이 promise은 부모 promise의 상태와 결과를 획득합니다). 두 가지 방법의 다른 점은 부모 promise가 해결되고 then()이 거부된 promise를 반환하는 경우 코드 1에서는 아무도 처리하지 않고 Uncaught Rejected Promise 예외가 발생한다는 것입니다. 아래 예제를 참조하세요:\n\n```js\n//코드 1:\nPromise.resolve('해결됨:')\n  .then(() =\u003e Promise.reject(\"거절된 자식 Promise\"), (rejectValue) =\u003e console.log(`${rejectValue} 부우!!`));\n\n//코드 2:\nPromise.resolve('해결됨:')\n  .then(() =\u003e Promise.reject(\"거절된 자식 Promise\"))\n  .catch((rejectValue) =\u003e console.log(`${rejectValue} 부우!!`));\n```\n\n\n\n\n![이미지1](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_21.png)\n\n![이미지2](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_22.png)\n\n이렇게 하는 이유는 코드 2에서 반환된 거부된 하위 프로미스가 연쇄적으로 처리기인 onRejection() 핸들러에 의해 처리되지만, 코드 1에서는 그렇지 않기 때문입니다.\n\n# 섹션 9: 몇 가지 까다로운 코드 스니펫의 출력 예측\n\n\n\n\n\n![이미지](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_23.png)\n\n이 섹션의 제목은 이 기사의 첫 번째 섹션이었다면 더 적절했을 것 같습니다. 지금까지 프로미스에 대해 충분히 익숙할 텐데 말이죠. 하지만 여전히 살펴봐야 할 복잡한 경우들이 있을 수 있다고 생각합니다. 그래서 이제 시작해 볼게요-:\n\n문제 1:\n\n```js\n(() =\u003e {\n    return (new Promise((resolve, reject) =\u003e {\n        resolve();\n        console.log(\"일요일 -\u003e \");\n    }).then(() =\u003e console.log(\"화요일\")));\n})();\n\n(()=\u003econsole.log(\"월요일-\u003e \"))();\n```\n\n\n\n\n이 코드 조각의 출력물은 무엇이 될 것이라고 생각하시나요? 아래 내용을 읽기 전에 먼저 출력물에 대해 생각해보세요.\n\n많은 사람들이 resolve() 메서드가 \"보류 중\" 프로미스의 상태를 \"이행됨\"으로 변경하고(그 외 다른 일들도 수반되며) onFulfillment() 콜백 핸들러를 호출한다고 생각합니다. 하지만 이것은 사실이 아닙니다. resolve() 메서드는 어떤 핸들러에도 호출을 하지 않습니다. JS Interpreter는 Executor 함수를 완전히 실행하고, 그 후에 Promise 생성자가 프로미스의 새 상태에 따라 각 예약된 콜백 핸들러(단일 \"핸들러\"가 아니라 여러 개의 핸들러가 등록될 수 있으므로)에 대한 호출을 수행합니다. 따라서 위 코드의 출력물은 \"Sunday - Monday - Tuesday\"이 될 것입니다.\n\n문제 2:\n\n```js\nvar letsResolveThisOutside, letsRejectThisOutside;\n\nnew Promise((resolve, reject) =\u003e { \n    letsResolveThisOutside = resolve; \n    letsRejectThisOutside = reject; \n})\n.then((resolveValue) =\u003e console.log(`${resolveValue}`));\n\nletsResolveThisOutside(\"나 죽었나?\");\n```\n\n\n\n위의 Promise가 질문을 한 콘솔을 볼 수 있을 거라고 생각하십니까? 생각해보신 후에 계속 읽어주세요.\n\n기술적으로 말하면, Executor의 범위 외에서 Promise를 해결/거부하는 것이 가능할까요? 네, 가능합니다. 로그가 그것을 말해주고 있습니다.\n\nMarkdown 형식의 표입니다:\n\n\n| Syntax | Description |\n| ----------- | ----------- |\n| Header | Title |\n| Paragraph | Text |\n\n\n이것은 두 가지 이유 때문입니다. 첫 번째로, \"var\" 변수가 전역 공간에 정의되어 있고 Executor 함수 내부가 아닌 곳에 있기 때문에 코드 어디에서든 접근이 가능합니다 (심지어 Promise 클래스 내부에서도). 두 번째로, JS가 동기적 언어이므로 onFulfillment() 핸들러가 이미 실행이 예약되어 있었기 때문에, 우리가 마지막으로 letsResolveThisOutside() 메서드를 호출했을 때 Promise가 해결되고 Callback 핸들러가 호출되었습니다.\n\n\n\n문제 3:\n\n다음 이미지에 나와 있는 과제에 대한 솔루션을 보여 드리겠습니다. 그리고 해당 코드 조각의 출력물이 무엇인지 알아내셔야 합니다. 출력물이 예상치 못한 것으로 나타난다면 코드를 크게 변경하지 않고도 예상된 출력물을 얻는 방법을 찾아내셔야 합니다. 과제:\n\n![task image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_25.png)\n\n먼저, 위 과제를 직접 구현해보시거나 아래 솔루션을 읽고 후속 질문에 답해보시기 바랍니다...\n\n\n\n해결책:\n\n```js\nconst cleanRoom = (resolve, reject) =\u003e {\n    let num = Math.random();\n    if (num \u003e= .5) { \n      resolve(num); //방 청소 완료\n    } else {\n      reject(new Error(num)); //방 청소 미완료\n    }\n  }\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) { // then1\n  console.log(`방이 청소되어 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number \u003e= .5) { //콘서트 가기\n      resolve(number);\n    } else {\n      reject(number); //강아지 케어\n    }\n  }) \n}).then(function goConcertAfterGoal(resolveValue) { // then2\n  console.log(`방이 청소되어 축구를 하고 골을 넣었습니다!! 이제 음악 콘서트로 갑니다 -: ${resolveValue}`);\n}).catch(function cleanDogAfterlosing(errorValue) { // catch1\n  console.log(`방이 청소되어 축구를 하러 갔지만 골을 못 넣어서 강아지 케어 -: ${errorValue}`);\n})\n  \nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) { // catch2\n  console.log(`방이 청소되지 않아 세탁을 하러 갑니다 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 \u003e= .5) { //콘서트 가기\n      resolve(number_2);\n    } else {\n      reject(number_2); //강아지 케어\n    }\n  })\n}).then(function goConcertAfterLaundry(resolveValue) { // then3\n  console.log(`방이 청소되지 않아 세탁을 했지만 완료하지 못했어요. 그래서 강아지 케어 -: ${resolveValue}`);\n}).catch(function cleanDogAfterNoLaundry(errorValue){ //catch3\n  console.log(`방이 청소되지 않아 세탁을 하러 갔지만 완료하지 못해 강아지를 케어합니다 -: ${errorValue}`)\n}); \n```\n\n이제 위 코드에서 방이 청소되지 않고 세탁도 완료되지 않는 경우의 출력 결과를 찾아보세요. 그럼 아래 코드 로그를 확인해서 답을 확인하실 수 있습니다:\n\n```js\n방이 청소되지 않아 세탁을 하러 갑니다 -: Error: 0.10282616920143206\n방이 청소되어 축구를 하러 갔지만 골을 못 넣어서 강아지 케어 -: Error: 0.10282616920143206\n방이 청소되지 않아 세탁을 하러 갔지만 완료하지 못해 강아지를 케어합니다 -: 0.3140749736813231\n```\n\n\n\n이것은 좀 까다로울 거에요. 콘솔에서 위 출력물을 보고 있을 때 머리를 맞은 적이 있어요. 방이 깨끗한데 왜 두 번째 줄에 \"방이 청소되지 않았다...\"라고 나왔을까요?\n\n제가 이게 작은 실수라고 말하면 돌을 던지지 마세요. 자세히 살펴보면 이 코드가 혼란스럽고 오류가 있습니다. 바로 then2가 then1에 연결돼 있고 goFootballAfterCleaning() 핸들러가 반환한 프로미스에 연결되지 않았다는 거죠. 비슷하게 catch2도 catch1에 연결돼 있고 goLaundryAfterNoCleaning() 핸들러가 반환한 프로미스에 연결돼 있지 않다는 문제가 있어요. 그러니 이러한 오류를 수정해볼게요:\n\n```js\nconst cleanRoom = (resolve, reject) =\u003e {\n  let num = Math.random();\n  if (num \u003e= 0.5)\n    resolve(num); // 방이 깨끗함\n  else\n    reject(new Error(num)); // 방이 청소되지 않음\n};\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) {// then1\n  console.log(`방이 깨끗해요. 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number \u003e= 0.5)\n      resolve(number); // 콘서트에 감\n    else\n      reject(number); // 강아지를 씻겨야 해요\n  })\n    .then(function goConcertAfterGoal(resolveValue) {// then2\n      console.log(`방이 깨끗해요. 축구를 한 다음 골을 넣었어요!! 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);})\n    .catch(function cleanDogAfterlosing(errorValue) {// catch1\n      console.log( `방이 깨끗해요. 축구를 했지만 골을 넣지 못해서 강아지를 씻겨야 합니다 -: ${errorValue}`);\n    });\n});\n\nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) {// catch2\n  console.log(`방이 청소되지 않았어요. 세탁하러 가요 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 \u003e= 0.5) // 콘서트에 가요\n      resolve(number_2);\n    else\n      reject(number_2); // 강아지를 씻겨야 해요\n  })\n    .then(function goConcertAfterLaundry(resolveValue) {// then3\n      console.log(`방이 청소되지 않았어요. 세탁을 하러 간 후 완료했으니 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);\n    })\n    .catch(function cleanDogAfterNoLaundry(errorValue) {//catch3\n      console.log(`방이 청소되지 않았어요. 세탁을 하러 갔지만 완료하지 못해서 강아지를 씻겨야 합니다 -: ${errorValue}`);\n    });\n});\n```\n\n이렇게 돌린다면 잘 될 거 같죠? 글쎄요, 잘 되지 않았어요. 가능한 결과 중 하나는 다음과 같았습니다:\n\n\n\n\n![Image](/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_26.png)\n\n로그에 추가로 Uncaught Rejected Promise 오류가 표시되고 이미 섹션 7에서 왜 이러한 오류가 발생하는지, 이 문제에 대한 해결책을 이미 알고 있습니다. 이 문제를 빠르게 해결해 봅시다:\n\n```js\nconst cleanRoom = (resolve, reject) =\u003e {\n  let num = Math.random();\n  if (num \u003e= 0.5)\n    resolve(num); // 방청소 완료\n  else\n    reject(new Error(num)); // 방청소 실패\n};\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise.then(function goFootballAfterCleaning(resolveValue) {// then1\n  console.log(`방을 청소했으니 축구를 하러 갑니다 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number \u003e= 0.5)\n      resolve(number); // 콘서트로 가기\n    else\n      reject(number); // 강아지 돌보기\n  })\n    .then(function goConcertAfterGoal(resolveValue) {// then2\n      console.log(`방을 청소했으니 축구를 하러 갔고 골을 넣었어요!! 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);})\n    .catch(function cleanDogAfterlosing(errorValue) {// catch1\n      console.log( `방을 청소했으니 축구를 하러 갔지만 골을 못 넣어서 강아지를 돌봅니다 -: ${errorValue}`);\n    });\n})\n.catch(()=\u003e{});\n\nroomCleaningPromise.catch(function goLaundryAfterNoCleaning(errorValue) {// catch2\n  console.log(`방을 청소하지 않았으니 세탁을 하러 갑니다 -: ${errorValue}`);\n  return new Promise(function doLaundry(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 \u003e= 0.5) // 콘서트로 가기\n      resolve(number_2);\n    else\n      reject(number_2); // 강아지 돌보기\n  })\n    .then(function goConcertAfterLaundry(resolveValue) {// then3\n      console.log(`방을 청소하지 않았으니 세탁을 하러 갔고 완료했으니 이제 음악 콘서트에 갑니다 -: ${resolveValue}`);\n    })\n    .catch(function cleanDogAfterNoLaundry(errorValue) {// catch3\n      console.log(`방을 청소하지 않았으니 세탁을 하러 갔지만 완료하지 못했으니 강아지를 돌봅니다 -: ${errorValue}`);\n    });\n});\n```\n\n이 코드는 완벽하게 작동하지만 전문적이지 않은 방식으로 작성된 코드입니다. .catch(()=`''')를 보고 목적을 알기 어려울 것입니다. 따라서 이 작업을 더 나은 방법으로 해결하고 전문적인 모듈식 코드를 작성하는 것이 좋습니다. 같은 해결책을 생각했을 것으로 기대합니다:\n\n\n\n\n```js\nconst cleanRoom = (resolve, reject) =\u003e {\n  let num = Math.random();\n  if (num \u003e= 0.5) resolve(num); // 방을 청소했어요\n  else reject(new Error(num)); // 방을 못 청소했어요\n};\n\nfunction goConcertAfterGoal(resolveValue) {\n    console.log(`방을 청소해서 축구를 하러 갔다가 골을 넣었어요!! 이제 음악 회관으로 갑니다 -: ${resolveValue}`);\n}\n\nfunction cleanDogAfterlosing(errorValue) {\n    console.log(`방을 청소해서 축구를 하러 갔지만 골을 못 넣어서 개를 씻고 있어요 -: ${errorValue}`);\n}\n\nfunction goConcertAfterLaundary(resolveValue) {\n    console.log(`방을 청소하지 않았어요. 빨래를 하러 가는데 완료했어요. 이제 음악 회관에 갑니다 -: ${resolveValue}`);\n}\n\nfunction cleanDogAfterNoLaundary(errorValue) {\n    console.log(`방을 청소하지 않았어요. 빨래를 하러 가는데 못 했어서 개를 씻고 있어요 -: ${errorValue}`);\n}\n\nfunction goFootballAfterCleaning(resolveValue) {\n  console.log(`방을 청소해서 축구를 하러 가요 -: ${resolveValue}`);\n  return new Promise(function makeGoal(resolve, reject) {\n    let number = Math.random();\n    if (number \u003e= 0.6) resolve(number); // 음악 회관으로 가요\n    else reject(number); // 개 씻음\n  })\n    .then((resolveValue) =\u003e goConcertAfterGoal(resolveValue), (errorValue) =\u003e cleanDogAfterlosing(errorValue));\n}\n\nfunction goLaundaryAfterNoCleaning(errorValue) {\n  console.log(`방을 청소하지 않았어요. 빨래를 하러 가요 -: ${errorValue}`);\n  return new Promise(function doLaundary(resolve, reject) {\n    let number_2 = Math.random();\n    if (number_2 \u003e= 0.4) resolve(number_2); // 음악 회관으로 가요\n    else reject(number_2); // 개 씻음\n  })\n    .then((resolveValue) =\u003e goConcertAfterLaundary(resolveValue), (errorValue) =\u003e cleanDogAfterNoLaundary(errorValue));\n}\n\nconst roomCleaningPromise = new Promise(cleanRoom);\n\nroomCleaningPromise\n  .then((resolveValue) =\u003e goFootballAfterCleaning(resolveValue), (errorValue) =\u003e goLaundaryAfterNoCleaning(errorValue));\n```\n\n위 문제에 대한 참고 자료: 과제의 출처.\n\n# 섹션 10: 프로미스가 어떻게 구현되는지 이해하기 위해 사용자 정의 프로미스 만들기.\n\n\u003cimg src=\"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_27.png\" /\u003e\n\n\n\n\n\"How\" Promises가 실제로 작동하는 방식과 Promises를 구현할 때 왜 그렇게 하는지에 대해 이야기하려면 Bottom-up 방식을 채택해야 합니다. 즉, 우리는 다음과 같이 기본부터 직접 Custom Promises를 만들어가면서 이러한 두 가지에 대해 배우게 됩니다:\n\n```js\nclass CustomPromise {\n  constructor(executor) {\n    this.state = \"pending\";\n    this.result = null;\n    this.onResolveCallbacks = []; // 모든 예약된 resolve 콜백을 저장하는 곳\n    this.onRejectCallbacks = []; // 모든 예약된 reject 콜백을 저장하는 곳\n\n    const resolve = (resolveValue) =\u003e {\n      if (this.state === \"pending\") {\n        this.state = \"fulfilled\";\n        this.result = resolveValue;\n        this.executeCallbacks(this.onResolveCallbacks, resolveValue);\n      }\n    };\n\n    const reject = (reason) =\u003e {\n      if (this.state === \"pending\") {\n        this.state = \"rejected\";\n        this.result = reason;\n        this.executeCallbacks(this.onRejectCallbacks, reason);\n      }\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  executeCallbacks(callbacks, arg) {\n    // 다음 tick에서 실행되도록 콜백들을 대기열로 지정합니다\n    setTimeout(() =\u003e {\n      callbacks.forEach((callback) =\u003e {\n        try {\n          const result = callback(arg);\n          if (result instanceof CustomPromise) {\n            // 콜백이 프로미스를 반환하는 경우 연쇄화합니다\n            result.then(\n              (value) =\u003e this.resolveChainedPromise(value),\n              (reason) =\u003e this.rejectChainedPromise(reason)\n            );\n          } else {\n            // 콜백이 프로미스가 아닌 값을 반환하는 경우 해당 값으로 프로미스를 해결합니다\n            this.resolveChainedPromise(result);\n          }\n        } catch (error) {\n          // 예외가 발생하는 경우 프로미스를 거부합니다\n          this.rejectChainedPromise(error);\n        }\n      });\n    }, 0); // 비동기 실행을 위해\n  }\n\n  resolveChainedPromise(result) {\n    // 주어진 결과로 프로미스를 해결합니다\n    this.state = \"fulfilled\";\n    this.result = result;\n    this.executeCallbacks(this.onResolveCallbacks, result);\n  }\n\n  rejectChainedPromise(reason) {\n    // 주어진 이유로 프로미스를 거부합니다\n    this.state = \"rejected\";\n    this.result = reason;\n    this.executeCallbacks(this.onRejectCallbacks, reason);\n  }\n\n  then(onFulfilled, onRejected) {\n    return new CustomPromise((resolve, reject) =\u003e {\n      if (this.state === \"fulfilled\") {\n        this.queueCallbackForExecution(\n          onFulfilled,\n          this.result,\n          resolve,\n          reject\n        );\n      } else if (this.state === \"rejected\") {\n        this.queueCallbackForExecution(\n          onRejected,\n          this.result,\n          resolve,\n          reject\n        );\n      } else {\n        this.onResolveCallbacks.push((result) =\u003e {\n          this.queueCallbackForExecution(onFulfilled, result, resolve, reject);\n        });\n        this.onRejectCallbacks.push((reason) =\u003e {\n          this.queueCallbackForExecution(onRejected, reason, resolve, reject);\n        });\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  queueCallbackForExecution(callback, arg, resolve, reject) {\n    setTimeout(() =\u003e {\n      try {\n        const result = callback ? callback(arg) : arg;\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    }, 0); // 비동기 실행을 위해\n  }\n}\n```\n\n참고: 위의 Custom Promise는 교육 목적으로 제공되었으며 많은 기능이 누락되었으며 실제로 구현된 방식과 다를 수 있습니다. 또한 위의 코드가 모든 시나리오에 작동하지 않을 수도 있습니다 (P.S. 저는 프로그래밍 언어 개발자가 아닙니다 🙃)\n\n위의 Promise는 확실히 설득력 있지만 동시에 압도적입니다. 따라서 Promise가 해결될 때 위의 코드의 제어 흐름을 살펴봅시다.\n\n\n\n단계 1: Constructor가 Executor 함수로 호출됩니다. 여기서 먼저 상태, 결과, onResolveCallbacks, onRejectCallbacks 필드가 기본값으로 할당됩니다. 또한 resolve와 reject 메서드가 여기서 정의되고 변수에 저장됩니다 (나중에 Executor 함수에 전달될 것임).\n\n단계 2: Executor 함수가 실행되어 resolve() 함수 또는 reject() 함수를 호출합니다. 예를 들어, resolve() 메서드가 호출되었다고 가정합니다.\n\n단계 3: resolve() 메서드는 Promise의 상태를 변경하고 결과를 저장합니다. 또한 이 메서드는 나중에 비동기적으로 실행될 executeCallbacks() 메서드를 \"예약\"합니다.\n\n단계 4: JS 해석기는 Executor 함수를 계속 실행한 다음, then() 메서드를 실행합니다.\n\n\n\n단계 5: 제어가 then() 메서드로 전달됩니다. 먼저 약속이 아직 \"대기 중\" 상태에 있으므로 executeCallbacks() 메서드가 아직 실행되지 않았기 때문에 else 부분이 실행됩니다.\n\n단계 6: 약속이 \"이행\" 상태가 되면 executeCallbacks()가 호출되어 onResolveCallbacks에 저장된 콜백을 실행합니다.\n\n이로써 JavaScript의 Promise에 관한 6000단어가 넘는 기사가 끝이 났습니다. 마음에 드셨기를 바랍니다.","ogImage":{"url":"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-TheHowandWhyofPromisesinJavaScript_0.png","tag":["Tech"],"readingTime":36},{"title":"자바스크립트 CircleQueue  Map  빠르고 덮어쓸 수 있는 큐","description":"","date":"2024-05-14 13:03","slug":"2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue","content":"\n\n시퀀셜하게 실행해야 하는 작업들을 대기열에 넣고 일정 간격으로 처리하는 시스템은 매우 흔합니다. 프론트엔드용 새로운 뷰 시스템을 개발하는 도중, 프레임별로 대기열에서 처리할 수 있는 작업량만 시간 제한 내에 처리하는 메커니즘을 도입했습니다. 초당 60프레임 제한으로 한 프레임 당 실행 시간은 16밀리초입니다. 대기열 작업 처리가 16밀리초를 초과하면 남은 작업은 다음 프레임에서 처리됩니다.\n\n대기열에 누적된 많은 작업들이 매 프레임마다 실행되어야 하는 경우, 빠른 속도로 대기열 작업을 디큐하는 과정이 필요했습니다. 또한, 대기열에 이미 동일한 식별 키를 갖는 작업이 존재할 경우 해당 작업은 무시되고 새 작업으로 덮어쓰이는 기능을 구현해야 했습니다.\n\n- 고속 인큐 및 디큐 작업.\n- 각 작업에 할당된 키가 동일한 경우 덮어쓰기.\n\n먼저 간단한 자바스크립트로 이 문제를 해결해 보겠습니다. 가장 먼저 떠오르는 방법은 서큘러 큐입니다. 버퍼 크기를 초과하지 않는 한 요소를 인큐하고 디큐하는 것은 쉽습니다. 저는 이를 단순한 버전으로 구현했습니다.\n\n\n\n```js\nclass MapQueue{\n  #size;\n  #front = 0;\n  #rear = 0;\n  #length = 0;\n  constructor(size){this.#size = size;}\n  length(){return this.#length;}\n  add(value){\n    if(this.#length === this.#size) throw new Error('overflow');\n    this[this.#rear++] = value;\n    if(this.#rear === this.#size) this.#rear -= this.#size;\n    this.#length++;\n  }\n  shift(){\n    if(!this.#length) return null;\n    this.#length--;\n    const data = this[this.#front++];\n    if(this.#front === this.#size) this.#front -= this.#size;\n    return data;\n  }\n}\n```\n\n원과 리어 포인터를 사용하는 원형 큐의 매우 전형적인 구현으로, 모듈로 연산 대신에 사이즈를 미리 빼는 약간의 성능적 이점이 있습니다.\n\n객체가 배열이 아니기 때문에 이미 이것만으로 초고속 큐가 완성되었습니다. 이제 두 번째 요구사항에 대해 다룰 차례입니다: 같은 키에 대한 덮어쓰기입니다.\n\n```js\nconst EMPTY = Object.create(null);\nclass MapQueue{\n  #keys = Object.create(null);\n  #size;\n  #front = 0;\n  #rear = 0;\n  #length = 0;\n  constructor(size){this.#size = size;}\n  length(){return this.#length;}\n  set(key, value){\n    if(this.#keys[key] === undefined){\n      if(this.#length === this.#size) throw new Error('overflow');\n      this.#keys[key] = this.#rear;\n      this[this.#rear++] = value;\n      if(this.#rear === this.#size) this.#rear -= this.#size;\n      this.#length++;\n    }else{\n      const old = this[this.#keys[key]];\n      this[this.#keys[key]] = value;\n      return old;\n    }\n  }\n  get(key){\n    if(this.#keys[key] === undefined) return null;\n    return this[this.#keys[key]];\n  }\n  remove(key){\n    if(this.#keys[key] === undefined) return;\n    this[this.#keys[key]] = EMPTY;\n    delete this.#keys[key];\n    this.#length--;\n  }\n  shift(){\n    if(!this.#length) return null;\n    while(this[this.#front] === EMPTY){\n      delete this[this.#front];\n      this.#front++;\n      if(this.#front === this.#size) this.#front -= this.#size;\n    }\n    const data = this[this.#front];\n    delete this[this.#front];\n    this.#front++;\n    if(this.#front === this.#size) this.#front -= this.#size;\n    this.#length--;\n    return data;\n  }\n}\n```\n\n\n\n특성:\n- #keys: 키와 해당 키의 인덱스를 큐에 저장하는 맵으로 사용되는 객체입니다.\n- #size: 큐의 최대 크기입니다.\n- #front: 큐의 맨 앞 요소의 인덱스입니다.\n- #rear: 다음 요소가 큐에 추가될 인덱스입니다.\n- #length: 큐 안 현재 요소의 수입니다.\n\n메서드:\n- constructor(size): 주어진 최대 크기로 큐를 초기화하는 생성자 메서드입니다.\n- length(): 큐 안 현재 요소의 수를 반환합니다.\n- set(key, value): 지정된 키와 값으로 새 요소를 큐에 추가합니다. 키가 이미 존재하는 경우 해당 값이 업데이트되고 이전 값을 반환합니다. 큐가 꽉 찬 경우 'overflow' 오류를 발생시킵니다.\n- get(key): 큐에서 지정된 키와 관련된 값을 검색합니다. 키가 존재하지 않는 경우 null을 반환합니다.\n- remove(key): 큐에서 지정된 키를 가진 요소를 제거합니다. 키가 존재하지 않는 경우 아무 작업도 수행하지 않습니다. 제거된 요소를 EMPTY로 표시합니다.\n- shift(): 큐에서 맨 앞 요소를 제거하고 반환합니다. 큐가 비어 있는 경우 null을 반환합니다. 큐의 맨 앞에 있는 EMPTY 요소를 건너뛰고 제거합니다.\n\n이 코드는 객체 기반의 원형 큐 접근 방식을 사용하여 빠른 큐를 구현합니다. 고유한 키로 요소를 추가하고, 기존 키에 대한 값 업데이트, 키별로 요소 제거, 맨 앞 요소 검색을 지원합니다. 큐는 요소가 큐 중간에서 제거될 때 해당 요소를 EMPTY로 표시하고, 앞에서 요소를 이동할 때 해당 요소를 건너뛰는 방식으로 효율적으로 처리합니다.","ogImage":{"url":"/assets/img/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue_0.png"},"coverImage":"/assets/img/2024-05-14-JSCircleQueueMapUltra-fastoverwritablequeue_0.png","tag":["Tech"],"readingTime":4}],"page":"107","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"107"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>