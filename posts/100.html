<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/100" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/100" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="타입 vs 인터페이스 TypeScript에서" href="/post/2024-05-14-TypesVsInterfacesinTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="타입 vs 인터페이스 TypeScript에서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="타입 vs 인터페이스 TypeScript에서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">타입 vs 인터페이스 TypeScript에서</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요" href="/post/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마이크로 프론트엔드 재사용하는 방법" href="/post/2024-05-14-HowtoReuseMicroFrontends"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마이크로 프론트엔드 재사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마이크로 프론트엔드 재사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">마이크로 프론트엔드 재사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드" href="/post/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라라벨 8로 사용자 로그인 및 등록 화면 생성" href="/post/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라라벨 8로 사용자 로그인 및 등록 화면 생성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라라벨 8로 사용자 로그인 및 등록 화면 생성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">라라벨 8로 사용자 로그인 및 등록 화면 생성</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기" href="/post/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="전문 개발자를 위한 18가지 고급 JavaScript 기술" href="/post/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="전문 개발자를 위한 18가지 고급 JavaScript 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="전문 개발자를 위한 18가지 고급 JavaScript 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">전문 개발자를 위한 18가지 고급 JavaScript 기술</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" href="/post/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">API 응답에 TypeScript 유형을 올바르게 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" href="/post/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내가 좋아하는 JavaScript 짧은 코드 한 줄" href="/post/2024-05-14-MyFavouriteJavaScriptOne-Liners"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내가 좋아하는 JavaScript 짧은 코드 한 줄" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내가 좋아하는 JavaScript 짧은 코드 한 줄" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">내가 좋아하는 JavaScript 짧은 코드 한 줄</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link posts_-active__YVJEi" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`\u0026`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} \u0026 Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} \u0026 Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},{"title":"가장빠른 구체적인걸로 Golang Air를 이용한 실시간 리로드 구현 안내로 표현하는게 괜찮을거 같아요","description":"","date":"2024-05-14 15:24","slug":"2024-05-14-GuideforImplementingLiveReloadUsingGolangAir","content":"\n에어는 개발 중에 Go 애플리케이션을 실시간으로 다시로드하는 데 사용되는 명령 줄 유틸리티입니다. 이 도구는 Go 애플리케이션이 실시간으로 다시로드되도록 하는 데 도움이 되는 도구로 작용합니다.\n\n![이미지](/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png)\n\n코딩하는 동안 라이브 리로드를 사용하면 개발자가 실시간으로 변경 사항을 확인할 수 있습니다. 변경 사항이 있을 때 서버를 수동으로 중지하고 다시 시작할 필요가 없어 시간을 절약할 수 있습니다. 어떤 Go 라이브 리로드 프레임워크는 소스 코드 변경 후 애플리케이션을 자동으로 다시로드할 수 있습니다. 이 기사에서는 Air 라이브러리를 사용하여 Go에서 라이브 리로드를 구현하는 방법을 안내합니다.\n\n# Golang Air 라이브러리 소개\n\n에어는 개발 중인 Go 애플리케이션을 실시간으로 다시로드할 수 있도록 설계된 명령줄 유틸리티입니다. 이것은 Go 애플리케이션이 실시간으로 다시로드될 수 있도록 도와주는 도구로 작용합니다.\n\n에어 외에도 Go용 잘 알려진 라이브 리로드 프레임워크로는 Fresh와 Realize가 있습니다. 이들은 소스 코드의 변경을 감지하면 자동으로 애플리케이션을 다시 빌드하고 다시 시작하는 방식으로 작동합니다.\n\n- Fresh는 모든 Go 웹 서버와 함께 사용할 수 있는 명령줄 도구로, 손쉽게 빌드 프로세스에 통합할 수 있습니다.\n- Realize는 Go 기반 빌드 시스템으로, Go 애플리케이션에 대한 라이브 리로딩 기능을 제공합니다.\n\n이러한 옵션들 사이의 기능적 유사성을 고려할 때, Go 프로젝트에 사용할 프레임워크를 선택하는 것은 주로 개인 취향에 달려 있습니다. 각 프레임워크를 시험해보고 어떤 것이 작업 흐름에 가장 직관적이고 직관적으로 느껴지는지 확인해보세요.\n\n# Live Reload이란 무엇인가요?\n\nLive Reload는 소스 코드를 수정할 때 애플리케이션이나 서버를 자동으로 새로 고침하는 개발 기능입니다. 이는 개발 및 디버깅 중에 특히 유용하며, 코드를 수정할 때마다 애플리케이션을 수동으로 중지하고 다시 시작해야 하는 필요성을 제거합니다.\n\n# Live Reload를 구현해야 하는 시점은 언제인가요?\n\nLive Reload는 다양한 시나리오에서 유용합니다. 여기에는 다음이 포함됩니다:\n\n# 웹 개발\n\n라이브 리로드는 웹 개발에서 일반적으로 사용됩니다. 클라이언트 측 (HTML, CSS, 자바스크립트)와 서버 측 (백엔드 코드) 변경사항에 모두 적용됩니다. 파일을 저장하면 웹 페이지가 자동으로 새로 고침되어 수동으로 새로 고침할 필요 없이 최신 변경 사항이 반영됩니다.\n\n# 프론트엔드 프레임워크\n\n리액트, 앵귤러, 뷰와 같은 프론트엔드 프레임워크는 종종 내장되어 있거나 쉽게 통합할 수 있는 도구를 지원합니다. 이는 개발 프로세스를 가속화하고 개발자가 사용자 인터페이스에서 즉각적인 변경 사항을 볼 수 있도록 해줍니다.\n\n# 백엔드 개발\n\n백엔드 개발 중에는 서버 측 코드에 변경 사항이 있을 때 서버를 자동으로 다시 시작하는 라이브 리로드가 유용합니다. 이 기능은 Express (Node.js), Django (Python)와 같은 프레임워크에서 일반적으로 사용됩니다.\n\n# 크로스 플랫폼 개발\n\nReact Native 또는 Flutter와 같은 프레임워크를 사용한 모바일 앱 개발과 같은 크로스 플랫폼 개발 시나리오에서 라이브 리로드는 가치 있는 기능입니다. 코드 변경사항이 연결된 기기나 에뮬레이터에서 자동 업데이트를 트리거할 수 있습니다.\n\n# Go 언어 (Golang)\n\nGo 프로그래밍 언어는 개발 중에 실시간 리로드를 잘 지원합니다. gin, fresh, air와 같은 도구들은 Go 커뮤니티에서 인기가 있습니다. 이 도구들은 코드 변경을 모니터하고 자동으로 Go 애플리케이션을 다시 빌드하고 재시작하여 원활한 개발 경험을 제공합니다.\n\ngin을 사용한 예시:\n\n```js\ngo get -u github.com/codegangsta/gin\ngin run main.go\n```\n\n에어를 사용한 예시:\n\n```js\ngo get -u github.com/cosmtrek/air\nair\n```\n\n# Go에서의 라이브 리로드 vs 핫 리로드\n\nGo에서 \"라이브 리로드\"라는 용어는 응용프로그램을 수동으로 중지하고 다시 시작할 필요 없이 자동으로 새로 고침하고 업데이트하는 기능을 가리킵니다.\n\n\"핫 리로드\"라고도 알려진 유사한 개념은 응용 프로그램의 코드를 업데이트하는 것을 의미하는데, 이때 응용 프로그램이 여전히 실행 중인 상태에서 현재 상태나 진행 중인 프로세스를 방해하지 않고 업데이트하는 것입니다.\n\n라이브 리로드와 핫 리로드는 모두 개발에서 유용하며, 수동으로 중단하고 다시 시작할 필요 없이 코드 변경의 빠른 반복과 테스트를 가능하게 합니다. 응용 프로그램의 복잡성에 따라, 핫 리로딩을 구현하는 것이 불가능하거나 더 많은 도전을 야기할 수 있습니다.\n\nGo 및 Gin 프로젝트는 라이브 리로드 기능을 내장하고 있지 않습니다. 따라서, Go와 Gin 프로젝트에서 라이브 리로드를 구현하기 위해 Air 라이브러리를 구성하는 방법을 살펴보겠습니다.\n\n# Gin Gonic과 함께 Golang Air 사용하는 6단계\n\n# 단계 1: Gin Gonic과 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Gin Gonic과 Air를 설치하세요:\n\n```js\n# Gin Gonic 설치\ngo get -u github.com/gin-gonic/gin\n```\n\n```js\n# Air 설치\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Gin 애플리케이션 만들기\n\n다음 내용으로 main.go라는 새 파일을 만드세요:\n\n```js\n// main.go\npackage main\n\nimport (\n \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n // 새 Gin 라우터 생성\n router := gin.Default()\n\n // 라우트 정의\n router.GET(\"/\", func(c *gin.Context) {\n  c.JSON(200, gin.H{\n   \"message\": \"안녕, Gin!\",\n  })\n })\n\n // 서버를 8080 포트에서 실행\n router.Run(\":8080\")\n}\n```\n\n# 단계 3: Air 구성 파일 만들기\n\nair.toml이라는 파일을 만들어서 다음 내용을 넣어주세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동한 후 Air를 사용하여 애플리케이션을 실행하세요:\n\n```js\n공기;\n```\n\n이렇게 하면 live-reloading이 포함된 Gin 애플리케이션이 시작됩니다. 코드를 변경하고 파일을 저장하면 Air가 변경 사항을 자동으로 감지하고 서버를 다시 시작합니다.\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080에 접속해보세요. JSON 응답을 확인할 수 있어야 합니다.\n\n```js\n{\"message\":\"안녕, 진님!\"}\n```\n\n# 단계 6: 변경 내용을 만들고 실시간 새로 고침 확인하기\n\nmain.go 파일을 수정하고 저장한 뒤 Air가 서버를 자동으로 다시 시작하는 것을 확인하세요. 응용 프로그램을 수동으로 다시 시작하지 않아도 브라우저에서 업데이트된 응답을 확인할 수 있습니다.\n\n# Echo로 Golang Air 사용하는 6 단계\n\n# 단계 1: Echo와 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Echo와 Air를 설치하세요:\n\n```js\n# Echo 설치\ngo get -u github.com/labstack/echo/v4\n\n# Air 설치\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Echo 애플리케이션 생성하기\n\n```go\n// main.go\npackage main\n\nimport (\n \"github.com/labstack/echo/v4\"\n \"net/http\"\n)\n\nfunc main() {\n // Create a new Echo instance\n e := echo.New()\n\n // Define a route\n e.GET(\"/\", func(c echo.Context) error {\n  return c.JSON(http.StatusOK, map[string]string{\n   \"message\": \"Hello, Echo!\",\n  })\n })\n\n // Start the server on port 8080\n e.Start(\":8080\")\n}\n```\n\nStep 3: Air Configuration File 생성하기\n\n다음 내용으로 air.toml이라는 파일을 생성하세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동하여 다음 명령어를 사용하여 애플리케이션을 실행하세요:\n\n```js\nair;\n```\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080에 접속해보세요. 다음과 같은 JSON 응답이 표시되어야 합니다:\n\n```js\n{\"message\":\"Hello, Echo!\"}\n```\n\n# 단계 6: 변경 사항을 적용하고 라이브 리로딩 확인하기\n\n위와 동일합니다.\n\n# Air 및 Fiber 사용을 위한 6 단계\n\n# 단계 1: Fiber 및 Air 설치하기\n\n터미널을 열고 다음 명령어를 실행하여 Fiber와 Air를 설치하세요:\n\n```js\n# Fiber 설치하기\ngo get -u github.com/gofiber/fiber/v2\n```\n\n```js\n# Air 설치하기\ngo get -u github.com/cosmtrek/air\n```\n\n# 단계 2: 간단한 Fiber 애플리케이션 만들기\n\n다음 내용으로 main.go란 새 파일을 만드세요.\n\n# 스텝 3: Air 구성 파일 생성\n\n다음 내용으로 air.toml이라는 파일을 생성하세요:\n\n```js\n# air.toml\nroot = \".\"\ntmp_dir = \"tmp\"\nbuild_cmd = \"go build -o ./tmp/main .\"\nrun_cmd = \"./tmp/main\"\n```\n\n# 단계 4: Air로 애플리케이션 실행하기\n\n터미널에서 프로젝트 디렉토리로 이동하고 Air를 사용하여 애플리케이션을 실행하세요:\n\n```js\nair;\n```\n\n이렇게 하면 Fiber 애플리케이션이 라이브 리로딩과 함께 시작됩니다. 코드를 수정하고 파일을 저장할 때마다 Air가 변경 사항을 자동으로 감지하고 서버를 다시 시작합니다.\n\n# 단계 5: 애플리케이션 테스트하기\n\n웹 브라우저를 열고 http://localhost:8080 으로 이동하세요. JSON 응답을 확인해야합니다:\n\n```js\n{\"message\":\"Hello, Fiber!\"}\n```\n\n# 단계 6: 변경 사항을 만들고 실시간 리로딩 확인하기\n\n위와 동일합니다.\n\n# 도커 컨테이너와 함께 Golang Air 사용하기 위한 4단계\n\n고랭 어플리케이션에서 도커 컨테이너와 함게 라이브 리로드를 사용하는 주요 이점 중 하나는 매번 컨테이너를 중지하고 시작하는 번거로움 없이 코드를 빠르게 반복할 수 있다는 것입니다.\n\n이는 특히 컨테이너 안에서 어플리케이션을 개발하고 유효성을 검사할 때 매우 유용하며, 문제를 신속하고 쉽게 식별하여 해결할 수 있도록 도와줍니다.\n\n라이브 리로드 라이브러리를 도커와 통합하려면, 도커 컨테이너 내에서 로컬 소스 코드 디렉토리를 볼륨 마운트해야 합니다. 이 설정을 통해 Air 라이브러리가 코드 변경을 모니터하고 필요에 따라 서버를 자동으로 새로 고칠 수 있게 됩니다.\n\n# 단계 1: Air 설치 및 실행을 위한 Dockerfile 작성\n\n```js\nFROM golang:latest\n\n# 컨테이너 내에서 작업 디렉토리 설정\nWORKDIR /app\n\n# go.mod 및 go.sum 파일을 작업 공간으로 복사\nCOPY go.mod go.sum ./\n\n# 모든 종속성 다운로드\nRUN go mod download\n\n# 현재 디렉토리의 소스를 작업 공간으로 복사\nCOPY . .\n\n# Go 앱 빌드\nRUN go build -o main .\n\n# 외부로 포트 8080 노출\nEXPOSE 8080\n\n# 실행 가능 파일 실행하는 명령\nCMD [\"air\"]\n```\n\n# 단계 2: .air.toml 파일 생성하기\n\n프로젝트 루트에 다음 내용을 포함하는 .air.toml 파일을 만들어주세요:\n\n```toml\nroot = \".\"\ntestdata_dir = \"testdata\"\ntmp_dir = \"tmp\"\n\n[build]\n  args_bin = []\n  bin = \"./tmp/main\"\n  cmd = \"go build -o ./tmp/main .\"\n  delay = 1000\n  exclude_dir = [\"assets\", \"tmp\", \"vendor\", \"testdata\"]\n  exclude_file = []\n  exclude_regex = [\"_test.go\"]\n  exclude_unchanged = false\n  follow_symlink = false\n  full_bin = \"\"\n  include_dir = []\n  include_ext = [\"go\", \"tpl\", \"tmpl\", \"html\"]\n  kill_delay = \"0s\"\n  log = \"build-errors.log\"\n  send_interrupt = false\n  stop_on_error = true\n\n[color]\n  app = \"\"\n  build = \"yellow\"\n  main = \"magenta\"\n  runner = \"green\"\n  watcher = \"cyan\"\n\n[log]\n  time = false\n\n[misc]\n  clean_on_exit = false\n\n[screen]\n  clear_on_rebuild = false\n```\n\n# 단계 3: Docker 이미지 빌드하기\n\n```bash\ndocker build -t airy-app .\n```\n\n# 단계 4: 도커 컨테이너에서 서버 실행하기\n\n```js\ndocker run -p 8080:8080 -v $PWD:/app airy-app\n```\n\n- docker run: 도커 컨테이너를 실행하는 데 사용되는 명령어입니다.\n- p 8080:8080: 이 옵션은 호스트 머신의 포트 8080을 컨테이너 내부의 포트 8080에 매핑합니다. 외부 시스템이 컨테이너 내에서 실행 중인 애플리케이션에 포트 8080을 통해 액세스할 수 있게 합니다.\n- v $PWD:/app: 이 옵션은 호스트 머신의 현재 작업 디렉토리($PWD)를 컨테이너 내부의 /app 디렉토리에 마운트합니다. 이것은 볼륨 마운트이며, 호스트의 현재 작업 디렉토리의 파일 및 디렉토리에 대한 컨테이너의 액세스를 허용합니다. 호스트나 컨테이너의 파일을 변경하면 둘 다 반영됩니다.\n- airy-app: 이것은 실행 중인 도커 이미지의 이름입니다. 이것은 컨테이너가 생성될 이미지를 지정합니다.\n\n`docker run` 명령은 airy-app 이미지에서 컨테이너를 생성하고 실행합니다. 이는 호스트의 포트 8080을 컨테이너 내부의 포트 8080으로 매핑하여 외부에서 애플리케이션에 액세스할 수 있게 합니다. 또한 현재 작업 디렉토리를 호스트에서 컨테이너 내부의 /app디렉토리로 마운트하여 호스트와 컨테이너 간의 데이터 공유를 용이하게 합니다.\n\n# Go에서 Live Reload 사용의 장단점\n\n# 장점\n\nLive reload는 코딩 프로세스의 효율성을 크게 향상시키는 개발 도구입니다. 소스 코드를 변경할 때 응용 프로그램이 자동으로 즉시 업데이트되도록 하는 것으로, 수동 재시작이 필요 없습니다. 여기에서 이점을 살펴보겠습니다:\n\n- 개발 속도 향상: 기존 개발은 코드 변경 사항이 적용되는 것을 보기 위해 응용 프로그램을 중지하고 다시 시작해야 하는 경우가 많습니다. Live reload를 사용하면 코드를 저장하는 즉시 변경 사항이 동적으로 적용되어 더 빠른 개발 워크플로우를 제공합니다.\n- 다운타임 최소화: Live reload 없이는 수정 후 응용 프로그램이 다시 시작될 때까지 다운타임을 경험하는 경우가 많습니다. Live reload를 사용하면 이러한 다운타임을 최소화하여 코딩에 집중하며 중단 없이 작업할 수 있습니다.\n- 디버깅 용이: Live reload는 가치 있는 디버깅 도구입니다. 변경 사항이 발생할 때마다 응용 프로그램을 자동 새로고침하여 문제를 신속히 식별하고 해결할 수 있습니다. 이러한 즉각적인 피드백 루프는 디버깅 프로세스를 가속화합니다.\n- 효율적인 테스팅: 지속적이고 자동화된 새로고침은 서로 다른 시나리오를 테스트하는 데 유용하며, 수동 개입이 필요하지 않고 변경 사항이 철저히 테스트됨을 보장합니다.\n- 심플한 컨테이너 개발: Docker와 같은 컨테이너 환경에서는 빠르게 변화에 적응하기 위해 live reload가 유용하며, 컨테이너화된 응용 프로그램 내에서 문제를 식별하고 해결하기가 더 쉬워집니다.\n- 복잡한 프로젝트에 이상적: 다수의 종속성이나 긴 시작 시간이 필요한 복잡한 프로젝트에서 live reload는 특히 유용합니다. 반복적인 수동 개입없이 코드 변경 사항의 영향을 실시간으로 확인하여 개발 프로세스를 간소화합니다.\n\n본질적으로 라이브 리로딩은 개발 워크플로우를 간소화하고 다운 타임을 줄이며 디버깅을 돕는 시간 절약 메커니즘입니다. 특히 복잡한 구조나 긴 시작 프로세스를 갖는 프로젝트에 특히 유용합니다.\n\n# 단점\n\n- 자원 소모가 큼: 라이브 리로딩 도구는 추가적인 시스템 자원을 사용하여 응용 프로그램을 모니터하고 다시 불러오는 데 사용됩니다. 이는 개발 중에 메모리와 CPU 사용량이 증가할 수 있습니다.\n- 의도치 않은 부작용 가능성: 자동 리로딩은 기존 상태와 진행 중인 프로세스를 중단시키므로 복잡한 응용프로그램에서 예기치 않은 동작을 초래할 수 있습니다. 개발자들은 잠재적인 부작용에 주의해야 합니다.\n- 호환성 문제: 라이브 리로딩 기능을 통합하려면 프로젝트 구조나 종속성을 조정해야 할 수 있습니다. 일부 프로젝트는 특정 라이브 리로딩 도구와 호환되지 않을 수 있습니다.\n- 빌드 시간 부담: 라이브 리로딩 중에 응용 프로그램을 다시 빌드하고 다시 시작하는 과정은 약간의 지연을 발생시킵니다. 이 지연은 일반적으로 최소화되지만 시간이 지남에 따라 누적되어 전체 개발 경험에 영향을 줄 수 있습니다.\n- 특정 도구에 종속: 라이브 리로딩은 종종 특정 도구나 라이브러리(예: Air, Fresh)를 통해 용이해집니다. 이러한 도구에 의존하는 것은 관리 및 업데이트가 필요한 종속성을 도입할 수 있습니다.\n\n라이브 리로딩을 통해 코드 변경에 대한 빠른 피드백을 제공함으로써 개발 경험을 크게 향상시킬 수 있습니다. 그러나 자원 소모, 의도치 않은 부작용, 특정 프로젝트 환경에서의 신중한 통합 필요성과 같은 잠재적인 단점에 대해 인지해야 합니다. 라이브 리로딩을 사용할지 여부는 프로젝트의 특정 요구 사항과 특성을 기반으로 결정되어야 합니다.\n\n# 결론\n\n요약하자면, 개발 과정에서 실시간 다시로드의 중요성은 과장할 수 없습니다. 이는 더 효율적인 작업 흐름을 위한 촉매제 역할을 하며, 개발자들이 코드 변경의 영향을 실시간으로 확인할 수 있도록 합니다.\n\nGo (Golang)의 경우, Air와 같은 도구는 다시 빌드하고 다시 시작하는 프로세스를 자동화하여 지속적인 개발 환경을 조성하는 데 중요한 역할을 합니다. 이는 반복 속도를 가속화할 뿐만 아니라, 개발자들이 수동 개입으로 인한 방해 없이 코딩에 집중할 수 있도록 하기 때문에 전반적인 생산성을 향상시킵니다.\n\n궁극적으로, Air와 같은 도구가 보여주는 실시간 다시로드는 현대적인 개발 환경에서 필수적인 자산으로, 빠른 피드백 루프와 반응성 있는 코딩 경험에 기여합니다.\n","ogImage":{"url":"/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png"},"coverImage":"/assets/img/2024-05-14-GuideforImplementingLiveReloadUsingGolangAir_0.png","tag":["Tech"],"readingTime":10},{"title":"마이크로 프론트엔드 재사용하는 방법","description":"","date":"2024-05-14 15:22","slug":"2024-05-14-HowtoReuseMicroFrontends","content":"\n\n## 마이크로 프론트엔드는 재사용하기 어렵습니다. 그러나 적절한 도구 세트를 활용하면 서로 다른 프로젝트에 걸쳐 마이크로 프론트엔드를 재사용할 수 있습니다.\n\n![Micro Frontends](/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png)\n\n이론상으로 마이크로 프론트엔드는 멋지지만, 여러 팀이 동시에 병렬로 생성하고 개별적으로 섞어 다양한 응용 프로그램을 만들어내고 그들의 로직을 재작성할 필요 없이 서로 조합할 수 있습니다.\n\n그들은 마치 마법 같아요!\n\n\n\n하지만 실제로 이러한 마이크로 프론트엔드를 공유하고 재사용하는 과정은 쉽지 않습니다.\n\n그래서 이 글에서 여러 프로젝트에서 무난하게 재사용하는 방법을 보여드릴 거에요.\n\n시작해봅시다!\n\n# 우리가 사용할 도구\n\n\n\n마이크로 프론트엔드 자체로는 재사용이나 여러 팀 또는 개발 커뮤니티와 공유할 방법을 제공하지 않습니다.\n\n따라서 우리는 어떤 종류의 도구가 필요하며, 오늘은 비트(Bit)에 대해 알려 드리겠습니다.\n\n비트(Bit) 및 비트 클라우드(Bit Cloud)(클라우드 기반 마켓플레이스)는 구성 가능한 소프트웨어 제품을 개발하는 혁신적인 팀을 위한 완벽한 솔루션을 제공합니다. 업계를 선도하는 구성 요소 기반 개발 플랫폼으로, 수천 개의 팀 및 포춘 500 개사에게 대규모 앱 개발을 위한 구성 가능 앱 개발을 지원합니다.\n\n아래는 CDD 플랫폼에서 필요한 주요 기능 중 일부이며 비트(Bit)에서 제공하는 기능입니다.\n\n\n\n- 컴포넌트 중심 개발 툴셋\n- 컴포넌트 소스 코드 관리 및 버전 관리\n- 의존성 관리: 자동화, 스마트하고 일관성 있음\n- 패키징 및 배포\n- 공유하고 협업하는 중앙 플랫폼\n- 찾아보기 및 검색\n- 사용, 설치 및 통합 (빌드 시간 및 런타임)\n\n여기서 \"composable app development\"와 \"component-driven\"에 대해 얘기하고 있는 이유가 뭘까요? 왜냐하면 그것이 우리 문제를 해결하는 열쇠가 될 것이기 때문이에요.\n\n알다시피, Bit에는 코드뿐만 아니라 테스트와 논리적 컴포넌트의 문서까지 포함하는 \"컴포넌트\" 개념이 있어요. 이 \"컴포넌트\" 개념을 우리의 마이크로 프론트엔드에 매핑할 수 있게 되면 위에서 언급한 혜택을 누릴 수 있게 됩니다.\n\n\n\n우리의 마이크로 프론트엔드는 갑자기 다음과 같습니다:\n\n- 조립 가능합니다.\n- 모든 종속성을 쉽게 관리할 수 있습니다.\n- 개별 패키지로 쉽게 배포할 수 있습니다.\n- Bit.cloud를 통해 쉽게 발견할 수 있습니다.\n- 그리고 Bit를 통해 이러한 패키지를 설치하는 것은 단 한 가지 명령을 실행하는 것만큼 단순합니다.\n\n다른 프로젝트 내에서 일부 마이크로 프론트엔드를 재사용하는 실용적인 예제를 살펴봅시다.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 20년치의 지식을 모두와 공유하는 내 무료 뉴스레터에 가입해 보시는 건 어떨까요? \"늙은 개발자의 혼잣말\"에 참여해 보세요!\n\n\n\n# 기존의 마이크로 프론트엔드 재사용\n\n만약 Bit를 사용하여 독자적인 마이크로 프론트엔드를 어떻게 만들 수 있는지 궁금하다면, 아래 기사를 읽어보세요. 그곳에서 모든 과정을 단계별로 보여줄 테니까요:\n\n그러나 단순히 재사용만 하려면, 조금 더 간단한 프로세스가 적용됩니다.\n\n먼저 해야 할 일은 아래와 같은 명령어로 Bit를 설치하는 것입니다:\n\n\n\n```js\nnpx @teambit/bvm install\n```\n\n설치가 완료되면 Bit은 프로젝트에 패키지를 추가할 준비가 되어 있지만, 이를 수행할 수 있는 여러 가지 방법을 이해해야 합니다.\n\n우선 Bit.cloud를 통해 원하는 마이크로 프론트엔드를 찾아 설치해야 합니다. 예를 들어, 얼마 전에 만든 블로그 마이크로 프론트엔드를 한 번 살펴보겠습니다. 그것은 기사를 나열하는 간단한 마이크로 프론트엔드입니다.\n\n페이지의 오른쪽 상단에는 \"사용\" 버튼이 있습니다. 클릭하면 다음 메뉴가 표시됩니다:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoReuseMicroFrontends_1.png\" /\u003e\n\n알겠지만, 'Bit'를 사용하는 것 외에도 \"npm\", \"yarn\", \"pnpm\"을 사용할 수 있습니다. 이 모든 프로세스는 간단합니다. 웹사이트에서 제공된 라인을 사용하기만 하면 됩니다. 사실, 이 방법은 Bit가 시스템에 설치되어 있을 필요가 전혀 없습니다. 그러나 이 명령을 사용하여 사용자 정의 Bit 레지스트리를 구성해야 합니다.\n\n```js\nnpm config set '@deleteman:registry' https://node.bit.cloud\n```\n\n그러나 아마도 이미 알고 계실 것처럼, 이 도구들은 모든 종속성을 직접 node_modules 폴더 내에 설치합니다. 이는 유용하지만 패키지의 코드에 쉽게 액세스하지 못하게 하고 심지어 변경할 수 없게 합니다. 보통 다른 사람의 패키지를 변경하고 싶지 않지만, 여기서는 여러분이 자신의 마이크로 프론트엔드를 재사용하고자 할 수도 있기 때문에 여기저기 변경하는 게 유용할 수 있습니다.\n\n\n\n그런 경우에는 비트(Bit)의 옵션에 대해 알아두는 게 좋아요:\n\n- 설치: 이 옵션은 npm을 사용하는 것과 거의 비슷합니다. 프로젝트에 구성 요소를 설치하면 예상대로 node_modules 폴더 안에 저장됩니다.\n- 가져오기: 이전 옵션처럼 종속성을 저장하는 대신, 이 명령은 패키지를 워크스페이스 루트에 새 폴더에 다운로드합니다. 그러면 node_modules 블랙홀에 빠질 필요 없이 코드에 쉽게 액세스할 수 있어요. 더불어 Bit는 가져온 각 구성 요소에 대해 node_modules 안에 심볼릭 링크를 만들고 새로 다운로드한 파일을 가리킵니다. 이렇게 하면 코드에서 가져온 구성 요소를 여전히 일반 외부 구성 요소처럼 가져올 수 있습니다. 가져온 마이크로 프론트엔드를 변경하면 업데이트를 새 버전으로 푸시할 수 있어요. 다른 사람들과 협업하여 마이크로 프론트엔드를 개발하고 확장하려는 경우에 이 옵션이 완벽해요.\n- 포크: 그러나 마이크로 프론트엔드의 사본을 만들고 변경하고 싶다면, Forking이 적절한 옵션이에요. \"가져오기\" 명령과 동일하게 작동하지만 버전 기록을 다운로드하지 않아서 사실상 당신의 변경을 기다리는 새로운 구성 요소가 됩니다.\n\n이런 내용을 감안하고, 내가 만든 마이크로 프론트엔드를 사용해 새로운 프로젝트를 처음부터 만드는 실용적인 예시를 살펴보겠어요.\n\n## 마이크로 프론트엔드로 웹사이트 구축하기\n\n\n\n위 예시를 통해, 홈 화면에 2개의 링크가 있는 웹사이트를 만들어보겠습니다:\n\n- 블로그: 블로그 마이크로 프론트엔드를 사용하여 블로그를 표시할 예정입니다.\n- 문서: 문서 마이크로 프론트엔드를 사용하여 내부 네비게이션 및 사용자 정의 페이지를 표시할 예정입니다.\n\n이들은 모두 예시 마이크로 프론트엔드입니다만, 귀하의 사용 사례에 유용한 예시로 확장할 수 있습니다.\n\n우리는 Bit를 사용하여 React 앱을 만들고, 그 후에 마이크로 프론트엔드를 설치할 것입니다.\n\n\n\n코딩을 시작하기 전에 먼저 Bit 워크스페이스를 생성하여 애플리케이션 코드를 넣을 수 있도록 하겠어요. 이렇게 하면 나중에 공유할 수 있게 될 거에요 (이에 대해서는 잠시 후에 더 자세히 알려드릴게요).\n\n```js\nyour-project-folder\u003e bit new react workspace --env teambit.react/react-env --default-scope deleteman.test-website\n```\n\n이제 워크스페이스 폴더 안에서 작업할 거에요.\n\n이제 새로운 React 애플리케이션을 만들어봅시다.\n\n\n\n이를 위해서, 아래 명령어를 사용할 거에요:\n\n```js\nbit create react-app apps/website --aspect teambit.react/react-env\n```\n\n이것은 기본 scope 내 (우리의 경우에는 test-website)에 apps/website 폴더를 생성합니다.\n\n이제 앱을 다음과 같이 설정하세요:\n\n\n\n```js\nbit use apps/website\n```\n\n그리고 `bit run website`으로 마침내 테스트할 수 있습니다. 이것은 포트 3000에서 서버를 시작하며 다음과 같이 매우 기본적인 내용이 표시됩니다:\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_2.png)\n\n이제 `apps/website/website.tsx` 파일의 코드를 다음과 같이 변경하겠습니다:\n\n\n\n\n```js\nimport './App.css';\n\nexport function Website() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cp\u003e\n         웹사이트에 오신 것을 환영합니다!\n        \u003c/p\u003e\n        \u003cp\u003e\n          저희 제품에 대해 더 알고 싶다면, 저희의 \u003ca href=\"/docs\"\u003e문서\u003c/a\u003e를 방문해 주세요.\n          혹은 \u003ca href=\"/blog\"\u003e기술 블로그\u003c/a\u003e도 확인해 보세요.\n        \u003c/p\u003e\n        \n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n우리는 더 간단히 단축할 수 있지만, 너무 복잡하게 하지 않기 위해 새 홈페이지가 어떻게 보이는지 알려드릴게요:\n\n![2024-05-14-HowtoReuseMicroFrontends_3.png](/assets/img/2024-05-14-HowtoReuseMicroFrontends_3.png)\n\n이제 두 섹션에 대한 라우트를 추가해 봅시다. 블로그 섹션이 가장 쉽기 때문에, 그것부터 시작해봅시다.\n\n\n\n가장 먼저 해야 할 일은 Bit를 사용하여 블로그 마이크로 프론트엔드를 가져오는 것입니다:\n\n```js\nyour-project-folder\u003e bit import deleteman.microfrontends/blog\n```\n\n지금은 프로젝트의 루트에 microfrontends라는 폴더가 생겼을 것이며, website.tsx 파일을 다음과 같이 편집할 수 있을 것입니다:\n\n```js\nimport { useState } from 'react';\nimport { Blog } from \"@deleteman/microfrontends.blog\";\nimport './App.css';\n\nexport function Website() {\n\n  const [page, setPage] = useState(\"home\");\n\n  function navTo(event, target) {\n    event.preventDefault();\n    setPage(target);\n    return false;\n  }\n\n  if(page === \"home\") {\n    return (\n      \u003cdiv className=\"App\"\u003e\n        \u003cheader className=\"App-header\"\u003e\n          \u003cp\u003e\n            웹사이트에 오신 것을 환영합니다!\n          \u003c/p\u003e\n          \u003cp\u003e\n            제품에 대해 더 알아보려면 \u003ca href=\"#\" className='inline' onClick={(evt) =\u003e navTo(evt,'docs')}\u003e문서\u003c/a\u003e를 방문해주세요.\n            또는 \u003ca href=\"#\" className='inline' onClick={(evt) =\u003e navTo(evt, 'blog')}\u003e기술 블로그\u003c/a\u003e를 확인해도 좋아요.\n          \u003c/p\u003e\n        \u003c/header\u003e\n      \u003c/div\u003e\n    );\n  }\n\n  if(page === \"blog\") {\n    return (\n      \u003c\u003e\n        \u003cBlog /\u003e\n        \u003cp\u003e\n          홈으로 돌아가려면 \u003ca href=\"#\" className='inline' onClick={(evnt) =\u003e navTo(evnt, 'home')}\u003e홈\u003c/a\u003e을 클릭하세요.\n        \u003c/p\u003e\n      \u003c/\u003e\n    );\n  }\n}\n```\n\n\n\n주목하세요! 여기서는 첫 번째 마이크로 프론트엔드인 Blog 컴포넌트를 가져온다는 것을 알 수 있습니다. 파일이 다른 위치에 있더라도 node_modules 폴더 안에 복사된 것처럼 다룰 수 있어요.\n\n게다가 추가적인 라우팅을 추가하지 않았으므로 간단한 페이지 상태 변수로 내비게이션을 시뮬레이션하고 있어요.\n\n이제 Docs 마이크로 프론트엔드에서는 동일한 동작이 되도록, 올바른 컴포넌트를 렌더링하기 위해 새로운 if 문을 추가할 거예요:\n\n```js\nimport {Docs} from \"@deleteman/microfrontends.docs\"\n\n if(page == \"docs\") {\n    return (\n      \u003c\u003e\n      \u003cDocs /\u003e\n        \u003cp\u003e\n          Go back \u003ca href=\"#\" className='inline' onClick={(evnt) =\u003e navTo(evnt, 'home')}\u003eHome\u003c/a\u003e\n        \u003c/p\u003e\n      \u003c/\u003e\n    )\n  }\n```\n\n\n\n다시 한 번 알고 계시든 아니면 그렇지 않든, Docs 컴포넌트를 마치 node_modules 내에 설치된 것처럼 가져오고 있어요.\n\n그리고 여기가 최종 (그리고 못생긴) 결과입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*DAkwXJnhXjDGwVvmrh_M0Q.gif)\n\n단순히 프로젝트에 2개의 마이크로 프론트엔드를 추가함으로써, 블로그와 문서 섹션을 위한 완전히 작동하는 내비게이션과 새로운 내부 링크 및 페이지를 쉽게 추가할 수 있었어요.\n\n\n\n강력한 내용이네요!\n\n## Bit에 최종 제품 푸시하기\n\n네, Bit를 사용하면 컴포넌트를 공유할 뿐만 아니라 완전한 애플리케이션도 공유할 수 있어요.\n\n이유가 뭔가요? 그것은 이들이 실제로 플랫폼에서 CI를 구성할 수 있는 능력을 제공하기 때문이에요.\n\n\n\n하지만 중요한 점은 최최 어플리케이션이 완성되면 버전을 지정하여 컴포넌트로 공유할 수 있다는 것이다. 다른 개발자들이 이를 설치하고 작업할 수 있으며, 동시에 완벽하게 작동하는 CI/CD 파이프라인을 갖게 될 것이다.\n\n가장 먼저 해야 할 일은 Bit.cloud에 가서 새 scope를 생성하는 것이다. 나는 \"test-website\"라고 이름 지었어 (네, 너무 원래 있어 보여!):\n\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_4.png)\n\n지금쯤이면 이미 어플리케이션을 설정하고 생성했을 것이다 (이 강의 전체를 통해 그렇게 했으니까), 따라서 남은 것은 버전을 지정하고 내보내는 것이다.\n\n\n\n다음 명령어를 실행해주세요:\n\n```js\nbit tag\nbit export\n```\n\n첫 번째 명령은 테스트를 실행하고 코드를 린트하며 모든 것이 예상대로 작동하는지 확인할 것입니다. 그리고 그렇게 되면 버전을 0.0.1로 만들 것입니다.\n\n마지막 명령은 두 파일을 클라우드에 업로드할 것입니다. 제 경우에는 여기에서 최종 결과를 볼 수 있습니다.\n\n\n\n\"그리고 만일 'Dependencies' 탭을 클릭하면, 앱을 만들 때 사용한 2개의 마이크로 프론트엔드를 보실 수 있습니다:\n\n![Dependencies](/assets/img/2024-05-14-HowtoReuseMicroFrontends_5.png)\n\n이제 우리의 프로젝트는 팀원들과 함께 협업할 준비가 된 상태입니다.\n\n성공!\"\n\n\n\n마이크로 프론트엔드는 환상적인 재사용성 솔루션을 제시합니다. 이미 존재하는 것을 재사용하여 복잡한 웹사이트와 애플리케이션을 만들 수 있습니다.\n\n팀은 개별적으로 이러한 구성 요소를 만들 수 있으며, 다른 사용자들은 이를 섞어서 매치할 수 있습니다. 생각해보면 레고 블록과 놀이하는 것과 매우 흡사합니다.\n\n물론, \"블록\"을 공유하고 사용하는 것은 간단하지 않습니다. 이를 발견하고 새 프로젝트에 설치하기 위한 도구가 필요합니다. 다행히도 Bit를 사용하면 컴포넌트 중심의 접근 방식으로 마이크로 프론트엔드를 쉽게 만들고 공유하고 재사용할 수 있습니다.\n\n그뿐만 아니라, 이미 존재하는 구성 요소를 확장할 수 있는 도구를 개발자들에게 제공합니다.\n\n\n\n# 또한, 기존 애플리케이션에 마이크로 프론트엔드를 생성하고 추가하는 방법에 대해 알아보세요:\n\n# 추가로 읽을 거리:","ogImage":{"url":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 47일차 - 자바스크립트 기초 마스터하기 면접 준비를 위한 포괄적인 가이드","description":"","date":"2024-05-14 15:21","slug":"2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation","content":"\n\n100일간의 자바스크립트 면접 준비: 초보자의 여정 | 코딩 라운드\n\n![이미지](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png)\n\n## 상위 10개 중요한 인터뷰 자바스크립트 코딩 라운드 인터뷰 질문\n\n## 자바스크립트에서 ARRAY의 ARRAY를 펼치는 방법?\n\n\n\n```js\nconst arry = [[1, 2, [3]], 4, [5, [6, 7]]]\n\n// 출력  [1, 2, 3, 4, 5, 6, 7]\n```\n\n답변\n\n단계 1 — flattenMyArray 함수는 배열을 입력으로 받고 각 요소를 반복합니다.\n\n단계 2 — 요소가 배열이면 해당 하위 배열을 펼치기 위해 재귀적으로 자신을 호출합니다.\n\n\n\n**단계 3** — 그렇지 않으면, 요소를 평탄화된 배열에 추가합니다.\n\n**단계 4** — 마지막으로, 평탄화된 배열을 반환합니다.\n\n# 방법 1 — (ForEach 방법)\n\n**단계 1** — 평탄화해야 할 입력 배열을 정의합니다.\n\n\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n```\n\nStep 2— `flattenArray` 함수와 결과값(펼쳐진 배열)을 저장할 빈 배열을 만듭니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n    let flattened = [];\n\n}\n```\n\nStep 3— 각 요소를 `forEach` 방법으로 반복하고 함수의 끝에 펼쳐진 값을 반환합니다.\n\n\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item =\u003e {\n     console.log(item)\n       \n   });\n\n    return flattened;\n}\n```\n\n제 4단계 — 입력 배열로 함수를 호출하고 항목에 대한 console.log를 확인합니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item =\u003e {\n     console.log(item)\n       \n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_1.png\" /\u003e\n\n\n\n\nStep 5— foreach 코드 안에 위의 console.log 관찰에 따라 몇 가지 조건을 추가해 봅시다.\n\n- 요소가 배열인 경우, 해당 하위 배열을 평탄화하도록 재귀적으로 자신을 호출합니다.\n- 그렇지 않으면, 해당 요소를 평탄화된 배열에 푸시합니다.\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]]\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item =\u003e {\n   /* 요소가 배열인 경우, 해당 하위 배열을 재귀적으로 평탄화하도록 호출합니다. */\n    if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item));\n        } else {\n   // 그렇지 않으면, 해당 요소를 평탄화된 배열에 푸시합니다\n            flattened.push(item);\n        }\n\n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\n![JavaScript Basics](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_2.png)\n\n\n\n# 최종 코드\n\n```js\nconst nestedArray = [[1, 2, [3]], 4, [5, [6, 7]]];\n\nfunction flattenArray(arr) {\n   let flattened = [];\n\n   arr.forEach(item =\u003e {\n   /* 만약 요소가 배열이라면 해당 하위 배열을 평탄화하기 위해 재귀적으로 자신을 호출합니다. */\n    if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item));\n        } else {\n   // 그렇지 않으면 요소를 평탄화된 배열에 추가합니다.\n            flattened.push(item);\n        }\n\n   });\n\n    return flattened;\n}\n\nconst flattenedArray = flattenArray(nestedArray);\n```\n\nES6 Map 방법을 사용한 또 다른 방법을 DAY 48에서 논의할 예정입니다.\n\n![JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_3.png](/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_3.png)\n\n\n\n# 행복한 코딩 하세요 그리고 기대해주세요 :)\n\n# 만약 제 블로그가 도움이 되었다면 구독, 박수와 팔로우 부탁드립니다 :)","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptDay47MasteringJavaScriptBasicsAComprehensiveGuideforInterviewPreparation_0.png","tag":["Tech"],"readingTime":4},{"title":"라라벨 8로 사용자 로그인 및 등록 화면 생성","description":"","date":"2024-05-14 15:19","slug":"2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8","content":"\n\nLaravel 8 로그인 및 회원가입 튜토리얼; 이 튜토리얼에서는 라라벨 애플리케이션에서 사용자 지정 인증 로그인 및 회원가입을 생성하는 방법에 대해 설명합니다.\n\n단계 1: 라라벨 애플리케이션 만들기\n단계 2: 데이터베이스 연결\n단계 3: 권한 부여 컨트롤러 설정\n단계 4: 권한 부여 라우트 생성\n단계 5: 권한 부여 블레이드 뷰 파일 생성\n단계 6: 라라벨 개발 서버 실행\n\n단계 1: 라라벨 애플리케이션 만들기\n\n시스템에 이미 Composer를 구성했다고 가정하고, 다음 명령을 실행하여 새 라라벨 애플리케이션을 설치합니다. 그렇지 않은 경우에는 다음 링크에서 다운로드할 수 있습니다.\n\n\n\n```js\ncomposer create-project - prefer-dist laravel/laravel_demo_app\n```\n\n그런 다음, 애플리케이션 폴더로 이동하세요:\n\n```js\ncd laravel_demo_app\n```\n\n단계 2: 데이터베이스에 연결하기\n\n\n\n이제 Laravel 애플리케이션을 데이터베이스에 연결하기 위해 .env 구성 파일에 데이터베이스 이름, 사용자 이름 및 비밀번호를 추가해야 합니다:\n\n```js\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=데이터베이스_이름\nDB_USERNAME=데이터베이스_사용자_이름\nDB_PASSWORD=데이터베이스_비밀번호\n```\n\nLaravel 애플리케이션에는 기본 User 모델과 마이그레이션 파일이 함께 제공됩니다. 데이터베이스에 새 테이블을 만들기 위해 다음 명령을 실행해야 합니다. 따라서 터미널로 이동하여 다음 명령을 실행하세요.\n\n```js\nphp artisan migrate\n```\n\n\n\n3단계: 인가 컨트롤러 설정하기\n\n다음으로, 제안된 명령을 명령 프롬프트에 작성하고 새로운 컨트롤러 파일인 CustomAuthController를 생성하는 명령을 실행하세요.\n\n```js\nphp artisan make:controller CustomAuthController\n```\n\n그런 다음 파일을 열어주세요.\n\n\n\n```plaintext\n`app\\Http\\Controllers\\CustomAuthController.php` 에 위 코드를 주의 깊게 넣어주세요.\n\n\u003c?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Hash;\nuse Session;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass CustomAuthController extends Controller\n{\n\n    public function index()\n    {\n        return view('auth.login');\n    }\n\n    public function customLogin(Request $request)\n    {\n       $validator =  $request-\u003evalidate([\n            'email' =\u003e 'required',\n            'password' =\u003e 'required',\n        ]);\n   \n    \n        $credentials = $request-\u003eonly('email', 'password');\n        if (Auth::attempt($credentials)) {\n            return redirect()-\u003eintended('dashboard')\n                        -\u003ewithSuccess('Signed in');\n        }\n        $validator['emailPassword'] = '이메일 주소 또는 비밀번호가 올바르지 않습니다.';\n        return redirect(\"login\")-\u003ewithErrors($validator);\n    }\n\n\n\n    public function registration()\n    {\n        return view('auth.registration');\n    }\n\n    public function customRegistration(Request $request)\n    {  \n        $request-\u003evalidate([\n            'name' =\u003e 'required',\n            'email' =\u003e 'required|email|unique:users',\n            'password' =\u003e 'required|min:6',\n        ]);\n           \n        $data = $request-\u003eall();\n        $check = $this-\u003ecreate($data);\n         \n        return redirect(\"dashboard\")-\u003ewithSuccess('가입이 완료되었습니다');\n    }\n\n\n    public function create(array $data)\n    {\n      return User::create([\n        'name' =\u003e $data['name'],\n        'email' =\u003e $data['email'],\n        'password' =\u003e Hash::make($data['password'])\n      ]);\n    }\n\n    public function dashboard()\n    {\n        if(Auth::check()){\n            return view('dashboard');\n        }\n  \n        return redirect(\"login\")-\u003ewithSuccess('접근 권한이 없습니다');\n    }\n\n    public function signOut() {\n        Session::flush();\n        Auth::logout();\n  \n        return Redirect('login');\n    }\n}\n\nStep 4: 권한 부여 라우트 생성\n\n\n\n\n이 단계에서는 라라벨 애플리케이션에서 사용자 정의 인증을 처리하기 위해 POST 및 GET 방식으로 경로를 생성하는 방법을 설명합니다. route/web.php 파일을 열고 다음 코드를 추가하세요.\n\n\u003c?php\n\nuse Illuminate\\Support\\Facades\\Route;\nuse App\\Http\\Controllers\\CustomAuthController;\n\n/*\n|--------------------------------------------------------------------------\n| Web Routes\n|--------------------------------------------------------------------------\n*/\n\nRoute::get('dashboard', [CustomAuthController::class, 'dashboard']); \nRoute::get('login', [CustomAuthController::class, 'index'])-\u003ename('login');\nRoute::post('custom-login', [CustomAuthController::class, 'customLogin'])-\u003ename('login.custom'); \nRoute::get('registration', [CustomAuthController::class, 'registration'])-\u003ename('register-user');\nRoute::post('custom-registration', [CustomAuthController::class, 'customRegistration'])-\u003ename('register.custom'); \nRoute::get('signout', [CustomAuthController::class, 'signOut'])-\u003ename('signout');\n\n단계 5: Auth Blade View 파일 생성\n\nResources/views/ 폴더 내에서 auth 폴더를 생성하고 그 안에 new login.blade.php 파일을 만들어 이 파일에 다음 코드를 넣어주세요.\n\n\n\n\u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e\n\u003cmain class=\"login-form\"\u003e\n    \u003cdiv class=\"cotainer\"\u003e\n        \u003cdiv class=\"row justify-content-center\"\u003e\n            \u003cdiv class=\"col-md-4\"\u003e\n                \u003cdiv class=\"card\"\u003e\n                    \u003ch3 class=\"card-header text-center\"\u003e로그인\u003c/h3\u003e\n                    \u003cdiv class=\"card-body\"\u003e\n                        \u003cform method=\"POST\" action=\"{ route('login.custom') }\"\u003e\n                            @csrf\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cinput type=\"text\" placeholder=\"이메일\" id=\"email\" class=\"form-control\" name=\"email\" required autofocus\u003e\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cinput type=\"password\" placeholder=\"비밀번호\" id=\"password\" class=\"form-control\" name=\"password\" required\u003e\n                                @if ($errors-\u003ehas('emailPassword'))\n                                \u003cspan class=\"text-danger\"\u003e{ $errors-\u003efirst('emailPassword') }\u003c/span\u003e\n                                @endif\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cdiv class=\"checkbox\"\u003e\n                                    \u003clabel\u003e\n                                        \u003cinput type=\"checkbox\" name=\"remember\"\u003e 기억하기\n                                    \u003c/label\u003e\n                                \u003c/div\u003e\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"d-grid mx-auto\"\u003e\n                                \u003cbutton type=\"submit\" class=\"btn btn-dark btn-block\"\u003e로그인\u003c/button\u003e\n                            \u003c/div\u003e\n                        \u003c/form\u003e\n\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\u003c/main\u003e\n\nResources/views/auth 폴더로 이동하여 비슷하게 registration.blade.php 파일을 만들고, 이 파일에 다음 코드를 추가해주세요:\n\n\u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e\n\n\u003cmain class=\"signup-form\"\u003e\n    \u003cdiv class=\"cotainer\"\u003e\n        \u003cdiv class=\"row justify-content-center\"\u003e\n            \u003cdiv class=\"col-md-4\"\u003e\n                \u003cdiv class=\"card\"\u003e\n                    \u003ch3 class=\"card-header text-center\"\u003e사용자 등록\u003c/h3\u003e\n                    \u003cdiv class=\"card-body\"\u003e\n\n                        \u003cform action=\"{ route('register.custom') }\" method=\"POST\"\u003e\n                            @csrf\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cinput type=\"text\" placeholder=\"이름\" id=\"name\" class=\"form-control\" name=\"name\"\n                                    required autofocus\u003e\n                                @if ($errors-\u003ehas('name'))\n                                \u003cspan class=\"text-danger\"\u003e{ $errors-\u003efirst('name') }\u003c/span\u003e\n                                @endif\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cinput type=\"text\" placeholder=\"이메일\" id=\"email_address\" class=\"form-control\"\n                                    name=\"email\" required autofocus\u003e\n                                @if ($errors-\u003ehas('email'))\n                                \u003cspan class=\"text-danger\"\u003e{ $errors-\u003efirst('email') }\u003c/span\u003e\n                                @endif\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cinput type=\"password\" placeholder=\"비밀번호\" id=\"password\" class=\"form-control\"\n                                    name=\"password\" required\u003e\n                                @if ($errors-\u003ehas('password'))\n                                \u003cspan class=\"text-danger\"\u003e{ $errors-\u003efirst('password') }\u003c/span\u003e\n                                @endif\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"form-group mb-3\"\u003e\n                                \u003cdiv class=\"checkbox\"\u003e\n                                    \u003clabel\u003e\u003cinput type=\"checkbox\" name=\"remember\"\u003e 기억하기\u003c/label\u003e\n                                \u003c/div\u003e\n                            \u003c/div\u003e\n\n                            \u003cdiv class=\"d-grid mx-auto\"\u003e\n                                \u003cbutton type=\"submit\" class=\"btn btn-dark btn-block\"\u003e가입하기\u003c/button\u003e\n                            \u003c/div\u003e\n                        \u003c/form\u003e\n\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/div\u003e\n\u003c/main\u003e\n\nResources/views/ 폴더로 이동하여 새로운 dashboard.blade.php 파일을 만들고, 이 파일에 다음 코드를 추가해주세요:\n\n\n\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003e라라벨에서 사용자 지정 인증\u003c/title\u003e\n    \u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n\n    \u003cnav class=\"navbar navbar-light navbar-expand-lg mb-5\" style=\"background-color: #e3f2fd;\"\u003e\n        \u003cdiv class=\"container\"\u003e\n            \u003ca class=\"navbar-brand mr-auto\" href=\"#\"\u003e코드사전\u003c/a\u003e\n            \u003cbutton class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarNav\"\n                aria-controls=\"navbarNav\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"\u003e\n                \u003cspan class=\"navbar-toggler-icon\"\u003e\u003c/span\u003e\n            \u003c/button\u003e\n            \u003cdiv class=\"collapse navbar-collapse\" id=\"navbarNav\"\u003e\n                \u003cul class=\"navbar-nav\"\u003e\n                    @guest\n                    \u003cli class=\"nav-item\"\u003e\n                        \u003ca class=\"nav-link\" href=\"{ route('login') }\"\u003e로그인\u003c/a\u003e\n                    \u003c/li\u003e\n                    \u003cli class=\"nav-item\"\u003e\n                        \u003ca class=\"nav-link\" href=\"{ route('register-user') }\"\u003e가입하기\u003c/a\u003e\n                    \u003c/li\u003e\n                    @else\n                    \u003cli class=\"nav-item\"\u003e\n                        \u003ca class=\"nav-link\" href=\"{ route('signout') }\"\u003e로그아웃\u003c/a\u003e\n                    \u003c/li\u003e\n                    @endguest\n                \u003c/ul\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    \u003c/nav\u003e\n\n\u003c/body\u003e\n\n\u003c/html\u003e\n\n단계 6: 라라벨 서버 실행하기\n\n마지막으로, 브라우저에서 애플리케이션을 시작할 수 있도록 라라벨 개발 서버를 실행해야 합니다. 명령 프롬프트를 통해 다음 명령어를 실행해 주세요.\n\nphp artisan serve\n\n\n\n브라우저 주소창에 다음 URL을 추가하고 애플리케이션을 테스트해보세요.\n\nhttp://127.0.0.1:8000/login\nhttp://127.0.0.1:8000/registration\n\n소스 코드\n\n![이미지](/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png)","ogImage":{"url":"/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png"},"coverImage":"/assets/img/2024-05-14-CreationofuserloginandregistrationscreenswithLaravel8_0.png","tag":["Tech"],"readingTime":11},{"title":"당신만의 개인 복사 편집기 LangChainjs와 일렉트론을 이용해 LLM 지원 앱 만들기","description":"","date":"2024-05-14 15:17","slug":"2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron","content":"\n\n![이미지](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png)\n\n자바스크립트를 사용하여 LLM을 백엔드로 지원하는 앱을 작성한다니, 미친 생각일 수도 있죠? 사실 LangChain과 같은 외부 API와 라이브러리에 크게 의존하는 앱에는 파이썬 대신 자바스크립트를 사용하는 것이 혜택이 있습니다. 기존의 웹 앱 모델에서는 HTML/CSS/JS 프론트엔드와 원하는 서버 측 언어를 사용한 백엔드를 개발해야 합니다. 그러나 LangChain과 js-tiktoken과 같은 LLM을 다루는 자바스크립트 라이브러리들이 등장하면서, 이제는 백엔드 계층 없이 AI 기능이 탑재된 앱을 만들 수 있습니다.\n\n객관적으로 말하자면, 완전한 클라이언트 측 접근 방식을 선택하면 기능이 제한될 수 있습니다. 하지만 완전한 클라이언트 측 응용프로그램을 견고한 Electron 데스크톱 프레임워크와 결합하면, 이러한 제약이 많이 해결됩니다. Electron을 사용하면 프론트엔드 웹 앱을 크로스 플랫폼 데스크톱 앱으로 패키징할 수 있고, 여러 플랫폼의 앱 스토어에 배포할 수 있습니다.\n\n일반적으로 웹 앱에서 기대되는 계정 관리와 같은 기능들은 데스크톱 공간에서 선택사항이 됩니다. 게다가 호스트 운영 체제와 상호 작용하는 네이티브 플러그인에 액세스할 수 있어, 일반적인 웹 앱의 한계를 벗어나 앱을 확장할 수 있습니다.\n\n\n\n이 기사에서는 LLM을 백업하는 응용 프로그램의 자바스크립트 POC(Concept(POC)) 구현물을 포괄적인 데스크톱 경험으로 전환하는 과정을 살펴볼 것입니다. 이 기사에서 논의된 코드는 오픈 소스이며 MIT 라이선스에 따라 라이선스가 부여되었으므로 자유롭게 사용하거나 더 나아가 포크하고 개선 또는 향상시킬 수 있습니다.\n\n이 아이디어가 발생한 것은 ChatGPT에 기사를 수동으로 복사하고 붙여넣기 하는 것에 지쳤을 때였습니다. Python에서 LangChain을 사용해본 경험이 있었기 때문에 간단한 단일 페이지 React 앱을 만들어 보았습니다. 이 앱은 입력된 텍스트를 가져와 JS로 LangChain을 통해 처리하고 편집된 텍스트를 반환할 수 있는 앱이었습니다. LangChain의 API는 Python 및 JavaScript 구현 간에 매우 유사하여 한 언어에 익숙한 사람이 다른 언어를 탐색하기 쉽습니다. 흥미로운 점은 LangChain 코드가 POC의 가장 쉬운 부분이었습니다. 아래에 LLM 상호작용을 위한 코드가 제공되었습니다.\n\n```js\nconst openAIApiKey = process.env.REACT_APP_OPENAI_API_KEY;\nconst modelName =  \"gpt-4\";\nconst enc = encodingForModel(modelName);\nconst chunk_token_size = 1000;\nconst llm = new ChatOpenAI({modelName: modelName, temperature: 0, openAIApiKey: openAIApiKey});\nconst promptTemplate = ChatPromptTemplate.fromPromptMessages([\n    SystemMessagePromptTemplate.fromTemplate(\n      \"You are an expert copy editor. It is your task to take a piece of an article and proof-read it for grammar and style. Provide a rewritten copy of the article portion back to the human.\"\n    ),\n    HumanMessagePromptTemplate.fromTemplate(\"{input}\")\n  ])\nconst chain = new ConversationChain({prompt: promptTemplate, llm: llm});\n\n...\n\nconst openAICalls = chunks.map((chunk, idx) =\u003e chain.call({input: chunk}));\n```\n\n그 다음으로, 나는 사용자 정의 텍스트 청크 알고리즘을 개발했습니다. 문단 중간에 텍스트를 분할하는 것을 피하고 싶었기 때문에 내장된 분할 방법을 활용하여 새 줄을 기준으로 텍스트를 분할했습니다. 이는 문단을 분할하는 대략적인 근사치지만 merseured 분할을 위해 spaCy나 NLTK와 같은 도구에 액세스할 수 없었기 때문에 최선의 선택이었습니다. 그런 다음 분할된 각 문자열을 검토하고 js-tiktoken을 사용하여 토큰 카운트를 계산했습니다. 이 카운트는 분할을 최대 토큰 수로 결합하는 데 사용되었습니다. 이 방법을 통해 문단을 분할하지 않으면서 LLMChain에 개별 호출할 수 있었으며 나중에 완전히 편집된 텍스트로 재조립할 수 있었습니다.\n\n\n\n지금까지 총 24시간 동안 자바스크립트 코드를 약 250줄 작성하여 POC를 완성했습니다. 최신 미디엄 기사를 사이트에 붙여넣고 한 번의 버튼 클릭으로 교정된 복사본을 받았을 때, 공유할 가치가 있는 것이 느껴졌어요.\n\n운이 좋게도 제게는 미디엄에 글을 쓰는 친구들이 있어요. 제 간단한 POC를 그들과 공유했는데, 그들은 흥미로워 했어요! 하지만 리액트 코드베이스를 다운로드하고 종속성을 설치하고 적절한 환경 변수로 실행하는 기술적 전문성이 부족했어요. 자체 호스팅 웹 앱보다 더 사용하기 쉬운 제품이 필요했죠.\n\nAI를 기반으로 한 제품을 개발할 때, 초기에 사용자당 비용을 고려하는 게 중요해요. AI 앱에 대한 인기 있는 모델인 소프트웨어 서비스(SaaS)는 사용자 계정을 쉽게 활용할 수 있어서 AI 앱의 경우 효율적이에요. 게다가 사용자가 지불한 것만 액세스 할 수 있도록 보장하는 것도 간단해요. 하지만, 구독의 단점 중 하나는 많은 사용자들이 매달 새로운 앱을 구매해야 할 때 느끼는 피로감이에요.\n\n이 문제를 회피하기 위해 사용자들로부터 자신의 OpenAI API 키를 제공해 달라고 결정했어요. 이 방식이 NextCloud와 같은 다른 오픈 소스 프로젝트에서 성공적으로 작동하고 있다는 것을 봤어요. 이러면 사용자의 AI 사용에 대한 지불을 피할 수 있어요. 또한 API는 사용량에 따라 지불하는 방식으로 운영되어 사용자들이 많은 AI 기반 웹 앱들에서 요구되는 가짜 돈 토큰을 구매할 필요가 없어지는 소비자를 위한 움직임이에요.\n\n\n\n내 다른 동료 Medium 작가들이 이 앱을 사업으로 전환하는 기회를 왜 잡지 않았느냐고 의문을 제기했습니다. 컨셉은 탄탄하고 효과적했는데, 왜 나만의 사장이 되지 않았느냐고요? 제 다소 부끄러운 대답은 비즈니스보다 오픈 소스 프로젝트를 관리하는 것이 더 낫다고 느끼기 때문이라고 했습니다. 하지만 이것이 전부가 아니에요. 더 나아가 사용자들이 매월 구독을 해야 하는 것 없이 강력한 AI 작성 능력에 접근할 수 있는 도구를 제공하기를 목표로 했습니다. 2008년 이후로 오픈 소스 소프트웨어의 능동적인 사용자로서, 개인이나 소규모 그룹이 중요한 영향력을 행사하기 위한 최상의 방법이라고 단정했습니다.\n\n비즈니스 고려는 뒷전으로, 지금은 이 POC를 완전한 OSS 데스크탑 앱으로 발전시키는 방법에 대해 생각할 때입니다. 주로 백엔드 Python 코드를 작성하거나 가끔 JavaScript로 웹 앱을 만드는 개발자로서 Electron은 자연스러운 선택이었습니다. 익숙한 웹 기술로 작업할 수 있을 뿐만 아니라, 리눅스를 포함한 주요 플랫폼에 쉽게 배포할 수 있도록 도와줍니다.\n\n조사를 한 결과, Electron 앱을 만드는 방법이 웹 앱을 만드는 방법만큼 다양하다는 것을 빨리 깨달았습니다. POC는 React와 Material UI 컴포넌트를 사용하여 작성되어 있어서, Electron을 사용하기로 선택한 솔루션에서 계속 사용할 수 있는지가 중요했습니다. 몇 가지 다른 옵션을 테스트한 후, Electron과 React를 사용하여 빌드하기 위한 최상의 해결책은 Electron-React-Boilerplate임을 자신 있게 말할 수 있습니다.\n\n이 프로젝트는 포괄적인 기본 GitHub 저장소를 제공합니다. 추가 개발을 위해 준비된 간단한 웹 앱뿐만 아니라, 각 지원 OS에 대한 코드베이스 테스트를 위한 GitHub Actions, 결과 이진 파일을 빌드하고 게시하는 GitHub 릴리스, 코드 취약점을 스캔하는 등이 포함되어 있습니다. 개발적인 측면에서, 종속성을 설치한 후 npm start 명령어 하나로 프로젝트를 실행시킬 수 있습니다. Electron-React-Boilerplate를 사용하면 훌륭하게 구성된, 견해가 명확한 설정을 채택하고 내 앱을 구축하는 데 집중할 수 있습니다.\n\n\n\n다음 단계는 모든 하드 코딩된 매개변수를 React 상태로 변환하여 나중에 설정 패널에 포함할 것입니다. 이에는 이전에 환경 변수를 사용하여 웹 앱으로 전달했던 OpenAI API 키도 포함됩니다. 나는 사용자들이 혼란스러워하지 않도록 설정을 \"일반\"과 \"고급\"으로 분류하기로 결정했습니다. 참고용으로 아래 스크린샷을 확인해주세요.\n\n![이미지](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_1.png)\n\n기본 설정이 정해지면, 나의 초점은 코딩에서 프로젝트의 다른 측면으로 옮겼습니다. 첫 번째 작업은 앱 로고를 만드는 것이었습니다. 예술가는 아니지만, 빠르게 DALL-E에게 로고를 생성하도록 요청하는 OpenAI API 키가 있었기 때문에 로고를 만들었습니다. 그 후 간단한 README를 작성하고 새 로고를 저장소에 추가했습니다.\n\n추가 조정을 통해, 내 POC(Concept화된 개념)를 베타 품질의 데스크탑 앱으로 성공적으로 변형했습니다. 간단한 아이디어를 가져와 사용 가능한 제품으로 발전시켰습니다. POC(Proof of Concept)를 제품으로 발전하는 과정은 절대적으로 간단하지 않지만, 적절한 도구를 갖추면 프로세스를 크게 용이하게 할 수 있습니다. 만약 Python과 JavaScript로 오픈 소스 프로젝트에 작업을 한다면, 유지해야 하는 코드 베이스 수가 두 배로 증가하고 웹 앱을 자체 호스팅하려는 사람들로만 구성되는 대상으로 제한될 것입니다. 그러나 Electron을 이용하면 사람들이 쉽게 다운로드하고 사용할 수 있는 앱을 만들고 배포할 수 있었습니다.\n\n\n\n![사진](/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_2.png)\n\n내가 만든 프로젝트는 \"편집장(Editor in Chief)\"입니다. 많은 사람들에게 정말 유용할 수 있는 잠재력이 있다고 생각해요.\n\n다음 수준으로 나아가는 데 도와주고 싶으세요? 사용해보고 버그 보고서를 제출하고 코드 및 문서를 기여하세요. 어떤 방식으로 상호 작용하든 상관없어요. 꼭 당신을 환영할 거예요.\n\nGPT-4를 활용한 기사 편집과 인공지능 기술을 활용한 작성을 위한 FOSS 솔루션인 '편집장(Editor in Chief)'을 이용해보세요.","ogImage":{"url":"/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png"},"coverImage":"/assets/img/2024-05-14-YourPersonalCopyEditorBuildaLLM-backedAppUsingLangChainjsandElectron_0.png","tag":["Tech"],"readingTime":6},{"title":"전문 개발자를 위한 18가지 고급 JavaScript 기술","description":"","date":"2024-05-14 15:16","slug":"2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png\" /\u003e\n\n# 브라우저\n\n# 전체 화면 달성하기 🖥️\n\n현재 화면을 전체 화면으로 표시해야 할 때\n\n\n\n\n# 전체 화면으로 변환하기 ✨\n\n```js\nfunction fullScreen() {  \n    const el = document.documentElement\n    const rfs = \n    el.requestFullScreen || \n    el.webkitRequestFullScreen || \n    el.mozRequestFullScreen || \n    el.msRequestFullscreen\n    if(typeof rfs != \"undefined\" \u0026\u0026 rfs) {\n        rfs.call(el)\n    }\n}\n// 클릭하여 🌐 전체 화면으로 전환하기!\nfullScreen()\n```\n\n# 전체 화면 나가기 🏁\n\n전체 화면을 나가려면\n\n```js\nfunction exitScreen() {\n    if (document.exitFullscreen) { \n        document.exitFullscreen()\n    } \n    else if (document.mozCancelFullScreen) { \n        document.mozCancelFullScreen()\n    } \n    else if (document.webkitCancelFullScreen) { \n        document.webkitCancelFullScreen()\n    } \n    else if (document.msExitFullscreen) { \n        document.msExitFullscreen()\n    } \n    if(typeof cfs != \"undefined\" \u0026\u0026 cfs) {\n        cfs.call(el)\n    }\n    // 전체 화면에서 나가기 🚪🏃\n}\nexitScreen()\n```\n\n\n\n# 페이지 인쇄 🖨️\n\n현재 페이지를 인쇄해야 할 때\n\n```js\n// 페이지를 인쇄하려면 클릭 🖨️\nwindow.print()\n```\n\n# 인쇄 내용 스타일 변경 📄\n\n\n\n현재 페이지를 인쇄하려면서 레이아웃을 수정해야 할 때\n\n```js\n\u003cstyle\u003e\n/* 인쇄 레이아웃 조정 🔧 */\n@media print {\n    .noprint {\n        display: none;\n    }\n}\n\u003c/style\u003e\n\u003cdiv class=\"print\"\u003e인쇄\u003c/div\u003e\n\u003cdiv class=\"noprint\"\u003e인쇄 안 함\u003c/div\u003e\n```\n\n# 차단 닫기 이벤트 🔒\n\n사용자가 새로 고침하거나 브라우저를 닫는 것을 막아야 할 때, beforeunload 이벤트를 트리거하도록 선택할 수 있습니다. 일부 브라우저에서는 텍스트 내용을 사용자 지정할 수 없습니다.\n\n\n\n\n```js\nwindow.onbeforeunload = function(){\n    return 'haorooms 블로그를 나가시겠습니까? 🚪🤔';\n};\n```\n\n# 화면 녹화 📹\n\n현재 화면을 녹화하고 녹화된 화면을 업로드 또는 다운로드해야 할 때\n\n```js\n// 이곳에서 화면 녹화하기 🎬\nconst streamPromise = navigator.mediaDevices.getDisplayMedia()\nstreamPromise.then(stream =\u003e {\n    var recordedChunks = [];// 녹화된 비디오 데이터\n    var options = { mimeType: \"video/webm; codecs=vp9\" };// 인코딩 형식 설정\n    var mediaRecorder = new MediaRecorder(stream, options);// MediaRecorder 인스턴스 초기화\n    mediaRecorder.ondataavailable = handleDataAvailable;// 데이터가 사용 가능한 경우 콜백 설정 (화면 녹화 종료)\n    mediaRecorder.start();\n    // 비디오 조각화\n    function handleDataAvailable(event) {\n        if (event.data.size \u003e 0) {\n            recordedChunks.push(event.data);// 데이터 추가, event.data는 BLOB 객체\n            download();// BLOB 객체로 래핑하여 다운로드\n        }\n    }\n    // 파일 다운로드\n    function download() {\n        var blob = new Blob(recordedChunks, {\n            type: \"video/webm\"\n        });\n        // 여기서 비디오를 백엔드로 업로드할 수 있음\n        var url = URL.createObjectURL(blob);\n        var a = document.createElement(\"a\");\n        document.body.appendChild(a);\n        a.style = \"display: none\";\n        a.href = url;\n        a.download = \"test.webm\";\n        a.click();\n        window.URL.revokeObjectURL(url);\n    }\n})\n```\n\n\n\n# 가로 및 세로 화면 판단하기 🔄\n\n모바일 전화기의 가로 또는 세로 화면 상태를 판단해야 할 때\n\n```js\nfunction hengshuping() {\n    if (window.orientation == 180 || window.orientation == 0) {\n        alert(\"세로 모드! 📱\");\n    }\n    if (window.orientation == 90 || window.orientation == -90) {\n        alert(\"가로 모드! 🌅\");\n    }\n}\n// 화면 방향 변경을 위한 리스너 추가 🔄\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", hengshuping, false);\n```\n\n# 가로 및 세로 화면 스타일 변경하기 ↔️\n\n\n\n다양한 스타일을 수평 및 수직 화면에 대해 설정해야 할 때\n\n```js\n\u003cstyle\u003e\n@media all and (orientation : landscape) {\n    body {\n        background-color: #ff0000;\n    }\n}\n@media all and (orientation : portrait) {\n    body {\n        background-color: #00ff00;\n    }\n}\n\u003c/style\u003e\n```\n\n# 탭 페이지가 숨김 처리됨 🙈\n\n탭이 표시되거나 숨겨지는 이벤트를 모니터링해야 할 때\n\n\n\n```js\n// 탭 페이지 숨김 🙈\nconst {hidden, visibilityChange} = (() =\u003e {\n    let hidden, visibilityChange;\n    if (typeof document.hidden !== \"undefined\") {\n      // Opera 12.10 및 Firefox 18 이후 지원\n      hidden = \"hidden\";\n      visibilityChange = \"visibilitychange\";\n    } else if (typeof document.msHidden !== \"undefined\") {\n      hidden = \"msHidden\";\n      visibilityChange = \"msvisibilitychange\";\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      hidden = \"webkitHidden\";\n      visibilityChange = \"webkitvisibilitychange\";\n    }\n    return {\n      hidden,\n      visibilityChange\n    }\n})();\n\nconst handleVisibilityChange = () =\u003e {\n    console.log(\"현재 숨겨진 상태\", document[hidden]);\n};\ndocument.addEventListener(\n    visibilityChange,\n    handleVisibilityChange,\n    false\n);\n```\n\n# 이미지\n\n# 로컬 이미지 미리보기 🌄\n\n클라이언트로부터 이미지를 받았지만 즉시 서버에 업로드할 수 없고 미리보기해야 하는 경우\n\n\n\n\n```js\n\u003c!-- 이미지 업로드 및 미리보기 📸 --\u003e\n\u003cdiv class=\"test\"\u003e\n    \u003cinput type=\"file\" name=\"\" id=\"\"\u003e\n    \u003cimg src=\"\" alt=\"\"\u003e\n\u003c/div\u003e\n\u003cscript\u003e\nconst getObjectURL = (file) =\u003e {\n    let url = null;\n    if (window.createObjectURL != undefined) { // basic\n        url = window.createObjectURL(file);\n    } else if (window.URL != undefined) { // webkit or chrome\n        url = window.URL.createObjectURL(file);\n    } else if (window.URL != undefined) { // mozilla(firefox)\n        url = window.URL.createObjectURL(file);\n    }\n    return url;\n}\ndocument.querySelector('input').addEventListener('change', (event) =\u003e {\n    document.querySelector('img').src = getObjectURL(event.target.files[0])\n})\n\u003c/script\u003e\n```\n\n# 이미지 미리로딩 🔄\n\n사진이 많을 때는 화면이 하얗게 보이지 않도록 사진을 미리로딩해야 합니다.\n\n```js\nconst images = []\nfunction preloader(args) {\n    for (let i = 0, len = args.length; i \u003c len; i++) {  \n        images[i] = new Image()  \n        images[i].src = args[i]\n    } \n}  \npreloader(['1.png', '2.jpg'])\n```\n\n\n\n# Js\n\n# 문자열 스크립트 💬\n\n문자열을 js 스크립트로 변환해야 할 때는 이 방법이 xss 취약점이 있으니 주의해서 사용해야 합니다\n\n```js\nconst obj = eval('({ name: \"jack\" })')\n// obj는 object{ name: \"jack\" }로 변환됩니다\nconst v = eval('obj')\n// v는 변수 obj가 됩니다\n```\n\n\n\n# 재귀 함수 이름 분리하기 🔗\n\n재귀 함수를 작성할 때 함수 이름을 선언하지만 함수 이름을 수정할 때마다 내부 함수 이름을 수정하는 것을 항상 잊어버립니다. argument는 함수의 내부 객체로, 함수에 전달된 모든 매개변수를 포함하며 arguments.callee는 함수 이름을 나타냅니다.\n\n```js\n// 이것은 기본 피보나치 수열입니다\nfunction fibonacci (n) {\n    const fn = arguments.callee\n    if (n \u003c= 1) return 1\n    return fn(n - 1) + fn(n - 2)\n}\n```\n\n\n\n# 암묵적 판단 👁️‍🗨️\n\n페이지 뷰에 현재 DOM 요소가 나타나 있는지 판단해야 할 때 IntersectionObserver를 사용해보세요.\n\n```js\n\u003cstyle\u003e\n.item {\n    height: 350px;\n}\n\u003c/style\u003e\n\n\u003cdiv class=\"container\"\u003e\n  \u003cdiv class=\"item\" data-id=\"1\"\u003e보이지 않음\u003c/div\u003e\n  \u003cdiv class=\"item\" data-id=\"2\"\u003e보이지 않음\u003c/div\u003e\n  \u003cdiv class=\"item\" data-id=\"3\"\u003e보이지 않음\u003c/div\u003e\n\u003c/div\u003e\n\u003cscript\u003e\n  if (window?.IntersectionObserver) {\n    let items = [...document.getElementsByClassName(\"item\")]; // 진정한 배열로 변환하여 파싱, Array.prototype.slice.call()도 사용 가능\nlet io = new IntersectionObserver(\n      (entries) =\u003e {\n        entries.forEach((item) =\u003e {\n          item.target.innerHTML =\n            item.intersectionRatio === 1 // 요소의 표시 비율, 1이면 완전히 보이고 0이면 완전히 보이지 않음\n              ? `요소가 완전히 보입니다`\n              : `요소가 부분적으로 보이지 않습니다`;\n        });\n      },\n      {\n        root: null,\n        rootMargin: \"0px 0px\",\n        threshold: 1, // 임계값을 1로 설정하고, 비율이 1에 도달할 때만 콜백 함수가 트리거됨\n      }\n    );\n    items.forEach((item) =\u003e io.observe(item));\n  }\n\u003c/script\u003e\n```\n\n# 편집 가능 요소 ✏️\n\n\n\nDOM 요소를 편집해야 할 때, 텍스트 영역처럼 클릭하세요.\n\n```js\n\u003cdiv contenteditable=\"true\"\u003e여기를 편집할 수 있어요\u003c/div\u003e\n```\n\n# 요소 속성 감시하기 👀\n\n```js\n\u003cdiv id=\"test\"\u003e테스트\u003c/div\u003e\n\u003cbutton onclick=\"handleClick()\"\u003e확인\u003c/button\u003e\n\n\u003cscript\u003e\n  const el = document.getElementById(\"test\");\n  let n = 1;\n  const observe = new MutationObserver((mutations) =\u003e {\n    console.log(\"속성이 변경되었어요\", mutations);\n  })\n  observe.observe(el, {\n    attributes: true\n  });\n  function handleClick() {\n    el.setAttribute(\"style\", \"color: red\");\n    el.setAttribute(\"data-name\", n++);\n  }\n  setTimeout(() =\u003e {\n    observe.disconnect(); // 감시 중지\n  }, 5000);\n\u003c/script\u003e\n```\n\n\n\n# DOM 요소 출력하기 🖨️\n\n개발 과정에서 DOM 요소를 출력해야 할 때, console.log을 사용하면 종종 전체 DOM 요소만 출력되고 내부 속성을 볼 수 없습니다. console.dir을 사용해보세요.\n\n```js\nconsole.dir(document.body)\n```\n\n# 기타\n\n\n\n# 어플리케이션 활성화하기 🚀\n\n모바일 측면에서 개발할 때, 다른 애플리케이션을 열어야 할 때가 있어요. 아래 방법들은 location.href 할당을 통해서도 작동할 수 있어요.\n\n```js\n\u003c!-- 다음 링크들을 사용해서 폰 기능을 활성화해보세요 📲 --\u003e\n\u003ca href=\"tel:12345678910\"\u003e전화 걸기\u003c/a\u003e\n\u003ca href=\"sms:12345678910,12345678911?body=안녕하세요\"\u003e안드로이드 메시지\u003c/a\u003e \n\u003ca href=\"sms:/open?addresses=12345678910,12345678911\u0026body=안녕하세요\"\u003eiOS 메시지\u003c/a\u003e\n\u003ca href=\"wx://\"\u003eiOS 메시지\u003c/a\u003e\n```\n\n# 쉬운 용어로 설명 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수치고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png"},"coverImage":"/assets/img/2024-05-14-18AdvancedJavaScriptTechniquesforExpertDevelopers_0.png","tag":["Tech"],"readingTime":9},{"title":"API 응답에 TypeScript 유형을 올바르게 사용하는 방법","description":"","date":"2024-05-14 15:14","slug":"2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse","content":"\n\n## JSON 응답을 받을 때 올바른 타입을 보장받을 수 없습니다. 물론 형 변환을 수행하고 모든 것이 괜찮다고 가정할 수 있지만, 이 상황에서 정말로 타입 안전한 방법을 알고 계신가요?\n\n![How to correctly use TypeScript types for your API response](/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png)\n\n조금 더 일반적인 주제부터 시작해봅시다. 우리는 어떻게 타입을 확인할 수 있을까요? 두 가지 접근 방식이 있습니다. 정적으로 타입을 확인할 수 있습니다(컴파일 시간, 정적 분석기) 또는 런타임에서 확인할 수 있습니다.\n\n정적 타입 확인은 우리가 미리 데이터를 알고 있다는 경우에는 충분히 강력합니다. 그러나 대부분의 상황에서는 해당되지 않습니다. 데이터는 대개 API, 파일 또는 사용자 입력과 같은 소스에서 가져옵니다. 이러한 소스의 인터페이스는 문자열을 반환하며, 우리의 책임은 그것을 우리 프로그램에서 기대하는 형태로 파싱하는 것입니다.\n\n\n\n100% 유형 안전성을 위해 실행 시 데이터를 분석해야 합니다. 대부분의 유형 안전성 언어는 정적 유형 확인을 실행 시 확인과 결합합니다. 하지만 TypeScript의 경우는 어떨까요?\n\nTypeScript는 컴파일 시에만 유형을 확인합니다. JavaScritp로 컴파일된 후에는 유형에 대한 정보가 남지 않으므로 우리가 동적 데이터(예: API 응답)가 가정한 형식을 실제로 갖고 있는지 확신할 수 없습니다.\n\n# 예시 시간\n\n이러한 동작을 설명하는 가장 좋은 방법은 예시를 통해 보여주는 것입니다. 다음 예시는 API에서 데이터를 가져오는 일반적인 상황을 보여줍니다.\n\n\n\n우리가 처음에 마주한 문제는 코드 완성 기능의 부재였습니다. TypeScript를 사용하고 있기 때문에 쉽게 해결할 수 있어요. 우리가 기대하는 응답에 대한 타입을 정의해주면 되죠.\n\n이제는 타입 캐스팅을 사용하여 코드 완성기능을 사용할 수 있게 되었어요.\n\n이제 우리는 끝났다고 생각할 수 있지만, 여전히 코드를 개선할 수 있는 부분이 있습니다. fetchData 함수의 반환 타입 any는 최선의 방법이 아닙니다. 이를 Article로 변경할 수 있지만, 그렇게 하면 함수가 특정 반환 타입에 의존하게 되어버립니다. 이 경우에 이상적인 해결책은 제네릭을 사용하는 것이에요.\n\n이 방법을 통해 typecast (as Article)를 삭제할 수도 있습니다.\n\n\n\n지금 우리 코드가 멋지게 보이고 함수 fetchData를 다른 엔드포인트에도 사용할 수 있게 되었어요. 그런데 만약 API 응답이 우리 코드에 정의된 타입과 일치하지 않으면 어떻게 될까요? 우리의 타입 시스템이 그것에 대해 경고를 해줄까요? 답은 NO에요. 제가 소개에서 말했듯이, TypeScript에서 런타임에는 타입 체크가 없어요.\n\n# 런타임에서 타입을 확인하는 방법은?\n\nTS에서는 리플렉션을 지원하지 않기 때문에 수동으로 처리해야 해요. string이나 number와 같은 기본 타입을 위해서는 쉬워요. 간단한 if 문을 작성하고 끝이에요.\n\n```js\nif (typeof myVariable === 'number') {\n  // 우리 작업을 해요\n}\nif (typeof myVariable === 'string') {\n  // 우리 작업을 해요\n}\n```\n\n\n\n하지만 객체들은 훨씬 복잡합니다. 변수가 객체인지 확인하고, null을 체크하고, 각 속성에 대해 객체 내에서 존재하는지 확인하고 별도의 유형 체크를 해야 합니다.\n우리의 Article에 대한 적절한 제어는 다음과 같이 보일 것입니다.\n\n더 복잡하거나 심지어 중첩된 객체에 대해 이겨내야 한다고 상상할 수 있나요? 그걸 하기는 정말 괴로운 아이디어이고, 너무나도 오류가 발생하기 쉽습니다. 그렇다면 어떻게 하면서 다른 부분을 망치치 않을 수 있을까요?\n\n## 타입 가드\n\n한 가지 가능한 해결책은 타입 가드를 생성하는 것입니다. 타입 가드는 보통 함수들이지만 함수의 시그니처가 TS에게 함수의 매개변수가 특정 유형을 가지고 있음을 알려줍니다. 시그니처는 두 가지로 구성됩니다. 함수는 boolean을 반환해야 하며 반환 형식은 param is myType이어야 합니다.\n다음 예제는 타입 가드가 어떻게 사용되는지를 보여줍니다.\n\n\n\n이전 예제의 if 문과 마찬가지로 타입 가드의 구현을 볼 수 있습니다. 유용한 해결책은 이러한 타입 가드를 생성하는 것일 것입니다. 그러나 이것 또한 많은 단점을 가지고 있습니다. 내가 보기에, 이전 예제와 동일한 문제들 외에 가장 큰 문제는 타입 정의와의 동기화입니다.\n\n# 런타임 타입에서 TS 타입 추론하기\n\n수동 접근 방법은 널리 사용하기에는 충분히 실용적이지 않다는 것을 보았습니다. 진짜 열쇠는 typeof 연산자에 숨겨져 있습니다. 우리는 런타임 타입에서 TS 타입을 추론하는 데 이것을 사용할 수 있습니다.\n\n타입을 추론하는 기술 중 하나는 타입 가드의 사용입니다. 실제로 위의 예제에서 이를 보았습니다.\n\n\n\n두 번째로 비슷한 방법은 단언 함수를 사용하는 것입니다. 이러한 함수들은 부울 대신에 매개변수 유형이 잘못된 경우 오류를 throw합니다.\n\n이 방법의 장점 중 하나는 예외와 관련된 메시지가 있어 문제가 발생한 위치를 알 수 있다는 것입니다. 또한 함수를 호출할 때 조건을 작성할 필요가 없습니다. 그러나 그러한 함수의 반환 유형은 void 여야 하며 나중에 보게 될 것처럼 다른 것을 반환하는 것이 유용할 수 있습니다.\n\n## 기능적 접근\n\nEither를 사용하여 유형 검사 함수를 사용할 수 있습니다.\n\n\n\n이제는 이렇게 할 수도 있다는 것을 언급하고 싶어요. 이 개념에 익숙하지 않다면 걱정할 필요 없이 계속 읽어주세요.\n\n## 기본 타입에 대한 최소 구현\n\n비기능적인 방법은 예외를 사용하고 타입이 올바른 경우 입력 매개변수를 반환하는 것입니다. 기본 타입에 대한 최소 구현은 다음과 같이 보일 수 있습니다.\n\n이러한 예는 간단하며 설명이 거의 필요하지 않습니다. TypeGuard`T` 타입은 이러한 함수의 타입이며 이후의 예제에서 더 널리 사용될 것입니다.\n\n\n\n이 기능은 배열의 모든 항목이 내부 유형 가드로 강제되는지 확인합니다.\n\n여기서 보여줄 가드 중에서 가장 복잡한 것입니다. 가드 객체를 인수로 사용하여 해당 객체의 모든 속성이 올바른 유형인지 확인하는 함수를 반환합니다.\n\n## 사용법\n\n위의 함수들은 매우 간단하게 사용할 수 있습니다.\n\n\n\n일반적인 타입 정의 구문과 유사하지만 이제 우리는 런타임 세계에 저장된 타입을 가지게 되었어요. 그리고 앞서 언급했듯이 런타임에서 타입 세계로 정보를 쉽게 얻을 수 있어요. typeof 연산자를 사용하면 끝이에요.\n\n```js\ntype Article = ReturnType\u003ctypeof Article\u003e\n```\n\n타입에 동일한 이름을 사용할 수도 있어요.\n\n# 데이터를 가져오는 안전한 방법\n\n\n\n우리가 보여준 기술을 사용해서 원래 예제를 리팩토링할 수 있어요.\n\n그게 그냥 이렇게 간단해요.\n\n# 새로운 타입의 슈퍼파워\n\n타입 가드는 어떤 함수든 될 수 있어요. 이것은 당신이 원하는 대로 타입을 정의할 수 있다는 걸 의미해요. 항상 짝수인 타입을 가지고 싶다고 상상해보세요. 문제없어요. 당신의 가드만 정의하면 됩니다.\n\n\n\n여기서의 한계는 단지 당신의 상상력뿐이지만, 몇 가지 엉뚱한 유형을 만들 때 조심하는 것이 좋습니다.\n\n# 결론\n\n외부 소스로부터 데이터를 다룰 때는 해당 데이터가 올바른 유형을 가지고 있는지 100% 확신할 수 없습니다. 우리는 TypeScript 유형을 정의하고, 변수를 유형으로 캐스팅하여 모든 것이 작동할 것을 기대할 수 있습니다. 하지만 그것은 단지 희망일 뿐입니다. 우리는 런타임에서 유형을 확인할 방법이 필요하지만 TS에는 이를 위한 세련된 내장 도구가 없습니다. 수동 유형 가드를 작성할 수 있지만 많은 단점이 있습니다. 유형 정의와 유형 가드를 동기화할 필요를 없애기 위해 먼저 유형 가드를 정의하고 typeof 연산자를 사용하여 런타임 정의에서 TS 유형을 추론할 수 있습니다.\n\n# 라이브러리\n\n\n\n이 글에서 소개된 것보다 더 견고한 해결책을 찾고 있다면 다음과 같은 기능을 제공하는 몇 가지 라이브러리가 있습니다.\n\n- IO-ts - 함수형 라이브러리\n- Zod\n- Runtypes\n- 여기서 더 많은 정보를 얻을 수 있습니다.\n\n오늘 제가 가진 것은 여기까지입니다. 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png","tag":["Tech"],"readingTime":5},{"title":"Title TypeScript과 Go 및 Rust 오류 Try Catch 없어 이단주의","description":"","date":"2024-05-14 15:12","slug":"2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy","content":"\n\n![2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png](/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png)\n\n자, 그러면 나에 대한 소소한 이야기부터 시작해볼까요? 저는 경력이 약 열 년 정도인 소프트웨어 개발자입니다. 처음에는 PHP로 일하다가 서서히 JavaScript로 전환했어요.\n\n약 다섯 년 전 TypeScript를 사용하기 시작했고, 그 이후로는 결코 JavaScript로 돌아가지 않았습니다. TypeScript를 사용하기 시작한 순간, 이 전세계에서 가장 멋진 프로그래밍 언어인 것 같다고 생각했어요. 모두가 그것을 사랑하고 사용하니까요... 정말 최고의 언어인 거 맞죠? 맞죠? 그렇죠?\n\n그런데 다른 언어들을 좀 더 현대적인 것으로 시도해보기 시작했어요. 먼저 Go를 접했고, 이어서 천천히 Rust를 목록에 추가했어요 (감사합니다, Prime).\n\n\n\n알지 못할 때 뭔가를 놓치는 것은 어렵습니다.\n\n제가 얘기하고 싶은 것은 무엇일까요? Go와 Rust가 공유하는 공통점은 무엇인가요? 오류입니다. 그것이 가장 눈에 띄는 점이었죠. 그리고 좀 더 구체적으로, 이러한 언어들이 오류를 어떻게 처리하는지에 대해서요.\n\nJavaScript는 오류를 처리하기 위해 예외를 던지는 데 의존하지만, Go와 Rust는 그것들을 값으로 취급합니다. 이게 그다지 큰 문제가 아니라고 생각할 수도 있습니다만... 하지만, 정말 그럴듯하게 들릴지도 몰라요; 하지만, 이것은 게임 체인저입니다.\n\n마주하겠습니다. 각 언어에 대해 깊게 들어가지는 않을 거에요; 일반적인 접근 방식을 알고 싶어 하는 것이죠.\n\n\n\n자바스크립트/타입스크립트와 작은 게임으로 시작해볼까요?\n\n아래 코드를 5초 동안 살펴보고, 왜 try/catch로 감싸야 하는지 답해보세요.\n\n```js\ntry {\n  const request = { name: \"test\", value: 2n };\n  const body = JSON.stringify(request);\n  const response = await fetch(\"https://example.com\", {\n    method: \"POST\",\n    body,\n  });\n  if (!response.ok) {\n    return;\n  }\n  // handle response\n} catch (e) {\n  // handle error\n  return;\n}\n```\n\n대부분의 분들이 예상한 대로, response.ok를 확인하고 있는데도 fetch 메서드가 오류를 발생시킬 수 있다는 것을 알았을 것입니다. response.ok는 4xx와 5xx 네트워크 오류만을 \"잡아내지\"요. 그러나 네트워크 자체에 문제가 발생하면 오류가 발생합니다.\n\n\n\n하지만 JSON.stringify가 오류를 던질 것이라는 것을 얼마나 많은 사람이 추측했을지 궁금하네요. 이유는 요청 객체에 bigint (2n) 변수가 포함되어 있기 때문에 JSON이 이를 문자열화하는 방법을 모른다는 점입니다.\n\n그래서 첫 번째 문제는, 개인적으로는 JavaScript 역사상 가장 큰 문제라고 생각합니다: 어떤 것이 오류를 발생시킬 수 있는지 모른다는 것입니다. JavaScript 오류 관점에서, 이는 다음과 같습니다:\n\n```js\ntry {\n  let data = \"Hello\";\n} catch (err) {\n  console.error(err);\n}\n```\n\nJavaScript는 모릅니다; JavaScript는 신경 쓰지 않습니다. 하지만 여러분은 알아야 합니다.\n\n\n\n두 번째로, 여기 완벽히 유효한 코드입니다:\n\n```js\nconst request = { name: \"test\", value: 2n };\nconst body = JSON.stringify(request);\nconst response = await fetch(\"https://example.com\", {\n  method: \"POST\",\n  body,\n});\nif (!response.ok) {\n  return;\n}\n```\n\n에러 없이, 린터도 통과하여도 여전히 앱을 망가뜨릴 수 있답니다.\n\n지금 내 머릿속에서 \"뭐가 문제니, 그냥 모든 곳에 try/catch를 사용하면 되지\"라는 목소리를 듣는 것 같아요. 여기 세 번째 문제가 나타나죠: 어떤 예외가 발생하였는지 알 수 없어요. 물론 에러 메시지를 통해 어떤 예외가 발생했는지 어느 정도는 추측할 수 있지만, 에러가 발생할 수 있는 많은 서비스/기능이 있는 큰 프로젝트라면 어떻게 할 건가요? 당신이 모든 예외 상황을 try/catch로 제대로 처리하고 있는지 확신할 수 있나요?\n\n\n\n알았어요, JS를 비난하는 걸 그만하고 다른 얘기로 넘어갈까요? 이 Go 코드로 시작해봐요:\n\n```go\nf, err := os.Open(\"filename.ext\")\nif err != nil {\n  log.Fatal(err)\n}\n// 열린 *File f로 무언가를 처리합니다\n```\n\n우리는 파일을 열어서 파일 또는 오류를 반환하려고 해요. 이걸 자주 볼 거에요, 왜냐하면 어떤 함수가 항상 오류를 반환하는지 알고 있기 때문이에요. 한 번도 놓치지 않아요. 여기서 오류를 값으로 다루는 첫 번째 예시를 볼 수 있어요. 어떤 함수가 그것들을 반환할 수 있는지 지정하고, 반환하고, 할당하고, 확인하고, 다루는거죠.\n\n그리고 이것은 그렇게 다채롭지 않다는 점도 있고, Go가 비판받는 것 중 하나인 ‘\"오류 확인 코드\"’인데요, err != nil ' … 같은 부분이 종종 나머지보다 더 많은 줄을 차지하기도 해요.\n\n\n\n```js\n만약 에러가 발생하면 {\n  …\n  만약 에러가 발생하면 {\n    …\n    만약 에러가 발생하면 {\n      … \n    }\n  } \n}\n만약 에러가 발생하면 {\n  … \n}\n…\n만약 에러가 발생하면 {\n  … \n}\n```\n\n전체 노력이 확실히 가치 있어, 믿어도 괜찮아.\n\n그리고 마지막으로, Rust:\n\n```js\nlet greeting_file_result = File::open(\"hello.txt\");\nlet greeting_file = match greeting_file_result {\n  Ok(file) =\u003e file,\n  Err(error) =\u003e panic!(\"파일 열기에 문제 발생: {:?}\", error),\n};\n```\n\n\n\n여기 세 가지 중 가장 상세하고, 기이하게도 가장 좋은 것이 있습니다. 그래서, 먼저 러스트는 놀라운 enum을 사용하여 오류를 처리합니다 (TypeScript의 enum과는 다릅니다!). 자세히 설명하지 않고 중요한 것은 두 가지 변형을 가진 Result라는 enum을 사용한다는 것입니다: Ok과 Err입니다. 상상컨대 Ok에는 값이 포함되어 있고 Err에는... 놀랍게도 오류가 포함되어 있습니다 :D.\n\nGo 문제를 완화하기 위해 더 편리하게 처리하기 위한 방법이 많이 있습니다. 가장 잘 알려진 방법 중 하나는 ? 연산자입니다.\n\n```js\nlet greeting_file_result = File::open(\"hello.txt\")?;\n```\n\n여기서 주요한 점은 Go와 Rust가 항상 어디에 오류가 발생할 수 있는지 알고 있고, 오류가 나타난 곳에서 바로 처리하도록 강제한다는 것입니다 (대부분). 숨겨진 오류나 추측, 놀란 얼굴로 앱이 깨지는 일은 없습니다.\n\n\n\n그리고 이 방법이 그냥 더 나은 거야. 아주 많이.\n\n그럼, 솔직해지는 시간이야; 난 조금 거짓말을 했어. TypeScript 오류를 Go/Rust와 같이 작동하도록 만들 수는 없어. 여기서의 제한 요인은 언어 자체야; 그 일을 수행할 적절한 도구가 없거든.\n\n하지만 우리가 할 수 있는 건 비슷하게 만들어 보려고 노력하는 거야. 그리고 간단하게 만드는 거야.\n\n이렇게 시작해 보자:\n\n\n\n```js\nexport type Safe\u003cT\u003e =\n  | {\n    success: true;\n    data: T;\n  }\n  | {\n    success: false;\n    error: string;\n  };\n```\n\n여기에는 특별한 것은 없어요. 그냥 간단한 제네릭 타입일 뿐이에요. 그러나 이 작은 아이가 코드를 완전히 바꿀 수 있어요. 아마도 알아차릴 수 있을 거예요만, 이곳에서 가장 큰 차이점은 데이터를 반환하거나 에러를 반환한다는 점이죠. 익숙해 보이나요?\n\n그리고… 또 하나의 거짓말, 우리는 몇 개의 try/catch가 필요해요. 좋은 점은 100,000이 아니라 약 두 개만 필요하다는 것이에요.\n\n```js\nexport function safe\u003cT\u003e(promise: Promise\u003cT\u003e, err?: string): Promise\u003cSafe\u003cT\u003e\u003e;\nexport function safe\u003cT\u003e(func: () =\u003e T, err?: string): Safe\u003cT\u003e;\nexport function safe\u003cT\u003e(\n  promiseOrFunc: Promise\u003cT\u003e | (() =\u003e T),\n  err?: string,\n): Promise\u003cSafe\u003cT\u003e\u003e | Safe\u003cT\u003e {\n  if (promiseOrFunc instanceof Promise) {\n    return safeAsync(promiseOrFunc, err);\n  }\n  return safeSync(promiseOrFunc, err);\n}\n\nasync function safeAsync\u003cT\u003e(\n  promise: Promise\u003cT\u003e, \n  err?: string\n): Promise\u003cSafe\u003cT\u003e\u003e {\n  try {\n    const data = await promise;\n    return { data, success: true };\n  } catch (e) {\n    console.error(e);\n    if (err !== undefined) {\n      return { success: false, error: err };\n    }\n    if (e instanceof Error) {\n      return { success: false, error: e.message };\n    }\n    return { success: false, error: \"Something went wrong\" };\n  }\n}\n\nfunction safeSync\u003cT\u003e(\n  func: () =\u003e T, \n  err?: string\n): Safe\u003cT\u003e {\n  try {\n    const data = func();\n    return { data, success: true };\n  } catch (e) {\n    console.error(e);\n    if (err !== undefined) {\n      return { success: false, error: err };\n    }\n    if (e instanceof Error) {\n      return { success: false, error: e.message };\n    }\n    return { success: false, error: \"Something went wrong\" };\n  }\n}\n```\n\n\n\n\"와우, 무슨 천재인가요. try/catch를 위한 래퍼를 만들었네요.\" 네, 맞아요; 이것은 Safe 타입을 반환하는 래퍼일 뿐입니다. 하지만 때로는 간단한 것만으로 충분할 때도 있죠. 위의 예시와 함께 결합해봅시다.\n\n예전 코드 (16 줄):\n\n```js\ntry {\n  const request = { name: \"test\", value: 2n };\n  const body = JSON.stringify(request);\n  const response = await fetch(\"https://example.com\", {\n    method: \"POST\",\n    body,\n  });\n  if (!response.ok) {\n    // 네트워크 에러 처리\n    return;\n  }\n  // 응답 처리\n} catch (e) {\n  // 에러 처리\n  return;\n}\n```\n\n새 코드 (20 줄):\n\n\n\n```js\nconst request = { name: \"test\", value: 2n };\nconst body = safe(\n  () =\u003e JSON.stringify(request),\n  \"요청을 직렬화하는 데 실패했습니다\",\n);\nif (!body.success) {\n  // 에러 처리 (body.error)\n  return;\n}\nconst response = await safe(\n  fetch(\"https://example.com\", {\n    method: \"POST\",\n    body: body.data,\n  }),\n);\nif (!response.success) {\n  // 에러 처리 (response.error)\n  return;\n}\nif (!response.data.ok) {\n  // 네트워크 에러 처리\n  return;\n}\n// 응답 처리 (body.data)\n```\n\n그래서 새롭게 제안된 솔루션은 더 길지만, 다음과 같은 이유로 성능이 우수합니다:\n\n- try/catch가 없음\n- 발생한 각 오류를 해당 위치에서 처리\n- 특정 함수에 대한 오류 메시지 지정 가능\n- 상단부터 하단까지 좋은 논리 구조, 모든 오류가 상단에 있고 가장 아래에는 응답만 있음\n\n다음의 내용을 확인하는 것을 잊을 경우 어떻게 될까요?\n\n\n\n\n```js\nif (!body.success) {\n  // 에러 처리 (body.error)\n  return;\n}\n```\n\n문제는... 우리는 그것을 할 수 없어요. 네, 그 확인을 해야 합니다. 그것을 하지 않으면 body.data가 존재하지 않을 거에요. LSP가 \"Property 'data' does not exist on type 'Safe`string`’\" 오류를 던져서 우리를 알릴 거에요. 그리고 그건 우리가 만든 간단한 Safe 타입 덕분이에요. 그리고 에러 메시지에도 작동해요. 우리는 !body.success를 확인하지 않으면 body.error에 액세스할 수 없어요.\n\n여기 TypeScript를 감사하게 생각해야 할 때예요. 그리고 이것이 적용되는 방법은 다음과 같아요:\n\n\n\n```js\nif (!response.success) {\n  // 오류 처리 (response.error)를 핸들링하세요\n  return;\n}\n```\n\n!response.success를 제거할 수 없는 이유는 그렇게 하지 않으면 response.data가 존재하지 않을 수 있기 때문입니다.\n\n물론, 우리의 해결책에는 문제가 없지 않습니다. 가장 큰 문제는 오류를 발생시킬 수 있는 Promise/함수를 안전한 래퍼로 감싸야 한다는 것을 기억해야 한다는 점입니다. 이 \"우리가 알아야 하는\" 것은 극복할 수 없는 언어 제한입니다.\n\n어렵게 들릴 수 있지만, 실제로는 그렇지 않습니다. 곧 코딩에서 거의 모든 Promise가 오류를 발생할 수 있고 동기 함수 중에서도 그런 것을 알아보고 그 수가 많지 않다는 것을 깨닫게 될 것입니다.\n\n\n\n\n여전히 의문이 있을 수도 있겠죠? 하지만 저희는 그것이 가치가 있다고 생각해요. 저희 팀에서는 정말 잘 작동하고 있거든 :). 예를 들어, 어디에서나 try/catch가 없는 큰 서비스 파일을 본다면, 모든 오류가 발생한 곳에서 처리되고, 논리적으로 순조롭게 흘러간다면... 정말 멋지게 보이죠.\n\n여기 SvelteKit FormAction을 사용한 실제 예제가 있어요:\n\n```js\nexport const actions = {\n  createEmail: async ({ locals, request }) =\u003e {\n    const end = perf(\"CreateEmail\");\n    const form = await safe(request.formData());\n    if (!form.success) {\n      return fail(400, { error: form.error });\n    }\n    const schema = z\n      .object({\n        emailTo: z.string().email(),\n        emailName: z.string().min(1),\n        emailSubject: z.string().min(1),\n        emailHtml: z.string().min(1),\n      })\n      .safeParse({\n        emailTo: form.data.get(\"emailTo\"),\n        emailName: form.data.get(\"emailName\"),\n        emailSubject: form.data.get(\"emailSubject\"),\n        emailHtml: form.data.get(\"emailHtml\"),\n      });\n    if (!schema.success) {\n      console.error(schema.error.flatten());\n      return fail(400, { form: schema.error.flatten().fieldErrors });\n    }\n    const metadata = createMetadata(URI_GRPC, locals.user.key)\n    if (!metadata.success) {\n      return fail(400, { error: metadata.error });\n    }\n    const response = await new Promise\u003cSafe\u003cEmail__Output\u003e\u003e((res) =\u003e {\n      usersClient.createEmail(schema.data, metadata.data, grpcSafe(res));\n    });\n    if (!response.success) {\n      return fail(400, { error: response.error });\n    }\n    end();\n    return {\n      email: response.data,\n    };\n  },\n} satisfies Actions;\n```\n\n다음 사항 몇 가지를 강조해보겠어요:\n\n\n\n- 저희 사용자 정의 함수 grpcSafe는 gGRPC 콜백 처리를 돕습니다.\n- createMetadata는 Safe를 반환하므로 래핑할 필요가 없습니다.\n- zod 라이브러리도 동일한 패턴을 사용합니다 :) 스키마.success 확인을 하지 않으면 스키마.data에 접근할 수 없습니다.\n\n깔끔하게 보이지 않나요? 한번 시도해보세요! 아마도 여러분에게도 잘 맞을지도 모르겠네요 :)\n\n읽어 주셔서 감사합니다.\n\nP.S. 비슷해 보이나요?\n\n\n\n```js\nf, err := os.Open(\"filename.ext\")\nif err != nil {\n  log.Fatal(err)\n}\n// 열린 *File f를 사용해 작업을 수행합니다\n```\n\n```js\nconst response = await safe(fetch(\"https://example.com\"));\nif (!response.success) {\n  console.error(response.error);\n  return;\n}\n// response.data를 활용해 작업을 수행합니다\n```\n\n만약 마음에 드셨다면, 저의 트위터를 팔로우해주시고 공유해주시면 정말 감사하겠습니다! 제가 gRPC와 페이지로 데이터를 점진적으로 스트리밍하는 등, 잘 알려지지 않은 기술들에 대해 지식을 나누기를 원합니다. :)\n\n[트위터에서 팔로우하기](https://twitter.com/mapiorowski)","ogImage":{"url":"/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png"},"coverImage":"/assets/img/2024-05-14-TypeScriptWithGoandRustErrorsNoTryCatchHeresy_0.png","tag":["Tech"],"readingTime":10},{"title":"내가 좋아하는 JavaScript 짧은 코드 한 줄","description":"","date":"2024-05-14 15:11","slug":"2024-05-14-MyFavouriteJavaScriptOne-Liners","content":"\n\n\n![My Favourite JavaScript One-Liners](/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png)\n\n오늘은 다양한 코딩 과제에서 많은 도움을 받은 가장 유용하고 간단한 JavaScript 원 라이너를 여러분과 공유하고 싶어요.\n\n다음의 속임수를 사용함으로써 복잡한 함수를 프로그래밍하는 데 많은 작업을 줄일 수 있어요.\n\n그러니 이제 말이 더 필요 없죠! 함께 시작해봐요!\n\n\n\n\n# 디자인 모드\n\n일반적으로 꺼져 있는 이 기능을 활성화하면 웹사이트에서 어떤 텍스트든 선택하고 편집할 수 있습니다. 이를 통해 소스 코드를 변경하지 않고도 빠르게 다양한 텍스트나 단어를 시도해 볼 수 있습니다.\n\n이 기능을 활성화하려면 아래 코드만 필요합니다:\n\n```js\ndocument.designMode = \"on\"\n```\n\n\n\n# 배열 병합\n\n```js\nconst merge = [...array1, ...array2];\n```\n\n이 코드 스니펫은 JavaScript의 전개 구문을 활용하여 두 배열의 내용을 매끄럽게 병합합니다. 각 배열의 요소를 대괄호 안에 펼쳐서 새로운 배열을 만들어 두 소스 배열의 모든 요소를 포함시킵니다.\n\n이 간결한 접근 방식은 원본 배열을 변형시키지 않고 배열을 결합하는 과정을 간단하게 만들어 줍니다.\n\n\n\n중복을 피하고 각 요소가 한 번만 존재하도록 하려면 Set() 메서드를 사용하십시오:\n\n```js\nconst merge = [...new Set([...array1, ...array2])];\n```\n\n# 랜덤 Hex 색상 생성\n\n다음 코드는 16진수 코드로 랜덤 색상을 생성합니다. 이는 데이터 시각화나 동적 콘텐츠 생성 시 매우 유용합니다.\n\n\n\n```js\nconst randomHexColor = '#' + Math.floor(Math.random() * 16777215).toString(16);\n```\n\n# 클립보드에 복사\n\n선택된 웹사이트의 일부를 클립보드에 복사할 수 있습니다.\n\n```js\ndocument.execCommand('copy');\n```\n\n\n\n자바스크립트를 사용하여 텍스트를 클립보드에 복사하는 방법은 클립보드 API를 사용하는 것입니다. 간단한 예제를 보여드리겠습니다:\n\n```js\nfunction copyToClipboard(text) {\n  const textarea = document.createElement('textarea');\n  textarea.value = text;\n  document.body.appendChild(textarea);\n  textarea.select();\n  document.execCommand('copy');\n  document.body.removeChild(textarea);\n}\n\n// 사용 예시:\nconst textToCopy = \"안녕하세요, 세상!\";\ncopyToClipboard(textToCopy);\n```\n\n- copyToClipboard 함수는 임시 텍스트영역 요소를 생성하여 해당 값으로 설정하고, 문서 바디에 추가한 뒤 해당 내용을 선택하고, 복사 명령을 실행하여 마지막으로 DOM에서 텍스트영역 요소를 제거합니다.\n- \"안녕하세요, 세상!\"을 복사할 텍스트로 교체해주세요.\n\n\nconsole.table\n\n\n\n\n이 함수는 특히 대량 데이터의 콘솔 출력을 용이하게 합니다. console.log()에 비해 데이터를 표로 표시하여 더 명확한 대안을 제공합니다.\n\n```js\nconst data = [\n  { name: 'John', age: 30, city: 'New York' },\n  { name: 'Alice', age: 25, city: 'Los Angeles' },\n  { name: 'Bob', age: 35, city: 'Chicago' }\n];\n\nconsole.table(data);\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_1.png\" /\u003e\n\n이 게시물이 여러분의 문제 중 일부를 해결하고 즐겁게 읽으셨기를 바랍니다! 여러분의 가장 좋아하는 JavaScript 원라이너가 무엇인지 댓글로 알려주세요.\n\n\n\n가장 최신 컨텐츠를 받아보려면 구독을 잊지마세요! 👍\n\n코딩 즐기세요! 🚀","ogImage":{"url":"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png"},"coverImage":"/assets/img/2024-05-14-MyFavouriteJavaScriptOne-Liners_0.png","tag":["Tech"],"readingTime":3}],"page":"100","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"100"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>