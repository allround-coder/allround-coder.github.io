<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/100" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/100" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="TailwindCSS를 알아야 하며 사용해야 할 라이브러리들" href="/post/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TailwindCSS를 알아야 하며 사용해야 할 라이브러리들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TailwindCSS를 알아야 하며 사용해야 할 라이브러리들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TailwindCSS를 알아야 하며 사용해야 할 라이브러리들</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리" href="/post/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법" href="/post/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석" href="/post/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등" href="/post/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 과학을 위한 도커의 직관적인 안내" href="/post/2024-05-15-AnIntuitiveGuidetoDockerforDataScience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 과학을 위한 도커의 직관적인 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 과학을 위한 도커의 직관적인 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 과학을 위한 도커의 직관적인 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기" href="/post/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" href="/post/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라이언트 측 로직 간소화 뷰 모델의 전략적 활용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">클라이언트 측 로직 간소화 뷰 모델의 전략적 활용</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" href="/post/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 앱에 Stripe 결제 추가하는 방법" href="/post/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 앱에 Stripe 결제 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 앱에 Stripe 결제 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nextjs 앱에 Stripe 결제 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link posts_-active__YVJEi" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"TailwindCSS를 알아야 하며 사용해야 할 라이브러리들","description":"","date":"2024-05-15 03:01","slug":"2024-05-15-TailwindCSSlibrariesyoushouldknowanduse","content":"\n\n\n![TailwindCSS Libraries](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png)\n\nTailwindcss는 유틸리티 우선 CSS 프레임워크입니다. 핵심 원칙은 작고 단일 목적의 CSS 클래스 모음을 제공하여 웹 요소에 원하는 스타일을 달성할 수 있는 유틸리티 도구 같은 것입니다.\n\nTailwindcss는 2017년 Tailwind Labs의 CEO인 Adam Wathan과 일부 기여자들에 의해 만들어졌습니다. 이 프레임워크는 HTML을 떠나지 않고도 개발자가 현대적인 웹 애플리케이션을 구축하는 데 도움을 주도록 설계되었습니다. Tailwindcss는 기존의 프레임워크보다 디자인 프로세스에 대한 유연성과 제어를 더 많이 제공합니다. 미리 구축된 구성 요소로 제한받지 않고 개발자들이 원활한 작업 흐름을 갖게 되도록 합니다. 그 유연성과 쉬운 통합 덕분에 Tailwindcss는 매우 인기 있는 CSS 프레임워크가 되었으며 React, Next, Vue와 같은 대부분의 프론트엔드 프레임워크에서 선호하는 선택이 되었습니다.\n\nTailwindCSS 위에 구축된 많은 타사 구성 요소 라이브러리가 있습니다. 이러한 라이브러리는 Tailwind의 유틸리티 클래스로 이미 스타일이 적용된 버튼, 내비게이션 바, 모달 창 등과 같은 미리 구축된 구성 요소를 제공합니다. 이 기사에서는 Tailwind CSS를 통해 빠른 개발과 프로젝트 간 일관된 디자인을 활용할 수 있는 최고의 5가지 tailwindcss 라이브러리를 소개하겠습니다.\n\n\n\n\n## 1. Shadcn UI\n\nShadcn은 아름답게 디자인된 구성 요소를 제공하여 앱에 복사하여 붙여넣을 수 있습니다. Tailwind의 유틸리티 우선 접근 방식을 적용하면서도 빠르게 사전 구축된 UI 요소를 웹 애플리케이션에 통합할 수 있습니다. 사전 제작되었지만 Shadcn을 사용하여 구성 요소를 사용자 정의하여 특정 디자인 요구 사항에 맞게 조정할 수 있습니다. Tailwind의 유틸리티 클래스를 사용하여 스타일, 색상 및 레이아웃을 조정할 수 있습니다. Shadcn UI를 시작하려면 ui.shadcn.com을 방문하세요.\n\n![image](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_1.png)\n\n## 2. Flowbite\n\n\n\nFlowbite는 Tailwind CSS를 기반으로 구축된 600개 이상의 UI 구성 요소를 제공하며 Figma에서 디자인되었습니다. 이에는 버튼, 내비게이션 바, 폼, 카드, 모달 등과 같은 일반 요소가 포함됩니다. 준비된 구성 요소를 사용하면 Tailwind의 유틸리티 클래스만 사용하여 모든 것을 처음부터 만드는 것보다 시간을 절약할 수 있습니다. Flowbite는 Figma 디자인 시스템을 제공하여 디자이너가 Flowbite 구성 요소를 사용하여 사용자 인터페이스를 시각적으로 디자인하고 이를 쉽게 Tailwind CSS 코드로 변환할 수 있도록 합니다. Flowbite로 시작하려면 flowbite.com을 방문하세요.\n\n![이미지](/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_2.png)\n\n## 3. DaisyUI\n\nDaisyUI는 Tailwind CSS와 특별히 작동하도록 구축된 무료 인기 있는 컴포넌트 라이브러리입니다. Tailwind의 유틸리티 클래스만 사용하여 모든 것을 처음부터 만드는 것에 비해 프로젝트에 쉽게 통합할 수 있는 사전 스타일이 적용된 다양한 UI 구성 요소를 제공합니다. DaisyUI로 시작하려면 daisyui.com을 방문하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_3.png\" /\u003e\n\n## 4. Preline UI\n\nPreline UI는 Tailwind CSS를 기반으로 한 컴포넌트를 완전히 빌드하며, 스타일링을 위해 유틸리티 클래스를 사용합니다. 이로 인해 기존의 Tailwind 설정과 원활하게 통합되는 일관된 외관을 만들어냅니다. 또한 Tailwind 클래스를 사용하여 미리 구축된 컴포넌트를 더욱 특별하게 사용자 정의할 수 있습니다. Preline UI는 가벼우면서 모듈식으로 설계되었습니다. 프로젝트에 필요한 특정 컴포넌트만 가져와서 코드베이스를 깔끔하고 효율적으로 유지할 수 있습니다. Preline UI를 시작하려면 preline.co를 방문해보세요.\n\n\u003cimg src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_4.png\" /\u003e\n\n\n\n## 5. Sailboat UI\n\nSailboat UI은 150개 이상의 UI 구성 요소를 자랑하며, 일부 다른 Tailwind CSS 라이브러리보다 더 다양한 옵션을 제공합니다. 버튼, 폼, 카드, 네비게이션 메뉴, 모달 등과 같은 일반적인 요소뿐만 아니라 유용한 일부 일반적이지 않은 구성 요소도 포함되어 있습니다. Sailboat UI는 알파인.js를 기본적으로 사용하여 구성 요소에 상호 작용성을 추가합니다. 알파인.js는 완전한 JavaScript 프레임워크를 필요로 하지 않고 HTML 요소에 동적 동작을 추가할 수 있는 가벼운 JavaScript 라이브러리입니다. Sailboat UI로 시작하려면 sailboatui.com을 방문해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_5.png\" /\u003e\n\n마지막으로, Tailwind CSS의 세계는 유틸리티 클래스 이상으로 확장되었습니다. 이 다섯 가지 Tailwind CSS 라이브러리는 이 프레임워크의 강점과 다양성을 보여줍니다. 각 라이브러리는 독특한 기능 세트를 제공하며 다양한 개발 요구 사항을 충족시킵니다. 프로젝트 요구 사항에 관계없이, 개발 프로세스를 간소화하고 아름답고 현대적인 사용자 인터페이스를 만들 수 있는 Tailwind CSS 라이브러리가 있습니다. 이러한 사전 구축된 구성 요소를 활용하여 웹 애플리케이션의 핵심 기능에 집중하고 효율적으로 디자인 비전을 실현할 수 있습니다.\n\n\n\n더 많은 내용을 보시려면 팔로우해주세요. 읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png"},"coverImage":"/assets/img/2024-05-15-TailwindCSSlibrariesyoushouldknowanduse_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 아키텍처 구축 제2부  NgRx SignalStore를 활용한 상태 쿼리 및 관리","description":"","date":"2024-05-15 02:58","slug":"2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png\" /\u003e\n\n이 시리즈의 첫 번째 파트에서는 Apollo Client를 사용하여 Angular 애플리케이션에서 GraphQL API와 상호 작용하는 견고한 기반을 확립했습니다. 이제 애플리케이션 데이터 흐름에서 중요한 지점으로 약간 초점을 옮기면서 데이터를 효과적으로 처리하고 업데이트하는 방법을 살펴보겠습니다.\n\n이를 어떻게 효과적으로 처리할지는 시험하고 검증된 서비스 및 서브젝트 패턴을 사용하거나 RxJs를 사용한 강력한 반응형 구현만으로도 충분히 달성할 수 있습니다. 그러나 애플리케이션이 점점 확장되고 더 많은 기능이 서로 작동해야 하는 경우, 상태 관리는 복잡해집니다.\n\n이러한 이해를 바탕으로 많은 개발자들은 확장 가능하고 사용하기 쉬운 툴킷을 제공하는 외부 라이브러리로 돌아간다는 경향이 있습니다. 시장에는 여러 옵션이 있지만 가장 일반적인 것은 NgRx에 의한 Redux 기반 구현일 것입니다. 그러나 동일한 팀은 최근 SignalStore라는 최신 버전을 출시했는데, 이는 본질적으로 서비스와 서브젝트(시그널) 패턴을 확장한 것입니다.\n\n\n\n주요 장점은 직관적이고 보일러플레이트가 적으며 선언적이라는 점입니다. 이는 확장 가능성에 도움이 되는 높은 모듈성을 구현하며 유형 안전 및 강하게 주장하는 동시에 유연한 밸런스를 제공합니다. 여기서 설치 단계를 찾을 수 있습니다.\n\n## 할 일 저장소 설정하기\n\n먼저, 우리는 todos.store.ts 파일을 생성할 수 있습니다. 여기에는 저장소를 정의할 것입니다. 개략적으로 보면 다음과 같을 것입니다:\n\n```js\nexport const TodosStore = signalStore(\n  withMethods((store) =\u003e {\n    /*** 여기에 메서드가 사용 가능할 것입니다 ***/\n  }),\n  withComputed(() =\u003e ({\n    /*** 여기에서 계산된 값 정의가 가능합니다 ***/\n  })),\n  withHooks(({ loadAll }) =\u003e ({\n    /*** onInit 및 onDestroy 라이프사이클 후크에 액세스할 수 있습니다 ***/\n  }))\n);\n\nexport type TodosStore = InstanceType\u003ctypeof TodosStore\u003e;\n\nexport function provideTodosStore(): Provider[] {\n  return [TodosStore];\n}\n```\n\n\n\n간단히 말하자면, `withMethods` 함수를 사용하여 메소드를 선언합니다. 이들은 상태 변이부터 API 호출 및 데이터 처리에 이르기까지 어떤 것이든 될 수 있습니다. UI를 보다 선언적으로 만들고 중복된 계산을 피하기 위해, `SignalStore` 내에서 계산된 속성을 사용할 수도 있습니다. 이를 통해 기본 상태에서 값을 유도할 수 있으며, 컴포넌트가 데이터를 표시하는 데 집중하도록 유지할 수 있습니다. 게다가, 컴포넌트에서 빌린 개념인 라이프사이클 후크도 있습니다. `withHooks`을 사용하면 상점의 생성과 소멸에 탭하여 초기화 또는 정리 같은 작업을 수행할 수 있습니다.\n\n마지막으로, 이 종속성을 더 깔끔하게 제공할 수 있는 부분을 포함했습니다(예: 컴포넌트에 `provideTodosStore()`를 추가하는 방식). 그리고 스토어를 TodosStore 유형으로 생성자에 주입할 수 있도록 쉽게 스토어를 주입할 수 있게 되며 'constructor(private todosStore: TodosStore)'를 추가하는 것만큼 쉽습니다. 또한 클래스 속성에 `inject` 함수를 통해 주입할 수도 있지만, 저는 생성자 주입을 선호하는 편입니다. 더 읽기 쉽다고 느껴지기 때문입니다. 더 나아가, 전역으로 스토어를 제공하려면 다음과 같이 스토어를 선언하여 전역으로 제공할 수도 있습니다: `export const TodosStore = signalStore(' providedIn: `root` ', ...);`.\n\n## 상태 정의\n\n최초 반복에서는 다음과 같이 `withState()` 함수를 사용하여 상태를 정의할 수 있습니다.\n\n\n\n```js\ntype TodosState = {\n  data?: Todos[];\n  errors?: string[];\n  loading: boolean; \n}\n\nconst initialState: TodosState = {\n  loading: true\n}\n\nexport const TodosStore = signalStore(\n  withState(initialState)\n);\n```\n\n`TodosState` 타입은 상태가 어떻게 보일지를 정의합니다. 우리는 할 일 배열과 오류 문자열 배열이 있고 이 중 어떤 작업이 실패하면 로드될 예정이며 작업이 진행 중인지 여부를 나타내는 로딩 플래그가 있습니다.\n\n데이터와 오류 속성은 로드될 때까지 기본적으로 정의되지 않기 때문에 초기 상태는 로딩 플래그만으로 설정할 수 있습니다. 그런 다음, 상태를 연결하여 상점을 설정합니다. 이것은 이전에 설명한 메커니즘을 사용하여 원하는 대로 변경할 수 있는 가장 기본적인 구현입니다.\n\n...하지만 다르게 보일 수도 있습니다.\n\n\n\n\n## 모듈화 - 사용자 정의 저장소 기능 외부화\n\n더 많은 기능을 구축할수록 로딩 및 오류 상태를 관리하는 것이 반복적인 작업이 될 것을 알게될 것입니다. 중복을 피하고 코드를 모듈화 유지하기 위해 이를 재사용 가능한 기능으로 만들어봅시다. 이렇게하여 request.feature.ts 파일을 아래와 같이 생성할 수 있습니다.\n\n```js\ntype RequestState = {\n  loading: boolean;\n  errors?: string[];\n};\n\nfunction withRequestStatus() {\n  return signalStoreFeature(withState\u003cRequestState\u003e({ loading: false }));\n}\n\nfunction setLoading(): Partial\u003cRequestState\u003e {\n  return { loading: true };\n}\n\nfunction setLoaded(): Partial\u003cRequestState\u003e {\n  return { loading: false };\n}\n\nfunction setErrors(value: string[]): Partial\u003cRequestState\u003e {\n  return { errors: value };\n}\n\nexport { withRequestStatus, setLoading, setLoaded, setErrors };\n```\n\n이전과 마찬가지로 상태 타입을 생성한 다음 상태 기능을 연결할 수 있는 함수와 상태를 변이하는 데 사용할 수있는 몇 가지 함수를 만듭니다. 실제로는 아래와 같은 결과물이 나오게 될 것입니다.\n\n\n\n```js\ntype TodosState = {\n  data?: Todos[];\n};\n\nconst initialState: TodosState = {\n  data: []\n};\n\nexport const TodosStore = signalStore(\n  withState(initialState),\n  withRequestStatus(),\n  withMethods((store) =\u003e {\n    const apollo = inject(Apollo);\n\n    return {\n      loadAll: rxMethod\u003cvoid\u003e(\n        pipe(\n          tap(() =\u003e patchState(store, setLoading())),\n          switchMap(() =\u003e apollo.query({ query: GET_TODOS_QUERY })),\n          tapResponse({\n            next: (response: ApolloQueryResult\u003c{ getTodos: Todo[] }\u003e) =\u003e\n              patchState(store, { data: response.data.getTodos }),\n            error: (errors: ApolloError[]) =\u003e patchState(store, setErrors(errors.map(e =\u003e e.message))),\n            finalize: () =\u003e patchState(store, setLoaded()),\n          })\n        )\n      ),\n  }),\n);\n```\n\n저희의 상태가 조금 줄어든 것을 보실 수 있고, 로딩 및 에러 기능을 추가하기 위해 플러그인을 사용했습니다. 앞으로는 메소드를 확장했습니다. 스토어를 인수로 사용하고 운영을 수행하기 위해 apollo 클라이언트를 주입했습니다.\n\n더불어 RxJs의 강력함을 활용하기 위해 rxMethod를 사용할 것입니다. loadAll 함수를 호출하면 void 타입의 스트림이 생성됩니다. 그런 다음 스트림에 탭하여 우리가 만든 함수를 통해 상태를 로딩으로 설정할 수 있습니다. 이를 통해 스피너 등을 표시할 수 있습니다. 요청으로 스트림을 전환하고 마지막으로 @ngrx/operators 패키지의 tapResponse 연산자를 활용할 것입니다. 여기서 next에는 상태의 데이터 필드에 Todos를 설정하고, 요청이 실패한 경우에는 오류를 설정하고, 스트림이 완료되면 로딩을 false로 설정할 수 있습니다.\n\n## Entity Management makes a comeback\n\n\n\n\n이 코드는 NgRx에 익숙한 사용자들에게 이미 알려진 기능 중 하나로, SignalStore에서도 entity 관리 확장이 되돌아왔습니다. 이 기능은 addEntity, setEntity, updateEntity, removeEntity와 같은 메소드를 통해 CRUD 작업을 간편하게 수행할 수 있도록 도와줍니다.\n\n아래는 저희의 스토어 최종 버전이며, 모든 CRUD 메소드가 해당 API 작업 및 상태 변이와 함께 구현된 것을 확인할 수 있습니다. rxMethod는 입력 스트림이 될 수 있는 아무 타입을 지정할 수 있습니다. 이는 가져올 할 일의 ID부터 업서트 작업을 위한 부분 또는 완전한 객체까지 다양할 수 있습니다. 이러한 매개변수를 메소드 호출에 추가하는 것이 필요합니다.\n\n또한, 보류 중인 할 일과 완료된 할 일에 해당하는 배열을 얻을 수 있는 계산된 값의 예제를 볼 수 있습니다. withComputed 메소드는 스토어를 매개변수로 사용하며, 이를 통해 선택적으로 해당 부분을 선택하여 확장할 수 있습니다. 저희의 경우, 기준에 따라 필터링된 entities를 선택했습니다.\n\n\n\n마침내 훅을 활용하게 됩니다. 이는 초기화 시 Todos를 로드하고 싶다는 것을 의미합니다. 실제로 스토어를 컴포넌트에 제공할 때 Todos는 이미 사전로드되어 있을 것입니다.\n\n## 계속 진행하겠습니다...\n\n드디어 우리가 구현한 상태 관리 기능을 어떻게 활용할 수 있는지 확인할 시간이 왔습니다. 사용자 인터페이스를 더 쉽게 구성하기 위해 Angular Material을 설치했으며 데이터를 목록으로 로드하거나 대화상자를 생성하는 등의 간단한 방법을 제공합니다.\n\n```js\n// todos.component.ts\n@Component({\n  selector: 'app-todo-list',\n  standalone: true,\n  templateUrl: './todos.component.html',\n  providers: [provideTodosStore()],\n  imports: [\n    MatDivider,\n    MatToolbar,\n    MatButton,\n    MatList,\n    MatListItem,\n    MatIconButton,\n    MatIcon,\n    MatLine,\n    CdkDropListGroup,\n    CdkDropList,\n    CdkDrag,\n  ],\n})\nexport class TodosComponent {\n\n  constructor(protected readonly store: TodosStore, protected readonly dialog: MatDialog) {}\n\n  changeTodoCompletion(event: CdkDragDrop\u003cTodo[]\u003e): void {\n    this.store.updateTodo({ id: event.item.data.id, completed: !event.item.data.completed });\n  }\n\n  openUpsertDialog(todo?: Todo): void {\n    this.dialog.open(TodoDialogComponent, { data: { todo } });\n  }\n}\n```\n\n\n\n```js\n\u003c!-- todos.component.html --\u003e\n\u003cmat-toolbar class=\"flex justify-between\" color=\"primary\"\u003e\n  \u003cspan\u003e할 일 목록\u003c/span\u003e\n  \u003cbutton mat-raised-button color=\"accent\" (click)=\"openUpsertDialog()\"\u003e할 일 추가\u003c/button\u003e\n\u003c/mat-toolbar\u003e\n\n\u003csection class=\"container mx-auto p-4 grid grid-cols-2 gap-4\"\u003e\n  \u003cdiv\u003e\n    \u003ch2 class=\"text-xl font-bold mb-2\"\u003e보류 중인 할 일\u003c/h2\u003e\n    \u003cmat-list cdkDropList [cdkDropListData]=\"store.pendingTodos()\" cdkDropListSortingDisabled #pending=\"cdkDropList\" [cdkDropListConnectedTo]=\"[completed]\" (cdkDropListDropped)=\"changeTodoCompletion($event)\"\u003e\n      @for(todo of store.pendingTodos(); track todo.id) {\n      \u003cmat-list-item cdkDrag [cdkDragData]=\"todo\"\u003e\n        \u003cmat-icon matListItemIcon class=\"text-gray-500\"\u003echeck_circle\u003c/mat-icon\u003e\n        \u003cdiv matLine class=\"flex justify-between align-middle\"\u003e\n          \u003cspan\u003e{ todo.text }\u003c/span\u003e\n          \u003cdiv\u003e\n            \u003cbutton mat-icon-button class=\"text-blue-500\" (click)=\"openUpsertDialog(todo)\"\u003e\n              \u003cmat-icon\u003eedit\u003c/mat-icon\u003e\n            \u003c/button\u003e\n            \u003cbutton mat-icon-button class=\"text-red-500\" (click)=\"store.removeTodo({ id: todo.id })\"\u003e\n              \u003cmat-icon\u003edelete\u003c/mat-icon\u003e\n            \u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/mat-list-item\u003e\n      } @empty {\n      \u003cp\u003e목록에 할 일이 없습니다.\u003c/p\u003e\n      }\n    \u003c/mat-list\u003e\n  \u003c/div\u003e\n\n  \u003cdiv\u003e\n    \u003ch2 class=\"text-xl font-bold mb-2\"\u003e완료된 할 일\u003c/h2\u003e\n    \u003cmat-list cdkDropList [cdkDropListData]=\"store.completeTodos()\" cdkDropListSortingDisabled #completed=\"cdkDropList\" [cdkDropListConnectedTo]=\"[pending]\" (cdkDropListDropped)=\"changeTodoCompletion($event)\"\u003e\n      @for(todo of store.completeTodos(); track todo.id) {\n      \u003cmat-list-item cdkDrag [cdkDragData]=\"todo\"\u003e\n        \u003cmat-icon matListItemIcon class=\"text-green-500\"\u003echeck_circle\u003c/mat-icon\u003e\n        \u003cdiv matLine class=\"flex justify-between align-middle\"\u003e\n          \u003cspan\u003e{ todo.text }\u003c/span\u003e\n          \u003cdiv\u003e\n            \u003cbutton mat-icon-button class=\"text-blue-500\" (click)=\"openUpsertDialog(todo)\"\u003e\n              \u003cmat-icon\u003eedit\u003c/mat-icon\u003e\n            \u003c/button\u003e\n            \u003cbutton mat-icon-button class=\"text-red-500\" (click)=\"store.removeTodo({ id: todo.id })\"\u003e\n              \u003cmat-icon\u003edelete\u003c/mat-icon\u003e\n            \u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/mat-list-item\u003e\n      } @empty {\n      \u003cp\u003e목록에 할 일이 없습니다.\u003c/p\u003e\n      }\n    \u003c/mat-list\u003e\n  \u003c/div\u003e\n\u003c/section\u003e\n```\n\n```js\n// todos-dialog.component.ts\n@Component({\n  selector: 'app-todo-upsert',\n  standalone: true,\n  template: `\u003ch2 mat-dialog-title\u003e{ id ? '할 일 수정' : '할 일 추가' }\u003c/h2\u003e\n\n    \u003cmat-dialog-content\u003e\n      \u003cform\u003e\n        \u003cmat-form-field\u003e\n          \u003cmat-label\u003e할 일\u003c/mat-label\u003e\n          \u003cinput matInput [formControl]=\"text\" /\u003e\n        \u003c/mat-form-field\u003e\n      \u003c/form\u003e\n    \u003c/mat-dialog-content\u003e\n\n    \u003cmat-dialog-actions\u003e\n      \u003cbutton mat-button (click)=\"dialogRef.close()\"\u003e취소\u003c/button\u003e\n      \u003cbutton mat-raised-button color=\"primary\" [disabled]=\"text.invalid\" (click)=\"upsertTodo()\"\u003e저장\u003c/button\u003e\n    \u003c/mat-dialog-actions\u003e`,\n  providers: [provideTodosStore()],\n  imports: [MatDialogModule, MatButtonModule, MatInputModule, ReactiveFormsModule],\n})\nexport class TodoDialogComponent {\n  protected readonly id?: string;\n  protected readonly text: FormControl\u003cstring\u003e;\n\n  constructor(\n    private readonly store: TodosStore,\n    protected readonly dialogRef: MatDialogRef\u003cTodoDialogComponent\u003e,\n    @Inject(MAT_DIALOG_DATA) data?: { todo?: Todo }\n  ) {\n    this.id = data?.todo?.id;\n    this.text = new FormControl(data?.todo?.text ?? '', {\n      validators: [Validators.required, Validators.minLength(2)],\n      nonNullable: true,\n    });\n  }\n\n  upsertTodo(): void {\n    if (this.id) {\n      this.store.updateTodo({ id: this.id, text: this.text.value });\n    } else {\n      this.store.addTodo({ text: this.text.value });\n    }\n    this.dialogRef.close();\n  }\n}\n```\n\n요약하면 CRUD 기능을 커플 컴포넌트에서 구현했습니다. 초기에 OnInit 후크를 통해 데이터를로드하는 목록이 있습니다. 이 목록에는 한 열에서 다른 열로 항목을 이동할 때 저장소 업데이트를 호출하는 드래그 앤 드롭 기능이 있습니다. 게다가, ID가 있는지 여부에 따라 업데이트 또는 추가 메서드를 호출하는 재사용 가능한 대화 상자가 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_1.png\" /\u003e\n\n\n\n\n## 마무리\n\n이제 우리는 NgRx SignalStore의 힘을 활용하여 Todo 애플리케이션의 API와 컴포넌트 사이의 레이어의 반응적 기초를 만들었습니다. 우리는 작업을 별도로 정의함으로써 API 상호작용이 매우 간단해지며, 따라서 따로 두지 않고 직접 저장소에 구현한 이유입니다.\n\n이를 통해 방법과 신호를 통해 결정론적인 데이터 흐름을 노출시켰는데, 이 때 신호는 직관적인 변경 감지 전략 및 UI 업데이트를 우아하게 수행하는 데 중요한 역할을 합니다.\n\n다음 기사에서는 데이터 모의를 어떻게 구현하여 개발 경험을 향상시킬 수 있는지, 그리고 테스트를 위한 프론트엔드 분리를 완벽하게 하는 방법을 소개할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png"},"coverImage":"/assets/img/2024-05-15-ArchitectingAngularPart2QueryingandManagingStatewithNgRxSignalStore_0.png","tag":["Tech"],"readingTime":11},{"title":"나의 우주 테마 Threejs 포트폴리오 사이트를 위해 사용자 정의 이질 변위 맵을 만드는 방법","description":"","date":"2024-05-15 02:55","slug":"2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite","content":"\n\n## 온라인에서 무료로 사용할 수 있는 미리 제작된 변위 맵의 부족에 놀라웠습니다. 나만의 변위 맵을 만들기가 얼마나 쉬운지에 더욱 놀랐죠.\n\n포트폴리오 사이트 작업 중 변위 맵과 관련된 흥미로운 문제를 만났습니다.\n\n잠깐 설명하자면, 일반적으로 그래픽을 다룰 때, 특히 Three.js 메쉬와 함께 작업할 때, 메쉬의 속성을 변경하기 위해 다양한 종류의 맵을 사용할 수 있습니다. 이 중 가장 간단한 것은 컬러 맵으로, 이 맵의 픽셀은 메쉬에 매핑됩니다. 제가 사용한 것과 같이 구 형상 기하학을 사용하는 경우, 컬러 맵을 구의 기하학적 형상을 장식하는 포장지와 같은 역할로 생각할 수 있습니다.\n\n간단히 말해, 변위 맵은 각 픽셀의 밝기가 해당 정점의 기하학적 형상을 얼마나 (맞죠!) 변위시킬지 결정하는 회색조 이미지입니다. Three.js 메쉬에 사용할 수 있는 다른 많은 종류의 맵이 있으며 다양한 목적으로 사용할 수 있습니다. Three의 MeshStandardMaterial 문서는 더 자세히 알아보고 싶다면 좋은 참고 자료입니다.\n\n\n\n내 옵션을 살펴본 후, 무작위로 생성된 소행성과 내가 만든 행성 중 하나에서 현실감을 더하기 위해 변위 매핑을 사용하기로 결정했습니다. 그러나 비교적 쉽게 찾을 수있는 좋은 색상 지도와는 다르게, 내가 필요로 하는 변위 맵을 찾기 어려웠습니다. 무료로 사용할 수 있는 옵션을 찾기는 더욱 어려웠습니다. 다행히도, 살짝 기발하고 실험을 통해 나만의 방법을 발견할 수 있었습니다.\n\n내 속임수에 대한 자세한 내용을 예고 없이 알려드리기 전에 두 가지 중요한 주의사항이 있습니다:\n\n1. 이 방법이 당신의 사용 사례에 맞지 않을 수 있습니다. 나는 이러한 변위 맵을 매우 특정한 목적으로 만들었습니다. 즉, 그것들이 다소 무작위로 보이면서 동시에 암석 형태의 비교적 부드러운 미학을 보존하기 위함이었습니다. 사용 방법은 개인에 따라 다를 수 있습니다.\n\n2. 이 방법은 아마도 여러분이 찾을 수 있는 가장 우아한 방법은 아닐 것입니다. 나보다 3D 모델링 및 애니메이션 분야에 더 정통한 사람들이나 돈을 들이고 싶어하는 사람들을 위해 더 깔끔한 솔루션이 있을 것입니다. 포토샵을 사용하여 처음부터 변위 맵을 만들 수 있습니다. Blender와 같은 도구를 사용하여 완전한 3D 모델을 만들거나 처음부터 변위 매핑에 의존하지 않고도 가능합니다. 그리고 제가 그 품질이나 가치를 검증할 수 없지만, 미리 제작된 변위 맵을 찾는 동안 상당한 가격으로 판매하고 있는 몇 개의 사이트도 발견했습니다.\n\n\n\n그렇게 해결을 마치고 난 다음, 무료로 그리고 어떠한 화려한 도구도 사용하지 않고 빠르게 나만의 암석 변위 지도를 만드는 방법을 소개할게요:\n\n1. 유료 변위 지도의 워터마크 미리보기를 발견한 후 Google Lens를 사용하여 비슷한 이미지를 무료로 찾았어요. 솔직히 말해서 이 시점에서 정확히 무엇을 찾고 있는지 정확히 모르겠었어요. 주로 나에게 적합한 변위 지도가 어떻게 생겼는지 탐색하고, 유료 지도의 미리보기에서 시작하는 것이 꽤 괜찮아 보였어요. 되돌아보면, 실제로는 그렇게 중요하지 않았어요. 가장 중요한 것은 흑백 이미지이며 흥미롭게 유지할 만큼 충분한 밝기 다양성을 가지고 있어야 했어요. 여기서 제 과정을 따르고 자신만의 변위 지도를 만들기 위해 이 글을 읽는다면, 이 단계를 건너뛰고 무료로 사용할 수 있는 흑백 이미지를 선택하거나 아래 제가 제공하는 이미지 중 하나를 사용할 수 있어요.\n\n2. 좋은 후보 이미지로 보이는 몇 장의 이미지를 골랐어요. 또한 선택한 몇 장의 이미지를 기반으로 새 Lens 검색을 실행했어요. 마지막으로 좁힌 두 가지 이미지는 화성의 협곡을 보여주는 퍼블릭 도메인 이미지와 우연히도 화성 상의 소금 함유물에 관한 NASA 이미지였어요.\n\n3. 이미지를 자르고 정사각형으로 만들고 합리적인 해상도로 크기를 조정했어요, 512x512 픽셀. 일반적으로 맵은 정사각형이어야 하며, 높이/너비는 2의 거듭제곱이어야 해요. 대부분의 응용 프로그램에서 512x512가 충분할 것이며, 세부사항을 희생하지 않으면서도 성능을 향상시키기 위해 256x256까지 낮출 수도 있어요.\n\n4. 이미지의 1/4를 다른 이미지로 복사했어요. 실제로 사용한 변위 지도 중 하나에만 이렇게 한 적이 있어요. 처음에는 지표 면에 어떠한 이음선도 나타나지 않도록 하기 위해 이렇게 했어요. 이론적으로, 맵을 다룰 때, 이미지의 왼쪽 색과 오른쪽 색이 완전히 일치해야 하기 때문에 경계가 이상하게 보이지 않아야 해요. 실제로, 두 번째 맵에 이 단계를 건너뛰어보았고 결과는 완전히 괜찮았어요.\n\n5. 각 이미지 상단과 하단에 수평선을 추가했어요. 이유는 이전 단계와 비슷하지만, 이번에는 이 작업이 상당히 중요했어요. 이미지의 상단과 하단 가장자리 픽셀의 밝기가 완벽하게 일치하지 않으면, 구와의 극에 눈에 띄는 효과가 나타날 수 있어요. 이 시점에서 맵은 다음과 같이 보였어요:\n\n6. 이미지를 흐리게 해 왜곡을 완화했어요. 5단계 후에 만족스러운 진행을 이룬 것에 대해 만족스러웠지만, 결과물이 원하는 대로 이루어진 것 같지 않았어요. 행성과 소행성 표면의 버팀목은 분명히 눈에 띄었지만, 취향에 너무 뾰족하고 울퉁불퉁했어요. (가시적인 왜곡을 찾고 있다면, 이 단계를 건너뛰어보세요.) Blur의 각 이미지에 대해 다른 레벨의 흐림을 실험했고, 골디락스 영역에 도달할 때까지 계속해보았어요. 이미지를 흐리게 하기 과정에서 선을 다시 추가해야 했는데, 이미지의 희미화 과정에서 선들이 흡수되었기 때문이었어요.\n\n\n\n## 그리고 요렇게! 두 개의 좋은 작은 왜곡 지도가 나왔어요:\n\n내가 정확히 필요한 것을 위해 기능하는 방법을 안내받아 기쁨으로 가득 찼어. 당신이 원한다면 네 자신의 프로젝트에 사용해도 괜찮아.\n\n## 완성된 사이트에서 암석 행성과 소행성이 어떻게 보이는지 확인해보세요.\n\n## 프로젝트의 소스 코드를 확인해보세요\n\n\n\n이 기사는 저가 개발한 소셜 블로깅 사이트 COACSS에서 2022년 8월 28일에 원래 게시되었습니다.\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/assets/img/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite_0.png"},"coverImage":"/assets/img/2024-05-15-HowICreatedCustomDisplacementMapsforMySpace-ThemedThreejsPortfolioSite_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터가 중요해요 레일즈에서 데이터베이스 관리와 최적화를 위한 상위 10가지 보석","description":"","date":"2024-05-15 02:53","slug":"2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails","content":"\n\n이미지를 Markdown 형식으로 변경했습니다!\n\n물론입니다! 이제 여러분의 Ruby on Rails 애플리케이션의 성능을 캐싱 기술과 최적화 전략을 통해 엄청나게 향상시킬 수 있는 상위 10개의 Ruby Gems로 들어가 봅시다. 이러한 Gems는 귀하의 개발 워크플로우를 크게 개선하고 코드 품질을 향상시키며 보안을 강화할 수 있습니다. 여기 그 목록입니다:\n\n- Dalli:\n\n- Dalli은 Memcached 캐싱 시스템과 귀하의 Ruby 애플리케이션을 연결하는 강력한 인터페이스를 제공하는 인기 있는 Ruby Gem입니다. Memcached는 키-값 쌍을 메모리에 저장하여 데이터베이스의 부하를 줄이고 자주 사용되는 데이터에 빠르게 액세스할 수 있도록 도와줍니다.\n\n\n\n# Memcached-Rails:\n\n- Memcached-Rails는 Memcached 서버에 연결하는 데 사용됩니다. Memcached는 데이터를 캐시하고 검섹의 배경 처리를 위한 큐를 만드는 데 사용됩니다.\n\n```js\n# Memcached 서버에 연결\ncache = Dalli::Client.new('localhost:11211')\n# 캐시에 데이터 저장\ncache.set('user:123', { name: 'John Doe', email: 'john@example.com' })\n# 캐시에서 데이터 가져오기\nuser_data = cache.get('user:123')\n```\n\n2. Redis-Rails:\n\n- Redis-Rails는 Redis, 메모리 내 데이터 구조 저장소와 Ruby on Rails 애플리케이션을 통합합니다. Redis를 사용하면 데이터를 캐시하거나 세션 스토리지를 관리하고, 백그라운드 처리를 위한 큐를 생성할 수 있습니다.\n\n```js\n# config/initializers/redis.rb에서 Redis 연결 구성\n$redis = Redis.new(host: 'localhost', port: 6379)\n# Redis 캐시에 데이터 저장\n$redis.set('product:123', { name: 'Widget', price: 19.99 })\n# Redis 캐시에서 데이터 가져오기\nproduct_data = $redis.get('product:123')\n```\n\n\n\n3. ActiveSupport::Cache:\n\n- ActiveSupport::Cache는 루비 온 레일의 핵심 구성 요소로, 통합된 캐싱 인터페이스를 제공합니다. Memcached, Redis 및 파일 기반 캐싱과 같은 다양한 캐싱 저장소를 지원합니다.\n\n```ruby\n# config/environments/development.rb에서 캐싱 저장소 구성\nconfig.cache_store = :mem_cache_store, 'localhost:11211'\n# 캐시에 데이터 저장\nRails.cache.write('user:123', { name: 'Jane Smith', email: 'jane@example.com' })\n# 캐시에서 데이터 검색\nuser_data = Rails.cache.read('user:123')\n```\n\n4. Rack::Cache:\n\n\n\n- Rack::Cache는 루비 웹 애플리케이션을 위한 HTTP 캐싱을 제공하는 미들웨어입니다. 웹 서버와 앱 사이에서 중계 역할을 하며 HTTP 헤더에 따라 응답을 캐시할 수 있도록 합니다.\n\n```ruby\n# config.ru에 Rack::Cache 미들웨어 추가\nrequire 'rack/cache'\nuse Rack::Cache\n# 앱에서 캐싱 옵션 정의\nclass MyApp \u003c Sinatra::Base\n  set :static_cache_control, [:public, max_age: 3600]\n  set :dynamic_cache_control, [:public, max_age: 600]\nend\n```\n\n5. Bullet:\n\n- Bullet는 레일즈 애플리케이션에서 N+1 쿼리 문제를 식별하는 데 도움을 주는 젬(Gem)입니다. 단일 쿼리로 해결 가능한 상황에서 여러 개의 데이터베이스 쿼리를 수행하는 경우를 감지합니다. 데이터베이스 쿼리를 최적화함으로써 데이터베이스 서버 부하를 줄이고 응답 시간을 개선할 수 있습니다.\n\n\n\n```rb\n# In your development.rb or production.rb\nconfig.after_initialize do\n  Bullet.enable = true\n  Bullet.alert = true\n  Bullet.bullet_logger = true\nend\n```\n\n6. Rack Mini Profiler:\n\n- Rack Mini Profiler는 귀하의 Rails 애플리케이션을 위한 가벼운 프로파일러를 제공합니다. 요청-응답 주기의 각 부분에 소요된 시간을 측정하여 성능 병목 현상을 식별하는 데 도움을 줍니다. 느린 데이터베이스 쿼리, 뷰 렌더링 시간 등을 쉽게 식별할 수 있습니다.\n- Gemfile에 다음 Gem을 추가해주세요:\n\n```rb\ngem 'rack-mini-profiler', require: false\n```\n\n\n\n\n```ruby\nrequire 'rack-mini-profiler'\nRack::MiniProfilerRails.initialize!(Rails.application)\n```\n\n7. Database Cleaner:\n\n- Database Cleaner는 테스트 중 깨끗한 데이터베이스를 유지하는 데 필수적입니다. 이를 통해 각 테스트 후 데이터베이스 레코드를 정리함으로써 일관된 상태에서 테스트 스위트를 실행할 수 있습니다. 이를 통해 데이터 오염을 방지하고 테스트 신뢰성을 향상시킬 수 있습니다.\n\n\n\n\n\n# spec_helper.rb 또는 rails_helper.rb 파일에서\nrequire 'database_cleaner'\nDatabaseCleaner.strategy = :transaction\n\n\n8. Ransack:\n\n- Ransack은 Rails 애플리케이션에서 복잡한 검색 폼을 간단하게 만들어줍니다. 사용자 입력을 기반으로 레코드를 검색하고 정렬하기 위한 SQL 쿼리를 생성합니다. Ransack을 사용하면 사용자 정의 SQL 쿼리를 작성하지 않고도 강력한 검색 기능을 만들 수 있습니다.\n\n```ruby\n# 컨트롤러에서\ndef index\n  @q = Product.ransack(params[:q])\n  @products = @q.result(distinct: true)\nend\n```\n\n\n\n9. Puma:\n\n- Puma는 루비 애플리케이션을 위한 고성능 웹 서버입니다. 여러 동시 요청을 효율적으로 처리하기 위해 설계되었습니다. Puma를 사용하면 애플리케이션의 확장성과 응답성을 향상시킬 수 있습니다.\n\n```js\ngem 'puma' [Gemfile에 추가]\n```\n\n10. Bullet Train:\n\n\n\n- Bullet Train은 Bullet Gem의 확장 프로그램입니다. 사용되지 않는 eager loading 및 누락된 인덱스를 감지하는 추가 기능을 제공합니다. 이러한 문제를 해결함으로써 응용 프로그램의 데이터베이스 쿼리를 더욱 최적화할 수 있습니다.\n\n```js\n# 개발 환경 또는 운영 환경의 설정 파일에서\nconfig.after_initialize do\n  Bullet.enable = true\n  Bullet.add_footer = true\n  Bullet.raise = true\nend\n```\n\n이 Gem들을 추가로 탐험하고 특정 사용 사례에 맞게 적용하는 것을 기억해두세요. 즐거운 최적화하세요! 😊🚀","ogImage":{"url":"/assets/img/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails_0.png"},"coverImage":"/assets/img/2024-05-15-DataMattersTop10GemsforDatabaseManagementandOptimizationinRails_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 취미생활 25 Angular과 Wiz가 통합되며, React와 Angular의 차이점, 등등","description":"","date":"2024-05-15 02:52","slug":"2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore","content":"\n\n## 2024년 4월 제가 좋아하는 Angular 자료\n\n![이미지](/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png)\n\n# 👋안녕하세요, Angular 애딕트 여러분\n\n이것은 Angular Addicts 뉴스레터의 25번째 호입니다. 매달 선별된 Angular 자료들로 구성되어 있습니다. (여기서는 24번째, 23번째, 22번째 호를 찾아볼 수 있어요.)\n\n\n\n# 💎2024년 4월의 Angular 보물들\n\n## 📰 Angular과 Wiz, 함께하는 게 더 좋아요\n\nGoogle은 두 개의 웹 프레임워크를 가지고 있어요: Angular과 Wiz. 옛날부터 Wiz는 성능이 중요한 앱에 초점을 맞추고, Angular은 매우 상호 작용적인 앱을 제공하는 데 초점을 맞췄어요. Jatin Ramanathan과 Minko Gechev는 두 프레임워크 사이의 차이점과 이후 몇 년 동안 두 프레임워크가 점차적으로 통합될 것임을 설명한 기사를 소개했어요.\n\n## 📰 Figma, Storybook 및 Angular로 디자인부터 코드 플로우 마스터하기\n\n\n\nMarkus Nissl씨는 4부작 시리즈에서 Figma, Storybook 및 Angular 간의 상호 관계를 통해 디자인 및 개발에 대한 현대적인 워크플로우를 보여줍니다:\n\n- Part 1: Design tokens\n- Part 2: Figma의 변수\n- Part 3: Figma에서 변수(디자인 토큰) 추출\n- Part 4: Angular 컴포넌트에 디자인 토큰 적용\n\n## 📰 드디어 누군가가 JavaScript를 고쳤습니다\n\nEffect는 개발자가 복잡한 동기화 및 비동기 프로그램을 쉽게 만들 수 있도록 설계된 강력한 TypeScript 라이브러리입니다. Almaju는 Effect의 네 가지 기능을 소개합니다.\n\n\n\n- 동시성 처리\n- 안전한 오류 처리\n- 브랜드 타입 및\n- 의존성 주입\n\n## 📰 Angular와 React 간의 이해\n\nMaksim Dolgikh은 두 가지 주요 웹 기술 사이의 차이를 이해하는 데 도움이 되도록 일련의 기사를 썼습니다:\n\n- Angular와 React 간의 이해. 파트 1: Dumb \u0026 Smart Components\n- Angular와 React 간의 이해. 파트 2: Lifecycle hooks\n- Angular와 React 간의 이해. 파트 3: Services \u0026 Context API\n\n\n\n## 📖 모던 앵귤러\n\n만프레드 스테이어가 무료 e-book '모던 앵귤러'의 두 번째 판을 출시했습니다. 이 책은 14개의 챕터로 구성되어 있으며 다음과 같은 주제를 다룹니다:\n\n- 독립형 컴포넌트, 디렉티브 및 파이프의 구현\n- 기존 코드 및 NgModules과의 호환성\n- 라우팅, 지연 로딩, DI 및 상태 관리\n- 독립형 컴포넌트와 함께 Angular Elements/Web Components 사용\n- NgModules 없이 현대적인 아키텍처\n- 시그널의 성공적인 활용\n- 새로운 내장형 제어 흐름과 @defer\n- 자동 이전 버전 전환을 위한 옵션\n- esbuild, SSR 및 Hydration\n\n# 👨‍💻저자 소개\n\n\n\n나의 이름은 Gergely Szerovay이고, 많은 해 동안 데이터 과학자 및 풀 스택 개발자로 일해왔습니다. 현재는 Angular 기반 프런트엔드 개발에 중점을 둔 프런트엔드 기술 리드로 일하고 있습니다. 제 역할의 일환으로 Angular 및 프런트엔드 개발 영역이 어떻게 발전하고 있는지 지속적으로 관찰하고 있습니다.\n\nAngular는 지난 몇 년 동안 빠르게 발전해왔으며, 작년에는 생성적 AI의 등장으로 소프트웨어 개발 워크플로우도 빠르게 발전해왔습니다. AI 보조 소프트웨어 개발의 발전을 밀접히 따라가기 위해 공개적으로 AI 도구를 개발하기로 결심했고, AIBoosted.dev 에 진행 상황을 게시하기로 했습니다. 여기에서 구독하세요 🚀\n\nAngular, AI와 함께 AI 앱을 만드는 방법에 대해 자세히 알아보려면 Substack(Angular 중독자), Substack(AIBoosted.dev), Medium, Dev.to, X 또는 LinkedIn에서 저를 팔로우해 주세요!\n\n# 📨 귀하의 Angular 자료를 제출하세요\n\n\n\n요즘 흥미로운 Angular 관련 기사, 트윗 또는 다른 자료를 발견하거나 작성했나요? 댓글로 알려주세요. 또는 트위터 DM으로 보내주세요! 제가 다음 Angular Addicts 이슈에서 소개할 수도 있어요!","ogImage":{"url":"/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png"},"coverImage":"/assets/img/2024-05-15-AngularAddicts25AngularandWizwillbemergedthedifferencesbetweenReactandAngularmore_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터 과학을 위한 도커의 직관적인 안내","description":"","date":"2024-05-15 02:49","slug":"2024-05-15-AnIntuitiveGuidetoDockerforDataScience","content":"\n![An Intuitive Guide to Docker for Data Science](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png)\n\n데이터 과학자로 일할 때, 모든 운영 체제에서 실행되고 필요한 종속성이 모두 갖춰진 코드를 작성하고 클라우드에 배포할 수 있어야 합니다. 노력에도 불구하고 작동하지 않을 수 있고 문제가 무엇인지 이해하는 데 시간을 낭비할 수도 있습니다.\n\n이 고통을 피하기 위해 어떤 도구를 사용할 수 있을까요? Docker가 여러분의 문제를 해결해 줄 것입니다. Docker를 사용하면 데이터 과학 프로젝트를 위한 견고한 환경을 손쉽게 얻을 수 있습니다. 미치도록 미쳐버리지 않고요.\n\n이 글에서는 Docker의 주요 개념, 가장 일반적인 명령어, 그리고 Docker화된 머신러닝 애플리케이션의 빠른 예제에 대해 설명하겠습니다. 시작해 봅시다!\n\n목차:\n\n- Docker란 무엇인가?\n- Docker의 기본 개념\n- 가상 머신 대 컨테이너\n- Docker 설정\n- ML 애플리케이션 도커화\n- Docker 명령어 요약\n- Docker의 한계\n\n## Docker란 무엇인가?\n\nDocker는 매우 인기 있는 가상화 기술로, 개발자가 몇 분 내에 머신러닝 애플리케이션을 신속하게 개발, 실행 및 배포할 수 있도록 합니다.\n\n표 태그를 Markdown 형식으로 변경할 수 있습니다.\n\nContainers를 통해 응용 프로그램을 빠르고 일관된 방식으로 실행할 수 있는 격리된 환경을 포함할 수 있습니다.\n\n이 플랫폼을 사용하면 인프라와 응용 프로그램을 동시에 관리할 수 있습니다. 또한 코드를 작성하고 배포하는 시간을 줄일 수 있습니다.\n\n## Docker의 기본 개념\n\n![Docker 이미지](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_1.png)\n\n더 진행하기 전에, Docker와 관련된 세 가지 개념을 잘 알고 가는 것이 중요합니다:\n\n- Docker File에는 Docker Image를 빌드하는 데 사용되는 지시 사항이 포함되어 있습니다. 운영 체제를 정의하거나 애플리케이션의 종속성을 지정하는 등의 작업이 이루어집니다.\n- Docker Image는 Docker File에서 시작하여 빌드할 때 만들어집니다.\n- Docker Container는 Docker Image를 실행한 후에 얻어집니다. 어디에서든 실행할 수 있는 격리된 독립 환경입니다.\n\n위 그림을 살펴보면 개념을 더 잘 이해할 수 있습니다. Docker File은 케이크 레시피와 유사한 개념이며, 우리가 관심을 갖는 대상의 재료가 정의되어 있습니다. Docker Image는 반죽이고 Docker Container는 우리가 원하는 케이크입니다.\n\n## 가상 머신 대 컨테이너\n\n![Docker Image](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_2.png)\n\n가상 머신과 컨테이너는 물리적 인프라 내에서 여러 격리된 환경을 실행할 수 있게 해주는 가상화 기술입니다. 둘 다 리소스와 비용을 최적화하기 위해 고안되었지만, 중요한 차이점이 있습니다.\n\n가상 머신 내에는 각각 다른 게스트 운영 체제가 실행됩니다. 그에 비해 컨테이너는 호스트 운영 체제를 공유하여 가상 머신보다 적은 리소스를 사용합니다.\n\n컨테이너는 애플리케이션과 해당 의존성만 캡슐화하기 때문에 매우 휴대성이 뛰어나며 배포 프로세스를 더 쉽고 빠르게 만들어줍니다.\n\n## Docker 설정하기\n\n![Docker Desktop](/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_3.png)\n\nDocker Desktop은 컨테이너화된 응용 프로그램을 빌드하고 공유하며 실행하는 데 필요한 응용 프로그램입니다. Linux, Windows 또는 Mac에 설치할 수 있습니다.\n\nDocker Hub에 이미지를 만들고 푸시하려면 Docker Hub에 계정을 만들어야 합니다. Docker Hub는 Docker 이미지를 찾고 공유할 수 있는 중앙 저장소입니다.\n\n## ML 애플리케이션 도커화하기\n\n도커의 개념을 익히셨다면, 이제 머신 러닝 애플리케이션을 도커화하는 예제를 보여드릴 시간입니다. 튜토리얼을 쉽게 따라가기 위해 Visual Studio Code를 코드 편집기로 사용하는 것을 권장합니다.\n\n이 미니 프로젝트에서는 캐글(Kaggle)의 Tours and Travels Churn Prediction 데이터셋을 사용할 것입니다. 따라서 여행 회사의 고객이 연령, 연간 서비스 등 여러 변수를 기반으로 이탈할지 여부를 예측하는 작업을 진행하겠습니다.\n\n튜토리얼을 더 잘 따라가기 위해 GitHub 저장소를 확인해보세요.\n\n고객 이탈 예측 데이터셋을 로드합니다.\n\n```Python\nchurn_df = pd.read_csv('Customertravel.csv')\nX = churn_df.drop(columns=['Target'],axis=1)\ny = churn_df['Target']\n\n# 데이터 분할\nX_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=123)\nX_train, X_val, y_train, y_val = train_test_split(X_train,y_train,test_size=0.2,random_state=123)\ntrain_data = Pool(data=X_train,label=y_train,cat_features=[1,2,4,5])\nval_data = Pool(data=X_val,label=y_val,cat_features=[1,2,4,5])\ntest_data = Pool(data=X_test,label=y_test,cat_features=[1,2,4,5])\n\n# CatBoost 모델 훈련\nmodel = CatBoostClassifier(n_estimators=500,\n                           learning_rate=0.1,\n                           depth=4,\n                           loss_function='Logloss',\n                           random_seed=123,\n                           verbose=True)\nmodel.fit(train_data,eval_set=val_data)\n\n# 예측 생성\ny_train_pred = model.predict(train_data)\ny_val_pred = model.predict(val_data)\ny_test_pred = model.predict(test_data)\n\n# 정밀도와 재현율 계산\ntrain_precision_score = precision_score(y_train, y_train_pred)\ntrain_recall_score = recall_score(y_train, y_train_pred)\nval_precision_score = precision_score(y_val, y_val_pred)\nval_recall_score = recall_score(y_val, y_val_pred)\ntest_precision_score = precision_score(y_test, y_test_pred)\ntest_recall_score = recall_score(y_test, y_test_pred)\n\n# 정밀도와 재현율 출력\nprint(f'Train 정밀도: {train_precision_score}')\nprint(f'Val 정밀도: {val_precision_score}')\nprint(f'Test 정밀도: {test_precision_score}')\nprint(f'Train 재현율: {train_recall_score}')\nprint(f'Val 재현율: {val_recall_score}')\nprint(f'Test 재현율: {test_recall_score}')\n```\n\n- requirements.txt 파일 생성\n\n저희 애플리케이션을 도커로 쉽게 사용하기 위해 모든 파이썬 의존성이 포함된 requirements.txt 파일이 필요합니다.\n\n라이브러리 pigar을 설치하고 터미널에서 pigar generate 명령을 실행하여 자동으로 생성할 수 있습니다.\n\n다음과 같은 파일을 얻어야 합니다:\n\ncatboost==1.2.5\npandas==2.2.2\nscikit-learn==1.4.2\n\n2. Create Dockerfile\n\nAlong with requirements.txt, let's create a file called Dockerfile. This file consists of instructions for building the Docker Image.\n\n```js\nFROM python:3.10\n\nWORKDIR /src\n\n# Copy the requirements file and install dependencies\nCOPY train_churn_model.py requirements.txt Customertravel.csv /src/\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Run the script\nCMD [\"python\",\"train_churn_model.py\"]\n```\n\nFROM 명령은 프로젝트에 사용되는 기본 환경을 지정합니다. 이 경우 Python 3.10이었습니다.\n\n작업 디렉토리를 설정하고 requirements.txt, train_churn_model.py 그리고 Customertravel.csv 파일을 복사한 후 requirements.txt 파일을 복사하면 종속성을 설치할 수 있습니다.\n\n마지막으로 CMD 명령을 사용하여 스크립트를 실행하는 명령을 포함할 수 있습니다.\n\n3. 도커 이미지 빌드\n\n파일 requirements.txt와 Dockerfile을 생성했다면, 대부분의 작업이 끝났어요. Docker 이미지를 생성하기 위해서는 빌드 명령어를 사용하기만 하면 돼요:\n\n```js\ndocker build -t churn-pred-image .\n```\n\n\"churn-pred-image\"라는 이름으로 Docker 이미지를 생성한 후에는 모든 이미지를 확인해 보세요. 우리가 이미지를 성공적으로 만들었는지 확인하는 것이 중요하니까요.\n\n```js\ndocker images\n```\n\n다음은 명령어에서 얻은 이미지 목록입니다:\n\n```js\nREPOSITORY         TAG       IMAGE ID       CREATED             SIZE\nchurn-pred-image   latest    f2d735527110   About an hour ago   1.81GB\n```\n\n다른 이미지를 만든 경우 테이블에 더 많은 행이 포함될 것이며, 각각 다른 이미지에 해당합니다.\n\n4. Docker 컨테이너를 빌드하세요.\n\n드디어, Docker 컨테이너를 만들 준비가 되었습니다. 이미지를 빌드했으므로 이제 컨테이너를 실행하기만 하면 됩니다:\n\n```js\ndocker run -d --name churn-pred-container churn-pred-image\n```\n\n--name 태그에서는 Docker 컨테이너의 이름을 지정하고, 뒤에 이전에 빌드한 Docker 이미지의 이름을 적어주면 됩니다.\n\n이전처럼 flag -a를 사용하여 지금까지 생성된 모든 컨테이너를 표시하려면:\n\n```js\n도커 ps -a\n```\n\n요 출력입니다:\n\n```js\nCONTAINER ID   IMAGE              COMMAND                  CREATED             STATUS                      PORTS     NAMES\n7865084c8e70   churn-pred-image   \"python train_churn_…\"   약 한 시간 전        Exited (0) 17 minutes ago             churn-pred-container\n```\n\n그게 다야! 머신러닝 애플리케이션을 도커화했어요!\n\n## 도커 명령어 요약\n\n- 도커 이미지를 빌드하려면 docker build -t `내-이미지-이름`을 사용하세요.\n- 도커 컨테이너를 빌드하려면 docker run -d --name `내-컨테이너-이름` `내-이미지-이름`을 사용하세요.\n- 생성된 이미지 목록을 확인하려면 docker images를 사용하세요.\n- 컨테이너 목록을 보려면 docker ps -a를 사용하세요.\n- 이미지를 제거하려면 docker rmi `내-이미지-id`를 사용하세요.\n- 실행 중인 컨테이너를 중지하려면 docker stop `내-컨테이너-id`를 사용하세요.\n- 중지된 컨테이너를 제거하려면 docker rm `내-컨테이너-id`를 사용하세요.\n\n## 도커의 한계\n\n다른 가상화 기술과 마찬가지로 도커에도 일부 제약이 있습니다. 이는 주요 단점으로서 다음과 같습니다:\n\n- 도커 파일을 작성하고 이미지를 빌드하며 컨테이너를 관리하는 방법을 처음 접하는 경우에는 시간이 필요할 수 있어요.\n- 컨테이너는 VM보다 가벼우며 더 적은 리소스가 필요하지만, 동일한 운영 체제로 인해 보안 문제가 발생할 수 있어요.\n- 도커는 GPU가 필요하지 않은 응용 프로그램을 위해 초기에 설계되었기 때문에 그래픽 사용자 인터페이스가 필요한 사용 사례에서 어려움을 겪을 수 있어요.\n\n## 마무리\n\n이것은 도커를 시작하는 데 도움이 될 수 있는 입문 가이드였어요.\n\n도커는 데이터 과학 프로젝트에 강력한 도구가 될 수 있어요. 특정 사용 사례에 도커가 적합한 선택인지 고려하기 위해서는 장단점을 고려하는 것이 중요해요.\n\n만약 주제를 더 자세히 알아보고 싶다면, 기사 끝에 나열된 자료들을 살펴보세요.\n\n기사가 유용했다면 좋겠습니다. 즐거운 하루 되세요!\n\n면책 조항: 이 데이터셋은 CC0 1.0 Universal (CC0)로 라이센스가 부여되어 있습니다.\n\n유용한 자료:\n\n- 도커 가이드\n- 도커파일 참조\n- 도커 CLI를 위한 기본 명령어\n","ogImage":{"url":"/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png"},"coverImage":"/assets/img/2024-05-15-AnIntuitiveGuidetoDockerforDataScience_0.png","tag":["Tech"],"readingTime":7},{"title":"서버 감시 마스터하기 Socketio를 사용하여 온라인 장치 추적하기","description":"","date":"2024-05-15 02:47","slug":"2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png\" /\u003e\n\n서버에 연결된 디바이스의 정확한 수를 파악하는 것은 오늘날의 네트워크화된 디지털 환경에서 효율성, 보안 및 전반적인 성능을 유지하는 데 중요합니다. 귀하가 거대한 네트워크 인프라나 소규모 웹 사이트를 담당하고 있든 상관없이 온라인 환경의 동력을 파악하는 것이 모든 차이를 만들 수 있습니다. 다행히도 Socket.io라는 실시간 웹 애플리케이션 엔진을 통해 디지털 풍경에 대한 중요한 정보를 제공받을 수 있습니다. 이 게시물에서는 Socket.io를 사용하여 서버에 연결된 온라인 디바이스를 모니터링하는 방법에 대해 자세히 살펴보며 초보자와 숙련된 개발자 모두에게 포괄적인 설명서를 제공할 것입니다.\n\n서버에 연결된 인터넷 디바이스를 모니터링하기 위해 Socket.io의 기능을 활용하는 첫 번째 단계는 Node.js 프로젝트를 설정하는 것입니다. 다음 간단한 단계를 따라 프로젝트를 시작하세요:\n\n- Node.js 설치: 아직 설치하지 않은 경우 공식 웹 사이트에서 Node.js를 다운로드하고 설치하세요. Node.js에는 프로젝트 의존성 관리에 사용할 npm(Node Package Manager)이 함께 제공됩니다.\n- 프로젝트 디렉토리 생성: 파일 시스템에서 적절한 위치를 선택하고 프로젝트용 새 디렉토리를 만드세요. 명령줄을 사용하여 mkdir 명령 다음에 선택한 디렉토리 이름을 입력하여 이 작업을 수행할 수 있습니다.\n\n\n\n```bash\nmkdir socketio\n```\n\n3. 프로젝트 디렉토리로 이동: cd 명령어를 사용하여 새로 생성한 프로젝트 디렉토리로 이동합니다.\n\n```bash\ncd socketio\n```\n\n4. Node.js 프로젝트 초기화: npm init 명령어를 사용하여 새로운 package.json 파일을 생성합니다. 이 파일은 프로젝트 및 의존성에 대한 메타데이터를 저장하게 됩니다. 프로젝트 이름, 버전, 설명 등의 세부 정보를 입력하도록 프롬프트에 따라 진행하며, 대부분의 경우 기본값을 사용하기 위해 Enter 키를 누를 수 있습니다.\n\n\n\n\n1. npm으로 초기화하세요.\n   \n   js\n   npm init\n   \n\n2. 필요한 패키지 설치: 이제 프로젝트에 필요한 패키지를 설치해봅시다. 웹 서버를 만들기 위해 express와 실시간 통신을 위해 socket.io가 필요합니다.\n\n   js\n   npm install express socket.io http\n   \n\n3. 프로젝트 파일 생성: 주로 index.js와 같이 이름 지어지는 주 서버 파일을 만들고, 서버 설정 및 Socket.io 연결을 처리할 코드를 작성하세요.\n\n\n\n\n```js\nconst express = require(\"express\");\nconst socketIO = require(\"socket.io\");\nconst server = require(\"http\").createServer(app);\nconst PORT = process.env.PORT || 3001;\nconst io = socketIO(server, {\n  cors: {\n    origin: \"*\",\n    methods: \"GET\", \"POST,\"\n  },\n});\nlet userCount = 0;\nio.on(\"connection\", (socket) =\u003e {\n  userCount++;\n  io.emit(\"userCount\", userCount);\n\n  socket.on(\"disconnect\", () =\u003e {\n    userCount--;\n    io.emit(\"userCount\", userCount);\n  });\n});\nserver.listen(PORT, () =\u003e {\n  console.log(\"Server is running on port \" + PORT);\n});\n```\n\n**Node.js 서버 시작하기:** 메인 서버 파일을 node 명령어를 사용하여 실행하여 Node.js 서버를 시작합니다.\n\n```js\nnode index.js\n```\n\n**서버 출력 확인:** 서버가 부팅되면 지정된 포트에서 영역화되고 작동 중임을 나타내는 출력을 확인해야 합니다. 서버가 구성된 방식에 따라, 여기에서는 \"서버가 3001 포트에서 청취 중입니다\" 라는 메시지가 표시됩니다.\n\n\n\n\n소켓 이벤트를 수신하고 실시간으로 연결된 사용자 수를 파악할 수 있어요.\n\n방법 1: 웹페이지에서\n\nHTML 템플릿 생성하기\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003ctitle\u003e실시간 사용자 수\u003c/title\u003e\n    \u003cstyle\u003e\n      body {\n        font-family: Arial, sans-serif;\n        text-align: center;\n        padding-top: 50px;\n      }\n      #userCount {\n        font-size: 48px;\n        font-weight: bold;\n        color: #333;\n      }\n    \u003c/style\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003ch1\u003e연결된 사용자 수\u003c/h1\u003e\n    \u003cdiv id=\"userCount\"\u003e\u003c/div\u003e\n    \u003cscript src=\"https://cdn.socket.io/4.4.1/socket.io.min.js\"\u003e\u003c/script\u003e\n    \u003cscript\u003e\n      const socket = io(\"http://localhost:3001\");\n      socket.on(\"connect\", () =\u003e {\n        console.log(\"Socket.IO 서버에 연결되었습니다\");\n      });\n      socket.on(\"userCount\", (count) =\u003e {\n        document.getElementById(\"userCount\").textContent = count;\n      });\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\n\n우리는 이전에 HTML에서 시작한 서버에 연결 중이며, 연결할 때마다 서버는 \"userCount\"라는 이름의 이벤트를 생성하여 해당 서버에 연결된 사용자에 대한 정보를 포함합니다.\n\n방법 2: NodeJs 사용\n\n```js\nconst io = require(\"socket.io-client\");\nconst socket = io(\"http://localhost:3001\");\nsocket.on(\"connect\", () =\u003e {\n    console.log(\"Socket.IO 서버에 연결되었습니다\");\n});\nsocket.on(\"userCount\", (count) =\u003e {\n    console.log(\"연결된 사용자 수:\", count);\n});\n```\n\n요약하자면, Socket.io와 Node.js는 실시간 사용자 모니터링을 가능하게 함으로 효과적으로 작동합니다. Socket.io를 Node.js 환경에 통합함으로써 개발자는 쉽게 사용자 행동과 서버 성능을 모니터링할 수 있습니다. 이는 예방적인 서버 자원 관리를 가능하게 하여 완벽한 사용자 경험을 보장합니다. Socket.io의 중요한 사용자 연결에 대한 통찰력을 활용함으로써 개발자는 확장 가능하고 반응성 있는 응용프로그램을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png"},"coverImage":"/assets/img/2024-05-15-MasteringServerSurveillanceTrackingOnlineDeviceswithSocketio_0.png","tag":["Tech"],"readingTime":4},{"title":"클라이언트 측 로직 간소화 뷰 모델의 전략적 활용","description":"","date":"2024-05-15 02:45","slug":"2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels","content":"\n\n\n![User View Model](/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png)\n\n애플리케이션은 종종 서버에서 직접 사용 가능한 데이터 표현과는 다른 데이터 표현이 필요합니다. 예를 들어 사용자 객체에는 열거형 역할, 열거형 상태, 이름 등의 속성이 포함될 수 있습니다. 클라이언트 측 뷰에서 이러한 서버 측 모델을 직접 사용하면 종종 UI 로직 전체에 분산된 복잡한 변환을 유발합니다.\n\n이 문제를 해결하기 위해 각 엔티티에 대한 뷰 모델 클래스를 생성하는 것을 주장합니다. 이 캡슐화는 데이터 처리를 간단하게 만들어주며 UI가 필요한 것만 받도록 보장합니다. 다음은 UserVm의 간단한 실제 예시입니다:\n\n```js\nconst rolesMap = fromBeEnum(UserRoleEnum, {\n  VIEWER: '뷰어',\n  ADMIN: '관리자',\n  SIGNER: '서명자',\n  OWNER: '소유자'\n});\n\nexport class UserVm {\n  constructor(dto: User) {\n    this.displayName = dto.name || dto.email;\n    this.isActive = dto.status === UserStatusEnum.ACTIVE;\n    this.isServiceAccount = dto.type === UserTypeEnum.SERVICE_ACCOUNT;\n    this.isViewer = dto.role === UserRoleEnum.VIEWER;\n    this.isOwner = dto.role === UserRoleEnum.OWNER;\n    this.isActiveAdmin = dto.isAdmin \u0026\u0026 this.isActive;\n    this.typeLabel = dto.isServiceAccount ? '서비스 계정' : '사용자';\n    this.roleLabel = this.userRoleToLabel();\n    this.hasAddQuorum = hasQuorum(dto, 'add');\n    this.hasRemoveQuorum = hasQuorum(dto, 'remove');\n    this.isPendingApproval = this.hasAddQuorum || this.hasRemoveQuorum;\n  }\n  \n  private userRoleToLabel() {\n    return rolesMap[this.dto.role] || '알 수 없음';\n  }\n}\n```\n\n\n\ngetUser 엔드포인트에서 데이터를 받으면 UserVm 클래스를 사용하여 응답에 맞는 새 사용자 뷰 모델을 생성합니다. 이 추상화를 통해 깔끔하고 유지 관리 가능한 코드 구조를 유지할 수 있습니다.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getUser({ vaultId }) {\n    return this.query({\n      queryKey: ['user'],\n      queryFn: () =\u003e {\n        return this.client.getAuthenticatedUser({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(user =\u003e new UserVm())\n    )\n  }\n}\n```\n\n이 원칙은 엔티티 배열을 다룰 때에도 동일하게 적용됩니다. 예를 들어, 응용 프로그램 내에서 거래가 어떻게 처리되는지 살펴보면 — UI 변환을 거치는 중요한 엔티티인 거래에 대해 어떻게 다루는지에 대해 생각해 보세요.\n\n```js\nimport { injectQuery, mapResultData } from '@ngneat/query';\n\n@Injectable({ providedIn: 'root' })\nexport class TransactionsService {\n  private query = injectQuery();\n  private client = injectApiClient();\n\n  getTransactions({ vaultId }) {\n    return this.query({\n      queryKey: ['transactions'],\n      queryFn: () =\u003e {\n        return this.client.getTransactions({ vaultId })\n      }\n    }).result$.pipe(\n      mapResultData(res =\u003e res.transactions.map(t =\u003e new TransactionVm(t)))\n    )\n  }\n}\n```\n\n\n\n# 뷰 모델 사용의 이점\n\n## 명확성과 사용자 정의\n\n백엔드 네이밍 규칙 때문에 머리를 긁는 순간들을 우리 모두 겪어봤죠 😛. 뷰 모델은 속성 이름을 바꿔 더 직관적으로 만들 수 있습니다. DTO 이름이 애매할 때, VM은 DTO를 직접 변경하지 않고 더 구체적인 이름을 사용하는 방법을 제공합니다.\n\n## 스키마 유연성\n\n\n\nVMs(Visual Models)은 백엔드 구조에 영향을 미치지 않고 DTO 스키마를 애플리케이션의 요구에 더 잘 맞게 수정할 수 있는 기회를 제공합니다. 이 유연성은 다양한 사용 케이스에 적응하는 데 중요합니다.\n\n## 중앙화된 수정\n\nDTO에 중요한 변경이 있거나 예기치 못한 수정이 필요한 경우, 조정은 뷰 모델에서만 하면 되며 애플리케이션 전체에 수정을 반영할 필요가 없습니다. 이 중앙화는 버그와 유지보수 부담을 크게 줄여줍니다.\n\n## 캡슐화\n\n\n\n변환 로직을 VM 내부로 캡슐화하면 컴포넌트 전체에서의 파이프, 유틸리티 함수 및 열거형에 대한 의존성이 줄어들어 더 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n## 재사용성\n\n한 번 정의된 View Model은 응용 프로그램의 다른 부분 또는 다른 프로젝트에서도 재사용할 수 있습니다. 이러한 재사용성은 개발 시간을 크게 단축하고 오류를 줄일 수 있습니다. 예를 들어, ownerVm을 사용하는 DeviceVm의 시나리오를 살펴보겠습니다:\n\n```js\nexport class DeviceVm {\n  ownerVm: UserVm;\n\n  constructor(device: Device) {\n    // ...device props\n    this.ownerVm = new UserVm(device.owner);\n  }\n}\n```\n\n\n\n이 설정을 사용하면 장치를 처리하는 애플리케이션의 어떤 부분이든 UserVm에서 사용 가능한 풍부한, 사전 처리된 데이터를 자동으로 활용할 수 있습니다.\n\nEntity 간 관련이 있는 복잡한 데이터 구조는 조합된 VM에서 크게 이점을 얻을 수 있습니다. 예를 들어, 여러 장치를 가진 사용자 시나리오는 다음과 같이 보일 수 있습니다:\n\n```js\nexport class UserWithDevicesVm extends UserVm {\n  devices: DeviceVm[];\n\n  constructor(user: User, devices: Device[]) {\n    super(user); // 기본 UserVm 초기화\n    this.devices = devices.map(device =\u003e new DeviceVm(device));\n  }\n}\n\n// 서비스에서\nimport { intersectResults$ } from '@ngneat/query';\n\ncombineLatest([\n  this.usersService.getUsers({ vaultId }),\n  this.devicesService.getDevices({ vaultId })\n]).pipe(\n  intersectResults$(([users, devices]) =\u003e {\n    const userDevices = devices.filter(...); \n    return users.map(user =\u003e new UserWithDevicesVm(user, userDevices));\n  })\n)\n```\n\n# 업데이트용 뷰 모델 복제\n\n\n\n가끔가다 VM을 업데이트해야 할 때가 있습니다. 이런 경우를 위해 원본 DTO를 보존하고 복제 방법을 구현할 수 있습니다:\n\n```js\nexport class DeviceVm {\n  \n  constructor(private dto: Device) {\n    // 장치 속성\n  }\n  \n  clone() {\n    return new DeviceVm(this.dto)\n  }\n}\n```\n\n제 애플리케이션에서는 보통 VM을 직접 업데이트하지 않습니다. 대신 성능 문제가 없는 한, @ngneat/query(내부적으로 tanstack/query를 사용)의 invalidateQueries 함수를 활용합니다. 이 방식은 서버에서 데이터를 다시 가져오고 자동으로 새 VM을 생성하여 사용자 인터페이스를 업데이트합니다.\n\n# 결론\n\n\n\n뷰 모델은 애플리케이션 데이터를 관리하기 위한 강력한 패턴으로 작용합니다. 이들은 클라이언트 측 개발을 단순화할 뿐만 아니라 애플리케이션의 유지 보수성과 확장성을 향상시킵니다. 데이터 처리 및 변환을 전용 클래스로 추상화함으로써, 개발자들은 견고하고 사용자 친화적인 인터페이스를 구축하는 데 집중할 수 있습니다.\n\nAngular 및 JS에 대해 더 알아보려면 Medium 또는 Twitter에서 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png"},"coverImage":"/assets/img/2024-05-15-SimplifyingClient-SideLogicTheStrategicUseofViewModels_0.png","tag":["Tech"],"readingTime":5},{"title":"API 성능 향상 병렬 처리, 일괄 처리, 그리고 Bson 필터","description":"","date":"2024-05-15 02:43","slug":"2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters","content":"\n\n이 글에서는 개발자가 API의 성능을 향상시키기 위해 사용할 수 있는 최적화 시리즈를 탐색해 보겠습니다. API를 디자인할 때 최적의 성능을 확보하는 것이 중요합니다. 그러나 때로는 사용 가능한 도구를 효과적으로 활용하지 못하거나, 충분한 정보가 없어 판단을 내리기 어려울 수 있습니다.\n\n일반적인 시나리오를 살펴보겠습니다: 데이터베이스에서 카테고리 및 해당 카테고리에 속한 제품을 가져오는 과정입니다. 우리는 구현할 수 있는 다양한 최적화 또는 수정 단계를 따라갈 것입니다.\n\n```js\nList\u003cCategory\u003e categories = getAllCategory();\n        \ncategories.forEach(category -\u003e {\n    Product product = getProductByCategory(category.getId());\n    productList.add(product);\n});\n```\n\n이 코드 조각은 잘 작동하며 우리가 하려고 하는 작업을 수행합니다. 그런데 더 나은 방법이 있을까요?\n\n\n\n병렬 스트림이 도와드릴게요!!!\n\nJava는 API 성능을 향상시키기 위해 병렬 스트림을 제공하지만 효율적으로 사용하지 않으면 시스템 가속화에 도움이 되지 않을 수 있습니다. 병렬 스트림은 백그라운드 OS 스레드를 활용하여 실행하므로 스레드 컨텍스트 전환의 오버헤드를 고려하면서 효과적으로 사용하는 방법을 이해하는 것이 중요합니다.\n\n배치 처리 소개\n\n한 걸음 더 나아가서 일부 배치 처리를 사용하고 병렬 스트림을 활용하여 더욱 최적화할 수 있습니다.\n\n\n\n```java\nList\u003cCategory\u003e categories = getAllCategory();\nList\u003cList\u003cCategory\u003e\u003e partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch -\u003e {\n    categoryBatch.parallelStream().forEach(category -\u003e {\n        Product product = getProductByCategory(category.getId());\n        productList.add(product);\n    });\n});\n```\n\n파티션 함수는 원본 목록을 지정된 배치 크기를 기준으로 일괄로 나눕니다. 예를 들어, 원본 목록에 220개의 요소가 있다면 결과 목록은 크기가 `50, 50, 50, 50, 20`인 5개의 요소로 나눠질 것입니다.\n\n그리고 이제 중첩된 병렬 스트림을 사용하여 요소를 반복할 수 있습니다.\n\n다중 처리를 잘 활용한 것 같은데, 더 개선할 부분이 있을까요?\n\n\n\n데이터베이스 최적화\n\n이제 최적화된 접근법처럼 보이지만, 여전히 DB(데이터베이스)에 N번 접근하고 있습니다. 다만, 여러 스레드를 사용하여 동일한 작업을 수행하고 있을 뿐입니다.\n\n더 좋은 접근 방식은 분할된 목록을 사용하여 WHERE 절을 구성하고 여러 카테고리 ID를 전달하여 단일 데이터베이스 호출을 실행하는 것입니다.\n\n```js\ndb.getCollection('Product').find({'category_id':{$in:['categoryId1','categoryId2']}\n```\n\n\n\n```js\nBson filter = Filters.in(\"categoryId\", \"categoryId1\", \"categoryId2\");\n// 마찬가지로 필터를 사용하여 카테고리 ID를 전달할 수 있습니다.\nList\u003cCategory\u003e categories = getAllCategory();\nList\u003cList\u003cCategory\u003e\u003e partitionedCategories = Lists.partition(categories, 50);\n\npartitionedCategories.parallelStream().forEach(categoryBatch-\u003e{\n    Bson filter = Filters.in(\"categoryId\", categoryBatch);\n    List\u003cProduct\u003e productsBatch = getProducts(filter);\n    productList.addAll(productsBatch);\n});\n```\n\nBson 필터를 사용하여 데이터 검색을 구현하면 API에 유연성을 추가할 수 있어서 클라이언트가 쿼리를 자신의 요구에 맞게 조정할 수 있습니다. 이 방식은 API의 사용성을 향상시키고 다양한 시나리오에서 유용하게 사용할 수 있도록 합니다.\n\n지금까지 한 작업을 요약해볼까요!\n\n정말 멋진 개선이군요. 일괄 검색 및 여러 스레드를 활용하면 데이터베이스 호출 수를 줄이고 병렬 처리를 효율적으로 활용하여 성능을 크게 향상시킬 수 있습니다. API의 성능에 상당한 최적화가 되었으므로 성능 상에서 뚜렷한 차이를 느낄 수 있을 겁니다.\n\n\n\n\n이 풀 리퀘스트는 정말 리뷰할 준비가 되어 있어요! 😄🚀","ogImage":{"url":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png"},"coverImage":"/assets/img/2024-05-15-ImprovingAPIperformanceParallelprocessingbatchingandBsonfilters_0.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs 앱에 Stripe 결제 추가하는 방법","description":"","date":"2024-05-14 16:09","slug":"2024-05-14-HowtoaddStripepaymentstoyourNextjsapp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png\" /\u003e\n\n와! 내 매체 암호를 찾았어요!\n\n이제, 내 첫 번째 기사에서 Stripe를 Next.js 앱에 통합하는 방법에 대해 이야기하려고 해요.\n\n이 프로젝트에서는 너무 복잡한 것을 만드는 데 주의를 기울이지 않을 거에요. 대신에 우리는 간편한 Next.js 13.4 앱을 개발하여 일회성 Stripe 결제를 가능하게 할 거에요.\n\n\n\n## 설정하기\n\n터미널을 열고 나의 경우에는 Workspace 안에서 다음 명령을 실행해 주세요.\n\n```js\nnpx create-next-app@latest\n```\n\n위 명령을 실행하면 \"create-next-app@13.4.1\"을 설치하라는 메시지가 표시되며 몇 가지 질문이 있을 겁니다.\n\n\n\n- 프로젝트 이름은 무엇인가요? stripe-nextjs\n- TypeScript를 사용하고 싶나요? 네\n- ESLint를 사용하고 싶나요? 네\n- 이 프로젝트에 Tailwind CSS를 사용하고 싶나요? 아니요, 스타일 작업을 하지 않을 예정이기 때문에\n- `src/` 디렉토리를 사용하고 싶나요? 네\n- App Router를 사용하시겠습니까? 네\n- 기본 import 별칭을 사용자 정의하시겠습니까? 아니요\n\n질문에 모두 답했다면, 설치가 시작됩니다!\n\n이제 설치가 완료되었습니다! 이제 실제로 Next.js 앱을 보려면 터미널에서 다음 명령을 실행하세요. Next.js 앱 내부에 있는지 확인하세요.\n\n```js\nyarn run dev\n```\n\n\n\n더 나아가기 전에, Stripe 계정을 생성하고 API 키를 받아봐요.\n\nStripe 계정을 만든 후에, dashboard.stripe.com/test/apikeys로 이동해서 API 키를 받아요.\n\n## 환경 파일 설정하기\n\n루트 디렉토리 안에, .env.local이라는 파일을 만들어주세요.\n\n\n\n.env.local 파일 안에 다음을 추가해주세요:\n\n```js\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\"\"\nSTRIPE_SECRET_KEY=\"\"\n```\n\n여기서 기억해야 할 중요한 점이 몇 가지 있어요. 먼저, \"\"\"를 Stripe 키로 대체해야 합니다. 둘째로, 두 변수 간의 차이를 이해하는 것이 중요합니다. 하나는 \"NEXT_PUBLIC\"을 포함하고 다른 하나는 포함하지 않습니다. 간단히 말해서, \"NEXT_PUBLIC\"을 사용하여 STRIPE_PUBLISHABLE_KEY를 노출시키는 것은 괜찮지만 시크릿 키는 절대로 클라이언트 측에 노출되어서는 안 됩니다.\n\n알았어요, 이해했어요? 그럼 다음 단계로 넘어갑시다!\n\n\n\n## 필요한 패키지 설치하기\n\n당신의 Next.js 앱 내부에 다음 패키지를 설치해보세요:\n\n```js\n@stripe/react-stripe-js @stripe/stripe-js stripe axios\n```\n\n## 백엔드 작업을 시작해봅시다\n\n\n\n우리 앱 폴더 안에 api라는 새 폴더를 만들어주세요. 이곳에 모든 백엔드 코드가 위치하게 됩니다.\n\napi 폴더 안에 create-payment-intent라는 새 폴더를 만들고, 그 안에 route.ts 라는 파일을 생성해주세요.\n\n![이미지](/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_1.png)\n\n\"create-payment-intent\" 폴더 안에 \"route\"라는 파일을 만드는 이유는 Next.js에 API 요청을 다루고 있다는 것을 알리는 것입니다. 공식 문서에 따르면, route는 라우팅의 가장 기본적인 수준으로, 페이지가 하는 것처럼 레이아웃이나 클라이언트 측 탐색에 영향을주지 않습니다. \"route.ts\" 파일이 \"page.ts\" 파일이 있는 곳에 존재할 수 없다는 점을 명심해야 합니다. 자세한 내용은 문서를 참고하는 것을 강력히 권장합니다.\n\n\n\n여기는 route.ts 파일의 코드입니다:\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n\nexport async function POST(req: NextRequest) {\n  const { data } = await req.json();\n  const { amount } = data;\n  try {\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(amount) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n  } catch (error: any) {\n    return new NextResponse(error, {\n      status: 400,\n    });\n  }\n}\n```\n\n이것을 자세히 살펴보고 무슨 일이 일어나고 있는지 이해해 봅시다.\n\n첫째로, 우리는 타입과 stripe를 import 합니다:\n\n\n\n```js\nimport { NextResponse, NextRequest } from \"next/server\";\nimport Stripe from \"stripe\";\n```\n\n다음으로 stripe 인스턴스를 만듭니다:\n\n```js\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  typescript: true,\n  apiVersion: \"2022-11-15\",\n});\n```\n\n우리의 Stripe 인스턴스는 env.local 파일에서 Stripe 비밀키가 필요합니다. 더 나아가, 우리는 Stripe 인스턴스에 TypeScript를 활성화하고 인스턴스용 Stripe API 버전을 지정했습니다.\n\n\n\n계속 진행하기 전에 Next.js 13.4에서 API 경로를 다루는 방법에 대해 이야기해 봅시다.\n\n아마 이미 주목했을 것이지만, 함수의 제목이 \"POST\"와 같이 모두 대문자로 되어 있습니다. 이 네이밍 규칙은 Next.js가 실행할 해당 HTTP 메소드를 결정하기 위해 필요합니다. 예를 들어, GET 요청을 수행하려면 함수의 제목을 \"GET\"으로 지정해야 하며, 수행하려는 다른 작업에 대해서도 유사하게 지정해야 합니다.\n\n알겠습니다, 이해했습니다, 좋아요! 계속 진행합시다!\n\n우리 함수 내에서는 요청에서 데이터를 비구조화하는 방식으로 진행합니다. 그 후에는 데이터 객체에서 금액을 더욱 세분화합니다.\n\n\n\n```js\nconst { data } = await req.json();\nconst { amount } = data;\n```\n\n이제 모든 흥미로운 로직이 발생하는 trycatch 블록을 살펴보겠습니다!\n\n파고들어 봅시다.\n\n```js\nconst paymentIntent = await stripe.paymentIntents.create({\n      amount: Number(price) * 100,\n      currency: \"USD\",\n    });\n\n    return new NextResponse(paymentIntent.client_secret, { status: 200 });\n```\n\n\n\n우리의 try 블록 안에서, 결제 인텐트를 생성할 것입니다. 결제 인텐트에 대해 잘 모르신다면 걱정하지 마세요. 거래에 관한 중요한 정보를 담고 있죠. 지원되는 결제 방법, 징수할 금액, 그리고 희망하는 통화를 포함하고 있습니다.\n\n마지막으로, Stripe로부터 얻은 클라이언트 시크릿을 포함한 응답을 반환할 것입니다. 이 단계는 매우 중요합니다. 왜냐하면 우리는 클라이언트 측에서 Stripe가 결제를 확인하는 데 도움을 주기 위해 클라이언트 시크릿을 활용할 것이기 때문이죠.\n\n```js\n    return new NextResponse(error, {\n      status: 400,\n    });\n```\n\n우리의 catch 블록 안에서는 간단히 오류를 포함한 응답을 반환합니다.\n\n\n\n이 시점에서 백엔드 개발은 완료되었습니다. 이제 새로 만든 엔드포인트와 상호 작용할 클라이언트 측으로 이동해 봅시다.\n\n## 프론트엔드\n\n마법을 시작하기 전에 정리해 봅시다!\n\nlayout.tsx 파일에서 global.css를 불러오는 줄을 삭제하세요. 스타일에 대해서는 다루지 않을 거에요.\n\n\n\n앱.tsx 파일에서 `main` 태그 내부의 모든 내용을 삭제하고, Image 컴포넌트 import 구문을 삭제해주세요.\n\n좋아요, 이 시점에서 layout.tsx 파일은 다음과 같아야 합니다:\n\n```js\nimport { Inter } from \"next/font/google\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata = {\n  title: \"Create Next App\",\n  description: \"Generated by create next app\",\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody className={inter.className}\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n그리고 app.tsx 파일은 다음과 같아야 합니다:\n\n\n\n```js\nexport default function Home() {\n  return (\n    \u003c\u003e\u003c/\u003e\n  );\n}\n```\n\n여기 멋진 곳에요, 결제 양식을 설정해 봅시다!\n\n\"src\" 폴더에서 \"components\"라는 새 폴더를 만들어 주세요. \"components\" 폴더 안에 \"PaymentForm\"이라는 또 다른 폴더를 만들어 주세요. \"PaymentForm\" 폴더 안에 \"PaymentForm.tsx\"라는 파일을 만들어 주세요. 거기에 우리의 결제 양식이 위치하고 대부분의 로직이 여기서 실행될 거에요.\n\n시작해 봅시다!\n\n\n\n우리가 컴포넌트 작성을 시작하기 전에, Next.js에게 서버 컴포넌트가 아닌 클라이언트 컴포넌트를 다루고 있다는 것을 알려주어야 해요.\n\nPaymentForm.tsx 파일의 맨 위에 다음을 추가해주세요:\n\n```js\n\"use client\";\n```\n\n그 다음에 다음과 같은 import 문을 추가해주세요:\n\n\n\n```js\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n```\n\n이제 빈 컴포넌트를 생성해봅시다:\n\n```js\nexport default function PaymentForm() {\n  return \u003c\u003e\u003c/\u003e;\n}\n```\n\n지금까지의 파일은 이렇게 보여야 합니다:\n\n\n\n```js\n\"사용자용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  return \u003c\u003e\u003c/\u003e;\n}\n```\n\n우리 컴포넌트 안에서 처음으로 해야 할 일은 Stripe 훅을 사용하는 것인데, 우리가 사용할 훅은 useStripe와 useElements 입니다.\n\n```js\n  const stripe = useStripe();\n  const elements = useElements();\n```\n\nfrom을 제출할 수 있는 onSubmit이라는 함수를 만들어봅시다.\n\n\n\n```js\n  const onSubmit = async (e: React.FormEvent\u003cHTMLFormElement\u003e) =\u003e {}\n```\n\nonSubmit 함수 안에서 e.preventDefault(); 를 사용하여 기본 동작을 막아줍시다.\n\n다음으로, stripe 카드 엘리먼트에 다음 스니펫을 사용하여 접근해야 합니다:\n\n```js\n    const cardElement = elements?.getElement(\"card\");\n```\n\n\n\n지금부터 실제 마법을 시도해 봅시다!\n\ntry-catch 블록을 만들어 봅시다. try 블록 안에는 stripe와 cardElement의 존재 여부를 확인하는 조건문을 만들 것입니다. 둘 중 하나라도 누락된 경우, onSubmit 함수를 효과적으로 중단시키고 더 이상의 작업을 방지하기 위해 null을 반환할 것입니다.\n\ncatch 블록에서는 단순히 error를 console.log 하면 됩니다.\n\n다음은 코드 조각입니다:\n\n\n\n```js\n    try {\n      if (!stripe || !cardElement) return null;\n    } catch (error) {\n      console.log(error);\n    }\n```\n\n안녕하세요 여러분, 지금 좋은 위치에 있어요. 계속 진행하죠.\n\nStripe와 cardElement가 모두 존재하는지 확인한 후에, 이전에 백엔드에서 설정한 API를 사용하여 결제 의도를 생성할 수 있습니다. API에 전달할 데이터는 금액이 포함되며, 저의 경우에는 89로 설정되어 있어요.\n\n```js\n    const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n```\n\n\n\n응답을 clientSecret라는 변수에 할당해보세요.\n\n```js\nconst clientSecret = data;\n```\n\n마지막으로 우리가 해야 할 일은 stripe에서 제공하는 confirmCardPayment 메서드를 사용하여 결제를 확인하는 것입니다. 아래는 예시 코드 조각입니다:\n\n```js\nawait stripe?.confirmCardPayment(clientSecret, {\n  payment_method: { card: cardElement },\n});\n```\n\n\n\n지금까지 onSubmit 함수를 완료했습니다.\n\n우리의 컴포넌트가 stripe에서 제공하는 CardElement 컴포넌트를 사용하는 폼을 반환하도록 만들어보겠습니다.\n\n```js\n    \u003cform onSubmit={onSubmit}\u003e\n      \u003cCardElement /\u003e\n      \u003cbutton type=\"submit\"\u003e제출하기\u003c/button\u003e\n    \u003c/form\u003e\n```\n\n최종 결과:\n\n\n\n```js\n\"사용자 사용\";\n\nimport { CardElement, useElements, useStripe } from \"@stripe/react-stripe-js\";\nimport axios from \"axios\";\nimport React from \"react\";\n\nexport default function PaymentForm() {\n  const stripe = useStripe();\n  const elements = useElements();\n\n  const onSubmit = async (e: React.FormEvent\u003cHTMLFormElement\u003e) =\u003e {\n    e.preventDefault();\n    const cardElement = elements?.getElement(\"card\");\n\n    try {\n      if (!stripe || !cardElement) return null;\n      const { data } = await axios.post(\"/api/create-payment-intent\", {\n        data: { amount: 89 },\n      });\n      const clientSecret = data;\n\n      await stripe?.confirmCardPayment(clientSecret, {\n        payment_method: { card: cardElement },\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  return (\n    \u003cform onSubmit={onSubmit}\u003e\n      \u003cCardElement /\u003e\n      \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n좋은 소식입니다! 우리의 PaymentForm 컴포넌트가 이제 완성되었습니다. 만세! 이제 마지막 단계로 넘어가서, 새롭게 생성된 PaymentForm 컴포넌트를 사용하도록 앱의 app.tsx 파일을 업데이트하는 것을 진행해보겠습니다.\n\nPaymentForm 컴포넌트가 app.tsx 안에서 사용되기 전에, 몇 가지를 import하고 stripe를 로드해야 합니다.\n\n```js\n\"사용자 사용\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n```\n\n\n\nstripe를 불러와보겠습니다:\n\n```js\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n```\n\nstripe를 컴포넌트 외부에서 로드하는 것을 확인해주세요. 그렇지 않으면 stripe가 매번 렌더링되어 원하지 않는 결과가 발생할 수 있습니다.\n\n마지막으로, return 문 안에서 우리에게 제공된 Element 공급자를 활용해봅시다. PaymentForm 컴포넌트를 해당 공급자로 감싸겠습니다. 다음과 같이 보여야 합니다:\n\n\n\n여기 완성된 결과입니다:\n\n```js\n\"use client\";\nimport { Elements } from \"@stripe/react-stripe-js\";\nimport { loadStripe } from \"@stripe/stripe-js\";\nimport PaymentForm from \"@/components/PaymentForm/PaymentForm\";\n// 컴포넌트 렌더링 시에 `Stripe` 객체를 다시 생성하는 것을 피하기 위해\n// `loadStripe`를 컴포넌트 밖에서 호출하는 것을 확인해주세요.\nconst stripePromise = loadStripe(\n  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!\n);\n\nexport default function Home() {\n  return (\n    \u003cElements stripe={stripePromise}\u003e\n      \u003cPaymentForm /\u003e\n    \u003c/Elements\u003e\n  );\n}\n```\n\n와! Stripe를 사용하여 결제 폼을 만들었네요. 잘 했어요!\n\n\n\n이 글이 도움이 되었으면 좋겠어요! 앞으로 여기서 더 활발하게 활동할 거에요. 기대돼요 🤔\n\n여기 git 레포지토리 링크에요. 즐겨보세요!","ogImage":{"url":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoaddStripepaymentstoyourNextjsapp_0.png","tag":["Tech"],"readingTime":10}],"page":"100","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"100"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>