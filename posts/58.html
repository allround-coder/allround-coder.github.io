<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/58" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/58" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular v18 발표 내용 정리 " href="/post/2024-05-27-Angularv18announcements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v18 발표 내용 정리 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Angularv18announcements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v18 발표 내용 정리 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v18 발표 내용 정리 </strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기" href="/post/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 18의 새로운 기능 알아보기" href="/post/2024-05-27-WhatsnewinAngular18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 18의 새로운 기능 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-WhatsnewinAngular18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 18의 새로운 기능 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular 18의 새로운 기능 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ElysiaJS 소개 및 정리" href="/post/2024-05-27-FirstLookAtElysiaJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ElysiaJS 소개 및 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ElysiaJS 소개 및 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ElysiaJS 소개 및 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모던 브라우저에서 AWS S3 직접 업로드하는 방법" href="/post/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모던 브라우저에서 AWS S3 직접 업로드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모던 브라우저에서 AWS S3 직접 업로드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모던 브라우저에서 AWS S3 직접 업로드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NestJS의 비즈니스 로직 조직 이해하기" href="/post/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NestJS의 비즈니스 로직 조직 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NestJS의 비즈니스 로직 조직 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NestJS의 비즈니스 로직 조직 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 부모 컴포넌트에서 자식 함수를 호출하는 방법" href="/post/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 부모 컴포넌트에서 자식 함수를 호출하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 부모 컴포넌트에서 자식 함수를 호출하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 부모 컴포넌트에서 자식 함수를 호출하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 개발의 기초 내용들 정리" href="/post/2024-05-27-BasicofWebDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 개발의 기초 내용들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-BasicofWebDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 개발의 기초 내용들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 개발의 기초 내용들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS에서 rgba 대신 color-mix를 사용해야하는 이유" href="/post/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS에서 rgba 대신 color-mix를 사용해야하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS에서 rgba 대신 color-mix를 사용해야하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS에서 rgba 대신 color-mix를 사용해야하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 컴파일러와 리액트 18에 대해서 알아보기" href="/post/2024-05-27-ReactCompilerWithReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 컴파일러와 리액트 18에 대해서 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-ReactCompilerWithReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 컴파일러와 리액트 18에 대해서 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 컴파일러와 리액트 18에 대해서 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link posts_-active__YVJEi" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular v18 발표 내용 정리 ","description":"","date":"2024-05-27 18:57","slug":"2024-05-27-Angularv18announcements","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-Angularv18announcements_0.png\" /\u003e\n\n2024년 5월 26일, Angular 팀이 Angular 18 버전을 발표했어요. Angular 개발자로서 Angular이 새로운 반응형 시스템을 구축한 진전에 대해 너무 기대돼요. 그래서 이들의 발표를 함께 공유하려고 해요.\n\n이번 새 릴리스는 Angular을 향상시켜 개발자 커뮤니티에 더 나은 서비스를 제공하고 웹을 발전시키기 위한 방법을 찾는 것을 목표로 하고 있어요. 이들의 향상 사항 중 일부를 나열하면:\n\n- 템플릿 레벨의 지연 로딩과 defer 구문.\n- 더 직관적인 제어 흐름.\n- Angular 시그널을 활용한 반응성 개선.\n- SSR(Server side rendering) 및 Hydration 지원을 포함해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 더 많은 개선 사항이 있습니다.\n\n# 새로운 반응성 시스템 상태\n\n가장 중요한 프로젝트부터 시작합니다. 그들의 반응성 시스템을 재설계하는 프로젝트가 시작되었습니다. 이 재설계 작업은 Angular v16부터 시작되었습니다.\n\n이 프로젝트의 주요 목표는 Angular 애플리케이션에서 zone.js를 선택 사항으로 만드는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 질문에 대한 답변으로 Alex Rickabaugh는 zone.js로 구축된 응용 프로그램의 역호환성이 있다고 확인했습니다. 그리고 그들은 zone.js와 함께 반응성에 대한 성능 약점을 발견했으며 많은 유지 보수적인 도전 과제도 있었습니다. 또한 새로운 웹 API의 추가로 로딩 및 초기화 비용이 증가했습니다.\n\n이후 Angular 팀은 다음 10년 동안 개발자의 요구를 충족시키고 웹 성능을 향상시킬 새로운 반응성 시스템에 투자하기로 결정했습니다.\n\nAngular은 이미 Angular 16부터 새로운 반응성 시스템의 재설계를 시작했습니다. 시그널, 컴퓨티드 그리고 이펙트라는 세 가지 반응 API를 소개하여\n\nAngular 17에서, 시그널, 컴퓨티드 그리고 이펙트는 안정된 API가 되었습니다. 이러한 API들은 새로운 반응성 시스템의 핵심이며, 우리가 사용함으로써 Angular이 응용 프로그램 상태에서 발생한 변경 사항을 이해하고 UI를 올바르고 효율적으로 업데이트할 수 있도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 Angular 팀은 NgXS 및 NgRx 팀에 접근하여 신호 API가 그들의 사용 사례를 지원하는지 확인했습니다. NgRx의 signal store의 통합은 이 협력의 열매입니다.\n\n이 세 가지 API는 Angular에게 존을 사용하지 않고도 이 반응성 모델을 구축할 수 있는 기초를 제공합니다.\n\n# 하이브리드 변경 감지\n\nAngular 라이브러리 및 응용 프로그램을 존에서 독립적으로 사용할 수 있게 하기 위해 모든 구성 요소에 영향을 주지 않고 Angular 팀은 지난 여섯 달 동안 새로운 변경 감지 모드에 대해 작업해 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모드의 목표는 정확성, 성능, 개발자 경험 및 하위 호환성을 균형있게 유지하는 것입니다.\n\n이를 완전히 구현하는 데는 시간이 걸립니다. 또한, Angular 팀은 구글 Angular 애플리케이션에서 이러한 아이디어를 테스트하고 일부는 이미 제품에 적용되었습니다.\n\nV18에서 새로운 변경 감지 모드의 두 가지 요소를 출시했습니다:\n\n- 하이브리드 변경 감지 : V18에서 기본적으로 활성화되며, zone.js에 추가로 Angular은 신호도 감지하고 변경 감지를 예약합니다.\n- Zone을 비활성화하는 실험적 API : 이 API는 여전히 실험 중인 상태입니다. 이 API를 사용하면 zones를 비활성화하고 애플리케이션이 완전히 zone-less 상태가 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nV18 이후, Angular 팀에는 다음과 같은 다른 프로젝트들이 준비 중입니다:\n\n- Angular 패키지 및 다른 생태계 라이브러리를 위한 zone-less Angular의 개발자 미리보기.\n- 시그널 기반의 폼과 라우터.\n- 시그널 컴포넌트.\n- Angular의 안정성과 신뢰성에 대한 헌신.\n\n# Angular 수분\n\n이 기능은 Angular 16에서 소개되었습니다. 이는 Angular Universal과 함께 SSR을 사용할 때, Angular이 이제 서버 측 렌더링된 HTML을 클라이언트에서 재사용할 수 있게 되었음을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DevTools에서 수분 보충 기능이 강화되었습니다\n\nV18 Angular 팀에서는 Angular DevTools에서 수분 보충을 지원하기 위한 기능을 강화했습니다. 개발자는 수분 보충 정보를 볼 수 있습니다. 수분 보충된 컴포넌트, 건너 뛰어진 컴포넌트, 그리고 오류를 만난 컴포넌트를 쉽게 수정할 수 있습니다.\n\n## Angular Material 컴포넌트는 수분 보충을 지원합니다\n\nV18에서는 모든 Angular Material 컴포넌트가 수분 보충을 지원하여 애플리케이션 성능을 높일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## i18n 블록 지원 — 미리보기\n\nV18에서는 i18n 블록을 위한 수분 지원도 추가되었고, 이 기능은 개발자 미리보기 상태입니다.\n\n## 이벤트 재생 — 미리보기\n\nAngular 팀에서 미리보기 모드에 새로운 기능인 이벤트 재생(Event Replay)도 출시했습니다. 애플리케이션이 수분화되는 중에 사용자가 애플리케이션과 상호 작용할 수 있습니다. 이러한 작업은 캡쳐되어 재생할 수 있습니다. 이 기능은 JsAction에 의해 제공되며 Wiz와의 협력으로 나온 것입니다. 애플리케이션이 완전히 수분화될 때 이벤트가 캡처되어 올바른 시간에 재생됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 Angular 수분화를 위해\n\n- 루트용 렌더링 모드 선택, 클라이언트 측, 서버 측 또는 빌드 시간에 렌더링될 루트를 선택할 수 있도록 후크를 구축하려고 합니다.\n- 매개변수화된 루트의 SSG(정적 사이트 생성) 경험 향상.\n\n# Angular material 3\n\nAngular V18은 드디어 material design 3을 지원합니다. 새로운 사용 가능한 기능은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 테마 생성 체계를 변경했습니다.\n- CSS 변수를 기반으로 한 간소화된 테마 스타일.\n- CSS 변수를 기반으로 한 더 세부적인 테마 사용자 정의.\n- 컴포넌트에 색상 변형을 적용하기 위한 더 유연한 API.\n\n앱에서 Material 3을 사용하려면 mat.define-theme을 사용하여 sass에서 m3 테마를 생성하세요 :\n\n![image](/assets/img/2024-05-27-Angularv18announcements_1.png)\n\n또는 Angular CLI의 ng generate 명령을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ ng generate @angular/material:m3-theme\n```\n\n테마를 애플리케이션에 적용하려면 가져와서 적용해야 합니다:\n\n![Angularv18announcements_2](/assets/img/2024-05-27-Angularv18announcements_2.png)\n\n색상, 타이포그래피 등을 읽기 위한 새로운 SASS API도 소개되었습니다. 또한 M2 테마는 여전히 지원된다고 발표되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular Material의 다음 단계에 있습니다.\n\n- 더 많은 유연성을 위해 앵귤러 마테리얼의 일부 동작을 근미래에 완전히 사용자 정의 된 CDK 구성 요소로 추출하고 있습니다.\n\n# 기타 기능\n\n이전에 설명한 것 외에 V18에는 다음 세대 웹 앱을 구축하는 데 도움이 되는 추가적인 작은 기능 및 버그 수정이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 새로운 시그널 기반 API\n\n- 시그널 입력 API: 시그널 입력을 사용하면 부모와 자식 컴포넌트 간에 값을 바인딩할 수 있습니다. 일방향 바인딩.\n\n![](/assets/img/2024-05-27-Angularv18announcements_3.png)\n\n- 모델 입력 API: 시그널 모델 입력을 사용하여 데이터를 두 방향 바인딩하여 동기화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Angular v18 Announcement Image 4](/assets/img/2024-05-27-Angularv18announcements_4.png)\n\n- Signal Query APIs: offer an alternative approach to the decorator-based queries, namely @ViewChild, @ViewChildren, @ContentChild, and @ContentChildren, supplying query results as a Signal.\n\n![Angular v18 Announcement Image 5](/assets/img/2024-05-27-Angularv18announcements_5.png)\n\nTo learn more about signals, check the guide: [Angular Signals Guide](https://angular.dev/guide/signals)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Zoneless APIs\n\nzone.js 이벤트 통합은 V18에서 기본적으로 활성화되며, zone-less와 동일한 스케줄러를 사용합니다:\n\n![](/assets/img/2024-05-27-Angularv18announcements_6.png)\n\nzone.js를 사용하는 Angular은 Angular zone 밖에서 변경이 일어날 때에도 변경 감지를 스케줄할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Angular v18 announcements](/assets/img/2024-05-27-Angularv18announcements_7.png)\n\n이전에 언급했듯이 Angular Material 구성 요소 및 CDK는 zone-less 호환됩니다. zone-less는 실험적인 모드에서 사용할 수 있습니다.\n\n## Typescript 5.4\n\nV18에서는 typescript 5.4 기능을 활용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마지막 할당 후 클로저에서의 유지된 좁힘.\n- NoInfer 유틸리티 타입.\n- Object.groupBy 및 Map.groupBy\n- …\n\n더 많은 TS 5.4 기능을 확인하려면 이 블로그 포스트를 확인하세요 : https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/\n\n## 기본 `ng-content`\n\n이 릴리스 이후, 개발자들은 이제 `ng-content`에 기본값을 제공할 수 있습니다. 이를 통해 빈 목록과 현재 콘텐츠가 없는 다른 컴포넌트에 값 할당이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-27-Angularv18announcements_8.png\" /\u003e\n\n## Angular Forms 새로운 전역 observable\n\nGitHub에서 가장 많은 투표를 받은 기능 요청을 개발했습니다. 이는 모든 컨트롤 및 해당 하위 요소에 대한 모든 종류의 이벤트를 추적하도록 구독할 수 있는 전역 observable입니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-Angularv18announcements_9.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Angular.dev\n\n해당 업데이트는 현대화된 로고를 갖춘 새로운 Angular.dev 웹사이트를 소개하였습니다.\n\n마지막으로, Angular 팀의 전체 로드맵을 확인하고 싶다면 다음 페이지를 방문해주세요 : [Angular 로드맵](https://angular.dev/roadmap)\n\n이 기사의 끝까지 읽어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 박수로 응원하고 팔로우하세요! 👏️\n- 저를 팔로우하세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-05-27-Angularv18announcements_0.png"},"coverImage":"/assets/img/2024-05-27-Angularv18announcements_0.png","tag":["Tech"],"readingTime":7},{"title":"챗GPT, TypeScript를 사용하여 기본 코드 주도형 DB 도구 만들기","description":"","date":"2024-05-27 18:54","slug":"2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png\" /\u003e\n\n안녕하세요! ChatGPT가 등장했고 엔지니어들 사이에서 큰 첫 인상을 남겼어요 — 이름에 비웃음을 보이는 사람부터 우주 탄생에 대해 이야기하는 등 다양한 의견이 있어요. 어느 쪽에 속하더라도 대부분은 이것이 산업 전체에 많은 변화를 가져올 것이라는 것을 깨달아요.\n\n저는 프로그래머들이 만든 어떤 생산성 도구와 마찬가지로, ChatGPT를 효과적으로 활용하는 한 보상을 받을 것으로 생각해요. 효과적으로 사용하는 법을 배우기 위해서는 복잡한 시나리오를 시도하고 이를 어떻게 운영하는지 확인해야 해요. 저는 ChatGPT를 사용하여 빠르게 기본적인 코드 기반 데이터베이스 도구를 만들어보고, 그것에 추가해서 프로젝트를 실제로 몇 가지 기본 사례에 맞게 작동하도록 만들 계획이에요.\n\n우선, 어떤 것에 대한 복잡한 프롬프트를 선택해봅시다. 코드 기반 데이터베이스 마이그레이터를 만드는 것은 흥미로운 도전이 될 수 있을 것 같아요. 우리는 코드 파일을 이해하고 필요한 추가 컨텍스트로 일부 클래스 속성을 장식하는 메타프로그래밍 작업을 해야하기 때문이죠. 이 글을 간결하게 유지하기 위해, 우리는 Primary 및 Foreign 키가 있는 테이블 생성 스크립트를 생성하고 작업 순서를 보장하는 마이그레이터의 일부분만 만들 것이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요구 사항 목록은 다음과 같습니다:\n\n- 데이터베이스의 테이블을 위한 인터페이스 작성 — 이는 어떤 플러그인이 적응할 수 있는 데이터의 추상 표현을 제공합니다\n- 테이블 간의 관계 데이터를 어떻게 표현할지에 대한 인터페이스 조정 — 이는 우리의 이관 작업에 대비한 더 고급 개념입니다\n- 플러그인이 관계 데이터를 마이그레이션 도구의 스크립트로 변환할 수 있도록 하는 인터페이스 작성 — 우리는 상하 이관 작업을 원할 것이며 이러한 작업의 추상화를 최대한 포착할 겁니다\n- 내보낸 클래스의 소스 파일을 읽고 인터페이스를 활용하여 데이터를 구축할 수 있는 프로토타입 애플리케이션 작성 — 데이터베이스 코드 모델링의 기능적 측면을 테스트하기 위함입니다\n\n이러한 요구 사항이 작성되면 이제 빠른 프롬프트를 만들어볼 수 있습니다. 몇 번의 시행착오 뒤에, 이에 대한 ChatGPT의 출력을 확인해 봅시다:\n\n이리저리 까다로운 조건들이 많지만, ChatGPT는 기꺼이 협조할 준비가 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_1.png)\n\n지금까지... 그리 좋지 않아요. 우리의 클래스 파일을 정규식으로 맞추고 싶지 않고, 앞으로 나올 것들이 좀 무서워요.\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_2.png)\n\n처음 텍스트 출력물은 놀랍네요. TypeScript를 거의 10년 동안 다루어왔지만, TypeScript 컴파일러 API에서 무언가를 가져오거나 내보내 본 적이 없었어요. 코드는 정말 흥미로워요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_3.png\" /\u003e\n\n이것은 멋진 시작이에요. 컴파일러 API에서 정보를 추출할 수 있는 매우 간단하고 우아한 방법에 대해 동시에 배우고 있어요. 이 방법은 코드-퍼스트 솔루션에 대한 제 아이디어의 기능 프로토 타입을 계속 구축할 수 있는 필요한 모든 정의로 연결되는 게이트웨이에요. 그리고 프로토타입 코드가 실시간으로 작성돼요. ChatGPT와 함께 작업하는 핵심 개념에 접근할 수 있는데, 그 중 가장 흥미로운 건 오직 올바른 방법으로 프롬프트하면 솔루션에 대한 많은 연구를 처리할 수 있다는 거에요.\n\n심지어 코드 파일로 복사하여 추가 수정 없이 다중 행 주석으로 붙여넣을 수 있는 작동 방식에 대한 설명도 포함돼 있어요:\n\n\u003cimg src=\"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 그 다음에 나오는 내용은 제가 찾던 것과는 조금 다릅니다. ChatGPT는 다음 코드 파일에서 기존 솔루션을 재정의하고 로컬 Postgres 데이터베이스가 설정되었고 Sequelize가 추가되었으며 classInfoList 출력을 통해 정의된 모델을 설정합니다.\n\n![이미지](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_5.png)\n\n우리가 찾던 것은 아닌 것 같고, 원래 프롬프트를 다시 살펴보면, 실제 마이그레이션이 발생하지 않도록 했어야 합니다. 우리가 원한 것은 단지 마이그레이션을 생성하는 다른 전략을 \"연결할\" 수 있는 인터페이스를 생성하는 것이었습니다.\n\n그래서 해야 할 일 목록에서, ChatGPT가 우리를 다음과 같은 불필요한 일로부터 구해준 것을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 우리가 존재하는 것을 모르고 발견 못할 수도 있는 해결책에 대해 조사 중이었습니다.\n- 원본 파일에서 클래스와 종속성을 추출할 수 있는 초기 프로토타입을 작성 중입니다.\n\n처음부터 끝까지 생성된 모든 것, 처음에 정규 표현식 및 마지막에 Sequelize를 포함한 모든 것은 유용하지 않으며 사양의 일부도 아닙니다. 적어도 이 복잡한 프롬프트에 대한 어느 정도의 이해를 보여줍니다. 이 경우에는 ChatGPT가 몇몇 비관론자들이 예측한 것보다 전반적으로 조금 덜 진전을 남겼다는 것을 안타깝게 생각합니다.\n\n우리의 Code-First 이관 도구를 위한 인터페이스를 구축하기 시작하는 것부터 유용하게 일부 코드를 적응해봅시다. 테이블 생성을 스크립팅하기 위해 필요한 TableInfo 유형 및 지원 유형을 정의하는 것부터 시작합니다:\n\n이 유형은 약간 복잡합니다. 그러므로 최종적인 TableInfo 인터페이스로부터 분해해 보겠습니다. 클래스 이름에서 파생된 테이블 이름, 열 집합 및 테이블 간 관계를 나타내는 문자열을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 관계 - 관계를 나열해 놓는 이유는 대부분의 RDBMS에서 활성 관계가 없는 경우 테이블을 삭제하는 작업이 가능하지 않은 경우가 있기 때문입니다. 관계를 나열함으로써 테이블을 만들고 삭제할 순서를 결정할 수 있습니다.\n- 컬럼 - 이는 테이블 정의의 본질을 담고 있습니다. 컬럼은 fieldName, datatype, nullable을 포함하며, 이는 자명한 내용입니다. \"modifiers\" 속성은 주/외래 키와 같은 주요 정의를 위한 대체 속성입니다.\n\n![image1](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_6.png)\n\n![image2](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_7.png)\n\n우리는 Automigrate API를 위한 일반적인 인터페이스를 정의했습니다. 이로써, 특정 데이터베이스를 위한 플러그인이 구현되어 있다면, 마이그레이터는 여러 데이터베이스 언어를 지원할 수 있을 만큼 유연해질 것입니다. 이제 프로그래밍할 인터페이스를 알았으니, CodeFirst 모델 관점에서 TableInfo를 작성하는 방법을 고민해볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 예시 모델 몇 개를 작성해 보겠습니다. 우리는 일종의 TypeScript 클래스로 일련의 테이블을 코드 기반으로 정의할 것입니다.\n\n이제 우리에겐 몇 개의 테이블이 있습니다: Project, Feature, Person, 그리고 Project_Persons입니다. 여기에 몇 가지 관계가 포함되어 있습니다. Feature가 Project에 속하고, Project에는 많은 사람들이 할당될 수 있지만, 사람들은 프로젝트 외부에서 관리되어야 합니다.\n\n그러나 현재 상태에서는 관계 자체를 정의할 수 없으며, 다른 곳에서 어떻게 가정할지도 어렵습니다. 또한 기본 키나 외래 키를 나타내는 필드 또는 이러한 외래 키가 어떻게 관련되는지를 관리하는 좋은 방법이 없습니다. 또한 사용자들이 이러한 관계를 추적하기 위해 모델에 추가 속성을 정의하거나 생성자에 정보를 넣어야 한다면 사용자 경험에 좋지 않을 것입니다.\n\n여기에는 필드에 메타데이터를 표시할 수 있게 해주는 실험적인 TypeScript 데코레이터 개념이 있습니다. '실험적인'이라는 표현에 겁먹지 마세요. 이 기능은 꽤 오랫동안 개선되어 왔습니다. 이를 활성화하기 위해 tsconfig.json 파일로 이동하여 experimentalDecorators와 emitDecoratorMetadata를 true로 표시하여 컴파일러에서 지원을 받을 수 있도록 설정해야 합니다. 이 작업을 마치면 기본 키와 외래 키에 대한 일부 데코레이터를 정의할 수 있어야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 두 개의 새로운 데코레이터, PrimaryKey 및 ForeignKey를 정의하고 reflect 라이브러리를 통해 메타데이터를 추출할 수 있는 메서드를 제공합니다. 여기서 \"target\"의 존재는 이러한 메서드를 클래스의 인스턴스화된 인스턴스에 호출하여 해당 메타데이터를 검색해야 한다는 것을 의미합니다. 이는 나중에 구현을 약간 복잡하게 만들 수 있지만 대부분의 경우에는 배포 스크립트를 효과적으로 작성할 수 있도록 해줄 것입니다.\n\n이 코드는 실험적인 것이며 위의 가설을 확인하고 싶으므로, 이러한 데코레이터가 예상대로 작동하는지 확인하기 위한 테스트도 작성하겠습니다:\n\n이러한 모든 테스트가 실행되고 통과되었으므로, 이제 코드 퍼스트 모델에서 이러한 새로운 데코레이터를 활용할 준비가 되었습니다. 우리가 조정한 CodeFirst.ts 파일을 보여주기 위해 여기서 차이를 사용하겠습니다:\n\n이제 우리가 예제 모델을 확인하고 지원하는 참조 메타데이터를 설정하고 플러그인 인터페이스를 구축했으므로, 문제의 핵심인 TypeScript 컴파일러 API를 통해 클래스 정의의 메타데이터를 추출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원래의 ChatGPT 코드 출력으로 돌아가 봅시다. 그 코드는 디렉토리에서 파일을 가져 와 TypeScript API를 통해 ClassInfo를 검색 한 다음 해당 이름과 종속성을 반환하는 코드를 생성 했습니다. 모두 함께, 우리가 작성해야 하는 유형의 코드입니다. 이 코드를 관련 책임으로 분해하여 각각에 대해 고려하고 무슨 일이 일어나고 있는지 명확하게합니다.\n\n제가 말하고 싶은 것은 애플리케이션의 주요 부분에서 소스에서 파일을 검색하는 처리를 처리하고 싶지 않다는 것입니다. 이는 애플리케이션의 외부에서 발생해야 하므로, 소스 파일이 위치한 곳을 선택할 수 있도록 새로운 Modeler 클래스를 만들 것입니다. 이때 다른 사람이 우리 라이브러리를 사용하려는 경우 소스 파일의 위치를 지정할 수 있습니다.\n\nTypeScript 컴파일러의 SourceFiles 유형을 사용하고 코드를 가져 오기위한 방법을 구현할 것입니다. 예제 디렉토리에서 사물을 테스트 할 수 있도록:\n\n여기서 SourceExtractor 클래스를 만들었습니다. 이 클래스에는 두 개의 static 메서드가 있습니다 - getSourceFile 및 getFilesFrom이라는, 파일을 읽고 해당 TypeScript SourceFile을 검색하기 위해 문자열 인수를 취하는 메서드입니다. 이것은 이제 클래스 정의를 해석하고 플러그인 API 유형을 생성하는 모델러에게 전달될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 소스 파일 유형을 사용 가능한 데이터로 분해하는 데 도움이 되는 메서드를 분해하고 구축하는 것부터 시작합시다:\n\n소스 파일을 구문 분석하는 데 도움이 되는 몇 가지 메서드가 있습니다.\n\n- tryGetTargetInstance — 모델에서 클래스를 인스턴스화하여 반환합니다. 실행 중에 클래스가 등록되지 않은 경우, 실행이 실패한 이유를 명시적으로 알려주고 사용자가 어떻게 해야 하는지 설명하는 오류가 발생합니다.\n- getPropertiesOf — 클래스 멤버에서 속성을 필터링하는 데 도움이 되는 구문 설탕\n- getClassesFrom — 소스 파일에서 클래스를 필터링하는 데 도움이 되는 구문 설탕\n- processClassFile — 이것은 단일 클래스 속성 처리를 기대하는 뼈대 메서드입니다. 우리의 이상적인 결과는 전체 ColumnDefinition 또는 속성이 어떤 이유로 표현할 수 없는 경우 false입니다.\n- getColumnDefinitionsFrom — ColumnDefinitions를 생성하는 데 호출할 메서드입니다. 또한 출력에서 구문 분석 실패를 필터링합니다.\n\n이제 추출기를 설정하여 소스 파일 구문 분석기의 도우미 메서드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모델러는 여기서 단 하나의 도우미 함수인 extractForeignKeyTables만 가지고 있습니다. 이 함수는 현재 열 목록과 다른 모델 간의 종속성 목록을 생성하여 출력된 업 및 다운 마이그레이션의 순서를 정렬합니다.\n\n이외에도 추출 메서드는 간단합니다. 소스 추출기로 추출할 파일과 등록된 유형을 사용하여 TableInfo[]를 생성하는데, 모두 정적 타입 확인으로 강제됩니다. 이는 각 파일을 반복하고 클래스를 가져와 getColumnDefinitions 메서드를 통해 인터페이스 정의를 추출하는 방식으로 동작합니다. 또한 우리의 도우미 함수를 활용하여 마이그레이션을 구축하는 데 필요한 모든 정보를 얻을 수 있습니다.\n\n이제 라이브러리를 사용하는 최종 사용자의 관점에서 어떻게 보일지 살펴보는 것이 좋을 것 같습니다. 이전에 코드 퍼스트 예제 파일을 검토했지만, 그것을 어떻게 통합할까요? 간단히 다음과 같이 요약해 봅시다:\n\n매우 간단합니다! 먼저 대상 파일(이 경우 CodeFirst.ts 파일)을 가져와 파일로부터 모델 추출을 실행하고 TableInfo 인터페이스를 상태 파일로 출력할 수 있습니다. 이는 로컬 환경과 새로 만든 변경 사항 간의 차이점을 나타내는 변경점에 대해서만 스크립트를 생성하기 위해 이전 마이그레이션 간의 차이를 구현할 가능성이 높은 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가로 예제 플러그인이 생성하는 것을 모델링할 수 있습니다. AutomigrateAPI 인터페이스를 구현하는 스텁 클래스를 간단히 선언하여 해당 정보를 스크립트 파일로 출력하면 됩니다. 이러한 스크립트는 마이그레이션을 수행하는 대상 환경에서 실행하는 것입니다.\n\n사용하기 매우 쉽고 인터페이스에 대해 매우 확신하고 있습니다. 충분한 테스트 커버리지가 있으므로 자신 있게 변경을 할 수 있고 필요에 따라 테스트를 조정할 수 있습니다. 이제 소스 파일 해석이 작동하도록 해 봅시다!\n\n자주 마주칠 개념 중 하나는 TypeScript 컴파일러 API가 구문에 대한 자체 내부 표현을 가지고 있다는 것입니다. 이는 SyntaxKind라는 enum 안에 존재하며 컴파일러가 인식하는 코드의 각 부분에 대한 표현이 있습니다. typescript.d.ts에서 SyntaxKind 정의로 이동하는 단축키인 fn+F12를 사용하여 액세스할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 필요한 것은 TypeScript 컴파일러 출력을 해석하고 작업 중인 인터페이스를 위해 이러한 유형 (DatabaseType)의 표현을 반환하는 기능 세트가 있어야 할 것 같아요.\n\n일단 이를 작성해 봅시다:\n\ntypescriptSyntaxKindToDatabaseTypeMap은 우리 라이브러리의 \"방해 방지 계층\"으로 존재하여 우리가 필요에 따라 쉽게 변화할 수 있게 해줍니다. 대부분이 꽤 직접적인 변환인 점을 고려하면, SyntaxKind를 그대로 사용하고 SyntaxKind.UndefinedKeyword와 SyntaxKind.TypeReference을 만나면 단순히 정의되지 않은 값을 반환하는 것이 아닌가하는 의문이 생길 수 있습니다. 그 이유는 이 라이브러리가 항상 TypeScript 컴파일러를 사용할지 알 수 없기 때문입니다.\n\n이 방법을 통해 API로부터 기저 구현의 세부 정보를 반환함으로써 이를 넘나드는 방법을 만들어봅시다. 우리가 지금 사용하는 것보다 우수한 새 라이브러리를 찾으면 이 라이브러리와는 아무 상관이 없는 응용 프로그램 코드의 중요 부분이 변경되어야 할 수도 있음을 발견할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nextractKeyData 메소드는 클래스 파일을 해석하면서 클래스 객체의 인스턴스에서 데코레이터 (AKA 키 데이터)를 생성합니다. 이는 미래 마이그레이션을 위한 ColumnDefinitions을 생성하는 중요한 부분입니다.\n\n이전에는 processClassProperty라는 메서드 스텁을 추가하여 코드를 작성할 준비를 했습니다. 이제 해당 스텁을 제거하고 TypeScript 컴파일러 API를 통해 많은 속성 정보 추출을 처리할 새 파일에 재작성하겠습니다.\n\n원래 ChatGPT 구현의 \"본질\"은 TypeScript 컴파일러 API에 대해 약간 배웠던 곳에 있습니다. 이를 통해 각 속성 선언이 여러 연관 값들을 가지고 있고, 컴파일러 API가 노드를 평가하는 데 일부 단순화된 도우미를 제공한다는 것을 알게 되었습니다. 몇 가지 유효성 검사 후 정적 유형 확인이 어떻게 타입을 표현하는지도 조금 배우게 될 것입니다.\n\n이는 상당히 큰 코드 청크이므로, 먼저 processClassProperty 메서드에서부터 다른 코드 경로를 방문하면서 분석해 보겠습니다. GitHub에 통합된 빠른 머메이드 차트를 작성해보겠습니다. 이를 README와 함께 문서화의 나머지 부분에 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflowchart TD\n A[processClassProperty]\n A --\u003e B{Is Union Type?} \n B --\u003e |No| singleNode[processSingularNode]\n B --\u003e |Yes| C[Definition is Valid]\n C --\u003e |No| E[Error]\n C --\u003e |Defined Type| singleNode\n singleNode --\u003e typeRefCheck{Node Type?}\n typeRefCheck --\u003e |TypeReference or date| pTypeRef[processFromTypeReferenceNode]\npTypeRef --\u003e return\n typeRefCheck --\u003e |Array| arrayCheck{Is array type?}\n arrayCheck --\u003e retArr[Retrieve array type]\n retArr --\u003e typeRefCheck\n typeRefCheck --\u003e |Basic Type| basicType[typescriptSyntaxKindToDatabaseTypeMap]\n return((return ColumnDefinition))\n basicType --\u003e return\n typeRefCheck --\u003e |Else| error[Error]\n```\n\n![image](/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_9.png)\n\n첫 번째 호출이 속성이 공용 형식인지 여부에 따라 분기되는 것을 볼 수 있습니다. 이는 공용 형식을 사용하는 방식 중 하나로 \"archived: boolean | undefined\"와 같이 null 값을 db 모델로 나타낼 수 있는 방법입니다. 반면에 \"string | number\"를 허용하는 모델을 작성하려는 경우, 대부분의 데이터베이스에서 이를 표현할 수 없으므로 이를 시도하는 사람에게 명시적인 오류를 throw합니다. Else 조건의 경우 \"정의되지 않은 형식\" 노드를 일반적으로 처리할 것입니다.\n\n그리하여 processSingularNode로 이어지는데, 이 처리 과정이 우리의 분류 작업의 주된 부분을 담당합니다. 현재 노드 유형을 가져오고 여러 코드 경로가 있으며 각각은 열 정의를 생성하는 방식에서 약간의 차이가 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Array - 배열은 자체 유형이며 그 아래에 더 많은 노드가 있어 배열화된 값을 정의합니다. 이에 따라 주요 배열 유형을 추출한 후 processSingularNode 호출로 다시 전달해야 합니다. 거기서 반환 값을 내부적으로 처리할 수 있습니다.\n- TypeReference - TypeReference는 사용자가 정의한 클래스나 JavaScript 자체의 데이터 유형인 이 속성을 의미합니다. 두 경우 모두 다룰 것이지만, 현재 우리는 다른 비-기본 유형에 대해서는 아무것도 하지 않습니다.\n- 기본 유형 - 여기서 TypeScript 유형을 API 호출용 데이터범에 매핑하고 값을 반환합니다.\n\n이를 넘어서, 이제 ColumnDefinition을 메인 응용 프로그램으로 반환하고 있습니다! 이제 응용 프로그램을 테스트하고 프로토타입을 구현할 수 있습니다. 인기 있는 데이터베이스인 Postgres 플러그인을 만들어보겠습니다.\n\n플러그인을 구현하는 사람을 위해 drop table 문의 정렬기가 유용하다는 것을 알고 있습니다. 플러그인을 활용하는 누구나 테이블 삭제를 순서대로 처리하는 정렬기를 사용할 수 있도록 하겠습니다. 우리가 각 구현에서 수행해야 할 것임을 알고 있기 때문에 모든 사람들의 시간을 절약하기 위해 도움말 파일을 추가하겠습니다:\n\n그리고 자신의 테이블이 효과적으로 정렬되는지 확인하기 위해 몇 가지 테스트를 작성해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상단의 테스트에서 우리가 기대한 정렬 순서가 유지되었음을 확인했으므로 테이블을 올바르게 삭제할 것입니다. 이것은 특히 복잡한 시나리오를 처리하지는 않지만, 미래 유지보수자나 이관 도구를 사용하고 싶어하는 사람들에게 일부 테스트된 리소스를 제공하는 방법을 보여주기 위한 단순한 구현입니다.\n\n이제 빠르게 Postgres 플러그인을 만들어 봅시다:\n\n이 플러그인은 조금 무겁지만, 빠르게 살펴보겠습니다:\n\n- postgresMap은 데이터베이스 유형 추상화에서 Postgres의 데이터 유형으로의 관계를 제공합니다. 이는 열 정의를 구성할 때 사용됩니다.\n- columnMap은 열을 생성하는 방법입니다. 가능한 옵션의 배열을 만들고, junk를 제거하기 위해 boolean에 맞게 필터링한 다음, 이를 하나의 공백으로 결합합니다. 여기에는 열의 기본/외래 키 지정도 포함되어 있습니다.\n- relationshipMap은 외래 키 관계를 매핑하는 작은 도우미입니다.\n- tableCreateMapper는 매우 직관적으로 단일 완전한 테이블 생성 스크립트를 생성합니다.\n- tableDropMapper는 유사하지만 테이블 삭제용입니다.\n- PostgresPlugin은 AutomigrateAPI를 실제로 구현하는 클래스입니다. 다른 함수들을 한 곳에 모아 AutoMigrateOutput을 생성하여 데이터베이스에 적용할 수 있는 up-and-down 이관을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 모든 코드를 미리 작성했고 모델도 작성했으니, 테스트를 한 번 해보겠습니다! 먼저, 방금 작성한 Postgres 플러그인을 사용하도록 예제 인덱스 파일을 변경하겠습니다:\n\n위의 차이점을 보면 예제 플러그인을 PostgresPlugin으로 교체하는 것을 보여줍니다. 이런 식으로 인터페이스를 활용하는 것의 장점은 이 코드 조각을 쉽게 교체할 수 있으며, 테스트의 다른 부분에는 변경이 필요하지 않다는 것입니다. 모든 것이 여전히 동일하게 작동합니다. 실행하면 두 가지 예상 출력이 생성됩니다: 현재 실행 상태를 포함하는 state/state.json 파일과 API 인터페이스에서 정의한 마이그레이션을 포함하는 scripts/scripts.json 파일(문자열 배열로 된 up 및 down).\n\n우리의 출력 상태에는 테이블 정보 배열이 포함되어 있습니다. 이 배열은 테이블 이름, 열, 다른 테이블과의 관계에 대한 문자열 배열을 포함합니다. 열 정의에는 필드 이름, 열 유형, Null 여부 및 수정자(즉, 키)가 포함됩니다. 이 모든 것이 플러그인에게 유효한 마이그레이션을 생성하는 데 필요했던 내용입니다. 이것은 기본 사례를 다루지만, 프로덕션 환경에서 플러그인을 올바르게 관리하기 위해 상태 파일의 다른 반복을 저장하고 비교해야 할 것입니다.\n\n생산된 마이그레이션이 무엇인지 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 보았을 때, 출력물이 API 정의와 일치하는 것을 확인할 수 있습니다. up 및 down 문자열 배열을 포함하는 JSON 객체는 마이그레이션 프로세스의 단계를 나타냅니다. 테이블 생성문이 작동하고, 데이터를 제대로 비우기 위해 테이블 삭제문이 순서대로 나열되어 있어 우리의 다운 마이그레이션 작업이 문제없이 진행될 수 있음을 알 수 있습니다. 우리의 기본 케이스가 잘 이행된 것이죠!\n\n# 다음 단계\n\n마이그레이션 도구를 프로덕션 환경에 사용할 수 있도록 만드는 것은 범위를 벗어나지만, 이 곳에서 생성된 로직의 대부분이 이미 완성되었으므로 우리에게는 꽤 간단한 길이 있다는 것을 알고 있습니다. 프로덕션 환경에 맞게 만들기 위해 statefile 작업에 관한 몇 가지를 변경해야 합니다:\n\n- 내부적으로 statefile을 관리하기 위해 라이브러리의 실행 프로세스를 수정하거나 새로운 메소드 집합을 개발합니다.\n- statefile에 해시 코드 또는 날짜 후위사항을 추가하여 어떤 순서로 statefile을 고려해야 하는지 추적할 수 있도록 합니다.\n- statefile 간의 차이를 활용하여 플러그인 아키텍처에서 호출할 메소드를 결정하는 책임을 지는 클래스를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 라이브러리 코드 실행 사이에 마이그레이션 차이점만 적용할 수 있습니다.\n\n플러그인 자체에 대해 말하자면, 지금은 완전히 구현된 테이블만 생성할 수 있습니다. 단일 책임 원칙을 위반하지 않고 플러그인 아키텍처를 명확하고 간결하게 유지하는 가장 좋은 방법은 차이점을 처리하고 이를 플러그인 API 호출로 변환하는 레이어를 삽입하는 것입니다. 우리를 제품 사용 가능한 상태로 이끌 수 있는 몇 가지 API 변경과 수정이 있습니다:\n\n- 테이블 제거\n- 열 추가/삭제/변경\n- 관계 변경\n- 수동 스크립트 (데이터 마이그레이션 등)\n\nChatGPT가 우리에게 가르칠 수 있는 것들을 살펴보고 TypeScript 컴파일러 API에 대해 좀 더 배우는 것을 즐겼으면 좋겠습니다. 이것은 메타 프로그래밍 작업에 강력한 도구이며 개발자의 관점에서 매우 흥미로운 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 작동 코드를 확인하고 싶다면, 디버깅으로 실행하고 npm 설치를 위한 로컬 라이브러리 빌드 구성이 포함된 최종 운영 코드를 확인하실 수 있습니다. GitHub 링크는 여기 있어요:\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png"},"coverImage":"/assets/img/2024-05-27-UsingChatGPTtheTypeScriptCompilerandExperimentalDecoratorstoBuildaBasicCode-FirstDBTool_0.png","tag":["Tech"],"readingTime":15},{"title":"Angular 18의 새로운 기능 알아보기","description":"","date":"2024-05-27 18:51","slug":"2024-05-27-WhatsnewinAngular18","content":"\n\n![image](/assets/img/2024-05-27-WhatsnewinAngular18_0.png)\n\n2024년 5월 23일에 릴리스된 Angular의 새로운 버전인 Angular 18은 개발을 간소화하고 성능을 향상시키며 보다 동적인 웹 애플리케이션을 작성할 수 있도록 개선 사항을 가져왔습니다. 주요 기능들을 살펴보고 Angular 경험을 더 높여줄 수 있는 기능들을 살펴보겠습니다.\n\n## 독립형 컴포넌트 — 더 간단하고 재사용 가능한 구성 요소\n\nAngular 18은 독립형 컴포넌트를 소개하여 NgModules의 제약 없이 재사용 가능한 컴포넌트를 만들 수 있게 했습니다. 이를 통해 프로젝트 구조를 간소화하고 보일러플레이트 코드를 줄이며 모듈식 접근 방식을 사용할 수 있습니다. 더 작고 독립적인 컴포넌트로 복잡한 UI를 구축하고 이를 유지 보수하고 응용 프로그램의 다른 영역 간에 공유하기 쉽게 만들어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에는 기본 독립형 컴포넌트를 보여주는 코드 예제가 있습니다:\n\n![DatePickerComponent](/assets/img/2024-05-27-WhatsnewinAngular18_1.png)\n\n이 예제에서 DatePickerComponent는 NgModule이 필요하지 않습니다. 직접 가져와서 애플리케이션의 루트 모듈이나 다른 컴포넌트에서 사용할 수 있습니다. 이를 통해 UI를 구축하는 더 가벼운 방식과 조립 가능한 방식을 촉진합니다.\n\n## Zone-less Change Detection — 성능 향상 (실험적)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 18은 실험적 기능으로 Zone-less 변화 감지를 소개했습니다. Zone.js에 대한 의존성을 제거함으로써, 이 방식은 특히 대규모 애플리케이션에서 성능 향상을 이끌어낼 수 있습니다. Zone.js는 특정 시나리오에서 오버헤드를 일으킬 수 있으며, Zone-less 변화 감지는 Angular 애플리케이션 내에서 변화 감지에 대한 대안적 접근 방식을 제공합니다.\n\n## 함수를 이용한 라우트 리다이렉트 — 유연한 라우팅 제어\n\n함수를 정의할 수 있는 기능을 통해 라우트 리다이렉트는 더 많은 기능을 얻습니다. 이를 통해 애플리케이션의 라우팅 전략 내에서 더 동적이고 조건부적인 리다이렉션 로직을 구현할 수 있습니다. 사용자 역할, 인증 상태 또는 기타 동적 조건에 따라 리다이렉트를 생성하는 상황을 상상해보세요.\n\n![이미지](/assets/img/2024-05-27-WhatsnewinAngular18_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개선된 디버깅 도구 — 문제 해결이 쉬워집니다\n\nAngular 18은 디버깅 도구를 개선했으며 의존성 주입 계층 구조에 대한 더 나은 가시성과 DI 관련 문제에 대한 개선된 오류 메시지를 제공합니다. 복잡한 Angular 애플리케이션의 디버깅은 때로는 어려울 수 있습니다. 개선된 디버깅 도구는 의존성 주입과 관련된 문제를 더 쉽게 식별할 수 있도록 도와주며 디버깅 프로세스를 간소화합니다.\n\n## 새롭고 업데이트된 웹 사이트\n\nAngular.io가 Angular.dev로 대체되었습니다. 기능인 문서, 튜토리얼 및 새로운 기능을 살펴볼 수 있는 플레이그라운드와 함께 재정의된 사용자 인터페이스를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-WhatsnewinAngular18_3.png\" /\u003e\n\n## 강조점 너머\n\n이것들은 Angular 18의 많은 흥미로운 기능 중 일부입니다. 다른 주목할만한 개선 사항은 다음과 같습니다:\n\n- 향상된 AOT 컴파일: 더 효율적인 AOT 컴파일 프로세스로 대규모 응용 프로그램의 빌드 시간을 단축하고 실행 시간 성능을 향상시킬 수 있습니다.\n- ng-content 기본 콘텐츠: 컴포넌트 템플릿의 유연성을 높이기 위해 ng-content 태그 내에서 기본 콘텐츠를 직접 정의할 수 있습니다. 이를 통해 구성 요소의 구조를 단순화하고 콘텐츠가 어떻게 투영되는지에 대한 더 많은 제어권을 제공할 수 있습니다.\n- TypeScript 5.5 지원: TypeScript의 최신 기능과 개선 사항을 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앵귤러 개발의 미래에 도전하세요\n\n성능, 개발자 경험 및 모듈성에 초점을 맞춘 Angular 18은 우수한 웹 애플리케이션을 구축할 수 있도록 돕습니다. 이러한 기능에 대해 자세히 살펴보고 다음 프로젝트에서 Angular 18의 전체 잠재력을 발휘하기 위해 공식 Angular 문서를 탐험해보세요.\n\n기억하세요, 이것은 시작에 불과합니다. Angular 18은 탐험할 다양한 기능을 제공합니다. 포괄적인 세부 정보 및 코드 예제를 위해 공식 문서를 참조해보세요.\n\n원문: [https://cheeseblogger.com](https://cheeseblogger.com), 2024년 5월 25일에 게시됨","ogImage":{"url":"/assets/img/2024-05-27-WhatsnewinAngular18_0.png"},"coverImage":"/assets/img/2024-05-27-WhatsnewinAngular18_0.png","tag":["Tech"],"readingTime":3},{"title":"ElysiaJS 소개 및 정리","description":"","date":"2024-05-27 18:50","slug":"2024-05-27-FirstLookAtElysiaJS","content":"\n\n## 새로운 번 런타임 환경에서 현대적인 API 구축\n\n중간에 Medium에 오랫동안 없어서 죄송합니다. 제가 계획한 기사 시리즈, 튜토리얼, 고찰 및 코드를 공유하기 위해 기다리고 있습니다.\n\n최근에 프론트엔드 개발자로서 큰 전기를 경험했습니다. 백엔드 개발에 더 많은 시간을 투자해야겠다고 결정했습니다. 최근에 트윗을 읽고 새로운 기술이 Ben Holmes의 의견을 이끈다는 것에 대해 생각해보게 되었습니다.\n\n인터넷 전체(Reddit.com만)를 연구하고 사람들의 의견을 듣고 나니, 개발자들은 여전히 Express를 좋아하는 것으로 결론을 내렸습니다. Express는 인터넷에 많은 것을 제공해 왔으며 여전히 가장 안정적인 라이브러리 중 하나입니다. 하지만 저는 개인적으로 다른 기술을 시도하고 다른 기술에 도전하고 싶었습니다. 그때 발견한 것이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 번\n\n![이미지](/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png)\n\n와 어마어마해! 그게 필요한 거잖아. 또 다른 자바스크립트... 잠깐, 런타임 환경?\n\n맞아, 라이브러리나 프레임워크가 아니야; 런타임 환경이거든. 2018년에 Ryan Dahl이 Node 문제를 해결하기 위해 Deno를 발명했지만, 그렇게 유명해진 것 같지는 않아.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2023년 9월 8일, Bun이 첫 안정 버전을 출시했어요. 많은 JavaScript 개발자들이 이 새로운 런타임 환경을 시도 중이고 매우 유망해 보여요. Next, Nuxt, SvelteKit과 같은 유명한 프론트엔드 프레임워크들이 Bun을 사용할 수 있는 옵션을 제공하고 있어요. 저는 Bun 라이브러리들을 살펴보았고 API를 구축하기 위해 이것을 배우기로 결정했어요:\n\n# ElysiaJS\n\n![ElysiaJS](/assets/img/2024-05-27-FirstLookAtElysiaJS_1.png)\n\nElysiaJS는 자신을 \"에르고노믹 프레임워크\"로 소개하며 엔드투엔드 유형 안전성을 제공한다고 주장해요. 이 언어를 시험해보고 나서, 나는 이것을 매우 직관적으로 느꼈어요. 풍부한 API, 훌륭한 플러그인 관리 및 원하는 것이 정확히 얻을 수 있도록 보증해주는 견고한 유효성 검사 API가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Elysia 설치하기\n\n이 문서에서는 이미 Bun을 설치했다고 가정합니다. 다음과 같이 새로운 Elysia 애플리케이션을 생성할 수 있습니다:\n\n```js\nbun create elysia hello-server\ncd hello-server\n```\n\n기존 애플리케이션이 있다면, Elysia를 다음과 같이 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbun add elysia\n```\n\n그리고 여기에 자세히 설명된 패키지.json 파일에 필요한 스크립트를 설정하세요.\n\n# ElysiaJS 첫 번째 살펴보기\n\n몇 줄의 코드로 매우 간단한 서버를 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* src/index.ts */\nimport { Elysia } from 'elysia';\n\nconst app = new Elysia()\n  .onStart(() =\u003e console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () =\u003e \"안녕하세요 서버\")\n  .listen(8080);\n```\n\n이 서버를 실행하고 테스트할 수 있습니다:\n\n```js\n$ bun dev\n서버가 시작되었습니다!\n\n$ curl http://localhost:8080/\n안녕하세요 서버\n```\n\n더 많은 라우트를 그룹화하고 생성하기 위해 인스턴스를 만들고 메인 애플리케이션에서 사용할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node src/index.ts\"\n  },\n  \"dependencies\": {\n    \"elysia\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^4.0.3\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 프레임워크는 Elysia가 하는 일을 합니다. 그런데 왜 Elysia가 다른 것일까요? 그것은 타입 안전성과 유효성 검사 때문입니다. 위의 나이 예제를 고려해보세요. 나이는 어떤 타입이든 될 수 있습니다. 이것은 타입 안전하지 않습니다.\n\n```js\n/* src/index.ts */\nimport { Elysia, t } from 'elysia';\n\nconst age = new Elysia()\n  .get('/age', () =\u003e \"당신의 나이를 모릅니다.\")\n  .post('/age', ({ body: { age } }) =\u003e `안녕하세요, 당신은 ${age}살 입니다.`, {\n    body: t.Object({\n      age: t.Number()\n    })\n  });\n\nconst app = new Elysia()\n  .onStart(() =\u003e console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () =\u003e \"안녕하세요 서버\")\n  .use(age)\n  .listen(8080);\n```\n\n이 서버를 다시 실행하고 bun dev를 사용하여 테스트해보세요.\n\n```js\n$ curl -v -H \"Content-Type: application/json\" \\\n\u003e   -X POST \\\n\u003e   -d '{\"age\": \"20\"}' \\\n\u003e   http://localhost:8080/age\n{\n  \"type\": \"body\",\n  \"at\": \"age\",\n  \"message\": \"예상된 숫자\",\n  \"expected\": {\n    \"age\": 0\n  },\n  \"found\": {\n    \"age\": \"20\"\n  },\n  \"errors\": [\n    {\n      \"type\": 41,\n      \"schema\": {\n        \"type\": \"number\"\n      },\n      \"path\": \"/age\",\n      \"value\": \"20\",\n      \"message\": \"예상된 숫자\"\n    }\n  ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nElysiaJS에서는 나이 대신 숫자가 아닌 문자열을 보내면 오류가 발생합니다. 서버 측 개발자로서, 본문 데이터를 수동으로 유효성 검사할 필요가 없었습니다. 응답의 헤더를 보면 HTTP/1.1 400 Bad Request가 반환되는 것을 확인할 수 있습니다. 정수를 전달하면 curl이 성공합니다.\n\n```js\n$ curl -v -H \"Content-Type: application/json\" \\\n\u003e   -X POST \\\n\u003e   -d '{\"age\": 20}' \\\n\u003e   http://localhost:8080/age\nHi, you are 20 years old\n```\n\n# ElysiaJS/Eden\n\n이것은 Type-Safety 제목의 확장입니다. API 엔드포인트를 테스트할 때 curl을 사용했습니다. 개발자로서, Postman이나 wget을 사용할 수도 있지만 이러한 도구들은 타입 안전하지 않습니다. 요청을 할 때 실수를 하면 정의되지 않은 동작이 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 애플리케이션은 API 요청을 할 때 타입 오류가 발생하기 쉽습니다. tRPC는 이 기능을 제공하는 좋은 시도였지만, 프로젝트를 구현하기 위한 적응성이 큰 단점이었습니다. Eden은 이 문제를 훌륭하게 해결하여 이 시리즈의 향후 기사에서 자세히 다루겠습니다.\n\nEden으로 돌아와서, 라우트가 원하는 대로 작동하는지 확인하기 위해 일부 유닛 테스트를 작성해보겠습니다. 먼저 index.ts에서 애플리케이션 타입을 내보내야 합니다.\n\n```js\n/* src/index.ts */\nimport { Elysia, t } from 'elysia';\n\nconst age = new Elysia()\n  .get('/age', () =\u003e \"당신의 나이를 모르겠어요\")\n  .post('/age', ({ body: { age } }) =\u003e `안녕하세요, 당신은 ${age}살 입니다`, {\n    body: t.Object({\n      age: t.Number()\n    })\n  });\n\nconst app = new Elysia()\n  .onStart(() =\u003e console.log(\"서버가 시작되었습니다!\"))\n  .get('/', () =\u003e \"안녕하세요 서버\")\n  .use(age)\n  .listen(8080);\n\nexport type App = typeof app // \u003c- 타입을 내보내기\n```\n\n두 번째로, 유닛 테스트를 작성할 수 있습니다. 의존성으로 @elysiajs/eden을 설치해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* test/route.test.ts */\nimport { describe, expect, it } from 'bun:test';\nimport { edenTreaty } from '@elysiajs/eden';\nimport { type App } from '../src';\n\nconst BASE_URL = \"http://localhost:8080\";\nconst app = edenTreaty\u003cApp\u003e(BASE_URL);\n\ndescribe(\"Age API\", () =\u003e {\n  it(\"GET / works as expected\", async () =\u003e {\n    const { data, status } = await app.get();\n\n    expect(data).toBe(\"Hello Server\");\n    expect(status).toBe(200);\n  });\n\n  describe(\"/age routes\", () =\u003e {\n    it(\"GET /age returns IDK\", async () =\u003e {\n      const { data, status } = await app.age.get();\n\n      expect(data).toBe(\"I don't know your age\");\n      expect(status).toBe(200);\n    });\n\n    it(\"POST /age with number returns OK\", async () =\u003e {\n      const body = { age: 20 };\n      const { data, status } = await app.age.post(body);\n\n      expect(data).toBe(`Hi, you are ${body.age} years old`);\n      expect(status).toBe(200);\n    });\n\n    it(\"POST /age with string returns error\", async () =\u003e {\n      const body = { age: \"20\" };\n      const { status, error } = await app.age.post(body);\n\n      expect(status).toBe(400);\n      expect(error).toBeTruthy();\n    });\n\n    it(\"POST /age with wrong key returns error\", async () =\u003e {\n      const body = { myAge: \"20\" };\n      const { status, error } = await app.age.post(body);\n\n      expect(status).toBe(400);\n      expect(error).toBeTruthy();\n    });\n  })\n});\n```\n\n우리가 가진 라우트에 대한 유형이 edenTreaty에서 반환될 때 다음과 같이 매핑됩니다:\n\n```js\nGET /              -\u003e app.get()\nGET /age           -\u003e app.age.get()\nPOST /age          -\u003e app.age.post(body)\n\nGET /api/books     -\u003e app.api.books.get()\nGET /api/books/:id -\u003e app.api.books[id].get()\nPOST /auth/login   -\u003e app.auth.login.post(body)\n```\n\nhttp://localhost:8080에서 서버를 실행 중이라면, 애플리케이션을 테스트해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ bun test\nbun test v1.0.30 (1424a196)\n\ntest/route.test.ts:\n✓ Age API \u003e /age routes \u003e GET /age returns IDK [3.70ms]\n✓ Age API \u003e /age routes \u003e POST /age with number returns OK [1.35ms]\n✓ Age API \u003e /age routes \u003e POST /age with string returns error [5.12ms]\n✓ Age API \u003e /age routes \u003e POST /age with wrong key returns error [0.94ms]\n✓ Age API \u003e GET / works as expected [0.59ms]\n\n 5 pass\n 0 fail\n 10 expect() calls\nRan 5 tests across 1 files. [43.00ms]\n\n\nEden은 E2E Type Safety를 얻을 수 있는 훌륭한 도구입니다. 이를 프런트엔드 애플리케이션에서 사용하거나 서버를 테스트할 때 활용할 수 있습니다.\n\n# 결론\n\n안타깝게도 이 글은 너무 길어져서 종료하겠습니다. 유용한 기능을 가진 Elysia에 대한 설명을 계속 진행할 수 없어서 유감스럽습니다. 더 많은 정보를 알고 싶다면 여기에서 문서를 확인할 수 있습니다. Elysia 팀은 훌륭한 일을 하고 있고 이 라이브러리가 밝은 미래를 가질 것으로 기대합니다. 첫 안정적인 릴리스를 기대할 수밖에 없네요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 기사를 즐겁게 읽어 주셨기를 바랍니다. 무슨 교훈이 있다면 더 좋겠네요. 감사합니다!\n\n```js\n연결하고 싶으시면?\n\n내 GitHub 프로필.\n내 포트폴리오 웹사이트.\n```","ogImage":{"url":"/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png"},"coverImage":"/assets/img/2024-05-27-FirstLookAtElysiaJS_0.png","tag":["Tech"],"readingTime":8},{"title":"모던 브라우저에서 AWS S3 직접 업로드하는 방법","description":"","date":"2024-05-27 18:48","slug":"2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers","content":"\n\n안녕하세요, 제 이름은 Taylor Hughes입니다. 소프트웨어 엔지니어입니다. 저는 페이스북, 구글, 클럽하우스 및 중간의 여러 스타트업에서 앱을 출시하고 팀을 구축했습니다.\n\n사용자가 S3 버킷에 파일을 업로드할 수 있는 방법을 제공하는 문제는 모든 프로젝트에서 마주치는 문제입니다. 그러나 올바른 JavaScript 구성 요소를 식별하고 모든 것을 함께 작동하도록 설정하여이 작업을 수행하는 것은 마법처럼 느껴집니다.\n\nAWS 문서에 따르면 추가 인증 서비스를 설정하고 전체 AWS JS SDK를 클라이언트 코드로 가져와야하지만 실제로 그럴 필요는 없습니다!\n\n대신 사전 서명된 URL 및 현대적인 웹 API를 사용하여 브라우저에서 손쉽게 S3로 직접 업로드 할 수 있습니다. 코드 몇 줄을 사용하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 브라우저의 관점에서 전체 솔루션은 다음과 같습니다:\n\n- 사용자가 \"파일 업로드\"를 클릭하고 파일을 선택합니다.\n- 해당 파일의 메타데이터를 기반으로 서버 측 API에서 미리 서명된 S3 PutObject URL을 요청합니다.\n- 미리 서명된 S3 URL을 제공받으면 브라우저는 XmlHttpRequest를 사용하여 파일을 PUT하고 진행 상황을 모니터링할 수 있습니다.\n- 업로드가 완료되면 브라우저는 새 키를 다시 API로 반환하여 업로드된 파일에 대해 API가 수행해야 하는 작업을 트리거합니다.\n- 이윤 창출!\n\n만약 완성된 코드로 바로 이동하고 싶다면, TypeScript 프론트엔드 및 Python API 핸들러 예시가 포함된 gist를 확인해보세요.\n\n이 게시물에서는 단계별로 진행해 보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## AWS 구성\n\n먼저, 공개 액세스가 비활성화되어 있고 액세스 정책이 없는 새 버킷 yourproject-upload을 만듭니다. (또한 이 버킷에 대해 모든 것을 24시간 후에 만료되도록 하는 라이프사이클 규칙을 추가했습니다 — 업로드된 파일을 다른 위치로 이동하여 공개적으로 사용합니다.)\n\n둘째, web-upload-only라는 새 IAM 사용자를 추가합니다. 새 사용자의 액세스 키와 비밀을 가져와서 이를 백엔드 웹 서버에 추가하세요. (이 자격 증명은 주 AWS 자격 증명과 별도여야 합니다.)\n\n셋째, web-upload-only에게 새 버킷 yourproject-upload/*의 모든 경로에 대한 s3:PutObject 액세스 권한을 부여합니다. (우리는 사전 서명된 PutObject URL을 반환할 때 쓰기 키를 제한할 것입니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png\" /\u003e\n\n마지막으로, 일반 AWS 역할 또는 사용자에게 yourproject-upload/* 버킷에 s3:GetObject 액세스도 부여하세요. 업로드 버킷에서 파일을 가져와 main/public 서빙 버킷으로 옮기기 위해 더 많은 권한을 가진 다른 사용자가 필요합니다.\n\n## 웹 서버: \"업로드 생성\" API 엔드포인트 추가\n\n새 IAM 사용자의 액세스 키와 시크릿을 얻었다면 이제 S3에 특정 키를 쓸 수 있는 사전 서명된 URL을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 엔드포인트로 전송되는 입력은 다음과 같습니다:\n\n- content_type — 브라우저의 PUT 요청의 컨텐츠 유형으로 설정될 파일의 MIME 유형이며, 서명에 포함되어야 합니다.\n- filename — 파일의 원본 파일명으로, 여기서 확장자를 가져와서 S3 키에 좋은 확장자를 부여할 수 있습니다.\n\n이러한 입력을 바탕으로 AWS S3 클라이언트를 생성하고 서명된 PutObject URL을 생성하세요. Python에서 boto3를 사용하면 다음과 같이 보입니다:\n\n```python\ndef upload_s3_client() -\u003e S3Client:\n    return boto3.client(\n        \"s3\",\n        aws_access_key_id=settings.UPLOAD_AWS_ACCESS_KEY_ID,\n        aws_secret_access_key=settings.UPLOAD_AWS_SECRET_ACCESS_KEY,\n        region_name=AWS_REGION,\n    )\n\n@api_view(\"/upload/create\")\ndef create_upload(request: Request) -\u003e Response:\n    ext = request.validated_data[\"original_filename\"].split(\".\")[-1].lower()\n    # 생성된 S3 경로에 사용자 ID와 날짜 포함하기:\n    date = datetime.now().strftime(\"%Y%m%d\")\n    key = f\"uploads/{request.user.id}/{date}-{uuid.uuid4()}.{ext}\"\n    # 서명된 URL 생성:\n    presigned_upload_url = upload_s3_client().generate_presigned_url(\n        \"put_object\",\n        Params={\n            \"Bucket\": \"yourproject-upload\",\n            \"Key\": key,\n            \"ContentType\": request.validated_data[\"content_type\"],\n        },\n        ExpiresIn=60 * 60,\n    )\n    # 클라이언트에게 키 및 서명된 PutObject URL을 반환합니다:\n    return success_response(\n        {\"key\": key, \"presigned_upload_url\": presigned_upload_url}\n    )\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클라이언트 측: 모두 연결하기\n\n이제 클라이언트 측에서는 파일 입력란을 추가하여 파일 객체를 가져와야합니다. 한 번 파일 객체를 가져오면 새 API 백엔드에서 미리 서명된 URL을 요청할 수 있습니다. API 요청을 보통 어떻게 만들든지 상관없습니다:\n\n```js\nfunction getPresignedUrl(file: File) {\n  return makeAPIRequest(\n    \"POST\",\n    \"upload/create\",\n    {\n      original_filename: file.name,\n      content_type: file.type,\n    },\n    (response) =\u003e response as {\n      key: string;\n      presigned_upload_url: string;\n    },\n  );\n}\n```\n\n그런 다음, XmlHttpRequest를 만들어 파일을 직접 S3로 전송할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction uploadFile(\n  file: File,\n  presignedUploadUrl: string,\n  onProgress: (pct: number) =\u003e void,\n): Promise\u003cvoid\u003e {\n  return new Promise\u003cvoid\u003e((resolve, reject) =\u003e {\n    const xhr = new XMLHttpRequest();\n    xhr.upload.addEventListener(\"progress\", (e) =\u003e {\n      if (e.lengthComputable) {\n        const pct = e.loaded / e.total;\n        onProgress(pct * 100);\n      }\n    });\n    xhr.upload.addEventListener(\"error\", (e) =\u003e {\n      reject(new Error(\"Upload failed: \" + e.toString()));\n    });\n    xhr.upload.addEventListener(\"abort\", (e) =\u003e {\n      reject(new Error(\"Upload aborted: \" + e.toString()));\n    });\n    xhr.addEventListener(\"load\", (e) =\u003e {\n      if (xhr.status === 200) {\n        resolve();\n      } else {\n        reject(new Error(\"Upload failed \" + xhr.status));\n      }\n    });\n    xhr.open(\"PUT\", presignedUploadUrl, true);\n    try {\n      xhr.send(file);\n    } catch (e) {\n      reject(new Error(\"Upload failed: \" + e.toString()));\n    }\n  });\n}\n```\n\nReact Hooks를 사용하는 프로젝트라면 다음과 같이 모두 연결할 수 있습니다:\n\n```js\nexport function useUpload() {\n  const [uploadState, setUploadState] = useState\u003c\n    \"idle\" | \"starting\" | \"uploading\" | \"finishing\" | \"done\" | \"error\"\n  \u003e(\"idle\");\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [uploadError, setUploadError] = useState\u003cError | null\u003e(null);\n\n  return {\n    uploadState,\n    uploadProgress,\n    uploadError,\n    upload: async (\n      file: File,\n      onSuccess: (uploadKey: string) =\u003e Promise\u003cvoid\u003e,\n    ) =\u003e {\n      setUploadState(\"starting\");\n\n      try {\n        // 백엔드 API에서 사전 서명된 URL 가져오기:\n        const { key, presigned_upload_url } = await getPresignedUrl(\n          file,\n        );\n        setUploadState(\"uploading\");\n        // XmlHttpRequest를 사용하여 실제 업로드:\n        await uploadFile(file, presigned_upload_url, (pct) =\u003e {\n          setUploadProgress(pct);\n        });\n        setUploadState(\"finishing\");\n        // 이 업로드된 파일을 유용하게 활용하기; 아마도 이 키를 다른 API 엔드포인트로 전달할 것입니다!\n        await onSuccess(key);\n        setUploadState(\"done\");\n      } catch (e) {\n        setUploadState(\"error\");\n        setUploadError(e);\n      }\n    },\n  };\n}\n```\n\n## 마지막으로: 새로 업로드된 파일 사용하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업로드가 완료되면 업로드한 S3 키를 API로 전송하여 다른 곳에 저장하거나 원하는 대로 후속 처리할 수 있습니다.\n\n업로드 전용 S3 버킷 내의 경로인 업로드 키를 받는 또 다른 API 엔드포인트를 추가하세요. 그런 다음 파일을 다운로드하여 유효성을 검사하거나 다른 서비스에서 즉시 사용할 수 있도록 다른 버킷으로 복사할 수 있습니다.\n\n(저는 업로드 키에 인증된 사용자 ID를 넣는 것을 좋아합니다. 이렇게 하면 이 엔드포인트 내에서 현재 사용자로부터 업로드된 것인지 확인할 수 있습니다.)\n\n다음은 Python에서 버킷을 공개 서빙 버킷에 복사하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nupload_key = request.validated_data[\"upload_key\"]\next = upload_key.split(\".\")[-1]\nslug = slugify(request.validated_data[\"filename\"])\ndate = datetime.now().strftime(r\"%Y%m%d_%H%M%S\")\npublic_key = f\"media/{request.user.id}/{date}-{slug}.{ext}\"\n\ntry:\n  public_content_s3_client().copy(\n    CopySource={\n      \"Bucket\": \"yourproject-upload\",\n      \"Key\": upload_key,\n    },\n    Bucket=\"yourproject-public\",\n    Key=public_key,\n  )\nexcept Exception:\n  logging.exception(f\"Failed to copy file for user={request.user.id}\")\n```\n\n요렇게 해요. 누군가에겐 도움이 되길 바래요! 혹시 다시 필요하시다면 여기 스크립트 내용이 담긴 gist 링크도 드릴게요. 🥰\n\n의견이나 피드백이 있으시면 언제든지 알려주세요! @taylorhughes\n","ogImage":{"url":"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png"},"coverImage":"/assets/img/2024-05-27-Simplesecuredirect-to-S3uploadsfrommodernbrowsers_0.png","tag":["Tech"],"readingTime":7},{"title":"NestJS의 비즈니스 로직 조직 이해하기","description":"","date":"2024-05-27 18:47","slug":"2024-05-27-UnderstandingNestJSsBusinessLogicOrganization","content":"\n\n\n![Understanding NestJS's Business Logic Organization](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png)\n\n전통적인 MVC 아키텍처에서 왔다면 NestJS는 낯설게 느껴질 수 있습니다. 물론, view(사용자 인터페이스) 계층, model(데이터베이스) 계층, 및 controller(비즈니스 로직) 간의 관심사 분리 아이디어는 존재합니다. 그러나 NestJS에서는 파일과 비즈니스 로직을 구조화하기 위한 새로운 흐름을 소개합니다. 라우팅 요청에 대한 컨트롤러, 비즈니스 로직 처리를 위한 서비스, 데이터베이스 조작을 위한 리포지토리의 패턴을 사용합니다. NestJS에서 비즈니스 로직을 어떻게 구성할지 살펴보겠습니다.\n\n## 요청 처리 새로운 방식\n\nNestJS는 구성 기반의 백엔드 프레임워크입니다. JavaScript로 작성되었지만 TypeScript를 사용할 때 가장 빛을 발합니다. 기본 NodeJS와 Express의 Wild West 접근 방식과 Ruby on Rails의 엄격한 규칙 기반 접근 방식과는 다릅니다. NestJS는 애플리케이션 개발을 위한 최상의 관행을 형성하면서도 유연한 디자인을 가능하게 하는 패턴 또는 레시피를 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS 프로젝트의 설정은 모듈의 조율에 중점을 두고 있습니다. 모든 로직은 기능을 제공하거나 사용하는 모듈에 래핑되어 있습니다. 다른 소프트웨어와 마찬가지로 진입점이 있으며 서로 의존하는 웹이 있습니다:\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_1.png)\n\nNestJS는 사용자 요청을 처리하기 위해 서비스와 리포지토리를 모듈 간에 공유하면서 복잡해질 수 있습니다. 단순하게 시작하여 컨트롤러, 서비스 및 리포지토리를 포함하는 격리된 모듈부터 시작하는 것이 좋습니다. 데이터베이스 변경 요청이 NestJS 프로젝트를 통해 어떻게 라우팅되는지 살펴보겠습니다.\n\n## NestJS에서 컨트롤러는 무엇을 하는가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것은 컨트롤러에서 시작됩니다. 클래식 MVC 프로젝트에서는 컨트롤러가 프로젝트의 많은 부분을 책임집니다. 뷰는 서버에서 반환된 데이터를 반영합니다. 모델은 데이터 구조를 제공하고 레코드와 관련된 비즈니스 로직을 저장하며, 컨트롤러는 이들 간의 모든 것을 조율합니다.\n\nNestJS에서도 컨트롤러는 일부 비슷한 기능을 가지지만 책임은 훨씬 적습니다. 컨트롤러는 간단히 트래픽 디렉터로 기능하여 어디로 어떻게 전달해야 하는지 확인합니다. 요청 유효성 검사를 위한 파이프나 들어오는 데이터를 형성하고 유효성 검사하기 위한 DTO(데이터 전송 객체)와 같이 더 많은 기능을 추가할 수 있지만, 컨트롤러는 비즈니스 로직을 처리하지 않습니다.\n\nNestJS에서는 컨트롤러의 역할이 요청을 수락하고 일부 유효성 검사를 수행하여 요청과 데이터를 올바른 서비스로 라우트하는 것입니다. 이는 여전히 많은 책임을 요구하지만 다른 프레임워크보다는 적습니다.\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## NestJS에서 서비스는 무엇을 하는가요?\n\n요청 및 선택적 데이터가 어디로 가는지 알게 되면 비즈니스 로직에 맞게 형태를 변형합니다. 이것이 우리의 서비스 파일이 필요한 이유입니다. NestJS의 서비스는 컨트롤러로부터의 요청에 기반하여 데이터를 생성, 형태를 변형 또는 업데이트하는 로직을 말합니다. 신발을 구매한 사람을 위한 새로운 주문을 생성하거나 사용자의 구식 지불 수단을 제거하는 등의 작업이 일어날 수 있습니다.\n\n무엇을 하든, 서비스에서는 애플리케이션 데이터에 대한 작업을 수행하여 새 상태를 지속할 수 있게 됩니다. 서비스가 데이터를 형태로 만드는 동안, 이 새 상태를 지속하기 위해 데이터베이스와 대화하는 책임은 없습니다. 데이터를 지속시키기 위해서는 저장소가 필요합니다.\n\n## NestJS에서 리포지토리는 무엇을 하는가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저장소는 데이터베이스로의 요청을 처리합니다. 사용자의 요청이 올바른 비즈니스 로직(컨트롤러에 의해)으로 라우팅되고 데이터에 필요한 작업(서비스에 의해)이 수행되면 업데이트된 응용 프로그램 상태를 영속화할 준비가 됩니다.\n\n저장소는 CRU(D) 작업으로 구성되어 있으며 API 클라이언트와 유사한 도구로 볼 수 있습니다. 저장소의 메서드는 데이터베이스에 특정 데이터 레코드를 읽거나 쓰기를 예상합니다. 그게 전부입니다. 이는 다른 접근 방식인 ORM과는 달라요, 여기서 데이터베이스 호출이 서비스에 직접 엮이지 않습니다. 추가 파일이 늘어나는 것은 더 많은 작업이 필요해 보일 수 있지만, 별도의 저장소 파일을 갖는 것은 서비스 또는 앱 사이에서 데이터베이스 작업을 공유하고, 코드를 확장하기 위해 코드를 모듈화하는 데 도움이 됩니다.\n\n## NestJS에 대한 마지막 생각\n\nNestJS는 강력한 백엔드 프레임워크로 API를 빌드하는 프로세스를 가속화합니다. Ruby on Rails 또는 Java 배경에서 오는 것을 배워야 할 내용이 많을 수 있습니다. 다행히 문서는 방대하고 이해하기 쉽습니다. 깨끗하고 일관된 코드를 작성하기 위해 문서를 여러 번 검토하는 것을 강력히 권장합니다.","ogImage":{"url":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png"},"coverImage":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png","tag":["Tech"],"readingTime":3},{"title":"React에서 부모 컴포넌트에서 자식 함수를 호출하는 방법","description":"","date":"2024-05-27 18:46","slug":"2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_0.png\" /\u003e\n\nReact에서는 부모 컴포넌트에서 자식 컴포넌트의 메소드를 호출해야 하는 경우가 있습니다. 이를 위해 useImperativeHandle 훅과 useEffect 훅을 사용할 수 있습니다. 이 기사에서는 각 접근 방식을 사용하는 시점과 단계별 지침을 제공하겠습니다.\n\n# 방법 1: useImperativeHandle 훅 사용\n\nuseImperativeHandle 훅은 React에서 그다지 알려지지 않은 훅으로, ref를 사용할 때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자 정의할 수 있습니다. 이 방법은 불필요한 재렌더링을 유발하지 않고 자식 컴포넌트에서 여러 메소드를 직접 호출해야 할 때 권장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 부모 구성 요소에서 ref를 선언하세요: useRef 훅을 사용하여 부모 구성 요소에 참조를 생성하세요.\n- 참조를 자식 구성 요소로 전달하세요: 참조를 자식 구성 요소에 prop으로 전달하세요.\n- 자식 구성 요소를 forwardRef로 감싸세요: forwardRef 하이어오더 컴포넌트를 사용하여 참조를 자식 구성 요소로 전달하세요.\n- useImperativeHandle로 자식 메소드 정의하기: 자식 구성 요소에서 useImperativeHandle 훅을 사용하여 노출하고자 하는 메소드를 정의하세요.\n\n# 예시 코드\n\n![예시 이미지 1](/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_1.png)\n\n![예시 이미지 2](/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 설명\n\n- 자식 컴포넌트는 부모가 메서드에 액세스할 수 있도록 forwardRef로 래핑됩니다.\n- 자식 컴포넌트 내부에서 useImperativeHandle을 사용하여 부모에 노출할 메서드를 정의합니다.\n- 부모 컴포넌트는 useRef를 사용하여 참조를 생성하고 이를 자식에 전달한 후 이 참조를 통해 자식의 메서드를 호출합니다.\n\n# 방법 2: useEffect Hook 사용\n\n부모 컴포넌트에서 자식의 함수를 호출하는 또 다른 방법은 useEffect 훅을 사용하는 것입니다. 이 접근 방식은 부모에서 사이드 이펙트를 통해 자식 함수를 트리거하는 부모의 상태를 설정하는 것을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 부모 구성 요소의 트리거 상태 선언: 자식 함수를 트리거할 수 있는 부모 구성 요소에 상태를 생성합니다.\n- 자식 구성 요소로 트리거 상태 전달: 이 상태를 자식 구성 요소로 속성(prop)으로 전달합니다.\n- 자식 구성 요소에서 useEffect 사용: 자식 구성 요소에서 useEffect 훅을 사용하여 트리거 상태의 변경을 감시하고 그에 따라 함수를 호출합니다.\n\n# 예시 코드\n\n![image](/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_3.png)\n\n![image](/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 설명\n\n- 상위 컴포넌트는 버튼 클릭시 증가하는 트리거 상태를 유지합니다.\n- 트리거 상태는 자식 컴포넌트에 프롭으로 전달됩니다.\n- 자식 컴포넌트는 useEffect 훅을 사용하여 트리거 상태의 변경을 감지하고 트리거가 변경될 때마다 handleSubmit을 호출합니다.\n\n# 어떤 방법을 사용해야 하나요?\n\n- 상위 컴포넌트에서 자식의 메서드를 직접 호출할 때 이상적입니다.\n- 자식을 다시 렌더링하지 않아도 되는 경우 또는 여러 메서드를 호출해야 할 때 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 부모 상태 변경에 따라 자식에서 함수를 트리거하는 데 유용합니다.\n- 상태 변경으로 인해 부작용이 자연스럽게 발생하는 상황에 적합합니다.\n\n# 마지막으로\n\nReact에서 부모 구성 요소에서 자식의 함수를 호출할 때는 useImperativeHandle 또는 useEffect를 사용하여 효율적으로 관리할 수 있습니다. 두 가지 방법 중에서 선택하는 것은 특정 요구 사항과 구성 요소 상호 작용의 복잡성에 달려 있습니다. 이러한 메서드를 이해하고 구현함으로써 React 애플리케이션의 상호 작용성과 유지 관리성을 향상시킬 수 있습니다.\n\n좋은 코딩 되세요! 😎","ogImage":{"url":"/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoCallaChildFunctionfromaParentComponentinReact_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 개발의 기초 내용들 정리","description":"","date":"2024-05-27 18:45","slug":"2024-05-27-BasicofWebDevelopment","content":"\n\n\n![Basic of Web Development](/assets/img/2024-05-27-BasicofWebDevelopment_0.png)\n\n요즘, 수천 명의 사람들이 온라인으로 일하고 있어. 사람들은 프리랜싱을 선호하고 있어. 급부상하고 있는 분야 중 하나가 웹 개발이야. 소프트웨어 공학 또는 컴퓨터 과학 전공자 뿐만 아니라 많은 비기술적인 사람들도 이 분야로 오고 있어.\n\n거의 모든 브랜드와 심지어 가게들도 웹 사이트를 갖추고 있는데, 그 웹 개발자가 그들을 위해 웹 사이트를 디자인하고 만들어 주는 거야. 이제 어떻게 웹 개발자가 되고 어떻게 시작해야 할지 궁금증이 드는데요?\n\n먼저 사람은 프런트엔드, 백엔드 또는 풀 스택 개발자 가운데 어디로 갈지 결정해야 해. 프런트엔드에 대해 이야기해 보죠.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 HTML (하이퍼텍스트 마크업 언어)를 배우는 것이 첫 단계입니다. 이것은 웹사이트를 구축하는 기본 요소입니다. HTML 없이는 웹사이트를 만들 수 없습니다. HTML을 배우는 것은 정말 쉽습니다. HTML의 모든 태그를 습득하는 데 최대 1주일이 걸릴 것입니다. 제목, 단락, div, span, 테이블, 순서 있는 목록, 순서 없는 목록, 강조 효과, 양식 관련 태그를 배워야 합니다.\n\nHTML을 배운 후에는 CSS (캐스케이딩 스타일 시트)를 배우는 것이 다음 단계입니다. CSS는 HTML을 스타일링하는 것을 의미합니다. CSS를 통해 글꼴 크기, 배경색, 그리드, 테두리 색, 내비게이션 바, 그라데이션, 애니메이션, 버튼, 플렉스박스 등을 변경할 수 있습니다.\n\n마지막 단계는 JavaScript를 배우는 것입니다. JS는 기능을 제공하기 위해 사용됩니다. 이것은 코딩 언어입니다. 변수, 함수, 객체, 배열, 조건문, 반복문, 형 변환, 모듈, JSON 등에 대해 배워야 합니다.\n\n그래서 HTML, CSS 및 JavaScript를 숙달한 후에는 거의 모든 종류의 웹사이트를 만들 수 있습니다. 그러나 부트스트랩, 리액트, 앵귤러, 넥스트.제이에스, 리액트 네이티브와 같은 다른 많은 기술들은 프론트엔드 개발자가 숙달해야 할 것입니다. 이러한 기술을 숙달함으로써 웹 개발자는 소프트웨어 회사나 프리랜서로 일할 수 있으며 상당한 돈을 벌 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![BasicofWebDevelopment_1](/assets/img/2024-05-27-BasicofWebDevelopment_1.png)","ogImage":{"url":"/assets/img/2024-05-27-BasicofWebDevelopment_0.png"},"coverImage":"/assets/img/2024-05-27-BasicofWebDevelopment_0.png","tag":["Tech"],"readingTime":2},{"title":"CSS에서 rgba 대신 color-mix를 사용해야하는 이유","description":"","date":"2024-05-27 18:44","slug":"2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix","content":"\n\n아, 당신은 Sass 변수에서 CSS 변수의 반짝이는 세계로 전환한 것인가요? 그런데 rgba() 함수를 사용하는 데 어려움을 겪고 있나요? 걱정 마세요, 혼자가 아니에요!\n\n![image](/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_0.png)\n\n제가 아는 것처럼, 한 때 당신이 이렇게 Sass 변수에 의존했던 것처럼 말이에요:\n\n```js\n$primary: #00ccff;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 CSS 변수의 힘을 받았군요:\n\n```js\n:root {\n  --primary : #00ccff;\n}\n```\n\n문제는 Sass를 통해 rgba() 마법을 번역하려는 것입니다:\n\n```js\nbackground-color: rgba($color: $primary, $alpha: 0.6);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* 안돼요, 이건 작동 안 돼요! */\n배경색 : rgba($color: var(--primary), $alpha: 0.6);\n```\n\n허무하죠? 그렇죠? 그럴 준비를 하세요. 왜냐하면 color-mix()가 여러분을 구할 거예요!\n\n## 기다려봐... color-mix()는 지원돼요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n짧은 대답은 단언컨대 YES입니다! 모던 브라우저(일부 이전 버전 제외)가 모두 지원하고 있습니다. MDN 웹 문서와 caniuse.com에서 지원 세부 정보를 확인해보세요.\n\n![Image 1](/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_1.png)\n\n![Image 2](/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_2.png)\n\n## 시간이 바꾸는 시간입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncolor-mix()를 사용하여 rgba()로 익숙한 투명 효과를 복제하는 방법을 살펴보겠습니다.\n\n다음과 같이 작성하던 방식을 이제 안녕하세요라고 말해보세요:\n\n```js\nbackground-color: rgba($color: $primary, $alpha: 0.6);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbackground-color: color-mix(in srgb, var(--primary) 60%, transparent);\n```\n\n여기에 대한 설명:\n\n- in srgb: 색 공간을 지정합니다 (sRGB는 웹의 표준입니다).\n- var(--primary): 신뢰할 수 있는 CSS 변수가 섞는 첫 번째 색상입니다.\n- 60%: 이는 혼합물에서 --primary 색상의 백분율을 설정합니다 (알파값 0.6과 동등합니다).\n- transparent: 혼합하는 두 번째 색상입니다 (이것이 투명 효과를 만듭니다).\n\n## color-mix()가 좋은 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 직관적: 퍼센트 기반 접근 방식으로 투명도 수준을 시각화하는 것이 더 쉬워집니다.\n- 유연: 색상이 아닌 투명도가 있는 색 뿐만 아니라 어떤 두 가지 색도 섞어 사용할 수 있습니다.\n- 강력: 간단한 투명도 이외의 창의적인 색상 혼합 가능성을 열어줍니다.\n\n## 한 번 시도해 보세요!\n\n앞으로 나가서 color-mix()를 실험해보세요. 퍼센트를 조정하고 다양한 색상 조합을 시도해보고 어떤 놀라운 결과를 얻을 수 있는지 확인해보세요. 즐거운 스타일링 되세요!","ogImage":{"url":"/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_0.png"},"coverImage":"/assets/img/2024-05-27-CSSGame-ChangerDitchrgbaforcolor-mix_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 컴파일러와 리액트 18에 대해서 알아보기","description":"","date":"2024-05-27 18:43","slug":"2024-05-27-ReactCompilerWithReact18","content":"\n\n우선, 아니요. React 컴파일러는 React 19의 일부가 아닙니다. React 19는 단순히 React 라이브러리일 뿐입니다. 빌드 변경사항은 없습니다. 따라서 React 컴파일러를 통합하려면 스스로 작업해야 합니다. 또한 React 컴파일러가 선택 사항이라는 것을 의미합니다. 이것이 좋은 점입니다.\n\nReact 19에 대한 포인트를 더 증명하기 위해 React 18 프로젝트에서 React 컴파일러를 사용하는 방법을 보여드릴게요.\n\n![ReactCompilerWithReact18_0](/assets/img/2024-05-27-ReactCompilerWithReact18_0.png)\n\n# 프로젝트 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 다른 프레임워크와 달리 리액트 19가 아닌 리액트 18.2.0으로 설정되어 있어서 Vite를 사용할 것입니다.\n\n```js\npnpm create vite r18-with-compiler --template react\n```\n\n또한 TypeScript를 사용하지 않기로 했어요. 어떤 타이핑 문제를 피하기 위해서 우리가 생성한 c 훅을 반환하는 배열로 타이핑할 수 있어요.\n\n# 예제 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일러가 작동하는 방식을 보여주기 위해 최적화되지 않은 버전을 먼저 보여준 다음, 컴파일러를 설치하고 최적화된 버전을 확인해보겠습니다.\n\n다음과 같이 App 컴포넌트를 이 구현으로 대체할 것입니다:\n\n```js\nimport { useState } from \"react\";\n\nfunction Header() {\n  console.log(\"Header\", Math.random());\n  return (\n    \u003cheader\u003e\n      \u003ch1\u003eReact Counter\u003c/h1\u003e\n    \u003c/header\u003e\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003c\u003e\n      \u003cHeader /\u003e\n      \u003cdiv\u003e\n        \u003cp\u003e{count}\u003c/p\u003e\n        \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n여기에는 간단한 헤더를 표시하는 새로운 Header 컴포넌트와 Header를 사용하고 자체적인 카운터 구현을 갖는 App 컴포넌트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최적화되지 않은 React 컴포넌트에서 Header는 매번 App이 버튼을 클릭하여 카운터를 업데이트할 때 다시 렌더링됩니다.\n\n이를 직접 확인하기 위해 응용 프로그램을 시작하고 버튼을 클릭하세요. 클릭할 때마다 Header 컴포넌트에서 console.log를 볼 수 있어야 합니다.\n\n# React 컴파일러를 사용한 최적화\n\nReact 컴파일러는 우리의 App 컴포넌트(사실 Header도)를 최적화하는 방식으로 작동합니다. App에서 Header를 렌더링할 때 Header가 의존하는지 확인합니다. 좋은 소식은, Header가 어느 것에도 의존하지 않습니다. 그래서 Header를 렌더링한 것이 처음이면 마지막이 되어야 합니다. 컴파일러를 사용하는 것이 최적화된 결과입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 작업했다면 버튼을 클릭할 때 Header의 console.log에서 메시지가 표시되지 않을 것을 기대할 수 있습니다. 이는 Header 함수가 호출되지 않기 때문입니다.\n\n먼저 React 컴파일러를 설치해야 합니다:\n\n```js\npnpm add babel-plugin-react-compiler\n```\n\n그런 다음 Vite 구성에서 babel 플러그인을 구성해야 합니다. 제 경우에는 다음과 같이 보입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\n\nconst ReactCompilerConfig = {\n  runtimeModule: \"@/mycache\",\n};\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n  plugins: [\n    react({\n      babel: {\n        plugins: [[\"babel-plugin-react-compiler\", ReactCompilerConfig]],\n      },\n    }),\n  ],\n});\n```\n\n여기에는 두 가지 작업이 진행 중입니다. 무엇보다 defineConfig의 plugins 섹션을 사용하여 React Compiler babel 플러그인을 설치하고 구성하고 있습니다. 그리고 ReactCompilerConfig 객체로 컴파일러를 구성하고 있습니다.\n\n컴파일러 구성에서는 컴파일러가 보통 react-compiler-runtime에서 가져오는 캐시 메모이제이션 훅을 @/mycache에서 가져오도록 지정하고 있습니다.\n\n또한 @ 별칭을 설정하고 소스로 가리키도록해야 합니다. 이렇게 하면 컴포넌트가 위치한 곳과 관계없이 항상 우리의 훅을 찾을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 무엇을 다시 하고 있나요?\n\n간단히 다시 돌아가서 무슨 일이 일어나고 있는지 이야기해 봅시다. 여기서 일어나고 있는 것은 React 컴파일러가 memoization을 사용하여 컴포넌트를 최적화한다는 것입니다. 그러나 이를 위해 전통적인 React.memo나 useMemo 또는 useCallback을 사용하는 것이 아닙니다. 대신 새로운 훅을 사용합니다. 해당 훅은 이전에는 useMemoCache로 불리다가 지금은 c로 불립니다. 그리고 react-compiler-runtime 라이브러리에 해당 훅이 내장되어 있습니다.\n\n저는 react-compiler-runtime 라이브러리가 React 19에 의존한다고 확신합니다. 따라서 React 18과 함께 사용하려면 해당 라이브러리에서 c 함수의 직접적인 구현이 필요합니다. 실제로 그 함수는 매우 간단해서 문제가 되지 않습니다. 사실 너무 쉬워서 여기에 구현해 두었습니다:\n\n```js\nimport { useState } from \"react\";\n\nexport function c(size) {\n  return useState(() =\u003e new Array(size))[0];\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠깐만요. 말 그대로 하는 게 없어요. 먼저 사전 할당된 배열의 필요한 크기를 매개변수로 사용하고, 그 크기의 배열이 있는 컴포넌트와 관련된 몇 가지 상태를 반환합니다. 그래서 useState를 사용하여 해당 배열을 만들고 배열만 반환합니다.\n\n실제로 이게 어떻게 작동하는지에 대해 조금 후에 알아보겠습니다. 지금은 src/mycache.js 파일(또는 원하는 곳)에 해당 C 구현을 저장해야 합니다. 그런 다음 어플리케이션을 실행하면, 바로! 버튼을 누르면 Header가 다시 렌더링되지 않습니다. 성공!\n\n# 약간 다른 구현\n\n다른 옵션은 사실상 패키지 관리자를 속여 ./src/mycache가 실제로 react-compiler-runtime 라이브러리라고 생각하게 하는 것입니다. 그래서 package.json 의 종속성에 이 부분을 추가할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"dependencies\": { ..., \"react-compiler-runtime\": \"file:./src/mycache\" }\n```\n\n그러고 나면 Vite 구성에서 ReactCompilerConfig 블록에서 runtimeModule 키를 제거할 수 있습니다.\n\n이것은 공식 폴리필이며 가장 최신 버전은 이 기스트에 있습니다.\n\n# 그래서 왜 이 C 구현이 작동합니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모든 것이 원활히 진행되었으니 이 C 구현을 한 번 더 살펴보고 왜 동작하는지 알아보려고 해봅시다.\n\n```js\nimport { useState } from \"react\";\n\nexport function c(size) {\n  return useState(() =\u003e new Array(size))[0];\n}\n```\n\n여기서 상태를 생성하고 그 상태를 반환하고 있습니다. 상태 설정 함수를 반환하지 않고 상태만 반환하고 있으니, 뭔가 이상하죠?\n\n이 컴포넌트를 컴파일해보죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport default function Hello() {\n  return \u003cdiv className=\"foo\"\u003e안녕하세요\u003c/div\u003e;\n}\n```\n\n위의 코드가 아래와 같이 변합니다:\n\n```js\nimport {c as _c} from \"/src/mycache.js\";\nexport default function Hello() {\n    const $ = _c(2);\n    if ($[0] !== \"a49bfc30998b8cb2...\") {\n        for (let $i = 0; $i \u003c 2; $i += 1) {\n            $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n        }\n        $[0] = \"a49bfc30998b8cb2...\";\n    }\n    let t0;\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = jsxDEV(\"div\", {\n            className: \"foo\",\n            children: \"안녕하세요\"\n        }, void 0, false, {\n        }, this);\n        $[1] = t0;\n    } else {\n        t0 = $[1];\n    }\n    return t0;\n}\n```\n\n컴파일된 코드의 상단에서 c 훅을 불러오고 최적화된 컴포넌트에서 사용한다는 것을 확인할 수 있습니다. 컴파일러는 초기화된 플래그를 저장하는 데 첫 번째 슬롯, 두 번째 슬롯에는 DOM 트리가 포함된 JSX의 메모이즈된 버전을 저장할 때 두 개의 슬롯만 필요하다는 사실을 알고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 c 훅이 어떻게 사용되는지 알았으니, 왜 우리의 구현이 작동하는지에 대해 조금 더 이해할 수 있게 되었습니다.\n\n첫째, 우리는 메모이징을 하고 있고, 메모이징을 통해 컴포넌트를 다시 렌더링하게 만들 필요가 없습니다. 그래서 우리는 상태 설정 함수를 호출하지 않는 것입니다. 왜냐하면 그렇게 하면 다시 렌더링이 강제되기 때문입니다.\n\n둘째, 우리는 useState로부터 배열에 대한 참조를 받기 때문에 (그리고 즉, 우리는 배열 내의 데이터를 단순히 배열 요소를 설정함으로써 변경할 수 있습니다) 데이터를 변경할 수 있고, 그 변경 사항은 유지될 것입니다. 왜냐하면 useState는 배열의 내용이 아니라 배열에 대한 참조를 유지하기 때문입니다.\n\n그 두 번째 부분이 여러분을 헷갈리게 한다면, JavaScript 메모리 관리와 참조가 배열 및 객체와 관련하여 작동하는 방식에 대한 이 비디오를 추천합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공식 Polyfill\n\n만약 이를 실제로 적용하고 싶다면 c 함수의 원본 소스를 확인해보세요. 그리고 작업 그룹 기사도 살펴보세요. 이 지침 외에도 공식 Polyfill을 따를 수 있습니다.\n\n# 더 깊게 들어가보기\n\n만약 React 컴파일러와 메모이제이션 작업 방식에 대해 더 자세히 알고 싶다면 제 React 컴파일러 영상을 꼭 시청해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 비디오는 메모이제이션의 메커니즘을 심도 있게 다루어서 React 컴포넌트 코드가 어떻게 변환되고 메모이징되며, 그 메모이제이션의 정밀도를 정말로 이해할 수 있도록 도와줍니다.\n\n## 가능하지만 권장되지 않는 방법\n\n무언가를 할 수 있다고 해서 반드시 해야 한다는 것은 아닙니다. 이 경우에도 그렇게 적용됩니다. React 컴파일러는 실제로 React 19 생태계 내에서 작동하도록 설계되었습니다. 그러므로 오늘 18 버전에서 사용할 수 있다고 해도, 내일 그것이 작동한다는 보장은 없습니다. 간단히 말해서, 사용 시 주의가 필요합니다. 레드 옥토버를 찾아서에서 말하는 대로 \"가능하지만 권장되지 않습니다.\"\n\n## 더욱 심화된 주제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신이 이러한 고급 React 주제에 관심이 있다면, 특히 NextJS에 대해, 제 ProNextJS 뉴스레터에 가입해보세요. 그것을 통해 NextJS 상태 관리와 폼 관리에 대한 두 가지 무료 자습서에 액세스 할 수 있습니다. 그리고 ProNextJS 전체 코스가 출시될 때 알림을 받을 수도 있어요! 곧 공개될 예정이에요!","ogImage":{"url":"/assets/img/2024-05-27-ReactCompilerWithReact18_0.png"},"coverImage":"/assets/img/2024-05-27-ReactCompilerWithReact18_0.png","tag":["Tech"],"readingTime":7}],"page":"58","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"58"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>