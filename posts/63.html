<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/63" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/63" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-b692b09f2b5275a4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" href="/post/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" href="/post/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" href="/post/2024-05-14-ReactHowtostopre-renderinginReactComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드" href="/post/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드" href="/post/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션" href="/post/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 하이드레이션 오류 지옥 탈출하기" href="/post/2024-05-14-EscapingReactHydrationErrorHell"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 하이드레이션 오류 지옥 탈출하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 하이드레이션 오류 지옥 탈출하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 하이드레이션 오류 지옥 탈출하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기" href="/post/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기" href="/post/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">31<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기" href="/post/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link posts_-active__YVJEi" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"React의 강력한 콤비 useReducer와 useContext에 대한 간단한 안내","description":"","date":"2024-05-14 11:15","slug":"2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png\" /\u003e\n\nuseReducer과 useContext는 React에서 함께 사용하여 전체 애플리케이션의 상태를 관리하는 강력한 두 가지 훅입니다. useReducer는 복잡한 상태 전환을 더 예측 가능하고 관리하기 쉽게 처리할 수 있는 방법을 제공하며, useContext는 각 레벨을 통해 수동으로 props를 전달하지 않아도 컴포넌트 트리로 데이터를 전달할 수 있도록 해주어 데이터를 전역적으로 사용할 수 있게 합니다.\n\n이 블로그에서는 현재 알고 있는 코드 최적화 방법을 적용할 것입니다.\n\n앱에서 \"context\"라는 폴더를 생성하고 그 폴더 안에 \"IncrementContext\"라는 파일을 생성하세요.\n\n\n\n```js\r\nimport { createContext, useContext, useReducer } from 'react';\n\n// 상태를 보유하는 컨텍스트 생성\nconst IncrementContext = createContext();\n\n// 초기 상태 정의\nconst initialState = {\n  count: 0\n};\n```\n\n\n\n위의 코드 스니펫에서는 세 가지 리액트 훅, createContext, useContext 및 useReducer를 import했습니다.\n\n- CreateContext는 상태를 보유하는 컨텍스트를 생성하는 데 사용됩니다.\n- useContext는 컨텍스트를 호출하는 데 사용됩니다.\n- useReducer는 상태 변수와 기능을 관리하는 데 사용됩니다.\n\n또한 key-value 쌍인 count를 기본 값 0으로 가진 initialState 객체를 선언했습니다.\n\n이 코드를 useReducer 훅에 전달하여 기능을 구축할 것입니다.\n\n\n\n2. 리듀서 함수 작성하기\n\n```js\nconst reducer = (state, action) =\u003e {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// 리듀서와 초기 상태(initialState)와 함께 사용할 컴포넌트를 useReducer 훅 안에 선언할 것입니다.\n\n// IncrementProvider 내부에 선언될 것입니다.\nconst [state, dispatch] = useReducer(reducer, initialState);\n```\n\n리듀서 함수는 현재 상태와 액션 객체를 받아들여 액션의 유형 및 페이로드를 기반으로 새 상태를 반환하는 순수 함수입니다. 이는 React 애플리케이션에서 복잡한 상태 로직을 관리하기 위해 useReducer 훅과 함께 사용됩니다. 리듀서 함수는 현재 상태를 직접 수정하는 대신 항상 새 상태 객체를 반환해야 합니다.\n\n제공된 코드 스니펫에서 리듀서 함수는 현재 상태 객체와 형식(type) 속성이 있는 액션 객체를 받아들입니다. 액션 타입에 따라 리듀서는 count 속성이 증가하거나 감소한 새로운 상태 객체를 반환합니다. 액션 유형이 인식되지 않으면, 리듀서는 잘못된 액션이 전송되었음을 나타내기 위해 오류를 throw합니다.\n\n\n\n3. 콘텍스트 프로바이더 작성 및 데이터를 전역적으로 접근 가능하게 만들기\n\n```js\n// 리듀서와 초기 상태에 모두 액세스하려면 useReducer를 사용합니다.\nconst IncrementProvider = (props) =\u003e {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    \u003cIncrementContext.Provider value={{ ...state, dispatch }}\u003e\n      {props.children}\n    \u003c/IncrementContext.Provider\u003e\n  );\n}\n\n// IncrementProvider를 사용하여 index.js에서 전체 애플리케이션을 래핑합니다.\n// 이렇게 하면 콘텍스트 객체를 전역적으로 액세스할 수 있게 됩니다.\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cIncrementProvider\u003e\n      \u003cApp /\u003e\n    \u003c/IncrementProvider\u003e\n  \u003c/React.StrictMode\u003e\n);\n```\n\nIncrementProvider는 useReducer를 사용하여 상태를 관리하고 createContext를 사용하여 콘텍스트를 생성하는 사용자 정의 프로바이더 컴포넌트입니다. 프로바이더 컴포넌트는 props를 인수로 받아 자식 컴포넌트를 래핑하는 프로바이더 컴포넌트를 반환합니다.\n\n프로바이더 컴포넌트는 IncrementContext.Provider를 사용하여 상태와 디스패치 함수를 컨텍스트를 통해 자식 컴포넌트에 제공합니다. 이를 위해 IncrementContext.Provider에 값을 전달하여 상태와 디스패치 함수가 포함된 객체를 전달합니다.\n\n\n\n예제 코드에서 IncrementProvider는 index.js 파일에서 App 컴포넌트를 감싸고 있습니다. 이렇게 함으로써 상태와 디스패치 함수를 App 컴포넌트의 모든 하위 컴포넌트에서 사용할 수 있게 됩니다.\n\nIncrementProvider로 전체 애플리케이션을 감싸면 모든 컴포넌트가 상태에 액세스하고 수정을 위한 액션을 디스패치할 수 있도록 보장합니다. 이는 React 애플리케이션에서 컨텍스트와 useReducer 훅을 사용하여 전역 상태를 관리하는 일반적인 패턴입니다.\n\n4. 컴포넌트에서 데이터에 액세스\n\n```js\nimport { useIncrementContext } from 'IncrementContext'\n\nconst MyComponent = () =\u003e {\n  // useContext를 사용하여 컨텍스트를 호출할 필요가 없습니다\n  // useIncrementContext 함수를 작성하여 컨텍스트를 호출하였기 때문입니다\n  const { state, dispatch } = useIncrementContext()\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {state.count}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n`useIncrementContext`은 `IncrementContext.Provider`에서 생성된 컨텍스트를 소비하는 데 사용되는 사용자 정의 후크입니다. 이 후크는 `useContext` 후크를 사용하는 보일러플레이트 코드를 추상화하여 컨텍스트 값을 쉽게 액세스할 수 있도록 돕습니다.\n\n예시 코드에서 `useIncrementContext`는 `IncrementContext` 파일에서 가져옵니다. `MyComponent` 컴포넌트는 `useIncrementContext` 후크를 사용하여 컨텍스트에서 상태 및 디스패치 함수에 액세스합니다.\n\n`useIncrementContext` 후크를 사용함으로써 컴포넌트에서 `useContext` 후크를 직접 사용할 필요가 없습니다. 대신 `useIncrementContext` 함수를 호출하여 컨텍스트에서 상태 및 디스패치 함수에 액세스할 수 있습니다.\n\n`MyComponent` 컴포넌트는 상태 객체에서 현재 카운트 값을 보여주는 단락을 렌더링합니다. 또한 클릭할 때 증가 또는 감소 액션을 디스패치하는 두 개의 버튼을 렌더링합니다.\n\n\n\n이 코드 스니펫은 React 컴포넌트에서 컨텍스트 값을 사용하기 위한 사용자 정의 훅을 어떻게 사용하는지 보여줍니다. 컨텍스트를 사용하는 과정을 간단하게 만들어주며 응용 프로그램의 여러 컴포넌트에서 상태와 디스패치 기능에 쉽게 액세스할 수 있습니다.\n\n이 블로그가 도움이 되기를 바라요!\n\nGithub : https://github.com/DevgenX","ogImage":{"url":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png"},"coverImage":"/assets/img/2024-05-14-AShortGuidetoReactsPowerfulDuouseReducerandUseContext_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 JS에서 React-Toastify  Tailwind로 알림 시스템 구축하기","description":"","date":"2024-05-14 11:13","slug":"2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png\" /\u003e\n\nReact + Tailwind에서 토스 (알림 시스템)를 만들어 봅시다!\n\n새로운 튜토리얼 준비되셨나요!? 저는 로봇이나 인공지능이 아니라 다재다능한 사람입니다.\n\n음, 생각해 보니까 \"왜 안 해볼까\"라는 생각이 들더라고요. React JS를 한 번 시도해보는 거야.\n\n\n\n나의 취향에 따르면, React는 몇 가지 멋진 기능을 가지고 있어요!\n\n그래서 2016년에 뒤떨어진 채로 두고 둔 React JS에 다시 기회를 주게 되어 너무 흥분되고 있어요.\n\n# 내 컴퓨터에 React JS를 설치하는 방법은?\n\nReact JS 프로젝트의 모두에게 선호되는 선택지로 시작해 봅시다.\n\n\n\n최소 프로젝트를 시작하려면 먼저 다음 명령을 실행해야 합니다.\n\n이 프로젝트를 \"Tailwind-toast\"라고 이름 짓겠습니다. 샘플이기 때문입니다. 프로젝트 이름은 자유롭게 변경하셔도 됩니다.\n\n```js\nnpx create-react-app tailwind-toast\n```\n\nReactJS에 관한 이전 기사들을 통해 자바스크립트에 대해 더 많은 도움을 얻을 수도 있습니다.\n\n\n\n여기에서 새로운 REACT 프로젝트가 설정되고 생성되었음을 확인할 수 있습니다.\n\n계속하기 전에 Tailwind CSS를 설정해야 합니다.\n\n우리는 CDN을 사용하여 리액트 앱 내부에 tailwind를 설정할 계획입니다.\n\n다음으로, 새로운 리액트 프로젝트의 루트를 찾아야 합니다!\n\n\n\n```js\n./public/index.html\n```\n\n그리고 index의 head에 CDN Tailwind 스크립트 태그를 추가하십시오.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"utf-8\" /\u003e\n    \u003clink rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e\n    \u003cmeta name=\"theme-color\" content=\"#000000\" /\u003e\n    \u003cmeta\n      name=\"description\"\n      content=\"create-react-app을 사용하여 생성된 웹 사이트\"\n    /\u003e\n    \u003clink rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /\u003e\n    \u003c!--\n      manifest.json은 사용자의 모바일 기기나 데스크톱에서 웹 앱이 설치될 때 사용되는 메타데이터를 제공합니다. https://developers.google.com/web/fundamentals/web-app-manifest/\n    --\u003e\n    \u003clink rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /\u003e\n    \u003c!--\n      위 태그들에서 %PUBLIC_URL%을 주목하세요.\n      이것은 빌드 중에 'public' 폴더의 URL로 대체될 것입니다.\n      HTML에서는 'public' 폴더 내의 파일만 참조할 수 있습니다.\n\n      \"/favicon.ico\"나 \"favicon.ico\"와 달리, \"%PUBLIC_URL%/favicon.ico\"는\n      클라이언트 측 라우팅과 최상위 공용 URL 양측에서 제대로 작동합니다.\n      비공용 URL을 구성하는 방법은 `npm run build`를 실행하여 알아보세요.\n    --\u003e\n    \u003ctitle\u003eReact App\u003c/title\u003e\n    \u003cscript src=\"https://cdn.tailwindcss.com\"\u003e\u003c/script\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cnoscript\u003e이 앱을 실행하려면 JavaScript를 활성화해야 합니다.\u003c/noscript\u003e\n    \u003cdiv id=\"root\"\u003e\u003c/div\u003e\n    \u003c!--\n      이 HTML 파일은 템플릿입니다.\n      브라우저에서 직접 열면 빈 페이지가 표시됩니다.\n\n      이 파일에 웹 폰트, 메타 태그 또는 분석을 추가할 수 있습니다.\n      빌드 단계에서 번들된 스크립트가 \u003cbody\u003e 태그에 배치됩니다.\n\n      개발을 시작하려면 `npm start` 또는 `yarn start`를 실행하십시오.\n      프로덕션 번들을 만들려면 `npm run build` 또는 `yarn build`를 사용하십시오.\n    --\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n# 내 프로젝트에 React Toastify를 설치하는 방법은 무엇인가요?```\n\n\n\n\"React-Toastify\"라는 라이브러리를 먼저 가져와야 해요.\n\n이 라이브러리에는 토스트 메시지를 사용자 정의하고 더 많은 기능을 제공하는 멋진 기능이 있어요.\n\n아래 명령을 실행해 보세요.\n\n```js\nnpm install --save react-toastify\n```\n\n\n\n이제 Toast를 실행할 필요한 모든 패키지가 준비되었습니다!\n\n## React Toastify CSS를 가져오는 방법\n\n지금 튜토리얼의 이 지점에서 모든 패키지를 가지고 있지만 React-Toastify가 올바르게 작동하려면 약간의 CSS가 필요합니다.\n\n텍스트 편집기를 열고 App.js 파일을 몇 가지 수정하십시오. 이 파일은 자동으로 생성되며 src라는 디렉토리 안에 있습니다.\n\n\n\n다음으로, 이 두 줄의 코드를 포함해야 합니다.\n\n```js\nimport { ToastContainer, toast } from 'react-toastify';\n\nimport 'react-toastify/dist/ReactToastify.css';\n```\n\n좋아요! 이제 우리는 ToastContainer 및 toast를 사용하여 버튼 클릭 시 알림을 트리거할 수 있습니다.\n\n새로운 reactjs 프로젝트 안에 버튼을 정의해 봅시다. 이전과 같은 파일인 App.js에서 시작해서, 어떠한 onClick 이벤트에 대비할 준비가 된 상수 변수를 사용하여 새로운 버튼을 설정할 수 있습니다.\n\n\n\n```js\nconst notify = () =\u003e {};  \nreturn (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cp\u003e\n          Edit \u003ccode\u003esrc/App.js\u003c/code\u003e and save to reload.\n        \u003c/p\u003e\n        \u003ca\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        \u003e\n          Learn React\n        \u003c/a\u003e\n        \u003cbutton onClick={notify}\u003eNotify !\u003c/button\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n```\n\n멋져요! 다음은 버튼에 Tailwind를 추가하는 것입니다. ReactJS에서는 버튼에 class 대신 className을 사용해야 합니다. Tailwind CSS 스타일은 매우 직관적입니다. 여기서는 font-bold와 배경색이 필요합니다.\n\n```js\n\u003cbutton className=\"bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-700 hover:border-blue-500 rounded m-5 text-base\" onClick={notify}\u003eNotify !\u003c/button\u003e\n```\n\n잘 진행 중입니다! 이제 Toast를 작동시켜 봅시다! App.js 파일에 다음 줄을 추가하세요.\n\n\n\n\n```js\n const notify = () =\u003e toast(\"와우 정말 쉬워요!\");\n```\n\n이전에 우리는 App.js 파일 안에서 Toast 및 ToastContainer를 가져왔습니다.\n\n다음으로, 토스트가 테일윈드 CSS만으로 멋지게 설정되어 있는지 확인해야 합니다!\n\n어떠세요, contextClass를 상수로 추가하고 테일윈드가 특별한 매력을 불어 넣도록 할까요? 🪄\n```\n\n\n\n```js\nconst contextClass = {\n  success: \"bg-blue-500\",\n  error: \"bg-red-600\",\n  info: \"bg-gray-600\",\n  warning: \"bg-orange-400\",\n  default: \"bg-indigo-600\",\n  dark: \"bg-white-600 font-gray-300\",\n};\n```\n\n이제 마지막 파트… ToastContainer를 설정해야 합니다.\n\n이곳이 모든 마법이 시작되고 끝나는 곳이니 준비하세요!\n\n```js\n\u003cToastContainer\n  toastClassName={(context) =\u003e\n    contextClass[context?.type || \"default\"] +\n    \" relative flex p-1 min-h-10 rounded-md justify-between overflow-hidden cursor-pointer\"\n  }\n  bodyClassName={() =\u003e \"text-sm font-white font-med block p-3\"}\n  position=\"top-left\"\n  autoClose={3000}\n  icon={({ type }) =\u003e {\n    if (type === \"success\") return \"👻\";\n    if (type === \"error\") return \"🚨\";\n    else return \"ℹ️\";\n  }}\n/\u003e\n```\n\n\n\n우리는 이전에 만든 컨텍스트를 전달하여 ToastClassName 컨테이너를 정의합니다. 그런 다음 몇 가지 Tailwind 스타일을 적용하여 ToastContainer가 멋지게 보이도록 합니다.\n\n다음으로 알림의 위치를 상단 및 왼쪽으로 설정합니다.\n\n훌륭해요! 이제 모두 설정되었어요. 하지만 React-Toastify에서 아이콘을 업데이트하고 싶습니다.\n\n일반적으로 React 라이브러리 내의 아이콘에 스타일을 변경하는 것은 어려울 수 있지만, react-toastify 자바스크립트에는 아이콘을 위한 특정 속성이 있습니다.\n\n\n\n앗 안돼! ...보이니 저희 토스트 알림 시스템이 예상대로 작동하지 않는 것 같아요.\n\n# 나만의 커스텀 Tailwind 스타일로 React-Toastify를 어떻게 발동시킬까요?\n\n이 튜토리얼을 끝까지 따라오면서 여러분은 아마도 우리가 만드는 팝업 알림이 올바른 스타일을 사용하지 않는다는 것을 느꼈을 겁니다.\n\n그 이유는 우리가 리액트의 알림 시스템에게 트리거될 때 올바른 컨텍스트를 사용하도록 활성적으로 알려줘야하기 때문이죠.\n\n\n\n앞서 우리의 React-toastify 알림 시스템이 사용자 지정 Tailwind 스타일을 트리거하지 않는 정확한 이유를 이해하려면 최종 App.js의 시작 지점으로 돌아가 봅시다.\n\n```js\nimport { ToastContainer, toast } from 'react-toastify';\n\nimport 'react-toastify/dist/ReactToastify.css';\n\nconst contextClass = {\n  success: \"bg-blue-500\",\n  error: \"bg-red-600\",\n  info: \"bg-gray-600\",\n  warning: \"bg-orange-400\",\n  default: \"bg-indigo-600\",\n  dark: \"bg-white-600 font-gray-300\",\n};\n\nfunction App() {\n const notify = () =\u003e toast(\"와우, 정말 쉬워요!\");\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\n        \u003cp\u003e\n          \u003ccode\u003esrc/App.js\u003c/code\u003e를 편집하고 저장하세요.\n        \u003c/p\u003e\n        \u003ca\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        \u003e\n          React 배우기\n        \u003c/a\u003e\n        \u003cbutton className=\"bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-700 hover:border-blue-500 rounded m-5 text-base\" onClick={notify}\u003e알림 보내기!\u003c/button\u003e\n          \u003cToastContainer\n            toastClassName={(context) =\u003e\n              contextClass[context?.type || \"default\"] +\n              \" relative flex p-1 min-h-10 rounded-md justify-between overflow-hidden cursor-pointer\"\n            }\n            bodyClassName={() =\u003e \"text-sm font-white font-med block p-3\"}\n            position=\"top-left\"\n            autoClose={3000}\n            icon={({ type }) =\u003e {\n                if (type === \"success\") return \"👻\";\n                if (type === \"error\") return \"🚨\";\n                else return \"ℹ️\";\n            }\n          /\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n문제점을 알아챘나요? 실제로... 우리는 Tailwind CSS 스타일이 기본 React-toastify 스타일을 재정의하기 위한 특정 컨텍스트를 확인하거나 유효화하지 않았군요.\n\n# React-Toastify 스타일 덮어쓰기 및 Tailwind 스타일이 나타나지 않는 문제를 해결하는 방법?\n\n\n\nReact-Toastify 설정을 수동으로 재정의하여 알림에 사용 가능한 타입을 다시 정의해야 합니다. 예를 들어, 성공 알림을 호출하려면 해당 알림을 선택해야 합니다.\n\nReact-Toastify 스타일에서 성공 알림을 선택하고 이전에 생성한 tailwind 스타일이 적용되어야 합니다.\n\n또한 progress-bar의 스타일을 변경하는 등 알림을 좀 더 사용자 정의할 수 있습니다.\n\n각 알림마다 react-toastify 옵션에서 progressStyle를 업데이트할 수 있습니다.\n\n\n\n표 태그를 Markdown 형식으로 변경해보세요.\n\n```js\nconst notify = () =\u003e toast(\"와우 정말 쉽군요 !\", { type: \"success\", progressStyle: { background: '#E8DFD0' } });\n```\n\n이제 올바른 스타일이 보일 것입니다. Tailwind와 React JS는 강력합니다. CSS와 JS를 마음대로 섞어 사용할 수 있어요.\n\n튜토리얼을 이렇게 멀리 따라오셔서 축하드려요!\n\n\n\n위 코드는 테스트해보고 싶은 사람을 위한 최종 코드입니다.\n\n# ReactJS + Libs에 대한 우리의 마지막 생각\n\n튜토리얼을 완료하며 많은 것을 이루었습니다.\n\nAngular와는 달리 작은 구성으로 많은 작업을 수행할 수 있다는 것이 놀라운 점입니다.\n\n\n\n저는 ReactJS가 훌륭한 도구라고 생각하지만, 모든 도구처럼 문제가 여전히 발생합니다.\n\nReact에서 경험했던 일반적인 문제는 역위 호환성 지원입니다.\n\n제가 틀렸다고 느낀다면 자유롭게 반론해주세요만…\n\nReact의 방법론은 항상 최신 기술에 초점을 맞추고 있어서 과거를 고려하지 않는다는 것을 의미합니다.\n\n\n\n한 번 완료된 프로젝트가 일 년 후에 무엇이 깨지면 여러 번 다시 시작하고 싶지는 않아요.\n\n즐거운 프로그래밍 하세요!! - 우리는 인공지능이 일자리를 없애는 걸 찬성하지 않아요 😵, 그러니 친절하게 대해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaNotificationSystemwithReact-ToastifyTailwindinReactJS_0.png","tag":["Tech"],"readingTime":9},{"title":"리액트  리액트 컴포넌트에서 리렌더링을 멈추는 방법","description":"","date":"2024-05-14 11:12","slug":"2024-05-14-ReactHowtostopre-renderinginReactComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png\" /\u003e\n\n리액트는 초기에 비해 많은 발전을 이루었습니다. 그럼에도 여전히 많은 사람들이 불필요한 다시 렌더링을 고치기 어려운 것으로 생각합니다.\n\n불필요한 다시 렌더링을 피하는 다양한 방법이 있습니다. 여기에서는 리액트에서 불필요한 다시 렌더링을 피하는 몇 가지 방법과 접근법을 논의하고 있습니다.\n\n- useState()를 useRef()훅으로 대체하기.\n- 메모이제이션된 셀렉터를 만들기 위해 Reselect 라이브러리 사용.\n- 데이터 가져오기를 위한 리액트 훅 라이브러리인 SWR 사용.\n- useMemo() 및 useCallback() 훅을 사용한 메모이제이션.\n\n\n\n# 1. useState()을 useRef() 훅으로 변경하기\n\nuseState() 훅은 React 함수형 컴포넌트에서 상태가 변경될 때 컴포넌트를 다시 렌더링하는 데 자주 사용되는 훅입니다. 그러나 경우에 따라 컴포넌트를 다시 렌더링하지 않고 업데이트를 추적해야 할 때가 있습니다. 이럴 때 useRef() 훅을 사용할 수 있습니다. useRef()를 사용하면 useState()처럼 다시 렌더링을 호출하지 않고 업데이트를 추적할 수 있습니다.\n\nuseState()를 사용한 예시:\n\n```js\nfunction inputWithState() {\n  const [value, setValue] = useState(\"\");\n  return (\n    \u003cinput \n      value={value} \n      onChange={e =\u003e setValue(e.target.value)} \n      type={type} \n    /\u003e\n  );\n}\n```\n\n\n\n이 예시에서는 input에서 각 키 입력마다 onChange 이벤트로 상태 변경이 발생하여 재렌더링됩니다.\n\nuseRef()를 활용한 예시:\n\n```js\nfunction inputWithRef() {\n  const inputEl = useRef(null);\n  console.log(inputEl?.current?.value);\n  return (\n    \u003cinput ref={inputEl} type=\"text\" /\u003e\n  );\n}\n```\n\n이 예시에서는 input에 입력하는 모든 내용을 input 참조를 통해 읽을 수 있습니다. 이 접근법은 각 키 입력마다 불필요한 재렌더링을 피할 수 있습니다.\n\n\n\n# 2. Reselect 라이브러리를 사용하여 메모이제이션 셀렉터 만들기\n\n리액트 컴포넌트는 빠른 수명주기를 갖고 있지만, 너무 많은 다시 렌더링으로 늘 피해를 입는 경우가 많습니다. 이를 해결하기 위해 개발자들은 성능을 개선하기 위해 Redux와 함께 사용되는 인기 라이브러리 Reselect의 래퍼인 서드파티 성능 라이브러리 re-select를 만들었습니다. 이 라이브러리는 메모이제이션 셀렉터를 코딩하여 성능을 향상시킵니다.\n\n- 셀렉터는 파생 데이터를 계산할 수 있어 Redux가 가능한 한 적은 상태를 저장할 수 있게 합니다.\n- 셀렉터는 효율적입니다. 셀렉터는 인수 중 하나가 변경될 때까지 재계산되지 않습니다.\n- 셀렉터는 조합 가능합니다. 다른 셀렉터의 입력으로 사용될 수 있습니다.\n\n예시:\n\n\n\n```js\nimport { createSelector } from 'reselect'\nconst selectShopItems = state =\u003e state.shop.items\nconst selectTaxPercent = state =\u003e state.shop.taxPercent\nconst selectSubtotal = createSelector(selectShopItems, items =\u003e\n  items.reduce((subtotal, item) =\u003e subtotal + item.value, 0)\n)\nconst selectTax = createSelector(\n  selectSubtotal,\n  selectTaxPercent,\n  (subtotal, taxPercent) =\u003e subtotal * (taxPercent / 100)\n)\nconst selectTotal = createSelector(\n  selectSubtotal,\n  selectTax,\n  (subtotal, tax) =\u003e ({ total: subtotal + tax })\n)\nconst exampleState = {\n  shop: {\n    taxPercent: 8,\n    items: [\n      { name: 'apple', value: 1.2 },\n      { name: 'orange', value: 0.95 }\n    ]\n  }\n}\nconsole.log(selectSubtotal(exampleState)) // 2.15\nconsole.log(selectTax(exampleState)) // 0.172\nconsole.log(selectTotal(exampleState)) // { total: 2.322 }\n```\n\n여기서 createSelector는 2개의 선택기를 입력으로 받아 메모이즈된 버전을 반환합니다. 값이 다를 때까지 이 메모이즈된 버전을 사용하여 선택기는 다시 계산되지 않을 것입니다.\n\nReselect는 Redux에만 한정되지 않으나, 공식 Redux Toolkit 패키지에 이미 기본으로 포함되어 있습니다. 추가 설치가 필요하지 않습니다.\n\n# 3. SWR 사용하기 - 데이터 패치용 리액트 훅스 라이브러리```\n\n\n\nSWR은 데이터 가져오기를 위한 React Hooks 라이브러리입니다.\n\n\"SWR\"이라는 이름은 stale-while-revalidate의 약자입니다. SWR은 먼저 캐시에서 데이터를 반환한 후(request), 데이터를 업데이트하고(get), 최신 데이터를 다시 가져옵니다. 이를 통해 컴포넌트가 여러 번 다시 렌더링 되는 것을 방지할 수 있습니다.\n\n한 가지 훅으로 프로젝트에서 데이터 가져오기 로직을 크게 간소화할 수 있습니다. 뿐만 아니라 속도, 정확성, 안정성 면에서 모두 다루어져 더 나은 애플리케이션을 구축하는 데 도움이 됩니다.\n\n예시:\n\n\n\n```js\nfunction Profile() {\n  const { data, error } = useSWR('/api/user', fetcher)\n\n  if (error) return \u003cdiv\u003e로드에 실패했습니다\u003c/div\u003e\n  if (!data) return \u003cdiv\u003e로딩 중...\u003c/div\u003e\n  return \u003cdiv\u003e안녕하세요 {data.name}님!\u003c/div\u003e\n}\n```\n\n더 많은 정보와 예제는 여기를 참조하세요: [https://swr.vercel.app/](https://swr.vercel.app/)\n\n## 4. useMemo() 및 useCallback()Hooks를 사용한 Memoization\n\nMemoization은 우리의 리액트 코드를 프롭스에 업데이트가 있을 때에만 컴포넌트를 다시 렌더링하도록 하는 것을 가능하게 합니다. 이 접근 방식을 통해 개발자는 불필요한 다시 렌더링을 피하고 응용 프로그램에서의 계산 부하를 줄일 수 있습니다.\n\n\n\n\n리액트는 메모이제이션을 만들기 위해 두 가지 훅을 제공합니다:\n\n- useMemo()\n- useCallback()\n\n이 훅들은 계산 없이 입력이 동일한 경우 캐싱되어 동일한 결과를 반환하여 다시 렌더링을 줄입니다. 입력이 업데이트되면 캐시가 무효화되고 새로운 컴포넌트 상태가 렌더링됩니다.\n\n- useMemo()\n\n\n\n이 훅은 함수 호출과 렌더 사이에서 계산 결과를 메모이징하는 데 사용됩니다.\n\n예시:\n\n```js\nconst expensiveFunction = (inputValue) =\u003e {\n  let expensiveValue = inputValue * 42;\n  //... 입력값을 포함한 계산 작업이 많은 경우...\n  expensiveValue = 'World';\n  return expensiveValue;\n};\nconst MyComponent = ({ something }) =\u003e {\n  const [inputValue, setInputValue] = useState('');  \n  const expensiveValue = useMemo(\n    () =\u003e expensiveFunction(inputValue), \n    [ inputValue ]\n  );  \n  return \u003ch1\u003eHello {expensiveValue}\u003c/h1\u003e;\n};\n```\n\n2. useCallback()\n\n\n\n이것은 메모이제이션을 구현하는 또 다른 React Hook입니다. 그러나 useMemo()와 달리 결과를 캐시하지 않고 대신 제공된 콜백 함수를 메모이즈합니다.\n\n예시:\n\n```js\nfunction item() {\n  const onClick = useCallback(event =\u003e {\n    console.log('Clicked Item : ', event.currentTarget);\n  }, [item]);\n  \n  return (\n    \u003cli={item} onClick={onClick} /\u003e\n  );\n}\n```\n\n예시에서 useCallback()은 onClick 콜백을 메모이즈합니다. 따라서 사용자가 동일한 항목을 계속 클릭해도 컴포넌트를 다시 렌더링하지 않습니다.\n\n\n\n이 기사가 리액트 컴포넌트에서 재랜더링 문제를 해결하는 데 도움이 되기를 바랍니다. 만약 리액트에서 재랜더링을 피하는 다른 방법이나 기술이 있다면 댓글에 추가해 주세요.\n\n당신의 지원을 보여주기 위해 아래의 👏 버튼을 최대한 많이 눌러주세요!\n\n독자 여러분, 감사합니다. 화이팅!!!\n\n당신은 멋져요!","ogImage":{"url":"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png"},"coverImage":"/assets/img/2024-05-14-ReactHowtostopre-renderinginReactComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"ASPNET MVC 프로젝트에 React 애플리케이션 통합하기 단계별 가이드","description":"","date":"2024-05-14 11:11","slug":"2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide","content":"\n\n소개: 웹 개발 분야에서, React와 같은 현대적인 JavaScript 프레임워크를 전통적인 MVC (Model-View-Controller) 응용 프로그램에 통합하는 것이 일반적인 실천 방법이 되었습니다. 이러한 통합을 통해 개발자들은 React의 구성 요소 기반 아키텍처의 강점을 ASP.NET MVC의 익숙한 구조 내에서 활용할 수 있습니다. 이 안내서에서는 React 애플리케이션을 ASP.NET MVC 프로젝트에 매끄럽게 통합하는 과정을 안내하겠습니다.\n\nCreate React App: 먼저 create-react-app이나 기타 선호하는 방법을 사용하여 React 애플리케이션을 설정하세요.\n\n필수 패키지 설치: 아래 명령을 실행하여 React 개발에 필요한 패키지를 설치하세요:\n\n- npm install react react-dom\n- npm install — save-dev babel-core babel-loader @babel/preset-react @babel/preset-env\n- npm install babel-polyfill\n- npm install — save-dev webpack webpack-cli\n\n\n\n웹팩 구성하기: 루트 폴더에 webpack.config.js 파일을 생성하고 제공된 구성 코드를 붇여넣어주세요.\n\n```js\nconst path = require('path');\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.js', '.jsx'],\n  },\n  externals: {\n    react: 'React', \n    'react-dom': 'ReactDOM', \n  },\n};\n```\n\nBabel 구성: 루트 폴더에 .babelrc 파일을 생성하고 Babel을 위한 제공된 프리셋을 추가해주세요.\n\n```js\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n\n\nESLint 구성 (선택 사항): 린팅 이슈가 발생하면, .eslintrc.json 파일을 만들고 지정된 대로 구성하세요.\n\n```js\n   // .eslintrc.json\n   {\n       \"env\": {\n         \"browser\": true,\n         \"es2021\": true,\n         \"node\": true\n       },\n       \"extends\": \"eslint:recommended\",\n       \"parserOptions\": {\n         \"ecmaVersion\": 12,\n         \"sourceType\": \"module\"\n       },\n       \"rules\": {\n         // 여기에 다른 규칙을 추가하세요\n       },\n       \"globals\": {\n         \"React\": \"writable\",\n         \"ReactDOM\": \"writable\",\n         \"createRoot\": \"writable\"\n       }\n     }\n```\n\nPackage.json 업데이트: package.json의 스크립트 섹션에 \"wpb\": \"webpack\"을 추가하세요.\n\n![이미지](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png)\n\n\n\n리액트 앱 컴파일: 리액트 애플리케이션을 컴파일하려면 npm run wpb를 실행하세요. 이렇게 하면 지정된 dist 폴더에 bundle.js 파일이 생성됩니다.\n\n리액트 폴더 구조는 다음과 같이 보일 것입니다:\n\n![React Folder Structure](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_1.png)\n\n# MVC 애플리케이션 설정하기\n\n\n\nMVC 애플리케이션 생성: 먼저 Visual Studio나 선호하는 다른 IDE에서 새 ASP.NET MVC 애플리케이션을 생성해보세요.\n\n.cshtml 파일 업데이트: 렌더링하려는 React 컴포넌트를 포함하고자 하는 .cshtml 파일을 열어주세요.\n\n폴더 구조 생성: MVC 앱 내에서 컴파일된 React JS 파일을 저장할 폴더를 생성하세요. 그리고 React 앱에서 생성된 bundle.js 파일을 해당 폴더에 넣어두세요. (예: wwwroot/dist)\n\nReact 파일 참조: .cshtml 파일에서 React 종속성 및 컴파일된 bundle.js 파일을 참조하도록 다음 코드 스니펫을 포함해주세요:\n\n\n\n```jsx\n\u003cdiv id=\"root\"\u003e\u003c/div\u003e\n```\n\n## Scripts\n```html\n\u003cscript src=\"https://unpkg.com/react@18/umd/react.development.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"~/dist/bundle.js\"\u003e\u003c/script\u003e\n```\n\n![Illustration](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_2.png)\n\n# 결과:\n\nMVC 애플리케이션 실행...완료!\n\n\n\n\n![이미지](/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_3.png)\n\n결론: 이 단계별 지침을 따르면 React 응용 프로그램을 ASP.NET MVC 프로젝트에 원활하게 통합할 수 있습니다. 이 접근 방식을 통해 React의 컴포넌트 기반 아키텍처의 이점을 활용하면서 서버 측 렌더링 및 비즈니스 로직 처리에 ASP.NET MVC의 견고함을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingReactApplicationintoASPNETMVCProjectAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"React에서 JSON 객체를 Excel 파일로 내보내는 방법 완벽한 가이드","description":"","date":"2024-05-14 11:10","slug":"2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png\" /\u003e\n\n## 소개 🌟\n\n리액트 개발자들은 종종 데이터를 다양한 형식으로 변환하고 다운로드해야 합니다. 현대 웹 개발에서 공통이지만 필수적인 작업 중 하나는 JSON 객체를 Excel 파일로 내보내는 것입니다. 이 안내서는 이 프로세스를 간단하게 만들어 React 애플리케이션에서 JSON 데이터를 빠르게 변환하고 다운로드하는 방법을 안내합니다. 초보자부터 경험 많은 개발자까지 모두에게 적합하며, 이 튜토리얼은 XLSX와 FileSaver와 같은 인기 있는 라이브러리를 사용하여 애플리케이션의 데이터 처리 기능을 향상시킵니다.\n\n시작하기 전에, 제 개인 웹사이트에서 웹 개발에 대한 더 깊이있는 기사들을 살펴보세요:\n\n\n\n## 라이브러리 이해하기: XLSX 및 FileSaver 📚\n\n코드를 시작하기 전에 사용할 라이브러리를 간단히 살펴보겠습니다. XLSX는 웹 애플리케이션에서 엑셀 작업을 다루는 인기 있는 라이브러리로, 엑셀 문서를 읽고 조작하며 작성할 수 있게 해줍니다.\n\nFileSaver는 클라이언트 측에서 파일을 저장하는 데 유용한 다른 라이브러리로, 변환된 엑셀 파일을 다운로드하기에 이상적입니다. 이러한 라이브러리들은 JSON 데이터를 React 환경에서 엑셀 파일로 내보내는 데 원활한 방법을 제공합니다.\n\n## 단계 1: XLSX 라이브러리 설치 및 가져오기 ⚙️\n\n\n\nReact에서 Excel 파일을 다루려면 XLSX 라이브러리를 사용합니다. 먼저 npm을 사용하여 React 프로젝트에 설치해야 합니다:\n\n```js\nnpm install xlsx file-saver\n```\n\nfile-saver 패키지는 파일 다운로드를 트리거하는 데 도움을 줍니다. 다음으로 이 라이브러리들을 React 컴포넌트에 가져옵니다:\n\n```js\nimport * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\n```\n\n\n\n## Step 2: JSON 데이터 준비하기 📊\n\n내보내기 전에 JSON 데이터가 올바르게 구조화되어 있는지 확인하세요. 예를 들어, 각 객체가 엑셀의 행을 나타내는 JSON 배열을 고려해보세요:\n\n```js\nconst data = [\n    { name: \"John\", email: \"john@example.com\", age: 28 },\n    { name: \"Jane\", email: \"jane@example.com\", age: 32 }\n];\n```\n\n## Step 3: 내보내기 함수 정의하기 🚀\n\n\n\n편리하게 사용할 수 있도록 React 컴포넌트 내에서 내보내기를 처리하는 함수를 만들어보세요. 해당 함수는 JSON 데이터를 Excel 형식으로 변환하고 다운로드를 시작할 것입니다:\n\n```js\nconst exportToExcel = () =\u003e {\n    const worksheet = XLSX.utils.json_to_sheet(data);\n    const workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, worksheet, \"Sheet1\");\n\n    // 생성된 Excel 파일을 저장할 버퍼\n    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });\n\n    saveAs(blob, \"data.xlsx\");\n};\n```\n\n## Step 4: 내보내기 버튼 만들기 🔘\n\nReact 컴포넌트 내에서 클릭되었을 때 exportToExcel 함수를 호출하는 버튼을 추가해보세요:\n\n\n\n```js\n\u003cbutton onClick={exportToExcel}\u003eExcel로 내보내기\u003c/button\u003e\n```\n\n## Step 5: JSON을 Excel로 내보내는 컴포넌트 완성 ✅\n\n이번 단계에서는 모든 부분을 모아 완전히 작동하는 React 컴포넌트로 조립합니다. 이 컴포넌트를 사용하면 사용자가 간단한 버튼 클릭으로 JSON 데이터를 Excel 파일로 내보낼 수 있습니다.\n\n```js\nimport React from 'react';\nimport * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\n\nfunction ExcelExportComponent() {\n    const data = [\n        { name: \"John\", email: \"john@example.com\", age: 28 },\n        { name: \"Jane\", email: \"jane@example.com\", age: 32 },\n        // ... 더 많은 데이터\n    ];\n\n    const exportToExcel = () =\u003e {\n        const worksheet = XLSX.utils.json_to_sheet(data);\n        const workbook = XLSX.utils.book_new();\n        XLSX.utils.book_append_sheet(workbook, worksheet, \"시트1\");\n\n        // 생성된 Excel 파일을 저장할 버퍼\n        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n        const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });\n\n        saveAs(blob, \"exportedData.xlsx\");\n    };\n\n    return (\n        \u003cdiv className=\"App\"\u003e\n            \u003cbutton onClick={exportToExcel}\u003eExcel로 내보내기\u003c/button\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default ExcelExportComponent;\n```\n\n\n\n이 컴포넌트를 React 앱에 통합하고 'Excel로 내보내기' 버튼을 클릭하면 데이터 배열이 Excel 파일로 변환되어 컴퓨터로 다운로드됩니다. 이 컴포넌트는 React 애플리케이션 내에서 내보내기 기능을 어떻게 처리하는지 효과적으로 보여줍니다.\n\n## 실행과 출력 📈\n\nExcelExportComponent를 React 앱에 통합하면 쉽게 기능을 테스트할 수 있습니다. 애플리케이션을 실행하고 'Excel로 내보내기'라고 표시된 버튼이 있는 것을 볼 수 있습니다. 이 버튼을 클릭하면 exportedData.xlsx라는 이름의 Excel 파일이 다운로드되며 JSON 데이터가 스프레드시트로 포맷되어 있습니다.\n\n실제 시나리오에서 이 컴포넌트의 작동을 명확히 이해할 수 있도록 CodeSandbox의 실시간 데모를 확인해보세요. 이 상호 작용 예제를 통해 컴포넌트를 실제로 볼 수 있고 코드를 탐색하여 실제 시나리오에서의 작동 방식을 명확히 이해할 수 있습니다.\n\n\n\n## 결론 🎯\n\n이 가이드는 React에서 JSON을 Excel로 내보내는 과정을 간소화하여 웹 애플리케이션에서 데이터 처리에 대한 효과적인 해결책을 보여줍니다. 제공된 단계들과 라이브 데모는 React가 데이터를 쉽게 처리하고 변환하는 방법을 강조하며, 현대 웹 개발 시나리오에서 개발자들에게 실용적인 도구를 제공합니다. 이 기능은 사용자 경험을 향상시키는데 그치지 않고 React가 다양한 데이터 형식을 처리하는 다양성을 보여줍니다.\n\n즐거운 내보내기!!!","ogImage":{"url":"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ExportingJSONObjectsasExcelFilesinReactCompleteGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Reactjs에서 멋진 호버 효과 만들기 GitHub을 영감받은 카드 애니메이션","description":"","date":"2024-05-14 11:08","slug":"2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation","content":"\n\n\n![Card Hover Effect](https://miro.medium.com/v2/resize:fit:1200/1*Cm18EAy6mzdv8N4iOpm1mA.gif)\n\n이 글에서는 React를 사용하여 매혹적인 카드 호버 효과를 구현하는 방법을 살펴봅니다. 커서를 따라 움직이는 동적 라이트 효과를 추가하는 과정부터 사용자 경험을 몰입적이고 시각적으로 매력적으로 만드는 것까지 다룰 것입니다. 마우스 이벤트 처리부터 부드러운 애니메이션 및 성능 최적화까지, 웹 프로젝트를 높이는 눈에 띄는 카드 상호작용을 만드는 데 필요한 모든 것을 다룰 것입니다.\n\n먼저, CardWithAnimationComponent 라는 컴포넌트를 생성합니다:\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    return (\n        \u003cdiv className={styles.main_div_card_with_animation}\u003e\n            {children}\n        \u003c/div\u003e\n    );\n}\n```   \n  \n\n\n\n안녕하세요! 보시다시피, children이라는 하나의 prop을 가져와요. 이 prop은 ReactNode 타입이에요. 컴포넌트 내부에서는 스타일시트에서 CSS 클래스인 main_div_card_with_animation을 가진 `div` 요소를 렌더링하고 이 `div` 내에 children을 렌더링해요.\n\n다음 단계에서 화면에서 커서 위치를 가져오기 위해 이 코드를 작성했어요:\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n\n    const handleMouseMove = (e: MouseEvent) =\u003e {\n        const x = e.clientX;\n        const y = e.clientY;\n        setHoverPosition({x, y});\n    };\n\n    return (\n        \u003cdiv className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}\u003e\n            {children}\n        \u003c/div\u003e\n    );\n}\n```\n\n컴포넌트 내부에서 useState 훅을 사용하여 hoverPosition이라는 상태 변수를 초기화하고, 이 변수는 x와 y라는 속성을 갖는 객체이며, 초기값은 모두 0으로 설정돼요. 그런 다음 MouseEvent를 인수로하여 handleMouseMove 함수를 정의했어요. 이 함수는 마우스가 컴포넌트 내에서 움직일 때마다 현재 마우스 좌표 (clientX 및 clientY)로 hoverPosition 상태를 업데이트해요.\n\n\n\n이제 커서를 따라 이동하는 라이트를 만들기 위해 또 다른 div를 추가할 시간입니다:\n\n```js\n\u003cdiv className={styles.main_div_card_with_animation}\n     onMouseMove={handleMouseMove}\u003e\n    {children}\n    \u003cdiv\n      className={styles.light}\n        style={\n          left: hoverPosition.x,\n          top: hoverPosition.y,\n          zIndex: -1,\n         }/\u003e\n\u003c/div\u003e\n```\n\n```js\n.main_div_card_with_animation {\n    position: relative;\n    overflow: hidden;\n    border-radius: 10px;\n    border: 1px solid rgba(255, 255, 255, 0.08);\n    background: rgb(0, 0, 0);\n}\n\n.light {\n    position: absolute;\n    width: 50%;\n    aspect-ratio: 1;\n    border-radius: 50%;\n    filter: blur(100px);\n    -webkit-filter: blur(100px);\n    background-color: rgba(255, 39, 223, 0.51);\n}\n```\n\n이 CSS 코드는 .light 클래스를 만들어서 position을 absolute로, width를 50%로 설정하고, filter 속성을 사용하여 요소에 매우 강한 blur 효과를 적용합니다.\n\n\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*Q9mUuviNZgZdAB_iUsmfkg.gif)\n\n마우스 커서를 따라 이동하는 빛이 있지만 2 가지 문제가 있습니다. 먼저, 빛이 커서의 중심이 아니며 둘째로 마우스가 div 영역을 벗어나면 빛이 사라지지 않습니다.\n\n## 빛의 위치 수정하기\n\n이 문제를 해결하기 위한 아이디어 중 하나는:\n  \n\n\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n    const containerRef = useRef\u003cHTMLDivElement\u003e(null);\n\n    const handleMouseMove = (e: MouseEvent) =\u003e {\n        if (!containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const lightSize = rect.width * 0.5; // 50% of container's width, equal to light size in css file\n        const x = e.clientX - rect.left - lightSize / 2;\n        const y = e.clientY - rect.top - lightSize / 2;\n        setHoverPosition({x, y});\n    };\n    return (\n        \u003cdiv className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}\n             ref={containerRef}\u003e\n            {children}\n            \u003cdiv\n                className={styles.light}\n                style={{\n                    left: hoverPosition.x,\n                    top: hoverPosition.y,\n                    zIndex: -1,\n                }}\n            /\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n저는 containerRef를 추가했고 handleMouseMove 함수도 변경했습니다. containerRef는 useRef 훅을 사용하여 생성된 참조 객체입니다. 이 객체는 카드의 컨테이너 div 요소에 할당됩니다. React에서 Refs는 렌더 메서드에서 생성된 DOM 노드나 React 요소에 액세스하는 방법을 제공합니다. 이 경우 containerRef는 handleMouseMove 함수에서 컨테이너와 마우스 위치를 계산하는 데 사용됩니다.\n\nhandleMouseMove 함수에서 x와 y 좌표가 어떻게 계산되는지 살펴보겠습니다:\n\n- 마우스 이동 이벤트가 발생하면 clientX 및 clientY 속성이 제공됩니다. 이는 브라우저 창의 클라이언트 영역에 대한 마우스 포인터의 수평 및 수직 좌표를 나타냅니다.\n- 직사각형과 오프셋: getBoundingClientRect() 메서드는 요소의 크기와 뷰포트에 대한 위치를 반환합니다. 여기서 containerRef로 참조된 컨테이너 div에 대해 호출됩니다. rect 객체에는 요소의 상하좌우 위치를 나타내는 top, left, right, bottom과 같은 속성이 포함됩니다.\n- 빛 크기 조정: lightSize는 컨테이너 너비의 반( rect.width * 0.5 )로 계산됩니다. 이는 CSS 파일에서 빛의 크기에 해당합니다.\n- X와 Y 계산: x와 y 좌표를 컨테이너에 대해 계산하기 위해 마우스의 clientX 및 clientY 위치에서 컨테이너의 left 및 top 위치를 각각 빼줍니다. 추가로 lightSize의 절반을 빼서 x와 y 좌표가 마우스 포인터를 중심으로 정렬되도록 합니다.```\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*juNu5QaGs6gO0FmqX4jQDA.gif\" /\u003e\n\n## 마우스가 div를 벗어났을 때 가시성 수정\n\n```js\nfunction CardWithAnimationComponent({children}: { children: ReactNode }) {\n    const [hoverPosition, setHoverPosition] = useState({x: 0, y: 0});\n    const [isHovering, setIsHovering] = useState(false);\n    const containerRef = useRef\u003cHTMLDivElement\u003e(null);\n\n    const handleMouseMove = (e: MouseEvent) =\u003e {\n        if (!containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const lightSize = rect.width * 0.5; // container 너비의 50%, CSS 파일에서 빛 크기와 동일\n        const x = e.clientX - rect.left - lightSize / 2;\n        const y = e.clientY - rect.top - lightSize / 2;\n        setHoverPosition({x, y});\n    };\n\n    const handleMouseEnter = () =\u003e {\n        setIsHovering(true);\n    };\n\n    const handleMouseLeave = () =\u003e {\n        setIsHovering(false);\n    };\n\n    return (\n        \u003cdiv className={styles.main_div_card_with_animation}\n             onMouseMove={handleMouseMove}\n             onMouseEnter={handleMouseEnter}\n             onMouseLeave={handleMouseLeave}\n             ref={containerRef}\u003e\n            {children}\n            \u003cdiv\n                className={styles.light}\n                style={{\n                    left: hoverPosition.x,\n                    top: hoverPosition.y,\n                    zIndex: -1,\n                    opacity: isHovering ? '1' : '0',\n                    transition: 'opacity 500ms ease',\n                }}\n            /\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n여기에는 빛의 투명도를 설정하고 애니메이션과 함께 보여주기 위해 isHovering 및 handleMouseEnter 및 handleMouseLeave를 추가했습니다. 그리고 끝났어요!\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*Fu0K11BdC_r-j1gLHidQfA.gif)\n\n❤️ 이 기사를 읽어 주셔서 감사합니다. 여러분의 생각을 듣고 싶습니다. 저에 대해 더 알고 싶으시면 제 웹사이트를 방문해주세요:\n","ogImage":{"url":"/assets/img/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingStunningHoverEffectsInReactjsTheGitHub-InspiredCardAnimation_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트 하이드레이션 오류 지옥 탈출하기","description":"","date":"2024-05-14 11:06","slug":"2024-05-14-EscapingReactHydrationErrorHell","content":"\n\n# 소개\n\n리액트 애플리케이션을 하이드레이션할 때 다음과 같은 오류 메시지가 표시되었을 수 있습니다:\n\n![Error](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png)\n\n이 오류는 서버 측에서 렌더링된 리액트 트리와 브라우저에서 처음 렌더링할 때 클라이언트 측에서 생성된 리액트 트리 간에 차이가 있는 경우 발생합니다. React는 이 둘 간의 차이를 조정할 수 없어서 트리의 UI 및 상호 작용을 제어할 수 없게 됩니다.\n\n\n\n여기서는 일반적인 원인, 오류를 디버그하는 방법 및 수화 오류를 피하는 일반적인 해결책을 살펴보겠습니다.\n\n# 원인\n\n수화 오류의 일반적인 원인 몇 가지가 있습니다.\n\n![2024-05-14-EscapingReactHydrationErrorHell_1.png](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_1.png)\n\n\n\n## 브라우저 감지 기반 렌더링\n\n컴포넌트가 브라우저에서 렌더링되는지 또는 서버에서 렌더링되는지를 감지하는 로직이 있다면 주의가 필요합니다. 예를 들어:\n\n```js\nconst isClient = typeof window !== \"undefined\";\n```\n\n다음 가짜 예시를 살펴봅시다:\n\n\n\n```js\nconst IsomorphicContainer = () =\u003e {\n  const isClient = typeof window !== \"undefined\";\n\n  return isClient ? \u003cClientOnlyComponent /\u003e : null;\n};\n```\n\n여기서 `ClientOnlyComponent /`은 클라이언트 측에서만 사용할 수 있다고 가정합니다. 외부 스크립트와 통합할 때 이런 경우가 흔합니다. 아마도 클라이언트 측 GTM DataLayer 구성 구성 요소인 것 같습니다.\n\nReact는 세계의 이해가 동기화되지 않아 발생하는 이슈가 있습니다:\n\n- 서버에서는 isClient 조건이 false로 평가되어 null 값이 렌더링됩니다.\n- 수화하기 전 클라이언트 측에선 window가 정의되어 이 표현식이 true로 평가됩니다.\n- 수화 후 함수형 컴포넌트가 처음 렌더링되면 `ClientOnlyComponent /`이 결과로 나오는데, 이는 서버 측에서 렌더링된 null 값과 맞지 않습니다.\n- 이로 인해 수화 오류가 발생합니다.```\n\n\n\n## 브레이크포인트 감지 기반 렌더링\n\n브라우저 감지 문제의 확장으로, 특정 브라우저 API의 결과에 따라 기능을 감지하고 조건부로 렌더링하려는 모든 구성 요소가 영향을 받을 수 있습니다. 예를 들어:\n\n```js\nconst mediaQueryList = window?.matchMedia(\"(max-width: 768px)\") ?? {};\n```\n\n다음 가짜 예제를 고려해 봅시다:\n\n\n\n```js\nimport { useMediaQuery } from 'react-responsive';\n\nconst BreakpointVaryingCTA = ({ showModel }) =\u003e {\n  const isMobileOrTablet = useMediaQuery({ maxWidth: 768 });\n\n  return isMobileOrTablet ? \u003ca href=\"/content\"\u003e추가 정보\u003c/a\u003e : \u003cbutton type=\"button\" onClick={showModel}\u003e추가 정보\u003c/button\u003e\n};\n```\n\n여기에는 모바일 및 태블릿 장치에서 링크를 렌더링하고, 데스크톱 장치에서는 추가 정보를 위해 모달을 열고자 하는 강제로 설정된 설정이 있습니다.\n\n서버 측에서 미디어 쿼리 후크는 폭이 768px 미만이 아니기 때문에 false로 평가됩니다. 사실, 서버 측에서는 뷰포트 개념이 전혀 없습니다!\n\n클라이언트 측에서 데스크톱에서는 후크가 false로 해결되고 하이드레이션 매치를 얻을 수 있어 운이 좋습니다.\n\n\n\n\n모바일에서 클라이언트 측에서 문제가 발생할 수 있어요. 후크는 true로 해결되고 첫 번째 렌더링은 앵커 요소가 되어 서버에 렌더링된 버튼과 일치하지 않아 오류가 발생합니다.\n\n## 공백\n\n수많은 수많은 습성의 수난과 번거로운 원인 중 하나로 수분상 software나 될 수 있어요. 서버 측에 렌더링된 내용과 클라이언트 측에 렌더링된 내용 사이의 공백 불일치가 발생할 때 오류가 발생하곤 해요.\n\n일부 템플릿 리터럴을 사용하여 만들어진 문자열 보간 코드로 생성된 React 루트 요소의 두 가지 변형을 고려해보세요:\n\n\n\n```js\n\u003cdiv id=\"root\"\u003e${html}\u003c/div\u003e\n\n\u003cdiv id=\"root\"\u003e\n  ${html}\n\u003c/div\u003e\n```\n\n후자의 예시는 React 트리 내용을 감싸는 새 줄과 루트 노드 간의 불일치로 인해 수분화 오류가 발생할 가능성이 있습니다:\n\n```js\n경고: \u003cdiv\u003e에서 텍스트 노드 \" \"을(를) 포함하는 서버 HTML을 기대하지 않았습니다.\n```\n\n이와 유사하게 응답 HTML의 공백을 제거하여 압축하면 비슷한 문제가 발생할 수 있습니다.```\n\n\n\n## 데이터 차이점\n\n사용자에게 컴포넌트를 통해 반영되는 데이터가 서버 렌더링과 클라이언트 렌더링 사이에 시간이나 환경 때문에 다를 수 있다면, 이 또한 불일치를 초래할 수 있습니다.\n\n이 문제의 가장 일반적인 형태는 타임스탬프를 렌더링하는 것입니다:\n\n- 클라이언트 측 타임스탬프가 서버 측과 다르게 나타날 것이며 시간이 흐르기 때문입니다;\n- 클라이언트보다 서버의 시간대가 다르다면, 시간대가 출력 값에 고려되지 않는다면 차이가 발생할 수 있습니다.\n\n\n\n다른 예시로는 다음과 같은 것들이 있을 수 있습니다:\n\n- 수분화 전에 검색한 API 데이터를 컴포넌트 안에 반영하는 것입니다. 예를 들어, 클라이언트에서 API 데이터를 새로 고치고 나서 수분화하면, 서버 측에서 렌더링한 이후에 API 데이터가 변경된 경우 일치하지 않을 수 있습니다.\n- 서버와 클라이언트 모두에서 uuid 패키지를 사용하는 비결정적 ids를 사용하는 것 대신에, React 18 이후 버전을 사용하면 React.useId()를 사용해보세요.\n- 문자 인코딩 차이 - 서버와 클라이언트가 일치하는지 확인하세요! 일반적으로 utf-8을 사용하는 것이 좋습니다.\n\n## 잘못된 HTML\n\n일부 요소는 다른 요소 안에 중첩될 수 없습니다. 예를 들어 `a` 요소 안에 다른 `a` 요소를 중첩할 수 없습니다.\n\n\n\n```\n![이미지](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_2.png)\n\n브라우저에 따라 이러한 부적절한 요소가 수화 전에 DOM에서 제거될 수 있으며, React가 수화하려고 할 때 불일치가 발생할 수 있습니다.\n\n여기서 중요한 점은 유효한 HTML을 작성하는 것입니다!\n\n## 제삼자의 간섭\n```\n\n\n\n알려진 몇 가지 시나리오에는 코드 외의 메커니즘이 서버 응답에 영향을 줄 수 있어 수분화 문제가 발생할 수 있습니다:\n\n- 페이지 조작하는 브라우저 확장 프로그램 — React 이슈를 참조하세요.\n- 클라우드 제공업체 / CDN이 HTML 응답을 조작하는 경우 — Cloudflare 문서를 참조하세요.\n- 구글 크롬 번역 기능으로 페이지 조작하는 경우 — React 이슈를 참조하세요.\n- iOS 형식 감지가 HTML 응답을 조작하는 경우 — NextJS 문서를 참조하세요.\n- 수분화 이전에 페이지를 조작하는 조기 실행 타사 스크립트, 예: GTM, HotJar.\n\n# 디버깅\n\n그러면 수분화 경고의 근본 원인을 디버깅할 수 있는 몇 가지 방법을 살펴봅시다!\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_3.png\" /\u003e\n\n## React 개발 빌드\n\nReact의 개발 빌드를 사용할 때는 개발 도구 콘솔에서 완전하지만 압축되지 않은 수분화 경고를 받을 수 있습니다. 이를 통해 문제가 발생한 구성 요소를 빠르게 식별할 수 있습니다.\n\n거기서 알려진 수분화 오류 원인 중 일부와 구성 요소를 빠르게 매칭하여 문제를 해결할 수 있습니다.\n\n\n\n현재 로컬에서 React를 개발 모드로 실행하면서 테스트 또는 프로덕션 환경 API와 통합할 수 없는 경우, 개발자 경험을 향상시키기 위해 팀에서 시간을 투자하는 것이 가치가 있을 수 있습니다.\n\n## 복구 가능한 오류 로그\n\n이 옵션들은 React 18 버전 이후를 사용한다고 가정합니다.\n\n바닐라 React 애플리케이션\n\n\n\nReact 트리에 hydrateRoot()를 호출할 때 옵션으로 전달할 수 있는 세 번째 인수가 있습니다.\n\n이 옵션 중 하나는 onRecoverableError이며, 이는 React가 오류에서 자동으로 복구할 때 호출할 콜백을 받습니다. 예를 들어 수분화 오류가 발생한 경우입니다.\n\n이 콜백에 지표를 추가하여 문제를 로깅할 수 있도록 권장됩니다. 예를 들어 New Relic, Sentry, Datadog, Elastic RUM 등의 관측성 플랫폼에 이러한 문제를 기록할 수 있습니다.\n\n여기에 예시 코드 조각이 있습니다:\n\n\n\n```js\nimport { hydrateRoot } from 'react-dom/client';\nimport MyObservabilityPlatform from 'my-observability-platform';\nimport App from './App'\n \nfunction onRecoverableError(error, errInfo) {\n  let context = {};\n \n  if (errInfo?.componentStack) {\n     // 생성된 합성 오류를 사용하면 모니터링 서비스가 소스맵을 적용하여 스택 트레이스를 압축 해제하고 가독성 있게 만들 수 있습니다.\n     const errorBoundaryError = new Error(error.message);\n     errorBoundaryError.name = `React ErrorBoundary ${errorBoundaryError.name}`;\n     errorBoundaryError.stack = errInfo.componentStack;\n \n     error.cause = errorBoundaryError;\n \n     context.componentStack = errInfo.componentStack;\n  }\n \n  MyObservabilityPlatform.captureException(error, { context })\n}\n \nconst domNode = document.getElementById('root');\n \nhydrateRoot(domNode, \u003cApp /\u003e, { onRecoverableError });\n```\n\nhydrateRoot() 옵션에 대한 추가 정보는 리액트 문서에서 확인할 수 있습니다.\n\nNextJS 어플리케이션\n\nNextJS를 사용할 때는 애플리케이션의 수화를 직접 호출할 필요가 없습니다. NextJS가 대신 수행해줍니다.```\n\n\n\nNextJS는 현재 hydrateRoot()에 onRecoverableError 옵션을 전달할 수 있는 기능을 제공하지 않습니다. 이 옵션을 노출하기 위한 시도에 대한 논의를 위해 https://github.com/vercel/next.js/discussions/36641을 참고하세요.\n\n그러나 우리는 이 옵션을 수동으로 패치하여 로컬 및 프로덕션 환경에서 문제를 디버깅할 수 있습니다. 이를 위한 한 가지 방법은 Chrome 로컬 오버라이드를 사용하는 것입니다:\n\n- Chrome에서 수분화 오류가 발생하는 페이지로 이동하고 개발자 도구를 엽니다.\n- Sources 탭을 열고 왼쪽 메뉴에서 Page 탭을 선택합니다. 자산 트리에서 오른쪽 클릭하여 모든 파일에서 검색 옵션을 표시합니다.\n- 열리는 창에서 onRecoverableError 용어를 검색하여 모든 코드 일치 항목을 확인합니다.\n- 코드 중 하나는 this.onRecoverableError = a;와 유사해야 합니다. 이 코드를 수정하여 오류와 errorInfo 인수를 모두 콘솔에 기록하도록 수정할 것입니다.\n- 파일 탭에서 오른쪽 클릭하여 Override Content 옵션을 클릭합니다. 이로써 측면 메뉴에 오버라이드 탭이 열릴 것입니다. Enable Local Overrides 옵션이 선택되어 있는지 확인합니다.\n- 이 시점에서 파일이 압축되어 보인다면, 가독성을 높이기 위해 prettifier 버튼 ''를 사용합니다.\n- 다음 스니펫으로 코드를 교체합니다:\nthis.onRecoverableError = (error, errorInfo) =\u003e console.error(error, errorInfo);. 이렇게 하면 수분화 오류와 추가 componentStack 정보가 이제 콘솔에 기록됩니다. 반드시 저장하세요!\n- 페이지를 새로고침하고 이제 수분화 오류 옆에 추가 객체가 로그되는 것을 확인하십시오. 이제 컴포넌트 스택을 사용하여 어떤 컴포넌트에 문제가 있는지 추적할 수 있습니다. 스택이 압축되어 있기 때문에 어떤 컴포넌트가 작동 중인지 정확히 식별하기 어려울 수 있습니다 - identifier되는 요소인 주 태그부터 시작하여 트리를 따라 자식 요소로 이동하는 것이 종종 유용합니다.\n\n수동으로 패치하는 대안적인 전략은 코드로 패치하는 것입니다. NextJS에 대한 아이디어를 위한 이 NextJS 논의 스레드 또는 코드 예제를 참조하십시오. 이는 프로덕션 환경에 권장되지 않지만 로컬 개발 빌드에 도입하는 것이 개발자 경험을 향상시키는 편리한 능력이 될 수도 있습니다.\n\n\n\n## DevTools 디버거\n\n수분 오류를 식별하는 또 다른 방법은 DevTools 디버거를 사용하여 예외 발생 시 일시 중지하는 것입니다. 특히 \"잡힌 예외에서 일시 중지\"는 수분 오류에 특히 유용할 수 있습니다.\n\n이 방법의 단점은 응용 프로그램이 발생(및 잡는) 예외의 수에 따라 원인을 식별하는 것이 꽤 번거로울 수 있다는 것입니다. 문제와 관련이 있는 것을 찾기 전에 상당수의 관련이 없는 잡힌 예외를 한땀한땀 찾아야 할 수도 있습니다.\n\nChrome DevTools의 잡힌 예외에 대한 자세한 정보는 Chrome 개발자 문서에서 확인할 수 있습니다.\n\n\n\n# 해결책\n\n서버와 클라이언트 측에서 렌더링된 것을 조정할 수 없는 상황이라면 수분화 문제를 해결하는 몇 가지 전술이 있습니다.\n\n![이미지](/assets/img/2024-05-14-EscapingReactHydrationErrorHell_4.png)\n\n## 두 번째 렌더링으로 연기\n\n\n\n한 가지 해결책은 서버 측 및 클라이언트 측의 첫 번째 렌더링에 동일한 콘텐츠가 렌더링되고, 그 후부터는 클라이언트 측 특정 컴포넌트를 렌더링할 수 있도록 하는 것입니다.\n\n```js\nconst IsomorphicContainer = () =\u003e {\n  const [isClient, setIsClient] = useState(false);\n \n  useEffect(() =\u003e {\n    setIsClient(true);\n \n    return () =\u003e {\n      setIsClient(false);\n    }\n  }, []);\n \n  return isClient ? \u003cClientOnlyComponent /\u003e : null;\n}\n```\n\n이펙트는 서버 측에서 실행되지 않기 때문에 서버에서 렌더링될 때 isClient 값은 false입니다.\n\n또한 이펙트는 첫 번째 렌더링 후에 실행되므로 클라이언트 측에서 첫 번째 패스에는 isClient 부울 값이 여전히 false이며 수분화 매칭이 유지됩니다.\n\n\n\nReact 트리에 컴포넌트가 마운트되면 부수 효과가 트리거되어 불리언을 true로 전환하며 `ClientOnlyComponent`를 생성합니다.\n\nReact 문서에서 자세한 정보를 확인할 수 있습니다.\n\n추가적인 고려 사항\n\n성능\n\n\n\n이 해결책은 성능 부담이 적은 단순히 렌더링만 하는 것과 비교할 때 React 트리에 마운트될 때 컴포넌트가 두 번 렌더링되는 현상을 가져옵니다.\n\n컴포넌트를 다시 렌더링하는 추가 CPU 시간은 가장 큰 콘텐츠 렌더 시간 (LCP) 및 다음 렌더링까지의 상호작용 (INP)과 같은 CPU에 의한 성능 지표에 부정적인 영향을 미칠 수 있습니다.\n\n비스안스 스타일 콘텐츠의 깜빡임\n\n시각적으로 무언가를 렌더링하는 컴포넌트의 경우, 이 접근 방법으로 비스안스 스타일 콘텐츠 깜박임 (FOUC)이 발생하는 경우, 화면을 다시 그리기 전에 트리거될 useLayoutEffect를 사용하는 것을 고려해보세요.\n\n\n\n이는 화면에 첫 번째 다시 그리기가 발생하기 전에 첫 번째 렌더, 후크 실행 및 두 번째 렌더의 전체 주기가 모두 발생함을 보장합니다.\n\n이로 인해 다음 페인트까지의 시간에 성능 영향을 미치지만 useEffect 사용은 항상 먼저 고려되어야 합니다. 특히 INP와 같은 지표들이 더 두드러질 때에는 더욱 그렇습니다.\n\n## NextJS 동적 패키지 \"매직\"\n\nNextJS를 사용 중이라면 클라이언트 측에서만 고려되어야 하는 컴포넌트를 지정하는 대체 옵션이 몇 가지 있습니다.\n\n\n\n다음/동적 모듈을 사용하여 이를 구현했습니다:\n\n```js\nimport dynamic from 'next/dynamic';\n \nconst ClientOnlyComponent = dynamic(() =\u003e import('../components/Component'), { ssr: false });\n```\n\nNextJS 문서에서 더 많은 정보를 확인할 수 있습니다.\n\n## 로다블 컴포넌트 패키지 \"매직\"\n\n\n\n만약 @loadable/component 패키지를 사용 중이라면, next/dynamic 패키지와 유사하게 컴포넌트를 클라이언트 측만 고려해야 한다는 옵션을 지정할 수 있습니다:\n\n```js\nimport loadable from '@loadable/component';\n\n// 이 동적 임포트는 서버 측에서 처리되지 않습니다\nconst Other = loadable(() =\u003e import('../components/Component'), { ssr: false });\n```\n\nLoadable 컴포넌트 문서에서 더 많은 정보를 확인할 수 있습니다.\n\n## 다중 렌더링\n\n\n\n브레이크포인트 기반 렌더링과 같은 시나리오를 다룰 때 “두 번째 렌더에 연기\" 기술을 사용할 수 있지만, 이 경우 적어도 하나의 브레이크포인트가 올바른 컴포넌트가 두 번째로 렌더링될 때까지 다른 뷰포트를 위한 내용이 잠깐 나타나는 문제가 발생할 수 있어요.\n\nCSS를 통해 이 문제를 완화할 수 있는데, 두 번째 렌더 전까지 내용을 시각적으로 숨겨놓은 후 렌더링하는 방법이 있지만, 이렇게 할 경우 콘텐츠 레이아웃 이동(CLS) 메트릭에 부정적인 영향을 미칠 수 있어요. CLS는 검색 엔진 최적화(SEO)에 영향을 미치며 사용자 경험을 나쁘게 만드는 요인이 될 수 있어요.\n\n여기서 일반적으로 수용되는 해결책은 모든 잠재적 변형을 서버 측에서 렌더링하는 것이에요:\n\n- 각 브레이크포인트에서 필요한 모든 변형을 서버 측에서 렌더링해요.\n- 렌더링 블로킹 스타일이나 링크 태그로 전달되는 CSS 미디어 쿼리를 사용하여 클라이언트에서 처음으로 로딩될 때 사용자에게 원하는 변형만 표시되도록 해요.\n- \"두 번째 렌더에 연기\" 기술을 사용하여 수분화 불일치가 없도록 해요.\n- 두 번째 렌더링 시에는 원하지 않는 컴포넌트를 null로 렌더링하고 언마운트하면 돼요.\n\n\n\n서버 렌더링된 HTML이 부풀어오르는 결과를 초래할 수 있는 이 문제는 TTFB에 영향을 미칠 수 있습니다. 또한 \"두 번째 렌더링으로 연기\" 기술의 CPU 사용량 주의사항을 겪을 수 있지만, 서버와 클라이언트 간에 원활한 전환을 보장하고 원치 않는 콘텐츠가 번쩍이지 않도록 해줍니다.\n\n이 기술에 대한 자세한 정보는 다음 기사에서 확인할 수 있습니다: viewport 특정 반응형 디자인에 SSR을 사용할 때 CLS 제거하기.\n\n## React 트리 가지치기\n\n이 방법은 \"다중 렌더링\" 기술과 비슷한데, 모든 여러 변형을 모두 수화한 다음 제거하는 대신 리액트 트리를 수화하기 전/수화하는 동안 가지를 잘라냅니다:\n\n\n\n- 모든 변형을 서버 측에서 렌더링합니다.\n- CSS를 사용하여 원하지 않는 콘텐츠가 플래시되지 않도록 합니다.\n- 변형을 하이드레이트/첫 번째 렌더링 시에 원하는 변형인지 여부를 결정하고, 그렇지 않은 경우 React가 해당 노드에 액세스하기 전에 DOM에서 제거합니다 — React는 존재했다는 것을 모르는 DOM 노드에 대해 일치하지 못합니다.\n- DOM에 남아 있는 것이 유효한 유일한 변형인 경우 \"두 번째 렌더에 위임\" 기술을 사용할 필요가 없으므로 우리는 원하는대로 즉시 렌더링할 수 있습니다.\n\n\"다중 렌더링\" 기술과 마찬가지로 이 기술도 TTFB에 영향을 줄 수 있는 팽창된 서버 렌더링 HTML을 만들지만, 다른 기술의 성능 영향은 없습니다.\n\n이 기술에 대한 자세한 정보 및 구현 방법은 이 지스트 예제 및 @artsy/fresnel 패키지에 대한 이 PR에서 찾을 수 있습니다.\n\n또한 최근 X(이전에는 Twitter로 알려진)에 대한 토론도 확인할 수 있습니다.\n\n\n\n# 하이드레이션 경고 비활성화\n\nReact에서 HTML 요소 JSX는 하이드레이션 오류에서 발생하는 경고를 억제하는 데 사용할 수 있는 suppressHydrationWarning 부울을 받습니다.\n\n이는 데이터가 조정되지 않을 때만 사용해야 합니다. 예를 들어, 타임스탬프나 날짜를 페이지에 작성할 때와 텍스트 콘텐츠에서 가리는 차이가 있는 경우에만 사용되어야 합니다.\n\n추가 정보는 React 문서에서 확인할 수 있습니다.\n\n\n\n이게 다예요! 읽어 주셔서 감사합니다 ☺️\n\n수분 공급 오류를 일으키는 다른 예제가 있나요? 또는 문제를 해결하거나 디버그하는 편리한 방법이 있나요?\n\n댓글로 알려주세요!","ogImage":{"url":"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png"},"coverImage":"/assets/img/2024-05-14-EscapingReactHydrationErrorHell_0.png","tag":["Tech"],"readingTime":11},{"title":"오픈 소스로 배우는 팁 Nextjs에서 리다이렉트가 어떻게 작동하는지 살펴보기","description":"","date":"2024-05-14 11:04","slug":"2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood","content":"\n\n이 기사에서는 넥스트.js에서 리다이렉션 작동 방식을 살펴보면서 넥스트.js 소스 코드 주변의 리다이렉션 기능에 대해 배우게 됩니다.\n\n# 나의 접근 방식:\n\n- Import를 시작으로\n- Redirect 함수를 redirect.ts 파일까지 추적\n- redirect.ts 설명\n- 에러를 throw 하는 것이 리디렉션이 작동하는 방법\n- 전체 맥락을 이해하기 위해 redirect.test.ts 확인\n- redirect-boundary.ts에 리다이렉션 기능이 있음\n\n# 1. Import를 시작으로:\n\n\n\n리다이렉트 함수는 next/navigation에서 가져온 것입니다. 리다이렉트에 대해 더 알고 싶다면 다음 링크를 확인해보세요: https://nextjs.org/docs/app/api-reference/functions/redirect.\n\n하지만 next/navigation 코드는 어디에서 찾을 수 있을까요? navigation.js 파일에서 이 코드를 찾을 수 있습니다. 이 파일은 기본적으로 navigation.ts를 내보내는데, 이는 /packages/next/src/client/components에 있습니다.\n\n# 2. 리다이렉트 함수를 redirect.ts 파일로 추적하기\n\n현재 이 글을 작성하는 시점에서 navigation.ts에는 272줄의 코드가 있지만, 우리가 관심 있는 것은 파일 끝에 아래와 같이 표시된 \"redirect\"의 내보내기입니다. 찾고자 하는 것에 집중하세요. 다른 코드에 방해받지 마세요.\n\n\n\n\"여기 보시다시피, redirect는 navigation.react-server.ts에서 내보내는 것입니다. navigation.react-server.ts 안에 들어가보면, redirect 함수가 실제로 redirect.ts에서 왔다는 것을 알게 될 거에요.\n\n저는 중첩된 내보내기를 몰랐어요. 흥미롭네요.\"\n\n\n\n# 3. Render.ts 설명\n\n“redirect() 함수를 호출하면 NEXT_REDIRECT 오류가 발생하고 발생한 위치의 라우트 세그먼트의 렌더링을 중단합니다.\" — Nextjs 문서\n\nredirect.ts 파일 내에서 오류를 발생시키는 코드 조각을 살펴봅시다.\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_2.png)\n\n\n\n# 4. 에러를 발생시켜서 리디렉션이 작동하는 방식은 무엇인가요?\n\n리디렉트 함수가 에러를 발생시켜서 에러.digest를 설정하지만, 에러를 발생시켜서 리디렉션이 작동하는 방식이 명확하지 않았습니다.\n\n오랫동안 찾아봤고, 리디렉트가 에러를 발생시킨다는 것을 고려하여 catch 블록을 찾으려고 노력했습니다. 서버 관련 파일을 뒤져봐도 도움이 되지 않았어요.\n\nredirect.test.ts를 살펴보면서 조금씩 이해되기 시작했어요.\n\n\n\n# 5. 전체 맥락을 이해하려면 redirect.test.ts를 확인하세요\n\n![image](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_3.png)\n\n한 번 어딘가에서 함수의 컨텍스트를 이해하는 데 테스트를 사용할 수 있다고 읽은 적이 있습니다. 그래서 redirect.test.ts에서 코드를 확인한 이유입니다.\n\n테스트 코드에서 getURLFromRedirectError(err) 함수가 호출되는 것이 명백합니다. 이 함수는 react-boundary.ts에서 찾을 수 있습니다.\n\n\n\n알겠어요. 테스트에서는 getURLFromRedirectError 함수를 호출하는데 실행 흐름은 어떻게 될까요? 에러가 발생한 후에는 무엇이 일어날까요? getURLFromRedirectError 함수를 기반으로 검색한 결과는 다음과 같아요:\n\n![이미지](/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_4.png)\n\n## 6. redirect-boundary.ts에는 리디렉션 기능이 있어요\n\n답은 Next.js 리디렉션이 useRouter 훅을 사용하며 리디렉션 유형에 따라 URL을 푸시하거나 교체합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_5.png\" /\u003e\n\n이 리다이렉트 경계는 아래에 표시된 앱-라우터 코드의 일부입니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_6.png\" /\u003e\n\n리다이렉트에서 오류가 발생하면 리다이렉트 경계에서 오류가 catch되고 리다이렉트가 발생합니다. 리다이렉트 함수 자체가 리다이렉트를 수행하지 않고 앱-라우터 내부의 리다이렉트 경계가 라우팅 로직을 처리하는 것이 상당히 흥미로운 점입니다.\n\n\n\n# 결론:\n\n나는 이 API가 왜 이런 식으로 설계되었는지 모르겠지만, 여기에 오류를 throw하는 패턴을 사용하고 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용할 수 있습니다. 이 npm 패키지에서 오류를 throw하는 패턴을 사용하여 해당 오류를 catch하고 원하는 작업을 수행하는 boundary 를 사용해 보세요.\n\nredirect.test.ts 코드를 확인하지 않았다면, redirect 작동 방식을 파악하지 못했을 것입니다. 나는 redirect.ts 에 catch 블록을 찾고 있었지만 그렇지 않았기 때문입니다.\n\n이 글에 대해 궁금한 점이 있으시면 언제든지 ramu.narasinga@gmail.com 으로 연락 주세요.\n\n\n\n# 더 많은 자료:\n\n- [navigation.react-server.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/navigation.react-server.ts)\n- [navigation.js](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/navigation.js)\n- [redirect.ts](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect.ts)\n- [redirect.test.ts](https://github.com/vercel/next.js/blob/canary/packages/next/src/client/components/redirect.test.ts)\n- [redirect-boundary.tsx](https://github.com/vercel/next.js/blob/c1f8d9317588e51a8a31240f6add36b5f2c9f9bf/packages/next/src/client/components/redirect-boundary.tsx#L8)","ogImage":{"url":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png"},"coverImage":"/assets/img/2024-05-14-Tipsfromopen-sourceHowredirectinNextjsworksunderthehood_0.png","tag":["Tech"],"readingTime":4},{"title":"Lexical와 함께하는 React용 리치 텍스트 에디터 시작하기","description":"","date":"2024-05-14 11:00","slug":"2024-05-14-GettingStartedwithLexicalRichTextEditorforReact","content":"\n\n## React JS에서 Lexical을 사용하는 방법에 대한 튜토리얼; 예제와 함께 기본 사항.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png\" /\u003e\n\n... 그러나 유감스럽게도 이 문서는 좋은 설명의 예시가 아닙니다. 이 기사에서는 이 라이브러리를 어떻게 사용하는지를 간단한 용어로 설명하겠습니다.\n\n여기서는 특별한 스타일, 모달 또는 팝오버 없이 렉시컬 리치 텍스트 기능의 기본을 다룰 것입니다:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_1.png)\n\n만약 이 라이브러리가 무엇을 할 수 있는지 확인하고 싶다면, 멋진 렉시컬 플레이그라운드를 확인해보세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_2.png)\n\n관련 이야기:\n\n\n\n# 다룰 내용\n\n- 준비물\n- 시작하기\n- 히스토리 플러그인\n- 노드\n- 리치 텍스트\n- 테마\n- 제목, 도우미 및 노드 구성\n- 페이로드로 자신만의 명령어를 만드는 방법\n- 사용자 정의 노드 만들기\n\n# 준비물\n\n우리는 다음과 같이 만들어진 간단한 React JS 애플리케이션으로 시작할 것입니다:\n\n\n\n```js\nyarn create react-app react-lexical-examples --template typescript\n```\n\n그리고 우리는 어휘 패키지를 설치해야 합니다:\n\n```js\nyarn add lexical @lexical/react\n\n// OR\n\nnpm install --save lexical @lexical/react\n```\n\n# 시작\n```\n\n\n\nLexical을 이용하여 작업을 시작하려면 이 템플릿을 사용할 수 있어요:\n\n```js\nimport React, {useMemo} from 'react';\nimport {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n\nexport const App: React.FC = () =\u003e {\n\n    const CustomContent = useMemo(() =\u003e {\n        return (\n            \u003cContentEditable style={\n                position: 'relative',\n                borderColor: 'rgba(255,211,2,0.68)',\n                border: '2px solid red',\n                borderRadius: '5px',\n                maxWidth: '100%',\n                padding: '10px'\n            }/\u003e\n        )\n    }, []);\n\n    const CustomPlaceholder = useMemo(() =\u003e {\n        return (\n            \u003cdiv style={\n                position: 'absolute', top: 30, left: 30,\n            }\u003e\n                텍스트를 입력하세요...\n            \u003c/div\u003e\n        )\n    }, []);\n\n    const lexicalConfig: InitialConfigType = {\n        namespace: '나의 리치 텍스트 편집기',\n        onError: (e) =\u003e {\n            console.log('에러 발생:', e)\n        }\n    }\n\n    return (\n        \u003cdiv style={padding: '20px'}\u003e\n            \u003cLexicalComposer initialConfig={lexicalConfig}\u003e\n                \u003cPlainTextPlugin\n                    contentEditable={CustomContent}\n                    placeholder={CustomPlaceholder}\n                    ErrorBoundary={LexicalErrorBoundary}\n                /\u003e\n            \u003c/LexicalComposer\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*-7S9xp-EweAiYl8Fn0O8_w.gif)\n\n보다시피, 아주 복잡해 보이지 않죠. 걱정하지 마세요, 나중에 이 컴포넌트들에 대해 자세히 다룰 거예요. 일단은 모든 것이 예상대로 작동하는지 확인하는 것이 중요해요.\n\n\n\n이제 기능을 하나씩 추가해 봅시다.\n\n# 히스토리 플러그인\n\n이전 예제에서 새 텍스트를 입력할 수 있었지만, CTRL-Z(실행 취소)를 누르면 아무 일도 일어나지 않았죠. 이 문제를 해결하기 위해 @lexical/history 플러그인을 추가하여 CTRL-Z(실행 취소)와 CTRL-SHIFT-Z(다시 실행)를 사용할 수 있게 할 수 있습니다.\n\n선택 사항으로 직접 Undo/Redo를 처리하는 사용자 정의 컴포넌트를 추가할 수도 있습니다:\n\n\n\n```js\n@@ -3,6 +3,8 @@\n import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n+import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n+import {CustomHistoryActions} from \"./components\";\n \n export const App: React.FC = () =\u003e {\n \n@@ -44,7 +46,12 @@\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n                 /\u003e\n+                \u003cHistoryPlugin/\u003e\n+                \u003cdiv style={margin: '20px 0px'}\u003e\n+                    \u003cCustomHistoryActions/\u003e\n+                \u003c/div\u003e\n             \u003c/LexicalComposer\u003e\n+\n         \u003c/div\u003e\n     );\n }\n```\n\n```js\nimport {UNDO_COMMAND, REDO_COMMAND} from 'lexical';\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\n\nexport const CustomHistoryActions = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n    return (\n        \u003c\u003e\n            \u003cbutton onClick={() =\u003e editor.dispatchCommand(UNDO_COMMAND, undefined)}\u003e되돌리기\u003c/button\u003e\n            \u003cbutton onClick={() =\u003e editor.dispatchCommand(REDO_COMMAND, undefined)}\u003e다시 실행\u003c/button\u003e\n        \u003c/\u003e\n    );\n}\n```\n\n설명:\n\n- editor는 `LexicalComposer/` 컴포넌트에서 가져온 컨텍스트 값입니다. 에디터 클래스/메소드에 대한 자세한 내용은 여기서 확인할 수 있습니다:```\n\n\n\n간단한 사용 예시:\n\n```js\nconst [editor] = useLexicalComposerContext();\n\n  useEffect(() =\u003e {\n    // 이펙트가 발생할 때 에디터에 포커스를 맞춥니다!\n    editor.focus();\n  }, [editor]);\n```\n\n- UNDO_COMMAND과 REDO_COMMAND는 에디터 내용(또는 원하는 내용)을 처리해야 할 것을 렉시컬에 알리는 등록된 렉시컬 명령입니다. 다음과 같이 사용자 고유의 명령을 생성할 수도 있습니다:\n\n```js\nimport { createCommand, COMMAND_PRIORITY_NORMAL } from \"lexical\";\n\nexport const DO_SOMETHING_AWESOME = createCommand(\"create_banner\");\n\nexport const CustomComponent: React.FC = () =\u003e {\n  const [editor] = useLexicalComposerContext();\n\n  editor.registerCommand(\n    DO_SOMETHING_AWESOME,\n    () =\u003e {\n      console.log('이것은 내가 만든 명령입니다')\n      return true;\n    },\n    COMMAND_PRIORITY_NORMAL,\n  );\n\n  return null;\n};\n```\n\n\n\n걱정하지 마세요, 나중에 이 주제를 조금 더 다룰 거예요.\n\n- editor.dispatchCommand(UNDO_COMMAND, undefined) → 왜 두 번째 인자로 undefined를 전달하는 걸까요? 첫 번째, 그렇게 하지 않으면 TS 오류가 발생합니다. 둘째, 이것은 명령과 함께 전달될 수 있는 페이로드 데이터입니다(우리 경우에는 해당되지 않습니다). dispatchCommand에 대해 더 알아보세요.\n\n# 노드\n\n이 섹션에서는 용어의 작동 방식과 저장하는 데이터에 대해 깊이 파헤쳐야 할 것입니다.\n\n\n\n먼저, 에디터의 상태 변화를 모니터링하고 에디터의 상태를 로깅하는 간단한 플러그인을 만들 것입니다:\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() =\u003e {\n        return editor.registerUpdateListener((listener) =\u003e {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n다음으로, `LexicalComposer/`의 하위 컴포넌트로 `OnChangePlugin/` 컴포넌트를 추가해주세요:\n\n```js\nIndex: src/App.tsx\n@@ -5,6 +5,7 @@\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n import {CustomHistoryActions} from \"./components\";\n+import {OnChangePlugin} from \"./components\";\n\nexport const App: React.FC = () =\u003e {\n\n@@ -47,6 +48,7 @@\n                    ErrorBoundary={LexicalErrorBoundary}\n                /\u003e\n                \u003cHistoryPlugin/\u003e\n+                \u003cOnChangePlugin /\u003e\n                \u003cdiv style={margin: '20px 0px'}\u003e\n                    \u003cCustomHistoryActions/\u003e\n                \u003c/div\u003e\n```\n\n\n\n이제 편집기의 상태가 변경될 때마다 편집기의 상태 트리 데이터를 콘솔에 출력할 것입니다:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_3.png)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Lqyfyb4peVPoHJQvYuBNhQ.gif)\n\n이 텍스트를 입력하면 어떤 데이터를 얻을지 확인해 봅시다:\n\n\n\n```json\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"asd\",\n            \"type\": \"text\",\n            \"version\": 1\n          },\n          {\n            \"type\": \"linebreak\",\n            \"version\": 1\n          },\n          {\n            \"detail\": 0,\n            \"format\": 0,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"dsa\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n아마도 노드가 간단한 속성을 가진 객체임을 알았을겁니다. 주요 속성은 노드의 종류인 type과 노드의 내용인 text입니다.\n\n\n\n```js\nimport initialState from './initialState.json';\n\n// ...\n\nreturn (\n      \u003cLexicalComposer\n        initialConfig={\n          // ...\n          editorState: JSON.stringify(initialState),\n        }\n      \u003e\n            {/* ... */}\n      \u003c/LexicalComposer\u003e\n    );\n```\n\n이 경우 앱을 다시 시작할 때마다 동일한 결과를 얻을 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_4.png\" /\u003e\n\nNodes에 대해 더 많은 정보를 읽어보실 수 있습니다.\n```\n\n\n\n# 리치 텍스트\n\n첫 번째 노드 수정 핸들러를 만들어 봅시다.\n\n이전에 PlainTextPlugin 컴포넌트를 사용했기 때문에 \"bold\" (CTRL+B) 액션과 같은 텍스트 작업을 처리할 수 없습니다:\n\n```js\n\u003cLexicalComposer initialConfig={lexicalConfig}\u003e\n  \u003cPlainTextPlugin ...  /\u003e\n...\n\u003c/LexicalComposer\u003e\n```\n\n\n\nApp.tsx 파일에서 PlainTextPlugin을 RichTextPlugin으로 변경해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -1,6 +1,6 @@\n import React, {useMemo} from 'react';\n import {InitialConfigType, LexicalComposer} from '@lexical/react/LexicalComposer';\n-import {PlainTextPlugin} from \"@lexical/react/LexicalPlainTextPlugin\";\n+import {RichTextPlugin} from \"@lexical/react/LexicalRichTextPlugin\";\n import {ContentEditable} from '@lexical/react/LexicalContentEditable';\n import LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n import {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\n@@ -46,7 +46,7 @@\n             \u003cLexicalComposer\n                 initialConfig={lexicalConfig}\n             \u003e\n-                \u003cPlainTextPlugin\n+                \u003cRichTextPlugin\n                     contentEditable={CustomContent}\n                     placeholder={CustomPlaceholder}\n                     ErrorBoundary={LexicalErrorBoundary}\n```\n\n이제 에디터에서 기본 텍스트 작업을 사용할 수 있을 것입니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:768/1*GWYMSFDfd3PI2PSh5bVsYw.gif\" /\u003e\n\n\n\n우리의 커스텀 버튼을 만들어 봅시다:\n\n```js\n// src/components/CustomTextActions/CustomTextActions.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {FORMAT_TEXT_COMMAND, TextFormatType} from 'lexical';\n\nexport const CustomTextActions = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: TextFormatType) =\u003e {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, formatType)\n    }\n\n    return (\n        \u003cdiv style={{marginTop: '10px'}}\u003e\n            \u003cspan style={{fontWeight: 'bold'}}\u003e텍스트 액션\u003c/span\u003e\n            \u003cdiv\u003e\n                {[\n                    '굵게',\n                    '이탤릭체',\n                    '밑줄',\n                    '코드',\n                    '하이라이트',\n                    '취소선',\n                    '아래첨자',\n                    '위첨자'\n                ].map(value =\u003e {\n                    return (\n                        \u003cbutton\n                            onClick={() =\u003e handleOnClick(value.toLowerCase() as TextFormatType)}\u003e\n                            {value}\n                        \u003c/button\u003e\n                    )\n                })}\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_5.png\" /\u003e\n\n하지만 텍스트를 수정하려고 하면 기대했던 결과가 나오지 않을 수 있습니다: 일부 항목은 변경되고 일부는 변경되지 않을 수 있습니다. 그 이유가 무엇일까요?\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_6.png\" /\u003e\n\nHTML 출력을 확인해 봅시다:\n\n```js\n\u003cp dir=\"ltr\"\u003e\u003cstrong data-lexical-text=\"true\"\u003e굵게\u003c/strong\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003cem data-lexical-text=\"true\"\u003e이탤릭체\u003c/em\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003cspan data-lexical-text=\"true\"\u003e밑줄\u003c/span\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003ccode data-lexical-text=\"true\"\u003e\u003cspan\u003e코드\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\n    \u003cmark data-lexical-text=\"true\"\u003e\u003cspan\u003e강조\u003c/span\u003e\u003c/mark\u003e\n\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003cspan data-lexical-text=\"true\"\u003e취소선\u003c/span\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003csub data-lexical-text=\"true\"\u003e\u003cspan\u003e아래 첨자\u003c/span\u003e\u003c/sub\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003csup data-lexical-text=\"true\"\u003e\u003cspan\u003e위 첨자\u003c/span\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp dir=\"ltr\"\u003e\u003ccode data-lexical-text=\"true\"\u003e\u003cstrong\u003e모두 표시\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\n```\n\n요소에는 적용된 스타일이 없지만 브라우저에서 `mark`/`strong/`/`em/`에 대한 사전 정의된 스타일이 있어 약간의 스타일 변화가 있습니다. 그러나 우리가 기대한 것은 아닙니다.\n\n\n\n이제 다음 주제인 → 테마를 다루어볼 시간입니다.\n\n👉 작은 참고사항입니다. Align 작업 구현이 이렇게 보일 것입니다 (텍스트와 동일한 디스패치 명령어 접근 방식):\n\n```js\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {\n    FORMAT_ELEMENT_COMMAND,\n    ElementFormatType,\n    OUTDENT_CONTENT_COMMAND,\n    INDENT_CONTENT_COMMAND\n} from 'lexical';\n\nexport const CustomAlignActions = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (formatType: ElementFormatType) =\u003e {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, formatType)\n    }\n\n    return (\n        \u003cdiv style={marginTop: '10px'}\u003e\n            \u003cspan style={fontWeight: 'bold'}\u003eAlign actions\u003c/span\u003e\n            \u003cdiv\u003e\n                {[\n                    'Left',\n                    'Center',\n                    'Right',\n                    'Justify',\n                ].map(value =\u003e {\n                    return (\n                        \u003cbutton\n                            onClick={() =\u003e handleOnClick(value.toLowerCase() as ElementFormatType)}\u003e\n                            {value}\n                        \u003c/button\u003e\n                    )\n                })}\n                \u003cbutton\n                    onClick={() =\u003e editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined)}\u003e\n                    Outdent\n                \u003c/button\u003e\n                \u003cbutton\n                    onClick={() =\u003e editor.dispatchCommand(INDENT_CONTENT_COMMAND, undefined)}\u003e\n                    Indent\n                \u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_7.png)\n\n\n\n위의 경우 \"정당화\" 노드가 편집기 상태 JSON에서 어떻게 나타낼지에 대한 예시입니다:\n\n```js\n{\n  \"children\": [\n    {\n      \"detail\": 0,\n      \"format\": 1,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \"Justify\",\n      \"type\": \"text\",\n      \"version\": 1\n    },\n    {\n      \"detail\": 0,\n      \"format\": 0,\n      \"mode\": \"normal\",\n      \"style\": \"\",\n      \"text\": \" - Lorem ipsum dolor sit amet, \u003c...\u003e\",\n      \"type\": \"text\",\n      \"version\": 1\n    }\n  ],\n  \"direction\": \"ltr\",\n  \"format\": \"justify\",\n  \"indent\": 0,\n  \"type\": \"paragraph\",\n  \"version\": 1\n}\n```\n\n# 테마\n\nNodes를 수정할 때, lexical은 테마 객체 theme.[`노드-타입`]에서 지정된 노드 타입에 대해 스타일(클래스 이름)을 적용합니다.\n\n\n\n해달 코드를 추가하고 텍스트 스타일을 적용해 보겠습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions\n } from \"./components\";\n import initialState from './initialState.json';\n+import './App.css'\n \n export const App: React.FC = () =\u003e {\n \n@@ -38,6 +39,18 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        theme: {\n+            text: {\n+                bold: \"text-bold\",\n+                italic: \"text-italic\",\n+                underline: \"text-underline\",\n+                code: 'text-code',\n+                highlight: 'text-highlight',\n+                strikethrough: 'text-strikethrough',\n+                subscript: 'text-subscript',\n+                superscript: 'text-superscript',\n+            },\n+        },\n         onError: (e) =\u003e {\n             console.log('ERROR:', e)\n         },\n```\n\nCSS:\n\n```js\n.text-bold {\n    font-weight: bold;\n}\n\n.text-italic {\n    font-style: italic;\n}\n\n.text-underline {\n    text-decoration: underline;\n}\n\n.text-code {\n    background-color: #f0f2f5;\n    padding: 1px 0.25rem;\n    font-family: Menlo, Consolas, Monaco, monospace;\n    font-size: 94%;\n}\n\n.text-highlight {\n    margin: 0 5px;\n}\n\n.text-strikethrough {\n    text-decoration: line-through;\n}\n\n.text-subscript {\n    vertical-align: sub;\n}\n\n.text-superscript {\n    vertical-align: super;\n}\n\np {\n    margin: 0;\n}\n```\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1260/1*_KW7zAxitBpOe3HrAqHHfw.gif)\n\n![image](/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_8.png)\n\n**Bold**\n*Italic*\n\u003cins\u003eUnderline\u003c/ins\u003e\n`Code`\n\u003cmark\u003eHighlight\u003c/mark\u003e\n~~Strike~~\nX\u003csub\u003eSub\u003c/sub\u003e\nX\u003csup\u003eSuper\u003c/sup\u003e\n\u003cmark\u003e\u003cstrong\u003e\u003cem\u003e\u003cins\u003e\u003cu\u003e\u003cstrike\u003e\u003csub\u003eAll of them\u003c/sub\u003e\u003c/strike\u003e\u003c/u\u003e\u003c/ins\u003e\u003c/em\u003e\u003c/strong\u003e\u003c/mark\u003e\n\n\n\n\n알겠지만, 우리가 디스패치를 트리거할 때마다, 렉시컬이 클래스를 교체하지 않고, 있는 경우 추가하거나 있는 경우 제거했습니다. 이 점을 명심해주세요. \"굵게 기울임체 밑줄\"에 대해 별도의 CSS 클래스를 만들 필요가 없습니다.\n\n에디터의 상태 JSON:\n\n```js\n{\n  \"root\": {\n    \"children\": [\n      {\n        \"children\": [\n          {\n            \"detail\": 0,\n            \"format\": 11,\n            \"mode\": \"normal\",\n            \"style\": \"\",\n            \"text\": \"굵게 기울임체 밑줄\",\n            \"type\": \"text\",\n            \"version\": 1\n          }\n        ],\n        \"direction\": \"ltr\",\n        \"format\": \"\",\n        \"indent\": 0,\n        \"type\": \"paragraph\",\n        \"version\": 1\n      }\n    ],\n    \"direction\": \"ltr\",\n    \"format\": \"\",\n    \"indent\": 0,\n    \"type\": \"root\",\n    \"version\": 1\n  }\n}\n```\n\n# 헤딩. 헬퍼 및 노드 구성\n\n\n\n등록된 어휘 명령이 없을 경우 어떻게 해야 할까요? 단어 요소(어휘의 기본 노드)를 어휘 명령을 사용하지 않고 헤더 노드로 변환해 봅시다:\n\n```js\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport { $getSelection, $isRangeSelection } from \"lexical\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport { HeadingTagType, $createHeadingNode } from \"@lexical/rich-text\";\n\nexport const CustomHeadingActions = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) =\u003e {\n        editor.update(() =\u003e {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, () =\u003e $createHeadingNode(tag));\n            }\n        });\n    };\n\n    return (\n        \u003cdiv style={{ marginTop: '10px' }}\u003e\n            \u003cspan style={{ fontWeight: 'bold' }}\u003eAlign actions\u003c/span\u003e\n            \u003cdiv\u003e\n                {([\"h1\", \"h2\", \"h3\", \"h4\", \"h5\"] as Array\u003cHeadingTagType\u003e).map((tag) =\u003e {\n                    return (\n                        \u003cbutton\n                            key={tag}\n                            onClick={() =\u003e handleOnClick(tag)}\n                        \u003e\n                            {tag}\n                        \u003c/button\u003e\n                    );\n                })}\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n}\n```\n\n일부 노드를 헤딩 노드로 변환하는 데 미리 정의된 명령이 없기 때문에 여기서는 다음과 같은 작업을 수행합니다:\n\n- 콜백을 인수로 전달하는 editor.update 함수 호출\n- 선택된 노드를 가져오기 위해 $getSelection 헬퍼 사용\n- $isRangeSelection을 사용하여 RangeSelection 유형인지 확인합니다.\n\n\n\n```js\n// 소스코드\nexport function $isRangeSelection(x: unknown): x is RangeSelection {\n  return x instanceof RangeSelection;\n}\n```\n\n4. $setBlocksType을 새로운 $createHeadingNode (h1, h2, h3…)으로 변경하세요;\n\n⚠️ 하지만 앱에서 사용해보면 아무 일도 일어나지 않습니다 → 문단이 헤더로 변경되지 않습니다. 에디터에서 사용하고 싶은 노드에 대해 렉시컬이 알지 못하기 때문입니다 (기본 노드를 제외하고). 노드 구성 배열에 HeaderNode를 추가해야 합니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -10,6 +10,7 @@\n     CustomHistoryActions,\n     CustomAlignActions, CustomHeadingActions\n } from \"./components\";\n+import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n \n@@ -40,6 +41,7 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n+        nodes: [HeadingNode],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_9.png\" /\u003e\n\n# 페이로드와 함께 자신만의 명령어를 생성하는 방법\n\n이전 코드를 다시 작성해 보겠습니다. 다른 곳에서 변환 명령을 호출해야 하는 경우에도 이 조각을 복사-붙여넣기할 필요가 없도록 바꿀 거에요:\n\n```js\neditor.update(() =\u003e {\n    const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, () =\u003e $createHeadingNode(tag));\n      }\n});\n```\n\n\n\n위 작업을 위해 페이로드 `\"h1\" | \"h2\" | \"h3\", ...`을 사용하여 자체 FORMAT_HEADING_COMMAND를 생성하고 등록합니다.\n\n```js\n// src/components/CustomHeadingPlugin/CustomHeadingPlugin.tsx\n\nimport { useEffect } from \"react\";\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\";\nimport {\n    createCommand,\n    $getSelection,\n    $isRangeSelection,\n    COMMAND_PRIORITY_NORMAL,\n} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {\n    HeadingTagType,\n    $createHeadingNode\n} from \"@lexical/rich-text\";\n\nexport const FORMAT_HEADING_COMMAND = createCommand(\"FORMAT_HEADING_COMMAND\");\n\nexport const CustomHeadingPlugin = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    useEffect(() =\u003e {\n        editor.registerCommand\u003cHeadingTagType\u003e(\n            FORMAT_HEADING_COMMAND,\n            (payload) =\u003e {\n                const selection = $getSelection();\n                if ($isRangeSelection(selection)) {\n                    $setBlocksType(selection, () =\u003e $createHeadingNode(payload));\n                }\n                return true;\n            },\n            COMMAND_PRIORITY_NORMAL,\n        );\n    }, []);\n\n    return null;\n}\n```\n\n이제 `CustomHeadingActions/` 구현을 업데이트할 수 있습니다:\n\n```js\nIndex: src/components/CustomHeadingActions/CustomHeadingActions.tsx\n@@ -1,22 +1,15 @@\nimport {\n    useLexicalComposerContext\n} from \"@lexical/react/LexicalComposerContext\";\nimport {HeadingTagType} from \"@lexical/rich-text\";\nimport {FORMAT_HEADING_COMMAND} from \"../CustomHeadingPlugin\";\n\nexport const CustomHeadingActions = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = (tag: HeadingTagType) =\u003e {\n        editor.dispatchCommand(FORMAT_HEADING_COMMAND, tag);\n    };\n\n    return (\n        \u003cdiv style={marginTop: '10px'}\u003e\n```\n\n\n\n이 변형은 내게 훨씬 깔끔하고 재사용 가능해 보여요. 그 이후에는 LexicalComposer의 자식으로 우리가 만든 Header Plugin을 배치해야할거에요:\n\n```js\nIndex: src/App.tsx\n\n@@ -8,8 +8,11 @@\n     OnChangePlugin,\n     CustomTextActions,\n     CustomHistoryActions,\n     CustomAlignActions,\n     CustomHeadingActions,\n+    CustomHeadingPlugin,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n\n@@ -70,7 +74,7 @@\n                 /\u003e\n                 \u003cHistoryPlugin/\u003e\n                 \u003cOnChangePlugin/\u003e\n+                \u003cCustomHeadingPlugin/\u003e\n                 \u003cdiv style={margin: '20px 0px'}\u003e\n                     \u003cCustomHistoryActions/\u003e\n                     \u003cCustomHeadingActions/\n```\n\n👉 참고: 이전에 다뤘지만 다시 한 번 상기시키자면... 테마 구성을 업데이트하여 각 헤딩 엘리먼트에 적용하려는 CSS 클래스 이름을 지정할 수 있어요:\n\n```js\nIndex: src/App.tsx\n\n@@ -62,6 +62,14 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            heading: {\n+                // Flowbite examples: https://flowbite.com/docs/typography/headings/#heading-one-h1\n+                h1: \"text-5xl font-extrabold dark:text-white\",\n+                h2: \"text-4xl font-bold dark:text-white\",\n+                h3: \"text-3xl font-bold dark:text-white\",\n+                h4: \"text-2xl font-bold dark:text-white\",\n+                h5: \"text-xl font-bold dark:text-white\",  \n+            },\n             banner: 'banner'\n         },\n         onError: (e) =\u003e {\n```\n\n\n\n# 커스텀 노드를 만드는 방법\n\n이전 섹션에서는 기본적으로 모든 것을 다루었으니, 이번 섹션에서는 직접 노드를 만들어보겠습니다. 제가 생각하기에 렉시컬이 노드를 처리하는 전체 그림을 파악하게 될 것입니다.\n\n가장 간단한 배너 노드:\n\n```js\nimport {\n    EditorConfig,\n    ElementNode,\n    LexicalEditor,\n    SerializedElementNode,\n    Spread,\n} from \"lexical\";\n\nexport type SerializedBannerNode = Spread\u003c\n    {\n        customValue: string;\n    },\n    SerializedElementNode\n\u003e;\n\nexport class BannerNode extends ElementNode {\n    createDOM(_config: EditorConfig, _editor: LexicalEditor): HTMLElement {\n        const div = document.createElement(\"div\");\n        div.className = _config.theme.banner;\n        return div;\n    }\n\n    static clone(node: BannerNode): BannerNode {\n        return new BannerNode(node.__key);\n    }\n\n    static getType(): string {\n        return \"banner\";\n    }\n\n    /**\n     * Returning false tells Lexical that this node does not need its\n     * DOM element replacing with a new copy from createDOM.\n     */\n    updateDOM(\n        _prevNode: unknown,\n        _dom: HTMLElement,\n        _config: EditorConfig,\n    ): boolean {\n        return false;\n    }\n\n    exportJSON(): SerializedBannerNode {\n        return {\n            type: \"banner\",\n            version: 1,\n            children: [],\n            customValue: \"anything you like\",\n            format: \"\",\n            indent: 1,\n            direction: null,\n        };\n    }\n}\n```\n\n\n\n설명:\n- 새로운 어휘 노드를 만들려면 미리 정의된 어휘 노드(ElementNode | TextNode | DecoratorNode 중 하나를 확장한 클래스를 만들고 메서드를 재정의해야 합니다(모든 메서드를 다루지는 않겠습니다));\n- 먼저, 어휘는 노드의 타입에 대한 일치 항목을 찾으려고 할 것이며, 타입 함수를 호출하여 구성 노드 배열('banner'의 경우)에서 지정한 노드들로부터 getType 함수를 호출할 것입니다;\n- 그 다음으로, 어휘는 HTML 요소를 만드는 createDOM 메서드를 호출할 것입니다;\n- OnChangePlugin에 toJSON 함수가 있는 것을 기억하시나요?\n\n```js\n// src/components/OnChangePlugin/OnChangePlugin.tsx\n\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {useEffect} from \"react\";\n\nexport const OnChangePlugin = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n    useEffect(() =\u003e {\n        return editor.registerUpdateListener((listener) =\u003e {\n            console.log('DATA', listener.editorState.toJSON())\n        });\n    }, [editor]);\n\n    return null;\n}\n```\n\n여기서 우리의 Banner exportJSON 함수가 호출될 것입니다.\n\n\n\n이제 BannerNode를 위한 플러그인을 생성해야 합니다. 이미 Headings 섹션에서 이를 수행한 적이 있습니다:\n\n```js\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {$getSelection, $isRangeSelection, COMMAND_PRIORITY_NORMAL, createCommand} from \"lexical\";\nimport {\n    $setBlocksType\n} from \"@lexical/selection\";\nimport {BannerNode} from \"../../nodes\";\nimport React from \"react\";\n\nexport const $createBannerNode = (): BannerNode =\u003e new BannerNode();\n\nexport const INSERT_BANNER_COMMAND = createCommand(\"create_banner\");\n\nexport const CustomBannerPlugin: React.FC = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    if (!editor.hasNode(BannerNode)) {\n        throw new Error('BannerPlugin: \"BannerNode\" not registered on editor');\n    }\n    editor.registerCommand(\n        INSERT_BANNER_COMMAND,\n        () =\u003e {\n            const selection = $getSelection();\n            if ($isRangeSelection(selection)) {\n                $setBlocksType(selection, $createBannerNode);\n            }\n            return true;\n        },\n        COMMAND_PRIORITY_NORMAL,\n    );\n\n    return null;\n};\n```\n\nCustomBannerActions 컴포넌트를 추가하세요: 우리 명령어와 함께 간단한 버튼이 있습니다:\n\n```js\nimport React from \"react\";\nimport {useLexicalComposerContext} from \"@lexical/react/LexicalComposerContext\";\nimport {INSERT_BANNER_COMMAND} from \"../CustomBannerPlugin\";\n\nexport const CustomBannerActions: React.FC = () =\u003e {\n    const [editor] = useLexicalComposerContext();\n\n    const handleOnClick = () =\u003e {\n        editor.dispatchCommand(INSERT_BANNER_COMMAND, undefined);\n    };\n\n    return (\n        \u003cdiv style={{marginTop: '10px'}}\u003e\n            \u003cspan style={{fontWeight: 'bold'}}\u003eHeading actions\u003c/span\u003e\n            \u003cdiv\u003e\n                \u003cbutton onClick={handleOnClick}\u003e\n                    Banner\n                \u003c/button\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n};\n```\n\n\n\nApp.tsx를 업데이트하였습니다:\n\n```js\nIndex: src/App.tsx\n\n@@ -11,10 +11,13 @@\n     CustomAlignActions,\n     CustomHeadingActions,\n     CustomHeadingPlugin,\n+    CustomBannerPlugin,\n+    CustomBannerActions,\n } from \"./components\";\n import {HeadingNode} from \"@lexical/rich-text\";\n import initialState from './initialState.json';\n import './App.css'\n+import {BannerNode} from \"./nodes\";\n \n export const App: React.FC = () =\u003e {\n \n@@ -43,7 +46,10 @@\n \n     const lexicalConfig: InitialConfigType = {\n         namespace: 'My Rich Text Editor',\n-        nodes: [HeadingNode],\n+        nodes: [\n+            BannerNode,\n+            HeadingNode\n+        ],\n         theme: {\n             text: {\n                 bold: \"text-bold\",\n@@ -55,6 +61,7 @@\n                 subscript: 'text-subscript',\n                 superscript: 'text-superscript',\n             },\n+            banner: 'banner'\n         },\n         onError: (e) =\u003e {\n             console.log('ERROR:', e)\n@@ -75,8 +82,10 @@\n                 \u003cHistoryPlugin/\u003e\n                 \u003cOnChangePlugin/\u003e\n                 \u003cCustomHeadingPlugin/\u003e\n+                \u003cCustomBannerPlugin/\u003e\n                 \u003cdiv style={margin: '20px 0px'}\u003e\n                     \u003cCustomHistoryActions/\u003e\n+                    \u003cCustomBannerActions/\u003e\n                     \u003cCustomHeadingActions/\u003e\n                     \u003cCustomTextActions/\u003e\n                     \u003cCustomAlignActions/\u003e\n```\n\nCSS:\n\n```js\nIndex: src/App.css\n\n@@ -33,6 +33,13 @@\n     vertical-align: super ;\n }\n \n+.banner {\n+    border-left: 3px coral solid;\n+    background-color: lightskyblue;\n+    border-radius: 3px;\n+    padding: 10px 0;\n+}\n+\n p {\n     margin: 0;\n }\n```\n\n\n\n결과:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1334/1*zesdcbkZmVlSoY1HaflYUA.gif\" /\u003e\n\n🔴 문제가 두 가지 있을 것입니다:\n\n- 사용자가 Enter 키 또는 Shift+Enter 키를 눌러 노드에서 \"나가기\"를 할 수 없을 것입니다.\n- 사용자가 Backspace 키를 눌러 노드를 \"제거\"할 수 없을 것입니다.\n\n\n\n우리의 BannerNode를 업데이트해 봅시다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -2,6 +2,9 @@\n     EditorConfig,\n     ElementNode,\n     LexicalEditor,\n+    $createParagraphNode,\n+    LexicalNode,\n+    RangeSelection,\n     SerializedElementNode,\n     Spread,\n } from \"lexical\";\n@@ -40,6 +43,34 @@\n         return false;\n     }\n\n+    /**\n+     * 사용자가 모든 콘텐츠를 삭제할 때 노드를 단락으로 설정해야 합니다\n+     */\n+    collapseAtStart(_: RangeSelection): boolean {\n+        const paragraph = $createParagraphNode();\n+        const children = this.getChildren();\n+        children.forEach((child) =\u003e paragraph.append(child));\n+        this.replace(paragraph);\n+\n+        return true;\n+    }\n+\n+    /**\n+     * 사용자가 Enter 키를 누를 때 노드를 단락으로 설정해야 합니다.\n+     * Shift+Enter를 누를 경우 노드는 유지됩니다\n+     */\n+    insertNewAfter(\n+        _: RangeSelection,\n+        restoreSelection?: boolean,\n+    ): LexicalNode | null {\n+        const paragraph = $createParagraphNode();\n+        const direction = this.getDirection();\n+        paragraph.setDirection(direction);\n+        this.insertAfter(paragraph, restoreSelection);\n+\n+        return paragraph;\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n지금까지 얻은 것을 확인해 보겠습니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1334/1*44Wg5Stz5crAXpP3Qi-PRA.gif\" /\u003e\n\n\n\n🟢 업데이트 후:\n\n- 사용자는 노드에서 Enter 키를 눌러 \"나가기\" 할 수 있습니다;\n- 사용자는 노드를 Shift + Enter 키를 눌러 \"확장\"할 수 있습니다;\n- 사용자는 콘텐츠 텍스트가 비어 있을 때 Backspace 키를 눌러 노드를 \"삭제\"할 수 있습니다;\n\n마지막으로, 에디터의 JSON 트리에서 BannerNode을 파싱하는 함수가 필요합니다:\n\n```js\nIndex: src/nodes/BannerNode/BannerNode.tsx\n\n@@ -71,6 +71,10 @@\n         return paragraph;\n     }\n \n+    static importJSON(_: SerializedBannerNode): BannerNode {\n+        return new BannerNode();\n+    }\n+\n     exportJSON(): SerializedBannerNode {\n         return {\n             type: \"banner\",\n```\n\n\n\n# 깃허브 리포지토리:\n\n관련된 기사들:\n\n이 글이 도움이 되었기를 바랍니다. 만약 그렇다면, \"claps\"를 주시면 감사하겠습니다.\n\n# 간단히 설명\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 칭찬하고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터, 링크드인, 유튜브, 그리고 디스코드에서 저희를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithLexicalRichTextEditorforReact_0.png","tag":["Tech"],"readingTime":31},{"title":"리액트와 ASPNet Core 웹 API를 사용한 Full Stack CRUD 애플리케이션 개발하기","description":"","date":"2024-05-14 10:58","slug":"2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI","content":"\n\n리액트를 사용하여 ASP.NET Core 웹 API와 함께 전체 스택 CRUD 애플리케이션을 만드는 것은 강력한 방법입니다. 견고하고 효율적인 웹 애플리케이션을 개발하는 데 도움이 됩니다. 이 안내서에서는 CRUD 작업의 기본 원리를 탐구하고 React 프론트엔드와 ASP.NET Core 웹 API 백엔드를 설정하고 연결하는 단계별 프로세스를 살펴볼 것입니다. 각 계층의 복잡성과 상호 작용을 이해하여 개발자는 확장 가능하고 효율적인 전체 스택 애플리케이션을 구축하는 데 능숙해질 수 있습니다.\n\n# 전체 스택 CRUD 애플리케이션 소개\n\n전체 스택 CRUD (생성, 읽기, 업데이트, 삭제) 애플리케이션을 만드는 것은 프론트엔드와 백엔드 구성 요소 모두를 데이터베이스와 상호 작용하도록 구축하는 것을 포함합니다. 이를 통해 사용자는 기본적인 데이터베이스 작업을 원활하게 수행할 수 있습니다.\n\n# CRUD 작업 이해\n\n\n\n데이터베이스 작업시 사용되는 기본 작업은 CRUD 연산입니다. Create는 새 데이터를 추가하고, Read는 기존 데이터를 검색하며, Update는 데이터를 수정하고, Delete는 데이터를 삭제합니다. 이러한 작업들은 상호 작용하는 애플리케이션의 기본을 형성합니다.\n\nASP.Net Core Web API 백엔드 개발\n\nASP.Net Core Web API를 사용하여 백엔드를 구축하는 것은 데이터 작업을 처리하고 프론트엔드 애플리케이션과 상호 작용하는 견고한 기반을 만드는 것을 의미합니다.\n\n먼저 시작하기 위해 먼저 Visual Studio에서 필요한 종속성을 설치해야 합니다. 이를 위해 Tools-`NuGet Package Manager-` Manage Nuget Packages for solution로 이동해야 합니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png)\n\n\n그러고 나서 이 패키지들을 모두 설치하세요,\n\n- Microsoft.EntityFrameworkCore.Design\n- Microsoft.EntityFrameworkCore.SqlServer\n- Microsoft.EntityFrameworkCore.Tools\n- Newtonsoft.Json\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_1.png)\n\n\n\n\n첫 번째 단계로 모델 폴더를 선택한 후에 마우스 오른쪽 단추를 클릭하여 Student.cs 클래스를 만드세요.\n\n## Student.cs\n\n```js\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ReactASPCrud.Models\n{\n    public class Student\n    {\n\n    [Key] // 이것을 추가한 후에 위 라이브러리(DataAnnotations)가 자동으로 작성됩니다.\n    public int id { get; set; }\n    public string stname { get; set; }\n\n    public string course { get; set; }\n\n    }\n}\n```\n\n## StudentDbContext.cs\n\n\n\n```cs\nusing Microsoft.EntityFrameworkCore;\n\nnamespace ReactASPCrud.Models\n{\n    public class StudentDbContext : DbContext\n    {\n\n        public StudentDbContext(DbContextOptions\u003cStudentDbContext\u003e options) : base(options) \n        {\n        \n        }\n    \n        public DbSet\u003cStudent\u003e Students { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseSqlServer(\"Data Source=.; initial Catalog=lbs;User Id=test; password=123; TrustServerCertificate= True\");\n        }\n\n    }\n}\n```\n\n이곳에 SQL 인증을 추가하는 대신, 위의 OnConfiguring 메소드에 아래 코드를 사용하여 Windows 인증을 적용할 수 있습니다. (여기서는 id, password를 추가할 필요가 없습니다)\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_2.png)\n\n```js\nData Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\n```\n\n\n\n- 데이터 원본 = DIVANI\\SQLEXPRESS: 서버 이름 또는 IP 주소.\n- 데이터베이스 = lbs: 데이터베이스의 이름.\n- 통합 보안 = True: Windows 인증을 사용하여 연결을 인증하는 것을 나타냅니다.\n- 연결 제한 시간 = 30: 연결 제한 시간(초).\n- 암호화 = False: 암호화 비활성화.\n- 서버 인증서 신뢰 = False: 서버 인증서 신뢰.\n- 애플리케이션 의도 = ReadWrite: 읽기 및 쓰기 작업을 위한 의도.\n- 멀티 서브넷 장애 조치 = False: 멀티 서브넷 장애 조치 설정. 이 설정은 클라이언트가 더 나은 오류 허용성을 위해 여러 서브넷을 통해 데이터베이스에 연결할 수 있게 합니다.\n\n데이터베이스 연결 설정하기\n\n다음 내용을 Program.cs 파일에 추가합니다.\n\n```js\nbuilder.Services.AddDbContext\u003cStudentDbContext\u003e(options =\u003e\noptions.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n```\n\n웹 API에 이 권한을 허용하도록 설정하기\n\n```js\napp.UseCors(policy =\u003e policy.AllowAnyHeader()\n.AllowAnyMethod()\n.SetIsOriginAllowed(origin =\u003e true)\n.AllowCredentials());\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\n| Header1 | Header2 | Header3 |\n| ------- | ------- | ------- |\n| Data1   | Data2   | Data3   |\n| Data4   | Data5   | Data6   |\n\n\n이제 위의 코드를 Program.cs 파일 내 어디에 붙여넣어야 하는지 알려줄 거에요.\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 컨테이너에 서비스 추가.\n\nbuilder.Services.AddControllers();\n// 더 자세한 Swagger/OpenAPI 구성 방법은 https://aka.ms/aspnetcore/swashbuckle에서 확인하세요.\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddDbContext\u003cStudentDbContext\u003e(options =\u003e\n   options.UseSqlServer(builder.Configuration.GetConnectionString(\"StudentDbContext\")));\n\nvar app = builder.Build();\napp.UseCors(policy =\u003e policy.AllowAnyHeader()\n                            .AllowAnyMethod()\n                            .SetIsOriginAllowed(origin =\u003e true)\n                            .AllowCredentials());\n\n// HTTP 요청 파이프라인 구성.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.Run();\n```\n\n이제 appsettings.json 파일에 연결 문자열을 추가하세요.\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"StudentDbContext\": \"Data Source=DIVANI\\SQLEXPRESS;Database=lbs;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=False;ApplicationIntent=ReadWrite;MultiSubnetFailover=False\"\n  }\n}\n```\n\n\n\n그 후에 도구-`NuGet 패키지 관리자-`패키지 관리자 콘솔로 이동하여 아래 명령어를 추가하십시오:\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_3.png)\n\nadd-migration initial\n\nupdate-database\n\n\n\n마이그레이션 파일을 생성하고 나서 데이터베이스가 만들어졌습니다. SQL Server를 열어서 데이터베이스가 생성되었는지 확인해보세요. 동시에 프로젝트에 마이그레이션 폴더가 생성되어 있습니다. 해당 폴더를 확인할 수 있습니다.\n\n이제 SQL Server를 통해 추가되었는지 확인할 수 있습니다.\n\n![이미지 1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_4.png)\n\n![이미지 2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_5.png)\n\n\n\n이후에 Controller 폴더를 선택하고 Web API로 Student Controller를 생성하세요.\n\n![이미지1](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_6.png)\n\n![이미지2](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_7.png)\n\n![이미지3](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_8.png)\n\n\n\n이제 StudentController.cs 파일에 API를 만들어야 합니다.\n\n여기서 API 내에서 CRUD 작업을 처리하기 위한 엔드포인트를 생성할 것입니다. POST, GET, PUT 및 DELETE와 같은 HTTP 동사를 사용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 메서드를 구현할 것입니다.\n\n## StudentController.cs\n\n```csharp\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing ReactAspCrud.Models;\n\nnamespace ReactAspCrud.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class StudentController : ControllerBase\n    {\n        private readonly StudentDbContext _studentDbContext;\n\n        public StudentController(StudentDbContext studentDbContext)\n        {\n            _studentDbContext = studentDbContext;\n        }\n\n        [HttpGet]\n        [Route(\"GetStudent\")]\n        public async Task\u003cIEnumerable\u003cStudent\u003e\u003e GetStudents()\n        {\n            return await _studentDbContext.Student.ToListAsync();\n        }\n\n        [HttpPost]\n        [Route(\"AddStudent\")]\n        public async Task\u003cStudent\u003e AddStudent(Student objStudent)\n        {\n            _studentDbContext.Student.Add(objStudent);\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpPatch]\n        [Route(\"UpdateStudent/{id}\")]\n        public async Task\u003cStudent\u003e UpdateStudent(Student objStudent)\n        {\n            _studentDbContext.Entry(objStudent).State= EntityState.Modified;\n            await _studentDbContext.SaveChangesAsync();\n            return objStudent;\n        }\n\n        [HttpDelete]\n        [Route(\"DeleteStudent/{id}\")]\n        public bool DeleteStudent(int id) \n        {\n            bool a = false;\n            var student = _studentDbContext.Student.Find(id);\n            if (student != null)\n            {\n                a = true;\n                _studentDbContext.Entry(student).State= EntityState.Deleted;\n                _studentDbContext.SaveChanges();\n            }\n            else\n            {\n                a = false;\n            }\n            return a;\n        }\n    }\n}\n```\n\n\n\n프로그램을 실행한 후 Swagger를 통해 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_9.png)\n\n값을 실행하여 각 API 컨트롤러가 작동하는지 확인하세요.\n\n# 어플리케이션을 위한 React Frontend 설정\n\n\n\n이제 백엔드 개발 부분을 이미 마무리했군요.\n\n이제 프론트엔드 개발 부분으로 넘어가 볼까요?\n\n먼저, 관련 경로 내에서 React 앱을 생성해야 합니다.\n\n![React app 생성](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_10.png)\n\n\n\n그럼 명령 프롬프트에 다음 명령을 입력해야 해요:\n\nnpx create-react-app my-app\ncd my-app\n\nReact 프로젝트를 VS code 편집기에서 열고 React 앱을 실행하려면 이 명령을 추가하세요,\n\ncode .\nnpm start\n\n\n\n이제 React 환영 페이지를 보실 수 있습니다.\n\n그 후 다음 명령어를 입력하여 Bootstrap을 설치하십시오.\n\nnpm i bootstrap\n\n그 후 다음 명령어를 입력하여 axios를 설치하십시오.\n\n\n\nnpm i axios\n\nVS code에서 프로젝트를 열고 아래 코드를 추가하세요,\n\n## App.js\n\n```js\nimport './App.css';\nimport StudentCrud from './components/StudentCrud';\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003cStudentCrud/\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\n\n새 폴더(components)를 만든 후, 그 안에 StudentCrud.js 파일을 생성하고 아래 코드를 추가해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_11.png\" /\u003e\n\n## StudentCrud.js\n\n```js\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\n\nfunction StudentCrud(){\n\nconst [id, setId] = useState(\"\");\nconst [stname, setName] = useState(\"\");\nconst [course, setCourse] = useState(\"\");\nconst [students, setUsers] = useState([]);\n\n  useEffect(() =\u003e {\n    (async () =\u003e await Load())();\n  }, []);\n\n  async function Load() {\n\n    const result = await axios.get(\"https://localhost:7135/api/Student/GetStudent\");\n    setUsers(result.data);\n    console.log(result.data);\n  }\n\n  async function save(event) {\n\n    event.preventDefault();\n    try {\n      await axios.post(\"https://localhost:7135/api/Student/AddStudent\", {\n\n        stname: stname,\n        course: course,\n\n      });\n      alert(\"학생 등록 성공\");\n          setId(\"\");\n          setName(\"\");\n          setCourse(\"\");\n\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n  async function editStudent(students) {\n    setName(students.stname);\n    setCourse(students.course);\n\n\n    setId(students.id);\n  }\n\n  async function DeleteStudent(id) {\n\n  await axios.delete(\"https://localhost:7135/api/Student/UpdateStudent/\" + id);\n  alert(\"학생이 성공적으로 삭제되었습니다\");\n  setId(\"\");\n  setName(\"\");\n  setCourse(\"\");\n  Load();\n  }\n\n  async function update(event) {\n    event.preventDefault();\n    try {\n      //this is API handling the path\n  await axios.patch(\"https://localhost:7135/api/Student/UpdateStudent/\"+ students.find((u) =\u003e u.id === id).id || id,\n        {\n        id: id,\n        stname: stname,\n        course: course,\n        }\n      );\n      alert(\"등록이 업데이트되었습니다\");\n      setId(\"\");\n      setName(\"\");\n      setCourse(\"\");\n\n      Load();\n    } catch (err) {\n      alert(err);\n    }\n  }\n\n\nreturn(\n //student form\n\u003cdiv\u003e\n\u003ch1\u003e학생 세부 정보\u003c/h1\u003e\n      \u003cdiv class=\"container mt-4\"\u003e\n        \u003cform\u003e\n          \u003cdiv class=\"form-group\"\u003e\n\n            \u003cinput\n              type=\"text\"\n              class=\"form-control\"\n              id=\"id\"\n              hidden\n              value={id}\n              onChange={(event) =\u003e {\n                setId(event.target.value);\n              }\n            /\u003e\n            \u003clabel\u003e학생 이름\u003c/label\u003e\n            \u003cinput\n              type=\"text\"\n              class=\"form-control\"\n              id=\"stname\"\n              value={stname}\n              onChange={(event) =\u003e {\n                setName(event.target.value);\n              }\n            /\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"form-group\"\u003e\n            \u003clabel\u003e과정\u003c/label\u003e\n            \u003cinput\n              type=\"text\"\n              class=\"form-control\"\n              id=\"course\"\n              value={course}\n              onChange={(event) =\u003e {\n                setCourse(event.target.value);\n              }\n            /\u003e\n          \u003c/div\u003e\n          \u003cdiv\u003e\n            \u003cbutton class=\"btn btn-primary mt-4\" onClick={save}\u003e\n              등록\n            \u003c/button\u003e\n            \u003cbutton class=\"btn btn-warning mt-4\" onClick={update}\u003e\n              업데이트\n            \u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/form\u003e\n      \u003c/div\u003e\n      \u003cbr\u003e\u003c/br\u003e\n\n\n      \u003ctable class=\"table table-dark\" align=\"center\"\u003e\n        \u003cthead\u003e\n          \u003ctr\u003e\n            \u003cth scope=\"col\"\u003e학생 아이디\u003c/th\u003e\n            \u003cth scope=\"col\"\u003e학생 이름\u003c/th\u003e\n            \u003cth scope=\"col\"\u003e과정\u003c/th\u003e\n\n            \u003cth scope=\"col\"\u003e옵션\u003c/th\u003e\n          \u003c/tr\u003e\n        \u003c/thead\u003e\n        {students.map(function fn(student) {\n          return (\n            \u003ctbody\u003e\n              \u003ctr\u003e\n                \u003cth scope=\"row\"\u003e{student.id} \u003c/th\u003e\n                \u003ctd\u003e{student.stname}\u003c/td\u003e\n                \u003ctd\u003e{student.course}\u003c/td\u003e\n\n                \u003ctd\u003e\n                  \u003cbutton\n                    type=\"button\"\n                    class=\"btn btn-warning\"\n                    onClick={() =\u003e editStudent(student)}\n                  \u003e\n                    편집\n                  \u003c/button\u003e\n                  \u003cbutton\n                    type=\"button\"\n                    class=\"btn btn-danger\"\n                    onClick={() =\u003e DeleteStudent(student.id)}\n                  \u003e\n                    삭제\n                  \u003c/button\u003e\n                \u003c/td\u003e\n              \u003c/tr\u003e\n            \u003c/tbody\u003e\n          );\n        })}\n      \u003c/table\u003e\n\u003c/div\u003e\n);\n}\n\nexport default StudentCrud;\n```\n\n\n\n프론트엔드와 백엔드 간 통신 수립하기\nReact 프론트엔드와 ASP.Net Core 웹 API 백엔드가 준비되었습니다. 이제 이들끼리 소통할 시간이에요. 이 디지털 소개팅을 설정하고 둘 사이에 원활한 통신 경로를 수립해봅시다.\n\nReact 컴포넌트에서 API 엔드포인트 사용하기\nReact 컴포넌트들은 마치 만물뷔페에서 배고픈 십대처럼, ASP.Net Core 웹 API에서 제공하는 API 엔드포인트를 소비하기를 열망하고 있습니다. 백엔드에서 데이터를 컴포넌트에 공급하는 방법을 배워서 UI를 기쁘게 춤추게 해보세요.\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_12.png)\n\n따라서 백엔드 코드를 실행한 후, StudentCrud.js 파일의 해당 위치에 각 웹 API 규칙에 대한 요청 URL을 추가하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_13.png)\n\n데이터 응답 및 오류 처리\n가끔 데이터가 마치 부드러운 시냇물처럼 매끈하게 흘러들어오지만, 때로는 오류가 예기치 못하게 파티에 뜬금 없이 나타나는 손님처럼 발생하기도 합니다. 전문가처럼 데이터 응답을 우아하게 처리하고 문제를 해결하는 방법을 발견하여 응용 프로그램이 매끈하게 실행되도록 유지해보세요.\n\n# 전체 스택 CRUD 애플리케이션 테스트 및 디버깅\n\nReact 컴포넌트의 유닛 테스트\n우리의 React 컴포넌트를 현미경 아래 두고 연구실 쥐처럼 테스트해보겠습니다(하지만 더 정성을 다하면서요). 각 컴포넌트가 훌륭하게 역할을 수행하고 그 귀찮은 버그를 피하여 사용자 경험을 망가뜨리는 일을 방지하는 방법을 배워보세요.\n\n\n\nAPI 엔드포인트의 통합 테스트\n탐정 모자를 살 때입니다. API 엔드포인트의 동작을 조사해보세요. 통합 테스트를 통해 백엔드 서비스가 정확히 응답하고 프론트엔드와 잘 작동하는지 확인할 수 있습니다. 셜록 홈즈가 자랑스러워할 것입니다.\n\n크로스 플랫폼 문제 해결\n크로스 플랫폼 개발의 기쁨입니다. 다양한 브라우저에서 다양한 디바이스로, 이러한 문제를 해결하고 디버그하는 방법을 탐색해보세요. 이 문제들은 어플리케이션이 이상하게 작동하게 할 수 있습니다.\n\n# 배포 및 유지보수 고려 사항\n\n배포를 위한 애플리케이션 준비\n쇼타임입니다! 풀 스택 CRUD 애플리케이션을 인터넷의 넓은 세계에 배포하기 위한 필수 단계를 배워보세요. 설정에서 최적화까지, 앱을 큰 무대에서 빛나게 할 준비를 해보세요.\n\n\n\n애플리케이션 확장 전략\n애플리케이션이 인기를 얻게 되면 확장이 매우 중요해집니다. 전체 스택 애플리케이션을 효율적으로 확장할 수 있는 전략을 알아보세요. 이를 통해 향후 증가하는 트래픽을 처리하고 최적 성능을 유지할 수 있습니다. 디지털 성장 분기점을 대비하는 것으로 생각해보세요.\n\n모니터링 및 유지보수 최고의 실천법\n애플리케이션이 러브 상태가 되면 일은 끝나지 않습니다. 애플리케이션 성능을 모니터링하고 사용자 행동을 추적하며 유지보수 루틴을 실행하는 최고의 실천법을 살펴보세요. 모든 것이 원활히 작동되도록 하기 위해 앱에 정기적인 건강 진단을 하는 느낌이죠.\n\n결론적으로, ASP.Net Core Web API를 사용한 React를 이용한 Full Stack CRUD 애플리케이션 작성에 숙달하면 다재다능하고 반응 좋은 웹 애플리케이션을 개발하고자 하는 개발자들에게 다양한 기회를 제공해줍니다. 이 기사에서 제시된 지침을 따르면 두 기술의 장점을 활용하여 사용자 경험을 원활하게 만들고 프로젝트에서 혁신을 이끌어낼 수 있습니다. 풀 스택 개발의 잠재력을 받아들이고 늘 새로운 방법을 탐구하여 기술을 향상시키고 디지털 환경의 변화하는 경험을 만들어보세요.\n\n# FAQ\n\n# 1. 풀 스택 CRUD 애플리케이션이란 무엇인가요?\n\n\n\n풀 스택 CRUD 애플리케이션은 프론트엔드 및 백엔드 기술을 이용하여 데이터를 생성, 읽기, 업데이트 및 삭제하는 웹 애플리케이션입니다. 일반적으로 사용자 인터페이스를 위한 프론트엔드 프레임워크와 데이터 및 비즈니스 로직을 관리하는 백엔드 시스템으로 구성됩니다.\n\n## 2. 이 안내를 따르려면 React 및 ASP.Net Core 이전 경험이 필요한가요?\n\nReact와 ASP.Net Core의 이전 경험이 도움이 될 수 있지만, 이 안내서는 초보자를 위한 단계별 접근 방식을 제공하도록 구성되어 있습니다. JavaScript와 C#의 기본 지식이 도움이 될 것이나, 설명과 코드 샘플은 모든 개발자 수준에게 접근하기 쉽도록 하고 있습니다.\n\n## 3. 완료 후 풀 스택 CRUD 애플리케이션을 어떻게 배포할 수 있나요?\n\n\n\n애플리케이션을 배포하는 것은 프론트엔드와 백엔드 구성 요소를 서버에 호스팅하는 과정을 말합니다. React 프론트엔드의 경우, Netlify 또는 Vercel과 같은 플랫폼에 배포할 수 있습니다. ASP.Net Core Web API 백엔드는 Azure, AWS 또는 온프레미스 서버와 같은 서비스에 호스팅할 수 있습니다. 호스팅 환경에 따라 배포 과정이 달라질 수 있습니다.\n\n# 4. 최고의 API 문서 작성 도구는 무엇인가요?\n\n- Swagger\n- Postman\n- Readme\n- Stoplight\n- Redocly\n- Document360","ogImage":{"url":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingFullStackCrudApplicationusingReactwithASPNetCoreWebAPI_0.png","tag":["Tech"],"readingTime":16}],"page":"63","totalPageCount":99,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"63"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>