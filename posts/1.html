<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="안드로이드 14 포어그라운드 서비스 가이드" href="/post/2024-07-01-GuidetoForegroundServicesonAndroid14"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 14 포어그라운드 서비스 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 14 포어그라운드 서비스 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">안드로이드 14 포어그라운드 서비스 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Staff 레벨에서 인터뷰 준비하는 방법" href="/post/2024-07-01-InterviewingatStafflevel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Staff 레벨에서 인터뷰 준비하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-InterviewingatStafflevel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Staff 레벨에서 인터뷰 준비하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Staff 레벨에서 인터뷰 준비하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Xcode 16에 새로 추가된 기능은" href="/post/2024-07-01-WhatsNewinXcode16"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Xcode 16에 새로 추가된 기능은" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-WhatsNewinXcode16_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Xcode 16에 새로 추가된 기능은" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Xcode 16에 새로 추가된 기능은</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 차트 쉽게 만드는 방법" href="/post/2024-07-01-IntroductiontoChartsinSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 차트 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 차트 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">SwiftUI에서 차트 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이렇게 파이썬 함수 작성 안 하면 PR 거부할 거야" href="/post/2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이렇게 파이썬 함수 작성 안 하면 PR 거부할 거야" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이렇게 파이썬 함수 작성 안 하면 PR 거부할 거야" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이렇게 파이썬 함수 작성 안 하면 PR 거부할 거야</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GitHub Copilot, 이제 라이브 코딩 인터뷰가 필요 없을까" href="/post/2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GitHub Copilot, 이제 라이브 코딩 인터뷰가 필요 없을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GitHub Copilot, 이제 라이브 코딩 인터뷰가 필요 없을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">GitHub Copilot, 이제 라이브 코딩 인터뷰가 필요 없을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose로 안드로이드 카운트다운 스낵바 만드는 방법" href="/post/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose로 안드로이드 카운트다운 스낵바 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose로 안드로이드 카운트다운 스낵바 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Jetpack Compose로 안드로이드 카운트다운 스낵바 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법" href="/post/2024-07-01-DotDashDesign"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-DotDashDesign_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Winglang으로 클라우드 마이그레이션 하기 파트 1" href="/post/2024-07-01-PortedtoCloudwithWinglangPartOne"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Winglang으로 클라우드 마이그레이션 하기 파트 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Winglang으로 클라우드 마이그레이션 하기 파트 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Winglang으로 클라우드 마이그레이션 하기 파트 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">31<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 초보자를 위한 테스트 및 디버깅 가이드" href="/post/2024-07-01-FlutterTestingandDebuggingABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 초보자를 위한 테스트 및 디버깅 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-FlutterTestingandDebuggingABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 초보자를 위한 테스트 및 디버깅 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Flutter 초보자를 위한 테스트 및 디버깅 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">3 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"안드로이드 14 포어그라운드 서비스 가이드","description":"","date":"2024-07-01 20:13","slug":"2024-07-01-GuidetoForegroundServicesonAndroid14","content":"\n\n안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.\n\n또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.\n\n이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.\n\n![Foreground Services on Android 14](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 포그라운드 서비스란 무엇인가요?\n\n포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.\n\n포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:\n\n- 사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),\n- 폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),\n- 운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 포그라운드 서비스 유형\n\nAndroid 10에서는 `service` 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.\n\nAndroid 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.\n\n현재 지원되는 유형은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때\n- connectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때\n- dataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함\n- health (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용\n- 위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이\n- mediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때\n- mediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때\n- 마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때\n- phoneCall — 계속 중인 통화를 할 때\n- remoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때\n- shortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능\n- specialUse — 다른 유형이 사용 사례를 수용하지 못할 때\n- systemExempted — 시스템 앱을 위해 예약\n\n백그라운드 서비스 유형 선언\nAndroid 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.\n\n서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:\n\n```js\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...\u003e\n    \u003cservice\n        android:name=\".MyForegroundService\"\n        android:foregroundServiceType=\"camera|location|microphone\"\n        android:exported=\"false\"\u003e\n    \u003c/service\u003e\n\u003c/manifest\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.\n\n## 특정 foreground service 권한 요청\n\nAndroid 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.\n\n```js\n\u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAndroid 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.\n\n```js\n\u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE\"/\u003e\n```\n\n만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.\n\n두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\njava.lang.SecurityException: \n     Permission Denial: startForeground from pid=8589, uid=10623 \n     requires android.permission.FOREGROUND_SERVICE\n\nor\n\njava.lang.SecurityException: \n     Starting FGS with type mediaPlayback targetSDK=34 \n     requires permissions: \n        all of the permissions allOf=true \n        [android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK]\n```\n\n## startForeground() 함수에서 서비스 유형 지정\n\nmanifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.\n\n서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.\n\n```js\nServiceCompat.startForeground(\n    this,\n    id,\n    notification,\n    if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.R) {\n        ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK\n    } else {\n        0\n    }\n)\n```\n\nforegroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:\n\n```js\nandroid.app.InvalidForegroundServiceTypeException: \n  Starting FGS with type none \n  targetSDK=34 has been prohibited\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:\n\n```js\njava.lang.IllegalArgumentException: \n  foregroundServiceType 0x00000002 is not a subset of \n  foregroundServiceType attribute 0x00000000 in service \n  element of manifest file\n```\n\n```js\nandroid.app.ForegroundServiceDidNotStartInTimeException: \n  Context.startForegroundService() did not then call Service.startForeground()\n```\n\n## 런타임 권한 요청하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.\n\n예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.\n\n그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.\n\n- 매니페스트에 다음 중 하나 이상의 권한을 선언:\n- CHANGE_NETWORK_STATE\n- CHANGE_WIFI_STATE\n- CHANGE_WIFI_MULTICAST_STATE\n- NFC\n- TRANSMIT_IR\n- 다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:\n- BLUETOOTH_CONNECT\n- BLUETOOTH_ADVERTICE\n- BLUETOOTH_SCAN\n- UWB_RANGING\n- UsbManager.requestPermission() 호출하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.\n\n```js\nStarting FGS with type connectedDevice targetSDK=34 requires permissions: \n- all of the permissions allOf=true \n  - [android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE] \n- any of the permissions allOf=false \n  - [android.permission.BLUETOOTH_ADVERTISE, \n     android.permission.BLUETOOTH_CONNECT, \n     android.permission.BLUETOOTH_SCAN, \n     android.permission.CHANGE_NETWORK_STATE, \n     android.permission.CHANGE_WIFI_STATE, \n     android.permission.CHANGE_WIFI_MULTICAST_STATE, \n     android.permission.NFC, \n     android.permission.TRANSMIT_IR, \n     android.permission.UWB_RANGING, \n     USB Device, \n     USB Accessory]\n```\n\n## 알림이 올바르게 설정되어 있는지 확인해주세요\n\n백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- POST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png)\n\n- 권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.\n- 알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Google Play 콘솔의 사용 사례에 대한 세부 정보 제공\n\nGoogle Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.\n\nGoogle은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.\n\n선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.\n- 시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.\n- 각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.\n- 각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.\n\n## 삼성 기기를 위한 개선 사항\n\n삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 인용문이 있습니다:\n\n# 샘플 앱\n\n안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:\n\n- 위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작\n- 서비스 시작 전에 위치 권한 요청\n- Activity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신\n- 액티비티에서 서비스 중지\n- 포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.\n\n새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.\n\n이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자원:\n\n- https://developer.android.com/develop/background-work/services/foreground-services — foreground 서비스에 대한 공식 문서\n- https://developer.android.com/about/versions/14/changes/fgs-types-required — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.\n- https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/ — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.\n\n참고 자료:\n\n- [1] https://www.demandsage.com/android-statistics/\n- [2] https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html","ogImage":{"url":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png"},"coverImage":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png","tag":["Tech"],"readingTime":9},{"title":"Staff 레벨에서 인터뷰 준비하는 방법","description":"","date":"2024-07-01 20:11","slug":"2024-07-01-InterviewingatStafflevel","content":"\n\nStaff+ Individual Contributor (IC) 레벨 직책에 대한 면접을 진행하는 것은 도전적이면서도 흥미로운 경험일 수 있어요. 이러한 직책에 채용되기를 염원하는 당신은 새로운 기업 문화, 기술 스택 및 비즈니스 영역에 적응할 수 있는 능력에 대한 불확실성에 맞서야 할 수 있어요. 그렇다면... 이런 면접을 어떻게 준비해야 할까요?\n\n이 블로그 포스트에서, 저는 다양한 회사의 Staff 레벨 면접 준비를 어떻게 했는지 소개하고 있어요. Staff+ 직책에서 요구되는 다재다능한 기술 세트로 인해 각 회사마다 독특한 면접 절차를 갖고 있을 수 있어요. 당신은 유연하고 어떠한 유형의 면접에도 준비할 준비가 되어 있어야 해요. Staff+ 직책은 희소한데다 경쟁이 치열할 수 있어요. 회사의 다양한 면접 준비를 위해 기다린다면, 첫 날부터 인상적인 모습을 보여줄 준비가 된 사람에게 기회를 놓칠 수도 있어요.\n\n저는 FAANG 및 대형 및 중소 규모의 기술 회사에서 면접을 진행한 경험이 있어요. 하지만 면접을 진행한 회사나 그들의 프로세스의 세부 사항에 대해서는 공개하지 않겠어요. 면접관들이 알맞은 시기에 모든 필요한 정보를 알려 줄 거예요. 대신, 가장 일반적인 면접 유형에 대해 통찰력을 제공하겠어요: 1) 자료 구조 및 알고리즘, 2) 전문 분야 (제 경우 안드로이드), 3) 시스템 설계, 그리고 4) 행동 면접.\n\n그런데 궁금한 점이 있으시다면... 네, 맞아요! 저는 여러 회사의 면접 프로세스를 통과하여 Bumble Inc. 🐝의 Staff Android 엔지니어로 합류했어요. 다가오는 섹션에서, 이 4가지 종류의 면접에 대한 준비 방법과 그것들을 성공적으로 통과하는데 도움이 되는 팁에 대해 설명하고 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스탭 이상 엔지니어가 될 준비가 되셨나요?\n\n당신은 아무도 모르겠지만, 스탭 이상 엔지니어가 될 준비가 되었는지 또는 그것이 향수하는 목표인지 알고 있습니다. 이 수준으로의 여정은 기술적 기술만이 아니라 리더십과 영향력에 대한 명확한 이해도 필요합니다. 멋진 작가들이 그 주제에 대해 책 전체를 썼기 때문에 제가 단락 두 개로 충고하려고 노력하는 것은 주제에 대한 공정하지 못한 비판일 것입니다.\n\n이 역할에 대해 이해하는 데 가장 좋아하는 책은 Tanya Reilly의 The Staff’s Engineer’s Path입니다. 이것은 진정한 걸작입니다. 또 다른 흥미로운 책은 Will Larson의 Staff Engineer입니다.\n\n![이미지](/assets/img/2024-07-01-InterviewingatStafflevel_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 스태프 이상 IC 엔지니어는 일반적으로 회사 내에서 고급 수준에서 활동합니다. 특정 영역에 대한 폭넓은 기술 지식을 보유하고 자주 리더십 역할을 맡을 수 있습니다. 기술적 우수성을 촉진하며 멘토십을 제공하고 고수준 의사 결정에 기여하는 것이 그들의 책임입니다.\n\n# DS/A 면접 준비\n\n자료 구조 및 알고리즘 인터뷰는 아마도 가장 논란이 많은 면접 중 하나일 것입니다. 어떤 사람들은 그것을 좋아하고, 다른 사람들은 싫어합니다! 왜 일부 회사들이 이러한 종류의 면접을 실시하기를 선택하는지 이해할 수 있습니다:\n\n- 코딩 스킬을 향상시켜줍니다. 생각을 기능적인 코드로 번역할 수 있습니다.\n- 간단한 질문을 더 발전시킬 수 있으며, 후보자가 어떻게 이유를 근거 짓고 인터뷰어로부터 피드백을 받아들이는지를 확인할 수 있습니다.\n- 문제를 체계적으로 생각하도록 강요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDS/A 면접에서 성공하기 위한 핵심 3가지 포인트에 대해 이야기해보겠어요. 하나씩 살펴봐요.\n\n## 코딩 실력 향상\n\n맞닥뜨릴 수 있는 다양한 유형의 문제를 학습하는 것 외에도, 문제를 해결해야 해요. 문제에 대한 작동하는 해결책을 찾는 것이 필수적이에요. 해결책을 도출하고 개선하는 효율은 당신이 면접관과 함께 하는 토의의 깊이에 상당한 영향을 미칠 수 있어요. 종종 이는 성공적인 면접으로 이어집니다.\n\n효율성을 높이려면, 당신이 선택한 프로그래밍 언어에서 가장 일반적인 유틸리티를 학습하는 것을 권장해요. Kotlin에서는 몇 가지 연습문제에서 유용할 수 있는 일반적이지 않은 Collections API에 익숙해져야 해요. 유용한 Kotlin Collections 참고 자료가 있다면 활용할 수 있어요; 예를 들어, Jussi Hallila가 만든 이것을 사용했어요. 또한 Random API, Mutex API, 그리고 스레드 안전한 Collections과 같은 몇 가지 유용한 API에 대한 지식을 되새김하는 것도 좋아요. 이러한 지식은 코딩을 보다 효율적으로 만들어주는데 그치지 않고, 면접 중에 좀 더 통찰력 있는 토의의 가능성을 열어줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 연습하기\n\n이 유형의 면접에서 더 나아지려면, 계속해서 연습해야 합니다. 친숙한 Cracking the Coding Interview by Gayle L. McDowell의 녹색 표지를 꺼내어 다양한 챕터를 성실히 공부해보세요. 또한 다른 플랫폼에서 DS/A 기술을 증명하세요! 저는 LeetCode를 사용하여 꽤 만족스러운 결과를 얻었습니다. 가능한 많은 문제를 풀어보고 Grind 75 문제를 통해 모든 가능한 DS/A 질문에 대한 철저한 이해를 얻으세요. 또한, 모의 면접을 진행하여 다른 사람 앞에서 실력을 테스트해보세요. 이를 위해 Pramp를 사용했는데, 다소 다양성이 부족하지만 전체적으로 필요한 것을 제공했습니다.\n\n![이미지](/assets/img/2024-07-01-InterviewingatStafflevel_1.png)\n\n## 당신과 면접관\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서로 다른 인터뷰어마다 인터뷰 스타일이 다양하지만 내가 보는 가장 일반적인 유형은 당신의 한계를 이해하고 긍정적인 경험을 보장하고자 하는 인터뷰어입니다. 당신의 인터뷰에서는 대부분 무차별 공격적인 해결책을 사용하는 질문으로 시작할 것입니다.\n\n해결책에 도달하는 방식이 당신이 입력하는 것만큼 중요합니다. 소리내어 생각하고 인터뷰어와 다양한 대안에 대해 논의해보세요: 이들의 대가, 시간 및 공간 복잡성, 가능한 개선 사항 등. 내가 드릴 수 있는 가장 좋은 조언은 당신의 인터뷰어의 피드백을 적극적으로 듣고 당신의 방식에 적용하는 것입니다. 예외적인 상황에 처하지 않는다면, 대부분의 인터뷰어는 당신이 성공하길 진심으로 바라고 있습니다! 그들은 문제 해결을 위해 도와주기 위해 힌트나 지침을 제공할 가능성이 높습니다.\n\n## 문제 해결 방식을 구조화하세요\n\n특정 문제에 대처하기 위해 나는 Cracking the Coding Interview 책에 나와 있는 문제 해결 구조를 따릅니다: 듣기, 예외 상황 고려, 무차별 공격, 최적화, 방식 검토, 구현, 테스트.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직원 포지션에 대비하면서 Adam Bennet의 오 면접 블로그 게시물이 귀중한 자원이라고 생각했어. 특히 그의 Github 프로젝트를 즐겨보았어, DS/A 면접 문제에 대한 공통 전략과 같은 보석들이 담겨 있어.\n\n# 안드로이드 (또는 전문 분야) 면접 준비\n\n안드로이드 면접은 다양한 형식으로 진행될 수 있어. 당신은 그 자리에서 앱을 만들거나 기존 앱을 개선하거나, 코드베이스에 의도적인 버그를 식별하고 수정하거나, 면접 중에 논의할 과제를 완성할 수도 있어.\n\n만약 집에서 과제를 완성해야 한다면, Paul Blundell의 안드로이드 면접 블로그 게시물을 강력히 추천해. 그의 과제 앱 중 하나의 구현을 보고 직접 페이지네이션을 구현하는 방법을 배우기도 해.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n면접 중에 처음부터 앱을 만들어야 한다면, MVx 아키텍처를 사용하여 두 개의 스크린 - 목록 및 상세 화면 -으로 간단한 앱을 만들어 연습해보세요. 기존 애플리케이션을 개선해야 한다면, 주로 위에 언급한 내용을 의지했습니다. 안드로이드 개발자로서의 경험을 통해 나머지 대비를 하였습니다.\n\n![이미지](/assets/img/2024-07-01-InterviewingatStafflevel_2.png)\n\n아키텍처, 의존성 주입, Jetpack Compose, 또는 스레딩과 같은 주제에 대한 자신감이 있는데, 이러한 부분에 대해 많이 준비하지는 않았습니다. 그러나 회사의 안드로이드 기술 스택에 대해 알아보고 해당 도구들 및 기존 지식과 어떻게 일치하는지 알아두는 것이 좋습니다.\n\n# 시스템 디자인 인터뷰 준비하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템 디자인 면접은 제가 가장 좋아하는 면접 중 하나에요. 아무런 준비 없이 해도 되겠지 생각할 수도 있지만, 만약 완벽하게 해내고 싶다면 충분한 준비가 필요해요. 저는 체계적인 성격이라서 이런 면접은 체계적인 전략을 통해 더 큰 이점을 얻을 수 있다고 믿어요.\n\n시스템 디자인 문제에 직면했을 때, 미리 물어볼 중요한 질문들을 파악하는 것이 핵심이에요. 정보를 수집하는 과정에서 기반으로 선택지를 조정해가며 논리적인 순서로 질문을 던져보세요. 일반적으로 면접관으로부터 요구 사항을 수집하여 무엇을 누구를 위해 구축할 것인지 이해하는 것부터 시작해요. DAU(일일 활성 사용자), 인증, 오프라인 모드, 페이지네이션 등과 같은 기능적 및 비기능적 요구 사항을 물어봐요.\n\n이후에는 정보를 바탕으로 현명한 결정을 내리고, 올바른 네트워크 프로토콜(예: REST, gRPC, GraphQL 등)을 선택하고 비즈니스 요구 사항과 백엔드와의 통신을 위한 데이터 모델을 정의하며 세부 사항에 대해 파고들어가세요.\n\n저는 우선순위에 따라 질문이 정리된 치트 시트와 성능, 네트워킹, 데이터 관리 등 주제별 치트 시트를 사용했어요. 시스템 디자인 문제에는 단일 옳은 답이 항상 있는 것은 아니라는 것을 기억하세요. 대화를 이끌며 타협을 논의하고 면접관과 함께 공동 이해를 도모하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-InterviewingatStafflevel_3.png\" /\u003e\n\n## 모바일 시스템 디자인 인터뷰\n\n만약 당신이 모바일 앱 개발 분야에 종사하고 계시다면, 시스템 디자인 인터뷰에서 성공하기 위한 필수 자료는 Alex Lementuev의 Mobile system design Github 프로젝트입니다. 이 포괄적인 저장소에는 이 유형의 인터뷰에서 성공하기 위해 필요한 모든 것이 포함되어 있습니다. 서로 다른 주제에 대한 장단점에 특별히 주목하십시오. 이것은 여러분의 의사 결정을 정당화하는 데 매우 중요합니다. 여러분이 할 수 있는 다양한 선택을 배우는 데 그치지 않고, 이 자료는 또한 인터뷰에 접근하는 방식을 구조화하는 데 도움이 됩니다. 실제 인터뷰에서 이러한 지식을 어떻게 적용하는지 보려면 YouTube 채널의 모의 인터뷷을 확인해보세요. 문제에 접근하는 사람들이 어떻게 접근하는지 관찰하는 것을 강력히 추천합니다.\n\n모바일 앱의 아키텍처를 다룰 때, 권장되는 계층화된 안드로이드 아키텍처와 단방향 데이터 흐름(UDF)에 대해 생각해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당이외에 ByteByteGo 뉴스레터에서 콘텐츠를 읽고 Alex Xu의 시스템 디자인 면접 책(1, 2)을 통해 다양한 디자인 패턴을 새로이 하고, Martin Kleppmann의 디자인 데이터 집약 애플리케이션 책을 읽었어요.\n\n면접 유형별로 준비할 때와 마찬가지로, 실력을 연습하고 더 많은 연습을 해야 해요. 좋아하는 앱의 기능 하나를 찾아 어떻게 디자인할지 고민해보세요. 더 많은 영감을 얻기 위해 앞서 언급한 Mobile 시스템 디자인 프로젝트에 명시된 연습문제를 확인해보세요.\n\n![인터뷰](/assets/img/2024-07-01-InterviewingatStafflevel_4.png)\n\n# 행동 면접 준비하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행동 인터뷰를 준비하려면, Cracking the Coding Interview 책에 소개된 방식을 따를 수 있어요. 가장 중요한 프로젝트에 대한 표를 작성하고 핵심 측면에 대해 체계적으로 반성해 보세요. 예를 들어, 가장 어려웠던 점, 배운 점, 가장 흥미로운 점, 가장 어려웠던 버그, 가장 즐거웠던 점, 갈등, 다르게 할 점, 리더십 및 실패 등을 고려해 보세요.\n\n기타 질문으로는, 소중한 교훈을 얻었던 때, 팀을 전진시킨 능력, 팀 외부에 영향을 미치는 능력, 일어나길 원하는 열정, 예상을 뛰어넘는 성과를 달성한 때, 부당하다고 생각한 성과 평가를 받았던 경험 등이 있을 수 있어요.\n\n인터뷰는 스태프 이상의 역할을 하는 것에요. 전문 지식, 리더십 및 영향력에 집중하세요. 여러분이 한 일이 비즈니스에 어떻게 영향을 미쳤는지, 다른 개발자들을 위한 곱셈기 역할을 한 것에 대한 예시를 제공할 수 있어야 하며, 기술적 전문성 외에 비즈니스 결과에 대해 고려하고 있다는 것을 입증해야 해요. 이 구조화된 접근 방식은 행동 인터뷰 중에 경험, 성취 및 과제를 효과적으로 전달할 수 있도록 준비가 잘 되어 있음을 보장해 줄 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 최고의 조언이 있어요: 거짓말 하지 마세요! 솔직함은 면접 프로세스 전반에 중요해요. 부정확한 정보를 제공하여 성공해도, 팀에 합류했을 때 오해를 일으킬 수 있어요. 하지만 소심해하지 마세요! 이 면접은 여러분의 순간이니까 ⭐. 여러분 자신을 판매해야 해요. 개인적인 성취와 프로젝트에 기여한 내용에 집중하세요.\n\n## 리더십 스타일 개선하기\n\n리더십은 경험에 따라 오는 것이지만, 리더십 스타일을 개선하는 것은 관련 서적의 통찰을 적용함으로써 가속화될 수 있어요. 소개에서 언급한 Staff engineer 책 외에도 아래 책들을 살펴보세요. 저는 이 책들을 정말 즐겁게 읽었어요:\n- Daniel Coyle의 The Culture Code: 우수한 팀을 구축하는 다양한 기술을 배우세요. 안전한 문화, 취약점 공유, 명확한 목적 성립에 집중하세요.\n- Kerry Patterson의 Crucial Conversations: 입을 열기 전에 해야 할 중요한 기술을 배우고, 대화를 시작하는 방법과 건설적인 결론을 이끌어내는 방법을 알아보세요.\n- Erin Meyer의 The Culture Map: 이를테면 업무와 개인적인 삶에도 적합한 통찰력과 실용적인 안내로 문화적 차이를 이해하고 탐색하세요.\n- Chris Voss의 Never Split the Difference: 상대방과의 대화에서 듣기, 감정 공감, 최대한 많이 얻어내는 협상 기술을 발견하세요.\n- Kim Scott의 Radical Candor: 개인적으로 관심을 가지면서 직접적으로 팀에 도전하여 최상의 성과를 얻는 방법을 배우세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 책들을 읽으면서 당신의 판단을 사용하여 자신과 공감되는 아이디어를 선택하고 실천해보세요. 진실성이 중요합니다. 당신만의 독특한 리더십 스타일과 부합하는 방식으로 교훈을 적응하고 적용해보세요.\n\n![](/assets/img/2024-07-01-InterviewingatStafflevel_6.png)\n\n## 결론\n\nStaff+ IC 레벨 면접 준비에는 기술, 행동 및 리더십 측면을 모두 고려한 다각적인 접근이 필요합니다. 이 여정에는 DS/A에서 시스템 설계 및 행동 평가로 이어지는 다양한 면접 형식을 탐색하는 것이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구조화된 준비 전략을 채택하는 것이 중요합니다. 다양한 주제에 대해 학습하고, 자신만의 전략을 선택하며, 모의 면접을 연습하고, 적극적으로 듣고, 면접관과 함께 최상의 해결책을 찾아가세요.\n\n4가지 다른 면접을 제대로 준비하는 데 시간을 투자하세요. 시간을 계획하며 자신에게 맞도록 작동하게 해보세요. 각 면접에 몇 주씩 투자하여 해당 면접의 다양한 측면에 심층적으로 파고들어보세요. 면접이 다가올 때 되면, 하루에 한 가지 유형씩 공부하는 것도 좋을 수 있습니다.\n\n당신을 독특하게 만드는 것은 자신의 강점과 경험입니다. 외부 자료에서 많은 것을 배웠더라도, 나만의 사실과 배움으로 면접을 물들이세요. 그렇게 하면 특별해지며, 다른 사람들과 뚜렷하게 차이를 보일 수 있습니다.\n\n마지막으로, 면접을 대비할 때는... 재미를 느껴보세요! 그 어려움을 극복하길 진심으로 바라는 기회로 바라보세요. 여러분은 지식과 기술을 보유한 능력과 자신감 있는 전문가입니다. 여러분은 할 수 있습니다! 면접 여정에서 행운을 빕니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# [보너스] 취직 축하해요!\n\n신입사원으로 취직을 축하합니다! 새로운 직책에 발을 딜 때, Michael Watkins의 '첫 90일' 도서를 읽는 걸 추천해요. 이 책은 새로운 직책에 스무스하게 적응하도록 도와줄 거에요. 회사가 자체적인 온보딩 계획을 가지고 있더라도, 당신만의 개인적인 여정을 준비하고 둘 다 손을 잡고 따라가보세요.\n\n그리고 한 가지 친근한 알림: 새로운 동료와 그들의 코드에 애정을 보여주세요. 비판은 하지 말아요! 모든 것에는 이야기가 있어요. 당신은 게임을 더 높이기 위해 거기 있으니까, 다른 사람의 행진에 물을 뿌리기 위해서가 아니에요. 새로운 모험에 건배해요! 🚀\n\n행운을 빕니다! 🍀","ogImage":{"url":"/assets/img/2024-07-01-InterviewingatStafflevel_0.png"},"coverImage":"/assets/img/2024-07-01-InterviewingatStafflevel_0.png","tag":["Tech"],"readingTime":9},{"title":"Xcode 16에 새로 추가된 기능은","description":"","date":"2024-07-01 20:09","slug":"2024-07-01-WhatsNewinXcode16","content":"\n\nWWDC 24에서 공개된 Xcode 16의 새로운 기능을 알아보세요.\n\n![Xcode 16 새로운 기능](/assets/img/2024-07-01-WhatsNewinXcode16_0.png)\n\n매번 새로운 버전이 출시될 때마다 Apple 플랫폼을 위한 통합 개발 환경(IDE)인 Xcode는 계속 변화합니다. 이 블로그에서는 Xcode 16에 추가된 새로운 기능을 살펴보겠습니다. Xcode 16 베타 버전을 다운로드하려면 Mac이 macOS 버전 14.5 이상을 실행 중인지 확인하세요. Xcode 16을 여기서 다운로드할 수 있습니다.\n\n# 편집:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXcode 16에서 편집 기능 중 새로운 점 세 가지에 대해 이야기해 봅시다.\n\n- 코드 완성: Xcode 16이 macOS Sequoia에서 실행 중일 때, 더 철저한 코드 제안을 제공하고 주변 코드 컨텍스트(함수 이름 및 주석)를 활용합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*kBBk_DqXZa-mbx22vp7yig.gif)\n\n- Swift 6 업데이트: Swift 6의 새로운 언어 모드는 동시성 안전 보증을 위한 새로운 언어 모드를 제공합니다. 데이터 경주를 런타임 문제로 변환합니다. 이제 각 다가오는 언어 기능에 대해 경고를 점진적으로 활성화하는 방법을 확인해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-07-01-WhatsNewinXcode16_1.png)\n\n예를 들어: Isolated Global Variables를 true로 설정하면 동시성 보안을 위해 이슈 탐색기에서 경고가 제공됩니다.\n\n![이미지](/assets/img/2024-07-01-WhatsNewinXcode16_2.png)\n\n- 미리보기 개선: 미리보기 개선을 위한 두 개의 새 API가 제공됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Previewable Macro: State와 같은 프로퍼티 래퍼를 첨부하여 미리보기 블록 내에서 직접 사용할 수 있게 합니다. 래퍼 뷰 작성이 필요하지 않습니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-WhatsNewinXcode16_3.png\" /\u003e\n\n2. PreviewModifier: 미리보기를 위해 환경이나 데이터를 쉽게 공유할 수 있게 됩니다. 중복 코드를 줄이는 데 도움이 되며 미리보기 시스템이 데이터를 캐시할 수 있도록 도와줍니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-WhatsNewinXcode16_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 빌드:\n\nXcode 16에서는 명시적 모듈을 제공하여 개선된 병렬성, 더 나은 진단 및 빠른 디버깅을 제공할 것입니다. Objective-C는 기본 명시적 모듈을 제공하지만 Swift에서는 빌드 설정에서 명시적으로 빌드된 모듈을 활성화해야 합니다.\n\n![Xcode 16의 신기능](/assets/img/2024-07-01-WhatsNewinXcode16_5.png)\n\nXcode 16에서는 Swift 패키지 통합이 개선되어 빌드 패키지 해결이 완료될 때까지 기다릴 필요 없이 빌드를 큐로 업데이트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-07-01-WhatsNewinXcode16_6.png)\n\nXcode 16부터는 소스 파일을 컴파일하는 중에 그것을 포함할 것이기 때문에, 모듈 문제로 빌드에 실패하면 명확한 오류 메시지를 얻게 될 것입니다. 더 많은 정보를 원하신다면 빌드 모듈에 대해 자세히 알아보세요: [https://developer.apple.com/videos/play/wwdc2024/10171](https://developer.apple.com/videos/play/wwdc2024/10171).\n\n# 디버깅:\n\n- macOS Sequoia 또는 iOS 18으로 배포에 빌드할 때 DWARF5가 이제 기본 디버그 심볼 형식입니다. 따라서 dSYM 번들이 더 작아지고 심볼이 더 빠르게 보입니다.\n- Xcode 16에서 코드를 디버깅할 때, 스레드 성능 확인기가 더 강화되었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 메인 스레드가 멈춤: 디버그바에서 통합 백트레이스 뷰를 활성화할 수 있습니다. 호출 스택을 시각화하여 멈춤 문제를 찾는 데 도움이 될 것입니다.\n\n2. 디스크 쓰기 진단: 문제의 영향을 서로 다른 앱 버전에서 어떻게 변경되었는지 확인할 수 있습니다.\n\n3. 시작 진단: 이는 조직자의 새로운 카테고리입니다. 앱의 시작 진단 로그를 확인하는 데 사용될 것입니다. Xcode는 앱 시작이 시간이 오래 걸리는 이유를 보여줄 것입니다.\n\n# 테스트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift Testing을 사용하면 표현력 있는 API를 포함하는 새로운 프레임워크를 통해 테스트 작성이 간단해집니다. 이 테스트는 XCTests와 함께 완벽하게 작동할 것입니다.\n\n![Xcode 16.7의 새로운 기능](/assets/img/2024-07-01-WhatsNewinXcode16_7.png)\n\nSwiftTesting 프레임워크를 사용하면 결과를 확장하여 테스트가 실패한 이유에 대한 자세한 설명을 확인할 수 있습니다. Swift Testing 프레임워크에 대해 더 알아보려면 \"Swift Testing\"으로 진행하고, \"Meet Swift Testing\"을 확인해보세요.\n\nXcode에서의 StoreKit 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 앱 정책 구성: StoreKit.configuration 파일에 사용자 라이선스 동의서 및 로컬라이즈된 개인정보 보호 정책을 추가하여 StoreKit 뷰에 표시되도록합니다.\n- Win-Back Offers 테스트: StoreKit.configuration 파일에서 구성하여 자동 갱신 멤버십용 윈백 오퍼를 설정합니다.\n\n# Instrument 툴을 사용하여 성능 최적화:\n\nInstrument 16의 새로운 Flame 그래프 프레임은 추적 실행의 고수준 개요를 제공합니다.\n\n![이미지](/assets/img/2024-07-01-WhatsNewinXcode16_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Xcode 16의 기능에 대해 더 자세히 이야기해봅시다.\n\n## 프로젝트와 워크스페이스\n\n- 프로젝트 네비게이터의 컨텍스트 메뉴에서 확인 대화 상자 없이 빠르게 스위프트 파일을 생성할 수 있습니다.\n- 편집 메뉴의 복사, 붙여넣기, 복제 옵션을 사용하여 기존 파일을 기반으로 새 파일을 빠르게 생성할 수 있습니다.\n- 소스 편집기에서 원하는 텍스트를 잘라내어 프로젝트 네비게이터의 컨텍스트 메뉴에서 \"클립보드로부터 새 파일 만들기\" 명령을 선택하기 전에 Option 키를 눌러 소스 파일의 일부로부터 빠르게 새 파일을 생성할 수 있습니다.\n\n## 기기와 시뮬레이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 업그레이드된 시뮬레이터로 비전 OS에서 FaceTime 및 SharePlay 지원이 가능합니다.\n- 다운로드가 중단되어도 시뮬레이터 업데이트가 재개되므로 Xcode에서 프로젝트를 빠르게 시작할 수 있습니다. 또한, 'Components' 메뉴를 통해 다운로드 가능한 구성 요소를 관리할 수 있습니다.\n\n# 자산 관리\n\n- Xcode 16에서 iOS용 새로운 다크 모드와 틴티드 앱 아이콘을 추가할 수 있습니다.\n\n# Xcode 클라우드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용자 정의 별칭 설정을 정의할 것입니다. Xcode 및 macOS 구성을 중앙 집중화합니다. 또한 Xcode 클라우드에서 빌드 보고서를 열어 Xcode의 보고서 탐색기 아래에서 커버리지 데이터를 볼 수 있습니다.\n\n## 지역화\n\n- Xcode 16은 문자열 카탈로그에 대한 새로운 기능을 제공합니다. 예를 들어 인라인 진단 및 번역하지 않을 문자열로 표시하는 기능이 있습니다.\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXcode 16은 Apple의 개발 도구에서 주요한 진보를 이룬 것으로, 개발자 생산성을 향상시키고 코딩을 간소화하는 강력한 새로운 기능을 소개했습니다. 코드 완성 및 테스트를 위한 고급 AI 기능, Swift 6과의 더 깊은 통합, 그리고 SwiftUI 및 기타 프레임워크에 걸쳐 개선 사항이 포함되어 있습니다. 이러한 개선으로 앱 개발이 더 효율적이고 즐거워집니다.\n\n참고: 현재 Xcode 16은 베타 버전입니다. 몇 가지 충돌 문제가 있을 수 있으므로 사용하기 전에 한 번 확인해주십시오.","ogImage":{"url":"/assets/img/2024-07-01-WhatsNewinXcode16_0.png"},"coverImage":"/assets/img/2024-07-01-WhatsNewinXcode16_0.png","tag":["Tech"],"readingTime":5},{"title":"SwiftUI에서 차트 쉽게 만드는 방법","description":"","date":"2024-07-01 20:07","slug":"2024-07-01-IntroductiontoChartsinSwiftUI","content":"\n\n![Introduction to Charts in SwiftUI](/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_0.png)\n\n사용자에게 정보를 제공할 때, 간편한 것이 더 좋습니다.\n\n특히 큰 데이터 세트를 다룰 때는 그렇습니다. 사용자 정의 뷰, 테이블, 요약 등 다양한 옵션이 있지만, 좀 더 풍부한 경험을 제공하고자 그래픽 표현을 활용할 수 있습니다.\n\n차트를 사용하면 사용자는 제시된 데이터에 대한 이해를 확장할 수 있습니다. 처음 봤을 때, 사용자는 데이터를 더 잘 파악할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 앱의 참여를 높이고 싶다면, 차트를 활용하는 방법에 대한 빠르고 쉽게 따라할 수 있는 가이드를 보여드릴게요.\n\n![차트](https://miro.medium.com/v2/resize:fit:592/1*7d3jOjvtUsl06TJrvp3q8w.gif)\n\n# 기본 사항\n\n차트를 만들 때는 차트 요소들을 조합하여 만듭니다. 이러한 요소들은 ChartContent 프로토콜을 준수해야 하며, 차트 범위 내에서 그려질 수 있는 유형을 나타내야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차트를 만들려면 init(content:) 메서드를 사용합니다. ViewBuilder 클로저에서 필요한 모든 시각적 요소를 추가합니다.\n\n```js\nstruct ChartView: View {\n  var body: some View {\n    ChartView {\n      // 차트 요소\n    }\n  }\n}\n```\n\n## 알겠어요, 그런데 어떤 요소들을 추가할 수 있나요?\n\nCharts framework에는 Marks라고 불리는 사용 준비된 ChartContent 세트가 있습니다. Mark는 데이터를 표현하는 그래픽 요소로 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_1.png)\n\n## 차트에서 3가지 종류의 데이터를 사용할 수 있습니다.\n\n- 양적 데이터: Int, Double, Float와 같은 수치 값.\n- 명목 데이터: 이산적인 범주 또는 그룹.\n- 시간적 데이터: 시점.\n\n사용하는 데이터 유형에 따라 차트 UI를 조작하는 데 적용할 수 있는 구성 요소가 달라집니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드를 보여주겠어요 🤓\n\n우리의 데모에서는 사용자가 latte, cappuccino, cortado, 그리고 flat white 유형에 대해 시간에 따라 소비한 커피의 수를 나타내고 싶어해요.\n\n그래서 간단한 막대 차트를 만들어 총 커피 수를 보여줄까요?\n\n```js\nstruct CoffeeData: Identifiable {\n  typealias CoffeeDetails = (type: Coffee, amount: Int)\n  let id = UUID()\n  let date: Date\n  let details: [CoffeeDetails]\n  \n  static func mockData() -\u003e [CoffeeData] { ... }\n}\n\nstruct DemoChart: View {\n  @State private var coffeeData = CoffeeData.mockData()\n  \n  var body: some View {\n    Chart {\n      ForEach(coffeeData, id: \\.id) { coffeeInfo in\n        BarMark(\n          x: .value(\"Date\", coffeeInfo.date),\n          y: .value(\"Coffee\", totalCoffees(in: coffeeInfo.details))\n        )\n      }\n    }\n    .frame(height: 300)\n    .padding()\n  }\n  \n  func totalCoffees(in details: [CoffeeData.CoffeeDetails]) -\u003e Int {\n    return details.map({$0.amount}).reduce(0, +)\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Chart](/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_2.png)\n\n## 차트 사용자 정의하기\n\n커피 유형별 데이터를 구분하려면 CoffeeDetails를 추가 반복하고 foregroundStyle(by:) 수정자를 사용하여 정보를 그룹화해야 합니다.\n\n```swift\nstruct DemoChart: View {\n  @State private var coffeeData = CoffeeData.mockData()\n    \n  var body: some View {\n    Chart {\n      ForEach(coffeeData, id: \\.id) { coffeeInfo in\n        ForEach(coffeeInfo.details, id: \\.type) { coffeeDetails in\n          BarMark(\n              x: .value(\"Date\", coffeeInfo.date),\n              y: .value(\"Coffee\", coffeeDetails.amount)\n          )\n          .foregroundStyle(by: .value(\"Coffee Type\", coffeeDetails.type))\n        }\n      }\n    }\n    .frame(height: 300)\n    .padding()\n  }\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_3.png\" /\u003e\n\n이 작은 변화로 데이터를 그룹화했습니다. 그러나 이 유형의 차트는 주로 특정 값의 진행 상황을 보여줄 때 사용됩니다.\n\n우리의 경우, 각 커피 종류에 대해 한 막대 막대가 필요하기 때문에 각 X-값(즉, 월)에 대해 4개의 막대(라떼/카푸치노/코르타도/플랫화이트)가 필요합니다. 이를 위해 두 가지 변경 사항이 필요합니다:\n\n- X-축 값에서 unit 옵션을 사용하여 월별로 값을 그룹화하려고 한다는 것을 표시합니다.\n- 실제로 그룹화된 막대를 만들기 위해 position(by:axis:span:) 수정자를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nstruct DemoChart: View {\n  @State private var coffeeData = CoffeeData.mockData()\n    \n  var body: some View {\n    Chart {\n      ForEach(coffeeData, id: \\.id) { coffeeInfo in\n        ForEach(coffeeInfo.details, id: \\.type) { coffeeDetails in\n          BarMark(\n              x: .value(\"날짜\", coffeeInfo.date, unit: .month),\n              y: .value(\"커피 양\", coffeeDetails.amount)\n          )\n          .foregroundStyle(by: .value(\"커피 종류\", coffeeDetails.type))\n          .position(by: .value(\"커피 종류\", coffeeDetails.type))\n        }\n      }\n    }\n    .frame(height: 300)\n    .padding()\n  }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_4.png\" /\u003e\n\n# 차트를 우리의 요구에 맞게 계속 수정할 수 있습니다\n\n## 사용자 정의 막대 색상\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nchartForegroundStyleScale(_:) 수정자를 사용하세요. 그룹화에 사용하는 모든 옵션에 값을 지정해야 합니다. 우리 경우에는 Latte, Cappuccino, Cortado, FlatWhite을 사용하면 됩니다.\n\n## 스케일 변경\n\n차트 표식을 더 크거나 작게 만들기 위해 축에 표시되는 값들을 제어하려면 chartYScale(domain:type:) 및 chartXScale(domain:type:) 수정자를 사용할 수 있습니다. 도메인은 양적 및 날짜 유형에는 닫힌 범위(예: 0에서 15까지)이거나 이산 유형에는 값들의 배열이 될 수 있습니다.\n\n## 축 레이블 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 경우에는 X 축에 월과 연도를 함께 표시하는 것이 좋을 것 같아요, 예를 들면, 2023년 8월처럼요. chartXAxis(content:) 수정자를 사용하면 이를 할 수 있어요.\n\n## 주석 추가\n\n가끔은 차트의 표식에 추가 정보를 포함하여 더 읽기 쉽게 만들어야 할 때가 있어요. annotation(position:alignment:spacing:content)을 사용하면 어떤 보기든 표식과 함께 배치할 수 있어요.\n\n```js\nstruct DemoChart: View {\n  @State private var coffeeData = CoffeeData.mockData()\n  \n  var body: some View {\n    Chart {\n      ForEach(coffeeData, id: \\.id) { coffeeInfo in\n        ForEach(coffeeInfo.details, id: \\.type) { coffeeDetails in\n          BarMark(\n            x: .value(\"날짜\", coffeeInfo.date, unit: .month),\n            y: .value(\"커피\", coffeeDetails.amount)\n          )\n          .annotation(position: .위, alignment: .가운데) {\n            Text(\"\\(coffeeDetails.amount)\")\n          }\n          .foregroundStyle(by: .value(\"커피 종류\", coffeeDetails.type))\n          .position(by: .value(\"커피 종류\", coffeeDetails.type))\n          .cornerRadius(12)\n        }\n      }\n    }\n    .chartForegroundStyleScale([\n      Coffee.latte: Color.accentColor,\n      Coffee.cappuccino: Color.accentColor.opacity(0.7),\n      Coffee.cortado: Color.accentColor.opacity(0.5),\n      Coffee.flatwhite: Color.accentColor.opacity(0.3),\n    ])\n    .chartXAxis {\n      AxisMarks(values: .stride(by: .month, count: 1)) { _ in\n        AxisValueLabel(format: .dateTime.month(.abbreviated).year(.twoDigits), centered: true)\n      }\n    }\n    .chartScrollableAxes(.수평)\n    .chartYScale(domain: 0 ... 15)\n    .frame(height: 300)\n    .padding()\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_5.png\" /\u003e\n\n# Composing \u0026 Interactivity\n\n내가 차트를 만들 때 다른 ChartComponent를 추가해서 만든다고 했던 걸 기억하는가? 이러한 구성 요소들은 꼭 동일한 유형이어야 하는 것은 아니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_6.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라인마크와 에어리아마크를 결합하여 이 UI를 구현할 수 있습니다. \n\n```js\nstruct OverallData: Identifiable {\n    let id = UUID()\n    let date: Date\n    let coffee: Int\n    \n    static func mockData() -\u003e [OverallData] {\n        \n        return [\n            .init(date: Date(year: 2023, month: 08), coffee: 12),\n            .init(date: Date(year: 2023, month: 09), coffee: 15),\n            .init(date: Date(year: 2023, month: 10), coffee: 8),\n            .init(date: Date(year: 2023, month: 11), coffee: 18),\n            .init(date: Date(year: 2023, month: 12), coffee: 14),\n            .init(date: Date(year: 2024, month: 01), coffee: 22),\n        ]\n    }\n}\n\nstruct DemoChart: View {\n  @State private var overallData = OverallData.mockData()\n\n  private var areaBackground: Gradient {\n    return Gradient(colors: [Color.accentColor, Color.accentColor.opacity(0.1)])\n  }\n\n  var body: some View {\n    Chart(overallData) {\n      LineMark(\n        x: .value(\"월\", $0.date, unit: .month),\n        y: .value(\"양\", $0.coffee)\n      )\n      .symbol(.circle)\n      .interpolationMethod(.catmullRom)\n      \n      AreaMark(\n        x: .value(\"월\", $0.date, unit: .month),\n        y: .value(\"양\", $0.coffee)\n      )\n      .interpolationMethod(.catmullRom)\n      .foregroundStyle(areaBackground)\n    }\n    .chartXAxis {\n      AxisMarks(values: .stride(by: .month, count: 1)) { _ in\n        AxisValueLabel(format: .dateTime.month(.abbreviated).year(.twoDigits), centered: true)\n      }\n    }\n    .chartYScale(domain: 0 ... 30)\n    .frame(height: 300)\n    .padding()\n  }\n}\n```\n\n이 조합을 계속해서 룰마크를 추가하고 사용자가 특정 지점을 선택하여 값을 볼 수 있는 사용자 정의 뷰를 주석으로 추가할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:592/1*J24NHU32eh38kMeASpLt1A.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nstruct DemoChart: View {\n  @Environment(\\.calendar) var calendar\n  @State private var coffeeData = CoffeeData.mockData()\n  @State private var overallData = OverallData.mockData()\n  @State private var chartSelection: Date?\n    \n  private var areaBackground: Gradient {\n      return Gradient(colors: [Color.accentColor, Color.accentColor.opacity(0.1)])\n  }\n\n  var body: some View {\n    Chart(overallData) {\n      LineMark(\n        x: .value(\"Month\", $0.date, unit: .month),\n        y: .value(\"Amount\", $0.coffee)\n      )\n      .symbol(.circle)\n      .interpolationMethod(.catmullRom)\n      \n      if let chartSelection {\n        RuleMark(x: .value(\"Month\", chartSelection, unit: .month))\n          .foregroundStyle(.gray.opacity(0.5))\n          .annotation(\n            position: .top,\n            overflowResolution: .init(x: .fit, y: .disabled)\n          ) {\n            ZStack {\n              Text(\"\\(getCoffee(for: chartSelection)) coffees\")\n            }\n            .padding()\n            .background {\n              RoundedRectangle(cornerRadius: 4)\n                .foregroundStyle(Color.accentColor.opacity(0.2))\n            }\n          }\n      }\n      \n      AreaMark(\n        x: .value(\"Month\", $0.date, unit: .month),\n        y: .value(\"Amount\", $0.coffee)\n      )\n      .interpolationMethod(.catmullRom)\n      .foregroundStyle(areaBackground)\n    }\n    .chartXAxis {\n      AxisMarks(values: .stride(by: .month, count: 1)) { _ in\n          AxisValueLabel(format: .dateTime.month(.abbreviated).year(.twoDigits), centered: true)\n      }\n    }\n    .chartYScale(domain: 0 ... 30)\n    .frame(height: 300)\n    .padding()\n    .chartXSelection(value: $chartSelection)\n  }\n}\n```\n\n# 배울 점\n\n- 그래픽 요소를 고려하기 전에 사용자에게 보여주고 싶은 내용을 고려해보세요. 어떤 정보를 전달하고 싶으신가요?\n- 데이터 모델링에 집중하세요. 데이터를 어떻게 모델링하느냐가 차트를 작업하기 쉽게 할 것입니다.\n- 그룹화된 정보를 제공하여 사용자에게 차트에서 발견할 데이터의 일부를 미리 보여줍니다.\n- 차트 작업을 시작하는 데 도움이 되는 몇 가지 기본 사항을 보여드렸습니다. 그러나 차트를 더욱 효과적으로 만들기 위해 사용할 수 있는 많은 구성 및 조정 사항이 있습니다. 공식 Apple 차트 문서를 자세히 살펴보고 WWDC 세션을 시청하는 것을 추천드립니다.\n\n질문이 있으신가요? 언제든지 메시지 남겨주세요! 🙂\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 🤓 iOS 개발 팁과 통찰을 정기적으로 공유하는 X에서 저와 함께하세요\n- 🚀 제 GitHub에서 내 예제 프로젝트들을 확인해보세요","ogImage":{"url":"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_0.png"},"coverImage":"/assets/img/2024-07-01-IntroductiontoChartsinSwiftUI_0.png","tag":["Tech"],"readingTime":11},{"title":"이렇게 파이썬 함수 작성 안 하면 PR 거부할 거야","description":"","date":"2024-07-01 20:06","slug":"2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest","content":"\n\n\u003cimg src=\"/assets/img/2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png\" /\u003e\n\n이게 바로 제가 회사에서 기술 리드로부터 얻은 에너지였어요. 사실 저도 이 시점에서 그의 말에 동의해요.\n\n# 우리가 파이썬 함수를 작성하는 방법\n\n여기 간단한 함수가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 숫자 목록 `num_list`\n- 숫자 `num`","ogImage":{"url":"/assets/img/2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png"},"coverImage":"/assets/img/2024-07-01-WritePythonFunctionsLikeThisOrIllRejectYourPullRequest_0.png","tag":["Tech"],"readingTime":1},{"title":"GitHub Copilot, 이제 라이브 코딩 인터뷰가 필요 없을까","description":"","date":"2024-07-01 20:05","slug":"2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews","content":"\n\n더 이상 그들이 우리에게 필요한가요?\n\n![image](/assets/img/2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews_0.png)\n\n코딩 면접은 소프트웨어 업계에서 민감한 주제입니다. 충분히 공부하고 반복하면 다른 사람들과 차별화될 수 있는 어떤 테스트처럼 게임을 할 수 있습니다. (게임을 할 수 없었다면, 이 책이나 LeetCode와 같은 사이트가 왜 성공적인 것일까요?)","ogImage":{"url":"/assets/img/2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews_0.png"},"coverImage":"/assets/img/2024-07-01-DoesGitHubCopilotMeanWeCanStopDoingLiveCodingInterviews_0.png","tag":["Tech"],"readingTime":1},{"title":"Jetpack Compose로 안드로이드 카운트다운 스낵바 만드는 방법","description":"","date":"2024-07-01 20:04","slug":"2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose","content":"\n\n환영합니다 👋\n\n이 기사에서는 젯팩 콤포즈(Jetpack Compose)에서 카운트다운 스낵바를 만들어보겠습니다. 이 기능은 사용자가 계정을 삭제하는 등 중요한 작업을 다시 생각할 시간을 제공하기에 안성맞춤입니다.\n\n계속 주목해 주시고, 함께 시작해 보겠습니다! 🚀\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스낵바 카운트다운 생성하기\n\n먼저 시각적으로 카운트다운 타이머를 나타내는 SnackbarCountdown 조합 함수를 정의합니다.\n\n```js\n@Composable\nprivate fun SnackbarCountdown(\n    timerProgress: Float,\n    secondsRemaining: Int,\n    color: Color\n) {\n    Box(\n        modifier = Modifier.size(24.dp),\n        contentAlignment = Alignment.Center\n    ) {\n        Canvas(Modifier.matchParentSize()) {\n            // 스트로크 정의\n            val strokeStyle = Stroke(\n                width = 3.dp.toPx(),\n                cap = StrokeCap.Round\n            )\n            // 트랙 그리기\n            drawCircle(\n                color = color.copy(alpha = 0.12f),\n                style = strokeStyle\n            )\n            // 진행 상황 그리기\n            drawArc(\n                color = color,\n                startAngle = -90f,\n                sweepAngle = (-360f * timerProgress),\n                useCenter = false,\n                style = strokeStyle\n            )\n        }\n        // 남은 초 표시\n        Text(\n            text = secondsRemaining.toString(),\n            style = LocalTextStyle.current.copy(\n                fontSize = 14.sp,\n                color = color\n            )\n        )\n    }\n}\n```\n\n# 카운트다운Snackbar 함수 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 SnackbarCountdown을 구성했으니 CountdownSnackbar을 정의할 수 있습니다. 이 composable은 외관과 동작을 사용자 정의하기 위해 여러 매개변수를 가져야 합니다.\n\n```js\n@Composable\nfun CountdownSnackbar(\n    snackbarData: SnackbarData,\n    modifier: Modifier = Modifier,\n    durationInSeconds: Int = 5,\n    actionOnNewLine: Boolean = false,\n    shape: Shape = SnackbarDefaults.shape,\n    containerColor: Color = SnackbarDefaults.color,\n    contentColor: Color = SnackbarDefaults.contentColor,\n    actionColor: Color = SnackbarDefaults.actionColor,\n    actionContentColor: Color = SnackbarDefaults.actionContentColor,\n    dismissActionContentColor: Color = SnackbarDefaults.dismissActionContentColor,\n) {\n    // 여기에 구현...\n}\n```\n\n⏳ snackbarData ➜ Snackbar을 위한 데이터.\n\n⏳ modifier ➜ Snackbar에 적용할 Modifier.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n⏳ durationInSeconds ➜ 카운트다운 타이머의 기간.\n\n⏳ actionOnNewLine ➜ 동작을 별도의 줄에 표시할지 여부.\n\n⏳ shape ➜ 스낵바 컨테이너의 모양.\n\n⏳ containerColor, contentColor, actionColor, actionContentColor, dismissActionContentColor ➜ 다양한 색상 스타일링 매개변수.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CountdownSnackbar 구현\n\n## 스낵바의 지속 시간 및 상태 관리\n\n다음으로, 밀리초로 총 지속 시간을 계산하고 상태 변수를 사용하여 남은 시간을 관리합니다. 또한 LaunchedEffect를 사용하여 카운트다운을 처리하고 시간이 다 되면 스낵바를 해제합니다.\n\n```js\nval totalDuration = remember(durationInSeconds) { durationInSeconds * 1000 }\nvar millisRemaining by remember { mutableIntStateOf(totalDuration) }\n\nLaunchedEffect(snackbarData) {\n    while (millisRemaining \u003e 0) {\n        delay(40)\n        millisRemaining -= 40\n    }\n    snackbarData.dismiss()\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n40밀리초 간격을 사용하면 인간의 눈에 매끄러운 25 FPS 진행 업데이트가 발생합니다. 특정 요구 사항에 맞게 조정해 주셔도 좋습니다.\n\n## 작업 및 닫기 버튼 처리\n\n작업 및 닫기 버튼을 만들기 위해 snackbarData에서 제공된 정보를 활용합니다.\n\n```js\n// 작업 레이블이 제공되면 작업 버튼 정의\nval actionLabel = snackbarData.visuals.actionLabel\nval actionComposable: (@Composable () -\u003e Unit)? = if (actionLabel != null) {\n    @Composable {\n        TextButton(\n            colors = ButtonDefaults.textButtonColors(contentColor = actionColor),\n            onClick = { snackbarData.performAction() },\n            content = { Text(actionLabel) }\n        )\n    }\n} else {\n    null\n}\n\n// snackbar에 닫기 작업이 포함되어 있는 경우 닫기 버튼 정의\nval dismissActionComposable: (@Composable () -\u003e Unit)? = if (snackbarData.visuals.withDismissAction) {\n    @Composable {\n        IconButton(\n            onClick = { snackbarData.dismiss() },\n            content = {\n                Icon(Icons.Rounded.Close, null)\n            }\n        )\n    }\n} else {\n    null\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Snackbar 표시\n\n마지막으로, 모든 것을 함께 모아 Snackbar를 표시해 봅시다.\n\n```js\nSnackbar(\n    modifier = modifier.padding(12.dp), // Snackbar 주변에 패딩 적용\n    action = actionComposable,\n    actionOnNewLine = actionOnNewLine,\n    dismissAction = dismissActionComposable,\n    dismissActionContentColor = dismissActionContentColor,\n    actionContentColor = actionContentColor,\n    containerColor = containerColor,\n    contentColor = contentColor,\n    shape = shape,\n) {\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.spacedBy(12.dp)\n    ) {\n        SnackbarCountdown(\n            // 타이머 진행 상황 계산\n            timerProgress = millisRemaining.toFloat() / totalDuration.toFloat(),\n            // 남은 초 계산\n            secondsRemaining = (millisRemaining / 1000) + 1,\n            color = contentColor\n        )\n        // 메시지 표시\n        Text(snackbarData.visuals.message)\n    }\n}\n```\n\n축하합니다🥳! 성공적으로 만들었습니다👏. 전체 코드 구현은 GitHub Gist에서 확인할 수 있습니다🧑‍💻. 이제 이를 어떻게 활용할 수 있는지 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 광고\n\n외국어를 배우면서 새로운 어휘에 어려움을 겪고 계신가요? 그렇다면, 여러분의 학습 여정을 쉽고 편리하게 만들어 줄 이 단어 학습 앱을 꼭 확인해보시기를 강력히 추천합니다!\n\n![이미지](/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_1.png)\n\n# 실용적인 예시 💁\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 실제로 사용하여 사용자가 계정을 삭제하고 이 결정을 5초 동안 취소할 수 있는 예제를 만들어 봅시다.\n\n```kotlin\nBox(Modifier.fillMaxSize()) {\n    val context = LocalContext.current\n    val scope = rememberCoroutineScope()\n    // 스낵바 상태를 관리하는 SnackbarHostState를 정의합니다\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    Button(\n        modifier = Modifier.align(Alignment.Center),\n        onClick = {\n            scope.launch {\n                // 스낵바를 표시합니다\n                val result = snackbarHostState.showSnackbar(\n                    message = \"사용자 계정이 삭제되었습니다.\",\n                    actionLabel = \"취소\",\n                    duration = SnackbarDuration.Indefinite\n                )\n                // 스낵바 결과 처리\n                when (result) {\n                    SnackbarResult.Dismissed -\u003e {\n                        Toast.makeText(context, \"영구 삭제되었습니다\", Toast.LENGTH_SHORT).show()\n                    }\n                    SnackbarResult.ActionPerformed -\u003e {\n                        Toast.makeText(context, \"삭제 취소됨\", Toast.LENGTH_SHORT).show()\n                    }\n                }\n            }\n        }\n    ) {\n        Text(\"계정 삭제\")\n    }\n\n    // 스낵바를 표시하는 SnackbarHost를 생성합니다\n    SnackbarHost(\n        hostState = snackbarHostState,\n        modifier = Modifier.align(BottomCenter)\n    ) { data -\u003e\n        // CountdownSnackbar를 사용합니다\n        CountdownSnackbar(data)\n    }\n}\n```\n\n## 결과:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*7-Q98heTXND5N7XbAEKBYQ.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 내용도 좋아할지도요 👇\n\n이 기사를 읽어 주셔서 감사합니다! ❤️ 즐겁고 가치 있게 읽으셨길 바랍니다. 만약 좋았다면 박수 버튼👏을 눌러서 감사를 표현하고 Kappdev를 팔로우해서 더 많은 흥미로운 기사를 읽어보세요 😊\n\n코딩 즐기세요!\n\n![이미지](/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_2.png)","ogImage":{"url":"/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoCreateaCountdownSnackbarinAndroidwithJetpackCompose_0.png","tag":["Tech"],"readingTime":7},{"title":"도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법","description":"","date":"2024-07-01 20:03","slug":"2024-07-01-DotDashDesign","content":"\n\n## PathEffect로 Jetpack Compose에서 선을 특화하세요\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_0.png)\n\nJetpack Compose에서 UI를 생성할 때 선을 그리는 경우가 많습니다. 때로는 일부 공간을 구분하는 구분선으로, 때로는 더 복잡한 모양이나 디자인의 일부로 시각적으로 사용됩니다. 보통은 단순한 직선일 필요가 없을 때도 있습니다. 점 또는 대시를 사용하면 단순한 직선보다 덜 혹독한 효과를 줄 수 있으며 재미있는 모양이나 스타일 적용된 선 끝을 사용하면 디자인을 더욱 섬세하게 꾸밀 수 있습니다.\n\n만약 선이 모스 부호처럼 점과 대시로 표시되길 원한다면, 선의 스타일링 비밀을 해독하는 방법을 계속 읽어보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 사항.\n\n서로 이해하기 위해 기본적인 Jetpack Compose에서 선을 그리는 방법을 알려드리겠습니다:\n\n여기서 선은 수평적이며 캔버스 내부에 있으며 시작 및 끝 오프셋이 있습니다. strokeWidth는 픽셀 값을 설정하며 (제 경우에는 dp에서 변환된 값), 색상을 설정할 수 있습니다. 단색 대신 브러시를 사용하는 버전을 사용하면 더 흥미로운 색상 효과를 적용할 수 있습니다.\n\n![선](/assets/img/2024-07-01-DotDashDesign_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좌표가 (0,0)에서 시작하여 상단 왼쪽에 있으며 하단 오른쪽이 캔버스의 (너비, 높이) 지점입니다.\n\n![image](/assets/img/2024-07-01-DotDashDesign_2.png)\n\nJetpack Compose 및 DrawScope에서 Canvas에 그리는 방법에 대한 기본 안내서는 공식 문서를 확인해보세요.\n\n이제 선이 그려졌으니, 좀 더 정교하게 만드는 방법은 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선 끝 처리\n\n첫 번째로 할 수 있는 것은 선에 더 정교한 선 끝을 적용하는 것입니다.\n\n여기서 선택할 수 있는 옵션은 StrokeCap.Butt로, 이는 기본값으로 아무 확장 없이 직사각형 끝이 있는 것입니다. 또한, 선을 반원으로 연장하는 StrokeCap.Rounded와 선을 사각형 모양으로 연장하는 StrokeCap.Square이 있습니다 (이는 Butt처럼 보이지만 연장된 부분이 사각형 모양이다).\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모르는 것은 물어보세요. 실수를 겁내지 말아요. 편하게 물어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 형식으로 표 태그를 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모스 부호\n\n여기서는 dashPathEffect에 더 많은 간격을 추가하여 대시를 조금 더 복잡하게 만들 수 있습니다:\n\n재미있고 흥미로운 선을 얻을 수 있어요:\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스탬핑 시간\n\n만약 여러 줄로 이루어진 선을 원하지 않는다면 어떨까요? 대신에, stampedPathEffect를 사용하여 선 a아에 특정 모양을 찍어낼 수 있습니다. 여기서 원하는 모양을 구성하고, 모양 사이의 간격 (advance, 이전과 같은 상태 및 StampedPathEffectStyle을 사용하여 모양을 설정합니다.\n\n원 모양을 찍어내는 경우, 우리는 원형 점들의 라인을 \u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_7.png\" /\u003e 처럼 갖게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStampedPathEffectStyle.Translate은 선을 따라 움직이며 모양을 이전에 정의한 대로 유지합니다. 다른 유형의 StampedPathEffectStyle에 대해서는 나중에 설명하겠습니다. 직선을 보고 있을 때는 실제로 다른 유형이 적용되지 않습니다.\n\n좀 더 화려하게 만들기 위해 모양을 다양하게 만들어보세요:\n\n![image](/assets/img/2024-07-01-DotDashDesign_8.png)\n\n# 짹짹? 파도?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 이런 라인을 만드는 방법이 무엇이 있을까요:\n\n\n![image](/assets/img/2024-07-01-DotDashDesign_9.png)\n\n\n선을 그리기 위해 경로를 만들고 모든 지그재그를 포인트로 계산하고 그릴 수도 있지만, 이 경로 모양을 한 번 생성한 다음 위에서 한 것처럼 이 경로를 찍으면 됩니다.\n\n첫 번째 시도에서는 모양을 만들고 선을 따라 모양을 찍습니다 (전체 모양과 같은 너비의 진행을 사용하여)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 예상치 못한 (그러나 좋지 않은 결과는 아닙니다) 결과를 제공합니다:\n\n\n![image](/assets/img/2024-07-01-DotDashDesign_10.png)\n\n\n보통, 이를 경로로 그릴 때는 `DrawStyle.Stroke` 스타일을 사용하여 `drawPath`를 사용할 수 있고 선으로 직선으로 그립니다. 그러나 이것을 모양으로 사용하고 있기 때문에 자동으로 채워집니다. 이를 수정하기 위해 경로를 닫아주어야 합니다.\n\n이것을 줄에 넣으면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_11.png)\n\n여기서 실제 선이 점 (0,0)에서 그려지는 것을 알 수 있습니다. 이로 인해 지그재그 모양이 아래에 매달리고 실제 선의 끝에서 확장됩니다. 이를 더 쉽게 확인할 수 있습니다. 직선 경로를 함께 추가하면:\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_12.png)\n\n더욱 정확하게 그리고 싶다면 Offset을 사용하여 경로를 변환해 지정한 선 위에 정확하게 그릴 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n달콤한 톤으로 한국어로 번역하면:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_13.png\" /\u003e\n\n지그재그 선의 전체 코드:\n\n# 물론, 직선뿐만 아니라요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 직선을 그리는 것에 숙달했어요! 만약 이를 도형으로 넣고 싶다면 어떻게 해야 할까요? 그럼 drawRect나 drawCircle 또는 drawPath를 사용해서 원하는 모양을 얻을 수 있어요:\n\n![도형 이미지](/assets/img/2024-07-01-DotDashDesign_14.png)\n\n## 모서리에서는 어떻게 될까요?\n\n모서리에서 무슨 일이 일어나나요?\n\n이전에 StampedPathEffectStyle에 대해 언급했었는데, 이것은 직선만 그리지 않을 때 유용해요. 이는 라인이 방향을 바꿀 때 스탬프 경로에게 무엇을 해야 하는지 알려줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 하트 경로를 사용하여 서로 다른 스타일을 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_15.png\" /\u003e\n\n번역한 것은 직역이며, 하트 모양의 오프셋을 수정하지 않았기 때문에 모양이 정확한 직사각형 윤곽을 따르지 않아 넘어집니다. 회전 스타일은 그 넘어짐을 수정하는 방식으로 모양을 회전시키지만, 서로 더 가깝거나 멀리 떨어져 있는 일부 하트가 생성됩니다. Morph의 경우에는 진동 경로로 더 쉽게 확인할 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_16.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 차이가 더 두드러지며, 회전은 하트 경로에 대해서는 잘 작동하지만 스탬프 모양이 연결된 지그재그에서는 구멍이 모서리에 뚜렷하게 나타납니다(그리고 일부 지점에서 겹침). Morph는 모서리를 따라 변형하여 간극을 해결하고(대부분의 경우 — 좌하단 코너 참조) 보다 부드러운 선 효과를 제공합니다. 하트 경로와 마찬가지로 하트들도 모서리에서 조금 작아져 모서리 주변을 이동할 수 있도록 허용됩니다.\n\n# 선. 마스터했다.\n\n지금은 Jetpack Compose에서 선을 스타일링하고 흥미로운 모양과 경로에서 사용하는 여러 방법을 볼 수 있습니다.\n\n점과 대시로 즐거운 모스 부호를 만들고 사용자들에게 비밀 메시지를 보내세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 사용된 모든 샘플 코드를 내 GitHub 실험에서 찾을 수 있습니다:\n\n옹골지는 사람들은 PathEffect.chainPathEffect에 대해 논의하지 않았다는 것을 알아차릴 수도 있습니다. 솔직히 말해서, 저는 이를 잘 사용할 수 있는 좋은 예제를 구성하지 못했고 다른 사람들이 그것을 사용한 예제를 찾을 수도 없었습니다(심지어 Gemini도 시도했습니다!) 좋은 예제를 발견하면 제게 공유해 주시기 바랍니다.\n\n어쩌면 언젠가 chainPathEffect에 대한 따로 두 번째 파트를 작성할 수도 있을 것입니다!","ogImage":{"url":"/assets/img/2024-07-01-DotDashDesign_0.png"},"coverImage":"/assets/img/2024-07-01-DotDashDesign_0.png","tag":["Tech"],"readingTime":5},{"title":"Winglang으로 클라우드 마이그레이션 하기 파트 1","description":"","date":"2024-07-01 19:57","slug":"2024-07-01-PortedtoCloudwithWinglangPartOne","content":"\n\n## \"Hexagonal Architecture Explained\"에서의 Blue Zone Application\n\n![이미지](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_0.png)\n\n클라우드로 소프트웨어 응용 프로그램을 직접 이식하는 것은 종종 비효율적이며 유지보수가 어려운 코드로 이어집니다. 그러나 새로운 클라우드 지향 프로그래밍 언어 'Wing'을 Hexagonal Architecture와 결합하여 사용하면 성공적인 조합임이 입증되었습니다. 이 접근 방식은 비용, 성능, 유연성, 보안 사이에서 적절한 균형을 찾아냅니다.\n\n이번 시리즈에서는 주류 프로그래밍 언어에서 Winglang로의 다양한 응용 프로그램 이관 경험을 공유하겠습니다. 제가 Wing에서 Hexagonal Architecture를 구현한 첫 번째 경험은 \"Hello, Winglang Hexagon!\"이라는 기사에서 보고되었습니다. 이것은 이 조합에 대한 신뢰를 증명하는 데 충분했지만, 이것은 \"안녕, 세계!\" 인사 서비스를 단순화한 것이므로, 몇 가지 필수 요소가 없었고 이러한 방법이 규모에 맞게 작동하는 능력을 증명하기에 부족했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPart One에서는 최근 발표된 책 \"Hexagonal Architecture Explained\"에 소개된 “Blue Zone” 애플리케이션을 Java에서 Wing으로 이식하는 데 초점을 맞추었습니다. “Blue Zone” 애플리케이션은 많은 양의 코드베이스를 가져오며, 너무 복잡해서 다루기 어렵지는 않지만 대규모 애플리케이션 클래스를 잘 대표합니다. 또한, 이것이 처음에는 주류 Java로 작성되었다는 사실은 이러한 애플리케이션의 클라우드 네이티브 변형에 대한 흥미로운 사례 연구를 제공합니다.\n\n이 보고서는 2024년 4월에 안타깝게도 세상을 떠난 이 책의 공동 저자인 Juan Manuel Garrido de Paz에 대한 헌사입니다.\n\n계속 진행하기 전에 헥사고날 아키텍처 패턴의 기본 사항을 다시 살펴보겠습니다.\n\n# 헥사고날 아키텍처 패턴 기본 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"‘Hexagonal Architecture Explained’ 책의 두 번째 장을 참조하면 패턴에 대한 자세하고 공식적인 설명을 볼 수 있습니다. 여기서는 패턴의 주요 의미를 간략하게 되짚어 보겠습니다.\n\n'Hexagonal Architecture' 패턴은 소프트웨어에서 관심사를 분리하는 간단하면서도 실용적인 접근 방법을 제안합니다. 관심사를 분리하는 것이 왜 중요한가요? 소프트웨어 코드 베이스는 전달된 가치에 비해 작지만 빠르게 성장합니다. 챙겨야 할 것이 너무 많습니다. 인지적 통제를 유지하기 위해서는 기관 또는 범주별로 고수준의 조직이 필요합니다. 이 도전에 대처하기 위해 'Hexagonal Architecture' 패턴은 특정 소프트웨어 응용 프로그램에 관여하는 모든 요소를 다섯 가지 다른 범주로 분할하고 각각을 개별적으로 처리하는 것을 제안합니다:\n\n- 응용 프로그램 자체. 이 범주는 잠재적 고객과 사용자에게 제공되는 실제 가치를 캡슐화합니다. 이것이 소프트웨어가 처음부터 개발 및 사용되는 이유입니다. 때로는 핵심 또는 개발 중인 시스템(SuD)이라고도 불립니다. 이 부분에 대한 다른 이름으로 Computation이 있을 수 있습니다. 외부 입력이 처리되고 최종 결과물이 생성되는 곳입니다. 시각적으로 시스템의 응용 프로그램 부분은 육각형 형태로 표현됩니다. 이 모양에는 특별하거나 마법 같은 것은 없습니다. 'Hexagonal Architecture Explained’ 책의 저자들이 설명하는대로:\n\n2. 응용 프로그램과 통신하는 외부 상호작용자들. 이들은 인간 최종 사용자, 전자 장치 또는 다른 응용 프로그램일 수 있습니다. 원래 패턴은 주요(또는 주도) 상호작용자와 (Driving) — 응용 프로그램과 상호작용을 시작하는 사람들, 그리고 보조(또는 기동) 상호작용자 — 응용 프로그램이 통신을 시작하는 사람들로 추가 분리를 제안합니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 포트 — 주요 역할자가 사용할 수 있는 형식 인터페이스에 대한 공식 사양의 멋진 이름(주행 포트라고도 함) 또는 부차 역할자가 구현해야 하는 것(구동 포트라고도 함)으로, 응용 프로그램과 통신하기 위해. 인터페이스 동사의 공식 사양 외에도(예: 주차권 구매) 포트는 이러한 인터페이스를 통해 교환되는 데이터 구조에 대한 자세한 사양 제공.\n\n4. 어댑터 — 외부 역할자와 포트 간의 간격을 메꾸는 역할. 이름에서 알 수 있듯이, 어댑터는 유의미한 계산을 수행하는 것이 아니라, 기본적으로 역할자가 이해할 수 있는 형식으로 데이터를 변환하거나 역할자가 이해할 수 있는 형식으로 데이터를 변환.\n\n5. 설정자 — 외부 역할자를 해당 어댑터를 사용하여 포트를 통해 응용 프로그램에 연결함으로 모든 것을 하나로 규합. 하는 아키텍처적 결정과 가격/성능/유연성 요구사항에 대한 처리하려는 결정에 따라, 특정 구성을 응용 프로그램 배포 전에 정적으로 생성하거나 응용 프로그램 실행 중 동적으로 생성할 수 있음.\n\n일반적인 신념과는 달리, 이 패턴은 한 범주, 예를 들어 응용 프로그램이 다른 것보다 중요하다거나 다른 것이 작아야 한다는 것을 의미하지 않음을 완전히 말하고 있지 않습니다. 포트와 어댑터가 없으면 어떤 응용 프로그램도 실제로 사용될 수 없습니다. 상대적인 크기는 확장성, 성능, 비용, 가용성 및 보안과 같은 비기능적 요구사항에 따라 종종 결정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패턴은 한 번에 한 가지 문제에 집중하여 복잡성과 위험을 줄이는 것을 제안합니다. 다른 측면을 일시적으로 무시하는 것을 시사합니다. 또한 동일한 계산에 대한 여러 구성의 존재를 보장하는 실용적인 방법을 시사합니다. 각 구성은 테스트 자동화이거나 다른 환경에서의 작동과 같은 특정한 필요성에 대응합니다.\n\n아래 \"Hexagonal Architecture Explained\" 책에서 가져온 그림은 패턴의 모든 주요 요소를 잘 요약합니다:\n\n![Hexagonal Architecture](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_1.png)\n\n# \"Blue Zone\" 샘플 애플리케이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션 README에서:\n\n이 애플리케이션을 선택한 이유는 두 가지입니다. 첫째로, \"헥사고날 아키텍처 설명\" 책에서 권장하는 대표적인 예제로 소개되었습니다. 둘째로, 이 애플리케이션은 원래 Java로 개발되었습니다. Wing 프로그래밍 언어를 사용하여 꽤 복잡한 Java 애플리케이션을 클라우드로 이관하는 과정이 무엇인지 궁금해서 선택하게 되었습니다.\n\n# 어디서부터 시작해야 하나요?\n\n\"헥사고날 아키텍처 설명\" 책은 제 4.9장 \"개발 순서는 무엇인가?\"에서 합리적인 권고 사항을 제공합니다. \"테스트부터 테스트\"로 시작하여 계속 진행하는 것이 합리적입니다. 그러나 대부분의 소프트웨어 엔지니어들이 하는 것처럼 제가 한 일은 Java 코드를 Wing으로 번역하는 작업으로 시작했습니다. 일부를 제외한 며칠간의 업무 시간을 투자하여 Wing에서 로컬에서 외부 인터페이스를 시뮬레이트하면서 작동하는 것으로 진행 상태에 이르렀습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기술적으로는 작동했지만 결과적으로 코드 크기가 애플리케이션의 크기에 비해 너무 커서 이해하기 어렵고 미적으로 매력이 없으며 완전히 Wingish하지 않았어. 그래서 나는 두 주 동안 리팩터링 주기를 시작했고 Wing 언어와 클라우드 환경의 특정 요소에 맞춰 핵심 패턴 아이디어를 가장 관용적으로 표현하기 위해 노력했어.\n\n다음으로 오는 것은 내가 작업한 방식과는 다르다. 그것은 코드의 큰 부분이 생산되고 평가되고 폐기되는 혼돈스런 순방향 이동의 긴 연속이었어. 이런 일은 주로 익숙하지 않은 기술과 도메인을 다룰 때 소프트웨어 개발 중에 발생해.\n\n마침내, 다음에는 조금 덜 고통스럽고 더 생산적일 수 있는 좀 더 체계적이고 체계적인 프로세스로 서서히 체계화될 수 있는 무언가를 고안해냈어. 그래서 다음 번에는 현실에 일어난 것이 아닌 다음 번에 사용할 개념적으로 바람직한 순서로 내 연구 결과를 제시할 예정이야.\n\n# 테스트부터 시작하라.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 정확하게 하려면, 시스템의 아키텍처적으로 중요한 사용 사례에 대한 일련의 수용 테스트로 시작하는 것이 가장 좋고 비용 효율적인 방법입니다. \"Hexagonal Architecture Explained\" 책의 5.1 장인 \"이것이 사용 사례와 어떻게 관련되는가?\"에서는 사용 사례 모델링과 육각형 아키텍처 사이의 깊은 연결에 대해 자세히 설명하고 있습니다. 꼼꼼히 읽을 가치가 있습니다.\n\n심지어 이전 진술도 100% 정확하지는 않았습니다. 우리는 주요 외부 주체를 식별한 후 그들이 시스템과 상호 작용하는 가장 특징적인 방법으로 시작해야 합니다. \"블루 존\" 애플리케이션의 경우 주요 외부 주체로는 다음 두 가지가 있습니다:\n\n- 카드 운전사\n- 주차 감시관\n\n카드 운전사 주체의 경우, 기본 사용 사례는 \"티켓 구매\"이며 주차 감시관 주체의 경우, 기본 사용 사례는 \"차량 확인\"일 것입니다. 이러한 사용 사례의 구현을 설명함으로써 우리는 보조 외부 주체와 그 밖의 요소를 식별할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n분석 결과로 얻은 초기 사용 사례 모델은 아래에 제시되어 있습니다:\n\n![image](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_2.png)\n\n위 다이어그램에는 Payment Service와 같은 하나의 보조 액터만 포함되어 있으며 데이터베이스와 같은 내부 보조 액터는 포함되어 있지 않습니다. 이러한 기술 요소들은 결국 Application에서 일치하는 Driven Ports에 의해 격리될 것이지만, 적어도 Use Case 액터의 전통적인 해석에서는 Use Case 외부 액터를 대표하지 않습니다.\n\n개발을 시작하기 전에 사용 사례 수용 기준을 명시하는 것은 내부 재구성을 수행하는 동안 시스템의 안정성을 보장하기 위한 매우 효과적인 기술입니다. \"Blue Zone\" 애플리케이션의 경우, 사용 사례 수락 테스트는 Cucumber for Java 프레임워크를 사용하여 Gherkin 언어로 지정되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 Wing을 위한 Cucumber 프레임워크가 하나도 없습니다. 그 이유는 매우 어린 언어이기 때문입니다. JavaScript용 공식 Cucumber가 존재하고 TypeScript Cucumber Tutorial도 있지만, 이 기술에 대한 조사를 연기하고 Wing에서 몇 가지 테스트를 직접 복제해 보기로 결정했습니다.\n\n놀랍게도 가능했고 제 목적을 위해 꽤 잘 작동했습니다. 다음은 Wing에서 완전히 명시된 Buy Ticket 사용 사례 happy path 수용 테스트의 예시입니다. 잘 작동했어요!\n\n아래는 구입 티켓 사용 사례에 대한 happy path 수용 테스트의 예시입니다. 이는 Wing에서 완전히 명시된 Buy Ticket 사용 사례 happy path 수용 테스트의 예시입니다:\n\n```js\nbring \"../src\" as src;\nbring \"./steps\" as steps;\n\n/*\n사용 사례: Buy Ticket\n  AS\n  a car driver\n  I WANT TO\n  a) obtain a list of available rates\n  b) submit a \"buy a ticket\" request with the selected rate\n  SO THAT\n  I can park the car without being fined\n*/\nlet _configurator = new src.Configurator(\"BuyTicketFeatureTest\");\nlet _testFixture = _configurator.getForAdministering();\nlet _systemUnderTest = _configurator.getForParkingCars();\nlet _ = new steps.BuyTicketTestSteps(_testFixture, _systemUnderTest);\n\ntest \"Buy ticket for 2 hours; no error\" {\n    /* Given */\n        [\"name\",    \"eurosPerHour\"],\n        [\"Blue\",    \"0.80\"],\n        [\"Green\",   \"0.85\"],\n        [\"Orange\",  \"0.75\"]\n    ]);\n    _.next_ticket_code_is(\"1234567890\");\n    _.current_datetime_is(\"2024/01/02 17:00\");\n    _.no_error_occurs_while_paying();\n    /* When */\n    _.I_do_a_get_available_rates_request();\n    /* Then */\n    _.I_should_obtain_these_rates([\n        [\"name\",    \"eurosPerHour\"],\n        [\"Blue\",    \"0.80\"],\n        [\"Green\",   \"0.85\"],\n        [\"Orange\",  \"0.75\"]\n    ]);\n    /* When */\n    _.I_submit_this_buy_ticket_request([\n        [\"carPlate\", \"rateName\", \"euros\", \"card\"],\n        [\"6989GPJ\",  \"Green\",    \"1.70\",  \"1234567890123456-123-062027\"]\n    ]);\n    /* Then */\n    _.this_pay_request_should_have_been_done([\n        [\"euros\", \"card\"],\n        [\"1.70\",  \"1234567890123456-123-062027\"]\n    ]);\n    /* And */\n    _.this_ticket_should_be_returned([\n        [\"ticketCode\", \"carPlate\", \"rateName\", \"startingDateTime\", \"endingDateTime\",   \"price\"],\n        [\"1234567890\", \"6989GPJ\",  \"Green\",    \"2024/01/02 17:00\", \"2024/01/02 19:00\", \"1.70\"]\n    ]);\n    /* And */\n    _.the_buy_ticket_response_should_be_the_ticket_stored_with_code(\"1234567890\");\n}\n```\n\n멋진 작업! 이 모든 것을 한 번에 처리하기에는 상당히 많은 것이 있습니다. 하나씩 해결해 나가 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트 구조\n\n위의 테스트는 특정 프로젝트 폴더 구조를 가정하고 Wing 모듈 및 import 규칙을 반영합니다.\n\n테스트 소스의 처음 두 줄에서 프로젝트에는 모든 소스 코드가 위치한 src와 모든 테스트가 위치한 test 두 개의 주요 폴더가 있다는 결론을 내릴 수 있습니다. 더하여, test\\steps 하위 폴더가 있어 개별 테스트 단계 구현이 유지됩니다.\n\n테스트 소스의 다음 세 줄에서는 사전 설정(Configurator) 객체를 할당하고 그 중 두 개의 포인터를 추출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- _testFixture는 테스트 설정을 담당하는 사전 클래스를 가리킵니다.\n- _systemUnderTest는 운전자 대상 주 포트 인터페이스를 가리킵니다.\n\n다음으로, 우리는 개별 단계를 구현하는 BuyTicketTestSteps 객체를 할당합니다. 일반적으로, 이 객체는 거의 보이지 않는 밑줄 이름을 가지며, 전체 테스트 가독성을 향상시킵니다. 이는 일반 목적 호스트 언어에 내장된 도메인 특화 언어(DSL)를 개발하는 일반적인 기술입니다.\n\n중요한 점은 제 경우에는 그렇지 않았지만, 간단한 src 및 test\\steps 폴더 구조 및 다른 아키텍처 결정을 주도하는 간단한 테스트 설정으로 프로젝트를 시작하는 것이 완전히 가능하다는 것입니다.\n\n물론, 단계가 구현되지 않았다면 테스트는 심지어 컴파일조차 되지 않을 것입니다. 진행하기 위해서는 BuyTicketTestSteps 클래스 내부를 살펴보아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트 단계 클래스\n\n\"Buy Ticket Use Case\"를 위한 테스트 단계 클래스는 아래에 제시되어 있습니다:\n\n```js\nbring expect;\nbring \"./Parser.w\" as parse;\nbring \"./TestStepsBase.w\" as base;\nbring \"../../src/application/ports\" as ports;\n\n\npub class BuyTicketTestSteps extends base.TestStepsBase {\n    _systemUnderTest: ports.ForParkingCars;\n    inflight var _currentAvailableRates: Set\u003cports.Rate\u003e;\n    inflight var _currentBoughtTicket: ports.Ticket?;\n\n    new(\n        testFixture: ports.ForAdministering, \n        systemUnderTest: ports.ForParkingCars\n    ) {\n        super(testFixture);\n        this._systemUnderTest = systemUnderTest;\n    }\n    \n    inflight new() {\n        this._currentBoughtTicket = nil;\n        this._currentAvailableRates = Set\u003cports.Rate\u003e[];\n    }\n\n    pub inflight the_existing_rates_in_the_repository_are(\n        sRates: Array\u003cArray\u003cstr\u003e\u003e\n    ): void {\n        this.testFixture.initializeRates(parse.Rates(sRates).toArray());\n    }\n\n    // 나머지 코드는 생략\n}\n```\n\n이 클래스는 간단합니다! 사용자로 하여금 입력 데이터를 Array`Array`str``로 균일하게 해석하여, 응용프로그램 특정 데이터 구조로 변환한 후, 이를 testFixture 또는 _systemUnderTest 객체로 전송하여 중간 결과를 유지하고 적절한 곳에서 예상 대비 실제 결과를 비교합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유일하게 주의할 점은 사전 점검과 비행 정의를 올바르게 처리하는 것입니다. 이것을 올바르게 하도록 도와준 Cristian Pallares에게 감사드립니다.\n\n우리는 명확하게 구분된 역할을 가진 세 가지 추가 요소를 가지고 있습니다:\n\n- 파서: 균일한 문자열 입력 배열을 응용프로그램 특정 데이터 구조로 변환하는 역할을 담당합니다.\n- 테스트 픽스처: 사전 조건 설정 및 사후 조건 확인을 위한 시스템과의 백도어 통신을 담당합니다.\n- 시스템 테스트 대상: 응용프로그램 논리를 구현하는 역할을 담당합니다.\n\n각각을 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 파서\n\n아래는 **Parser** 모듈의 소스 코드입니다:\n\n```js\nbring structx;\nbring datetimex;\nbring \"../../src/application/ports\" as ports;\n\n\npub class Util {\n    pub inflight static Rates(sRates: Array\u003cArray\u003cstr\u003e\u003e): Set\u003cports.Rate\u003e {\n        return unsafeCast(\n            structx.fromFieldArray(\n                sRates, \n                ports.Rate.schema()\n            )\n        );\n    }\n\n    pub inflight static BuyRequest(\n     sRequest: Array\u003cArray\u003cstr\u003e\u003e\n   ): ports.BuyTicketRequest {\n        let requestSet: Set\u003cports.BuyTicketRequest\u003e = unsafeCast(\n            structx.fromFieldArray(\n                sRequest, \n                ports.BuyTicketRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n\n    pub inflight static Tickets(\n     sTickets: Array\u003cArray\u003cstr\u003e\u003e\n   ): Set\u003cports.Ticket\u003e {\n        return unsafeCast(\n            structx.fromFieldArray(\n                sTickets, \n                ports.Ticket.schema(), \n                datetimex.DatetimeFormat.YYYYMMDD_HHMM\n            )\n        );\n    }\n\n    pub inflight static Ticket(sTicket: Array\u003cArray\u003cstr\u003e\u003e): ports.Ticket {\n        return Util.Tickets(sTicket).toArray().at(0);\n    }\n\n    pub inflight static PayRequest(\n     sRequest: Array\u003cArray\u003cstr\u003e\u003e\n   ): ports.PayRequest {\n        let requestSet: Set\u003cports.PayRequest\u003e = unsafeCast(\n            structx.fromFieldArray(\n                sRequest, \n                ports.PayRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n\n    pub inflight static CheckCarRequest(\n     sRequest: Array\u003cArray\u003cstr\u003e\u003e\n   ): ports.CheckCarRequest {\n        let requestSet: Set\u003cports.CheckCarRequest\u003e = unsafeCast(\n            structx.fromFieldArray(\n                sRequest, \n                ports.CheckCarRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n    \n    pub inflight static CheckCarResult(\n     sResult: Array\u003cArray\u003cstr\u003e\u003e\n   ): ports.CheckCarResult {\n        let resultSet: Set\u003cports.CheckCarResult\u003e = unsafeCast(\n            structx.fromFieldArray(\n                sResult, ports.CheckCarResult.schema()\n            )\n        );\n        return resultSet.toArray().at(0);\n    }\n\n    pub inflight static DateTime(dateTime: str): std.Datetime {\n        return datetimex.parse(\n            dateTime, \n            datetimex.DatetimeFormat.YYYYMMDD_HHMM\n        );\n    }\n\n    pub inflight static PaymentError(error: str): ports.PaymentError {\n        return Map\u003cports.PaymentError\u003e{\n            \"NONE\" =\u003e ports.PaymentError.NONE,\n            \"GENERIC_ERROR\" =\u003e ports.PaymentError.GENERIC_ERROR,\n            \"CARD_DECLINED\" =\u003e ports.PaymentError.CARD_DECLINED\n        }.get(error);\n    }\n}\n```\n\n이 클래스는 알고리즘적으로는 정교하지 않지만 매우 중요한 아키텍처적 결정을 반영하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, src\\\\application\\ports 폴더에 위치한 시스템 Ports에 대한 종속성을 선언합니다. “헥사고날 아키텍처 설명서” 책의 4.8장인 “내 파일을 어디에 넣어야 할까요?”에서는 명확한 주장을 합니다:\n\n그러나 “패턴의 의도와 일치하지 않는 폴더 구조가 손상을 일으키는 것을 관찰했습니다”라고 경고합니다. Java와 같은 강력한 형식의 언어에 대해, 주행 및 종속 Ports의 사양을 따로 유지하는 것을 권장합니다.\n\n저도 그러한 구조로 시작했지만, 곧죽 코드의 크기를 키우고 Wing 모듈과 import 규칙을 효과적으로 활용할 수 없게 만든다는 것을 깨달았습니다. 이에 따라, 모든 Ports를 한 전용 폴더에 유지하기로 결정했습니다. 현재 애플리케이션의 크기를 고려하면, 이러한 결정은 타당해 보입니다.\n\n둘째, 명시되지 않은 Wing 모듈과 import 기능을 활용하여, Util이라는 클래스의 모든 공용 정적 inflight 메서드를 클라이언트 모듈에서 직접 액세스할 수 있게 하여 코드 가독성을 개선합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째로, 필요한 몇 가지 기능을 보완하기 위해 개발된 두 가지 Wing 표준 라이브러리 확장인 datetimex와 structx를 사용합니다. 이러한 확장 기능은 제가 여기에서 보고한 \"Winglang 미들웨어 탐색\" 프로젝트 endor.w의 일부였습니다.\n\n이러한 확장 기능에 대한 정당성은 Port 인터페이스 및 데이터를 표현하는 핵심 아키텍처 결정을 살펴볼 때 명확해질 것입니다.\n\n# Port 인터페이스 및 데이터 표현\n\nJava와 같은 전통적인 강력한 형식의 객체 지향 언어는 모든 도메인 요소를 객체로 캡슐화하는 것을 주장합니다. 이 조언을 따른다면 Ticket 객체는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npub inflight class Ticket {\n  pub ticketCode: str;\n  pub carPlate: str;\n  pub rateName: str;\n  pub startingDateTime: std.Datetime;\n  pub endingDateTime: std.Datetime;\n  pub price: num;\n  pub paymentId: str;\n  \n  new (ticketCode: str, ...) {\n    this.ticketCode = ticketCode;\n    ...\n  }\n  pub toJson(): Json {\n    return Json {\n       ticketCode: this.ticketCode,\n       ...\n  }\n  pub static fromJson(data: Json): Ticket {\n    return new Ticket(\n      data.get(\"ticketCode\").asStr(),\n      ...\n   );\n  }\n  pub toFieldArray(): Array\u003cstr\u003e {\n    return [\n      this.ticketCode,\n      ...\n    ];\n  }\n  pub static fromFieldArray(records: Array\u003cArray\u003cstr\u003e\u003e): Set\u003cTicket\u003e {\n    let result = new MutSet\u003cTicket\u003e[];\n    for record in records {\n      result.add(new Ticket(\n        record.at(0),\n        ...\n      );\n    }\n    return result.copy();\n }\n}\n```\n\n이런 방식은 데이터 필드당 초기화 및 변환을 위해 코드당 6줄의 추가 코드를 도입하고 일부 고정된 메서드 정의 오버헤드가 발생합니다. 이로 인해 상당한 보일러플레이트 오버헤드가 발생합니다.\n\n자바 및 파이썬과 같은 주류 언어는 데코레이터, 추상 베이스 클래스 또는 메타 클래스와 같은 다양한 메타 프로그래밍 자동화 도구를 사용하여 이러한 번거로움을 완화하려고 노력합니다.\n\nWing에서는 Wing 표준 라이브러리의 소량 조정만 이루어지면 이러한 것들이 비효율적이고 불필요함이 입증되었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n티켓 데이터 구조를 다음과 같이 정의할 수 있습니다:\n\n```rust\npub struct Ticket {                 //객체를 나타내는 데이터 구조\n                                    //주차 티켓의 데이터를 포함함:\n    ticketCode: str;                //티켓의 고유 식별자\n                                    //필요한 경우 선행 0이 포함된 10자리 숫자\n    carPlate: str;                  //주차된 차량의 차량 번호\n    rateName: str;                  //차량이 주차된 지역의 요금 이름\n    startingDateTime: std.Datetime; //주차 기간이 시작되는 시간\n    endingDateTime: std.Datetime;   //주차 기간이 만료되는 시간\n    price: num;                     //티켓에 지불한 유로 금액\n    paymentId: str;                 //티켓을 받기 위해 수행된 결제의 고유 식별자\n}\n```\n\n## 주차 차량용 포트\n\n\"Hexagonal Architecture Explained\" 책의 권장 사항을 따라, 포트 명명은 For`ActorName` 컨벤션을 채택합니다. 다음은 주차 차량용 포트가 정의된 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub struct BuyTicketRequest {  // 차량을 주차하기 위한 티켓 구매에 필요한 입력 데이터:\n    carPlate: str;    // 주차된 차량의 차량번호\n    rateName: str;    // 주차된 지역의 요금 이름\n    euros: num;       // 지불할 유로 금액\n    card: str;        // 지불에 사용되는 카드, 'n-c-mmyyyy' 형식으로, 여기서\n                      // 'n'은 카드 번호 (16자리)\n                      // 'c'는 확인 코드 (3자리),\n                      // 'mmyyyy'는 만료 월과 년 (6자리)\n}\n\n/**\n * DRIVING PORT (제공된 인터페이스)\n */\npub 인터페이스 ForParkingCars {\n    /**\n     * 도시의 규제된 지역에서 자동차를 주차하는 데 필요한 요금을 포함하는 세트를 반환합니다.\n     * 요금이 없는 경우 빈 세트가 반환됩니다.\n     */\n    getAvailableRates(): Set\u003crate.Rate\u003e;\n\n    /**\n     * 주차 요금을 지불하고, 요금이 적용된 지역에서 자동차를 주차하기 위한 티켓을 구매하여 리포지토리에 저장합니다.\n     * 티켓의 유효 기간은 현재 날짜 및 시간부터 시작되며, 유로 금액을 기준으로 요금을 적용하여 분 단위로 계산됩니다.\n     * @param request 티켓을 구매하는 데 필요한 입력 데이터\n     *      @see BuyTicketRequest\n     * @return 요금이 적용된 지역에서 자동차를 주차하기 위한 유효한 티켓,\n     *    카드를 사용하여 유로 금액을 지불합니다.\n     *    티켓은 지불한 식별자에 대한 참조를 보유합니다.\n     * @throws BuyTicketRequestException\n     *    요청에 있는 입력 데이터가 유효하지 않은 경우\n     * @throws PayErrorException\n     *    지불하는 동안 오류가 발생한 경우\n     */\n    buyTicket (request: BuyTicketRequest): ticket.Ticket;\n}\n```\n\n티켓 및 요금 객체와 마찬가지로 BuyTicketRequest 객체는 위에서 설명한 자동 형변환 인프라에 의존하는 일반 Wing 구조체로 정의됩니다.\n\nForParkingCars는 Wing 인터페이스로 정의됩니다. 원래의 \"Blue Zone\" 구현과 달리이 구현에는 BuyTicketRequest 유효성 검사가 포트 사양에 포함되어 있지 않습니다. 이것은 일부로 이루어졌습니다.\n\n강력한 객체 캡슐화는 validate() 메서드를 BuyTicketRequest 클래스에 포함하는 것을 권장하지만, 여기서 사용된 열린 불변 데이터 구조와 같이 해당 위치에서 수행할 수 있습니다. 반면에 포트 사양에 요청 유효성 검사 논리를 포함하는 것은 구현 세부 사항을 너무 일찍 가져오는 문제가 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 포트 관리\n\n이 기능은 testFixture 기능을 제공하기 위해 사용되며 길지만 완전히 직관적입니다:\n\n```js\nbring \"./Rate.w\" as rate;\nbring \"./Ticket.w\" as ticket;\nbring \"./ForPaying.w\" as forPaying;\n\n\n/**\n * DRIVING PORT (제공된 인터페이스)\n * 초기화, 리포지토리에서 데이터 로드, 앱에서 사용되는 서비스 구성 등과 같은 관리 작업을 수행하는 데 사용됨.\n * 일반적으로 다음에서 사용됨:\n *      - 테스트(testing actors)에서 테스트 픽스처(tested actors)를 설정하기 위해.\n *      - 앱 초기화를 위한 시작.\n */\n pub inflight interface ForAdministering {\n\n    /**\n    * 주어진 요율을 데이터 리포지토리에로드하여,\n    * 이전에 존재하던 요율을 삭제함.\n    */\n    initializeRates(newRates: Array\u003crate.Rate\u003e): void;\n\n    /**\n    * 주어진 티켓을 데이터 리포지토리에로드하여,\n    * 이전에 존재하던 티켓을 삭제함.\n    */\n    initializeTickets(newTickets: Array\u003cticket.Ticket\u003e): void;\n\n    /**\n    * 주어진 티켓 코드를 요청 시 반환될 다음 코드로 설정함.\n    */\n    changeNextTicketCode(newNextTicketCode: str): void;\n\n    /**\n    * 주어진 코드로 저장된 티켓을 리포지토리에서 반환함.\n    */\n    getStoredTicket(ticketCode: str): ticket.Ticket;\n\n    /**\n    * \"pay\" 메서드에 대한 마지막 요청을 반환함.\n    */\n    getLastPayRequest(): forPaying.PayRequest;\n\n    /**\n    * \"pay\" 메서드에서 반환된 마지막 응답을 반환함.\n    * 이는 지불 내역의 식별자임.\n    */\n    getLastPayResponse(): str;\n\n    /**\n    * 지불 에러의 확률을 매개변수로 지정된 \"퍼센트\"로 설정함.\n    */\n    setPaymentError(errorCode: forPaying.PaymentError): void;\n\n    /**\n    * \"pay\" 메서드 실행 시 발생한 에러 코드를 반환함.\n    */\n    getPaymentError(): forPaying.PaymentError;\n\n    /**\n    * 주어진 날짜-시각을 현재 날짜-시각으로 설정함.\n    */\n    changeCurrentDateTime(newCurrentDateTime: std.Datetime): void;\n\n}\r\n```\n\n이제, 애플리케이션 로직 구현을 자세히 살펴보아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구현 세부 정보\n\n## 주차 차량 백엔드용\n\n```js\nbring \"../../application/ports\" as ports;\nbring \"../../application/usecases\" as usecases;\n\n\npub class ForParkingCarsBackend impl ports.ForParkingCars {\n    _buyTicket: usecases.BuyTicket;\n    _getAvailableRates: usecases.GetAvailableRates;\n\n    new(\n        dataRepository: ports.ForStoringData,\n        paymentService: ports.ForPaying,\n        dateTimeService: ports.ForObtainingDateTime\n    ) {\n        this._buyTicket = new usecases.BuyTicket(\n          dataRepository, paymentService, dateTimeService);\n        this._getAvailableRates = new usecases.GetAvailableRates(\n          dataRepository);\n    }\n\n    pub inflight getAvailableRates(): Set\u003cports.Rate\u003e {\n        return this._getAvailableRates.apply();\n    }\n\n    pub inflight buyTicket(request: ports.BuyTicketRequest): ports.Ticket {\n        return this._buyTicket.apply(request);\n    }\n}\n```\n\n이 클래스는 src/outside/backend 폴더에 위치하고 ports.ForParkingCars 인터페이스의 구현을 제공합니다. 이 인터페이스는 직접 함수 호출에 적합합니다. 두 가지 추가 서드파티 포트를 가정하며, 실제 구현은 BuyTicket 및 GetAvailableRates 두 Use Case 구현에 위임됩니다. BuyTicket Use Case 구현은 핵심 시스템 로직이 있는 곳이므로 해당 부분을 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## BuyTicket Use Case\n\n```js\n수정된 내용:\n\n수정된 내용 없음\n\n기능:\n\n- 요청 유효성 검사\n- 새 티켓 구매\n- 티켓 레코드 생성\n- 데이터베이스에 티켓 레코드 저장\n```\n\n“Buy Ticket” Use Case 구현 클래스는 src/application/usescases 폴더에 있습니다. 이 클래스는 다음 Use Case 로직을 실행하는 데 책임을지는 즉시 함수를 반환합니다:\n\n- 요청 유효성 검사\n- 새 티켓 구매\n- 티켓 레코드 생성\n- 데이터베이스에 티켓 레코드 저장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUse Cases를 인플라이트 함수로 구현하는 주된 이유는 모든 Wing 이벤트 핸들러가 인플라이트 함수이기 때문입니다. 직접 함수 호출은 로컬 테스트에 유용하지만, 실제 배포에서는 일반적으로 HTTP REST 또는 GraphQL API 호출일 것입니다.\n\nBuyTicketRequest의 실제 유효성 검사는 Verifier.w 모듈 내의 보조 Util 클래스로 위임됩니다. 이는 각 필드의 유효성 검사가 매우 상세하고 많은 저수준 구체적인 사항을 포함하여 전반적인 유스케이스 논리 이해에 적은 기여를 하는 경우가 많기 때문입니다.\n\n## 모든 구성 요소 통합하기\n\n\"Hexagonal Architecture Explained\" 책의 권장사항을 따르면, 이는 Configurator 클래스 내에서 구현됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport util;\nimport endor;\nimport outside from \"./outside\";\nimport ports from \"./application/ports\";\n\nenum ApiType {\n    DIRECT_CALL,\n    HTTP_REST\n}\n\nenum ProgramType {\n    UNKNOWN,\n    TEST,\n    SERVICE\n}\n\nclass Configurator implements outside.BlueZoneApiFactory {\n    _apiFactory: outside.BlueZoneApiFactory;\n\n    constructor(name: string) {\n        let mockService = new outside.mock.MockDataRepository();\n        let programType = this._getProgramType(name);\n        let mode = this._getMode(programType);\n        let apiType = this._getApiType(programType, mode);\n        this._apiFactory = this._getApiFactory(\n            name,\n            mode, \n            apiType,\n            mockService,\n            mockService,\n            mockService\n        );\n    }\n\n    _getProgramType(name: string): ProgramType {\n        if (name.endsWith(\"Test\")) {\n            return ProgramType.TEST;\n        } else if (name.endsWith(\"Service\") || name.endsWith(\"Application\")) {\n            return ProgramType.SERVICE;\n        } else if (std.Node.of(this).app.isTestEnvironment) {\n            return ProgramType.TEST;\n        }\n        return ProgramType.UNKNOWN;\n    }\n\n    _getMode(programType: ProgramType): endor.Mode {\n        if (let mode = util.tryEnv(\"MODE\")) {\n            return {\n                \"DEV\": endor.Mode.DEV,\n                \"TEST\": endor.Mode.TEST,\n                \"STAGE\": endor.Mode.STAGE,\n                \"PROD\": endor.Mode.PROD\n            }[mode];\n        } else if (programType == ProgramType.TEST) {\n            return endor.Mode.TEST;\n        } else if (programType == ProgramType.SERVICE) {\n            return endor.Mode.STAGE;\n        }\n        return endor.Mode.DEV;\n    }\n\n    _getApiType(programType: ProgramType, mode: endor.Mode): ApiType {\n        if (let apiType = util.tryEnv(\"API_TYPE\")) {\n            return {\n                \"DIRECT_CALL\": ApiType.DIRECT_CALL,\n                \"HTTP_REST\": ApiType.HTTP_REST\n            }[apiType];\n        } else if (programType == ProgramType.SERVICE) {\n            return ApiType.HTTP_REST;\n        }\n        let target = util.env(\"WING_TARGET\");\n        if (target.contains(\"sim\")) {\n            return ApiType.DIRECT_CALL;\n        }\n        return ApiType.HTTP_REST;        \n    }\n\n    _getApiFactory(\n        name: string, \n        mode: endor.Mode,\n        apiType: ApiType,\n        dataService: ports.ForStoringData,\n        paymentService: ports.ForPaying,\n        dateTimeService: ports.ForObtainingDateTime\n    ): outside.BlueZoneApiFactory {\n        let directCall = new outside.DirectCallApiFactory(\n            dataService, \n            paymentService, \n            dateTimeService\n        );\n        if (apiType == ApiType.DIRECT_CALL) {\n            return directCall;\n        } else if (apiType == ApiType.HTTP_REST) {\n            return new outside.HttpRestApiFactory(\n                name,\n                mode,\n                directCall\n            );\n        }\n    }\n\n    getForAdministering(): ports.ForAdministering {\n        return this._apiFactory.getForAdministering();\n    }\n\n    getForParkingCars(): ports.ForParkingCars {\n        return this._apiFactory.getForParkingCars();\n    }\n\n    getForIssuingFines(): ports.ForIssuingFines {\n        return this._apiFactory.getForIssuingFines();\n    }\n\n}\n```\n\n이건 실험적인, 아직 최종적이지는 않은 구현입니다. 하지만 프로덕션 배포 요구 사항을 해결하기 위해 확장할 수 있습니다. Wing 사전 검사 도구를 활용하여 정적 시스템 구성을 채택했습니다.\n\n이 구현에서 특수 MockDataStore 객체가 모든 세컨더리 포트를 구현합니다: 데이터 서비스, 결제 서비스 및 날짜 및 시간 서비스. 반드시 이런 방식이어야 하는 것은 아니며, 시카플딩 개발 과정에서 시간을 절약하기 위해 만들어졌습니다.\n\nConfigurator 클래스의 주요 책임은 사용할 API 유형을 결정하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 직접 호출\n- 로컬 HTTP REST\n- 원격 HTTP REST\n- 로컬 HTTP REST 및 HTML\n- 원격 HTTP REST 및 HTML\n\n해당 API 생성은 해당 ApiFactory 클래스로 위임됩니다.\n\n이러한 구현에서 주목할 점은 실제 HTML 기반 UI 모드를 제외한 모든 구성에 동일한 테스트 스위트가 사용된다는 것입니다. 후자도 구현할 수 있지만 Selenium과 같은 HTML 테스트 드라이버가 필요합니다.\n\n처음으로 이러한 수준의 코드 재사용을 달성했습니다. 그 결과로 로컬 직접 호출 구성에서 코드 구조 리팩토링을 수행할 때 대부분의 시간을 실행하며, 실제 테스트 및 프로덕션 환경에서 수정 없이 실행될 것이라는 확신을 갖게 됩니다. 이는 Wing 클라우드지향 프로그래밍 언어와 헥사고널 아키텍처가 진정으로 우수한 조합임을 입증합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 큰 그림\n\n각 모듈의 전체 소스 코드를 모두 포함하면 이 문서의 크기가 너무 커질 수 있습니다. 본 프로젝트의 GitHub 저장소에 대한 엑세스는 요청 시 제공됩니다.\n\n대신, 전체 폴더 구조, 두 개의 UML 클래스 다이어그램, 그리고 주요 프로그램 요소와 관계를 반영한 클라우드 리소스 다이어그램을 제시하겠습니다.\n\n```js\n├── src\n│   ├── application\n│   │   ├── ports\n│   │   │   ├── ForAdministering.w\n│   │   │   ├── ForIssuingFines.w\n│   │   │   ├── ForObtainingDateTime.w\n│   │   │   ├── ForParkingCars.w\n│   │   │   ├── ForPaying.w\n│   │   │   ├── ForStoringData.w\n│   │   │   ├── Rate.w\n│   │   │   └── Ticket.w\n│   │   ├── usecases\n│   │   │   ├── BuyTicket.w\n│   │   │   ├── CheckCar.w\n│   │   │   ├── GetAvailableRates.w\n│   │   │   └── Veryfier.w\n│   ├── outside\n│   │   ├── backend\n│   │   │   ├── ForAdministeringBackend.w\n│   │   │   ├── ForIssuingFinesBackend.w\n│   │   │   └── ForParkingCarsBackend.w\n│   │   ├── http\n│   │   │   ├── html\n│   │   │   │    ├── _htmlForParkingCarsFormatter.ts\n│   │   │   │    └── htmlForParkingCarsFormatter.w\n│   │   │   ├── json\n│   │   │   │    ├── jsonForIssuingFinesFormatter.w\n│   │   │   │    └── jsonForParkingCarsFormatter.w\n│   │   │   ├── ForIssuingFinesClient.w\n│   │   │   ├── ForIssuingFinesController.w\n│   │   │   ├── ForParkingCarsClient.w\n│   │   │   ├── ForParkingCarsController.w\n│   │   │   └── middleware.w\n│   │   ├── mock\n│   │   │   └── MockDataRepository.w\n│   │   ├── ApiFactory.w\n│   │   ├── BlueZoneAplication.main.w\n│   │   ├── DirectCallApiFactory.w\n│   │   └── HttpRestApiFactory.w\n│   └── Configurator.w\n├── test\n│   ├── steps\n│   │   ├── BuyTicketTestSteps.w\n│   │   ├── CheckCarTestSteps.w\n│   │   ├── Parser.w\n│   │   └── TestStepsBase.w\n│   ├── usecase.BuyTicketTest.w\n│   └── usecase.CheckCarTest.w\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── README.md\n├── package-lock.json\n├── package.json\n└── tsconfig.json\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션 로직 측면에서 이 프로젝트는 작습니다. 그러나 구조에 대한 인지적 제어를 충분히 요구하는 문제가 있는 정도로 이미 상당히 커졌습니다. 현재 버전은 다음과 같은 여러 기준 사이에서 합리적인 균형을 이루려고 노력합니다:\n\n- 파일 구조의 깊이.\n- 복잡성 및 import 문의 양.\n- 의도한 가치를 전달하는 코드와, 해당 코드를 정리하고 테스트하여 전달하기 위해 필요한 코드 사이의 비율.\n\n이 출판물의 모든 바람직한 지표 집합을 계산하는 것은 이 문서의 범위를 벗어납니다. 그러나 여기서 그림에서 손으로 간단한 계산을 수행할 수 있습니다: 애플리케이션 내부 폴더와 외부 폴더(중간 폴더 포함)에 있는 파일의 비율(\"가치\"라고 부름)과 파일 및 폴더의 총 개수(\"물건\"이라고 부름). 현재 버전에서 숫자는 다음과 같습니다:\n\n총합: 55\nsrc/application: 16\nsrc/: 41\n파일: 43\n엄격한 가치 대 물건 비율: 16*100/55 = 29.09%\n확장된 가치 대 물건 비율: (15+19)*100/42 = 74.55%\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크거나 작은가요? 좋은가 나쁜가요? 현재로서는 확실하지 않습니다. 초기 인상은 숫자가 건강하다는 것입니다. 더 타당한 결론을 도출하려면 추가 연구와 실험이 필요합니다. 실제 제품 시스템은 상당히 많은 테스트가 필요합니다.\n\n인지 부담 관점에서 43개 파일은 인간 커뮤니케이션 채널과 짧은 기억의 유명한 7 ± 2 제한을 초과하는 많은 수입니다. 조직이 필요합니다. 현재 버전에서 한 수준에서의 파일 최대 개수는 8개이며, 이는 제한 내에 있습니다.\n\n제시된 계층 다이어그램은 실제 그래프 이미지를 부분적으로만 반영합니다 - 'bring' 문의 교차 파일 종속성은 보이지 않습니다. 또한, 외부 종속성을 반영하고 패키지 크기에 영향을 미치는 __node_files__ 폴더가 누락되어 있습니다.\n\n간단히 말해서, 도구 및 측정 방법론에 추가 투자가 없으면 그림은 부분적일 뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원하는 방향을 정립할 수 있습니다: 가능한 한 직접 가치를 창출하는 자산과 그것이 작동하기 위해 필요한 지원 요소를 최소한으로 다루는 것을 선호합니다. 건강한 가치 대 지원물 비율은 언어 및 라이브러리 지원에서 올 수 있습니다. 생성 코드 자동화는 타이핑을 줄이지만 총인지 부담은 줄여주지 않을 것입니다.\n\n## 클래스 다이어그램\n\n\"블루 존\" 응용프로그램 요소를 모두 하나의 UML 클래스 다이어그램으로 그리는 것은 현실적이지 않을 수 있습니다. UML은 사전 점검 및 운행 중인 요소를 독립적으로 표현하는 것을 지원하지 않습니다. 시스템의 가장 중요한 부분을 별도로 시각화할 수 있습니다. 예를 들어, 아래는 응용프로그램 부분에 대한 UML 클래스 다이어그램입니다:\n\n![애플리케이션 부분의 UML 클래스 다이어그램](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주차 차량에 대한 IForParkingCars 및 ForIssuingFines 주요 인터페이스는 자동차 운전자 및 주차 감독관 주요 역할로 명명된다는 점에 주목해주세요. BuyTicket 및 CheckCar 사용 사례와는 이름이 다릅니다. 이것은 실수가 아닙니다. 주요 포트 인터페이스 이름은 특정 사용 사례에서 주요 역할에 따라 반영되어야 합니다. 이러한 명명에 대한 자동 규칙은 없습니다. 선택된 이름이 직관적이기를 바랍니다.\n\n또한 애플리케이션 모듈 내에서 주요 인터페이스가 직접 구현되지 않으며 이러한 인터페이스와 사용 사례 구현 간에는 끊어짐이 있음을 알아주세요.\n\n이 또한 실수가 아닙니다. 주요 인터페이스와 해당 사용 사례 구현 간의 구체적인 연결은 UML 클래스 다이어그램에서 나타나는 것과 같이 구성에 따라 달라집니다:\n\n![class diagram](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 클래스 다이어그램에 따르면 Configurator가 어떤 IBlueZoneApiFactory 구현체를 사용할지 결정합니다: 로컬 테스트용으로 DirectApiCallFactory를 사용하거나 HTTP를 통해 로컬 및 원격 테스트 및 프로덕션 배포용으로 HttpRestApiFactory를 사용합니다.\n\n## 클라우드 리소스\n\n![이미지](/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 소개된 클라우드 리소스 다이어그램은 Wing 컴파일레이션 결과를 AWS 타겟 플랫폼에 반영한 것입니다. 이는 위에서 소개된 UML 클래스 다이어그램과 매우 다르며, 서로 보완하는 다양한 유형의 다이어그램이 있다는 것을 결론 지을 수 있습니다. 클라우드 리소스 다이어그램은 비용, 성능, 신뢰성, 회복력, 보안과 같은 시스템의 운영 측면을 이해하고 제어하는 데 중요합니다.\n\n이전 다이어그램과 마찬가지로, 주요 과제는 규모입니다. 클라우드 리소스가 많아질수록 다이어그램은 너무 많은 세부 사항으로 혼동될 수 있습니다.\n\n현재 모든 다이어그램 버전은 공식 청사진보다는 유용한 일러스트레이션 같은 모습입니다. 정확성과 이해도 사이의 적절한 균형을 찾는 것은 미래 연구의 주제입니다. 나는 초기 발표 중 하나에서 이 문제를 다루었습니다. 아마도 이 연구 주제로 다시 돌아가는 것이 좋을 것 같습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최근 출간된 책 \"Hexagonal Architecture Explained\" 에서 소개된 “Blue Zone” 애플리케이션을 Java에서 Wing으로 이식하는 경험은 다음의 중간 결론으로 이어졌습니다.\n\n- 소프트웨어 애플리케이션을 직접적으로 클라우드로 이식하는 것은 종종 비효율적이고 유지보수하기 어려운 코드로 이어질 수 있습니다.\n- 각 프로그래밍 언어는 설계 결정을 표현하는 고유한 방식을 갖고 있으며, 하나에서 다른 언어로의 맹목적인 번역은 작동하지 않습니다.\n- 새로운 클라우드 지향 프로그래밍 언어인 Wing에서 Hexagonal Architecture 패턴을 구현하는 것은 성공적인 조합이 되었습니다. 이 방식은 비용, 성능, 유연성, 보안 사이에서 적절한 균형을 갖추고 있습니다.\n- 기능 면에서 조금만 발전한 응용 프로그램에서도 코드베이스 크기가 빠르게 증가합니다. 복잡성을 통제하기 위해서는 방법론과 지침이 필요합니다.\n- 애플리케이션 로직과 클라우드 자원의 그래픽 표현은 설명을 위해 유용합니다. 이를 공식 청사진으로 전환하는 것은 추가 연구가 필요합니다.\n\n# 감사의 글\n\n본 출판물을 준비하는 동안 초안을 향상시키고 품질을 보장하기 위해 여러 중요 도구를 활용했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문서 초고안은 노션의 무료 구독 기능을 통해 구조화 및 아이디어 개발을 용이하게 했습니다.\n\n문법 및 철자 검토를 위해 Grammarly의 무료 버전이 기본적인 오류를 식별하고 수정하여 텍스트의 가독성을 보장하는 데 유용했습니다.\n\n문체 표현의 향상과 이야기 일관성 검사는 ChatGPT 4o의 유료 버전을 사용하여 진행되었습니다. ChatGPT 4o 도구는 TypeScript의 Trusted Wing Libraries의 중요 부분인 datetimex와 struct를 개발하는 데도 사용되었습니다.\n\nUML 클래스 다이어그램은 무료 버전의 PlantText UML 온라인 도구를 사용하여 생성되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트 단계 클래스에서 사전 확인 및 비행 정의를 올바르게 처리하는 데 Cristian Pallares의 도움이 중요했습니다.\n\n이 출판물 초기 버전에 중요한 의견을 제공해 준 Elad Ben-Israel에게 많은 감사를 표합니다.\n\n책의 공동 저자인 Juan Manuel Garrido de Paz가 개발한 \"Blue Zone\" 애플리케이션의 Java 버전입니다. Juan Manuel Garrido de Paz가 안타깝게도 2024년 4월에 세상을 떠났습니다. 그의 추억이 기억되길 바라며 이 보고서가 그에게 헌사가 되기를 바랍니다.\n\n준비 과정에 모든 고급 도구와 자원이 크게 기여했지만, 이 글에서 제시된 개념, 솔루션 및 최종 결정은 내가 완전히 스스로 해결해 나가며 모든 책임을 져야 합니다.","ogImage":{"url":"/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_0.png"},"coverImage":"/assets/img/2024-07-01-PortedtoCloudwithWinglangPartOne_0.png","tag":["Tech"],"readingTime":31},{"title":"Flutter 초보자를 위한 테스트 및 디버깅 가이드","description":"","date":"2024-07-01 17:08","slug":"2024-07-01-FlutterTestingandDebuggingABeginnersGuide","content":"\n\n소프트웨어 개발에서 테스트와 디버깅은 중요한 구성 요소입니다. 이들을 통해 애플리케이션이 의도한 대로 작동하고 사용자에게 원활한 경험을 제공할 수 있습니다. 이 블로그에서는 플러터(Flutter)에서의 유닛 테스트, 통합 테스트 및 위젯 테스트에 대해 탐구할 것입니다. 만약 플러터에서의 테스트가 처음이라면, 이 안내서가 처음 시작하는 데 도움이 될 것입니다.\n\n![Flutter Testing and Debugging](/assets/img/2024-07-01-FlutterTestingandDebuggingABeginnersGuide_0.png)\n\n## 왜 테스트가 중요한가요?\n\n구체적인 내용에 대해 들어가기 전에, 테스트가 왜 중요한지 이해하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 품질 보증: 테스트는 앱이 올바르게 작동하는지 확인하는 데 도움이 됩니다.\n- 초기 버그 검출: 개발 초기에 버그를 찾아 고치면 시간과 노력을 절약할 수 있습니다.\n- 코드 안정성: 테스트를 거친 코드는 새로운 기능이 추가될 때 덜 고장날 가능성이 높습니다.\n- 문서화: 테스트는 코드의 다른 부분이 어떻게 작동해야 하는지 설명하는 문서로써의 역할을 할 수 있습니다.\n\n## 플루터의 테스트 유형\n\n플루터는 세 가지 주요 테스트 유형을 지원합니다:\n\n- 단위 테스트: 단일 함수, 메서드 또는 클래스를 테스트합니다.\n- 위젯 테스트: UI 구성 요소를 테스트합니다.\n- 통합 테스트: 전체 앱 또는 앱의 큰 부분을 테스트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에서의 유닛 테스트\n\n유닛 테스트는 가장 간단한 형태의 테스트입니다. 개별 함수나 메서드에 집중하여 예상한 출력을 생성하는지 확인합니다.\n\n## 유닛 테스트 설정\n\n먼저, pubspec.yaml 파일에 test 패키지를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  test: ^1.16.0\n```\n\n프로젝트 루트에 테스트 디렉토리를 만들어 보세요. 만약 해당 디렉토리가 없다면 새로 생성해주세요. 이 디렉토리 안에 테스트를 위한 새 파일을 만들어 보세요. 예를 들어, `calculator_test.dart`와 같이 만들 수 있습니다.\n\n## 단위 테스트 작성하기\n\n간단한 덧셈 메소드를 가진 계산기 클래스가 있다고 가정해봅시다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nclass Calculator {\n  int add(int a, int b) {\n    return a + b;\n  }\n}\n```\n\n이제, 이 메소드에 대한 단위 테스트를 작성해 봅시다:\n\n```js\nimport 'package:test/test.dart';\nimport 'package:my_app/calculator.dart';\n\nvoid main() {\n  group('Calculator', () {\n    test('두 수를 더하기', () {\n      final calculator = Calculator();\n      expect(calculator.add(2, 3), 5);\n    });\n  });\n}\n```\n\n이 테스트에서는:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 테스트 패키지 및 Calculator 클래스를 가져옵니다.\n- Calculator를 위한 테스트 그룹을 정의합니다.\n- add 메서드가 올바른 합계를 반환하는지 확인하는 테스트를 작성합니다.\n\n## 단위 테스트 실행\n\n다음 명령을 사용하여 단위 테스트를 실행할 수 있습니다:\n\n```js\nflutter test\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위젯 테스트 작성\n\n위젯 테스트(또는 컴포넌트 테스트)는 개별 위젯을 테스트합니다. 이를 통해 위젯의 UI가 예상대로 보이고 작동하는지 확인할 수 있습니다.\n\n## 위젯 테스트 설정하기\n\nFlutter에는 기본적으로 flutter_test 패키지가 포함되어 있으므로 수동으로 추가할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 위젯 테스트 작성\n\n간단한 카운터 앱을 위한 위젯 테스트를 작성해 봅시다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('카운터 증가 스모크 테스트', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    // 카운터가 0에서 시작하는지 확인합니다.\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // '+' 아이콘을 탭하고 프레임을 트리거합니다.\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    // 카운터가 증가했는지 확인합니다.\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n이 테스트에서는:  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 패키지를 import하세요.\n- 카운터의 초기 상태를 확인하는 테스트를 작성하세요.\n- '+' 아이콘을 탭하는 것을 모의로 시뮬레이트하세요.\n- 카운터가 올바르게 증가하는지 확인하세요.\n\n## 위젯 테스트 실행하기\n\n동일한 명령어인 유닛 테스트를 사용하여 위젯 테스트를 실행할 수 있습니다:\n\n```js\nflutter test\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 통합 테스트 작성하기\n\n통합 테스트는 앱의 모든 위젯과 서비스가 정확히 함께 작동하는지를 보장합니다. 이 테스트는 완전한 앱이나 그 중요한 부분을 테스트합니다.\n\n## 통합 테스트 설정하기\n\npubspec.yaml 파일에 integration_test 패키지를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청하신 내용은 다음과 같습니다.\n\n```yaml\ndev_dependencies:\n  integration_test:\n    sdk: flutter\n  flutter_test:\n    sdk: flutter\n```\n\n프로젝트 루트에 test_driver 디렉토리를 만드세요. 해당 디렉토리 안에 app_test.dart와 같은 새 파일을 생성하세요.\n\n## 통합 테스트 작성\n\n동일한 카운터 앱을 대상으로 통합 테스트를 작성해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:integration_test/integration_test.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    // Verify that the counter starts at 0.\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Tap the '+' icon and trigger a frame.\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    // Verify that the counter has incremented.\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n이 테스트에서는 위젯 테스트와 유사한 단계를 따르지만, 이번에는 통합 테스트로 실행됩니다.\n\n## 통합 테스트 실행하기\n\n새 파일 test_driver/integration_test.dart를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:integration_test/integration_test_driver.dart';\n\nFuture\u003cvoid\u003e main() =\u003e integrationDriver();\n```\n\n아래 명령어를 사용하여 통합 테스트를 실행하세요:\n\n```bash\nflutter drive --driver=test_driver/integration_test.dart --target=test_driver/app_test.dart\n```\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 개발자에게는 테스트와 디버깅이 필수적인 기술입니다. 단위 테스트, 위젯 테스트, 통합 테스트를 작성함으로써 앱이 의도한 대로 작동하고 사용자에게 뛰어난 경험을 제공할 수 있습니다. 테스트를 통해 더 많은 경험을 쌓으면 코드베이스를 유지하고 확장하기가 더 쉬워질 것입니다.\n\n즐거운 테스트하세요!","ogImage":{"url":"/assets/img/2024-07-01-FlutterTestingandDebuggingABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-07-01-FlutterTestingandDebuggingABeginnersGuide_0.png","tag":["Tech"],"readingTime":5}],"page":"1","totalPageCount":157,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>