<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/149" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/149" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" href="/post/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js에서 로컬 스토리지 사용하는 방법" href="/post/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js에서 로컬 스토리지 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" href="/post/2024-05-01-HooksinReacts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HooksinReacts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서의 훅(Hooks)을 제대로 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js를 위한 실제 API 미들웨어 작성 방법" href="/post/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js를 위한 실제 API 미들웨어 작성 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue3 + Vite 컴포넌트화 하는 방법" href="/post/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3 + Vite 컴포넌트화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React-Native로 투두 앱 만드는 방법" href="/post/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React-Native로 투두 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React-Native로 투두 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React-Native로 투두 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" href="/post/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" href="/post/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 최고의 React 보일러플레이트 소개" href="/post/2024-05-01-TopReactBoilerplates2024completeresearch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 최고의 React 보일러플레이트 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 최고의 React 보일러플레이트 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년 최고의 React 보일러플레이트 소개</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Hook Form과 Zod, MUI로 React Form 만들기" href="/post/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Hook Form과 Zod, MUI로 React Form 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Hook Form과 Zod, MUI로 React Form 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Hook Form과 Zod, MUI로 React Form 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/141">141</a><a class="link" href="/posts/142">142</a><a class="link" href="/posts/143">143</a><a class="link" href="/posts/144">144</a><a class="link" href="/posts/145">145</a><a class="link" href="/posts/146">146</a><a class="link" href="/posts/147">147</a><a class="link" href="/posts/148">148</a><a class="link posts_-active__YVJEi" href="/posts/149">149</a><a class="link" href="/posts/150">150</a><a class="link" href="/posts/151">151</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법","description":"","date":"2024-05-01 18:11","slug":"2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications","content":"\n\n웹 개발에 한정되어 있던 JavaScript가 이제는 브라우저 외의 다양한 응용 프로그램을 구동하는 데 확장되었습니다. 데스크톱 애플리케이션부터 모바일 앱까지, JavaScript는 유연성과 다양한 프레임워크 및 라이브러리 생태계 덕분에 만연한 언어가 되었습니다. 이 글에서는 JavaScript의 응용 분야, 데스크톱 및 모바일 개발을 위한 프레임워크, 그리고 그들을 마스터하기 위한 학습 프로그램에 대해 살펴보겠습니다.\n\n## JavaScript를 사용할 수 있는 곳\n\n- 웹 개발: JavaScript의 주요 용도는 여전히 웹 개발입니다. 이는 웹 페이지의 상호 작용성과 기능을 향상시켜 동적 콘텐츠, 양식 유효성 검사, 애니메이션 등을 가능하게 합니다.\n- 데스크톱 애플리케이션: Electron의 등장으로 JavaScript는 데스크톱 애플리케이션 개발에 진출했습니다. Electron을 통해 개발자는 HTML, CSS, JavaScript와 같은 웹 기술을 활용하여 크로스 플랫폼 데스크톱 앱을 구축할 수 있으며, 웹 개발 기술을 활용할 수 있습니다.\n- 모바일 애플리케이션: JavaScript는 점점 더 모바일 앱 개발에 활용되고 있으며, 주로 React Native 및 Progressive Web Apps (PWA)와 같은 프레임워크를 통해 구현됩니다. 이러한 프레임워크를 사용하면 JavaScript를 사용하여 모바일 앱을 개발할 수 있으며, 네이티브와 유사한 경험을 제공할 수 있습니다.\n- 서버 측 개발: Chrome의 V8 JavaScript 엔진 위에 구축된 Node.js는 JavaScript를 사용하여 서버 측 코드를 작성할 수 있도록 하는 JavaScript 런타임입니다. 비차단, 이벤트 주도 아키텍처로 인기를 얻은 Node.js는 확장 가능하고 실시간 애플리케이션을 구축하기에 적합합니다.\n\n![이미지](/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데스크톱 및 모바일 애플리케이션을 위한 프레임워크\n\nElectron: Electron은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 구축하기 위한 프레임워크입니다. 웹 콘텐츠를 독립적인 애플리케이션으로 패키징하여 네이티브와 유사한 경험을 제공하며, 다양한 플랫폼에 배포할 수 있습니다. 핵심 기능으로는 네이티브 운영 체제 API, 자동 업데이트 및 광범위한 커뮤니티 지원이 있습니다.\n\nReact Native: 페이스북에서 개발된 React Native은 JavaScript와 React를 사용하여 모바일 애플리케이션을 구축하는 인기 있는 프레임워크입니다. 개발자들은 코드를 한 번 작성하고 iOS 및 Android 플랫폼 모두에 배포할 수 있어 개발 시간과 노력을 줄일 수 있습니다. React Native은 네이티브 컴포넌트를 활용하여 고성능 및 네이티브와 유사한 앱을 제작할 수 있습니다.\n\nFlutter: JavaScript를 기반으로 하지는 않지만, Flutter는 모바일 앱 개발에서 두드러진 성과를 보여주기 때문에 언급할 가치가 있습니다. Google에서 개발된 Flutter는 Dart 프로그래밍 언어를 사용하며 React Native와 유사한 반응형 프레임워크를 제공합니다. 단일 코드베이스로 고품질 크로스 플랫폼 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자바스크립트 프레임워크를 마스터하기 위한 학습 프로그램\n\n자바스크립트의 기초: 자바스크립트 기본 지식을 토대로 시작해보세요. 문법, 데이터 유형, 함수, 비동기 프로그래밍 등을 포함한 기본 개념을 이해합니다.\n\n리액트로 웹 개발: 리액트는 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리로, 재사용 가능한 UI 구성 요소를 만드는 데 주로 초점을 맞춥니다. 핵심적으로, 리액트는 가상 DOM(문서 객체 모델)의 원리에 따라 작동하며 컴포넌트 기반 아키텍처를 따릅니다. 리액트는 UI를 재사용 가능한 구성 요소로 구성하며, 이는 사용자 인터페이스의 일부를 나타내는 작고 독립적인 코드 단위입니다. 컴포넌트는 서로 중첩시켜 복잡한 UI 구조를 만들 수 있습니다.\n\n리액트는 가상 DOM이라고 하는 가벼운 인메모리 DOM 표현을 유지합니다. 응용 프로그램의 상태나 데이터에 변경이 있을 때, 리액트는 실제 DOM을 직접 조작하는 대신 가상 DOM을 재 렌더링합니다. 리액트는 JSX를 도입했는데, 이는 자바스크립트를 위한 구문 확장으로, 개발자가 자바스크립트 내에서 HTML과 유사한 코드를 작성할 수 있게 합니다. JSX를 사용하면 UI 구성 요소의 구조와 동작을 선언적으로 정의하는 것이 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데스크톱 애플리케이션용 Electron: Electron.js 또는 간단히 Electron으로 불리는 Electron은 GitHub에서 개발된 오픈소스 프레임워크로, HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 만들 수 있습니다. 이를 통해 개발자들은 웹사이트를 구축하는 데 사용하는 동일한 기술을 사용하여 데스크톱 애플리케이션을 만들 수 있습니다. Electron은 HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 데스크톱 애플리케이션을 구축하는 프레임워크를 제공합니다. Windows, macOS, Linux 등 다양한 운영체제에서 실행할 수 있는 데스크톱 애플리케이션을 단일 코드베이스로 개발할 수 있도록 합니다. 개발 과정을 간소화하는 라이브러리, 도구, 리소스로 이루어진 풍부한 생태계가 있습니다. npm 패키지, 프레임워크, 플러그인 등을 활용하여 Electron 애플리케이션 기능을 확장할 수 있습니다.\n\nElectron은 크로스 플랫폼 데스크톱 애플리케이션을 구축하는 데 주로 사용됩니다. 생산성 도구, 통신 앱, 미디어 플레이어, 개발 도구 등 다양한 목적의 애플리케이션을 개발할 수 있습니다. Electron을 사용하면 웹 기반 사용자 인터페이스로 데스크톱 애플리케이션을 만들 수 있어 웹 개발자에게 익숙하고 빠른 개발이 가능합니다. Electron 애플리케이션은 다양한 웹 기술과 서드파티 라이브러리를 활용하여 사용자 정의 및 확장이 가능합니다. 개발자는 자신의 애플리케이션에 고유한 사용자 경험을 만들고 추가 기능을 통합할 수 있는 유연성을 갖습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 고급 주제\n- 상태 관리 라이브러리(Redux, MobX)와 같은 고급 주제에 대해 탐구해보세요. \n- 테스트, 성능 최적화, 그리고 데스크톱 및 모바일 애플리케이션의 배포 전략에 대한 학습도 이어지겠지요.\n\n### 크로스 플랫폼 개발을 위한 Flutter\n- 플러터(Flutter)는 풍부하고 반응형 사용자 인터페이스를 구축하기 위한 미리 디자인된 위젯 세트를 제공하는 포괄적인 UI 툴킷입니다.\n- Flutter는 텍스트, 버튼, 이미지, 레이아웃, 애니메이션 등 다양한 사용자 정의 가능한 위젯을 제공합니다.\n- Flutter를 사용하면 개발자들은 코드를 한 번 작성하고 iOS, Android, 웹, 데스크톱을 포함한 여러 플랫폼에 배포할 수 있습니다.\n- 이 접근 방식은 효율적인 크로스 플랫폼 개발을 가능케 하며, 개발 시간과 노력을 줄일 수 있습니다.\n\n### 실제 프로젝트\n- 개인적으로 또는 GitHub와 같은 온라인 플랫폼을 통해 실제 프로젝트에 참여하여 실무 경험을 쌓고 본인의 기술을 과시해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구조화된 공부 프로그램을 따라가면 JavaScript 기반 데스크톱 및 모바일 애플리케이션 개발을 위한 프레임워크와 도구를 점차 숙달할 수 있습니다. 소프트웨어 개발 분야에서 보람찬 경력을 쌓을 수 있도록 길을 열어줄 거에요.\n\n친구, 시간 내 주셔서 고마워요... 다음 기사에서 만나요 :)","ogImage":{"url":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"},"coverImage":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png","tag":["Tech"],"readingTime":4},{"title":"Next.js에서 로컬 스토리지 사용하는 방법","description":"","date":"2024-05-01 18:10","slug":"2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png\" /\u003e\n\n로컬 스토리지는 웹 응용 프로그램이 사용자의 브라우저 내에서 데이터를 로컬로 저장할 수 있는 웹 스토리지 유형입니다. 이 웹 API를 사용하면 개발자가 브라우저의 메모리에 키-값 쌍을 저장할 수 있습니다. 이는 브라우저 세션 및 페이지 새로 고침 간에 데이터를 지속적으로 유지하거나 저장하는 데 사용할 수 있는 간단하면서도 강력한 도구입니다. 이는 사용자 환경 설정을 저장하거나 오프라인 환경을 만들거나 나중에 사용할 데이터를 저장하는 데 유용할 수 있습니다.\n\n이 글에서는 로컬 스토리지의 사용 사례와 Next.js 웹 응용 프로그램에서 로컬 스토리지를 사용하는 방법을 살펴보겠습니다.\n\n## 어디에서 로컬 스토리지를 사용할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 애플리케이션에서 사용할 수 있는 여러 시나리오가 있어요. \n\n- 사용자 설정 저장: 전자 상거래 애플리케이션에서는 사용자가 선호하는 통화를 로컬 스토리지에 저장하여 매번 웹 사이트를 방문할 때 해당 통화로 가격을 자동으로 표시할 수 있어요.\n- 임시 데이터 저장: 업무 관리 애플리케이션에서는 사용자가 '할 일' 목록에 추가한 작업을 아직 완료하지 않은 상태로 로컬 스토리지에 저장할 수 있어요. 그래서 브라우저를 닫거나 페이지를 이탈해도 진행 상황이 소멸되지 않아요.\n- 폼 데이터 저장: 구직 신청서에서는 사용자가 입력한 데이터를 나중에도 폼으로 돌아와서 진행 상황을 유지할 수 있도록 로컬 스토리지에 저장할 수 있어요.\n- 데이터 캐싱: 날씨 애플리케이션에서는 현재 날씨 상황을 로컬 스토리지에 저장하여 사용자가 오프라인일 때에도 접근할 수 있게 할 수 있어요.\n- 인증 정보 저장: 소셜 미디어 애플리케이션에서는 사용자의 인증 토큰을 로컬 스토리지에 저장하여 매번 애플리케이션을 열 때마다 로그인할 필요가 없게 할 수 있어요. (로컬 스토리지에 민감한 데이터를 암호화하지 않고 저장하는 것은 추천되지 않아요. 민감한 데이터 암호화를 다루는 방법을 알고 싶다면 이 기사를 참고해보세요.)\n\n## Local Storage 객체\n\n로컬 스토리지를 사용하기 위해서는 브라우저에서 제공하는 localStorage 객체를 사용할 수 있어요. 이 객체에는 로컬 스토리지와 상호작용하기 위한 여러 메소드가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메서드\n\n다음은 localStorage에서 사용할 수 있는 메서드입니다:\n\n- setItem(key, value): 이 메서드는 키-값 쌍을 로컬 스토리지에 추가하는 데 사용됩니다. 키는 문자열이며 값은 문자열 또는 JavaScript 객체가 될 수 있습니다. 이 값은 저장되기 전에 자동으로 문자열로 변환됩니다.\n\n```js\nlocalStorage.setItem('username', 'Anisha');\nlocalStorage.setItem('userId', '12345');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- getItem(key): 해당 메서드는 로컬 스토리지에서 키의 값을 검색하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 값을 문자열로 반환합니다.\n\n```js\nlocalStorage.getItem('username');\nlocalStorage.getItem('userId');\n```\n\n- removeItem(key): 해당 메서드는 로컬 스토리지에서 키-값 쌍을 제거하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 키-값 쌍을 로컬 스토리지에서 제거합니다.\n\n```js\nlocalStorage.removeItem('username');\nlocalStorage.removeItem('userId');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- clear(): 이 메서드는 로컬 스토리지에서 모든 키-값 쌍을 제거하는 데 사용됩니다.\n\n```js\nlocalStorage.clear();\n```\n\n- key(index): 이 메서드는 로컬 스토리지에서 특정 인덱스에 있는 키-값 쌍의 키를 검색하는 데 사용됩니다. 인덱스를 매개변수로 받아 해당하는 키를 문자열 형식으로 반환합니다.\n\n```js\nconst key = localStorage.key(0); // 0번 인덱스의 키를 가져오기\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- length: 숫자 쌍의 개수를 반환하는 읽기 전용 속성입니다.\n\n```js\nconst numOfItemsInLocalStorage = localStorage.length()\n```\n\n## 로컬 저장소 구현 예시\n\n다음은 Next.js 애플리케이션에서 모든 localStorage 메서드를 사용하는 방법에 대한 완전한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 우리는 localStorage에 저장할 각 항목에 대한 상태를 만들고 키와 로컬 저장소의 항목 수에 대한 상태를 생성합니다.\n\n```js\nconst [username, setUsername] = useState\u003cstring | null\u003e(null);\nconst [userId, setUserId] = useState\u003cstring | null\u003e(null);\nconst [userData, setUserData] = useState\u003c{email: string, age: number} | null\u003e(null);\nconst [keys, setKeys] = useState\u003cstring[]\u003e([]);\nconst [length, setLength] = useState\u003cnumber\u003e(0);\n```\n\n이제 useEffect 훅을 사용하여 브라우저의 localStorage API의 사용 가능 여부를 확인하고, 컴포넌트가 처음으로 렌더링될 때 localStorage에 저장된 키-값 쌍의 값을 검색합니다.\n\n```js\nuseEffect(() =\u003e {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    let username = localStorage.getItem('username');\n    let userId = localStorage.getItem('userId');\n    let userData = JSON.parse(localStorage.getItem('userData'));\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}, []);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 handleSave, handleRemove, handleClear 세 가지 이벤트 핸들러를 사용해서 데이터를 저장, 삭제, 지우는 함수를 구현했어요.\n\nhandleSave 함수 안에서는 setItem 메서드를 사용하여 로컬 스토리지에 키-값 쌍을 저장해요. 그런 다음 getItem 메서드를 사용하여 그 값을 불러와 setUsername, setUserId, setUserData, setKeys, setLength를 사용해서 상태를 갱신합니다.\n\n```js\nfunction handleSave() {\n  if (typeof window !== \"undefined\" \u0026\u0026 window.localStorage) {\n    localStorage.setItem(\"username\", \"Anisha\");\n    localStorage.setItem(\"userId\", \"12345\");\n    localStorage.setItem(\"userData\", JSON.stringify({ email: \"anisha@example.com\", age: 25 }));\n\n    let username = localStorage.getItem(\"username\");\n    let userId = localStorage.getItem(\"userId\");\n    let userData = JSON.parse(localStorage.getItem(\"userData\")!);\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhandleRemove 함수에서는 removeItem 메서드를 사용하여 로컬 저장소에서 `username` 키-값 쌍을 제거하고 setUsername을 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleRemove() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.removeItem('username');\n    setUsername(null);\n  }\n}\n```\n\nhandleClear 함수에서는 clear 메서드를 사용하여 로컬 저장소에서 모든 키-값 쌍을 제거하고 setUsername, setUserId, setUserData, setKeys, setLength를 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleClear() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.clear();\n    setUsername(null);\n    setUserId(null);\n    setUserData(null);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 렌더 메서드에서는 localStorage에 저장된 키-값 쌍의 값을 표시하고 로컬 저장소와 상호 작용할 수 있는 버튼을 제공합니다.\n\n```js\n\u003cdiv\u003e\n  \u003cbutton onClick={handleSave}\u003elocalStorage에 저장\u003c/button\u003e\n  \u003cbutton onClick={handleRemove}\u003elocalStorage에서 제거\u003c/button\u003e\n  \u003cbutton onClick={handleClear}\u003elocalStorage 지우기\u003c/button\u003e\n  \u003cp\u003e사용자 이름: {username}\u003c/p\u003e\n  \u003cp\u003e사용자 ID: {userId}\u003c/p\u003e\n  \u003cp\u003e사용자 데이터: {JSON.stringify(userData)}\u003c/p\u003e\n  \u003cp\u003e키 목록: {keys.join(\", \")}\u003c/p\u003e\n  \u003cp\u003e로컬 저장소의 총 아이템 수: {length}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n코드의 더 자세한 내용을 확인하고 싶다면, 내 GitHub 저장소를 자유롭게 확인해주세요.\n\n## 로컬 저장소 사용 시 보안 고려 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 사용하는 한 가지 단점은 그 안에 저장된 데이터가 일반 텍스트 형식이라는 것입니다. 이는 악성 스크립트에 의해 쉽게 액세스될 수 있다는 것을 의미합니다. 이는 공격자가 사용자의 장치에 액세스를 얻으면 로컬 스토리지에 저장된 데이터에 잠재적으로 액세스할 수 있다는 것을 의미합니다.\n\n다음은 Next.js 애플리케이션에서 민감한 데이터를 암호화하는 방법을 찾는 데 도움이 되는 이 기사의 제2부입니다. Next.js 앱의 로컬 스토리지에 민감한 데이터를 안전하게 보호하기","ogImage":{"url":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서의 훅(Hooks)을 제대로 사용하는 방법","description":"","date":"2024-05-01 18:08","slug":"2024-05-01-HooksinReacts","content":"\n\n현대 웹 개발 분야에서는 React의 Hooks 도입이 개발자들이 사용자 인터페이스를 구축하는 방식에 상당한 변화를 가져왔어요. Hooks는 클래스를 작성하지 않고도 상태 및 기타 React 기능을 활용할 수 있게 해주는 함수들이에요. 이를 통해 개발 프로세스가 간소화되고 코드베이스를 더 잘 관리하고 가독성있게 만들 수 있어요. Hooks를 사용하면 useState를 활용하여 컴포넌트 상태를 쉽게 관리하고, useEffect로 부수 효과를 처리하며, useContext를 사용하여 컴포넌트 내에서 컨텍스트에 접근할 수 있어요.\n\n# useReducer\n\nuseReducer는 컴포넌트 내에서 복잡한 상태 로직을 관리하기 위해 사용되는 React 훅이에요. 특히 이전 상태에 따라 상태 전이가 발생하는 경우에 유용해요. 여기서 useReducer가 적용될 수 있는 몇 가지 다른 사용 사례들을 제공할게요.\n\n```js\nimport React, { useReducer } from \"react\";\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"LOGIN\":\nreturn { …state, user: action.payload.user, isLoggedIn: true };\ncase \"LOGOUT\":\nreturn { …state, user: null, isLoggedIn: false };\ndefault:\nreturn state;\n}\n}\nfunction Auth() {\nconst [state, dispatch] = useReducer(reducer, {\nuser: null,\nisLoggedIn: false,\n});\nconst handleLogin = () =\u003e {\n// 로그인 처리 로직\nconst fakeUser = { username: \"user\", email: \"user@example.com\" };\ndispatch({ type: \"LOGIN\", payload: { user: fakeUser } });\n};\nconst handleLogout = () =\u003e {\n// 로그아웃 처리 로직\ndispatch({ type: \"LOGOUT\" });\n};\nreturn (\n\u003cdiv\u003e\n{state.isLoggedIn ? (\n\u003cdiv\u003e\n\u003cp\u003e환영합니다, {state.user.username}님!\u003c/p\u003e\n\u003cbutton onClick={handleLogout}\u003e로그아웃\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cbutton onClick={handleLogin}\u003e로그인\u003c/button\u003e\n)}\n\u003c/div\u003e\n);\n}\nexport default Auth;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useContext\n\nuseContext은 함수형 컴포넌트 내에서 컨텍스트를 소비하는 데 사용되는 React 훅입니다. 이를 통해 React.createContext() 함수에 의해 생성된 컨텍스트 객체의 값을 액세스할 수 있습니다. useContext의 몇 가지 다른 사용 사례와 여러 값을 처리하는 방법에 대해 살펴보겠습니다:\n\n```js\nimport React, { createContext, useContext, useState } from 'react';\nconst UserContext = createContext();\nconst UserProvider = ({ children }) =\u003e {\nconst [user, setUser] = useState(null);\nconst login = (userData) =\u003e {\nsetUser(userData);\n};\nconst logout = () =\u003e {\nsetUser(null);\n};\nreturn (\n\u003cUserContext.Provider value={ user, login, logout }\u003e\n{children}\n\u003c/UserContext.Provider\u003e\n);\n};\nconst Profile = () =\u003e {\nconst { user, logout } = useContext(UserContext);\nreturn (\n\u003cdiv\u003e\n{user ? (\n\u003cdiv\u003e\n\u003cp\u003eWelcome, {user.name}!\u003c/p\u003e\n\u003cbutton onClick={logout}\u003eLogout\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cp\u003ePlease log in\u003c/p\u003e\n)}\n\u003c/div\u003e\n);\n};\nconst LoginForm = () =\u003e {\nconst { login } = useContext(UserContext);\nconst [username, setUsername] = useState('');\nconst [password, setPassword] = useState('');\nconst handleLogin = () =\u003e {\n// perform login logic\nconst userData = { name: username }; // Example data\nlogin(userData);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={username} onChange={(e) =\u003e setUsername(e.target.value)} /\u003e\n\u003cinput type=\"password\" value={password} onChange={(e) =\u003e setPassword(e.target.value)} /\u003e\n\u003cbutton onClick={handleLogin}\u003eLogin\u003c/button\u003e\n\u003c/div\u003e\n);\n};\nconst App = () =\u003e {\nreturn (\n\u003cUserProvider\u003e\n\u003cProfile /\u003e\n\u003cLoginForm /\u003e\n\u003c/UserProvider\u003e\n);\n};\nexport default App;\n```\n\n# useRef\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseRef은 주로 React 훅으로 사용되며, 다시 렌더링을 유발하지 않고 렌더링 간 지속되는 가변 값에 액세스하고 저장하는 데 주로 사용됩니다. 이는 DOM 요소에 액세스하거나 렌더링 간 값 추적 또는 가변 변수 저장에 흔히 사용됩니다. useRef의 다양한 사용 사례와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useRef } from \"react\";\nfunction MutableValues() {\nconst counterRef = useRef(0);\nconst incrementCounter = () =\u003e {\ncounterRef.current += 1;\nconsole.log('Current value of counter:', counterRef.current);\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={incrementCounter}\u003eIncrement Counter\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default MutableValues;\n```\n\n# useCallback\n\nuseCallback은 함수를 메모이제이션하는 데 사용되는 React 훅입니다. 자식 컴포넌트에 콜백을 전달할 때 불필요한 다시 렌더링을 방지하는 데 특히 유용합니다. useCallback의 다양한 사용 사례와 여러 값을 처리하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useCallback } from 'react';\nimport ChildComponent from './ChildComponent';\nfunction ParentComponent() {\nconst [count, setCount] = useState(0);\n// count를 의존성으로 갖는 메모이제이션된 콜백 함수\nconst handleClick = useCallback(() =\u003e {\nconsole.log('버튼이 클릭되었습니다! Count:', count);\n}, [count]);\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent onClick={handleClick} /\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e증가\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useMemo\n\nuseMemo는 비용이 많이 드는 계산을 메모이제이션하기 위해 사용되는 React 훅입니다. 값들의 불필요한 다시 계산을 피하고 성능을 최적화해야 하는 경우에 특히 유용합니다. useMemo의 다양한 사용 사례와 여러 값들을 다루는 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useMemo } from \"react\";\nfunction ProductList() {\nconst [products] = useState([\n{ id: 1, name: \"제품 1\", price: 10 },\n{ id: 2, name: \"제품 2\", price: 20 },\n{ id: 3, name: \"제품 3\", price: 30 },\n{ id: 4, name: \"제품 4\", price: 30 },\n{ id: 5, name: \"제품 5\", price: 30 },\n]);\nconst [selectedProducts, setSelectedProducts] = useState([]);\nconst handleToggleProduct = (productId) =\u003e {\nsetSelectedProducts((prevSelectedProducts) =\u003e {\nconst isSelected = prevSelectedProducts.includes(productId);\nif (isSelected) {\nreturn prevSelectedProducts.filter((id) =\u003e id !== productId);\n} else {\nreturn [...prevSelectedProducts, productId];\n}\n});\n};\n// 총 가격 메모이제이션된 계산\nconst totalPrice = useMemo(() =\u003e {\nconsole.log(\"총 가격 계산 중...\");\nreturn selectedProducts.reduce((total, productId) =\u003e {\nconst selectedProduct = products.find(\n(product) =\u003e product.id === productId\n);\nreturn total + (selectedProduct ? selectedProduct.price : 0);\n}, 0);\n}, [selectedProducts, products]);\nreturn (\n\u003cdiv\u003e\n\u003ch2\u003e제품 목록\u003c/h2\u003e\n\u003cul\u003e\n{products.map((product) =\u003e (\n\u003cli key={product.id}\u003e\n\u003clabel\u003e\n\u003cinput\ntype=\"checkbox\"\nchecked={selectedProducts.includes(product.id)}\nonChange={() =\u003e handleToggleProduct(product.id)}\n/\u003e\n{product.name} - ${product.price}\n\u003c/label\u003e\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003ch3\u003e총 가격: ${totalPrice}\u003c/h3\u003e\n\u003c/div\u003e\n);\n}\nexport default ProductList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useImperativeHandle\n\nuseImperativeHandle은 React 훅으로, React.forwardRef를 사용할 때 부모 컴포넌트가 자식 컴포넌트에 노출하는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 부모 컴포넌트의 부모에게 액세스 가능한 함수 또는 값들을 정의하고, 직접 자식 컴포넌트에 노출되지 않도록 합니다. useImperativeHandle의 몇 가지 사용 사례 및 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useImperativeHandle, forwardRef } from 'react';\nconst ChildComponent = forwardRef((props, ref) =\u003e {\nconst [count, setCount] = useState(0);\nuseImperativeHandle(ref, () =\u003e ({\ngetCount: () =\u003e count\n}));\nreturn (\n\u003cdiv\u003e\n\u003cp\u003eCount: {count}\u003c/p\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n\u003c/div\u003e\n);\n});\nfunction ParentComponent() {\nconst childRef = useRef(null);\nconst handleGetCount = () =\u003e {\nalert(`Count from child component: ${childRef.current.getCount()}`);\n};\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent ref={childRef} /\u003e\n\u003cbutton onClick={handleGetCount}\u003eGet Count from Child\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useLayoutEffect\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseLayoutEffect은 useEffect와 유사한 React 훅이지만, 모든 DOM 변이 후 동기적으로 실행됩니다. 브라우저가 화면을 그리기 전에 반드시 DOM 명령을 실행하거나 DOM에서 레이아웃 정보를 읽어야 하는 경우에 유용합니다. useLayoutEffect의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useLayoutEffect, useRef } from 'react';\nfunction ComponentWithLayoutEffect() {\nconst [dimensions, setDimensions] = useState({ width: 0, height: 0 });\nconst elementRef = useRef(null);\nuseLayoutEffect(() =\u003e {\nconst { current: element } = elementRef;\nif (!element) return;\nconst { width, height } = element.getBoundingClientRect();\nsetDimensions({ width, height });\n}, [elementRef]);\nreturn (\n\u003cdiv ref={elementRef}\u003e\n\u003cp\u003eWidth: {dimensions.width}px\u003c/p\u003e\n\u003cp\u003eHeight: {dimensions.height}px\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default ComponentWithLayoutEffect;\n```\n\n# useDeferredValue\n\nuseDeferredValue는 React 18에서 도입된 React 훅으로, 일정 시간이 지난 후 컴포넌트 내의 값을 업데이트를 지연시킵니다. 부드러운 사용자 상호작용을 우선시하거나 빠른 상태 변경으로 인한 불필요한 다시 렌더링을 줄이는 경우에 유용합니다. useDeferredValue의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useDeferredValue } from 'react';\nfunction TextInput() {\nconst [text, setText] = useState('');\nconst deferredText = useDeferredValue(text, { timeoutMs: 1000 });\nconst handleChange = (e) =\u003e {\nsetText(e.target.value);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={text} onChange={handleChange} /\u003e\n\u003cp\u003eDeferred Value: {deferredText}\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default TextInput;\n```\n\n# useTransition\n\nuseTransition은 React 18에서 도입된 React 훅입니다. 애플리케이션에서 애니메이션과 업데이트를 조정할 수 있게 해줍니다. 특히 원활한 전환을 통해 특정 작업을 수행하고 싶을 때 유용합니다. useTransition의 몇 가지 유즈 케이스와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useTransition } from \"react\";\nfunction AnimatedList() {\nconst [items, setItems] = useState([]);\nconst [isPending, startTransition] = useTransition({ timeoutMs: 300 });\nconst addItem = () =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e […prevItems, Date.now()]);\n});\n};\nconst removeItem = (timestamp) =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e prevItems.filter((item) =\u003e item !== timestamp));\n});\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={addItem}\u003eAdd Item\u003c/button\u003e\n{isPending \u0026\u0026 \u003cp\u003eLoading…\u003c/p\u003e}\n\u003cul\u003e\n{items.map((item) =\u003e (\n\u003cli key={item}\u003e\n\u003cbutton onClick={() =\u003e removeItem(item)}\u003eRemove\u003c/button\u003e\nItem {item}\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003c/div\u003e\n);\n}\nexport default AnimatedList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useId\n\nuseId은 내장된 React 훅이 아닙니다. 하지만 React 컴포넌트 내에서 고유한 식별자를 생성하는 데 사용되는 사용자 정의 훅 또는 유틸리티 함수로 종종 구현됩니다. 이러한 식별자는 목록 항목에 고유한 키 속성을 설정하거나 고유한 HTML id 속성을 생성하거나 양식 입력란과 라벨을 연결하는 등 다양한 목적으로 유용합니다. useId의 몇 가지 사용 사례와 여러 값을 처리하는 방법에 대해 설명합니다:\n\n```js\nimport React from 'react';\nfunction List({ items }) {\n  return (\n    \u003cul\u003e\n      {items.map(item =\u003e (\n        \u003cli key={useId()}\u003e{item}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\nexport default List;\n```","ogImage":{"url":"/assets/img/2024-05-01-HooksinReacts_0.png"},"coverImage":"/assets/img/2024-05-01-HooksinReacts_0.png","tag":["Tech"],"readingTime":10},{"title":"Next.js를 위한 실제 API 미들웨어 작성 방법","description":"","date":"2024-05-01 18:07","slug":"2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png\" /\u003e\n\n어플리케이션을 위한 웹 클라이언트나 특정한 종류의 컨셉 프로젝트를 구현해야 할 때 저는 본능적으로 Next.js를 선택합니다. 몇 년 전, 제가 구현해야 했던 어플리케이션은 Next.js 버전 12가 나온 시기에 맞춰 만들어졌었는데, 이 때 공개된 많은 새로운 기능들에 대해 듣게 되어 흥분했습니다. 그 중에서도 API Middleware의 출시는 저에게 가장 흥미로운 기능 중 하나였습니다.\n\n하지만 이 흥분은 잠시 지속되었습니다. 그들의 구현은 이름은 같고 개념적으로 유사하지만, 이전에 있던 것을 재탄생시킨 느낌이었고, 결과적으로 베이스림에 담긴 벽돌 같은 느낌을 주었습니다.\n\n# Middleware가 어떤 문제를 해결하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNext.js API routes는 정말 편리한 방법 중 하나로, 클라이언트에 API를 추가할 수 있습니다. 해야 할 일은 api 디렉토리 내에 새 파일을 만들고 함수를 작성하는 것 뿐입니다.\n\n```js\nexport default function handler(req, res) {\n  res.status(200).json({ name: 'John Doe' })\n}\n```\n\n시작하기에는 이 간단함이 좋지만, 복잡성을 구현 수준으로 미루는 결과가 될 수 있습니다.\n\n예를 들어, 구현에서 요청 유형 분기 처리를 처리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport default function handler(req, res) {\n  if (req.method === 'POST') {\n    // POST 요청 처리\n  } else {\n    // 다른 모든 HTTP 메소드 처리\n  }\n}\n```\n\n이제 사용자가 인증되었는지 확인하고 싶다면 어떻게 해야 할까요? 해당 내용은 라우트 핸들러 내에서 처리해야 합니다.\n\n```js\nexport default function handler(req, res) {\n  if (!isAuthenticated(req)) {\n    res.status(401).send(\"권한이 없습니다\")\n  }\n  // 구현\n}\n```\n\n이러한 방식으로 계속 하다 보면, 핸들러 구현 앞에 조건들이 계속 쌓이는 것을 알게 되고, 더 나쁜 일로, 핸들러 간에 많은 복사 및 붙여넣기 작업이 필요합니다. 이는 완전히 혼란스러워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보통 이 문제는 어떻게 해결하나요?\n\n이 문제는 Express와 같은 프레임워크를 사용하여 매우 우아하게 해결됩니다. \n\n우리의 코드는 아래와 같이 보일 수 있어요:\n\n```js\napp.post(\n  '/hello',\n  requireAuth,\n  validatePayload,\n  doUsefulStuff,\n  respond,\n);\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 구현된 다음 인터페이스를 준수하는 한 재사용 가능한 여러 함수를 서로 쌓을 수 있게 해줍니다:\n\n- 함수는 next라는 매개변수를 가져야 하며, 이 매개변수는 함수여야 합니다.\n- 사용자 정의 로직이 실행된 후, 체인 내의 다음 함수로 이동하려면 next()를 호출하거나 즉시 요청에 응답해야 합니다.\n\n```js\nfunction myMiddleware(req, res, next) {\n  // 일부 검사 수행\n  next()\n}\n```\n\n이제 이러한 미들웨어를 목록에 추가하여 활성화하거나 제거하거나 주석 처리하여 비활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문법은 매우 명확하며 코드를 재사용할 수 있어요.\n\n# Next.js에서 미들웨어 문제를 어떻게 해결하나요?\n\nNext.js 문서를 보면 middleware.js 파일을 생성하고 미들웨어를 구현하라고 합니다. 이 부분이 조금 마음에 들지 않지만 계속해 봅시다.\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  return response\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어를 구현한 후에는 Next.js에 해당 미들웨어가 실행되어야 하는 위치를 알려주는 구성 객체를 내보내야 합니다.\n\n```js\n// 미들웨어.js\n\nexport const config = {\n  matcher: '/api/:여러분의-엔드포인트-여기에*'\n}\n```\n\n이 구성 객체에서는 정규 표현식을 지원하는 매처를 지정할 수 있습니다.\n\n만족스럽지 않다면, 미들웨어 선언 내에서 조건문을 활용하여 사용자 정의 로직을 적용해볼 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    return NextResponse.rewrite(new URL('/about-2', request.url))\n  }\n \n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\n  }\n}\n```\n\n여기서 약간의 점들이 왜 저는 이 방식을 좋아하지 않는지에 대해 이야기해 드리겠습니다:\n\n- 미들웨어 구현이 담긴 전용 middleware.js 파일이 있으면 조잡하게 느껴집니다. 라우트가 정의된 곳에 내 미들웨어를 두고 싶어요.\n- 설정과 매처 접근 방식은 정말로 필요 없어보입니다. 왜 내 미들웨어를 실행하려면 매처와 정규식을 작성해야 하는 건가요? 이미 디렉토리 구조로 라우트를 설정했는데 (제가 처음에 Next.js를 선택한 가장 큰 이유가 이것인데) 이제 다른 연관성 없는 곳으로 가서 매처나 조건문을 작성해야 한다니요.\n\n몇 가지 상황에서는 이러한 방식이 실용적일 수 있는데, 예를 들어 애플리케이션 수준에서 모든 요청에 대해 실행되는 미들웨어를 사용하는 경우 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말씀하신 대로, 이 기능의 디자인은 별로 마음에 들지 않아요. 미들웨어를 정의하고 라우트를 정의하는 곳과 같이 깔끔하게 쌓아 나열하고 유지 관리하기 쉽게 만들고 싶어요.\n\n# API 라우트를 위한 사용자 정의 미들웨어\n\n최근 Next.js에서 라우트 핸들러를 출시했지만, 대부분의 사람들(포함해서 저도)은 여전히 대부분의 프로젝트에서 API 라우트를 사용하고 있기 때문에, 먼저 API 라우트의 구현 방법에 대해 다루겠습니다.\n\n소스 코드는 GitHub에서 사용 가능하며, 아래 예시에서는 간단한 JavaScript를 사용하겠습니다. 이는 의사코드와 유사하지만 여전히 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 루트가 작동하는 방식을 설명한 것입니다.\n\n```js\n// src/pages/api/hello.js\n\nconst middleware_1 = async (req, res, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\nconst middleware_2 = async (req, res, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\nconst middleware_3 = async (req, res, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\nconst middleware_4 = async (req, res, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\nconst hello = async (req, res) =\u003e {\n  res.status(200).json({ message: 'Hello World.' })\n};\nexport default handler(\n  middleware_1,\n  middleware_2,\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n언제든지 미들웨어 체인 중간에서 next() 함수 대신 res 객체를 사용하여 응답할 수 있어야하며, 그때 체인이 실행이 중단됩니다. 또한 미들웨어는 다른 곳에서 선언되어 재사용 가능하도록 작성되고 루트로 가져와야 합니다.\n\n이러한 기능을 구현하기 위해 할 일은 여기서 호출하고 있는 handler 함수를 구현하는 것뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 예시 구현을 확인할 수 있고, 소스 코드는 여기서 찾을 수 있습니다.\n\n```js\n// src/pages/middleware/handler.js\n\nconst execMiddleware = async (\n  req,\n  res,\n  middleware,\n  index = 0,\n) =\u003e {\n  if (res.headersSent || !middleware[index]) return\n  if (typeof middleware[index] !== 'function') {\n    res.status(500).end('Middleware must be a function!')\n    throw new Error('Middleware must be a function!')\n  }\n  await middleware[index](req, res, async () =\u003e {\n    await execMiddleware(req, res, middleware, index + 1)\n  })\n}\n\nexport const handler =\n  (...middleware) =\u003e\n  async (req, res) =\u003e {\n    await execMiddleware(req, res, middleware)\n  }\n```\n\n추가적으로, 여기에서 사용할 수 있는 allowMethods 미들웨어가 포함되어 있어요. 라우트에서 다음과 같이 사용할 수 있습니다:\n\n```js\n// src/pages/api/hello.js\n\nexport default handler(\n  allowMethods(['GET', 'PUT']),\n  hello,\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라우트 핸들러를 위한 사용자 지정 미들웨어\n\n라우트 핸들러는 Next.js에서 최신 API 구현 접근 방식이며, 앞으로 채택할 것을 권장합니다.\n\n한편으로는 HTTP 메소드(GET, POST, PUT 등)별로 명명된 내보내기가 필요하게 되어 좋아하지만, 핸들러 내에서 명시적으로 응답 값을 반환해야 하는 변경 사항에는 큰 부담을 느낍니다.\n\n위와 마찬가지로 소스 코드는 GitHub에서 확인할 수 있으며, 우리가 구현하고 있는 기능을 설명하기 위해 간단한 JavaScript를 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 원하는 라우트 작업 방식을 보여줍니다.\n\n```js\n// src/app/api/hello/route.js\n\nconst middleware_1 = async (req, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\n\nconst middleware_2 = async (req, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\n\nconst middleware_3 = async (req, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\n\nconst middleware_4 = async (req, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\n\nconst hello = async (req) =\u003e {\n  return NextResponse.json({ data: 'Hello World' })\n};\n\nexport const GET = handler(\n  middleware_1,\n  middleware_2,\n  hello,\n);\n\nexport const POST = handler(\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n한 번 더 강조하지만, 미들웨어 체인에서 언제든지 응답을 반환하여 next() 함수를 호출하는 대신 응답을 반환할 수 있으며, 체인이 실행을 중지합니다.\n\n아래는 handler 함수의 예시 구현입니다. 소스 코드는 여기에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/app/middleware/handler.js\n\nexport const handler =\n  (...middleware) =\u003e\n  async (request) =\u003e {\n    let result\n    for (let i = 0; i \u003c middleware.length; i++) {\n      let nextInvoked = false\n      const next = async () =\u003e {\n        nextInvoked = true\n      };\n      result = await middleware[i](request, next);\n      if (!nextInvoked) {\n        break\n      }\n    }\n    if (result) return result\n    throw new Error('핸들러 또는 미들웨어가 NextResponse를 반환해야 합니다!')\n  }\n```\n\n# 결론\n\n당연히 취향의 문제일 수 있지만, 우리는 50줄 이하의 코드로 Next.js에 우리의 미들웨어 구현을 성공적으로 적용했고, 이것은 내 기준에서 이긴 것입니다.\n\nNext.js가 가는 방향에 대해서는, 우리가 그냥 우회로에 들어간 것이고 곧 간단하고 깨끗하며 쉬운 개발자 경험으로 돌아갈 것을 손가락을 꼬집었어요. 몇 년 전에 그들의 개발 경험이 얼마나 부드러운지 보았을 때 반해버렸으며, 아직 희망을 버리지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어 패턴에 대해서는 어떤 프로젝트에든 자유롭게 코드를 활용하셔도 괜찮아요. 이는 로직을 세분화하여 작은 조각으로 쌓는 훌륭한 방법입니다.\n\n호기심을 잃지 말고, 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png","tag":["Tech"],"readingTime":8},{"title":"Vue3 + Vite 컴포넌트화 하는 방법","description":"","date":"2024-05-01 18:06","slug":"2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas","content":"\n\n# Vue3 + rspack 003: 컴포넌트화의 기술 (Composition API) 및 일반적인 문제 해결 아이디어\n\nVue 3에서 Composition API는 컴포넌트와 로직을 재사용하는 새로운 방법을 제공합니다. 이는 우리의 코드에 더 나은 구성 구조를 제공할 뿐만 아니라 복잡한 컴포넌트 로직을 더 유연하게 처리할 수 있는 기회를 줍니다. 아래에서 탐색해봅시다.\n\n# 컴포넌트 생성 및 사용\n\n컴포넌트는 Vue 애플리케이션의 기본 구성 요소입니다. Composition API에서는 reactive 상태와 컴포넌트의 동작을 정의하기 위해 setup 함수를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시: 간단한 카운터 컴포넌트\n\n```js\n\u003ctemplate\u003e\n  \u003cbutton @click=\"increment\"\u003e{ count }\u003c/button\u003e\n\u003c/template\u003e\u003cscript\u003e\nimport { ref } from 'vue';export default {\n  setup() {\n    const count = ref(0);\n    function increment() {\n      count.value++;\n    }    return { count, increment };\n  };\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: Composition API를 사용할 때, 개발자들은 조각난 상태 로직을 경험하여 컴포넌트를 유지하기 어렵게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 관련 로직을 함수로 캡슐화한 후에 이 함수를 설정(setup)에서 호출하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.\n\n# 부모 및 자식 컴포넌트 간 통신\n\nVue 3에서 부모 및 자식 컴포넌트 간의 통신은 주로 props와 emit을 통해 이루어집니다. Composition API는 defineProps와 defineEmit 함수를 제공하여이 프로세스를 간단화합니다.\n\n# 예: 부모-자식 컴포넌트 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- ChildComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cdiv @click=\"emitToParent\"\u003e나를 클릭해주세요!\u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { defineProps, defineEmit } from 'vue';\nexport default {\n  setup() {\n    const props = defineProps(['messageFromParent']);\n    const emit = defineEmit(['messageToParent']);\n    \n    function emitToParent() {\n      emit('messageToParent', '안녕하세요, 부모님!');\n    }\n    \n    return { emitToParent };\n  }\n};\n\u003c/script\u003e\n\n\u003c!-- ParentComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cChildComponent\n    :messageFromParent=\"parentMessage\"\n    @messageToParent=\"handleMessageFromChild\"\n  /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ChildComponent from './components/ChildComponent.vue';\nexport default {\n  components: {\n    ChildComponent\n  },\n  setup() {\n    const parentMessage = ref('안녕하세요, 자식님!');\n    \n    function handleMessageFromChild(message) {\n      console.log(message);\n    }\n    \n    return { parentMessage, handleMessageFromChild };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움 : 대규모 어플리케이션에서는 종종 다층 중첩된 컴포넌트 간의 통신 요구사항이 발생합니다. 직접 props와 emit을 사용하면 \"props를 계층적으로 전달하는\" 및 \"이벤트를 계층적으로 발생시키는\" 문제가 발생할 수 있습니다.\n\n해결책 : 이러한 번거로운 계층별 전달을 피하기 위해 Vue 3의 provide 및 inject API를 사용하여 컴포넌트 간 수준의 통신을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 슬롯 사용\n\n슬롯을 사용하면 자식 컴포넌트의 내용으로 어떤 템플릿 코드든 부모 컴포넌트에 전달할 수 있습니다. Composition API에서는 슬롯 내용에 접근할 수 있습니다.\n\n# 예시: 슬롯 사용하기\n\n```js\n\u003c!-- BaseLayout.vue --\u003e\n\u003ctemplate\u003e\n  \u003cheader\u003e\n    \u003cslot name=\"header\"\u003e\u003c/slot\u003e\n  \u003c/header\u003e\n  \u003cmain\u003e\n    \u003cslot\u003e\u003c/slot\u003e\n  \u003c/main\u003e\n  \u003cfooter\u003e\n    \u003cslot name=\"footer\"\u003e\u003c/slot\u003e\n  \u003c/footer\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { useSlots } from 'vue';\nexport default {\n  setup() {\n    const slots = useSlots();\n    return { slots };\n  }\n};\n\u003c/script\u003e\n\u003c!-- App.vue --\u003e\n\u003ctemplate\u003e\n  \u003cBaseLayout\u003e\n    \u003ctemplate #header\u003e\n      \u003ch1\u003e여기에 페이지 제목이 올 수 있어요\u003c/h1\u003e\n    \u003c/template\u003e\n    \u003cp\u003e페이지의 주요 내용\u003c/p\u003e\n    \u003ctemplate #footer\u003e\n      \u003cp\u003e여기에 연락처 정보가 있습니다\u003c/p\u003e\n    \u003c/template\u003e\n  \u003c/BaseLayout\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport BaseLayout from './components/BaseLayout.vue';\nexport default {\n  components: {\n    BaseLayout\n  }\n};\n\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실용적인 어려움과 해결책\n\n어려움: 이름이 지정된 슬롯을 사용할 때, 슬롯 콘텐츠를 자식 컴포넌트의 상태 또는 동작에 따라 동기화하는 것이 복잡할 수 있습니다.\n\n해결책: scoped 슬롯을 사용할 수 있습니다. scoped 슬롯을 사용하면 자식 컴포넌트가 부모 컴포넌트에 데이터를 노출시킬 수 있고 그 데이터를 부모 컴포넌트의 슬롯 콘텐츠에서 사용할 수 있습니다.\n\n# 동적 컴포넌트와 비동기 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVue 3는 defineAsyncComponent를 통해 비동기 컴포넌트를 지원합니다. 동적 컴포넌트는 내장 `component` 태그와 `:` 속성을 사용하여 구현할 수 있습니다.\n\n# 예시: 비동기 컴포넌트\n\n```js\n// defineAsyncComponent를 사용하여 비동기 컴포넌트 로드\nimport { defineAsyncComponent } from 'vue';export default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =\u003e\n      import('./components/AsyncComponent.vue')\n    )\n  }\n};\n```\n\n# 예시: 동적 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003ccomponent :is=\"currentComponent\" /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ComponentA from './components/ComponentA.vue';\nimport ComponentB from './components/ComponentB.vue';\nexport default {\n  setup() {\n    const currentComponent = ref('ComponentA');    // 실제 상황에 맞게 currentComponent의 값을 변경하여 컴포넌트를 전환할 수 있습니다.\n    \n    // currentComponent.value = 'ComponentB';\n    \n    return { currentComponent, ComponentA, ComponentB };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: 비동기 컴포넌트를 사용할 때 컴포넌트 로딩 지연이나 실패와 같은 문제가 발생할 수 있어 사용자 경험에 영향을 줄 수 있습니다.\n\n해결책: 로딩 상태 힌트 및 오류 처리 매커니즘을 제공할 수 있습니다. 예를 들어, Suspense 컴포넌트를 사용하여 비동기 컴포넌트를 감쌀 수 있고 대체 콘텐츠(대체 콘텐츠)를 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003cSuspense\u003e\n    \u003ctemplate #default\u003e\n      \u003cAsyncComponent /\u003e\n    \u003c/template\u003e\n    \u003ctemplate #fallback\u003e\n      \u003cdiv\u003eLoading...\u003c/div\u003e\n    \u003c/template\u003e\n  \u003c/Suspense\u003e\n\u003c/template\u003e\n```\n\n위의 예제와 해결책을 통해 Vue 3의 모듈화 및 Composition API가 강력한 기능과 유연성을 제공하여 우리가 실용적인 개발 문제를 더 잘 해결하고 우아한 방식으로 복잡한 애플리케이션을 구축할 수 있음을 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"},"coverImage":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png","tag":["Tech"],"readingTime":5},{"title":"React-Native로 투두 앱 만드는 방법","description":"","date":"2024-05-01 18:04","slug":"2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png\" /\u003e\n\nReact-Native를 이용한 Todo List 애플리케이션 만들기에 대한 포괄적인 안내서에 오신 것을 환영합니다!\n\nReact-Native는 페이스북에서 개발한 강력한 프레임워크로, React의 익숙한 구문을 사용하여 크로스 플랫폼 모바일 애플리케이션을 개발할 수 있습니다. 이 튜토리얼에서는 컴포넌트, 상태 관리, 기본적인 스타일링을 포함한 React-Native의 필수 개념을 다룰 것입니다. 이 가이드의 끝에는 모바일 기기용 완전히 기능하는 Todo List 앱을 만들 준비가 될 것입니다.\n\n# 준비물\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n할 일 목록 앱을 만들기 전에 다음 사전 준비 사항이 갖춰져 있는지 확인해주세요:\n\n- JavaScript와 React 개념에 대한 기본 지식\n- 컴퓨터에 Node.js 및 npm이 설치되어 있어야 합니다.\n- Expo CLI가 npm install -g expo-cli 명령을 사용하여 전역으로 설치되어 있어야 합니다.\n- Visual Studio Code와 같은 코드 편집기\n- 테스트를 위해 Expo Go 앱이 설치된 모바일 기기\n\n# 단계 1: 프로젝트 설정하기\n\n첫 번째 작업은 Expo를 사용하여 React-Native 프로젝트를 설정하는 것입니다. 터미널을 열고 다음 명령을 실행해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1) React-Native 앱 만들기\n\n```js\nexpo init todo-app\n```\n\n## 2) 프로젝트 디렉토리로 이동\n\n```js\ncd todo-app\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3) 개발 서버 시작하기\n\n```js\nexpo start\n```\n\n이 명령어를 입력하면 새로운 React-Native 프로젝트인 \"todo-app\"이 생성되고 개발 서버가 시작됩니다.\n\n# 단계 2: 앱 컴포넌트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리의 할 일 목록 애플리케이션의 진입점인 App 컴포넌트를 만들어 봅시다.\n\n```js\n// App.js\nimport React from 'react';\nimport TodoList from './components/TodoList';\n\nexport default function App() {\n  return (\n    \u003cTodoList /\u003e\n  );\n}\n```\n\n# 단계 3: TodoList 컴포넌트 만들기\n\n이 단계에서는 작업 목록을 관리하고 작업 관련 기능을 처리할 TodoList 컴포넌트를 만들 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// components/TodoList.js\nimport React, { useState } from 'react';\nimport { View, TextInput, Button } from 'react-native';\nimport TodoItem from './TodoItem';\n\nexport default function TodoList() {\n  // State Hooks\n  const [tasks, setTasks] = useState([\n    { id: 1, text: '의사 예약', completed: true },\n    { id: 2, text: '학교 회의', completed: false },\n  ]);\n  const [text, setText] = useState('');\n  // Function to Add Task\n  function addTask() {\n    const newTask = { id: Date.now(), text, completed: false };\n    setTasks([...tasks, newTask]);\n    setText('');\n  }\n  // Function to Delete Task\n  function deleteTask(id) {\n    setTasks(tasks.filter(task =\u003e task.id !== id));\n  }\n  // Function to Toggle Task Completion\n  function toggleCompleted(id) {\n    setTasks(tasks.map(task =\u003e (task.id === id ? { ...task, completed: !task.completed } : task));\n  }\n  // Render TodoList Component\n  return (\n    \u003cView\u003e\n      {tasks.map(task =\u003e (\n        \u003cTodoItem\n          key={task.id}\n          task={task}\n          deleteTask={deleteTask}\n          toggleCompleted={toggleCompleted}\n        /\u003e\n      ))}\n      \u003cTextInput\n        value={text}\n        onChangeText={setText}\n        placeholder=\"새 작업\"\n      /\u003e\n      \u003cButton title=\"추가\" onPress={addTask} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- 필요한 모듈 가져오기: TodoList 컴포넌트에 필요한 모듈을 가져오는 것부터 시작합니다.\n- TodoList 컴포넌트 정의: 우리는 할 일 목록을 관리하는 중심 컴포넌트인 TodoList 함수형 컴포넌트를 선언합니다.\n- State Hooks: useState 훅을 사용하여 두 가지 상태 변수를 초기화합니다. tasks는 작업 목록을 관리하고, text는 새 작업을 추가하는 데 사용되는 입력 텍스트를 처리합니다. tasks 상태는 초기에 두 가지 예제 작업으로 설정됩니다.\n- 작업 추가 함수: addTask 함수는 고유 ID와 입력 텍스트, 완료 상태가 false로 설정된 새 작업 객체를 생성합니다. 그런 다음 새 작업을 추가하고 입력 텍스트를 재설정하여 tasks 상태를 업데이트합니다.\n- 작업 삭제 함수: deleteTask 함수는 주어진 ID를 가진 작업을 tasks 상태에서 제거합니다.\n- 작업 완료 토글 함수: toggleCompleted 함수는 주어진 ID를 가진 작업의 완료 상태를 토글합니다. map 메서드를 사용하여 대상 작업의 완료 상태가 뒤바뀐 새로운 작업 배열을 생성합니다.\n- TodoList 컴포넌트 렌더링: TodoList 컴포넌트는 map 메서드를 사용하여 작업 목록을 렌더링하며, 각 작업을 TodoItem 컴포넌트에 전달합니다. 또한 새 작업을 입력하는 TextInput과 addTask 함수를 트리거하는 Button을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 TodoList에서 개별 작업을 나타내는 TodoItem 컴포넌트를 생성할 차례입니다.\n\n```js\n// components/TodoItem.js\nimport React from 'react';\nimport { View, Text, CheckBox, Button } from 'react-native';\n\nexport default function TodoItem({ task, deleteTask, toggleCompleted }) {\n  return (\n    \u003cView\u003e\n      \u003cCheckBox\n        value={task.completed}\n        onValueChange={() =\u003e toggleCompleted(task.id)}\n      /\u003e\n      \u003cText style={{ textDecorationLine: task.completed ? 'line-through' : 'none' }}\u003e\n        {task.text}\n      \u003c/Text\u003e\n      \u003cButton title=\"X\" onPress={() =\u003e deleteTask(task.id)} /\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- CheckBox: CheckBox 컴포넌트는 작업의 완료 상태를 나타냅니다. 그 값은 작업의 완료 상태에 따라 결정되며, onValueChange는 체크박스와 상호작용할 때 toggleCompleted 함수를 호출합니다.\n- 스타일이 적용된 Text: Text 컴포넌트는 작업 텍스트를 표시합니다. 작업이 완료되었을 경우 라인 스타일을 줄 긋게 만드는 스타일이 적용됩니다.\n- 삭제 버튼: Button 컴포넌트는 \"X\" 레이블이 있는 삭제 버튼을 제공합니다. 버튼을 누르면 deleteTask 함수가 호출됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 5: 스타일링\n\n할 일 목록을 시각적으로 더 매력적으로 만들기 위해, 기본적인 스타일을 적용해 보겠습니다. 프로젝트에서 styles.css라는 파일을 생성하고 아래 스타일을 추가해주세요:\n\n```js\n/* styles.css */\n.todo-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center; /* 아이템을 수직으로 중앙 정렬합니다 */\n  margin-bottom: 8px;\n  padding: 8px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n}\n.todo-item-text {\n  flex: 1; /* 텍스트가 남은 공간을 차지할 수 있도록 설정합니다 */\n  margin-right: 8px;\n  color: #333;\n}\n.completed {\n  text-decoration: line-through;\n  color: #888;\n}\n.delete-button {\n  background-color: #ff6347; /* 토마토 색 */\n  color: #fff;\n  padding: 4px 8px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n```\n\n이제, TodoItem.js 파일에서 styles.css를 import하여 로컬에서 스타일을 적용해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// components/TodoItem.js\nimport React from 'react';\nimport { View, Text, CheckBox, TouchableOpacity } from 'react-native';\nimport styles from './styles'; // 스타일 가져오기\n\nexport default function TodoItem({ task, deleteTask, toggleCompleted }) {\n  return (\n    \u003cView style={styles.todo-item}\u003e\n      \u003cCheckBox\n        value={task.completed}\n        onValueChange={() =\u003e toggleCompleted(task.id)}\n      /\u003e\n      \u003cText style={[styles.todo-item-text, task.completed \u0026\u0026 styles.completed]}\u003e\n        {task.text}\n      \u003c/Text\u003e\n      \u003cTouchableOpacity\n        style={styles.delete-button}\n        onPress={() =\u003e deleteTask(task.id)}\n      \u003e\n        \u003cText style={{ color: '#fff' }}\u003e삭제\u003c/Text\u003e\n      \u003c/TouchableOpacity\u003e\n    \u003c/View\u003e\n  );\n}\n```\n\n# 설명:\n\n- .todo-item : 각 할 일 항목에 플렉스 레이아웃을 적용하고 항목을 가로로 정렬하여 간격을 두고 깔끔한 외관을 위해 패딩, 테두리 및 테두리 반경을 추가합니다.\n- .todo-item-text : 텍스트가 나머지 공간을 차지하도록 하며 오른쪽 여백을 추가하고 텍스트 색상을 변경합니다.\n- .completed : 완료된 작업에 대해 가로 줄 꾸미기 및 텍스트 색상 변경을 추가합니다.\n- .delete-button : 빨간색 배경, 흰색 텍스트, 패딩 및 테두리 반경으로 삭제 버튼을 스타일링합니다. 또한 상호 작용을 위해 커서 포인터를 제공합니다.\n\n여기까지 완료되었습니다! React-Native를 사용하여 직접 Todo List 앱을 만들었다니 축하드립니다. 이 안내서를 통해 React-Native 컴포넌트, 상태 관리, 훅, 프롭스, 이벤트 처리를 이해하고 스타일링을 향상시켰습니다. 이제 당신이 이룬 것을 되돌아보고 다음 단계를 생각해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마지막으로\n\n할 일 목록 앱을 만드는 것은 단지 React-Native 여행의 일부에 불과해요. 닦은 토대 위에, 어디로 나아갈지 고민할 때입니다. 할 일 편집, 드래그 앤 드롭으로 재정렬, 또는 백엔드 통합에 대해 고려해보세요. 이러한 기능을 추가하여 앱을 더욱 발전시켜보세요.\n\n그리고 여기서 멈추는 것은 왜 그런가요? 도전을 받아들이고, 실시간 채팅과 소셜 기능을 탐험하여 앱을 더욱 상호작용적으로 만들어 보세요. Amity의 채팅 및 소셜 SDK가 제공하는 것을 한 번 살펴보세요. 다음 큰 프로젝트에 빠진 퍼즐 조각이 될 지도 모릅니다. 또한, 채팅, 소셜 및 라이브 스트리밍에 대한 완성된 솔루션이 비즈니스 목표와 일치한다면, 주저하지 말고 Amity에 연락하여 일을 가속화하세요.\n\n코딩과 학습을 계속하면서, 코드 한 줄이 한 걸음을 의미한다는 것을 기억하세요. 따라서 계속 전진하고 새로운 지평을 탐험하며, React-Native 개발의 흥미로운 세계를 받아들이세요. 당신의 코딩 여행에 건배합니다!","ogImage":{"url":"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingaTodoListAppwithReact-NativeAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"ReactJS, NextJS 제대로 알고 쓰자 - React JSX 마스터하기","description":"","date":"2024-05-01 18:03","slug":"2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX","content":"\n\nReact JSX는 JavaScript XML의 약자로, 개발자들이 JavaScript 내에서 직접 HTML과 유사한 코드를 작성할 수 있는 강력한 구문 확장 기능입니다. React 개발 세계에서 JSX는 사용자 인터페이스와 컴포넌트를 정의하는 데 중요한 역할을 합니다. JSX를 이해하는 것은 React를 다루는 데 필수적이며, 코드의 가독성과 유지보수성을 크게 향상시킵니다.\n\n이 포괄적인 가이드에서 React JSX에 대한 중요한 내용부터 문법과 사용법, 그리고 JavaScript로 변환하는 방법까지 알아보겠습니다.\n\nJSX는 JavaScript를 위한 구문 확장 기능으로, 개발자들이 JavaScript 파일 내에서 HTML과 유사한 코드를 작성할 수 있도록 합니다. React 애플리케이션에서 UI 컴포넌트를 정의하는 익숙하고 표현적인 방법을 제공합니다. JSX는 별도의 템플릿 언어가 아닌, React 요소를 생성하는 것을 단순화하는 구문적 설탕입니다.\n\nReact에서 JSX를 사용하는 주요 이유 중 하나는 HTML과 유사한 구문을 JavaScript 표현식과 혼합할 수 있는 능력 때문이며, 이를 통해 UI 코드를 이해하고 유지하기 쉽게 만듭니다. JSX를 활용함으로써, 개발자들은 HTML과 유사한 코드를 작성할 수 있으면서 JavaScript와 같은 동작을 수행하도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX 구문은 HTML과 매우 닮아 있어 개발자들이 UI 요소와 컴포넌트를 선언적으로 정의할 수 있습니다. JSX 태그는 HTML 태그와 유사하지만 실제로는 React.createElement()를 호출하는 문법 설탕입니다.\n\n```js\nconst element = \u003ch1\u003eHello, JSX!\u003c/h1\u003e;\n```\n\nJSX는 중괄호 {} 안에 JavaScript 표현식을 포함할 수도 있습니다. 이를 통해 동적 콘텐츠, 변수, 그리고 함수 호출을 JSX 요소 내부에 직접 포함할 수 있습니다.\n\n```js\nconst name = 'John';\nconst element = \u003ch1\u003eHello, {name}!\u003c/h1\u003e;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX 표현식을 사용하면 JavaScript 로직을 JSX 요소 안에 직접 삽입할 수 있습니다. 이를 통해 애플리케이션 상태에 따라 동적 콘텐츠 렌더링 및 조건부 렌더링이 가능해집니다.\n\n```js\nconst isLoggedIn = true;\nconst greeting = isLoggedIn ? \u003ch1\u003e다시 오신 것을 환영합니다!\u003c/h1\u003e : \u003ch1\u003e로그인하세요\u003c/h1\u003e;\n```\n\nJSX 표현식에는 변수, 함수, 심지어 복잡한 로직도 포함할 수 있어 React 애플리케이션에서 동적 UI를 구축하는 다재다능한 도구로 활용됩니다.\n\nReact에서 JSX 요소는 UI 컴포넌트의 구성 요소를 나타냅니다. JSX를 사용하면 개발자가 사용자 정의 요소를 생성하고 이를 결합하여 복잡한 인터페이스를 구축할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst App = () =\u003e {\n  return (\n    \u003cdiv\u003e\n      \u003cHeader /\u003e\n      \u003cMainContent /\u003e\n      \u003cFooter /\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\nJSX 요소는 props 및 children도 받아들일 수 있어서 유연한 컴포넌트 조합과 재사용이 가능합니다.\n\nJSX는 실제로는 Babel과 같은 도구에 의해 일반 JavaScript 코드로 변환됩니다. JSX 요소는 React.createElement() 호출로 컴파일되어 JSX 구문에서 React 엘리먼트를 생성합니다.\n\n```js\nconst element = \u003ch1\u003eHello, JSX!\u003c/h1\u003e;\n// 컴파일 후:\nconst element = React.createElement('h1', null, 'Hello, JSX!');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSX가 JavaScript로 변환되는 과정을 이해하는 것은 React 애플리케이션의 디버깅과 최적화에 필수적입니다.\n\nJSX 작업 시에는 최상의 관례를 따르는 것이 중요합니다. 이는 일관된 들여쓰기, JSX 프래그먼트의 올바른 사용, 이벤트 처리의 올바른 방법, 그리고 컴포넌트 내부에서 책임을 분리하는 것을 포함합니다.\n\n```js\nconst Button = ({ onClick, children }) =\u003e {\n  return \u003cbutton onClick={onClick}\u003e{children}\u003c/button\u003e;\n};\n```\n\n최상의 관행을 준수함으로써 개발자는 효율적이고 가독성 있는 JSX 코드를 작성할 수 있으며 유지보수 및 확장이 쉬운 코드를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 JSX는 리액트 애플리케이션에서 UI 개발을 간소화하는 강력한 도구입니다. 문법, 표현식, 요소, 그리고 최상의 방법을 이해함으로써, 개발자들은 손쉽게 견고하고 유지보수가 쉬운 사용자 인터페이스를 구축할 수 있습니다.\n\n이 안내서에서는 리액트 JSX의 기초부터 문법과 사용법, 최상의 방법, 그리고 자바스크립트로 변환하는 것까지 다루었습니다. 이 지식을 바탕으로, 여러분은 리액트 개발을 깊이있게 알아가고 여러분의 프로젝트에서 JSX의 전체 잠재력을 활용할 준비가 되었습니다.\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png"},"coverImage":"/assets/img/2024-05-01-UnleashingthePotentialofReactJSNextJSChapter04MasteringReactJSX_0.png","tag":["Tech"],"readingTime":3},{"title":"Zustand vs. Redux: 상태 관리 어떤 것을 사용해야할까? 비교 정리","description":"","date":"2024-05-01 18:02","slug":"2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement","content":"\n\n![이미지](/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png)\n\n현재 웹 개발에서 상태 관리는 응용 프로그램의 성능, 확장성 및 유지 관리성에 직접적인 영향을 미치는 중요한 측면입니다. 전통적으로 Redux는 React 애플리케이션에서 상태를 관리하는 데 사용되는 주요 라이브러리였습니다. 그러나 최근에 Zustand가 경쟁 대상으로 등장하여 더 간단하고 효율적인 대안을 제공하고 있습니다. 이 문서에서는 많은 개발자들이 Zustand를 Redux보다 더 나은 상태 관리 시스템으로 여기는 이유를 살펴볼 것입니다.\n\n# 1. 간결함과 크기\n\nRedux는 강력하지만 그 힘은 복잡성과 함께 옵니다. 액션, 리듀서 및 저장소 설정이 필요하며, 이는 초보자에겐 압도적일 수 있습니다. 반면 Zustand는 최소주의 방법을 취합니다. 복잡한 설정 없이 상태 관리를 제공하는 단일 훅입니다. 이 간결함은 Zustand를 접근하기 쉽게 만들어주며, 특히 작은 프로젝트나 상태 관리에 새로운 개발자들에게 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRedux의 크기는 성능이 중요한 웹 애플리케이션에서도 고려해야 할 사항일 수 있습니다. 그것은 광범위한 기능 세트로 인해 상당한 번들 크기를 가지고 있습니다. 무게가 가벼운 Zustand(압축 후 1KB 미만)는 번들 크기를 유지하는 데 도움을 주어 로드 시간을 단축하고 성능을 향상시킵니다.\n\n# 2. 불변성이 쉬워집니다\n\nRedux는 예측 가능한 상태 변경을 위한 좋은 사례인 불변성을 강제합니다. 그러나 이를 달성하기 위해 종종 많은 보일러플레이트 코드가 필요합니다. Zustand는 React의 useReducer와 useState 훅과 통합되어 상태를 직접 변경할 수 있도록 하여 불변성을 간소화합니다. 이는 완전히 불변성을 포기해야 한다는 뜻은 아니지만 Zustand는 상태 변경을 처리하는 보다 편리한 방법을 제공합니다.\n\n# 3. 편리한 API\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand API는 React 개발자들에게 자연스러운 느낌을 제공하도록 설계되었습니다. 스토어를 정의할 때 간단한 create 함수와 상태에 액세스하기 위한 hook을 제공합니다.\n\n다음은 기본적인 예시입니다:\n\n```js\nimport create from 'zustand';\nconst useCountStore = create((set) =\u003e ({\n  count: 0,\n  increment: () =\u003e set((state) =\u003e ({ count: state.count + 1 })),\n  decrement: () =\u003e set((state) =\u003e ({ count: state.count - 1 })),\n}));\n\nfunction Counter() {\n  const count = useCountStore((state) =\u003e state.count);\n  const increment = useCountStore((state) =\u003e state.increment);\n  const decrement = useCountStore((state) =\u003e state.decrement);\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={increment}\u003eIncrement\u003c/button\u003e\n      \u003cbutton onClick={decrement}\u003eDecrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 API는 직관적이고 간결하여 Zustand를 사용하기 쉽게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 성능 최적화\n\nZustand은 React의 컨텍스트와 후크를 활용하여 다시 렌더링을 최적화합니다. React의 내장된 메모이제이션 덕분에 변경된 특정 상태를 사용하는 컴포넌트만 다시 렌더링됩니다. 이는 때로는 불필요한 업데이트가 발생할 수 있는 Redux와 비교해 적은 수의 다시 렌더링을 가져올 수 있습니다.\n\n# 5. 개발 도구 통합\n\nRedux는 디버깅에 매우 유용한 개발자 도구 생태계를 갖추고 있습니다. Zustand은 Redux와 같이 전용 개발 도구 확장 기능을 갖추고 있지 않지만, Redux DevTools 또는 React DevTools와 같은 인기있는 개발 도구와 통합할 수 있습니다. 이를 통해 Redux와 동일하게 Zustand 스토어를 검사하고 타임 트래블 디버깅할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. React Concurrent Mode 호환성\n\nReact Concurrent Mode의 등장으로, Zustand는 이와 원활하게 작업할 수 있습니다. Concurrent Mode는 React 애플리케이션의 성능과 반응성을 향상시키기 위해 설계되었으며, Zustand의 가벼운 성격은 이 목표와 잘 맞습니다.\n\n## 7. 커뮤니티 및 채택\n\nRedux는 오랜 기간동안 존재하며 방대한 커뮤니티와 생태계를 갖추고 있습니다. 대규모 및 복잡한 애플리케이션에 유리할 수 있습니다. 그러나 Zustand의 커뮤니티는 꾸준히 성장하고 있으며, 그 간결함과 사용 편의성으로 더 많은 개발자들을 끌어들이고 있어 새로운 프로젝트에 유망한 선택지가 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n종합적으로, Zustand와 Redux는 둘 다 가능성 있는 상태 관리 라이브러리이지만, 그 적합성은 프로젝트 요구사항과 팀원들의 익숙함에 따라 다릅니다. Zustand는 간결함, 크기, 그리고 사용 편의성 측면에서 빛을 발하며, 이는 작거나 중간 규모의 프로젝트나 복잡하지 않은 상태 관리 솔루션을 선호하는 개발자들에겐 탁월한 선택이 될 수 있습니다. Redux는 광범위한 생태계와 도구들을 갖추고 있어, 복잡한 상태 관리가 필요한 대규모 애플리케이션에는 여전히 견고한 선택이 될 것입니다. 결국, Zustand와 Redux 사이의 선택은 프로젝트의 구체적인 요구사항과 제약 사항에 기반하여 이루어져야 합니다.","ogImage":{"url":"/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png"},"coverImage":"/assets/img/2024-05-01-ZustandvsReduxAComprehensiveComparisoninStateManagement_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년 최고의 React 보일러플레이트 소개","description":"","date":"2024-05-01 17:59","slug":"2024-05-01-TopReactBoilerplates2024completeresearch","content":"\n\n\n![React](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png)\n\n# 웹 프레임워크 선택 문제\n\n요즘 React는 시대를 앞서가는 인터페이스 프레임워크 중 하나로 자리매김했습니다. 2023년 설문조사에 따르면 전 세계 개발자 중 40.58%가 React.js를 사용하고 있어 가장 인기 있는 웹 프레임워크 중 하나로 떠올랐습니다. Facebook에서 개발된 React.js는 PayPal, Uber, Instagram, Airbnb와 같은 주요 기업들이 사용하여 사용자 인터페이스를 강화하고 있습니다. 확실히 React는 생산성, 구성 요소 기반 아키텍처 및 선언적 구문의 조합으로, 널리 사용되고 강력한 커뮤니티 지원을 받고 있습니다. 이는 개발자들이 이전보다 더 많은 프로젝트를 React로 구축하고 있다는 것을 의미합니다.\n\nReact 라이브러리는 의견을 가지지 않는 설계로, '맨 처음에' 정의되고 구성 요소를 관리하는 핵심 기능 이외에는 실제로 거의 어떤 추가 기능도 포함하지 않습니다. 따라서 프로퍼티 전달, 구성 요소 분해, React 응용 프로그램 파일 구조화, 전체 응용 프로그램 규모 확장 및 기타 세부 사항에 대한 최상의 방법을 알지 못하는 경우 쉽게 혼동할 수 있습니다. 이러한 함정은 내장 함수 및 구성 요소를 포함하여 개발 프로세스를 최적화하고 개발자가 초기 설정 및 구성 처리에 시간을 허비하는 대신 응용 프로그램 로직을 구축하는 데 집중할 수 있도록 하는 보일러플레이트를 사용하여 피할 수 있습니다. 다시 말해, 응용 프로그램 개발을 시작하는 표준화된 기점 역할을 합니다. GitHub에서 'react-boilerplate'을 검색하면 현재 44.8k 저장소가 나옵니다. 개발용으로 선택할 템플릿을 결정할 때, 자신의 응용 프로그램에 해당하고 확장성과 향후 유지 관리에 좋은 것을 선택하는 문제가 생깁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# React 보일러플레이트 유형\n\n과거에는 React 프로젝트를 시작하는 가장 일반적인 방법은 create-react-app (CRA)이었습니다 — 이는 Facebook에서 인기 있는 공식 보일러플레이트였습니다. 그러나 2023년 3월 16일에 발표된 새로운 React 문서에서는 더 이상 CRA를 React 프로그램을 만드는 최적의 해결책으로 권장하지 않습니다. 대안을 고려하고 비교하여 프로젝트를 시작하는 가장 좋은 방법을 결정해봅시다.\n\nReact 보일러플레이트의 다양한 측면을 탐구함으로써, 어떤 기준으로 나눌 수 있는지 살펴보겠습니다:\n\n라이브러리와 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 미니멀리즘 보일러플레이트: React 프로젝트를 위한 기본 구성을 제공하며, Webpack, Babel, ESLint 등의 기본 설정을 포함합니다. 개발자가 필요에 따라 특정 라이브러리와 기능을 추가할 것으로 가정합니다. 대부분의 보일러플레이트가 이 범주에 속합니다.\n- 기능이 풍부한 보일러플레이트: 미리 구성된 추가 라이브러리와 도구를 포함합니다. 상태 관리(예: Redux), 라우팅(React Router), 테스팅 등을 포함할 수 있으며, 기본 UI 구성 요소와 페이지를 포함할 수도 있어 개발 속도를 높여 공통 UI 요소와 레이아웃을 제공합니다.\n\n인증 및 등록:\n\n- 인증 및 등록을 위한 보일러플레이트: 로그인, 가입, 사용자 세션을 위한 컴포넌트를 포함합니다.\n- 인증 없는 보일러플레이트: 인증 구현을 개발자에게 맡깁니다.\n\n풀 스택 vs. 프론트엔드 전용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 풀 스택 보일러플레이트: React를 사용한 프론트엔드와 백엔드를 모두 다루는 웹 애플리케이션을 구축하기 위한 종합적인 솔루션을 제공합니다.\n- 프론트엔드 전용 보일러플레이트: 주로 React 인터페이스에 초점을 맞춥니다. 개발자가 원하는 서버와 통합해야 합니다.\n\nUI 컴포넌트 라이브러리:\n\n- UI 컴포넌트가 포함된 보일러플레이트: 일관된 디자인 패턴(예: 버튼, 폼, 모달)을 준수하는 전체 UI 컴포넌트 세트가 포함되어 있습니다.\n- UI 컴포넌트가 없는 보일러플레이트: 개발자가 보일러플레이트를 사용하는 동안 컴포넌트를 완전히 개발해야 합니다.\n\n유료 vs. 무료:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료/오픈 소스 보일러플레이트: 사용에 제한이 없고 커뮤니티 지원이 있으며 종종 잘 유지보수됩니다.\n- 유료 보일러플레이트: 일부 상용 템플릿은 추가 기능, 프리미엄 지원 또는 확장된 기능을 제공합니다.\n\n위 분류에 따라 가장 인기 있는 React 보일러플레이트는 Vite, Create React App (CRA), Create Next App, Razzle 등이 있으며 React로 개발을 시작하는 데 필요한 기본 라이브러리와 구성만 포함하고 있습니다 (최소한의 보일러플레이트).\n\n# React 템플릿 선택 기준\n\n개발 중에 사용할 보일러플레이트를 결정하는 것은 그냥 애플리케이션을 만드는 것만큼이나 그 이후에 스케일링 및 유지보수하는 것과 관련이 있기 때문에 꽤 어려울 수 있습니다. 그래서 기존 보일러플레이트의 다양성에서 적절한 솔루션을 선택하고 일반적으로 어떻게 선택해야 하는 지 어떻게 결정할 수 있을까요? 프로젝트를 시작할 보일러플레이트를 선택할 때 주의를 기울여야 할 핵심 포인트는 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지원 및 유지보수 옵션: 프로젝트는 정기적으로 업데이트되나요?\n- 성능 점수\n- 코드 품질 (구조의 청결성, 확장 가능성, 코드 구성)\n- 제품 준비 상태: 프로젝트가 현재 제품 사용에 준비되었나요?\n- 인증, 라우팅, 국제화, 폼 처리, 테스팅, 기본 페이지 및 UI 구성 요소와 같은 기능의 가용성 — 목록은 계속될 수 있지만, 프로젝트 구현에 필요한 기능을 결정하고 뼈대에 찾으시면 됩니다.\n\n# 프로젝트 구조화 도구\n\nReact 애플리케이션을 개발하는 초기 단계는 일반적으로 Vite, Create React App, Create Next App 또는 Razzle 중 하나를 기반으로 선택하는 것을 포함합니다. 이러한 도구들은 프로젝트 구조 설정, 빌드 도구 구성, 그리고 개발 서버 제공과 관련해 프레임워크 유사한 기능을 제공합니다.\n\nVite는 웹 개발에서 빠른 개발 서버와 워크플로우 속도를 중점으로 두고 있습니다. 개발 중에 자체 ES 모듈을 가져와 시작 시간을 빠르게 하여 속도를 높입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCreate React App (CRA)은 Webpack, Babel 및 기타 빌드 도구의 설정 복잡성을 감추어주어 개발자들이 React 코드 작성에 집중할 수 있도록 도와줍니다. 효율적인 개발을 위해 핫 모듈 리로딩과 같은 기능을 제공합니다.\n\nNext.js는 서버 사이드 렌더링 및 정적 웹 애플리케이션을 구축하기 위한 React 프레임워크입니다. Next.js 프로젝트를 합리적인 기본 설정으로 구성하며, 서버 사이드 렌더링(SSR), 파일 기반 라우팅, API 라우트와 같은 기능을 제공합니다.\n\nRazzle은 에어비앤비에서 만든 빌드 도구로, 서버 사이드 렌더링을 단순화합니다. Razzle은 서버 사이드 렌더링 설정 복잡성을 감추어주고, 다재다능한 자바스크립트 애플리케이션을 쉽게 만들 수 있도록 합니다. 코드 분할, CSS-in-JS, 핫 모듈 교체와 같은 기능을 지원하여, 서버 사이드 렌더링이 필요한 React 애플리케이션을 구축하기에 적합합니다.\n\n상기 언급된 빌드 도구들은 종종 React 보일러플레이트로 언급됩니다. 설정 복잡성을 감춰주고 기본 설정을 제공하며 빌드 워크플로우를 최적화하는 기능만 제공하기 때문에, 추가적인 기능을 포함하고 있지는 않고 매우 기능이 제한되어 있습니다. 따라서 위의 분류에 따라, 이러한 도구들을 미니멀리스틱 보일러플레이트로 분류합니다. 기본 템플릿으로 대표되는 이 도구들은 보다 기능이 풍부한 React 보일러플레이트를 만드는 데 탁월한 도구입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 선택된 보일러플레이트 표\n\n이제 우리는 라이선스 수수료를 부과하지 않거나 기능을 유료로 제공하지 않는 React 보일러플레이트를 고려하고 또한 최근 업데이트 날짜를 고려합니다 (6개월 이내). 이에 따라, 우리는 12가지 보일러플레이트를 고려했습니다*:\n\n* 2024년 4월 기준\n\n# 기능 별 보일러플레이트 비교\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 보일러플레이트를 사용하여 개발자들이 얻을 수 있는 기능을 자세히 살펴보고 고려해야 할 사항을 알아보겠습니다:\n\nAPI 통합: 특정 API 또는 서버 서비스와 통합하기 위한 구성을 포함한 템플릿이 있을 수 있습니다.\n\n상태 관리 솔루션: Redux, MobX, Recoil과 같은 옵션 또는 React의 내장 상태 관리. 또한 비동기 React Query를 무시하기 어렵습니다.\n\n테스트 설정: 미리 정의된 테스트 설정 또는 전혀 없는 것들도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증 및 권한 부여: 사용자 인증 및 권한이 어떻게 정의되고 처리되는지, 특히 특정 인증 라이브러리와의 통합 여부가 명시되어 있는지 확인해주세요.\n\n국제화(i18n) 및 지역화(Localization): react-i18next나 react-intl과 같은 라이브러리를 사용하여 여러 언어를 지원할 수 있는 기능을 제공하는지 확인해주세요.\n\nESLint 규칙 준수: 코드 포맷팅 중에 문제를 감지하거나 수정하는 것뿐만 아니라 잠재적인 버그를 식별할 수 있도록 하는지 확인해주세요.\n\n스타일링 솔루션: CSS 모듈, styled-components 또는 UI 라이브러리를 사용하여 스타일드 컴포넌트를 쉽고 효율적으로 재사용할 수 있는 솔루션이 있는지 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 타입 안전성: TypeScript를 사용하여 개발 중 정적 유형을 제공하며, 클래스 또는 모듈을 활용하여 더 확장 가능하고 신뢰할 수 있는 애플리케이션을 만듭니다.\n\n앱 테마 선택: 사용자가 기본 설정 또는 자동 설정에 따라 라이트와 다크 테마 사이에서 전환할 수 있도록 합니다.\n\n사전 제작된 폼 컴포넌트: 양식 전체에서 재사용되도록 의도된 컴포넌트를 제공하여 코드 중복을 줄이고 표준화를 촉진합니다. 내장된 유효성 검사와 오류 처리를 포함할 수도 있으며, 개발을 더 신뢰할 수 있게 합니다.\n\nUI 컴포넌트 라이브러리: 버튼 및 모달 창과 같은 사전 제작 및 사용자 정의 가능한 컴포넌트를 제공하여 개발자가 애플리케이션에 쉽게 통합할 수 있습니다. 이러한 요소를 처음부터 디자인하고 코딩하는 시간과 노력을 절약할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 각 보일러플레이트를 분석한 후 다음과 같은 표를 얻었습니다:\n\n# 표의 보일러플레이트 설명\n\nExtensive-react-boilerplate. 이 React 보일러플레이트는 모든 종류의 프로젝트를 위해 설계되었습니다. 이는 백엔드 보일러플레이트 nestjs-boilerplate과 완벽하게 호환되는 것뿐만 아니라 독립적인 솔루션으로도 동작하여 주요 장점 중 하나입니다. 이 템플릿은 다음과 같은 다양한 기능을 제공합니다:\n\n- 사용자 인증 및 권한 부여, 구글 또는 페이스북 계정 사용 가능.\n- 페이지의 공개 또는 비공개 액세스 설정.\n- 코드 효율성과 깨끗함을 높이기 위한 사용자 정의 규칙이 설정된 ESLint.\n- 작성된 코드의 신뢰성을 확보하기 위한 타입 안전성.\n- 사용자 정의 useLanguage hook을 사용한 프로젝트 로컬라이징.\n- E2E 테스트 지원.\n- 사용자의 선택에 따라 Light 또는 Dark Mode.\n- MUI를 기반으로 한 컨트롤 컴포넌트 라이브러리, 기본적으로 react-hook-form과 통합되어 있어 입력 필드를 컨트롤러에 연결하는 추가 시간을 소비할 필요가 없습니다.\n- React Query를 사용한 비동기 작업 처리를 위한 상태 관리.\n- 사용자 관리 기능 (CRUD).\n- dropzone 기능이 있는 아바타 선택 및 업로드 기능.\n- 향상된 애플리케이션 성능과 SEO 최적화를 위한 Next.js 프레임워크 (SSR) 지원.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급된 기능들을 보시면, 이 보일러플레이트는 프로젝트의 시작 시간을 크게 줄여줍니다 (대략 193시간), 고려할 가치가 있는 선택입니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 프론트엔드 전용 (그리고 완벽히 호환되는 백엔드 보일러플레이트도 있어서 풀 스택 보일러플레이트로 사용할 수 있음), 무료.\n\nReact-starter-kit. React를 기반으로 웹 애플리케이션을 만들기 위한 템플릿입니다. CSS-in-JS, Vitest, VSCode 설정, Cloudflare 지원, SSR과 같이 미리 구성된 세팅이 제공됩니다. 데이터베이스로는 Firestore 연결이 사용됩니다. Joy UI를 기반으로 한 툴바나 사이드바와 같은 몇 가지 UI 구성 요소가 구현되어 있습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact-redux-saga-boilerplate. Redux를 사용하여 상태 관리를 하는 React 애플리케이션을 생성하는데 사용하는 스타터 프로젝트입니다. 유닛 및 엔드 투 엔드 테스트, react-helmet 지원하며, Emotion 라이브러리를 사용하여 CSS 스타일링을 간단하게 합니다. styled 기능을 사용하여 헤더나 푸터와 같은 사용자 정의 컴포넌트를 제공합니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nNext-js-Boilerplate. 이 보일러플레이트는 유연한 코드 구조를 가지고 있어 필요한 기능을 선택하고 저장하기만 하면 됩니다. Tailwind CSS 통합, Clerk와의 인증 지원, SQLite, PostgreSQL, 그리고 MySQL 데이터베이스와 호환됩니다. 유닛 테스트는 Jest를 사용하며, Zod 라이브러리는 유효성 검사 스키마에 사용됩니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 및 등록이 있는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라디안-리액트-템플릿. 이 보일러플레이트는 다국어 지원, 부드러운 애니메이션 및 JSON 파일에 모든 콘텐츠를 저장하여 React.js에 대한 사전 지식이 없어도 텍스트를 관리할 수 있도록 해줍니다. styled-components를 사용하여 HTML 엘리먼트를 스타일링한 자체 컴포넌트(버튼, 입력란, 텍스트영역 등) 세트를 포함하고 있습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n코어. Vite를 기반으로 빠른 프로젝트 생성 도구를 사용하여 개발된 현대적인 템플릿입니다. TypeScript를 지원하여 타입 안정성을 제공하며 ESLint, Prettier, CommitLint, Husky, Lint-Staged에 대한 좋은 구성을 포함하고 있습니다.\n\n카테고리: 최소주의 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNextjs-boilerplate. 이 React 보일러플레이트는 정적 페이지 생성을 위해 Next.js를 사용합니다. git 메시지 규칙을 지원하며, Plop를 사용하여 컴포넌트 생성을 지원하며, Tailwind CSS를 사용하여 스타일을 구성합니다. 컴포넌트 문서화를 위해 Storybook이 포함되어 있습니다.\n\n카테고리: 미니멀리즘 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nReact-pwa. 프로젝트를 처음부터 시작하기 위한 준비된 세트입니다. React 애플리케이션을 개발할 때 개발자들이 typicall하게 필요로 하는 핵심 라이브러리, 컴포넌트 및 유틸리티의 미니멀한 결합으로 구성되어 있습니다. 페이지의 오류 처리를 위한 자체 HOC가 포함되어 있으며, Vite를 기반으로 개발되었습니다.\n\n카테고리: 기능이 풍부한 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비타민. Tailwind CSS와 기본적인 스타일 리셋이 포함된 스타터 프로젝트로, Prettier 플러그인을 사용하여 자동으로 클래스를 정리합니다. Vitest, Testing Library, Cypress 등의 도구를 사용하여 테스트하지만, React UI 컴포넌트 라이브러리는 포함되어 있지 않습니다.\n\n카테고리: 미니멀리즘 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nNext-saas-stripe-starter. 이 보일러플레이트를 사용하면 Next.js, Prisma, Planetscale, Auth.js v5, Resend, React Email, Shadcn/ui, Stripe와 같은 기능을 추가하여 프로젝트 기능을 확장할 수 있습니다. Radix UI와 Tailwind CSS를 사용하여 구성된 컴포넌트 라이브러리가 포함되어 있습니다.\n\n카테고리: 기능 풍부한 보일러플레이트, 인증 및 등록이 포함된 보일러플레이트, 풀스택 보일러플레이트, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGatsby-starter-apple. 멋진 반응형 디자인을 갖춘 애플리케이션을 만들기 위한 템플릿으로, 모바일 메뉴에 애니메이션이 포함되어 있습니다. 사용된 컴포넌트들의 스타일링은 styled-components를 기반으로 합니다. 이 보일러플레이트는 검색 엔진 최적화를 잘 지원하며 RSS 피드 기능을 갖추고 있습니다.\n\n카테고리: 미니멀리스트 보일러플레이트, 인증 없는 보일러플레이트, 프론트엔드 전용, 무료.\n\nFullstack-typescript. 이 보일러플레이트는 프로젝트를 신속하게 시작하기 위한 풀스택 애플리케이션으로, Material UI를 기반으로 한 사용자 정의 컴포넌트 라이브러리를 갖추고 있습니다. 클라이언트-서버 통신에는 axios가 사용되며, Redux, MobX 등 특정 상태 관리 기술을 지원하지 않습니다.\n\n카테고리: 미니멀리스트 보일러플레이트, 인증 없는 보일러플레이트, 풀스택 보일러플레이트, 무료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일부 기능 구현 특이사항\n\n일반적으로, React 템플릿은 개발 프로세스의 속도를 높이고 표준화하기 위한 다양한 구현 기능을 제공합니다. 그 중에는 UI 컴포넌트 라이브러리와 스타일링, 상태 관리, 기본 ESLint 구성을 포괄하는 일반적인 접근 방식이 포함됩니다.\n\n## React UI 컴포넌트 라이브러리\n\nReact 보일러플레이트의 기능 구현은 주로 구성 요소가 재사용 가능하고 조합 가능하게 설계되어 있는 모듈화된 개발을 중심으로 진행됩니다. 현재 라이브러리를 분석하고 이 기사에 따르면, 다음은 가장 인기 있는 것들로 간주될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_1.png)\n\n지금은 Material UI가 가장 인기 있는 라이브러리로 91.2k 개의 GitHub 스타와 매주 300만 회 이상의 다운로드가 있습니다. 반응형 웹 디자인(RWD) 기능 덕분에 응용 프로그램이 다양한 화면과 장치에 자동으로 적응할 수 있으므로 안심할 수 있습니다.\n\n## 스타일링 솔루션\n\nCSS 모듈, styled-components, 또는 Sass와 같은 스타일링 솔루션은 일반적으로 React 보일러플레이트에 포함되어 있습니다. 이들은 컴포넌트에 스타일을 적용하는 다양한 방법을 제공하여 유연성과 확장성을 유지하면서 컴포넌트 캡슐화를 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstyled-components를 스타일링 솔루션으로 사용하는 장점:\n\n- 라이브러리가 페이지에 렌더링된 컴포넌트를 자동으로 추적하고 그 스타일만 적용합니다.\n- 스타일에 고유한 클래스 이름을 자동으로 생성하여 클래스 이름에 오류가 없도록 합니다.\n- 스타일이 특정 컴포넌트에 연결되어 CSS 자체를 쉽게 제거할 수 있습니다.\n- 코드에서 보이는 것처럼 손쉬운 동적 스타일링(bc-boilerplates에서 인스턴스 코드 아래 참고).\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_2.png)\n\n5. 스타일링 중 컴포넌트의 동적 props를 사용합니다. 이를 통해 변수의 값에 따라 스타일이 업데이트되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_3.png)\n\n6. 이를 통해 한 구성 요소에서 다른 구성 요소로 스타일을 재사용하거나 다른 구성 요소에 영향을 미칠 수 있습니다 (상위-하위 관계).\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_4.png)\n\n## 상태 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 관리는 복잡한 애플리케이션에서 특히 확장성과 유지 보수성을 제공하는 중요한 요소입니다. 보통 상태 관리 도구를 선택할 때 Redux, MobX, Zustand이 떠오릅니다. 그러나 이들은 클라이언트 측 라이브러리이며, 비동기 데이터 저장과 같은 작업에 React Query와 비교했을 때 효율적이지 않을 수 있습니다.\n\nReact Query는 서버 상태 라이브러리입니다. 서버와 클라이언트 간 비동기 작업을 관리할 뿐만 아니라 React 및 Next.js 애플리케이션에서 데이터 검색, 캐싱 및 업데이트를 위한 기능을 제공하는 역할을 합니다. 몇 줄의 코드로 React Query는 클라이언트 상태에서 캐시된 데이터를 관리하기 위해 사용되는 부재 코드를 대체합니다. 이 상태 관리 접근 방식은 extensive-react-boilerplate에서 사용됩니다.\n\n## 보일러플레이트의 ESLint 규칙\n\n프로젝트 개발 중 ESLint 규칙을 사용하는 효율성은 사용자 지정 규칙을 작성하는 데도 나타납니다. ESLint는 포맷팅 및 규칙뿐만 아니라 내부 프로젝트 결정 사항도 고려할 수 있도록 많은 기능과 유연성을 제공합니다. 예를 들어, 폼 작업 시 불필요한 렌더링 가능성을 제어하고 개발자에게 경고를 주거나, 객체 작업 시에는 잘못된 솔루션을 알리거나, 사용하지 않는 import를 가리킬 수 있습니다. 예를 들어, extensive-react-boilerplate에서는 이러한 문제를 다음과 같이 다룹니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 패턴을 잘못 사용한 경우의 규칙에 대해 경고합니다\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_5.png)\n\n- 제어할 수 없는 렌더링이 발생할 수 있다는 가능성을 알립니다\n\n![이미지](/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n효과적인 React 템플릿을 선택하는 것은 프로젝트의 성공에 중요합니다. 바퀴를 다시 발명하는 대신, 잘 선택된 보일러플레이트의 파워를 활용하면 개발 프로세스를 크게 가속화하고 견고한 기반을 구축할 수 있습니다. 보일러플레이트를 선택할 때, 해당 디렉토리 구조와 구성 파일을 숙지하여 기반, 통합 용이성, 모듈화 및 기술적 요구에 최대한 부합하는지를 이해하는 것이 좋습니다. 제공되는 기능이 필요한 기능을 제공할 수 있는지 고려하십시오. 이렇게 하면 개발 시간을 절약하고 잘 유지되고 테스트된 코드를 활용할 수 있을 수도 있습니다.\n\n다양한 보일러플레이트를 동시에 적용하는 방법에 대한 질문이 자주 있었는데, 이러한 템플릿에서 포괄적인 기능이 부족한 점 때문에 bc 보일러플레이트 팀은 광범위한 리액트 보일러플레이트로 해결책을 제안했습니다. 우리는 이견을 제시하고 널리 알려진 대안들 사이에서 자리를 잡고 주목할만한 경쟁 상대가 될 수 있는 것으로 생각합니다. 이제 한 번 시도해보시고 새로운 스타로서의 피드백을 기다리겠습니다.\n\n# 간단하게 이야기하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클로하고 팔로우해주세요 👏\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png"},"coverImage":"/assets/img/2024-05-01-TopReactBoilerplates2024completeresearch_0.png","tag":["Tech"],"readingTime":13},{"title":"React Hook Form과 Zod, MUI로 React Form 만들기","description":"","date":"2024-05-01 17:57","slug":"2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio","content":"\n\nReact Hook Form과 Zod 스키마를 사용하여 효율적으로 유효성을 검사하는 방법을 배우세요. MUI 컨트롤과 함께 사용하여 양식 유효성 검사 능력을 한 단계 업그레이드하세요. 이 포괄적인 가이드를 통해 React 애플리케이션에서 견고함과 정확성을 보장하세요. 통합 프로세스를 몰두하고 개발 워크플로우를 간소화하세요!\n\n효율적이고 사용자 친화적인 양식을 작성하는 것은 React 애플리케이션에서 중요합니다. 그러나 유효성 검사, 상태 및 스타일 관리는 지루하고 복잡해질 수 있습니다. 이것이 React Hook Form, Zod 및 MUI의 조합이 빛을 발하는 곳입니다!\n\n![](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png)\n\nReact Hook Form:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 선언적 접근 방식: 등록, 유효성 검사 및 제출에 대한 후크를 사용하여 양식 관리를 간소화합니다.\n- 내장 유효성 검사: 외부 라이브러리가 필요하지 않습니다. 양식 내에서 직접 유효성 검사 규칙을 정의하세요.\n- 비제어 컴포넌트: 네이티브 HTML 입력 또는 제어 컴포넌트를 활용하여 유연성을 높이세요.\n\nZod:\n\n- 유형 안전한 유효성 검사: 강력한 스키마 유효성 검사 라이브러리로 데이터 품질을 보장하세요.\n- 명확한 오류 메시지: Zod 스키마를 사용하면 사용자가 어떤 오류가 발생했는지 이해할 수 있도록 명확한 오류 메시지를 작성할 수 있습니다. 더 나아가 중첩된 유효성 검사를 사용하여 고급 유효성 검사 규칙을 작성할 수 있어 복잡한 데이터 구조를 처리하기가 더 쉬워집니다.\n- React Hook Form과의 통합: zodResolver와의 원활한 통합으로 양식에서 간편한 유효성 검사를 수행하세요.\n\nMUI:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아름다운 UI 구성 요소: 미리 만들어진 MUI 컴포넌트를 사용하여 시각적으로 매력적이고 접근성 있는 양식을 만들어보세요.\n- 사용자 정의: 브랜드 아이덴티티에 맞춰 테마를 사용자 정의하여 앱 UI의 모양과 느낌을 조정하세요.\n- 쉬운 통합: Material-UI 컴포넌트는 React Hook Form과 원활하게 통합되어 스타일 충돌 가능성을 줄입니다.\n\n이 3가지를 사용하는 장점:\n\n- 향상된 개발자 경험: 보일러플레이트를 줄이고 더 깔끔하고 유지보수하기 쉬운 코드를 작성하세요.\n- 향상된 사용자 경험: 자동 유효성 검사, 명확한 오류 메시지, 부드러운 작업 흐름을 활용하세요.\n- 오류 감소: 타입 안전한 유효성 검사로 데이터 문제를 일찍 발견하고 예방하세요.\n- 빠른 개발: 기능 구축에 집중하고 양식과의 싸움을 줄이세요.\n\n예제를 만들어봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 폼 유효성 검사를 위한 Zod 스키마 정의\n// Yup 유효성 검사를 대신 사용할 수도 있습니다.\nconst schema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일입니다.\").min(1, \"이메일은 필수입니다.\"),\n  password: z.string().min(6, \"비밀번호는 최소 6자 이상이어야 합니다.\"),\n  phoneNumber: z\n    .string()\n    .min(10, \"전화번호는 최소 10자 이상이어야 합니다.\")\n    .max(10)\n    .optional(),\n  country: z.string().min(1, \"국가는 필수입니다.\"),\n});\n```\n\n여기서 복잡한 객체를 Zod를 사용하여 유효성 검사하는 방법입니다.\n\n```js\nconst addressSchema = z.object({\n  street: z.string().min(1, \"거리를 입력해주세요.\"),\n  city: z.string().min(1, \"도시를 입력해주세요.\"),\n  zipCode: z\n    .string()\n    .min(5, \"우편번호는 최소 5자 이상이어야 합니다.\")\n    .refine(value =\u003e /^\\d+$/.test(value), {\n      message: \"우편번호는 숫자로만 이루어져야 합니다.\"\n    }),\n});\n\nconst userSchema = z.object({\n  email: z.string().email(\"유효하지 않은 이메일입니다.\").min(1, \"이메일은 필수입니다.\"),\n  password: z.string().min(6, \"비밀번호는 최소 6자 이상이어야 합니다.\"),\n  phoneNumber: z\n    .string()\n    .min(10, \"전화번호는 최소 10자 이상이어야 합니다.\")\n    .max(10)\n    .optional(),\n  country: z.string().min(1, \"국가는 필수입니다.\"),\n  address: addressSchema,\n});\n```\n\n폼 데이터의 유형을 정의하고 useForm 훅을 사용하여 입력 상태를 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 폼 데이터 유형 정의\ntype FormData = z.infer\u003ctypeof schema\u003e;\n// react-hook-form에서 useForm을 구조분해하여 가져옵니다\nconst {\n  // register: 입력 요소 등록 함수\n  register,\n  // handleSubmit: 폼 제출 처리 함수\n  handleSubmit,\n  // watch: 폼 입력 값 감시 함수\n  watch,\n  // formState: 폼 상태 정보를 포함한 객체\n  formState: { errors, touchedFields }, // formState에서 errors 및 touchedFields를 구조분해합니다\n} = useForm\u003cFormData\u003e({ // generic 타입 FormData로 useForm 훅 호출\n  // resolver: Zod를 사용하여 폼 유효성 검사에 대한 리졸버 지정\n  resolver: zodResolver(schema), // Zod 스키마를 리졸버에 전달\n  // defaultValues: 폼 입력의 기본 값 지정\n  defaultValues: {\n    email: \"\", \n    password: \"\", \n    phoneNumber: \"\",\n    country: \"\",\n  },\n});\n\n const onSubmit = (data: FormData) =\u003e {\n    console.log(data); // 제출된 데이터로 API 호출\n };\n```\n\nReact Hook Form과 Material-UI 컴포넌트, MUI 폼 컨트롤을 사용하여 폼을 생성해봅시다.\n\n```js\n        \u003cform onSubmit={handleSubmit(onSubmit)}\u003e\n          \u003cTypography variant=\"h4\" gutterBottom\u003e\n            회원가입\n          \u003c/Typography\u003e\n          \u003cTextField\n            label=\"이메일\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.email}\n            {...register(\"email\")}\n            error={!!errors.email}\n            helperText={errors.email?.message}\n          /\u003e\n          \u003cTextField\n            label=\"비밀번호\"\n            type=\"password\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.password}\n            {...register(\"password\")}\n            error={!!errors.password}\n            helperText={errors.password?.message}\n          /\u003e\n          \u003cTextField\n            label=\"전화번호\"\n            fullWidth\n            margin=\"normal\"\n            defaultValue={defaultValues.phoneNumber}\n            {...register(\"phoneNumber\")}\n            error={!!errors.phoneNumber}\n            helperText={errors.phoneNumber?.message}\n          /\u003e\n\n          \u003cFormControl fullWidth margin=\"normal\" error={!!errors.country}\u003e\n            \u003cInputLabel\u003e국가\u003c/InputLabel\u003e\n            \u003cSelect\n              label=\"국가\"\n              {...register(\"country\")}\n              defaultValue={defaultValues.country}\n              sx={ my: 1 }\n            \u003e\n              \u003cMenuItem value=\"USA\"\u003e미국\u003c/MenuItem\u003e\n              \u003cMenuItem value=\"Canada\"\u003e캐나다\u003c/MenuItem\u003e\n              {/* 필요한 경우 다른 국가 추가 */}\n            \u003c/Select\u003e\n            \u003cFormHelperText\u003e{errors.country?.message}\u003c/FormHelperText\u003e\n          \u003c/FormControl\u003e\n\n          \u003cButton type=\"submit\" variant=\"contained\" color=\"primary\"\u003e\n            제출\n          \u003c/Button\u003e\n        \u003c/form\u003e\n```\n\n위의 코드에서 무슨 일이 벌어지고 있는지 설명드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n- defaultValue={defaultValues.phoneNumber}: 여기서는 입력 필드의 기본값을 저장된 값으로 설정합니다.\n- {...register(\"phoneNumber\")}: 이 줄은 React Hook Form과 입력 필드를 등록하여 폼 데이터의 \"phoneNumber\" 필드와 연결합니다. 이를 통해 React Hook Form을 사용하여 폼 유효성 검사 및 데이터 처리를 활성화할 수 있습니다.\n- error={!!errors.phoneNumber}: 이 속성은 입력 필드에 대한 오류 상태를 표시할지 여부를 결정합니다. 만약 폼 데이터의 \"phoneNumber\" 필드에 오류가 있으면 오류 상태를 트리거합니다.\n- helperText={errors.phoneNumber?.message}: 여기서 \"phoneNumber\" 필드와 관련된 오류 메시지를 표시합니다. 오류가 없으면 이 속성은 비어 있지만, 폼 유효성 검사 중 오류가 발생하면 사용자에게 오류 메시지를 표시하여 안내합니다.\n```\n\n사용자에게 피드백을 제공하고 유효성 검사 오류를 조건적으로 표시하는 데 touchedFields 객체를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_1.png)\n\n예를 들어 사용자가 상호 작용한 필드에 대해서만 유효성 검사 오류를 표시하고 싶을 수 있습니다. 필드의 touched 상태가 true인지 확인하여 오류 메시지를 조건부로 렌더링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nerror={!!errors.firstName \u0026\u0026 touchedFields.firstName}\n```\n\nwatch를 사용하면 사용자가 입력하는 값의 변경 사항을 추적하고 반응할 수 있습니다. 비밀번호를 입력할 때 암호 강도를 표시하고 싶다면, 입력 값을 기반으로 실시간으로 유효성을 검사하는 watch를 사용하여 이를 달성할 수 있습니다.\n\n```js\nconst password = watch('password');\n\nuseEffect(() =\u003e {\n    console.log(passwordWatch); // 로깅\n    if (password.length \u003c 8 || !hasAlphabet(password) || !hasLowercase(password) || !hasSpecialCharacter(password)) {\n      // 비밀번호 강도 경고 표시\n    } else {\n      // 경고 숨기기\n    }\n  }, [password]);\n```\n\n비밀번호가 변경될 때마다 비밀번호 값이 변경되는 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_2.png\" /\u003e\n\nFormControl과 control은 서로 다른 목적을 가지고 있습니다.\n\nFormControl\n\n- Material-UI의 컴포넌트: 이 컴포넌트는 텍스트 필드, 체크박스, 라디오 버튼과 같은 폼 컨트롤을 스타일링하고 그룹화하기 위해 특별히 디자인된 컴포넌트입니다. 시각적 일관성과 접근성을 위한 스타일링 및 레이아웃 옵션을 제공합니다.\n- 예시: 코드에서 FormControl은 이메일과 비밀번호 필드를 위해 InputLabel과 Select 컴포넌트를 감싸는 데 사용되어, 레이블과 에러 처리를 포함하는 스타일링된 인풋 그룹을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨트롤\n\n- react-hook-form의 기능: useForm 훅에서 제공되는 함수로, 폼 입력을 등록하고 값 및 상태를 관리할 수 있게 해줍니다. 입력을 폼 상태에 연결하고 검증 및 상호작용 메커니즘을 제공하는 내부 논리를 처리합니다.\n- 예시: register 내에서 컨트롤 함수를 전달하면 필드 이름(이메일 또는 비밀번호)과 함께 입력을 폼 상태에 등록할 수 있습니다. 이렇게 하면 react-hook-form이 입력의 값을, 오류 및 검증 상태를 추적할 수 있습니다.\n\n![이미지](/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_3.png)\n\nreact-hook-form-mui 라이브러리를 사용하는 것을 고려해보세요. 이 라이브러리는 Material-UI 구성요소에 대한 사용자 지정 컴포넌트 및 래퍼를 제공하며, react-hook-form과 원활하게 통합됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반 사용 사례\n\nMaterial-UI 구성 요소를 사용할 때는 register 및 Controller 간의 선택이 특정 컴포넌트 및 원하는 제어 수준에 따라 달라집니다:\n\n다음에 register 사용:\n\n- 제어된 동작을 갖는 기본 Material-UI 구성 요소:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 텍스트 필드\n- 선택\n- 체크박스\n- 라디오 그룹\n\n컨트롤러 사용 사례:\n\n기본적으로 제어된 동작을 따르지 않는 고급 Material-UI 구성 요소\n\n- 자동 완성\n- 날짜 선택기\n- 시간 선택기\n- 스위치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 기능\n\n## Re-Renderers 분리하기\n\nRe-Renderers 분리하기는 React Hook Form의 기능 중 하나로, 필요한 컴포넌트만 다시 렌더링하여 폼의 성능을 개선할 수 있게 해줍니다. 전체 폼을 다시 렌더링하는 대신 업데이트해야 할 컴포넌트만 다시 렌더링하는 것이 중요합니다. 이는 폼이 로드되는 데 필요한 시간을 줄이고 사용자와의 상호 작용을 향상시킬 수 있습니다.\n\n세 개의 자식 컴포넌트를 포함한 폼이 있다고 상상해봅시다: 자식 컴포넌트 A, 자식 컴포넌트 B, 자식 컴포넌트 C. 제어되는 폼에서 자식 컴포넌트 A를 변경하면, 자식 컴포넌트 B와 자식 컴포넌트 C가 업데이트될 필요가 없더라도 세 개의 자식 컴포넌트가 모두 다시 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Hook Form을 사용하면 Child Component A의 다시 렌더링을 격리시켜 해당 컴포넌트가 변경되었을 때 해당 컴포넌트만 다시 렌더링됩니다. 이렇게 하면 대형이거나 복잡한 폼을 사용할 경우 폼의 성능을 크게 향상시킬 수 있습니다.\n\n# 결론\n\nReact Hook Form, Zod 및 MUI를 결합하여 견고하고 효율적이며 사용자 친화적인 폼을 만들어 React 개발 경험을 향상시킬 수 있습니다. 그러니 복잡성을 버리고 엔터프라이즈 수준의 폼 빌딩 여정을 위해 이 강력한 세트를 환영해 보세요!\n\n유용하게 여겨진다면 박수 버튼을 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png"},"coverImage":"/assets/img/2024-05-01-SuperchargeyourReactFormswithReactHookFormZodandMUIAPowerfulTrio_0.png","tag":["Tech"],"readingTime":9}],"page":"149","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":11,"currentPageGroup":7},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"149"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>