<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/60" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/60" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="풀리 시스템 모델링 방법" href="/post/2024-05-27-HowtoModelPulleySystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="풀리 시스템 모델링 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-HowtoModelPulleySystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="풀리 시스템 모델링 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">풀리 시스템 모델링 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="YOLOv10 Custom Object Detection" href="/post/2024-05-27-YOLOv10CustomObjectDetection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="YOLOv10 Custom Object Detection" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-YOLOv10CustomObjectDetection_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="YOLOv10 Custom Object Detection" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">YOLOv10 Custom Object Detection</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs 19가 출시, 새로운 기능 및 내용 정리" href="/post/2024-05-27-Nodejs19isOutHerearetheNewUpdates"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs 19가 출시, 새로운 기능 및 내용 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Nodejs19isOutHerearetheNewUpdates_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs 19가 출시, 새로운 기능 및 내용 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs 19가 출시, 새로운 기능 및 내용 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 활용한 마이크로서비스 만드는 방법" href="/post/2024-05-27-LeveragingMicroserviceswithNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 활용한 마이크로서비스 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 활용한 마이크로서비스 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 활용한 마이크로서비스 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 레벨의 개발자를 위한 필수 Nodejs 가이드" href="/post/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 레벨의 개발자를 위한 필수 Nodejs 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 레벨의 개발자를 위한 필수 Nodejs 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모든 레벨의 개발자를 위한 필수 Nodejs 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Routing으로 나만의 파일 경로 기반 라우터 만들기" href="/post/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Routing으로 나만의 파일 경로 기반 라우터 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Routing으로 나만의 파일 경로 기반 라우터 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Routing으로 나만의 파일 경로 기반 라우터 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" href="/post/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" href="/post/2024-05-27-NestJSTheGoodTheBadandTheUgly"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" href="/post/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 개발자가 반드시 알아야 하는 10가지 도구" href="/post/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 개발자가 반드시 알아야 하는 10가지 도구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 개발자가 반드시 알아야 하는 10가지 도구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 개발자가 반드시 알아야 하는 10가지 도구</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link posts_-active__YVJEi" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"풀리 시스템 모델링 방법","description":"","date":"2024-05-27 18:33","slug":"2024-05-27-HowtoModelPulleySystems","content":"\n\n\n![Pulley System](/assets/img/2024-05-27-HowtoModelPulleySystems_0.png)\n\n풀리 시스템은 비탄성 케이블이나 줄을 통해 연결된 물체들의 시스템으로, 일반적으로 고정된 축 위의 바퀴인 부드러운 풀리를 통해 통과됩니다. 일상생활에서 가장 흔히 발견되는 풀리 시스템은 강철 케이블로 연결된 두 묵직한 물체로 구성됩니다. 케이블이 시스템 상단의 부드러운 풀리를 통과하고 물체들은 풀리 양쪽에서 수직으로 올라가거나 내려갑니다.\n\n풀리의 한 쪽에 엘리베이터가 있고 다른 쪽에 카운터웨이트가 있는 엘리베이터 시스템이 일반적인 예입니다. 또 다른 일반적이고 비슷한 예로는 인간이 카운터웨이트에 맞서 풀리를 통해 케이블을 당기는 웨이트 머신이 있습니다.\n\n풀리 시스템 문제는 고등학교에서 흔히 배우는 수학 도구를 사용하여 해결하는 데 재미있고 깔끔할 수 있습니다. 최근에 매우 만족스러운 해결책이 있는 이 형태의 문제를 발견했습니다. 이 문제를 해결하기 위해서는 뉴턴의 법칙, 운동의 기본 방정식, 그리고 에너지와 운동량에 대한 기본 지식이 필요합니다. 또한 문제를 수학으로 모델링하기 위해 체계적으로 생각할 수 있어야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제를 설명하겠습니다.\n\nA 파일드라이버는 가벼운 무게 m의 경량 카운터웨이트에 의해 무거운 질량 M의 무게로 구성되어 있으며 매끄럽고 가벼운 고정 풀리를 통해 전달되는 불편한 조건자 그리고 카운터웨이트가 연결된 무거운 질량 M으로 이루어져 있습니다. 편은 파일 아래에 위치합니다. 파일 드라이버는 파일 위에 위치한 상태에서 정지된 상태에서 시작되며, 그 이후의 충돌은 파일드라이버와 파일 간에만 발생하며 이러한 충돌은 완전히 탄력적입니다. 파일드라이버가 정지 상태에 이르기까지 걸리는 시간이 처음으로 파일을 제동시키기까지 걸리는 시간의 세 배임을 보여줍니다.\n\n## 문제 이해\n\n역학 문제의 경우 다이어그램이 많은 도움이 됩니다. 이것이 파일 위에 위치한 초기 상황의 다이어그램입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![How to Model Pulley Systems Part 1](/assets/img/2024-05-27-HowtoModelPulleySystems_1.png)\n\n이 시스템은 정지 상태에서 출발되며, 우리는 편막기가 말뚝을 타격할 것으로 예상할 수 있습니다. 이 충돌이 완전히 탄성 없다고 합니다. 이는 모든 운동 에너지가 손실되고 편막기가 말뚝에서 튕겨 나오지 않고 충돌 후 그 자리에서 그대로 남게 될 것을 의미합니다.\n\n그러나 카운터웨이트는 충돌 후에도 계속해서 상승할 것이며, 그 결과 줄은 느슨해질 것입니다. 이것은 중력이 카운터웨이트를 멈출 때까지 계속될 것이며, 그리고 다시 하강하기 시작합니다. 이 상황의 다이어그램은 다음과 같습니다:\n\n![How to Model Pulley Systems Part 2](/assets/img/2024-05-27-HowtoModelPulleySystems_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어느 순간, 줄이 다시 팽창되어 긴장이 생기면서 편입기가 중력에 의해 느려지고 제로가 될 때까지 위로 올라갈 것입니다. 그런 다음, 파일과 충돌할 때까지 떨어지며, 이 과정은 시스템이 영구적으로 정지할 때까지 반복됩니다.\n\n## 첫 번째 충돌 전에 움직임 이해하기\n\n시스템이 해제되면 힘이 작용하고, 가속될 것으로 예상할 수 있습니다. 아래쪽 힘을 양수, 위쪽 힘을 음수로 간주합시다. 풀리의 각 측면에서 힘을 분해하고 뉴턴의 제2법칙을 사용하여 동시 방정식을 구할 수 있습니다 (중력 가속도를 나타내는 데 g를 사용):\n\n![image](/assets/img/2024-05-27-HowtoModelPulleySystems_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 방정식을 재배열하고 첫 번째 방정식에 대입하면, 시스템의 가속도에 대한 식을 유도할 수 있습니다. 다음과 같이:\n\n![이미지](/assets/img/2024-05-27-HowtoModelPulleySystems_4.png)\n\n이제 이 질문에 대한 진전을 이루기 위해, 첫 충돌이 발생하는데 걸리는 시간에 대한 식을 구해야 합니다. 이를 위해 이동 방정식을 사용할 수 있습니다. 우리는 가속도를 알고 있고, 초기 속도 u = 0임을 알고 있습니다. 충돌 지점에서의 속도를 v로 부르겠습니다. 첫 번째 충돌이 발생하는 데 걸리는 시간을 찾기 위해 v = u + at와 같은 방정식을 사용해 봅시다:\n\n![이미지](/assets/img/2024-05-27-HowtoModelPulleySystems_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 첫 번째와 두 번째 충돌 사이의 움직임 연구\n\n알다시피, 첫 충돌 직후 집게는 정지 상태를 유지하지만, 카운터웨이트는 중력에 반항하여 계속 상승하다가 중력이 그것을 느리게 하여 멈추고 다시 하강하기 시작합니다.\n\n이제 충돌 시점에서 집게의 속도를 v로 가정하겠습니다. 따라서 충돌 시점에서 카운터웨이트도 속력 v로 상승 중입니다. 충돌 이후에도 카운터웨이트는 이 초기 속도로 계속 상승하며, 줄은 늘어나게 되고, 중력이 카운터웨이트를 느리게 하여 멈추게 한 후 다시 하강하기 시작합니다. 줄이 다시 팽팽해지는 시점에, 다시 속도 v에 도달하게 됩니다. 이전과 같은 운동 방정식을 사용하고, 초기 속도가 v이고 최종 속도가 0이며 가속도가 -g임을 고려하면, 카운터웨이트가 멈추기까지 걸리는 시간이 v/g임을 쉽게 찾을 수 있고, 줄이 다시 팽팽해지기까지 걸리는 시간은 2v/g임을 알 수 있습니다.\n\n이제 줄이 다시 팽팽해지는 시점에서, 장력은 집게와 카운터웨이트가 새로운 속도로 함께 움직이도록 유발할 것입니다. 우리는 전단량 보존 법칙을 사용하여 우리가 v₁이라고 부를 새로운 속도를 계산할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-27-HowtoModelPulleySystems_6](/assets/img/2024-05-27-HowtoModelPulleySystems_6.png)\n\n이제 이 시스템이 중력으로 인해 느려지고, 더블카드가 두 번째로 펠을 충돌할 때 속도 v₁로 다시 돌아올 것을 알았습니다. 우리는 이전에 계산한 것과 같은 방법을 사용하여 더블카드가 멈출 때까지 걸리는 시간을 계산합니다. 초기 속도는 v₁, 최종 속도는 0이며, 가속도는 전체 시스템의 가속도입니다. 따라서 다음과 같습니다:\n\n![2024-05-27-HowtoModelPulleySystems_7](/assets/img/2024-05-27-HowtoModelPulleySystems_7.png)\n\n첫 번째와 두 번째 충돌 사이의 총 시간 T₁을 얻으려면 이 값을 두 배하여 역추적하는 시간을 더해야 합니다:\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-HowtoModelPulleySystems_8.png)\n\n## 연속적인 충돌 사이의 움직임 공부\n\n우리의 논리를 반복하면, 만약 v₁가 두 번째 충돌 직전 시스템의 속도라면, 반추중량은 2v₁/g 시간에 탄력줄 위치로 돌아올 것입니다. 이 시점에서 우리는 시스템의 새로운 속도 v₂가 다음과 같은 조건을 만족한다고 말할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-HowtoModelPulleySystems_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 방법을 사용하여 결합된 시스템이 제로로 느려지는 데 걸리는 시간을 계산할 수도 있습니다. 이 계산 결과는 다음과 같습니다:\n\n![image](/assets/img/2024-05-27-HowtoModelPulleySystems_10.png)\n\n그리고 같은 과정을 따라 두 번째 충돌과 세 번째 충돌 사이의 시간 T₂를 결정할 수 있습니다:\n\n![image](/assets/img/2024-05-27-HowtoModelPulleySystems_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 이제 충돌 사이의 소요 시간이 등비 수열인 것을 쉽게 알 수 있습니다. 즉:\n\n![image](/assets/img/2024-05-27-HowtoModelPulleySystems_12.png)\n\n## 마지막 단계\n\n충돌 사이의 시간 순열이 공비율 m/(M+m) 과 첫 항 T₁을 가진 등비 수열임을 알았으며, 공비율이 명백히 1보다 작음을 고려하면, 모든 충돌의 시작부터 끝까지의 총 시간이 극한값으로 수렴함을 말할 수 있고, 등비 급수의 합 T = T₁ + T₂ + … 를 다음과 같이 계산할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-27-HowtoModelPulleySystems_13.png)\n\n그냥 언급할 사항만 남았네요. 이는 망치가 처음으로 말끔히 칠 때까지 걸리는 시간의 두 배입니다(이전에 계산한 것). 따라서 시스템이 정지할 때까지 걸리는 총 시간은 망치가 처음으로 말끔히 칠 때까지 걸리는 시간의 세 배입니다.\n\n이 문제에 대해 어떻게 생각하셨나요? 다르게 접근할 방법이 있나요? 자유롭게 의견을 남겨주세요!","ogImage":{"url":"/assets/img/2024-05-27-HowtoModelPulleySystems_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoModelPulleySystems_0.png","tag":["Tech"],"readingTime":5},{"title":"YOLOv10 Custom Object Detection","description":"","date":"2024-05-27 18:31","slug":"2024-05-27-YOLOv10CustomObjectDetection","content":"\n\nYOLOv10 및 사용자 지정 데이터로 모델 학습 개요\n\n![YOLOv10CustomObjectDetection_0.png](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_0.png)\n\n## 개요\n\nUltralytics Python 패키지를 사용하여 개발된 YOLOv10은 실시간 객체 검출을 위한 새로운 접근 방식을 제공합니다. Qinghua 대학 연구원들이 개발한 이 모델은 모델 아키텍처 개선과 non-maximum suppression (NMS) 제거를 통해 성능을 향상시켰습니다. 이러한 최적화로 인해 더 낮은 계산 요구사항으로 최신 기술 성능을 제공합니다. YOLOv10은 다양한 모델 규모에 대해 우수한 정확도-대기간 교환을 제공하는 것으로 실험 결과 보여졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 이전 기사를 읽은 사람들은 알겠지만, YOLO 모델을 사용한 다양한 프로젝트를 공유해 왔습니다. 사전 학습된 모델 중에서 성능과 효율성 면에서 두드러지는 YOLO 모델입니다. 그러나 실시간 객체 감지는 비최대 억제 (NMS)와 구조적 비효율성에 의해 도전을 겪어왔습니다. YOLOv10은 이러한 문제를 해결하기 위해 NMS를 제거하고 효율성과 정확도 양쪽을 모두 고려한 설계 전략을 채택했습니다.\n\n## 구조\n\n![YOLOv10CustomObjectDetection_1](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_1.png)\n\n- 백본: 특징 추출을 담당하는 백본은 CSPNet (Cross Stage Partial Network)의 향상된 버전을 사용하여 기울기 흐름을 개선하고 계산 중복성을 줄였습니다.\n- 넥: 다양한 스케일의 특징을 집계하고 헤드로 전달하는 넥은 효과적인 다중 스케일 특징 퓨전을 위해 PAN (Path Aggregation Network) 레이어를 포함하고 있습니다.\n- One-to-Many 헤드: 훈련 중 하나의 객체에 대해 여러 예측을 생성하여 풍부한 지도 신호를 제공하고 학습 정확도를 향상시킵니다.\n- One-to-One 헤드: 추론 중 하나의 객체에 대해 최상의 예측을 생성하여 NMS의 필요성을 제거하고 지연 시간을 줄이며 효율성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모델 변형과 성능\n\nYOLOv10은 여섯 가지 모델로 제공됩니다:\n\n- YOLOv10-N: 매우 자원이 제한된 환경을 위한 나노 버전.\n- YOLOv10-S: 속도와 정확도를 균형있게 유지한 작은 버전.\n- YOLOv10-M: 일반적인 용도를 위한 중간 버전.\n- YOLOv10-B: 정확도를 높이기 위해 넓이를 증가시킨 균형잡힌 버전.\n- YOLOv10-L: 컴퓨팅 자원을 늘리는 대가로 더 높은 정확도를 가진 대형 버전.\n- YOLOv10-X: 최대 정확도와 성능을 위한 초대형 버전\n\n![이미지](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비교\n\n서로 다른 모델 간의 지연 시간과 정확도에 대한 비교를 살펴봅시다. 이는 COCO와 같은 표준 벤치마크에서 테스트되었습니다.\n\n![Image 1](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_3.png)\n\n![Image 2](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYOLOv10은 실시간 객체 검출 애플리케이션에 대한 첨단 기술로, 더 적은 매개변수로 더 높은 정확도와 속도 성능을 제공합니다.\n\n## 사용자 정의 객체 검출을 위한 YOLOv10 훈련\n\n먼저, 공식 YOLOv10 GitHub 저장소를 복제하여 필요한 yolov10n 모델을 다운로드하세요.\n\n```js\n!pip install -q git+https://github.com/THU-MIG/yolov10.git\n\n!wget -P -q https://github.com/jameslahm/yolov10/releases/download/v1.0/yolov10n.pt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로보플로 유니버스에서 원하는 사용자 정의 프로젝트를 실험하고, 직접 데이터셋을 생성하며, 인텔이 후원하는 RF100 데이터셋을 사용할 수 있어요. 이 게시물에서는 X-레이 이미지에서 위험한 항목을 감지하기 위해 준비된 데이터셋을 사용할 거에요.\n\n로보플로 API를 사용하여 YOLOv8 형식으로 모델을 다운로드하세요.\n\n```python\n!pip install -q roboflow\nfrom roboflow import Roboflow\nrf = Roboflow(api_key=\"your-api-key\")\nproject = rf.workspace(\"vladutc\").project(\"x-ray-baggage\")\nversion = project.version(3)\ndataset = version.download(\"yolov8\")\n```\n\n매개변수와 파일 경로를 지정한 다음, 모델 훈련을 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n!yolo task=detect mode=train epochs=25 batch=32 plots=True \\\nmodel='/content/-q/yolov10n.pt' \\\ndata='/content/X-Ray-Baggage-3/data.yaml'\n\n\n예시 data.yaml 파일\n\n\nnames:\n- Gun\n- Knife\n- Pliers\n- Scissors\n- Wrench\n\nnc: 5\n\nroboflow:\n  license: CC BY 4.0\n  project: x-ray-baggage\n  url: https://universe.roboflow.com/vladutc/x-ray-baggage/dataset/3\n  version: 3\n  workspace: vladutc\n\ntest: /content/X-Ray-Baggage-3/test/images\ntrain: /content/X-Ray-Baggage-3/train/images\nval: /content/X-Ray-Baggage-3/valid/images\n\n\n결과를 살펴봅시다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmd\n![Training results](/content/runs/detect/train/results.png){width=1000}\n\n![Prediction results](/assets/img/2024-05-27-YOLOv10CustomObjectDetection_5.png)\n\n테스트 데이터를 예측하고 결과를 5x2 그리드로 표시합니다.\n\n```python\nfrom ultralytics import YOLOv10\n\nmodel_path = '/content/runs/detect/train/weights/best.pt'\nmodel = YOLOv10(model_path)\nresults = model(source='/content/X-Ray-Baggage-3/test/images', conf=0.25, save=True)\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport glob\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nimages = glob.glob('/content/runs/detect/predict/*.jpg')\n\nimages_to_display = images[:10]\n\nfig, axes = plt.subplots(2, 5, figsize=(20, 10))\n\nfor i, ax in enumerate(axes.flat):\n    if i \u003c len(images_to_display):\n        img = mpimg.imread(images_to_display[i])\n        ax.imshow(img)\n        ax.axis('off')  \n    else:\n        ax.axis('off')  \n\nplt.tight_layout()\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-YOLOv10CustomObjectDetection_6.png\" /\u003e\n\n## 결론 및 권장 사항\n\n- 이 글을 작성하는 동안 여러 데이터셋에서 YOLOv10n 모델을 학습하여 Colab의 15GB 무료 T4 GPU 한도를 고갈시켰습니다. Colab 환경에서 모델을 학습할 때 한도를 초과하면 T4 GPU에 제한이 있습니다. 이 문제를 해결하기 위해 다른 구글 계정으로 로그인할 수 있습니다.\n- 기술이 빠르게 발전함에 따라 컴퓨터 비전과 대형 언어 모델 양쪽에서 단일 기술에 갇히지 않고 주요 개념을 배우는 것이 유익하다고 생각됩니다. 이를 적응하기 위해 이러한 기술의 개발자들로부터 배우는 것이 도움이 됩니다. Ultralytics와 Roboflow의 콘텐츠는 이 분야에서 매우 가치 있으며, 그들을 팔로우하는 것이 바람직합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- 공식 레포: https://github.com/THU-MIG/yolov10\n- 울트라리틱스 (Ultralytics)\n- 로보플로우 (Roboflow)\n\n```js\n@article{THU-MIGyolov10,\n  title={YOLOv10: 실시간 엔드 투 엔드 객체 검출},\n  author={Ao Wang, Hui Chen, Lihao Liu 등},\n  journal={arXiv 사전 인쇄 arXiv:2405.14458},\n  year={2024},\n  institution={Tsinghua University},\n  license={AGPL-3.0}\n}\n```\n\n```js\n@misc{\nx-ray-baggage_dataset,\ntitle={X-레이 수하물 데이터셋},\ntype={오픈 소스 데이터셋},\nauthor={vladutc},\nhowpublished={\\url{ https://universe.roboflow.com/vladutc/x-ray-baggage }},\nurl={https://universe.roboflow.com/vladutc/x-ray-baggage},\njournal={Roboflow Universe},\npublisher={Roboflow},\nyear={2024},\nmonth={5},\nnote={방문일: 2024년 5월 26일},\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 청화 대학교의 연구원들, Ultralytics와 Roboflow 팀, 그리고 오픈 소스 커뮤니티의 모든 기여자들에게 감사드립니다.","ogImage":{"url":"/assets/img/2024-05-27-YOLOv10CustomObjectDetection_0.png"},"coverImage":"/assets/img/2024-05-27-YOLOv10CustomObjectDetection_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs 19가 출시, 새로운 기능 및 내용 정리","description":"","date":"2024-05-27 18:29","slug":"2024-05-27-Nodejs19isOutHerearetheNewUpdates","content":"\n\n## 노드 v19의 새로운 기능을 강조한 릴리스 노트의 친숙한 버전\n\n![Node v19](/assets/img/2024-05-27-Nodejs19isOutHerearetheNewUpdates_0.png)\n\n보통 런타임의 새 버전을 위한 릴리스 노트가 나오면, 사용자들로서는 꽤 내부적이고 투명한 부분들에 대한 업데이트가 많이 포함되어 있습니다.\n\n그러나 Node.js 19의 릴리스 노트에서는 세부적으로 살펴보지 않는다면 발표 공지에서 놓칠 수 있는 흥미로운 정보가 몇 가지 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 이제 우리가 가장 기대되는 것들을 살펴보겠습니다. 우리가 좋아하는 JavaScript 런타임의 버전 19에서 발표된 변경 사항 중에서 어떤 것들이 있는지요?\n\n# 이제 WATCH 플래그가 있습니다\n\n비록 실험적인 모드에 있지만, 적어도 워치 플래그의 초석이 있다고 말할 수 있습니다. 이것이 의미하는 바가 무엇인가요? Node가 Deno 팀에서 몇 가지 아이디어를 천천히 받아들이고 있는 것일까요?\n\nDeno가 CLI를 설계할 때 Node와 다른 접근 방식을 취했습니다. 그들의 사용자들에게 스크립트를 실행하는 간소화된 방법을 제공하는 대신에, Deno 팀은 모든 필요한 것을 단일 실행 파일로 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 파일 감시자, 테스트 러너, 코드 포멧터 등을 의미합니다. 지난 10년간 노드가 수행해온 것과는 확실히 다른 접근 방식이지만 작동하는 것으로 보입니다. Deno 개발자들과 대화를 나눈 후, 이 도구들이 한 곳에서 제공된다는 매력을 느낄 수 있었습니다.\n\n그러니까, 이것이 자체 CLI 도구로 커뮤니티에 의해 개발된 다양한 도구들을 통합하는 과정에서 한 발자국 중 하나라고 안전하게 말할 수 있을까요?\n\n확실한 것은 말할 수 없습니다. 비슷한 접근 방식을 살펴볼 수 있지만, 한 번에 한 번 일어날 수도 있습니다.\n\n특히 이 플래그는 흥미롭습니다. 기본적으로 진입점 파일과 필요한 또는 가져온 종속성을 모두 감시합니다. 특정 폴더에서 변경 사항을 감시하려면(구성 파일 변경 사항을 감시하는 것과 유사한지 상정합니다), 실험 단계에 있는 watch-path 플래그를 명시해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 \"감시 모드\"에서 변경이 감지되면 Node.js 프로세스가 다시 시작될 뿐, 할 일이 많지 않아요.\n\n제가 잘못 이해시킨게 아니에요. 이미 많은 일을 하는 것이긴 하지만, 이벤트에 연결하여 추가적인 흥미로운 작업을 수행할 수 있다면 더 좋을 것 같아요.\n\n그래도 아쉽네요. 아마 다음 버전에는 가능할지도 몰라요!\n\n# 사용자 정의 ESM 해상도 조정 (이것을 빠트리지 마세요!)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 제목을 보고 나는 처음에 그냥 내부 플래그가 제거된 것 같다고 생각해서 건너뛰었어요. 정말 별로 관심이 없었거든요.\n\n그러다가 몇 가지 링크를 따라가서 이 변화가 어떤 것인지 읽어봤어요.\n\n사실 이름이 Node.js 핵심 개발자가 아니라면 약간 암호적일 수도 있지만, 기능은 그렇지 않아요. Node에서 파일을 이렇게 require 해본 적이 몇 번이나 있었나요?\n\n```javascript\nconst myPkg = require(\"./folder/file\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n폴더에 확장자가 없다는 점에 주목하세요. 노드는 포기하기 전에 여러 가지 대안을 찾기 때문에 확장자를 생략한 것입니다.\n\n또는 이렇게 폴더를 직접 참조할 수도 있어요:\n\n```javascript\nconst myPkg = require(\"./my-folder\")\n```\n\n이 폴더 안에 index.js 파일이 있다면 동작할 거예요. 노드가 자동으로 해당 파일을 찾아줄 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 동일한 패키지를 가져오려고 시도하면 그렇지 않습니다. 노드의 \"ESM specifier resolution\"은 해당 추가 동작을 지원하지 않습니다. 올바른 확장명을 직접 지정하지 않는다면 파일을 찾을 수 없습니다.\n\n--experimental-specifier-resolution=node 플래그를 사용하여 CommonJS 동작을 모방할 수 있습니다. 하지만 그렇다고 해도 이것은 \"실험적\"인 단어가 들어간 긴 지저분한 플래그입니다. 사용자들에게 이것이 실행해도 안전하다고 설득하는 데 행운을 빕니다!\n\n다행히도 이제 Node.js 19에서는 이 문제가 더 이상 발생하지 않습니다. 새로운 로더로 이와 같은 작업을 수행할 수 있습니다:\n\n\nimport file from `./file` // \"file\"에 올바른 확장명이 있으면 동작합니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아니요\n\nimport myFile from `./폴더` //만약 \"폴더\" 안에 \"index.js\"가 있다면\n\n보셨나요? 이 업데이트의 이름 때문에 다른 걸로 생각할 수도 있겠지만, 실제로는 매우 좋고 환영받는 개선 사항이죠.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 2 10년 간의 지혜를 모두와 공유하는 무료 뉴스레터를 구독해 보세요. “늙은 개발자의 혼잣말”에 가입해 보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 우리는 V8의 새 버전을 사용 중입니다\n\n우리는 10.2 버전에서 10.7 버전으로 넘어갔어요\n\n누가 관심 있겠어요?\n\n하지만 당신도 모를까봐요! 이번에 이루어진 이 업데이트는 Node.js가 런타임의 최신 릴리스를 사용하도록 유지시키고 우리가 뒤쳐지지 않게 하는 것 외에도, 특정 버전이 ECMAScript의 Stage 3 제안으로부터 새로운 업데이트를 소개하게 됐다는 사실이요: Intl.numberFormat API의 업데이트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언어의 새로운 기능을 사용해볼 때 항상 흥분되는데요, 특히 프로젝트에서 숫자를 다루는 경우에는 이 기능이 매우 흥미로울 거에요.\n\n기존 메소드들의 정밀도가 향상되고 새로운 형식 옵션이 추가되는 등 여러 가지 면에서 이 기능은 매우 흥미로운 것들을 제공해줍니다. 아직은 공식적인 3단계 단계에 있지만, 이 제안은 이미 Node의 최신 버전을 이용하여 시도하고 테스트할 수 있으니 한 번 시도해보세요!\n\n# DTrace/SystemTap/ETW 지원이 사라지고 있어요\n\n알지 못하셨다면, DTrace, SystemTap 및 ETW는 각각 다른 OS에서 작동하는 프로파일링 도구이며, Node.js 팀 내부에서 런타임이 모두와 호환되도록 유지되고 작동할 수 있도록 노력했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 외부 도구를 사용하여 프로필을 만들고 Node.js 기반 코드가 다른 상황에서 어떻게 실행되는지 이해할 수 있게 되었습니다.\n\n하지만 발표에 따르면, 이러한 도구를 유지하고 업데이트하는 노력은 노드 사용자들에게 가져다 주는 이익 대비 너무 컸던 것 같아요.\n\n그래서 이 도구들은 더 이상 지원되지 않게 되었습니다.\n\n과거에 이를 활용하셨나요? 이제는 어떻게 할 건가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 업데이트도 공지를 확인하면 찾을 수 있어요, 그런데 솔직히 이것들이 제 눈길을 사로잡았어요. 특히 조금 더 파헤쳐봐야 이해할 수 있는 부분들이요.\n\nNode.js 19의 변경 사항에 대해 기대되시나요? 어떻게 당신에게 영향을 미치는지 댓글로 남겨주세요! 다른 분들이 Node를 어떻게 사용하는지 읽어보는 건 항상 기쁘답니다!\n\n# 레고처럼 재사용 가능한 컴포넌트로 앱을 제작하세요\n\n![Node.js 19 업데이트 이미지](/assets/img/2024-05-27-Nodejs19isOutHerearetheNewUpdates_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBit의 오픈 소스 도구는 25만 명 이상의 개발자들이 구성 요소를 활용하여 앱을 구축할 수 있도록 도와줍니다.\n\n모든 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하고 애플리케이션 전체에 공유할 수 있습니다. 협업하고 더 빠르게 개발하는 것이 더 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누릴 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포(repository)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-05-27-Nodejs19isOutHerearetheNewUpdates_0.png"},"coverImage":"/assets/img/2024-05-27-Nodejs19isOutHerearetheNewUpdates_0.png","tag":["Tech"],"readingTime":5},{"title":"Nodejs를 활용한 마이크로서비스 만드는 방법","description":"","date":"2024-05-27 18:27","slug":"2024-05-27-LeveragingMicroserviceswithNodejs","content":"\n\n## 궁극적인 확장성과 민첩성의 해제\n\n마이크로서비스는 거대한 앱을 독립적인 서비스로 분할합니다. Node.js와 함께 사용하면 다음과 같은 이점을 얻을 수 있습니다:\n\n- 개별 서비스의 확장\n- 각 서비스에 최적의 기술 스택 사용\n- 내구성을 위해 장애 격리\n- 병렬 개발을 통한 빠른 전달\n- 쉬운 유지보수 및 업그레이드\n\n## 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이른바 빠르게 변화하는 디지털 세상에서는 기업들이 시장 상황에 신속히 대응하고 대규모 트래픽 증가를 처리하며 새로운 기능을 매끄럽게 통합할 수 있는 애플리케이션을 요구합니다. 마이크로서비스는 개발자들이 이러한 유연하고 확장 가능한 시스템을 구축할 수 있도록 함께 부상한 혁명적인 아키텍처 패러다임입니다. Node.js의 효율성과 성능과 결합되면, 마이크로서비스는 새로운 수준의 잠재력을 발휘합니다. 이 블로그 포스트는 마이크로서비스의 기본 원칙, 혁신적인 이점 및 Node.js에서의 구현을 위한 모베스트 프랙티스를 안내해 드릴 것입니다.\n\n## 마이크로서비스란?\n\n전통적인 단일체 응용 프로그램을 거대하고 연결된 구조로 상상해보십시오. 여기에서 각 구성 요소는 꽉 결합되어 있고 서로 의존적입니다. 애플리케이션의 일부를 변경하거나 특정 부분을 확장하는 것은 어려운 일이 됩니다. 심지어 미세한 조정이라도 전체 시스템 전반에 파급 효과를 일으킬 수 있습니다. 마이크로서비스는 애플리케이션을 더 작고 독립적인 서비스로 분해하여 각각이 특정 비즈니스 기능을 담당하는 혁신적인 방식을 제시합니다.\n\n모든 고객을 위해 특정 중앙 주방에서 서비스되는 거대한 레스토랑을 상상해보십시오. 마이크로서비스 아키텍처에서는 레스토랑이 각각이 특정 요리나 음식에 전념한 여러 전문화된 주방을 가지고 있습니다. 이탈리아 주방은 모든 파스타와 피자 주문을 처리하고, 스시 주방은 신선한 초밥 롤을 준비하는 데만 전념합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png)\n\n이 모듈식 접근 방식은 효율적인 자원 할당, 빠른 서비스 및 쉬운 유지 보수를 가능하게 합니다. 각 주방이 독립적으로 작동하고 수요에 따라 확장할 수 있기 때문입니다.\n\n## 마이크로서비스의 변화를 가져다주는 혜택들\n\n- 비교할 수 없는 확장성: 마이크로서비스를 사용하면 수요에 따라 개별 서비스를 독립적으로 확장할 수 있습니다. 하나의 서비스에 트래픽이 급증하는 경우, 해당 서비스에 더 많은 자원을 할당할 수 있습니다. 예를 들어 전자 상거래 애플리케이션에서 대규모 할인 행사 중 주문 처리 서비스가 많은 주문을 받을 수 있습니다. 마이크로서비스를 사용하면 개별 서비스를 효율적으로 확장하여 늘어난 부하를 처리할 수 있으며, 원활한 운영과 최적의 성능을 보장하면서 비용을 절감할 수 있습니다.\n- 유연성과 기술 다양성: 각 서비스는 가장 적합한 기술 스택을 사용하여 개발할 수 있으므로 다른 언어, 프레임워크 및 데이터베이스의 장점을 활용할 수 있습니다. 예를 들어 고성능 API 서비스에 Node.js를 사용하고, 기계 학습 서비스에 Python을 사용하고, 유연한 데이터 저장소가 필요한 서비스에는 NoSQL 데이터베이스를 사용할 수 있습니다. 적절한 도구를 선택할 수 있는 이 자유는 개발자가 고품질 맞춤형 솔루션을 제공할 수 있도록 도와줍니다.\n- 개선된 오류 격리 및 복원력: 단일 지점의 장애가 전체 시스템을 다운시킬 수 있는 모놀리식 애플리케이션과 달리, 마이크로서비스를 사용하면 서비스 하나가 실패해도 전체 애플리케이션에 미치지 않습니다. 이 격리는 전체 시스템의 건강과 복원력을 유지하는 데 도움이 됩니다. 예를 들어 결제 처리 서비스에 문제가 발생하는 상황을 상상해보세요. 마이크로서비스를 사용하면 고객은 여전히 제품 카탈로그를 찾아보고 주문을 할 수 있으며, 결제 서비스는 별도로 처리됩니다.\n- 빠른 시장 진입: 마이크로서비스를 통해 팀이 각기 다른 서비스에 동시에 작업할 수 있어 개발 주기를 단축하고 빠른 릴리스를 가능하게 합니다. 예를 들어 한 팀은 케이터링 서비스에 대한 새로운 기능을 개발하고, 다른 팀은 제품 카탈로그 서비스를 개선함으로써 병렬 개발이 가능하며, 새로운 기능을 최종 사용자에게 빠르게 제공할 수 있습니다.\n- 쉬운 유지 보수 및 업그레이드: 작고 모듈식 코드베이스를 사용하면 개별 서비스의 유지 보수 및 업그레이드가 훨씬 쉬워집니다. 프레임워크나 언어의 새 버전으로 서비스를 리팩토링하거나 이주할 수 있으며 전체 애플리케이션을 방해하지 않고 진행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Node.js에서 마이크로서비스 구현하기\n\n마이크로서비스는 많은 장점을 제공하지만 효과적으로 구현하려면 신중한 고려와 모베스트 프랙티스 준수가 필요합니다. Node.js는 이벤트 기반, 논블로킹 I/O 모델과 가벼우며 효율적인 런타임으로, 마이크로서비스 구축에 탁월한 선택입니다. Node.js에서 마이크로서비스를 구현할 때 주의할 점 몇 가지를 살펴보겠습니다:\n\n- 서비스 디자인: 비즈니스 기능을 중심으로 서비스를 디자인하여 각 서비스가 단일 책임과 명확한 인터페이스를 갖도록 합니다. 이 관심사 분리 원칙은 모듈성, 테스트 가능성 및 유지보수성을 촉진합니다.\n- 통신: 마이크로서비스는 네트워크를 통해 서로 통신하며, 종종 HTTP/REST와 같은 가벼운 통신 프로토콜을 사용합니다. 비동기 통신 시나리오의 경우 RabbitMQ, Apache Kafka 또는 BullMq와 같은 메시지 브로커를 사용하여 서비스를 분리하고 이벤트 기반 아키텍처를 처리하는 것을 고려해보세요.\n- 배포: Docker와 같은 컨테이너화 기술은 마이크로서비스를 배포하는 데 필수적입니다. Docker 컨테이너는 각 서비스와 해당 종속성을 자체 포함된 단위로 패키징하여 서로 다른 환경에서 서비스를 배포하고 관리하기 쉽게 만듭니다.\n- 모니터링 및 로깅: 분산 시스템에서 여러 서비스가 실행되는 경우 전체 응용 프로그램의 건강 상태와 성능을 이해하기 위해 모니터링 및 로깅이 중요해집니다. Prometheus 및 Grafana 또는 Newrelic과 같은 모니터링 솔루션과 함께 Cloudwatch 로깅을 구현하여 생태계에 대한 더 많은 통찰력을 얻을 수 있습니다.\n- 보안: 서비스 수준에서 인증 및 권한 부여를 구현하여 서비스 간 안전한 통신을 보장합니다. npm 패키지를 사용하여 요청 제한, 요청 유효성 검사 및 액세스 제어와 같은 일반적인 보안 문제를 처리하세요.\n\n## 최상의 실천 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 탈중앙화된 데이터 관리: 각 마이크로서비스는 자체 데이터베이스를 관리해야 하며, 단일 장애 지점을 피하고 서비스가 완전히 독립적이 될 수 있도록 해야 합니다. 이 \"서비스 당 데이터베이스\" 패턴은 데이터 격리와 확장성을 촉진합니다.\n- 버전 관리: API 버전 관리를 구현하여 기존 클라이언트에 영향을 주지 않고 변화와 업데이트를 처리할 수 있습니다. 이를 통해 역호환성을 유지하고 새로운 기능을 도입하거나 서비스를 리팩토링할 때 원활한 전환을 가능하게 합니다.\n- 자동화된 테스트: 각 서비스에는 단위, 통합 및 종단간 테스트를 포함한 포괄적인 자동화된 테스트 스위트가 있어야 합니다. 이는 개발 주기 초기에 문제를 발견하고 개별 서비스 및 전체 시스템의 신뢰성과 품질을 보장하는 데 도움이 됩니다.\n- 지속적 통합/지속적 배포 (CI/CD): CI/CD 파이프라인을 도입하여 테스트, 빌드 및 배포 프로세스를 자동화하고 일관된 신뢰할 수 있는 릴리스를 보장해야 합니다. 젠킨스, AWS 파이프라인과 같은 도구를 활용하여 이러한 프로세스를 간소화하고 빠른 이터레이션을 가능하게 할 수 있습니다.\n\n## 결론\n\n마이크로서비스는 응용 프로그램을 구축하고 확장하는 방식을 혁신적으로 바꿨으며, 우수한 유연성, 확장성 및 견고성을 제공합니다. 이러한 아키텍처 접근 방식이 Node.js의 효율성과 성능과 결합될 때, 이는 혁신과 민첩성에 새로운 차원을 열어줍니다.\n\n기본 개념, 이점 및 모범 사례를 이해하면 마이크로서비스의 잠재력을 활용하여 비즈니스 성공을 이끄는 견고하고 확장 가능하며 유지보수 가능한 응용 프로그램을 제공하는 데 잘 준비될 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png"},"coverImage":"/assets/img/2024-05-27-LeveragingMicroserviceswithNodejs_0.png","tag":["Tech"],"readingTime":5},{"title":"모든 레벨의 개발자를 위한 필수 Nodejs 가이드","description":"","date":"2024-05-27 18:25","slug":"2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels","content":"\n\n![Node.js Guide](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png)\n\n안녕하세요, Node.js 팬 여러분! 당신이 전문 개발자이건, JavaScript 백엔드에 막 입문한 사람이건, 이 블로그는 실제 Node.js 앱을 만들기에 완벽한 장소입니다.\n\n우리는 애플리케이션 아키텍처 및 코딩을 위한 권장 사항을 살펴보고, 앱을 성능적이고 안전하게 만들기 위한 몇 가지 추가 제안도 제공할 것입니다.\n\nNode.js 게임을 한 단계 업시키기 위해 준비하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image1](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_1.png)\n\n[Gmail](mailto:your.email@gmail.com) | [LinkedIn](https://www.linkedin.com/in/yourprofile)\n\n## Why These Practices Matter\n\n![image2](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환영합니다!\n\nNode.js는 비동기 입출력(I/O)-바운드 작업(예: 데이터베이스 상호 작용 및 네트워크 요청과 유사)을 뛰어난 성능으로 수행합니다. 이는 논블로킹 I/O 모델과 이벤트 루프 덕분입니다.\n\n일반적인 멀티스레드 디자인과 대조적으로, Node.js는 병목 현상을 초래할 수 있는 여러 스레드 디자인과 달리 여러 요청을 동시에 처리하면서 성능이 떨어지지 않습니다.\n\n모듈화 디자인과 같은 특정 방법이 왜 Node.js에 유익한지 이해하는 것은 Node.js의 기능을 활용하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 애플리케이션 아키텍처 모범 사례\n\n![이미지](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_3.png)\n\n자, 이제 멋진 것을 만들어 봅시다! 다음은 염두에 둘 아키텍처적인 모범 사례입니다:\n\n## 모듈식 디자인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션을 작은, 재사용 가능한 구성 요소로 나눠보세요.\n\n이렇게 하면 코드가 더 이해하기 쉽고 유지보수 및 테스트가 용이해집니다.\n\n작은, 집중된 부분이 서로 교차하여 복잡한 구조물을 만들어내는 레고 블록을 사용해보세요.\n\n모듈은 레고와 유사합니다. 각 모듈은 단일 작업을 수행하고 잘 정의된 기능을 가져야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것을 통해 기능을 분리하고 응용 프로그램 전체에서 코드를 재사용할 수 있어요. 이렇게 함으로써 반복을 줄이고 유지 보수를 향상시킬 수 있어요.\n\n## 계층 구조\n\n프레젠테이션(앱의 인터페이스), 비즈니스 로직(핵심 기능) 및 데이터 액세스(데이터베이스와의 상호 작용)와 같은 계층을 사용하여 문제를 분리하세요.\n\n이렇게 하면 코드를 청소하고 복잡한 앱을 유지하기 쉽게 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주방(비즈니스 로직)과 식당(프레젠테이션)을 분리하면 일을 원할하게 처리할 수 있어요.\n\nMVC(Model-View-Controller)와 마이크로서비스 같은 인기 있는 패턴을 여기에 적용할 수 있어요.\n\nMVC는 애플리케이션을 모델(Model), 데이터를 나타내는 뷰(View), 데이터 표시 방식을 제어하는 컨트롤러(Controller) 세 개의 층으로 나눠요. 사용자 입력을 받고 모델과 뷰를 적절하게 조정하는 역할을 하는 거죠.\n\n마이크로서비스는 API를 사용하여 상호 통신하는 작은 독립적인 서비스로 애플리케이션을 나누는 개념이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 Markdown 형식으로 변경하겠습니다.\n\n## Dependency Injection\n\n이 방법은 크고 복잡한 응용 프로그램에 가장 적합하며 확장성을 촉진합니다.\n\n이 멋진 용어는 의존성(예: 데이터베이스 또는 외부 서비스)를 코드에 하드코딩하는 대신 추가하는 것을 의미합니다.\n\n이렇게 하면 테스트가 개선되고 느슨하게 연결된 코드를 유지하므로 개별 구성 요소의 쉬운 대체가 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성 주입을 사용하면 다른 데이터베이스로 쉽게 전환할 수 있어요.\n\nNode.js에서 의존성 주입을 구현하는 다양한 전략이 있지만, 일반적인 전략 중 하나는 의존성 주입 컨테이너를 사용하는 것입니다. 이 컨테이너는 의존성의 라이프사이클을 제어하고 필요할 때 코드에 주입합니다.\n\n## 이벤트 주도 아키텍처\n\n이벤트 이벤터와 메시지 큐를 사용하여 앱 내에서와 외부 서비스와의 비동기 통신을 제공하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그램의 각 구성 요소가 효율적으로 이벤트에 응답하고 서로 대기하지 않고 작동할 수 있도록 합니다.\n\n알림 시스템과 유사하게, 각 구성 요소는 이벤트에 가입하고 발생할 때 대응 조치를 취할 수 있습니다.\n\n이벤트 주도 아키텍처는 실시간 애플리케이션 개발 및 대규모 프로세스 관리에 매우 유용합니다.\n\n메시지 큐를 사용하여 시스템에 일시적으로 장애가 있더라도 이벤트가 일관되게 전달됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 수준의 최상의 실천 방법\n\n지금 우리가 견고한 아키텍처를 갖고 있으므로, 깨끗하고 효율적인 코드를 개발하는 데 중점을 둘 수 있습니다:\n\n## 깨끗한 코드와 가독성\n\n깨끗하고 간단하며 잘 서식이 지정된 코드를 목표로 해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n린터, 포매터 및 스타일 가이드를 사용하여 일관성을 보장하세요. 잘 쓰인 레시피는 읽고 따르기 쉽습니다.\n\n명확한 변수와 함수 이름이 있는 잘 서식이 맞춰진 코드는 미래에 그것을 작업해야 할 수도 있는 다른 개발자들과 여러분 모두가 이해하기 쉽게 만들어 줍니다.\n\n린터와 포매터는 코드 표준을 유지하면서 프로세스를 자동화하는 데 도움이 될 수 있습니다.\n\n## 비동기 프로그래밍\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPromises나 async/await을 사용하여 비동기 프로그래밍을 마스터하세요.\n\n이 작업을 통해 Node.js에서 I/O 작업을 이벤트 루프를 막지 않고 처리할 수 있습니다.\n\n이것을 공을 던지면서 생각해보세요: 여러 작업을 함께 완료할 수 있고 아무것도 떨어뜨리지 않을 수 있습니다! 비동기 작업에는 데이터베이스 호출, 네트워크 요청 및 파일 I/O가 포함됩니다.\n\nPromises와 async/await을 사용하면 이러한 작업의 비동기적인 성격을 처리하면서 코드를 깔끔하고 가독성 있게 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 오류 처리 및 로깅\n\n효과적인 오류 처리 구조 및 로깅 접근 방식을 구현하세요.\n\n이것은 애플리케이션 성능을 디버깅하고 모니터링하는 데 중요합니다.\n\n로그 및 오류 메시지는 앱의 문제를 경고하는 엔진 라이트 버전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n적절한 오류 처리는 부드럽게 오류를 잡아내고, 디버깅을 위한 필수 정보를 문서화하며 사용자에게 유용한 오류 메시지를 제공하는 것을 의미합니다.\n\n# 코드 예제: 최상의 관행을 실천으로\n\n우리는 많은 것을 다루었지만, 이제 이러한 최상의 관행들이 코드에 어떻게 적용되는지 살펴봅시다. 기본 개념을 보여주는 몇 가지 실제 예제가 여기 있습니다:\n\n## 모듈화된 디자인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// user.service.js\nfunction getUserById(id) {\n  // 데이터베이스에서 사용자 데이터를 가져오는 로직\n}\n\nfunction updateUser(user) {\n  // 데이터베이스에서 사용자 데이터를 업데이트하는 로직\n}\n\nmodule.exports = {\n  getUserById,\n  updateUser,\n};\n```\n\n위 코드는 사용자 데이터를 가져오고 업데이트하는 여러 방법을 제공하는 사용자 서비스 모듈입니다. 이는 재사용성을 향상시키고 코드를 보다 쉽게 읽고 유지보수할 수 있도록 만듭니다.\n\n## 의존성 주입(Dependency Injection):\n\n```js\n// database.js\nclass Database {\n  constructor(config) {\n    // config를 사용하여 데이터베이스에 연결하는 로직\n  }\n\n  getUserById(id) {\n    // 사용자를 위한 데이터베이스 쿼리 로직\n  }\n}\n\n// user.service.js (의존성 주입 사용)\nfunction __getUserById(database, id) {\n  // 데이터베이스 인스턴스를 사용하여 사용자 데이터를 가져오는 로직\n}\n\nconst userService = {\n  getUserById: __getUserById.bind(null, new Database(config)), // 데이터베이스 의존성 주입\n};\n\nmodule.exports = userService;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuserService는 데이터베이스와 직접 상호 작용하지 않습니다. 대신, 의존성으로 데이터베이스 인스턴스를 수신합니다.\n\n이를 통해 더 쉬운 테스트가 가능해지고 서비스를 더 유연하게 만들 수 있습니다 - 핵심 로직을 수정하지 않고 데이터베이스 구현을 교체할 수 있습니다.\n\n# 성능 최적화 팁\n\n## 캐싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 호출 및 API 요청 수를 줄이기 위해 캐싱 전략을 구현해보세요.\n\n자주 액세스되는 데이터의 성능을 크게 향상시킬 수 있습니다.\n\n잘 갖춘 식료품 저장실을 상상해보세요 — 재료가 필요할 때마다 식료품점에 가실 필요가 없습니다! Node.js에서 자주 사용되는 캐싱 전략에는 인메모리 캐싱과 브라우저 캐싱 메커니즘을 사용한 클라이언트 측 캐싱이 포함됩니다.\n\n## I/O 작업 최소화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 수행하는 I/O 작업 횟수를 줄이세요.\n\n데이터베이스 호출, 파일 I/O 및 네트워크 요청이 여기에 포함됩니다.\n\n이들은 비동기적이지만, 너무 많은 호출은 여전히 이벤트 루프에 부담을 줄 수 있습니다.\n\n너무 많은 공을 토스하듯이 생각해보세요 — 추적하기 어려워집니다! I/O 작업을 최적화하면 이벤트 루프의 효율성을 유지하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 효율적인 이벤트 루프 활용\n\n이벤트 루프를 사용하는 방법에 유의하세요.\n\n콜백 내에서 긴 실행 시간이 소요되는 작업을 피하십시오. 해당 작업은 이벤트 루프를 차단하고 다른 요청이 처리되는 것을 방해할 수 있습니다.\n\n계산 집약적인 작업에는 워커 스레드와 같은 기술을 활용하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따로 할당된 어시스턴트가 있다면 좋겠죠. 이렇게 하면 주 이벤트 루프가 다른 요청을 처리할 수 있게 해줍니다.\n\n성능을 높이려면 프로파일링 도구를 사용하여 프로그램의 오류를 발견해 보세요.\n\n이 도구들은 코드가 대부분의 시간을 보내는 곳을 파악하고 개선할 위치를 찾는 데 도움이 될 것입니다.\n\n# 보안 팁\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보안을 잊지 마세요! Node.js 어플리케이션은 많은 위협에 노출될 수 있으므로 전략을 세워보세요:\n\n- 알려진 보안 취약점을 해결하기 위해 주기적으로 종속성을 업데이트하세요.\n- SQL 인젝션 및 XSS와 같은 인젝션 위협에 대비하려면 사용자 입력을 살균하세요.\n- 민감한 데이터 접근을 제한하기 위해 강력한 인증 및 권한 부여 기술을 사용하세요.\n\nNode.js 보안에 대해 더 많이 배울 수 있는 온라인 자료가 여러 개 있습니다.\n\n이런 제안을 따르면 보통의 보안 위험을 줄이고 더 안전한 어플리케이션을 만들 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 확장성 전략\n\n프로젝트가 성장할수록 확장성은 중요한 요소입니다. 여기에 몇 가지 접근 방식이 있습니다:\n\n## 클러스터링\n\n노드 JS 어플리케이션을 여러 서버에 다른 인스턴스로 실행하여 작업 부하를 분산시킵니다. 이렇게 하면 보다 많은 동시 요청을 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요리사 팀이 함께 일한다고 상상해보세요 — 그들은 더 적은 시간에 더 많은 식사를 준비할 수 있어요!\n\n## 부하 분산\n\n단일 서버에 과부하를 피하기 위해 들어오는 트래픽을 여러 응용 프로그램 인스턴스로 분산합니다.\n\n이는 교통 안내원과 유사하게 작동하여 요청을 가장 이용 가능한 서버로 라우팅하여 원활한 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 Node.js 앱을 확장하는 몇 가지 기본적인 방법 중 일부에 불과해요.\n\n선택하는 특정 방법은 귀하의 애플리케이션의 기능 및 트래픽 패턴에 의존합니다.\n\n## 마지막으로\n\n이 블로그에서 소개된 모범 사례를 따르면 사용자 베이스가 확대됨에 따라 계속 유지될 강력하고 확장 가능하며 안전한 Node.js 앱을 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발의 다양한 측면에 대해 더 자세히 다룰 향후 블로그를 기대해 주세요!\n\n![image 1](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_4.png)\n\n![image 2](/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_5.png)\n\n# 간단하게 설명하기 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인 플레인 영어 커뮤니티에 참여해 주셔서 감사합니다! 떠나기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 거래하도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png"},"coverImage":"/assets/img/2024-05-27-TheEssentialNodejsGuideforDevelopersofAllLevels_0.png","tag":["Tech"],"readingTime":8},{"title":"Routing으로 나만의 파일 경로 기반 라우터 만들기","description":"","date":"2024-05-27 18:24","slug":"2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter","content":"\n\n## 모든 현대 프레임워크에서 사용하는 기능, 왜 비밀로 유지해야합니까?\n\n![image](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png)\n\n대부분의 JavaScript 프레임워크가 채택하고 있는 한 가지 트렌드는 경로 기반 라우팅을 제공하는 것입니다. 이는 방문하려는 URL과 프로젝트 내의 특수 폴더 사이에 1:1 관계가 있다는 의미입니다. 이 특수 폴더에는 라우트 핸들러 함수들이 포함되어 있습니다.\n\n즉, http://`호스트`/users/list를 방문한다면 users/list.js 파일(또는 사용자의 선호에 따라 users/list/index.js 내부에 있을 수도 있음) 내에 핸들러 함수가 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 정말 멋진 기능이에요. Next, Fresh 또는 다른 프레임워크와 같이 당연하게 사용하는 기능 중 하나에요.\n\n하지만, 저는 당연한 것을 싫어해요. 그래서 이 기능이 어떻게 작동하는지 역공학을 시도해 보겠어요.\n\nExpress를 사용하여 경로 기반 라우팅의 자체 버전을 구현하는 방법을 살펴보겠어요.\n\n# 이 작업을 하는 이유?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 모든 현대 프레임워크에 깊게 자리한 기능을 명확히 설명하는 데 있어서 이것은 개발 경험을 향상시키는 매우 좋은 기능입니다. 이 형식은 라우트 핸들러를 설정하는 방법을 단순화하며 이전에 사용했던 단일 라우트 매핑 파일과 같은 하위 최적화 방법 대신 새로운 방식을 제공합니다.\n\n이전에는 모든 라우트와 해당 핸들러 파일을 포함하는 단일 라우트 매핑 파일을 사용하여 해결책을 찾았습니다. 이런 식으로:\n\n그것은 작은 앱과 몇 개의 라우트만 있는 경우 좋은 해결책이었습니다. 심지어 라우트 핸들러를 다른 위치에 저장할 수 있는 유연성을 가지고도 했습니다. 그러나 반면에 대규모 기업 애플리케이션을 작업 중이라면 이 파일 내에 수백 줄에 달하는 코드를 다뤄야 할 수도 있습니다. 아마도 짐작할 수 있겠지만, 그런 파일을 유지하는 것은 아무도 원치 않았고 그것에 버그를 추가하는 것은 너무 쉬웠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 여기서 \"구성보다 규약\"을 사용하여 우리의 코드가 어떤 라우트를 처리하는지 정의하는 \"더 간단한\" 방법을 유지할 필요가 없게 되었어요. 이것은 또 다른 파일을 유지할 필요없이 코드의 어느 부분이 어떤 라우트를 처리하는지 정의하는 \"더 단순한 방법\"을 제공합니다. 이 부분을 유지하는 것이 승리라고 생각해요!\n\n저는 이러한 유형의 기능이 개발자 경험(DX)을 향상시키기 때문에 정말 좋아해요.\n\n물론, 이를 수행하는 것은 웹 프로젝트의 구조에 대해 많은 것을 결정할 수 있지만, 라우터를 직접 구축하는 경우에는 필요한 수정 사항을 정확히 필요한 대로 수행할 수도 있어요.\n\n그럼 이 구현이 어떻게 보이는지 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 우리만의 라우터 구현하기\n\n이 예제에서는 ExpressJS를 사용할 것입니다. 하지만 ExpressJS의 기본 라우터를 사용하는 것은 말이 안 되기 때문에 사용하지 않을 것입니다. 대신에 웹 서버를 생성하는 과정을 좀 더 간단하게 추상화해주니까, 이것이 주된 목적은 아니지만 여러분들이 일을 더 쉽게 처리할 수 있게 해줄 겁니다.\n\n우리가 만들고자 하는 라우터는 다음과 같은 구조를 다룰 수 있도록 하는 것이 목표입니다:\n\n![라우터 구조](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우트 폴더의 내용을 확인해보세요:\n\n- 우리는 앱의 주요 라우트에 해당해야 할 index.js 파일이 있습니다.\n- 파일 이름을 사용하여 핸들러를 가질 수 있습니다. users.js는 /users로의 요청을 처리하고, books/index.js 파일은 /books로의 요청을 처리할 것입니다.\n- /books/addresses URL을 처리하는 books/addresses/index.js와 같이 더 깊게 중첩된 라우트도 있습니다.\n- 마지막으로, /books/[book].js 파일 덕분에 동적 라우트를 사용할 수도 있습니다. 해당 파일은 루트나 /books/addresses가 아닌 /books 내의 모든 경로를 처리할 것입니다.\n\n총평하자면 매우 완벽한 구조이며, 보다시피, 동적 라우트를 처리하는 유일한 복잡한 로직이 있고, 나머지는 상당히 간단합니다.\n\n## 파일 경로 기반 라우팅 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 간단한 논리를 살펴봅시다: 동적 경로를 제외한 모든 것입니다.\n\nExpressJS를 설치한 후에는 all 메서드를 사용하여 catch-all 핸들러를 설정해 봅시다:\n\n이 코드는 모든 라우트를 캐치하고(all 메서드 덕분) 모든 HTTP 동사를 다루고(*/ 라우트 덕분) 있습니다.\n\n이 핸들러에 의해 요청이 캐치될 때마다 URL을 가져와 routes 폴더 안에 .js 확장자가 있는 파일이 있는지 확인합니다. 파일이 없으면 폴더로 가정하고 해당 폴더 안에 있는 index.js 파일을 찾습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결되었으니, executeRoute 함수를 호출하고 결과 값을 얻겠습니다. 만약 false이면, 파일을 찾을 수 없어 실행에 실패한 것으로 간주하겠습니다. 그래서 그 오류를 \"404 — 찾을 수 없음 응답\"으로 변환하겠습니다.\n\n이 퍼즐의 빠진 조각 executeRoute 함수는 다음과 같이 생겼습니다:\n\n동적 import 함수를 사용하고 있는데, 찾고 있는 파일이 존재한다면 계속 진행하고 요청에 사용된 HTTP 동사를 얻습니다. 이렇게 하면 catch-all 핸들러인 handler(네, 정말 좋은 이름!)를 정의하거나 동사의 이름을 메서드 이름으로 사용할 수 있습니다. 정의하면 코드가 대신 사용하겠죠.\n\n만약 import에 실패한다면(예외를 발생시킨다면) 그것은 가져올 파일이 없기 때문이며, 이는 해당 경로가 매핑되어 있지 않다는 의미입니다. 결과적으로 404 오류를 반환해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n믿든지 말든지, 파일 경로 라우팅을 달성하는 데 거의 필요한 것이 전부입니다.\n\n물론, 이전에 보여준 것처럼 동적 라우팅을 지원하려면 \"약간\"의 추가 코드가 필요합니다.\n\n# 동적 라우팅 지원 추가\n\n이제 URL에 따라 라우트 핸들러를 가져오는 방법을 알았으므로 executeRoute 함수가 false를 반환하는 시나리오에 대한 몇 가지 로직을 추가해야 합니다. 결국, 이는 라우트가 파일과 직접 매핑되지 않음을 의미하지만 \"와일드카드\" 파일을 지원하고자 하는 것이기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같은 로직을 추가하는 것이 좋습니다:\n\n- 직접 매핑된 파일이 없다면, 우선 동적 매개변수의 이름과 값을 추출합니다.\n- URL에서 이름을 제거하여 특수 파일이 있는 폴더를 이해합니다.\n- 동적 매개변수의 이름을 대괄호로 묶어 새 파일의 이름을 만듭니다.\n- 새 파일을 가져와서 executeRoute를 호출하려고 합니다.\n\n다음 예시를 상상해보세요:\n\n- 경로 /api/users/donald를 요청했습니다.\n- 파일 /routes/api/users/donald.js 또는 /routes/api/users/donald/index.js를 찾았지만 그 안에 아무 것도 없습니다.\n- 그래서 우리는 URL에서 \"donald\"를 제거하고, /routes/api/users 폴더 안에서 대괄호로 묶인 이름을 가진 파일을 찾아냅니다. 그리고 [user].js 파일을 찾습니다.\n- 이제 동적 매개변수가 \"user\"라는 것과 그 값이 \"donald\"인 것을 알게 되었습니다.\n- 이제 동적 파일을 가져와서 매개변수를 Request 객체에 추가하여 동적 핸들러가 그것을 사용할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기는 우리 서버의 전체 코드입니다. 이미 알고 있는 부분은 무시하셔도 괜찮지만, 58번 줄에 추가한 false 절 내부의 논리를 살펴보세요. 이미 설명한 내용을 따르고 있습니다.\n\n파일 이름과 매개변수 이름의 결합을 “동적 핸들러”라고 부르며, URL에서 그것을 가져오는 함수를 작성했습니다.\n\n상기 코드 상단에 있는 getDynamicHandler 함수는 “특별” 파일이 있어야 하는 폴더를 탐색합니다. 그 폴더 안의 모든 파일을 읽고, 이름에 괄호가 있는 파일을 찾습니다. 루트 당 하나의 동적 핸들러만 갖는 것이 합리적이므로, 한 번 찾으면 더 이상 찾지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정말 깔끔한 정규 표현식을 사용하면 파일 이름에서 대괄호로 둘러싸인 매개변수 이름도 캡처할 수 있어요.\n\n이제 매개변수의 이름과 핸들러 코드를 포함한 파일 이름을 모두 반환할 수 있어요. 기억해요, 매개변수의 실제 값은 URL에서 직접 가져와요.\n\n그게 바로 동적 라우터가 간단한 라우트, 다양한 HTTP 동사, 그리고 특별히 명명된 핸들러 파일을 사용하는 동적 라우트를 처리할 수 있게 한 거에요.\n\n이 모든 것이 100줄 미만의 단일 파일 안에 포함되어 있답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 제 비슷한 실험들과 마찬가지로, 이것은 학습용 연습입니다. 이 코드를 제품 환경으로 가져가려면 조금 정리하는 것과 아마도 동적 요청마다 디스크에서 읽는 것을 피하기 위해 캐싱을 추가하는 것을 권장합니다. 마지막으로 유닛 테스트를 추가하는 것이 좋습니다.\n\n그럼에도 불구하고, 이 글이 유용했기를 바라며, 이전에 자체 파일 경로 라우터를 작성한 경험이 있다면 댓글에 어떻게 했는지 알려주세요. 노트를 비교해보고 싶습니다!\n\n# 레고와 같은 재사용 가능한 구성 요소로 앱 만들기\n\n![이미지](/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트의 오픈 소스 도구는 25만 명 이상의 개발자들이 컴포넌트로 앱을 빌드할 수 있도록 도와줍니다.\n\n어떤 UI, 기능 또는 페이지든 재사용 가능한 컴포넌트로 변환하고, 여러 애플리케이션들 간에 공유하세요. 협업하고 더 빠르게 빌드하는 것이 더 쉬워집니다.\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고, 원하는 워크플로에 대해 최상의 경험을 즐기세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 레포(repository)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png"},"coverImage":"/assets/img/2024-05-27-DemystifyingRoutingCreatingYourOwnfile-path-basedRouter_0.png","tag":["Tech"],"readingTime":6},{"title":"Nodejs를 사용하여 파이썬 프로그램을 이용해 이메일 보내기","description":"","date":"2024-05-27 18:22","slug":"2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram","content":"\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 살펴보겠습니다. 우리는 프로젝트 구조를 설계하여 관심사를 분리하고 코드베이스를 깔끔하게 유지할 것입니다.\n\n## 목차\n\n- 소개\n- 프로젝트 구조\n- 환경 설정\n- Python 이메일 발신 스크립트 생성\n- Node.js 컨트롤러 생성\n- 라우트 설정\n- 서버 생성\n- 결론\n\n### 1. 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 경우에는 Node.js 애플리케이션에서 Python의 기능을 활용하고 싶을 수 있습니다. 이 튜토리얼은 Node.js 백엔드에서 Python을 사용하여 이메일을 보내는 방법을 보여줍니다. 우리는 Node.js의 child_process 모듈에서 spawn 함수를 사용하여 Python 스크립트를 호출할 것입니다.\n\n# 2. 프로젝트 구조\n\n다음은 우리 프로젝트의 구조입니다:\n\n\nserver/\n  ├── Controller/\n  │   └── mailController.js\n  ├── route/\n  │   └── mailRoute.js\n  ├── Utils/\n  │   └── mailSender.py\n  └── server.js\n  └── .env\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 환경 설정하기\n\n## 단계 1: Node.js 프로젝트 초기화\n\n```js\nmkdir email-sender\ncd email-sender\nnpm init -y\nnpm install express dotenv body-parser\n```\n\n## 단계 2: 환경 변수 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉토리에 다음 내용을 사용하여 .env 파일을 만들어주세요:\n\n```js\nGMAIL_USER=your-email@gmail.com\nGMAIL_APP_PASSWORD=your-app-password\n```\n\nyour-email@gmail.com 및 your-app-password를 실제 Gmail 주소 및 앱 비밀번호로 교체해주세요. Gmail 보안 탭 내에서 앱 비밀번호를 얻을 수 있습니다.\n\n# 4. 파이썬 이메일 발신 스크립트 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUtils 디렉토리에 mailSender.py라는 Python 스크립트를 만들어주세요:\n\n```python\nimport smtplib\nimport os\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\ndef send_email(to_email, subject, body):\n    from_email = os.environ['GMAIL_USER']\n    app_password = os.environ['GMAIL_APP_PASSWORD']\n\n    msg = MIMEMultipart()\n    msg['From'] = from_email\n    msg['To'] = to_email\n    msg['Subject'] = subject\n    msg.attach(MIMEText(body, 'plain'))\n\n    try:\n        server = smtplib.SMTP('smtp.gmail.com', 587)\n        server.starttls()\n        server.login(from_email, app_password)\n        text = msg.as_string()\n        server.sendmail(from_email, to_email, text)\n        server.quit()\n        print(\"이메일을 성공적으로 전송했습니다.\")\n    except Exception as e:\n        print(f\"이메일 전송에 실패했습니다: {str(e)}\")\n\nif __name__ == \"__main__\":\n    import sys\n    to_email = sys.argv[1]\n    subject = sys.argv[2]\n    body = sys.argv[3]\n    send_email(to_email, subject, body)\n```\n\n# 5. Node.js Controller 생성\n\nController 디렉토리에 mailController.js라는 파일을 만들어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst { spawn } = require('child_process');\nconst path = require('path');\n\nexports.sendEmail = (req, res) =\u003e {\n  const { to, subject, body } = req.body;\n  const pythonProcess = spawn('python3', [path.join(__dirname, '../Utils/mailSender.py'), to, subject, body]);\n\n  pythonProcess.stdout.on('data', (data) =\u003e {\n    console.log(`stdout: ${data}`);\n  });\n\n  pythonProcess.stderr.on('data', (data) =\u003e {\n    console.error(`stderr: ${data}`);\n  });\n\n  pythonProcess.on('close', (code) =\u003e {\n    console.log(`child process exited with code ${code}`);\n    res.send('Email sent');\n  });\n};\n```\n\n# 6. Setting Up the Routes\n\n라우트 설정하기\n\nroute 디렉토리에 mailRoute.js라는 파일을 만드세요:\n\n```js\nconst express = require('express');\nconst router = express.Router();\nconst mailController = require('../Controller/mailController');\n\nrouter.post('/send-email', mailController.sendEmail);\n\nmodule.exports = router;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 서버 생성\n\n루트 디렉토리에 server.js라는 파일을 생성하세요:\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst dotenv = require('dotenv');\nconst mailRoute = require('./route/mailRoute');\n\ndotenv.config();\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.use('/api', mailRoute);\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n# 8. 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그 포스트에서는 Node.js 애플리케이션에서 Python 스크립트를 호출하여 이메일을 보내는 방법을 소개했습니다. 프로젝트 구조 설정, 환경 변수 구성, Python 전자 메일 발신자 스크립트 작성, 그리고 Node.js 백엔드를 설정하여 spawn 함수를 사용하여 Python 스크립트를 호출하는 방법에 대해 다뤘습니다. 이 접근 방식은 Node.js와 Python의 강점을 활용하여 유연하고 강력한 이메일 발송 솔루션을 제공합니다.\n\n이 단계를 따라가면 Python 스크립트를 Node.js 애플리케이션에 매끄럽게 통합하여 두 언어의 최상의 기능을 활용할 수 있습니다.\n\n더 나아가 향상된 이메일 처리 및 추가 기능을 위해 Python의 smtplib의 능력과 다양한 이메일 콘텐츠 및 첨부 파일을 처리하는 방법을 탐색하고 싶을 것입니다. 즐거운 코딩 하세요!","ogImage":{"url":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png"},"coverImage":"/assets/img/2024-05-27-SendingEmailsfromNodejsUsingaPythonProgram_0.png","tag":["Tech"],"readingTime":5},{"title":"네스트JS 좋은 점, 나쁜 점, 그리고 추천하지 않는 이유","description":"","date":"2024-05-27 18:21","slug":"2024-05-27-NestJSTheGoodTheBadandTheUgly","content":"\n\n## 다음 프로젝트에 NestJS를 선택하시겠습니까?\n\n![이미지](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png)\n\n지난 몇 년 동안 수백, 수천, 심지어 수백만 명의 유럽 고객에 의해 활용된 여러 애플리케이션을 NestJS를 사용하여 개발했습니다. 이러한 애플리케이션은 다양한 규모의 팀(스타트업, 스케일업, 기업 조직)에서 구축되었습니다. 모듈화된 단일체에서 이벤트 기반 마이크로서비스, GraphQL 및 REST까지 NestJS를 사용하여 개발했습니다. 그러나 모든 좋은 면이 있는 동시에 나쁜 면과 심지어 추악한 면이 있습니다.\n\n본 기사에서는 이 기간 동안 NestJS를 사용한 후 내 생각을 공유하려고 합니다. 개발자, 기술 리더 및 팀 리더가 NestJS 사용 중 발생할 수 있는 잠재적인 문제를 예상하고 해결하는 데 필요한 도구를 제공하는 것이 목표입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 좋은 점\n\n다양한 크기의 팀에서 깨끗한 코드에 대한 다른 의견과 응용프로그램이 완료되었을 때의 정의에 대한 다른 의견을 가지고 일해 왔습니다. 회사마다, 팀마다, 심지어 사람마다 다르게 다양합니다. 팀 내 개인의 의견은 종종 주관적이며, 이로 인해 개발 가이드라인과 코딩 스타일을 형성하기 어렵게 만들 수 있습니다. 실제로, 모든 팀이 언젠가는 다이어그램이 나타내는 것처럼 동일한 학습 곡선 단계를 따릅니다.\n\n![Diagram](/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_1.png)\n\n여기서 Nest가 실제로 가치를 증명합니다. Nest는 팀을 특정 방향으로 안내하고 이미 작업을 대부분 처리하는 디자인 패턴을 제공합니다. Nest는 매우 주관적이며, 그것이 좋은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팀용 Nest의 가치는 팀 간 일관성 및 코드베이스의 일관성에서 그 자체를 입증합니다. 프레임워크를 사용하면 GraphQL 애플리케이션에 실제로 참여할 수 있으며, 내부를 깊이 파악할 필요 없이 즉시 사용할 수 있습니다. Nest는 훌륭한 코드 예제들을 제공하여 이를 가능하게 만듭니다.\n\n비즈니스가 빠르게 움직이는 가운데, 비즈니스 방향성에 따라 유연하게 이동할 수 있는 개발 프레임워크를 사용하는 것은 큰 장점입니다. Nest를 사용하면 팀이 온보딩 프로세스보다는 제품 출시에 집중할 수 있습니다. 새로운 개발자를 쉽게 통합할 수 있으며, 훌륭한 문서와 발전하는 커뮤니티 덕분에 신입 개발자도 즉시 기여하기 시작할 수 있습니다.\n\n# 아쉬운 점\n\n좋은 것과 함께 항상 나쁜 점이 있습니다. 솔직히 말해서 이것은 프레임워크 자체보다는 종종 팀 또는 개인이 프레임워크 내에서 개념을 오용하거나 오해하는 데 직접적으로 책임이 있는 경우가 많습니다. 하지만 내가 경험한 Nest의 몇 가지 부분에서 어떤 팀들이 반복해서 고민하는 부분을 지적하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원형 의존성 문제\n\nSooner or later each NestJS project will face the moment that circular dependencies are introduced. Not only can I relate from experience, but also Nest elaborates on this common issue and the community-built package nestjs-spelunker identifies similar problems as well (even though it’s focused a bit more on the dependency injection tree in general).\n\nThe circular dependency issue is quite a nasty one, that could potentially slow down the entire development team in the long run — if not solved properly. Fortunately, quite recently an article about circular dependencies was published by Trilon, where a core contributor of Nest points out a tool, called Madge, to identify circular dependencies early.\n\n## Swallowed logs on application startup\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n서로 의존하는 문제가 발생하는 경우 종종 나타나는 또 다른 문제는 시작 시 오류가 발생할 때 로그가 소진되는 것입니다. 이로 인해 개발자들이 실제로 무슨 일이 발생했는지 이해하기가 매우 어려워집니다.\n\n오류를 식별하기 위한 일반적인 접근 방식은 오류 발생 시 중단을 비활성화하고 오류 메시지를 다시 던지는 것입니다.\n\n이제 콘솔에 실제 오류가 기록됩니다.\n\n# 실망하기 쉬운 부분\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋은 것과 나쁜 것이 있는 것처럼 추악한 면도 존재합니다. 솔직히 말해서, 이것은 항상 프레임워크가 직접 책임지는 것은 아니라, 그보다는 팀 또는 개인들이 프레임워크 내의 개념을 오용하거나 오해하는 경우가 많습니다. 저는 함께 일한 팀들이 Nest의 일부 영역에서 여러 번 고민을 겪었다는 점을 지적하고 싶습니다.\n\n## 단위 테스트\n\nNest에서의 단위 테스트는 프레임워크 자체와 매우 통합되어 있습니다. 단위와 통합 테스트 사이의 차이를 정의하는 것은 팀마다, 심지어 사람마다 달라집니다. Nest 내에서 가장 작은 단위를 테스트하려면 상당한 부가 코드와 다양한 기술에 대한 지식이 필요합니다. 특히 새로운 개발자들에게는 테스트 작성이 복잡할 수 있습니다. 왜냐하면 Nest가 어떻게 의존성 주입 트리를 해결하는지에 대한 지식이 필요하기 때문입니다.\n\n간단한 애플리케이션을 테스트하려고 하면 아래와 비슷한 테스트 파일에 맞닥뜨리게 되실 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 실제 응용 프로그램에서 하나의 제공 업체에 대해 여러 종속성이 있을 것이며, 이로 인해 단위 테스트의 복잡성이 심각하게 증가할 것입니다. 시간이 지남에 따라 이러한 테스트는 팀이 단위 자체를 테스트하는 대신 어떻게 테스트를 작성하고 종속성 주입 트리를 구축할지에 더 많은 주의를 기울이면서 병목 현상이 될 수도 있습니다.\n\n다르게 할 수 있을까요? 물론, 테스트의 복잡성을 해결하는 팀들을 본 적이 있습니다. 클래스 메소드에 구현하는 대신 별도의 함수에 로직을 구현함으로써 테스트의 복잡성에 대응합니다. 이 접근 방식의 장점은 테스트가 간편해지고, 새로운 개발자가 JavaScript를 알고 있기 때문에 더 쉽게 익힐 수 있다는 것입니다. 다음을 고려해 보세요:\n\n모든 좋은 면에는 단점이 따르지만, 이러한 접근 방식의 구현으로 단위 테스트의 복잡성을 해결할 수 있을 뿐 아니라 다른 일면에서도 타협 사항이 있을 수 있습니다.\n\n## 동적 컨트롤러의 부재\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNest에는 강력한 프로바이더 개념이 함께 제공됩니다. 이러한 프로바이더는 사용자 정의된 것이며 어떤 형태든 될 수 있습니다. 프로젝트가 더 성숙해지면 이러한 프로바이더는 매우 유용해집니다. 하지만 Nest의 의존성 주입 트리를 해결하는 방법에 대해 알아야 하는 개발자들에게는 어느 정도의 지식이 필요합니다.\n\n어쨌든, 실제로 필요한 것은 이러한 사용자 정의 프로바이더에 해당하는 사용자 정의 컨트롤러의 대응물입니다. Nest의 창시자에 따르면 이러한 컨트롤러는 Nest의 아이디어와 완전히 반대되지만, 프로젝트가 성장할 때 실제로 매우 유용합니다. Nest의 한계를 극복하기 위해 이러한 접근 방식을 구현할 수 있습니다. GitHub 쓰레드에 설명된 factory 접근 방식으로 구현할 수 있습니다:\n\n(하지만 오직 이것만이 아닌) Dynamic Modules를 통해 이 factory를 사용할 수 있습니다.\n\n하지만 모든 것은 좋음으로 이어지는 나쁨이 따르며, 이러한 접근 방식을 구현하면 동적 컨트롤러를 다루게 되는 반면에 한편으로는 Nest의 컨트롤러에 대한 의견이 있는 패턴을 포기하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nNest는 Node 랜드스케이프 내에서 정말 성숙하고 잘 문서화되어 있어서 많은 사람들이 선택하는 프레임워크입니다. 하지만 모든 것에는 좋은 점뿐만 아니라 나쁜 점과 가장 나쁜 점 등도 있습니다. 그러니 NestJS와 같은 프레임워크를 선택할 때 팀이 직면할 수 있는 잠재적인 문제점을 식별하는 것이 중요합니다.\n\n마지막 질문은 — 다음 프로젝트에 NestJS를 선택할 것인가. 음, 항상 그렇지만, 상황에 따라 다를거에요 ;)!","ogImage":{"url":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png"},"coverImage":"/assets/img/2024-05-27-NestJSTheGoodTheBadandTheUgly_0.png","tag":["Tech"],"readingTime":5},{"title":"structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법","description":"","date":"2024-05-27 18:19","slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\" /\u003e\n\n# 1. 서문\n\n왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\n\n이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 객체를 깊은 복제하는 두 가지 방법\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png)\n\n내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\n\n```js\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  domNode: document.createElement(\"div\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 testData를 테스트 데이터로 사용할 것입니다.\n\n# 2.1# JSON.parse와 JSON.stringify\n\n이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\n\n```js\ntry {\n  const jsonClone = JSON.parse(JSON.stringify(testData))\n  console.log(jsonClone)\n} catch (error) {\n  console.log(\"JSON 메서드가 이 데이터를 처리할 수 없습니다\")\n}\n// 출력\n/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지를 포함한 코드 블록:\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nJSON.parse(JSON.stringify(obj))\n```\n\nMarkdown 형식으로 변환 된 표:\n\n# 2.2# lodash.clone\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\n\n```js\nconst _ = require('lodash')\nconst lodashClone = _.cloneDeep(testData)\nconsole.log(lodashClone)\n\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\n```\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png)\n\n# 3.1# 새로운 API: structuredClone?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\" /\u003e\n\nmdn에서 가져왔어요!\n\n2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\n\n아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  // function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  // domNode: document.createElement(\"div\")\n}\n\nconst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: undefined, // Functions are not cloned\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: undefined // DOM nodes are not cloned\n}\n*/\n\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\" /\u003e\n\n우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\n\n# 3.2# structuredClone의 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\n\n하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3.3 구조화된 복제의 일부 제한 사항\n\n친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\n\n함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\n\n```js\nconst obj = { fn: () =\u003e {} }\n\nstructuredClone(obj)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\" /\u003e\n\n```js\nconst obj = { domNode: document.createElement('div') }\n\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\" /\u003e\n\n이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 보내고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 개발자가 반드시 알아야 하는 10가지 도구","description":"","date":"2024-05-27 18:18","slug":"2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3","content":"\n\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png)\n\n10 fantastic web dev tools to level up your productivity and achieve your coding goals faster than ever.\n\nFrom breathtaking animations to rapid project creation, these tools will boost your workflow and make a lot of things easier.\n\n# 1. Fira Code\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 코드 편집기의 기본 글꼴은 지루해요 (예: Consolas).\n\n대신 이 아름다운 고정폭 글꼴을 사용해보세요:\n\n![](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_1.png)\n\n글꼴 리거처는 항상 뛰어난 특징 중 하나였어요 — 일반적인 코딩 문자 그룹을 세련된 직관적인 방식으로 병합하는 기능이에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVS Code의 글꼴을 변경하는 것은 매우 간단해요. 설정으로 이동해 보시면 \"자주 사용하는\" 옵션 중에 있을 거에요:\n\n![image](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_2.png)\n\n# 2. Barba JS\n\n웹페이지에 창의적인 멋을 더하고 사용자들을 기쁘게 만들어줄 멋진 전환 효과를 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경된 텍스트입니다.\n\n![Image 1](https://miro.medium.com/v2/resize:fit:1400/0*X8tn7Y3ovmldXD_B.gif)\n\n당연히 클라이언트 측 라우팅을 사용하여 앱과 같은 경험을 제공합니다:\n\n![Image 2](https://miro.medium.com/v2/resize:fit:1400/0*hR4-kwV-JDKmMfW2.gif)\n\n# 3. Consola\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nConsolas을 방금 비난했는데, 그건 오타가 아니에요.\n\n이 아름다운 사용자 친화적인 콘솔 래퍼에요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_3.png)\n\n정교한 CLI 도구를 만드는 데 완벽해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_4.png\" /\u003e\n\n# 4. Preact JS\n\n리액트의 빠른 대안 - 10 배 이상 가볍습니다!\n\n들어가 보면 훅, JSX, 함수형 컴포넌트가 있습니다... 사실상 드롭인 대체물입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApp 컴포넌트를 확인해 보세요. 제 오른손으로 (아니면 왼손으로) 차이점을 거의 세어볼 수 있어요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_5.png)\n\n그리고 36,000개 이상의 GitHub 스타 — 진지하게 다룰 만하죠.\n\n# 5. Carbon\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사람들을 지루하게 만들 필요는 없어요. \n\n카보너(Carbon)를 사용하여 코드 스니펫을 아름답게 만들어 세상에 아름다움을 더해보세요:\n\n![Carbon](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_6.png)\n\n여러 가지 테마 중에서 선택할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_7.png\" /\u003e\n\n# 6. Firestore\n\n아마도 가장 좋은 NoSQL 데이터베이스입니다.\n\n넓고 무료 제한으로 새로운 아이디어를 시도하기에 훌륭합니다. 제가 여러 차례 해봤던 것처럼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표를 바꾼 것입니다.\n\n\n![Amazing Tools Part 1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_8.png)\n\nJS 개발자로써 매우 쉽고 직관적일 것입니다.\n\n![Amazing Tools Part 2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_9.png)\n\n심지어 클라이언트 측에서 사용하고 서버 요청을 완전히 건너뛸 수도 있습니다 — 비용 절감과 앱 성능 향상을 도모할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 이전에 무료 웹 소켓 서버를 사용한 적이 있었는데, 서버 측 보호장치와 완벽하게 작동했었어요.\n\n# 7. react-input-autosize\n\n입력 자동 조절: 만연한 웹 디자인 문제: \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*piupw_8S7ljNmEAL.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 이유로 react-input-autosize가 문제를 해결하고 나서 매주 수백만 번의 다운로드를 받게 되었습니다:\n\n![이미지1](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_10.png)\n\n매우 쉽게 사용할 수 있는 UI 컴포넌트:\n\n![이미지2](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8. VS Code용 라이브 서버\n\n정적 HTML 페이지를 신속하게 작성하는 강력한 도구 — 4800만 회 다운로드!\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_12.png)\n\n웹페이지를 수동으로 다시로드할 필요가 없습니다 — 브라우저에서 페이지를 불러오고 파일 내용과 화면을 동기화해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*XyzPx0jn9viCwfGa.gif)\n\n# 9. Parcel\n\nParcel: 아무 설정 없이 제로 설정으로 사용 가능한 번들러 - 고대의 Create React App보다 훨씬 더 유연합니다.\n\n모든 최신 웹 기술을 지원하며 우수한 성능을 자랑합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_13.png)\n\n우리는 index.jsx에서 새로운 React 앱을 빠르게 생성할 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_14.png)\n\n# 10. SendGrid\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강력하고 인기 있는 API로 마케팅 및 거래 이메일을 보내고 99%의 전달률을 유지하세요.\n\n스팸 폴더를 건너뛰고 인박스에 직접 도착하는 아름다운, 매력적인 이메일을 디자인하세요.\n\n![이미지](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_15.png)\n\n# 마지막으로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 생산성과 개발자의 삶의 질을 높이는 데 이 멋진 도구들을 사용해보세요.\n\n# 자바스크립트가 하는 모든 미친짓\n\n당신이 이미 모든 특이점을 알고 있다고 생각했을 때,\n자바스크립트가 하는 모든 미친짓은 자바스크립트의 세세한 함정과 잘 알려지지 않은 부분에 대한 흥미진진한 안내서로 귀하의 소중한 시간을 절약하면서 고통스러운 버그를 피하는 데 도움이 됩니다.\n\n오늘 무료 복사본을 받아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 코드입니다.\n\n\n![이미지 설명](/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_16.png)\n","ogImage":{"url":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png"},"coverImage":"/assets/img/2024-05-27-10amazingtoolsthateverywebdevelopershouldknowPart3_0.png","tag":["Tech"],"readingTime":5}],"page":"60","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"60"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>