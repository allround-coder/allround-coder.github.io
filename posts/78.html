<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/78" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/78" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)" href="/post/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React 테스팅 라이브러리들 정리" href="/post/2024-05-01-ReactTestingLibraries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React 테스팅 라이브러리들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ReactTestingLibraries_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React 테스팅 라이브러리들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React 테스팅 라이브러리들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" href="/post/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Native 앱 디버깅하는 방법" href="/post/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Native 앱 디버깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Native 앱 디버깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React Native 앱 디버깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" href="/post/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" href="/post/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js에서 로컬 스토리지 사용하는 방법" href="/post/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js에서 로컬 스토리지 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js에서 로컬 스토리지 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" href="/post/2024-05-01-HooksinReacts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HooksinReacts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트에서의 훅(Hooks)을 제대로 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트에서의 훅(Hooks)을 제대로 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js를 위한 실제 API 미들웨어 작성 방법" href="/post/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js를 위한 실제 API 미들웨어 작성 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Next.js를 위한 실제 API 미들웨어 작성 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue3 + Vite 컴포넌트화 하는 방법" href="/post/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue3 + Vite 컴포넌트화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue3 + Vite 컴포넌트화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"데이터 시각화를 위한 최고의 React 차트 라이브러리 8가지🔥(2024년 최신)","description":"","date":"2024-05-01 18:18","slug":"2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024","content":"\n\n![2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png)\n\n현대 애플리케이션에서 데이터 시각화는 중요한 요소로 떠오르고 있습니다. 기업 및 개인들은 데이터 기반 의사 결정을 촉진하기 위해 시각적으로 매력적이고 통찰력 있는 차트에 의존하고 있습니다. 사용자 인터페이스를 만드는 데 널리 사용되는 JavaScript 라이브러리인 React의 등장으로, 앱에 쉽게 통합 가능한 React 차트 라이브러리에 대한 높아진 필요성이 있습니다. 이 글에서는 2024년에 데이터 시각화를 위한 가장 주목할만한 React 차트 라이브러리에 대해 살펴보고, 주요 기능과 실용적인 적용 사례에 대해 밝혀 드리며, 프로젝트에 최적인 React 차트 라이브러리를 선택하는 데 도움을 드릴 것입니다. 📊✨\n\n## 시작해봅시다 👇👇\n\n# Recharts\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRecharts는 개발자들이 쉽고 시각적으로 매력적인 차트를 애플리케이션에 손쉽게 통합할 수 있도록 도와주는 포괄적인 React 차트 라이브러리입니다. 📈 D3.js 위에 구축된 이 라이브러리는 유연성과 간결함 사이의 균형을 이루어 React 환경에서 직관적이면서 강력한 데이터 시각화 솔루션을 찾는 사람들에게 우수한 선택지가 됩니다.\n\n## Recharts 주요 기능:\n\n- 사용 편의성 🚀: Recharts는 선언적이고 컴포넌트 기반 접근 방식을 통해 차트 생성 프로세스를 간단화하며, React 철학과 원활하게 조화를 이룹니다. 이를 통해 초보자와 숙련된 개발자 모두에게 접근하기 쉽게 만들어줍니다.\n- 다양한 차트 유형 📊: 라이브러리는 선형 차트, 막대 차트, 영역 차트, 파이 차트 등 다양한 유형의 차트를 제공합니다. 이 다양성은 Recharts가 다양한 데이터 시각화 요구에 대응할 수 있도록 보장합니다.\n- 반응형 디자인 📱: Recharts는 기본적으로 반응형으로 설계되어 다양한 화면 크기에 자동적으로 적응합니다. 이 기능은 다양한 장치와 플랫폼에서 사용자 친화적인 애플리케이션을 만드는 데 중요합니다.\n- 사용자 정의 옵션 🎨: 개발자는 다양한 스타일 옵션을 사용하여 차트의 외관을 쉽게 사용자 정의할 수 있습니다. 색상, 모양, 툴팁 및 기타 시각적 요소를 구성함으로써 애플리케이션 디자인과 유연성을 일치시킬 수 있습니다.\n- 상호작용 🤝: Recharts는 툴팁 및 확대 등 상호작용 기능을 지원하여 사용자가 데이터를 자세히 탐색하고 이해할 수 있도록 사용자 경험을 향상시킵니다.\n- 애니메이션 지원 🔄: 애니메이션 전환을 통해 차트를 생동감 있게 만들어 데이터 시각화 경험을 더욱 매력적으로 합니다. Recharts는 부드러운 애니메이션을 지원하여 차트에 세련되고 동적인 요소를 추가합니다.\n- React 통합 🔄: React 특화 라이브러리인 Recharts는 React 애플리케이션과 원활하게 통합됩니다. 이는 React 개발자들에게 일관되고 효율적인 개발 프로세스를 보장합니다.\n- 활발한 커뮤니티 🌐: 활발하고 지지력 있는 커뮤니티로 인해 Recharts는 지속적인 개발, 버그 수정 및 best practices 공유의 혜택을 받습니다. 이 커뮤니티 주도 방식은 라이브러리의 신뢰성과 성장에 기여합니다.\n\nhttps://recharts.org/en-US/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_1.png\" /\u003e\n\n# Chartjs\n\nChart.js는 웹 애플리케이션에서 인터랙티브하고 시각적으로 매력적인 차트를 만드는 데 사용되는 인기 있는 JavaScript 라이브러리입니다. Chart.js는 간결성과 유연성으로 유명하여 개발자들이 다양한 종류의 차트를 손쉽게 생성할 수 있습니다. 📈🌐\n\n## Chart.js의 주요 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사용 편의성: Chart.js는 사용자 친화적인 API로 유명하여 모든 기술 수준의 개발자들이 쉽게 이용할 수 있습니다.\n- 반응형 디자인: Chart.js로 생성된 차트는 본질적으로 반응형이며, 다양한 기기와 화면 크기에서 최적의 보기와 상호 작용을 제공합니다. 📱💻\n- 사용자 정의: 디자인 요구 사항을 충족시키기 위해 개발자들이 차트의 모양을 맞춤화할 수 있는 다양한 옵션을 제공합니다.\n- 다양한 차트 유형 지원: Chart.js는 라인 차트, 막대 차트, 레이더 차트 등 다양한 차트 유형을 지원하여 데이터의 시각화에 다양성을 제공합니다.\n- 상호 작용: 사용자는 차트와 상호 작용할 수 있으며, 데이터 포인트 위에 마우스를 올려 세부 정보를 확인할 수 있어 사용자에게 재미있는 경험을 제공합니다.\n- 애니메이션: Chart.js는 부드러운 애니메이션을 포함하여 차트의 시각적 매력을 높이고 동적인 사용자 경험을 제공합니다.\n\nhttps://www.chartjs.org/\n\n![Image](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_2.png)\n\n# React-chartjs-2\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact-chartjs-2은 Chart.js를 감싸는 React 래퍼로, 인기 있는 JavaScript 차트 라이브러리입니다. React 애플리케이션과 Chart.js가 제공하는 강력한 차트 기능 사이에 원활한 다리 역할을 합니다. 📊🚀\n\n## React-chartjs-2의 주요 기능:\n\n- 쉬운 통합: React-chartjs-2는 Chart.js를 React 애플리케이션에 간단하게 통합하여 개발자들에게 원활하고 번거로움 없는 경험을 제공합니다. 🤝\n- 선언적 구문: React의 선언적 특성을 활용하여, 이 라이브러리는 코드를 더 읽기 쉽고 유지하기 쉬운 깔끔하고 직관적인 구문을 사용하여 차트를 나타낼 수 있습니다. ✨\n- 반응형 디자인: React-chartjs-2로 생성된 차트는 본질적으로 반응형으로, 다양한 화면 크기에 자동으로 조정됨으로써 다양한 기기에서 일관된 사용자 경험을 제공합니다. 📱\n- 사용자 정의 옵션: 이 라이브러리는 다양한 사용자 정의 옵션을 제공하여, 개발자들이 차트의 모양을 프로젝트 요구 사항에 맞게 맞출 수 있습니다. 이는 색상, 라벨, 기타 시각적 요소를 조정하는 것을 포함합니다. 🎨\n- 상호 작용: React-chartjs-2는 툴팁 및 호버 효과와 같은 상호 작용 기능을 지원하여, 차트에 제시된 데이터와의 사용자 상호 작용을 증가시킵니다. 🖱️📈\n- 다양한 차트 유형 지원: 선 차트, 막대 차트, 레이더 차트 등 다양한 차트 유형을 지원하며, 이 다양성으로 다양한 데이터 시각화 요구 사항에 적합합니다. 🔄📉\n- 동적 데이터 바인딩: React-chartjs-2는 동적 데이터 바인딩을 원활하게 처리하여, 기존 데이터가 변경되는 대로 차트를 실시간으로 업데이트할 수 있습니다. ⚡\n- 커뮤니티 지원: Chart.js를 기반으로 하므로, React-chartjs-2는 기존 라이브러리의 강력한 커뮤니티 지원과 지속적인 개발을 상속합니다. 이는 개발자가 최신 기능과 개선 사항에 액세스할 수 있도록 보장합니다. 👩‍💻👨‍💻\n\nhttps://react-chartjs-2.js.org/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_3.png)\n\n# Victory\n\nVictory는 동적인 React 차트 라이브러리로, 데이터 시각화를 매끄럽고 시각적으로 멋지게 만드는 다양한 기능을 제공하여 눈에 띕니다. 🌐\n\n## 주요 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 리액트 중심적 접근 방식: Victory는 특히 React를 위해 설계되었으며 이 인기있는 JavaScript 라이브러리의 모든 잠재력을 활용합니다. 그 컴포넌트들은 React 애플리케이션과 원활하게 통합되어 개발 프로세스를 원활하게 보장합니다.\n- 다양한 차트 유형: Victory는 기본 선 그래프 및 막대 그래프에서 산점도와 히트맵과 같은 더 복잡한 차트까지 다양한 차트 유형을 지원합니다. 이 다양성을 통해 개발자들은 데이터에 가장 적합한 시각화를 선택할 수 있습니다.\n- 반응형 디자인: 📱 Victory는 반응형 디자인 원칙을 받아들여 차트가 서로 다른 화면 크기에 유연하게 대응할 수 있도록 합니다. 이는 다양한 기기에서 최적의 뷰잉 경험을 보장하여 접근성과 사용자 참여를 향상시킵니다.\n- 사용자 정의 기능: 🎨 Victory는 개발자들에게 광범위한 사용자 정의 옵션을 제공하여 색상, 스타일부터 축 구성에 이르기까지 차트의 모양을 자신의 애플리케이션의 시각적 정체성과 일치시킬 수 있습니다.\n- 실시간 업데이트: 🔄 실시간 데이터 업데이트가 필요한 애플리케이션에 대해 Victory는 매끄러운 지원을 제공합니다. 라이브러리는 동적 데이터를 효율적으로 처리하여 성능을 저해하지 않고 차트가 즉시 반영되도록 보장합니다.\n- 상호 작용성: 🖱️ Victory는 상호 작용 요소를 통해 사용자 참여를 향상시킵니다. 호버 효과, 툴팁 및 클릭 이벤트를 통해 사용자들은 데이터를 탐색하고 이해하는 것을 더 직관적으로 할 수 있습니다.\n- 커뮤니티 지원: 👥 리액트 생태계의 필수적인 부분으로 Victory는 활기찬 커뮤니티의 혜택을 받습니다. 개발자들은 문제 해결을 위한 협력적인 환경을 유도하는 충분한 리소스, 튜토리얼 및 서드파티 확장 기능을 찾을 수 있습니다.\n\nhttps://formidable.com/open-source/victory/docs/victory-chart/\n\n![2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_4.png](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_4.png)\n\n# Visx\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVisx는 React 애플리케이션을 위해 특별히 설계된 강력하고 다재다능한 데이터 시각화 라이브러리입니다. 🚀 Airbnb에서 개발되었으며, 커스터마이징과 성능에 중점을 둔 다양한 차트 및 그래프를 생성하기 위한 강력한 구성 요소 세트를 제공합니다.\n\n## Visx의 주요 기능:\n\n- 모듈성 및 확장성 🧩: Visx는 모듈식으로 설계되어 개발자들이 필요에 맞게 구성 요소를 선택할 수 있습니다. 이 모듈성은 유연성을 촉진하고 기존 프로젝트와의 통합을 용이하게 합니다.\n- 선언적 구문 📝: React의 선언적 구문을 이용하여, Visx는 복잡한 시각화를 명확하고 간결하게 표현할 수 있도록 도와줍니다. 이는 초보자와 경험자 모두에게 접근하기 쉽게 만듭니다.\n- 다양한 차트 유형 📊: Visx는 기본적인 선 및 막대 차트부터 트리맵 및 극지 플롯과 같은 고급 시각화까지 다양한 차트 유형을 지원합니다. 이 다양성은 다양한 데이터 표현 요구에 적합합니다.\n- 높은 성능 🚀: 성능 최적화에 중점을 둔 Visx는 대규모 데이터 세트를 처리하면서도 렌더링 속도를 희생하지 않습니다. 이는 특히 상당한 양의 데이터를 처리할 때 부드러운 사용자 경험을 보장합니다.\n- 사용자 정의 옵션 🎨: Visx는 차트의 모양과 동작을 특정 디자인 요구에 맞게 맞춤화할 수 있는 다양한 사용자 정의 기능을 제공합니다. 이 유연성은 현대적인 스타일링 요구를 갖는 프로젝트에 적합합니다.\n- 반응형 디자인 📱: 반응형 디자인 원칙을 지원하는 Visx 차트는 자동으로 다양한 화면 크기에 적응합니다. 이는 데스크톱부터 모바일 기기까지 다양한 장치에서 일관된 시각적으로 매력적인 경험을 보장합니다.\n- 활발한 커뮤니티 지원 🤝: Airbnb와 활발한 오픈 소스 커뮤니티의 지원을 받는 Visx는 정기적인 업데이트와 버그 수정, 그리고 많은 커뮤니티 기여 구성 요소를 활용합니다. 이 지원은 라이브러리가 항상 관련성 있고 신뢰할 수 있도록 합니다.\n- 잘 문서화 📚: Visx는 포괄적인 문서와 예제를 제공하여 개발자들이 쉽게 시작하고 기능을 탐색할 수 있게 도와줍니다. 이는 학습 곡선을 줄이고 프로젝트에 효율적으로 통합하는 데 도움이 됩니다.\n\nhttps://airbnb.io/visx/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![React Chart Libraries](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_5.png)\n\n# Nivo\n\nNivo는 웹 애플리케이션에서 데이터 시각화에 우아함과 기능성을 더해주는 포괄적인 React 차트 라이브러리입니다. 🌐 React와 D3로 개발된 Nivo는 간결성과 다양성으로 눈에 띄며, 개발자가 효율적이고 미적으로 매력적인 해결책을 찾는 데 최적의 선택지입니다.\n\n## Nivo 주요 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 차트 유형 📈: Nivo는 막대 차트, 선 그래프, 파이 차트 등 다양한 차트 유형을 지원합니다. 이 다양성 덕분에 개발자들은 자신의 데이터에 가장 적합한 시각화를 선택할 수 있습니다.\n- 반응형 디자인 📱: Nivo 차트는 기본적으로 반응형으로 제공되어 다양한 화면 크기와 장치에 매끄럽게 적응합니다. 이를 통해 사용자들이 다양한 플랫폼에서 일관되고 시각적으로 매력적인 경험을 할 수 있습니다.\n- 사용자 정의 옵션 🎨: 라이브러리는 다양한 사용자 정의 옵션을 제공하여 개발자들이 그들의 응용 프로그램의 독특한 스타일과 일치하는 차트의 모양을 맞춤화할 수 있게 합니다. 이는 색 구성표, 레이블 및 상호 작용 요소를 포함합니다.\n- 애니메이션 전환 🔄: Nivo는 부드럽고 직관적인 애니메이션 전환으로 사용자 참여를 높입니다. 데이터 포인트 간의 다이내믹한 전환은 차트를 더욱 매력적이고 사용자 친화적으로 만듭니다.\n- 상호 작용 기능 🖱️: Nivo 차트에는 툴팁 및 확대 기능과 같은 상호 작용 기능이 탑재되어 있습니다. 이러한 기능을 통해 사용자들은 시각화 내에서 직접 데이터를 탐색하고 통찰을 얻을 수 있습니다.\n- 범례 및 축 🗂️: 라이브러리는 차트에 범례와 축을 간단하게 추가하도록 도와줍니다. 이는 데이터 해석에 필수적인 컨텍스트를 제공하여 시각화의 전반적인 명확성과 사용성을 높입니다.\n- 쉬운 통합 🧩: Nivo는 개발자 친화적인 API로 설계되어 React 앱에 쉽게 통합됩니다. 라이브러리 문서는 상세하며 구현 프로세스를 최적화하기 위한 명확한 지침과 예제가 제공됩니다.\n- 활발한 커뮤니티 및 업데이트 🚀: Nivo는 활발한 오픈 소스 커뮤니티의 혜택을 받아 정기적인 업데이트와 계속적인 개선이 이루어집니다. 이 지원 네트워크는 도전에 직면한 개발자들이나 고급 구현을 위한 영감을 찾는 데 유용합니다.\n\nhttps://nivo.rocks/components/\n\n![차트 이미지](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_6.png)\n\n# React-stockcharts\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 스톡차트는 리액트 애플리케이션 내에서 금융 및 주식 시장 데이터 시각화를 위해 특별히 설계된 강력한 라이브러리입니다. 📈📊\n\n## 주요 기능:\n\n- 다양한 차트 유형 제공: 리액트 스톡차트는 선 그래프, 캔들스틱 차트, OHLC 차트, 산점도 등 다양한 차트 유형을 지원합니다. 이 다양성은 다양한 금융 데이터셋을 시각화하는 데 적합합니다.\n- 상호 작용 요소: 라이브러리에는 확대, 이동, 툴팁과 같은 내장 상호 작용 기능이 제공됩니다. 사용자는 차트와 상호 작용하여 자세한 데이터 포인트를 탐색하고 분석할 수 있습니다.\n- 기술적 지표: 리액트 스톡차트에는 금융 분석에서 일반적으로 사용되는 포괄적인 기술적 지표가 포함되어 있습니다. 이러한 지표들은 이동 평균, RSI (상대강도지수), MACD (이동평균수렴확산)와 같이 사용자에게 철저한 기술적 분석을 수행할 수 있는 도구를 제공합니다.\n- 반응형 디자인: 라이브러리는 반응형을 고려하여 설계되어 다양한 화면 크기에 매끄럽게 적응합니다. 다양한 기기에서 일관된 사용자 친화적 경험을 제공하는 데 중요합니다.\n- 통합의 용이성: 리액트 스톡차트는 리액트 애플리케이션과 원활하게 통합되도록 개발되었습니다. 모듈화된 구조와 잘 정리된 API로 개발자에게 접근성을 제공하며, 더 빠르고 간편한 통합 프로세스를 용이하게 합니다.\n- 사용자 정의 옵션: 개발자들은 차트의 모양과 동작을 프로젝트 요구 사항에 맞게 사용자 정의할 수 있습니다. 이러한 유연성은 시각적으로 매력적이고 특별한 금융 시각화를 만들 수 있게 합니다.\n- 커뮤니티 지원: 활발하고 적극적인 커뮤니티가 있어 지속적인 개발, 버그 수정, 최고의 사례 공유를 통해 리액트 스톡차트는 발전하고 있습니다. 이는 개발자가 라이브러리를 사용할 때 리소스와 지원에 엑세스할 수 있도록 보장합니다.\n\nhttps://rrag.github.io/react-stockcharts/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_7.png\" /\u003e\n\n# Ant Design Charts\n\nAnt Design Charts는 Ant Design 팀에 의해 개발된 강력하고 다양한 차트 라이브러리로, React 애플리케이션과 매끄럽게 통합되도록 설계되었습니다. 📈🛠️\n\n## 주요 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 차트 유형: Ant Design Charts는 선 그래프, 막대 그래프, 영역 그래프, 원 그래프 등 다양한 차트 유형을 지원합니다. 📊\n- 사용자 정의: 이 라이브러리는 색상 구성표, 레이블, 툴팁 및 기타 시각적 요소를 사용자의 요구에 맞게 조정할 수 있는 포괄적인 사용자 정의 옵션을 제공합니다. 🎨✨\n- 반응형 디자인: Ant Design Charts는 반응형을 고려하여 제작되어, 차트가 다양한 화면 크기와 장치에 맞게 잘 적응됩니다. 이는 다양한 플랫폼 간에 매끄럽게 작동하는 사용자 인터페이스를 만드는 데 중요합니다. 📱💻\n- 상호 작용 요소: 이 라이브러리는 줌, 이동, 가리기 등과 같은 상호 작용 기능을 지원하여 사용자 경험을 향상시키고 데이터를 보다 효과적으로 탐색하고 분석할 수 있게 합니다. 🔄🖱️\n- 통합 용이성: Ant Design Charts는 React 애플리케이션에 쉽게 통합할 수 있도록 설계되어, 개발 프로세스를 간소화하고 개발자의 학습 곡선을 줄입니다. ⚙️👩‍💻\n- 문서 및 커뮤니티 지원: 이 라이브러리는 포괄적인 문서와 활발한 커뮤니티의 혜택을 받아, 개발자들이 지원을 찾고 문제를 해결하며 모범 사례를 최신 상태로 유지하는 데 용이합니다. 📚👥\n\nhttps://ant-design-charts-next.antgroup.com/\n\n![Top 8 React Chart Libraries for Data Visualization in 2024](/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_8.png)\n\n## 읽어 주셔서 감사합니다 ❤️❤️","ogImage":{"url":"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png"},"coverImage":"/assets/img/2024-05-01-Top8ReactChartLibrariesforDataVisualizationin2024_0.png","tag":["Tech"],"readingTime":10},{"title":"React 테스팅 라이브러리들 정리","description":"","date":"2024-05-01 18:17","slug":"2024-05-01-ReactTestingLibraries","content":"\n\nReact에서의 테스트에는 두 가지 세계가 있어요: 하나는 UserEvent이고, 다른 하나는 FireEvent에요. 대다수의 사람들은 FireEvent에 대해 알고 있어요. 둘 다 기본적으로 리액트 테스트 라이브러리로, 프론트엔드 테스트를 작성하고 클릭 또는 입력란 작성과 같은 이벤트를 시뮬레이트할 수 있는 도구에요. 그래서 사용자가 수행했을 법한 작업을 시뮬레이트하며, 실제 사용자를 참여시키지 않고도 테스트를 작성하며 동시에 그 작업의 기능 또는 동작을 테스트하는 거예요.\n\n위에서 언급된 것들을 사용해야 하는 이유가 더 많지만, 원래 논의로 돌아와서 더 나은 것은 무엇일까요? 두 가지를 함께 검토하고 우리 도메인에 더 적절한 것은 무엇인지 결론 내보도록 하죠.\n\n두 방법 간의 차이를 이해하기 위해 작은 예시를 살펴보죠. 이 예시는 인사 상자 애플리케이션으로, 사용자가 이름을 입력하고 인사 버튼을 누르면 인사말이 표시되는 애플리케이션입니다.\n\n![ReactTestingLibraries_0.png](/assets/img/2024-05-01-ReactTestingLibraries_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 애플리케이션에 대한 테스트를 작성하는 방법을 생각해보세요. 가장 기본적이면서 명확한 테스트 중 하나는 \"사용자가 이름을 입력하고 인사 버튼을 클릭하면 인사말이 표시되어야 합니다.\" 입니다. 이 테스트를 작성해 보겠습니다. 하지만 그 전에 비슷한 기능을 가진 리액트 애플리케이션을 만드십시오.\n\n다음 주소에서 프로젝트를 복제하세요: https://github.com/Rajshree02/react-testing-library\n\n다음과 같은 라이브러리를 App.test.js 파일에 가져와 테스트를 수행하십시오.\n\n```js\nimport { fireEvent, render, screen } from \"@testing-library/react\";\nimport App from \"./App\";\nimport userEvent from \"@testing-library/user-event\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## FireEvent\n\n이 라이브러리는 DOM 이벤트를 발생시킵니다. DOM(Data Object Model)은 여러분이 아시다시피 언어와는 무관한 인터페이스로, 여러분의 프론트엔드 프레임워크와 라이브러리가 웹 페이지와 상호작용할 수 있도록 도와줍니다. 따라서, FireEvent를 사용할 때는 기본적으로 DOM과 밀접하게 작업하게 되며, 때로는 이 FireEvent가 그 DOM에 대한 래퍼로 간주되기도 합니다.\n\n아래는 FireEvent를 사용하여 우리의 환영 메시지 애플리케이션을 테스트하는 코드 조각입니다.\n\n```js\ntest(\"버튼 클릭 시 환영 메시지가 나타나야 합니다\", () =\u003e {\n  const window = render(\u003cApp /\u003e);\n  const inputBox = window.getByLabelText(\"당신의 이름을 입력하세요\");\n\n  fireEvent.change(inputBox, { target: { value: \"John\" } });\n  expect(inputBox).toHaveValue(\"John\");\n  const button = screen.getByRole(\"button\");\n  fireEvent.click(button);\n  const actualGreet = window.getByText(\"안녕하세요 John !!\");\n\n  expect(actualGreet).toBeInTheDocument();\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기서 생기는 질문은 진짜 중요한가? 그리고 그럴 때 또 다른 옵션이 있습니다.\n\n## UserEvent\n\n위의 질문에 대답하면, 중요하다는 것입니다. 왜냐하면 마지막으로 이를 사용하는 것은 UI를 테스트하기 때문입니다. 그러니까, 특정 컴포넌트의 동작을 이해하고 싶다면, 이 옵션이 좋은 선택일 것입니다. 그러나 사용자의 작업을 시뮬레이트하고 작업과 관련된 기능을 테스트하려면 UserEvent를 사용하세요. 그러니까, 사용자가 애플리케이션과 상호 작용할 때, 화면이나 표시된 UI는 DOM이 아닙니다. 사용자가 상호 작용하거나 변경하는 화면이 브라우저에 의해 DOM에 반영되고 사용자가 DOM과 상호 작용할 때 발생하는 일련의 일들이 있습니다. 예를 들어, 사용자가 텍스트 상자에 입력하면 요소가 포커싱되어야 하고 키보드 및 입력 이벤트가 발생하며 선택 및 값이 타이핑하는 동안 조작됩니다. FireEvent의 경우, 이러한 단계들이 생략되어 개발자로 하여금 DOM의 어떤 요소에 대한 이벤트도 트리거할 수 있게 됩니다.\n\nUserEvent는 테스트를 작성하고 사용자가 시스템과 실제로 상호 작용하는 방식을 테스트할 수 있게 도와줍니다. 그래서 이것을 사용하면 사용자가 키보드를 사용하여 입력하는 동안 발생하는 일련의 단계를 테스트할 수 있습니다. 아래는 UserEvent를 사용하여 인사 애플리케이션을 테스트하는 코드 스니펫입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 두 가지를 조금 설명한 후에 애플리케이션에 맞는 것을 결정해보세요.","ogImage":{"url":"/assets/img/2024-05-01-ReactTestingLibraries_0.png"},"coverImage":"/assets/img/2024-05-01-ReactTestingLibraries_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 18에서 비즈니스 로직과 UI 컴포넌트를 분리하는 방법","description":"","date":"2024-05-01 18:15","slug":"2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18","content":"\n\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png)\n\n# 소개\n\nReact는 사용자 인터페이스를 만들기 위한 인기있는 JavaScript 라이브러리이며, 최근 버전에서 상당한 개선을 거쳤습니다. React 18을 통해 개발자들은 이제 비즈니스 로직을 UI 구성 요소에서 효과적으로 분리하는 더 강력한 도구를 갖게 되었습니다. 이 글에서는 비즈니스 로직과 UI 구성 요소를 분리하는 장점을 탐구하고, React 18의 새로운 기능을 사용하여 이를 어떻게 달성할 수 있는지 보여줄 것입니다.\n\n# 목차\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n- 비즈니스 로직 분리를 위한 React 18의 새로운 기능들\n- 비즈니스 로직 분리하기: 단계별 안내서\n- React 18에서 비즈니스 로직 분리를 위한 고급 기술\n- 결론\n- 참고 자료\n\n# 비즈니스 로직과 UI 구성 요소를 왜 분리해야 할까요?\n\n- 코드 재사용성: 비즈니스 로직이 분리되면 응용 프로그램의 다른 부분이나 다른 프로젝트에서도 쉽게 구성 요소를 재사용할 수 있습니다.\n- 테스트: 비즈니스 로직과 UI 구성 요소를 독립적으로 단위 테스트할 수 있으므로 테스트가 더 간단해집니다. 이는 테스트 범위와 전체 코드 품질을 향상시킵니다.\n- 가독성 및 유지보수성: 비즈니스 로직을 UI 구성 요소에서 분리하면 더 깨끗하고 유지보수가 쉬운 코드가 됩니다. 각 부분의 책임을 이해하기 쉬워집니다.\n- 확장성: 응용 프로그램이 성장함에 따라 관심을 분리하면 충돌 없이 개발자가 코드베이스의 다른 부분에 동시에 작업할 수 있습니다.\n\n# React 18의 비즈니스 로직 분리를 위한 새로운 기능들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 리액트 훅\n\n리액트 16.8에서 소개된 리액트 훅은 클래스 컴포넌트를 작성하지 않고도 상태 및 다른 리액트 기능을 사용할 수 있는 방법을 제공합니다. useState 및 useEffect와 같은 훅을 사용하면, 개발자는 비즈니스 로직을 캡슐화하고 컴포넌트 간에 재사용할 수 있습니다.\n\n## 동시 모드의 서스펜스\n\n리액트 18에서는 동시 모드와 서스펜스에서 개선 사항을 가져왔습니다. 동시 모드를 통해 리액트가 동시에 여러 작업을 처리하여 더 나은 성능을 제공합니다. 서스펜스는 선언적 데이터 가져오기와 코드 분할을 가능하게 하여 비동기 작업을 쉽게 다룰 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비즈니스 로직 분리하기: 단계별 안내\n\n## 단계 1: 비즈니스 로직 식별\n\n컴포넌트에서 데이터, 상태를 관리하거나 API 호출을 수행하는 작업과 관련된 부분을 식별합니다.\n\n## 단계 2: 커스텀 훅 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지정된 비즈니스 로직을 캡슐화하기 위해 사용자 정의 훅을 생성하세요. 사용자 정의 훅은 use로 시작하는 함수입니다. 내부적으로 다른 훅을 사용할 수 있습니다.\n\n코드 예시 (사용자 정의 훅):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() =\u003e {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다.\n    fetch('https://api.example.com/users')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e setUserData(data))\n      .catch((error) =\u003e console.error('데이터를 가져오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n```\n\n## 단계 3: 컴포넌트에서 사용자 정의 훅 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI 컴포넌트 내에서 비즈니스 로직과 데이터에 접근하기 위해 사용자 정의 후크를 활용하세요. 이렇게 하면 컴포넌트가 렌더링에 집중하고, 후크가 내부 로직을 처리합니다.\n\n코드 예시 (컴포넌트에서 사용자 정의 후크 사용):\n\n```js\n// UserList.js\nimport React from 'react';\nimport { useUserData } from './useUserData';\n\nfunction UserList() {\n  const userData = useUserData();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e사용자 목록\u003c/h1\u003e\n      \u003cul\u003e\n        {userData.map((user) =\u003e (\n          \u003cli key={user.id}\u003e{user.name}\u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n## 단계 4: Suspense를 사용한 코드 분할\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSuspense를 사용하면 비동기 데이터 가져오기나 계산이 많이 필요한 컴포넌트를 코드로 나누고 지연로드할 수 있어요. 이렇게 하면 관심사를 분리하고 애플리케이션의 성능을 향상시킬 수 있어요.\n\n코드 예시 (Suspense를 사용한 코드 분할):\n\n```js\n// App.js\nimport React, { Suspense } from 'react';\nconst UserList = React.lazy(() =\u003e import('./UserList'));\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e나의 앱\u003c/h1\u003e\n      \u003cSuspense fallback={\u003cdiv\u003e로딩 중...\u003c/div\u003e}\u003e\n        \u003cUserList /\u003e\n      \u003c/Suspense\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n# 리액트 18에서 비즈니스 로직 분리를 위한 고급 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 커스텀 훅 조합\n\n커스텀 훅의 강력한 측면 중 하나는 더 복잡한 로직을 만들기 위해 조합할 수 있다는 것입니다. 여러 커스텀 훅을 결합함으로써, 복잡한 비즈니스 로직을 구축하면서 UI 컴포넌트를 깔끔하고 집중적으로 유지할 수 있습니다.\n\n코드 예시 (커스텀 훅 조합):\n\n```js\n// useUserData.js\nimport { useState, useEffect } from 'react';\n\nexport function useUserData() {\n  const [userData, setUserData] = useState([]);\n\n  useEffect(() =\u003e {\n    // API에서 사용자 데이터를 가져와 상태를 업데이트합니다\n    fetch('https://api.example.com/users')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e setUserData(data))\n      .catch((error) =\u003e console.error('데이터를 불러오는 중 오류 발생:', error));\n  }, []);\n\n  return userData;\n}\n\n// useFilteredUserData.js\nimport { useUserData } from './useUserData';\n\nexport function useFilteredUserData(searchTerm) {\n  const userData = useUserData();\n\n  // 검색어를 기반으로 사용자 데이터 필터링\n  const filteredData = userData.filter((user) =\u003e\n    user.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  return filteredData;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`useFilteredUserData` 훅을 사용하면 검색어에 기반을 둔 필터링된 사용자 데이터를 가져올 수 있으며, `useUserData`에서 가져오는 로직을 재사용할 수 있습니다. 이 합성 접근 방식은 로직을 모듈식으로 유지하고 컴포넌트 간에 재사용할 수 있도록 합니다.\n\n## 2. 부수효과를 위한 커스텀 훅\n\n가끔 비즈니스 로직에는 데이터 가져오기 이상의 부수효과가 필요할 수 있습니다. 예를 들어 타이머 관리나 외부 API와의 상호작용과 같은 것들이 있습니다. 커스텀 훅은 이러한 부수효과를 캡슐화하여 컴포넌트 간에 일관되게 처리되도록 보장합니다.\n\n코드 예시 (타이머용 커스텀 훅):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// useTimer.js\nimport { useState, useEffect } from 'react';\n\nexport function useTimer(initialTime = 0) {\n  const [time, setTime] = useState(initialTime);\n\n  useEffect(() =\u003e {\n    const interval = setInterval(() =\u003e {\n      setTime((prevTime) =\u003e prevTime + 1);\n    }, 1000);\n\n    return () =\u003e clearInterval(interval);\n  }, []);\n\n  return time;\n}\n```\n\n이제 인터벌을 관리할 걱정 없이 타이머 기능을 모든 컴포넌트에 쉽게 통합할 수 있습니다.\n\n## 3. 전역 상태 관리를 위한 컨텍스트\n\n여러 컴포넌트 간에 공유해야 하는 상태 관리를 위해 React 18의 Context API를 활용할 수 있습니다. 비즈니스 로직에 대한 컨텍스트를 생성함으로써 어떤 컴포넌트에서든 해당 상태와 액션에 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예제 (상태 관리를 위해 컨텍스트 사용):\n\n```js\n// UserDataContext.js\nimport React, { createContext, useContext } from 'react';\nimport { useUserData } from './useUserData';\n\nconst UserDataContext = createContext();\n\nexport function UserDataProvider({ children }) {\n  const userData = useUserData();\n\n  return (\n    \u003cUserDataContext.Provider value={userData}\u003e\n      {children}\n    \u003c/UserDataContext.Provider\u003e\n  );\n}\n\nexport function useUserDataContext() {\n  return useContext(UserDataContext);\n}\n```\n\nUserDataContext와 useUserDataContext 훅을 사용하여 UserDataProvider 내의 모든 컴포넌트에서 프롭 전달 없이 사용자 데이터에 액세스할 수 있습니다.\n\n## 4. Cross-Cutting Concerns을 위한 Higher-Order Components (HOCs)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 컴포넌트에 특정 로직을 적용해야 하는 경우, 고차 컴포넌트(Higher-Order Components, HOCs)를 사용할 수 있어요. HOCs는 컴포넌트를 가져와서 추가 프롭이나 로직이 포함된 새로운 컴포넌트를 반환하는 함수들이에요.\n\n코드 예시 (스타일링을 위한 HOC):\n\n```js\n// withStyles.js\nimport React from 'react';\n\nfunction withStyles(WrappedComponent) {\n  return function WithStyles(props) {\n    return (\n      \u003cdiv style={{ color: 'blue' }}\u003e\n        \u003cWrappedComponent {...props} /\u003e\n      \u003c/div\u003e\n    );\n  };\n}\n\n// 사용 예시\nconst MyComponent = ({ name }) =\u003e \u003cdiv\u003eHello, {name}!\u003c/div\u003e;\nconst StyledComponent = withStyles(MyComponent);\n```\n\n이제 StyledComponent는 MyComponent에 정의된 스타일들을 자동으로 적용해요. 여러 곳에서 스타일 선언을 반복할 필요가 없어졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nReact 18의 새로운 기능을 활용하여 사용자 정의 훅, Suspense 및 Context API를 포함한 고급 기술을 효과적으로 구현할 수 있습니다. 이를 통해 비즈니스 로직과 UI 구성 요소를 보다 효과적으로 분리할 수 있습니다. 사용자 정의 훅 조합, 부작용 처리, 전역 상태 관리를 위한 Context API, 그리고 고차 컴포넌트를 활용하여 개발자는 모듈화되고 유지보수가 용이한 React 애플리케이션을 만들 수 있습니다.\n\n이러한 기술을 적용함으로써 개발자는 코드 구성을 개선하고 성능을 향상시키면서 더욱 확장 가능하고 유지보수가 쉬운 애플리케이션을 구축할 수 있습니다.\n\n# 참고 문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- React 문서\n- React에서 Hooks 소개\n- React 18 알파 - 동시 모드\n- 상태 Hook 사용하기\n- 데이터 가져오기용 서스펜스\n- React 커스텀 훅 - 구성\n- React 컨텍스트\n- React 고차 컴포넌트\n\n이러한 참고 자료는 React 18의 새로운 기능과 비즈니스 로직을 UI 컴포넌트에서 분리하기 위한 모베스트 프랙티스에 대한 심도 있는 정보를 제공합니다.\n\n![이미지](/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_1.png)\n\n이 글이 도움이 되셨나요? 좋아요나 코멘트를 남겨주세요. 고맙습니다 🙏.","ogImage":{"url":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png"},"coverImage":"/assets/img/2024-05-01-SeparatingBusinessLogicfromUIComponentsinReact18_0.png","tag":["Tech"],"readingTime":8},{"title":"React Native 앱 디버깅하는 방법","description":"","date":"2024-05-01 18:14","slug":"2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-ReactNativeAppsDebuggingTopToolsandStrategies_0.png\" /\u003e\n\n리액트 네이티브 앱을 디버깅하는 것은 도전일 수 있어요! 제게 (그리고 많은 개발자들에게) 도움이 된 몇 가지 필수 도구와 전략이 있답니다:\n\n## 도구:\n\n- React Native Debugger: 필수품! 디버거, 콘솔, 요소 검사기를 비롯한 종합적인 디버깅 환경을 제공해줘요.\n- Chrome DevTools: Chrome DevTools 디버거를 사용하여 코드를 디버깅하고 중지점을 설정하고 변수를 검사할 수 있어요.\n- Console.log(): 간단하지만 효과적이에요. console.log()를 사용하여 변수, 함수, 오류를 콘솔에 출력해주세요.\n- React Native CLI: React Native CLI를 사용하여 앱을 실행할 때 — debug 플래그를 사용하여 디버깅 기능을 활성화할 수 있어요.\n- Flipper: React Native를 위한 인기 있는 디버깅 도구로, 디버거, 콘솔 등을 제공해줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전략:\n\n- 분할 정복: 문제를 격리하기 위해 코드를 주석 처리하고 작은 구성 요소를 테스트하며 문제를 추적하기 위해 console.log()을 사용합니다.\n- 콘솔 확인: 정기적으로 콘솔을 확인하여 오류, 경고 및 로그를 확인하여 문제를 식별합니다.\n- 디버거 사용: 중단점을 설정하여 코드를 따라가고 변수를 검사하여 흐름을 이해하고 문제를 식별합니다.\n- 구성 요소 검사: 요소 검사기를 사용하여 구성 요소 계층 구조, 속성 및 상태를 검사합니다.\n- 다른 기기에서 테스트: 여러 기기 및 시뮬레이터에서 테스트하여 문제가 특정 기기에 종속되지 않도록합니다.\n- 제3자 라이브러리 확인: 제3자 라이브러리가 최신 상태이며 올바르게 구성되어 있는지 확인합니다.\n- 온라인 검색: 유사한 문제, GitHub 문제 및 Stack Overflow 질문을 검색하여 솔루션을 찾습니다.\n\n# 성공 (그리고 실패!):\n\n- 성공: React Native Debugger를 사용하여 제3자 라이브러리와 관련된 까다로운 문제를 식별했습니다.\n- 실패: 몇 시간 동안 디버깅을 한 후에야 단순한 오타였음을 깨달았습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 여러분들의 차례입니다! 좋아하는 디버깅 도구와 전략을 공유해 주세요. 함께 서로의 경험을 나누며 배워봐요!","ogImage":{"url":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png"},"coverImage":"/assets/img/2024-05-01-DebuggingReactNativeAppsTopToolsandStrategies_0.png","tag":["Tech"],"readingTime":2},{"title":"대기업에서 React 상태 관리를 하는 방법,(Zustand와 React Query)","description":"","date":"2024-05-01 18:13","slug":"2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png\" /\u003e\n\n리액트 애플리케이션에서 상태를 관리하는 것은 복잡하고 시간이 많이 소모되는 작업일 수 있습니다. 애플리케이션이 커지고 복잡해지면 상태를 확장 가능하고 유지 보수 가능한 방식으로 관리하기가 점점 어려워집니다. 다행히 React용으로 제공되는 가벼운 강력한 상태 관리 라이브러리가 여러 개 있습니다. 이 글에서는 이 중 두 개의 라이브러리인 Zustand와 React Query를 살펴보고, React 애플리케이션에서 상태를 관리하는 견고하고 유연한 솔루션을 제공하는 방법을 보여줄 것입니다.\n\n# Zustand란 무엇인가요?\n\nZustand는 함수형 프로그래밍 개념을 사용하여 상태를 정의하고 관리하는 React용 가벼운 상태 관리 라이브러리입니다. Redux와 달리 Zustand는 전역 저장소나 복잡한 액션 및 리듀서 집합에 의존하지 않습니다. 대신, Zustand를 사용하면 간단한 자바스크립트 객체와 함수를 사용하여 상태를 정의할 수 있습니다. 이를 통해 더 복잡한 상태 관리 솔루션의 부하 없이 상태를 확장 가능하고 유지 보수 가능한 방식으로 정의하고 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand은 상태에 액세스하고 업데이트 기능을 제공하는 사용자 정의 React 훅을 생성하여 작동합니다. 이 훅은 응용 프로그램 어디에서나 상태에 액세스하고 업데이트할 수 있습니다. Zustand는 상태를 정의하고 다양한 방법으로 조작하기 쉽게 하는 도우미 함수 및 유틸리티 세트를 제공합니다.\n\n# React Query란?\n\nReact Query는 React용 강력하고 유연한 데이터 검색 및 캐싱 라이브러리입니다. REST API, GraphQL API 등 다양한 소스에서 데이터를 가져오는 간단하고 선언적인 API를 제공합니다. React Query는 또한 응용 프로그램에서 서버 상태를 관리하는 데 사용할 수 있는 강력한 캐싱 레이어를 제공합니다.\n\nReact Query의 주요 이점 중 하나는 그 유연성입니다. 자동 재시도, 백그라운드 다시 가져오기 등을 지원하는 데이터 검색 및 캐싱을 구성하는 다양한 옵션을 제공합니다. 이를 통해 사용자 지정 로직이나 보일러플레이트 없이도 응용 프로그램에서 다양한 데이터 검색 및 캐싱 시나리오를 쉽게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Zustand과 React Query 함께 사용하기\n\nZustand과 React Query는 각각 강력한 상태 관리 라이브러리입니다. 하지만 두 라이브러리를 함께 사용하면 더욱 강력한 기능을 발휘할 수 있습니다. 두 라이브러리를 결합하여 React 애플리케이션에서 상태를 효과적으로 관리하는 견고하고 유연한 솔루션을 만들 수 있습니다.\n\n전반적으로 접근 방식은 간단합니다. Zustand를 사용하여 애플리케이션의 로컬 상태를 관리하고, React Query를 사용하여 서버 상태를 관리합니다. Zustand는 함수형 프로그래밍 개념을 활용하여 간단하고 유연하게 로컬 상태를 정의하고 관리할 수 있는 방법을 제공하는 반면, React Query는 선언적 API를 활용하여 강력하고 유연하게 서버 상태를 관리할 수 있습니다.\n\n실제로 이를 구현하는 방법을 좀 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Zustand을 사용하여 상태 정의하기\n\nZustand와 React Query를 함께 사용하는 첫 번째 단계는 Zustand를 사용하여 애플리케이션의 상태를 정의하는 것입니다. 이 과정은 상태를 정의하고 업데이트 함수 집합을 제공하는 사용자 정의 훅을 생성하는 것을 포함합니다.\n\n다음은 이 과정이 어떻게 보일 수 있는지 예시입니다:\n\n![예시](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 Zustand를 사용하여 상태를 관리하는 간단한 카운터를 정의하고 있습니다. useStore 훅은 count 속성과 상태를 업데이트하는 데 사용할 수 있는 increment 및 decrement 함수를 포함하는 객체를 반환합니다.\n\n# Zustand과 React Query를 함께 사용하는 방법\n\n이제 Zustand와 React Query를 함께 사용하는 장점을 이해했으니, Zustand를 활용한 애플리케이션에서 React Query를 구현하는 방법을 살펴보겠습니다.\n\n- React Query 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 React Query와 그 종속성들을 설치해야 합니다. 터미널을 열고 프로젝트 디렉토리로 이동하세요.\n\n다음 명령어를 실행하세요:\nnpm install react-query\n\n2. React Query 공급자 설정\n\nReact Query를 사용하려면 QueryClientProvider 컴포넌트로 애플리케이션을 감싸야 합니다. 이 컴포넌트는 React Query가 제대로 작동할 수 있도록 필요한 컨텍스트를 제공합니다. 루트 컴포넌트 파일에서 필요한 종속성을 import하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_2.png)\n\n여기서는 QueryClient의 새 인스턴스를 생성하고 queryClient를 속성으로 전달하여 전체 애플리케이션을 QueryClientProvider 내에 래핑합니다.\n\n3. React Query를 사용하여 데이터 가져오기\n\nReact Query는 데이터를 가져오기 위한 간단하고 선언적인 API를 제공합니다. React Query를 사용하여 API 엔드포인트에서 데이터를 가져오는 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_3.png)\n\n이 예시에서는 React Query의 useQuery 훅을 사용하여 /api/users 엔드포인트에서 데이터를 가져오고 있습니다. useQuery의 첫 번째 인자는이 쿼리를 식별하는 고유한 키입니다. 두 번째 인자는 데이터를 가져오는 비동기 함수입니다. React Query는 캐싱, 백그라운드 재검색 및 오류 처리를 처리해줍니다.\n\nuseQuery 훅은 데이터, 로딩 상태 및 오류 여부 속성이 있는 객체를 반환합니다. 이러한 속성을 사용하여 데이터 가져오기 프로세스의 다른 상태를 처리할 수 있습니다.\n\n4. Zustand과 React Query를 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 결합하기 위해 React Query의 데이터를 Zustand 상태에 통합할 수 있습니다. Zustand를 사용하여 전역 상태를 관리하고 React Query를 사용하여 데이터를 가져오고 업데이트할 수 있습니다.\n\nReact Query 데이터를 Zustand에 통합하는 예시를 살펴봅시다:\n\n![image](/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_4.png)\n\n이 예시에서 useStore 훅을 사용하여 Zustand에서 users 상태를 정의합니다. 또한 상태를 업데이트하는 setUsers 함수를 정의합니다. UsersList 컴포넌트 내에서는 API 엔드포인트에서 데이터를 가져오기 위해 useQuery 훅을 사용합니다. 데이터를 가져올 때 setUsers 함수를 호출하여 가져온 데이터로 Zustand 상태를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 결합하여 전역 상태를 쉽게 관리할 수 있습니다. Zustand를 사용하면서 React Query의 강력한 데이터 가져오기 및 캐싱 기능을 활용할 수 있습니다.\n\n## Zustand과 React Query를 함께 사용하는 장점\n\n이전에 언급한대로, Zustand와 React Query는 React 애플리케이션용 강력한 상태 관리 라이브러리입니다. 함께 사용할 때는 Redux나 각각 사용하는 것보다 여러 장점을 제공합니다. 이러한 장점을 자세히 살펴보겠습니다.\n\n- 코드 간소화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZustand과 React Query를 함께 사용하는 가장 중요한 장점 중 하나는 코드를 간소화한다는 것입니다. Zustand는 응용 프로그램 상태를 관리하기 위한 간단한 API를 제공하며, React Query는 데이터 가져오기와 캐싱을 간단하게 만들어줍니다. 이 둘을 함께 사용하면 그렇지 않았다면 작성해야 했을 많은 뼈대 코드를 제거할 수 있습니다.\n예를 들어, Zustand를 사용하여 응용 프로그램의 전역 상태를 관리하고, 그런 다음 React Query를 사용하여 API에서 데이터를 가져올 수 있습니다. 이를 통해 데이터와 UI를 분리하여 코드를 더 모듈식으로 유지하고 이해하기 쉽게 만들 수 있습니다.\n\n2. 성능 향상\n\nReact Query의 캐싱 메커니즘은 응용 프로그램에 훌륭한 성능 향상을 제공합니다. 클라이언트 측에서 데이터를 캐시함으로써 응용 프로그램이 수행하는 네트워크 요청의 수를 줄일 수 있어 더 빠르고 반응성이 향상됩니다.\n\nZustand의 작은 크기와 간결함도 성능 향상에 기여합니다. Redux보다 훨씬 작기 때문에 로드하는 데 더 빠르고 응용 프로그램의 메모리 풋프린트를 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 쉬운 통합\n\nZustand와 React Query는 기존의 React 애플리케이션에 쉽게 통합할 수 있습니다. Zustand는 React의 훅과 잘 작동하는 간단한 API를 제공하여 구성 요소에 쉽게 통합할 수 있습니다. React Query도 통합하기 쉽고 데이터 가져오기 라이브러리와 함께 사용할 수 있어 유연하고 사용자 정의가 가능합니다.\n\n4. 확장성\n\nZustand의 간결함은 소규모에서 중규모 애플리케이션에 좋은 선택입니다. 그러나 React Query와 결합하면 대규모 복잡한 애플리케이션을 구축하는 강력한 도구가 됩니다. React Query의 캐싱 메커니즘과 다른 라이브러리와의 쉬운 통합은 애플리케이션의 확장에 좋은 선택입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\nZustand과 React Query는 함께 사용할 때 React 애플리케이션에서 상태를 관리하고 데이터를 가져오는 간단하고 확장 가능한 솔루션을 제공하는 강력한 상태 관리 라이브러리입니다. Zustand는 로컬 상태의 관리를 간소화하고, React Query는 서버 상태를 처리하고 성능있는 캐싱 레이어를 제공합니다.\n\nReact Query를 Zustand와 통합함으로써 React 애플리케이션에서 코드를 단순화하고 성능을 향상시키며 쉽게 통합하고 확장 가능성을 높일 수 있습니다. 작은 프로젝트나 대규모 애플리케이션을 구축하더라도 Zustand와 React Query는 상태 관리와 데이터 가져오기에 강력하고 유연한 솔루션을 제공합니다.\n\n다음 React 프로젝트에 Zustand와 React Query를 통합하여 상태 관리 작업에서 가져다 주는 효율성과 생산성을 경험해보세요.","ogImage":{"url":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png"},"coverImage":"/assets/img/2024-05-01-SuperchargeYourReactStateManagementlikeaSeniorDevUnlockingthePowerofZustandandReactQuery_0.png","tag":["Tech"],"readingTime":6},{"title":"JavaScript로 데스크탑에서 모바일 애플리케이션 만드는 방법","description":"","date":"2024-05-01 18:11","slug":"2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications","content":"\n\n웹 개발에 한정되어 있던 JavaScript가 이제는 브라우저 외의 다양한 응용 프로그램을 구동하는 데 확장되었습니다. 데스크톱 애플리케이션부터 모바일 앱까지, JavaScript는 유연성과 다양한 프레임워크 및 라이브러리 생태계 덕분에 만연한 언어가 되었습니다. 이 글에서는 JavaScript의 응용 분야, 데스크톱 및 모바일 개발을 위한 프레임워크, 그리고 그들을 마스터하기 위한 학습 프로그램에 대해 살펴보겠습니다.\n\n## JavaScript를 사용할 수 있는 곳\n\n- 웹 개발: JavaScript의 주요 용도는 여전히 웹 개발입니다. 이는 웹 페이지의 상호 작용성과 기능을 향상시켜 동적 콘텐츠, 양식 유효성 검사, 애니메이션 등을 가능하게 합니다.\n- 데스크톱 애플리케이션: Electron의 등장으로 JavaScript는 데스크톱 애플리케이션 개발에 진출했습니다. Electron을 통해 개발자는 HTML, CSS, JavaScript와 같은 웹 기술을 활용하여 크로스 플랫폼 데스크톱 앱을 구축할 수 있으며, 웹 개발 기술을 활용할 수 있습니다.\n- 모바일 애플리케이션: JavaScript는 점점 더 모바일 앱 개발에 활용되고 있으며, 주로 React Native 및 Progressive Web Apps (PWA)와 같은 프레임워크를 통해 구현됩니다. 이러한 프레임워크를 사용하면 JavaScript를 사용하여 모바일 앱을 개발할 수 있으며, 네이티브와 유사한 경험을 제공할 수 있습니다.\n- 서버 측 개발: Chrome의 V8 JavaScript 엔진 위에 구축된 Node.js는 JavaScript를 사용하여 서버 측 코드를 작성할 수 있도록 하는 JavaScript 런타임입니다. 비차단, 이벤트 주도 아키텍처로 인기를 얻은 Node.js는 확장 가능하고 실시간 애플리케이션을 구축하기에 적합합니다.\n\n![이미지](/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데스크톱 및 모바일 애플리케이션을 위한 프레임워크\n\nElectron: Electron은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 구축하기 위한 프레임워크입니다. 웹 콘텐츠를 독립적인 애플리케이션으로 패키징하여 네이티브와 유사한 경험을 제공하며, 다양한 플랫폼에 배포할 수 있습니다. 핵심 기능으로는 네이티브 운영 체제 API, 자동 업데이트 및 광범위한 커뮤니티 지원이 있습니다.\n\nReact Native: 페이스북에서 개발된 React Native은 JavaScript와 React를 사용하여 모바일 애플리케이션을 구축하는 인기 있는 프레임워크입니다. 개발자들은 코드를 한 번 작성하고 iOS 및 Android 플랫폼 모두에 배포할 수 있어 개발 시간과 노력을 줄일 수 있습니다. React Native은 네이티브 컴포넌트를 활용하여 고성능 및 네이티브와 유사한 앱을 제작할 수 있습니다.\n\nFlutter: JavaScript를 기반으로 하지는 않지만, Flutter는 모바일 앱 개발에서 두드러진 성과를 보여주기 때문에 언급할 가치가 있습니다. Google에서 개발된 Flutter는 Dart 프로그래밍 언어를 사용하며 React Native와 유사한 반응형 프레임워크를 제공합니다. 단일 코드베이스로 고품질 크로스 플랫폼 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자바스크립트 프레임워크를 마스터하기 위한 학습 프로그램\n\n자바스크립트의 기초: 자바스크립트 기본 지식을 토대로 시작해보세요. 문법, 데이터 유형, 함수, 비동기 프로그래밍 등을 포함한 기본 개념을 이해합니다.\n\n리액트로 웹 개발: 리액트는 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리로, 재사용 가능한 UI 구성 요소를 만드는 데 주로 초점을 맞춥니다. 핵심적으로, 리액트는 가상 DOM(문서 객체 모델)의 원리에 따라 작동하며 컴포넌트 기반 아키텍처를 따릅니다. 리액트는 UI를 재사용 가능한 구성 요소로 구성하며, 이는 사용자 인터페이스의 일부를 나타내는 작고 독립적인 코드 단위입니다. 컴포넌트는 서로 중첩시켜 복잡한 UI 구조를 만들 수 있습니다.\n\n리액트는 가상 DOM이라고 하는 가벼운 인메모리 DOM 표현을 유지합니다. 응용 프로그램의 상태나 데이터에 변경이 있을 때, 리액트는 실제 DOM을 직접 조작하는 대신 가상 DOM을 재 렌더링합니다. 리액트는 JSX를 도입했는데, 이는 자바스크립트를 위한 구문 확장으로, 개발자가 자바스크립트 내에서 HTML과 유사한 코드를 작성할 수 있게 합니다. JSX를 사용하면 UI 구성 요소의 구조와 동작을 선언적으로 정의하는 것이 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데스크톱 애플리케이션용 Electron: Electron.js 또는 간단히 Electron으로 불리는 Electron은 GitHub에서 개발된 오픈소스 프레임워크로, HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 만들 수 있습니다. 이를 통해 개발자들은 웹사이트를 구축하는 데 사용하는 동일한 기술을 사용하여 데스크톱 애플리케이션을 만들 수 있습니다. Electron은 HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 데스크톱 애플리케이션을 구축하는 프레임워크를 제공합니다. Windows, macOS, Linux 등 다양한 운영체제에서 실행할 수 있는 데스크톱 애플리케이션을 단일 코드베이스로 개발할 수 있도록 합니다. 개발 과정을 간소화하는 라이브러리, 도구, 리소스로 이루어진 풍부한 생태계가 있습니다. npm 패키지, 프레임워크, 플러그인 등을 활용하여 Electron 애플리케이션 기능을 확장할 수 있습니다.\n\nElectron은 크로스 플랫폼 데스크톱 애플리케이션을 구축하는 데 주로 사용됩니다. 생산성 도구, 통신 앱, 미디어 플레이어, 개발 도구 등 다양한 목적의 애플리케이션을 개발할 수 있습니다. Electron을 사용하면 웹 기반 사용자 인터페이스로 데스크톱 애플리케이션을 만들 수 있어 웹 개발자에게 익숙하고 빠른 개발이 가능합니다. Electron 애플리케이션은 다양한 웹 기술과 서드파티 라이브러리를 활용하여 사용자 정의 및 확장이 가능합니다. 개발자는 자신의 애플리케이션에 고유한 사용자 경험을 만들고 추가 기능을 통합할 수 있는 유연성을 갖습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 고급 주제\n- 상태 관리 라이브러리(Redux, MobX)와 같은 고급 주제에 대해 탐구해보세요. \n- 테스트, 성능 최적화, 그리고 데스크톱 및 모바일 애플리케이션의 배포 전략에 대한 학습도 이어지겠지요.\n\n### 크로스 플랫폼 개발을 위한 Flutter\n- 플러터(Flutter)는 풍부하고 반응형 사용자 인터페이스를 구축하기 위한 미리 디자인된 위젯 세트를 제공하는 포괄적인 UI 툴킷입니다.\n- Flutter는 텍스트, 버튼, 이미지, 레이아웃, 애니메이션 등 다양한 사용자 정의 가능한 위젯을 제공합니다.\n- Flutter를 사용하면 개발자들은 코드를 한 번 작성하고 iOS, Android, 웹, 데스크톱을 포함한 여러 플랫폼에 배포할 수 있습니다.\n- 이 접근 방식은 효율적인 크로스 플랫폼 개발을 가능케 하며, 개발 시간과 노력을 줄일 수 있습니다.\n\n### 실제 프로젝트\n- 개인적으로 또는 GitHub와 같은 온라인 플랫폼을 통해 실제 프로젝트에 참여하여 실무 경험을 쌓고 본인의 기술을 과시해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구조화된 공부 프로그램을 따라가면 JavaScript 기반 데스크톱 및 모바일 애플리케이션 개발을 위한 프레임워크와 도구를 점차 숙달할 수 있습니다. 소프트웨어 개발 분야에서 보람찬 경력을 쌓을 수 있도록 길을 열어줄 거에요.\n\n친구, 시간 내 주셔서 고마워요... 다음 기사에서 만나요 :)","ogImage":{"url":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png"},"coverImage":"/assets/img/2024-05-01-ExploringtheVersatilityofJavaScriptFromDesktoptoMobileApplications_0.png","tag":["Tech"],"readingTime":4},{"title":"Next.js에서 로컬 스토리지 사용하는 방법","description":"","date":"2024-05-01 18:10","slug":"2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png\" /\u003e\n\n로컬 스토리지는 웹 응용 프로그램이 사용자의 브라우저 내에서 데이터를 로컬로 저장할 수 있는 웹 스토리지 유형입니다. 이 웹 API를 사용하면 개발자가 브라우저의 메모리에 키-값 쌍을 저장할 수 있습니다. 이는 브라우저 세션 및 페이지 새로 고침 간에 데이터를 지속적으로 유지하거나 저장하는 데 사용할 수 있는 간단하면서도 강력한 도구입니다. 이는 사용자 환경 설정을 저장하거나 오프라인 환경을 만들거나 나중에 사용할 데이터를 저장하는 데 유용할 수 있습니다.\n\n이 글에서는 로컬 스토리지의 사용 사례와 Next.js 웹 응용 프로그램에서 로컬 스토리지를 사용하는 방법을 살펴보겠습니다.\n\n## 어디에서 로컬 스토리지를 사용할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 애플리케이션에서 사용할 수 있는 여러 시나리오가 있어요. \n\n- 사용자 설정 저장: 전자 상거래 애플리케이션에서는 사용자가 선호하는 통화를 로컬 스토리지에 저장하여 매번 웹 사이트를 방문할 때 해당 통화로 가격을 자동으로 표시할 수 있어요.\n- 임시 데이터 저장: 업무 관리 애플리케이션에서는 사용자가 '할 일' 목록에 추가한 작업을 아직 완료하지 않은 상태로 로컬 스토리지에 저장할 수 있어요. 그래서 브라우저를 닫거나 페이지를 이탈해도 진행 상황이 소멸되지 않아요.\n- 폼 데이터 저장: 구직 신청서에서는 사용자가 입력한 데이터를 나중에도 폼으로 돌아와서 진행 상황을 유지할 수 있도록 로컬 스토리지에 저장할 수 있어요.\n- 데이터 캐싱: 날씨 애플리케이션에서는 현재 날씨 상황을 로컬 스토리지에 저장하여 사용자가 오프라인일 때에도 접근할 수 있게 할 수 있어요.\n- 인증 정보 저장: 소셜 미디어 애플리케이션에서는 사용자의 인증 토큰을 로컬 스토리지에 저장하여 매번 애플리케이션을 열 때마다 로그인할 필요가 없게 할 수 있어요. (로컬 스토리지에 민감한 데이터를 암호화하지 않고 저장하는 것은 추천되지 않아요. 민감한 데이터 암호화를 다루는 방법을 알고 싶다면 이 기사를 참고해보세요.)\n\n## Local Storage 객체\n\n로컬 스토리지를 사용하기 위해서는 브라우저에서 제공하는 localStorage 객체를 사용할 수 있어요. 이 객체에는 로컬 스토리지와 상호작용하기 위한 여러 메소드가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메서드\n\n다음은 localStorage에서 사용할 수 있는 메서드입니다:\n\n- setItem(key, value): 이 메서드는 키-값 쌍을 로컬 스토리지에 추가하는 데 사용됩니다. 키는 문자열이며 값은 문자열 또는 JavaScript 객체가 될 수 있습니다. 이 값은 저장되기 전에 자동으로 문자열로 변환됩니다.\n\n```js\nlocalStorage.setItem('username', 'Anisha');\nlocalStorage.setItem('userId', '12345');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- getItem(key): 해당 메서드는 로컬 스토리지에서 키의 값을 검색하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 값을 문자열로 반환합니다.\n\n```js\nlocalStorage.getItem('username');\nlocalStorage.getItem('userId');\n```\n\n- removeItem(key): 해당 메서드는 로컬 스토리지에서 키-값 쌍을 제거하는 데 사용됩니다. 키를 매개변수로 받아 해당하는 키-값 쌍을 로컬 스토리지에서 제거합니다.\n\n```js\nlocalStorage.removeItem('username');\nlocalStorage.removeItem('userId');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- clear(): 이 메서드는 로컬 스토리지에서 모든 키-값 쌍을 제거하는 데 사용됩니다.\n\n```js\nlocalStorage.clear();\n```\n\n- key(index): 이 메서드는 로컬 스토리지에서 특정 인덱스에 있는 키-값 쌍의 키를 검색하는 데 사용됩니다. 인덱스를 매개변수로 받아 해당하는 키를 문자열 형식으로 반환합니다.\n\n```js\nconst key = localStorage.key(0); // 0번 인덱스의 키를 가져오기\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- length: 숫자 쌍의 개수를 반환하는 읽기 전용 속성입니다.\n\n```js\nconst numOfItemsInLocalStorage = localStorage.length()\n```\n\n## 로컬 저장소 구현 예시\n\n다음은 Next.js 애플리케이션에서 모든 localStorage 메서드를 사용하는 방법에 대한 완전한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 우리는 localStorage에 저장할 각 항목에 대한 상태를 만들고 키와 로컬 저장소의 항목 수에 대한 상태를 생성합니다.\n\n```js\nconst [username, setUsername] = useState\u003cstring | null\u003e(null);\nconst [userId, setUserId] = useState\u003cstring | null\u003e(null);\nconst [userData, setUserData] = useState\u003c{email: string, age: number} | null\u003e(null);\nconst [keys, setKeys] = useState\u003cstring[]\u003e([]);\nconst [length, setLength] = useState\u003cnumber\u003e(0);\n```\n\n이제 useEffect 훅을 사용하여 브라우저의 localStorage API의 사용 가능 여부를 확인하고, 컴포넌트가 처음으로 렌더링될 때 localStorage에 저장된 키-값 쌍의 값을 검색합니다.\n\n```js\nuseEffect(() =\u003e {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    let username = localStorage.getItem('username');\n    let userId = localStorage.getItem('userId');\n    let userData = JSON.parse(localStorage.getItem('userData'));\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}, []);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 handleSave, handleRemove, handleClear 세 가지 이벤트 핸들러를 사용해서 데이터를 저장, 삭제, 지우는 함수를 구현했어요.\n\nhandleSave 함수 안에서는 setItem 메서드를 사용하여 로컬 스토리지에 키-값 쌍을 저장해요. 그런 다음 getItem 메서드를 사용하여 그 값을 불러와 setUsername, setUserId, setUserData, setKeys, setLength를 사용해서 상태를 갱신합니다.\n\n```js\nfunction handleSave() {\n  if (typeof window !== \"undefined\" \u0026\u0026 window.localStorage) {\n    localStorage.setItem(\"username\", \"Anisha\");\n    localStorage.setItem(\"userId\", \"12345\");\n    localStorage.setItem(\"userData\", JSON.stringify({ email: \"anisha@example.com\", age: 25 }));\n\n    let username = localStorage.getItem(\"username\");\n    let userId = localStorage.getItem(\"userId\");\n    let userData = JSON.parse(localStorage.getItem(\"userData\")!);\n    let keys: string[] = [];\n    for (let i = 0; i \u003c localStorage.length; i++) {\n      keys.push(localStorage.key(i)!);\n    }\n\n    setUsername(username);\n    setUserId(userId);\n    setUserData(userData);\n    setKeys(keys);\n    setLength(localStorage.length);\n  }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhandleRemove 함수에서는 removeItem 메서드를 사용하여 로컬 저장소에서 `username` 키-값 쌍을 제거하고 setUsername을 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleRemove() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.removeItem('username');\n    setUsername(null);\n  }\n}\n```\n\nhandleClear 함수에서는 clear 메서드를 사용하여 로컬 저장소에서 모든 키-값 쌍을 제거하고 setUsername, setUserId, setUserData, setKeys, setLength를 사용하여 새 값으로 상태를 업데이트합니다.\n\n```js\nfunction handleClear() {\n  if (typeof window !== 'undefined' \u0026\u0026 window.localStorage) {\n    localStorage.clear();\n    setUsername(null);\n    setUserId(null);\n    setUserData(null);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 렌더 메서드에서는 localStorage에 저장된 키-값 쌍의 값을 표시하고 로컬 저장소와 상호 작용할 수 있는 버튼을 제공합니다.\n\n```js\n\u003cdiv\u003e\n  \u003cbutton onClick={handleSave}\u003elocalStorage에 저장\u003c/button\u003e\n  \u003cbutton onClick={handleRemove}\u003elocalStorage에서 제거\u003c/button\u003e\n  \u003cbutton onClick={handleClear}\u003elocalStorage 지우기\u003c/button\u003e\n  \u003cp\u003e사용자 이름: {username}\u003c/p\u003e\n  \u003cp\u003e사용자 ID: {userId}\u003c/p\u003e\n  \u003cp\u003e사용자 데이터: {JSON.stringify(userData)}\u003c/p\u003e\n  \u003cp\u003e키 목록: {keys.join(\", \")}\u003c/p\u003e\n  \u003cp\u003e로컬 저장소의 총 아이템 수: {length}\u003c/p\u003e\n\u003c/div\u003e\n```\n\n코드의 더 자세한 내용을 확인하고 싶다면, 내 GitHub 저장소를 자유롭게 확인해주세요.\n\n## 로컬 저장소 사용 시 보안 고려 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 스토리지를 사용하는 한 가지 단점은 그 안에 저장된 데이터가 일반 텍스트 형식이라는 것입니다. 이는 악성 스크립트에 의해 쉽게 액세스될 수 있다는 것을 의미합니다. 이는 공격자가 사용자의 장치에 액세스를 얻으면 로컬 스토리지에 저장된 데이터에 잠재적으로 액세스할 수 있다는 것을 의미합니다.\n\n다음은 Next.js 애플리케이션에서 민감한 데이터를 암호화하는 방법을 찾는 데 도움이 되는 이 기사의 제2부입니다. Next.js 앱의 로컬 스토리지에 민감한 데이터를 안전하게 보호하기","ogImage":{"url":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-01-UsingLocalStoragewithNextjsABeginnersGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서의 훅(Hooks)을 제대로 사용하는 방법","description":"","date":"2024-05-01 18:08","slug":"2024-05-01-HooksinReacts","content":"\n\n현대 웹 개발 분야에서는 React의 Hooks 도입이 개발자들이 사용자 인터페이스를 구축하는 방식에 상당한 변화를 가져왔어요. Hooks는 클래스를 작성하지 않고도 상태 및 기타 React 기능을 활용할 수 있게 해주는 함수들이에요. 이를 통해 개발 프로세스가 간소화되고 코드베이스를 더 잘 관리하고 가독성있게 만들 수 있어요. Hooks를 사용하면 useState를 활용하여 컴포넌트 상태를 쉽게 관리하고, useEffect로 부수 효과를 처리하며, useContext를 사용하여 컴포넌트 내에서 컨텍스트에 접근할 수 있어요.\n\n# useReducer\n\nuseReducer는 컴포넌트 내에서 복잡한 상태 로직을 관리하기 위해 사용되는 React 훅이에요. 특히 이전 상태에 따라 상태 전이가 발생하는 경우에 유용해요. 여기서 useReducer가 적용될 수 있는 몇 가지 다른 사용 사례들을 제공할게요.\n\n```js\nimport React, { useReducer } from \"react\";\nfunction reducer(state, action) {\nswitch (action.type) {\ncase \"LOGIN\":\nreturn { …state, user: action.payload.user, isLoggedIn: true };\ncase \"LOGOUT\":\nreturn { …state, user: null, isLoggedIn: false };\ndefault:\nreturn state;\n}\n}\nfunction Auth() {\nconst [state, dispatch] = useReducer(reducer, {\nuser: null,\nisLoggedIn: false,\n});\nconst handleLogin = () =\u003e {\n// 로그인 처리 로직\nconst fakeUser = { username: \"user\", email: \"user@example.com\" };\ndispatch({ type: \"LOGIN\", payload: { user: fakeUser } });\n};\nconst handleLogout = () =\u003e {\n// 로그아웃 처리 로직\ndispatch({ type: \"LOGOUT\" });\n};\nreturn (\n\u003cdiv\u003e\n{state.isLoggedIn ? (\n\u003cdiv\u003e\n\u003cp\u003e환영합니다, {state.user.username}님!\u003c/p\u003e\n\u003cbutton onClick={handleLogout}\u003e로그아웃\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cbutton onClick={handleLogin}\u003e로그인\u003c/button\u003e\n)}\n\u003c/div\u003e\n);\n}\nexport default Auth;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useContext\n\nuseContext은 함수형 컴포넌트 내에서 컨텍스트를 소비하는 데 사용되는 React 훅입니다. 이를 통해 React.createContext() 함수에 의해 생성된 컨텍스트 객체의 값을 액세스할 수 있습니다. useContext의 몇 가지 다른 사용 사례와 여러 값을 처리하는 방법에 대해 살펴보겠습니다:\n\n```js\nimport React, { createContext, useContext, useState } from 'react';\nconst UserContext = createContext();\nconst UserProvider = ({ children }) =\u003e {\nconst [user, setUser] = useState(null);\nconst login = (userData) =\u003e {\nsetUser(userData);\n};\nconst logout = () =\u003e {\nsetUser(null);\n};\nreturn (\n\u003cUserContext.Provider value={ user, login, logout }\u003e\n{children}\n\u003c/UserContext.Provider\u003e\n);\n};\nconst Profile = () =\u003e {\nconst { user, logout } = useContext(UserContext);\nreturn (\n\u003cdiv\u003e\n{user ? (\n\u003cdiv\u003e\n\u003cp\u003eWelcome, {user.name}!\u003c/p\u003e\n\u003cbutton onClick={logout}\u003eLogout\u003c/button\u003e\n\u003c/div\u003e\n) : (\n\u003cp\u003ePlease log in\u003c/p\u003e\n)}\n\u003c/div\u003e\n);\n};\nconst LoginForm = () =\u003e {\nconst { login } = useContext(UserContext);\nconst [username, setUsername] = useState('');\nconst [password, setPassword] = useState('');\nconst handleLogin = () =\u003e {\n// perform login logic\nconst userData = { name: username }; // Example data\nlogin(userData);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={username} onChange={(e) =\u003e setUsername(e.target.value)} /\u003e\n\u003cinput type=\"password\" value={password} onChange={(e) =\u003e setPassword(e.target.value)} /\u003e\n\u003cbutton onClick={handleLogin}\u003eLogin\u003c/button\u003e\n\u003c/div\u003e\n);\n};\nconst App = () =\u003e {\nreturn (\n\u003cUserProvider\u003e\n\u003cProfile /\u003e\n\u003cLoginForm /\u003e\n\u003c/UserProvider\u003e\n);\n};\nexport default App;\n```\n\n# useRef\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseRef은 주로 React 훅으로 사용되며, 다시 렌더링을 유발하지 않고 렌더링 간 지속되는 가변 값에 액세스하고 저장하는 데 주로 사용됩니다. 이는 DOM 요소에 액세스하거나 렌더링 간 값 추적 또는 가변 변수 저장에 흔히 사용됩니다. useRef의 다양한 사용 사례와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useRef } from \"react\";\nfunction MutableValues() {\nconst counterRef = useRef(0);\nconst incrementCounter = () =\u003e {\ncounterRef.current += 1;\nconsole.log('Current value of counter:', counterRef.current);\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={incrementCounter}\u003eIncrement Counter\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default MutableValues;\n```\n\n# useCallback\n\nuseCallback은 함수를 메모이제이션하는 데 사용되는 React 훅입니다. 자식 컴포넌트에 콜백을 전달할 때 불필요한 다시 렌더링을 방지하는 데 특히 유용합니다. useCallback의 다양한 사용 사례와 여러 값을 처리하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useCallback } from 'react';\nimport ChildComponent from './ChildComponent';\nfunction ParentComponent() {\nconst [count, setCount] = useState(0);\n// count를 의존성으로 갖는 메모이제이션된 콜백 함수\nconst handleClick = useCallback(() =\u003e {\nconsole.log('버튼이 클릭되었습니다! Count:', count);\n}, [count]);\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent onClick={handleClick} /\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e증가\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useMemo\n\nuseMemo는 비용이 많이 드는 계산을 메모이제이션하기 위해 사용되는 React 훅입니다. 값들의 불필요한 다시 계산을 피하고 성능을 최적화해야 하는 경우에 특히 유용합니다. useMemo의 다양한 사용 사례와 여러 값들을 다루는 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useMemo } from \"react\";\nfunction ProductList() {\nconst [products] = useState([\n{ id: 1, name: \"제품 1\", price: 10 },\n{ id: 2, name: \"제품 2\", price: 20 },\n{ id: 3, name: \"제품 3\", price: 30 },\n{ id: 4, name: \"제품 4\", price: 30 },\n{ id: 5, name: \"제품 5\", price: 30 },\n]);\nconst [selectedProducts, setSelectedProducts] = useState([]);\nconst handleToggleProduct = (productId) =\u003e {\nsetSelectedProducts((prevSelectedProducts) =\u003e {\nconst isSelected = prevSelectedProducts.includes(productId);\nif (isSelected) {\nreturn prevSelectedProducts.filter((id) =\u003e id !== productId);\n} else {\nreturn [...prevSelectedProducts, productId];\n}\n});\n};\n// 총 가격 메모이제이션된 계산\nconst totalPrice = useMemo(() =\u003e {\nconsole.log(\"총 가격 계산 중...\");\nreturn selectedProducts.reduce((total, productId) =\u003e {\nconst selectedProduct = products.find(\n(product) =\u003e product.id === productId\n);\nreturn total + (selectedProduct ? selectedProduct.price : 0);\n}, 0);\n}, [selectedProducts, products]);\nreturn (\n\u003cdiv\u003e\n\u003ch2\u003e제품 목록\u003c/h2\u003e\n\u003cul\u003e\n{products.map((product) =\u003e (\n\u003cli key={product.id}\u003e\n\u003clabel\u003e\n\u003cinput\ntype=\"checkbox\"\nchecked={selectedProducts.includes(product.id)}\nonChange={() =\u003e handleToggleProduct(product.id)}\n/\u003e\n{product.name} - ${product.price}\n\u003c/label\u003e\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003ch3\u003e총 가격: ${totalPrice}\u003c/h3\u003e\n\u003c/div\u003e\n);\n}\nexport default ProductList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useImperativeHandle\n\nuseImperativeHandle은 React 훅으로, React.forwardRef를 사용할 때 부모 컴포넌트가 자식 컴포넌트에 노출하는 인스턴스 값을 사용자 정의하는 데 사용됩니다. 부모 컴포넌트의 부모에게 액세스 가능한 함수 또는 값들을 정의하고, 직접 자식 컴포넌트에 노출되지 않도록 합니다. useImperativeHandle의 몇 가지 사용 사례 및 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useImperativeHandle, forwardRef } from 'react';\nconst ChildComponent = forwardRef((props, ref) =\u003e {\nconst [count, setCount] = useState(0);\nuseImperativeHandle(ref, () =\u003e ({\ngetCount: () =\u003e count\n}));\nreturn (\n\u003cdiv\u003e\n\u003cp\u003eCount: {count}\u003c/p\u003e\n\u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n\u003c/div\u003e\n);\n});\nfunction ParentComponent() {\nconst childRef = useRef(null);\nconst handleGetCount = () =\u003e {\nalert(`Count from child component: ${childRef.current.getCount()}`);\n};\nreturn (\n\u003cdiv\u003e\n\u003cChildComponent ref={childRef} /\u003e\n\u003cbutton onClick={handleGetCount}\u003eGet Count from Child\u003c/button\u003e\n\u003c/div\u003e\n);\n}\nexport default ParentComponent;\n```\n\n# useLayoutEffect\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nuseLayoutEffect은 useEffect와 유사한 React 훅이지만, 모든 DOM 변이 후 동기적으로 실행됩니다. 브라우저가 화면을 그리기 전에 반드시 DOM 명령을 실행하거나 DOM에서 레이아웃 정보를 읽어야 하는 경우에 유용합니다. useLayoutEffect의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useLayoutEffect, useRef } from 'react';\nfunction ComponentWithLayoutEffect() {\nconst [dimensions, setDimensions] = useState({ width: 0, height: 0 });\nconst elementRef = useRef(null);\nuseLayoutEffect(() =\u003e {\nconst { current: element } = elementRef;\nif (!element) return;\nconst { width, height } = element.getBoundingClientRect();\nsetDimensions({ width, height });\n}, [elementRef]);\nreturn (\n\u003cdiv ref={elementRef}\u003e\n\u003cp\u003eWidth: {dimensions.width}px\u003c/p\u003e\n\u003cp\u003eHeight: {dimensions.height}px\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default ComponentWithLayoutEffect;\n```\n\n# useDeferredValue\n\nuseDeferredValue는 React 18에서 도입된 React 훅으로, 일정 시간이 지난 후 컴포넌트 내의 값을 업데이트를 지연시킵니다. 부드러운 사용자 상호작용을 우선시하거나 빠른 상태 변경으로 인한 불필요한 다시 렌더링을 줄이는 경우에 유용합니다. useDeferredValue의 몇 가지 사용 사례와 다중 값 처리 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useDeferredValue } from 'react';\nfunction TextInput() {\nconst [text, setText] = useState('');\nconst deferredText = useDeferredValue(text, { timeoutMs: 1000 });\nconst handleChange = (e) =\u003e {\nsetText(e.target.value);\n};\nreturn (\n\u003cdiv\u003e\n\u003cinput type=\"text\" value={text} onChange={handleChange} /\u003e\n\u003cp\u003eDeferred Value: {deferredText}\u003c/p\u003e\n\u003c/div\u003e\n);\n}\nexport default TextInput;\n```\n\n# useTransition\n\nuseTransition은 React 18에서 도입된 React 훅입니다. 애플리케이션에서 애니메이션과 업데이트를 조정할 수 있게 해줍니다. 특히 원활한 전환을 통해 특정 작업을 수행하고 싶을 때 유용합니다. useTransition의 몇 가지 유즈 케이스와 여러 값 처리 방법은 다음과 같습니다:\n\n```js\nimport React, { useState, useTransition } from \"react\";\nfunction AnimatedList() {\nconst [items, setItems] = useState([]);\nconst [isPending, startTransition] = useTransition({ timeoutMs: 300 });\nconst addItem = () =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e […prevItems, Date.now()]);\n});\n};\nconst removeItem = (timestamp) =\u003e {\nstartTransition(() =\u003e {\nsetItems((prevItems) =\u003e prevItems.filter((item) =\u003e item !== timestamp));\n});\n};\nreturn (\n\u003cdiv\u003e\n\u003cbutton onClick={addItem}\u003eAdd Item\u003c/button\u003e\n{isPending \u0026\u0026 \u003cp\u003eLoading…\u003c/p\u003e}\n\u003cul\u003e\n{items.map((item) =\u003e (\n\u003cli key={item}\u003e\n\u003cbutton onClick={() =\u003e removeItem(item)}\u003eRemove\u003c/button\u003e\nItem {item}\n\u003c/li\u003e\n))}\n\u003c/ul\u003e\n\u003c/div\u003e\n);\n}\nexport default AnimatedList;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useId\n\nuseId은 내장된 React 훅이 아닙니다. 하지만 React 컴포넌트 내에서 고유한 식별자를 생성하는 데 사용되는 사용자 정의 훅 또는 유틸리티 함수로 종종 구현됩니다. 이러한 식별자는 목록 항목에 고유한 키 속성을 설정하거나 고유한 HTML id 속성을 생성하거나 양식 입력란과 라벨을 연결하는 등 다양한 목적으로 유용합니다. useId의 몇 가지 사용 사례와 여러 값을 처리하는 방법에 대해 설명합니다:\n\n```js\nimport React from 'react';\nfunction List({ items }) {\n  return (\n    \u003cul\u003e\n      {items.map(item =\u003e (\n        \u003cli key={useId()}\u003e{item}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\nexport default List;\n```","ogImage":{"url":"/assets/img/2024-05-01-HooksinReacts_0.png"},"coverImage":"/assets/img/2024-05-01-HooksinReacts_0.png","tag":["Tech"],"readingTime":10},{"title":"Next.js를 위한 실제 API 미들웨어 작성 방법","description":"","date":"2024-05-01 18:07","slug":"2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png\" /\u003e\n\n어플리케이션을 위한 웹 클라이언트나 특정한 종류의 컨셉 프로젝트를 구현해야 할 때 저는 본능적으로 Next.js를 선택합니다. 몇 년 전, 제가 구현해야 했던 어플리케이션은 Next.js 버전 12가 나온 시기에 맞춰 만들어졌었는데, 이 때 공개된 많은 새로운 기능들에 대해 듣게 되어 흥분했습니다. 그 중에서도 API Middleware의 출시는 저에게 가장 흥미로운 기능 중 하나였습니다.\n\n하지만 이 흥분은 잠시 지속되었습니다. 그들의 구현은 이름은 같고 개념적으로 유사하지만, 이전에 있던 것을 재탄생시킨 느낌이었고, 결과적으로 베이스림에 담긴 벽돌 같은 느낌을 주었습니다.\n\n# Middleware가 어떤 문제를 해결하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNext.js API routes는 정말 편리한 방법 중 하나로, 클라이언트에 API를 추가할 수 있습니다. 해야 할 일은 api 디렉토리 내에 새 파일을 만들고 함수를 작성하는 것 뿐입니다.\n\n```js\nexport default function handler(req, res) {\n  res.status(200).json({ name: 'John Doe' })\n}\n```\n\n시작하기에는 이 간단함이 좋지만, 복잡성을 구현 수준으로 미루는 결과가 될 수 있습니다.\n\n예를 들어, 구현에서 요청 유형 분기 처리를 처리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport default function handler(req, res) {\n  if (req.method === 'POST') {\n    // POST 요청 처리\n  } else {\n    // 다른 모든 HTTP 메소드 처리\n  }\n}\n```\n\n이제 사용자가 인증되었는지 확인하고 싶다면 어떻게 해야 할까요? 해당 내용은 라우트 핸들러 내에서 처리해야 합니다.\n\n```js\nexport default function handler(req, res) {\n  if (!isAuthenticated(req)) {\n    res.status(401).send(\"권한이 없습니다\")\n  }\n  // 구현\n}\n```\n\n이러한 방식으로 계속 하다 보면, 핸들러 구현 앞에 조건들이 계속 쌓이는 것을 알게 되고, 더 나쁜 일로, 핸들러 간에 많은 복사 및 붙여넣기 작업이 필요합니다. 이는 완전히 혼란스러워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보통 이 문제는 어떻게 해결하나요?\n\n이 문제는 Express와 같은 프레임워크를 사용하여 매우 우아하게 해결됩니다. \n\n우리의 코드는 아래와 같이 보일 수 있어요:\n\n```js\napp.post(\n  '/hello',\n  requireAuth,\n  validatePayload,\n  doUsefulStuff,\n  respond,\n);\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 구현된 다음 인터페이스를 준수하는 한 재사용 가능한 여러 함수를 서로 쌓을 수 있게 해줍니다:\n\n- 함수는 next라는 매개변수를 가져야 하며, 이 매개변수는 함수여야 합니다.\n- 사용자 정의 로직이 실행된 후, 체인 내의 다음 함수로 이동하려면 next()를 호출하거나 즉시 요청에 응답해야 합니다.\n\n```js\nfunction myMiddleware(req, res, next) {\n  // 일부 검사 수행\n  next()\n}\n```\n\n이제 이러한 미들웨어를 목록에 추가하여 활성화하거나 제거하거나 주석 처리하여 비활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문법은 매우 명확하며 코드를 재사용할 수 있어요.\n\n# Next.js에서 미들웨어 문제를 어떻게 해결하나요?\n\nNext.js 문서를 보면 middleware.js 파일을 생성하고 미들웨어를 구현하라고 합니다. 이 부분이 조금 마음에 들지 않지만 계속해 봅시다.\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  return response\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어를 구현한 후에는 Next.js에 해당 미들웨어가 실행되어야 하는 위치를 알려주는 구성 객체를 내보내야 합니다.\n\n```js\n// 미들웨어.js\n\nexport const config = {\n  matcher: '/api/:여러분의-엔드포인트-여기에*'\n}\n```\n\n이 구성 객체에서는 정규 표현식을 지원하는 매처를 지정할 수 있습니다.\n\n만족스럽지 않다면, 미들웨어 선언 내에서 조건문을 활용하여 사용자 정의 로직을 적용해볼 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// middleware.js\n\nexport function middleware(request) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    return NextResponse.rewrite(new URL('/about-2', request.url))\n  }\n \n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\n  }\n}\n```\n\n여기서 약간의 점들이 왜 저는 이 방식을 좋아하지 않는지에 대해 이야기해 드리겠습니다:\n\n- 미들웨어 구현이 담긴 전용 middleware.js 파일이 있으면 조잡하게 느껴집니다. 라우트가 정의된 곳에 내 미들웨어를 두고 싶어요.\n- 설정과 매처 접근 방식은 정말로 필요 없어보입니다. 왜 내 미들웨어를 실행하려면 매처와 정규식을 작성해야 하는 건가요? 이미 디렉토리 구조로 라우트를 설정했는데 (제가 처음에 Next.js를 선택한 가장 큰 이유가 이것인데) 이제 다른 연관성 없는 곳으로 가서 매처나 조건문을 작성해야 한다니요.\n\n몇 가지 상황에서는 이러한 방식이 실용적일 수 있는데, 예를 들어 애플리케이션 수준에서 모든 요청에 대해 실행되는 미들웨어를 사용하는 경우 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말씀하신 대로, 이 기능의 디자인은 별로 마음에 들지 않아요. 미들웨어를 정의하고 라우트를 정의하는 곳과 같이 깔끔하게 쌓아 나열하고 유지 관리하기 쉽게 만들고 싶어요.\n\n# API 라우트를 위한 사용자 정의 미들웨어\n\n최근 Next.js에서 라우트 핸들러를 출시했지만, 대부분의 사람들(포함해서 저도)은 여전히 대부분의 프로젝트에서 API 라우트를 사용하고 있기 때문에, 먼저 API 라우트의 구현 방법에 대해 다루겠습니다.\n\n소스 코드는 GitHub에서 사용 가능하며, 아래 예시에서는 간단한 JavaScript를 사용하겠습니다. 이는 의사코드와 유사하지만 여전히 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 루트가 작동하는 방식을 설명한 것입니다.\n\n```js\n// src/pages/api/hello.js\n\nconst middleware_1 = async (req, res, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\nconst middleware_2 = async (req, res, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\nconst middleware_3 = async (req, res, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\nconst middleware_4 = async (req, res, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\nconst hello = async (req, res) =\u003e {\n  res.status(200).json({ message: 'Hello World.' })\n};\nexport default handler(\n  middleware_1,\n  middleware_2,\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n언제든지 미들웨어 체인 중간에서 next() 함수 대신 res 객체를 사용하여 응답할 수 있어야하며, 그때 체인이 실행이 중단됩니다. 또한 미들웨어는 다른 곳에서 선언되어 재사용 가능하도록 작성되고 루트로 가져와야 합니다.\n\n이러한 기능을 구현하기 위해 할 일은 여기서 호출하고 있는 handler 함수를 구현하는 것뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 예시 구현을 확인할 수 있고, 소스 코드는 여기서 찾을 수 있습니다.\n\n```js\n// src/pages/middleware/handler.js\n\nconst execMiddleware = async (\n  req,\n  res,\n  middleware,\n  index = 0,\n) =\u003e {\n  if (res.headersSent || !middleware[index]) return\n  if (typeof middleware[index] !== 'function') {\n    res.status(500).end('Middleware must be a function!')\n    throw new Error('Middleware must be a function!')\n  }\n  await middleware[index](req, res, async () =\u003e {\n    await execMiddleware(req, res, middleware, index + 1)\n  })\n}\n\nexport const handler =\n  (...middleware) =\u003e\n  async (req, res) =\u003e {\n    await execMiddleware(req, res, middleware)\n  }\n```\n\n추가적으로, 여기에서 사용할 수 있는 allowMethods 미들웨어가 포함되어 있어요. 라우트에서 다음과 같이 사용할 수 있습니다:\n\n```js\n// src/pages/api/hello.js\n\nexport default handler(\n  allowMethods(['GET', 'PUT']),\n  hello,\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라우트 핸들러를 위한 사용자 지정 미들웨어\n\n라우트 핸들러는 Next.js에서 최신 API 구현 접근 방식이며, 앞으로 채택할 것을 권장합니다.\n\n한편으로는 HTTP 메소드(GET, POST, PUT 등)별로 명명된 내보내기가 필요하게 되어 좋아하지만, 핸들러 내에서 명시적으로 응답 값을 반환해야 하는 변경 사항에는 큰 부담을 느낍니다.\n\n위와 마찬가지로 소스 코드는 GitHub에서 확인할 수 있으며, 우리가 구현하고 있는 기능을 설명하기 위해 간단한 JavaScript를 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드는 우리가 원하는 라우트 작업 방식을 보여줍니다.\n\n```js\n// src/app/api/hello/route.js\n\nconst middleware_1 = async (req, next) =\u003e {\n  console.log('Running middleware 1')\n  next()\n};\n\nconst middleware_2 = async (req, next) =\u003e {\n  console.log('Running middleware 2')\n  next()\n};\n\nconst middleware_3 = async (req, next) =\u003e {\n  console.log('Running middleware 3')\n  next()\n};\n\nconst middleware_4 = async (req, next) =\u003e {\n  console.log('Running middleware 4')\n  next()\n};\n\nconst hello = async (req) =\u003e {\n  return NextResponse.json({ data: 'Hello World' })\n};\n\nexport const GET = handler(\n  middleware_1,\n  middleware_2,\n  hello,\n);\n\nexport const POST = handler(\n  middleware_3,\n  middleware_4,\n  hello,\n);\n```\n\n한 번 더 강조하지만, 미들웨어 체인에서 언제든지 응답을 반환하여 next() 함수를 호출하는 대신 응답을 반환할 수 있으며, 체인이 실행을 중지합니다.\n\n아래는 handler 함수의 예시 구현입니다. 소스 코드는 여기에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/app/middleware/handler.js\n\nexport const handler =\n  (...middleware) =\u003e\n  async (request) =\u003e {\n    let result\n    for (let i = 0; i \u003c middleware.length; i++) {\n      let nextInvoked = false\n      const next = async () =\u003e {\n        nextInvoked = true\n      };\n      result = await middleware[i](request, next);\n      if (!nextInvoked) {\n        break\n      }\n    }\n    if (result) return result\n    throw new Error('핸들러 또는 미들웨어가 NextResponse를 반환해야 합니다!')\n  }\n```\n\n# 결론\n\n당연히 취향의 문제일 수 있지만, 우리는 50줄 이하의 코드로 Next.js에 우리의 미들웨어 구현을 성공적으로 적용했고, 이것은 내 기준에서 이긴 것입니다.\n\nNext.js가 가는 방향에 대해서는, 우리가 그냥 우회로에 들어간 것이고 곧 간단하고 깨끗하며 쉬운 개발자 경험으로 돌아갈 것을 손가락을 꼬집었어요. 몇 년 전에 그들의 개발 경험이 얼마나 부드러운지 보았을 때 반해버렸으며, 아직 희망을 버리지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미들웨어 패턴에 대해서는 어떤 프로젝트에든 자유롭게 코드를 활용하셔도 괜찮아요. 이는 로직을 세분화하여 작은 조각으로 쌓는 훌륭한 방법입니다.\n\n호기심을 잃지 말고, 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png"},"coverImage":"/assets/img/2024-05-01-HowtoWriteActualAPIMiddlewareforNextjs_0.png","tag":["Tech"],"readingTime":8},{"title":"Vue3 + Vite 컴포넌트화 하는 방법","description":"","date":"2024-05-01 18:06","slug":"2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas","content":"\n\n# Vue3 + rspack 003: 컴포넌트화의 기술 (Composition API) 및 일반적인 문제 해결 아이디어\n\nVue 3에서 Composition API는 컴포넌트와 로직을 재사용하는 새로운 방법을 제공합니다. 이는 우리의 코드에 더 나은 구성 구조를 제공할 뿐만 아니라 복잡한 컴포넌트 로직을 더 유연하게 처리할 수 있는 기회를 줍니다. 아래에서 탐색해봅시다.\n\n# 컴포넌트 생성 및 사용\n\n컴포넌트는 Vue 애플리케이션의 기본 구성 요소입니다. Composition API에서는 reactive 상태와 컴포넌트의 동작을 정의하기 위해 setup 함수를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시: 간단한 카운터 컴포넌트\n\n```js\n\u003ctemplate\u003e\n  \u003cbutton @click=\"increment\"\u003e{ count }\u003c/button\u003e\n\u003c/template\u003e\u003cscript\u003e\nimport { ref } from 'vue';export default {\n  setup() {\n    const count = ref(0);\n    function increment() {\n      count.value++;\n    }    return { count, increment };\n  };\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: Composition API를 사용할 때, 개발자들은 조각난 상태 로직을 경험하여 컴포넌트를 유지하기 어렵게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 관련 로직을 함수로 캡슐화한 후에 이 함수를 설정(setup)에서 호출하세요. 이렇게 하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.\n\n# 부모 및 자식 컴포넌트 간 통신\n\nVue 3에서 부모 및 자식 컴포넌트 간의 통신은 주로 props와 emit을 통해 이루어집니다. Composition API는 defineProps와 defineEmit 함수를 제공하여이 프로세스를 간단화합니다.\n\n# 예: 부모-자식 컴포넌트 간 통신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- ChildComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cdiv @click=\"emitToParent\"\u003e나를 클릭해주세요!\u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { defineProps, defineEmit } from 'vue';\nexport default {\n  setup() {\n    const props = defineProps(['messageFromParent']);\n    const emit = defineEmit(['messageToParent']);\n    \n    function emitToParent() {\n      emit('messageToParent', '안녕하세요, 부모님!');\n    }\n    \n    return { emitToParent };\n  }\n};\n\u003c/script\u003e\n\n\u003c!-- ParentComponent.vue --\u003e\n\u003ctemplate\u003e\n  \u003cChildComponent\n    :messageFromParent=\"parentMessage\"\n    @messageToParent=\"handleMessageFromChild\"\n  /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ChildComponent from './components/ChildComponent.vue';\nexport default {\n  components: {\n    ChildComponent\n  },\n  setup() {\n    const parentMessage = ref('안녕하세요, 자식님!');\n    \n    function handleMessageFromChild(message) {\n      console.log(message);\n    }\n    \n    return { parentMessage, handleMessageFromChild };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움 : 대규모 어플리케이션에서는 종종 다층 중첩된 컴포넌트 간의 통신 요구사항이 발생합니다. 직접 props와 emit을 사용하면 \"props를 계층적으로 전달하는\" 및 \"이벤트를 계층적으로 발생시키는\" 문제가 발생할 수 있습니다.\n\n해결책 : 이러한 번거로운 계층별 전달을 피하기 위해 Vue 3의 provide 및 inject API를 사용하여 컴포넌트 간 수준의 통신을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 슬롯 사용\n\n슬롯을 사용하면 자식 컴포넌트의 내용으로 어떤 템플릿 코드든 부모 컴포넌트에 전달할 수 있습니다. Composition API에서는 슬롯 내용에 접근할 수 있습니다.\n\n# 예시: 슬롯 사용하기\n\n```js\n\u003c!-- BaseLayout.vue --\u003e\n\u003ctemplate\u003e\n  \u003cheader\u003e\n    \u003cslot name=\"header\"\u003e\u003c/slot\u003e\n  \u003c/header\u003e\n  \u003cmain\u003e\n    \u003cslot\u003e\u003c/slot\u003e\n  \u003c/main\u003e\n  \u003cfooter\u003e\n    \u003cslot name=\"footer\"\u003e\u003c/slot\u003e\n  \u003c/footer\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { useSlots } from 'vue';\nexport default {\n  setup() {\n    const slots = useSlots();\n    return { slots };\n  }\n};\n\u003c/script\u003e\n\u003c!-- App.vue --\u003e\n\u003ctemplate\u003e\n  \u003cBaseLayout\u003e\n    \u003ctemplate #header\u003e\n      \u003ch1\u003e여기에 페이지 제목이 올 수 있어요\u003c/h1\u003e\n    \u003c/template\u003e\n    \u003cp\u003e페이지의 주요 내용\u003c/p\u003e\n    \u003ctemplate #footer\u003e\n      \u003cp\u003e여기에 연락처 정보가 있습니다\u003c/p\u003e\n    \u003c/template\u003e\n  \u003c/BaseLayout\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport BaseLayout from './components/BaseLayout.vue';\nexport default {\n  components: {\n    BaseLayout\n  }\n};\n\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실용적인 어려움과 해결책\n\n어려움: 이름이 지정된 슬롯을 사용할 때, 슬롯 콘텐츠를 자식 컴포넌트의 상태 또는 동작에 따라 동기화하는 것이 복잡할 수 있습니다.\n\n해결책: scoped 슬롯을 사용할 수 있습니다. scoped 슬롯을 사용하면 자식 컴포넌트가 부모 컴포넌트에 데이터를 노출시킬 수 있고 그 데이터를 부모 컴포넌트의 슬롯 콘텐츠에서 사용할 수 있습니다.\n\n# 동적 컴포넌트와 비동기 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVue 3는 defineAsyncComponent를 통해 비동기 컴포넌트를 지원합니다. 동적 컴포넌트는 내장 `component` 태그와 `:` 속성을 사용하여 구현할 수 있습니다.\n\n# 예시: 비동기 컴포넌트\n\n```js\n// defineAsyncComponent를 사용하여 비동기 컴포넌트 로드\nimport { defineAsyncComponent } from 'vue';export default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =\u003e\n      import('./components/AsyncComponent.vue')\n    )\n  }\n};\n```\n\n# 예시: 동적 컴포넌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003ccomponent :is=\"currentComponent\" /\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nimport { ref } from 'vue';\nimport ComponentA from './components/ComponentA.vue';\nimport ComponentB from './components/ComponentB.vue';\nexport default {\n  setup() {\n    const currentComponent = ref('ComponentA');    // 실제 상황에 맞게 currentComponent의 값을 변경하여 컴포넌트를 전환할 수 있습니다.\n    \n    // currentComponent.value = 'ComponentB';\n    \n    return { currentComponent, ComponentA, ComponentB };\n  }\n};\n\u003c/script\u003e\n```\n\n# 실용적인 어려움과 해결책\n\n어려움: 비동기 컴포넌트를 사용할 때 컴포넌트 로딩 지연이나 실패와 같은 문제가 발생할 수 있어 사용자 경험에 영향을 줄 수 있습니다.\n\n해결책: 로딩 상태 힌트 및 오류 처리 매커니즘을 제공할 수 있습니다. 예를 들어, Suspense 컴포넌트를 사용하여 비동기 컴포넌트를 감쌀 수 있고 대체 콘텐츠(대체 콘텐츠)를 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ctemplate\u003e\n  \u003cSuspense\u003e\n    \u003ctemplate #default\u003e\n      \u003cAsyncComponent /\u003e\n    \u003c/template\u003e\n    \u003ctemplate #fallback\u003e\n      \u003cdiv\u003eLoading...\u003c/div\u003e\n    \u003c/template\u003e\n  \u003c/Suspense\u003e\n\u003c/template\u003e\n```\n\n위의 예제와 해결책을 통해 Vue 3의 모듈화 및 Composition API가 강력한 기능과 유연성을 제공하여 우리가 실용적인 개발 문제를 더 잘 해결하고 우아한 방식으로 복잡한 애플리케이션을 구축할 수 있음을 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png"},"coverImage":"/assets/img/2024-05-01-Vue3rspack003TheArtofComponentizationCompositionAPIandCommonProblemSolvingIdeas_0.png","tag":["Tech"],"readingTime":5}],"page":"78","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"78"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>