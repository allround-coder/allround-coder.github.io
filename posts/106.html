<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/106" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/106" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요" href="/post/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="흥미로운 자바스크립트 요령들" href="/post/2024-05-14-ObscureYetUsefulJavaScriptTricks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="흥미로운 자바스크립트 요령들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="흥미로운 자바스크립트 요령들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">흥미로운 자바스크립트 요령들</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 라우팅" href="/post/2024-05-14-RoutinginAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 라우팅" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-RoutinginAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 라우팅" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 라우팅</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다" href="/post/2024-05-14-ZodWhyyoureusingTypeScriptwrong"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">잠시만, 종 TypeScript를 잘못 사용하는 이유입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="블렌더를 Threejs와 통합하기 웹 상의 3D 콘텐츠 가능성 발휘하기" href="/post/2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="블렌더를 Threejs와 통합하기 웹 상의 3D 콘텐츠 가능성 발휘하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="블렌더를 Threejs와 통합하기 웹 상의 3D 콘텐츠 가능성 발휘하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">블렌더를 Threejs와 통합하기 웹 상의 3D 콘텐츠 가능성 발휘하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" href="/post/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" href="/post/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" href="/post/2024-05-14-ExpressgatewayYournextAPIGatewaySolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" href="/post/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" href="/post/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link posts_-active__YVJEi" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요","description":"","date":"2024-05-14 13:41","slug":"2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing","content":"\n\nJavaScript과 나는 생일이 같아요. 난 어린이였던 그 때에는 레고, 책, 그리고 곱셈표를 발견한 바로 그 때였어요. 1995년, 난 컴퓨터를 한 번도 보지 못했어요. 베를린의 장벽이 무너져내리고 철의 커튼이 열리기까지도 어딘가에서는 일어난 일들이었어요. 동유럽에서는 컴퓨터는 마음속에서 가장 먼 곳에 있었죠. 하지만 세계 반대편에서 중요한 일이 있었어요. 오늘날 우리가 알고 있는 웹과 기술을 가능케 한 일이죠. 그것이 바로 JavaScript인데, 누구도 중요하게 여기지 않았습니다. 윈도우 1995가 열광의 중심이었을 때, 누구나 어떤 어린 스크립트 언어에 대해 신경 쓸 이유가 있었을까요?\n\n## JavaScript의 역사로 가는 롤러코스터\n\n아마도 브랜든 아이치, 넷스케이프, 썬 마이크로시스템즈의 리더십을 제외하고는, 현재의 모든 인터넷 사용자를 위한 12월 4일의 순간이 얼마나 중요해질지 정말 아무도 몰랐을 거예요.\n\nJavaScript가 시작되었던 사실 중에 잘 알려지지 않은 것 하나는 그것이 언어가 되기로 의도된 것이 아니었다는 것이에요. 브랜든 아이치를 고용했을 때의 목표는 넷스케이프에 스킴 언어를 통합하는 것이었지만, 동시에 자바도 통합하려고 노력했습니다. 그러나 헝가리 속담에는 \"두 마리 토끼를 쫓다가 한 마리도 잡지 못한다\"라는 말이 있는데, 여기서도 적용되죠. 우리가 지금 알게 된 대로, 자바나 스킴은 브라우저에 통합되지 않았고, 넷스케이프의 경영진은 토끼를 쫓는 것을 멈추고 자바보다는 자바와 가까운 문법이 적용된 새로운 언어를 개발하기로 결정했어요.\n\n\n\n공식 릴리스가 된 12월까지는 이 언어가 JavaScript가 아니라 LiveScript라는 이름을 갖지 않았어요. 28년이 지난 지금도 제 생각에는 그 이름이 넷스케이프 경영진이 선택한 이름보다 훨씬 적합하다고 생각해요. 특히 Web 2.0과 Ajax의 소개 이후로 JavaScript의 주요 이점 중 하나는 페이지 새로 고침이 필요하지 않는 실시간 웹 애플리케이션을 가능하게 하는 능력이에요.\n\n10년이 흘러 2006년에는 우리가 사랑하고 미워하는 jQuery가 나왔어요. 단독으로 StackOverflow를 웹 개발자들에게 지옥으로 만든 라이브러리예요. 그리고 그래서 태어났죠. 단순한 JavaScript로 작성된 코드에 손 대지 않을 JS 엘리트들도 있는 반면 jQuery \"개발자\"를 어디서든 비하하는 JS 스노브도 있어요. 제 경우 어느 캠프에도 속하지 않는 것 같아요.\n\n물론 모든 상황에 이상적인 선택은 아니에요. 예를 들어 버전 3.0.0의 주요 문제는 dataType 옵션이 지정되지 않은 상태에서 교차 도메인 Ajax 요청을 수행했을 때 크로스사이트 스크립팅(XSS) 공격에 취약하다는 점이에요. jQuery 열차에 올라타기 전에 모든 개발자들이 알아야 할 실제적인 문제지요.\n\njQuery의 인기에서 영감을 받았거나 \"JS를 더 나아지게 만들어야 한다\"는 지속적인 요구에 의해 2009년 3년 뒤에는 아무도 실제로 요청하지 않았던 CoffeeScript가 등장했어요. \"Java\"가 \"커피\"를 뜻하기도 하니 그 새 언어의 이름으로는 너무나 분명한 선택이었을 지도 모르지만, 우리 개발자들은 명명하는 것에서 진짜 열악해요. 그래서 그 이름은 자리를 지켰죠. 브랜든 아이크는 자신의 생각에 JavaScript의 미래에 영향을 미치는 요인으로서 이 언어를 언급했어요. 그 말로 우스움 있어도 사랑받은 것이죠. 하게, Ruby on Rails 3.1에는 CoffeeScript를 내장 지원하는 기능이 있었는데, RoR이 얼마나 인기가 있었는지(시대에 따라 아직도 그렇죠.) 생각해보면 전혀 작지 않은 일이죠.\n\n\n\n세 년 뒤인 2012년에, 바닐라 JS 애호가들이 겸허함을 배우는 때가 왔습니다. 마이크로소프트가 JavaScript를 \"개선\"하기로 결정하는 바람에요. 그러나 그들의 엔지니어들은 CoffeeScript처럼 JS로 컴파일되는 새 언어를 만들지 않고, 덜 고통스러운 슈퍼셋 경로를 선택했어요. 위키피디아에 따르면:\n\n누군가는 이것에 논쟁할지도 모르지만, 그 인기는 부정할 수 없죠. 이것은 많은 소프트웨어 엔지니어들의 상상력과 주의를 사로잡았습니다. 그것은 갑자기 강력하게 타입이 지정된 언어를 좋아하는 많은 소프트웨어 엔지니어들의 관심을 끌었기 때문에, 갑자기 바닐라 JS 애호가들은 TS보다 JS를 지지하게 되었어요. 2023년에는 원래의 언어와 그 슈퍼셋 간에 어느 정도 균형이 이루어졌지만, 최근에는 Svelte와 Turbo 8와 같은 프레임워크가 TypeScript를 버리고 부담이 적은 다른 솔루션을 선호하는 모습을 보여주기도 해서, 마이크로소프트의 개선된 JS의 미래는 확실하지 않습니다.\n\n한편, 자바스크립트 뒤의 ECMAScript 표준은 멈추지 않았습니다. 그래서 또 세 년 후인 2015년에, 웹 개발자들은 드디어 브라우저에서 자연스럽게 실행되는 자신들의 가장 좋아하는 언어에 중요한 업데이트를 얻었어요. ES6 (ECMAScript 2015)는 오랜 시간 동안 가장 중요한 변화였으며, 모든 변화가 개발자들에 의해 매우 환영을 받았어요. 몇 주 안에, 개발자들은 화살표 함수, 템플릿 문자열 및 상수를 사랑하게 되었죠. 물론 이것들은 빙산의 일각에 불과했습니다.\n\n2015년 이후로 매년 새로운 표준 및 JavaScript로의 업데이트 세트가 도입되고 있습니다. 2023년에는 모든 주요 브라우저에서 심지어 ES7도 아주 잘 지원되며, 실시간 및 동적 애플리케이션 개발이 이전보다 더 직관적이고 편리해지고 있습니다.\n\n\n\n## JS 이상의 존재\n\n자바스크립트의 가장 흥미로운 측면 중 하나는 브라우저에서 동작하는 역사를 가졌다는 것 뿐만 아니라, 어디서든 실행되는 언어가 되었다는 점입니다. 일부 사람들은 \"할 수 없다고 해서 반드시 해서는 안 된다\"고 강력히 이야기할지 모르지만, 자바스크립트는 가장 이색적인 플랫폼에서도 다양한 해결책을 개발할 수 있도록 해주었습니다.\n\nJS를 백엔드에서 실행하거나 OS에서 실행하고 싶나요? 가능합니다. Node.js, Deno 그리고 이제 Bun까지 모두 사용하실 수 있습니다. 흔히 사용되는 많은 경우를 위해 바퀴를 다시 발명할 필요 없이 최신 UI를 구축하고 싶다면, React, Vue, Svelte, Angular 및 기타 다양한 UI 라이브러리와 프레임워크를 선택할 수 있습니다. 대부분의 경우 서버 사이드 렌더링을 기본으로 지원하기 때문에 따로 추가 패키지가 필요하지 않습니다. 데스크톱 및 모바일용 네이티브 애플리케이션을 만들 수도 있습니다. 필요한 것은 Electron이나 Ionic 뿐입니다.\n\n하지만 JS는 더 나아갑니다. 작은 퍽을 블루투스 파워포인트 프레젠터 리모컨으로 변신시킨 것처럼 임베디드 시스템이나 마이크로컨트롤러에서 실행할 수도 있습니다. 놀랍게도, 자바스크립트는 게임 개발에도 탁월합니다. 따라서 플래피 버드나 요즘 아이들이 하는 게임을 만드는 데 어려움은 없을 것입니다. 저는 게이머가 아니며 게임을 즐기기에 충분히 심심하지 않습니다. LEGO를 쌓는 것이 취미죠. 😁\n\n\n\n자바스크립트는 겸손한 언어에서 전체 스택으로 발전했는데, 이것은 소프트웨어 개발 세계에서 엄청난 파워를 발휘합니다. 개발자 뿐만 아니라 스마트한 비용 절약 결정을 내리고 싶은 기업에게도 이점이 있죠. 자바스크립트는 더 이상 개발자의 선호도에 그치는 것이 아니라, 훨씬 더 큰 기업 전략 대화로 진화하고 있습니다. 자바스크립트는 현실적으로 돈을 절약하고 벌 수 있으며, 소프트웨어 엔지니어의 기술 세트를 매우 재사용 가능하게 만들어, 그들이 그 외의 경우에 비해 훨씬 더 가치 있게 만듭니다. 동일한 언어를 모든 곳에서 사용할 수 있는 능력은 무척 강력하고 만족스럽습니다.\n\n## '2023년, 꽤 좋았던 해였어요'\n\n2023년은 일반적으로 세상을 볼 때 최고의 해는 아니었을지许는데, 그러나 자바스크립트 팬들로서 우리는 새로운 업데이트를 풍부하게 받았고 그중에서 지루하지 않았죠.\n\n아마도 가장 주목할 만한 유틸리티 함수는 새로운 Object.groupBy()일 거예요. 이제 객체의 속성을 다른 속성 값에 따라 그룹화할 수 있게 되었는데, 에러가 발생하기 쉬운 끝도 없는 코드를 작성하지 않고도 가능하며, 이 과정은 다음과 같이 간단합니다:\n\n\n\n```js\nconst inventory = [\n  { name: \"asparagus\", type: \"vegetables\", quantity: 5 },\n  { name: \"bananas\", type: \"fruit\", quantity: 0 },\n  { name: \"goat\", type: \"meat\", quantity: 23 },\n  { name: \"cherries\", type: \"fruit\", quantity: 5 },\n  { name: \"fish\", type: \"meat\", quantity: 22 },\n];\n\nconst result = Object.groupBy(inventory, ({ type }) =\u003e type);\n```\n\n결과는 다음과 같습니다:\n\n```js\n{\n  vegetables: [\n    { name: 'asparagus', type: 'vegetables', quantity: 5 },\n  ],\n  fruit: [\n    { name: \"bananas\", type: \"fruit\", quantity: 0 },\n    { name: \"cherries\", type: \"fruit\", quantity: 5 }\n  ],\n  meat: [\n    { name: \"goat\", type: \"meat\", quantity: 23 },\n    { name: \"fish\", type: \"meat\", quantity: 22 }\n  ]\n}\n```\n\n이것이 아름다운 것이 아니라면, 무엇이 아름다운지 모르겠어요. 🙂\n\n\n\n\n마침내 배열을 복제하지 않고도 변이를 피하기 위해 원래 배열을 변형하지 않고 배열을 뒤집거나 분할하고 정렬할 수도 있게 되었습니다. 여기에서 작동하는 toReversed(), toSpliced() 및 toSorted()을 살펴봅시다:\n\n```js\n// toReversed()\n\nconst items = [1, 2, 3];\nconsole.log(items); // [1, 2, 3]\n\nconst reversedItems = items.toReversed();\nconsole.log(reversedItems); // [3, 2, 1]\nconsole.log(items); // [1, 2, 3]\n// toSpliced()\n\nconst months = [\"Jan\", \"Mar\", \"Apr\", \"May\"];\n\n// 인덱스 1에 요소 삽입\nconst months2 = months.toSpliced(1, 0, \"Feb\");\nconsole.log(months2); // [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"]\n\n// 인덱스 2부터 두 요소 삭제\nconst months3 = months2.toSpliced(2, 2);\nconsole.log(months3); // [\"Jan\", \"Feb\", \"May\"]\n\n// 인덱스 1의 요소를 새로운 두 요소로 대체\nconst months4 = months3.toSpliced(1, 1, \"Feb\", \"Mar\");\nconsole.log(months4); // [\"Jan\", \"Feb\", \"Mar\", \"May\"]\n\n// 원본 배열이 수정되지 않음\nconsole.log(months); // [\"Jan\", \"Mar\", \"Apr\", \"May\"]\n// toSorted()\n\nconst months = [\"Mar\", \"Jan\", \"Feb\", \"Dec\"];\nconst sortedMonths = months.toSorted();\nconsole.log(sortedMonths); // ['Dec', 'Feb', 'Jan', 'Mar']\nconsole.log(months); // ['Mar', 'Jan', 'Feb', 'Dec']\n\nconst values = [1, 10, 21, 2];\nconst sortedValues = values.toSorted((a, b) =\u003e a - b);\nconsole.log(sortedValues); // [1, 2, 10, 21]\nconsole.log(values); // [1, 10, 21, 2]\n```\n\nJavaScript의 특이한 점들은 나를 거의 짜증나게 하지 않지만, 이러한 개선 사항은 확실히 환영받을 만하며 앞으로 훨씬 깔끔한 코드 베이스로 이어집니다.\n\n올해 나를 흥분하게 한 마지막 것은 HTML5의 dialog 태그이며, 이제 내장된 showModal() 및 close() 함수가 있습니다. 이제 대화 상자나 모달을 열고 닫을 수 있습니다:\n\n\n\n\n```js\ndialog.showModal();\nclose(); // 당신은 안쪽에 값도 반환할 수 있어\n```\n\n이거 정말 멋지지 않아요!\n\n물론, 대부분의 주요 JS 프레임워크도 상당한 변화를 겪었죠. create-react-app은 사라졌고 이제 Next.js가 대부분의 미래 React 애플리케이션과 동의어가 되었습니다. 또한, Next.js v13에서 채택된 React 서버 사이드 컴포넌트로 API를 호출할 수도 있어요.\n\nSvelte도 눈에 띄게 변화하고자 했고, 웹에서 \"반응성\"을 다시 생각하기 위해 \"룬\" 개념을 도입했어요. 기본적으로 컴파일 시간 반응성에서 섬세한 단위의 반응성으로 전환하는 것이죠. 그들이 말하는 바에 따르면:\n\n\n\n하지만 Angular 17보다 더 빠를까요? 여전히 제 마음 속에 가장 가까운 JS 프레임워크는 2023년 11월에 17버전에 도달했으며, 오랜 시간 만에 가장 큰 변화 중 하나를 가져왔습니다. 누구나 새로운 템플릿 구문을 바로 알아차릴 것입니다. 즉, 이제 ngIf와 ngFor를 작별하게 되었습니다.\n\n이것은 프론트엔드에서의 변화 중 하나일 뿐입니다. 백엔드에서도 Node.js는 조용히 개선되고 있습니다. 그중 하나의 주목할만한 업데이트는 --experimental-websocket 플래그인 도입으로 Node 21에서 자체 웹소켓 클라이언트를 소개했습니다.\n\nNode.js가 명백히 매우 인기가 많다는 것은 2023년에 새로운 경쟁 상대가 나타나지 않았다는 것을 의미하지 않습니다. Bun.js는 올인원 JavaScript 런타임이며, 특정 환경에서 Node보다 5배 이상 빠르다고 합니다. Bun 팀은 다음과 같이 주장합니다:\n\n아직 초기 단계이지만 확실히 약속을 보여줍니다. 하지만 저는 여전히 Node나 Deno를 한동안 사용하는 것을 선호합니다.\n\n\n\n## JS의 다음은 무엇일까요?\n\n그래서, 28년 만에 JavaScript의 다음은 무엇일까요? 실제 기능 측면에서는, 우리는 무엇을 기대해야 하는지 알고 있습니다. ES 제안의 제3 단계 후보는 상당히 많은데요 — 총 14개 — 모두 충분히 흥미롭어서 곧 현실이 될 것으로 예상됩니다. 초안에서는 23개 제안이 있으며, 그 중 일부는 수천 표를 받았습니다. 반면 제안 단계 1에서는 총 90개가 있습니다. 하지만 그 중 대부분은 단계 2 또는 3에 도달할 가능성이 적을 것으로 생각합니다.\n\n생태계 측면에서, JavaScript는 계속 번창할 것으로 생각됩니다. IEEE.org에 따르면, 2023년에 가장 인기 있는 언어 중 3위에 올랐으며, 앞으로 몇 년 동안 이것이 크게 변할 것 같지는 않습니다. 직업 기회 측면에서 보면, SQL, Python, 그리고 Java 다음으로 가장 많이 찾는 기술이 되었습니다. 🎉\n\n\n\n![JavaScript Birthday](/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_1.png)\n\n사랑하든 싫어하든, JavaScript는 활기차고 성숙하며 열정적인 커뮤니티를 갖고 있습니다. 이 커뮤니티는 JavaScript를 오롯이 유지하는 것뿐만 아니라 새로운 높이로 끌어올리고 있습니다. JS로 무엇이든 구축하는 방법에 대한 정보는 파이썬만큼이나 풍부합니다. 이는 프로그래밍에 새로운 사람들에게 접근하기 쉬운 언어이며, 아마도 파이썬보다 더 쉽게 접근할 수 있다고 말해도 좋을 것입니다. 네, 이상한 점들이 있지만, 저는 한 사람으로서 이를 사랑하고 함께 일하며 조정하기를 배웠습니다.\n\n생일 축하, JavaScript! 🍻🎂\n\nAttila Vago - 세상을 하나의 코드 줄씩 개선하는 소프트웨어 엔지니어. 영원한 멋쟁이, 코드와 블로그의 작가. 웹 접근성 옹호자, 레고 팬, 비닐 레코드 컬렉터. 수제 맥주를 좋아합니다! 제 \"안녕 이야기\"를 여기서 읽어보세요! 레고, 기술, 코딩 및 접근성에 관한 더 많은 이야기를 구독하세요! 가끔씩 방문하시는 독자분들을 위해 랜덤 이야기와 글도 써봅니다.","ogImage":{"url":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png"},"coverImage":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png","tag":["Tech"],"readingTime":9},{"title":"흥미로운 자바스크립트 요령들","description":"","date":"2024-05-14 13:39","slug":"2024-05-14-ObscureYetUsefulJavaScriptTricks","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png\" /\u003e\n\n제가 매일 업무 중에 수집한 약간 낯설지만 유용한 JavaScript 트릭 몇 가지를 소개해드릴게요. 이 모든 트릭들은 간결하고 우아한 한 줄짜리 코드들입니다. 이 트릭들이 여러분의 JavaScript 개발에 조금 도움이 될 수 있다고 믿어요.\n\n# 웹\n\n## 현재 페이지 다시 불러오기\n\n\n\n```js\nconst reload = () =\u003e location.reload();\nreload()\n```\n\n## 페이지 맨 위로 이동하기\n\n페이지를 맨 위로 가져와야 하는 경우\n\n```js\nconst goToTop = () =\u003e window.scrollTo(0, 0);\n\ngoToTop()\n```\n\n\n\n## 요소 스크롤링\n\n요소를 부드럽게 스크롤하여 뷰포트의 시작 지점으로 이동하려면\n\n```js\nconst scrollToTop = (element) =\u003e\n  element.scrollIntoView({ behavior: \"smooth\", block: \"start\" })\n\nscrollToTop(document.body)\n```\n\n요소를 부드럽게 스크롤하여 뷰포트의 끝 지점으로 이동하려면\n\n\n\n```js\nconst scrollToBottom = (element) =\u003e\n  element.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\nscrollToBottom(document.body);\n```\n\n## 현재 브라우저가 인터넷 익스플로러인지 확인하기\n\n```js\nconst isIE = !!document.documentMode;\n```\n\n## 주어진 텍스트에서 HTML 태그 제거하기\n\n\n\n단어로 마크업 태그들을 걸러내야 할 때\n\n```js\nconst stripHtml = (html) =\u003e new DOMParser().parseFromString(html, 'text/html').body.textContent || '';\n\nstripHtml('\u003cdiv\u003etest\u003c/div\u003e') // 'test'\n```\n\n## 리다이렉트\n\n다른 페이지로 이동할 때.\n\n\n\n## 텍스트 붙여넣기\n\n클립보드에 텍스트를 복사해야 할 때\n\n```js\nconst copy = (text) =\u003e navigator.clipboard?.writeText \u0026\u0026 navigator.clipboard.writeText(text)\ncopy('당신이 붙여넣어야 할 텍스트')\n```\n\n\n\n# 기능\n\n## 비동기 함수 확인\n\n함수가 비동기인지 확인하려면\n\n```js\nconst isAsyncFunction = (v) =\u003e Object.prototype.toString.call(v) === '[object AsyncFunction]'\n\nisAsyncFunction(async function () {}); // true\n```\n\n\n\n# 숫자\n\n## 숫자 자르기\n\n소수점 이후 특정 자릿수를 버릴 때 반올림하지 않고 잘라야 할 때\n\n```js\nconst toFixed = (n, fixed) =\u003e `${n}`.match(new RegExp(`^-?\\d+(?:.\\d{0,${fixed})?`))[0]\n\ntoFixed(10.255, 2) // 10.25\n```\n\n\n\n## 가장 가까운 수로 반올림\n\n소수점 이후의 특정 자릿수를 버리고 가장 가까운 수로 반올림해야 하는 경우\n\n```js\nconst round = (n, decimals = 0) =\u003e Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)\n\nround(10.255, 2) // 10.26\n```\n\n## Zero padding\n\n\n\n숫자 'num'을 'len' 자릿수가 될 때까지 앞에 0을 채우고 싶을 때\n\n```js\nconst replenishZero = (num, len, zero = 0) =\u003e num.toString().padStart(len, zero)\n\nreplenishZero(8, 2) // 08\n```\n\n# 객체\n\n## 잘못된 속성 삭제\n\n\n\n객체 내 값이 null 또는 정의되지 않은 속성들을 모두 삭제해야 할 때\n\n```js\nconst removeNullUndefined = (obj) =\u003e Object.entries(obj).reduce((a, [k, v]) =\u003e (v == null ? a : ((a[k] = v), a)), {});\n\nremoveNullUndefined({name: '', age: undefined, sex: null}) // { name: '' }\n```\n\n## 객체 키-값 쌍 반전\n\n객체의 키-값 쌍을 교환해야 할 때\n\n\n\n```js\nconst invert = (obj) =\u003e Object.keys(obj).reduce((res, k) =\u003e Object.assign(res, { [obj[k]]: k }), {})\n\ninvert({name: 'jack'}) // {jack: 'name'}\n```\n\n## 문자열을 객체로 변환하기\n\n'이름: \"jack\"'과 같은 문자열을 객체로 변환해야할 때는 JSON.parse를 직접 사용하면 오류가 발생할 수 있습니다.\n\n```js\nconst strParse = (str) =\u003e JSON.parse(str.replace(/(\\w+)\\s*:/g, (_, p1) =\u003e `\"${p1}\":`).replace(/\\'/g, \"\\\"\"))\n\nstrParse('{name: \"jack\"}')\n```\n\n\n\n# 날짜\n\n## 오늘 날짜인지 확인하기.\n\n```js\nconst isToday = (date) =\u003e date.toISOString().slice(0, 10) === new Date().toISOString().slice(0, 10)\n```\n\n## 날짜 변환\n\n\n\n날짜를 YYYY-MM-DD 형식으로 변환해야 할 때\n\n```js\nconst formatYmd = (date) =\u003e date.toISOString().slice(0, 10);\nformatYmd(new Date())\n```\n\n## 두 번째 변환\n\n시간(초)를 hh:mm:ss 형식으로 변환해야 할 때\n\n\n\n```js\nconst formatSeconds = (s) =\u003e new Date(s * 1000).toISOString().substr(11, 8)\n\nformatSeconds(200) // 00:03:20\n```\n\n## 특정 연도와 월의 첫 번째 날을 가져오기\n\n```js\nconst getFirstDate = (d = new Date()) =\u003e new Date(d.getFullYear(), d.getMonth(), 1);\n\ngetFirstDate(new Date('2024/05')) \n```\n\n## 특정 연도와 월의 마지막 날을 가져오기\n\n\n\n\n```js\nconst getLastDate = (d = new Date()) =\u003e new Date(d.getFullYear(), d.getMonth() + 1, 0);\ngetLastDate(new Date('2023/03/04')) \n```\n\n## 특정 연도의 특정 월의 전체 일 수 구하기\n\n```js\nconst getDaysNum = (year, month) =\u003e new Date(year, month, 0).getDate()  \nconst day = getDaysNum(2024, 2) // 29\n```\n\n# 배열\n\n\n\n## 배열 생성하기\n\n0부터 99까지의 배열이 필요할 때 아래의 코드를 사용하세요.\n\n```js\n// 방법1\nconst createArr = (n) =\u003e Array.from(new Array(n), (v, i) =\u003e i)\nconst arr = createArr(100)\n```\n\n```js\n// 방법2\nconst createArr = (n) =\u003e new Array(n).fill(0).map((v, i) =\u003e i)\ncreateArr(100)\n```\n\n\n\n## 배열 섞기\n\n배열이 있고 순서를 섞어야 할 때\n\n```js\nconst randomSort = list =\u003e list.sort(() =\u003e Math.random() - 0.5)\nrandomSort([0,1,2,3,4,5,6,7,8,9]) // 무작위 순열 결과\n```\n\n## 간단한 배열 중복 제거\n\n\n\n배열에서 각 중복 요소의 인스턴스를 하나만 유지해야 할 때\n\n```js\nconst removeDuplicates = list =\u003e [...new Set(list)]\nremoveDuplicates([0, 0, 2, 4, 5]) // [0,2,4,5]\n```\n\n## 배열의 고유한 값 중복 제거\n\n고유한 값에 기반하여 배열에서 중복을 제거합니다.\n\n\n\n```js\nconst duplicateById = list =\u003e [...list.reduce((prev, cur) =\u003e prev.set(cur.id, cur), new Map()).values()]\nduplicateById([{id: 1, name: 'jack'}, {id: 2, name: 'rose'}, {id: 1, name: 'jack'}])\n// [{id: 1, name: 'jack'}, {id: 2, name: 'rose'}]\n```\n\n## 여러 배열의 교집합\n\n여러 배열의 교집합을 찾아야 할 때\n\n```js\nconst intersection = (a, ...arr) =\u003e [...new Set(a)].filter((v) =\u003e arr.every((b) =\u003e b.includes(v)))\n\nintersection([1, 2, 3, 4], [2, 3, 4, 7, 8], [1, 3, 4, 9])\n// [3, 4]\n```\n\n\n\n## 최대 값의 인덱스 찾기\n\n배열에서 최대 값의 인덱스를 찾아야 할 때\n\n```js\nconst indexOfMax = (arr) =\u003e arr.reduce((prev, curr, i, a) =\u003e (curr \u003e a[prev] ? i : prev), 0);\nindexOfMax([1, 3, 9, 7, 5]); // 2\n```\n\n## 최소 값의 인덱스 찾기\n\n\n\n배열에서 최솟값의 인덱스를 찾아야 할 때\n\n```js\nconst indexOfMin = (arr) =\u003e arr.reduce((prev, curr, i, a) =\u003e (curr \u003c a[prev] ? i : prev), 0)\nindexOfMin([2, 5, 3, 4, 1, 0, 9]) // 5\n```\n\n## 가장 가까운 숫자 값 찾기\n\n배열에서 주어진 숫자에 가장 가까운 값을 찾아야 할 때\n\n\n\n```js\nconst closest = (arr, n) =\u003e arr.reduce((prev, curr) =\u003e (Math.abs(curr - n) \u003c Math.abs(prev - n) ? curr : prev))\nclosest([29, 87, 8, 78, 97, 20, 75, 33, 24, 17], 50) // 33\n```\n\n## 여러 배열을 압축하기\n\n여러 배열을 하나의 배열로 압축해야 할 때\n\n```js\nconst zip = (...arr) =\u003e Array.from({ length: Math.max(...arr.map((a) =\u003e a.length)) }, (_, i) =\u003e arr.map((a) =\u003e a[i]))\nzip([1,2,3,4], ['a', 'b', 'c', 'd'], ['A', 'B', 'C', 'D'])\n// [[1, 'a', 'A'], [2, 'b', 'B'], [3, 'c', 'C'], [4, 'd', 'D']]\n```\n\n\n\n## 행과 열 바꾸기\n\n행과 열을 교환해야 할 때\n\n```js\nconst transpose = (matrix) =\u003e matrix[0].map((col, i) =\u003e matrix.map((row) =\u003e row[i]));\ntranspose(\n    [              // [\n        [1, 2, 3], //      [1, 4, 7],\n        [4, 5, 6], //      [2, 5, 8],\n        [7, 8, 9], //      [3, 6, 9],\n     ]             //  ]\n );\n```\n\n# 숫자 변환\n\n\n\n## 기수 변환\n\n기수 10에서 n으로 변환하려면 toString(n)을 사용할 수 있어요!\n\n```js\nconst toDecimal = (num, n = 10) =\u003e num.toString(n) \n// 만약 10을 이진수 (기수 2)로 변환해야 한다면\ntoDecimal(10, 2) // '1010'\n```\n\n기수 n에서 기수 10으로 변환하려면 parseInt(num, n)을 사용할 수 있어요!\n\n\n\n```js\nconst toDecimalism = (num, n = 10) =\u003e parseInt(num, n)\ntoDecimalism(1010, 2)\n```\n\n# 기타\n\n## 두 객체 비교하기\n\n두 객체를 비교해야 할 때 JavaScript의 등가 연산자는 객체의 주소가 동일한지만 판단할 수 있습니다. 주소가 다를 경우 두 객체의 키-값 쌍이 동일한지 여부를 판단할 수 없습니다.\n\n\n\n```js\nconst isEqual = (...objects) =\u003e objects.every(obj =\u003e JSON.stringify(obj) === JSON.stringify(objects[0]))\nisEqual({name: 'jack'}, {name: 'jack'}) // true\nisEqual({name: 'jack'}, {name: 'jack1'}, {name: 'jack'}) // false\n```\n\n## 랜덤 색상 생성\n\n랜덤한 색상이 필요할 때\n\n```js\nconst getRandomColor = () =\u003e `#${Math.floor(Math.random() * 0xffffff).toString(16)}`\ngetRandomColor() // '#4c2fd7'\n```\n\n\n\n## 컬러 형식 변환\n\n16진수 색상을 RGB로 변환해야 할 때\n\n```js\nconst hexToRgb = hex =\u003e hex.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, (_, r, g, b) =\u003e `#${r}${r}${g}${g}${b}${b}`).substring(1).match(/.{2}/g).map((x) =\u003e parseInt(x, 16));\nhexToRgb('#00ffff'); // [0, 255, 255]\nhexToRgb('#0ff'); // [0, 255, 255]\n```\n\n## 랜덤 IP 주소 가져오기\n\n\n\nIP 주소를 생성할 때 필요한 함수입니다.\n\n```js\nconst randomIp = () =\u003e\n    Array(4)\n        .fill(0)\n        .map((_, i) =\u003e Math.floor(Math.random() * 255) + (i === 0 ? 1 : 0))\n        .join('.');\n```\n\n# UUID\n\nID를 생성할 때 필요한 함수입니다.\n\n\n\n```javascript\nconst uuid = (a) =\u003e (a ? (a ^ ((Math.random() * 16) \u003e\u003e (a / 4))).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid))\nuuid()\n```\n\n## 쿠키 가져오기\n\n쿠키를 객체로 변환해야 할 때\n\n```javascript\nconst getCookie = () =\u003e document.cookie\n    .split(';')\n    .map((item) =\u003e item.split('='))\n    .reduce((acc, [k, v]) =\u003e (acc[k.trim().replace('\"', '')] = v) \u0026\u0026 acc, {})\ngetCookie()\n```\n\n\n\n## 강제 대기\n\n일정 시간 동안 기다려야 할 때 setTimeout 함수에 작성하고 싶지 않은 경우, 콜백 지옥을 유발할 수 있습니다.\n\n```js\nconst sleep = async (t) =\u003e new Promise((resolve) =\u003e setTimeout(resolve, t));\nsleep(2000).then(() =\u003e {console.log('time')});\n```\n\n# 간단히 말해 🚀\n\n\n\nThank you for being a part of the In Plain English community! Before you go:\n\n- Be sure to clap and follow the writer 👏\n- Follow us: X | LinkedIn | YouTube | Discord | Newsletter\n- Visit our other platforms: Stackademic | CoFeed | Venture | Cubed\n- Tired of blogging platforms that force you to deal with algorithmic content? Try Differ\n- More content at PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png"},"coverImage":"/assets/img/2024-05-14-ObscureYetUsefulJavaScriptTricks_0.png","tag":["Tech"],"readingTime":9},{"title":"앵귤러에서의 라우팅","description":"","date":"2024-05-14 13:37","slug":"2024-05-14-RoutinginAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-RoutinginAngular_0.png\" /\u003e\n\n안녕하세요! 이 기사에서는 Angular에서 라우팅에 대해 이야기하고 서로 다른 컴포넌트를 렌더링하기 위해 라우팅을 사용하는 다양한 방법에 대해 알아볼 거예요.\n\n# 아젠다\n\n- Angular가 무엇인가요?\n\n\n\n- 라우팅이란 무엇인가요?\n\n- 라우팅의 장점은 무엇인가요?\n\n- 앵귤러에서의 라우팅\n\n- 라우팅 예시\n\n\n\n# 요구 사항\n\n- Node.js\n- Angular\n- VS Code\n\n\n\n# 앵귤러란 무엇인가요?\n\n앵귤러는 웹 애플리케이션을 구축하기 위한 인기있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재 Google의 앵귤러 팀에서 유지보수되고 있습니다. 앵귤러를 사용하면 개발자들은 동적인 싱글 페이지 애플리케이션(SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하는 구조적인 방법을 제공합니다.\n\n# 라우팅이란 무엇인가요?\n\n웹 개발의 맥락에서 라우팅이란 특정 URL이나 경로에 대한 애플리케이션의 응답 방식을 결정하는 프로세스를 말합니다. 이는 URL을 애플리케이션 내의 다른 구성 요소나 뷰로 매핑하고 요청된 URL에 따라 적절한 콘텐츠를 렌더링하는 것을 포함합니다.\n\n\n\n클라이언트 측 웹 애플리케이션인 Angular로 만든 싱글 페이지 애플리케이션(SPA)과 같은 경우에는 라우팅을 통해 사용자가 새로운 HTML 페이지를 서버에서 로드하지 않고도 서로 다른 뷰 또는 페이지 간을 이동할 수 있습니다. 대신, 요청한 라우트에 기반하여 응용 프로그램이 필요한 구성 요소와 데이터를 동적으로 업데이트하여 브라우저의 내용을 로드합니다.\n\n라우팅의 장점\n\n웹 애플리케이션의 라우팅은 여러 가지 이점을 제공합니다. 여기에 라우팅을 사용하는 주요 이점 중 일부가 있습니다:\n\n사용자 경험 향상: 라우팅을 통해 전체 페이지 다시로드 없이 응용 프로그램 내에서 서로 다른 뷰나 페이지로 내비게이션할 수 있어 사용자 경험을 원활하고 상호작용적으로 만들어줍니다.\n\n\n\n빠른 페이지 전환: 라우팅을 사용하면 요청된 경로에 필요한 컴포넌트와 데이터만 로드되어 더 빠른 페이지 전환을 경험할 수 있어요.\n\n모듈화와 유지보수성: 라우팅은 응용 프로그램을 모듈화된 구조로 유지하도록 장려하여 특정 경로와 관련된 서로 다른 뷰나 컴포넌트로 분할합니다. 이는 코드의 재사용성, 관심사의 분리 및 더 나은 유지보수성을 촉진합니다. 각 경로에는 해당 컴포넌트가 있어서 응용 프로그램의 특정 섹션을 보다 쉽게 관리하고 업데이트할 수 있습니다.\n\n조건부 렌더링과 동적 콘텐츠: 라우팅을 통해 현재 경로에 따라 컴포넌트를 조건부로 렌더링할 수 있습니다. 이를 통해 사용자의 탐색 경로에 따라 응용 프로그램의 특정 섹션을 표시하거나 숨길 수 있어요.\n\n경로 매개변수와 쿼리 매개변수: 라우팅은 경로 매개변수와 쿼리 매개변수를 지원합니다. 경로 매개변수를 사용하면 URL 내에서 ID나 사용자 이름과 같은 동적값을 전달하고 해당 컴포넌트에서 이를 검색할 수 있습니다. 쿼리 매개변수는 URL에 추가 데이터를 전달하여 필터링, 정렬 또는 기타 목적으로 사용할 수 있어요.\n\n\n\n보안 및 라우팅 가드: Angular 라우팅에는 특정 조건을 기반으로 특정 경로에 대한 액세스를 제어하는 메커니즘인 라우트 가드가 포함되어 있습니다. 라우트 가드는 인증, 권한 부여 및 기타 보안 관련 목적으로 사용할 수 있습니다. 사용자가 필요한 기준을 충족해야만 경로에 액세스하거나 작업을 수행할 수 있도록 도와줍니다.\n\n중첩 라우트: 라우팅은 중첩된 또는 하위 경로를 지원하여 응용 프로그램 내에서 계층적 탐색 구조를 정의할 수 있습니다. 이는 다중 수준의 탐색 또는 캡슐화되고 독립적으로 관리해야 하는 섹션을 처리할 때 특히 유용합니다.\n\n전반적으로 라우팅은 사용자 경험을 향상시키고 성능을 향상시키며 웹 애플리케이션에서 모듈식이고 유지 보수 가능한 코드 구조를 가능하게 하는 데 중요한 역할을 합니다.\n\n# Angular에서의 라우팅\n\n\n\n클라이언트 측 웹 애플리케이션에서 Angular을 사용하여 구축된 싱글 페이지 애플리케이션(SPA)과 같은 경우에는 라우팅을 통해 사용자가 서버로부터 새 HTML 페이지를 로딩하지 않고도 서로 다른 뷰 간을 이동할 수 있습니다. 대신에 어플리케이션은 요청된 경로에 기반하여 필요한 컴포넌트와 데이터를 동적으로 브라우저에 업데이트하여 내용을 렌더링합니다.\n\nAngular에서의 라우팅은 일반적으로 다음 구성 요소를 포함합니다:\n\n- 라우트(Routes): 라우트는 URL 경로와 해당 컴포넌트 간의 매핑을 정의합니다. 각 라우트는 URL 경로 및 해당 경로에 액세스할 때 렌더링될 컴포넌트로 정의됩니다.\n\n- 라우터(Router): 라우터는 현재 URL을 해석하고 정의된 라우트를 기반으로 적절한 컴포넌트를 로딩하는 역할을 담당합니다. 라우터는 URL 변경을 감지하고 어플리케이션 내에서의 네비게이션을 처리합니다.\n\n\n\nRouter Outlet: 라우터 아웃렛은 현재 라우트의 내용이 렌더링되는 애플리케이션 템플릿의 자리 표시자입니다.\n\nRouter 링크 및 내비게이션: 링크 및 내비게이션 요소인 앵커 태그(`a`)나 버튼과 같은 요소는 애플리케이션 내에서 다른 라우트로의 이동을 트리거하는 데 사용됩니다. 이러한 요소에는 Angular의 routerLink와 같은 디렉티브로 대상 경로를 지정할 수 있습니다.\n\n# Angular에서의 라우팅 예제\n\n단계 1\n\n\n\nNodeJS를 설치하세요.\n\nhttps://nodejs.org/en/download\n\n단계 2\n\n다음 명령을 사용하여 Angular CLI를 설치하세요.\n\n\n\n3단계\n\n다음 명령어를 사용하여 NodeJS와 Angular CLI가 설치되었는지 확인하세요:\n\n![Routing in Angular](/assets/img/2024-05-14-RoutinginAngular_1.png)\n\n새로운 Angular 애플리케이션을 생성하세요.\n\n\n\n**단계 4**\n\nAngular 애플리케이션을 VS Code와 같은 편집기 중 하나에서 열고 다음 명령어를 사용하여 부트스트랩을 설치하세요:\n\n이후에 angular.json 파일 내에 있는 스크립트 및 스타일 섹션에 부트스트랩 스크립트를 추가하세요.\n\n```js\n\"styles\": [\n\"src/styles.css\",\n\"./node_modules/bootstrap/dist/css/bootstrap.min.css\"\n],\n\"scripts\": [\n\"./node_modules/bootstrap/dist/js/bootstrap.min.js\"\n]\n```\n\n\n\n## 단계 5\n\n터미널이나 명령 프롬프트를 열고 Angular 프로젝트 디렉터리로 이동합니다. 아래 명령어를 실행하여 컴포넌트를 생성합니다:\n\n## 단계 6\n\n라우팅 구성:\n\n\n\n프로젝트에서 app-routing.module.ts 파일을 열어 새로 생성된 컴포넌트를 포함하도록 라우트 구성을 업데이트해주세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './components/home/home.component';\nimport { ProductComponent } from './components/product/product.component';\nimport { AboutComponent } from './components/about/about.component';\nimport { ContactComponent } from './components/contact/contact.component';\nimport { ProductOfferComponent } from './components/product-offer/product-offer.component';\nimport { ProductUpdatesComponent } from './components/product-updates/product-updates.component';\nimport { RatingComponent } from './components/rating/rating.component';\nimport { FeedbackComponent } from './components/feedback/feedback.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' }, // 기본 경로\n  { path: 'home', component: HomeComponent },\n  {\n    path: 'product/:id', component: ProductComponent,\n    children: [\n      {path: '', redirectTo:'updates', pathMatch:'full'},\n      { path: 'offers', component: ProductOfferComponent },\n      { path: 'updates', component: ProductUpdatesComponent }\n    ]\n  },\n  { path: 'about', component: AboutComponent, \n    children: [\n      {path: 'rating', outlet:'rate', component:RatingComponent},\n      {path: 'feedback', outlet:'feed', component:FeedbackComponent}\n    ]\n  },\n  { path: 'contact', component: ContactComponent },\n  { path: '**', component: HomeComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 구성은 각 경로를 해당 컴포넌트에 매핑합니다.\n\nAngular에서 RouterModule와 Routes는 응용 프로그램에서 라우팅을 구성하고 관리하는 데 사용되는 주요 구성 요소입니다.\n\n\n\n## RouterModule:\n\nRouterModule은 애플리케이션에서 라우팅을 구현하는 데 필요한 지시자, 서비스 및 기능을 제공하는 Angular 모듈입니다.\n\n## Routes:\n\nRoutes는 애플리케이션 내에서 경로 및 구성을 정의하는 배열입니다. Routes 배열 내의 각 route 개체는 해당 경로에 액세스할 때 렌더링될 URL 경로 및 해당 구성 요소를 지정합니다.\n\n\n\n13 번째 줄:\n\nAngular에서 기본 경로를 정의하려면 빈 경로 ''를 Routes 배열 구성에서 경로로 사용할 수 있습니다. 빈 경로에 액세스하면 Angular가 해당 경로에 연결된 컴포넌트를 렌더링합니다.\n\n기본 경로에 액세스할 때 다른 경로로 리디렉션하려면 redirectTo 속성을 사용하여 대상 경로로 이동할 수 있습니다. 또한 pathMatch 속성을 사용하여 경로의 일치 전략을 정의할 수 있습니다.\n\n15 번째 줄부터 22 번째 줄까지:\n\n\n\n제품 세부 정보를 표시하는 id 매개변수가 포함된 경로를 생성하려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n```js\npath: 'product/:id', component: ProductComponent\n```\n\n이 예에서는 경로가 'product/:id'인 경로를 추가하여 제품 세부 정보 페이지를 나타냈습니다. :id 부분은 ProductComponent에서 액세스할 수 있는 동적 매개변수를 나타냅니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { ProductsService } from '../../services/products.service';\n\n@Component({\n  selector: 'app-products',\n  templateUrl: './product.component.html',\n  styleUrls: ['./product.component.css']\n})\nexport class ProductComponent implements OnInit {\n\n  productDetail? : any;\n\n  constructor(private route : ActivatedRoute, private productService : ProductsService) {}\n\n  ngOnInit(): void {\n    let productId = this.route.snapshot.params['id'];\n    this.getProductDetailById(productId)\n  }\n\n  getProductDetailById(id: number) {\n    this.productService.getProductDetailById(id).subscribe(res =\u003e {\n      this.productDetail = res\n      console.log(res)\n    })\n  }\n}\n```\n\n\n\n이 코드에서는 ActivatedRoute 서비스를 주입하여 현재 라우트의 매개변수에 액세스합니다. ngOnInit() 라이프사이클 훅에서는 this.route.snapshot.params['id']를 사용하여 id 매개변수를 검색하고 이를 나중에 구성 요소의 템플릿에서 사용하기 위해 productId 속성에 할당합니다.\n\n마지막으로 URL에 id 값을 제공하여 제품 세부 정보 페이지로 이동할 수 있습니다. 예를 들어 id가 123인 제품이 있다면 http://localhost:4200/product/123로 이동하여 제품 세부 정보를 볼 수 있습니다.\n\nProductComponent는 URL에서 검색한 해당 id 매개변수로 렌더링되며 템플릿에서 관련 제품 정보를 표시하는 데 productId 속성을 사용할 수 있습니다.\n\nProductComponent 아래에 중첩된 자식 구성 요소인 ProductOfferComponent 및 ProductUpdatesComponent를 만들려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n\n\n루트 배열을 업데이트하여 ProductComponent 아래에 자식 라우트를 포함하도록 라우팅 모듈 (예: app-routing.module.ts)을 업데이트하세요:\n\n```js\n{\n  path: 'product/:id', component: ProductComponent,\n  children: [\n    {path: '', redirectTo:'updates', pathMatch:'full'},\n    { path: 'offers', component: ProductOfferComponent },\n    { path: 'updates', component: ProductUpdatesComponent }\n  ]\n}\n```\n\n이 업데이트된 예제에서는 ProductComponent에 자식 라우트를 추가했습니다. 자식 라우트 내의 빈 경로 ''는 /product에 액세스할 때 렌더링할 기본 구성 요소로 ProductComponent에 해당합니다. offers 및 updates 경로는 각각 ProductOfferComponent 및 ProductUpdatesComponent로 매핑됩니다.\n\n\n\nAboutComponent 아래에 중첩된 RatingComponent 및 FeedbackComponent 자식 구성 요소를 만들고, rating 및 feedback을 위한 이름이 지정된 outlet을 사용하려면 Angular에서 라우팅 구성을 다음과 같이 수정할 수 있습니다:\n\n라우팅 모듈(예: app-routing.module.ts)의 Routes 배열을 업데이트하여 AboutComponent 아래에 자식 라우트를 이름이 지정된 outlet과 함께 포함시킵니다:\n\n```js\n{ \n  path: 'about', component: AboutComponent,\n  children: [\n    {path: 'rating', outlet:'rate', component:RatingComponent},\n    {path: 'feedback', outlet:'feed', component:FeedbackComponent}\n  ]\n}\n```\n\n이 업데이트된 예제에서 AboutComponent에 자식 라우트를 추가하고 RatingComponent 및 FeedbackComponent에 대해 각각 이름이 지정된 outlet rate 및 feed을 지정했습니다.\n\n\n\nAboutComponent 템플릿(about.component.html)을 구현하여 이름이 지정된 outlet(출구) 플레이스홀더를 포함하도록 합니다. 예를 들어:\n\n```js\n\u003cp\u003eLorem ipsum dolor sit, amet consectetur adipisicing elit. Tenetur magni saepe sint, vel eaque veniam recusandae laboriosam numquam necessitatibus? Laborum mollitia excepturi qui. Modi corporis quasi ab minima eligendi numquam!\u003c/p\u003e\n\n\u003cdiv class=\"row\"\u003e\n    \u003cdiv class=\"col-md-6\"\u003e\n        \u003crouter-outlet name=\"rate\"\u003e\u003c/router-outlet\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"col-md-6\"\u003e\n        \u003crouter-outlet name=\"feed\"\u003e\u003c/router-outlet\u003e        \n    \u003c/div\u003e\n\u003c/div\u003e\n```\n\n이 템플릿에서는 'rate' 및 'feed'로 설정된 이름 속성을 가진 두 개의 `router-outlet` 플레이스홀더를 추가했습니다. 이 플레이스홀더는 AboutComponent 템플릿 내에서 RatingComponent 및 FeedbackComponent를 렌더링하는 데 사용될 것입니다.\n\nRatingComponent 및 FeedbackComponent의 컴포넌트 파일을 필요에 맞게 업데이트하십시오.\n\n\n\nAbout 및 Child 컴포넌트로 이름이 지정된 outlet을 사용하여 이동할 수 있습니다. 예를 들어, rating 컴포넌트에 액세스하려면 http://localhost:4200/about/(rate:rating//feed:feedback) 로 이동하면 됩니다.\n\n저는 앱 컴포넌트에서 아래에 보여드린대로 외부 링크를 만들었습니다. 그러나 필요에 따라 URL을 생성할 수 있습니다. 그 경우 적절한 라우터 링크와 outlet이 필요합니다.\n\n```js\n\u003ca class=\"nav-link\" [routerLink]=\"['/about',{\n  outlets:{\n    'rate': ['rating'],\n    'feed': ['feedback']\n  }\n}]\"\u003eAbout\u003c/a\u003e\n```\n\n30번째 줄:\n\n\n\n앵귤러에서 이중 별표 (**) 루트는 와일드카드 루트 또는 캐치-올 루트라고도 알려진데, 미리 정의된 루트와 일치하지 않는 루트를 처리하는 데 사용됩니다. 이는 응용 프로그램 내에서 알 수 없는 또는 잘못된 URL을 처리하는 폴백 루트 역할을 합니다.\n\n와일드카드 루트를 정의하려면 루트 배열 끝에 경로가 '**'인 구성을 추가할 수 있습니다. 이 루트는 요청된 URL과 일치하는 다른 루트가 없을 때 일치됩니다.\n\n```js\n{ path: '**', component: HomeComponent }\n```\n\n7단계\n\n\n\n앱 컴포넌트 뷰에서 라우터 아웃렛을 언급하여 네비게이션에 따라 다른 컴포넌트를 조건부로 렌더링하세요.\n\n```js\n\u003cnav class=\"navbar navbar-expand-lg bg-body-tertiary\"\u003e\n  \u003cdiv class=\"container-fluid\"\u003e\n    \u003ca class=\"navbar-brand\" href=\"#\"\u003e\n      \u003cimg src=\"../assets/logo/coder.png\" class=\"navlogo\"/\u003e 제품 어플리케이션\n    \u003c/a\u003e\n    \u003cbutton class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarNavAltMarkup\" aria-controls=\"navbarNavAltMarkup\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"\u003e\n      \u003cspan class=\"navbar-toggler-icon\"\u003e\u003c/span\u003e\n    \u003c/button\u003e\n    \u003cdiv class=\"collapse navbar-collapse\" id=\"navbarNavAltMarkup\"\u003e\n      \u003cdiv class=\"navbar-nav\"\u003e\n        \u003ca class=\"nav-link\" [routerLink]=\"['/about', {\n          outlets: {\n            'rate': ['rating'],\n            'feed': ['feedback']\n          }\n        }]\"\u003eAbout\u003c/a\u003e\n        \u003ca class=\"nav-link\" routerLink=\"/contact\"\u003eContact\u003c/a\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/nav\u003e\n\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n![라우팅 이미지 1](/assets/img/2024-05-14-RoutinginAngular_2.png)\n\n![라우팅 이미지 2](/assets/img/2024-05-14-RoutinginAngular_3.png)\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-RoutinginAngular_4.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-RoutinginAngular_5.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-14-RoutinginAngular_6.png\" /\u003e\n\n그래서, 이것이 Angular에서 라우팅에 대한 모든 것입니다.\n\n\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/angular-routing\n\n# 결론\n\n이 글에서는 Angular에서 라우팅의 이점과 Angular 15에서 서로 다른 컴포넌트를 만든 후 단계별 구현에 대해 설명했습니다.\n\n\n\n행복한 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-RoutinginAngular_0.png"},"coverImage":"/assets/img/2024-05-14-RoutinginAngular_0.png","tag":["Tech"],"readingTime":12},{"title":"잠시만, 종 TypeScript를 잘못 사용하는 이유입니다","description":"","date":"2024-05-14 13:35","slug":"2024-05-14-ZodWhyyoureusingTypeScriptwrong","content":"\n\n![이미지](/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png)\n\n간략 요약: 런타임에서 외부 데이터를 검증해야 합니다.\n\n웹 개발 경험이 있다면, API에서 외부 데이터를 다룰 때 런타임 오류를 반드시 마주쳐보았을 것입니다. TypeScript를 사용하면 애플리케이션 전체에서 모든 데이터의 구조와 유형을 상기시켜 주어 이러한 오류를 크게 줄일 수 있습니다. 그러나 TypeScript는 컴파일 중에 알려진 데이터에 대한 불가능한 작업을 방지하는 데 강점을 가지고 있지만, 외부(다른 말로, 알 수 없는) 데이터에 대해서는 너무 관대할 수 있습니다.\n\n본 문서에서는 TypeScript를 사용하여 런타임에서 실패할 수 있는 코드를 작성할 수 있게 하는 이유와 Zod가 이러한 데이터 관련 오류를 방지할 수 있는 방법에 대해 설명하겠습니다.\n\n\n\n# TypeScript의 목표\n\n소개에서 말했듯이, TypeScript의 아이디어는 전체 코드에서 모든 데이터의 구조와 유형을 추적하는 것입니다. 이는 IDE에서 자동완성을 제공하는 데 도움이 되는 것뿐만 아니라 런타임 중에 오류를 일으킬 수있는 유효하지 않은 작업을 방지하기도 합니다. 이론적으로 TypeScript 컴파일 중에 발생할 수 있는 모든 런타임 오류를 예측하고 식별할 수 있습니다. 그러나 실제론 그렇지 않습니다.\n\n## TypeScript는 목표를 달성하지 못했을까요?\n\n실제로 TypeScript의 주요 목표는 생산성을 향상시키는 것입니다. 이것은 TypeScript가 언제나 \"안전\"보다는 생산성을 선택한다는 것을 의미합니다.\n\n\n\n있는 것은 any 타입입니다. 그러나 널리 받아들여지는 것은 사용하지 말아야 한다는 것입니다. 그러나 우리 코드에서 any를 하나도 쓰지 않는다고 해서 우리 애플리케이션이 런타임 오류에 면역이라는 뜻은 아닙니다. 다음 스니펫을 살펴보세요:\n\n```js\nconst obviouslyAnArticle: Article = JSON.parse(input); // input is a string\n```\n\nJSON.parse의 반환 타입이 any인데, 이는 명시적으로 타입이 지정된 변수(이 예에서는 Article)와 연관시킬 수 있습니다. 우리 자신으로부터 명시적으로 작성하지 않아도 TypeScript에게 우리가 any로 작성하지 않고도 파싱된 내용이 Article 타입을 충족하지 않을 수 있는 런타임 가능성을 무시하도록 알려주고 있는 것입니다.\n\n## unknown 및 단언(assertions)\n\n\n\n만약 '어느' 대신 '모든'이 사용되었다면 위 조각을 만들 수 없었을 것입니다. 대신 as 키워드를 사용하여 명시적인 주장을 작성해야 합니다:\n\n```js\nconst shouldBeAnArticle = JSON.parse(input) as Article;\n```\n\n이 구문을 사용하면 TypeScript에게 명시적으로 경계를 낮추도록 지시합니다. 여전히 좋지 않지만 숨겨지지 않았어요!\n\n## 유형 좁히기 식\n\n\n\n위험한 유형 단언을 의존하는 대신, 유형 축소 표현식을 사용할 수 있어요.\n\n예를 들어, JavaScript에서 제공하는 typeof 연산자는 객체의 유형을 런타임 중에 결정할 수 있어요.\n\n```js\nconsole.log(typeof 42);\n// 기대하는 출력: \"number\"\n```\n\n조건문에서 사용되면 TypeScript는 객체의 유형을 축소할 수 있어요.\n\n\n\n```js\nif(typeof input === \"string\") {\n    // input이 문자열 형식으로 좁혀졌습니다.\n    submit(input.toLowerCase());\n}\n```\n\n이 표현은 TypeScript에게 해당 범위에서 input이 문자열만 가능함을 예측할 수 있도록 해줍니다.\n\n## 타입 추론\n\nTypeScript는 다른 표현식들로 타입을 좁힐 수 있지만, 이는 보통 유니언 혹은 원시 타입을 구체화할 때 의미가 있습니다. 이를 \"타입의 차별\"이라고 부릅니다.\n\n\n\n```js\ntype Fish = { swim: () =\u003e void };\ntype Bird = { fly: () =\u003e void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    // input is narrowed to the type Fish\n    return animal.swim();\n  }\n  // input is narrowed to the type Bird\n  return animal.fly();\n}\n```\n\n위 예제에서 키워드 in은 TypeScript가 animal 객체의 유형을 식별하도록 합니다.\n\n알 수 없는 데이터의 경우, 유형 판별은 시간 낭비일 수 있습니다:\n\n```js\nif(typeof input !== \"string\") {\n    // input is still unkown\n}\n```\n\n\n\n외부 데이터에 대해 유형 좁히기 표현식에만 의존할 수 없다는 뜻이에요. 유형을 좁히기 위한 또 다른 방법이 필요합니다: 데이터 유효성 검사.\n\n# Zod가 도와줍니다\n\nZod는 기본적으로 객체 스키마 유효성 검사 도구입니다. 이는 정의된 스키마를 가진 모든 객체의 유효성을 런타임에서 보장할 수 있다는 뜻이에요.\n\n## 스키마 선언\n\n\n\nZod을 사용할 때 첫 번째 할 일은 스키마를 정의하는 것입니다.\n\n```js\nimport * as z from \"zod\";\n\nconst userSchema = z.object({\n    id: z.number(),\n    name: z.string(),\n    age: z.number().optional()\n}).strict();\n```\n\n만약 이전에 yup이나 joi와 같은 유효성 검사 도구를 사용해본 적이 있다면, 이 방법에 익숙할지도 모릅니다. Zod은 object(), string()과 같은 여러 함수를 제공하며, 각 함수는 Zod 스키마를 반환하고 이를 조합하여 더 큰 스키마를 만들 수 있습니다.\n\n각 스키마 조각은 .optional()과 같은 메소드를 사용하여 \"새롭게 정의\"될 수 있으며, 이를 통해 복잡한 유효성 검사 규칙을 얻을 수 있습니다.\n\n\n\n## 스키마 사용하기\n\n스키마는 데이터를 유효성 검사하는 두 가지 방법을 제공합니다. .parse() 메서드는 에러를 throw할 수 있고, .safeParse() 메서드도 그렇습니다:\n\n```js\nconst result = userSchema.safeParse(input);\nif (!result.success) {\n  result.error;\n} else {\n  result.data; // 데이터 유형은 userSchema에서 유추됩니다\n}\n```\n\n파싱이 실패하거나 정의된 유효성 검사 스키마와 일치하는 객체가 반환됩니다. 이 경우 객체는 스키마 구조에서 추론된 유형을 상속받습니다.\n\n\n\n## 스키마로부터 타입 추론하기\n\n일반적으로 데이터는 여러 범위와 문맥에서 공유됩니다. 이러한 이유로 우리는 보통 한번만 타입 별칭을 선언하고 나서 데이터가 전달되는 모든 곳에서 사용합니다. Zod는 z.infer`` 제네릭을 제공하여 스키마에서 추론된 타입에 액세스할 수 있습니다.\n\n```js\ntype Article = z.infer\u003ctypeof articleSchema\u003e;\n```\n\n# Zod 실용적 사용법\n\n\n\n따라서, TypeScript 프로젝트에서 Zod를 사용하는 경우는 어디인가요?\n\n## API 응답 구문 분석\n\n알 수 없거나 예측할 수 없는 데이터의 주요 원천은 API 응답입니다. fetch promise에서 오는 데이터를 수동으로 유효성을 검사할 수 있습니다.\n\n```js\nfetch(getArticle)\n  .then((response) =\u003e response.json())\n  .then((data) =\u003e {\n    return articleSchema.parse(data);\n  })\n  .catch(console.error);\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경할 수도 있어요. \n\n## 양식 데이터 유효성 검사\n\n사용자 입력 또한 외부 데이터의 하나이죠. Zod는 문자열 유효성 검사를 위한 내장 유틸리티를 제공해요. 물론, .refine() 메서드를 사용하여 자신만의 규칙을 구현할 수도 있어요.\n\n```js\nconst myString = z.string().refine((val) =\u003e val.length \u003c= 255, {\n  message: \"문자열은 255자를 초과할 수 없어요\",\n});\n```\n\n\n\n만약 React를 사용 중이라면, React Hook Form에서 양식 유효성 검사를 위해 Zod 스키마를 사용할 수 있어요.\n\n## 구분하는 유형?\n\n저는 버전 1부터 Zod를 사용하기 시작했어요. 이 버전에는 .check() 메서드가 포함되어 스키마를 유형 가드로 사용할 수 있게 되었는데, 이는 유형을 구분하는 조건으로 사용될 수 있었어요.\n\n이 기능 때문에 “full-schema\" 접근 방식을 선택하고 Zod를 유효성 검사 및 유형 구분 모두에 사용하게 되는 것이 유혹스러웠어요. 그러나 이 방식을 취하는 것은 빠르게 시간이 낭비되는 것으로 나타났어요.\n\n\n\n해당 메서드는 라이브러리의 다음 버전에서 삭제되었습니다. 이것은 좋은 일이에요. 왜냐하면 Zod는 이제 외부 데이터 유효성 검사에 집중하고 있거든. 타입 축소 표현은 대부분의 상황에서 충분히 유용해서 타입 판별에 좋은 도구가 됐어요.\n\n# 요약\n\nTypeScript는 기본적으로 너무 관대해요. 더 안전한 코드를 작성하려면 외부 데이터(본질적으로 알 수 없는 데이터)를 Zod와 같은 도구로 유효성을 검사해야 해요. Zod는 폼 입력이나 API 응답과 같이 예측할 수 없는 데이터를 유효성 검사하는 데 가장 유용해요. 그 외의 대부분의 시나리오에서는 타입 축소 표현만으로 충분할 거에요.","ogImage":{"url":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png"},"coverImage":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png","tag":["Tech"],"readingTime":5},{"title":"블렌더를 Threejs와 통합하기 웹 상의 3D 콘텐츠 가능성 발휘하기","description":"","date":"2024-05-14 13:34","slug":"2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb","content":"\n\n\n![이미지](/assets/img/2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb_0.png)\n\n3D 그래픽과 웹 개발 분야에서 Blender와 Three.js의 시너지는 웹을 위한 놀라운 상호작용형 경험을 만들기위한 탁월한 기회를 제공합니다. Blender는 강력한 오픈 소스 3D 모델링 및 애니메이션 소프트웨어로, Three.js는 웹 브라우저에서 3D 그래픽을 렌더링하기위한 JavaScript 라이브러리와 원활하게 통합됩니다. 이 두 도구가 결합되어 개발자와 디자이너를 위한 무한한 가능성을 열어보겠습니다.\n\n# Blender의 파워 활용하기\n\nBlender는 복잡한 3D 모델, 애니메이션 및 장면을 정밀하고 유연하게 만드는 데 기초 역할을 합니다. 복잡한 캐릭터 디자인에서 사실적인 건축 렌더링까지, Blender는 예술가와 디자이너가 창의적인 비전을 디지털 형식으로 구현할 수 있게 돕습니다. Blender의 강력한 기능 세트에는 다음이 포함됩니다:\n\n\n\n\n- 모델링 도구: Blender는 3D 기하학을 만들고 조작하기 위한 포괄적인 모델링 도구 모음을 제공합니다. 유기적 모양을 조각하거나 건축 요소를 디자인하는 경우, Blender는 아이디어를 실현하기 위해 필요한 유연성과 제어를 제공합니다.\n- 텍스처 및 재질: Blender의 텍스처 페인팅 및 재질 편집 기능을 통해 예술가들은 3D 모델에 현실적이고 세밀한 디테일을 추가할 수 있습니다. 생생한 표면을 만들거나 금속, 나무, 천과 같은 다양한 재질을 시뮬레이션하는 것부터, Blender는 예술가들이 놀라운 시각적 효과를 달성할 수 있도록 합니다.\n- 애니메이션 및 리깅: Blender의 강력한 애니메이션 도구를 사용하면 예술가들이 그들의 작품에 생명을 불어넣을 수 있습니다. 캐릭터 애니메이션, 기계 리깅 또는 동적 시뮬레이션인 경우, Blender는 순조로운 표현적인 동작을 만들기 위해 필요한 도구를 제공합니다.\n- 렌더링 엔진: Blender의 내장 Cycles 렌더러는 고급 조명 및 셰이딩 효과를 통해 고품질의 사실적인 랜더링을 제공합니다. 예술가들은 프로젝트에 원하는 모습과 느낌을 얻기 위해 랜더링 프로세스의 모든 측면을 세밀하게 조정할 수 있습니다.\n\n# Three.js로 모델 내보내기\n\nBlender에서 3D 모델과 애니메이션을 만든 후, 해당 모델을 Three.js로 내보내 웹 기반 애플리케이션에 통합할 수 있습니다. Blender 자산을 Three.js로 내보내는 여러 가지 방법이 있습니다:\n\n- JSON으로 내보내기: Blender는 \"Three.js Export\"와 같은 플러그인을 제공하여 사용자가 모델과 애니메이션을 JSON 형식으로 내보낼 수 있도록 합니다. 이렇게 내보낸 파일은 적절한 로더를 사용하여 Three.js 애플리케이션에 직접로드할 수 있습니다.\n- glTF 형식 사용: Blender는 다양한 애플리케이션 간에 3D 모델과 씬을 전송하는 데 널리 사용되는 glTF(GL Transmission Format) 형식을 지원합니다. 사용자는 Blender 자산을 glTF 파일로 내보내고 그런 다음 해당 로더를 사용하여 Three.js에 로드할 수 있습니다.\n- 사용자 정의 내보내기 스크립트: 보다 복잡한 프로젝트 또는 특정 요구 사항의 경우, 개발자는 Python을 사용하여 Blender에서 사용자 정의 내보내기 스크립트를 작성할 수 있습니다. 이 스크립트는 Blender 씬을 Three.js와 호환되는 형식으로 내보내며 내보내기 프로세스를 완전히 제어할 수 있습니다.\n\n\n\n# Three.js와 통합하기\n\nBlender 자산을 내보낸 후에는 Three.js 애플리케이션에 심도있는 웹 경험을 만들기 위해 매끄럽게 통합시킬 수 있습니다. Three.js는 다음과 같은 다양한 로더(loader)와 유틸리티(utilities)를 제공하여 외부 자산을 가져오기 위한 기능을 제공합니다:\n\n- 오브젝트 로딩: Three.js는 Blender에서 내보낸 3D 모델, 텍스처 및 애니메이션을 가져오기 위한 로더(loader)를 제공합니다. 이러한 로더는 외부 파일의 파싱(parsing) 및 변환을 처리하여 브라우저에서 조작하고 렌더링할 수 있는 Three.js 객체로 변환합니다.\n- 재질 처리: Three.js는 재질(material) 및 셰이더(shader)를 지원하여 개발자가 가져온 Blender 모델에 텍스처, 색상 및 효과를 적용할 수 있게 합니다. Three.js의 재질 시스템을 활용하여 예술가는 다양한 플랫폼과 브라우저에서 일관된 렌더링을 달성할 수 있습니다.\n- 애니메이션 재생: Three.js는 Blender에서 내보낸 애니메이션(키프레임 애니메이션, 스켈레톤 애니메이션 및 모프 타겟 애니메이션)의 재생을 지원합니다. 개발자는 애니메이션의 타이밍, 재생 속도 및 보간을 제어하여 동적이고 인터랙티브한 장면을 만들 수 있습니다.\n\n# 실용적인 응용\n\n\n\n블렌더와 쓰리.js의 통합은 웹 개발에 다양한 실용적인 응용 프로그램을 제공합니다. 다음은 몇 가지 예시입니다:\n\n- 대화형 제품 쇼케이스: 제품을 대화형 3D 환경에서 쇼케이스하여 사용자가 어떤 각도에서든 회전, 줌, 탐험할 수 있습니다.\n- 가상 투어 및 워크스루: 블렌더로 만든 에셋을 사용하여 건축 공간, 박물관 또는 부동산을 이동하며 몰입형 가상 투어를 만들 수 있습니다.\n- 교육 콘텐츠: 애니메이션 다이어그램, 시뮬레이션 및 시각화를 활용하여 상호 작용적 교육 콘텐츠를 개발하여 학습 경험을 향상시킬 수 있습니다.\n- 게임 및 엔터테인먼트: 블렌더로 제작한 에셋 및 쓰리.js 렌더링을 활용하여 웹 기반 게임과 대화형 엔터테인먼트 경험을 디자인하고 배포할 수 있습니다.\n\n# 결론\n\n블렌더와 쓰리.js의 통합은 창의력과 기술의 강력한 결합을 상징하며, 개발자와 디자이너들이 웹 기반 3D 콘텐츠의 경계를 넓히도록 돕습니다. 블렌더의 고급 모델링 및 애니메이션 기능을 쓰리.js의 실시간 렌더링과 상호 작용성과 결합하면, 창작자는 웹에서 관객들을 사로잡는 몰입적이고 매료되는 경험을 전달할 수 있습니다. 대화형 제품 데모, 가상 투어, 교육 콘텐츠 또는 게임 등에 대해, 블렌더와 쓰리.js의 조합은 디지털 영역에서 혁신과 표현의 무한한 가능성을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb_0.png"},"coverImage":"/assets/img/2024-05-14-IntegratingBlenderwithThreejsUnleashingthePotentialof3DContentontheWeb_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs와 MongoDB를 사용하여 OTP 인증 시스템 구축하기","description":"","date":"2024-05-14 13:33","slug":"2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB","content":"\n\n요즘의 디지털 세계에서는 보안이 매우 중요합니다. 특히 사용자 인증 프로세스에서 보안을 강화하는 일반적인 방법 중 하나는 일회용 비밀번호(OTP) 확인입니다. OTP는 사용자가 자격 증명과 함께 입력해야 하는 고유한 코드를 생성하여 보안의 추가적인 계층을 더합니다. 이 튜토리얼에서는 Node.js와 MongoDB를 사용하여 OTP 확인 시스템을 구축하는 과정을 단계별로 안내하겠습니다.\n\n![이미지](/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png)\n\n# 저와 소통하기:\n\nLinkedin: [링크](https://www.linkedin.com/in/suneel-kumar-52164625a/)\n\n\n\n사전 준비 사항: 구현에 들어가기 전에 다음을 설치했는지 확인하세요:\n\n- Node.js: 시스템에 Node.js가 설치되어 있는지 확인하세요. 공식 Node.js 웹사이트에서 다운로드할 수 있습니다.\n- MongoDB: 사용자 데이터 및 OTP 정보를 저장할 MongoDB를 설치하세요. 공식 MongoDB 웹사이트에서 다운로드할 수 있습니다.\n- 텍스트 편집기: 원하는 텍스트 편집기나 IDE를 선택하세요. VS Code, Sublime Text 또는 Atom이 인기 있는 선택지입니다.\n\n프로젝트 설정: 프로젝트 디렉토리를 설정하고 필요한 종속성을 설치하는 것으로 시작해봅시다. 터미널을 열고 다음 단계를 따르세요:\n\n- 프로젝트용 새 디렉토리를 만드세요:\n\n\n\n```js\nmkdir otp-verification-system\ncd otp-verification-system\n```\n\n새로운 Node.js 프로젝트를 초기화하세요:\n\n```js\nnpm init -y\n```\n\n필요한 종속성을 설치하세요:\n\n\n\n```js\nnpm install express mongoose twilio dotenv body-parser\n```\n\n- express: 웹 서버를 만들기 위해 사용됩니다.\n- mongoose: MongoDB와 상호 작용하기 위해 사용됩니다.\n- twilio: SMS를 통해 OTP를 전송하는 데 사용됩니다.\n- dotenv: 환경 변수를 관리하기 위해 사용됩니다.\n- body-parser: 들어오는 요청 본문을 구문 분석하기 위한 미들웨어입니다.\n\n이제 프로젝트가 설정되었으므로 OTP 인증 시스템을 구축할 차례입니다.\n\nMongoDB 설정: 먼저 MongoDB 데이터베이스를 설정해보겠습니다. 프로젝트 디렉토리에 db.js라는 파일을 생성하고 다음 코드를 추가하세요:\n\n\n\n\n```js\nconst mongoose = require('mongoose');\n\nfunction connect() {\n  return new Promise((resolve, reject) =\u003e {\n    mongoose.connect('mongodb://localhost/otp_verification', {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n\n    const db = mongoose.connection;\n\n    db.on('error', error =\u003e {\n      console.error('MongoDB 연결 오류:', error);\n      reject(error);\n    });\n\n    db.once('open', () =\u003e {\n      console.log('MongoDB에 연결되었습니다');\n      resolve();\n    });\n  });\n}\n\nmodule.exports = { connect };\n```\n\n이 코드는 로컬 MongoDB 인스턴스에 연결하고 otp_verification이라는 이름의 데이터베이스를 생성합니다.\n\n사용자 모델 생성: 이제 사용자 정보를 저장할 사용자 모델을 만들어 봅시다. models/User.js 파일을 생성하고 다음 코드를 추가하세요:\n\n```js\nconst mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  username: String,\n  phone: String,\n  otp: String,\n  otpExpiration: Date,\n});\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n\n\n이 스키마는 MongoDB의 사용자 문서 구조를 정의합니다. 여기에는 사용자 이름, 전화번호, OTP 및 OTP 만료 시간 필드가 포함됩니다.\n\nOTP 생성 및 전송: 이제 SMS를 통해 OTP를 생성하고 전송하는 로직을 만들어 봅시다. 이를 위해 Twilio API를 사용하겠습니다. utils/otp.js라는 파일을 만들고 다음 코드를 추가하세요:\n\n```js\nconst twilio = require('twilio');\nconst dotenv = require('dotenv');\n\ndotenv.config();\n\nconst accountSid = process.env.TWILIO_ACCOUNT_SID;\nconst authToken = process.env.TWILIO_AUTH_TOKEN;\nconst client = new twilio(accountSid, authToken);\n\nasync function sendOTP(phone, otp) {\n  try {\n    const message = await client.messages.create({\n      body: `Your OTP is: ${otp}`,\n      from: process.env.TWILIO_PHONE_NUMBER,\n      to: phone,\n    });\n    console.log(`OTP sent to ${phone}: ${message.sid}`);\n  } catch (error) {\n    console.error('Error sending OTP:', error);\n  }\n}\n\nmodule.exports = { sendOTP };\n```\n\nTwilio 계정을 설정하고 필요한 자격 증명(Account SID, Auth Token 및 전화번호)을 얻었는지 확인하십시오. 이 정보는 .env 파일에 저장되어야 합니다.\n\n\n\nOTP 인증 엔드포인트 구현하기: 이제 OTP 인증을 처리하는 엔드포인트를 만들어 봅시다. routes/auth.js라는 파일을 만들고 아래 코드를 추가해주세요:\n\n```js\nconst express = require('express');\nconst router = express.Router();\nconst User = require('../models/User');\nconst { sendOTP } = require('../utils/otp');\nconst {randomInt} = require('crypto')\n\nrouter.post('/sendotp', async (req, res) =\u003e {\n  const { phone } = req.body;\n\n  // 6자리 OTP 생성\n  //const otp = Math.floor(100000 + Math.random() * 900000).toString();\n  const otp =  randomInt(100000, 999999);\n\n  try {\n    // OTP 및 만료 시간을 데이터베이스에 저장\n    const user = await User.findOneAndUpdate(\n      { phone },\n      { otp, otpExpiration: Date.now() + 600000 }, // OTP는 10분 후에 만료됨\n      { upsert: true, new: true }\n    );\n\n    // SMS로 OTP 전송\n    await sendOTP(phone, otp);\n\n    res.status(200).json({ success: true, message: 'OTP 전송 성공' });\n  } catch (error) {\n    console.error('OTP 전송 중 오류 발생:', error);\n    res.status(500).json({ success: false, message: 'OTP 전송 실패' });\n  }\n});\n\nrouter.post('/verifyotp', async (req, res) =\u003e {\n  const { phone, otp } = req.body;\n\n  try {\n    // 전화번호와 OTP로 사용자 찾기\n    const user = await User.findOne({ phone, otp });\n\n    if (!user || user.otpExpiration \u003c Date.now()) {\n      return res.status(400).json({ success: false, message: '유효하지 않은 OTP' });\n    }\n\n    // 성공적으로 확인된 후 OTP 및 만료 시간 비우기\n    user.otp = undefined;\n    user.otpExpiration = undefined;\n    await user.save();\n\n    res.status(200).json({ success: true, message: 'OTP 확인 성공' });\n  } catch (error) {\n    console.error('OTP 확인 중 오류 발생:', error);\n    res.status(500).json({ success: false, message: 'OTP 확인 실패' });\n  }\n});\n\nmodule.exports = router;\n```\n\n이 코드는 /sendotp 엔드포인트로 OTP를 생성하고 전송하고, /verifyotp 엔드포인트로 사용자가 입력한 OTP를 확인합니다.\n\n서버 시작하기: 마지막으로 애플리케이션을 시작하기 위한 주 서버 파일을 생성해봅시다. server.js라는 파일을 만들고 아래 코드를 추가해주세요:\n\n\n\n```js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst { connect } = require('./db'); // db.js에서 connect 함수를 가져옴\nconst authRoutes = require('./routes/auth');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// 미들웨어\napp.use(bodyParser.json());\n\n// 라우트\napp.use('/auth', authRoutes);\n\n// 서버를 시작하기 전에 데이터베이스에 연결\nconnect()\n  .then(() =\u003e {\n    // 서버 시작\n    app.listen(PORT, () =\u003e {\n      console.log(`서버가 ${PORT} 포트에서 실행 중입니다.`);\n    });\n  })\n  .catch(error =\u003e {\n    console.error('데이터베이스 연결 중 오류 발생:', error);\n  });\n```\n\n이 코드는 Express 서버를 설정하고, 수신된 JSON 요청을 파싱하며, 인증을 위한 라우트를 정의합니다.\n\n결론: 축하합니다! Node.js와 MongoDB를 사용하여 OTP(일회용 비밀번호) 확인 시스템을 성공적으로 구축했습니다. SMS로 전송된 일회용 비밀번호를 통해 사용자의 신원을 확인함으로써 응용 프로그램에 추가적인 보안층을 추가했습니다. OTP 확인을 기반으로 한 이메일, 요청 속도 제한, 오류 처리 기능을 추가함으로써 이 시스템을 확장하실 수 있습니다.\n\n이 튜토리얼에서 다룬 내용:\n  \n\n\n\n- 사용자 데이터 저장을 위해 MongoDB 설정하기\n- Twilio를 사용하여 SMS를 통해 OTP 생성 및 전송\n- OTP 인증 엔드포인트 구현하기","ogImage":{"url":"/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png"},"coverImage":"/assets/img/2024-05-14-BuildinganOTPVerificationSystemwithNodejsandMongoDB_0.png","tag":["Tech"],"readingTime":6},{"title":"웹 음성 API 무엇이 동작하고, 무엇이 동작하지 않으며, GPT 언어 모델과 연결하여 향상시키는 방법","description":"","date":"2024-05-14 13:30","slug":"2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel","content":"\n\n![웹 스피치 API가 작동하는 방식이 무엇이고, 어떻게 개선할 수 있는지에 대한 리스트와 GPT 언어 모델과 연결하는 방법](/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png)\n\n현대 기술들은 현재 소프트웨어가 제안하는 것보다 훨씬 간단하고 자연스러운 인간-컴퓨터 상호작용을 가능케 한다는 생각을 가지고 있어요. 사실, 저는 기술들이 충분히 성숙해져서 전통적인 인터페이스 없이도 사용자 경험에 혁명을 가져갈 수 있다고 생각해요.\n\n대형 언어 모델은 특히 정보 요청하는 방식에서 이러한 혁명의 한 단계를 촉발했습니다. 하지만, 제 생각에는 기술들이 더 많은 것을 제공할 수 있다고 봐요. 예를 들어, VR 헤드셋 비용이 점차 낮아지더라도 아직도 평평한 화면에 크게 의존하고 있고; 눈금, 음성 인식, 신체 부위 추적과 같은 기술들이 발전함에도 마우스, 키보드 및 터치 동작을 사용하고 있고; 음성 합성이 크게 발전했음에도 여전히 많은 것을 읽는 것에 그친 채 있어요.\n\n본 기사를 통해 저는 이미 잘 작동하는 현대 기술들로 인해 인간-컴퓨터 상호작용이 영원히 변할 수 있다는 것에 헌신하는 짧은 시리즈를 시작하려고 해요. 제가 공유할 코드 조각과 예시 앱을 통해 직접 테스트해보실 수 있을 거예요.\n\n\n\n저는 내 스타일을 유지하며, 이 모든 현대 기술의 웹 기반 구현에 대해 구체적으로 이야기하겠습니다. 그리고 여기서 웹 브라우저에 통합된 웹 음성 API로 시작하여 그 강점을 논의하고 일부 사용 사례를 보여주며 한계를 강조하고 일부 한계를 커버하는 방법에 대해 구체적으로 설명해 보겠습니다.\n\n# (현대) 음성 인식과 음성 합성\n\n특히 두 가지 기술, 음성 인식과 음성 합성은 거의 20년 동안 존재해 오며 더 자연스러운 인간과 컴퓨터 간 상호 작용을 도와줄 많은 것을 제공합니다.\n\n음성 인식 또는 ASR(Automatic Speech Recognition) 또는 STT(Speech-To-Text)는 구어를 쓰여진 텍스트로 변환합니다. 주요 넓은 적용 분야가 두 개 있습니다:\n\n\n\n- 명령어를 자연스럽게 발화하여 스마트폰이나 컴퓨터와 같은 하드웨어를 제어합니다. 스마트폰이나 Alexa 또는 Siri를 음성 명령을 통해 사용하는 방식을 생각해보세요.\n- 대화 내용을 필사하고(그리고 아마도 그 후에 표시하거나 저장하거나 분석함)하는 작업입니다. 회의 필사, 비디오 자막 등을 생각해보세요.\n\n두 응용 프로그램은 이 블로그 글의 주제와 직접적으로 관련이 있으며, 웹 프로그래머를 위해 Web Speech API를 통해 구현되었습니다.\n\n음성 합성 또는 TTS(텍스트를 음성으로 변환)는 쓰여진 텍스트를 말로 변환합니다. 이를 통해 컴퓨터 및 다른 장치가 인간과 유사한 말을 생성하여 정보를 청각적으로 액세스할 수 있게 되었습니다. 여기 Medium 기사에서 보는 것처럼 음성으로도 정보를 듣을 수 있게 해줍니다.\n\n음성 합성은 시각 장애인을 위한 접근성 기능, 대화형 음성 응답 시스템 및 멀티미디어 콘텐츠 보강을 포함한 다양한 시나리오에 적용됩니다.\n\n\n\nSTT와 TTS를 함께 사용하면 디지털 콘텐츠와의 상호작용이 더 포괄적이고 다양해지며, 무손실 및 화면 없이 작동하는 기회와 맞춤형 사용자 경험을 열어줍니다.\n\n## 음성 인식 및 합성 기술의 역사 개관\n\n음성 인식과 합성 기술은 특히 최신 AI 모델의 통합과 기계 학습 기술의 발전으로 지속적인 발전을 이루었습니다. 초기 시도가 컴퓨터를 언어 처리에 사용하려는 20세기 중반으로 거슬러 올라갑니다. 초기 모델은 발음, 방언, 동음이의어 및 언어적 미묘함에 대한 도전을 겪었으며, 음성 생성 및 이해 모두에서 직면했습니다. 통계 모델과 상징적 자연 언어 처리의 발전으로 ASR 시스템이 점차 향상되었지만, 2010년대 후반에 트랜스포머의 등장으로 ASR에서 특히 기반을 둔 획기적인 발전이 이루어졌습니다. \n\nSTT는 TTS보다 변수가 많아 다소 복잡하지만, 가장 현대적인 방법은 매우 잘 작동합니다. 이에 대해 자세히 다루지는 않겠습니다. 현대 STT는 여러 단계와 AI 모델이 협력하는 복잡한 프로세스를 포함합니다. 주요 단계는 오디오 입력의 전처리, 특징 추출, 음소 추출, 언어 모델 의사 결정 및 단어 시퀀스로의 디코딩이 포함됩니다. 현대 ASR 모델은 종종 모든 단계에서 트랜스포머를 사용하여 정보의 장거리 결합을 보존하여 정확도와 일관성을 향상시킵니다. 가장 선진적인 ASR 시스템에는 핵심 모듈에 직접 내장된 언어 모델 요소가 포함되어 있습니다. 이러한 내장 통합은 높은 전사 및 인식 정확도에 중요한 역할을 하였습니다.\n\n\n\n현대 ASR 및 TTS 기술은 실제로 단순한 음성인식 또는 합성 이상으로 한 걸음 더 나아가 \"말하는 언어의 이해\"에 근접할 수 있습니다. 가장 고급 스피치 투 텍스트(STT) 및 텍스트 투 스피치(TTS) 모델은 여러 언어로 오디오를 텍스트로 전사하거나 텍스트에서 오디오를 합성할 수 있으며, 일부는 언어를 자동으로 식별하고 맥락에 적응하며, 다양한 화자를 감지하거나 시뮬레이션할 수 있으며, 전사된 단어에 타임스탬프를 달거나 구두점 및 비언어적 발화를 처리하며, 사용자 정의 사전을 허용하는 등의 기능도 제공합니다.\n\n웹 Speech API를 통해 웹 앱에서 이러한 기능을 활용할 수 있는 가능성에 흥분한다면, 알아야 할 몇 가지 제약 사항이 있습니다. 브라우저가 지원하는 것이 최첨단 기술이 아니기 때문에 조금 실망할 수도 있습니다. 다행히도 Web Speech API를 대규모 언어 모델과 결합하면 이러한 문제 일부를 완화할 수 있으며, 많은 현대 ASR 및 TTS 기술이 수행하는 것처럼 GPT-3.5-turbo 또는 GPT-4를 프로그래밍적으로 사용하여 여기에서 보여드리겠습니다. 그것만으로 충분하지 않다면, 최첨단에서 ASR 및 TTS를 수행하기 위해 자사의 (유료) API를 제공하는 회사들도 있음을 알게 될 것입니다.\n\n# Web Speech API, 그 구성 요소 및 이용 가능성\n\nWeb Speech API는 웹 애플리케이션이 음성 데이터를 기능에 통합할 수 있도록 하는 웹 표준입니다. SpeechRecognition(음성 입력 및 인식을 허용하는 구성요소)와 SpeechSynthesis(음성 출력 및 합성을 허용하는 구성요소)로 구성되어 있습니다.\n\n\n\nWeb Speech API은 구글에서 2010년에 처음 제안되었고, 2013년 Chrome 25에서 구현되었습니다. 그 이후로 다른 브라우저에서도 지원되고 있지만 호환성과 기능에는 차이가 있습니다. 2023년 12월 기준으로 caniuse.com에서 보고한대로 매우 다양한 지원이 있습니다, 특히 음성 인식에 대해 말이죠:\n\n![음성인식](/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_1.png)\n\n제 경험상 API의 음성 인식 모듈은 사파리와 크롬에서만 잘 작동했습니다. 각각의 iOS 및 Android 버전도 지원하고 있죠. Brave나 Oculus Browser와 같은 크로미움 기반 브라우저(메타의 퀘스트 브라우저용 가상현실 웹 브라우저)는 음성 인식을 지원하지 않습니다. 이는 구글의 음성 인식 서비스가 독점적이며 라이선스가 필요하기 때문에 발생하는 문제입니다. 구글은 다른 브라우저에게 라이선스를 부여하지 않습니다. 소리내어 나타내자면, 크롬의 음성 인식은 클라우드 컴퓨팅을 기반으로하기 때문에 Brave와 같은 사용자 프라이버시에 중점을 둔 브라우저가 구글이 자원을 이용하여 음성 인식을 실행할 수 있게 하도록 허용한다면 어려운 결정을 내려야 할 것입니다. 그리고 프라이버시에 대해 언급하자면, Web Speech API를 통해 이루어지는 모든 음성 인식은 호출하는 웹페이지가 https를 통해 제공되어야 합니다!\n\n음성 합성은 음성 인식과는 달리 컴퓨터의 모든 주요 브라우저에서 잘 처리되며, 스마트폰을 포함한 대부분의 브라우저에서도 지원됩니다. TTS의 경우, 현재 https는 필수가 아닙니다.\n\n\n\n다음에는 구체적으로 Web Speech API에 초점을 맞추어 Chrome에서 해당 API를 사용하는 방법에 대해 알아볼 것입니다. 원칙적으로는 API를 지원하는 모든 다른 브라우저에서도 핵심 요소가 동일하게 작동해야 합니다.\n\n# Chrome의 Web Speech API 사용하기\n\n프로그래밍적으로 Web Speech API를 사용하려면 SpeechRecognition 또는 SpeechSynthesis 인터페이스의 인스턴스를 생성해야 합니다. 음성 입력 또는 출력을 사용하려는 경우에 따라 두 가지를 모두 생성하고 동일한 앱에서 사용할 수도 있습니다!\n\n## 음성 인식\n\n\n\n예를 들어, 음성 인식 객체를 생성하려면 이렇게 간단히 할 수 있어요:\n\n```js\nvar recognition = new SpeechRecognition();\n```\n\n하지만, 브라우저에서 실제로 ASR(음성 인식)이 활성화되어 있는지 확인해야 해요. 그러면 최소한의 코드 블록은 다음과 같아요:\n\n```js\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nwindow.onload = function () {\n  if (typeof SpeechRecognition === “undefined\") {  // 브라우저가 음성 인식을 할 수 있는지 확인\n    console.log(“Speech api failed\");\n  } else {\n    console.log(“Speech api ok\");\n    const recognition = new SpeechRecognition();  // 음성 인식 객체 생성\n    recognition.continuous = true;                // 동작 및 속성 정의, 예를 들어 지속적인 ASR을 요청하는 경우,\n    recognition.interimResults = true;            // ASR의 일부 결과 표시 (즉, 결과가 아직 최종이 아닌 경우에 발화가 계속되는 경우)\n    recognition.lang = \"en-US\";                   // 언어는 미리 정의되어야 해요\n    recognition.onresult = (event) =\u003e {           // 단어나 문장이 인식되었을 때 트리거\n      const res = event.results[last];            // 여러 인식된 단어/문장 목록이 있는 경우, 마지막 것을 가져와요\n      var text = res[0].transcript.trim();        // 텍스트 추출 및 정리\n      … // 텍스트 처리\n    }\n    recognition.start();            // 모든 설정이 준비된 상태로 인식 시작\n  }\n}\n```\n\n\n\n위에 표시된 대로 객체의 메서드와 속성을 사용하여 음성 인식 서비스를 제어하고 최상의 방법으로 활용할 수 있어요. 가장 많이 사용되는 명령어와 속성은 start, stop, abort, lang, interimResults 등이에요. 객체가 발생시키는 이벤트를 처리하기 위해 onstart, onend, onresult, onerror 등과 같은 이벤트 리스너를 추가할 수도 있어요.\n\n특히 주목할만한 프로퍼티 중 하나는, 약간의 부정적인 이유로 매우 주목할 가치가 있는 것은 \"grammars\"입니다. 음성 인식 \"grammars\"는 ASR을 수행하는 코드가 일반적으로 이해하지 못하거나 순위가 낮게 채점할 수 있는 단어를 이해할 수 있게 해줘야 한다고 합니다. 이 기능은 발음을 교정하고 이름, 전문용어, 지역 표현 등의 사용에 특히 중요하다고 해요. 기능에 대한 일부 정보는 여기서 찾아볼 수 있지만... 자세한 내용은 다루지 않겠습니다. 왜냐하면... 그냥 제대로 작동하지 않아서 많은 사람들이 이에 대해 불평하고 있거든요. 더구나, 현재 어떤 브라우저도 잘 지원하지 않기 때문에 API에서 gramamrs를 삭제할 계획이 있는데요 (여기를 참조하세요).\n\nSpeechRecognition 객체의 속성 및 이벤트에 대해 더 알고 싶다면, 여기를 확인해보세요.\n\n그리고 웹 Speech API를 음성 인식에 사용하는 전역적이고 완벽한 예제로, 웹 페이지의 배경색을 음성 명령어를 통해 변경하는 방법을 보여주는 이 공식 예제를 확인해보세요.\n\n\n\n## 음성 합성\n\n또한, 음성 합성 객체를 만들기 위해 다음과 같이 작성할 수 있습니다:\n\n```js\nvar synthesis = window.speechSynthesis;\n```\n\n그런 다음, SpeechSynthesisUtterance 인터페이스의 인스턴스를 생성할 수 있습니다. 이 인스턴스는 합성하고자 하는 구체적인 음성 요청을 나타냅니다. 텍스트, 음성, 속도, 음높이, 볼륨 등과 같은 utterance의 속성을 설정할 수 있습니다. 객체의 메서드와 속성을 사용하여 음성 합성 서비스를 제어할 수 있습니다. speak, pause, resume, cancel, getVoices 등과 같은 작업을 수행할 수도 있습니다. 또한, utterance가 발생시키는 이벤트를 처리하기 위해 이벤트 리스너를 추가할 수도 있습니다. onstart, onend, onerror 등과 같이 발생하는 이벤트를 처리하기 위한 예시로, 텍스트를 합성하고 시작과 종료시에 로그를 남기는 방법은 다음과 같습니다:\n\n\n\n웹 앱에서 정말 좋아하는 것 중 하나는 문자열을 받아서 음성으로 출력하는 함수를 가지고 있는 것입니다. 이 함수를 speakUp()이라고 부르고 다음과 같이 보입니다:\n\n```js\nfunction speakup(TextToSpeak) {\n  if (“speechSynthesis\" in window) {                            //TTS가 지원되는지 확인\n    const toSpeak = new SpeechSynthesisUtterance(TextToSpeak);  //음성 생성\n    toSpeak.lang = “en-US\";                                     //언어 설정\n    window.speechSynthesis.speak(toSpeak);                      //음성 출력!\n  } else {\n    console.log(“브라우저에서 음성 합성을 지원하지 않습니다.\");\n  }\n}\n```\n\n# 웹 Speech API를 통한 음성 인식 및 합성의 문제와 대형 언어 모델을 사용하여 그 일부를 수정하는 방법\n\n\n\n웹 Speech API는 매우 쉽게 사용할 수 있어요. 무료이며 API 키도 필요하지 않고 얼마나 자주 호출해도 제한이 없어요.\n\n하지만 계속 시도해보니 시스템이 자주 다운되는 경향이 보이는데, 특히 ASR(자동 음성 인식)에 대해서요. 게다가 API는 때때로 자체적으로 꺼지는 것처럼 보이며, 많은 사람들이 명확한 해결책 없이 질문을 합니다. 더 나쁜 점은 무료 API가 어떤 응용 프로그램에는 괜찮을 수 있지만, 음성 인식 및 합성 측면에서는 최신 기술 수준과는 거리가 멀어요. 일반적으로 설명한 현대 ASR(자동 음성 인식) 시스템에 비해, Chrome의 ASR 서비스는 매우 제한적이에요!\n\n음성 인식은 매우 정확하거나 신뢰성이 높지 않으며, 사투리나 방언에도 민감하지 않아요. 심지어 약간의 소음이 있어도 거의 쓸모가 없어요. 언어를 자동으로 감지하지 않고, 같은 대화에서 여러 사람이 말할 때도 인식하지 못하며, 구두점은 괜찮지만 발성과 혼동되기도 해요.\n\n음성 인식 서비스는 개인 정보 보호 및 보안 문제가 있어요. 음성 데이터가 사용자 동의나 지식 없이 외부 서버나 제3자에 전송됩니다.\n\n\n\n음성 합성 서비스는 특히 영어 이외의 언어에 대해서는 매우 자연스럽거나 표현력이 부족합니다.\n\n또한 위에서 본 것처럼 음성 인식 및 합성 서비스는 브라우저와 장치에 매우 의존적이며, 다른 플랫폼 및 지역에서 사용 가능하지 않거나 일관성이 없을 수 있습니다.\n\n그리고 그 한계로 인해 편견, 차별, 속임수, 조작 또는 가장 등 윤리적 및 사회적 영향이 발생할 수 있습니다.\n\n개발자로서 그리고 사용자로서, 이러한 제한사항과 도전에 대해 인식하고 Web Speech API를 책임 있게 사용해야 합니다.\n\n\n\n## 대형 언어 모델을 사용하여 음성 인식 문제 완화하기\n\n위 문제 중에서도 음성 인식(ASR)과 관련된 문제가 가장 중요합니다. 이러한 문제 중 많은 것들을 해결하기 위해서는 인식이 진행되는 가장 기본적인 수준에서 조치가 필요합니다. 그러나 전사 정확성과 전문 용어 완성과 관련된 가장 중요한 문제들은 대형 언어 모델을 사용해서 해결할 수 있습니다. 제가 GPT-3.5-turbo 또는 GPT-4를 통해 직접 JavaScript 내부의 웹 앱에서 프로그래밍을 통해 해결하고 있습니다.\n\n작동 방식\n기본적으로 언어 모델을 호출하여 입력이 어떻게 보일지와 해당 입력에 대한 출력이 어떻게 되어야 하는지 설명하는 프롬프트를 제공한 다음, API에서 인식한 음성으로부터 나오는 실제 (원시) 전사를 따릅니다.\n\n이 모든 작업을 일으킨 웹 앱에서는 음성 인식을 사용하여 명령을 트리거합니다. 예를 들어 사용자가 \"확대\", \"줌 인\" 또는 비슷한 명령을 하면 시각화(분자 그래픽을 위한 앱)가 확대되어야 합니다. 이 앱의 프롬프트는 다음과 같습니다:\n\n\n\n```js\nlet theprompt = [];         //프롬프트가 저장될 배열을 초기화합니다\n\ntheprompt.push({\n  role: \"system\",           //모드에게 수행할 작업을 알립니다\n  content: \"음성인식으로 텍스트를 받고 주어진 예제처럼 명령을 트리거하여 적절히 대응합니다. 요청을 이해하지 못하거나 목록에 없는 경우 didntUnderstand() 명령을 실행합니다.\",\n  });\n\ntheprompt.push(                                      //여기서부터 예제 제공\n { role: “user\", content: “분자 크게 만들기\" },\n { role: “assistant\", content: “scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"확대\" },\n { role: \"assistant\", content: \"scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"크게 만들기\" },\n { role: \"assistant\", content: \"scale(+)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"축소\" },\n { role: \"assistant\", content: \"scale(-)\" }\n);\ntheprompt.push(\n { role: \"user\", content: \"작게 만들기\" },\n { role: \"assistant\", content: \"scale(-)\" }\n);\n```\n\n이를 자세히 살펴보겠습니다. 여기에 프롬프트의 시스템 요소가 있습니다:\n\n그런 다음 사용자/어시스턴트 쌍이 동일한 또는 관련된 출력을 생성하는 가능한 입력의 예제를 제공하는 방법을 살펴보십시오. 예를 들어 \"확대\"라고 말하면 \"크게 만들기\" 모두 scale(+) 호출을 결과로 지니며, \"축소\"는 scale(-) 호출을 합니다.\n\n코드의 다른 부분에서는 프로그램이 크래시하지 않는 방식으로 입력을 수정하도록 언어 모델을 가르치는 항목을 찾을 수 있습니다. 동시에 올바른 출력을 생성할 가능성을 높입니다. 예를 들어, 제가 말하는 \"최소화\"는 종종 \"미니 마우스\"로 인식되고 \"ANI\"는 표준 영어 단어가 아닌 \"애니\"로 인식됩니다. 그런 다음 이러한 예제로 언어 모델을 지시할 수 있습니다:\n\n\n\n\n```js\ntheprompt.push(\n { role: \"사용자\", content: \"ANI로 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\ntheprompt.push(\n { role: \"사용자\", content: \"애니로 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\ntheprompt.push(\n { role: \"사용자\", content: \"애니로 미니 쥐들을 최소화하기\" },\n { role: \"조수\", content: \"minimize(ANI)\" }\n);\n...등등.\n```\n\n이 요령이 굉장히 잘 작동하는 것을 알 수 있습니다. 이는 최신 언어 모델인 Whisper와 같은 모던한 언어 모델의 핵심입니다. 이 모델은 언어 모델을 직접 음성 인식 절차에 포함시켜서 가능한 것입니다!\n\n이 섹션을 마치면서, 물론 전체 프롬프트는 저의 경우에는 주로 GPT-3.5-turbo나 OpenAI의 GPT-4로부터의 응답을 포함하는 프로미스 내부에 있어야 합니다.\n\n```js\nfetch(`https://api.openai.com/v1/chat/completions`, {    // 음성 API를 호출하는 주요 부분\n  body: JSON.stringify({\n  model: \"gpt-3.5-turbo\",                     // 또는 2023년 12월 기준 GPT-4\n  messages: theprompt,                    // 방금 생성된 프롬프트\n  temperature: 0,                         // 환각을 피하기 위해 이를 낮추세요\n  max_tokens: 20,                         // 출력물은 작은 명령어여야 하므로 이 값도 낮추세요\n}),\n  method: \"POST\",\n  headers: {\n    \"content-type\": \"application/json\",\n    Authorization: \"Bearer \" + 빈칸에 당신의 API 키와 문자열을 넣으세요,    // OpenAI의 GPT 모델용 API 키!\n  },\n}).then((response) =\u003e {\n  if (response.ok) {\n    response.json().then((json) =\u003e {\n    var command = json.choices[0].message.content.trim();    // 명령어가 담긴 텍스트를 추출합니다\n    console.log(command);\n    if (command == ....                 // 작업 목록을 나열하고 실행합니다                  \n```\n\n\n\n# Chrome Web Speech API를 사용하는 몇 가지 사례\n\n이 블로그 글을 트리거한 앱 이외에도 음성 인식 및/또는 합성 API를 사용하는 이 다른 프로젝트들을 공유할 수 있어요:\n\n이 예시에서, 나는 Chrome의 음성 인식 기능을 GPT-3과 함께 사용하여 음성으로 입력된 노트와 가이드라인에서 이메일을 작성하는 웹 앱을 만들었어요.\n\n여기에서, 나는 당신에게 Chrome의 음성 인식 및 합성 API를 사용하여 GPT-3으로 구동된 언어 모델이 채팅봇의 '뇌'로 작용하는 채팅GPT와 유사한 봇을 만드는 방법을 보여줄 거예요.\n\n\n\n이 다른 예제에서는 Chrome의 음성 인식 기능을 사용하여 웹 앱을 제어합니다. 이 경우, GPT-3를 사용하여 발언된 요청을 명령으로 변환합니다.\n\n# 웹 음성 API를 넘어서\n\n위에서 설명했듯이 일부 웹 브라우저는 음성 합성을 지원하지 않을 뿐 아니라 음성 인식도 지원하지 않습니다. 또한 Chrome의 내장 음성 API가 좋지 않다고 설명했고, 특히 음성 인식에 있어서는 그 제한사항이 극복되는 경우도 있지만, 이 전략으로 해결할 수 없는 문제도 있으며, 따라서 현대 음성 인식 시스템이 가지고 있는 많은 기능이 완전히 부족한 경우가 많습니다.\n\n이러한 맥락에서, 브라우저가 대안 서비스나 솔루션을 사용하여 음성 인식 및 합성을 지원할 수 있다는 것을 알아두는 것이 중요합니다 - Chrome의 무료 API와 대조적으로 유료이지만 일반적으로 더 강력한 원칙입니다.\n\n\n\n일부 이 API 서비스를 제공하는 회사들을 언급해보자면 Gladia, Speechly, AssemblyAI, Deepgram, Spechmatics(이 회사는 여기에서 멋진 예제를 자랑해요) 등이 있습니다. Google도 Chrome에서 무료로 제공하는 것과 별도로 ASR 시스템을 보유하고 있으며, 이는 분명히 더 잘 작동합니다. 또한 Microsoft와 AWS와 같은 기술 거인들도 API를 통해 제공하는 제품을 갖고 있습니다. OpenAI의 오픈 소스 Whisper를 다운로드해서 특정 서비스로 실행할 수도 있습니다. 이 경우에는 본인의 요구에 따라 커스터마이징하여 사용할 수도 있는데, 그런 경우에는 Gladia.io와 같이 API를 제공하는 회사와 함께 하는 편이 더욱 편리할 수 있습니다.\n\n물론, Whisper를 로컬 서버에서 사용하듯이, 닫힌 환경에서 구현하지 않는 한, 이러한 서비스 대부분은 오디오를 서버로 전송해야 하므로 개인 정보를 잠재적으로 노출할 수 있습니다. 그러나 민감하지 않은 작업에 대해서는 매우 저렴한 비용으로도 완벽한 해결책이 될 수 있습니다.\n\n# 더 많은 읽을거리\n\nwww.lucianoabriata.com 나는 내 관심 분야인 자연, 과학, 기술, 프로그래밍 등에 관한 모든 것에 대해 쓰고 있습니다. 새로운 이야기를 이메일로 받으시려면 구독하세요. 소규모 작업에 대해 상담하려면 여기에서 내 서비스 페이지를 확인하세요. 저에게 연락하려면 여기에서 연락하세요. 팁을 보내고 싶으시다면 여기에서 가능합니다.","ogImage":{"url":"/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png"},"coverImage":"/assets/img/2024-05-14-WebSpeechAPIWhatWorksWhatDoesntandHowtoImproveItbyLinkingIttoaGPTLanguageModel_0.png","tag":["Tech"],"readingTime":13},{"title":"익스프레스 게이트웨이 당신의 다음 API 게이트웨이 솔루션","description":"","date":"2024-05-14 13:28","slug":"2024-05-14-ExpressgatewayYournextAPIGatewaySolution","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png\" /\u003e\n\n안녕하세요 개발자 여러분! 이 블로그 포스트에 오신 것을 환영합니다. 이 포스트에서는 Express 게이트웨이에 대해 자세히 살펴보겠습니다. 왜 사용해야 하며 언제 사용해야 하는지, 그리고 어떤 문제를 해결할 수 있는지 알아봅시다. 시작해봅시다! 🚀\n\nAPI 게이트웨이는 현대 소프트웨어 아키텍처에서 중요한 구성 요소로, 백엔드 서비스와 API에 대한 모든 클라이언트 요청의 단일 진입점 역할을 합니다. 인증, 권한 부여, 속도 제한 및 라우팅과 같은 작업을 처리하며 클라이언트와 다양한 마이크로서비스 간의 통신을 간소화합니다. 이러한 기능을 중앙 집중화함으로써 API 게이트웨이는 분산 시스템의 보안, 확장성 및 관리 용이성을 향상시킵니다. 인기 있는 API 게이트웨이 솔루션에는 Kong, AWS API 게이트웨이 및 Traefik 등이 있으며, 이러한 서비스를 관리하는 UI와 함께 훌륭한 API 관리 시스템을 제공하지만 Express 게이트웨이는 이 문제에 대한 오픈 소스 솔루션이며 우리가 곧 살펴볼 모든 편리한 구성을 제공합니다.\n\nAPI 게이트웨이는 특히 분산 아키텍처에서 여러 마이크로서비스나 API를 관리할 때 사용해야 합니다. 통합된 진입점을 제공함으로써 클라이언트 액세스를 간소화하고 인증, 권한 부여 및 트래픽 관리와 같은 필수 기능을 제공합니다. 게다가 API 게이트웨이는 복잡한 서비스 지향 환경에서 보안 정책을 강화하고 잠재적인 위험을 완화하는 데 유용합니다.\n\n\n\n\n![Express Gateway 이미지 1](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_1.png)\n\n![Express Gateway 이미지 2](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_2.png)\n\nExpress Gateway는 미리 정의된 라우팅 규칙에 따라 들어오는 HTTP 요청을 가로채어 적절한 마이크로 서비스 또는 API로 보내는 방식으로 작동합니다. 인증, 권한 부여, 속도 제한 및 로깅과 같은 작업을 처리하여 클라이언트와 서비스 간의 안전하고 효율적인 통신을 보장합니다. Express Gateway의 정책 시스템은 사용자 정의 및 확장성을 허용하여 개발자가 특정 요구 사항에 맞게 조정할 수 있도록 합니다. Express Gateway에서 사용 가능한 정책 목록을 확인하고 그에 맞게 구성하는 방법을 알아봅시다.\n\n이제 Express Gateway의 설치부터 시작하여 우리의 요구 사항에 맞게 구성하는 방법을 살펴봅시다.\n\n\n\n\n```js\n$ bun add -g express-gateway\n```\n\n- 익스프레스 게이트웨이를 추가합니다.\n\n```js\n$ eg gateway create\n```\n\n몇 가지 질문에 답하면 기본 구성으로 준비된 게이트웨이 프로젝트가 생성됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_3.png\" /\u003e\n\n- server.js: 게이트웨이의 진입점이며 구성이 로드되고 응용 프로그램이 API 엔드포인트를위한 포트 8080 및 관리 API 엔드 포인트를위한 포트 9876에서 수신 대기를 시작하는 위치입니다.\n- system.config.yml: 게이트웨이의 시스템 수준 구성 및 글로벌 매개 변수가 정의되어 있으며 system.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이를 실행하는 데 사용되는 인프라 구성 설정을 설명합니다.\n- gateway.config.yml: 게이트웨이의 모든 기능이 정의되어 있으며 gateway.config.yml에 설명되어 있습니다. 이 구성 파일은 게이트웨이의 마이크로 서비스 및 API 연산 전체를 한눈에 보여줍니다.\n- models: models 디렉토리에는 Express Gateway 엔티티의 JSON 스키마를 설명하는 모델 구성 파일이 포함되어 있습니다. 이는 사용자 정의 및 확장 가능한 항목입니다.\n\nExpress Gateway 구성을 시도해보기 위해 각각 다른 포트 3000, 3001 및 3002에서 실행 중인 local-server에 세 개의 Express 서버를 만들었습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_4.png\" /\u003e\n\n\n\n이제 gateway.config.yml을 구성하여 익스프레스 게이트웨이의 라우트에 마이크로 서비스를 포함시켜서 요청을 지정된 마이크로 서비스로 리디렉션할 수 있도록 설정하십시오.\n\n```js\nhttp:\n  port: 8080\nadmin:\n  port: 9876\n  host: localhost\napiEndpoints:\n  ms1:\n    host: localhost\n    paths: /api/ms1/*\n  ms2:\n    host: localhost\n    paths: /api/ms2/*\nserviceEndpoints:\n  ms1:\n    url: 'http://localhost:3000'\n  ms2:\n    url: 'http://localhost:3001'\npolicies:\n  - basic-auth\n  - cors\n  - expression\n  - key-auth\n  - log\n  - oauth2\n  - proxy\n  - rate-limit\npipelines:\n  ms1:\n    apiEndpoints:\n      - ms1\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms1\n              changeOrigin: true\n  ms2:\n    apiEndpoints:\n      - ms2\n    policies:\n      - proxy:\n          - action:\n              serviceEndpoint: ms2\n              changeOrigin: true\n```\n\n- http: 익스프레스 게이트웨이가 수신하는 HTTP 요청의 포트를 지정합니다 (포트 8080).\n- admin: 관리 인터페이스에 액세스하기 위한 포트 (9876) 및 호스트 (localhost)를 정의합니다.\n- apiEndpoints: 지정된 경로를 기반으로 서로 다른 마이크로 서비스 (ms1 및 ms2)를 위한 엔드포인트를 구성합니다.\n- serviceEndpoints: 서비스 엔드포인트 (ms1 및 ms2)를 해당 URL과 연결합니다.\n- policies: API 라우트에 적용할 수 있는 사용 가능한 정책을 나열합니다. 기본 인증, CORS, 속도 제한 등이 포함됩니다.\n- pipelines: 각 마이크로 서비스에 대해 처리 파이프라인을 정의하고 적용할 API 엔드포인트 및 정책을 지정합니다. 예를 들어, ms1에 대한 파이프라인은 요청을 ms1 서비스 엔드포인트로 프록시하고 출처 변경을 가능하게 합니다. 마찬가지로, ms2에 대한 파이프라인은 출처 변경이 가능한 상태로 요청을 ms2 서비스 엔드포인트로 프록시합니다.\n\n게이트웨이 구성에 대해 더 알아보려면 이 링크를 따르세요 [링크](내부 링크 주소를 입력하세요).\n\n\n\n이제 구성 변경으로 인해 localhost:8080/api/ms1/에 요청을 보낼 수 있으며 해당 요청을 serviceEndpoint에 리디렉션할 것입니다.\n\n또한 다음은 이 구성을 편집할 수 있는 관리자 API 엔드포인트를 사용할 수 있습니다. 아래는 예시입니다.\n\n- API 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_5.png)\n\n\n\n- 서비스 엔드포인트 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_6.png)\n\n- 서비스 엔드포인트용 파이프라인 생성\n\n![이미지](/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_7.png)\n\n\n\n이 요청에서 다른 가능한 정책도 구성하세요.\n\napiEndpoints, serviceEndpoint 및 piplines을 나열할 수도 있습니다. 이러한 엔드포인트에 대해 GET 요청을 만들어 읽을 수 있습니다. 익스프레스 게이트웨이는 관리자 API를 자체 도메인이나 서브도메인으로 유지하고 이를 퍼블릭으로 사용할 수 없도록 권장하며, 이러한 엔드포인트에 인증을 추가할 수도 있습니다.\n\n관리자 API 엔드포인트에 대한 자세한 정보는 다음 문서를 읽는 것을 권장합니다.\n\nAPI 관리 여정에 착수하면서 익스프레스 게이트웨이의 공식 문서를 탐험하는 것을 잊지 마세요. 이 강력한 도구에 대한 이해와 능력을 향상시키는 데 소중한 자원으로 작용합니다. 즐거운 코딩👨‍💻️!","ogImage":{"url":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png"},"coverImage":"/assets/img/2024-05-14-ExpressgatewayYournextAPIGatewaySolution_0.png","tag":["Tech"],"readingTime":5},{"title":"디바운스Debounce와 스로틀링Throttling 그들이 뭔지 그리고 언제 사용해야 할까","description":"","date":"2024-05-14 13:27","slug":"2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem","content":"\n\n![이미지](/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png)\n\n웹 개발자이시라면, 짧은 시간 간격으로 반복적으로 실행되는 코드의 성능을 최적화해야 하는 상황에 직면할 수 있습니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이나 페이지 레이아웃을 조정하는 크기 조정 이벤트 핸들러 등이 있을 수 있습니다. 이러한 경우에 코드가 너무 자주 실행되지 않도록 하고, 불필요한 네트워크 요청, 느린 사용자 인터페이스 또는 고 CPU 사용량을 유발하지 않도록 하려면 좋지 않습니다.\n\n이 문제를 해결하기 위해 디바운싱(debouncing)과 쓰로틀링(throttling)이라는 두 가지 기술을 사용할 수 있습니다. 이러한 기술을 사용하면 코드가 실행되는 속도를 제어하고 호출되는 횟수를 줄일 수 있습니다. 이 기사에서는 디바운싱과 쓰로틀링이 무엇인지, 어떻게 다른지, 그리고 JavaScript에서 이를 구현하는 방법에 대해 설명하겠습니다.\n\n## 디바운싱이란 무엇인가요?\n\n\n\n디바운싱은 사용자가 특정 작업을 수행하지 않을 때까지 함수의 실행을 지연시키는 기술입니다. 예를 들어, 사용자가 타이핑하는 동안 백엔드에서 제안을 가져오는 검색 창이 있다면, API 호출을 수행하는 함수를 디바운싱할 수 있습니다. 이렇게 하면 사용자가 몇 초 동안 타이핑을 멈춘 후에만 해당 함수가 실행되도록 할 수 있습니다. 이렇게 함으로써 서버를 과부하로 만들거나 관련이 없는 결과를 반환하는 API 호출을 피할 수 있습니다.\n\n자바스크립트에서 디바운싱을 구현하려면 지연 기간을 추적하는 타이머 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 지연 기간 후에 함수를 실행할 타이머를 설정할 수 있습니다. 사용자가 동작을 다시 수행하기 전에 지연 기간이 끝나면 clearTimeout 함수를 사용하여 타이머를 취소할 수도 있습니다. 이렇게 함으로써 사용자가 동작을 멈춘 후에 함수가 한 번만 실행되도록 할 수 있습니다.\n\n다음은 자바스크립트에서 디바운싱을 구현하는 예시입니다:\n\n```js\n// 검색 쿼리로 API 호출을 수행하는 함수\nfunction searchHandler(query) {\n    // 검색 쿼리로 API 호출 수행\n    getSearchResults(query);\n}\n\n// 함수와 지연 시간을 매개변수로 받는 debounce 함수\nfunction debounce(func, delay) {\n    // 지연 기간을 추적하는 타이머 변수\n    let timer;\n    // 인수를 받는 함수를 반환\n    return function(...args) {\n        // 이전 타이머를 지우기\n        clearTimeout(timer);\n        // 지연 기간 후 함수를 실행할 새로운 타이머 설정\n        timer = setTimeout(() =\u003e {\n            // 인수와 함께 함수 적용\n            func.apply(this, args);\n        }, delay);\n    };\n}\n\n// 500ms 지연을 가진 검색 핸들러의 디바운스 버전\nconst debouncedSearchHandler = debounce(searchHandler, 500);\n\n// 검색 바 입력에 이벤트 리스너 추가\nsearchBar.addEventListener(\"input\", (event) =\u003e {\n    // 입력란의 값 가져오기\n    const query = event.target.value;\n    // 쿼리로 디바운스된 검색 핸들러 호출\n    debouncedSearchHandler(query);\n});\n```\n\n\n\n이 예제에서는 검색 쿼리로 API 호출을 하는 searchHandler 함수가 있습니다. 또한 함수와 지연을 매개변수로 사용하여 해당 함수의 디바운스 버전을 반환하는 debounce 함수도 있습니다. 우리는 이 debounce 함수를 사용하여 500ms 지연을 가진 debouncedSearchHandler 함수를 만듭니다. 그런 다음 검색 창 입력란에 이벤트 리스너를 추가하고 입력 값으로 debouncedSearchHandler 함수를 호출합니다. 이렇게 함으로써 사용자가 500ms 동안 타이핑을 멈추면 단 하나의 API 호출만 한다는 것을 보장할 수 있습니다.\n\n## 쓰로틀링이란?\n\n쓰로틀링은 함수의 실행을 지정된 시간 간격마다 한 번씩 제한하는 기술입니다. 예를 들어 페이지 레이아웃을 조정하는 리사이즈 이벤트 핸들러가 있는 경우, 레이아웃을 업데이트하는 함수를 쓰로틀링하여 100ms마다 한 번씩만 실행되도록 할 수 있습니다. 이렇게 함으로써 코드를 너무 자주 실행하는 것을 피하고, 사용자 인터페이스가 끊기거나 높은 CPU 사용률을 유발하는 것을 방지할 수 있습니다.\n\nJavaScript에서 쓰로틀링을 구현하려면 함수가 이미 실행 중인지 여부를 추적하는 플래그 변수를 사용할 수 있습니다. setTimeout 함수를 사용하여 시간 간격 이후에 플래그를 재설정할 타이머를 설정할 수 있습니다. 또한 함수를 실행하기 전에 플래그가 true인지 확인하는 if문을 사용할 수도 있습니다. 이렇게 함으로써 함수가 지정된 시간 간격마다 한 번만 실행되도록 보장할 수 있습니다.\n\n\n\n자바스크립트에서 쓸데없는 반복을 줄이는 방법 중 하나인 쓸데없는 실행을 빈번하게 하는 데바운싱(Debouncing)과 쓸데없는 실행을 일정 간격으로 제한하는 스로틀링(Throttling)을 구현하는 방법을 보여드렸어요.\n\n아래 코드는 페이지 레이아웃을 업데이트하는 updateLayout 함수와 함수 및 간격을 매개변수로 받아 해당 함수의 스로틀링된 버전을 반환하는 throttle 함수를 보여줍니다. 이 throttle 함수를 사용하여 100ms 간격의 throttledUpdateLayout 함수를 생성합니다. 그런 다음 창 크기 조정 이벤트에 대한 이벤트 리스너를 추가하고 throttledUpdateLayout 함수를 호출합니다. 이렇게 하면 100ms마다 레이아웃을 업데이트하는 것을 보장할 수 있어요.\n\n## 데바운싱(Debouncing)과 스로틀링(Throttling)의 차이점은 무엇인가요?\n\n\n\nDebouncing(디바운싱)과 Throttling(슈로틀링)의 주요 차이점은 디바운싱은 일정 시간 동안 기다린 후 함수를 실행하는 반면, 스로틀링은 일정 간격으로 함수를 실행한다는 것입니다. 두 기법 모두 코드의 성능을 향상시키는 데 유용하지만 각각 다른 사용 사례와 효과가 있습니다.\n\n디바운싱은 특정 작업을 수행하는 사용자가 멈출 때까지 코드의 실행을 지연시키고 싶을 때 유용합니다. 예를 들어 사용자가 백엔드에서 제안을 불러오기 전에 사용자가 입력을 멈출 때까지 기다리고 싶은 경우 자동 완성에 디바운싱을 사용할 수 있습니다. 디바운싱을 사용하면 코드 실행 횟수를 줄일 수 있지만 사용자 인터페이스에 지연이 발생할 수도 있습니다.\n\n스로틀링은 코드 실행을 일정 주기로 제한하고 싶을 때 유용합니다. 예를 들어 페이지 레이아웃을 일정한 속도로 업데이트하고 싶을 때 리사이즈에 대해 스로틀링을 사용할 수 있습니다. 스로틀링을 사용하면 사용자 인터페이스의 응답성을 향상시킬 수 있지만 코드의 일부 정보 누락이나 정확도 손실을 가져올 수도 있습니다.\n\n## 결론\n\n\n\n디바운싱과 쓰로틀링은 짧은 시간 동안 반복적으로 실행되는 코드의 성능을 최적화하는 데 도움이 되는 두 가지 기술입니다. 디바운싱은 사용자가 특정 작업을 일정 시간 동안 수행하지 않을 때까지 코드 실행을 지연시킵니다. 쓰로틀링은 코드 실행을 지정된 시간 간격마다 한 번으로 제한합니다. 두 기술은 서로 다른 사용 사례와 효과를 가지고 있으며, 여러분의 요구에 가장 잘 맞는 방법을 선택해야 합니다.","ogImage":{"url":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png"},"coverImage":"/assets/img/2024-05-14-DebounceandThrottlingWhatTheyAreandWhentoUseThem_0.png","tag":["Tech"],"readingTime":4},{"title":"카프틴 피카드와 함께하는 Q-테이블 강화학습 에이전트 만들기","description":"","date":"2024-05-14 13:24","slug":"2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png\" /\u003e\n\n만약 누군가가 나에게 비가 오는 오후를 보내며 'q-테이블'을 통한 강화 학습 데모를 만들어 오래된 친구들의 집에서 얼 그레이 차를 찾는 캡틴 피카드를 쫓는다고 말해 준다면, 나는 그들을 미친 사람이라고 부를 것이다.\n\n그런데, 여기에 우리가 있네요.\n\n(여기 내가 연례 휴가를 즐기며 지루해질 때 일어나는 일이지...)\n\n\n\n여러분이 8월 '23을 되돌아보자면, 저는 강화학습 기초에 관한 가이드를 작성하는 데 시간을 할애했었죠.\n\n이 가이드에서는 '다중암 기계' 문제를 살펴보고, 무작위 선택을 통해 보상을 최대화하는 다양한 방법을 탐색해보았습니다. 욕심 부리는 선택, 그리고 욕심부리는 엡실론 사용까지 비교해보았죠. 적어도 나에게는 정말 즐거운 경험이었어요! 하지만 그것은 강화학습 세계의 극표면을 다루는 것에 불과합니다. 'RL'이라 불리는 광범위한 세계에 대해 읽어보기 시작하면, 컴퓨터에게 보상을 극대화하는 법을 가르치기 위한 다양한 알고리즘, 방법론, 프레임워크로 가득한 깊고 복잡한 세계임을 알게 됩니다.\n\n본 후속 글에서는 강화학습 세계를 더 심도 있게 파헤치고, 문제를 해결하기 위해 강화학습을 사용하는 더 복잡하지만 흥미로운 방법 중 하나를 탐구할 것입니다. 최종적으로는 우리만의 강화학습 실험을 직접 구축하는 과정까지 이어질 것입니다! 만약 이 기사의 나머지 부분을 따라주신다면, 여러분은 여러분만의 브라우저에서 체험할 수 있는 강화학습의 작은 기술 데모를 즐길 수 있을 겁니다.\n\n# Q 누구?\n\n\n\n![image](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_1.png)\n\n특정 강화 학습 메커니즘인 'Q-러닝'에 대해 배우게 될 거에요. 그게 무엇인지 이해하려면 1989년으로 모습을 돌려봐야해요. 그 해, Christoper Watkins 교수라는 창의적인 학자가 나타났어요.\n\nWatkins는 AI/ML 엔터프라이즈에 중요한 공헌을 한 인물로, 기계 학습에 관한 다수의 논문(텍스트 해석 방식에서 큰 언어 모델과 사람 간의 유사성을 제시한 2022년 연구 포함)의 저자 또는 공동 저자로 활동했어요. 그 중 1989년에 'Q-러닝' 개념을 소개한 논문에 우리는 오늘 초점을 맞출 거에요.\n\n논문에는 \"Q-러닝(Watkins, 1989)은 에이전트가 제어된 Markov 도메인에서 최적으로 행동하는 법을 배우는 간단한 방법이다\"라고 나와 있어요. (Markov 도메인에 대한 자세한 내용은 나중에 설명할게요)\n\n\n\n첫째로, Q-학습은 다른 강화 학습 방법 및 알고리즘과 마찬가지로 에이전트가 환경을 이해하여 주어진 시나리오에서 보상을 극대화하기 위한 방법입니다. 강화 학습에 대한 첫 번째 글을 생각해보면 'RL 루프'를 다음과 같이 상상했습니다:\n\n![RL 루프 이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_2.png)\n\nQ-학습에도 동일한 다이어그램이 적용됩니다. 추상적으로 말하면 에이전트가 환경에서 행동을 취하여 보상을 얻고, 실제 세계의 사용 사례에서는 온라인 마케팅에 사용하여 고객에게 구매 습관에 가장 적합한 광고를 제공하는 최적화 작업에 사용할 수 있습니다 (고객이 광고를 클릭할 때 보상이 제공됩니다).\n\nQ 학습에서 에이전트는 특정 상태에서 작업을 시도하고, 즉시 받은 보상이나 패널티 및 해당 상태의 가치에 대한 추정을 평가합니다. 모든 상태에서 모든 작업을 반복적으로 시도함으로써 장기적으로 할인된 보상에 의해 평가된 전체적으로 가장 좋은 작업을 학습합니다.\n\n\n\n환경 내에서 행동의 가치에 대한 정보를 저장하기 위해 Q-러닝은 'Q-테이블'을 사용합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_3.png)\n\nQ 테이블을 그냥 그런 테이블로 생각해보세요. 이 테이블은 환경에서 가능한 상태와 행동을 나타내는 열과 행의 조회 테이블입니다.\n\nQ 테이블의 각 '셀'은 초기에 0으로 설정됩니다(이를 '미발견됨'으로 생각할 수 있습니다) 하지만 에이전트가 발견하면 상태와 행동의 각 조합에 대해 얻은 보상으로 Q-테이블을 업데이트합니다. 시간이 지남에 따라, 아이디어는 에이전트가 Q 테이블에서 지속적으로 업데이트되는 정보를 활용하여 보상을 극대화하기 위한 최상의 조치에 수렴할 것입니다.\n\n\n\n우리 이전의 기사에서 3개의 팔잡이 문제에 대한 관점을 고려해보면, 초기 q-테이블은 다음과 같이 보일 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |   0   |   0   |   0   |\n```\n\n슬롯 머신에는 실제로 손잡이를 당기는 하나의 상태만 있고, 3개의 기계를 가진 3개의 팔잡이 문제에서, 위와 같은 결과를 얻게 됩니다. 몇 번의 슬롯을 당겨본 후에는 몇 가지 보상 값이 나올 수 있어요:\n\n```js\n| State | Arm 1 | Arm 2 | Arm 3 |\n|-------|-------|-------|-------|\n|   1   |  0.5  |   1   |   4   |\n```\n\n\n\n에이전트가 상태에 있을 때, 그 상태에 대한 Q-테이블의 행을 확인하고 대부분의 경우, 그 행에서 가장 높은 Q-값을 갖는 행동을 선택합니다 (지금까지 알고 있는 가장 좋은 행동). '탐험률' (에이전트가 새로운 행동을 탐험할지 알려진 좋은 행동을 활용할지를 선택하는 빈도)과 '탐험 감소' (에이전트가 최대 보상 경로로 수렴하고 고수하는 속도)와 같은 요소들은 에이전트가 Q-테이블에서 찾은 값에 얼마나 의존할지에 영향을 미칩니다.\n\nQ-테이블과 상호 작용하는 공식인 '벨만' 방정식은 다음과 같습니다:\n\n새로운 Q-값 = 이전 Q-값 + 학습률 × (보상 + 할인율 × 최상의 미래 Q-값 - 이전 Q-값)\n\n벨만 방정식의 아이디어는 상태-행동 쌍의 가치가 즉시 보상뿐만 아니라 최선의 예상 미래 보상에도 기반하여 업데이트되며, 학습률에 의해 조정된다는 것입니다. 하지만 지난 보상들은 어떨까요? 이전에 있었던 일들의 역사는 어떻게 될까요?\n\n\n\n# 마르코프 성질의 역할\n\n![이미지](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_4.png)\n\n'마르코프(Markov)' 성질을 따르는 환경에 대해 얘기할 때 q-테이블 및 q-러닝 방법을 사용하는 것이 가장 적합하다는 점을 주목하는 것이 중요합니다.\n\n그게 뭔지 궁금하신가요?\n\n\n\n본질적으로 환경은 '마르코프'로 간주됩니다(러시아의 수학자 안드레이 마르코프에서 유래된 용어). 여기서 '마르코프'란 환경 안의 에이전트의 미래 상태가 현재 상태와 그 상태에서 취하는 행동에만 의존하며, 그 전에 발생한 사건이나 상태 순서에는 영향을 받지 않는 것을 의미합니다. 즉, 과거는 중요하지 않고, 현재와 즉각적인 미래만 고려하여 최상의 보상을 얻는 데 집중됩니다.\n\n마르코프 환경의 한 예로는 연결 네 개 보드가 있습니다. 연결 네에서 움직일 때마다, 실제로 중요한 것은 해당 시점의 보드 상태뿐이며, 5번 전에 누가 무슨 일을 했는지는 중요하지 않습니다(물론 그 때 중요했던 사항이지만, 움직일 때는 현재 보드 상태와 플레이 중인 모든 조각들만 알면 됩니다).\n\n마르코프 환경이 아닌 좋은 예시로는 포커 게임을 들 수 있습니다. 현재 카드와 베팅 풀뿐만 아니라, 상대의 베팅 이력과 블러핑 등의 맥락도 고려해야 합니다. 이러한 사항들은 현재와 미래 패를 플레이하기 위해 전략을 수정할 수 있습니다.\n\n강화학습에는 마르코프와 비마르코프 환경으로 처리하는 메커니즘이 있지만, Q-러닝은 전자를 위해 설계되었습니다.\n\n\n\n# 얼 그레이, 뜨겁게!\n\n이제 기다리고 계셨던 순간이 왔어요. 속 내용이 어떻게 스타 트렉: 다음 세대의 캡틴, 쟌 루크 피카드와 연결되는 건지 궁금하셨죠? 음, 여기서는 상기된 스타 플릿 선장과 그의 유명한 얼 그레이 차에 대한 애정을 사용해서 Q-러닝의 우리만의 구현을 보여드릴 거예요!\n\n그를 위해, '얼 그레이, 뜨겁게!' 라는 이름의 스타 트렉 우주를 기반으로 한 간단한 아케이드 게임을 디자인하기로 결정했어요.\n\n![Earl Grey, HOT!](/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_5.png)\n\n\n\n우리의 강화학습 기반 게임을 만들기 위해 몇 가지가 필요할 거에요. 끝에 GitHub 레포지토리 링크를 제공할 테니, 여정 동안 함께 하실 거예요. 실험에서는 다음을 선택했어요:\n\n- Phaser (웹 기반 게임 개발 툴킷). 브라우저에서 호스팅할 빠르게 프로토타입을 만들고 싶어서 선택했어요. Phaser에 대해 더 알고 싶다면 여기를 참고하세요 https://phaser.io/\n- JavaScript (브라우저/클라이언트 기반으로 무언가를 만들기 때문에 순수 바닐라 JavaScript를 사용할 거에요).\n- AWS AppRunner (마지막 솔루션을 호스팅하기 위해 사용할 거예요. AppRunner에 대한 지식은 필요하지 않지만, GitHub와 AWS AppRunner 사이의 효과적인 연동이 간단하고 효과적이어서 선택했어요. 더 알아보려면 여기를 참고하세요 https://docs.aws.amazon.com/apprunner/latest/dg/service-source-code.html\n\n제 이야기는 이렇습니다. 불쌍한 Picard가 우주 병원에 감염되었어요. 이 바이러스로 뇌의 논리와 결정 센터가 덮어씌워져 동물처럼 허기진 듯이 얼그레이 차를 찾는 무모한 욕망이 일어났는데요. 그 결과, 그는 더 많은 얼그레이를 찾기 위해 지역 양로원을 뒤지고 다닌다고 해요. 이것이 우리 게임의 핵심이 될 거예요:\n\n- 에이전트 (Picard 선장)\n- 환경 (어린이집, 우리 경우 8 * 8 그리드)\n- 목표 (얼그레이 찻잔)\n- 일부 장애물 (Picard의 진행을 막는 양로원 간호원들!)\n\n\n\n저희 어플리케이션은 매우 간단하게 유지하고 있습니다. 우리 게임을 표시하는 index.html이 있고, RL 로직을 포함한 game.js, 게임을 호스팅하는 node.js 스크립트인 server.js, 그리고 몇 개의 .png 에셋이 있습니다. 완성된 에셋은 다음 저장소에 있어서 즐거운 시간을 보내실 수 있습니다:\n\n우리의 Web UI에는 우리의 에이전트의 성능에 영향을 미칠 수 있는 강화 학습 매개변수가 몇 가지 있습니다! 이들은 다음과 같습니다:\n\n- 학습률 — 에이전트가 경험으로부터 학습하는 속도를 나타냅니다. 높은 학습률은 에이전트가 더 빨리 학습하지만, 오버피팅에 민감할 수도 있습니다.\n- 할인 계수 — 할인 계수는 에이전트가 미래 보상을 얼마나 중요하게 생각하는지 결정합니다. 높은 할인 계수는 에이전트가 미래 보상을 더 중요하게 생각하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 비율 — 탐험 비율은 에이전트가 새로운 행동을 얼마나 자주 탐구할지 결정합니다. 높은 탐험 비율은 에이전트가 더 자주 탐구하게 만들고, 그 반대도 마찬가지입니다.\n- 탐험 감소 — 탐험 감소는 탐험 비율이 시간이 지남에 따라 얼마나 빨리 감소할지 결정합니다. 높은 탐험 감소는 탐험이 더 빨리 감소하게 만들고, 그 반대도 마찬가지입니다.\n\n자바스크립트 코드를 비롯한 모든 내용을 하나하나 검토하는 것보다, 강화 학습 구현과 관련된 부분에 중점을 둘 것입니다. Phaser 게임의 기본 설정(스프라이트, 환경 등)에 대한 정보는 Phaser 웹사이트를 참조해주세요.\n\n\n\nQ-learning을 사용하기 때문에 q-테이블을 생성해야 하는데, 이전에 간단히 언급한 것보다 더 복잡한 q-테이블이 필요합니다. 강화학습 환경을 생각해 보면, 8x8 그리드가 있으므로 64개의 다른 상태가 있습니다. 게다가, Picard는 각 그리드 타일에서 위, 아래, 왼쪽 또는 오른쪽으로 이동할 수 있으므로 8x8x4로 이어지게 됩니다. 따라서 이를 위해 3차원 배열이 필요합니다!\n\n게임.js에서 이를 수행하기 위해 q-테이블을 다음과 같이 생성합니다:\n\n```js\nfunction create() {\n    // gridSize x gridSize x 4 (4는 행동의 수)\n    qTable = Array(gridSize).fill().map(() =\u003e Array(gridSize).fill().map(() =\u003e Array(4).fill(0)));\n```\n\n\n\n기본적으로 우리는 격자의 길이를 가진 배열을 생성하고, 각 요소가 격자의 길이인 배열 내에 배열을 생성한 다음, 그 배열 내에 배열을 만들어 각 요소가 4가지 작업 상태에 대한 배열을 포함하도록합니다.\n\n우리 게임에서 무슨 일이 일어날까요? 의사 결정 프로세스의 핵심은 update(time) 메서드에서 처리됩니다.\n\n여기에서 우리의 에이전트는 행동을 결정하고, 그 행동을 취하며 보상이 업데이트되고, q-테이블이 업데이트되고 목표가 달성될 때까지 진행됩니다. update(time) 내에는 위치를 업데이트하고 스프라이트 또는 텍스트를 렌더링하는 데 관련된 많은 코드가 있지만, 검토해야 할 두 가지 핵심 요소는 chooseAction(position) 함수와 takeAction(position, action) 함수입니다.\n\n다음은 우리의 chooseAction 메서드입니다:\n\n\n\n```js\nfunction chooseAction(position) {\n    var action;\n\n    // 마지막 이동을 되돌리는 행동을 피합니다.\n    var avoidActions = lastActions(); // 최근 몇 가지 작업을 피하기 위한 함수 호출\n\n    if (Math.random() \u003c explorationRate) {\n        do {\n            action = Math.floor(Math.random() * 4); // 탐험\n        } while (avoidActions.includes(action));\n    } else {\n        // 최선으로 알려진 행동을 활용하며, 가능한 경우 최근 작업의 반대를 피합니다.\n        var currentQValues = [...qTable[position.y][position.x]]; // 현재 Q-값을 복제합니다.\n        avoidActions.forEach(a =\u003e currentQValues[a] = Math.min(...currentQValues)); // 반대 행동을 방지합니다.\n        var maxQValue = Math.max(...currentQValues);\n        action = currentQValues.indexOf(maxQValue);\n    }\n\n    updateLastActions(action); // 최근 작업을 업데이트합니다.\n    return action;\n}\n```\n\n우리는 탐험(새로운 영역 찾기) 또는 활용(알려진 좋은 보상 선택)을 선택할 때 약간의 무작위성을 사용하지만, explorationRate의 값에 따라 어느 정도 제어되는 것을 알 수 있습니다.\n\n탐험하기로 결정하면, 무작위로 위/아래/왼쪽/오른쪽 움직임을 선택합니다 (하지만 최근 작업 중에서 선택하지 않도록 확인을 추가해야 했습니다. 이렇게 함으로써 에이전트가 말하자면, 예를 들어 2개의 타일 사이를 오가며 무한 루프에 갇히는 것을 막았습니다).\n\n활용하기로 결정하면, 우리의 Q-테이블이 가장 좋은 알려진 행동이 무엇인지 알려줍니다 (시간이 지날수록 더 나아지고 더 \"알려진\" 상태가 됩니다). 그런 다음 행동을 선택하고 움직이며, 간호사, 격자 상의 일반 공간 또는 목표 자체 - 맛있는 얼그레이 티를 만났는지 확인하는 등의 작업을 수행합니다.\n\n\n\n\n우리의 takeAction() 메서드에서는 구체적으로 '보상' 기능을 구현했습니다. 가능하다면 Picard를 이동하고 목표를 발견한 경우 긍정적인 보상을 제공하거나 장애물에 부딪힌 경우 약간 부정적인 보상(누적)을 제공합니다:\n\n```js\nfunction takeAction(position, action) {\n    var reward = -0.01;\n    var newPosition = { x: position.x, y: position.y };\n\n    // 새 위치가 유효한지 확인합니다(장애물이 아니며 그리드 범위 내에 있는지)\n    function isValidMove(newX, newY) {\n        if (newX \u003c 0 || newY \u003c 0 || newX \u003e= gridSize || newY \u003e= gridSize) {\n            return false; // 그리드 범위 초과\n        }\n        return !obstacles.some(obstacle =\u003e obstacle.x / tileSize === newX \u0026\u0026 obstacle.y / tileSize === newY);\n    }\n\n    // 동작에 따라 새 위치 결정\n    switch (action) {\n        case 0: // 위\n            if (isValidMove(position.x, position.y - 1)) newPosition.y -= 1;\n            break;\n        case 1: // 오른쪽\n            if (isValidMove(position.x + 1, position.y)) newPosition.x += 1;\n            break;\n        case 2: // 아래\n            if (isValidMove(position.x, position.y + 1)) newPosition.y += 1;\n            break;\n        case 3: // 왼쪽\n            if (isValidMove(position.x - 1, position.y)) newPosition.x -= 1;\n            break;\n    }\n\n    if (newPosition.x !== position.x || newPosition.y !== position.y) {\n        // 유효한 이동인 경우 에이전트 위치 업데이트\n        agentPosition = newPosition;\n\n        if (agentPosition.x === goalPosition.x \u0026\u0026 agentPosition.y === goalPosition.y) {\n            reward = 1; // 목표에 도달한 경우 보상\n        }\n    } else {\n        // 잘못된 이동(경계를 벗어나거나 장애물로 이동함)\n        reward -= 0.1;\n    }\n\n    return reward;\n}\n```\n\nPicard를 결정하고 이동한 후에는 q-테이블을 다음과 같이 업데이트해야 합니다:\n\n```js\nfunction updateQTable(position, action, reward) {\n    var nextState = agentPosition;\n    var maxQValueNextState = Math.max(...qTable[nextState.y][nextState.x]);\n    qTable[position.y][position.x][action] += learningRate * (reward + discountFactor * maxQValueNextState - qTable[position.y][position.x][action]);\n}\n```\n\n\n\n다음은 Q-테이블을 업데이트하는 데 사용되는 JavaScript 구현입니다:\n\nQ(state, action)←Q(state, action) + α×(reward+γ×maxaQ(nextState, a)−Q(state, action))\n\n간단히 말하면: 새 점수 = 이전 점수 + 학습 계수 × (최근 점수 + 미래 잠재력 - 이전 점수).\n\n행동을 선택하고 수행하며 Q-테이블을 업데이트하는 것 외에도, 업데이트 방법에서 수행하는 몇 가지 다른 작업이 있으며, 이는 에이전트가 탐험할지 또는 이용할지에 대한 가중치와 관련이 있습니다.\n\n\n\n먼저, 각 단계마다 탐사하는 양을 감소시켜 최대 보상 경로로 수렴할 수 있도록 천천히 줄입니다 (저희 감쇠율에 따라):\n\n```js\nexplorationRate = Math.max(explorationRate - explorationDecay, 0.01);\n```\n\n이에 추가하여, 에이전트가 '멈춰 있는' 것처럼 보일 때 임시로 결정을 탐사하는 가능성을 증가시키는 작은 조정을 업데이트 메서드에 추가해야 했습니다.\n\n```js\nif (samePositionCount \u003e 3) {\n    explorationRate = Math.min(explorationRate + 0.1, 1.0);\n    samePositionCount = 0; // 카운터를 재설정합니다\n}\n```\n\n\n\n이전에는 에이전트가 어딘가에서 루프에 자주 걸렸었지만, 추가하면서 멈춰있다가 얼마 동안 같은 위치에 있으면 약간의 '후드'를 줍니다. 이 변경 사항은 일시적이며 에이전트가 다시 움직일 때까지만 유효합니다.\n\n게임은 피카드가 소중한 얼 그레이에 도착할 때마다 보상을 평가하며, 5번의 연속 시도에서 최대 보상에 수렴할 때 실험이 완료/이루어집니다. 이 시점에서 우리는 에이전트가 가능한 한 작업에 '적합하게' 되었다고 생각합니다.\n\n완성품? 정말 멋진 ('알아요, 알아요 - 이것은 매우 유치하지만, 여전히 재미 있겠죠!') '얼 그레이, HOT1' 게임을 만들었는데요, 아래 링크에서 확인해보세요:\n\nhttps://earlgreyhot.org/\n\n\n\n![Building a Q-table Reinforcement Learning Agent with Captain Picard](/assets/img/2024-05-14-BuildingaQ-tableReinforcementLearningAgentwithCaptainPicard_6.png)\n\n재밌게 즐기고, 매개변수를 조정해보세요. 에이전트가 완료할 때까지 시도 횟수를 최소화해보세요! 그리고 덤으로, 누군가에게 다양한 보상(긍정적이고 부정적인 것, 또는 새로 만들기?)을 조정할 수 있는 기능을 추가하여 그것이 에이전트의 성능에 미치는 영향을 사용자들이 볼 수 있도록 소스 코드를 업데이트하도록 초대합니다.\n\n이 글이 재밌게 보이셨기를 바라며 — 항상 트레키한 방식으로 Q-러닝을 통한 강화 학습 개념을 다룬 것에 흥미를 느끼셨으면 이 기사를 즐기셨다면 박수를 보내거나 댓글을 남겨주세요 — 다음에 또 만나요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaQ-tableReinforementLearningAgentwithCaptainPicard_0.png","tag":["Tech"],"readingTime":12}],"page":"106","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"106"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>