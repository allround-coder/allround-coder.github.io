<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/65" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/65" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="대용량 JSON 파일을 효율적으로 전송하는 방법" href="/post/2024-05-20-HowToTransferLargeJSONFilesEfficiently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대용량 JSON 파일을 효율적으로 전송하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대용량 JSON 파일을 효율적으로 전송하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">대용량 JSON 파일을 효율적으로 전송하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" href="/post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">러스트 트레이트 TypeScript 인터페이스의 강력한 대안</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" href="/post/2024-05-20-FrontendWeeklyDigest3631319May2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 소식: 2024년 5월 13일  5월 19일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 소식: 2024년 5월 13일  5월 19일</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="장고로 대규모 프로젝트를 만드는 방법" href="/post/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="장고로 대규모 프로젝트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="장고로 대규모 프로젝트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">장고로 대규모 프로젝트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="템플릿 간소화하기 Angular 17에서의 제어 흐름" href="/post/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="템플릿 간소화하기 Angular 17에서의 제어 흐름" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="템플릿 간소화하기 Angular 17에서의 제어 흐름" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">템플릿 간소화하기 Angular 17에서의 제어 흐름</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" href="/post/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PHP 8.3에 추가된 20가지 흥미로운 기능들 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">PHP 8.3에 추가된 20가지 흥미로운 기능들 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합" href="/post/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NextJs 14에서 Route Groups이란 무엇인가?" href="/post/2024-05-18-WhatareRouteGroupsinNextJs14"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NextJs 14에서 Route Groups이란 무엇인가?" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NextJs 14에서 Route Groups이란 무엇인가?" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">NextJs 14에서 Route Groups이란 무엇인가?</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter와 Firebase로 픽셀 아트 앱 만들기" href="/post/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter와 Firebase로 픽셀 아트 앱 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter와 Firebase로 픽셀 아트 앱 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Flutter와 Firebase로 픽셀 아트 앱 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="패닉에서 준비 상태로 나의 면접 경험" href="/post/2024-05-18-FromPanictoPreparedMyInterviewExperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="패닉에서 준비 상태로 나의 면접 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="패닉에서 준비 상태로 나의 면접 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">패닉에서 준비 상태로 나의 면접 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link posts_-active__YVJEi" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"대용량 JSON 파일을 효율적으로 전송하는 방법","description":"","date":"2024-05-20 21:43","slug":"2024-05-20-HowToTransferLargeJSONFilesEfficiently","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png\" /\u003e\n\n대규모 JSON 데이터를 전송할 때, 기존 방식을 사용하면 데이터 처리를 시작하기 전에 완전한 JSON 데이터를 수신해야 하므로 사용자 경험에 영향을 줄 수 있습니다. 이 문제를 해결하기 위해 기존의 JSON 스트림 구문 분석 라이브러리를 사용할 수 있습니다. 예를 들어 내부적으로 TextDecoder API를 사용하는 @streamparser/json이 있습니다.\n\nTextDecoder API는 이진 데이터 (일반적으로 ArrayBuffer 또는 TypedArray)를 문자열로 디코딩하기 위한 JavaScript API입니다. 이는 Web 플랫폼의 일부이며 텍스트 인코딩의 디코딩을 처리하는 데 주로 사용됩니다. 예를 들어, 서버로부터 수신한 스트리밍 데이터, 파일 데이터 등을 처리하는 데 사용됩니다.\n\n# TextDecoder API 사용 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 애플리케이션에서 이진 데이터를 다룰 때, 이 데이터를 읽을 수 있는 문자열 형식으로 변환해야 하는 경우가 종종 있습니다. TextDecoder를 사용하면 이를 효율적이고 편리하게 할 수 있습니다.\n\nTextDecoder API에는 다음과 같은 기능이 있습니다:\n\n- 효율적: 수동으로 바이트 단위로 처리하는 것보다 효율적이며, 문자열로 직접 디코딩이 가능합니다.\n- 여러 인코딩 지원: 다양한 텍스트 인코딩(예: UTF-8, UTF-16, ISO-8859-1 등)을 지원합니다.\n- 스트리밍 처리 지원: 데이터를 조각조각으로 처리할 수 있어 대용량 데이터 스트림 또는 실시간 처리가 필요한 데이터에 적합합니다.\n\n# TextDecoder API 사용 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, TextDecoder API를 사용하는 네 가지 시나리오를 소개하겠습니다:\n\n- 서로 다른 인코딩된 바이너리 데이터 해독\n- 스트리밍 JSON 데이터 디코딩\n- 대용량 JSON 파일의 데이터 청크 디코딩\n\n## 1. 서로 다른 인코딩된 바이너리 데이터 해독\n\n```js\n// 다른 인코딩으로 TextDecoder 인스턴스 생성\nconst utf16Decoder = new TextDecoder('utf-16');\nconst iso88591Decoder = new TextDecoder('iso-8859-1');\n\nconst utf16Array = new Uint16Array([0x0048, 0x0065, 0x006C, 0x006C, 0x006F]);\nconst iso88591Array = new Uint8Array([72, 101, 108, 108, 111]);\n\n// 문자열로 디코딩\nconst utf16String = utf16Decoder.decode(utf16Array);\nconst iso88591String = iso88591Decoder.decode(iso88591Array);\n\nconsole.log(utf16String); // 출력：\"Hello\"\nconsole.log(iso88591String); // 출력：\"Hello\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 스트리밍 JSON 데이터 디코딩\n\n먼저, 결과를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_1.png)\n\n위의 예제에서는 Node.js의 http 모듈을 사용하여 로컬 SSE (서버 전송 이벤트) 서버를 빠르게 구축합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nserver.js\n\n```js\nconst http = require(\"http\");\n\nconst PORT = 3000;\n\nconst server = http.createServer((req, res) =\u003e {\n  if (req.url === \"/sse\") {\n    res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\":\n        \"Origin, X-Requested-With, Content-Type, Accept\",\n    });\n\n    let id = 1;\n    const interval = setInterval(() =\u003e {\n      const data = {\n        id: id,\n        message: `This is message ${id}`,\n        timestamp: +new Date(),\n      };\n      res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\n      if (id == 5) {\n        res.write(\"event: end\\n\");\n        res.write(\"data: End of stream\\n\\n\");\n        clearInterval(interval);\n        res.end();\n      }\n\n      id++;\n    }, 1000);\n\n    req.on(\"close\", () =\u003e {\n      clearInterval(interval);\n    });\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n    res.end(\"404 Not Found\");\n  }\n});\n\nserver.listen(PORT, () =\u003e {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n```\n\nsse 핸들러에서는 Content-Type 응답 헤더의 유형을 \"text/event-stream\"으로 설정하여 클라이언트에게 스트리밍 데이터를 반환한다는 것을 알려줍니다.\n\nindex.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSSE \u0026 TextDecoder\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003ch1\u003e서버-전송 이벤트 JSON 스트림 데이터 디코딩\u003c/h1\u003e\n    \u003cdiv id=\"messages\"\u003e\u003c/div\u003e\n    \u003cscript src=\"client.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\nclient.js\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", () =\u003e {\n  const messagesDiv = document.querySelector(\"#messages\");\n  const textDecoder = new TextDecoder(\"utf-8\");\n\n  fetch(\"http://localhost:3000/sse\").then((response) =\u003e {\n    const reader = response.body.getReader();\n    return new ReadableStream({\n      start(controller) {\n        function push() {\n          reader.read().then(({ done, value }) =\u003e {\n            if (done) {\n              controller.close();\n              return;\n            }\n\n            const chunk = textDecoder.decode(value, { stream: true });\n            const lines = chunk.split(\"\\n\");\n\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const json = line.slice(6);\n                const data = JSON.parse(json);\n                const p = document.createElement(\"p\");\n                p.textContent = `ID: ${data.id}, Message: ${data.message}, Timestamp: ${data.timestamp}`;\n                messagesDiv.appendChild(p);\n              } else if (line.startsWith(\"event: end\")) {\n                const p = document.createElement(\"p\");\n                p.textContent = \"스트림의 끝\";\n                messagesDiv.appendChild(p);\n                return;\n              }\n            }\n            push();\n          });\n        }\n        push();\n      },\n    });\n  });\n});\n```\n\nSSE 이벤트 스트림은 간단한 텍스트 데이터 스트림이며 해당 텍스트는 UTF-8 형식을 사용하여 인코딩됩니다. 따라서 textDecoder 객체를 생성할 때 인코딩을 utf-8로 설정해야 합니다. 텍스트Decoder 객체가 준비되면 해당 객체가 제공하는 decode 메소드를 호출하여 디코딩할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 대용량 JSON 파일에서 데이터 청크 디코딩하기\n\n다시 한번, 먼저 결과를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_2.png)\n\n위 그림에서 JSON 데이터 출력은 다음 large.json 파일에서 나온 것입니다. 우리는 파일을 0.5KB씩 잘라서 500ms마다 다음 청크를 보내는 방식으로 처리합니다. @streamparser/json 라이브러리를 사용하여 JSON 청크를 파싱할 수 있는 기능을 구현했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nlarge.json\n\n```js\n[\n  {},\n  {\n    \"image\": [\n      {\n        \"shape\": \"rect\",\n        \"fill\": \"#333\",\n        \"stroke\": \"#999\",\n        \"x\": 0.5e1,\n        \"y\": 0.5,\n        \"z\": 0.8,\n        \"w\": 0.5e5,\n        \"u\": 2e10,\n        \"foo\": 2e1,\n        \"bar\": 2,\n        \"width\": 47,\n        \"height\": 47\n      }\n    ],\n    \"corners\": { \"1\": true, \"3\": true, \"7\": true, \"9\": true }\n  },\n ...\n]\n```\n\njson-server.js\n\n```js\nconst http = require(\"http\");\nconst { join } = require(\"path\");\nconst { readFileSync } = require(\"fs\");\n\nconst PORT = 3000;\n\nconst largeJson = readFileSync(join(__dirname, \"large.json\")).toString();\n\nconst server = http.createServer((req, res) =\u003e {\n  if (req.url === \"/stream-json\") {\n    res.writeHead(200, {\n      \"Content-Type\": \"application/json\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\":\n        \"Origin, X-Requested-With, Content-Type, Accept\",\n    });\n\n    const CHUNK_SIZE = 512;\n    let position = 0;\n\n    const interval = setInterval(() =\u003e {\n      const chunk = largeJson.slice(position, position + CHUNK_SIZE);\n      res.write(chunk);\n      position += CHUNK_SIZE;\n\n      if (position \u003e= largeJson.length) {\n        clearInterval(interval);\n        res.end();\n      }\n    }, 500);\n\n    req.on(\"close\", () =\u003e {\n      clearInterval(interval);\n    });\n  } else {\n    res.writeHead(404, { \"Content-Type\": \"text/plain\" });\n    res.end(\"404 Not Found\");\n  }\n});\n\nserver.listen(PORT, () =\u003e {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstream.html\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n    \u003ctitle\u003eStream JSON\u003c/title\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003ch1\u003eStream JSON\u003c/h1\u003e\n    \u003cdiv id=\"messages\"\u003e\u003c/div\u003e\n    \u003cscript type=\"module\"\u003e\n      import { JSONParser } from \"https://cdn.jsdelivr.net/npm/@streamparser/json-whatwg@0.0.21/+esm\";\n      const messagesDiv = document.querySelector(\"#messages\");\n\n      document.addEventListener(\"DOMContentLoaded\", async () =\u003e {\n        const parser = new JSONParser();\n\n        const response = await fetch(\"http://localhost:3000/stream-json\");\n\n        const reader = response.body.pipeThrough(parser).getReader();\n        while (true) {\n          const { done, value: parsedElementInfo } = await reader.read();\n          if (done) break;\n\n          const { value, key, parent, stack, partial } = parsedElementInfo;\n          if (partial) {\n            console.log(`Parsing value: ${value}... (still parsing)`);\n          } else {\n            const p = document.createElement(\"p\");\n            p.textContent = `${JSON.stringify(value)}`;\n            messagesDiv.appendChild(p);\n            console.log(`Value parsed: ${JSON.stringify(value)}`);\n          }\n        }\n      });\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n@streamparser/json 라이브러리는 다른 용도도 있어요. 관심이 있다면 사용 설명서를 살펴보세요. TextDecoder API에 대한 다른 유용한 사용 사례가 있으면 댓글을 남겨주세요.\n\nTypeScript는 정말 멋지고 배울 가치가 있어요. TypeScript를 배우고 싶다면 Medium이나 Twitter에서 저를 팔로우해서 TS와 JS에 관한 더 많은 내용을 읽을 수 있어요!","ogImage":{"url":"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png"},"coverImage":"/assets/img/2024-05-20-HowToTransferLargeJSONFilesEfficiently_0.png","tag":["Tech"],"readingTime":9},{"title":"러스트 트레이트 TypeScript 인터페이스의 강력한 대안","description":"","date":"2024-05-20 21:42","slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface","content":"\n\n\n![RustTraitAPowerfulAlternativeToTypeScriptInterface](/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png)\n\nRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\n\n이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\n\n# 선언\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\n\n인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\n\nTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\n\n```js\ninterface Entity {\n    id: string;\n    timestamp: number;\n}\n\ninterface Document extends Entity {\n    revised: boolean;\n}\n\ninterface Image extends Entity {\n    type: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\n\n```js\nstruct Document {\n    id: String,\n    timestamp: u64,\n    revised: bool,\n}\n\nstruct Image {\n    id: String,\n    timestamp: u64,\n    mime_type: String,\n}\n```\n\n# 상속 및 제네릭\n\n이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e\n documents.find(({ id: docId }) =\u003e docId === id);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e\n images.find(({ id: imageId }) =\u003e imageId === id);\n```\n\n하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\n\n```js\nconst get = \u003cT extends Entity\u003e(\n id: string,\n elements: T[]\n): T | undefined =\u003e\n elements.find(({ id: elementId }) =\u003e elementId === id);\n\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e get\u003cDocument\u003e(id, documents);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e get\u003cImage\u003e(id, images);\n```\n\nRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rs\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    documents.into_iter().find(|document| document.id == id)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    images.into_iter().find(|image| image.id == id)\n}\n```\n\n위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\n\n이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\n\n```rs\ntrait Compare {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool;\n}\n\nimpl Compare for Document {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n\nimpl Compare for Image {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\n\n```js\nfn get\u003cT: Compare\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements.into_iter().find(|element| element.compare(\u0026id))\n}\n\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    get(id, documents)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    get(id, images)\n}\n```\n\n또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\n\n```js\nfn get\u003cT: Compare + OtherTrait\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements\n        .into_iter()\n        .find(|element| element.compare(\u0026id) \u0026\u0026 element.other_trait(\u0026id))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\n\n```rust\ntrait Compare {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering;\n}\n\nimpl Compare for Document {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.timestamp.cmp(\u0026other.timestamp)\n    }\n}\n```\n\n# 결론\n\n우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무한한 여정이 시작됩니다\n데이비드\n\n더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"},"coverImage":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png","tag":["Tech"],"readingTime":4},{"title":"프론트엔드 주간 소식: 2024년 5월 13일  5월 19일","description":"","date":"2024-05-20 21:41","slug":"2024-05-20-FrontendWeeklyDigest3631319May2024","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png\" /\u003e\n\n# 웹 개발\n\n- 온라인 콘텐츠가 사라질 때: 2013년에 존재했던 웹페이지 중 38%가 10년 후에는 더 이상 접근할 수 없음\n- 로컬 파일을 배포하여 라이브 웹사이트 만들기\n- WebRTC를 활용한 P2P 비디오 스트리밍 구현하기\n- NoJS 2 - 확률적인 부갈루. 순수 HTML과 CSS를 사용해 '랜덤성'을 추가하여 틱택토 게임 만들기. 자바스크립트 없이!\n- 정적 사이트도 확장이 가능하다: 11ty 이벤트에서 Eleventy 대 Next.js 비교\n- 서버 로딩 시 Prefetching이 작동하지 않을 때\n- 다중 페이지 애플리케이션 뷰 전환이 도착했습니다(Google I/O 2024)\n\n- 도구\n- GTmetrix의 새로운 디자인\n- 대부분의 개발자가 알지 못하는 5가지 멋진 Chrome 개발자 도구 기능\n- Safari 17.4의 최신 Webkit 기능 이해\n\n- 접근성\n- 웹에서 텍스트 크기 조정을 다시 생각하기\n- 웹을 보다 접근 가능하게 만들기: 메뉴와 로더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CSS\n\n- CSS 변수 대신 사용자 정의 @property가 필요한 경우\n- JS-Free 사이트 메뉴를위한 앵커 위치 지정 및 팝오버 API\n- CSS 미디어 쿼리 너머\n- 준수 대 가독성: CSS로 텍스트 색상 생성\n- 시간 기반 CSS 애니메이션\n- 전통적인 테두리 반경 권고 사항과 더 이상의 비범한 요령\n- CSS 메이슨리의 구문과 이름보다 tabbing 동작에 대해 걱정합니다.\n\n# JavaScript\n\n- JavaScript 패키지 문서화하는 방법\n- 프로젝트에 적합한 라이브러리 선택: htmx vs. React\n- Vuejs Amsterdam 2024, 29개 동영상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript\n  - TypeScript Adventures: Prop Drilling Down the Rabbit Hole\n  - ReScript vs. TypeScript: Overview and comparison\n  - Dynamic Github profile with Bun and Typescript\n- React\n  - Snappy UI Optimization with useDeferredValue\n  - Bulletproof React — A simple, scalable, and powerful architecture for building production ready React applications.\n  - Meta Releases Open Source React Compiler\n  - 5 Tips and Tricks To Make Your Life With Next.js 14 Easier\n  - What’s New at React Conf 2024\n  - It’s not just you, Next.js is getting harder to use\n- Angular\n  - Angular 18 will arrive next week\n  - Angular 18: Revolutionizing Web Development with Cutting-Edge Features\n  - Simplifying Client-Side Logic: The Strategic Use of View Models\n  - Template local variables with @let in Angular","ogImage":{"url":"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png"},"coverImage":"/assets/img/2024-05-20-FrontendWeeklyDigest3631319May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"장고로 대규모 프로젝트를 만드는 방법","description":"","date":"2024-05-18 22:36","slug":"2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png\" /\u003e\n\n요즘 장고는 이미 잘 아시겠지만, 큰 아이디어를 현실로 만들 때 절대적인 선택지입니다. 몇 가지를 만들어본 코더로서, 때로는 뭔가 엄청난 일들을 하려다 보면 조금씩 자신감이 떨어지기도 합니다. 그렇죠? '음, 장고가 이걸 오랫동안 버틸 수 있을까?' 하고 걱정이 드는 건 당연한 일입니다. 장고의 속도와 구조는 정말 생명을 살려주죠. (첫 번째 어드민 패널을 사용했을 때의 마법 같은 경험을 기억하시나요?) 하지만 여러분과 같은 코더로서, 나중에 복잡한 병목 현상을 걱정하기 시작할 때의 기분을 잘 아실 거예요.\n\n그러니까, 팬보이들의 이야기는 좀 떠나서 진짜 개발자들끼리 진지한 대화를 나눠보자고요. 장고는 정말 비범한 프로젝트에 대응할 수 있는 걸까요? 어디가 한계일까요? 이것이 정말 올바른 선택이며, 나중에 후회하지 않을 결정인지 어떻게 확신할 수 있을까요? 구글부터 현재 파이썬을 가르치고 있는 저의 경험에 따르면, 파헤쳐야 할 것들이 많다고 생각합니다.\n\n# 장고가 빛을 발하는 곳: 아이디어를 가속화합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빠른 시작, 빠른 반복: Django의 '전부 구비'는 빈말이 아닙니다. 사용자 인증이 필요한가요? 퍼워, 이미 구현되어 있어요. 객체-관계 매핑은? 해결했어요. 초기 단계는 아이디어를 발전시키는 데 집중할 수 있는 시간이에요. 새 프로젝트를 시작할 때 항상 Django를 선택하는 이유죠.\n- 구조가 정신 건강을 지킨다: 사실 몇몇 프로젝트는 빨리 코드 공룡이 될 수 있어요. Django의 모델은 데이터 관계를 깔끔하게 유지시켜주고 관리 패널은 전체 구조를 한 눈에 볼 수 있게 해줘요. 몇 달 후 코드를 다시 보게 되었을 때, 이것은 과거의 자신으로부터의 선물 같이 느껴질 거에요.\n- Django 커뮤니티의 지혜: 이상한 버그에 걸렸나요? 대형 Django 커뮤니티 속에 이미 누군가가 그것을 보았을 가능성이 높아요. Stack Overflow, 포럼, 블로그 사이에서 진짜로 꼼꼼히 막히는 일은 드물죠. 데드라인에 쫓겨 있을 때는 그만한 가치가 있다고 생각해요.\n\n## 예시: 내 컨텐츠 집계기가 작동 중\n\n당신의 컨텐츠 집계기를 떠올려보세요. Django를 사용한다면 아마 이와 같은 모델을 갖게 될 거에요:\n\n```js\nclass Source(models.Model):\n    name = models.CharField(max_length=100)\n    url = models.URLField()\n    # ... 기타 업데이트 주기 추적을 위한 필드들 \n\nclass Article(models.Model):\n    title = models.CharField(max_length=255)\n    content = models.TextField()\n    source = models.ForeignKey(Source, on_delete=models.CASCADE)\n    # ... 발행일, 작가 등을 위한 필드들\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보니까 많이 깨끗하다, 맞지? Django는 데이터베이스 관련 작업을 맡아 처리해주기 때문에 당신은 콘텐츠를 가져오고 표현하는 로직에 주력할 수 있어요. \n\n# 야망이 Django를 넘어설 때\n\n- 트래픽 몬스터: 그만봐도 알겠지만, 만약 다음 바이럴 히트를 만들고 있다면, 로우 Django는 이에 대응하기 어려울 수도 있어요. 하지만 이것은 Django의 실패가 아니에요! 여기에는 스마트한 아키텍처가 필요해요. 캐싱(미리 생성된 콘텐츠), 로드 밸런서(작업 분산), 그리고 쿼리 최적화를 고려하면 Django를 놀랄 정도로 멀리 뻗을 수 있어요.\n- 픽셀 퍼펙션 애정: 맞춤 및 혁신적인 상호작용이 필요한 디자인이 있는가요? Django의 템플릿 및 내장 구성 요소는 강력하지만, 매우 맞춤화된 UI는 씨름이 될 수도 있어요. Django와 함께 JavaScript 프레임워크를 고려하는 것이 더 현명한 장기적인 계획일 수 있어요.\n- 최신 기술에 대응: Django는 안정성과 신뢰할 수 있는 패키지의 거대한 생태계를 기반으로 발전해요. 만약 핵심 아이디어가 최신 AI 라이브러리나 실험적인 기술에 의존한다면 어려움에 부딪힐 수 있어요. 불가능한 것은 아니지만 소매를 걷고 통합 작업을 하기 위해 소매를 걷어올려야 할 준비를 해야 해요.\n\n## 예시: 게임이 시작될 때\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 멋진 실시간 멀티플레이어 게임 아이디어를 상상해 보세요. 물리 시뮬레이션, 게임 상태에 대한 지속적인 업데이트... Django는 플레이어 계정, 로비 등을 처리할 수 있지만 실시간, 저지연의 액션은 아마도 그 부분을 위해 특화된 도구가 필요할 것입니다. Django는 '큰 그림'을 관리하게 됩니다.\n\n중요한 참고사항: Django가 나쁜 것은 아닙니다! 모든 시나리오에 완벽한 도구는 없다는 점을 솔직하게 인식하는 것입니다. 숙련된 개발자의 초능력은 전략적으로 도구를 조합할 때를 알 수 있는 데에 있습니다.\n\n# \"달라질 수 있다\" 요소: Django만의 문제가 아닙니다\n\n- 당신의 팀의 Django-기술: 알고 있는 Django 팀은 요령을 알고 있습니다. 쿼리 최적화하는 방법, 장기적인 데이터 구조, 그리고 언제 추가 도구를 전략적으로 도입할지 알고 있습니다. Django에 익숙한 팀이 아닌 경우? 그들도 그 수준에 도달할 것이지만, 학습 곡선이 프로젝트 기한과 겹칠 수 있습니다.\n- 데이터 중심 vs. 야생의 서쪽: Django는 구조화된 데이터에서 빛을 발합니다. 전자상거래 사이트, 콘텐츠 플랫폼, 심지어 내부 도구들... 거기서 잘 동작합니다. 그러나 만약 당신의 아이디어가 예측할 수 없는 데이터 유형이나 상호작용을 가진 매우 실험적인 경우, Django를 자신의 의지에 맞게 굽히느라 건설하는 것보다 더 많은 시간을 보낼지도 모릅니다.\n- 야심찬...어떻게, 정확히? 백만 명의 사용자는 말하는 건가요, 그러나 비교적 직관적인 기능들일까요? Django는 스마트한 최적화로 이를 처리하는 경우가 많습니다. 그러나 적은 사용자지만 괴로운 완전히 복잡한 기능과 톤의 맞춤 논리가 있는 경우는? 그건 다른 종류의 도전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코딩의 아름다움(그리고 때로는 좌절!)은 보편적으로 '최고'인 도구가 없다는 점입니다. 올바른 선택은 이러한 요소들과 어떻게 조화를 이루느냐에 따라 달라집니다. 판단은 여러분의 최대 자산인 경험에 달려있어요.\n\n간단한 시나리오를 보여드리죠: 여러분의 컨텐츠 집계기가 성공적입니다. 하지만 홈페이지가 다수의 소스에서 최신 기사를 가져오기 때문에 느려지고 있어요.\n\n초보적인 접근 방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.all().order_by('-published_date')[:20] \n    return render(request, 'homepage.html', {'articles': latest_articles})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 이 방법은 모든 기사를 매번 가져와서 표시를 위해 슬라이스합니다. 데이터베이스가 커질수록 문제가 심각해집니다.\n\n최적화된 접근방식:\n\n```js\ndef homepage_view(request):\n    latest_articles = Article.objects.select_related('source').order_by('-published_date')[:20]\n```\n\n변경된 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- select_related: 이것은 Django에게 각 기사에 대해 관련 'Source' 객체를 미리 가져오도록 지시하여 나중에 데이터베이스 작업을 줄입니다.\n- Queryset Slicing: 우리는 필요한 최상위 20개만 가져옵니다, 모든 것을 가져오지 않습니다.\n\n왜 중요한가: 이 문제는 작아 보일 수 있지만, 규모에 맞게 그 최적화 작업은 빠른 사이트와 부하 하에 격렬하게 돌아가는 사이트 사이의 차이를 만들어냅니다. 이것은 경험 많은 Django 개발자가 제공하는 사고 방식입니다.\n\n# 정직한 판단\n\n- Django: 스위스 아미 나이프, 레이저 빔이 아님 Django는 상상할 수 있는 모든 것을 구축하는 데 관한 것이 아닙니다. 대신, 수많은 웹 프로젝트를 빠르고 훌륭하게 구축하는 데 중점을 두고 있습니다. 때로는 전문화된 도구가 필요할 때도 있습니다. 그것은 괜찮습니다!\n- 구축을 시작하고, 답이 나타날 것입니다: 솔직히 말해서, Django가 장기적으로 적합한지 알아보는 가장 좋은 방법은 직접 해 보는 것입니다. 초기 속도를 통해 잠재적인 병목 현상이 실제 문제가 되기 훨씬 전에 발견할 수 있습니다. '만약' 때문에 시작하는 것을 막지 마세요.\n- Django보다 크게 생각하십시오: 데이터베이스가 중요합니다! 확장성을 고려하지 않고 나쁜 데이터베이스를 선택하면, Django 코드가 얼마나 좋든 손해를 입을 것입니다. 같은 이유로 엉성한 배포도 마찬가지입니다 - 느린 서버는 모든 것을 느리게 만듭니다. 전문가적인 마인드는 전체 시스템에 대한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Django의 모든 문제가 아닙니다\n\n성능적인 한계에 부딪혔다고 가정해 봅시다. Django를 포기하기 전에 다음을 고려해 보세요:\n\n- 쿼리 시간: 데이터베이스 조회가 엉망인가요? 최적화는 매우 중요합니다 (이전 예시를 참고하세요!)\n- 외부 요소: 서버 성능이 좋지 않은가요? 의존하는 외부 API가 병목 현상을 일으키나요?\n\n핵심 포인트: Django는 여러분의 도구상자에서 강력한 도구일 뿐, 유일한 존재는 아닙니다. 성공은 이러한 조각들을 잘 맞물리게 하는 데에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 추가 맛\n\n- 장고 거인들: 인스타그램이 Django를 떠나기로 유명하다고 하지만, Disqus, Eventbrite, 심지어 NASA와 같은 사이트들은 여전히 시스템의 핵심 부분에 의지하고 있습니다. 규모는 상대적이며, Django의 매력 포인트는 생각보다 넓습니다.\n- 나의 Django '아하!' 순간: 프로젝트가 Django를 벗어나야 한다고 생각했어요. 복잡한 데이터, 수많은 맞춤 기능... 몇 가지 잘못된 쿼리가 문제의 원인이라는 것을 발견했습니다! 그것들을 다시 작업하니 Django가 새로운 존재처럼 느껴졌어요. 배운 교훈: 탈주하기 전에 최적화 작업을 하세요.\n- 전쟁 이야기를 나눠보세요: Django가 승리한 이야기나 실망했던 순간에 대한 이야기를 가지고 계신가요? 댓글에서 공유해주세요! 이런 경험들이 우리를 더 나아지게 하는 방법입니다. Django 커뮤니티가 강한 이유가 있습니다 — 우리는 이런 것에 대해 열정적으로 이야기하는 것을 좋아합니다.\n\n## 더 알아보기\n\n만약 이러한 해설이 도움이 되었다면, 중요한 Python과 Django 통찰을 좀 더 파헤치겠습니다. 제 Medium 페이지를 팔로우해주시고, 대화를 이어가고, 만약 가치 있다고 느끼시면 박수를 치세요. 또한, 곧 YouTube 채널을 시작할 준비 중이니, 더 많은 코딩 모험을 기대해주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 번역  🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 이렇게 가기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인해보세요","ogImage":{"url":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png"},"coverImage":"/assets/img/2024-05-18-CanDjangoHandleYourAmbitiousProjectLetsBeHonest_0.png","tag":["Tech"],"readingTime":6},{"title":"템플릿 간소화하기 Angular 17에서의 제어 흐름","description":"","date":"2024-05-18 22:35","slug":"2024-05-18-StreamlineYourTemplatesControlFlowinAngular17","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png\" /\u003e\n\n안녕하세요, Angular 열정가 여러분! 오늘은 Angular 17의 새로운 혁신인 내장 제어 흐름 구문을 발표하려고 왔어요! 이 새로운 기능을 사용하면 추가 지시문 (ngIf, ngFor, ngSwitch)을 버리고 집에 온 듯한 키워드를 사용하여 템플릿에서 제어 흐름 로직을 직접 작성할 수 있어요 (자바스크립트 같아요!). 이것이 어떻게 당신의 Angular 경험을 향상시키는 지 한번 알아봐요!\n\n우리는 여러 해 동안 조건부로 콘텐츠를 렌더링하고 데이터를 반복하는 데 지시문을 의존해 왔어요. 그들은 작동하지만 템플릿에 혼란과 복잡성의 추가 레이어를 덧붙일 수 있어요. Angular 17은 @if, @else if, @switch 및 @for 같은 익숙한 키워드를 사용하여 템플릿 내에서 직접 제어 흐름 로직을 작성할 수 있게 해줘요. 이러면 코드가 더 깔끔하고 읽기 쉽고 일반적인 자바스크립트를 작성하는 느낌이 들어요!\n\n## 왜 지시문 대신 제어 흐름을 선택해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 변경하는 것이 좋은 몇 가지 설득력 있는 이유입니다:\n\n- 뚜렷한 가독성: 제어 흐름 구문은 JavaScript의 제어 흐름 구조를 반영하여, JavaScript에 익숙한 사람들에게 이해하기 쉬운 템플릿을 만드는 데 도움이 됩니다.\n- 중복성 감소: ✂️ 제어 흐름을 통해 여분의 지시문이 필요 없어져 더 깔끔하고 간결한 템플릿을 생성할 수 있습니다.\n- 현대적인 개발 경험: 제어 흐름은 현대적인 JavaScript 관행과 일치하며, 일관되고 익숙한 개발 경험을 촉진합니다. 이는 더 적은 정신 부담과 놀라운 기능을 구축하는 데 더 많은 시간을 집중할 수 있다는 것을 의미합니다!\n\n# @if와 @else로 익숙함을 받아들이다\n\n참/거짓 변수에 따라 메시지를 표시하려는 시나리오를 상상해보십시오. 기존에는 다음과 같이 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (isLoggedIn) {\n  \u003cp\u003e다시 오신 것을 환영합니다!\u003c/p\u003e\n} @else {\n  \u003cp\u003e로그인해주세요.\u003c/p\u003e\n}\n```\n\n이렇게 제어 흐름 구문을 사용하면 JavaScript에서 제어 흐름을 작성하는 방식과 더 자연스러워집니다. 더 복잡한 조건을 위해 @else if 문을 연결할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Level Up Loops with @for\n\n데이터 컬렉션을 반복하는 것은 Angular 애플리케이션의 기본적인 부분입니다. 이전에 우리는 *ngFor을 사용했습니다. 제어 흐름은 유사한 접근 방식을 제공합니다:\n\n```js\n\u003cul\u003e\n  \u003cli *ngFor=\"let fruit of fruits\"\u003e{ fruit.name }\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n제어 흐름에 대한 비교:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cul\u003e\n  @for (과일 in 과일들; trackBy: 과일.name) {\n    \u003cli\u003e{ 과일.name }\u003c/li\u003e\n  } @empty {\n    \u003cli\u003e과일이 없습니다.\u003c/li\u003e\n  }\n\u003c/ul\u003e\n```\n\n하지만 기능이 향상되었습니다! 제어 흐름 구문을 사용하려면 trackBy를 사용하여 추적 함수를 지정해야 합니다. 이렇게 하면 Angular가 컬렉션 내의 변경 사항을보다 효율적으로 식별하여 앱이 특히 대규모 데이터 세트로도 원활하게 실행되도록 지원합니다! ❤️\n\n# @switch로 결정 내리기 ⚖️\n\n여러 조건에 따라 콘텐츠를 렌더링해야 하는 경우 @switch 문이 구원의 손을 내밀어줍니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@switch(selectedFruit) {\n  @case(apple){\n    \u003cp\u003e사과를 선택하셨네요!\u003c/p\u003e\n  }\n  @case(banana){\n    \u003cp\u003e바나나는 포타슘의 좋은 원천입니다!\u003c/p\u003e\n  }\n  @default {\n    \u003cp\u003e그것은 제가 알아듣는 과일이 아니에요.\u003c/p\u003e\n  }\n}\n```\n\n이렇게 하면 템플릿 안에서 switch-case 로직을 보다 간결하고 가독성 있게 처리할 수 있어요. 멋지죠? ✨\n\n# 링크\n\n아래에서 제어 흐름 구문의 상세 정보를 찾을 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angular — @for\n- Angular — @switch\n- Angular — @if","ogImage":{"url":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png"},"coverImage":"/assets/img/2024-05-18-StreamlineYourTemplatesControlFlowinAngular17_0.png","tag":["Tech"],"readingTime":3},{"title":"PHP 8.3에 추가된 20가지 흥미로운 기능들 정리","description":"","date":"2024-05-18 22:31","slug":"2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss","content":"\n\n## 웹 개발과 프로그래밍을 혁신하는 PHP 8.3의 최신 기능 및 개선 사항을 알아보세요.\n\n![이미지](/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png)\n\n인기 있는 서버 측 스크립팅 언어인 PHP의 최신 버전인 PHP 8.3은 새로운 기능과 개선 사항이 많이 포함되어 있어 웹 개발을 최적화하고 성능을 향상시킬 것을 약속합니다. readonly 클래스, 새 json_validate() 함수, Randomizer 클래스에 대한 추가, 더 적합한 날짜/시간 예외 등의 개선 사항을 통해 PHP 8.3은 PHP 개발 경험을 혁신할 것입니다. 이러한 업데이트는 PHP를 더 효율적, 안전하고 다양하게 만들어 웹 개발자와 기업의 변화하는 요구를 충족시키기 위해 목적을 두고 있습니다.\n\n# PHP 8.3의 20가지 흥미로운 기능 및 개선 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 읽기 전용 클래스 개선 사항\n- 새로운 json_validate() 함수\n- Randomizer 클래스에 대한 추가 기능\n- 타입이 지정된 클래스 상수\n- 익명 읽기 전용 클래스\n- 동적 클래스 상수 검색\n- 보다 적절한 날짜/시간 예외 처리\n- 개선된 unserialize() 오류 처리\n- 트레이트 및 정적 속성\n- 스택 오버플로 감지\n- 일정 상수 가시성\n- Assert String Eval 정리\n- 향상된 FFI\\CData:void\n- posix_getrlimit() 매개변수 개선\n- gc_status() 개선\n- 내부 클래스에 대한 class_alias() 지원\n- mysqli_poll() 오류 처리\n- array_pad() 개선 사항\n- opcache.consistency_checks ini 지시문 제거\n- number_format()을 사용하여 소수점 처리를 올바르게 처리\n\n# 1. 읽기 전용 클래스 개선 사항\n\nPHP 8.3에서 읽기 전용 클래스에 중요한 개선 사항이 있어 개발자들이 코드를 더 유연하고 효율적으로 제어할 수 있게 되었습니다. 특정하지만 중요한 엣지 케이스를 해결하기 위해 생성 및 복제 시 읽기 전용 속성을 다시 초기화할 수 있는 기능이 추가되었습니다. 이번 업그레이드로 읽기 전용 속성의 딥 클론이 가능하게 되어 PHP에서 읽기 전용 클래스의 유틸리티가 확장되었습니다. 다음은 DateTime 속성을 가진 읽기 전용 클래스의 예시입니다:\n\n```js\nreadonly class Post {\n    public function __construct(public DateTime $createdAt) {\n        // 생성자 로직\n    }\n\n    public function __clone() {\n        $this-\u003ecreatedAt = new DateTime();\n        // 읽기 전용 속성을 다시 초기화하는 것이 이제 허용됩니다\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서 Post 클래스에는 읽기 전용 속성 $createdAt이 있습니다. 이 속성은 게시물의 생성 날짜를 나타냅니다. PHP 8.3에서 개선된 사항으로, __clone() 메서드를 사용하여 읽기 전용 속성을 다시 초기화할 수 있어 객체의 깊은 복제를 가능하게 하고 읽기 전용 속성의 무결성을 해치지 않습니다.\n\n# 2. 새로운 json_validate() 함수\n\njson_validate() 함수의 도입으로 개발자들은 JSON 문자열을 유효성 검사하는 더 효율적이고 직접적인 방법을 제공받게 되었습니다. 이 함수는 JSON 문자열의 유효성을 확인해야 할 때 복호화 과정 없이 바로 확인할 수 있어 매우 유용합니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\nif (json_validate($jsonString)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서는 json_validate() 함수를 사용하여 JSON 문자열 $jsonString을 직접 유효성 검사합니다. JSON 문자열이 유효하면 해당 메시지가 표시됩니다. 이 함수는 디코딩 및 오류 처리 없이 JSON 데이터를 유효성 검사하는 간단한 방법을 제공합니다.\n\n사용자 정의 깊이와 플래그를 지정할 수도 있습니다.\n\n```js\n$jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\n\n// 사용자 정의 깊이와 플래그로 JSON 문자열 유효성 검사\nif (json_validate($jsonString, 512, JSON_THROW_ON_ERROR)) {\n    echo \"JSON 문자열이 유효합니다.\";\n} else {\n    echo \"JSON 문자열이 유효하지 않습니다.\";\n}\n```\n\n이 예제에서는 사용자 정의 깊이와 플래그로 json_validate() 함수를 사용했습니다. 두 번째 매개변수는 JSON 문자열의 최대 깊이를 지정하고, 세 번째 매개변수는 유효성 검사를 위한 플래그를 설정합니다. 이를 통해 개발자는 특정 요구 사항에 맞게 유효성 검사 과정을 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPHP 8.3에서 json_validate() 함수는 JSON 유효성 검사 프로세스를 간소화하여 JSON 문자열을 해독하는 대안으로 더 효율적인 메모리를 제공합니다. 이 향상된 기능은 JSON 데이터의 유효성만을 확인해야 하는 시나리오에서 특히 유용하며 PHP 애플리케이션에서 성능과 자원 활용을 향상시킵니다.\n\n# Randomizer 클래스에 추가된 내용\n\nRandomizer 클래스는 새로운 메서드로 확장되어 개발자가 더 많은 제어와 유연성을 가지고 무작위 데이터를 생성할 수 있게 되었습니다. 이러한 추가 기능은 Randomizer 클래스의 기능을 확장하여 지정된 범위와 제약 조건 내에서 무작위 값을 생성하는데 탁월한 지원을 제공합니다.\n\n```js\nuse Randomizer;\n\n$string = \"Hello, World!\";\n$length = 10;\n\n$randomBytes = Randomizer::getBytesFromString($string, $length);\nvar_dump($randomBytes);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 Randomizer 클래스의 getBytesFromString() 메서드는 지정된 길이($length)의 랜덤 바이트 문자열을 주어진 입력 문자열($string)에서 생성하는 데 사용됩니다. 이 메서드는 랜덤 데이터 생성이 필요한 시나리오에 기반하여 소스 문자열을 기반으로 랜덤 바이트 시퀀스를 생성하는 편리한 방법을 제공합니다.\n\n또한 지정된 범위 내에서 랜덤 정수를 생성할 수도 있습니다.\n\n```js\nuse Randomizer;\nuse IntervalBoundary;\n\n$min = 10;\n$max = 20;\n\n$randomInteger = Randomizer::getRandomInteger($min, $max, IntervalBoundary::Closed);\necho $randomInteger;\n```\n\n이 예시에서 Randomizer 클래스의 getRandomInteger() 메서드는 $min과 $max로 정의된 범위 내에서 랜덤 정수를 생성하는 데 활용됩니다. IntervalBoundary::Closed 열거형은 최소값과 최대값을 범위에 포함해야 함을 나타내는 데 사용됩니다. 이 메서드는 개발자들이 특정 범위 내에서 랜덤 정수를 생성할 수 있도록 돕고 생성된 값에 대한 정확한 제어를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPHP 8.3의 Randomizer 클래스에 추가 사항은 더 향상된 랜덤 데이터 생성 기능을 제공하여, 다양한 제어된 무작위성을 필요로 하는 사용 사례에 맞춤 기능을 제공합니다. 이러한 방법들은 PHP 개발자들에게 사용 가능한 랜덤 데이터 생성 옵션의 범위를 풍부하게 하여 Randomizer 클래스의 전반적인 다양성과 유틸리티에 기여합니다.\n\n# 4. Typed class constants\n\n타입화된 클래스 상수의 도입은 특정 데이터 유형과 함께 클래스 상수를 정의할 수 있도록 하여, 클래스 정의 내에서 향상된 유형 안전성과 명확성을 제공합니다. 이 향상된 기능을 통해 개발자들은 클래스 상수에 대한 유형 제약을 강제할 수 있어 코드의 가독성을 향상시키고 의도하지 않은 데이터 유형 불일치 가능성을 줄일 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass MathOperations {\n    public const PI: float = 3.14159;\n    public const MAX_ITERATIONS: int = 1000;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 MathOperations 클래스는 두 개의 클래스 상수, PI와 MAX_ITERATIONS을 특정 데이터 유형으로 정의합니다. PI 상수는 float로, MAX_ITERATIONS 상수는 INT로 유형이 지정됩니다. 이렇게 함으로써 이러한 상수가 지정된 데이터 유형의 값을 보유하도록 보장하여 유형 안전성을 증진시키고 코드 가독성을 높입니다.\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT: int = 30;\n    public const ENABLE_LOGGING: bool = true;\n    \n    public function setRequestTimeout(int $timeout): void {\n        // Set the request timeout using the DEFAULT_TIMEOUT constant\n        // defined as an integer\n        // ...\n    }\n    \n    public function enableLogging(bool $enable): void {\n        // Enable or disable logging based on the ENABLE_LOGGING constant\n        // defined as a boolean\n        // ...\n    }\n}\n```\n\n이 예에서 Configuration 클래스는 유형화된 클래스 상수를 사용하여 기본 시간 초과 및 로깅 설정 옵션을 정의합니다. DEFAULT_TIMEOUT 상수는 INT로 유형이 지정되어 정수 값을 보유하도록 보장하고, ENABLE_LOGGING 상수는 boolean으로 유형이 지정되어 boolean 값을 보유함을 나타냅니다. 이를 통해 클래스 메서드 내에서 이러한 상수를 사용할 때 일관성과 유형 안전성이 증진됩니다.\n\nPHP 8.3에서 유형화된 클래스 상수의 도입은 클래스 정의의 표현성과 신뢰성을 향상시킵니다. 개발자가 클래스 상수에 대한 데이터 유형을 지정할 수 있어 코드 품질 향상, 더 나은 문서 작성, 클래스 상수 내 데이터 유형 오류 가능성 감소에 기여하며, 결국 PHP 애플리케이션의 견고성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 익명 읽기 전용 클래스\n\n익명 읽기 전용 클래스의 소개는 객체 지향 프로그래밍에 새로운 유연성을 가져 왔습니다. 이러한 클래스를 사용하면 명명된 클래스를 명시적으로 정의할 필요 없이 가벼운 불변 객체를 생성할 수 있습니다. 이 기능은 일시적이거나 일회성 객체가 필요한 시나리오에서 특히 유용합니다. 포멀한 클래스 선언의 오버헤드 없이 필요한 임시 객체를 만들 수 있습니다. 이 기능을 몇 가지 예제를 통해 알아봅시다:\n\n```js\n$person = new class {\n    public function __construct(public string $name, public int $age) {}\n};\n\n$john = new $person('John Doe', 30);\necho $john-\u003ename; // 출력: John Doe\necho $john-\u003eage; // 출력: 30\n```\n\n이 예제에서는 '...' 구문을 사용하여 익명 읽기 전용 클래스를 생성합니다. 이 클래스에는 name 및 age에 대한 공용 속성이 있으며, 이 익명 클래스에서 $john 객체가 인스턴스화됩니다. 이를 통해 포멀한 클래스 선언이 필요 없이 간단하고 가벼운 객체를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n익명 읽기 전용 클래스를 데이터 구조로 사용할 수도 있습니다.\n\n```php\n$data = new class {\n    public array $values = [];\n\n    public function addValue($value): void {\n        $this-\u003evalues[] = $value;\n    }\n};\n\n$data-\u003eaddValue('A');\n$data-\u003eaddValue('B');\n$data-\u003eaddValue('C');\n\nprint_r($data-\u003evalues); // 출력: Array ( [0] =\u003e A [1] =\u003e B [2] =\u003e C )\n```\n\n이 예제에서는 익명 읽기 전용 클래스를 사용하여 값을 저장하는 간단한 데이터 구조를 만듭니다. 클래스에는 배열을 보유하는 공개 속성 values와 배열에 값을 추가하는 addValue 메서드가 있습니다. 이 예는 공식 클래스 정의 없이 즉석에서 작성된 데이터 구조를 만들기 위해 익명 읽기 전용 클래스를 사용하는 방법을 보여줍니다.\n\nPHP 8.3에서 익명 읽기 전용 클래스가 소개되면서 개발자들은 불변의 객체와 데이터 구조를 가볍고 유연하게 즉석에서 만들 수 있게 되었습니다. 이 기능은 PHP의 객체 지향 기능을 보다 표현력 있고 다용도로 사용할 수 있게 하며, 특정 상황에 대해 전통적인 클래스 선언에 대한 편리한 대안을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 동적 클래스 상수 가져오기\n\n이 기능은 개발자들이 클래스 상수를 더 동적인 구문을 사용하여 가져올 수 있게 해주어 클래스 상수를 다룰 때 더 큰 유연성과 표현력을 제공합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass Configuration {\n    public const DEFAULT_TIMEOUT = 30;\n    public const ENABLE_LOGGING = true;\n}\n\n$constantName = 'DEFAULT_TIMEOUT';\necho Configuration::{$constantName}; // 출력: 30\n```\n\n이 예제에서 DEFAULT_TIMEOUT 클래스 상수의 값을 변수 $constantName을 사용하여 동적으로 가져왔습니다. 이 동적 구문을 사용하면 실행 중 값에 따라 클래스 상수를 검색할 수 있어 클래스 상수를 다루는 더 유연한 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해도 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 더 적절한 날짜/시간 예외 처리\n\n이 기능은 다양한 날짜 및 시간 관련 특이 케이스에 대한 전용 예외를 도입하여, 날짜 및 시간 연산에서 보다 세분화되고 구체적인 오류 처리를 제공합니다. 이 향상된 기능은 다양한 오류 시나리오에 대해 더 정확한 예외 유형을 제공하여, 날짜 및 시간 관련 코드의 견고성과 신뢰성을 향상시키고자 합니다. 몇 가지 예제와 함께 이 기능을 살펴봅시다:\n\n```js\ntry {\n    // 범위 오류가 발생하는 날짜 연산\n    // ...\n} catch (DateRangeError $e) {\n    // 특정 DateRangeError 예외 처리\n    // 에러 로깅, 사용자에게 통보 또는 적절한 조치 취하기\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예제에서는 범위 오류가 발생한 날짜 연산을 처리하기 위해 특정 DateRangeError 예외가 잡힙니다. 이를 통해 날짜 범위 오류에 특화된 오류 처리가 가능해지며, 특정 예외 유형을 기반으로 적절한 조치를 취할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n날짜 형식이 잘못된 간격 문자열 예외에 대해서도 처리할 수 있어요.\n\n```js\ntry {\n    // 날짜 간격 파싱 작업\n    // ...\n} catch (DateMalformedIntervalStringException $e) {\n    // 특정 DateMalformedIntervalStringException 처리\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 이동\n    // ...\n}\n```\n\n이 예에서는 DateMalformedIntervalStringException을 사용하여 날짜 간격 문자열이 잘못된 경우 처리합니다. 이 특정 예외 유형을 사용하면 개발자가 날짜 간격 문자열이 잘못된 시나리오에 맞게 맞춤형 오류 처리를 구현할 수 있어요.\n\nPHP 8.3의 \"더 적절한 날짜/시간 예외\" 기능은 날짜 및 시간 관련 오류 처리에 대해 더 정확하고 체계적인 접근 방식을 제공해요. 특정 날짜 및 시간 예외를위한 전용 예외를 도입함으로써 이 개선 사항은 더 나은 오류 관리를 촉진하고 날짜 및 시간 관련 예외의 보다 효율적인 처리를 돕습니다. 이는 PHP 애플리케이션에서 날짜 및 시간 작업의 전체 신뢰성과 견고성에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8. unserialize() 오류 처리 기능 개선\n\n이 기능은 unserialize() 함수의 오류 처리 메커니즘을 향상시켜, 데이터의 역직렬화 중 문제가 발생했을 때 더 일관되고 예측 가능한 동작을 제공합니다. 이 개선은 오류 보고를 간소화하고 unserialize() 오류를 보다 효과적으로 처리하여 더 나은 오류 관리와 디버깅 기능을 제공하고 있습니다. 이 기능을 몇 가지 예제와 함께 살펴보겠습니다:\n\n```js\n$data = '...'; // 직렬화된 데이터\n$result = unserialize($data);\nif ($result === false) {\n    $error = error_get_last();\n    if ($error \u0026\u0026 $error['type'] === E_WARNING) {\n        // unserialize() 오류를 E_WARNING으로 처리\n        // 오류 기록, 사용자에게 알림 또는 적절한 조치를 취합니다\n        // ...\n    } else {\n        // 일반적인 오류 처리로 이동\n        // ...\n    }\n}\n```\n\n이 예제에서는 데이터의 역직렬화를 시도한 후 결과가 false인지 확인하여 오류를 나타내는지 여부를 확인합니다. 그런 다음 error_get_last()를 사용하여 마지막 오류를 가져와 오류 유형을 확인합니다. 오류 유형이 E_WARNING인 경우, unserialize() 오류를 경고로 처리하여 unserialize() 문제에 대한 특정 오류 처리를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n심지어 unserialize 메서드에서 예외 처리를 사용할 수도 있습니다.\n\n```js\n$data = '...'; // 직렬화된 데이터\ntry {\n    $result = unserialize($data);\n    // 직렬화 해제된 데이터 처리\n    // ...\n} catch (UnserializeException $e) {\n    // 특정 UnserializeException 처리\n    // 오류 기록, 사용자에게 알림 또는 적절한 조치 취함\n    // ...\n} catch (Exception $e) {\n    // 일반적인 예외 처리로 대체\n    // ...\n}\n```\n\n이 예제에서 코드는 직렬화 해제 프로세스를 처리하기 위해 try-catch 블록을 활용합니다. UnserializeException이 발생하면 unserialize() 예외에 대한 특정 오류 처리가 가능하며, 개발자들이 unserialize() 문제에 대한 대상적인 오류 관리를 구현할 수 있도록 합니다.\n\nPHP 8.3의 \"Improved unserialize() error handling\" 기능은 unserialize() 함수에 대한 더 일관적이고 구조화된 오류 처리를 도입하여, unserialize 데이터의 처리 중 오류 보고 및 관리에 대한 향상된 제어를 제공합니다. 더 예측 가능한 오류 처리 메커니즘을 제공함으로써, 이 개선 사항은 PHP 애플리케이션에서 직렬화된 데이터를 다룰 때 디버깅 능력과 전반적인 오류 내구성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. 특성과 정적 속성\n\n이 기능은 정적 속성을 사용하는 관련된 특성의 동작 변경을 소개합니다. 이 향상은 특성을 사용할 때 부모 클래스에서 상속받은 정적 속성의 재선언을 다루며, 각 클래스가 특성을 포함할 때 정적 속성에 대한 별도의 저장소를 유지하도록 보장합니다. 이 동작은 이제 특성 내에서 정적 속성을 직접 클래스에 추가하는 것과 유사해졌으며, 특성 내에서 정적 속성을 보다 예측 가능하고 일관된 방식으로 다루도록 장려합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\ntrait Loggable {\n    protected static $log = [];\n\n    public static function addToLog($message) {\n        self::$log[] = $message;\n    }\n\n    public static function getLog() {\n        return self::$log;\n    }\n}\n\nclass User {\n    use Loggable;\n}\n\nclass Product {\n    use Loggable;\n}\n\nUser::addToLog('사용자가 로그인했습니다');\nProduct::addToLog('새 제품이 추가되었습니다');\n\nvar_dump(User::getLog());\nvar_dump(Product::getLog());\n```\n\n이 예제에서 Loggable 특성은 $log라는 정적 속성과 로그에 메시지를 추가하고 로그를 검색하는 메서드를 포함합니다. User 및 Product 클래스는 Loggable 특성을 사용하여 로깅 기능을 통합합니다. 각 클래스는 정적 속성 $log을 위한 별도의 저장소를 유지함으로써 User 및 Product 클래스 간에 로그 데이터가 격리되고 구분되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 바꿀 수도 있어요.\n\n```js\ntrait Counter {\n    protected static int $count = 0;\n\n    public static function increment() {\n        self::$count++;\n    }\n\n    public static function getCount() {\n        return self::$count;\n    }\n}\n\nclass Order {\n    use Counter;\n}\n\nclass Invoice {\n    use Counter;\n}\n\nOrder::increment();\nInvoice::increment();\nOrder::increment();\n\nvar_dump(Order::getCount()); // Output: int(2)\nvar_dump(Invoice::getCount()); // Output: int(1)\n```\n\n이 예시에서, Counter 트레이트는 정적 속성 $count를 초기화하고 카운트를 증가시키고 카운트 값을 검색하는 메서드를 제공합니다. Order와 Invoice 클래스는 카운트를 별도로 추적하기 위해 Counter 트레이트를 사용합니다. 각 클래스는 자체 카운트를 유지하며, 트레이트 내 정적 속성의 별도 저장을 보여 주어 다른 클래스의 정적 속성과는 별개로 작동하는 것을 보여줍니다.\n\nPHP 8.3의 \"Traits and static properties\" 기능은 여러 클래스에서 사용될 때 정적 속성을 일관되고 예측 가능하게 구현함으로써 trait를 사용한 코드 구조에서 정적 속성을 처리하는 강력하고 직관적인 메커니즘을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 10. 스택 오버플로 감지\n\n이 기능은 스택 오버플로 상황을 감지하고 방지하기 위해 zend.max_allowed_stack_size와 zend.reserved_stack_size라는 두 가지 새로운 ini 지시문을 소개합니다. 이 향상된 기능은 스택 오버플로 상황을 감지하고 처리함으로써 PHP 애플리케이션의 신뢰성과 안정성을 향상시키고 세그멘테이션 오류의 가능성을 줄이며 디버깅을 쉽게 만드는 것을 목표로 합니다. 몇 가지 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// php.ini\nzend.max_allowed_stack_size = 128K\n```\n\n이 예시에서는 php.ini 구성 파일에서 zend.max_allowed_stack_size 지시문이 128 킬로바이트로 설정되어 있습니다. 이 지시문은 PHP 프로그램의 최대 허용 스택 크기를 지정하는데, 개발자가 호출 스택 크기의 상한선을 정의할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// php.ini\nzend.reserved_stack_size = 16K\n\n// PHP 코드\nfunction recursiveFunction($n) {\n    if ($n \u003c= 0) {\n        return;\n    }\n    recursiveFunction($n - 1);\n}\n\nrecursiveFunction(100000); // 큰 수로 재귀 호출\n\n```\n\n이 예제에서는 php.ini 구성 파일에서 zend.reserved_stack_size 지시문이 16 킬로바이트로 설정되어 있습니다. PHP 코드는 재귀 호출을 많이 수행하는 재귀 함수를 포함하고 있으며, 재귀 호출이 많아져 스택 오버플로 상황이 발생할 수 있습니다. zend.reserved_stack_size 지시문을 사용하면 PHP가 호출 스택이 오버플로우 직전에 있는지 감지하여 상황을 처리하고 오류를 throw하여 세그멘테이션 오류를 방지하며 디버깅을 용이하게 합니다.\n\nPHP 8.3의 \"스택 오버플로우 감지\" 기능은 개발자가 호출 스택 크기에 제한을 설정하고 잠재적인 스택 오버플로우 상황을 감지하는 수단을 제공하여 PHP 응용 프로그램의 안정성과 견고성을 향상시킵니다. 이 ini 지시문을 통해 PHP는 스택 오버플로우 상황에 대한 개선된 오류 처리를 제공하며 세그멘테이션 오류의 발생 가능성을 줄이고 더욱 효과적인 디버깅 과정을 용이하게 합니다.\n\n# 11. 불변 상수 가시성\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 invariant 키워드를 사용하여 클래스 상수를 선언하는 기능을 소개합니다. 이를 통해 클래스의 상수의 가시성이 하위 클래스에서 확장되더라도 불변으로 유지될 수 있습니다. 이 향상된 기능은 클래스 상수를 정의하는 더 명시적이고 제어된 방법을 제공하며, 상속 계층 구조에서 상수의 가시성을 유지할 수 있습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass ParentClass {\n    public invariant int MAX_VALUE = 100;\n}\n\nclass ChildClass extends ParentClass {\n    // MAX_VALUE의 가시성을 변경하려고 시도하면 컴파일 오류가 발생합니다\n    protected invariant int MAX_VALUE = 200;\n}\n```\n\n이 예에서 ParentClass는 public invariant 상수인 MAX_VALUE를 값 100으로 선언합니다. ChildClass는 MAX_VALUE의 가시성을 protected로 변경하려고 시도하면 컴파일 오류가 발생하여 상속 계층 구조 전체에서 상수의 불변 가시성이 강제됩니다.\n\n인터페이스에서도 invariant 상수를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n인터페이스 Constants {\n    공개 불변의 문자열 VERSION = '1.0';\n}\n\n클래스 ImplementationClass는 Constants를 구현합니다 {\n    // VERSION의 가시성은 구현 클래스에서도 공개로 유지되어야 합니다\n    개인 불변의 문자열 VERSION = '2.0';\n}\n```\n\n이 예에서 Constants 인터페이스는 값이 ‘1.0’인 공개 불변 상수 VERSION을 선언합니다. ImplementationClass가 VERSION의 가시성을 개인으로 변경하려고 하면 컴파일 오류가 발생하여 상수의 가시성이 인터페이스에서 지정한 대로 불변으로 유지되도록 합니다.\n\nPHP 8.3의 “불변 상수 가시성” 기능은 클래스 상수를 정의하는 더 견고하고 명시적인 방법을 제공하여 상수의 가시성이 상속 계층 구조나 인터페이스 구현에서 일관되게 유지되도록 보장합니다. 이 개선은 코드의 유지 보수성을 높이고 상수의 가시성에 의도하지 않은 변경이 발생할 가능성을 줄여 PHP 코드베이스의 전체 신뢰성과 예측 가능성을 향상시킵니다.\n\n# 12. Assert String Eval Cleanup\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 문자열 평가 코드 어설션의 폐기를 포함하며, 더 안전하고 유지보수가 용이한 코딩 관행을 장려합니다. 이 개선은 문자열 평가 코드를 통한 어설션 사용을 억제하여 보안 취약점 및 코드 유지 관리 도전에 대응합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\nassert('is_numeric($value)');\n```\n\n이 예에서는 assert 함수가 $value가 숫자인지 확인하기 위해 문자열 평가 코드 어설션과 함께 사용됩니다. 그러나 이 방식은 보안 위험에 노출되어 있으며 PHP 8.3에서는 폐기됩니다.\n\n여기서는 직접 표현식을 사용한 어설션의 업데이트된 버전을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nassert(is_numeric($value));\n```\n\nPHP 8.3에서는 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하는 것이 권장됩니다. 단언문 내에서 is_numeric 함수를 직접 호출함으로써 코드를 더 안전하고 유지보수하기 쉽게 만들 수 있습니다.\n\nPHP 8.3의 \"Assert String Eval Cleanup\" 기능은 개발자들이 단언문에 문자열 평가 코드 대신 직접 표현식을 사용하도록 전환하도록 권장하며, 더 안전하고 신뢰할 수 있는 코딩 관행을 촉진합니다. 이 접근 방식을 deprecated 처리함으로써 PHP는 코드 보안과 유지보수성을 향상시키고, PHP 애플리케이션의 전체적인 견고성에 기여하고 있습니다.\n\n# 13. 향상된 FFI\\CData:void\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 FFI (외부 함수 인터페이스) 확장 기능을 향상시켜 C 함수가 void 반환 유형을 가질 때 PHP에서 FFI\\CData`void` 인스턴스를 반환하는 대신 null로 표시할 수 있도록 합니다. 이 개선을 통해 값을 반환하지 않는 C 함수를 처리하기가 더 간편해지며, PHP에서 예상하는 null 반환 유형과 일치시킵니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// C 코드\nvoid myFunction() {\n    // 함수 구현\n}\n\n// PHP FFI\n$ffi = FFI::cdef(\"\n    void myFunction();\n\", \"mylib.so\");\n\n$ffi-\u003emyFunction(); // C 함수 호출\n```\n\n이 예제에서 C 함수 myFunction은 void 반환 유형을 가지고 있습니다. PHP 8.3에서 FFI를 사용하여이 함수를 호출할 때 반환 값은 FFI\\CData`void` 인스턴스가 아닌 null이 됩니다. void를 반환하는 C 함수를 처리하기가 간단해집니다.\n\n다음과 같이 반환 유형을 확인할 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$result = $ffi-\u003emyFunction();\n\nif ($result === null) {\n    echo \"함수가 성공적으로 실행되고 null을 반환했습니다.\";\n} else {\n    echo \"예기치 않은 반환 값입니다.\";\n}\n```\n\n이 예제에서는 C 함수 myFunction의 반환 값을 확인합니다. 반환 값이 null이면 함수가 성공적으로 실행되고 값을 반환하지 않았음을 나타내며, void를 반환하는 함수에 대한 예상 동작과 일치합니다.\n\nPHP 8.3의 \"Improved FFI\\CData:void\" 기능은 PHP에서 void를 반환하는 C 함수를 간소화하여 FFI를 통한 이러한 함수와의 상호 작용을 단순화합니다. PHP에서 이러한 함수를 null로 표현할 수 있도록 함으로써, 이 향상은 값을 반환하지 않는 C 함수를 다룰 때 더 직관적이고 일관된 FFI 경험에 기여합니다.\n\n# 14. posix_getrlimit() 매개변수 향상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능은 posix_getrlimit() 함수에 개선 사항을 소개합니다. 선택적 매개변수를 전달하여 단일 리소스 제한을 가져올 수 있도록 허용합니다. 이 향상된 기능은 특정 리소스에 대한 자원 제한을 검색할 때 더 큰 유연성과 정밀도를 제공함으로써 PHP 애플리케이션 내에서 자원 한도에 대한 자세한 정보를 획득하는 프로세스를 간소화합니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n// 최대 열린 파일 수에 대한 소프트 제한 가져오기\n$softLimit = posix_getrlimit(posix_RLIMIT_NOFILE, POSIX_RLIMIT_SOFT);\necho \"최대 열린 파일 수에 대한 소프트 제한: \" . $softLimit . \"\\n\";\n```\n\n이 예제에서 posix_getrlimit() 함수는 최대 열린 파일 수에 대한 소프트 제한을 가져오는 데 사용됩니다. 선택적 매개변수 POSIX_RLIMIT_SOFT를 사용하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용에 대한 자세한 정보를 제공합니다.\n\n심지어 CPU 시간에 대한 하드 제한도 가져올 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// CPU 시간의 하드 제한을 가져오는 중\n$hardLimit = posix_getrlimit(posix_RLIMIT_CPU, POSIX_RLIMIT_HARD);\necho \"CPU 시간의 하드 제한: \" . $hardLimit . \"\\n\";\n```\n\n이 예제에서는 posix_getrlimit() 함수를 사용하여 CPU 시간의 하드 제한을 얻는 방법을 보여줍니다. 선택적 매개변수로 POSIX_RLIMIT_HARD를 지정하여 함수는 특정 리소스 제한을 검색하고 반환하여 리소스 사용 세부 정보에 정확하게 액세스할 수 있도록 합니다.\n\nPHP 8.3의 \"posix_getrlimit() 매개변수 개선\"은 개발자가 개별 리소스 제한을 쉽게 가져올 수 있는 능력을 부여합니다. 개별 리소스 제한을 가져오는 접근 방식을 제공하여 리소스 사용 정보를 더 세부적으로 확인할 수 있도록 합니다. 이 개선은 리소스 제한과 관련된 더 세밀하고 유연한 작업을 향상시키며, PHP 애플리케이션 내에서 유효한 리소스 관리에 필수적인 세부 리소스 제한 정보를 제공합니다.\n\n# 15. gc_status() 개선내용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngc_status() 함수가 개선되어 PHP 애플리케이션 내에서 메모리 관리 및 가비지 수집에 대한 상세 정보를 제공하는 총 여덟 가지 새로운 필드가 도입되었습니다. 이러한 필드는 실제 가비지 수집이 실행 중인지, 메모리 블록이 가비지 수집으로부터 보호되는지, 가득찬 가비지 수집 주기가 진행 중인지 등 다양한 측면에 대한 세부 정보를 제공합니다.\n새로운 필드 목록은 다음과 같습니다:\n\n- \"running\" =` bool: 현재 가비지 수집이 실행 중인지를 나타냅니다.\n- \"protected\" =` bool: 메모리 블록이 가비지 수집으로부터 보호되는지를 나타냅니다.\n- \"full\" =` bool: 완전한 가비지 수집 주기가 진행 중인지를 나타냅니다.\n- \"buffer_size\" =` int: 가비지 수집을 위한 버퍼 크기를 바이트 단위로 지정합니다.\n- \"application_time\" =` float: 가비지 수집 주기를 포함한 총 응용 프로그램 실행 시간을 나타냅니다.\n- \"collector_time\" =` float: 소멸자의 실행 및 값의 해제를 포함하여 수집 주기에 소요된 시간을 반영합니다.\n- \"destructor_time\" =` float: 수집 주기 동안 소멸자를 실행하는 데 사용된 시간을 나타냅니다.\n- \"free_time\" =` float: 수집 주기 동안 값들을 해제하는 데 사용된 시간을 나타냅니다.\n\n이러한 필드에 접근하여 개발자들은 가비지 수집 상태, 메모리 보호, 수집 주기 시간, 리소스 활용 등에 대한 가치 있는 통찰을 얻을 수 있습니다. 이러한 상세 정보는 개발자들이 메모리에 관련된 결정을 내릴 때 인포메이션을 바탕으로 신중한 판단을 할 수 있도록 돕습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 16. 내부 클래스에 대한 class_alias() 지원\n\n이 기능은 class_alias() 함수의 기능을 확장하여 내부 PHP 클래스에 대한 별칭을 생성할 수 있도록 지원합니다. 이 향상된 기능은 내부 클래스를 다룰 때 더 많은 유연성과 편의성을 제공하여, 기존 내부 클래스에 대한 대체 이름을 생성할 수 있게 해줍니다. 이를 통해 클래스 참조를 간단히 하고 코드 가독성을 높일 수 있습니다. 아래 예시를 통해 이 기능을 살펴보겠습니다:\n\n```js\nclass_alias('DateTime', 'MyDateTime');\n```\n\n이 예시에서는 class_alias() 함수를 사용하여 내부 PHP 클래스 DateTime에 대한 별칭 MyDateTime을 생성합니다. 이를 통해 개발자는 코드베이스 전반에서 MyDateTime이라는 별칭을 사용하여 DateTime 클래스에 참조할 수 있게 되며, 해당 클래스에 대해 더 명확하고 맥락적인 이름을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내부 클래스 초기화를 위해 클래스 별칭을 사용할 수도 있어요.\n\n```js\n$date = new MyDateTime('2023-11-24');\necho $date-\u003eformat('Y-m-d');\n```\n\n이 예제에서 MyDateTime 별칭은 내부 클래스 DateTime의 객체를 생성하는 데 사용되었어요. 이 별칭은 클래스 인스턴스 생성에 더 직관적이고 의미 있는 이름을 제공하여 코드의 가독성과 유지 보수성을 높여줍니다.\n\nPHP 8.3의 \"내부 클래스에 대한 class_alias() 지원\" 기능은 내부 클래스에 별칭을 만드는 프로세스를 간소화하여 개발자들에게 내부 클래스에 대한 대체 이름을 정의할 수 있는 편리한 메커니즘을 제공합니다. 이 개선으로 PHP 애플리케이션 내에서 보다 명확하고 읽기 쉬운 클래스 참조를 제공하여 더 표현적이고 일관성 있는 코드베이스로의 기여가 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 17. mysqli_poll() 오류 처리\n\n이 기능은 오류 처리와 관련된 동작 변경을 소개합니다. 특히, mysqli_poll() 함수를 호출할 때 읽기 및 오류 인수를 제공하지 않으면 이제 ValueError가 발생합니다. 이 향상은 mysqli_poll() 함수가 적절한 인수를 사용하여 사용되며, 비동기적 MySQL 쿼리 실행과 관련된 시나리오에서 더 견고하고 예측 가능한 오류 처리를 촉진합니다. 이 동작을 설명하기 위해 예제를 살펴봅시다:\n\n```js\n$links = [...]; // MySQL 링크 배열\n$read = $error = $reject = [];\nif (mysqli_poll($links, $read, $error, $reject, $timeout)) {\n    // 결과 처리\n    foreach ($read as $link) {\n        // 성공한 쿼리 실행 처리\n    }\n    foreach ($error as $link) {\n        // 쿼리 실행 오류 처리\n    }\n    foreach ($reject as $link) {\n        // 거부된 연결 처리\n    }\n} else {\n    // 폴링 오류 처리\n}\n```\n\n이 예제에서 mysqli_poll() 함수는 $read, $error, $reject 배열을 포함한 올바른 인수와 함께 호출됩니다. 이 사용법은 PHP 8.3의 업데이트된 동작을 준수하며, 폴링 작업 결과를 처리하기 위해 필요한 인수로 함수가 호출되도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nread나 error 인자가 전달되지 않을 때 ValueError를 발생시키는 PHP 8.3은 더 명시적이고 신뢰할 수 있는 오류 처리 방법을 장려하며, mysqli_poll() 호출에 필요한 모든 인자를 제공하도록 개발자들을 격려합니다. 이 개선으로 PHP 애플리케이션에서 비동기 MySQL 쿼리 실행의 전체적인 견고성과 예측 가능성이 향상됩니다.\n\n## array_pad() 기능 향상\n\n이 기능은 array_pad() 함수를 사용하여 한 번에 추가할 수 있는 요소 수에 대한 이전 제한을 제거합니다. 이 개선 이전에 배열을 패딩할 때 한 번에 최대 1048576개의 요소만 추가할 수 있었습니다.\n\n그러나 PHP 8.3에서 소개된 개선으로, array_pad() 함수는 이제 배열이 가질 수 있는 최대 요소 수만 제한으로 나타냅니다. 이를 통해 개발자들은 더 큰 유연성을 가지고 이전의 배열 패딩 작업을 통해 추가할 수 있는 요소 수에 대한 제약을 제거할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 향상은 배열을 훨씬 많은 요소로 채우는 것을 가능하게 하며, 기존 제한으로 인해 배열 크기가 제한되지 않고 다양한 크기의 배열을 다룰 수 있도록 합니다. 결과적으로, 개발자는 array_pad() 함수를 보다 효과적으로 활용하여 배열 조작과 동적 크기 조정이 필요한 시나리오에서 유연성과 확장성을 향상시키는데 기여하며, PHP 애플리케이션 내에서 배열 패딩 작업의 유연성과 확장성을 향상시킵니다.\n\n# 19. opcache.consistency_checks ini 지시문 제거\n\n이 기능은 이전에 OPCache에서 일관성 검사를 활성화 또는 비활성화하는 데 사용되었던 opcache.consistency_checks ini 지시문의 제거를 나타냅니다. 이러한 제거로 인해 opcache.consistency_checks 지시문을 관리할 필요가 없어지며, OPCache 설정 및 유지 관리 프로세스를 간소화하여 OPCache 구성을 단순화합니다. 이 변경이 OPCache 구성에 미치는 영향에 대한 예시는 다음과 같습니다:\n\n이전 OPCache 설정과 opcache.consistency_checks.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopcache.consistency_checks=1\n```\n\n이 예제에서는 opcache.consistency_checks 지시문을 1로 설정하여 OPCache의 일관성 검사를 활성화합니다.\n\nPHP 8.3에서 opcache.consistency_checks 지시문이 삭제되면 OPCache의 일관성 검사 구성이 더 이상 필요하지 않아져 OPCache 구성 프로세스가 간소화됩니다.\n\n이 변경은 OPCache 구성에 대한 단순화된 접근 방식을 반영하며, OPCache의 일관성 검사를 관리하는 복잡성을 줄이고 PHP 8.3에서 OPCache의 전체 효율성과 사용 편의성을 향상시키는 목표와 일치합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 20. number_format()을 사용하여 소수점 처리하는 방법\n\n이 함수는 $decimal 매개변수를 올바르게 처리하도록 개선되었습니다. 이제 $decimal에 음수 정수가 올바르게 처리됩니다. $decimal에 음수 값을 사용하여 반올림하면 $num이 소수점 이전의 지정된 유효 숫자 자릿수로 반올림됩니다. 이전에는 음수 $decimal이 무시되고 숫자가 소수점 이하 자릿수가 0으로 반올림되었습니다. 몇 가지 예제를 통해 이 기능을 살펴보겠습니다:\n\n```js\n$num = 1234.56789;\n$formatted1 = number_format($num, 2); // 1,234.57\n$formatted2 = number_format($num, -2); // 1,200\n```\n\n이 예제에서 number_format() 함수는 음수 $decimal 값을 올바르게 처리하여 숫자를 지정된 유효 숫자 자릿수로 소수점 이전에 반올림합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 업그레이드는 number_format() 함수를 사용하여 숫자를 반올림할 때 더 일관성 있고 예측 가능한 동작을 보장하여 개발자들이 숫자 값의 형식을 더 잘 제어할 수 있도록 합니다.\n\n축하합니다! PHP 8.3에서 소개된 상위 20가지 기능과 개선 사항에 대해 학습을 완료했습니다. 이 최신 릴리스는 계속 변화하는 개발자들과 기업들의 요구에 부합하는 다양한 개선 사항을 제공하여 더 효율적이고 신뢰할 수 있으며 유지보수가 쉬운 코드를 작성할 수 있도록 지원합니다.","ogImage":{"url":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png"},"coverImage":"/assets/img/2024-05-18-Top20PHP83ExcitingFeaturesYouCantAffordtoMiss_0.png","tag":["Tech"],"readingTime":23},{"title":"Ecotone과 RabbitMQ를 활용한 PHP 애플리케이션 통합","description":"","date":"2024-05-18 22:28","slug":"2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png\" /\u003e\n\nPHP 애플리케이션(서비스) 간의 통합은 정말 어려울 수 있습니다. 많은 것들이 망가지고 실패할 수 있는 영역으로 진입하게 됩니다. 종종 서로 다른 팀이 소유한 서로 다른 애플리케이션이라는 점이 해결을 더 어렵게 만드는데요. 이러한 통합을 만들기 위해서는 의사소통 방식에 동의해야 하며, 양쪽이 서로 이해할 수 있도록 해야 합니다.\n\n가장 흔한 두 가지 통합 방법은 \"HTTP\" 또는 \"Message Broker\"입니다. HTTP 통합 시 고려해야 할 잠재적인 문제가 있지만, 이에 대한 논의는 이 글의 범위를 벗어납니다. 이 글에서는 Message Broker를 사용한 통합에 중점을 두고 있고, 보다 구체적으로는 RabbitMQ에 초점을 맞출 것입니다.\n\nMessage Broker를 사용한 통합은 메시징 및 경로 지정 패턴에 대한 다양한 지식이 필요하며 쉽게 복잡해질 수 있습니다. 그로 인해 종종 서비스 간의 통합이 복잡한 작업이 되어 논의가 많아지고 실패한 시도와 변경사항이 여러 번 일어나며 종종 몇 일 간이나 더 나쁜 경우에는 몇 주에 걸칠 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제의 해결책은 더 높은 수준의 추상화에서 작업하는 데에 있습니다. 우리가 메시지 브로커에서 저수준 라우팅 패턴을 직접 처리할 필요가 없도록 충분히 높은 수준의 추상화를 사용합니다. 목표는 진입 장벽을 낮추고 통합을 쉽게 이해하고 수행할 수 있도록 하는 것입니다. 따라서 통합은 몇 시간이나 몇 분 안에 완료될 수 있습니다. 이 글의 목표는 당신에게 PHP 및 RabbitMQ를 사용하여 Ecotone을 활용하는 방법과 도구를 제공하는 것입니다.\n\n그러나 Ecotone의 솔루션이 어디서 나왔는지 이해하려면 먼저 시스템의 논리적 부분과 물리적 부분 사이의 근본적인 차이를 이해해야 합니다.\n\n# 시스템의 논리적 부분과 물리적 부분\n\n우리가 서비스를 통합할 때, 우리는 시스템의 논리적 부분 또는 물리적 부분에 초점을 둘 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 논리 부분은 비즈니스 측면입니다. 여기에서는 \"결제 서비스에서 결제가 처리되면 배송 서비스가 주문을 전달할 것\"과 같은 비즈니스 개념을 사용하여 논의합니다.\n- 물리 부분은 기술적 세부 정보에 관한 것입니다. 여기에서는 \"소프트웨어.public.payment.order’라는 주제 기반 교환을 생성하고 'payment.ordered' 라우팅 키를 사용하여 메시지를 발행해 'order_shipping' 큐가 이에 바인딩할 수 있도록 해야 한다\"와 같은 메시지 브로커 특정 개념을 사용하여 논의합니다.\n\n우리가 작업하는 추상화 수준이 낮을수록, 논리적인 부분이 아닌 물리적인 부분에 더 많은 초점을 둘 것입니다. 이는 우리가 일을 하는데 더 많은 시간을 코드와 구성 작성, 유지 관리 및 이해에 투자할 것을 의미합니다. 이로 인해 왜 특정 작업을 수행하는지 추적하기 어려워질 수 있으며, 우리의 초점이 세부 사항에 맞추어지고 높은 수준의 그림이 아닙니다.\n\n# Ecotone의 분산 버스\n\nEcotone의 각 서비스는 \"shipping_service\" 또는 \"payment_service\"라는 지정된 이름으로 배포 메커니즘에 연결됩니다.\n여기서 논리적인 부분이 필요합니다. 실제로 비즈니스 경계(응용 프로그램)에 대한 명명을 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이 이름을 사용하여 Ecotone의 분산 버스를 통해 서비스 간에 통신할 것입니다. 분산 버스는 높은 수준의 추상화를 제공하여 우리가 시스템의 논리적 부분에 집중할 수 있게 해줍니다. 이전에는 메시지 브로커의 저수준 개념에 주의를 기울였던 것과 달리, 분산 버스를 사용하면 더 많은 일을 수행할 수 있습니다.\n\n분산 버스를 사용하면 두 가지 다른 유형의 메시지인 명령(Command)과 이벤트(Event)와 함께 작동하게 됩니다. 이 둘 사이의 차이점은 중요하며, 곧 그 이유를 알게 될 것입니다.\n\n이제 분산 버스를 통해 명령 메시지를 보내는 것으로 시작해 봅시다.\n\n## Ecotone의 분산 메커니즘 활성화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDistributed Bus를 통해 메시지(명령 및 이벤트)를 전송하기 시작하려면 먼저 활성화해야 합니다. Ecotone의 ServiceContext 구성을 사용하여 RabbitMQ를 위해 활성화할 것입니다:\n\n결과적으로 의존성 컨테이너에 DistributedBus가 등록되어 바로 사용할 수 있게 됩니다.\n\nDistributed Bus로부터 메시지를 받으려면 Distributed Consumer를 활성화하고 싶습니다:\n\n이로 인해 새로운 메시지 컨슈머(작업 프로세스)가 등록되어, \"ecotone:run\" 콘솔 명령을 사용하여 실행할 수 있게 됩니다. 메시지 컨슈머의 이름은 이전에 정의한 서비스 이름과 동일할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSymfony:\n\nLaravel:\n\n# 명령어 전송\n\n우리가 \"order_service\"에서 새 주문을 처리한다고 가정해봅시다. 주문을 받은 후에는 결제를 진행하고 싶습니다. 결제를 진행하기 위해 별도의 \"payment_service\" 서비스를 사용할 것입니다.\n특정 서비스에서 작업을 트리거하고 싶을 때는 명령어를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 명령어(Command)에 대한 개념에 익숙하지 않다면, 이 문서에서 더 자세한 내용을 확인할 수 있습니다.\n\n![Command Concept](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_1.png)\n\n이제 한 번 위 다이어그램을 살펴보고 잠시 멈춰서 생각해 봅시다. 이 다이어그램에는 우리가 다음 질문에 대답하는 데 도움이 되는 두 가지 논리적인 지점이 있습니다:\n\n- 어디로 명령을 보내고 싶은가? — 우리는 명령을 결제 서비스로 보냅니다.\n- 거기서 어떤 조치를 취하고 싶은가? — 우리는 결제를 진행하기 원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용은 우리가 어떤 경계로 상호작용하며 어떻게 하는지를 설명하는 중요한 정보입니다.\n\n실제로 Ecotone의 분산 버스를 사용하여 이를 가능하게 합시다:\n\n코드는 위 다이어그램과 같은 질문에 답하므로 더 높은 수준의 관점을 이해하기 위해서는 필요하지 않습니다. 우리는 결제 서비스에 명령을 보내어 결제를 수행하는 것을 쉽게 이해할 수 있습니다.\n분산 버스가 트리거되면 명령 메시지가 \"payment_service\"로 전송됩니다.\n\n# 명령 수신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Payment Service에서 명령을 받을 수 있게 되었으니, 분산 Command Handler를 등록합시다:\n\n여기서 CommandHandler 및 Distributed 속성을 사용하여 다음을 수행합니다:\n\n- 주어진 메서드를 CommandHandler 속성으로 표시함으로써 로컬 CommandBus에 의해 트리거될 수 있도록 합니다.\n- Distributed 속성을 추가함으로써 분산 Command Handler가 DistributedBus에서도 사용 가능하도록 지정합니다.\n\n이제 이 Command Handler는 \"payment.take\" 라우팅 키를 사용하여 분산 통신에 사용할 수 있습니다.\nEcotone을 사용하여 서비스 간 통신을 위해 할 일은 여기까지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 명령어는 어떻게 작동합니까\n\n저희가 RabbitMQ와 직접 통합을 작성하지는 않겠지만, 더 높은 수준의 코드에서 작업 중이므로 사실상 어떻게 작동하는지 알아두는 것이 여러분에게 도움이 될 것입니다.\n\n명령어를 보낼 때, 사실은 서비스 이름을 라우팅 키로 하는 메시지를 보내는 것입니다:\n\n![image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nService가 소비자로서 Ecotone의 분산 메커니즘에 연결되면 자동으로 해당 서비스 이름에 의해 바인딩된 Queue가 생성됩니다:\n\n![Queue Creation](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_3.png)\n\n이것은 결제 서비스로 명령이 전송될 때 이 서비스의 Queue로 전달됨을 의미합니다.\n그런 다음 결제 서비스 Queue에서 메세지가 소비되면 우리의 분산 명령 핸들러를 트리거합니다.\n\n# 이벤트 메세지 발행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 명령에 대해 논의했지만, 두 번째 유형의 메시지인 이벤트 메시지도 있습니다. 이벤트는 특정 서비스에 보내는 대신 게시되며, 관심이 있는 누구나 구독할 수 있습니다. 따라서 이벤트 메시지는 여러 서비스에 전달될 수 있습니다.\n\n이벤트 개념에 익숙하지 않다면 다음 기사에서 자세한 내용을 확인할 수 있습니다.\n\n성공적인 결제의 결과로 주문을 고객에게 전달하려고 합니다. 결제는 \"payment_service\"에서 처리되고 배송은 \"shipping_service\"에서 이루어집니다.\n\n우리가 이벤트 메시지를 게시할 때는 Ecotone의 분산 교환에 라우팅 키를 제공하여 메시지를 보내는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_4.png)\n\n# 이벤트 메시지 구독\n\n분산 이벤트를 구독하는 것은 매우 간단합니다. 라우팅 키 이름과 분산 속성을 EventHandler에 제공합니다.\n\nEcotone은 내부적으로 우리 서비스의 큐를 주어진 라우팅 키로 바인딩합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_5.png\" /\u003e\n\n모든 작업이 명령 및 이벤트를 사용하여 통신하는 데 필요한 것은, Ecotone을 사용하는 것이 매우 직관적이며 시스템의 논리 부분에 집중하려면 이것이어야 하는 방법입니다. Ecotone 분산 모듈을 설치하는 방법은 문서 페이지에서 읽을 수 있습니다.\n\n이제, 분산 통신을 시작할 때 자주 논의되는 몇 가지 다른 시나리오를 살펴볼 수 있습니다.\n\n# 이벤트 비공개 유지\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템은 분산 통신을 명시적으로 처리하지 않는 경우가 많습니다. 이러한 상황에서 외부 서비스는 우리의 이벤트에 단순히 바인딩되어 있으며, 때로는 우리의 통제 없이 연결될 수 있습니다. 이벤트가 노출될지 여부가 결정되지 않은 상태에서 외부 서비스가 이벤트에 바인딩되면 추적하기 힘들어집니다.\n\n이에 따라 외부 서비스에 의해 소비되는 것이 무엇이고 어떻게 되는지 쉽게 잊어버릴 수 있으며, 명시적 서비스 경계가 퇴화될 수 있습니다:\n\n- 우연히 다른 시스템을 손상시킴 — 다른 서비스가 우리의 내부 이벤트에 직접 바인딩될 수 있으면, 그 서비스는 우리의 이벤트를 소비하는 측이 됩니다. 이벤트 구조를 변경하면 외부 서비스가 우연히 손상될 수 있습니다.\n- 현대화의 부재 — 우리의 이벤트는 공용 이벤트가 되었으므로, 우리는 더 이상 완전히 소유권을 가지지 않게 됩니다. 결과적으로 변경할 수 있는 것을 실제로 논의하고 상담해야 합니다. 이는 종종 사람들이 이벤트를 변경하려는 뜻을 내지 않게 만들어, 시간이 너무 많이 소요된다는 이유에서 그렇습니다.\n- 논리적 부분 손실 — 경계를 논의하고 비즈니스 언어를 사용한 서비스 간 통신은 종종 잊혀지거나 이해하기 어려울 수 있습니다. 우리는 비즈니스 개념이 적용되지 않는 저수준 프로그래밍으로 빠지게 되는 것입니다.\n\n반면 분산 버스를 사용하면 사항을 명확하게 처리하고 서비스 경계가 존중됩니다. 우리가 외부로 발행하고 싶은 것과 비공개로 유지하고 싶은 것을 명시적으로 명시합니다. 이러한 방식으로 팀 내 모두에게 경계의 가장자리에 무엇이 존재하고 무엇이 내부에 유지되는지 명확하게 보여줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모든 이벤트 배포하기\n\n기본적으로 모든 시스템은 외부로 모든 이벤트를 발행하는 여러 시스템이 있습니다. 이는 위에서 설명한 문제를 상속받기 때문에 권장되지 않지만, 이미 해당 방식으로 시스템이 작동 중이라면 필요할 수 있습니다.\n\n레거시 시스템에서 Ecotone으로 마이그레이션할 때, 더 큰 변경을 피하기 위해 이 동작을 유지하고 싶을 수 있습니다. 이러한 상황에서는 대부분 이벤트 버스를 사용합니다. 이러한 상황에서는 현재의 이벤트 버스를 Ecotone의 이벤트 버스로 대체하여 내부적으로 이벤트를 발행할 수 있습니다.\n\n그리고 간단히 \"object\"에 구독하여 모든 이벤트를 구독하여 분배할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체 대신에 여기에 구현된 이벤트 집합을 전달하는 인터페이스를 사용할 수도 있습니다. 또는 이벤트 클래스의 합집합으로도 전달할 수 있습니다:\n\n# 비공개 대 공용 이벤트\n\n일반적으로 분산 이벤트(공용)와 단일 서비스 수준에서 처리해야 하는 이벤트(비공개) 사이의 구별을 따르는 것이 좋습니다.\n이렇게 하면 내부적으로만 사용되는 이벤트를 안전하게 변경할 수 있는지 여부를 알 수 있고 변경하기 전에 특별한 주의를 요하는 이벤트를 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이벤트 분배 중에 우리는 더 많은 단계를 거쳐 Public Event에 사용자 정의 구조를 제공할 수 있습니다. 이렇게 하면 내부 이벤트 구조가 외부 서비스와 완전히 분리될 것입니다.\n\n# 분리된 메시지 클래스\n\n어떤 프레임워크에서는 발행 및 수용 측에서 동일한 클래스를 사용해야 합니다. 즉, 이벤트나 명령을 역직렬화하려면 각 참여 서비스에서 동일한 이름과 네임스페이스를 가진 클래스가 필요합니다. 이는 서비스 간에 강력한 결합을 만들어내기 때문에 이 클래스 이름이 변경되면 쉽게 깨질 수 있습니다.\n\nEcotone에서는 메시지가 클래스가 아닌 라우팅을 기반으로 전달됩니다. 역직렬화해야 할 클래스는 메시지 핸들러 실행 전에 메서드의 매개변수를 기반으로 결정됩니다. 따라서 각 서비스에서 클래스 이름이 다르더라도 이를 역직렬화할 수 있습니다. 이는 더 나아 가서, 배열로 역직렬화할 수 있기 때문에 실제로 클래스를 사용할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게시 측면이 분리되는 것처럼 원하는 유형을 사용할 수 있습니다. 예를 들어, 배열:\n\n서비스를 분리하는 방법에 대해 더 알고 싶다면, 해당 내용을 다룬 이전 기사 중 하나를 읽어보세요.\n\n# 한 번에 더 많은 이벤트를 구독\n\n주어진 서비스가 더 많은 이벤트를 구독할 때는 *, 즉 별표를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게하면 \"billing.\" 접두사가 포함된 모든 이벤트에 등록합니다.\n\"billing.order_charged\", \"billing.refund.made\"가 포함됩니다.\n\n# 오류 모드\n\n주어진 메시지 처리에 문제가 발생하는 경우, Ecotone은 오류 처리를 제공합니다. 오류 처리는 서비스 수준 비동기 처리와 정확히 동일하게 작동합니다.\n예외가 발생하는 경우 구성에 따라 처리를 차단하거나 지연된 재시도를 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n딜레이 재시도가 초과되면 메시지를 삭제하거나 Dead Letter Database에 저장할 수 있습니다.\n\n![image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_7.png)\n\n재시도와 Dead Letter에 대해 더 읽고 싶다면 문서 페이지를 확인해주세요.\n\n## 사용자 정의 오류 메커니즘 제공\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러 핸들링 프로세스를 완전히 맡을 수도 있습니다. 사용자 정의 에러 채널을 정의하여:\n\n그런 다음 서비스 활성화기를 사용하여 연결할 수 있습니다.\n\n# 누락된 명령 핸들러\n\n명령 라우팅 키가 실제로 변경되었거나 명령 핸들러가 단순히 삭제되었을 수 있습니다. 이러한 상황에서 메시지가 그냥 버려지거나 무시되는 것을 원치 않으며, 이는 해결해야 할 잠재적인 버그이므로 데이터를 보존해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_8.png\" /\u003e\n\n서비스 이름을 통해 명령이 라우팅되기 때문에 대상 서비스로 메시지가 전달됩니다. 대상 서비스에서 라우팅이 변경되어도 Ecotone은 실패 모드를 시작하며 해당 명령을 Dead Letter에 저장합니다.\n\n# Outbox Pattern을 사용하여 안전하게 이벤트 배포하기\n\n메시지를 RabbitMQ로 보내고 데이터베이스에 변경 사항을 저장하는 동시에 한 번에 변경사항을 저장하면 일관되지 않은 상태에 빠질 수 있습니다. 이는 두 개의 저장소에서 동시에 변경사항을 수행하고 있기 때문에 한쪽이 실패할 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_9.png)\n\nIn the code, it would look like this:\n\nTo solve this, we can use Ecotone's inbuilt feature to send messages over the Database:\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_10.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 에코톤(Event Bus)을 사용하여 이벤트를 내부적으로 발행할 것입니다.\n\n각 Command Handler는 기본적으로 데이터베이스 트랜잭션으로 랩핑되므로 주문(Order)과 메시지(Message)가 함께 커밋됩니다.\n그런 다음 내부 이벤트를 구독하고 분배합니다.\n\n이벤트 핸들러가 데이터베이스에 메시지를 저장하려면 \"orders\"를 데이터베이스 메시지 채널로 정의해야 합니다.\n\n더 많은 내용을 보고 싶다면, 이전 게시물 중 하나를 읽어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 메타데이터 전송\n\n명령 또는 이벤트와 함께 메타데이터를 전송하고 싶을 때가 있습니다. 이는 실행자 ID, 타임스탬프 또는 요청이 발생한 이벤트 HTTP 도메인과 같은 세부 정보일 수 있습니다.\n\n이러한 세부 정보는 주로 메시지 처리 관점에서 중요하지 않을 수 있지만, 나중에 트리거된 감사, 디버깅 또는 사이드 이펙트와 같은 부작용을 위해 중요할 수 있습니다. 이러한 정보를 명령 또는 이벤트에 직접 넣으면 목적이 흐릿해질 수 있고 전달하기 번거로울 수 있습니다.\n\nEcotone은 메타데이터를 주요 역할로 취급하여 명령과 이벤트와 함께 전달되도록 하여 이 문제를 해결합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDistributed Event Handlers로 직접 액세스할 수 있습니다.\n\nMetadata 및 전파는 메시지 기반 시스템에서 중요하며 Ecotone은 여기에 표시된 것보다 더 많은 기능을 지원합니다. 해당 주제를 깊이 있게 탐구하고 싶다면, Laravel의 Multi-Tenant 또는 Symfony의 Multi-Tenant를 읽어보는 것을 추천합니다. 이 주제에 대해 더 자세히 설명되어 있습니다.\n\n# 별도의 대기열 및 처리\n\n지금까지 우리는 단일 메시지 대기열의 맥락에서 분산 메시지 처리에 대해 논의해 왔습니다. 그러나 대규모 시스템에서는 실제로 일부 메시지를 다른 것들과 별도로 또는 더 높은 우선순위로 처리하길 원할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메시지 소비자를 따로 확장하려면 Taken Payments와 Failed Payments에 관련된 것을 분리할 수 있습니다. 그런 다음 이를 서로 다른 메시지 채널(큐)로 분리할 수 있습니다:\n\n![Image](/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_11.png)\n\n서비스 수준의 코드는 다음과 같이 보일 것입니다:\n\n그런 다음 Service Context 구성을 사용하여 \"taken_payments\" 및 \"failed_payments\" 메시지 채널을 정의합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 통해 우리는 결제 요청에 대한 메시지 소비자를 확장할 수 있고 실패한 지불로부터 독립적으로 처리할 수 있으며 분산 큐를 단순한 프록시로 다룰 수 있습니다.\n\n# 개요\n\n우리가 작업하는 코드의 수준이 낮을수록 시스템의 논리적 부분에 높은 희생을 감수해야 할 것입니다. 기술적 세부 사항에 집중할수록 비즈니스 부분에 집중하기 어려워집니다.\n\n반면에 Ecotone은 우리에게 더 높은 수준의 추상화로 작업할 수 있는 도구를 제공하여 더 빠르게 제공하고, 덜 구성이 필요하며 비즈니스에 더 많은 초점을 둘 수 있습니다. 비즈니스 중심적인 접근은 강요되지 않아야 하며, 통합에 덜 시간을 쓰면 자연스럽게 비즈니스 부분에 초점을 맞출 것입니다. 이렇게 하면 사람들이 비즈니스 요구에 부합하는 고품질 소프트웨어를 생산할 수 있는 환경을 조성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 저장소의 분산 통신 예시 구현과 Symfony 및 Laravel로 작성된 완전한 애플리케이션 예시를 분산 버스를 통합하여 찾아 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png"},"coverImage":"/assets/img/2024-05-18-IntegratingPHPApplicationswithEcotoneandRabbitMQ_0.png","tag":["Tech"],"readingTime":12},{"title":"NextJs 14에서 Route Groups이란 무엇인가?","description":"","date":"2024-05-18 22:26","slug":"2024-05-18-WhatareRouteGroupsinNextJs14","content":"\n\n안녕하세요 여러분! Next.js에서는 종종 페이지를 앱 디렉토리 내의 폴더로 구성하죠, 맞죠? 그런데 만약 URL 경로를 지저분하게 하지 않고 관련된 경로를 그룹화하고 싶다면 어떻게 할까요? 바로 Route Groups가 등장합니다!\n\n그러니 함께 살펴봅시다. NextJs의 이 개념에 익숙하실 것입니다. 우리는 각 폴더에 page.tsx 파일을 포함하여 앱 디렉토리 안에 폴더를 만들 수 있습니다. 이를 통해 URL 경로에 폴더 이름을 추가할 수 있게 됩니다. 아래는 이를 설명하는 예시입니다:\n\n![Route Groups in NextJs](/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png)\n\n이것은 앱 폴더 내의 폴더 디렉토리로, 'button'이라는 폴더를 만들고 그 안에 page.tsx 파일을 만들었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/button으로 이동하면 page.tsx에 있는 내용을 볼 수 있습니다.\n\n기본 사항을 잘 이해하셨으니, 여기서 라우트 그룹이 어떻게 작용하는지 알아보겠습니다. 많은 경우, 우리는 만들어 둔 폴더를 표시하고 싶지 않거나 URL을 깔끔하게 유지하면서 관련 폴더를 그룹화해야 할 때가 있습니다. 이때 라우트 그룹이 마법을 부리는 시점입니다! 라우트 그룹을 사용하면 경로에 추가하지 않고 폴더 이름을 생성할 수 있습니다. 유일한 제한 사항은 NextJS가 어떤 이름을 회피해야 하는지 알기 위해서는 폴더 이름을 원형 괄호로 감싸야 한다는 것입니다.\n\n다음은 예시입니다:\n\n![라우트 그룹 예시](/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 처음에 논의한 것에 따르면, 페이지.tsx의 콘텐츠를 표시할 때 URL이 example/button과 같아야 했지만 example이 괄호 안에 있기 때문에 NextJS는 경로에 포함할 필요가 없다는 것을 알고 있어 URL은 /button이 됩니다.\n\n그래서 언제 경로 그룹을 사용해야 할까요?\n1. 간소화된 URL 경로: 관련된 route를 그룹화하여 폴더에 넣고 URL 경로를 그룹 폴더의 이름으로 복잡하지 않게 만들고 싶을 때 사용합니다.\n\n2. 사용자 정의 레이아웃: 특정 폴더에 대해 다른 레이아웃을 사용하고 싶을 때 사용합니다. 한 폴더에 속하는 모든 파일은 레이아웃.tsx를 따르며 이를 통해 각 폴더에 맞게 사용자 정의 레이아웃을 가질 수 있습니다!\n\n경로 그룹에 대해 더 알아보려면, 공식 NextJS 문서를 읽는 것을 추천합니다: [NextJS 문서](https://nextjs.org/docs/app/building-your-application/routing/route-groups)","ogImage":{"url":"/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png"},"coverImage":"/assets/img/2024-05-18-WhatareRouteGroupsinNextJs14_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter와 Firebase로 픽셀 아트 앱 만들기","description":"","date":"2024-05-18 22:24","slug":"2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase","content":"\n\n## 자신만의 r/place 만들기\n\n![이미지](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png)\n\n# 소개\n\n요즘 r/place나 z/place에 대해 들어보셨을 것 같은데, 듣지 못했다면 무슨 얘길 하는 건지 궁금하실 것입니다. 이것들은 협업 프로젝트이자 소셜 실험이며, 사용자들이 한 번에 한 픽셀의 색을 변경하여 캔버스를 편집할 수 있는 프로젝트입니다. 행사가 끝나면 대개 2~3일 후에 아름다운 픽셀 아트 작품이 완성됩니다. 모든 정보는 위키백과에서 찾아볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음, 저의 GitHub 계정에서 전체 프로젝트를 찾을 수 있어요! 이 프로젝트는 클린 아키텍처 패턴을 따르지만 몇 가지 변형이 있어요. 이 글을 위해 완전히 맹목적이 될 필요를 느끼지 않았답니다.\n\n# 받게 되는 것\n\n# 필수 요구 사항\n\n- 픽셀을 그리고 색상을 선택하는 방법.\n- 픽셀을 저장하고 가장 중요한 것은 변경이 발생할 때 사용자에게 알릴 수 있는 실시간 데이터베이스.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 당신처럼 나를 그려주세요...\n\n![image](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_1.png)\n\n먼저, 픽셀을 설명하는 클래스를 생성해봅시다. 별로 복잡한 건 아닙니다. 그저 2D 위치를 설명하는 Offset이 필요한데요, 이것은 그릴 위치와 현재 색상을 알려줍니다. 고급 섹션에서는 추가 정보도 더할 수 있습니다.\n\n픽셀을 그리기 위해서는 캔버스를 제공하는 위젯이 필요합니다. 그것이 CustomPaint가 하는 일이며, 표현하고자 하는 내용과 방법을 지정하기 위해 CustomPainter가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 CustomPaint는 화면 전체를 차지하지만, 모두에게 동일한 그리기 경험을 제공하고 싶으므로 그냥 1920x1080으로 고정하겠습니다. 이는 200만 픽셀 이상이 됩니다. 충분할 거예요! 흥미로운 사실은 사용하지 않는 두 가지 추가 속성이 있답니다. isComplex와 willChange입니다. 열광적으로 개발한다면 캐시 이점을 얻기 위해 true로 설정해보세요.\n\n그런 다음, 우리는 CustomPainter와 그 Paint 설정을 생성해야 합니다.\n\n조금 더 복잡해졌어요. 우리의 painter는 CustomPainter를 확장한다는 점을 보실 수 있죠. 이렇게 함으로써 paint와 shouldRepaint 메서드를 재정의해야 합니다. 그리려는 List`Pixel`을 매개변수로 받아서... 그뿐이에요. repaint 인수는 필요하지 않습니다. 픽셀 목록이 업데이트될 때마다 뷰가 다시 빌드될 거에요. 그런 다음 간단합니다, 픽셀 목록을 반복하고 각각의 해당 좌표에 그려주기만 하면 되죠.\n\n게다가, 픽셀 좌표를 결정하는 방법이 필요해요. 가장 쉬운 방법은 CustomPaint를 Listener 위젯으로 감싸고 onPointerDown 콜백을 구현하는 겁니다. 그렇게 함으로써 localePosition 이벤트 매개변수를 활용하여 커서 위치를 얻을 수 있어요. position을 사용하지 마세요. 그렇게 하면 절대 위치가 아닌 캔버스 내에서의 상대 위치를 얻을 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n드디어 색상을 선택하기 위해 flutter_colorpicker 패키지를 사용하기로 결정했어요. 제가 직접 위젯을 구현할 수도 있었지만, 어차피 이미 만들어진 것을 다시 만들 필요 없잖아요.\n\n별 다른 얘길 할 게 없어요. BlockPicker 위젯은 Scaffold AppBar에 위치해 있고, onColorChanged가 트리거될 때마다 새로운 색상을 저장하여 CustomPainter에 제공하고 있어요. 저는 제가 필요에 맞게 하나를 만들었지만, 기본 레이아웃을 사용하셔도 되요.\n\n# 지속성\n\n![이미지](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스를 빠르게 설정하는 가장 빠른 방법 중 하나는 아마도 Firebase를 사용하는 것입니다. 사용하기 쉽고 잘 문서화되어 있으며 기본적인 용법 대부분에 대해 무료로 제공됩니다. Firebase 콘솔에서 프로젝트를 만들고 Firebase 실시간 데이터베이스를 활성화하고 플러터 프로젝트에서 Firebase 데이터베이스를 구성하면 됩니다. 현재는 권한에 대해 걱정할 필요가 없습니다. 그냥 누구든지 데이터베이스를 읽고 쓸 수 있도록 허용하십시오.\n\n```js\n{\n  \"rules\": {\n    \".read\": true,\n    \".write\": true,\n  }\n}\n```\n\n최악의 경우 캔버스를 잃을 수도 있습니다. 하지만 우리는 그것을 대처할 수 있을 거예요, 분명합니다.\n\n# 네트워크 레이어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠르고... 깔끔하게 진행해 봅시다! BLoC와 FirebasePixelsRepository를 설정하여 각각 프레젠테이션 레이어와 Firebase 데이터베이스와 상호 작용하도록 해보세요.\n\n저장소부터 시작해 봅시다. 소개에서 언급했듯이, 데이터베이스에서 변경 사항이 발생할 때마다 알림을 받아야 합니다. 그래서 우리는 실시간 데이터베이스와... 스트림을 사용합니다. 목표는 데이터 변경 사항을 수신하고 그에 따라 반응하는 것입니다.\n\nPixelsRepository는 간단한 인터페이스입니다. 실용적으로 생각해 봅시다. 우리에겐 두 가지 기능만 필요합니다.\n\n- createPixel은 좌표를 기반으로 한 고유 해시로 참조된 픽셀을 만듭니다. 이를 통해 색상을 변경할 때 쉽게 액세스할 수 있으며 계속해서 새로운 픽셀을 무조건적으로 만드는 것을 방지합니다.\n- listenPixels는 데이터베이스 내의 추가 또는 변경 사항에 구독하고, 스트림에 푸시하여 새로운 픽셀이 생성되거나 업데이트될 때 알립니다. StreamGroup에 대해 자세히 알아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPixelModel은 다음과 같습니다. (역)직렬화 개체를 원활하게 수행하기 위해 두 개의 컨버터를 만들었습니다. 비용이 거의 들지 않습니다. 많이 도와줍니다.\n\n이제, 저장소와 표현 계층 사이에 작은 다리를 만들어 봅시다. 관심사의 분리 원칙... 당신은 이미 알고 계시겠지만요!\n\n무서워하지 마세요! 정말 아무것도 아닙니다. 저희 BLoC는 PixelsEventListen 및 PixelsEventAdd에 대응하여 저장소 메서드를 수신합니다. 또한 customStream과 `Map\u003cint, Pixel\u003e`을 생성하여 이를 스트림을 통해 표현 계층에 제공합니다.\n\n언급할 가치가 있는 두 가지 사항: 먼저, 우리는 listen을 사용하여 스트림을 구독합니다. 두 번째, 우리는 cancelOnError를 사용하지 않습니다. (데이터의) 흐름을 계속 유지합시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBLoC를 뷰에 추가하고 Stream을 StreamBuilder 위젯에 제공하세요. 그런 다음 데이터를 캔버스로 전송하세요. 여러 창에서 실행하고 하나에서 픽셀을 만들면 다른 창에서도 복제되는 것을 볼 수 있어야 합니다.\n\n# Make It Shine\n\n![Build a Collaborative Pixel Art App with Flutter and Firebase](/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 조금 빨리 진행하겠습니다. 실제 r/place 규칙에 더 가까운 몇 가지 추가 기능을 제공하기 위해 노력할 거에요. 너무 제한적이지 않으면서도 사용자가 이를 변경할 수 없게 할 생각이에요.\n\n## 사용자 인증\n\nfirebase_auth 패키지를 추가하고, firebase 콘솔에서 인증 기능을 활성화하고 익명을 로그인 방법으로 허용해주세요. 그런 다음 firebase_auth_repository를 만들어 처리하도록 해봐요. 물론, 이메일, Google 등의 다른 가입 수단을 추가해도 되요.\n\n우리가 매우 기본적인 인증 개념을 가졌기 때문에 보안 규칙을 조금 업그레이드할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"rules\": {\n    \".read\": true,\n    \".write\": \"auth != null\"\n  }\n}\n```\n\n와우! 이제 인증된 사용자만 픽셀 쓰기가 가능합니다. 다음으로 뷰와 상호 작용할 AuthCubit을 생성하고 해당에 버튼을 추가하면 끝입니다!\n\nCubit을 사용하면 BLoC과 달리 사용자 정의 이벤트를 만들 필요가 없습니다. 메소드를 바로 호출하면 됩니다!\n\n## 수정 이력\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n픽셀이 추가되거나 수정될 때마다 모든 변경 사항을 추적할 시간입니다. 우리가 픽셀을 저장하는 데 사용한 것과 동일한 Realtime 데이터베이스를 사용해 봅시다. 이를 위해 단순히 createPixel 메서드를 업데이트하면 됩니다.\n\n완료했습니다. 픽셀을 생성하는 동시에 새로운 고유한 참조를 푸시하고 해당 픽셀 정보를 설정합니다. 유일한 차이점은 모든 변경 사항을 영원히 유지할 것이라는 것입니다. 그것들을 사용하여 재생을 생성하는 데 사용할 수도 있겠죠?\n\n픽셀 생성에 했던 것과 마찬가지로 전용 스트림을 작성해 주세요. 프레젠테이션 레이어에서는 각각이 픽셀 업데이트인 ListTile 목록을 포함하는 ListView에 데이터를 제공하면 됩니다. 구현에 대한 레포지토리를 확인하시고, 쉬우니까요.\n\n## 확대/축소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 조금 어려울 거에요. 지금까지 사용자들은 전체 1920x1080 캔버스를 볼 수 있기 위해 매우 큰 스크린을 갖고 있어야 했어요. 이 문제를 해결하기 위해, 먼저 수직 및 수평 스크롤을 위한 double SingleChildScrollView 위젯을 추가하고 싶을 수 있지만, 이것은 실수일 수 있고 어차피 부드럽게 작동하지 않아요.\n\n캔버스를 InteractiveViewer 위젯 내에 감싸야 해요. constrained 속성을 false로 설정하고 minScale 및 maxScale을 필요에 맞게 조정해야 해요. 이렇게 하면 화면 크기에 상관없이 원하는 곳으로 이동할 수 있을 거예요. 자세한 정보는 문서를 참고해주세요.\n\n레이아웃 제약 조건을 처리하고 위젯을 올바르게 배치하는 방법에 대한 정보는 저장소를 확인해주세요.\n\n## 호스팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정말 간단해요. 공식 문서를 따라하기만 하면 돼요.\n\n먼저 flutter build web --release 명령어를 실행하고, firebase init hosting 명령어를 실행해서 몇 가지 질문에 답하면 호스팅 URL을 얻을 수 있어요. 도메인을 더 세밀하게 설정하려면 Firebase 콘솔의 호스팅 구성을 확인하세요.\n\n```js\n? What do you want to use as your public directory? build/web\n? Configure as a single-page app (rewrite all urls to /index.html)? No\n? Set up automatic builds and deploys with GitHub? No\n✔ Wrote build/web/404.html\n```\n\nbuild/web을 공개 저장소로 설정하는 것이 중요해요. 여기에 소스 파일이 저장돼 있어요. 그런 다음 firebase deploy를 실행하면 웹사이트가 공개돼요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 작성하는 것만큼 읽는 데 즐거움을 느끼셨기를 바랍니다. 이 글은 조밀하게 쓰여 있어 몇 가지 세부 내용을 건너뛴 것 같지만 필요하다면 저장소를 확인해 주세요.\n\n## 더 알고 싶으신가요?","ogImage":{"url":"/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png"},"coverImage":"/assets/img/2024-05-18-BuildaCollaborativePixelArtAppWithFlutterandFirebase_0.png","tag":["Tech"],"readingTime":7},{"title":"패닉에서 준비 상태로 나의 면접 경험","description":"","date":"2024-05-18 22:22","slug":"2024-05-18-FromPanictoPreparedMyInterviewExperience","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png\" /\u003e\n\n안녕하세요 👋 제 독자 여러분, 제목을 보시다시피 몇 분들이 무엇을 쓸 것인지 유추하셨을 거에요. 하지만 기다려주세요, 모든 걸 스스로 가정하지 마시고, 모두가 고유한 경험을 갖고 있기 때문이에요. 그리고 재미있는 사실은, 이 글은 제 인터뷰 경험에 대한 이야기입니다.\n\n이 글의 목적: 많은 분들이 이 글을 쓰는 이유가 궁금할 텐데, 그 이유는 제 인터뷰 의식주에 대한 통찰과 생각을 공유하고자 하는 것입니다.\n\n# 취업 인터뷰의 현실\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에 두 개의 취업 면접을 진행했는데, 자주 인위적으로 느껴지는 질문에 대비하는 데 얼마나 많은 시간을 소비했는지를 깨달았어요. \"자기 소개해주세요\", \"귀하는 약점이 무엇이라고 생각하나요\", \"귀하는 강점이 무엇이라고 생각하나요\", \"이 직무를 원하는 이유\", \"이전 직장에서 다른 직장으로 이동한 이유\" 등의 질문은 면접 과정에서 필수적인 질문들이에요. 저희를 포함한 많은 지원자들은 완벽한 대답을 준비하기 위해 ChatGPT와 같은 자원을 활용해요. 그런데, 왜 우리는 면접관들에게 완벽한 모습으로 보여주어야 하는 필요성을 느끼는 걸까요?\n   \n# 진정성을 받아들이기\n\n사실은, 모든 사람들은 각자의 약점을 갖고 있는데, 그것은 전혀 괜찮은 일이에요. 그럼에도 불구하고, 면접에 관한 관행적인 지혜는 종종 우리가 완벽해야 한다는 생각을 장려해요. 마치 면접이 두 사람 사이의 대화가 아닌 서로가 실제보다 나아보이려고 하는 거짓말쟁이들의 대화인 것 같아요. 이런 가장을 꾸밀 필요 없이 약점을 강점으로 내세우기 위해 허구적인 행동을 하는 것은 가짜 같고, 저의 실제 모습을 정확하게 대변하는 것이 아니에요.\n\n# 면접관들의 불완전함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생각해보세요: 인터뷰를 진행하는 사람도 완벽하지 않다는 사실을요. 그들에게도 약점과 결점이 있습니다. 그렇다면 우리 지원자로서 왜 진정한 모습을 숨겨야 하는지 강요받아야 할까요? 사실 아무도 완벽하지 않다는데, 완벽한 사람으로 자처하는 것이 어색하고 약간 죄책감을 느끼게하는 생각이에요.\n\n# 불완전함의 아름다움\n\n불완전함이 인간의 아름다움이에요. 인터뷰 관계자들이 후보자들을 그들이 진정으로 가진 강점과 약점을 받아들인다면, 인터뷰 프로세스가 더 진솔하고 의미있어질 거예요. 제처럼 자신을 솔직히 밝히기 위해 직장을 확보하기 위해 거짓말하고 싶지 않은 사람들이 많이 있어요. 인터뷰어들이 이를 이해하고 완벽보다는 진실성을 받아들이는 것이 때 되었다고 생각해요.\n\n모두에게 제 경험을 공유하자면, 솔직히 몇몇 인터뷰 질문이 마음에 들지 않아요. 대답에 어려움이 있는 것이 아니라, 제 답변을 진실하게 받아들이기 어려운 인터뷰어들 때문이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 나의 첫 면접: 배운 경험\n\n나는 첫 면접을 준비할 때 정말 무척이나 긴장했어요. 많은 지원자들이 느낄 것 같아요. 부족한 자신감으로 더욱 불안해지고 때때로 심지어 패닉에 빠졌죠. 그럼에도 불구하고 나는 그 상황을 극복하고 면접을 완료했어요. 이 경험으로부터 몇 가지 소중한 교훈을 얻을 수 있었어요.\n\n# 주요 포인트:\n\n## 말 속도를 조절하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 먼저 깨달은 것 중 하나는 일정한 이야기 속도를 유지하는 중요성이었습니다. 때로는 너무 빨리 말하고 때로는 너무 느리게 말했습니다. 균형을 맞추고 보통 속도로 말하는 것이 중요합니다.\n\n**## 주의 깊게 듣기**\n\n질문을 주의 깊게 듣고 단계별로 대답하는 것이 중요합니다. 긴장으로 나에게 키 포인트를 놓치게 만들기도 했습니다. 차분하고 침착해지는 것이 중요합니다.\n\n**## 준비하다**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nThere were topics I hadn’t studied, and this gap in my preparation affected my performance. Next time, I plan to cover all relevant topics thoroughly to ensure I am well-prepared.\n\n# 공동 경험에 대한 호소\n\n내 독자들의 면접 경험에 대해 듣고 싶어해요. 다른 사람들이 비슷한 어려움을 겪은 것을 알면 매우 동기부여가 될 것 같아요. 댓글에서 여러분의 경험을 공유해주세요. 궁금한 점이 있다면 댓글을 남겨주시면 제가 확실히 답변해드릴게요.\n\n# 마무리 당신을 위해\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저쪽에서는 여기까지입니다! 제안이나 피드백이 있으시면 언제든지 연락해주세요. 특정 주제에 대해 글을 작성해 달라면 댓글에 언급해주세요.\n\nLinkedIn에서 연결해요!\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에 박수를 보내주시고 팔로우도 잊지 말아주세요! 👏","ogImage":{"url":"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-18-FromPanictoPreparedMyInterviewExperience_0.png","tag":["Tech"],"readingTime":3}],"page":"65","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"65"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>