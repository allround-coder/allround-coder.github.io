<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/23" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/23" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" href="/post/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" href="/post/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ES8에서 가장 혁신적인 자바스크립트 기능 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ES8에서 가장 혁신적인 자바스크립트 기능 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" href="/post/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React와 TailwindCSS로 반응형 NavBar 만드는 방법" href="/post/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React와 TailwindCSS로 반응형 NavBar 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React와 TailwindCSS로 반응형 NavBar 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">React와 TailwindCSS로 반응형 NavBar 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v17이 해결한 이전에는 해결 불가능했던 문제" href="/post/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v17이 해결한 이전에는 해결 불가능했던 문제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v17이 해결한 이전에는 해결 불가능했던 문제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v17이 해결한 이전에는 해결 불가능했던 문제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법" href="/post/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v18 출시 최신 기능 알아보기" href="/post/2024-06-22-Angularv18isnowavailable"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v18 출시 최신 기능 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Angularv18isnowavailable_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v18 출시 최신 기능 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular v18 출시 최신 기능 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법" href="/post/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로처럼 React 컴포넌트 작성하는 방법" href="/post/2024-06-22-WriteaReactComponentLikeaPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로처럼 React 컴포넌트 작성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로처럼 React 컴포넌트 작성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프로처럼 React 컴포넌트 작성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오늘 React 컴파일러를 사용해 봤는데, 결과가 " href="/post/2024-06-22-ItriedReactCompilertodayandguesswhat"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오늘 React 컴파일러를 사용해 봤는데, 결과가 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오늘 React 컴파일러를 사용해 봤는데, 결과가 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">오늘 React 컴파일러를 사용해 봤는데, 결과가 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link posts_-active__YVJEi" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"이렇게 하면 functional try-catch가 JavaScript 코드를 변형합니다","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode","content":"\n\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png)\n\nHow common is this?\n\n![image](/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_1.png)\n\nIt’s yet another instance where we want a value that depends on whether or not there’s an exception.\n","ogImage":{"url":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png"},"coverImage":"/assets/img/2024-06-22-Thisishowfunctionaltry-catchtransformsyourJavaScriptcode_0.png","tag":["Tech"],"readingTime":1},{"title":"ES8에서 가장 혁신적인 자바스크립트 기능 5가지","description":"","date":"2024-06-22 05:19","slug":"2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8","content":"\n\n\n![ES8](/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png)\n\nES8는 우리가 JavaScript를 작성하는 방식을 변화시키는 귀중한 기능으로 가득 찼습니다.\n\n코드가 더 깔끔해지고 작성하기 쉬워지며 새로운 기능이 추가되었습니다.\n\n지금 그것들을 확인해보고 놓친 것들을 확인해보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 트레일링 쉼표","ogImage":{"url":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png"},"coverImage":"/assets/img/2024-06-22-The5mosttransformativeJavaScriptfeaturesfromES8_0.png","tag":["Tech"],"readingTime":1},{"title":"모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술","description":"","date":"2024-06-22 05:16","slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\" /\u003e\n\n자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\n\n## 1. `var` 대신 `let` 및 `const` 사용하기\n\n문제: `var`은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 블록 스코프를 갖는 `let`과 `const`를 사용하세요.\n\n```js\nlet count = 0;\nconst PI = 3.14;\n```\n\n`let`과 `const`를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\n\n## 2. 기본 매개변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\n\n해결책: 기본 매개변수를 사용하여 대안 값 설정.\n\n```js\nfunction greet(name = '방문자') {\nreturn `안녕하세요, ${name}님!`;\n}\nconsole.log(greet()); // \"안녕하세요, 방문자님!\"\n```\n\n기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 템플릿 리터럴\n\n문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\n\n해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\n\n```js\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, John!\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\n\n## 4. 비구조화 할당\n\n문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\n\n해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane', age: 25 };\nconst { name, age } = user;\nconsole.log(name, age); // \"Jane\" 25\n```\n\n구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\n\n## 5. 화살표 함수\n\n문제: 기존 함수 표현식은 장황할 수 있고 `this`를 렉시컬하게 바인딩하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 `this`를 활용하세요.\n\n```js\nconst add = (a, b) =\u003e a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 `this`가 렉시컬하게 바인딩되어 있는지 보장합니다.\n\n## 6. 전개 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\n\n```js\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = […arr1, …arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n```\n\n전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 나머지 매개변수\n\n문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\n\n해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\n\n```js\nfunction sum(…args) {\nreturn args.reduce((total, num) =\u003e total + num, 0);\n}\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\n\n## 8. 단락 평가\n\n문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\n\n해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst isLoggedIn = true;\nconst user = isLoggedIn \u0026\u0026 { name: 'Jane', age: 25 };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n단축 평가는 논리적 `\u0026\u0026` 및 `||` 연산자를 사용하여 조건식을 간단하게 만듭니다.\n\n## 9. 선택적 체이닝\n\n문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 `null` 또는 `undefined`인 경우 오류를 발생시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\n\n```js\nconst user = { profile: { name: 'Jane' } };\nconst userName = user?.profile?.name;\nconsole.log(userName); // \"Jane\"\n```\n\n선택적 체이닝을 사용하면 `null` 또는 `undefined`인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\n\n## 10. 널리쉬 콜리싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: `||`를 사용하여 기본 값을 제공하는 경우, 값이 `0` 또는 `\"\"`이면 예상치 못한 결과가 발생할 수 있습니다.\n\n해결책: `nullish coalescing` (`??`)을 사용하여 `null` 또는 `undefined`일 때만 기본 값을 제공합니다.\n\n```js\nconst user = { name: '', age: 0 };\nconst userName = user.name ?? '익명';\nconst userAge = user.age ?? 18;\nconsole.log(userName); // \"\"\nconsole.log(userAge); // 0\n```\n\n`Nullish coalescing`은 왼쪽 피연산자가 `null` 또는 `undefined`일 때에만 기본 값을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 11. 객체 속성 축약\n\n문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\n\n해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\n\n```js\nconst name = 'Jane';\nconst age = 25;\nconst user = { name, age };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\n\n## 12. 동적 프로퍼티 이름\n\n문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\n\n해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst propName = '나이';\nconst user = { 이름: '제인', [propName]: 25 };\nconsole.log(user); // { 이름: '제인', 나이: 25 }\n```\n\n계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\n\n## 13. 배열 `map()`, `filter()`, 및 `reduce()`\n\n문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 일반적인 배열 작업에 `map()`, `filter()`, 및 `reduce()`를 사용하세요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num =\u003e num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(num =\u003e num % 2 === 0);\nconsole.log(evens); // [2, 4]\nconst sum = numbers.reduce((total, num) =\u003e total + num, 0);\nconsole.log(sum); // 15\n```\n\n이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\n\n## 14. 문자열 `includes()`, `startsWith()`, 및 `endsWith()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\n\n해결책: 더 간단한 문자열 확인을 위해 `includes()`, `startsWith()`, `endsWith()`를 사용하세요.\n\n```js\nconst str = 'Hello, world!';\nconsole.log(str.includes('world')); // true\nconsole.log(str.startsWith('Hello')); // true\nconsole.log(str.endsWith('!')); // true\n```\n\n이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 15. 함수 매개변수에서 배열 및 객체 비구조화\n\n문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\n\n해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\n\n```js\nconst user = { name: 'Jane', age: 25 };\nfunction greet({ name, age }) {\n    return `안녕, ${name}! 당신은 ${age}살 입니다.`;\n}\nconsole.log(greet(user)); // \"안녕, Jane! 당신은 25살 입니다.\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\n\n## 16. 구조 분해에서 기본값 활용\n\n문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\n\n해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane' };\nconst { name, age = 18 } = user;\nconsole.log(name); // \"Jane\"\nconsole.log(age); // 18\n```\n\n구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\n\n## 17. Object `assign()`\n\n문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `Object.assign()`을 사용하여 객체를 복제하거나 병합할 수 있습니다.\n\n```js\nconst target = { a: 1 };\nconst source = { b: 2 };\nconst merged = Object.assign(target, source);\nconsole.log(merged); // { a: 1, b: 2 }\n```\n\n`Object.assign()`을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\n\n## 18. Array `find()` 및 `findIndex()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\n\n해결책: 더 가독성있는 코드를 위해 `find()`와 `findIndex()`를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nconst user = users.find(u =\u003e u.id === 1);\nconsole.log(user); // { id: 1, name: 'Jane' }\nconst index = users.findIndex(u =\u003e u.id === 1);\nconsole.log(index); // 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\n\n## 19. 배열 `some()` 및 `every()`\n\n문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `some()` 및 `every()`를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num =\u003e num % 2 === 0);\nconsole.log(hasEven); // true\nconst allEven = numbers.every(num =\u003e num % 2 === 0);\nconsole.log(allEven); // false\n```\n\n이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\n\n## 20. 배열 `flat()` 및 `flatMap()`\n\n문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: 더 읽기 쉬운 코드를 위해 `flat()` 및 `flatMap()`을 사용하세요.\n\n```js\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(2);\nconsole.log(flat); // [1, 2, 3, [4]]\nconst mapped = [1, 2, 3].flatMap(x =\u003e [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n```\n\n이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\n\n## 21. Array `from()` and `of()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `Array.from()` 및 `Array.of()`를 사용하세요.\n\n```js\nconst set = new Set([1, 2, 3]);\nconst arrFromSet = Array.from(set);\nconsole.log(arrFromSet); // [1, 2, 3]\nconst arrOfNumbers = Array.of(1, 2, 3);\nconsole.log(arrOfNumbers); // [1, 2, 3]\n```\n\n`Array.from()`은 이터러블 객체에서 배열을 만들 수 있고, `Array.of()`은 인수 목록에서 배열을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 22. 콜백에서 파라미터 구조 분해\n\n문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nusers.forEach(({ id, name }) =\u003e {\nconsole.log(`User ID: ${id}, User Name: ${name}`);\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\n\n## 23. 선택적 콜백 함수\n\n문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\n\n해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction fetchData(url, callback) {\n    fetch(url)\n    .then(response =\u003e response.json())\n    .then(data =\u003e {\n        callback \u0026\u0026 callback(data);\n    });\n}\n```\n\n단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\n\n## 24. 콜백을 프로미스로 변환하기\n\n문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\n\n```js\nfunction promisify(fn) {\nreturn function (…args) {\nreturn new Promise((resolve, reject) =\u003e {\nfn(…args, (err, result) =\u003e {\nif (err) reject(err);\nelse resolve(result);\n});\n});\n};\n}\nconst readFile = promisify(require('fs').readFile);\nreadFile('path/to/file.txt', 'utf8')\n.then(data =\u003e console.log(data))\n.catch(err =\u003e console.error(err));\n```\n\n프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\n\n## 25. 동기적인 코드를 위한 Async/Await\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\n\n해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\n\n```js\nasync function fetchData(url) {\ntry {\nconst response = await fetch(url);\nconst data = await response.json();\nconsole.log(data);\n} catch (error) {\nconsole.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n}\n}\nfetchData('https://api.example.com/data');\n```\n\nAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 26. Promises 연쇄하기\n\n문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\n\n해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\n\n```js\nfetch('https://api.example.com/data')\n.then(response =\u003e response.json())\n.then(data =\u003e {\n    console.log('데이터:', data);\n    return fetch('https://api.example.com/more-data');\n})\n.then(response =\u003e response.json())\n.then(moreData =\u003e {\n    console.log('더 많은 데이터:', moreData);\n})\n.catch(error =\u003e {\n    console.error('에러:', error);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.**\n\n## 27. 동시 실행을 위한 Promise.all\n\n문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\n\n해결책: `Promise.all`을 사용하여 동시에 비동기 작업을 처리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst fetchData1 = fetch('https://api.example.com/data1').then(response =\u003e response.json());\nconst fetchData2 = fetch('https://api.example.com/data2').then(response =\u003e response.json());\nPromise.all([fetchData1, fetchData2])\n.then(([data1, data2]) =\u003e {\nconsole.log('Data 1:', data1);\nconsole.log('Data 2:', data2);\n})\n.catch(error =\u003e {\nconsole.error('Error:', error);\n});\n```\n\n`Promise.all`을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\n\n## 28. 디바운스 함수\n\n문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\n\n```js\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =\u003e func.apply(this, args), wait);\n  };\n}\nwindow.addEventListener('resize', debounce(() =\u003e {\n  console.log('창 크기 조정됨');\n}, 200));\n```\n\ndebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\n\n## 29. 스로틀 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\n\n해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\n\n```js\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n  return function (...args) {\n    if (!lastRan) {\n      func.apply(this, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() =\u003e {\n        if (Date.now() - lastRan \u003e= limit) {\n          func.apply(this, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() =\u003e {\n  console.log('창 스크롤됨');\n}, 200));\n```\n\n스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 30. 객체의 깊은 복제\n\n문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\n\n해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\n\n```js\nconst obj = { a: 1, b: { c: 2 } };\nconst deepClone = JSON.parse(JSON.stringify(obj));\nconsole.log(deepClone); // { a: 1, b: { c: 2 } }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\n\n## 31. 메모이제이션\n\n문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\n\n해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction memoize(func) {\nconst cache = new Map();\nreturn function (...args) {\nconst key = JSON.stringify(args);\nif (cache.has(key)) {\nreturn cache.get(key);\n}\nconst result = func.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\nconst expensiveFunction = memoize((num) =\u003e {\nconsole.log('계산 중…');\nreturn num * 2;\n});\nconsole.log(expensiveFunction(2)); // \"계산 중…\" 4\nconsole.log(expensiveFunction(2)); // 4\n```\n\n메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\n\n## 32. 함수 커링\n\n문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\n\n```js\nfunction curry(func) {\nreturn function curried(…args) {\nif (args.length \u003e= func.length) {\nreturn func.apply(this, args);\n}\nreturn function (…nextArgs) {\nreturn curried.apply(this, args.concat(nextArgs));\n};\n};\n}\nconst sum = (a, b, c) =\u003e a + b + c;\nconst curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\n```\n\n커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\n\n## 33. 부분 적용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\n\n해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\n\n```js\nfunction partial(func, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn func(...presetArgs, ...laterArgs);\n};\n}\nconst multiply = (a, b, c) =\u003e a * b * c;\nconst double = partial(multiply, 2);\nconsole.log(double(3, 4)); // 24\n```\n\n부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n34. 함수 합성\n\n문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\n\n```js\nconst compose = (…funcs) =\u003e (arg) =\u003e\nfuncs.reduceRight((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\n\n## 35. 함수 파이프라이닝\n\n문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\n\n해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst pipe = (...funcs) =\u003e (arg) =\u003e\nfuncs.reduce((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = pipe(add, multiply);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\n\n## 36. 스스로 호출하는 함수\n\n문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\n\n```js\n(function () {\nconsole.log('즉시 실행됩니다!');\n})();\n```\nIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\n\n## 37. 전역 변수 사용을 피하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\n\n해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\n\n```js\n// 지역 변수 사용\nfunction doSomething() {\n    let localVariable = '지역 변수입니다';\n    console.log(localVariable);\n}\n// 모듈 사용\nconst myModule = (function () {\n    let privateVariable = '비공개 변수입니다';\n    return {\n        publicMethod() {\n            console.log(privateVariable);\n        },\n    };\n})();\nmyModule.publicMethod(); // \"비공개 변수입니다\"\n```\n\n전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 38. 클로저를 사용한 캡슐화\n\n문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\n\n해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\n\n```js\nfunction createCounter() {\nlet count = 0;\nreturn {\nincrement() {\ncount++;\nreturn count;\n},\ndecrement() {\ncount--;\nreturn count;\n},\n};\n}\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\n\n## 39. 모듈 패턴\n\n문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\n\n해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst myModule = (function () {\nlet privateVariable = 'This is private';\nfunction privateMethod() {\nconsole.log(privateVariable);\n}\nreturn {\npublicMethod() {\nprivateMethod();\n},\n};\n})();\nmyModule.publicMethod(); // \"This is private\"\n```\n\n모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\n\n## 40. 싱글톤 패턴\n\n문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\n\n```js\nconst singleton = (function () {\nlet instance;\nfunction createInstance() {\nreturn {\nname: '싱글톤 인스턴스',\n};\n}\nreturn {\ngetInstance() {\nif (!instance) {\ninstance = createInstance();\n}\nreturn instance;\n},\n};\n})();\nconst instance1 = singleton.getInstance();\nconst instance2 = singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n```\n\n싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\n\n## 41. 팩토리 패턴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\n\n해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\n\n```js\nfunction createUser(name, role) {\nreturn {\nname,\nrole,\nsayHello() {\nconsole.log(`안녕하세요, 제 이름은 ${this.name}이고 ${this.role}입니다.`);\n},\n};\n}\nconst admin = createUser('Alice', 'admin');\nconst user = createUser('Bob', 'user');\nadmin.sayHello(); // \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\nuser.sayHello(); // \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\n```\n\n팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 42. 관찰자 패턴\n\n문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\n\n해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\n\n```js\nfunction Subject() {\nthis.observers = [];\n}\nSubject.prototype = {\nsubscribe(observer) {\nthis.observers.push(observer);\n},\nunsubscribe(observer) {\nthis.observers = this.observers.filter((obs) =\u003e obs !== observer);\n},\nnotify(data) {\nthis.observers.forEach((observer) =\u003e observer.update(data));\n},\n};\nfunction Observer(name) {\nthis.name = name;\n}\nObserver.prototype.update = function (data) {\nconsole.log(`${this.name} received data: ${data}`);\n};\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('새로운 데이터 이용 가능'); // \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\n\n## 43. 이벤트 위임\n\n문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\n\n해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndocument.getElementById('parent').addEventListener('click', (event) =\u003e {\nif (event.target \u0026\u0026 event.target.matches('button.className')) {\nconsole.log('Button clicked:', event.target.textContent);\n}\n});\n```\n\n이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\n\n## 44. `eval()` 사용 피하기\n\n문제: `eval()` 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `eval()`을 사용하지 말고 더 안전한 대안을 사용하세요.\n\n```js\n// 피하십시오\nconst code = 'console.log(\"Hello, world!\")';\neval(code); // \"Hello, world!\"\n// 더 안전한 대안 사용\nconst func = new Function('console.log(\"Hello, world!\")');\nfunc(); // \"Hello, world!\"\n```\n\n`eval()`을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\n\n## 45. `for…of`를 사용하여 반복하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\n\n해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nfor (const value of arr) {\nconsole.log(value);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n`for...of`는 간단하고 안전한 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":21},{"title":"React와 TailwindCSS로 반응형 NavBar 만드는 방법","description":"","date":"2024-06-22 05:04","slug":"2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS","content":"\n\n현재의 모바일 중심 세상에서는 반응형 디자인을 만들고 이를 구현하는 것이 모든 기기에서 원활한 사용자 경험을 제공하는 데 필수적입니다. \n오늘은 내비게이션 바에 반응 형성을 어떻게 구현할 수 있는지에 대해 이야기하겠습니다.\n\n1- NavBar.tsx 라는 컴포넌트를 생성하세요 (이 튜토리얼에서 TypeScript를 사용할 것입니다).\n\n2- 더 큰 화면에 대한 NavBar 세부 정보를 구현하십시오. 간단하게 말해서, 이것들은 nav를 플렉스 컨테이너로 만들고 그 안에 웹 사이트 로고, 정렬되지 않은 목록 및 오른쪽에 버튼이 있을 것입니다.\n\n```jsx\n  \u003cnav className=\"flexBetween max-container padding-container relative z-30 py-5\"\u003e\n      \u003cLink href=\"/\"\u003e\n        \u003cImage src=\"/hilink-logo.svg\" alt=\"logo\" width={74} height={29} /\u003e\n      \u003c/Link\u003e\n      \u003cul className=\"hidden h-full gap-12 lg:flex\"\u003e\n        {NAV_LINKS.map((link) =\u003e (\n          \u003cLink\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          \u003e\n            {link.label}\n          \u003c/Link\u003e\n        ))}\n      \u003c/ul\u003e\n\n      \u003cdiv className=\"lg:flexCenter hidden\"\u003e\n        \u003cButton\n          type=\"button\"\n          title=\"Login\"\n          icon=\"/user.svg\"\n          variant=\"btn_dark_green\"\n        /\u003e\n      \u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서, nav 태그에는 단순히 (flex items-center justify-between)인 flexBetween 특수 css 클래스가 있습니다. 이 컨테이너의 첫 번째 아이템은 로고이고, 그 다음은 웹 사이트 루트로의 내비게이션 링크가 있는 비순서 목록이며, 마지막으로 버튼이 있습니다.\n\n3- 작은 화면을 위한 내비게이션 구현하기.\n이제, 1024px보다 작은 화면에는 내비게이션이 없을 것임을 알았습니다 (lg:는 콜론 뒤에 넣은 클래스명이 대형 화면 및 이상에서만 사용된다는 의미입니다).\n\n작은 화면에는 햄버거 아이콘을 넣을 것입니다.\n\n![해당 이미지](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 작은 화면용 내비게이션을 넣기 위해 이 버튼이 클릭될 때 언제 체크해야 합니다.\n그를 위해:\n\n```js\nconst [isOpen, setIsOpen] = useState(false);\nconst changeIsOpen = () =\u003e {\n setIsOpen(!isOpen);\n};\nuseEffect(() =\u003e {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n또한 isOpen 상태 변화를 모니터링하기 위해 useEffect 훅을 사용할 수 있습니다:\n\n```js\nuseEffect(() =\u003e {\n console.log(isOpen);\n}, [isOpen]);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4- IsOpen 변수 및 changeIsOpen 함수 사용하기\n\n```js\n{isOpen \u0026\u0026 \u003cNavSmallScreen changeIsOpen={changeIsOpen}/\u003e}\n\n\u003cImage\n    src=\"menu.svg\"\n    alt=\"menu\"\n    width={32}\n    height={32}\n    className=\"inline-block cursor-pointer lg:hidden\"\n    onClick={changeIsOpen}\n```\n\n5- NavSmallScreen 컴포넌트 구현하기\n\n그다음으로 NavSmallScreen 컴포넌트를 만들겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {NAV_LINKS} from \"@/constants\";\nimport Link from \"next/link\";\nimport Image from \"next/image\";\n\nfunction NavSmallScreen({changeIsOpen}: {changeIsOpen: () =\u003e void}) {\n  return (\n    \u003cdiv\n      className=\"flex flex-col items-center min-w-[70vw] z-[105] p-10 h-full w-full fixed left-0 top-0 opacity-90 bg-black  backdrop-blur-md rounded-lg\"\u003e\n      \u003cul\n        className=\"flex flex-col items-center justify-center gap-10 text-xl h-full \"\u003e\n        {NAV_LINKS.map((link) =\u003e (\n          \u003cLink\n            href={link.href}\n            key={link.key}\n            className=\"regular-16 text-gray-500 flexCenter cursor-pointer pb-1.5 transition-all hover:font-bold\"\n          \u003e\n            {link.label}\n          \u003c/Link\u003e\n        ))}\n\n        \u003cImage\n          src=\"close.svg\"\n          alt=\"menu\"\n          width={32}\n          height={32}\n          className=\"inline-block cursor-pointer lg:hidden\"\n          onClick={changeIsOpen}\n        /\u003e\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default NavSmallScreen;\r\n```\n\n![Responsive Navbar](/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_1.png)\n\n저희는 부모 컴포넌트에서 changeIsOpen 함수를 자식 컴포넌트로 전달하고, 이 함수를 클릭시 닫기 아이콘(X)에 사용합니다. 그래서 메뉴가 닫힙니다.\n\n이 게시물을 읽어 주셔서 감사합니다. 여러분의 반응형 목표를 달성하는데 도움이 되었으면 좋겠습니다! 즐거운 하루 되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub repository 에서 소스 코드를 확인할 수 있습니다.\n[이 곳](https://github.com/egemenc21/camptraveler/blob/main/components/Navbar.tsx)에서 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png"},"coverImage":"/assets/img/2024-06-22-MakeyourNavBarResponsivewithReactandTailwindCSS_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular v17이 해결한 이전에는 해결 불가능했던 문제","description":"","date":"2024-06-22 05:02","slug":"2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem","content":"\n## 도커 빌드에 간단한 유니코드 문자가 문제를 일으킨 방법\n\n# 소개\n\n소프트웨어 엔지니어로서, 소프트웨어 문제가 발생할 때, 그 원인을 파악하는 것을 좋아합니다. 따라서, 우리가 실행 중인 시스템을 소유하거나 제어하지 못하여 충분히 파고들기 어렵다면, 해결할 수 없는 문제나 설명할 수 없는 문제는 없다고 말할 수 있습니다.\n\n이 기사에서는 간단한 유니코드 문자가 문제를 일으킨 방법을 분석하겠습니다. 이 문제는 해결하기 위해 많은 시간을 투자했지만, 해결할 수 없었던 것처럼 보였습니다. 걱정하지 마세요, 여전히 해결책을 찾아가겠지만, 다른 문제를 일으킬 수 있다는 주의를 요청드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제에 직면하기 전에, Angular, Azure Container Registry 및 Azure Pipelines Windows 에이전트가 어떻게 연관되는지 이해해야 합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png)\n\n## Azure 파이프라인 에이전트\n\nAzure 파이프라인은 마이크로소프트에서 제공하는 솔루션이며, 코드 프로젝트를 자동으로 빌드하고 테스트합니다. 지속적 통합 및 지속적 전달 (CI/CD) 관행을 결합하여 응용 프로그램을 어떠한 대상에도 빌드, 테스트 및 릴리스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAzure 파이프라인 에이전트는 한 번에 하나의 작업을 실행하는 에이전트 소프트웨어가 설치된 컴퓨팅 인프라(컴퓨터)입니다. CI/CD 작업은 이러한 작업 내에서 수행됩니다.\n\nAzure 파이프라인은 두 가지 주요 유형의 에이전트를 제공합니다:\n\n- Microsoft 호스팅 에이전트(마이크로소프트에 의해 클라우드에서 호스팅되고 완전히 관리됨)\n- 자체 호스팅 에이전트(온프레미스 인프라에서 호스팅됨)\n\nAzure 파이프라인 에이전트는 여러 유형의 기계에 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- macOS 에이전트\n- Linux 에이전트\n- Windows 에이전트\n- Docker 에이전트\n\n이게 왜 중요한지 조금 뒤에 알아보겠습니다.\n\n## az acr build 명령어란?\n\n익숙한 docker build 형식을 사용하여 Azure CLI의 az acr build 명령은 프로젝트를 압축하고 임시 blob 저장소로 업로드한 다음 Microsoft 호스팅 에이전트 중 하나가 이를 가져와 docker build를 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빌드 과정 중에 빌드 에이전트는 로그를 우리에게 스트리밍합니다 (나중에 이것이 왜 중요한지 알게됩니다). 작업이 완료되면 빌드된 이미지가 Microsoft Azure 클라우드에 호스팅된 관리형 Docker 레지스트리 서비스인 Azure Container Registry에 푸시됩니다.\n\n## Angular에 대하여\n\nAngular는 인기있는 오픈 소스 프론트엔드 웹 애플리케이션 프레임워크로, 동적인 단일 페이지 웹 애플리케이션(SPA) 및 점진적 웹 애플리케이션(PWA)을 구축하는 데 사용됩니다.\n\n# Angular이 책임을 집니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 Angular 애플리케이션의 Dockerfile을 살펴봅시다.\n\nAngular 프로젝트는 ng build 명령어를 사용하여 빌드됩니다. 이 명령어는 npm run build명령어에 의해 백그라운드에서 호출됩니다.\n\n버전 17 이전의 모든 Angular 버전에서는 완료 후에 npm run build명령에 대한 출력으로 다음 텍스트가 표시됩니다:\n\n![Angular output](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n녹색 체크 표시는 \"✔\"가 유니코드 문자 (코드 U+2714)인 것이 문제를 만드는 원인이 됩니다.\n\n# Azure DevOps 에이전트가 잘못되었다\n\n다음과 같은 YAML 파이프라인 정의를 사용하여 Azure 파이프라인에서 az acr 빌드 명령을 Windows 에이전트에서 실행해 봅시다 (Windows OS가 중요한 이유를 조금 후에 알게 될 것입니다):\n\nPython을 사용하여 Windows OS 기계에서 다음 명령을 실행함으로써 동일한 오류를 재현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n(파이썬 -c \"print('\\u2714')\") \u003e\u003e output.txt\n```\n\n# 발생하는 위치와 이유\n\n만약 자체 호스팅된 에이전트를 사용한다면, 파이프라인 로그 중에 하나도 에이전트의 컴퓨터에 저장되지 않음을 알 수 있습니다. 대신, 저희가 사용하는 파이프라인 에이전트는 모든 로그를 Azure DevOps 서버로 보내어 저장합니다.\n\n문제는 '체크 마크'로 알려진 '\\u2714' 문자가 파이프라인 에이전트에서 디코딩을 시도할 때 발생합니다. 이는 colorama/ansitowin32.py 스크립트 파일 내에서 다음과 같은 에러 로그 부분에서 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nD:\\a\\_work\\1\\s\\build_scripts\\windows\\artifacts\\cli\\Lib\\site-packages\\colorama/ansitowin32.py\n```\n\n플로우 다이어그램을 살펴보고 모든 구성 요소가 서로 어떻게 대화하는지 살펴봅시다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_2.png)\n\n기술적으로, 2단계와 3단계의 경우 우리의 압축된 프로젝트는 Azure Blog 스토리지에 업로드되며, ACR 빌드 에이전트에 의해 가져옵니다. 마찬가지로 ACR 빌드 에이전트는 Azure Blog 스토리지에 로그를 저장한 후 az acr 명령어의 일부로 스트리밍됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAzure 파이프라인 빌드 에이전트에서 오류가 발생했습니다. 단계 3과 4 사이에서 발생한 오르로, Azure 블로그 스토리지에서 로그를 스트리밍하고 stdout로 출력하는 과정 중에 발생했습니다.\n\nAzure CLI 서버는 터미널에 색상이 있는 텍스트를 생성하기 위해 colorama(파이썬 패키지)를 사용합니다. 이를 위해 stdout을 래핑하여 찾은 ANSI 시퀀스를 제거하고(결과물로 나타나는 의미없는 문자열을) 해당 시퀀스를 수정하는 적절한 Win32 API 호출로 변환합니다.\n\n## Azure CLI 소스 코드 심층 분석\n\nAzure CLI에서 발생한 오류는 command_modules/acr/\\_stream_utils.py 파일의 143번째 줄에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport colorama\n.\n.\ncolorama.init()\n.\n.\nprint(flush.decode('utf-8', errors='ignore'))\n```\n\n이 줄은 단순히 UTF-8 디코딩된 바이트 스트링을 출력합니다 (블롭 스토리지에서 검색된 로그 데이터). 그러나 colorama 패키지가 가져와서 초기화되었으므로 다음 print 명령은 텍스트에 색상 또는 스타일을 추가하는 colorama의 기능을 활용할 것입니다.\n\nColorama는 Win32 API 호출을 사용하여 터미널 상태를 수정하며, Win32 API는 기본적으로 Unicode-특정 문자를 지원하지 않는 ANSI 코드 페이지를 사용합니다. 이는 Unicode 문자열을 표시하려고 시도하는 동안 Unicode 코드 페이지를 지원하지 않는 API를 사용하려는 것이 우리 문제의 근본 원인입니다.\n\n이제 우리는 백그라운드에서 무슨 일이 일어나는지 이해하기 시작합니다. 그러나 실제 솔루션을 살펴보기 전에 다른 가능한 어정쩡한 솔루션을 확인해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로그 없이도 문제 없을까요?\n\n로그를 비활성화하면 문제가 해결될 것으로 생각할 수 있습니다. 비록 그게 맞긴 하지만, 더 나은 방법이 있습니다. 로그를 비활성화하는 방법은 두 가지가 있습니다:\n\n- -- no-logs 인수를 추가하여 az acr build 명령에서 로그 스트리밍을 완전히 비활성화합니다. 이것은 빌드 로그를 완전히 잃어버리기 때문에 이 방법은 최악의 해결책입니다.\n\n```js\naz acr build --no-logs --registry $(Registry) --image \"$(image):$(tag)\" .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `ng build` 명령어의 진행 로그를 `--progress=false` 인수로 비활성화하세요. 진행과 관련된 로그의 일부를 여전히 잃게 되어 이는 이상적인 해결책은 아닙니다.\n\n```js\nRUN npm run build -- --progress=false\n```\n\n# 진짜 해결책\n\n해결책을 살펴보기 전에, 인코딩과 문자 집합(코드 페이지)이 어떻게 작동하는지에 대해 이해해야 합니다. Unicode와 문자 집합에 관해 꼭 알아야 할 절대 최소한의 정보 - 모든 소프트웨어 개발자가 반드시 알아야 할 것 (변명 금지!) -이라는 글을 읽는 것을 강력히 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ACP은 ANSI (American National Standards Institute) 코드 페이지를 나타내며, 미국 및 서유럽 지역의 기본값은 Windows-1252 문자 세트로 설정됩니다. 이는 레거시 GUI 애플리케이션에서 사용됩니다.\n- OEMCP는 제조업체 코드 페이지를 의미하며, 기본값은 437 (원래 IBM PC의 문자 세트)로 설정됩니다. 이는 레거시 콘솔 애플리케이션에서 사용됩니다.\n\nPowerShell을 통해 다음 레지스트리 경로를 확인하여 Windows 레지스트리에서 현재 정의된 ANSI 코드 페이지와 OEM 코드 페이지를 확인할 수 있습니다:\n\n```shell\nGet-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage `\n  | Select-Object OEMCP, ACP\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지역 설정에 따라이 값은 코드 페이지 식별자 목록에서 어느 것이든 취할 수 있습니다. 가장 일반적인 것은 다음과 같습니다:\n\n- 874-태국어\n- 932-ShiftJIS — 일본어\n- 936-GBK — 중국어 (중국 본토, 싱가포르)\n- 949-한국 통합 한글\n- 950-Big5 Extended — 중국어 (대만, 홍콩)\n- 1250-중앙 유럽\n- 1251-키릴 자모\n- 1252-미국 (ANSI)\n- 1253-그리스어\n- 1254-터키어\n- 1255-히브리어\n- 1256-아랍어\n- 1257-발트 어\n\ncmd.exe 및 powershell.exe에서 텍스트는 현재 지정된 ANSI 코드 페이지를 사용하여 작성하고 읽습니다.\n\n유니코드 특수 문자 인코딩을 지원하기 위해 Windows 레지스트리 항목을 변경하여 Windows가 UTF-8 인코딩 (코드 페이지 65001)을 사용하도록 설정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nNew-ItemProperty -LiteralPath 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage' -Name 'ACP' -Value '65001' -PropertyType String -Force;\n\n\n전 세계 언어 지원을 위해 유니코드 UTF-8 사용 베타 기능을 활성화함으로써 비슷한 결과를 얻을 수 있습니다.\n\n- intl.cpl을 실행합니다.\n- \"관리자\" 탭을 엽니다.\n- \"시스템 로캘 변경\"을 엽니다.\n- \"베타: 전 세계 언어 지원을 위한 유니코드 UTF-8 사용\"을 활성화합니다.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이 솔루션으로 다른 문제가 발생하는 방법\n\n그러나 이것은 오래된 Windows 버전에서 부팅 문제를 일으키며, PowerShell을 작은 글꼴 크기로 고정시키고 텍스트가 올바르게 표시되지 않는 등의 문제를 일으킵니다. 따라서 이 문제를 해결함으로써 다른 문제가 발생할 수 있습니다.\n\n그래서 우리는 여기서 덜 나쁜 것을 선택하는 것 뿐입니다.\n\n## Linux 에이전트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 질문이 생깁니다. Linux 기반 Azure DevOps 에이전트에서도 동일한 오류가 발생하는가요? 답은 아니오, 왜냐하면 colorama가 터미널 출력을 변경하기 위해 Win32 API 호출을 하지 않기 때문입니다.\n\n# Angular 버전 17.x가 이 문제를 어떻게 해결했는지\n\n실은 매우 간단합니다. Angular 버전 17부터는 'ng build' 명령어의 빌드 출력에 '✔' (유니코드 문자)는 더 이상 표시되지 않으며, 따라서 Win32 API와의 인코딩 문제를 일으키지 않게 되었습니다. 그게 다에요.\n\n![이미지](/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n처음에 해결할 수 없는 것 같은 코딩 문제는 먼저는 좀 짜증이 나겠지만, 이를 해결해내는 것이 우리 소프트웨어 엔지니어들이 하는 일입니다. 우리의 인내와 끈기를 시험하며, 해결되면 귀중한 경험을 안겨주고 배경에서 어떻게 작동하는지에 대한 자세한 통찰력을 제공합니다.\n\n명확한 해결책이 없는 도로 봉쇄물에 부딪힌 것은 좌절스러울 수 있지만, 그러한 도로 봉쇄물이 우리에게 성장과 학습 기회를 제공하는 것을 기억하는 것이 중요합니다. 궁극적으로, 이들은 우리를 다른 소프트웨어 엔지니어들과 깊이 이해차로 만들어 줍니다.\n\n그러니 이것이 지나가고 과거에 겪었던 해결이 어렵다고 여겼던 코딩 문제를 다시 시도해 보는 동기가 되길 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서 사용된 모든 소스 코드는 제 GitHub 저장소에 있습니다.\n\n# 쉽게 이해할 수 있는 용어로 🚀\n\nIn Plain English 커뮤니티에 함께 해주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 박수로 격려하고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기\n","ogImage":{"url":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png"},"coverImage":"/assets/img/2024-06-22-HowAngularv17AccidentallySolvedaPreviouslyUnsolvableProblem_0.png","tag":["Tech"],"readingTime":8},{"title":"애플리케이션 성능을 높이는 Angular Signals, Reactive Context, 그리고 동적 의존성 추적 방법","description":"","date":"2024-06-22 05:00","slug":"2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking","content":"\n\nAngular Signals를 효과적으로 사용하려면 \"반응형 컨텍스트\" 개념과 의존성 추적 방법을 이해하는 것이 중요합니다. 이 글에서는 이 두 가지를 설명하고 관련 버그를 피하는 방법을 보여 드리겠습니다.\n\n## 의존성 추적\n\nAngular Signals를 사용할 때 구독하고 구독 해제에 대해 걱정할 필요가 없습니다. 작동 방식을 이해하려면 몇 가지 용어가 필요합니다:\n\n- 의존 그래프: 노드의 그래프, 각 노드는 ReactiveNode 인터페이스를 구현합니다.\n- 생산자: 값을 포함하고 새 값에 대해 알림을 보내는 노드(반응성을 \"생산\"함).\n- 소비자: 생성된 값들을 읽는 노드(반응성을 \"소비\"함).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신호는 생산자이며, computed()는 생산자이자 소비자이며, effect()는 소비자이며, 템플릿은 소비자입니다.\n\n자동 의존성 추적이 작동하는 방식: 모든 반응 노드에 대한 전역 변수인 activeConsumer가 있고, computed()가 계산 함수를 실행할 때마다, effect()가 부수 효과 함수를 실행할 때마다, 또는 변경 사항을 확인할 때마다 실행할 때마다, 다음을 수행합니다:\n\n- activeConsumer의 값을 읽어 이전 소비자를 기억합니다.\n- 자신을 activeConsumer로 등록합니다.\n- 함수를 실행하거나 템플릿을 실행합니다 (일부 신호는이 단계에서 읽힐 수 있음).\n- 이전 소비자 (단계 1에서)를 activeConsumer로 등록합니다.\n\n어떤 생산자도 읽힐 때는 activeConsumer의 값을 검색하고이 활성 소비자를 신호에 종속된 소비자 목록에 포함합니다. 신호가 업데이트되면 목록에서 각 소비자로 알림을 전송합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 단계별로 어떻게 일이 진행되는지 살펴봅시다.\n\n```js\n@Component({\n  template: `\n   Items count: { $items().length }\n   Active items count: { $activeItemsCount() }\n`   \n})\nclass ExampleComponent {\n  protected readonly $items = signal([{id: 1, $isActive: signal(true) }]);\n\n  protected readonly $activeItemsCount = computed(() =\u003e {\n    return this.getActiveItems().length;\n  });\n\n  private getActiveItems() {\n    return this.$items().filter(i =\u003e i.$isActive());\n  }\n}\n```\n\n- 템플릿은 activeConsumer의 값을 읽고 이를 prevConsumer 변수에 저장합니다. (이 변수는 템플릿 내에서만 사용 가능함);\n- 템플릿은 자신을 activeConsumer로 설정합니다;\n- $items() 신호를 호출하여 값을 가져옵니다;\n- $items 신호는 activeConsumer의 값을 검색합니다;\n- 받은 값이 비어 있지 않으므로 (이는 템플릿에 대한 링크를 포함하고 있음), $items 신호는 이 값(우리 템플릿에 대한 링크)을 소비자 목록에 넣습니다. 이후 $items가 업데이트될 때마다 템플릿에 통지됩니다 — 종속성 그래프에 새 링크가 만들어집니다;\n- $items는 값으로 반환되어 템플릿에 전달됩니다;\n- 템플릿은 $activeItemsCount 신호의 값을 읽습니다. 값을 반환하려면 $activeItemsCount는 계산 함수를 실행해야 합니다(computed 함수에 전달한 함수);\n- 계산 함수를 실행하기 전에 $activeItemsCount는 activeConsumer의 값을 읽고 이를 로컬 변수 prevConsumer에 저장합니다. $activeItemsCount도 소비자이므로 activeConsumer 변수에 자체를 가리키는 링크를 추가합니다;\n- 계산 함수는 getActiveItems() 함수를 호출합니다;\n- 이 함수 내에서는 $items의 값을 읽습니다 — 3에서 6단계를 반복하지만, 템플릿이 이미 $items에 의존하고 있기 때문에, 5단계는 새 소비자를 목록에 추가하지 않습니다;\n- 반환된 값(아이템 배열)을 획득하면 getActiveItems()는이 배열의 각 요소를 읽고 $isActive의 값을 읽습니다;\n- $isActive는 신호입니다. 값으로 반환하기 전에 3에서 6까지 단계를 다시 반복합니다. 4단계에서 $isActive는 activeConsumer의 값을 검색합니다. 이때 activeConsumer에는 $activeItemsCount에 대한 링크가 포함되어 있으므로 5단계에서 $isActive (배열의 각 요소마다)는 $activeItemsCount를 종속 소비자 목록에 추가합니다. $isActive가 업데이트될 때마다 $activeItemsCount에 통지됩니다. $activeItemsCount는 템플릿에 값을 갱신해야 함을 통지하며 계산해야 함을 알립니다. 그 후, 템플릿에서 마침내 (통지 바로 다음이 아니라) $activeItemsCount에게 새로운 값을 물어봅니다. 그리고 7단계부터 14단계가 반복됩니다;\n- getActiveItems()가 값을 반환합니다. $activeItemsCount는이 값을 계산에 사용하고 반환하기 전에 로컬 변수 prevConsumer의 값을 activeConsumer 변수에 넣습니다;\n- $activeItemsCount가 값을 반환합니다;\n- 템플릿은 이전에 저장한 prevConsumer 값을 activeConsumer에 넣습니다.\n\n리스트가 길지만 꼼꼼히 읽어주시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 중요한 것은 여기서 소비자들 (computed(), effect(), templates)가 읽은 신호를 종속성 목록에 추가하는 걱정을 할 필요가 없다는 것입니다. 신호들은 자체적으로 activeConsumer 변수를 사용하여 이 작업을 수행합니다. 이 변수는 모든 반응성 노드에서 접근할 수 있으므로, 어떤 신호가 함수 체인의 어느 정도 깊은 곳에서 읽히든 상관없이 모든 신호는 activeConsumer의 값을 얻고 이를 소비자 목록에 추가할 것입니다.\n\n기억하세요: 템플릿, computed() 또는 effect() (소비자)에서 함수를 호출하고, 그 함수가 다른 함수를 읽고, 다른 함수가 다시 다른 함수를 읽는 경우에... 마침내 어떤 수준에서 함수가 신호를 읽고, 그 신호가 해당 소비자를 목록에 추가하고 업데이트에 대해 알릴 것입니다.\n\n디버깅과 같이 읽는 것은 지루할 수 있으므로, 이 작은 앱으로 당신을 즐겁게 해드리겠습니다:\n\n이 앱에서 다음을 수행해주십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 버튼 “2”를 눌러 활성화하고 다시 한 번 클릭하세요. 버튼 위의 “Active items” 텍스트가 변경되는 것을 확인하세요;\n- “Add Item” 버튼을 클릭하세요;\n- 버튼 “4”를 클릭하세요. “Active items” 텍스트가 변경되지 않는 것을 확인하세요;\n- 버튼 “2”를 클릭하세요;\n- 이제 버튼 “4”를 여러 번 클릭하고 “Active items” 텍스트가 예상대로 변경되는 것을 확인하세요.\n\n하지만 왜 그럴까요? 코드를 확인해보겠습니다:\n\n```js\nexport type Item = {\n  id: number;\n  $isActive: WritableSignal\u003cboolean\u003e;\n};\n\n@Component({\n  selector: 'my-app',\n  template: `\n    \u003cdiv\u003eActive items: { $activeItems() }\u003c/div\u003e\n    \u003cdiv\u003e\n      \u003cspan\u003eClick to to toggle:\u003c/span\u003e\n      @for(item of items; track item.id) {\n        \u003cbutton (click)=\"item.$isActive.set(!item.$isActive())\" \n                [class.active]=\"item.$isActive()\"\u003e\n          { item.id }\n       \u003c/button\u003e\n      }\n    \u003c/div\u003e\n    \u003cdiv\u003e\n      \u003cbutton (click)=\"addItem()\"\u003eAdd Item\u003c/button\u003e\n    \u003c/div\u003e\n  `,\n})\nexport class App {\n  protected readonly items: Item[] = [\n    { id: 1, $isActive: signal(true) },\n    { id: 2, $isActive: signal(false) },\n    { id: 3, $isActive: signal(true) },\n  ];\n\n  protected readonly $activeItems = computed(() =\u003e {\n    const ids = [];\n    for (const item of this.items) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.items.push({\n      id: this.items.length + 1,\n      $isActive: signal(false),\n    });\n  }\n}\n```\n\n이제 “Active items” 라인이 정확하게 업데이트되지 않는 이유를 분석해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 템플릿에서 바인딩:\n\n```js\n\u003cdiv\u003e활성 항목: { $activeItems() }\u003c/div\u003e\n```\n\n$activeItems은 computed()에 의해 제공되는 시그널입니다:\n\n```js\nprotected readonly $activeItems = computed(() =\u003e {\n  const ids = [];\n  for (const item of this.items) {\n    if (item.$isActive()) {\n      ids.push(item.id);\n    }\n  }\n  return ids.join(', ');\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncomputed() 함수에 전달하는 함수는 읽는 신호 중 하나라도 업데이트될 때마다 다시 실행됩니다. 그 곳에서는 어떤 신호를 읽을까요?\n\n이는 this.items 배열의 각 항목의 $isActive 신호입니다.\n\n그렇다면 왜 단계 2와 3 이후에 $activeItems이 업데이트되지 않았을까요?\n\n계산 함수는 의존하는 신호 중 하나가 업데이트될 때에만 다시 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Add Item\"을 클릭하면 이.items를 수정하고 새 항목 내에 새 신호를 생성합니다. 그러나 이 순간 이전에 computed() 함수가 해당 신호를 읽어본 적이 없기 때문에 의존 목록에 없습니다.\n\n\"Add Item\"을 클릭하기 전과 후에도 $activeItems가 의존하는 신호 목록은 바뀌지 않습니다: this.items의 세 항목에서 나오는 세 $isActive 신호입니다.\n\n\"Add Item\"을 클릭할 때 이러한 신호 중 어느 것도 수정되지 않기 때문에 computed() 함수에 알림이 전달되지 않고 계산 함수가 다시 실행되지 않습니다.\n\n우리는 새 항목을 버튼 목록에서 여러 번 토글할 수 있지만, 처음 세 항목의 신호만 $activeItems에 알림을 보내고 우리가 전송한 함수가 다시 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 우리가 계산 함수를 다시 실행하면, 이.items에서 모든 항목을 다시 읽고 새로운 시그널을 읽게 될 것입니다. 새로운 시그널은 $activeItems 노드의 새로운 종속성이 되며, 그중 하나가 변경될 때마다 알림을 받게 될 것입니다.\n\n이를 위해 기존 종속성 중 하나를 수정해야 합니다: 이것이 step 4에서 \"2\" 버튼을 클릭하는 이유입니다.\n\n이 예시는 computed()와 effect()에 전달하는 함수가 업데이트된 생산자 중 하나가 있을 때에만 다시 실행되는 것을 상기시키기 위해 만들어졌습니다.\n\n이것이 computed()가 어떤 종속성을 가지고 있고 그 중 어떤 것이 다시 계산을 유발해야 하는지 재확인하는 것이 언제나 유용한 이유입니다. 그 중 몇 가지는 유배제용()을 사용해야 할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncomputed() 또는 effect()에 전달하는 일부 함수는 신호를 읽을 수 있습니다 (또는 호출된 함수가 신호를 읽을 수 있습니다).\n\n```js\nthis.$petWalkingIsAllowed = computed(() =\u003e {\n  return this.$isFreeTime() \u0026\u0026 this.isItGoodWeatherOutside();\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() \u0026\u0026 $isWarm() \u0026\u0026 !$isStormy();\n}\n```\n\n원하지 않는 다시 계산을 피하기 위해 해당 호출을 untracked()로 감싸야 할지 여부를 이해하기 위해 이러한 논리를 사용할 수 있습니다:\n\n- 만약 우리가 computed()가 새로운 값을 계산하지 말아야 하는 경우, 그 함수(isItGoodWeatherOutside())가 새로운 값을 반환할 때 untracked()로 감싸주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nthis.$petWalkingIsAllowed = computed(() =\u003e {\n  return this.$isFreeTime() \u0026\u0026 untracked(() =\u003e this.isItGoodWeatherOutside());\n});\n\nisItGoodWeatherOutside() {\n  return $isSunny() \u0026\u0026 $isWarm() \u0026\u0026 !$isStormy();\n}\n```\n\n- 만약 해당 함수로부터의 모든 새 값에 대해 계산을 다시 실행하길 원한다면 untracked()으로 감싸지 마세요.\n\n보시다시피, untracked()은 우리가 추적하고 싶은 종속성을 제어하는 데 도움이 됩니다. 또한 또 다른 중요한 측면을 관리하는 데 도움이 됩니다:\n\n## 반응형 컨텍스트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 \"자동 종속성 추적 방법\"에서는 activeConsumer라는 변수에 대해 언급했어요.\n\nactiveConsumer가 null이 아닌 경우, 우리가 읽는 시그널은 activeConsumer를 소비자 목록에 추가하여 나중에 이 목록의 멤버들에게 시그널의 변경 사항에 대한 알림을 보내게 됩니다. 반응 노드가 읽힐 때 activeConsumer가 비어 있는 상태라면, 반응 노드의 종속성 그래프에 새로운 링크가 생성되지 않을 거에요.\n\n다시 말해, activeConsumer가 설정되어 있을 때는 반응적인 컨텍스트 내에서 시그널을 읽고 있는 것이에요.\n\n대부분의 경우에는 반응적인 컨텍스트가 자동으로 처리되며, 의도한 링크와 종속성만이 생성되고 제거될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 때로는 반응적인 컨텍스트를 무의식적으로 노출시키기도 합니다.\n\n다음 앱을 시험해 봅시다:\n\n사용해 보면 다음을 알 수 있을 거에요:\n\n- \"항목 추가\"를 클릭하면 모든 상태가 완전히 재설정됩니다.\n- 상태를 토글하면 무작위로 변경되어 한 가지 버튼 이상에 영향을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠르게 버그를 발견하실 수 있나요?\n\n```js\n@Component({\n  template: `\n    \u003cdiv\u003eActive items: { $activeItems() }\u003c/div\u003e\n    \u003cdiv class=\"flex-row\"\u003e\n      \u003cspan\u003eClick to to toggle:\u003c/span\u003e\n      @for(item of $items(); track item.id) {\n      \u003cbutton (click)=\"item.$isActive.set(!item.$isActive())\" [class.active]=\"item.$isActive()\" [style.transform]=\"'scale('+item.$scale()+')'\"\u003e\n        { item.id }\n      \u003c/button\u003e\n      }\n    \u003c/div\u003e\n    \u003cdiv\u003e\n      \u003cbutton (click)=\"addItem()\"\u003eAdd Item\u003c/button\u003e\n    \u003c/div\u003e\n  `,\n})\nexport class App {\n  private readonly $itemsCount = signal(3);\n\n  protected readonly $items: Signal\u003cItem[]\u003e = computed(() =\u003e {\n    console.warn('Generating items!');\n   \n    const items: Item[] = [];\n    for (let id = 0; id \u003c this.$itemsCount(); id++) {\n      const $isActive = signal(Math.random() \u003e 0.5);\n      const $scale = signal($isActive() ? 1.2 : 1);\n      items.push({ id, $isActive, $scale });\n    }\n    return items;\n  });\n\n  protected readonly $activeItems = computed(() =\u003e {\n    const ids = [];\n    for (const item of this.$items()) {\n      if (item.$isActive()) {\n        ids.push(item.id);\n      }\n    }\n    return ids.join(', ');\n  });\n\n  protected addItem() {\n    this.$itemsCount.update(c =\u003e c + 1);\n  }\n}\n```\n\n여기서 알 수 있는 것:\n\n- 우리는 $items에서 아이템 목록을 렌더링합니다. 이는 computed()로 구성되어 있습니다.\n- $items는 새로운 아이템 배열을 생성하며, 그 수는 $itemsCount 시그널에 의해 제어됩니다. $itemsCount를 수정할 때마다 아이템이 재생성됩니다.\n- addItem()은 단순히 $itemsCount를 증가시키고, $items의 재계산을 유도합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 \"Add Item\"이 이렇게 작동하는 이유를 알 수 있습니다. 이제 상태 토글이 이상하게 동작하는 이유를 알아보겠습니다.\n\n콘솔을 열면 버튼을 클릭할 때마다 \"Generating items!\" 경고가 기록된다는 것을 알 수 있습니다. 하지만 왜 그럴까요? $itemsCount를 수정하지 않았는데 $items가 다시 계산되는 이유는 무엇일까요?\n\n아마도 이미 주목했을지도 모르지만, $items의 계산 함수가 또 하나의 반응 소스를 읽고 있는 것을 알 수 있습니다: 신호 $isActive:\n\n```js\nconst $scale = signal($isActive() ? 1.2 : 1);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 신호 ($isActive)은 반응적인 컨텍스트에서 읽힙니다: activeConsumer에는 $items이 포함되어 있으므로 $isActive은 모든 변경 사항에 대해 $items에 통지합니다. 따라서이 상태를 전환하려고 $isActive을 수정할 때 우리는 $items의 재계산을 발생시킵니다.\n\n이 버그를 수정하는 여러 가지 방법이 있지만, 이 접근 방식은 반응적 컨텍스트의 누출을 방지합니다:\n\n```js\nconst $scale = signal(untracked($isActive) ? 1.2 : 1);\n```\n\nuntracked()가 하는 일은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/**\n * https://github.com/angular/angular/blob/75a186e321cb417685b2f13e9961906fc0aed36c/packages/core/src/render3/reactivity/untracked.ts#L15\n *\n * packages/core/src/render3/reactivity/untracked.ts\n *\n **/\nexport function untracked\u003cT\u003e(nonReactiveReadsFn: () =\u003e T): T {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n```\n\n- activeConsumer을 null로 설정하고 반환 값을 지역 변수 prevConsumer에 저장합니다.\n- 주어진 함수를 실행합니다.\n- prevConsumer에서 activeConsumer을 복원합니다.\n\n이 함수는 반응적인 컨텍스트를 일시적으로 해제하고 우리 함수를 실행한 후 반응적인 컨텍스트를 복원합니다.\n\n따라서 우리 함수가 실행되는 동안, 시그널이 읽혀지는 경우 activeConsumer에 null을 읽고 이를 소비자 목록에 추가하지 않습니다. 즉, 새로운 종속성이 생성되지 않습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서 콘솔에는 \"힌트\"가 있고, 우리의 코드는 매우 작고 간단합니다. 실제 앱에서는 신호 읽기가 함수 호출 체인 내에 깊이 숨겨져 있고, 코드가 훨씬 더 크고 복잡할 수 있습니다. 이러한 버그는 실제 앱에서 디버깅하기 어려울 수 있으므로 리액티브 컨텍스트를 누출하고 싶지 않을 때는 항상 untracked()을 사용하여 미리 방지하는 것을 권장합니다.\n\n리액티브 컨텍스트를 누락시킬 수 있는 흥미로운 예상치 못한 방법이 있습니다:\n\n- 신호를 읽는 클래스의 인스턴스를 만들기;\n- 신호를 읽는 함수를 호출하는 함수 호출하기;\n- effect() 내에서 컴포넌트 생성하기;\n- observable에 새 값을 발행하기.\n\ncomputed()와 effect()를 사용할 때,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 신호를 읽을 때 주의하세요. 다른 함수가 변경될 때마다 전체 함수를 다시 실행하며 다른 함수에 의해 트리거됩니다.\n- 이러한 기능들을 읽고 이해하기 쉽게 만드세요;\n- 함수 소비의 반응 소스를 모두 다시 확인하세요.\n\n자주 있듯이 암시적 의존성 추적은 혜택만 가져오는 것이 아니라 어떤 점에서는 희생을 갖고 올 수도 있습니다. 하지만 숙련된 기술과 주의를 기울여 사용할 때 Angular Signals를 사용하여 멋진 앱을 만들 수 있습니다!\n\n작성된 이 문서의 다듬어짐에 많은 기여를 한 리뷰어분들께 깊은 감사를 표합니다:\n\n- Rainer Hahnekamp\n- Josh Morony","ogImage":{"url":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png"},"coverImage":"/assets/img/2024-06-22-AngularSignalsReactiveContextandDynamicDependencyTracking_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular v18 출시 최신 기능 알아보기","description":"","date":"2024-06-22 04:58","slug":"2024-06-22-Angularv18isnowavailable","content":"\n\n오늘은 Angular 진화의 다음 단계를 공유하게 되어 흥분됩니다! 지난 세 번의 릴리스 동안 새로운 기능과 개선사항을 많이 소개했습니다. 이번에는 새로운 API 중 많은 부분을 안정 버전으로 승격하고, 개발자의 요청에 맞는 기능을 해결하며, 열망했던 로드맵 프로젝트 중 하나인 zoneless change detection을 실험적으로 출시했습니다.\n\n![Angularv18isnowavailable_0.png](/assets/img/2024-06-22-Angularv18isnowavailable_0.png)\n\n이번 릴리스의 하이라이트는 다음과 같습니다:\n\n- zoneless change detection에 대한 실험적 지원\n- Angular 개발자를 위한 새로운 홈페이지인 Angular.dev\n- Material 3, deferrable views, 내장 제어 흐름이 안정화되었으며 여러 개선사항이 포함되어 있습니다\n- i18n 수분화 지원, 더 나은 디버깅, Angular Material의 수분화 지원, Google 검색과 동일한 라이브러리를 통해 구동되는 이벤트 재생을 통한 서버사이드 렌더링 개선내용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시각적 개요를 위해 릴리스 이벤트에서 비디오를 확인해보세요:\n\n# 진화하는 변경 감지\n\n과거에는 zone.js라는 라이브러리가 Angular의 변경 감지를 트리거하는 역할을 했습니다. 이 라이브러리는 개발자 경험과 성능 면에서 몇 가지 단점이 있었습니다. 몇 년 동안 zone.js에 의존하지 않고 Angular를 사용하는 방법을 찾고 있었으며, 우리는 zoneless의 첫 실험적 API를 공유할 수 있어 매우 흥분합니다!\n\n오늘부터 Angular에서 실험적인 zoneless 지원을 시도해 볼 수 있습니다! 애플리케이션 부트스트랩에 provideExperimentalZonelessChangeDetection을 추가해 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideExperimentalZonelessChangeDetection()\n  ]\n});\n```\n\n위와 같은 프로바이더를 추가한 후에는 angular.json 파일에서 폴리필에 있는 zone.js를 제거해주세요.\n\n앞으로 나아가 zoneless는 개발자들에게 많은 가능성을 제공합니다:\n\n- 마이크로 프론트엔드 및 다른 프레임워크와의 상호 운용성을 향상시킴\n- 더 빠른 초기 렌더링 및 실행\n- 더 작은 번들 크기 및 빠른 페이지 로딩\n- 더 가독성이 좋은 스택 트레이스\n- 더 간단한 디버깅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴포넌트에서 zoneless를 사용하는 가장 좋은 방법은 signals로 처리하는 것입니다:\n\n```js\n@Component({\n  ...\n  template: `\n    \u003ch1\u003eHello from { name() }!\u003c/h1\u003e\n    \u003cbutton (click)=\"handleClick()\"\u003eGo Zoneless\u003c/button\u003e\n  `,\n})\nexport class App {\n  protected name = signal('Angular');\n\n  handleClick() {\n    this.name.set('Zoneless Angular');\n  }\n}\n```\n\n위 예시에서 버튼을 클릭하면 handleClick 메소드가 호출되어 신호 값이 업데이트되고 UI도 갱신됩니다. 이는 zone.js를 사용하는 응용 프로그램과 유사하게 작동하지만 몇 가지 차이점이 있습니다. zone.js를 사용하면 Angular은 응용 프로그램 상태가 변경될 때마다 변경 감지를 수행했습니다. 그러나 zone 없이는 Angular이 신호 업데이트와 같은 적은 트리거에 대해서만 변경 감지를 제한합니다. 이 변경에는 변경을 여러 번 연속으로 확인하는 것을 피하기 위한 코얼리싱을 포함한 새로운 스케줄러도 포함되어 있습니다.\n\n위의 버튼을 클릭하면 Angular이 코얼리싱을 통해 변경 감지를 한 번만 실행합니다. 더 많은 정보는 당사의 문서에서 zoneless를 배우세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 존리스로 업데이트 중\n\n요즘 Angular는 흥미로운 진화를 거치고 있는데, 존리스는 그 핵심 요소 중 하나입니다. 프레임워크를 발전시키면서 모든 기존 API가 예상대로 작동하고 Angular에 도입하는 새로운 기능과의 호환성이 잘 유지되도록 하고 있습니다.\n\n존리스는 우리의 호환성 접근 방식의 또 다른 예입니다. 게다가, 기존 애플리케이션을 존리스로 이전하는 과정이 가능한 간단해지도록 하고자 했습니다. Angular의 ChangeDetectionStrategy.OnPush 변경 감지 전략과 호환되는 경우, 구성 요소는 존리스와 대부분 호환되어 변환이 매끄럽게 진행될 것입니다!\n\n# 기본값으로 병합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nv18부터는 존이 없는 앱과 zone.js를 사용하며 coalescing이 활성화된 앱에 대해 동일한 스케줄러를 사용하고 있습니다. 새로운 zone.js 앱의 변경 감지 주기 수를 줄이기 위해 우리는 기본적으로 zone coalescing을 활성화했습니다.\n\n이 동작은 이전 변경 감지 동작에 의존하는 앱에서 버그를 발생시킬 수 있기 때문에 새로운 애플리케이션에 대해서만 활성화됩니다. Coalescing은 불필요한 변경 감지 주기를 줄이고 일부 애플리케이션의 성능을 크게 향상시킵니다.\n\n기존 프로젝트에 이벤트 coalescing을 적용하려면, bootstrapApplication에서 NgZone 프로바이더를 구성하세요:\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideZoneChangeDetection({ eventCoalescing: true })\n  ]\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 네이티브 await을 사용하여 Zone이 필요 없는 앱\n\nZone.js는 Angular의 변경 감지를 위해 많은 브라우저 호출을 가로챕니다. 그러나 async/await은 zone.js가 monkey patch할 수 없는 API 중 하나이기 때문에 Angular CLI를 통해 promises로 다운레벨해야 합니다. 이것은 모든 최신 브라우저가 지원하는 비동기/대기(async/await)를 promises보다 더 표현력이 있고 JavaScript 런타임에서 최적화되었다는 점에서 최적이 아닙니다.\n\n오늘날, 실험적인 zoneless change detection을 사용하는 앱을 만들면 Angular CLI는 네이티브 async/await을 사용하여 promises로 다운레벨링하지 않습니다. 이것은 디버깅을 개선하고 번들 크기를 줄일 것입니다.\n\n# 컴포넌트들은 Zone을 지원합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular CDK와 Angular Material에서 Zoneless 지원을 활성화했습니다. 이로 인해 Zoneless 모델의 일부 문제점을 발견하고 개선할 수 있었습니다.\n\n# Angular 개발자를 위한 새로운 홈\n\n지난 18개월 동안 우리는 angular.dev에서 직관적이고 실용적인 시작하는 과정을 제공하고 깊이 있는 안내서를 개선하기 위해 많은 노력을 기울였습니다. 오늘, 우리는 angular.dev이 Angular의 공식 문서 웹사이트로 지정되었음을 기쁘게 알려드립니다!\n\n새롭고 현대적인 느낌뿐만 아니라 WebContainers를 기반으로 한 대화형 실습 튜토리얼, 예제와 함께 제공되는 대화형 플레이그라운드, Algolia를 통해 구동되는 개선된 검색, 업데이트된 안내서, 간소화된 내비게이션 등이 추가되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Angularv18isnowavailable_1.png\" /\u003e\n\nangular.io의 모든 요청이 이제 자동으로 angular.dev로 리디렉션됩니다. 모든 기존 링크가 계속 작동하도록 하기 위해 개발자를 v17.angular.io로 리디렉션합니다.\n\nangular.dev로 가서 확인해보세요!\n\n# Material 3이 이제 안정화되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몇 달 전에 저희는 Material 3에 대한 실험적인 지원을 소개했어요. 개발자들의 피드백을 고려하고 Material 3 컴포넌트를 다듬은 후, 안정 버전으로 업데이트했어요!\n\n이와 함께, material.angular.io도 새로운 Material 3 테마와 문서로 새롭게 업데이트되었어요.\n\n\u003cimg src=\"/assets/img/2024-06-22-Angularv18isnowavailable_2.png\" /\u003e\n\n이제 우리의 안내서에서 어떻게 Angular Material 3를 앱에서 사용할 수 있는지 찾아보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개발자 미리보기에서의 Signal API\n\nAngular 버전 17.1과 17.2에서 새로운 signal 입력, signal 기반 쿼리, 그리고 새로운 출력 구문이 발표되었습니다.\n\n시그널 가이드에서 APIs를 어떻게 사용할지 알아보세요. 앞으로 몇 달 동안 여러분의 피드백을 기반으로 구현을 계속 개선하고, 안정 버전으로 승격할 것입니다.\n\n# 지연 로드 뷰가 이제 안정화되었습니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 6개월 동안, 우리는 deferrable views에 대한 많은 관심을 받았습니다. 이를 통해 개발자들이 앱의 핵심 웹 가치를 쉽게 향상시킬 수 있다는 것을 알게되었습니다. 예를 들어, Bill.com은 @defer를 사용하여 한 앱의 번들 크기를 50% 줄였다고 나누었습니다. 오늘, deferrable views가 이제 안정화되었습니다! 여러분은 여러분의 응용 프로그램과 라이브러리에서 이를 사용할 수 있습니다.\n\n# 내장 제어 흐름이 이제 안정화되었습니다\n\nv17에서 deferrable views와 함께, 성능을 개선한 새로운 내장 제어 흐름을 발표했습니다. 이 새로운 문법이 크게 채택되었고, 커뮤니티 피드백에 대응한 후, 우리는 이 API를 안정화했다는 것을 기쁘게 발표합니다!\n\n미리보기 단계에서는 제어 흐름의 타입 체크를 추가로 개선했고, 더 많은 효율적인 암시적 변수 별칭을 활성화하고, 특정 성능 관련 안티 패턴에 대한 가드레일을 설정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 서버 측 렌더링 개선사항\n\n1년 전에 우리는 하이드레이션을 소개했고 v17에서 안정 버전으로 출시했습니다. 공개 HTTPArchive 데이터셋을 기반으로 하면, 프리랜더링이나 서버 측 렌더링을 사용하는 Angular v17 앱 중 76%가 이미 하이드레이션을 사용하고 있습니다.\n\n더 많은 사람들이 하이드레이션을 활용할 수 있도록 하는 데 있어 한 가지 큰 걸림돌이 있었습니다 — i18n 지원 부족이었습니다. Chrome Aurora 팀과 협력한 끝에, 우리는 i18n 블록의 하이드레이션을 개발자 미리보기 모드로 제공하는 것을 기쁘게 생겨 v18에서 사용 가능합니다!\n\n# 이벤트 재생\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 달 가량 전에, 우리는 Angular과 Google의 내부 프레임워크 Wiz를 융합하는 장기 진행 중인 프로젝트를 발표했어요. Angular과 Wiz는 과거에 서로 다른 앱 세그먼트를 제공했었죠 — Wiz는 소비자를 주 타깃으로 한 앱에서 주로 사용되며 성능에 초점을 맞추었고, Angular은 생산성과 개발자 경험에 중점을 둔 것이었어요.\n\n융합 노력의 결과로, Wiz는 Angular Signls를 그들의 렌더링 모델에 깊게 통합시켰어요. 우리는 ng-conf에서 YouTube가 이제 Angular Signls를 사용하고 있다는 사실을 공유했었죠. 비슷하게, Angular은 이제 부분 수분화와 같은 성능 중심의 기능을 더 많이 가져오고 있어요. 조금 후에 더 자세히 소개할게요.\n\n두 경우 모두, 우리는 여러분의 기능 요청 및 다른 요구 사항을 모티브로 두 프레임워크의 중요한 기능을 융합하고 있어요.\n\n![이미지](/assets/img/2024-06-22-Angularv18isnowavailable_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 Google.com에서 실행 중인 핵심 라이브러리 중 하나인 이벤트 디스패치(event dispatch)가 Angular 모노레포에 추가되었다는 좋은 소식을 전해드립니다. 이벤트 디스패치는 이제 하이브리드 렌더링을 사용할 때 이벤트 재생을 담당하며, v18부터 제공됩니다.\n\n대부분의 개발자들은 이벤트 디스패치와 직접 상호 작용하지 않을 것이므로, 왜 이벤트 재생이 유용한지 살펴보겠습니다. 아래에 간단한 전자 상거래 웹사이트의 모형을 찾을 수 있습니다. 매우 느린 네트워크 연결을 시뮬레이션하기 위해 인위적인로딩 지연을 도입했습니다. 페이지가 아직 로딩 중이고 아직 수화되지 않은 상태에서 사용자가 카트에 여러 개의 헤드폰을 추가하려고 한다고 상상해보십시오. 페이지가 아직 수화되지 않았기 때문에 상호작용할 수 없으므로 모든 사용자 이벤트가 손실됩니다. v18에서 이벤트 디스패치를 사용하여 시작하면 Angular가 사용자 이벤트를 기록하기 시작합니다. 애플리케이션이 수화되면 이벤트 디스패치가 그것들을 재생하고 카트에 여섯 개의 항목이 생기게 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Angularv18isnowavailable_4.png\" /\u003e\n\n이벤트 재생 기능은 개발자 미리보기로 v18에서 사용할 수 있습니다. withEventReplay()를 사용하여 기능을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(withEventReplay())\n  ]\n});\n```\n\n# 디버깅 경험을 개선했습니다\n\nAngular DevTools를 업데이트하여 Angular의 수화 프로세스를 시각화했습니다. 각 구성 요소 옆에는 구성 요소의 수화 상태를 나타내는 아이콘이 있습니다. 페이지에서 Angular가 수화한 구성 요소를 미리 볼 수 있도록 오버레이 모드도 활성화할 수 있습니다. 앱에 수화 오류가 있는 경우 Angular DevTools가 구성 요소 탐색기에 시각화해줍니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Angularv18isnowavailable_5.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 커뮤니티 기여자 Matthieu Riegler에게 이 기능을 추가해 준 것에 대해 큰 감사를 전합니다!\n\n## CDK 및 Material의 수분 보충 지원 \n\nv17에서 일부 Angular Material 및 CDK 구성 요소가 수분 보충에서 제외되어 다시 렌더링되는 문제가 있었습니다. v18부터 모든 구성 요소 및 기본 구성 요소가 완전한 수분 보충 호환성을 갖추었습니다.\n\n## 우리의 부분적 수분 보충 계획\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng-conf와 Google I/O에서 부분 수분화를 발표했어요. 이 기술은 서버 사이드 렌더링 후 앱을 점진적으로 수분화할 수 있게 해줘요. 앱의 점진적 수분화는 처음에 적은 양의 JavaScript를 로드하고 앱의 성능을 향상시키는데 도움을 줘요.\n\n부분 수분화는 지연 뷰와 동일한 기반 위에 구축돼요. 오늘과 같이 서버에서 @placeholder 블록을 렌더링하는 대신, Angular가 서버에서 @defer 블록의 주요 콘텐츠를 렌더링할 수 있는 모드를 활성화할 수 있게 될 거예요. 클라이언트에서는 Angular가 템플릿에서 지정된 트리거 조건이 충족될 때에만 연기된 블록을 다운로드하고 수분화할 거에요. 예를 들어, 다음은 가상의 API 예시에요:\n\n```js\n@defer (서버에서 렌더링; 뷰포트 진입 시) {\n  \u003capp-calendar/\u003e\n}\n```\n\n위의 블록은 캘린더 컴포넌트를 서버에서 렌더링할 거예요. 클라이언트로 도달하면 Angular가 해당 JavaScript를 다운로드하고, 뷰포트에 들어간 후에만 상호작용 가능한 캘린더를 수분화할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 부분 수분 유화에 대해 노력하고 있습니다. 이미 상호 작용 트리거와 함께 사용할 수 있는 상태에 있습니다. 우리는 현재 파트너와 함께 작업하여 구성 요소가 속성을 수신하거나 바인딩 값을 변경하는 데이터 트리거의 중요성을 평가하고 있습니다.\n\n대규모의 중요한 성능을 필요로 하는 애플리케이션을 개발하고 있고, 부분 수분 유화의 미래를 형성하는 초기 액세스 프로그램에 참여하고 싶다면 devrel@angular.io로 이메일을 보내주세요.\n\n# Firebase 앱 호스팅으로 앱에 강력한 호스팅\n\n웹 플랫폼의 점점 더 복잡해지면서 응용 프로그램의 호스팅은 성능, 신뢰성, 생산성 및 확장성 측면에서 중요한 역할을 합니다. 하이브리드 렌더링을 사용하는 앱은 서버 측 렌더링, 사전 렌더링 및 클라이언트 측 렌더링을 위한 다른 호스팅 요구 사항이 있습니다. 이 복잡성을 수동으로 관리하는 것은 부담스러울 수 있습니다. Firebase 앱 호스팅은 개발자를 위해 이 모든 것을 투명하게 처리하고 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-Angularv18isnowavailable_6.png\" /\u003e\n\n올해 구글 I/O에서 Firebase가 앱 호스팅을 발표했습니다. 앱 호스팅은 동적 Angular 애플리케이션의 개발 및 배포를 간소화하며 기본 프레임워크 지원, GitHub 통합 및 인증, 클라우드 Firestore, Firebase의 Vertex AI와의 통합 등을 제공합니다.\n\nAngular와 함께 Firebase 작업을 하면서 개발자 경험을 보다 원할하게 만들도록 노력해 왔습니다. 오늘 앱 호스팅을 시작하는 것에 관한 속기 보세요!\n\n# 그리고 추가로... \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 계속 나아가는 대규모 프로젝트들과 함께, 항상 개발자들의 일반적인 요구를 해결하기 위해 시간을 보내고 있어요. v18의 하이라이트 중 일부는 다음과 같아요:\n\n# ng-content에 대한 폴백 콘텐츠 지정\n\n가장 많은 추천을 받은 문제 중 하나는 ng-content에 대한 기본 콘텐츠를 지정하는 것이었어요. v18에서 그것이 이제 가능해졌어요! 여기에 간단한 예시가 있어요:\n\n```js\n@Component({\n  selector: 'app-profile',\n  template: `\n    \u003cng-content select=\".greeting\"\u003eHello \u003c/ng-content\u003e\n\n    \u003cng-content\u003eUnknown user\u003c/ng-content\u003e\n  `,\n})\nexport class Profile {}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 컴포넌트를 사용할 수 있습니다:\n\n```js\n\u003capp-profile\u003e\n  \u003cspan class=\"greeting\"\u003e좋은 아침 \u003c/span\u003e\n\u003c/app-profile\u003e\n```\n\n결과는 다음과 같습니다:\n\n```js\n\u003cspan class=\"greeting\"\u003e좋은 아침 \u003c/span\u003e\n알 수 없는 사용자\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 통합된 제어 상태 변경 이벤트\n\nAngular Forms에서 FormControl, FormGroup 및 FormArray 클래스는 이제 events라는 속성을 노출시켜 이 폼 컨트롤의 이벤트 스트림에 구독할 수 있게 했습니다. 이를 사용하여 값 변경, 터치 상태, 원시 상태 및 제어 상태의 변경을 계속 추적할 수 있습니다.\n\n이제 다음과 같이 사용할 수 있습니다:\n\n```js\nconst nameControl = new FormControl\u003cstring|null\u003e('name', Validators.required);\nnameControl.events.subscribe(event =\u003e {\n  // 개별 이벤트 처리\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능 요청은 GitHub에서 440개 이상의 좋아요를 받았습니다. 저희 커뮤니티 기여자 Matthieu Riegler님 덕분에 모든 사람들에게 이용할 수 있게 되었습니다!\n\n# 응용 프로그램 빌더로의 마이그레이션 자동화\n\nAngular v17에서 우리는 \"응용 프로그램 빌더\"를 안정적인 상태로 발표하고 새로운 프로젝트에 대해 기본으로 활성화했습니다. 내부적으로는 Vite와 esbuild를 사용하여 이전 webpack 경험을 대체했습니다.\n\n대부분의 앱들에 대해, 개발자들은 angular.json을 업데이트함으로써 새로운 빌드 시스템으로 업데이트할 수 있었습니다. 지난 6개월 동안 우리는 사용자로부터 더 많은 피드백을 수집하고, 업데이트 경험을 개선하여 모두가 새로운 빌드 경험으로 이동하고 편집/새로 고침 효과를 받을 수 있도록 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당사의 업데이트 가이드에서 업데이트 경험을 자동화하기 위해 개발한 도구를 찾을 수 있습니다.\n\n새로운 빌드 시스템의 핵심 경로에 웹팩이 없기 때문에 웹팩에 대한 의존성을 선택 사항으로 만들었고, 이로 인해 Angular CLI의 총 종속성 수를 50% 이상 줄일 수 있었습니다! 이 변경으로 Angular CLI 설치 시간이 더 빨라집니다.\n\n# 함수로 된 경로 리디렉션\n\n리디렉션 처리 시 더 높은 유연성을 제공하기 위해 Angular v18에서 redirectTo는 이제 문자열을 반환하는 함수를 허용합니다. 예를 들어 런타임 상태에 따라 라우트로 리디렉션하고 싶은 경우 함수에서 더 복잡한 로직을 구현할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nconst routes: Routes = [\n{ path: \"first-component\", component: FirstComponent },\n{\npath: \"old-user-page\",\nredirectTo: ({ queryParams }) =\u003e {\nconst errorHandler = inject(ErrorHandler);\nconst userIdParam = queryParams['userId'];\nif (userIdParam !== undefined) {\nreturn `/user/${userIdParam}`;\n} else {\nerrorHandler.handleError(new Error('Attempted navigation to user page without user ID.'));\nreturn `/not-found`;\n}\n},\n},\n{ path: \"user/:userId\", component: OtherComponent },\n];\n\n\n### TypeScript 5.4\n\n마지막으로 TypeScript의 종속성이 업데이트되어 최신 TypeScript 5.4 기능을 모두 활용할 수 있게 되었습니다!\n\n### 커뮤니티 하이라이트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러에서 일어나는 혁신은 커뮤니티에서 많은 발전을 보게 되었어요!\n\nngrx, ngxs, rxAngular와 같은 인기 있는 상태 관리 라이브러리들은 이미 앵귤러 신호를 채택하고 컴포넌트에서 세밀한 반응성을 활성화하고 있어요.\n\n두 달 전에 앵귤러 GDE인 Brandon Roberts는 Analog.js 버전 1.0을 발표했어요. 이는 앵귤러를 위한 커뮤니티 주도의 메타 프레임워크로, 파일 기반 라우팅, API 라우트, 일급 마크다운 지원 등의 멋진 기능을 제공해요. Analog.js 팀은 커뮤니티가 좋아하는 단일 파일 컴포넌트 형식을 실험하고 있어요!\n\n또 다른 생태계의 인기 라이브러리가 앵귤러 어댑터를 개발하고 있는 것도 흥미롭게 보여요. Chau Tran, Arnoud de Vries, 그리고 Corbin Crutchley가 TanStack Store, TanStack Query, TanStack Forms 지원을 앵귤러로 출시했어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세계 각지의 Angular 커뮤니티 컨퍼런스에 참여할 수 있어 기뻐요. 올해 남은 행사들도 기대되네요. 수백 명의 참가자와 수십 명의 연사를 대상으로 컨퍼런스를 기획하는 것은 쉬운 일이 아니에요. 올해 이 힘든 과제를 현실로 만들어준 모든 분들께 감사의 말씀을 전합니다. 이들에는 ng-conf, Angular Belgrade, ng-de, ng-be, NGPoland, ngRome, NG Kenya, ngIndia, Angular TLV 등이 포함돼요! 만약 빠뜨린 컨퍼런스가 있다면 댓글에서 공유해주세요.\n\n뿐만 아니라, v16 이후로 290명 이상의 사람들로부터 기여를 받았어요! 코드, 이슈, 컨텐츠, 커뮤니티 조직 또는 가능한 방법으로 도와준 모든 분들께 감사드립니다 🙏\n\n# 우리의 진전을 되돌아보며\n\nAngular 부흥의 일환으로 지난 2년 동안 많은 것을 선보였고 앞으로도 더 많은 혁신이 예정돼 있어요. 이 부분에서 현재를 살펴보고 어디에 있는지 축하하고 싶었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular을 신호 및 고급 혼합 렌더링 기능으로 진화시키면서, 우리는 항상 개발자들이 자신감을 가지고 웹 애플리케이션을 제공할 수 있도록 하는 우리의 미션을 충실하게 이행해왔습니다. 현재 세계에서 두 번째로 큰 웹사이트인 YouTube가 Angular의 반응성 기본 요소를 사용하고 있어, 우리는 더 큰 작업 그룹의 일부로 신호를 웹 플랫폼에 추가하기 위해 협업하고 있습니다.\n\n또한, Vite, Nx, Cypress, Puppeteer, Storybook 등의 도구 개발자들과 긴밀히 협력하여 모든 사람을 위한 개발자 경험을 향상시키고 있습니다. 동시에, Angular로 어떤 것이 가능한지 확장하는 열정적인 개발자, 커뮤니티 조직자, 저자, 연설자들로 이루어진 커뮤니티가 있어 우리는 행운이라고 생각합니다.\n\nAngular 부흥 과정에 함께해준 여러분께 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png"},"coverImage":"/assets/img/2024-06-22-Angularv18isnowavailable_0.png","tag":["Tech"],"readingTime":14},{"title":"가디언이 Deno를 사용해 270만 개 기사에서 접근성과 성능을 감사하는 방법","description":"","date":"2024-06-22 04:56","slug":"2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles","content":"\n\n\n![Image](/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png)\n\n(원래 deno.com/blog에 게시됨.)\n\n독립 매체인 가디언은 자사의 기사의 성능과 접근성을 감사하기 위한 가벼운 유지보수 솔루션이 필요했습니다. 가디언이 Deno를 핵심 인프라에서 이용하여 270만 개의 기사 전반에 걸쳐 접근성과 성능을 감사하는 방법을 알아보세요.\n\n# 과제\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가디언 웹사이트는 매달 3억 5천만 개 이상의 고유 페이지 조회수를 기록합니다. 독자들의 기대를 충족하기 위해서는 웹사이트가 성능에 최적화되어 있고 콘텐츠를 최대한 빨리 제공할 뿐만 아니라 다양한 웹 접근성 요구사항을 지원해야 합니다.\n\n대형 매체 사이트로서 각 밀리초가 중요합니다. BBC에 따르면 페이지 로딩에 추가된 1초가 사용자의 10%를 이탈시킨다고 합니다. 웹사이트의 고객 소프트웨어 엔지니어인 맥스 듀발은 \"웹사이트에 발행된 자산이 최적화되었는지를 보장하기 위한 방법이 필요했습니다\"라고 말합니다.\n\n성능 이외에도 엔지니어들은 독자들이 웹사이트에서 콘텐츠를 소비할 때 다양한 보조 기술을 사용하는 사실을 인지하고 있습니다. 자신들의 이야기가 널리 읽히도록 하려면 웹 접근성 요구사항을 준수해야 합니다. 맥스는 \"수동 감사를 통해 일부 기사에 중요 속성이 누락된 HTML 요소가 포함되어 있는 것이 밝혀졌습니다. 새로운 기사는 최상의 접근성 규칙을 준수하도록 하고 싶었으나, 이러한 불일치 사항을 대규모로 발견하는 시스템화된 자동 접근 방법이 없었습니다\"라고 말합니다.\n\n# 해결책\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팀은 접근성 및 성능 불일치를 평가하기 위한 자동화 시스템을 구축해야 한다는 것을 알았습니다. 먼저 Node를 시도했지만 복잡성 문제에 직면했습니다. Max는 \"페이지를 다운로드하고 살펴보는 것과 같이 간단한 작업에 Node를 사용하는 것은 매우 복잡했다\"고 말합니다. \"GET 요청 수행, URL 구문 분석, 리다이렉션 해결은 모두 라이브러리를 평가하고 설치하는 것이 필요했습니다.\" 그러나 웹 표준 API를 네이티브로 지원하는 Deno를 사용하면 동일한 스크립트가 훨씬 간단해집니다. Max는 \"Deno에는 의존성 부풀림 위험이 없으므로 Node 및 npm에서 발생하는 문제가 없습니다.\"\n\n또한 Deno를 사용해 네이티브 TypeScript 지원을 즐겼습니다. Max는 \"가디언은 서버 코드의 대부분을 전통적으로 스칼라로 사용해왔는데 강한 유형화가 되어 있습니다. TypeScript는 꾸준히 인기를 얻고 있지만 번들되지 않은 애플리케이션에 사용하기 어려웠습니다. 설정 없이 TypeScript를 작성하고 실행할 수 있는 것은 우리 팀이 빠르게 움직이는 데 도움이 되었습니다,\"라고 말합니다.\n\n자동화된 시스템은 GitHub Actions에서 매일 Deno 스크립트를 실행하여 누락된 HTML 속성 및 이미지, 폰트, 기타 미디어와 같은 에셋 크기를 확인하여 접근성 및 성능을 평가합니다. 작업에 의해 나타난 어떤 차이점이라도 팀이 조사할 수 있도록 GitHub 이슈를 업데이트합니다.\n\n\"우리의 이야기들이 가능한 많은 독자들에 의해 소비될 수 있도록 하는 것에 도움이 되도록 기반을 설치하는 것이 우리에게 쉬웠다,\"고 Max는 말합니다.","ogImage":{"url":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png"},"coverImage":"/assets/img/2024-06-22-HowtheGuardianusesDenotoauditaccessibilityandperformanceacrosstheir27millionarticles_0.png","tag":["Tech"],"readingTime":2},{"title":"프로처럼 React 컴포넌트 작성하는 방법","description":"","date":"2024-06-22 04:55","slug":"2024-06-22-WriteaReactComponentLikeaPro","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png\" /\u003e\n\n리액트 세계에서 컴포넌트를 작성하는 것은 예술입니다. 그것은 단순히 작동하게 만드는 것이 아니라, 잘 작동하게 만드는 것이 중요합니다. 오늘은 프로처럼 컴포넌트를 만드는 방법을 살펴보겠습니다. 가독성, 재사용성, 효율성에 초점을 맞춰.\n\n## 리스트 컴포넌트 만들기\n\n우리가 기본 리스트 컴포넌트부터 시작해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/components/List.js\nimport React from 'react';\n\nconst List = ({ data }) =\u003e {\n  return (\n    \u003cul\u003e\n      {data.map((item, index) =\u003e (\n        \u003cli key={index}\u003e{item}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\n\nexport default List;\n```\n\n이 컴포넌트는 데이터 배열을 가져와서 목록으로 렌더링합니다.\n\n## HOC로 컴포넌트 향상하기\n\n고차 컴포넌트(Higher-Order Components, HOC)는 컴포넌트 로직을 재사용하는 강력한 패턴입니다. 기본적으로 컴포넌트를 감싸서 구조를 변경하지 않고 기능을 확장합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, withLoading HOC를 사용하면 로딩 상태를 표시할 수 있습니다:\n\n```js\n// src/hocs/withLoading.js\nimport React, { useState } from 'react';\n\nfunction withLoading(Component) {\n  return function WithLoading({ isLoading, ...props }) {\n    if (isLoading) {\n      return \u003cdiv\u003eLoading...\u003c/div\u003e;\n    }\n    return \u003cComponent {...props} /\u003e;\n  };\n}\n\nexport default withLoading;\n```\n\n이 HOC는 isLoading 속성을 확인합니다. 만약 true이면 \"로딩 중...\" 메시지를 렌더링합니다. 그렇지 않으면 래핑된 컴포넌트를 렌더링하여 데이터 가져오는 동안 사용자 경험이 연속적이게 됩니다.\n\n비슷하게, withErrorHandling은 에러 상태를 관리하는 다른 HOC입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/hocs/withErrorHandling.js\nimport React from 'react';\n\nfunction withErrorHandling(Component) {\n  return function WithErrorHandling({ error, ...props }) {\n    if (error) {\n      return \u003cdiv\u003eError: {error.message}\u003c/div\u003e;\n    }\n    return \u003cComponent {...props} /\u003e;\n  };\n}\n\nexport default withErrorHandling;\n```\n\n에러가 발생하면 withErrorHandling이 에러 메시지를 표시합니다. 그렇지 않으면 컴포넌트를 일반적으로 렌더링합니다. 이 HOC는 특히 fetch 오류를 처리하거나 컴포넌트 라이프사이클 내에서 발생하는 문제를 처리하기에 유용합니다.\n\nwithLoading과 withErrorHandling을 결합하여, 로딩 및 에러 상태를 우아하게 처리하는 견고한 컴포넌트를 만들 수 있습니다. 이 접근 방식은 코드 재사용과 관심사 분리를 촉진하여 컴포넌트를 더 쉽게 유지하고 이해하기 쉽게 만듭니다.\n\n## 훅을 사용하여 데이터 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 훅을 사용하면 클래스를 작성하지 않고도 상태 및 기타 리액트 기능을 사용할 수 있습니다. useFetch는 API에서 데이터를 가져오는 커스텀 훅입니다:\n\n```js\n// src/hooks/useFetch.js\nimport { useState, useEffect } from 'react';\n\nconst useFetch = (url) =\u003e {\n  const [data, setData] = useState([]);\n  const [isLoading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() =\u003e {\n    const fetchData = async () =\u003e {\n      setLoading(true);\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        const json = await response.json();\n        setData(json);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () =\u003e {\n      // Cleanup logic if needed\n    };\n  }, [url]);\n\n  return { data, isLoading, error };\n};\n\nexport default useFetch;\n```\n\n이 훅은 데이터 가져오기 상태, 데이터 저장 및 오류 처리를 처리하여 컴포넌트에서 데이터를 쉽게 가져와 표시할 수 있습니다.\n\n## 앱 조립하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, App 컴포넌트에서 모든 것을 하나로 통합합니다:\n\n```js\n// src/App.js\nimport React from 'react';\nimport withLoading from './hocs/withLoading';\nimport withErrorHandling from './hocs/withErrorHandling'; // 새로운 HOC 추가\nimport useFetch from './hooks/useFetch';\nimport List from './components/List';\n\nconst ListWithLoading = withLoading(List);\nconst ListWithErrorHandling = withErrorHandling(ListWithLoading); // ListWithLoading 컴포넌트에 에러 처리 추가\n\nconst App = () =\u003e {\n  const { data, isLoading, error } = useFetch('https://api.example.com/data');\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eList Component\u003c/h1\u003e\n      \u003cListWithErrorHandling data={data} isLoading={isLoading} error={error} /\u003e {/* 에러가 발생하면 ListWithLoading 컴포넌트로 전달됩니다 */}\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\nuseFetch 훅을 사용하여 데이터를 로드하고 HOC를 통해 로딩 및 에러 처리 기능이 추가된 List 컴포넌트에 전달합니다.\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로처럼 컴포넌트를 작성하려면 더 큰 그림을 고려하는 것이 중요합니다. 읽기 쉽고 유지보수 및 재사용이 용이한 컴포넌트를 만드는 것이죠. HOCs와 훅과 같은 패턴을 사용하여 시간이 지나도 유지보수가 용이하고 효율적인 코드베이스를 만들 수 있습니다.\n\n코딩을 즐기세요!\n\n# 평문으로 쓴 것 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 나가시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 박수로 응원하고 팔로우 해 주세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png"},"coverImage":"/assets/img/2024-06-22-WriteaReactComponentLikeaPro_0.png","tag":["Tech"],"readingTime":5},{"title":"오늘 React 컴파일러를 사용해 봤는데, 결과가 ","description":"","date":"2024-06-22 04:52","slug":"2024-06-22-ItriedReactCompilertodayandguesswhat","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png\" /\u003e\n\n이것은 아마도 내가 만든 가장 클릭베이트 스러운 제목일 것 같아요. 그러나 요즘의 React 커뮤니티에서 가장 혹평 받는 주제 중 하나에 대한 글은 이렇게 만들어야 한다고 느껴요 😅.\n\n지난 두 년 반 동안, 리렌더링과 메모이제이션과 관련된 패턴을 언급하는 내용을 게시한 후에, 미래에서 온 방문자들이 댓글 섹션으로 내려와서 React Forget(지금은 React Compiler로 알려져 있음) 때문에 이전에 말한 내용이 더 이상 관련이 없다고 친절히 알려주곤 했어요.\n\n이제 우리의 시간표가 그들의 시간표에 따라잡혔고, React Compiler가 실험적인 기능으로 실제로 일반 대중에게 출시되었으니, 앞으로 리액트에서는 메모이제이션을 잊을 수 있는지 여부를 조사해 봐야 할 때입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 리액트 컴파일러란?\n\n하지만 먼저, 매우 간단히 말하면, 이 컴파일러는 무엇이며 어떤 문제를 해결하며 어떻게 시작할 수 있는지에 대해 알아보겠습니다.\n\n문제: 리액트에서의 다시 렌더링은 연쇄적입니다. 리액트 컴포넌트의 상태를 변경할 때마다 해당 컴포넌트의 다시 렌더링이 트리의 끝까지 도달할 때까지 해당 컴포넌트 내, 그 안에 있는 컴포넌트, 이와 같은 컴포넌트들의 컴포넌트 등이 다시 렌더링됩니다.\n\n![이미지](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 하위 다시 렌더링이 무겁거나 너무 자주 발생하면, 앱의 성능 문제를 야기할 수 있습니다.\n\n이러한 성능 문제를 해결하는 한 가지 방법은 그 다시 렌더링 체인을 방지하는 것이며, 이를 위한 한 가지 방법은 메모이제이션을 사용하는 것입니다: React.memo, useMemo, 그리고 useCallback. 보통, 우리는 React.memo로 컴포넌트를 래핑하고, 모든 프롭스를 useMemo와 useCallback으로 감싸며, 부모 컴포넌트가 다음번 다시 렌더링될 때, 메모로 래핑된 컴포넌트는 다시 렌더링되지 않습니다.\n\n그러나 이러한 도구를 올바르게 사용하는 것은 어렵습니다. 정말로 어렵습니다. 이 주제에 대해 몇 가지 기사를 작성하고 몇 개의 비디오를 제작했습니다. 만일 여러분이 지식을 시험해보고 싶다면 (How to useMemo and useCallback: you can remove most of them, Mastering memoization in React — Advanced React course, Episode 5).\n\n여기서 React 컴파일러가 등장합니다. 컴파일러는 React 코어 팀에 의해 개발된 도구입니다. 이 도구는 빌드 시스템에 통합되어 원본 컴포넌트 코드를 가져와 컴포넌트, 그 프롭스, 그리고 훅의 의존성이 기본적으로 메모이제이션되도록 코드로 변환하려고 노력합니다. 최종 결과는 모든 것을 memo, useMemo 또는 useCallback으로 감싸는 것과 유사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 단지 그것을 이해하기 위해 대략적인 것일 뿐이에요. 실제로는 훨씬 더 복잡한 변환을 합니다. Jack Herrington이 최근 비디오에서 이에 대한 좋은 개요를 제시했어요(React Compiler: In-Depth Beyond React Conf 2024), 실제 세부 내용을 알고 싶다면 보는 것을 권해드려요. 혹은, 굉장히 복잡한 것을 체감하고 싶다면 \"React Compiler Deep Dive\" 토크에서 Sathya Gunasekaran이 컴파일러를 설명하고 Mofei Zhang이 20분 동안 실시간 코딩하는 것을 보세요. 🤯\n\n만약 여러분이 직접 컴파일러를 시도해 보고 싶다면, 문서를 따라가보세요: https://react.dev/learn/react-compiler. 이미 충분히 잘 작성되어 있고 필요한 모든 내용과 어떻게 해야 하는지 담겨 있어요. 기억하세요: 이것은 아직 실험 단계인 것으로, React의 캐너리 버전을 설치하는 것을 기반으로 하고 있으니 조심하세요.\n\n준비는 여기까지에요. 이제 이것이 무엇을 할 수 있는지 그리고 실제로 어떻게 작동하는지 살펴봐 볼까요?\n\n# 컴파일러 시도하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저에게 이 기사의 주요 목적은 컴파일러에 대한 우리의 기대가 현실과 일치하는지 조사하는 것이었습니다. 현재의 약속은 무엇인가요?\n\n- 컴파일러는 플러그 앤 플레이입니다: 설치하고 그냥 작동합니다. 기존 코드를 다시 작성할 필요가 없습니다.\n- React.memo, useMemo 및 useCallback에 대해 설치한 후에는 다시 생각할 필요가 없습니다: 필요가 없을 것입니다.\n\n이러한 가정을 테스트하기 위해 제가 몇 가지 간단한 예제를 독립적으로 컴파일러를 테스트하는 데 구현하고, 그런 다음 사용 가능한 세 가지 다른 앱에서 실행했습니다.\n\n## 단순 예제: 독립적으로 컴파일러 테스트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 예제의 전체 코드는 여기에서 확인할 수 있습니다: https://github.com/developerway/react-compiler-test\n\n컴파일러를 처음부터 시작하는 가장 쉬운 방법은 Next.js의 캐너리 버전을 설치하는 것입니다. 기본적으로 이 작업은 필요한 모든 것을 제공할 것입니다:\n\n```js\nnpm install next@canary babel-plugin-react-compiler\n```\n\n그런 다음, next.config.js에서 컴파일러를 켤 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst nextConfig = {\n  experimental: {\n    reactCompiler: true,\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n그리고 와라! React Dev Tools 에서 자동으로 메모이제이션된 컴포넌트를 즉시 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_2.png\" /\u003e\n\n지금까지의 가정이 맞았습니다: 설치는 매우 간단하고 그냥 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 작성을 시작해봅시다. 컴파일러가 어떻게 처리하는지 확인해 봅시다.\n\n## 첫 번째 예시: 간단한 상태 변경.\n\n```js\nconst SimpleCase1 = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setIsOpen(!isOpen)}\u003e\n        다이얼로그 전환\n      \u003c/button\u003e\n      {isOpen \u0026\u0026 \u003cDialog /\u003e}\n      \u003cVerySlowComponent /\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n우리는 modal dialog가 열려 있는지 여부를 제어하는 isOpen 상태 변수를 가지고 있으며, 동일한 컴포넌트에서 렌더링된 VerySlowComponent가 있습니다. 일반 React 동작은 isOpen 상태가 변경될 때마다 VerySlowComponent를 다시 렌더링하므로, dialog가 지연되어 팝업하는 것을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 이러한 상황을 메모이제이션을 사용하여 해결하려면 (물론 다른 방법도 있지만), React.memo로 VerySlowComponent를 감싸야 합니다:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nconst SimpleCase1 = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    \u003c\u003e\n      ...\n      \u003cVerySlowComponentMemo /\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n컴파일러를 사용하면 순수한 마법입니다: React.memo를 제거해도 개발 도구에서 VerySlowComponent가 메모이제이션되어 있고 딜레이가 사라지며, VerySlowComponent 내부에 console.log를 넣으면 상태 변경시 다시 렌더링되지 않음을 확인할 수 있습니다.\n\n[이 예제의 전체 코드는 여기에서 확인할 수 있습니다.](링크)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 두 번째 예시: 느린 컴포넌트의 속성(props).\n\n지금까지는 잘 진행되었지만, 이전 예시는 가장 간단한 것이었습니다. 조금 더 복잡하게 만들어서 등식에 props을 소개해 봅시다.\n\n아주 느린 컴포넌트인 VerySlowComponent가 함수를 기대하는 onSubmit prop과 배열을 수용하는 data prop을 가지고 있다고 가정해 봅시다:\n\n```js\nconst SimpleCase2 = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const onSubmit = () =\u003e {};\n  const data = [{ id: 'bla' }];\n\n  return (\n    \u003c\u003e\n      ...\n      \u003cVerySlowComponent onSubmit={onSubmit} data={data} /\u003e\n    \u003c/\u003e\n  );\n};\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 수동 메모이제이션의 경우에는 React.memo로 VerySlowComponent를 감싸는 것 외에도 배열을 useMemo로 감싸고 (어떤 이유로 이를 바깥쪽으로 옮기지 못한다는 것을 가정해 봅시다) onSubmit을 useCallback으로 감싸야 합니다:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nexport const SimpleCase2Memo = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // 여기에 메모이제이션\n  const onSubmit = useCallback(() =\u003e {}, []);\n\n  // 여기에 메모이제이션\n  const data = useMemo(() =\u003e [{ id: 'bla' }], []);\n\n  return (\n    \u003cdiv\u003e\n      ...\n      \u003cVerySlowComponentMemo\n        onSubmit={onSubmit}\n        data={data}\n      /\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n그러나 Compiler를 사용하는 경우에는 그렇게 할 필요가 없습니다! VerySlowComponent는 여전히 React 개발 도구에서 메모이제이션된 상태로 표시되며, 그 안에 있는 \"control\" console.log가 여전히 실행되지 않습니다.\n\n이 저장소에서 이러한 예제를 로컬에서 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 세 번째 예시: 자식 요소로 요소들.\n\n알겠어요, 세 번째 예시입니다. 실제 앱을 테스트하기 전에 처리할 내용입니다. 거의 아무도 제대로 메모이즈를 할 수 없는 경우는 어떻게 할까요? 만약 우리의 느린 컴포넌트가 자식 요소를 받는다면 어떨까요?\n\n```js\nexport const SimpleCase3 = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    \u003c\u003e\n      ...\n      \u003cVerySlowComponent\u003e\n        \u003cSomeOtherComponent /\u003e\n      \u003c/VerySlowComponent\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n머릿속으로 바로 VerySlowComponent를 올바르게 메모이즈하는 방법을 기억할 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 사람들은 VerySlowComponent와 SomeOtherComponent를 모두 React.memo로 감싸야 한다고 생각할 것입니다. 하지만 이것은 틀렸어요. 우리는 대신에 `SomeOtherComponent /` 요소를 useMemo로 감싸야 합니다. 아래처럼요:\n\n```js\nconst VerySlowComponentMemo = React.memo(VerySlowComponent);\n\nexport const SimpleCase3 = () =\u003e {\n  const [isOpen, setIsOpen] = useState(false);\n\n  // React.memo 대신 useMemo를 사용하여 자식 요소 메모이제이션\n  const child = useMemo(() =\u003e \u003cSomeOtherComponent /\u003e, []);\n\n  return (\n    \u003c\u003e\n      ...\n      \u003cVerySlowComponentMemo\u003e{child}\u003c/VerySlowComponentMemo\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n만약 왜 이렇게 하는지 확신이 들지 않는다면, 이 비디오를 시청해보세요. 이 비디오에서 메모이제이션에 대해 자세히 설명하고, 이 패턴도 다루고 있어요: Mastering memoization in React — Advanced React course, Episode 5. 또한 이 글도 유용할 것입니다: The mystery of React Element, children, parents and re-renders\n\n다행히 React 컴파일러는 여기서도 마법을 부릅니다 ✨! 모든 것이 메모이제이션되어, 매우 느린 컴포넌트는 다시 렌더링되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번의 시도 가운데 세 번 모두 성공하셨네요, 인상적입니다! 하지만 그 예시들은 매우 간단했죠. 현실에서는 쉬운 것이 그렇게 많지 않죠? 이제 진짜 도전을 해보겠습니다.\n\n# 실제 코드에서 컴파일러 테스트하기\n\n컴파일러에 진짜 도전을 주기 위해, 저는 제가 가지고 있는 세 개의 코드베이스에서 테스트를 진행했습니다.\n\n- 앱 하나: 몇 년 전에 만들어진 상당히 큰 React, React Router \u0026 Webpack 기반 앱으로, 여러 사람이 작성한 코드입니다.\n- 앱 둘: 조금 더 최근에 만들어진데도 여전히 상당히 큰 React \u0026 Next.js 앱으로, 여러 사람이 작성한 코드입니다.\n- 앱 셋: 제 개인 프로젝트로, 매우 최근에 시작했고, 최신 Next.js를 사용하며, 아주 작습니다 — 몇 개의 CRUD 작업을 수행하는 화면이 몇 개 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 앱에 대해 다음을 수행했습니다:\n\n- 초기 건강 점검을 통해 컴파일러를 위한 앱의 준비 상태를 확인했습니다.\n- Compiler의 eslint 규칙을 활성화하고 전체 코드베이스에서 실행했습니다.\n- React 버전을 19 canary로 업데이트했습니다.\n- 컴파일러를 설치했습니다.\n- 컴파일러를 켜기 전에 불필요한 다시 렌더링의 몇 가지 명백한 경우를 식별했습니다.\n- 컴파일러를 켜고 해당 불필요한 다시 렌더링이 해결되었는지 확인했습니다.\n\n## App One에서 Compiler를 테스트한 결과\n\n이 앱은 아마도 React 부분의 전체 코드의 약 15만 줄 정도일 것으로 예상됩니다. 이 앱에는 10 개의 명확한 불필요한 다시 렌더링 사례를 식별했습니다. 그 중 일부는 전체 헤더 구성 요소를 전체 다시 렌더링하는 것과 같이 매우 사소한 것이었습니다. 또 다른 것은 입력 필드에 타이핑할 때 전체 페이지를 다시 렌더링하는 것과 같이 좀 더 큰 사례였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 초기 건강 진단: 구성 요소의 97.7%가 컴파일될 수 있었습니다! 호환되지 않는 라이브러리는 없습니다.\n- Eslint 체크: 규칙 위반이 20건 발견되었습니다.\n- React 19 업데이트: 몇 가지 사소한 문제가 발생했지만 주석 처리한 후에는 앱이 잘 작동하는 것 같았습니다.\n- 컴파일러 설치: 이 과정에서 몇 가지 문제가 발생하여 ChatGPT의 도움이 필요했습니다. 오랜만에 Webpack이나 Babel과 관련된 것을 다루어 본 것이라 그런 것 같아요. 하지만 결국 성공했습니다.\n- 앱 테스트: 10가지 불필요한 재랜더링 중... 컴파일러가 해결한 것은 2가지뿐이네요 😢\n\n10가지 중 2가지만 해결된 결과는 상당히 실망스러웠습니다. 그런데 이 앱에는 아직 수정하지 않은 eslint 위반이 있습니다. 그게 그 이유일까요? 다음 앱을 살펴보겠습니다.\n\n## 두 번째 앱에서 컴파일러 테스트 결과\n\n이 앱은 훨씬 작아요, 대략 30,000줄 정도의 React 코드로 이루어져 있습니다. 여기에서도 10가지 불필요한 재랜더링을 확인했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 초기 건강 확인: 동일 결과, 97.7% 구성 요소가 컴파일될 수 있었습니다.\n- Eslint 확인: 단 하나의 규칙 위반만 발견되었어요! 🎉 완벽한 후보입니다.\n- React 19 업데이트 및 Compiler 설치: 이를 위해 Next.js를 canary 버전으로 업데이트해야 했는데, 그 외는 Next.js가 해결해주었습니다. 설치 후에는 바로 작동되었고, Webpack 기반 앱을 업데이트하는 것보다 훨씬 쉬웠어요.\n- 앱 테스트: 불필요한 재랜더링 10가지 중 2가지만 구체적으로 컴파일러에 의해 수정되었습니다 😢\n\n10가지 중 2가지 또한! 완벽한 후보겠죠… 다소 실망스럽네요. 실제 상황과 합성 “카운터” 예제의 대립입니다. 문제를 해결하기 전에 세 번째 앱을 살펴보겠습니다.\n\n## 세 번째 앱에서 Compiler 테스트: 결과\n\n이것은 모두 중에서 가장 작은 앱이며, 주말 또는 몇 주 동안 작성되었습니다. 데이터 테이블이 있는 몇 개 페이지와 테이블에서 엔티티를 추가/편집/제거할 수 있는 기능만 있어요. 앱 전체가 아주 작고 간단해서, 내가 식별한 불필요한 재랜더링이 8가지뿐이었습니다. 모든 상호작용에 대해 모든 것이 다시 렌더링되며, 어떠한 최적화 역시 하지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 컴파일러에게 재랜더링 상황을 크게 개선할 수 있는 좋은 주제네요!\n\n- 초기 건강 점검: 100%의 컴포넌트가 컴파일될 수 있습니다.\n- Eslint 점검: 어긋남이 없어요 🎉\n- 리액트 19 업데이트 \u0026 컴파일러 설치: 이전 것보다 놀랍게도 더 나빠졌어요. 사용한 몇 가지 라이브러리가 아직 리액트 19와 호환되지 않아서 경고를 무시하기 위해 종속성을 강제로 설치해야 했어요. 하지만 실제 앱과 모든 라이브러리는 여전히 작동했으므로 큰 문제는 없었어요, 아마도요.\n- 앱 테스트: 불필요한 재랜더링 8건 중에, 리액트 컴파일러가 고칠 수 있었던 것은… 덩실 덩실… 하나. 딱 하나! 🫠 이 시점에서 거의 울고 싶어진 건 이 테스트를 위해서 큰 희망을 품었었기 때문이었어요.\n\n이건 예전 냉소적인 성향이 예상했지만, 어린애 같은 내면은 기대하지 않았던 것이에요. 아마 난 리액트 코드를 잘못 작성하고 있는 걸까요? 컴파일러의 메모이제이션 결과를 조사하고, 어떻게 고칠 수 있는지 알아볼까요?\n\n# 컴파일러에 의한 메모이제이션 결과 조사\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이슈를 유용하게 디버그하기 위해 세 번째 앱의 페이지 중 하나를 별도의 저장소로 추출했습니다. 여기서 확인할 수 있습니다: (https://github.com/developerway/react-compiler-test/) 제 생각을 따라가보고 코드 실습도 해보고 싶다면 들어가보세요. 세 번째 앱의 페이지 중 하나와 거의 동일한데, 가짜 데이터와 몇 가지 제거된 부분(SSR과 같은 것)이 있어서 디버깅 경험을 간소화했습니다.\n\nUI는 매우 간단합니다. 국가 목록이 있는 테이블, 각 행마다 \"삭제\" 버튼, 그리고 테이블 아래에 있는 입력 컴포넌트로 새로운 국가를 목록에 추가할 수 있습니다.\n\n\n![테이블](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_3.png)\n\n\n코드적으로는 하나의 컴포넌트만 있는데, 상태, 쿼리 및 뮤테이션도 있습니다. 전체 코드는 여기 있습니다. 조사에 필요한 필수 정보만 있는 간소화된 버전은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const Countries = () =\u003e {\n  // input에서 입력한 내용을 저장합니다\n  const [value, setValue] = useState(\"\");\n\n  // react-query를 사용하여 국가 전체 목록을 가져옵니다\n  const { data: countries } = useQuery(...);\n\n  // react-query를 사용하여 국가를 삭제하는 뮤테이션\n  const deleteCountryMutation = useMutation(...);\n\n  // react-query를 사용하여 국가를 추가하는 뮤테이션\n  const addCountryMutation = useMutation(...);\n\n  // \"delete\" 버튼에 전달되는 콜백\n  const onDelete = (name: string) =\u003e deleteCountryMutation.mutate(name);\n\n  // \"add\" 버튼에 전달되는 콜백\n  const onAddCountry = () =\u003e {\n    addCountryMutation.mutate(value);\n    setValue(\"\");\n  };\n\n  return (\n    ...\n      {countries?.map(({ name }, index) =\u003e (\n        \u003cTableRow key={`${name.toLowerCase()}`}\u003e\n          ...\n          \u003cTableCell className=\"text-right\"\u003e\n            \u003c!-- onDelete이 여기에 있습니다 --\u003e\n            \u003cButton onClick={() =\u003e onDelete(name)} variant=\"outline\"\u003e\n              Delete\n            \u003c/Button\u003e\n          \u003c/TableCell\u003e\n        \u003c/TableRow\u003e\n      ))}\n    ...\n    \u003cInput\n      type=\"text\"\n      placeholder=\"새로운 국가 추가\"\n      value={value}\n      onChange={(e) =\u003e setValue(e.target.value)}\n    /\u003e\n    \u003cbutton onClick={onAddCountry}\u003e추가\u003c/button\u003e\n  );\n};\n```\n\n이 컴포넌트는 로컬 상태와 쿼리/뮤테이션 업데이트가 모두 있는 하나의 컴포넌트이기 때문에 모든 상호작용 시마다 다시 렌더링됩니다. 앱을 시작하면 다음과 같이 불필요한 다시 렌더링이 발생합니다:\n\n- \"새로운 국가 추가\" 입력란에 입력하는 동안 모든 것이 다시 렌더링됩니다.\n- \"삭제\"를 클릭하면 모든 것이 다시 렌더링됩니다.\n- \"추가\"를 클릭하면 모든 것이 다시 렌더링됩니다.\n\n이런 간단한 컴포넌트의 경우, 컴파일러가 이를 모두 해결해 줄 것으로 기대됩니다. 특히 React Dev Tools에서 모든 것이 메모이제이션되어 있는 것을 고려할 때요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![React Compiler](/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_4.png)\n\n하지만 \"컴포넌트 렌더링 시 업데이트 강조\" 설정을 활성화해보고 멋진 빛쇼를 즐기세요.\n\n![Light Show](https://miro.medium.com/v2/resize:fit:1076/0*XrqU0579UN-SXWgm.gif)\n\n테이블 내 모든 컴포넌트에 console.log를 추가하면 헤더 컴포넌트를 제외한 모든 것이 모든 원천에서 상태 업데이트 시 다시 렌더링됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 그러한지 조사하는 방법은 무엇인가요? 🤔\n\n리액트 개발 도구에서 추가 정보를 제공하지 않습니다. 저는 그 컴포넌트를 Compiler Playground로 복사하여 무슨 일이 일어나는지 확인할 수 있겠죠… 하지만 결과를 보세요! 😬 그건 잘못된 방향으로 나아가는 것 같고, 솔직히 말해서, 가장 할 일이 아닌 것 같아요.\n\n머릿속에 떠오르는 유일한 방법은 테이블을 점진적으로 메모화하고 컴포넌트나 종속성에 이상이 있는지 확인하는 것입니다.\n\n# 수동 메모화를 통한 조사\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 부분은 모든 수동 메모이제이션 기술이 어떻게 작동하는지 완전히 이해하는 사람을 대상으로 합니다. React.memo, useMemo 또는 useCallback에 대해 불편하게 느낀다면, 먼저 이 비디오를 시청하는 것을 추천합니다.\n\n또한, 코드를 로컬로 열고(https://github.com/developerway/react-compiler-test) 코드 연습을 해보는 것을 추천드립니다. 이렇게 하면 아래의 사고 과정을 더 쉽게 따를 수 있습니다.\n\n## 입력란에 타이핑해 보면서 렌더링을 조사하기\n\n우리는 다시 테이블을 자세히 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n\u003cTable\u003e\n  \u003cTableCaption\u003e지원되는 국가 목록.\u003c/TableCaption\u003e\n  \u003cTableHeader\u003e\n    \u003cTableRow\u003e\n      \u003cTableHead className=\"w-[400px]\"\u003e이름\u003c/TableHead\u003e\n      \u003cTableHead className=\"text-right\"\u003e동작\u003c/TableHead\u003e\n    \u003c/TableRow\u003e\n  \u003c/TableHeader\u003e\n  \u003cTableBody\u003e\n    {countries?.map(({ name }, index) =\u003e (\n      \u003cTableRow key={`${name.toLowerCase()}`}\u003e\n        \u003cTableCell className=\"font-medium\"\u003e\n          \u003cLink href={`/country/${name.toLowerCase()}`}\u003e\n            {name}\n          \u003c/Link\u003e\n        \u003c/TableCell\u003e\n        \u003cTableCell className=\"text-right\"\u003e\n          \u003cButton\n            onClick={() =\u003e onDelete(name)}\n            variant=\"outline\"\n          \u003e\n            삭제\n          \u003c/Button\u003e\n        \u003c/TableCell\u003e\n      \u003c/TableRow\u003e\n    ))}\n  \u003c/TableBody\u003e\n\u003c/Table\u003e\r\n```\n\n헤더 컴포넌트가 메모이즈되어 있어서, 컴파일러가 무슨 일을 했는지 알 수 있었습니다: 아마도 모든 컴포넌트를 React.memo와 같은 방식으로 감쌌을 것이고, TableBody 내부의 일부는 useMemo와 유사한 것으로 메모이즈되었을 것입니다. 그리고 useMemo와 비슷한 것이 그 종속성 중 하나가 모든 다시 렌더링 때마다 업데이트되어 TableBody 내의 모든 것을 다시 렌더링하도록 유도했을 거라고 생각됩니다. 최소한 테스트해볼만한 가설입니다.\n\n만약 해당 내용 부분을 메모이제이션한다면 어떤 단서를 제공할 수 있을지 확인해보겠습니다:\n\n```js\r\n// TableBody의 전체 내용을 메모이즈\nconst body = useMemo(\n  () =\u003e\n    countries?.map(({ name }, index) =\u003e (\n      \u003cTableRow key={`${name.toLowerCase()}`}\u003e\n        \u003cTableCell className=\"font-medium\"\u003e\n          \u003cLink href={`/country/${name.toLowerCase()}`}\u003e\n            {name}\n          \u003c/Link\u003e\n        \u003c/TableCell\u003e\n        \u003cTableCell className=\"text-right\"\u003e\n          \u003cButton\n            onClick={() =\u003e onDelete(name)}\n            variant=\"outline\"\n          \u003e\n            삭제\n          \u003c/Button\u003e\n        \u003c/TableCell\u003e\n      \u003c/TableRow\u003e\n    )),\n  // 이 부분은 그 코드 덩어리에서 사용되는 종속성들입니다.\n  // eslint를 감사하게 생각합니다!\n  [countries, onDelete],\n);\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 전체 부분이 데이터의 countries 배열과 onDelete 콜백에 의존함을 명확히 알 수 있습니다. countries 배열은 쿼리에서 가져오기 때문에 매번 다시 렌더링될 수 없습니다. 이를 캐싱하는 것이 라이브러리의 주요 책임 중 하나입니다.\n\nonDelete 콜백은 다음과 같이 생겼습니다:\n\n```js\nconst onDelete = (name: string) =\u003e {\n  deleteCountryMutation.mutate(name);\n};\n```\n\n이것이 의존성으로 들어가려면 memoized 되어야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nconst onDelete = useCallback(\n  (name: string) =\u003e {\n    deleteCountryMutation.mutate(name);\n  },\n  [deleteCountryMutation],\n);\r\n```\n\n그리고 deleteCountryMutation은 다시 react-query의 뮤테이션입니다, 그러니까 괜찮습니다:\n\n```js\r\nconst deleteCountryMutation = useMutation({...});\r\n```\n\n마지막 단계는 TableBody를 메모이즈하고 메모이즈된 자식을 렌더링하는 것입니다. 모든 것이 올바르게 메모이즈되었다면, 입력란에 타이핑할 때 행과 셀의 재렌더링이 멈추어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst TableBodyMemo = React.memo(TableBody);\n\n// Countries 내부에서 이것을 렌더링하세요\n\u003cTableBodyMemo\u003e{body}\u003c/TableBodyMemo\u003e;\n```\n\n그리고 안 됐네요 🤦🏻‍♀️ 이제 좀 진전이 있네요 — 의존성에서 무언가를 엉망으로 만들어놨나 봅니다, 아마 컴파일러도 똑같이 한게겠죠. 그런데 무엇이 문제일까요? 국가들 이외에 제가 가진 유일한 의존성은 deleteCountryMutation 이에요. 그것을 사용하는 게 안전하다고 가정했는데, 정말일까요? 실체가 무엇인지 알아야겠네요. 다행히 소스 코드를 확인할 수 있어요. useMutation 은 많은 일을 하는 후크로서 다음을 반환합니다:\n\n```js\nconst mutate = React.useCallback(...);\n\nreturn { ...result, mutate, mutateAsync: result.mutate };\n```\n\n반환값은 memoized되지 않은 객체야요!! 단순히 의존성으로 사용할 수 있다고 가정했던 것이 잘못된 판단이었네요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmutate 함수 자체가 기억화(memoized)되어 있습니다. 이론상으로는, 의존성에 전달하는 것만으로 충분할 것 같아요:\n\n```js\n// 반환된 객체에서 mutate 추출하기\nconst { mutate: deleteCountry } = useMutation(...);\n\n// 의존성으로 전달하기\nconst onDelete = useCallback(\n  (name: string) =\u003e {\n    // 여기서 바로 사용\n    deleteCountry(name);\n  },\n  // 안녕, memoized 의존성\n  [deleteCountry],\n);\n```\n\n위 단계를 거치면, 우리의 수동 메모화가 최종적으로 작동합니다.\n\n이제 이 단계를 거치면, 이론상으로 모든 수동 메모화를 제거하고 mutate 수정만 남기면, React 컴파일러가 이를 인식할 수 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정말 그렇죠! 이제 텍스트를 입력할 때 테이블 행과 셀이 더 이상 다시 렌더링되지 않네요 🎉\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/0*6EAVCBR4lWCY3mQE.gif\" /\u003e\n\n하지만 \"추가\" 및 \"삭제\"를 할 때 재렌더링이 여전히 발생합니다. 이 부분도 수정해봐요.\n\n## \"추가\" 및 \"삭제\" 재렌더링 조사하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그는 다음과 같이 Markdown 형식으로 변경해보겠습니다.\n\n\n| TableBody |\n| --- |\n| {countries?.map(({ name }, index) =\u003e ( |\n|   | \u003cTableRow key={index}\u003e |\n|   |   \u003cTableCell className=\"font-medium\"\u003e |\n|   |     \u003cLink href={`/country/${name.toLowerCase()}`}\u003e |\n|   |       {name} |\n|   |     \u003c/Link\u003e |\n|   |   \u003c/TableCell\u003e |\n|   |   \u003cTableCell className=\"text-right\"\u003e |\n|   |     \u003cButton |\n|   |       onClick={() =\u003e onDelete(name)} |\n|   |       variant=\"outline\"|\n|   |     \u003e |\n|   |       Delete |\n|   |     \u003c/Button\u003e |\n|   |   \u003c/TableCell\u003e |\n|   \u003c/TableRow\u003e |\n| ))} |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, \"key\" 속성을 배열의 위치가 아니라 국가와 일치하도록 확인하세요. 인덱스는 사용하지 마세요. 목록의 처음에서 국가를 제거하면 아래의 모든 행의 인덱스가 변경되어 메모이제이션이 강제로 다시 렌더링되게 됩니다. 실제로는 각 국가를 위한 어떤 종류의 ID를 도입해야 할 것입니다. 우리 간소화된 경우에서는 이름을 사용하고 중복 이름을 추가하지 않도록 해야 합니다. 키는 고유해야 합니다.\n\n```js\n{\n  countries?.map(({ name }) =\u003e (\n    \u003cTableRow key={name}\u003e...\u003c/TableRow\u003e\n  ));\n}\n```\n\n둘째, TableRow를 React.memo로 래핑하세요. 쉽죠.\n\n```js\nconst TableRowMemo = React.memo(TableRow);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTableRow의 자식 요소를 useMemo로 메모이제이션하세요:\n\n```js\n{\n  countries?.map(({ name }) =\u003e (\n    \u003cTableRow key={name}\u003e\n      ... // 여기 안의 모든 것을 useMemo로 메모이제이션해야 합니다\n      with useMemo\n    \u003c/TableRow\u003e\n  ));\n}\n```\n\n렌더 함수 내부에 있기 때문에 불가능합니다: 훅은 컴포넌트의 맨 위에서 render 함수 외부에서만 사용할 수 있습니다.\n\n이를 해결하기 위해 TableRow 전체 내용을 컴포넌트로 추출해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst CountryRow = ({ name, onDelete }) =\u003e {\n  return (\n    \u003cTableRow\u003e\n      \u003cTableCell className=\"font-medium\"\u003e\n        \u003cLink href={`/country/${name.toLowerCase()}`}\u003e\n          {name}\n        \u003c/Link\u003e\n      \u003c/TableCell\u003e\n      \u003cTableCell className=\"text-right\"\u003e\n        \u003cButton\n          onClick={() =\u003e onDelete(name)}\n          variant=\"outline\"\n        \u003e\n          Delete\n        \u003c/Button\u003e\n      \u003c/TableCell\u003e\n    \u003c/TableRow\u003e\n  );\n};\n```\n\n다음과 같이 props를 통해 데이터를 전달해주세요:\n\n```js\n\u003cTableBody\u003e\n  {countries?.map(({ name }) =\u003e (\n    \u003cCountryRow\n      name={name}\n      onDelete={onDelete}\n      key={name}\n    /\u003e\n  ))}\n\u003c/TableBody\u003e\n```\n\n그리고 CountryRow를 React.memo로 감싸주세요. onDelete은 이미 메모이제이션되어 있습니다 - 우리가 이미 수정했어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매뉴얼 메모이제이션을 구현할 필요가 없었어요. 그 행들을 컴포넌트로 추출하기만 하자마자 컴파일러가 즉시 이를 감지하여 다시 렌더링이 멈춰버렸어요 🎉. 인간 대 기계 전투에서 2 대 0!\n\n재미있게도, 컴파일러는 CountryRow 컴포넌트 내부의 모든 것을 감지할 수 있지만 컴포넌트 자체는 감지하지 못해요. 매뉴얼 메모이제이션을 제거하지만 키와 CountryRow 변경은 유지하면, 셀과 행은 추가/삭제 시 더 이상 다시 렌더링되지 않지만 CountryRow 컴포넌트 자체는 여전히 다시 렌더링돼요.\n\n이 시점에서는 컴파일러로 이 문제를 해결할 아이디어가 부족하고, 이미 충분한 자료가 되었으니 그냥 다시 렌더링하도록 할게요. 내부의 모든 것은 메모이제이션되어 있으니 큰 문제는 아니에요.\n\n# 그럼 판단은 뭘까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일러는 간단한 경우와 구성 요소에서 놀라운 성능을 보여줍니다. 3번 시도 중 3번 모두 맞았어요! 하지만 현실은 조금 더 복잡해요.\n\n제가 시도한 3개 앱 모두에서 컴파일러가 불필요한 다시 렌더링 여부를 판단한 8-10개의 경우 중 1-2개만 고칠 수 있었어요.\n\n하지만 추론력과 짐작으로 결과를 개선할 수 있을 것으로 보이며, 코드를 약간 수정함으로써 가능합니다. 하지만 이를 조사하는 것은 매우 어렵고 창의적인 사고와 React 알고리즘 및 기존 메모이제이션 기술에 대한 숙련이 요구돼요.\n\n컴파일러의 동작을 개선하기 위해 기존 코드를 수정해야 했던 변경 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- useMutation 훅의 반환 값에서 mutate를 추출하여 코드에 직접 사용하십시오.\n- TableRow 및 내부 모든 것을 분리된 컴포넌트로 추출하십시오.\n- \"key\"를 index에서 name으로 변경하십시오.\n\n코드 변화를 확인하고 앱을 직접 체험해보세요.\n\n제가 조사한 가정에 대해:\n\n그냥 작동합니까? 기술적으로, 네. 그냥 켜놓기만 하면 깨진 것 같지 않습니다. 그러나 React Dev Tools에서 메모이즈된 것처럼 보이지만 모든 것을 올바르게 메모이즈하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일러를 설치한 후 메모, useMemo, useCallback을 잊어버릴 수 있을까요? 절대 그렇지 않아요! 적어도 현재 상태에서는 아닌 것 같아요. 실제로, 지금보다 더 잘 알아야 할 필요성이 있고, 컴파일러에 최적화된 컴포넌트를 작성할 수 있는 감각을 키워나가야 해요. 또는 디버그할 때 다시 렌더링을 고치려는 상황에서 사용할 수 있어요.\n\n물론, 그것들을 고치려는 의지가 있다고 가정하면요. 제 생각에는 이런 일이 벌어질 거예요: 우리 모두가 제품 출시 준비가 완료된 시점에 컴파일러를 켤 거예요. 개발 도구에서 \"memo ✨\"가 보이면 우리는 안심을 느낄 거예요. 그래서 모두 다시 렌더링에 대해 여유롭게 생각하고 기능 구현에 집중할 거예요. 대부분의 다시 렌더링이 성능에 미치는 영향이 무시할 만하다는 점 때문에 아마도 아무도 그저 어려워하지 않을 거예요.\n\n실제로 다시 렌더링이 성능에 영향을 미치는 경우에는 상태를 아래로 내리거나 자식 요소나 props로 전달하거나 데이터를 Context로 추출하거나 분할된 공급자로 이동시키는 합성 기법과 같은 방법을 사용해 쉽게 수정할 수 있게 될 거에요. 그리고 가끔씩은 — 수동으로 React.memo와 useCallback을 사용할 거에요.\n\n미래에서 온 방문자들에 대해서는, 저는 그들이 병렬 우주에서 왔다고 확신해요. React가 유연성이 높은 JavaScript보다 구조화된 언어로 작성되었고, 컴파일러가 그런 이유로 100%의 경우를 해결하는 놀라운 곳이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원문은 https://www.developerway.com에서 확인하실 수 있어요. 해당 웹사이트에는 이와 유사한 더 많은 기사가 있습니다. 😉\n\nReact 실력을 더 향상시키기 위해 Advanced React 책을 확인해보세요.\n\n다음 기사가 게시되는 즉시 알림을 받으려면 뉴스레터를 구독하거나 LinkedIn에서 연결하거나 Twitter를 팔로우하세요.","ogImage":{"url":"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png"},"coverImage":"/assets/img/2024-06-22-ItriedReactCompilertodayandguesswhat_0.png","tag":["Tech"],"readingTime":21}],"page":"23","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"23"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>