<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/35" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/35" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내" href="/post/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법" href="/post/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들" href="/post/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular, Docker, Nginx 한 번 빌드하고 어디서든 배포하세요" href="/post/2024-06-20-AngularDockerNginxBuildonceDeployanywhere"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular, Docker, Nginx 한 번 빌드하고 어디서든 배포하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular, Docker, Nginx 한 번 빌드하고 어디서든 배포하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular, Docker, Nginx 한 번 빌드하고 어디서든 배포하세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 국제화i18n 가이드" href="/post/2024-06-20-AGuidetoInternationalizationi18ninAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 국제화i18n 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-AGuidetoInternationalizationi18ninAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 국제화i18n 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 국제화i18n 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내 Neovim 설정 React, TypeScript, Tailwind CSS 등" href="/post/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내 Neovim 설정 React, TypeScript, Tailwind CSS 등" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내 Neovim 설정 React, TypeScript, Tailwind CSS 등" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">내 Neovim 설정 React, TypeScript, Tailwind CSS 등</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 Angular 프로젝트에 ESLint 설정하기" href="/post/2024-06-20-SettingUpESLintinYourAngularProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 Angular 프로젝트에 ESLint 설정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-SettingUpESLintinYourAngularProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 Angular 프로젝트에 ESLint 설정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">당신의 Angular 프로젝트에 ESLint 설정하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앵귤러에서의 라우팅 가드" href="/post/2024-06-20-RouteGuardsinAngular"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앵귤러에서의 라우팅 가드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-RouteGuardsinAngular_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앵귤러에서의 라우팅 가드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">앵귤러에서의 라우팅 가드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아파트는 공유하지 않을 거예요" href="/post/2024-06-20-theapartmentwewontshare"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아파트는 공유하지 않을 거예요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-theapartmentwewontshare_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아파트는 공유하지 않을 거예요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">아파트는 공유하지 않을 거예요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript, Express, TypeORM, 인증, 권한 부여 및 Postgres를 활용한 REST API 구축하기" href="/post/2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript, Express, TypeORM, 인증, 권한 부여 및 Postgres를 활용한 REST API 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript, Express, TypeORM, 인증, 권한 부여 및 Postgres를 활용한 REST API 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript, Express, TypeORM, 인증, 권한 부여 및 Postgres를 활용한 REST API 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link posts_-active__YVJEi" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Nx 모노레포 애플리케이션을 도커화하는 방법 Angular과 NestJS를 사용한 단계별 안내","description":"","date":"2024-06-20 05:35","slug":"2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png\" /\u003e\n\n안녕하세요,\n저는 Medium에 처음으로 포스팅하는 중입니다 (사실 인생에서 처음이에요 😔). 요즘 작업 중이었고 다양한 시각을 검토하기 위해 이 플랫폼에서 많은 도움을 받은 소스를 스캔하는 동안 누락된 것 같다고 생각한 주제에 대해 첫 블로그를 쓰기로 결심했습니다. 수년 동안 써보고 싶었지만 시작하는 동기를 얻지 못했어요. 먼저 Aziz Nal에게 지원해주시고 글을 쓰라고 격려해 준 분께 감사드립니다.\n\n이 글은 Angular, NestJS 및 이들이 사용하는 라이브러리가 포함된 NX Monorepo 프로젝트에서 각 프로젝트에 대한 Dockerfile을 작성하는 방법과 각 프로젝트를 개별 컨테이너에 배포하는 방법을 단일 Docker-Compose 파일을 사용해 살펴볼 것입니다. \n\n이 글은 터키어로도 읽을 수 있습니다. 해당 링크에서 읽어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 시작해 보죠 😄\n\n## 우리의 NX 프로젝트 만들기\n\n다음 명령어로 NX 워크스페이스를 생성해 봅시다.\n\n```js\nnpx create-nx-workspace@latest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령을 실행한 후 워크스페이스 설정을 위해 몇 가지 선택지와 입력을 요청받게 됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_1.png)\n\n여기서 우리의 주요 목적은 프로젝트를 생성하는 것이 아니기 때문에, 미리 구성된 프로젝트 설정을 위해 다음 옵션을 선택하였습니다:\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 후 설정을 계속 진행할 구성을 선택해야 해요. 제 글의 시작 부분에서도 언급했듯이, Angular 및 NestJS 애플리케이션에 대해 마지막 옵션을 선택했어요.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_3.png)\n\n마지막 단계로, 워크스페이스와 프로젝트 이름을 입력하고 Angular 프로젝트에 대한 몇 가지 설정을 선택해야 해요. 이 단계에서 'NXDockerDeployment'를 레포지토리 이름으로, 'MyApp'을 프로젝트 이름으로 지정했고, Angular 프로젝트 css 형식으로 'scss'를 선택했어요. 'NX Cloud'를 사용하고 싶지 않아서 'No' 옵션을 선택했어요.\n\n프로젝트 설정이 완료되면, 프로젝트 구조는 이렇게 보일 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_4.png)\n\n여기에는 'my-app'이라는 Angular 프로젝트, 'api'라는 NestJS 프로젝트, 그리고 함께 사용할 라이브러리 프로젝트가 있습니다.\n\nApi 및 My-app 프로젝트를 실행하고 브라우저에서 열면 다음 페이지가 표시됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작은 업데이트를 진행하겠습니다. NX의 미리 구성된 설정을 사용할 때 Angular 프로젝트를 위한 준비된 프록시 구성이 함께 제공됩니다. 이 글의 주제가 제품 환경에 맞게 프록시 구성을 조정하는 데 있지 않기 때문에 이 구성을 무시하고 나의 프로젝트에서 선호하는대로 작은 변경을 가할 것입니다.\n\n먼저, 'my-app/src/environments' 폴더 아래에 있는 'environment.ts' 파일을 열어 다음과 같이 업데이트합니다:\n\n```js\nexport const environment = {\n  production: false,\n  BACKEND_URL: 'http://localhost:3333', // 실제 백엔드 포트와 다를 경우 업데이트 해야 합니다.\n};\n```\n\n그 다음, 제품 환경으로 프로젝트를 컴파일하고 배포할 것이므로, 동일한 폴더 아래에 있는 'environment.prod.ts' 파일을 다음과 같이 업데이트합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const environment = {\n  production: true,\n  BACKEND_URL: 'http://192.168.1.154:8080',\n};\n```\n\n마침내, 우리는 ‘my-app/src/app’ 폴더 아래의 ‘app.component.ts’ 파일을 열어 위에서 업데이트한 주소에 따라 api 프로젝트로 요청을 보낼 수 있도록 다음과 같이 업데이트합니다:\n\n```js\nimport { environment } from './../environments/environment';\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Message } from '@nxdocker-deployment/api-interfaces';\n```\n\n```js\n@Component({\n  selector: 'nxdocker-deployment-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\nexport class AppComponent {\n  hello$ = this.http.get\u003cMessage\u003e(`${environment.BACKEND_URL}/hello`);\n  constructor(private http: HttpClient) {}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 업데이트를 한 후에도, 애플리케이션을 실행하고 브라우저에서 열면 이전과 같은 화면을 볼 수 있을 거에요.\n\n\u003cimg src=\"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_6.png\" /\u003e\n\n프론트엔드 작업을 완료한 후에는, API 프로젝트에서 CORS를 구성해야하는데, 이렇게 함으로써 배포 후에 문제가 없도록 할 수 있어요.\n\n'api/src' 폴더 아래의 'main.ts' 파일을 열어서, \"app.enableCors()\"라인을 추가하여 CORS를 활성화해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Logger } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\n```\n\n```js\nimport { AppModule } from './app/app.module';\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const globalPrefix = 'api';\n  app.setGlobalPrefix(globalPrefix);\n  app.enableCors();\n  const port = process.env.PORT || 3333;\n  await app.listen(port);\n  Logger.log(\n    `🚀 Application is running on: http://localhost:${port}/${globalPrefix}`\n  );\n}\nbootstrap();\n```\n\n결과적으로, 프로젝트 배포를 위해 준비가 끝났습니다. 이제 두 번째 과정으로 넘어가서 'Dockerfile' 파일을 작성하는 것부터 시작하여 프로젝트를 배포할 준비를 완료할 수 있습니다.\n\n## Dockerfile 파일 작성하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 내 앱 Angular 프로젝트를 위한 Dockerfile\n\n저희 프론트엔드 프로젝트용 Dockerfile을 작성하는 것으로 시작해보겠습니다. 이를 위해 저희 프로젝트 내 apps/my-app 폴더 아래에 Dockerfile이란 이름의 파일을 생성하고 아래의 코드를 복사해 넣습니다.\n\n```js\nFROM node:16.13.0-alpine AS builder\n```\n\n```js\nWORKDIR /app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ \u0026\u0026 rm -rf /var/cache/apk/*\nRUN npm install\nCOPY . .\nRUN npx nx build my-app --prod\nFROM nginx:stable-alpine\nWORKDIR /usr/share/nginx/html\nRUN rm -rf ./*\nCOPY --from=builder /app/dist/apps/my-app ./\nRUN sed -i '10i \\\\ttry_files $uri $uri/ /index.html;' /etc/nginx/conf.d/default.conf\nENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"]\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 함께 한 작업을 다시 한 번 살펴봐요.\n먼저, Angular 프로젝트인 my-app에 대해 두 단계 배포를 진행하고 있어요. 첫 번째 단계에서는 프로젝트의 종속성을 설치하는 작업을 수행하고 빌드할 수 있는 node 이미지에서 프로젝트를 실행하고 빌드해요. 그리고 프로젝트를 컴파일하고 제품용으로 사용할 파일들을 생성해요. 두 번째 단계에서는 웹 서버에서 빌드 프로세스를 완료하고 컴파일된 프로젝트 파일을 게시할 수 있도록 필요한 조정을 완료해요. 저는 여기서 SPA (싱글 페이지 애플리케이션) 애플리케이션에서 흔히 사용되는 설정을 가진 nginx를 선호하고 설정했어요. 지금까지 우리가 한 작업을 대략적으로 살펴보았으니, 코드를 한 줄씩 자세히 살펴보려는 나와 같은 세부 사항에 관심 있는 친구들을 위해 코드를 살펴봐요.\n\n- 우리는 작업을 수행하기 위해 Node가 설치된 node-alpine 배포본을 사용할 것을 명시하고 AS를 사용하여 'builder' 이미지로 이름을 지정해요.\n- 다음 단계에서 사용할 /app 폴더를 작업 디렉토리로 지정해요.\n- 프로젝트에서 필요한 패키지를 포함한 package.json 및 package-lock.json 파일들을 프로젝트에서 이 디렉토리로 복사해요.\n- 성공적인 배포를 위해 필요한 종속성을 설치해요.\n참고: 사용하는 배포본에 따라 이 단계가 달라질 수 있고 다른 패키지 설치 요구사항이 있거나 전혀 필요하지 않을 수 있어요.\n- npm install 명령을 실행하여 앞서 복사한 패키지 파일에 따라 필요한 패키지를 설치해요.\n- 프로젝트 파일들을 작업 디렉토리로 모두 복사해요.\n- 프로덕션 환경을 위해 프로젝트를 빌드해요.\n- 다음 단계에는 nginx:stable-alpine 이미지를 사용할 것을 명시해요.\n- 작업 디렉토리를 /usr/share/nginx/html로 설정해요.\n- 작업 디렉토리와 함께 제공되는 기본 파일들을 삭제해요.\n- 첫 번째 단계에서는 'builder' 이미지 내에서 프로젝트를 컴파일한 위치에서 컴파일된 프로젝트 파일을 이 작업 디렉토리로 복사해요.\n- 싱글 페이지 애플리케이션에 필요한 nginx를 구성해요.\n- 마지막으로 nginx 서버를 시작해요. 참고: 이 설정에 따라 nginx 서버는 기본적으로 80번 포트에서 프로젝트를 게시할 거예요.\n\n2. NestJS 프로젝트용 Dockerfile\n\n이제 백엔드 프로젝트용 Dockerfile을 작성해보겠어요. 이를 위해 프로젝트의 apps/api 폴더 아래 Dockerfile이라는 파일을 만들고 다음 코드를 복사해 넣어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nFROM node:alpine AS builder\n```\n\n```js\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ \u0026\u0026 rm -rf /var/cache/apk/*\nRUN npm install --only=development --silent\nCOPY . .\nRUN npx nx build api --prod\nFROM node:alpine\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN apk add --update python3 make g++ \u0026\u0026 rm -rf /var/cache/apk/*\nRUN npm install -g pm2@latest\nRUN npm install --only=production --silent\nRUN npm install express\nCOPY --from=builder /usr/src/app/dist/apps/api ./build\nENTRYPOINT [\"pm2-runtime\", \"build/main.js\"]\n```\n\n이제 여기서 차례대로 무엇을 하는지 살펴보겠습니다.\n먼저, NestJS 프로젝트인 api에 대해 두 단계 배포를 할 것입니다. 첫 번째 단계에서는 프로젝트 종속성을 설치하고 프로젝트를 실행하고 빌드할 수 있는 노드 이미지에서 작업을 수행합니다. 그런 다음 프론트엔드 프로젝트와 마찬가지로 프로젝트를 컴파일하고 프로덕션에서 사용할 파일을 생성합니다. 두 번째 단계에서는 첫 번째 이미지에서 컴파일된 프로젝트 파일을 복사하고 프로덕션에 필요한 npm 패키지 설치를 마무리하고 빌드 프로세스를 완료합니다. 여기서 프로젝트를 시작하는 데 pm2를 사용하도록 선택했습니다. 지금까지 우리가 무엇을 할 것인지 대략적으로 논의했으므로, 이제 우리가 무엇을 하는지 단계별로 살펴보며 설명해보겠습니다.\n\n- 우리는 운영을 수행할 노드 설치가 완료된 node-alpine 배포를 사용할 것임을 지정하며 'builder'로 이미지를 명명합니다.\n- 다음 단계에서 사용할 /usr/src/app 폴더를 작업 디렉토리로 지정합니다.\n- 프로젝트에서 필요한 패키지를 포함하는 package.json 및 package-lock.json 파일을 프로젝트에서 이 디렉토리로 복사합니다.\n- 성공적으로 배포하기 위해 필요한 종속성을 설치 중입니다.\n참고: 사용하는 배포에 따라 이 단계가 다를 수 있으며 다른 패키지 설치 요구 사항이 있을 수도 있습니다. 또는 전혀 필요하지 않을 수도 있습니다.\n- 이전에 복사한 패키지 파일에 따라 필요한 패키지만 설치하도록 지정하여 npm install 명령을 실행합니다.\n- 모든 프로젝트 파일을 작업 디렉토리로 복사합니다.\n- 프로덕션 환경을 위해 프로젝트를 빌드합니다.\n- 다음 단계의 작업을 계속하기 위해 새로운 node:alpine 이미지를 사용할 것임을 지정합니다.\n- 작업 디렉토리를 /usr/src/app으로 설정합니다.\n- 어플리케이션은 백엔드 어플리케이션이므로 로컬에 필요한 npm 패키지가 설치되어야 합니다. 따라서 여기에도 패키지 파일을 복사합니다.\n- 이 이미지 내에서 성공적으로 배포하기 위해 필요한 종속성을 다시 설치합니다.\n- 우리가 프로젝트 시작에 사용할 pm2 패키지를 전역으로 설치합니다.\n- 프로젝트의 프로덕션을 위해 필요한 npm 패키지를 설치합니다.\n- 이 단계에서 express 패키지를 설치합니다. 이 패키지를 별도로 설치해야 하는 이유는 express 패키지가 설치를 위한 package.json 파일에 포함되어 있지 않기 때문입니다. 이미 프로젝트에 express를 설치한 경우 이 단계가 필요하지 않을 것입니다.\n- 첫 번째 단계에서 'builder' 이미지 내에서 프로젝트를 컴파일한 위치에서 컴파일된 프로젝트 파일을 이 작업 디렉토리의 build 폴더로 복사합니다.\n- 그런 다음 main.js 파일에서 pm2-runtime 명령을 사용하여 백엔드 서버를 시작합니다.\n참고: 이 컨테이너를 시작하면 main.ts에서 지정된 포트에서 프로젝트가 실행됩니다. 저는 이를 3333으로 설정했으므로 프로젝트는 이 포트에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 도커 Compose 파일 준비\n\n이번 단계에서는 모든 프로젝트를 한 곳에서 설정하는 방법과, 각각을 별도의 컨테이너에서 실행하는 단일 명령으로 모두 실행하는 방법을 살펴봅시다.\n\n먼저, 프로젝트와 동일한 디렉토리에 docker-compose.yml이라는 파일을 다음 내용으로 생성해 보겠습니다.\n\n![이미지](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 도커 컴포즈 파일의 내용을 채워봅시다.\n\nVSCode에서 만든 docker-compose.yml 파일을 열고 다음 코드를 복사하여 붙여넣어주세요.\n\n```js\nversion: \"3\"\n```\n\n```js\nservices:\n  backend-app:\n    container_name: backend-app\n    restart: always\n    ports:\n      - \"8080:3333\"\n    build:\n      context: ./nxdocker-deployment\n      dockerfile: ./apps/api/Dockerfile\n      \n  frontend-app:\n    container_name: frontend-app\n    restart: always\n    ports:\n      - \"8090:80\"\n    depends_on:\n      - backend-app\n    build:\n      context: ./nxdocker-deployment\n      dockerfile: ./apps/my-app/Dockerfile\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 코드를 단계별로 살펴봅시다.\n\n- version : 우리는 docker-compose 버전 3을 사용할 것임을 명시합니다.\n- services: 이 docker-compose로 시작할 모든 서비스를 나열합니다.\n- backend-app: 우리의 백엔드 애플리케이션에 이름을 부여합니다.\n- container_name: 백엔드 애플리케이션이 실행될 컨테이너의 이름을 backend-app으로 지정합니다.\n- restart: 도커 서비스가 충돌하거나 다시 시작하거나 컴퓨터가 재부팅될 때 자동으로 다시 시작하도록 항상 설정합니다.\n- ports: 컨테이너 안에서 백엔드 프로젝트가 실행되는 3333 포트를 외부에서 접근할 수 있도록 8080 포트로 노출합니다.\n- build: mono repo 아키텍처로 인해 Dockerfile이 docker-compose 파일과 같은 위치에 있지 않을 것이므로 프로젝트의 메인 디렉터리와 함께 Dockerfile 파일이 있는 위치를 지정해서 서비스가 컴파일해야 하는 곳을 명시합니다.\n- frontend-app: 우리의 프론트엔드 애플리케이션에 이름을 부여합니다.\n- container_name: 프론트엔드 애플리케이션이 실행될 컨테이너의 이름을 frontend-app으로 지정합니다.\n- restart: 도커 서비스가 충돌하거나 다시 시작하거나 컴퓨터가 재부팅될 때 자동으로 다시 시작하도록 항상 설정합니다.\n- ports: 컨테이너 안에서 nginx로 실행되는 프론트엔드 프로젝트가 실행되는 80포트를 외부에서 접근할 수 있도록 8090포트로 노출합니다.\n- build: 프로젝트의 메인 디렉터리를 지정하고 프론트엔드 프로젝트를 빌드하고 도커 이미지를 생성할 Dockerfile 파일을 찾는 경로를 지정합니다.\n\n## 프로젝트 실행\n\n이제 코드를 하나씩 따라가면서 프로젝트를 실행해봅시다. 어느새 설정에 지쳤나요? 프로젝트 끝이 보이지 않나요? 언제쯤 끝날까요? 😊\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n믿기 어렵지만, 프로젝트를 시작할 준비가 모두 마련되었어요. 필요한 것은 터미널과 그 마법 같은 명령어만 남았네요 🙂\n\n저희 docker-compose.yml 파일이 위치한 디렉토리에서 터미널 창을 열고 다음 명령어를 실행해 보세요.\n\n```js\ndocker-compose up -d\n```\n\n이 명령어를 실행하면 docker-compose 파일에 있는 모든 설정이 실행됩니다. 필요한 이미지가 다운로드되고, Dockerfile 구성에 따라 레이어가 작성되며, 인터넷 속도에 따라 작업이 완료될 거예요. 작업이 끝나면 ‘-d’ 플래그가 터미널을 제어권으로 돌려줄 거에요. 🙏\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 마법 같은 명령을 함께 실행해보고 결과를 확인해봐요!\n\n![image](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_8.png)\n\n이제 모든 노력으로 우리 프로젝트가 원할하게 실행될 거에요.\n\n바로 브라우저에서 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image1](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_9.png)\n\n우리 해냈어요! 🎉🎊🍸🍾🥂 그게 다예요.\n\n![image2](/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_10.png)\n\n## 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 첫 블로그 포스트에서는 Nrwl NX Monorepo를 사용하여 프로젝트를 개발한 후 제작한 도커파일들이 어떻게 제작되는지 쉽게 설명해보려고 노력했어요. 그리고 단일 도커 컴포즈를 준비한 후 한 번의 명령으로 발행하는 방법을 알려드렸어요. 물론 이 과정은 프로젝트의 요구사항 및 필요에 따라 다양하게 달라질 수 있고, 배포는 간단하지 않지만, 이 글이 여러분에게 조금이나마 도움이 되었으면 좋겠어요.\n\n여러분의 글에 피드백을 제공해드릴 수 있어서 기쁩니다. 모든 건설적인 비평을 환영합니다.\n\n이 첫 번째 모험을 함께해줘서 감사합니다 🙏\n\n## 참고 자료 및 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NX 문서\n- Docker 문서","ogImage":{"url":"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoDockerizeYourNxMonorepoApplicationsAStep-by-StepGuideUsingAngularandNestJS_0.png","tag":["Tech"],"readingTime":12},{"title":"새로운 버전 18로 Angular 프로젝트를 업그레이드하는 방법","description":"","date":"2024-06-20 05:33","slug":"2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18","content":"\n\nAngular은 웹 애플리케이션을 구축하기 위한 강력하고 널리 사용되는 프레임워크입니다. Angular 프로젝트를 최신 버전으로 유지하면 새로운 기능, 성능 향상, 보안 업데이트를 활용할 수 있습니다. Angular 18에는 개선 사항 및 업데이트가 여러 가지 포함되어 있어 개발 프로세스를 더욱 효율적으로 처리할 수 있습니다. 이 블로그 포스트에서는 Angular 프로젝트를 최신 버전 18로 업그레이드하는 과정을 안내해 드릴 것입니다.\n\n# Angular 18으로 업그레이드하는 단계별 안내서\n\n# 1. 현재 버전 및 의존성 확인\n\n업그레이드 프로세스를 시작하기 전에 현재 Angular 버전과 프로젝트의 의존성을 파악하는 것이 중요합니다. 이를 통해 업그레이드 단계를 효과적으로 계획할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 디렉토리를 열어주세요.\n\n현재 사용 중인 Angular 버전을 확인하려면 다음 명령어를 실행해보세요:\n\n\nng version\n\n\nAngular CLI, Angular 프레임워크 및 기타 종속성을 확인하고 메모해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. Angular CLI 및 Angular Core 업데이트\n\nAngular CLI (Command Line Interface)는 Angular 프로젝트를 관리하는 데 중요한 도구입니다. 먼저 Angular CLI를 전역적으로 업데이트하세요:\n\n- 현재 Angular CLI를 제거하기 위해 다음 명령어를 실행하세요:\n\n```bash\nnpm uninstall -g @angular/cli\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 최신 Angular CLI를 설치해보세요:\n\n\nnpm install -g @angular/cli@latest\n\n\n프로젝트의 로컬 Angular CLI를 업데이트해보세요:\n\n\nng update @angular/cli\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 Angular 코어 및 기타 관련 패키지를 업데이트해보세요:\n\nAngular 코어 및 기타 Angular 패키지 업데이트:\n\nng update @angular/core\n\n선택적인 업데이트가 있다면 Angular이 제안할 것입니다. Angular CLI에서 제공하는 지침에 따라 진행해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 제3자 종속성 다루기\n\nAngular 18과 호환되기 위해 서드파티 종속성이 업데이트되어야 할 수도 있습니다. 오래된 패키지가 있는지 확인해보세요:\n\n다음 명령어를 실행하여 오래된 패키지를 확인해보세요:\n\n```bash\nnpm outdated\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n#### 더 이상 사용되지 않는 패키지를 업데이트하세요:\n\n\nnpm update\n\n\n일부 패키지는 주요 업데이트나 호환되지 않는 변경사항이 있을 경우 수동 개입이 필요할 수 있습니다. 각 패키지의 설명서를 확인하여 특정 업데이트 지침을 확인하세요.\n\n#### 4. TypeScript 버전 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 18은 특정 TypeScript 버전이 필요할 수 있습니다. 올바른 TypeScript 버전이 설치되어 있는지 확인해 주세요:\n\n필요한 TypeScript 버전을 확인하려면 Angular 문서를 참조하세요.\n\n필요한 버전으로 TypeScript를 업데이트하세요:\n\n```bash\nnpm install typescript@`required_version`\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular 문서에 명시된 버전으로 'required_version'을 바꿔주세요.\n\n## 5. Breaking Changes와 Deprecated 사항 수정하기\n\n업데이트 후에는 해결해야 할 Breaking Changes 또는 Deprecated 사항이 있을 수 있습니다. Angular CLI는 이러한 문제를 식별하고 수정하는 데 도움이 되는 도구를 제공합니다:\n\n다음 명령어를 실행하여 잠재적인 사항을 식별하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nng lint\n\n문제를 고쳐주세요. 공식 안티 연규 및 문서를 참고하여 일반적인 호환성 문제에 대한 해결책을 확인할 수 있습니다.\n\n## 6. 애플리케이션 테스트하기\n\n업데이트를 완료한 후에는 애플리케이션을 철저히 테스트하여 모든 것이 올바르게 작동하는지 확인해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유닛 테스트를 실행하세요:\n\n\nng test\n\n\n엔드 투 엔드 테스트를 실행하세요:\n\n\nng e2e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하의 응용 프로그램의 주요 부분을 수동으로 테스트하여 모든 기능이 정상적으로 작동하는지 확인하세요.\n\n# 7. 문서와 종속성 업데이트\n\n마지막으로, 업그레이드 프로세스 중에 수행된 변경 사항을 반영하도록 내부 문서를 업데이트하세요. 또한 package.json을 업데이트하여 향후 개발자가 사용 중인 버전을 파악할 수 있도록 해주세요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 프로젝트를 최신 버전 18로 업그레이드하는 것은 어려울 수 있지만, 이러한 단계를 체계적으로 따라가면 원활한 전환을 보장할 수 있습니다. 프로젝트를 최신 상태로 유지하는 것은 새로운 기능과 개선 사항뿐만 아니라 응용 프로그램의 보안과 안정성도 유지하는 데 도움이 됩니다. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoUpgradeYourAngularProjecttotheLatestVersion18_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러와 리액트 앱에서의 마이크로프론트엔드의 까다로운 부분들","description":"","date":"2024-06-20 05:33","slug":"2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png\" /\u003e\n\n이 게시물은 Angular/React 기업 애플리케이션의 마이크로프론트엔드에 대해 깊이 파고들기 위한 연재물 중 첫 번째입니다. 이번에는 Angular에서 셸 앱에 동적 원격 컴포넌트를로드하는 방법에 대해 이야기하겠습니다.\n\n웹 개발의 급속한 변화 속에서 모듈식이고 확장 가능한 아키텍처에 대한 수요는 마이크로프론트 엔드의 등장으로 이어졌습니다. 이 설계 접근 방식은 복잡한 웹 애플리케이션을 구축하고 관리하는 방식을 혁신하겠다는 약속을 합니다. 개발 프로세스를 간소화하는 잠재력과 성장하는 중요성에도 불구하고, 이 주제에 대한 포괄적인 자료 및 상세한 토론에는 뚜렷한 공백이 남아 있습니다.\n\n# 정신적 모델:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 원격: 원격은 별도로 구축되고 배포되는 애플리케이션입니다. 다른 애플리케이션에서 로드할 수있는 ESM을 노출 할 수 있습니다.\n- 쉘: 쉘은 필요할 때 원격을 로드합니다. 프레임워크 관점에서 이 기능은 전통적인 지연 로딩과 비슷합니다. 큰 차이점은 컴파일 시간에 쉘이 원격을 모르는 것입니다.\n\n# 원격 앱\n\n독립 구성 요소를 노출합니다. 예를 들어 간단한 프로필 구성 요소를 만들고 federation.config.js로 구성을 업데이트합니다.\n\n```js\nconst {\n withNativeFederation,\n shareAll,\n} = require('@angular-architects/native-federation/config');\n\nmodule.exports = withNativeFederation({\n name: 'profile',\n exposes: {\n  './MyProfileComponent': './src/app/myprofile/myprofile.component.ts',\n },\n shared: {\n  ...shareAll({\n   singleton: true,\n   strictVersion: true,\n   requiredVersion: 'auto',\n  }),\n },\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쉘\n\n```js\n{\n    \"profile\": \"http://profile-app.com/remoteEntry.json\",\n}\n```\n\n자, 우리는 독립형 컴포넌트를 만들어보자. 이름은 federated component로 하자!\n\n```js\n\u003cng-template #federatedComponent\u003e\u003c/ng-template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { loadRemoteModule } from '@angular-architects/native-federation';\nimport { Component, OnInit, ViewContainerRef, Input, ViewChild } from '@angular/core';\n\n@Component({\n    selector: 'app-federated-component',\n    templateUrl: './federated.component.html',\n    standalone: true,\n})\nexport class FederatedComponent implements OnInit {\n    @ViewChild('federatedComponent', { read: ViewContainerRef })\n    private federatedComponent: ViewContainerRef;\n\n    @Input() entryName: string = '';\n    @Input() module: string = '';\n    @Input() componentName: string = '';\n    @Input() additionalProps: Map\u003cstring, unknown\u003e = new Map();\n\n    ngOnInit(): void {\n        loadRemoteModule(this.entryName, this.module).then((federated) =\u003e {\n            if (this.federatedComponent) {\n                const comp = this.federatedComponent.createComponent(federated[this.componentName]);\n\n                if (this.additionalProps.size \u003e 0) {\n                    this.additionalProps.forEach((value, key) =\u003e {\n                        comp.setInput(key, value);\n                    });\n                }\n            }\n        });\n    }\n}\n```\n\nCreate an enum for exposed remotes where we can map remote apps\n\n```js\nexport const FederatedModuleMap = {\n    profile: {\n        name: 'profile',\n        modules: {\n            myprofile: {\n                name: './MyProfileComponent',\n                componentName: 'MyProfileComponent',\n            },\n        },\n    },\n};\n```\n\nNow let`s create the component that will load a remote application from our dynamic component, which we created — `app.federated.component /\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003capp-federated-component\n        [additionalProps]=\"props()\"\n        [entryName]=\"exposedName()\"\n        [module]=\"exposedModule()\"\n        [componentName]=\"exposedComponent()\"\u003e\u003c/ram-federated-component\u003e \n```\n\n```js\nimport { Component, ViewEncapsulation, signal } from '@angular/core';\nimport { FederatedModuleMap } from '@enums';\n\n@Component({\n    selector: 'app-my-profile',\n    templateUrl: './my-profile.component.html',\n    encapsulation: ViewEncapsulation.Emulated,\n})\nexport class MyProfileComponent {\n    protected exposedName = signal(FederatedModuleMap.profile.name);\n    protected exposedModule = signal(\n        FederatedModuleMap.profile.modules.myprofile.name\n    );\n    protected exposedComponent = signal(\n        FederatedModuleMap.profile.modules.myprofile.componentName\n    );\n    protected props = signal(\n        new Map\u003cstring, unknown\u003e([['canEdit', false]])\n    );\n}\n```\n\n원격 컴포넌트가 입력을 필요로 하는 경우 Map과 함께 모든 입력을 전달할 수 있습니다.\n\n이것은 Angular로의 마이크로 프론트엔드에 전념된 시리즈의 첫 번째 블로그이며, 앞으로 미래 게시물에서 MFE 통합의 보다 어려운 측면을 탐구할 예정입니다.","ogImage":{"url":"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png"},"coverImage":"/assets/img/2024-06-20-TrickyPartsofMicrofrontendinAngularReactapps_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular, Docker, Nginx 한 번 빌드하고 어디서든 배포하세요","description":"","date":"2024-06-20 05:31","slug":"2024-06-20-AngularDockerNginxBuildonceDeployanywhere","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_0.png\" /\u003e\n\nGithub 코드: https://github.com/fbzz/angular-build-once-deploy-anywhere\n\n소프트웨어 개발 과정에서 각기 다른 설정을 갖는 여러 환경을 보유하는 것은 꽤 흔합니다. Angular는 환경 변수를 관리하는 내장 시스템을 제공하여 빌드 시 파일을 교체할 수 있도록 합니다. 그러나 이 접근 방식은 종종 각 환경별로 별도의 빌드를 생성해야 하므로 시간이 소모될 수 있습니다. 이를 해결하기 위해 업계에서는 꽤 흔한 패턴이 있습니다.\n\n## 한 번 빌드하고 어디에나 배포하세요…\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, DEV와 PROD라는 두 가지 환경이 있는 예제를 살펴보겠습니다. 하나의 빌드를 사용하려면 다음을 사용합니다:\n\n- Angular — SPA 애플리케이션을 구축하기 위한 프론트엔드 프레임워크입니다.\n- Nginx — 웹 서버 및 역방향 프록시 서버입니다.\n- Docker — 가볍고 휴대 가능하며 독립적인 환경인 컨테이너에서 애플리케이션을 개발, 배포 및 실행하는 플랫폼입니다.\n\n# 1 - Angular\n\n세 가지 파일을 생성해보겠습니다. 이 파일들은 환경에 기반한 다른 구성을 처리할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`src\\config`\n\n- `app-config.dev.json` — 개발용.  \n- `app-config.prod.json` — 프로덕션용.\n\n`src\\`\n\n- `app-config.json` — 로컬 개발용이며, 향후 대체될 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n//App 구성의 예시, 간단한 JSON입니다.\n{\n  \"API_URL\": \"로컬 개발용\",\n}\n```\n\n이제 번들에 포함시켜 봅시다. Angular.json 파일의 빌드 섹션에, config 폴더를 자산에 추가하세요.:\n\n```js\n  \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser-esbuild\",\n            ...\n            \"assets\": [\n              \"src/favicon.ico\",\n              \"src/assets\",\n              \"src/app-config.json\",\n              \"src/config\", // 여기\n            ],\n            ...\n}\n```\n\nnpm run build를 실행하면 dist에 config 폴더가 생깁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Angular Docker Nginx BuildonceDeployanywhere](/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_1.png)\n\n1.2 - Angular에서는 응용 프로그램 전체에 걸쳐 데이터를 유지할 수 있는 싱글톤 서비스를 생성할 수 있습니다. 이는 응용 프로그램 전체에서 재사용할 수 있습니다.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { firstValueFrom } from 'rxjs';\nimport { HttpClient, HttpBackend } from '@angular/common/http';\n\n//Move this type to a shared folder\nexport interface AppConfig {\n  API_URL: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ConfigService {\n  //We create the configuration with default values in case anything fails\n  private configuration: AppConfig = {\n    API_URL: '/api',\n  };\n\n  private http: HttpClient;\n  constructor(private readonly httpHandler: HttpBackend) {\n    this.http = new HttpClient(this.httpHandler);\n  }\n\n  //This function will get the current config for the environment\n  setConfig(): Promise\u003cvoid | AppConfig\u003e {\n    return firstValueFrom(this.http.get\u003cAppConfig\u003e('./app-config.json'))\n      .then((config: AppConfig) =\u003e (this.configuration = config))\n      .catch(error =\u003e {\n        console.error(error);\n      });\n  }\n\n  //We're going to use this function to read the config.\n  readConfig(): AppConfig {\n    return this.configuration;\n  }\n}\n```\n\n1.3 - Angular에서는 APP_INITIALIZER라는 DI 토큰을 제공하여 하나 이상의 초기화 함수를 제공할 수 있습니다. 이 함수는 응용 프로그램 부트스트랩 프로세스 중에 실행되며 시작할 때 필요한 데이터가 사용 가능해집니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNgModules:\n\n```typescript\n// Config Service를 받아와 사용하여 설정 파일을 가져오는 함수가 여기 있습니다.\nexport function initConfig(appConfig: ConfigService) {\n  return () =\u003e appConfig.setConfig();\n}\n\n@NgModule({\n  imports: [BrowserModule],\n  declarations: [AppComponent],\n  bootstrap: [AppComponent],\n  providers: [\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initConfig,\n      deps: [ConfigService], // Angular에게 이 초기화 프로그램이 ConfigService에 의존한다고 말합니다.\n      // 따라서 config 서비스는 init config에서 사용할 수 있게 됩니다.\n      multi: true,\n    },\n  ],\n})\n\nexport class AppModule {}\n```\n\nStandalone:\n\n```typescript\nimport { provideHttpClient } from \"@angular/common/http\";\nimport { APP_INITIALIZER } from \"@angular/core\";\nimport { bootstrapApplication } from \"@angular/platform-browser\";\nimport { ConfigService } from \"./core/services/config.service\";\n\nexport function initConfig(appConfig: ConfigService) {\n  return () =\u003e appConfig.setConfig();\n}\n\nbootstrapApplication(App, {\n  providers: [\n    provideHttpClient(),\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initConfig,\n      multi: true,\n      deps: [ConfigService],\n    },\n  ],\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1.4 - 이제, 구성 요소에서 소비하는 것은 간단합니다!\n\n```js\nimport { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterOutlet } from '@angular/router';\nimport { ConfigService } from '../util/config.service';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet],\n  templateUrl: './app.component.html',\n  //참고: 우리가 이미 제공했기 때문에 providers에서 제공할 필요가 없습니다.\n  styleUrl: './app.component.scss',\n})\nexport class AppComponent {\n  //참고: 이 구성 요소는 독립 실행형으로 사용하고 있으며, ngModules의 경우 module providers에서 가져오기만 하면 됩니다.\n  configService = inject(ConfigService);\n\n  apiUrl = this.configService.readConfig().API_URL;\n\n  constructor() {\n    console.log(this.configService.readConfig().API_URL);\n  }\n}\n```\n\n# 2 - Nginx 구성 파일\n\n프로젝트 루트에서 자산을 제공하기 위한 간단한 구성 파일을 작성합니다. 참고: 귀하의 구성을 자유롭게 포함하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nserver {\n  listen 80;\n\n  gzip on;\n  gzip_http_version 1.1;\n  gzip_disable      \"MSIE [1-6]\\.\";\n  gzip_min_length   256;\n  gzip_vary         on;\n  gzip_proxied      expired no-cache no-store private auth;\n  gzip_types        text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n  gzip_comp_level   9;\n  client_max_body_size 5M;\n  proxy_read_timeout 200s;\n\n  location / {\n    include /etc/nginx/mime.types;\n    root /usr/share/nginx/html;\n    add_header Cache-Control \"public, max-age=1M\";\n    try_files $uri $uri/ /index.html =404;\n  }\n\n  location /healthcheck {\n        access_log off;\n        add_header 'Content-Type' 'text/plain';\n        return 200 \"Healthy\\n\";\n    \n  }\n}\n```\n\n# 3 - Docker\n\nLet’s containerize our application by creating the Dockerfile at the root of our project, inside of it we have all the steps for building our application.\n\n```js\n# Use official node image as the base image\nFROM node:lts as build\n\nADD ./package.json /tmp/package.json\nRUN cd /tmp \u0026\u0026 npm install\nRUN mkdir -p /usr/local/app \u0026\u0026 cp -a /tmp/node_modules /usr/local/app/\n\nWORKDIR /usr/local/app\n\n# Add the source code from the app to the container\nCOPY ./ /usr/local/app/\n\n# Generate the build of the application\nRUN npm run build\n\n# Stage 2: Serve app with nginx server\n# Use official nginx image as the base image\nFROM nginx:latest\n\n# Copy the build output to replace the default nginx contents.\nCOPY --from=build /usr/local/app/dist/build/browser /usr/share/nginx/html\n\n# This line is IMPORTANT, we will breakdown it on a minute.\nCOPY ./entrypoint.sh /usr/local/app/entrypoint.sh\n\n# Copy the nginx conf that we created to the container\nCOPY ./nginx.conf  /etc/nginx/conf.d/default.conf\n\n# Expose ports\nEXPOSE 80 443 6006 4200\n\nRUN chmod +x /usr/local/app/entrypoint.sh\nENTRYPOINT [ \"/usr/local/app/entrypoint.sh\" ]\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 애플리케이션은 현재 컨테이너 내에 캡슐화되어 있습니다. 그러나 지정된 앱 구성을 사용하는 방법을 지정해야 합니다. 실행 중인 기기에는 현재 환경 정보를 전달하는 환경 변수가 있는 것으로 가정해 봅시다. 이를 용이하게 하기 위해 프로젝트 루트에서 entrypoint.sh를 생성할 수 있습니다. 이 스크립트는 애플리케이션이 작동하는 특정 환경에 기반한 파일 교체를 결정할 것입니다.\n\n\"Entrypoint\"는 컨테이너가 시작될 때 실행되는 초기 명령어로, 본질적으로 컨테이너를 초기화합니다.\n\n참고: 회사에 따라 구체적인 사항이 달라질 수 있지만 기본적인 컨셉은 적용 가능하며 프로젝트 요구에 따라 적응될 수 있습니다.\n\n```js\n#!/bin/bash -e\n\n# ENVIRONMENT 변수를 확인하고 해당하는 파일로 교체합니다\nif [[ $ENVIRONMENT == \"Dev\" ]]; then\n   cp /usr/share/nginx/html/config/app-config.dev.json /usr/share/nginx/html/app-config.json\nfi\n\nif [[ $ENVIRONMENT == \"Production\" ]]; then\n   cp /usr/share/nginx/html/config/app-config.prod.json /usr/share/nginx/html/app-config.json\nfi\n\nnginx -g 'daemon off;'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4 - 컨테이너 실행하기\n\n```js\n# 이미지를 빌드하고 태그를 할당하고, 루트 폴더에서 실행합니다\ndocker build . -t angular-boda\n\n# 빌드가 완료되면 애플리케이션을 시작하고 포트 8080을 사용할 수 있습니다\n# 검사를 위해 우리는 환경을 프로덕션으로 설정하여 BODA가 작동하는지 확인합니다\n# 다른 값으로 테스트하려면 ENVIRONMENT=Dev로 변경하십시오\ndocker run -p 8080:80 -e ENVIRONMENT=Production -t angular-boda\n```\n\nlocalhost:8080에서 애플리케이션을 볼 수 있어야합니다: \n\n![이미지](/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 마무리\n\n읽어 주셔서 감사합니다. 이 글에서 우리는 Angular, Docker 및 Nginx의 힘을 활용하여 다양한 환경에서 원활하게 배포할 수 있는 다재다능한 컨테이너를 만들었습니다. 이는 개발 프로세스를 최적화할 뿐만 아니라 CI/CD 파이프라인의 효율도 최적화합니다.\n\nGitHub에서 완성된 예제를 자유롭게 살펴보세요.\n\n새해 복 많이 받으세요! 🎆🎆","ogImage":{"url":"/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_0.png"},"coverImage":"/assets/img/2024-06-20-AngularDockerNginxBuildonceDeployanywhere_0.png","tag":["Tech"],"readingTime":9},{"title":"앵귤러에서의 국제화i18n 가이드","description":"","date":"2024-06-20 05:30","slug":"2024-06-20-AGuidetoInternationalizationi18ninAngular","content":"\n\n![2024-06-20-AGuidetoInternationalizationi18ninAngular_0.png](/assets/img/2024-06-20-AGuidetoInternationalizationi18ninAngular_0.png)\n\n디지털 세계에서 전 세계 대중에 도달하는 것은 웹 개발자들의 궁극적인 목표입니다. 이를 달성하는 한 가지 방법은 Angular 애플리케이션을 다국어로 만드는 것입니다. 국제화(i18n)의 세계에 오신 것을 환영합니다. 여기서 여러 나라 사용자들의 언어로 의사소통할 수 있는 앱을 만들어 보겠습니다. 이 블로그에서는 Angular 프로젝트에 i18n을 통합하고 전 세계 사용자들에게 앱을 이용할 수 있도록 하는 방법을 탐구할 것입니다.\n\n# Angular에서 국제화(i18n) 소개\n\n웹 앱을 세계의 다른 지역 사용자들과 연결할 수 있는 도구로 생각해보세요. 모든 사람에게 환영받고 사용하기 쉬운 경험을 제공하기 위해 우리는 그들의 언어를 구사해야 합니다. 국제화(i18n)는 여러 언어와 지역에 적응할 수 있도록 앱을 만드는 과정입니다. Angular는 이를 성취할 수 있는 강력한 도구와 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 새 Angular 프로젝트 설정하기\n\ni18n 여행을 시작하기 전에 새 Angular 프로젝트를 만들어봅시다. 걱정하지 마세요; 이 부분은 간단합니다.\n\n```js\nng new i18n-app\n```\n\n이 명령은 Angular CLI를 사용하여 새 Angular 프로젝트를 초기화합니다. 프로젝트 구성에 대한 몇 가지 질문을 하게 될 것인데, 예를 들어 Angular 라우팅을 포함할지, 어떤 스타일시트 형식을 사용할지 (CSS, SCSS 등) 등을 물을 것입니다. 프로젝트의 요구에 맞는 옵션을 선택해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Angular의 i18n 도구 설치 및 구성\n\ni18n 여행을 시작하기 위해 올바른 도구가 필요합니다. 우리 앱을 다국어로 만들기 위해 Angular의 i18n 도구를 설치하고 구성해보겠습니다.\n\n```js\nng add @angular/localize\n```\n\n이 명령은 필요한 패키지를 설치하고 프로젝트 구성을 업데이트하여 i18n 지원을 활성화합니다. Angular의 @angular/localize 패키지는 번역 추출 및 관리 도구를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 안녕하세요! \n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@@appTitle 값은 이 번역 메시지의 고유 식별자로 작동합니다. 다양한 언어로의 번역을 이 특정 텍스트와 연관시키는 데 도움이 됩니다.\n\n각 텍스트를 고유한 i18n 식별자와 연결하는 것이 좋은 실천 방법입니다.\n\n# messages.xlf 생성 자동화\n\n앱을 업데이트할 때마다 번역 메시지를 수동으로 추출하는 것은 번거로울 수 있습니다. 다행히도 xliffmerge 패키지를 사용하여이 프로세스를 자동화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- xliffmerge를 설치하세요:\n\n```js\nnpm install xliffmerge --save-dev\n```\n\n- xliffmerge 구성: 구성 파일을 만들어 xliffmerge를 구성하세요. 예를 들어, xliffmerge.config.json과 같이 파일을 만들고 지원할 언어 및 번역을위한 원본 및 대상 폴더를 지정하세요. 다음은 간단한 구성입니다:\n\n```js\n{\n  \"xliffmergeOptions\": {\n    \"srcDir\": \"src\",\n    \"genDir\": \"src/locale\",\n    \"languages\": [\"en\", \"fr\", \"es\"]\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 번역 생성: xliffmerge를 실행하여 messages.xlf 파일을 생성하거나 업데이트하세요:\n\n```js\nnpx xliffmerge --profile xliffmerge.config.json\n```\n\n이 명령어는 앱 템플릿에서 번역 메시지를 자동으로 추출하고 병합하여 각 언어 파일에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 언어 및 로캘 설정하기\n\n우리 앱의 전역 여행에서 시작점이 필요합니다 - 기본 언어. 이를 앱의 app.module.ts 파일에서 설정할 수 있습니다.\n\n```js\nimport { LOCALE_ID } from '@angular/core';\n\n@NgModule({\n  providers: [{ provide: LOCALE_ID, useValue: 'en-US' }],\n})\nexport class AppModule {}\n```\n\n이 예제에서는 기본 언어를 영어(미국)로 설정했습니다. 이는 사용자가 앱을 처음 방문할 때 영어로 표시되며, 그들이 다른 언어를 선택하지 않는 한 계속 영어로 표시됨을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 언어 전환하기\n\n언어 전환기 컴포넌트를 구현하여 사용자가 선호하는 언어를 선택할 수 있도록 하면 앱을 사용자의 요구에 맞게 조정할 수 있습니다.\n\n아래에는 Angular 앱에서 언어 전환기를 만드는 간단한 예제가 있습니다:\n\n```js\n\u003cbutton (click)=\"changeLanguage('fr')\"\u003e프랑스어\u003c/button\u003e\n\u003cbutton (click)=\"changeLanguage('es')\"\u003e스페인어\u003c/button\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴포넌트 안에서:\n\n```js\nchangeLanguage(language: string) {\n  this.translateService.use(language);\n}\n```\n\n이 코드를 사용하면 사용자가 앱의 언어를 동적으로 변경할 수 있습니다.\n\n# 날짜, 숫자 및 통화 형식 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n숫자와 날짜는 각 지역에 따라 다른 형식을 가지고 있어요. Angular는 사용자의 로캘에 따라 그들을 포맷하는 내장된 파이프들을 제공하여 이를 간편하게 만들어줘요. 마치 당신의 앱에 문화적 전환을 주는 것과 같달까요?\n\nAngular의 파이프를 사용하면 사용자의 로캘에 따라 숫자, 날짜 및 통화를 포맷할 수 있어요. 예를 들어, 날짜 파이프를 사용하여 날짜를 포맷할 수 있어요:\n\n```js\n{ today | date: 'shortDate' }\n```\n\n이 예제에서 today는 JavaScript Date 객체이며, date 파이프를 통해 사용자의 로캘에 따라 단축된 날짜 형식으로 포맷되어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 국제화된 앱을 테스트해보세요\n\n이제 여러 언어로 지원되는 앱을 사용해보고 다른 언어로 테스트해보는 탐험가 모자를 쓰는 시간입니다. 긴 번역으로 인해 발생할 수 있는 텍스트 오버플로 및 UI 문제를 확인하세요.\n\n모든 국제 사용자를 위해 부드러운 사용자 경험을 보장하기 위해 다양한 언어로 앱을 철저히 테스트하는 것이 중요합니다.\n\n# 국제화된 Angular 앱을 배포하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱이 여러 언어로 유창해지면 웹을 정복할 준비가 된 것입니다. 배포하고 전 세계 사용자들을 매료시키는 것을 지켜보세요.\n\n국제화된 Angular 앱을 배포하는 것은 일반적인 Angular 앱을 배포하는 것과 별 다를 바가 없습니다. Netlify, Vercel, 또는 AWS와 같은 다양한 호스팅 서비스나 플랫폼을 사용하여 앱을 호스팅하고 전 세계 사용자에게 접근할 수 있습니다.\n\n# 결론\n\n축하합니다, 여러 언어로 번역된 Angular 앱을 만드는 비밀을 발견했습니다! 국제화 (i18n)를 통해 앱을 세계 여행에 떠날 수 있으며 모든 사용자의 언어를 구사할 수 있습니다. 다양성을 수용하고 문화를 이어주며 참으로 세계적인 웹 존재를 만들어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 추가 자료\n\n- Angular i18n 문서\n- xliffmerge GitHub 저장소\n\n이제 국제화 및 자동화의 기술을 정복했으니, 앱이 전 세계 사용자들과 소통할 준비가 되었습니다.","ogImage":{"url":"/assets/img/2024-06-20-AGuidetoInternationalizationi18ninAngular_0.png"},"coverImage":"/assets/img/2024-06-20-AGuidetoInternationalizationi18ninAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"내 Neovim 설정 React, TypeScript, Tailwind CSS 등","description":"","date":"2024-06-20 05:27","slug":"2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_0.png\" /\u003e\n\n안녕하세요, 타쿠야입니다. 제 어플리케이션 인크드롭(Inkdrop)을 코딩하기 위해 주로 Neovim을 사용하는 것을 아시겠지만, 인크드롭은 크로스 플랫폼 마크다운 노트 앱입니다. 데스크탑용으로는 일렉트론(Electron), 모바일 플랫폼으로는 리액트 네이티브(React Native)로 만들어졌습니다. 지난 번 Neovim 설정을 올린 지 1년이 지났네요. Neovim과 관련 플러그인들이 아주 잘 발전했습니다. 그래서 리액트와 타입스크립트 기반의 앱 개발을 위한 제 최신 설정을 공유하고 싶습니다. 주요 변화 중 하나는 설정 파일이 이제 Lua로 작성되었다는 점입니다. vim-plug에서 Packer로 변경했습니다. 그리고 M1 MacBook Air에서 Neovim을 처음부터 설정하는 방법에 대한 튜토리얼 비디오도 만들었습니다. 이미 여러분들께서 자신만의 도트 파일을 보유하고 계신다면, 제 설정을 선택적으로 사용해보세요. 즐겨주시기 바랍니다!\n\n# 재료\n\n여기 제 설정의 간단한 요약입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Neovim `= 0.7\r\n- wbthomason/packer.nvim — Neovim을 위한 플러그인 매니저\r\n- svrana/neosolarized.nvim — Truecolor, 솔라라이즈드 다크 컬러스킴\r\n- nvim-lualine/lualine.nvim — Lua로 작성된 Neovim 스테이터스 라인으로 빠르고 쉽게 구성할 수 있습니다.\r\n- onsails/lspkind-nvim — VSCode와 유사한 픽토그램들\r\n- L3MON4D3/LuaSnip — Lua로 작성된 Neovim을 위한 스니펫 엔진\r\n- hrsh7th/cmp-nvim-lsp — Neovim의 내장 LSP를 위한 nvim-cmp 소스\r\n- hrsh7th/cmp-buffer — 버퍼 단어를 위한 nvim-cmp 소스\r\n- hrsh7th/nvim-cmp — Lua로 작성된 Neovim을 위한 완성 엔진 플러그인\r\n- neovim/nvim-lspconfig — Neovim의 내장 LSP 구성 모음\r\n- jose-elias-alvarez/null-ls.nvim — Lua를 통해 LSP 진단, 코드 액션 등을 삽입하기 위해 Neovim을 언어 서버로 사용합니다.\r\n- MunifTanjim/prettier.nvim - Neovim의 내장 LSP 클라이언트를 위한 Prettier 플러그인\r\n- williamboman/mason.nvim - Neovim에서 동작하는 이동 가능한 패키지 매니저로 LSP 서버, DAP 서버, 린터 및 포매터를 쉽게 설치하고 관리할 수 있습니다.\r\n- williamboman/mason-lspconfig.nvim - mason.nvim의 확장으로 mason.nvim과 lspconfig를 쉽게 사용할 수 있도록 합니다.\r\n- glepnir/lspsaga.nvim - 높은 성능의 UI를 갖춘 neovim의 내장 LSP를 기반으로 한 가벼운 lsp 플러그인\r\n- nvim-treesitter/nvim-treesitter - Neovim을 위한 Treesitter 구성 및 추상화 레이어\r\n- kyazdani42/nvim-web-devicons - neovim용 vim-web-devicons의 Lua 포크\r\n- nvim-telescope/telescope.nvim - 리스트를 통해 확장 가능한 퍼지 찾기 도구\r\n- nvim-telescope/telescope-file-browser.nvim - telescope.nvim의 파일 브라우저 확장\r\n- windwp/nvim-autopairs - 자동 괄호 기능\r\n- windwp/nvim-ts-autotag - Treesitter를 사용하여 html 태그를 자동으로 닫고 이름을 바꿉니다.\r\n- norcalli/nvim-colorizer.lua - 고성능 색상 강조 플러그인\r\n- akinsho/nvim-bufferline.lua - 멋진 버퍼 라인\r\n- lewis6991/gitsigns.nvim - 버퍼용 Git 통합\r\n- dinhhuy258/git.nvim - 플러그인 vim-fugitive의 단순한 클론\r\n- folke/zen-mode.nvim - 산만한 모드\r\n- iamcco/markdown-preview.nvim - Markdown 실시간 미리보기\r\n\r\n그리고 여기가 제 dotfiles 저장소입니다.\r\n\r\n튜토리얼 비디오 (YouTube):\r\n\r\n# 사전 요구 사항 — iTerm2 및 Patched Nerd 글꼴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niTerm2는 macOS용 빠른 터미널 에뮬레이터입니다. 터미널에서 멋진 글리프를 표시하기 위해 Nerd Fonts 중 하나를 설치하세요. 저는 현재 Hack을 사용하고 있어요. 그리고 터미널 앱에서 사용해보세요. 예를 들어, iTerm2에서:\n\n[2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_1.png](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_1.png)를 확인해보세요.\n\n# Homebrew를 통해 Neovim 설치하기\n\n간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbrew install neovim\n```\n\n# 디렉토리 구조\n\nNeovim은 XDG 기본 디렉토리 구조를 준수합니다. 여기는 내 설정 파일 구조입니다:\n\n```js\n📂 ~/.config/nvim\n├── 📁 after\n│  └── 📁 plugin\n├── 📂 lua\n│  └── 🌑 base.lua\n├── 📁 plugin\n└── 🇻 init.lua\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNeovim은 $HOME/.config/nvim/init.vim 또는 init.lua를 $HOME/.vimrc 대신 먼저로드합니다. 자세한 내용은 퀵스타트 가이드를 확인해보세요:\n\n## 플러그인 매니저 설치: Packer\n\n아래 명령어를 실행하여 Packer를 설치하세요:\n\n```bash\ngit clone --depth 1 https://github.com/wbthomason/packer.nvim \\\n~/.local/share/nvim/site/pack/packer/start/packer.nvim\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면, 다음과 같이 `.config/nvim/lua/plugins.lua` 파일을 만들어주세요:\n\n```lua\nlocal status, packer = pcall(require, \"packer\")\nif (not status) then\n  print(\"Packer가 설치되지 않았습니다\")\n  return\nend\n\nvim.cmd [[packadd packer.nvim]]\n\npacker.startup(function(use)\n  use 'wbthomason/packer.nvim'\n  -- 여기에 사용할 플러그인을 추가하세요\nend)\n```\n\n그런 다음, `init.lua`에서 다음과 같이 불러오세요:\n\n```lua\nrequire('plugins') \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 색 구성표: Neosolarized\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_2.png)\n\n저는 svrana/neosolarized.nvim을 일부 사용자 지정과 함께 사용합니다.\n\n```lua\nlocal status, n = pcall(require, \"neosolarized\")\nif (not status) then return end\n\nn.setup({\n  comment_italics = true,\n})\n\nlocal cb = require('colorbuddy.init')\nlocal Color = cb.Color\nlocal colors = cb.colors\nlocal Group = cb.Group\nlocal groups = cb.groups\nlocal styles = cb.styles\n\nColor.new('black', '#000000')\nGroup.new('CursorLine', colors.none, colors.base03, styles.NONE, colors.base1)\nGroup.new('CursorLineNr', colors.yellow, colors.black, styles.NONE, colors.base1)\nGroup.new('Visual', colors.none, colors.base03, styles.reverse)\n  \nlocal cError = groups.Error.fg\nlocal cInfo = groups.Information.fg\nlocal cWarn = groups.Warning.fg\nlocal cHint = groups.Hint.fg\n\nGroup.new(\"DiagnosticVirtualTextError\", cError, cError:dark():dark():dark():dark(), styles.NONE)\nGroup.new(\"DiagnosticVirtualTextInfo\", cInfo, cInfo:dark():dark():dark(), styles.NONE)\nGroup.new(\"DiagnosticVirtualTextWarn\", cWarn, cWarn:dark():dark():dark(), styles.NONE)\nGroup.new(\"DiagnosticVirtualTextHint\", cHint, cHint:dark():dark():dark(), styles.NONE)\nGroup.new(\"DiagnosticUnderlineError\", colors.none, colors.none, styles.undercurl, cError)\nGroup.new(\"DiagnosticUnderlineWarn\", colors.none, colors.none, styles.undercurl, cWarn)\nGroup.new(\"DiagnosticUnderlineInfo\", colors.none, colors.none, styles.undercurl, cInfo)\nGroup.new(\"DiagnosticUnderlineHint\", colors.none, colors.none, styles.undercurl, cHint)\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 상태 라인: Lualine\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_3.png)\n\nnvim-lualine/lualine.nvim은 상태 행을 유연하게 구성할 수 있는 방법을 제공합니다.\n\n```lua\nlocal status, lualine = pcall(require, \"lualine\")\nif (not status) then return end\n\nlualine.setup {\n  options = {\n    icons_enabled = true,\n    theme = 'solarized_dark',\n    section_separators = { left = '', right = '' },\n    component_separators = { left = '', right = '' },\n    disabled_filetypes = {}\n  },\n  sections = {\n    lualine_a = { 'mode' },\n    lualine_b = { 'branch' },\n    lualine_c = { {\n      'filename',\n      file_status = true, -- 파일 상태 표시(읽기 전용 상태, 수정된 상태)\n      path = 0 -- 0 = 파일 이름만, 1 = 상대 경로, 2 = 절대 경로\n    } },\n    lualine_x = {\n      { 'diagnostics', sources = { \"nvim_diagnostic\" }, symbols = { error = ' ', warn = ' ', info = ' ',\n        hint = ' ' } },\n      'encoding',\n      'filetype'\n    },\n    lualine_y = { 'progress' },\n    lualine_z = { 'location' }\n  },\n  inactive_sections = {\n    lualine_a = {},\n    lualine_b = {},\n    lualine_c = { {\n      'filename',\n      file_status = true, -- 파일 상태 표시(읽기 전용 상태, 수정된 상태)\n      path = 1 -- 0 = 파일 이름만, 1 = 상대 경로, 2 = 절대 경로\n    } },\n    lualine_x = { 'location' },\n    lualine_y = {},\n    lualine_z = {}\n  },\n  tabline = {},\n  extensions = { 'fugitive' }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Lspconfig\n\nNeovim에는 내장 LSP 지원이 있습니다. neovim/nvim-lspconfig를 사용하여 쉽게 구성할 수 있습니다. 예를 들어, Neovim에서 typescript 언어 서버를 활성화하려면:\n\n```js\nlocal status, nvim_lsp = pcall(require, \"lspconfig\")\nif (not status) then return end\n\nlocal protocol = require('vim.lsp.protocol')\n\nlocal on_attach = function(client, bufnr)\n  -- 저장 시 형식 지정\n  if client.server_capabilities.documentFormattingProvider then\n    vim.api.nvim_create_autocmd(\"BufWritePre\", {\n      group = vim.api.nvim_create_augroup(\"Format\", { clear = true }),\n      buffer = bufnr,\n      callback = function() vim.lsp.buf.formatting_seq_sync() end\n    })\n  end\nend\n\n-- TypeScript\nnvim_lsp.tsserver.setup {\n  on_attach = on_attach,\n  filetypes = { \"typescript\", \"typescriptreact\", \"typescript.tsx\" },\n  cmd = { \"typescript-language-server\", \"--stdio\" }\n} \n```\n\n타입스크립트 언어 서버를 설치하는 것을 잊지 마세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i -g typescript-language-server\n```\n\n# 자동 완성: Lspkind 및 cmp\n\n\u003cimg src=\"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_4.png\" /\u003e\n\n팬시한 픽토그램이 포함된 LSP를 인식하는 자동 완성 기능을 얻으려면 다음 플러그인을 사용합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- onsails/lspkind-nvim - VSCode와 비슷한 그림표\n- L3MON4D3/LuaSnip - 스니펫 엔진\n- hrsh7th/cmp-nvim-lsp - neovim 내장 LSP용 nvim-cmp 소스\n- hrsh7th/cmp-buffer - 버퍼 단어용 nvim-cmp 소스\n- hrsh7th/nvim-cmp - neovim을 위한 완성 엔진 플러그인\n\n다음과 같이 설정하십시오:\n\n```js\nlocal status, cmp = pcall(require, \"cmp\")\nif (not status) then return end\nlocal lspkind = require 'lspkind'\n\ncmp.setup({\n  snippet = {\n    expand = function(args)\n      require('luasnip').lsp_expand(args.body)\n    end,\n  },\n  mapping = cmp.mapping.preset.insert({\n    ['\u003cC-d\u003e'] = cmp.mapping.scroll_docs(-4),\n    ['\u003cC-f\u003e'] = cmp.mapping.scroll_docs(4),\n    ['\u003cC-Space\u003e'] = cmp.mapping.complete(),\n    ['\u003cC-e\u003e'] = cmp.mapping.close(),\n    ['\u003cCR\u003e'] = cmp.mapping.confirm({\n      behavior = cmp.ConfirmBehavior.Replace,\n      select = true\n    }),\n  }),\n  sources = cmp.config.sources({\n    { name = 'nvim_lsp' },\n    { name = 'buffer' },\n  }),\n  formatting = {\n    format = lspkind.cmp_format({ with_text = false, maxwidth = 50 })\n  }\n})\n\nvim.cmd [[\n  set completeopt=menuone,noinsert,noselect\n  highlight! default link CmpItemKind CmpItemMenuDefault\n]]\n```\n\n# 문법 강조: Treesitter\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_5.png)\n\nTreesitter은 구문 강조를 위한 인기있는 언어 구문 분석기입니다. 먼저 다음을 설치하세요:\n\n```js\nbrew install tree-sitter\n```\n\nPacker를 사용하여 nvim-treesitter/nvim-treesitter를 설치하고 다음과 같이 구성하세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```lua\nlocal status, ts = pcall(require, \"nvim-treesitter.configs\")\nif (not status) then return end\n\nts.setup {\n  highlight = {\n    enable = true,\n    disable = {},\n  },\n  indent = {\n    enable = true,\n    disable = {},\n  },\n  ensure_installed = {\n    \"tsx\",\n    \"toml\",\n    \"fish\",\n    \"php\",\n    \"json\",\n    \"yaml\",\n    \"swift\",\n    \"css\",\n    \"html\",\n    \"lua\"\n  },\n  autotag = {\n    enable = true,\n  },\n}\n\nlocal parser_config = require \"nvim-treesitter.parsers\".get_parser_configs()\nparser_config.tsx.filetype_to_parsername = { \"javascript\", \"typescript.tsx\" }\n```\n\n# Autotag and Autopair\n\n리액트 앱에서는 태그를 빠르게 닫고 싶을 때가 많습니다. windwp/nvim-ts-autotag가 정확히 원하는 기능을 제공합니다.\n\n```lua\nlocal status, autotag = pcall(require, \"nvim-ts-autotag\")\nif (not status) then return end\n\nautotag.setup({})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nwindwp/nvim-autopairs는 괄호를 자동으로 닫아주는 플러그인이에요.\n\n```lua\nlocal status, autopairs = pcall(require, \"nvim-autopairs\")\nif (not status) then return end\n\nautopairs.setup({\n  disable_filetype = { \"TelescopePrompt\" , \"vim\" },\n})\n```\n\n# 퍼즈 파인더: Telescope\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntelescope.nvim은 최신 Neovim 기능을 기반으로 한 목록 위의 대화식 퍼지 파인더를 제공합니다. 또한 filer로 telescope-file-browser.nvim을 사용합니다.\n\n실제로 파일을 열지 않고도 파일의 내용을 보면서 파일을 검색할 수 있어서 매우 유용합니다. Vim, 파일, Git, LSP, Treesitter 등 다양한 소스를 지원합니다. Telescope의 쇼케이스를 확인해보세요.\n\nTelescope, 상태행 및 다른 지원 플러그인에 파일 아이콘을 얻기 위해 kyazdani42/nvim-web-devicons를 설치하세요.\n\n구성은 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```lua\nlocal status, telescope = pcall(require, \"telescope\")\nif (not status) then return end\nlocal actions = require('telescope.actions')\nlocal builtin = require(\"telescope.builtin\")\n\nlocal function telescope_buffer_dir()\n  return vim.fn.expand('%:p:h')\nend\n\nlocal fb_actions = require \"telescope\".extensions.file_browser.actions\n\ntelescope.setup {\n  defaults = {\n    mappings = {\n      n = {\n        [\"q\"] = actions.close\n      },\n    },\n  },\n}\n\n-- 키맵\nvim.keymap.set('n', ';f',\n  function()\n    builtin.find_files({\n      no_ignore = false,\n      hidden = true\n    })\n  end)\nvim.keymap.set('n', ';r', function()\n  builtin.live_grep()\nend)\nvim.keymap.set('n', '\\\\', function()\n  builtin.buffers()\nend)\nvim.keymap.set('n', ';t', function()\n  builtin.help_tags()\nend)\nvim.keymap.set('n', ';;', function()\n  builtin.resume()\nend)\nvim.keymap.set('n', ';e', function()\n  builtin.diagnostics()\nend)\n```\n\n이미지를 추가했어요: \n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_7.png)\n\n텔레스코프 브라우저 확장 기능을 사용합니다:\n\n```lua\ntelescope.setup {\n  defaults = {\n    mappings = {\n      n = {\n        [\"q\"] = actions.close\n      },\n    },\n  },\n  extensions = {\n    file_browser = {\n      theme = \"dropdown\",\n      -- netrw를 비활성화하고 telescope-file-browser를 사용합니다\n      hijack_netrw = true,\n      mappings = {\n        -- 사용자 정의 삽입 모드 매핑\n        [\"i\"] = {\n          [\"\u003cC-w\u003e\"] = function() vim.cmd('normal vbd') end,\n        },\n        [\"n\"] = {\n          -- 사용자 정의 일반 모드 매핑\n          [\"N\"] = fb_actions.create,\n          [\"h\"] = fb_actions.goto_parent_dir,\n          [\"/\"] = function()\n            vim.cmd('startinsert')\n          end\n        },\n      },\n    },\n  },\n}\ntelescope.load_extension(\"file_browser\")\n\nvim.keymap.set(\"n\", \"sf\", function()\n  telescope.extensions.file_browser.file_browser({\n    path = \"%:p:h\",\n    cwd = telescope_buffer_dir(),\n    respect_gitignore = false,\n    hidden = true,\n    grouped = true,\n    previewer = false,\n    initial_mode = \"normal\",\n    layout_config = { height = 40 }\n  })\nend)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 탭: 버퍼 라인\n\n\u003cimg src=\"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_8.png\" /\u003e\n\n나는 탭의 보다 멋진 모양을 얻기 위해 akinsho/nvim-bufferline.lua를 사용합니다. Solarized 테마와 더 잘 어울리도록 몇 가지 사용자 정의를 추가했습니다:\n\n```js\nlocal status, bufferline = pcall(require, \"bufferline\")\nif (not status) then return end\n\nbufferline.setup({\n  options = {\n    mode = \"tabs\",\n    separator_style = 'slant',\n    always_show_bufferline = false,\n    show_buffer_close_icons = false,\n    show_close_icon = false,\n    color_icons = true\n  },\n  highlights = {\n    separator = {\n      guifg = '#073642',\n      guibg = '#002b36',\n    },\n    separator_selected = {\n      guifg = '#073642',\n    },\n    background = {\n      guifg = '#657b83',\n      guibg = '#002b36'\n    },\n    buffer_selected = {\n      guifg = '#fdf6e3',\n      gui = \"bold\",\n    },\n    fill = {\n      guibg = '#073642'\n    }\n  },\n})\n\nvim.keymap.set('n', '\u003cTab\u003e', '\u003cCmd\u003eBufferLineCycleNext\u003cCR\u003e', {})\nvim.keymap.set('n', '\u003cS-Tab\u003e', '\u003cCmd\u003eBufferLineCyclePrev\u003cCR\u003e', {})\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# LSP 설정: Lspsaga\n\n![](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_9.png)\n\n![](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_10.png)\n\n![](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlocal status, saga = pcall(require, \"lspsaga\")\nif (not status) then return end\n\nsaga.init_lsp_saga {\n  server_filetype_map = {\n    typescript = 'typescript'\n  }\n}\n\nlocal opts = { noremap = true, silent = true }\nvim.keymap.set('n', '\u003cC-j\u003e', '\u003cCmd\u003eLspsaga diagnostic_jump_next\u003cCR\u003e', opts)\nvim.keymap.set('n', 'K', '\u003cCmd\u003eLspsaga hover_doc\u003cCR\u003e', opts)\nvim.keymap.set('n', 'gd', '\u003cCmd\u003eLspsaga lsp_finder\u003cCR\u003e', opts)\nvim.keymap.set('i', '\u003cC-k\u003e', '\u003cCmd\u003eLspsaga signature_help\u003cCR\u003e', opts)\nvim.keymap.set('n', 'gp', '\u003cCmd\u003eLspsaga preview_definition\u003cCR\u003e', opts)\nvim.keymap.set('n', 'gr', '\u003cCmd\u003eLspsaga rename\u003cCR\u003e', opts)\n```\n\n# Code formatter: Prettier and null-ls\n\n제가 가장 좋아하는 LSP 플러그인 중 하나인 glepnir/lspsaga.nvim은 hover doc, definition preview, rename actions 등과 같은 다양한 LSP 관련 기능에 대한 아름다운 UI를 제공합니다. 제 설정은 간단합니다. typescript 파일에 대해 'typescript' 서버를 매핑하고, 다른 기능에 대한 keymap을 설정합니다.\n\nTypeScript/JavaScript/CSS 파일을 포맷하는 데 Prettier에 큰 의존을 하고 있습니다. 이를 위해 jose-elias-alvarez/null-ls.nvim 및 MunifTanjim/prettier.nvim을 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, prettierd를 설치해야 합니다:\n\n```js\nbrew install prettierd\n```\n\n그런 다음 null-ls를 다음과 같이 구성하세요:\n\n```js\nlocal status, null_ls = pcall(require, \"null-ls\")\nif (not status) then return end\n\nnull_ls.setup({\n  sources = {\n    null_ls.builtins.diagnostics.eslint_d.with({\n      diagnostics_format = '[eslint] #{m}\\n(#{c})'\n    }),\n    null_ls.builtins.diagnostics.fish\n  }\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친화적인 톤으로 번역하면:\n\n```js\nlocal status, prettier = pcall(require, \"prettier\")\nif (not status) then return end\n\nprettier.setup {\n  bin = 'prettierd',\n  filetypes = {\n    \"css\",\n    \"javascript\",\n    \"javascriptreact\",\n    \"typescript\",\n    \"typescriptreact\",\n    \"json\",\n    \"scss\",\n    \"less\"\n  }\n}\n```\n\n# Git 표시: gitsigns\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_12.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlewis6991/gitsigns.nvim은 현재 버퍼에 대한 Git 장식을 제공합니다. 현재 변경된 줄을 파악하는 데 도움이 됩니다. 기본 설정으로 작동합니다.\n\n```js\nrequire('gitsigns').setup {}\n```\n\n# git\n\n\u003cimg src=\"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_13.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘 제가 자주 사용하는 사이트는 GitHub입니다. dinhhuy258/git.nvim을 사용하면 Neovim에서 바로 GitHub을 열 수 있고, 분할 화면에서 git blame을 볼 수 있어 정말 편리해요.\n\n```js\nlocal status, git = pcall(require, \"git\")\nif (not status) then return end\n\ngit.setup({\n  keymaps = {\n    -- Open blame window\n    blame = \"\u003cLeader\u003egb\",\n    -- Open file/folder in git repository\n    browse = \"\u003cLeader\u003ego\",\n  }\n})\n```\n\n# LSP 도구: mason\n\n\u003cimg src=\"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_14.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 라이브러리에 대한 추가 LSP 지원이 필요하면 williamboman/mason.nvim 및 williamboman/mason-lspconfig.nvim이 필요할 수 있습니다. Neovim에서 Tailwind CSS 언어 서버를 실행하기 위해 사용하고 있어요.\n\n```js\nlocal status, mason = pcall(require, \"mason\")\nif (not status) then return end\nlocal status2, lspconfig = pcall(require, \"mason-lspconfig\")\nif (not status2) then return end\n\nmason.setup({})\n\nlspconfig.setup {\n  ensure_installed = { \"sumneko_lua\", \"tailwindcss\" },\n}\n```\n\n다음으로 lspconfig을 추가하세요:\n\n```js\nlocal nvim_lsp = require \"lspconfig\"\nnvim_lsp.tailwindcss.setup {}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것으로 대부분 끝났어요! 네오빔 환경을 개선하는 데 도움이 되길 바랍니다.\n\n# 온라인에서 나를 따르세요\n\n- Inkdrop라는 앱을 확인해보세요 — 마크다운 노트 앱\n- Twitter: [https://twitter.com/inkdrop_app](https://twitter.com/inkdrop_app)\n- 블로그: [https://blog.inkdrop.app/](https://blog.inkdrop.app/)\n- YouTube: [https://www.youtube.com/devaslife](https://www.youtube.com/devaslife)\n- Instagram: [https://instagram.com/craftzdog](https://instagram.com/craftzdog)\n\n![이미지](/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_15.png)","ogImage":{"url":"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_0.png"},"coverImage":"/assets/img/2024-06-20-MyNeovimsetupforReactTypeScriptTailwindCSSetc_0.png","tag":["Tech"],"readingTime":18},{"title":"당신의 Angular 프로젝트에 ESLint 설정하기","description":"","date":"2024-06-20 05:26","slug":"2024-06-20-SettingUpESLintinYourAngularProject","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-SettingUpESLintinYourAngularProject_0.png\" /\u003e\n\n린트는 소프트웨어 개발의 중요한 측면으로, 코드 품질, 일관성 및 신뢰성을 보장합니다. Angular의 세계에서 ESLint는 코딩 표준을 강제하고 잠재적인 오류를 잡는 데 사용되는 주요 도구가 되었습니다.\n\n# 전제조건\n\n시작하기 전에 다음 전제조건이 갖추어져 있는지 확인해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Node.js 및 npm: 개발 머신에 Node.js 및 npm이 설치되어 있는지 확인해주세요.\n- Angular의 기본 이해: 이 안내서를 따라가기 위해서는 Angular 개발에 대한 이해가 필수적입니다.\n\n# Angular 프로젝트 생성\n\n이미 Angular 프로젝트가 없는 경우, Angular CLI(명령줄 인터페이스)를 사용하여 프로젝트를 생성할 수 있습니다. 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nnpx @angular/cli new your-angular-project\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"your-angular-project\"을(를) 귀하의 프로젝트 이름으로 바꿔주세요. Angular CLI를 사용하면 프로젝트 설정을 안내받을 수 있습니다. 원하는 기능과 스타일시트를 선택할 수 있습니다.\n\n# ESLint 설치\n\nESLint는 인기 있는 JavaScript 린트 도구로, Angular 프로젝트에 쉽게 통합할 수 있습니다. 시작하려면 프로젝트의 루트 디렉토리로 이동해주세요:\n\n```js\ncd your-angular-project\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 프로젝트에 개발 의존성으로 ESLint를 설치해보세요:\n\n```js\nnpm install eslint --save-dev\n```\n\n# ESLint 규칙 구성\n\nESLint를 사용하면 프로젝트의 코딩 스타일과 가이드라인을 정의하는 규칙을 구성할 수 있습니다. 다음 명령어를 사용하여 프로젝트 디렉토리에 ESLint 구성 파일을 만들 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpx eslint --init\n```\n\n이 명령어를 실행하면 .eslintrc.js 파일을 생성하기 위해 여러 질문들을 안내받게 됩니다. 여기서 프로젝트에 맞는 linting 규칙을 지정할 수 있습니다. 필요한 경우 이러한 규칙을 더 자세히 사용자 정의할 수도 있습니다.\n\n다음은 ESLint 구성 파일의 예시입니다:\n\n```js\nmodule.exports = {\n  extends: 'eslint:recommended',\n  rules: {\n    // 여기에 사용자 정의 규칙을 추가하세요\n  },\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 당신의 Angular 프로젝트와 통합하기\n\nESLint를 Angular 프로젝트와 통합하려면 package.json 파일에 linting 스크립트를 추가할 수 있습니다. package.json을 열고 다음과 같은 스크립트를 추가해보세요:\n\n```js\n\"scripts\": {\n  \"lint\": \"eslint .\",\n  \"lint:fix\": \"eslint . --fix\"\n}\n```\n\nlint 스크립트는 ESLint 위반 사항을 확인하고, lint:fix 스크립트는 이러한 문제 중 일부를 자동으로 수정하려고 시도할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ESLint 체크 실행\n\n이제 ESLint가 설정되었으므로 다음 명령을 실행하여 Angular 프로젝트에서 린팅 체크를 실행할 수 있습니다:\n\n```js\nnpm run lint\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e your-angular-project@0.0.0 lint /path/to/your-angular-project\n\u003e eslint .\n\n\n\n...\n✅ 모든 린트 체크 통과! 오류나 경고가 발견되지 않았습니다.\n```\n\nESLint가 코드 위반을 스캔하여 터미널에서 피드백을 제공할 것입니다. 위의 예시 결과에서 58개의 문제가 있고, 52개는 --fix 옵션을 사용하여 잠재적으로 수정할 수 있음을 볼 수 있습니다.\n\n일부 문제를 자동으로 수정하고 싶을 경우, 다음 명령을 실행할 수 있습니다:\n\n```js\nnpm run lint:fix\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 다음과 같이 Markdown 형식으로 변경해주세요.\n\n\nThis will apply automatic fixes to your code where possible.\n\n## Automating Linting with IDE Plugins\n\nTo make the linting process even more seamless, consider installing ESLint plugins for your preferred code editor. Popular code editors like Visual Studio Code have ESLint extensions available. These extensions can highlight ESLint issues directly in your editor as you write code.\n\n## Conclusion\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 다음과 같은 중요한 작업을 다루었습니다:\n\n- 새로운 Angular 애플리케이션 생성\n- 코드에서 문제를 분석하고 확인하기 위해 ESLint 추가\n\nESLint 구성에 대해 더 자세히 알아보거나 더 고급 사용 사례를 탐색하려면 공식 ESLint 문서를 꼭 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-20-SettingUpESLintinYourAngularProject_0.png"},"coverImage":"/assets/img/2024-06-20-SettingUpESLintinYourAngularProject_0.png","tag":["Tech"],"readingTime":3},{"title":"앵귤러에서의 라우팅 가드","description":"","date":"2024-06-20 05:24","slug":"2024-06-20-RouteGuardsinAngular","content":"\n\n웹 애플리케이션에서 보안은 매우 중요합니다. Angular가 애플리케이션 보안을 도울 수 있는 한 가지 방법은 Route Guards를 통해입니다. Route Guards는 사용자가 특정 경로로 이동하거나 이동하는 것을 제어합니다. 페이지를 나갈 때 변경 사항을 저장하라는 프롬프트를 본 적이 있거나 관리자 페이지에 접근할 수 없는 경우에는 Guards를 만난 적이 있을 것입니다.\n\n이 블로그 포스트에서는 다양한 유형의 가드와 Angular 애플리케이션에서 효과적으로 사용하는 방법 및 사용 사례에 대해 논의하겠습니다.\n\n![RouteGuardsinAngular_0](/assets/img/2024-06-20-RouteGuardsinAngular_0.png)\n\n# 가드란 무엇인가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공항 안의 보안 검문 철저히 하는 가드를 생각해보세요. 일정한 조건을 기반으로 접근을 허용하거나 거부합니다. Angular에서 가드는 특정 라우트 네비게이션의 단계 전에 실행되는 스크립트입니다. 네비게이션을 진행할지 또는 재지정할지를 결정합니다. Angular의 주요 가드 유형은 다음과 같습니다:\n\n- CanActivate\n- CanActivateChild\n- CanDeactivate\n- Resolve\n- CanLoad\n\n# CanActivate\n\nCanActivate 가드는 라우트를 활성화할 수 있는지 확인합니다. 사용자 인증과 같이 특정 조건을 충족해야만 접근할 수 없어야 하는 라우트를 보호하는 데 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례: 사용자 인증\n\n인증된 사용자만 액세스할 수 있어야 하는 관리자 대시보드가 있다고 상상해보세요. CanActivate 가드는 사용자가 관리자 페이지로 이동하기 전에 로그인되어 있는지 확인할 수 있습니다. 사용자가 인증되지 않은 경우 가드가 로그인 페이지로 리디렉션합니다.\n\n## CanActivate 가드 생성하기\n\nAngular CLI를 사용하여 가드를 만들려면 다음을 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate guard auth\n```\n\n그리고 CanActivate를 구현합니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n\n  constructor(private router: Router) {}\n\n  canActivate(): boolean {\n    if (/* 여러분의 인증 조건 */) {\n      return true;\n    } else {\n      this.router.navigate(['/login']);\n      return false;\n    }\n  }\n}\n```\n\n## 라우트에 CanActivate 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가드가 준비되면 보호하려는 경로에 추가하세요:\n\n```js\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  { path: 'protected', component: ProtectedComponent, canActivate: [AuthGuard] },\n  // ...\n];\n```\n\n# CanActivateChild\n\nCanActivate과 유사하지만 하위 경로에서 작동합니다. 여러 하위 경로를 갖는 기능 모듈에 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례: 기능 접근 제어\n\n만약 당신의 어플리케이션에 \"프로필 설정\", \"계정 설정\", 그리고 \"개인 정보 설정\"과 같은 다양한 자식 경로를 가진 설정 페이지가 있다면, CanActivateChild 가드를 사용하여 적절한 권한을 가진 사용자만 이러한 자식 경로에 접근할 수 있도록 할 수 있습니다.\n\n```js\nconst childRoutes: Routes = [\n  { path: 'child', component: ChildComponent, canActivateChild: [AuthGuard] },\n  // ...\n];\n```\n\n# CanDeactivate\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 가드는 컴포넌트에서 이탈할 때 작동합니다. 사용자가 저장되지 않은 변경 사항에 대해 경고하는 데 자주 사용됩니다.\n\n## 사용 사례: 저장되지 않은 변경 사항\n\n프로필 정보를 편집하는 양식 페이지가 있습니다. 사용자가 변경 사항을 가했지만 저장하지 않고 이동하려고 할 때 CanDeactivate 가드는 변경 사항을 저장하거나 저장하지 않고 나가겠다는 확인을 요청할 수 있습니다.\n\n```js\nexport interface CanComponentDeactivate {\n canDeactivate: () =\u003e boolean;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 인터페이스를 구현하면 컴포넌트에서 사용할 수 있으며 CanDeactivate 가드에서 이를 사용할 수 있습니다.\n\n# Resolve\n\nResolve 가드는 내비게이션이 완료되기 전에 데이터를 가져옵니다. 이 데이터는 라우트 매개변수를 채우는 데 사용할 수 있습니다.\n\n## 사용 사례: 데이터 미리 로딩\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전자 상거래 애플리케이션에서 제품 상세 페이지가 있습니다. Resolve 가드는 라우트가 활성화되기 전에 제품 세부 정보를 미리 가져올 수 있으므로 사용자가 빈 페이지나 부분적으로 로드된 페이지를 보지 않게 할 수 있습니다.\n\n```js\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataResolver implements Resolve\u003cData\u003e {\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Data {\n    // 데이터를 여기서 가져옵니다\n  }\n}\n```\n\n# CanLoad\n\nCanLoad는 모듈을 지연 로드해야 하는지 여부를 확인합니다. 응용프로그램 일부를 다운로드하는 것을 방지하려면 권한이 없는 사용자가 해당 모듈을 다운로드하는 것을 막으려면 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례: 기능 게이팅\n\n귀하의 애플리케이션에는 프리미엄 기능 모듈이 있습니다. 이 모듈은 프리미엄 사용자만 액세스할 수 있으며 따라서 다운로드도 할 수 있어야 합니다. CanLoad 가드를 사용하여 미인가된 사용자가 이 모듈을 다운로드하지 못하도록하면 대역폭을 절약하고 보안을 강화할 수 있습니다.\n\n```js\nconst routes: Routes = [\n  {\n    path: 'feature',\n    loadChildren: () =\u003e import('./feature/feature.module').then(m =\u003e m.FeatureModule),\n    canLoad: [AuthGuard]\n  },\n  // ...\n];\n```\n\n# 가드 등록하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가드를 사용하려면 Angular 모듈에서 제공해야 합니다.\n\n```js\n@NgModule({\n  providers: [AuthGuard],\n  // ...\n})\nexport class AppModule {}\n```\n\nAngular의 가드는 애플리케이션 내에서 네비게이션을 효과적으로 제어하는 방법을 제공합니다. 다양한 유형의 가드를 사용하여 사용자 인증 확인, 저장되지 않은 변경 사항 알림 및 네비게이션 완료 전 데이터 사전 로드 등 다양한 조건을 처리할 수 있습니다. 개발자로서 가드를 이해하는 것은 Angular 앱의 보안 및 데이터 무결성을 보장하는 데 중요합니다.\n\n읽는 데 즐거웠으면 좋겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친하게 연락해 주세요! 트위터(@urstruly_raghu)나 링크드인(https://www.linkedin.com/in/raghuvardhan-karanam/)에서 연락 주세요.","ogImage":{"url":"/assets/img/2024-06-20-RouteGuardsinAngular_0.png"},"coverImage":"/assets/img/2024-06-20-RouteGuardsinAngular_0.png","tag":["Tech"],"readingTime":5},{"title":"아파트는 공유하지 않을 거예요","description":"","date":"2024-06-20 05:24","slug":"2024-06-20-theapartmentwewontshare","content":"\n\n![2024-06-20-theapartmentwewontshare_0.png](/assets/img/2024-06-20-theapartmentwewontshare_0.png)\n\n창밖으로 엿보지 못할 찬스가 없는 창문을 통해 햇빛이 스며들어 댄스를 추는 먼 훗날 먼 미래의 미립자들을 비추고 있습니다 – 아니, 당신 없이는. 아파트 – 여전히 엉성하게 걸린 크리스마스 조명, 4년 연속으로 키스를 나눈 자리에 놓인 킬티드를 밝히는 향수의 꿈과 속삭임의 냉혹한 메아리 – 우리 쇼파가 가져다줄 편안함을 알아볼 수 없을 것 같습니다. 계류대 상의 깨진 머그컵에 여전히 당신의 지문이 남아 있을까요? 벽들은 저희가 공유하지 않은 웃음 소리의 비밀, 싸운 적 없는 싸움, 지키지 않은 약속들을 속삭일까요?\n\n가지지 못할 개는 제가 걸어다닐 모든 공원을 쫓아다닐 것입니다. 그 개는 당신의 까불까불한 미소를 지닐 것이고, 우리가 방문했던 과거에 묶인 꿈들을 추격할 것입니다. 한때 우리의 비밀 언어였던 알쏭달쏭한 내부 농담은 내 마음의 먼지 투성이 구석에 잠들 것이고, 내 머릿속 깊은 곳에 파묻혀버리지 않을 더러운 농담들이 있을 것입니다. 제가 즐거운 어릴 적들을 키우지 않을 딸은 당신의 눈과 제 미소를 가진 아이로, '만약'의 별들과 어두운 공기로 영원히 어린시절에 갇히게 될 것입니다.\n\n이 모든 것은 제가 되지 못한 것이 우리가 필요로 한 모든 것이었기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네 악몽 속의 악마는 다른 누군가의 부담이 될 것입니다. 누군가, 아직 보이지 않은 영혼이 그 악몽의 무게를 지고, 그들의 손길은 얽힌 시트 아래 당신의 가슴에 차가운 압력을 줄 것입니다. 내 악마들은 나 안에 남아 있고 결코 떠나지 않을 것입니다. 그들을 추방하려면 나 자신의 한 부분을 끊어야 할 것이고, 그 부분은 영원히 너와 얽혀 있습니다. 나는 우리가 함께하지 않을 아파트에 너가 집으로 돌아올 수 있도록 창문을 열어둘 거야.","ogImage":{"url":"/assets/img/2024-06-20-theapartmentwewontshare_0.png"},"coverImage":"/assets/img/2024-06-20-theapartmentwewontshare_0.png","tag":["Tech"],"readingTime":1},{"title":"TypeScript, Express, TypeORM, 인증, 권한 부여 및 Postgres를 활용한 REST API 구축하기","description":"","date":"2024-06-20 05:21","slug":"2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres_0.png\" /\u003e\n\n안녕하세요! TypeScript, Express.js, 그리고 TypeORM을 활용하여 REST API를 만드는 이 튜토리얼에 오신 것을 환영합니다. 이 튜토리얼은 JWT 인증, 데이터 캐싱, 그리고 역할 기반 권한 부여를 포함하고 있습니다. 이 튜토리얼을 완료하면 이러한 핵심 개념과 기술에 대한 튼튼한 이해를 갖게 될 것입니다.\n\n## 사전 준비 사항:\n\n시작하기 전에 다음 도구에 대한 경험이나 이해가 필요합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript\n- TypeORM\n- SQL\n- Node.js \u0026 NPM\n- JSON Web Tokens (JWT)\n- Caching\n\n## ORM과 TypeORM이 무엇이며 왜 중요한가요?\n\nORM은 Object-Relational Mapping의 약자로, 객체 지향 패러다임을 사용하여 관계형 데이터베이스와 상호작용을 용이하게 하는 프로그래밍 기술 및 프레임워크입니다. ORM은 관계형 데이터베이스 (예: MySQL, PostgreSQL, SQLite)와 응용 프로그램 코드 사이의 다리 역할을 하며 복잡한 SQL 쿼리와 저수준 데이터베이스 상호작용을 추상화합니다.\n\nTypeORM은 Node.js 및 다양한 플랫폼에서 작동하는 다재다능한 ORM입니다. TypeScript 응용 프로그램에 매우 적합하며, 엔티티 및 열을 정의하기 위해 데코레이터를 사용한다는 점이 특히 잘 어울립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 캐시(캐싱)란 무엇인가요?\n\n캐싱은 컴퓨터 과학과 정보 기술에서 사용되는 기술로, 주로 액세스되거나 계산된 데이터를 \"캐시\"라고 불리는 임시 저장 영역에 저장하는 것을 말합니다. 캐싱의 주요 목적은 데이터 액세스 및 검색 속도를 향상시키고, 대기 시간을 줄이며, 전반적인 시스템 성능을 향상시키는 것입니다.\n\n이론은 이만하고, 이제 직접 해보자! 😎\n\n# 프로젝트 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트를 초기화하려면 TypeORM CLI를 사용해보세요:\n\n```js\nnpx typeorm init --name restAPi --database postgres\n```\n\n이 강좌에서는 Postgres를 데이터베이스로 사용하지만 mysql, mariadb, postgres, cockroachdb, sqlite, mssql, sap, spanner, oracle, mongodb, cordova, react-native, expo, nativescript 같은 다른 데이터베이스도 사용할 수 있어요.\n\n참고: 위 명령을 실행하기 전에 컴퓨터에 TypeORM이 전역으로 설치되어 있는지 확인하세요. 만약 없다면 간단히 아래 명령을 실행해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i -g typeorm\n```\n\nTypeorm init 명령어를 실행하면 아래 파일들이 생성됩니다:\n\n```js\nrestApi\n├── src                   // TypeScript 코드가 저장되는 위치\n│   ├── entity            // 엔티티(데이터베이스 모델)가 저장되는 위치\n│   │   └── User.ts       // 샘플 엔티티\n│   ├── migration         // 마이그레이션이 저장되는 위치\n│   ├── data-source.ts    // 데이터 소스 및 모든 연결 구성\n│   └── index.ts          // 어플리케이션의 시작점\n├── .gitignore            // 표준 gitignore 파일\n├── package.json          // 노드 모듈 의존성\n├── README.md             // 간단한 readme 파일\n└── tsconfig.json         // TypeScript 컴파일러 옵션\n```\n\n이제 추가적인 종속성을 설치해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nnpm install express dotenv bcrypt jsonwebtoken concurrently memory-cache\r\n```\n\n위에 언급된 각 패키지가 하는 일은 다음과 같습니다:\n\n- Express: Node.js를 위한 웹 프레임워크로, 서버를 생성하는 데 사용됩니다.\n- dotenv: 모든 환경 변수를 읽는 데 도움이 됩니다.\n- bcrypt: 비밀번호를 암호화하는 데 사용됩니다.\n- jsonwebtoken: 사용자를 식별하거나 사용자에 대한 정보를 전달하는 데 자주 사용되며, 웹 애플리케이션에서 인증 및 권한 부여에 토큰이 자주 사용됩니다.\n- concurrently: 단일 터미널에서 여러 npm 스크립트를 동시에 실행할 수 있게 하는 Node.js 유틸리티입니다.\n- memory-cache: Node.js를 위한 간단한 메모리 캐싱 라이브러리로, 데이터를 메모리에 저장하여 빠르게 액세스하고 검색할 수 있는 방법을 제공합니다.\n\n## 이러한 종속성들에 대한 TypeScript 타입 정의 설치:  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript로 작업하고 있으니 의존성에 대한 @types를 설치하는 것이 좋습니다.\n\n```js\nnpm i @types/express @types/bcrypt @types/jsonwebtoken @types/memory-cache\n```\n\n이제 생성된 파일을 수정해야 합니다.\n\n# 프로젝트 파일 수정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 폴더 구조:\n\n```js\nstep-by-step\n ┣ src\n ┃ ┣ controllers\n ┃ ┃ ┣ auth.controller.ts\n ┃ ┃ ┣ movie.controllers.ts\n ┃ ┃ ┗ user.controllers.ts\n ┃ ┣ dto\n ┃ ┃ ┗ user.dto.ts\n ┃ ┣ entity\n ┃ ┃ ┣ Movies.entity.ts\n ┃ ┃ ┗ User.entity.ts\n ┃ ┣ helpers\n ┃ ┃ ┗ encrypt.ts\n ┃ ┣ middleware\n ┃ ┃ ┣ errorHandler.ts\n ┃ ┃ ┣ authentification.ts\n ┃ ┃ ┗ authorization.ts\n ┃ ┣ migration\n ┃ ┃ ┣ 1698321500514-user.ts\n ┃ ┃ ┗ 1698321512351-movie.ts\n ┃ ┣ routes\n ┃ ┃ ┣ movie.routes.ts\n ┃ ┃ ┗ user.routes.ts\n ┃ ┣ data-source.ts\n ┃ ┗ index.ts\n ┣ .env\n ┣ .gitignore\n ┣ package-lock.json\n ┣ package.json\n ┣ README.md\n ┗ tsconfig.json\n```\n\n# package.json\n\n다음 종속성을 포함하여 package.json 파일을 업데이트하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"name\": \"restTye\",\n  \"version\": \"0.0.1\",\n  \"description\": \"TypeORM으로 개발된 멋진 프로젝트입니다.\",\n  \"type\": \"commonjs\",\n  \"devDependencies\": {\n    \"@types/bcrypt\": \"^5.0.1\",\n    \"@types/express\": \"^4.17.20\",\n    \"@types/jsonwebtoken\": \"^9.0.4\",\n    \"@types/memory-cache\": \"^0.2.4\",\n    \"@types/node\": \"^16.11.10\",\n    \"concurrently\": \"^8.2.2\",\n    \"ts-node\": \"10.7.0\",\n    \"typescript\": \"4.5.2\"\n  },\n  \"dependencies\": {\n    \"@types/cors\": \"^2.8.15\",\n    \"bcrypt\": \"^5.1.1\",\n    \"dotenv\": \"^16.3.1\",\n    \"express\": \"^4.18.2\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"memory-cache\": \"^0.2.0\",\n    \"pg\": \"^8.4.0\",\n    \"reflect-metadata\": \"^0.1.13\",\n    \"typeorm\": \"0.3.17\"\n  },\n  \"scripts\": {\n    \"watch\": \"tsc -w\",\n    \"dev\": \"nodemon build/index.js\",\n    \"start:dev\": \"concurrently \\\"tsc -w\\\" \\\"nodemon build/index.js\\\"\",\n    \"build\": \"tsc\",\n    \"start\": \"ts-node src/index.ts\",\n    \"typeorm\": \"typeorm-ts-node-commonjs\",\n    \"migration\": \" npm run typeorm migration:run -- -d ./src/data-source.ts\"\n  }\n}\n```\n\n필요한 종속성과 개발에 필요한 스크립트 및 마이그레이션 실행이 포함되어 있습니다. \n\nconcurrently를 사용하여 \"tsc -w\" 및 \"nodemon build/index.js\"를 동시에 실행하므로 앱을 실행하려면 npm run start:dev를 실행하면 ts 파일을 js로 컴파일한 다음 nodemon을 실행할 것입니다.\n\n# src/index.ts\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 향상된 src/index.ts 파일이 있습니다:\n\n```js\nimport { AppDataSource } from \"./data-source\";\nimport * as express from \"express\";\nimport * as dotenv from \"dotenv\";\nimport { Request, Response } from \"express\";\nimport { userRouter } from \"./routes/user.routes\";\nimport { movieRouter } from \"./routes/movie.routes\";\nimport \"reflect-metadata\";\ndotenv.config();\n\nconst app = express();\napp.use(express.json());\napp.use(errorHandler);\nconst { PORT = 3000 } = process.env;\napp.use(\"/auth\", userRouter);\napp.use(\"/api\", movieRouter);\n\napp.get(\"*\", (req: Request, res: Response) =\u003e {\n  res.status(505).json({ message: \"Bad Request\" });\n});\n\nAppDataSource.initialize()\n  .then(async () =\u003e {\n    app.listen(PORT, () =\u003e {\n      console.log(\"Server is running on http://localhost:\" + PORT);\n    });\n    console.log(\"Data Source has been initialized!\");\n  })\n  .catch((error) =\u003e console.log(error));\n```\n\n이 index.ts 파일은 Express.js 서버를 설정하고 경로를 적용하며 서버를 시작합니다. 사용자 관련 및 영화 관련 엔드포인트를 위한 라우트도 포함되어 있습니다.\n\n# src/data-source.ts\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 업데이트된 src/data-source.ts 파일입니다:\n\n이 파일은 환경 변수를 읽는 등 데이터베이스 구성을 처리합니다. .env 파일에 필요한 데이터베이스 연결 세부 정보가 포함되어 있는지 확인해주세요.\n\n```js\nimport \"reflect-metadata\";\nimport { DataSource } from \"typeorm\";\n\nimport * as dotenv from \"dotenv\";\nimport { User } from \"./entity/User.entity\";\nimport { Movie } from \"./entity/Movies.entity\";\n\ndotenv.config();\n\nconst { DB_HOST, DB_PORT, DB_USERNAME, DB_PASSWORD, DB_DATABASE, NODE_ENV } =\n  process.env;\n\nexport const AppDataSource = new DataSource({\n  type: \"postgres\",\n  host: DB_HOST,\n  port: parseInt(DB_PORT || \"5432\"),\n  username: DB_USERNAME,\n  password: DB_PASSWORD,\n  database: DB_DATABASE,\n\n  synchronize: NODE_ENV === \"dev\" ? false : false,\n//logging logs sql command on the treminal\n  logging: NODE_ENV === \"dev\" ? false : false,\n  entities: [User, Movie],\n  migrations: [__dirname + \"/migration/*.ts\"],\n  subscribers: [],\n});\n```\n\n# Entities\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것들은 데이터베이스 테이블의 구조를 정의합니다:\n\n# 사용자 엔터티\n\n```js\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n} from \"typeorm\";\n\n@Entity({ name: \"users\" })\nexport class User {\n  @PrimaryGeneratedColumn(\"uuid\")\n  id: string;\n\n  @Column({ nullable: false })\n  name: string;\n\n  @Column({ nullable: false })\n  email: string;\n\n  @Column({ nullable: false })\n  password: string;\n\n  @Column({ default: \"user\" })\n  role: string;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n}\n```\n\n# 영화 엔터티\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {\n  Column,\n  CreateDateColumn,\n  Entity,\n  PrimaryGeneratedColumn,\n  UpdateDateColumn,\n} from \"typeorm\";\n\n@Entity({ name: \"movies\" })\nexport class Movie {\n  @PrimaryGeneratedColumn(\"uuid\")\n  id: string;\n\n  @Column({ nullable: false })\n  title: string;\n\n  @Column({ nullable: false })\n  description: string;\n\n  @Column({ nullable: false })\n  director: string;\n\n  @Column({ nullable: false })\n  year: number;\n\n  @Column({ nullable: false })\n  rating: string;\n\n  @Column({ nullable: false })\n  image: string;\n\n  @Column({ nullable: false })\n  cast: string;\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n}\n```\n\n나는 uuid를 사용하고 있지만 rowid나 incremental 등 다른 것을 사용할 수도 있고, 필드가 비어있지 않도록 하기 위해 nullable 옵션을 false로 전달하고 있습니다.\n\nsrc/helpers/helpers.ts\n\nEncrypt 클래스는 비밀번호를 암호화하고, 로그인 프로세스를 위해 비교하며 토큰을 생성하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport * as jwt from \"jsonwebtoken\";\nimport * as bcrypt from \"bcrypt\";\nimport * as dotenv from \"dotenv\";\nimport { payload } from \"../dto/user.dto\";\n\ndotenv.config();\nconst { JWT_SECRET = \"\" } = process.env;\nexport class encrypt {\n  static async encryptpass(password: string) {\n    return bcrypt.hashSync(password, 12);\n  }\n  static comparepassword(hashPassword: string, password: string) {\n    return bcrypt.compareSync(password, hashPassword);\n  }\n\n  static generateToken(payload: payload) {\n    return jwt.sign(payload, JWT_SECRET, { expiresIn: \"1d\" });\n  }\n}\n```\n\n# Middleware\n\n# Error Handling\n\nsrc/middlewares/error.middleware.ts에서 전역 오류 처리 미들웨어를 설정해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { NextFunction, Request, Response } from \"express\";\n\nexport const errorHandler = (\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) =\u003e {\n  console.error(`Error: ${error.message}`);\n  return res.status(500).json({ message: \"내부 서버 오류\" });\n};\n```\n\n# 인증 및 권한 부여 미들웨어\n\nsrc/middlewares/auth.middleware.ts에서 인증 및 권한 부여 미들웨어를 구현하십시오:\n\n```js\nimport { NextFunction, Request, Response } from \"express\";\nimport * as jwt from \"jsonwebtoken\";\nimport * as dotenv from \"dotenv\";\ndotenv.config();\n\nexport const authentification = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) =\u003e {\n  const header = req.headers.authorization;\n  if (!header) {\n    return res.status(401).json({ message: \"인가되지 않음\" });\n  }\n  const token = header.split(\" \")[1];\n  if (!token) {\n    return res.status(401).json({ message: \"인가되지 않음\" });\n  }\n  const decode = jwt.verify(token, process.env.JWT_SECRET);\n  if (!decode) {\n    return res.status(401).json({ message: \"인가되지 않음\" });\n  }\n  req[\"currentUser\"] = decode;\n  next();\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청에 인증 속성을 포함하는 헤더가 있는지 확인합니다. 그런 속성이 없는 경우에는 권한이 없음을 반환합니다. 사용자는 특정 경로에 액세스할 수 없습니다. 속성이 있는 경우에는 해당 토큰을 추출한 다음 그 토큰을 생성할 때 사용한 비밀 키로 복호화합니다. 그 토큰의 데이터가 올바른 경우 토큰에 있는 데이터를 요청에 전달하여 애플리케이션의 나머지 부분에서 사용할 수 있습니다. 토큰이 복호화되지 않으면 다음 함수가 호출되지 않습니다.\n\n```js\nimport { NextFunction, Request, Response } from \"express\";\nimport { AppDataSource } from \"../data-source\";\nimport { User } from \"../entity/User.entity\";\n\nexport const authorization = (roles: string[]) =\u003e {\n  return async (req: Request, res: Response, next: NextFunction) =\u003e {\n    const userRepo = AppDataSource.getRepository(User);\n    const user = await userRepo.findOne({\n      where: { id: req[\" currentUser\"].id },\n    });\n    console.log(user);\n    if (!roles.includes(user.role)) {\n      return res.status(403).json({ message: \"Forbidden\" });\n    }\n    next();\n  };\n};\n```\n\n# 사용자 데이터를 user.dto.ts로 사용자 정의하기\n\nAPI 응답에 전송된 사용자 데이터를 맞춤 설정하는 데 user.dto.ts 파일을 활용하고자 하는 관심이 표현되었습니다. 이 특정 파일은 제공된 코드 샘플에 명시적으로 포함되지는 않았지만, API 응답을 위해 구조화하고 수정할 데이터를 형성하는 강력한 도구로 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## user.dto.ts이 무엇인가요?\n\nuser.dto.ts 파일은 Data Transfer Object의 약자로, API로부터 응답으로 전송되기 전 사용자 데이터의 형식과 내용을 정밀하게 사용자 정의할 수 있게 합니다. 이 파일 안에 특정 인터페이스, 구조 또는 변환 로직을 정의함으로써, 개발자는 응용 프로그램 또는 API를 사용하는 클라이언트의 요구 사항과 사용자 데이터를 정확하게 맞출 수 있습니다. 그리고 일부 사용자 데이터를 보안할 수 있습니다.\n\n## user.dto.ts 활용하기\n\n다음은 user.dto.ts 파일을 구조화하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport class UserResponce {\n  name: string;\n  email: string;\n  role: string;\n}\n```\n\n## 사용 방법\n\nAPI 응답에서 사용자 데이터의 사용자 정의가 필요한 시나리오에서는 user.dto.ts 파일을 활용할 수 있습니다. 응답으로 보낼 원하는 형식에 맞는 UserDTO 인터페이스의 구조를 정의한 후 응답으로 보내세요.\n\n이 접근 방식은 API 응답을 특정 요구 사항에 맞게 유연하게 조정하여 응용 프로그램의 상호 운용성과 효율성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트에 맞게 user.dto.ts 파일을 통합 및 조정하고, API 엔드포인트를 통해 전송되는 데이터를 정확하게 제어할 수 있습니다.\n\n이 프로젝트의 경우, 저는 다음과 같이 사용했을 것입니다:\n\n```js\nimport { Request, Response } from \"express\";\nimport { AppDataSource } from \"../data-source\";\nimport { User } from \"../entity/User.entity\";\nimport { encrypt } from \"../helpers/encrypt\";\nimport { UserResponce } from \"../dto/user.dto\"; // 올바른 경로에서 UserDto를 가져옵니다\nimport * as cache from \"memory-cache\";\n\nexport class UserController {\n  static async signup(req: Request, res: Response) {\n    const { name, email, password, role } = req.body;\n    const encryptedPassword = await encrypt.encryptpass(password);\n    const user = new User();\n    user.name = name;\n    user.email = email;\n    user.password = encryptedPassword;\n    user.role = role;\n\n    const userRepository = AppDataSource.getRepository(User);\n    await userRepository.save(user);\n    \n    // 응답으로 보내는 데이터 구조화를 위해 UserResponse DTO 사용\n    const userDataSent = new UserResponce();\n    userDataSent.name = user.name;\n    userDataSent.email= user.email;\n    userDataSent.role = user.role;\n    \n    const token = encrypt.generateToken({ id: user.id });\n\n    return res\n      .status(200)\n      .json({ message: \"사용자가 성공적으로 생성되었습니다\", token, userDataSent });\n  }\n}\n```\n\nUserResponse 클래스가 UserController 파일로 올바르게 가져와지고 속성들이 API 응답에 전송할 데이터와 일치하는지 확인하세요. 이 접근 방식을 사용하면 API 엔드포인트를 통해 전송되는 사용자 데이터를 정확하게 사용자 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 컨트롤러\n\n사용자 및 영화 엔티티에 대한 컨트롤러 메소드를 정의하세요:\n\n컨트롤러는 클라이언트(일반적으로 웹 브라우저)로부터 수신한 요청을 처리하고 응용 프로그램의 로직을 조정하는 구성 요소입니다. 컨트롤러는 응용 프로그램의 관심사를 분리하는 데 중요한 역할을 하며, 코드를 구성하고 유지보수할 수 있도록 도와줍니다. 우리의 getalluser 및 getmovies에서 캐시 메모리에서 데이터를 가져오려고 하는 데, 존재한다면 캐시에서 가져오고, 그렇지 않은 경우 데이터베이스에서 가져온 후 캐시에 일정 시간 동안 넣습니다.\n\n# Auth Controller (src/controllers/Auth.controller.ts)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## 사용자 컨트롤러 (src/controllers/user.controller.ts)\n\n```js\nimport { Request, Response } from \"express\";\nimport { AppDataSource } from \"../data-source\";\nimport { User } from \"../entity/User.entity\";\nimport { encrypt } from \"../helpers/encrypt\";\nimport * as cache from \"memory-cache\";\n\nexport class UserController {\n  static async signup(req: Request, res: Response) {\n    const { name, email, password, role } = req.body;\n    const encryptedPassword = await encrypt.encryptpass(password);\n    const user = new User();\n    user.name = name;\n    user.email = email;\n    user.password = encryptedPassword;\n    user.role = role;\n\n    const userRepository = AppDataSource.getRepository(User);\n    await userRepository.save(user);\n\n    // userRepository.create({ Name, email, password });\n    const token = encrypt.generateToken({ id: user.id });\n\n    return res\n      .status(200)\n      .json({ message: \"User created successfully\", token, user });\n  }\n  static async getUsers(req: Request, res: Response) {\n    const data = cache.get(\"data\");\n    if (data) {\n      console.log(\"serving from cache\");\n      return res.status(200).json({\n        data,\n      });\n    } else {\n      console.log(\"serving from db\");\n      const userRepository = AppDataSource.getRepository(User);\n      const users = await userRepository.find();\n\n      cache.put(\"data\", users, 6000);\n      return res.status(200).json({\n        data: users,\n      });\n    }\n  }\n  static async updateUser(req: Request, res: Response) {\n    const { id } = req.params;\n    const { name, email } = req.body;\n    const userRepository = AppDataSource.getRepository(User);\n    const user = await userRepository.findOne({\n      where: { id },\n    });\n    user.name = name;\n    user.email = email;\n    await userRepository.save(user);\n    res.status(200).json({ message: \"udpdate\", user });\n  }\n\n  static async deleteUser(req: Request, res: Response) {\n    const { id } = req.params;\n    const userRepository = AppDataSource.getRepository(User);\n    const user = await userRepository.findOne({\n      where: { id },\n    });\n    await userRepository.remove(user);\n    res.status(200).json({ message: \"ok\" });\n  }\n}\n```\n\n# 영화 컨트롤러 (src/controllers/movie.controller.ts)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Request, Response } from \"express\";\nimport * as cache from \"memory-cache\";\nimport { AppDataSource } from \"../data-source\";\nimport { Movie } from \"../entity/Movies.entity\";\n\nexport class MovieController {\n  static async getAllMovies(req: Request, res: Response) {\n    const data = cache.get(\"data\");\n    if (data) {\n      console.log(\"캐시에서 제공 중\");\n      return res.status(200).json({\n        data,\n      });\n    } else {\n      console.log(\"데이터베이스에서 제공 중\");\n      const movieRepository = AppDataSource.getRepository(Movie);\n      const movies = await movieRepository.find();\n      cache.put(\"data\", movies, 10000);\n      return res.status(200).json({\n        data: movies,\n      });\n    }\n  }\n  static async createMovie(req: Request, res: Response) {\n    const { title, description, director, year, rating, image, cast } =\n      req.body;\n    const movie = new Movie();\n    movie.title = title;\n    movie.description = description;\n    movie.director = director;\n    movie.year = year;\n    movie.rating = rating;\n    movie.image = image;\n    movie.cast = cast;\n    const movieRepository = AppDataSource.getRepository(Movie);\n    await movieRepository.save(movie);\n    return res\n      .status(200)\n      .json({ message: \"영화가 성공적으로 생성되었습니다\", movie });\n  }\n\n  static async updateMovie(req: Request, res: Response) {\n    const { id } = req.params;\n    const { title, description, director, year, rating, image, cast } =\n      req.body;\n    const movieRepository = AppDataSource.getRepository(Movie);\n    const movie = await movieRepository.findOne({\n      where: { id },\n    });\n    movie.title = title;\n    movie.description = description;\n    movie.director = director;\n    movie.year = year;\n    movie.rating = rating;\n    movie.image = image;\n    movie.cast = cast;\n    await movieRepository.save(movie);\n    return res\n      .status(200)\n      .json({ message: \"영화가 성공적으로 업데이트되었습니다\", movie });\n  }\n\n  static async deleteMovie(req: Request, res: Response) {\n    const { id } = req.params;\n    const movieRepository = AppDataSource.getRepository(Movie);\n    const movie = await movieRepository.findOne({\n      where: { id },\n    });\n    await movieRepository.remove(movie);\n    return res\n      .status(200)\n      .json({ message: \"영화가 성공적으로 삭제되었습니다\", movie });\n  }\n}\n```\n\n# 사용자 라우팅\n\nsrc/routes/user.routes.ts 파일에 사용자 관리와 관련된 라우트를 정의하십시오:\n\n라우트는 웹 애플리케이션 내에서 클라이언트가 다양한 작업을 수행하거나 특정 리소스를 요청할 수 있는 특정 URL 또는 엔드포인트를 가리킵니다. 라우트는 수신된 HTTP 요청에 대한 웹 애플리케이션이 응답하는 방식을 정의하는 데 중요한 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nimport * as express from \"express\";\nimport { authentification } from \"../middleware/authentification\";\nimport { UserController } from \"../controllers/user.controllers\";\nimport { authorization } from \"../middleware/authorization\";\nimport { AuthController } from \"../controllers/auth.controller\";\nconst Router = express.Router();\n\nRouter.get(\n  \"/users\",\n  authentification,\n  authorization([\"admin\"]),\n  UserController.getUsers\n);\nRouter.get(\n  \"/profile\",\n  authentification,\n  authorization([\"user\", \"admin\"]),\n  AuthController.getProfile\n);\nRouter.post(\"/signup\", UserController.signup);\nRouter.post(\"/login\", AuthController.login);\nRouter.put(\n  \"/update/:id\",\n  authentification,\n  authorization([\"user\", \"admin\"]),\n  UserController.updateUser\n);\nRouter.delete(\n  \"/delete/:id\",\n  authentification,\n  authorization([\"admin\"]),\n  UserController.deleteUser\n);\nexport { Router as userRouter };\n```\n\n# 영화 라우트\n\n```javascript\nimport * as express from \"express\";\nimport { authentification } from \"../middleware/authentification\";\nimport { MovieController } from \"../controllers/movie.controllers\";\nimport { authorization } from \"../middleware/authorization\";\n\nconst Router = express.Router();\n\nRouter.get(\"/movies\", authentification, MovieController.getAllMovies);\nRouter.post(\"/movies\", authentification, MovieController.createMovie);\n\nRouter.put(\n  \"/movies/:id\",\n  authentification,\n  authorization([\"admin\"]),\n  MovieController.updateMovie\n);\nRouter.delete(\n  \"/movies/:id\",\n  authentification,\n  authorization([\"admin\"]),\n  MovieController.deleteMovie\n);\nexport { Router as movieRouter };\n```\n\n# 미들웨어 순서 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 미들웨어를 정의된 순서대로 실행합니다. 라우트 정의 시에 올바른 순서로 미들웨어를 배치하는 것이 중요합니다.\n\n예를 들어 사용자 라우트의 경우, 우리는 두 개의 미들웨어 함수인 authenticate와 authorize가 있습니다. authenticate는 사용자의 신원을 확인하기 때문에 먼저 와야 합니다. authorize는 그 다음에 위치하여 사용자가 적절한 역할을 가지고 있는지 확인합니다.\n\n# 이주\n\n우리는 엔티티에 대한 마이그레이션을 생성하고 실행해야 합니다. 이로써 해당 데이터베이스 테이블이 생성됩니다. 문서에 나와 있는 대로 수행해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령어는 src/migration 디렉토리에 마이그레이션 파일을 생성합니다. 생성된 마이그레이션 파일을 편집하여 테이블 구조를 정의하고 아래 코드에 나와 있는 대로 마이그레이션을 실행하세요.\n\n```js\ntypeorm migration:create ./migrations/users\n```\n\n```js\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\n\nexport class User1698321500514 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise\u003cvoid\u003e {\n// 여기에 직접 추가할 부분\n    await queryRunner.query(\n      ` \n          --테이블 정의\n          CREATE TABLE \"users\"  (\n            \"id\" uuid NOT NULL DEFAULT uuid_generate_v4(),\n            \"name\" character varying NOT NULL,\n            \"email\" character varying NOT NULL,\n            \"password\" character varying NOT NULL,\n            \"role\"  character varying NOT NULL DEFAULT 'user',\n            \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),\n            \"updatedAt\" TIMESTAMP NOT NULL DEFAULT now(),\n            CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\")\n          )\n\n          \n          \n          \n          \n          `\n    ),\n      undefined;\n  }\n\n  public async down(queryRunner: QueryRunner): Promise\u003cvoid\u003e {\n// 그리고 이 부분\n    await queryRunner.query(`DROP TABLE \"users\"`, undefined);\n  }\n}\n```\n\n```js\nimport { MigrationInterface, QueryRunner } from \"typeorm\";\n\nexport class Movie1698321512351 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise\u003cvoid\u003e {\n    await queryRunner.query(`\n        --테이블 정의\n        CREATE TABLE \"movies\"  (\n            \"id\" uuid NOT NULL DEFAULT uuid_generate_v4(),\n            \"title\" character varying NOT NULL,\n            \"description\" character varying NOT NULL,\n            \"director\" character varying NOT NULL,\n            \"year\" integer NOT NULL,\n            \"rating\" character varying NOT NULL,\n            \"image\" character varying NOT NULL,\n            \"cast\" character varying NOT NULL,\n            \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),\n            \"updatedAt\" TIMESTAMP NOT NULL DEFAULT now(),\n            CONSTRAINT \"PK_1031171c13130102495201e3e20\" PRIMARY KEY (\"id\")\n          )\n          \n          \n          \n          \n          \n          `),\n      undefined;\n  }\n\n  public async down(queryRunner: QueryRunner): Promise\u003cvoid\u003e {\n    await queryRunner.query(`DROP TABLE \"movies\"`, undefined);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지 JSON 파일에 데이터베이스 마이그레이션을 실행하기 위한 스크립트를 추가해야 합니다:\n\n```js\n   \"migration\": \" npm run typeorm migration:run -- -d ./src/data-source.ts\"\n```\n\ndata-source.ts 파일은 데이터베이스 구성이 저장된 위치입니다.\n\n# 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI를 테스트하려면 Postman, cURL 또는 다른 HTTP 클라이언트와 같은 도구를 사용할 수 있습니다. API 엔드포인트에 요청을 보내어 제대로 작동하는지 확인할 수 있습니다.\n\n# 오류 처리\n\n제공된 errorHandler 미들웨어에서 처리되지 않은 오류가 발생하면 해당 오류가 기록되고 일반적인 오류 응답이 클라이언트에게 전송됩니다. 이 미들웨어를 사용자 정의하여 오류 처리 요구 사항에 맞게 조정할 수 있습니다.\n\n맺음말\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번 튜토리얼에서는 TypeScript, Express.js 및 TypeORM을 사용하여 강력한 REST API를 만드는 여정에 출발했습니다. 이 과정에서 인증, 권한 부여 및 데이터베이스 상호 작용과 같은 기본 개념을 탐험했습니다. 우리가 배운 내용을 되짚어봅시다:\n\n- Object-Relational Mapping (ORM)의 중요성과 특히 TypeScript 애플리케이션에서 데이터베이스 상호 작용을 간소화하는 TypeORM에 대해 이해했습니다.\n- 캐싱은 데이터 액세스 및 검색 속도를 향상시키는 기술로 명료하게 설명되었으며 시스템 성능을 향상했습니다.\n- 프로젝트를 설정하고 종속성을 설치하고 중요한 구성 파일을 설정했습니다.\n\n이제 이 지식을 바탕으로 견고한 웹 애플리케이션을 만들 준비가 되었습니다. 하지만 기억하세요, 이것은 시작에 불과합니다. 탐험할 거대한 웹 개발 세계가 기다리고 있으며 더 깊이 파고들고 고급 주제를 더 탐구하고 API 기능을 확장하는 것을 장려합니다.\n\n이 학습 여정에 함께해 주셔서 기쁩니다. 궁금한 점이 있거나 피드백이나 경험을 공유하고 싶다면 망설이지 말고 연락해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발의 끊임없이 발전하는 세계에서는 항상 배울 것이 더 많고 만들 것이 더 많습니다. 계속 코딩하고, 계속 탐험하고, 놀라운 것을 계속 만들어 보세요. 웹은 당신의 캔버스이며, 당신이 아티스트입니다.\n\n이 튜토리얼의 일부가 되어 주셔서 감사합니다. 앞으로의 프로젝트에서 행운을 빕니다!\n\n제 GitHub에서 전체 프로젝트를 확인할 수 있습니다.\n\n이것으로 우리의 튜토리얼을 마칩니다. 유용하게 활용하셨다면 박수를 치거나 댓글을 남겨주세요. 제안이나 피드백은 언제나 환영합니다. 또한 Twitter, LinkedIn, GitHub에서 저와 소통하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingaRESTAPIwithTypeScriptExpressTypeORMAuthenticationAuthorizationandPostgres_0.png","tag":["Tech"],"readingTime":25}],"page":"35","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"35"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>