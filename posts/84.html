<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/84" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/84" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Angular HttpContext를 이해하는 진짜 간단한 사용 사례와 이전 버전에서의 대안" href="/post/2024-05-16-AngularArealandsimpleuse-caseforunderstandingHttpContextanditsalternativeinlowerversions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular HttpContext를 이해하는 진짜 간단한 사용 사례와 이전 버전에서의 대안" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-AngularArealandsimpleuse-caseforunderstandingHttpContextanditsalternativeinlowerversions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular HttpContext를 이해하는 진짜 간단한 사용 사례와 이전 버전에서의 대안" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular HttpContext를 이해하는 진짜 간단한 사용 사례와 이전 버전에서의 대안</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 깨끗하고 유지보수가 쉬운 코드를 위한 최고의 실천 방법" href="/post/2024-05-16-TypeScriptBestPracticesforCleanandMaintainableCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 깨끗하고 유지보수가 쉬운 코드를 위한 최고의 실천 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-TypeScriptBestPracticesforCleanandMaintainableCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 깨끗하고 유지보수가 쉬운 코드를 위한 최고의 실천 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">TypeScript 깨끗하고 유지보수가 쉬운 코드를 위한 최고의 실천 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년을 위한 16가지 최고의 루비 프레임워크" href="/post/2024-05-16-16BestRubyFrameworksforWebDevelopment2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년을 위한 16가지 최고의 루비 프레임워크" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년을 위한 16가지 최고의 루비 프레임워크" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년을 위한 16가지 최고의 루비 프레임워크</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기" href="/post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가치 사슬 관리를 위한 데이터 과학" href="/post/2024-05-16-DataScienceforValue-ChainManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가치 사슬 관리를 위한 데이터 과학" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-DataScienceforValue-ChainManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가치 사슬 관리를 위한 데이터 과학" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">가치 사슬 관리를 위한 데이터 과학</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 심층 탐구 React의 useEffect 및 Objectis 함정 탐색" href="/post/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 심층 탐구 React의 useEffect 및 Objectis 함정 탐색" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 심층 탐구 React의 useEffect 및 Objectis 함정 탐색" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">자바스크립트 심층 탐구 React의 useEffect 및 Objectis 함정 탐색</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReacType v21 소개 React 개발의 진입 장벽을 낮추고 품질 높이기" href="/post/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReacType v21 소개 React 개발의 진입 장벽을 낮추고 품질 높이기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReacType v21 소개 React 개발의 진입 장벽을 낮추고 품질 높이기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">ReacType v21 소개 React 개발의 진입 장벽을 낮추고 품질 높이기</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RocksDB를 사용한 서버 부팅 속도 최적화" href="/post/2024-05-16-ServerbootstrapoptimizationusingRocksDB"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RocksDB를 사용한 서버 부팅 속도 최적화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RocksDB를 사용한 서버 부팅 속도 최적화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">RocksDB를 사용한 서버 부팅 속도 최적화</strong><div class="PostList_meta__VCFLX"><span class="date">May 16, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="규모 확장 가능한 개인 정보 보호 GenAI GPU 없이 텍스트 익명화하여 1100의 비용으로" href="/post/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="규모 확장 가능한 개인 정보 보호 GenAI GPU 없이 텍스트 익명화하여 1100의 비용으로" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="규모 확장 가능한 개인 정보 보호 GenAI GPU 없이 텍스트 익명화하여 1100의 비용으로" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">규모 확장 가능한 개인 정보 보호 GenAI GPU 없이 텍스트 익명화하여 1100의 비용으로</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="흑자 블랙 바스타의 코발트 스트라이크를 추적하기" href="/post/2024-05-15-HuntingBlackBastasCobaltStrike"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="흑자 블랙 바스타의 코발트 스트라이크를 추적하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="흑자 블랙 바스타의 코발트 스트라이크를 추적하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">흑자 블랙 바스타의 코발트 스트라이크를 추적하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 15, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link posts_-active__YVJEi" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Angular HttpContext를 이해하는 진짜 간단한 사용 사례와 이전 버전에서의 대안","description":"","date":"2024-05-16 03:21","slug":"2024-05-16-AngularArealandsimpleuse-caseforunderstandingHttpContextanditsalternativeinlowerversions","content":"\n\n이런 경우를 겪어 보셨나요? HTTP 요청들에 대해 캐싱, 스피너 보여주지 않기, 오류 추적하기 등의 작업을 대부분의 요청에 대해 수행하고 싶지만, 일부 요청에는 이 작업을 실행하고 싶지 않거나 그 반대로 수행하고 싶지 않은 경우가 있습니다.\n\n각 요청에 컨텍스트를 추가하여 HttpRequests 간에 차이를 두실 수 있습니다. 이 컨텍스트에는 요청에 관한 메타데이터가 포함되어 있어서 인터셉터가 요청 간의 차이점을 구분할 수 있습니다.\n\nHttpContext는 Angular V12+ 버전부터 추가된 기능입니다. 그렇다면 낮은 버전의 Angular은 이러한 시나리오를 어떻게 처리할까요? 이 스토리에서 이러한 질문들에 대한 대답을 제공해 드리겠습니다.\n\n저는 간단한 예시를 들어 설명드리겠습니다. HTTP 오류를 추적하고 오류 내용을 데이터베이스에 저장하여 나중에 디버깅하는 API가 있다고 가정해 보겠습니다.\n\n\n\n아래는 API를 호출하여 HTTP 오류를 추적하는 TrackErrorService입니다.\n\n이제 오류를 추적해야 하는 HttpRequest도 필요합니다. 우리는 존재하지 않는 사용자의 세부 정보를 가져오기 위해 GET 요청을 수행하고 있습니다. 이 API 호출은 404 오류로 실패할 것입니다.\n\nTestInterceptorService로 넘어가면,\n\n인터셉터는 AppModule의 providers에 등록되어 있습니다.\n\n\n\n```js\n{\nprovide: HTTP_INTERCEPTORS,\nuseClass: TestInterceptorService,\nmulti: true,\n},\n```\n\n위의 인터셉터 서비스에는 어떤 문제가 있나요?\n\nHttpRequest 중에 오류가 발생하면 catchError 연산자가 실행되어 아래 2개의 observable을 순차적으로 실행합니다:\n\n```ts\nthis.trackErrorService.trackError(err)\n```\n\n\n\n\n`throwError(err)\n\ntrackError() 메서드는 TrackErrorService의 첫 번째 observable을 반환하는데, 이는 HttpRequest를 실행할 때 발생한 오류를 추적할 것입니다.\n\nthrowError() rxjs 연산자에 의해 반환된 두 번째 observable은 오류를 구성 요소나 전역 핸들러 클래스(즉, 내장 ErrorHandler 클래스를 구현한)로 다시 던질 것입니다. 이후 추가 조치를 취할 수 있습니다.\n\n만약 HTTP 오류를 추적하는 첫 번째 observable 자체에 오류가 발생하면 어떻게 될까요? 브라우저 창을 닫을 때까지 TrackErrorService의 trackError() 메서드가 무한히 호출되어 루프에 갇히게 됩니다.\n\n\n\n\nI. HttpContext를 사용하여 메타데이터 전달하기\n\n여기서 2개의 HttpRequests를 구별해야 할 필요가 생깁니다. 우리는 track error API 자체를 제외한 모든 HttpRequest에 대한 오류를 추적하고 싶습니다. 따라서 Interceptor와 TrackErrorService 클래스를 수정하여 HttpContext를 추가하겠습니다.\n\n아래는 업데이트된 TestInterceptorService입니다.\n\n다음은 우리가 한 변경사항입니다:\n\n\n\n- HttpContextToken 클래스를 사용하여 컨텍스트 토큰을 생성했습니다. 이 토큰은 errorsToBeTracked라는 상수에 저장되어 있습니다. 이 토큰을 사용하여 HttpContext에 저장된 값에 액세스하고 조작할 것입니다. 이 토큰의 기본값은 true로, 람다 함수 () =\u003e `true`에서 확인할 수 있습니다. 이 토큰의 기본값이 true인 것은 기본적으로 모든 HTTP 요청이 오류 추적 대상임을 의미합니다.\n\n```js\nexport const errorsToBeTracked = new HttpContextToken\u003cboolean\u003e(() =\u003e true);\n```\n\n2. intercept() 내부에서 errorsToBeTracked 토큰의 값을 확인하기 위한 IF 조건을 추가했습니다. 해당 토큰이 true인 경우, HttpRequest에 대한 오류를 추적해야 한다는 것을 의미합니다. 토큰 값이 false인 경우, HttpRequest에 대한 오류를 추적하지 말아야 합니다.\n\n```js\ncatchError((err) =\u003e {\n\nif (req.context.get(errorsToBeTracked)) {\nconsole.log('오류가 추적될 것입니다');\nreturn concat(this.trackErrorService.trackError(err), throwError(err));\n} \nelse {\nconsole.log('오류가 추적되지 않을 것입니다');\nreturn throwError(err);\n}\n\n})\n```\n\n\n\n현재 HttpContext에 저장된 토큰 errorsToBeTracked의 값을 어떻게 읽고 있나요?\n\n현재 HttpRequest의 context에 저장된 token errorsToBeTracked의 값을 읽기 위해 HttpContext의 get()을 사용하고 있습니다.\n\n```js\nreq.context.get(errorsToBeTracked)\n```\n\n토큰 값이 true이면, TrackErrorService의 trackError()를 사용하여 에러를 추적하고, 에러를 컴포넌트/전역 에러 핸들러로 다시 던집니다.\n\n\n\n토큰 값이 false이면 오류를 추적하지 않고, 대신에 오류를 컴포넌트/전역 오류 핸들러로 다시 던집니다.\n\n다음은 업데이트된 TrackErrorService입니다:\n\n우리는 trackError()를 업데이트하여 이 HttpRequest에 대해 HttpContext에서 errorsToBeTracked 토큰의 기본 값을 true에서 false로 재정의했습니다.\n\n데모\n\n\n\n저희 애플리케이션은 이렇게 생겼어요. \"사용자 불러오기\" 버튼이 있습니다. 이 버튼을 클릭하면 TestService의 getUsersData()를 호출하게 됩니다.\n\n존재하지 않는 사용자를 불러오기 위한 API는 예상대로 404 에러로 실패했어요.\n\n위의 HttpRequest가 실패할 때 catchError 연산자가 실행되는데, 우리는 HttpRequest의 컨텍스트에 있는 토큰 값이 true 또는 false인지 확인하고 있어요. HttpRequest 내 토큰 값이 기본적으로 true인데, TestService 내에서 이 값을 재정의하지 않았기 때문에 이 HttpRequest에 대해 값은 여전히 true로 유지되어요.\n\n따라서 오류를 추적하는 API가 호출된 적이 한 번 있으며, 이 역시 실패했어요. 이 HttpRequest의 컨텍스트 토큰 값이 false이기 때문에 오류 추적 API가 또 호출되지는 않았어요.\n\n\n\nII. 헤더를 사용하여 메타데이터 전달하기\n\nHttpContext는 V12 이하의 Angular 버전에서 사용할 수 없기 때문에 이 시나리오를 어떻게 처리할 수 있을까요? 요청 헤더를 사용합니다.\n\nTrackErrorService가 다음과 같이 업데이트되었습니다. trackError() 내에서 사용자 정의 헤더 \"allow-error-track\"을 값 \"no\"와 함께 전달합니다. 이는 이 HttpRequest에 대한 오류를 추적하고 싶지 않다는 것을 의미합니다.\n\nTestService가 다음과 같이 업데이트되었습니다. getUsersData() 내에서 사용자 정의 헤더 \"allow-error-track\"을 값 \"yes\"와 함께 전달합니다. 이는 이 HttpRequest에 대한 오류를 추적하고 싶다는 것을 의미합니다.\n\n\n\n다른 인터셉터 서비스를 생성해 보겠습니다: AlternativeInterceptorService.\n\n이 접근법을 테스트하려면 TestInterceptorService를 주석 처리하고 AppModule의 providers에 AlternativeInterceptorService를 등록하면 됩니다.\n\n```js\nproviders: [\n  //아래 시나리오 토큰을 위해 주석 처리를 해제하세요\n  // {\n  // provide: HTTP_INTERCEPTORS,\n  // useClass: TestInterceptorService,\n  // multi: true,\n  // },\n\n  //사용자 정의 헤더 접근법\n  {\n    provide: HTTP_INTERCEPTORS,\n    useClass: AlternativeInterceptorService,\n    multi: true,\n  },\n],\n```\n\n이 인터셉터는 TestInterceptorService와 매우 유사합니다. 차이점은 HttpRequest에 대한 오류를 추적할지 여부를 결정하는 조건에 있습니다.\n\n\n\n- 우리는 사용자 정의 요청 헤더 \"allow-error-track\"의 값을 확인하고 그 값을 상수인 shouldErrorsBeTracked에 저장하고 있습니다. 그런 다음 사용자 정의 \"allow-error-track\" 헤더를 삭제한 후에 HttpRequest의 클론을 생성하고 있습니다. 결과적으로 복제된 요청은 이 사용자 정의 헤더를 가지고 있지 않을 것입니다.\n\n```js\nconst shouldErrorsBeTracked = req.headers.get('allow-error-track');\n\nlet modifiedRequest = req.clone({\nheaders: req.headers.delete('allow-error-track'),\n});\n```\n\n2. 마지막으로 HttpRequest가 실패하는 경우 catchError 연산자가 실행됩니다. 여기서는 상수 shouldErrorsBeTracked의 값을 확인하고 있습니다.\n\n만약 상수가 \"no\" 값을 포함하고 있다면, 해당 HttpRequest에 대한 오류를 추적할 필요가 없고, 컴포넌트/전역 오류 핸들러 클래스로 간단히 전달될 것을 의미합니다.\n\n\n\n만약 상수에 \"yes\"가 포함되어 있다면, HttpRequest에 해당하는 오류를 추적해야 함을 의미합니다. 따라서 오류 추적 API가 호출되고, 그 다음에 오류가 컴포넌트/글로벌 오류 핸들러로 반환됩니다.\n\n```js\nreturn next.handle(modifiedRequest).pipe(\ncatchError((err) =\u003e {\n\nif (shouldErrorsBeTracked === ‘yes’) {\nconsole.log(‘error will be tracked’);\nreturn concat(this.trackErrorService.trackError(err),throwError(err));\n} \nelse {\nconsole.log(‘error will not be tracked’);\nreturn throwError(err);\n}\n})\n);\n```\n\n아래는 작동 예시입니다:","ogImage":{"url":"/assets/img/2024-05-16-AngularArealandsimpleuse-caseforunderstandingHttpContextanditsalternativeinlowerversions_0.png"},"coverImage":"/assets/img/2024-05-16-AngularArealandsimpleuse-caseforunderstandingHttpContextanditsalternativeinlowerversions_0.png","tag":["Tech"],"readingTime":6},{"title":"TypeScript 깨끗하고 유지보수가 쉬운 코드를 위한 최고의 실천 방법","description":"","date":"2024-05-16 03:19","slug":"2024-05-16-TypeScriptBestPracticesforCleanandMaintainableCode","content":"\n\n이 블로그에서는 더 깨끗하고 안전하며 효율적인 코드를 작성하는 데 도움이 되는 TypeScript의 필수적인 최상의 관행에 대해 살펴볼 것입니다. 엄격 모드를 활용하고 타입 주석 및 인터페이스를 포함하여 \"any\" 타입의 함정을 피하고 읽기 전용 속성, 선택적 체이닝, nullish 병합 및 유틸리티 타입과 같은 고급 기능을 활용하는 등, TypeScript 스킬을 향상시키고 최상의 소프트웨어 솔루션을 제공하기 위해 필요한 모든 것을 다룰 것입니다. 함께 알아보겠습니다!\n\n- 엄격 모드 사용하기: TypeScript의 엄격 모드는 일반적인 오류를 잡고 안전한 코드를 보장하는 데 도움이 되는 여러 컴파일러 확인을 활성화합니다. 엄격 모드 활성화(tsconfig.json의 \"strict\": true)에는 strictNullChecks, strictPropertyInitialization, strictBindCallApply 등의 옵션이 포함됩니다. 시작부터 엄격 모드를 채택하면 프로젝트에 견고한 기반이 마련되어 많은 잠재적인 버그를 방지할 수 있습니다.\n\n예시: TypeScript에서 엄격 모드 사용의 장점을 보여주기 위해 특히 strictNullChecks에 초점을 맞춘 간단한 예제를 고려해 봅시다.\n문자열 매개변수를 받아 해당 문자열의 길이를 반환하는 함수가 있다고 가정해 봅시다:\n\n```js\n// 엄격 모드 사용하지 않았을 때\nfunction getStringLength(input: string): number {\n return input.length; // 'input'이 null 또는 undefined인 경우 잠재적인 런타임 오류 발생\n}\nconsole.log(getStringLength(\"Hello\")); \nconsole.log(getStringLength(null)); // 잠재적인 런타임 오류 발생\n```\n\n\n\nTypeScript에서는 코드를 무리없이 컴파일하지만, 실행 시 오류가 발생할 것입니다. 왜냐하면 null의 length 속성에 접근하려고 하기 때문에 오류가 발생합니다.\n\n이제 tsconfig.json에서 strictNullChecks를 활성화해 봅시다.\n\n```js\n{\n    \"compilerOptions\": {\n        \"strict\": true,\n        \"strictNullChecks\": true\n    }\n}\n```\n\nstrictNullChecks를 활성화하면 TypeScript가 엄격한 null 검사를 적용하여, 문자열이 예상된 위치에 null 또는 undefined를 전달하는 것을 방지합니다.\n\n\n\n```typescript\n// strictNullChecks를 활성화한 상태\n\nfunction getStringLength(input: string): number {\n    return input.length; // TypeScript 오류: 객체가 'null' 또는 'undefined'일 수 있습니다\n}\n\nconsole.log(getStringLength(\"Hello\")); \nconsole.log(getStringLength(null));    // TypeScript 오류: 'null'의 형식은 'string'의 매개변수에 할당할 수 없습니다\n```\n\nstrictNullChecks를 활성화하면 TypeScript는 컴파일 시간에 input이 null 또는 undefined일 수 있다는 경고를 표시하여 런타임에 발생할 수 있는 잠재적 오류를 잡을 수 있습니다. 이를 통해 더 안전한 코드를 작성하고 null 및 undefined 값과 관련된 일반적인 함정을 방지할 수 있습니다.\n\n1. Type Annotations과 Interfaces: TypeScript의 가장 큰 강점은 정적 타입 시스템에 있습니다. 타입 주석과 인터페이스를 활용하여 코드를 문서화하는 동시에 개발자와 도구에게 소중한 지원을 제공할 수 있습니다. 복잡한 데이터 구조에 대해 명확한 인터페이스를 정의하고 함수 매개변수와 반환 타입에 대해 타입 주석을 사용하여 명확성과 유지보수성을 보장하세요.\n\n2. \"any\" 타입 사용 지양: TypeScript는 타입을 모르거나 동적인 상황에서 any 타입을 제공하나 최소화하는 것이 좋습니다. any 타입은 사실상 타입 검사를 건너뛰는 것이므로 TypeScript의 주요 장점 중 하나를 약화시킵니다. 대신 변수와 함수를 명시적으로 타입 지정하고 TypeScript의 타입 시스템의 전체 장점을 활용하세요.\n\n\n\n\n다음은 tsconfig.json을 구성하여 어떻게 사용하지 않도록 설정할 수 있는지에 대한 설명입니다:-\n\n```js\n{\n    \"compilerOptions\": {\n        \"noImplicitAny\": true,\n    }\n}\n```\n\n4. \"readonly\" 사용하기: TypeScript에는 읽기 전용 속성과 변수를 만들 수 있는 readonly 수식어가 제공됩니다. 이는 초기화 후의 의도치 않은 수정을 방지합니다.\n간단한 사용자 프로필 정보를 관리하는 응용프로그램을 가정해보겠습니다. 사용자 프로필이 작성된 후에는 해당 속성이 수정되지 않도록 보장하고 싶습니다. TypeScript에서 readonly 속성을 사용하여 이것을 구현할 수 있습니다.\n\n```js\ninterface UserProfile {\n    readonly name: string;\n    readonly age: number;\n    readonly email: string;\n}\n\nfunction createUserProfile(name: string, age: number, email: string): UserProfile {\n    return { name, age, email };\n}\n\nconst user: UserProfile = createUserProfile(\"test user\", 30, \"testUser@example.com\");\n\nuser.name = \"Sample User\";  // TypeScript 에러 : const 또는 readonly 변수에 할당을 시도함\n```\n\n\n\n만약 우리가 읽기 전용 속성인 이름을 수정하려고 하면 TypeScript가 컴파일 오류를 발생시켜 사용자 프로필이 실수로 수정되는 것을 방지합니다.\n\n이 방식을 통해 한 번 사용자 프로필이 생성되면 해당 속성을 수정할 수 없게 되어 불변성을 유지하고 코드 신뢰성을 향상시킵니다.\n\n5. Optional Chaining과 Nullish Coalescing 사용 : TypeScript는 옵셔널 체이닝 (?.)과 널리쉬 코얼리싱 (??)과 같은 ECMAScript 기능을 지원하여 오류 처리를 간소화하고 코드 가독성을 높일 수 있습니다. Optional chaining을 사용하면 중첩된 속성에 안전하게 액세스할 수 있으며 널 또는 언디파인 값에 대해 걱정할 필요가 없습니다. 반면 널리쉬 코얼리싱은 잠재적으로 널 또는 언디파인 변수에 대한 기본 값을 처리하는 간결한 방법을 제공합니다.\n\n예시 :\n사용자의 주소, 도시, 국가에 대한 중첩 속성을 가진 객체가 있다고 가정해보겠습니다. 그러나 어떤 사용자는 주소 세부 정보를 제공하지 않을 수 있습니다. 우리는 이러한 속성에 안전하게 액세스하고 값이 누락된 경우 기본 값을 제공하고 싶습니다.\n\n\n\n```javascript\ninterface User {\n    name: string;\n    address?: {\n        city?: string;\n        country?: string;\n    };\n}\n\nconst user1: User = {\n    name: \"Test User\",\n    address: {\n        city: \"New York\",\n        country: \"USA\"\n    }\n};\n\nconst user2: User = {\n    name: \"Sample User\"\n};\n\nconst user1City = user1.address?.city ?? \"Unknown\";\nconst user1Country = user1.address?.country ?? \"Unknown\";\n\nconst user2City = user2.address?.city ?? \"Unknown\";\nconst user2Country = user2.address?.country ?? \"Unknown\";\n\nconsole.log(`${user1.name} lives in ${user1City}, ${user1Country}`); // 출력: Test User lives in New York, USA\nconsole.log(`${user2.name} lives in ${user2City}, ${user2Country}`); // 출력: Sample User lives in Unknown, Unknown\n```\n\n위 예제에서는 선택적 체이닝 (?.)을 사용하여 주소 객체의 중첩된 속성에 안전하게 액세스했습니다. 주소 또는 그 중첩된 속성 중 하나가 null 또는 정의되지 않은 경우, 표현식은 오류를 발생시키지 않고 undefined로 평가됩니다. 또한 누리 연산자 (??)를 사용하여 누락된 속성 또는 정의되지 않은 속성에 대한 기본값(\"Unknown\")을 제공했습니다.\n이 접근 방식을 사용하면 선택적 중첩된 속성을 간결하고 안전한 방식으로 처리하여 특정 속성이 제공되지 않은 경우에도 코드가 예측 가능하게 작동하도록 할 수 있습니다.\n\n6. 유틸리티 타입: TypeScript는 다른 타입을 조작하는 데 사용할 수 있는 일련의 유틸리티 타입을 제공합니다. 일반적으로 사용되는 유틸리티 타입에는 Partial, Pick, Omit, Record, Exclude, Extract, NonNullable 등이 있습니다.\n\n간단한 User 타입을 사용하여 유틸리티 타입을 사용하는 예제를 만들어보고 일부 유틸리티 타입을 시연해보겠습니다:\n\n\n\n\n```js\ntype 사용자 = {\n  id: number;\n  username: string;\n  email: string;\n  age: number;\n  isAdmin: boolean;\n};\n\ntype 부분사용자 = Partial\u003c사용자\u003e;\nconst 부분사용자: 부분사용자 = { id: 4 };\n\ntype 선택된사용자 = Pick\u003c사용자, \"username\" | \"email\"\u003e;\nconst 선택된사용자: 선택된사용자 = { username: \"dave\", email: \"dave@example.com\" };\n\ntype 제외된사용자 = Omit\u003c사용자, \"isAdmin\"\u003e;\nconst 제외된사용자: 제외된사용자 = { id: 5, username: \"eve\", email: \"eve@example.com\", age: 22 };\n```\n\n위 예제에서는 다음의 유틸리티 타입을 사용했습니다 -\n\n- `Partial\u003c사용자\u003e`는 선택적 속성을 가진 사용자 객체를 생성할 수 있습니다.\n- `Pick\u003c사용자, \"username\" | \"email\"\u003e`은 사용자의 username과 email 속성만 선택합니다.\n- `Omit\u003c사용자, \"isAdmin\"\u003e`은 사용자에서 isAdmin 속성을 제거합니다.\n\n이를 통해 동일한 타입을 여러 번 정의하지 않고 코드를 재사용 가능하고 더 깔끔하게 만들 수 있습니다.\n\n\n\n위에서 언급한 최상의 사례를 TypeScript 개발 워크플로에 통합함으로써 코드 품질, 유지 보수성 및 개발자 생산성을 더욱 향상시킬 수 있습니다. 이를 통해 더 나은 소프트웨어 솔루션을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-TypeScriptBestPracticesforCleanandMaintainableCode_0.png"},"coverImage":"/assets/img/2024-05-16-TypeScriptBestPracticesforCleanandMaintainableCode_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년을 위한 16가지 최고의 루비 프레임워크","description":"","date":"2024-05-16 03:17","slug":"2024-05-16-16BestRubyFrameworksforWebDevelopment2024","content":"\n\n1995년 이래로 널리 받아들여지고 있는 프로그래밍 언어 루비는 오픈 소스로 계속 발전 중입니다. 루비는 빠르고 객체 지향적이며 안전합니다. MVC 지원 구조를 통해 프로젝트에 동적 기능을 제공하여 개발을 이전보다 편리하게 만듭니다. 스타트업들이 루비를 적극적으로 받아들이면서, 언어는 웹 개발을 비롯한 거의 모든 분야에서 상당한 진전을 보였습니다. 루비의 인기로 인해 사람들은 개발을 새로운 수준으로 끌어올릴 수 있었습니다.\n\n일부 프레임워크를 구축하는 것은 Middleware와 응용 프로그램의 요청/응답을 간소화하기 위한 것입니다. 일부는 REST API를 위해 설계되었고, 일부는 웹 애플리케이션을 위해 설계되었습니다. 이 기사에서는 전 세계에서 최고의 루비 프레임워크를 소개하며, 각 프레임워크가 개발자들이 루비를 활용할 수 있게 하는 방법에 대해 설명하겠습니다.\n\n# 웹 개발을 위한 최고의 루비 프레임워크\n\n다시 본론으로 돌아와, 비즈니스에 큰 도움이 될 최고의 루비 프레임워크에 대한 자세한 내용을 살펴봅시다.\n\n\n\n# 루비 온 레일즈\n\n루비 온 레일즈 [1]은 최고의 루비 프레임워크 중 하나로 간주됩니다. 트위터와 같은 대규모 프로젝트를 개발하는 데 주로 사용되며 커뮤니티 발전을 촉진하는 데 도움이 되었습니다. \"레일즈\"로 더 잘 알려진 루비 온 레일즈는 현재 6.1 버전을 운영 중인 MVC 제어 구조를 갖춘 웹 개발 프레임워크입니다. 16년 된 이 언어는 웹 개발의 구조 및 데이터베이스 및 웹 애플리케이션의 다른 구성 요소 관리에 큰 영향을 미쳤습니다.\n\n![Ruby on Rails](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_0.png)\n\n루비 온 레일즈에는 \"젬\"이라는 확장 플러그인 라이브러리가 있으며 이는 인기 있는 루비 패키지 관리자인 루비젬을 통해 배포 및 설치할 수 있습니다. 가장 유명한 루비 온 레일즈 프로젝트로는 트위터, 에어비앤비, 블룸버그 등이 있습니다.\n\n\n\n# 시나트라\n\n시나트라 [2]는 시장에서 가장 좋은 루비 프레임워크입니다. 시나트라는 간단하고 사용하기 쉬운 DSL로 루비로 작성되어 있으며 루비 온 레일즈 대신 웹 개발 프레임워크로 자주 사용됩니다. 전설적인 음악가 프랭크 시나트라에 영감을 받아 만들어진 시나트라는 강력하며 한 파일만 있으면 완전한 기능의 웹 애플리케이션을 만들 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_1.png)\n\n시나트라는 2007년에 출시되었으며 오픈 소스이므로 루비 애호가들은 무료로 사용할 수 있습니다. 랙을 기반으로 한 시나트라는 레일즈보다 적은 리소스로 작고 무겁게 웹 애플리케이션을 개발할 수 있습니다. 때로는 시나트라가 마이크로 프레임워크라고 들을 수 있지만 이는 가벼움과 작은 크기 덕분입니다. 시나트라는 강력하고 능력이 있으며 루비젬을 지원하여 최소한의 노력으로 특정 작업을 완료할 수 있습니다.\n\n\n\n일부 잘 알려진 Sinatra를 사용하는 프로젝트에는 LinkedIn, Heroku, Apple 및 BBC가 있습니다.\n\n## Camping\n\nCamping은 가장 좋은 Ruby 웹 프레임워크 중 하나입니다. Camping 프레임워크의 소스 코드 크기는 단 4KB로, 동등한 기능을 제공하는 Ruby 프레임워크 중에서 가장 가벼운 것입니다. 규모 외에도 Camping이 유명한 이유는 2009년 8월에 사라진 신원 불명의 프로그래머가 작성했기 때문입니다. 익명의 프로그래머인 \"왜 행운한 나쁜 것\"이 프로젝트를 떠나면서 Camping이 인기를 얻게 되었습니다. Large community를 가진 오픈 소스 프레임워크입니다.\n\n![Camping Image](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_2.png)\n\n\n\n캠핑은 이러한 프로젝트를 처리하기 위해 랙을 필요로 하며 GitHub에서 RubyGem으로 제공될 수 있습니다. 캠핑의 한 가지 훌륭하고 강력한 기능은 완전한 웹 애플리케이션을 하나의 파일로 변환하고 MVC 구조로 구성하는 것입니다. 캠핑에 대해 더 알아보려면 공식 Camping GitHub 페이지 [4]를 방문해 주세요.\n\n# 라마즈\n\n라마즈 [5]는 훌륭한 웹 개발 프로젝트를 만드는 데 도움이 되는 또 다른 최고의 루비 웹 프레임워크입니다. 라마즈는 가벼우며 빠르며 학습 곡선이 완만합니다. 제이쿼리, AJAX, ORM, 자바스크립트 또는 특정 템플릿 엔진을 포함하는 루비 프로젝트의 경우 라마즈는 고려할 가치가 있는 훌륭한 선택지입니다. 라마즈는 강력하고 인기 있는 \"오류가 없는\" 프레임워크입니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_3.png)\n\n\n\nRails와 비교하면 Ramaze는 깔끔하고 가벼운 솔루션을 제공합니다. Ramaze의 GitHub 페이지는 Ramaze Github 링크 [6]를 통해 접속할 수 있습니다.\n\n# Goliath\n\n다른 Ruby 프레임워크와는 다르게 \"개발\" 부분에 집중하는 Goliath [7]은 루비로 작성된 가장 좋은 루비 프레임워크로 간주됩니다. Goliath는 PostRank를 지원하는 가벼운 웹 서버 프레임워크로, Ruby의 Rack APIs, Middleware의 구현 및 관리, 그리고 완전히 비동기 처리를 중점으로합니다. Goliath는 이벤트 기반 디자인에 집중하며, Goliath의 작동 기초를 형성하는 EventMachine 반응기 덕분에 이벤트 기반 설계에 중점을 두고 있습니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_4.png)\n\n\n\n\nThe Goliath project can be accessed through its Goliath GitHub repository page [8]. Goliath has a powerful feature that can organize complex asynchronous requests into linear execution communication processes. Therefore, Goliath’s asynchronous mechanism can be quickly used for streaming data, firehose API, etc. In addition, Goliath is open source, which is also an important factor in its linear development. If you are passionate about web server development in Ruby, you will definitely enjoy working in Goliath.\n\n# Hanami\n\nWith its concise architecture design and main object approach, Hanami [9] is considered one of the best Ruby frameworks and is widely popular as an alternative to Rails. Hanami has been \"sorted\" in design and provides small files that can be used independently to create project stacks. Hanami is lightweight, consumes fewer resources, and reduces memory by 60% compared to other large Ruby frameworks.\n\n![Best Ruby Frameworks for Web Development](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_5.png)\n\n\n\n\n한아미는 MVC 구조를 기반으로 하며 CSRF, XSS 방지를 위한 HTML 이스케이핑 및 브라우저의 Content-Security-Policy를 유지하는 우수한 추가 기능을 제공합니다.\n\n# 파드리노\n\n파드리노는 신트라를 기반으로 한 루비 웹 프레임워크 중 하나이며, 본질적으로 오픈 소스입니다. 파드리노는 Merb와 Camping 대안으로 널리 사용됩니다. 이 섹션에서 소개된 프레임워크들과 유사하게, 파드리노도 Rack 웹 서버 인터페이스에 적합합니다. 파드리노의 개발 아이디어는 신트라의 인기에서 비롯되며 계속해서 기능을 확장하여 더 많은 분야에서 사용되도록 만들어진 풍부한 라이브러리를 갖춘 프레임워크입니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_6.png)\n\n\n\n파드리노의 성능 지표 [11]에 따르면 레일즈보다 4배 빠르다고 나와 있어요. 파드리노는 파드리노 GitHub 페이지 [12]를 통해 액세스할 수 있어요.\n\n# NYNY\n\nNYNY의 공식 웹사이트 [13]에서는 NYNY를 \"놀랍도록 작다\"라고 정의하며, 최고의 루비 웹 프레임워크 중 하나로 손꼽히고 있어요. NYNY는 300줄의 코드로만 작성되어 있어서 다른 프레임워크인 랙보다 놀랍도록 작다고 볼 수 있어요. 사실, 대부분의 플러그인이 LOC로 작성된다면 NYNY는 높아요.\n\nNYNY의 하이라이트 중 하나는 이 루비 프레임워크가 루비 개발자의 인기 있는 요구 사항을 모두 포함하고 있다는 점이에요. 더 많은 콘텐츠가 필요하다면 프레임워크를 수정하고 여러 기능을 추가할 수 있어요. 이렇게 수정하면 신뢰할 수 있고 다재다능한 미들웨어를 구축할 수 있어요.\n\n\n\n\n![NYNY applications](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_7.png)\n\nNYNY applications can be used with Sinatra, Rails, or any other Rack-based application. The official NYNY GitHub page [14] contains all relevant information, from setup to configuring the application to running it on the server.\n\n# Cuba\n\nCuba [15] is a micro-framework for developing web applications in Ruby language. Rum inspired Cuba, and the official website defines Cuba as \"a small but powerful Rack application mapper\", making it one of the best Ruby frameworks. If you want to start developing in Cuba, the GitHub page is a practical guide.\n\n\n\n\n\n쿠바는 최고의 결과를 얻기 위해 여러 기술을 사용합니다. 예를 들어, 쿠바의 응답은 Rack의 최적화된 버전입니다. 이 템플릿은 Tilt [16]을 통해 통합되고, Cutest [17] 및 Capybara [18]를 통해 테스트됩니다.\n\n# Grape\n\nGrape [19]는 루비 프로그래밍 언어로 작성된 REST와 유사한 마이크로프레임워크입니다. Grape는 Rack에서 실행하거나 Sinatra 또는 Rails와 같은 기존 웹 애플리케이션 프레임워크를 보완하는 데 사용할 수 있으며, 후자는 DSL 기반 REST-API를 통해 통신할 수 있습니다. Grape 루비 웹 프레임워크는 웹 애플리케이션 분야에서 효율적이고 의미 있는 API 작업을 장려합니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_8.png)\n\n\n\n포도는 표준 규칙, 다중 형식 지원, 콘텐츠 협상, 버전 관리 등을 포함한 지원을 제공합니다. 포도를 이용하여 REST-API를 개발하고 API를 테스트하며 성능 지표를 분석하는 완벽한 가이드는 공식 포도 GitHub 페이지 [20]에서 확인할 수 있습니다.\n\n# Scorched\n\nScorched [21]는 루비 2.0 이상이 필요한 최고의 루비 웹 프레임워크 중 하나입니다. Scorched는 가벼우며, 공식 웹사이트는 Scorched가 \"실제로 신아트라의 진화와 개선\"이라고 주장합니다. Scorched 개발자들은 Scorched가 Rack 위에 위치하기 때문에 다른 개발자들이 이미 익숙하다고 믿습니다. 결과적으로, 중복되는 기능을 모두 제거하고 Scorched의 작업을 간단하고 구체적으로 만들었습니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_9.png)\n\n\n\n루비 초보 개발자나 경험이 적은 프로그래머들이 Scorched를 사용하는 것은 권장되지 않습니다. Scorched를 사용하면 새로운 도구를 실험하고 구현하며, 이 오픈 프레임워크를 활용할 수 있습니다. 이 프레임워크는 HTTP 요청을 처리하는 명확하고 견고한 구조를 제공하며, 확장 가능한 루비 기반 애플리케이션에도 사용할 수 있습니다.\n\n# Roda\n\nRoda는 웹 애플리케이션을 구축하는 데 도움이 되는 최고의 루비 프레임워크 중 하나입니다. Roda는 단순함, 가용성 및 생산성에 의존하며, 랭귀지의 강력함을 바탕으로 합니다. Roda는 Rack 위에 구축되어 유연한 아키텍처와 여러 API를 제공합니다. Roda는 요청을 어디에서든 라우팅 지점에서 실행할 수 있도록 Route Tree Web Toolkit를 소개하는 데 알려져 있습니다. 상대적으로 적은 메모리를 사용하며, 설치, 구성 및 사용이 매우 쉽습니다. Roda에는 미들웨어, 요청/응답 및 메일을 포함한 플러그인 목록이 함께 제공됩니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_10.png)\n\n\n\n# 볼트\n\n볼트는 웹 애플리케이션을 개발하는 데 도움이 되는 루비 웹 애플리케이션 프레임워크입니다. 볼트는 서버와 클라이언트에서 루비 코드를 실행하여 속도에 중점을 둡니다. 사용자가 웹 애플리케이션과 상호 작용할 때 문서 객체 모델 노드가 서버 및 페이지에서 동적으로 변경됩니다. 이 프로세스는 반응형 프로그래밍으로도 알려져 있습니다.\n\n볼트는 서버와 클라이언트 간 통신을 위해 HTTP 대신 지속적인 통신 네트워크에 중점을 두고 있습니다. 볼트 코드에 내장된 동기화 메커니즘을 통해 여러 클라이언트, 서버 및 데이터베이스의 데이터가 클라이언트의 변경 사항에 따라 업데이트됩니다.\n\n\n\nVolt는 다양한 분야에서 실행되는 많은 실용적인 웹 기반 애플리케이션을 구축하는 데 도움이 되었습니다. Volt에 대해 더 알고 싶다면 Volt GitHub 페이지 [23]를 방문해보세요.\n\n# Ramverk\n\nRamverk은 루비 웹 응용 프레임워크로, 미니멀리스트 방식을 채택합니다. Ramverk는 MVC 애플리케이션을 구축하고 프레임워크에 자체 기능을 추가하는 데 도움을 줍니다. Ramverk의 목표는 애플리케이션을 시작하는 데 필요한 기능만 제공하는 것이지만, 개발자들에게 더 많은 기능을 제공하도록 요구합니다.  \n\n![Ramverk](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_12.png)\n\n\n\n솔직히 말해서, Ramverk는 강력하지도 않고 높은 확장성과 복잡한 Ruby 애플리케이션을 위한 성숙한 프레임워크를 제공하지도 않습니다. 다양한 옵션들이 있기 때문에, Ramverk는 개발자들이 추가 작업을 해야 한다는 이유로 패배했습니다. 그러나 Ramverk는 아직 개발 중이며, 향후 버전에서 특정 기능들을 추가할 예정입니다. Ramverk GitHub 페이지 [24]를 통해 설치 방법을 안내받을 수 있습니다.\n\n# Hobbit\n\nHobbit은 \"반복을 하지 않는\" 개념에 기반한 웹 애플리케이션 마이크로프레임워크입니다. Hobbit은 다른 마이크로프레임워크보다 빠른 실행 속도를 제공하는 최고의 가벼운 Ruby 프레임워크입니다. Hobbit Ruby 프레임워크는 Rack 위에 구축되어 있으며, Sinatra에서 영감을 받은 DSL을 사용합니다.\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_13.png)\n\n\n\n호빗의 코드는 추가 논리 없이도 다양한 랙 클래스와 모듈을 사용하여 확장할 수 있습니다. 최소한의 구성으로 호빗은 이러한 기능을 활용하는 웹 애플리케이션 개발에 적합한 선택입니다.\n\n호빗 GitHub 페이지를 통해 레시피, 템플릿, 가이드, 데모 응용 프로그램에 액세스할 수 있습니다.\n\n# Cramp\n\n크램프는 루비로 작성된 실시간 웹 프레임워크로, EventMachine 위에 구축되었습니다. 크램프는 비동기 통신 메커니즘을 사용하는 또 다른 루비 프레임워크로, 너무 많은 오픈 연결이 있는 상황에도 원활하게 사용할 수 있습니다. 크램프는 웹소켓, 서버 전송 이벤트 및 API를 개발하는 데 사용할 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_14.png)\n\n크램프의 공식 저장소는 크램프 GitHub 페이지 [26]에서 찾을 수 있으며 간단한 젬 명령어로 설치할 수 있습니다: gem install cramp. 크램프는 효율적이고 빠른 완전 이중 양방향 통신을 제공합니다.\n\n# 참고 자료\n\n[1] 루비 온 레일스: https://rubyonrails.org\n\n\n\n[2] Sinatra: http://sinatrarb.com/\n\n[3] Camping: http://www.ruby-camping.com/\n\n[4] Camping Official GitHub Page: https://github.com/camping/camping\n\n[5] Ramaze: http://ramaze.net/\n\n\n\n[6] Ramaze Github 링크: https://github.com/Ramaze/ramaze \n\n[7] Goliath: https://postrank-labs.github.io/goliath/\n\n[8] Goliath GitHub 저장소 페이지: https://github.com/postrank-labs/goliath \n\n[9] Hanami: https://hanamirb.org/\n\n[10] Padrino: http://padrinorb.com/\n\n\n\n[11] Padrino의 벤치마크 지표: https://github.com/DAddYE/web-frameworks-benchmark/wiki\n\n[12] Padrino GitHub 페이지: https://github.com/padrino/padrino-framework\n\n[13] NYNY 공식 웹사이트: https://alisnic.github.io/nyny/\n\n[14] NYNY GitHub 공식 페이지: https://github.com/alisnic/nyny\n\n\n\n[15] Cuba: https://cuba.is/\n\n[16] Tilt: https://github.com/rtomayko/tilt\n\n[17] Cutest: https://github.com/djanowski/cutest\n\n[18] Capybara: https://github.com/teamcapybara/capybara\n\n\n\n[19] Grape: http://www.ruby-grape.org/\n\n[20] Grape 공식 GitHub 페이지: https://github.com/ruby-grape/grape\n\n[21] Scorched: https://scorchedrb.com/\n\n[22] Roda: https://roda.jeremyevans.net/documentation.html\n\n\n\n[23] Volt GitHub 페이지: https://github.com/voltrb/volt\n\n[24] Ramverk GitHub 페이지: https://github.com/Genti81/Ramverk\n\n[25] Hobbit GitHub 페이지: https://github.com/patriciomacadden/hobbit\n\n[26] Cramp GitHub 페이지: https://github.com/lifo/cramp","ogImage":{"url":"/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_0.png"},"coverImage":"/assets/img/2024-05-16-16BestRubyFrameworksforWebDevelopment2024_0.png","tag":["Tech"],"readingTime":11},{"title":"서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기","description":"","date":"2024-05-16 03:14","slug":"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications","content":"\n\n이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png)\n\n# 수분 섭취란?\n\n요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.\n\n\n\n이제 수분 보충이 작동하는 방식을 살펴보겠습니다:\n\n- 서버는 코드를 컴파일하고 정적 HTML을 생성합니다.\n- HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.\n- 브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.\n\n# 수분 보충 불일치 오류\n\n수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.\n\n\n\n## 수분 불일치의 일반 원인:\n\n## 잘못된 HTML\n\n서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.\n\n예시:\n\n\n\n\n\u003ca\n  class=\"Invalid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n  \u003cdiv\u003e\n    \u003ca href=\"https://www.youtube.com/\"\u003e\n      World\n    \u003c/a\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\u003cp class=\"Invalid P tag\"\u003e\n  \u003cdiv\u003eBye World\u003c/div\u003e\n\u003c/p\u003e\n\n\n이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.\n\n![2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png)\n\n이 코드에는 중첩 오류가 두 가지 있습니다:\n\n\n\n\n- 다른 'a' 태그 안에 중첩된 'a' 태그.\n- 'p' 태그 안에 중첩된 'div' 태그.\n\n그리고 브라우저는 코드를 다음과 같이 렌더링합니다.\n\n```js\n\u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  Hello\n\u003c/a\u003e\n\u003cdiv\u003e\n  \u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  \u003c/a\u003e\n  \u003ca href=\"https://www.youtube.com/\"\u003e\n    World\n  \u003c/a\u003e\n\u003c/div\u003e\n```\n\n이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 \"수정\"되었습니다.\n\n\n\n## HTML을 수정하는 스크립트들\n\n서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.\n특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.\n\n예시:\nVue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.\n\n## 상태 불일치\n\n\n\n서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.\n\n예시\n\n```js\n\u003cscript setup\u003e\nconst articles = useAsyncData('articles', async () =\u003e {\n  // 클라이언트에서만 기사 데이터 가져오기\n  const response = await fetch('/api/articles');\n  return await response.json();\n})\n\u003c/script\u003e\n\n\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    { articles.length === 0 ? '로딩 중...' : '' }\n    \u003cdiv v-if=\"articles.length \u003e 0\"\u003e\n      \u003cp v-for=\"article in articles\"\u003e\n        {  article }\n      \u003c/p\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 \"로딩 중…\" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 \"로딩 중…\" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.\n\n\n\n## 날짜, 타임스탬프 및 무작위화\n\n날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.\n\n예시\n\n```js\n\u003cdiv\u003e\n  \u003cp\u003e\n    { Math.random() }\n  \u003c/p\u003e\n\u003c/div\u003e\n```\n\n\n\n서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.\n\n# 수분 불일치 해소\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png)\n\n실제 해결책으로 수분 불일치에 대응해 보겠습니다:\n\n\n\n## 올바른 HTML 보장하기\n\n- 올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.\n- 린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.\n\n예시 (위의 잘못된 HTML에 대한 해결책)\n\n```js\n\u003ca\n  class=\"Valid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n\u003c/a\u003e\n\u003ca href=\"https://www.youtube.com/\"\u003e\n  World\n\u003c/a\u003e\n\u003cp class=\"Valid P tag\"\u003e\n  Bye World\n\u003c/p\u003e\n```\n\n\n\n이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:\n\n- 중첩된 `a` 태그를 제거했습니다. `a` 태그 안에 또 다른 `a` 태그를 넣을 수 없습니다.\n- `p` 태그 내에 불필요한 `div` 태그를 제거했습니다. 단락 (`p`)은 텍스트 콘텐츠를 직접 포함해야 하며 `div`와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.\n\n## 서버와 클라이언트 간 상태 불일치 해결하기\n\n- 서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.\n- Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.\n- Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.\n\n\n\n## 최종 탈출\n\n## `ClientOnly` 컴포넌트\n\n`ClientOnly` 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.\n\n- 이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.\n- 이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.\n\n\n\n## .client과 .server 접미사 사용하기\n\n특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.\n\n.server:\n\n- 파일은 초기 렌더링 중에 서버에서만 실행됩니다.\n- 초기 로드 및 SEO를 개선합니다.\n- 창 객체나 클라이언트 측 API에 접근할 수 없습니다.\n\n\n\n.client:\n\n- 파일은 클라이언트 측에서만 실행됩니다.\n- 상호작용을 위해 완전한 브라우저 환경을 활용합니다.\n- 사용자 입력 및 동적 기능에 이상적입니다.\n\n## NuxtLazyHydrate\n\n- NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.\n- 지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.\n\n\n\n# 읽어 주셔서 감사합니다!\n\n이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!\n\n![image](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png)\n\n# 참고문헌\n\n\n\n- Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter\n- 서버 사이드 렌더링 (SSR) | Vue.js\n- Nuxt 3 \"Hydration Mismatch\" 오류 · Harlan Wilton\n- Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles\n- Baroshem/nuxt-lazy-hydrate","ogImage":{"url":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png"},"coverImage":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"가치 사슬 관리를 위한 데이터 과학","description":"","date":"2024-05-16 03:11","slug":"2024-05-16-DataScienceforValue-ChainManagement","content":"\n\n## 데이터 과학을 활용하여 운영을 최적화하고 수익성을 향상시킬 수 있는 방법은 무엇인가요?\n\n![image](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_0.png)\n\n가치사슬 관리(Value Chain Management, VCM)는 시장에서 경쟁 우위를 차지하기 위해 제품 또는 서비스에 가치를 더하는 활동을 조직하는 프로세스를 의미합니다.\n\n이 방법을 통해 기관은 시장 동향에 효과적으로 대응하고 효율성을 향상시켜 수익성을 높일 수 있습니다.\n\n\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_1.png)\n\n이 글에서는 가치 사슬 관리의 기본 구성 요소에 대해 빠르게 살펴보겠습니다.\n\n그런 다음 전략적인 주요 활동을 지원하기 위한 데이터 과학 응용 사례 4가지를 탐색해 보겠습니다.\n\n```js\n요약\n\nI. 가치 사슬 관리의 기둥\n   1. 가치 창출 활동\n 가치 창출의 기본 구성 요소를 이해하기\n   2. 주요 활동이란?\n 제품 생산, 마케팅 및 배송과 직접 관련된 중요 기능들\n   3. 지원 활동이란?\n 가치 창출에 간접적으로 기여하는 주요 기능들\n   4. 주요 활동 지원을 위한 데이터 과학\n 주요 활동을 최적화하고 전반적인 가치 사슬 관리를 향상시키는 데 데이터 과학 도구와 기술이 어떻게 활용될 수 있는지에 대해 논의\nII. 인바운드 로지스틱스: 원자재 공급\n   1. 그래프 이론을 사용한 공급 업체 매핑\n 리스크 평가 및 최적화를 위해 공급 업체 네트워크 분석\n   2. 지속 가능한 소싱 네트워크 최적화\n 경제적이고 지속 가능한 기준에 따라 업체 선택\nIII. 오퍼레이션: 원자재부터 완제품까지\n   1. 와그너-위튼 알고리즘을 사용한 생산 계획 최적화\n 생산 계획을 최적화하여 설치 비용과 재고 관리를 균형 있게 유지\n   2. 솔루션의 영향을 측정하는 방법은?\nIV. 아웃바운드 로지스틱스: 최종 제품 배포\n   1. 공급망 컨트롤 타워 자동화\n 배출 배포의 모니터링을 자동화하고 효율성을 향상\n   2. 이러한 진단을 활용하여 성능을 어떻게 개선할 수 있을까요?\nV. 결론\n```\n\n\n\n# 가치 사슬 관리의 두 가지 기둥\n\n기업들은 효율성을 향상시키고 수익을 극대화하여 경쟁 우위를 확보하기 위한 방법을 지속적으로 탐색합니다.\n\n저는 공급망 엔지니어나 데이터 과학자로 진행한 대부분의 프로젝트에서 이를 공통적으로 경험해왔습니다.\n\n따라서, 이 블로그에서 게시된 대부분의 기사들은 비용을 감소시키는 궁극적 목표를 가지고 데이터 분석을 활용하여 공급망 프로세스를 최적화하는 데 초점을 맞춥니다.\n\n\n\n가치 사슬 관리(VCM)는 비즈니스 프로세스의 각 단계를 최적화하여 성능을 향상시키기 위한 전략적 접근 방식입니다.\n\n생산부터 배송까지 모든 것을 포함하여 최대한의 고객 가치를 창출하고 비용을 최소화하는 것을 목표로 합니다.\n\n## 가치 창출을 위한 활동\n\n가치 사슬 프레임워크는 마이클 포터의 책 \"경쟁 우위: 우수한 성과 창출과 유지\"에서 처음 소개되었습니다.\n\n\n\n이는 사업을 일렬로 연결된 활동군으로 나누어 소비자에게 가치를 생성하고 전달하는데 기여하는 것으로 인식하는 사업 방식을 혁신했습니다.\n\n![value-chain-management](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_2.png)\n\n- 주요 활동은 제품이나 서비스를 만드는 데 직접 참여하며, 판매, 유지보수, 그리고 지원하는 활동을 포함합니다.\n- 지원 활동은 인프라, 기술 개발, 인력 관리, 그리고 조달을 포함합니다.\n\n이제 아시아에서 티셔츠를 생산하고 유럽에서 판매하는 패션 소매업체를 예로 들어 각각의 정의를 살펴보겠습니다.\n\n\n\n## 기본 활동은 무엇인가요?\n\n기본 활동에는 인바운드 물류, 운영, 아웃바운드 물류, 마케팅 및 서비스가 포함됩니다.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_3.png)\n\n이러한 활동들은 제품 또는 서비스의 생산, 마케팅 및 고객에게 전달과 직접적으로 관련된 핵심 기능들입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_4.png\" /\u003e\n\n우리가 티셔츠의 가치 사슬을 예로 들면:\n\n- 입고 물류는 공급업체로부터 면을 조달하고 제조 시설로 운송하는 것을 포함합니다.\n- 영업은 면을 패턴으로 변형시키고 이를 조립하여 티셔츠를 만드는 것을 포함합니다.\n- 출고 물류는 티셔츠를 패키징, 보관 및 최종 목적지로 배송하는 모든 물류 프로세스를 포함합니다.\n- 마케팅 및 판매는 세일즈를 생성하기 위한 프로모션에 중점을 두고 있습니다.\n- 서비스는 매출 후 지원, 고객 서비스 및 맞춤 서비스와 같은 추가 서비스를 포함합니다.\n\n또한, 지원 활동은 이러한 주요 활동이 원할하게 작동되도록 보장하는 데 중요한 역할을 합니다.\n\n\n\n이러한 핵심 지원 기능들에 대해 자세히 알아보겠습니다.\n\n## 지원 활동이란?\n\n지원 활동은 제1차 활동의 효율성과 효과성을 향상시킴으로써 제품이나 서비스의 가치에간접적으로 기여합니다.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_5.png)\n\n\n\n지원활동은 인프라, 기술 개발, 인적자원 관리 및 조달을 포함합니다.\n\n- 기업 인프라는 가치 사슬의 원활한 운영을 가능하게 하는 조직 구조, 통제 시스템 및 행정 업무를 포함합니다.\n- 기술 개발 활동은 가치 사슬을 지원하는 기술과 시스템과 관련됩니다.\n- 인적자원 관리는 모든 가치 사슬 단계에 기여하는 직원을 채용, 교육 및 유지시키는 것을 포함합니다.\n- 조달은 가치 사슬에 필요한 입안물을 구매하고 조달하는 것을 의미합니다. 이는 원자재부터 사무용 장비까지 다양한 것을 포함합니다.\n\n## 기본 활동 지원을 위한 데이터 과학\n\n신규 고용된 데이터 과학 매니저로써, 주요 활동을 지원하기 위해 고급 분석 도구를 구현하기 위한 로드맵을 제안하고 싶습니다.\n\n\n\n위의 내용을 번역하면 다음과 같습니다.\n\n목표는 신중히 선정된 가치 사슬 활동을 지원하고 귀하의 팀을 회사의 전략적 자산으로 만드는 것입니다.\n\n# 수송 및 수입물류: 원자재 공급\n\n이것은 생산 전 내부적으로 받아들이고 저장하고 분배하는 모든 과정 및 활동을 포함합니다.\n\n우리의 예시에서는 셔츠를 제조하는 데 필요한 원단, 염료 및 기타 공급품과 같은 원자재가 될 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_6.png\" /\u003e\n\n💡 과거 경험을 기반으로, 운영적인 도전에 대답하고 프로세스를 최적화하기 위한 분석 도구 세트를 제안합니다.\n\n## 그래프 이론으로 공급업체 매핑\n\nSuppliers의 위험 평가를 지원하기 위한 솔루션을 제안하고 싶습니다.\n\n\n\n구매 팀은 공급 업체 네트워크 전체를 볼 수 있도록 도와주는 도구가 필요합니다. 이를 통해 위험 평가, 공급 업체 통합 및 물류 네트워크 디자인을 수행할 수 있습니다.\n\n![그림](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_7.png)\n\n이 구체적인 경우에는 그래프 이론을 사용하여\n\n- 특정 품목의 가치 사슬에 참여하는 모든 공급 업체를 시각화합니다.\n- 동일한 가치 사슬에 참여하는 모든 공장을 시각화합니다: 원자재 가공 공장 및 조립 부품 공장 등.\n\n\n\n저는 소매 회사의 라우팅 전략을 분석하는 데 이 이론을 사용했습니다.\n\n목표는 동일한 경로로 배달된 모든 매장을 시각화하는 것이었습니다.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_8.png)\n\n이 예시는 공급 업체 네트워크를 감사하는 데 쉽게 적용할 수 있습니다.\n\n\n\n- 공급 업체가 B-45 공장으로 납품하는 경우, 링크를 생성하세요.\n- 원자재 처리 공장 B-45와 조립 라인 C-78 사이의 링크를 만들어주세요.\n\nGraph Theory에 대한 자세한 정보는 아래를 참조해주세요.\n\n- 리스크 평가: 특정 공급 업체에 얼마나 많은 항목이 의존하는지 알려주세요?\n🎯 이 공급 업체의 중요성을 시각적으로 추정하고 그에 대한 리스크를 평가하세요.\n- 네트워크 설계: 특정 공장에 대한 공급 업체들은 어디에 위치하고 있나요?🚛 조달 리드 타임을 줄이고 해상 운송에 대한 의존성을 줄이기 위해, 공급 업체들에게 이 공장 가까운 곳에 공장을 이전하도록 요청할 수 있습니다.\n\n이 시각화는 조달 팀에 충분한 가시성을 제공하며, 리스크 평가나 공급 업체 합리화에 대한 논의를 지원할 수 있습니다.\n\n\n\n## 지속가능한 소싱 네트워크 최적화\n\n소싱 팀이 인바운드 흐름의 환경 영향을 줄이기 위해 적절한 공급 업체를 선택하는 도구를 요청했습니다.\n\n동료들은 다음을 기반으로 올바른 공급 업체를 선택하는 도구가 필요합니다.\n\n- 공급 ≥ 수요, 공급 업체의 제한된 용량 및 단위 생산당 최대 배출량 또는 수 사용량과 같은 제약 사항.\n- 특정 목표: 비용, 수 사용량 또는 이산화탄소 배출을 최소화합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_10.png\" /\u003e\n\n제가 배포한 애플리케이션에서 사용자는 경제적이거나 지속 가능성 기준에 따라 여러 시나리오를 쉽게 시뮬레이션하여 의사 결정을 용이하게 할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*s2UYkEpnrtmVDk-Q.gif\" /\u003e\n\n\n\n이 기사는 이 도구 뒤에 있는 이론을 자세히 소개합니다.\n\n이 분석 솔루션을 배포하면 귀하의 조직이 낮은 비용으로 원자재 공급을 지속적으로 확보할 수 있습니다.\n\n이제 우리는 두 번째 활동인 이러한 원자재의 변형으로 넘어갈 수 있습니다.\n\n# 운영: 원자재에서 완제품으로\n\n\n\n실제 티셔츠 생산이 이루어지는 단계입니다. 이 단계에서는 인바운드 물류로부터의 입력을 최종 제품으로 변환합니다.\n\n이 활동에는 원단 절단, 교봉, 염색 및 인쇄와 같은 공정이 포함됩니다.\n\n![티셔츠 생산](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_11.png)\n\n💡 원재료 가격 상승을 흡수하기 위해 제조부서가 생산 비용을 줄이는 데 도움을 요청했습니다.\n\n\n\n## Production Planning Optimization with Wagner-Whitin Algorithm\n\n생산 계획을 최적화하는 솔루션을 제안하고 싶습니다.\n\n![Image](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_12.png)\n\n![Image](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_13.png)\n\n\n\n위의 예시에서 고객들은 다음 12개월 동안 배송될 양을 공유했습니다.\n\n이 연습에서는 다음 사항 사이의 균형을 찾아야 합니다.\n\n- 설치 비용: 생산 라인을 설정할 때마다 발생하는 고정 비용\n한 달에 요청된 수량만 생산하는 경우 재고가 낮아지지만 설치 비용이 폭발할 것이다.\n- 보유 비용: 단위당 단위 시간당 저장 비용\n첫 달에 총 수량을 생산하는 경우 설치 비용이 최소화되지만 많은 재고가 누적됩니다.\n\n![image](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_14.png)\n\n\n\n바그너와 위탄은 설정 및 재고 비용을 균형 있게 유지하는 동적 프로그래밍에 의해 최적의 계획을 찾는 알고리즘을 개발했습니다.\n\n해당 이론에 대해 더 알고 싶다면, 이 문서에서 자세한 발표 자료가 제공됩니다.\n\n## 솔루션의 영향을 측정하는 방법은?\n\n특정 공장의 계획을 지원하는 프로토타입을 사용해 시도해 볼 수 있습니다.\n\n\n\n- 현재 생산 계획을 평가해 보세요: 재고, 특정 기간 동안 설정 횟수 및 비용.\n- 동일한 기간에 도구를 실행하세요.\n- 생산 계획자들과 결과를 검증하고 잠재적인 절약액을 계산하세요.\n\n몇 달 전에 배포한 프로토타입으로 지금 시도해 볼 수 있어요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*HAr855liASjPs6i8.gif\" /\u003e\n\n수산물 물류로 이제 완제품을 고객에게 전달해 볼까요?\n\n\n\n# 외부 물류: 최종 제품 배포\n\n완제품을 저장하는 유통 센터에서 물류 운영 팀은 고객에게 주문을 준비하고 배송하는 과정을 관리합니다.\n\n패션 소매업체의 경우, 이에는 유럽 전역으로의 저장, 주문 처리, 운송 및 상점 배송이 포함됩니다.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_15.png)\n\n\n\n💡 매장 관리자들이 배송 소요 시간에 불평을 해서, 운영 이사가 유통 프로세스를 개선하기 위해 지원을 요청했어요.\n\n## 공급망 컨트롤타워 자동화\n\n유통 계획 매니저와 연락 중이에요. 그녀의 팀은 매장 보충 주문을 모니터링해요.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_16.png)\n\n\n\n가게에서 판매되는 각 상품은 유통 기획자가 ERP에서 모니터링하는 재고 수준(단위)이 있습니다.\n\n재고 수준이 기획자가 설정한 최소 수준에 도달하면\n\n- 시스템은 자동으로 수량과 요청된 납품일이 포함된 보충 주문을 생성합니다.\n- 창고 운영 팀은 배송을 위해 주문을 준비합니다.\n- 운송팀은 가게로의 배송을 조직합니다.\n\n유통 체인에 참여하는 다양한 시스템은 각 핵심 단계에서 타임스탬프를 기록합니다.\n\n\n\n아래 표는 Markdown 형식으로 변경하세요.\n\n![이미지](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_17.png)\n\n주문 생성부터 상점 배송까지\n\n- 프로세스 완료 시 타임스탬프 기록됨;\n- 서비스 수준 협약에 따라 예상 완료 시간 계산됨;\n\n근본 원인 분석을 지원하기 위해, 중간 단계의 지연을 자동으로 식별하는 시스템을 구현해 주시기 바랍니다.\n\n\n\n아래 예시에서 \"Shipping Time\" 목표를 놓쳤으며, 그로 인해 배송이 지연되었습니다.\n\n이 규칙들로 늦은 배송 이유 코드를 자동으로 생성할 수 있습니다.\n\n\n\n이 솔루션을 구현하는 방법에 대한 자세한 내용은 아래를 참고하세요.\n\n## 이 진단을 활용하여 성능을 개선하는 방법은 무엇인가요?\n\n이러한 통찰력은 배포 계획 담당자가 운영 팀에 영향을 미칠 수 있습니다:\n\n- 이유 코드로 매주 지연 횟수 보고;\n- 이유 코드 매핑을 통한 루트 원인 분석으로 운영 팀에 도전;\n- 공급망 내 주문이 제때 완전히 전달될 백분율을 측정하는 전반적인 KPI로 매장에 미치는 영향 측정;\n\n\n\n데이터 분석 매니저로서, 지속적인 개선 프로젝트를 지원할 충분한 통찰력을 제공하여 기간 단축에 기여하셨습니다.\n\n# 결론\n\n가치 사슬 관리는 기업이 운영에 대한 심층적인 이해를 얻고 프로세스를 최적화하며 고객에 대한 우수한 가치를 창출할 수 있게 하는 접근 방식입니다.\n\n데이터 과학을 가치 사슬 관리에 통합함으로써 기업은 운영 효율성을 향상시키고 비용을 줄이며 궁극적으로 수익을 증대할 기회를 얻게 됩니다.\n\n\n\n수입 물류부터 출하 배포까지 다양한 예시를 통해 데이터 과학이 전략적 프로세스에 미치는 변혁적 영향을 설명했습니다.\n\n![Data Science Image](/assets/img/2024-05-16-DataScienceforValue-ChainManagement_20.png)\n\n이것은 전체 가치 사슬에 영향을 미치는 주요 변화의 촉매제가 될 수 있습니다.\n\n기업이 디지털 변환을 계속 받아들이는 가운데, 여러분은 팀의 잠재력을 회사의 전략적 자산으로 발휘할 수 있는 도구를 가지고 있습니다.\n\n\n\n# 나에 대해\n\nLinkedin과 Twitter에서 연락해요. 나는 데이터 분석을 이용하여 물류 운영을 개선하고 비용을 절감하는 공급망 엔지니어입니다.\n\n데이터 분석과 공급망에 관심이 있다면, 내 웹사이트를 방문해주세요.\n\n# 참고 문헌\n\n\n\n- \"경쟁 우위: 우수한 성과를 창출하고 유지하는 방법\", 마이클 포터","ogImage":{"url":"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_0.png"},"coverImage":"/assets/img/2024-05-16-DataScienceforValue-ChainManagement_0.png","tag":["Tech"],"readingTime":9},{"title":"자바스크립트 심층 탐구 React의 useEffect 및 Objectis 함정 탐색","description":"","date":"2024-05-16 03:08","slug":"2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap","content":"\n\n\n![Image](/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_0.png)\n\nReact에서 side effect를 수행하고 array dependency가 수정될 때마다 다시 렌더링을 관리하기 위해 useEffect 훅을 자주 사용합니다. 그러나 이 훅에 익숙하지 않은 일부 개발자는 브라우저가 멈추는 상황이나 컴포넌트 상태를 새로고침하는 문제 등 특정 상황에서 약간 헷갈릴 수 있습니다.\n\n간단한 예시를 살펴보겠습니다:\n\n```js\nfunction CountClick() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\u003e {\n      console.log('Count updated');\n  }, []);\n\n  const onClick = () =\u003e setCount(count + 1);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={onClick}\u003eClick me\u003c/button\u003e\n      \u003cdiv\u003eCount: {count}\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n페이지에 접속하면 빈 배열 []을 두 번째 인자로 전달하여 콘솔 로그가 한 번 출력되는 것을 확인할 수 있습니다. 이것은 React가 첫 번째 렌더링에서만 효과를 실행한다는 것을 의미합니다.\n\n\u003cimg src=\"/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_1.png\" /\u003e\n\n좋아요!\n\n이제 콘솔을 지우고 \"Click me\" 버튼을 클릭하여 무엇이 발생하는지 확인해봅시다.\n\n\n\n\n![Screenshot](/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_2.png)\n\n카운터가 증가하는 것을 관찰할 수 있지만, 콘솔에서는 아무 일도 일어나지 않습니다. 여기서 useEffect의 의존성이 실제로 작용하게 됩니다.\n\n코드를 조금 조정해 봅시다:\n\n```js\nfunction CountClick() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\u003e {\n      console.log('Count updated');\n  }, [count]);\n\n  const onClick = () =\u003e setCount(count + 1);\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eCount: {count}\u003c/div\u003e\n      \u003cbutton onClick={onClick}\u003eClick me\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n이제 'Click me' 버튼을 클릭한 후 콘솔에 메시지가 표시되는 것을 확인할 수 있습니다. 그러나 실제 세계에서는 백엔드와 통합되는 앱을 만들며, localStorage에서 데이터를 읽고 더 복잡한 솔루션을 사용합니다. 이전 예시에서 우리는 기본 형식에 대해 작업했습니다.\n\n이번에는 참조 형식인 객체를 사용하는 코드를 만들어보겠습니다:\n\n```js\nfunction CountClick() {\n  const [data, setData] = useState\u003cPerson\u003e()\n  const [count, setCount] = useState(0)\n\n  useEffect(() =\u003e {\n    console.log('Count updated');\n    setData({ firstName: 'Bruce', lastName: 'Wayne' });\n  }, [data]);\n\n\n  const onClick = () =\u003e setCount(count + 1);\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003eCount: {count}\u003c/div\u003e\n      \u003cbutton onClick={onClick}\u003eClick me\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n위 코드에서는 실수가 발생했습니다.\n\n\n\n\n![Image 1](/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_3.png)\n\n우리의 코드가 무한 루프를 발생시키고 있어요. 컴포넌트가 불필요하게 계속해서 자기 자신을 다시 렌더링하며, 업데이트의 끝나지 않는 사이클을 초래하고 있죠.\n\n다행히도, React의 소스 코드는 오픈 소스로 제공되어 있어요. 그래서 우리는 이 효과의 구현을 쉽게 찾을 수 있어요!\n\n![Image 2](/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_4.png)\n\n\n\n\n이 코드의 구현을 더 자세히 살펴보면 그리 복잡해 보이지 않아요. 그럼 문제가 뭘까요?\n\n이 함수의 정의를 찾아보려 노력해 봅시다.\n\n있네요! — 우리의 버그/예상 동작은 Object.is 정적 메서드에 있습니다. 그러니 테스트해 봅시다.\n\n```js\nconsole.log(Object.is({ firstName: 'Bruce', lastName: 'Wayne' }, { firstName: 'Bruce', lastName: 'Wayne' }));\n// false\n```\n\n\n\n그래서 현재 동일한 객체 정의에 대해 Object.is가 false를 반환하는 것을 알았죠.\n\n하지만 왜 그럴까요?\n\n자바스크립트는 꽤 표준화된 프로그래밍 언어입니다. Object.is는 SamveValue 추상 작업을 참조합니다. 그것에는 다음과 같이 기술되어 있습니다:\n\n```js\n//SameValueNonNumber\n7.2.11 SameValueNonNumber ( x, y )\n===== TRUNCATED =====\n6. 주의: 다른 모든 ECMAScript 언어 값은 동일성으로 비교됩니다.\n7. x가 y와 동일하면 true를, 그렇지 않으면 false를 반환합니다.\n```\n\n\n\n그리고 여기 중요한 참고 사항이 있습니다:\n\n이 함수는 호출될 때 같은 값이 아닌 경우와 원시 유형을 참조하는 SameValueNonNumber 및 SameValue에 대해 다음 단계를 수행함을 의미합니다. 객체, 배열, 함수 등과 같은 다른 값들에 대해서는 내용을 비교하는 대신 메모리 위치가 동일한지 확인하여 비교가 이루어집니다.\n\n따라서 이는 원시 유형에 대해서만 작동합니다.\n\n```js\nObject.is(NaN, NaN) // true\nObject.is(0, 0) // true\nObject.is(1.000123, 1.000123) // true\nObject.is(Infinity, Infinity) // true\nObject.is(-Infinity, -Infinity) // true\nObject.is(0/-1, 0/-1) // true\nObject.is(\"test\", \"test\") // true\nObject.is(null, null) // true\nObject.is(false, false) // true\nObject.is(true, true) // true\n```\n\n\n\n그리고 참조 유형에 대해서는 해당되지 않습니다\n\n```js\nObject.is(Symbol(\"foo\"), Symbol(\"foo\")) // false\nObject.is({}, {}) // false\nObject.is([], []) // false\n```\n\n# 어떻게 이 문제를 해결할까요?\n\n가장 간단한 해결책은 깊은 동등성을 사용하는 것입니다 (다른 해결책에 대한 좋은 기사 몇 개를 링크 섹션에 게시했습니다).\n\n\n\n```js\ntype Person = {\n  firstName: string;\n  lastName: string;\n};\n\nfunction CountClick() {\n  const [data, setData] = useState\u003cPerson\u003e()\n  const [count, setCount] = useState(0)\n\n  useEffect(() =\u003e {\n    setData({ firstName: 'Bruce', lastName: 'Wayne' });\n    console.log('Count updated');\n  }, [data?.firstName]);\n\n\n  const onClick = () =\u003e setCount(count + 1);\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv\u003ecount: {count}\u003c/div\u003e\n      \u003cbutton onClick={onClick}\u003eClick me\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n# 결론\n\n- useEffect 이해: React의 useEffect 훅은 컴포넌트에서 부수효과를 관리하는 데 중요하다. 이를 통해 개발자는 컴포넌트 라이프사이클 이벤트(마운트, 업데이트, 언마운트)에 대응하는 코드를 실행할 수 있다.\n- useEffect에서 의존성 배열: useEffect에 전달되는 두 번째 인자인 의존성 배열은 효과가 의존하는 값들을 지정한다. 이 배열이 변경되면 효과가 다시 실행된다. 이 배열을 생략하거나 빈 배열을 전달하면 효과는 최초 렌더링 후 단 한 번만 실행된다.\n- 참조 타입 사용 시 주의사항: 객체나 배열과 같은 참조 타입을 의존성 배열에 사용하면 예상치 못한 동작이 발생할 수 있다. 원시 타입과 달리 참조 타입은 값이 아닌 참조에 의해 비교된다. 따라서 두 객체의 내용이 같더라도 동일한 메모리 위치를 참조하지 않는 한 동일하지 않다.\n- Object.is 함정: 값 동등성 비교에 사용되는 Object.is 메서드는 참조 타입과 원시 타입에 따라 다르게 동작한다. 객체나 배열과 같은 경우, 이 메서드는 두 값이 동일한지 식별하며, 객체나 배열과 관련된 작업 시 예상치 않은 결과를 가져올 수 있다.\n- 해결책: useEffect에서 참조 타입을 사용할 때 무한 루프나 예상치 않은 동작을 피하기 위해 개발자는 깊은 동등성 체크를 활용할 수 있다. 이를 통해 객체의 내용을 기준으로 비교되도록 보장할 수 있다.\n\n# 링크\n\n\n\n- 기본 / 참조 유형 https://gist.github.com/branneman/7fb06d8a74d7e6d4cbcf75c50fec599c\n- https://github.com/facebook/react/blob/26f24960935cc395dd9892b3ac48249c9dbcc195/packages/react-server/src/ReactFizzHooks.js#L161\n- https://tc39.es/ecma262/#sec-samevalue\n- https://medium.com/suyeonme/react-lets-deep-dive-into-deps-array-of-useeffect-13ab96468db7","ogImage":{"url":"/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_0.png"},"coverImage":"/assets/img/2024-05-16-DeepDiveIntoJavaScriptNavigatingReactuseEffectandtheObjectisTrap_0.png","tag":["Tech"],"readingTime":6},{"title":"ReacType v21 소개 React 개발의 진입 장벽을 낮추고 품질 높이기","description":"","date":"2024-05-16 03:06","slug":"2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment","content":"\n\n우리는 ReacType (v21) 출시를 기쁘게 알리게 되었습니다. 이는 사용자가 어플리케이션 아키텍처를 동적으로 시각화할 수 있는 React 프로토타이핑 도구로, 실시간 컴포넌트 코드 미리보기와 상호작용 가능한 드래그 앤 드롭 디스플레이를 제공합니다. 또한, 라이브 비디오 및 채팅 기능이 통합된 협업 공간도 제공됩니다.\n\n오늘날 급변하는 소프트웨어 환경에서, ReacType (v21)은 소프트웨어 엔지니어링 커뮤니티의 개발 역량을 강화하기 위한 우리의 헌신의 증표로 남아 있습니다. 기술 창조를 지원하는 개발자 도구의 중요성을 인식하며, 우리는 그러한 도구가 개발자의 경력 단계에 관계없이 접근 가능하고 강력하게 유지되도록 약속하고 있습니다.\n\n![ReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment](/assets/img/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment_0.png)\n\nReacType v21의 새로운 기능\n\n\n\n최신 업데이트로 ReacType(v21)는 사용자 프로젝트 다양성, 디자인 능력 및 개발 효율성에 혁신적인 향상을 이루었습니다. 새롭게 통합된 49가지 Material UI 구성 요소는 추가 구성 없이도 즉시 사용할 수 있도록 준비되어 있어 엔지니어들의 창의적 범위를 크게 확대합니다. 이 확장에 대응하기 위해 사용자 인터페이스가 주의 깊게 재구성되어 더 직관적이고 접근하기 쉬운 환경을 제공합니다.\n\n이러한 개선은 플랫폼의 미학적 및 기능적 측면을 개선할 뿐만 아니라, React 앱 프로토타이핑과 협업을 위한 최고 수준의 도구로서 ReacType가 그 영향력을 강화합니다. 게다가 이러한 혁신은 사용자가 Material UI 속성을 사용자 정의하거나 추가적인 구성 요소 라이브러리를 통합하는 데 관련된 추가 개선 작업의 기초를 마련합니다.\n\n개선된 코드 생성\n\n이러한 새로운 구성 요소의 도입으로 인해 코드 생성 논리를 철저하게 개편할 필요가 있었습니다. 강화된 시스템은 이제 수입 문, 상태, 이벤트 핸들러 및 기타 중요한 변수 및 기능을 보다 효율적으로 관리합니다. 이 최적화로 생성된 코드는 완전히 기능하며 성능을 위해 세밀하게 조정되어 내보낼 준비가 되어 있습니다. 사용자가 애플리케이션을 구축하는 동안 준비된 상태입니다.\n\n\n\n\n![Introducing ReacType v2.1: Lowering the barrier to entry and raising the bar in React development](/assets/img/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment_1.png)\n\n### Revamped iframe Implementation\n\nUnderstanding the need for stateful interactions with UI components, we’ve reengineered our iframe implementation. The **\"Demo Render\"** enhancements allow users to interact seamlessly with state-dependent components, providing a highly realistic and practical preview of component behavior in a live environment. This upgrade ensures that developers can accurately assess and refine UI/UX experiences in real time, enhancing the quality and effectiveness of final projects.\n\n**Bug Fixes and Improvements**\n\n\n\n\n우리는 간소화되고 부드러운 사용자 경험에 대한 헌신에 부응하여, ReacType (v21)은 플랫폼에 중요한 수정사항과 향상된 기능을 가져왔습니다. 우리는 UI 전반에 걸쳐 발생한 다수의 렌더링 문제를 해결하여 일관된 성능과 사용자 기대에 부합하는 인터페이스를 제공하고 있습니다. 게다가, 프론트엔드와 백엔드 모두에서 잊혀진 비밀번호 기능과 관련된 문제를 해결함으로써, 보다 순조로운 사용자 경험을 보장하고 있습니다. 뿐만 아니라, 우리는 273개의 JSDoc 주석 블록을 추가하여 코드베이스를 보강했습니다. 이는 자세한 내용의 인라인 설명을 제공함으로써 새로운 기여자들이 코드를 이해하고 참여하기 쉽도록 만들어주었습니다.\n\n테스트 환경 최적화\n\nVite로의 최근 이전을 통해, ReacType (v21)은 테스트 스위트 내의 호환성 문제를 성공적으로 해결하고, 새로운 기능에 대한 30개의 테스트를 추가함으로써 최적화를 이루어냈습니다. 이 중요한 최적화는 프레임워크의 신뢰성과 성능을 향상시키는 데에 도움이 되었을 뿐만 아니라, 사용자 경험을 크게 개선하여 ReacType과의 상호작용을 이전보다 부드럽고 즐거운 것으로 만들어주었습니다.\n\n협업과 효율 제고\n\n\n\n(v21) 버전을 통해 ReacType는 협업과 효율성을 강조하고 있습니다. 이제 플랫폼은 우리의 강력한 프리스타일 구성 요소 스위트를 통해 개발자들 간 더 다이내믹한 상호작용을 지원합니다. 실시간 코딩, 동료 리뷰, 또는 상호 작용 문제 해결이든, ReacType (v21)은 함께 일할 때 간단하고 생산적으로 할 수 있도록 돕습니다.\n\n미래를 내다보며 사회와 함께 향하는 ReacType\n\n앞으로를 내다보며, ReacType는 React 앱 프로토타이핑 분야에서 지속적인 향상과 혁신에 헌신하고 있습니다. 저희 팀은 이러한 발전에 대해 열정적이며, ReacType가 웹 개발 여정의 어느 단계에서나 프로그래머들에게 가치 있는 도구를 제공하고 더 나아갈 것이라고 자신합니다.\n\nReacType의 핵심 가치인 함께 만들면 더 나은 개발자가 되고 개발은 접근 가능하고 효율적이어야 한다는 믿음을 바탕으로, 오늘 바로 ReacType를 사용하여 React 앱 프로토타이핑의 혜택을 경험하실 것을 권장합니다.\n\n\n\nReacType의 미래를 함께 만들어 보세요\n\n저희 웹사이트를 방문하여 (v21)의 새로운 기능을 탐험하고 가입하세요. 활기찬 커뮤니티에 참여하고 ReacType의 계속적인 발전에 기여하세요. 사용자 피드백을 적극 수용하며 신기술에 대응하여 저희 플랫폼이 업계를 선도하도록 합니다. 여러분의 통찰력과 기여는 ReacType을 가장 강력하고 사용자 친화적인 React 프로토타이핑 도구로 만들기 위해 귀중합니다. 따라서 GitHub에서 오픈 소스 프로젝트에 이슈를 제기하거나 기여해 주시기를 부탁드립니다.\n\nReact 프로젝트를 더욱 발전시키고 싶으신가요? 지금 바로 ReacType의 가능성을 탐험해 보세요!\n\nReacType 21.0 기여자 및 공동 저자\n\n\n\nAustin Alvarez | LinkedIn | GitHub\n\nHeather Pfeiffer | LinkedIn | GitHub\n\nSean Ryan | LinkedIn | GitHub\n\nJesse Wowczuk | LinkedIn | GitHub\n\n\n\nZack Vandiver | LinkedIn | Github","ogImage":{"url":"/assets/img/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment_0.png"},"coverImage":"/assets/img/2024-05-16-IntroducingReacTypev21LoweringthebarriertoentryandraisingthebarinReactdevelopment_0.png","tag":["Tech"],"readingTime":4},{"title":"RocksDB를 사용한 서버 부팅 속도 최적화","description":"","date":"2024-05-16 03:02","slug":"2024-05-16-ServerbootstrapoptimizationusingRocksDB","content":"\n\n# 소개\n\nFlipkart의 검색 인프라에서 Mustang은 SOLR 인덱스를 관리하는 필수 서비스입니다. 현재, 우리는 Flipkart, Grocery, Hyperlocal 및 Shopsy와 같은 다양한 비즈니스 단위에 대응하는 다양한 샤드에서 운영하고 있습니다. 각 샤드는 해당 샤드로 직접 전송되는 데이터 양과 요청 양에 따라 결정된 다양한 복제본을 호스팅합니다.\n\n각 복제본에는 디스크에 저장된 데이터(제품 관련 데이터, SOLR에서 제공)와 판매자별 목록 데이터에 대한 메모리에 저장된 데이터가 포함되어 있습니다. 빠르게 변화하는 속성에 대한 NRT(Near Real-Time) 데이터로, 애플리케이션 구동 시 중앙 집중식 Redis 클러스터에서 데이터를 가져와 메모리에 있는 데이터 구조체가 구축됩니다. 이러한 메모리에 있는 데이터 구조체는 Kafka 파이프라인을 통해 업데이트되어 Redis와 동기화되어 유지됩니다.\n\n![이미지](/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_0.png)\n\n\n\n평균적으로 각 복제본은 약 15 백만 개의 리스트에 대한 데이터를 보유합니다. 부팅 중에 이러한 인메모리 데이터 구조를 구축하는 프로세스에는 약 30~40분이 소요됩니다. 이 프로세스에서 주요 병목 현상은 Redis인데, 배포 중 동시 요청의 증가를 처리하는 데 어려움을 겪습니다 (이 클러스터의 크기가 각 데이터 센터에 거의 400대의 가상 머신에 가깝기 때문).\n\n이 전체 절차는 배포를 크게 늦추어 최소 2일 이상 소요됩니다. 개발자의 생산성뿐만 아니라 적시에 버그 수정을 배포하는 데도 어려움을 겪게 됩니다.\n\n이 블로그에서는 RocksDB를 사용하여 Mustang의 부팅 시간을 최적화하는 방법에 대해 논의합니다.\n\n# 문제 분석\n\n\n\n우리 Redis 클러스터는 Mustang 서버가 다시 시작될 때마다 막혔었습니다. 10%의 롤아웃 요인조차도 약 40개의 Mustang 서버가 Redis에 대해 300K 이상의 동시 호출을 하는 결과를 가져왔습니다. 이러한 대규모 동시 요청의 이유는 각 서버의 폴러 스레드 수 및 배치 크기 때문이었습니다.\n\n또한, Redis에서 목록에 대한 데이터를 가져오는 것이 단순한 Redis GET 작업이 아니었습니다. 우리는 Redis에서 목록 POJO를 작성하는 논리를 추상화한 라이브러리를 작성했는데, 이 라이브러리는 다중 동시 호출을 통해 각 속성의 데이터를 얻기 위해 내부적으로 Redis에 대한 요청을 여러 번 보내고 이를 병합하여 단일 POJO를 생성합니다.\n\n예를 들어, 목록과 관련된 제공은 Redis 내에 SET으로 저장되었으며, 서비스 가능 영역의 가용성 데이터는 BITFIELD로 저장되었습니다. 두 데이터를 가져오려면 Redis에 대해 구별된 쿼리가 필요했으며, 응답 구문 분석도 그에 따라 달랐습니다.\n\n문제점을 찾기 위해 아래에서 위로 가는 방식으로 병목 현상을 탐색하는 것은 좋은 선택처럼 보였습니다. 따라서 우리는 Redis부터 시작했습니다.\n\n\n\n# Redis 튜닝\n\n각 애플리케이션 서버의 폴러 스레드의 일괄 처리 크기와 스레드 수를 조정해 보았지만 전반적인 성능에는 개선이 없었습니다. 각 일괄 처리의 지연 시간은 조금 줄었지만 전체적으로 처리해야 하는 일괄 처리가 더 많아져 얻는 이점이 상쇄되었습니다.\n\n사용되지 않는 몇 가지 상품 속성을 찾았지만 여전히 상품 POJO의 일부였습니다. 이러한 속성을 POJO에서 제거하니 성능이 조금 향상되었지만 충분하지는 않았습니다.\n\nRedis 클러스터의 각 샤드에 레플리카 수를 늘리는 옵션도 검토했습니다. 이를 통해 더 나은 부하 분산을 얻을 수 있지만 클러스터가 대부분 유휴 상태이고 Mustang 배포 중에만 사용되기 때문에 실용적이지 않았습니다. 여기에 더 많은 리소스를 추가하는 것에 가치가 없다고 판단했습니다.\n\n\n\nRedis를 더 최적화하는 것이 어려워서, 우리는 응용 프로그램의 서버 쪽 옵션을 탐색했어요.\n\n# 파일 캐시 생성\n\n아이디어는 Redis로부터 데이터를 한 번만 검색하여 인메모리 데이터 구조를 구축하고, 그 후에는 미래 배포를 위해 로컬로 캐시하는 것이었습니다.\n\n같은 작업을 위한 빠른 POC를 진행하기 위해 우리는 셧다운 후크를 작성했어요. 이 후크는 모든 인메모리 데이터 구조를 로컬 디스크의 별도 파일에 직렬화할 거에요. 시작 시, 응용 프로그램은 로컬에 저장된 데이터를 역직렬화하고 인메모리 데이터 구조를 로드할 거예요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_1.png\" /\u003e\n\n시작할 때는 아이디어가 유망해 보였지만 나중에 다양한 문제가 발생했습니다. 이 중 일부는 아래와 같습니다:\n\n- 저희의 인메모리 데이터 구조는 사실상 코드의 다른 세그먼트(그리고 메모리에서)입니다. 그러나 이들은 모두 상품 목록 데이터에서 파생되었습니다. 한 세그먼트의 직렬화 중에 문제가 발생하면 해당 세그먼트를 다시 불러오지 않고는 복구할 수 없습니다. 이는 단 하나의 파일이 손상되어도 직렬화된 데이터를 모두 폐기하고 Redis로부터 전체 데이터를 다시 부트스트랩해야 한다는 것을 의미합니다.\n- 상품 목록 데이터는 각 샤드마다 동일하지만, 이러한 인메모리 데이터 구조는 응용 프로그램 서버 간에 심지어 같은 샤드 내에서도 다를 수 있습니다. 이 차이는 이러한 데이터 구조 내에서 상품 목록을 식별할 때 사용하는 서수의 무작위적인 특성에서 비롯됩니다. 이 상품 목록 서수는 SOLR 색인 파일을 비동기적으로 로드하는 프로세스 동안 먼저 도착한 사람이 우선적으로 생성되기 때문에 결정론적이지 않습니다. 따라서 동일한 샤드의 다른 복제본들 사이에서 직렬화된 파일을 공유하는 것이 불가능합니다.\n- 코드가 지저분해 보였던 이유는 직렬화 및 역직렬화를 위해 Jackson을 사용했기 때문입니다. Jackson은 우리 코드에서 정상적으로 작동하기 위해 특정 getter 및 setter를 필요로 합니다. 이는 특히 상속을 다룰 때 또는 간단히 속성을 반환하는 대신 사용자 정의 논리를 포함하는 getter가 이미 있는 경우에 복잡함을 야기했습니다.\n\n이러한 제약으로 인해 더 견고하고 우아한 솔루션이 필요했습니다. POC를 기반으로 내장 데이터베이스 접근 방식이 유망해 보였고 우리는 결국 RocksDB를 선택하게 되었습니다.\n\n\n\n# RocksDB가 당신을 구해줍니다\n\n## 왜 RocksDB를 선택했나요?\n\n우리가 RocksDB를 선택한 이유를 이해해 봅시다.\n\n- 이는 내장형 데이터베이스입니다. 이는 중앙 서버에서 실행할 필요가 없음을 의미합니다. 라이브러리로 직접 코드에 사용할 수 있습니다. 우리는 중앙 집중형 솔루션에서 벗어나려고 했기 때문에, 이것은 우리에게 완벽했습니다.\n- 당신의 요구에 맞게 튜닝할 수 있는 구성 옵션을 제공합니다.\n- 다양한 작업 부하에서 테스트할 때 유망한 결과를 보았으며, 이는 그 성능에 대한 우리의 신뢰를 높였습니다.\n- 이는 매우 인기 있는 데이터베이스이며 다양한 산업에서 사용되고 있습니다 (X가 비슷한 문제를 해결하기 위해 어떻게 사용하는지, Cloudflare가 어떻게 사용하는지, MySQL과의 통합하여 저장 엔진으로 사용하는 방법 확인 등)\n- 페이스북이 유지 관리하는 매우 활발한 커뮤니티 지원이 있습니다.\n\n\n\n이 데이터 포인트들은 좋은 임베디드 데이터베이스를 선택하는 데 도움이 많이 되었어요. \n\n## RocksDB의 저장 스키마\n\n임베디드 데이터베이스 선택을 결정하고 나면 코드에 통합하는 작업을 진행했어요. 이 작업은 간단했어요. 우리는 Redis에서 데이터를 한 번 가져와서 이후 배포에서 로컬로 저장된 데이터를 사용할 수 있도록 RocksDB에 저장하고 싶었어요. \n\n![RocksDB를 사용한 서버 부트스트랩 최적화](/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_2.png)\n\n\n\n간단하게 유지하기 위해 우리는 간단한 저장 스키마를 설계했습니다. RocksDB의 각 행은 단일 목록의 데이터를 포함했습니다. 각 행의 키는 목록의 ID이었고 값은 직렬화된 목록 POJO였습니다. 다음과 같이 보였습니다:\n\n```js\n“LISTING_1\": “{\\\"attribute_1\\\": \\\"value_1\\\", \\\"attribute_2\\\": \\\"value_2\\\"}\"\n```\n\n단순함 외에도 이러한 종류의 스키마를 선택한 주된 이유 중 하나는 작업의 세분화였습니다. 이 스키마를 사용하면 필요에 따라 단일 목록 또는 그룹의 목록을 업설 또는 가져올 수 있었습니다. RocksDB에 일부 목록의 데이터가 없는 경우 Redis에서 누락된 레코드를 다음 부트스트랩 단계에서 가져와 RocksDB를 업데이트할 수 있습니다. 시스템은 자가 치유 기능을 제공합니다.\n\n이것이 우리 솔루션의 기초를 놓은 것이지만, 아직 해결해야 할 많은 문제가 있었습니다. 다음 섹션에서 몇 가지 다른 어려움에 대해 이야기하겠습니다.\n\n\n\n## 고요한 데이터 문제 해결\n\nRedis에서 데이터를 한 번 가져와 로컬에 저장하는 것만으로는 비즈니스의 빠르게 변화하는 성격 때문에 충분하지 않았습니다. 플립카트의 대부분 비즈니스 요구 사항은 목록 속성에 일부 변경이 필요했으며(인메모리 데이터 구조에 대한 비슷한 스키마 변경 포함), 그래서 그럴 때마다 RocksDB에 저장된 데이터는 애플리케이션의 스키마와 호환되지 않게 되었습니다.\n\n이 문제를 해결하기 위해 RocksDB에 인메모리 데이터 구조의 스키마 해시를 리스트 데이터와 함께 저장했습니다. 이 스키마는 배포가 발생할 때 최신 스키마(코드에 저장된)와 비교됩니다. 스키마 불일치가 발생하면 RocksDB 데이터를 단순히 폐기하고 Redis에서 최신 데이터로 다시 채웁니다.\n\n이 방법은 괜찮았지만, 결과적으로 서면 배포의 60%가 데이터 구조 변경을 포함했다는 것이 밝혀졌습니다. 이는 여전히 대부분의 배포에서 Redis에 의존하고 있다는 것을 의미했으며, 이는 이상적이지 않았습니다.\n\n\n\n우리는 더 나은 계획을 세웠어요. 동일한 샤드 내의 모든 레플리카가 동일한 목록 데이터를 가지고 있다는 사실을 알고 있었죠. 그래서 왜 각 샤드의 단일 무작위 레플리카로부터 RocksDB 데이터를 생성하여 GCS에 저장한 다음 해당 샤드의 다른 레플리카에 사용하지 않을까요?\n\n이 방법을 구현하는 것은 쉬웠어요. 우리는 코드에 유효성 검사 레이어를 작성해뒀는데, Mustang 시작 시 스키마 해시를 비교할 수 있도록 했어요. 동일하다면 응용 프로그램은 RocksDB에서 데이터를 로드하지만 다르다면 해당 응용 프로그램은 로컬 RocksDB 데이터를 삭제하고 GCS에서 최신 데이터를 가져와서 계속해서 RocksDB에서 데이터를 로드해요.\n\nGCS에 데이터가 없을 경우 Redis로 데이터를 부트스트랩합니다. 배포 파이프라인도 이러한 유형의 배포를 처리하도록 변경되었어요. 스키마 변경이 있을 때마다 CI 파이프라인이 각 샤드에서 무작위 레플리카를 선택하여 최신 코드를 배포하고 Redis에서 부트스트랩한 다음 로컬 RocksDB 데이터를 GCS에 업로드합니다. 나머지 레플리카는 로컬 데이터가 무효화될 때 자동으로 GCS에서 데이터를 가져와요.\n\n## Kafka 업데이트 처리\n\n\n\n카프카에서 업데이트를 다룰 때, RocksDB의 데이터가 Redis에 있는 것과 함께 최신 상태를 유지해야 했습니다. 우리는 이 프로세스를 최적화하기 위해 카프카 업데이트를 가로채고 그것을 RocksDB에 추가한 후 메모리 데이터 구조의 변경 사항을 반영하는 전용 클래스를 개발했습니다.\n\n우리는 전체 POJO를 RocksDB에 저장했기 때문에 데이터를 업데이트하기 위해 읽기-수정-업데이트 작업을 수행해야 했습니다. 주요 기술적 장벽은 RocksDB 내에서 잠재적인 업데이트 실패를 관리하여 Mustang이 다음 재시작 시 RocksDB에서 가장 최신 데이터를 검색할 수 있도록 보장하는 데 있었습니다.\n\n이를 완화하기 위해 우리는 try-catch 블록 내에서 오류 처리를 구현했습니다. 어떤 이유로든 업데이트가 실패하면 해당 목록을 간단히 RocksDB에서 삭제했습니다. 삭제 실패의 드문 경우(다시 시도 후에도)를 대비하여 종료시 전체 RocksDB 데이터 세트를 지우기로 선택했습니다. RocksDB 업데이트가 실패하더라도 사용자에 대한 데이터 불일치가 없도록 메모리 데이터 구조를 업데이트했습니다.\n\n해결해야 할 또 다른 문제가 있었습니다. RocksDB의 부트스트랩 후 카프카 이벤트를 가장 최신 오프셋에서 읽기 시작하는 Mustang의 경우(기존 시스템의 기본 동작 방식)에는 데이터 손실이 발생할 수 있습니다. 이는 RocksDB가 Mustang이 재시작하는 동안 업데이트를 받지 못하기 때문입니다. 그 전에는 Mustang이 소스의 진실인 Redis에서 부트스트랩을 했기 때문에 가장 최신 카프카 오프셋에서 읽기를 안전하게 시작할 수 있었던 것이었습니다.\n\n\n\n이 문제를 해결하기 위해 우리는 종료할 때 모든 파티션의 Kafka 오프셋을 RocksDB에 저장하기 시작했습니다. 그런 다음 시작할 때 Mustang은 해당 파티션의 저장된 오프셋으로 다시 이동하였습니다. 응용 프로그램 충돌과 같은 이유로 RocksDB에서 오프셋을 찾을 수 없는 경우, 로컬 덤프를 폐기합니다. 또한 현재 오프셋과 저장된 오프셋 간의 차이가 상당히 큰 경우 로컬 덤프도 폐기합니다. 이 결정은 이러한 중요한 데이터 갭을 다시 채우는 데 상당한 시간이 걸릴 것으로 이해하고 기준이 됩니다. 이 차이에 대한 임계값은 Mustang이 일반적으로 다섯 분 동안 처리할 수 있는 업데이트 양을 추정하여 결정됩니다.\n\n## 사용 사례에 맞게 RocksDB 조정\n\n이 시점까지 우리는 RocksDB를 우리의 코드베이스에 성공적으로 통합할 수 있었습니다. Mustang이 인메모리 데이터 구조를 부팅하는 데 걸리는 시간은 30분에서 15분으로 줄었습니다. 우리는 우리의 액세스 패턴을 더 잘 이해하고 RocksDB의 내부를 깊이 파고들면 RocksDB에서 더 많은 성과를 얻을 수 있다고 믿었습니다.\n\n우리의 워크로드는 쓰기와 읽기의 혼합물이었습니다. Redis에서 데이터를 부팅하고 RocksDB에 삽입하는 동안은 완전히 쓰기 중심이지만 이후 배포에서는 항상 읽기 중심입니다. 이러한 패턴 중 하나에만 최적화할 수 있었고, 우리는 읽기를 최적화하기로 결정했습니다 (당연한 이유로).\n\n\n\n아래는 저희 케이스에 작동한 몇 가지 최적화 내용입니다:\n\n- 캐시 비활성화: LRU 기반 블록 캐시는 모든 RocksDB 사용 사례에서 사용하는 것이 좋지만 심한 락 경합이 발생합니다. 부팅 중에 한 번만 목록을 읽는 경우에는 데이터 블록의 캐시를 비활성화했습니다.\n- 레벨 컴팩션 사용: 레벨 컴팩션 전략은 크기 단위(일명 유니버설) 컴팩션 전략보다 읽기 및 공간 증폭면에서 더 나은 결과를 줍니다.\n- LSM 트리의 레벨 수 줄임: LSM 트리의 레벨 수는 RocksDB에서 중요한 속성입니다. LSM 트리에 존재할 레벨 수를 결정합니다. 데이터 중 일부가 핫하게 액세스되는 경우 레벨이 많으면 유익하지만, 액세스 패턴이 무작위인 경우 읽기 대기 시간에 영향을 줄 수 있습니다. 우리의 경우에는 레벨 수를 기본값인 7에서 3으로 줄였습니다.\n- 주기적인 전체 컴팩션 트리거: RocksDB는 최상태일 때 가장 잘 작동합니다. 읽기 성능을 최적화하기 위해 카프카 업데이트로 인한 읽기(및 공간) 증폭을 줄이기 위해 매일 취침 시간에 전체 컴팩션을 수동으로 트리거하는 비동기 스레드를 작성했습니다.\n- WAL 비활성화: 기본적으로 RocksDB는 모든 쓰기를 WAL에 메모리 테이블과 함께 저장합니다. 데이터가 손실되지 않는 자가 치유하는 성격의 경우 WAL을 비활성화했습니다.\n- multiGet()을 사용하여 데이터 읽기: RocksDB는 DB에서 데이터를 읽는 다양한 방법을 제공합니다. get() 명령 또는 multiGet() 명령을 실행할 수 있습니다. multiGet()은 다중 get() 호출에 비해 더 효율적이며, 필터/인덱스 캐시에서 적은 스레드 경합, 내부 메서드 호출 수 감소, 다른 데이터 블록에 대한 IO에 대한 더 나은 병렬화 등 여러 이유로 선호됩니다.\n- 목록 정렬 및 일괄 처리: 전체 목록 세트를 정렬한 다음 RocksDB에서 데이터를 가져오기 전에 이를 작은 일괄 처리로 만들었습니다. 정렬된 목록은 디스크에서 동일한 또는 근접한 페이지에 있을 가능성이 크기 때문에 랜덤 디스크 IO를 줄였습니다.\n\n이러한 최적화로 부팅 시간을 15분에서 약 6분으로 대폭 단축하여 효율을 높이는 우리의 노력에서 중요한 성과를 도출했습니다.\n\n자세한 내용은 이 튜닝 안내서를 읽어보세요.\n\n\n\n# RocksDB를 운영 환경으로 이끌기\n\n모든 것이 준비된 상태에서 우리는 RocksDB를 운영 환경으로 적용하고 싶었습니다. 그러나 스택에 새로운 기술을 도입하는 것은 어떠한 중단도 방지하기 위해 조심스럽게 진행해야 했습니다. Mustang이 RocksDB와 어떻게 상호 작용하는지 모니터링하기 위한 적절한 메트릭을 도입하고 위험을 완화하는 방법을 구현했습니다. 그런 다음, 각 샤드 내의 일부 레플리카에 대한 제한적인 배포를 시작했습니다.\n\n## 작은 결함\n\n몇 개의 Mustang 서버에 최신 코드를 배포한 직후, 응답 시간이 저하되는 현상이 발생하기 시작했습니다. 더 깊게 파고들어보니, 몇 일 동안 전체 VM의 메모리가 천천히 소비되는 것을 발견했습니다. 이 과도한 메모리 사용은 Solr의 인덱스 관련 파일을 캐싱하는 능력을 방해하여 런타임 중 과도한 디스크 이용률을 초래하여 지연 시간을 증가시켰습니다. Java 어플리케이션이 이 메모리 누수를 발생시킬 수 없다는 것은 명백했습니다. 왜냐하면 Java 어플리케이션은 시작 시에 고정된 메모리 청크(힙 메모리 형태로 할당)만 할당되고, 그 위에 JVM이 기능하기 위해 약간의 추가 네이티브 메모리만 사용하는 것 뿐이기 때문입니다. (JVM이 사용하는 네이티브 메모리를 확인하는 방법은 이 가이드를 참조하세요)\n\n\n\n의심이 RocksDB로 향했는데, 내장 데이터베이스로 분류되었지만 Java 라이브러리뿐만 아니라 C++ 구성 요소도 포함되어 있고 JNI를 통해 Java 애플리케이션과 상호 작용하는 것으로 확인되었습니다. Java에서 RocksDB와 상호 작용하는 클래스들은 내부적으로 RocksDB의 C++ 대응물을 호출합니다. C++의 메모리 관리는 자동 가비지 콜렉션 시스템이 없어서 어려워요. 우리는 초반에 RocksDB에 버그가 있을거라고 생각했어요.\n\n그때부터 우리는 네이티브 메모리 누수를 디버깅할 수 있는 옵션을 탐색하기 시작했어요. 네이티브 메모리 누수를 찾아가는 우리의 여정은 블로그로서 충분히 소개할 만한 주제였지만, 간결함을 위해 이 자리에서 우리가 도움을 받은 내용에 대해서만 이야기할 예정이에요.\n\n이러한 유형의 메모리 누수를 디버깅하기 위해 우리는 Jeprof라는 도구를 발견했어요. 이 도구는 JNI 호출과 같은 이유로 발생하는 네이티브 메모리 할당을 추적하는 데 사용됩니다. 그래서 우리는 Jeprof를 구성하여 애플리케이션의 네이티브 메모리 할당에 대한 메모리 덤프를 수 분마다 수행하도록 설정했어요. 나중에 우리는 몇 시간 간격으로 생성된 2개의 무작위 덤프를 비교하여 어떤 객체가 크기가 커지고 있는지 확인했어요. 같은 내용의 일부를 아래에 기술한 내용을 참고해 주세요:\n\n![이미지](/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_3.png)\n\n\n\n스크린샷을 보면, RocksDB에서 제공된 ReadOptions()와 WriteOptions() 객체들이 많이 할당되었음을 확인할 수 있었습니다.\n\n코드를 확인해본 결과, 이 두 클래스에 대한 새로운 객체 할당이 발생하는 곳은 하나뿐이었습니다. 우리 코드에서 RocksDB 관련 구성을 처리하기 위해, ReadOptions()와 WriteOptions()와 같은 다양한 객체를 보유하고 이를 맵에 다양한 열 패밀리 이름에 매핑하는 새 클래스를 만들었습니다. 이러한 객체들은 일반적으로 Mustang 시작 시 제공되며 다시 생성되지 않습니다.\n\n그러나 안전을 위해, 열 패밀리에 요청되었을 때 이미 사용 가능한 객체들이 없는 상황을 처리하기 위한 해결책을 마련했습니다. 우리는 Map의 getOrDefault() 메서드를 활용하여, 미리 구성된 객체를 검색하거나 지정된 열 패밀리에 대해 실행 중에 새로운 객체를 생성할 수 있도록 했습니다. 이 구현에 대한 자바 코드는 아래와 유사했습니다:\n\n```java\n...\npublic ReadOptions getReadOptionsByColumnFamily(String columnFamilyName) {\n  return this.readOptions.getOrDefault(columnFamilyName, new ReadOptions());\n}\n\npublic WriteOptions getWriteOptionsByColumnFamily(String columnFamilyName) {\n  return this.writeOptions.getOrDefault(columnFamilyName, new WriteOptions());\n}\n...\n```\n\n\n\n## 그럼 왜 메모리 누수를 발생시킬까요?\n\nRocksDB의 메모리 관리에 관한 문서를 읽어보니, RocksDB의 각 클래스가 Autocloseable을 직간접적으로 구현한다는 것을 알게 되었습니다. RocksDB의 자바 객체에서 실제 메모리를 해제하기 위해 사용이 완료되면 명시적으로 close()를 호출해야 합니다 (또는 try-with-resources를 사용). 이를 하지 않으면 메모리 누수가 발생할 수 있습니다.\n\n위의 코드 조각에서 언급된 로직을 구현하는 과정에서, Map의 getOrDefault() 내에서 새 객체가 생성되고 있음을 인지하지 못했습니다. 그 함수가 호출될 때마다 사전 구성된 객체가 주어진 칼럼 패밀리를 위해 존재하는지 여부와 관계없이 이러한 새로 생성된 객체는 닫히지 않고 메모리 누수에 기여했습니다.\n\n메모리 누수의 근본 원인을 이해한 후, 문제 해결은 쉬웠습니다. 이 구성 클래스를 인스턴스화하는 동안 기본 ReadOptions 및 WriteOptions 객체를 한 번만 만들어서 Map의 getOrDefault()에서 새 객체를 생성하는 대신 이들을 사용했습니다.\n\n\n\n영향을 받은 Mustang 서버에 대한 수정 사항을 신속하게 배포하고 메모리 안정성을 확인하기 위해 한동안 모니터링했어요.\n\n## 배포 계속 진행\n\nRocksDB의 부정적인 영향이 없고 모든 것이 원활히 작동하는 것을 확인한 후, 시스템 자원에 특별히 주의를 기울이면서 남은 Mustang 서버를 배포하기로 했어요. 이 점진적인 접근법을 통해 우리는 원활한 전환을 보장하고 제품 환경의 안정성을 유지할 수 있었어요.\n\n## 결론\n\n\n\n요약하자면, RocksDB는 Mustang의 배포 과정에서 현저한 향상을 이끌어냈습니다. Redis에 의존했던 이전 방식 대비 인메모리 데이터 구조를 부트스트랩하는 데 필요한 시간을 크게 줄였습니다. \n\n다양한 샤드를 통해 방대한 테스트를 거친 결과, 부트스트랩 시간이 상당히 줄어들었으며 평균 6분으로 안정화되었습니다 (이전 30~40분). 서버 당 부트스트랩 시간뿐만 아니라 배포 속도도 향상되었으며 이제 더 많은 서버를 병렬로 배포할 수 있게 되었습니다.\n\n그 결과, 전체 샤드에 걸친 Mustang의 전체 배포 과정은 이제 3시간 미만이 소요되며, RocksDB 도입을 통해 달성한 효율성 향상의 증거가 되었습니다. 이 성공은 저희 인프라 내 지속적인 개선과 최적화에 대한 헌신을 강조합니다.","ogImage":{"url":"/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_0.png"},"coverImage":"/assets/img/2024-05-16-ServerbootstrapoptimizationusingRocksDB_0.png","tag":["Tech"],"readingTime":12},{"title":"규모 확장 가능한 개인 정보 보호 GenAI GPU 없이 텍스트 익명화하여 1100의 비용으로","description":"","date":"2024-05-15 16:45","slug":"2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost","content":"\n\n기업 엔지니어링 팀들은 대량의 비정형 텍스트를 처리하기 위해 OpenAI 및 다른 생성 AI 서비스의 파워를 활용하여 생산성을 크게 향상시키고 있습니다. 그들은 고객, 직원, 및 하위 비즈니스를 위한 생산성 도구를 만들고 평가하고 있습니다. 비즈니스 중요 텍스트를 활용하는 프로덕션급 도구들은 엄격한 데이터 준수 가이드라인이 필요합니다. 대부분의 기업은 고객에게 표시할 수 있는 텍스트 유형 및 OpenAI GPT-4와 같은 제3자 AI API 서비스로 보낼 수 있는 텍스트 유형에 대한 준수 정책을 가지고 있습니다.\n\n![그림](/assets/img/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost_0.png)\n\n![그림](/assets/img/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost_1.png)\n\n## 원시 비정형 텍스트 청크의 프라이버시 보호 필요성이 커지고 있습니다.\n\n\n\n사용자에게 보여지거나 안전한 환경을 벗어난 텍스트에는 SSN, 신용 카드 번호 또는 이메일 등의 PII(개인 식별 정보)가 포함되지 않도록 해야 합니다. 예를 들어 외부 API와 같은 임베딩 서비스나 GPT-4 프롬프팅을 사용하기 전에는 안전한 환경을 벗어나는 텍스트에서 PII를 삭제하여 규정을 준수해야 합니다.\n\n## 기존 솔루션: 높은 GPU 사용량과 증가된 대기 시간\n\nNamed Entity Recognition (NER)은 텍스트 분석에서 잘 알려진 문제이며, Hugging Face와 같은 회사에서 제공하는 것처럼 이를 해결하기 위한 여러 오픈 소스 모델이 있습니다. 그러나 이러한 모델을 확장하려면 상당한 GPU 자원이 필요합니다. 예를 들어, BERT와 같은 기본 모델은 리소스 소모가 많으며, 세부 조정을 위해 4대의 V100 GPU에서 몇 시간이 필요합니다(표 1 참조). 또한 배포 중에 느려지는 경우가 있어, 애플리케이션 응답 시간이 약 50배 이상 소요될 수 있습니다(그림 1 참조). 반면, spaCy와 같은 저렴한 대안은 리소스 소비가 적지만, 더 정교한 모델의 93%에 미치지 못하는 65%의 정확도를 제공합니다. 성능 차이는 NER 솔루션을 배포할 때 계산 요구 사항과 정확도 사이의 교환이 강조됩니다.\n\n## ThirdAI의 CPU 전용 NER 모델: 신속한 세부 조정, 초고속 대기 시간, SOTA 정확도. GPU 사이클을 해방하세요.\n\n\n\n저희는 NER을 위해 특별히 제작된 사전 훈련된 기본 모델을 자랑스럽게 소개합니다. 최신 기술의 정확성을 제공하며 BERT나 DistillBERT보다 30~50배 빠른 레이턴시로 작동합니다. 놀랍게도 최대 1,000개의 토큰에서도 우리 모델은 단일 CPU 코어에서 1,000개의 라벨 예측에 대해 약 50ms의 레이턴시를 유지합니다. (비교 자료는 도표 1과 테이블 1을 참고하세요)\n\n저렴한 CPU 전용 인스턴스에서 세밀한 조정 가능: 저희 모델은 수백만 개의 라벨이 지정된 샘플을 몇 분 내에 저렴하고 쉽게 구할 수 있는 CPU 전용 인스턴스에서 세밀하게 조정할 수 있습니다. 추론 및 세밀 조정 중에 다양한 프로세서 간에 일관된 성능을 유지합니다.\n\n저희 기술을 활용하고자 하는 개발자들을 위해 사전 훈련된 NER 모델을 배포하는 간단한 스크립트를 제공해드립니다. 이 모델은 여러 언어에서 표준 NER 범주를 식별할 수 있는 능력이 있습니다. 언어 및 지원되는 범주에 대한 자세한 내용은 안내에서 확인할 수 있습니다. 특화된 다국어 데이터셋에 대해 세밀한 조정을 원하시는 경우에는 다음 대체 스크립트를 사용하십시오.\n\n## 순서 개선된 총소유비용(TCO)\n\n\n\nTable 1은 세밀 조정 비용을 요약하며 Figure 1의 차이는 배치 비용으로 직접 변환됩니다. ThirdAI의 기술적 차이로 인해 전용 GPU 리소스 제약 조건을 없애고 비용을 100배 절감할 수 있습니다. ThirdAI를 사용하여 언제 어디서나 손쉽게 데이터를 사적으로 보호하세요.\n\n## 중요한 링크\n\n모든 파이썬 노트북 및 지침서 링크: https://github.com/ThirdAILabs/Demos/tree/main/named_entity_recognition","ogImage":{"url":"/assets/img/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost_0.png"},"coverImage":"/assets/img/2024-05-15-PrivacyPreservingGenAIatScaleAnonymizeYourTextwithoutGPUsforahundredththecost_0.png","tag":["Tech"],"readingTime":3},{"title":"흑자 블랙 바스타의 코발트 스트라이크를 추적하기","description":"","date":"2024-05-15 16:44","slug":"2024-05-15-HuntingBlackBastasCobaltStrike","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_0.png\" /\u003e\n\n지난 주 FBI와 CISA가 Black Basta 랜섬웨어 그룹을 위한 #StopRansomware 경보를 발표했습니다.2024년 중에 이 그룹은 LockBit와 Play 다음으로 총 랜섬웨어 피해자가 세 번째로 많은 것으로 나타났습니다. 특히, 그 그룹이 Cobalt Strike를 사용한다는 점이 강조되었습니다(표 10 - \"알려진 Black Basta Cobalt Strike 서버 도메인\" 참조).\n\nIntel-Ops는 Black Basta가 배포한 Cobalt Strike 서버를 포함하여 야생에서 Cobalt Strike 서버를 적극적으로 추적하고 있습니다. 이 게시물에서는 FBI/CISA 경보에 포함된 C2 서버 및 해당 경보에 미포함된 C2 서버 또는 악의적이거나 Black Basta와 관련된 서버로 공개적으로 추적되지 않은 서버에 대한 분석 결과 중 일부를 강조하겠습니다.\n\n\n\n블랙 바스타의 코발트 스트라이크 그래프:\n\n발리딘의 \"Bulk Analyzer\" 도구를 사용하여 공지사항의 도메인을 빠르게 활성 IP 주소로 해결하고 시간에 따른 호스팅 패턴을 이해하며, 말테고 그래프에 대한 상관 관계를 생성할 수 있습니다:\n\n![그래프 이미지](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_1.png)\n\n# 결과\n\n\n\n- 블랙 바스타 인프라는 명확한 클러스터로 그룹화될 수 있으며, 이 중 일부를 아래에서 강조하겠습니다.\n- 블랙 바스타 인프라에서 관찰된 주요 워터마크는 1357776117 및 1158277545입니다.\n- 코발트 스트라이크 서버의 대부분은 Vult Hosting LLC (AS-CHOOPA), JW Lucasweg 35, Digital Ocean 및 Servinga에서 호스팅됩니다.\n\n# 클러스터 1\n\n블랙 바스타가 운영하는 대다수의 코발트 스트라이크 서버는 DNS 비컨을 활용합니다: https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/listener-infrastructue_beacon-dns.htm. 우리의 분석에 따르면, 공지서에서의 IOC는 거의 전적으로 Vultr, Lucasweg 및 Digital Ocean에서 호스팅됩니다.\n\n우리의 조사에 따르면, 적어도 6개의 추가 DNS 코발트 스트라이크 비컨이 이러한 제공업체에서 호스팅되었습니다. Intel-Ops는 다른 제공업체에서도 유사한 C2를 식별했습니다. \"thenewbees[.]org\"와 같은 새로 식별된 도메인은 공지서에 기재된 다른 DNS 비컨들의 네이밍 컨벤션과 일치합니다.\n\n\n\n인텔-옵스 클러스터 1의 예시 DNS 비콘:\n\n![Example DNS Beacon](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_2.png)\n\n## 클러스터 2\n\n도메인 \"usaglobalnews[.]org\"은 Cobalt Strike 비콘의 일부인 것으로 보입니다. 인텔-옵스 클러스터 2에서는 두 개의 도메인이 이전에 이미 Pikabot을 포함한 Black Basta 사건과 관련하여 Trend Micro에 의해 2023년 12월에 보고되었습니다. \"ruggioil[.]com\"과 \"bluenetworking[.]net\"의 도메인은 모두 해당 사건과 연결되었습니다.\n\n\n\nhttps://www.trendmicro.com/content/dam/trendmicro/global/ko/research/24/a/a-look-into-pikabot-spam-wave-campaign/ioc-pikabot-spam-campaign.txt\n\nIntel-Ops Cluster 2에서의 Cobalt Strike 서버 예시:\n\n![Cobalt Strike 3](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_3.png)\n\n![Cobalt Strike 4](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_4.png)\n\n\n\n# 클러스터 3\n\n인텔-옵스 클러스터 3 내에서는 3개의 자문 도메인이 관찰되었으며, 이 중 일부는 중국 호스팅 업체 및 중국 DNS 레코드의 분포가 더 큰 코발트 스트라이크 서버와 클러스터링되어 있습니다. 추가로, \"dfir-delight\"의 2024년 4월 보고서에서 적어도 3개의 추가 C2 서버와 자문 도메인 중 하나가 공개적으로 블랙 바스타 활동에 속한다고 확인되었습니다: https://dfir-delight.de/p/black-basta-iocs/\n\n인텔-옵스 클러스터 3 코발트 스트라이크 C2 서버 예시:\n\n![HuntingBlackBastasCobaltStrike_5](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_5.png)\n\n\n\n# 클러스터 4\n\nIntel-Ops는 워터마크가 있는 여러 개의 Cobalt Strike 비콘을 식별했습니다: 1357776117. 이 워터마크가 있는 IP 주소의 비교적 작은 클러스터가 있습니다: 우리는 Hunt.io를 사용하여 지난 30일 동안 이 워터마크가 있는 IP의 수를 식별할 수 있습니다. 특히, 해결 도메인 중 일부가 공고서의 도메인 이름 규약과 일치하는 것을 확인했습니다:\n\n![이미지](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_6.png)\n\n이 클러스터 내에서, 최근의 Black Basta 사건에 공개적으로 속한 다른 IP 주소가 있습니다. 또한, 워터마크만을 분석했을 때 호스팅이 Black Basta 클러스터의 다른 패턴과 거의 일치하지 않았습니다, 예를 들어 DNS 비콘이요.\n\n\n\n예시 인텔-옵스 클러스터 4 내의 Cobalt Strike C2 서버:\n\n![Alt text](/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_7.png)\n\n# 결론\n\n블랙 바스터 공고로부터 추론할 수 있는 추가적인 클러스터/상관 관계가 있습니다. 이 분석은 보고서에 나와 있는 알려진 지표만 다루고 있습니다. Cobalt Strike를 이용하는 그룹에 대한 보호를 강화하고 추가 정보를 얻으려면:\n\n\n\n**Hunting Adversary Infrastructure Course**\n\n우리의 \"Hunting Adversary Infrastructure\" 과정에서 가르치는 기술을 활용하면 보안 분석가들이 모두 레벨에서 활동을 클러스터링하고 소속을 판단하는 등 보고서를 더욱 풍부하게 할 수 있습니다. 이러한 모든 지표들은 Intel-Ops에서 적극 추적되고 곧 C2 위협 피드를 통해 제공될 예정입니다.\n\nCobalt Strike와 Black Basta와 같은 그룹과 같은 프레임워크를 추적하는 방법을 배우고 싶다면, 저희 과정에 등록해보시기 바랍니다. 여기에서 등록하면 학생들은 배우는 데 도움을 줄 추가적인 쿼리 및 API 크레딧이 포함된 Validin 플랫폼을 위한 특별한 Intel-Ops 계정을 획들할 수 있습니다.\n\nC2 Feed\n\n\n\n저희 C2 피드에 관한 정보가 필요하시면 LinkedIn, Twitter 또는 이메일(contact@intel-ops.io)로 연락해주세요.","ogImage":{"url":"/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_0.png"},"coverImage":"/assets/img/2024-05-15-HuntingBlackBastasCobaltStrike_0.png","tag":["Tech"],"readingTime":4}],"page":"84","totalPageCount":151,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"84"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>