<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>allround-coder</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///posts/115" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="allround-coder" data-gatsby-head="true"/><meta property="og:title" content="allround-coder" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///posts/115" data-gatsby-head="true"/><meta name="twitter:title" content="allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-ec7535a55e788b31.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Vue 34의 State에 대한 개념 모델" href="/post/2024-05-14-AConceptualModelofStateinVue34"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue 34의 State에 대한 개념 모델" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue 34의 State에 대한 개념 모델" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue 34의 State에 대한 개념 모델</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" href="/post/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" href="/post/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular Routes반쯤 타입 지정하는 간단한 꿀팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Angular Routes반쯤 타입 지정하는 간단한 꿀팁</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nodejs는 단일 스레드인가요" href="/post/2024-05-14-IsNodejssingle-threaded"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nodejs는 단일 스레드인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IsNodejssingle-threaded_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nodejs는 단일 스레드인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Nodejs는 단일 스레드인가요</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vue 3  동적 컴포넌트" href="/post/2024-05-14-Vue3DynamicComponents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vue 3  동적 컴포넌트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-Vue3DynamicComponents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vue 3  동적 컴포넌트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">Vue 3  동적 컴포넌트</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년을 향한 새로운 JavaScript 7 기능" href="/post/2024-05-14-7NEWJavaScript2024Features"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년을 향한 새로운 JavaScript 7 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년을 향한 새로운 JavaScript 7 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">2024년을 향한 새로운 JavaScript 7 기능</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WASM을 전혀 잘못 이해하고 있었어요 " href="/post/2024-05-14-IwasunderstandingWASMallwrong"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WASM을 전혀 잘못 이해하고 있었어요 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WASM을 전혀 잘못 이해하고 있었어요 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">WASM을 전혀 잘못 이해하고 있었어요 </strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" href="/post/2024-05-14-FrontendWeeklyDigest362612May2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" href="/post/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" href="/post/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/assets/profile.jpg"/></div><span class="writer">Allround Coder</span></div><strong class="PostList_title__loLkl">기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제</strong><div class="PostList_meta__VCFLX"><span class="date">May 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link posts_-active__YVJEi" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a><a class="link" href="/posts/120">120</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Vue 34의 State에 대한 개념 모델","description":"","date":"2024-05-14 12:33","slug":"2024-05-14-AConceptualModelofStateinVue34","content":"\n\n상태와 컴포넌트 경계의 배치를 이해하는 것은 현대 프론트엔드 웹 개발에서 가장 중요한 도전 중 하나이며, 어플리케이션의 규모가 커짐에 따라 개발을 가속화하거나 가장 큰 마찰 원인이 될 수 있는 팀이 내릴 수 있는 가장 중요한 결정 중 하나입니다.\n\n올바르게 수행하면 프론트엔드 컴포넌트의 구축, 구성, 리팩토링 및 테스트가 간단해집니다. 잘못 수행하면 코드베이스를 부서지기 쉽게 만들며 추적하기 어려운 유령 버그의 끝없는 근원이 될 수 있습니다.\n\nVue의 3.4 릴리스로 실험적인 상태에서 벗어나 정식 출시된 defineModel 마크로는 아마도 서로 다른 컴포넌트 간의 복잡한 상태 상호작용을 어떻게 생각하고 구현해야 하는지를 형성하는 방식에 대해 팀이 생각하는 방식을 바꿀 수 있는 가장 혁신적인 기능 중 하나일지도 모릅니다.\n\n이 설명은 꽤 무해한 것처럼 보입니다:\n\n\n\n표면적으로 보면, 이 매크로의 유용성은 미묘해 보일 수 있지만, 팀이 상태에 대해 생각하고 컴포넌트 경계를 관리하는 방식에 깊은 영향을 미칩니다. defineModel이 무엇을 하는지 알아보고 Vue 3.4에 추가된 것이 얼마나 패러다임 변화처럼 느껴지는지 살펴보겠습니다 — 비록 그것이 단순한 매크로일 뿐이라도요.\n\n# 상태에 대한 개념적 모델\n\n일반적으로, 현대 프론트엔드 애플리케이션을 생각할 때 상태에는 3가지 범위가 있습니다 (창 수준의 진정으로 전역 상태를 제외한 경우).\n\n![Conceptual Model of State](/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png)\n\n\n\n- 전역, 공유 상태. 이는 전체 계층 구조 내에서 여러 컴포넌트에서 액세스할 수 있는 상태로, 로그인한 사용자 계정 정보 및 경로 간에 공유되는 정보와 같이 실제로 글로벌 상태에 해당합니다.\n- 계층 구조 형태의 컴포넌트 상태. 이는 계층 구조의 하위 트리 내에서 여러 컴포넌트에서 액세스할 수 있는 상태입니다. 예시로는 목록-상세 편집기 뷰가 있습니다.\n- 단일 컴포넌트 레벨 상태. 이는 계층 구조 내의 단일 컴포넌트 내에서만 액세스할 수 있는 상태로, 상태 상호 작용이 트리를 올라가거나 내려가지 않아도 되는 컴포넌트의 경계 내에서 유지됩니다.\n\n글로벌 수준에서 이를 해결하기 위한 많은 라이브러리와 솔루션이 있습니다. 예를 들어, React의 Zustand, Jotai, Recoil, Redux (그 외 다른 라이브러리 및 프레임워크) 및 Vue의 Pinia는 컴포넌트 트리 내부에서 상태를 전역 범위로 끌어내어 트리를 가로질러 이동할 수 있도록 도와줍니다. 이러한 용도로 light/dark 모드나 테넌트 ID와 같은 실제로 전역 상태를 유지하는 것이 목적입니다.\n\n이 두 번째 상태 레이어에서, 팀이 마주치는 'prop drilling' 마찰이 발생합니다 — React, Vue 또는 다른 라이브러리나 프레임워크에서 발생하는 것일 수 있습니다. 그 중 일부는 수많은 상태를 컴포넌트 간에 상하로 이동하는 것을 관리하기 번거로운 점입니다.\n\n이 경우 팀이 자연스럽게 내리는 결정을 하는 것은 상태를 전역 스토어로 옮겨놓는 것이거나, 상태를 이동하는 대신 세 번째 컴포넌트 범위로 빠져 이 마찰을 피하고 단순히 하나의 거대한 컴포넌트에 계속 쌓는 것입니다 — 이로써 다른 종류의 고통이 생기게 됩니다.\n\n\n\n상태를 prop 트리거링 없이 쉽게 분리할 수 있다면 얼마나 좋을까요? Vue의 반응형 양방향 바인딩을 유지하면서 컴포넌트 간 상태를 이동하는 데 생기는 마찰과 고통을 크게 줄여줄 수 있는 defineModel이 나타납니다.\n\n# defineModel이란?\n\n먼저 무엇인지와 무엇을 하는지를 이해하는 것이 중요합니다. Vue에 익숙하지 않은 사용자들을 위해 컴포넌트 간으로 상태를 옮기는 유행적인 방식은 props와 emits를 사용했습니다.\n\n## defineModel 이전 - props와 emits\n\n\n\n예를 들어, 부모-자식 구성 요소를 고려해 봅시다:\n\n![이미지](/assets/img/2024-05-14-AConceptualModelofStateinVue34_1.png)\n\n양방향 바인딩을 위해 내부 NameInput.vue 컴포넌트를 다음과 같이 만들어야 합니다:\n\n```js\n\u003c!-- NameInput.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"NameInput.vue\"\u003e\n    \u003c!-- 👇 이 곳에 input을 바인딩합니다 --\u003e\n    \u003cinput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\n// 👇 프롭으로 들어옴\nconst props = defineProps\u003c{\n  modelValue: string\n}\u003e()\n\n// 👇 업데이트를 부모에게 emit\nconst emits = defineEmits\u003c{\n  'update:modelValue': [string]\n}\u003e()\n\n// 👇 연결하기 위한 writable 컴퓨티드\nconst name = computed({\n  get() {\n    return props.modelValue\n  },\n  set(val) {\n    emits('update:modelValue', val)\n  }\n})\n\u003c/script\u003e\n``` \n\n\n\n밖에 있는 예시1.vue 컴포넌트는 다음과 같습니다:\n\n```js\n\u003c!-- 예시1.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"예시1.vue\"\u003e\n    \u003ch1\u003e예시 1\u003c/h1\u003e\n    \u003cp\u003e안녕하세요, { name.length === 0 ? \"(아래에 이름을 입력하세요)\" : name }\u003c/p\u003e\n    \u003c!-- 👇 여기가 우리 컴포넌트입니다 --\u003e\n    \u003cNameInput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst name = ref('')\n\u003c/script\u003e\r\n```\n\n이제 텍스트 상자에 값을 입력하면 이 값이 prop의 값으로 자동으로 업데이트됩니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1358/0*f_imWYDRjdKfO_RA.gif\" /\u003e\n\n\n\n이렇게 간단한 것을 위한 보일러플레이트가 얼마나 지루해질 수 있는지 쉽게 알 수 있어요!\n\n## defineModel 이후 ✨\n\nVue 3.4에서 defineModel이 출시되면, 이것이 NameInput.vue를 어떻게 간단하게 만드는지 살펴봐요:\n\n```js\n\u003c!-- NameInput.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"NameInput.vue\"\u003e\n    \u003cinput v-model=\"name\"/\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\n  // 🎉 한 줄로 끝!\nconst name = defineModel\u003cstring\u003e({ required: true })\n\u003c/script\u003e\r\n```\n\n\n\n## 탁상 속에서 이 변경은 상당히 사소해 보일지 모릅니다. 편의성이 약간 향상되긴 했지만, 개발자가 상태를 관리하는 방식에 이것이 어떻게 실제로 영향을 미치는 걸까요? 그저 간단한 매크로인데 이렇게 주장하는 건 너무나 황당한 일이 아닌가요?\n\n실제로 개발자들은 가급적 쉬운 길을 택하려고 합니다. 그리고 그 쉬운 길이 나쁜 관행 중 하나인 경우, 그렇다면 개발자들은 많은 많은 나쁜 관행을 갖춘 코드베이스를 만들어냅니다 — 일명 \"기술 부채(Tech Debt)\"라고도 불리는 것이죠. 1000줄 이상의 React나 Vue 컴포넌트를 보았다면(누구나 그런 경험이 있으시죠?), 그 이유는 컴포넌트가 유기적으로 성장함에 따라 상태를 관리하기 괴로워져서 새 컴포넌트를 분리하는 것보다 동일한 상태를 계속 공유하는 게 더 쉬웠기 때문이라고 할 수 있습니다.\n\n\n\n`defineModel`가 하는 일은 최소한의 저항력 경로를 만들어주는 동시에 팀이 상태에 대해 어떻게 생각할 수 있는 방법을 개선하는 데 도움이 되는 것입니다. 갑자기 계층적 컴포넌트 상태를 관리하는 중간 지점이 미미하게 쉬워지고 상태를 전역 범위로 옮기거나 대형 컴포넌트를 작은 구성 요소로 분해하기를 꺼린다는 유혹을 없애주어 상태를 오르내리는 게 골치 아프다는 것을 없애줍니다 (보통 1000줄 이상 컴포넌트가 생기는 방법).\n\n## 계층적 상태를 단순화하기 위해 defineModel 사용하기\n\n다음과 같은 간단한 연락처 관리 앱을 고려해보세요:\n\n![contact management app](/assets/img/2024-05-14-AConceptualModelofStateinVue34_2.png)\n\n\n\n이 예제에서 계층구조를 주의해서 보시기 바랍니다. 사용자가 Listing.vue에서 연락처를 선택하면 앱은 Details.vue에 세부 정보를 보여주어야 합니다. 사용자가 Details.vue에서 세부 정보를 편집하고 변경 사항을 저장하면 앱은 Listing.vue의 항목을 업데이트해야 합니다.\n\nListing.vue와 Details.vue 간에 상태를 공유하려면 전역 상태이거나 공통 부모 Example3.vue에서 시작하는 계층 상태 여야 합니다. 그렇지 않으면 한 거대한 컴포넌트에 모든 것을 모으려는 유혹이 큽니다!\n\n이 경우에는 우리의 계층구조 상태가 다음과 같습니다:\n\n![상태 개념 모델](/assets/img/2024-05-14-AConceptualModelofStateinVue34_3.png)\n\n\n\n바깥쪽부터 코드를 살펴봐봅시다.\n\n여기에는 부모 컴포넌트인 Example3.vue가 있습니다:\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Example3.vue\"\u003e\n    \u003ch1\u003eExample 3\u003c/h1\u003e\n\n    \u003cp v-if=\"!!selectedContact\"\u003e\n      선택된: { selectedContact.name } ({ selectedContact.handle })\n    \u003c/p\u003e\n\n    \u003cdiv class=\"parent\"\u003e\n      \u003c!-- 👈 왼쪽 가지 --\u003e\n      \u003cListing\n        v-model=\"contacts\"\n        v-model:selected=\"selectedContact\"/\u003e\n\n      \u003c!-- 👉 오른쪽 가지 --\u003e\n      \u003cDetails v-model=\"selectedContact\"/\u003e\n    \u003c/div\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selectedContact = ref\u003cContact\u003e()\n\nconst contacts = ref\u003cContact[]\u003e([{\n  name: 'Charles',\n  handle: '@chrlschn'\n}])\n\u003c/script\u003e\r\n```\n\n이것은 우리의 상태가 살고 있는 루트이며, Listing 및 Details 컴포넌트로 바인딩을 통해 전달됩니다.\n\n\n\n```js\n\u003c!-- Example3.vue에서 스니펫입니다--\u003e\n\u003cListing\n  v-model=\"contacts\"\n  v-model:selected=\"selectedContact\"/\u003e\n\n\u003cDetails v-model=\"selectedContact\"/\u003e\n```\n\n먼저 Details.vue 파일을 살펴봅시다:\n\n```js\n\u003c!-- Details.vue, 오른쪽 폼 입력란 --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Details.vue\"\u003e\n    \u003cdiv v-if=\"!!selected\"\u003e\n      \u003c!-- 사용자 이름 입력 --\u003e\n      \u003clabel\u003e\n        이름\n        \u003cinput v-model=\"name\"/\u003e\n      \u003c/label\u003e\n\n      \u003c!-- 사용자 핸들 입력 --\u003e\n      \u003clabel\u003e\n        핸들\n        \u003cinput v-model=\"handle\"/\u003e\n      \u003c/label\u003e\n\n      \u003c!-- 작업 버튼 --\u003e\n      \u003cdiv\u003e\n        \u003cbutton @click=\"handleCancel\"\u003e완료\u003c/button\u003e\n        \u003cbutton @click=\"handleDone\"\u003e저장\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cp v-else\u003e\n      연락처를 선택하세요\n    \u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selected = defineModel\u003cContact|undefined\u003e({\n  required: true\n})\n\nconst name = ref('')\n\nconst handle = ref('')\n\n// 선택된 값이 업데이트되면 로컬 사본을 업데이트합니다.\nwatch (selected, (contact) =\u003e {\n  if (!contact) {\n    return\n  }\n\n  name.value = contact.name,\n  handle.value = contact.handle\n})\n\n// 변경 내용을 취소하면 모든 것을 되돌립니다.\nfunction handleCancel() {\n  selected.value = undefined\n}\n\n// 변경 사항이 저장되면 선택한 객체를 업데이트합니다.\nfunction handleDone() {\n  if (!selected.value) {\n    return\n  }\n\n  selected.value.name = name.value;\n  selected.value.handle = handle.value;\n}\n\u003c/script\u003e\r\n```\n\n이 컴포넌트는 연락처 세부 정보의 사본을 얻는 state 집합을 가지고 작성되었습니다. 선택된 연락처가 변경되면 컴포넌트가 값들을 로컬 상태로 복사하여 사용자가 저장할 때 까지 상태(이름과 핸들)를 변경할 수 있게 합니다. 이로써 사용자는 편집을 취소할 수도 있습니다.\n\n\n\n(속성 집합이 큰 경우에는 개체의 완전한 반응형 사본을 만들고 직접 바인딩하는 것을 고려하십시오.)\n\n왼쪽에 있는 Listing.vue 컴포넌트에는 연락처 목록이 포함되어 있으며 새 연락처를 추가할 수 있는 옵션이 있습니다.\n\n```js\n\u003c!-- Listing.vue --\u003e\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Listing.vue\"\u003e\n    \u003cdiv class=\"container\"\u003e\n      \u003cContactItem\n        v-for=\"contact in contacts\"\n        :contact=\"contact\"\n        :selected=\"selected == contact\"\n        @click=\"selected = contact\"\u003e\n      \u003c/ContactItem\u003e\n    \u003c/div\u003e\n\n    \u003cdiv\u003e\n      \u003cbutton @click=\"handleAddContact\"\u003e Add contact \u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst contacts = defineModel\u003cContact[]\u003e({\n  required: true\n})\n\nconst selected = defineModel\u003cContact|undefined\u003e('selected', {\n  required: true\n})\n\nfunction handleAddContact() {\n  contacts.value.push({\n    name: '이름',\n    handle: '핸들'\n  })\n}\n\u003c/script\u003e\r\n```\n\n그런 다음 ContactItem.vue에서는 변형이 없으므로 (그리고 양방향 바인딩이 필요하지 않으므로) Listing.vue가 표시 값을 바로 전달합니다:\n\n\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer\n    label=\"Contact.vue\"\n    class=\"contact\"\n    :class=\"{\n      'selected': !!selected\n    }\"\u003e\n    \u003cp class=\"name\"\u003e{ contact.name }\u003c/p\u003e\n    \u003cp class=\"handle\"\u003e{ contact.handle }\u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\ndefineProps\u003c{\n  contact: Contact,\n  selected?: boolean\n}\u003e()\n\u003c/script\u003e\r\n```\n\n이것이 어떻게 모두 함께 작동하는지 봅시다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*EfFxU6oa6uYyKIFA.gif\" /\u003e\n\n간편하게 상호 작용을 단순화하도록 도와주는 defineModel 없이는 여러 emit 및 computed를 작성하는 것이 마찬가지로 이 작은 예시에서도 어느 정도의 마찰을 초래할 수 있기 때문에 바로 전역 상태로 이동하거나 단축키를 사용하는 것이 직관적으로 느껴질 수 있습니다!\n\n\n\n빌리 미즈가 말할 것 같이, \"그러나 기다려! 더 있어요!\"; 이 코드를 이해하기 쉽고 관리하기 쉽도록 만드는 더 많은 방법을 살펴보겠습니다.\n\n## Composables를 사용하여 defineModel\n\nComposables를 활용하면 상태를 컴포넌트에서 분리함으로써 코드를 더욱 간단하고 이해하기 쉽게 만들 수 있습니다. 컴포넌트가 커지면 특히 유용합니다.\n\nVue에서는 이를 쉽게 수행할 수 있으며 리팩토링 및 복잡성 재구성을 간편하게 수행할 수 있습니다.\n\n\n\n우리는 간단히 상태와 함수를 컴포넌트에서 끌어올려서 다른 함수로 넣어주기만 하면 됩니다:\n\n```js\n// useContacts 컴포저블\nexport function useContacts() {\n  const selectedContact = ref\u003cContact\u003e()\n\n  const contacts = ref\u003cContact[]\u003e([{\n    name: 'Charles',\n    handle: '@chrlschn'\n  }])\n\n  function addContact() {\n    contacts.value.push({\n      name: '이름',\n      handle: '핸들'\n    })\n  }\n\n  return {\n    selectedContact,\n    contacts,\n    addContact\n  }\n}\n```\n\n예를 들어, Details.vue에서 논리와 상태를 더 많이 가져와서 다른 컴포저블에 넣고 싶다면, 예를 들어 이름, 핸들 참조값들과 handleCancel() 및 handleDone() 함수들을 또 다른 컴포저블로 옮기고 공유하는 것은 매우 적은 마찰력을 가질 것입니다.:\n\n```js\n// useDetailsEditor.ts\n\n// 👇 선택된 연락처를 받아서 반응형으로 사용하는 방법\n// 여기서는 관찰할 수 있습니다.\nexport function useDetailsEditor(\n  selectedContact: Ref\u003cContact|undefined\u003e\n) {\n  const name = ref('')\n\n  const handle = ref('')\n\n  // 👇 여기서 selectedContact를 관찰하여\n  // 캡슐화된 상태를 업데이트합니다.\n  watch (selectedContact, (contact) =\u003e {\n    if (!contact) {\n      return\n    }\n\n    name.value = contact.name,\n    handle.value = contact.handle\n  })\n\n  function cancel() {\n    selectedContact.value = undefined\n  }\n\n  function done() {\n    if (!selectedContact.value) {\n      return\n    }\n\n    selectedContact.value.name = name.value;\n    selectedContact.value.handle = handle.value;\n  }\n\n  return {\n    name,\n    handle,\n    cancel,\n    done\n  }\n}\n```\n\n\n\n그리고 Details.vue를 업데이트합니다:\n\n```js\n\u003ctemplate\u003e\n  \u003cLabeledContainer label=\"Details.vue\"\u003e\n    \u003cdiv v-if=\"!!selected\"\u003e\n      \u003cdiv\u003e\n        \u003clabel\u003e\n          이름\n          \u003cinput v-model=\"name\"/\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n\n      \u003cdiv\u003e\n        \u003clabel\u003e\n          핸들\n          \u003cinput v-model=\"handle\"/\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n\n      \u003cdiv\u003e\n        \u003cbutton @click=\"cancel\"\u003e완료\u003c/button\u003e\n        \u003cbutton @click=\"done\"\u003e저장\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cp v-else\u003e\n      연락처를 선택하세요\n    \u003c/p\u003e\n  \u003c/LabeledContainer\u003e\n\u003c/template\u003e\n\n\u003cscript setup lang=\"ts\"\u003e\nconst selected = defineModel\u003cContact|undefined\u003e({\n  required: true\n})\n\nconst {\n  name,\n  handle,\n  cancel,\n  done\n} = useDetailsEditor(selected)\n// 👆 여기에서 선택한 연락처를 사용하여 \n// composable에서 감시할 수 있도록 전달합니다\n\u003c/script\u003e\r\n```\n\nVue 3 콤포저블과 Vue 3.4의 defineModel 매크로를 사용하여 관련 상태 및 로직을 깔끔하게 분리하고 캡슐화하는 데 아주 효과적입니다. 이 패턴을 통해 코드를 이 패턴에 맞게 리팩토링하는 것이 얼마나 쉬운지 보여줍니다. 단순히 상태, 함수, 감시자 및 계산된 값을 전부 복사하여 컴포저블에 붙여넣으면 됩니다.\n\n이 패턴을 사용하면 대규모 하위 컴포넌트 트리도 쉽게 관리, 리팩토링 및 테스트할 수 있습니다.\n\n\n\n# 마무리\n\nVue 3.4의 defineModel 소개는 실은 팀이 최상의 방법을 따르고 더 나은, 더 관리 가능한 컴포넌트를 구축하는 데 도움을 줄 것입니다. 계층 형태의 상태를 구성하는 데 드는 많은 마찰을 제거함으로써 팀이 전역 상태에 바로 의존하거나 엉성한 방법을 사용할 가능성을 줄여줍니다.\n\ndefineModel을 Vue 컴포저블과 결합하면 팀이 관련 있는 상태와 로직을 체계적으로 구성하고 캡슐화하여 읽기 쉬운 컴포넌트를 만들 수 있습니다.\n\nEvan You가 Vue 3를 위해 Composition API를 처음 제안했을 때, Options API의 간단함과 접근성을 유지하고 싶어했던 커뮤니티로부터 많은 걱정과 항의가 있었습니다. 그러나 회고적으로 볼 때, Vue를 대규모 프로젝트를 구축하는 팀에 더 나아가게 도와줄 Evan You의 방향이 옳았다는 것을 분명히 알 수 있습니다.\n\n\n\n3.4버전으로 인해 비전이 더욱 완성됐다는 느낌을 받을 수 있어요. 상태 관리를 간소하고 명확하게 만들어서 종종 복잡한 과정에서 어디에 상태를 배치해야 하는지에 대한 결정을 명확하게 도와줍니다. defineModel은 작은 돌처럼 느껴집니다. 바다에 떨어뜨려진 작은 돌이 언젠가 대형파가 될 것 같은 기분이에요!\n\n이 글을 작성하도록 영감을 준 Lefan에게 특별히 감사드려요.","ogImage":{"url":"/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png"},"coverImage":"/assets/img/2024-05-14-AConceptualModelofStateinVue34_0.png","tag":["Tech"],"readingTime":12},{"title":"미스테리를 밝히다 JavaScript의 이상한 부분 탐색하기  1","description":"","date":"2024-05-14 12:32","slug":"2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1","content":"\n\n![이미지](/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png)\n\n자바스크립트는 다양하고 동적인 언어로, 웹에 상호작용성과 기능을 추가하는 능력으로 웹을 채웁니다. 그러나 확장성과 인기 속에서 특정 측면은 \"이상한 부분\"으로 불릴 수 있습니다. 이것들은 개발자들을 종종 당혹케 하는 특이성과 기이함입니다. 특히 이 언어를 처음 사용하는 사람들에게 도움이 됩니다. 이러한 기이함을 이해하면 자바스크립트에 대한 깊은 이해를 가지게 되며 더 견고하고 효율적인 코드를 작성할 수 있는 도구가 됩니다. 이 흥미로운 이야기를 풀어내고 자바스크립트의 이상한 부분을 해소해봅시다.\n\n# 형 강제 변환:\n\n자바스크립트는 동적으로 타입이 지정되는 언어로, 변수는 모든 데이터 유형의 값을 보유할 수 있습니다. 이 유연성은 강력하지만, 유형 강제 변환으로 인해 예기치 않은 동작이 발생할 수 있습니다. 예를 들어, 덧셈 연산자(+)는 피연산자의 유형에 따라 다르게 작동합니다. 피연산자 중 하나가 문자열이면 문자열을 연결하고, 그렇지 않은 경우에는 덧셈을 수행합니다. 이러한 암묵적인 유형 변환을 이해하면 버그를 방지하고 코드 가독성을 향상시킬 수 있습니다.\n\n\n\n```js\nconsole.log(1 + \"2\"); // \"12\"\nconsole.log(1 + 2);   // 3\n```\n\n형 변환이 일부 경우에 유용할 수 있지만, 잠재적인 문제점에 대해 알고 있어야 합니다.\n\n```js\nconsole.log(1\u003c2\u003c3); // true\nconsole.log(3\u003c2\u003c1) ; // true \n// (이유: 3\u003c2=false이므로 false\u003c1이 되고, Number(false)=0 이므로, 0\u003c1= true)\n```\n\n# 프로토타입 상속:\n\n\n\n프로토타입 상속은 자바스크립트의 기본 개념 중 하나로, 객체가 다른 객체로부터 속성과 메서드를 상속하는 방식을 관리합니다. 자바나 C++과 같은 언어에서 볼 수 있는 고전적 상속과는 달리, 자바스크립트의 상속 모델은 프로토타입을 기반으로 하며 객체 지향 프로그래밍에 더 동적이고 유연한 접근법을 제공합니다.\n\n프로토타입 이해하기:\n\n자바스크립트에서 모든 객체는 프로토타입을 가집니다. 프로토타입은 단순히 다른 객체가 속성을 상속하는 객체입니다. 객체의 속성이나 메서드에 접근할 때, JavaScript는 먼저 해당 객체에서 직접 찾습니다. 찾지 못하면 프로토타입 체인을 따라 상위로 올라가 속성을 찾거나 체인의 끝에 도달할 때까지 계속합니다(프로토타입이 null일 때).\n\n```js\nconst person = {\n    firstName: 'John',\n    lastName: 'Doe',\n    fullName: function() {\n        return this.firstName + ' ' + this.lastName;\n    }\n};\n\nconst employee = {\n    position: 'Developer'\n};\n\nemployee.__proto__ = person; // employee의 프로토타입을 person으로 설정\n\nconsole.log(employee.fullName()); // \"John Doe\"\nconsole.log(employee.position);   // \"Developer\"\n```\n\n\n\n위의 예시에서 직원은 원형(person)에서 fullName 메서드를 상속받습니다. 직원.fullName()이 호출되면 JavaScript는 직원에게 fullName 속성을 찾아보고, 찾지 못하면 원형 체인을 따라가 원형에 있는 fullName을 찾습니다.\n\n생성자를 이용한 프로토타입 상속:\n\n생성자와 프로토타입은 종종 함께 사용되어 JavaScript에서 상속을 구현하는 데 사용됩니다. 공유 속성과 메서드를 가진 객체를 만드는 템플릿으로 사용될 생성자 함수를 만들 수 있습니다.\n\n```js\nfunction Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nPerson.prototype.fullName = function() {\n    return this.firstName + ' ' + this.lastName;\n};\n\nfunction Employee(firstName, lastName, position) {\n    Person.call(this, firstName, lastName); // Person 생성자 호출\n    this.position = position;\n}\n\nEmployee.prototype = Object.create(Person.prototype); // Person의 프로토타입에서 상속\nEmployee.prototype.constructor = Employee; // 생성자 재설정\n\nconst johnDoe = new Employee('John', 'Doe', 'Developer');\nconsole.log(johnDoe.fullName()); // \"John Doe\"\nconsole.log(johnDoe.position);   // \"Developer\"\n```\n\n\n\n이 예시에서, Employee 생성자는 Person으로부터 속성과 메서드를 상속받기 위해 그 프로토타입을 Person.prototype의 인스턴스로 설정합니다.\n\nObject.create() 메서드:\n\nObject.create() 메서드는 지정된 프로토타입을 가진 객체를 생성하는 또 다른 방법을 제공합니다.\n\n```js\nconst person = {\n    firstName: 'John',\n    lastName: 'Doe',\n    fullName: function() {\n        return this.firstName + ' ' + this.lastName;\n    }\n};\n\nconst employee = Object.create(person);\nemployee.position = 'Developer';\n\nconsole.log(employee.fullName()); // \"John Doe\"\nconsole.log(employee.position);   // \"Developer\"\n```\n\n\n\n# 스코핑과 클로저:\n\n스코핑과 클로저를 이해하는 것은 깔끔하고 효율적인 JavaScript 코드를 작성하는 데 매우 중요합니다. JavaScript는 함수 수준의 스코프를 가지고 있어 변수들이 선언된 함수 내에서만 유효합니다. 반면에 클로저는 외부 함수의 실행이 완료된 후에도 해당 범위 변수에 대한 접근 권한을 유지할 수 있도록 합니다.\n\n## 스코핑:\n\n스코프란 변수가 선언되고 액세스되는 컨텍스트를 의미합니다. JavaScript에서는 전역 스코프와 지역 스코프 두 가지 주요 유형의 스코프가 있습니다.\n\n\n\n글로벌 스코프: 어떤 함수 안에서도 선언되지 않은 변수들은 전역 스코프에 있게 되며 전체 스크립트 어디에서나 접근할 수 있어요.\n\n```js\nconst globalVar = '나는 글로벌';\n\nfunction foo() {\n    console.log(globalVar); // \"나는 글로벌\"\n}\n\nfoo();\n```\n\n로컬 스코프: 함수 안에서 선언된 변수들은 로컬 스코프에 있어서 해당 함수 내에서만 접근이 가능해요.\n\n```js\nfunction foo() {\n    const localVar = '나는 로컬';\n    console.log(localVar);\n}\n\nfoo(); // \"나는 로컬\"\nconsole.log(localVar); // 에러: localVar가 정의되지 않았어요\n```\n\n\n\n블록 범위: ES6에서 도입된 let 및 const를 사용하여 선언된 변수는 블록 범위로 지정되어 있습니다. 즉, 정의된 블록 내에서만 액세스할 수 있습니다.\n\n```js\nfunction foo() {\n    if (true) {\n        const localVar = '저는 블록 안에 있어요';\n        console.log(localVar);\n    }\n    console.log(localVar); // 에러: localVar가 정의되지 않았습니다\n}\n\nfoo();\n```\n\n## 클로저:\n\n클로저란 함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다. 이를 통해 함수는 외부 함수의 실행이 완료된 후에도 포함하는 범위의 변수에 액세스할 수 있습니다. 다시 말해, 클로저는 내부 함수에서 외부 함수의 범위에 액세스할 수 있게 해줍니다.\n\n\n\n```js\nfunction outer() {\n    const outerVar = 'I am from the outside';\n    \n    function inner() {\n        console.log(outerVar); // The inner function has access to outerVar\n    }\n    \n    return inner;\n}\n\nconst innerFunc = outer();\ninnerFunc(); // \"I am from the outside\"\n```\n\n이 예제에서 inner 함수는 outer 함수를 감싼 클로저를 형성하여 outerVar에 대한 액세스 권한을 유지합니다. outer 함수의 실행이 완료된 후에도 계속 사용할 수 있습니다.\n\n클로저의 일부 사용 사례:\n\n캡슐화: 클로저를 사용하여 비공개 변수를 캡슐화하고 모듈을 생성하여 구현 세부 정보를 숨기고 필요한 기능만 노출시킬 수 있습니다.\n\n\n\n```js\nfunction counter() {\n    let count = 0;\n\n    return {\n        increment: function() {\n            count++;\n        },\n        getCount: function() {\n            return count;\n        }\n    };\n}\n\nconst counterObj = counter();\ncounterObj.increment();\nconsole.log(counterObj.getCount()); // 1\n```\n\n함수 팩토리: 클로저를 사용하면 주변 범위에 따라 특정 동작을 하는 다른 함수를 생성하는 함수를 만들 수 있습니다.\n\n```js\nfunction multiplier(factor) {\n    return function(x) {\n        return x * factor;\n    };\n}\n\nconst double = multiplier(2);\nconsole.log(double(5)); // 10\n```\n\n이벤트 핸들러: 클로저는 이벤트 핸들러에서 널리 사용되며, 이벤트의 컨텍스트와 관련된 변수에 계속 액세스할 수 있도록 합니다.\n\n\n\n```js\nfunction setupCounter() {\n    let count = 0;\n    document.getElementById('btn').addEventListener('click', function() {\n        count++;\n        console.log(count);\n    });\n}\n\nsetupCounter();\n```\n\n# 결론:\n\n이 게시물에서는 JavaScript의 중요한 몇 가지 개념에 대해 다루고 소개했습니다. JavaScript의 이상한 부분들은 처음에는 어렵게 보일 수 있지만, 이를 마스터하는 것은 능숙한 JavaScript 개발자가 되는 데 필수적입니다. 타입 강제 변환, 프로토타입 상속, 스코핑, 클로저를 이해하여 더 예측 가능하고 효율적이며 유지보수 가능한 코드를 작성할 수 있습니다. JavaScript의 별난 점들을 받아들이고, 그것들은 더 이상 장애물이 아닌 코딩 여정에서 사용할 도구로 바뀝니다.\n\n아래 댓글란에 피드백을 주시면 감사하겠습니다.\n\n\n\n\n참고 자료:\n1. [Understanding JavaScript](https://www.udemy.com/course/understand-javascript/)\n   \n2. [Mozilla Developer Network](https://developer.mozilla.org/)","ogImage":{"url":"/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png"},"coverImage":"/assets/img/2024-05-14-UnveilingtheMysteriesNavigatingJavaScriptsWeirdParts1_0.png","tag":["Tech"],"readingTime":6},{"title":"Angular Routes반쯤 타입 지정하는 간단한 꿀팁","description":"","date":"2024-05-14 12:31","slug":"2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped","content":"\n\n\n![Simple Trick To Make Your Angular Routes Semi-Typed](/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png)\n\n링크나 버튼 요소의 [routerLink] 지시문이 하드 코딩된 값을 입력받는 프로젝트를 많이 본 적이 있습니다. 예를 들어:\n\n```js\n\u003ca [routerLink]=\"['/movies', movie.id, 'edit']\"\u003e 영화 편집 \u003c/a\u003e\n```\n\n만약 언젠가 movie를 film으로, edit을 update로 변경하고 싶을 때 링크가 깨지는 경우가 발생할 수 있습니다. 그래서 저는 이에 대한 일종의 방어선으로 작동하는 작은 꼼수를 고안해보았습니다.\n\n\n\n\n## 단계 1: 라우트 정의하기\n\n우리가 몇 개의 인증 관련 라우트들 중 일부를 가지고 있다고 가정해봅시다. auth.routes.ts 파일을 만들고 먼저 타입 또는 인터페이스를 생성할 것입니다:\n\n```js\nexport type AuthRoutes = {\n    login: Route\n    register: Route\n    verifyEmail: Route\n}\n```\n\n이제 인터페이스에 따라 라우트를 선언해보겠습니다:\n\n\n\n```js\nexport const authRoutes: AuthRoutes = {\n    login: {\n        path: 'login',\n        loadComponent: () =\u003e import('./login.component')\n            .then((m) =\u003e m.LoginComponent),\n    },\n    register: {\n        path: 'register',\n        loadComponent: () =\u003e import('./register.component')\n            .then((m) =\u003e RegisterComponent),\n    },\n    verifyEmail: {\n        path: 'verify-email/:token',\n        loadComponent: () =\u003e import('./verify-email.component')\n            .then((m) =\u003e m.VerifyEmailComponent),\n    },\n}\n```\n\n동일한 방식으로, 편의에 맞게 다른 세분화된 route 파일을 만들어보세요.\n\n```js\nexport type MovieRoutes = {\n    movieByActor: Route\n}\n\nexport const movieRoutes: MovieRoutes = {\n    movieByActor: {\n        path: 'dashboard/actors/:actorId/movies/:movieId',\n        loadComponent: import('./movie-details.component')\n            .then(m =\u003e m.MovieDetailsComponent),\n    }\n}\n```\n\n또한 not-found-page.route.ts에 다음과 같은 캐치-올 route를 만들어봅시다:\n\n\n\n```js\nexport type NotFoundPageRoutes = {\n    index: Route\n}\n\nexport const notFoundPageRoutes: NotFoundPageRoutes = {\n    index: {\n        path: '**',\n        loadComponent: () =\u003e import('./not-found.page'),\n    },\n}\n```\n\n## 스텝 2: 라우트 등록하기\n\n앱 라우트 파일인 app.routes.ts로 돌아가거나 애플리케이션 라우트를 정의한 곳으로 이동하세요. 모든 그룹화된 라우트를 여기로 가져와주세요:\n\n```js\ntype GroupedRoutes = [\n    HomeRoutes,\n    AuthRoutes,\n    MovieRoutes,\n    // 모든 것을 수용하는 라우트는 마지막에 위치해야 합니다\n    NotFoundPageRoutes,\n]\n\nconst groupedRoutes: GroupedRoutes = [\n    homeRoutes,\n    authRoutes,\n    movieRoutes,\n    notFoundPageRoutes,\n]\n```\n\n\n\n우리의 루트는 객체 안에 있기 때문에 펼쳐주어야 해요:\n\n```js\nconst flattenedRoutes: Route[] = []\nfor (const routeGroup of groupedRoutes) {\n    for (const route of Object.values(routeGroup)) {\n        flattenedRoutes.push(route)\n    }\n}\n\nexport const AppRoutes = flattenedRoutes\n```\n\n앱 설정에 라우트를 등록해주세요 (일반적으로 app.config.ts 또는 main.ts 파일에 위치합니다):\n\n```js\nimport { ApplicationConfig, importProvidersFrom } from '@angular/core'\n// ... 다른 import들\n\nexport const appConfig: ApplicationConfig = {\n    providers: [\n        // ... 다른 프로바이더들\n        provideRouter(\n\n        \tAppRoutes, // \u003c-- 여기에 펼쳐진 라우트를 import 해요\n\n        ),\n    ],\n}\n```\n\n\n\n## 단계 3: 사용하기\n\n이 시점에서 우리의 솔루션이 준비되었습니다. 테스트 컴포넌트에서의 사용 예시:\n\n```js\nimport { authRoutes, AuthRoutes } from 'src/pages/auth/auth.routes.ts';\n\n@Component({\n    selector: 'app-test',\n    standalone: true,\n    imports: [CommonModule, RouterModule],\n    template: `\n      \u003ca\n        routerLink=\"{ '/' + authRoutes.login.path }\"\n      \u003e\n        로그인\n      \u003c/a\u003e\n          \n      \u003ca \n        routerLink=\"{ '/' + authRoutes.register.path }\"\n      \u003e\n        회원 가입\n      \u003c/a\u003e\n  \n      \u003c!-- 경로 매개 변수 대체 --\u003e\n      \u003ca \n        routerLink=\"{ \n          '/' + authRoutes.verifyEmail.path.replace(':token', token) \n        }\"\u003e\n          이메일 확인\n      \u003c/a\u003e\n\n      \u003c!-- 컨트롤러 클래스 내에서 사용 --\u003e\n      \u003cbutton (click)=\"goToMoviesHome()\"\u003e\n        내 대시보드\n      \u003c/button\u003e\n      \n      \u003cbutton (click)=\"goToMovie(actorId, movieId)\"\u003e\n        영화 상세 정보 보기\n      \u003c/button\u003e\n    `,\n    styleUrl: './test.component.scss',\n})\nexport class TestComponent {\n    readonly authRoutes: AuthRoutes = authRoutes\n    \n    token = 'abcd1234'\n    movieId = '2'\n    actorId = '1'\n    \n    goToMoviesHome() {\n      this.router.navigateByUrl('/' + this.movieRoutes.index.path)\n    }\n\n    goToMovie(actorId: string, movieId: string) {\n      this.router.navigateByUrl('/' + \n        this.movieRoutes.movieByActor\n          .replace(':actorId', this.actorId)\n          .replace(':movieId', this.movieId)\n      )\n    }\n}\n```\n\n이제 경로가 원치 않는 링크 차단에 대한 정도로 더 안전합니다. 한 곳에서 경로 값을 변경하면 모든 링크가 그에 맞게 업데이트됩니다.\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 반드시 글쓴이를 클랩하고 팔로우해 주세요 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png"},"coverImage":"/assets/img/2024-05-14-SimpleTrickToMakeYourAngularRoutesSemiTyped_0.png","tag":["Tech"],"readingTime":5},{"title":"Nodejs는 단일 스레드인가요","description":"","date":"2024-05-14 12:29","slug":"2024-05-14-IsNodejssingle-threaded","content":"\n\n\n![Node.js](/assets/img/2024-05-14-IsNodejssingle-threaded_0.png)\n\n아마도 노드.제이에스(Node.js)는 싱글 스레드, 비동기 런타임 환경이라고 들어봤을 것입니다. 그러나 이는 완전히 사실이 아닙니다. JavaScript 환경 자체는 하나의 스레드에서 실행되지만, 노드.제이에스 아키텍처에서 Libuv라는 중요한 구성 요소가 또 있습니다.\n\n## Libuv란?\n\nLibuv는 논 블로킹 I/O 작업을 추상화하기 위해 노드.제이에스를 위해 원래 작성된 C 라이브러리입니다.\n\n\n\n\n## Libuv를 신경 써야 하는 이유\n\nNode.js에서 Libuv를 이해하는 것이 중요한 이유는 Libuv가 비동기 I/O 기능을 제공하여 높은 동시성 및 I/O 바운드 작업을 효율적으로 처리하여 응답성과 확장성을 보장하기 때문입니다.\n\n이 게시물에서는 Libuv의 주요 기능 중 하나인 스레드 풀에 대해 더 자세히 살펴보겠습니다.\n\n## Libuv의 스레드 풀이란 무엇인가요?\n\n\n\nLibuv는 파일 시스템 및 DNS 작업과 같이 이벤트 루프를 차단할 수 있는 일부 I/O 작업을 오프로드하기 위해 작업자 스레드 풀을 사용합니다. 스레드 풀을 통해 이러한 작업이 주 이벤트 루프를 차단하지 않고 비동기적으로 수행되어 Node.js가 반응적이고 효율적으로 유지되도록합니다.\n\n## Libuv의 스레드 풀에서 무슨 일이 벌어질까요?\n\n태스크는 이벤트 루프에서 스레드 풀로 전달되며, 주로 두 가지 유형으로 분류됩니다:\n\n- I/O 집중적인\n\n\n\n- DNS: dns.lookup(), dns.lookupService(). \n- 파일 시스템: fs.FSWatcher()을 제외한 모든 파일 시스템 API\n\n2. CPU 집약적\n\n- Crypto: crypto.pbkdf2(), crypto.scrypt(), crypto.randomBytes(), crypto.randomFill(), crypto.generateKeyPair(). \n- Zlib: 명시적으로 동기화되지 않는 모든 zlib API는 libuv의 스레드 풀을 사용합니다.\n\n*C++ 애드온도 스레드 풀을 사용할 수 있습니다.\n\n\n\n기본 쓰레드 수는 4입니다. 위에서 언급한 작업들을 많이 의존한다면 UV_THREADPOOL_SIZE를 늘리거나 쓰레드 풀에 대한 경합을 피하기 위해 이러한 함수들을 사용하지 않는 것이 좋습니다.\n\n## 결론\n\nNode.js가 종종 완전히 싱글 스레드로 오해되는 반면, Libuv와 그 쓰레드 풀의 역할을 이해하면 좀 더 세밀한 그림이 드러납니다. Node.js는 Libuv의 기능을 활용하여 I/O와 CPU 집약적 작업을 효율적으로 처리합니다.","ogImage":{"url":"/assets/img/2024-05-14-IsNodejssingle-threaded_0.png"},"coverImage":"/assets/img/2024-05-14-IsNodejssingle-threaded_0.png","tag":["Tech"],"readingTime":2},{"title":"Vue 3  동적 컴포넌트","description":"","date":"2024-05-14 12:29","slug":"2024-05-14-Vue3DynamicComponents","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3DynamicComponents_0.png\" /\u003e\n\n블로그 포스트 목록이 있다고 상상해봅시다 (여기 예시를 사용하고 있어요). 대부분의 경우, 모든 포스트가 너무 비슷해서 우리는 하나의 컴포넌트를 추출하고 재사용하고 싶을 것입니다. 이를 blogPost.vue라고 부를게요. 이런 경우에는 제목, 부제목 및 이미지를 표시하고 싶을 때 사용할 수 있어요.\n\n이제 블로그 포스트가 다른 특성을 가지고 있다고 상상해보세요. 어떤 포스트는 이미지 대신 상호작용이 필요한 인포그래픽을 가지고 있을 수도 있고, 어떤 것은 그저 다른 디자인이 필요할 수도 있어요. 이 문제를 해결하는 한 가지 방법은 blogPost.vue 컴포넌트 내부에 많은 if (조건부) 렌더링을 만드는 것이 있습니다. 다른 방법은 동적 컴포넌트를 사용하는 것이죠!!\n\n## 예제\n\n\n\n위에서 시작한 프로젝트를 확장해 나가려고 합니다. 이것은 Medium에서 가져온 블로그 포스트 목록입니다. 현재 이들은 모두 같은 디자인을 가지고 있지만, 동적 컴포넌트를 사용하여 컴포넌트를 깨끗하게 유지하면서 세 가지 다른 디자인을 만들 것입니다.\n\n기본적인 blogPost.vue 컴포넌트는 다음과 같이 보입니다:\n\n```js\n\u003cscript setup\u003e\nconst props = defineProps(['post'])\nconst openPostWindow = (url) =\u003e {\n  window.open(url, '_blank')\n}\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"card\" @click=\"openPostWindow(post.mediumUrl)\"\u003e\n    \u003cdiv class=\"card__header\"\u003e\n      \u003cimg :src=\"`https://miro.medium.com/v2/resize:fill:500:200/${post.previewImage.id}`\" alt=\"Post Image\" class=\"post-image\" /\u003e\n\n    \u003c/div\u003e\n    \u003cdiv class=\"card__body\"\u003e\n      \u003ch4\u003e\n        { post.title }\n      \u003c/h4\u003e\n      \u003cp\u003e\n        { post.extendedPreviewContent.subtitle }\n      \u003c/p\u003e\n    \u003c/div\u003e\n    \u003cdiv class=\"card__footer\"\u003e\n      \u003cdiv class=\"user\"\u003e\n        \u003cdiv class=\"user__info\"\u003e\n          \u003csmall\u003e\n            { Math.ceil(post.readingTime) } 분\n          \u003c/small\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cstyle scoped\u003e\n /* 스타일은 실제 저장소에 있습니다 */\n\u003c/style\u003e\n```\n\n\n\n```javascript\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\n\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\n\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"MediumPreview\" :post=\"post\" v-for=\"post in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n지금까지 잘 진행되고 있어요! 이제 우리는 동적 접근 방식을 사용하고 있습니다. component 키워드를 사용하여 Vue에게 MediumPreview.vue 컴포넌트를 사용하도록 하고 있어요. 결과는 이렇게 나와요:\n\n![2024-05-14-Vue3DynamicComponents_1](/assets/img/2024-05-14-Vue3DynamicComponents_1.png)\n\n\n\n\n## 동적이 멋있어지는 때\n\n지금까지 우리는 동적 접근 방식만 사용하여 동일한 컴포넌트를 표시했습니다. 이것은 좋은 시작점이지만, 동적 컴포넌트의 진정한 힘을 활용하지 못합니다. 그것은 여러 컴포넌트를 사용할 때에만 얻을 수 있습니다. 그래서 포스트용으로 또 다른 디자인을 추가해 볼까요?\n저는 단순히 MediumPreview2.vue로 불리는 다른 컴포넌트를 만들었습니다. 보기에는 비슷해 보이지만, 이 예제에서는 중요하지 않습니다. 각 컴포넌트가 코드를 더 깨끗하게 만드는 충분히 다른 컴포넌트임을 상상해 봅시다.\n\n이제 부모 컴포넌트는 이렇게 생겼습니다.\n\n```js\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\n\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\nimport MediumPreview2 from './blogDesigns/MediumPreview2.vue'\n\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"index % 2 === 0 ? MediumPreview : MediumPreview2\" :post=\"post\" v-for=\"(post, index) in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n\n\n결과는 아래와 같습니다:\n\n![Vue3 Dynamic Components](/assets/img/2024-05-14-Vue3DynamicComponents_2.png)\n\n## 최종 목표\n\n동적 컴포넌트의 일반적인 사용 사례는 사용자가 어떤 종류의 뷰/디자인을 사용하고 싶은지 선택할 수 있는 탭일 수도 있습니다. 따라서 사용자가 보여져야 하는 디자인의 종류를 선택할 수 있는 탭을 포함한 예제를 확장할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-Vue3DynamicComponents_3.png\" /\u003e\n\nPinia store를 사용하여 쉽게 이루어집니다. 어떤 디자인을 보여줄지의 값을 저장하기 위한 Pinia store를 사용합니다 →\n\n```js\n\u003cscript setup\u003e\nimport { usePostsStore } from './../stores/posts'\nimport { useTabStore } from './../stores/tab'\nimport MediumPreview from './blogDesigns/MediumPreview.vue'\nimport MediumPreview2 from './blogDesigns/MediumPreview2.vue'\n\nconst componentMap = { MediumPreview, MediumPreview2 }\nconst tabStore = useTabStore()\nconst postStore = usePostsStore()\n\u003c/script\u003e\n\n\u003ctemplate\u003e\n  \u003cdiv class=\"container\"\u003e\n    \u003ccomponent :is=\"componentMap[tabStore.tab]\" :post=\"post\" v-for=\"(post, index) in postStore.posts\" :key=\"post.title\"\u003e\n    \u003c/component\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\r\n```\n\n## 결론\n\n\n\n동적 구성 요소를 설정하는 것은 코드베이스를 간단하게 유지하고 분할하는 효과적인 방법일 수 있어요. 새로운 디자인을 추가하는 것은 완전히 별도의 파일에서 할 수 있어서 현재 구성 요소에 오류와 버그를 도입할 가능성이 줄어들어요.\n\n여기서 전체 예제 repo를 확인하세요\n\n여기서 데모 사이트를 확인하세요\n\n아래 내용도 참고해보세요:\n\n\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우하세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보세요","ogImage":{"url":"/assets/img/2024-05-14-Vue3DynamicComponents_0.png"},"coverImage":"/assets/img/2024-05-14-Vue3DynamicComponents_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년을 향한 새로운 JavaScript 7 기능","description":"","date":"2024-05-14 12:27","slug":"2024-05-14-7NEWJavaScript2024Features","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png\" /\u003e\n\n2024년 JavaScript 업데이트는 7가지 주요 기능을 소개합니다.\n\n텍스트와 날짜를 간편하게 처리하는 방법부터 프로그램이 함께 기다리고 작동하는 새로운 방법, 그리고 패턴을 더 쉽게 찾을 수 있도록 도와주는 기능까지 있습니다.\n\n뉴스를 확인해보세요!\n\n\n\n# 잘 형성된 유니코드 문자열\n\n잘 형성된 유니코드 문자열은 JavaScript에서 UTF-16 인코딩으로 올바르게 형식화된 문자열을 보장하는 방법을 소개합니다.\n\n이 기능은 JavaScript가 유니코드를 다루는 방식을 개선하여, 문자열 내의 부적절하게 쌍을 이룬 서로 대용 코드 포인트를 감지하고 수정함으로써 다른 언어 및 문자와 작업하기 쉬워지도록 목표로 합니다.\n\n## 사용법 실습\n\n\n\n사용자가 생성한 다양한 언어와 기호를 포함할 수 있는 콘텐츠로 작업 중이라고 상상해보세요.\n\n이 콘텐츠가 올바르게 인코딩되어 있는지 확인하는 것은 오류 없이 처리하고 표시하는 데 중요합니다.\n\n- 올바르게 형식이 지정된 유니코드 문자열을 확인하세요: String.prototype.toWellFormed을 사용하여 문자열이 올바르게 인코딩되어 있는지 확인하고 혼자 있는 서로게이트가 있는지 확인합니다.\n\n```js\nconst exampleString = \"Example with Unicode 🌈\";\nconsole.log(exampleString.isWellFormed()); // 혼자 있는 서로게이트가 없으면 True\n```\n\n\n\n- Unicode 문자열을 잘 구성된 문자열로 변환하십시오: String.prototype.toWellFormed를 사용하여 불완전한 서로게이트가 포함된 문자열을 Unicode 대체 문자(U+FFFD)로 대체하여 잘 구성된 문자열로 변환하십시오.\n\n```js\nconst malformedString = \"Example with a lone surrogate \\uD800\";\nconsole.log(malformedString.toWellFormed()); // \"\\uD800\" 대신 U+FFFD로 대체됩니다\n```\n\n이 기능은 국제화 또는 이모지를 다룰 때 특히 유용하며, 다양한 플랫폼 및 환경에서 문자열을 더 신뢰성 있게 처리할 수 있도록 합니다.\n\n이는 웹 애플리케이션에서 흔한 버그 원인을 다루며, JavaScript가 글로벌 콘텐츠를 처리하는 데 더 강력하도록 만듭니다.\n\n\n\n# Atomic waitSync\n\nAtomic waitSync는 기존 Atomics API를 보완하는 동기화 기본 요소입니다.\n\n이를 통해 메인 스레드와 워커 간의 더 나은 조정을 가능하게 하는 공유 메모리 위치에서 동기화 대기가 가능하며, 이는 복잡한, 멀티 스레드 웹 애플리케이션에서 중요합니다.\n\n## 동기화 예제\n\n\n\n웹 어플리케이션에서 웹 워커에서 중달처리나 실시간 데이터 처리를 수행하는 경우,\n\n주요 스레드와 워커 스레드를 효율적으로 조정하는 것이 성능과 데이터 무결성을 유지하는 데 중요합니다.\n\n```js\n// 공유 Int32Array 버퍼를 가정\nconst sharedBuffer = new SharedArrayBuffer(1024);\nconst intArray = new Int32Array(sharedBuffer);\n\n// 주요 스레드가 값을 설정함\nAtomics.store(intArray, 0, 123);\n\n// 워커 스레드가 값이 변경될 때까지 동기적으로 대기함\nAtomics.waitSync(intArray, 0, 123);\n\n// 워커에서 일부 작업을 수행한 후\nAtomics.store(intArray, 0, 456); // 공유 메모리 값 변경\n\n// 주요 스레드는 이 변경을 통지받거나 이에 대해 조치를 취할 수 있음\n```\n\n원자적인 waitSync는 복잡하고 오류를 유발할 수 있는 메시징이나 폴링 메커니즘을 사용하지 않고 주요 스레드와 웹 워커 간 작업을 동기화하는 더 직관적인 방법을 제공하여 JavaScript의 동시성 모델을 향상시킵니다.\n\n\n\n병렬 처리를 필요로 하는 응용 프로그램의 성능과 신뢰성을 크게 향상시킬 수 있습니다.\n\n# RegExp v Flag with Set Notation + Properties of Strings\n\n정규 표현식(RegEx)에서 문자열의 속성과 집합 표기법과 함께 v 플래그를 도입하는 것은 JavaScript의 패턴 매칭 능력을 상당히 향상시킨 것을 의미합니다.\n\n이 기능은 RegEx의 표현력과 강력한 구문을 더욱 간단하게 만들어주며, 복잡한 패턴을 기반으로 텍스트를 매칭하고 교체하는 프로세스를 단순화합니다. 이는 특히 국제화 및 다국어 콘텐츠를 다루는 작업에 매우 유용합니다.\n\n\n\n## 고급 검색\n\nv 플래그와 집합 표기법 및 문자열 속성을 결합하면 Unicode 속성에 의해 정의된 특정 문자 집합과 일치시킬 수 있는 정규 표현식을 만들 수 있습니다.\n\n이 개선은 특히 다양한 문자 집합과 다국어 지원이 필요한 응용 프로그램에 유용합니다.\n\n- 화이트스페이스 또는 이모지 일치: v 플래그는 집합 표기법 내에서 Unicode 속성 이스케이프의 사용을 가능하게 하며, 이를 통해 이모지나 화이트스페이스 문자와 같은 광범위한 문자 범주와 정확히 일치시킬 수 있습니다.\n\n\n\n```js\nconst regex = new RegExp(\"[\\\\p{Emoji}\\\\p{White_Space}]\", \"v\");\n```\n\n예시 사용법: 이모지와 공백이 모두 포함된 문자열에 대해 정규식을 테스트하면 이러한 문자 유형을 정확하게 식별하는 능력을 확인할 수 있습니다.\n\n```js\nconst testString = \"Here is an emoji 😊 and some spaces\";\nconsole.log(testString.match(regex)); // 이모지와 공백이 일치할 것으로 예상됩니다\n```\n\n이 RegExp의 개선 사항은 복잡한 문자 집합을 다룰 때 보다 직관적이고 오류 가능성이 낮아져서 다양한 언어와 기호를 수용해야 하는 글로벌 응용 프로그램을 다룰 때 매우 유용합니다.\n\n\n\n# 파이프라인 연산자 (|`)\n\n파이프라인 연산자는 JavaScript에서 연산 순서를 더 가독성 있고 기능적으로 작성할 수 있는 방법을 소개합니다.\n\n이를 통해 개발자들은 중첩된 함수 호출보다 직관적이고 깔끔한 방식으로 함수를 연결할 수 있으며, 데이터 처리나 함수형 프로그래밍 환경에서 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.\n\n## 예제\n\n\n\n여러 번의 변환을 적용해야 하는 상황을 생각해봅시다. 파이프라인 연산자를 사용하면 각 단계가 명확하게 구분되어 코드를 더 쉽게 따를 수 있어요.\n\n```js\n// 파이프라인에 사용될 예시 함수들\nconst double = n =\u003e n * 2;\nconst increment = n =\u003e n + 1;\n\n// 함수들을 적용하기 위해 파이프라인 연산자 사용\nlet result = 5 |\u003e double |\u003e increment;\n\nconsole.log(result); // 결과는 11이 출력됩니다.\n파이프라인 연산자는 JavaScript 내에서 함수형 프로그래밍 스타일로 가는 중요한 한 발걸음을 의미해요.\n```\n\n현대 JavaScript 개발의 가독성과 구성 목표와 잘 맞고, 표현력이 풍부한 구문적 해결책을 제공합니다.\n\n# Temporal API\n\n\n\nTemporal API는 JavaScript에서의 날짜 및 시간 조작의 복잡성과 일관성 부재를 해결합니다.\n\n날짜, 시간, 시간대 및 기간 처리를 다루기 위한 다양한 객체 및 메서드를 제공하여 Temporal API는 시간 관련 데이터 처리를 단순화합니다.\n\n이를 통해 Temporal API는 견고하고 표준화된 솔루션으로 제3 자 라이브러리가 필요한 필요성을 대체하고자 합니다.\n\n## Temporal API 사용 예제\n\n\n\n날짜와 시간을 다루다 보면, 시간대, 일광 절약 시간 변경 및 형식 지정과 관련된 작업을 해야 합니다.\n\nTemporal API를 사용하면 이러한 작업이 더 간단하고 오류가 적은 방식으로 처리됩니다.\n\n```js\n// 특정 시간대에서 날짜-시간 객체 생성\nconst meetingDate = Temporal.PlainDateTime.from(\"2024-03-25T15:00:00\");\nconst zonedDate = meetingDate.withTimeZone(\"America/New_York\");\n\nconsole.log(zonedDate.toString()); // \"2024-03-25T15:00:00-04:00[America/New_York]\"\n\n// 두 날짜 간의 차이 계산\nconst startDate = Temporal.PlainDate.from(\"2024-01-01\");\nconst endDate = Temporal.PlainDate.from(\"2024-03-01\");\nconst difference = startDate.until(endDate);\n\nconsole.log(difference.toString()); // \"P2M\" (2개월간의 기간)\n```\n\n이 기능은 기존 Date 객체보다 훨씬 직관적이고 강력한 도구 세트를 제공하여 날짜와 시간 조작의 모든 측면에 대해 개발자들에게 큰 개선을 제공합니다.\n\n\n\nJS 애플리케이션에서 시간 데이터를 다룰 때 개발 경험을 크게 향상시킵니다.\n\n# 레코드와 튜플\n\n레코드와 튜플은 JavaScript에서 새롭고 변경할 수 없는 데이터 구조로 제안되어 코드 신뢰성과 간결함을 향상시키려고 합니다.\n\n- 레코드는 한 번 생성되면 변경할 수 없지만 개체와 유사한 변경할 수 없는 키-값 쌍을 만들 수 있습니다.\n- 튜플은 생성 후 변경할 수 없는 배열과 유사한 변경할 수 없는 순서가 지정된 목록입니다.\n\n\n\n이러한 구조들은 데이터가 예기치 않게 변경되지 않도록 보장해주어 함수형 프로그래밍 및 애플리케이션 상태 관리에 특히 유용합니다.\n\n## 예시\n\n레코드와 튜플이 어떻게 적용될 수 있는지 살펴봅시다. 사용자 프로필 관리 시나리오에서 레코드를 사용하여 애플리케이션의 생명주기 내내 데이터 무결성을 유지하는 방법을 알아봅시다.\n\n레코드를 사용하여 변경할 수 없는 사용자 프로필 만들기:\n\n\n\n- 사용자 프로필을 변경할 수 없는 키-값 쌍으로 정의하는 Records를 사용하여 데이터 무결성을 유지합니다. 사용자 프로필을 설정하면 변경할 수 없으므로 데이터의 무결성이 보장됩니다.\n\n```js\nconst userProfile = #{\n  name: \"Jane Doe\",\n  age: 28,\n};\n```\n\nTuples를 사용하여 순서가 있는 데이터를 관리하는 방법:\n\n- Tuples를 구현하여 포인트나 좌표와 같은 데이터 시퀀스를 처리합니다. 한 번 초기화되면 수정 실수의 위험이 사라지고 일정합니다.\n\n\n\n```js\nconst points = #[1, 2, 3];\n```\n\n또한 애플리케이션 실행 중 데이터 상태에 대해 확신을 제공하여 의도치 않은 변이로 인한 버그를 방지합니다.\n\n특히 복잡한 상태 관리가 필요하거나 함수형 프로그래밍 패턴이 적용된 애플리케이션에서 특히 유용합니다.\n\nECMAScript 2024에 예정된 이러한 기능은 그뿐만 아니라 JavaScript를 현대화하고 더 강력하게 만들며 개발자 경험을 개선하는 필수적인 단계입니다.\n\n\n\n데이터 무결성과 코드 가독성을 모두 고려한 레코드와 튜플, 그리고 향상된 패턴 매칭을 통해 ES15은 개발자들이 더 효율적이고 신뢰할 수 있으며 유지보수가 용이한 애플리케이션을 작성할 수 있는 도구를 제공할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png"},"coverImage":"/assets/img/2024-05-14-7NEWJavaScript2024Features_0.png","tag":["Tech"],"readingTime":6},{"title":"WASM을 전혀 잘못 이해하고 있었어요 ","description":"","date":"2024-05-14 12:24","slug":"2024-05-14-IwasunderstandingWASMallwrong","content":"\n\n# 요약\n\n- WASM은 프론트엔드와 백엔드 모두에 적합하며 브라우저에서 JavaScript의 실행 속도를 높이는 데 사용됩니다.\n- 백엔드에서의 WASM은 외부 함수 인터페이스(FFI)와는 다르게 작동합니다. WASM은 빠르고 효율적으로 실행되도록 설계되었습니다.\n- WASM의 속도는 저수준 이진 형식, 간단한 메모리 모델 및 미리 컴파일된 특성에서 나옵니다. 이는 오버헤드를 최소화하여 네이티브 코드와 유사한 성능을 제공합니다.\n- 저는 Rust와 WASM을 사용하여 wa-ulid에서 ULID 생성을 최적화했습니다. 그 결과 JavaScript 버전보다 40배 빨랐습니다.\n- 현재 WASM 파일은 JavaScript보다 크기가 크기 때문에 도전적일 수 있습니다. 그러나 WASM 툴체인과 최적화 기술이 개선됨에 따라, WASM은 백엔드 및 프론트엔드 애플리케이션에 더욱 실용적일 것입니다.\n\n# 소개\n\n개발자로서 저는 종종 Gartner Hype Cycle과 유사한 새로운 기술을 탐험하는 단계를 거치곤 합니다. 이 주기는 새로운 기술을 채택하는 일반적인 경로를 보여줍니다. 이 글에서는 WASM을 통해 백엔드 성능을 향상시키는 방법에 대해 의심에서 호기심으로 변화하는 과정을 설명하고 싶습니다.\n\n\n\n![이미지](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png)\n\nWASM은 저수준 명령어 형식입니다. 이는 C, C++, Rust와 같은 언어들의 컴파일 대상으로 설계되었습니다. 주요 목표는 고성능 웹 애플리케이션을 가능하게 하는 것입니다. 그러나 성능이 중요한 경우 서버 측에서도 점점 더 사용되고 있습니다.\n\n내 WASM 여행은 좋은 일과 나쁜 일이 있었습니다. 과대 기대로 시작해서 실망으로 끝났지만 확고한 이해와 실용적인 적용으로 마무리되었습니다.\n\n# 초기 오해들\n\n\n\nWASM에 대한 소문을 처음 들었을 때 기대가 컸어요. WASM을 통해 복잡한 계산을 웹 브라우저에 원활하게 통합할 수 있을 것으로 생각했어요. 이것은 FFI가 고수준 언어가 기계 코드를 실행할 수 있도록 하는 방법과 비슷하다고 느꼈어요.\n\n## FFI란 무엇인가요?\n\nFFI는 한 언어의 코드가 다른 언어의 코드를 직접 호출할 수 있게 해줍니다. 성능이 중요하고 로직의 일부가 C 또는 Rust와 같은 저수준 언어로 구현된 경우 사용됩니다. 그 저수준 코드는 그런 후 Python이나 JavaScript와 같은 고수준 언어에서 호출됩니다.\n\n나는 WASM이 FFI와 같은 것으로 여겨, 브라우저에서 기계 수준의 코드를 실행하는 방법일 것이라고 생각했어요. WASM은 고수준 언어를 저수준 바이너리 형식으로 컴파일하기 때문에 이것은 타당했던 것 같아요. 하지만 WASM의 독특한 아키텍처와 제약을 간과하고 있던 거였죠.\n\n\n\n## WASM과 FFI 비교\n\nWASM을 FFI로 보았을 때, WASM이 전통적인 기계 코드와 다른 점을 그리워했어요. FFI에서는 종종 호스트 언어와 외부 함수 간 전환 시 주요 오버헤드가 발생합니다. 서로 다른 메모리 레이아웃 간 데이터 이동 또한 비용이 많이 듭니다.\n\n# 현실 확인\n\nWASM을 더 탐험하면서, 처음 기대와 실제 사용 간의 차이를 볼 수 있었어요.\n\n\n\n## WASM과 Rust로의 첫 걸음\n\n나는 WASM을 실험하기 시작했고, wasm-bindgen이라는 도구를 사용했다. 이 도구는 WASM 모듈과 JavaScript가 함께 작동할 수 있도록 도와준다. 나의 첫 예제는 간단했다:\n\n```js\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: u32, b: u32) -\u003e u32 {\n  a + b\n}\n```\n\nLink-time optimization (LTO)을 사용하여 wasm-pack을 이용하면, 이 기본적인 덧셈 함수가 작은 214바이트의 WASM 모듈로 컴파일된다. 처음에는 이로 인해 WASM이 간결하고 효율적인 코드를 제공할 수 있다는 것을 입증한 것으로 여겨졌다.\n\n\n\n## WAT 형식 알아보기\n\n이 작은 코드 조각이 어떻게 작동하는지 더 잘 이해하기 위해, WAT(WebAssembly 텍스트 형식) 버전을 살펴보았습니다. WAT는 WASM 이진 코드의 가독성 있는 버전입니다. WASM 애플리케이션을 디버깅하고 최적화하는 데 필수적입니다. 'add' 함수의 WAT는 다음과 같습니다:\n\n```js\n(module\n  (type (;0;) (func (param i32 i32) (result i32)))\n  (func (;0;) (type 0) (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (memory (;0;) 17)\n  (export \"memory\" (memory 0))\n  (export \"add\" (func 0)))\n```\n\n이 간결한 형식은 WASM의 간단한 계산 작업에 대한 효율성을 보여줍니다 — 여분의 오버헤드가 없고, 함수를 수행하는 핵심 연산만 있습니다.\n\n\n\n## 복잡성 추가의 영향\n\n나는 그 예시를 수정하여 문자열 작업을 추가하여 모듈 크기에 미치는 영향을 살펴보았습니다:\n\n```js\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: u32, b: u32) -\u003e u32 {\n    let a = a.to_string().parse::\u003cu32\u003e().unwrap();\n    let b = b.to_string().parse::\u003cu32\u003e().unwrap();\n    return a + b;\n}\n```\n\n똑같은 계산을 하지만, 이 버전은 훨씬 더 큰 14.5KB의 WASM 모듈을 생성했습니다. WAT 파일은 7,126줄 이상으로 늘어나며, 문자열 처리의 추가 복잡성과 오버헤드를 반영했습니다.\n\n\n\n![2024-05-14-IwasunderstandingWASMallwrong_1.png](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_1.png)\n\n웹어셈블리( WebAssembly) 인스턴스 생성자는 4KB 미만의 모듈만 동기적으로 컴파일할 수 있습니다. 더 큰 모듈은 비동기적으로 컴파일해야 합니다. 하지만 그 한도 이내로 WASM 파일을 유지하는 것은 불가능한 것 같았어요.\n\n# 환상의 깨달음\n\n문자열 조작과 같은 기능을 추가하면 WASM 모듈의 크기가 급격하게 증가하는 것이 큰 과제였습니다. 파일 크기의 급증은 WASM이 경량이고 효율적인 형식으로서의 약속과 상반됐어요.\n\n\n\n## WASM 모듈 크기 최적화\n\n이러한 문제를 해결하기 위해 WASM 모듈 크기를 최적화하는 방법을 탐색했습니다. 다음은 WASM 애플리케이션의 크기를 최소화하기 위한 몇 가지 전략입니다:\n\n- 패닉 회피하기: Rust의 패닉 처리는 오버헤드를 추가합니다. `Option` 및 `Result` 유형을 사용하여 오류를 효율적으로 처리하고 패닉의 부풀어 오름을 피합니다.\n- 문자열 사용 제한: 동적 문자열 작업은 WASM 모듈 크기를 크게 불리울 수 있습니다. 정수 또는 고정 크기 데이터 유형을 사용하여 모듈을 간결하게 유지합니다.\n- 링크-시간 최적화 (LTO): Rust 컴파일러에서 LTO를 활성화하면 사용되지 않는 코드를 제거하고 크레이트 경계를 효율적으로 최적화하여 컴파일된 WASM 크기를 줄일 수 있습니다.\n- 수동 트리 셰이킹: Rust-to-WASM 파이프라인에서 자동 트리 셰이킹이 제한되지만, 필요한 함수 및 종속성만 포함되도록 수동으로 확인하여 부풀림을 줄입니다.\n\n이러한 노력에도 불구하고 때로는 복잡한 데이터 유형 및 고수준 프로그래밍 작업에서 흔히 발생하는 작업으로 인해 극복하기 어려운 과제가 있었습니다.\n\n\n\n## 웹어셈블리(WASM)에서 동적 언어\n\nWASM의 난점은 러스트에만 해당하는 것은 아닙니다. 특히 파이썬과 같은 동적 언어는 더 큰 어려움을 겪습니다. 왜 그런지 살펴보려면 동적 언어를 WASM으로 컴파일하는 것을 고려해보세요:\n\n- 인터프리터 컴파일: 파이썬의 경우, 사용자의 코드뿐만 아니라 전체 인터프리터를 WASM으로 컴파일해야 합니다. 이는 언어가 지원하는 모든 내장 함수와 라이브러리를 포함합니다.\n- 코드 실행: WASM으로 컴파일된 파이썬 코드를 실행하려면 인터프리터 내에서 인터프리터를 실행해야 합니다. 이는 상당한 오버헤드를 발생시키며 큰 WASM 이진 파일을 만들 수 있습니다.\n\n\n\n고도 정적 타입 컴파일 언어인 Go의 경우에도, 최소 WASM 파일 크기는 Go 프로그래밍 언어 위키에 따르면 2MB입니다.\n\n## 커뮤니티 도전 과제\n\n나는 다른 개발자 커뮤니티와 같이 저의 환멸을 겪었습니다. 많은 기사들이 유사한 어려움을 논의했습니다:\n\n- Zaplib 사후 분석: 이는 성능 향상 부족 및 개발 복잡성으로 인해 WASM을 버리기로 한 스타트업의 선택을 자세히 다룹니다.\n- 나무 흔들기, 식물학적으로 오류가 있는 알고리즘: 이는 WASM 도구 체인에서 나무 흔들기의 미숙함을 강조하며, 사용하지 않는 코드를 제거하여 최종 바이너리 크기를 줄이는 중요한 프로세스를 강조합니다.\n\n\n\n이 커뮤니티 경험들은 현재의 WASM을 사용하는 데 어려움을 겪는 것을 강조하며 처음에 느꼈던 흥분을 식게 만드는 반대 의견을 제공했습니다.\n\n# 변화의 시작\n\nWASM에 대한 실망을 극복하면서, Uber에서 개발한 h3 라이브러리를 찾았을 때 판별적인 순간이 찾아왔습니다. 이 라이브러리는 여러 언어(C, Python, Java, JavaScript)로 구현된 버전을 포함하고 있으며, h3-js는 C에서 컴파일된 WASM을 사용하는 JavaScript와 WASM을 연결하기 위해 Emscripten을 사용합니다.\n\n## h3 이해하기\n\n\n\nh3는 지리 공간 색인을 위해 설계되었습니다. 이는 좌표를 육각형 그리드에 색인화하는 방법을 제공합니다. 이 시스템은 대규모 지리 공간 데이터셋을 가진 애플리케이션에 특히 유용합니다. 저는 자주 쓰는 한 가지 함수는 `latLngToCell`인데, 이 함수는 위도와 경도 좌표를 육각형 그리드 셀 식별자로 변환해줍니다.\n\n## 성능 비교\n\nh3-js의 성능을 측정하기 위해 C 구현과 JavaScript 버전을 WASM을 사용하여 벤치마크했습니다. 다행히, 두 레포지토리에 이미 벤치마킹 프로그램이 포함되어 있었습니다. 여기 내 로컬 M1 MacBookPro에서의 결과입니다:\n\n# WASM의 기능 탐색\n\n\n\n의완 놀라운 h3-js 결과에 영감을 받아 WASM의 능력을 더 파헤치기로 결정했어요. Collatz 추측을 사용하여 JavaScript와 FFI의 성능을 비교해봤어요.\n\n## Collatz 추측이란?\n\nCollatz 추측은 “3n + 1 문제\"로 알려진 수학적 가설로, 다음과 같이 정의된 순서를 포함합니다:\n\n- 양의 정수 n으로 시작합니다.\n- 만약 n이 짝수이면 2로 나눕니다.\n- 만약 n이 홀수이면 3을 곱하고 1을 더합니다.\n- n이 1이 될 때까지 이 과정을 반복합니다.\n\n\n\n![Image](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_3.png)  \n\n가설은 시작하는 n 값이 무엇이든, 시퀀스는 항상 결국 1에 도달한다고 주장합니다.\n\n## JS, FFI 및 WASM에서 Collatz 가설\n\n성능을 비교하기 위해 가설을 순수 JavaScript로 구현했고, Rust 함수를 호출하기 위해 FFI를 사용했으며 WASM에서 직접 구현했습니다. 그리고 입력값으로 n = 670617279을 사용했는데, 이는 1에 도달하는 데 986단계가 필요합니다.\n\n\n\n- JavaScript\n\n```js\nfunction collatzSteps(n) {\n    let counter = 0;\n    while (n !== 1) {\n      if (n % 2 === 0) {\n        n /= 2;\n      } else {\n        n = 3 * n + 1;\n      }\n      counter++;\n    }\n    return counter;\n  }\n```\n\n- Rust (FFI) and Rust (WASM)\n\n```js\npub fn collatz_steps(mut n: u64) -\u003e u64 {\n    let mut counter = 0;\n    while n != 1 {\n      if n % 2 == 0 {\n        n /= 2;\n      } else {\n        n = 3 * n + 1;\n      }\n      counter += 1;\n    }\n    return counter;\n  }\n```\n\n\n\n더 많은 세부 정보를 원하시면 제 리포지토리를 확인해주세요. 다음은 M1 MacBook Pro와 관련한 벤치마크입니다:\n\n이러한 결과는 WASM이 연산 집중적인 작업에 특히 네이티브 JavaScript 및 FFI보다 우월한 성능을 보일 수 있다는 것을 입증했습니다.\n\n# WASM 성능에 대한 깊은 탐구\n\nh3-js와 콜라츠 추측에서의 WASM의 뛰어난 성능을 보고 나니, WASM에 대해 처음에 이해한 것 이상의 가능성이 있다는 것이 분명해졌습니다.\n\n\n\n## WASM이 FFI와 다른 점\n\nWASM의 효율성을 이해하는 핵심은 낮은 수준의 이진 명령 형식으로 설계된 것에 있습니다. 이것은 플랫폼에 의존하지 않을 뿐만 아니라 실행 속도와 조밀성을 최적화했습니다. 이는 FFI와 달리 높은 오버헤드가 발생할 수 있는데, 이는 실행 컨텍스트 간 데이터 매샬링과 다른 메모리 모델 처리로 인해 발생할 수 있습니다. 이 구성은 다음을 통해 일반적인 FFI 오버헤드를 최소화합니다:\n\n- 메모리 관리가 직선적이고 일관적임: WASM은 단일 연속 메모리 블록을 사용하여 호스트 환경과의 인터페이스를 단순하게 만듭니다. 이는 전통적인 FFI 환경에서 메모리 관리와 관련된 비용을 줄입니다.\n- 실행에 최적화된 이진 형식: WASM 이진 형식은 현대 JIT(Just-In-Time) 컴파일러에 의해 효율적으로 디코딩 및 실행되도록 설계되었습니다. 이는 일반적인 런타임 해석 벌칙을 따르지 않아도 네이티브 기계 코드 속도에 근접한 성능을 제공합니다.\n\n## WASM의 백엔드 사용 사례\n\n\n\nh3-js 라이브러리 조사 결과와 내 Collatz 추측 실험으로 인해 WASM의 응용 프로그램 랜드스케이프에 대한 시각이 변화했습니다:\n\n- Frontend보다 Backend: WASM은 초반에는 웹 애플리케이션 잠재력으로 알려졌지만, 그 강점은 특히 백엔드 및 브라우저 이외의 환경에서 데이터 처리, 과학적 계산 및 실시간 미디어 인코딩/디코딩과 같은 공통 계산 중심 환경에서 두드러집니다.\n- Edge Computing: WASM은 엣지 컴퓨팅 애플리케이션에 이상적으로 적합하며, 데이터 소스 근처에서 코드를 실행함으로써 응답 시간을 크게 개선하고 대역폭 사용량을 줄일 수 있습니다.\n\n# WASM을 활용한 ULID 생성 최적화\n\nWASM의 성능을 활용한 실용적인 응용 프로그램 중 하나는 Universally Unique Lexicographically Sortable Identifiers (ULID)를 생성하는 것입니다. ULID는 UUID와 유사한 목적을 가지고 있지만 정렬 가능합니다. 타임스탬프와 무작위 구성 요소로 구성되어 있으며, 고유성과 사전식 정렬 가능성을 보장하기 위해 인코딩되어 있습니다. 이로 인해 정렬 순서와 고유성이 중요한 분산 시스템에서 특히 유용합니다.\n\n\n\n## 40배 성능 향상\n\n기존 JavaScript ULID 생성 구현을 Rust로 변환하여 WASM으로 컴파일했더니, 상당한 성능 향상을 이뤘습니다. 원래 JavaScript 버전보다 약 40배 빠릅니다.\n\n이 초기 번역은 간단했지만, 성능을 더 최적화하기 위해 섬세한 방법이 이어졌습니다.\n\n## 이후 최적화\n\n\n\n먼저, 성능 향상은 초기에 약 10배 빨라졌습니다. 그러나 러스트 구현에서 여러 최적화를 통해 이를 40배로 높였습니다. 이 높은 성능 향상에 기여한 주요 기술들은 WASM에 특정되지는 않지만 다음과 같습니다:\n\n1. 효율적인 데이터 구조 사용\n\n구현에 사용되는 데이터 구조를 최적화하는 것, 즉 동적으로 크기를 조절하는 대신 미리 할당 용량을 갖춘 벡터와 같은 데이터 구조를 사용하는 것은 메모리 할당을 최소화하고 성능이 빈번한 메모리 작업에 의해 방해받지 않도록 보장했습니다.\n\n```rust\n// 이전\nString::new();\n// 이후\nString::with_capacity(len);\n```\n\n\n\n2. 불필요한 변환과 메모리 할당 피하기\n\n원래의 러스트 구현은 계산 비용이 많이 드는 문자열 및 문자 변환을 포함했습니다. 데이터 처리 방식을 최적화하고 메모리 할당을 줄이는 것으로 성능이 크게 향상되었습니다. 예를 들어, 가능한 경우에 문자열이나 문자로 변환하는 대신 직접 바이트 배열을 사용하는 것이 오버헤드를 줄이는 데 도움이 되었습니다.\n\n```js\n// 이전\nconst ENCODING: \u0026str = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\n...\nlet mut chars = Vec::with_capacity(len);\nfor index in 0..len {\n    chars.push(ENCODING.chars().nth(index).unwrap());\n}\n\n// 이후\nconst ENCODING: \u0026str = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst ENCODING_BYTES: \u0026[u8] = ENCODING.as_bytes();\n...\nlet mut chars = Vec::with_capacity(len);\nfor index in 0..len {\n    chars.push(ENCODING_BYTES[index] as char);\n}\n```\n\n\n\n함수 호출간에 반복적으로 사용되는 값, 예를 들어 인코딩 길이의 제곱과 같은 값을 미리 계산하고 캐싱함으로써 계산 부하를 크게 줄였습니다. 이는 `decode_time`과 같은 함수에 특히 효과적이었습니다. 이 함수들은 반복적이고 예측 가능한 작업들이 많았기 때문이죠.\n\n```js\n// Before\nconst ENCODING_LEN: usize = 32;\nconst TIME_LEN: usize = 10;\n...\nfor i in 0..TIME_LEN {\n    time += i as f64 * (ENCODING_LEN as u64).pow(index as u32) as f64;\n}\n\n// After\nconst ENCODING_LEN: usize = 32;\nconst POWERS: [f64; 10] = [1.0, 32.0, ..., 35184372088832.0];\n...\nfor i in 0..TIME_LEN {\n    time += i as f64 * POWERS[index];\n}\n```\n\n# 결론\n\nWASM을 활용한 ULID 생성의 최적화는 WASM의 성능을 이해하고 활용함으로써 실제 응용 프로그램에서 상당한 성능 향상을 이끌어냈습니다. 이 사례 연구는 성능과 효율이 중요한 백엔드 시스템 뿐만 아니라 웹에서도 툴체인이 발전함에 따라 WASM이 효과적으로 활용될 수 있는 한 예입니다.\n\n\n\n현재, 대규모 이진 크기의 문제로 WASM 사용이 프론트엔드 애플리케이션에서 다운로드 및 실행 속도가 중요한 경우에 제한되는 도전 과제가 있습니다. 그러나 이는 영구적인 제한이 아니라 현재의 장애물입니다. WASM 툴체인이 트리 쉐이킹 및 바이너리 출력 최적화와 같은 기술에서 더 발전함에 따라 이진 크기가 크게 축소될 것으로 예상됩니다.\n\n웹에서의 WASM의 미래는 밝습니다. 툴체인이 발전하고 더 작고 효율적인 바이너리를 생성하는 능력을 향상함에 따라 WASM은 웹 성능과 기능을 혁신할 잠재력이 커집니다. 이것은 백엔드 애플리케이션을 향상시키는 것뿐만 아니라 복잡한 애플리케이션이 브라우저 환경에서 배포되고 실행되는 방식을 철저히 변화시킬 수 있어, 원시 환경과 동등하게 효율적이고 강력하게 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png"},"coverImage":"/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png","tag":["Tech"],"readingTime":10},{"title":"프론트엔드 주간 다이제스트 362 2024년 5월 6일5월 12일","description":"","date":"2024-05-14 12:23","slug":"2024-05-14-FrontendWeeklyDigest362612May2024","content":"\n\n![이미지](/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png)\n\n# 웹 개발\n\n- HTML 툴팁에 Popover API 사용하기\n- Figma의 모바일 엔진 진화: TypeScript로의 Figma 여정\n- Google Gemini를 활용한 채팅 통합 구축\n- Frontend 용어 분석: Jamstack에 대해\n- 모바일 핀테크 API 작업의 어려움 극복하기\n- 의도적인 렌더링 차단\n- React Three Fiber로 3D 텍스트 왜곡 효과 탐색\n- Target=_blank은 rel=noopener를 의미합니다\n\n- 도구\n  - 5개의 노드 버전 관리자 비교 - 어떤 것이 적합한가요?\n  - Gulp 개발자 설문조사 소개\n\n- 접근성\n  - 왜 웹 접근성에 크게 관심을 가지고 있고 당신도 해야 할 이유\n  - 유럽 접근성 법안 (EAA) 소개\n  - 강조된 텍스트에 대한 간단한 주의 문단\n\n\n\n# CSS\n\n- 섹션 기반 스크롤 진행 표시기에 CSS 스크롤-드리븐 애니메이션 사용하기\n- CSS 앵커 위치 지정 API 소개\n- CSS 모양 만드는 현대 가이드\n- 왜 더 이상 CSS를 최소화하는 것에 대해 이야기하지 않을까요?\n\n# JavaScript\n\n- JavaScript에 대한 5가지 기본적인 것, 비 JavaScript 중심 웹 디자이너에 도움이 될 것\n- innerHTML에 대한 새로운 대안\n- 글로벌 변수 수정이 해로운 이유\n- JavaScript에서 완벽한 깊은 동등성 얻는 방법\n\n\n\n- 리액트\n\t- [리액트 개발자 도구 사용 방법 - 예제를 통한 설명](#)\n\t- [리액트 서버 컴포넌트(RSCs)의 범죄 조사](#)\n\t- [왜 리액트 쿼리를 사용해야 하는가?](#)\n\t- [코드 400줄로 나만의 리액트.js 만들기](#)\n\t- [리액트를 위한 헤들리스 UI v2.0](#)\n\t- [RedwoodJS에서 리액트 서버 컴포넌트 활용하기](#)\n\t- [반응형 디자인을 위해 리사이즈 옵저버 API 사용하기](#)\n\n- 앵귤러\n\t- [앵귤러에서 미뤄진 뷰에서의 번들 크기 개선](#)\n\t- [앵귤러의 변경 감지에 대한 신비를 해소하다: 철저한 가이드](#)\n\t- [앵귤러 뷰 엔진 vs Ivy: 철저한 가이드](#)\n\t- [앵귤러: DOM 살포화](#)","ogImage":{"url":"/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png"},"coverImage":"/assets/img/2024-05-14-FrontendWeeklyDigest362612May2024_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 애플리케이션에서 원격 상태 관리를 위한 RTK Query 시작하기","description":"","date":"2024-05-14 12:20","slug":"2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications","content":"\n\n현대 웹 애플리케이션에서 상태를 관리하는 것은 종종 복잡하고 번거로울 수 있습니다, 특히 API 요청과 같은 비동기 데이터를 처리할 때. 그러나 Redux Toolkit Query (RTK Query)를 사용하면 데이터 가져오기, 캐싱 및 상태 관리가 간소화되어 개발자들이 더 적은 코드로 성능 최적화된 애플리케이션을 작성할 수 있습니다. 이 기사에서는 RTK Query를 사용하여 Todo 애플리케이션 설정하는 방법을 안내하며, 그 강력함과 효율성을 소개하겠습니다.\n\n# 프로젝트 구조 설정하기\n\n먼저 React 프로젝트를 구성하여 시작하고 Redux Toolkit 및 RTK Query가 설치되어 있는지 확인하세요. 프로젝트 구조에는 주 진입 파일, API 서비스 슬라이스 및 Todo 컴포넌트가 포함됩니다.\n\n```js\n//main.jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App.jsx';\nimport { ApiProvider } from \"@reduxjs/toolkit/query/react\";\nimport apiSlice from \"./feature/todo/todoAPI/apiSlice.js\";\n\n// 루트 엘리먼트를 설정하고 전체 애플리케이션을 RTK Query용으로 ApiProvider로 랩합니다\nReactDOM.createRoot(document.getElementById('root')).render(\n  \u003cReact.StrictMode\u003e\n    \u003cApiProvider api={apiSlice}\u003e\n        \u003cApp /\u003e\n    \u003c/ApiProvider\u003e\n  \u003c/React.StrictMode\u003e,\n);\n```\n\n\n\n# API 서비스 슬라이스 구성하기\n\nAPI 슬라이스는 RTK Query를 사용하여 할 일을 가져오고 추가하고 업데이트하고 삭제하는 방법을 정의하는 곳입니다.\n\n```js\n//apiSlice.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst todoApi = createApi({\n    reducerPath: \"api\", // API 상태 슬라이스를 위한 고유한 키\n    baseQuery: fetchBaseQuery({ baseUrl: \"http://localhost:5050\" }), // 가져오기 로직을 처리하는 기본 쿼리\n    tagTypes: [\"TODOS\"], // 자동 캐시 다시 가져오기를 위한 태그\n    endpoints: (builder) =\u003e ({\n        getTodos: builder.query({ // 할 일을 가져오는 엔드포인트\n            query: () =\u003e \"/todos\",\n            providesTags: [\"TODOS\"]\n        }),\n        addTodo: builder.mutation({ // 새로운 할 일 추가하는 엔드포인트\n            query: (todo) =\u003e ({\n                url: \"/todos\",\n                method: \"POST\",\n                body: todo\n            }),\n            invalidatesTags: [\"TODOS\"]\n        }),\n        updateTodo: builder.mutation({ // 기존 할 일을 업데이트하는 엔드포인트\n            query: (todo) =\u003e ({\n                url: `/todos/${todo.id}`,\n                method: \"PATCH\",\n                body: todo\n            }),\n            invalidatesTags: [\"TODOS\"]\n        }),\n        deleteTodo: builder.mutation({ // 할 일을 삭제하는 엔드포인트\n            query: ({ id }) =\u003e ({\n                url: `/todos/${id}`,\n                method: \"DELETE\",\n            }),\n            invalidatesTags: [\"TODOS\"]\n        })\n    })\n});\n\nexport const { useGetTodosQuery, useAddTodoMutation, useUpdateTodoMutation, useDeleteTodoMutation } = todoApi;\n\nexport default todoApi;\n```\n\n# 할 일 컴포넌트 구성하기\n\n\n\nTodo 컴포넌트에서 할 일을 표시하고 관리하는 기능을 구현해보세요.\n\n```js\n//TodoApp.jsx\nimport { useState } from 'react';\nimport styles from './TodoApp.module.css';\nimport { useAddTodoMutation, useDeleteTodoMutation, useGetTodosQuery, useUpdateTodoMutation } from \"./todoAPI/apiSlice.js\";\n\nfunction TodoApp() {\n    const [task, setTask] = useState('');\n    const { data: todos, isLoading, isError, isSuccess, error } = useGetTodosQuery();\n    const [addTodo] = useAddTodoMutation();\n    const [updateTodo] = useUpdateTodoMutation();\n    const [deleteTodo] = useDeleteTodoMutation();\n\n    // 할 일 추가를 처리하는 함수\n    function addTodoHandler() {\n        const newTodo = { id: Math.random(), task: task, isCompleted: false };\n        addTodo(newTodo);\n        setTask('');\n    }\n\n    // 할 일 완료 상태 전환을 처리하는 함수\n    function toggleCompletion(todo) {\n        updateTodo({ ...todo, isCompleted: !todo.isCompleted });\n    }\n\n    // 할 일 삭제를 처리하는 함수\n    function deleteTodoHandler(todo) {\n        deleteTodo(todo);\n    }\n\n    return (\n        \u003cdiv className={styles.container}\u003e\n            \u003ch1 className={styles.title}\u003e할 일 목록\u003c/h1\u003e\n            \u003cinput\n                type=\"text\"\n                placeholder=\"새로운 작업 추가\"\n                value={task}\n                onChange={(e) =\u003e setTask(e.target.value)}\n                className={styles.todoInput}\n            /\u003e\n            \u003cbutton className={styles.button} onClick={addTodoHandler}\u003e할 일 추가\u003c/button\u003e\n            \u003cul className={styles.todoList}\u003e\n                {isLoading \u0026\u0026 \u003cp\u003e로딩 중...\u003c/p\u003e}\n                {todos \u0026\u0026 \u003c\u003e\n                    {todos.map((todo) =\u003e (\n                        \u003cli key={todo.id} className={styles.todoItem}\u003e\n                            \u003cspan\n                                className={styles.todoTask}\n                                style={{ textDecoration: todo.isCompleted ? 'line-through' : 'none' }}\n                                onClick={() =\u003e toggleCompletion(todo)}\n                            \u003e\n                              {todo.task}\n                            \u003c/span\u003e\n                            \u003cbutton className={`${styles.button} ${styles.delete}`} onClick={() =\u003e deleteTodoHandler(todo)}\u003e삭제\u003c/button\u003e\n                        \u003c/li\u003e\n                    ))}\n                \u003c/\u003e}\n            \u003c/ul\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default TodoApp;\n```\n\n참고: 코드샌드박스 링크에는 컴포넌트를 스타일링하는 CSS 파일도 제공됩니다.\n\n# 마무리\n\n\n\nRTK Query는 Redux 애플리케이션에서 서버 측 데이터를 효율적으로 관리할 수 있는 강력한 솔루션을 제공합니다. 데이터 가져오기 및 상태 관리 로직을 추상화함으로써, 개발자들이 기능 구축에 집중할 수 있도록 도와줍니다. React 개발자들에게 꼭 필요한 도구가 될 수 있습니다.\n\n[여기를 클릭하여 데모 사이트에서 확인해보세요!](https://codesandbox.io/p/devbox/rtk-query-r8ttsh?embed=1\u0026file=%2Fsrc%2Ffeatures%2Ftodo%2FtodoAPI%2FapiSlice.js)","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithRTKQueryforManagingRemoteStateinReactApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"기본을 정복하라 React로 넘어가기 전에 배워야 할 10가지 필수 JavaScript 주제","description":"","date":"2024-05-14 12:18","slug":"2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact","content":"\n\n![이미지](/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png)\n\n자바스크립트는 현대 웹 개발의 기초가 된 다재다능하고 동적인 프로그래밍 언어입니다. React, Angular, Vue.js와 같은 인기있는 프레임워크들이 등장함에 따라 특정 프레임워크를 배우기에 싫증이 나게 되기 쉽습니다. 그러나 점프하기 전에 자바스크립트 기초를 확실히 이해하는 것이 중요합니다. 이 블로그 포스트에서는 React 또는 다른 자바스크립트 프레임워크로 넘어가기 전에 반드시 숙달해야 할 핵심 주제를 살펴보겠습니다.\n\n# 1. 변수, 데이터 유형 및 연산자\n\n자바스크립트의 변수, 데이터 유형 및 연산자의 기초를 이해하는 것은 어떤 프로그래밍 작업에도 꼭 필요합니다. 이에는 다음이 포함됩니다:\n\n\n\n- 변수 선언 (let, const, var)\n- 데이터 유형 (원시, 복합, null, undefined)\n- 유형 강제 변환 및 변환\n- 연산자 우선순위 및 결합성\n\n코드 예시:\n\n\n# 변수 선언:\n\nJavaScript\n\n\n\n\n```js\nlet name = 'John';\nconst PI = 3.14;\nvar age = 30;\n```\n\n# 데이터 유형:\n\n자바스크립트\n\n```js\nlet isAdmin = true; // 불리언\nlet num = 42; // 숫자\nlet greeting = 'Hello'; // 문자열\n```\n\n\n\n# 형 변환:\n\n자바스크립트\n\n```js\nlet num = '42'; // 문자열\nconsole.log(num * 2); // 84 출력 (숫자로 강제 변환)\n```\n\n# 연산자 우선순위:\n\n\n\n자바스크립트\n\n```js\nlet result = 2 + 3 * 4; // 결과는 14가 나옵니다 (곱셈이 덧셈보다 높은 우선순위를 갖습니다)\n```\n\n## 2. 제어 구조 및 함수\n\n제어 구조 및 함수는 자바스크립트 프로그래밍의 기본 요소입니다. 다음을 확실히 이해해두세요:\n\n\n\n- 조건문 (if/else, switch)\n- 반복문 (for, while, do-while)\n- 함수 (선언, 표현식, 화살표 함수)\n- 함수 매개변수 및 반환 유형\n\n코드 예시:\n\n```javascript\n// 조건문:\n\n```\n\n\n\n```javascript\nlet age = 25;\nif (age \u003e= 18) {\n  console.log('당신은 성인입니다.');\n} else {\n  console.log('당신은 미성년자입니다.');\n}\n```\n\n# 반복문:\n\nJavaScript\n\n```javascript\nfor (let i = 0; i \u003c 5; i++) {\n  console.log(i);\n}\n```\n\n\n\n# Functions:\n\n자바스크립트\n\n```js\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\ngreet('John'); // \"Hello, John!\"을 출력합니다\n```\n\n# 화살표 함수:\n\n\n\n자바스크립트\n\n```js\nlet double = x =\u003e x * 2;\nconsole.log(double(5)); // 10을 출력합니다.\n```\n\n## 3. 객체지향 프로그래밍 (OOP) 개념\n\n자바스크립트는 객체지향 언어이며, OOP 원칙을 이해하는 것이 중요합니다.\n\n\n\n- 객체와 속성\n- 생성자와 프로토타입\n- 상속과 다형성\n- 캡슐화와 추상화\n\n코드 예시:\n\n# 객체와 속성:\n\nJavaScript\n\n\n\n```js\nlet person = {\n  name: '존',\n  age: 30,\n  greet: function() {\n    console.log(`안녕, 내 이름은 ${this.name}이야!`);\n  }\n};\nperson.greet(); // \"안녕, 내 이름은 존이야!\"\n\n# 생성자와 프로토타입:\n\nJavaScript\n\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.greet = function() {\n  console.log(`안녕, 내 이름은 ${this.name}이야!`);\n};\nlet john = new Person('존', 30);\njohn.greet(); // \"안녕, 내 이름은 존이야!\"\n\n\n\n# 상속:\n\n자바스크립트\n\nfunction Employee(name, age, department) {\n  Person.call(this, name, age);\n  this.department = department;\n}\nEmployee.prototype = Object.create(Person.prototype);\nlet employee = new Employee('Jane', 25, '마케팅');\nemployee.greet(); // \"안녕하세요, 제 이름은 Jane입니다!\"\n\n# 4. DOM 조작과 이벤트\n\n\n\n문서 객체 모델(DOM)은 웹 개발의 기바입니다. 다음을 배워보세요:\n\n- DOM 요소 선택 및 조작하기\n- 이벤트 처리하기 (클릭, 호버, 제출 등)\n- 이벤트 위임과 버블링 사용하기\n\n코드 예시:\n\n- DOM 요소 선택 및 조작하기:\n\n\n\nJavaScript\n\nlet heading = document.querySelector('h1');\nheading.textContent = '새 헤딩';\n\n# 이벤트 처리:\n\nJavaScript\n\n\n\nlet button = document.querySelector('button');\nbutton.addEventListener('click', function() {\n  console.log('버튼이 클릭되었습니다!');\n});\n\n# 이벤트 위임:\n\nJavaScript\n\nlet ul = document.querySelector('ul');\nul.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    console.log('리스트 아이템이 클릭되었습니다!');\n  }\n});\n\n\n\n# 5. 비동기 프로그래밍과 콜백\n\n자바스크립트에서 비동기 프로그래밍은 매우 중요합니다. 특히 외부 데이터나 API를 다룰 때:\n\n- 콜백과 고차 함수를 이해하세요.\n- 프로미스 및 async/await 구문에 대해 배우세요.\n- 오류 및 예외 상황을 다루세요.\n\n코드 예시:\n\n\n\n## 콜백:\n\n자바스크립트\n\nfunction loadData(callback) {\n  setTimeout(function() {\n    callback(['John', 'Jane', 'Bob']);\n  }, 2000);\n}\nloadData(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n\n## 프로미스:\n\n\n\nJavaScript\n\nfunction loadData() {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(['John', 'Jane', 'Bob']);\n    }, 2000);\n  });\n}\nloadData().then(function(data) {\n  console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n});\n\n# Async/await:\n\nJavaScript\n\n\n\nasync function loadData() {\n  try {\n    let data = await fetch('(링크 제공 불가)');\n    console.log(data); // 출력: [\"John\", \"Jane\", \"Bob\"]\n  } catch (error) {\n    console.error(error);\n  }\n}\nloadData();\n\n# 6. JavaScript 객체 메소드와 배열\n\n필수 객체 메소드와 배열 조작 기술을 익혀보세요:\n\n- 객체 메소드 (keys, values, entries 등)\n- 배열 메소드 (map, filter, reduce 등)\n- 배열 구조 분해 및 전개\n\n\n\n코드 예시:\n\n# 객체 메소드:\n\n자바스크립트\n\nlet person = { name: 'John', age: 30 };\nconsole.log(Object.keys(person)); // 출력: [\"name\", \"age\"]\nconsole.log(Object.values(person)); // 출력: [\"John\", 30]\n\n\n\n# 배열 메소드:\n\n자바스크립트\n\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(numbers.map(x =\u003e x * 2)); // 결과: [2, 4, 6, 8, 10]\nconsole.log(numbers.filter(x =\u003e x % 2 === 0)); // 결과: [2, 4]\n\n# 배열 해체 및 전개:\n\n\n\n자바스크립트\n\nlet arr = [1, 2, 3];\nlet [first, ...rest] = arr;\nconsole.log(first); // 결과는 1\nconsole.log(rest); // 결과는 [2, 3]\n\nlet newArr = [...arr, 4, 5];\nconsole.log(newArr); // 결과는 [1, 2, 3, 4, 5]\n\n# 7. 클로저와 'this' 키워드\n\n\n\n클로저와 ‘this’ 키워드는 조금 까다로울 수 있지만, 이해하는 것이 중요합니다:\n\n- 클로저와 렉시컬 스코핑\n- ‘this’ 키워드와 컨텍스트 바인딩\n- bind, call, apply 메소드의 사용법\n\n코드 예시:\n\n# 클로저:\n\n\n\nJavaScript\n\nfunction outer() {\n  let x = 10;\n  function inner() {\n    console.log(x); // 10을 출력합니다\n  }\n  return inner;\n}\nlet innerFunc = outer();\ninnerFunc(); // 10을 출력합니다\n\n# 'this' 키워드:\n\nJavaScript\n\n\n\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}!`);\n};\nlet john = new Person('John');\njohn.greet(); // 출력: \"Hello, my name is John!\"\n\n# Bind, call, and apply:\n\nJavaScript\n\nfunction greet(name) {\n  console.log(`Hello, ${name}!`);\n}\nlet greetJohn = greet.bind(null, 'John');\ngreetJohn(); // 출력: \"Hello, John!\"\n\n\n\nlet person = { name: 'Jane' };\ngreet.call(person, person.name); // 출력: \"안녕, Jane!\"\nlet numbers = [1, 2, 3];\nconsole.log(Math.max.apply(null, numbers)); // 출력: 3\n\n# 8. 오류 처리 및 디버깅\n\n오류를 처리하고 코드를 효과적으로 디버깅하는 방법을 배워보세요:\n\n- 오류 객체와 스택 추적 이해하기\n- console.log, debugger, 그리고 브라우저의 개발자 도구 사용하기\n- try-catch 블록 및 오류 처리 전략 구현하기\n\n\n\n코드 예시:\n\n## 오류 처리:\n\nJavaScript\n\ntry {\n  let x = 10 / 0;\n} catch (error) {\n  console.error(error); // \"Error: Division by zero\"이 출력됩니다.\n}\n\n\n\n# 디버깅:\n\nJavaScript\n\nconsole.log('Hello'); // \"Hello\"를 출력합니다\ndebugger; // 실행을 일시 중단하고 DevTools를 엽니다\n\n# 9. JavaScript Best Practices and Code Organization\n\n\n\n깨끗하고 유지보수 가능한 코드를 작성하기 위해 최상의 관행을 따르고 코드베이스를 조직화하세요:\n\n- 모듈식 코드와 임포트 사용\n- 네이밍 규칙과 코딩 표준 준수\n- 코드 분할과 트리 쉐이킹 구현\n\n코드 예시:\n\n\n# 모듈식 코드:\n\n\n\nJavaScript\n\n// greet.js\nfunction greet(name) {\n  console.log(`안녕, ${name}!`);\n}\nexport { greet };\n\nJavaScript\n\n// main.js\nimport { greet } from './greet.js';\ngreet('John'); // 출력 결과: \"안녕, John!\"\n\n\n\n# 네이밍 규칙 및 코딩 표준:\n\nJavaScript\n\n// 일관된 네이밍 규칙을 따르세요\nlet firstName = 'John';\nlet lastName = 'Doe';\n\n// 일관된 들여쓰기와 공백을 사용하세요\nif (true) {\n  console.log('Hello');\n}\n\n\n\n# 코드 분할과 트리 쉐이킹:\n\n자바스크립트\n\n// Webpack 또는 Rollup을 사용하여 코드를 작은 조각으로 분할하고\n// 사용하지 않는 코드를 제거하세요 (트리 쉐이킹)\n\n# 10. 브라우저 호환성 및 웹 표준\n\n\n\n여러 브라우저에서 코드가 작동하도록 보장하고 웹 표준을 따르세요:\n\n- 브라우저의 특이점과 불일치를 이해하세요\n- 기능 감지와 폴리필 사용하기\n- 웹 표준과 접근성 가이드라인 준수하기\n\n코드 예시:\n\n\n# 기능 감지:\n\n\n\n\n자바스크립트\n\nif (typeof window.addEventListener === 'function') {\n  // 이벤트 리스너 추가\n} else {\n  // 대체 방법 사용\n}\n\n## 폴리필:\n\n자바스크립트\n\n\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement) {\n    // Polyfill 구현\n  };\n}\n\n# 웹 표준과 접근성:\n\nJavaScript\n\n// 시맨틱 HTML 요소 사용\n\u003cheader\u003e헤더\u003c/header\u003e\n\u003cnav\u003e네비게이션\u003c/nav\u003e\n\u003cmain\u003e주요 콘텐츠\u003c/main\u003e\n\n\n\n// 접근성을 위해 ARIA 속성을 사용하세요\n\u003cbutton aria-label=\"제출\"\u003e제출\u003c/button\u003e\n\n추가 자료\n\n- MDN Web Docs: JavaScript 문서 및 튜토리얼에 대한 포괄적인 자료\n- W3Schools: 웹 개발 튜토리얼 및 참고 자료가 있는 인기 있는 웹사이트\n- JavaScript Subreddit: JavaScript와 웹 개발에 대한 토론을 하는 커뮤니티 주도 포럼\n- Udemy 및 Coursera 강좌: JavaScript와 웹 개발 학습을 위한 온라인 강좌 및 튜토리얼\n\n# 결론\n\n\n\n\n자바스크립트의 기본을 완벽히 이해하는 것은 견고하고 확장 가능하며 유지보수가 쉬운 웹 애플리케이션을 구축하는 데 중요합니다. 이 블로그 포스트에서 다루는 주요 주제를 이해하면 더 고급 개념과 React, Angular, Vue.js와 같은 프레임워크에 대처할 준비가됩니다. 유능한 자바스크립트 개발자로 발전하기 위해 연습하고 실험하며 계속 학습해야합니다. 즐겨 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringtheBasics10EssentialJavaScriptTopicstoLearnBeforeMovingtoReact_0.png","tag":["Tech"],"readingTime":8}],"page":"115","totalPageCount":156,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"115"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>